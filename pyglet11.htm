<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
        "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html>
<head>
<title>Multimediální knihovna Pyglet: podpora pro tvorbu modelů kvadrik, disků a kruhových výsečí přes GLU</title>
<meta name="Author" content="Pavel Tisnovsky" />
<meta name="Generator" content="vim" />
<meta http-equiv="content-type" content="text/html; charset=utf-8" />
<style type="text/css">
         body {color:#000000; background:#ffffff;}
         h1  {font-family: arial, helvetica, sans-serif; color:#ffffff; background-color:#c00000; text-align:center; padding-left:1em}
         h2  {font-family: arial, helvetica, sans-serif; color:#ffffff; background-color:#0000c0; padding-left:1em; text-align:left}
         h3  {font-family: arial, helvetica, sans-serif; color:#000000; background-color:#c0c0c0; padding-left:1em; text-align:left}
         h4  {font-family: arial, helvetica, sans-serif; color:#000000; background-color:#e0e0e0; padding-left:1em; text-align:left}
         a   {font-family: arial, helvetica, sans-serif;}
         li  {font-family: arial, helvetica, sans-serif; color:#000000; text-align:justify; width:450px;}
         ol  {font-family: arial, helvetica, sans-serif; color:#000000; text-align:justify; width:450px;}
         ul  {font-family: arial, helvetica, sans-serif; color:#000000; text-align:justify; width:450px;}
         p   {font-family: arial, helvetica, sans-serif; color:#000000; text-align:justify;}
         pre {background:#e0e0e0}
</style>
</head>

<body>

<h1>Multimediální knihovna Pyglet: podpora pro tvorbu modelů kvadrik, disků a kruhových výsečí přes GLU</h1>

<h3>Pavel Tišnovský</h3>

<p></p>

<h1>Úvodník</h1>

<p>V&nbsp;knihovně Pyglet neexistuje žádná přímá podpora pro vykreslení složitějších těles, nabízeno je &bdquo;pouze&ldquo; rozhraní ke knihovnám OpenGL a GLU. Ale právě existence rozhraní pro knihovnu GLU (OpenGL Utility Library) nám umožní do trojrozměrných scén přidat základní 3D tělesa (koule, válce, kužely), pomocné 2D tvary (disky, mezikruží a kruhové výseče) a v&nbsp;případě potřeby i NURB (Non-uniform rational B-spline) plochy.</p><!--more-->



<h2>Obsah</h2>

<p><a href="#k01">1. Podpora pro tvorbu modelů kvadrik, disků a kruhových výsečí v&nbsp;knihovně GLU</a></p>
<p><a href="#k02">2. Co značí pojem &bdquo;kvadrika&ldquo;?</a></p>
<p><a href="#k03">3. Postup pro vytvoření a zobrazení kvadrik při použití GLU</a></p>
<p><a href="#k04">4. Vytvoření trojrozměrného modelu koule</a></p>
<p><a href="#k05">5. První demonstrační příklad: vykreslení modelu koule</a></p>
<p><a href="#k06">6. Vytvoření modelu válce nebo kužele</a></p>
<p><a href="#k07">7. Druhý demonstrační příklad: vykreslení modelu válce</a></p>
<p><a href="#k08">8. Třetí demonstrační příklad: vykreslení modelu kužele</a></p>
<p><a href="#k09">9. Vytvoření disku či mezikruží</a></p>
<p><a href="#k10">10. Čtvrtý demonstrační příklad: vykreslení mezikruží</a></p>
<p><a href="#k11">11. Vytvoření kruhové výseče</a></p>
<p><a href="#k12">12. Pátý demonstrační příklad: vykreslení kruhové výseče</a></p>
<p><a href="#k13">13. Změna parametrů vykreslovaných kvadrik</a></p>
<p><a href="#k14">14. Šestý demonstrační příklad: vykreslení koule s&nbsp;interaktivní změnou všech parametrů modelu</a></p>
<p><a href="#k15">15. Repositář s&nbsp;demonstračními příklady</a></p>
<p><a href="#k16">16. Funkce knihovny GLU popsané v&nbsp;tomto článku</a></p>
<p><a href="#k17">17. Odkazy na Internetu</a></p>



<p><a name="k01"></a></p>
<h2 id="k01">1. Podpora pro tvorbu modelů kvadrik, disků a kruhových výsečí v&nbsp;knihovně GLU</h2>

<p>Důležitá úvodní poznámka: v&nbsp;moderním OpenGL se setkáme s&nbsp;jiným přístupem k&nbsp;vykreslování trojrozměrných těles, v&nbsp;němž se používá programovatelná vykreslovací pipeline a unifikovaný formát vstupních dat, což mimo jiné znamená, že se již nepoužívají příkazy <strong>glBegin()</strong> a <strong>glEnd()</strong> (tento režim se nazývá <i>immediate mode</i>). I přesto může být knihovna GLU užitečná, neboť nám umožní vykreslit základní 3D tvary velmi jednoduše, prakticky jen třemi příkazy. Se současným způsobem práce s&nbsp;vykreslovací pipeline (zejména s&nbsp;použitím VBO &ndash; Vertex Buffer Objects), který je rychlejší a flexibilnější, se setkáme ve třinácté a čtrnácté části tohoto seriálu.</p>

<p>Knihovna OpenGL nabízí programátorům podporu pro vykreslování pouze základních grafických primitiv, z&nbsp;nichž se skládají složitější objekty. Mezi tato primitiva patří body, úsečky, polyčáry (na sebe navazující úsečky), trojúhelníky, pruhy trojúhelníků, trsy trojúhelníků, čtyřúhelníky a pruhy čtyřúhelníků. Poněkud složitější geometrické tvary jsou podporovány až knihovnou GLU, která je ovšem z&nbsp;Pygletu taktéž dostupná. Jedná se v&nbsp;první řadě o takzvané <i>kvadriky</i>. Mezi základní podporované kvadriky patří tělesa ve tvaru koule, válce a kužele. Taktéž je možné pracovat s&nbsp;plošným tělesem ve tvaru disku a kruhového výřezu. Složitější kvadriky, mezi něž patří různé hyperboloidy, paraboloidy, sedlové plochy atd., je možné vytvořit buď s&nbsp;využitím programově spočítané trojúhelníkové sítě nebo NURBS ploch, kterými se v&nbsp;tomto seriálu budeme v&nbsp;dalších částech taktéž zabývat.</p>

<a href="https://mojefedora.cz/wp-content/uploads/2017/03/opengl_03_1.gif"><img class="alignnone size-thumbnail wp-image-8609" src="https://mojefedora.cz/wp-content/uploads/2017/03/opengl_03_1.gif" alt="" width="256" height="225" /></a>
<p><i>Obrázek 1: Grafické primitivum GL_POINTS.</i></p>

<a href="https://mojefedora.cz/wp-content/uploads/2017/03/opengl_03_2.gif"><img class="alignnone size-thumbnail wp-image-8610" src="https://mojefedora.cz/wp-content/uploads/2017/03/opengl_03_2.gif" alt="" width="256" height="225" /></a>
<p><i>Obrázek 2: Grafické primitivum GL_LINES.</i></p>

<a href="https://mojefedora.cz/wp-content/uploads/2017/03/opengl_03_3.gif"><img class="alignnone size-thumbnail wp-image-8611" src="https://mojefedora.cz/wp-content/uploads/2017/03/opengl_03_3.gif" alt="" width="256" height="225" /></a>
<p><i>Obrázek 3: Grafické primitivum GL_LINE_STRIP.</i></p>

<a href="https://mojefedora.cz/wp-content/uploads/2017/03/opengl_03_4.gif"><img class="alignnone size-thumbnail wp-image-8612" src="https://mojefedora.cz/wp-content/uploads/2017/03/opengl_03_4.gif" alt="" width="256" height="225" /></a>
<p><i>Obrázek 4: Grafické primitivum GL_LINE_LOOP.</i></p>

<a href="https://mojefedora.cz/wp-content/uploads/2017/03/opengl_03_5.gif"><img class="alignnone size-thumbnail wp-image-8613" src="https://mojefedora.cz/wp-content/uploads/2017/03/opengl_03_5.gif" alt="" width="380" height="240" /></a>
<p><i>Obrázek 5: Grafické primitivum GL_TRIANGLES.</i></p>

<a href="https://mojefedora.cz/wp-content/uploads/2017/03/opengl_03_6.gif"><img class="alignnone size-thumbnail wp-image-8614" src="https://mojefedora.cz/wp-content/uploads/2017/03/opengl_03_6.gif" alt="" width="380" height="240" /></a>
<p><i>Obrázek 6: Grafické primitivum GL_TRIANGLE_FAN.</i></p>

<a href="https://mojefedora.cz/wp-content/uploads/2017/03/opengl_03_7.gif"><img class="alignnone size-thumbnail wp-image-8615" src="https://mojefedora.cz/wp-content/uploads/2017/03/opengl_03_7.gif" alt="" width="380" height="240" /></a>
<p><i>Obrázek 7: Grafické primitivum GL_TRIANGLE_STRIP.</i></p>

<a href="https://mojefedora.cz/wp-content/uploads/2017/03/opengl_03_8.gif"><img class="alignnone size-thumbnail wp-image-8616" src="https://mojefedora.cz/wp-content/uploads/2017/03/opengl_03_8.gif" alt="" width="380" height="240" /></a>
<p><i>Obrázek 8: Grafické primitivum GL_QUADS.</i></p>

<a href="https://mojefedora.cz/wp-content/uploads/2017/03/opengl_03_9.gif"><img class="alignnone size-thumbnail wp-image-8617" src="https://mojefedora.cz/wp-content/uploads/2017/03/opengl_03_9.gif" alt="" width="450" height="186" /></a>
<p><i>Obrázek 9: Grafické primitivum GL_QUAD_STRIP.</i></p>

<a href="https://mojefedora.cz/wp-content/uploads/2017/03/opengl_03_a.gif"><img class="alignnone size-thumbnail wp-image-8618" src="https://mojefedora.cz/wp-content/uploads/2017/03/opengl_03_a.gif" alt="" width="380" height="240" /></a>
<p><i>Obrázek 10: Grafické primitivum GL_POLYGON.</i></p>



<p><a name="k02"></a></p>
<h2 id="k02">2. Co značí pojem &bdquo;kvadrika&ldquo;?</h2>

<p>Před popisem funkcí nabízených knihovnou, které umožňují práci s&nbsp;kvadrikami, si nejdříve řekněme, co to vlastně kvadrika je. Pojmem <i>kvadrika</i> se v&nbsp;matematice a přeneseně i v&nbsp;počítačové grafice označují trojrozměrná tělesa, jejichž povrch (plocha) je určena implicitní funkcí:</p>

<p>
<i>f(x, y, z)=0</i>
</p>

<p>kde implicitní funkce <i>f(x, y, z)</i> nabývá tvaru:</p>

<p>
<i>f(x, y, z) = a<sub>1</sub>x<sup>2</sup> + a<sub>2</sub>y<sup>2</sup> + a<sub>3</sub>z<sup>2</sup> + a<sub>4</sub>xy + a<sub>5</sub>yz + a<sub>6</sub>xz + a<sub>7</sub>x + a<sub>8</sub>y + a<sub>9</sub>z + a<sub>10</sub></i>
</p>

<p>(jinými slovy - jedná se, podle nejvyšší použité mocniny, o algebraické plochy druhého stupně).</p>

<p>To mj.&nbsp;znamená, že pro zadané parametry implicitní plochy <i>a<sub>1</sub>-a<sub>10</sub></i> je možné zjistit, zda bod <i>P=[x, y, z]</i> leží či neleží na ploše kvadriky. Podle znaménka výsledku funkce <i>f(x, y, z)</i> lze dokonce zjistit, zda bod leží uvnitř či vně kvadriky &ndash; to samozřejmě platí pouze pro uzavřené plochy, nikoli plochy nekonečné, jako je <strong>hyperboloid</strong>. Pro některé hodnoty parametrů je výše zmíněná rovnice v&nbsp;oboru reálných čísel neřešitelná (tj. neexistují takové hodnoty <i>x, y, z</i> pro které by funkce <i>f</i> nabývala nuly), proto takovou kvadriku nelze sestrojit.</p>

<a href="https://mojefedora.cz/wp-content/uploads/2017/07/11.jpg"><img class="alignnone size-thumbnail wp-image-9239" src="https://mojefedora.cz/wp-content/uploads/2017/07/11-254x254.jpg" alt="" width="254" height="254" /></a>
<p><i>Obrázek 11: Některé vybrané kvadriky vykreslené raytracerem PovRay.</i></p>

<p>Mezi nejznámější a nejpoužívanější kvadriky v&nbsp;matematice patří:</p>

<ul>

<li><strong>Elipsoid:</strong>
<i>x<sup>2</sup>/a<sup>2</sup>+y<sup>2</sup>/b<sup>2</sup>+z<sup>2</sup>/c<sup>2</sup>-1=0</i> (uvádím nejpoužívanější tvar rovnice, převod na výše zmíněný formát je triviální).</li>

<li><strong>Hyperboloid:</strong>
<i>x<sup>2</sup>/a<sup>2</sup>+y<sup>2</sup>/b<sup>2</sup>-z<sup>2</sup>/c<sup>2</sup>=+-1</i>.</li>

<li><strong>Paraboloid:</strong>
<i>x<sup>2</sup>/p+-y<sup>2</sup>/q=2z</i>.</li>

</ul>

<p>Speciálním případem <strong>elipsoidu</strong> je <strong>koule</strong>, <strong>válec</strong> lze získat dosazením vhodných hodnot do implicitní rovnice <strong>hyperboloidu</strong>. Takto získaný válec je nekonečný, tj.&nbsp;neobsahuje obě &bdquo;víčka&ldquo;, ale pouze plášť.</p>

<p>Kvadriky se často používají v&nbsp;některých CAD a CAM aplikacích, kde se z&nbsp;nich (a případně i z&nbsp;dalších tvarů &ndash; <strong>roviny</strong>, <strong>poloprostoru</strong> a <strong>toroidu</strong>) vytváří složitější tělesa s&nbsp;využitím konstruktivní geometrie těles (<i>Constructive Solid Geometry</i>, <i>CSG</i>). Většina programů pro fotorealistické zobrazování scén pomocí raytracingu také CSG (a tím pádem i kvadriky, alespoň ty základní) využívá. Z&nbsp;této kategorie programů je pro Linux i další platformy dostupný především volně šiřitelný raytracer <i>POVRay</i>.</p>

<p>Pokud se vrátíme zpět ke knihovnám GLU a OpenGL, je nutné říct, že GLU neumožňuje vytvářet všechny možné kvadriky, ale pouze ty nejzákladnější: koule a válce (resp.&nbsp;kužele, válce jsou v&nbsp;pojetí GLU speciálním případem kuželů). K&nbsp;tomu lze vytvářet i disky (plošné těleso) a jejich výřezy, což se hodí zejména pro uzavírání různých &bdquo;děr&ldquo; ve vznikajícím modelu tělesa.</p>



<p><a name="k03"></a></p>
<h2 id="k03">3. Postup pro vytvoření a zobrazení kvadrik při použití GLU</h2>

<p>Pro vytvoření a následné vykreslení kvadrik ve vznikající trojrozměrné scéně je nutné dodržet následující postup:</p>

<ol>

<li>vytvořit nový objekt pro následné renderování kvadrik pomocí funkce <i>gluNewQuadric()</i>.</li>

<li>nastavit atributy pro rendering (vykreslování) tohoto objektu, v&nbsp;některých případech je však možné ponechat původní nastavení. Změna atributů kvadrik se provádí s&nbsp;využitím funkcí <i>gluQuadricDrawStyle()</i>, <i>gluQuadricOrientation()</i>, <i>gluQuadricNormals()</i> a <i>gluQuadricTexture()</i>.</li>

<li>zaregistrovat callback funkci, která je volaná v&nbsp;případě výskytu chyby při renderování kvadriky. Registrace callback funkce se provede zavoláním funkce <i>gluQuadricCallback()</i> (není vyložené nutné).</li>

<li>zavolat funkci pro vytvoření požadované kvadriky: <i>gluSphere()</i>, <i>gluCylinder()</i>, <i>gluDisk()</i> nebo <i>gluPartialDisk()</i>.</li>

<li>po vykreslení požadované kvadriky je možné objekt pro renderování kvadrik smazat (tj.&nbsp;odstranit z&nbsp;paměti jeho atributy) pomocí funkce <i>gluDeleteQuadric()</i>.</li>

</ol>

<p>Poznámka: při práci s&nbsp;kvadrikami se ve všech funkcích pracuje s&nbsp;referencí na objekt typu <i>GLUquadric</i>. V&nbsp;dokumentaci ke knihovně GLU se sice stále mluví o objektu (má některé objektové vlastnosti, kromě polymorfismu a dědičnosti), ve skutečnosti ale jde o běžnou C-čkovou datovou strukturu. Ostatně celá knihovna GLU je postavena na čistém jazyce C, což zjednodušuje volání jejich funkcí i z&nbsp;programů vytvořených v&nbsp;jiných programovacích jazycích. A právě této vlastnosti využijeme v&nbsp;demonstračních příkladech, které jsou psané v&nbsp;programovacím jazyku Python &ndash; budeme pracovat s&nbsp;céčkovským ukazatelem přes <i>ctypes</i>.</p>



<p><a name="k04"></a></p>
<h2 id="k04">4. Vytvoření trojrozměrného modelu koule</h2>

<p>Koule, jež patří mezi nejjednodušší kvadriky (pokud vynecháme lineární struktury, které jsou podmnožinou kvadrik), je popsána rovnicí:</p>

<p>
<i>x<sup>2</sup>+y<sup>2</sup>+z<sup>2</sup>-r<sup>2</sup>=0</i>,
<br> kde <i>r</i> značí poloměr koule.
</p>

<p>Z&nbsp;předchozí rovnice plyne, že jediným parametrem, kterým je takto definovaná koule specifikována, je právě poloměr <i>r</i>. Střed koule leží v&nbsp;počátku souřadného systému, což však nepředstavuje při práci s&nbsp;modelem významnější problém, jelikož je možné souřadný systém natáčet a posouvat změnou transformačních matic, tj.&nbsp;pomocí funkcí <i>glTranslatef()</i> a <i>glRotatef()</i>.</p>

<p>Funkce pro vytvoření modelu koule pomocí kvadrik se jmenuje <i>gluSphere()</i> a má v&nbsp;Pythonu následující deklaraci:</p>

<pre>
def gluSphere(
    quadric,
    radius,
    slices,
    stacks
)
</pre>

<p>Význam jednotlivých parametrů této funkce:</p>

<ol>

<li>V&nbsp;prvním parametru <i>quadric</i> se předává ukazatel na dříve vytvořený objekt kvadriky.</li>

<li>Ve druhém parametru <i>radius</i> se předává hodnota značící poloměr vytvářené koule. Ve skutečnosti se jedná o nadbytečný údaj, protože se velikost koule dá změnit i pomocí úpravy transformačních matic, zde však nedochází ke změně měřítka normálových vektorů.</li>

<li>Ve třetím parametru <i>slices</i> se předává počet &bdquo;poledníků&ldquo; pomocí nichž je koule rozdělena na jednotlivé plošky. Čím je tento údaj větší, tím více ploškami bude koule tvořena a tím přesnější bude její model (sníží se samozřejmě rychlost vykreslování).</li>

<li>Ve čtvrtém parametru <i>stacks</i> se předává počet &bdquo;rovnoběžek&ldquo; pomocí nichž je koule rozdělena na plošky. Počet rovnoběžek je o jedničku nižší než zde zadaná hodnota. To znamená, že pokud je do parametru <i>stacks</i> zapsána hodnota 2, vytvoří se pouze jedna rovnoběžka &ndash; rovník a dva póly, mezi kterými jsou vytvořeny vykreslované plošky.</li>

</ol>

<a href="https://mojefedora.cz/wp-content/uploads/2017/07/12.png"><img class="alignnone size-thumbnail wp-image-9240" src="https://mojefedora.cz/wp-content/uploads/2017/07/12-254x254.png" alt="" width="254" height="254" /></a>
<p><i>Obrázek 12: Model koule vykreslený prvním příkladem.</i></p>



<p><a name="k05"></a></p>
<h2 id="k05">5. První demonstrační příklad: vykreslení modelu koule</h2>

<p>V&nbsp;dnešním prvním demonstračním příkladu je vykreslen model koule, a to konkrétně ve funkci <strong>draw_quadric
</strong>. V&nbsp;této funkci se nejdříve nastaví vlastnosti vykreslování, konkrétně fakt, že se má koule vykreslit jako drátový model. Následně se specifikuje výpočet normálových vektorů a koule je vykreslena příkazem <strong>gluSphere()</strong>. Následně je objekt reprezentující kvadriku odstraněn:</p>

<pre>
def draw_quadric():
    radius = 8.0
    slices = 10
    stacks = 10
    quadric = gluNewQuadric()                   # vytvoreni kvadriky
    gluQuadricDrawStyle(quadric, GLU_LINE)      # nastaveni vlastnosti kvadriky
    gluQuadricNormals(quadric, GLU_SMOOTH)      # smer generovanych normal
    gluSphere(quadric, radius, slices, stacks)  # vykresleni kvadriky
    gluDeleteQuadric(quadric)                   # zruseni kvadriky
</pre>

<a href="https://mojefedora.cz/wp-content/uploads/2017/07/13.png"><img class="alignnone size-thumbnail wp-image-9241" src="https://mojefedora.cz/wp-content/uploads/2017/07/13-254x254.png" alt="" width="254" height="254" /></a>
<p><i>Obrázek 13: Model koule vykreslený prvním příkladem.</i></p>

<p>Samotné vykreslení je realizováno ve funkci <strong>on_draw()</strong>, v&nbsp;níž se současně reaguje na stisk kurzorových kláves sloužících pro otáčení koulí ve scéně:</p>

<pre>
@window.event
def on_draw():
    global r1, r2

    if keys[key.LEFT]:
        r2 -= 2
    if keys[key.RIGHT]:
        r2 += 2
    if keys[key.UP]:
        r1 -= 2
    if keys[key.DOWN]:
        r1 += 2

    clear_buffers()
    set_projection_matrix(fov, nearPlane, farPlane)
    set_modelview_matrix(r1, r2)
    draw_quadric()                         # vykresleni dratoveho modelu koule
</pre>

<p>Úplný zdrojový kód prvního demonstračního příkladu vypadá následovně:</p>

<pre>
#!/usr/bin/env python

import pyglet
from pyglet.gl import *
from pyglet.window import key

fov = 70.0                                 # zorny uhel (field of view)
nearPlane = 0.1                            # blizsi orezavaci rovina
farPlane = 90.0                            # vzdalenejsi orezavaci rovina

r1 = 0.0
r2 = 0.0


window = pyglet.window.Window(width=500,
                              height=500,
                              caption="Pyglet library")

keys = key.KeyStateHandler()
window.push_handlers(keys)


def init():
    glClearColor(0.0, 0.0, 0.3, 0.0)       # barva pozadi obrazku
    glPolygonMode(GL_FRONT, GL_FILL)       # nastaveni rezimu vykresleni modelu
    glPolygonMode(GL_BACK, GL_FILL)

    # zakaz odstranovani hran nebo sten podle jejich normal
    glDisable(GL_CULL_FACE)

    glShadeModel(GL_SMOOTH)                # nastaveni stinovaciho rezimu


@window.event
def on_resize(width, height):
    init()
    glViewport(0, 0, width, height)        # viditelna oblast pres cele okno


def draw_quadric():
    radius = 8.0
    slices = 10
    stacks = 10
    quadric = gluNewQuadric()                   # vytvoreni kvadriky
    gluQuadricDrawStyle(quadric, GLU_LINE)      # nastaveni vlastnosti kvadriky
    gluQuadricNormals(quadric, GLU_SMOOTH)      # smer generovanych normal
    gluSphere(quadric, radius, slices, stacks)  # vykresleni kvadriky
    gluDeleteQuadric(quadric)                   # zruseni kvadriky


def clear_buffers():
    # vymazani vsech bitovych rovin barvoveho bufferu
    glClear(GL_COLOR_BUFFER_BIT)


def set_projection_matrix(fov, nearPlane, farPlane):
    # zacatek modifikace projekcni matice
    glMatrixMode(GL_PROJECTION)
    # vymazani projekcni matice (=identita)
    glLoadIdentity()
    gluPerspective(fov, 1.0, nearPlane, farPlane)


def set_modelview_matrix(rotation1, rotation2):
    glMatrixMode(GL_MODELVIEW)
    glLoadIdentity()                       # nahrat jednotkovou matici

    gluLookAt(4.0, 6.0, 18.0,              # bod, odkud se kamera diva
              0.0, 2.0,  0.0,              # bod, kam se kamera diva
              0.0, 1.0,  0.0)              # poloha "stropu" ve scene

    glRotatef(rotation1, 1.0, 0.0, 0.0)    # rotace objektu
    glRotatef(rotation2, 0.0, 1.0, 0.0)


@window.event
def on_draw():
    global r1, r2

    if keys[key.LEFT]:
        r2 -= 2
    if keys[key.RIGHT]:
        r2 += 2
    if keys[key.UP]:
        r1 -= 2
    if keys[key.DOWN]:
        r1 += 2

    clear_buffers()
    set_projection_matrix(fov, nearPlane, farPlane)
    set_modelview_matrix(r1, r2)
    draw_quadric()                         # vykresleni dratoveho modelu koule


pyglet.app.run()
</pre>



<p><a name="k06"></a></p>
<h2 id="k06">6. Vytvoření modelu válce nebo kužele</h2>

<p>Mezi další kvadriky, které je možné s&nbsp;využitím funkcí z&nbsp;knihovny GLU vytvořit, patří válec a kužel. Pro oba tvary je použita stejná funkce, které se jmenuje <i>gluCylinder()</i> a má v&nbsp;Pythonu následující deklaraci:</p>

<pre>
gluCylinder(
    quadric,
    baseRadius,
    topRadius,
    height,
    slices,
    stacks
)
</pre>

<p>Význam jednotlivých parametrů této funkce je následující:</p>

<ol>

<li>Přes první parametr <i>quadric</i> je předán ukazatel na dříve vytvořený objekt kvadriky, který má stejný význam jako u výše uvedené funkce <i>gluSphere()</i>.</li>

<li>Ve druhém parametru <i>baseRadius</i> je uveden poloměr válce/kužele u jeho základny. Tato hodnota by neměla být záporná.</li>

<li>Ve třetím parametru <i>topRadius</i> je uveden poloměr válce/kužele u jeho horní základny (vrchlíku). Pokud jsou hodnoty parametrů <i>baseRadius</i> a <i>topRadius</i> shodné, vytvoří se válec, pokus jsou rozdílné, vytvoří se komolý kužel. V&nbsp;případě, že je parametr <i>topRadius</i> nastaven na nulu, vytvoří se normální kužel s&nbsp;jedním vrcholem.</li>

<li>Čtvrtým parametrem <i>height</i> je specifikována výška válce či kužele. Základna modelu je umístěna v&nbsp;počátku a osa vytvořeného tělesa směřuje vzhůru ve směru osy <i>z</i>. Aby byl model vycentrovaný, je zapotřebí před jeho vykreslením provést posun v&nbsp;záporném směru <i>z</i>-ové osy: <i>glTranslatef(0.0f, 0.0f, -height/2)</i>.</li>

<li>V&nbsp;pátém parametru <i>slices</i> se předává počet &bdquo;poledníků&ldquo;, tj.&nbsp;dělení kolmých na základnu, pomocí nichž je válec či kužel rozdělen na jednotlivé plošky. Čím je tento údaj větší, tím více ploškami bude těleso tvořeno a tím přesnější bude jeho model (sníží se samozřejmě rychlost vykreslování).</li>

<li>V&nbsp;posledním, šestém parametru <i>stacks</i> se předává počet &bdquo;rovnoběžek&ldquo;, tj.&nbsp;dělení rovnoběžných se základnou, pomocí nichž je válec či kužel rozdělen na plošky. Počet rovnoběžek je o jedničku nižší než zde zadaná hodnota. To znamená, že pokud je do parametru <i>stacks</i> zapsána hodnota 2, vytvoří se pouze jedna rovnoběžka &ndash; &bdquo;rovník&ldquo; a dvě základny o poloměrech <i>baseRadius</i> a <i>topRadius</i>, mezi kterými jsou vytvořeny vykreslované plošky.</li>

</ol>



<p><a name="k07"></a></p>
<h2 id="k07">7. Druhý demonstrační příklad: vykreslení modelu válce</h2>

<p>Druhý příklad se do značné míry podobá příkladu prvnímu, pouze se změnil obsah funkce pro vykreslení kvadriky. Nový tvar této funkce používá volání <strong>gluCylinder()</strong> a nikoli <strong>gluSphere()</strong>. Navíc ještě celý válec posuneme ve směru Z-ové osy o hodnotu <i>-výška_válce/2</i>, aby došlo k&nbsp;jeho vycentrování na počátek světových souřadnic. Tím dosáhneme toho, že se válec bude otáčet okolo svého středu a nikoli okolo středu své podstavy:</p>

<pre>
def draw_quadric():
    baseRadius = 8.0
    topRadius = 8.0
    height = 10.0
    slices = 50
    stacks = 10
    quadric = gluNewQuadric()                   # vytvoreni kvadriky
    gluQuadricDrawStyle(quadric, GLU_LINE)      # nastaveni vlastnosti kvadriky
    gluQuadricNormals(quadric, GLU_SMOOTH)      # smer generovanych normal
    glTranslatef(0, 0, -height/2)               # vycentrovani valce
    gluCylinder(quadric, baseRadius, topRadius, height, slices, stacks)
    gluDeleteQuadric(quadric)                   # zruseni kvadriky
</pre>

<a href="https://mojefedora.cz/wp-content/uploads/2017/07/14.png"><img class="alignnone size-thumbnail wp-image-9242" src="https://mojefedora.cz/wp-content/uploads/2017/07/14-254x254.png" alt="" width="254" height="254" /></a>
<p><i>Obrázek 14: Model válce vykreslený druhým příkladem.</i></p>

<p>Následuje výpis zdrojového kódu tohoto příkladu:</p>

<pre>
#!/usr/bin/env python

import pyglet
from pyglet.gl import *
from pyglet.window import key

fov = 70.0                                 # zorny uhel (field of view)
nearPlane = 0.1                            # blizsi orezavaci rovina
farPlane = 90.0                            # vzdalenejsi orezavaci rovina

r1 = 0.0
r2 = 0.0


window = pyglet.window.Window(width=500,
                              height=500,
                              caption="Pyglet library")

keys = key.KeyStateHandler()
window.push_handlers(keys)


def init():
    glClearColor(0.0, 0.0, 0.3, 0.0)       # barva pozadi obrazku
    glPolygonMode(GL_FRONT, GL_FILL)       # nastaveni rezimu vykresleni modelu
    glPolygonMode(GL_BACK, GL_FILL)

    # zakaz odstranovani hran nebo sten podle jejich normal
    glDisable(GL_CULL_FACE)

    glShadeModel(GL_SMOOTH)                # nastaveni stinovaciho rezimu


@window.event
def on_resize(width, height):
    init()
    glViewport(0, 0, width, height)        # viditelna oblast pres cele okno


def draw_quadric():
    baseRadius = 8.0
    topRadius = 8.0
    height = 10.0
    slices = 50
    stacks = 10
    quadric = gluNewQuadric()                   # vytvoreni kvadriky
    gluQuadricDrawStyle(quadric, GLU_LINE)      # nastaveni vlastnosti kvadriky
    gluQuadricNormals(quadric, GLU_SMOOTH)      # smer generovanych normal
    glTranslatef(0, 0, -height/2)               # vycentrovani valce
    gluCylinder(quadric, baseRadius, topRadius, height, slices, stacks)
    gluDeleteQuadric(quadric)                   # zruseni kvadriky


def clear_buffers():
    # vymazani vsech bitovych rovin barvoveho bufferu
    glClear(GL_COLOR_BUFFER_BIT)


def set_projection_matrix(fov, nearPlane, farPlane):
    # zacatek modifikace projekcni matice
    glMatrixMode(GL_PROJECTION)
    # vymazani projekcni matice (=identita)
    glLoadIdentity()
    gluPerspective(fov, 1.0, nearPlane, farPlane)


def set_modelview_matrix(rotation1, rotation2):
    glMatrixMode(GL_MODELVIEW)
    glLoadIdentity()                       # nahrat jednotkovou matici

    gluLookAt(4.0, 6.0, 18.0,              # bod, odkud se kamera diva
              0.0, 2.0,  0.0,              # bod, kam se kamera diva
              0.0, 1.0,  0.0)              # poloha "stropu" ve scene

    glRotatef(rotation1, 1.0, 0.0, 0.0)    # rotace objektu
    glRotatef(rotation2, 0.0, 1.0, 0.0)


@window.event
def on_draw():
    global r1, r2

    if keys[key.LEFT]:
        r2 -= 2
    if keys[key.RIGHT]:
        r2 += 2
    if keys[key.UP]:
        r1 -= 2
    if keys[key.DOWN]:
        r1 += 2

    clear_buffers()
    set_projection_matrix(fov, nearPlane, farPlane)
    set_modelview_matrix(r1, r2)
    draw_quadric()                         # vykresleni dratoveho modelu valce


pyglet.app.run()
</pre>



<p><a name="k08"></a></p>
<h2 id="k08">8. Třetí demonstrační příklad: vykreslení modelu kužele</h2>

<p>Nepatrnou změnou jediné proměnné ve funkci:</p>

<pre>
def draw_quadric():
    baseRadius = 8.0
    topRadius = 8.0
    height = 10.0
    slices = 50
    stacks = 10
    quadric = gluNewQuadric()                   # vytvoreni kvadriky
    gluQuadricDrawStyle(quadric, GLU_LINE)      # nastaveni vlastnosti kvadriky
    gluQuadricNormals(quadric, GLU_SMOOTH)      # smer generovanych normal
    glTranslatef(0, 0, -height/2)               # vycentrovani valce
    gluCylinder(quadric, baseRadius, topRadius, height, slices, stacks)
    gluDeleteQuadric(quadric)                   # zruseni kvadriky
</pre>

<p>za:</p>

<pre>
def draw_quadric():
    baseRadius = 6.0
    topRadius = 0.0
    height = 10.0
    slices = 50
    stacks = 10
    quadric = gluNewQuadric()                   # vytvoreni kvadriky
    gluQuadricDrawStyle(quadric, GLU_LINE)      # nastaveni vlastnosti kvadriky
    gluQuadricNormals(quadric, GLU_SMOOTH)      # smer generovanych normal
    glTranslatef(0, 0, -height/2)               # vycentrovani valce
    gluCylinder(quadric, baseRadius, topRadius, height, slices, stacks)
    gluDeleteQuadric(quadric)                   # zruseni kvadriky
</pre>

<p>dosáhneme vykreslení kužele a nikoli válce.</p>

<a href="https://mojefedora.cz/wp-content/uploads/2017/07/15.png"><img class="alignnone size-thumbnail wp-image-9243" src="https://mojefedora.cz/wp-content/uploads/2017/07/15-254x254.png" alt="" width="254" height="254" /></a>
<p><i>Obrázek 15: Model kužele vykreslený třetím příkladem.</i></p>

<p>Opět následuje výpis zdrojového kódu tohoto příkladu:</p>

<pre>
#!/usr/bin/env python

import pyglet
from pyglet.gl import *
from pyglet.window import key

fov = 70.0                                 # zorny uhel (field of view)
nearPlane = 0.1                            # blizsi orezavaci rovina
farPlane = 90.0                            # vzdalenejsi orezavaci rovina

r1 = 0.0
r2 = 0.0


window = pyglet.window.Window(width=500,
                              height=500,
                              caption="Pyglet library")

keys = key.KeyStateHandler()
window.push_handlers(keys)


def init():
    glClearColor(0.0, 0.0, 0.3, 0.0)       # barva pozadi obrazku
    glPolygonMode(GL_FRONT, GL_FILL)       # nastaveni rezimu vykresleni modelu
    glPolygonMode(GL_BACK, GL_FILL)

    # zakaz odstranovani hran nebo sten podle jejich normal
    glDisable(GL_CULL_FACE)

    glShadeModel(GL_SMOOTH)                # nastaveni stinovaciho rezimu


@window.event
def on_resize(width, height):
    init()
    glViewport(0, 0, width, height)        # viditelna oblast pres cele okno


def draw_quadric():
    baseRadius = 6.0
    topRadius = 0.0
    height = 10.0
    slices = 50
    stacks = 10
    quadric = gluNewQuadric()                   # vytvoreni kvadriky
    gluQuadricDrawStyle(quadric, GLU_LINE)      # nastaveni vlastnosti kvadriky
    gluQuadricNormals(quadric, GLU_SMOOTH)      # smer generovanych normal
    glTranslatef(0, 0, -height/2)               # vycentrovani valce
    gluCylinder(quadric, baseRadius, topRadius, height, slices, stacks)
    gluDeleteQuadric(quadric)                   # zruseni kvadriky


def clear_buffers():
    # vymazani vsech bitovych rovin barvoveho bufferu
    glClear(GL_COLOR_BUFFER_BIT)


def set_projection_matrix(fov, nearPlane, farPlane):
    # zacatek modifikace projekcni matice
    glMatrixMode(GL_PROJECTION)
    # vymazani projekcni matice (=identita)
    glLoadIdentity()
    gluPerspective(fov, 1.0, nearPlane, farPlane)


def set_modelview_matrix(rotation1, rotation2):
    glMatrixMode(GL_MODELVIEW)
    glLoadIdentity()                       # nahrat jednotkovou matici

    gluLookAt(4.0, 6.0, 18.0,              # bod, odkud se kamera diva
              0.0, 2.0,  0.0,              # bod, kam se kamera diva
              0.0, 1.0,  0.0)              # poloha "stropu" ve scene

    glRotatef(rotation1, 1.0, 0.0, 0.0)    # rotace objektu
    glRotatef(rotation2, 0.0, 1.0, 0.0)


@window.event
def on_draw():
    global r1, r2

    if keys[key.LEFT]:
        r2 -= 2
    if keys[key.RIGHT]:
        r2 += 2
    if keys[key.UP]:
        r1 -= 2
    if keys[key.DOWN]:
        r1 += 2

    clear_buffers()
    set_projection_matrix(fov, nearPlane, farPlane)
    set_modelview_matrix(r1, r2)
    draw_quadric()                         # vykresleni dratoveho modelu valce


pyglet.app.run()
</pre>

<a href="https://mojefedora.cz/wp-content/uploads/2017/07/16.png"><img class="alignnone size-thumbnail wp-image-9244" src="https://mojefedora.cz/wp-content/uploads/2017/07/16-254x254.png" alt="" width="254" height="254" /></a>
<p><i>Obrázek 16: Model kužele vykreslený třetím příkladem.</i></p>



<p><a name="k09"></a></p>
<h2 id="k09">9. Vytvoření disku či mezikruží</h2>

<p>Kromě prostorových modelů těles lze pomocí kvadrik vytvořit i plošný disk (kruh či mezikruží). Ten je možné použít například při vyplňování děr ve vytvářeném modelu, nebo pro uzavírání válců a kuželů. Vzhledem k&nbsp;tomu, že pomocí OpenGL není možné vykreslit kruh přímo jako grafickou primitivu (i když by analytické řešení průsečíku jednotlivých skenovacích řádků bylo jednodušší než u trojúhelníku), je model kruhu nejdříve rozdělen na několik plošek a teprve tyto jsou poslány do grafického vykreslovacího řetězce.</p>

<p>Počet plošek, na které je kruh rozdělen, je možné programově měnit již při jeho vytváření.</p>

<p>Funkce pro vytvoření disku/kruhu se jmenuje <i>gluDisk()</i> a má v&nbsp;Pythonu následující deklaraci:</p>

<pre>
gluDisk(
    quadric,
    innerRadius,
    outerRadius,
    slices,
    loops
)
</pre>

<p>Význam jednotlivých parametrů této funkce je následující:</p>

<ol>

<li>V&nbsp;prvním parametru <i>quadric</i> funkce <i>gluDisk()</i> se předává ukazatel na dříve vytvořený objekt kvadriky. Význam tohoto parametru je tedy stejný jako u funkcí <i>gluSphere()</i> a <i>gluCylinder()</i>.</li>

<li>Ve druhém parametru <i>innerRadius</i> je předán vnitřní poloměr disku. Pokud je vnitřní poloměr nulový, bude disk celý vyplněn a vytvoří se tak kruh. Poloměr sice může být nulový, ale neměl by být záporný.</li>

<li>Ve třetím parametru <i>outerRadius</i> je specifikován vnější poloměr disku, který by měl být větší než vnitřní poloměr. Pokud se vnitřní a vnější poloměry liší pouze o malou hodnotu (a přitom platí <i>outerRadius>innerRadius</i>), je výsledkem tenký prstenec.</li>

<li>Dalším parametrem <i>slices</i> je možné zadat počet řezů, tj.&nbsp;počet vrcholů, které jsou vytvořeny na jednotlivých prstencích.</li>

<li>Posledním parametrem <i>loops</i> se specifikuje počet prstenců, na kterých se vrcholy vytváří. Celkový počet vrcholů, ze kterých je vytvořena plocha prstence je roven hodnotě <i>slices*loop</i>. Podobně jako u dalších objektů reprezentovaných svou hranicí platí, že čím větší je počet vrcholů na ploše, tím přesněji je plocha vykreslena (resp.&nbsp;tím přesněji odpovídá matematické ploše). Na druhou stranu se samozřejmě zvyšuje zatížení sběrnice a grafického akcelerátoru, který musí zpracovat větší množství dat.</li>

</ol>



<p><a name="k10"></a></p>
<h2 id="k10">10. Čtvrtý demonstrační příklad: vykreslení mezikruží</h2>

<p>Ve čtvrtém příkladu je vykresleno mezikruží s&nbsp;vnitřním poloměrem dvou délkových jednotek a vnějším poloměrem osm délkových jednotek. Pro ilustraci způsobu vytvoření tohoto tělesa se opět používá vykreslení s&nbsp;využitím úseček, výsledkem je tedy drátový model (<i>wireframe</i>):</p>

<pre>
def draw_disk():
    innerRadius = 2.0
    outerRadius = 8.0
    slices = 24
    loops = 8
    quadric = gluNewQuadric()                   # vytvoreni kvadriky
    gluQuadricDrawStyle(quadric, GLU_LINE)      # nastaveni vlastnosti kvadriky
    gluDisk(quadric, innerRadius, outerRadius, slices, loops)
    gluDeleteQuadric(quadric)                   # zruseni kvadriky
</pre>

<a href="https://mojefedora.cz/wp-content/uploads/2017/07/17.png"><img class="alignnone size-thumbnail wp-image-9245" src="https://mojefedora.cz/wp-content/uploads/2017/07/17-254x254.png" alt="" width="254" height="254" /></a>
<p><i>Obrázek 17: Mezikruží vykreslené čtvrtým příkladem.</i></p>

<p>Opět následuje výpis zdrojového kódu tohoto příkladu:</p>

<pre>
#!/usr/bin/env python

import pyglet
from pyglet.gl import *
from pyglet.window import key

fov = 70.0                                 # zorny uhel (field of view)
nearPlane = 0.1                            # blizsi orezavaci rovina
farPlane = 90.0                            # vzdalenejsi orezavaci rovina

r1 = 0.0
r2 = 0.0


window = pyglet.window.Window(width=500,
                              height=500,
                              caption="Pyglet library")

keys = key.KeyStateHandler()
window.push_handlers(keys)


def init():
    glClearColor(0.0, 0.0, 0.3, 0.0)       # barva pozadi obrazku
    glPolygonMode(GL_FRONT, GL_FILL)       # nastaveni rezimu vykresleni modelu
    glPolygonMode(GL_BACK, GL_FILL)

    # zakaz odstranovani hran nebo sten podle jejich normal
    glDisable(GL_CULL_FACE)

    glShadeModel(GL_SMOOTH)                # nastaveni stinovaciho rezimu


@window.event
def on_resize(width, height):
    init()
    glViewport(0, 0, width, height)        # viditelna oblast pres cele okno


def draw_disk():
    innerRadius = 2.0
    outerRadius = 8.0
    slices = 24
    loops = 8
    quadric = gluNewQuadric()                   # vytvoreni kvadriky
    gluQuadricDrawStyle(quadric, GLU_LINE)      # nastaveni vlastnosti kvadriky
    gluDisk(quadric, innerRadius, outerRadius, slices, loops)
    gluDeleteQuadric(quadric)                   # zruseni kvadriky


def clear_buffers():
    # vymazani vsech bitovych rovin barvoveho bufferu
    glClear(GL_COLOR_BUFFER_BIT)


def set_projection_matrix(fov, nearPlane, farPlane):
    # zacatek modifikace projekcni matice
    glMatrixMode(GL_PROJECTION)
    # vymazani projekcni matice (=identita)
    glLoadIdentity()
    gluPerspective(fov, 1.0, nearPlane, farPlane)


def set_modelview_matrix(rotation1, rotation2):
    glMatrixMode(GL_MODELVIEW)
    glLoadIdentity()                       # nahrat jednotkovou matici

    gluLookAt(4.0, 6.0, 18.0,              # bod, odkud se kamera diva
              0.0, 2.0,  0.0,              # bod, kam se kamera diva
              0.0, 1.0,  0.0)              # poloha "stropu" ve scene

    glRotatef(rotation1, 1.0, 0.0, 0.0)    # rotace objektu
    glRotatef(rotation2, 0.0, 1.0, 0.0)


@window.event
def on_draw():
    global r1, r2

    if keys[key.LEFT]:
        r2 -= 2
    if keys[key.RIGHT]:
        r2 += 2
    if keys[key.UP]:
        r1 -= 2
    if keys[key.DOWN]:
        r1 += 2

    clear_buffers()
    set_projection_matrix(fov, nearPlane, farPlane)
    set_modelview_matrix(r1, r2)
    draw_disk()                            # vykresleni dratoveho modelu disku


pyglet.app.run()
</pre>



<p><a name="k11"></a></p>
<h2 id="k11">11. Vytvoření kruhové výseče</h2>

<p>Kruhová výseč je, podobně jako disk, rovinný útvar, který je tvořený pomocí čtyřúhelníků. Stejně jako u disků, i u kruhové výseče je nutné specifikovat vnitřní a vnější poloměr a způsob rozdělení tvaru na plošky. K&nbsp;těmto údajům je nutné navíc specifikovat i dva úhly, pomocí nichž se zadává tvar výseče, tj.&nbsp;část kruhu či prstence, která má být zobrazena.</p>

<p>Funkce pro vytvoření kruhové výseče se jmenuje <i>gluPartialDisk()</i> a má v&nbsp;Pythonu následující deklaraci:</p>

<pre>
gluPartialDisk(
    quadric,
    innerRadius,
    outerRadius,
    slices,
    loops,
    startAngle,
    sweepAngle
)
</pre>

<p>Význam jednotlivých parametrů této funkce je následující:</p>

<ol>

<li>Přes první parametr <i>quadric</i> je předán ukazatel na dříve vytvořený model kvadriky.</li>

<li>Pomocí druhého parametru <i>innerRadius</i> je specifikován vnitřní poloměr výseče.</li>

<li>Pomocí třetího parametru <i>outerRadius</i> je specifikován vnější poloměr výseče. Pro oba poloměry platí stejné zákonitosti jako u výše popsané funkce <i>gluDisk()</i>.</li>

<li>Čtvrtým parametrem <i>slices</i> se zadává počet řezů disku, ze kterého se výseč tvoří.</li>

<li>Počet prstenců, které tvoří kruhovou výseč, se předává v&nbsp;pátém parametru <i>loops</i>.</li>

<li>V&nbsp;předposledním parametru <i>startAngle</i> je předán první úhel kruhové výseče, který je zadán ve stupních. Hodnota tohoto úhlu může být kladná i záporná, přičemž se berou do úvahy hodnoty vypočtené &bdquo;modulo&ldquo; 360.</li>

<li>V&nbsp;posledním parametru <i>sweepAngle</i> je předán obloukový úhel kruhové výseče, který je taktéž zadán ve stupních. Smysluplné hodnoty leží v&nbsp;rozsahu -360..360 stupňů, zadaná hodnota je do tohoto rozsahu ořezána.</li>

</ol>

<a href="https://mojefedora.cz/wp-content/uploads/2017/07/18.png"><img class="alignnone size-thumbnail wp-image-9246" src="https://mojefedora.cz/wp-content/uploads/2017/07/18-254x254.png" alt="" width="254" height="254" /></a>
<p><i>Obrázek 18: Kruhová výseč vykreslená pátým příkladem.</i></p>



<p><a name="k12"></a></p>
<h2 id="k12">12. Pátý demonstrační příklad: vykreslení kruhové výseče</h2>

<p>V&nbsp;dnešním předposledním demonstračním příkladu je ukázán způsob vykreslení kruhové výseče. Tento příklad je prakticky totožný s&nbsp;příkladem předchozím, pouze došlo ke změně funkce <strong>gluDisk()</strong> za volání funkce <strong>gluPartialDisk()</strong>. Zdrojový kód tohoto příkladu vypadá následovně:</p>

<pre>
#!/usr/bin/env python

import pyglet
from pyglet.gl import *
from pyglet.window import key

fov = 70.0                                 # zorny uhel (field of view)
nearPlane = 0.1                            # blizsi orezavaci rovina
farPlane = 90.0                            # vzdalenejsi orezavaci rovina

r1 = 0.0
r2 = 0.0


window = pyglet.window.Window(width=500,
                              height=500,
                              caption="Pyglet library")

keys = key.KeyStateHandler()
window.push_handlers(keys)


def init():
    glClearColor(0.0, 0.0, 0.3, 0.0)       # barva pozadi obrazku
    glPolygonMode(GL_FRONT, GL_FILL)       # nastaveni rezimu vykresleni modelu
    glPolygonMode(GL_BACK, GL_FILL)

    # zakaz odstranovani hran nebo sten podle jejich normal
    glDisable(GL_CULL_FACE)

    glShadeModel(GL_SMOOTH)                # nastaveni stinovaciho rezimu


@window.event
def on_resize(width, height):
    init()
    glViewport(0, 0, width, height)        # viditelna oblast pres cele okno


def draw_partial_disk():
    innerRadius = 2.0
    outerRadius = 8.0
    slices = 24
    loops = 8
    startAngle = -45
    sweepAngle = 270
    quadric = gluNewQuadric()                   # vytvoreni kvadriky
    gluQuadricDrawStyle(quadric, GLU_LINE)      # nastaveni vlastnosti kvadriky
    gluPartialDisk(quadric, innerRadius, outerRadius, slices, loops,
                   startAngle, sweepAngle)
    gluDeleteQuadric(quadric)                   # zruseni kvadriky


def clear_buffers():
    # vymazani vsech bitovych rovin barvoveho bufferu
    glClear(GL_COLOR_BUFFER_BIT)


def set_projection_matrix(fov, nearPlane, farPlane):
    # zacatek modifikace projekcni matice
    glMatrixMode(GL_PROJECTION)
    # vymazani projekcni matice (=identita)
    glLoadIdentity()
    gluPerspective(fov, 1.0, nearPlane, farPlane)


def set_modelview_matrix(rotation1, rotation2):
    glMatrixMode(GL_MODELVIEW)
    glLoadIdentity()                       # nahrat jednotkovou matici

    gluLookAt(4.0, 6.0, 18.0,              # bod, odkud se kamera diva
              0.0, 2.0,  0.0,              # bod, kam se kamera diva
              0.0, 1.0,  0.0)              # poloha "stropu" ve scene

    glRotatef(rotation1, 1.0, 0.0, 0.0)    # rotace objektu
    glRotatef(rotation2, 0.0, 1.0, 0.0)


@window.event
def on_draw():
    global r1, r2

    if keys[key.LEFT]:
        r2 -= 2
    if keys[key.RIGHT]:
        r2 += 2
    if keys[key.UP]:
        r1 -= 2
    if keys[key.DOWN]:
        r1 += 2

    clear_buffers()
    set_projection_matrix(fov, nearPlane, farPlane)
    set_modelview_matrix(r1, r2)
    draw_partial_disk()                    # vykresleni dratoveho modelu disku


pyglet.app.run()
</pre>



<p><a name="k13"></a></p>
<h2 id="k13">13. Změna parametrů vykreslovaných kvadrik</h2>

<p>Atributy kvadrik se nastavují před jejich vlastním vykreslením pomocí několika funkcí, které budou popsány v&nbsp;následujících odstavcích.</p>

<h4>gluQuadricDrawStyle()</h4>

<p>Funkcí <i>gluQuadricDrawStyle()</i> se nastavuje styl vykreslování kvadriky, tj.&nbsp;typ grafické primitivy, který bude použit pro reprezentaci povrchu kvadriky. Tato funkce má dva parametry. V&nbsp;prvním parametru <i>quadric</i> se specifikuje objekt kvadriky, který byl předem získán pomocí funkce <i>gluNewQuadric()</i>. Ve druhém parametru <i>drawStyle</i> se předává styl, kterým bude kvadrika vykreslena.</p>

<p>Kvadriku lze vykreslit pomocí jednotlivých bodů, úseček spojujících jednotlivé vrcholy nebo pomocí vyplněných polygonů:</p>

<ul>

<li><strong>GLU_FILL</strong> &ndash; kvadrika je vykreslena pomocí vyplněných polygonů.</li>

<li><strong>GLU_LINE</strong> &ndash; povrch kvadriky je složen z úseček, výsledkem je tedy drátový (<i>wireframe</i>) model.</li>

<li><strong>GLU_SILHOUETTE</strong> &ndash; povrch kvadriky je složen z&nbsp;úseček, ale pouze v&nbsp;těch částech povrchu, kde na sebe navazující plošky nejsou koplanární, tj.&nbsp;mají rozdílnou orientaci a směr svých normálových vektorů.</li>

<li><strong>GLU_POINT</strong> &ndash; povrch kvadriky je složen z&nbsp;jednotlivých bodů.</li>

</ul>

<a href="https://mojefedora.cz/wp-content/uploads/2017/07/19.png"><img class="alignnone size-thumbnail wp-image-9247" src="https://mojefedora.cz/wp-content/uploads/2017/07/19-254x254.png" alt="" width="254" height="254" /></a>
<p><i>Obrázek 19: Koule vykreslená pouze s&nbsp;využitím bodů.</i></p>

<h4>gluQuadricNormals()</h4>

<p>Funkcí <i>gluQuadricNormals()</i> se specifikuje, jakým způsobem se mají generovat normálové vektory na povrchu kvadriky. Normálové vektory se buď nemusí generovat vůbec, mohou se generovat pro každý polygon (použito u flat stínování) nebo samostatně pro každý vrchol (použito u Gouraudova stínování).</p>

<p>Tato funkce má dva parametry. V&nbsp;prvním parametru <i>quadric</i> se specifikuje objekt kvadriky, podobně jako u funkce <i>gluQuadricDrawStyle()</i>.</p>

<p>Ve druhém parametru <i>normal</i> se pomocí symbolické konstanty předává způsob generování normálových vektorů. Tento parametr může nabývat tří hodnot:</p>

<ol>

<li><strong>GLU_NONE</strong> &ndash; normálové vektory nejsou generovány, není je tedy možné použít například při výpočtu osvětlení povrchu.  </li>

<li><strong>GLU_FLAT</strong> &ndash; normálové vektory jsou generovány pro každou vytvořenou plošku, při osvětlení má tedy každá ploška konstantní barvu, jelikož se používá konstantní stínování.</li>

<li><strong>GLU_SMOOTH</strong> &ndash; normálové vektory jsou generovány pro každý vrchol (jsou tedy získány průměrem normálových vektorů jednotlivých plošek, které mají společný vrchol). Tento způsob vytváření normálových vektorů se používá zejména při Gouraudově stínování.</li>

</ol>

<a href="https://mojefedora.cz/wp-content/uploads/2017/07/20.png"><img class="alignnone size-thumbnail wp-image-9248" src="https://mojefedora.cz/wp-content/uploads/2017/07/20-254x254.png" alt="" width="254" height="254" /></a>
<p><i>Obrázek 20: Koule vykreslená formou plošek (ovšem bez osvětlovacího modelu to není příliš viditelné).</i></p>

<h4>gluQuadricOrientation()</h4>

<p>Pomocí funkce <i>gluQuadricOrientation()</i> se nastavuje orientace normálových vektorů při vytváření kvadrik. Normálové vektory mohou být směřovány buď dovnitř tělesa nebo od povrchu tělesa směrem do volného prostoru. Tato funkce má opět dva parametry.</p>

<p>V&nbsp;prvním parametru <i>quadric</i> se specifikuje objekt kvadriky, podobně jako u výše popsaných funkcí <i>gluQuadricDrawStyle()</i> a <i>gluQuadricNormals()</i>.</p>

<p>Ve druhém parametru <i>orientation</i> se specifikuje orientace vytvářených normálových vektorů. Tento parametr může nabývat následujících hodnot:<p>

<ol>

<li><strong>GLU_INSIDE</strong> &ndash; vytvářené normálové vektory budou směřovat dovnitř kvadriky.</li>

<li><strong>GLU_OUTSIDE</strong> &ndash; vytvářené normálové vektory budou mířit směrem do prostoru. Toto chování je nastaveno implicitně a odpovídá smyslu normálových vektorů vytvářených pro účely osvětlování.</li>

</ol>

<a href="https://mojefedora.cz/wp-content/uploads/2017/07/21.png"><img class="alignnone size-thumbnail wp-image-9249" src="https://mojefedora.cz/wp-content/uploads/2017/07/21-254x254.png" alt="" width="254" height="254" /></a>
<p><i>Obrázek 21: Koule vykreslená formou úseček (wireframe model).</i></p>

<h4>gluQuadricTexture()</h4>

<p>Funkcí <i>gluQuadricTexture()</i> se zakazuje nebo povoluje generování texturovacích souřadnic pro vytvářenou kvadriku. Ve druhém parametru této funkce se pomocí symbolických konstant <strong>GL_TRUE</strong> a <strong>GL_FALSE</strong> specifikuje, zda se mají souřadnice do textur generovat či nikoli. Implicitně je generování texturovacích souřadnic vypnuto, protože se jedná o poměrně zdlouhavou operaci.</p>

<p>Pokud se generování texturovacích souřadnic povolí, je pro každý vypočtený vrchol na povrchu kvadriky zavolána i funkce <i>glTexCoord*()</i> s&nbsp;příslušnou souřadnicí.</p>



<p><a name="k14"></a></p>
<h2 id="k14">14. Šestý demonstrační příklad: vykreslení koule s&nbsp;interaktivní změnou všech parametrů modelu</h2>

<p>Šestý příklad je nepatrně komplikovanější, protože je v&nbsp;něm možné několika klávesovými zkratkami změnit styl vykreslení koule:</p>

<table>
<tr><th>Klávesa</th><th>Význam</th></tr>
<tr><td>P</td><td>vykreslení bodů na kouli</td></tr>
<tr><td>L</td><td>vykreslení drátového (wireframe) modelu</td></tr>
<tr><td>F</td><td>vykreslení plošek</td></tr>
<tr><td>&nbsp;</td><td>&nbsp;</td></tr>
<tr><td>PageUp</td><td>zvýšení počtu &bdquo;rovnoběžek&ldquo;</td></tr>
<tr><td>PageDown</td><td>snížení počtu &bdquo;rovnoběžek&ldquo;</td></tr>
<tr><td>Home</td><td>snížení počtu &bdquo;poledníků&ldquo;</td></tr>
<tr><td>End</td><td>zvýšení počtu &bdquo;poledníků&ldquo;</td></tr>
</table>

<a href="https://mojefedora.cz/wp-content/uploads/2017/07/22.png"><img class="alignnone size-thumbnail wp-image-9250" src="https://mojefedora.cz/wp-content/uploads/2017/07/22-254x254.png" alt="" width="254" height="254" /></a>
<p><i>Obrázek 22: Snížením počtu &bdquo;poledníků&ldquo; získáme těleso, které se již dokonalé kouli v&nbsp;žádném případě nepodobá.</i></p>

<p>Nastavení stylu vykreslování se provádí v&nbsp;nové funkci <strong>on_key_press()</strong>, která je volána ve chvíli, kdy uživatel stiskne klávesu (ovšem logiku pro rotaci těles zde nemáme, protože u ní potřebujeme zjistit, zda je klávesa stále stisknuta):</p>

<pre>
@window.event
def on_key_press(symbol, modifiers):
    global depthBufferEnabled
    global quadricDrawStyle
    global sphereSlices, sphereStacks

    if symbol == key.Z:
        depthBufferEnabled = not depthBufferEnabled
    if symbol == key.L:
        quadricDrawStyle = GLU_LINE
    if symbol == key.P:
        quadricDrawStyle = GLU_POINT
    if symbol == key.F:
        quadricDrawStyle = GLU_FILL
    if symbol == key.PAGEUP:
        sphereStacks += 1
    if symbol == key.PAGEDOWN:
        if sphereStacks &gt; 1:
            sphereStacks -= 1
    if symbol == key.HOME:
        if sphereSlices &gt; 1:
            sphereSlices -= 1
    if symbol == key.END:
        sphereSlices += 1
</pre>

<p>Úplný zdrojový kód příkladu vypadá následovně:</p>

<pre>
#!/usr/bin/env python

import pyglet
from pyglet.gl import *
from pyglet.window import key

fov = 70.0                                 # zorny uhel (field of view)
nearPlane = 0.1                            # blizsi orezavaci rovina
farPlane = 90.0                            # vzdalenejsi orezavaci rovina

r1 = 0.0
r2 = 0.0

depthBufferEnabled = False                 # povoleni ci zakaz Z-bufferu

quadricDrawStyle = GLU_LINE                # styl vykreslovani kvadriky
sphereSlices = 10                          # rozdeleni koule na 'poledniky'
sphereStacks = 10                          # rozdeleni koule na 'rovnobezky'


window = pyglet.window.Window(width=500,
                              height=500,
                              caption="Pyglet library")

keys = key.KeyStateHandler()


def init():
    glClearColor(0.0, 0.0, 0.3, 0.0)       # barva pozadi obrazku
    glPolygonMode(GL_FRONT, GL_FILL)       # nastaveni rezimu vykresleni modelu
    glPolygonMode(GL_BACK, GL_FILL)

    # zakaz odstranovani hran nebo sten podle jejich normal
    glDisable(GL_CULL_FACE)
    glDepthFunc(GL_LESS)                   # funkce pro testovani fragmentu

    glShadeModel(GL_SMOOTH)                # nastaveni stinovaciho rezimu
    glPointSize(3.0)


@window.event
def on_resize(width, height):
    init()
    glViewport(0, 0, width, height)        # viditelna oblast pres cele okno


def draw_quadric(drawStyle, slices, stacks):
    radius = 8.0
    quadric = gluNewQuadric()                   # vytvoreni kvadriky
    gluQuadricDrawStyle(quadric, drawStyle)     # nastaveni vlastnosti kvadriky
    gluQuadricNormals(quadric, GLU_SMOOTH)      # smer generovanych normal
    gluSphere(quadric, radius, slices, stacks)  # vykresleni kvadriky
    gluDeleteQuadric(quadric)                   # zruseni kvadriky


def set_depth_buffer(depthBufferEnabled):
    if depthBufferEnabled:
        glEnable(GL_DEPTH_TEST)
    else:
        glDisable(GL_DEPTH_TEST)


def clear_buffers(depthBufferEnabled):
    if depthBufferEnabled:
        # vymazani vsech bitovych rovin barvoveho bufferu i Z bufferu
        glClear(GL_COLOR_BUFFER_BIT | GL_DEPTH_BUFFER_BIT)
    else:
        # vymazani vsech bitovych rovin barvoveho bufferu
        glClear(GL_COLOR_BUFFER_BIT)


def set_projection_matrix(fov, nearPlane, farPlane):
    # zacatek modifikace projekcni matice
    glMatrixMode(GL_PROJECTION)
    # vymazani projekcni matice (=identita)
    glLoadIdentity()
    gluPerspective(fov, 1.0, nearPlane, farPlane)


def set_modelview_matrix(rotation1, rotation2):
    glMatrixMode(GL_MODELVIEW)
    glLoadIdentity()                       # nahrat jednotkovou matici

    gluLookAt(4.0, 6.0, 18.0,              # bod, odkud se kamera diva
              0.0, 2.0,  0.0,              # bod, kam se kamera diva
              0.0, 1.0,  0.0)              # poloha "stropu" ve scene

    glRotatef(rotation1, 1.0, 0.0, 0.0)    # rotace objektu
    glRotatef(rotation2, 0.0, 1.0, 0.0)


@window.event
def on_key_press(symbol, modifiers):
    global depthBufferEnabled
    global quadricDrawStyle
    global sphereSlices, sphereStacks

    if symbol == key.Z:
        depthBufferEnabled = not depthBufferEnabled
    if symbol == key.L:
        quadricDrawStyle = GLU_LINE
    if symbol == key.P:
        quadricDrawStyle = GLU_POINT
    if symbol == key.F:
        quadricDrawStyle = GLU_FILL
    if symbol == key.PAGEUP:
        sphereStacks += 1
    if symbol == key.PAGEDOWN:
        if sphereStacks &gt; 1:
            sphereStacks -= 1
    if symbol == key.HOME:
        if sphereSlices &gt; 1:
            sphereSlices -= 1
    if symbol == key.END:
        sphereSlices += 1


@window.event
def on_draw():
    global r1, r2

    if keys[key.LEFT]:
        r2 -= 2
    if keys[key.RIGHT]:
        r2 += 2
    if keys[key.UP]:
        r1 -= 2
    if keys[key.DOWN]:
        r1 += 2

    clear_buffers(depthBufferEnabled)
    set_depth_buffer(depthBufferEnabled)
    set_projection_matrix(fov, nearPlane, farPlane)
    set_modelview_matrix(r1, r2)
    draw_quadric(quadricDrawStyle, sphereSlices, sphereStacks)


window.push_handlers(keys)
pyglet.app.run()
</pre>

<a href="https://mojefedora.cz/wp-content/uploads/2017/07/23.png"><img class="alignnone size-thumbnail wp-image-9251" src="https://mojefedora.cz/wp-content/uploads/2017/07/23-254x254.png" alt="" width="254" height="254" /></a>
<p><i>Obrázek 23: Snížením počtu &bdquo;rovnoběžek&ldquo; opět získáme těleso, které se již dokonalé kouli v&nbsp;žádném případě nepodobá.</i></p>



<p><a name="k15"></a></p>
<h2 id="k15">15. Repositář s&nbsp;demonstračními příklady</h2>

<p>Všechny dnes popsané demonstrační příklady byly uloženy do Git repositáře dostupného na adrese <a href="https://github.com/tisnik/presentations">https://github.com/tisnik/presentations</a>. Příklady si můžete v&nbsp;případě potřeby stáhnout i jednotlivě bez nutnosti klonovat celý repositář. Pro jejich spuštění je nutné mít nainstalovanou jak knihovnu Pyglet, tak i podpůrné grafické knihovny OpenGL a GLU (což se většinou provede automaticky v&nbsp;rámci instalace balíčku s&nbsp;Pygletem, viz též <a href="https://mojefedora.cz/multimedialni-knihovna-pyglet/">úvodní díl tohoto seriálu</a>):</p>

<table>
<tr><th>Příklad</th><th>Odkaz</th></tr>
<tr><td>54_quadric_sphere.py</td><td><a href="https://github.com/tisnik/presentations/blob/master/pyglet/54_quadric_sphere.py">https://github.com/tisnik/presentations/blob/master/pyglet/54_quadric_sphere.py</a></td></tr>
<tr><td>55_quadric_cylinder.py</td><td><a href="https://github.com/tisnik/presentations/blob/master/pyglet/55_quadric_cylinder.py">https://github.com/tisnik/presentations/blob/master/pyglet/55_quadric_cylinder.py</a></td></tr>
<tr><td>56_quadric_cone.py</td><td><a href="https://github.com/tisnik/presentations/blob/master/pyglet/56_quadric_cone.py">https://github.com/tisnik/presentations/blob/master/pyglet/56_quadric_cone.py</a></td></tr>
<tr><td>57_disk.py</td><td><a href="https://github.com/tisnik/presentations/blob/master/pyglet/57_disk.py">https://github.com/tisnik/presentations/blob/master/pyglet/57_disk.py</a></td></tr>
<tr><td>58_partial_disk.py</td><td><a href="https://github.com/tisnik/presentations/blob/master/pyglet/58_partial_disk.py">https://github.com/tisnik/presentations/blob/master/pyglet/58_partial_disk.py</a></td></tr>
<tr><td>59_guadric_sphere_style.py</td><td><a href="https://github.com/tisnik/presentations/blob/master/pyglet/59_guadric_sphere_style.py">https://github.com/tisnik/presentations/blob/master/pyglet/59_guadric_sphere_style.py</a></td></tr>
</table>



<p><a name="k16"></a></p>
<h2 id="k16">16. Funkce knihovny GLU popsané v&nbsp;tomto článku</h2>

<p>V&nbsp;dnešním článku jsme se seznámili s&nbsp;následujícími jedenácti funkcemi knihovny GLU:</p>

<ol>
<li>gluNewQuadric()</li>
<li>gluQuadricDrawStyle()</li>
<li>gluQuadricOrientation()</li>
<li>gluQuadricNormals()</li>
<li>gluQuadricTexture()</li>
<li>gluQuadricCallback()</li>
<li>gluDeleteQuadric()</li>
<li>gluSphere()</li>
<li>gluCylinder()</li>
<li>gluDisk()</li>
<li>gluPartialDisk()</li>
</ol>



<p><a name="k17"></a></p>
<h2 id="k17">17. Odkazy na Internetu</h2>

<ol>

<li>Pyglet: Module Hierarchy<br />
<a href="https://pythonhosted.org/pyglet/api/module-tree.html">https://pythonhosted.org/pyglet/api/module-tree.html</a>
</li>

<li>Learning Modern OpenGL<br />
<a href="https://www.codeproject.com/articles/771225/learning-modern-opengl">https://www.codeproject.com/articles/771225/learning-modern-opengl</a>
</li>

<li>OpenGL Utility Library<br />
<a href="https://en.wikipedia.org/wiki/OpenGL_Utility_Library">https://en.wikipedia.org/wiki/OpenGL_Utility_Library</a>
</li>

<li>GLU Specification<br />
<a href="https://www.opengl.org/registry/doc/glu1.3.pdf">https://www.opengl.org/registry/doc/glu1.3.pdf</a>
</li>

<li>The Perlin noise math FAQ<br />
<a href="https://mzucker.github.io/html/perlin-noise-math-faq.html">https://mzucker.github.io/html/perlin-noise-math-faq.html</a>
</li>

<li>Perlin noise<br />
<a href="https://en.wikipedia.org/wiki/Perlin_noise">https://en.wikipedia.org/wiki/Perlin_noise</a>
</li>

<li>Perlin Noise Generator (Python recipe)<br />
<a href="http://code.activestate.com/recipes/578470-perlin-noise-generator/">http://code.activestate.com/recipes/578470-perlin-noise-generator/</a>
</li>

<li>Simplex noise demystified<br />
<a href="http://www.itn.liu.se/~stegu/simplexnoise/simplexnoise.pdf">http://www.itn.liu.se/~stegu/simplexnoise/simplexnoise.pdf</a>
</li>

<li>glTexEnv - příkaz OpenGL<br />
<a href="https://www.khronos.org/registry/OpenGL-Refpages/gl2.1/xhtml/glTexEnv.xml">https://www.khronos.org/registry/OpenGL-Refpages/gl2.1/xhtml/glTexEnv.xml</a>
</li>

<li>glGetTexEnv - příkaz OpenGL<br />
<a href="https://www.khronos.org/registry/OpenGL-Refpages/gl2.1/xhtml/glGetTexEnv.xml">https://www.khronos.org/registry/OpenGL-Refpages/gl2.1/xhtml/glGetTexEnv.xml</a>
</li>

<li>Pyglet Home Page<br />
<a href="https://bitbucket.org/pyglet/pyglet/wiki/Home">https://bitbucket.org/pyglet/pyglet/wiki/Home</a>
</li>

<li>Dokumentace k verzi 1.2<br />
<a href="https://pyglet.readthedocs.io/en/pyglet-1.2-maintenance/">https://pyglet.readthedocs.io/en/pyglet-1.2-maintenance/</a>
</li>

<li>Dokumentace k verzi 1.2 ve formátu PDF<br />
<a href="https://readthedocs.org/projects/pyglet/downloads/pdf/pyglet-1.2-maintenance/">https://readthedocs.org/projects/pyglet/downloads/pdf/pyglet-1.2-maintenance/</a>
</li>

<li>PyOpenGL<br />
<a href="http://pyopengl.sourceforge.net/">http://pyopengl.sourceforge.net/</a>
</li>

<li>The #! magic, details about the shebang/hash-bang mechanism on various Unix flavours<br />
<a href="https://www.in-ulm.de/~mascheck/various/shebang/">https://www.in-ulm.de/~mascheck/various/shebang/</a>
</li>

<li>Shebang (Unix)<br />
<a href="https://en.wikipedia.org/wiki/Shebang_%28Unix%29">https://en.wikipedia.org/wiki/Shebang_%28Unix%29</a>
</li>

<li>Domovská stránka systému LÖVE<br />
<a href="http://love2d.org/">http://love2d.org/</a>
</li>

<li>Simple DirectMedia Layer (home page)<br />
<a href="http://www.libsdl.org/">http://www.libsdl.org/</a>
</li>

<li>Simple DirectMedia Layer (Wikipedia)<br />
<a href="https://en.wikipedia.org/wiki/Simple_DirectMedia_Layer">https://en.wikipedia.org/wiki/Simple_DirectMedia_Layer</a>
</li>

<li>Seriál Grafická knihovna OpenGL<br />
<a href="https://www.root.cz/serialy/graficka-knihovna-opengl/">https://www.root.cz/serialy/graficka-knihovna-opengl/</a>
</li>

<li>Pyglet event loop<br />
<a href="http://pyglet.readthedocs.io/en/latest/programming_guide/eventloop.html">http://pyglet.readthedocs.io/en/latest/programming_guide/eventloop.html</a>
</li>

<li>Decorators I: Introduction to Python Decorators<br />
<a href="http://www.artima.com/weblogs/viewpost.jsp?thread=240808">http://www.artima.com/weblogs/viewpost.jsp?thread=240808</a>
</li>

<li>3D Programming in Python - Part 1 <br />
<a href="https://greendalecs.wordpress.com/2012/04/21/3d-programming-in-python-part-1/">https://greendalecs.wordpress.com/2012/04/21/3d-programming-in-python-part-1/</a>
</li>

<li>A very basic Pyglet tutorial<br />
<a href="http://www.natan.termitnjak.net/tutorials/pyglet_basic.html">http://www.natan.termitnjak.net/tutorials/pyglet_basic.html</a>
</li>

<li>Alpha blending<br />
<a href="https://en.wikipedia.org/wiki/Alpha_compositing#Alpha_blending">https://en.wikipedia.org/wiki/Alpha_compositing#Alpha_blending</a>
</li>

</ol>



<p></p><p></p>
<p><small>Autor: <a href="http://www.fit.vutbr.cz/~tisnovpa">Pavel Tišnovský</a> &nbsp; 2017</small></p>
</body>
</html>

