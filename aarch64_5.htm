<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
        "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html>
<head>
<title>Instrukční sada AArch64 (3.část - technologie NEON)</title>
<meta name="Author" content="Pavel Tisnovsky" />
<meta name="Generator" content="vim" />
<meta http-equiv="content-type" content="text/html; charset=utf-8" />
<style type="text/css">
         body {color:#000000; background:#ffffff;}
         h1  {font-family: arial, helvetica, sans-serif; color:#ffffff; background-color:#c00000; text-align:center; padding-left:1em}
         h2  {font-family: arial, helvetica, sans-serif; color:#ffffff; background-color:#0000c0; padding-left:1em; text-align:left}
         h3  {font-family: arial, helvetica, sans-serif; color:#000000; background-color:#c0c0c0; padding-left:1em; text-align:left}
         h4  {font-family: arial, helvetica, sans-serif; color:#000000; background-color:#e0e0e0; padding-left:1em; text-align:left}
         a   {font-family: arial, helvetica, sans-serif;}
         li  {font-family: arial, helvetica, sans-serif; color:#000000; text-align:justify; width:450px;}
         ol  {font-family: arial, helvetica, sans-serif; color:#000000; text-align:justify; width:450px;}
         ul  {font-family: arial, helvetica, sans-serif; color:#000000; text-align:justify; width:450px;}
         p   {font-family: arial, helvetica, sans-serif; color:#000000; text-align:justify;}
         pre {background:#e0e0e0}
</style>
</head>

<body>

<h1>Instrukční sada AArch64 (3.část - technologie NEON)</h1>

<h3>Pavel Tišnovský</h3>

<p></p>

<h1>Úvodník</h1>

<p>Jednou z nejdůležitějších a potenciálně nejužitečnějších vlastností mikroprocesorových jader ARMv8-A s instrukční sadou AArch64 je upravená a v několika směrech vylepšená technologie NEON umožňující provádění SIMD operací. Dnes si řekneme, jaké operace NEON na AArch64 podporuje.</p>



<h2>Obsah</h2>

<p><a href="#k01">1. Instrukční sada AArch64 (3.část - technologie NEON)</a></p>
<p><a href="#k02">2. Úspěšná a užitečná kombinace RISC + SIMD</a></p>
<p><a href="#k03">3. Od technologie VFP k&nbsp;Advanced SIMD (NEON)</a></p>
<p><a href="#k04">4. Podpora technologie NEON v&nbsp;jádrech AArch64</a></p>
<p><a href="#k05">5. Registry používané instrukcemi NEON</a></p>
<p><a href="#k06">6. Použitá terminologie: vector, lane, element</a></p>
<p><a href="#k07">7. Podporované formáty prvků vektorů</a></p>
<p><a href="#k08">8. Práce se skalárními daty</a></p>
<p><a href="#k09">9. Formát instrukcí NEON, prefixy a suffixy u instrukcí</a></p>
<p><a href="#k10">10. Konverze operandů (rozšíření, zmenšení), operace se saturací</a></p>
<p><a href="#k11">11. Příklad různých variant instrukce ADD</a></p>
<p><a href="#k12">12. Typy podporovaných vektorových instrukcí</a></p>
<p><a href="#k13">13. Aritmetické a logické instrukce</a></p>
<p><a href="#k14">14. Instrukce pro provedení jednoho kroku delší operace</a></p>
<p><a href="#k15">15. Podpora SIMD instrukcí ve vyšších programovacích jazycích</a></p>
<p><a href="#k16">16. Odkazy na Internetu</a></p>



<p><a name="k01"></a></p>
<h2 id="k01">1. Instrukční sada AArch64 (3.část - technologie NEON)</h2>

<p>Prakticky každá významnější společnost (v&nbsp;případě mikroprocesorů řady
PowerPC pak dokonce aliance) navrhující mikroprocesory s&nbsp;architekturou
<i>RISC</i> přišla dříve či později na trh s&nbsp;instrukční sadou obsahující
&bdquo;vektorové&ldquo; instrukce, které jsou dnes souhrnně označovány zkratkou
<i>SIMD</i> (původní vektorové instrukce používané na superpočítačích jsou
v&nbsp;některých ohledech flexibilnější, proto budeme v&nbsp;dnešním článku
používat spíše poněkud přesnější zkratku <i>SIMD</i> znamenající &bdquo;single
instruction &ndash; multiple data&ldquo;). Rozšiřující instrukční sady byly
pojmenovávány nejrůznějšími názvy a zkratkami a nikdy vlastně nedošlo &ndash;
na rozdíl od platformy <i>x86</i> &ndash; ke sjednocení těchto instrukcí do
jediné skupiny &bdquo;SIMD pro RISC&ldquo;, což je vlastně logické, protože
procesory <i>RISC</i> jsou mnohdy určeny pro specializované oblasti použití, od
vestavných (embedded) systémů přes smartphony a tablety až po
superpočítače.</p>

<p>Nejvýznamnější implementace instrukcí typu <i>SIMD</i> na mikroprocesorech
s&nbsp;architekturou <i>RISC</i>, ať již se jedná o instrukce určené pro
operace s&nbsp;celými čísly či s&nbsp;čísly reálnými (přesněji řečeno
s&nbsp;plovoucí řádovou čárkou), jsou vypsány v&nbsp;následující tabulce:</p>

<table>
<tr><th>#</th><th>Zkratka/název</th><th>Plný název</th><th>Rodina procesorů</th></tr>
<tr><td>1</td><td>MAX-1  </td><td>Multimedia Acceleration eXtensions v1</td><td>HP-PA RISC    </td></tr>
<tr><td>2</td><td>MAX-2  </td><td>Multimedia Acceleration eXtensions v2</td><td>HP-PA RISC    </td></tr>
<tr><td>3</td><td>VIS 1  </td><td>Visual Instruction v1                </td><td>Set SPARC V9  </td></tr>
<tr><td>4</td><td>VIS 2  </td><td>Visual Instruction v2                </td><td>Set SPARC V9  </td></tr>
<tr><td>5</td><td>AltiVec</td><td>(obchodní názvy Velocity Engine, VMX)</td><td>PowerPC       </td></tr>
<tr><td>6</td><td>MDMX   </td><td>MIPS Digital Media eXtension (MaDMaX)</td><td>MIPS          </td></tr>
<tr><td>7</td><td>MIPS-3D</td><td>MIPS-3D                              </td><td>MIPS          </td></tr>
<tr><td>8</td><td>MVI    </td><td>Motion Video Instructions            </td><td>DEC Alpha     </td></tr>
<tr><td>9</td><td>NEON   </td><td>Advanced SIMD                        </td><td>Cortex (ARMv7, ARMv8)</td></tr>
<tr><td>10</td><td>Packed SIMD</td><td>Packed SIMD (není finalizováno)</td><td>RISC-V</td></tr>
<tr><td>11</td><td>Vector Set</td><td>Vector Set (není finalizováno)</td><td>RISC-V</td></tr>
</table>



<p><a name="k02"></a></p>
<h2 id="k02">2. Úspěšná a užitečná kombinace RISC + SIMD</h2>

<p>Důvodů, proč se instrukce typu <i>SIMD</i> na RISCových procesorech vůbec
objevily, je větší množství. Jedním z&nbsp;nich je to, že se tyto procesory
začaly používat v&nbsp;grafických pracovních stanicích, mj.&nbsp;i pro
zpracování videa, provádění rastrových operací a v&nbsp;některých případech i
3D operací, což je přesně ta oblast, v&nbsp;níž je možné informace zpracovávat
nikoli jen ve formě skalárních dat, ale i jako vektory pevné délky (u 3D
operací se typicky jedná o vektory a matice). Dalším důvodem byla snaha výrobců
RISCových procesorů o průnik na trh s&nbsp;počítači určenými pro náročné
výpočty (jedná se o určitý mezistupeň mezi výkonnými pracovními stanicemi a
superpočítači, v&nbsp;oblasti superpočítačů se však <a
href="https://en.wikipedia.org/wiki/Xeon#Supercomputers">většinou používají
XEONy</a>, s&nbsp;výjimkami projektů typu Flagship2020, které sází právě na
nová ARMovská jádra).</p>

<p>V&nbsp;tomto oboru se mnoho algoritmů provádí nad maticemi a vektory
obsahujícími numerické hodnoty reprezentované v&nbsp;systému plovoucí řádové
čárky (FP: Floating Point). Třetím důvodem je samozřejmě snaha o zvýšení
výpočetního výkonu a právě <i>SIMD</i> instrukce k&nbsp;němu mohou vést, aniž
by bylo nutné radikálně měnit používanou výrobní technologii čipů (zvyšovat
úroveň integrace, snižovat napěťové úrovně či zvyšovat frekvenci,
popř.&nbsp;přidávat drahé vyrovnávací paměti/cache).</p>

<p>Poznámka: instrukce <i>SIMD</i> představují pouze jednou z&nbsp;možností
zvýšení výpočetního výkonu mikroprocesorů. Další variantou jsou &ndash; podle
používané <i>Flynnovy</i> klasifikace sekvenčních a paralelních systémů &ndash;
instrukce/architektura <i>MISD</i> využívaná ve specializovaných aplikacích či
nejobecnější architektura <i>MIMD</i>. Ve více než padesátileté historii vývoje
výpočetní techniky se již objevily všechny čtyři možné kombinace instrukčního a
datového paralelismu. Viz též následující tabulka:</p>

<table>
<tr><th>Zkratka klasifikace</th><th>Anglický význam zkratky</th><th>Využití systémů s&nbsp;danou klasifikací</th></tr>
<tr><td>SISD</td><td>Single Instruction Stream, Single Data</td><td>klasická architektura pro procesory CISC a RISC, stále používána, nejjednodušší pro programátory i překladače</td></tr>
<tr><td>SIMD</td><td>Single Instruction Stream, Multiple Data</td><td>vektorové procesory, GPU, procesory s&nbsp;instrukční sadou SSE/MMX...</td></tr>
<tr><td>MISD</td><td>Multiple Instructions Stream, Single Data Stream</td><td>poměrně speciální případy, řídicí počítače raketoplánů (Space Shuttle)</td></tr>
<tr><td>MIMD</td><td>Multiple Instructions Stream, Multiple Data Stream</td><td>Connection Machine, transputery, symetrické multiprocesory</td></tr>
</table>



<p><a name="k03"></a></p>
<h2 id="k03">3. Od technologie VFP k&nbsp;Advanced SIMD (NEON)</h2>

<p>Pokud se podíváme na historii mikroprocesorů ARM, zjistíme, že cesta
k&nbsp;technologii NEON na jádrech AArch64 vlastně nebyla vůbec přímočará.
První implementace &bdquo;vektorových&ldquo; operací pro procesory ARM
používaly rozhraní pro koprocesory, takže se vlastně používala
paralelní/doplňková instrukční sada. Konkrétně se jednalo o technologii
nazvanou <i>VFP</i> neboli <i>Vector Floating Point</i>. Touto technologií,
která je stále na některých ARMovských jádrech podporována, jsme se již
v&nbsp;seriálu o architekturách počítačů <a
href="https://www.root.cz/clanky/mikroprocesory-arm-a-architektura-vfp-vector-floating-point/">zabývali</a>.
Na tomto místě je vhodné zdůraznit, že i přesto, že se v&nbsp;názvu VFP používá
termín &bdquo;vector&ldquo;, nejednalo se o implementaci skutečných SIMD
operací, protože se prvky vektorů zpracovávaly postupně, tedy sekvenčně (stále
se však jednalo o vylepšení, protože se ušetřilo načtení instrukce a její
dekódování). Z&nbsp;tohoto důvodu byl &bdquo;vektorový režim&ldquo; VFP poměrně
rychle nahrazen novou technologií nazvanou NEON označovanou též Advanced SIMD.
Dnes se s&nbsp;VFP můžeme na některých ARMovských jádrech setkat, další jádra
pak podporují jen <i>VFPLite</i>, kde však každá operace trvá zhruba deset
strojových cyklů!</p>

<p>Technologie NEON již podporovala plnohodnotné SIMD operace, při použití
vektorů s&nbsp;nejmenšími prvky o velikosti jednoho bajtu až šestnáct
operací (například součtu) paralelně. Díky tomu bylo možné implementovat
například dekodér pro známý formát MP3 na mikroprocesoru s&nbsp;taktem pouhých
10 MHz popř.&nbsp;implementovat <a
href="https://cs.wikipedia.org/wiki/AMR_%28kodek%29">AMR kodek</a> na podobném
čipu, ovšem s&nbsp;hodinovým taktem 13 MHz. Při použití klasických výpočtů se
skalárními hodnotami by bylo nutné použít čip s&nbsp;vyšší hodinovou frekvencí
či naopak &ndash; tento výkonný čip by již neměl dostatek výkonu pro provádění
dalších činností. Pro ukázku: ještě mikroprocesory 486DX2 s&nbsp;hodinovou
frekvencí 66 MHz měly s&nbsp;dekódováním MP3 velké problémy a zvládaly jen
menší bitrate a monofonní výstup). Právě díky NEONu se začaly čipy ARM používat
i v&nbsp;některých oblastech, které byly dříve vyhrazeny digitálním signálovým
procesorům.</p>

<p>Mimo VFP a NEON bylo pro některá (dnes již notně stará) jádra ARM vyvinuto
rozšíření pro <i>DSP</i> operace. Konkrétně se jednalo o jádra <i>ARMv5TE</i>.
Nové instrukce byly využitelné například při kódování a dekódování videa, při
zpracování zvukového signálu (včetně zvukové syntézy), práci s&nbsp;rastrovými
obrazy (<i>image processing</i>) atd. Instrukce typu <i>Load &amp; Store</i>
mohly pracovat s&nbsp;registrovými páry, zavedeny byly nové adresovací režimy,
aritmetika se saturací (tj.&nbsp;bez přetečení) a taktéž instrukce typu
&bdquo;multiply and accumulate (<strong>MAC</strong>)&ldquo; 16&times;16 bitů a
32&times;16 bitů, které mohly být v&nbsp;instrukční pipeline vykonány
v&nbsp;rozmezí jednoho taktu (v&nbsp;jejich průběhu se tedy mohly začít
zpracovávat další instrukce). Uvádí se, že při zpracování signálů byla
výkonnost nových instrukcí v&nbsp;jádrech <i>ARMv5TE</i> dvakrát až třikrát
vyšší, než při použití &bdquo;běžných&ldquo; jader <i>ARMv5</i> (samozřejmě za
předpokladu ruční optimalizace kódu, což ostatně až na některé výjimky platí
dodnes, protože <i>intrinsic</i> nejsou samospasitelné).</p>

<p>Další odbočkou byla technologie <i>SIMD extensions for multimedia</i> pro
jádra ARMv6, která byla později nahrazena Advanced SIMD (NEONem).</p>

<p>Poznámka: skutečná míra paralelnosti SIMD operací se na různých ARM jádrech
lišila. Například na Cortex-A8 se sice stále daly provádět operace se
128bitovými registry obsahujícími prvky vektorů (viz navazující kapitoly),
ovšem ve skutečnosti se v&nbsp;daný okamžik zpracovávalo jen 64 bitů,
tj.&nbsp;každá operace se musela provádět dvakrát. Naproti tomu na Cortex-15 se
již zpracovávaly celé 128bitové registry.</p>



<p><a name="k04"></a></p>
<h2 id="k04">4. Podpora technologie NEON v&nbsp;jádrech AArch64</h2>

<p>Podle specifikace by všechny <a
href="http://infocenter.arm.com/help/index.jsp?topic=/com.arm.doc.den0024a/BABIGHEB.html">standardní
implementace jader ARMv8 (s&nbsp;instrukční sadou AArch64) měly technologii
NEON podporovat</a>, stejně jako operace s&nbsp;FP hodnotami (jinými slovy
&ndash; už není nutné řešit například problém &bdquo;hardfp versus
softfp&ldquo;). Ovšem v&nbsp;budoucnosti se pravděpodobně setkáme i se
specializovanými jádry nakonfigurovanými odlišným způsobem, například:</p>

<ul>
<li>NEON nebude vůbec podporován.</li>
<li>FP operace nebudou vůbec podporovány.</li>
<li>NEON+FP budou podporovány, ale bez zpracování výjimek u FP operací.</li>
</ul>



<p><a name="k05"></a></p>
<h2 id="k05">5. Registry používané instrukcemi NEON</h2>

<p>Původní technologie NEON, která byla implementovaná na 32bitových jádrech
ARM, používala sadu třiceti dvou nových pracovních registrů, přičemž každý
registr měl šířku 64 bitů. Tato sada byla oddělena od klasických celočíselných
pracovních registrů, což samozřejmě zvýšilo možnosti překladače při
optimalizacích kódu. Nové registry byly pojmenovány <strong>D0</strong> až
<strong>D31</strong> (<strong>D</strong> = double), popř.&nbsp;mohly být vždy
dva sousední registry spojeny do jednoho 128bitového registru (ty byly
pojmenovány <strong>Q0</strong> až <strong>Q15</strong>, <strong>Q</strong> =
quad). Pokud jádro kromě NEONu podporovalo i výše zmíněnou VFP (konkrétně VFPv3
nebo VFPv4), byly registry <strong>D0</strong> až <strong>D31</strong> sdíleny
mezi oběma jednotkami.</p>

<p>U jader ARMv8-A s&nbsp;instrukční sadou AArch64 došlo v&nbsp;této oblasti
k&nbsp;vylepšení, protože programátoři nově mají k&nbsp;dispozici 32 pracovních
registrů, ovšem nyní se jedná o plnohodnotné 128bitové registry. Tyto registry
jsou současně používány i při běžných matematických operacích s&nbsp;hodnotami
uloženými v&nbsp;systému plovoucí řádové čárky a taktéž kryptografickým
modulem. Došlo ještě k&nbsp;další změně &ndash; již nedochází k&nbsp;rozdělení
jednoho registru pro typ <i>double</i> do dvou registrů pro hodnotu typu
<i>single/float</i>, jako tomu bylo u <a
href="https://www.root.cz/clanky/mikroprocesory-arm-a-architektura-vfp-vector-floating-point/#k02">VFP</a>.
Nově je možné každý registr použít jako 128bitový vektor, pro uložení hodnoty
<i>double</i> (spodních 64 bitů), uložení hodnoty typu <i>single/float</i>
(spodních 32 bitů) popř.&nbsp;pro uložení hodnoty typu <i>half float</i>
(spodních 16 bitů). Horní bity jsou při čtení ignorovány, při zápisu
nulovány:</p>

<table>
<tr><th>Jméno</th><th>Význam</th></tr>
<tr><td>v0..v31</td><td>128bitové registry</td></tr>
<tr><td>d0..d31</td><td>spodních 64 bitů registrů v0..v31, použito pro hodnoty typu <i>double</i></td></tr>
<tr><td>s0..s31</td><td>spodních 32 bitů registrů v0..v31, použito pro hodnoty typu <i>single/float</i></td></tr>
<tr><td>h0..h31</td><td>spodních 16 bitů registrů v0..v31, použito pro hodnoty typu <i>half float</i></td></tr>
</table>

<p>Poznámka: datový typ <i>half float</i> o šířce pouhých šestnácti bitů je
podporován jen několika instrukcemi. Nejedná se totiž o formát určený primárně
pro zpracování hodnot, ale pouze o formát pro načtení či naopak uložení
výsledků. S&nbsp;tímto formátem se můžeme setkat u grafických akcelerátorů či
v&nbsp;OpenCL. Zde má použití <i>half float</i> svůj význam, protože u
některých algoritmů se úzkým hrdlem výpočtu stává přenosová rychlost sběrnice,
rychlost přístupu do operační paměti či výpadky cache (a u pole prvků typu
<i>half float</i> bude výpadků méně, než u prvků typu <i>single/float</i> či
dokonce <i>double</i>).</p>



<p><a name="k06"></a></p>
<h2 id="k06">6. Použitá terminologie: vector, lane, element</h2>

<p>U technologie NEON se používá následující terminologie:</p>

<ol>

<li><i>Vector</i> vždy značí 64bitovou či 128bitovou část pracovního registru
<strong>Vn</strong>, která je rozdělena na prvky.</li>

<li><i>Element</i> je prvek vektoru.</li>

<li><i>Lane</i> označuje index prvku vektoru. U mnoha operací se kombinují
prvky z&nbsp;různých vektorů, které mají shodný index.</li>

</ol>

<p>Indexy jednotlivých <i>lanes</i> se zvyšují směrem od nejnižšího bitu
k&nbsp;bitu nejvyššímu. Pro pracovní registry <strong>V0</strong> až
<strong>V31</strong> a použitý typ prvků mohou indexy nabývat těchto
hodnot:</p>

<table>
<tr><th>Vektor</th><th>Indexy jednotlivých lanes</th></tr>
<tr><td>128bitový registr</td><td>&times;</td></tr>
<tr><td>2&times;64 bitů</td><td>1, 0</td></tr>
<tr><td>4&times;32 bitů</td><td>3, 2, 1, 0</td></tr>
<tr><td>8&times;16 bitů</td><td>7, 6, ..0</td></tr>
<tr><td>16&times;8 bitů</td><td>15..0</td></tr>
</table>

<p>Víme již, že je možné namísto 128bitových vektorů používat i vektory
64bitové, tj.&nbsp;registrové aliasy <strong>D0</strong> až
<strong>D31</strong>. Zde samozřejmě bude k&nbsp;dispozici jen polovina
indexů:</p>

<table>
<tr><th>Vektor</th><th>Indexy jednotlivých lanes</th></tr>
<tr><td>64bitový registr</td><td>&times;</td></tr>
<tr><td>1&times;64 bitů</td><td>0</td></tr>
<tr><td>2&times;32 bitů</td><td>1, 0</td></tr>
<tr><td>4&times;16 bitů</td><td>3, 2, 1, 0</td></tr>
<tr><td>8&times;8 bitů</td><td>7, 6, ..0</td></tr>
</table>



<p><a name="k07"></a></p>
<h2 id="k07">7. Podporované formáty prvků vektorů</h2>

<p>Instrukce NEON na 64bitových mikroprocesorech AArch64 podporují vektory
s&nbsp;elementy (prvky) těchto typů:</p>

<table>
<tr><th>Typ</th><th>Šířka</th><th>Poznámka</th></tr>
<tr><td>float</td><td>32 bitů</td><td>hodnota s&nbsp;plovoucí řádovou čárkou, jednoduchá přesnost</td></tr>
<tr><td>double</td><td>64 bitů</td><td>hodnota s&nbsp;plovoucí řádovou čárkou, dvojitá přesnost</td></tr>
<tr><td>half</td><td>32 bitů</td><td>hodnota s&nbsp;plovoucí řádovou čárkou, poloviční přesnost (jen převody)</td></tr>
<tr><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td></tr>
<tr><td>int8</td><td>8 bitů</td><td>osmibitové celé číslo se znaménkem, obecné použití</td></tr>
<tr><td>int16</td><td>16 bitů</td><td>16bitové celé číslo se znaménkem, obecné použití</td></tr>
<tr><td>int32</td><td>32 bitů</td><td>32bitové celé číslo se znaménkem, obecné použití</td></tr>
<tr><td>int64</td><td>64 bitů</td><td>64bitové celé číslo se znaménkem, obecné použití</td></tr>
<tr><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td></tr>
<tr><td>uint8</td><td>8 bitů</td><td>osmibitové celé číslo bez znaménka, typicky barvová složka pixelu</td></tr>
<tr><td>uint16</td><td>16 bitů</td><td>16bitové celé číslo bez znaménka, typicky zvukový vzorek</td></tr>
<tr><td>uint32</td><td>32 bitů</td><td>32bitové celé číslo bez znaménka, obecné použití</td></tr>
<tr><td>uint64</td><td>64 bitů</td><td>64bitové celé číslo bez znaménka, obecné použití</td></tr>
<tr><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td></tr>
<tr><td>polynomial</td><td>8 bitů</td><td>používán pro výpočty korekcí chyb atd.</td></tr>
<tr><td>polynomial</td><td>16 bitů</td><td>používán pro výpočty korekcí chyb atd.</td></tr>
</table>

<p>Poznámka: některé typy (formáty) jsou dostupné jen pro NEON implementovaný
na mikroprocesorech s&nbsp;architekturou AArch64. Týká se to zejména použití
vektorů s&nbsp;elementy typu <i>double</i>.</p>



<p><a name="k08"></a></p>
<h2 id="k08">8. Práce se skalárními daty</h2>

<p>I přesto, že je technologie SIMD primárně určena pro provádění operací
s&nbsp;prvky vektorů, nabízí NEON i mnoho instrukcí pracujících se skalárními
daty. U těchto instrukcí se pracuje buď s&nbsp;celými 128bitovými hodnotami či
s&nbsp;hodnotami 64bitovými popř.&nbsp;&bdquo;pouze&ldquo; 32bitovými.
V&nbsp;prvním případě jsou zdrojové a cílové registry pojmenovány
<strong>Vn</strong>, v&nbsp;případě druhém pak <strong>Dn</strong> (zde se tedy
využije spodních 64 bitů původně 128bitového registru, u 32bitových operací jen
spodních 32 bitů). Příkladem může být instrukce <strong>ADD</strong>, která
může být prováděna na běžné ALU, kde bude pracovat s&nbsp;registry
<strong>Wn</strong> či <strong>Xn</strong>. NEON nabízí stejnou instrukci,
ovšem pro použití s&nbsp;registry <strong>Dn</strong>, které obsahují celé
číslo (pro FP operace je určena instrukce <strong>FADD</strong>). Některé
instrukce pro zpracování skalárních dat jsou vypsány v&nbsp;následující
tabulce:</p>

<table>
<tr><th>Instrukce</th><th>Poznámka</th></tr>
<tr><td>ABS</td><td></td></tr>
<tr><td>ADDP</td><td></td></tr>
<tr><td>CMEQ</td><td></td></tr>
<tr><td>CMEQ</td><td></td></tr>
<tr><td>CMGE</td><td></td></tr>
<tr><td>CMGE</td><td></td></tr>
<tr><td>CMGT</td><td></td></tr>
<tr><td>CMGT</td><td></td></tr>
<tr><td>CMHI</td><td></td></tr>
<tr><td>CMHS</td><td></td></tr>
<tr><td>CMLE</td><td></td></tr>
<tr><td>CMLT</td><td></td></tr>
<tr><td>CMTST</td><td></td></tr>
<tr><td>DUP</td><td></td></tr>
<tr><td>FABD</td><td></td></tr>
<tr><td>FACGE</td><td></td></tr>
<tr><td>FACGT</td><td></td></tr>
<tr><td>FADDP</td><td></td></tr>
<tr><td>FCMEQ</td><td></td></tr>
<tr><td>FCMEQ</td><td></td></tr>
<tr><td>FCMGE</td><td></td></tr>
<tr><td>FCMGE</td><td></td></tr>
<tr><td>FCMGT</td><td></td></tr>
<tr><td>FCMGT</td><td></td></tr>
<tr><td>FCMLE</td><td></td></tr>
<tr><td>FCMLT</td><td></td></tr>
<tr><td>FCVTAS</td><td></td></tr>
<tr><td>FCVTAU</td><td></td></tr>
<tr><td>FCVTMS</td><td></td></tr>
<tr><td>FCVTMU</td><td></td></tr>
<tr><td>FCVTNS</td><td></td></tr>
<tr><td>FCVTNU</td><td></td></tr>
<tr><td>FCVTPS</td><td></td></tr>
<tr><td>FCVTPU</td><td></td></tr>
<tr><td>FCVTXN</td><td></td></tr>
<tr><td>FCVTZS</td><td></td></tr>
<tr><td>FCVTZS</td><td></td></tr>
<tr><td>FCVTZU</td><td></td></tr>
<tr><td>FCVTZU</td><td></td></tr>
<tr><td>FMAXNMP</td><td></td></tr>
<tr><td>FMAXP</td><td></td></tr>
<tr><td>FMINNMP</td><td></td></tr>
<tr><td>FMINP</td><td></td></tr>
<tr><td>FMLA</td><td></td></tr>
<tr><td>FMLS</td><td></td></tr>
<tr><td>FMUL</td><td></td></tr>
<tr><td>FMULX</td><td></td></tr>
<tr><td>FMULX</td><td></td></tr>
<tr><td>FRECPE</td><td></td></tr>
<tr><td>FRECPS</td><td></td></tr>
<tr><td>FRECPX</td><td></td></tr>
<tr><td>FRSQRTE</td><td></td></tr>
<tr><td>FRSQRTS</td><td></td></tr>
<tr><td>MOV</td><td></td></tr>
<tr><td>NEG</td><td></td></tr>
<tr><td>SCVTF</td><td></td></tr>
<tr><td>SCVTF</td><td></td></tr>
<tr><td>SHL</td><td></td></tr>
<tr><td>SLI</td><td></td></tr>
<tr><td>SQABS</td><td>výpočet se saturací, operand je celé číslo se znaménkem</td></tr>
<tr><td>SQADD</td><td>výpočet se saturací, operand je celé číslo se znaménkem</td></tr>
<tr><td>SQDMLAL</td><td>výpočet se saturací, operand je celé číslo se znaménkem</td></tr>
<tr><td>SQDMLAL</td><td>výpočet se saturací, operand je celé číslo se znaménkem</td></tr>
<tr><td>SQDMLSL</td><td>výpočet se saturací, operand je celé číslo se znaménkem</td></tr>
<tr><td>SQDMLSL</td><td>výpočet se saturací, operand je celé číslo se znaménkem</td></tr>
<tr><td>SQDMULH</td><td>výpočet se saturací, operand je celé číslo se znaménkem</td></tr>
<tr><td>SQDMULH</td><td>výpočet se saturací, operand je celé číslo se znaménkem</td></tr>
<tr><td>SQDMULL</td><td>výpočet se saturací, operand je celé číslo se znaménkem</td></tr>
<tr><td>SQDMULL</td><td>výpočet se saturací, operand je celé číslo se znaménkem</td></tr>
<tr><td>SQNEG</td><td>výpočet se saturací, operand je celé číslo se znaménkem</td></tr>
<tr><td>SQRDMULH</td><td>výpočet se saturací, operand je celé číslo se znaménkem</td></tr>
<tr><td>SQRDMULH</td><td>výpočet se saturací, operand je celé číslo se znaménkem</td></tr>
<tr><td>SQRSHL</td><td>výpočet se saturací, operand je celé číslo se znaménkem</td></tr>
<tr><td>SQRSHRN</td><td>výpočet se saturací, operand je celé číslo se znaménkem</td></tr>
<tr><td>SQRSHRUN</td><td>výpočet se saturací, operand je celé číslo se znaménkem</td></tr>
<tr><td>SQSHL</td><td>výpočet se saturací, operand je celé číslo se znaménkem</td></tr>
<tr><td>SQSHL</td><td>výpočet se saturací, operand je celé číslo se znaménkem</td></tr>
<tr><td>SQSHLU</td><td>výpočet se saturací, operand je celé číslo se znaménkem</td></tr>
<tr><td>SQSHRN</td><td>výpočet se saturací, operand je celé číslo se znaménkem</td></tr>
<tr><td>SQSHRUN</td><td>výpočet se saturací, operand je celé číslo se znaménkem</td></tr>
<tr><td>SQSUB</td><td>výpočet se saturací, operand je celé číslo se znaménkem</td></tr>
<tr><td>SQXTN</td><td>výpočet se saturací, operand je celé číslo se znaménkem</td></tr>
<tr><td>SQXTUN</td><td>výpočet se saturací, operand je celé číslo se znaménkem</td></tr>
<tr><td>SRI</td><td></td></tr>
<tr><td>SRSHL</td><td></td></tr>
<tr><td>SRSHR</td><td></td></tr>
<tr><td>SRSRA</td><td></td></tr>
<tr><td>SSHL</td><td></td></tr>
<tr><td>SSHR</td><td></td></tr>
<tr><td>SSRA</td><td></td></tr>
<tr><td>SUB</td><td></td></tr>
<tr><td>SUQADD</td><td></td></tr>
<tr><td>UCVTF</td><td></td></tr>
<tr><td>UCVTF</td><td></td></tr>
<tr><td>UQADD</td><td>výpočet se saturací, operand je celé číslo bez znaménka</td></tr>
<tr><td>UQRSHL</td><td>výpočet se saturací, operand je celé číslo bez znaménka</td></tr>
<tr><td>UQRSHRN</td><td>výpočet se saturací, operand je celé číslo bez znaménka</td></tr>
<tr><td>UQSHL</td><td>výpočet se saturací, operand je celé číslo bez znaménka</td></tr>
<tr><td>UQSHL</td><td>výpočet se saturací, operand je celé číslo bez znaménka</td></tr>
<tr><td>UQSHRN</td><td>výpočet se saturací, operand je celé číslo bez znaménka</td></tr>
<tr><td>UQSUB</td><td>výpočet se saturací, operand je celé číslo bez znaménka</td></tr>
<tr><td>UQXTN</td><td>výpočet se saturací, operand je celé číslo bez znaménka</td></tr>
<tr><td>URSHL</td><td></td></tr>
<tr><td>URSHR</td><td></td></tr>
<tr><td>URSRA</td><td></td></tr>
<tr><td>USHL</td><td></td></tr>
<tr><td>USHR</td><td></td></tr>
<tr><td>USQADD</td><td></td></tr>
<tr><td>USRA</td><td></td></tr>
</table>



<p><a name="k09"></a></p>
<h2 id="k09">9. Formát instrukcí NEON, prefixy a suffixy u instrukcí</h2>

<p>Pojmenování instrukcí technologie NEON je u AArch64 v&nbsp;porovnání
s&nbsp;původní 32bitovou architekturou odlišné, s&nbsp;čímž se setkají
především programátoři pracující s&nbsp;assemblerem nebo s&nbsp;debuggerem.
Zejména došlo k&nbsp;odstranění prefixového znaku <strong>V</strong>, protože
způsob provádění instrukce je odvozen z&nbsp;typů operandů. Namísto toho se
používají prefixy <strong>S</strong>, <strong>U</strong>, <strong>F</strong> a
<strong>P</strong> s&nbsp;následujícím významem:</p>

<table>
<tr><th>Prefix</th><th>Význam</th></tr>
<tr><td>S</td><td>signed</td></tr>
<tr><td>U</td><td>unsigned</td></tr>
<tr><td>F</td><td>floating point</td></tr>
<tr><td>P</td><td>polynomial</td></tr>
</table>

<p>Přesná konfigurace vektorů, které se používají jako vstupní a výstupní
operandy instrukcí, je určena suffixem uvedeným za jméno příslušného registru,
ať již se jedná o registr zdrojový či cílový.  Suffix se od jména registru
odděluje tečkou:</p>

<table>
<tr><th>Suffix</th><th>Význam</th><th>Šířka vektoru</th></tr>
<tr><td>Vn.8B </td><td>8 bitů &times; 8</td><td>64 bitů</td></tr>
<tr><td>Vn.16B</td><td>8 bitů &times; 16</td><td>128 bitů</td></tr>
<tr><td>Vn.4H </td><td>16 bitů či half &times; 4</td><td>64 bitů</td></tr>
<tr><td>Vn.8H </td><td>16 bitů či half &times; 8</td><td>128 bitů</td></tr>
<tr><td>Vn.2S </td><td>32 bitů či single/float &times; 2</td><td>64 bitů</td></tr>
<tr><td>Vn.4S </td><td>32 bitů či single/float &times; 4</td><td>128 bitů</td></tr>
<tr><td>Vn.1D </td><td>64 bitů či double &times; 1</td><td>64 bitů</td></tr>
<tr><td>Vn.2D </td><td>64 bitů či double &times; 2</td><td>128 bitů</td></tr>
</table>

<p>Zde můžeme vidět, že je skutečně nutné použít kombinaci prefixu a suffixu,
aby bylo možné rozlišit například součet vektorů čtyř 32bitových celých čísel
se znaménkem od součtu 32bitových celých čísel bez znaménka či čtyř hodnot typu
single/float &ndash; ve všech případech mají vektory stejný počet prvků a prvky
mají stejnou bitovou šířku, ale prováděná operace může být diametrálně
odlišná.</p>

<p>Poznámka: u <a
href="http://infocenter.arm.com/help/topic/com.arm.doc.ihi0073a/IHI0073A_arm_neon_intrinsics_ref.pdf">intrinsic</a>
se prefix <strong>V</strong> stále používá.</p>



<p><a name="k10"></a></p>
<h2 id="k10">10. Konverze operandů (rozšíření, zmenšení), operace se saturací</h2>

<p>Některé instrukce, typicky základní aritmetické instrukce prováděné nad
prvky vektorů, existují v&nbsp;několika variantách:</p>

<ul>

<li>V&nbsp;<i>normální</i> variantě se paralelně provádí operace nad
jednotlivými prvky bez dalších úprav či konverzí. U této varianty je typ
výsledného vektoru shodný s&nbsp;vektory zdrojovými.</li>

<li>U varianty označované slovem <i>long (lengtening)</i> se nejprve prvky
vstupních vektorů zkonvertují na dvojnásobnou šířku (osm bitů &rarr; 16 bitů,
16 bitů &rarr; 32 bitů či 32 bitů &rarr; 64 bitů), provede se zvolená operace a
výsledky se uloží do cílového vektoru. Vzhledem k&nbsp;tomu, že došlo
k&nbsp;rozšíření prvků vektorů, je možné zpracovat vždy jen polovinu prvků,
protože druhou polovinu by nebylo možné nikam uložit. Z&nbsp;tohoto důvodu vždy
existují dvě varianty každé instrukce, přičemž druhá varianta používá suffix
<strong>2</strong> pro odlišení, zda se má pracovat s&nbsp;horní polovinou či
dolní polovinou vektoru.</li>

<li>Další varianta se jmenuje <i>wide (widening)</i> a dochází u ní ke
kombinaci dvou zdrojových vektorů různých typů. Druhý zdrojový vektor obsahuje
prvky s&nbsp;poloviční šířkou, které jsou opět zkonvertovány a následně je
provedena zvolená operace. Opět platí, že každá instrukce existuje ve dvou
variantách podle toho, kterou polovinu druhého zdrojového vektoru
zpracovává.</li>

<li>Opačná situace nastává u varianty označované <i>narrow (narrowing)</i>, kde
se nejprve provede zvolená operace a následně se prvky sníží na poloviční
šířku.</li>

<li>Další varianty rozlišují provedení operace se saturací. V&nbsp;tomto
případě se používají prefixy <strong>SQ</strong> a <strong>UQ</strong> podle
toho, zda prvky vstupních vektorů jsou hodnoty se znaménkem či bez
znaménka.</li>

<li>Posledním suffixem je znak <strong>P</strong> značící, že se zvolená operace
nemá provést vždy mezi korespondujícími prvky dvou vstupních vektorů, ale vždy
mezi dvěma sousedními prvky prvního zdrojového vektoru a posléze mezi stejnými
páry druhého zdrojového vektoru.</li>

</ul>



<p><a name="k11"></a></p>
<h2 id="k11">11. Příklad různých variant instrukce ADD</h2>

<p>Vzhledem k&nbsp;tomu, že u technologie NEON je možné používat vektory
s&nbsp;prvky různých typů a navíc se při výpočtech může provádět konverze
operandů, je celkový počet kombinací instrukcí velmi vysoký. Můžeme si to
ukázat na instrukci <strong>ADD</strong>, tj.&nbsp;instrukci, která má provést
součet. Přitom se může jednat o součet dvou skalárů (různých typů) nebo o
součet prvků vektorů, přičemž počet prvků a jejich typ se může lišit
(připomeňme si, že můžeme použít &bdquo;jen&ldquo; 64bitové vektory či naopak
vektory 128bitové):</p>

<table>
<tr><th>Instrukce</th><th>Význam/provedená operace</th></tr>
<tr><td>ADD Wd, Wn, Wm</td><td>skalární součet s&nbsp;32bitovými operandy typu celé číslo</td></tr>
<tr><td>ADD Xd, Xn, Xm</td><td>skalární součet se 64bitovými operandy typu celé číslo</td></tr>
<tr><td>ADD Dd, Dn, Dm</td><td>skalární součet se 64bitovými operandy typu celé číslo, tentokrát s&nbsp;registry NEONu</td></tr>
<tr><td>&nbsp;</td><td>&nbsp;</td></tr>
<tr><td>FADD Sd, Sn, Sm</td><td>skalární součet s&nbsp;FP operandy typu <i>float/single</i></td></tr>
<tr><td>FADD Dd, Dn, Dm</td><td>skalární součet s&nbsp;FP operandy typu <i>double</i></td></tr>
<tr><td>&nbsp;</td><td>&nbsp;</td></tr>
<tr><td>SQDD Vd.typ, Vn.typ, Vm.typ</td><td>skalární součet se saturací pro celá čísla se znaménkem</td></tr>
<tr><td>UQDD Vd.typ, Vn.typ, Vm.typ</td><td>skalární součet se saturací pro celá čísla bez znaménka</td></tr>
<tr><td>&nbsp;</td><td>&nbsp;</td></tr>
<tr><td>ADD Vd.8B, Vn.8B, Vm.8B</td><td>&bdquo;vektorový&ldquo; součet osmi prvků typu byte</td></tr>
<tr><td>ADD Vd.16B, Vn.16B, Vm.16B</td><td>&bdquo;vektorový&ldquo; součet šestnácti prvků typu byte</td></tr>
<tr><td>ADD Vd.4H, Vn.4H, Vm.4H</td><td>&bdquo;vektorový&ldquo; součet čtyř prvků typu 16bit integer</td></tr>
<tr><td>ADD Vd.8H, Vn.8H, Vm.8H</td><td>&bdquo;vektorový&ldquo; součet osmi prvků typu 16bit integer</td></tr>
<tr><td>ADD Vd.2S, Vn.2S, Vm.2S</td><td>&bdquo;vektorový&ldquo; součet dvou prvků typu 32bit integer</td></tr>
<tr><td>ADD Vd.4S, Vn.4S, Vm.4S</td><td>&bdquo;vektorový&ldquo; součet čtyř prvků typu 32bit integer</td></tr>
<tr><td>ADD Vd.2D, Vn.2D, Vm.2D</td><td>&bdquo;vektorový&ldquo; součet dvou prvků typu 64bit integer</td></tr>
<tr><td>&nbsp;</td><td>&nbsp;</td></tr>
<tr><td>FADD Vd.2S, Vn.2S, Vm.2S</td><td>&bdquo;vektorový&ldquo; součet dvou prvků typu <i>float/single</i></td></tr>
<tr><td>FADD Vd.4S, Vn.4S, Vm.4S</td><td>&bdquo;vektorový&ldquo; součet čtyř prvků typu <i>float/single</i></td></tr>
<tr><td>FADD Vd.2D, Vn.2D, Vm.2D</td><td>&bdquo;vektorový&ldquo; součet dvou prvků typu <i>double</i></td></tr>
<tr><td>&nbsp;</td><td>&nbsp;</td></tr>
<tr><td>UADDL Vd.8H, Vn.8B, Vm.8B</td><td>&bdquo;vektorový&ldquo; součet s&nbsp;rozšířením operandů bez znaménka (byte &rarr; 16bit integer)</td></tr>
<tr><td>UADDL Vd.4S, Vn.4H, Vm.4H</td><td>&bdquo;vektorový&ldquo; součet s&nbsp;rozšířením operandů bez znaménka (16bit integer &rarr; 32bit integer)</td></tr>
<tr><td>UADDL Vd.2D, Vn.2S, Vm.2S</td><td>&bdquo;vektorový&ldquo; součet s&nbsp;rozšířením operandů bez znaménka (32bit integer &rarr; 64bit integer)</td></tr>
<tr><td>UADDL2 Vd.8H, Vn.8B, Vm.8B</td><td>jako první UADDL, ale pro druhou polovinu vektoru</td></tr>
<tr><td>UADDL2 Vd.4S, Vn.4H, Vm.4H</td><td>jako první UADDL, ale pro druhou polovinu vektoru</td></tr>
<tr><td>UADDL2 Vd.2D, Vn.2S, Vm.2S</td><td>jako první UADDL, ale pro druhou polovinu vektoru</td></tr>
<tr><td>&nbsp;</td><td>&nbsp;</td></tr>
<tr><td>SADDL Vd.8H, Vn.8B, Vm.8B</td><td>&bdquo;vektorový&ldquo; součet s&nbsp;rozšířením operandů se znaménkem (byte &rarr; 16bit integer)</td></tr>
<tr><td>SADDL Vd.4S, Vn.4H, Vm.4H</td><td>&bdquo;vektorový&ldquo; součet s&nbsp;rozšířením operandů se znaménkem (16bit integer &rarr; 32bit integer)</td></tr>
<tr><td>SADDL Vd.2D, Vn.2S, Vm.2S</td><td>&bdquo;vektorový&ldquo; součet s&nbsp;rozšířením operandů se znaménkem (32bit integer &rarr; 64bit integer)</td></tr>
<tr><td>SADDL2 Vd.8H, Vn.8B, Vm.8B</td><td>jako první SADDL, ale pro druhou polovinu vektoru</td></tr>
<tr><td>SADDL2 Vd.4S, Vn.4H, Vm.4H</td><td>jako první SADDL, ale pro druhou polovinu vektoru</td></tr>
<tr><td>SADDL2 Vd.2D, Vn.2S, Vm.2S</td><td>jako první SADDL, ale pro druhou polovinu vektoru</td></tr>
<tr><td>&nbsp;</td><td>&nbsp;</td></tr>
<tr><td>UADDW Vd.8H, Vn.8H, Vm.8B</td><td>&bdquo;vektorový&ldquo; součet s&nbsp;rozšířením operandu bez znaménka (byte &rarr; 16bit integer)</td></tr>
<tr><td>UADDW Vd.4S, Vn.4S, Vm.4H</td><td>&bdquo;vektorový&ldquo; součet s&nbsp;rozšířením operandu bez znaménka (16bit integer &rarr; 32bit integer)</td></tr>
<tr><td>UADDW Vd.2D, Vn.2D, Vm.2S</td><td>&bdquo;vektorový&ldquo; součet s&nbsp;rozšířením operandu bez znaménka (32bit integer &rarr; 64bit integer)</td></tr>
<tr><td>UADDW2 Vd.8H, Vn.8H, Vm.8B</td><td>jako první UADDW, ale pro druhou polovinu vektoru</td></tr>
<tr><td>UADDW2 Vd.4S, Vn.4S, Vm.4H</td><td>jako první UADDW, ale pro druhou polovinu vektoru</td></tr>
<tr><td>UADDW2 Vd.2D, Vn.2D, Vm.2S</td><td>jako první UADDW, ale pro druhou polovinu vektoru</td></tr>
<tr><td>&nbsp;</td><td>&nbsp;</td></tr>
<tr><td>SADDW Vd.8H, Vn.8H, Vm.8B</td><td>&bdquo;vektorový&ldquo; součet s&nbsp;rozšířením operandu se znaménkem (byte &rarr; 16bit integer)</td></tr>
<tr><td>SADDW Vd.4S, Vn.4S, Vm.4H</td><td>&bdquo;vektorový&ldquo; součet s&nbsp;rozšířením operandu se znaménkem (16bit integer &rarr; 32bit integer)</td></tr>
<tr><td>SADDW Vd.2D, Vn.2D, Vm.2S</td><td>&bdquo;vektorový&ldquo; součet s&nbsp;rozšířením operandu se znaménkem (32bit integer &rarr; 64bit integer)</td></tr>
<tr><td>SADDW2 Vd.8H, Vn.8H, Vm.8B</td><td>jako první SADDW, ale pro druhou polovinu vektoru</td></tr>
<tr><td>SADDW2 Vd.4S, Vn.4S, Vm.4H</td><td>jako první SADDW, ale pro druhou polovinu vektoru</td></tr>
<tr><td>SADDW2 Vd.2D, Vn.2D, Vm.2S</td><td>jako první SADDW, ale pro druhou polovinu vektoru</td></tr>
<tr><td>&nbsp;</td><td>&nbsp;</td></tr>
<tr><td>ADDP Vd.typ, Vn.typ, Vm.typ</td><td>součet sousedních párů prvků obou zdrojových vektorů</td></tr>
<tr><td>FADDP Vd.typ, Vn.typ, Vm.typ</td><td>dtto, ale pro typy single a double</td></tr>
</table>



<p><a name="k12"></a></p>
<h2 id="k12">12. Typy podporovaných vektorových instrukcí</h2>

<p>Instrukce v&nbsp;technologii NEON jsou navrženy takovým způsobem, aby je
bylo možné použít při zpracování 1D signálů (filtry s&nbsp;konečnou a
nekonečnou odezvou, FFT, DFT, DCT), při image processingu, zpracování videa
(motion vektory atd.) popř.&nbsp;v&nbsp;3D grafice:</p>

<table>
<tr><th>Instrukce</th><th>Zpracování signálu</th><th>Image/video processing</th><th>Další použití</th></tr>
<tr><td>vektorový součet</td><td>obecně použitelný</td><td>změna velikosti, změna jasu</td><td>detekce kolizí</td></tr>
<tr><td>maticový součet</td><td>FFT</td><td>rotace obrazu</td><td>&nbsp;</td></tr>
<tr><td>vektorový rozdíl</td><td>obecně použitelný, FFT</td><td>změna jasu</td><td>&nbsp;</td></tr>
<tr><td>maticový rozdíl</td><td>FIR</td><td>&nbsp;</td><td>&nbsp;</td></tr>
<tr><td>násobení prvků vektorů</td><td>FIR</td><td>změna kontrastu</td><td>&nbsp;</td></tr>
<tr><td>vektorový MAC</td><td>FIR</td><td>&nbsp;</td><td>&nbsp;</td></tr>
<tr><td>násobení matic</td><td>FIR</td><td>&nbsp;</td><td>&nbsp;</td></tr>
<tr><td>dělení prvků vektorů</td><td>IIR</td><td>&nbsp;</td><td>&nbsp;</td></tr>
<tr><td>výpočet délky vektoru</td><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td></tr>
<tr><td>normalizace vektoru</td><td>&nbsp;</td><td>&nbsp;</td><td>3D grafika</td></tr>
<tr><td>absolutní hodnota</td><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td></tr>
<tr><td>skalární součin</td><td>&nbsp;</td><td>&nbsp;</td><td>3D grafika</td></tr>
<tr><td>vektorový součin</td><td>&nbsp;</td><td>&nbsp;</td><td>3D grafika</td></tr>
<tr><td>determinant matice</td><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td></tr>
<tr><td>inverzní matice</td><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td></tr>
<tr><td>transpozice matice</td><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td></tr>
</table>



<p><a name="k13"></a></p>
<h2 id="k13">13. Aritmetické a logické instrukce</h2>

<p>Základní aritmetické a logické instrukce prováděné s&nbsp;prvky vektorů jsou
vypsány v&nbsp;následující tabulce. Povšimněte si, že některé instrukce
existují ve variantách pro celočíselné i FP operandy, u dalších instrukcí se
navíc rozlišuje režim se saturací a instrukce pro násobení pracuje i pro typ
polynomial:</p>

<table>
<tr><th>Instrukce</th><th>Poznámka</th></tr>
<tr><td>ADD/FADD</td><td>součet</td></tr>
<tr><td>SQADD/UQADD/</td><td>součet se saturací</td></tr>
<tr><td>SUB/FSUB</td><td>rozdíl</td></tr>
<tr><td>SQSUB/UQSUB/</td><td>rozdíl se saturací</td></tr>
<tr><td>&nbsp;</td><td>&nbsp;</td></tr>
<tr><td>MUL/FMUL/PMUL</td><td>součin</td></tr>
<tr><td>MLA/FMLA</td><td>multiply-accumulate (MAC)</td></tr>
<tr><td>MLS/FMLS</td><td>multiply-subtract (podobné předchozímu, ale výsledek se odečte od akumulátoru)</td></tr>
<tr><td>FDIV</td><td>podíl (jen pro single a double)</td></tr>
<tr><td>&nbsp;</td><td>&nbsp;</td></tr>
<tr><td>UABD/SABD/FABD</td><td>absolutní hodnota rozdílu</td></tr>
<tr><td>UABA/SABA</td><td>absolutní hodnota rozdílu se přičte s&nbsp;cílovému vektoru (akumulace)</td></tr>
<tr><td>UMAX/SMAX/FMAX</td><td>maximální hodnota</td></tr>
<tr><td>UMIN/SMIN/FMIN</td><td>minimální hodnota</td></tr>
<tr><td></td><td></td></tr>
<tr><td>&nbsp;</td><td>&nbsp;</td></tr>
<tr><td>AND</td><td>logický součin bit po bitu</td></tr>
<tr><td>EOR</td><td>logická operace XOR</td></tr>
<tr><td>ORR</td><td>logický součet bit po bitu</td></tr>
<tr><td>ORN</td><td>logický součet + negace</td></tr>
</table>



<p><a name="k14"></a></p>
<h2 id="k14">14. Instrukce pro provedení jednoho kroku delší operace</h2>

<p>Některé delší operace se rozdělují do série několika instrukcí a provádí se
tak iterativně, přičemž v&nbsp;každé iteraci dochází ke zpřesnění výsledku. U
těchto instrukcí se mezivýsledky ukládají do speciálních registrů (konkrétně se
jmenují <strong>FRECPS</strong> a <strong>FRSQRTS</strong>):</p>

<p>První takovou instrukcí je <strong>FRECPS</strong>. Tato instrukce vynásobí
příslušné dvojice prvků vektorů, odečte tento výsledek od konstanty 2 a
výsledek uloží do příslušných prvků cílového vektoru. Jedná se o jeden krok
iterativního výpočtu:</p>

<p>
x<sub>n+1</sub> = x<sub>n</sub> (2-dx<sub>n</sub>)
</p>

<p>který konverguje k&nbsp;hodnotě 1/d, ovšem jen ve chvíli, pokud je prvotní
odhad výsledku x<sub>0</sub> proveden instrukcí <strong>FRECPE</strong>.</p>

<p>Druhá instrukce se jmenuje <strong>FRSQRTS</strong> a provádí jeden krok
iterativního výpočtu:</p>

<p>
x<sub>n+1</sub> = x<sub>n</sub> (3-dx<sub>n</sub><sup>2</sup>)/2
</p>

<p>Tento výpočet konverguje k&nbsp;hodnotě 1/&radic;d, ovšem původní odhad
mezivýsledku je nutné spočítat instrukcí <strong>FRSQRTE</strong> (E znamená
&bdquo;estimate&ldquo; zatímco S v&nbsp;předchozí instrukci znamená
&bdquo;step&ldquo;).</p>



<p><a name="k15"></a></p>
<h2 id="k15">15. Podpora SIMD instrukcí ve vyšších programovacích jazycích</h2>

<p>Nové instrukce zavedené v&nbsp;rámci technologie <i>NEON</i> lze samozřejmě
využívat především přímo v&nbsp;assembleru, což je sice ta nejobtížnější
varianta, na druhou stranu však má programátor v&nbsp;tomto případě možnost
přímo a do všech podrobností ovlivnit výslednou podobu programu. Ovšem naprostá
většina programového kódu je v&nbsp;současnosti vytvářena ve vyšších
programovacích jazycích. Z&nbsp;tohoto důvodu musí existovat nějaká možnost,
jak tyto nové instrukce ve vyšších programovacích jazycích využívat.
Z&nbsp;hlediska programátora je nejjednodušší možností využít již existující
odladěné a optimalizované knihovny implementované právě s&nbsp;pomocí
<i>SIMD</i> instrukcí, což je většinou ideální řešení v&nbsp;případech, kdy
tyto knihovny již obsahují implementaci časově nejnáročnějších částí programů.
Mezi takové knihovny patří v&nbsp;případě mikroprocesorů <i>ARM</i> a
technologie <i>NEON</i> například knihovna <i>OpenMAX DL</i>, v&nbsp;níž jsou
implementovány různé zvukové i video kodeky: části algoritmů pro komprimaci a
dekomprimaci pomocí <i>JPEG</i> (rastrové obrazy), <i>MP3</i> (zvuk),
<i>H.264</i> (AV kodek), <i>MPEG-4</i> (taktéž AV kodek) atd.</p>

<p>Kromě těchto algoritmů či jejich částí jsou v&nbsp;knihovně <i>OpenMAX
DL</i> implementovány i funkce určené pro filtraci a zpracování signálů,
především <i>FIR</i>, <i>IIR</i> (číslicové filtry s&nbsp;konečnou a nekonečnou
impulsní odezvou) a <i>FFT</i> (rychlá Fourierova transformace). <i>SIMD</i>
instrukce byly použity i při optimalizaci známé knihovny <i>Cairo</i> pro
procesory <i>ARM</i>, kde se například podařilo zrychlit některé operace
s&nbsp;rastrovým obrazem (<i>alpha blending</i>) až osmkrát v&nbsp;porovnání se
&bdquo;sekvenčním&ldquo; řešením (v&nbsp;případě <i>Cairo</i> se však podle
mých informací veškeré optimalizace týkaly pouze úpravy některých funkcí pro
práci s&nbsp;rastrovým obrazem; nešlo tedy o optimalizaci většiny funkcí, které
jsou v&nbsp;této poměrně rozsáhlé knihovně implementovány).</p>

<p>Další možnost využití instrukcí typu <i>SIMD</i> i z&nbsp;vyšších
programovacích jazyků spočívá v&nbsp;takzvané automatické
&bdquo;vektorizaci&ldquo;. Překladače jazyků C a C++ totiž v&nbsp;některých
případech dokážou rozpoznat, že je možné nějakou programovou smyčku provádět
nikoli čistě sekvenčně, ale s&nbsp;využitím operací prováděných nad vektory.
Programátor však musí v&nbsp;těchto případech překladači vhodným způsobem
&bdquo;napovědět&ldquo;, například tak, že přímo v&nbsp;programu naznačí, že
počet cyklů ve smyčce bude za všech okolností dělitelný čtyřmi či osmi atd. To
nemusí být vždy úplně jednoduché, už jen z&nbsp;toho důvodu, že jazyky C a C++
nepodporují zápis metadat do programu (v&nbsp;Javě by to bylo umožněno
s&nbsp;využitím anotací).</p>

<p>Automatická &bdquo;vektorizace&ldquo; zmíněná v&nbsp;předchozím odstavci
však stále nedokáže (alespoň v&nbsp;současnosti) využít celého potenciálu
technologie <i>NEON</i>.  Z&nbsp;tohoto důvodu mohou programátoři
v&nbsp;případě potřeby zavolat přímo z&nbsp;programů psaných v&nbsp;C či C++
takzvané <a href="http://en.wikipedia.org/wiki/Intrinsic_function">interní
(intrinsic)</a> funkce, tj.&nbsp;funkce, které jsou překladačem spravovány
speciálním způsobem.  Jejich použití se sice podobá volání běžné funkce, ve
skutečnosti se však jedná o makro, které překladač vhodným způsobem expanduje
do použití některé instrukce zavedené v&nbsp;technologii <i>NEON</i>. Příklad
použití <i>intrinsic</i> funkce je ukázán níže na volání instrukce pro součet
dvou vektorů:</p>

<pre>
&nbsp;
#include &lt;arm_neon.h&gt;
&nbsp;
uint32x4_t double_elements(uint32x4_t input)
{ 
    return(vaddq_u32(input, input)); 
}
&nbsp;
</pre>



<p><a name="k16"></a></p>
<h2 id="k16">16. Odkazy na Internetu</h2>

<ol>

<li>NEON Technology (stránky ARM)<br />
<a href="https://developer.arm.com/technologies/neon">https://developer.arm.com/technologies/neon</a>
</li>

<li>SIMD Assembly Tutorial: ARM NEON - Xiph.org<br />
<a href="https://people.xiph.org/~tterribe/daala/neon_tutorial.pdf">https://people.xiph.org/~tterribe/daala/neon_tutorial.pdf</a>
</li>

<li>Ne10<br />
<a href="http://projectne10.github.io/Ne10/">http://projectne10.github.io/Ne10/</a>
</li>

<li>NEON and Floating-Point architecture<br />
<a href="http://infocenter.arm.com/help/index.jsp?topic=/com.arm.doc.den0024a/BABIGHEB.html">http://infocenter.arm.com/help/index.jsp?topic=/com.arm.doc.den0024a/BABIGHEB.html</a>
</li>

<li>An Introduction to ARM NEON<br />
<a href="http://peterdn.com/post/an-introduction-to-ARM-NEON.aspx">http://peterdn.com/post/an-introduction-to-ARM-NEON.aspx</a>
</li>

<li>ARM NEON Intrinsics Reference<br />
<a href="http://infocenter.arm.com/help/topic/com.arm.doc.ihi0073a/IHI0073A_arm_neon_intrinsics_ref.pdf">http://infocenter.arm.com/help/topic/com.arm.doc.ihi0073a/IHI0073A_arm_neon_intrinsics_ref.pdf</a>
</li>

<li>Arm Neon Intrinsics vs hand assembly<br />
<a href="https://stackoverflow.com/questions/9828567/arm-neon-intrinsics-vs-hand-assembly">https://stackoverflow.com/questions/9828567/arm-neon-intrinsics-vs-hand-assembly</a>
</li>

<li>ARM NEON Optimization. An Example<br />
<a href="http://hilbert-space.de/?p=22">http://hilbert-space.de/?p=22</a>
</li>

<li>AArch64 NEON instruction format<br />
<a href="https://developer.arm.com/docs/den0024/latest/7-aarch64-floating-point-and-neon/73-aarch64-neon-instruction-format">https://developer.arm.com/docs/den0024/latest/7-aarch64-floating-point-and-neon/73-aarch64-neon-instruction-format</a>
</li>

<li>Vektorové procesory aneb další pokus o zvýšení výpočetního výkonu počítačů<br />
<a href="http://www.root.cz/clanky/vektorove-procesory-aneb-dalsi-pokus-o-zvyseni-vypocetniho-vykonu-pocitacu/">http://www.root.cz/clanky/vektorove-procesory-aneb-dalsi-pokus-o-zvyseni-vypocetniho-vykonu-pocitacu/</a>
</li>

<li>SIMD instrukce využívané v moderních mikroprocesorech řady x86<br />
<a href="http://www.root.cz/clanky/simd-instrukce-vyuzivane-v-modernich-mikroprocesorech-rady-x86/">http://www.root.cz/clanky/simd-instrukce-vyuzivane-v-modernich-mikroprocesorech-rady-x86/</a>
</li>

<li>SIMD instrukce v moderních mikroprocesorech řady x86 (2.část: SSE)<br />
<a href="http://www.root.cz/clanky/simd-instrukce-v-modernich-mikroprocesorech-rady-x86-2-cast-sse/">http://www.root.cz/clanky/simd-instrukce-v-modernich-mikroprocesorech-rady-x86-2-cast-sse/</a>
</li>

<li>SIMD instrukce v moderních mikroprocesorech řady x86 (3.část: SSE2)<br />
<a href="http://www.root.cz/clanky/simd-instrukce-v-modernich-mikroprocesorech-rady-x86-3-cast-sse2/">http://www.root.cz/clanky/simd-instrukce-v-modernich-mikroprocesorech-rady-x86-3-cast-sse2/</a>
</li>

<li>Instrukce typu SIMD na mikroprocesorech RISC<br />
<a href="http://www.root.cz/clanky/instrukce-typu-simd-na-mikroprocesorech-risc/">http://www.root.cz/clanky/instrukce-typu-simd-na-mikroprocesorech-risc/</a>
</li>

<li>Instrukce typu SIMD na mikroprocesorech RISC (2. část)<br />
<a href="http://www.root.cz/clanky/instrukce-typu-simd-na-mikroprocesorech-risc-2-cast/">http://www.root.cz/clanky/instrukce-typu-simd-na-mikroprocesorech-risc-2-cast/</a>
</li>

<li>Instrukce typu SIMD na mikroprocesorech RISC (3.část - MIPS-3D a VIS)<br />
<a href="http://www.root.cz/clanky/instrukce-typu-simd-na-mikroprocesorech-risc-3-cast-mips-3d-a-vis/">http://www.root.cz/clanky/instrukce-typu-simd-na-mikroprocesorech-risc-3-cast-mips-3d-a-vis/</a>
</li>

<li>Trasování a ladění nativních aplikací v&nbsp;Linuxu<br />
<a href="https://www.root.cz/clanky/trasovani-a-ladeni-nativnich-aplikaci-v-linuxu/">https://www.root.cz/clanky/trasovani-a-ladeni-nativnich-aplikaci-v-linuxu/</a>
</li>

<li>Trasování a ladění nativních aplikací v&nbsp;Linuxu: použití GDB a jeho nadstaveb<br />
<a href="https://www.root.cz/clanky/trasovani-a-ladeni-nativnich-aplikaci-v-linuxu-pouziti-gdb-a-jeho-nadstaveb/">https://www.root.cz/clanky/trasovani-a-ladeni-nativnich-aplikaci-v-linuxu-pouziti-gdb-a-jeho-nadstaveb/</a>
</li>

<li>Debuggery a jejich nadstavby v Linuxu (3): Nemiver<br />
<a href="http://mojefedora.cz/debuggery-a-jejich-nadstavby-v-linuxu-3-nemiver/">http://mojefedora.cz/debuggery-a-jejich-nadstavby-v-linuxu-3-nemiver/</a>
</li>

<li>Debuggery a jejich nadstavby v Linuxu (4): KDbg<br />
<a href="http://mojefedora.cz/debuggery-a-jejich-nadstavby-v-linuxu-4-kdbg/">http://mojefedora.cz/debuggery-a-jejich-nadstavby-v-linuxu-4-kdbg/</a>
</li>

<li>Debuggery a jejich nadstavby v Linuxu (5): ladění aplikací v&nbsp;editorech Emacs a Vim<br />
<a href="http://mojefedora.cz/debuggery-a-jejich-nadstavby-v-linuxu-5-ladeni-aplikaci-v-editorech-emacs-a-vim/">http://mojefedora.cz/debuggery-a-jejich-nadstavby-v-linuxu-5-ladeni-aplikaci-v-editorech-emacs-a-vim/</a>
</li>

<li>Tracing (software)<br />
<a href="https://en.wikipedia.org/wiki/Tracing_%28software%29">https://en.wikipedia.org/wiki/Tracing_%28software%29</a>
</li>

<li>cgdb: the curses debugger<br />
<a href="https://cgdb.github.io/">https://cgdb.github.io/</a>
</li>

<li>cgdb: dokumentace<br />
<a href="https://cgdb.github.io/docs/cgdb-split.html">https://cgdb.github.io/docs/cgdb-split.html</a>
</li>

<li>strace(1) - Linux man page<br />
<a href="http://linux.die.net/man/1/strace">http://linux.die.net/man/1/strace</a>
</li>

<li>strace (stránka projektu na SourceForge)<br />
<a href="https://sourceforge.net/projects/strace/">https://sourceforge.net/projects/strace/</a>
</li>

<li>strace (Wikipedia)<br />
<a href="https://en.wikipedia.org/wiki/Strace">https://en.wikipedia.org/wiki/Strace</a>
</li>

<li>GDB - Dokumentace<br />
<a href="http://sourceware.org/gdb/current/onlinedocs/gdb/">http://sourceware.org/gdb/current/onlinedocs/gdb/</a>
</li>

<li>GDB - Supported Languages<br />
<a href="http://sourceware.org/gdb/current/onlinedocs/gdb/Supported-Languages.html#Supported-Languages">http://sourceware.org/gdb/current/onlinedocs/gdb/Supported-Languages.html#Supported-Languages</a>
</li>

<li>GNU Debugger (Wikipedia)<br />
<a href="https://en.wikipedia.org/wiki/GNU_Debugger">https://en.wikipedia.org/wiki/GNU_Debugger</a>
</li>

<li>The LLDB Debugger<br />
<a href="http://lldb.llvm.org/">http://lldb.llvm.org/</a>
</li>

<li>Debugger (Wikipedia)<br />
<a href="https://en.wikipedia.org/wiki/Debugger">https://en.wikipedia.org/wiki/Debugger</a>
</li>

<li>Comparison of ARMv8-A cores<br />
<a href="https://en.wikipedia.org/wiki/Comparison_of_ARMv8-A_cores">https://en.wikipedia.org/wiki/Comparison_of_ARMv8-A_cores</a>
</li>

<li>A64 General Instructions<br />
<a href="http://www.keil.com/support/man/docs/armclang_asm/armclang_asm_pge1427898258836.htm">http://www.keil.com/support/man/docs/armclang_asm/armclang_asm_pge1427898258836.htm</a>
</li>

<li>ARMv8 (AArch64) Instruction Encoding<br />
<a href="http://kitoslab-eng.blogspot.cz/2012/10/armv8-aarch64-instruction-encoding.html">http://kitoslab-eng.blogspot.cz/2012/10/armv8-aarch64-instruction-encoding.html</a>
</li>

<li>Cortex-A32 Processor<br />
<a href="https://www.arm.com/products/processors/cortex-a/cortex-a32-processor.php">https://www.arm.com/products/processors/cortex-a/cortex-a32-processor.php</a>
</li>

<li>Cortex-A35 Processor<br />
<a href="https://www.arm.com/products/processors/cortex-a/cortex-a35-processor.php">https://www.arm.com/products/processors/cortex-a/cortex-a35-processor.php</a>
</li>

<li>Cortex-A53 Processor<br />
<a href="https://www.arm.com/products/processors/cortex-a/cortex-a53-processor.php">https://www.arm.com/products/processors/cortex-a/cortex-a53-processor.php</a>
</li>

<li>Cortex-A57 Processor<br />
<a href="https://www.arm.com/products/processors/cortex-a/cortex-a57-processor.php">https://www.arm.com/products/processors/cortex-a/cortex-a57-processor.php</a>
</li>

<li>Cortex-A72 Processor<br />
<a href="https://www.arm.com/products/processors/cortex-a/cortex-a72-processor.php">https://www.arm.com/products/processors/cortex-a/cortex-a72-processor.php</a>
</li>

<li>Cortex-A73 Processor<br />
<a href="https://www.arm.com/products/processors/cortex-a/cortex-a73-processor.php">https://www.arm.com/products/processors/cortex-a/cortex-a73-processor.php</a>
</li>

<li>Apple A7 (SoC založen na CPU Cyclone)<br />
<a href="https://en.wikipedia.org/wiki/Apple_A7">https://en.wikipedia.org/wiki/Apple_A7</a>
</li>

<li>System cally pro AArch64 na Linuxu<br />
<a href="https://github.com/torvalds/linux/blob/master/include/uapi/asm-generic/unistd.h">https://github.com/torvalds/linux/blob/master/include/uapi/asm-generic/unistd.h</a>
</li>

<li>Architectures/AArch64 (FedoraProject.org)<br />
<a href="https://fedoraproject.org/wiki/Architectures/AArch64">https://fedoraproject.org/wiki/Architectures/AArch64</a>
</li>

<li>SIG pro AArch64 (CentOS)<br />
<a href="https://wiki.centos.org/SpecialInterestGroup/AltArch/AArch64">https://wiki.centos.org/SpecialInterestGroup/AltArch/AArch64</a>
</li>

<li>The ARMv8 instruction sets<br />
<a href="http://infocenter.arm.com/help/index.jsp?topic=/com.arm.doc.den0024a/ch05s01.html">http://infocenter.arm.com/help/index.jsp?topic=/com.arm.doc.den0024a/ch05s01.html</a>
</li>

<li>A64 Instruction Set<br />
<a href="https://developer.arm.com/products/architecture/instruction-sets/a64-instruction-set">https://developer.arm.com/products/architecture/instruction-sets/a64-instruction-set</a>
</li>

<li>Switching between the instruction sets<br />
<a href="http://infocenter.arm.com/help/index.jsp?topic=/com.arm.doc.den0024a/ch05s01.html">http://infocenter.arm.com/help/index.jsp?topic=/com.arm.doc.den0024a/ch05s01.html</a>
</li>

<li>The A64 instruction set<br />
<a href="http://infocenter.arm.com/help/index.jsp?topic=/com.arm.doc.den0024a/ch05s01.html">http://infocenter.arm.com/help/index.jsp?topic=/com.arm.doc.den0024a/ch05s01.html</a>
</li>

<li>Introduction to ARMv8 64-bit Architecture<br />
<a href="https://quequero.org/2014/04/introduction-to-arm-architecture/">https://quequero.org/2014/04/introduction-to-arm-architecture/</a>
</li>

<li>MCU market turns to 32-bits and ARM<br />
<a href="http://www.eetimes.com/document.asp?doc_id=1280803">http://www.eetimes.com/document.asp?doc_id=1280803</a>
</li>

<li>Cortex-M0 Processor (ARM Holdings)<br />
<a href="http://www.arm.com/products/processors/cortex-m/cortex-m0.php">http://www.arm.com/products/processors/cortex-m/cortex-m0.php</a>
</li>

<li>Cortex-M0+ Processor (ARM Holdings)<br />
<a href="http://www.arm.com/products/processors/cortex-m/cortex-m0plus.php">http://www.arm.com/products/processors/cortex-m/cortex-m0plus.php</a>
</li>

<li>ARM Processors in a Mixed Signal World<br />
<a href="http://www.eeweb.com/blog/arm/arm-processors-in-a-mixed-signal-world">http://www.eeweb.com/blog/arm/arm-processors-in-a-mixed-signal-world</a>
</li>

<li>ARM Architecture (Wikipedia)<br />
<a href="https://en.wikipedia.org/wiki/ARM_architecture">https://en.wikipedia.org/wiki/ARM_architecture</a>
</li>

<li>DSP for Cortex-M<br />
<a href="https://developer.arm.com/technologies/dsp/dsp-for-cortex-m">https://developer.arm.com/technologies/dsp/dsp-for-cortex-m</a>
</li>

<li>Cortex-M processors in DSP applications? Why not?!<br />
<a href="https://community.arm.com/processors/b/blog/posts/cortex-m-processors-in-dsp-applications-why-not">https://community.arm.com/processors/b/blog/posts/cortex-m-processors-in-dsp-applications-why-not</a>
</li>

<li>White Paper - DSP capabilities of Cortex-M4 and Cortex-M7<br />
<a href="https://community.arm.com/processors/b/blog/posts/white-paper-dsp-capabilities-of-cortex-m4-and-cortex-m7">https://community.arm.com/processors/b/blog/posts/white-paper-dsp-capabilities-of-cortex-m4-and-cortex-m7</a>
</li>

<li>Q (number format)<br />
<a href="https://en.wikipedia.org/wiki/Q_%28number_format%29">https://en.wikipedia.org/wiki/Q_%28number_format%29</a>
</li>

<li>TriCore Architecture &amp; Core<br />
<a href="http://www.infineon.com/cms/en/product/microcontroller/32-bit-tricore-tm-microcontroller/tricore-tm-architecture-and-core/channel.html?channel=ff80808112ab681d0112ab6b73d40837">http://www.infineon.com/cms/en/product/microcontroller/32-bit-tricore-tm-microcontroller/tricore-tm-architecture-and-core/channel.html?channel=ff80808112ab681d0112ab6b73d40837</a>
</li>

<li>TriCoreTM V1.6 Instruction Set: 32-bit Unified Processor Core<br />
<a href="http://www.infineon.com/dgdl/tc_v131_instructionset_v138.pdf?fileId=db3a304412b407950112b409b6dd0352">http://www.infineon.com/dgdl/tc_v131_instructionset_v138.pdf?fileId=db3a304412b407950112b409b6dd0352</a>
</li>

<li>TriCore v2.2 C Compiler, Assembler, Linker Reference Manual<br />
<a href="http://tasking.com/support/tricore/tc_reference_guide_v2.2.pdf">http://tasking.com/support/tricore/tc_reference_guide_v2.2.pdf</a>
</li>

<li>Infineon TriCore (Wikipedia)<br />
<a href="https://en.wikipedia.org/wiki/Infineon_TriCore">https://en.wikipedia.org/wiki/Infineon_TriCore</a>
</li>

<li>C166®S V2 Architecture &amp; Core<br />
<a href="http://www.infineon.com/cms/en/product/microcontroller/16-bit-c166-microcontroller/c166-s-v2-architecture-and-core/channel.html?channel=db3a304312bef5660112c3011c7d01ae">http://www.infineon.com/cms/en/product/microcontroller/16-bit-c166-microcontroller/c166-s-v2-architecture-and-core/channel.html?channel=db3a304312bef5660112c3011c7d01ae</a>
</li>

<li>Comparing four 32-bit soft processor cores<br />
<a href="http://www.eetimes.com/author.asp?section_id=14&doc_id=1286116">http://www.eetimes.com/author.asp?section_id=14&doc_id=1286116</a>
</li>

<li>RISC-V Instruction Set<br />
<a href="http://riscv.org/download.html#spec_compressed_isa">http://riscv.org/download.html#spec_compressed_isa</a>
</li>

<li>RISC-V Spike (ISA Simulator)<br />
<a href="http://riscv.org/download.html#isa-sim">http://riscv.org/download.html#isa-sim</a>
</li>

<li>RISC-V (Wikipedia)<br />
<a href="https://en.wikipedia.org/wiki/RISC-V">https://en.wikipedia.org/wiki/RISC-V</a>
</li>

<li>David Patterson (Wikipedia)<br />
<a href="https://en.wikipedia.org/wiki/David_Patterson_(computer_scientist)">https://en.wikipedia.org/wiki/David_Patterson_(computer_scientist)</a>
</li>

<li>OpenRISC (oficiální stránky projektu)<br />
<a href="http://openrisc.io/">http://openrisc.io/</a>
</li>

<li>OpenRISC architecture<br />
<a href="http://openrisc.io/architecture.html">http://openrisc.io/architecture.html</a>
</li>

<li>Emulátor OpenRISC CPU v JavaScriptu<br />
<a href="http://s-macke.github.io/jor1k/demos/main.html">http://s-macke.github.io/jor1k/demos/main.html</a>
</li>

<li>OpenRISC (Wikipedia)<br />
<a href="https://en.wikipedia.org/wiki/OpenRISC">https://en.wikipedia.org/wiki/OpenRISC</a>
</li>

<li>OpenRISC - instrukce<br />
<a href="http://sourceware.org/cgen/gen-doc/openrisc-insn.html">http://sourceware.org/cgen/gen-doc/openrisc-insn.html</a>
</li>

<li>OpenRISC - slajdy z přednášky o projektu<br />
<a href="https://iis.ee.ethz.ch/~gmichi/asocd/lecturenotes/Lecture6.pdf">https://iis.ee.ethz.ch/~gmichi/asocd/lecturenotes/Lecture6.pdf</a>
</li>

<li>Berkeley RISC<br />
<a href="http://en.wikipedia.org/wiki/Berkeley_RISC">http://en.wikipedia.org/wiki/Berkeley_RISC</a>
</li>

<li>Great moments in microprocessor history<br />
<a href="http://www.ibm.com/developerworks/library/pa-microhist.html">http://www.ibm.com/developerworks/library/pa-microhist.html</a>
</li>

<li>Microprogram-Based Processors<br />
<a href="http://research.microsoft.com/en-us/um/people/gbell/Computer_Structures_Principles_and_Examples/csp0167.htm">http://research.microsoft.com/en-us/um/people/gbell/Computer_Structures_Principles_and_Examples/csp0167.htm</a>
</li>

<li>Great Microprocessors of the Past and Present<br />
<a href="http://www.cpushack.com/CPU/cpu1.html">http://www.cpushack.com/CPU/cpu1.html</a>
</li>

<li>A Brief History of Microprogramming<br />
<a href="http://www.cs.clemson.edu/~mark/uprog.html">http://www.cs.clemson.edu/~mark/uprog.html</a>
</li>

<li>What is RISC?<br />
<a href="http://www-cs-faculty.stanford.edu/~eroberts/courses/soco/projects/2000-01/risc/whatis/">http://www-cs-faculty.stanford.edu/~eroberts/courses/soco/projects/2000-01/risc/whatis/</a>
</li>

<li>RISC vs. CISC<br />
<a href="http://www-cs-faculty.stanford.edu/~eroberts/courses/soco/projects/2000-01/risc/risccisc/">http://www-cs-faculty.stanford.edu/~eroberts/courses/soco/projects/2000-01/risc/risccisc/</a>
</li>

<li>RISC and CISC definitions:<br />
<a href="http://www.cpushack.com/CPU/cpuAppendA.html">http://www.cpushack.com/CPU/cpuAppendA.html</a>
</li>

<li>FPGA<br />
<a href="https://cs.wikipedia.org/wiki/Programovateln%C3%A9_hradlov%C3%A9_pole">https://cs.wikipedia.org/wiki/Programovateln%C3%A9_hradlov%C3%A9_pole</a>
</li>

<li>The Evolution of RISC<br />
<a href="http://www.ibm.com/developerworks/library/pa-microhist.html#sidebar1">http://www.ibm.com/developerworks/library/pa-microhist.html#sidebar1</a>
</li>

</ol>



<p></p><p></p>
<p><small>Autor: <a href="http://www.fit.vutbr.cz/~tisnovpa">Pavel Tišnovský</a> &nbsp; 2017</small></p>
</body>
</html>

