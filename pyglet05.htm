<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
        "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html>
<head>
<title>Multimediální knihovna Pyglet: blending při kreslení 2D i 3D scén</title>
<meta name="Author" content="Pavel Tisnovsky" />
<meta name="Generator" content="vim" />
<meta http-equiv="content-type" content="text/html; charset=utf-8" />
<style type="text/css">
         body {color:#000000; background:#ffffff;}
         h1  {font-family: arial, helvetica, sans-serif; color:#ffffff; background-color:#c00000; text-align:center; padding-left:1em}
         h2  {font-family: arial, helvetica, sans-serif; color:#ffffff; background-color:#0000c0; padding-left:1em; text-align:left}
         h3  {font-family: arial, helvetica, sans-serif; color:#000000; background-color:#c0c0c0; padding-left:1em; text-align:left}
         h4  {font-family: arial, helvetica, sans-serif; color:#000000; background-color:#e0e0e0; padding-left:1em; text-align:left}
         a   {font-family: arial, helvetica, sans-serif;}
         li  {font-family: arial, helvetica, sans-serif; color:#000000; text-align:justify; width:450px;}
         ol  {font-family: arial, helvetica, sans-serif; color:#000000; text-align:justify; width:450px;}
         ul  {font-family: arial, helvetica, sans-serif; color:#000000; text-align:justify; width:450px;}
         p   {font-family: arial, helvetica, sans-serif; color:#000000; text-align:justify;}
         pre {background:#e0e0e0}
</style>
</head>

<body>

<h1>Multimediální knihovna Pyglet: blending při kreslení 2D i 3D scén</h1>

<h3>Pavel Tišnovský</h3>

<p></p>

<h1>Úvodník</h1>

<p></p>



<h2>Obsah</h2>

<p><a href="#k01">1. Multimediální knihovna Pyglet: blending při kreslení 2D i 3D scén</a></p>
<p><a href="#k02">2. Co je to fragment?</a></p>
<p><a href="#k03">3. Povolení a zákaz blendingu</a></p>
<p><a href="#k04">4. Míchací rovnice použitá při blendingu</a></p>
<p><a href="#k05">5. Specifikace parametrů míchací rovnice funkcemi OpenGL</a></p>
<p><a href="#k06">*** 6. První demonstrační příklad: jednoduchý blending</a></p>
<p><a href="#k07">*** 7. </a></p>
<p><a href="#k08">*** 8. </a></p>
<p><a href="#k09">*** 9. </a></p>
<p><a href="#k10">*** 10. </a></p>
<p><a href="#k11">*** 11. </a></p>
<p><a href="#k12">*** 12. </a></p>
<p><a href="#k13">*** 13. Repositář s&nbsp;demonstračními příklady</a></p>
<p><a href="#k14">*** 14. Odkazy na Internetu</a></p>



<p><a name="k01"></a></p>
<h2 id="k01">1. Multimediální knihovna Pyglet: blending při kreslení 2D i 3D scén</h2>

<p>V&nbsp;předchozích dílech seriálu o multimediální knihovně Pyglet jsme si již několikrát popisovali barvový formát používaný při práci s&nbsp;barvami v&nbsp;OpenGL. Barvy jsou v&nbsp;tomto barvovém formátu popsány s&nbsp;využitím tří barvových složek R (<i>Red</i>), G (<i>Green</i>) a B (<i>Blue</i>); při použití čísel typu <i>float</i> je hodnota složek v&nbsp;rozsahu 0,0 až 0,1 (včetně obou mezních hodnot). K&nbsp;těmto složkám se často přidává ještě složka čtvrtá, nazývaná A (<i>Alpha</i>). Výsledný barvový model se označuje zkratkou RGBA. K&nbsp;čemu je vlastně alfa složka užitečná? Všechny moderní grafické akcelerátory mohou při vykreslování provádět i takzvaný <i>blending</i> neboli míchání (barev). A k&nbsp;tomuto účelu se většinou používá právě již zmíněná čtvrtá barvová složka specifikovaná příkazem <strong>glColor4f(R, G, B, A)</strong> a nikoli &bdquo;pouze&ldquo; <strong>glColor3f(R, G, B)</strong>. Složka alfa může na základě nastavené blending funkce (viz další text) představovat například průhlednost specifikované barvy. Při použití blendingu musíme nejdříve nastavit, jakým způsobem se budou kombinovat právě vykreslované <i>fragmenty</i> s&nbsp;hodnotami uloženými ve framebufferu.</p>



<p><a name="k02"></a></p>
<h2 id="k02">2. Co je to fragment?</h2>

<p>Připomeňme si, že <i>fragment</i> je datová struktura složená z&nbsp;barvy pixelu, jeho průhlednosti, vzdálenosti od pozorovatele a případných dalších informací. Framebuffer je v&nbsp;podstatě pravidelná matice fragmentů. Barvy fragmentů tvoří ve framebufferu samostatný color-buffer, který se zobrazuje na obrazovce. Rasterizace je proces, kterým se matematický model plošky (trojúhelníku, čtyřúhelníku, konvexního polygonu) převádí na jednotlivé fragmenty. Způsob míchání barvy uložené ve framebufferu a barvy vykreslovaného fragmentu se řídí uživatelem definovanou míchací rovnicí (<i>blending function</i>). V&nbsp;této rovnici vystupují následující členy:</p>

<ol>

<li>Zdroj (<i>source</i>) je fragment vzniklý rasterizací v&nbsp;právě běžícím rasterizačním procesu.</li>

<li>Cíl (<i>destination</i>) je hodnota zapsaná ve framebufferu, tj.&nbsp;barva fragmentu, který již byl vykreslen dříve. Tato hodnota bude v&nbsp;závislosti na nastavené blending funkci přepsána nebo jinak ovlivněna.</li>

</ol>

<p>Na schématu se zjednodušenou vykreslovací pipeline si povšimněte především toho, že při blendingu je nutné kombinovat již vykreslený obsah framebufferu s&nbsp;novými fragmenty:</p>

*** image ***
<p><i>Obrázek 1: Klasická OpenGL pipeline se zvýrazněním bloku, v&nbsp;němž se provádí blending.</i></p>



<p><a name="k03"></a></p>
<h2 id="k03">3. Povolení a zákaz blendingu</h2>

<p>V&nbsp;knihovně OpenGL lze stanovit koeficienty míchání pro každou barvovou složku zvlášť. Tak lze jednoduše dosáhnout na první pohled složitých efektů, například maskování jedné barvy apod. Při spuštění programu, který používá pro vykreslování grafickou knihovnu OpenGL, je vliv alfa složky na vykreslovanou plošku zakázán. Proto pokud chceme programovat některé grafické efekty, musíme před vykreslením vhodně nastavit režim míchání již nakreslené části scény s&nbsp;nově vykreslovanými tělesy. Podobně jako je tomu i v&nbsp;dalších případech se o povolení stará funkce nazvaná <strong>glEnable()</strong> a o zákaz funkce nazvaná <strong>glDisable()</strong>. Povolení blendingu tedy může vypadat následovně:</p>

<pre>
def init():
    glClearColor(0.0, 0.0, 0.3, 0.0)          # barva pozadi obrazku
    glClearDepth(1.0)                         # implicitni hloubka ulozena v pameti hloubky
    ...
    ...
    # další funkce
    ...
    ...
    glEnable(GL_BLEND)                        # povoleni blendingu
</pre>

<p>Poznámka: blending lze selektivně zapínat či vypínat i přímo při vykreslování, což je ostatně často děje i v&nbsp;praxi.</p>



<p><a name="k04"></a></p>
<h2 id="k04">4. Míchací rovnice použitá při blendingu</h2>

<p>Míchací rovnici, která se tradičně v&nbsp;knihách o počítačové grafice zapisuje ve vektorovém tvaru, lze rozepsat do čtyř rovnic odpovídajících barvovému modelu RGBA:</p>

<p>R<sub>n</sub> = R<sub>s</sub> &times; S<sub>r</sub> + R<sub>d</sub> &times; D<sub>r</sub><br />
G<sub>n</sub> = G<sub>s</sub> &times; S<sub>g</sub> + G<sub>d</sub> &times; D<sub>g</sub><br />
B<sub>n</sub> = B<sub>s</sub> &times; S<sub>b</sub> + B<sub>d</sub> &times; D<sub>b</sub><br />
A<sub>n</sub> = A<sub>s</sub> &times; S<sub>a</sub> + A<sub>d</sub> &times; D<sub>a</sub><br />
</p>

<p>Význam jednotlivých členů v&nbsp;rovnicích:</p>

<table>
<tr><th>Člen</th><th>Stručný popis</th></tr>
<tr><td>R<sub>n</sub></td><td>nově vypočtená červená barevná složka</td></tr>
<tr><td>G<sub>n</sub></td><td>nově vypočtená zelená barevná složka</td></tr>
<tr><td>B<sub>n</sub></td><td>nově vypočtená modrá barevná složka</td></tr>
<tr><td>A<sub>n</sub></td><td>nová hodnota alfa složky</td></tr>
<tr><td>&nbsp;</td><td>&nbsp;</td></tr>
<tr><td>R<sub>s</sub></td><td>červená barevná složka zdrojového fragmentu</td></tr>
<tr><td>G<sub>s</sub></td><td>zelená barevná složka zdrojového fragmentu</td></tr>
<tr><td>B<sub>s</sub></td><td>modrá barevná složka zdrojového fragmentu</td></tr>
<tr><td>A<sub>s</sub></td><td>alfa složka zdrojového fragmentu</td></tr>
<tr><td>&nbsp;</td><td>&nbsp;</td></tr>
<tr><td>R<sub>d</sub></td><td>červená barevná složka cílového fragmentu</td></tr>
<tr><td>G<sub>d</sub></td><td>zelená barevná složka cílového fragmentu</td></tr>
<tr><td>B<sub>d</sub></td><td>modrá barevná složka cílového fragmentu</td></tr>
<tr><td>A<sub>d</sub></td><td>alfa složka cílového fragmentu</td></tr>
<tr><td>&nbsp;</td><td>&nbsp;</td></tr>
<tr><td>S<sub>r</sub></td><td>míchací faktor pro červenou barvu zdrojového fragmentu</td></tr>
<tr><td>S<sub>g</sub></td><td>míchací faktor pro zelenou barvu zdrojového fragmentu</td></tr>
<tr><td>S<sub>b</sub></td><td>míchací faktor pro modrou barvu zdrojového fragmentu</td></tr>
<tr><td>S<sub>a</sub></td><td>míchací faktor pro alfa složku zdrojového fragmentu</td></tr>
<tr><td>&nbsp;</td><td>&nbsp;</td></tr>
<tr><td>D<sub>r</sub></td><td>míchací faktor pro červenou barvu cílového fragmentu</td></tr>
<tr><td>D<sub>g</sub></td><td>míchací faktor pro zelenou barvu cílového fragmentu</td></tr>
<tr><td>D<sub>b</sub></td><td>míchací faktor pro modrou barvu cílového fragmentu</td></tr>
<tr><td>D<sub>a</sub></td><td>míchací faktor pro alfa složku cílového fragmentu</td></tr>
</table>

<p>Pro praxi si však stačí zapamatovat význam jednotlivých písmen: R-red, G-green, B-blue, A-alpha, n-new fragment, s-source fragment, d-destination fragment.</p>



<p><a name="k05"></a></p>
<h2 id="k05">5. Specifikace parametrů míchací rovnice funkcemi OpenGL</h2>

<p>Ve výše uvedených rovnicích je nutné specifikovat míchací faktory (koeficienty) S<sub>r</sub>, S<sub>g</sub>, S<sub>b</sub>, S<sub>a</sub>, D<sub>r</sub>, D<sub>g</sub>, D<sub>b</sub> a D<sub>a</sub>, ostatní hodnoty odpovídají barvám a alfa-složkám zdrojových a cílových fragmentů. Koeficienty S a D se nezadávají přímo číselnou hodnotou, protože se mohou měnit v&nbsp;závislosti na barvách zdrojových a cílových fragmentů. Místo toho se používají symboly, jejichž konkrétní hodnota se vypočte automaticky při rasterizaci.</p>

<p>Pro zadání míchacích koeficientů se používá funkce:</p>

<pre>
glBlendFunc(sFactor, dFactor)
</pre>

<p>První parametr <strong>sFactor</strong> určuje způsob výpočtu míchacích faktorů S<sub>r</sub>, S<sub>g</sub>, S<sub>b</sub> a S<sub>a</sub>, druhý parametr <strong>dFactor</strong> způsob výpočtu faktorů D<sub>r</sub>, D<sub>g</sub>, D<sub>b</sub> a D<sub>a</sub>.</p>

<p>Pro hodnoty, které lze do těchto parametrů dosadit, platí základní jednoduchá pravidla:</p>

<ol>

<li>Za sFactor popř. dFactor je možné dosadit některou z&nbsp;konstant, které jsou předdefinovány v&nbsp;hlavičkovém souboru <i>gl.h</i> (to samozřejmě platí především pro nativní aplikace psané v&nbsp;C či C++, nicméně podobné konstanty nalezneme i v&nbsp;Pygletu).</li>

<li>Některé z&nbsp;těchto konstant je možné zadat do obou parametrů. Jedná se například o konstanty <i>GL_ZERO</i>, <i>GL_ONE</i> apod. Význam těchto konstant se samozřejmě liší podle toho, do kterého parametru jsou dosazeny.</li>

<li>Některé konstanty lze použít pouze pro parametr sFactor. Jedná se zejména o konstanty <i>GL_DST_COLOR</i> nebo <i>GL_ONE_MINUS_DST_CO­LOR</i>.</li>

<li>Některé konstanty lze naopak použít pouze pro parametr dFactor. Jde o konstanty <i>GL_SRC_COLOR</i>, <i>GL_ONE_MINUS_SRC_CO­LOR</i> apod.</li>

</ol>

<p>V&nbsp;následující tabulce je vypsán význam míchacích faktorů, které můžeme použít pro specifikaci koeficientů míchací rovnice. Ve sloupci <i>Název</i> je uvedeno jméno faktoru, tj.&nbsp;symbolická konstanta definovaná v&nbsp;souboru <i>gl.h</i> popř.&nbsp;modulu Pygletu. Ve sloupci <i>Použití</i> je označeno, zda se může symbolická konstanta použít pro dosazení do parametru <i>sFactor</i> (S), <i>dFactor</i> (D) nebo do obou parametrů. Ve sloupci <i>Význam</i> jsou ve vektorovém tvaru naznačeny hodnoty zdrojových či cílových koeficientů.</p>

<table>
<tr><th>Název</th><th>Použití</th><th>Význam</th></tr>
<tr><td>GL_ZERO</td><td>S nebo D</td><td>(0, 0, 0, 0)</td></tr>
<tr><td>GL_ONE</td><td>S nebo D</td><td>(1, 1, 1, 1)</td></tr>
<tr><td>GL_DST_COLOR</td><td>S</td><td>(R<sub>d</sub>, G<sub>d</sub>, B<sub>d</sub>, A<sub>d</sub>)</td></tr>
<tr><td>GL_SRC_COLOR</td><td>D</td><td>(R<sub>s</sub>, G<sub>s</sub>, B<sub>s</sub>, A<sub>s</sub>)</td></tr>
<tr><td>GL_ONE_MINUS_DST_CO­LOR</td><td>S</td><td>(1, 1, 1, 1)-(R<sub>d</sub>, G<sub>d</sub>, B<sub>d</sub>, A<sub>d</sub>)</td></tr>
<tr><td>GL_ONE_MINUS_SRC_CO­LOR</td><td>D</td><td>(1, 1, 1, 1)-(R<sub>s</sub>, G<sub>s</sub>, B<sub>s</sub>, A<sub>s</sub>)</td></tr>
<tr><td>GL_SRC_ALPHA</td><td>S nebo D</td><td>(A<sub>s</sub>, A<sub>s</sub>, A<sub>s</sub>, A<sub>s</sub>)</td></tr>
<tr><td>GL_ONE_MINUS_SRC_AL­PHA</td><td>S nebo D</td><td>(1, 1, 1, 1)-(A<sub>s</sub>, A<sub>s</sub>, A<sub>s</sub>, A<sub>s</sub>)</td></tr>
<tr><td>GL_DST_ALPHA</td><td>S nebo D</td><td>(A<sub>d</sub>, A<sub>d</sub>, A<sub>d</sub>, A<sub>d</sub>)</td></tr>
<tr><td>GL_ONE_MINUS_DST_AL­PHA</td><td>S nebo D</td><td>(1, 1, 1, 1)-(A<sub>d</sub>, A<sub>d</sub>, A<sub>d</sub>, A<sub>d</sub>)</td></tr>
<tr><td>GL_SRC_ALPHA_SA­TURATE</td><td>S</td><td>(f, f, f, 1)   f=min(A<sub>s</sub>, 1-A<sub>d</sub>)</td></tr>
</table>



<p><a name="k06"></a></p>
<h2 id="k06">6. První demonstrační příklad: jednoduchý blending</h2>

<pre>
def init():
    glClearColor(0.0, 0.0, 0.3, 0.0)          # barva pozadi obrazku
    glClearDepth(1.0)                         # implicitni hloubka ulozena v pameti hloubky
    glPolygonMode(GL_FRONT, GL_FILL)          # nastaveni rezimu vykresleni vyplnenych sten
    glPolygonMode(GL_BACK, GL_FILL)           # jak pro predni tak pro zadni steny
    glDisable(GL_CULL_FACE)                   # zadne hrany ani steny se nebudou odstranovat
    glDepthFunc(GL_LESS)                      # funkce pro testovani fragmentu
    glEnable(GL_BLEND)                        # povoleni blendingu
    glBlendFunc (GL_SRC_ALPHA, GL_ONE_MINUS_SRC_ALPHA)
</pre>

<pre>
#!/usr/bin/env python

import pyglet
from pyglet.gl import *
from pyglet.window import key

fov = 70.0                                    # hodnota zorneho uhlu - field of view
nearPlane = 0.1                               # blizsi orezavaci rovina
farPlane = 90.0                               # vzdalenejsi orezavaci rovina

r1 = 0.0
r2 = 0.0

depthBufferEnabled = False                    # povoleni ci zakaz Z-bufferu

window = pyglet.window.Window(width=500,
                              height=500,
                              caption="Pyglet+OpenGL")


keys = key.KeyStateHandler()
window.push_handlers(keys)



def init():
    glClearColor(0.0, 0.0, 0.3, 0.0)          # barva pozadi obrazku
    glClearDepth(1.0)                         # implicitni hloubka ulozena v pameti hloubky
    glPolygonMode(GL_FRONT, GL_FILL)          # nastaveni rezimu vykresleni vyplnenych sten
    glPolygonMode(GL_BACK, GL_FILL)           # jak pro predni tak pro zadni steny
    glDisable(GL_CULL_FACE)                   # zadne hrany ani steny se nebudou odstranovat
    glDepthFunc(GL_LESS)                      # funkce pro testovani fragmentu
    glEnable(GL_BLEND)                        # povoleni blendingu
    glBlendFunc (GL_SRC_ALPHA, GL_ONE_MINUS_SRC_ALPHA)



@window.event
def on_resize(width, height):
    init()
    glViewport(0, 0, width, height)           # viditelna oblast pres cele okno



def draw_walls():
    glBegin(GL_QUADS)                         # vykresleni otevrene krychle - sten domecku
    glColor4f(0.0, 0.0, 1.0, 0.5)                  # modra barva steny
    glVertex3f(-5.0, -5.0, -5.0)
    glVertex3f(-5.0, -5.0,  5.0)
    glVertex3f( 5.0, -5.0,  5.0)
    glVertex3f( 5.0, -5.0, -5.0)

    glColor4f(0.0, 1.0, 0.0, 0.5)             # zelena barva steny
    glVertex3f(-5.0,  5.0, -5.0)
    glVertex3f(-5.0,  5.0,  5.0)
    glVertex3f( 5.0,  5.0,  5.0)
    glVertex3f( 5.0,  5.0, -5.0)

    glColor4f(1.0, 0.0, 0.0, 0.5)             # cervena barva steny
    glVertex3f(-5.0, -5.0, -5.0)
    glVertex3f(-5.0, -5.0,  5.0)
    glVertex3f(-5.0,  5.0,  5.0)
    glVertex3f(-5.0,  5.0, -5.0)

    glColor4f(1.0, 1.0, 0.0, 0.5)             # zluta barva steny
    glVertex3f( 5.0, -5.0, -5.0)
    glVertex3f( 5.0, -5.0,  5.0)
    glVertex3f( 5.0,  5.0,  5.0)
    glVertex3f( 5.0,  5.0, -5.0)
    glEnd()



def draw_roof():
    glBegin(GL_TRIANGLES)                      # vykresleni strechy domecku z trojuhelniku
    glColor4f(0.0, 1.0, 1.0, 0.5)
    glVertex3f(-5.0,  5.0, -5.0)
    glVertex3f( 5.0,  5.0, -5.0)
    glVertex3f( 0.0, 11.0,  0.0)
 
    glColor4f(1.0, 0.0, 1.0, 0.5)
    glVertex3f( 5.0,  5.0, -5.0)
    glVertex3f( 5.0,  5.0,  5.0)
    glVertex3f( 0.0, 11.0,  0.0)
 
    glColor4f(1.0, 1.0, 1.0, 0.5)
    glVertex3f( 5.0,  5.0,  5.0)
    glVertex3f(-5.0,  5.0,  5.0)
    glVertex3f( 0.0, 11.0,  0.0)
 
    glColor4f(0.0, 0.0, 0.0, 0.5)
    glVertex3f(-5.0,  5.0,  5.0)
    glVertex3f(-5.0,  5.0, -5.0)
    glVertex3f( 0.0, 11.0,  0.0)
    glEnd()



def set_depth_buffer(depthBufferEnabled):
    if depthBufferEnabled:
        glEnable(GL_DEPTH_TEST)
    else:
        glDisable(GL_DEPTH_TEST)



def clear_buffers(depthBufferEnabled):
    if depthBufferEnabled:
        glClear(GL_COLOR_BUFFER_BIT | GL_DEPTH_BUFFER_BIT) # vymazani i Z/W bufferu
    else:
        glClear(GL_COLOR_BUFFER_BIT)          # vymazani vsech bitovych rovin barvoveho bufferu



@window.event
def on_draw():
    global r1, r2
    global depthBufferEnabled

    if keys[key.LEFT]:
        r2 = r2 - 1
    if keys[key.RIGHT]:
        r2 = r2 + 1
    if keys[key.UP]:
        r1 = r1 - 1
    if keys[key.DOWN]:
        r1 = r1 + 1
    if keys[key.E]:
        depthBufferEnabled = True
    if keys[key.D]:
        depthBufferEnabled = False

    clear_buffers(depthBufferEnabled)
    set_depth_buffer(depthBufferEnabled)

    glMatrixMode(GL_PROJECTION)               # zacatek modifikace projekcni matice
    glLoadIdentity()                          # vymazani projekcni matice (=identita)
    gluPerspective(fov, 1.0, nearPlane, farPlane);

    glMatrixMode(GL_MODELVIEW)
    glLoadIdentity()                          # nahrat jednotkovou matici

    gluLookAt(4.0, 6.0, 18.0,                 # bod, odkud se kamera diva
              0.0, 2.0,  0.0,                 # bod, kam se kamera diva
              0.0, 1.0,  0.0)                 # poloha "stropu" ve scene

    glRotatef(r1, 1.0, 0.0, 0.0)              # rotace objektu
    glRotatef(r2, 0.0, 1.0, 0.0) 

    draw_walls()
    draw_roof()



pyglet.app.run()
</pre>

*** image ***
<p><i>Obrázek 2: Screenshot prvního demonstračního příkladu.</i></p>



<p><a name="k07"></a></p>
<h2 id="k07">7. </h2>



<p><a name="k08"></a></p>
<h2 id="k08">8. </h2>



<p><a name="k09"></a></p>
<h2 id="k09">9. </h2>



<p><a name="k10"></a></p>
<h2 id="k10">10. </h2>



<p><a name="k11"></a></p>
<h2 id="k11">11. </h2>



<p><a name="k12"></a></p>
<h2 id="k12">12. </h2>



<p><a name="k13"></a></p>
<h2 id="k13">13. Repositář s&nbsp;demonstračními příklady</h2>



<p><a name="k14"></a></p>
<h2 id="k14">14. Odkazy na Internetu</h2>

<ol>

<li>Pyglet Home Page<br />
<a href="https://bitbucket.org/pyglet/pyglet/wiki/Home">https://bitbucket.org/pyglet/pyglet/wiki/Home</a>
</li>

<li>Dokumentace k verzi 1.2<br />
<a href="https://pyglet.readthedocs.io/en/pyglet-1.2-maintenance/">https://pyglet.readthedocs.io/en/pyglet-1.2-maintenance/</a>
</li>

<li>Dokumentace k verzi 1.2 ve formátu PDF<br />
<a href="https://readthedocs.org/projects/pyglet/downloads/pdf/pyglet-1.2-maintenance/">https://readthedocs.org/projects/pyglet/downloads/pdf/pyglet-1.2-maintenance/</a>
</li>

<li>PyOpenGL<br />
<a href="http://pyopengl.sourceforge.net/">http://pyopengl.sourceforge.net/</a>
</li>

<li>The #! magic, details about the shebang/hash-bang mechanism on various Unix flavours<br />
<a href="https://www.in-ulm.de/~mascheck/various/shebang/">https://www.in-ulm.de/~mascheck/various/shebang/</a>
</li>

<li>Shebang (Unix)<br />
<a href="https://en.wikipedia.org/wiki/Shebang_%28Unix%29">https://en.wikipedia.org/wiki/Shebang_%28Unix%29</a>
</li>

<li>Domovská stránka systému LÖVE<br />
<a href="http://love2d.org/">http://love2d.org/</a>
</li>

<li>Simple DirectMedia Layer (home page)<br />
<a href="http://www.libsdl.org/">http://www.libsdl.org/</a>
</li>

<li>Simple DirectMedia Layer (Wikipedia)<br />
<a href="https://en.wikipedia.org/wiki/Simple_DirectMedia_Layer">https://en.wikipedia.org/wiki/Simple_DirectMedia_Layer</a>
</li>

<li>Seriál Grafická knihovna OpenGL<br />
<a href="https://www.root.cz/serialy/graficka-knihovna-opengl/">https://www.root.cz/serialy/graficka-knihovna-opengl/</a>
</li>

<li>Pyglet event loop<br />
<a href="http://pyglet.readthedocs.io/en/latest/programming_guide/eventloop.html">http://pyglet.readthedocs.io/en/latest/programming_guide/eventloop.html</a>
</li>

<li>Decorators I: Introduction to Python Decorators<br />
<a href="http://www.artima.com/weblogs/viewpost.jsp?thread=240808">http://www.artima.com/weblogs/viewpost.jsp?thread=240808</a>
</li>

<li>3D Programming in Python - Part 1 <br />
<a href="https://greendalecs.wordpress.com/2012/04/21/3d-programming-in-python-part-1/">https://greendalecs.wordpress.com/2012/04/21/3d-programming-in-python-part-1/</a>
</li>

<li>A very basic Pyglet tutorial<br />
<a href="http://www.natan.termitnjak.net/tutorials/pyglet_basic.html">http://www.natan.termitnjak.net/tutorials/pyglet_basic.html</a>
</li>

</ol>



<p></p><p></p>
<p><small>Autor: <a href="http://www.fit.vutbr.cz/~tisnovpa">Pavel Tišnovský</a> &nbsp; 2017</small></p>
</body>
</html>

