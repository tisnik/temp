<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
        "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html>
<head>
<title>Multimediální knihovna Pyglet: blending při kreslení 2D i 3D scén</title>
<meta name="Author" content="Pavel Tisnovsky" />
<meta name="Generator" content="vim" />
<meta http-equiv="content-type" content="text/html; charset=utf-8" />
<style type="text/css">
         body {color:#000000; background:#ffffff;}
         h1  {font-family: arial, helvetica, sans-serif; color:#ffffff; background-color:#c00000; text-align:center; padding-left:1em}
         h2  {font-family: arial, helvetica, sans-serif; color:#ffffff; background-color:#0000c0; padding-left:1em; text-align:left}
         h3  {font-family: arial, helvetica, sans-serif; color:#000000; background-color:#c0c0c0; padding-left:1em; text-align:left}
         h4  {font-family: arial, helvetica, sans-serif; color:#000000; background-color:#e0e0e0; padding-left:1em; text-align:left}
         a   {font-family: arial, helvetica, sans-serif;}
         li  {font-family: arial, helvetica, sans-serif; color:#000000; text-align:justify; width:450px;}
         ol  {font-family: arial, helvetica, sans-serif; color:#000000; text-align:justify; width:450px;}
         ul  {font-family: arial, helvetica, sans-serif; color:#000000; text-align:justify; width:450px;}
         p   {font-family: arial, helvetica, sans-serif; color:#000000; text-align:justify;}
         pre {background:#e0e0e0}
</style>
</head>

<body>

<h1>Multimediální knihovna Pyglet: blending při kreslení 2D i 3D scén</h1>

<h3>Pavel Tišnovský</h3>

<p></p>

<h1>Úvodník</h1>

<p>V&nbsp;páté části seriálu o multimediální knihovně Pyglet si ukážeme, jakým způsobem se používá takzvaný &bdquo;blending&ldquo; (míchání) podporovaný grafickými akcelerátory i knihovnou OpenGL. Taktéž se zmíníme o možnostech kombinace blendingu s&nbsp;funkcí paměti hloubky (Z-bufferu).</p>



<h2>Obsah</h2>

<p><a href="#k01">1. Multimediální knihovna Pyglet: blending při kreslení 2D i 3D scén</a></p>
<p><a href="#k02">2. Co je to fragment?</a></p>
<p><a href="#k03">3. Povolení a zákaz blendingu</a></p>
<p><a href="#k04">4. Míchací rovnice použitá při blendingu</a></p>
<p><a href="#k05">5. Specifikace parametrů míchací rovnice funkcemi OpenGL</a></p>
<p><a href="#k06">6. První demonstrační příklad: jednoduchý blending</a></p>
<p><a href="#k07">7. Kombinace funkce blendingu a paměti hloubky</a></p>
<p><a href="#k08">8. Druhý demonstrační příklad: blending + paměť hloubky</a></p>
<p><a href="#k09">9. Otestování více variant míchací funkce</a></p>
<p><a href="#k10">10. Třetí demonstrační příklad: více variant míchací funkce</a></p>
<p><a href="#k11">11. Vliv alfa složky při aplikaci míchací funkce</a></p>
<p><a href="#k12">12. Čtvrtý demonstrační příklad: vliv alfa složky při aplikaci míchací funkce</a></p>
<p><a href="#k13">13. Repositář s&nbsp;demonstračními příklady</a></p>
<p><a href="#k14">14. Odkazy na Internetu</a></p>



<p><a name="k01"></a></p>
<h2 id="k01">1. Multimediální knihovna Pyglet: blending při kreslení 2D i 3D scén</h2>

<p>V&nbsp;předchozích dílech seriálu o multimediální knihovně Pyglet jsme si již několikrát popisovali barvový formát používaný při práci s&nbsp;barvami v&nbsp;OpenGL (a tím pádem nepřímo používaný i na grafických akcelerátorech). Připomeňme si ve stručnosti, že barvy jsou v&nbsp;tomto barvovém formátu popsány s&nbsp;využitím tří barvových složek označovaných písmeny <strong>R</strong> (<i>Red</i>), <strong>G</strong> (<i>Green</i>) a <strong>B</strong> (<i>Blue</i>). Při použití čísel typu <i>float</i> je hodnota složek v&nbsp;rozsahu 0,0 až 0,1 (včetně obou mezních hodnot), ovšem je možné použít i celočíselné hodnoty s&nbsp;rozsahem 0 až 255. K&nbsp;těmto složkám se často přidává ještě složka čtvrtá, nazývaná <strong>A</strong> (<i>Alpha</i>). Výsledný barvový model se označuje zkratkou <strong>RGBA</strong>.</p>

<a href="https://mojefedora.cz/wp-content/uploads/2017/04/01.jpg"><img class="alignnone size-thumbnail wp-image-8800" src="https://mojefedora.cz/wp-content/uploads/2017/04/01.jpg" alt="" width="125" height="109" /></a>
<p><i>Obrázek 1: Použití blendingu pro vykreslování výbuchů s&nbsp;využitím jednoduchých částicových systémů.</i></p>

<p>K&nbsp;čemu vlastně může být alfa složka užitečná? Všechny moderní grafické akcelerátory mohou při vykreslování provádět i takzvaný <i>blending</i> neboli míchání (barev). A k&nbsp;tomuto účelu se většinou používá právě již zmíněná čtvrtá barvová složka specifikovaná příkazem <strong>glColor4f(R, G, B, A)</strong> a nikoli &bdquo;pouze&ldquo; příkazem <strong>glColor3f(R, G, B)</strong>. Složka alfa může na základě nastavené blending funkce (viz další text) představovat například průhlednost specifikované barvy. Při použití blendingu musíme nejdříve nastavit, jakým způsobem se budou kombinovat právě vykreslované <i>fragmenty</i> s&nbsp;hodnotami uloženými ve framebufferu.</p>

<a href="https://mojefedora.cz/wp-content/uploads/2017/04/02.jpg"><img class="alignnone size-thumbnail wp-image-8801" src="https://mojefedora.cz/wp-content/uploads/2017/04/02.jpg" alt="" width="101" height="101" /></a>
<p><i>Obrázek 2: Použití blendingu pro vykreslování &bdquo;magických jevů&ldquo;.</i></p>



<p><a name="k02"></a></p>
<h2 id="k02">2. Co je to fragment?</h2>

<p>Připomeňme si, že <i>fragment</i> je datová struktura složená z&nbsp;barvy pixelu, jeho průhlednosti, vzdálenosti od pozorovatele a případných dalších informací. Framebuffer je v&nbsp;podstatě pravidelná matice fragmentů. Barvy fragmentů tvoří ve framebufferu samostatný color-buffer, který se zobrazuje na obrazovce. Rasterizace je proces, kterým se matematický model plošky (trojúhelníku, čtyřúhelníku, konvexního polygonu) převádí na jednotlivé fragmenty. Způsob míchání barvy uložené ve framebufferu a barvy vykreslovaného fragmentu se řídí uživatelem definovanou míchací rovnicí (<i>blending function</i>). V&nbsp;této rovnici vystupují následující členy:</p>

<ol>

<li>Zdroj (<i>source</i>) je fragment vzniklý rasterizací v&nbsp;právě běžícím rasterizačním procesu.</li>

<li>Cíl (<i>destination</i>) je hodnota zapsaná ve framebufferu, tj.&nbsp;barva fragmentu, který již byl vykreslen dříve. Tato hodnota bude v&nbsp;závislosti na nastavené blending funkci přepsána nebo jinak ovlivněna.</li>

</ol>

<p>Na schématu se zjednodušenou vykreslovací pipeline si povšimněte především toho, že při blendingu je nutné kombinovat již vykreslený obsah framebufferu s&nbsp;novými fragmenty:</p>

<a href="https://mojefedora.cz/wp-content/uploads/2017/04/03-4.png"><img class="alignnone size-thumbnail wp-image-8802" src="https://mojefedora.cz/wp-content/uploads/2017/04/03-4-366x254.png" alt="" width="366" height="254" /></a>
<p><i>Obrázek 3: Klasická OpenGL pipeline se zvýrazněním bloku, v&nbsp;němž se provádí blending. Povšimněte si, že v&nbsp;tomto kroku je zapotřebí číst údaje z&nbsp;framebufferu, tj.&nbsp;údaje o rasterizovaných fragmentech.</i></p>



<p><a name="k03"></a></p>
<h2 id="k03">3. Povolení a zákaz blendingu</h2>

<p>V&nbsp;knihovně OpenGL lze stanovit koeficienty míchání pro každou barvovou složku zvlášť. Tak lze jednoduše dosáhnout na první pohled složitých efektů, například maskování jedné barvy apod. Při spuštění programu, který používá pro vykreslování grafickou knihovnu OpenGL, je vliv alfa složky na vykreslovanou plošku zakázán. Proto pokud chceme programovat některé grafické efekty, musíme před vykreslením vhodně nastavit režim míchání již nakreslené části scény s&nbsp;nově vykreslovanými tělesy. Podobně jako je tomu i v&nbsp;dalších případech se o povolení stará funkce nazvaná <strong>glEnable()</strong> a o zákaz funkce nazvaná <strong>glDisable()</strong>. Povolení blendingu tedy může vypadat následovně:</p>

<pre>
def init():
    glClearColor(0.0, 0.0, 0.3, 0.0)          # barva pozadi obrazku
    glClearDepth(1.0)                         # implicitni hloubka ulozena v pameti hloubky
    ...
    ...
    # další funkce
    ...
    ...
    glEnable(GL_BLEND)                        # povoleni blendingu
</pre>

<p>Poznámka: blending lze selektivně zapínat či vypínat i přímo při vykreslování, což je ostatně často děje i v&nbsp;praxi.</p>


<a href="https://mojefedora.cz/wp-content/uploads/2017/04/06-2.png"><img class="alignnone size-thumbnail wp-image-8779" src="https://mojefedora.cz/wp-content/uploads/2017/04/06-2-243x254.png" alt="" width="243" height="254" /></a>
<p><i>Obrázek 4: Screenshot demonstračního příkladu, v&nbsp;němž se při vykreslení domečku používá paměť hloubky neboli Z-buffer.</i></p>



<p><a name="k04"></a></p>
<h2 id="k04">4. Míchací rovnice použitá při blendingu</h2>

<p>Míchací rovnici, která se tradičně v&nbsp;knihách o počítačové grafice zapisuje ve vektorovém tvaru, lze rozepsat do čtyř rovnic odpovídajících barvovému modelu RGBA:</p>

<p>R<sub>n</sub> = R<sub>s</sub> &times; S<sub>r</sub> + R<sub>d</sub> &times; D<sub>r</sub><br />
G<sub>n</sub> = G<sub>s</sub> &times; S<sub>g</sub> + G<sub>d</sub> &times; D<sub>g</sub><br />
B<sub>n</sub> = B<sub>s</sub> &times; S<sub>b</sub> + B<sub>d</sub> &times; D<sub>b</sub><br />
A<sub>n</sub> = A<sub>s</sub> &times; S<sub>a</sub> + A<sub>d</sub> &times; D<sub>a</sub><br />
</p>

<p>Význam jednotlivých členů v&nbsp;rovnicích:</p>

<table>
<tr><th>Člen</th><th>Stručný popis</th></tr>
<tr><td>R<sub>n</sub></td><td>nově vypočtená červená barevná složka</td></tr>
<tr><td>G<sub>n</sub></td><td>nově vypočtená zelená barevná složka</td></tr>
<tr><td>B<sub>n</sub></td><td>nově vypočtená modrá barevná složka</td></tr>
<tr><td>A<sub>n</sub></td><td>nová hodnota alfa složky</td></tr>
<tr><td>&nbsp;</td><td>&nbsp;</td></tr>
<tr><td>R<sub>s</sub></td><td>červená barevná složka zdrojového fragmentu</td></tr>
<tr><td>G<sub>s</sub></td><td>zelená barevná složka zdrojového fragmentu</td></tr>
<tr><td>B<sub>s</sub></td><td>modrá barevná složka zdrojového fragmentu</td></tr>
<tr><td>A<sub>s</sub></td><td>alfa složka zdrojového fragmentu</td></tr>
<tr><td>&nbsp;</td><td>&nbsp;</td></tr>
<tr><td>R<sub>d</sub></td><td>červená barevná složka cílového fragmentu</td></tr>
<tr><td>G<sub>d</sub></td><td>zelená barevná složka cílového fragmentu</td></tr>
<tr><td>B<sub>d</sub></td><td>modrá barevná složka cílového fragmentu</td></tr>
<tr><td>A<sub>d</sub></td><td>alfa složka cílového fragmentu</td></tr>
<tr><td>&nbsp;</td><td>&nbsp;</td></tr>
<tr><td>S<sub>r</sub></td><td>míchací faktor pro červenou barvu zdrojového fragmentu</td></tr>
<tr><td>S<sub>g</sub></td><td>míchací faktor pro zelenou barvu zdrojového fragmentu</td></tr>
<tr><td>S<sub>b</sub></td><td>míchací faktor pro modrou barvu zdrojového fragmentu</td></tr>
<tr><td>S<sub>a</sub></td><td>míchací faktor pro alfa složku zdrojového fragmentu</td></tr>
<tr><td>&nbsp;</td><td>&nbsp;</td></tr>
<tr><td>D<sub>r</sub></td><td>míchací faktor pro červenou barvu cílového fragmentu</td></tr>
<tr><td>D<sub>g</sub></td><td>míchací faktor pro zelenou barvu cílového fragmentu</td></tr>
<tr><td>D<sub>b</sub></td><td>míchací faktor pro modrou barvu cílového fragmentu</td></tr>
<tr><td>D<sub>a</sub></td><td>míchací faktor pro alfa složku cílového fragmentu</td></tr>
</table>

<p>Pro praxi si však stačí zapamatovat význam jednotlivých písmen: R-red, G-green, B-blue, A-alpha, n-new fragment, s-source fragment, d-destination fragment.</p>



<p><a name="k05"></a></p>
<h2 id="k05">5. Specifikace parametrů míchací rovnice funkcemi OpenGL</h2>

<p>Ve výše uvedených rovnicích je nutné specifikovat míchací faktory (koeficienty) S<sub>r</sub>, S<sub>g</sub>, S<sub>b</sub>, S<sub>a</sub>, D<sub>r</sub>, D<sub>g</sub>, D<sub>b</sub> a D<sub>a</sub>, ostatní hodnoty odpovídají barvám a alfa-složkám zdrojových a cílových fragmentů. Koeficienty S a D se nezadávají přímo číselnou hodnotou, protože se mohou měnit v&nbsp;závislosti na barvách zdrojových a cílových fragmentů. Místo toho se používají symboly, jejichž konkrétní hodnota se vypočte automaticky při rasterizaci.</p>

<p>Pro zadání míchacích koeficientů se používá funkce:</p>

<pre>
glBlendFunc(sFactor, dFactor)
</pre>

<p>První parametr <strong>sFactor</strong> určuje způsob výpočtu míchacích faktorů S<sub>r</sub>, S<sub>g</sub>, S<sub>b</sub> a S<sub>a</sub>, druhý parametr <strong>dFactor</strong> způsob výpočtu faktorů D<sub>r</sub>, D<sub>g</sub>, D<sub>b</sub> a D<sub>a</sub>.</p>

<p>Pro hodnoty, které lze do těchto parametrů dosadit, platí základní jednoduchá pravidla:</p>

<ol>

<li>Za sFactor popř. dFactor je možné dosadit některou z&nbsp;konstant, které jsou předdefinovány v&nbsp;hlavičkovém souboru <i>gl.h</i> (to samozřejmě platí především pro nativní aplikace psané v&nbsp;C či C++, nicméně podobné konstanty nalezneme i v&nbsp;Pygletu).</li>

<li>Některé z&nbsp;těchto konstant je možné zadat do obou parametrů. Jedná se například o konstanty <i>GL_ZERO</i>, <i>GL_ONE</i> apod. Význam těchto konstant se samozřejmě liší podle toho, do kterého parametru jsou dosazeny.</li>

<li>Některé konstanty lze použít pouze pro parametr sFactor. Jedná se zejména o konstanty <i>GL_DST_COLOR</i> nebo <i>GL_ONE_MINUS_DST_COLOR</i> (v&nbsp;novějších verzích OpenGL již toto omezení neplatí).</li>

<li>Některé konstanty lze naopak použít pouze pro parametr dFactor. Jde o konstanty <i>GL_SRC_COLOR</i>, <i>GL_ONE_MINUS_SRC_COLOR</i> apod. (opět: v&nbsp;novějších verzích OpenGL již toto omezení neplatí)</li>

</ol>

<p>V&nbsp;následující tabulce je vypsán význam míchacích faktorů, které můžeme použít pro specifikaci koeficientů míchací rovnice. Ve sloupci <i>Název</i> je uvedeno jméno faktoru, tj.&nbsp;symbolická konstanta definovaná v&nbsp;souboru <i>gl.h</i> popř.&nbsp;modulu Pygletu. Ve sloupci <i>Použití</i> je označeno, zda se může symbolická konstanta použít pro dosazení do parametru <i>sFactor</i> (S), <i>dFactor</i> (D) nebo do obou parametrů. Ve sloupci <i>Význam</i> jsou ve vektorovém tvaru naznačeny hodnoty zdrojových či cílových koeficientů.</p>

<table>
<tr><th>Název</th><th>Použití</th><th>Význam</th></tr>
<tr><td>GL_ZERO</td><td>S nebo D</td><td>(0, 0, 0, 0)</td></tr>
<tr><td>GL_ONE</td><td>S nebo D</td><td>(1, 1, 1, 1)</td></tr>
<tr><td>GL_DST_COLOR</td><td>S</td><td>(R<sub>d</sub>, G<sub>d</sub>, B<sub>d</sub>, A<sub>d</sub>)</td></tr>
<tr><td>GL_SRC_COLOR</td><td>D</td><td>(R<sub>s</sub>, G<sub>s</sub>, B<sub>s</sub>, A<sub>s</sub>)</td></tr>
<tr><td>GL_ONE_MINUS_DST_COLOR</td><td>S</td><td>(1, 1, 1, 1)-(R<sub>d</sub>, G<sub>d</sub>, B<sub>d</sub>, A<sub>d</sub>)</td></tr>
<tr><td>GL_ONE_MINUS_SRC_COLOR</td><td>D</td><td>(1, 1, 1, 1)-(R<sub>s</sub>, G<sub>s</sub>, B<sub>s</sub>, A<sub>s</sub>)</td></tr>
<tr><td>GL_SRC_ALPHA</td><td>S nebo D</td><td>(A<sub>s</sub>, A<sub>s</sub>, A<sub>s</sub>, A<sub>s</sub>)</td></tr>
<tr><td>GL_ONE_MINUS_SRC_ALPHA</td><td>S nebo D</td><td>(1, 1, 1, 1)-(A<sub>s</sub>, A<sub>s</sub>, A<sub>s</sub>, A<sub>s</sub>)</td></tr>
<tr><td>GL_DST_ALPHA</td><td>S nebo D</td><td>(A<sub>d</sub>, A<sub>d</sub>, A<sub>d</sub>, A<sub>d</sub>)</td></tr>
<tr><td>GL_ONE_MINUS_DST_ALPHA</td><td>S nebo D</td><td>(1, 1, 1, 1)-(A<sub>d</sub>, A<sub>d</sub>, A<sub>d</sub>, A<sub>d</sub>)</td></tr>
<tr><td>GL_SRC_ALPHA_SATURATE</td><td>S</td><td>(f, f, f, 1)   f=min(A<sub>s</sub>, 1-A<sub>d</sub>)</td></tr>
</table>

<p>Jako příklad na použití blendingu si uvedeme jednoduchý problém. Máme zobrazit dvě plošky přes sebe, ale při překrytí má být bližší ploška průhledná z&nbsp;50%. Postup řešení tohoto problému je následující:</p>

<ol>
<li>Blending globálně povolíme příkazem <i>glEnable(GL_BLEN­D)</i>.</li>
<li>Nastavíme zdrojový faktor na hodnotu <i>GL_ONE</i>.</li>
<li>Nastavíme cílový faktor na hodnotu <i>GL_ZERO</i>.</li>
<li>Vykreslíme první (spodní) plošku. Tato ploška je vykreslena svou originální barvou, protože cílový fragment (tj.&nbsp;pozadí) je vynulován a barva plošky je vynásobena jedničkou.</li>
<li>Nastavíme zdrojový faktor na hodnotu <i>GL_SRC_ALPHA</i>.</li>
<li>Nastavíme cílový faktor na hodnotu <i>GL_ONE_MINUS_SRC_AL­PHA</i>.</li>
<li>Vykreslíme druhou (vrchní) plošku. Alfa hodnota barvy této plošky musí být nastavena na 0.5. To znamená, že se zdrojový i cílový faktor vynásobí stejnou hodnotou (1=1&#8211;0.5) a posléze sečtou. Výsledkem našeho snažení je, že tato druhá ploška je vykreslena s&nbsp;padesátiprocentní průhledností.</li>
</ol>



<p><a name="k06"></a></p>
<h2 id="k06">6. První demonstrační příklad: jednoduchý blending</h2>

<p>V&nbsp;dnešním prvním demonstračním příkladu nejdříve ve funkci <strong>init</strong> povolíme blending a nastavíme míchání s&nbsp;použitím faktorů <strong>GL_SRC_ALPHA</strong> a <strong>GL_ONE_MINUS_SRC_ALPHA</strong>, což znamená, že se každá ploška vykreslí poloprůhledně s&nbsp;ohledem na čtvrtou barvovou složku (alfa). Jedná se o nejběžnější použití blendingu v&nbsp;praxi:</p>

<pre>
def init():
    glClearColor(0.0, 0.0, 0.3, 0.0)                   # barva pozadi obrazku
    glClearDepth(1.0)                                  # implicitni hloubka ulozena v pameti hloubky
    glPolygonMode(GL_FRONT, GL_FILL)                   # nastaveni rezimu vykresleni vyplnenych sten
    glPolygonMode(GL_BACK, GL_FILL)                    # jak pro predni tak pro zadni steny
    glDisable(GL_CULL_FACE)                            # zadne hrany ani steny se nebudou odstranovat
    glDepthFunc(GL_LESS)                               # funkce pro testovani fragmentu
    glEnable(GL_BLEND)                                 # povoleni blendingu
    glBlendFunc (GL_SRC_ALPHA, GL_ONE_MINUS_SRC_ALPHA) # blending funkce
</pre>

<p>Klávesami <strong>E</strong> a <strong>D</strong> je možné povolit funkci paměti hloubky, která je ovšem v&nbsp;souvislosti s&nbsp;blendingem problematická &ndash; většinou potřebujeme vykreslit všechny plošky, nejenom ty, které jsou nejblíže k&nbsp;pozorovateli. Kurzorovými klávesami je možné otáčet 3D modelem &ndash; domečkem:</p>

<pre>
if keys[key.LEFT]:
    r2 = r2 - 1
if keys[key.RIGHT]:
    r2 = r2 + 1
if keys[key.UP]:
    r1 = r1 - 1
if keys[key.DOWN]:
    r1 = r1 + 1
if keys[key.E]:
    depthBufferEnabled = True
if keys[key.D]:
    depthBufferEnabled = False
</pre>

<a href="https://mojefedora.cz/wp-content/uploads/2017/04/07-2.png"><img class="alignnone size-thumbnail wp-image-8780" src="https://mojefedora.cz/wp-content/uploads/2017/04/07-2-243x254.png" alt="" width="243" height="254" /></a>
<p><i>Obrázek 5: Screenshot prvního demonstračního příkladu.</i></p>

<p>Následuje výpis celého zdrojového kódu dnešního prvního demonstračního příkladu:</p>

<pre>
#!/usr/bin/env python

import pyglet
from pyglet.gl import *
from pyglet.window import key

fov = 70.0                                    # hodnota zorneho uhlu - field of view
nearPlane = 0.1                               # blizsi orezavaci rovina
farPlane = 90.0                               # vzdalenejsi orezavaci rovina

r1 = 0.0
r2 = 0.0

depthBufferEnabled = False                    # povoleni ci zakaz Z-bufferu

window = pyglet.window.Window(width=500,
                              height=500,
                              caption="Pyglet+OpenGL")


keys = key.KeyStateHandler()
window.push_handlers(keys)



def init():
    glClearColor(0.0, 0.0, 0.3, 0.0)          # barva pozadi obrazku
    glClearDepth(1.0)                         # implicitni hloubka ulozena v pameti hloubky
    glPolygonMode(GL_FRONT, GL_FILL)          # nastaveni rezimu vykresleni vyplnenych sten
    glPolygonMode(GL_BACK, GL_FILL)           # jak pro predni tak pro zadni steny
    glDisable(GL_CULL_FACE)                   # zadne hrany ani steny se nebudou odstranovat
    glDepthFunc(GL_LESS)                      # funkce pro testovani fragmentu
    glEnable(GL_BLEND)                        # povoleni blendingu
    glBlendFunc (GL_SRC_ALPHA, GL_ONE_MINUS_SRC_ALPHA)



@window.event
def on_resize(width, height):
    init()
    glViewport(0, 0, width, height)           # viditelna oblast pres cele okno



def draw_walls():
    glBegin(GL_QUADS)                         # vykresleni otevrene krychle - sten domecku
    glColor4f(0.0, 0.0, 1.0, 0.5)                  # modra barva steny
    glVertex3f(-5.0, -5.0, -5.0)
    glVertex3f(-5.0, -5.0,  5.0)
    glVertex3f( 5.0, -5.0,  5.0)
    glVertex3f( 5.0, -5.0, -5.0)

    glColor4f(0.0, 1.0, 0.0, 0.5)             # zelena barva steny
    glVertex3f(-5.0,  5.0, -5.0)
    glVertex3f(-5.0,  5.0,  5.0)
    glVertex3f( 5.0,  5.0,  5.0)
    glVertex3f( 5.0,  5.0, -5.0)

    glColor4f(1.0, 0.0, 0.0, 0.5)             # cervena barva steny
    glVertex3f(-5.0, -5.0, -5.0)
    glVertex3f(-5.0, -5.0,  5.0)
    glVertex3f(-5.0,  5.0,  5.0)
    glVertex3f(-5.0,  5.0, -5.0)

    glColor4f(1.0, 1.0, 0.0, 0.5)             # zluta barva steny
    glVertex3f( 5.0, -5.0, -5.0)
    glVertex3f( 5.0, -5.0,  5.0)
    glVertex3f( 5.0,  5.0,  5.0)
    glVertex3f( 5.0,  5.0, -5.0)
    glEnd()



def draw_roof():
    glBegin(GL_TRIANGLES)                      # vykresleni strechy domecku z trojuhelniku
    glColor4f(0.0, 1.0, 1.0, 0.5)
    glVertex3f(-5.0,  5.0, -5.0)
    glVertex3f( 5.0,  5.0, -5.0)
    glVertex3f( 0.0, 11.0,  0.0)
 
    glColor4f(1.0, 0.0, 1.0, 0.5)
    glVertex3f( 5.0,  5.0, -5.0)
    glVertex3f( 5.0,  5.0,  5.0)
    glVertex3f( 0.0, 11.0,  0.0)
 
    glColor4f(1.0, 1.0, 1.0, 0.5)
    glVertex3f( 5.0,  5.0,  5.0)
    glVertex3f(-5.0,  5.0,  5.0)
    glVertex3f( 0.0, 11.0,  0.0)
 
    glColor4f(0.0, 0.0, 0.0, 0.5)
    glVertex3f(-5.0,  5.0,  5.0)
    glVertex3f(-5.0,  5.0, -5.0)
    glVertex3f( 0.0, 11.0,  0.0)
    glEnd()



def set_depth_buffer(depthBufferEnabled):
    if depthBufferEnabled:
        glEnable(GL_DEPTH_TEST)
    else:
        glDisable(GL_DEPTH_TEST)



def clear_buffers(depthBufferEnabled):
    if depthBufferEnabled:
        glClear(GL_COLOR_BUFFER_BIT | GL_DEPTH_BUFFER_BIT) # vymazani i Z/W bufferu
    else:
        glClear(GL_COLOR_BUFFER_BIT)          # vymazani vsech bitovych rovin barvoveho bufferu



@window.event
def on_draw():
    global r1, r2
    global depthBufferEnabled

    if keys[key.LEFT]:
        r2 = r2 - 1
    if keys[key.RIGHT]:
        r2 = r2 + 1
    if keys[key.UP]:
        r1 = r1 - 1
    if keys[key.DOWN]:
        r1 = r1 + 1
    if keys[key.E]:
        depthBufferEnabled = True
    if keys[key.D]:
        depthBufferEnabled = False

    clear_buffers(depthBufferEnabled)
    set_depth_buffer(depthBufferEnabled)

    glMatrixMode(GL_PROJECTION)               # zacatek modifikace projekcni matice
    glLoadIdentity()                          # vymazani projekcni matice (=identita)
    gluPerspective(fov, 1.0, nearPlane, farPlane);

    glMatrixMode(GL_MODELVIEW)
    glLoadIdentity()                          # nahrat jednotkovou matici

    gluLookAt(4.0, 6.0, 18.0,                 # bod, odkud se kamera diva
              0.0, 2.0,  0.0,                 # bod, kam se kamera diva
              0.0, 1.0,  0.0)                 # poloha "stropu" ve scene

    glRotatef(r1, 1.0, 0.0, 0.0)              # rotace objektu
    glRotatef(r2, 0.0, 1.0, 0.0) 

    draw_walls()
    draw_roof()



pyglet.app.run()
</pre>

<a href="https://mojefedora.cz/wp-content/uploads/2017/04/06-3.png"><img class="alignnone size-thumbnail wp-image-8803" src="https://mojefedora.cz/wp-content/uploads/2017/04/06-3-243x254.png" alt="" width="243" height="254" /></a>
<p><i>Obrázek 6: Screenshot prvního demonstračního příkladu ve chvíli, kdy je povolena funkce paměti hloubky.</i></p>



<p><a name="k07"></a></p>
<h2 id="k07">7. Kombinace funkce blendingu a paměti hloubky</h2>

<p>Při vykreslování průhledných těles záleží na pořadí vykreslování objektů. Jako první by se proto měly vykreslit nejvzdálenější objekty (resp.&nbsp;přesněji řečeno jejich plošky). Zejména proto, že řazení plošek podle vzdálenosti od pozorovatele je časově náročné a nejednoznačné, je nutno metodu trošku vylepšit. Doporučuje se proto dodržovat následující postup:</p>

<ol>

<li>Nejprve je zapotřebí při startu aplikace alokovat společně s&nbsp;barvovými buffery i hloubkový buffer (Z-buffer). To je v&nbsp;knihovně Pyglet splněno automaticky.</li>

<li>Hloubkový buffer se musí nastavit do režimu čtení i zápisu (read-write) hloubek fragmentů. Toho dosáhneme zavoláním příkazu <i>glDepthMask(GL_TRUE)</i>.</li>

<li>Po nastavení hloubkového bufferu se vykreslí všechny neprůhledné objekty. Tyto objekty se vzhledem k&nbsp;testu hloubky každého vykreslovaného fragmentu vykreslí korektně. To je zapříčiněno funkcí hloubkového bufferu, který pro každý vykreslovaný fragment testuje, zda je umístěn před nebo za již vykresleným fragmentem, jehož hloubka je v hloubkovém bufferu uložena. Po vykreslení všech neprůhledných objektů je tedy v&nbsp;hloubkovém bufferu zapsána &bdquo;výšková mapa&ldquo;; nejbližších vykreslených fragmentů v&nbsp;každé buňce framebufferu.</li>

<li>Před vykreslením průhledných objektů se musí hloubkový režim nastavit do režimu read-only, tj. hloubky fragmentů jsou z hloubkového bufferu pouze čteny (a popř. odstraněny z dalšího vykreslování). Zápis hodnot do hloubkového bufferu je zakázán, protože průhledné objekty se musí vykreslit i tehdy, pokud jsou schovány za dalším průhledným objektem a neprůhledné objekty se za objekty průhlednými nesmí vymazat. Nastavení hloubkového bufferu do režimu read-only provedeme příkazem <i>glDepthMask(GL_FALSE)</i>.</li>

<li>Dalším krokem je seřazení průhledných objektů podle jejich hloubky (vzdálenosti) od pozorovatele. Objekty se poté vykreslí v&nbsp;tomto pořadí, nejdříve samozřejmě objekt nejvzdálenější.</li>

<li>Složité objekty, tj.&nbsp;objekty, jejichž plošky jsou složeny z&nbsp;mnohoúhelníků, je někdy nutné <i>tesselací</i> rozdělit na jednotlivé trojúhelníky, jinak by mohly nastat vizuální chyby při překrývání objektů. K&nbsp;tesselaci je možné použít funkce z&nbsp;knihovny GLU. U moderních GPU se doporučuje tesselaci provést vždy, neboť se vykreslování urychlí.</li>

<li>Po vykreslení všech průhledných objektů se hloubkový buffer nastaví opět do režimu read-write (<i>glDepthMask(GL_TRUE)</i>), aby se v&nbsp;příštím průchodu neprůhledné objekty vykreslily korektně.</li>

</ol>



<p><a name="k08"></a></p>
<h2 id="k08">8. Druhý demonstrační příklad: blending + paměť hloubky</h2>

<p>Ve druhém demonstračním příkladu je ukázána kombinace použití blendingu a paměti hloubky. Kromě našeho 3D domečku jsou do scény vloženy dvě poloprůhledné stěny. Povšimněte si postupu vykreslování těchto stěn, kdy se nejdříve Z-buffer přepne do režimu čtení a po vykreslení stěn se opět zapne do režimu čtení+zápisu:</p>

<pre>
def draw_planes():
    glMatrixMode(GL_MODELVIEW)                  # bude se menit modelova matice
    glLoadIdentity()                            # nahrat jednotkovou matici
    glTranslatef(0.0, 0.0, -50.0)               # posun objektu dale od kamery
    glDepthMask(GL_FALSE)                       # Z-buffer v rezimu read-only
    glEnable(GL_BLEND)                          # povoleni michani
    glBlendFunc(GL_SRC_ALPHA, GL_ONE_MINUS_SRC_ALPHA) # michaci funkce
    glBegin(GL_QUADS)                           # vykresleni dvou rovin
    glColor4f(1.0, 0.5, 0.5, 0.7) 
    glVertex3f(-14.0, -8.0, 35.0) 
    glVertex3f( -0.0, -8.0, 35.0) 
    glVertex3f( -0.0,  8.0, 35.0) 
    glVertex3f(-14.0,  8.0, 35.0) 
    glColor4f(0.5, 0.5, 1.0, 0.7) 
    glVertex3f(  0.0, -8.0, 25.0) 
    glVertex3f( 14.0, -8.0, 25.0) 
    glVertex3f( 14.0,  8.0, 25.0) 
    glVertex3f(  0.0,  8.0, 25.0) 
    glEnd() 
    glDepthMask(GL_TRUE)                        # Z-buffer v rezimu read-write
    glDisable(GL_BLEND)                         # zakazani michani
</pre>

<a href="https://mojefedora.cz/wp-content/uploads/2017/04/07-3.png"><img class="alignnone size-thumbnail wp-image-8804" src="https://mojefedora.cz/wp-content/uploads/2017/04/07-3-243x254.png" alt="" width="243" height="254" /></a>
<p><i>Obrázek 7: Screenshot druhého demonstračního příkladu ve chvíli, kdy je povolena funkce paměti hloubky.</i></p>

<pre>
#!/usr/bin/env python

import pyglet
from pyglet.gl import *
from pyglet.window import key

fov = 70.0                                    # hodnota zorneho uhlu - field of view
nearPlane = 0.1                               # blizsi orezavaci rovina
farPlane = 90.0                               # vzdalenejsi orezavaci rovina

r1 = 0.0
r2 = 0.0

depthBufferEnabled = False                    # povoleni ci zakaz Z-bufferu

window = pyglet.window.Window(width=500,
                              height=500,
                              caption="Pyglet+OpenGL")


keys = key.KeyStateHandler()
window.push_handlers(keys)



def init():
    glClearColor(0.0, 0.0, 0.3, 0.0)          # barva pozadi obrazku
    glClearDepth(1.0)                         # implicitni hloubka ulozena v pameti hloubky
    glPolygonMode(GL_FRONT, GL_FILL)          # nastaveni rezimu vykresleni vyplnenych sten
    glPolygonMode(GL_BACK, GL_FILL)           # jak pro predni tak pro zadni steny
    glDisable(GL_CULL_FACE)                   # zadne hrany ani steny se nebudou odstranovat
    glDepthFunc(GL_LESS)                      # funkce pro testovani fragmentu
    glEnable(GL_BLEND)                        # povoleni blendingu
    glBlendFunc (GL_SRC_ALPHA, GL_ONE_MINUS_SRC_ALPHA)



@window.event
def on_resize(width, height):
    init()
    glViewport(0, 0, width, height)           # viditelna oblast pres cele okno



def draw_walls():
    glBegin(GL_QUADS)                         # vykresleni otevrene krychle - sten domecku
    glColor4f(0.0, 0.0, 1.0, 0.5)                  # modra barva steny
    glVertex3f(-5.0, -5.0, -5.0)
    glVertex3f(-5.0, -5.0,  5.0)
    glVertex3f( 5.0, -5.0,  5.0)
    glVertex3f( 5.0, -5.0, -5.0)

    glColor4f(0.0, 1.0, 0.0, 0.5)             # zelena barva steny
    glVertex3f(-5.0,  5.0, -5.0)
    glVertex3f(-5.0,  5.0,  5.0)
    glVertex3f( 5.0,  5.0,  5.0)
    glVertex3f( 5.0,  5.0, -5.0)

    glColor4f(1.0, 0.0, 0.0, 0.5)             # cervena barva steny
    glVertex3f(-5.0, -5.0, -5.0)
    glVertex3f(-5.0, -5.0,  5.0)
    glVertex3f(-5.0,  5.0,  5.0)
    glVertex3f(-5.0,  5.0, -5.0)

    glColor4f(1.0, 1.0, 0.0, 0.5)             # zluta barva steny
    glVertex3f( 5.0, -5.0, -5.0)
    glVertex3f( 5.0, -5.0,  5.0)
    glVertex3f( 5.0,  5.0,  5.0)
    glVertex3f( 5.0,  5.0, -5.0)
    glEnd()



def draw_roof():
    glBegin(GL_TRIANGLES)                      # vykresleni strechy domecku z trojuhelniku
    glColor4f(0.0, 1.0, 1.0, 0.5)
    glVertex3f(-5.0,  5.0, -5.0)
    glVertex3f( 5.0,  5.0, -5.0)
    glVertex3f( 0.0, 11.0,  0.0)
 
    glColor4f(1.0, 0.0, 1.0, 0.5)
    glVertex3f( 5.0,  5.0, -5.0)
    glVertex3f( 5.0,  5.0,  5.0)
    glVertex3f( 0.0, 11.0,  0.0)
 
    glColor4f(1.0, 1.0, 1.0, 0.5)
    glVertex3f( 5.0,  5.0,  5.0)
    glVertex3f(-5.0,  5.0,  5.0)
    glVertex3f( 0.0, 11.0,  0.0)
 
    glColor4f(0.0, 0.0, 0.0, 0.5)
    glVertex3f(-5.0,  5.0,  5.0)
    glVertex3f(-5.0,  5.0, -5.0)
    glVertex3f( 0.0, 11.0,  0.0)
    glEnd()



def draw_planes():
    glMatrixMode(GL_MODELVIEW)                  # bude se menit modelova matice
    glLoadIdentity()                            # nahrat jednotkovou matici
    glTranslatef(0.0, 0.0, -50.0)               # posun objektu dale od kamery
    glDepthMask(GL_FALSE)                       # Z-buffer v rezimu read-only
    glEnable(GL_BLEND)                          # povoleni michani
    glBlendFunc(GL_SRC_ALPHA, GL_ONE_MINUS_SRC_ALPHA) # michaci funkce
    glBegin(GL_QUADS)                           # vykresleni dvou rovin
    glColor4f(1.0, 0.5, 0.5, 0.7) 
    glVertex3f(-14.0, -8.0, 35.0) 
    glVertex3f( -0.0, -8.0, 35.0) 
    glVertex3f( -0.0,  8.0, 35.0) 
    glVertex3f(-14.0,  8.0, 35.0) 
    glColor4f(0.5, 0.5, 1.0, 0.7) 
    glVertex3f(  0.0, -8.0, 25.0) 
    glVertex3f( 14.0, -8.0, 25.0) 
    glVertex3f( 14.0,  8.0, 25.0) 
    glVertex3f(  0.0,  8.0, 25.0) 
    glEnd() 
    glDepthMask(GL_TRUE)                        # Z-buffer v rezimu read-write
    glDisable(GL_BLEND)                         # zakazani michani



def set_depth_buffer(depthBufferEnabled):
    if depthBufferEnabled:
        glEnable(GL_DEPTH_TEST)
    else:
        glDisable(GL_DEPTH_TEST)



def clear_buffers(depthBufferEnabled):
    if depthBufferEnabled:
        glClear(GL_COLOR_BUFFER_BIT | GL_DEPTH_BUFFER_BIT) # vymazani i Z/W bufferu
    else:
        glClear(GL_COLOR_BUFFER_BIT)          # vymazani vsech bitovych rovin barvoveho bufferu



@window.event
def on_draw():
    global r1, r2
    global depthBufferEnabled

    if keys[key.LEFT]:
        r2 = r2 - 1
    if keys[key.RIGHT]:
        r2 = r2 + 1
    if keys[key.UP]:
        r1 = r1 - 1
    if keys[key.DOWN]:
        r1 = r1 + 1
    if keys[key.E]:
        depthBufferEnabled = True
    if keys[key.D]:
        depthBufferEnabled = False

    clear_buffers(depthBufferEnabled)
    set_depth_buffer(depthBufferEnabled)

    glMatrixMode(GL_PROJECTION)               # zacatek modifikace projekcni matice
    glLoadIdentity()                          # vymazani projekcni matice (=identita)
    gluPerspective(fov, 1.0, nearPlane, farPlane);

    glMatrixMode(GL_MODELVIEW)
    glLoadIdentity()                          # nahrat jednotkovou matici

    gluLookAt(4.0, 6.0, 18.0,                 # bod, odkud se kamera diva
              0.0, 2.0,  0.0,                 # bod, kam se kamera diva
              0.0, 1.0,  0.0)                 # poloha "stropu" ve scene

    glRotatef(r1, 1.0, 0.0, 0.0)              # rotace objektu
    glRotatef(r2, 0.0, 1.0, 0.0) 

    draw_walls()
    draw_roof()
    draw_planes()



pyglet.app.run()
</pre>

<a href="https://mojefedora.cz/wp-content/uploads/2017/04/08-3.png"><img class="alignnone size-thumbnail wp-image-8805" src="https://mojefedora.cz/wp-content/uploads/2017/04/08-3-243x254.png" alt="" width="243" height="254" /></a>
<p><i>Obrázek 8: Screenshot druhého demonstračního příkladu ve chvíli, kdy je vypnuta funkce paměti hloubky.</i></p>

<a href="https://mojefedora.cz/wp-content/uploads/2017/04/09-3.png"><img class="alignnone size-thumbnail wp-image-8806" src="https://mojefedora.cz/wp-content/uploads/2017/04/09-3-243x254.png" alt="" width="243" height="254" /></a>
<p><i>Obrázek 9: Screenshot druhého demonstračního příkladu ve chvíli, kdy je opět zapnuta funkce paměti hloubky.</i></p>



<p><a name="k09"></a></p>
<h2 id="k09">9. Otestování více variant míchací funkce</h2>

<p>V&nbsp;předchozím demonstračním příkladu jsme si vyzkoušeli pouze jedinou míchací funkci nastavenou s&nbsp;využitím příkazu:</p>

<pre>
glBlendFunc(GL_SRC_ALPHA, GL_ONE_MINUS_SRC_ALPHA) # michaci funkce
</pre>

<p>Můžeme si ovšem vyzkoušet i další povolené kombinace. K&nbsp;tomuto účelu si vytvoříme pomocnou funkci, která nastaví míchací funkci a následně do framebufferu vykreslí čtverec žlutou barvou s&nbsp;nastavenou alfa složkou na 0,7. Tato pomocná funkce vypadá následovně:</p>

<pre>
def draw_square_with_blending(x, y, sfactor, dfactor):
    glBlendFunc(sfactor, dfactor)
    glColor4f(1.0, 1.0, 0.0, 0.7)
    glBegin(GL_QUADS)
    glVertex2f(x, y)
    glVertex2f(x+40, y)
    glVertex2f(x+40, y+40)
    glVertex2f(x, y+40)
    glEnd()
</pre>

<p>Pozadí scény bude tvořeno šedým čtvercem, při jehož vykreslení bude blending zakázaný:</p>

<pre>
def draw_background_plane():
    border = 10
    glDisable(GL_BLEND)                       # zakaz blendingu
    glColor3f(0.5, 0.5, 0.5)
    glBegin(GL_QUADS)
    glVertex2f(border, border)
    glVertex2f(window.width-border, border)
    glVertex2f(window.width-border, window.height-border)
    glVertex2f(border, window.height-border)
    glEnd()
</pre>

<p>Následně si připravíme dva seznamy obsahující konstanty představující typy zdrojových a cílových faktorů:</p>

<pre>
sfactors = [GL_SRC_ALPHA, GL_ONE_MINUS_SRC_ALPHA, GL_DST_COLOR, GL_ONE_MINUS_DST_COLOR, GL_ZERO, GL_ONE]
dfactors = [GL_SRC_ALPHA, GL_ONE_MINUS_SRC_ALPHA, GL_SRC_COLOR, GL_ONE_MINUS_SRC_COLOR, GL_ZERO, GL_ONE]
</pre>

<p>V&nbsp;posledním kroku ve dvojici vnořených programových smyček zkombinujeme všechny zdrojové faktory se všemi faktory cílovými a vykreslíme žlutý čtverec s&nbsp;povoleným blendingem:</p>

<pre>
for y in xrange(0, 6):
    sfactor = sfactors[y]
    for x in xrange(0, 6):
        dfactor = dfactors[x]
        draw_square_with_blending( 50+60*x, 50+60*y, sfactor, dfactor)
</pre>

<p>Výsledkem by měl být následující obrázek:</p>

<a href="https://mojefedora.cz/wp-content/uploads/2017/04/10-1.png"><img class="alignnone size-thumbnail wp-image-8807" src="https://mojefedora.cz/wp-content/uploads/2017/04/10-1-242x254.png" alt="" width="242" height="254" /></a>
<p><i>Obrázek 10: Screenshot třetího demonstračního příkladu.</i></p>



<p><a name="k10"></a></p>
<h2 id="k10">10. Třetí demonstrační příklad: více variant míchací funkce</h2>

<p>Úplný zdrojový kód třetího demonstračního příkladu, který po svém spuštění vykreslil obrázek z&nbsp;desátého screenshotu, vypadá následovně:</p>

<pre>
#!/usr/bin/env python

import pyglet
from pyglet.gl import *
from pyglet.window import key

window = pyglet.window.Window(width=450,
                              height=450,
                              caption="Pyglet+OpenGL")


def init():
    glClearColor(0.0, 0.0, 0.0, 0.0)          # barva pozadi obrazku
    glClearDepth(1.0)                         # implicitni hloubka ulozena v pameti hloubky
    glPolygonMode(GL_FRONT, GL_FILL)          # nastaveni rezimu vykresleni vyplnenych sten
    glPolygonMode(GL_BACK, GL_FILL)           # jak pro predni tak pro zadni steny
    glDisable(GL_CULL_FACE)                   # zadne hrany ani steny se nebudou odstranovat



@window.event
def on_resize(width, height):
    init()
    glViewport(0, 0, width, height)           # viditelna oblast pres cele okno



def clear_buffers():
    glClear(GL_COLOR_BUFFER_BIT)              # vymazani vsech bitovych rovin barvoveho bufferu



def set_projection():
    glMatrixMode(GL_MODELVIEW)
    glLoadIdentity()                          # nahrat jednotkovou matici



def draw_background_plane():
    border = 10
    glDisable(GL_BLEND)                       # zakaz blendingu
    glColor3f(0.5, 0.5, 0.5)
    glBegin(GL_QUADS)
    glVertex2f(border, border)
    glVertex2f(window.width-border, border)
    glVertex2f(window.width-border, window.height-border)
    glVertex2f(border, window.height-border)
    glEnd()



def draw_square_with_blending(x, y, sfactor, dfactor):
    glBlendFunc(sfactor, dfactor)
    glColor4f(1.0, 1.0, 0.0, 0.7)
    glBegin(GL_QUADS)
    glVertex2f(x, y)
    glVertex2f(x+40, y)
    glVertex2f(x+40, y+40)
    glVertex2f(x, y+40)
    glEnd()



@window.event
def on_draw():
    clear_buffers()
    set_projection()
    draw_background_plane()

    glEnable(GL_BLEND)
    sfactors = [GL_SRC_ALPHA, GL_ONE_MINUS_SRC_ALPHA, GL_DST_COLOR, GL_ONE_MINUS_DST_COLOR, GL_ZERO, GL_ONE]
    dfactors = [GL_SRC_ALPHA, GL_ONE_MINUS_SRC_ALPHA, GL_SRC_COLOR, GL_ONE_MINUS_SRC_COLOR, GL_ZERO, GL_ONE]

    for y in xrange(0, 6):
        sfactor = sfactors[y]
        for x in xrange(0, 6):
            dfactor = dfactors[x]
            draw_square_with_blending( 50+60*x, 50+60*y, sfactor, dfactor)



pyglet.app.run()
</pre>



<p><a name="k11"></a></p>
<h2 id="k11">11. Vliv alfa složky při aplikaci míchací funkce</h2>

<p>U některých kombinací zdrojových a cílových faktorů může být zajímavé sledovat, jaký vliv na vykreslení původně žlutého čtverce bude mít proměnlivá hodnota složky alfa, tedy čtvrté barvové složky. To můžeme otestovat, a dokonce velmi snadno. Postačuje nepatrně zmodifikovat demonstrační příklad takovým způsobem, aby se pomocí kurzorových kláves (šipka doleva, šipka doprava) a klávesy <strong>R</strong> (<i>reset</i>) mohla alfa složka měnit. Pro zajímavost nejsou nikde stanoveny žádné limity, takže alfa složka může být záporná nebo vyšší než 1,0. Realizace změny alfa složky je triviální:</p>

<pre>
alpha = 0.5
</pre>

<pre>
@window.event
def on_draw():
    global alpha
    if keys[key.LEFT]:
        alpha = alpha - 0.01
    if keys[key.RIGHT]:
        alpha = alpha + 0.01
    if keys[key.R]:
        alpha = 0.5
</pre>

<p>Vykreslovací rutina se taktéž změní, protože se jí předává další parametr &ndash; čtvrtá barvová složka:</p>

<pre>
def draw_square_with_blending(x, y, sfactor, dfactor, alpha):
    glBlendFunc(sfactor, dfactor)
    glColor4f(1.0, 1.0, 0.0, alpha)
    glBegin(GL_QUADS)
    glVertex2f(x, y)
    glVertex2f(x+40, y)
    glVertex2f(x+40, y+40)
    glVertex2f(x, y+40)
    glEnd()
</pre>

<a href="https://mojefedora.cz/wp-content/uploads/2017/04/11-1.png"><img class="alignnone size-thumbnail wp-image-8808" src="https://mojefedora.cz/wp-content/uploads/2017/04/11-1-242x254.png" alt="" width="242" height="254" /></a>
<p><i>Obrázek 11: Alfa složka žlutých čtverců je nastavena na hodnotu 0,01.</i></p>

<a href="https://mojefedora.cz/wp-content/uploads/2017/04/12-1.png"><img class="alignnone size-thumbnail wp-image-8809" src="https://mojefedora.cz/wp-content/uploads/2017/04/12-1-242x254.png" alt="" width="242" height="254" /></a>
<p><i>Obrázek 12: Alfa složka žlutých čtverců je nastavena na hodnotu 0,30.</i></p>

<a href="https://mojefedora.cz/wp-content/uploads/2017/04/13-1.png"><img class="alignnone size-thumbnail wp-image-8810" src="https://mojefedora.cz/wp-content/uploads/2017/04/13-1-242x254.png" alt="" width="242" height="254" /></a>
<p><i>Obrázek 13: Alfa složka žlutých čtverců je nastavena na hodnotu 0,70.</i></p>

<a href="https://mojefedora.cz/wp-content/uploads/2017/04/14-1.png"><img class="alignnone size-thumbnail wp-image-8811" src="https://mojefedora.cz/wp-content/uploads/2017/04/14-1-242x254.png" alt="" width="242" height="254" /></a>
<p><i>Obrázek 14: Alfa složka žlutých čtverců je nastavena na hodnotu 1,00.</i></p>



<p><a name="k12"></a></p>
<h2 id="k12">12. Čtvrtý demonstrační příklad: vliv alfa složky při aplikaci míchací funkce</h2>

<p>Úplný zdrojový kód čtvrtého a dnes i současně posledního demonstračního příkladu vypadá následovně:</p>

<pre>
#!/usr/bin/env python

import pyglet
from pyglet.gl import *
from pyglet.window import key

window = pyglet.window.Window(width=450,
                              height=450,
                              caption="Pyglet+OpenGL")


alpha = 0.5

keys = key.KeyStateHandler()
window.push_handlers(keys)



def init():
    glClearColor(0.0, 0.0, 0.0, 0.0)          # barva pozadi obrazku
    glClearDepth(1.0)                         # implicitni hloubka ulozena v pameti hloubky
    glPolygonMode(GL_FRONT, GL_FILL)          # nastaveni rezimu vykresleni vyplnenych sten
    glPolygonMode(GL_BACK, GL_FILL)           # jak pro predni tak pro zadni steny
    glDisable(GL_CULL_FACE)                   # zadne hrany ani steny se nebudou odstranovat



@window.event
def on_resize(width, height):
    init()
    glViewport(0, 0, width, height)           # viditelna oblast pres cele okno



def clear_buffers():
    glClear(GL_COLOR_BUFFER_BIT)              # vymazani vsech bitovych rovin barvoveho bufferu



def set_projection():
    glMatrixMode(GL_MODELVIEW)
    glLoadIdentity()                          # nahrat jednotkovou matici



def draw_background_plane():
    border = 10
    glDisable(GL_BLEND)                       # zakaz blendingu
    glColor3f(0.5, 0.5, 0.5)
    glBegin(GL_QUADS)
    glVertex2f(border, border)
    glVertex2f(window.width-border, border)
    glVertex2f(window.width-border, window.height-border)
    glVertex2f(border, window.height-border)
    glEnd()



def draw_square_with_blending(x, y, sfactor, dfactor, alpha):
    glBlendFunc(sfactor, dfactor)
    glColor4f(1.0, 1.0, 0.0, alpha)
    glBegin(GL_QUADS)
    glVertex2f(x, y)
    glVertex2f(x+40, y)
    glVertex2f(x+40, y+40)
    glVertex2f(x, y+40)
    glEnd()



@window.event
def on_draw():
    global alpha

    clear_buffers()
    set_projection()
    draw_background_plane()

    if keys[key.LEFT]:
        alpha = alpha - 0.01
    if keys[key.RIGHT]:
        alpha = alpha + 0.01
    if keys[key.R]:
        alpha = 0.5

    window.set_caption("Alpha = %3.2f" % alpha)
    glEnable(GL_BLEND)
    sfactors = [GL_SRC_ALPHA, GL_ONE_MINUS_SRC_ALPHA, GL_DST_COLOR, GL_ONE_MINUS_DST_COLOR, GL_ZERO, GL_ONE]
    dfactors = [GL_SRC_ALPHA, GL_ONE_MINUS_SRC_ALPHA, GL_SRC_COLOR, GL_ONE_MINUS_SRC_COLOR, GL_ZERO, GL_ONE]

    for y in xrange(0, 6):
        sfactor = sfactors[y]
        for x in xrange(0, 6):
            dfactor = dfactors[x]
            draw_square_with_blending( 50+60*x, 50+60*y, sfactor, dfactor, alpha)



pyglet.app.run()
</pre>



<p><a name="k13"></a></p>
<h2 id="k13">13. Repositář s&nbsp;demonstračními příklady</h2>

<p>Všechny čtyři dnes popsané demonstrační příklady byly uloženy do Git repositáře dostupného na adrese <a href="https://github.com/tisnik/presentations">https://github.com/tisnik/presentations</a>. Příklady si můžete v&nbsp;případě potřeby stáhnout i jednotlivě bez nutnosti klonovat celý repositář. Pro jejich spuštění je nutné mít nainstalovanou jak knihovnu Pyglet, tak i podpůrné grafické knihovny OpenGL a GLU (což se většinou provede automaticky v&nbsp;rámci instalace balíčku s&nbsp;Pygletem, viz též <a href="https://mojefedora.cz/multimedialni-knihovna-pyglet/">úvodní díl tohoto seriálu</a>):</p>

<table>
<tr><th>Příklad</th><th>Odkaz</th></tr>
<tr><td>23_blending.py</td><td><a href="https://github.com/tisnik/presentations/blob/master/pyglet/23_blending.py">https://github.com/tisnik/presentations/blob/master/pyglet/23_blending.py</a></td></tr>
<tr><td>24_blending2.py</td><td><a href="https://github.com/tisnik/presentations/blob/master/pyglet/24_blending2.py">https://github.com/tisnik/presentations/blob/master/pyglet/24_blending2.py</a></td></tr>
<tr><td>25_blending_function.py</td><td><a href="https://github.com/tisnik/presentations/blob/master/pyglet/25_blending_function.py">https://github.com/tisnik/presentations/blob/master/pyglet/25_blending_function.py</a></td></tr>
<tr><td>26_variable_alpha.py</td><td><a href="https://github.com/tisnik/presentations/blob/master/pyglet/26_variable_alpha.py">https://github.com/tisnik/presentations/blob/master/pyglet/26_variable_alpha.py</a></td></tr>
</table>



<p><a name="k14"></a></p>
<h2 id="k14">14. Odkazy na Internetu</h2>

<ol>

<li>Pyglet Home Page<br />
<a href="https://bitbucket.org/pyglet/pyglet/wiki/Home">https://bitbucket.org/pyglet/pyglet/wiki/Home</a>
</li>

<li>Dokumentace k verzi 1.2<br />
<a href="https://pyglet.readthedocs.io/en/pyglet-1.2-maintenance/">https://pyglet.readthedocs.io/en/pyglet-1.2-maintenance/</a>
</li>

<li>Dokumentace k verzi 1.2 ve formátu PDF<br />
<a href="https://readthedocs.org/projects/pyglet/downloads/pdf/pyglet-1.2-maintenance/">https://readthedocs.org/projects/pyglet/downloads/pdf/pyglet-1.2-maintenance/</a>
</li>

<li>PyOpenGL<br />
<a href="http://pyopengl.sourceforge.net/">http://pyopengl.sourceforge.net/</a>
</li>

<li>The #! magic, details about the shebang/hash-bang mechanism on various Unix flavours<br />
<a href="https://www.in-ulm.de/~mascheck/various/shebang/">https://www.in-ulm.de/~mascheck/various/shebang/</a>
</li>

<li>Shebang (Unix)<br />
<a href="https://en.wikipedia.org/wiki/Shebang_%28Unix%29">https://en.wikipedia.org/wiki/Shebang_%28Unix%29</a>
</li>

<li>Domovská stránka systému LÖVE<br />
<a href="http://love2d.org/">http://love2d.org/</a>
</li>

<li>Simple DirectMedia Layer (home page)<br />
<a href="http://www.libsdl.org/">http://www.libsdl.org/</a>
</li>

<li>Simple DirectMedia Layer (Wikipedia)<br />
<a href="https://en.wikipedia.org/wiki/Simple_DirectMedia_Layer">https://en.wikipedia.org/wiki/Simple_DirectMedia_Layer</a>
</li>

<li>Seriál Grafická knihovna OpenGL<br />
<a href="https://www.root.cz/serialy/graficka-knihovna-opengl/">https://www.root.cz/serialy/graficka-knihovna-opengl/</a>
</li>

<li>Pyglet event loop<br />
<a href="http://pyglet.readthedocs.io/en/latest/programming_guide/eventloop.html">http://pyglet.readthedocs.io/en/latest/programming_guide/eventloop.html</a>
</li>

<li>Decorators I: Introduction to Python Decorators<br />
<a href="http://www.artima.com/weblogs/viewpost.jsp?thread=240808">http://www.artima.com/weblogs/viewpost.jsp?thread=240808</a>
</li>

<li>3D Programming in Python - Part 1 <br />
<a href="https://greendalecs.wordpress.com/2012/04/21/3d-programming-in-python-part-1/">https://greendalecs.wordpress.com/2012/04/21/3d-programming-in-python-part-1/</a>
</li>

<li>A very basic Pyglet tutorial<br />
<a href="http://www.natan.termitnjak.net/tutorials/pyglet_basic.html">http://www.natan.termitnjak.net/tutorials/pyglet_basic.html</a>
</li>

<li>Alpha blending<br />
<a href="https://en.wikipedia.org/wiki/Alpha_compositing#Alpha_blending">https://en.wikipedia.org/wiki/Alpha_compositing#Alpha_blending</a>
</li>

</ol>



<p></p><p></p>
<p><small>Autor: <a href="http://www.fit.vutbr.cz/~tisnovpa">Pavel Tišnovský</a> &nbsp; 2017</small></p>
</body>
</html>

