<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
        "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html>
<head>
<title>Interpretry, pøekladaèe, JIT pøekladaèe a transpøekladaèe programovacího jazyka Lua</title>
<meta name="Author" content="Pavel Tisnovsky" />
<meta name="Generator" content="vim" />
<meta http-equiv="content-type" content="text/html; charset=iso-8859-2" />
<style type="text/css">
         body {color:#000000; background:#ffffff;}
         h1  {font-family: arial, helvetica, sans-serif; color:#ffffff; background-color:#c00000; text-align:center; padding-left:1em}
         h2  {font-family: arial, helvetica, sans-serif; color:#ffffff; background-color:#0000c0; padding-left:1em; text-align:left}
         h3  {font-family: arial, helvetica, sans-serif; color:#000000; background-color:#c0c0c0; padding-left:1em; text-align:left}
         h4  {font-family: arial, helvetica, sans-serif; color:#000000; background-color:#e0e0e0; padding-left:1em; text-align:left}
         a   {font-family: arial, helvetica, sans-serif;}
         li  {font-family: arial, helvetica, sans-serif; color:#000000; text-align:justify; width:450px;}
         ol  {font-family: arial, helvetica, sans-serif; color:#000000; text-align:justify; width:450px;}
         ul  {font-family: arial, helvetica, sans-serif; color:#000000; text-align:justify; width:450px;}
         p   {font-family: arial, helvetica, sans-serif; color:#000000; text-align:justify;}
         pre {background:#e0e0e0}
</style>
</head>

<body>

<h1>Interpretry, pøekladaèe, JIT pøekladaèe a transpøekladaèe programovacího jazyka Lua</h1>

<h3>Pavel Ti¹novský</h3>

<p></p>

<h1>Úvodník</h1>

<p>Programovací jazyk Lua je standardnì pøekládán do bajtkódu, který je následnì interpretován, podobnì jako je tomu u vìt¹iny dal¹ích skriptovacích jazykù. Ve skuteènosti v¹ak mají vývojáøi vyu¾ívající tento programovací jazyk k dispozici i dal¹í mo¾nosti, a» ji¾ se jedná o pøekladaèe, transpøekladaèe èi JIT pøekladaèe. Právì tìmito nástroji se dnes budeme zabývat.</p>



<h2>Obsah</h2>

<p><a href="#k01">1. Interpretry, pøekladaèe, JIT pøekladaèe a transpøekladaèe programovacího jazyka Lua</a></p>
<p><a href="#k02">2. Pøeklad programù do bajtkódu a následná interpretace tohoto bajtkódu</a></p>
<p><a href="#k03">3. Bajtkód programovacího jazyka Lua</a></p>
<p><a href="#k04">4. Pøímé volání pøekladaèe a výpis vygenerovaného bajtkódu</a></p>
<p><a href="#k05">5. LuaJIT &ndash; Just in Time pøekladaè pro jazyk Lua</a></p>
<p><a href="#k06">6. Mezikód a výsledný kód generovaný LuaJITem</a></p>
<p><a href="#k07">7. Transpøekladaè z&nbsp;jazyka Lua do JavaScriptu</a></p>
<p><a href="#k08">8. Virtuální stroj jazyka Lua transformovaný do JavaScriptu</a></p>
<p><a href="#k09">9. Transpøekladaè z&nbsp;jazyka Lua do C</a></p>
<p><a href="#k10">10. Pøíklad pou¾ití transpøekladaèe</a></p>
<p><a href="#k11">11. Výsledky benchmarku: interpret Lua vs. LuaJIT vs. transpøeklad do C</a></p>
<p><a href="#k12">12. Odkazy na Internetu</a></p>



<p><a name="k01"></a></p>
<h2 id="k01">1. Interpretry, pøekladaèe, JIT pøekladaèe a transpøekladaèe programovacího jazyka Lua</h2>

<p>Ve èlánku <i>Programovací jazyk Lua v roli skriptovacího jazyka pro WWW
stránky</i> <a
href="http://www.root.cz/clanky/programovaci-jazyk-lua-v-roli-skriptovaciho-jazyka-pro-www-stranky/">zveøejnìném
minulý týden</a> jsme se zabývali popisem dvou projektù, jejich¾ cílem bylo
umo¾nit spou¹tìní aplikací naprogramovaných v&nbsp;jazyce <i>Lua</i> ve webovém
prohlí¾eèi vybaveném pouze interpretrem <i>JavaScriptu</i>. Pøipomeòme si, ¾e
se jednalo o projekt nazvaný <i>lua2js</i>, v&nbsp;nìm¾ byla pou¾ita
technologie takzvaného transpøekladaèe/transcompileru (program musel být na
poèítaèi vývojáøe pøeveden do relativnì neèitelného JavaScriptu). Takté¾ byl
popsán konkurenèní projekt pojmenovaný <i>lua.vm.js</i>, v&nbsp;nìm¾ byl naopak
celý virtuální stroj jazyka Lua (Lua VM) pøeveden do JavaScriptu
s&nbsp;vyu¾itím technologie <i>Clang</i> a <i>Emscripten</i>, tak¾e ve výsledku
tento VM dokázal pøímo spou¹tìt skripty napsané v&nbsp;jazyku Lua bez nutnosti
jejich transformace èi pøekladu do jiného programovacího jazyka. To
s&nbsp;sebou pøiná¹í pøednosti, ale takté¾ zápory. Pøednosti jsou zøejmé
&ndash; programátor se vùbec nemusí zabývat JavaScriptem, mezi zápory pak patøí
zejména neexistence debuggeru pro jazyk Lua na stranì webového prohlí¾eèe (na
druhou stranu ladit JavaScript vzniklý transpøekladaèem takté¾ není ¾ádná velká
zábava :-).</p>

<p>V&nbsp;dne¹ním èlánku bude provedeno struèné pøedstavení nìkterých dal¹ích
mo¾ností, které mohou vývojáøi preferující programovací jazyk Lua vyu¾ít pro
spou¹tìní èi dokonce pro pøeklad svých aplikací. Nabízené mo¾nosti jsou pomìrnì
¹iroké, co¾ mo¾ná mù¾e vypadat ponìkud zvlá¹tnì (kdy¾ si navíc uvìdomíme, ¾e
pravdìpodobnì roz¹íøenìj¹í Java je dosti úzce svázaná se svým bajtkódem a JITem
atd.), ov¹em právì zde mù¾eme vidìt dùsledek toho, ¾e jak samotný programovací
jazyk Lua, tak i bajtkód tohoto jazyka jsou navr¾eny takovým zpùsobem, aby byly
implementaènì velmi jednoduché a pøitom dostateènì sémanticky bohaté, co¾
nìkteré vývojáøe inspiruje k&nbsp;provádìní rùzných experimentù s&nbsp;mnohdy
velmi zajímavými výsledky (pøíkladem mù¾e být projekt <a
href="http://www.root.cz/clanky/metalua-uzitecna-rozsireni-jazyka-lua/">Metalua</a>
èi <a
href="http://www.root.cz/clanky/luajit-just-in-time-prekladac-pro-programovaci-jazyk-lua/">LuaJIT</a>).
Ostatnì jazyk Lua v&nbsp;¾ádném pøípadì není v&nbsp;tomto ohledu osamoceným
projektem, proto¾e podobnì se experimentuje napøíklad s&nbsp;Pythonem.
Dùsledkem je, ¾e kromì pùvodního interpretru CPython existují dal¹í
interpretry, pøekladaèe èi transpøekladaèe, napøíklad Jython (Python pro JVM),
IronPython (Python pro .NET Framework a Mono), Pyjs/Pyjamas (Python pro
JavaScriptové interpretry), Shed Skin (tranpøekladaè do céèka) a samozøejmì
takté¾ populární PyPy.</p>



<p><a name="k02"></a></p>
<h2 id="k02">2. Pøeklad programù do bajtkódu a následná interpretace tohoto bajtkódu</h2>

<p>Skripty psané v&nbsp;programovacím jazyku Lua jsou standardnì zpracovávány
interpretrem dostupným na adrese <a
href="http://www.lua.org/ftp/">http://www.lua.org/ftp/</a>. Podobnì jako
v&nbsp;prakticky v¹ech klasických interpretrech (snad jen s&nbsp;výjimkou
rùzných typù shellù, napøíklad BASHe) je ve skuteènosti spou¹tìní skriptù
rozdìleno na dvì fáze. V&nbsp;první fázi je zdrojový kód rozdìlen na lexémy,
parsován a analyzován (popø.&nbsp;i optimalizován). Posléze se vygeneruje
mezikód a bajtkód (Lua, Python atd.). Výjimkou jsou interpretry klasických
BASICù, v&nbsp;nich¾ se namísto bajtkódu ukládá tokenizovaná forma pùvodního
zdrojového kódu, co¾ znamená, ¾e generování tokenù mù¾e být navázáno pøímo na
lexikální analyzátor (zde tro¹ku zjednodu¹uji). Vra»me se v¹ak k&nbsp;moderním
interpretrùm pracujícím s&nbsp;bajtkódem. Teprve bajtkód je skuteènì
interpretován, tj.&nbsp;postupnì jsou naèítány a provádìny jeho instrukce
s&nbsp;pøípadnou kontrolou chyb a u nìkterých typù interpretrù mù¾e být pou¾it
i JIT (nikoli v¹ak u standardního interpretru jazyka Lua, ten je pojatý
minimalisticky, ostatnì jeho velikost vèetnì základních knihoven nepøesahuje
200 kB). Pøekladaè do bajtkódu se jmenuje <strong>luac</strong>, samotný
interpret pak <strong>lua</strong>.</p>



<p><a name="k03"></a></p>
<h2 id="k03">3. Bajtkód programovacího jazyka Lua</h2>

<p>Bajtkód jazyka Lua je typický tím, ¾e se v&nbsp;nìm nepou¾ívá zásobník
operandù, proto¾e indexy operandù jsou pøímo souèástí instrukèního slova, co¾
sice vede k&nbsp;nutnosti pou¾ití vìt¹ího mno¾ství bitù pro zakódování celé
instrukce, ov¹em celkový poèet instrukcí se mnohdy pomìrnì radikálnì sní¾í a
navíc se i zvy¹uje efektivita interpretru. I formát instrukèních kódù je
napøíklad pøi porovnání s&nbsp;bajtkódem virtuálního stroje Javy (JVM) velmi
odli¹ný, proto¾e zatímco v&nbsp;pøípadì bajtkódu JVM je kód instrukce ulo¾en
v&nbsp;celém bajtu (s&nbsp;nìkolika málo výjimkami týkajícími se prefixu
<i>wide</i>), je u bajtkódu pou¾ívaném Lua VM kód instrukce ulo¾en
v&nbsp;pouhých ¹esti bitech, zatímco zbylých 26 bitù instrukèního slova je
rezervováno pro ulo¾ení indexù operandù èi konstant. Bajtkód Lua VM takté¾
obsahuje spí¹e vysokoúrovòové instrukce, které velmi dobøe reflektují
vlastnosti tohoto programovacího jazyka. Existují napøíklad instrukce pro
implementaci programové smyèky <strong>for</strong>, instrukce pro práci
s&nbsp;(asociativními) poli tvoøícími nejdùle¾itìj¹í strukturovaný datový typ
jazyka Lua a dokonce se v&nbsp;bajtkódu nachází instrukce pro vytvoøení uzávìru
(<i>closure</i>) a pro tail call. Sémantická mezera mezi jazykem Lua a jeho
bajtkódem je tedy pomìrnì malá.</p>

<p>Instrukce bajtkódu mohou mít jeden z&nbsp;následujících formátù:</p>

<h3>iABC</h3>

<table>
<tr><th>#</th><th>Oznaèení</th><th>Délka bitového pole</th><th>Význam</th></tr>
<tr><td>1</td><td>i</td><td>6</td><td>kód instrukce</td></tr>
<tr><td>2</td><td>A</td><td>8</td><td>index èi hodnota prvního operandu</td></tr>
<tr><td>3</td><td>B</td><td>9</td><td>index èi hodnota druhého operandu</td></tr>
<tr><td>4</td><td>C</td><td>9</td><td>index èi hodnota tøetího operandu</td></tr>
</table>

<h3>iABx</h3>

<table>
<tr><th>#</th><th>Oznaèení</th><th>Délka bitového pole</th><th>Význam</th></tr>
<tr><td>1</td><td>i</td><td>6</td><td>kód instrukce</td></tr>
<tr><td>2</td><td>A</td><td>8</td><td>index èi hodnota prvního operandu</td></tr>
<tr><td>3</td><td>Bx</td><td>18</td><td>index èi hodnota druhého operandu</td></tr>
</table>

<h3>iAsBx</h3>

<table>
<tr><th>#</th><th>Oznaèení</th><th>Délka bitového pole</th><th>Význam</th></tr>
<tr><td>1</td><td>i</td><td>6</td><td>kód instrukce</td></tr>
<tr><td>2</td><td>A</td><td>8</td><td>index èi hodnota prvního operandu</td></tr>
<tr><td>3</td><td>sBx</td><td>18</td><td>index èi hodnota druhého operandu (zde se znaménkem)</td></tr>
</table>

<h3>iAx</h3>

<table>
<tr><th>#</th><th>Oznaèení</th><th>Délka bitového pole</th><th>Význam</th></tr>
<tr><td>1</td><td>i</td><td>6</td><td>kód instrukce</td></tr>
<tr><td>2</td><td>Ax</td><td>26</td><td>index èi hodnota prvního (jediného) operandu</td></tr>
</table>

<p>Instrukce bajtkódu jsou struènì zmínìny v&nbsp;podkapitolách.</p>

<h3>Aritmetické instrukce</h3>

<table>
<tr><th>Operaèní kód</th><th>Instrukce</th><th>Význam</th></tr>
<tr><td>0x0d</td><td>ADD</td><td>aritmetická operace s&nbsp;trojicí registrù: souèet</td></tr>
<tr><td>0x0e</td><td>SUB</td><td>aritmetická operace s&nbsp;trojicí registrù: rozdíl</td></tr>
<tr><td>0x0f</td><td>MUL</td><td>aritmetická operace s&nbsp;trojicí registrù: souèin</td></tr>
<tr><td>0x10</td><td>DIV</td><td>aritmetická operace s&nbsp;trojicí registrù: podíl</td></tr>
<tr><td>0x11</td><td>MOD</td><td>aritmetická operace s&nbsp;trojicí registrù: podíl modulo</td></tr>
<tr><td>0x12</td><td>POW</td><td>aritmetická operace s&nbsp;trojicí registrù: umocnìní</td></tr>
<tr><td>0x13</td><td>UNM</td><td>zmìna znaménka</td></tr>
</table>

<h3>Logické operace</h3>

<table>
<tr><th>Operaèní kód</th><th>Instrukce</th><th>Význam</th></tr>
<tr><td>0x14</td><td>NOT            </td><td>negace</td></tr>
</table>

<h3>Pøesuny a konverze dat</h3>

<table>
<tr><th>Operaèní kód</th><th>Instrukce</th><th>Význam</th></tr>
<tr><td>0x00</td><td>MOVE           </td><td>pøesun dat ze zdrojového registru do cílového registru</td></tr>
</table>

<h3>Podmínìné a nepodmínìné skoky</h3>

<table>
<tr><th>Operaèní kód</th><th>Instrukce</th><th>Význam</th></tr>
<tr><td>0x17</td><td>JMP(A,sBx)     </td><td>nepodmínìný relativní skok v rámci jedné funkce</td></tr>
<tr><td>0x18</td><td>EQ(A,B,C)      </td><td>pøeskok dal¹í instrukce za podmínky ((RK[B] == RK[C]) ~= A)</td></tr>
<tr><td>0x19</td><td>LT(A,B,C)      </td><td>pøeskok dal¹í instrukce za podmínky ((RK[B] &lt; RK[C]) ~= A) </td></tr>
<tr><td>0x1a</td><td>LE(A,B,C)      </td><td>pøeskok dal¹í instrukce za podmínky ((RK[B] &lt;= RK[C]) ~= A)</td></tr>
<tr><td>0x1b</td><td>TEST(A,C)      </td><td>pøeskok dal¹í instrukce za podmínky not (R[A] &lt;=&gt; C)</td></tr>
<tr><td>0x1c</td><td>TESTSET(A,B,C) </td><td>podmínìný pøeskok dal¹í instrukce/pøiøazení</td></tr>
</table>

<h3>Práce s konstantami</h3>

<table>
<tr><th>Operaèní kód</th><th>Instrukce</th><th>Význam</th></tr>
<tr><td>0x01</td><td>LOADK(A,Bx)    </td><td>naètení konstanty</td></tr>
<tr><td>0x02</td><td>LOADKX(A)      </td><td>naètení konstanty (alternativní forma instrukce)</td></tr>
<tr><td>0x03</td><td>LOADBOOL(A,B,C)</td><td>naètení booleovské konstanty a podmínìný pøeskok dal¹í instrukce</td></tr>
<tr><td>0x04</td><td>LOADNIL(A,B)   </td><td>nastavení zvolené sekvence prvkù na nil</td></tr>
</table>

<h3>Práce s promìnnými</h3>

<table>
<tr><th>Operaèní kód</th><th>Instrukce</th><th>Význam</th></tr>
<tr><td>0x05</td><td>GETUPVAL(A,B)  </td><td>pøístup k vázaným promìnným (ètení promìnné)</td></tr>
<tr><td>0x06</td><td>GETTABUP(A,B,C)</td><td>pøístup k vázaným promìnným</td></tr>
<tr><td>0x07</td><td>GETTABLE(A,B,C)</td><td>pøístup k prvkùm tabulky (ètení)</td></tr>
<tr><td>0x08</td><td>SETTABUP(A,B,C)</td><td>pøístup k vázaným promìnným (zápis do promìnné)</td></tr>
<tr><td>0x09</td><td>SETUPVAL(A,B)  </td><td>pøístup k vázaným promìnným</td></tr>
<tr><td>0x0a</td><td>SETTABLE(A,B,C)</td><td>pøístup k prvkùm tabulky (zápis)</td></tr>
<tr><td>0x0b</td><td>NEWTABLE(A,B,C)</td><td>vytvoøení tabulky o zadané velikosti</td></tr>
<tr><td>0x0c</td><td>SELF(A,B,C)    </td><td>získání hodnoty self/this</td></tr>
</table>

<h3>Programové smyèky a volání funkcí</h3>

<table>
<tr><th>Operaèní kód</th><th>Instrukce</th><th>Význam</th></tr>
<tr><td>0x1d</td><td>CALL(A,B,C)    </td><td>volání funkce s&nbsp;pøedáním parametrù v registrech</td></tr>
<tr><td>0x1e</td><td>TAILCALL(A,B,C)</td><td>tail call</td></tr>
<tr><td>0x1f</td><td>RETURN(A,B)    </td><td>návrat z funkce s pøedáním návratových hodnot v registrech</td></tr>
<tr><td>0x20</td><td>FORLOOP(A,sBx) </td><td>dal¹í iterace poèítané programové smyèky pøi splnìní podmínky</td></tr>
<tr><td>0x21</td><td>FORPREP(A,sBx) </td><td>pøíprava poèítané programové smyèky for</td></tr>
<tr><td>0x22</td><td>TFORCALL(A,C)  </td><td>volání iterátoru, typicky ve smyèce typu for-each</td></tr>
<tr><td>0x23</td><td>TFORLOOP(A,sBx)</td><td>dal¹í iterace smyèky typu for-each pøi splnìní podmínky</td></tr>
</table>

<h3>Dal¹í instrukce</h3>

<table>
<tr><th>Operaèní kód</th><th>Instrukce</th><th>Význam</th></tr>
<tr><td>0x15</td><td>LEN(A,B)       </td><td>výpoèet délky/velikosti (tabulky...)</td></tr>
<tr><td>0x16</td><td>CONCAT         </td><td>konverze dat</td></tr>
<tr><td>0x24</td><td>SETLIST(A,B,C) </td><td>konverze dat</td></tr>
<tr><td>0x25</td><td>CLOSURE        </td><td>vytvoøení uzávìru</td></tr>
<tr><td>0x26</td><td>VARARG(A,B)    </td><td>naètení vararg do zvolené sady registrù</td></tr>
<tr><td>0x27</td><td>EXTRAARG(Ax)   </td><td>naètení konstanty, roz¹íøení instrukce LOADKX</td></tr>
</table>



<p><a name="k04"></a></p>
<h2 id="k04">4. Pøímé volání pøekladaèe a výpis vygenerovaného bajtkódu</h2>

<p>Podívejme se ve struènosti na pou¾ití standardního pøekladaèe jazyka Lua.
Mìjme jednoduchý zdrojový kód ulo¾ený v&nbsp;souboru
<strong>circles.lua</strong>:</p>

<pre>
local i,j,k
&nbsp;
print("P2")
print("400 400")
print("255")
&nbsp;
for i = 0, 399 do
    for j = 0, 399 do
        local k = i * i + j * j
        k = k % 0x100
        io.write(k)
        io.write(" ")
    end
end
</pre>

<img src="http://i.iinfo.cz/images/408/circles.png" class="image-215395" alt="&#160;" height="400" width="400" />
<p><i>Obrázek 1: Rastrový vzorek vygenerovaný demonstraèním pøíkladem.</i></p>

<p>Pro pøeklad bajtkódu (do operaèní pamìti) a jeho spu¹tìní èi interpretaci se
pou¾ívá pøíkaz:</p>

<pre>
lua circles.lua
</pre>

<p>Pro pøeklad do bajtkódu s&nbsp;jeho ulo¾ením na disk (ov¹em bez spu¹tìní
interpretru) se naproti tomu pou¾ije:</p>

<pre>
luac circles.lua
</pre>o

<p>Popø.&nbsp;se mù¾eme zbavit ladicích informací (a èásteènì tak znepøíjemnit
¾ivot lidem pokou¹ejícím se o reverse engineering v&nbsp;pøípadì, ¾e
z&nbsp;nìjakého dùvodu není mo¾né vyvíjet open source projekt):</p>

<pre>
luac -s circles.lua
</pre>o

<p>Výsledkem je soubor pojmenovaný <strong>luac.out</strong>, který má (i
s&nbsp;ladicími informacemi) velikost 762 bajtù, bez ladicích informací pak 330
bajtù. Výpis vygenerovaného bajtkódu, resp.&nbsp;pøesnìji øeèeno symbolických
jmen instrukcí i jejich parametrù, zajistí pøíkaz:</p>

<pre>
luac -l circles.lua
</pre>

<p>Výsledek mù¾e vypadat následovnì:</p>

<pre>
main &lt;circles.lua:0,0&gt; (33 instructions at 0x1b313c0)
0+ params, 14 slots, 1 upvalue, 12 locals, 11 constants, 0 functions
        1       [1]     <strong>LOADNIL</strong>         0 2
        2       [3]     <strong>GETTABUP</strong>        3 0 -1  ; <i>_ENV "print"</i>
        3       [3]     <strong>LOADK</strong>           4 -2    ; <i>"P2"</i>
        4       [3]     <strong>CALL</strong>            3 2 1
        5       [4]     <strong>GETTABUP</strong>        3 0 -1  ; <i>_ENV "print"</i>
        6       [4]     <strong>LOADK</strong>           4 -3    ; <i>"400 400"</i>
        7       [4]     <strong>CALL</strong>            3 2 1
        8       [5]     <strong>GETTABUP</strong>        3 0 -1  ; <i>_ENV "print"</i>
        9       [5]     <strong>LOADK</strong>           4 -4    ; <i>"255"</i>
        10      [5]     <strong>CALL</strong>            3 2 1
        11      [7]     <strong>LOADK</strong>           3 -5    ; <i>0</i>
        12      [7]     <strong>LOADK</strong>           4 -6    ; <i>399</i>
        13      [7]     <strong>LOADK</strong>           5 -7    ; <i>1</i>
        14      [7]     <strong>FORPREP</strong>         3 17    ; <i>to 32</i>
        15      [8]     <strong>LOADK</strong>           7 -5    ; <i>0</i>
        16      [8]     <strong>LOADK</strong>           8 -6    ; <i>399</i>
        17      [8]     <strong>LOADK</strong>           9 -7    ; <i>1</i>
        18      [8]     <strong>FORPREP</strong>         7 12    ; <i>to 31</i>
        19      [9]     <strong>MUL</strong>             11 6 6
        20      [9]     <strong>MUL</strong>             12 10 10
        21      [9]     <strong>ADD</strong>             11 11 12
        22      [10]    <strong>MOD</strong>             11 11 -8
        23      [11]    <strong>GETTABUP</strong>        12 0 -9 ; <i>_ENV "io"</i>
        24      [11]    <strong>GETTABLE</strong>        12 12 -10       ; <i>"write"</i>
        25      [11]    <strong>MOVE</strong>            13 11
        26      [11]    <strong>CALL</strong>            12 2 1
        27      [12]    <strong>GETTABUP</strong>        12 0 -9 ; <i>_ENV "io"</i>
        28      [12]    <strong>GETTABLE</strong>        12 12 -10       ; <i>"write"</i>
        29      [12]    <strong>LOADK</strong>           13 -11  ; <i>" "</i>
        30      [12]    <strong>CALL</strong>            12 2 1
        31      [8]     <strong>FORLOOP</strong>         7 -13   ; <i>to 19</i>
        32      [7]     <strong>FORLOOP</strong>         3 -18   ; <i>to 15</i>
        33      [14]    <strong>RETURN</strong>          0 1
</pre>



<p><a name="k05"></a></p>
<h2 id="k05">5. LuaJIT &ndash; Just in Time pøekladaè pro jazyk Lua</h2>

<p>Z&nbsp;technologického hlediska je velmi zajímavým a souèasnì i u¾iteèným
projektem nástroj nazvaný <i>LuaJIT</i> neboli Just in Time pøekladaè pro Luu.
LuaJIT je internì relativnì jednoduchý, zejména v&nbsp;porovnání
s&nbsp;monstrózním JVM JITem, a navíc pou¾ívá snadno pochopitelný <a
href="http://cs.wikipedia.org/wiki/Mezijazyk">mezijazyk</a> (anglicky <i>IR
&ndash; Intermediate Representation</i>), který je následnì
&bdquo;JITován&ldquo;. Tento IR je odli¹ný od bajtkódu jazyka Lua, s&nbsp;ním¾
jsme se velmi struènì seznámili v&nbsp;pøedchozích kapitolách. Zatímco pùvodní
bajtkód jazyka Lua byl orientován pøedev¹ím s&nbsp;ohledem na mo¾nosti
interpretru, je IR v&nbsp;LuaJITu navr¾en takovým zpùsobem, aby byl jeho
následný pøeklad do nativního kódu pomìrnì snadný a rychlý, a to navíc bez
ohledu na architekturu pou¾itého mikroprocesoru. <i>LuaJIT</i> je z&nbsp;velké
èásti dílem jediného programátora, který se jmenuje <i>Mike Pall</i>, který se
zabýval i vývojem dal¹ích nástrojù a knihoven pou¾itelných vývojáøi
v&nbsp;jazyku Lua. Rychlost JITovaného skriptu bude porovnána se standardním
interpretrem jazyka Lua a s&nbsp;pøelo¾eným kódem <a
href="#k11">v&nbsp;jedenácté kapitole</a>.</p>

<p>Celý projekt <i>LuaJIT</i> se skládá z&nbsp;nìkolika modulù, které pøi
spu¹tìní aplikace vytvoøené v&nbsp;programovacím jazyku Lua musí vzájemnì
spolupracovat. Prvním modulem je pøekladaè slou¾ící pro kompilaci zdrojového
kódu napsaného v&nbsp;Lue do mezijazyka, který budeme v&nbsp;dal¹ím textu
zkrácenì oznaèovat <strong>IR</strong> &ndash; <i>Intermediate
Representation</i>. IR je navr¾en takovým zpùsobem, aby mohl být buï
interpretován (jde o ty èásti kódu, které nejsou spou¹tìny pøíli¹ èasto) nebo
pøekládán do nativního strojového kódu s&nbsp;vyu¾itím JITu (vìt¹inou se jedná
o opìtovnì spou¹tìné èásti kódu). IR pou¾ívá takzvaný tøíadresový kód a
instrukce o pevné ¹íøce tøiceti dvou bitù. Pøístup k&nbsp;instrukcím je tedy
obecnì mnohem rychlej¹í, ne¾ pøi pou¾ití instrukcí promìnné délky, tak jako je
tomu v&nbsp;JVM.</p>



<p><a name="k06"></a></p>
<h2 id="k06">6. Mezikód a výsledný kód generovaný LuaJITem</h2>

<p>Existují dva formáty instrukcí, pøesnìji øeèeno dva zpùsoby rozdìlení
32bitového slova na jednotlivá bitová pole. V&nbsp;obou formátech má operaèní
kód instrukce ¹íøku osmi bitù, obsazení dal¹ích 24 bitù je v¹ak odli¹né.</p>

<p>První formát se pou¾ívá u instrukcí s&nbsp;trojicí operandù. Typické pou¾ití
tohoto formátu je u aritmetických instrukcí:</p>

<table>
<tr><th>Oznaèení</th><th>©íøka (bitù)</th><th>Popis</th></tr>
<tr><td>B</td><td>8</td><td>první vstupní operand (zdrojová promìnná)</td></tr>
<tr><td>C</td><td>8</td><td>druhý vstupní operand (zdrojová promìnná, numerická konstanta atd.)</td></tr>
<tr><td>A</td><td>8</td><td>výsledek operace (promìnná pro ulo¾ení výsledku)</td></tr>
<tr><td>OP</td><td>8</td><td>operaèní kód instrukce</td></tr>
<tr><td>Celkem</td><td>32</td><td>&nbsp;</td></tr>
</table>

<p>Druhý formát doká¾e adresovat pouze dva operandy, ov¹em operand oznaèený
písmenem <strong>D</strong> má ¹íøku ¹estnáct bitù a lze ho v&nbsp;nìkterých
instrukcích pou¾ít napøíklad k&nbsp;pøímému ulo¾ení ¹estnáctibitové celoèíselné
konstanty se znaménkem (srov.&nbsp;s&nbsp;pomìrnì velkým mno¾stvím instrukcí
v&nbsp;bajtkódu JVM, které se pokou¹í o toté¾, ale mnohem komplikovanìj¹ím
zpùsobem):</p>

<table>
<tr><th>Oznaèení</th><th>©íøka (bitù)</th><th>Popis</th></tr>
<tr><td>D</td><td>16</td><td>vstupní operand (zdrojová promìnná)</td></tr>
<tr><td>A</td><td>8</td><td>první operand nebo promìnná pro ulo¾ení výsledku</td></tr>
<tr><td>OP</td><td>8</td><td>operaèní kód instrukce</td></tr>
<tr><td>Celkem</td><td>32</td><td>&nbsp;</td></tr>
</table>

<p>Pro ji¾ ukázaný demonstraèní pøíklad:</p>

<pre>
local i,j,k
&nbsp;
print("P2")
print("400 400")
print("255")
&nbsp;
for i = 0, 399 do
    for j = 0, 399 do
        local k = i * i + j * j
        k = k % 0x100
        io.write(k)
        io.write(" ")
    end
end
</pre>

<p>Vypadá mezikód pou¾ívaný LuaJITem následovnì:</p>

<pre>
-- BYTECODE -- circles.lua:0-16
0001    <strong>KNIL</strong>     0   2
0002    <strong>GGET</strong>     3   0      ; <i>"print"</i>
0003    <strong>KSTR</strong>     4   1      ; <i>"P2"</i>
0004    <strong>CALL</strong>     3   1   2
0005    <strong>GGET</strong>     3   0      ; <i>"print"</i>
0006    <strong>KSTR</strong>     4   2      ; <i>"400 400"</i>
0007    <strong>CALL</strong>     3   1   2
0008    <strong>GGET</strong>     3   0      ; <i>"print"</i>
0009    <strong>KSTR</strong>     4   3      ; <i>"255"</i>
0010    <strong>CALL</strong>     3   1   2
0011    <strong>KSHORT</strong>   3   0
0012    <strong>KSHORT</strong>   4 399
0013    <strong>KSHORT</strong>   5   1
0014    <strong>FORI</strong>     3 =&gt; <i>0033</i>
0015 =&gt; <strong>KSHORT</strong>   7   0
0016    <strong>KSHORT</strong>   8 399
0017    <strong>KSHORT</strong>   9   1
0018    <strong>FORI</strong>     7 =&gt; <i>0032</i>
0019 =&gt; <strong>MULVV</strong>   11   6   6
0020    <strong>MULVV</strong>   12  10  10
0021    <strong>ADDVV</strong>   11  11  12
0022    <strong>MODVN</strong>   11  11   0  ; <i>256</i>
0023    <strong>GGET</strong>    12   4      ; <i>"io"</i>
0024    <strong>TGETS</strong>   12  12   5  ; <i>"write"</i>
0025    <strong>MOV</strong>     13  11
0026    <strong>CALL</strong>    12   1   2
0027    <strong>GGET</strong>    12   4      ; <i>"io"</i>
0028    <strong>TGETS</strong>   12  12   5  ; <i>"write"</i>
0029    <strong>KSTR</strong>    13   6      ; <i>" "</i>
0030    <strong>CALL</strong>    12   1   2
0031    <strong>FORL</strong>     7 =&gt; 0019
0032 =&gt; <strong>FORL</strong>     3 =&gt; 0015
0033 =&gt; <strong>RET0</strong>     0   1
</pre>



<p><a name="k07"></a></p>
<h2 id="k07">7. Transpøekladaè z&nbsp;jazyka Lua do JavaScriptu</h2>

<p>Alternativou ke <a href="#k02">klasickému interpretru</a> i <a
href="#k05">k&nbsp;LuaJITu</a> mù¾e pro nìkteré vývojáøe být projekt nazvaný
<i>lua2js</i>, o nìm¾ jsme se ji¾ zmiòovali v&nbsp;pøedchozím èlánku.
Pøipomeòme si tedy, ¾e se jedná o transpøekladaè (<i>transcompiler</i>)
slou¾ící pro pøeklad zdrojových kódù napsaných v&nbsp;programovacím jazyce Lua
do JavaScriptu. Samotný transpøekladaè <i>lua2js</i> je naprogramován takté¾
v&nbsp;JavaScriptu. Pøeklad jazykových konstrukcí není ve vìt¹inì pøípadù
problematický, ov¹em je nutné mít na pamìti, ¾e pøi spu¹tìní skriptu ve webovém
prohlí¾eèi nebudou korektnì fungovat mnohé funkce základních knihoven, co¾ se
týká pøedev¹ím modulu/knihovny <strong>io</strong> [<a
href="http://lua-users.org/wiki/IoLibraryTutorial">http://lua-users.org/wiki/IoLibraryTutorial</a>]
a takté¾ modulu <strong>os</strong> [<a
href="http://lua-users.org/wiki/OsLibraryTutorial">http://lua-users.org/wiki/OsLibraryTutorial</a>],
co¾ je v¹ak vzhledem k&nbsp;velkým rozdílùm mezi bì¾ným skriptem a aplikací
bì¾ící v&nbsp;prohlí¾eèi pochopitelné.</p>



<p><a name="k08"></a></p>
<h2 id="k08">8. Virtuální stroj jazyka Lua transformovaný do JavaScriptu</h2>

<p>I o dal¹ím projektu jsme se zmiòovali minule; jedná se o projekt pojmenovaný
<i>lua.vm.js</i>. Tento projekt je zalo¾en na technologii <i>Emscriptenu</i>,
proto¾e <i>lua.vm.js</i> není nic jiného ne¾ virtuální stroj jazyka Lua
implementovaný v&nbsp;JavaScriptu. Autoøi <i>lua.vm.js</i> se v¹ak nesna¾ili o
znovuobjevení kola a o implementaci vlastního virtuálního stroje, ale pou¾ili
infrastrukturu <i>Clang+LLVM+Emscripten</i> pro pøeklad pùvodního virtuálního
stroje (ten je naprogramován v&nbsp;ANSI C) do JavaScriptu. Co to znamená
v&nbsp;praxi? Bìh skriptù je pøibli¾nì o polovinu pomalej¹í, ne¾ v&nbsp;pøípadì
pou¾ití nativního Lua VM (a je¹tì pomalej¹í v&nbsp;porovnání s&nbsp;<a
href="http://www.root.cz/clanky/luajit-just-in-time-prekladac-pro-programovaci-jazyk-lua/">LuaJITem</a>),
ov¹em programátoøi získávají stoprocentní kompatibilitu s&nbsp;pùvodní
implementací programovacího jazyka Lua. Navíc je tento projekt vytvoøen takovým
zpùsobem, ¾e se do WWW stránek pøímo vkládají skripty psané v&nbsp;Lue.
Virtuální stroj si pomocí DOM pøíslu¹né skripty naète a následnì je vykoná
(s&nbsp;pøevodem do bajtkódu atd., viz té¾ <a href="#k02">pøedchozí
kapitoly</a>).</p>



<p><a name="k09"></a></p>
<h2 id="k09">9. Transpøekladaè z&nbsp;jazyka Lua do C</h2>

<p>Mnozí ètenáøi si pravdìpodobnì polo¾ili otázku, proè pou¾ívat Just in Time
pøekladaè (tedy konkrétnì LuaJIT) a nikoli plnohodnotný pøeklad programù
napsaných v&nbsp;jazyku Lua do nativního kódu. Ukazuje se, ¾e to není tak
jednoduché, a to zejména z&nbsp;toho dùvodu, ¾e Lua je dynamicky typovaný
jazyk, navíc navr¾ený takovým zpùsobem, ¾e se s&nbsp;vyu¾itím takzvaných
metatabulek mohou pro u¾ivatelské datové typy mìnit významy operátorù. Co to
znamená v&nbsp;praxi? Napøíklad pøíkaz <strong>local x = a + b</strong> nemù¾e
být obecnì pøeveden na nativní instrukci <strong>add</strong> èi
<strong>fadd</strong>, proto¾e ze zapsaného pøíkazu není patrné, zda je
skuteènì za v¹ech okolností operátor + pou¾itý v&nbsp;pøíkazu aplikován na
celoèíselné èi reálné operandy. Podobných &ndash; z&nbsp;hlediska pøekladu
problematických &ndash; vlastností je v&nbsp;jazyku Lua povícero. Èásteèné
øe¹ení pøedstavuje právì ji¾ vý¹e zmínìný LuaJIT, který si sám hlídá provádìné
operace a doká¾e v&nbsp;pøípadì potøeby jeden blok pøelo¾it víckrát èi se
vrátit k&nbsp;&bdquo;pouhé&ldquo; interpretaci. Druhé èásteèné øe¹ení je
implementováno v&nbsp;projektu <strong>lua2c</strong> dostupného na adrese <a
href="http://lua-users.org/wiki/OsLibraryTutorial">http://lua-users.org/wiki/OsLibraryTutorial</a>.</p>

<p>V&nbsp;rámci tohoto projektu je implementován prozatím znaènì naivní
transpøekladaè z&nbsp;jazyka Lua do céèka. Podívejme se, jakým zpùsobem se
(trans)pøelo¾í trojice pøíkazù:</p>

<pre>
local a = 10
local b = 20
local x = a + b
</pre>

<p><strong>lua2c</strong> vygeneruje céèkový zdrojový soubor dlouhý necelých
pìt kilobajtù(!), pøièem¾ vý¹e uvedené pøíkazy jsou pøelo¾eny následujícím
zpùsobem:</p>

<pre>
static int lcf_main (lua_State * L) {
  enum { lc_nformalargs = 0 };
  const int lc_nactualargs = lua_gettop(L);
  const int lc_nextra = (lc_nactualargs - lc_nformalargs);
&nbsp;
  /* local a = 10 */
  lua_pushnumber(L,10);
  assert(lua_gettop(L) - lc_nextra == 1);
&nbsp;
  /* local b = 20 */
  lua_pushnumber(L,20);
  assert(lua_gettop(L) - lc_nextra == 2);
&nbsp;
  /* local x = a + b */
  lc_add(L,(1 + lc_nextra),(2 + lc_nextra));
  assert(lua_gettop(L) - lc_nextra == 3);
  return 0;
</pre>

<p>Vidíme, ¾e zdánlivì primitivní operace souètu je zde realizována voláním
funkce <strong>lc_add</strong>. Ta takté¾ není triviální:</p>

<pre>
static void lc_add(lua_State * L, int idxa, int idxb) {
  if (lua_isnumber(L,idxa) &amp;&amp; lua_isnumber(L,idxb)) {
    lua_pushnumber(L,lua_tonumber(L,idxa) + lua_tonumber(L,idxb));
  }
  else {
    if (luaL_getmetafield(L,idxa,"__add")||luaL_getmetafield(L,idxb,"__add")) {
      lua_pushvalue(L,idxa &lt; 0 &amp;&amp; idxa &gt; LUA_REGISTRYINDEX ? idxa-1 : idxa);
      lua_pushvalue(L,idxb &lt; 0 &amp;&amp; idxb &gt; LUA_REGISTRYINDEX ? idxb-2 : idxb);
      lua_call(L,2,1);
    }
    else {
      luaL_error(L, "attempt to perform arithmetic");
    }
  }
}
</pre>

<p>Transpøekladaè se tak vlastnì sna¾í napodobit funkci klasického interpretru
jazyka Lua, který pøi interpretaci u¾ivatelských skriptù musí provádìt podobné
operace. Zajisté není zapotøebí zdùrazòovat, ¾e výsledek nebude ideální, a to
ani z&nbsp;hlediska spotøeby pamìti, tak i z&nbsp;hlediska výpoèetního výkonu
(viz té¾ <a href="#k11">jedenáctou kapitolu</a>, kde uvidíme, jak ¹patnì na tom
ve skuteènosti výsledek transpøekladu je :-).</p>



<p><a name="k10"></a></p>
<h2 id="k10">10. Pøíklad pou¾ití transpøekladaèe</h2>

<p>Naposledy se podívejme na jednoduchý testovací pøíklad naprogramovaný
v&nbsp;jazyku Lua:</p>

<pre>
local i,j,k
&nbsp;
print("P2")
print("400 400")
print("255")
&nbsp;
for i = 0, 399 do
    for j = 0, 399 do
        local k = i * i + j * j
        k = k % 0x100
        io.write(k)
        io.write(" ")
    end
end
</pre>

<p>Tento pøíklad s&nbsp;vyu¾itím transpøekladaèe pøevedeme do zdrojového kódu
v&nbsp;céèku:</p>

<pre>
LUA_PATH=$CWD/lib/?.lua lua lua2c circles.lua &gt; circles.c
</pre>

<p>Pro zajímavost se podívejme, jak vygenerovaný kód vypadá:</p>

<pre>
/* WARNING: This file was automatically generated by lua2c. */
&nbsp;
#ifdef __cplusplus
extern "C" {
#endif
#include &lt;lua.h&gt;
#include &lt;lauxlib.h&gt;
#include &lt;lualib.h&gt;
#ifdef __cplusplus
}
#endif
#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;
&nbsp;
&nbsp;
#include &lt;string.h&gt;
&nbsp;
&nbsp;
#include &lt;assert.h&gt;
&nbsp;
/* __add metamethod handler.
 * warning: assumes indices in range LUA_REGISTRYINDEX &lt; x &lt; 0 are relative. */
static void lc_add(lua_State * L, int idxa, int idxb) {
  if (lua_isnumber(L,idxa) &amp;&amp; lua_isnumber(L,idxb)) {
    lua_pushnumber(L,lua_tonumber(L,idxa) + lua_tonumber(L,idxb));
  }
  else {
    if (luaL_getmetafield(L,idxa,"__add")||luaL_getmetafield(L,idxb,"__add")) {
      lua_pushvalue(L,idxa &lt; 0 &amp;&amp; idxa &gt; LUA_REGISTRYINDEX ? idxa-1 : idxa);
      lua_pushvalue(L,idxb &lt; 0 &amp;&amp; idxb &gt; LUA_REGISTRYINDEX ? idxb-2 : idxb);
      lua_call(L,2,1);
    }
    else {
      luaL_error(L, "attempt to perform arithmetic");
    }
  }
}
&nbsp;
&nbsp;
/* __mul metamethod handler.
 * warning: assumes indices in range LUA_REGISTRYINDEX &lt; x &lt; 0 are relative. */
static void lc_mul(lua_State * L, int idxa, int idxb) {
  if (lua_isnumber(L,idxa) &amp;&amp; lua_isnumber(L,idxb)) {
    lua_pushnumber(L,lua_tonumber(L,idxa) * lua_tonumber(L,idxb));
  }
  else {
    if (luaL_getmetafield(L,idxa,"__mul")||luaL_getmetafield(L,idxb,"__mul")) {
      lua_pushvalue(L,idxa &lt; 0 &amp;&amp; idxa &gt; LUA_REGISTRYINDEX ? idxa-1 : idxa);
      lua_pushvalue(L,idxb &lt; 0 &amp;&amp; idxb &gt; LUA_REGISTRYINDEX ? idxb-2 : idxb);
      lua_call(L,2,1);
    }
    else {
      luaL_error(L, "attempt to perform arithmetic");
    }
  }
}
&nbsp;
&nbsp;
#include &lt;math.h&gt;
&nbsp;
/* __mod metamethod handler.
 * warning: assumes indices in range LUA_REGISTRYINDEX &lt; x &lt; 0 are relative. */
static void lc_mod(lua_State * L, int idxa, int idxb) {
  if (lua_isnumber(L,idxa) &amp;&amp; lua_isnumber(L,idxb)) {
    lua_pushnumber(L,lua_tonumber(L,idxa) - floor(lua_tonumber(L,idxa)/lua_tonumber(L,idxb))*lua_tonumber(L,idxb));
  }
  else {
    if (luaL_getmetafield(L,idxa,"__mod")||luaL_getmetafield(L,idxb,"__mod")) {
      lua_pushvalue(L,idxa &lt; 0 &amp;&amp; idxa &gt; LUA_REGISTRYINDEX ? idxa-1 : idxa);
      lua_pushvalue(L,idxb &lt; 0 &amp;&amp; idxb &gt; LUA_REGISTRYINDEX ? idxb-2 : idxb);
      lua_call(L,2,1);
    }
    else {
      luaL_error(L, "attempt to perform arithmetic");
    }
  }
}
&nbsp;
&nbsp;
/* name: (main)
 * function(...) */
static int lcf_main (lua_State * L) {
  enum { lc_nformalargs = 0 };
  const int lc_nactualargs = lua_gettop(L);
  const int lc_nextra = (lc_nactualargs - lc_nformalargs);
&nbsp;
  /* local i,j,k */
  lua_settop(L,(lua_gettop(L) + 3));
  assert(lua_gettop(L) - lc_nextra == 3);
&nbsp;
  /* print("P2") */
  lua_getfield(L,LUA_ENVIRONINDEX,"print");
  lua_pushliteral(L,"P2");
  lua_call(L,1,0);
  assert(lua_gettop(L) - lc_nextra == 3);
&nbsp;
  /* print("400 400") */
  lua_getfield(L,LUA_ENVIRONINDEX,"print");
  lua_pushliteral(L,"400 400");
  lua_call(L,1,0);
  assert(lua_gettop(L) - lc_nextra == 3);
&nbsp;
  /* print("255") */
  lua_getfield(L,LUA_ENVIRONINDEX,"print");
  lua_pushliteral(L,"255");
  lua_call(L,1,0);
  assert(lua_gettop(L) - lc_nextra == 3);
&nbsp;
  /* for i = 0, 399 do */
  lua_pushnumber(L,0);
  lua_pushnumber(L,399);
  if (!((lua_isnumber(L,-2) &amp;&amp; lua_isnumber(L,-1)))) {
    luaL_error(L,"'for' limit must be a number");
  }
  double lc1_var = lua_tonumber(L,-2);
  const double lc2_limit = lua_tonumber(L,-1);
  const double lc3_step = 1;
  lua_pop(L,2);
  enum { lc4 = 3 };
  while ((((lc3_step &gt; 0) &amp;&amp; (lc1_var &lt;= lc2_limit)) || ((lc3_step &lt;= 0) &amp;&amp; (lc1_var &gt;= lc2_limit)))) {
&nbsp;    
    /* internal: local i at index 4 */
    lua_pushnumber(L,lc1_var);
 &nbsp;       
    /* for j = 0, 399 do */
    lua_pushnumber(L,0);
    lua_pushnumber(L,399);
    if (!((lua_isnumber(L,-2) &amp;&amp; lua_isnumber(L,-1)))) {
      luaL_error(L,"'for' limit must be a number");
    }
    double lc5_var = lua_tonumber(L,-2);
    const double lc6_limit = lua_tonumber(L,-1);
    const double lc7_step = 1;
    lua_pop(L,2);
    enum { lc8 = 4 };
    while ((((lc7_step &gt; 0) &amp;&amp; (lc5_var &lt;= lc6_limit)) || ((lc7_step &lt;= 0) &amp;&amp; (lc5_var &gt;= lc6_limit)))) {
 &nbsp;         
      /* internal: local j at index 5 */
      lua_pushnumber(L,lc5_var);
 &nbsp;         
      /* local k = i * i + j * j */
      lc_mul(L,(4 + lc_nextra),(4 + lc_nextra));
      lc_mul(L,(5 + lc_nextra),(5 + lc_nextra));
      lc_add(L,-2,-1);
      lua_remove(L,-2);
      lua_remove(L,-2);
      assert(lua_gettop(L) - lc_nextra == 6);
 &nbsp;         
      /* k = k % 0x100 */
      lua_pushnumber(L,256);
      lc_mod(L,(6 + lc_nextra),-1);
      lua_remove(L,-2);
      lua_replace(L,(6 + lc_nextra));
      assert(lua_gettop(L) - lc_nextra == 6);
 &nbsp;         
      /* io.write(k) */
      lua_getfield(L,LUA_ENVIRONINDEX,"io");
      lua_pushliteral(L,"write");
      lua_gettable(L,-2);
      lua_remove(L,-2);
      lua_pushvalue(L,(6 + lc_nextra));
      lua_call(L,1,0);
      assert(lua_gettop(L) - lc_nextra == 6);
 &nbsp;         
      /* io.write(" ") */
      lua_getfield(L,LUA_ENVIRONINDEX,"io");
      lua_pushliteral(L,"write");
      lua_gettable(L,-2);
      lua_remove(L,-2);
      lua_pushliteral(L," ");
      lua_call(L,1,0);
      assert(lua_gettop(L) - lc_nextra == 6);
 &nbsp;         
      /* internal: stack cleanup on scope exit */
      lua_pop(L,2);
      lc5_var += lc7_step;
    }
    lua_settop(L,(lc8 + lc_nextra));
    assert(lua_gettop(L) - lc_nextra == 4);
 &nbsp;       
    /* internal: stack cleanup on scope exit */
    lua_pop(L,1);
    lc1_var += lc3_step;
  }
  lua_settop(L,(lc4 + lc_nextra));
  assert(lua_gettop(L) - lc_nextra == 3);
  return 0;
}
&nbsp;
&nbsp;
/* from lua.c */
static int traceback (lua_State *L) {
  if (!lua_isstring(L, 1))  /* 'message' not a string? */
    return 1;  /* keep it intact */
  lua_getfield(L, LUA_GLOBALSINDEX, "debug");
  if (!lua_istable(L, -1)) {
    lua_pop(L, 1);
    return 1;
  }
  lua_getfield(L, -1, "traceback");
  if (!lua_isfunction(L, -1)) {
    lua_pop(L, 2);
    return 1;
  }
  lua_pushvalue(L, 1);  /* pass error message */
  lua_pushinteger(L, 2);  /* skip this function and traceback */
  lua_call(L, 2, 1);  /* call debug.traceback */
  return 1;
}
&nbsp;
&nbsp;
static void lc_l_message (const char *pname, const char *msg) {
  if (pname) fprintf(stderr, "%s: ", pname);
  fprintf(stderr, "%s\n", msg);
  fflush(stderr);
}
&nbsp;
static int lc_report (lua_State *L, int status) {
  if (status &amp;&amp; !lua_isnil(L, -1)) {
    const char *msg = lua_tostring(L, -1);
    if (msg == NULL) msg = "(error object is not a string)";
    /*FIX-IMROVE:progname*/
    lc_l_message("lua", msg);
    lua_pop(L, 1);
  }
  return status;
}
&nbsp;
static int lc_docall (lua_State *L, int narg, int clear) {
  int status;
  int base = lua_gettop(L) - narg;  /* function index */
  lua_pushcfunction(L, traceback);  /* push traceback function */
  lua_insert(L, base);  /* put it under chunk and args */
  /*FIX? signal(SIGINT, laction); */
  status = lua_pcall(L, narg, (clear ? 0 : LUA_MULTRET), base);
  /*FIX? signal(SIGINT, SIG_DFL); */
  lua_remove(L, base);  /* remove traceback function */
  /* force a complete garbage collection in case of errors */
  if (status != 0) lua_gc(L, LUA_GCCOLLECT, 0);
  return status;
}
&nbsp;
static int lc_dofile (lua_State *L, const char *name) {
  int status = luaL_loadfile(L, name) || lc_docall(L, 0, 1);
  return lc_report(L, status);
}
&nbsp;
static int lc_dostring (lua_State *L, const char *s, const char *name) {
  int status = luaL_loadbuffer(L, s, strlen(s), name) || lc_docall(L, 0, 1);
  return lc_report(L, status);
}
&nbsp;
static int lc_handle_luainit (lua_State *L) {
  const char *init = getenv(LUA_INIT);
  if (init == NULL) return 0;  /* status OK */
  else if (init[0] == '@')
    return lc_dofile(L, init+1);
  else
    return lc_dostring(L, init, "=" LUA_INIT);
}
&nbsp;
&nbsp;
typedef struct {
  int c;
  const char ** v;
} lc_args_t;
&nbsp;
&nbsp;
/* create global arg table */
static void lc_createarg(lua_State * L, const lc_args_t * const args) {
  int i;
  lua_newtable(L);
  for (i=0; i &lt; args-&gt;c; i++) {
    lua_pushstring(L, args-&gt;v[i]);
    lua_rawseti(L, -2, i);
  }
  lua_setglobal(L, "arg");
}
&nbsp;
&nbsp;
static int lc_pmain(lua_State * L) {
  luaL_openlibs(L);
&nbsp;
  const lc_args_t * const args = (lc_args_t*)lua_touserdata(L, 1);
  lc_createarg(L, args);
&nbsp;
  lua_pushcfunction(L, traceback);
&nbsp;
  const int status1 = lc_handle_luainit(L);
  if (status1 != 0) return 0;
&nbsp;
  /* note: IMPROVE: closure not always needed here */
  lua_newtable(L); /* closure table */
  lua_pushcclosure(L, lcf_main, 1);
  int i;
  for (i=1; i &lt; args-&gt;c; i++) {
    lua_pushstring(L, args-&gt;v[i]);
  }
  int status2 = lua_pcall(L, args-&gt;c-1, 0, -2);
  if (status2 != 0) {
    const char * msg = lua_tostring(L,-1);
    if (msg == NULL) msg = "(error object is not a string)";
    fputs(msg, stderr);
  }
  return 0;
}
&nbsp;
&nbsp;
int main(int argc, const char ** argv) {
  lc_args_t args = {argc, argv};
  lua_State * L = luaL_newstate();
  if (! L) { fputs("Failed creating Lua state.", stderr); exit(1); }
&nbsp;
  int status = lua_cpcall(L, lc_pmain, &amp;args);
  if (status != 0) {
    fputs(lua_tostring(L,-1), stderr);
  }
&nbsp;
  lua_close(L);
  return 0;
}
</pre>

<p>(uff!)</p>

<p>Pøedposledním krokem je pøeklad céèkového kódu do nativní (spustitelné)
aplikace. Zde je nutné správnì nastavit cesty jak k&nbsp;hlavièkovým souborùm,
tak i ke knihovnì jazyka Lua:</p>

<pre>
gcc circles.c -o circles -I/usr/include/lua5.1 -lm -llua5.1
</pre>

<p>Program mù¾eme spustit tak, jako ka¾dou jinou nativní aplikaci:</p>

<pre>
./circles &gt; circles.pgm
</pre>



<p><a name="k11"></a></p>
<h2 id="k11">11. Výsledky benchmarku: interpret Lua vs. LuaJIT vs. transpøeklad do C</h2>

<p>Pøeklad zdrojového kódu do jazyka C s&nbsp;následnou mo¾ností pou¾ití v¹ech
optimalizací nabízených moderními pøekladaèi céèka sice vypadá zajímavì, ov¹em
kvùli ji¾ zmínìnému volání operátorù a metod pøes metatabulky v¹e nebude tak
výkonné, jak by se na první pohled mohlo zdát. Pojïme si v¹e vyzkou¹et na
benchmarku orientovaném na numerické výpoèty s&nbsp;reálnými èísly. Bude se
jednat o klasický výpoèet Mandelbrotovy mno¾iny, co¾ je dostateènì výpoèetnì
nároèný algoritmus i pro soudobé poèítaèe. Céèková verze algoritmu vypadá
následovnì (výsledkem je obrázek typu PGM):</p>

<pre>
#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;
#include &lt;string.h&gt;
#include &lt;math.h&gt;
&nbsp;
/* rozmery bitmapy */
#define BITMAP_WIDTH  2048
#define BITMAP_HEIGHT 1536
&nbsp;
/* maximalni pocet iteraci */
#define MAXITER 256
&nbsp;
void recalcMandelbrot()
{
    double zx, zy, zx2, zy2;                    /* slozky komplexni promenne Z a Z^2 */
    double cx, cy;                              /* slozky komplexni konstanty C */
&nbsp;
    int    x, y;                                /* pocitadla sloupcu a radku v bitmape */
    int    iter;                                /* pocitadlo iteraci */
&nbsp;
    cy=-1.5;
    for (y=0; y&lt;BITMAP_HEIGHT; y++) {           /* pro vsechny radky v bitmape */
        cx=-2.0;
        for (x=0; x&lt;BITMAP_WIDTH; x++) {        /* pro vsechny pixely na radku */
            zx=0; zy=0;
            for (iter=0; iter&lt;MAXITER; iter++) {/* iteracni smycka */
                zx2=zx*zx;                      /* zkraceny vypocet druhe mocniny slozek Z */
                zy2=zy*zy;
                if (zx2+zy2&gt;4.0) break;         /* kontrola prekroceni meze divergence */
                zy=2.0*zx*zy+cy;                /* vypocet Z(n+1) */
                zx=zx2-zy2+cx;
            }
            printf("%d\n", iter);
            cx+=(4.0)/BITMAP_WIDTH;             /* posun na dalsi bod na radku */
        }
        cy+=(3.0)/BITMAP_HEIGHT;                /* posun na dalsi radek */
    }
}
&nbsp;
&nbsp;
&nbsp;
int main(int argc, char **argv)
{
    puts("P2");
    printf("%d %d\n", BITMAP_WIDTH, BITMAP_HEIGHT);
    puts("255");
    recalcMandelbrot();
    return 0;
}
&nbsp;
&nbsp;
&nbsp;
/* ------------------------------------------------------------------ */
/* finito                                                             */
/* ------------------------------------------------------------------ */
</pre>

<img src="http://i.iinfo.cz/images/378/mandelbrot.png" class="image-215396" alt="&#160;" height="300" width="400" />
<p><i>Obrázek 2: Èást obrazu Mandelbrotovy mno¾iny vykreslená pøedchozím
demonstraèním pøíkladem.</i></p>

<p>Ekvivalentní verze stejného algoritmu, tentokrát implementovaného
v&nbsp;jazyku Lua:</p>

<pre>
-- rozmery bitmapy
local BITMAP_WIDTH  = 2048
local BITMAP_HEIGHT = 1536
&nbsp;
-- maximalni pocet iteraci
local MAXITER = 256
&nbsp;
function recalcMandelbrot()
    local zx, zy, zx2, zy2                    -- slozky komplexni promenne Z a Z^2
    local cx, cy                              -- slozky komplexni konstanty C
&nbsp;
    local x, y                                -- pocitadla sloupcu a radku v bitmape
    local iter = 0                            -- pocitadlo iteraci
&nbsp;
    cy=-1.5
    for y=0, BITMAP_HEIGHT-1 do               -- pro vsechny radky v bitmape
        cx=-2.0
        for x=0, BITMAP_WIDTH-1 do            -- pro vsechny pixely na radku
            zx=0 zy=0
            for i=0, MAXITER do               -- iteracni smycka
                iter = i
                zx2=zx*zx                     -- zkraceny vypocet druhe mocniny slozek Z
                zy2=zy*zy
                if zx2+zy2&gt;4.0 then
                    break                     -- kontrola prekroceni meze divergence
                end
                zy=2.0*zx*zy+cy               -- vypocet Z(n+1)
                zx=zx2-zy2+cx
            end
            print(iter)
            cx=cx+(4.0)/BITMAP_WIDTH          -- posun na dalsi bod na radku
        end
        cy=cy+(3.0)/BITMAP_HEIGHT            -- posun na dalsi radek
    end
end
&nbsp;
&nbsp;
&nbsp;
function main()
    print("P2")
    print(BITMAP_WIDTH .. " " .. BITMAP_HEIGHT)
    print("255")
    recalcMandelbrot()
end
&nbsp;
&nbsp;
&nbsp;
main()
&nbsp;
&nbsp;
&nbsp;
-- ------------------------------------------------------------------
-- finito                                                            
-- ------------------------------------------------------------------
</pre>

<p>Nejzajímavìj¹í budou výsledky doby trvání výpoètu zmìøené (pro jednoduchost)
pøíkazem <strong>time</strong>. Mìøit budeme:</p>

<ol>
<li>Výpoèet s&nbsp;vyu¾itím céèkového kódu optimalizovaného pøi pøekladu (-O3).</li>
<li>Výpoèet s&nbsp;vyu¾itím standardního interpretru <strong>lua</strong>.</li>
<li>Výpoèet s&nbsp;vyu¾itím <i>LuaJITu</i></li>
<li>Výpoèet programem vzniklým z&nbsp;Lua kódu pomocí <strong>lua2c</strong>, tento program byl takté¾ pøelo¾en s&nbsp;optimalizacemi.</li>
</ol>

<p>Výsledky:</p>

<table>
<tr><th>Metoda</th><th>real</th><th>user</th><th>sys</th></tr>
<tr><td>Nativní C           </td><td> 0.782s</td><td> 0.769s</td><td>0.012s</td></tr>
<tr><td>Interpret Lua       </td><td>22.187s</td><td>17.344s</td><td>4.823s</td></tr>
<tr><td>LuaJIT              </td><td> 1.834s</td><td> 1.822s</td><td>0.010s</td></tr>
<tr><td>Pøeklad Lua &rarr; C</td><td>33.557s</td><td>33.490s</td><td>0.040s</td></tr>
</table>

<p>Interpretace výsledkù je pro ná¹ benchmark zøejmá: nativní kód je podle
oèekávání nejrychlej¹í, ov¹em pøekvapil LuaJIT, který není o moc hor¹í (musíme
si toti¾ uvìdomit, ¾e JITování nezaène ihned, navíc se v&nbsp;celkovém èasu
zapoèítává i èas JITování, ostatnì zkuste si sami pøepsat algoritmus do Javy a
porovnat). Interpretovaný kód zpracovávaný nástrojem <strong>lua</strong> je
výraznì pomalej¹í a kupodivu nejpomalej¹í je nativní kód získaný
s&nbsp;vyu¾itím <strong>lua2c</strong>.</p>

<p>Poznámka na závìr: pøíklad naprogramovaný v&nbsp;Lue se pro úèely benchmarkù
nijak neupravoval, co¾ znamená, ¾e si podobný benchmark mù¾ete vyzkou¹et
s&nbsp;(pravdìpodobnì) jakoukoli aplikací napsanou v&nbsp;Lue a sami si
zjistit, jaká metoda spou¹tìní je pro va¹i konkrétní aplikaci nejlep¹í. Já jsem
pro porovnání zvolil algoritmus s&nbsp;numerickými výpoèty, výsledky v¹ak mohou
být odli¹né pøi práci s&nbsp;tabulkami atd. (zde je ov¹em slo¾ité udìlat
adekvátní verzi v&nbsp;C).</p>



<p><a name="k12"></a></p>
<h2 id="k12">12. Odkazy na Internetu</h2>

<ol>

<li>LuaJIT - Just in Time pøekladaè pro programovací jazyk Lua<br />
<a href="http://www.root.cz/clanky/luajit-just-in-time-prekladac-pro-programovaci-jazyk-lua/">http://www.root.cz/clanky/luajit-just-in-time-prekladac-pro-programovaci-jazyk-lua/</a>
</li>

<li>LuaJIT - Just in Time pøekladaè pro programovací jazyk Lua (2)<br />
<a href="http://www.root.cz/clanky/luajit-just-in-time-prekladac-pro-programovaci-jazyk-lua-2/">http://www.root.cz/clanky/luajit-just-in-time-prekladac-pro-programovaci-jazyk-lua-2/</a>
</li>

<li>LuaJIT - Just in Time pøekladaè pro programovací jazyk Lua (3)<br />
<a href="http://www.root.cz/clanky/luajit-just-in-time-prekladac-pro-programovaci-jazyk-lua-3/">http://www.root.cz/clanky/luajit-just-in-time-prekladac-pro-programovaci-jazyk-lua-3/</a>
</li>

<li>LuaJIT - Just in Time pøekladaè pro programovací jazyk Lua (4)<br />
<a href="http://www.root.cz/clanky/luajit-just-in-time-prekladac-pro-programovaci-jazyk-lua-4/">http://www.root.cz/clanky/luajit-just-in-time-prekladac-pro-programovaci-jazyk-lua-4/</a>
</li>

<li>LuaJIT - Just in Time pøekladaè pro programovací jazyk Lua (5 - tabulky a pole)<br />
<a href="http://www.root.cz/clanky/luajit-just-in-time-prekladac-pro-programovaci-jazyk-lua-5-tabulky-a-pole/">http://www.root.cz/clanky/luajit-just-in-time-prekladac-pro-programovaci-jazyk-lua-5-tabulky-a-pole/</a>
</li>

<li>LuaJIT - Just in Time pøekladaè pro programovací jazyk Lua (6 - pøeklad programových smyèek do mezijazyka LuaJITu)<br />
<a href="http://www.root.cz/clanky/luajit-just-in-time-prekladac-pro-programovaci-jazyk-lua-6-preklad-programovych-smycek-do-mezijazyka-luajitu/">http://www.root.cz/clanky/luajit-just-in-time-prekladac-pro-programovaci-jazyk-lua-6-preklad-programovych-smycek-do-mezijazyka-luajitu/</a>
</li>

<li>LuaJIT - Just in Time pøekladaè pro programovací jazyk Lua (7 - dokonèení popisu mezijazyka LuaJITu)<br />
<a href="http://www.root.cz/clanky/luajit-just-in-time-prekladac-pro-programovaci-jazyk-lua-7-dokonceni-popisu-mezijazyka-luajitu/">http://www.root.cz/clanky/luajit-just-in-time-prekladac-pro-programovaci-jazyk-lua-7-dokonceni-popisu-mezijazyka-luajitu/</a>
</li>

<li>LuaJIT - Just in Time pøekladaè pro programovací jazyk Lua (8 - základní vlastnosti trasovacího JITu)<br />
<a href="http://www.root.cz/clanky/luajit-just-in-time-prekladac-pro-programovaci-jazyk-lua-8-zakladni-vlastnosti-trasovaciho-jitu/">http://www.root.cz/clanky/luajit-just-in-time-prekladac-pro-programovaci-jazyk-lua-8-zakladni-vlastnosti-trasovaciho-jitu/</a>
</li>

<li>LuaJIT - Just in Time pøekladaè pro programovací jazyk Lua (9 - dal¹í vlastnosti trasovacího JITu)<br />
<a href="http://www.root.cz/clanky/luajit-just-in-time-prekladac-pro-programovaci-jazyk-lua-9-dalsi-vlastnosti-trasovaciho-jitu/">http://www.root.cz/clanky/luajit-just-in-time-prekladac-pro-programovaci-jazyk-lua-9-dalsi-vlastnosti-trasovaciho-jitu/</a>
</li>

<li>LuaJIT - Just in Time pøekladaè pro programovací jazyk Lua (10 - JIT pøeklad do nativního kódu)<br />
<a href="http://www.root.cz/clanky/luajit-just-in-time-prekladac-pro-programovaci-jazyk-lua-10-jit-preklad-do-nativniho-kodu/">http://www.root.cz/clanky/luajit-just-in-time-prekladac-pro-programovaci-jazyk-lua-10-jit-preklad-do-nativniho-kodu/</a>
</li>

<li>LuaJIT - Just in Time pøekladaè pro programovací jazyk Lua (11 - JIT pøeklad do nativního kódu procesorù s architekturami x86 a ARM)<br />
<a href="http://www.root.cz/clanky/luajit-just-in-time-prekladac-pro-programovaci-jazyk-lua-11-jit-preklad-do-nativniho-kodu-procesoru-s-architekturami-x86-a-arm/">http://www.root.cz/clanky/luajit-just-in-time-prekladac-pro-programovaci-jazyk-lua-11-jit-preklad-do-nativniho-kodu-procesoru-s-architekturami-x86-a-arm/</a>
</li>

<li>LuaJIT - Just in Time pøekladaè pro programovací jazyk Lua (12 - pøeklad operací s reálnými èísly)<br />
<a href="http://www.root.cz/clanky/luajit-just-in-time-prekladac-pro-programovaci-jazyk-lua-12-preklad-operaci-s-realnymi-cisly/">http://www.root.cz/clanky/luajit-just-in-time-prekladac-pro-programovaci-jazyk-lua-12-preklad-operaci-s-realnymi-cisly/</a>
</li>

<li>The Lua VM, on the Web<br />
<a href="https://kripken.github.io/lua.vm.js/lua.vm.js.html">https://kripken.github.io/lua.vm.js/lua.vm.js.html</a>
</li>

<li>Lua.vm.js REPL<br />
<a href="https://kripken.github.io/lua.vm.js/repl.html">https://kripken.github.io/lua.vm.js/repl.html</a>
</li>

<li>lua2js<br />
<a href="https://www.npmjs.com/package/lua2js">https://www.npmjs.com/package/lua2js</a>
</li>

<li>lua2js na GitHubu<br />
<a href="https://github.com/basicer/lua2js-dist">https://github.com/basicer/lua2js-dist</a>
</li>

<li>Seriál o programovacím jazyku Lua<br />
<a href="http://www.root.cz/serialy/programovaci-jazyk-lua/">http://www.root.cz/serialy/programovaci-jazyk-lua/</a>
</li>

<li>Source-to-source compiler<br />
<a href="https://en.wikipedia.org/wiki/Source-to-source_compiler">https://en.wikipedia.org/wiki/Source-to-source_compiler</a>
</li>

<li>JavaScript is Assembly Language for the Web: Sematic Markup is Dead! Clean vs. Machine-coded HTML<br />
<a href="http://www.hanselman.com/blog/JavaScriptIsAssemblyLanguageForTheWebSematicMarkupIsDeadCleanVsMachinecodedHTML.aspx">http://www.hanselman.com/blog/JavaScriptIsAssemblyLanguageForTheWebSematicMarkupIsDeadCleanVsMachinecodedHTML.aspx</a>
</li>

<li>JavaScript is Web Assembly Language and that's OK.<br />
<a href="http://www.hanselman.com/blog/JavaScriptIsWebAssemblyLanguageAndThatsOK.aspx">http://www.hanselman.com/blog/JavaScriptIsWebAssemblyLanguageAndThatsOK.aspx</a>
</li>

<li>Dart<br />
<a href="https://www.dartlang.org/">https://www.dartlang.org/</a>
</li>

<li>CoffeeScript<br />
<a href="http://coffeescript.org/">http://coffeescript.org/</a>
</li>

<li>TypeScript<br />
<a href="http://www.typescriptlang.org/">http://www.typescriptlang.org/</a>
</li>

<li>Lua (programming language)<br />
<a href="http://en.wikipedia.org/wiki/Lua_(programming_language)">http://en.wikipedia.org/wiki/Lua_(programming_language)</a>
</li>

<li>Static single assignment form (SSA)<br />
<a href="http://en.wikipedia.org/wiki/Static_single_assignment_form">http://en.wikipedia.org/wiki/Static_single_assignment_form</a>
</li>

<li>Wikipedia: Mezijazyk<br />
<a href="http://cs.wikipedia.org/wiki/Mezijazyk">http://cs.wikipedia.org/wiki/Mezijazyk</a>
</li>

<li>LuaJIT 2.0 SSA IR
<a href="http://wiki.luajit.org/SSA-IR-2.0">http://wiki.luajit.org/SSA-IR-2.0</a>
</li>

<li>The LuaJIT Project<br />
<a href="http://luajit.org/index.html">http://luajit.org/index.html</a>
</li>

<li>LuaJIT FAQ<br />
<a href="http://luajit.org/faq.html">http://luajit.org/faq.html</a>
</li>

<li>LuaJIT Performance Comparison<br />
<a href="http://luajit.org/performance.html">http://luajit.org/performance.html</a>
</li>

<li>LuaJIT 2.0 intellectual property disclosure and research opportunities<br />
<a href="http://article.gmane.org/gmane.comp.lang.lua.general/58908">http://article.gmane.org/gmane.comp.lang.lua.general/58908</a>
</li>

<li>LuaJIT Wiki<br />
<a href="http://wiki.luajit.org/Home">http://wiki.luajit.org/Home</a>
</li>

<li>LuaJIT 2.0 Bytecode Instructions<br />
<a href="http://wiki.luajit.org/Bytecode-2.0">http://wiki.luajit.org/Bytecode-2.0</a>
</li>

<li>Programming in Lua (first edition)<br />
<a href="http://www.lua.org/pil/contents.html">http://www.lua.org/pil/contents.html</a>
</li>

<li>Lua 5.2 sources<br />
<a href="http://www.lua.org/source/5.2/">http://www.lua.org/source/5.2/</a>
</li>

<li>Tcl Plugin Version 3<br />
<a href="http://www.tcl.tk/software/plugin/">http://www.tcl.tk/software/plugin/</a>
</li>

<li>JavaScript: The Web Assembly Language?<br />
<a href="http://www.informit.com/articles/article.aspx?p=1856657">http://www.informit.com/articles/article.aspx?p=1856657</a>
</li>

<li>asm.js<br />
<a href="http://asmjs.org/">http://asmjs.org/</a>
</li>

<li>List of languages that compile to JS<br />
<a href="https://github.com/jashkenas/coffeescript/wiki/List-of-languages-that-compile-to-JS">https://github.com/jashkenas/coffeescript/wiki/List-of-languages-that-compile-to-JS</a>
</li>

<li>REPL<br />
<a href="https://en.wikipedia.org/wiki/Read%E2%80%93eval%E2%80%93print_loop">https://en.wikipedia.org/wiki/Read%E2%80%93eval%E2%80%93print_loop</a>
</li>

<li>The LLVM Compiler Infrastructure<br />
<a href="http://llvm.org/ProjectsWithLLVM/">http://llvm.org/ProjectsWithLLVM/</a>
</li>

<li>clang: a C language family frontend for LLVM<br />
<a href="http://clang.llvm.org/">http://clang.llvm.org/</a>
</li>

<li>emscripten<br />
<a href="http://kripken.github.io/emscripten-site/">http://kripken.github.io/emscripten-site/</a>
</li>

<li>LLVM Backend ("Fastcomp")<br />
<a href="http://kripken.github.io/emscripten-site/docs/building_from_source/LLVM-Backend.html#llvm-backend">http://kripken.github.io/emscripten-site/docs/building_from_source/LLVM-Backend.html#llvm-backend</a>
</li>

<li>Emscripten - Fastcomp na GitHubu<br />
<a href="https://github.com/kripken/emscripten-fastcomp">https://github.com/kripken/emscripten-fastcomp</a>
</li>

<li>Clang (pro Emscripten) na GitHubu<br />
<a href="https://github.com/kripken/emscripten-fastcomp-clang">https://github.com/kripken/emscripten-fastcomp-clang</a>
</li>

<li>Why not use JavaScript?<br />
<a href="https://ckknight.github.io/gorillascript/">https://ckknight.github.io/gorillascript/</a>
</li>

<li>Lambda the Ultimate: Coroutines in Lua,<br />
<a href="http://lambda-the-ultimate.org/node/438">http://lambda-the-ultimate.org/node/438</a>
</li>

<li>Coroutines Tutorial,<br />
<a href="http://lua-users.org/wiki/CoroutinesTutorial">http://lua-users.org/wiki/CoroutinesTutorial</a>
</li>

<li>Lua Coroutines Versus Python Generators,<br />
<a href="http://lua-users.org/wiki/LuaCoroutinesVersusPythonGenerators">http://lua-users.org/wiki/LuaCoroutinesVersusPythonGenerators</a>
</li>

</ol>



<p></p><p></p>
<p><small>Autor: <a href="http://www.fit.vutbr.cz/~tisnovpa">Pavel Ti¹novský</a> &nbsp; 2015</small></p>
</body>
</html>

