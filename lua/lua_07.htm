<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
        "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html>
<head>
<title>Programovací jazyk Lua v aplikacích II</title>
<meta name="Author" content="Pavel Tisnovsky" />
<meta name="Generator" content="vim" />
<meta http-equiv="content-type" content="text/html; charset=utf-8" />
<style type="text/css">
         body {color:#000000; background:#ffffff;}
         h1  {font-family: arial, helvetica, sans-serif; color:#ffffff; background-color:#c00000; text-align:center; padding-left:1em}
         h2  {font-family: arial, helvetica, sans-serif; color:#ffffff; background-color:#0000c0; padding-left:1em; text-align:left}
         h3  {font-family: arial, helvetica, sans-serif; color:#000000; background-color:#c0c0c0; padding-left:1em; text-align:left}
         h4  {font-family: arial, helvetica, sans-serif; color:#000000; background-color:#e0e0e0; padding-left:1em; text-align:left}
         a   {font-family: arial, helvetica, sans-serif;}
         li  {font-family: arial, helvetica, sans-serif; color:#000000; text-align:justify; width:450px;}
         ol  {font-family: arial, helvetica, sans-serif; color:#000000; text-align:justify; width:450px;}
         ul  {font-family: arial, helvetica, sans-serif; color:#000000; text-align:justify; width:450px;}
         p   {font-family: arial, helvetica, sans-serif; color:#000000; text-align:justify;}
         pre {background:#e0e0e0}
</style>
</head>

<body>

<h1>Programovací jazyk Lua v aplikacích II</h1>

<h3>Pavel Tišnovský</h3>

<p></p>

<h1>Úvodník</h1>

<p>V sedmé části seriálu o programovacím jazyce Lua budou popsány rozdíly v aplikačním programovém rozhraní verze 5.0 a 5.1, vysvětlíme si způsob použití vlastního alokátoru paměti a taktéž si ukážeme, jakým způsobem lze kontrolovat a převádět parametry předávané z Lua skriptu do volaných céčkových funkcí.</p>



<h1>Obsah</h1>
<p>
<a href="#k01">1. Rozdíly v&nbsp;API mezi Lua 5.0 a Lua 5.1</a><br />
<a href="#k02">2. První demonstrační příklad: nekorektní inicializace knihoven v&nbsp;Lua 5.1</a><br />
<a href="#k03">3. Druhý demonstrační příklad: korektní inicializace knihoven v&nbsp;Lua 5.1</a><br />
<a href="#k04">4. Použití vlastního alokátoru paměti</a><br />
<a href="#k05">5. Třetí demonstrační příklad: alokátor paměti vypisující základní ladicí informace</a><br />
<a href="#k06">6. Kontrola parametrů předávaných z&nbsp;Lua skriptu do C</a><br />
<a href="#k07">7. Konverze parametrů předávaných z&nbsp;Lua skriptu do C</a><br />
<a href="#k08">8. Zdrojové kódy všech demonstračních příkladů i testovacích skriptů</a><br />
<a href="#k09">9. Odkazy na Internetu</a><br />
</p>



<p><a name="k01"></a></p>
<h1>1. Rozdíly v&nbsp;API mezi Lua 5.0 a Lua 5.1</h1>

<p>V&nbsp;předchozí části seriálu o programovacím jazyku <i>Lua</i> byly
popsány některé základní funkce aplikačního programového rozhraní (API)
běhového prostředí. Vzhledem k&nbsp;tomu, že mezi verzí 5.0 a 5.1 došlo
k&nbsp;několika změnám v&nbsp;API, může docházet k&nbsp;chybám při pokusu o
spuštění aplikace používající &bdquo;staré&ldquo; API spolu s&nbsp;<i>Lua
5.1</i> (nejedná se pouze o teoretickou možnost, na Internetu je
k&nbsp;dispozici poměrně velké množství demonstračních příkladů vytvořených pro
<i>Lua 5.0</i>). Ve druhé a třetí kapitole si popíšeme rozdílné chování API při
načítání a inicializaci standardních knihoven. Jeden z&nbsp;poměrně zásadních
rozdílů mezi <i>Lua 5.0</i> a <i>Lua 5.1</i> spočívá také v&nbsp;odlišném
způsobu vytvoření <i>stavu</i> běhového prostředí, který se ukládá do datové
struktury <i>lua_State</i>. Zatímco ve verzi 5.0 se pro vytvoření a
inicializaci stavu používala bezparametrická funkce <strong>lua_open()</strong>
(dnes dostupná jako makro pro zachování zpětné kompatibility), ve verzi 5.1 lze
pro tentýž účel použít buď taktéž bezparametrickou funkci
<strong>luaL_newstate()</strong>, popř.&nbsp;funkci
<strong>lua_newstate()</strong>, které lze předat ukazatel na alokátor paměti
(tímto způsobem je možné ovlivnit způsob alokace paměti běhového prostředí
<i>Lua</i>, čehož lze využít jak pro zvýšení efektivity správy paměti, tak i
pro ladicí účely). Této problematice se budeme věnovat ve čtvrté a páté
kapitole.</p>



<p><a name="k02"></a></p>
<h1>2. První demonstrační příklad: nekorektní inicializace knihoven v&nbsp;Lua 5.1</h1>

<p>V&nbsp;prvním demonstračním příkladu je ukázán (dnes nekorektní) způsob
inicializace knihoven, který již není možné ve verzi <i>Lua 5.1</i> použít.
Přesněji řečeno &ndash; některé knihovny sice je možné níže uvedeným způsobem
načíst a inicializovat, ale chyba nastane v&nbsp;případě pokusu o načtení
knihovny <i>io</i> pomocí přímého volání céčkové funkce
<strong>luaopen_io()</strong>. Důvod, proč přímé otevření této knihovny není
funkční, spočívá ve způsobu práce se soubory v&nbsp;knihovně <i>io</i> &ndash;
pro otevření souboru se používá funkce <strong>popen()</strong>, pro uzavření
by se tedy měla použít funkce <strong>pclose()</strong> a nikoli
<strong>fclose()</strong> (zavolání <strong>fclose()</strong> na soubor
otevřený pomocí <strong>popen()</strong> není dle POSIXu povoleno). Interpret
<i>Lua</i> si sice pamatuje, kterou funkcí mají být soubory uzavřeny, ovšem pro
korektní zapamatování tohoto příznaku je nutné <strong>luaopen_io()</strong>
volat přes <strong>lua_call()</strong>, přičemž se korektně nastaví prostředí
(<i>environment</i>), ve kterém jsou mj.&nbsp;uloženy i informace o tom, jakým
způsobem mají být soubory uzavřeny. V&nbsp;případě, že interpret zjistí, že
v&nbsp;prostředí nejsou tyto informace uloženy, vypíše se chybové hlášení
"PANIC: unprotected error in call to Lua API (no calling environment)" a
aplikace je ukončena. Tímto způsobem se interpret brání situaci, ve které by
mohlo dojít k&nbsp;porušení souborů. Jednodušší způsob práce s&nbsp;knihovnami,
který je podporovaný v&nbsp;<i>Lua 5.1</i>, je uveden ve třetí kapitole.
Následuje výpis zdrojového kódu prvního demonstračního příkladu:</p>

<code-area><i>/*</i>
<i> * Prvni demonstracni priklad</i>
<i> *</i>
<i> * Nekorektni, ve verzi Lua 5.1 jiz nepodporovany,</i>
<i> * zpusob nacteni knihoven.</i>
<i> */</i>

<strong>#include &lt;stdio.h&gt;</strong>
<strong>#include &lt;stdlib.h&gt;</strong>

<i>/* Zakladni a doplnkove funkce interpretu jazyka Lua */</i>
<strong>#include &lt;lualib.h&gt;</strong>
<strong>#include &lt;lauxlib.h&gt;</strong>

<i>/* Skript napsany v programovacim jazyce Lua */</i>
<strong>const</strong> <strong>char</strong> * SCRIPT =
"print('mocniny cisla 2')\n"\
"x=1\n"\
"for i=0, 16 do\n"\
"    print(i, x)\n"\
"    x=x*2\n"\
"end\n";

<i>/* Hlavni funkce konzolove aplikace */</i>
<strong>int </strong>main(<strong>void</strong>)
{
    <strong>int </strong>result;

    <i>/* vytisteni hlavicky */</i>
    puts(LUA_RELEASE);
    puts(LUA_COPYRIGHT);
    puts(LUA_AUTHORS);
    putchar('\n');

    <i>/* vytvoreni objektu, do nejz se uklada stav interpretu */</i>
    lua_State* L = lua_open();
    <i>/* nacteme zakladni knihovnu obsahujici mj. i funkci print() */</i>
    luaopen_base(L);
    <i>/* pokus o nacteni knihovny se vstupne-vystupnimi funkcemi */</i>
    luaopen_io(L);
    <i>/* nacteni retezce interpretem, jeho preklad a nasledne spusteni */</i>
    result = luaL_dostring(L, SCRIPT);
    <i>/* odstraneni vsech objektu asociovanych se stavem "Lua" */</i>
    lua_close(L);
    <strong>if </strong>(result != 0)
    {
        printf("Error # %d\n", result);
    }
    <i>/* vypocet navratoveho kodu */</i>
    <strong>return</strong> (result != 0);
}

<i>/* finito */</i>
</code-area>

<p>Po spuštění prvního demonstračního příkladu se vypíše chybové hlášení a
program je následně ukončen, aniž by byl spuštěn vložený skript.
V&nbsp;následujícím výpisu je sloučený standardní i chybový výstup, protože
poslední řádek (s&nbsp;hlášením o chybě) je poslán na chybový výstup &ndash;
<strong>stderr</strong>, zatímco řádky předchozí na výstup standardní &ndash;
<strong>stdout</strong>:</p>

<code-area>Lua 5.1.3
Copyright (C) 1994-2008 Lua.org, PUC-Rio
R. Ierusalimschy, L. H. de Figueiredo &amp; W. Celes

PANIC: unprotected error in call to Lua API (no calling environment)
</code-area>



<p><a name="k03"></a></p>
<h1>3. Druhý demonstrační příklad: korektní inicializace knihoven v&nbsp;Lua 5.1</h1>

<p>Ve druhém demonstračním příkladu se standardní knihovny otevírají pomocí
funkce <strong>luaL_openlibs(L)</strong> (proměnná <strong>L</strong>
reprezentuje stav interpretu &ndash; viz předchozí část tohoto seriálu) a
nikoli přes <strong>luaopen_base()</strong> a <strong>luaopen_io()</strong>,
což je již korektní &ndash; nedojde k&nbsp;běhové chybě. Funkce
<strong>luaL_openlibs(L)</strong> automaticky otevře všechny standardní
knihovny, tj.&nbsp;nahrazuje volání <strong>luaopen_base()</strong>,
<strong>luaopen_package()</strong>, <strong>luaopen_string()</strong>,
<strong>luaopen_table()</strong>, <strong>luaopen_math()</strong>,
<strong>luaopen_io()</strong>, <strong>luaopen_os()</strong> a konečně
<strong>luaopen_debug()</strong>. V&nbsp;případě, že skript nemá mít povolený
přístup k&nbsp;některé z&nbsp;těchto knihoven (například budeme chtít zakázat
volání API operačního systému či možnost manipulace se soubory; na
mikrořadičích nemusí být dostupná knihovna <i>math</i> atd.), může se místo
&bdquo;universální&ldquo; funkce <strong>luaL_openlibs()</strong> použít
například následující fragment kódu. Knihovny, které se nemají otevřít, lze
jednoduše z&nbsp;tabulky <i>lualibs</i> odstranit či zapoznámkovat (struktura
<i>luaL_Reg</i> je definována v&nbsp;souboru <i>lauxlib.h</i>):</p>

<code-area>
<i>/* Seznam knihoven, ktere se maji otevrit */</i>
<strong>static </strong><strong>const </strong>luaL_Reg lualibs[] = {
    {"", luaopen_base},
    {LUA_LOADLIBNAME, luaopen_package},
    {LUA_TABLIBNAME, luaopen_table},
    {LUA_IOLIBNAME, luaopen_io},
    {LUA_OSLIBNAME, luaopen_os},
    {LUA_STRLIBNAME, luaopen_string},
    {LUA_MATHLIBNAME, luaopen_math},
    {LUA_DBLIBNAME, luaopen_debug},
    {NULL, NULL}
};

<i>/* Otevreni vsech knihoven ulozenych v poli lualibs */</i>
LUALIB_API <strong>void</strong> open_custom_libs(lua_State *L)
{
    <strong>const </strong>luaL_Reg *lib = lualibs;
    <strong>for</strong> (; lib-&gt;func; lib++)
    {
        <i>/* nevola se primo lib->func, ale lua_call() s nastavenymi parametry */</i>
        <i>/* (volani lib->func je nekorektni, jedna se o stejny kod, */</i>
        <i>/* jaky byl pouzit v prvnim demonstracnim prikladu) */</i>
        lua_pushcfunction(L, lib-&gt;func);
        lua_pushstring(L, lib-&gt;name);
        lua_call(L, 1, 0);
    }
}
</code-area>

<p>Zdrojový kód druhého demonstračního příkladu má tvar:</p>

<code-area><i>/*</i>
<i> * Druhy demonstracni priklad</i>
<i> *</i>
<i> * Korektni zpusob prace s knihovnami, ktery je nutne pouzit</i>
<i> * v Lua 5.1</i>
<i> */</i>

<strong>#include &lt;stdio.h&gt;</strong>
<strong>#include &lt;stdlib.h&gt;</strong>

<i>/* Zakladni a doplnkove funkce interpretu jazyka Lua */</i>
<strong>#include &lt;lualib.h&gt;</strong>
<strong>#include &lt;lauxlib.h&gt;</strong>

<i>/* Skript napsany v programovacim jazyce Lua */</i>
<strong>const</strong> <strong>char</strong> * SCRIPT =
"print('mocniny cisla 2')\n"\
"x=1\n"\
"for i=0, 16 do\n"\
"    print(i, x)\n"\
"    x=x*2\n"\
"end\n";

<i>/* Hlavni funkce konzolove aplikace */</i>
<strong>int </strong>main(<strong>void</strong>)
{
    <strong>int </strong>result;

<i>    /* vytisteni hlavicky */</i>
    puts(LUA_RELEASE);
    puts(LUA_COPYRIGHT);
    puts(LUA_AUTHORS);
    putchar('\n');

<i>    /* vytvoreni objektu, do nejz se uklada stav interpretu */</i>
    lua_State* L = lua_open();
<i>    /* nacteni vsech knihoven - korektni zpusob */</i>
    luaL_openlibs(L);
<i>    /* nacteni retezce interpretem, jeho preklad a nasledne spusteni */</i>
    result = luaL_dostring(L, SCRIPT);
<i>    /* odstraneni vsech objektu asociovanych se stavem "Lua" */</i>
    lua_close(L);
    <strong>if </strong>(result != 0)
    {
        printf("Error # %d\n", result);
    }
<i>    /* vypocet navratoveho kodu */</i>
    <strong>return</strong> (result != 0);
}

<i>/* finito */</i>

</code-area>

<p>Po spuštění druhého demonstračního příkladu se knihovny korektně načtou,
provede se jejich inicializace a posléze se spustí i skript uložený
v&nbsp;řetězci. Výstupem je tabulka druhých mocnin čísla 2:</p>

<code-area>Lua 5.1.3
Copyright (C) 1994-2008 Lua.org, PUC-Rio
R. Ierusalimschy, L. H. de Figueiredo &amp; W. Celes

mocniny cisla 2
0       1
1       2
2       4
3       8
4       16
5       32
6       64
7       128
8       256
9       512
10      1024
11      2048
12      4096
13      8192
14      16384
15      32768
16      65536
</code-area>



<p><a name="k04"></a></p>
<h1>4. Použití vlastního alokátoru paměti</h1>

<p>V&nbsp;první kapitole jsme si řekli, že jeden z&nbsp;rozdílů mezi verzí
<i>Lua 5.0</i> a <i>Lua 5.1</i> spočívá v&nbsp;odlišném způsobu vytvoření
<i>stavu</i> interpreteru, který se ukládá do datové struktury
<i>lua_State</i>. Existují tři základní funkce pro vytvoření a prvotní
inicializaci stavu &ndash; <strong>lua_open()</strong>,
<strong>lua_newstate()</strong> a <strong>luaL_newstate()</strong>. Funkce
<strong>lua_open()</strong> byla využívána v&nbsp;předchozích verzích jazyka
<i>Lua</i>, dnes je udržována především kvůli zpětné kompatibilitě &ndash;
pohledem do hlavičkového souboru <i>lua.h</i> se můžeme přesvědčit, že se ve
skutečnosti jedná o makro preprocesoru volající funkci
<strong>luaL_newstate()</strong>. Jak makro <strong>lua_open()</strong>, tak i
funkce <strong>luaL_newstate()</strong> nevyžadují při svém volání žádné
parametry a jejich návratovou hodnotou je ukazatel na strukturu
<i>lua_State</i>, který je použit při všech dalších voláních aplikačního
programového rozhraní. Funkce <strong>lua_newstate()</strong> je poněkud
odlišná, neboť jí lze předat dvojici ukazatelů &ndash; ukazatel na funkci
volanou pro alokaci, realokaci a uvolňování paměti a uživatelsky nastavovaný
ukazatel, jehož hodnota je předávána do funkce, která provádí alokaci paměti
(použití tohoto ukazatele není nijak specifikováno, může například obsahovat
odkaz na strukturu popisující konfiguraci či stav aplikace). V&nbsp;následující
kapitole si ukážeme, jak by mohla funkce provádějící alokaci, realokaci a
uvolnění paměti vypadat.</p>



<p><a name="k05"></a></p>
<h1>5. Třetí demonstrační příklad: alokátor paměti vypisující základní ladicí informace</h1>

<p>V&nbsp;dnešním třetím demonstračním příkladu je ukázáno, jakým způsobem je
možné vytvořit funkci provádějící alokaci, realokaci i uvolňování paměti.
Alokátor paměti je automaticky volán běhovým prostředím jazyka <i>Lua</i>,
například ve chvíli, kdy jsou inicializovány knihovny, vytvářeny funkce či
proměnné atd. Taktéž ve chvíli, kdy je nějaká proměnná již nepoužívaná
(například blok, ve kterém je proměnná vytvořena, není platný), může garbage
collector zavolat tuto funkci, aby provedla uvolnění některého z&nbsp;bloků
paměti. Hlavička alokátoru paměti má čtyři parametry &ndash; uživatelsky
nastavený ukazatel (viz funkce <strong>lua_newstate()</strong>), ukazatel na
blok paměti, jenž se má uvolnit nebo jehož velikost se má změnit, původní délka
bloku a nová (požadovaná) délka bloku. V&nbsp;případě, že je ukazatel na blok
paměti nastavený na hodnotu <strong>NULL</strong>, znamená to, že se požaduje
alokace nového bloku o zadané délce (čtvrtý parametr). Při uvolnění bloku
paměti se z&nbsp;funkce musí vrátit hodnota <strong>NULL</strong>,
v&nbsp;opačném případě ukazatel na alokovaný či realokovaný blok (realokace
totiž může znamenat, že se blok dat přesune do nové oblasti paměti). Následuje
výpis zdrojového kódu třetího demonstračního příkladu; popis, co příklad po
svém spuštění vypíše, je uveden pod zdrojovým kódem:</p>

<code-area><i>/*</i>
<i> * Treti demonstracni priklad</i>
<i> *</i>
<i> * Pouziti vlastni alokacni funkce, ktera</i>
<i> * loguje veskere alokace, realokace ci uvolnovani pameti</i>
<i> * (tyto operace jsou automaticky provadeny interpretem a GC)</i>
<i> */</i>

<strong>#include &lt;stdio.h&gt;</strong>
<strong>#include &lt;stdlib.h&gt;</strong>

<i>/* Zakladni a doplnkove funkce interpretu jazyka Lua */</i>
<strong>#include &lt;lualib.h&gt;</strong>
<strong>#include &lt;lauxlib.h&gt;</strong>

<i>/* Skript napsany v programovacim jazyce Lua */</i>
<i>/* Ve skriptu se neustale zvetsuje pamet nutna pro ulozeni */</i>
<i>/* retezce 'x' */</i>
<strong>const</strong> <strong>char</strong> * SCRIPT =
"x='hello '\n"\
"for i=0, 10 do\n"\
"    local z='world!'\n"\
"    x=x..z..' '\n"\
"end\n";

<i>/* Vlastni alokacni funkce */</i>
<i>/* ud - uzivatelsky nastaveny ukazatel (vzdy konstantni) */</i>
<i>/* ptr - ukazatel na pamet, ktera se ma alokovat ci dealokovat */</i>
<i>/* osize - puvodni delka bloku */</i>
<i>/* nsize - nova (pozadovana) delka bloku */</i>
<strong>static void</strong> *memory_allocator(<strong>void</strong> *ud, <strong>void</strong> *ptr, size_t osize, size_t nsize)
{
    printf("memory_allocator (ud=%p): ", ud);
    <i>/* pokud je nsize == 0, znamena to, ze se ma pamet uvolnit */</i>
    <strong>if </strong>(nsize == 0)
    {
        printf("uvolnuji %d bajtu pameti na adrese %p\n", osize, ptr);
        <i>/* Muze nastat free(NULL), pokud osize==0, to je vsak v ANSI C korektni */</i>
        free(ptr);
        <strong>return</strong> NULL;
    }
    <strong>else</strong>
    {
        <strong>if </strong>(ptr==NULL)
        {
            printf("alokuji %d bajtu pameti\n", nsize);
        }
        <strong>else</strong>
        {
            printf("realokuji %d bajtu pameti na adrese %p na delku %d\n", osize, ptr, nsize);
        }
        <i>/* pokud ptr==NULL, provede se malloc() */</i>
        <strong>return</strong> realloc(ptr, nsize);
    }
}

<i>/* Hlavni funkce konzolove aplikace */</i>
<strong>int </strong>main(<strong>void</strong>)
{
    <strong>int </strong>result;

    <i>/* vytisteni hlavicky */</i>
    puts(LUA_RELEASE);
    puts(LUA_COPYRIGHT);
    puts(LUA_AUTHORS);
    putchar('\n');

    <i>/* vytvoreni objektu, do nejz se uklada stav interpretu */</i>
    lua_State* L = lua_newstate(memory_allocator, (<strong>void</strong>*)0x1234);
    <i>/* nacteni retezce interpretem, jeho preklad a nasledne spusteni */</i>
    result = luaL_dostring(L, SCRIPT);
    <i>/* odstraneni vsech objektu asociovanych se stavem "Lua" */</i>
    lua_close(L);
    <strong>if </strong>(result != 0)
    {
        printf("Error # %d\n", result);
    }
    <i>/* vypocet navratoveho kodu */</i>
    <strong>return</strong> (result != 0);
}

<i>/* finito */</i>
</code-area>

<p>Po spuštění tohoto příkladu se nejprve provede alokace paměti pro samotný
interpret i jeho běhové prostředí (včetně <i>stavu</i> interpretu) a následně
též pro vlastní skript, ve kterém je neustále prodlužován řetězec
<strong>x</strong>. Jakmile je skript ukončen a je zavolána funkce
<strong>lua_close()</strong>, dojde k&nbsp;postupnému uvolnění všech bloků
paměti. Požadavky běhového prostředí na alokace, realokace i uvolňování
paměťových bloků se vypisují na standardní výstup. Na výpisu uvedeném pod
odstavcem můžeme vidět, že i při běhu velmi jednoduchého skriptu obsahující
pouze dvě proměnné, je provedeno poměrně velké množství volání paměťového
alokátoru. Nutno však podotknout, že množství počátečních alokací na začátku
programu (inicializace interpretu) i uvolnění paměti na konci programu je do
značné míry nezávislé na délce či složitosti skriptu. Na výpisu si také
povšimněte, že uživatelsky nastavený ukazatel má při volání alokátoru paměti
stále stejnou hodnotu zadanou jako druhý parametr funkce
<strong>lua_newstate()</strong>:</p>

<code-area>Lua 5.1.3
Copyright (C) 1994-2008 Lua.org, PUC-Rio
R. Ierusalimschy, L. H. de Figueiredo &amp; W. Celes

memory_allocator (ud=00001234): alokuji 376 bajtu pameti
memory_allocator (ud=00001234): alokuji 192 bajtu pameti
memory_allocator (ud=00001234): alokuji 720 bajtu pameti
memory_allocator (ud=00001234): alokuji 32 bajtu pameti
memory_allocator (ud=00001234): uvolnuji 0 bajtu pameti na adrese 00000000
memory_allocator (ud=00001234): alokuji 64 bajtu pameti
memory_allocator (ud=00001234): alokuji 32 bajtu pameti
memory_allocator (ud=00001234): uvolnuji 0 bajtu pameti na adrese 00000000
memory_allocator (ud=00001234): alokuji 64 bajtu pameti
memory_allocator (ud=00001234): alokuji 128 bajtu pameti
memory_allocator (ud=00001234): uvolnuji 0 bajtu pameti na adrese 00000000
memory_allocator (ud=00001234): alokuji 24 bajtu pameti
memory_allocator (ud=00001234): alokuji 27 bajtu pameti
memory_allocator (ud=00001234): alokuji 21 bajtu pameti
memory_allocator (ud=00001234): alokuji 23 bajtu pameti
memory_allocator (ud=00001234): alokuji 21 bajtu pameti
memory_allocator (ud=00001234): alokuji 22 bajtu pameti
memory_allocator (ud=00001234): alokuji 22 bajtu pameti
memory_allocator (ud=00001234): alokuji 22 bajtu pameti
memory_allocator (ud=00001234): alokuji 22 bajtu pameti
memory_allocator (ud=00001234): alokuji 22 bajtu pameti
memory_allocator (ud=00001234): alokuji 22 bajtu pameti
memory_allocator (ud=00001234): alokuji 22 bajtu pameti
memory_allocator (ud=00001234): alokuji 22 bajtu pameti
memory_allocator (ud=00001234): alokuji 21 bajtu pameti
memory_allocator (ud=00001234): alokuji 21 bajtu pameti
memory_allocator (ud=00001234): alokuji 25 bajtu pameti
memory_allocator (ud=00001234): alokuji 23 bajtu pameti
memory_allocator (ud=00001234): alokuji 20 bajtu pameti
memory_allocator (ud=00001234): alokuji 22 bajtu pameti
memory_allocator (ud=00001234): alokuji 19 bajtu pameti
memory_allocator (ud=00001234): alokuji 21 bajtu pameti
memory_allocator (ud=00001234): alokuji 23 bajtu pameti
memory_allocator (ud=00001234): alokuji 20 bajtu pameti
memory_allocator (ud=00001234): alokuji 22 bajtu pameti
memory_allocator (ud=00001234): alokuji 20 bajtu pameti
memory_allocator (ud=00001234): alokuji 25 bajtu pameti
memory_allocator (ud=00001234): alokuji 19 bajtu pameti
memory_allocator (ud=00001234): alokuji 19 bajtu pameti
memory_allocator (ud=00001234): alokuji 22 bajtu pameti
memory_allocator (ud=00001234): alokuji 20 bajtu pameti
memory_allocator (ud=00001234): alokuji 20 bajtu pameti
memory_allocator (ud=00001234): alokuji 19 bajtu pameti
memory_allocator (ud=00001234): alokuji 23 bajtu pameti
memory_allocator (ud=00001234): alokuji 256 bajtu pameti
memory_allocator (ud=00001234): uvolnuji 128 bajtu pameti na adrese 003D27D8
memory_allocator (ud=00001234): alokuji 23 bajtu pameti
memory_allocator (ud=00001234): alokuji 21 bajtu pameti
memory_allocator (ud=00001234): alokuji 21 bajtu pameti
memory_allocator (ud=00001234): alokuji 22 bajtu pameti
memory_allocator (ud=00001234): alokuji 22 bajtu pameti
memory_allocator (ud=00001234): alokuji 34 bajtu pameti
memory_allocator (ud=00001234): alokuji 84 bajtu pameti
memory_allocator (ud=00001234): alokuji 32 bajtu pameti
memory_allocator (ud=00001234): alokuji 76 bajtu pameti
memory_allocator (ud=00001234): alokuji 32 bajtu pameti
memory_allocator (ud=00001234): uvolnuji 0 bajtu pameti na adrese 00000000
memory_allocator (ud=00001234): alokuji 18 bajtu pameti
memory_allocator (ud=00001234): alokuji 32 bajtu pameti
memory_allocator (ud=00001234): alokuji 64 bajtu pameti
memory_allocator (ud=00001234): alokuji 23 bajtu pameti
memory_allocator (ud=00001234): alokuji 64 bajtu pameti
memory_allocator (ud=00001234): uvolnuji 32 bajtu pameti na adrese 003D53D8
memory_allocator (ud=00001234): alokuji 128 bajtu pameti
memory_allocator (ud=00001234): uvolnuji 64 bajtu pameti na adrese 003D5468
memory_allocator (ud=00001234): alokuji 16 bajtu pameti
memory_allocator (ud=00001234): alokuji 16 bajtu pameti
memory_allocator (ud=00001234): alokuji 18 bajtu pameti
memory_allocator (ud=00001234): alokuji 28 bajtu pameti
memory_allocator (ud=00001234): alokuji 256 bajtu pameti
memory_allocator (ud=00001234): uvolnuji 128 bajtu pameti na adrese 003D27D8
memory_allocator (ud=00001234): alokuji 48 bajtu pameti
memory_allocator (ud=00001234): alokuji 28 bajtu pameti
memory_allocator (ud=00001234): alokuji 27 bajtu pameti
memory_allocator (ud=00001234): alokuji 512 bajtu pameti
memory_allocator (ud=00001234): uvolnuji 256 bajtu pameti na adrese 003D5500
memory_allocator (ud=00001234): realokuji 64 bajtu pameti na adrese 003D5400 na delku 128
memory_allocator (ud=00001234): realokuji 16 bajtu pameti na adrese 003D54B0 na delku 32
memory_allocator (ud=00001234): realokuji 16 bajtu pameti na adrese 003D54C8 na delku 32
memory_allocator (ud=00001234): alokuji 18 bajtu pameti
memory_allocator (ud=00001234): realokuji 48 bajtu pameti na adrese 003D5608 na delku 96
memory_allocator (ud=00001234): alokuji 23 bajtu pameti
memory_allocator (ud=00001234): alokuji 18 bajtu pameti
memory_allocator (ud=00001234): realokuji 32 bajtu pameti na adrese 003D5898 na delku 64
memory_allocator (ud=00001234): realokuji 32 bajtu pameti na adrese 003D58C0 na delku 64
memory_allocator (ud=00001234): realokuji 64 bajtu pameti na adrese 003D5400 na delku 56
memory_allocator (ud=00001234): realokuji 64 bajtu pameti na adrese 003D5468 na delku 56
memory_allocator (ud=00001234): realokuji 128 bajtu pameti na adrese 003D27D8 na delku 112
memory_allocator (ud=00001234): uvolnuji 0 bajtu pameti na adrese 00000000
memory_allocator (ud=00001234): realokuji 96 bajtu pameti na adrese 003D5908 na delku 60
memory_allocator (ud=00001234): uvolnuji 0 bajtu pameti na adrese 00000000
memory_allocator (ud=00001234): alokuji 20 bajtu pameti
memory_allocator (ud=00001234): uvolnuji 32 bajtu pameti na adrese 003D5310
memory_allocator (ud=00001234): alokuji 32 bajtu pameti
memory_allocator (ud=00001234): alokuji 30 bajtu pameti
memory_allocator (ud=00001234): alokuji 37 bajtu pameti
memory_allocator (ud=00001234): alokuji 44 bajtu pameti
memory_allocator (ud=00001234): realokuji 32 bajtu pameti na adrese 003D5310 na delku 34
memory_allocator (ud=00001234): alokuji 51 bajtu pameti
memory_allocator (ud=00001234): realokuji 34 bajtu pameti na adrese 003D59E0 na delku 41
memory_allocator (ud=00001234): alokuji 58 bajtu pameti
memory_allocator (ud=00001234): realokuji 41 bajtu pameti na adrese 003D5A50 na delku 48
memory_allocator (ud=00001234): alokuji 65 bajtu pameti
memory_allocator (ud=00001234): realokuji 48 bajtu pameti na adrese 003D5A50 na delku 55
memory_allocator (ud=00001234): alokuji 72 bajtu pameti
memory_allocator (ud=00001234): realokuji 55 bajtu pameti na adrese 003D5B20 na delku 62
memory_allocator (ud=00001234): alokuji 79 bajtu pameti
memory_allocator (ud=00001234): realokuji 62 bajtu pameti na adrese 003D5BB0 na delku 69
memory_allocator (ud=00001234): alokuji 86 bajtu pameti
memory_allocator (ud=00001234): realokuji 69 bajtu pameti na adrese 003D5C50 na delku 76
memory_allocator (ud=00001234): alokuji 93 bajtu pameti
memory_allocator (ud=00001234): realokuji 76 bajtu pameti na adrese 003D5D00 na delku 83
memory_allocator (ud=00001234): alokuji 100 bajtu pameti
memory_allocator (ud=00001234): uvolnuji 20 bajtu pameti na adrese 003D5950
memory_allocator (ud=00001234): uvolnuji 512 bajtu pameti na adrese 003D5690
memory_allocator (ud=00001234): uvolnuji 0 bajtu pameti na adrese 00000000
memory_allocator (ud=00001234): uvolnuji 32 bajtu pameti na adrese 003D5390
memory_allocator (ud=00001234): uvolnuji 56 bajtu pameti na adrese 003D5400
memory_allocator (ud=00001234): uvolnuji 0 bajtu pameti na adrese 00000000
memory_allocator (ud=00001234): uvolnuji 112 bajtu pameti na adrese 003D27D8
memory_allocator (ud=00001234): uvolnuji 56 bajtu pameti na adrese 003D5468
memory_allocator (ud=00001234): uvolnuji 60 bajtu pameti na adrese 003D5908
memory_allocator (ud=00001234): uvolnuji 0 bajtu pameti na adrese 00000000
memory_allocator (ud=00001234): uvolnuji 76 bajtu pameti na adrese 003D5338
memory_allocator (ud=00001234): uvolnuji 64 bajtu pameti na adrese 003D2790
memory_allocator (ud=00001234): uvolnuji 0 bajtu pameti na adrese 00000000
memory_allocator (ud=00001234): uvolnuji 32 bajtu pameti na adrese 003D2768
memory_allocator (ud=00001234): uvolnuji 64 bajtu pameti na adrese 003D2720
memory_allocator (ud=00001234): uvolnuji 0 bajtu pameti na adrese 00000000
memory_allocator (ud=00001234): uvolnuji 32 bajtu pameti na adrese 003D26F8
memory_allocator (ud=00001234): uvolnuji 18 bajtu pameti na adrese 003D5990
memory_allocator (ud=00001234): uvolnuji 84 bajtu pameti na adrese 003D52B0
memory_allocator (ud=00001234): uvolnuji 19 bajtu pameti na adrese 003D4F10
memory_allocator (ud=00001234): uvolnuji 65 bajtu pameti na adrese 003D5AD0
memory_allocator (ud=00001234): uvolnuji 22 bajtu pameti na adrese 003D5260
memory_allocator (ud=00001234): uvolnuji 22 bajtu pameti na adrese 003D4D88
memory_allocator (ud=00001234): uvolnuji 79 bajtu pameti na adrese 003D5BF8
memory_allocator (ud=00001234): uvolnuji 28 bajtu pameti na adrese 003D53D8
memory_allocator (ud=00001234): uvolnuji 18 bajtu pameti na adrese 003D54E0
memory_allocator (ud=00001234): uvolnuji 20 bajtu pameti na adrese 003D5058
memory_allocator (ud=00001234): uvolnuji 22 bajtu pameti na adrese 003D4DE8
memory_allocator (ud=00001234): uvolnuji 93 bajtu pameti na adrese 003D5D58
memory_allocator (ud=00001234): uvolnuji 27 bajtu pameti na adrese 003D2880
memory_allocator (ud=00001234): uvolnuji 21 bajtu pameti na adrese 003D4E68
memory_allocator (ud=00001234): uvolnuji 21 bajtu pameti na adrese 003D5220
memory_allocator (ud=00001234): uvolnuji 22 bajtu pameti na adrese 003D4DC8
memory_allocator (ud=00001234): uvolnuji 44 bajtu pameti na adrese 003D5608
memory_allocator (ud=00001234): uvolnuji 22 bajtu pameti na adrese 003D4E08
memory_allocator (ud=00001234): uvolnuji 100 bajtu pameti na adrese 003D5E20
memory_allocator (ud=00001234): uvolnuji 23 bajtu pameti na adrese 003D51E0
memory_allocator (ud=00001234): uvolnuji 22 bajtu pameti na adrese 003D4E28
memory_allocator (ud=00001234): uvolnuji 21 bajtu pameti na adrese 003D4E48
memory_allocator (ud=00001234): uvolnuji 18 bajtu pameti na adrese 003D53B8
memory_allocator (ud=00001234): uvolnuji 22 bajtu pameti na adrese 003D4DA8
memory_allocator (ud=00001234): uvolnuji 27 bajtu pameti na adrese 003D5668
memory_allocator (ud=00001234): uvolnuji 18 bajtu pameti na adrese 003D58E8
memory_allocator (ud=00001234): uvolnuji 21 bajtu pameti na adrese 003D5200
memory_allocator (ud=00001234): uvolnuji 22 bajtu pameti na adrese 003D5038
memory_allocator (ud=00001234): uvolnuji 23 bajtu pameti na adrese 003D50B8
memory_allocator (ud=00001234): uvolnuji 21 bajtu pameti na adrese 003D4F30
memory_allocator (ud=00001234): uvolnuji 23 bajtu pameti na adrese 003D4D08
memory_allocator (ud=00001234): uvolnuji 21 bajtu pameti na adrese 003D4D28
memory_allocator (ud=00001234): uvolnuji 58 bajtu pameti na adrese 003D5A88
memory_allocator (ud=00001234): uvolnuji 21 bajtu pameti na adrese 003D4CE8
memory_allocator (ud=00001234): uvolnuji 23 bajtu pameti na adrese 003D5970
memory_allocator (ud=00001234): uvolnuji 25 bajtu pameti na adrese 003D4FD0
memory_allocator (ud=00001234): uvolnuji 37 bajtu pameti na adrese 003D59B0
memory_allocator (ud=00001234): uvolnuji 30 bajtu pameti na adrese 003D58C0
memory_allocator (ud=00001234): uvolnuji 20 bajtu pameti na adrese 003D4F70
memory_allocator (ud=00001234): uvolnuji 19 bajtu pameti na adrese 003D5098
memory_allocator (ud=00001234): uvolnuji 28 bajtu pameti na adrese 003D5640
memory_allocator (ud=00001234): uvolnuji 24 bajtu pameti na adrese 003D2860
memory_allocator (ud=00001234): uvolnuji 34 bajtu pameti na adrese 003D5280
memory_allocator (ud=00001234): uvolnuji 23 bajtu pameti na adrese 003D4EB0
memory_allocator (ud=00001234): uvolnuji 72 bajtu pameti na adrese 003D5B60
memory_allocator (ud=00001234): uvolnuji 20 bajtu pameti na adrese 003D5078
memory_allocator (ud=00001234): uvolnuji 25 bajtu pameti na adrese 003D4E88
memory_allocator (ud=00001234): uvolnuji 23 bajtu pameti na adrese 003D4F50
memory_allocator (ud=00001234): uvolnuji 22 bajtu pameti na adrese 003D4F90
memory_allocator (ud=00001234): uvolnuji 19 bajtu pameti na adrese 003D4FF8
memory_allocator (ud=00001234): uvolnuji 20 bajtu pameti na adrese 003D4ED0
memory_allocator (ud=00001234): uvolnuji 22 bajtu pameti na adrese 003D4EF0
memory_allocator (ud=00001234): uvolnuji 22 bajtu pameti na adrese 003D4D48
memory_allocator (ud=00001234): uvolnuji 20 bajtu pameti na adrese 003D4FB0
memory_allocator (ud=00001234): uvolnuji 19 bajtu pameti na adrese 003D5018
memory_allocator (ud=00001234): uvolnuji 86 bajtu pameti na adrese 003D5CA0
memory_allocator (ud=00001234): uvolnuji 22 bajtu pameti na adrese 003D5240
memory_allocator (ud=00001234): uvolnuji 51 bajtu pameti na adrese 003D5A10
memory_allocator (ud=00001234): uvolnuji 22 bajtu pameti na adrese 003D4D68
memory_allocator (ud=00001234): uvolnuji 23 bajtu pameti na adrese 003D5448
memory_allocator (ud=00001234): uvolnuji 256 bajtu pameti na adrese 003D50D8
memory_allocator (ud=00001234): uvolnuji 83 bajtu pameti na adrese 003D5DC0
memory_allocator (ud=00001234): uvolnuji 192 bajtu pameti na adrese 003D2630
memory_allocator (ud=00001234): uvolnuji 720 bajtu pameti na adrese 003D4A10
memory_allocator (ud=00001234): uvolnuji 376 bajtu pameti na adrese 003D24B0
</code-area>



<p><a name="k06"></a></p>
<h1>6. Kontrola parametrů předávaných z&nbsp;Lua skriptu do C</h1>

<p>V&nbsp;předchozí části tohoto seriálu jsme si řekli, že při volání céčkové
funkce z&nbsp;<i>Lua</i> skriptu se všechny parametry předávají přes zvláštní
zásobník, nikoli na standardní rámec (<i>frame</i>) procesu &ndash; na něj se
ukládá pouze jeden ukazatel. Z&nbsp;toho vyplývá i poměrně velké zabezpečení
aplikace, například proti nestandardní manipulaci s&nbsp;rámcem (útoky typu
<i>stack overflow</i>). Na druhou stranu je však nutné parametry z&nbsp;výše
uvedeného zvláštního zásobníku získat, zkonvertovat na standardní céčkové typy
a teprve s&nbsp;nimi dále pracovat. Pro zjištění, kolik parametrů je na
zásobník skutečně uloženo, slouží funkce <strong>lua_gettop()</strong>. Další
funkce vypsané v&nbsp;tabulce je možné použít na zjištění typů jednotlivých
parametrů &ndash; vzhledem k&nbsp;dynamičnosti jazyka <i>Lua</i> totiž není
možné typ zjistit při překladu zdrojového textu do bajtkódu, ale až za běhu
skriptu (<i>runtime type identification</i>). Všechny funkce určené pro
zjištění typu předávané hodnoty mají dva argumenty &ndash; <i>stav</i>
interpretu a index parametru, jehož typ se má zjistit, přičemž parametry jsou
číslovány od jedničky (jedná se o jejich pozici v&nbsp;zásobníku).</p>

<table>
<tr><th>Funkce</th><th>Význam</th></tr>
<tr><td>lua_gettop(lua_State *L)</td><td>vrací obsazení zásobníku, tj.&nbsp;počet předaných parametrů</td></tr>
<tr><td>lua_isnumber(lua_State *L, int idx)</td><td>vrací pravdivostní hodnotu dle toho, zda je parametr typu číslo</td></tr>
<tr><td>lua_isstring(lua_State *L, int idx)</td><td>vrací pravdivostní hodnotu dle toho, zda je parametr typu řetězec</td></tr>
<tr><td>lua_iscfunction(lua_State *L, int idx)</td><td>vrací pravdivostní hodnotu dle toho, zda je parametr typu C-funkce</td></tr>
<tr><td>lua_isuserdata(lua_State *L, int idx)</td><td>vrací pravdivostní hodnotu dle toho, zda je parametr typu uživatelská data</td></tr>
<tr><td>lua_type(lua_State *L, int idx)</td><td>vrací typ parametru &ndash; konstanty typu LUA_T* (viz <i>lua.h</i>)</td></tr>
<tr><td>lua_typename(lua_State *L, int tp)</td><td>převádí číslo typu na jeho tisknutelné jméno (lze použít při výpisu chybových hlášení apod.)</td></tr>
</table>



<p><a name="k07"></a></p>
<h1>7. Konverze parametrů předávaných z&nbsp;Lua skriptu do C</h1>

<p>Parametry, se kterými je registrovaná céčková funkce volána
z&nbsp;<i>Lua</i> skriptu, je nutné před jejich dalším zpracováním převést na
nějaký známý céčkový typ. K&nbsp;tomuto účelu slouží jedno makro a osm funkcí,
jež jsou vypsány v&nbsp;tabulce pod tímto odstavcem. Prvním argumentem všech
konverzních funkcí i zmíněného makra je ukazatel na strukturu udržující
<i>stav</i> interpretu a druhým argumentem je index parametru uloženého na
zásobník před zavoláním céčkové funkce, přičemž parametry jsou, jak jsme se již
dozvěděli v&nbsp;předchozí kapitole, číslovány od jedničky. Návratová hodnota
funkce <strong>lua_tonumber()</strong> je typu <strong>LUA_NUMBER</strong>
&ndash; tento typ je specifikován v&nbsp;hlavičkovém souboru <i>luaconf.h</i>.
Změnou typu je možné nastavit, s&nbsp;jakými čísly bude interpret jazyka
<i>Lua</i> pracovat. Implicitním číselným typem je <i>double</i>, poměrně
jednoduše však lze provést změnu na <i>short int</i> či <i>int</i> (taktéž je
nutné změnit konverzní makra <i>lua_number2int</i> a
<i>lua_number2integer</i>). Funkce <strong>lua_tonumber()</strong> taktéž
dokáže provést i konverzi řetězce na číselnou hodnotu, samozřejmě za
předpokladu, že v&nbsp;řetězci jsou uloženy znaky představující platné cifry,
popř.&nbsp;znaménko či desetinný oddělovač.</p>

<table>
<tr><th>Funkce</th><th>Význam</th></tr>
<tr><td>lua_tonumber(lua_State *L, int idx)</td><td>převod parametru na číslo (typ záleží na nastavení <i>luaconf.h</i>)</td></tr>
<tr><td>lua_tointeger(lua_State *L, int idx)</td><td>převod parametru na integer (celé číslo se znaménkem)</td></tr>
<tr><td>lua_toboolean(lua_State *L, int idx)</td><td>převod parametru na pravdivostní hodnotu, při konverzi platí všechna pravidla jazyka <i>Lua</i></td></tr>
<tr><td>lua_tolstring(lua_State *L, int idx, size_t *len)</td><td>převod parametru na řetězec, naplní se i délka řetězce (místo platného ukazatele může být poslední parametr roven <strong>NULL</strong>)</td></tr>
<tr><td>lua_tostring(lua_State *L, int idx)</td><td>převod parametru na řetězec (jedná se o makro, nikoli funkci)</td></tr>
<tr><td>lua_tocfunction(lua_State *L, int idx)</td><td>převod parametru na céčkovou funkci (ukazatel na tuto funkci)</td></tr>
<tr><td>lua_touserdata(lua_State *L, int idx)</td><td>převod parametru na uživatelská data</td></tr>
<tr><td>lua_tothread(lua_State *L, int idx)</td><td>převod parametru na vlákno jazyka <i>Lua</i></td></tr>
<tr><td>lua_topointer(lua_State *L, int idx)</td><td>převod parametru na generický céčkový pointer (<i>void *</i>)</td></tr>
</table>



<p><a name="k08"></a></p>
<h1>8. Zdrojové kódy všech demonstračních příkladů i testovacích skriptů</h1>

<p>V&nbsp;následující tabulce jsou uloženy odkazy na zdrojové kódy všech tří
demonstračních příkladů popsaných v&nbsp;předchozích kapitolách. Taktéž jsou
zde uvedeny výsledky běhu demonstračních příkladů (jedná se o standardní i
chybový výstup přesměrovaný do souboru po převodu tabulátorů na mezery).</p>

<table>
<tr><th>Soubor</th></tr>
<tr><td><att-url id="730">Zdrojový kód prvního demonstračního příkladu</att-url></td></tr>
<tr><td><att-url id="731">Výsledek běhu prvního demonstračního příkladu</att-url></td></tr>
<tr><td><att-url id="732">Zdrojový kód druhého demonstračního příkladu</att-url></td></tr>
<tr><td><att-url id="733">Výsledek běhu druhého demonstračního příkladu</att-url></td></tr>
<tr><td><att-url id="734">Zdrojový kód třetího demonstračního příkladu</att-url></td></tr>
<tr><td><att-url id="735">Výsledek běhu třetího demonstračního příkladu</att-url></td></tr>
</table>



<p><a name="k09"></a></p>
<h1>9. Odkazy na Internetu</h1>

<ol>

<li>Programming in Lua (first edition)<br />
<a href="http://www.lua.org/pil/index.html">http://www.lua.org/pil/index.html</a>
</li>

<li>Lua home page<br />
<a href="http://www.lua.org/ ">http://www.lua.org/ </a>
</li>

<li>Lua: vestavitelný minimalista<br />
<a href="http://www.root.cz/clanky/lua-vestavitelny-minimalista/">http://www.root.cz/clanky/lua-vestavitelny-minimalista/</a>
</li>

<li>Lua<br />
<a href="http://www.linuxexpres.cz/praxe/lua">http://www.linuxexpres.cz/praxe/lua</a>
</li>

<li>CZ Wikipedia: Lua<br />
<a href="http://cs.wikipedia.org/wiki/Lua">http://cs.wikipedia.org/wiki/Lua</a>
</li>

<li>EN Wikipedia: Lua (programming language)<br />
<a href="http://en.wikipedia.org/wiki/Lua_(programming_language)">http://en.wikipedia.org/wiki/Lua_(programming_language)</a>
</li>

<li>The Lua Programming Language<br />
<a href="http://www.tiobe.com/index.php/paperinfo/tpci/Lua.html">http://www.tiobe.com/index.php/paperinfo/tpci/Lua.html</a>
</li>

<li>Lua Programming Gems<br />
<a href="http://www.lua.org/gems/">http://www.lua.org/gems/</a>
</li>

<li>LuaForge<br />
<a href="http://luaforge.net/">http://luaforge.net/</a>
</li>

<li>Forge project tree<br />
<a href="http://luaforge.net/softwaremap/trove_list.php">http://luaforge.net/softwaremap/trove_list.php</a>
</li>

</ol>



<p></p><p></p>
<p><small>Autor: <a href="http://www.fit.vutbr.cz/~tisnovpa">Pavel Tišnovský</a> &nbsp; 2009</small></p>
</body>
</html>

