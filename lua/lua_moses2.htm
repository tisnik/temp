<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
        "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html>
<head>
<title>Podpora funkcionálního programovaní v jazyku Lua s využitím knihovny Moses (pokračování)</title>
<meta name="Author" content="Pavel Tisnovsky" />
<meta name="Generator" content="vim" />
<meta http-equiv="content-type" content="text/html; charset=utf-8" />
<style type="text/css">
         body {color:#000000; background:#ffffff;}
         h1  {font-family: arial, helvetica, sans-serif; color:#ffffff; background-color:#c00000; text-align:center; padding-left:1em}
         h2  {font-family: arial, helvetica, sans-serif; color:#ffffff; background-color:#0000c0; padding-left:1em; text-align:left}
         h3  {font-family: arial, helvetica, sans-serif; color:#000000; background-color:#c0c0c0; padding-left:1em; text-align:left}
         h4  {font-family: arial, helvetica, sans-serif; color:#000000; background-color:#e0e0e0; padding-left:1em; text-align:left}
         a   {font-family: arial, helvetica, sans-serif;}
         li  {font-family: arial, helvetica, sans-serif; color:#000000; text-align:justify; width:450px;}
         ol  {font-family: arial, helvetica, sans-serif; color:#000000; text-align:justify; width:450px;}
         ul  {font-family: arial, helvetica, sans-serif; color:#000000; text-align:justify; width:450px;}
         p   {font-family: arial, helvetica, sans-serif; color:#000000; text-align:justify;}
         pre {background:#e0e0e0}
</style>
</head>

<body>

<h1>Podpora funkcionálního programovaní v jazyku Lua s využitím knihovny Moses (pokračování)</h1>

<h3>Pavel Tišnovský</h3>

<p></p>

<h1>Úvodník</h1>

<p></p>



<h2>Obsah</h2>

<p><a href="#k01">1. Podpora funkcionálního programovaní v&nbsp;jazyku Lua s&nbsp;využitím knihovny Moses (pokračování)</a></p>
<p><a href="#k02">2. Funkce <strong>sum</strong> a <strong>product</strong></a></p>
<p><a href="#k03">3. Funkce <strong>mean</strong>, <strong>median</strong>, <strong>min</strong> a <strong>max</strong></a></p>
<p><a href="#k04">4. Pokročilejší zpracování polí: <strong>flatten</strong> a <strong>compact</strong></a></p>
<p><a href="#k05">5. Vytvoření párů hodnot funkcí <strong>xprod</strong></a></p>
<p><a href="#k06">6. Funkce <strong>reduce</strong> aplikovaná na tabulku</a></p>
<p><a href="#k07">7. Zpracování prvků tabulky v&nbsp;opačném směru funkcí <strong>reduceRight</strong></a></p>
<p><a href="#k08">*** 8. Rozdělení tabulky funkcí vyššího řádu <strong>groupBy</strong></a></p>
<p><a href="#k09">*** 9. Iterace prvky tabulky pomocí funkcí <strong>each</strong></a></p>
<p><a href="#k10">*** 10. Rozdíl mezi funkcemi <strong>each</strong> a <strong>eachi</strong></a></p>
<p><a href="#k11">11. Další funkce vyššího řádu procházející tabulkou: <strong>map</strong></a></p>
<p><a href="#k12">12. Zřetězení operací nad tabulkou s&nbsp;využitím <strong>chain</strong></a></p>
<p><a href="#k13">13. Složitější příklady zřetězení operací</a></p>
<p><a href="#k14">*** 14. Funkce vyššího řádu <strong>mapReduce</strong></a></p>
<p><a href="#k15">*** 15. Rozdíl mezi funkcemi <strong>mapReduce</strong> a <strong>mapReduceRight</strong></a></p>
<p><a href="#k16">*** 16. Iterace prvky tabulky funkcemi <strong>sortedk</strong> a <strong>sortedv</strong></a></p>
<p><a href="#k17">17. Obsah závěrečného článku o knihovně Moses</a></p>
<p><a href="#k18">18. Repositář s&nbsp;demonstračními příklady</a></p>
<p><a href="#k19">19. Články o programovacím jazyce Lua i o technologii LuaJITu</a></p>
<p><a href="#k20">20. Odkazy na Internetu</a></p>



<p><a name="k01"></a></p>
<h2 id="k01">1. Podpora funkcionálního programovaní v&nbsp;jazyku Lua s&nbsp;využitím knihovny Moses (pokračování)</h2>

<p>Ve druhém článku o knihovně <i>Moses</i> se budeme zpočátku zabývat těmi
funkcemi, které jsou primárně určené pro zpracování tabulek. Připomeňme si na
tomto místě, že použitá terminologie může být matoucí, protože se pod pojmem
tabulka ve skutečnosti skrývá datová struktura známá v&nbsp;jiných jazycích pod
jménem slovník. V&nbsp;následující tabulce (sic) jsou terminologické rozdíly
mezi tandemem <i>Lua+Moses</i> a většinou dalších programovacích jazyků
shrnuty:</p>

<table>
<tr><th>#</th><th>Termín použitý v&nbsp;Moses</th><th>Běžný význam</th></tr>
<tr><td>1</td><td>array</td><td>list, set</td></tr>
<tr><td>2</td><td>table</td><td>dictionary</td></tr>
</table>

<p><div class="rs-tip-major">Poznámka: ve skutečnosti může tabulka
v&nbsp;jazyku Lua obsahovat dvě části &ndash; &bdquo;seznamovou&ldquo; a
&bdquo;slovníkovou&ldquo;. Jedná se o poměrně specifický rys tohoto
programovacího jazyka, protože v&nbsp;mnoha jiných jazycích jsou
k&nbsp;dispozici dvě odlišné datové struktury většinou i s&nbsp;odlišnými
operacemi. V&nbsp;programovacím jazyku Lua je situace o to více matoucí, že
některé operace &ndash; typicky operace resp.&nbsp;operátor pro zjištění délky
struktury &ndash; pracují pouze se &bdquo;seznamovou&ldquo; částí tabulky.
Ovšem díky použití knihovny <i>Moses</i> můžeme být od těchto nízkoúrovňových
detailů do značné míry odstíněni. Více viz například klasický výklad dostupný
na adrese <a
href="http://lua-users.org/wiki/TablesTutorial">http://lua-users.org/wiki/TablesTutorial</a>.</div></p>

<p>V&nbsp;tomto článku budou popsány následující funkce (a metody) poskytované
knihovnou <i>Moses</i>:</p>

<table>
<tr><th> #</th><th>Funkce</th><th>Kapitola</th></tr>
<tr><td> 1</td><td>sum</td><td><a href="#k02">2</a></td></tr>
<tr><td> 2</td><td>product</td><td><a href="#k02">2</a></td></tr>
<tr><td> 3</td><td>mean</td><td><a href="#k03">3</a></td></tr>
<tr><td> 4</td><td>median</td><td><a href="#k03">3</a></td></tr>
<tr><td> 5</td><td>min</td><td><a href="#k03">3</a></td></tr>
<tr><td> 6</td><td>max</td><td><a href="#k03">3</a></td></tr>
<tr><td> 7</td><td>flatten</td><td><a href="#k04">4</a></td></tr>
<tr><td> 8</td><td>compact</td><td><a href="#k04">4</a></td></tr>
<tr><td> 9</td><td>xprod</td><td><a href="#k05">5</a></td></tr>
<tr><td>10</td><td>reduce</td><td><a href="#k06">6</a></td></tr>
<tr><td>11</td><td>reduceRight</td><td><a href="#k07">7</a></td></tr>
<tr><td>12</td><td>groupBy</td><td><a href="#k08">8</a></td></tr>
<tr><td>13</td><td>each</td><td><a href="#k09">9</a></td></tr>
<tr><td>14</td><td>eachi</td><td><a href="#k10">10</a></td></tr>
<tr><td>15</td><td>map</td><td><a href="#k11">11</a></td></tr>
<tr><td>16</td><td>chain</td><td><a href="#k12">12</a></td></tr>
<tr><td>17</td><td>mapReduce</td><td><a href="#k14">14</a></td></tr>
<tr><td>18</td><td>mapReduceRight</td><td><a href="#k15">15</a></td></tr>
<tr><td>19</td><td>sortedk</td><td><a href="#k16">16</a></td></tr>
<tr><td>20</td><td>sortedv</td><td><a href="#k16">16</a></td></tr>
</table>



<p><a name="k02"></a></p>
<h2 id="k02">2. Funkce <strong>sum</strong> a <strong>product</strong></h2>

<p>Dvě sice jednoduché, ovšem prakticky velmi dobře použitelné funkce, které
v&nbsp;knihovně <i>Moses</i> nalezneme, se jmenují <strong>sum</strong> a
<strong>product</strong>. První z&nbsp;těchto funkcí je určena pro součet všech
prvků pole, druhá pro postupný součin všech prvků. Použití obou zmíněných
funkcí je snadné:</p>

<pre>
<i>-- načtení knihovny Moses a současně import symbolů do globálního jmenného prostoru</i>
M = require "moses"
M.import()
&nbsp;
&nbsp;
<i>-- tisk obsahu pole</i>
<strong>function</strong> printArrayInLine(array)
    <i>-- test na prázdné pole</i>
    <strong>if</strong> #array == 0 <strong>then</strong>
        print("*empty*")
        <strong>return</strong>
    <strong>end</strong>
    <strong>for</strong> i, value <strong>in</strong> ipairs(array) <strong>do</strong>
        io.write(value)
        <strong>if</strong> i ~= #array <strong>then</strong>
            io.write(", ")
        <strong>end</strong>
    <strong>end</strong>
    print()
<strong>end</strong>
&nbsp;
&nbsp;
<i>-- oddělení obsahu</i>
<strong>function</strong> printSeparator()
    print("--------------------------------------------")
<strong>end</strong>
&nbsp;
&nbsp;
<i>-- první vstupní pole obsahuje sekvenci čísel 1 až 10</i>
a = range(10)
&nbsp;&nbsp;
printSeparator()
print("Original array")
printArrayInLine(a)
print()
&nbsp;
<i>-- tisk součtu (sumace) a součinu všech hodnot v poli</i>
print("Sum=" .. sum(a))
print("Product=" .. product(a))
</pre>

<p>Tento demonstrační příklad by měl po svém spuštění vypsat součet prvků
z&nbsp;aritmetické posloupnosti 1 až 10. Ihned poté se vypočte a zobrazí i
součin všech těchto deseti prvků:</p>

<pre>
--------------------------------------------
Original array
1, 2, 3, 4, 5, 6, 7, 8, 9, 10
&nbsp;
Sum=55
Product=3628800
</pre>

<p>Pokud se ovšem v&nbsp;sekvenci bude nabízet nulový prvek, vrátí funkce
<strong>product</strong> (pochopitelně) i nulový výsledek:</p>

<pre>
<i>-- druhé vstupní pole obsahuje sekvenci čísel 0 až 10</i>
b = range(0, 10)
&nbsp;
printSeparator()
print("Original array")
printArrayInLine(b)
print()
&nbsp;
<i>-- tisk součtu (sumace) a součinu všech hodnot v poli</i>
print("Sum=" .. sum(b))
print("Product=" .. product(b))
</pre>

<p>Poslední řádek skutečně v&nbsp;tomto případě zobrazuje nulu:</p>

<pre>
--------------------------------------------
Original array
0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10
&nbsp;
Sum=55
Product=0
</pre>

<p>Vyzkoušejme si ještě, co se stane v&nbsp;případě, kdy je vstupní pole
prázdné, tj.&nbsp;když neobsahuje žádné prvky:</p>

<pre>
<i>-- vstupní pole je prázné</i>
a = {}
&nbsp;
printSeparator()
print("Original array")
printArrayInLine(a)
print()
&nbsp;
<i>-- tisk součtu (sumace) a součinu všech hodnot v poli</i>
print("Sum=" .. sum(a))
print("Product=" .. product(a))
</pre>

<p>Zde nastane zvláštní situace &ndash; suma bude rovna nule, ovšem součin
roven jedné:</p>

<pre>
--------------------------------------------
Original array
*empty*
&nbsp;
Sum=0
Product=1
</pre>

<p>Operaci prováděnou funkcí <strong>product</strong> můžeme využít pro výpočet
faktoriálu, resp.&nbsp;přesněji řečeno tabulky faktoriálů pro vstupní hodnoty 0
až 10:</p>

<pre>
<i>-- načtení knihovny Moses a současně import symbolů do globálního jmenného prostoru</i>
M = require "moses"
M.import()
&nbsp;
&nbsp;
<i>-- výpočet faktoriálu vstupních hodnot 0 až 10</i>
<strong>for</strong> n = 0, 10 <strong>do</strong>
    <i>-- konstrukce pole</i>
    a = range(1, n)
    <i>-- výpočet a tisk produktu hodnot 1..n == n!</i>
    print(n, product(a))
<strong>end</strong>
</pre>

<p>Výsledná tabulka vypočtená předchozím demonstračním příkladem:</p>

<pre>
0       0
1       1
2       2
3       6
4       24
5       120
6       720
7       5040
8       40320
9       362880
10      3628800
</pre>

<p><div class="rs-tip-major">Poznámka: s&nbsp;různými způsoby výpočtu
faktoriálu se ještě několikrát setkáme v&nbsp;navazujících
kapitolách.</div></p>



<p><a name="k03"></a></p>
<h2 id="k03">3. Funkce <strong>mean</strong>, <strong>median</strong>, <strong>min</strong> a <strong>max</strong></h2>

<p>Knihovna <i>Moses</i> obsahuje i funkce určené pro výpočet průměru a
mediánu; další dvě funkce slouží pro nalezení prvku s&nbsp;minimální
resp.&nbsp;s&nbsp;maximální hodnotou. Matematický význam těchto funkcí by měl
být zřejmý, takže si je můžeme přímo otestovat:</p>

<pre>
<i>-- načtení knihovny Moses a současně import symbolů do globálního jmenného prostoru</i>
M = require "moses"
M.import()
&nbsp;
&nbsp;
<i>-- tisk obsahu pole</i>
<strong>function</strong> printArrayInLine(array)
    <i>-- test na prázdné pole</i>
    <strong>if</strong> #array == 0 <strong>then</strong>
        print("*empty*")
        <strong>return</strong>
    <strong>end</strong>
    <strong>for</strong> i, value <strong>in</strong> ipairs(array) <strong>do</strong>
        io.write(value)
        <strong>if</strong> i ~= #array <strong>then</strong>
            io.write(", ")
        <strong>end</strong>
    <strong>end</strong>
    print()
<strong>end</strong>
&nbsp;
&nbsp;
<i>-- oddělení obsahu</i>
<strong>function</strong> printSeparator()
    print("--------------------------------------------")
<strong>end</strong>
&nbsp;
&nbsp;
<i>-- vytvoření a naplnění pole o sto prvcích</i>
a={}
<strong>for</strong> i = 1, 100 <strong>do</strong>
    a[i] = math.random(10)
<strong>end</strong>
&nbsp;
<i>-- vytištění původního pole</i>
printSeparator()
print("Original array")
printArrayInLine(a)
&nbsp;
<i>-- výpočet a tisk základních statistických veličin</i>
print()
print("Mean:   " .. mean(a))
print("Median: " .. median(a))
print("Min:    " .. min(a))
print("Max:    " .. max(a))
</pre>

<p>Pole o sto prvcích je naplněno náhodnými hodnotami v&nbsp;rozsahu 1 až 10,
čemuž odpovídají i vypočtené hodnoty průměru a mediánu:</p>

<pre>
--------------------------------------------
Original array
9, 4, 8, 8, 10, 2, 4, 8, 3, 6, 5, 7, 4, 6, 10, 10, 7, 8, 2, 7, 1, 3, 2, 9, 2, 5, 2, 2, 10, 3, 6, 9, 7, 3, 7, 6, 5, 10, 3, 8, 6, 8, 5, 9, 3, 4, 9, 10, 1, 10, 6, 1, 2, 7, 9, 4, 1, 1, 5, 1, 3, 10, 10, 9, 3, 6, 4, 8, 6, 7, 6, 1, 5, 10, 10, 8, 3, 8, 7, 4, 7, 2, 5, 9, 9, 4, 3, 9, 4, 7, 10, 6, 7, 9, 5, 10, 4, 9, 7, 10
&nbsp;
Mean:   5.97
Median: 6.0
Min:    1
Max:    10
</pre>

<p>Pokud příklad upravíme tak, aby se generovaly pseudonáhodné hodnoty od 0 do
10 (tedy včetně nuly), bude průměr a medián odlišný:</p>

<pre>
<i>-- načtení knihovny Moses a současně import symbolů do globálního jmenného prostoru</i>
M = require "moses"
M.import()
&nbsp;
&nbsp;
<i>-- tisk obsahu pole</i>
<strong>function</strong> printArrayInLine(array)
    <i>-- test na prázdné pole</i>
    <strong>if</strong> #array == 0 <strong>then</strong>
        print("*empty*")
        <strong>return</strong>
    <strong>end</strong>
    <strong>for</strong> i, value <strong>in</strong> ipairs(array) <strong>do</strong>
        io.write(value)
        <strong>if</strong> i ~= #array <strong>then</strong>
            io.write(", ")
        <strong>end</strong>
    <strong>end</strong>
    print()
<strong>end</strong>
&nbsp;
&nbsp;
<i>-- oddělení obsahu</i>
<strong>function</strong> printSeparator()
    print("--------------------------------------------")
<strong>end</strong>
&nbsp;
&nbsp;
<i>-- vytvoření a naplnění pole o sto prvcích</i>
a={}
<strong>for</strong> i = 1, 100 <strong>do</strong>
    <i>-- náhodná hodnota v rozsahu 0 až 10</i>
    a[i] = math.random(0, 10)
<strong>end</strong>
&nbsp;
<i>-- vytištění původního pole</i>
printSeparator()
print("Original array")
printArrayInLine(a)
&nbsp;
<i>-- výpočet a tisk základních statistických veličin</i>
print()
print("Mean:   " .. mean(a))
print("Median: " .. median(a))
print("Min:    " .. min(a))
print("Max:    " .. max(a))
</pre>

<p>Nyní bude průměr roven 5.5 a medián (hodnota rozdělující setříděnou sekvenci
v&nbsp;polovině) bude roven pěti:</p>

<pre>
--------------------------------------------
Original array
9, 4, 8, 8, 10, 2, 3, 8, 3, 6, 5, 6, 4, 5, 10, 10, 6, 7, 1, 6, 0, 2, 1, 8, 1, 4, 1, 1, 10, 2, 5, 9, 6, 3, 7, 5, 5, 10, 3, 8, 5, 8, 4, 9, 3, 3, 8, 10, 0, 10, 5, 0, 2, 7, 9, 3, 0, 0, 5, 0, 2, 10, 9, 9, 2, 5, 4, 8, 5, 7, 5, 0, 4, 10, 10, 7, 3, 8, 7, 3, 7, 1, 4, 9, 9, 3, 2, 9, 3, 7, 10, 6, 7, 9, 4, 10, 4, 8, 7, 10
&nbsp;
Mean:   5.5
Median: 5.0
Min:    0
Max:    10
</pre>

<p>Ještě si ukažme, jak budou výpočty vypadat pro prázdné vstupní pole:</p>

<pre>
<i>-- prázdné vstupní pole</i>
a={}
&nbsp;
<i>-- vytištění původního pole</i>
printSeparator()
print("Original array")
printArrayInLine(a)
&nbsp;
<i>-- výpočet a tisk základních statistických veličin</i>
print()
print("Mean:   " .. mean(a))
print("Median: " .. (median(a) or "nil"))
print("Min:    " .. (min(a) or "nil"))
print("Max:    " .. (max(a) or "nil"))
</pre>

<p>Zde dochází k&nbsp;tomu, že průměr je roven NaN (protože se interně
pravděpodobně dělí nula nulou), kdežto ostatní statistické veličiny budou rovny
<strong>nil</strong> (prázdná hodnota):</p>

<pre>
--------------------------------------------
Original array
*empty*
&nbsp;
Mean:   -nan
Median: nil
Min:    nil
Max:    nil
</pre>

<p><div class="rs-tip-major">Poznámka: v&nbsp;praxi tedy bude nutné testovat
prázdná pole na vstupu.</div></p>



<p><a name="k04"></a></p>
<h2 id="k04">4. Pokročilejší zpracování polí: <strong>flatten</strong> a <strong>compact</strong></h2>

<p>Další dvě funkce mohou být velmi užitečné při zpracování polí (či slovníků),
jejichž data byla importována například z&nbsp;formátu XML, JSON či EDT.
Typicky se jedná o strukturovaná data představovaná poli/slovníky, jejichž
prvky jsou další pole/slovníky. První z&nbsp;funkcí se jmenuje
<strong>flatten</strong> a umožňuje původní hierarchickou datovou strukturu
&bdquo;zploštit&ldquo; buď do běžné jednorozměrné (lineární tabulky) nebo lze
v&nbsp;případě potřeby &bdquo;zploštění&ldquo; provést pouze na nejvyšší úrovni
(a ostatní hierarchické struktury zachovat). Ukažme si nejdříve první případ,
tj.&nbsp;úplné zploštění obsahu tabulky pomocí funkce nazvané příznačně
<strong>flatten</strong>. Povšimněte si, že v&nbsp;příkladu používáme novou
pomocnou funkci pojmenovanou <strong>nestedArray</strong>, která akceptuje
tabulku s&nbsp;libovolnou interní strukturou a zobrazí její obsah ve formě
S-výrazu používaného v&nbsp;mnoha LISPovských programovacích jazycích:</p>

<pre>
<i>-- načtení knihovny Moses a současně import symbolů do globálního jmenného prostoru</i>
M = require "moses"
M.import()
&nbsp;
&nbsp;
<i>-- získaní textové podoby obsahu pole obsahujícího další vnořená pole</i>
<strong>function</strong> nestedArray(array)
    <strong>if</strong> type(array) == 'table' <strong>then</strong>
        <strong>local</strong> s = '('
        <i>-- použít LISPovské s-výrazy</i>
        <strong>for</strong> i, v <strong>in</strong> ipairs(array) <strong>do</strong>
            <i>-- oddělovač</i>
            <strong>if</strong> i &gt; 1 <strong>then</strong>
                s = s .. ' '
            <strong>end</strong>
            <i>-- pole mohou být vnořena</i>
            s = s .. nestedArray(v)
        <strong>end</strong>
        <strong>return</strong> s .. ')'
    <strong>else</strong>
        <strong>return</strong> tostring(array)
    <strong>end</strong>
<strong>end</strong>
&nbsp;
&nbsp;
<i>-- oddělení obsahu</i>
<strong>function</strong> printSeparator()
    print("--------------------------------------------")
<strong>end</strong>
</pre>

<p>Vlastní zploštění se provádí zde:</p>

<pre>
<i>-- původní pole</i>
a = {1, 2, 3, {4, 5, 6, {7, 8, 9}, {10, 11}}, 12}
printSeparator()
&nbsp;
<i>-- tisk původního pole</i>
print("Original array")
print(nestedArray(a))
print()
&nbsp;
<i>-- tisk zploštělého pole</i>
printSeparator()
print("Flatten array")
print(nestedArray(flatten(a)))
</pre>

<p>Příklad po svém spuštění nejdříve vypíše obsah původní tabulky (zde je
patrná hierarchická a rekurzivní struktura) a následně obsah stejné tabulky,
ovšem po zploštění:</p>

<pre>
--------------------------------------------
Original array
(1 2 3 (4 5 6 (7 8 9) (10 11)) 12)
&nbsp;
--------------------------------------------
Flatten array
(1 2 3 4 5 6 7 8 9 10 11 12)
</pre>

<p>Můžeme mít samozřejmě tabulku s&nbsp;mnohem hlubší strukturou,
například:</p>

<pre>
<i>-- původní pole</i>
b = {"a", {"b", {"c", {"d", {"e", {"f", {"g"}}}}}}}
printSeparator()
&nbsp;
<i>-- tisk původního pole</i>
print("Original array")
print(nestedArray(b))
print()
&nbsp;
<i>-- tisk zploštělého pole</i>
print("Flatten array")
print(nestedArray(flatten(b)))
</pre>

<p>Výsledek po spuštění této části demonstračního příkladu:</p>

<pre>
--------------------------------------------
Original array
(a (b (c (d (e (f (g)))))))
&nbsp;
Flatten array
(a b c d e f g)
</pre>

<p>Pokud ovšem funkci <strong>flatten</strong> předáme další (nepovinný)
parametr, provede se zploštění pouze na nejvyšší úrovni hierarchie &ndash;
funkce nebude aplikována rekurzivně i na všechny prvky tabulky (a na případné
vnořené tabulky). Opět si ukažme, jak taková operace vypadaná v&nbsp;praxi:</p>

<pre>
<i>-- načtení knihovny Moses a současně import symbolů do globálního jmenného prostoru</i>
M = require "moses"
M.import()
&nbsp;
&nbsp;
<i>-- získaní textové podoby obsahu pole obsahujícího další vnořená pole</i>
<strong>function</strong> nestedArray(array)
    <strong>if</strong> type(array) == 'table' <strong>then</strong>
        <i>-- použít LISPovské s-výrazy</i>
        <strong>local</strong> s = '('
        <strong>for</strong> i, v <strong>in</strong> ipairs(array) <strong>do</strong>
            <i>-- oddělovač</i>
            <strong>if</strong> i &gt; 1 <strong>then</strong>
                s = s .. ' '
            <strong>end</strong>
            <i>-- pole mohou být vnořena</i>
            s = s .. nestedArray(v)
        <strong>end</strong>
        <strong>return</strong> s .. ')'
    <strong>else</strong>
        <strong>return</strong> tostring(array)
    <strong>end</strong>
<strong>end</strong>
&nbsp;
&nbsp;
<i>-- oddělení obsahu</i>
<strong>function</strong> printSeparator()
    print("--------------------------------------------")
<strong>end</strong>
&nbsp;
&nbsp;
<i>-- původní pole</i>
a = {1, 2, 3, {4, 5, 6, {7, 8, 9}, {10, 11}}, 12}
printSeparator()
&nbsp;
<i>-- tisk původního pole</i>
print("Original array")
print(nestedArray(a))
print()
printSeparator()
&nbsp;
<i>-- tisk zploštělého pole</i>
print("Flatten array")
print(nestedArray(flatten(a, <strong>true</strong>)))
</pre>

<p>Opět se nejdříve vypíše původní struktura tabulky a posléze struktura po
zploštění. Povšimněte si, že vnořené tabulky nejsou v&nbsp;tomto případě
zploštěny:</p>

<pre>
--------------------------------------------
Original array
(1 2 3 (4 5 6 (7 8 9) (10 11)) 12)
&nbsp;
--------------------------------------------
Flatten array
(1 2 3 4 5 6 (7 8 9) (10 11) 12)
</pre>

<p>Tatáž operace je ještě lépe viditelná na tabulce, která interně připomíná
lineárně vázaný seznam známý z&nbsp;programovacího jazyka LISP:</p>

<pre>
<i>-- původní pole</i>
b = {"a", {"b", {"c", {"d", {"e", {"f", {"g"}}}}}}}
printSeparator()
&nbsp;
<i>-- tisk původního pole</i>
print("Original array")
print(nestedArray(b))
print()
&nbsp;
<i>-- tisk zploštělého pole</i>
print("Flatten array")
print(nestedArray(flatten(b, true)))
</pre>

<p>Výsledek zploštění pouze na nejvyšší úrovni:</p>

<pre>
--------------------------------------------
Original array
(a (b (c (d (e (f (g)))))))
&nbsp;
Flatten array
(a b (c (d (e (f (g))))))
</pre>

<p>Nakonec si ukažme postupné zplošťování obsahu tabulky až do chvíle, kdy je
nějaká varianta tabulky totožná s&nbsp;variantou zploštěnou. Začátek zdrojového
kódu demonstračního příkladu je stále stejný:</p>

<pre>
<i>-- načtení knihovny Moses a současně import symbolů do globálního jmenného prostoru</i>
M = require "moses"
M.import()
&nbsp;
&nbsp;
<i>-- získaní textové podoby obsahu pole obsahujícího další vnořená pole</i>
<strong>function</strong> nestedArray(array)
    <strong>if</strong> type(array) == 'table' <strong>then</strong>
        <i>-- použít LISPovské s-výrazy</i>
        <strong>local</strong> s = '('
        <strong>for</strong> i, v <strong>in</strong> ipairs(array) <strong>do</strong>
            <i>-- oddělovač</i>
            <strong>if</strong> i &gt; 1 <strong>then</strong>
                s = s .. ' '
            <strong>end</strong>
            <i>-- pole mohou být vnořena</i>
            s = s .. nestedArray(v)
        <strong>end</strong>
        return s .. ')'
    <strong>else</strong>
        return tostring(array)
    <strong>end</strong>
<strong>end</strong>
&nbsp;
&nbsp;
<i>-- oddělení obsahu</i>
<strong>function</strong> printSeparator()
    print("--------------------------------------------")
<strong>end</strong>
</pre>

<p>Zplošťování probíhá v&nbsp;programové smyčce typu
<strong>repeat-until</strong> až do chvíle, kdy je zploštěná tabulka totožná
s&nbsp;mezitabulkou (a kdy tudíž již nemá smysl funkci <strong>flatten</strong>
neustále spouštět):</p>

<pre>
<i>-- původní pole</i>
a = {1, 2, 3, {4, 5, 6, {7, 8, 9, {10, 11}}, {12, 13, {14, 15}}}, 16}
printSeparator()
&nbsp;
<i>-- tisk původního pole</i>
print("Original array")
print(nestedArray(a))
&nbsp;
printSeparator()
&nbsp;
<i>-- tisk postupně "zplošťovaného" pole</i>
print("Flatten array")
&nbsp;
<strong>repeat</strong>
    b = a
    a = flatten(a, <strong>true</strong>)
    print(nestedArray(b))
<strong>until</strong> isEqual(a, b)
</pre>

<p>Výsledek po spuštění příkladu:</p>

<pre>
--------------------------------------------
Original array
(1 2 3 (4 5 6 (7 8 9 (10 11)) (12 13 (14 15))) 16)
&nbsp;
--------------------------------------------
Flatten array
(1 2 3 (4 5 6 (7 8 9 (10 11)) (12 13 (14 15))) 16)
(1 2 3 4 5 6 (7 8 9 (10 11)) (12 13 (14 15)) 16)
(1 2 3 4 5 6 7 8 9 (10 11) 12 13 (14 15) 16)
(1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16)
</pre>

<p>Tutéž operaci provedeme s&nbsp;druhou tabulkou, kterou již známe (jakýsi
LISPovský seznam či jeho obdoba):</p>

<pre>
<i>-- původní pole</i>
a = {"a", {"b", {"c", {"d", {"e", {"f", {"g"}}}}}}}
printSeparator()
&nbsp;
<i>-- tisk původního pole</i>
print("Original array")
print(nestedArray(a))
print()
&nbsp;
<i>-- tisk postupně "zplošťovaného" pole</i>
print("Flatten array")
&nbsp;
<strong>repeat</strong>
    b = a
    a = flatten(a, <strong>true</strong>)
    print(nestedArray(b))
<strong>until</strong> isEqual(a, b)
</pre>

<p>Výsledek postupného splošťování:</p>

<pre>
--------------------------------------------
Original array
(a (b (c (d (e (f (g)))))))
&nbsp;
Flatten array
(a (b (c (d (e (f (g)))))))
(a b (c (d (e (f (g))))))
(a b c (d (e (f (g)))))
(a b c d (e (f (g))))
(a b c d e (f (g)))
(a b c d e f (g))
(a b c d e f g)
</pre>

<p>Druhou funkcí, kterou si v&nbsp;této kapitole popíšeme, je funkce nazvaná
<strong>compact</strong>. Tato funkce z&nbsp;tabulky odstraní &bdquo;nepravdivé
prvky&ldquo;, konkrétně prvky mající hodnotu <strong>false</strong> nebo
<strong>nil</strong>:</p>

<pre>
<i>-- načtení knihovny Moses a současně import symbolů do globálního jmenného prostoru</i>
M = require "moses"
M.import()
&nbsp;
&nbsp;
<i>-- tisk obsahu pole</i>
<strong>function</strong> printArrayInLine(array)
    <i>-- test na prázdné pole</i>
    <strong>if</strong> #array == 0 <strong>then</strong>
        print("*empty*")
        <strong>return</strong>
    <strong>end</strong>
    <strong>for</strong> i, value <strong>in</strong> ipairs(array) <strong>do</strong>
        io.write(tostring(value))
        <strong>if</strong> i ~= #array <strong>then</strong>
            io.write(", ")
        <strong>end</strong>
    <strong>end</strong>
    print()
<strong>end</strong>
&nbsp;
&nbsp;
<i>-- oddělení obsahu</i>
<strong>function</strong> printSeparator()
    print("--------------------------------------------")
<strong>end</strong>
&nbsp;
&nbsp;
<i>-- tisk původního pole i pole "kompaktního"</i>
<strong>function</strong> printCompacedArray(a)
    printSeparator()
    print("original array")
    printArrayInLine(a)
    print("compacted array")
    printArrayInLine(compact(a))
    print()
<strong>end</strong>
&nbsp;
&nbsp;
printCompacedArray({})
printCompacedArray({1, 2, 3, 4})
printCompacedArray(zeros(10))
printCompacedArray({true, <strong>false</strong>, <strong>true</strong>, <strong>false</strong>, <strong>true</strong>, <strong>false</strong>})
printCompacedArray({"foo", <strong>nil</strong>, "bar", <strong>nil</strong>, <strong>nil</strong>, "baz", <strong>nil</strong>, <strong>nil</strong>, <strong>nil</strong>})
</pre>

<p>Povšimněte si, že pokud tabulka prvky <strong>nil</strong> nebo
<strong>false</strong> neobsahuje, není pozměněna:</p>

<pre>
--------------------------------------------
original array
*empty*
compacted array
*empty*
&nbsp;
--------------------------------------------
original array
1, 2, 3, 4
compacted array
1, 2, 3, 4
&nbsp;
--------------------------------------------
original array
0, 0, 0, 0, 0, 0, 0, 0, 0, 0
compacted array
0, 0, 0, 0, 0, 0, 0, 0, 0, 0
&nbsp;
--------------------------------------------
original array
true, false, true, false, true, false
compacted array
true, true, true
&nbsp;
--------------------------------------------
original array
foo
compacted array
foo, bar, baz
</pre>

<p><div class="rs-tip-major">Poznámka: v&nbsp;tomto demonstračním příkladu jsme
narazili na jednu velmi problematickou vlastnost programovacího jazyka
<i>Lua</i> &ndash; výpis obsahu tabulky (resp.&nbsp;iterace přes její prvky) se
zastaví na prvním prvku s&nbsp;hodnotou <strong>nil</strong>.</div></p>



<p><a name="k05"></a></p>
<h2 id="k05">5. Vytvoření párů hodnot funkcí <strong>xprod</strong></h2>

<p>V&nbsp;některých algoritmech může být užitečné zkombinovat dvojici tabulek,
a to takovým způsobem, že výsledkem bude další tabulka, jejíž prvky budou
postupně obsahovat všechny možné kombinace prvků z&nbsp;původních dvou tabulek.
Nejlépe si chování osvětlíme na dvou vstupních tabulkách, které mohou mít
rozdílný počet prvků (3 resp. 5 prvků). Výsledkem bude tabulka s&nbsp;celkem
patnácti prvky, kde každý prvek je dvojicí:</p>

<pre>
--------------------------------------------
first original array
foo, bar, baz
&nbsp;
second original array
1, 2, 3, 4, 5
&nbsp;
generated pairs
((foo 1) (foo 2) (foo 3) (foo 4) (foo 5) (bar 1) (bar 2) (bar 3) (bar 4) (bar 5) (baz 1) (baz 2) (baz 3) (baz 4) (baz 5))
</pre>

<p>Tento výsledek byl získán spuštěním následujícího demonstračního
příkladu:</p>

<pre>
<i>-- načtení knihovny Moses a současně import symbolů do globálního jmenného prostoru</i>
M = require "moses"
M.import()
&nbsp;
&nbsp;
<i>-- tisk obsahu pole</i>
<strong>function</strong> printArrayInLine(array)
    <i>-- test na prázdné pole</i>
    <strong>if</strong> #array == 0 <strong>then</strong>
        print("*empty*")
        <strong>return</strong>
    <strong>end</strong>
    <strong>for</strong> i, value <strong>in</strong> ipairs(array) <strong>do</strong>
        io.write(value)
        <strong>if</strong> i ~= #array <strong>then</strong>
            io.write(", ")
        <strong>end</strong>
    <strong>end</strong>
    print()
<strong>end</strong>
&nbsp;
&nbsp;
<i>-- získaní textové podoby obsahu pole obsahujícího další vnořená pole</i>
<strong>function</strong> nestedArray(array)
    <strong>if</strong> type(array) == 'table' <strong>then</strong>
        <i>-- použít LISPovské s-výrazy</i>
        <strong>local</strong> s = '('
        <strong>for</strong> i, v <strong>in</strong> ipairs(array) <strong>do</strong>
            <i>-- oddělovač</i>
            <strong>if</strong> i &gt; 1 <strong>then</strong>
                s = s .. ' '
            <strong>end</strong>
            <i>-- pole mohou být vnořena</i>
            s = s .. nestedArray(v)
        <strong>end</strong>
        <strong>return</strong> s .. ')'
    <strong>else</strong>
        <strong>return</strong> tostring(array)
    <strong>end</strong>
<strong>end</strong>
&nbsp;
&nbsp;
<i>-- oddělení obsahu</i>
<strong>function</strong> printSeparator()
    print("--------------------------------------------")
<strong>end</strong>
&nbsp;
&nbsp;
a = {"foo", "bar", "baz"}
b = range(5)
p = xprod(a, b)
&nbsp;
printSeparator()
print("first original array")
printArrayInLine(a)
print()
print("second original array")
printArrayInLine(b)
print()
print("generated pairs")
print(nestedArray(p))
</pre>

<p>V&nbsp;případě, že je jedno ze vstupních polí prázdné, bude prázdné i pole
výstupní, protože prvky druhého pole není možné zkombinovat s&nbsp;prvky
prázdného pole. O tom se ostatně můžeme velmi snadno přesvědčit:</p>

<pre>
a = range(100)
b = {}
p = xprod(a, b)
</pre>

<pre>
--------------------------------------------
first original array
1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31, 32, 33, 34, 35, 36, 37, 38, 39, 40, 41, 42, 43, 44, 45, 46, 47, 48, 49, 50, 51, 52, 53, 54, 55, 56, 57, 58, 59, 60, 61, 62, 63, 64, 65, 66, 67, 68, 69, 70, 71, 72, 73, 74, 75, 76, 77, 78, 79, 80, 81, 82, 83, 84, 85, 86, 87, 88, 89, 90, 91, 92, 93, 94, 95, 96, 97, 98, 99, 100
&nbsp;
second original array
*empty*
&nbsp;
generated pairs
()
</pre>

<p>Pokud nějaká tabulka obsahuje prvek s&nbsp;hodnotou <strong>nil</strong>, je
vytváření párů na tomto prvku zastaveno:</p>

<pre>
a = range(10)
b = {"a", "b", <strong>nil</strong>, "c"}
p = xprod(a, b)
&nbsp;
printSeparator()
print("first original array")
printArrayInLine(a)
print()
print("second original array")
printArrayInLine(b)
print()
print("generated pairs")
print(nestedArray(p))
</pre>

<p>S&nbsp;výsledky:</p>

<pre>
first original array
1, 2, 3, 4, 5, 6, 7, 8, 9, 10
&nbsp;
second original array
a, b, 
&nbsp;
generated pairs
((1 a) (1 b) (2 a) (2 b) (3 a) (3 b) (4 a) (4 b) (5 a) (5 b) (6 a) (6 b) (7 a) (7 b) (8 a) (8 b) (9 a) (9 b) (10 a) (10 b))
</pre>



<p><a name="k06"></a></p>
<h2 id="k06">6. Funkce <strong>reduce</strong> aplikovaná na tabulku</h2>

<p>Ve většině programovacích jazyků inspirovaných funkcionálním programováním
se, jak již ostatně víme z&nbsp;článku o knihovně <i>Lua Fun</i>, velmi často
setkáme i s&nbsp;funkcí nazvanou <strong>reduce</strong> nebo
<strong>fold</strong>, popř.&nbsp;s&nbsp;různými alternativami s&nbsp;podobnými
operacemi. Základní operací tohoto typu je funkce vyššího řádu nazvaná
<strong>reduce</strong>, která postupně zpracovává všechny prvky pole nebo
slovníku zleva doprava a aplikuje na každý prvek a akumulovanou hodnotu nějakou
funkci (a právě to tedy mj.&nbsp;znamená, že <strong>reduce</strong> je funkcí
vyššího řádu). Výsledkem je v&nbsp;každé iteraci nová hodnota akumulátoru a po
projití celé vstupní sekvence je výsledná hodnota uložená v&nbsp;akumulátoru
současně i návratovou hodnotou funkce. Tuto funkci můžeme využít například při
výpočtu faktoriálu, protože při výpočtu faktoriálu nějakého <i>n</i> postačuje
pomocí <strong>range</strong> vytvořit pole o <i>n</i> prvcích a posléze jeho
prvky postupně pronásobit. Implementace založená na pojmenované (neanonymní)
funkci může vypadat následovně:</p>

<pre>
<i>-- načtení knihovny Moses a současně import symbolů do globálního jmenného prostoru</i>
M = require "moses"
M.import()
&nbsp;
&nbsp;
<i>-- pomocná funkce pro součin jejích dvou parametrů</i>
<strong>function</strong> multiply(x, y)
    <strong>return</strong> x * y
<strong>end</strong>
&nbsp;
&nbsp;
<i>-- výpočet faktoriálu vstupních hodnot 0 až 10</i>
<strong>for</strong> n = 0, 10 <strong>do</strong>
    <i>-- konstrukce pole</i>
    a = range(1, n)
    <i>-- výpočet produktu hodnot 1..n == n!</i>
    prod = reduce(a, multiply)
    <i>-- tisk produktu hodnot 1..n == n!</i>
    print(n, prod)
<strong>end</strong>
</pre>

<p>Výsledná tabulka vytištěná demonstračním příkladem:</p>

<pre>
0       0
1       1
2       2
3       6
4       24
5       120
6       720
7       5040
8       40320
9       362880
10      3628800
</pre>

<p>Totéž ovšem můžeme provést i bez nutnosti explicitně pojmenovat funkci
<strong>multiply</strong>; použijeme namísto toho funkci anonymní:</p>

<pre>
<i>-- načtení knihovny Moses a současně import symbolů do globálního jmenného prostoru</i>
M = require "moses"
M.import()
&nbsp;
&nbsp;
<i>-- výpočet faktoriálu vstupních hodnot 0 až 10</i>
<strong>for</strong> n = 0, 10 <strong>do</strong>
    <i>-- konstrukce pole</i>
    a = range(1, n)
    <i>-- výpočet produktu hodnot 1..n == n!</i>
    <i>-- (použila se anonymní funkce)</i>
    prod = reduce(a, <strong>function</strong> (x, y) <strong>return</strong> x * y <strong>end</strong>)
    <i>-- tisk produktu hodnot 1..n == n!</i>
    print(n, prod)
<strong>end</strong>
</pre>

<p>Výsledky budou totožné:</p>

<pre>
0       0
1       1
2       2
3       6
4       24
5       120
6       720
7       5040
8       40320
9       362880
10      3628800
</pre>

<p>Třetí příklad ukazuje způsob spojení všech prvků v&nbsp;poli do jediného
řetězce, tedy o variantu na funkci typu <strong>join</strong>:</p>

<pre>
<i>-- načtení knihovny Moses a současně import symbolů do globálního jmenného prostoru</i>
M = require "moses"
M.import()
&nbsp;
&nbsp;
<i>-- vstupní pole</i>
a = {"foo", "bar", "baz"}
&nbsp;
<i>-- postupné zpracování prvků pole zleva s akumulací výsledku</i>
print(reduce(a, function (x, y) return x .. " " .. y end))
</pre>

<p>Po spuštění tohoto příkladu by se měl zobrazit jediný řetězec tvořený třemi
slovy:</p>

<pre>
foo bar baz
</pre>



<p><a name="k07"></a></p>
<h2 id="k07">7. Zpracování prvků tabulky v&nbsp;opačném směru funkcí <strong>reduceRight</strong></h2>

<p>Funkce <strong>reduce</strong> popsaná <a href="#k06">v&nbsp;předchozí
kapitole</a> zpracovávala prvky pole nebo slovníku (s&nbsp;akumulací
mezivýsledků) od začátku pole/slovníku směrem k&nbsp;jeho konci. Proto je
taktéž tato funkce známá pod jménem <strong>foldl</strong>, kde &bdquo;l&ldquo;
značí &bdquo;from left&ldquo;. V&nbsp;některých případech je však nutné
sekvenci prvků zpracovávat od prvku posledního směrem k&nbsp;prvku prvnímu (i
když u klasických sekvencí se jedná o nepřirozenou a mnohdy ani nepodporovanou
operaci &ndash; speciálně to platí pro nekonečné sekvence vytvářené nějakým
generátorem). Funkce provádějící tuto operaci se nazývá <strong>foldr</strong>
nebo taktéž <strong>reduceRight</strong>. V&nbsp;dalším demonstračním příkladu
je ukázáno, jak se tyto dvě funkce (<strong>reduce</strong> a
<strong>reduceRight</strong>) od sebe odlišují při zpracování pole obsahujícího
celočíselné prvky s&nbsp;hodnotami 1 až 10. Prvky postupně čteme zprava či
zleva, převádíme na řetězec a spojujeme do většího řetězce:</p>

<pre>
<i>-- načtení knihovny Moses a současně import symbolů do globálního jmenného prostoru</i>
M = require "moses"
M.import()
&nbsp;
&nbsp;
<i>-- vstupní pole</i>
a = range(10)
&nbsp;
<i>-- postupné zpracování prvků pole zleva s akumulací výsledku</i>
print("reduceleft")
print(reduce(a, function (x, y) return tostring(x) .. " " .. tostring(y) end))
&nbsp;
print()
&nbsp;
<i>-- postupné zpracování prvků pole zprava s akumulací výsledku</i>
print("reduceright")
print(reduceright(a, function (x, y) return tostring(x) .. " " .. tostring(y) end))
</pre>

<p>Výsledky získané po spuštění tohoto demonstračního příkladu. Můžeme na nich
vidět, že se prvky skutečně zpracovávaly odlišným způsobem:</p>

<pre>
reduceLeft
1 2 3 4 5 6 7 8 9 10
&nbsp;
reduceRight
10 9 8 7 6 5 4 3 2 1
</pre>

<p><div class="rs-tip-major">Poznámka: ve skutečnosti není nutné používat
funkci <strong>tostring</strong> v&nbsp;případě, že prvky pole jsou celá čísla.
Konverze čísla na řetězec se v&nbsp;tomto případě (logicky) provede
automaticky. A protože Lua rozlišuje mezi operátorem &bdquo;+&ldquo; a
&bdquo;..&ldquo;, nedochází k&nbsp;nejasnostem, jaká operace se vlastně
provádí:</div></p>

<pre>
<i>-- postupné zpracování prvků pole zleva s akumulací výsledku</i>
print("reduceleft")
print(reduce(a, function (x, y) return x .. " " .. y end))
&nbsp;
print()
&nbsp;
<i>-- postupné zpracování prvků pole zprava s akumulací výsledku</i>
print("reduceright")
print(reduceright(a, function (x, y) return x .. " " .. y end))
</pre>



<p><a name="k08"></a></p>
<h2 id="k08">8. Rozdělení tabulky funkcí vyššího řádu <strong>groupBy</strong></h2>

<p></p>

<pre>
<i>-- načtení knihovny Moses a současně import symbolů do globálního jmenného prostoru</i>
M = require "moses"
M.import()


<i>-- tisk obsahu pole</i>
<strong>function</strong> printArrayInLine(array)
    -- test na prázdné pole
    <strong>if</strong> #array == 0 then
        print("*empty*")
        return
    <strong>end</strong>
    <strong>for</strong> i, value in ipairs(array) do
        io.write(value)
        if i ~= #array then
            io.write(", ")
        end
    <strong>end</strong>
    print()
<strong>end</strong>

<i>-- tisk tabulky, jejíž prvky tvoří pole</i>
<strong>function</strong> printTable(table)
    <strong>for</strong> key, values in pairs(table) do
        -- tisk klíče
        io.write(key .. ":\t")
        -- tisk hodnot
        printArrayInLine(values)
    <strong>end</strong>
<strong>end</strong>

<i>-- oddělení obsahu</i>
<strong>function</strong> printSeparator()
    print("--------------------------------------------")
<strong>end</strong>


<i>-- pomocná funkce, která na základě hodnoty prvku vrátí návěští</i>
<strong>function</strong> labelItem(x)
    <strong>if</strong> x % 2 == 0 then
        return "even"
    <strong>else</strong>
        return "odd"
    <strong>end</strong>
<strong>end</strong>


<i>-- původní sekvence</i>
a = range(10)

<i>-- tisk původní sekvence</i>
printSeparator()
print("original array")
printArrayInLine(a)
print()

<i>-- rozdělení prvků v sekvenci podle návěští sudá/lichá</i>
g = groupBy(a, labelItem)

<i>-- tisk prvků rozdělených do skupin</i>
printSeparator()
print("groupedBy odd/even")
printTable(g)
</pre>

<p></p>

<pre>
--------------------------------------------
original array
1, 2, 3, 4, 5, 6, 7, 8, 9, 10

--------------------------------------------
groupedBy odd/even
even:   2, 4, 6, 8, 10
odd:    1, 3, 5, 7, 9
</pre>

<pre>
<i>-- načtení knihovny Moses a současně import symbolů do globálního jmenného prostoru</i>
M = require "moses"
M.import()


<i>-- tisk obsahu pole</i>
<strong>function</strong> printArrayInLine(array)
    -- test na prázdné pole
    <strong>if</strong> #array == 0 then
        print("*empty*")
        return
    <strong>end</strong>
    <strong>for</strong> i, value in ipairs(array) do
        io.write(tostring(value))
        if i ~= #array then
            io.write(", ")
        end
    <strong>end</strong>
    print()
<strong>end</strong>

<i>-- tisk tabulky, jejíž prvky tvoří pole</i>
<strong>function</strong> printTable(table)
    <strong>for</strong> key, values in pairs(table) do
        -- tisk klíče
        io.write(key .. ":\t")
        -- tisk hodnot
        printArrayInLine(values)
    <strong>end</strong>
<strong>end</strong>

<i>-- oddělení obsahu</i>
<strong>function</strong> printSeparator()
    print("--------------------------------------------")
<strong>end</strong>


<i>-- původní sekvence</i>
a = {1, 2, 3, 4, "a", "b", "c", nil, true, false, 42, function () end, print}

<i>-- tisk původní sekvence</i>
printSeparator()
print("original array")
printArrayInLine(a)
print()

<i>-- rozdělení prvků v sekvenci podle jejich typu</i>
g = groupBy(a, type)

<i>-- tisk prvků rozdělených do skupin podle jejich typu</i>
printSeparator()
print("groupedBy type")
printTable(g)
</pre>

<pre>
--------------------------------------------
original array
1, 2, 3, 4, a, b, c, 

--------------------------------------------
groupedBy type
boolean:        true, false
string: a, b, c
number: 1, 2, 3, 4, 42
<strong>function</strong>:       function: 0x558e68e62e30, function: 0x7f9bfb7316b0
</pre>



<p><a name="k09"></a></p>
<h2 id="k09">9. Iterace prvky tabulky pomocí funkcí <strong>each</strong></h2>

<p></p>

<pre>
<i>-- načtení knihovny Moses a současně import symbolů do globálního jmenného prostoru</i>
M = require "moses"
M.import()


<i>-- tisk tabulky, jejíž prvky tvoří pole</i>
<strong>function</strong> printTable(table)
    <strong>for</strong> key, values in pairs(table) do
        -- tisk klíče
        io.write(key .. ":\t")
        -- tisk hodnot
        each(values, function (value) io.write(tostring(value) .. " ") end)
        print()
    <strong>end</strong>
<strong>end</strong>

<i>-- oddělení obsahu</i>
<strong>function</strong> printSeparator()
    print("--------------------------------------------")
<strong>end</strong>


<i>-- původní sekvence</i>
a = {1, 2, 3, 4, "a", "b", "c", nil, true, false, 42, function () end, print}

<i>-- tisk původní sekvence funkcí each</i>
printSeparator()
print("original array")
each(a, function(value, index) print(value) end)
print()

<i>-- rozdělení prvků v sekvenci podle jejich typu</i>
g = groupBy(a, type)

<i>-- tisk prvků rozdělených do skupin podle jejich typu</i>
printSeparator()
print("groupedBy type")
printTable(g)
</pre>

<p></p>

<pre>
--------------------------------------------
original array
1
2
3
4
a
b
c
true
false
42
function: 0x55603df42e00
function: 0x7fa6a6f706b0

--------------------------------------------
groupedBy type
number: 1 2 3 4 42 
string: a b c 
function:       function: 0x55603df42e00 function: 0x7fa6a6f706b0 
boolean:        true false 
</pre>

<pre>
<i>-- načtení knihovny Moses a současně import symbolů do globálního jmenného prostoru</i>
M = require "moses"
M.import()


<i>-- tisk tabulky, jejíž prvky tvoří pole</i>
<strong>function</strong> printTable(table)
    -- tisk prvků tabulky pomocí funkce each
    each(table, function(values, key)
            -- tisk klíče
            io.write(key .. ":\t")
            -- tisk hodnot
            each(values, function (value) io.write(tostring(value) .. " ") end)
            print()
        end
    )
<strong>end</strong>

<i>-- oddělení obsahu</i>
<strong>function</strong> printSeparator()
    print("--------------------------------------------")
<strong>end</strong>


<i>-- původní sekvence</i>
a = {1, 2, 3, 4, "a", "b", "c", nil, true, false, 42, function () end, print}

<i>-- tisk původní sekvence funkcí each</i>
printSeparator()
print("original array")
each(a, function(value, index) print(value) end)
print()

<i>-- rozdělení prvků v sekvenci podle jejich typu</i>
g = groupBy(a, type)

printSeparator()
print("groupedBy type")
printTable(g)
</pre>

<pre>
--------------------------------------------
original array
1
2
3
4
a
b
c
true
false
42
function: 0x5590b5e69e00
function: 0x7fe95625b6b0

--------------------------------------------
groupedBy type
number: 1 2 3 4 42 
boolean:        true false 
string: a b c 
function:       function: 0x5590b5e69e00 function: 0x7fe95625b6b0 
</pre>



<p><a name="k10"></a></p>
<h2 id="k10">10. Rozdíl mezi funkcemi <strong>each</strong> a <strong>eachi</strong></h2>

<p></p>

<pre>
<i>-- načtení knihovny Moses a současně import symbolů do globálního jmenného prostoru</i>
M = require "moses"
M.import()


<i>-- tisk tabulky, jejíž prvky tvoří pole</i>
<strong>function</strong> printTable(table)
    -- tisk prvků tabulky funkcí each
    each(table, function(values, key)
            -- tisk klíče
            io.write(key .. ":\t")
            -- tisk hodnot
            eachi(values, function (value) io.write(tostring(value) .. " ") end)
            print()
        end
    )
<strong>end</strong>

<i>-- oddělení obsahu</i>
<strong>function</strong> printSeparator()
    print("--------------------------------------------")
<strong>end</strong>


<i>-- původní sekvence</i>
a = {1, 2, 3, 4, "a", "b", "c", nil, true, false, 42, function () end, print}

<i>-- tisk původní sekvence funkcí eachi</i>
printSeparator()
print("original array")
eachi(a, function(value, index) print(value) end)
print()

<i>-- rozdělení prvků v sekvenci podle jejich typu</i>
g = groupBy(a, type)

printSeparator()
print("groupedBy type")
printTable(g)
</pre>

<p></p>

<pre>
--------------------------------------------
original array
1
2
3
4
a
b
c
true
false
42
function: 0x5620cc0b2e00
function: 0x7efffb42e6b0

--------------------------------------------
groupedBy type
function:       function: 0x5620cc0b2e00 function: 0x7efffb42e6b0 
number: 1 2 3 4 42 
boolean:        true false 
string: a b c 
</pre>

<pre>
<i>-- načtení knihovny Moses a současně import symbolů do globálního jmenného prostoru</i>
M = require "moses"
M.import()


<i>-- tisk tabulky, jejíž prvky tvoří pole</i>
<strong>function</strong> printTable(table)
    -- tisk tabulky funkcí eachi
    eachi(table, function(values, key)
            -- tisk klíče
            io.write(key .. ":\t")
            -- tisk hodnot
            eachi(values, function (value) io.write(tostring(value) .. " ") end)
            print()
        end
    )
<strong>end</strong>

<i>-- oddělení obsahu</i>
<strong>function</strong> printSeparator()
    print("--------------------------------------------")
<strong>end</strong>


<i>-- původní sekvence</i>
a = {1, 2, 3, 4, "a", "b", "c", nil, true, false, 42, function () end, print}

<i>-- tisk původní sekvence funkcí eachi</i>
printSeparator()
print("original array")
eachi(a, function(value, index) print(value) end)
print()

<i>-- rozdělení prvků v sekvenci podle jejich typu</i>
g = groupBy(a, type)

printSeparator()
print("groupedBy type")
printTable(g)
</pre>

<pre>
--------------------------------------------
original array
1
2
3
4
a
b
c
true
false
42
function: 0x55ea586d1e00
function: 0x7f31fea176b0

--------------------------------------------
groupedBy type
</pre>



<p><a name="k11"></a></p>
<h2 id="k11">11. Další funkce vyššího řádu procházející tabulkou: <strong>map</strong></h2>

<p>Funkci vyššího řádu <strong>map</strong> již poměrně dobře známe
z&nbsp;knihovny <i>Lua Fun</i>, takže si bez dalších složitějších popisů ukažme
způsob jejího použití. Nejprve aplikujeme tuto funkci na tabulku s&nbsp;více
sekvencemi celočíselných hodnot s&nbsp;aplikací funkce
<strong>product</strong>, která každou sekvenci nahradí součinem prvků:</p>

<pre>
<i>-- načtení knihovny Moses a současně import symbolů do globálního jmenného prostoru</i>
M = require "moses"
M.import()
&nbsp;
&nbsp;
<i>-- výpočet faktoriálu vstupních hodnot 1 až 10</i>
n = range(1, 10)
&nbsp;
<i>-- pomocné pole se sekvencí</i>
r = map(n, <strong>function</strong> (n) <strong>return</strong> range(1, n) <strong>end</strong>)
&nbsp;
<i>-- výpočet produktu hodnot 1..n == n!</i>
f = map(r, product)
&nbsp;
<i>-- tisk výsledků funkcí each</i>
each(f, <strong>function</strong>(x,y) print(y,x) <strong>end</strong>)
</pre>

<p>Výsledkem je (opět) tabulka faktoriálů hodnot:</p>

<pre>
1       1
2       2
3       6
4       24
5       120
6       720
7       5040
8       40320
9       362880
10      3628800
</pre>

<p>Pokud vás zajímá, jak se k&nbsp;výsledku došlo, je možné si nechat zobrazit
tabulky s&nbsp;mezivýsledky (tj.&nbsp;s&nbsp;vlastními sekvencemi hodnot):</p>

<pre>
<i>-- načtení knihovny Moses a současně import symbolů do globálního jmenného prostoru</i>
M = require "moses"
M.import()
&nbsp;
<i>-- tisk obsahu pole</i>
<strong>function</strong> printArrayInLine(array)
    <i>-- test na prázdné pole</i>
    <strong>if</strong> #array == 0 <strong>then</strong>
        print("*empty*")
        <strong>return</strong>
    <strong>end</strong>
    <strong>for</strong> i, value <strong>in</strong> ipairs(array) <strong>do</strong>
        io.write(value)
        <strong>if</strong> i ~= #array <strong>then</strong>
            io.write(", ")
        <strong>end</strong>
    <strong>end</strong>
    print()
<strong>end</strong>
&nbsp;
&nbsp;
<i>-- výpočet faktoriálu vstupních hodnot 1 až 10</i>
n = range(1, 10)
&nbsp;
<i>-- pomocné pole se sekvencí</i>
r = map(n, <strong>function</strong> (n) <strong>return</strong> range(1, n) <strong>end</strong>)
&nbsp;
<i>-- tisk tabulky tabulek pro ladicí účely</i>
each(r, printArrayInLine)
&nbsp;
<i>-- výpočet produktu hodnot 1..n == n!</i>
f = map(r, product)
&nbsp;
<i>-- tisk výsledků funkcí each</i>
each(f, <strong>function</strong>(x,y) print(y,x) <strong>end</strong>)
</pre>

<p>Nyní se po spuštění takto upraveného příkladu zobrazí i všechny
mezivýsledky:</p>

<pre>
1
1, 2
1, 2, 3
1, 2, 3, 4
1, 2, 3, 4, 5
1, 2, 3, 4, 5, 6
1, 2, 3, 4, 5, 6, 7
1, 2, 3, 4, 5, 6, 7, 8
1, 2, 3, 4, 5, 6, 7, 8, 9
1, 2, 3, 4, 5, 6, 7, 8, 9, 10
1       1
2       2
3       6
4       24
5       120
6       720
7       5040
8       40320
9       362880
10      3628800
</pre>



<p><a name="k12"></a></p>
<h2 id="k12">12. Zřetězení operací nad tabulkou s&nbsp;využitím <strong>chain</strong></h2>

<p>Nyní již nastal správný okamžik pro popis zřetězení většího množství operací
nad tabulkou. Mnohdy se totiž s&nbsp;obsahem tabulky postupně provádí větší
množství operací &ndash; mapování funkce, redukce, filtrace, otočení prvků,
další filtrace prvků atd. A tyto operace je možné zapsat buď tak, že se hodnoty
postupně předávají do dalších funkcí:</p>

<pre>
a1 = reverse(range(10))
</pre>

<p>popř.:</p>

<pre>
a2 = reverse(filter(range(10), function (x) return x%2==0 end))
</pre>

<p>Ovšem to není příliš čitelné. Výhodnější je použít přístup známý
z&nbsp;mnoha programovacích jazyků podporujících datové <i>streamy</i>,
tj.&nbsp;použití zřetězení. To má v&nbsp;případě knihovny <i>Moses</i>
následující podobu:</p>

<pre>
<i>-- první pole začínající standardně od jedničky</i>
<i>-- je ihned po konstrukci otočeno</i>
a1 = M.chain(range(10)):reverse():value()
</pre>

<p>popř.&nbsp;pro tři operace (včetně filtrace):</p>

<pre>
<i>-- nyní zkusíme zřetězit více operací</i>
a2 = M.chain(range(10)):filter(function (x) return x%2==0 end):reverse():value()
</pre>

<p>Z&nbsp;obou zápisů je patrné, že zřetězení začíná voláním M.chain() a že se
jedná o metodu (i ostatní volání jsou metodami, tj.&nbsp;explicitně se neuvádí
jejich první parametr <strong>self</strong>). Úplný zdrojový kód demonstračního
příkladu s&nbsp;dvojicí zřetězení vypadá následovně:</p>

<pre>
<i>-- načtení knihovny Moses a současně import symbolů do globálního jmenného prostoru</i>
M = require "moses"
M.import()
&nbsp;
&nbsp;
<i>-- tisk obsahu pole</i>
<strong>function</strong> printArray(array)
    <strong>for</strong> index, value in ipairs(array) do
        print(index, value)
    <strong>end</strong>
<strong>end</strong>
&nbsp;
&nbsp;
<i>-- oddělení obsahu</i>
<strong>function</strong> printSeparator()
    print("-------------------------------")
end
&nbsp;
&nbsp;
<i>-- první pole začínající standardně od jedničky</i>
<i>-- je ihned po konstrukci otočeno</i>
a1 = M.chain(range(10)):reverse():value()
printSeparator()
print("reverse(range(10))")
printArray(a1)
&nbsp;
&nbsp;
<i>-- nyní zkusíme zřetězit více operací</i>
a2 = M.chain(range(10)):filter(function (x) return x%2==0 end):reverse():value()
printSeparator()
print("reverse(filter(range(10)))")
printArray(a2)
</pre>

<p>A vypsané výsledky:</p>

<pre>
-------------------------------
reverse(range(10))
1       10
2       9
3       8
4       7
5       6
6       5
7       4
8       3
9       2
10      1
-------------------------------
reverse(filter(range(10)))
1       10
2       8
3       6
4       4
5       2
</pre>

<p><div class="rs-tip-major">Poznámka: metoda <strong>value()</strong> převede
objekt zpět na běžnou tabulku.</div></p>



<p><a name="k13"></a></p>
<h2 id="k13">13. Složitější příklady zřetězení operací</h2>

<p>Nyní, když již známe způsob zajištění zřetězení operací, se můžeme pokusit o
zápis výpočtu tabulky faktoriálů hodnot 1 až 10 na dva řádky. První řádek
zajistí:</p>

<ol>
<li>Vygenerování vstupů 1 až 10</li>
<li>Vytvoření rozsahu (<i>range</i>) pro každý vstup 1 až 10</li>
<li>Výpočet produktu (součinu) všech hodnot rozsahu</li>
<li>Převod výsledků zpět na běžné pole</li>
</ol>

<p>Druhý programový řádek již jen použije funkci <strong>each</strong> pro tisk
obsahu pole na standardní výstup (s&nbsp;tím, že index současně odpovídá
vstupní hodnotě <i>n</i>):</p>

<pre>
<i>-- načtení knihovny Moses a současně import symbolů do globálního jmenného prostoru</i>
M = require "moses"
M.import()
&nbsp;
&nbsp;
<i>-- výpočet faktoriálu vstupních hodnot 1 až 10</i>
fact = M.chain(range(1, 10)):map(<strong>function</strong> (n) <strong>return</strong> range(1, n) <strong>end</strong>):map(product):value()
each(fact, function(x,y) print(y,x) end)
</pre>

<p>Výsledkem je skutečně tabulka faktoriálů:</p>

<pre>
1       1
2       2
3       6
4       24
5       120
6       720
7       5040
8       40320
9       362880
10      3628800
</pre>

<p>Ovšem nic nám nezabrání zapsat celý výpočet na jediný řádek, protože i
volání funkce vyššího řádu <strong>each</strong> může být zřetězeno. Zde ovšem
již nemusíme na konci volat metodu <strong>value()</strong>, protože žádné
výsledné pole nepotřebujeme (jeho obsah již byl vypsán):</p>

<pre>
<i>-- načtení knihovny Moses a současně import symbolů do globálního jmenného prostoru</i>
M = require "moses"
M.import()
&nbsp;
&nbsp;
<i>-- výpočet faktoriálu vstupních hodnot 1 až 10</i>
fact = M.chain(range(1, 10)):map(<strong>function</strong> (n) <strong>return</strong> range(1, n) <strong>end</strong>):map(product):each(function(x,y) print(y,x) end)
</pre>

<p>Tabulka s&nbsp;výsledky by měla vypadat stejně, jako v&nbsp;předchozím
případě:</p>

<pre>
1	1
2	2
3	6
4	24
5	120
6	720
7	5040
8	40320
9	362880
10	3628800
</pre>



<p><a name="k14"></a></p>
<h2 id="k14">14. Funkce vyššího řádu <strong>mapReduce</strong></h2>

<p></p>

<pre>
<i>-- načtení knihovny Moses a současně import symbolů do globálního jmenného prostoru</i>
M = require "moses"
M.import()


<i>-- konstrukce pole</i>
a = range(1, 10)

<i>-- výpočet produktu hodnot 1..n == n! s uložením všech mezivýsledků</i>
<i>-- (použila se anonymní funkce)</i>
prod = mapReduce(a, function (x, y) return x * y end)

<i>-- tisk produktu hodnot 1..n == n!</i>
each(prod, function(x,y) print(y,x) end)
</pre>

<p></p>

<pre>
1	1
2	2
3	6
4	24
5	120
6	720
7	5040
8	40320
9	362880
10	3628800
</pre>



<p><a name="k15"></a></p>
<h2 id="k15">15. Rozdíl mezi funkcemi <strong>mapReduce</strong> a <strong>mapReduceRight</strong></h2>

<pre>
<i>-- načtení knihovny Moses a současně import symbolů do globálního jmenného prostoru</i>
M = require "moses"
M.import()


<i>-- načtení knihovny Moses a současně import symbolů do globálního jmenného prostoru</i>
M = require "moses"
M.import()


<i>-- konstrukce pole</i>
a = range(1, 10)

<i>-- výpočet produktu hodnot 1..n == n! s uložením všech mezivýsledků</i>
<i>-- (použila se anonymní funkce)</i>
prod = mapReduceRight(a, function (x, y) return x * y end)

<i>-- tisk produktu hodnot 1..n == n!</i>
each(prod, function(x,y) print(y,x) end)
</pre>

<pre>
1       10
2       90
3       720
4       5040
5       30240
6       151200
7       604800
8       1814400
9       3628800
10      3628800
</pre>



<p><a name="k16"></a></p>
<h2 id="k16">16. Iterace prvky tabulky funkcemi <strong>sortedk</strong> a <strong>sortedv</strong></h2>

<p></p>

<pre>
</pre>

<p></p>

<pre>
</pre>



<p><a name="k17"></a></p>
<h2 id="k17">17. Obsah závěrečného článku o knihovně Moses</h2>

<p>Knihovna <i>Moses</i> obsahuje mnohem větší množství funkcionality než již
dříve popsaná knihovna <i>Lua Fun</i>. Z&nbsp;tohoto důvodu se knihovně
<i>Moses</i> budeme věnovat ještě v&nbsp;jednom článku. Popíšeme si především
dvě zajímavé funkcionální techniky nazvané <i>memoization</i> a <i>currying</i>
(poslední technika byla pojmenována podle Haskella Curryho, jehož jméno není ve
funkcionálním světě neznámé). Taktéž se zmíníme u funkcích typu
&bdquo;path&ldquo;, které umožňují získat data z&nbsp;vnořených tabulek. Může
se jednat například o deserializovaná data získaná z&nbsp;formátů XML, JSON či
EDN. Tyto funkce, konkrétně se jedná o funkce <strong>path</strong>,
<strong>spreadPath</strong> a <strong>flattenPath</strong>, částečně vychází
z&nbsp;technologie XPath, ovšem jsou pojaty uživatelsky přívětivějším způsobem
(minimálně pro vývojáře, kteří XPath a jeho DSL neznají či aktivně
nepoužívají).</p>



<p><a name="k18"></a></p>
<h2 id="k18">18. Repositář s&nbsp;demonstračními příklady</h2>

<p>Zdrojové kódy všech dnes použitých demonstračních příkladů byly uloženy do
nového Git repositáře, který je dostupný na adrese <a
href="https://github.com/tisnik/functional-lua">https://github.com/tisnik/functional-lua</a>
(jedná se o podadresář <a
href="https://github.com/tisnik/functional-lua/tree/master/moses/">moses/</a>).
V&nbsp;případě, že nebudete chtít klonovat celý repositář (ten je ovšem &ndash;
alespoň prozatím &ndash; velmi malý, dnes má přibližně několik jednotek
kilobajtů), můžete namísto toho použít odkazy na jednotlivé demonstrační
příklady a jejich části, které naleznete v&nbsp;následující tabulce:</p>

<table>
<tr><th> #</th><th>Příklad</th><th>Stručný popis</th><th>Cesta</th></tr>
<tr><td> 1</td><td>21_sum_prod.lua</td><td>výpočet součtu a součinu prvků pole</td><td><a href="https://github.com/tisnik/functional-lua/tree/master/moses/21_sum_prod.lua">https://github.com/tisnik/functional-lua/tree/master/moses/21_sum_prod.lua</a></td></tr>
<tr><td> 2</td><td>22_sum_prod_empty_array.lua</td><td>výpočet součtu a součinu prvků prázdného pole</td><td><a href="https://github.com/tisnik/functional-lua/tree/master/moses/22_sum_prod_empty_array.lua">https://github.com/tisnik/functional-lua/tree/master/moses/22_sum_prod_empty_array.lua</a></td></tr>
<tr><td> 3</td><td>23_factorial.lua</td><td>zobrazení faktoriálu vstupních hodnot 1..10</td><td><a href="https://github.com/tisnik/functional-lua/tree/master/moses/23_factorial.lua">https://github.com/tisnik/functional-lua/tree/master/moses/23_factorial.lua</a></td></tr>
<tr><td> 4</td><td>24_mean_median_min_max.lua</td><td>výpočet průměru, mediánu, minimální a maximální hodnoty</td><td><a href="https://github.com/tisnik/functional-lua/tree/master/moses/24_mean_median_min_max.lua">https://github.com/tisnik/functional-lua/tree/master/moses/24_mean_median_min_max.lua</a></td></tr>
<tr><td> 5</td><td>25_mean_median_min_max.lua</td><td>výpočet průměru, mediánu, minimální a maximální hodnoty</td><td><a href="https://github.com/tisnik/functional-lua/tree/master/moses/25_mean_median_min_max.lua">https://github.com/tisnik/functional-lua/tree/master/moses/25_mean_median_min_max.lua</a></td></tr>
<tr><td> 6</td><td>26_mean_median_min_max_zeros.lua</td><td>výpočet průměru, mediánu, minimální a maximální hodnoty prázdného pole</td><td><a href="https://github.com/tisnik/functional-lua/tree/master/moses/26_mean_median_min_max_zeros.lua">https://github.com/tisnik/functional-lua/tree/master/moses/26_mean_median_min_max_zeros.lua</a></td></tr>
<tr><td> 7</td><td>27_flatten.lua</td><td>&bdquo;zploštění&ldquo; pole na všech úrovních</td><td><a href="https://github.com/tisnik/functional-lua/tree/master/moses/27_flatten.lua">https://github.com/tisnik/functional-lua/tree/master/moses/27_flatten.lua</a></td></tr>
<tr><td> 8</td><td>28_flatten_shallow.lua</td><td>první iterace &bdquo;zploštění&ldquo; pole</td><td><a href="https://github.com/tisnik/functional-lua/tree/master/moses/28_flatten_shallow.lua">https://github.com/tisnik/functional-lua/tree/master/moses/28_flatten_shallow.lua</a></td></tr>
<tr><td> 9</td><td>29_flatten_steps.lua</td><td>postupné iterace zploštění pole</td><td><a href="https://github.com/tisnik/functional-lua/tree/master/moses/29_flatten_steps.lua">https://github.com/tisnik/functional-lua/tree/master/moses/29_flatten_steps.lua</a></td></tr>
<tr><td>10</td><td>30_compact.lua</td><td>odstranění prvků <strong>false</strong> a <strong>nil</strong> ze vstupního pole</td><td><a href="https://github.com/tisnik/functional-lua/tree/master/moses/30_compact.lua">https://github.com/tisnik/functional-lua/tree/master/moses/30_compact.lua</a></td></tr>
<tr><td>11</td><td>31_xprod.lua</td><td>vytvoření tabulky se všemi kombinacemi prvků ze vstupních polí</td><td><a href="https://github.com/tisnik/functional-lua/tree/master/moses/31_xprod.lua">https://github.com/tisnik/functional-lua/tree/master/moses/31_xprod.lua</a></td></tr>
<tr><td>12</td><td>32_xprod_empty_array.lua</td><td>vytvoření tabulky se všemi kombinacemi prvků ze vstupních polí, jedno z&nbsp;polí je prázdné</td><td><a href="https://github.com/tisnik/functional-lua/tree/master/moses/32_xprod_empty_array.lua">https://github.com/tisnik/functional-lua/tree/master/moses/32_xprod_empty_array.lua</a></td></tr>
<tr><td>13</td><td>33_reduce.lua</td><td>procházení tabulkou s&nbsp;akumulací výsledků</td><td><a href="https://github.com/tisnik/functional-lua/tree/master/moses/33_reduce.lua">https://github.com/tisnik/functional-lua/tree/master/moses/33_reduce.lua</a></td></tr>
<tr><td>14</td><td>34_reduce_anonymous_function.lua</td><td>podobný příklad, ovšem založený na anonymní funkci</td><td><a href="https://github.com/tisnik/functional-lua/tree/master/moses/34_reduce_anonymous_function.lua">https://github.com/tisnik/functional-lua/tree/master/moses/34_reduce_anonymous_function.lua</a></td></tr>
<tr><td>15</td><td>35_reduce_concat.lua</td><td>spojení všech prvků do jediného řetězce</td><td><a href="https://github.com/tisnik/functional-lua/tree/master/moses/35_reduce_concat.lua">https://github.com/tisnik/functional-lua/tree/master/moses/35_reduce_concat.lua</a></td></tr>
<tr><td>16</td><td>36_reduce_right.lua</td><td>rozdíl mezi funkcemi <strong>reduce</strong> a <strong>reduceRight</strong></td><td><a href="https://github.com/tisnik/functional-lua/tree/master/moses/36_reduce_right.lua">https://github.com/tisnik/functional-lua/tree/master/moses/36_reduce_right.lua</a></td></tr>
<tr><td>17</td><td>37_group_by.lua</td><td>rozdělení prvků tabulky do skupin na základě kritéria</td><td><a href="https://github.com/tisnik/functional-lua/tree/master/moses/37_group_by.lua">https://github.com/tisnik/functional-lua/tree/master/moses/37_group_by.lua</a></td></tr>
<tr><td>18</td><td>38_group_by_type.lua</td><td>rozdělení prvků tabulky do skupin na základě jejich typu</td><td><a href="https://github.com/tisnik/functional-lua/tree/master/moses/38_group_by_type.lua">https://github.com/tisnik/functional-lua/tree/master/moses/38_group_by_type.lua</a></td></tr>
<tr><td>19</td><td>39_each.lua</td><td>Iterace nad prvky tabulky funkcí <strong>each</strong></td><td><a href="https://github.com/tisnik/functional-lua/tree/master/moses/39_each.lua">https://github.com/tisnik/functional-lua/tree/master/moses/39_each.lua</a></td></tr>
<tr><td>20</td><td>40_each_no_loops.lua</td><td>Náhrada programových smyček za funkci <strong>each</strong></td><td><a href="https://github.com/tisnik/functional-lua/tree/master/moses/40_each_no_loops.lua">https://github.com/tisnik/functional-lua/tree/master/moses/40_each_no_loops.lua</a></td></tr>
<tr><td>21</td><td>41_eachi.lua</td><td>Rozdíly mezi funkcemi <strong>each</strong> a <strong>eachi</strong></td><td><a href="https://github.com/tisnik/functional-lua/tree/master/moses/41_eachi.lua">https://github.com/tisnik/functional-lua/tree/master/moses/41_eachi.lua</a></td></tr>
<tr><td>22</td><td>42_eachi_bad_usage.lua</td><td>Špatné použití funkce <strong>eachi</strong></td><td><a href="https://github.com/tisnik/functional-lua/tree/master/moses/42_eachi_bad_usage.lua">https://github.com/tisnik/functional-lua/tree/master/moses/42_eachi_bad_usage.lua</a></td></tr>
<tr><td>23</td><td>43_map.lua</td><td>Funkce vyššího řádu <strong>map</strong></td><td><a href="https://github.com/tisnik/functional-lua/tree/master/moses/43_map.lua">https://github.com/tisnik/functional-lua/tree/master/moses/43_map.lua</a></td></tr>
<tr><td>24</td><td>44_map.lua</td><td>Stejný příklad, ovšem s&nbsp;ladicím výpisem</td><td><a href="https://github.com/tisnik/functional-lua/tree/master/moses/44_map.lua">https://github.com/tisnik/functional-lua/tree/master/moses/44_map.lua</a></td></tr>
<tr><td>25</td><td>45_chain.lua</td><td>Zřetězení více operací nad tabulkou funkcí <strong>chain</strong></td><td><a href="https://github.com/tisnik/functional-lua/tree/master/moses/45_chain.lua">https://github.com/tisnik/functional-lua/tree/master/moses/45_chain.lua</a></td></tr>
<tr><td>26</td><td>46_chain_map.lua</td><td>Výpočet tabulky faktoriálů na dvou řádcích</td><td><a href="https://github.com/tisnik/functional-lua/tree/master/moses/46_chain_map.lua">https://github.com/tisnik/functional-lua/tree/master/moses/46_chain_map.lua</a></td></tr>
<tr><td>27</td><td>47_chain_map_each.lua</td><td>Výpočet tabulky faktoriálů na jediném řádku</td><td><a href="https://github.com/tisnik/functional-lua/tree/master/moses/47_chain_map_each.lua">https://github.com/tisnik/functional-lua/tree/master/moses/47_chain_map_each.lua</a></td></tr>
<tr><td>28</td><td>48_map_reduce.lua</td><td>Ukázka použití funkce <strong>mapReduce</strong></td><td><a href="https://github.com/tisnik/functional-lua/tree/master/moses/48_map_reduce.lua">https://github.com/tisnik/functional-lua/tree/master/moses/48_map_reduce.lua</a></td></tr>
<tr><td>29</td><td>49_map_reduce_right.lua</td><td>Rozdíl mezi funkcí <strong>mapReduce</strong> a <strong>mapReduceRight</strong></td><td><a href="https://github.com/tisnik/functional-lua/tree/master/moses/49_map_reduce_right.lua">https://github.com/tisnik/functional-lua/tree/master/moses/49_map_reduce_right.lua</a></td></tr>
<tr><td>30</td><td>50_sortedk.lua</td><td>Příklad použití funkce <strong>sortedk</strong></td><td><a href="https://github.com/tisnik/functional-lua/tree/master/moses/50_sortedk.lua">https://github.com/tisnik/functional-lua/tree/master/moses/50_sortedk.lua</a></td></tr>
</table>



<p><a name="k19"></a></p>
<h2 id="k19">19. Články o programovacím jazyce Lua i o technologii LuaJITu</h2>

<p>Předchozí dva články o funkcionálním stylu programování podporovaného
knihovnou <i>Lua Fun</i> a úvodní článek o knihovně <i>Moses</i>:</p>

<ol>

<li>Lua Fun: knihovna pro zpracování konečných i nekonečných sekvencí v&nbsp;jazyce Lua<br />
<a href="https://www.root.cz/clanky/lua-fun-knihovna-pro-zpracovani-konecnych-i-nekonecnych-sekvenci-v-jazyce-lua/">https://www.root.cz/clanky/lua-fun-knihovna-pro-zpracovani-konecnych-i-nekonecnych-sekvenci-v-jazyce-lua/</a>
</li>

<li>Lua Fun: knihovna pro zpracování konečných i nekonečných sekvencí v&nbsp;jazyce Lua (dokončení)<br />
<a href="https://www.root.cz/clanky/lua-fun-knihovna-pro-zpracovani-konecnych-i-nekonecnych-sekvenci-v-jazyce-lua-dokonceni/">https://www.root.cz/clanky/lua-fun-knihovna-pro-zpracovani-konecnych-i-nekonecnych-sekvenci-v-jazyce-lua-dokonceni/</a>
</li>

<li>Podpora funkcionálního programovaní v&nbsp;jazyku Lua s&nbsp;využitím knihovny Moses<br />
<a href="https://www.root.cz/clanky/podpora-funkcionalniho-programovani-v-jazyku-lua-s-vyuzitim-knihovny-moses/">https://www.root.cz/clanky/podpora-funkcionalniho-programovani-v-jazyku-lua-s-vyuzitim-knihovny-moses/</a>
</li>

</ol>

<p>Programovacím jazykem Lua jsme se již na stránkách Rootu poměrně podrobně
zabývali <a
href="https://www.root.cz/serialy/programovaci-jazyk-lua/">v&nbsp;samostatném
seriálu</a>. Jedná se o snadno naučitelný jazyk, který je ovšem (mj.&nbsp;i
díky konceptu metatabulek) rozšiřitelný a poměrně tvárný. Viz též následující
odkazy na již vydané články (včetně odkazu na e-book, jenž na základě těchto
článků později vznikl):</p>

<ol>

<li>Programovací jazyk Lua<br />
<a href="https://www.root.cz/clanky/programovaci-jazyk-lua/">https://www.root.cz/clanky/programovaci-jazyk-lua/</a>
</li>

<li>Základní konstrukce v programovacím jazyku Lua<br />
<a href="https://www.root.cz/clanky/zakladni-konstrukce-v-programovacim-jazyku-lua/">https://www.root.cz/clanky/zakladni-konstrukce-v-programovacim-jazyku-lua/</a>
</li>

<li>Operátory a asociativní pole v&nbsp;jazyku Lua<br />
<a href="https://www.root.cz/clanky/operatory-a-asociativni-pole-v-jazyku-lua/">https://www.root.cz/clanky/operatory-a-asociativni-pole-v-jazyku-lua/</a>
</li>

<li>Funkce v&nbsp;programovacím jazyku Lua<br />
<a href="https://www.root.cz/clanky/funkce-v-programovacim-jazyku-lua/">https://www.root.cz/clanky/funkce-v-programovacim-jazyku-lua/</a>
</li>

<li>Funkce v&nbsp;programovacím jazyku Lua - uzávěry<br />
<a href="https://www.root.cz/clanky/funkce-v-programovacim-jazyku-lua-uzavery/">https://www.root.cz/clanky/funkce-v-programovacim-jazyku-lua-uzavery/</a>
</li>

<li>Programovací jazyk Lua vestavěný do aplikací<br />
<a href="https://www.root.cz/clanky/programovaci-jazyk-lua-vestaveny-do-aplikaci/">https://www.root.cz/clanky/programovaci-jazyk-lua-vestaveny-do-aplikaci/</a>
</li>

<li>Programovací jazyk Lua v&nbsp;aplikacích II<br />
<a href="https://www.root.cz/clanky/programovaci-jazyk-lua-v-aplikacich-ii/">https://www.root.cz/clanky/programovaci-jazyk-lua-v-aplikacich-ii/</a>
</li>

<li>Objektově orientované programování v&nbsp;Lua<br />
<a href="https://www.root.cz/clanky/objektove-orientovane-programovani-v-lua/">https://www.root.cz/clanky/objektove-orientovane-programovani-v-lua/</a>
</li>

<li>Objektově orientované programování v&nbsp;Lua II<br />
<a href="https://www.root.cz/clanky/objektove-orientovane-programovani-v-lua-ii/">https://www.root.cz/clanky/objektove-orientovane-programovani-v-lua-ii/</a>
</li>

<li>Programovací jazyk Lua a koprogramy<br />
<a href="https://www.root.cz/clanky/programovaci-jazyk-lua-a-koprogramy/">https://www.root.cz/clanky/programovaci-jazyk-lua-a-koprogramy/</a>
</li>

<li>Knihovny a frameworky pro programovací jazyk Lua<br />
<a href="https://www.root.cz/clanky/knihovny-a-frameworky-pro-programovaci-jazyk-lua/">https://www.root.cz/clanky/knihovny-a-frameworky-pro-programovaci-jazyk-lua/</a>
</li>

<li>Lua + LÖVE: vytvořte si vlastní hru<br />
<a href="https://www.root.cz/clanky/lua-love-vytvorte-si-vlastni-hru/">https://www.root.cz/clanky/lua-love-vytvorte-si-vlastni-hru/</a>
</li>

<li>Hrátky se systémem LÖVE<br />
<a href="https://www.root.cz/clanky/hratky-se-systemem-love/">https://www.root.cz/clanky/hratky-se-systemem-love/</a>
</li>

<li>Vytváříme hru v&nbsp;systému LÖVE<br />
<a href="https://www.root.cz/clanky/vytvarime-hru-v-systemu-love/">https://www.root.cz/clanky/vytvarime-hru-v-systemu-love/</a>
</li>

<li>Hrátky se systémem LÖVE - částicové systémy<br />
<a href="https://www.root.cz/clanky/hratky-se-systemem-love-casticove-systemy/">https://www.root.cz/clanky/hratky-se-systemem-love-casticove-systemy/</a>
</li>

<li>Hrátky se systémem LÖVE – kolize a odrazy těles<br />
<a href="https://www.root.cz/clanky/hratky-se-systemem-love-ndash-kolize-a-odrazy-teles/">https://www.root.cz/clanky/hratky-se-systemem-love-ndash-kolize-a-odrazy-teles/</a>
</li>

<li>Hrátky se systémem LÖVE - kolize a odrazy těles II<br />
<a href="https://www.root.cz/clanky/hratky-se-systemem-love-kolize-a-odrazy-teles-ii/">https://www.root.cz/clanky/hratky-se-systemem-love-kolize-a-odrazy-teles-ii/</a>
</li>

<li>Hrátky se systémem LÖVE - pružné vazby mezi tělesy<br />
<a href="https://www.root.cz/clanky/hratky-se-systemem-love-pruzne-vazby-mezi-telesy/">https://www.root.cz/clanky/hratky-se-systemem-love-pruzne-vazby-mezi-telesy/</a>
</li>

<li>Hrátky se systémem LÖVE - dokončení<br />
<a href="https://www.root.cz/clanky/hratky-se-systemem-love-dokonceni/">https://www.root.cz/clanky/hratky-se-systemem-love-dokonceni/</a>
</li>

<li>LuaJ – implementace jazyka Lua v&nbsp;Javě<br />
<a href="https://www.root.cz/clanky/luaj-ndash-implementace-jazyka-lua-v-jave/">https://www.root.cz/clanky/luaj-ndash-implementace-jazyka-lua-v-jave/</a>
</li>

<li>LuaJ a skriptování podle specifikace JSR-223<br />
<a href="https://www.root.cz/clanky/luaj-a-skriptovani-podle-specifikace-jsr-223/">https://www.root.cz/clanky/luaj-a-skriptovani-podle-specifikace-jsr-223/</a>
</li>

<li>Metalua: programovatelné rozšíření sémantiky jazyka Lua<br />
<a href="https://www.root.cz/clanky/metalua-programovatelne-rozsireni-semantiky-jazyka-lua/">https://www.root.cz/clanky/metalua-programovatelne-rozsireni-semantiky-jazyka-lua/</a>
</li>

<li>Metalua: užitečná rozšíření jazyka Lua<br />
<a href="https://www.root.cz/clanky/metalua-uzitecna-rozsireni-jazyka-lua/">https://www.root.cz/clanky/metalua-uzitecna-rozsireni-jazyka-lua/</a>
</li>

<li>Programovací jazyk Lua v&nbsp;roli skriptovacího jazyka pro WWW stránky<br />
<a href="https://www.root.cz/clanky/programovaci-jazyk-lua-v-roli-skriptovaciho-jazyka-pro-www-stranky/">https://www.root.cz/clanky/programovaci-jazyk-lua-v-roli-skriptovaciho-jazyka-pro-www-stranky/</a>
</li>

<li>Interpretry, překladače, JIT překladače a transpřekladače programovacího jazyka Lua<br />
<a href="https://www.root.cz/clanky/interpretry-prekladace-jit-prekladace-a-transprekladace-programovaciho-jazyka-lua/">https://www.root.cz/clanky/interpretry-prekladace-jit-prekladace-a-transprekladace-programovaciho-jazyka-lua/</a>
</li>

<li>Kooperace mezi jazykem Lua a nativním (céčkovým) kódem<br />
<a href="https://www.root.cz/clanky/kooperace-mezi-jazykem-lua-a-nativnim-ceckovym-kodem/">https://www.root.cz/clanky/kooperace-mezi-jazykem-lua-a-nativnim-ceckovym-kodem/</a>
</li>

<li>Kooperace mezi jazykem Lua a nativním (céčkovým) kódem: knihovna FFI<br />
<a href="https://www.root.cz/clanky/kooperace-mezi-jazykem-lua-a-nativnim-ceckovym-kodem-knihovna-ffi/">https://www.root.cz/clanky/kooperace-mezi-jazykem-lua-a-nativnim-ceckovym-kodem-knihovna-ffi/</a>
</li>

<li>Profilery pro programovací jazyk Lua<br />
<a href="https://www.root.cz/clanky/profilery-pro-programovaci-jazyk-lua/">https://www.root.cz/clanky/profilery-pro-programovaci-jazyk-lua/</a>
</li>

<li>Využití knihovny debug v&nbsp;programovacím jazyku Lua<br />
<a href="https://www.root.cz/clanky/vyuziti-knihovny-debug-v-programovacim-jazyku-lua/">https://www.root.cz/clanky/vyuziti-knihovny-debug-v-programovacim-jazyku-lua/</a>
</li>

<li>Programovací jazyk Lua (e-book)<br />
<a href="https://www.knihydobrovsky.cz/e-kniha/programovaci-jazyk-lua-240253190">https://www.knihydobrovsky.cz/e-kniha/programovaci-jazyk-lua-240253190</a>
</li>

</ol>

<p>Původně byla Lua realizována jako klasický interpret &ndash; prováděl se
automatický a prakticky okamžitý překlad do bajtkódu, který byl následně
interpretován. Později byl vytvořen i plnohodnotný (a nutno podotknout, že až
neobvykle dobrý) just-in-time (JIT) překladač nazvaný LuaJIT. Touto zajímavou
technologií jsme se zabývali v&nbsp;následující sérii článků (které jsou
poněkud paradoxně součástí seriálu o <a
href="https://www.root.cz/serialy/programovaci-jazyk-java-a-jvm/">programovacím
jazyku Java a JVM</a>):</p>

<ol>

<li>LuaJIT – Just in Time překladač pro programovací jazyk Lua<br />
<a href="https://www.root.cz/clanky/luajit-just-in-time-prekladac-pro-programovaci-jazyk-lua/">https://www.root.cz/clanky/luajit-just-in-time-prekladac-pro-programovaci-jazyk-lua/</a>
</li>

<li>LuaJIT – Just in Time překladač pro programovací jazyk Lua (2)<br />
<a href="https://www.root.cz/clanky/luajit-just-in-time-prekladac-pro-programovaci-jazyk-lua-2/">https://www.root.cz/clanky/luajit-just-in-time-prekladac-pro-programovaci-jazyk-lua-2/</a>
</li>

<li>LuaJIT – Just in Time překladač pro programovací jazyk Lua (3)<br />
<a href="https://www.root.cz/clanky/luajit-just-in-time-prekladac-pro-programovaci-jazyk-lua-3/">https://www.root.cz/clanky/luajit-just-in-time-prekladac-pro-programovaci-jazyk-lua-3/</a>
</li>

<li>LuaJIT – Just in Time překladač pro programovací jazyk Lua (4)<br />
<a href="https://www.root.cz/clanky/luajit-just-in-time-prekladac-pro-programovaci-jazyk-lua-4/">https://www.root.cz/clanky/luajit-just-in-time-prekladac-pro-programovaci-jazyk-lua-4/</a>
</li>

<li>LuaJIT – Just in Time překladač pro programovací jazyk Lua (5 – tabulky a pole)<br />
<a href="https://www.root.cz/clanky/luajit-just-in-time-prekladac-pro-programovaci-jazyk-lua-5-tabulky-a-pole/">https://www.root.cz/clanky/luajit-just-in-time-prekladac-pro-programovaci-jazyk-lua-5-tabulky-a-pole/</a>
</li>

<li>LuaJIT – Just in Time překladač pro programovací jazyk Lua (6 – překlad programových smyček do mezijazyka LuaJITu)<br />
<a href="https://www.root.cz/clanky/luajit-just-in-time-prekladac-pro-programovaci-jazyk-lua-6-preklad-programovych-smycek-do-mezijazyka-luajitu/">https://www.root.cz/clanky/luajit-just-in-time-prekladac-pro-programovaci-jazyk-lua-6-preklad-programovych-smycek-do-mezijazyka-luajitu/</a>
</li>

<li>LuaJIT – Just in Time překladač pro programovací jazyk Lua (7 – dokončení popisu mezijazyka LuaJITu)<br />
<a href="https://www.root.cz/clanky/luajit-just-in-time-prekladac-pro-programovaci-jazyk-lua-7-dokonceni-popisu-mezijazyka-luajitu/">https://www.root.cz/clanky/luajit-just-in-time-prekladac-pro-programovaci-jazyk-lua-7-dokonceni-popisu-mezijazyka-luajitu/</a>
</li>

<li>LuaJIT – Just in Time překladač pro programovací jazyk Lua (8 – základní vlastnosti trasovacího JITu)<br />
<a href="https://www.root.cz/clanky/luajit-just-in-time-prekladac-pro-programovaci-jazyk-lua-8-zakladni-vlastnosti-trasovaciho-jitu/">https://www.root.cz/clanky/luajit-just-in-time-prekladac-pro-programovaci-jazyk-lua-8-zakladni-vlastnosti-trasovaciho-jitu/</a>
</li>

<li>LuaJIT – Just in Time překladač pro programovací jazyk Lua (9 – další vlastnosti trasovacího JITu)<br />
<a href="https://www.root.cz/clanky/luajit-just-in-time-prekladac-pro-programovaci-jazyk-lua-9-dalsi-vlastnosti-trasovaciho-jitu/">https://www.root.cz/clanky/luajit-just-in-time-prekladac-pro-programovaci-jazyk-lua-9-dalsi-vlastnosti-trasovaciho-jitu/</a>
</li>

<li>LuaJIT – Just in Time překladač pro programovací jazyk Lua (10 – JIT překlad do nativního kódu)<br />
<a href="https://www.root.cz/clanky/luajit-just-in-time-prekladac-pro-programovaci-jazyk-lua-10-jit-preklad-do-nativniho-kodu/">https://www.root.cz/clanky/luajit-just-in-time-prekladac-pro-programovaci-jazyk-lua-10-jit-preklad-do-nativniho-kodu/</a>
</li>

<li>LuaJIT – Just in Time překladač pro programovací jazyk Lua (11 – JIT překlad do nativního kódu procesorů s architekturami x86 a ARM)<br />
<a href="https://www.root.cz/clanky/luajit-just-in-time-prekladac-pro-programovaci-jazyk-lua-11-jit-preklad-do-nativniho-kodu-procesoru-s-architekturami-x86-a-arm/">https://www.root.cz/clanky/luajit-just-in-time-prekladac-pro-programovaci-jazyk-lua-11-jit-preklad-do-nativniho-kodu-procesoru-s-architekturami-x86-a-arm/</a>
</li>

<li>LuaJIT – Just in Time překladač pro programovací jazyk Lua (12 – překlad operací s reálnými čísly)<br />
<a href="https://www.root.cz/clanky/luajit-just-in-time-prekladac-pro-programovaci-jazyk-lua-12-preklad-operaci-s-realnymi-cisly/">https://www.root.cz/clanky/luajit-just-in-time-prekladac-pro-programovaci-jazyk-lua-12-preklad-operaci-s-realnymi-cisly/</a>
</li>

</ol>

<p>A konečně nesmíme zapomenout na to, že kromě původní implementace
interpretru a LuaJITu existuje celá řada dalších implementací tohoto
programovacího jazyka. Některé z&nbsp;těchto implementací byly zmíněny
v&nbsp;následujících článcích:</p>

<ol>

<li>Skriptovací jazyk Lua v&nbsp;aplikacích naprogramovaných v&nbsp;Go<br />
<a href="https://www.root.cz/clanky/skriptovaci-jazyk-lua-v-aplikacich-naprogramovanych-v-go/">https://www.root.cz/clanky/skriptovaci-jazyk-lua-v-aplikacich-naprogramovanych-v-go/</a>
</li>

<li>Programovací jazyk Lua v&nbsp;roli skriptovacího jazyka pro WWW stránky<br />
<a href="https://www.root.cz/clanky/programovaci-jazyk-lua-v-roli-skriptovaciho-jazyka-pro-www-stranky/">https://www.root.cz/clanky/programovaci-jazyk-lua-v-roli-skriptovaciho-jazyka-pro-www-stranky/</a>
</li>

<li>LuaJ – implementace jazyka Lua v&nbsp;Javě<br />
<a href="https://www.root.cz/clanky/luaj-ndash-implementace-jazyka-lua-v-jave/">https://www.root.cz/clanky/luaj-ndash-implementace-jazyka-lua-v-jave/</a>
</li>

<li>Tvorba pluginů pro Vim s&nbsp;využitím programovacího jazyka Lua<br />
<a href="https://www.root.cz/clanky/tvorba-pluginu-pro-vim-s-vyuzitim-programovaciho-jazyka-lua/">https://www.root.cz/clanky/tvorba-pluginu-pro-vim-s-vyuzitim-programovaciho-jazyka-lua/</a>
</li>

</ol>

<p><div class="rs-tip-major">Poznámka: předchozí články sice nepokrývají
ekosystém tohoto jazyka dokonale, ovšem přibližně 90% všech relevantních
informací je uvedeno. To je v&nbsp;případě dalších ekosystémů (Java, Python,
Ruby, ...) prakticky nemožné, resp.&nbsp;to není v&nbsp;silách jediného autora
:-)</div></p>



<p><a name="k20"></a></p>
<h2 id="k20">20. Odkazy na Internetu</h2>

<ol>

<li>Repositář projektu Lua Fun<br />
<a href="https://github.com/luafun/luafun">https://github.com/luafun/luafun</a>
</li>

<li>Lua Functional 0.1.3 documentation<br />
<a href="https://luafun.github.io/reference.html">https://luafun.github.io/reference.html</a>
</li>

<li>Getting Started<br />
<a href="https://luafun.github.io/getting_started.html">https://luafun.github.io/getting_started.html</a>
</li>

<li>Rockspec knihovny Fun<br />
<a href="https://raw.githubusercontent.com/luafun/luafun/master/fun-scm-1.rockspec">https://raw.githubusercontent.com/luafun/luafun/master/fun-scm-1.rockspec</a>
</li>

<li>Awesome Lua &ndash; A curated list of quality Lua packages and resources.<br />
<a href="https://github.com/LewisJEllis/awesome-lua">https://github.com/LewisJEllis/awesome-lua</a>
</li>

<li>Repositář projektu Moses<br />
<a href="https://github.com/Yonaba/Moses/">https://github.com/Yonaba/Moses/</a>
</li>

<li>Lambda the Ultimate: Coroutines in Lua<br />
<a href="http://lambda-the-ultimate.org/no­de/438">http://lambda-the-ultimate.org/no­de/438</a>
</li>

<li>Coroutines Tutorial<br />
<a href="http://lua-users.org/wiki/Co­routinesTutori­al">http://lua-users.org/wiki/Co­routinesTutori­al</a>
</li>

<li>Lua Coroutines Versus Python Generators<br />
<a href="http://lua-users.org/wiki/Lu­aCoroutinesVer­susPythonGene­rators">http://lua-users.org/wiki/Lu­aCoroutinesVer­susPythonGene­rators</a>
</li>

<li>Programming in Lua 9.1 – Coroutine Basics<br />
<a href="http://www.lu­a.org/pil/9.1­.html">http://www.lu­a.org/pil/9.1­.html</a>
</li>

<li>Wikipedia CZ: Koprogram<br />
<a href="http://cs.wiki­pedia.org/wiki/Ko­program">http://cs.wiki­pedia.org/wiki/Ko­program</a>
</li>

<li>Wikipedia EN: Coroutine<br />
<a href="http://en.wiki­pedia.org/wiki/Co­routine">http://en.wiki­pedia.org/wiki/Co­routine</a>
</li>

<li>Repositář knihovny Moses<br />
<a href="https://github.com/Yonaba/Moses/">https://github.com/Yonaba/Moses/</a>
</li>

<li>Návod k&nbsp;použití knihovny Moses<br />
<a href="https://github.com/Yonaba/Moses/blob/master/doc/tutorial.md">https://github.com/Yonaba/Moses/blob/master/doc/tutorial.md</a>
</li>

<li>How to understand clojure's lazy-seq<br />
<a href="https://stackoverflow.com/questions/44095400/how-to-understand-clojures-lazy-seq">https://stackoverflow.com/questions/44095400/how-to-understand-clojures-lazy-seq</a>
</li>

<li>Lua Implementations<br />
<a href="http://lua-users.org/wiki/LuaImplementations">http://lua-users.org/wiki/LuaImplementations</a>
</li>

<li>Generator (computer programming)<br />
<a href="https://en.wikipedia.org/wiki/Generator_(computer_programming)">https://en.wikipedia.org/wiki/Generator_(computer_programming)</a>
</li>

<li>Lambda the Ultimate: Coroutines in Lua,<br />
<a href="http://lambda-the-ultimate.org/node/438">http://lambda-the-ultimate.org/node/438</a>
</li>

<li>Coroutines Tutorial,<br />
<a href="http://lua-users.org/wiki/CoroutinesTutorial">http://lua-users.org/wiki/CoroutinesTutorial</a>
</li>

<li>Lua Coroutines Versus Python Generators,<br />
<a href="http://lua-users.org/wiki/LuaCorouti­nesVersusPythonGenerators">http://lua-users.org/wiki/LuaCorouti­nesVersusPythonGenerators</a>
</li>

<li>Category:Lua na Rosetta code<br />
<a href="https://rosettacode.org/wiki/Category:Lua">https://rosettacode.org/wiki/Category:Lua</a>
</li>

<li>Programming in Lua: 23 – The Debug Library<br />
<a href="http://www.lua.org/pil/23.html">http://www.lua.org/pil/23.html</a>
</li>

<li>Programming in Lua: 23.1 – Introspective Facilities<br />
<a href="http://www.lua.org/pil/23.1.html">http://www.lua.org/pil/23.1.html</a>
</li>

<li>Programming in Lua: 23.2 – Hooks<br />
<a href="http://www.lua.org/pil/23.2.html">http://www.lua.org/pil/23.2.html</a>
</li>

<li>Lua 5.2 Reference Manual: 6.10 – The Debug Library<br />
<a href="http://www.lua.org/manual/5­.2/manual.html#6.10">http://www.lua.org/manual/5­.2/manual.html#6.10</a>
</li>

<li>Turtles all the way down<br />
<a href="https://en.wikipedia.org/wiki/Turtles_all_the_way_down">https://en.wikipedia.org/wiki/Turtles_all_the_way_down</a>
</li>

<li>Issues k&nbsp;projektu LuaFun<br />
<a href="https://github.com/luafun/luafun/issues">https://github.com/luafun/luafun/issues</a>
</li>

<li>Archived | Embed Lua for scriptable apps<br />
<a href="https://developer.ibm.com/tutorials/l-embed-lua/">https://developer.ibm.com/tutorials/l-embed-lua/</a>
</li>

<li>Embedding Lua<br />
<a href="https://www.oreilly.com/library/view/lua-quick-start/9781789343229/3a6f3daf-f74c-4a25-a125-584da58568e4.xhtml">https://www.oreilly.com/library/view/lua-quick-start/9781789343229/3a6f3daf-f74c-4a25-a125-584da58568e4.xhtml</a>
</li>

</ol>



<p></p><p></p>
<p><small>Autor: <a href="http://www.fit.vutbr.cz/~tisnovpa">Pavel Tišnovský</a> &nbsp; 2020</small></p>
</body>
</html>

