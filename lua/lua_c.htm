<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
        "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html>
<head>
<title>Kooperace mezi jazykem Lua a nativním (céčkovým) kódem</title>
<meta name="Author" content="Pavel Tisnovsky" />
<meta name="Generator" content="vim" />
<meta http-equiv="content-type" content="text/html; charset=utf-8" />
<style type="text/css">
         body {color:#000000; background:#ffffff;}
         h1  {font-family: arial, helvetica, sans-serif; color:#ffffff; background-color:#c00000; text-align:center; padding-left:1em}
         h2  {font-family: arial, helvetica, sans-serif; color:#ffffff; background-color:#0000c0; padding-left:1em; text-align:left}
         h3  {font-family: arial, helvetica, sans-serif; color:#000000; background-color:#c0c0c0; padding-left:1em; text-align:left}
         h4  {font-family: arial, helvetica, sans-serif; color:#000000; background-color:#e0e0e0; padding-left:1em; text-align:left}
         a   {font-family: arial, helvetica, sans-serif;}
         li  {font-family: arial, helvetica, sans-serif; color:#000000; text-align:justify; width:450px;}
         ol  {font-family: arial, helvetica, sans-serif; color:#000000; text-align:justify; width:450px;}
         ul  {font-family: arial, helvetica, sans-serif; color:#000000; text-align:justify; width:450px;}
         p   {font-family: arial, helvetica, sans-serif; color:#000000; text-align:justify;}
         pre {background:#e0e0e0}
</style>
</head>

<body>

<h1>Kooperace mezi jazykem Lua a nativním (céčkovým) kódem</h1>

<h3>Pavel Tišnovský</h3>

<p></p>

<h1>Úvodník</h1>

<p>V předchozím článku o programovacím jazyku Lua jsme se mj. seznámili s možností transpřekladu skriptů naprogramovaných v Lue do jazyka C. Zdrojový kód v céčku je pak možné běžným způsobem přeložit. Ovšem mnohem častěji se v praxi využívá kooperace mezi nativním (céčkovým) kódem a skripty napsanými v Lue. Tímto tématem se budeme zabývat dnes.</p>



<h2>Obsah</h2>

<p><a href="#k01">1. Kooperace mezi jazykem Lua a nativním (céčkovým) kódem</a></p>
<p><a href="#k02">2. Způsoby vestavění virtuálního stroje jazyka Lua do nativních aplikací</a></p>
<p><a href="#k03">3. Izolace skriptů běžících v&nbsp;rámci virtuálního stroje jazyka Lua</a></p>
<p><a href="#k04">4. Inicializace a ukončení práce virtuálního stroje jazyka Lua</a></p>
<p>&nbsp;&nbsp;&nbsp;<a href="#k041">4.1 První demonstrační příklad &ndash; vytištění informací o verzi interpretru i o jeho autorech</a></p>
<p>&nbsp;&nbsp;&nbsp;<a href="#k042">4.2 Druhý demonstrační příklad &ndash; inicializace a ukončení práce virtuálního stroje jazyka Lua</a></p>
<p><a href="#k05">5. Spuštění skriptů z&nbsp;nativního (céčkového) kódu</a></p>
<p>&nbsp;&nbsp;&nbsp;<a href="#k051">5.1 Třetí demonstrační příklad &ndash; spuštění skriptu uloženého v&nbsp;řetězci</a></p>
<p>&nbsp;&nbsp;&nbsp;<a href="#k052">5.2 Čtvrtý demonstrační příklad &ndash; spuštění skriptu uloženého v&nbsp;externím souboru</a></p>
<p><a href="#k06">6. Komunikace C &rarr; Lua</a></p>
<p>&nbsp;&nbsp;&nbsp;<a href="#k061">6.1 Pátý demonstrační příklad &ndash; zavolání funkce ze standardní knihovny jazyka Lua z&nbsp;C</a></p>
<p>&nbsp;&nbsp;&nbsp;<a href="#k062">6.2 Šestý demonstrační příklad &ndash; předání dvou parametrů různých typů volané funkci</a></p>
<p>&nbsp;&nbsp;&nbsp;<a href="#k063">6.3 Sedmý demonstrační příklad &ndash; přečtení návratové hodnoty Lua funkce</a></p>
<p><a href="#k07">7. Komunikace Lua &rarr; C</a></p>
<p>&nbsp;&nbsp;&nbsp;<a href="#k071">7.1 Osmý demonstrační příklad &ndash; zavolání céčkové funkce ze skriptu</a></p>
<p><a href="#k08">8. Alternativní způsob komunikace mezi jazykem Lua a nativním kódem: knihovna <strong>FFI</strong></a></p>
<p>&nbsp;&nbsp;&nbsp;<a href="#k081">8.1 Devátý demonstrační příklad &ndash; základ použití knihovny <strong>FFI</strong></a></p>
<p>&nbsp;&nbsp;&nbsp;<a href="#k082">8.2 Desátý demonstrační příklad &ndash; volání složitější funkce</a></p>
<p><a href="#k09">9. Repositář s&nbsp;dnešními demonstračními příklady</a></p>
<p><a href="#k10">10. Odkazy na Internetu</a></p>



<p><a name="k01"></a></p>
<h2 id="k01">1. Kooperace mezi jazykem Lua a nativním (céčkovým) kódem</h2>

<p>Ve článku nazvaném <a
href="http://www.root.cz/clanky/interpretry-prekladace-jit-prekladace-a-transprekladace-programovaciho-jazyka-lua/">Interpretry,
překladače, JIT překladače a transpřekladače programovacího jazyka Lua</a>,
který na Rootu vyšel minulý týden, jsme se mj.&nbsp;seznámili i
s&nbsp;projektem nazvaným <i>Lua2c</i>. Jedná se o prozatím velmi naivní
transpřekladač sloužící k&nbsp;překladu zdrojových textů napsaných
v&nbsp;programovacím jazyce Lua do zdrojového kódu programovacího jazyka C.
Výsledný céčkový zdrojový kód se může následně přeložit libovolným céčkovým
překladačem (gcc, Clang apod.) a výsledkem tohoto překladu (a slinkování) bude
čistě nativní aplikace. I pokud pomineme fakt, že výsledný nativní kód je i při
provedení optimalizací pomalejší, než původní skript napsaný v&nbsp;Lue a
spuštěný v&nbsp;LuaJITu, přináší přímý transpřeklad do céčka i další nevýhody
&ndash; složité ladění (ne již na úrovni původního kódu) a především pak ztrátu
většiny vlastností klasického interpretru (mj.&nbsp;i ztrátu možnost okamžitého
spuštění napsaného programu bez nutnosti kompilace &ndash; a spuštění
interpretru Luy či LuaJITu je skutečně &bdquo;okamžité&ldquo;, minimálně
z&nbsp;pohledu člověka-vývojáře).</p>



<p><a name="k02"></a></p>
<h2 id="k02">2. Způsoby vestavění virtuálního stroje jazyka Lua do nativních aplikací</h2>

<p>V&nbsp;praxi se však programovací jazyk Lua používá odlišným způsobem.
Namísto transpřekladu do céčka či jiného nízkoúrovňového programovacího jazyka
se buď přímo spouští skripty napsané v&nbsp;Lue, a to s&nbsp;využitím
originálního interpretru či poněkud vyspělejšího LuaJITu (Lua je tedy použita
stejným způsobem jako například BASH, Perl atd.), nebo se virtuální stroj
jazyka Lua může přímo vložit do aplikací, což je poměrně jednoduché (pokud
situaci zjednoduším, nejedná se o nic jiného, než o přilinkování jedné
knihovny). Ostatně právě zde můžeme vidět jeden z&nbsp;hlavních důvodů
relativně velké oblíbenosti programovacího jazyka <i>Lua</i> mezi vývojáři
komerčních i nekomerčních aplikací: do prakticky libovolného programu je možné
zabudovat buď plnohodnotný interpret tohoto jazyka, nebo pouze tu část, která
se stará o běh přeloženého bajtkódu. V&nbsp;některých typech aplikací,
například (komerčních) počítačových hrách, totiž nemusí být nutné překládat
nové zdrojové kódy, ale pouze spouštět bajtkód přeložený přímo výrobcem hry;
další aplikace naopak mohou těžit z&nbsp;toho, že jsou uživatelsky
skriptovatelné (viz většina moderních &bdquo;Office&ldquo;, programy typu CAD
či CAM, grafické a textové editory a mnoho dalších typů aplikací).</p>

<a href="http://www.root.cz/obrazek/215993/"><img src="http://i.iinfo.cz/images/575/lua1.png" class="image-215993" alt="&#160;" height="200" width="320" /></a>
<p><i>Obrázek 1: Nativní aplikace (typicky naprogramovaná v&nbsp;C či C++) může
být slinkována s&nbsp;knihovnou obsahující virtuální stroj jazyka Lua. Taková
aplikace pak může načítat a spouštět skripty napsané v&nbsp;Lue či je dokonce
možné spouštět již přeložený bajtkód a vynechat tak fázi překladu.</i></p>

<p>Na tomto místě je nutné zdůraznit, že se v&nbsp;případě programovacího
jazyka Lua nejedná o unikátní vlastnost, protože i mnoho interpretů dalších
programovacích jazyků lze vestavět do jiných aplikací &ndash; v&nbsp;poslední
době se stává populární především <i>JavaScript</i> vedle již zavedeného
<i>Pythonu</i> (OpenOffice.org, GIMP), <i>Scheme</i> (opět GIMP), <i>Lispu</i>
(AutoCAD, Emacs) či <i>Visual Basicu (VBA)</i> (MS Office a mnohé další
aplikace). Ovšem v&nbsp;případě jazyka <i>Lua</i> je její vestavění do
libovolné aplikace skutečně snadné &ndash; z&nbsp;pohledu programátora
(především pokud programuje v&nbsp;céčku či C++), který ve své aplikaci
potřebuje použít nějaký skriptovací jazyk, se jedná o pouhých několik
programových řádků s&nbsp;následným slinkováním s&nbsp;objektovým kódem
uloženým v&nbsp;archivu <strong>liblua.a</strong>, jak si ostatně ukážeme
v&nbsp;navazujících kapitolách. Vložením celého překladače a interpretu jazyka
<i>Lua</i> včetně jeho podpůrného běhového prostředí (základní funkce, garbage
collector aj.) se zvětší velikost výsledného spustitelného souboru o cca 70 kB,
což není nijak závratná hodnota, především při porovnání velikostí interpretů
dalších programovacích jazyků (předpokládáme zde statické slinkování, ale i
velikost dynamické knihovny se příliš neliší).</p>

<a href="http://www.root.cz/obrazek/215994/"><img src="http://i.iinfo.cz/images/48/lua2-prev.png" class="image-215994" alt="&#160;" height="124" width="370" /></a>
<p><i>Obrázek 2: Lua však může být použita i ve funkci klasického skriptovacího
jazyka (podobně jako BASH či Perl). I v&nbsp;takovém případě je však možné
volat funkce z&nbsp;nativních knihoven.</i></p>



<p><a name="k03"></a></p>
<h2 id="k03">3. Izolace skriptů běžících v&nbsp;rámci virtuálního stroje jazyka Lua</h2>

<p>Vestavěný interpret jazyka <i>Lua</i> do jisté míry řeší taktéž otázku
bezpečnosti skriptů, aby se zabránilo šíření makrovirů, které byly tak
&bdquo;populární&ldquo; mezi uživateli jednoho rozšířeného kancelářského
balíku. Problém bezpečnosti je řešen především izolací běhového prostředí
skriptů od ostatního systému. Pouze přímo programátor aplikace, která má
obsahovat překladač a interpret <i>Lua</i>, může (explicitně zapsaným importem
příslušné knihovny) skriptům povolit například možnost práce se soubory,
spouštění dalších programů přes volání <i>os.execute()</i> apod. Bez importu
těchto knihoven je skriptu povoleno se svým okolím komunikovat pouze
s&nbsp;využitím volání zaregistrovaných funkcí: skript tedy v&nbsp;reálné
aplikaci nemá žádnou možnost, jak přistoupit k&nbsp;souborovému systému,
k&nbsp;síťovému rozhraní, nemůže bez povolení ani spustit jiný program, nemůže
poškodit paměť své hostitelské nativní aplikace apod. Pro předávání parametrů
se navíc používá zvláštní zásobník, ne standardní rámec procesu (na něj se
ukládá pouze jeden ukazatel), takže skripty ani nemají možnost manipulovat se
zásobníkem procesu pod kterým běží (tím se eliminují prakticky všechny útoky
typu <i>stack overflow</i>). Interpret provádí i základní kontrolu korektnosti
předaného bajtkódu.</p>

<p>Pro zajímavost: skriptu napsanému v&nbsp;jazyku Lua lze povolit či naopak
neumožnit přístup k&nbsp;těmto knihovnám:</p>

<table>
<tr><th>#</th><th>Knihovna</th><th>Význam</th></tr>
<tr><td>1</td><td>coroutine</td><td><a href="http://www.lua.org/pil/9.html">Podpora pro volání koprogramů</a></td></tr>
<tr><td>2</td><td>table    </td><td><a href="http://www.lua.org/pil/19.html">Práce s tabulkami a poli</a></td></tr>
<tr><td>3</td><td>io       </td><td><a href="http://www.lua.org/pil/21.html">Základní vstupně/výstupní operace</a></td></tr>
<tr><td>4</td><td>os       </td><td><a href="http://www.lua.org/pil/22.html">Volání systémových funkcí</a></td></tr>
<tr><td>5</td><td>string   </td><td><a href="http://www.lua.org/pil/20.html">Práce s řetězci</a></td></tr>
<tr><td>6</td><td>math     </td><td><a href="http://www.lua.org/pil/18.html">Matematické funkce</a></td></tr>
<tr><td>7</td><td>debug    </td><td><a href="http://www.lua.org/pil/23.html">Reflexe, přístup k zásobníkovým rámcům atd.</a></td></tr>
<tr><td>8</td><td>package  </td><td><a href="http://www.lua.org/pil/15.html">Práce s balíčky apod.</a></td></tr>
</table>

<p>Pokud se nějaká knihovna nenačte, není nutné ji ani linkovat, což je
užitečné zejména u podpory matematických funkcí na mikrořadičích (ušetří se
desítky kilobajtů kódu).</p>



<p><a name="k04"></a></p>
<h2 id="k04">4. Inicializace a ukončení práce virtuálního stroje jazyka Lua</h2>

<p>V&nbsp;této kapitole budou ukázány dva demonstrační příklady, na nichž si
vyzkoušíme základy připojení virtuálního stroje programovacího jazyka
<i>Lua</i> s&nbsp;nativní aplikací. Překladač a interpret programovacího jazyka
<i>Lua</i> je možné do aplikací vytvářených v&nbsp;céčku či C++ vložit velmi
snadno. <i>Lua</i> se instaluje buď překladem ze zdrojových kódů (k&nbsp;řízení
překladu je samozřejmě určen soubor <strong>Makefile</strong>) nebo
s&nbsp;využitím balíčkovacího nástroje příslušné Linuxové distribuce
(v&nbsp;tomto případě je nutné nainstalovat i variantu nazvanou &bdquo;Lua
devel&ldquo;, například <strong>liblua5.1-0-dev</strong>).</p>

<p>V&nbsp;obou případech získáme několik hlavičkových souborů, především pak
<strong>lua.h</strong>, <strong>lualib.h</strong> a <strong>lauxlib.h</strong>
(pro C++ i <strong>lua.hpp</strong>) a taktéž archiv nazvaný
<strong>liblua.a</strong> (popř.&nbsp;<strong>liblua5.1.a</strong> atd.), jenž
obsahuje objektové soubory potřebné pro sestavení aplikace s&nbsp;překladačem a
interpretem <i>Lua</i> (pokud se nepoužije překladač <i>gcc</i>, může být název
archivu s&nbsp;objektovými soubory odlišný, některé překladače například
pracují se soubory majícími koncovku <strong>.lib</strong>).</p>

<p>Ve stále ještě velmi často používané (i když dnes již poněkud zastaralé)
verzi <i>Lua 5.1</i> obsahuje archiv <strong>liblua5.1.a</strong> následující
soubory (výpis je proveden příkazem <strong>ar t liblua.a | sort</strong>):</p>

<pre>
lapi.o
lauxlib.o
lbaselib.o
lcode.o
ldblib.o
ldebug.o
ldo.o
ldump.o
lfunc.o
lgc.o
linit.o
liolib.o
llex.o
lmathlib.o
lmem.o
loadlib.o
lobject.o
lopcodes.o
loslib.o
lparser.o
lstate.o
lstring.o
lstrlib.o
ltable.o
ltablib.o
ltm.o
lundump.o
lvm.o
lzio.o
</pre>

<p>Pro knihovnu jazyka Lua ve verzi <i>5.2</i> několik objektových souborů
přibylo. Nové objektové soubory jsou v&nbsp;následujícím výpisu zvýrazněny:</p>

<pre>
lapi.o
lauxlib.o
lbaselib.o
<strong>lbitlib.o</strong>
lcode.o
<strong>lcorolib.o</strong>
<strong>lctype.o</strong>
ldblib.o
ldebug.o
ldo.o
ldump.o
lfunc.o
lgc.o
linit.o
liolib.o
llex.o
lmathlib.o
lmem.o
loadlib.o
lobject.o
lopcodes.o
loslib.o
lparser.o
lstate.o
lstring.o
lstrlib.o
ltable.o
ltablib.o
ltm.o
lundump.o
lvm.o
lzio.o
</pre>



<p><a name="k041"></a></p>
<h3 id="k041">4.1 První demonstrační příklad &ndash; vytištění informací o verzi interpretru i o jeho autorech</h3>

<p>Dnešní první demonstrační příklad je velmi jednoduchý, protože se v&nbsp;něm
pracuje pouze s&nbsp;několika konstantami uloženými v&nbsp;hlavičkovém souboru
<strong>lualib.h</strong>, konkrétně s&nbsp;konstantami
<strong>LUA_VERSION</strong>, <strong>LUA_RELEASE</strong>,
<strong>LUA_COPYRIGHT</strong> a <strong>LUA_AUTHORS</strong>. Hodnoty těchto
konstant jsou součástí přeložené aplikace:</p>

<p>Zdrojový kód:</p>

<pre>
<i>/*</i>
<i> * Prvni demonstracni priklad ukazujici zpusob propojeni</i>
<i> * skriptu v Lue a kodu v C. Zde se pouze vytisknou informace</i>
<i> * o verzi interpretru i o jeho autorech. Zadne dalsi operace</i>
<i> * se s virtualnim strojem neprovadi.</i>
<i> */</i>
&nbsp;
#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;
&nbsp;
<i>/* Zakladni a doplnkove funkce interpretu jazyka Lua */</i>
#include &lt;lualib.h&gt;
&nbsp;
<i>/* Hlavni funkce konzolove aplikace */</i>
int main(void)
{
    <i>/* vytisteni hlavicky */</i>
    puts(LUA_VERSION);
    puts(LUA_RELEASE);
    puts(LUA_COPYRIGHT);
    puts(LUA_AUTHORS);
    putchar('\n');
&nbsp;
    <i>/* navratovy kod */</i>
    return 0;
}
&nbsp;
/* finito */
</pre>

<p>Makefile určený pro překlad (cestu k&nbsp;hlavičkovému souboru a verzi VM
Lua je zapotřebí upravit):</p>

<pre>
CC=gcc
COPTIONS=-ansi -Wall
INCLUDEPATH=/usr/include/lua5.1
LIBS=lua5.1
&nbsp;
all:    lua_c_1
&nbsp;
clean:
        rm -f *.o
        rm -f lua_c_1
&nbsp;
lua_c_1:        lua_c_1.o
        $(CC) -o $@ $&lt; -l$(LIBS)
&nbsp;
%.o: %.c
        $(CC) $(COPTIONS) -c -I$(INCLUDEPATH) $&lt;
</pre>

<p>Po překladu a spuštění by se měly vypsat tyto informace (pochopitelně
s&nbsp;případnou změnou verze):</p>

<pre>
Lua 5.1
Lua 5.1.5
Copyright (C) 1994-2012 Lua.org, PUC-Rio
R. Ierusalimschy, L. H. de Figueiredo &amp; W. Celes
</pre>

<p>Podívejme se ještě příkazem <strong>ldd</strong> na knihovny používané
přeloženou aplikací:</p>

<pre>
        linux-vdso.so.1 =&gt;  (0x00007fffd87fe000)
        libc.so.6 =&gt; /lib/x86_64-linux-gnu/libc.so.6 (0x00007fbe9f85f000)
        /lib64/ld-linux-x86-64.so.2 (0x00007fbe9fc48000)
</pre>

<p>(vidíme, že se pro spuštění této aplikace nepoužívají žádné knihovny jazyka
Lua!)</p>



<p><a name="k042"></a></p>
<h3 id="k042">4.2 Druhý demonstrační příklad &ndash; inicializace a ukončení práce virtuálního stroje jazyka Lua</h3>

<p>Ve druhém demonstračním příkladu se objevují nové funkce, zejména pak funkce
nazvaná <strong>luaL_newstate()</strong> a též funkce
<strong>lua_close()</strong>. První z&nbsp;těchto funkcí slouží
k&nbsp;inicializaci virtuálního stroje jazyka Lua a taktéž k&nbsp;vytvoření
stavu běhového prostředí. Stav je uložen v&nbsp;datové struktuře typu
<strong>lua_State</strong> a většina funkcí, která s&nbsp;virtuálním strojem
jazyka Lua komunikuje, má jako jeden z&nbsp;parametrů ukazatel na tuto datovou
strukturu (to vlastně znamená, že je možné mít v&nbsp;rámci jedné nativní
aplikace větší množství navzájem izolovaných virtuálních strojů jazyka
Lua!):</p>

<pre>
<i>/*</i>
<i> * Druhy demonstracni priklad - inicializace virtualniho stroje</i>
<i> * ulozeni jeho stavu do lokalni promenne a nasledne ukonceni prace.</i>
<i> */</i>
&nbsp;
#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;
&nbsp;
<i>/* Zakladni a doplnkove funkce interpretu jazyka Lua */</i>
#include &lt;lualib.h&gt;
#include &lt;lauxlib.h&gt;
&nbsp;
<i>/* Hlavni funkce konzolove aplikace */</i>
int main(void)
{
    <i>/* vytisteni hlavicky */</i>
    puts(LUA_RELEASE);
    puts(LUA_COPYRIGHT);
    puts(LUA_AUTHORS);
    putchar('\n');
&nbsp;
    <i>/* vytvoreni objektu, do nejz se uklada stav virtualniho stroje */</i>
    lua_State* L = luaL_newstate();
    printf("State: %p\n", L);
&nbsp;
    <i>/* odstraneni vsech objektu asociovanych se stavem "Lua" */</i>
    lua_close(L);
&nbsp;
    <i>/* navratovy kod */</i>
    return 0;
}
&nbsp;
<i>/* finito */</i>
</pre>

<p>Na standardní výstup se po spuštění druhého demonstračního příkladu vypíšou
tyto řádky:</p>

<pre>
Lua 5.1.5
Copyright (C) 1994-2012 Lua.org, PUC-Rio
R. Ierusalimschy, L. H. de Figueiredo &amp; W. Celes
&nbsp;
State: 0x1f70010
</pre>

<p>Makefile použitý pro překlad:</p>

<pre>
CC=gcc
COPTIONS=-ansi -Wall
INCLUDEPATH=/usr/include/lua5.1
LIBS=lua5.1
&nbsp;
all:    lua_c_2
&nbsp;
clean:
        rm -f *.o
        rm -f lua_c_1
&nbsp;
lua_c_2:        lua_c_2.o
        $(CC) -o $@ $&lt; -l$(LIBS)
&nbsp;
%.o: %.c
        $(CC) $(COPTIONS) -c -I$(INCLUDEPATH) $&lt;
</pre>

<p>Opět se příkazem <strong>ldd</strong> podívejme na knihovny používané
přeloženou aplikací:</p>

<pre>
        linux-vdso.so.1 =&gt;  (0x00007fff353fe000)
        liblua5.1.so.0 =&gt; /usr/lib/x86_64-linux-gnu/liblua5.1.so.0 (0x00007fd6c7f2d000)
        libc.so.6 =&gt; /lib/x86_64-linux-gnu/libc.so.6 (0x00007fd6c7b68000)
        libm.so.6 =&gt; /lib/x86_64-linux-gnu/libm.so.6 (0x00007fd6c7861000)
        libdl.so.2 =&gt; /lib/x86_64-linux-gnu/libdl.so.2 (0x00007fd6c765d000)
        /lib64/ld-linux-x86-64.so.2 (0x00007fd6c817e000)
</pre>



<p><a name="k05"></a></p>
<h2 id="k05">5. Spuštění skriptů z&nbsp;nativního (céčkového) kódu</h2>

<p>V&nbsp;této kapitole si ukážeme dva základní způsoby spuštění skriptů
(psaných v&nbsp;jazyce Lua) z&nbsp;nativního kódu. Nejprve bude předvedeno
spuštění skriptu uloženého v&nbsp;řetězci, posléze pak spuštění skriptu
načteného z&nbsp;externího souboru.</p>



<p><a name="k051"></a></p>
<h3 id="k051">5.1 Třetí demonstrační příklad &ndash; spuštění skriptu uloženého v&nbsp;řetězci</h3>

<p>V&nbsp;dnešním třetím demonstračním příkladu je ukázán způsob spuštění
skriptu napsaného v&nbsp;programovacím jazyce <i>Lua</i>, který je uložen
v&nbsp;céčkovém řetězcovém literálu, tj.&nbsp;v&nbsp;řetězcové konstantě
umístěné přímo ve výsledném spustitelném souboru v&nbsp;kódovém segmentu (při
prohlížení spustitelného souboru binárním editorem lze zdrojový kód skriptu
poměrně rychle nalézt). Celý skript je spuštěn s&nbsp;využitím funkce
<strong>luaL_dostring()</strong>, přičemž první parametr představuje objekt
s&nbsp;uloženým stavem interpretu a druhý parametr je řetězec se skriptem
(přesněji řečeno odkaz na paměť s&nbsp;uloženým řetězcem zakončeným nulou, jak
je ostatně v&nbsp;céčku zvykem).</p>

<p>Nejedná se sice o typický způsob ukládání skriptů, už jen kvůli
nepřehlednosti zápisu řetězce na mnoha řádcích a problémy s&nbsp;některými
znaky se speciálním významem (ty je zapotřebí převést na céčkovou znakovou
entitu), v&nbsp;některých případech se však může hodit &ndash; například tehdy,
když se má celá aplikace spouštět na mikrořadičích bez souborového systému či
v&nbsp;případě požadavku, aby byl celý program i se všemi potřebnými daty
uložen v&nbsp;jediném souboru, který tak není nutné instalovat, ale lze ho
spouštět například přímo ze sítě či přenosného USB disku. Následuje výpis
zdrojového kódu prvního demonstračního příkladu:</p>

<pre>
<i>/*</i>
<i> * Treti demonstracni priklad - spusteni skriptu napsaneho</i>
<i> * v programovacim jazyce Lua, ktery je ulozeny v Ceckovem</i>
<i> * retezcovem literalu.</i>
<i> */</i>
&nbsp;
#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;
&nbsp;
<i>/* Zakladni a doplnkove funkce interpretu jazyka Lua */</i>
#include &lt;lualib.h&gt;
#include &lt;lauxlib.h&gt;
&nbsp;
<i>/* Skript napsany v programovacim jazyce Lua */</i>
const char * SCRIPT =
"-- Demonstracni priklad: pouziti uzaveru\n"\
"\n"\
"-- pomocna funkce vracejici uzaver\n"\
"function defPosloupnosti(n)\n"\
    "-- pamatovana hodnota, ktera vsak\n"\
    "-- neni z okolniho programu dostupna\n"\
    "local y = 1\n"\
    "-- pocitadlo volani = exponent\n"\
    "local index = 0\n"\
    "-- anonymni funkce vytiskne pamatovanou\n"\
    "-- hodnotu a nakonec ji vynasobi zvolenou konstantou\n"\
    "return function()\n"\
        "print(index, y)\n"\
        "y = y * n\n"\
        "index = index + 1\n"\
    "end\n"\
"end\n"\
"\n"\
"print('mocniny cisla 2')\n"\
"-- ziskani uzaveru\n"\
"generator = defPosloupnosti(2)\n"\
"\n"\
"-- postupne se budou tisknout\n"\
"-- mocniny cisla 2\n"\
"for i=0, 16 do\n"\
    "generator()\n"\
"end\n"\
"\n"\
"print()\n"\
"\n"\
"print('mocniny cisla 3')\n"\
"-- ziskani uzaveru\n"\
"generator = defPosloupnosti(3)\n"\
"\n"\
"-- postupne se budou tisknout\n"\
"-- mocniny cisla 3\n"\
"for i=0, 16 do\n"\
    "generator()\n"\
"end\n"\
"\n"\
"print()\n"\
"\n"\
"print('mocniny cisla 10')\n"\
"-- ziskani uzaveru\n"\
"generator = defPosloupnosti(10)\n"\
"\n"\
"-- postupne se budou tisknout\n"\
"-- mocniny cisla 3\n"\
"for i=0, 16 do\n"\
    "generator()\n"\
"end\n";
&nbsp;
<i>/* Hlavni funkce konzolove aplikace */</i>
int main(void)
{
    <i>/* navratova hodnota ziskana po zavolani skriptu */</i>
    int result;
&nbsp;
    <i>/* vytisteni hlavicky */</i>
    puts(LUA_RELEASE);
    puts(LUA_COPYRIGHT);
    puts(LUA_AUTHORS);
    putchar('\n');
&nbsp;
    <i>/* vytvoreni objektu, do nejz se uklada stav virtualniho stroje */</i>
    lua_State* L = luaL_newstate();
    <i>/* nacteme zakladni knihovnu obsahujici mj. i funkci print() */</i>
    luaopen_base(L);
    <i>/* nacteni retezce interpretem, jeho preklad a nasledne spusteni */</i>
    result = luaL_dostring(L, SCRIPT);
    <i>/* odstraneni vsech objektu asociovanych se stavem "Lua" */</i>
    lua_close(L);
    if (result != 0)
    {
        printf("Error # %d\n", result);
    }
    <i>/* vypocet navratoveho kodu */</i>
    return (result != 0);
}
&nbsp;
<i>/* finito */</i>
</pre>

<p>Po spuštění třetího příkladu se na standardní výstup vypíšou následující
řádky:</p>

<pre>
Lua 5.1.5
Copyright (C) 1994-2012 Lua.org, PUC-Rio
R. Ierusalimschy, L. H. de Figueiredo &amp; W. Celes
&nbsp;
mocniny cisla 2
0       1
1       2
2       4
3       8
4       16
5       32
6       64
7       128
8       256
9       512
10      1024
11      2048
12      4096
13      8192
14      16384
15      32768
16      65536
&nbsp;
mocniny cisla 3
0       1
1       3
2       9
3       27
4       81
5       243
6       729
7       2187
8       6561
9       19683
10      59049
11      177147
12      531441
13      1594323
14      4782969
15      14348907
16      43046721
&nbsp;
mocniny cisla 10
0       1
1       10
2       100
3       1000
4       10000
5       100000
6       1000000
7       10000000
8       100000000
9       1000000000
10      10000000000
11      100000000000
12      1000000000000
13      10000000000000
14      1e+14
15      1e+15
16      1e+16
</pre>

<p>Makefile je prakticky shodný s&nbsp;předchozími dvěma příklady.</p>



<p><a name="k052"></a></p>
<h3 id="k052">5.2 Čtvrtý demonstrační příklad &ndash; spuštění skriptu uloženého v&nbsp;externím souboru</h3>

<p>Ve čtvrtém demonstračním příkladu je ukázán mnohem častěji používaný způsob
spuštění skriptu, jehož kód je uložen v&nbsp;externím souboru (a ne
v&nbsp;řetězci, jak tomu bylo v&nbsp;příkladu předchozím). Externě uložený
skript je buď možné programově načíst do céčkového řetězce, ovšem to je poměrně
komplikované (musí se například předem zjišťovat délka řetězce, alokovat paměť
pro řetězec atd.). Jednodušší je použít již odladěnou knihovní funkci nazvanou
<strong>luaL_dofile()</strong>, která načtení, překlad i spuštění skriptu
provede automaticky. Návratovou hodnotou této funkce se signalizuje, zda skript
proběhl korektně nebo zda v&nbsp;průběhu jeho načítání, překladu, spuštění či
běhu došlo k&nbsp;nějaké chybě: v&nbsp;případě korektního běhu se vrátí nula,
pokud nastane chyba, vrátí se jednička. Chybu je také možné vygenerovat
programově, tj.&nbsp;ve skriptu, zavoláním funkce <i>error()</i>, popřípadě
z&nbsp;céčkové funkce zavoláním <strong>lua_error()</strong> (řetězec
obsahující chybové hlášení musí být v&nbsp;tomto případě uložen na zásobníku,
což si ukážeme v&nbsp;následujících kapitolách). Zdrojový kód druhého
demonstračního příkladu má následující tvar:</p>

<pre>
<i>/*</i>
<i> * Ctvrty demonstracni priklad - spusteni skriptu napsaneho</i>
<i> * v programovacim jazyce Lua, ktery je ulozeny v externim</i>
<i> * souboru.</i>
<i> */</i>
&nbsp;
#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;
&nbsp;
<i>/* Zakladni a doplnkove funkce interpretu jazyka Lua */</i>
#include &lt;lualib.h&gt;
#include &lt;lauxlib.h&gt;
&nbsp;
<i>/* Hlavni funkce konzolove aplikace */</i>
int main(int argc, char **argv)
{
    <i>/* navratova hodnota ziskana po zavolani skriptu */</i>
    int result;
&nbsp;
    <i>/* kontrola, zda je zadano jmeno skriptu */</i>
    if (argc != 2)
    {
        puts("Pouziti: ./lua_c_4 script.lua");
        return 1;
    }
&nbsp;
    <i>/* vytisteni hlavicky */</i>
    puts(LUA_RELEASE);
    puts(LUA_COPYRIGHT);
    puts(LUA_AUTHORS);
    putchar('\n');
&nbsp;
    <i>/* vytvoreni objektu, do nejz se uklada stav virtualniho stroje */</i>
    lua_State* L = luaL_newstate();
    <i>/* nacteme zakladni knihovnu obsahujici mj. i funkci print() */</i>
    luaopen_base(L);
    <i>/* nacteni externiho skriptu, jeho preklad a nasledne spusteni */</i>
    result = luaL_dofile(L, argv[1]);
&nbsp;
    <i>/* odstraneni vsech objektu asociovanych se stavem "Lua" */</i>
    lua_close(L);
    if (result != 0)
    {
        printf("Error # %d\n", result);
    }
    <i>/* vypocet navratoveho kodu */</i>
    return (result != 0);
}
&nbsp;
<i>/* finito */</i>
</pre>

<p>Skript naprogramovaný v&nbsp;jazyce Lua, jenž je možné využít pro otestování
dnešního čtvrtého demonstračního příkladu:</p>

<pre>
<i>-- Testovaci skript pro ctvrty demonstracni priklad</i>
<i>-- pouziti uzaveru</i>
&nbsp;
<i>-- pomocna funkce vracejici uzaver</i>
<strong>function</strong> defPosloupnosti(n)
    <i>-- pamatovana hodnota, ktera vsak</i>
    <i>-- neni z okolniho programu dostupna</i>
    <strong>local</strong> y = 1
    <i>-- pocitadlo volani = exponent</i>
    <strong>local</strong> index = 0
    <i>-- anonymni funkce vytiskne pamatovanou</i>
    <i>-- hodnotu a nakonec ji vynasobi zvolenou konstantou</i>
    <strong>return</strong> <strong>function</strong>()
        print(index, y)
        y = y * n
        index = index + 1
    <strong>end</strong>
<strong>end</strong>
&nbsp;
print("mocniny cisla 2")
<i>-- ziskani uzaveru</i>
generator = defPosloupnosti(2)
&nbsp;
<i>-- postupne se budou tisknout</i>
<i>-- mocniny cisla 2</i>
<strong>for</strong> i=0, 16 <strong>do</strong>
    generator()
<strong>end</strong>
&nbsp;
print()
&nbsp;
print("mocniny cisla 3")
<i>-- ziskani uzaveru</i>
generator = defPosloupnosti(3)
&nbsp;
<i>-- postupne se budou tisknout</i>
<i>-- mocniny cisla 3</i>
<strong>for</strong> i=0, 16 <strong>do</strong>
    generator()
<strong>end</strong>
&nbsp;
print()
&nbsp;
print("mocniny cisla 10")
<i>-- ziskani uzaveru</i>
generator = defPosloupnosti(10)
&nbsp;
<i>-- postupne se budou tisknout</i>
<i>-- mocniny cisla 3</i>
<strong>for</strong> i=0, 16 <strong>do</strong>
    generator()
<strong>end</strong>
&nbsp;
<i>-- finito</i>
</pre>

<p>Po spuštění by měl standardní výstup vypadat takto:</p>

<pre>
Lua 5.1.5
Copyright (C) 1994-2012 Lua.org, PUC-Rio
R. Ierusalimschy, L. H. de Figueiredo &amp; W. Celes
&nbsp;
mocniny cisla 2
0       1
1       2
2       4
3       8
4       16
5       32
6       64
7       128
8       256
9       512
10      1024
11      2048
12      4096
13      8192
14      16384
15      32768
16      65536
&nbsp;
mocniny cisla 3
0       1
1       3
2       9
3       27
4       81
5       243
6       729
7       2187
8       6561
9       19683
10      59049
11      177147
12      531441
13      1594323
14      4782969
15      14348907
16      43046721
&nbsp;
mocniny cisla 10
0       1
1       10
2       100
3       1000
4       10000
5       100000
6       1000000
7       10000000
8       100000000
9       1000000000
10      10000000000
11      100000000000
12      1000000000000
13      10000000000000
14      1e+14
15      1e+15
16      1e+16
</pre>



<p><a name="k06"></a></p>
<h2 id="k06">6. Komunikace C &rarr; Lua</h2>

<p>V&nbsp;mnoha případech je nutné z&nbsp;programovacího jazyka C či C++
zavolat funkci naprogramovanou v&nbsp;Lue, popř.&nbsp;zavolat nějakou knihovní
funkci z&nbsp;Luy. Právě v&nbsp;těchto případech se setkáme s&nbsp;programovým
rozhraním C &rarr; Lua založeném na zásobníku, přes který se předávají
parametry a návratové hodnoty (v&nbsp;Lue lze z&nbsp;funkce vrátit několik
návratových hodnot). Základem při volání funkcí naprogramovaných v&nbsp;jazyku
Lua je:</p>

<ul>

<li>Céčková funkce <strong>lua_getglobal()</strong> sloužící pro získání
reference na volanou funkci (reference se stane součástí <i>stavu</i>
virtuálního stoje, není ji zapotřebí nikam ukládat.</li>

<li>Céčková funkce <strong>lua_pushinteger()</strong> pro uložení celočíselné
hodnoty na zásobník.</li>

<li>Další funkce se stejným významem, ale odlišným datovým typem:
<strong>lua_pushnil, lua_pushnumber, lua_pushinteger, lua_pushunsigned,
lua_pushlstring, lua_pushstring, lua_pushvfstring, lua_pushfstring,
lua_pushcclosure, lua_pushboolean, lua_pushlightuserdata,
lua_pushthread,</strong></li>

<li>Funkce <strong>lua_call()</strong> či <strong>lua_pcall()</strong> pro
zavolání Lua kódu.</li>

<li><strong>lua_pop()</strong> pro odstranění návratové hodnoty (hodnot) ze
zásobníku.</li>

</ul>



<p><a name="k061"></a></p>
<h3 id="k061">6.1 Pátý demonstrační příklad &ndash; zavolání funkce ze standardní knihovny jazyka Lua z&nbsp;C</h3>

<p>V&nbsp;pátém demonstračním příkladu je z&nbsp;céčka zavolána funkce
<strong>print(42)</strong>. Nejprve je nutné s&nbsp;využitím
<strong>lua_getglobal()</strong> získat referenci na <strong>print()</strong>,
posléze se přes <strong>lua_pushinteger()</strong> na zásobník uloží hodnota
42, která se má tisknout a následně je funkce zavolána s&nbsp;využitím
<strong>lua_pcall()</strong> (<i>protected call</i>). Parametry lua_pcall(L, 1,
0, 0) znamenají, že se předává jeden argument a neočekává se žádná návratová
hodnota:</p>

<pre>
<i>/*</i>
<i> * Paty demonstracni priklad - zavolani funkce ze standardni</i>
<i> * knihovny Lua z jazyka C.</i>
<i> */</i>
&nbsp;
#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;
&nbsp;
<i>/* Zakladni a doplnkove funkce interpretu jazyka Lua */</i>
#include &lt;lualib.h&gt;
#include &lt;lauxlib.h&gt;
&nbsp;
<i>/* Hlavni funkce konzolove aplikace */</i>
int main(void)
{
    int result;
&nbsp;
    <i>/* vytisteni hlavicky */</i>
    puts(LUA_RELEASE);
    puts(LUA_COPYRIGHT);
    puts(LUA_AUTHORS);
    putchar('\n');
&nbsp;
    <i>/* vytvoreni objektu, do nejz se uklada stav virtualniho stroje */</i>
    lua_State* L = luaL_newstate();
    printf("State: %p\n", L);
&nbsp;
    <i>/* nacteni vsech knihoven */</i>
    luaL_openlibs(L);
&nbsp;
    <i>/* bude se volat funkce pojmenovana "print" */</i>
    lua_getglobal(L, "print");
    <i>/* ulozit parametr volane funkce na zasobnik */</i>
    lua_pushinteger(L, 42);
    <i>/* zavolani funkce "print" a predani jednoho parametru */</i>
    <i>/* neocekavame pritom zadne vysledne hodnoty */</i>
    result = lua_pcall(L, 1, 0, 0);
    <i>/* kontrola volani funkce */</i>
    if (result) {
        lua_error(L);
        puts("Chyba pri volani funkce print()!");
    }
&nbsp;
    <i>/* odstraneni vsech objektu asociovanych se stavem "Lua" */</i>
    lua_close(L);
&nbsp;
    <i>/* navratovy kod */</i>
    return 0;
}
&nbsp;
<i>/* finito */</i>
</pre>

<p>Výstup tohoto demonstračního příkladu vypadá následovně:</p>

<pre>
Lua 5.1.5
Copyright (C) 1994-2012 Lua.org, PUC-Rio
R. Ierusalimschy, L. H. de Figueiredo &amp; W. Celes
&nbsp;
State: 0x22dd010
42
</pre>



<p><a name="k062"></a></p>
<h3 id="k062">6.2 Šestý demonstrační příklad &ndash; předání dvou parametrů různých typů volané funkci</h3>

<p>V&nbsp;dalším příkladu je ukázáno, jak se volané Lua funkci předává větší
množství parametrů, zde konkrétně celočíselná hodnota a řetězec. Nejdůležitější
je si uvědomit, že se parametry na zásobník ukládají v&nbsp;tom pořadí,
v&nbsp;jakém by se předávaly volané funkci ve skriptu. Dále je pak nutné
správně označit počet skutečně předávaných parametrů při volání
<strong>lua_pcall()</strong>, protože virtuální stroj Luy nemá žádnou jinou
možnost, jak počet parametrů jinak zjistit (existují Lua funkce akceptující
proměnný počet parametrů apod.). Podívejme se na kód příkladu, z&nbsp;něhož
bude vše patrné:</p>

<pre>
<i>/*</i>
<i> * Sesty demonstracni priklad - zavolani funkce ze standardni</i>
<i> * knihovny Lua z jazyka C.</i>
<i> */</i>
&nbsp;
#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;
&nbsp;
<i>/* Zakladni a doplnkove funkce interpretu jazyka Lua */</i>
#include &lt;lualib.h&gt;
#include &lt;lauxlib.h&gt;
&nbsp;
<i>/* Hlavni funkce konzolove aplikace */</i>
int main(void)
{
    int result;
&nbsp;
    <i>/* vytisteni hlavicky */</i>
    puts(LUA_RELEASE);
    puts(LUA_COPYRIGHT);
    puts(LUA_AUTHORS);
    putchar('\n');
&nbsp;
    <i>/* vytvoreni objektu, do nejz se uklada stav virtualniho stroje */</i>
    lua_State* L = luaL_newstate();
    printf("State: %p\n", L);
&nbsp;
    <i>/* nacteni vsech knihoven */</i>
    luaL_openlibs(L);
&nbsp;
    <i>/* bude se volat funkce pojmenovana "print" */</i>
    lua_getglobal(L, "print");
    <i>/* ulozit prvni parametr volane funkce na zasobnik */</i>
    lua_pushinteger(L, 42);
    <i>/* ulozit druhy parametr volane funkce na zasobnik */</i>
    lua_pushstring(L, "Hello world!");
    <i>/* zavolani funkce print a predani dvou parametru */</i>
    <i>/* neocekavame pritom zadne vysledne hodnoty */</i>
    result = lua_pcall(L, 2, 0, 0);
    <i>/* kontrola volani funkce */</i>
    if (result) {
        lua_error(L);
        puts("Chyba pri volani funkce print()!");
    }
&nbsp;
    <i>/* odstraneni vsech objektu asociovanych se stavem "Lua" */</i>
    lua_close(L);
&nbsp;
    <i>/* navratovy kod */</i>
    return 0;
}
&nbsp;
<i>/* finito */</i>
</pre>

<p>Výstup tohoto demonstračního příkladu vypadá následovně:</p>

<pre>
Lua 5.1.5
Copyright (C) 1994-2012 Lua.org, PUC-Rio
R. Ierusalimschy, L. H. de Figueiredo &amp; W. Celes
&nbsp;
State: 0x2457010
42      Hello world!
</pre>



<p><a name="k063"></a></p>
<h3 id="k063">6.3 Sedmý demonstrační příklad &ndash; přečtení návratové hodnoty Lua funkce</h3>

<p>V&nbsp;sedmém demonstračním příkladu se z&nbsp;nativního kódu volá Lua
funkce <strong>tonumber()</strong>, která převede svůj parametr (řetězec) na
číslo. Setkáme se zde tedy jak s&nbsp;předáním parametru volané funkci, tak i
se zpracováním výsledku (návratové) hodnoty této funkce, což je zohledněno ve
volání <strong>lua_pcall(L, 1, 1, 0)</strong>:</p>

<pre>
<i>/*</i>
<i> * Sedmy demonstracni priklad - zavolani funkce ze standardni</i>
<i> * knihovny Lua z jazyka C a precteni navratove hodnoty.</i>
<i> */</i>
&nbsp;
#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;
&nbsp;
<i>/* Zakladni a doplnkove funkce interpretu jazyka Lua */</i>
#include &lt;lualib.h&gt;
#include &lt;lauxlib.h&gt;
&nbsp;
<i>/* Hlavni funkce konzolove aplikace */</i>
int main(void)
{
    int result;
&nbsp;
    <i>/* vytisteni hlavicky */</i>
    puts(LUA_RELEASE);
    puts(LUA_COPYRIGHT);
    puts(LUA_AUTHORS);
    putchar('\n');
&nbsp;
    <i>/* vytvoreni objektu, do nejz se uklada stav virtualniho stroje */</i>
    lua_State* L = luaL_newstate();
    printf("State: %p\n", L);
&nbsp;
    <i>/* nacteni vsech knihoven */</i>
    luaL_openlibs(L);
&nbsp;
    <i>/* bude se volat funkce pojmenovana "tonumber" */</i>
    lua_getglobal(L, "tonumber");
    <i>/* ulozit parametr volane funkce na zasobnik */</i>
    lua_pushstring(L, "42");
    <i>/* zavolani funkce print a predani parametru */</i>
    result = lua_pcall(L, 1, 1, 0);
    <i>/* kontrola volani funkce */</i>
    if (result) {
        lua_error(L);
        puts("Chyba pri volani funkce print()!");
    }
    <i>/* ziskani vysledku */</i>
    printf("Result is: %d\n", (int)lua_tointeger(L, 0));
    lua_pop(L, 1);
&nbsp;
    <i>/* odstraneni vsech objektu asociovanych se stavem "Lua" */</i>
    lua_close(L);
&nbsp;
    <i>/* navratovy kod */</i>
    return 0;
}
&nbsp;
<i>/* finito */</i>
</pre>

<pre>
Lua 5.1.5
Copyright (C) 1994-2012 Lua.org, PUC-Rio
R. Ierusalimschy, L. H. de Figueiredo &amp; W. Celes
&nbsp;
State: 0x1642010
Result is: 42
</pre>



<p><a name="k07"></a></p>
<h2 id="k07">7. Komunikace Lua &rarr; C</h2>

<p>Jednou z&nbsp;nejdůležitějších funkcí API je zajištění předávání parametrů
do céčkové funkce a návratu vypočtených hodnot zpět do <i>Lua</i> skriptu.
Vzhledem k&nbsp;tomu, že v&nbsp;jazyku <i>Lua</i> se typy parametrů odvozují
z&nbsp;hodnot uložených do proměnných, není možné již v&nbsp;době překladu
provést stoprocentní typovou kontrolu &ndash; tu je nutné ponechat až na dobu
běhu (<i>runtime</i>). Pro usnadnění práce s&nbsp;parametry předávanými ze
skriptu do céčkové (C++) aplikace je k&nbsp;dispozici několik funkcí, především
<strong>lua_gettop()</strong> (počet předaných parametrů) a sada funkcí pro
zjištění skutečného typu <i>i</i>-tého parametru:
<strong>lua_isnumber()</strong>, <strong>lua_isstring()</strong>,
<strong>lua_iscfunction()</strong> atd.</p>

<p>Kromě toho existují ještě konverzní funkce typu
<strong>lua_tonumber()</strong>, <strong>lua_tointeger()</strong> či
<strong>lua_tolstring()</strong>, pomocí nichž lze parametry konvertovat. Pro
návrat hodnot z&nbsp;céčkové funkce do skriptu je určený zásobník vytvořený
interpretem, jelikož v&nbsp;<i>Lua</i> je možné vracet hodnot několik. Pro
ukládání hodnot do tohoto zásobníku slouží funkce typu
<strong>lua_pushstring()</strong> a <strong>lua_pushnumber()</strong>. Nesmíme
také zapomenout na to, že céčková funkce musí vrátit (příkazem
<strong>return</strong>) celkový počet parametrů uložených na zásobník.</p>



<p><a name="k071"></a></p>
<h3 id="k071">7.1 Osmý demonstrační příklad &ndash; zavolání céčkové funkce ze skriptu</h3>

<p>V&nbsp;následujícím demonstračním příkladu si ukážeme, jakým způsobem je
možné předávat parametry céčkové funkci, i to, jak lze kontrolovat počet i typ
parametrů a způsob předávání návratových hodnot zpět do <i>Lua</i> skriptu.
V&nbsp;příkladu je vytvořena funkce nazvaná <strong>gcd()</strong>, pomocí níž
je možné vypočítat největší společný dělitel (<i>greatest common divisor</i>)
dvou celých čísel Euklidovým algoritmem, přičemž první číslo by mělo být větší
než druhé. Tato funkce je zaregistrována pro možnost jejího zavolání
z&nbsp;<i>Lua</i> skriptu. Po svém zavolání si funkce nejprve zkontroluje počet
a typ parametrů a pouze tehdy, když jsou funkci předány dva parametry typu
číslo, je funkce provedena. Výsledkem výpočtu je dvojice hodnot &ndash;
největší společný dělitel a počet iterací Euklidova algoritmu, které bylo
zapotřebí provést pro nalezení výsledku. Obě hodnoty jsou uloženy na zásobník
vytvořený interpretem jazyka <i>Lua</i>; návratová hodnota funkce
<strong>gcd()</strong> pak udává počet uložených výsledků (tj.&nbsp;vlastně
hloubku zaplněného zásobníku). Zdrojový kód tohoto demonstračního příkladu má
tvar:</p>

<pre>
<i>/*</i>
<i> * Osmy demonstracni priklad - zavolani ceckove funkce</i>
<i> * z Lua skriptu.</i>
<i> */</i>
&nbsp;
#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;
&nbsp;
<i>/* Zakladni a doplnkove funkce interpretu jazyka Lua */</i>
#include &lt;lualib.h&gt;
#include &lt;lauxlib.h&gt;
&nbsp;
<i>/* Vypocet nejvetsiho spolecneho delitele */</i>
static int gcd(lua_State* L)
{
    int x, y, iter = 1;
    <i>/* zjistit pocet parametru pri volani funkce */</i>
    if (lua_gettop(L) != 2)
    {
        lua_pushstring(L, "incorrect argument");
        lua_error(L);
    }
    <i>/* kontrola typu obou parametru */</i>
    if (!lua_isnumber(L, 1))
    {
        lua_pushstring(L, "incorrect first argument");
        lua_error(L);
    }
    if (!lua_isnumber(L, 2))
    {
        lua_pushstring(L, "incorrect second argument");
        lua_error(L);
    }
&nbsp;
    <i>/* nacist parametry */</i>
    x = lua_tonumber(L, 1);
    y = lua_tonumber(L, 2);
&nbsp;
    <i>/* vypocet nejvetsiho spolecneho delitele */</i>
    while (x % y &gt; 0)
    {
        int pom = y;
        y = x % y;
        x = pom;
        iter ++;
    }
&nbsp;
    <i>/* prvni vysledek */</i>
    lua_pushnumber(L, y);
&nbsp;
    <i>/* druhy vysledek */</i>
    lua_pushnumber(L, iter);
&nbsp;
    <i>/* ulozit pocet vysledku na zasobniku */</i>
    return 2;
}
&nbsp;
<i>/* Hlavni funkce konzolove aplikace */</i>
int main(int argc, char **argv)
{
    <i>/* navratova hodnota ziskana po zavolani skriptu */</i>
    int result;
&nbsp;
    <i>/* kontrola, zda je na CLI zadano jmeno skriptu */</i>
    if (argc != 2)
    {
        puts("Pouziti: ./lua_c_8 script.lua");
        return 1;
    }
&nbsp;
    <i>/* vytisteni hlavicky */</i>
    puts(LUA_RELEASE);
    puts(LUA_COPYRIGHT);
    puts(LUA_AUTHORS);
    putchar('\n');
&nbsp;
    <i>/* vytvoreni objektu, do nejz se uklada stav virtualniho stroje */</i>
    lua_State* L = luaL_newstate();
    <i>/* nacteme zakladni knihovnu obsahujici mj. i funkci print() */</i>
    luaopen_base(L);
&nbsp;
    <i>/* registrace ceckove funkce gcd() pod jmenem "gcd" */</i>
    lua_register(L, "gcd", gcd);
&nbsp;
    <i>/* nacteni externiho skriptu, jeho preklad a nasledne spusteni */</i>
    result = luaL_dofile(L, argv[1]);
&nbsp;
    <i>/* odstraneni vsech objektu asociovanych se stavem "Lua" */</i>
    lua_close(L);
    if (result != 0)
    {
        printf("Error # %d\n", result);
    }
    <i>/* vypocet navratoveho kodu */</i>
    return (result != 0);
}
&nbsp;
<i>/* finito */</i>
</pre>

<p>Testovací skript:</p>

<pre>
<i>-- Testovaci skript pro osmy demonstracni priklad</i>
&nbsp;
print("i", "j", "gcd(i,j)", "#of iterations")
&nbsp;
<strong>for</strong> i=1, 12 <strong>do</strong>
    <strong>for</strong> j=1, i <strong>do</strong>
        <i>-- funkce gcd() vraci dvojici hodnot</i>
        result, iter = gcd(i, j)
        print(i, j, result, iter)
    <strong>end</strong>
<strong>end</strong>
&nbsp;
<i>-- finito</i>
</pre>

<p>Podívejme se, co se stane po spuštění tohoto příkladu:</p>

<pre>
Lua 5.1.5
Copyright (C) 1994-2012 Lua.org, PUC-Rio
R. Ierusalimschy, L. H. de Figueiredo &amp; W. Celes
&nbsp;
i       j       gcd(i,j)        #of iterations
1       1          1            1
2       1          1            1
2       2          2            1
3       1          1            1
3       2          1            2
3       3          3            1
4       1          1            1
4       2          2            1
4       3          1            2
4       4          4            1
5       1          1            1
5       2          1            2
5       3          1            3
5       4          1            2
5       5          5            1
6       1          1            1
6       2          2            1
6       3          3            1
6       4          2            2
6       5          1            2
6       6          6            1
7       1          1            1
7       2          1            2
7       3          1            2
7       4          1            3
7       5          1            3
7       6          1            2
7       7          7            1
8       1          1            1
8       2          2            1
8       3          1            3
8       4          4            1
8       5          1            4
8       6          2            2
8       7          1            2
8       8          8            1
9       1          1            1
9       2          1            2
9       3          3            1
9       4          1            2
9       5          1            3
9       6          3            2
9       7          1            3
9       8          1            2
9       9          9            1
10      1          1            1
10      2          2            1
10      3          1            2
10      4          2            2
10      5          5            1
10      6          2            3
10      7          1            3
10      8          2            2
10      9          1            2
10      10         10           1
11      1          1            1
11      2          1            2
11      3          1            3
11      4          1            3
11      5          1            2
11      6          1            3
11      7          1            4
11      8          1            4
11      9          1            3
11      10         1            2
11      11         11           1
12      1          1            1
12      2          2            1
12      3          3            1
12      4          4            1
12      5          1            3
12      6          6            1
12      7          1            4
12      8          4            2
12      9          3            2
12      10         2            2
12      11         1            2
12      12         12           1
</pre>



<p><a name="k08"></a></p>
<h2 id="k08">8. Alternativní způsob komunikace mezi jazykem Lua a nativním kódem: knihovna <strong>FFI</strong></h2>

<p>Způsob kooperace mezi skripty naprogramovanými v&nbsp;jazyce Lua a nativním
kódem, který jsme si popsali v&nbsp;předchozích kapitolách, je bezpečný a
poměrně snadno pochopitelný. Ovšem s&nbsp;velkou pravděpodobností se nejedná o
způsob, který by vývojář preferoval ve chvíli, kdy potřebuje z&nbsp;jazyka Lua
volat množství funkcí z&nbsp;nějaké nativní knihovny (příkladem může být
knihovna <i>OpenGL</i> s&nbsp;desítkami funkcí). Naštěstí je možné v&nbsp;mnoha
aplikacích použít alternativní způsob volání nativních knihoven, a to
s&nbsp;využitím knihovny nazvané <strong>FFI</strong> (<i>Foreign Function
Interface</i>), která je součástí <i>LuaJITu</i>. Při použití
<strong>FFI</strong> je pouze nutné specifikovat hlavičky volaných funkcí (a to
včetně specifikace datových typů) a následně se tyto funkce již dají jednoduše
volat stylem <strong>ffi.C.jméno_funkce(parametry)</strong>, přičemž o
případnou konverzi předávaných parametrů se již programátor ve většině případů
nemusí starat (připomeňme si, že ještě v&nbsp;Lua 5.2 se používá jen jediný
formát numerických hodnot atd.).</p>

<a href="http://www.root.cz/obrazek/215995/"><img src="http://i.iinfo.cz/images/498/lua3.png" class="image-215995" alt="&#160;" height="200" width="325" /></a>
<p><i>Obrázek 3: Způsob využití FFI při volání funkcí uložených
v&nbsp;nativních knihovnách.</i></p>



<p><a name="k081"></a></p>
<h3 id="k081">8.1 Devátý demonstrační příklad &ndash; základ použití knihovny <strong>FFI</strong></h3>

<p>Podívejme se na způsob použití <strong>FFI</strong> v&nbsp;praxi.
Předpokládejme, že potřebujeme volat céčkovou funkci nazvanou
<strong>rand()</strong>, které se nepředávají žádné parametry. Nejprve je nutné
explicitně knihovnu <strong>FFI</strong> načíst, což zajišťuje první řádek
skriptu. Následně se musí zapsat hlavička nativní funkce či funkcí, které se
budou z&nbsp;Lua skriptu volat (řádek začínající na <strong>ffi.cdef</strong>.
Samotné volání nativní funkce je již jednoduché: <strong>ffi.C.rand()</strong>,
výsledek (návratová hodnota) je uložena do lokální proměnné nazvané
<strong>random</strong>:</p>

<pre>
<i>-- Prvni demonstracni priklad vyuzivajici knihovnu FFI</i>
&nbsp;
<strong>local</strong> ffi = require("ffi")
&nbsp;
<i>-- Definice ceckovske funkce ze standardni knihovny</i>
&nbsp;
ffi.cdef[[
int rand(void);
]]
&nbsp;
<strong>for</strong> i=0,10 <strong>do</strong>
    <i>-- Zavolani ceckovske funkce</i>
    <strong>local</strong> random = ffi.C.rand()
    print(random)
<strong>end</strong>
</pre>

<p>Tento příklad je nutné spustit <i>LuaJITem</i>!. Příklad výstupu:</p>

<pre>
1804289383
846930886
1681692777
1714636915
1957747793
424238335
719885386
1649760492
596516649
1189641421
1025202362
</pre>

<p>Při pokusu o použití klasického interpretru jazyka Lua dostaneme pouze
chybové hlášení:</p>

<pre>
$ lua ffi_example1.lua 
&nbsp;
lua: ffi_example1.lua:3: module 'ffi' not found:
        no field package.preload['ffi']
        no file '/usr/local/share/lua/5.2/ffi.lua'
        no file '/usr/local/share/lua/5.2/ffi/init.lua'
        no file '/usr/local/lib/lua/5.2/ffi.lua'
        no file '/usr/local/lib/lua/5.2/ffi/init.lua'
        no file '/usr/share/lua/5.2/ffi.lua'
        no file '/usr/share/lua/5.2/ffi/init.lua'
        no file './ffi.lua'
        no file '/usr/local/lib/lua/5.2/ffi.so'
        no file '/usr/lib/x86_64-linux-gnu/lua/5.2/ffi.so'
        no file '/usr/lib/lua/5.2/ffi.so'
        no file '/usr/local/lib/lua/5.2/loadall.so'
        no file './ffi.so'
stack traceback:
        [C]: in function 'require'
        ffi_example1.lua:3: in main chunk
        [C]: in ?
</pre>



<p><a name="k082"></a></p>
<h3 id="k082">8.2 Desátý demonstrační příklad &ndash; volání složitější funkce</h3>

<p>V&nbsp;dalším demonstračním příkladu je knihovna <strong>FFI</strong>
použita pro zavolání funkce nazvané <strong>atoi()</strong>, která je součástí
standardní knihovny programovacího jazyka C. Funkce <strong>atoi()</strong> již
akceptuje (čti vyžaduje) parametr typu řetězec, což je v&nbsp;případě
programovacího jazyka C datový typ <strong>const char *</strong>, tedy ukazatel
na první znak řetězce (klíčové slovo const zde může pomáhat překladači při
optimalizacích a navíc &ndash; což je důležitější &ndash; nám říká, že funkce
řetězec nebude modifikovat). Při volání funkce <strong>atoi()</strong> ze
skriptu napsaného v&nbsp;Lua se automaticky provede konverze mezi Lua stringem
a céčkovým řetězcem:</p>

<pre>
<i>-- Druhy demonstracni priklad vyuzivajici knihovnu FFI</i>
&nbsp;
<strong>local</strong> ffi = require("ffi")
&nbsp;
<i>-- Definice ceckovske funkce ze standardni knihovny</i>
&nbsp;
ffi.cdef[[
int atoi(const char *);
]]
&nbsp;
<i>-- Zavolani ceckovske funkce</i>
<strong>local</strong> value = ffi.C.atoi("42")
&nbsp;
print(value)
</pre>

<p>Složitějšími případy, konverzemi dat apod. se budeme zabývat příště.</p>



<p><a name="k09"></a></p>
<h2 id="k09">9. Repositář s&nbsp;dnešními demonstračními příklady</h2>

<p>Všech deset dnes popsaných demonstračních příkladů bylo uloženo do Git
repositáře dostupného na adrese <a
href="https://github.com/tisnik/luajit-examples">https://github.com/tisnik/luajit-examples</a>.
V&nbsp;tabulce zobrazené pod tímto odstavcem naleznete na zdrojové kódy
jednotlivých demonstračních příkladů přímé odkazy:</p>

<table>
<tr><th> #</th><th>Příklad </th><th>Github</th></tr>
<tr><td> 1</td><td>lua_c_1</td><td><a href="https://github.com/tisnik/luajit-examples/tree/master/lua_c/lua_c_1">https://github.com/tisnik/luajit-examples/tree/master/lua_c/lua_c_1</a></td></tr>
<tr><td> 2</td><td>lua_c_2</td><td><a href="https://github.com/tisnik/luajit-examples/tree/master/lua_c/lua_c_2">https://github.com/tisnik/luajit-examples/tree/master/lua_c/lua_c_2</a></td></tr>
<tr><td> 3</td><td>lua_c_3</td><td><a href="https://github.com/tisnik/luajit-examples/tree/master/lua_c/lua_c_3">https://github.com/tisnik/luajit-examples/tree/master/lua_c/lua_c_3</a></td></tr>
<tr><td> 4</td><td>lua_c_4</td><td><a href="https://github.com/tisnik/luajit-examples/tree/master/lua_c/lua_c_4">https://github.com/tisnik/luajit-examples/tree/master/lua_c/lua_c_4</a></td></tr>
<tr><td> 5</td><td>lua_c_5</td><td><a href="https://github.com/tisnik/luajit-examples/tree/master/lua_c/lua_c_5">https://github.com/tisnik/luajit-examples/tree/master/lua_c/lua_c_5</a></td></tr>
<tr><td> 6</td><td>lua_c_6</td><td><a href="https://github.com/tisnik/luajit-examples/tree/master/lua_c/lua_c_6">https://github.com/tisnik/luajit-examples/tree/master/lua_c/lua_c_6</a></td></tr>
<tr><td> 7</td><td>lua_c_7</td><td><a href="https://github.com/tisnik/luajit-examples/tree/master/lua_c/lua_c_7">https://github.com/tisnik/luajit-examples/tree/master/lua_c/lua_c_7</a></td></tr>
<tr><td> 8</td><td>lua_c_8</td><td><a href="https://github.com/tisnik/luajit-examples/tree/master/lua_c/lua_c_8">https://github.com/tisnik/luajit-examples/tree/master/lua_c/lua_c_8</a></td></tr>
<tr><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td></tr>
<tr><td> 9</td><td>ffi_example1</td><td><a href="https://github.com/tisnik/luajit-examples/blob/master/ffi/ffi_example1.lua">https://github.com/tisnik/luajit-examples/blob/master/ffi/ffi_example1.lua</a></td></tr>
<tr><td>10</td><td>ffi_example2</td><td><a href="https://github.com/tisnik/luajit-examples/blob/master/ffi/ffi_example2.lua">https://github.com/tisnik/luajit-examples/blob/master/ffi/ffi_example2.lua</a></td></tr>
</table>



<p><a name="k10"></a></p>
<h2 id="k10">10. Odkazy na Internetu</h2>

<ol>

<li>LuaJIT - Just in Time překladač pro programovací jazyk Lua<br />
<a href="http://www.root.cz/clanky/luajit-just-in-time-prekladac-pro-programovaci-jazyk-lua/">http://www.root.cz/clanky/luajit-just-in-time-prekladac-pro-programovaci-jazyk-lua/</a>
</li>

<li>LuaJIT - Just in Time překladač pro programovací jazyk Lua (2)<br />
<a href="http://www.root.cz/clanky/luajit-just-in-time-prekladac-pro-programovaci-jazyk-lua-2/">http://www.root.cz/clanky/luajit-just-in-time-prekladac-pro-programovaci-jazyk-lua-2/</a>
</li>

<li>LuaJIT - Just in Time překladač pro programovací jazyk Lua (3)<br />
<a href="http://www.root.cz/clanky/luajit-just-in-time-prekladac-pro-programovaci-jazyk-lua-3/">http://www.root.cz/clanky/luajit-just-in-time-prekladac-pro-programovaci-jazyk-lua-3/</a>
</li>

<li>LuaJIT - Just in Time překladač pro programovací jazyk Lua (4)<br />
<a href="http://www.root.cz/clanky/luajit-just-in-time-prekladac-pro-programovaci-jazyk-lua-4/">http://www.root.cz/clanky/luajit-just-in-time-prekladac-pro-programovaci-jazyk-lua-4/</a>
</li>

<li>LuaJIT - Just in Time překladač pro programovací jazyk Lua (5 - tabulky a pole)<br />
<a href="http://www.root.cz/clanky/luajit-just-in-time-prekladac-pro-programovaci-jazyk-lua-5-tabulky-a-pole/">http://www.root.cz/clanky/luajit-just-in-time-prekladac-pro-programovaci-jazyk-lua-5-tabulky-a-pole/</a>
</li>

<li>LuaJIT - Just in Time překladač pro programovací jazyk Lua (6 - překlad programových smyček do mezijazyka LuaJITu)<br />
<a href="http://www.root.cz/clanky/luajit-just-in-time-prekladac-pro-programovaci-jazyk-lua-6-preklad-programovych-smycek-do-mezijazyka-luajitu/">http://www.root.cz/clanky/luajit-just-in-time-prekladac-pro-programovaci-jazyk-lua-6-preklad-programovych-smycek-do-mezijazyka-luajitu/</a>
</li>

<li>LuaJIT - Just in Time překladač pro programovací jazyk Lua (7 - dokončení popisu mezijazyka LuaJITu)<br />
<a href="http://www.root.cz/clanky/luajit-just-in-time-prekladac-pro-programovaci-jazyk-lua-7-dokonceni-popisu-mezijazyka-luajitu/">http://www.root.cz/clanky/luajit-just-in-time-prekladac-pro-programovaci-jazyk-lua-7-dokonceni-popisu-mezijazyka-luajitu/</a>
</li>

<li>LuaJIT - Just in Time překladač pro programovací jazyk Lua (8 - základní vlastnosti trasovacího JITu)<br />
<a href="http://www.root.cz/clanky/luajit-just-in-time-prekladac-pro-programovaci-jazyk-lua-8-zakladni-vlastnosti-trasovaciho-jitu/">http://www.root.cz/clanky/luajit-just-in-time-prekladac-pro-programovaci-jazyk-lua-8-zakladni-vlastnosti-trasovaciho-jitu/</a>
</li>

<li>LuaJIT - Just in Time překladač pro programovací jazyk Lua (9 - další vlastnosti trasovacího JITu)<br />
<a href="http://www.root.cz/clanky/luajit-just-in-time-prekladac-pro-programovaci-jazyk-lua-9-dalsi-vlastnosti-trasovaciho-jitu/">http://www.root.cz/clanky/luajit-just-in-time-prekladac-pro-programovaci-jazyk-lua-9-dalsi-vlastnosti-trasovaciho-jitu/</a>
</li>

<li>LuaJIT - Just in Time překladač pro programovací jazyk Lua (10 - JIT překlad do nativního kódu)<br />
<a href="http://www.root.cz/clanky/luajit-just-in-time-prekladac-pro-programovaci-jazyk-lua-10-jit-preklad-do-nativniho-kodu/">http://www.root.cz/clanky/luajit-just-in-time-prekladac-pro-programovaci-jazyk-lua-10-jit-preklad-do-nativniho-kodu/</a>
</li>

<li>LuaJIT - Just in Time překladač pro programovací jazyk Lua (11 - JIT překlad do nativního kódu procesorů s architekturami x86 a ARM)<br />
<a href="http://www.root.cz/clanky/luajit-just-in-time-prekladac-pro-programovaci-jazyk-lua-11-jit-preklad-do-nativniho-kodu-procesoru-s-architekturami-x86-a-arm/">http://www.root.cz/clanky/luajit-just-in-time-prekladac-pro-programovaci-jazyk-lua-11-jit-preklad-do-nativniho-kodu-procesoru-s-architekturami-x86-a-arm/</a>
</li>

<li>LuaJIT - Just in Time překladač pro programovací jazyk Lua (12 - překlad operací s reálnými čísly)<br />
<a href="http://www.root.cz/clanky/luajit-just-in-time-prekladac-pro-programovaci-jazyk-lua-12-preklad-operaci-s-realnymi-cisly/">http://www.root.cz/clanky/luajit-just-in-time-prekladac-pro-programovaci-jazyk-lua-12-preklad-operaci-s-realnymi-cisly/</a>
</li>

<li>The Lua VM, on the Web<br />
<a href="https://kripken.github.io/lua.vm.js/lua.vm.js.html">https://kripken.github.io/lua.vm.js/lua.vm.js.html</a>
</li>

<li>Lua.vm.js REPL<br />
<a href="https://kripken.github.io/lua.vm.js/repl.html">https://kripken.github.io/lua.vm.js/repl.html</a>
</li>

<li>lua2js<br />
<a href="https://www.npmjs.com/package/lua2js">https://www.npmjs.com/package/lua2js</a>
</li>

<li>lua2js na GitHubu<br />
<a href="https://github.com/basicer/lua2js-dist">https://github.com/basicer/lua2js-dist</a>
</li>

<li>Seriál o programovacím jazyku Lua<br />
<a href="http://www.root.cz/serialy/programovaci-jazyk-lua/">http://www.root.cz/serialy/programovaci-jazyk-lua/</a>
</li>

<li>Source-to-source compiler<br />
<a href="https://en.wikipedia.org/wiki/Source-to-source_compiler">https://en.wikipedia.org/wiki/Source-to-source_compiler</a>
</li>

<li>JavaScript is Assembly Language for the Web: Sematic Markup is Dead! Clean vs. Machine-coded HTML<br />
<a href="http://www.hanselman.com/blog/JavaScriptIsAssemblyLanguageForTheWebSematicMarkupIsDeadCleanVsMachinecodedHTML.aspx">http://www.hanselman.com/blog/JavaScriptIsAssemblyLanguageForTheWebSematicMarkupIsDeadCleanVsMachinecodedHTML.aspx</a>
</li>

<li>JavaScript is Web Assembly Language and that's OK.<br />
<a href="http://www.hanselman.com/blog/JavaScriptIsWebAssemblyLanguageAndThatsOK.aspx">http://www.hanselman.com/blog/JavaScriptIsWebAssemblyLanguageAndThatsOK.aspx</a>
</li>

<li>Dart<br />
<a href="https://www.dartlang.org/">https://www.dartlang.org/</a>
</li>

<li>CoffeeScript<br />
<a href="http://coffeescript.org/">http://coffeescript.org/</a>
</li>

<li>TypeScript<br />
<a href="http://www.typescriptlang.org/">http://www.typescriptlang.org/</a>
</li>

<li>Lua (programming language)<br />
<a href="http://en.wikipedia.org/wiki/Lua_(programming_language)">http://en.wikipedia.org/wiki/Lua_(programming_language)</a>
</li>

<li>Static single assignment form (SSA)<br />
<a href="http://en.wikipedia.org/wiki/Static_single_assignment_form">http://en.wikipedia.org/wiki/Static_single_assignment_form</a>
</li>

<li>Wikipedia: Mezijazyk<br />
<a href="http://cs.wikipedia.org/wiki/Mezijazyk">http://cs.wikipedia.org/wiki/Mezijazyk</a>
</li>

<li>LuaJIT 2.0 SSA IR
<a href="http://wiki.luajit.org/SSA-IR-2.0">http://wiki.luajit.org/SSA-IR-2.0</a>
</li>

<li>The LuaJIT Project<br />
<a href="http://luajit.org/index.html">http://luajit.org/index.html</a>
</li>

<li>LuaJIT FAQ<br />
<a href="http://luajit.org/faq.html">http://luajit.org/faq.html</a>
</li>

<li>LuaJIT Performance Comparison<br />
<a href="http://luajit.org/performance.html">http://luajit.org/performance.html</a>
</li>

<li>LuaJIT 2.0 intellectual property disclosure and research opportunities<br />
<a href="http://article.gmane.org/gmane.comp.lang.lua.general/58908">http://article.gmane.org/gmane.comp.lang.lua.general/58908</a>
</li>

<li>LuaJIT Wiki<br />
<a href="http://wiki.luajit.org/Home">http://wiki.luajit.org/Home</a>
</li>

<li>LuaJIT 2.0 Bytecode Instructions<br />
<a href="http://wiki.luajit.org/Bytecode-2.0">http://wiki.luajit.org/Bytecode-2.0</a>
</li>

<li>Programming in Lua (first edition)<br />
<a href="http://www.lua.org/pil/contents.html">http://www.lua.org/pil/contents.html</a>
</li>

<li>Lua 5.2 sources<br />
<a href="http://www.lua.org/source/5.2/">http://www.lua.org/source/5.2/</a>
</li>

<li>Tcl Plugin Version 3<br />
<a href="http://www.tcl.tk/software/plugin/">http://www.tcl.tk/software/plugin/</a>
</li>

<li>JavaScript: The Web Assembly Language?<br />
<a href="http://www.informit.com/articles/article.aspx?p=1856657">http://www.informit.com/articles/article.aspx?p=1856657</a>
</li>

<li>asm.js<br />
<a href="http://asmjs.org/">http://asmjs.org/</a>
</li>

<li>List of languages that compile to JS<br />
<a href="https://github.com/jashkenas/coffeescript/wiki/List-of-languages-that-compile-to-JS">https://github.com/jashkenas/coffeescript/wiki/List-of-languages-that-compile-to-JS</a>
</li>

<li>REPL<br />
<a href="https://en.wikipedia.org/wiki/Read%E2%80%93eval%E2%80%93print_loop">https://en.wikipedia.org/wiki/Read%E2%80%93eval%E2%80%93print_loop</a>
</li>

<li>The LLVM Compiler Infrastructure<br />
<a href="http://llvm.org/ProjectsWithLLVM/">http://llvm.org/ProjectsWithLLVM/</a>
</li>

<li>clang: a C language family frontend for LLVM<br />
<a href="http://clang.llvm.org/">http://clang.llvm.org/</a>
</li>

<li>emscripten<br />
<a href="http://kripken.github.io/emscripten-site/">http://kripken.github.io/emscripten-site/</a>
</li>

<li>LLVM Backend ("Fastcomp")<br />
<a href="http://kripken.github.io/emscripten-site/docs/building_from_source/LLVM-Backend.html#llvm-backend">http://kripken.github.io/emscripten-site/docs/building_from_source/LLVM-Backend.html#llvm-backend</a>
</li>

<li>Emscripten - Fastcomp na GitHubu<br />
<a href="https://github.com/kripken/emscripten-fastcomp">https://github.com/kripken/emscripten-fastcomp</a>
</li>

<li>Clang (pro Emscripten) na GitHubu<br />
<a href="https://github.com/kripken/emscripten-fastcomp-clang">https://github.com/kripken/emscripten-fastcomp-clang</a>
</li>

<li>Why not use JavaScript?<br />
<a href="https://ckknight.github.io/gorillascript/">https://ckknight.github.io/gorillascript/</a>
</li>

<li>Lambda the Ultimate: Coroutines in Lua,<br />
<a href="http://lambda-the-ultimate.org/node/438">http://lambda-the-ultimate.org/node/438</a>
</li>

<li>Coroutines Tutorial,<br />
<a href="http://lua-users.org/wiki/CoroutinesTutorial">http://lua-users.org/wiki/CoroutinesTutorial</a>
</li>

<li>Lua Coroutines Versus Python Generators,<br />
<a href="http://lua-users.org/wiki/LuaCoroutinesVersusPythonGenerators">http://lua-users.org/wiki/LuaCoroutinesVersusPythonGenerators</a>
</li>

</ol>



<p></p><p></p>
<p><small>Autor: <a href="http://www.fit.vutbr.cz/~tisnovpa">Pavel Tišnovský</a> &nbsp; 2015</small></p>
</body>
</html>

