<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
        "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html>
<head>
<title>Kooperace mezi jazykem Lua a nativním (céčkovým) kódem: knihovna FFI</title>
<meta name="Author" content="Pavel Tisnovsky" />
<meta name="Generator" content="vim" />
<meta http-equiv="content-type" content="text/html; charset=utf-8" />
<style type="text/css">
         body {color:#000000; background:#ffffff;}
         h1  {font-family: arial, helvetica, sans-serif; color:#ffffff; background-color:#c00000; text-align:center; padding-left:1em}
         h2  {font-family: arial, helvetica, sans-serif; color:#ffffff; background-color:#0000c0; padding-left:1em; text-align:left}
         h3  {font-family: arial, helvetica, sans-serif; color:#000000; background-color:#c0c0c0; padding-left:1em; text-align:left}
         h4  {font-family: arial, helvetica, sans-serif; color:#000000; background-color:#e0e0e0; padding-left:1em; text-align:left}
         a   {font-family: arial, helvetica, sans-serif;}
         li  {font-family: arial, helvetica, sans-serif; color:#000000; text-align:justify; width:450px;}
         ol  {font-family: arial, helvetica, sans-serif; color:#000000; text-align:justify; width:450px;}
         ul  {font-family: arial, helvetica, sans-serif; color:#000000; text-align:justify; width:450px;}
         p   {font-family: arial, helvetica, sans-serif; color:#000000; text-align:justify;}
         pre {background:#e0e0e0}
</style>
</head>

<body>

<h1>Kooperace mezi jazykem Lua a nativním (céčkovým) kódem: knihovna FFI</h1>

<h3>Pavel Tišnovský</h3>

<p></p>

<h1>Úvodník</h1>

<p>Zatímco v předchozí části seriálu o využití programovacího jazyka Lua v praxi jsme se zabývali převážně rozhraním mezi C a Luou nabízeným přímo standardním interpretrem jazyka Lua, dnes se zaměříme na popis způsobu použití knihovny FFI, s níž je možné pracovat v případě, že se namísto standardního interpretru použije LuaJIT.</p>



<h2>Obsah</h2>

<p><a href="#k01">1. Zopakování z&nbsp;minula: volání nativních funkcí ze standardních knihoven</a></p>
<p><a href="#k02">2. První demonstrační příklad</a></p>
<p><a href="#k03">3. Druhý demonstrační příklad</a></p>
<p><a href="#k04">4. Vytvoření vlastní nativní knihovny</a></p>
<p><a href="#k05">5. Volání funkcí z&nbsp;uživatelské knihovny</a></p>
<p><a href="#k06">6. Třetí demonstrační příklad</a></p>
<p><a href="#k07">7. Předávání různých datových typů do nativních funkcí</a></p>
<p><a href="#k08">8. Čtvrtý demonstrační příklad</a></p>
<p><a href="#k09">9. Základy práce s&nbsp;řetězci</a></p>
<p><a href="#k10">10. Pátý demonstrační příklad</a></p>
<p><a href="#k11">11. Práce s&nbsp;poli</a></p>
<p><a href="#k12">12. Šestý demonstrační příklad</a></p>
<p><a href="#k13">13. Repositář s&nbsp;dnešními demonstračními příklady</a></p>
<p><a href="#k14">14. Odkazy na Internetu</a></p>



<p><a name="k01"></a></p>
<h2 id="k01">1. Zopakování z&nbsp;minula: volání nativních funkcí ze standardních knihoven</h2>

<p><a
href="http://www.root.cz/clanky/kooperace-mezi-jazykem-lua-a-nativnim-ceckovym-kodem/">V&nbsp;předchozím
článku</a> jsme se zabývali způsobem komunikace mezi nativním kódem (typicky
naprogramovaným v&nbsp;jazyku C) a skripty napsanými v&nbsp;programovacím
jazyku Lua. Připomeňme si, že již ve standardním interpretru jazyka Lua
existuje možnost volání céčkové funkce z&nbsp;Lua skriptu a naopak i funkce
naprogramované v&nbsp;jazyku Lua z&nbsp;céčka, tj.&nbsp;z&nbsp;nativního kódu.
Volání není přímé, protože se parametry a návratové hodnoty předávají
explicitně přes zásobník ovládaný interpretrem a nikoli přes standardní
(nativní) zásobníkový rámec. Taktéž je v&nbsp;některých případech nutné
provádět konverzi dat. Na druhou stranu je však rozhraní C &rarr; Lua i Lua
&rarr; C navrženo takovým způsobem, že je volání funkcí bezpečné, programátor
nativní části aplikace může explicitně povolit jen potřebné moduly a navíc nemá
skript naprogramovaný v&nbsp;jazyku Lua prakticky žádnou možnost, jak poškodit
obsah nativního zásobníkového rámce a tím například způsobit chybu (či útok)
typu <i>buffer overflow</i>.</p>

<p>Pokud nějaká aplikace namísto standardního interpretru jazyka <i>Lua</i>
využívá možnosti nabízené projektem <i>LuaJIT</i>, volání nativních funkcí
z&nbsp;Lua skriptů se mnohem zjednoduší, a to díky knihovně <i>Lua FFI</i>.
Tato knihovna pro svou činnost pouze potřebuje znát hlavičky nativních funkcí,
které zpracuje a na jejich základě vytvoří tabulku Lua funkcí, které je možné
ihned volat z&nbsp;Lua skriptů. Nativní knihovny, které se mají volat, je nutné
explicitně načíst (a zmíněná tabulka funkcí je vytvořena pro každou takto
načtenou knihovnu). Výjimkou jsou základní céčkové knihovny, konkrétně
<strong>libc</strong>, <strong>libm</strong> a na Linuxu i knihovna
<strong>libdl</strong>, které jsou načteny automaticky, což je samozřejmě
výhodné, neboť se tak zjednoduší tvorba skriptů. Na systému Windows
(32bitovém!) jsou takto automaticky načteny knihovny
<strong>kernel32.dll</strong>, <strong>user32.dll</strong> a
<strong>gdi32.dll</strong> (popř.&nbsp;i <strong>msvcrt_verze.dll</strong>.
Hlavičky funkcí je možné získat například z&nbsp;hlavičkových souborů (pokud se
tedy nepoužívají pro tvorbu názvů složitější makra).</p>



<p><a name="k02"></a></p>
<h2 id="k02">2. První demonstrační příklad</h2>

<p>Demonstrační příklad nazvaný <strong>ffi_example1</strong> jsme si již
ukazovali minule, ovšem pro úplnost si ho znovu uvedeme, a to z&nbsp;toho
důvodu, aby se ukázal rozdíl mezi voláním nativních funkcí ze standardní
knihovny a voláním funkcí z&nbsp;knihovny uživatelské. Předpokládejme tedy, že
potřebujeme volat céčkovou funkci nazvanou <strong>rand()</strong>, které se
nepředávají žádné parametry. Nejprve je nutné explicitně knihovnu
<strong>FFI</strong> načíst, což zajišťuje první řádek skriptu. Následně se
musí zapsat hlavička nativní funkce či funkcí, které se budou z&nbsp;Lua
skriptu volat (řádek začínající na <strong>ffi.cdef</strong>. Samotné volání
nativní funkce je již jednoduché: <strong>ffi.C.rand()</strong>, výsledek
(návratová hodnota) je uložena do lokální proměnné nazvané
<strong>random</strong> (<strong>ffi.C</strong> je tabulkou funkcí ze
standardních knihoven):</p>

<pre>
<i>-- Prvni demonstracni priklad vyuzivajici knihovnu FFI</i>
&nbsp;
<strong>local</strong> ffi = require("ffi")
&nbsp;
<i>-- Definice ceckovske funkce ze standardni knihovny</i>
&nbsp;
ffi.cdef[[
int rand(void);
]]
&nbsp;
<strong>for</strong> i=0,10 <strong>do</strong>
    <i>-- Zavolani ceckovske funkce</i>
    <strong>local</strong> random = ffi.C.rand()
    print(random)
<strong>end</strong>
</pre>

<p>Tento příklad je nutné spustit <i>LuaJITem</i>!. Příklad výstupu:</p>

<pre>
1804289383
846930886
1681692777
1714636915
1957747793
424238335
719885386
1649760492
596516649
1189641421
1025202362
</pre>



<p><a name="k03"></a></p>
<h2 id="k03">3. Druhý demonstrační příklad</h2>

<p>I tento demonstrační příklad byl ukázán minule, takže si ho popíšeme jen
stručně. V&nbsp;tomto příkladu se volá funkce nazvaná <strong>atoi()</strong>,
která je součástí standardní knihovny programovacího jazyka C. Funkce
<strong>atoi()</strong> akceptuje (čti vyžaduje) parametr typu řetězec, což je
v&nbsp;případě programovacího jazyka C datový typ <strong>const char
*</strong>, tedy ukazatel na první znak řetězce (klíčové slovo const zde může
pomáhat překladači při optimalizacích a navíc &ndash; což je důležitější
&ndash; nám říká, že funkce řetězec nebude modifikovat). Při volání funkce
<strong>atoi()</strong> ze skriptu napsaného v&nbsp;Lua se automaticky provede
konverze mezi Lua stringem a céčkovým řetězcem:</p>

<pre>
<i>-- Druhy demonstracni priklad vyuzivajici knihovnu FFI</i>
&nbsp;
<strong>local</strong> ffi = require("ffi")
&nbsp;
<i>-- Definice ceckovske funkce ze standardni knihovny</i>
&nbsp;
ffi.cdef[[
int atoi(const char *);
]]
&nbsp;
<i>-- Zavolani ceckovske funkce</i>
<strong>local</strong> value = ffi.C.atoi("42")
&nbsp;
print(value)
</pre>

<p>Spuštění příkladu:</p>

<pre>
<strong>luajit ffi_example2.lua</strong>
42
</pre>



<p><a name="k04"></a></p>
<h2 id="k04">4. Vytvoření vlastní nativní knihovny</h2>

<p>Jak je z&nbsp;předchozích dvou demonstračních příkladů patrné, je volání
funkcí umístěných ve standardních knihovnách velmi snadné a provádí se přes
dynamicky tvořenou tabulku <strong>ffi.C</strong>. Poněkud náročnější je
situace ve chvíli, kdy programátor vytváří jak nativní část aplikace, tak i
část skriptovanou v&nbsp;jazyce Lua. V&nbsp;tomto případě je totiž nutné
z&nbsp;nativních funkcí psaných v&nbsp;céčku vytvořit knihovnu a tu explicitně
načíst ve chvíli inicializace Lua skriptu. Podívejme se na jednoduchý příklad
zdrojového kódu <strong>test.c</strong> psaného v&nbsp;jazyce C, který obsahuje
jedinou funkci, kterou budeme chtít volat z&nbsp;Lua skriptů:</p>

<pre>
void test(void)
{
    puts("***TEST***");
}
</pre>

<p>Postupovat je možné následujícím způsobem. Nejdříve se musí provést překlad
céčkového zdrojového kódu do nativního objektového kódu:</p>

<pre>
gcc -fPIC -c -o test.o test.c
</pre>

<p>Výsledkem je objektový soubor nazvaný <strong>test.o</strong>. Následně se
vytvoří knihovna příkazem:</p>

<pre>
gcc -shared -Wl,-soname,libtest.so -o libtest.so test.o
</pre>

<p>Povšimněte si, že výsledná knihovna má prefix &bdquo;lib&ldquo;. To je
důležité, neboť kdyby tento prefix nebyl použit a knihovna se jmenovala jen
<strong>test.so</strong>, nastaly by problémy s&nbsp;jejím načítáním.</p>



<p><a name="k05"></a></p>
<h2 id="k05">5. Volání funkcí z&nbsp;uživatelské knihovny</h2>

<p>Nyní se podíváme na způsob volání funkcí (v&nbsp;našem případě jediné
funkce) z&nbsp;právě přeložené uživatelské knihovny. Nejprve nastavíme
proměnnou shellu <strong>LD_LIBRARY_PATH</strong> takovým způsobem, aby
ukazovala i na aktuální adresář, v&nbsp;němž je nativní knihovna uložena:</p>

<pre>
export LD_LIBRARY_PATH=.:$LD_LIBRARY_PATH
</pre>

<p>Úpravy v&nbsp;Lua skriptu jsou jednoduché. Nově vytvořenou knihovnu je nutné
explicitně načíst funkcí <strong>ffi.load()</strong>. Povšimněte si, že se
použije jméno <strong>test</strong> a nikoli <strong>libtest</strong>:</p>

<pre>
local lib = ffi.load("test")
</pre>

<p>Hlavičku funkce je nutné zaregistrovat (interně je to ovšem poměrně
složité):</p>

<pre>
ffi.cdef[[
void test(void);
]]
</pre>

<p>A posléze je již možné nativní funkci zavolat:</p>

<pre>
lib.test()
</pre>

<p>Spuštění:</p>

<pre>
luajit test.lua
***TEST***
</pre>



<p><a name="k06"></a></p>
<h2 id="k06">6. Třetí demonstrační příklad</h2>

<p>Dnešní třetí demonstrační příklad vlastně shrnuje všechny kroky, které jsme
si popsali <a href="#k02">ve druhé</a> a <a href="#k03">ve třetí</a> kapitole.
Příklad se jmenuje <strong>ffi_example3</strong> a všechny potřebné zdrojové
soubory i skripty naleznete na adrese <a
href="https://github.com/tisnik/luajit-examples/tree/master/ffi/ffi_example3">https://github.com/tisnik/luajit-examples/tree/master/ffi/ffi_example3</a>.</p>



<h3>Céčková část příkladu</h3>

<pre>
#include &lt;stdio.h&gt;
&nbsp;
<strong>void</strong> function1(void)
{
    puts("Function1!");
}
</pre>



<h3>Skript pro překlad céčkové části do nativní knihovny</h3>

<pre>
gcc -fPIC -c -o ffi_example3.o ffi_example3.c
gcc -shared -Wl,-soname,libffi_example3.so -o libffi_example3.so ffi_example3.o
</pre>



<h3>Výpis symbolů z&nbsp;nativní knihovny</h3>

<pre>
objdump -T libffi_example3.so |grep text
</pre>

<pre>
00000000000006d5 g    DF .text  0000000000000012  Base        function1
</pre>


<h3>Lua skript</h3>

<pre>
<i>-- Treti demonstracni priklad vyuzivajici knihovnu FFI</i>
&nbsp;
<strong>local</strong> ffi = require("ffi")
&nbsp;
<strong>local</strong> lib = ffi.load("ffi_example3")
&nbsp;
<i>-- Definice ceckovske funkce z uzivatelske knihovny</i>
&nbsp;
ffi.cdef[[
void function1(void);
]]
&nbsp;
<i>-- Zavolani ceckovske funkce</i>
lib.function1()
</pre>



<h3>Spuštění demonstračního příkladu</h3>

<pre>
export LD_LIBRARY_PATH=.:$LD_LIBRARY_PATH
luajit ffi_example3.lua
</pre>



<p><a name="k07"></a></p>
<h2 id="k07">7. Předávání různých datových typů do nativních funkcí</h2>

<p>Do nativních funkcí je ve většině případů nutné předávat parametry, takže je
potřebné zajistit správnou kooperaci mezi skriptem psaným v&nbsp;jazyce Lua
(kde je množina primitivních datových typů relativně malá) a funkcemi psanými
v&nbsp;céčku, které je naopak známé velkým množstvím primitivních datových typů
a jejich variant (<i>signed/unsigned</i>). Nejprve se podívejme na použití
celočíselných i reálných datových typů. Zde je situace relativně jednoduchá,
neboť knihovna FFI automaticky provede všechny potřebné konverze. K&nbsp;tomu
nám též napomáhá fakt, že již jméno volané céčkové funkce je jednoznačné, na
rozdíl od (například) C++ s&nbsp;přetěžováním funkcí, přičemž skutečně volaná
funkce se rozpozná až na základě počtu a typů parametrů. Tato složitost nám
v&nbsp;případě programovacího jazyka C zcela odpadá.</p>



<p><a name="k08"></a></p>
<h2 id="k08">8. Čtvrtý demonstrační příklad</h2>

<p>Způsob předávání celočíselných i reálných hodnot nativním funkcím je ukázán
v&nbsp;dnešním čtvrtém demonstračním příkladu. V&nbsp;céčkovém zdrojovém kódu
můžeme vidět deklaraci pěti funkcí, přičemž jedna funkce neočekává žádné
parametry, další funkce očekává celočíselný parametr, třetí funkce dva
celočíselné parametry, funkce čtvrtá očekává reálnou hodnotu
(resp.&nbsp;přesněji řečeno hodnotu reprezentovanou v&nbsp;systému plovoucí
řádové čárky) a poslední funkce očekává znak, resp.&nbsp;jeho kód
(předpokládejme pro jednoduchost použití ASCII). Volání všech těchto funkcí
z&nbsp;Lua skriptu je velmi snadné, což je patrné z&nbsp;výpisu tohoto
skriptu:</p>



<h3>Céčková část příkladu</h3>

<pre>
#include &lt;stdio.h&gt;
&nbsp;
<strong>void</strong> function1(void)
{
    puts("Function1!");
}
&nbsp;
<strong>void</strong> function2(int x)
{
    printf("Function2! %d\n", x);
}
&nbsp;
<strong>void</strong> function3(int x, int y)
{
    printf("Function3! %d\n", x+y);
}
&nbsp;
<strong>void</strong> function4(float x)
{
    printf("Function4! %7.5f\n", 1.f/x);
}
&nbsp;
<strong>void</strong> function5(char c)
{
    printf("Function5! %c\n", c);
}
</pre>



<h3>Skript pro překlad céčkové části do nativní knihovny</h3>

<pre>
gcc -fPIC -c -o ffi_example4.o ffi_example4.c
gcc -shared -Wl,-soname,libffi_example4.so -o libffi_example4.so ffi_example4.o
</pre>



<h3>Výpis symbolů z&nbsp;nativní knihovny</h3>

<pre>
objdump -T libffi_example4.so |grep text
</pre>

<pre>
00000000000007fa g    DF .text  000000000000002b  Base        function3
00000000000007c5 g    DF .text  0000000000000012  Base        function1
0000000000000825 g    DF .text  0000000000000033  Base        function4
0000000000000858 g    DF .text  0000000000000026  Base        function5
00000000000007d7 g    DF .text  0000000000000023  Base        function2
</pre>



<h3>Lua skript</h3>

<pre>
<i>-- Ctvrty demonstracni priklad vyuzivajici knihovnu FFI</i>
&nbsp;
<strong>local</strong> ffi = require("ffi")
&nbsp;
<strong>local</strong> lib = ffi.load("ffi_example4")
&nbsp;
<i>-- Definice ceckovskych funkci z uzivatelske knihovny</i>
&nbsp;
ffi.cdef[[
void function1(void);
void function2(int);
void function3(int, int);
void function4(float);
void function5(char);
]]
&nbsp;
<i>-- Zavolani ceckovskych funkci</i>
lib.function1()
lib.function2(42)
lib.function3(1,2)
lib.function4(3)
lib.function5(97)
</pre>



<h3>Spuštění demonstračního příkladu</h3>

<pre>
export LD_LIBRARY_PATH=.:$LD_LIBRARY_PATH
luajit ffi_example4.lua
</pre>

<pre>
Function1!
Function2! 42
Function3! 3
Function4! 0.33333
Function5! a
</pre>



<p><a name="k09"></a></p>
<h2 id="k09">9. Základy práce s&nbsp;řetězci</h2>

<p>Zatímco práce s&nbsp;celočíselnými i reálnými parametry je i přes rozdíly
mezi jazykem C a Lua snadno pochopitelná, poněkud složitější je situace ve
chvíli, kdy se má pracovat s&nbsp;řetězci. Pokud nativní céčková funkce
akceptuje parametr typu <strong>const char *</strong>, je možné při volání této
funkce použít řetězec v&nbsp;jazyce Lua, i když tento řetězec je interně
zpracováván odlišným způsobem (zejména se o jeho dealokaci stará automatický
správce paměti). Opačný způsob komunikace, tedy vrácení řetězce z&nbsp;céčkové
funkce do skriptu psaného v&nbsp;jazyce Lua, je nepatrně obtížnější, a to
z&nbsp;toho důvodu, že se musí provést explicitní konverze funkcí
<strong>ffi.string()</strong>. Této funkci se předá řetězec vrácený
z&nbsp;nativní funkce (ten je z&nbsp;pohledu Luy typu &bdquo;cdata&ldquo;) a
výsledkem je běžný Lua řetězec.</p>



<p><a name="k10"></a></p>
<h2 id="k10">10. Pátý demonstrační příklad</h2>

<p>V&nbsp;dnešním pátém demonstračním příkladu jsou ukázány oba směry
komunikace při předávání řetězců do nativní funkce i při vrácení řetězce
z&nbsp;jiné nativní funkce. Funkce nazvaná <strong>function1</strong> akceptuje
parametr typu <strong>const char *</strong>, což knihovna FFI správně pochopí a
dovolí nám do této funkce předat řetězec přímo z&nbsp;jazyka Lua. Naproti tomu
funkce nazvaná <strong>function2</strong> je bezparametrická, ale vrací
konstantu typu <strong>const char*</strong>. Tato hodnota nám sama o sobě není
v&nbsp;Lua skriptu příliš užitečná, takže se musí s&nbsp;využitím výše zmíněné
funkce <strong>ffi.string()</strong> provést její převod na Lua string. Pro
ukázání rozdílu mezi vrácenou hodnotou a plnohodnotným řetězcem jsou po
spuštění tohoto demonstračního příkladu vypsány obě hodnoty.</p>



<h3>Céčková část příkladu</h3>

<pre>
#include &lt;stdio.h&gt;
&nbsp;
<strong>const char</strong> *HELLO_MSG = "Hello World!";
&nbsp;
<strong>void</strong> function1(const char *str)
{
    printf("Function1! %s\n", str);
}
&nbsp;
<strong>const char*</strong> function2(void)
{
    return HELLO_MSG;
}
</pre>



<h3>Skript pro překlad céčkové části do nativní knihovny</h3>

<pre>
gcc -fPIC -c -o ffi_example5.o ffi_example5.c
gcc -shared -Wl,-soname,libffi_example5.so -o libffi_example5.so ffi_example5.o
</pre>



<h3>Výpis symbolů z&nbsp;nativní knihovny</h3>

<pre>
objdump -T libffi_example5.so |grep text
</pre>

<pre>
0000000000000755 g    DF .text  0000000000000026  Base        function1
000000000000077b g    DF .text  0000000000000010  Base        function2
</pre>



<h3>Lua skript</h3>

<pre>
<i>-- Paty demonstracni priklad vyuzivajici knihovnu FFI</i>
&nbsp;
<strong>local</strong> ffi = require("ffi")
&nbsp;
<strong>local</strong> lib = ffi.load("ffi_example5")
&nbsp;
<i>-- Definice ceckovskych funkci z uzivatelske knihovny</i>
&nbsp;
ffi.cdef[[
void function1(const char *);
const char* function2(void);
]]
&nbsp;
<i>-- Zavolani ceckovskych funkci</i>
lib.function1("Hello world!")
&nbsp;
<strong>local</strong> return_value = lib.function2()
print(return_value)
&nbsp;
<strong>local</strong> str = ffi.string(return_value)
print(str)
</pre>



<h3>Spuštění demonstračního příkladu</h3>

<pre>
export LD_LIBRARY_PATH=.:$LD_LIBRARY_PATH
luajit ffi_example5.lua
</pre>

<pre>
Function1! Hello world!
cdata&lt;const char *&gt;: 0x7f3299d11795
Hello World!
</pre>



<p><a name="k11"></a></p>
<h2 id="k11">11. Práce s&nbsp;poli</h2>

<p>Podobně problematická činnost, jakou je předávání řetězců, může být práce
s&nbsp;poli. Jak již víme z&nbsp;předchozích částí tohoto seriálu, programovací
jazyk Lua vlastně pojem klasického pole nezná, neboť tabulky mají dvojí podobu
(a dvě části): část indexovaná celými čísly implicitně od jedničky a část
indexovaná prakticky libovolným klíčem (kromě hodnoty <strong>nil</strong>).
Při tvorbě datové struktury kompatibilní s&nbsp;céčkovým polem nám může pomoci
funkce <strong>ffi.new</strong>, v&nbsp;jejímž prvním parametru je možné zapsat
typ pole a případně i počet jeho prvků a další (nepovinné) parametry pak
představují hodnotu jednotlivých prvků tohoto pole. Podívejme se na jednoduchý
příklad sloužící pro vytvoření céčkového pole s&nbsp;deseti inicializovanými
prvky:</p>

<pre>
ffi.new("int[10]", 1, 2, 3, 4, 5, 6, 7, 8, 9, 10)
</pre>

<p>popř.&nbsp;praktičtěji (převod z&nbsp;Lua tabulky na pole):</p>

<pre>
ffi.new("int[10]", {1, 2, 3, 4, 5, 6, 7, 8, 9, 10})
</pre>

<p>Alternativně je možné počet prvků předat v&nbsp;prvním parametru a
inicializační hodnoty tak o jedno místo posunout. Volání funkce
<strong>ffi.new</strong> může vypadat i takto:</p>

<pre>
ffi.new("int[?]", 10, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10)
</pre>

<p>Hodnoty prvků není zapotřebí vypisovat v&nbsp;případě, že má být pole automaticky vynulováno:</p>

<pre>
ffi.new("int[10]", {})
</pre>



<p><a name="k12"></a></p>
<h2 id="k12">12. Šestý demonstrační příklad</h2>

<p>Práce s&nbsp;poli je ukázána v&nbsp;šestém a současně i dnešním posledním
demonstračním příkladu, v&nbsp;jehož céčkové části je deklarována funkce
nazvaná <strong>modifyArray</strong>. Této funkci se předá pole prvků typu int
a funkce pouze změní šestý prvek tohoto pole (prvky jsou v&nbsp;céčku
indexovány od nuly, na rozdíl od jazyka Lua). Neprovádí se přitom žádná
kontrola, zda má pole skutečně minimálně šest požadovaných prvků!. Pole předané
do této funkce je v&nbsp;Lua skriptu vytvořeno příkazem
<strong>ffi.new("int[10]", 1, 2, 3, 4, 5, 6, 7, 8, 9, 10)</strong> a po
zavolání nativní funkce <strong>modifyArray</strong> se nové prvky pole vypíšou
na standardní výstup s&nbsp;využitím klasické počítané programové smyčky typu
<strong>for</strong>, tj.&nbsp;podobně, jakoby se jednalo o běžnou Lua
tabulku:</p>



<h3>Céčková část příkladu</h3>

<pre>
#include &lt;stdio.h&gt;
&nbsp;
<strong>void</strong> modifyArray(int *array)
{
    <i>/* neprovadi se zadna kontrola, zda pole skutecne existuje! */</i>
    array[5] = -1;
}
</pre>



<h3>Skript pro překlad céčkové části do nativní knihovny</h3>

<pre>
gcc -fPIC -c -o ffi_example6.o ffi_example6.c
gcc -shared -Wl,-soname,libffi_example6.so -o libffi_example6.so ffi_example6.o
</pre>



<h3>Výpis symbolů z&nbsp;nativní knihovny</h3>

<pre>
objdump -T libffi_example6.so |grep text
</pre>

<pre>
0000000000000695 g    DF .text  0000000000000018  Base        modifyArray
</pre>



<h3>Lua skript</h3>

<pre>
<i>-- Sesty demonstracni priklad vyuzivajici knihovnu FFI</i>
&nbsp;
<strong>local</strong> ffi = require("ffi")
&nbsp;
<strong>local</strong> lib = ffi.load("ffi_example6")
&nbsp;
<i>-- Definice ceckovske funkce z uzivatelske knihovny</i>
&nbsp;
ffi.cdef[[
void modifyArray(int *array);
]]
&nbsp;
<strong>local</strong> array = ffi.new("int[10]", 1, 2, 3, 4, 5, 6, 7, 8, 9, 10)
&nbsp;
<i>-- Zavolani ceckovske funkce</i>
lib.modifyArray(array)
&nbsp;
<i>-- vypis prvku pole</i>
<strong>for</strong> i = 0, 9 <strong>do</strong>
    print(i, array[i])
<strong>end</strong>
</pre>



<h3>Spuštění demonstračního příkladu</h3>

<pre>
export LD_LIBRARY_PATH=.:$LD_LIBRARY_PATH
luajit ffi_example6.lua
</pre>

<pre>
0       1
1       2
2       3
3       4
4       5
5       -1
6       7
7       8
8       9
9       10
</pre>



<p><a name="k13"></a></p>
<h2 id="k13">13. Repositář s&nbsp;dnešními demonstračními příklady</h2>

<p>Všech šest demonstračních příkladů, které jsme si dnes popsali, bylo uloženo
do Git repositáře dostupného na adrese <a
href="https://github.com/tisnik/luajit-examples">https://github.com/tisnik/luajit-examples</a>.
V&nbsp;tabulce zobrazené pod tímto odstavcem naleznete odkazy na adresáře
obsahující jak zdrojové kódy příkladů, tak i pomocné skripty apod:</p>

<table>
<tr><th>#</th><th>Příklad </th><th>Github</th></tr>
<tr><td>1</td><td>ffi_example1</td><td><a href="https://github.com/tisnik/luajit-examples/blob/master/ffi/ffi_example1.lua">https://github.com/tisnik/luajit-examples/blob/master/ffi/ffi_example1.lua</a></td></tr>
<tr><td>2</td><td>ffi_example2</td><td><a href="https://github.com/tisnik/luajit-examples/blob/master/ffi/ffi_example2.lua">https://github.com/tisnik/luajit-examples/blob/master/ffi/ffi_example2.lua</a></td></tr>
<tr><td>3</td><td>ffi_example3</td><td><a href="https://github.com/tisnik/luajit-examples/tree/master/ffi/ffi_example3">https://github.com/tisnik/luajit-examples/tree/master/ffi/ffi_example3</a></td></tr>
<tr><td>4</td><td>ffi_example4</td><td><a href="https://github.com/tisnik/luajit-examples/tree/master/ffi/ffi_example4">https://github.com/tisnik/luajit-examples/tree/master/ffi/ffi_example4</a></td></tr>
<tr><td>5</td><td>ffi_example5</td><td><a href="https://github.com/tisnik/luajit-examples/tree/master/ffi/ffi_example5">https://github.com/tisnik/luajit-examples/tree/master/ffi/ffi_example5</a></td></tr>
<tr><td>6</td><td>ffi_example6</td><td><a href="https://github.com/tisnik/luajit-examples/tree/master/ffi/ffi_example6">https://github.com/tisnik/luajit-examples/tree/master/ffi/ffi_example6</a></td></tr>
</table>



<p><a name="k14"></a></p>
<h2 id="k14">14. Odkazy na Internetu</h2>

<ol>

<li>LuaJIT - Just in Time překladač pro programovací jazyk Lua<br />
<a href="http://www.root.cz/clanky/luajit-just-in-time-prekladac-pro-programovaci-jazyk-lua/">http://www.root.cz/clanky/luajit-just-in-time-prekladac-pro-programovaci-jazyk-lua/</a>
</li>

<li>LuaJIT - Just in Time překladač pro programovací jazyk Lua (2)<br />
<a href="http://www.root.cz/clanky/luajit-just-in-time-prekladac-pro-programovaci-jazyk-lua-2/">http://www.root.cz/clanky/luajit-just-in-time-prekladac-pro-programovaci-jazyk-lua-2/</a>
</li>

<li>LuaJIT - Just in Time překladač pro programovací jazyk Lua (3)<br />
<a href="http://www.root.cz/clanky/luajit-just-in-time-prekladac-pro-programovaci-jazyk-lua-3/">http://www.root.cz/clanky/luajit-just-in-time-prekladac-pro-programovaci-jazyk-lua-3/</a>
</li>

<li>LuaJIT - Just in Time překladač pro programovací jazyk Lua (4)<br />
<a href="http://www.root.cz/clanky/luajit-just-in-time-prekladac-pro-programovaci-jazyk-lua-4/">http://www.root.cz/clanky/luajit-just-in-time-prekladac-pro-programovaci-jazyk-lua-4/</a>
</li>

<li>LuaJIT - Just in Time překladač pro programovací jazyk Lua (5 - tabulky a pole)<br />
<a href="http://www.root.cz/clanky/luajit-just-in-time-prekladac-pro-programovaci-jazyk-lua-5-tabulky-a-pole/">http://www.root.cz/clanky/luajit-just-in-time-prekladac-pro-programovaci-jazyk-lua-5-tabulky-a-pole/</a>
</li>

<li>LuaJIT - Just in Time překladač pro programovací jazyk Lua (6 - překlad programových smyček do mezijazyka LuaJITu)<br />
<a href="http://www.root.cz/clanky/luajit-just-in-time-prekladac-pro-programovaci-jazyk-lua-6-preklad-programovych-smycek-do-mezijazyka-luajitu/">http://www.root.cz/clanky/luajit-just-in-time-prekladac-pro-programovaci-jazyk-lua-6-preklad-programovych-smycek-do-mezijazyka-luajitu/</a>
</li>

<li>LuaJIT - Just in Time překladač pro programovací jazyk Lua (7 - dokončení popisu mezijazyka LuaJITu)<br />
<a href="http://www.root.cz/clanky/luajit-just-in-time-prekladac-pro-programovaci-jazyk-lua-7-dokonceni-popisu-mezijazyka-luajitu/">http://www.root.cz/clanky/luajit-just-in-time-prekladac-pro-programovaci-jazyk-lua-7-dokonceni-popisu-mezijazyka-luajitu/</a>
</li>

<li>LuaJIT - Just in Time překladač pro programovací jazyk Lua (8 - základní vlastnosti trasovacího JITu)<br />
<a href="http://www.root.cz/clanky/luajit-just-in-time-prekladac-pro-programovaci-jazyk-lua-8-zakladni-vlastnosti-trasovaciho-jitu/">http://www.root.cz/clanky/luajit-just-in-time-prekladac-pro-programovaci-jazyk-lua-8-zakladni-vlastnosti-trasovaciho-jitu/</a>
</li>

<li>LuaJIT - Just in Time překladač pro programovací jazyk Lua (9 - další vlastnosti trasovacího JITu)<br />
<a href="http://www.root.cz/clanky/luajit-just-in-time-prekladac-pro-programovaci-jazyk-lua-9-dalsi-vlastnosti-trasovaciho-jitu/">http://www.root.cz/clanky/luajit-just-in-time-prekladac-pro-programovaci-jazyk-lua-9-dalsi-vlastnosti-trasovaciho-jitu/</a>
</li>

<li>LuaJIT - Just in Time překladač pro programovací jazyk Lua (10 - JIT překlad do nativního kódu)<br />
<a href="http://www.root.cz/clanky/luajit-just-in-time-prekladac-pro-programovaci-jazyk-lua-10-jit-preklad-do-nativniho-kodu/">http://www.root.cz/clanky/luajit-just-in-time-prekladac-pro-programovaci-jazyk-lua-10-jit-preklad-do-nativniho-kodu/</a>
</li>

<li>LuaJIT - Just in Time překladač pro programovací jazyk Lua (11 - JIT překlad do nativního kódu procesorů s architekturami x86 a ARM)<br />
<a href="http://www.root.cz/clanky/luajit-just-in-time-prekladac-pro-programovaci-jazyk-lua-11-jit-preklad-do-nativniho-kodu-procesoru-s-architekturami-x86-a-arm/">http://www.root.cz/clanky/luajit-just-in-time-prekladac-pro-programovaci-jazyk-lua-11-jit-preklad-do-nativniho-kodu-procesoru-s-architekturami-x86-a-arm/</a>
</li>

<li>LuaJIT - Just in Time překladač pro programovací jazyk Lua (12 - překlad operací s reálnými čísly)<br />
<a href="http://www.root.cz/clanky/luajit-just-in-time-prekladac-pro-programovaci-jazyk-lua-12-preklad-operaci-s-realnymi-cisly/">http://www.root.cz/clanky/luajit-just-in-time-prekladac-pro-programovaci-jazyk-lua-12-preklad-operaci-s-realnymi-cisly/</a>
</li>

<li>The Lua VM, on the Web<br />
<a href="https://kripken.github.io/lua.vm.js/lua.vm.js.html">https://kripken.github.io/lua.vm.js/lua.vm.js.html</a>
</li>

<li>Lua.vm.js REPL<br />
<a href="https://kripken.github.io/lua.vm.js/repl.html">https://kripken.github.io/lua.vm.js/repl.html</a>
</li>

<li>lua2js<br />
<a href="https://www.npmjs.com/package/lua2js">https://www.npmjs.com/package/lua2js</a>
</li>

<li>lua2js na GitHubu<br />
<a href="https://github.com/basicer/lua2js-dist">https://github.com/basicer/lua2js-dist</a>
</li>

<li>Seriál o programovacím jazyku Lua<br />
<a href="http://www.root.cz/serialy/programovaci-jazyk-lua/">http://www.root.cz/serialy/programovaci-jazyk-lua/</a>
</li>

<li>Source-to-source compiler<br />
<a href="https://en.wikipedia.org/wiki/Source-to-source_compiler">https://en.wikipedia.org/wiki/Source-to-source_compiler</a>
</li>

<li>JavaScript is Assembly Language for the Web: Sematic Markup is Dead! Clean vs. Machine-coded HTML<br />
<a href="http://www.hanselman.com/blog/JavaScriptIsAssemblyLanguageForTheWebSematicMarkupIsDeadCleanVsMachinecodedHTML.aspx">http://www.hanselman.com/blog/JavaScriptIsAssemblyLanguageForTheWebSematicMarkupIsDeadCleanVsMachinecodedHTML.aspx</a>
</li>

<li>JavaScript is Web Assembly Language and that's OK.<br />
<a href="http://www.hanselman.com/blog/JavaScriptIsWebAssemblyLanguageAndThatsOK.aspx">http://www.hanselman.com/blog/JavaScriptIsWebAssemblyLanguageAndThatsOK.aspx</a>
</li>

<li>Dart<br />
<a href="https://www.dartlang.org/">https://www.dartlang.org/</a>
</li>

<li>CoffeeScript<br />
<a href="http://coffeescript.org/">http://coffeescript.org/</a>
</li>

<li>TypeScript<br />
<a href="http://www.typescriptlang.org/">http://www.typescriptlang.org/</a>
</li>

<li>Lua (programming language)<br />
<a href="http://en.wikipedia.org/wiki/Lua_(programming_language)">http://en.wikipedia.org/wiki/Lua_(programming_language)</a>
</li>

<li>Static single assignment form (SSA)<br />
<a href="http://en.wikipedia.org/wiki/Static_single_assignment_form">http://en.wikipedia.org/wiki/Static_single_assignment_form</a>
</li>

<li>Wikipedia: Mezijazyk<br />
<a href="http://cs.wikipedia.org/wiki/Mezijazyk">http://cs.wikipedia.org/wiki/Mezijazyk</a>
</li>

<li>LuaJIT 2.0 SSA IR
<a href="http://wiki.luajit.org/SSA-IR-2.0">http://wiki.luajit.org/SSA-IR-2.0</a>
</li>

<li>The LuaJIT Project<br />
<a href="http://luajit.org/index.html">http://luajit.org/index.html</a>
</li>

<li>LuaJIT FAQ<br />
<a href="http://luajit.org/faq.html">http://luajit.org/faq.html</a>
</li>

<li>LuaJIT Performance Comparison<br />
<a href="http://luajit.org/performance.html">http://luajit.org/performance.html</a>
</li>

<li>LuaJIT 2.0 intellectual property disclosure and research opportunities<br />
<a href="http://article.gmane.org/gmane.comp.lang.lua.general/58908">http://article.gmane.org/gmane.comp.lang.lua.general/58908</a>
</li>

<li>LuaJIT Wiki<br />
<a href="http://wiki.luajit.org/Home">http://wiki.luajit.org/Home</a>
</li>

<li>LuaJIT 2.0 Bytecode Instructions<br />
<a href="http://wiki.luajit.org/Bytecode-2.0">http://wiki.luajit.org/Bytecode-2.0</a>
</li>

<li>Programming in Lua (first edition)<br />
<a href="http://www.lua.org/pil/contents.html">http://www.lua.org/pil/contents.html</a>
</li>

<li>Lua 5.2 sources<br />
<a href="http://www.lua.org/source/5.2/">http://www.lua.org/source/5.2/</a>
</li>

<li>Tcl Plugin Version 3<br />
<a href="http://www.tcl.tk/software/plugin/">http://www.tcl.tk/software/plugin/</a>
</li>

<li>JavaScript: The Web Assembly Language?<br />
<a href="http://www.informit.com/articles/article.aspx?p=1856657">http://www.informit.com/articles/article.aspx?p=1856657</a>
</li>

<li>asm.js<br />
<a href="http://asmjs.org/">http://asmjs.org/</a>
</li>

<li>List of languages that compile to JS<br />
<a href="https://github.com/jashkenas/coffeescript/wiki/List-of-languages-that-compile-to-JS">https://github.com/jashkenas/coffeescript/wiki/List-of-languages-that-compile-to-JS</a>
</li>

<li>REPL<br />
<a href="https://en.wikipedia.org/wiki/Read%E2%80%93eval%E2%80%93print_loop">https://en.wikipedia.org/wiki/Read%E2%80%93eval%E2%80%93print_loop</a>
</li>

<li>The LLVM Compiler Infrastructure<br />
<a href="http://llvm.org/ProjectsWithLLVM/">http://llvm.org/ProjectsWithLLVM/</a>
</li>

<li>clang: a C language family frontend for LLVM<br />
<a href="http://clang.llvm.org/">http://clang.llvm.org/</a>
</li>

<li>emscripten<br />
<a href="http://kripken.github.io/emscripten-site/">http://kripken.github.io/emscripten-site/</a>
</li>

<li>LLVM Backend ("Fastcomp")<br />
<a href="http://kripken.github.io/emscripten-site/docs/building_from_source/LLVM-Backend.html#llvm-backend">http://kripken.github.io/emscripten-site/docs/building_from_source/LLVM-Backend.html#llvm-backend</a>
</li>

<li>Emscripten - Fastcomp na GitHubu<br />
<a href="https://github.com/kripken/emscripten-fastcomp">https://github.com/kripken/emscripten-fastcomp</a>
</li>

<li>Clang (pro Emscripten) na GitHubu<br />
<a href="https://github.com/kripken/emscripten-fastcomp-clang">https://github.com/kripken/emscripten-fastcomp-clang</a>
</li>

<li>Why not use JavaScript?<br />
<a href="https://ckknight.github.io/gorillascript/">https://ckknight.github.io/gorillascript/</a>
</li>

<li>Lambda the Ultimate: Coroutines in Lua,<br />
<a href="http://lambda-the-ultimate.org/node/438">http://lambda-the-ultimate.org/node/438</a>
</li>

<li>Coroutines Tutorial,<br />
<a href="http://lua-users.org/wiki/CoroutinesTutorial">http://lua-users.org/wiki/CoroutinesTutorial</a>
</li>

<li>Lua Coroutines Versus Python Generators,<br />
<a href="http://lua-users.org/wiki/LuaCoroutinesVersusPythonGenerators">http://lua-users.org/wiki/LuaCoroutinesVersusPythonGenerators</a>
</li>

</ol>



<p></p><p></p>
<p><small>Autor: <a href="http://www.fit.vutbr.cz/~tisnovpa">Pavel Tišnovský</a> &nbsp; 2015</small></p>
</body>
</html>

