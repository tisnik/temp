<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
        "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html>
<head>
<title>Jazyk Shine: „lepší“ Lua</title>
<meta name="Author" content="Pavel Tisnovsky" />
<meta name="Generator" content="vim" />
<meta http-equiv="content-type" content="text/html; charset=utf-8" />
<style type="text/css">
         body {color:#000000; background:#ffffff;}
         h1  {font-family: arial, helvetica, sans-serif; color:#ffffff; background-color:#c00000; text-align:center; padding-left:1em}
         h2  {font-family: arial, helvetica, sans-serif; color:#ffffff; background-color:#0000c0; padding-left:1em; text-align:left}
         h3  {font-family: arial, helvetica, sans-serif; color:#000000; background-color:#c0c0c0; padding-left:1em; text-align:left}
         h4  {font-family: arial, helvetica, sans-serif; color:#000000; background-color:#e0e0e0; padding-left:1em; text-align:left}
         a   {font-family: arial, helvetica, sans-serif;}
         li  {font-family: arial, helvetica, sans-serif; color:#000000; text-align:justify; width:450px;}
         ol  {font-family: arial, helvetica, sans-serif; color:#000000; text-align:justify; width:450px;}
         ul  {font-family: arial, helvetica, sans-serif; color:#000000; text-align:justify; width:450px;}
         p   {font-family: arial, helvetica, sans-serif; color:#000000; text-align:justify;}
         pre {background:#e0e0e0}
</style>
</head>

<body>

<h1>Jazyk Shine: „lepší“ Lua</h1>

<h3>Pavel Tišnovský</h3>

<p></p>

<h1>Úvodník</h1>

<p>V dnešním článku se seznámíme se základními vlastnostmi programovacího jazyka nazvaného Shine. Jedná se o jazyk, který je postaven na známém a poměrně populárním jazyku Lua i na ekosystému LuaJITu. Výsledek je poměrně zajímavý i prakticky použitelný.</p>



<h2>Obsah</h2>

<p><a href="#k01">1. Programovací jazyk Lua: stálice na poli programovacích jazyků</a></p>
<p><a href="#k02">2. LuaJIT</a></p>
<p><a href="#k03">3. Lua je stabilním jazykem, pro některé účely však až příliš stabilním</a></p>
<p><a href="#k04">4. Od jazyku Lua ke Shine</a></p>
<p><a href="#k05">5. Překlad jazyka Shine</a></p>
<p><a href="#k06">6. Program typu &bdquo;Hello, world&ldquo; ve variantě pro jazyky Lua i Shine</a></p>
<p><a href="#k07">7. Volání funkcí s&nbsp;větším počtem parametrů</a></p>
<p><a href="#k08">8. Zápis komentářů do programového kódu</a></p>
<p><a href="#k09">9. Definice funkce, volání funkce</a></p>
<p><a href="#k10">10. Specifikace výchozích hodnot parametrů volané funkce</a></p>
<p><a href="#k11">11. Nepovinná typová kontrola</a></p>
<p><a href="#k12">12. Specifikace typu globálních i lokálních proměnných</a></p>
<p><a href="#k13">13. Viditelnost proměnných: rozdíl mezi jazykem Lua a Shine</a></p>
<p><a href="#k14">14. Globální a lokální proměnná se stejným jménem</a></p>
<p><a href="#k15">15. Nelokální proměnné a uzávěry</a></p>
<p><a href="#k16">*** 16. Uzávěr s&nbsp;parametrem</a></p>
<p><a href="#k17">*** 17. Obsah druhé části článku</a></p>
<p><a href="#k18">18. Repositář s&nbsp;demonstračními příklady</a></p>
<p><a href="#k19">19. Odkazy na relevantní články a seriály na Rootu</a></p>
<p><a href="#k20">20. Odkazy na Internetu</a></p>



<p><a name="k01"></a></p>
<h2 id="k01">1. Programovací jazyk Lua: stálice na poli programovacích jazyků</h2>

<p>S&nbsp;programovacím jazykem <i>Lua</i> jsme se již na stránkách tohoto
serveru setkali, a to dokonce již mnohokrát (i když se mnohdy jedná o poněkud
starší články). Většina základních informací o tomto programovacím jazyku je
shrnuta do seriálu <a
href="https://www.root.cz/serialy/programovaci-jazyk-lua/">Programovací jazyk
Lua</a> a taktéž jsme se Luou zabývali ve druhém seriálu nazvaném <a
href="https://www.root.cz/serialy/torch-framework-pro-strojove-uceni/">Torch:
framework pro strojové učení</a>. Víme již, že se tento programovací jazyk stal
oblíbený například mezi tvůrci her, v&nbsp;nichž je použit pro skriptování (a
nutno dodat, že se v&nbsp;této oblasti stále používá). To ovšem není zdaleka
vše, protože Lua je použita například i v&nbsp;systému <i>LuaTeX</i>,
v&nbsp;databázi <i>Redis</i>, ve webovém serveru <i>Nginx</i> a
v&nbsp;neposlední řadě i v&nbsp;textovém editoru <i>Neovim</i>, což je
v&nbsp;několika ohledech vylepšená varianta slavného Vimu. Jednoduše použitelná
syntaxe a současně i poměrně velká vyjadřovací schopnost jazyka Lua by však
pravděpodobně nedostačovala pro jeho masovější rozšíření, a to zejména
v&nbsp;situaci, kdy tuto niku programovacích jazyků do značné míry okupuje
programovací jazyk <a href="https://www.root.cz/n/python/">Python</a>, kterému
se již úspěšně podařilo v&nbsp;menší či větší míře &bdquo;odstavit&ldquo;
některé konkurenty.</p>

<p><div class="rs-tip-major">Poznámka: připomeňme si, že jsme si taktéž popsali
programovací jazyk <i>Moonscript</i>, který do značné míry využívá ekosystém
vybudovaný okolo jazyka Lua (ve skutečnosti je přímo transpilovaný do Luy).
Odkazy na příslušné články jsou uvedeny v&nbsp;předposlední kapitole.</div></p>

<p>Hlavním důvodem, proč jsou některé hry, například <i>Escape from Monkey
Island</i>, <i>Grim Fandango</i>, <i>Fish Fillets</i>, <i>Neverwinter
Nights</i> či <i>MDK2</i> (což jsou, pravda, starší tituly) z&nbsp;menší či
větší části naprogramované právě v&nbsp;jazyku Lua, spočívá v&nbsp;tom, že
kombinace nízkoúrovňového a skriptovacího jazyka umožňuje soustředit se při
vývoji na podstatné věci &ndash; herní engine vytvořit co nejefektivnější
s&nbsp;využitím všech možností nízkoúrovňového jazyka a naopak herní scénář a
logiku hry naskriptovat s&nbsp;co největším urychlením cyklu
oprava–překlad–spuštění.</p>

<p>V&nbsp;mnoha případech se také využívá další užitečné vlastnosti jazyka Lua
&ndash; celý překladač i interpret vygenerovaného bajtkódu (popř.&nbsp;pouze
interpret) je možné velmi snadno zabudovat do jiné aplikace, přičemž se
výsledná velikost spustitelného souboru této aplikace zvětší o cca 70 kB
(popř.&nbsp;lze volat dynamickou knihovnu o řádově stejné velikosti), což není
mnoho, navíc když si uvědomíme, že dostáváme k&nbsp;dispozici plnohodnotný
vysokoúrovňový programovací jazyk (ostatně Lua se díky své malé velikosti
používá i pro pouhé zpracování konfiguračních souborů, které díky tomu mohou
obsahovat různé konstanty, výrazy atd.).</p>



<p><a name="k02"></a></p>
<h2 id="k02">2. LuaJIT</h2>

<p>Ekosystém programovacího jazyka Lua sice není tak rozsáhlý, jako je tomu
například v&nbsp;případě Pythonu a Javy (nemluvě již o JavaScriptu), ale i
přesto v&nbsp;něm nalezneme poměrně zajímavé technologie. Kromě standardního
interpretru jazyka Lua tak existují transpilery tohoto jazyka, například
<i>lua2js</i>, virtuální stroje pro Luu běžící ve webovém prohlížeči
(<i>LuaVM</i>) atd. Ovšem jedním z&nbsp;nejdůležitějších projektů je
<i>LuaJIT</i>. <i>LuaJIT</i> je původně z&nbsp;velké části dílem jediného
programátora, který se jmenuje <i>Mike Pall</i>. To je velmi zajímavá
skutečnost, zvláště když si uvědomíme, že <i>LuaJIT</i> je v&nbsp;současné
verzi velmi kvalitní produkt podporující větší množství procesorových
architektur (na jiných JITech se běžně podílejí minimálně desítky
vývojářů).</p>

<p>LuaJIT je skutečným <i>just-in-time</i> překladačem, který je rozdělen do
několika modulů, které při spuštění aplikace vytvořené v&nbsp;programovacím
jazyku Lua musí vzájemně spolupracovat. Prvním modulem je překladač sloužící
pro kompilaci zdrojového kódu napsaného v&nbsp;Lue do mezijazyka, který budeme
v&nbsp;dalším textu zkráceně označovat <strong>IR</strong> &ndash;
<i>Intermediate Representation</i>. IR je navržen takovým způsobem, aby mohl
být buď interpretován (jde o ty části kódu, které nejsou spouštěny příliš
často) nebo překládán do nativního strojového kódu s&nbsp;využitím JITu
(většinou se jedná o opětovně spouštěné části kódu).</p>

<p>Důležité je, že v&nbsp;projektu <i>LuaJIT</i> se využívá takzvaný
&bdquo;trasovací JIT překladač&ldquo;, který se v&nbsp;několika ohledech
odlišuje od dnes asi známějších JIT překladačů typu hot spot (typickým
příkladem je HotSpot JIT použitý v&nbsp;JVM, jehož poměrně podrobnému popisu
jsme se již <a
href="http://www.root.cz/serialy/programovaci-jazyk-java-a-jvm/">v&nbsp;tomto
seriálu</a> kdysi věnovali).</p>

<p>Činnost trasovacích JITů je založena na dvou snadno pochopitelných
předpokladech. Prvním předpokladem je, že typické aplikace tráví nejvíce času
(přesněji řečeno strojového času) v&nbsp;programových smyčkách (tento
předpoklad je někdy rozšířen i o tail rekurzi). Druhým předpokladem je, že
pokud se vykonává programová smyčka, bude cesta v&nbsp;kódu pravděpodobně vždy
stejná popř.&nbsp;v&nbsp;horším případě že bude existovat jen několik cest
v&nbsp;programovém kódu (cestou je myšlena sekvence instrukcí). Trasovací JITy
založené na těchto předpokladech se soustředí na detekci tzv. <i>hot-loops</i>,
tedy často vykonávaných programových smyček. Tyto smyčky jsou následně
optimalizovány a přeloženy do nativního kódu mikroprocesoru.</p>

<p>Při optimalizacích se provádí mnoho operací, s&nbsp;nimiž se můžeme setkat i
s&nbsp;běžných překladačích &ndash; eliminace mrtvého kódu (zmenšují se nároky
na instrukční cache), rozbalení smyček (snižuje se počet skoků a tím pádem se i
vylepšuje využití instrukční pipeline) atd. Detekce <i>hot-loops</i> byla
v&nbsp;tradičních trasovacích JITech implementována analýzou zpětných
podmíněných skoků (vedoucích na začátek smyčky), ovšem v&nbsp;<i>LuaJITu</i> to
není nutné, a to díky speciálním instrukcím bajtkódu: <strong>LOOP</strong> a
<strong>FORI</strong>.</p>



<p><a name="k03"></a></p>
<h2 id="k03">3. Lua je stabilním jazykem, pro některé účely však až příliš stabilním</h2>

<p>Již <a href="#k01">v&nbsp;úvodní kapitole</a> jsme se zmínili o tom, že
jednou z&nbsp;předností programovacího jazyka Lua je jeho jednoduchá a snadno
naučitelná syntaxe a relativně dobré vyjadřovací schopnosti. Samotný
programovací jazyk je navíc i velmi stabilní, což zde konkrétně znamená, že se
nevydal cestou Pythonu, jenž je neustále rozšiřován o další a další programové
konstrukce. To je na jednu stranu (v&nbsp;některých oborech) poměrně velká
výhoda, na stranu druhou však nebudeme skrývat fakt, že některé vlastnosti
jazyka Lua jsou buď pro programátory poněkud neobvyklé či zcela zmatečné a
některé jazykové konstrukce prakticky úplně chybí (zejména v&nbsp;porovnání
s&nbsp;mainstreamem).</p>

<p>Mezi neobvyklé a možná i matoucí vlastnosti programovacího jazyka Lua patří
zejména způsob práce s&nbsp;tabulkami (což je jediná &bdquo;univerzální&ldquo;
datová struktura kombinující vlastnosti běžných polí se slovníky). Prvky pole
jsou indexovány od jedničky a možnost mít v&nbsp;jedné tabulce jak prvky
indexované celým číslem, tak i jiným klíčem ovlivňuje sémantiku programové
smyčky <i>for-each</i> (rozdíl mezi chováním <strong>pairs</strong> a
<strong>ipairs</strong>). Pro některé vývojáře může být matoucí i fakt, že
lokální proměnné je zapotřebí explicitně označit klíčovým slovem
<strong>local</strong>, jinak by se jednalo o proměnné globální či nelokální.
To je v&nbsp;poměrně ostrém kontrastu s&nbsp;jazykem <i>Python</i>, v&nbsp;němž
jsou naopak nijak neoznačené proměnné považovány za lokální (což s&nbsp;sebou
ovšem nese komplikace u nelokálních proměnných, které je nutné označit
relativně novým klíčovým slovem <strong>nonlocal</strong> &ndash; o tomto
problému jsme se mimochodem zmiňovali v&nbsp;souvislosti s&nbsp;uzávěry).</p>

<p>Mezi chybějící či zdánlivě chybějící vlastnosti jazyka Lua patří podpora pro
objektově orientované programování. Ve skutečnosti je možné i v&nbsp;Lue
pracovat s&nbsp;objekty a jejich &bdquo;šablonami&ldquo; (což zhruba odpovídá
třídám), ovšem jedná se o přístup, který je poněkud specifický a pro
programátory přicházející z&nbsp;jiných programovacích jazyků neobvyklý. Dalším
chybějícím konceptem, resp.&nbsp;přesněji řečeno technikou, která je
potenciálně velmi užitečná, je podpora pro dekorátory (například tak, jak jsou
využity právě v&nbsp;&bdquo;konkurenčním&ldquo; programovacím jazyku Python). A
taktéž chybí konstrukce podobná <strong>with</strong> použitelná společně se
správci kontextů (<i>context managers</i>). A v&nbsp;neposlední řadě (a pro
mnohé na prvním místě) je chybějící podpora pro specifikaci typů parametrů a
proměnných.</p>



<p><a name="k04"></a></p>
<h2 id="k04">4. Od jazyku Lua ke Shine</h2>

<p>Řešením některých <a href="#k03">výše zmíněných problémů a nedostatků</a>
programovacího jazyka Lua by se mohl zdát relativně nový a neznámý programovací
jazyk nazvaný <i>Shine</i> (což je mimochodem jméno, které dobře zapadá do
konceptu jmen souvisejících s&nbsp;Měsícem &ndash; mnoho projektů
v&nbsp;ekosystému jazyka Lua je pojmenováno podobně; ostatně v&nbsp;chybových
hlášeních níže objevíme slovo &bdquo;lunokhod&ldquo;). Tento jazyk do Luy
přidává nové jazykové konstrukce, vylepšuje práci s&nbsp;tabulkami a řetězci,
zlepšuje pravidla pro viditelnosti proměnných a taktéž přidává podporu pro
zápis typů. Skripty jsou přitom nikoli pouze interpretovány, ale JITovány,
takže výsledné programy jsou mnohem rychlejší, než při pouhé interpretaci.</p>

<p><div class="rs-tip-major">Poznámka: jazyk Shine není ve skutečnosti žádnou
žhavou novinkou. Jeho vývoj byl zahájen přibližně před deseti lety (2013) a
v&nbsp;současnosti se zdá, že jeho aktivní vývoj dále neprobíhá (což je možná
velká škoda). I tak však může být užitečný, zejména v&nbsp;oblasti malých
mikropočítačů a u aplikací, kde &bdquo;čistá&ldquo; Lua nemusí dostačovat a
Python je příliš těžkotonážní řešení.</div></p>



<p><a name="k05"></a></p>
<h2 id="k05">5. Překlad jazyka Shine</h2>

<p>Interpret s&nbsp;JIT (<strong>shine</strong>) i překladač do bajtkódu
(<strong>shinec</strong>) je možné si snadno přeložit (což je většinou i
nutnost, pokud Shine nenaleznete v&nbsp;repositářích použité distribuce
Linuxu). K&nbsp;tomu je zapotřebí překladač céčka (GCC), nástroj make a taktéž
autotools.</p>

<p>Nejprve naklonujeme repositář se zdrojovými kódy Shine:</p>

<pre>
$ <strong>git clone git@github.com:richardhundt/shine.git</strong>
&nbsp;
Cloning into 'shine'...
remote: Enumerating objects: 1696, done.
remote: Counting objects: 100% (3/3), done.
remote: Compressing objects: 100% (3/3), done.
remote: Total 1696 (delta 0), reused 1 (delta 0), pack-reused 1693
Receiving objects: 100% (1696/1696), 597.94 KiB | 1.28 MiB/s, done.
Resolving deltas: 100% (1010/1010), done.
</pre>

<p>Přejdeme do adresáře, který byl naklonováním vytvořen:</p>

<pre>
$ <strong>cd shine</strong>
</pre>

<p>Spustíme překlad přímo zadáním <strong>make</strong>:</p>

<pre>
$ <strong>make</strong>
</pre>

<p>Překlad se zahájí operacemi, které nejsou příliš zajímavé:</p>

<pre>
...
...
...
mkdir -p /tmp/ramdisk/shine/build/deps
mkdir -p /tmp/ramdisk/shine/build/lang
mkdir -p /tmp/ramdisk/shine/build/core
mkdir -p /tmp/ramdisk/shine/build/libs
...
...
...
</pre>

<p>Následuje ovšem zajímavější operace &ndash; získání dalších modulů,
například modulu s&nbsp;implementací upravené varianty LuaJITu. Zdrojový kód
této VM se naklonuje a taktéž přeloží:</p>

<pre>
git submodule update --init /tmp/ramdisk/shine/deps/tvmjit
Submodule 'deps/tvmjit' (https://github.com/richardhundt/tvmjit.git) registered for path 'deps/tvmjit'
Cloning into '/tmp/ramdisk/shine/deps/tvmjit'...
Submodule path 'deps/tvmjit': checked out 'b58b5bef683f28cfb47df2f9bd0ed092f65b5132'
make PREFIX=/usr/local MULTILIB= TRAVIS=1 -C /tmp/ramdisk/shine/deps/tvmjit
make[1]: Entering directory '/tmp/ramdisk/shine/deps/tvmjit'
==== Building TvmJIT 0.1.3 ====
make -C src
make[2]: Entering directory '/tmp/ramdisk/shine/deps/tvmjit/src'
HOSTCC    host/minilua.o
HOSTLINK  host/minilua
DYNASM    host/buildvm_arch.h
HOSTCC    host/buildvm.o
</pre>

<p>Výsledkem překladu je dvojice spustitelných souborů <strong>shine</strong> a
<strong>shinec</strong> uložená v&nbsp;podadresáři <strong>build</strong>:</p>

<pre>
$ <strong>ls -l build/shine*</strong>
&nbsp;
-rwxrwxr-x 1 ptisnovs ptisnovs 708520 Mar 29 09:21 build/shine
-rwxrwxr-x 1 ptisnovs ptisnovs 704384 Mar 29 09:21 build/shinec
-rw-rw-r-- 1 ptisnovs ptisnovs   2915 Mar 29 09:21 build/shinec.o
-rw-rw-r-- 1 ptisnovs ptisnovs   3516 Mar 29 09:21 build/shine.o
</pre>

<p>Jedná se o poměrně velké soubory (700 kB), resp.&nbsp;přesněji řečeno jsou
velké z&nbsp;pohledu ekosystému jazyka Lua, zatímco v&nbsp;jiných ekosystémech
by se jednalo o zanedbatelnou velikost. Můžeme se pokusit o zmenšení pomocí
nástroje <strong>strip</strong>:</p>

<pre>
$ <strong>strip build/shine</strong>
&nbsp;
$ <strong>strip build/shinec</strong>
&nbsp;
</pre>

<p>Výsledné velikosti:</p>

<pre>
$ <strong>ls -l build/shine*</strong>
&nbsp;
-rwxrwxr-x 1 ptisnovs ptisnovs 637624 Mar 29 09:23 build/shine
-rwxrwxr-x 1 ptisnovs ptisnovs 633528 Mar 29 09:24 build/shinec
-rw-rw-r-- 1 ptisnovs ptisnovs   2915 Mar 29 09:21 build/shinec.o
-rw-rw-r-- 1 ptisnovs ptisnovs   3516 Mar 29 09:21 build/shine.o
</pre>

<p>Spustitelný soubor <strong>shinec</strong> dokáže přeložit zdrojové kódy do
bajtkódu nebo do mezikódu a taktéž dokáže zobrazit strukturu kódu po převedení
do formy stromu. K&nbsp;popisu tohoto nástroje se dostaneme příště:</p>

<pre>
$ <strong>build/shinec</strong>
&nbsp;
usage: build/shinec [options]... input output.
Available options are:
  -t type       Output file format.
  -b            List formatted bytecode.
  -n name       Provide a chunk name.
  -g            Keep debug info.
  -p            Print the parse tree.
  -o            Print the opcode tree.
</pre>

<p>Spustitelný soubor <strong>shine</strong> představuje interpret jazyka Shine
vybavený JIT překladačem. Je možné ho použít samostatně, tj.&nbsp;zbytek celého
repositáře není nutné mít k&nbsp;dispozici pro správnou verzi interpretru:</p>

<pre>
$ <strong>build/shine </strong>
&nbsp;
Shine 0.1.1 -- Copyright (C) 2013-2016 Richard Hundt.
shine&gt;
</pre>



<p><a name="k06"></a></p>
<h2 id="k06">6. Program typu &bdquo;Hello, world&ldquo; ve variantě pro jazyky Lua i Shine</h2>

<p>Při prakticky každém popisu nového programovacího jazyka se začíná
programem, který po svém spuštění vypíše zprávu &bdquo;Hello, world!&ldquo;
nebo její obdobu. Jak v&nbsp;jazyku Lua, tak i v&nbsp;jazyku Shine je zápis
takového programu totožný &ndash; zavolá se vestavěná funkce
<strong>print</strong>, které se předá řetězec se zprávou:</p>

<pre>
print("Hello, world!")
</pre>

<p>Navíc jak jazyk Lua, tak i Shine podporuje vynechání závorek okolo argumentu
funkce v&nbsp;případě, že se funkci předává jen jediný argument. Můžeme tedy
pouze psát:</p>

<pre>
print "Hello, world!"
</pre>

<p><div class="rs-tip-major">Poznámka: středníky ukončující příkazy jsou
nepovinné a většinou se nikdo nenamáhá s&nbsp;jejich použitím.</div></p>



<p><a name="k07"></a></p>
<h2 id="k07">7. Volání funkcí s&nbsp;větším počtem parametrů</h2>

<p>V&nbsp;programovacím jazyku Lua je možné kulaté závorky okolo argumentů
funkce vynechat jen v&nbsp;případě, že se předává jediný argument. To tedy
znamená, že následující příkaz je nekorektní:</p>

<pre>
print 1, 2, 3
</pre>

<p>Na tuto chybu nás interpret jazyka Lua upozorní:</p>

<pre>
$ <strong>lua 03_print_values.lua</strong>
&nbsp;
lua: 03_print_values.lua:1: syntax error near '1'
</pre>

<p>Naproti tomu programovací jazyk Shine povoluje tento zápis povoluje:</p>

<pre>
print 1, 2, 3
</pre>

<pre>
$ <strong>./shine 03_print_values.shn</strong>
&nbsp;
1       2       3
</pre>

<p><div class="rs-tip-major">Poznámka: interpret <strong>shine</strong> dokáže
do značné míry emulovat chování klasického interpretru jazyka Lua. To
v&nbsp;praxi znamená, že pokud se pokusíme o spuštění původního skriptu
s&nbsp;koncovkou &bdquo;.lua&ldquo;, i <strong>shine</strong> vypíše
chybu:</div></p>

<pre>
$ <strong>./shine 03_print_values.lua </strong>
&nbsp;
Error: [string "shine"]:0: [string "lunokhod"]:0: 03_print_values.lua:1: unexpected symbol near 1
stack traceback:
        [C]: in function 'assert'
        [string "shine"]: in main chunk
        [string "shine"]: in main chunk
        [C]: at 0x564ce89e7510
</pre>



<p><a name="k08"></a></p>
<h2 id="k08">8. Zápis komentářů do programového kódu</h2>

<p>Připomeňme si, že v&nbsp;jazyku Lua jsou podporovány dva typy komentářů.
Jednořádkový komentář začíná dvěma pomlčkami, podobně jako v&nbsp;jazyku SQL
(což se mimochodem zapisuje rychleji, než například znak #):</p>

<pre>
-- jednoradkovy komentar
</pre>

<p>Víceřádkový komentář je zapsán stylem:</p>

<pre>
--[[
   viceradkovy
   komentar
]]
</pre>

<p>Toto je tedy zcela korektní skript zpracovatelný jak intepretrem jazyka Lua,
tak i Shine:</p>

<pre>
-- jednoradkovy komentar
print("Hello")
&nbsp;
--[[
   viceradkovy
   komentar
]]
&nbsp;
print("world")
</pre>

<p>V&nbsp;jazyce Shine je k&nbsp;dispozici ještě jeden typ víceřádkového
komentáře, který je primárně určen pro to, aby se daná (zakomentovaná) část
kódu zpracovala dalšími nástroji. Tento zápis je nepatrně komplikovanější, ale
umožňuje specifikovat symbol pro ukončení komentáře. Zápis vypadá
následovně:</p>

<pre>
--:{zvolený-symbol}:
   specialni
   viceradkovy
   komentar
:{zvolený-symbol}:
</pre>

<p>Následující skript je tedy zpracovatelný jen interpretrem jazyka Shine:</p>

<pre>
-- jednoradkovy komentar
print("Hello")
&nbsp;
--[[
   viceradkovy
   komentar
]]
print("world")
&nbsp;
--:END:
   specialni
   viceradkovy
   komentar
:END:
print("!")
</pre>

<p>Navíc je možné (například) do symbolu s&nbsp;komentářem zapsat i nějaké
parametry, které bude interpret Shine ignorovat, ale které mohou být použité
jiným nástrojem, typicky pro vygenerování nápovědy, &bdquo;stubu&ldquo; pro
další jazyky atd. Příklad specifikace argumentu &bdquo;use-asciidoc&ldquo;:</p>

<pre>
--:format(use-asciidoc):
   specialni
   viceradkovy
   komentar
:format:
</pre>



<p><a name="k09"></a></p>
<h2 id="k09">9. Definice funkce, volání funkce</h2>

<p>Základním stavebním prvkem pro tvorbu abstrakcí v&nbsp;programech psaných
v&nbsp;jazycích Lua i Shine jsou funkce. Ty se deklarují v&nbsp;obou jazycích
stejným způsobem, i když v&nbsp;dalším textu uvidíme, že Shine nabízí i další
možnosti a rozšíření. Podívejme se nejdříve na deklaraci jednoduché funkce se
dvěma parametry následovanou zavoláním této funkce:</p>

<pre>
function print_two_values(a, b)
    print(a, b)
end
&nbsp;
print_two_values(1, 2)
</pre>

<p>Jazyk Shine navíc umožňuje (kromě dalších možností) volání funkce bez zápisu
kulatých závorek, a to i v&nbsp;případě, že má funkce větší množství parametrů
(což jsme již ostatně viděli na příkladu s&nbsp;<strong>print</strong>):</p>

<pre>
function print_two_values(a, b)
    print(a, b)
end
&nbsp;
print_two_values(1, 2)
print_two_values 1, 2
</pre>



<p><a name="k10"></a></p>
<h2 id="k10">10. Specifikace výchozích hodnot parametrů volané funkce</h2>

<p>V&nbsp;programovacím jazyku Shine je možné, ostatně podobně jako i
v&nbsp;dalších moderních programovacích jazycích, specifikovat výchozí hodnoty
parametrů funkce. Pokud se hodnoty těchto parametrů (tedy argumenty) explicitně
při volání funkce neuvedou, použije se právě tato výchozí hodnota:</p>

<pre>
function print_two_values(a, b=2)
    print(a, b)
end
&nbsp;
print_two_values 100, 200
print_two_values 100
</pre>

<p>Výsledkem budou tyto zprávy:</p>

<pre>
100     200
100     2
</pre>

<p>Pokud se výchozí hodnoty specifikují u všech parametrů, budou při volání
funkce všechny argumenty nepovinné:</p>

<pre>
function print_two_values(a=1, b=2)
    print(a, b)
end
&nbsp;
print_two_values 100, 200
print_two_values 100
print_two_values
</pre>

<p>Výsledek získaný po zavolání tohoto skriptu:</p>

<pre>
100     200
100     2
1       2
</pre>

<p>Pozor je ovšem nutné dát na to, že nelze použít &bdquo;pythonovský&ldquo;
způsob zápisu s&nbsp;explicitním určením jména a hodnoty při volání:</p>

<pre>
function print_two_values(a=1, b=2)
    print(a, b)
end
&nbsp;
<strong>print_two_values a=100</strong>
</pre>

<p>Ten povede k&nbsp;chybě:</p>

<pre>
Error: [string "core"]:0: cannot bind 100 to: function(a, b): 0x40912da8
stack traceback:
        [C]: in function 'error'
        [string "core"]: in function 'bind'
        [string "core"]: in function '__extract__'
        error.shn:5: in main chunk
        [string "shine"]: in main chunk
        [string "shine"]: in main chunk
        [C]: at 0x555ca0a40510
&nbsp;
shell returned 1
</pre>

<p>Naproti tomu je možné &ndash; na rozdíl od Pythonu &ndash; nejprve uvést
parametry s&nbsp;výchozí hodnotou a teprve poté běžné poziční parametry:</p>

<pre>
function print_two_values(a=1, b)
    print(a, b)
end

print_two_values 100, 200
print_two_values 100
print_two_values
</pre>

<p>Tentokrát se v&nbsp;posledních dvou voláních do parametru <strong>b</strong>
nedosadí žádná hodnota (argument), takže se použije výchozí hodnota
<strong>nil</strong>, a to bez nahlášení chyby:</p>

<pre>
100     200
100     nil
1       nil
</pre>



<p><a name="k11"></a></p>
<h2 id="k11">11. Nepovinná typová kontrola</h2>

<p>Zapomenout nesmíme asi na pravděpodobně největší potenciální přínos
programovacího jazyka Shine. Nejsou to ani nové jazykové konstrukce (syntaxe),
ale možnost specifikace typů (tedy spíše sémantická záležitost). Nejprve si
ukažme způsob specifikace typu parametru funkce. Je to snadné a používá se zde
slovo <strong>is</strong>, zatímco například v&nbsp;podobně koncipovaném
Pythonu se používá dvojtečka:</p>

<pre>
function <strong>print_number</strong>(a is Number)
    print(a)
end
&nbsp;
print_number(100)
print_number(3.14)
print_number("foo")
print_number(nil)
</pre>

<p>V&nbsp;případě, že tento skript spustíme, vypíše se první předaný argument
(ten <i>je</i> typu Number), taktéž druhý předaný argument (i reálná čísla jsou
Number)  a poté se již detekuje chyba:</p>

<pre>
100
3.14
Error: 09_type_checks.shn:7: bad argument #1 to 'print_number' (Number expected got String)
stack traceback:
        [C]: in function 'error'
        09_type_checks.shn:1: in function 'print_number'
        09_type_checks.shn:7: in main chunk
        [string "shine"]: in main chunk
        [string "shine"]: in main chunk
        [C]: at 0x559e2c5e2510
;
</pre>

<p>Mezi základní datové typy patří:</p>

<table>
<tr><th>Jméno typu</th></tr>
<tr><td>Nil</td></tr>
<tr><td>Boolean</td></tr>
<tr><td>Number</td></tr>
<tr><td>String</td></tr>
<tr><td>Table</td></tr>
<tr><td>Function</td></tr>
<tr><td>Coroutine</td></tr>
<tr><td>UserData</td></tr>
<tr><td>CData</td></tr>
<tr><td>null</td></tr>
<tr><td>Array</td></tr>
<tr><td>Range</td></tr>
<tr><td>Error</td></tr>
<tr><td>Class</td></tr>
<tr><td>Module</td></tr>
<tr><td>Grammar</td></tr>
<tr><td>Pattern</td></tr>
<tr><td>ArrayPattern</td></tr>
<tr><td>TablePattern</td></tr>
<tr><td>ApplyPattern</td></tr>
<tr><td>Meta</td></tr>
</table>

<p><div class="rs-tip-major">Poznámka: informace o jednotlivých vybraných
datových typech bude uvedena příště.</div></p>



<p><a name="k12"></a></p>
<h2 id="k12">12. Specifikace typu globálních i lokálních proměnných</h2>

<p>Naprosto stejným způsobem lze specifikovat typ globálních proměnných při
jejich deklaraci:</p>

<pre>
a is Number = 10
b is String = "foo"
c is Boolean = true
d is Nil = nil
&nbsp;
print a
print b
print c
print d
</pre>

<p>Nekorektní použití vypadá následovně:</p>

<pre>
a is Number = "foo"
b is String = 3
c is Boolean = nil
d is Nil = true
&nbsp;
print a
print b
print c
print d
</pre>

<p>Chyba detekovaná interpretrem Shine:</p>

<pre>
Error: 11_variable_types.shn:1: bad assignment to 'a' (Number expected got String)
stack traceback:
        [C]: in function 'error'
        [string "core"]: in function '__check__'
        11_variable_types.shn:1: in main chunk
        [string "shine"]: in main chunk
        [string "shine"]: in main chunk
        [C]: at 0x560afc92d510
</pre>

<p>Ukažme si ještě způsob deklarace typů u lokálních proměnných. Zápis vypadá
stejně, jako v&nbsp;předchozích dvou příkladech:</p>

<pre>
function test()
    a is Number = 10
    b is String = "foo"
    c is Boolean = true
    d is Nil = nil
&nbsp;
    print a
    print b
    print c
    print d
end
&nbsp;
test
</pre>



<p><a name="k13"></a></p>
<h2 id="k13">13. Viditelnost proměnných: rozdíl mezi jazykem Lua a Shine</h2>

<p>Poměrně nepraktickou vlastností programovacího jazyka Lua je jeho způsob
rozlišování globálních a lokálních proměnných. Připomeňme si, že při přiřazení
hodnoty do nové proměnné je tato proměnná vytvořena. A v&nbsp;případě, že není
použito klíčové slovo <strong>local</strong>, je nově vytvořená proměnná
globální. To je vlastně přesný opak sémantiky jazyka Python, kde je naopak
taková proměnná lokální.</p>

<p>Například následující skript zapsaný v&nbsp;jazyce Lua vytvoří po zavolání
funkce <strong>test</strong> novou <i>globální</i> proměnnou
<strong>a</strong>, která bude viditelná i při výskoku z&nbsp;této funkce:</p>

<pre>
function test()
    a = 10
end
&nbsp;
test()
print(a)
</pre>

<p>Tento skript bude funkční a při svém spuštění vypíše hodnotu 10.</p>

<p>Programovací jazyk Shine má v&nbsp;tomto případě odlišnou sémantiku, protože
proměnná <strong>a</strong> naplněná uvnitř funkce <strong>test</strong> bude
globální:</p>

<pre>
function test()
    a = 10
end
&nbsp;
test()
print(a)
</pre>

<p>Při pokusu o spuštění tohoto skriptu vznikne chyba:</p>

<pre>
Error: [string "shine.lang.translator"]:0: shine: 13_local_variables.shn:6: "a" used but not defined
&nbsp;
stack traceback:
        [C]: in function 'error'
        [string "shine.lang.translator"]: in function 'abort'
        [string "shine.lang.translator"]: in function 'close'
        [string "shine.lang.translator"]: in function 'translate'
        [string "shine.lang.loader"]: in function 'loadchunk'
        [string "shine"]: in main chunk
        [string "shine"]: in main chunk
        [C]: at 0x561f56df3510
</pre>

<p>Lokální proměnnou lze označit klíčovým slovem <strong>local</strong>, a to i
v&nbsp;jazyku Lua:</p>

<pre>
function test()
    local a = 10
end
&nbsp;
test()
print(a)
</pre>

<p>Tento skript se (bohužel) dokončí bez chyby a vypíše se:</p>

<pre>
nil
</pre>

<p><div class="rs-tip-major">Poznámka: to je v&nbsp;praxi a u větších aplikací
velmi problematické chování.</div></p>

<p>Klíčové slovo <strong>local</strong> můžeme použít i ve Shine, i když zde má
stejný význam, jako přiřazení do proměnné bez zápisu tohoto klíčového
slova:</p>

<pre>
function test()
    local a = 10
end
&nbsp;
test()
print(a)
</pre>

<p>Výsledkem bude (opět) chybové hlášení:</p>

<pre>
Error: [string "shine.lang.translator"]:0: shine: 14_local_variable.shn:6: "a" used but not defined
&nbsp;
stack traceback:
        [C]: in function 'error'
        [string "shine.lang.translator"]: in function 'abort'
        [string "shine.lang.translator"]: in function 'close'
        [string "shine.lang.translator"]: in function 'translate'
        [string "shine.lang.loader"]: in function 'loadchunk'
        [string "shine"]: in main chunk
        [string "shine"]: in main chunk
        [C]: at 0x55f6fdf73510
</pre>



<p><a name="k14"></a></p>
<h2 id="k14">14. Globální a lokální proměnná se stejným jménem</h2>

<p>Vyzkoušejme si chování programovacího jazyka Shine v&nbsp;případě, že je ve
funkci deklarována nová proměnná s&nbsp;uvedením klíčového slova
<strong>local</strong> a současně existuje stejná globální proměnná stejného
jména. Zajímat nás bude, jaká hodnota se vypíše posledním příkazem
<strong>print</strong>:</p>

<pre>
a = 20
&nbsp;
function test()
    local a = 10
end
&nbsp;
test()
print(a)
</pre>

<p>Po spuštění tohoto příkladu se podle očekávání vypíše hodnota 20.</p>

<p>Druhý skript je prakticky totožný, ovšem chybí zde klíčové slovo
<strong>local</strong>:</p>

<pre>
a = 20
&nbsp;
function test()
    a = 10
end
&nbsp;
test()
print(a)
</pre>

<p>Nyní se vypíše hodnota 10. Proč tomu tak je? Jazyk Shine zjistil, že se
snažíme změnit hodnotu proměnné <strong>a</strong>, která existuje a je
viditelná. Proto nevytvořil proměnnou novou.</p>

<p><div class="rs-tip-major">Poznámka: odlišná sémantika viditelnosti
proměnných je jedním z&nbsp;největších rozdílů mezi jazyky Lua a Shine a je
zapotřebí si na ni dávat pozor.</div></p>



<p><a name="k15"></a></p>
<h2 id="k15">15. Nelokální proměnné a uzávěry</h2>

<p>S&nbsp;problematikou viditelnosti proměnných souvisí i možnost přístupu
k&nbsp;nelokálním proměnným, tj.&nbsp;k&nbsp;proměnným, které nejsou globální a
současně jsou definovány vně nějaké funkce. Tyto proměnné se typicky používají
v&nbsp;uzávěrech (<i>closure</i>). Můžeme se pokusit o vytvoření jednoduchého
uzávěru, který bude pracovat jako čítač: funkce <strong>next</strong>, která je
návratovou hodnotou &bdquo;konstruktoru&ldquo; <strong>counter</strong> při
každém svém zavolání vrátí hodnotu čítače zvýšenou o jedničku. Přitom při
každém zavolání &bdquo;konstruktoru&ldquo; <strong>counter</strong> získáme
nový čítač nezávislý na ostatních čítačích, což znamená, že na funkci
<strong>next</strong> bude navázána odlišná nelokální proměnná
<strong>cnt</strong>:</p>

<pre>
function counter()
    local cnt = 0
&nbsp;
    function next()
        cnt = cnt + 1
        return cnt
    end
&nbsp;
    return next
end
&nbsp;
&nbsp;
counter1 = counter()
&nbsp;
counter2 = counter()
counter2()
&nbsp;
for i = 0, 10 do
    result1 = counter1()
    result2 = counter2()
    print(i, result1, result2)
end
</pre>

<p>Otestujme si to v&nbsp;praxi, nejdříve při použití interpretru jazyka
Lua:</p>

<pre>
$ <strong>lua 17_counter_1.lua</strong>
&nbsp;
0       1       2
1       2       3
2       3       4
3       4       5
4       5       6
5       6       7
6       7       8
7       8       9
8       9       10
9       10      11
10      11      12
</pre>

<p>V&nbsp;jazyce Shine je zápis čítače naprosto totožný:</p>

<pre>
function counter()
    local cnt = 0
&nbsp;
    function next()
        cnt = cnt + 1
        return cnt
    end
&nbsp;
    return next
end
&nbsp;
&nbsp;
counter1 = counter()
&nbsp;
counter2 = counter()
counter2()
&nbsp;
for i = 0, 10 do
    result1 = counter1()
    result2 = counter2()
    print(i, result1, result2)
end
</pre>

<p>I chování jazyka Shine je stejné &ndash; získáme dva na sobě nezávislé
čítače:</p>

<pre>
$ <strong>./shine 17_counter_1.shn </strong>
&nbsp;
0       1       2
1       2       3
2       3       4
3       4       5
4       5       6
5       6       7
6       7       8
7       8       9
8       9       10
9       10      11
10      11      12
</pre>

<p>Navíc je možné v&nbsp;jazyce Shine zkrátit zápis:</p>

<pre>
cnt = cnt + 1
</pre>

<p>na:</p>

<pre>
cnt += 1
</pre>

<p>Což je provedeno v&nbsp;tomto skriptu:</p>

<pre>
function counter()
    cnt = 0
&nbsp;
    function next()
        cnt += 1
        return cnt
    end
&nbsp;
    return next
end
&nbsp;
&nbsp;
counter1 = counter()
&nbsp;
counter2 = counter()
counter2()
&nbsp;
for i = 0, 10 do
    result1 = counter1()
    result2 = counter2()
    print(i, result1, result2)
end
</pre>

<p><div class="rs-tip-major">Poznámka: v&nbsp;Pythonu by na tomto místě bylo
nutné použít klíčové slovo <strong>nonlocal</strong> pro specifikaci, že se
bude přistupovat k&nbsp;nelokální proměnné a že se tedy nemá vytvořit nová
čistě lokální proměnná:</div></p>

<pre>
def createCounter():
    counter = 0
    def next():
        nonlocal counter
        counter += 1
        return counter
    return next
&nbsp;
&nbsp;
&nbsp;
def main():
    counter1 = createCounter()
    counter2 = createCounter()
    for i in range(1,11):
        result1 = counter1()
        result2 = counter2()
        print("Iteration #%d" % i)
        print("    Counter1: %d" % result1)
        print("    Counter2: %d" % result2)
&nbsp;
&nbsp;
main()
</pre>

<p>Jen na okraj důkaz, že se tento skript chová podle předpokladů:</p>

<pre>
Iteration #1
    Counter1: 1
    Counter2: 1
Iteration #2
    Counter1: 2
    Counter2: 2
Iteration #3
    Counter1: 3
    Counter2: 3
Iteration #4
    Counter1: 4
    Counter2: 4
Iteration #5
    Counter1: 5
    Counter2: 5
Iteration #6
    Counter1: 6
    Counter2: 6
Iteration #7
    Counter1: 7
    Counter2: 7
Iteration #8
    Counter1: 8
    Counter2: 8
Iteration #9
    Counter1: 9
    Counter2: 9
Iteration #10
    Counter1: 10
    Counter2: 10
</pre>



<p><a name="k16"></a></p>
<h2 id="k16">16. Uzávěr s&nbsp;parametrem</h2>

<pre>
function counter(delta)
    local cnt = 0

    function next()
        cnt = cnt + delta
        return cnt
    end

    return next
end


counter1 = counter(2)

counter2 = counter(3)

for i = 0, 10 do
    result1 = counter1()
    result2 = counter2()
    print(i, result1, result2)
end
</pre>

<pre>
function counter(delta)
    local cnt = 0

    function next()
        cnt = cnt + delta
        return cnt
    end

    return next
end


counter1 = counter(2)

counter2 = counter(3)

for i = 0, 10 do
    result1 = counter1()
    result2 = counter2()
    print(i, result1, result2)
end
</pre>



<p><a name="k17"></a></p>
<h2 id="k17">17. Obsah druhé části článku</h2>



<p><a name="k18"></a></p>
<h2 id="k18">18. Repositář s&nbsp;demonstračními příklady</h2>

<p>Demonstrační příklady popsané v&nbsp;dnešním článku byly uloženy do
veřejného <a href="https://github.com/tisnik/presentations.git">Git
repositáře</a>, z&nbsp;něhož si je můžete snadno stáhnout a otestovat ve své
instalaci jazyka Shine:</p>

<table>
<tr><th> #</th><th>Soubor</th><th>Stručný popis</th><th>Odkaz</th></tr>
<tr><td>1</td><td>01_hello_world.lua</td><td>program typu &bdquo;Hello, world&ldquo; ve variantě pro programovací jazyky Lua i Shine</td><td><a href="https://github.com/tisnik/presentations/blob/master/shine/01_hello_world.lua">https://github.com/tisnik/presentations/blob/master/shine/01_hello_world.lua</a></td></tr>
<tr><td>2</td><td>02_hello_world.lua</td><td>program typu &bdquo;Hello, world&ldquo; ve variantě pro programovací jazyky Lua i Shine</td><td><a href="https://github.com/tisnik/presentations/blob/master/shine/02_hello_world.lua">https://github.com/tisnik/presentations/blob/master/shine/02_hello_world.lua</a></td></tr>
<tr><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td></tr>
<tr><td>3</td><td>03_print_values.lua</td><td>volání funkcí s&nbsp;větším počtem parametrů, varianta pro jazyk Lua</td><td><a href="https://github.com/tisnik/presentations/blob/master/shine/03_print_values.lua">https://github.com/tisnik/presentations/blob/master/shine/03_print_values.lua</a></td></tr>
<tr><td>4</td><td>03_print_values.shn</td><td>volání funkcí s&nbsp;větším počtem parametrů, varianta pro jazyk Shine</td><td><a href="https://github.com/tisnik/presentations/blob/master/shine/03_print_values.shn">https://github.com/tisnik/presentations/blob/master/shine/03_print_values.shn</a></td></tr>
<tr><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td></tr>
<tr><td>5</td><td>04_comments.lua</td><td>zápis komentářů do programového kódu, varianta pro jazyk Lua</td><td><a href="https://github.com/tisnik/presentations/blob/master/shine/04_comments.lua">https://github.com/tisnik/presentations/blob/master/shine/04_comments.lua</a></td></tr>
<tr><td>6</td><td>04_comments.shn</td><td>zápis komentářů do programového kódu, varianta pro jazyk Shine</td><td><a href="https://github.com/tisnik/presentations/blob/master/shine/04_comments.shn">https://github.com/tisnik/presentations/blob/master/shine/04_comments.shn</a></td></tr>
<tr><td>7</td><td>05_comments.shn</td><td>zápis komentářů do programového kódu, varianta pro jazyk Shine</td><td><a href="https://github.com/tisnik/presentations/blob/master/shine/05_comments.shn">https://github.com/tisnik/presentations/blob/master/shine/05_comments.shn</a></td></tr>
<tr><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td></tr>
<tr><td>8</td><td>06_function_call.lua</td><td>definice a volání funkcí, varianta pro jazyk Lua</td><td><a href="https://github.com/tisnik/presentations/blob/master/shine/06_function_call.lua">https://github.com/tisnik/presentations/blob/master/shine/06_function_call.lua</a></td></tr>
<tr><td>9</td><td>06_function_call.shn</td><td>definice a volání funkcí, varianta pro jazyk Shine</td><td><a href="https://github.com/tisnik/presentations/blob/master/shine/06_function_call.shn">https://github.com/tisnik/presentations/blob/master/shine/06_function_call.shn</a></td></tr>
<tr><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td></tr>
<tr><td>10</td><td>07_default_values.shn</td><td>výchozí hodnoty parametrů funkcí, první varianta</td><td><a href="https://github.com/tisnik/presentations/blob/master/shine/07_default_values.shn">https://github.com/tisnik/presentations/blob/master/shine/07_default_values.shn</a></td></tr>
<tr><td>11</td><td>08_default_values.shn</td><td>výchozí hodnoty parametrů funkcí, druhá varianta</td><td><a href="https://github.com/tisnik/presentations/blob/master/shine/08_default_values.shn">https://github.com/tisnik/presentations/blob/master/shine/08_default_values.shn</a></td></tr>
<tr><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td></tr>
<tr><td>12</td><td>09_type_checks.shn</td><td>specifikace typů parametrů funkcí</td><td><a href="https://github.com/tisnik/presentations/blob/master/shine/09_type_checks.shn">https://github.com/tisnik/presentations/blob/master/shine/09_type_checks.shn</a></td></tr>
<tr><td>13</td><td>10_variable_types.shn</td><td>specifikace typů proměnných, korektní typy</td><td><a href="https://github.com/tisnik/presentations/blob/master/shine/10_variable_types.shn">https://github.com/tisnik/presentations/blob/master/shine/10_variable_types.shn</a></td></tr>
<tr><td>14</td><td>11_variable_types.shn</td><td>specifikace typů proměnných, nekorektní typy</td><td><a href="https://github.com/tisnik/presentations/blob/master/shine/11_variable_types.shn">https://github.com/tisnik/presentations/blob/master/shine/11_variable_types.shn</a></td></tr>
<tr><td>15</td><td>12_variable_types_in_function.shn</td><td>specifikace typů parametrů lokálních proměnných</td><td><a href="https://github.com/tisnik/presentations/blob/master/shine/12_variable_types_in_function.shn">https://github.com/tisnik/presentations/blob/master/shine/12_variable_types_in_function.shn</a></td></tr>
<tr><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td></tr>
<tr><td>16</td><td>13_local_variables.lua</td><td>globální vs. lokální proměnné, varianta pro jazyk Lua</td><td><a href="https://github.com/tisnik/presentations/blob/master/shine/13_local_variables.lua">https://github.com/tisnik/presentations/blob/master/shine/13_local_variables.lua</a></td></tr>
<tr><td>17</td><td>13_local_variables.shn</td><td>globální vs. lokální proměnné, varianta pro jazyk Shine</td><td><a href="https://github.com/tisnik/presentations/blob/master/shine/13_local_variables.shn">https://github.com/tisnik/presentations/blob/master/shine/13_local_variables.shn</a></td></tr>
<tr><td>18</td><td>14_local_variable.shn</td><td>lokální proměnná, použití modifikátoru <strong>local</strong></td><td><a href="https://github.com/tisnik/presentations/blob/master/shine/14_local_variable.shn">https://github.com/tisnik/presentations/blob/master/shine/14_local_variable.shn</a></td></tr>
<tr><td>19</td><td>14_local_variables.lua</td><td>lokální proměnná, použití modifikátoru <strong>local</strong></td><td><a href="https://github.com/tisnik/presentations/blob/master/shine/14_local_variables.lua">https://github.com/tisnik/presentations/blob/master/shine/14_local_variables.lua</a></td></tr>
<tr><td>20</td><td>15_global_and_local_variable.shn</td><td>globální i lokální proměnná stejného jména, varianta s&nbsp;<strong>local</strong></td><td><a href="https://github.com/tisnik/presentations/blob/master/shine/15_global_and_local_variable.shn">https://github.com/tisnik/presentations/blob/master/shine/15_global_and_local_variable.shn</a></td></tr>
<tr><td>21</td><td>16_global_and_local_variable.shn</td><td>globální i lokální proměnná stejného jména, varianta bez <strong>local</strong></td><td><a href="https://github.com/tisnik/presentations/blob/master/shine/16_global_and_local_variable.shn">https://github.com/tisnik/presentations/blob/master/shine/16_global_and_local_variable.shn</a></td></tr>
<tr><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td></tr>
<tr><td>22</td><td>17_counter_1.lua</td><td>čítač vytvořený s&nbsp;využitím uzávěru, varianta pro jazyk Lua</td><td><a href="https://github.com/tisnik/presentations/blob/master/shine/17_counter_1.lua">https://github.com/tisnik/presentations/blob/master/shine/17_counter_1.lua</a></td></tr>
<tr><td>23</td><td>17_counter_1.shn</td><td>čítač vytvořený s&nbsp;využitím uzávěru, varianta pro jazyk Shine</td><td><a href="https://github.com/tisnik/presentations/blob/master/shine/17_counter_1.shn">https://github.com/tisnik/presentations/blob/master/shine/17_counter_1.shn</a></td></tr>
<tr><td>24</td><td>18_counter_1.shn</td><td>zjednodušený zápis předchozího příkladu</td><td><a href="https://github.com/tisnik/presentations/blob/master/shine/18_counter_1.shn">https://github.com/tisnik/presentations/blob/master/shine/18_counter_1.shn</a></td></tr>
<tr><td>25</td><td>19_counter_2.lua</td><td>čítač s&nbsp;konfigurovatelným krokem, varianta pro jazyk Lua</td><td><a href="https://github.com/tisnik/presentations/blob/master/shine/19_counter_2.lua">https://github.com/tisnik/presentations/blob/master/shine/19_counter_2.lua</a></td></tr>
<tr><td>26</td><td>19_counter_2.shn</td><td>čítač s&nbsp;konfigurovatelným krokem, varianta pro jazyk Shine</td><td><a href="https://github.com/tisnik/presentations/blob/master/shine/19_counter_2.shn">https://github.com/tisnik/presentations/blob/master/shine/19_counter_2.shn</a></td></tr>
<tr><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td></tr>
<tr><td>27</td><td>20_varargs.shn</td><td>zpracování funkce s&nbsp;proměnným počtem parametrů</td><td><a href="https://github.com/tisnik/presentations/blob/master/shine/20_varargs.shn">https://github.com/tisnik/presentations/blob/master/shine/20_varargs.shn</a></td></tr>
<tr><td>28</td><td>21_varargs.shn</td><td>zpracování funkce s&nbsp;proměnným počtem parametrů</td><td><a href="https://github.com/tisnik/presentations/blob/master/shine/21_varargs.shn">https://github.com/tisnik/presentations/blob/master/shine/21_varargs.shn</a></td></tr>
<tr><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td></tr>
<tr><td>29</td><td>22_table_type.shn</td><td>parametr funkce typu <strong>table</strong></td><td><a href="https://github.com/tisnik/presentations/blob/master/shine/22_table_type.shn">https://github.com/tisnik/presentations/blob/master/shine/22_table_type.shn</a></td></tr>
<tr><td>30</td><td>23_array_type.shn</td><td>parametr funkce typu <strong>array</strong></td><td><a href="https://github.com/tisnik/presentations/blob/master/shine/23_array_type.shn">https://github.com/tisnik/presentations/blob/master/shine/23_array_type.shn</a></td></tr>
</table>



<p><a name="k19"></a></p>
<h2 id="k19">19. Odkazy na relevantní články a seriály na Rootu</h2>

<p>S&nbsp;technologiemi souvisejícími s&nbsp;programovacím jazykem Lua,
LuaJITem, ale i s&nbsp;jazyky postavenými nad ekosystémem Luy (viz například
výše zmíněný Moonscript) jsme se již na stránkách Roota několikrát setkali.
Následují odkazy na více či méně relevantní články k&nbsp;dnes probíranému
tématu:</p>

<ol>

<li>Seriál Programovací jazyk Lua<br />
<a href="https://www.root.cz/serialy/programovaci-jazyk-lua/">https://www.root.cz/serialy/programovaci-jazyk-lua/</a>
</li>

<li>Seriál Torch: framework pro strojové učení<br />
<a href="https://www.root.cz/serialy/torch-framework-pro-strojove-uceni/">https://www.root.cz/serialy/torch-framework-pro-strojove-uceni/</a>
</li>

<li>Skriptovací jazyk Lua v&nbsp;aplikacích naprogramovaných v&nbsp;Go<br />
<a href="https://www.root.cz/clanky/skriptovaci-jazyk-lua-v-aplikacich-naprogramovanych-v-go/">https://www.root.cz/clanky/skriptovaci-jazyk-lua-v-aplikacich-naprogramovanych-v-go/</a>
</li>

<li>Interpretry, překladače, JIT překladače a transpřekladače programovacího jazyka Lua<br />
<a href="https://www.root.cz/clanky/interpretry-prekladace-jit-prekladace-a-transprekladace-programovaciho-jazyka-lua/">https://www.root.cz/clanky/interpretry-prekladace-jit-prekladace-a-transprekladace-programovaciho-jazyka-lua/</a>
</li>

<li>LuaJIT &ndash; Just in Time překladač pro programovací jazyk Lua<br />
<a href="https://www.root.cz/clanky/luajit-just-in-time-prekladac-pro-programovaci-jazyk-lua/">https://www.root.cz/clanky/luajit-just-in-time-prekladac-pro-programovaci-jazyk-lua/</a>
</li>

<li>LuaJIT &ndash; Just in Time překladač pro programovací jazyk Lua (2)<br />
<a href="http://www.root.cz/clanky/luajit-just-in-time-prekladac-pro-programovaci-jazyk-lua-2/">http://www.root.cz/clanky/luajit-just-in-time-prekladac-pro-programovaci-jazyk-lua-2/</a>
</li>

<li>LuaJIT &ndash; Just in Time překladač pro programovací jazyk Lua (3)<br />
<a href="http://www.root.cz/clanky/luajit-just-in-time-prekladac-pro-programovaci-jazyk-lua-3/">http://www.root.cz/clanky/luajit-just-in-time-prekladac-pro-programovaci-jazyk-lua-3/</a>
</li>

<li>LuaJIT &ndash; Just in Time překladač pro programovací jazyk Lua (4)<br />
<a href="http://www.root.cz/clanky/luajit-just-in-time-prekladac-pro-programovaci-jazyk-lua-4/">http://www.root.cz/clanky/luajit-just-in-time-prekladac-pro-programovaci-jazyk-lua-4/</a>
</li>

<li>LuaJIT &ndash; Just in Time překladač pro programovací jazyk Lua (5 &ndash; tabulky a pole)<br />
<a href="http://www.root.cz/clanky/luajit-just-in-time-prekladac-pro-programovaci-jazyk-lua-5-tabulky-a-pole/">http://www.root.cz/clanky/luajit-just-in-time-prekladac-pro-programovaci-jazyk-lua-5-tabulky-a-pole/</a>
</li>

<li>LuaJIT &ndash; Just in Time překladač pro programovací jazyk Lua (6 &ndash; překlad programových smyček do mezijazyka LuaJITu)<br />
<a href="http://www.root.cz/clanky/luajit-just-in-time-prekladac-pro-programovaci-jazyk-lua-6-preklad-programovych-smycek-do-mezijazyka-luajitu/">http://www.root.cz/clanky/luajit-just-in-time-prekladac-pro-programovaci-jazyk-lua-6-preklad-programovych-smycek-do-mezijazyka-luajitu/</a>
</li>

<li>LuaJIT &ndash; Just in Time překladač pro programovací jazyk Lua (7 &ndash; dokončení popisu mezijazyka LuaJITu)<br />
<a href="http://www.root.cz/clanky/luajit-just-in-time-prekladac-pro-programovaci-jazyk-lua-7-dokonceni-popisu-mezijazyka-luajitu/">http://www.root.cz/clanky/luajit-just-in-time-prekladac-pro-programovaci-jazyk-lua-7-dokonceni-popisu-mezijazyka-luajitu/</a>
</li>

<li>LuaJIT &ndash; Just in Time překladač pro programovací jazyk Lua (8 &ndash; základní vlastnosti trasovacího JITu)<br />
<a href="http://www.root.cz/clanky/luajit-just-in-time-prekladac-pro-programovaci-jazyk-lua-8-zakladni-vlastnosti-trasovaciho-jitu/">http://www.root.cz/clanky/luajit-just-in-time-prekladac-pro-programovaci-jazyk-lua-8-zakladni-vlastnosti-trasovaciho-jitu/</a>
</li>

<li>LuaJIT &ndash; Just in Time překladač pro programovací jazyk Lua (9 &ndash; další vlastnosti trasovacího JITu)<br />
<a href="http://www.root.cz/clanky/luajit-just-in-time-prekladac-pro-programovaci-jazyk-lua-9-dalsi-vlastnosti-trasovaciho-jitu/">http://www.root.cz/clanky/luajit-just-in-time-prekladac-pro-programovaci-jazyk-lua-9-dalsi-vlastnosti-trasovaciho-jitu/</a>
</li>

<li>LuaJIT &ndash; Just in Time překladač pro programovací jazyk Lua (10 &ndash; JIT překlad do nativního kódu)<br />
<a href="http://www.root.cz/clanky/luajit-just-in-time-prekladac-pro-programovaci-jazyk-lua-10-jit-preklad-do-nativniho-kodu/">http://www.root.cz/clanky/luajit-just-in-time-prekladac-pro-programovaci-jazyk-lua-10-jit-preklad-do-nativniho-kodu/</a>
</li>

<li>Moonscript: jazyk inspirovaný CoffeeScriptem určený pro ekosystém jazyka Lua<br />
<a href="https://www.root.cz/clanky/moonscript-jazyk-inspirovany-coffeescriptem-urceny-pro-ekosystem-jazyka-lua/">https://www.root.cz/clanky/moonscript-jazyk-inspirovany-coffeescriptem-urceny-pro-ekosystem-jazyka-lua/</a>
</li>

<li>Moonscript: jazyk inspirovaný CoffeeScriptem určený pro ekosystém jazyka Lua (2)<br />
<a href="https://www.root.cz/clanky/moonscript-jazyk-inspirovany-coffeescriptem-urceny-pro-ekosystem-jazyka-lua-2/">https://www.root.cz/clanky/moonscript-jazyk-inspirovany-coffeescriptem-urceny-pro-ekosystem-jazyka-lua-2/</a>
</li>

<li>Moonscript: jazyk inspirovaný CoffeeScriptem určený pro ekosystém jazyka Lua (dokončení)<br />
<a href="https://www.root.cz/clanky/moonscript-jazyk-inspirovany-coffeescriptem-urceny-pro-ekosystem-jazyka-lua-dokonceni/">https://www.root.cz/clanky/moonscript-jazyk-inspirovany-coffeescriptem-urceny-pro-ekosystem-jazyka-lua-dokonceni/</a>
</li>

<li>Použití nástroje RQ (Redis Queue) pro správu úloh zpracovávaných na pozadí<br />
<a href="https://www.root.cz/clanky/pouziti-nastroje-rq-redis-queue-pro-spravu-uloh-zpracovavanych-na-pozadi/">https://www.root.cz/clanky/pouziti-nastroje-rq-redis-queue-pro-spravu-uloh-zpracovavanych-na-pozadi/</a>
</li>

<li>Proudy (streams) podporované systémem Redis<br />
<a href="https://www.root.cz/clanky/proudy-streams-podporovane-systemem-redis/">https://www.root.cz/clanky/proudy-streams-podporovane-systemem-redis/</a>
</li>

<li>Proudy (streams) podporované systémem Redis (dokončení)<br />
<a href="https://www.root.cz/clanky/proudy-streams-podporovane-systemem-redis-dokonceni/">https://www.root.cz/clanky/proudy-streams-podporovane-systemem-redis-dokonceni/</a>
</li>

</ol>



<p><a name="k20"></a></p>
<h2 id="k20">20. Odkazy na Internetu</h2>

<ol>

<li>Repositář projektu Shine<br />
<a href="https://github.com/richardhundt/shine">https://github.com/richardhundt/shine</a>
</li>

<li>Languages that compile to Lua<br />
<a href="https://github.com/hengestone/lua-languages?tab=readme-ov-file#languages-that-compile-to-lua">https://github.com/hengestone/lua-languages?tab=readme-ov-file#languages-that-compile-to-lua</a>
</li>

<li>Repositář projektu Lua Fun<br />
<a href="https://github.com/luafun/luafun">https://github.com/luafun/luafun</a>
</li>

<li>Lua Functional 0.1.3 documentation<br />
<a href="https://luafun.github.io/reference.html">https://luafun.github.io/reference.html</a>
</li>

<li>Lua Profiler (GitHub)<br />
<a href="https://github.com/luaforge/luaprofiler">https://github.com/luaforge/luaprofiler</a>
</li>

<li>Lua Profiler (LuaForge)<br />
<a href="http://luaforge.net/projects/luaprofiler/">http://luaforge.net/projects/luaprofiler/</a>
</li>

<li>ctrace<br />
<a href="http://webserver2.tecgraf.puc-rio.br/~lhf/ftp/lua/">http://webserver2.tecgraf.puc-rio.br/~lhf/ftp/lua/</a>
</li>

<li>The Lua VM, on the Web<br />
<a href="https://kripken.github.io/lua.vm.js/lua.vm.js.html">https://kripken.github.io/lua.vm.js/lua.vm.js.html</a>
</li>

<li>Lua.vm.js REPL<br />
<a href="https://kripken.github.io/lua.vm.js/repl.html">https://kripken.github.io/lua.vm.js/repl.html</a>
</li>

<li>lua2js<br />
<a href="https://www.npmjs.com/package/lua2js">https://www.npmjs.com/package/lua2js</a>
</li>

<li>lua2js na GitHubu<br />
<a href="https://github.com/basicer/lua2js-dist">https://github.com/basicer/lua2js-dist</a>
</li>

<li>Lua (programming language)<br />
<a href="http://en.wikipedia.org/wiki/Lua_(programming_language)">http://en.wikipedia.org/wiki/Lua_(programming_language)</a>
</li>

<li>LuaJIT 2.0 SSA IR<br />
<a href="http://wiki.luajit.org/SSA-IR-2.0">http://wiki.luajit.org/SSA-IR-2.0</a>
</li>

<li>The LuaJIT Project<br />
<a href="http://luajit.org/index.html">http://luajit.org/index.html</a>
</li>

<li>LuaJIT FAQ<br />
<a href="http://luajit.org/faq.html">http://luajit.org/faq.html</a>
</li>

<li>LuaJIT Performance Comparison<br />
<a href="http://luajit.org/performance.html">http://luajit.org/performance.html</a>
</li>

<li>LuaJIT 2.0 intellectual property disclosure and research opportunities<br />
<a href="http://article.gmane.org/gmane.comp.lang.lua.general/58908">http://article.gmane.org/gmane.comp.lang.lua.general/58908</a>
</li>

<li>LuaJIT Wiki<br />
<a href="http://wiki.luajit.org/Home">http://wiki.luajit.org/Home</a>
</li>

<li>LuaJIT 2.0 Bytecode Instructions<br />
<a href="http://wiki.luajit.org/Bytecode-2.0">http://wiki.luajit.org/Bytecode-2.0</a>
</li>

<li>Programming in Lua (first edition)<br />
<a href="http://www.lua.org/pil/contents.html">http://www.lua.org/pil/contents.html</a>
</li>

<li>Lua 5.2 sources<br />
<a href="http://www.lua.org/source/5.2/">http://www.lua.org/source/5.2/</a>
</li>

<li>REPL<br />
<a href="https://en.wikipedia.org/wiki/Read%E2%80%93eval%E2%80%93print_loop">https://en.wikipedia.org/wiki/Read%E2%80%93eval%E2%80%93print_loop</a>
</li>

<li>The LLVM Compiler Infrastructure<br />
<a href="http://llvm.org/ProjectsWithLLVM/">http://llvm.org/ProjectsWithLLVM/</a>
</li>

<li>clang: a C language family frontend for LLVM<br />
<a href="http://clang.llvm.org/">http://clang.llvm.org/</a>
</li>

<li>LLVM Backend ("Fastcomp")<br />
<a href="http://kripken.github.io/emscripten-site/docs/building_from_source/LLVM-Backend.html#llvm-backend">http://kripken.github.io/emscripten-site/docs/building_from_source/LLVM-Backend.html#llvm-backend</a>
</li>

<li>Lambda the Ultimate: Coroutines in Lua,<br />
<a href="http://lambda-the-ultimate.org/node/438">http://lambda-the-ultimate.org/node/438</a>
</li>

<li>Coroutines Tutorial,<br />
<a href="http://lua-users.org/wiki/CoroutinesTutorial">http://lua-users.org/wiki/CoroutinesTutorial</a>
</li>

<li>Lua Coroutines Versus Python Generators,<br />
<a href="http://lua-users.org/wiki/LuaCoroutinesVersusPythonGenerators">http://lua-users.org/wiki/LuaCoroutinesVersusPythonGenerators</a>
</li>

</ol>



<p></p><p></p>
<p><small>Autor: <a href="http://www.fit.vutbr.cz/~tisnovpa">Pavel Tišnovský</a> &nbsp; 2024</small></p>
</body>
</html>

