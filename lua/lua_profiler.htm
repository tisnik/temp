<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
        "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html>
<head>
<title>Profilery pro programovací jazyk Lua</title>
<meta name="Author" content="Pavel Tisnovsky" />
<meta name="Generator" content="vim" />
<meta http-equiv="content-type" content="text/html; charset=utf-8" />
<style type="text/css">
         body {color:#000000; background:#ffffff;}
         h1  {font-family: arial, helvetica, sans-serif; color:#ffffff; background-color:#c00000; text-align:center; padding-left:1em}
         h2  {font-family: arial, helvetica, sans-serif; color:#ffffff; background-color:#0000c0; padding-left:1em; text-align:left}
         h3  {font-family: arial, helvetica, sans-serif; color:#000000; background-color:#c0c0c0; padding-left:1em; text-align:left}
         h4  {font-family: arial, helvetica, sans-serif; color:#000000; background-color:#e0e0e0; padding-left:1em; text-align:left}
         a   {font-family: arial, helvetica, sans-serif;}
         li  {font-family: arial, helvetica, sans-serif; color:#000000; text-align:justify; width:450px;}
         ol  {font-family: arial, helvetica, sans-serif; color:#000000; text-align:justify; width:450px;}
         ul  {font-family: arial, helvetica, sans-serif; color:#000000; text-align:justify; width:450px;}
         p   {font-family: arial, helvetica, sans-serif; color:#000000; text-align:justify;}
         pre {background:#e0e0e0}
</style>
</head>

<body>

<h1>Profilery pro programovací jazyk Lua</h1>

<h3>Pavel Tišnovský</h3>

<p></p>

<h1>Úvodník</h1>

<p>Někteří vývojáři používající programovací jazyk Lua potřebují kromě samotného interpretru a standardních knihoven využívat i debugger a profiler. V této oblasti sice Lua nenabízí žádné unifikované řešení, ale jak debuggery, tak i profilery pro tento jazyk existují. Dnes si jeden z těchto nástrojů popíšeme.</p>



<h2>Obsah</h2>

<p><a href="#k01">1. Profilery pro programovací jazyk Lua</a></p>
<p><a href="#k02">2. Stažení a překlad projektu LuaProfiler</a></p>
<p><a href="#k03">3. Načtení modulu s&nbsp;profilovacími funkcemi</a></p>
<p><a href="#k04">4. Spuštění profileru</a></p>
<p><a href="#k05">5. Analýza výsledků</a></p>
<p><a href="#k06">6. Praktičtější příklad: výpočet faktoriálu různými způsoby</a></p>
<p><a href="#k07">7. Výsledky měření</a></p>
<p><a href="#k08">8. Příloha: bajtkód funkcí pro výpočet faktoriálu</a></p>
<p><a href="#k09">9. Odkazy na Internetu</a></p>



<p><a name="k01"></a></p>
<h2 id="k01">1. Profilery pro programovací jazyk Lua</h2>

<p>Mezi užitečné programátorské nástroje, které se při vývoji a laděni aplikací
velmi často používají, patří mj.&nbsp;i různé debuggery a profilery.
V&nbsp;základní instalaci balíčku s&nbsp;programovacím jazykem Lua se sice tyto
nástroje nenachází (nalezneme zde totiž pouze interpret představovaný
spustitelným souborem <strong>lua</strong> a překladač zdrojového kódu do
bajtkódu reprezentovaný souborem <strong>luac</strong>), nicméně existuje hned
několik podpůrných nástrojů, které je možné relativně snadno nainstalovat a
následně používat. Jedním z&nbsp;těchto nástrojů je i profiler nazvaný
jednoduše <strong>LuaProfiler</strong>. Tento nástroj si dnes stručně popíšeme
a ukážeme si jeho základní použití při analýze několika variant <a
href="http://rosettacode.org/wiki/Factorial">algoritmu pro výpočet
faktoriálu</a>. Tento výpočet byl zvolen zejména z&nbsp;toho důvodu, že se
jedná o známou (typicky školní :-) úlohu, kterou navíc lze v&nbsp;programovacím
jazyce Lua realizovat hned několika možnými způsoby.</p>



<p><a name="k02"></a></p>
<h2 id="k02">2. Stažení a překlad projektu LuaProfiler</h2>

<p>Zdrojové kódy profileru <strong>LuaProfiler</strong> jsou dostupné na
GitHubu na adrese <a
href="https://github.com/luaforge/luaprofiler">https://github.com/luaforge/luaprofiler</a>.
Jedná se o běžný GIT repositář, takže je možné si ho naklonovat příkazem:</p>

<pre>
<strong>git clone https://github.com/luaforge/luaprofiler</strong>
&nbsp;
Cloning into 'luaprofiler'...
remote: Counting objects: 388, done.
remote: Total 388 (delta 0), reused 0 (delta 0), pack-reused 388
Receiving objects: 100% (388/388), 106.90 KiB | 73.00 KiB/s, done.
Resolving deltas: 100% (255/255), done.
Checking connectivity... done.
</pre>

<p>Profiler je implementován v&nbsp;programovacím jazyku C a nevyužívají se
v&nbsp;něm žádné další knihovny kromě standardních knihoven céčka a knihovny
jazyka Lua ve verzi 5.1 (překlad oproti verzi 5.2 je problematičtější). Pro
úspěšný překlad je tedy nutné mít k&nbsp;dispozici překladač ANSI C (gcc,
Clang, ...) a balíček pojmenovaný většinou <i>liblua5.1.0-dev</i> či podobným
způsobem. Ještě před překladem je nutné upravit soubor nazvaný
<strong>config.linux</strong> takovým způsobem, aby proměnná
<strong>LUA_INCLUDE</strong> ukazovala do správného adresáře
s&nbsp;hlavičkovými soubory interptretru jazyka Lua. Na 64bitové platformě je
navíc nutné upravit proměnnou <strong>CFLAGS</strong>, konkrétně do ní přidat
volbu <strong>-fPIC</strong> (nic by se však nemělo stát ani při přidání tohoto
přepínače na 32bitovém systému). Podívejme se na ukázku, jak soubor
<strong>config.linux</strong> vypadá na mém systému. Změněný text je
zvýrazněn:</p>

<pre>
LUA_INCLUDE= <strong>/usr/include/lua5.1</strong>
&nbsp;
PROFILER_OUTPUT= bin/profiler.so
&nbsp;
INCS= -I$(LUA_INCLUDE)
CC= gcc
WARN= -ansi -W -Wall
EXTRA_LIBS=
CFLAGS= -O2 -DTESTS $(WARN) $(INCS) -I./src <strong>-fPIC</strong>
</pre>

<p>Samotný překlad je otázkou jediného příkazu:</p>

<pre>
make -f Makefile.linux
</pre>

<p>Výsledkem překladu je buď zpráva o chybě :-) nebo méně častěji nativní
knihovna nazvaná <strong>profiler.so</strong>, která je umístěna
v&nbsp;podadresáři <strong>bin</strong>.</p>



<p><a name="k03"></a></p>
<h2 id="k03">3. Načtení modulu s&nbsp;profilovacími funkcemi</h2>

<p>Použití profileru je poměrně snadné. Jediné, co musíme zajistit, je umístění
knihovny <strong>profiler.so</strong> tak, aby ji měřený skript našel, takže
v&nbsp;nejjednodušším případě stačí vytvořit symlink do pracovního adresáře.
Nejprve je nutné profiler načíst příkazem <strong>require("profiler")</strong>,
čímž dojde k&nbsp;vytvoření globální tabulky nazvané &bdquo;profiler&ldquo;.
Následně se (prakticky kdykoli) spustí profiling voláním
<strong>profiler.start(jméno_souboru)</strong>, kde do souboru se jménem
<strong>jméno_souboru</strong> budou zapisovány informace o volaných funkcích
atd. Profiling se vypíná voláním <strong>profiler.stop()</strong>. To je
vlastně vše, takže se pojďme podívat na jednoduchý příklad, v&nbsp;němž je
profiler načten, spuštěn a na konci příkladu i řádně vypnut:</p>

<pre>
require("profiler")
&nbsp;
profiler.start("test.prof")
&nbsp;
<strong>function</strong> first()
    <strong>local</strong> x = ""
&nbsp;
    <strong>for</strong> i = 0, 1000 <strong>do</strong>
        x = x .. tostring(i) .. ","
        print(i)
    <strong>end</strong>
<strong>end</strong>
&nbsp;
<strong>function</strong> second()
    <strong>local</strong> tbl = {}
&nbsp;
    <strong>for</strong> i = 1, 1000 <strong>do</strong>
        tbl[i] = i
    <strong>end</strong>
&nbsp;
    print(#tbl)
<strong>end</strong>
&nbsp;
first()
second()
&nbsp;
profiler.stop()
&nbsp;
</pre>



<p><a name="k04"></a></p>
<h2 id="k04">4. Spuštění profileru</h2>

<p>Samotné spuštění programu je jednoduché (připomeňme však ještě jednou
nutnost vytvoření symlinku na nativní knihovnu <strong>profiler.so</strong>).
Nejdříve pro jistotu vymažeme soubor s&nbsp;profilovacími informacemi, jinak by
došlo k&nbsp;pouhému připojení dalších dat (což nechceme) a následně se spustí
interpret s&nbsp;naším skriptem. Vzhledem k&nbsp;tomu, že na systému mám
nainstalovánu Luu 5.1 i Luu 5.2, musel jsem zvolit správnou verzi
interpretru:</p>

<pre>
rm -f test.prof
lua5.1 test.lua
</pre>

<p>Po doběhnutí skriptu by se v&nbsp;aktuálním adresáři měl nacházet i soubor
nazvaný <strong>test.prof</strong>, jehož obsah bude vypadat přibližně takto
(jednotlivé časy se samozřejmě budou lišit):</p>

<pre>
stack_level     file_defined    function_name   line_defined    current_line    local_time      total_time
0               (string)        profiler_init   -1              -1              0.000014        0.000013
1               (string)        tostring        -1              9               0.000012        0.000011
2               (string)        called from print               -1              -1              0.000006        0.000006
1               (string)        print           -1              10              0.000037        0.000046
1               (string)        tostring        -1              9               0.000010        0.000010
2               (string)        called from print               -1              -1              0.000007        0.000007
1               (string)        print           -1              10              0.000022        0.000031
1               (string)        tostring        -1              9               0.000009        0.000009
2               (string)        called from print               -1              -1              0.000005        0.000006
1               (string)        print           -1              10              0.000021        0.000030
1               (string)        tostring        -1              9               0.000007        0.000008
2               (string)        called from print               -1              -1              0.000005        0.000005
</pre>



<p><a name="k05"></a></p>
<h2 id="k05">5. Analýza výsledků</h2>

<p>Datový soubor zmíněný <a href="#k04">v&nbsp;předchozí kapitole</a> obsahuje
pouze surová data, pro jejichž další zpracování a vygenerování výsledků je
zapotřebí použít ještě jeden nástroj. Tento nástroj je reprezentován skriptem
nazvaným <strong>summary.lua</strong>, který naleznete v&nbsp;podadresáři
<strong>src/analyzer</strong> projektu <strong>LuaProfiler</strong>. Skript
načte výsledek běhu profileru a vytvoří čitelnou tabulku s&nbsp;kumulativními
časy trvání jednotlivých funkcí, průměrným časem běhu každé funkce atd.
Důležité je, aby profiler nezapsal do jednoho souboru profilovací informace
vícekrát za sebou, jinak dojde k&nbsp;běhové chybě, protože
<strong>summary.lua</strong> není příliš robustní. Podívejme se na výsledek
jeho práce. Skript spustíme s&nbsp;volbou -v, abychom dostali více
informací:</p>

<pre>
lua5.1 summary.lua -v test.prof &gt; test.out
</pre>

<p>Výsledkem bude tato tabulka:</p>

<pre>
Node name            Calls       Average per call     Total time    %Time
print                1002        1.1568862275449e-05  0.011592      43.541298876911
first                1           0.006767             0.006767      25.417871765015
tostring             1001        4.3506493506494e-06  0.004355      16.358036284416
called from print    1002        3.8413173652694e-06  0.003849      14.457424031852
second               1           4.4e-05              0.000044      0.1652706306577
profiler_init        1           1.4e-05              0.000014      0.0525861097547
stop                 1           2e-06                0.000002      0.0075123013935
</pre>

<p>Výsledky jsou částečně předvídatelné &ndash; funkce <strong>print()</strong>
byla volána 1002&times; (1001&times; ve smyčce + jedenkrát v&nbsp;další funkci)
a skript v&nbsp;ní strávil nejvíce času. I funkce <strong>first()</strong> byla
časově náročná, což je dáno jejím tělem s&nbsp;programovou smyčkou (volána byla
pouze jedenkrát). Celých 16% času skript strávil i ve funkci
<strong>tostring</strong> atd. atd.</p>



<p><a name="k06"></a></p>
<h2 id="k06">6. Praktičtější příklad: výpočet faktoriálu různými způsoby</h2>

<p>Podívejme se nyní na poněkud praktičtější příklad. Mějme čtyři různé
implementace výpočtu faktoriálu:</p>

<ol>
<li>Klasický &bdquo;školní&ldquo; rekurzivní výpočet</li>
<li>Rekurzivní výpočet používající <a
href="https://en.wikipedia.org/wiki/Tail_call_optimization">tail call
optimization (TCO)</a>, tj.&nbsp;optimalizaci prováděnou interpretrem</li>
<li>Nerekurzivní výpočet realizovaný počítanou smyčkou typu <strong>for</strong></li>
<li>Nerekurzivní výpočet realizovaný smyčkou typu <strong>while</strong></li>
</ol>

<p>Celý skript se zmíněnými čtyřmi implementacemi výpočtu (který volá i
profiler) vypadá následovně:</p>

<pre>
require("profiler")
&nbsp;
profiler.start("factorials.prof")
&nbsp;
&nbsp;
&nbsp;
<i>--</i>
<i>-- Rekurzivni vypocet faktorialu</i>
<i>--</i>
<strong>function</strong> fact_recursive(n)
    <strong>if</strong> n==0 <strong>then</strong>
        <strong>return</strong> 1
    <strong>else</strong>
        <strong>return</strong> n*fact_recursive(n-1)
    <strong>end</strong>
<strong>end</strong>
&nbsp;
&nbsp;
&nbsp;
<i>--</i>
<i>-- Rekurzivni vypocet faktorialu vyuzivajici tail call optimization</i>
<i>--</i>
<strong>function</strong> fact_tail_call(n, accum)
    accum = accum or 1
    <strong>if</strong> n == 0 <strong>then</strong>
        <strong>return</strong> accum
    <strong>else</strong>
        <strong>return</strong> fact_tail_call(n-1, n*accum)
    <strong>end</strong>
<strong>end</strong>
&nbsp;
&nbsp;
&nbsp;
<i>--</i>
<i>-- Nerekurzivni vypocet faktorialu vyuzivajici programovou smycku typu for</i>
<i>--</i>
<strong>function</strong> fact_loop(n)
    <strong>if</strong> n==0 <strong>then</strong>
        <strong>return</strong> 1
    <strong>else</strong>
        <strong>local</strong> x = 1
        <strong>for</strong> i = 1,n <strong>do</strong>
            x = x * i
        <strong>end</strong>
        <strong>return</strong> x
    <strong>end</strong>
<strong>end</strong>
&nbsp;
&nbsp;
&nbsp;
<i>--</i>
<i>-- Nerekurzivni vypocet faktorialu vyuzivajici programovou smycku typu while</i>
<i>--</i>
<strong>function</strong> fact_loop_2(n)
    <strong>local</strong> x = 1
    <strong>while</strong> n &gt; 0 <strong>do</strong>
        x = x * n
        n = n - 1
    <strong>end</strong>
    <strong>return</strong> x
<strong>end</strong>
&nbsp;
&nbsp;
&nbsp;
<strong>for</strong> i = 0, 149 <strong>do</strong>
    print(i, fact_recursive(i), fact_tail_call(i), fact_loop(i), fact_loop_2(i))
<strong>end</strong>
&nbsp;
profiler.stop()
&nbsp;
</pre>



<p><a name="k07"></a></p>
<h2 id="k07">7. Výsledky měření</h2>

<p>Skript spustíme a následně analyzujeme výsledky běhu profileru:</p>

<pre>
rm factorials.prof
lua5.1 factorials.lua
echo "--------------------------------------"
lua5.1 summary.lua -v factorials.prof &gt; factorials.out
</pre>

<p>Nejprve malá kontrola správnosti výpočtu:</p>

<pre>
0                         1                       1                       1                       1
1                         1                       1                       1                       1
2                         2                       2                       2                       2
3                         6                       6                       6                       6
4                        24                      24                      24                      24
5                       120                     120                     120                     120
6                       720                     720                     720                     720
7                      5040                    5040                    5040                    5040
8                     40320                   40320                   40320                   40320
9                    362880                  362880                  362880                  362880
10                  3628800                 3628800                 3628800                 3628800
11                 39916800                39916800                39916800                39916800
12                479001600               479001600               479001600               479001600
13               6227020800              6227020800              6227020800              6227020800
14              87178291200             87178291200             87178291200             87178291200
15            1307674368000           1307674368000           1307674368000           1307674368000
16           20922789888000          20922789888000          20922789888000          20922789888000
17      3.5568742809600e+14     3.5568742809600e+14     3.5568742809600e+14     3.5568742809600e+14
18      6.4023737057280e+15     6.4023737057280e+15     6.4023737057280e+15     6.4023737057280e+15
19      1.2164510040883e+17     1.2164510040883e+17     1.2164510040883e+17     1.2164510040883e+17
...
...
...
146     1.1749972043909e+254    1.1749972043909e+254    1.1749972043909e+254    1.1749972043909e+254
147     1.7272458904546e+256    1.7272458904546e+256    1.7272458904546e+256    1.7272458904546e+256
148     2.5563239178729e+258    2.5563239178729e+258    2.5563239178729e+258    2.5563239178729e+258
149     3.8089226376306e+260    3.8089226376306e+260    3.8089226376306e+260    3.8089226376306e+260
</pre>

<p>Podle očekávání je klasický rekurzivní výpočet nejpomalejší (navíc i
paměťově nejnáročnější), ovšem těsně za ním je výpočet s&nbsp;TCO (což mě
osobně překvapilo, čekal jsem lepší výsledky tohoto výpočtu). Naproti tomu jsou
výpočty využívající programovou smyčku <strong>for</strong> či
<strong>while</strong> mnohem rychlejší, což ukazuje na fakt, že samotný
výpočet (násobení, odečtení jedničky, skok...) je v&nbsp;porovnání
s&nbsp;voláním funkce v&nbsp;tomto případě neporovnatelně rychlejší.</p>

<pre>
Node name           Calls       Average per call      Total time   %Time
fact_recursive      11325       3.2175805739514e-05   0.364391     49.717297517076
fact_tail_call      11325       3.1855894039735e-05   0.360768     49.222977490225
print               150         2.4233333333333e-05   0.003635     0.49595729991841
called from print   750         4.1626666666667e-06   0.003122     0.42596387629857
fact_loop_2         150         3.6e-06               0.00054      0.073677288020892
fact_loop           150         3.06e-06              0.000459     0.062625694817758
profiler_init       1           9e-06                 0.000009     0.0012279548003482
stop                1           2e-06                 0.000002     0.00027287884452182
</pre>



<p><a name="k08"></a></p>
<h2 id="k08">8. Příloha: bajtkód funkcí pro výpočet faktoriálu</h2>

<p>Pro zajímavost se podívejme na bajtkód všech čtyř funkcí pro výpočet
faktoriálu. Asi nejzajímavější je způsob realizace TCO (zvýrazněné instrukce se
starají o provedení další iterace):</p>

<pre>
<i>--</i>
<i>-- Rekurzivni vypocet faktorialu</i>
<i>--</i>
function &lt;factorials.lua:5,11&gt; (11 instructions, 44 bytes at 0x246d790)
1 param, 3 slots, 0 upvalues, 1 local, 3 constants, 0 functions
        1       [6]     EQ              0 0 -1  ; - 0
        2       [6]     JMP             3       ; to 6
        3       [7]     LOADK           1 -2    ; 1
        4       [7]     RETURN          1 2
        5       [7]     JMP             5       ; to 11
        6       [9]     GETGLOBAL       1 -3    ; fact_recursive
        7       [9]     SUB             2 0 -2  ; - 1
        8       [9]     <strong>CALL</strong>            1 2 2
        9       [9]     MUL             1 0 1
        10      [9]     RETURN          1 2
        11      [11]    RETURN          0 1
</pre>

<pre>
<i>--</i>
<i>-- Rekurzivni vypocet faktorialu vyuzivajici tail call optimization</i>
<i>--</i>
function &lt;factorials.lua:13,20&gt; (13 instructions, 52 bytes at 0x246dd20)
2 params, 5 slots, 0 upvalues, 2 locals, 3 constants, 0 functions
        1       [14]    TEST            1 0 1
        2       [14]    JMP             1       ; to 4
        3       [14]    LOADK           1 -1    ; 1
        4       [15]    EQ              0 0 -2  ; - 0
        5       [15]    JMP             2       ; to 8
        6       [16]    RETURN          1 2
        7       [16]    JMP             5       ; to 13
        8       [18]    GETGLOBAL       2 -3    ; fact_tail_call
        9       [18]    SUB             3 0 -1  ; - 1
        10      [18]    MUL             4 0 1
        11      [18]    <strong>TAILCALL</strong>        2 3 0
        12      [18]    RETURN          2 0
        13      [20]    RETURN          0 1
</pre>

<pre>
<i>--</i>
<i>-- Nerekurzivni vypocet faktorialu vyuzivajici programovou smycku typu for</i>
<i>--</i>
function &lt;factorials.lua:22,32&gt; (14 instructions, 56 bytes at 0x246e200)
1 param, 6 slots, 0 upvalues, 6 locals, 2 constants, 0 functions
        1       [23]    EQ              0 0 -1  ; - 0
        2       [23]    JMP             3       ; to 6
        3       [24]    LOADK           1 -2    ; 1
        4       [24]    RETURN          1 2
        5       [24]    JMP             8       ; to 14
        6       [26]    LOADK           1 -2    ; 1
        7       [27]    LOADK           2 -2    ; 1
        8       [27]    MOVE            3 0
        9       [27]    LOADK           4 -2    ; 1
        10      [27]    <strong>FORPREP</strong>         2 1     ; to 12
        11      [28]    MUL             1 1 5
        12      [27]    <strong>FORLOOP</strong>         2 -2    ; to 11
        13      [30]    RETURN          1 2
        14      [32]    RETURN          0 1
</pre>

<pre>
<i>--</i>
<i>-- Nerekurzivni vypocet faktorialu vyuzivajici programovou smycku typu while</i>
<i>--</i>
function &lt;factorials.lua:34,41&gt; (8 instructions, 32 bytes at 0x246d8a0)
1 param, 2 slots, 0 upvalues, 2 locals, 2 constants, 0 functions
        1       [35]    LOADK           1 -1    ; 1
        2       [36]    LT              0 -2 0  ; 0 -
        3       [36]    JMP             3       ; to 7
        4       [37]    MUL             1 1 0
        5       [38]    SUB             0 0 -1  ; - 1
        6       [38]    <strong>JMP</strong>             -5      ; to 2
        7       [40]    RETURN          1 2
        8       [41]    RETURN          0 1
</pre>



<p><a name="k09"></a></p>
<h2 id="k09">9. Odkazy na Internetu</h2>

<ol>

<li>Factorial (Rosetta Code)<br />
<a href="http://rosettacode.org/wiki/Factorial#Lua">http://rosettacode.org/wiki/Factorial#Lua</a>
</li>

<li>Lua Profiler (GitHub)<br />
<a href="https://github.com/luaforge/luaprofiler">https://github.com/luaforge/luaprofiler</a>
</li>

<li>Lua Profiler (LuaForge)<br />
<a href="http://luaforge.net/projects/luaprofiler/">http://luaforge.net/projects/luaprofiler/</a>
</li>

<li>ctrace<br />
<a href="http://webserver2.tecgraf.puc-rio.br/~lhf/ftp/lua/">http://webserver2.tecgraf.puc-rio.br/~lhf/ftp/lua/</a>
</li>

<li>LuaJIT - Just in Time překladač pro programovací jazyk Lua<br />
<a href="http://www.root.cz/clanky/luajit-just-in-time-prekladac-pro-programovaci-jazyk-lua/">http://www.root.cz/clanky/luajit-just-in-time-prekladac-pro-programovaci-jazyk-lua/</a>
</li>

<li>LuaJIT - Just in Time překladač pro programovací jazyk Lua (2)<br />
<a href="http://www.root.cz/clanky/luajit-just-in-time-prekladac-pro-programovaci-jazyk-lua-2/">http://www.root.cz/clanky/luajit-just-in-time-prekladac-pro-programovaci-jazyk-lua-2/</a>
</li>

<li>LuaJIT - Just in Time překladač pro programovací jazyk Lua (3)<br />
<a href="http://www.root.cz/clanky/luajit-just-in-time-prekladac-pro-programovaci-jazyk-lua-3/">http://www.root.cz/clanky/luajit-just-in-time-prekladac-pro-programovaci-jazyk-lua-3/</a>
</li>

<li>LuaJIT - Just in Time překladač pro programovací jazyk Lua (4)<br />
<a href="http://www.root.cz/clanky/luajit-just-in-time-prekladac-pro-programovaci-jazyk-lua-4/">http://www.root.cz/clanky/luajit-just-in-time-prekladac-pro-programovaci-jazyk-lua-4/</a>
</li>

<li>LuaJIT - Just in Time překladač pro programovací jazyk Lua (5 - tabulky a pole)<br />
<a href="http://www.root.cz/clanky/luajit-just-in-time-prekladac-pro-programovaci-jazyk-lua-5-tabulky-a-pole/">http://www.root.cz/clanky/luajit-just-in-time-prekladac-pro-programovaci-jazyk-lua-5-tabulky-a-pole/</a>
</li>

<li>LuaJIT - Just in Time překladač pro programovací jazyk Lua (6 - překlad programových smyček do mezijazyka LuaJITu)<br />
<a href="http://www.root.cz/clanky/luajit-just-in-time-prekladac-pro-programovaci-jazyk-lua-6-preklad-programovych-smycek-do-mezijazyka-luajitu/">http://www.root.cz/clanky/luajit-just-in-time-prekladac-pro-programovaci-jazyk-lua-6-preklad-programovych-smycek-do-mezijazyka-luajitu/</a>
</li>

<li>LuaJIT - Just in Time překladač pro programovací jazyk Lua (7 - dokončení popisu mezijazyka LuaJITu)<br />
<a href="http://www.root.cz/clanky/luajit-just-in-time-prekladac-pro-programovaci-jazyk-lua-7-dokonceni-popisu-mezijazyka-luajitu/">http://www.root.cz/clanky/luajit-just-in-time-prekladac-pro-programovaci-jazyk-lua-7-dokonceni-popisu-mezijazyka-luajitu/</a>
</li>

<li>LuaJIT - Just in Time překladač pro programovací jazyk Lua (8 - základní vlastnosti trasovacího JITu)<br />
<a href="http://www.root.cz/clanky/luajit-just-in-time-prekladac-pro-programovaci-jazyk-lua-8-zakladni-vlastnosti-trasovaciho-jitu/">http://www.root.cz/clanky/luajit-just-in-time-prekladac-pro-programovaci-jazyk-lua-8-zakladni-vlastnosti-trasovaciho-jitu/</a>
</li>

<li>LuaJIT - Just in Time překladač pro programovací jazyk Lua (9 - další vlastnosti trasovacího JITu)<br />
<a href="http://www.root.cz/clanky/luajit-just-in-time-prekladac-pro-programovaci-jazyk-lua-9-dalsi-vlastnosti-trasovaciho-jitu/">http://www.root.cz/clanky/luajit-just-in-time-prekladac-pro-programovaci-jazyk-lua-9-dalsi-vlastnosti-trasovaciho-jitu/</a>
</li>

<li>LuaJIT - Just in Time překladač pro programovací jazyk Lua (10 - JIT překlad do nativního kódu)<br />
<a href="http://www.root.cz/clanky/luajit-just-in-time-prekladac-pro-programovaci-jazyk-lua-10-jit-preklad-do-nativniho-kodu/">http://www.root.cz/clanky/luajit-just-in-time-prekladac-pro-programovaci-jazyk-lua-10-jit-preklad-do-nativniho-kodu/</a>
</li>

<li>LuaJIT - Just in Time překladač pro programovací jazyk Lua (11 - JIT překlad do nativního kódu procesorů s architekturami x86 a ARM)<br />
<a href="http://www.root.cz/clanky/luajit-just-in-time-prekladac-pro-programovaci-jazyk-lua-11-jit-preklad-do-nativniho-kodu-procesoru-s-architekturami-x86-a-arm/">http://www.root.cz/clanky/luajit-just-in-time-prekladac-pro-programovaci-jazyk-lua-11-jit-preklad-do-nativniho-kodu-procesoru-s-architekturami-x86-a-arm/</a>
</li>

<li>LuaJIT - Just in Time překladač pro programovací jazyk Lua (12 - překlad operací s reálnými čísly)<br />
<a href="http://www.root.cz/clanky/luajit-just-in-time-prekladac-pro-programovaci-jazyk-lua-12-preklad-operaci-s-realnymi-cisly/">http://www.root.cz/clanky/luajit-just-in-time-prekladac-pro-programovaci-jazyk-lua-12-preklad-operaci-s-realnymi-cisly/</a>
</li>

<li>The Lua VM, on the Web<br />
<a href="https://kripken.github.io/lua.vm.js/lua.vm.js.html">https://kripken.github.io/lua.vm.js/lua.vm.js.html</a>
</li>

<li>Lua.vm.js REPL<br />
<a href="https://kripken.github.io/lua.vm.js/repl.html">https://kripken.github.io/lua.vm.js/repl.html</a>
</li>

<li>lua2js<br />
<a href="https://www.npmjs.com/package/lua2js">https://www.npmjs.com/package/lua2js</a>
</li>

<li>lua2js na GitHubu<br />
<a href="https://github.com/basicer/lua2js-dist">https://github.com/basicer/lua2js-dist</a>
</li>

<li>Seriál o programovacím jazyku Lua<br />
<a href="http://www.root.cz/serialy/programovaci-jazyk-lua/">http://www.root.cz/serialy/programovaci-jazyk-lua/</a>
</li>

<li>Source-to-source compiler<br />
<a href="https://en.wikipedia.org/wiki/Source-to-source_compiler">https://en.wikipedia.org/wiki/Source-to-source_compiler</a>
</li>

<li>JavaScript is Assembly Language for the Web: Sematic Markup is Dead! Clean vs. Machine-coded HTML<br />
<a href="http://www.hanselman.com/blog/JavaScriptIsAssemblyLanguageForTheWebSematicMarkupIsDeadCleanVsMachinecodedHTML.aspx">http://www.hanselman.com/blog/JavaScriptIsAssemblyLanguageForTheWebSematicMarkupIsDeadCleanVsMachinecodedHTML.aspx</a>
</li>

<li>JavaScript is Web Assembly Language and that's OK.<br />
<a href="http://www.hanselman.com/blog/JavaScriptIsWebAssemblyLanguageAndThatsOK.aspx">http://www.hanselman.com/blog/JavaScriptIsWebAssemblyLanguageAndThatsOK.aspx</a>
</li>

<li>Dart<br />
<a href="https://www.dartlang.org/">https://www.dartlang.org/</a>
</li>

<li>CoffeeScript<br />
<a href="http://coffeescript.org/">http://coffeescript.org/</a>
</li>

<li>TypeScript<br />
<a href="http://www.typescriptlang.org/">http://www.typescriptlang.org/</a>
</li>

<li>Lua (programming language)<br />
<a href="http://en.wikipedia.org/wiki/Lua_(programming_language)">http://en.wikipedia.org/wiki/Lua_(programming_language)</a>
</li>

<li>Static single assignment form (SSA)<br />
<a href="http://en.wikipedia.org/wiki/Static_single_assignment_form">http://en.wikipedia.org/wiki/Static_single_assignment_form</a>
</li>

<li>Wikipedia: Mezijazyk<br />
<a href="http://cs.wikipedia.org/wiki/Mezijazyk">http://cs.wikipedia.org/wiki/Mezijazyk</a>
</li>

<li>LuaJIT 2.0 SSA IR
<a href="http://wiki.luajit.org/SSA-IR-2.0">http://wiki.luajit.org/SSA-IR-2.0</a>
</li>

<li>The LuaJIT Project<br />
<a href="http://luajit.org/index.html">http://luajit.org/index.html</a>
</li>

<li>LuaJIT FAQ<br />
<a href="http://luajit.org/faq.html">http://luajit.org/faq.html</a>
</li>

<li>LuaJIT Performance Comparison<br />
<a href="http://luajit.org/performance.html">http://luajit.org/performance.html</a>
</li>

<li>LuaJIT 2.0 intellectual property disclosure and research opportunities<br />
<a href="http://article.gmane.org/gmane.comp.lang.lua.general/58908">http://article.gmane.org/gmane.comp.lang.lua.general/58908</a>
</li>

<li>LuaJIT Wiki<br />
<a href="http://wiki.luajit.org/Home">http://wiki.luajit.org/Home</a>
</li>

<li>LuaJIT 2.0 Bytecode Instructions<br />
<a href="http://wiki.luajit.org/Bytecode-2.0">http://wiki.luajit.org/Bytecode-2.0</a>
</li>

<li>Programming in Lua (first edition)<br />
<a href="http://www.lua.org/pil/contents.html">http://www.lua.org/pil/contents.html</a>
</li>

<li>Lua 5.2 sources<br />
<a href="http://www.lua.org/source/5.2/">http://www.lua.org/source/5.2/</a>
</li>

<li>Tcl Plugin Version 3<br />
<a href="http://www.tcl.tk/software/plugin/">http://www.tcl.tk/software/plugin/</a>
</li>

<li>JavaScript: The Web Assembly Language?<br />
<a href="http://www.informit.com/articles/article.aspx?p=1856657">http://www.informit.com/articles/article.aspx?p=1856657</a>
</li>

<li>asm.js<br />
<a href="http://asmjs.org/">http://asmjs.org/</a>
</li>

<li>List of languages that compile to JS<br />
<a href="https://github.com/jashkenas/coffeescript/wiki/List-of-languages-that-compile-to-JS">https://github.com/jashkenas/coffeescript/wiki/List-of-languages-that-compile-to-JS</a>
</li>

<li>REPL<br />
<a href="https://en.wikipedia.org/wiki/Read%E2%80%93eval%E2%80%93print_loop">https://en.wikipedia.org/wiki/Read%E2%80%93eval%E2%80%93print_loop</a>
</li>

<li>The LLVM Compiler Infrastructure<br />
<a href="http://llvm.org/ProjectsWithLLVM/">http://llvm.org/ProjectsWithLLVM/</a>
</li>

<li>clang: a C language family frontend for LLVM<br />
<a href="http://clang.llvm.org/">http://clang.llvm.org/</a>
</li>

<li>emscripten<br />
<a href="http://kripken.github.io/emscripten-site/">http://kripken.github.io/emscripten-site/</a>
</li>

<li>LLVM Backend ("Fastcomp")<br />
<a href="http://kripken.github.io/emscripten-site/docs/building_from_source/LLVM-Backend.html#llvm-backend">http://kripken.github.io/emscripten-site/docs/building_from_source/LLVM-Backend.html#llvm-backend</a>
</li>

<li>Emscripten - Fastcomp na GitHubu<br />
<a href="https://github.com/kripken/emscripten-fastcomp">https://github.com/kripken/emscripten-fastcomp</a>
</li>

<li>Clang (pro Emscripten) na GitHubu<br />
<a href="https://github.com/kripken/emscripten-fastcomp-clang">https://github.com/kripken/emscripten-fastcomp-clang</a>
</li>

<li>Why not use JavaScript?<br />
<a href="https://ckknight.github.io/gorillascript/">https://ckknight.github.io/gorillascript/</a>
</li>

<li>Lambda the Ultimate: Coroutines in Lua,<br />
<a href="http://lambda-the-ultimate.org/node/438">http://lambda-the-ultimate.org/node/438</a>
</li>

<li>Coroutines Tutorial,<br />
<a href="http://lua-users.org/wiki/CoroutinesTutorial">http://lua-users.org/wiki/CoroutinesTutorial</a>
</li>

<li>Lua Coroutines Versus Python Generators,<br />
<a href="http://lua-users.org/wiki/LuaCoroutinesVersusPythonGenerators">http://lua-users.org/wiki/LuaCoroutinesVersusPythonGenerators</a>
</li>

</ol>



<p></p><p></p>
<p><small>Autor: <a href="http://www.fit.vutbr.cz/~tisnovpa">Pavel Tišnovský</a> &nbsp; 2015</small></p>
</body>
</html>

