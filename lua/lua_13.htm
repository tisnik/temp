<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
        "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html>
<head>
<title>Hrátky se systémem LÖVE</title>
<meta name="Author" content="Pavel Tisnovsky" />
<meta name="Generator" content="vim" />
<meta http-equiv="content-type" content="text/html; charset=utf-8" />
<style type="text/css">
         body {color:#000000; background:#ffffff;}
         h1  {font-family: arial, helvetica, sans-serif; color:#ffffff; background-color:#c00000; text-align:center; padding-left:1em}
         h2  {font-family: arial, helvetica, sans-serif; color:#ffffff; background-color:#0000c0; padding-left:1em; text-align:left}
         h3  {font-family: arial, helvetica, sans-serif; color:#000000; background-color:#c0c0c0; padding-left:1em; text-align:left}
         h4  {font-family: arial, helvetica, sans-serif; color:#000000; background-color:#e0e0e0; padding-left:1em; text-align:left}
         a   {font-family: arial, helvetica, sans-serif;}
         li  {font-family: arial, helvetica, sans-serif; color:#000000; text-align:justify; width:450px;}
         ol  {font-family: arial, helvetica, sans-serif; color:#000000; text-align:justify; width:450px;}
         ul  {font-family: arial, helvetica, sans-serif; color:#000000; text-align:justify; width:450px;}
         p   {font-family: arial, helvetica, sans-serif; color:#000000; text-align:justify;}
         pre {background:#e0e0e0}
</style>
</head>

<body>

<h1>Hrátky se systémem LÖVE</h1>

<h3>Pavel Tišnovský</h3>

<p></p>

<h1>Úvodník</h1>

<p>V dnešní části seriálu o programovacím jazyce Lua si na sedmi jednoduchých příkladech ukážeme, jakým způsobem je možné s využitím systému LÖVE vytvořit okno, vykreslit do tohoto okna geometrické obrazce, vytvářet animace a taktéž pracovat s fonty i rastrovými obrázky, které lze mj. použít jako sprity.</p>



<h1>Obsah</h1>
<p>
<a href="#k01">1. Seznam demonstračních příkladů a způsob jejich spuštění</a><br />
<a href="#k02">2. Zjištění všech dostupných celoobrazovkových režimů</a><br />
<a href="#k03">3. Načtení externího fontu a vykreslení všech jeho znaků</a><br />
<a href="#k04">4. Natočení textu při jeho vykreslování</a><br />
<a href="#k05">5. Funkce určené pro změnu stylu vykreslování</a><br />
<a href="#k06">6. Vykreslení jednoduchého obrazce pomocí funkcí z&nbsp;knihovny love.graphics</a><br />
<a href="#k07">7. Nastavení míchání barev a použití průhlednosti při vykreslování</a><br />
<a href="#k08">8. Základ animací</a><br />
<a href="#k09">9. Načtení externího obrázku, vykreslení obrázku v&nbsp;animaci s&nbsp;jeho natočením</a><br />
</p>



<p><a name="k01"></a></p>
<h1>1. Seznam demonstračních příkladů a způsob jejich spuštění</h1>

<p>V&nbsp;dnešním článku bude mj.&nbsp;uvedeno sedm demonstračních příkladů, na
nichž si vysvětlíme některé základní funkce systému <i>LÖVE</i>. Nejprve si
řekněme, jakým způsobem je možné tyto demonstrační příklady spustit
(předpokladem samozřejmě je, že systém <i>LÖVE</i> je již nainstalovaný).
Nejjednodušší metoda spočívá v&nbsp;tom, že se interpretr <strong>love</strong>
či <strong>love.exe</strong> spustí s&nbsp;jedním parametrem, kterým je název
(popřípadě doplněný i o cestu) k&nbsp;souboru s&nbsp;koncovkou <i>.love</i>.
Tento soubor není ve skutečnosti nic jiného než archiv vytvořený programem typu
<i>zip</i>, jenž obsahuje několik souborů: konfigurační soubor
<strong>game.conf</strong> (který prozatím nevyužíváme, proto má jen velmi
jednoduchou strukturu), vlastní skript představující aplikaci (hru) nazvaný
<strong>main.lua</strong> a v&nbsp;případě potřeby i další potřebné soubory
&ndash; většinou se v&nbsp;demonstračních příkladech jedná o font
<strong>DejaVuLGCSansMono.ttf</strong> nebo o rastrový obrázek
<strong>gnome-globe.png</strong>.</p>

<p>Výsledné balíky tedy obsahují všechna data potřebná pro jejich běh (pozor
&ndash; musí se komprimovat přímo soubory se hrou, nikoli nadřazený adresář!).
Druhou možností spouštění, kterou využijí především vývojáři, je vyvolání
interpretru <strong>love</strong> či <strong>love.exe</strong> s&nbsp;jedním
parametrem představujícím cestu k&nbsp;adresáři, který obsahuje všechny výše
uvedené soubory (nesmí se uvést přímo cesta ke skriptu
<strong>main.lua</strong>, ale k&nbsp;celému adresáři). Je tedy možné například
soubor <strong>gfx_modes.love</strong> rozbalit programem <i>unzip</i> (či
podobnou aplikací) do samostatného adresáře a cestu k&nbsp;tomuto adresáři
předat interpretru. V&nbsp;následující tabulce jsou uloženy odkazy na všech
sedm demonstračních příkladů popsaných v&nbsp;následujících kapitolách:</p>

<table>
<tr><th>Název příkladu</th><th>Balík s&nbsp;příkladem</th></tr>
<tr><td>Zjištění dostupných celoobrazovkových režimů</td><td><att-url id="">gfx_modes.love</att-url></td></tr>
<tr><td>Načtení externího fontu                     </td><td><att-url id="">fonts1.love</att-url></td></tr>
<tr><td>Natočení textu                              </td><td><att-url id="">fonts2.love</att-url></td></tr>
<tr><td>Vykreslení jednoduchého obrazce             </td><td><att-url id="">drawing1.love</att-url></td></tr>
<tr><td>Nastavení míchání barev                     </td><td><att-url id="">drawing2.love</att-url></td></tr>
<tr><td>Jednoduchá animace                          </td><td><att-url id="">animation.love</att-url></td></tr>
<tr><td>Pohybující se rastrový obrázek              </td><td><att-url id="">images.love</att-url></td></tr>
</table>



<p><a name="k02"></a></p>
<h1>2. Zjištění všech dostupných celoobrazovkových režimů</h1>

<p>Již v&nbsp;předchozí části tohoto seriálu jsme si řekli, že systém
<i>LÖVE</i> umožňuje běh hry či jiné multimediální aplikace jak v&nbsp;běžném
okně (vytvářeném pomocí správce oken daného operačního systému), tak i
v&nbsp;takzvaném celoobrazovkovém režimu &ndash; <i>fullscreen mode</i>.
V&nbsp;celoobrazovkovém režimu má aplikace zajištěn exkluzivní přístup
k&nbsp;části video paměti a při porušení této oblasti paměti
(tj.&nbsp;například ve chvíli přepnutí do jiné aplikace) systém sám požádá o
překreslení celé scény. Okno či celoobrazovkový režim je možné nastavit pomocí
funkce <i>love.graphics.setMode()</i>, ovšem před voláním této funkce je
vhodné, zejména při snaze o nastavení celoobrazovkového režimu, zavoláním
<i>love.graphics.getModes()</i> nebo <i>love.graphics.checkMode()</i> zjistit,
zda je požadovaný grafický režim vůbec podporován (například na mnoha
počítačích existují poměrně restriktivní omezení pro rozlišení
celoobrazovkových režimů). V&nbsp;následující tabulce je vypsáno všech pět
parametrů funkce <i>love.graphics.setMode()</i>, kterou budeme používat ve
všech dnešních demonstračních příkladech:</p>

<h2>Parametry funkce <i>love.graphics.checkMode()</i></h2>

<table>
<tr><th>Název parametru</th><th>Význam</th></tr>
<tr><td>width</td><td>požadovaný počet pixelů na horizontální ose (buď se jedná
o vnitřní šířku okna bez započítání jeho okrajů, nebo o horizontální rozlišení
celoobrazovkového režimu)</td></tr>
<tr><td>height</td><td>požadovaný počet pixelů na vertikální ose (buď se jedná
o vnitřní výšku okna bez okrajů a horní lišty, nebo o vertikální rozlišení
celoobrazovkového režimu)</td></tr>
<tr><td>fullscreen</td><td>pravdivostní příznak určující, zda se má vykreslovat
do okna či na celou obrazovku</td></tr>
<tr><td>vsync</td><td>pravdivostní příznak určující, zda se má provádět
synchronizace vykreslování s&nbsp;vertikálním návratem paprsku (vertikální
zatmění); většinou je vhodné synchronizaci zapnout, aby se zabránilo nežádoucím
&bdquo;střihům&ldquo; ve scéně při přepínání předního a zadního
bufferu</td></tr>
<tr><td>fsaa</td><td>počet bufferů použitých při antialiasingu celé scény
(antialiasing však lze zapnout lokálně, například při vykreslování
geometrických tvarů, což bude patrné i ze screenshotů demonstračních příkladů),
toto nastavení má význam především při práci s&nbsp;rastrovými
obrázky</td></tr>
</table>

<p>Funkce <i>love.graphics.getModes()</i>, na rozdíl od výše popsané funkce
<i>love.graphics.setMode()</i>, nevyžaduje při svém volání předání žádných
parametrů. Výstupní hodnotou této funkce je asociativní pole obsahující seznam
všech podporovaných celoobrazovkových grafických režimů. Každý grafický režim
je v&nbsp;tomto poli představován jednou položkou, která je taktéž (jako
prakticky každý složitější datový typ jazyka <i>Lua</i>) asociativním polem
s&nbsp;dvojicí klíčů <i>width</i> a <i>height</i> obsahujících horizontální a
vertikální rozlišení každého celoobrazovkového grafického režimu. Dnešní první
demonstrační příklad slouží ke zjištění všech těchto režimů a uložení informací
o nich do globální proměnné <i>modes</i>. Následně je otevřeno okno, načteno
standardní písmo (viz následující kapitoly) a do okna je celý seznam režimů
vypsán. Vertikální velikost okna je přepočtena na základě celkového počtu
podporovaných režimů. Pokud by bylo okno příliš vysoké, postačuje snížit
hodnotu konstanty <i>fontHeight</i>, čímž dojde ke zmenšení písma použitého pro
výpis informací. Zdrojový kód prvního demonstračního příkladu, tj.&nbsp;obsah
souboru nazvaného <strong>main.lua</strong>, je následující:</p>

<pre>
<i>-----------------------------------------------------------------------</i><br />
<i>-- Seriál "Programovací jazyk Lua"</i><br />
<i>--</i><br />
<i>-- Zjištění všech podporovaných celoobrazovkových grafických režimů</i><br />
<i>-----------------------------------------------------------------------</i><br />
<br />
<i>-- asociativní pole, do kterého se seznam podporovaných režimů uloží</i><br />
modes = nil<br />
<br />
fontHeight = 20<br />
<br />
<i>-- callback funkce zavolaná při inicializaci aplikace</i><br />
<strong>function</strong> load()<br />
    <i>-- získat všechny podporované grafické režimy</i><br />
    modes = love.graphics.getModes()<br />
    <i>-- načíst standardní font</i><br />
    <strong>local</strong> font = love.graphics.newFont(love.default_font, fontHeight)<br />
    <i>-- vytvořit okno pro vykreslování</i><br />
    love.graphics.setMode(450, 100 + #modes * fontHeight, false, false, 0)<br />
    love.graphics.setFont(font)<br />
<strong>end</strong><br />
<br />
<i>-- callback funkce volaná průběžně ve chvíli, kdy je zapotřebí překreslit okno</i><br />
<strong>function</strong> draw()<br />
    love.graphics.setColor(255, 255, 255)<br />
    love.graphics.draw("Gfx modes:", 10, 30) <br />
    <i>-- iterovat přes všechny režimy uložené v asociativním poli "modes"</i><br />
    <strong>for</strong> i, mode in ipairs(modes) do <br />
        <i>-- výpočet intenzity jedné barvové složky pro změnu barvy textu</i><br />
        <strong>local</strong> color = 255*(i-1)/#modes<br />
        love.graphics.setColor(255-color, 255, color)<br />
        <i>-- formátování řetězce, který se vypíše do okna</i><br />
        <strong>local</strong> desc = string.format("gfx.mode %d: %dx%d", i, mode.width, mode.height) <br />
        love.graphics.draw(desc, 20, 50 + i * fontHeight) <br />
    end <br />
    love.graphics.setColor(255, 128, 128)<br />
    <i>-- přepočet vertikálního umístění řetězce v závislosti na počtu grafických režimů</i><br />
    love.graphics.draw("Press escape to exit.", 30, 90 + #modes * fontHeight)<br />
<strong>end</strong><br />
<br />
<i>-- callback funkce volaná ve chvíli, kdy uživatel stlačí nějakou klávesu</i><br />
<strong>function</strong> keypressed(key)<br />
    <strong>if</strong> key == love.key_escape <strong>then</strong><br />
        love.system.exit()<br />
    <strong>end</strong><br />
<strong>end</strong><br />
<br />
<i>-- finito</i><br />
</pre>

<img src="http://i.iinfo.cz/rs2/105/lua13-01.png" alt="lua13_01" height="300" width="450" />
<p><i>Obrázek 1: Screenshot prvního demonstračního příkladu, který byl
spuštěn na počítači s&nbsp;grafickou kartou Intel 82852 GM. Tato karta sice
podporuje i vyšší rozlišení, než zde zobrazených 1024&times;768 pixelů, ovšem
nabídka všech reálně nabízených režimů je omezena taktéž maximálním rozlišením
displeje, které je v&nbsp;tomto případě rovno právě zmíněným 1024&times;768
pixelům (jedná se o starší notebook s&nbsp;displejem 4:3).</i></p>



<p><a name="k03"></a></p>
<h1>3. Načtení externího fontu a vykreslení všech jeho znaků</h1>

<p>Ve druhém demonstračním příkladu si ukážeme, jakým způsobem je možné načíst
libovolný font ve formátu <i>TrueType</i> či <i>OpenType</i> (třetím
podporovaným formátem je rastrový obrázek s&nbsp;vykreslenými znaky, jehož
použití si ukážeme příště). Soubor s&nbsp;fontem by měl být umístěný ve stejném
adresáři, v&nbsp;jakém se nachází samotný skript s&nbsp;hrou (soubor
<strong>main.lua</strong>), popř.&nbsp;ho lze umístit i do archivu s&nbsp;hrou.
Font se při inicializaci hry načte pomocí funkce
<i>love.graphics.newFont()</i>. Tato funkce akceptuje buď jeden či dva
parametry. Prvním parametrem je vždy název souboru s&nbsp;fontem, druhý
(nepovinný) parametr udává velikost písma. Pokud není druhý parametr zadaný,
doplní se automaticky velikost 12 bodů. Vzhledem k&nbsp;tomu, že ve formátech
<i>TrueType</i> i <i>OpenType</i> jsou hranice znaků popsány parametricky, je
možné písmo takřka libovolně zvětšovat a zmenšovat (navíc se může při
zmenšování uplatnit takzvaný <i>hinting</i> zlepšující kresbu malých znaků). Po
načtení fontu je možné pomocí funkce <i>love.graphics.draw()</i> provést výpis
libovolného řetězce na obrazovku. Tato funkce je přetížená (viz následující
kapitolu), přičemž v&nbsp;tomto demonstračním příkladu je použita její
nejjednodušší podoba se třemi parametry: samotným řetězcem následovaným x-ovou
a y-ovou souřadnicí začátku vykreslování. Následuje výpis zdrojového kódu
druhého demonstračního příkladu:</p>

<pre>
<i>-----------------------------------------------------------------------</i><br />
<i>-- Seriál "Programovací jazyk Lua"</i><br />
<i>--</i><br />
<i>-- Ukázka načtení fontu uloženého v externím souboru</i><br />
<i>-----------------------------------------------------------------------</i><br />
<br />
<i>-- callback funkce zavolaná při inicializaci aplikace</i><br />
<strong>function</strong> load()<br />
    <i>--<strong>local</strong> font = love.graphics.newFont(love.default_font, 20)</i><br />
    <strong>local</strong> font = love.graphics.newFont("DejaVuLGCSansMono.ttf", 20)<br />
    love.graphics.setMode(450, 300, false, false, 0)<br />
    love.graphics.setFont(font)<br />
<strong>end</strong><br />
<br />
<i>-- průměrná výška fontu</i><br />
fontHeight = 30<br />
<br />
<i>-- callback funkce volaná průběžně ve chvíli, kdy je zapotřebí překreslit okno</i><br />
<strong>function</strong> draw()<br />
    love.graphics.setColor(200, 255, 200)<br />
    <i>-- vykreslit matici 32x8 znaků</i><br />
    <i>-- (prvních 32 znaků však většinou font neobsahuje, popřípadě obsahuje</i><br />
    <i>--  pouze samé prázdné obdélníky - podle typu fontu)</i><br />
    <strong>for</strong> y = 0, 7 <strong>do</strong><br />
        <strong>local</strong> str = ""<br />
        <strong>for</strong> x = 0, 31 <strong>do</strong><br />
            str = str .. string.char(x + y * 32)<br />
        <strong>end</strong><br />
        <i>-- vypsat celý řádek 32 znaků uložený v řetězci "str"</i><br />
        love.graphics.draw(str, 20, fontHeight + y * fontHeight)<br />
    <strong>end</strong><br />
    love.graphics.setColor(255, 200, 255)<br />
    love.graphics.draw("Press escape to exit.", 30, 280)<br />
<strong>end</strong><br />
<br />
<i>-- callback funkce volaná ve chvíli, kdy uživatel stlačí nějakou klávesu</i><br />
<strong>function</strong> keypressed(key)<br />
    <strong>if</strong> key == love.key_escape <strong>then</strong><br />
        love.system.exit()<br />
    <strong>end</strong><br />
<strong>end</strong><br />
<br />
<i>-- finito</i><br />
</pre>

<img src="http://i.iinfo.cz/rs2/369/lua13-02.png" alt="lua13_02" height="300" width="450" />
<p><i>Obrázek 2: Screenshot druhého demonstračního příkladu &ndash;
výpis prvních 256 znaků fontu nazvaného <strong>DejaVu LGC Sans Mono</strong>.
Prvních 32 znaků je zcela prázdných a znaky na pozicích 128-160 obsahují pouze
obdélník, tj.&nbsp;pro praktické využití jsou také neobsazené. Systém LÖVE
nedokáže ve své současné verzi vypsat znaky s&nbsp;jiným kódem než 0-255, což
způsobuje problémy při práci s&nbsp;lokalizovanými aplikacemi. Jedno
z&nbsp;možných řešení tohoto problému si ukážeme příště.</i></p>



<p><a name="k04"></a></p>
<h1>4. Natočení textu při jeho vykreslování</h1>

<p>V&nbsp;předchozí kapitole jsme si řekli, že funkce
<i>love.graphics.draw()</i> je přetížená, tj.&nbsp;akceptuje při svém volání
různý počet i odlišné typy parametrů, které ovlivňují její chování. Pro
vykreslování písma (řetězce znaků) je možné využít celkem čtyři podoby této
funkce, které jsou vypsány v&nbsp;následující tabulce. Navíc jsou
v&nbsp;tabulce pro úplnost vypsány i dvě podoby funkce
<i>love.graphics.drawf()</i> (draw formatted string), pomocí níž lze řetězec
zalomit do odstavce se zadanou šířkou (v&nbsp;pixelech).</p>

<h2>Podoby funkce <i>love.graphics.draw()</i> při vykreslování písma</h2>

<table>
<tr><th>Volání funkce love.graphics.draw()</th><th>Význam</th></tr>
<tr><td>love.graphics.draw(string, x, y)               </td><td>výpis řetězce
na pozici [x,y]</td></tr>
<tr><td>love.graphics.draw(string, x, y, angle)        </td><td>výpis řetězce
na pozici [x,y] s&nbsp;natočením <i>angle</i> stupňů</td></tr>
<tr><td>love.graphics.draw(string, x, y, angle, s)     </td><td>stejné, jako
předchozí volání, ovšem text lze zvětšit či zmenšit podle hodnoty parametru
<i>s</i></td></tr>
<tr><td>love.graphics.draw(string, x, y, angle, sx, sy)</td><td>hodnoty
parametrů <i>sx</i> a <i>sy</i> ovlivňují měřítko v&nbsp;horizontální a
vertikální ose</td></tr>
<tr><td>love.graphics.drawf(string, x, y, limit)       </td><td>výpis řetězce
zalomeného do odstavce, jehož šířka je <i>limit</i> pixelů</td></tr>
<tr><td>love.graphics.drawf(string, x, y, limit, align)</td><td>výpis řetězce
zalomeného do odstavce, jehož šířka je <i>limit</i> pixelů, řádky
v&nbsp;odstavci jsou zarovnány podle parametru <i>align</i>:
<i>love.align_left</i>, <i>love.align_center</i> či
<i>love.align_right</i></td></tr>
</table>

<p>Ve třetím demonstračním příkladu je funkce <i>love.graphics.draw()</i>
volána se čtveřicí parametrů: vlastním řetězcem, který se má vykreslit,
souřadnicemi počátku vykreslovaného řetězce v&nbsp;okně a konečně úhlem
natočení řetězce. Po spuštění příkladu se vykreslí 36 řetězců, každý
s&nbsp;odlišným natočením i různým počátečním bodem. Úhel natočení se postupně
zvyšuje tak, aby po ukončení vykreslování všech řetězců byla dokončena celá
smyčka o 360&deg; a počátek vykreslování řetězce se posouvá z&nbsp;bodu [30,
20] směrem vpravo dolů. Zdrojový text třetího demonstračního příkladu má
tvar:</p>

<pre>
<i>-----------------------------------------------------------------------</i><br />
<i>-- Seriál "Programovací jazyk Lua"</i><br />
<i>--</i><br />
<i>-- Ukázka načtení fontu uloženého v externím souboru a vykreslení</i><br />
<i>-- textu spolu s jeho natočením a změnou barvy</i><br />
<i>-----------------------------------------------------------------------</i><br />
<br />
<i>-- callback funkce zavolaná při inicializaci aplikace</i><br />
<strong>function</strong> load()<br />
    <strong>local</strong> font = love.graphics.newFont("DejaVuLGCSansMono.ttf", 30)<br />
    love.graphics.setMode(450, 450, false, false, 0)<br />
    love.graphics.setFont(font)<br />
<strong>end</strong><br />
<br />
<i>-- callback funkce volaná průběžně ve chvíli, kdy je zapotřebí překreslit okno</i><br />
<strong>function</strong> draw()<br />
    <i>-- vypisovaný řetězec</i><br />
    str = "www.root.cz"<br />
    <strong>for</strong> i=0, 255, 7 <strong>do</strong><br />
        <i>-- nastavení barvy</i><br />
        love.graphics.setColor(i, 255, 255-i)<br />
        <i>-- výpis textu s jeho natočením</i><br />
        <strong>local</strong> uhel = i * 360 / 255<br />
        love.graphics.draw(str, 30 + i, 1.5 * i + 20, uhel)<br />
    <strong>end</strong><br />
    love.graphics.setColor(255, 200, 255)<br />
    love.graphics.draw("Press escape to exit.", 30, 430)<br />
<strong>end</strong><br />
<br />
<i>-- callback funkce volaná ve chvíli, kdy uživatel stlačí nějakou klávesu</i><br />
<strong>function</strong> keypressed(key)<br />
    <strong>if</strong> key == love.key_escape <strong>then</strong><br />
        love.system.exit()<br />
    <strong>end</strong><br />
<strong>end</strong><br />
<br />
<i>-- finito</i><br />
</pre>

<img src="http://i.iinfo.cz/rs2/583/lua13-03.png" alt="lua13_03" height="450" width="450" />
<p><i>Obrázek 3: Screenshot třetího demonstračního příkladu &ndash;
výpis řetězce s&nbsp;posunem počátku jeho vykreslení i úhlu
natočení.</i></p>



<p><a name="k05"></a></p>
<h1>5. Funkce určené pro změnu stylu vykreslování</h1>

<p>Knihovna <i>love.graphics</i> obsahuje několik funkcí určených pro
vykreslování základních geometrických obrazců, především bodů
(<i>love.graphics.point</i>), úseček (<i>love.graphics.line</i>) a kružnic
(<i>love.graphics.circle</i>). Tyto obrazce jsou vykresleny nastavenou barvou,
tloušťkou čáry, stylem čáry (plná, čárkovaná atd.) a se zapnutým či vypnutým
antialiasingem. Styl čáry je ovlivněn šestnáctibitovou hodnotou představující
bitový vzorek &ndash; bitová hodnota 1 znamená, že se ve vzorku nachází krátká
čárka, nula naopak znamená mezeru. Použití si ukážeme příště
v&nbsp;komplexnějším demonstračním příkladu, který bude všechny dostupné styly
používat. Povolení antialiasingu funkcí
<i>love.graphics.setLineStyle(love.line_smooth)</i> poměrně výrazným způsobem
zlepšuje kvalitu výsledného obrázku, především u šikmých linek, kde díky
vlastnostem rastrového displeje dochází k&nbsp;tvorbě &bdquo;schodů&ldquo;
&ndash; <i>jagged lines</i>, ovšem toto vizuální vylepšení jde na úkor
rychlosti vykreslování. U jednodušších her, ve kterých se používá omezený počet
objektů (řádově stovky), si však s&nbsp;tímto typem antialiasingu soudobé
grafické akcelerátory bez větších problémů poradí, protože vykreslování je
prováděno (přes knihovnu OpenGL i ovladač grafické karty) samotným GPU
umístěným na akcelerátoru. Seznam funkcí ovlivňujících způsob vykreslování, je
uveden v&nbsp;tabulce níže:</p>

<table>
<tr><th>Název funkce</th><th>Význam</th></tr>
<tr><td>love.graphics.setColor()</td><td>nastavení barvy vykreslovaných
objektů</td></tr>
<tr><td>love.graphics.setColorMode()</td><td>určení, zda se má při vykreslování
provádět modulace (násobení) barvy s&nbsp;pozadím</td></tr>
<tr><td>love.graphics.setBlendMode()</td><td>povolení či zákaz míchání barev
s&nbsp;pozadím při vykreslování</td></tr>
<tr><td>love.graphics.setLineWidth()</td><td>šířka čáry při
vykreslování</td></tr>
<tr><td>love.graphics.setLineStyle()</td><td>povolení či zákaz antialiasingu
při vykreslování úseček</td></tr>
<tr><td>love.graphics.setLineStipple()</td><td>nastavení typu čáry podle
zadaného bitového vzorku</td></tr>
</table>



<p><a name="k06"></a></p>
<h1>6. Vykreslení jednoduchého obrazce pomocí funkcí z&nbsp;knihovny love.graphics</h1>

<p>Ve čtvrtém demonstračním příkladu, kde je výše zmíněný antialiasing při
vykreslování úseček povolen (jedná se ostatně o implicitní nastavení), je
ukázán způsob vykreslení úseček funkcí <i>love.graphics.line()</i> spolu se
změnou jejich barvy pomocí funkce <i>love.graphics.setColor()</i>, které lze
předat buď trojici barvových složek červená, zelená, modrá barvového režimu
RGB, popřípadě lze k&nbsp;této trojici přidat i míru průhlednosti (viz
následující kapitolu). Hodnoty všech tří barvových složek i hodnota
průhlednosti musí ležet v&nbsp;rozsahu 0 až 255, kde nula značí nulovou
intenzitu složky a hodnota 255 naopak maximální intenzitu. Černá barva je tedy
zadána trojicí (0, 0, 0), čistá červená barva trojicí (255, 0, 0), barva žlutá
trojicí (255, 255, 0) a bílá pomocí (255, 255, 255). Při vývoji aplikace je
možné potřebné barevné odstíny získat například z&nbsp;dialogu pro míchání
barev, který se nachází mj.&nbsp;i v&nbsp;programu <i>GIMP</i> či
<i>PaintBrush</i>. Pomocí úseček je vytvořen objekt sestavený ze čtyřiceti
rovnostranných trojúhelníků s&nbsp;proměnnou barvou stran. Následuje výpis
zdrojového kódu tohoto demonstračního příkladu:</p>

<pre>
<i>-----------------------------------------------------------------------</i><br />
<i>-- Seriál "Programovací jazyk Lua"</i><br />
<i>--</i><br />
<i>-- Kreslení pomocí funkcí z knihovny love.graphics</i><br />
<i>-----------------------------------------------------------------------</i><br />
<br />
<i>-- rozměry okna</i><br />
width = 450<br />
height = 450<br />
<br />
<i>-- poloměr vykreslovaného obrazce</i><br />
radius = 200<br />
<br />
<i>-- callback funkce zavolaná při inicializaci aplikace</i><br />
<strong>function</strong> load()<br />
    <i>-- načtení standardního fontu a nastavení grafického režimu</i><br />
    <strong>local</strong> font = love.graphics.newFont(love.default_font, 20)<br />
    love.graphics.setMode(width, height, false, false, 0)<br />
    love.graphics.setFont(font)<br />
<strong>end</strong><br />
<br />
<i>-- callback funkce volaná průběžně ve chvíli, kdy je zapotřebí překreslit okno</i><br />
<strong>function</strong> draw()<br />
    <strong>local</strong> max = 120<br />
    <i>-- vykreslení obrazce složeného ze sady rovnostranných trojúhelníků</i><br />
    <strong>for</strong> i=1, max, 3 <strong>do</strong><br />
        <i>-- natočení trojúhelníku</i><br />
        <strong>local</strong> colorAngle = math.rad(i*360/max)<br />
        <i>-- výpočet a nastavení barvy</i><br />
        love.graphics.setColor(128+127*math.cos(colorAngle), 255, 128+128*math.sin(colorAngle))<br />
        <strong>for</strong> j=0, 2 <strong>do</strong><br />
            <strong>local</strong> angle1 = math.rad(i + j * 120)<br />
            <strong>local</strong> angle2 = angle1 + math.rad(120)<br />
            <strong>local</strong> x1 = width/2 + radius*math.cos(angle1)<br />
            <strong>local</strong> y1 = width/2 + radius*math.sin(angle1)<br />
            <strong>local</strong> x2 = width/2 + radius*math.cos(angle2)<br />
            <strong>local</strong> y2 = width/2 + radius*math.sin(angle2)<br />
            love.graphics.line(x1, y1, x2, y2)<br />
        <strong>end</strong><br />
    <strong>end</strong><br />
    love.graphics.setColor(255, 200, 255, 255)<br />
    love.graphics.draw("Press escape to exit.", 30, 443)<br />
<strong>end</strong><br />
<br />
<i>-- callback funkce volaná ve chvíli, kdy uživatel stlačí nějakou klávesu</i><br />
<strong>function</strong> keypressed(key)<br />
    <strong>if</strong> key == love.key_escape <strong>then</strong><br />
        love.system.exit()<br />
    <strong>end</strong><br />
<strong>end</strong><br />
<br />
<i>-- finito</i><br />
</pre>

<img src="http://i.iinfo.cz/rs2/32/lua13-04.png" alt="lua13_04" height="450" width="450" />
<p><i>Obrázek 4: Screenshot čtvrtého demonstračního příkladu &ndash;
povšimněte si, že při vykreslování úseček byl použit antialiasing, takže jejich
okraje vypadají poněkud rozmazaně a především se snížil (většinou) nežádoucí
jagging šikmých čar.</i></p>



<p><a name="k07"></a></p>
<h1>7. Nastavení míchání barev a použití průhlednosti při vykreslování</h1>

<p>V&nbsp;dnešním pátém demonstračním příkladu, jehož zdrojový kód je vypsán
pod tímto odstavcem, je ukázáno použití funkce
<i>love.graphics.setBlendMode()</i> i význam čtvrtého (nepovinného) parametru
funkce <i>love.graphics.setColor()</i>, nazývaného <i>alfa (alpha)</i>. Tento
parametr určuje průhlednost nastavené barvy a tím i celkový vizuální vzhled
objektu. Po spuštění demonstračního příkladu je možné pomocí klávesy
<strong>B</strong> přepínat režim míchání barev mezi
<i>love.blending_normal</i> a <i>love.blending_additive</i> a klávesami
<strong>0</strong> až <strong>9</strong> se nastavuje aktuální hodnota
<i>alfa</i>, jež musí ležet mezi nulou a 255. V&nbsp;režimu
<i>love.blending_normal</i> je nastavená barva pouze vynásobena hodnotou
<i>alfa</i> (předaná hodnota je nejprve vydělena 255, aby se nacházela
v&nbsp;rozsahu 0.0 až 1.0), ovšem pokud je nastavený režim
<i>love.blending_additive</i>, je proveden součet barvy pozadí (tj.&nbsp;i
dříve nakreslených objektů) s&nbsp;barvou vykreslovaného objektu, takže
v&nbsp;místech, kde se objekty překrývají, dochází ke zvýšení intenzity
barev:</p>

<pre>
<i>-----------------------------------------------------------------------</i><br />
<i>-- Seriál "Programovací jazyk Lua"</i><br />
<i>--</i><br />
<i>-- Kreslení pomocí funkcí z knihovny love.graphics, nastavení režimu</i><br />
<i>-- směšování barev</i><br />
<i>-----------------------------------------------------------------------</i><br />
<br />
<i>-- rozměry okna</i><br />
width = 450<br />
height = 450<br />
<br />
<i>-- poloměr vykreslovaného obrazce</i><br />
radius = 200<br />
<br />
<i>-- režim směšování barev</i><br />
blending = love.blend_normal<br />
<i>-- konstanta pro směšování</i><br />
blend_factor = 80<br />
<br />
<i>-- callback funkce zavolaná při inicializaci aplikace</i><br />
<strong>function</strong> load()<br />
    <i>-- načtení standardního fontu a nastavení grafického režimu</i><br />
    <strong>local</strong> font = love.graphics.newFont(love.default_font, 20)<br />
    love.graphics.setMode(width, height, false, false, 0)<br />
    love.graphics.setFont(font)<br />
<strong>end</strong><br />
<br />
<i>-- callback funkce volaná průběžně ve chvíli, kdy je zapotřebí překreslit okno</i><br />
<strong>function</strong> draw()<br />
    <i>-- nastavení režimu směšování barev</i><br />
    love.graphics.setBlendMode(blending)<br />
    love.graphics.setColor(255, 255, 255, blend_factor)<br />
    <i>-- vykreslení obrazce</i><br />
    <strong>for</strong> i=1, 90 <strong>do</strong><br />
        <strong>for</strong> j=0, 3 <strong>do</strong><br />
            <strong>local</strong> angle1 = math.rad(i + j * 90)<br />
            <strong>local</strong> angle2 = angle1 + 90<br />
            <strong>local</strong> x1 = width/2 + radius*math.cos(angle1*2)<br />
            <strong>local</strong> y1 = width/2 + radius*math.sin(angle1*3)<br />
            <strong>local</strong> x2 = width/2 + radius*math.cos(angle2*3)<br />
            <strong>local</strong> y2 = width/2 + radius*math.sin(angle2*2)<br />
            love.graphics.line(x1, y1, x2, y2)<br />
        <strong>end</strong><br />
    <strong>end</strong><br />
    love.graphics.setColor(255, 200, 255, 255)<br />
    love.graphics.draw("Press escape to exit.", 30, 443)<br />
<strong>end</strong><br />
<br />
<i>-- callback funkce volaná ve chvíli, kdy uživatel stlačí nějakou klávesu</i><br />
<strong>function</strong> keypressed(key)<br />
    <strong>if</strong> key == love.key_escape <strong>then</strong><br />
        love.system.exit()<br />
    <strong>end</strong><br />
    <strong>if</strong> key == love.key_b <strong>then</strong><br />
        setBlending()<br />
    <strong>end</strong><br />
    <strong>if</strong> key &gt;= love.key_0 and key&lt;= love.key_9 <strong>then</strong><br />
        setBlendFactor(key)<br />
    <strong>end</strong><br />
<strong>end</strong><br />
<br />
<i>-- povolení či zákaz směšování barev po stisku klávesy "b"</i><br />
<strong>function</strong> setBlending()<br />
    <strong>if</strong> blending == love.blend_normal <strong>then</strong><br />
        blending = love.blend_additive<br />
    else<br />
        blending = love.blend_normal<br />
    <strong>end</strong><br />
<strong>end</strong><br />
<br />
<i>-- nastavení hodnoty blend_factor po stisku kláves "0" až "9"</i><br />
<strong>function</strong> setBlendFactor(key)<br />
    <strong>local</strong> code = key - love.key_0<br />
    blend_factor = code * 255 / 10<br />
<strong>end</strong><br />
<br />
<i>-- finito</i><br />
</pre>

<img src="http://i.iinfo.cz/rs2/182/lua13-05.png" alt="lua13_05" height="450" width="450" />
<p><i>Obrázek 5: Screenshot pátého demonstračního
příkladu.</i></p>



<p><a name="k08"></a></p>
<h1>8. Základ animací</h1>

<p>V&nbsp;předposledním demonstračním příkladu je ukázáno, jakým způsobem je
možné vytvořit jednoduchou animaci založenou na postupné změně parametrů
použitých při vykreslování obrazce složeného z&nbsp;úseček. V&nbsp;příkladu je
použita callback funkce <i>update()</i> volaná automaticky systémem <i>LÖVE</i>
v&nbsp;relativně pravidelných intervalech po cca 100 milisekundách,
tj.&nbsp;10&times; za sekundu. V&nbsp;callback funkci se nejprve volá funkce
<i>love.timer.sleep()</i>, která zajišťuje pasivní čekání s&nbsp;možností
přepnutí řízení na jiný proces, což představuje rozdíl oproti aktivnímu čekání
v&nbsp;programové smyčce, které zbytečně zatěžuje mikroprocesor a blokuje běh
dalších aplikací v&nbsp;systému. Po ukončení funkce <i>love.timer.sleep()</i>
se zvýší hodnota globální proměnné <i>offset</i>, která je následně využita
v&nbsp;průběhu překreslení celé scény v&nbsp;callback funkci <i>draw()</i>.
Pokud by bylo zapotřebí animaci časovat přesněji, lze pro tento účel využít
hodnotu parametru <i>dt</i> předávaného funkci <i>update()</i>, popř.&nbsp;je
také možné použít časovač dostupný přes funkce nabízené knihovnou
<i>love.timer</i>.</p>

<img src="http://i.iinfo.cz/rs2/192/lua13-06.png" alt="lua13_06" height="450" width="450" />
<p><i>Obrázek 6: Šestý demonstrační příklad &ndash; začátek animace.</i></p>

<p>Zdrojový kód šestého demonstračního příkladu má tvar:</p>

<pre>
<i>-----------------------------------------------------------------------</i><br />
<i>-- Seriál "Programovací jazyk Lua"</i><br />
<i>--</i><br />
<i>-- Jednoduchá animace objektu složeného z úseček</i><br />
<i>-----------------------------------------------------------------------</i><br />
<br />
<i>-- rozměry okna</i><br />
width = 450<br />
height = 450<br />
<br />
<i>-- poloměr objektu</i><br />
radius = 200<br />
<br />
<i>-- průběžně zvyšovaná hodnota</i><br />
offset = 0<br />
<br />
<i>-- callback funkce zavolaná při inicializaci aplikace</i><br />
<strong>function</strong> load()<br />
    <strong>local</strong> font = love.graphics.newFont(love.default_font, 20)<br />
    love.graphics.setMode(width, height, false, false, 0)<br />
    love.graphics.setFont(font)<br />
<strong>end</strong><br />
<br />
<i>-- callback funkce volaná průběžně ve chvíli, kdy je zapotřebí překreslit okno</i><br />
<strong>function</strong> draw()<br />
    <i>-- nastavení režimu kreslení (míchání stávajícího obrázku s novým objektem)</i><br />
    love.graphics.setBlendMode(love.blend_additive)<br />
    love.graphics.setColor(255, 255, 255, 80)<br />
    <i>-- vykreslení celého obrazce</i><br />
    <strong>for</strong> i=1, 90 <strong>do</strong><br />
        <strong>for</strong> j=0, 3 <strong>do</strong><br />
            <strong>local</strong> angle1 = math.rad(i + j * 90)<br />
            <strong>local</strong> angle2 = angle1 + math.rad(offset)<br />
            <strong>local</strong> x1 = width/2 + radius*math.cos(angle1*2)<br />
            <strong>local</strong> y1 = width/2 + radius*math.sin(angle1*3)<br />
            <strong>local</strong> x2 = width/2 + radius*math.cos(angle2*3)<br />
            <strong>local</strong> y2 = width/2 + radius*math.sin(angle2*2)<br />
            love.graphics.line(x1, y1, x2, y2)<br />
        <strong>end</strong><br />
    <strong>end</strong><br />
    love.graphics.setColor(255, 200, 255, 255)<br />
    love.graphics.draw("Press escape to exit.", 30, 443)<br />
<strong>end</strong><br />
<br />
<i>-- callback funkce volaná po 10ms</i><br />
<strong>function</strong> update(dt)<br />
    love.timer.sleep(100)<br />
    <i>-- zvýší se hodnota globální proměnné "offset"</i><br />
    offset = offset + 1<br />
<strong>end</strong><br />
<br />
<i>-- callback funkce volaná ve chvíli, kdy uživatel stlačí nějakou klávesu</i><br />
<strong>function</strong> keypressed(key)<br />
    <strong>if</strong> key == love.key_escape <strong>then</strong><br />
        love.system.exit()<br />
    <strong>end</strong><br />
<strong>end</strong><br />
<i>-- finito</i><br />
</pre>

<img src="http://i.iinfo.cz/rs2/614/lua13-07.png" alt="lua13_07" height="450" width="450" />
<img src="http://i.iinfo.cz/rs2/101/lua13-08.png" alt="lua13_08" height="450" width="450" />
<p><i>Obrázek 7 a 8: Další snímky z&nbsp;animace prováděné šestým
demonstračním příkladem</i></p>



<p><a name="k09"></a></p>
<h1>9. Načtení externího obrázku, vykreslení obrázku v&nbsp;animaci s&nbsp;jeho natočením</h1>

<p>I dnešní poslední demonstrační příklad bude po svém spuštění zobrazovat
jednoduchou animaci. Animovaný objekt je představován rastrovým obrázkem
uloženým ve formátu PNG, který je do aplikace načtený funkcí
<i>love.graphics.newImage()</i>. Po načtení je obrázek uložen do paměti
grafického akcelerátoru ve formě textury, což mj.&nbsp;znamená, že s&nbsp;ním
není možné provádět některé operace, například změnu barvy pixelu, čtení barev
pixelů atd. Naopak je podporováno hardwarově urychlené vykreslení obrázků,
které je interně provedeno namapováním obrázku (tj.&nbsp;rastrové textury) na
obdélník, který je následně promítnut do vykreslované scény. S&nbsp;využitím
systému <i>LÖVE</i> je vykreslení obrázku jednoduché, neboť se používá již výše
zmíněná přetížená funkce <i>love.graphics.draw()</i>. Této funkci lze předat
objekt představující obrázek, souřadnice obrázku (buď jeho středu nebo bodu
zadaného metodou <i>setCenter(x,y)</i>) a volitelně také úhel natočení obrázku
a změnu jeho měřítka. V&nbsp;demonstračním příkladu je poloha obrázku
(tj.&nbsp;vlastního objektu) měněna na základě výpočtu, který simuluje
trajektorii míčku v&nbsp;gravitačním poli (odrazy míčku jsou beze ztráty
pohybové energie). S&nbsp;každým odrazem se také mění směr otáčení obrázku.
Povšimněte si, že funkce <i>love.graphics.newImage()</i> ve skutečnosti vrací
objekt s&nbsp;několika metodami, které lze volat, například
<i>image:getWidth()</i>.</p>

<img src="http://i.iinfo.cz/rs2/679/lua13-09.png" alt="lua13_09" height="96" width="96" />
<p><i>Obrázek 9: Tato bitmapa je použita jako &bdquo;sprite&ldquo;
v&nbsp;sedmém demonstračním příkladu.</i></p>

<pre>
<i>-----------------------------------------------------------------------</i><br />
<i>-- Seriál "Programovací jazyk Lua"</i><br />
<i>--</i><br />
<i>-- Ukázka načtení rastrového obrázku uloženého v externím souboru,</i><br />
<i>-- natočení obrázku při jeho vykreslování</i><br />
<i>-----------------------------------------------------------------------</i><br />
<br />
<i>-- rozměry okna</i><br />
width = 450<br />
height = 450<br />
<br />
<i>-- parametry obrázku</i><br />
image = nil<br />
x = 100<br />
y = 100<br />
<br />
<i>-- posun obrázku a míra gravitace</i><br />
dx = 1<br />
dy = 1<br />
gravity = 0.01<br />
<br />
<i>-- natočení obrázku a změna natočení (doprava, doleva)</i><br />
angle = 0<br />
rotation = 1<br />
<br />
<i>-- callback funkce zavolaná při inicializaci aplikace</i><br />
<strong>function</strong> load()<br />
    <i>-- načíst standardní font</i><br />
    <strong>local</strong> font = love.graphics.newFont(love.default_font, 20)<br />
    love.graphics.setFont(font)<br />
    <i>-- načíst externí obrázek</i><br />
    image = love.graphics.newImage("gnome-globe.png")<br />
    love.graphics.setMode(width, height, false, false, 0)<br />
<strong>end</strong><br />
<br />
<i>-- callback funkce volaná průběžně ve chvíli, kdy je zapotřebí překreslit okno</i><br />
<strong>function</strong> draw()<br />
    <i>-- vykreslit natočený obrázek</i><br />
    love.graphics.draw(image, x + image:getWidth()/2, y + image:getHeight()/2, angle)<br />
    love.graphics.setColor(255, 200, 255, 255)<br />
    love.graphics.draw("Press escape to exit.", 30, 443)<br />
<strong>end</strong><br />
<br />
<i>-- průběžně volaná callback funkce</i><br />
<strong>function</strong> update(dt)<br />
    <i>-- posun obrázku</i><br />
    x = x + dx<br />
    y = y + dy<br />
    <i>-- gravitace = zrychlení ve směru osy y</i><br />
    dy = dy + gravity<br />
    <i>-- změna rotace obrázku</i><br />
    angle = angle + rotation<br />
    <i>-- otestovat nárazy do okrajů okna</i><br />
    <strong>if</strong> x &lt; 0 <strong>then</strong><br />
        x = 0<br />
        dx = -dx<br />
        rotation = 1<br />
    <strong>end</strong><br />
    <strong>if</strong> x &gt; width - image:getWidth() <strong>then</strong><br />
        x = width - image:getWidth()<br />
        dx = -dx<br />
        rotation = -1<br />
    <strong>end</strong><br />
    <i>-- "podlaha" a "strop"</i><br />
    <strong>if</strong> y &lt; 0 <strong>then</strong><br />
        y = 0<br />
        dy = -dy<br />
    <strong>end</strong><br />
    <strong>if</strong> y &gt; height - image:getHeight() <strong>then</strong><br />
        y = height - image:getHeight()<br />
        dy = -dy<br />
    <strong>end</strong><br />
    love.timer.sleep(10)<br />
<strong>end</strong><br />
<br />
<i>-- callback funkce volaná ve chvíli, kdy uživatel stlačí nějakou klávesu</i><br />
<strong>function</strong> keypressed(key)<br />
    <strong>if</strong> key == love.key_escape <strong>then</strong><br />
        love.system.exit()<br />
    <strong>end</strong><br />
<strong>end</strong><br />
<br />
<i>-- finito</i><br />
</pre>

<img src="http://i.iinfo.cz/rs2/228/lua13-10.png" alt="lua13_10" height="450" width="450" />
<p><i>Obrázek 10: Jeden snímek animace prováděné sedmým demonstračním
příkladem.</i></p>



<p></p><p></p>
<p><small>Autor: <a href="http://www.fit.vutbr.cz/~tisnovpa">Pavel Tišnovský</a> &nbsp; 2009</small></p>
</body>
</html>

