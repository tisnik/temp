<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
        "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html>
<head>
<title>Využití knihovny debug v programovacím jazyku Lua</title>
<meta name="Author" content="Pavel Tisnovsky" />
<meta name="Generator" content="vim" />
<meta http-equiv="content-type" content="text/html; charset=utf-8" />
<style type="text/css">
         body {color:#000000; background:#ffffff;}
         h1  {font-family: arial, helvetica, sans-serif; color:#ffffff; background-color:#c00000; text-align:center; padding-left:1em}
         h2  {font-family: arial, helvetica, sans-serif; color:#ffffff; background-color:#0000c0; padding-left:1em; text-align:left}
         h3  {font-family: arial, helvetica, sans-serif; color:#000000; background-color:#c0c0c0; padding-left:1em; text-align:left}
         h4  {font-family: arial, helvetica, sans-serif; color:#000000; background-color:#e0e0e0; padding-left:1em; text-align:left}
         a   {font-family: arial, helvetica, sans-serif;}
         li  {font-family: arial, helvetica, sans-serif; color:#000000; text-align:justify; width:450px;}
         ol  {font-family: arial, helvetica, sans-serif; color:#000000; text-align:justify; width:450px;}
         ul  {font-family: arial, helvetica, sans-serif; color:#000000; text-align:justify; width:450px;}
         p   {font-family: arial, helvetica, sans-serif; color:#000000; text-align:justify;}
         pre {background:#e0e0e0}
</style>
</head>

<body>

<h1>Využití knihovny debug v programovacím jazyku Lua</h1>

<h3>Pavel Tišnovský</h3>

<p></p>

<h1>Úvodník</h1>

<p>Programovací jazyk Lua sice ve své základní konfiguraci nabízí vývojářům pouze omezené množství knihoven, ovšem i funkce ze standardních knihoven jsou mnohdy velmi užitečné (a v mnoha jazycích je nenajdeme). Dobrým příkladem je knihovna nazvaná debug, kterou si dnes stručně představíme.</p>



<h2>Obsah</h2>

<p><a href="#k01">1. Využití knihovny debug v&nbsp;programovacím jazyku Lua</a></p>
<p><a href="#k02">2. Možnosti nabízené knihovnou <strong>debug</strong></a></p>
<p><a href="#k03">3. První demonstrační příklad: základní verze modulu umožňujícího trasování programu</a></p>
<p><a href="#k04">4. Druhý demonstrační příklad: zjištění a výpis jména zdrojového kódu a čísla řádku volaných funkcí</a></p>
<p><a href="#k05">5. Třetí demonstrační příklad: zpracování a zobrazení úrovně zanoření volaných funkcí</a></p>
<p><a href="#k06">6. Problém s&nbsp;funkcí <strong>pcall</strong> při vzniku výjimky</a></p>
<p><a href="#k07">7. Čtvrtý demonstrační příklad: úprava trasování tak, aby se zajistilo zpracování <strong>pcall</strong></a></p>
<p><a href="#k08">8. Repositář s&nbsp;demonstračními příklady</a></p>
<p><a href="#k09">9. Odkazy na Internetu</a></p>



<p><a name="k01"></a></p>
<h2 id="k01">1. Využití knihovny debug v&nbsp;programovacím jazyku Lua</h2>

<p>Programovací jazyk Lua je v&nbsp;současnosti používán zejména ve funkci
skriptovacího jazyka určeného pro kooperaci s&nbsp;nativními funkcemi, které
jsou většinou součástí rozsáhlejších knihoven či aplikací. Samotný interpret
tohoto programovacího jazyka i jeho základní knihovny jsou navrženy takovým
způsobem, aby se pro jejich překlad mohl použít libovolný překladač jazyka C
odpovídající normě ANSI C (C89, C90). Z&nbsp;toho ovšem vyplývají i některá
omezení, jelikož standard ANSI C (popř.&nbsp;C89 či C90) předepisuje pouze
relativně malé množství funkcí dostupných ve <a
href="https://en.wikipedia.org/wiki/C_standard_library">standardní knihovně</a>
a přeneseně pak i v&nbsp;knihovnách, které svým programátorům nabízí jazyk Lua.
Dobrým příkladem je absence funkcí pro práci se souborovým systémem (vytváření,
mazání a procházení adresářů, práva k&nbsp;souborům a adresářům atd.) či
absence podpory regulárních výrazů.</p>

<p>Na druhou stranu však mají programátoři k&nbsp;dispozici i knihovnu nazvanou
<strong>debug</strong> (viz též <a href="http://www.lua.org/pil/23.html">PIL
23</a>), která je určena pro zjišťování či změnu stavu virtuálního stroje
tohoto jazyka v&nbsp;době běhu aplikace (<i>runtime</i>). Možnosti nabízené
touto knihovnou jsou poměrně velké, protože je možné zkoumat obsah
zásobníkových rámců a tím pádem i zjišťovat pořadí volání funkcí, u
jednotlivých funkcí lze zjistit, v&nbsp;jakém souboru a na jakém programovém
řádku začíná jejich definice, lze přistupovat k&nbsp;lokálním proměnným funkcí
atd. Taktéž je možné provést registraci funkcí, které jsou automaticky zavolány
virtuálním strojem jazyka Lua ve chvíli, kdy dojde ke zvolené události,
například k&nbsp;zavolání libovolné funkce, návratu z&nbsp;funkce apod. Díky
této vlastnosti je možné implementovat například trasovací utility (což si
ukážeme v&nbsp;navazujících kapitolách), debuggery, profilery apod.</p>



<p><a name="k02"></a></p>
<h2 id="k02">2. Možnosti nabízené knihovnou <strong>debug</strong></h2>

<p>Programovací jazyk Lua verze 5.2 (což je dnes pravděpodobně nejpoužívanější
verze) v&nbsp;knihovně <strong>debug</strong> nabízí programátorům následující
funkce:</p>

<table>
<tr><th> #</th><th>Jméno funkce</th><th>Význam</th></tr>
<tr><td> 1</td><td>debug.debug       </td><td>zajistí přechod do interaktivního režimu, obdoba REPLu</td></tr>
<tr><td> 2</td><td>debug.gethook     </td><td>vrátí informace o nastaveném handleru (funkce+maska příznaků+počet volání, viz též debug.sethook popsaný dále)</td></tr>
<tr><td> 3</td><td>debug.getinfo     </td><td>zjištění runtime informací o funkci (viz též další kapitoly)</td></tr>
<tr><td> 4</td><td>debug.getlocal    </td><td>zjištění runtime informací o lokální proměnné či paramtru uloženém na zásobníkovém rámci (lze přistupovat na libovolný rámec)</td></tr>
<tr><td> 5</td><td>debug.getmetatable</td><td>vrátí metatabulku pro předanou hodnotu popř. <strong>nil</strong> pokud hodnota nemá přiřazenou metatabulku</td></tr>
<tr><td> 6</td><td>debug.getregistry </td><td>vrátí speciální tabulku určenou pro sdílení informací mezi Luou a C (podrobnosti se dozvíme příště)</td></tr>
<tr><td> 7</td><td>debug.getupvalue  </td><td>vrátí externí lokální proměnnou navázanou na funkci (pokud existuje, což ovšem platí jen pro uzávěry)</td></tr>
<tr><td> 8</td><td>debug.getuservalue</td><td>vrátí userdata pokud existují (jinak <strong>nil</strong>)</td></tr>
<tr><td> 9</td><td>debug.sethook     </td><td>nastavení handleru zavolaného po vzniku nějaké události, viz též další kapitoly s&nbsp;ukázkou kódu</td></tr>
<tr><td>10</td><td>debug.setlocal    </td><td>nastavení hodnoty lokální proměnné pomocí manipulace se zásobníkovými rámci (poměrně nebezpečné)</td></tr>
<tr><td>11</td><td>debug.setmetatable</td><td>nastavení nové metatabulky k&nbsp;předané hodnotě</td></tr>
<tr><td>12</td><td>debug.setupvalue  </td><td>nastavení externí lokální proměnné navázané na funkci (uzávěr, closure)</td></tr>
<tr><td>13</td><td>debug.setuservalue</td><td>změna userdata</td></tr>
<tr><td>14</td><td>debug.traceback   </td><td>vrátí stack trace (jako řetězec) popř.&nbsp;jen předanou zprávu</td></tr>
<tr><td>15</td><td>debug.upvalueid   </td><td>vrátí jednoznačný identifikátor externí lokální proměnné. Tento identifikátor je možné využít například na zjištění, zda dva uzávěry nesdílí stejnou proměnnou</td></tr>
<tr><td>16</td><td>debug.upvaluejoin </td><td>změna reference externí lokální proměnné jednoho uzávěru na odlišnou proměnnou v&nbsp;jiném uzávěru</td></tr>
</table>

<p>Většině funkcí lze v&nbsp;prvním parametru předat vlákno, s&nbsp;jehož
zásobníkovým rámcem se bude manipulovat. Pokud identifikátor vlákna není
předán, použije se současně běžící vlákno, tedy vlákno, z&nbsp;něhož je funkce
<strong>debug.jméno_funkce()</strong> volána.</p>

<p>Některé tyto funkce jsou součástí demonstračních příkladů popsaných
v&nbsp;navazujících kapitolách, o dalších vybraných funkcích se pak zmíním
v&nbsp;příští části tohoto seriálu.</p>



<p><a name="k03"></a></p>
<h2 id="k03">3. První demonstrační příklad: základní verze modulu umožňujícího trasování programu</h2>

<p>Podívejme se nyní na využití některých možností knihovny
<strong>debug</strong> v&nbsp;praxi. Mějme aplikaci, která se skládá ze tří
modulů pojmenovaných <strong>main</strong>, <strong>module1</strong> a
<strong>module2</strong>, přičemž funkce z&nbsp;jednotlivých modulů se navzájem
volají (což mimochodem nevypovídá o dobře navržené struktuře aplikace :-).
Budeme chtít, aby se při volání funkcí na standardní výstup vypsaly základní
informace o tom, která funkce je zavolána a do jakého modulu tato funkce patří.
Toto chování bude zajišťovat modul nazvaný <strong>tracer</strong>:</p>

<h3>main.lua</h3>

<pre>
<strong>local</strong> tracer = require("tracer")
require("module1")
require("module2")
&nbsp;
tracer.enable()
&nbsp;
<strong>function</strong> f1()
    print("Hello world!")
<strong>end</strong>
&nbsp;
<strong>function</strong> f2()
    f1()
<strong>end</strong>
&nbsp;
<strong>function</strong> f3()
    f2()
<strong>end</strong>
&nbsp;
&nbsp;
f3()
module1_f3()
module2_f3()
</pre>



<h3>module1.lua</h3>

<pre>
<strong>function</strong> module1_f1()
    print("Hello world from module1!")
<strong>end</strong>
&nbsp;
<strong>function</strong> module1_f2()
    module1_f1()
<strong>end</strong>
&nbsp;
<strong>function</strong> module1_f3()
    module1_f2()
<strong>end</strong>
</pre>



<h3>module2.lua</h3>

<pre>
<strong>function</strong> module2_f1()
    module1_f3()
<strong>end</strong>
&nbsp;
<strong>function</strong> module2_f2()
    module2_f1()
<strong>end</strong>
&nbsp;
<strong>function</strong> module2_f3()
    module2_f2()
<strong>end</strong>
</pre>



<h3>tracer.lua</h3>

<p>Nejzajímavější je samozřejmě modul <strong>tracer</strong>. Ten obsahuje
dvojici funkcí nazvaných <strong>tracer.eventHandler</strong> a
<strong>tracer.enable</strong>. Funkce <strong>tracer.enable</strong> volá:</p>

<pre>
debug.sethook(tracer.eventHandler, "cr")
</pre>

<p>Co toto volání znamená? Provádí se zde registrace handleru představovaného
uživatelskou funkcí <strong>tracer.eventHandler</strong>, přičemž tato funkce
je zavolána v&nbsp;případě, že ve virtuálním stroji jazyka Lua dojde
k&nbsp;jedné z&nbsp;těchto událostí:</p>

<table>
<tr><th>Maska</th><th>Plný název</th><th>Význam</th></tr>
<tr><td>c</td><td>call</td><td>volání libovolné funkce</td></tr>
<tr><td>r</td><td>return</td><td>návrat z&nbsp;libovolné funkce</td></tr>
</table>

<p>Samotný handler pak volá <strong>debug.getinfo(2)</strong> a
<strong>debug.getinfo(3)</strong>, kde hodnoty 2 a 3 značí relativní pozici
zásobníkového rámce (ty jsou za sebou zřetězeny, podobně jako v&nbsp;klasickém
céčku):</p>

<table>
<tr><th>debug.getinfo(n)</th><th>Význam</th></tr>
<tr><td>0</td><td>současně probíhající funkce, tedy samotné getinfo()</td></tr>
<tr><td>1</td><td>funkce volající getinfo(), což je tracer.eventHandler()</td></tr>
<tr><td>2</td><td>volaná funkce (zde zjišťujeme její typ a zda jde o volání či o return)</td></tr>
<tr><td>3</td><td>volající funkce (zde zjišťujeme číslo řádku a jméno zdrojového souboru)</td></tr>
<tr><td>4</td><td>funkce, která zavolala volající funkci :-)</td></tr>
<tr><td>5</td><td>atd. atd.</td></tr>
</table>

<p>Struktura vrácená funkcí <strong>debug.getinfo(n)</strong> se následně
použije pro zjištění jména souboru, čísla řádku, typu volané funkce (nativní
céčková funkce či Lua funkce) a taktéž typu události (volání či ukončení
funkce):</p>

<pre>
<i>--</i>
<i>-- Lua tracer v.1</i>
<i>--</i>
<strong>local</strong> tracer = {
}
&nbsp;
&nbsp;
&nbsp;
<i>--</i>
<i>-- Event handler called from Lua VM.</i>
<i>--</i>
<strong>function</strong> tracer.eventHandler(event)
    <strong>local</strong> output = ""
&nbsp;
    <strong>local</strong> debugInfo = debug.getinfo(3)
&nbsp;
    <strong>local</strong> output = "→ → → "
&nbsp;
    <strong>if</strong> debugInfo and debugInfo.currentline &gt;= 0 <strong>then</strong>
        output = output .. debugInfo.short_src, ":" .. debugInfo.currentline .. " "
    <strong>end</strong>
&nbsp;
    <strong>local</strong> debugInfo = debug.getinfo(2)
&nbsp;
    <i>-- 'what' attribute could have the following values:</i>
    <i>--    "Lua"  for regular Lua functions</i>
    <i>--    "C"    for C function</i>
    <i>--    "main" for the main part of a Lua chunk.</i>
    <strong>if</strong> debugInfo.what == "main" <strong>then</strong>
        <strong>if</strong> event == "call" <strong>then</strong>
            output = output .. "begin " .. debugInfo.short_src
        <strong>else</strong>
            output = output .. "end " .. debugInfo.short_src
        <strong>end</strong>
    <i>-- regular Lua function call</i>
    <strong>elseif</strong> debugInfo.what == "Lua" <strong>then</strong>
        output = output .. " •" .. (debugInfo.name or "(unknown Lua code)") .. "•"
    <i>-- C (native) function call</i>
    <strong>elseif</strong> debugInfo.what == "C" <strong>then</strong>
        output = output .. " •" .. (debugInfo.name or "(unknown C code)") .. "•"
    <i>-- should not happen :)</i>
    <strong>else</strong>
        output = output .. " unknown!"
    <strong>end</strong>
    print(output)
<strong>end</strong>
&nbsp;
&nbsp;
&nbsp;
<i>--</i>
<i>-- Register event handler for the "call" and "return" events.</i>
<i>--</i>
<strong>function</strong> tracer.enable()
    <i>-- we want to call event handler for the following events:</i>
    <i>-- "call"</i>
    <i>-- "return"</i>
    debug.sethook(tracer.eventHandler, "cr")
<strong>end</strong>
&nbsp;
&nbsp;
&nbsp;
<strong>return </strong>tracer
</pre>



<h3>Výsledky běhu prvního demonstračního příkladu</h3>

<p>Po spuštění by se měl na standardním výstupu objevit tento text (který navíc
umožňuje otestovat, zda Lua a terminál podporují UTF-8). Povšimněte si, že
uvnitř funkce <strong>print</strong> se podle očekávání volá nějaký nativní
kód:</p>

<pre>
→ → → ./tracer.lua •sethook•
→ → → main.lua •enable•
→ → → main.lua •f3•
→ → → main.lua •f2•
→ → → main.lua •f1•
→ → → main.lua •print•
→ → →  •(unknown C code)•
→ → →  •(unknown C code)•
Hello world!
→ → → main.lua •print•
→ → → main.lua •f1•
→ → → main.lua •f2•
→ → → main.lua •f3•
→ → → main.lua •module1_f3•
→ → → ./module1.lua •module1_f2•
→ → → ./module1.lua •module1_f1•
→ → → ./module1.lua •print•
→ → →  •(unknown C code)•
→ → →  •(unknown C code)•
Hello world from module1!
→ → → ./module1.lua •print•
→ → → ./module1.lua •module1_f1•
→ → → ./module1.lua •module1_f2•
→ → → main.lua •module1_f3•
→ → → main.lua •module2_f3•
→ → → ./module2.lua •module2_f2•
→ → → ./module2.lua •module2_f1•
→ → → ./module2.lua •module1_f3•
→ → → ./module1.lua •module1_f2•
→ → → ./module1.lua •module1_f1•
→ → → ./module1.lua •print•
→ → →  •(unknown C code)•
→ → →  •(unknown C code)•
Hello world from module1!
→ → → ./module1.lua •print•
→ → → ./module1.lua •module1_f1•
→ → → ./module1.lua •module1_f2•
→ → → ./module2.lua •module1_f3•
→ → → ./module2.lua •module2_f1•
→ → → ./module2.lua •module2_f2•
→ → → main.lua •module2_f3•
→ → → end main.lua
→ → →  •(unknown C code)•
</pre>



<p><a name="k04"></a></p>
<h2 id="k04">4. Druhý demonstrační příklad: zjištění a výpis jména zdrojového kódu a čísla řádku volaných funkcí</h2>

<p>Ve druhém demonstračním příkladu si možnosti vyvíjeného traceru poněkud
rozšíříme. Zejména budeme vypisovat i informaci o tom, v&nbsp;jakém místě
programu (jméno zdrojového souboru + číslo řádku) došlo k&nbsp;volání té které
funkce a taktéž se bude provádět rozlišení mezi voláním funkce (<i>call</i>) a
návratem z&nbsp;této funkce (<i>return</i>). Pro zpřehlednění zdrojového kódu
bylo formátování zprávy při volání/návratu z&nbsp;Lua funkce či nativní céčkové
funkce přesunuto do samostatných funkcí nazvaných
<strong>tracer.formatLuaCall</strong> a <strong>tracer.formatCCall</strong>.
Nová podoba modulu <strong>tracer</strong> vypadá následovně:</p>

<h3>tracer.lua</h3>

<pre>
<i>--</i>
<i>-- Lua tracer v.2</i>
<i>--</i>
<strong>local</strong> tracer = {
}
&nbsp;
&nbsp;
&nbsp;
<i>--</i>
<i>-- Format information about the Lua function call.</i>
<i>--</i>
<strong>function</strong> tracer.formatLuaCall(event, debugInfo)
    <strong>return </strong>" " .. event .. " •" .. (debugInfo.name or "(unknown Lua)")
           .. "•"
           .. "  &lt;" .. debugInfo.short_src .. ":" .. debugInfo.linedefined .. "&gt;"
<strong>end</strong>
&nbsp;
&nbsp;
&nbsp;
<i>--</i>
<i>-- Format information about C function call.</i>
<i>--</i>
<strong>function</strong> tracer.formatCCall(event, debugInfo)
    <strong>return </strong>" " .. event .. " •" .. (debugInfo.name or "(unknown C)")
           .. "•"
           .. "  [" .. debugInfo.what .. "]"
<strong>end</strong>
&nbsp;
&nbsp;
&nbsp;
<i>--</i>
<i>-- Event handler called from Lua VM.</i>
<i>--</i>
<strong>function</strong> tracer.eventHandler(event)
    <strong>local</strong> output = ""
&nbsp;
    <strong>local</strong> debugInfo = debug.getinfo(3)
&nbsp;
    <strong>local</strong> output = "→ → → "
&nbsp;
    <strong>if</strong> debugInfo and debugInfo.currentline &gt;= 0 <strong>then</strong>
        output = output .. debugInfo.short_src, ":" .. debugInfo.currentline .. " "
    <strong>end</strong>
&nbsp;
    <strong>local</strong> debugInfo = debug.getinfo(2)
&nbsp;
    <i>-- 'what' attribute could have the following values:</i>
    <i>--    "Lua"  for regular Lua functions</i>
    <i>--    "C"    for C function</i>
    <i>--    "main" for the main part of a Lua chunk.</i>
    <strong>if</strong> debugInfo.what == "main" <strong>then</strong>
        <strong>if</strong> event == "call" <strong>then</strong>
            output = output .. "begin " .. debugInfo.short_src
        <strong>else</strong>
            output = output .. "end " .. debugInfo.short_src
        <strong>end</strong>
    <i>-- regular Lua function call</i>
    <strong>elseif</strong> debugInfo.what == "Lua" <strong>then</strong>
        output = output .. tracer.formatLuaCall(event, debugInfo)
    <i>-- C (native) function call</i>
    <strong>elseif</strong> debugInfo.what == "C" <strong>then</strong>
        output = output .. tracer.formatCCall(event, debugInfo)
    <i>-- should not happen :)</i>
    <strong>else</strong>
        output = output .. " unknown!"
    <strong>end</strong>
    print(output)
<strong>end</strong>
&nbsp;
&nbsp;
&nbsp;
<i>--</i>
<i>-- Register event handler for the "call" and "return" events.</i>
<i>--</i>
<strong>function</strong> tracer.enable()
    <i>-- we want to call event handler for the following events:</i>
    <i>-- "call"</i>
    <i>-- "return"</i>
    debug.sethook(tracer.eventHandler, "cr")
<strong>end</strong>
&nbsp;
&nbsp;
&nbsp;
<strong>return </strong>tracer
</pre>



<h3>Výsledky běhu druhého demonstračního příkladu</h3>

<p>Po spuštění druhého demonstračního příkladu již získáme podrobnější výpis.
Každý řádek obsahuje celkem pět údajů:</p>

<ol>
<li>Modul, odkud se provádí volání, například <strong>main.lua</strong></li>
<li>Zda se jedná o volání (<i>call</i>) či o návrat z&nbsp;funkce (<i>return</i>)</li>
<li>Jméno volané funkce, například <strong>module1_f3</strong></li>
<li>Jméno modulu, kde se nachází volaná funkce, například <strong>./module1.lua</strong></li>
<li>Číslo řádku v&nbsp;rámci modulu, například <strong>:9</strong></li>
</ol>

<pre>
→ → → ./tracer.lua return •sethook•  [C]
→ → → main.lua return •enable•  &lt;./tracer.lua:75&gt;
→ → → main.lua call •f3•  &lt;main.lua:15&gt;
→ → → main.lua call •f2•  &lt;main.lua:11&gt;
→ → → main.lua call •f1•  &lt;main.lua:7&gt;
→ → → main.lua call •print•  [C]
→ → → call •(unknown C)•  [C]
→ → → return •(unknown C)•  [C]
Hello world!
→ → → main.lua return •print•  [C]
→ → → main.lua return •f1•  &lt;main.lua:7&gt;
→ → → main.lua return •f2•  &lt;main.lua:11&gt;
→ → → main.lua return •f3•  &lt;main.lua:15&gt;
→ → → main.lua call •module1_f3•  &lt;./module1.lua:9&gt;
→ → → ./module1.lua call •module1_f2•  &lt;./module1.lua:5&gt;
→ → → ./module1.lua call •module1_f1•  &lt;./module1.lua:1&gt;
→ → → ./module1.lua call •print•  [C]
→ → → call •(unknown C)•  [C]
→ → → return •(unknown C)•  [C]
Hello world from module1!
→ → → ./module1.lua return •print•  [C]
→ → → ./module1.lua return •module1_f1•  &lt;./module1.lua:1&gt;
→ → → ./module1.lua return •module1_f2•  &lt;./module1.lua:5&gt;
→ → → main.lua return •module1_f3•  &lt;./module1.lua:9&gt;
→ → → main.lua call •module2_f3•  &lt;./module2.lua:9&gt;
→ → → ./module2.lua call •module2_f2•  &lt;./module2.lua:5&gt;
→ → → ./module2.lua call •module2_f1•  &lt;./module2.lua:1&gt;
→ → → ./module2.lua call •module1_f3•  &lt;./module1.lua:9&gt;
→ → → ./module1.lua call •module1_f2•  &lt;./module1.lua:5&gt;
→ → → ./module1.lua call •module1_f1•  &lt;./module1.lua:1&gt;
→ → → ./module1.lua call •print•  [C]
→ → → call •(unknown C)•  [C]
→ → → return •(unknown C)•  [C]
Hello world from module1!
→ → → ./module1.lua return •print•  [C]
→ → → ./module1.lua return •module1_f1•  &lt;./module1.lua:1&gt;
→ → → ./module1.lua return •module1_f2•  &lt;./module1.lua:5&gt;
→ → → ./module2.lua return •module1_f3•  &lt;./module1.lua:9&gt;
→ → → ./module2.lua return •module2_f1•  &lt;./module2.lua:1&gt;
→ → → ./module2.lua return •module2_f2•  &lt;./module2.lua:5&gt;
→ → → main.lua return •module2_f3•  &lt;./module2.lua:9&gt;
→ → → end main.lua
→ → → return •(unknown C)•  [C]
</pre>



<p><a name="k05"></a></p>
<h2 id="k05">5. Třetí demonstrační příklad: zpracování a zobrazení úrovně zanoření volaných funkcí</h2>

<p>Třetí verze traceru se od verze předchozí liší především v&nbsp;tom, že si
tracer pamatuje úroveň zanoření jednotlivých funkcí, kterou používá pro
odsazení později volaných funkcí při výpisu trasovacích informací na standardní
výstup. Tato nová funkcionalita je implementována
v&nbsp;<strong>tracer.updateTraceLevel()</strong>, kde se na základě typu
události (volání funkce &ndash; <i>call</i> či návrat z&nbsp;funkce &ndash;
<i>return</i>) mění hodnota lokální proměnné modulu nazvaná
<strong>tracer.level</strong>. Tato hodnota potom řídí počet mezer vypsaných na
standardním výstupu:</p>

<pre>
string.rep("    ", tracer.level)
</pre>

<p>Nová podoba modulu vypadá následovně:</p>

<h3>tracer.lua</h3>

<pre>
<i>--</i>
<i>-- Lua tracer v.3</i>
<i>--</i>
<strong>local</strong> tracer = {
    level=0
}
&nbsp;
&nbsp;
&nbsp;
<i>--</i>
<i>-- Update trace level (for a bit nicer output).</i>
<i>--</i>
<strong>function</strong> tracer.updateTraceLevel(debugInfo, event)
    <i>-- decision between calling a function or returning from the function</i>
    <strong>if</strong> event == "call" <strong>then</strong>
        tracer.level = tracer.level + 1
    <strong>else</strong>
        tracer.level = tracer.level - 1
        <strong>if</strong> tracer.level &lt; 0 <strong>then</strong>
            tracer.level = 0
        <strong>end</strong>
    <strong>end</strong>
<strong>end</strong>
&nbsp;
&nbsp;
&nbsp;
<i>--</i>
<i>-- Format information about the Lua function call.</i>
<i>--</i>
<strong>function</strong> tracer.formatLuaCall(event, debugInfo)
    <strong>return </strong>" " .. event .. " •" .. (debugInfo.name or "(unknown Lua)")
           .. "•"
           .. "  &lt;" .. debugInfo.short_src .. ":" .. debugInfo.linedefined .. "&gt;"
<strong>end</strong>
&nbsp;
&nbsp;
&nbsp;
<i>--</i>
<i>-- Format information about C function call.</i>
<i>--</i>
<strong>function</strong> tracer.formatCCall(event, debugInfo)
    <strong>return </strong>" " .. event .. " •" .. (debugInfo.name or "(unknown C)")
           .. "•"
           .. "  [" .. debugInfo.what .. "]"
<strong>end</strong>
&nbsp;
&nbsp;
&nbsp;
<i>--</i>
<i>-- Event handler called from Lua VM.</i>
<i>--</i>
<strong>function</strong> tracer.eventHandler(event)
    <strong>local</strong> output = ""
&nbsp;
    <strong>local</strong> debugInfo = debug.getinfo(3)
&nbsp;
    <strong>local</strong> output = tracer.level .. " → → → " .. string.rep("    ", tracer.level)
&nbsp;
    <strong>if</strong> debugInfo and debugInfo.currentline &gt;= 0 <strong>then</strong>
        output = output .. debugInfo.short_src, ":" .. debugInfo.currentline .. " "
    <strong>end</strong>
&nbsp;
    <strong>local</strong> debugInfo = debug.getinfo(2)
&nbsp;
    tracer.updateTraceLevel(debugInfo, event)
&nbsp;
    <i>-- 'what' attribute could have the following values:</i>
    <i>--    "Lua"  for regular Lua functions</i>
    <i>--    "C"    for C function</i>
    <i>--    "main" for the main part of a Lua chunk.</i>
    <strong>if</strong> debugInfo.what == "main" <strong>then</strong>
        <strong>if</strong> event == "call" <strong>then</strong>
            output = output .. "begin " .. debugInfo.short_src
        <strong>else</strong>
            output = output .. "end " .. debugInfo.short_src
        <strong>end</strong>
    <i>-- regular Lua function call</i>
    <strong>elseif</strong> debugInfo.what == "Lua" <strong>then</strong>
        output = output .. tracer.formatLuaCall(event, debugInfo)
    <i>-- C (native) function call</i>
    <strong>elseif</strong> debugInfo.what == "C" <strong>then</strong>
        output = output .. tracer.formatCCall(event, debugInfo)
    <i>-- should not happen :)</i>
    <strong>else</strong>
        output = output .. " unknown!"
    <strong>end</strong>
    print(output)
<strong>end</strong>
&nbsp;
&nbsp;
&nbsp;
<i>--</i>
<i>-- Register event handler for the "call" and "return" events.</i>
<i>--</i>
<strong>function</strong> tracer.enable()
    <i>-- we want to call event handler for the following events:</i>
    <i>-- "call"</i>
    <i>-- "return"</i>
    debug.sethook(tracer.eventHandler, "cr")
<strong>end</strong>
&nbsp;
&nbsp;
&nbsp;
<strong>return </strong>tracer
</pre>



<h3>Výsledky běhu třetího demonstračního příkladu (<strong>main.lua</strong>)</h3>

<p>Po spuštění třetího demonstračního příkladu již získáme podrobnější výpis i
s&nbsp;odsazením:</p>

<pre>
0 → → → ./tracer.lua return •sethook•  [C]
0 → → → main.lua return •enable•  &lt;./tracer.lua:96&gt;
0 → → → main.lua call •f3•  &lt;main.lua:15&gt;
1 → → →     main.lua call •f2•  &lt;main.lua:11&gt;
2 → → →         main.lua call •f1•  &lt;main.lua:7&gt;
3 → → →             main.lua call •print•  [C]
4 → → →                 call •(unknown C)•  [C]
5 → → →                     return •(unknown C)•  [C]
Hello world!
4 → → →                 main.lua return •print•  [C]
3 → → →             main.lua return •f1•  &lt;main.lua:7&gt;
2 → → →         main.lua return •f2•  &lt;main.lua:11&gt;
1 → → →     main.lua return •f3•  &lt;main.lua:15&gt;
0 → → → main.lua call •module1_f3•  &lt;./module1.lua:9&gt;
1 → → →     ./module1.lua call •module1_f2•  &lt;./module1.lua:5&gt;
2 → → →         ./module1.lua call •module1_f1•  &lt;./module1.lua:1&gt;
3 → → →             ./module1.lua call •print•  [C]
4 → → →                 call •(unknown C)•  [C]
5 → → →                     return •(unknown C)•  [C]
Hello world from module1!
4 → → →                 ./module1.lua return •print•  [C]
3 → → →             ./module1.lua return •module1_f1•  &lt;./module1.lua:1&gt;
2 → → →         ./module1.lua return •module1_f2•  &lt;./module1.lua:5&gt;
1 → → →     main.lua return •module1_f3•  &lt;./module1.lua:9&gt;
0 → → → main.lua call •module2_f3•  &lt;./module2.lua:9&gt;
1 → → →     ./module2.lua call •module2_f2•  &lt;./module2.lua:5&gt;
2 → → →         ./module2.lua call •module2_f1•  &lt;./module2.lua:1&gt;
3 → → →             ./module2.lua call •module1_f3•  &lt;./module1.lua:9&gt;
4 → → →                 ./module1.lua call •module1_f2•  &lt;./module1.lua:5&gt;
5 → → →                     ./module1.lua call •module1_f1•  &lt;./module1.lua:1&gt;
6 → → →                         ./module1.lua call •print•  [C]
7 → → →                             call •(unknown C)•  [C]
8 → → →                                 return •(unknown C)•  [C]
Hello world from module1!
7 → → →                             ./module1.lua return •print•  [C]
6 → → →                         ./module1.lua return •module1_f1•  &lt;./module1.lua:1&gt;
5 → → →                     ./module1.lua return •module1_f2•  &lt;./module1.lua:5&gt;
4 → → →                 ./module2.lua return •module1_f3•  &lt;./module1.lua:9&gt;
3 → → →             ./module2.lua return •module2_f1•  &lt;./module2.lua:1&gt;
2 → → →         ./module2.lua return •module2_f2•  &lt;./module2.lua:5&gt;
1 → → →     main.lua return •module2_f3•  &lt;./module2.lua:9&gt;
0 → → → end main.lua
0 → → → return •(unknown C)•  [C]
</pre>



<p><a name="k06"></a></p>
<h2 id="k06">6. Problém s&nbsp;funkcí <strong>pcall</strong> při vzniku výjimky</h2>

<p>Na základě výstupu traceru, který jsme mohli vidět v&nbsp;předchozí
kapitole, by se mohlo zdát, že tracer pracuje bezchybně, ovšem ve skutečnosti
tomu tak není. Jeden z&nbsp;problémů vzniká při použití dvojice funkcí
<strong>pcall+error</strong>, což je dvojice speciálních funkcí sloužících
k&nbsp;vyvolání výjimky (<strong>error</strong>) a k&nbsp;jejímu zachycení
(<strong>pcall</strong>). Zmíněný problém spočívá v&nbsp;tom, že při vyvolání
výjimky se řízení ihned předá na volající <strong>pcall</strong> a nedojde tedy
ke vzniku události <i>return</i> (jinými slovy to znamená, že dvojice událostí
<i>call</i> a <i>return</i> nejsou vyvážené). Podívejme se na kód, který náš
tracer vyvede z&nbsp;míry:</p>

<h3>main2.lua</h3>

<pre>
<strong>local</strong> tracer = require("tracer")
require("module1")
require("module2")
&nbsp;
tracer.enable()
&nbsp;
<strong>function</strong> x()
    error("error")
<strong>end</strong>
&nbsp;
<strong>function</strong> pcall_x()
    pcall(x)
<strong>end</strong>
&nbsp;
<strong>for</strong> i=1,10 <strong>do</strong>
    pcall_x()
<strong>end</strong>
</pre>



<h3>Výsledky běhu třetího demonstračního příkladu (<strong>main2.lua</strong>)</h3>

<p>Po spuštění příkladu vidíme, že se výpočet úrovně zanoření provádí chybně
&ndash; při vyvolání výjimky pomocí <strong>error</strong> a jejím následném
zachycení v&nbsp;<strong>pcall</strong> by se úroveň zanoření funkcí měla
snížit o 3 a ne o 1:</p>

<pre>
0 → → → ./tracer.lua return •sethook•  [C]
0 → → → main2.lua return •enable•  &lt;./tracer.lua:96&gt;
0 → → → main2.lua call •pcall_x•  &lt;main2.lua:11&gt;
1 → → →     main2.lua call •pcall•  [C]
2 → → →         call •(unknown Lua)•  &lt;main2.lua:7&gt;
3 → → →             main2.lua call •error•  [C]
4 → → →                 main2.lua return •pcall•  [C]
3 → → →             main2.lua return •pcall_x•  &lt;main2.lua:11&gt;
2 → → →         main2.lua call •pcall_x•  &lt;main2.lua:11&gt;
3 → → →             main2.lua call •pcall•  [C]
4 → → →                 call •(unknown Lua)•  &lt;main2.lua:7&gt;
5 → → →                     main2.lua call •error•  [C]
6 → → →                         main2.lua return •pcall•  [C]
5 → → →                     main2.lua return •pcall_x•  &lt;main2.lua:11&gt;
4 → → →                 main2.lua call •pcall_x•  &lt;main2.lua:11&gt;
5 → → →                     main2.lua call •pcall•  [C]
6 → → →                         call •(unknown Lua)•  &lt;main2.lua:7&gt;
7 → → →                             main2.lua call •error•  [C]
8 → → →                                 main2.lua return •pcall•  [C]
7 → → →                             main2.lua return •pcall_x•  &lt;main2.lua:11&gt;
6 → → →                         main2.lua call •pcall_x•  &lt;main2.lua:11&gt;
7 → → →                             main2.lua call •pcall•  [C]
8 → → →                                 call •(unknown Lua)•  &lt;main2.lua:7&gt;
9 → → →                                     main2.lua call •error•  [C]
10 → → →                                         main2.lua return •pcall•  [C]
9 → → →                                     main2.lua return •pcall_x•  &lt;main2.lua:11&gt;
8 → → →                                 main2.lua call •pcall_x•  &lt;main2.lua:11&gt;
9 → → →                                     main2.lua call •pcall•  [C]
10 → → →                                         call •(unknown Lua)•  &lt;main2.lua:7&gt;
11 → → →                                             main2.lua call •error•  [C]
12 → → →                                                 main2.lua return •pcall•  [C]
11 → → →                                             main2.lua return •pcall_x•  &lt;main2.lua:11&gt;
10 → → →                                         main2.lua call •pcall_x•  &lt;main2.lua:11&gt;
11 → → →                                             main2.lua call •pcall•  [C]
12 → → →                                                 call •(unknown Lua)•  &lt;main2.lua:7&gt;
13 → → →                                                     main2.lua call •error•  [C]
14 → → →                                                         main2.lua return •pcall•  [C]
13 → → →                                                     main2.lua return •pcall_x•  &lt;main2.lua:11&gt;
12 → → →                                                 main2.lua call •pcall_x•  &lt;main2.lua:11&gt;
13 → → →                                                     main2.lua call •pcall•  [C]
14 → → →                                                         call •(unknown Lua)•  &lt;main2.lua:7&gt;
15 → → →                                                             main2.lua call •error•  [C]
16 → → →                                                                 main2.lua return •pcall•  [C]
15 → → →                                                             main2.lua return •pcall_x•  &lt;main2.lua:11&gt;
14 → → →                                                         main2.lua call •pcall_x•  &lt;main2.lua:11&gt;
15 → → →                                                             main2.lua call •pcall•  [C]
16 → → →                                                                 call •(unknown Lua)•  &lt;main2.lua:7&gt;
17 → → →                                                                     main2.lua call •error•  [C]
18 → → →                                                                         main2.lua return •pcall•  [C]
17 → → →                                                                     main2.lua return •pcall_x•  &lt;main2.lua:11&gt;
16 → → →                                                                 main2.lua call •pcall_x•  &lt;main2.lua:11&gt;
17 → → →                                                                     main2.lua call •pcall•  [C]
18 → → →                                                                         call •(unknown Lua)•  &lt;main2.lua:7&gt;
19 → → →                                                                             main2.lua call •error•  [C]
20 → → →                                                                                 main2.lua return •pcall•  [C]
19 → → →                                                                             main2.lua return •pcall_x•  &lt;main2.lua:11&gt;
18 → → →                                                                         main2.lua call •pcall_x•  &lt;main2.lua:11&gt;
19 → → →                                                                             main2.lua call •pcall•  [C]
20 → → →                                                                                 call •(unknown Lua)•  &lt;main2.lua:7&gt;
21 → → →                                                                                     main2.lua call •error•  [C]
22 → → →                                                                                         main2.lua return •pcall•  [C]
21 → → →                                                                                     main2.lua return •pcall_x•  &lt;main2.lua:11&gt;
20 → → →                                                                                 end main2.lua
19 → → →                                                                             return •(unknown C)•  [C]
</pre>



<p><a name="k07"></a></p>
<h2 id="k07">7. Čtvrtý demonstrační příklad: úprava trasování tak, aby se zajistilo zpracování <strong>pcall</strong></h2>

<p>Náprava zmíněného problému s&nbsp;výjimkami je relativně jednoduchá &ndash;
stačí zjistit, že se zavolala funkce <strong>pcall</strong>. V&nbsp;tomto
případě se aktuální úroveň zanoření zapamatuje v&nbsp;nové proměnné
<strong>tracer.pcall_level</strong> a při návratu z&nbsp;funkce
<strong>pcall</strong> dojde k&nbsp;obnovení proměnné
<strong>tracer.level</strong> na hodnotu zapamatovanou
v&nbsp;<strong>tracer.pcall_level</strong> (lepší by bylo použití zásobníku pro
zajištění vnořených <strong>pcall</strong>, v&nbsp;praxi to však nebude
nezbytné). Poslední verze traceru tedy vypadá takto:</p>

<h3>tracer.lua</h3>

<pre>
<i>--</i>
<i>-- Lua tracer v.4</i>
<i>--</i>
<strong>local</strong> tracer = {
    level=0,
    pcall_level=0
}
&nbsp;
&nbsp;
&nbsp;
<i>--</i>
<i>-- Update trace level (for a bit nicer output).</i>
<i>--</i>
<strong>function</strong> tracer.updateTraceLevel(debugInfo, event)
    <i>-- decision between calling a function or returning from the function</i>
    <strong>if</strong> event == "call" <strong>then</strong>
        tracer.level = tracer.level + 1
    <strong>else</strong>
        tracer.level = tracer.level - 1
        <strong>if</strong> tracer.level &lt; 0 <strong>then</strong>
            tracer.level = 0
        <strong>end</strong>
    <strong>end</strong>
<strong>end</strong>
&nbsp;
&nbsp;
&nbsp;
<i>--</i>
<i>-- Call of pcall() function needs special handling, because</i>
<i>-- error() would break normal call-return flow.</i>
<i>-- (even better would be to use a user-defined stack instead of pcall_level)</i>
<i>--</i>
<strong>function</strong> tracer.handlePcall(debugInfo, event)
    <strong>if</strong> debugInfo.what == "C" and debugInfo.name == "pcall" <strong>then</strong>
        <strong>if</strong> event == "call" <strong>then</strong>
            tracer.pcall_level = tracer.level
        <strong>else</strong>
            tracer.level = tracer.pcall_level+1
        <strong>end</strong>
    <strong>end</strong>
<strong>end</strong>
&nbsp;
&nbsp;
&nbsp;
<i>--</i>
<i>-- Format information about the Lua function call.</i>
<i>--</i>
<strong>function</strong> tracer.formatLuaCall(event, debugInfo)
    <strong>return </strong>" " .. event .. " •" .. (debugInfo.name or "(unknown Lua)")
           .. "•"
           .. "  &lt;" .. debugInfo.short_src .. ":" .. debugInfo.linedefined .. "&gt;"
<strong>end</strong>
&nbsp;
&nbsp;
&nbsp;
<i>--</i>
<i>-- Format information about C function call.</i>
<i>--</i>
<strong>function</strong> tracer.formatCCall(event, debugInfo)
    <strong>return </strong>" " .. event .. " •" .. (debugInfo.name or "(unknown C)")
           .. "•"
           .. "  [" .. debugInfo.what .. "]"
<strong>end</strong>
&nbsp;
&nbsp;
&nbsp;
<i>--</i>
<i>-- Event handler called from Lua VM.</i>
<i>--</i>
<strong>function</strong> tracer.eventHandler(event)
    <strong>local</strong> output = ""
&nbsp;
    <strong>local</strong> debugInfo = debug.getinfo(3)
&nbsp;
    <strong>local</strong> output = tracer.level .. " → → → " .. string.rep("    ", tracer.level)
&nbsp;
    <strong>if</strong> debugInfo and debugInfo.currentline &gt;= 0 <strong>then</strong>
        output = output .. debugInfo.short_src, ":" .. debugInfo.currentline .. " "
    <strong>end</strong>
&nbsp;
    <strong>local</strong> debugInfo = debug.getinfo(2)
&nbsp;
    tracer.handlePcall(debugInfo, event)
    tracer.updateTraceLevel(debugInfo, event)
&nbsp;
    <i>-- 'what' attribute could have the following values:</i>
    <i>--    "Lua"  for regular Lua functions</i>
    <i>--    "C"    for C function</i>
    <i>--    "main" for the main part of a Lua chunk.</i>
    <strong>if</strong> debugInfo.what == "main" <strong>then</strong>
        <strong>if</strong> event == "call" <strong>then</strong>
            output = output .. "begin " .. debugInfo.short_src
        <strong>else</strong>
            output = output .. "end " .. debugInfo.short_src
        <strong>end</strong>
    <i>-- regular Lua function call</i>
    <strong>elseif</strong> debugInfo.what == "Lua" <strong>then</strong>
        output = output .. tracer.formatLuaCall(event, debugInfo)
    <i>-- C (native) function call</i>
    <strong>elseif</strong> debugInfo.what == "C" <strong>then</strong>
        output = output .. tracer.formatCCall(event, debugInfo)
    <i>-- should not happen :)</i>
    <strong>else</strong>
        output = output .. " unknown!"
    <strong>end</strong>
    print(output)
<strong>end</strong>
&nbsp;
&nbsp;
&nbsp;
<i>--</i>
<i>-- Register event handler for the "call" and "return" events.</i>
<i>--</i>
<strong>function</strong> tracer.enable()
    <i>-- we want to call event handler for the following events:</i>
    <i>-- "call"</i>
    <i>-- "return"</i>
    debug.sethook(tracer.eventHandler, "cr")
<strong>end</strong>
&nbsp;
&nbsp;
&nbsp;
<strong>return </strong>tracer
</pre>



<h3>Výsledky běhu čtvrtého demonstračního příkladu (<strong>main.lua</strong>)</h3>

<p>Otestujme si nový tracer na původním modulu <strong>main.lua</strong>. Zde
se nevolá ani <strong>pcall()</strong> ani <strong>error()</strong>, takže
podle očekávání se funkcionalita nijak nezmění:</p>

<pre>
0 → → → ./tracer.lua return •sethook•  [C]
0 → → → main.lua return •enable•  &lt;./tracer.lua:114&gt;
0 → → → main.lua call •f3•  &lt;main.lua:15&gt;
1 → → →     main.lua call •f2•  &lt;main.lua:11&gt;
2 → → →         main.lua call •f1•  &lt;main.lua:7&gt;
3 → → →             main.lua call •print•  [C]
4 → → →                 call •(unknown C)•  [C]
5 → → →                     return •(unknown C)•  [C]
Hello world!
4 → → →                 main.lua return •print•  [C]
3 → → →             main.lua return •f1•  &lt;main.lua:7&gt;
2 → → →         main.lua return •f2•  &lt;main.lua:11&gt;
1 → → →     main.lua return •f3•  &lt;main.lua:15&gt;
0 → → → main.lua call •module1_f3•  &lt;./module1.lua:9&gt;
1 → → →     ./module1.lua call •module1_f2•  &lt;./module1.lua:5&gt;
2 → → →         ./module1.lua call •module1_f1•  &lt;./module1.lua:1&gt;
3 → → →             ./module1.lua call •print•  [C]
4 → → →                 call •(unknown C)•  [C]
5 → → →                     return •(unknown C)•  [C]
Hello world from module1!
4 → → →                 ./module1.lua return •print•  [C]
3 → → →             ./module1.lua return •module1_f1•  &lt;./module1.lua:1&gt;
2 → → →         ./module1.lua return •module1_f2•  &lt;./module1.lua:5&gt;
1 → → →     main.lua return •module1_f3•  &lt;./module1.lua:9&gt;
0 → → → main.lua call •module2_f3•  &lt;./module2.lua:9&gt;
1 → → →     ./module2.lua call •module2_f2•  &lt;./module2.lua:5&gt;
2 → → →         ./module2.lua call •module2_f1•  &lt;./module2.lua:1&gt;
3 → → →             ./module2.lua call •module1_f3•  &lt;./module1.lua:9&gt;
4 → → →                 ./module1.lua call •module1_f2•  &lt;./module1.lua:5&gt;
5 → → →                     ./module1.lua call •module1_f1•  &lt;./module1.lua:1&gt;
6 → → →                         ./module1.lua call •print•  [C]
7 → → →                             call •(unknown C)•  [C]
8 → → →                                 return •(unknown C)•  [C]
Hello world from module1!
7 → → →                             ./module1.lua return •print•  [C]
6 → → →                         ./module1.lua return •module1_f1•  &lt;./module1.lua:1&gt;
5 → → →                     ./module1.lua return •module1_f2•  &lt;./module1.lua:5&gt;
4 → → →                 ./module2.lua return •module1_f3•  &lt;./module1.lua:9&gt;
3 → → →             ./module2.lua return •module2_f1•  &lt;./module2.lua:1&gt;
2 → → →         ./module2.lua return •module2_f2•  &lt;./module2.lua:5&gt;
1 → → →     main.lua return •module2_f3•  &lt;./module2.lua:9&gt;
0 → → → end main.lua
0 → → → return •(unknown C)•  [C]
</pre>



<h3>Výsledky běhu čtvrtého demonstračního příkladu (<strong>main2.lua</strong>)</h3>

<p>Zajímavější bude test traceru s&nbsp;modulem <strong>main2.lua</strong>, kde
se vyvolávají a zachycují výjimky. Povšimněte si korektního přeskoku ze čtvrté
úrovně na úroveň první, například na řádku 7:</p>

<pre>
0 → → → ./tracer.lua return •sethook•  [C]
0 → → → main2.lua return •enable•  &lt;./tracer.lua:114&gt;
0 → → → main2.lua call •pcall_x•  &lt;main2.lua:11&gt;
1 → → →     main2.lua call •pcall•  [C]
2 → → →         call •(unknown Lua)•  &lt;main2.lua:7&gt;
3 → → →             main2.lua call •error•  [C]
4 → → →                 main2.lua return •pcall•  [C]
1 → → →     main2.lua return •pcall_x•  &lt;main2.lua:11&gt;
0 → → → main2.lua call •pcall_x•  &lt;main2.lua:11&gt;
1 → → →     main2.lua call •pcall•  [C]
2 → → →         call •(unknown Lua)•  &lt;main2.lua:7&gt;
3 → → →             main2.lua call •error•  [C]
4 → → →                 main2.lua return •pcall•  [C]
1 → → →     main2.lua return •pcall_x•  &lt;main2.lua:11&gt;
0 → → → main2.lua call •pcall_x•  &lt;main2.lua:11&gt;
1 → → →     main2.lua call •pcall•  [C]
2 → → →         call •(unknown Lua)•  &lt;main2.lua:7&gt;
3 → → →             main2.lua call •error•  [C]
4 → → →                 main2.lua return •pcall•  [C]
1 → → →     main2.lua return •pcall_x•  &lt;main2.lua:11&gt;
0 → → → main2.lua call •pcall_x•  &lt;main2.lua:11&gt;
1 → → →     main2.lua call •pcall•  [C]
2 → → →         call •(unknown Lua)•  &lt;main2.lua:7&gt;
3 → → →             main2.lua call •error•  [C]
4 → → →                 main2.lua return •pcall•  [C]
1 → → →     main2.lua return •pcall_x•  &lt;main2.lua:11&gt;
0 → → → main2.lua call •pcall_x•  &lt;main2.lua:11&gt;
1 → → →     main2.lua call •pcall•  [C]
2 → → →         call •(unknown Lua)•  &lt;main2.lua:7&gt;
3 → → →             main2.lua call •error•  [C]
4 → → →                 main2.lua return •pcall•  [C]
1 → → →     main2.lua return •pcall_x•  &lt;main2.lua:11&gt;
0 → → → main2.lua call •pcall_x•  &lt;main2.lua:11&gt;
1 → → →     main2.lua call •pcall•  [C]
2 → → →         call •(unknown Lua)•  &lt;main2.lua:7&gt;
3 → → →             main2.lua call •error•  [C]
4 → → →                 main2.lua return •pcall•  [C]
1 → → →     main2.lua return •pcall_x•  &lt;main2.lua:11&gt;
0 → → → main2.lua call •pcall_x•  &lt;main2.lua:11&gt;
1 → → →     main2.lua call •pcall•  [C]
2 → → →         call •(unknown Lua)•  &lt;main2.lua:7&gt;
3 → → →             main2.lua call •error•  [C]
4 → → →                 main2.lua return •pcall•  [C]
1 → → →     main2.lua return •pcall_x•  &lt;main2.lua:11&gt;
0 → → → main2.lua call •pcall_x•  &lt;main2.lua:11&gt;
1 → → →     main2.lua call •pcall•  [C]
2 → → →         call •(unknown Lua)•  &lt;main2.lua:7&gt;
3 → → →             main2.lua call •error•  [C]
4 → → →                 main2.lua return •pcall•  [C]
1 → → →     main2.lua return •pcall_x•  &lt;main2.lua:11&gt;
0 → → → main2.lua call •pcall_x•  &lt;main2.lua:11&gt;
1 → → →     main2.lua call •pcall•  [C]
2 → → →         call •(unknown Lua)•  &lt;main2.lua:7&gt;
3 → → →             main2.lua call •error•  [C]
4 → → →                 main2.lua return •pcall•  [C]
1 → → →     main2.lua return •pcall_x•  &lt;main2.lua:11&gt;
0 → → → main2.lua call •pcall_x•  &lt;main2.lua:11&gt;
1 → → →     main2.lua call •pcall•  [C]
2 → → →         call •(unknown Lua)•  &lt;main2.lua:7&gt;
3 → → →             main2.lua call •error•  [C]
4 → → →                 main2.lua return •pcall•  [C]
1 → → →     main2.lua return •pcall_x•  &lt;main2.lua:11&gt;
0 → → → end main2.lua
0 → → → return •(unknown C)•  [C]
</pre>

<p>Otázka pro čtenáře: je nyní tracer korektní pro všechny možné případy, které
mohou v&nbsp;Lue nastat, nebo může dojít k&nbsp;situaci, kdy se bude špatně
vyhodnocovat buď volání funkce nebo návrat z&nbsp;funkce?</p>



<p><a name="k08"></a></p>
<h2 id="k08">8. Repositář s&nbsp;demonstračními příklady</h2>

<p>Všechny čtyři dnes popsané demonstrační příklady byly, podobně jako
v&nbsp;některých předchozích částech tohoto seriálu, uloženy do Git repositáře
dostupného na adrese <a
href="https://github.com/tisnik/luajit-examples">https://github.com/tisnik/luajit-examples</a>.
V&nbsp;tabulce zobrazené pod tímto odstavcem naleznete na zdrojové kódy
jednotlivých demonstračních příkladů přímé odkazy:</p>

<table>
<tr><th>#</th><th>Příklad</th><th>URL</th></tr>
<tr><td>1</td><td>debug_example1</td><td><a href="https://github.com/tisnik/luajit-examples/tree/master/debug/debug_example1">https://github.com/tisnik/luajit-examples/tree/master/debug/debug_example1</a></td></tr>
<tr><td>2</td><td>debug_example2</td><td><a href="https://github.com/tisnik/luajit-examples/tree/master/debug/debug_example2">https://github.com/tisnik/luajit-examples/tree/master/debug/debug_example2</a></td></tr>
<tr><td>3</td><td>debug_example3</td><td><a href="https://github.com/tisnik/luajit-examples/tree/master/debug/debug_example3">https://github.com/tisnik/luajit-examples/tree/master/debug/debug_example3</a></td></tr>
<tr><td>4</td><td>debug_example4</td><td><a href="https://github.com/tisnik/luajit-examples/tree/master/debug/debug_example4">https://github.com/tisnik/luajit-examples/tree/master/debug/debug_example4</a></td></tr>
</table>



<p><a name="k09"></a></p>
<h2 id="k09">9. Odkazy na Internetu</h2>

<ol>

<li>Programming in Lua: 23 - The Debug Library<br />
<a href="http://www.lua.org/pil/23.html">http://www.lua.org/pil/23.html</a>
</li>

<li>Programming in Lua: 23.1 - Introspective Facilities<br />
<a href="http://www.lua.org/pil/23.1.html">http://www.lua.org/pil/23.1.html</a>
</li>

<li>Programming in Lua: 23.2 - Hooks<br />
<a href="http://www.lua.org/pil/23.2.html">http://www.lua.org/pil/23.2.html</a>
</li>

<li>Lua 5.2 Reference Manual: 6.10 - The Debug Library<br />
<a href="http://www.lua.org/manual/5.2/manual.html#6.10">http://www.lua.org/manual/5.2/manual.html#6.10</a>
</li>

<li>Factorial (Rosetta Code)<br />
<a href="http://rosettacode.org/wiki/Factorial#Lua">http://rosettacode.org/wiki/Factorial#Lua</a>
</li>

<li>Lua Profiler (GitHub)<br />
<a href="https://github.com/luaforge/luaprofiler">https://github.com/luaforge/luaprofiler</a>
</li>

<li>Lua Profiler (LuaForge)<br />
<a href="http://luaforge.net/projects/luaprofiler/">http://luaforge.net/projects/luaprofiler/</a>
</li>

<li>ctrace<br />
<a href="http://webserver2.tecgraf.puc-rio.br/~lhf/ftp/lua/">http://webserver2.tecgraf.puc-rio.br/~lhf/ftp/lua/</a>
</li>

<li>LuaJIT - Just in Time překladač pro programovací jazyk Lua<br />
<a href="http://www.root.cz/clanky/luajit-just-in-time-prekladac-pro-programovaci-jazyk-lua/">http://www.root.cz/clanky/luajit-just-in-time-prekladac-pro-programovaci-jazyk-lua/</a>
</li>

<li>LuaJIT - Just in Time překladač pro programovací jazyk Lua (2)<br />
<a href="http://www.root.cz/clanky/luajit-just-in-time-prekladac-pro-programovaci-jazyk-lua-2/">http://www.root.cz/clanky/luajit-just-in-time-prekladac-pro-programovaci-jazyk-lua-2/</a>
</li>

<li>LuaJIT - Just in Time překladač pro programovací jazyk Lua (3)<br />
<a href="http://www.root.cz/clanky/luajit-just-in-time-prekladac-pro-programovaci-jazyk-lua-3/">http://www.root.cz/clanky/luajit-just-in-time-prekladac-pro-programovaci-jazyk-lua-3/</a>
</li>

<li>LuaJIT - Just in Time překladač pro programovací jazyk Lua (4)<br />
<a href="http://www.root.cz/clanky/luajit-just-in-time-prekladac-pro-programovaci-jazyk-lua-4/">http://www.root.cz/clanky/luajit-just-in-time-prekladac-pro-programovaci-jazyk-lua-4/</a>
</li>

<li>LuaJIT - Just in Time překladač pro programovací jazyk Lua (5 - tabulky a pole)<br />
<a href="http://www.root.cz/clanky/luajit-just-in-time-prekladac-pro-programovaci-jazyk-lua-5-tabulky-a-pole/">http://www.root.cz/clanky/luajit-just-in-time-prekladac-pro-programovaci-jazyk-lua-5-tabulky-a-pole/</a>
</li>

<li>LuaJIT - Just in Time překladač pro programovací jazyk Lua (6 - překlad programových smyček do mezijazyka LuaJITu)<br />
<a href="http://www.root.cz/clanky/luajit-just-in-time-prekladac-pro-programovaci-jazyk-lua-6-preklad-programovych-smycek-do-mezijazyka-luajitu/">http://www.root.cz/clanky/luajit-just-in-time-prekladac-pro-programovaci-jazyk-lua-6-preklad-programovych-smycek-do-mezijazyka-luajitu/</a>
</li>

<li>LuaJIT - Just in Time překladač pro programovací jazyk Lua (7 - dokončení popisu mezijazyka LuaJITu)<br />
<a href="http://www.root.cz/clanky/luajit-just-in-time-prekladac-pro-programovaci-jazyk-lua-7-dokonceni-popisu-mezijazyka-luajitu/">http://www.root.cz/clanky/luajit-just-in-time-prekladac-pro-programovaci-jazyk-lua-7-dokonceni-popisu-mezijazyka-luajitu/</a>
</li>

<li>LuaJIT - Just in Time překladač pro programovací jazyk Lua (8 - základní vlastnosti trasovacího JITu)<br />
<a href="http://www.root.cz/clanky/luajit-just-in-time-prekladac-pro-programovaci-jazyk-lua-8-zakladni-vlastnosti-trasovaciho-jitu/">http://www.root.cz/clanky/luajit-just-in-time-prekladac-pro-programovaci-jazyk-lua-8-zakladni-vlastnosti-trasovaciho-jitu/</a>
</li>

<li>LuaJIT - Just in Time překladač pro programovací jazyk Lua (9 - další vlastnosti trasovacího JITu)<br />
<a href="http://www.root.cz/clanky/luajit-just-in-time-prekladac-pro-programovaci-jazyk-lua-9-dalsi-vlastnosti-trasovaciho-jitu/">http://www.root.cz/clanky/luajit-just-in-time-prekladac-pro-programovaci-jazyk-lua-9-dalsi-vlastnosti-trasovaciho-jitu/</a>
</li>

<li>LuaJIT - Just in Time překladač pro programovací jazyk Lua (10 - JIT překlad do nativního kódu)<br />
<a href="http://www.root.cz/clanky/luajit-just-in-time-prekladac-pro-programovaci-jazyk-lua-10-jit-preklad-do-nativniho-kodu/">http://www.root.cz/clanky/luajit-just-in-time-prekladac-pro-programovaci-jazyk-lua-10-jit-preklad-do-nativniho-kodu/</a>
</li>

<li>LuaJIT - Just in Time překladač pro programovací jazyk Lua (11 - JIT překlad do nativního kódu procesorů s architekturami x86 a ARM)<br />
<a href="http://www.root.cz/clanky/luajit-just-in-time-prekladac-pro-programovaci-jazyk-lua-11-jit-preklad-do-nativniho-kodu-procesoru-s-architekturami-x86-a-arm/">http://www.root.cz/clanky/luajit-just-in-time-prekladac-pro-programovaci-jazyk-lua-11-jit-preklad-do-nativniho-kodu-procesoru-s-architekturami-x86-a-arm/</a>
</li>

<li>LuaJIT - Just in Time překladač pro programovací jazyk Lua (12 - překlad operací s reálnými čísly)<br />
<a href="http://www.root.cz/clanky/luajit-just-in-time-prekladac-pro-programovaci-jazyk-lua-12-preklad-operaci-s-realnymi-cisly/">http://www.root.cz/clanky/luajit-just-in-time-prekladac-pro-programovaci-jazyk-lua-12-preklad-operaci-s-realnymi-cisly/</a>
</li>

<li>The Lua VM, on the Web<br />
<a href="https://kripken.github.io/lua.vm.js/lua.vm.js.html">https://kripken.github.io/lua.vm.js/lua.vm.js.html</a>
</li>

<li>Lua.vm.js REPL<br />
<a href="https://kripken.github.io/lua.vm.js/repl.html">https://kripken.github.io/lua.vm.js/repl.html</a>
</li>

<li>lua2js<br />
<a href="https://www.npmjs.com/package/lua2js">https://www.npmjs.com/package/lua2js</a>
</li>

<li>lua2js na GitHubu<br />
<a href="https://github.com/basicer/lua2js-dist">https://github.com/basicer/lua2js-dist</a>
</li>

<li>Seriál o programovacím jazyku Lua<br />
<a href="http://www.root.cz/serialy/programovaci-jazyk-lua/">http://www.root.cz/serialy/programovaci-jazyk-lua/</a>
</li>

<li>Source-to-source compiler<br />
<a href="https://en.wikipedia.org/wiki/Source-to-source_compiler">https://en.wikipedia.org/wiki/Source-to-source_compiler</a>
</li>

<li>JavaScript is Assembly Language for the Web: Sematic Markup is Dead! Clean vs. Machine-coded HTML<br />
<a href="http://www.hanselman.com/blog/JavaScriptIsAssemblyLanguageForTheWebSematicMarkupIsDeadCleanVsMachinecodedHTML.aspx">http://www.hanselman.com/blog/JavaScriptIsAssemblyLanguageForTheWebSematicMarkupIsDeadCleanVsMachinecodedHTML.aspx</a>
</li>

<li>JavaScript is Web Assembly Language and that's OK.<br />
<a href="http://www.hanselman.com/blog/JavaScriptIsWebAssemblyLanguageAndThatsOK.aspx">http://www.hanselman.com/blog/JavaScriptIsWebAssemblyLanguageAndThatsOK.aspx</a>
</li>

<li>Dart<br />
<a href="https://www.dartlang.org/">https://www.dartlang.org/</a>
</li>

<li>CoffeeScript<br />
<a href="http://coffeescript.org/">http://coffeescript.org/</a>
</li>

<li>TypeScript<br />
<a href="http://www.typescriptlang.org/">http://www.typescriptlang.org/</a>
</li>

<li>Lua (programming language)<br />
<a href="http://en.wikipedia.org/wiki/Lua_(programming_language)">http://en.wikipedia.org/wiki/Lua_(programming_language)</a>
</li>

<li>Static single assignment form (SSA)<br />
<a href="http://en.wikipedia.org/wiki/Static_single_assignment_form">http://en.wikipedia.org/wiki/Static_single_assignment_form</a>
</li>

<li>Wikipedia: Mezijazyk<br />
<a href="http://cs.wikipedia.org/wiki/Mezijazyk">http://cs.wikipedia.org/wiki/Mezijazyk</a>
</li>

<li>LuaJIT 2.0 SSA IR
<a href="http://wiki.luajit.org/SSA-IR-2.0">http://wiki.luajit.org/SSA-IR-2.0</a>
</li>

<li>The LuaJIT Project<br />
<a href="http://luajit.org/index.html">http://luajit.org/index.html</a>
</li>

<li>LuaJIT FAQ<br />
<a href="http://luajit.org/faq.html">http://luajit.org/faq.html</a>
</li>

<li>LuaJIT Performance Comparison<br />
<a href="http://luajit.org/performance.html">http://luajit.org/performance.html</a>
</li>

<li>LuaJIT 2.0 intellectual property disclosure and research opportunities<br />
<a href="http://article.gmane.org/gmane.comp.lang.lua.general/58908">http://article.gmane.org/gmane.comp.lang.lua.general/58908</a>
</li>

<li>LuaJIT Wiki<br />
<a href="http://wiki.luajit.org/Home">http://wiki.luajit.org/Home</a>
</li>

<li>LuaJIT 2.0 Bytecode Instructions<br />
<a href="http://wiki.luajit.org/Bytecode-2.0">http://wiki.luajit.org/Bytecode-2.0</a>
</li>

<li>Programming in Lua (first edition)<br />
<a href="http://www.lua.org/pil/contents.html">http://www.lua.org/pil/contents.html</a>
</li>

<li>Lua 5.2 sources<br />
<a href="http://www.lua.org/source/5.2/">http://www.lua.org/source/5.2/</a>
</li>

<li>Tcl Plugin Version 3<br />
<a href="http://www.tcl.tk/software/plugin/">http://www.tcl.tk/software/plugin/</a>
</li>

<li>JavaScript: The Web Assembly Language?<br />
<a href="http://www.informit.com/articles/article.aspx?p=1856657">http://www.informit.com/articles/article.aspx?p=1856657</a>
</li>

<li>asm.js<br />
<a href="http://asmjs.org/">http://asmjs.org/</a>
</li>

<li>List of languages that compile to JS<br />
<a href="https://github.com/jashkenas/coffeescript/wiki/List-of-languages-that-compile-to-JS">https://github.com/jashkenas/coffeescript/wiki/List-of-languages-that-compile-to-JS</a>
</li>

<li>REPL<br />
<a href="https://en.wikipedia.org/wiki/Read%E2%80%93eval%E2%80%93print_loop">https://en.wikipedia.org/wiki/Read%E2%80%93eval%E2%80%93print_loop</a>
</li>

<li>The LLVM Compiler Infrastructure<br />
<a href="http://llvm.org/ProjectsWithLLVM/">http://llvm.org/ProjectsWithLLVM/</a>
</li>

<li>clang: a C language family frontend for LLVM<br />
<a href="http://clang.llvm.org/">http://clang.llvm.org/</a>
</li>

<li>emscripten<br />
<a href="http://kripken.github.io/emscripten-site/">http://kripken.github.io/emscripten-site/</a>
</li>

<li>LLVM Backend ("Fastcomp")<br />
<a href="http://kripken.github.io/emscripten-site/docs/building_from_source/LLVM-Backend.html#llvm-backend">http://kripken.github.io/emscripten-site/docs/building_from_source/LLVM-Backend.html#llvm-backend</a>
</li>

<li>Emscripten - Fastcomp na GitHubu<br />
<a href="https://github.com/kripken/emscripten-fastcomp">https://github.com/kripken/emscripten-fastcomp</a>
</li>

<li>Clang (pro Emscripten) na GitHubu<br />
<a href="https://github.com/kripken/emscripten-fastcomp-clang">https://github.com/kripken/emscripten-fastcomp-clang</a>
</li>

<li>Why not use JavaScript?<br />
<a href="https://ckknight.github.io/gorillascript/">https://ckknight.github.io/gorillascript/</a>
</li>

<li>Lambda the Ultimate: Coroutines in Lua,<br />
<a href="http://lambda-the-ultimate.org/node/438">http://lambda-the-ultimate.org/node/438</a>
</li>

<li>Coroutines Tutorial,<br />
<a href="http://lua-users.org/wiki/CoroutinesTutorial">http://lua-users.org/wiki/CoroutinesTutorial</a>
</li>

<li>Lua Coroutines Versus Python Generators,<br />
<a href="http://lua-users.org/wiki/LuaCoroutinesVersusPythonGenerators">http://lua-users.org/wiki/LuaCoroutinesVersusPythonGenerators</a>
</li>

</ol>



<p></p><p></p>
<p><small>Autor: <a href="http://www.fit.vutbr.cz/~tisnovpa">Pavel Tišnovský</a> &nbsp; 2015</small></p>
</body>
</html>

