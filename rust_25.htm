<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
        "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html>
<head>
<title>Programovací jazyk Rust: spouštění nových procesů a komunikace s nimi</title>
<meta name="Author" content="Pavel Tisnovsky" />
<meta name="Generator" content="vim" />
<meta http-equiv="content-type" content="text/html; charset=utf-8" />
<style type="text/css">
         body {color:#000000; background:#ffffff;}
         h1  {font-family: arial, helvetica, sans-serif; color:#ffffff; background-color:#c00000; text-align:center; padding-left:1em}
         h2  {font-family: arial, helvetica, sans-serif; color:#ffffff; background-color:#0000c0; padding-left:1em; text-align:left}
         h3  {font-family: arial, helvetica, sans-serif; color:#000000; background-color:#c0c0c0; padding-left:1em; text-align:left}
         h4  {font-family: arial, helvetica, sans-serif; color:#000000; background-color:#e0e0e0; padding-left:1em; text-align:left}
         a   {font-family: arial, helvetica, sans-serif;}
         li  {font-family: arial, helvetica, sans-serif; color:#000000; text-align:justify; width:450px;}
         ol  {font-family: arial, helvetica, sans-serif; color:#000000; text-align:justify; width:450px;}
         ul  {font-family: arial, helvetica, sans-serif; color:#000000; text-align:justify; width:450px;}
         p   {font-family: arial, helvetica, sans-serif; color:#000000; text-align:justify;}
         pre {background:#e0e0e0}
</style>
</head>

<body>

<h1>Programovací jazyk Rust: spouštění nových procesů a komunikace s nimi</h1>

<h3>Pavel Tišnovský</h3>

<p></p>

<h1>Úvodník</h1>

<p>Ve dvacáté páté části seriálu o programovacím jazyku Rust si ukážeme, jakým způsobem je možné spustit nový proces, předat mu argumenty, upravit proměnné prostředí a také to, jak lze s&nbsp;tímto procesem komunikovat přes vstupně/výstupní proudy (streamy).</p>



<h2>Obsah</h2>

<p><a href="#k01">1. Programovací jazyk Rust: spouštění nových procesů a komunikace s nimi</a></p>
<p><a href="#k02">2. Postup při spouštění nového procesu</a></p>
<p><a href="#k03">3. Příklad: vytvoření nového procesu s&nbsp;čekáním na jeho dokončení</a></p>
<p><a href="#k04">4. Reakce na chybu při pokusu o vytvoření nového procesu</a></p>
<p><a href="#k05">5. Předání argumentu nově vytvářenému procesu</a></p>
<p><a href="#k06">6. Předání více argumentů spouštěnému procesu</a></p>
<p><a href="#k07">7. Návratová hodnota procesu</a></p>
<p><a href="#k08">8. Argumenty procesu předané pomocí vektoru</a></p>
<p><a href="#k09">9. Pokus o spuštění lokálního skriptu</a></p>
<p><a href="#k10">10. Nastavení proměnných prostředí pro nově vznikající proces</a></p>
<p><a href="#k11">11. Odstranění vybrané proměnné prostředí</a></p>
<p><a href="#k12">12. Převzetí dat posílaných procesem na standardní výstup</a></p>
<p><a href="#k13">13. Repositář s&nbsp;demonstračními příklady</a></p>
<p><a href="#k14">14. Odkazy na Internetu</a></p>



<p><a name="k01"></a></p>
<h2 id="k01">1. Programovací jazyk Rust: spouštění nových procesů a komunikace s nimi</h2>

<p>Pro spouštění procesů a základní komunikaci s&nbsp;nimi se používá několik
struktur:</p>

<table>
<tr><th>Struktura</th><th>Význam</th></tr>
<tr><td><a href="https://doc.rust-lang.org/std/process/struct.Command.html">std::process::Command</a></td><td>reprezentuje příkaz sloužící pro spuštění procesu</td></tr>
<tr><td><a href="https://doc.rust-lang.org/std/process/struct.Child.html">std::process::Child</a></td><td>reprezentuje spuštěný nebo již zastavený proces</td></tr>
<tr><td><a href="https://doc.rust-lang.org/std/process/struct.ExitStatus.html">std::process::ExitStatus</a></td><td>výsledek po zastavení procesu (jakýmkoli způsobem)</td></tr>
<tr><td><a href="https://doc.rust-lang.org/std/process/struct.ChildStdin.html">std::process::ChildStdin</a></td><td>vstupní proud spuštěného procesu</td></tr>
<tr><td><a href="https://doc.rust-lang.org/std/process/struct.ChildStdout.html">std::process::ChildStdout</a></td><td>výstupní proud spuštěného procesu</td></tr>
<tr><td><a href="https://doc.rust-lang.org/std/process/struct.ChildStderr.html">std::process::ChildStderr</a></td><td>chybový proud spuštěného procesu</td></tr>
</table>



<p><a name="k02"></a></p>
<h2 id="k02">2. Postup při spouštění nového procesu</h2>

<p>Před vytvořením nového procesu je nutné získat strukturu typu
<strong>Command</strong>, která reprezentuje příkaz, jenž se má spustit, dále
pak argumenty tohoto příkazu a v&nbsp;neposlední řadě také proměnné prostředí.
Tato struktura, resp.&nbsp;přesněji řečeno její základní podoba, se získá
konstruktorem <strong>new</strong>, kterému se předá jméno spouštěného
příkazu:</p>

<pre>
let command = Command::new("ls");
</pre>

<p>Samotný proces se spustí metodou <strong>spawn</strong> vracející typ
Result&lt;Child&gt;. Většinou se vytvoření příkazu kombinuje s&nbsp;jeho
spuštěním na jeden programový řádek:</p>

<pre>
let process = Command::new("ls").spawn();
</pre>

<p>Pokud je zapotřebí čekat na dokončení spuštěného procesu, použije se metoda
<strong>Child.wait()</strong> vracející hodnotu typu
<strong>Result&lt;ExitStatus&gt;</strong>. Samotná struktura
<strong>ExitStatus</strong> obsahuje jak návratový kód, tak i další užitečné
informace o ukončeném procesu.</p>



<p><a name="k03"></a></p>
<h2 id="k03">3. Příklad: vytvoření nového procesu s&nbsp;čekáním na jeho dokončení</h2>

<p>Podívejme se nyní na způsob použití výše popsaných metod
<strong>Command.spawn()</strong> a <strong>Child.wait()</strong>
v&nbsp;příkladu, který spustí externí příkaz <strong>ls</strong> a následně
vypíše návratový kód i další informace o právě ukončeném příkazu. Pro reakci na
všechny případné chyby a pro získání hodnot obalených do typu
<strong>Result</strong> je použit oblíbený pattern matching. Navíc si
povšimněte modifikátoru <strong>mut</strong>, který je kvůli volání
<strong>child.wait()</strong> vyžadován:</p>

<pre>
use std::process::Command;
&nbsp;
fn main() {
    let process = <strong>Command::new("ls").spawn()</strong>;
&nbsp;
    match process {
        Ok(<strong>mut</strong> child) =&gt; {
            println!("spawn ok");
            match <strong>child.wait()</strong> {
                Ok(code) =&gt; {
                    println!("process exited with code: {}", code);
                }
                Err(err) =&gt; {
                    println!("failed to wait on child: {}", err);
                }
            }
        }
        Err(err) =&gt; {
            println!("spawn error: {}", err);
        }
    }
&nbsp;
}
</pre>

<p>Po překladu byl program spuštěn v&nbsp;adresáři se všemi dnešními
demonstračními příklady, takže se po spuštění vypsaly následující informace
(tučně jsou zvýrazněny informace psané našim programem, nikoli příkazem
<strong>ls</strong>):</p>

<pre>
<strong>spawn ok</strong>
308_spawn_process            308_spawn_process.rs
308.txt                      309_spawn_error.rs
310_process_arg.rs           311_process_args.rs
312_bad_directory.rs         313_process_args_in_vector.rs
314_local_script_error.rs    315_process_env_vars.rs
316_process_env_remove.rs    317_process_output.rs
hello.sh
<strong>process exited with code: exit code: 0</strong>
</pre>



<p><a name="k04"></a></p>
<h2 id="k04">4. Reakce na chybu při pokusu o vytvoření nového procesu</h2>

<p>Zkusme si nyní demonstrační příklad nepatrně upravit, a to konkrétně takovým
způsobem, aby se namísto externího příkazu <strong>ls</strong> spouštěl neznámý
příkaz <strong>unknown</strong>. Zbytek zdrojového kódu zůstává stejný
s&nbsp;předchozím příkladem:</p>

<pre>
use std::process::Command;
&nbsp;
fn main() {
    let process = <strong>Command::new("unknown").spawn()</strong>;
&nbsp;
    match process {
        Ok(<strong>mut</strong> child) =&gt; {
            println!("spawn ok");
            match <strong>child.wait()</strong> {
                Ok(code) =&gt; {
                    println!("process exited with code: {}", code);
                }
                Err(err) =&gt; {
                    println!("failed to wait on child: {}", err);
                }
            }
        }
        Err(err) =&gt; {
            println!("spawn error: {}", err);
        }
    }
&nbsp;
}
</pre>

<p>Z&nbsp;výpisu je patrné, že chyba byla zachycena, a to konkrétně ve vnějším
bloku pro pattern matching. Chybové hlášení je převzato z&nbsp;operačního
systému:</p>

<pre>
spawn error: No such file or directory (os error 2)
</pre>



<p><a name="k05"></a></p>
<h2 id="k05">5. Předání argumentu nově vytvářenému procesu</h2>

<p>O předání argumentu nově vytvářenému procesu se postará metoda
<strong>arg()</strong> zavolaná pro strukturu typu <strong>Command</strong>.
Tato metoda akceptuje řetězec (konkrétně typu OsStr, což můžeme v&nbsp;této
chvíli považovat za běžný řetězec) a vrací novou strukturu typu
<strong>Command</strong>:</p>

<pre>
fn arg&lt;S: AsRef&lt;OsStr&gt;&gt;(&amp;mut self, arg: S) -&gt; &amp;mut Command
</pre>

<p>Pokud například potřebujeme předat nově spuštěnému procesu
<strong>ls</strong> argument <strong>-1</strong> (jeden soubor na řádek),
použijeme namísto:</p>

<pre>
let process = Command::new("unknown").spawn();
</pre>

<p>Nepatrně upravený zápis:</p>

<pre>
let process = Command::new("ls").<strong>arg("-1")</strong>.spawn();
</pre>

<p>Otestujme si předání argumentů to v&nbsp;novém příkladu:</p>

<pre>
use std::process::Command;
&nbsp;
fn main() {
    let process = Command::new("ls").<strong>arg("-1")</strong>.spawn();
&nbsp;
    match process {
        Ok(mut child) =&gt; {
            println!("spawn ok");
            match child.wait() {
                Ok(code) =&gt; {
                    println!("process exited with code: {}", code);
                }
                Err(err) =&gt; {
                    println!("failed to wait on child: {}", err);
                }
            }
        }
        Err(err) =&gt; {
            println!("spawn error: {}", err);
        }
    }
&nbsp;
}
</pre>

<p>Výsledkem spuštění přeloženého programu by mohly být následující řádky
(samozřejmě opět v&nbsp;závislosti na skutečném obsahu aktuálního
adresáře):</p>

<pre>
<strong>spawn ok</strong>
308_spawn_process.rs
309_spawn_error.rs
310_process_arg
310_process_arg.rs
310.txt
311_process_args.rs
312_bad_directory.rs
313_process_args_in_vector.rs
314_local_script_error.rs
315_process_env_vars.rs
316_process_env_remove.rs
317_process_output.rs
hello.sh
<strong>process exited with code: exit code: 0</strong>
</pre>



<p><a name="k06"></a></p>
<h2 id="k06">6. Předání více argumentů spouštěnému procesu</h2>

<p>Vzhledem k&nbsp;tomu, že metoda <strong>Command.arg()</strong> vrací novou
strukturu typu <strong>Command</strong>, není samozřejmě žádným větším
problémem zřetězit volání těchto metod a zajistit tak, aby se příkazu předalo
větší množství argumentů. Podívejme se, jak příkazu <strong>ls</strong> předáme
argument &bdquo;-1&ldquo; (jeden soubor na řádek) s&nbsp;argumentem
&bdquo;/&ldquo; (výpis obsahu kořenového adresáře):</p>

<pre>
let process = Command::new("ls").<strong>arg("-1")</strong>.<strong>arg("/")</strong>.spawn();
</pre>

<p>Zakomponujeme toto volání do zdrojového kódu našeho demonstračního
příkladu:</p>

<pre>
use std::process::Command;
&nbsp;
fn main() {
    let process = Command::new("ls").<strong>arg("-1")</strong>.<strong>arg("/")</strong>.spawn();
&nbsp;
    match process {
        Ok(mut child) =&gt; {
            println!("spawn ok");
            match child.wait() {
                Ok(code) =&gt; {
                    println!("process exited with code: {}", code);
                }
                Err(err) =&gt; {
                    println!("failed to wait on child: {}", err);
                }
            }
        }
        Err(err) =&gt; {
            println!("spawn error: {}", err);
        }
    }
&nbsp;
}
</pre>

<p>Ukázka spuštění tohoto příkladu na Linux Mintu:</p>

<pre>
<strong>spawn ok</strong>
bin
boot
cdrom
dev
etc
home
initrd.img
lib
lib64
lost+found
media
mnt
opt
proc
root
run
sbin
srv
sys
tmp
usr
var
vmlinuz
<strong>process exited with code: exit code: 0</strong>
</pre>



<p><a name="k07"></a></p>
<h2 id="k07">7. Návratová hodnota procesu</h2>

<p>Zkusme nyní příklad upravit takovým způsobem, aby se příkaz &bdquo;ls&ldquo;
snažil vypsat neexistující adresář &bdquo;/xyzzy&ldquo; (který je tedy umístěn
přímo v&nbsp;kořenovém adresáři). V&nbsp;takovém případě proces
&bdquo;ls&ldquo; samozřejmě nastartuje korektně (není důvod, aby se nespustil)
a teprve poté dojde k&nbsp;chybě. Tato chyba je pro náš program reprezentována
návratovým kódem, který bude odlišný od nuly. Konkrétně v&nbsp;případě příkazu
&bdquo;ls&ldquo; návratové kódy snadno zjistíme z&nbsp;manuálové stránky:</p>

<pre>
<strong>man ls</strong>
...
...
...
&nbsp;
   Exit status:
       0      if OK,
&nbsp;
       1      if minor problems (e.g., cannot access subdirectory),
&nbsp;
       2      if serious trouble (e.g., cannot access command-line argument).
</pre>

<p>Zdrojový kód upraveného příkladu vypadá následovně:</p>

<pre>
use std::process::Command;
&nbsp;
fn main() {
    let process = Command::new("ls").arg("-1").<strong>arg("/xyzzy")</strong>.spawn();
&nbsp;
    match process {
        Ok(mut child) =&gt; {
            println!("spawn ok");
            match child.wait() {
                Ok(code) =&gt; {
                    println!("process exited with code: {}", code);
                }
                <strong>Err(err) =&gt; {</strong>
                    <strong>println!("failed to wait on child: {}", err);</strong>
                <strong>}</strong>
            }
        }
        Err(err) =&gt; {
            println!("spawn error: {}", err);
        }
    }
&nbsp;
}
</pre>

<p>V&nbsp;tomto případě se uplatní druhá větev vnořené konstrukce match, která
je na výpisu zvýrazněna tučně. Ostatně je to patrné i ze zpráv vypisovaných
příkladem na standardní výstup:</p>

<pre>
spawn ok
process exited with code: exit code: 2
</pre>



<p><a name="k08"></a></p>
<h2 id="k08">8. Argumenty procesu předané pomocí vektoru</h2>

<p>Vzhledem k&nbsp;tomu, že předávání většího množství argumentů nově
vytvářenému procesu je v&nbsp;praxi velmi časté, obsahuje standardní knihovna
Rustu i užitečnou metodu <strong>Command.args()</strong>, které lze předat
&bdquo;slice&ldquo; ne vektor řetězců, které představují jednotlivé argumenty.
To například znamená, že namísto:</p>

<pre>
let process = Command::new("ls").<strong>arg("-1")</strong>.<strong>arg("/bin")</strong>.<strong>arg("-c")</strong>.spawn();
</pre>

<p>je možné napsat jen:</p>

<pre>
let process = Command::new("ls").args(&amp;["-1", "/bin", "-c"]).spawn();
</pre>

<p>(povšimněte si, že skutečně vytváříme &bdquo;slice&ldquo; na vektor).</p>

<p>Chování <strong>Command.args()</strong> si můžeme snadno odzkoušet:</p>

<pre>
use std::process::Command;
&nbsp;
fn main() {
    let process = Command::new("ls").<strong>args(&amp;["-1", "/bin", "-c"])</strong>.spawn();
&nbsp;
    match process {
        Ok(mut child) =&gt; {
            println!("spawn ok");
            match child.wait() {
                Ok(code) =&gt; {
                    println!("process exited with code: {}", code);
                }
                Err(err) =&gt; {
                    println!("failed to wait on child: {}", err);
                }
            }
        }
        Err(err) =&gt; {
            println!("spawn error: {}", err);
        }
    }
&nbsp;
}
</pre>

<p>Výsledkem by měl být obsah všech souborů a případných podadresářů umístěných
v &bdquo;/bin&ldquo;:</p>

<pre>
spawn ok
udevadm
dbus-cleanup-sockets
dbus-daemon
dbus-uuidgen
loginctl
dmesg
lsblk
more
tailf
tar
findmnt
mount
umount
cpio
mt-gnu
mountpoint
pidof
chgrp
chmod
chown
dd
df
dir
false
ls
mknod
pwd
touch
true
vdir
cat
cp
date
echo
ln
mkdir
mktemp
mv
readlink
rm
rmdir
sleep
stty
sync
uname
ip
ss
fusermount
ulockmgr_server
login
su
kill
ps
plymouth-upstart-bridge
plymouth
running-in-container
rbash
bash
netstat
ping
ping6
vmmouse_detect
which
whiptail
ypdomainname
zcat
zcmp
zdiff
zegrep
zfgrep
zforce
zgrep
zless
zmore
znew
uncompress
unicode_start
tempfile
static-sh
run-parts
sed
setfacl
setfont
setupcon
sh
sh.distrib
red
ntfsinfo
ntfsls
ntfsmftalloc
ntfsmove
ntfstruncate
ntfswipe
open
openvt
ntfs-3g.secaudit
ntfs-3g.usermap
ntfscat
ntfsck
ntfscluster
ntfscmp
ntfsdump_logfile
ntfsfix
nisdomainname
ntfs-3g
ntfs-3g.probe
mt
lowntfs-3g
lsmod
less
lessecho
lessfile
lesskey
lesspipe
loadkeys
kbd_mode
keyctl
kmod
getfacl
grep
gunzip
gzexe
gzip
hostname
fuser
fgconsole
fgrep
ed
egrep
dnsdomainname
domainname
dumpkeys
dash
chacl
chvt
busybox
bzcat
bzcmp
bzdiff
bzegrep
bzexe
bzfgrep
bzgrep
bzip2
bzip2recover
bzless
bzmore
bunzip2
process exited with code: exit code: 0
</pre>



<p><a name="k09"></a></p>
<h2 id="k09">9. Pokus o spuštění lokálního skriptu</h2>

<p>Pokusme se nyní z&nbsp;aplikace naprogramované v&nbsp;Rustu spustit tento
jednoduchý lokální skript, tj.&nbsp;skript umístěný v&nbsp;aktuálním
adresáři:</p>

<pre>
echo "Hello world"
</pre>

<p>Pokus o spuštění bude vypadat takto:</p>

<pre>
use std::process::Command;
&nbsp;
fn main() {
    let process = Command::<strong>new("hello.sh")</strong>.spawn();
&nbsp;
    match process {
        Ok(mut child) =&gt; {
            println!("spawn ok");
            match child.wait() {
                Ok(code) =&gt; {
                    println!("process exited with code: {}", code);
                }
                Err(err) =&gt; {
                    println!("failed to wait on child: {}", err);
                }
            }
        }
        Err(err) =&gt; {
            println!("spawn error: {}", err);
        }
    }
&nbsp;
}
</pre>

<p>S&nbsp;poměrně velkou pravděpodobností se však tento skript nepodaří spustit
a dostaneme následující chybové hlášení:</p>

<pre>
spawn error: No such file or directory (os error 2)
</pre>

<p>Co to znamená? Skript nebyl nalezen, a to z&nbsp;toho prostého důvodu, že
většina (?) uživatelů nemá do proměnné  prostředí <strong>PATH</strong> přidán
aktuální adresář, tedy &bdquo;.&ldquo;, což je samozřejmě z&nbsp;hlediska
bezpečnosti velmi rozumné.</p>



<p><a name="k10"></a></p>
<h2 id="k10">10. Nastavení proměnných prostředí pro nově vznikající proces</h2>

<p>Před spuštěním nového procesu je ovšem možné mu proměnné prostředí nastavit.
K&nbsp;tomu slouží metoda <strong>Command.env()</strong>, které se předá jméno
proměnné a její hodnota (většinou se jedná o řetězce) a která vrátí novou
strukturu typu <strong>Command</strong>:</p>

<pre>
fn env&lt;K, V&gt;(&amp;mut self, key: K, val: V) -&gt; &amp;mut Command
</pre>

<p>Vzhledem k&nbsp;tomu, že se vrací nový <strong>Command</strong>, je možné
volání <strong>env()</strong> zřetězit, a to stejným způsobem, jako u metody
<strong>arg()</strong> či <strong>args()</strong>.</p>

<p>Úprava programu, který má spustit lokální skript, bude vypadat takto:</p>

<pre>
use std::process::Command;
&nbsp;
fn main() {
    let process = Command::new("hello.sh").<strong>env("PATH", ".")</strong>.spawn();
&nbsp;
    match process {
        Ok(mut child) =&gt; {
            println!("spawn ok");
            match child.wait() {
                Ok(code) =&gt; {
                    println!("process exited with code: {}", code);
                }
                Err(err) =&gt; {
                    println!("failed to wait on child: {}", err);
                }
            }
        }
        Err(err) =&gt; {
            println!("spawn error: {}", err);
        }
    }
&nbsp;
}
</pre>

<p>Ze zpráv vypsaných na standardní výstup je patrné, že se tentokrát spuštění
podařilo:</p>

<pre>
spawn ok
Hello world!
process exited with code: exit code: 0
</pre>



<p><a name="k11"></a></p>
<h2 id="k11">11. Odstranění vybrané proměnné prostředí</h2>

<p>Pokud potřebujeme nějakou proměnnou prostředí naopak odstranit, může se
použít metoda <strong>Command.env_remove()</strong>, které se předá jméno
proměnné (hodnota samozřejmě nikoli) a kterou lze opět zřetězit:</p>

<pre>
let process = Command::new("ls").<strong>env_remove("PATH")</strong>.spawn();
</pre>

<p>V&nbsp;případě, že si naopak chceme být jistí, že procesu nepředáme žádnou
proměnnou získanou z&nbsp;rodičovského procesu, můžeme využít metodu
<strong>Command.env_clear()</strong>. Typické použití může vypadat takto:</p>

<pre>
let process = Command::new("ls").<strong>env_clear()</strong>.<strong>env("foo", "bar")</strong>.<strong>env("password", "this_one")</strong>.spawn();
</pre>

<p>Můžeme si to snadno odzkoušet:</p>

<pre>
use std::process::Command;
&nbsp;
fn main() {
    let process = Command::new("ls").env_remove("PATH").spawn();
&nbsp;
    match process {
        Ok(mut child) =&gt; {
            println!("spawn ok");
            match child.wait() {
                Ok(code) =&gt; {
                    println!("process exited with code: {}", code);
                }
                Err(err) =&gt; {
                    println!("failed to wait on child: {}", err);
                }
            }
        }
        Err(err) =&gt; {
            println!("spawn error: {}", err);
        }
    }
&nbsp;
}
</pre>

<p>Výsledek spuštění tohoto programu:</p>

<pre>
spawn ok
308_spawn_process.rs
309_spawn_error.rs
310_process_arg.rs
311_process_args.rs
312_bad_directory.rs
313_process_args_in_vector.rs
314_local_script_error.rs
315_process_env_vars.rs
316_process_env_remove
316_process_env_remove.rs
316.txt
317_process_output.rs
hello2.sh
hello.sh
process exited with code: exit code: 0
</pre>



<p><a name="k12"></a></p>
<h2 id="k12">12. Převzetí dat posílaných procesem na standardní výstup</h2>

<p>Nyní se dostáváme k&nbsp;důležitému tématu &ndash; proces sice umíme
spustit, ovšem ještě by bylo dobré umět zpracovat jeho standardní a chybový
výstup popř.&nbsp;procesu poslat nějaká data přes jeho standardní vstup. Ve
chvíli, kdy je již proces vytvořen, tj.&nbsp;když vznikla struktura
<strong>std::process::Child</strong>, můžeme mít k&nbsp;dispozici všechny tři
vstupně/výstupní proudy procesu, protože tato struktura vypadá zhruba
následovně:</p>

<pre>
pub struct Child {
    pub stdin: Option&lt;ChildStdin&gt;,
    pub stdout: Option&lt;ChildStdout&gt;,
    pub stderr: Option&lt;ChildStderr&gt;,
}
</pre>

<p>Pokud například budeme chtít zpracovat standardní výstup nového procesu,
musíme ho nakonfigurovat ještě před jeho spuštěním:</p>

<pre>
let process = Command::new("ls").arg("-1").<strong>stdout(Stdio::piped())</strong>.spawn();
</pre>

<p>Takto nakonfigurovaný proces používá klasickou rouru (<i>pipe</i>) pro
komunikaci s&nbsp;naším programem a je tedy možné provést čtení jeho výstupu,
například takto:</p>

<ol>
<li>Vytvoříme si pomocnou proměnnou &ndash; řetězec s&nbsp;měnitelnou délkou.</li>
<li>Získáme standardní výstup procesu voláním <strong>Child.stdout</strong> (je typu <strong>Result</strong>, proto je nutné použít unwrap)</li>
<li>Přečteme výstup buď celý (v&nbsp;praxi poměrně nebezpečné ve chvíli, kdy si nejsme jisti množstvím dat) nebo po částech do bufferu a zpracujeme ho.</li>
<li>Uzavření výstupu se provede automaticky při výskoku z&nbsp;bloku.</li>
</ol>

<p>Výše uvedené kroky se realizují programově takto:</p>

<pre>
let mut buffer = String::new();
let stdout = child.stdout.as_mut().unwrap();
match stdout.read_to_string(&amp;mut buffer) {
    Ok(read_bytes) =&gt; {
        println!("read {} bytes", read_bytes);
        println!("{}", buffer);
    }
    Err(err) =&gt; {
        println!("read error: {}", err);
    }
}
</pre>

<p>Tyto příkazy jsou umístěny do samostatného bloku, aby se přesně stanovila
živost (viditelnost) všech objektů a tím se mj.&nbsp;zaručilo, že bude možné
zavolat <strong>Child.wait()</strong>.</p>

<p>Podívejme se nyní na celý příklad:</p>

<pre>
use std::process::Command;
use std::process::Stdio;
use std::io::Read;
&nbsp;
fn main() {
    let process = Command::new("ls").arg("-1").stdout(Stdio::piped()).spawn();
&nbsp;
    match process {
        Ok(mut child) =&gt; {
            println!("spawn ok");
            {
                let mut buffer = String::new();
                let stdout = child.stdout.as_mut().unwrap();
                match stdout.read_to_string(&amp;mut buffer) {
                    Ok(read_bytes) =&gt; {
                        println!("read {} bytes", read_bytes);
                        println!("{}", buffer);
                    }
                    Err(err) =&gt; {
                        println!("read error: {}", err);
                    }
                }
            }
            match child.wait() {
                Ok(code) =&gt; {
                    println!("process exited with code: {}", code);
                }
                Err(err) =&gt; {
                    println!("failed to wait on child: {}", err);
                }
            }
        }
        Err(err) =&gt; {
            println!("spawn error: {}", err);
        }
    }
&nbsp;
}
</pre>

<p>Spuštění tohoto příkladu by mělo dát stejné výsledky, jako tomu bylo
v&nbsp;příkladu předchozím, ovšem s&nbsp;jedním důležitým rozdílem &ndash;
tentokrát veškerý výstup zpracoval náš program a nikoli přímo příkaz
<strong>ls</strong>:</p>

<pre>
spawn ok
read 297 bytes
308_spawn_process.rs
309_spawn_error.rs
310_process_arg.rs
311_process_args.rs
312_bad_directory.rs
313_process_args_in_vector.rs
314_local_script_error.rs
315_process_env_vars.rs
316_process_env_remove
316_process_env_remove.rs
317_process_output
317_process_output.rs
317.txt
hello2.sh
hello.sh
</pre>



<p><a name="k13"></a></p>
<h2 id="k13">13. Repositář s&nbsp;demonstračními příklady</h2>

<p>Všechny dnes popisované demonstrační příklady byly, ostatně podobně jako ve
všech předchozích částech <a
href="https://www.root.cz/serialy/programovaci-jazyk-rust/">tohoto seriálu</a>,
uloženy do Git repositáře dostupného na adrese <a
href="https://github.com/tisnik/presentations">https://github.com/tisnik/presentations</a>.
Příklady si můžete v&nbsp;případě potřeby stáhnout i jednotlivě bez nutnosti
klonovat celý repositář:</p>

<table>
<tr><th>Příklad</th><th>Adresa</th></tr>
<tr><td>308_spawn_process.rs</td><td><a href="https://github.com/tisnik/presentations/blob/master/rust/308_spawn_process.rs">https://github.com/tisnik/presentations/blob/master/rust/308_spawn_process.rs</a></td></tr>
<tr><td>309_spawn_error.rs</td><td><a href="https://github.com/tisnik/presentations/blob/master/rust/309_spawn_error.rs">https://github.com/tisnik/presentations/blob/master/rust/309_spawn_error.rs</a></td></tr>
<tr><td>310_process_arg.rs</td><td><a href="https://github.com/tisnik/presentations/blob/master/rust/310_process_arg.rs">https://github.com/tisnik/presentations/blob/master/rust/310_process_arg.rs</a></td></tr>
<tr><td>311_process_args.rs</td><td><a href="https://github.com/tisnik/presentations/blob/master/rust/311_process_args.rs">https://github.com/tisnik/presentations/blob/master/rust/311_process_args.rs</a></td></tr>
<tr><td>312_bad_directory.rs</td><td><a href="https://github.com/tisnik/presentations/blob/master/rust/312_bad_directory.rs">https://github.com/tisnik/presentations/blob/master/rust/312_bad_directory.rs</a></td></tr>
<tr><td>313_process_args_in_vector.rs</td><td><a href="https://github.com/tisnik/presentations/blob/master/rust/313_process_args_in_vector.rs">https://github.com/tisnik/presentations/blob/master/rust/313_process_args_in_vector.rs</a></td></tr>
<tr><td>314_local_script_error.rs</td><td><a href="https://github.com/tisnik/presentations/blob/master/rust/314_local_script_error.rs">https://github.com/tisnik/presentations/blob/master/rust/314_local_script_error.rs</a></td></tr>
<tr><td>315_process_env_vars.rs</td><td><a href="https://github.com/tisnik/presentations/blob/master/rust/315_process_env_vars.rs">https://github.com/tisnik/presentations/blob/master/rust/315_process_env_vars.rs</a></td></tr>
<tr><td>316_process_env_remove.rs</td><td><a href="https://github.com/tisnik/presentations/blob/master/rust/316_process_env_remove.rs">https://github.com/tisnik/presentations/blob/master/rust/316_process_env_remove.rs</a></td></tr>
<tr><td>317_process_output.rs</td><td><a href="https://github.com/tisnik/presentations/blob/master/rust/317_process_output.rs">https://github.com/tisnik/presentations/blob/master/rust/317_process_output.rs</a></td></tr>
<tr><td>&nbsp;</td><td>&nbsp;</td></tr>
<tr><td>hello.sh</td><td><a href="https://github.com/tisnik/presentations/blob/master/rust/hello.sh">https://github.com/tisnik/presentations/blob/master/rust/hello.sh</a></td></tr>
<tr><td>hello2.sh</td><td><a href="https://github.com/tisnik/presentations/blob/master/rust/hello2.sh">https://github.com/tisnik/presentations/blob/master/rust/hello2.sh</a></td></tr>
<table>



<p><a name="k14"></a></p>
<h2 id="k14">14. Odkazy na Internetu</h2>

<ol>

<li>Cargo: správce projektů a balíčků pro programovací jazyk Rust<br />
<a href="https://mojefedora.cz/cargo-spravce-projektu-a-balicku-pro-programovaci-jazyk-rust/">https://mojefedora.cz/cargo-spravce-projektu-a-balicku-pro-programovaci-jazyk-rust/</a>
</li>

<li>Network Communication and Serialization in Rust<br />
<a href="https://www.safaribooksonline.com/blog/2014/01/28/network-communication-serialization-rust/">https://www.safaribooksonline.com/blog/2014/01/28/network-communication-serialization-rust/</a>
</li>

<li>Crate bincode<br />
<a href="http://tyoverby.com/bincode/bincode/index.html">http://tyoverby.com/bincode/bincode/index.html</a>
</li>

<li>Struct std::fs::File<br />
<a href="https://doc.rust-lang.org/std/fs/struct.File.html">https://doc.rust-lang.org/std/fs/struct.File.html</a>
</li>

<li>Trait std::io::Seek<br />
<a href="https://doc.rust-lang.org/std/io/trait.Seek.html">https://doc.rust-lang.org/std/io/trait.Seek.html</a>
</li>

<li>Trait std::io::Read<br />
<a href="https://doc.rust-lang.org/std/io/trait.Read.html">https://doc.rust-lang.org/std/io/trait.Read.html</a>
</li>

<li>Trait std::io::Write<br />
<a href="https://doc.rust-lang.org/std/io/trait.Write.html">https://doc.rust-lang.org/std/io/trait.Write.html</a>
</li>

<li>Trait std::io::BufRead<br />
<a href="https://doc.rust-lang.org/std/io/trait.BufRead.html">https://doc.rust-lang.org/std/io/trait.BufRead.html</a>
</li>

<li>Module std::io::prelude<br />
<a href="https://doc.rust-lang.org/std/io/prelude/index.html">https://doc.rust-lang.org/std/io/prelude/index.html</a>
</li>

<li>std::net::IpAddr<br />
<a href="https://doc.rust-lang.org/std/net/enum.IpAddr.html">https://doc.rust-lang.org/std/net/enum.IpAddr.html</a>
</li>

<li>std::net::Ipv4Addr<br />
<a href="https://doc.rust-lang.org/std/net/struct.Ipv4Addr.html">https://doc.rust-lang.org/std/net/struct.Ipv4Addr.html</a>
</li>

<li>std::net::Ipv6Addr<br />
<a href="https://doc.rust-lang.org/std/net/struct.Ipv6Addr.html">https://doc.rust-lang.org/std/net/struct.Ipv6Addr.html</a>
</li>

<li>TcpListener<br />
<a href="https://doc.rust-lang.org/std/net/struct.TcpListener.html">https://doc.rust-lang.org/std/net/struct.TcpListener.html</a>
</li>

<li>TcpStream<br />
<a href="https://doc.rust-lang.org/std/net/struct.TcpStream.html">https://doc.rust-lang.org/std/net/struct.TcpStream.html</a>
</li>

<li>Binary heap (Wikipedia)<br />
<a href="https://en.wikipedia.org/wiki/Binary_heap">https://en.wikipedia.org/wiki/Binary_heap</a>
</li>

<li>Binární halda (Wikipedia)<br />
<a href="https://cs.wikipedia.org/wiki/Bin%C3%A1rn%C3%AD_halda">https://cs.wikipedia.org/wiki/Bin%C3%A1rn%C3%AD_halda</a>
</li>

<li>Halda (datová struktura)<br />
<a href="https://cs.wikipedia.org/wiki/Halda_%28datov%C3%A1_struktura%29">https://cs.wikipedia.org/wiki/Halda_%28datov%C3%A1_struktura%29</a>
</li>

<li>Struct std::collections::HashSet<br />
<a href="https://doc.rust-lang.org/std/collections/struct.HashSet.html">https://doc.rust-lang.org/std/collections/struct.HashSet.html</a>
</li>

<li>Struct std::collections::BTreeSet<br />
<a href="https://doc.rust-lang.org/std/collections/struct.BTreeSet.html">https://doc.rust-lang.org/std/collections/struct.BTreeSet.html</a>
</li>

<li>Struct std::collections::BinaryHeap<br />
<a href="https://doc.rust-lang.org/std/collections/struct.BinaryHeap.html">https://doc.rust-lang.org/std/collections/struct.BinaryHeap.html</a>
</li>

<li>Set (abstract data type)<br />
<a href="https://en.wikipedia.org/wiki/Set_%28abstract_data_type%29#Language_support">https://en.wikipedia.org/wiki/Set_%28abstract_data_type%29#Language_support</a>
</li>

<li>Associative array<br />
<a href="https://en.wikipedia.org/wiki/Associative_array">https://en.wikipedia.org/wiki/Associative_array</a>
</li>

<li>Hash Table<br />
<a href="https://en.wikipedia.org/wiki/Hash_table">https://en.wikipedia.org/wiki/Hash_table</a>
</li>

<li>B-tree<br />
<a href="https://en.wikipedia.org/wiki/B-tree">https://en.wikipedia.org/wiki/B-tree</a>
</li>

<li>Pedro Celis: Robin Hood Hashing (naskenované PDF!)<br />
<a href="https://cs.uwaterloo.ca/research/tr/1986/CS-86-14.pdf">https://cs.uwaterloo.ca/research/tr/1986/CS-86-14.pdf</a>
</li>

<li>Robin Hood hashing<br />
<a href="http://codecapsule.com/2013/11/11/robin-hood-hashing/">http://codecapsule.com/2013/11/11/robin-hood-hashing/</a>
</li>

<li>Robin Hood hashing: backward shift deletion<br />
<a href="http://codecapsule.com/2013/11/17/robin-hood-hashing-backward-shift-deletion/">http://codecapsule.com/2013/11/17/robin-hood-hashing-backward-shift-deletion/</a>
</li>

<li>Module std::collections<br />
<a href="https://doc.rust-lang.org/std/collections/">https://doc.rust-lang.org/std/collections/</a>
</li>

<li>Module std::vec<br />
<a href="https://doc.rust-lang.org/nightly/std/vec/index.html">https://doc.rust-lang.org/nightly/std/vec/index.html</a>
</li>

<li>Struct std::collections::VecDeque<br />
<a href="https://doc.rust-lang.org/std/collections/struct.VecDeque.html">https://doc.rust-lang.org/std/collections/struct.VecDeque.html</a>
</li>

<li>Struct std::collections::LinkedList<br />
<a href="https://doc.rust-lang.org/std/collections/struct.LinkedList.html">https://doc.rust-lang.org/std/collections/struct.LinkedList.html</a>
</li>

<li>Module std::fmt<br />
<a href="https://doc.rust-lang.org/std/fmt/">https://doc.rust-lang.org/std/fmt/</a>
</li>

<li>Macro std::println<br />
<a href="https://doc.rust-lang.org/std/macro.println.html">https://doc.rust-lang.org/std/macro.println.html</a>
</li>

<li>Enum std::result::Result<br />
<a href="https://doc.rust-lang.org/std/result/enum.Result.html">https://doc.rust-lang.org/std/result/enum.Result.html</a>
</li>

<li>Module std::result<br />
<a href="https://doc.rust-lang.org/std/result/">https://doc.rust-lang.org/std/result/</a>
</li>

<li>Result<br />
<a href="http://rustbyexample.com/std/result.html">http://rustbyexample.com/std/result.html</a>
</li>

<li>Rust stdlib: Option<br />
<a href="https://doc.rust-lang.org/std/option/enum.Option.html">https://doc.rust-lang.org/std/option/enum.Option.html</a>
</li>

<li>Module std::option<br />
<a href="https://doc.rust-lang.org/std/option/index.html">https://doc.rust-lang.org/std/option/index.html</a>
</li>

<li>Rust by example: option<br />
<a href="http://rustbyexample.com/std/option.html">http://rustbyexample.com/std/option.html</a>
</li>

<li>Rust by example: if-let<br />
<a href="http://rustbyexample.com/flow_control/if_let.html">http://rustbyexample.com/flow_control/if_let.html</a>
</li>

<li>Rust by example: while let<br />
<a href="http://rustbyexample.com/flow_control/while_let.html">http://rustbyexample.com/flow_control/while_let.html</a>
</li>

<li>Rust by example: Option&lt;i32&gt;<br />
<a href="http://rustbyexample.com/std/option.html">http://rustbyexample.com/std/option.html</a>
</li>

<li>An Overview of Macros in Rust<br />
<a href="http://words.steveklabnik.com/an-overview-of-macros-in-rust">http://words.steveklabnik.com/an-overview-of-macros-in-rust</a>
</li>

<li>A Practical Intro to Macros in Rust 1.0<br />
<a href="https://danielkeep.github.io/practical-intro-to-macros.html">https://danielkeep.github.io/practical-intro-to-macros.html</a>
</li>

<li>The Rust Programming Language: macros<br />
<a href="https://doc.rust-lang.org/beta/book/macros.html">https://doc.rust-lang.org/beta/book/macros.html</a>
</li>

<li>Rust by example: 15 macro_rules!<br />
<a href="http://rustbyexample.com/macros.html">http://rustbyexample.com/macros.html</a>
</li>

<li>Primitive Type isize<br />
<a href="https://doc.rust-lang.org/nightly/std/primitive.isize.html">https://doc.rust-lang.org/nightly/std/primitive.isize.html</a>
</li>

<li>Primitive Type usize<br />
<a href="https://doc.rust-lang.org/nightly/std/primitive.usize.html">https://doc.rust-lang.org/nightly/std/primitive.usize.html</a>
</li>

<li>Primitive Type array<br />
<a href="https://doc.rust-lang.org/nightly/std/primitive.array.html">https://doc.rust-lang.org/nightly/std/primitive.array.html</a>
</li>

<li>Module std::slice<br />
<a href="https://doc.rust-lang.org/nightly/std/slice/">https://doc.rust-lang.org/nightly/std/slice/</a>
</li>

<li>Rust by Example: 2.3 Arrays and Slices<br />
<a href="http://rustbyexample.com/primitives/array.html">http://rustbyexample.com/primitives/array.html</a>
</li>

<li>What is the difference between Slice and Array (stackoverflow)<br />
<a href="http://stackoverflow.com/questions/30794235/what-is-the-difference-between-slice-and-array">http://stackoverflow.com/questions/30794235/what-is-the-difference-between-slice-and-array</a>
</li>

<li>Learning Rust With Entirely Too Many Linked Lists<br />
<a href="http://cglab.ca/~abeinges/blah/too-many-lists/book/">http://cglab.ca/~abeinges/blah/too-many-lists/book/</a>
</li>

<li>Testcase: linked list<br />
<a href="http://rustbyexample.com/custom_types/enum/testcase_linked_list.html">http://rustbyexample.com/custom_types/enum/testcase_linked_list.html</a>
</li>

<li>Operators and Overloading<br />
<a href="https://doc.rust-lang.org/book/operators-and-overloading.html">https://doc.rust-lang.org/book/operators-and-overloading.html</a>
</li>

<li>Module std::ops<br />
<a href="https://doc.rust-lang.org/std/ops/index.html">https://doc.rust-lang.org/std/ops/index.html</a>
</li>

<li>Module std::cmp<br />
<a href="https://doc.rust-lang.org/std/cmp/index.html">https://doc.rust-lang.org/std/cmp/index.html</a>
</li>

<li>Trait std::ops::Add<br />
<a href="https://doc.rust-lang.org/stable/std/ops/trait.Add.html">https://doc.rust-lang.org/stable/std/ops/trait.Add.html</a>
</li>

<li>Trait std::ops::AddAssign<br />
<a href="https://doc.rust-lang.org/std/ops/trait.AddAssign.html">https://doc.rust-lang.org/std/ops/trait.AddAssign.html</a>
</li>

<li>Trait std::ops::Drop<br />
<a href="https://doc.rust-lang.org/std/ops/trait.Drop.html">https://doc.rust-lang.org/std/ops/trait.Drop.html</a>
</li>

<li>Trait std::cmp::Eq<br />
<a href="https://doc.rust-lang.org/std/cmp/trait.Eq.html">https://doc.rust-lang.org/std/cmp/trait.Eq.html</a>
</li>

<li>Struct std::boxed::Box<br />
<a href="https://doc.rust-lang.org/std/boxed/struct.Box.html">https://doc.rust-lang.org/std/boxed/struct.Box.html</a>
</li>

<li>Explore the ownership system in Rust<br />
<a href="https://nercury.github.io/rust/guide/2015/01/19/ownership.html">https://nercury.github.io/rust/guide/2015/01/19/ownership.html</a>
</li>

<li>Rust's ownership and move semantic<br/>
<a href="http://www.slideshare.net/saneyuki/rusts-ownership-and-move-semantics">http://www.slideshare.net/saneyuki/rusts-ownership-and-move-semantics</a>
</li>

<li>Trait std::marker::Copy<br/>
<a href="https://doc.rust-lang.org/stable/std/marker/trait.Copy.html">https://doc.rust-lang.org/stable/std/marker/trait.Copy.html</a>
</li>

<li>Trait std::clone::Clone<br />
<a href="https://doc.rust-lang.org/stable/std/clone/trait.Clone.html">https://doc.rust-lang.org/stable/std/clone/trait.Clone.html</a>
</li>

<li>The Stack and the Heap<br />
<a href="https://doc.rust-lang.org/book/the-stack-and-the-heap.html">https://doc.rust-lang.org/book/the-stack-and-the-heap.html</a>
</li>

<li>Rust Compare: Pointers &amp; References<br />
<a href="http://www.rust-compare.com/site/pointers.html">http://www.rust-compare.com/site/pointers.html</a>
</li>

<li>Rust Compare: Parameters<br />
<a href="http://www.rust-compare.com/site/params.html">http://www.rust-compare.com/site/params.html</a>
</li>

<li>Why does this compile? Automatic dereferencing?<br />
<a href="https://users.rust-lang.org/t/why-does-this-compile-automatic-dereferencing/2183">https://users.rust-lang.org/t/why-does-this-compile-automatic-dereferencing/2183</a>
</li>

<li>Understanding Pointers, Ownership, and Lifetimes in Rust<br />
<a href="http://koerbitz.me/posts/Understanding-Pointers-Ownership-and-Lifetimes-in-Rust.html">http://koerbitz.me/posts/Understanding-Pointers-Ownership-and-Lifetimes-in-Rust.html</a>
</li>

<li>Rust lang series episode #25 — pointers (#rust-series)<br />
<a href="https://steemit.com/rust-series/@jimmco/rust-lang-series-episode-25-pointers-rust-series">https://steemit.com/rust-series/@jimmco/rust-lang-series-episode-25-pointers-rust-series</a>
</li>

<li>Rust - home page<br />
<a href="https://www.rust-lang.org/en-US/">https://www.rust-lang.org/en-US/</a>
</li>

<li>Rust - Frequently Asked Questions<br />
<a href="https://www.rust-lang.org/en-US/faq.html">https://www.rust-lang.org/en-US/faq.html</a>
</li>

<li>Destructuring and Pattern Matching<br />
<a href="https://pzol.github.io/getting_rusty/posts/20140417_destructuring_in_rust/">https://pzol.github.io/getting_rusty/posts/20140417_destructuring_in_rust/</a>
</li>

<li>The Rust Programming Language<br />
<a href="https://doc.rust-lang.org/book/">https://doc.rust-lang.org/book/</a>
</li>

<li>Rust (programming language)<br />
<a href="https://en.wikipedia.org/wiki/Rust_%28programming_language%29">https://en.wikipedia.org/wiki/Rust_%28programming_language%29</a>
</li>

<li>Go - home page<br />
<a href="https://golang.org/">https://golang.org/</a>
</li>

<li>Stack Overflow - Most Loved, Dreaded, and Wanted language<br />
<a href="https://stackoverflow.com/research/developer-survey-2016#technology-most-loved-dreaded-and-wanted">https://stackoverflow.com/research/developer-survey-2016#technology-most-loved-dreaded-and-wanted</a>
</li>

<li>Rust vs Go (dva roky staré hodnocení, od té doby došlo k posunům v obou jazycích)<br />
<a href="http://jaredforsyth.com/2014/03/22/rust-vs-go/">http://jaredforsyth.com/2014/03/22/rust-vs-go/</a>
</li>

<li>Rust vs Go: My experience<br />
<a href="https://www.reddit.com/r/golang/comments/21m6jq/rust_vs_go_my_experience/">https://www.reddit.com/r/golang/comments/21m6jq/rust_vs_go_my_experience/</a>
</li>

<li>Friends of Rust (Organizations running Rust in production)<br />
<a href="https://www.rust-lang.org/en-US/friends.html">https://www.rust-lang.org/en-US/friends.html</a>
</li>

<li>Rust programs versus C++ g++<br />
<a href="https://benchmarksgame.alioth.debian.org/u64q/compare.php?lang=rust&lang2=gpp">https://benchmarksgame.alioth.debian.org/u64q/compare.php?lang=rust&lang2=gpp</a>
</li>

<li>Další benchmarky (nejedná se o reálné příklady &bdquo;ze života&ldquo;)<br />
<a href="https://github.com/kostya/benchmarks">https://github.com/kostya/benchmarks</a>
</li>

<li>Go na Redditu<br />
<a href="https://www.reddit.com/r/golang/">https://www.reddit.com/r/golang/</a>
</li>

<li>Rust vs. Go<br />
<a href="http://vschart.com/compare/rust/vs/go-language">http://vschart.com/compare/rust/vs/go-language</a>
</li>

<li>Abstraction without overhead: traits in Rust<br />
<a href="https://blog.rust-lang.org/2015/05/11/traits.html">https://blog.rust-lang.org/2015/05/11/traits.html</a>
</li>

<li>Method Syntax<br />
<a href="https://doc.rust-lang.org/book/method-syntax.html">https://doc.rust-lang.org/book/method-syntax.html</a>
</li>

<li>Traits in Rust<br />
<a href="https://doc.rust-lang.org/book/traits.html">https://doc.rust-lang.org/book/traits.html</a>
</li>

<li>Functional Programming in Rust - Part 1 : Function Abstraction<br />
<a href="http://blog.madhukaraphatak.com/functional-programming-in-rust-part-1/">http://blog.madhukaraphatak.com/functional-programming-in-rust-part-1/</a>
</li>

<li>Of the emerging systems languages Rust, D, Go and Nim, which is the strongest language and why?<br />
<a href="https://www.quora.com/Of-the-emerging-systems-languages-Rust-D-Go-and-Nim-which-is-the-strongest-language-and-why">https://www.quora.com/Of-the-emerging-systems-languages-Rust-D-Go-and-Nim-which-is-the-strongest-language-and-why</a>
</li>

<li>Chytré ukazatele (moderní verze jazyka C++) [MSDN]<br />
<a href="https://msdn.microsoft.com/cs-cz/library/hh279674.aspx">https://msdn.microsoft.com/cs-cz/library/hh279674.aspx</a>
</li>

<li>UTF-8 Everywhere<br />
<a href="http://utf8everywhere.org/">http://utf8everywhere.org/</a>
</li>

<li>Rust by Example<br />
<a href="http://rustbyexample.com/">http://rustbyexample.com/</a>
</li>

<li>Rust oficiálně ve Fedoře<br />
<a href="https://mojefedora.cz/rust-oficialne-ve-fedore/">https://mojefedora.cz/rust-oficialne-ve-fedore/</a>
</li>

<li>Resource acquisition is initialization<br />
<a href="https://en.wikipedia.org/wiki/Resource_acquisition_is_initialization">https://en.wikipedia.org/wiki/Resource_acquisition_is_initialization</a>
</li>

<li>TIOBE index (October 2016)<br />
<a href="http://www.tiobe.com/tiobe-index/">http://www.tiobe.com/tiobe-index/</a>
</li>

<li>Porovnání Go, D a Rustu na OpenHubu:<br />
<a href="https://www.openhub.net/languages/compare?language_name[]=-1&language_name[]=-1&language_name[]=dmd&language_name[]=golang&language_name[]=rust&language_name[]=-1&measure=commits">https://www.openhub.net/languages/compare?language_name[]=-1&language_name[]=-1&language_name[]=dmd&language_name[]=golang&language_name[]=rust&language_name[]=-1&measure=commits</a>
</li>

<li>String Types in Rust<br />
<a href="http://www.suspectsemantics.com/blog/2016/03/27/string-types-in-rust/">http://www.suspectsemantics.com/blog/2016/03/27/string-types-in-rust/</a>
</li>

<li>Trait (computer programming)<br />
<a href="https://en.wikipedia.org/wiki/Trait_%28computer_programming%29">https://en.wikipedia.org/wiki/Trait_%28computer_programming%29</a>
</li>

<li>Type inference<br />
<a href="https://en.wikipedia.org/wiki/Type_inference">https://en.wikipedia.org/wiki/Type_inference</a>
</li>

</ol>



<p></p><p></p>
<p><small>Autor: <a href="http://www.fit.vutbr.cz/~tisnovpa">Pavel Ti?novsk?</a> &nbsp; 2017</small></p>
</body>
</html>


