<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
        "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html>
<head>
<title>Specifické vlastnosti procesorů AArch64: podmíněné a nepodmíněné skoky</title>
<meta name="Author" content="Pavel Tisnovsky" />
<meta name="Generator" content="vim" />
<meta http-equiv="content-type" content="text/html; charset=utf-8" />
<style type="text/css">
         body {color:#000000; background:#ffffff;}
         h1  {font-family: arial, helvetica, sans-serif; color:#ffffff; background-color:#c00000; text-align:center; padding-left:1em}
         h2  {font-family: arial, helvetica, sans-serif; color:#ffffff; background-color:#0000c0; padding-left:1em; text-align:left}
         h3  {font-family: arial, helvetica, sans-serif; color:#000000; background-color:#c0c0c0; padding-left:1em; text-align:left}
         h4  {font-family: arial, helvetica, sans-serif; color:#000000; background-color:#e0e0e0; padding-left:1em; text-align:left}
         a   {font-family: arial, helvetica, sans-serif;}
         li  {font-family: arial, helvetica, sans-serif; color:#000000; text-align:justify; width:450px;}
         ol  {font-family: arial, helvetica, sans-serif; color:#000000; text-align:justify; width:450px;}
         ul  {font-family: arial, helvetica, sans-serif; color:#000000; text-align:justify; width:450px;}
         p   {font-family: arial, helvetica, sans-serif; color:#000000; text-align:justify;}
         pre {background:#e0e0e0}
</style>
</head>

<body>

<h1>Specifické vlastnosti procesorů AArch64: podmíněné a nepodmíněné skoky</h1>

<h3>Pavel Tišnovský</h3>

<p></p>

<h1>Úvodník</h1>

<p></p>



<h2>Obsah</h2>

<p><a href="#k01">1. Specifické vlastnosti procesorů AArch64: podmíněné a nepodmíněné skoky</a></p>
<p><a href="#k02">2. Adresace u instrukce nepodmíněného skoku</a></p>
<p><a href="#k03">*** 3. Adresace u instrukce podmíněného skoku</a></p>
<p><a href="#k04">4. Druhá varianta zápisu programové smyčky bez explicitního testování nulové hodnoty počitadla</a></p>
<p><a href="#k05">5. Test na ukončení smyčky na začátku každé iterace</a></p>
<p><a href="#k06">6. Instrukce <strong>CBZ</strong> a <strong>CBNZ</strong></a></p>
<p><a href="#k07">7. Úprava předchozího příkladu &ndash; použití instrukce <strong>CBNZ</strong></a></p>
<p><a href="#k08">*** 8. Podpora pro zpracování polí: automatická změna adresy uložené v&nbsp;registru v&nbsp;instrukcích typu LOAD a STORE</a></p>
<p><a href="#k09">*** 9. Úprava předchozích příkladů s&nbsp;využitím automatické změny adresy</a></p>
<p><a href="#k10">*** 10. Přesuny bloků dat</a></p>
<p><a href="#k11">*** 11. Příklad realizace přesunu bloku dat</a></p>
<p><a href="#k12">12. Zjednodušení zápisu kódu v&nbsp;assembleru s&nbsp;využitím maker</a></p>
<p><a href="#k13">13. Vytvoření jednoduchého makra bez parametrů</a></p>
<p><a href="#k14">14. Vytvoření makra s&nbsp;parametry</a></p>
<p><a href="#k15">15. Výpis zdrojového kódu po expanzi maker a překladu</a></p>
<p><a href="#k16">16. Makro pro přesun bloku dat po bajtech</a></p>
<p><a href="#k17">17. Použití návěští v&nbsp;makrech</a></p>
<p><a href="#k18">18. Repositář s&nbsp;demonstračními příklady</a></p>
<p><a href="#k19">19. Předchozí články o architektuře AArch64</a></p>
<p><a href="#k20">20. Odkazy na Internetu</a></p>



<p><a name="k01"></a></p>
<h2 id="k01">1. Specifické vlastnosti procesorů AArch64: podmíněné a nepodmíněné skoky</h2>

<p>Na <a
href="https://www.root.cz/clanky/specificke-vlastnosti-procesoru-aarch64-zakladni-instrukce/">úvodní
článek o specifických vlastnostech procesorů s&nbsp;architekturou AArch64</a>
dnes navážeme. Věnovat se budeme zejména problematice skoků, a to jak skoků
podmíněných, tak i nepodmíněných. Právě skoky jsou totiž instrukcemi, které
jsou v&nbsp;určitém ohledu velmi kritické z&nbsp;hlediska výpočetního výkonu
&ndash; provedení skoku totiž může (ale ne vždy musí) &bdquo;přerušit&ldquo;
pipeline RISCových procesorů, takže již nemusí docházet k&nbsp;dokončení
instrukce v&nbsp;každém strojovém cyklu (u skalárních procesorů). Proto je
důležité tyto instrukce navrhnout a implementovat správně.</p>

<p>Připomeňme si, jaké instrukce skoku jsou podporovány:</p>

<table>
<tr><th>#</th><th>Instrukce</th><th>Stručný popis</th></tr>
<tr><td>1</td><td>B</td><td>skok na adresu vypočtenou z&nbsp;offsetu vůči PC v&nbsp;rozsahu &pm;128 MB</td></tr>
<tr><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td></tr>
<tr><td>2</td><td>BL</td><td>branch and link, stejné jako předchozí instrukce, ovšem původní hodnota PC se uloží do X30</td></tr>
<tr><td>3</td><td>BR</td><td>skok na adresu uloženou v&nbsp;registru s&nbsp;hintem, že se nejedná o výskok z&nbsp;podprogramu</td></tr>
<tr><td>4</td><td>RET</td><td>jako BR, ovšem s&nbsp;hintem, že se jedná o výskok z&nbsp;podprogramu</td></tr>
<tr><td>5</td><td>BRL</td><td>kombinace BR + BL, tj.&nbsp;skok na adresu uloženou v&nbsp;registru + původní PC do X30</td></tr>
<tr><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td></tr>
<tr><td>6</td><td>B.EQ</td><td>podmíněný skok BEQ, rovnost při porovnání či nulový výsledek poslední ALU operace</td></tr>
<tr><td>7</td><td>B.NE</td><td>podmíněný skok BNE, nerovnost při porovnání či nenulový výsledek poslední ALU operace</td></tr>
<tr><td>8</td><td>B.MI</td><td>podmíněný skok BMI, výsledek je záporný</td></tr>
<tr><td>9</td><td>B.PL</td><td>podmíněný skok BPL, výsledek je kladný či 0</td></tr>
<tr><td>10</td><td>B.VS</td><td>podmíněný skok BVS, nastalo přetečení</td></tr>
<tr><td>11</td><td>B.VC</td><td>podmíněný skok BVC, nenastalo přetečení</td></tr>
<tr><td>12</td><td>B.CS</td><td>podmíněný skok BCS, C == 1</td></tr>
<tr><td>13</td><td>B.CC</td><td>podmíněný skok BCC, C == 0</td></tr>
<tr><td>14</td><td>B.HI</td><td>podmíněný skok BHI, C == 1 &amp; Z == 0</td></tr>
<tr><td>15</td><td>B.LS</td><td>podmíněný skok BLS, C == 0 | Z == 1</td></tr>
<tr><td>16</td><td>B.GE</td><td>podmíněný skok BGE, N == V</td></tr>
<tr><td>17</td><td>B.LT</td><td>podmíněný skok BLT, N &ne; V</td></tr>
<tr><td>18</td><td>B.GT</td><td>podmíněný skok BGT, Z = 0, N = V</td></tr>
<tr><td>19</td><td>B.LE</td><td>podmíněný skok BLE, Z = 1, N &ne; V</td></tr>
<tr><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td></tr>
<tr><td>20</td><td>CBZ </td><td>Compare and Branch if Zero, bude použit v&nbsp;demonstračních příkladech</td></tr>
<tr><td>21</td><td>CBNZ</td><td>Compare and Branch if Not Zero</td></tr>
<tr><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td></tr>
<tr><td>22</td><td>TBZ </td><td>Test and Branch if Zero</td></tr>
<tr><td>23</td><td>TBNZ</td><td>Test and Branch if Not Zero</td></tr>
</table>



<p><a name="k02"></a></p>
<h2 id="k02">2. Adresace u instrukce nepodmíněného skoku</h2>

<p>Nejprve se budeme zabývat tím nejobyčejnějším skokem, což je instrukce
s&nbsp;mnemotechnickým názvem <strong>B</strong>. Skok je prováděn na určitou
adresu:</p>

<pre>
<strong>b</strong> cíl_skoku
</pre>

<p>Víme již, že všechny instrukce jsou uloženy ve čtyřech bajtech, do nichž se
musí kromě samotného kódu instrukce vejít i adresa cíle skoku. Konkrétně je
instrukce <strong>b</strong> zakódována následujícím způsobem:</p>

<ol>
<li>Nejvyšších šest bitů obsahuje konstantu 000101</li>
<li>Následuje 26bitová adresa umožňující <i>relativní</i> skok v&nbsp;rozsahu
&plusm;128 MB (cíl skoku je vždy dělitelný čtyřmi, proto se spodní dva bity
nemusí ukládat)</li>
</ol>

<p>Následující příklad ukazuje použití instrukce <strong>B</strong> pro
realizaci nekonečné smyčky:</p>

<pre>
<i># asmsyntax=as</i>
&nbsp;
<i># Nekonečná smyčka</i>
<i># v assembleru GNU as.</i>
<i>#</i>
<i># Autor: Pavel Tisnovsky</i>
&nbsp;
&nbsp;
&nbsp;
<i># Linux kernel system call table</i>
sys_exit=93
sys_write=64
&nbsp;
<i># List of syscalls for AArch64:</i>
<i># https://github.com/torvalds/linux/blob/master/include/uapi/asm-generic/unistd.h</i>
&nbsp;
&nbsp;
&nbsp;
<i>#-----------------------------------------------------------------------------</i>
.section .data
&nbsp;
message:
        .string "Diamons are forever!\n"
end_string:
&nbsp;
<i>#-----------------------------------------------------------------------------</i>
.section .bss
&nbsp;
&nbsp;
&nbsp;
<i>#-----------------------------------------------------------------------------</i>
.section .text
        .global _start          <i>// tento symbol ma byt dostupny i linkeru</i>
&nbsp;
_start:
&nbsp;
loop:
        mov  x8, #sys_write     <i>// cislo sycallu pro funkci "write"</i>
        mov  x0, #1             <i>// standardni vystup</i>
        ldr  x1, =message       <i>// adresa retezce, ktery se ma vytisknout</i>
        mov  x2, #(end_string-message)   <i>// pocet znaku, ktere se maji vytisknout</i>
        svc  0                  <i>// volani Linuxoveho kernelu</i>
&nbsp;
        b    loop               <i>// dokolecka dokola</i>
</pre>

<p><div class="rs-tip-major">Poznámka: vůbec není nutné řešit
&bdquo;korektní&ldquo; ukončení aplikace, protože žádná instrukce za
<strong>B</strong> se neprovede.</div></p>

<p>Tento program bude přeložen následujícím způsobem:</p>

<pre>
   0:   d2800808        mov     x8, #0x40                       // #64
   4:   d2800020        mov     x0, #0x1                        // #1
   8:   58000101        ldr     x1, 28 &lt;_start+0x28&gt;
   c:   d28002c2        mov     x2, #0x16                       // #22
  10:   d4000001        svc     #0x0
  14:   17fffffb        <strong>b       0 &lt;_start&gt;</strong>
  18:   d2800ba8        mov     x8, #0x5d                       // #93
  1c:   d2800000        mov     x0, #0x0                        // #0
  20:   d4000001        svc     #0x0
</pre>

<p>Podívejme se na instrukci <strong>b</strong>, která je přeložena do:</p>

<pre>
  14:   17fffffb
</pre>

<p>Neboli binárně:</p>

<pre>
0001 0111 1111 1111 1111 1111 1111 1011
</pre>

<p>Víme již, že nejvyšších šest bitů je konstanta (samotný kód instrukce):</p>

<pre>
000101
</pre>

<p>Následuje adresa 1111.....1011, tj.&nbsp;hodnota zapsaná ve dvojkovém
doplňku. Jedná se o zápornou hodnotu, takže vypočteme její jedničkový a
následně dvojkový doplněk:</p>

<pre>
orig       11 1111 1111 1111 1111 1111 1011
1 doplněk  00 0000 0000 0000 0000 0000 0100
2 doplněk  00 0000 0000 0000 0000 0000 0101
</pre>

<p>Jedná se tedy o skok <i>zpět</i> o 0101=5&times;4=20 bajtů počítaných od
instrukce skoku. To přesně odpovídá skutečnosti, protože instrukce skoku je
uložena na adrese 0x14=20, takže skok je proveden na instrukci uložené na
adrese 0 (v&nbsp;rámci kódového segmentu):</p>

<pre>
   0:   d2800808        mov     x8, #0x40                       // #64
   4:   d2800020        mov     x0, #0x1                        // #1
   8:   58000101        ldr     x1, 28 &lt;_start+0x28&gt;
   c:   d28002c2        mov     x2, #0x16                       // #22
  10:   d4000001        svc     #0x0
  14:   17fffffb        <strong>b       0 &lt;_start&gt;</strong>
</pre>



<p><a name="k03"></a></p>
<h2 id="k03">3. Adresace u instrukce podmíněného skoku</h2>

<pre>
<i># asmsyntax=as</i>
&nbsp;
<i># Testovaci program naprogramovany v assembleru GNU as</i>
<i># - pocitana programova smycka</i>
<i># - uprava pro mikroprocesory s architekturou AArch64</i>
<i>#</i>
<i># Autor: Pavel Tisnovsky</i>
&nbsp;
&nbsp;
&nbsp;
<i># Linux kernel system call table</i>
sys_exit   = 93
sys_write  = 64
&nbsp;
<i># List of syscalls for AArch64:</i>
<i># https://github.com/torvalds/linux/blob/master/include/uapi/asm-generic/unistd.h</i>
&nbsp;
<i># Dalsi konstanty pouzite v programu - standardni streamy</i>
std_input  = 0
std_output = 1
&nbsp;
<i># pocet opakovani znaku</i>
rep_count  = 40
&nbsp;
&nbsp;
&nbsp;
<i>#-----------------------------------------------------------------------------</i>
.section .data
&nbsp;
&nbsp;
&nbsp;
<i>#-----------------------------------------------------------------------------</i>
.section .bss
        .lcomm buffer, rep_count     <i>// rezervace bufferu pro vystup</i>
&nbsp;
&nbsp;
&nbsp;
<i>#-----------------------------------------------------------------------------</i>
.section .text
        .global _start               <i>// tento symbol ma byt dostupny i linkeru</i>
&nbsp;
_start:
        ldr   x1, =buffer            <i>// zapis se bude provadet do tohoto bufferu</i>
        mov   x2, #rep_count         <i>// pocet opakovani znaku</i>
        mov   w3, #'*'               <i>// zapisovany znak</i>
loop:
        strb  w3, [x1]               <i>// zapis znaku do bufferu</i>
        add   x1, x1, #1             <i>// uprava ukazatele do bufferu</i>
        sub   x2, x2, #1             <i>// zmenseni pocitadla</i>
        cmp   x2, #0                 <i>// otestovani, zda jsme jiz nedosahli nuly</i>
        bne   loop                   <i>// pokud jsme se nedostali k nule, skok na zacatek smycky</i>
&nbsp;
        mov   x8, #sys_write         <i>// cislo syscallu pro funkci "write"</i>
        mov   x0, #std_output        <i>// standardni vystup</i>
        ldr   x1, =buffer            <i>// adresa retezce, ktery se ma vytisknout</i>
        mov   x2, #rep_count         <i>// pocet znaku, ktere se maji vytisknout</i>
        svc   0                      <i>// volani Linuxoveho kernelu</i>
&nbsp;
        mov   x8, #sys_exit          <i>// cislo sycallu pro funkci "exit"</i>
        mov   x0, #0                 <i>// exit code = 0</i>
        svc   0                      <i>// volani Linuxoveho kernelu</i>
</pre>

<p>Překlad tohoto demonstračního příkladu provedeme nám již známým způsobem (zde se jednotlivé architektury od sebe prakticky neodlišují):</p>

<pre>
$ <strong>as loop1-aarch64-v1.s -o loop1-aarch64-v1.o</strong>
$ <strong>ld -s loop1-aarch64-v1.o</strong>
</pre>

<p>Zpětný překlad lze získat klasickým &bdquo;disassemblingem&ldquo;:</p>

<pre>
$ <strong>objdump -f -d -t -h a.out</strong>
</pre>

<p>Výstup z&nbsp;disassembleru bude vypadat následovně:</p>

<pre>
a.out:     file format elf64-littleaarch64
architecture: aarch64, flags 0x00000102:
EXEC_P, D_PAGED
start address 0x00000000004000b0

Sections:
Idx Name          Size      VMA               LMA               File off  Algn
  0 .text         00000048  00000000004000b0  00000000004000b0  000000b0  2**3
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  1 .bss          00000028  00000000004100f8  00000000004100f8  000000f8  2**3
                  ALLOC
SYMBOL TABLE:
no symbols



Disassembly of section .text:

00000000004000b0 <.text>:
  4000b0:       58000201        ldr     x1, 0x4000f0
  4000b4:       d2800502        mov     x2, #0x28                       // #40
  4000b8:       52800543        mov     w3, #0x2a                       // #42
  4000bc:       39000023        strb    w3, [x1]
  4000c0:       91000421        add     x1, x1, #0x1
  4000c4:       d1000442        sub     x2, x2, #0x1
  4000c8:       f100005f        cmp     x2, #0x0
  4000cc:       54ffff81        b.ne    0x4000bc  // b.any
  4000d0:       d2800808        mov     x8, #0x40                       // #64
  4000d4:       d2800020        mov     x0, #0x1                        // #1
  4000d8:       580000c1        ldr     x1, 0x4000f0
  4000dc:       d2800502        mov     x2, #0x28                       // #40
  4000e0:       d4000001        svc     #0x0
  4000e4:       d2800ba8        mov     x8, #0x5d                       // #93
  4000e8:       d2800000        mov     x0, #0x0                        // #0
  4000ec:       d4000001        svc     #0x0
  4000f0:       004100f8        .inst   0x004100f8 ; undefined
  4000f4:       00000000        udf     #0
</pre>

<p>Povšimněte si, že se ve zpětném překladu používá &bdquo;ARMovský&ldquo; zápis instrukce podmíněného skoku: <strong>B.NE</strong> namísto alternativního zápisu <strong>BNE</strong>, který jsme použili ve zdrojovém kódu.</p>



<p><a name="k04"></a></p>
<h2 id="k04">4. Druhá varianta zápisu programové smyčky bez explicitního testování nulové hodnoty počitadla</h2>

<p>Alternativní způsob zápisu programové smyčky spočívá v&nbsp;odstranění
explicitního testování nulové hodnoty počitadla instrukcí <strong>CMP</strong>.
Můžeme totiž využít toho, že se příznak <strong>Z (zero)</strong> může nastavit
automaticky již při dekrementaci hodnoty počitadla. Na procesorech ARM je
v&nbsp;tomto případě nutné namísto instrukce <strong>SUB</strong> použít
instrukci <strong>SUBS</strong>, kde poslední znak &bdquo;S&ldquo; znamená
&bdquo;set (flags)&ldquo;. Celá programová smyčka se nám zkrátí o jednu
instrukci, což může v&nbsp;praxi znamenat poměrně znatelné urychlení
(samozřejmě nikoli v&nbsp;našem jednoduchém příkladu, ale například při
výpočtech nad velkými poli se tato optimalizace již může projevit):</p>

<pre>
loop:
        strb  w3, [x1]               <i>// zapis znaku do bufferu</i>
        add   x1, x1, #1             <i>// uprava ukazatele do bufferu</i>
        subs  x2, x2, #1             <i>// zmenseni pocitadla a soucasne nastaveni priznaku</i>
        bne   loop                   <i>// pokud jsme se nedostali k nule, skok na zacatek smycky</i>
</pre>

<p>Následuje úplný zdrojový kód druhého demonstračního příkladu, v&nbsp;němž je
tato úprava provedena:</p>

<pre>
<i># asmsyntax=as</i>
&nbsp; 
<i># Testovaci program naprogramovany v assembleru GNU as</i>
<i># - pocitana programova smycka</i>
<i># - uprava pro mikroprocesory s architekturou AArch64</i>
<i>#</i>
<i># Autor: Pavel Tisnovsky</i>
&nbsp;
&nbsp;
&nbsp;
<i># Linux kernel system call table</i>
sys_exit   = 93
sys_write  = 64
&nbsp;
<i># List of syscalls for AArch64:</i>
<i># https://github.com/torvalds/linux/blob/master/include/uapi/asm-generic/unistd.h</i>
&nbsp;
<i># Dalsi konstanty pouzite v programu - standardni streamy</i>
std_input  = 0
std_output = 1
&nbsp;
<i># pocet opakovani znaku</i>
rep_count  = 40
&nbsp;
&nbsp;
&nbsp;
<i>#-----------------------------------------------------------------------------</i>
.section .data
&nbsp;
&nbsp;
&nbsp;
<i>#-----------------------------------------------------------------------------</i>
.section .bss
        .lcomm buffer, rep_count     <i>// rezervace bufferu pro vystup</i>
&nbsp;
&nbsp;
&nbsp;
<i>#-----------------------------------------------------------------------------</i>
.section .text
        .global _start               <i>// tento symbol ma byt dostupny i linkeru</i>
&nbsp;
_start:
        ldr   x1, =buffer            <i>// zapis se bude provadet do tohoto bufferu</i>
        mov   x2, #rep_count         <i>// pocet opakovani znaku</i>
        mov   w3, #'*'               <i>// zapisovany znak</i>
loop:
        strb  w3, [x1]               <i>// zapis znaku do bufferu</i>
        add   x1, x1, #1             <i>// uprava ukazatele do bufferu</i>
        subs  x2, x2, #1             <i>// zmenseni pocitadla a soucasne nastaveni priznaku</i>
        bne   loop                   <i>// pokud jsme se nedostali k nule, skok na zacatek smycky</i>
&nbsp;
        mov   x8, #sys_write         <i>// cislo syscallu pro funkci "write"</i>
        mov   x0, #std_output        <i>// standardni vystup</i>
        ldr   x1, =buffer            <i>// adresa retezce, ktery se ma vytisknout</i>
        mov   x2, #rep_count         <i>// pocet znaku, ktere se maji vytisknout</i>
        svc   0                      <i>// volani Linuxoveho kernelu</i>
&nbsp;
        mov   x8, #sys_exit          <i>// cislo sycallu pro funkci "exit"</i>
        mov   x0, #0                 <i>// exit code = 0</i>
        svc   0                      <i>// volani Linuxoveho kernelu</i>
</pre>



<p><a name="k05"></a></p>
<h2 id="k05">5. Test na ukončení smyčky na začátku každé iterace</h2>

<p>Další možná úprava programové smyčky spočívá v&nbsp;testu ukončení iterací
na jejím začátku. To je opět téma, kterému se budeme muset věnovat mnohem
podrobněji, takže si dnes pouze ukažme, jakým způsobem je možné tuto
programovou smyčku implementovat na architektuře AArch64. Samotná programová
smyčka končí nepodmíněným skokem na její začátek; instrukce nepodmíněného skoku
se jmenuje <strong>B</strong> (&bdquo;branch&ldquo;):</p>

<pre>
loop:
        sub   x2, x2, #1             <i>// zmenseni pocitadla</i>
        cmp   x2, #0                 <i>// otestovani, zda jsme jiz nedosahli nuly</i>
        beq   konec                  <i>// pokud jsme se dostali k nule, konec smycky</i>
        strb  w3, [x1]               <i>// zapis znaku do bufferu</i>
        add   x1, x1, #1             <i>// uprava ukazatele do bufferu</i>
        b     loop                   <i>// nepodmineny skok na zacatek smycky</i>
konec:
</pre>

<p><div class="rs-tip-major">Poznámka: sémantika je ovšem odlišná &ndash;
přenos dat nemusí v&nbsp;tomto případě proběhnout ani jednou.</div></p>

<p>Samozřejmě je opět možné vynechat instrukci <strong>CMP</strong> a nastavit
příznak <strong>zero</strong> přímo při dekrementaci počitadla:</p>

<pre>
loop:
        subs  x2, x2, #1             <i>// zmenseni pocitadla a nastaveni priznaku</i>
        beq   konec                  <i>// pokud jsme se dostali k nule, konec smycky</i>
        strb  w3, [x1]               <i>// zapis znaku do bufferu</i>
        add   x1, x1, #1             <i>// uprava ukazatele do bufferu</i>
        b     loop                   <i>// nepodmineny skok na zacatek smycky</i>
konec:
</pre>

<p>Další části programu mohou zůstat nezměněny.</p>



<p><a name="k06"></a></p>
<h2 id="k06">6. Instrukce <strong>CBZ</strong> a <strong>CBNZ</strong></h2>

<p>Instrukční sada procesorů s&nbsp;architekturou <i>AArch64</i> obsahuje i
některé instrukce, které byly dříve úspěšně otestovány
v&nbsp;&bdquo;komprimovaných&ldquo; instrukčních sadách <i>Thumb</i> a
<i>Thumb-2</i>. Do této oblasti spadají i nové typy podmíněných skoků. Ty se
totiž v&nbsp;mnoha případech ukazují být kritickou částí kódu, protože zejména
podmíněné skoky mohou přerušit jinak plynulý tok zpracovávaných instrukcí,
takže se z&nbsp;ideálního stavu, kdy RISCové jádro díky existenci pipeline
dokončí v&nbsp;každém cyklu jednu instrukci (v&nbsp;případě superskalárních
čipů Cortex-A i více instrukcí) můžeme dostat do stavu, kdy podmíněný skok
způsobí nutnost přerušit již zpracovávané instrukce a začít znovu (samozřejmě
s&nbsp;latencí).</p>

<p>Při analýze reálných aplikací si tvůrci instrukční sady <i>Thumb-2</i>
všimli si, že se v&nbsp;programech velmi často vyskytuje sekvence instrukcí,
které nejdřív porovnají obsah vybraného pracovního registru s&nbsp;nulou a
posléze provedou podmíněný skok na základě toho, zda je onen pracovní registr
skutečně nulový nebo naopak nenulový. Poměrně velké frekvenci této sekvence
instrukcí se nelze ani divit, protože podobným způsobem mohou být ve
vysokoúrovňových programovacích jazycích (sem počítám v&nbsp;kontextu článku i
céčko) implementovány například testy na hodnotu NULL, počítané smyčky, smyčky
typu do-while v&nbsp;nichž je pravdivostní hodnota vyjádřena celým číslem,
práce s&nbsp;ASCIIZ řetězci atd. Aby bylo možné zmenšit velikost binárního kódu
programu a současně ho i urychlit, byly do instrukční sady Thumb-2 přidány dvě
nové instrukce, které nejprve provedou porovnání pracovního registru
s&nbsp;nulou a poté provedou skok, pokud je registr nulový či naopak není
nulový. Součástí instrukčního slova je přitom i krátký offset umožňující
provést skok do vzdálenosti PC-1MB až PC+1MB (což by v&nbsp;rámci jednoho
podprogramu mělo naprosto bez problémů postačovat).</p>

<p>První z&nbsp;těchto instrukcí provede skok, pokud je vybraný pracovní
registr nulový:</p>

<pre>
CBZ Rn, offset   <i>; compare and branch if zero</i>
</pre>

<p>Tato instrukce je ekvivalentní delší sekvenci:</p>

<pre>
CMP Rn, #0
BEQ label
</pre>

<p>Druhá instrukce provádí skok v přesně opačném případě, tj.&nbsp;tehdy, když
má registr nenulovou hodnotu:</p>

<pre>
CBNZ Rn, offset   <i>; compare and branch if non zero</i>
</pre>

<p>Ekvivalentní zápis by tedy vypadal následovně:</p>

<pre>
CMP Rn, #0
BNE label
</pre>

<p><div class="rs-tip-major">Poznámka: cíl skoku je vypočten z&nbsp;offsetu
uloženého v&nbsp;devatenácti bitech. Hodnota offsetu je vynásobena čtyřmi,
takže skutečně dostáváme 21bitový rozsah relativních adres, tedy
&plusm;1MB.</div></p>



<p><a name="k07"></a></p>
<h2 id="k07">7. Úprava předchozího příkladu &ndash; použití instrukce <strong>CBNZ</strong></h2>

<p>Vzhledem k&nbsp;tomu, že se instrukce <strong>CBZ</strong> a
<strong>CBNZ</strong> mohou použít i u 64bitové architektury AArch64, upravíme
si předchozí demonstrační příklad takovým způsobem, aby se v&nbsp;něm tyto
instrukce využily. To znamená, že se namísto sekvence instrukcí:</p>

<pre>
        mov   x2, #rep_count         <i>// pocet opakovani programove smycky</i>
loop:
        ...
        ...
        ...
        sub   x2, x2, #1             <i>// zmenseni pocitadla</i>
        cmp   x2, #0                 <i>// otestovani, zda jsme jiz nedosahli nuly</i>
        bne   loop                   <i>// pokud jsme se nedostali k nule, skok na zacatek smycky</i>
</pre>

<p>Použije nová sekvence:</p>

<pre>
        mov   x2, #rep_count         <i>// pocet opakovani programove smycky</i>
loop:
        ...
        ...
        ...
        sub   x2, x2, #1             <i>// zmenseni pocitadla a soucasne nastaveni priznaku</i>
        cbnz  x2, loop               <i>// pokud jsme se nedostali k nule, skok na zacatek smycky</i>
</pre>

<p>Vidíme, že se nám podařilo smyčku zkrátit o jednu instrukci, takže jsme se
vlastně dostali do stejné situace, jako při použití dvojice
<strong>SUBS</strong> + podmíněný skok (jinými slovy &ndash; zde nám instrukce
<strong>CBNZ</strong> vlastně příliš nepomohla):</p>

<pre>
        mov   x2, #rep_count         <i>// pocet opakovani programove smycky</i>
loop:
        ...
        ...
        ...
        subs  x2, x2, #1             <i>// zmenseni pocitadla a soucasne nastaveni priznaku</i>
        bne   loop                   <i>// pokud jsme se nedostali k nule, skok na zacatek smycky</i>
</pre>

<p>Podívejme se nyní na způsob zařazení instrukce <strong>CBNZ</strong> do
celého programu, který po svém spuštění vygeneruje řetězec se čtyřiceti
hvězdičkami, který následně vytiskne na standardní výstup:</p>

<pre>
<i># asmsyntax=as</i>
&nbsp; 
<i># Testovaci program naprogramovany v assembleru GNU as</i>
<i># - pocitana programova smycka realizovana instrukci CBNZ</i>
<i># - uprava pro mikroprocesory s architekturou AArch64</i>
<i>#</i>
<i># Autor: Pavel Tisnovsky</i>
&nbsp;
&nbsp;
&nbsp;
<i># Linux kernel system call table</i>
sys_exit   = 93
sys_write  = 64
&nbsp;
<i># List of syscalls for AArch64:</i>
<i># https://github.com/torvalds/linux/blob/master/include/uapi/asm-generic/unistd.h</i>
&nbsp;
<i># Dalsi konstanty pouzite v programu - standardni streamy</i>
std_input  = 0
std_output = 1
&nbsp;
<i># pocet opakovani znaku</i>
rep_count  = 40
&nbsp;
&nbsp;
&nbsp;
<i>#-----------------------------------------------------------------------------</i>
.section .data
&nbsp;
&nbsp;
&nbsp;
<i>#-----------------------------------------------------------------------------</i>
.section .bss
        .lcomm buffer, rep_count     <i>// rezervace bufferu pro vystup</i>
&nbsp;
&nbsp;
&nbsp;
<i>#-----------------------------------------------------------------------------</i>
.section .text
        .global _start               <i>// tento symbol ma byt dostupny i linkeru</i>
&nbsp;
_start:
        ldr   x1, =buffer            <i>// zapis se bude provadet do tohoto bufferu</i>
        mov   x2, #rep_count         <i>// pocet opakovani znaku</i>
        mov   w3, #'*'               <i>// zapisovany znak</i>
loop:
        strb  w3, [x1]               <i>// zapis znaku do bufferu</i>
        add   x1, x1, #1             <i>// uprava ukazatele do bufferu</i>
        sub   x2, x2, #1             <i>// zmenseni pocitadla a soucasne nastaveni priznaku</i>
        <strong>cbnz  x2, loop</strong>               <i>// pokud jsme se nedostali k nule, skok na zacatek smycky</i>
&nbsp;
        mov   x8, #sys_write         <i>// cislo syscallu pro funkci "write"</i>
        mov   x0, #std_output        <i>// standardni vystup</i>
        ldr   x1, =buffer            <i>// adresa retezce, ktery se ma vytisknout</i>
        mov   x2, #rep_count         <i>// pocet znaku, ktere se maji vytisknout</i>
        svc   0                      <i>// volani Linuxoveho kernelu</i>
&nbsp;
        mov   x8, #sys_exit          <i>// cislo sycallu pro funkci "exit"</i>
        mov   x0, #0                 <i>// exit code = 0</i>
        svc   0                      <i>// volani Linuxoveho kernelu</i>
</pre>



<p><a name="k08"></a></p>
<h2 id="k08">8. Podpora pro zpracování polí: automatická změna adresy uložené v&nbsp;registru v&nbsp;instrukcích typu LOAD a STORE</h2>

<pre>
loop:
        strb  w3, [x1], 1            // zapis znaku do bufferu s post-inkrementaci adresy
        sub   x2, x2, #1             // zmenseni pocitadla a soucasne nastaveni priznaku
        cbnz  x2, loop               // pokud jsme se nedostali k nule, skok na zacatek smycky
</pre>



<p><a name="k09"></a></p>
<h2 id="k09">9. Úprava předchozích příkladů s&nbsp;využitím automatické změny adresy</h2>

<pre>
# asmsyntax=as
 
# Testovaci program naprogramovany v assembleru GNU as
# - pocitana programova smycka realizovana instrukci CBNZ
# - uprava pro mikroprocesory s architekturou AArch64
#
# Autor: Pavel Tisnovsky
 
 
 
# Linux kernel system call table
sys_exit   = 93
sys_write  = 64

# List of syscalls for AArch64:
# https://github.com/torvalds/linux/blob/master/include/uapi/asm-generic/unistd.h
 
# Dalsi konstanty pouzite v programu - standardni streamy
std_input  = 0
std_output = 1

# pocet opakovani znaku
rep_count  = 40
 
 
 
#-----------------------------------------------------------------------------
.section .data
 
 
 
#-----------------------------------------------------------------------------
.section .bss
        .lcomm buffer, rep_count     // rezervace bufferu pro vystup
 
 
 
#-----------------------------------------------------------------------------
.section .text
        .global _start               // tento symbol ma byt dostupny i linkeru
 
_start:
        ldr   x1, =buffer            // zapis se bude provadet do tohoto bufferu
        mov   x2, #rep_count         // pocet opakovani znaku
        mov   w3, #'*'               // zapisovany znak
loop:
        strb  w3, [x1], 1            // zapis znaku do bufferu s post-inkrementaci adresy
        sub   x2, x2, #1             // zmenseni pocitadla a soucasne nastaveni priznaku
        cbnz  x2, loop               // pokud jsme se nedostali k nule, skok na zacatek smycky
 
        mov   x8, #sys_write         // cislo syscallu pro funkci "write"
        mov   x0, #std_output        // standardni vystup
        ldr   x1, =buffer            // adresa retezce, ktery se ma vytisknout
        mov   x2, #rep_count         // pocet znaku, ktere se maji vytisknout
        svc   0                      // volani Linuxoveho kernelu
 
        mov   x8, #sys_exit          // cislo sycallu pro funkci "exit"
        mov   x0, #0                 // exit code = 0
        svc   0                      // volani Linuxoveho kernelu
</pre>



<p><a name="k10"></a></p>
<h2 id="k10">10. Přesuny bloků dat</h2>



<p><a name="k11"></a></p>
<h2 id="k11">11. Příklad realizace přesunu bloku dat</h2>

<pre>
# asmsyntax=as

# Presun bloku dat.
#
# Autor: Pavel Tisnovsky



# Linux kernel system call table
sys_exit=93
sys_write=64

# List of syscalls for AArch64:
# https://github.com/torvalds/linux/blob/master/include/uapi/asm-generic/unistd.h

# pocet bajtu
rep_count  = 13


#-----------------------------------------------------------------------------
.section .data

hello_lbl:
        .string "Hello World!\n"

buffer:
        .string "************\n"

#-----------------------------------------------------------------------------
.section .bss



#-----------------------------------------------------------------------------
.section .text
        .global _start          // tento symbol ma byt dostupny i linkeru

_start:
        mov  x8, #sys_write     // cislo sycallu pro funkci "write"
        mov  x0, #1             // standardni vystup
        ldr  x1, =buffer        // adresa retezce, ktery se ma vytisknout
        mov  x2, #rep_count     // pocet znaku, ktere se maji vytisknout
        svc  0                  // volani Linuxoveho kernelu

        ldr   x1, =hello_lbl    // adresa bloku pro cteni
        ldr   x2, =buffer       // adresa bloku pro zapis
        mov   x4, #rep_count    // pocet bajtu
loop:
        ldrb  w3, [x1], 1       // cteni bajtu
        strb  w3, [x2], 1       // zapis bajtu
        sub   x4, x4, #1        // zmenseni pocitadla a soucasne nastaveni priznaku
        cbnz  x4, loop          // pokud jsme se nedostali k nule, skok na zacatek smycky

        mov  x8, #sys_write     // cislo sycallu pro funkci "write"
        mov  x0, #1             // standardni vystup
        ldr  x1, =buffer        // adresa retezce, ktery se ma vytisknout
        mov  x2, #rep_count     // pocet znaku, ktere se maji vytisknout
        svc  0                  // volani Linuxoveho kernelu

        mov  x8, #sys_exit      // cislo sycallu pro funkci "exit"
        mov  x0, #0             // exit code = 0
        svc  0                  // volani Linuxoveho kernelu
</pre>



<p><a name="k12"></a></p>
<h2 id="k12">12. Zjednodušení zápisu kódu v&nbsp;assembleru s&nbsp;využitím maker</h2>

<p>Nástroje typu &bdquo;assembler&ldquo; je možné podle principu jejich práce
rozdělit do několika kategorií. Do první kategorie spadají assemblery
<i>interaktivní</i>, které uživateli nabízejí poměrně komfortní vývojové
prostředí, v&nbsp;němž je v&nbsp;případě potřeby možné zapisovat jednotlivé
instrukce, spouštět programy, krokovat je, vypisovat obsahy pracovních registrů
mikroprocesoru, prohlížet si obsah operační paměti, zásobníku atd. Velkou
výhodou byla nezávislost těchto assemblerů na rychlém externím paměťovém médiu,
proto jsme se s&nbsp;nimi mohli setkat například na osmibitových domácích
mikropočítačích či dnes na různých zařízeních typu IoT (i když zde úlohu
pouhého interaktivního assembleru mnohdy přebírá interaktivní debugger). Druhý
typ assemblerů je široce používán dodnes &ndash; jedná se vlastně o běžné
překladače, kterým se na vstupu předloží zdrojový kód a po překladu se výsledný
nativní kód taktéž uloží na paměťové médium (odkud ho lze přímo spustit, což se
dělo například v&nbsp;operačním systému DOS, popř.&nbsp;ho ještě před spuštěním
slinkovat, což je případ Linuxu a dalších moderních operačních systémů).</p>

<a href="http://www.root.cz/obrazek/211572/"><img src="http://i.iinfo.cz/images/524/a3-prev.png" class="image-211572" alt="&#160;" height="264" width="370" /></a></p>
<p><i>Obrázek 1: Vývojové prostředí Atari Macro Assembleru (výpis obsahu
pracovních registrů mikroprocesoru). Jedná se o jeden z&nbsp;interaktivních
assemblerů.</i></p>

<p>Assemblery spadající do druhé kategorie jsou mnohdy vybaveny více či méně
dokonalým systémem maker; odtud ostatně pochází i jejich často používané
označení <i>macroassembler</i>. Makra, která se většinou aplikují na zdrojový
kód v&nbsp;první fázi překladu, je možné použít pro různé činnosti, ať již se
jedná o zjednodušení zápisu kódu či o jeho zkrácení a zpřehlednění. Existují
například sady poměrně složitých maker, která do assembleru přidávají některé
konstrukce známé z&nbsp;vyšších programovacích jazyků &ndash; rozvětvení,
programové smyčky, deklaraci objektů atd. <i>GNU Assembler</i>, podobně jako
prakticky všechny další moderní assemblery, práci s&nbsp;makry podporují, i
když se způsob zápisu maker i jejich základní vlastnosti od sebe odlišují.
Z&nbsp;tohoto důvodu se v&nbsp;navazujících kapitolách budeme věnovat
(prozatím) pouze makrům v&nbsp;<i>GNU Assembleru</i>. Ukážeme si i řešení
některých častých problémů, které mohou při deklaraci maker nastat, například
práci s&nbsp;návěštími (labels) apod.</p>

<a href="http://www.root.cz/obrazek/210813/"><img src="http://i.iinfo.cz/images/462/dev-8bit-9-prev.png" class="image-210813" width="370" height="264" alt="&#160;" /></a>
<p><i>Obrázek 2: Takto vypadá úryvek programu napsaný v&nbsp;assembleru
mikroprocesoru MOS 6502.</i></p>



<p><a name="k13"></a></p>
<h2 id="k13">13. Vytvoření jednoduchého makra bez parametrů</h2>

<p>Makra v&nbsp;assembleru, tedy i v&nbsp;námi používaném <i>GNU
Assembleru</i>, provádí textové substituce, což mj.&nbsp;znamená, že expanze
maker je vykonána v&nbsp;první fázi překladu. V&nbsp;GNU Assembleru deklarace
makra začíná direktivou <strong>.macro</strong> a končí direktivou
<strong>.endm</strong> (obě zmíněné direktivy se zapisují včetně teček na
začátku). Za direktivou <strong>.macro</strong> musí následovat jméno makra a
popř.&nbsp;i jeho parametry. Na dalších řádcích je pak vlastní text makra.
Použití makra je ještě jednodušší než jeho deklarace &ndash; kdekoli se prostě
uvede jméno makra s&nbsp;případnými parametry. Jakmile GNU Assembler zjistí, že
se ve zdrojovém kódu nachází jméno makra, provede jeho expanzi, takže se
vlastně případné instrukce, ze kterých se text makra skládá, přímo vloží do
kódu na místo volání makra.</p>

<p>Podívejme se nyní na velmi jednoduchý demonstrační příklad, kterým je makro
bez parametrů. Toto makro jsme nazvali <strong>exit</strong> a v&nbsp;jeho těle
se zavolá <i>syscall</i> (funkce jádra) sloužící k&nbsp;ukončení procesu:</p>

<pre>
<i># Deklarace makra pro ukonceni aplikace</i>
.macro <strong>exit</strong>
        mov  x8, #sys_exit      <i>// cislo sycallu pro funkci "exit"</i>
        mov  x0, #0             <i>// exit code = 0</i>
        svc  0                  <i>// volani Linuxoveho kernelu</i>
.endm
</pre>

<p>Povšimněte si, že v&nbsp;těle makra se může nacházet libovolný text, včetně
komentářů, symbolů deklarovaných mimo makro (sys_exit) atd. Volání makra
nazvaného <strong>exit</strong> vypadá takto:</p>

<pre>
<i>#-----------------------------------------------------------------------------</i>
.section .text
        .global _start               <i>// tento symbol ma byt dostupny i linkeru</i>
&nbsp;
_start:
        ...
        libovolné instrukce či volání jiných maker
        ...
        <strong>exit</strong>                         <i>// ukonceni aplikace</i>
</pre>

<p><div class="rs-tip-major">Poznámka: ve skutečnosti se nejedná o volání makra
ve smyslu volání subrutiny (podprogramu), ale skutečně pouze o textovou expanzi
prováděnou v&nbsp;době překladu programu ze zdrojového kódu do kódu
objektového.</div></p>

<p>Šablonu z&nbsp;úvodního článku tedy můžeme upravit do podoby:</p>

<pre>
<i># asmsyntax=as</i>
&nbsp;
<i># Sablona pro zdrojovy kod Linuxoveho programu naprogramovaneho</i>
<i># v assembleru GNU AS pro architekturu AArch64.</i>
<i>#</i>
<i># Autor: Pavel Tisnovsky</i>
&nbsp;
&nbsp;
&nbsp;
<i># Linux kernel system call table</i>
sys_exit=93
&nbsp;
<i># List of syscalls for AArch64:</i>
<i># https://github.com/torvalds/linux/blob/master/include/uapi/asm-generic/unistd.h</i>
&nbsp;
&nbsp;
<i># Deklarace makra pro ukonceni aplikace</i>
.macro <strong>exit</strong>
        mov  x8, #sys_exit      <i>// cislo sycallu pro funkci "exit"</i>
        mov  x0, #0             <i>// exit code = 0</i>
        svc  0                  <i>// volani Linuxoveho kernelu</i>
.endm
&nbsp;
&nbsp;
<i>#-----------------------------------------------------------------------------</i>
.section .data
&nbsp;
&nbsp;
&nbsp;
<i>#-----------------------------------------------------------------------------</i>
.section .bss
&nbsp;
&nbsp;
&nbsp;
<i>#-----------------------------------------------------------------------------</i>
.section .text
        .global _start          <i>// tento symbol ma byt dostupny i z linkeru</i>
&nbsp;
_start:
        <strong>exit</strong>
</pre>



<p><a name="k14"></a></p>
<h2 id="k14">14. Vytvoření makra s&nbsp;parametry</h2>

<p>Makra mohou v&nbsp;případě potřeby (a ta je poměrně častá) akceptovat i
parametry, ovšem práce s&nbsp;nimi může být zpočátku poněkud neobvyklá. Jména
parametrů se zadávají již v&nbsp;hlavičce makra přímo za jeho názvem, tedy
následujícím způsobem:</p>

<pre>
.macro <strong>jméno_makra</strong> parametr1, parametr2, ...
</pre>

<p>Důležitější ovšem je, že přímo v&nbsp;těle makra se před jméno parametru
musí vložit znak zpětného lomítka, jinak nedojde k&nbsp;náhradě názvu parametru
jeho skutečným obsahem (to má svůj význam, protože nemůže nastat situace, že by
se nějaký text nahrazoval parametrem makra omylem). Podívejme se na praktický
příklad &ndash; konkrétně na makro určené pro výpis zprávy na standardní
výstup. Tomuto makru se předává adresa řetězce a jeho délka. Uvnitř těla makra
se před parametry skutečně zapisuje zpětné lomítko:</p>

<pre>
<i># Deklarace makra pro vytisteni zpravy na standardni vystup</i>
.macro <strong>writeMessage message,messageLength</strong>
<i>        mov  x8, #sys_write       // cislo sycallu pro funkci "write"</i>
<i>        mov  x0, #1               // standardni vystup</i>
<i>        ldr  x1, =<strong>\message</strong>        // adresa retezce, ktery se ma vytisknout</i>
<i>        mov  x2, #<strong>\messageLength</strong>  // pocet znaku, ktere se maji vytisknout</i>
<i>        svc  0                    // volani Linuxoveho kernelu</i>
.endm
</pre>

<p>Příklad volání tohoto makra:</p>

<pre>
<strong>writeMessage buffer, rep_count</strong>
</pre>

<p><div class="rs-tip-major">Poznámka: to už vypadá podobně, jako by se program
zapisoval ve vyšším programovacím jazyce :-).</div></p>

<p>Aplikaci typu &bdquo;Hello, world!&ldquo;, s&nbsp;níž jsme se opět seznámili
minule, lze tedy přepsat do podoby využívající makra:</p>

<pre>
<i># asmsyntax=as</i>
&nbsp;
<i># Jednoducha aplikace typu "Hello world!" naprogramovana</i>
<i># v assembleru GNU as.</i>
<i>#</i>
<i># Autor: Pavel Tisnovsky</i>
&nbsp;
&nbsp;
&nbsp;
<i># Linux kernel system call table</i>
sys_exit=93
sys_write=64
&nbsp;
<i># List of syscalls for AArch64:</i>
<i># https://github.com/torvalds/linux/blob/master/include/uapi/asm-generic/unistd.h</i>
&nbsp;
&nbsp;
<i># Deklarace makra pro ukonceni aplikace</i>
.macro <strong>exit</strong>
        mov  x8, #sys_exit      <i>// cislo sycallu pro funkci "exit"</i>
        mov  x0, #0             <i>// exit code = 0</i>
        svc  0                  <i>// volani Linuxoveho kernelu</i>
.endm
&nbsp;
&nbsp;
<i># Deklarace makra pro vytisteni zpravy na standardni vystup</i>
.macro <strong>writeMessage message,messageLength</strong>
        mov  x8, #sys_write       <i>// cislo sycallu pro funkci "write"</i>
        mov  x0, #1               <i>// standardni vystup</i>
        ldr  x1, =\message        <i>// adresa retezce, ktery se ma vytisknout</i>
        mov  x2, #\messageLength  <i>// pocet znaku, ktere se maji vytisknout</i>
        svc  0                    <i>// volani Linuxoveho kernelu</i>
.endm
&nbsp;
&nbsp;
<i>#-----------------------------------------------------------------------------</i>
.section .data
&nbsp;
hello_lbl:
        .string "Hello World!\n"
&nbsp;
<i>#-----------------------------------------------------------------------------</i>
.section .bss
&nbsp;
&nbsp;
&nbsp;
<i>#-----------------------------------------------------------------------------</i>
.section .text
<i>        .global _start          // tento symbol ma byt dostupny i linkeru</i>
&nbsp;
_start:
        <strong>writeMessage hello_lbl, 13</strong>
        <strong>exit</strong>
</pre>



<p><a name="k15"></a></p>
<h2 id="k15">15. Výpis zdrojového kódu po expanzi maker a překladu</h2>

<p>Při zápisu maker či při jejich volání může dojít k&nbsp;situaci, kdy se
makro neexpanduje podle našich předpokladů a je nutné zjistit, kde přesně
nastal problém. GNU Assembler sice neexpanduje makra samostatným preprocesorem
(jak je tomu v&nbsp;céčku a jeho preprocesoru nazvaném <strong>cpp</strong>),
ovšem obsahuje možnost nechat si vygenerovat výpis původního zdrojového kódu
kombinovaného s&nbsp;přeloženým objektovým kódem, přesněji řečeno
s&nbsp;objektovým kódem zapsaným v&nbsp;hexadecimálním tvaru. Jedná se o mnohdy
velmi užitečnou vlastnost, kterou nalezneme u mnoha assemblerů, a to i u
některých starších nástrojů. Takový výpis se na historických mainframech bez
obrazovky většinou posílal přímo na tiskárnu, takže obsahoval i vepsané chyby
nalezené překladačem. A právě v&nbsp;tomto výpisu se mohou objevit expandovaná
makra. Podívejme se, co se stane, pokud při překladu použijeme volbu
<strong>-alm</strong> (resp.&nbsp;volbu <strong>-a</strong> s&nbsp;dalšími
příznaky <strong>l</strong> a <strong>m</strong>) kombinovanou s&nbsp;volbou
<strong>-g</strong>:</p>

<pre>
$ <strong>as -alm -g hello_world_3.s -o hello_world_3.o</strong>
</pre>

<p>Na standardní výstup by se měl vypsat následující výpis:</p>

<pre>
AARCH64 GAS  hello_world_3.s                    page 1
&nbsp;
&nbsp;
   1                    # asmsyntax=as
   2                    
   3                    # Jednoducha aplikace typu "Hello world!" naprogramovana
   4                    # v assembleru GNU as.
   5                    #
   6                    # Autor: Pavel Tisnovsky
   7                    
   8                    
   9                    
  10                    # Linux kernel system call table
  11                    sys_exit=93
  12                    sys_write=64
  13                    
  14                    # List of syscalls for AArch64:
  15                    # https://github.com/torvalds/linux/blob/master/include/uapi/asm-generic/unistd.h
  16                    
  17                    
  18                    # Deklarace makra pro ukonceni aplikace
  19                    .macro exit
  20                            mov  x8, #sys_exit      // cislo sycallu pro funkci "exit"
  21                            mov  x0, #0             // exit code = 0
  22                            svc  0                  // volani Linuxoveho kernelu
  23                    .endm
  24                    
  25                    
  26                    # Deklarace makra pro vytisteni zpravy na standardni vystup
  27                    .macro writeMessage message,messageLength
  28                            mov  x8, #sys_write       // cislo sycallu pro funkci "write"
  29                            mov  x0, #1               // standardni vystup
  30                            ldr  x1, =\message        // adresa retezce, ktery se ma vytisknout
  31                            mov  x2, #\messageLength  // pocet znaku, ktere se maji vytisknout
  32                            svc  0                    // volani Linuxoveho kernelu
  33                    .endm
  34                    
  35                    
  36                    #-----------------------------------------------------------------------------
  37                    .section .data
  38                    
  39                    hello_lbl:
  40 0000 48656C6C              .string "Hello World!\n"
  40      6F20576F 
  40      726C6421 
  40      0A00
  41                    
  42                    #-----------------------------------------------------------------------------
  43                    .section .bss
  44                    
  45                    
  46                    
  47                    #-----------------------------------------------------------------------------
  48                    .section .text
  49                            .global _start          // tento symbol ma byt dostupny i linkeru
  50                    
  51                    _start:
  52                            writeMessage hello_lbl, 13
  52 0000 080880D2      &gt;  mov x8,#sys_write
  52 0004 200080D2      &gt;  mov x0,#1
&nbsp;
&nbsp;
AARCH64 GAS  hello_world_3.s                  page 2
&nbsp;
&nbsp;
  52 0008 C1000058      &gt;  ldr x1,=hello_lbl
  52 000c A20180D2      &gt;  mov x2,#13
  52 0010 010000D4      &gt;  svc 0
  53                            exit
  53 0014 A80B80D2      &gt;  mov x8,#sys_exit
  53 0018 000080D2      &gt;  mov x0,#0
  53 001c 010000D4      &gt;  svc 0
  53      00000000 
  53      00000000 
</pre>

<p><div class="rs-tip-major">Poznámka: vidíme, že se skutečně jedná o
formátovaný výstup určený pro tisk, ovšem podstatné je, že došlo jak
k&nbsp;expanzi maker, tak i k&nbsp;umístění značek &gt; do těch částí kódu, kde
byla makra umístěna.</div></p>



<p><a name="k16"></a></p>
<h2 id="k16">16. Makro pro přesun bloku dat po bajtech</h2>

<p>Na základě předchozích příkladů se můžeme pokusit o vytvoření makra určeného
pro přesun bloku dat (prozatím po bajtech). Toto makro by mělo akceptovat
trojici parametrů &ndash; počáteční adresu zdrojového bloku, adresu, kam se má
blok přesunout a počet přesouvaných bajtů. První (a již na tomto místě nutno
říci, že nekorektní) varianta tohoto makra by mohla vypadat následovně:</p>

<pre>
<i># Deklarace makra pro presun bloku</i>
.macro <strong>moveBlock from, to, length</strong>
        ldr   x1, =\from        <i>// adresa bloku pro cteni</i>
        ldr   x2, =\to          <i>// adresa bloku pro zapis</i>
        mov   x4, #\length      <i>// pocet bajtu</i>
loop:
        ldrb  w3, [x1], 1       <i>// cteni bajtu</i>
        strb  w3, [x2], 1       <i>// zapis bajtu</i>
        sub   x4, x4, #1        <i>// zmenseni pocitadla a soucasne nastaveni priznaku</i>
        cbnz  x4, loop          <i>// pokud jsme se nedostali k nule, skok na zacatek smycky</i>
.endm
</pre>

<p>Celý příklad můžeme upravit takovým způsobem, že se sekvence instrukcí
v&nbsp;hlavním programu vlastně celá nahradí makry, což (zdánlivě) začíná
připomínat vysokoúrovňové programovací jazyky (které se ostatně vyvíjely právě
od makroassemblerů):</p>

<pre>
<strong>writeMessage buffer, rep_count</strong>
&nbsp;
<strong>moveBlock hello_lbl, buffer, rep_count</strong>
&nbsp;
<strong>writeMessage buffer, rep_count</strong>
&nbsp;
<strong>exit</strong>
</pre>

<p>Úplný zdrojový kód tohoto demonstračního příkladu:</p>

<pre>
<i># asmsyntax=as</i>
&nbsp;
<i># Presun bloku dat.</i>
<i>#</i>
<i># Autor: Pavel Tisnovsky</i>
&nbsp;
&nbsp;
&nbsp;
<i># Linux kernel system call table</i>
sys_exit=93
sys_write=64
&nbsp;
<i># List of syscalls for AArch64:</i>
<i># https://github.com/torvalds/linux/blob/master/include/uapi/asm-generic/unistd.h</i>
&nbsp;
<i># pocet bajtu</i>
rep_count  = 13
&nbsp;
&nbsp;
<i># Deklarace makra pro ukonceni aplikace</i>
.macro <strong>exit</strong>
        mov  x8, #sys_exit      <i>// cislo sycallu pro funkci "exit"</i>
        mov  x0, #0             <i>// exit code = 0</i>
        svc  0                  <i>// volani Linuxoveho kernelu</i>
.endm
&nbsp;
&nbsp;
&nbsp;
<i># Deklarace makra pro vytisteni zpravy na standardni vystup</i>
.macro <strong>writeMessage message,messageLength</strong>
        mov  x8, #sys_write       <i>// cislo sycallu pro funkci "write"</i>
        mov  x0, #1               <i>// standardni vystup</i>
        ldr  x1, =\message        <i>// adresa retezce, ktery se ma vytisknout</i>
        mov  x2, #\messageLength  <i>// pocet znaku, ktere se maji vytisknout</i>
        svc  0                    <i>// volani Linuxoveho kernelu</i>
.endm
&nbsp;
&nbsp;
<i># Deklarace makra pro presun bloku</i>
.macro <strong>moveBlock from,to,length</strong>
        ldr   x1, =\from        <i>// adresa bloku pro cteni</i>
        ldr   x2, =\to          <i>// adresa bloku pro zapis</i>
        mov   x4, #\length      <i>// pocet bajtu</i>
loop:
        ldrb  w3, [x1], 1       <i>// cteni bajtu</i>
        strb  w3, [x2], 1       <i>// zapis bajtu</i>
        sub   x4, x4, #1        <i>// zmenseni pocitadla a soucasne nastaveni priznaku</i>
        cbnz  x4, loop          <i>// pokud jsme se nedostali k nule, skok na zacatek smycky</i>
.endm
&nbsp;
&nbsp;
&nbsp;
<i>#-----------------------------------------------------------------------------</i>
.section .data
&nbsp;
hello_lbl:
        .string "Hello World!\n"
&nbsp;
buffer:
        .string "************\n"
&nbsp;
<i>#-----------------------------------------------------------------------------</i>
.section .bss
&nbsp;
&nbsp;
&nbsp;
<i>#-----------------------------------------------------------------------------</i>
.section .text
        .global _start          <i>// tento symbol ma byt dostupny i linkeru</i>
&nbsp;
_start:
        <strong>writeMessage buffer, rep_count</strong>
&nbsp;
        <strong>moveBlock hello_lbl, buffer, rep_count</strong>
&nbsp;
        <strong>writeMessage buffer, rep_count</strong>
&nbsp;
        <strong>exit</strong>
</pre>



<p><a name="k17"></a></p>
<h2 id="k17">17. Použití návěští v&nbsp;makrech</h2>

<p>V&nbsp;tělech mnoha maker se používají instrukce skoku, což
mj.&nbsp;znamená, že se mnohdy nevyhneme použití návěští. Což je ostatně přesně
náš případ. Podívejme se, kde vlastně vězí celý problém:</p>

<pre>
<i># Deklarace makra pro presun bloku</i>
.macro <strong>moveBlock from, to, length</strong>
        ldr   x1, =\from        <i>// adresa bloku pro cteni</i>
        ldr   x2, =\to          <i>// adresa bloku pro zapis</i>
        mov   x4, #\length      <i>// pocet bajtu</i>
loop:
        ldrb  w3, [x1], 1       <i>// cteni bajtu</i>
        strb  w3, [x2], 1       <i>// zapis bajtu</i>
        sub   x4, x4, #1        <i>// zmenseni pocitadla a soucasne nastaveni priznaku</i>
        cbnz  x4, loop          <i>// pokud jsme se nedostali k nule, skok na zacatek smycky</i>
.endm
</pre>

<p>Toto makro sice bude (alespoň zdánlivě) fungovat, ale pouze v&nbsp;tom
případě, že bude použito jen jedinkrát. Pokud makro použijeme dvakrát (či
samozřejmě vícekrát), vytvoří se v&nbsp;překládaném kódu větší množství návěští
se shodným názvem <strong>loop</strong>, což samozřejmě povede k&nbsp;chybě při
překladu. Ostatně můžeme si to vyzkoušet v&nbsp;dalším demonstračním příkladu,
kde přesouváme stejný blok dvakrát za sebou (zmíněná část kódu je dvakrát
podtržena):</p>

<pre>
<i># asmsyntax=as</i>
&nbsp;
<i># Presun bloku dat.</i>
<i>#</i>
<i># Autor: Pavel Tisnovsky</i>
&nbsp;
&nbsp;
&nbsp;
<i># Linux kernel system call table</i>
sys_exit=93
sys_write=64
&nbsp;
<i># List of syscalls for AArch64:</i>
<i># https://github.com/torvalds/linux/blob/master/include/uapi/asm-generic/unistd.h</i>
&nbsp;
<i># pocet bajtu</i>
rep_count  = 13
&nbsp;
&nbsp;
<i># Deklarace makra pro ukonceni aplikace</i>
.macro <strong>exit</strong>
        mov  x8, #sys_exit      <i>// cislo sycallu pro funkci "exit"</i>
        mov  x0, #0             <i>// exit code = 0</i>
        svc  0                  <i>// volani Linuxoveho kernelu</i>
.endm
&nbsp;
&nbsp;
&nbsp;
<i># Deklarace makra pro vytisteni zpravy na standardni vystup</i>
.macro <strong>writeMessage message,messageLength</strong>
        mov  x8, #sys_write       <i>// cislo sycallu pro funkci "write"</i>
        mov  x0, #1               <i>// standardni vystup</i>
        ldr  x1, =\message        <i>// adresa retezce, ktery se ma vytisknout</i>
        mov  x2, #\messageLength  <i>// pocet znaku, ktere se maji vytisknout</i>
        svc  0                    <i>// volani Linuxoveho kernelu</i>
.endm
&nbsp;
&nbsp;
<i># Deklarace makra pro presun bloku</i>
.macro <strong>moveBlock from,to,length</strong>
        ldr   x1, =\from        <i>// adresa bloku pro cteni</i>
        ldr   x2, =\to          <i>// adresa bloku pro zapis</i>
        mov   x4, #\length      <i>// pocet bajtu</i>
loop:
        ldrb  w3, [x1], 1       <i>// cteni bajtu</i>
        strb  w3, [x2], 1       <i>// zapis bajtu</i>
        sub   x4, x4, #1        <i>// zmenseni pocitadla a soucasne nastaveni priznaku</i>
        cbnz  x4, loop          <i>// pokud jsme se nedostali k nule, skok na zacatek smycky</i>
.endm
&nbsp;
&nbsp;
&nbsp;
<i>#-----------------------------------------------------------------------------</i>
.section .data
&nbsp;
hello_lbl:
        .string "Hello World!\n"
&nbsp;
buffer:
        .string "************\n"
&nbsp;
<i>#-----------------------------------------------------------------------------</i>
.section .bss
&nbsp;
&nbsp;
&nbsp;
<i>#-----------------------------------------------------------------------------</i>
.section .text
        .global _start          <i>// tento symbol ma byt dostupny i linkeru</i>
&nbsp;
_start:
        <strong>writeMessage buffer, rep_count</strong>
&nbsp;
        <strong><u>moveBlock hello_lbl, buffer, rep_count</u></strong>
        <strong><i>moveBlock hello_lbl, buffer, rep_count</i></strong>
&nbsp;
        <strong>writeMessage buffer, rep_count</strong>
&nbsp;
        <strong>exit</strong>
</pre>

<p>Takový program ovšem nelze přeložit:</p>

<pre>
$ <strong>as move3.s</strong>
&nbsp;
move3.s: Assembler messages:
move3.s:75: Error: symbol `loop' is already defined
</pre>

<p>Pro zajímavost se podívejme, jak vypadá listing překládaného programu při
výskytu takové chyby (ukážeme si pouze relevantní část):</p>

<pre>
$ <strong>as -alm move3.s</strong>
&nbsp;
  74                            moveBlock hello_lbl, buffer, rep_count
  74 ???? 21030058      &gt;  ldr x1,=hello_lbl
  74 ???? C2020058      &gt;  ldr x2,=buffer
  74 ???? A40180D2      &gt;  mov x4,#rep_count
  74                    &gt; loop:
  74 ???? 23144038      &gt;  ldrb w3,[x1],1
  74 ???? 43140038      &gt;  strb w3,[x2],1
  74 ???? 840400D1      &gt;  sub x4,x4,#1
  74 ???? A4FFFFB5      &gt;  cbnz x4,loop
  75                            moveBlock hello_lbl, buffer, rep_count
  75 ???? 41020058      &gt;  ldr x1,=hello_lbl
  75 ???? E2010058      &gt;  ldr x2,=buffer
  75 ???? A40180D2      &gt;  mov x4,#rep_count
  75                    &gt; loop:
  75 ???? 23144038      &gt;  ldrb w3,[x1],1
  75 ???? 43140038      &gt;  strb w3,[x2],1
  75 ???? 840400D1      &gt;  sub x4,x4,#1
  75 ???? C4FEFFB5      &gt;  cbnz x4,loop
</pre>

<p><div class="rs-tip-major">Poznámka: vidíme, že se assembleru nepodařilo
zjistit všechny adresy (poslední krok překladu), takže na určitá místa musel
pouze doplnit otazníky.</div></p>

<p>Vzhledem k&nbsp;tomu, že se při práci s&nbsp;makry velmi často setkáme
s&nbsp;nutností vytvořit symboly (například právě návěští) s&nbsp;unikátními
jmény, obsahuje GNU Assembler velmi jednoduše použitelný nástroj, který je
možné v&nbsp;makrech využít. Jedná se o počitadlo použití maker &ndash; při
každém použití makra se toto počitadlo automaticky zvýší o jedničku. Pokud tedy
hodnotu počitadla spojíme s&nbsp;prefixem návěští, budeme mít jistotu, že se
vždycky vytvoří unikátní jméno &ndash; nové použití makra zvýší počitadlo o
jedničku. Počitadlo je v&nbsp;makrech představováno znakem @, před nějž musíme
zapsat zpětné lomítko, ostatně jako i v&nbsp;případě parametrů atd. Upravená
verze makra pro výpis zprávy může vypadat následovně:</p>

<pre>
<i># Deklarace makra pro presun bloku</i>
.macro <strong>moveBlock</strong> from, to, length
        ldr   x1, =\from        <i>// adresa bloku pro cteni</i>
        ldr   x2, =\to          <i>// adresa bloku pro zapis</i>
        mov   x4, #\length      <i>// pocet bajtu</i>
loop\@:
        ldrb  w3, [x1], 1       <i>// cteni bajtu</i>
        strb  w3, [x2], 1       <i>// zapis bajtu</i>
        sub   x4, x4, #1        <i>// zmenseni pocitadla a soucasne nastaveni priznaku</i>
        cbnz  x4, loop\@        <i>// pokud jsme se nedostali k nule, skok na zacatek smycky</i>
.endm
</pre>

<p><div class="rs-tip-major">Poznámka: symbol <strong>@</strong> je platný
pouze uvnitř maker.</div></p>

<p>Na následujícím výpisu vidíme činnost počitadla symbolu
<strong>loop\@</strong> v&nbsp;praxi:</p>

<pre>
  74                            moveBlock hello_lbl, buffer, rep_count
  74 0014 21030058      &gt;  ldr x1,=hello_lbl
  74 0018 C2020058      &gt;  ldr x2,=buffer
  74 001c A40180D2      &gt;  mov x4,#rep_count
  74                    &gt; loop1:
  74 0020 23144038      &gt;  ldrb w3,[x1],1
  74 0024 43140038      &gt;  strb w3,[x2],1
  74 0028 840400D1      &gt;  sub x4,x4,#1
  74 002c A4FFFFB5      &gt;  cbnz x4,loop1
  75                            moveBlock hello_lbl, buffer, rep_count
  75 0030 41020058      &gt;  ldr x1,=hello_lbl
  75 0034 E2010058      &gt;  ldr x2,=buffer
  75 0038 A40180D2      &gt;  mov x4,#rep_count
  75                    &gt; loop2:
  75 003c 23144038      &gt;  ldrb w3,[x1],1
  75 0040 43140038      &gt;  strb w3,[x2],1
  75 0044 840400D1      &gt;  sub x4,x4,#1
  75 0048 A4FFFFB5      &gt;  cbnz x4,loop2
</pre>



<p><a name="k18"></a></p>
<h2 id="k18">18. Repositář s&nbsp;demonstračními příklady</h2>

<p>Všechny dnes popisované demonstrační příklady byly společně s&nbsp;podpůrným
souborem <strong>Makefile</strong> určeným pro jejich překlad či naopak pro
disassembling, uloženy do GIT repositáře dostupného na adrese <a
href="https://github.com/tisnik/presentations/">https://github.com/tisnik/presentations/</a>.
Všechny příklady jsou určeny pro GNU Assembler a používají výchozí syntaxi
procesorů Aarch64. Následuje tabulka s&nbsp;odkazy na zdrojové kódy příkladů i
na již zmíněné podpůrné skripty:</p>

<table>
<tr><th>Příklad</th><th>Popis</th><th>Zdrojový kód</th></tr>
<tr><td>template.s</td><td>šablona pro programy psané v&nbsp;assembleru</td><td><a href="https://github.com/tisnik/presentations/blob/master/assembler/aarch64/template.s">https://github.com/tisnik/presentations/blob/master/assembler/aarch64/template.s</a></td></tr>
<tr><td>template_2.s</td><td>šablona pro programy psané v&nbsp;assembleru, založeno na makrech</td><td><a href="https://github.com/tisnik/presentations/blob/master/assembler/aarch64/template_2.s">https://github.com/tisnik/presentations/blob/master/assembler/aarch64/template_2.s</a></td></tr>
<tr><td>hello_world_1.s</td><td>základní podoba programu typu &bdquo;Hello, world!&ldquo;</td><td><a href="https://github.com/tisnik/presentations/blob/master/assembler/aarch64/hello_world_1.s">https://github.com/tisnik/presentations/blob/master/assembler/aarch64/hello_world_1.s</a></td></tr>
<tr><td>hello_world_2.s</td><td>přepis tištěného řetězce</td><td><a href="https://github.com/tisnik/presentations/blob/master/assembler/aarch64/hello_world_2.s">https://github.com/tisnik/presentations/blob/master/assembler/aarch64/hello_world_2.s</a></td></tr>
<tr><td>hello_world_3.s</td><td>refaktoring, použití maker</td><td><a href="https://github.com/tisnik/presentations/blob/master/assembler/aarch64/hello_world_3.s">https://github.com/tisnik/presentations/blob/master/assembler/aarch64/hello_world_3.s</a></td></tr>
<tr><td>aritmetic1.s</td><td>základní aritmetické operace</td><td><a href="https://github.com/tisnik/presentations/blob/master/assembler/aarch64/aritmetic1.s">https://github.com/tisnik/presentations/blob/master/assembler/aarch64/aritmetic1.s</a></td></tr>
<tr><td>infinite_loop.s</td><td>nekonečná programová smyčka realizovaná instrukcí <strong>b</strong></td><td><a href="https://github.com/tisnik/presentations/blob/master/assembler/aarch64/infinite_loop.s">https://github.com/tisnik/presentations/blob/master/assembler/aarch64/infinite_loop.s</a></td></tr>
<tr><td>loop1-aarch64-v1.s</td><td>základní varianta počítané programové smyčky</td><td><a href="https://github.com/tisnik/presentations/blob/master/assembler/aarch64/loop1-aarch64-v1.s">https://github.com/tisnik/presentations/blob/master/assembler/aarch64/loop1-aarch64-v1.s</a></td></tr>
<tr><td>loop1-aarch64-v2.s</td><td>optimalizace &ndash; odstranění instrukce <strong>CMP</strong></td><td><a href="https://github.com/tisnik/presentations/blob/master/assembler/aarch64/loop1-aarch64-v2.s">https://github.com/tisnik/presentations/blob/master/assembler/aarch64/loop1-aarch64-v2.s</a></td></tr>
<tr><td>loop1-aarch64-v3.s</td><td>optimalizace &ndash; použití instrukce <strong>CBNZ</strong></td><td><a href="https://github.com/tisnik/presentations/blob/master/assembler/aarch64/loop1-aarch64-v3.s">https://github.com/tisnik/presentations/blob/master/assembler/aarch64/loop1-aarch64-v3.s</a></td></tr>
<tr><td>loop1-aarch64-v4.s</td><td>automatické zvýšení adresy (ukazatele)</td><td><a href="https://github.com/tisnik/presentations/blob/master/assembler/aarch64/loop1-aarch64-v4.s">https://github.com/tisnik/presentations/blob/master/assembler/aarch64/loop1-aarch64-v4.s</a></td></tr>
<tr><td>move1.s</td><td>přesun bloku dat</td><td><a href="https://github.com/tisnik/presentations/blob/master/assembler/aarch64/move1.s">https://github.com/tisnik/presentations/blob/master/assembler/aarch64/move1.s</a></td></tr>
<tr><td>move2.s</td><td>přepis s&nbsp;využitím maker</td><td><a href="https://github.com/tisnik/presentations/blob/master/assembler/aarch64/move2.s">https://github.com/tisnik/presentations/blob/master/assembler/aarch64/move2.s</a></td></tr>
<tr><td>move3.s</td><td>problém s&nbsp;vícenásobným použitím makra</td><td><a href="https://github.com/tisnik/presentations/blob/master/assembler/aarch64/move3.s">https://github.com/tisnik/presentations/blob/master/assembler/aarch64/move3.s</a></td></tr>
<tr><td>move4.s</td><td>vyřešení předchozího problému</td><td><a href="https://github.com/tisnik/presentations/blob/master/assembler/aarch64/move4.s">https://github.com/tisnik/presentations/blob/master/assembler/aarch64/move4.s</a></td></tr>
<tr><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td></tr>
<tr><td>Makefile</td><td>soubor pro překlad všech příkladů nástrojem <strong>make</strong></td><td><a href="https://github.com/tisnik/presentations/blob/master/assembler/aarch64/Makefile">https://github.com/tisnik/presentations/blob/master/assembler/aarch64/Makefile</a></td></tr>
</table>



<p><a name="k19"></a></p>
<h2 id="k19">19. Předchozí články o architektuře AArch64</h2>

<p>S&nbsp;architekturou AArch64 jsme se již na stránkách Roota setkali, a to
konkrétně v&nbsp;následující pětici článků, z&nbsp;nichž dnes vycházíme:</p>

<ol>

<li>64bitové mikroprocesory s architekturou AArch64<br />
<a href="https://www.root.cz/clanky/64bitove-mikroprocesory-s-architekturou-aarch64/">https://www.root.cz/clanky/64bitove-mikroprocesory-s-architekturou-aarch64/</a>
</li>

<li>Instrukční sada AArch64<br />
<a href="https://www.root.cz/clanky/instrukcni-sada-aarch64/">https://www.root.cz/clanky/instrukcni-sada-aarch64/</a>
</li>

<li>Instrukční sada AArch64 (2.část)<br />
<a href="https://www.root.cz/clanky/instrukcni-sada-aarch64-2-cast/">https://www.root.cz/clanky/instrukcni-sada-aarch64-2-cast/</a>
</li>

<li>Tvorba a ladění programů v&nbsp;assembleru mikroprocesorů AArch64<br />
<a href="https://www.root.cz/clanky/tvorba-a-ladeni-programu-v-assembleru-mikroprocesoru-aarch64/">https://www.root.cz/clanky/tvorba-a-ladeni-programu-v-assembleru-mikroprocesoru-aarch64/</a>
</li>

<li>Instrukční sada AArch64: technologie NEON<br />
<a href="https://www.root.cz/clanky/instrukcni-sada-aarch64-technologie-neon/">https://www.root.cz/clanky/instrukcni-sada-aarch64-technologie-neon/</a>
</li>

</ol>



<p><a name="k20"></a></p>
<h2 id="k20">20. Odkazy na Internetu</h2>

<ol>

<li>Arm Architecture Reference Manual for A-profile architecture<br />
<a href="https://developer.arm.com/documentation/ddi0487/latest">https://developer.arm.com/documentation/ddi0487/latest</a>
</li>

<li>The GNU Assembler - macros<br />
<a href="http://tigcc.ticalc.org/doc/gnuasm.html#SEC109">http://tigcc.ticalc.org/doc/gnuasm.html#SEC109</a>
</li>

<li>GNU Binutils<br />
<a href="https://sourceware.org/binutils/">https://sourceware.org/binutils/</a>
</li>

<li>Documentation for binutils 2.38<br />
<a href="https://sourceware.org/binutils/docs-2.38/">https://sourceware.org/binutils/docs-2.38/</a>
</li>

<li>AArch64 Instruction Set Architecture<br />
<a href="https://developer.arm.com/architectures/learn-the-architecture/aarch64-instruction-set-architecture/instruction-sets-in-the-arm-architecture">https://developer.arm.com/architectures/learn-the-architecture/aarch64-instruction-set-architecture/instruction-sets-in-the-arm-architecture</a>
</li>

<li>Arm Armv8-A A32/T32 Instruction Set Architecture<br />
<a href="https://developer.arm.com/documentation/ddi0597/2021-12/?lang=en">https://developer.arm.com/documentation/ddi0597/2021-12/?lang=en</a>
</li>

<li>Comparison of ARMv8-A cores<br />
<a href="https://en.wikipedia.org/wiki/Comparison_of_ARMv8-A_cores">https://en.wikipedia.org/wiki/Comparison_of_ARMv8-A_cores</a>
</li>

<li>Cortex-A32 Processor<br />
<a href="https://www.arm.com/products/processors/cortex-a/cortex-a32-processor.php">https://www.arm.com/products/processors/cortex-a/cortex-a32-processor.php</a>
</li>

<li>Cortex-A35 Processor<br />
<a href="https://www.arm.com/products/processors/cortex-a/cortex-a35-processor.php">https://www.arm.com/products/processors/cortex-a/cortex-a35-processor.php</a>
</li>

<li>Cortex-A53 Processor<br />
<a href="https://www.arm.com/products/processors/cortex-a/cortex-a53-processor.php">https://www.arm.com/products/processors/cortex-a/cortex-a53-processor.php</a>
</li>

<li>Cortex-A57 Processor<br />
<a href="https://www.arm.com/products/processors/cortex-a/cortex-a57-processor.php">https://www.arm.com/products/processors/cortex-a/cortex-a57-processor.php</a>
</li>

<li>Cortex-A72 Processor<br />
<a href="https://www.arm.com/products/processors/cortex-a/cortex-a72-processor.php">https://www.arm.com/products/processors/cortex-a/cortex-a72-processor.php</a>
</li>

<li>Cortex-A73 Processor<br />
<a href="https://www.arm.com/products/processors/cortex-a/cortex-a73-processor.php">https://www.arm.com/products/processors/cortex-a/cortex-a73-processor.php</a>
</li>

<li>Apple A7 (SoC založen na CPU Cyclone)<br />
<a href="https://en.wikipedia.org/wiki/Apple_A7">https://en.wikipedia.org/wiki/Apple_A7</a>
</li>

<li>System cally pro AArch64 na Linuxu<br />
<a href="https://github.com/torvalds/linux/blob/master/include/uapi/asm-generic/unistd.h">https://github.com/torvalds/linux/blob/master/include/uapi/asm-generic/unistd.h</a>
</li>

<li>Architectures/AArch64 (FedoraProject.org)<br />
<a href="https://fedoraproject.org/wiki/Architectures/AArch64">https://fedoraproject.org/wiki/Architectures/AArch64</a>
</li>

<li>SIG pro AArch64 (CentOS)<br />
<a href="https://wiki.centos.org/SpecialInterestGroup/AltArch/AArch64">https://wiki.centos.org/SpecialInterestGroup/AltArch/AArch64</a>
</li>

<li>The ARMv8 instruction sets<br />
<a href="http://infocenter.arm.com/help/index.jsp?topic=/com.arm.doc.den0024a/ch05s01.html">http://infocenter.arm.com/help/index.jsp?topic=/com.arm.doc.den0024a/ch05s01.html</a>
</li>

<li>A64 Instruction Set<br />
<a href="https://developer.arm.com/products/architecture/instruction-sets/a64-instruction-set">https://developer.arm.com/products/architecture/instruction-sets/a64-instruction-set</a>
</li>

<li>Switching between the instruction sets<br />
<a href="http://infocenter.arm.com/help/index.jsp?topic=/com.arm.doc.den0024a/ch05s01.html">http://infocenter.arm.com/help/index.jsp?topic=/com.arm.doc.den0024a/ch05s01.html</a>
</li>

<li>The A64 instruction set<br />
<a href="http://infocenter.arm.com/help/index.jsp?topic=/com.arm.doc.den0024a/ch05s01.html">http://infocenter.arm.com/help/index.jsp?topic=/com.arm.doc.den0024a/ch05s01.html</a>
</li>

<li>Introduction to ARMv8 64-bit Architecture<br />
<a href="https://quequero.org/2014/04/introduction-to-arm-architecture/">https://quequero.org/2014/04/introduction-to-arm-architecture/</a>
</li>

<li>MCU market turns to 32-bits and ARM<br />
<a href="http://www.eetimes.com/document.asp?doc_id=1280803">http://www.eetimes.com/document.asp?doc_id=1280803</a>
</li>

<li>Cortex-M0 Processor (ARM Holdings)<br />
<a href="http://www.arm.com/products/processors/cortex-m/cortex-m0.php">http://www.arm.com/products/processors/cortex-m/cortex-m0.php</a>
</li>

<li>Cortex-M0+ Processor (ARM Holdings)<br />
<a href="http://www.arm.com/products/processors/cortex-m/cortex-m0plus.php">http://www.arm.com/products/processors/cortex-m/cortex-m0plus.php</a>
</li>

<li>ARM Processors in a Mixed Signal World<br />
<a href="http://www.eeweb.com/blog/arm/arm-processors-in-a-mixed-signal-world">http://www.eeweb.com/blog/arm/arm-processors-in-a-mixed-signal-world</a>
</li>

<li>ARM Architecture (Wikipedia)<br />
<a href="https://en.wikipedia.org/wiki/ARM_architecture">https://en.wikipedia.org/wiki/ARM_architecture</a>
</li>

<li>DSP for Cortex-M<br />
<a href="https://developer.arm.com/technologies/dsp/dsp-for-cortex-m">https://developer.arm.com/technologies/dsp/dsp-for-cortex-m</a>
</li>

<li>Cortex-M processors in DSP applications? Why not?!<br />
<a href="https://community.arm.com/processors/b/blog/posts/cortex-m-processors-in-dsp-applications-why-not">https://community.arm.com/processors/b/blog/posts/cortex-m-processors-in-dsp-applications-why-not</a>
</li>

<li>White Paper - DSP capabilities of Cortex-M4 and Cortex-M7<br />
<a href="https://community.arm.com/processors/b/blog/posts/white-paper-dsp-capabilities-of-cortex-m4-and-cortex-m7">https://community.arm.com/processors/b/blog/posts/white-paper-dsp-capabilities-of-cortex-m4-and-cortex-m7</a>
</li>

<li>Q (number format)<br />
<a href="https://en.wikipedia.org/wiki/Q_%28number_format%29">https://en.wikipedia.org/wiki/Q_%28number_format%29</a>
</li>

<li>TriCore Architecture &amp; Core<br />
<a href="http://www.infineon.com/cms/en/product/microcontroller/32-bit-tricore-tm-microcontroller/tricore-tm-architecture-and-core/channel.html?channel=ff80808112ab681d0112ab6b73d40837">http://www.infineon.com/cms/en/product/microcontroller/32-bit-tricore-tm-microcontroller/tricore-tm-architecture-and-core/channel.html?channel=ff80808112ab681d0112ab6b73d40837</a>
</li>

<li>TriCoreTM V1.6 Instruction Set: 32-bit Unified Processor Core<br />
<a href="http://www.infineon.com/dgdl/tc_v131_instructionset_v138.pdf?fileId=db3a304412b407950112b409b6dd0352">http://www.infineon.com/dgdl/tc_v131_instructionset_v138.pdf?fileId=db3a304412b407950112b409b6dd0352</a>
</li>

<li>TriCore v2.2 C Compiler, Assembler, Linker Reference Manual<br />
<a href="http://tasking.com/support/tricore/tc_reference_guide_v2.2.pdf">http://tasking.com/support/tricore/tc_reference_guide_v2.2.pdf</a>
</li>

<li>Infineon TriCore (Wikipedia)<br />
<a href="https://en.wikipedia.org/wiki/Infineon_TriCore">https://en.wikipedia.org/wiki/Infineon_TriCore</a>
</li>

<li>C166®S V2 Architecture &amp; Core<br />
<a href="http://www.infineon.com/cms/en/product/microcontroller/16-bit-c166-microcontroller/c166-s-v2-architecture-and-core/channel.html?channel=db3a304312bef5660112c3011c7d01ae">http://www.infineon.com/cms/en/product/microcontroller/16-bit-c166-microcontroller/c166-s-v2-architecture-and-core/channel.html?channel=db3a304312bef5660112c3011c7d01ae</a>
</li>

<li>Comparing four 32-bit soft processor cores<br />
<a href="http://www.eetimes.com/author.asp?section_id=14&doc_id=1286116">http://www.eetimes.com/author.asp?section_id=14&doc_id=1286116</a>
</li>

<li>RISC-V Instruction Set<br />
<a href="http://riscv.org/download.html#spec_compressed_isa">http://riscv.org/download.html#spec_compressed_isa</a>
</li>

<li>RISC-V Spike (ISA Simulator)<br />
<a href="http://riscv.org/download.html#isa-sim">http://riscv.org/download.html#isa-sim</a>
</li>

<li>RISC-V (Wikipedia)<br />
<a href="https://en.wikipedia.org/wiki/RISC-V">https://en.wikipedia.org/wiki/RISC-V</a>
</li>

<li>David Patterson (Wikipedia)<br />
<a href="https://en.wikipedia.org/wiki/David_Patterson_(computer_scientist)">https://en.wikipedia.org/wiki/David_Patterson_(computer_scientist)</a>
</li>

<li>OpenRISC (oficiální stránky projektu)<br />
<a href="http://openrisc.io/">http://openrisc.io/</a>
</li>

<li>OpenRISC architecture<br />
<a href="http://openrisc.io/architecture.html">http://openrisc.io/architecture.html</a>
</li>

<li>Emulátor OpenRISC CPU v JavaScriptu<br />
<a href="http://s-macke.github.io/jor1k/demos/main.html">http://s-macke.github.io/jor1k/demos/main.html</a>
</li>

<li>OpenRISC (Wikipedia)<br />
<a href="https://en.wikipedia.org/wiki/OpenRISC">https://en.wikipedia.org/wiki/OpenRISC</a>
</li>

<li>OpenRISC - instrukce<br />
<a href="http://sourceware.org/cgen/gen-doc/openrisc-insn.html">http://sourceware.org/cgen/gen-doc/openrisc-insn.html</a>
</li>

<li>OpenRISC - slajdy z přednášky o projektu<br />
<a href="https://iis.ee.ethz.ch/~gmichi/asocd/lecturenotes/Lecture6.pdf">https://iis.ee.ethz.ch/~gmichi/asocd/lecturenotes/Lecture6.pdf</a>
</li>

<li>Berkeley RISC<br />
<a href="http://en.wikipedia.org/wiki/Berkeley_RISC">http://en.wikipedia.org/wiki/Berkeley_RISC</a>
</li>

<li>Great moments in microprocessor history<br />
<a href="http://www.ibm.com/developerworks/library/pa-microhist.html">http://www.ibm.com/developerworks/library/pa-microhist.html</a>
</li>

<li>Microprogram-Based Processors<br />
<a href="http://research.microsoft.com/en-us/um/people/gbell/Computer_Structures_Principles_and_Examples/csp0167.htm">http://research.microsoft.com/en-us/um/people/gbell/Computer_Structures_Principles_and_Examples/csp0167.htm</a>
</li>

<li>Great Microprocessors of the Past and Present<br />
<a href="http://www.cpushack.com/CPU/cpu1.html">http://www.cpushack.com/CPU/cpu1.html</a>
</li>

<li>A Brief History of Microprogramming<br />
<a href="http://www.cs.clemson.edu/~mark/uprog.html">http://www.cs.clemson.edu/~mark/uprog.html</a>
</li>

<li>What is RISC?<br />
<a href="http://www-cs-faculty.stanford.edu/~eroberts/courses/soco/projects/2000-01/risc/whatis/">http://www-cs-faculty.stanford.edu/~eroberts/courses/soco/projects/2000-01/risc/whatis/</a>
</li>

<li>RISC vs. CISC<br />
<a href="http://www-cs-faculty.stanford.edu/~eroberts/courses/soco/projects/2000-01/risc/risccisc/">http://www-cs-faculty.stanford.edu/~eroberts/courses/soco/projects/2000-01/risc/risccisc/</a>
</li>

<li>RISC and CISC definitions:<br />
<a href="http://www.cpushack.com/CPU/cpuAppendA.html">http://www.cpushack.com/CPU/cpuAppendA.html</a>
</li>

<li>FPGA<br />
<a href="https://cs.wikipedia.org/wiki/Programovateln%C3%A9_hradlov%C3%A9_pole">https://cs.wikipedia.org/wiki/Programovateln%C3%A9_hradlov%C3%A9_pole</a>
</li>

<li>The Evolution of RISC<br />
<a href="http://www.ibm.com/developerworks/library/pa-microhist.html#sidebar1">http://www.ibm.com/developerworks/library/pa-microhist.html#sidebar1</a>
</li>

<li>disasm.pro<br />
<a href="https://disasm.pro/">https://disasm.pro/</a>
</li>

<li>Exploring AArch64 assembler &ndash; Chapter 5<br />
<a href="https://thinkingeek.com/2016/11/13/exploring-aarch64-assembler-chapter-5/">https://thinkingeek.com/2016/11/13/exploring-aarch64-assembler-chapter-5/</a>
</li>

</ol>



<p></p><p></p>
<p><small>Autor: <a href="http://www.fit.vutbr.cz/~tisnovpa">Pavel Tišnovský</a> &nbsp; 2022</small></p>
</body>
</html>

