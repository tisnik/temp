<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
        "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html>
<head>
<title></title>
<meta name="Author" content="Pavel Tisnovsky" />
<meta name="Generator" content="vim" />
<meta http-equiv="content-type" content="text/html; charset=utf-8" />
<style type="text/css">
         body {color:#000000; background:#ffffff;}
         h1  {font-family: arial, helvetica, sans-serif; color:#ffffff; background-color:#c00000; text-align:center; padding-left:1em}
         h2  {font-family: arial, helvetica, sans-serif; color:#ffffff; background-color:#0000c0; padding-left:1em; text-align:left}
         h3  {font-family: arial, helvetica, sans-serif; color:#000000; background-color:#c0c0c0; padding-left:1em; text-align:left}
         h4  {font-family: arial, helvetica, sans-serif; color:#000000; background-color:#e0e0e0; padding-left:1em; text-align:left}
         a   {font-family: arial, helvetica, sans-serif;}
         li  {font-family: arial, helvetica, sans-serif; color:#000000; text-align:justify; width:450px;}
         ol  {font-family: arial, helvetica, sans-serif; color:#000000; text-align:justify; width:450px;}
         ul  {font-family: arial, helvetica, sans-serif; color:#000000; text-align:justify; width:450px;}
         p   {font-family: arial, helvetica, sans-serif; color:#000000; text-align:justify;}
         pre {background:#e0e0e0}
</style>
</head>

<body>

<h1></h1>

<h3>Pavel Tišnovský</h3>

<p></p>

<h1>Úvodník</h1>

<p></p>



<h2>Obsah</h2>

<p><a href="#k01">*** 1. </a></p>
<p><a href="#k02">2. Dostupné intrinsic funkce pro manipulaci s&nbsp;hodnotami typu <i>half float</i></a></p>
<p><a href="#k03">3. Podpora pro manipulaci s&nbsp;celými vektory v&nbsp;GCC</a></p>
<p><a href="#k04">4. Vektory obsahující prvky typu <i>half float</i> na platformě AArch64</a></p>
<p><a href="#k05">5. Korektní a nekorektní velikost vektorů</a></p>
<p><a href="#k06">*** 6. Základní aritmetické operace s&nbsp;vektory</a></p>
<p><a href="#k07">*** 7. Způsob překladu operací s&nbsp;prvky vektorů do strojového kódu A64</a></p>
<p><a href="#k08">*** 8. Zpracování delších vektorů</a></p>
<p><a href="#k09">*** 9. </a></p>
<p><a href="#k10">*** 10. </a></p>
<p><a href="#k11">*** 11. </a></p>
<p><a href="#k12">*** 12. </a></p>
<p><a href="#k13">*** 13. </a></p>
<p><a href="#k14">*** 14. </a></p>
<p><a href="#k15">*** 15. </a></p>
<p><a href="#k16">*** 16. </a></p>
<p><a href="#k17">*** 17. </a></p>
<p><a href="#k18">*** 18. Příloha: všechny instrukce z&nbsp;instrukční sady A64 použité v&nbsp;článku</a></p>
<p><a href="#k19">*** 19. Repositář s&nbsp;demonstračními příklady</a></p>
<p><a href="#k20">20. Odkazy na Internetu</a></p>



<p><a name="k01"></a></p>
<h2 id="k01">1. </h2>



<p><a name="k02"></a></p>
<h2 id="k02">2. Dostupné intrinsic funkce pro manipulaci s&nbsp;hodnotami typu <i>half float</i></h2>

<p>V&nbsp;moderních překladačích programovacího jazyka C, přesněji řečeno
v&nbsp;těch překladačích, které podporují platformu AArch64, jsou většinou
definovány intrinsic funkce (či jen <i>intrinsic</i>), jejichž volání
z&nbsp;céčkovského kódu se přímo překládá na instrukce cílové platformy (bez
samotného volání funkce, předávání parametrů atd.). Některé příklady jsme si
ukázali minule, takže si nyní ve stručnosti připomeneme, jakým způsobem se
intrinsic překládají do strojového kódu. Pochopitelně zůstaneme u těch operací,
které pracují s&nbsp;hodnotami typu <i>half float</i></p>

<pre>
#include &lt;arm_fp16.h&gt;
#include &lt;stdio.h&gt;
&nbsp;
void <strong>fp16_arithm</strong>(_Float16 x, _Float16 y) {
    _Float16 a=vaddh_f16(x, y);
    _Float16 b=vsubh_f16(x, y);
    _Float16 c=vmulh_f16(x, y);
    _Float16 d=vdivh_f16(x, y);
&nbsp;
    <i>// donutíme překladač, aby předchozí intrinsic skutečně vygeneroval do kódu</i>
    printf("%f %f %f %f\n", (double)a, (double)b, (double)c, (double)d);
}
</pre>

<p>Ve vygenerovaném kódu se na prvních čtyřech řádcích objevuje přímé volání
instrukcí, které provádí základní aritmetické operace s&nbsp;hodnotami typu
<i>half float</i>; zbytek kódu se týká volání funkce <strong>printf</strong>
(ovšem je zajímavé, jak &bdquo;levný&ldquo; je převod hodnot <i>half float</i>
na typ <i>double</i>):</p>

<pre>
<strong>fp16_arithm</strong>:
        fdiv    h3, h0, h1
        fmul    h2, h0, h1
        fsub    h31, h0, h1
        fadd    h0, h0, h1
        adrp    x0, .LC0
        add     x0, x0, :lo12:.LC0
        fcvt    d2, h2
        fcvt    d1, h31
        fcvt    d0, h0
        fcvt    d3, h3
        b       printf
</pre>

<p>Podobných intrinsic existuje celá řada. V&nbsp;následující tabulce jsou
vypsány ty intrinsic pro zpracování hodnot typu <i>half float</i>, které lze
volat v&nbsp;GCC:</p>

<table>
<tr><th>Návratová hodnota</td><td>Jméno funkce</td><td>Parametry</td></tr>
<tr><td>float16_t</td><td>vabsh_f16</td><td>float16_t __a</td></tr>
<tr><td>float16_t</td><td>vaddh_f16</td><td>float16_t __a, float16_t __b</td></tr>
<tr><td>int32_t</td><td>vcvtah_s32_f16</td><td>float16_t __a</td></tr>
<tr><td>uint32_t</td><td>vcvtah_u32_f16</td><td>float16_t __a</td></tr>
<tr><td>float16_t</td><td>vcvth_f16_s32</td><td>int32_t __a</td></tr>
<tr><td>float16_t</td><td>vcvth_f16_u32</td><td>uint32_t __a</td></tr>
<tr><td>float16_t</td><td>vcvth_n_f16_s32</td><td>int32_t __a, const int __b</td></tr>
<tr><td>float16_t</td><td>vcvth_n_f16_u32</td><td>uint32_t __a, const int __b</td></tr>
<tr><td>int32_t</td><td>vcvth_n_s32_f16</td><td>float16_t __a, const int __b</td></tr>
<tr><td>uint32_t</td><td>vcvth_n_u32_f16</td><td>float16_t __a, const int __b</td></tr>
<tr><td>int32_t</td><td>vcvth_s32_f16</td><td>float16_t __a</td></tr>
<tr><td>uint32_t</td><td>vcvth_u32_f16</td><td>float16_t __a</td></tr>
<tr><td>int32_t</td><td>vcvtmh_s32_f16</td><td>float16_t __a</td></tr>
<tr><td>uint32_t</td><td>vcvtmh_u32_f16</td><td>float16_t __a</td></tr>
<tr><td>int32_t</td><td>vcvtnh_s32_f16</td><td>float16_t __a</td></tr>
<tr><td>uint32_t</td><td>vcvtnh_u32_f16</td><td>float16_t __a</td></tr>
<tr><td>int32_t</td><td>vcvtph_s32_f16</td><td>float16_t __a</td></tr>
<tr><td>uint32_t</td><td>vcvtph_u32_f16</td><td>float16_t __a</td></tr>
<tr><td>float16_t</td><td>vdivh_f16</td><td>float16_t __a, float16_t __b</td></tr>
<tr><td>float16_t</td><td>vfmah_f16</td><td>float16_t __a, float16_t __b, float16_t __c</td></tr>
<tr><td>float16_t</td><td>vfmsh_f16</td><td>float16_t __a, float16_t __b, float16_t __c</td></tr>
<tr><td>float16_t</td><td>vmaxnmh_f16</td><td>float16_t __a, float16_t __b</td></tr>
<tr><td>float16_t</td><td>vminnmh_f16</td><td>float16_t __a, float16_t __b</td></tr>
<tr><td>float16_t</td><td>vmulh_f16</td><td>float16_t __a, float16_t __b</td></tr>
<tr><td>float16_t</td><td>vnegh_f16</td><td>float16_t __a</td></tr>
<tr><td>float16_t</td><td>vrndah_f16</td><td>float16_t __a</td></tr>
<tr><td>float16_t</td><td>vrndh_f16</td><td>float16_t __a</td></tr>
<tr><td>float16_t</td><td>vrndih_f16</td><td>float16_t __a</td></tr>
<tr><td>float16_t</td><td>vrndmh_f16</td><td>float16_t __a</td></tr>
<tr><td>float16_t</td><td>vrndnh_f16</td><td>float16_t __a</td></tr>
<tr><td>float16_t</td><td>vrndph_f16</td><td>float16_t __a</td></tr>
<tr><td>float16_t</td><td>vrndxh_f16</td><td>float16_t __a</td></tr>
<tr><td>float16_t</td><td>vsqrth_f16</td><td>float16_t __a</td></tr>
<tr><td>float16_t</td><td>vsubh_f16</td><td>float16_t __a, float16_t __b</td></tr>
</table>

<p><div class="rs-tip-major">Poznámka: nenechte se zmýlit prefixem
&bdquo;v&ldquo;</div>, protože tyto intrinsic nepracují s&nbsp;vektory, ale se
skalárními hodnotami.</p>



<p><a name="k03"></a></p>
<h2 id="k03">3. Podpora pro manipulaci s&nbsp;celými vektory v&nbsp;GCC</h2>

<p>Intrinsic funkce, které byly zmíněny <a href="#k02">v&nbsp;předchozí
kapitole</a>, mají své specifické využití a vyplatí se alespoň vědět o jejich
existenci. Ovšem jak již víme z&nbsp;předchozího článku, některé z&nbsp;nich
lze nahradit běžnými operátory jazyka C (nad typy <i>half float</i>).
Zajímavější situace ovšem nastane, pokud budeme vyžadovat práci s&nbsp;celými
vektory prvků typu <i>half float</i>. I to je možné (do jisté míry) zajistit,
protože GCC (ale i některé další překladače) nabízí vývojářům takzvané
&bdquo;vektorové rozšíření&ldquo;, se kterým jsme se setkali v&nbsp;článcích o
SIMD. Vzhledem k&nbsp;tomu, že se jedná o ústřední téma dnešního článku,
připomeneme si základní vlastnosti tohoto vektorového rozšíření.</p>

<p>GCC umožňuje definici nových datových struktur typu &bdquo;vektor prvků
X&ldquo;. Definice takového datového typu obecně vypadá takto:</p>

<pre>
typedef <u>typ_prvku</u> <strong>jméno_typu</strong> __attribute__((vector_size(<u>velikost_vektoru_v_bajtech</u>)));
</pre>

<p><div class="rs-tip-major">Poznámka: jedná se sice o poměrně kryptický zápis,
ovšem ve skutečnosti bude ve zdrojových kódech typicky uveden na jediném místě
(v&nbsp;hlavičkovém souboru), kde je taktéž vhodné ho okomentovat.</div></p>

<p>Podívejme se na následující demonstrační příklad, ve kterém je definován
nový datový typ nazvaný <strong>v16us</strong> (jméno může být pochopitelně
jakékoli). Jedná se o vektor o délce šestnácti bajtů, který obsahuje prvky typu
<strong>short int</strong>, což zde konkrétně může znamenat, že se do vektoru
vejde celkem osm těchto prvků za předpokladu, že <strong>sizeof(unsigned short
int)==2</strong>:</p>

<pre>
typedef <i>unsigned short int</i> <strong>v16us</strong> __attribute__((vector_size(<u>16</u>)));
</pre>

<p>Velikost jednoho prvku vektoru i velikost celého vektoru získáme operátorem
<strong>sizeof</strong>, což si můžeme snadno ověřit:</p>

<pre>
#include &lt;stdio.h&gt;
&nbsp;
typedef unsigned short int v16us __attribute__((vector_size(16)));
&nbsp;
int <strong>main</strong>(void)
{
    printf("scalar: %ld bytes\n", sizeof(unsigned short int));
    printf("vector: %ld bytes\n", sizeof(v16us));
&nbsp;
    return 0;
}
</pre>

<p>Výsledek by měl vypadat následovně:</p>

<pre>
scalar: 2 bytes
vector: 16 bytes
</pre>

<p>Vyzkoušet si můžeme i další vektory o celkové délce 16 bajtů, jejichž prvky
budou různých typů a tudíž i délka vektoru měřená v&nbsp;počtu prvků bude
odlišná:</p>

<pre>
#include &lt;stdio.h&gt;
&nbsp;
typedef unsigned char v16ub __attribute__((vector_size(16)));
typedef unsigned short int v16us __attribute__((vector_size(16)));
typedef unsigned int v16ui __attribute__((vector_size(16)));
typedef unsigned long int v16ul __attribute__((vector_size(16)));
&nbsp;
int <strong>main</strong>(void)
{
    printf("unsigned char:  %ld bytes\n", sizeof(unsigned char));
    printf("unsigned short: %ld bytes\n", sizeof(unsigned short int));
    printf("unsigned int:   %ld bytes\n", sizeof(unsigned int));
    printf("unsigned long:  %ld bytes\n", sizeof(unsigned long int));
&nbsp;
    printf("vector unsigned char:  %ld bytes\n", sizeof(v16ub));
    printf("vector unsigned short: %ld bytes\n", sizeof(v16us));
    printf("vector unsigned int:   %ld bytes\n", sizeof(v16ui));
    printf("vector unsigned long:  %ld bytes\n", sizeof(v16ul));
&nbsp;
    return 0;
}
</pre>

<p>Výsledek:</p>

<pre>
unsigned char:  1 bytes
unsigned short: 2 bytes
unsigned int:   4 bytes
unsigned long:  8 bytes
vector unsigned char:  16 bytes
vector unsigned short: 16 bytes
vector unsigned int:   16 bytes
vector unsigned long:  16 bytes
</pre>

<p>Totéž platí i pro vektory s&nbsp;prvky se znaménkem:</p>

<pre>
#include &lt;stdio.h&gt;
&nbsp;
typedef signed char v16ub __attribute__((vector_size(16)));
typedef signed short int v16us __attribute__((vector_size(16)));
typedef signed int v16ui __attribute__((vector_size(16)));
typedef signed long int v16ul __attribute__((vector_size(16)));
&nbsp;
int <strong>main</strong>(void)
{
    printf("signed char:  %ld bytes\n", sizeof(signed char));
    printf("signed short: %ld bytes\n", sizeof(signed short int));
    printf("signed int:   %ld bytes\n", sizeof(signed int));
    printf("signed long:  %ld bytes\n", sizeof(signed long int));
&nbsp;
    printf("vector signed char:  %ld bytes\n", sizeof(v16ub));
    printf("vector signed short: %ld bytes\n", sizeof(v16us));
    printf("vector signed int:   %ld bytes\n", sizeof(v16ui));
    printf("vector signed long:  %ld bytes\n", sizeof(v16ul));
&nbsp;
    return 0;
}
</pre>

<p>Výsledky:</p>

<pre>
signed char:  1 bytes
signed short: 2 bytes
signed int:   4 bytes
signed long:  8 bytes
vector signed char:  16 bytes
vector signed short: 16 bytes
vector signed int:   16 bytes
vector signed long:  16 bytes
</pre>



<p><a name="k04"></a></p>
<h2 id="k04">4. Vektory obsahující prvky typu <i>half float</i> na platformě AArch64</h2>

<p>V&nbsp;dnešním článku nás nejvíce zajímá způsob práce s&nbsp;vektory,
jejichž prvky jsou typu <i>half float</i>. Pokusme se tedy nyní definovat typ,
který takový vektor popíše. Připomeňme si, že definice typu vektoru vypadá
následovně:</p>

<pre>
typedef <u>typ_prvku</u> <strong>jméno_typu</strong> __attribute__((vector_size(<u>velikost_vektoru_v_bajtech</u>)));
</pre>

<p>Konkrétně vektor s&nbsp;osmi prvky typu <i>half float</i> (pro
<strong>sizeof half_float==2</strong>) tedy bude vypadat následovně:</p>

<pre>
typedef <u>_Float16</u> <strong>float16x8</strong> __attribute__((vector_size(<u>16</u>)));
</pre>

<p>Opět si pochopitelně můžeme ověřit velikost prvku (musí být dva bajty) i
velikost celého vektoru:</p>

<pre>
#include &lt;stdio.h&gt;
&nbsp; 
typedef _Float16 float16x8 __attribute__((vector_size(16)));
&nbsp;
int <strong>main</strong>(void)
{
    printf("scalar: %ld bytes\n", sizeof(_Float16));
    printf("vector: %ld bytes\n", sizeof(float16x8));
&nbsp; 
    return 0;
}
</pre>

<p>Po překladu a spuštění tohoto příkladu by se mělo vypsat:</p>

<pre>
scalar: 2 bytes
vector: 16 bytes
</pre>



<p><a name="k05"></a></p>
<h2 id="k05">5. Korektní a nekorektní velikost vektorů</h2>

<p><a href="#k04">V&nbsp;předchozím demonstračním příkladu</a> byla velikost
vektoru nastavena na šestnáct bajtů. Jedná se o korektní velikost, a to ze dvou
důvodů:</p>

<ol>

<li>Tato velikost je celočíselným násobkem velikosti jednoho prvku
(v&nbsp;bajtech). Konkrétně v&nbsp;tomto případě se jedná o celočíselný násobek
dvojky, protože <i>half float</i> v&nbsp;paměti obsadí přesně dva bajty.</li>

<li>Současně je tato velikost celočíselnou mocninou dvojky, což je obecný
požadavek GCC, který nezávisí na typu prvků vektoru.</li>

</ol>

<p>Ostatně můžeme si sami otestovat, jak bude překladač reagovat na pokus o
definici vektoru s&nbsp;nekorektní velikostí. Nejprve se pokusíme o definici
vektoru, jehož velikost není celočíselným násobkem
<strong>sizeof(_Float16</strong>):</p>

<pre>
#include &lt;stdio.h&gt;
&nbsp;
typedef _Float16 float16x8 __attribute__((vector_size(<u>17</u>)));
&nbsp;
int <strong>main</strong>(void)
{
    printf("scalar: %ld bytes\n", sizeof(_Float16));
    printf("vector: %ld bytes\n", sizeof(float16x8));
&nbsp; 
    return 0;
}
</pre>

<p>Překladač tento problém snadno odhalí:</p>

<pre>
$ <strong>gcc -Wall fp16_vector_incorrect_size_1.c</strong>
&nbsp;
fp16_vector_incorrect_size_1.c:3:1: error: vector size not an integral multiple of component size
    3 | typedef _Float16 float16x8 __attribute__((vector_size(17)));
      | ^~~~~~~
</pre>

<p>Ve druhém demonstračním příkladu sice bude velikost vektoru dělitelná
dvojkou, ale nebude celočíselnou mocninou dvojky:</p>

<pre>
#include &lt;stdio.h&gt;
&nbsp; 
typedef _Float16 float16x8 __attribute__((vector_size(<u>20</u>)));
&nbsp;
int <strong>main</strong>(void)
{
    printf("scalar: %ld bytes\n", sizeof(_Float16));
    printf("vector: %ld bytes\n", sizeof(float16x8));
&nbsp; 
    return 0;
}
</pre>

<p>I tento problém bude překladačem céčka odhalen:</p>

<pre>
$ <strong>gcc -Wall fp16_vector_incorrect_size_2.c</strong>
&nbsp;
fp16_vector_incorrect_size_2.c:3:1: error: number of vector components 10 not a power of two
    3 | typedef _Float16 float16x8 __attribute__((vector_size(20)));
      | ^~~~~~~
</pre>

<p><div class="rs-tip-major">Poznámka: toto druhé omezení je poměrně
nepříjemné, protože například neumožňuje snadnou práci s&nbsp;některými
embedded modely.</div></p>



<p><a name="k06"></a></p>
<h2 id="k06">6. Základní aritmetické operace s&nbsp;vektory</h2>

<pre>
typedef _Float16 float16x8 __attribute__((vector_size(16)));

float16x8 add(float16x8 x, float16x8 y)
{
    return x+y;
}
</pre>

<pre>
add:
        fadd    v0.8h, v0.8h, v1.8h
        ret
</pre>



<p><a name="k07"></a></p>
<h2 id="k07">7. Způsob překladu operací s&nbsp;prvky vektorů do strojového kódu A64</h2>

<p>S&nbsp;celými vektory lze pochopitelně provádět i ostatní tři základní aritmetické operace, což je ukázáno na dalším příkladu, společně s&nbsp;ukázkou toho, jak se vlastně vektory naplní daty:</p>

<pre>
typedef _Float16 float16x8 __attribute__((vector_size(16)));

float16x8 add(float16x8 x, float16x8 y)
{
    return x+y;
}

float16x8 sub(float16x8 x, float16x8 y)
{
    return x-y;
}

float16x8 mul(float16x8 x, float16x8 y)
{
    return x*y;
}

float16x8 div(float16x8 x, float16x8 y)
{
    return x/y;
}
</pre>

<pre>
add:
        fadd    v0.8h, v0.8h, v1.8h
        ret

sub:
        fsub    v0.8h, v0.8h, v1.8h
        ret

mul:
        fmul    v0.8h, v0.8h, v1.8h
        ret

div:
        fdiv    v0.8h, v0.8h, v1.8h
        ret
</pre>



<p><a name="k08"></a></p>
<h2 id="k08">8. Zpracování delších vektorů</h2>



<p><a name="k09"></a></p>
<h2 id="k09">9. </h2>



<p><a name="k10"></a></p>
<h2 id="k10">10. </h2>



<p><a name="k11"></a></p>
<h2 id="k11">11. </h2>



<p><a name="k12"></a></p>
<h2 id="k12">12. </h2>



<p><a name="k13"></a></p>
<h2 id="k13">13. </h2>



<p><a name="k14"></a></p>
<h2 id="k14">14. </h2>



<p><a name="k15"></a></p>
<h2 id="k15">15. </h2>



<p><a name="k16"></a></p>
<h2 id="k16">16. </h2>



<p><a name="k17"></a></p>
<h2 id="k17">17. </h2>



<p><a name="k18"></a></p>
<h2 id="k18">18. Příloha: všechny instrukce z&nbsp;instrukční sady A64 použité v&nbsp;článku</h2>

<p></p>

<table>
<tr><th></th><th></th></tr>
<tr><td></td><td></td></tr>
</table>



<p><a name="k19"></a></p>
<h2 id="k19">19. Repositář s&nbsp;demonstračními příklady</h2>

<p>Demonstrační příklady napsané v&nbsp;jazyku C, které jsou určené pro překlad
s&nbsp;využitím překladače <strong>gcc</strong> pro platformu AArch64, byly
uloženy do Git repositáře, který je dostupný na adrese <a
href="https://github.com/tisnik/8bit-fame">https://github.com/tisnik/8bit-fame</a>.
Jednotlivé demonstrační příklady si můžete v&nbsp;případě potřeby stáhnout i
jednotlivě bez nutnosti klonovat celý (dnes již poměrně rozsáhlý)
repositář:</p>

<table>
<tr><th> #</th><th>Příklad</th><th>Stručný popis</th><th>Adresa</th></tr>
<tr><td> 1</td><td>fp16_add.c</td><td>operace součtu dvou hodnot typu <i>half float</i></td><td><a href="https://github.com/tisnik/8bit-fame/blob/master/fp/fp16_add.c">https://github.com/tisnik/8bit-fame/blob/master/fp/fp16_add.c</a></td></tr>
<tr><td> 2</td><td>fp16_add.asm</td><td>překlad operace součtu dvou hodnot typu <i>half float</i></td><td><a href="https://github.com/tisnik/8bit-fame/blob/master/fp/fp16_add.asm">https://github.com/tisnik/8bit-fame/blob/master/fp/fp16_add.asm</a></td></tr>
<tr><td> 3</td><td>fp16_add_fp16.asm</td><td>překlad využívající instrukce pro přímé operace s&nbsp;hodnotami typu <i>half float</i></td><td><a href="https://github.com/tisnik/8bit-fame/blob/master/fp/fp16_add_fp16.asm">https://github.com/tisnik/8bit-fame/blob/master/fp/fp16_add_fp16.asm</a></td></tr>
<tr><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td></tr>
<tr><td> 4</td><td>fp16_arith.c</td><td>všechny čtyři základní aritmetické operace nad typy <i>half float</i></td><td><a href="https://github.com/tisnik/8bit-fame/blob/master/fp/fp16_arith.c">https://github.com/tisnik/8bit-fame/blob/master/fp/fp16_arith.c</a></td></tr>
<tr><td> 5</td><td>fp16_arith.asm</td><td>překlad všech čtyř základních aritmetických operací</td><td><a href="https://github.com/tisnik/8bit-fame/blob/master/fp/fp16_arith.asm">https://github.com/tisnik/8bit-fame/blob/master/fp/fp16_arith.asm</a></td></tr>
<tr><td> 6</td><td>fp16_arith_fp16.asm</td><td>překlad všech čtyř základních aritmetických operací s&nbsp;přímými instrukcemi pro <i>half float</i></td><td><a href="https://github.com/tisnik/8bit-fame/blob/master/fp/fp16_arith_fp16.asm">https://github.com/tisnik/8bit-fame/blob/master/fp/fp16_arith_fp16.asm</a></td></tr>
<tr><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td></tr>
<tr><td> 7</td><td>fp16_comparison.c</td><td>realizace všech šesti operací pro porovnání dvou hodnot typu <i>half float</i></td><td><a href="https://github.com/tisnik/8bit-fame/blob/master/fp/fp16_comparison.c">https://github.com/tisnik/8bit-fame/blob/master/fp/fp16_comparison.c</a></td></tr>
<tr><td> 8</td><td>fp16_comparison.asm</td><td>překlad operací pro porovnání dvou hodnot typu <i>half float</i></td><td><a href="https://github.com/tisnik/8bit-fame/blob/master/fp/fp16_comparison.asm">https://github.com/tisnik/8bit-fame/blob/master/fp/fp16_comparison.asm</a></td></tr>
<tr><td> 9</td><td>fp16_comparison_fp16.asm</td><td>překlad operací pro porovnání dvou hodnot typu <i>half float</i> s&nbsp;přímými instrukcemi</td><td><a href="https://github.com/tisnik/8bit-fame/blob/master/fp/fp16_comparison_fp16.asm">https://github.com/tisnik/8bit-fame/blob/master/fp/fp16_comparison_fp16.asm</a></td></tr>
<tr><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td></tr>
<tr><td>10</td><td>fp16_add_delta.c</td><td>přičtení konstanty ke všem prvkům pole</td><td><a href="https://github.com/tisnik/8bit-fame/blob/master/fp/fp16_add_delta.c">https://github.com/tisnik/8bit-fame/blob/master/fp/fp16_add_delta.c</a></td></tr>
<tr><td>11</td><td>fp16_add_delta.asm</td><td>překlad do strojového kódu bez přímého povolení manipulace s&nbsp;typy <i>half float</i></td><td><a href="https://github.com/tisnik/8bit-fame/blob/master/fp/fp16_add_delta.asm">https://github.com/tisnik/8bit-fame/blob/master/fp/fp16_add_delta.asm</a></td></tr>
<tr><td>12</td><td>fp16_add_delta_fp16.asm</td><td>překlad do strojového kódu s&nbsp;přímým povolení manipulace s&nbsp;typy <i>half float</i></td><td><a href="https://github.com/tisnik/8bit-fame/blob/master/fp/fp16_add_delta_fp16.asm">https://github.com/tisnik/8bit-fame/blob/master/fp/fp16_add_delta_fp16.asm</a></td></tr>
<tr><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td></tr>
<tr><td>13</td><td>fp16_add_arrays_32.c</td><td>součet odpovídajících si prvků polí typu <i>half float</i> se známou délkou</td><td><a href="https://github.com/tisnik/8bit-fame/blob/master/fp/fp16_add_arrays_32.c">https://github.com/tisnik/8bit-fame/blob/master/fp/fp16_add_arrays_32.c</a></td></tr>
<tr><td>14</td><td>fp16_add_arrays_32.asm</td><td>překlad do strojového kódu bez přímého povolení manipulace s&nbsp;typy <i>half float</i></td><td><a href="https://github.com/tisnik/8bit-fame/blob/master/fp/fp16_add_arrays_32.asm">https://github.com/tisnik/8bit-fame/blob/master/fp/fp16_add_arrays_32.asm</a></td></tr>
<tr><td>15</td><td>fp16_add_arrays_32_fp16.asm</td><td>překlad do strojového kódu s&nbsp;přímým povolení manipulace s&nbsp;typy <i>half float</i></td><td><a href="https://github.com/tisnik/8bit-fame/blob/master/fp/fp16_add_arrays_32_fp16.asm">https://github.com/tisnik/8bit-fame/blob/master/fp/fp16_add_arrays_32_fp16.asm</a></td></tr>
<tr><td>16</td><td>fp16_add_arrays_32_restrict.c</td><td>součet odpovídajících si prvků polí typu <i>half float</i>, zajištění, že se pole nepřekrývají</td><td><a href="https://github.com/tisnik/8bit-fame/blob/master/fp/fp16_add_arrays_32_restrict.c">https://github.com/tisnik/8bit-fame/blob/master/fp/fp16_add_arrays_32_restrict.c</a></td></tr>
<tr><td>17</td><td>fp16_add_arrays_32_restrict.asm</td><td>překlad do strojového kódu s&nbsp;přímým povolení manipulace s&nbsp;typy <i>half float</i></td><td><a href="https://github.com/tisnik/8bit-fame/blob/master/fp/fp16_add_arrays_32_restrict.asm">https://github.com/tisnik/8bit-fame/blob/master/fp/fp16_add_arrays_32_restrict.asm</a></td></tr>
<tr><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td></tr>
<tr><td>18</td><td>fp16_add_arrays_16.c</td><td>součet odpovídajících si prvků polí typu <i>half float</i> se známou délkou</td><td><a href="https://github.com/tisnik/8bit-fame/blob/master/fp/fp16_add_arrays_16.c">https://github.com/tisnik/8bit-fame/blob/master/fp/fp16_add_arrays_16.c</a></td></tr>
<tr><td>19</td><td>fp16_add_arrays_16.asm</td><td>překlad do strojového kódu bez přímého povolení manipulace s&nbsp;typy <i>half float</i></td><td><a href="https://github.com/tisnik/8bit-fame/blob/master/fp/fp16_add_arrays_16.asm">https://github.com/tisnik/8bit-fame/blob/master/fp/fp16_add_arrays_16.asm</a></td></tr>
<tr><td>20</td><td>fp16_add_arrays_16_fp16.asm</td><td>překlad do strojového kódu s&nbsp;přímým povolení manipulace s&nbsp;typy <i>half float</i></td><td><a href="https://github.com/tisnik/8bit-fame/blob/master/fp/fp16_add_arrays_16_fp16.asm">https://github.com/tisnik/8bit-fame/blob/master/fp/fp16_add_arrays_16_fp16.asm</a></td></tr>
<tr><td>21</td><td>fp16_add_arrays_16_restrict.c</td><td>součet odpovídajících si prvků polí typu <i>half float</i>, zajištění, že se pole nepřekrývají</td><td><a href="https://github.com/tisnik/8bit-fame/blob/master/fp/fp16_add_arrays_16_restrict.c">https://github.com/tisnik/8bit-fame/blob/master/fp/fp16_add_arrays_16_restrict.c</a></td></tr>
<tr><td>22</td><td>fp16_add_arrays_16_restrict.asm</td><td></td><td><a href="https://github.com/tisnik/8bit-fame/blob/master/fp/fp16_add_arrays_16_restrict.asm">https://github.com/tisnik/8bit-fame/blob/master/fp/fp16_add_arrays_16_restrict.asm</a></td></tr>
<tr><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td></tr>
<tr><td>23</td><td>fp16_vector_size.c</td><td>získání a tisk velikosti prvku typu <i>half float</i> i vektoru s&nbsp;těmito prvky</td><td><a href="https://github.com/tisnik/8bit-fame/blob/master/fp/fp16_vector_size.c">https://github.com/tisnik/8bit-fame/blob/master/fp/fp16_vector_size.c</a></td></tr>
<tr><td>24</td><td>fp16_vector_incorrect_size_1.c</td><td>pokus o konstrukci vektoru s&nbsp;neplatnou velikostí</td><td><a href="https://github.com/tisnik/8bit-fame/blob/master/fp/fp16_vector_incorrect_size_1.c">https://github.com/tisnik/8bit-fame/blob/master/fp/fp16_vector_incorrect_size_1.c</a></td></tr>
<tr><td>25</td><td>fp16_vector_incorrect_size_2.c</td><td>pokus o konstrukci vektoru s&nbsp;neplatnou velikostí</td><td><a href="https://github.com/tisnik/8bit-fame/blob/master/fp/fp16_vector_incorrect_size_2.c">https://github.com/tisnik/8bit-fame/blob/master/fp/fp16_vector_incorrect_size_2.c</a></td></tr>
<tr><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td></tr>
<tr><td>26</td><td></td><td></td><td><a href="https://github.com/tisnik/8bit-fame/blob/master/fp/">https://github.com/tisnik/8bit-fame/blob/master/fp/</a></td></tr>
<tr><td>27</td><td></td><td></td><td><a href="https://github.com/tisnik/8bit-fame/blob/master/fp/">https://github.com/tisnik/8bit-fame/blob/master/fp/</a></td></tr>
<tr><td>28</td><td></td><td></td><td><a href="https://github.com/tisnik/8bit-fame/blob/master/fp/">https://github.com/tisnik/8bit-fame/blob/master/fp/</a></td></tr>
<tr><td>29</td><td></td><td></td><td><a href="https://github.com/tisnik/8bit-fame/blob/master/fp/">https://github.com/tisnik/8bit-fame/blob/master/fp/</a></td></tr>
<tr><td>30</td><td></td><td></td><td><a href="https://github.com/tisnik/8bit-fame/blob/master/fp/">https://github.com/tisnik/8bit-fame/blob/master/fp/</a></td></tr>
<tr><td>31</td><td></td><td></td><td><a href="https://github.com/tisnik/8bit-fame/blob/master/fp/">https://github.com/tisnik/8bit-fame/blob/master/fp/</a></td></tr>
<tr><td>32</td><td></td><td></td><td><a href="https://github.com/tisnik/8bit-fame/blob/master/fp/">https://github.com/tisnik/8bit-fame/blob/master/fp/</a></td></tr>
<tr><td>33</td><td></td><td></td><td><a href="https://github.com/tisnik/8bit-fame/blob/master/fp/">https://github.com/tisnik/8bit-fame/blob/master/fp/</a></td></tr>
<tr><td>34</td><td></td><td></td><td><a href="https://github.com/tisnik/8bit-fame/blob/master/fp/">https://github.com/tisnik/8bit-fame/blob/master/fp/</a></td></tr>
<tr><td>35</td><td></td><td></td><td><a href="https://github.com/tisnik/8bit-fame/blob/master/fp/">https://github.com/tisnik/8bit-fame/blob/master/fp/</a></td></tr>
<tr><td>36</td><td></td><td></td><td><a href="https://github.com/tisnik/8bit-fame/blob/master/fp/">https://github.com/tisnik/8bit-fame/blob/master/fp/</a></td></tr>
<tr><td>37</td><td></td><td></td><td><a href="https://github.com/tisnik/8bit-fame/blob/master/fp/">https://github.com/tisnik/8bit-fame/blob/master/fp/</a></td></tr>
<tr><td>38</td><td></td><td></td><td><a href="https://github.com/tisnik/8bit-fame/blob/master/fp/">https://github.com/tisnik/8bit-fame/blob/master/fp/</a></td></tr>
</table>


fp16_vector_add_1.asm
fp16_vector_add_1.c
fp16_vector_add_2.asm
fp16_vector_add_2.c
fp16_vector_arith_1.asm
fp16_vector_arith_1.c
fp16_vector_arith_2.asm
fp16_vector_arith_2.c
fp16_vector_convert_1.asm
fp16_vector_convert_1.c
fp16_vector_convert_2.asm
fp16_vector_convert_2.c
fp16_vector_delta.asm
fp16_vector_delta.c
fp16_vector_mac.asm
fp16_vector_mac.c
fp16_vector_sum.asm
fp16_vector_sum.c
fp16_vector_zeros.asm
fp16_vector_zeros.c



<p><a name="k20"></a></p>
<h2 id="k20">20. Odkazy na Internetu</h2>

<ol>

<li>NEON Technology (stránky ARM)<br />
<a href="https://developer.arm.com/technologies/neon">https://developer.arm.com/technologies/neon</a>
</li>

<li>SIMD Assembly Tutorial: ARM NEON - Xiph.org<br />
<a href="https://people.xiph.org/~tterribe/daala/neon_tutorial.pdf">https://people.xiph.org/~tterribe/daala/neon_tutorial.pdf</a>
</li>

<li>Ne10<br />
<a href="http://projectne10.github.io/Ne10/">http://projectne10.github.io/Ne10/</a>
</li>

<li>NEON and Floating-Point architecture<br />
<a href="http://infocenter.arm.com/help/index.jsp?topic=/com.arm.doc.den0024a/BABIGHEB.html">http://infocenter.arm.com/help/index.jsp?topic=/com.arm.doc.den0024a/BABIGHEB.html</a>
</li>

<li>An Introduction to ARM NEON<br />
<a href="http://peterdn.com/post/an-introduction-to-ARM-NEON.aspx">http://peterdn.com/post/an-introduction-to-ARM-NEON.aspx</a>
</li>

<li>ARM NEON Intrinsics Reference<br />
<a href="http://infocenter.arm.com/help/topic/com.arm.doc.ihi0073a/IHI0073A_arm_neon_intrinsics_ref.pdf">http://infocenter.arm.com/help/topic/com.arm.doc.ihi0073a/IHI0073A_arm_neon_intrinsics_ref.pdf</a>
</li>

<li>Arm Neon Intrinsics vs hand assembly<br />
<a href="https://stackoverflow.com/questions/9828567/arm-neon-intrinsics-vs-hand-assembly">https://stackoverflow.com/questions/9828567/arm-neon-intrinsics-vs-hand-assembly</a>
</li>

<li>ARM NEON Optimization. An Example<br />
<a href="http://hilbert-space.de/?p=22">http://hilbert-space.de/?p=22</a>
</li>

<li>AArch64 NEON instruction format<br />
<a href="https://developer.arm.com/docs/den0024/latest/7-aarch64-floating-point-and-neon/73-aarch64-neon-instruction-format">https://developer.arm.com/docs/den0024/latest/7-aarch64-floating-point-and-neon/73-aarch64-neon-instruction-format</a>
</li>

<li>Vektorové procesory aneb další pokus o zvýšení výpočetního výkonu počítačů<br />
<a href="http://www.root.cz/clanky/vektorove-procesory-aneb-dalsi-pokus-o-zvyseni-vypocetniho-vykonu-pocitacu/">http://www.root.cz/clanky/vektorove-procesory-aneb-dalsi-pokus-o-zvyseni-vypocetniho-vykonu-pocitacu/</a>
</li>

<li>SIMD instrukce využívané v moderních mikroprocesorech řady x86<br />
<a href="http://www.root.cz/clanky/simd-instrukce-vyuzivane-v-modernich-mikroprocesorech-rady-x86/">http://www.root.cz/clanky/simd-instrukce-vyuzivane-v-modernich-mikroprocesorech-rady-x86/</a>
</li>

<li>SIMD instrukce v moderních mikroprocesorech řady x86 (2.část: SSE)<br />
<a href="http://www.root.cz/clanky/simd-instrukce-v-modernich-mikroprocesorech-rady-x86-2-cast-sse/">http://www.root.cz/clanky/simd-instrukce-v-modernich-mikroprocesorech-rady-x86-2-cast-sse/</a>
</li>

<li>SIMD instrukce v moderních mikroprocesorech řady x86 (3.část: SSE2)<br />
<a href="http://www.root.cz/clanky/simd-instrukce-v-modernich-mikroprocesorech-rady-x86-3-cast-sse2/">http://www.root.cz/clanky/simd-instrukce-v-modernich-mikroprocesorech-rady-x86-3-cast-sse2/</a>
</li>

<li>Instrukce typu SIMD na mikroprocesorech RISC<br />
<a href="http://www.root.cz/clanky/instrukce-typu-simd-na-mikroprocesorech-risc/">http://www.root.cz/clanky/instrukce-typu-simd-na-mikroprocesorech-risc/</a>
</li>

<li>Instrukce typu SIMD na mikroprocesorech RISC (2. část)<br />
<a href="http://www.root.cz/clanky/instrukce-typu-simd-na-mikroprocesorech-risc-2-cast/">http://www.root.cz/clanky/instrukce-typu-simd-na-mikroprocesorech-risc-2-cast/</a>
</li>

<li>Instrukce typu SIMD na mikroprocesorech RISC (3.část - MIPS-3D a VIS)<br />
<a href="http://www.root.cz/clanky/instrukce-typu-simd-na-mikroprocesorech-risc-3-cast-mips-3d-a-vis/">http://www.root.cz/clanky/instrukce-typu-simd-na-mikroprocesorech-risc-3-cast-mips-3d-a-vis/</a>
</li>

<li>Trasování a ladění nativních aplikací v&nbsp;Linuxu<br />
<a href="https://www.root.cz/clanky/trasovani-a-ladeni-nativnich-aplikaci-v-linuxu/">https://www.root.cz/clanky/trasovani-a-ladeni-nativnich-aplikaci-v-linuxu/</a>
</li>

<li>Trasování a ladění nativních aplikací v&nbsp;Linuxu: použití GDB a jeho nadstaveb<br />
<a href="https://www.root.cz/clanky/trasovani-a-ladeni-nativnich-aplikaci-v-linuxu-pouziti-gdb-a-jeho-nadstaveb/">https://www.root.cz/clanky/trasovani-a-ladeni-nativnich-aplikaci-v-linuxu-pouziti-gdb-a-jeho-nadstaveb/</a>
</li>

<li>Debuggery a jejich nadstavby v Linuxu (3): Nemiver<br />
<a href="http://mojefedora.cz/debuggery-a-jejich-nadstavby-v-linuxu-3-nemiver/">http://mojefedora.cz/debuggery-a-jejich-nadstavby-v-linuxu-3-nemiver/</a>
</li>

<li>Debuggery a jejich nadstavby v Linuxu (4): KDbg<br />
<a href="http://mojefedora.cz/debuggery-a-jejich-nadstavby-v-linuxu-4-kdbg/">http://mojefedora.cz/debuggery-a-jejich-nadstavby-v-linuxu-4-kdbg/</a>
</li>

<li>Debuggery a jejich nadstavby v Linuxu (5): ladění aplikací v&nbsp;editorech Emacs a Vim<br />
<a href="http://mojefedora.cz/debuggery-a-jejich-nadstavby-v-linuxu-5-ladeni-aplikaci-v-editorech-emacs-a-vim/">http://mojefedora.cz/debuggery-a-jejich-nadstavby-v-linuxu-5-ladeni-aplikaci-v-editorech-emacs-a-vim/</a>
</li>

<li>Tracing (software)<br />
<a href="https://en.wikipedia.org/wiki/Tracing_%28software%29">https://en.wikipedia.org/wiki/Tracing_%28software%29</a>
</li>

<li>cgdb: the curses debugger<br />
<a href="https://cgdb.github.io/">https://cgdb.github.io/</a>
</li>

<li>cgdb: dokumentace<br />
<a href="https://cgdb.github.io/docs/cgdb-split.html">https://cgdb.github.io/docs/cgdb-split.html</a>
</li>

<li>strace(1) - Linux man page<br />
<a href="http://linux.die.net/man/1/strace">http://linux.die.net/man/1/strace</a>
</li>

<li>strace (stránka projektu na SourceForge)<br />
<a href="https://sourceforge.net/projects/strace/">https://sourceforge.net/projects/strace/</a>
</li>

<li>strace (Wikipedia)<br />
<a href="https://en.wikipedia.org/wiki/Strace">https://en.wikipedia.org/wiki/Strace</a>
</li>

<li>GDB - Dokumentace<br />
<a href="http://sourceware.org/gdb/current/onlinedocs/gdb/">http://sourceware.org/gdb/current/onlinedocs/gdb/</a>
</li>

<li>GDB - Supported Languages<br />
<a href="http://sourceware.org/gdb/current/onlinedocs/gdb/Supported-Languages.html#Supported-Languages">http://sourceware.org/gdb/current/onlinedocs/gdb/Supported-Languages.html#Supported-Languages</a>
</li>

<li>GNU Debugger (Wikipedia)<br />
<a href="https://en.wikipedia.org/wiki/GNU_Debugger">https://en.wikipedia.org/wiki/GNU_Debugger</a>
</li>

<li>The LLDB Debugger<br />
<a href="http://lldb.llvm.org/">http://lldb.llvm.org/</a>
</li>

<li>Debugger (Wikipedia)<br />
<a href="https://en.wikipedia.org/wiki/Debugger">https://en.wikipedia.org/wiki/Debugger</a>
</li>

<li>Comparison of ARMv8-A cores<br />
<a href="https://en.wikipedia.org/wiki/Comparison_of_ARMv8-A_cores">https://en.wikipedia.org/wiki/Comparison_of_ARMv8-A_cores</a>
</li>

<li>A64 General Instructions<br />
<a href="http://www.keil.com/support/man/docs/armclang_asm/armclang_asm_pge1427898258836.htm">http://www.keil.com/support/man/docs/armclang_asm/armclang_asm_pge1427898258836.htm</a>
</li>

<li>ARMv8 (AArch64) Instruction Encoding<br />
<a href="http://kitoslab-eng.blogspot.cz/2012/10/armv8-aarch64-instruction-encoding.html">http://kitoslab-eng.blogspot.cz/2012/10/armv8-aarch64-instruction-encoding.html</a>
</li>

<li>Cortex-A32 Processor<br />
<a href="https://www.arm.com/products/processors/cortex-a/cortex-a32-processor.php">https://www.arm.com/products/processors/cortex-a/cortex-a32-processor.php</a>
</li>

<li>Cortex-A35 Processor<br />
<a href="https://www.arm.com/products/processors/cortex-a/cortex-a35-processor.php">https://www.arm.com/products/processors/cortex-a/cortex-a35-processor.php</a>
</li>

<li>Cortex-A53 Processor<br />
<a href="https://www.arm.com/products/processors/cortex-a/cortex-a53-processor.php">https://www.arm.com/products/processors/cortex-a/cortex-a53-processor.php</a>
</li>

<li>Cortex-A57 Processor<br />
<a href="https://www.arm.com/products/processors/cortex-a/cortex-a57-processor.php">https://www.arm.com/products/processors/cortex-a/cortex-a57-processor.php</a>
</li>

<li>Cortex-A72 Processor<br />
<a href="https://www.arm.com/products/processors/cortex-a/cortex-a72-processor.php">https://www.arm.com/products/processors/cortex-a/cortex-a72-processor.php</a>
</li>

<li>Cortex-A73 Processor<br />
<a href="https://www.arm.com/products/processors/cortex-a/cortex-a73-processor.php">https://www.arm.com/products/processors/cortex-a/cortex-a73-processor.php</a>
</li>

<li>Apple A7 (SoC založen na CPU Cyclone)<br />
<a href="https://en.wikipedia.org/wiki/Apple_A7">https://en.wikipedia.org/wiki/Apple_A7</a>
</li>

<li>System cally pro AArch64 na Linuxu<br />
<a href="https://github.com/torvalds/linux/blob/master/include/uapi/asm-generic/unistd.h">https://github.com/torvalds/linux/blob/master/include/uapi/asm-generic/unistd.h</a>
</li>

<li>Architectures/AArch64 (FedoraProject.org)<br />
<a href="https://fedoraproject.org/wiki/Architectures/AArch64">https://fedoraproject.org/wiki/Architectures/AArch64</a>
</li>

<li>SIG pro AArch64 (CentOS)<br />
<a href="https://wiki.centos.org/SpecialInterestGroup/AltArch/AArch64">https://wiki.centos.org/SpecialInterestGroup/AltArch/AArch64</a>
</li>

<li>The ARMv8 instruction sets<br />
<a href="http://infocenter.arm.com/help/index.jsp?topic=/com.arm.doc.den0024a/ch05s01.html">http://infocenter.arm.com/help/index.jsp?topic=/com.arm.doc.den0024a/ch05s01.html</a>
</li>

<li>A64 Instruction Set<br />
<a href="https://developer.arm.com/products/architecture/instruction-sets/a64-instruction-set">https://developer.arm.com/products/architecture/instruction-sets/a64-instruction-set</a>
</li>

<li>Switching between the instruction sets<br />
<a href="http://infocenter.arm.com/help/index.jsp?topic=/com.arm.doc.den0024a/ch05s01.html">http://infocenter.arm.com/help/index.jsp?topic=/com.arm.doc.den0024a/ch05s01.html</a>
</li>

<li>The A64 instruction set<br />
<a href="http://infocenter.arm.com/help/index.jsp?topic=/com.arm.doc.den0024a/ch05s01.html">http://infocenter.arm.com/help/index.jsp?topic=/com.arm.doc.den0024a/ch05s01.html</a>
</li>

<li>Introduction to ARMv8 64-bit Architecture<br />
<a href="https://quequero.org/2014/04/introduction-to-arm-architecture/">https://quequero.org/2014/04/introduction-to-arm-architecture/</a>
</li>

<li>MCU market turns to 32-bits and ARM<br />
<a href="http://www.eetimes.com/document.asp?doc_id=1280803">http://www.eetimes.com/document.asp?doc_id=1280803</a>
</li>

<li>Cortex-M0 Processor (ARM Holdings)<br />
<a href="http://www.arm.com/products/processors/cortex-m/cortex-m0.php">http://www.arm.com/products/processors/cortex-m/cortex-m0.php</a>
</li>

<li>Cortex-M0+ Processor (ARM Holdings)<br />
<a href="http://www.arm.com/products/processors/cortex-m/cortex-m0plus.php">http://www.arm.com/products/processors/cortex-m/cortex-m0plus.php</a>
</li>

<li>ARM Processors in a Mixed Signal World<br />
<a href="http://www.eeweb.com/blog/arm/arm-processors-in-a-mixed-signal-world">http://www.eeweb.com/blog/arm/arm-processors-in-a-mixed-signal-world</a>
</li>

<li>ARM Architecture (Wikipedia)<br />
<a href="https://en.wikipedia.org/wiki/ARM_architecture">https://en.wikipedia.org/wiki/ARM_architecture</a>
</li>

<li>DSP for Cortex-M<br />
<a href="https://developer.arm.com/technologies/dsp/dsp-for-cortex-m">https://developer.arm.com/technologies/dsp/dsp-for-cortex-m</a>
</li>

<li>Cortex-M processors in DSP applications? Why not?!<br />
<a href="https://community.arm.com/processors/b/blog/posts/cortex-m-processors-in-dsp-applications-why-not">https://community.arm.com/processors/b/blog/posts/cortex-m-processors-in-dsp-applications-why-not</a>
</li>

<li>White Paper - DSP capabilities of Cortex-M4 and Cortex-M7<br />
<a href="https://community.arm.com/processors/b/blog/posts/white-paper-dsp-capabilities-of-cortex-m4-and-cortex-m7">https://community.arm.com/processors/b/blog/posts/white-paper-dsp-capabilities-of-cortex-m4-and-cortex-m7</a>
</li>

<li>Q (number format)<br />
<a href="https://en.wikipedia.org/wiki/Q_%28number_format%29">https://en.wikipedia.org/wiki/Q_%28number_format%29</a>
</li>

<li>TriCore Architecture &amp; Core<br />
<a href="http://www.infineon.com/cms/en/product/microcontroller/32-bit-tricore-tm-microcontroller/tricore-tm-architecture-and-core/channel.html?channel=ff80808112ab681d0112ab6b73d40837">http://www.infineon.com/cms/en/product/microcontroller/32-bit-tricore-tm-microcontroller/tricore-tm-architecture-and-core/channel.html?channel=ff80808112ab681d0112ab6b73d40837</a>
</li>

<li>TriCoreTM V1.6 Instruction Set: 32-bit Unified Processor Core<br />
<a href="http://www.infineon.com/dgdl/tc_v131_instructionset_v138.pdf?fileId=db3a304412b407950112b409b6dd0352">http://www.infineon.com/dgdl/tc_v131_instructionset_v138.pdf?fileId=db3a304412b407950112b409b6dd0352</a>
</li>

<li>TriCore v2.2 C Compiler, Assembler, Linker Reference Manual<br />
<a href="http://tasking.com/support/tricore/tc_reference_guide_v2.2.pdf">http://tasking.com/support/tricore/tc_reference_guide_v2.2.pdf</a>
</li>

<li>Infineon TriCore (Wikipedia)<br />
<a href="https://en.wikipedia.org/wiki/Infineon_TriCore">https://en.wikipedia.org/wiki/Infineon_TriCore</a>
</li>

<li>C166®S V2 Architecture &amp; Core<br />
<a href="http://www.infineon.com/cms/en/product/microcontroller/16-bit-c166-microcontroller/c166-s-v2-architecture-and-core/channel.html?channel=db3a304312bef5660112c3011c7d01ae">http://www.infineon.com/cms/en/product/microcontroller/16-bit-c166-microcontroller/c166-s-v2-architecture-and-core/channel.html?channel=db3a304312bef5660112c3011c7d01ae</a>
</li>

<li>Comparing four 32-bit soft processor cores<br />
<a href="http://www.eetimes.com/author.asp?section_id=14&doc_id=1286116">http://www.eetimes.com/author.asp?section_id=14&doc_id=1286116</a>
</li>

<li>RISC-V Instruction Set<br />
<a href="http://riscv.org/download.html#spec_compressed_isa">http://riscv.org/download.html#spec_compressed_isa</a>
</li>

<li>RISC-V Spike (ISA Simulator)<br />
<a href="http://riscv.org/download.html#isa-sim">http://riscv.org/download.html#isa-sim</a>
</li>

<li>RISC-V (Wikipedia)<br />
<a href="https://en.wikipedia.org/wiki/RISC-V">https://en.wikipedia.org/wiki/RISC-V</a>
</li>

<li>David Patterson (Wikipedia)<br />
<a href="https://en.wikipedia.org/wiki/David_Patterson_(computer_scientist)">https://en.wikipedia.org/wiki/David_Patterson_(computer_scientist)</a>
</li>

<li>OpenRISC (oficiální stránky projektu)<br />
<a href="http://openrisc.io/">http://openrisc.io/</a>
</li>

<li>OpenRISC architecture<br />
<a href="http://openrisc.io/architecture.html">http://openrisc.io/architecture.html</a>
</li>

<li>Emulátor OpenRISC CPU v JavaScriptu<br />
<a href="http://s-macke.github.io/jor1k/demos/main.html">http://s-macke.github.io/jor1k/demos/main.html</a>
</li>

<li>OpenRISC (Wikipedia)<br />
<a href="https://en.wikipedia.org/wiki/OpenRISC">https://en.wikipedia.org/wiki/OpenRISC</a>
</li>

<li>OpenRISC - instrukce<br />
<a href="http://sourceware.org/cgen/gen-doc/openrisc-insn.html">http://sourceware.org/cgen/gen-doc/openrisc-insn.html</a>
</li>

<li>OpenRISC - slajdy z přednášky o projektu<br />
<a href="https://iis.ee.ethz.ch/~gmichi/asocd/lecturenotes/Lecture6.pdf">https://iis.ee.ethz.ch/~gmichi/asocd/lecturenotes/Lecture6.pdf</a>
</li>

<li>Berkeley RISC<br />
<a href="http://en.wikipedia.org/wiki/Berkeley_RISC">http://en.wikipedia.org/wiki/Berkeley_RISC</a>
</li>

<li>Great moments in microprocessor history<br />
<a href="http://www.ibm.com/developerworks/library/pa-microhist.html">http://www.ibm.com/developerworks/library/pa-microhist.html</a>
</li>

<li>Microprogram-Based Processors<br />
<a href="http://research.microsoft.com/en-us/um/people/gbell/Computer_Structures_Principles_and_Examples/csp0167.htm">http://research.microsoft.com/en-us/um/people/gbell/Computer_Structures_Principles_and_Examples/csp0167.htm</a>
</li>

<li>Great Microprocessors of the Past and Present<br />
<a href="http://www.cpushack.com/CPU/cpu1.html">http://www.cpushack.com/CPU/cpu1.html</a>
</li>

<li>A Brief History of Microprogramming<br />
<a href="http://www.cs.clemson.edu/~mark/uprog.html">http://www.cs.clemson.edu/~mark/uprog.html</a>
</li>

<li>What is RISC?<br />
<a href="http://www-cs-faculty.stanford.edu/~eroberts/courses/soco/projects/2000-01/risc/whatis/">http://www-cs-faculty.stanford.edu/~eroberts/courses/soco/projects/2000-01/risc/whatis/</a>
</li>

<li>RISC vs. CISC<br />
<a href="http://www-cs-faculty.stanford.edu/~eroberts/courses/soco/projects/2000-01/risc/risccisc/">http://www-cs-faculty.stanford.edu/~eroberts/courses/soco/projects/2000-01/risc/risccisc/</a>
</li>

<li>RISC and CISC definitions:<br />
<a href="http://www.cpushack.com/CPU/cpuAppendA.html">http://www.cpushack.com/CPU/cpuAppendA.html</a>
</li>

<li>FPGA<br />
<a href="https://cs.wikipedia.org/wiki/Programovateln%C3%A9_hradlov%C3%A9_pole">https://cs.wikipedia.org/wiki/Programovateln%C3%A9_hradlov%C3%A9_pole</a>
</li>

<li>The Evolution of RISC<br />
<a href="http://www.ibm.com/developerworks/library/pa-microhist.html#sidebar1">http://www.ibm.com/developerworks/library/pa-microhist.html#sidebar1</a>
</li>

<li>List of ARM instructions implementing half-precision floating-point arithmetic<br />
<a href="https://stackoverflow.com/questions/76255632/list-of-arm-instructions-implementing-half-precision-floating-point-arithmetic">https://stackoverflow.com/questions/76255632/list-of-arm-instructions-implementing-half-precision-floating-point-arithmetic</a>
</li>

<li>Half-Precision Floating Point (GCC)<br />
<a href="https://gcc.gnu.org/onlinedocs/gcc/Half-Precision.html">https://gcc.gnu.org/onlinedocs/gcc/Half-Precision.html</a>
</li>

<li>Additional Floating Types (GCC)<br />
<a href="https://gcc.gnu.org/onlinedocs/gcc/Floating-Types.html">https://gcc.gnu.org/onlinedocs/gcc/Floating-Types.html</a>
</li>

<li>Advanced SIMD (Neon)<br />
<a href="https://en.wikipedia.org/wiki/ARM_architecture_family#Advanced_SIMD_(NEON)">https://en.wikipedia.org/wiki/ARM_architecture_family#Advanced_SIMD_(NEON)</a>
</li>

<li>GCC: ARM options<br />
<a href="https://gcc.gnu.org/onlinedocs/gcc/ARM-Options.html">https://gcc.gnu.org/onlinedocs/gcc/ARM-Options.html</a>
</li>

<li>Compile ARM Neon intrinsics on macos (M3 chipsets) using clang<br />
<a href="https://stackoverflow.com/questions/79056335/compile-arm-neon-intrinsics-on-macos-m3-chipsets-using-clang">https://stackoverflow.com/questions/79056335/compile-arm-neon-intrinsics-on-macos-m3-chipsets-using-clang</a>
</li>

<li>Intrinsics - Arm Developer<br />
<a href="https://developer.arm.com/architectures/instruction-sets/intrinsics/">https://developer.arm.com/architectures/instruction-sets/intrinsics/</a>
</li>

<li>FCMEQ (register)<br />
<a href="https://www.scs.stanford.edu/~zyedidia/arm64/fcmeq_advsimd_reg.html">https://www.scs.stanford.edu/~zyedidia/arm64/fcmeq_advsimd_reg.html</a>
</li>

<li>FCMGE (register)<br />
<a href="https://www.scs.stanford.edu/~zyedidia/arm64/fcmge_advsimd_reg.html">https://www.scs.stanford.edu/~zyedidia/arm64/fcmge_advsimd_reg.html</a>
</li>

<li>FCMGT (register)<br />
<a href="https://www.scs.stanford.edu/~zyedidia/arm64/fcmgt_advsimd_reg.html">https://www.scs.stanford.edu/~zyedidia/arm64/fcmgt_advsimd_reg.html</a>
</li>

<li>A whirlwind tour of AArch64 vector instructions (NEON)<br />
<a href="https://www.corsix.org/content/whirlwind-tour-aarch64-vector-instructions">https://www.corsix.org/content/whirlwind-tour-aarch64-vector-instructions</a>
</li>

<li>How is arm_neon.h generated or maintained?<br />
<a href="https://stackoverflow.com/questions/71422209/how-is-arm-neon-h-generated-or-maintained">https://stackoverflow.com/questions/71422209/how-is-arm-neon-h-generated-or-maintained</a>
</li>

<li>Arm Neon programming quick reference<br />
<a href="https://community.arm.com/arm-community-blogs/b/operating-systems-blog/posts/arm-neon-programming-quick-reference">https://community.arm.com/arm-community-blogs/b/operating-systems-blog/posts/arm-neon-programming-quick-reference</a>
</li>

</ol>



<p></p><p></p>
<p><small>Autor: <a href="https://github.com/tisnik/">Pavel Tišnovský</a> &nbsp; 2025</small></p>
</body>
</html>

