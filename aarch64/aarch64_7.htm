<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
        "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html>
<head>
<title></title>
<meta name="Author" content="Pavel Tisnovsky" />
<meta name="Generator" content="vim" />
<meta http-equiv="content-type" content="text/html; charset=utf-8" />
<style type="text/css">
         body {color:#000000; background:#ffffff;}
         h1  {font-family: arial, helvetica, sans-serif; color:#ffffff; background-color:#c00000; text-align:center; padding-left:1em}
         h2  {font-family: arial, helvetica, sans-serif; color:#ffffff; background-color:#0000c0; padding-left:1em; text-align:left}
         h3  {font-family: arial, helvetica, sans-serif; color:#000000; background-color:#c0c0c0; padding-left:1em; text-align:left}
         h4  {font-family: arial, helvetica, sans-serif; color:#000000; background-color:#e0e0e0; padding-left:1em; text-align:left}
         a   {font-family: arial, helvetica, sans-serif;}
         li  {font-family: arial, helvetica, sans-serif; color:#000000; text-align:justify; width:450px;}
         ol  {font-family: arial, helvetica, sans-serif; color:#000000; text-align:justify; width:450px;}
         ul  {font-family: arial, helvetica, sans-serif; color:#000000; text-align:justify; width:450px;}
         p   {font-family: arial, helvetica, sans-serif; color:#000000; text-align:justify;}
         pre {background:#e0e0e0}
</style>
</head>

<body>

<h1></h1>

<h3>Pavel Tišnovský</h3>

<p></p>

<h1>Úvodník</h1>

<p></p>



<h2>Obsah</h2>

<p><a href="#k01">*** 1. </a></p>
<p><a href="#k02">2. Dostupné intrinsic funkce pro manipulaci s&nbsp;hodnotami typu <i>half float</i></a></p>
<p><a href="#k03">3. Podpora pro manipulaci s&nbsp;celými vektory v&nbsp;GCC</a></p>
<p><a href="#k04">4. Vektory obsahující prvky typu <i>half float</i> na platformě AArch64</a></p>
<p><a href="#k05">5. Korektní a nekorektní velikost vektorů</a></p>
<p><a href="#k06">6. Základní aritmetické operace s&nbsp;vektory</a></p>
<p><a href="#k07">7. Způsob překladu aritmetických operací s&nbsp;prvky vektorů do strojového kódu A64</a></p>
<p><a href="#k08">8. Zpracování delších vektorů</a></p>
<p><a href="#k09">9. Základní aritmetické operace s&nbsp;vektory obsahujícími 64 prvků</a></p>
<p><a href="#k10">10. Stejná operace prováděná se všemi prvky vektorů</a></p>
<p><a href="#k11">11. Konverze všech prvků vektoru: z&nbsp;typu <i>half float</i> na typ <i>float</i></a></p>
<p><a href="#k12">12. Konverze všech prvků vektoru: z&nbsp;typu <i>float</i> na typ <i>half float</i></a></p>
<p><a href="#k13">13. Operace <i>Multiply–accumulate</i> (<i>MAC</i>) s&nbsp;vektory</a></p>
<p><a href="#k14">*** 14. Součet všech prvků vektoru</a></p>
<p><a href="#k15">*** 15. Alternativní realizace součtu všech prvků vektoru</a></p>
<p><a href="#k16">*** 16. </a></p>
<p><a href="#k17">*** 17. Porovnání prvků vektorů s&nbsp;konstantou</a></p>
<p><a href="#k18">*** 18. Příloha: všechny instrukce z&nbsp;instrukční sady A64 použité v&nbsp;článku</a></p>
<p><a href="#k19">19. Repositář s&nbsp;demonstračními příklady</a></p>
<p><a href="#k20">20. Odkazy na Internetu</a></p>



<p><a name="k01"></a></p>
<h2 id="k01">1. </h2>



<p><a name="k02"></a></p>
<h2 id="k02">2. Dostupné intrinsic funkce pro manipulaci s&nbsp;hodnotami typu <i>half float</i></h2>

<p>V&nbsp;moderních překladačích programovacího jazyka C, přesněji řečeno
v&nbsp;těch překladačích, které podporují platformu AArch64, jsou většinou
definovány intrinsic funkce (či jen <i>intrinsic</i>), jejichž volání
z&nbsp;céčkovského kódu se přímo překládá na instrukce cílové platformy (bez
samotného volání funkce, předávání parametrů atd.). Některé příklady jsme si
ukázali minule, takže si nyní ve stručnosti připomeneme, jakým způsobem se
intrinsic překládají do strojového kódu. Pochopitelně zůstaneme u těch operací,
které pracují s&nbsp;hodnotami typu <i>half float</i></p>

<pre>
#include &lt;arm_fp16.h&gt;
#include &lt;stdio.h&gt;
&nbsp;
void <strong>fp16_arithm</strong>(_Float16 x, _Float16 y) {
    _Float16 a=vaddh_f16(x, y);
    _Float16 b=vsubh_f16(x, y);
    _Float16 c=vmulh_f16(x, y);
    _Float16 d=vdivh_f16(x, y);
&nbsp;
    <i>// donutíme překladač, aby předchozí intrinsic skutečně vygeneroval do kódu</i>
    printf("%f %f %f %f\n", (double)a, (double)b, (double)c, (double)d);
}
</pre>

<p>Ve vygenerovaném kódu se na prvních čtyřech řádcích objevuje přímé volání
instrukcí, které provádí základní aritmetické operace s&nbsp;hodnotami typu
<i>half float</i>; zbytek kódu se týká volání funkce <strong>printf</strong>
(ovšem je zajímavé, jak &bdquo;levný&ldquo; je převod hodnot <i>half float</i>
na typ <i>double</i>):</p>

<pre>
<strong>fp16_arithm</strong>:
        fdiv    h3, h0, h1
        fmul    h2, h0, h1
        fsub    h31, h0, h1
        fadd    h0, h0, h1
        adrp    x0, .LC0
        add     x0, x0, :lo12:.LC0
        fcvt    d2, h2
        fcvt    d1, h31
        fcvt    d0, h0
        fcvt    d3, h3
        b       printf
</pre>

<p>Podobných intrinsic existuje celá řada. V&nbsp;následující tabulce jsou
vypsány ty intrinsic pro zpracování hodnot typu <i>half float</i>, které lze
volat v&nbsp;GCC:</p>

<table>
<tr><th>Návratová hodnota</td><td>Jméno funkce</td><td>Parametry</td></tr>
<tr><td>float16_t</td><td>vabsh_f16</td><td>float16_t __a</td></tr>
<tr><td>float16_t</td><td>vaddh_f16</td><td>float16_t __a, float16_t __b</td></tr>
<tr><td>int32_t</td><td>vcvtah_s32_f16</td><td>float16_t __a</td></tr>
<tr><td>uint32_t</td><td>vcvtah_u32_f16</td><td>float16_t __a</td></tr>
<tr><td>float16_t</td><td>vcvth_f16_s32</td><td>int32_t __a</td></tr>
<tr><td>float16_t</td><td>vcvth_f16_u32</td><td>uint32_t __a</td></tr>
<tr><td>float16_t</td><td>vcvth_n_f16_s32</td><td>int32_t __a, const int __b</td></tr>
<tr><td>float16_t</td><td>vcvth_n_f16_u32</td><td>uint32_t __a, const int __b</td></tr>
<tr><td>int32_t</td><td>vcvth_n_s32_f16</td><td>float16_t __a, const int __b</td></tr>
<tr><td>uint32_t</td><td>vcvth_n_u32_f16</td><td>float16_t __a, const int __b</td></tr>
<tr><td>int32_t</td><td>vcvth_s32_f16</td><td>float16_t __a</td></tr>
<tr><td>uint32_t</td><td>vcvth_u32_f16</td><td>float16_t __a</td></tr>
<tr><td>int32_t</td><td>vcvtmh_s32_f16</td><td>float16_t __a</td></tr>
<tr><td>uint32_t</td><td>vcvtmh_u32_f16</td><td>float16_t __a</td></tr>
<tr><td>int32_t</td><td>vcvtnh_s32_f16</td><td>float16_t __a</td></tr>
<tr><td>uint32_t</td><td>vcvtnh_u32_f16</td><td>float16_t __a</td></tr>
<tr><td>int32_t</td><td>vcvtph_s32_f16</td><td>float16_t __a</td></tr>
<tr><td>uint32_t</td><td>vcvtph_u32_f16</td><td>float16_t __a</td></tr>
<tr><td>float16_t</td><td>vdivh_f16</td><td>float16_t __a, float16_t __b</td></tr>
<tr><td>float16_t</td><td>vfmah_f16</td><td>float16_t __a, float16_t __b, float16_t __c</td></tr>
<tr><td>float16_t</td><td>vfmsh_f16</td><td>float16_t __a, float16_t __b, float16_t __c</td></tr>
<tr><td>float16_t</td><td>vmaxnmh_f16</td><td>float16_t __a, float16_t __b</td></tr>
<tr><td>float16_t</td><td>vminnmh_f16</td><td>float16_t __a, float16_t __b</td></tr>
<tr><td>float16_t</td><td>vmulh_f16</td><td>float16_t __a, float16_t __b</td></tr>
<tr><td>float16_t</td><td>vnegh_f16</td><td>float16_t __a</td></tr>
<tr><td>float16_t</td><td>vrndah_f16</td><td>float16_t __a</td></tr>
<tr><td>float16_t</td><td>vrndh_f16</td><td>float16_t __a</td></tr>
<tr><td>float16_t</td><td>vrndih_f16</td><td>float16_t __a</td></tr>
<tr><td>float16_t</td><td>vrndmh_f16</td><td>float16_t __a</td></tr>
<tr><td>float16_t</td><td>vrndnh_f16</td><td>float16_t __a</td></tr>
<tr><td>float16_t</td><td>vrndph_f16</td><td>float16_t __a</td></tr>
<tr><td>float16_t</td><td>vrndxh_f16</td><td>float16_t __a</td></tr>
<tr><td>float16_t</td><td>vsqrth_f16</td><td>float16_t __a</td></tr>
<tr><td>float16_t</td><td>vsubh_f16</td><td>float16_t __a, float16_t __b</td></tr>
</table>

<p><div class="rs-tip-major">Poznámka: nenechte se zmýlit prefixem
&bdquo;v&ldquo;</div>, protože tyto intrinsic nepracují s&nbsp;vektory, ale se
skalárními hodnotami.</p>



<p><a name="k03"></a></p>
<h2 id="k03">3. Podpora pro manipulaci s&nbsp;celými vektory v&nbsp;GCC</h2>

<p>Intrinsic funkce, které byly zmíněny <a href="#k02">v&nbsp;předchozí
kapitole</a>, mají své specifické využití a vyplatí se alespoň vědět o jejich
existenci. Ovšem jak již víme z&nbsp;předchozího článku, některé z&nbsp;nich
lze nahradit běžnými operátory jazyka C (nad typy <i>half float</i>).
Zajímavější situace ovšem nastane, pokud budeme vyžadovat práci s&nbsp;celými
vektory prvků typu <i>half float</i>. I to je možné (do jisté míry) zajistit,
protože GCC (ale i některé další překladače) nabízí vývojářům takzvané
&bdquo;vektorové rozšíření&ldquo;, se kterým jsme se setkali v&nbsp;článcích o
SIMD. Vzhledem k&nbsp;tomu, že se jedná o ústřední téma dnešního článku,
připomeneme si základní vlastnosti tohoto vektorového rozšíření.</p>

<p>GCC umožňuje definici nových datových struktur typu &bdquo;vektor prvků
X&ldquo;. Definice takového datového typu obecně vypadá takto:</p>

<pre>
typedef <u>typ_prvku</u> <strong>jméno_typu</strong> __attribute__((vector_size(<u>velikost_vektoru_v_bajtech</u>)));
</pre>

<p><div class="rs-tip-major">Poznámka: jedná se sice o poměrně kryptický zápis,
ovšem ve skutečnosti bude ve zdrojových kódech typicky uveden na jediném místě
(v&nbsp;hlavičkovém souboru), kde je taktéž vhodné ho okomentovat.</div></p>

<p>Podívejme se na následující demonstrační příklad, ve kterém je definován
nový datový typ nazvaný <strong>v16us</strong> (jméno může být pochopitelně
jakékoli). Jedná se o vektor o délce šestnácti bajtů, který obsahuje prvky typu
<strong>short int</strong>, což zde konkrétně může znamenat, že se do vektoru
vejde celkem osm těchto prvků za předpokladu, že <strong>sizeof(unsigned short
int)==2</strong>:</p>

<pre>
typedef <i>unsigned short int</i> <strong>v16us</strong> __attribute__((vector_size(<u>16</u>)));
</pre>

<p>Velikost jednoho prvku vektoru i velikost celého vektoru získáme operátorem
<strong>sizeof</strong>, což si můžeme snadno ověřit:</p>

<pre>
#include &lt;stdio.h&gt;
&nbsp;
typedef unsigned short int v16us __attribute__((vector_size(16)));
&nbsp;
int <strong>main</strong>(void)
{
    printf("scalar: %ld bytes\n", sizeof(unsigned short int));
    printf("vector: %ld bytes\n", sizeof(v16us));
&nbsp;
    return 0;
}
</pre>

<p>Výsledek by měl vypadat následovně:</p>

<pre>
scalar: 2 bytes
vector: 16 bytes
</pre>

<p>Vyzkoušet si můžeme i další vektory o celkové délce 16 bajtů, jejichž prvky
budou různých typů a tudíž i délka vektoru měřená v&nbsp;počtu prvků bude
odlišná:</p>

<pre>
#include &lt;stdio.h&gt;
&nbsp;
typedef unsigned char v16ub __attribute__((vector_size(16)));
typedef unsigned short int v16us __attribute__((vector_size(16)));
typedef unsigned int v16ui __attribute__((vector_size(16)));
typedef unsigned long int v16ul __attribute__((vector_size(16)));
&nbsp;
int <strong>main</strong>(void)
{
    printf("unsigned char:  %ld bytes\n", sizeof(unsigned char));
    printf("unsigned short: %ld bytes\n", sizeof(unsigned short int));
    printf("unsigned int:   %ld bytes\n", sizeof(unsigned int));
    printf("unsigned long:  %ld bytes\n", sizeof(unsigned long int));
&nbsp;
    printf("vector unsigned char:  %ld bytes\n", sizeof(v16ub));
    printf("vector unsigned short: %ld bytes\n", sizeof(v16us));
    printf("vector unsigned int:   %ld bytes\n", sizeof(v16ui));
    printf("vector unsigned long:  %ld bytes\n", sizeof(v16ul));
&nbsp;
    return 0;
}
</pre>

<p>Výsledek:</p>

<pre>
unsigned char:  1 bytes
unsigned short: 2 bytes
unsigned int:   4 bytes
unsigned long:  8 bytes
vector unsigned char:  16 bytes
vector unsigned short: 16 bytes
vector unsigned int:   16 bytes
vector unsigned long:  16 bytes
</pre>

<p>Totéž platí i pro vektory s&nbsp;prvky se znaménkem:</p>

<pre>
#include &lt;stdio.h&gt;
&nbsp;
typedef signed char v16ub __attribute__((vector_size(16)));
typedef signed short int v16us __attribute__((vector_size(16)));
typedef signed int v16ui __attribute__((vector_size(16)));
typedef signed long int v16ul __attribute__((vector_size(16)));
&nbsp;
int <strong>main</strong>(void)
{
    printf("signed char:  %ld bytes\n", sizeof(signed char));
    printf("signed short: %ld bytes\n", sizeof(signed short int));
    printf("signed int:   %ld bytes\n", sizeof(signed int));
    printf("signed long:  %ld bytes\n", sizeof(signed long int));
&nbsp;
    printf("vector signed char:  %ld bytes\n", sizeof(v16ub));
    printf("vector signed short: %ld bytes\n", sizeof(v16us));
    printf("vector signed int:   %ld bytes\n", sizeof(v16ui));
    printf("vector signed long:  %ld bytes\n", sizeof(v16ul));
&nbsp;
    return 0;
}
</pre>

<p>Výsledky, které by se měly zobrazit na standardním výstupu po překladu a
spuštění tohoto demonstračního příkladu:</p>

<pre>
signed char:  1 bytes
signed short: 2 bytes
signed int:   4 bytes
signed long:  8 bytes
vector signed char:  16 bytes
vector signed short: 16 bytes
vector signed int:   16 bytes
vector signed long:  16 bytes
</pre>



<p><a name="k04"></a></p>
<h2 id="k04">4. Vektory obsahující prvky typu <i>half float</i> na platformě AArch64</h2>

<p>V&nbsp;dnešním článku nás nejvíce zajímá způsob práce s&nbsp;vektory,
jejichž prvky jsou typu <i>half float</i>. Pokusme se tedy nyní definovat typ,
který takový vektor popíše. Připomeňme si, že definice typu vektoru vypadá
následovně:</p>

<pre>
typedef <u>typ_prvku</u> <strong>jméno_typu</strong> __attribute__((vector_size(<u>velikost_vektoru_v_bajtech</u>)));
</pre>

<p>Konkrétně vektor s&nbsp;osmi prvky typu <i>half float</i> (pro
<strong>sizeof half_float==2</strong>) tedy bude vypadat následovně:</p>

<pre>
typedef <u>_Float16</u> <strong>float16x8</strong> __attribute__((vector_size(<u>16</u>)));
</pre>

<p>Opět si pochopitelně můžeme ověřit velikost prvku (musí být dva bajty) i
velikost celého vektoru:</p>

<pre>
#include &lt;stdio.h&gt;
&nbsp; 
typedef _Float16 float16x8 __attribute__((vector_size(16)));
&nbsp;
int <strong>main</strong>(void)
{
    printf("scalar: %ld bytes\n", sizeof(_Float16));
    printf("vector: %ld bytes\n", sizeof(float16x8));
&nbsp; 
    return 0;
}
</pre>

<p>Po překladu a spuštění tohoto příkladu by se mělo vypsat:</p>

<pre>
scalar: 2 bytes
vector: 16 bytes
</pre>

<p><div class="rs-tip-major">Poznámka: zdrojový kód tohoto demonstračního
příkladu naleznete na adrese <a
href="https://github.com/tisnik/8bit-fame/blob/master/fp/fp16_vector_size.c">https://github.com/tisnik/8bit-fame/blob/master/fp/fp16_vector_size.c</a>.</div></p>



<p><a name="k05"></a></p>
<h2 id="k05">5. Korektní a nekorektní velikost vektorů</h2>

<p><a href="#k04">V&nbsp;předchozím demonstračním příkladu</a> byla velikost
vektoru nastavena na šestnáct bajtů. Jedná se o korektní velikost, a to ze dvou
důvodů:</p>

<ol>

<li>Tato velikost je celočíselným násobkem velikosti jednoho prvku
(v&nbsp;bajtech). Konkrétně v&nbsp;tomto případě se jedná o celočíselný násobek
dvojky, protože <i>half float</i> v&nbsp;paměti obsadí přesně dva bajty.</li>

<li>Současně je tato velikost celočíselnou mocninou dvojky, což je obecný
požadavek GCC, který nezávisí na typu prvků vektoru.</li>

</ol>

<p>Ostatně můžeme si sami otestovat, jak bude překladač reagovat na pokus o
definici vektoru s&nbsp;nekorektní velikostí. Nejprve se pokusíme o definici
vektoru, jehož velikost není celočíselným násobkem
<strong>sizeof(_Float16</strong>):</p>

<pre>
#include &lt;stdio.h&gt;
&nbsp;
typedef _Float16 float16x8 __attribute__((vector_size(<u>17</u>)));
&nbsp;
int <strong>main</strong>(void)
{
    printf("scalar: %ld bytes\n", sizeof(_Float16));
    printf("vector: %ld bytes\n", sizeof(float16x8));
&nbsp; 
    return 0;
}
</pre>

<p>Překladač tento problém snadno odhalí:</p>

<pre>
$ <strong>gcc -Wall fp16_vector_incorrect_size_1.c</strong>
&nbsp;
fp16_vector_incorrect_size_1.c:3:1: error: vector size not an integral multiple of component size
    3 | typedef _Float16 float16x8 __attribute__((vector_size(17)));
      | ^~~~~~~
</pre>

<p><div class="rs-tip-major">Poznámka: zdrojový kód tohoto demonstračního
příkladu naleznete na adrese <a
href="https://github.com/tisnik/8bit-fame/blob/master/fp/fp16_vector_incorrect_size_1.c">https://github.com/tisnik/8bit-fame/blob/master/fp/fp16_vector_incorrect_size_1.c</a>.</div></p>

<p>Ve druhém demonstračním příkladu sice bude velikost vektoru dělitelná
dvojkou, ale nebude celočíselnou mocninou dvojky:</p>

<pre>
#include &lt;stdio.h&gt;
&nbsp; 
typedef _Float16 float16x8 __attribute__((vector_size(<u>20</u>)));
&nbsp;
int <strong>main</strong>(void)
{
    printf("scalar: %ld bytes\n", sizeof(_Float16));
    printf("vector: %ld bytes\n", sizeof(float16x8));
&nbsp; 
    return 0;
}
</pre>

<p>I tento problém bude překladačem céčka odhalen:</p>

<pre>
$ <strong>gcc -Wall fp16_vector_incorrect_size_2.c</strong>
&nbsp;
fp16_vector_incorrect_size_2.c:3:1: error: number of vector components 10 not a power of two
    3 | typedef _Float16 float16x8 __attribute__((vector_size(20)));
      | ^~~~~~~
</pre>

<p><div class="rs-tip-major">Poznámka: toto druhé omezení je poměrně
nepříjemné, protože například neumožňuje snadnou práci s&nbsp;některými
embedded modely.</div></p>

<p><div class="rs-tip-major">Poznámka: zdrojový kód tohoto demonstračního
příkladu naleznete na adrese <a
href="https://github.com/tisnik/8bit-fame/blob/master/fp/fp16_vector_incorrect_size_2.c">https://github.com/tisnik/8bit-fame/blob/master/fp/fp16_vector_incorrect_size_2.c</a>.</div></p>



<p><a name="k06"></a></p>
<h2 id="k06">6. Základní aritmetické operace s&nbsp;vektory</h2>

<p>Překladač GCC umožňuje aplikaci základních aritmetických (a popř.&nbsp;i
dalších) operátorů nad dvojicí vektorů stejné délky a stejného typu. Tyto
operace budou provedeny prvek po prvku, tj.&nbsp;operace se provede pro
odpovídající si prvky vektorů s&nbsp;indexem 0, dále s&nbsp;odpovídajícími si
prvky vektorů s&nbsp;indexem 1 atd. Důležitý je fakt, že pokud instrukční sada
umožňuje provedení těchto operací &bdquo;paralelně&ldquo;, tedy s&nbsp;využitím
vhodné vektorové instrukce či instrukcí, budou tyto instrukce skutečně
použity.</p>

<p>Pro vektory s&nbsp;prvky typu <i>half float</i> jsme omezeni na čtyři
základní aritmetické operace a taktéž na porovnání vektorů prvek po prvku.
Vyzkoušejme si aritmetickou operaci součtu:</p>

<pre>
typedef _Float16 <strong>float16x8</strong> __attribute__((vector_size(16)));
&nbsp;
float16x8 <strong>add</strong>(float16x8 x, float16x8 y)
{
    return x+y;
}
</pre>

<p>Na platformě AArch64 s&nbsp;instrukcemi pro <i>fp16</i> bude tato funkce
(která interně provádí osm součtů) přeložena do pouhých dvou instrukcí:</p>

<pre>
<strong>add</strong>:
        fadd    v0.8h, v0.8h, v1.8h
        ret
</pre>

<p><div class="rs-tip-major">Poznámka: zdrojový kód tohoto demonstračního
příkladu naleznete na adrese <a
href="https://github.com/tisnik/8bit-fame/blob/master/fp/fp16_vector_add_1.c">https://github.com/tisnik/8bit-fame/blob/master/fp/fp16_vector_add_1.c</a>.
Výsledek překladu do strojového kódu je uložen na adrese <a
href="https://github.com/tisnik/8bit-fame/blob/master/fp/fp16_vector_add_1.asm">https://github.com/tisnik/8bit-fame/blob/master/fp/fp16_vector_add_1.asm</a>.</div></p>

<p><div class="rs-tip-major">Poznámka: překladač provádí kontrolu, zda mají
vektory stejnou délku a taktéž stejný typ prvků. To znamená, že další dva
příklady se nepřeloží:</div></p>

<pre>
typedef _Float16 <strong>float16x8</strong> __attribute__((vector_size(16)));
typedef float <strong>float32x8</strong> __attribute__((vector_size(32)));
&nbsp;
float32x8 <strong>add</strong>(float16x8 x, float32x8 y)
{
    return x+y;
}
</pre>

<p>Chyba nalezená překladačem:</p>

<pre>
fp16_vector_add_3.c:6:13: error: invalid operands to binary + (have ‘float16x8’ {aka ‘__vector(8) _Float16’} and ‘float32x8’ {aka ‘__vector(8) float’})
    6 |     return x+y;
      |             ^
</pre>

<p>Vektory odlišné délky:</p>

<pre>
typedef _Float16 <strong>float16x8</strong> __attribute__((vector_size(16)));
typedef _Float16 <strong>float16x16</strong> __attribute__((vector_size(32)));
&nbsp;
float32x8 <strong>add</strong>(float16x8 x, float16x16 y)
{
    return x+y;
}
</pre>

<p>Chyba nalezená překladačem:</p>

<pre>
fp16_vector_add_4.c:6:13: error: invalid operands to binary + (have ‘float16x8’ {aka ‘__vector(8) _Float16’} and ‘float16x16’ {aka ‘__vector(16) _Float16’})
    6 |     return x+y;
      |             ^
</pre>

<p><div class="rs-tip-major">Poznámka: zdrojový kód těchto příkladů naleznete
na adresách <a
href="https://github.com/tisnik/8bit-fame/blob/master/fp/fp16_vector_add_3.c">https://github.com/tisnik/8bit-fame/blob/master/fp/fp16_vector_add_3.c</a>
a <a
href="https://github.com/tisnik/8bit-fame/blob/master/fp/fp16_vector_add_4.c">https://github.com/tisnik/8bit-fame/blob/master/fp/fp16_vector_add_4.c</a>.</div></p>



<p><a name="k07"></a></p>
<h2 id="k07">7. Způsob překladu aritmetických operací s&nbsp;prvky vektorů do strojového kódu A64</h2>

<p>S&nbsp;celými vektory, které mají stejnou délku a současně i shodný typ
prvků <i>half float</i>, je pochopitelně možné provádět i ostatní tři základní
aritmetické operace, což je ukázáno na dalším demonstračním příkladu.
Připomeňme si, že tyto operace jsou prováděny s&nbsp;odpovídajícími si typy
prvků, tj.&nbsp;například operátor <strong>*</strong> neznačí ani skalární ani
vektorový součin, ale skutečně pouze součiny prvků s&nbsp;indexem 0, další
součin prvků s&nbsp;indexem 1 atd.:</p>

<pre>
typedef _Float16 <strong>float16x8</strong> __attribute__((vector_size(16)));
&nbsp;
float16x8 <strong>add</strong>(float16x8 x, float16x8 y)
{
    return x+y;
}
&nbsp;
float16x8 <strong>sub</strong>(float16x8 x, float16x8 y)
{
    return x-y;
}
&nbsp;
float16x8 <strong>mul</strong>(float16x8 x, float16x8 y)
{
    return x*y;
}
&nbsp;
float16x8 <strong>div</strong>(float16x8 x, float16x8 y)
{
    return x/y;
}
</pre>

<p>Způsob realizace překladu tohoto příkladu do strojového kódu ukazuje, že se
skutečně provádí &bdquo;vektorizované&ldquo; aritmetické operace,
tj.&nbsp;vlastně osm aritmetických operací paralelně:</p>

<pre>
<strong>add</strong>:
        fadd    v0.8h, v0.8h, v1.8h
        ret
&nbsp;
<strong>sub</strong>:
        fsub    v0.8h, v0.8h, v1.8h
        ret
&nbsp;
<strong>mul</strong>:
        fmul    v0.8h, v0.8h, v1.8h
        ret
&nbsp;
<strong>div</strong>:
        fdiv    v0.8h, v0.8h, v1.8h
        ret
</pre>

<p><div class="rs-tip-major">Poznámka: připomeňme si, že existuje větší nabídka
operací, které lze provádět s&nbsp;vektory obsahujícími celočíselné prvky.
Příkladem mohou být bitové posuny atd.</div></p>

<p><div class="rs-tip-major">Poznámka: zdrojový kód tohoto demonstračního
příkladu naleznete na adrese <a
href="https://github.com/tisnik/8bit-fame/blob/master/fp/fp16_vector_arith_1.c">https://github.com/tisnik/8bit-fame/blob/master/fp/fp16_vector_arith_1.c</a>.
Překlad do strojového kódu viz <a
href="https://github.com/tisnik/8bit-fame/blob/master/fp/fp16_vector_arith_1.asm">https://github.com/tisnik/8bit-fame/blob/master/fp/fp16_vector_arith_1.asm</a>.</div></p>



<p><a name="k08"></a></p>
<h2 id="k08">8. Zpracování delších vektorů</h2>

<p>Prozatím jsme si otestovali, jakým způsobem se provádí zvolené aritmetické
operace s&nbsp;vektory o velikosti 16 bajtů (128 bitů). Vzhledem k&nbsp;tomu,
že prvek typu <i>half float</i> obsazuje v&nbsp;paměti 2 bajty (16 bitů), mohou
tyto vektory obsahovat osm prvků. Šířka 128 bitů není pochopitelně zvolena
náhodně, protože v&nbsp;instrukční sadě NEON na AArch64 mají
&bdquo;vektorové&ldquo; registry právě tuto bitovou šířku a tudíž byly (alespoň
prozatím) aritmetické operace realizovány jedinou strojovou instrukcí.</p>

<p>Nic nám ovšem nebrání v&nbsp;použití delších vektorů. Musíme pouze dodržet
zásadu, že délka (měřená v&nbsp;bajtech) musí být celočíselnou mocninou dvojky.
Snadno tedy provedeme součet vektorů s&nbsp;šestnácti prvky typu <i>half
float</i>:</p>

<pre>
typedef _Float16 <strong>float16x16</strong> __attribute__((vector_size(32)));
&nbsp;
float16x16 <strong>add</strong>(float16x16 x, float16x16 y)
{
    return x+y;
}
</pre>

<p>Z&nbsp;výsledků překladu tohoto příkladu do strojového kódu je patrné, že se
provedl součet pro první polovinu vektorů následovaný součtem pro polovinu
druhou. Ovšem současně se změnil i způsob předání parametrů &ndash; nyní se
parametry předávají referencí a totéž platí pro návratovou hodnotu (to je
zajímavé, protože lze teoreticky pro předávání parametrů použít registry
<strong>v0</strong> až <strong>v7</strong>):</p>

<pre>
<strong>add</strong>:
        ldp     q29, q31, [x0]
        ldp     q28, q30, [x1]
        fadd    v28.8h, v29.8h, v28.8h
        fadd    v30.8h, v31.8h, v30.8h
        stp     q28, q30, [x8]
        ret
</pre>

<p><div class="rs-tip-major">Poznámka: zdrojový kód tohoto demonstračního
příkladu naleznete na adrese <a
href="https://github.com/tisnik/8bit-fame/blob/master/fp/fp16_vector_add_2.c">https://github.com/tisnik/8bit-fame/blob/master/fp/fp16_vector_add_2.c</a>.</div></p>



<p><a name="k09"></a></p>
<h2 id="k09">9. Základní aritmetické operace s&nbsp;vektory obsahujícími 64 prvků</h2>

<p>Pokusme se o další zvětšení vektorů, se kterými se budou provádět
aritmetické operace. Konkrétně vektory rozšíříme na 128 bajtů, což pro typy
<i>half float</i> znamená, že vektory budou obsahovat 64 prvků. A právě
s&nbsp;těmito vektory provedeme všechny čtyři základní aritmetické operace:</p>

<pre>
typedef _Float16 <strong>float16x64</strong> __attribute__((vector_size(128)));
&nbsp;
float16x64 <strong>add</strong>(float16x64 x, float16x64 y)
{
    return x+y;
}
&nbsp;
float16x64 <strong>sub</strong>(float16x64 x, float16x64 y)
{
    return x-y;
}
&nbsp;
float16x64 <strong>mul</strong>(float16x64 x, float16x64 y)
{
    return x*y;
}
&nbsp;
float16x64 <strong>div</strong>(float16x64 x, float16x64 y)
{
    return x/y;
}
</pre>

<p>Z&nbsp;výsledků překladu do strojového kódu je patrné, že se vždy načte
dvojice částí registrů (osm prvků) a provede se s&nbsp;nimi požadovaná operace.
Následně se výsledek uloží. Tato trojice instrukcí se opakuje celkem 8&times; a
částečně se překrývá s&nbsp;ostatními sedmi opakováními stejné sekvence
instrukcí:</p>

<pre>
<strong>add</strong>:
        ldp     q17, q19, [x0]
        ldp     q16, q18, [x1]
        ldp     q21, q23, [x0, 32]
        ldp     q20, q22, [x1, 32]
        ldp     q25, q27, [x0, 64]
        ldp     q24, q26, [x1, 64]
        ldp     q29, q31, [x0, 96]
        ldp     q28, q30, [x1, 96]
        fadd    v16.8h, v17.8h, v16.8h
        fadd    v18.8h, v19.8h, v18.8h
        fadd    v20.8h, v21.8h, v20.8h
        fadd    v22.8h, v23.8h, v22.8h
        fadd    v24.8h, v25.8h, v24.8h
        fadd    v26.8h, v27.8h, v26.8h
        stp     q16, q18, [x8]
        fadd    v28.8h, v29.8h, v28.8h
        stp     q20, q22, [x8, 32]
        fadd    v30.8h, v31.8h, v30.8h
        stp     q24, q26, [x8, 64]
        stp     q28, q30, [x8, 96]
        ret
&nbsp;
<strong>sub</strong>:
        ldp     q17, q19, [x0]
        ldp     q16, q18, [x1]
        ldp     q21, q23, [x0, 32]
        ldp     q20, q22, [x1, 32]
        ldp     q25, q27, [x0, 64]
        ldp     q24, q26, [x1, 64]
        ldp     q29, q31, [x0, 96]
        ldp     q28, q30, [x1, 96]
        fsub    v16.8h, v17.8h, v16.8h
        fsub    v18.8h, v19.8h, v18.8h
        fsub    v20.8h, v21.8h, v20.8h
        fsub    v22.8h, v23.8h, v22.8h
        fsub    v24.8h, v25.8h, v24.8h
        fsub    v26.8h, v27.8h, v26.8h
        stp     q16, q18, [x8]
        fsub    v28.8h, v29.8h, v28.8h
        stp     q20, q22, [x8, 32]
        fsub    v30.8h, v31.8h, v30.8h
        stp     q24, q26, [x8, 64]
        stp     q28, q30, [x8, 96]
        ret
&nbsp;
<strong>mul</strong>:
        ldp     q17, q19, [x0]
        ldp     q16, q18, [x1]
        ldp     q21, q23, [x0, 32]
        ldp     q20, q22, [x1, 32]
        ldp     q25, q27, [x0, 64]
        ldp     q24, q26, [x1, 64]
        ldp     q29, q31, [x0, 96]
        ldp     q28, q30, [x1, 96]
        fmul    v16.8h, v17.8h, v16.8h
        fmul    v18.8h, v19.8h, v18.8h
        fmul    v20.8h, v21.8h, v20.8h
        fmul    v22.8h, v23.8h, v22.8h
        fmul    v24.8h, v25.8h, v24.8h
        fmul    v26.8h, v27.8h, v26.8h
        stp     q16, q18, [x8]
        fmul    v28.8h, v29.8h, v28.8h
        stp     q20, q22, [x8, 32]
        fmul    v30.8h, v31.8h, v30.8h
        stp     q24, q26, [x8, 64]
        stp     q28, q30, [x8, 96]
        ret
&nbsp;
<strong>div</strong>:
        ldp     q17, q19, [x0]
        ldp     q16, q18, [x1]
        ldp     q21, q23, [x0, 32]
        ldp     q20, q22, [x1, 32]
        ldp     q25, q27, [x0, 64]
        ldp     q24, q26, [x1, 64]
        ldp     q29, q31, [x0, 96]
        ldp     q28, q30, [x1, 96]
        fdiv    v16.8h, v17.8h, v16.8h
        fdiv    v18.8h, v19.8h, v18.8h
        fdiv    v20.8h, v21.8h, v20.8h
        fdiv    v22.8h, v23.8h, v22.8h
        fdiv    v24.8h, v25.8h, v24.8h
        fdiv    v26.8h, v27.8h, v26.8h
        stp     q16, q18, [x8]
        fdiv    v28.8h, v29.8h, v28.8h
        fdiv    v30.8h, v31.8h, v30.8h
        stp     q20, q22, [x8, 32]
        stp     q24, q26, [x8, 64]
        stp     q28, q30, [x8, 96]
        ret
</pre>

<p><div class="rs-tip-major">Poznámka: zdrojový kód tohoto demonstračního
příkladu naleznete na adrese <a
href="https://github.com/tisnik/8bit-fame/blob/master/fp/fp16_vector_arith_2.c">https://github.com/tisnik/8bit-fame/blob/master/fp/fp16_vector_arith_2.c</a>.</div></p>



<p><a name="k10"></a></p>
<h2 id="k10">10. Stejná operace prováděná se všemi prvky vektorů</h2>

<p>V&nbsp;dalším ukázkovém příkladu je realizována funkce, která ke všem prvkům
pole o známé délce přičítá konstantu předanou formou argumentu. Konstanta je
přitom stejného datového typu, jaký mají všechny prvky vektoru. Celý příklad je
naprogramován naivním způsobem, bez jakékoli snahy o optimalizace na úrovni
céčkovského zdrojového kódu &ndash; pouze zde důsledně využíváme typ
&bdquo;vektor&ldquo;:</p>

<pre>
typedef _Float16 <strong>float16x8</strong> __attribute__((vector_size(16)));
&nbsp;
float16x8 <strong>add_delta</strong>(float16x8 x, _Float16 delta)
{
    return x+delta;
}
</pre>

<p>Z&nbsp;výsledku překladu je patrné, že opět došlo
k&nbsp;&bdquo;vektorizaci&ldquo; operace součtu. Ovšem nejprve bylo nutné
hodnotu parametru <strong>delta</strong> taktéž převést na vektor instrukcí
<strong>dup</strong>:</p>

<pre>
<strong>add_delta</strong>:
        dup     v1.8h, v1.h[0]
        fadd    v0.8h, v1.8h, v0.8h
        ret
</pre>

<p><div class="rs-tip-major">Poznámka: zdrojový kód tohoto demonstračního
příkladu naleznete na adrese <a
href="https://github.com/tisnik/8bit-fame/blob/master/fp/fp16_add_delta_fp16.c">https://github.com/tisnik/8bit-fame/blob/master/fp/fp16_vector_delta.c</a>.
Výsledek překladu do strojového kódu A64 je na adrese <a
href="https://github.com/tisnik/8bit-fame/blob/master/fp/fp16_add_delta_fp16.asm">https://github.com/tisnik/8bit-fame/blob/master/fp/fp16_vector_delta.asm</a>.</div></p>



<p><a name="k11"></a></p>
<h2 id="k11">11. Konverze všech prvků vektoru: z&nbsp;typu <i>half float</i> na typ <i>float</i></h2>

<p>Některé operace nad celými vektory je nutné provádět s&nbsp;využitím
vestavěných funkcí nabízených překladačem GCC. Jedna z&nbsp;těchto funkcí se
jmenuje <strong>__builtin_convertvector</strong>. Jedná se o
&bdquo;generickou&ldquo; funkci, která dokáže převést prvky vektoru
z&nbsp;původního datového typu na nový datový typ, který je do funkce předán
jako druhý parametr (prvním parametrem je převáděný vektor). Už jen
z&nbsp;tohoto popisu je zřejmé, že se nemůže jednat o běžnou céčkovskou funkci,
ale o specializovaný intrinsic.</p>

<p>Podívejme se nejprve na převod všech prvků vektoru typu <i>half float</i> do
nového vektoru se stejným počtem prvků. Nyní ovšem budou mít nové prvky typ
<i>float</i>, což mj.&nbsp;znamená, že cílový vektor v&nbsp;operační paměti
zabere dvojnásobek místa (8&times;4 bajty namísto původních 8&times;2
bajtů):</p>

<pre>
typedef _Float16 <strong>float16x8</strong> __attribute__((vector_size(16)));
typedef float <strong>float32x8</strong> __attribute__((vector_size(32)));
&nbsp;
float32x8 <strong>to_float32x8</strong>(float16x8 x)
{
    return <u>__builtin_convertvector</u>(x, float32x8);
}
</pre>

<p>Překlad do strojového kódu je v&nbsp;tomto případě založen na instrukcích
<strong>fcvtl</strong> a <strong>fcvtl2</strong>. Samotná konverze je tedy
rozdělena na dvě instrukce, protože výsledkem musí být vždy maximálně 128bitová
hodnota:</p>

<pre>
<strong>to_float32x8</strong>:
        fcvtl   v31.4s, v0.4h
        fcvtl2  v0.4s, v0.8h
        stp     q31, q0, [x8]
        ret
</pre>

<p><div class="rs-tip-major">Poznámka: zdrojový kód tohoto demonstračního
příkladu naleznete na adrese <a
href="https://github.com/tisnik/8bit-fame/blob/master/fp/fp16_add_convert_1_fp16.c">https://github.com/tisnik/8bit-fame/blob/master/fp/fp16_vector_convert_1.c</a>.
Výsledek překladu do strojového kódu A64 je na adrese <a
href="https://github.com/tisnik/8bit-fame/blob/master/fp/fp16_add_convert_1_fp16.asm">https://github.com/tisnik/8bit-fame/blob/master/fp/fp16_vector_convert_1.asm</a>.</div></p>



<p><a name="k12"></a></p>
<h2 id="k12">12. Konverze všech prvků vektoru: z&nbsp;typu <i>float</i> na typ <i>half float</i></h2>

<p>Pochopitelně je podporována i konverze opačným směrem, tj.&nbsp;lze
zkonvertovat vektor s&nbsp;prvky typu <i>float</i> na vektor s&nbsp;prvky typu
<i>half float</i>. Céčkový kód se až na rozdílné typy parametrů neliší od kódu
předchozího:</p>

<pre>
typedef _Float16 <strong>float16x8</strong> __attribute__((vector_size(16)));
typedef float <strong>float32x8</strong> __attribute__((vector_size(32)));
&nbsp;
float16x8 <strong>from_float32x8</strong>(float32x8 x)
{
    return <u>__builtin_convertvector</u>(x, float16x8);
}
</pre>

<p>Ovšem ve strojovém kódu je situace v&nbsp;porovnání s&nbsp;předchozím
příkladem mnohem složitější. Nyní se prvky konvertují postupně a nikoli celý
vektor jako celek. Navíc se výsledný vektor postupně skládá
(resp.&nbsp;přesněji řečeno se do něj vkládají prvky) instrukcí
<strong>INS</strong> s&nbsp;následným prokladem prvků instrukcí
<strong>ZIP</strong>. Nejedná se ani o hezký ani o závratně rychlý kód:</p>

<pre>
<strong>from_float32x8</strong>:
        ldp     s28, s29, [x0, 8]
        ldp     s31, s30, [x0]
        fcvt    h24, s28
        fcvt    h25, s29
        ldp     s26, s27, [x0, 16]
        fcvt    h31, s31
        fcvt    h30, s30
        ldp     s28, s29, [x0, 24]
        fcvt    h26, s26
        fcvt    h27, s27
        ins     v31.h[1], v24.h[0]
        ins     v30.h[1], v25.h[0]
        fcvt    h28, s28
        fcvt    h29, s29
        ins     v31.h[2], v26.h[0]
        ins     v30.h[2], v27.h[0]
        ins     v31.h[3], v28.h[0]
        ins     v30.h[3], v29.h[0]
        zip1    v0.8h, v31.8h, v30.8h
        ret
</pre>

<p><div class="rs-tip-major">Poznámka: zdrojový kód tohoto demonstračního
příkladu naleznete na adrese <a
href="https://github.com/tisnik/8bit-fame/blob/master/fp/fp16_add_convert_2_fp16.c">https://github.com/tisnik/8bit-fame/blob/master/fp/fp16_vector_convert_2.c</a>.
Výsledek překladu do strojového kódu A64 je na adrese <a
href="https://github.com/tisnik/8bit-fame/blob/master/fp/fp16_add_convert_2_fp16.asm">https://github.com/tisnik/8bit-fame/blob/master/fp/fp16_vector_convert_2.asm</a>.</div></p>



<p><a name="k13"></a></p>
<h2 id="k13">13. Operace <i>Multiply–accumulate</i> (<i>MAC</i>) s&nbsp;vektory</h2>

<p>Při zpracování signálů ale i v&nbsp;dalších oblastech se poměrně často
setkáme s&nbsp;operací typu <i>multiply-accumulate</i>, tj.&nbsp;výpočtem
<strong>a=a+b&times;c</strong>. Tato operace je na platformě AArch64 široce
podporována, a to jak pro výpočty se skaláry, tak i pro výpočty s&nbsp;vektory.
Ostatně si to můžeme vyzkoušet sami. Pokusíme se o výše uvedený výpočet
<strong>a=a+b&times;c</strong>, ovšem s&nbsp;tím, že hodnoty
<strong>a</strong>, <strong>b</strong> a <strong>c</strong> nejsou skaláry, ale
vektory s&nbsp;osmi prvky typu <i>half float</i>:</p>

<pre>
typedef _Float16 <strong>float16x8</strong> __attribute__((vector_size(16)));
&nbsp;
float16x8 <strong>mac</strong>(float16x8 a, float16x8 b, float16x8 c)
{
    return <u>a+b*c</u>;
}
</pre>

<p>Překladač jazyka C (GCC) v&nbsp;tomto případě výpočet rozezná a namísto osmi
součinů a osmi součtů zavolá jedinou instrukci <strong>FMLA</strong>:</p>

<pre>
<strong>mac</strong>:
        fmla    v0.8h, v1.8h, v2.8h
        ret
</pre>

<p><div class="rs-tip-major">Poznámka: zdrojový kód tohoto demonstračního
příkladu naleznete na adrese <a
href="https://github.com/tisnik/8bit-fame/blob/master/fp/fp16_add_mac_fp16.c">https://github.com/tisnik/8bit-fame/blob/master/fp/fp16_vector_mac.c</a>.
Výsledek překladu do strojového kódu A64 je na adrese <a
href="https://github.com/tisnik/8bit-fame/blob/master/fp/fp16_add_mac_fp16.asm">https://github.com/tisnik/8bit-fame/blob/master/fp/fp16_vector_mac.asm</a>.</div></p>



<p><a name="k14"></a></p>
<h2 id="k14">14. Součet všech prvků vektoru</h2>

<p>Prozatím jsme si vyzkoušeli dva typy operací:</p>

<ol>
<li>Operace prováděné s&nbsp;odpovídajícími si prvky dvou vektorů</li>
<li>Operace prováděné se všemi prvky a skalární hodnotou, která je k&nbsp;prvkům přičítána, odečítána atd.</li>
</ol>

<pre>
typedef _Float16 <strong>float16x8</strong> __attribute__((vector_size(16)));
&nbsp;
_Float16 <strong>sum1</strong>(float16x8 x)
{
    _Float16 sum = 0.0;
    int i;
    for (i=0; i&lt;8; i++) {
        sum += x[i];
    }
    return sum;
}
</pre>

<p></p>

<pre>
<strong>sum1</strong>:
        movi    v31.4s, 0
        ext     v1.16b, v0.16b, v31.16b, #8
        fadd    v0.8h, v1.8h, v0.8h
        ext     v30.16b, v0.16b, v31.16b, #4
        fadd    v0.8h, v30.8h, v0.8h
        ext     v31.16b, v0.16b, v31.16b, #2
        fadd    v0.8h, v31.8h, v0.8h
        ret

</pre>



<p><a name="k15"></a></p>
<h2 id="k15">15. Alternativní realizace součtu všech prvků vektoru</h2>

<pre>
typedef _Float16 <strong>float16x8</strong> __attribute__((vector_size(16)));
&nbsp;
_Float16 <strong>sum2</strong>(float16x8 x)
{
    return x[0] + x[1] + x[2] + x[3] + x[4] + x[5] + x[6] + x[7];
}
</pre>

<p></p>

<pre>
<strong>sum2</strong>:
        dup     h31, v0.h[1]
        dup     h25, v0.h[2]
        dup     h26, v0.h[3]
        dup     h27, v0.h[4]
        fadd    h31, h31, h0
        dup     h28, v0.h[5]
        dup     h29, v0.h[6]
        dup     h30, v0.h[7]
        fadd    h31, h31, h25
        fadd    h31, h31, h26
        fadd    h31, h31, h27
        fadd    h31, h31, h28
        fadd    h31, h31, h29
        fadd    h0, h31, h30
        ret
</pre>



<p><a name="k16"></a></p>
<h2 id="k16">16. </h2>

<pre>
typedef _Float16 float16x8 __attribute__((vector_size(16)));

_Float16 dot_product(float16x8 a, float16x8 b) {
    int i;
    _Float16 result = 0.0;
    for (i=0; i&lt;sizeof(float16x8)/sizeof(_Float16); i++) {
        result += a[i] * b[i];
    }
    return result;
}
</pre>

<pre>
<strong>dot_product</strong>:
        movi    v31.4s, 0
        fmul    v0.8h, v0.8h, v1.8h
        ext     v2.16b, v0.16b, v31.16b, #8
        fadd    v0.8h, v2.8h, v0.8h
        ext     v1.16b, v0.16b, v31.16b, #4
        fadd    v0.8h, v1.8h, v0.8h
        ext     v31.16b, v0.16b, v31.16b, #2
        fadd    v0.8h, v31.8h, v0.8h
        ret
</pre>

<p><div class="rs-tip-major">Poznámka: zdrojový kód tohoto demonstračního
příkladu naleznete na adrese <a
href="https://github.com/tisnik/8bit-fame/blob/master/fp/fp16_add_mac_fp16.c">https://github.com/tisnik/8bit-fame/blob/master/fp/fp16_dot_product.c</a>.
Výsledek překladu do strojového kódu A64 je na adrese <a
href="https://github.com/tisnik/8bit-fame/blob/master/fp/fp16_add_mac_fp16.asm">https://github.com/tisnik/8bit-fame/blob/master/fp/fp16_dot_product.asm</a>.</div></p>



<p><a name="k17"></a></p>
<h2 id="k17">17. Porovnání prvků vektorů s&nbsp;konstantou</h2>

<pre>
typedef _Float16 float16x8 __attribute__((vector_size(16)));
typedef short int int16x8 __attribute__((vector_size(16)));

int16x8 zeros(float16x8 x)
{
    return x==0;
}
</pre>

<pre>
zeros:
        dup     h30, v0.h[1]
        dup     h24, v0.h[3]
        dup     h25, v0.h[2]
        dup     h26, v0.h[5]
        dup     h27, v0.h[4]
        fcvt    s29, h0
        fcvt    s30, h30
        fcvt    s24, h24
        fcvt    s25, h25
        dup     h28, v0.h[7]
        dup     h31, v0.h[6]
        fcvt    s26, h26
        fcmeq   s0, s29, 0
        fcmeq   s24, s24, 0
        fcmeq   s25, s25, 0
        fcvt    s27, h27
        fcmeq   s30, s30, 0
        fcvt    s28, h28
        fcvt    s31, h31
        fcmeq   s26, s26, 0
        ins     v0.h[1], v25.h[0]
        fcmeq   s27, s27, 0
        ins     v30.h[1], v24.h[0]
        fcmeq   s28, s28, 0
        fcmeq   s31, s31, 0
        ins     v30.h[2], v26.h[0]
        ins     v0.h[2], v27.h[0]
        ins     v30.h[3], v28.h[0]
        ins     v0.h[3], v31.h[0]
        zip1    v0.8h, v0.8h, v30.8h
        ret
</pre>



<p><a name="k18"></a></p>
<h2 id="k18">18. Příloha: všechny instrukce z&nbsp;instrukční sady A64 použité v&nbsp;článku</h2>

<p></p>

<table>
<tr><th></th><th></th></tr>
<tr><td></td><td></td></tr>
</table>



<p><a name="k19"></a></p>
<h2 id="k19">19. Repositář s&nbsp;demonstračními příklady</h2>

<p>Demonstrační příklady napsané v&nbsp;jazyku C, které jsou určené pro překlad
s&nbsp;využitím překladače <strong>gcc</strong> pro platformu AArch64, byly
uloženy do Git repositáře, který je dostupný na adrese <a
href="https://github.com/tisnik/8bit-fame">https://github.com/tisnik/8bit-fame</a>.
Jednotlivé demonstrační příklady si můžete v&nbsp;případě potřeby stáhnout i
jednotlivě bez nutnosti klonovat celý (dnes již poměrně rozsáhlý)
repositář:</p>

<table>
<tr><th> #</th><th>Příklad</th><th>Stručný popis</th><th>Adresa</th></tr>
<tr><td> 1</td><td>fp16_add.c</td><td>operace součtu dvou hodnot typu <i>half float</i></td><td><a href="https://github.com/tisnik/8bit-fame/blob/master/fp/fp16_add.c">https://github.com/tisnik/8bit-fame/blob/master/fp/fp16_add.c</a></td></tr>
<tr><td> 2</td><td>fp16_add.asm</td><td>překlad operace součtu dvou hodnot typu <i>half float</i></td><td><a href="https://github.com/tisnik/8bit-fame/blob/master/fp/fp16_add.asm">https://github.com/tisnik/8bit-fame/blob/master/fp/fp16_add.asm</a></td></tr>
<tr><td> 3</td><td>fp16_add_fp16.asm</td><td>překlad využívající instrukce pro přímé operace s&nbsp;hodnotami typu <i>half float</i></td><td><a href="https://github.com/tisnik/8bit-fame/blob/master/fp/fp16_add_fp16.asm">https://github.com/tisnik/8bit-fame/blob/master/fp/fp16_add_fp16.asm</a></td></tr>
<tr><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td></tr>
<tr><td> 4</td><td>fp16_arith.c</td><td>všechny čtyři základní aritmetické operace nad typy <i>half float</i></td><td><a href="https://github.com/tisnik/8bit-fame/blob/master/fp/fp16_arith.c">https://github.com/tisnik/8bit-fame/blob/master/fp/fp16_arith.c</a></td></tr>
<tr><td> 5</td><td>fp16_arith.asm</td><td>překlad všech čtyř základních aritmetických operací</td><td><a href="https://github.com/tisnik/8bit-fame/blob/master/fp/fp16_arith.asm">https://github.com/tisnik/8bit-fame/blob/master/fp/fp16_arith.asm</a></td></tr>
<tr><td> 6</td><td>fp16_arith_fp16.asm</td><td>překlad všech čtyř základních aritmetických operací s&nbsp;přímými instrukcemi pro <i>half float</i></td><td><a href="https://github.com/tisnik/8bit-fame/blob/master/fp/fp16_arith_fp16.asm">https://github.com/tisnik/8bit-fame/blob/master/fp/fp16_arith_fp16.asm</a></td></tr>
<tr><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td></tr>
<tr><td> 7</td><td>fp16_comparison.c</td><td>realizace všech šesti operací pro porovnání dvou hodnot typu <i>half float</i></td><td><a href="https://github.com/tisnik/8bit-fame/blob/master/fp/fp16_comparison.c">https://github.com/tisnik/8bit-fame/blob/master/fp/fp16_comparison.c</a></td></tr>
<tr><td> 8</td><td>fp16_comparison.asm</td><td>překlad operací pro porovnání dvou hodnot typu <i>half float</i></td><td><a href="https://github.com/tisnik/8bit-fame/blob/master/fp/fp16_comparison.asm">https://github.com/tisnik/8bit-fame/blob/master/fp/fp16_comparison.asm</a></td></tr>
<tr><td> 9</td><td>fp16_comparison_fp16.asm</td><td>překlad operací pro porovnání dvou hodnot typu <i>half float</i> s&nbsp;přímými instrukcemi</td><td><a href="https://github.com/tisnik/8bit-fame/blob/master/fp/fp16_comparison_fp16.asm">https://github.com/tisnik/8bit-fame/blob/master/fp/fp16_comparison_fp16.asm</a></td></tr>
<tr><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td></tr>
<tr><td>10</td><td>fp16_add_delta.c</td><td>přičtení konstanty ke všem prvkům pole</td><td><a href="https://github.com/tisnik/8bit-fame/blob/master/fp/fp16_add_delta.c">https://github.com/tisnik/8bit-fame/blob/master/fp/fp16_add_delta.c</a></td></tr>
<tr><td>11</td><td>fp16_add_delta.asm</td><td>překlad do strojového kódu bez přímého povolení manipulace s&nbsp;typy <i>half float</i></td><td><a href="https://github.com/tisnik/8bit-fame/blob/master/fp/fp16_add_delta.asm">https://github.com/tisnik/8bit-fame/blob/master/fp/fp16_add_delta.asm</a></td></tr>
<tr><td>12</td><td>fp16_add_delta_fp16.asm</td><td>překlad do strojového kódu s&nbsp;přímým povolení manipulace s&nbsp;typy <i>half float</i></td><td><a href="https://github.com/tisnik/8bit-fame/blob/master/fp/fp16_add_delta_fp16.asm">https://github.com/tisnik/8bit-fame/blob/master/fp/fp16_add_delta_fp16.asm</a></td></tr>
<tr><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td></tr>
<tr><td>13</td><td>fp16_add_arrays_32.c</td><td>součet odpovídajících si prvků polí typu <i>half float</i> se známou délkou</td><td><a href="https://github.com/tisnik/8bit-fame/blob/master/fp/fp16_add_arrays_32.c">https://github.com/tisnik/8bit-fame/blob/master/fp/fp16_add_arrays_32.c</a></td></tr>
<tr><td>14</td><td>fp16_add_arrays_32.asm</td><td>překlad do strojového kódu bez přímého povolení manipulace s&nbsp;typy <i>half float</i></td><td><a href="https://github.com/tisnik/8bit-fame/blob/master/fp/fp16_add_arrays_32.asm">https://github.com/tisnik/8bit-fame/blob/master/fp/fp16_add_arrays_32.asm</a></td></tr>
<tr><td>15</td><td>fp16_add_arrays_32_fp16.asm</td><td>překlad do strojového kódu s&nbsp;přímým povolení manipulace s&nbsp;typy <i>half float</i></td><td><a href="https://github.com/tisnik/8bit-fame/blob/master/fp/fp16_add_arrays_32_fp16.asm">https://github.com/tisnik/8bit-fame/blob/master/fp/fp16_add_arrays_32_fp16.asm</a></td></tr>
<tr><td>16</td><td>fp16_add_arrays_32_restrict.c</td><td>součet odpovídajících si prvků polí typu <i>half float</i>, zajištění, že se pole nepřekrývají</td><td><a href="https://github.com/tisnik/8bit-fame/blob/master/fp/fp16_add_arrays_32_restrict.c">https://github.com/tisnik/8bit-fame/blob/master/fp/fp16_add_arrays_32_restrict.c</a></td></tr>
<tr><td>17</td><td>fp16_add_arrays_32_restrict.asm</td><td>překlad do strojového kódu s&nbsp;přímým povolení manipulace s&nbsp;typy <i>half float</i></td><td><a href="https://github.com/tisnik/8bit-fame/blob/master/fp/fp16_add_arrays_32_restrict.asm">https://github.com/tisnik/8bit-fame/blob/master/fp/fp16_add_arrays_32_restrict.asm</a></td></tr>
<tr><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td></tr>
<tr><td>18</td><td>fp16_add_arrays_16.c</td><td>součet odpovídajících si prvků polí typu <i>half float</i> se známou délkou</td><td><a href="https://github.com/tisnik/8bit-fame/blob/master/fp/fp16_add_arrays_16.c">https://github.com/tisnik/8bit-fame/blob/master/fp/fp16_add_arrays_16.c</a></td></tr>
<tr><td>19</td><td>fp16_add_arrays_16.asm</td><td>překlad do strojového kódu bez přímého povolení manipulace s&nbsp;typy <i>half float</i></td><td><a href="https://github.com/tisnik/8bit-fame/blob/master/fp/fp16_add_arrays_16.asm">https://github.com/tisnik/8bit-fame/blob/master/fp/fp16_add_arrays_16.asm</a></td></tr>
<tr><td>20</td><td>fp16_add_arrays_16_fp16.asm</td><td>překlad do strojového kódu s&nbsp;přímým povolení manipulace s&nbsp;typy <i>half float</i></td><td><a href="https://github.com/tisnik/8bit-fame/blob/master/fp/fp16_add_arrays_16_fp16.asm">https://github.com/tisnik/8bit-fame/blob/master/fp/fp16_add_arrays_16_fp16.asm</a></td></tr>
<tr><td>21</td><td>fp16_add_arrays_16_restrict.c</td><td>součet odpovídajících si prvků polí typu <i>half float</i>, zajištění, že se pole nepřekrývají</td><td><a href="https://github.com/tisnik/8bit-fame/blob/master/fp/fp16_add_arrays_16_restrict.c">https://github.com/tisnik/8bit-fame/blob/master/fp/fp16_add_arrays_16_restrict.c</a></td></tr>
<tr><td>22</td><td>fp16_add_arrays_16_restrict.asm</td><td></td><td><a href="https://github.com/tisnik/8bit-fame/blob/master/fp/fp16_add_arrays_16_restrict.asm">https://github.com/tisnik/8bit-fame/blob/master/fp/fp16_add_arrays_16_restrict.asm</a></td></tr>
<tr><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td></tr>
<tr><td>23</td><td>fp16_vector_size.c</td><td>získání a tisk velikosti prvku typu <i>half float</i> i vektoru s&nbsp;těmito prvky</td><td><a href="https://github.com/tisnik/8bit-fame/blob/master/fp/fp16_vector_size.c">https://github.com/tisnik/8bit-fame/blob/master/fp/fp16_vector_size.c</a></td></tr>
<tr><td>24</td><td>fp16_vector_incorrect_size_1.c</td><td>pokus o konstrukci vektoru s&nbsp;neplatnou velikostí</td><td><a href="https://github.com/tisnik/8bit-fame/blob/master/fp/fp16_vector_incorrect_size_1.c">https://github.com/tisnik/8bit-fame/blob/master/fp/fp16_vector_incorrect_size_1.c</a></td></tr>
<tr><td>25</td><td>fp16_vector_incorrect_size_2.c</td><td>pokus o konstrukci vektoru s&nbsp;neplatnou velikostí</td><td><a href="https://github.com/tisnik/8bit-fame/blob/master/fp/fp16_vector_incorrect_size_2.c">https://github.com/tisnik/8bit-fame/blob/master/fp/fp16_vector_incorrect_size_2.c</a></td></tr>
<tr><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td></tr>
<tr><td>26</td><td>fp16_vector_add_1.c</td><td>součet odpovídajících si prvků vektorů typu <i>half float</i>, vektory mají délku osmi prvků</td><td><a href="https://github.com/tisnik/8bit-fame/blob/master/fp/fp16_vector_add_1.c">https://github.com/tisnik/8bit-fame/blob/master/fp/fp16_vector_add_1.c</a></td></tr>
<tr><td>27</td><td>fp16_vector_add_1.asm</td><td>překlad do strojového kódu s&nbsp;přímým povolením práce s&nbsp;typy <i>half float</i></td><td><a href="https://github.com/tisnik/8bit-fame/blob/master/fp/fp16_vector_add_1.asm">https://github.com/tisnik/8bit-fame/blob/master/fp/fp16_vector_add_1.asm</a></td></tr>
<tr><td>28</td><td>fp16_vector_add_2.c</td><td>součet odpovídajících si prvků vektorů typu <i>half float</i>, vektory mají délku šestnácti prvků</td><td><a href="https://github.com/tisnik/8bit-fame/blob/master/fp/fp16_vector_add_2.c">https://github.com/tisnik/8bit-fame/blob/master/fp/fp16_vector_add_2.c</a></td></tr>
<tr><td>29</td><td>fp16_vector_add_2.asm</td><td>překlad do strojového kódu s&nbsp;přímým povolením práce s&nbsp;typy <i>half float</i></td><td><a href="https://github.com/tisnik/8bit-fame/blob/master/fp/fp16_vector_add_2.asm">https://github.com/tisnik/8bit-fame/blob/master/fp/fp16_vector_add_2.asm</a></td></tr>
<tr><td>30</td><td>fp16_vector_add_3.c</td><td>pokus o součet vektorů, které mají stejný počet prvků, ovšem odlišného typu</td><td><a href="https://github.com/tisnik/8bit-fame/blob/master/fp/fp16_vector_add_3.c">https://github.com/tisnik/8bit-fame/blob/master/fp/fp16_vector_add_3.c</a></td></tr>
<tr><td>31</td><td>fp16_vector_add_4.c</td><td>pokus o součet vektorů, které mají prvky stejného typu, ovšem odlišnou délku</td><td><a href="https://github.com/tisnik/8bit-fame/blob/master/fp/fp16_vector_add_4.c">https://github.com/tisnik/8bit-fame/blob/master/fp/fp16_vector_add_4.c</a></td></tr>
<tr><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td></tr>
<tr><td>32</td><td>fp16_vector_arith_1.c</td><td>čtyři základní aritmetické operace s&nbsp;vektory typu <i>half float</i> s&nbsp;osmi prvky</td><td><a href="https://github.com/tisnik/8bit-fame/blob/master/fp/fp16_vector_arith_1.c">https://github.com/tisnik/8bit-fame/blob/master/fp/fp16_vector_arith_1.c</a></td></tr>
<tr><td>33</td><td>fp16_vector_arith_1.asm</td><td>překlad do strojového kódu s&nbsp;přímým povolením práce s&nbsp;typy <i>half float</i></td><td><a href="https://github.com/tisnik/8bit-fame/blob/master/fp/fp16_vector_arith_1.asm">https://github.com/tisnik/8bit-fame/blob/master/fp/fp16_vector_arith_1.asm</a></td></tr>
<tr><td>34</td><td>fp16_vector_arith_2.c</td><td>čtyři základní aritmetické operace s&nbsp;vektory typu <i>half float</i> se šestnácti prvky</td><td><a href="https://github.com/tisnik/8bit-fame/blob/master/fp/fp16_vector_arith_2.c">https://github.com/tisnik/8bit-fame/blob/master/fp/fp16_vector_arith_2.c</a></td></tr>
<tr><td>35</td><td>fp16_vector_arith_2.asm</td><td>překlad do strojového kódu s&nbsp;přímým povolením práce s&nbsp;typy <i>half float</i></td><td><a href="https://github.com/tisnik/8bit-fame/blob/master/fp/fp16_vector_arith_2.asm">https://github.com/tisnik/8bit-fame/blob/master/fp/fp16_vector_arith_2.asm</a></td></tr>
<tr><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td></tr>
<tr><td>36</td><td>fp16_vector_convert_1.c</td><td>konverze všech prvků vektorů mezi typy <i>float</i> a <i>half float</i></td><td><a href="https://github.com/tisnik/8bit-fame/blob/master/fp/fp16_vector_convert_1.c">https://github.com/tisnik/8bit-fame/blob/master/fp/fp16_vector_convert_1.c</a></td></tr>
<tr><td>37</td><td>fp16_vector_convert_1.asm</td><td>překlad do strojového kódu s&nbsp;přímým povolením práce s&nbsp;typy <i>half float</i></td><td><a href="https://github.com/tisnik/8bit-fame/blob/master/fp/fp16_vector_convert_1.asm">https://github.com/tisnik/8bit-fame/blob/master/fp/fp16_vector_convert_1.asm</a></td></tr>
<tr><td>38</td><td>fp16_vector_convert_2.c</td><td>konverze všech prvků vektorů mezi typy <i>float</i> a <i>half float</i></td><td><a href="https://github.com/tisnik/8bit-fame/blob/master/fp/fp16_vector_convert_2.c">https://github.com/tisnik/8bit-fame/blob/master/fp/fp16_vector_convert_2.c</a></td></tr>
<tr><td>39</td><td>fp16_vector_convert_2.asm</td><td>překlad do strojového kódu s&nbsp;přímým povolením práce s&nbsp;typy <i>half float</i></td><td><a href="https://github.com/tisnik/8bit-fame/blob/master/fp/fp16_vector_convert_2.asm">https://github.com/tisnik/8bit-fame/blob/master/fp/fp16_vector_convert_2.asm</a></td></tr>
<tr><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td></tr>
<tr><td>39</td><td>fp16_vector_delta.c</td><td>přičtení konstanty ke všem prvkům vektoru</td><td><a href="https://github.com/tisnik/8bit-fame/blob/master/fp/fp16_vector_delta.c">https://github.com/tisnik/8bit-fame/blob/master/fp/fp16_vector_delta.c</a></td></tr>
<tr><td>40</td><td>fp16_vector_delta.asm</td><td>překlad do strojového kódu s&nbsp;přímým povolením práce s&nbsp;typy <i>half float</i></td><td><a href="https://github.com/tisnik/8bit-fame/blob/master/fp/fp16_vector_delta.asm">https://github.com/tisnik/8bit-fame/blob/master/fp/fp16_vector_delta.asm</a></td></tr>
<tr><td>41</td><td>fp16_vector_mac.c</td><td>operace typu Multiply-accumulate s&nbsp;vektory</td><td><a href="https://github.com/tisnik/8bit-fame/blob/master/fp/fp16_vector_mac.c">https://github.com/tisnik/8bit-fame/blob/master/fp/fp16_vector_mac.c</a></td></tr>
<tr><td>42</td><td>fp16_vector_mac.asm</td><td>překlad do strojového kódu s&nbsp;přímým povolením práce s&nbsp;typy <i>half float</i></td><td><a href="https://github.com/tisnik/8bit-fame/blob/master/fp/fp16_vector_mac.asm">https://github.com/tisnik/8bit-fame/blob/master/fp/fp16_vector_mac.asm</a></td></tr>
<tr><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td></tr>
<tr><td>43</td><td>fp16_vector_sum.c</td><td>součet všech prvků vektoru</td><td><a href="https://github.com/tisnik/8bit-fame/blob/master/fp/fp16_vector_sum.c">https://github.com/tisnik/8bit-fame/blob/master/fp/fp16_vector_sum.c</a></td></tr>
<tr><td>44</td><td>fp16_vector_sum.asm</td><td>překlad do strojového kódu s&nbsp;přímým povolením práce s&nbsp;typy <i>half float</i></td><td><a href="https://github.com/tisnik/8bit-fame/blob/master/fp/fp16_vector_sum.asm">https://github.com/tisnik/8bit-fame/blob/master/fp/fp16_vector_sum.asm</a></td></tr>
<tr><td>45</td><td>fp16_dot_product.c</td><td>skalární součin dvou vektorů</td><td><a href="https://github.com/tisnik/8bit-fame/blob/master/fp/fp16_dot_product.c">https://github.com/tisnik/8bit-fame/blob/master/fp/fp16_dot_product.c</a></td></tr>
<tr><td>46</td><td>fp16_dot_product.asm</td><td>překlad do strojového kódu s&nbsp;přímým povolením práce s&nbsp;typy <i>half float</i></td><td><a href="https://github.com/tisnik/8bit-fame/blob/master/fp/fp16_dot_product.asm">https://github.com/tisnik/8bit-fame/blob/master/fp/fp16_dot_product.asm</a></td></tr>
<tr><td>47</td><td>fp16_vector_zeros.c</td><td>porovnání všech prvků vektoru s&nbsp;nulovou hodnotou</td><td><a href="https://github.com/tisnik/8bit-fame/blob/master/fp/fp16_vector_zeros.c">https://github.com/tisnik/8bit-fame/blob/master/fp/fp16_vector_zeros.c</a></td></tr>
<tr><td>48</td><td>fp16_vector_zeros.asm</td><td>překlad do strojového kódu s&nbsp;přímým povolením práce s&nbsp;typy <i>half float</i></td><td><a href="https://github.com/tisnik/8bit-fame/blob/master/fp/fp16_vector_zeros.asm">https://github.com/tisnik/8bit-fame/blob/master/fp/fp16_vector_zeros.asm</a></td></tr>
</table>



<p><a name="k20"></a></p>
<h2 id="k20">20. Odkazy na Internetu</h2>

<ol>

<li>NEON Technology (stránky ARM)<br />
<a href="https://developer.arm.com/technologies/neon">https://developer.arm.com/technologies/neon</a>
</li>

<li>SIMD Assembly Tutorial: ARM NEON - Xiph.org<br />
<a href="https://people.xiph.org/~tterribe/daala/neon_tutorial.pdf">https://people.xiph.org/~tterribe/daala/neon_tutorial.pdf</a>
</li>

<li>Ne10<br />
<a href="http://projectne10.github.io/Ne10/">http://projectne10.github.io/Ne10/</a>
</li>

<li>NEON and Floating-Point architecture<br />
<a href="http://infocenter.arm.com/help/index.jsp?topic=/com.arm.doc.den0024a/BABIGHEB.html">http://infocenter.arm.com/help/index.jsp?topic=/com.arm.doc.den0024a/BABIGHEB.html</a>
</li>

<li>An Introduction to ARM NEON<br />
<a href="http://peterdn.com/post/an-introduction-to-ARM-NEON.aspx">http://peterdn.com/post/an-introduction-to-ARM-NEON.aspx</a>
</li>

<li>ARM NEON Intrinsics Reference<br />
<a href="http://infocenter.arm.com/help/topic/com.arm.doc.ihi0073a/IHI0073A_arm_neon_intrinsics_ref.pdf">http://infocenter.arm.com/help/topic/com.arm.doc.ihi0073a/IHI0073A_arm_neon_intrinsics_ref.pdf</a>
</li>

<li>Arm Neon Intrinsics vs hand assembly<br />
<a href="https://stackoverflow.com/questions/9828567/arm-neon-intrinsics-vs-hand-assembly">https://stackoverflow.com/questions/9828567/arm-neon-intrinsics-vs-hand-assembly</a>
</li>

<li>ARM NEON Optimization. An Example<br />
<a href="http://hilbert-space.de/?p=22">http://hilbert-space.de/?p=22</a>
</li>

<li>AArch64 NEON instruction format<br />
<a href="https://developer.arm.com/docs/den0024/latest/7-aarch64-floating-point-and-neon/73-aarch64-neon-instruction-format">https://developer.arm.com/docs/den0024/latest/7-aarch64-floating-point-and-neon/73-aarch64-neon-instruction-format</a>
</li>

<li>Vektorové procesory aneb další pokus o zvýšení výpočetního výkonu počítačů<br />
<a href="http://www.root.cz/clanky/vektorove-procesory-aneb-dalsi-pokus-o-zvyseni-vypocetniho-vykonu-pocitacu/">http://www.root.cz/clanky/vektorove-procesory-aneb-dalsi-pokus-o-zvyseni-vypocetniho-vykonu-pocitacu/</a>
</li>

<li>SIMD instrukce využívané v moderních mikroprocesorech řady x86<br />
<a href="http://www.root.cz/clanky/simd-instrukce-vyuzivane-v-modernich-mikroprocesorech-rady-x86/">http://www.root.cz/clanky/simd-instrukce-vyuzivane-v-modernich-mikroprocesorech-rady-x86/</a>
</li>

<li>SIMD instrukce v moderních mikroprocesorech řady x86 (2.část: SSE)<br />
<a href="http://www.root.cz/clanky/simd-instrukce-v-modernich-mikroprocesorech-rady-x86-2-cast-sse/">http://www.root.cz/clanky/simd-instrukce-v-modernich-mikroprocesorech-rady-x86-2-cast-sse/</a>
</li>

<li>SIMD instrukce v moderních mikroprocesorech řady x86 (3.část: SSE2)<br />
<a href="http://www.root.cz/clanky/simd-instrukce-v-modernich-mikroprocesorech-rady-x86-3-cast-sse2/">http://www.root.cz/clanky/simd-instrukce-v-modernich-mikroprocesorech-rady-x86-3-cast-sse2/</a>
</li>

<li>Instrukce typu SIMD na mikroprocesorech RISC<br />
<a href="http://www.root.cz/clanky/instrukce-typu-simd-na-mikroprocesorech-risc/">http://www.root.cz/clanky/instrukce-typu-simd-na-mikroprocesorech-risc/</a>
</li>

<li>Instrukce typu SIMD na mikroprocesorech RISC (2. část)<br />
<a href="http://www.root.cz/clanky/instrukce-typu-simd-na-mikroprocesorech-risc-2-cast/">http://www.root.cz/clanky/instrukce-typu-simd-na-mikroprocesorech-risc-2-cast/</a>
</li>

<li>Instrukce typu SIMD na mikroprocesorech RISC (3.část - MIPS-3D a VIS)<br />
<a href="http://www.root.cz/clanky/instrukce-typu-simd-na-mikroprocesorech-risc-3-cast-mips-3d-a-vis/">http://www.root.cz/clanky/instrukce-typu-simd-na-mikroprocesorech-risc-3-cast-mips-3d-a-vis/</a>
</li>

<li>Trasování a ladění nativních aplikací v&nbsp;Linuxu<br />
<a href="https://www.root.cz/clanky/trasovani-a-ladeni-nativnich-aplikaci-v-linuxu/">https://www.root.cz/clanky/trasovani-a-ladeni-nativnich-aplikaci-v-linuxu/</a>
</li>

<li>Trasování a ladění nativních aplikací v&nbsp;Linuxu: použití GDB a jeho nadstaveb<br />
<a href="https://www.root.cz/clanky/trasovani-a-ladeni-nativnich-aplikaci-v-linuxu-pouziti-gdb-a-jeho-nadstaveb/">https://www.root.cz/clanky/trasovani-a-ladeni-nativnich-aplikaci-v-linuxu-pouziti-gdb-a-jeho-nadstaveb/</a>
</li>

<li>Debuggery a jejich nadstavby v Linuxu (3): Nemiver<br />
<a href="http://mojefedora.cz/debuggery-a-jejich-nadstavby-v-linuxu-3-nemiver/">http://mojefedora.cz/debuggery-a-jejich-nadstavby-v-linuxu-3-nemiver/</a>
</li>

<li>Debuggery a jejich nadstavby v Linuxu (4): KDbg<br />
<a href="http://mojefedora.cz/debuggery-a-jejich-nadstavby-v-linuxu-4-kdbg/">http://mojefedora.cz/debuggery-a-jejich-nadstavby-v-linuxu-4-kdbg/</a>
</li>

<li>Debuggery a jejich nadstavby v Linuxu (5): ladění aplikací v&nbsp;editorech Emacs a Vim<br />
<a href="http://mojefedora.cz/debuggery-a-jejich-nadstavby-v-linuxu-5-ladeni-aplikaci-v-editorech-emacs-a-vim/">http://mojefedora.cz/debuggery-a-jejich-nadstavby-v-linuxu-5-ladeni-aplikaci-v-editorech-emacs-a-vim/</a>
</li>

<li>Tracing (software)<br />
<a href="https://en.wikipedia.org/wiki/Tracing_%28software%29">https://en.wikipedia.org/wiki/Tracing_%28software%29</a>
</li>

<li>cgdb: the curses debugger<br />
<a href="https://cgdb.github.io/">https://cgdb.github.io/</a>
</li>

<li>cgdb: dokumentace<br />
<a href="https://cgdb.github.io/docs/cgdb-split.html">https://cgdb.github.io/docs/cgdb-split.html</a>
</li>

<li>strace(1) - Linux man page<br />
<a href="http://linux.die.net/man/1/strace">http://linux.die.net/man/1/strace</a>
</li>

<li>strace (stránka projektu na SourceForge)<br />
<a href="https://sourceforge.net/projects/strace/">https://sourceforge.net/projects/strace/</a>
</li>

<li>strace (Wikipedia)<br />
<a href="https://en.wikipedia.org/wiki/Strace">https://en.wikipedia.org/wiki/Strace</a>
</li>

<li>GDB - Dokumentace<br />
<a href="http://sourceware.org/gdb/current/onlinedocs/gdb/">http://sourceware.org/gdb/current/onlinedocs/gdb/</a>
</li>

<li>GDB - Supported Languages<br />
<a href="http://sourceware.org/gdb/current/onlinedocs/gdb/Supported-Languages.html#Supported-Languages">http://sourceware.org/gdb/current/onlinedocs/gdb/Supported-Languages.html#Supported-Languages</a>
</li>

<li>GNU Debugger (Wikipedia)<br />
<a href="https://en.wikipedia.org/wiki/GNU_Debugger">https://en.wikipedia.org/wiki/GNU_Debugger</a>
</li>

<li>The LLDB Debugger<br />
<a href="http://lldb.llvm.org/">http://lldb.llvm.org/</a>
</li>

<li>Debugger (Wikipedia)<br />
<a href="https://en.wikipedia.org/wiki/Debugger">https://en.wikipedia.org/wiki/Debugger</a>
</li>

<li>Comparison of ARMv8-A cores<br />
<a href="https://en.wikipedia.org/wiki/Comparison_of_ARMv8-A_cores">https://en.wikipedia.org/wiki/Comparison_of_ARMv8-A_cores</a>
</li>

<li>A64 General Instructions<br />
<a href="http://www.keil.com/support/man/docs/armclang_asm/armclang_asm_pge1427898258836.htm">http://www.keil.com/support/man/docs/armclang_asm/armclang_asm_pge1427898258836.htm</a>
</li>

<li>ARMv8 (AArch64) Instruction Encoding<br />
<a href="http://kitoslab-eng.blogspot.cz/2012/10/armv8-aarch64-instruction-encoding.html">http://kitoslab-eng.blogspot.cz/2012/10/armv8-aarch64-instruction-encoding.html</a>
</li>

<li>Cortex-A32 Processor<br />
<a href="https://www.arm.com/products/processors/cortex-a/cortex-a32-processor.php">https://www.arm.com/products/processors/cortex-a/cortex-a32-processor.php</a>
</li>

<li>Cortex-A35 Processor<br />
<a href="https://www.arm.com/products/processors/cortex-a/cortex-a35-processor.php">https://www.arm.com/products/processors/cortex-a/cortex-a35-processor.php</a>
</li>

<li>Cortex-A53 Processor<br />
<a href="https://www.arm.com/products/processors/cortex-a/cortex-a53-processor.php">https://www.arm.com/products/processors/cortex-a/cortex-a53-processor.php</a>
</li>

<li>Cortex-A57 Processor<br />
<a href="https://www.arm.com/products/processors/cortex-a/cortex-a57-processor.php">https://www.arm.com/products/processors/cortex-a/cortex-a57-processor.php</a>
</li>

<li>Cortex-A72 Processor<br />
<a href="https://www.arm.com/products/processors/cortex-a/cortex-a72-processor.php">https://www.arm.com/products/processors/cortex-a/cortex-a72-processor.php</a>
</li>

<li>Cortex-A73 Processor<br />
<a href="https://www.arm.com/products/processors/cortex-a/cortex-a73-processor.php">https://www.arm.com/products/processors/cortex-a/cortex-a73-processor.php</a>
</li>

<li>Apple A7 (SoC založen na CPU Cyclone)<br />
<a href="https://en.wikipedia.org/wiki/Apple_A7">https://en.wikipedia.org/wiki/Apple_A7</a>
</li>

<li>System cally pro AArch64 na Linuxu<br />
<a href="https://github.com/torvalds/linux/blob/master/include/uapi/asm-generic/unistd.h">https://github.com/torvalds/linux/blob/master/include/uapi/asm-generic/unistd.h</a>
</li>

<li>Architectures/AArch64 (FedoraProject.org)<br />
<a href="https://fedoraproject.org/wiki/Architectures/AArch64">https://fedoraproject.org/wiki/Architectures/AArch64</a>
</li>

<li>SIG pro AArch64 (CentOS)<br />
<a href="https://wiki.centos.org/SpecialInterestGroup/AltArch/AArch64">https://wiki.centos.org/SpecialInterestGroup/AltArch/AArch64</a>
</li>

<li>The ARMv8 instruction sets<br />
<a href="http://infocenter.arm.com/help/index.jsp?topic=/com.arm.doc.den0024a/ch05s01.html">http://infocenter.arm.com/help/index.jsp?topic=/com.arm.doc.den0024a/ch05s01.html</a>
</li>

<li>A64 Instruction Set<br />
<a href="https://developer.arm.com/products/architecture/instruction-sets/a64-instruction-set">https://developer.arm.com/products/architecture/instruction-sets/a64-instruction-set</a>
</li>

<li>Switching between the instruction sets<br />
<a href="http://infocenter.arm.com/help/index.jsp?topic=/com.arm.doc.den0024a/ch05s01.html">http://infocenter.arm.com/help/index.jsp?topic=/com.arm.doc.den0024a/ch05s01.html</a>
</li>

<li>The A64 instruction set<br />
<a href="http://infocenter.arm.com/help/index.jsp?topic=/com.arm.doc.den0024a/ch05s01.html">http://infocenter.arm.com/help/index.jsp?topic=/com.arm.doc.den0024a/ch05s01.html</a>
</li>

<li>Introduction to ARMv8 64-bit Architecture<br />
<a href="https://quequero.org/2014/04/introduction-to-arm-architecture/">https://quequero.org/2014/04/introduction-to-arm-architecture/</a>
</li>

<li>MCU market turns to 32-bits and ARM<br />
<a href="http://www.eetimes.com/document.asp?doc_id=1280803">http://www.eetimes.com/document.asp?doc_id=1280803</a>
</li>

<li>Cortex-M0 Processor (ARM Holdings)<br />
<a href="http://www.arm.com/products/processors/cortex-m/cortex-m0.php">http://www.arm.com/products/processors/cortex-m/cortex-m0.php</a>
</li>

<li>Cortex-M0+ Processor (ARM Holdings)<br />
<a href="http://www.arm.com/products/processors/cortex-m/cortex-m0plus.php">http://www.arm.com/products/processors/cortex-m/cortex-m0plus.php</a>
</li>

<li>ARM Processors in a Mixed Signal World<br />
<a href="http://www.eeweb.com/blog/arm/arm-processors-in-a-mixed-signal-world">http://www.eeweb.com/blog/arm/arm-processors-in-a-mixed-signal-world</a>
</li>

<li>ARM Architecture (Wikipedia)<br />
<a href="https://en.wikipedia.org/wiki/ARM_architecture">https://en.wikipedia.org/wiki/ARM_architecture</a>
</li>

<li>DSP for Cortex-M<br />
<a href="https://developer.arm.com/technologies/dsp/dsp-for-cortex-m">https://developer.arm.com/technologies/dsp/dsp-for-cortex-m</a>
</li>

<li>Cortex-M processors in DSP applications? Why not?!<br />
<a href="https://community.arm.com/processors/b/blog/posts/cortex-m-processors-in-dsp-applications-why-not">https://community.arm.com/processors/b/blog/posts/cortex-m-processors-in-dsp-applications-why-not</a>
</li>

<li>White Paper - DSP capabilities of Cortex-M4 and Cortex-M7<br />
<a href="https://community.arm.com/processors/b/blog/posts/white-paper-dsp-capabilities-of-cortex-m4-and-cortex-m7">https://community.arm.com/processors/b/blog/posts/white-paper-dsp-capabilities-of-cortex-m4-and-cortex-m7</a>
</li>

<li>Q (number format)<br />
<a href="https://en.wikipedia.org/wiki/Q_%28number_format%29">https://en.wikipedia.org/wiki/Q_%28number_format%29</a>
</li>

<li>TriCore Architecture &amp; Core<br />
<a href="http://www.infineon.com/cms/en/product/microcontroller/32-bit-tricore-tm-microcontroller/tricore-tm-architecture-and-core/channel.html?channel=ff80808112ab681d0112ab6b73d40837">http://www.infineon.com/cms/en/product/microcontroller/32-bit-tricore-tm-microcontroller/tricore-tm-architecture-and-core/channel.html?channel=ff80808112ab681d0112ab6b73d40837</a>
</li>

<li>TriCoreTM V1.6 Instruction Set: 32-bit Unified Processor Core<br />
<a href="http://www.infineon.com/dgdl/tc_v131_instructionset_v138.pdf?fileId=db3a304412b407950112b409b6dd0352">http://www.infineon.com/dgdl/tc_v131_instructionset_v138.pdf?fileId=db3a304412b407950112b409b6dd0352</a>
</li>

<li>TriCore v2.2 C Compiler, Assembler, Linker Reference Manual<br />
<a href="http://tasking.com/support/tricore/tc_reference_guide_v2.2.pdf">http://tasking.com/support/tricore/tc_reference_guide_v2.2.pdf</a>
</li>

<li>Infineon TriCore (Wikipedia)<br />
<a href="https://en.wikipedia.org/wiki/Infineon_TriCore">https://en.wikipedia.org/wiki/Infineon_TriCore</a>
</li>

<li>C166®S V2 Architecture &amp; Core<br />
<a href="http://www.infineon.com/cms/en/product/microcontroller/16-bit-c166-microcontroller/c166-s-v2-architecture-and-core/channel.html?channel=db3a304312bef5660112c3011c7d01ae">http://www.infineon.com/cms/en/product/microcontroller/16-bit-c166-microcontroller/c166-s-v2-architecture-and-core/channel.html?channel=db3a304312bef5660112c3011c7d01ae</a>
</li>

<li>Comparing four 32-bit soft processor cores<br />
<a href="http://www.eetimes.com/author.asp?section_id=14&doc_id=1286116">http://www.eetimes.com/author.asp?section_id=14&doc_id=1286116</a>
</li>

<li>RISC-V Instruction Set<br />
<a href="http://riscv.org/download.html#spec_compressed_isa">http://riscv.org/download.html#spec_compressed_isa</a>
</li>

<li>RISC-V Spike (ISA Simulator)<br />
<a href="http://riscv.org/download.html#isa-sim">http://riscv.org/download.html#isa-sim</a>
</li>

<li>RISC-V (Wikipedia)<br />
<a href="https://en.wikipedia.org/wiki/RISC-V">https://en.wikipedia.org/wiki/RISC-V</a>
</li>

<li>David Patterson (Wikipedia)<br />
<a href="https://en.wikipedia.org/wiki/David_Patterson_(computer_scientist)">https://en.wikipedia.org/wiki/David_Patterson_(computer_scientist)</a>
</li>

<li>OpenRISC (oficiální stránky projektu)<br />
<a href="http://openrisc.io/">http://openrisc.io/</a>
</li>

<li>OpenRISC architecture<br />
<a href="http://openrisc.io/architecture.html">http://openrisc.io/architecture.html</a>
</li>

<li>Emulátor OpenRISC CPU v JavaScriptu<br />
<a href="http://s-macke.github.io/jor1k/demos/main.html">http://s-macke.github.io/jor1k/demos/main.html</a>
</li>

<li>OpenRISC (Wikipedia)<br />
<a href="https://en.wikipedia.org/wiki/OpenRISC">https://en.wikipedia.org/wiki/OpenRISC</a>
</li>

<li>OpenRISC - instrukce<br />
<a href="http://sourceware.org/cgen/gen-doc/openrisc-insn.html">http://sourceware.org/cgen/gen-doc/openrisc-insn.html</a>
</li>

<li>OpenRISC - slajdy z přednášky o projektu<br />
<a href="https://iis.ee.ethz.ch/~gmichi/asocd/lecturenotes/Lecture6.pdf">https://iis.ee.ethz.ch/~gmichi/asocd/lecturenotes/Lecture6.pdf</a>
</li>

<li>Berkeley RISC<br />
<a href="http://en.wikipedia.org/wiki/Berkeley_RISC">http://en.wikipedia.org/wiki/Berkeley_RISC</a>
</li>

<li>Great moments in microprocessor history<br />
<a href="http://www.ibm.com/developerworks/library/pa-microhist.html">http://www.ibm.com/developerworks/library/pa-microhist.html</a>
</li>

<li>Microprogram-Based Processors<br />
<a href="http://research.microsoft.com/en-us/um/people/gbell/Computer_Structures_Principles_and_Examples/csp0167.htm">http://research.microsoft.com/en-us/um/people/gbell/Computer_Structures_Principles_and_Examples/csp0167.htm</a>
</li>

<li>Great Microprocessors of the Past and Present<br />
<a href="http://www.cpushack.com/CPU/cpu1.html">http://www.cpushack.com/CPU/cpu1.html</a>
</li>

<li>A Brief History of Microprogramming<br />
<a href="http://www.cs.clemson.edu/~mark/uprog.html">http://www.cs.clemson.edu/~mark/uprog.html</a>
</li>

<li>What is RISC?<br />
<a href="http://www-cs-faculty.stanford.edu/~eroberts/courses/soco/projects/2000-01/risc/whatis/">http://www-cs-faculty.stanford.edu/~eroberts/courses/soco/projects/2000-01/risc/whatis/</a>
</li>

<li>RISC vs. CISC<br />
<a href="http://www-cs-faculty.stanford.edu/~eroberts/courses/soco/projects/2000-01/risc/risccisc/">http://www-cs-faculty.stanford.edu/~eroberts/courses/soco/projects/2000-01/risc/risccisc/</a>
</li>

<li>RISC and CISC definitions:<br />
<a href="http://www.cpushack.com/CPU/cpuAppendA.html">http://www.cpushack.com/CPU/cpuAppendA.html</a>
</li>

<li>FPGA<br />
<a href="https://cs.wikipedia.org/wiki/Programovateln%C3%A9_hradlov%C3%A9_pole">https://cs.wikipedia.org/wiki/Programovateln%C3%A9_hradlov%C3%A9_pole</a>
</li>

<li>The Evolution of RISC<br />
<a href="http://www.ibm.com/developerworks/library/pa-microhist.html#sidebar1">http://www.ibm.com/developerworks/library/pa-microhist.html#sidebar1</a>
</li>

<li>List of ARM instructions implementing half-precision floating-point arithmetic<br />
<a href="https://stackoverflow.com/questions/76255632/list-of-arm-instructions-implementing-half-precision-floating-point-arithmetic">https://stackoverflow.com/questions/76255632/list-of-arm-instructions-implementing-half-precision-floating-point-arithmetic</a>
</li>

<li>Half-Precision Floating Point (GCC)<br />
<a href="https://gcc.gnu.org/onlinedocs/gcc/Half-Precision.html">https://gcc.gnu.org/onlinedocs/gcc/Half-Precision.html</a>
</li>

<li>Additional Floating Types (GCC)<br />
<a href="https://gcc.gnu.org/onlinedocs/gcc/Floating-Types.html">https://gcc.gnu.org/onlinedocs/gcc/Floating-Types.html</a>
</li>

<li>Advanced SIMD (Neon)<br />
<a href="https://en.wikipedia.org/wiki/ARM_architecture_family#Advanced_SIMD_(NEON)">https://en.wikipedia.org/wiki/ARM_architecture_family#Advanced_SIMD_(NEON)</a>
</li>

<li>GCC: ARM options<br />
<a href="https://gcc.gnu.org/onlinedocs/gcc/ARM-Options.html">https://gcc.gnu.org/onlinedocs/gcc/ARM-Options.html</a>
</li>

<li>Compile ARM Neon intrinsics on macos (M3 chipsets) using clang<br />
<a href="https://stackoverflow.com/questions/79056335/compile-arm-neon-intrinsics-on-macos-m3-chipsets-using-clang">https://stackoverflow.com/questions/79056335/compile-arm-neon-intrinsics-on-macos-m3-chipsets-using-clang</a>
</li>

<li>Intrinsics - Arm Developer<br />
<a href="https://developer.arm.com/architectures/instruction-sets/intrinsics/">https://developer.arm.com/architectures/instruction-sets/intrinsics/</a>
</li>

<li>FCMEQ (register)<br />
<a href="https://www.scs.stanford.edu/~zyedidia/arm64/fcmeq_advsimd_reg.html">https://www.scs.stanford.edu/~zyedidia/arm64/fcmeq_advsimd_reg.html</a>
</li>

<li>FCMGE (register)<br />
<a href="https://www.scs.stanford.edu/~zyedidia/arm64/fcmge_advsimd_reg.html">https://www.scs.stanford.edu/~zyedidia/arm64/fcmge_advsimd_reg.html</a>
</li>

<li>FCMGT (register)<br />
<a href="https://www.scs.stanford.edu/~zyedidia/arm64/fcmgt_advsimd_reg.html">https://www.scs.stanford.edu/~zyedidia/arm64/fcmgt_advsimd_reg.html</a>
</li>

<li>A whirlwind tour of AArch64 vector instructions (NEON)<br />
<a href="https://www.corsix.org/content/whirlwind-tour-aarch64-vector-instructions">https://www.corsix.org/content/whirlwind-tour-aarch64-vector-instructions</a>
</li>

<li>How is arm_neon.h generated or maintained?<br />
<a href="https://stackoverflow.com/questions/71422209/how-is-arm-neon-h-generated-or-maintained">https://stackoverflow.com/questions/71422209/how-is-arm-neon-h-generated-or-maintained</a>
</li>

<li>Arm Neon programming quick reference<br />
<a href="https://community.arm.com/arm-community-blogs/b/operating-systems-blog/posts/arm-neon-programming-quick-reference">https://community.arm.com/arm-community-blogs/b/operating-systems-blog/posts/arm-neon-programming-quick-reference</a>
</li>

<li>SimSIMD<br />
<a href="https://github.com/ashvardanian/simsimd">https://github.com/ashvardanian/simsimd</a>
</li>

<li>SIMD-dot-products-ARM-NEON-RISC-V<br />
<a href="https://github.com/crissmath/SIMD-dot-products-ARM-NEON-RISC-V">https://github.com/crissmath/SIMD-dot-products-ARM-NEON-RISC-V</a>
</li>

<li>Procedure Call Standard for the Arm® 64-bit Architecture (AArch64)<br />
<a href="https://github.com/ARM-software/abi-aa/blob/main/aapcs64/aapcs64.rst#simd-and-floating-point-registers">https://github.com/ARM-software/abi-aa/blob/main/aapcs64/aapcs64.rst#simd-and-floating-point-registers</a>
</li>

</ol>



<p></p><p></p>
<p><small>Autor: <a href="https://github.com/tisnik/">Pavel Tišnovský</a> &nbsp; 2025</small></p>
</body>
</html>

