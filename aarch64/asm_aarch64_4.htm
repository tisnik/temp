<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
        "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html>
<head>
<title></title>
<meta name="Author" content="Pavel Tisnovsky" />
<meta name="Generator" content="vim" />
<meta http-equiv="content-type" content="text/html; charset=utf-8" />
<style type="text/css">
         body {color:#000000; background:#ffffff;}
         h1  {font-family: arial, helvetica, sans-serif; color:#ffffff; background-color:#c00000; text-align:center; padding-left:1em}
         h2  {font-family: arial, helvetica, sans-serif; color:#ffffff; background-color:#0000c0; padding-left:1em; text-align:left}
         h3  {font-family: arial, helvetica, sans-serif; color:#000000; background-color:#c0c0c0; padding-left:1em; text-align:left}
         h4  {font-family: arial, helvetica, sans-serif; color:#000000; background-color:#e0e0e0; padding-left:1em; text-align:left}
         a   {font-family: arial, helvetica, sans-serif;}
         li  {font-family: arial, helvetica, sans-serif; color:#000000; text-align:justify; width:450px;}
         ol  {font-family: arial, helvetica, sans-serif; color:#000000; text-align:justify; width:450px;}
         ul  {font-family: arial, helvetica, sans-serif; color:#000000; text-align:justify; width:450px;}
         p   {font-family: arial, helvetica, sans-serif; color:#000000; text-align:justify;}
         pre {background:#e0e0e0}
</style>
</head>

<body>

<h1></h1>

<h3>Pavel Tišnovský</h3>

<p></p>

<h1>Úvodník</h1>

<p></p>



<h2>Obsah</h2>

<p><a href="#k01">*** 1. </a></p>
<p><a href="#k02">*** 2. Specifické vlastnosti aritmeticko-logické jednotky</a></p>
<p><a href="#k03">*** 3. Hodnoty typu <i>single</i> a <i>double</i></a></p>
<p><a href="#k04">*** 4. Formát plovoucí řádové binární tečky a norma IEEE 754</a></p>
<p><a href="#k05">*** 5. Operace s&nbsp;hodnotami typu <i>single</i> a <i>double</i></a></p>
<p><a href="#k06">*** 6. Základní operace s&nbsp;FP hodnotami &ndash; načtení konstanty do FP registru</a></p>
<p><a href="#k07">*** 7. </a></p>
<p><a href="#k08">*** 8. </a></p>
<p><a href="#k09">*** 9. </a></p>
<p><a href="#k10">*** 10. </a></p>
<p><a href="#k11">*** 11. </a></p>
<p><a href="#k12">*** 12. </a></p>
<p><a href="#k13">*** 13. </a></p>
<p><a href="#k14">*** 14. </a></p>
<p><a href="#k15">*** 15. </a></p>
<p><a href="#k16">*** 16. </a></p>
<p><a href="#k17">*** 17. </a></p>
<p><a href="#k18">*** 18. </a></p>
<p><a href="#k19">*** 19. Repositář s&nbsp;demonstračními příklady</a></p>
<p><a href="#k20">*** 20. Odkazy na Internetu</a></p>



<p><a name="k01"></a></p>
<h2 id="k01">1. </h2>

<p>Nová instrukční sada AArch64 obsahuje instrukce, které je možné rozdělit do několika oblastí podle toho, jaká jednotka tyto instrukce skutečně spouští:</p>

<table>
<tr><th>Skupina</th><th>Další dělení</th></tr>
<tr><td>Load-Store</td><td>Load-Store pro jeden registr</td></tr>
<tr><td>&nbsp;</td><td>Load-Store pro dvojici registrů</td></tr>
<tr><td>&nbsp;</td><td>Prefetch</td></tr>
<tr><td>&nbsp;</td><td>&nbsp;</td></tr>
<tr><td>Skoky</td><td>Nepodmíněné skoky</td></tr>
<tr><td>&nbsp;</td><td>Nepodmíněný skok na adresu v&nbsp;registru</td></tr>
<tr><td>&nbsp;</td><td>Podmíněné skoky</td></tr>
<tr><td>&nbsp;</td><td>&nbsp;</td></tr>
<tr><td>ALU operace</td><td>Základní aritmetické instrukce</td></tr>
<tr><td>&nbsp;</td><td>Násobení a dělení</td></tr>
<tr><td>&nbsp;</td><td>Logické instrukce</td></tr>
<tr><td>&nbsp;</td><td>Znaménkové rozšíření operandu či rozšíření o nuly</td></tr>
<tr><td>&nbsp;</td><td>Bitové operace</td></tr>
<tr><td>&nbsp;</td><td>Extrakce dat</td></tr>
<tr><td>&nbsp;</td><td>Bitové posuny</td></tr>
<tr><td>&nbsp;</td><td>Aritmetické posuny</td></tr>
<tr><td>&nbsp;</td><td>Podmíněné zpracování dat</td></tr>
<tr><td>&nbsp;</td><td>Podmíněné porovnání</td></tr>
<tr><td>&nbsp;</td><td>&nbsp;</td></tr>
<tr><td>FP operace</td><td>Přenos operandů mezi registry</td></tr>
<tr><td>&nbsp;</td><td>Konverze mezi různými formáty</td></tr>
<tr><td>&nbsp;</td><td>Převod na celá čísla (zaokrouhlení)</td></tr>
<tr><td>&nbsp;</td><td>Základní aritmetické operace</td></tr>
<tr><td>&nbsp;</td><td>Výpočet minima a maxima</td></tr>
<tr><td>&nbsp;</td><td>MAC (Multiply Accumulate)</td></tr>
<tr><td>&nbsp;</td><td>Porovnání operandů</td></tr>
<tr><td>&nbsp;</td><td>Podmíněný výběr operandu</td></tr>
<tr><td>&nbsp;</td><td>&nbsp;</td></tr>
<tr><td>SIMD operace</td><td>Aritmetické operace se skaláry</td></tr>
<tr><td>&nbsp;</td><td>Aritmetické operace s&nbsp;vektory</td></tr>
<tr><td>&nbsp;</td><td>Permutace vektorů</td></tr>
<tr><td>&nbsp;</td><td>Konverze dat</td></tr>
<tr><td>&nbsp;</td><td>Instrukce z&nbsp;crypto extension (patří do SIMD)</td></tr>
<tr><td>&nbsp;</td><td>&nbsp;</td></tr>
<tr><td>Systémové instrukce</td><td>Zpracování výjimek</td></tr>
<tr><td>&nbsp;</td><td>Přístup k&nbsp;systémovým registrům</td></tr>
<tr><td>&nbsp;</td><td>Implementace bariér</td></tr>
<tr><td>&nbsp;</td><td>Instrukce pro jádro systému</td></tr>
</table>



<p><a name="k02"></a></p>
<h2 id="k02">2. Specifické vlastnosti aritmeticko-logické jednotky</h2>



<p>Kromě toho, že aritmeticko-logická jednotka byla rozšířena pro zpracování 64bitových operandů u prakticky všech instrukcí, došlo k&nbsp;jejímu doplnění o násobičku a děličku. Násobička může provádět i operace typu <i>MAC</i> (<i>Multiply Accumulate</i>), které typicky najdeme u DSP. U AArchu64 je zde jedna podstatná změna &ndash; namísto akumulátoru se může použít odlišný vstupní a odlišný výstupní registr, což
konkrétně znamená, že DSP operace:</p>

<pre>
acc += op2 &times; op3
</pre>

<p>dokáže AArch64 provést:</p>

<pre>
op1 = op2 &times; op3 + op4
</pre>

<p>Podívejme se nyní, které instrukce provádí násobička a dělička:</p>

<table>
<tr><th>#</th><th>Instrukce</th><th>Stručný popis</th></tr>
<tr><td>1</td><td>MUL</td><td>32bitové či 64bitové násobení</td></tr>
<tr><td>2</td><td>MADD</td><td>výsledek = op2 &times; op3 + op4</td></tr>
<tr><td>3</td><td>MSUB</td><td>výsledek = op4 - op2 &times; op3</td></tr>
<tr><td>4</td><td>MNEG</td><td>výsledek = - op2 &times; op3</td></tr>
<tr><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td></tr>
<tr><td>5</td><td>SMULL</td><td>násobení hodnot se znaménkem (32&times;32 &rarr; 64)</td></tr>
<tr><td>6</td><td>SMADDL</td><td>MADD hodnot se znaménkem pro (32&times;32 &rarr; 64)</td></tr>
<tr><td>7</td><td>SMSUBL</td><td>MSUB hodnot se znaménkem pro (32&times;32 &rarr; 64)</td></tr>
<tr><td>8</td><td>SMNEGL</td><td>MNEG hodnot se znaménkem pro (32&times;32 &rarr; 64)</td></tr>
<tr><td>9</td><td>SMULH</td><td>násobení 64&times;64, z&nbsp;výsledku se vezme jen horních 64 bitů ze 128</td></tr>
<tr><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td></tr>
<tr><td>10</td><td>UMULL</td><td>násobení hodnot bez znaménka (32&times;32 &rarr; 64)</td></tr>
<tr><td>11</td><td>UMADDL</td><td>MADD hodnot bez znaménka pro (32&times;32 &rarr; 64)</td></tr>
<tr><td>12</td><td>UMSUBL</td><td>MSUB hodnot bez znaménka pro (32&times;32 &rarr; 64)</td></tr>
<tr><td>13</td><td>UMNEGL</td><td>MNEG hodnot bez znaménka pro (32&times;32 &rarr; 64)</td></tr>
<tr><td>14</td><td>UMULH</td><td>násobení 64&times;64, z&nbsp;výsledku se vezme jen horních 64 bitů ze 128</td></tr>
<tr><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td></tr>
<tr><td>15</td><td>SDIV</td><td>32bitové či 64bitové dělení hodnot se znaménkem</td></tr>
<tr><td>16</td><td>UDIV</td><td>32bitové či 64bitové dělení hodnot bez znaménka</td></tr>
</table>

<p><div class="rs-tip-major">Poznámka: ve skutečnosti je instrukce <strong>MUL</strong>, tedy &bdquo;běžné násobení&ldquo; aliasem pro instrukci <strong>MADD</strong>, v&nbsp;níž je třetím vstupním operandem registr <strong>WZR</strong> či <strong>XZR</strong>, tedy &bdquo;konstantní nula&ldquo;. Totéž platí pro instrukci <strong>MNEG</strong>, která vznikla z&nbsp;instrukce <strong>MSUB</strong>, u níž je opět posledním vstupním operandem nulový registr.</div></p>

<table>
<tr><th>Operace</th><th>Vstupní operandy</th><th>Výsledek</th></tr>
<tr><td>MUL</td><td>32&times;32 bitů</td><td>32 bitů</td></tr>
<tr><td>MUL</td><td>64&times;64 bitů</td><td>64 bitů</td></tr>
<tr><td>MUL</td><td>32&times;32 bitů</td><td>64 bitů (rozšíření)</td></tr>
<tr><td>MUL</td><td>64&times;64 bitů</td><td>horních 64 bitů (rozšíření)</td></tr>
<tr><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td></tr>
<tr><td>MAC</td><td>32&pm;32&times;32 bitů</td><td>32 bitů</td></tr>
<tr><td>MAC</td><td>64&pm;64&times;64 bitů</td><td>64 bitů</td></tr>
<tr><td>MAC</td><td>64&pm;32&times;32 bitů</td><td>64 bitů (rozšíření)</td></tr>
</table>



<p><a name="k03"></a></p>
<h2 id="k03">3. Hodnoty typu <i>single</i> a <i>double</i></h2>

<p>Uložení racionálních čísel ve formátu plovoucí řádové tečky (FP formát) se od formátu s&nbsp;pevnou řádovou tečkou (v&nbsp;ČR čárkou) odlišuje především v&nbsp;tom, že si každá numerická hodnota sama v&nbsp;sobě nese aktuální polohu řádové tečky. Z&nbsp;tohoto důvodu je kromě bitů, které musí být rezervovány pro uložení významných číslic numerické hodnoty, nutné pro každou numerickou hodnotu rezervovat i další bity, v&nbsp;nichž je určena mocnina o nějakém základu (typicky 2, 8, 10 či 16), kterou musí být významné číslice vynásobeny resp.&nbsp;vyděleny. První část čísla uloženého v&nbsp;FP formátu se nazývá <strong>mantisa</strong>, druhá část <strong>exponent</strong>. Obecný formát uložení a způsob získání původního čísla je následující:</p>

<p><i>x<sub>FP</sub>=b<sup>e</sup>&times;m</i></p>

<p>kde:</p>

<ol>
<li><i>x<sub>FX</sub></i> značí reprezentovanou numerickou hodnotu z&nbsp;podmnožiny reálných čísel</li>
<li><i>b</i> je báze, někdy také nazývaná <i>radix</i></li>
<li><i>e</i> je hodnota exponentu (může být i záporná)</li>
<li><i>m</i> je mantisa, která může být i záporná</li>
</ol>

<p><div class="rs-tip-major">Poznámka: většinou požadujeme i práci se zápornými hodnotami, proto se zavádí další bit <i>s</i> pro uložení znaménka. To mj.&nbsp;znamená, že lze reprezentovat kladnou i zápornou nulu, což lze považovat za výhodu.</div></p>

<p>Konkrétní formát numerických hodnot reprezentovaných v&nbsp;systému plovoucí řádové tečky závisí především na volbě báze (<strong>radixu</strong>) a také na počtu bitů rezervovaných pro uložení mantisy a exponentu. V&nbsp;minulosti existovalo značné množství různých formátů plovoucí řádové tečky (vzpomíná si někdo například na <strong>Turbo Pascal</strong> s&nbsp;jeho šestibajtovým datovým typem <i>real</i>?), v&nbsp;relativně nedávné minulosti se však ustálilo použití formátů specifikovaných v&nbsp;normě IEEE 754. Ovšem, jak uvidíme dále, se ukazuje, že původní formáty definované v&nbsp;IEEE 754 nedostačují všem požadavkům, a to na obou stranách spektra (někdo požaduje vyšší přesnost/rozsah, jiný zase rychlost výpočtů a malé paměťové nároky). Proto došlo k&nbsp;rozšíření této normy o nové formáty a nezávisle na tom i na vývoji formátu <strong>bfloat16</strong>. Nicméně nás dnes budou v&nbsp;souvislosti s&nbsp;procesory AArch64 zajímat především formáty s&nbsp;jednoduchou a dvojitou přesností, neboli <i>single (float)</i> a <i>double</i>.</p>



<p><a name="k04"></a></p>
<h2 id="k04">4. Formát plovoucí řádové binární tečky a norma IEEE 754</h2>

<p>V&nbsp;oblasti FP formátů se dnes nejčastěji setkáme s&nbsp;výše zmíněnou
normou IEEE 754 popř.&nbsp;jejími rozšířenými variantami. Norma IEEE 754
specifikuje nejenom vlastní formát uložení numerických hodnot v&nbsp;systému
plovoucí řádové tečky, ale (a to je celkem neznámá skutečnost) i pravidla
implementace operací s&nbsp;těmito hodnotami, včetně konverzí. Konkrétně je
v&nbsp;této normě popsáno:</p>

<ol>
<li>Základní (<i>basic</i>) a rozšířený (<i>extended</i>) formát uložení numerických hodnot.</li>
<li>Způsob provádění základních matematických operací:
    <ul>
    <li>součet</li>
    <li>rozdíl</li>
    <li>součin</li>
    <li>podíl</li>
    <li>zbytek po dělení</li>
    <li>druhá odmocnina</li>
    <li>porovnání</li>
    </ul></li>
<li>Režimy zaokrouhlování.</li>
<li>Způsob práce s&nbsp;denormalizovanými hodnotami.</li>
<li>Pravidla konverze mezi celočíselnými formáty (<i>integer</i> bez a se znaménkem) a formáty s&nbsp;plovoucí řádovou čárkou.</li>
<li>Způsob konverze mezi různými formáty s&nbsp;plovoucí řádovou čárkou (<i>single</i> &rarr; <i>double</i> atd.).</li>
<li>Způsob konverze základního formátu s&nbsp;plovoucí řádovou čárkou na řetězec číslic (včetně nekonečen a nečíselných hodnot).</li>
<li>Práce s&nbsp;hodnotami NaN (<i>not a number</i>) a výjimkami, které mohou při výpočtech za určitých předpokladů vzniknout.</li>
</ol>

<a href="https://www.root.cz/obrazek/305587/"><img src="https://i.iinfo.cz/images/346/fp-number-chaos-2-1-prev.jpg" class="image-305587" alt="&#160;" width="370" height="134" /></a>
<p><i>Obrázek 2: První čip, který používal formát definovaný v&nbsp;IEEE 754
&ndash; Intel 8087.<br />
Zdroj: Wikipedia, Autor: Dirk Oppelt</i></p>

<p>V&nbsp;normě (přesněji řečeno v&nbsp;její rozšířené variantě IEEE 754-2008
resp.&nbsp;její poslední úpravě IEEE 754-2019) nalezneme mj.&nbsp;i tyto FP
formáty:</p>

<table>
<tr><th>Označení</th><th>Šířka (b)</th><th>Báze</th><th>Exponent (b)</th><th>Mantisa (b)</th></tr>
<tr><td>IEEE 754 half</td><td>16</td><td>2</td><td>5</td><td>10+1</td></tr>
<tr><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td></tr>
<tr><td>IEEE 754 single</td><td>32</td><td>2</td><td>8</td><td>23+1</td></tr>
<tr><td>IEEE 754 double</td><td>64</td><td>2</td><td>11</td><td>52+1</td></tr>
<tr><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td></tr>
<tr><td>IEEE 754 double extended</td><td>80</td><td>2</td><td>15</td><td>64</td></tr>
<tr><td>IEEE 754 quadruple</td><td>128</td><td>2</td><td>15</td><td>112+1</td></tr>
<tr><td>IEEE 754 octuple</td><td>256</td><td>2</td><td>19</td><td>236+1</td></tr>
</table>

<img src="http://i.iinfo.cz/images/21/pc157-1.jpg" alt="foobar" width="450" height="448" />
<p><i>Obrázek 3: Mikroprocesory Pentium i všechny další čipy řady 80x86 již
implicitně obsahují plnohodnotný FPU. Zlé jazyky tvrdí, že u první řady Pentií
byl FPU tak rychlý jen proto, že <a
href="https://en.wikipedia.org/wiki/Pentium_FDIV_bug">výsledky pouze
odhadoval</a> :-)</i></p>

<p>Typ <i>single</i> (nebo <i>float</i> popř.&nbsp;<i>float32</i>) vypadá
takto:</p>

<table>
<tr><th>bit</th><td>31</td><td>30 &nbsp; 29 ... 24 &nbsp; 23</td><td>22 &nbsp; 21 ... 3 &nbsp; 2 &nbsp; 1 &nbsp; 0</td></tr>
<tr><th>význam</th><td>s</td><td>exponent (8 bitů)</td><td>mantisa (23 bitů)</td></tr>
</table>

<p>Exponent je přitom posunutý o hodnotu <strong>bias</strong>, která je
nastavena na 127, protože je použit výše uvedený vztah:</p>

<p><i>bias=2<sup>eb-1</sup>-1</i></p>

<p>a po dosazení <i>eb=8 (bitů)</i> dostaneme:</p>

<p><i>bias=2<sup>8-1</sup>-1=2<sup>7</sup>-1=128-1=</i><strong>127</strong></p>

<p>Vzorec pro vyjádření reálné hodnoty vypadá následovně:</p>

<p><i>X<sub>single</sub>=(-1)<sup>s</sup>&nbsp;&times;&nbsp;2<sup>exp-127</sup>&nbsp;&times;&nbsp;m</i></p>

<p>Rozsah hodnot, které je možné reprezentovat ve formátu jednoduché přesnosti
v&nbsp;normalizovaném tvaru je -3,4&times;10<sup>38</sup> až
3,4&times;10<sup>38</sup>. Nejnižší reprezentovatelná (normalizovaná) hodnota
je rovna 1,17549&times;10<sup>-38</sup>, denormalizovaná pak
1,40129&times;10<sup>-45</sup>. Jak jsme k&nbsp;těmto hodnotám došli? Zkuste se
podívat na následující vztahy:</p>

<table>
<tr><th>hexadecimální hodnota</th><th>výpočet FP</th><th>dekadický výsledek</th><th>normalizováno</th></tr>
<tr><td>0x00000001</td><td>2<sup>-126</sup>&times;2<sup>-23</sup></td><td>1,40129&times;10<sup>-45</sup></td><td>ne</td></tr>
<tr><td>0x00800000</td><td>2<sup>-126</sup></td><td>1,17549&times;10<sup>-38</sup></td><td>ano</td></tr>
<tr><td>0x7F7FFFFF</td><td>(2-2<sup>-23</sup>)&times;2<sup>127</sup></td><td>3,4&times;10<sup>38</sup></td><td>ano</td></tr>
</table>

<p>Formát s&nbsp;dvojitou přesností (<strong>double</strong>), který je
definovaný taktéž normou IEEE 754, se v&nbsp;mnoha ohledech podobá formátu
s&nbsp;jednoduchou přesností (<strong>single</strong>), pouze se zdvojnásobil
celkový počet bitů, ve kterých je hodnota uložena, tj.&nbsp;místo 32 bitů se
používá 64 bitů:</p>

<table>
<tr><th>bit</th><td>63</td><td>62 ... 52</td><td>51 ... 0</td></tr>
<tr><th>význam</th><td>s</td><td>exponent (11 bitů)</td><td>mantisa (52 bitů)</td></tr>
</table>

<p>Exponent je v&nbsp;tomto případě posunutý o hodnotu
<strong>bias=2047</strong> a vzorec pro výpočet reálné hodnoty vypadá
takto:</p>

<p><i>X<sub>double</sub>=(-1)<sup>s</sup>&nbsp;&times;&nbsp;2<sup>exp-2047</sup>&nbsp;&times;&nbsp;m</i></p>

<p>Přičemž hodnotu mantisy je možné pro normalizované hodnoty získat pomocí
vztahu:</p>

<p><i>m=1+m<sub>51</sub><sup>-1</sup>+m<sub>50</sub><sup>-2</sup>+m<sub>49</sub><sup>-3</sup>+...+m<sub>0</sub><sup>-52</sup></i></p>

<p>(<i>m<sub>x</sub></i> představuje <i>x</i>-tý bit mantisy)</p>

<p>Rozsah hodnot ukládaných ve dvojité přesnosti je
-1,7&times;10<sup>308</sup>..1,7&times;10<sup>308</sup>, nejmenší možná
nenulová hodnota je rovna 2,2&times;10<sup>-308</sup>.</p>

<p>V&nbsp;novější normě IEEE 754-2008 je specifikován nepovinný formát nazvaný
<i>binary128</i>, který se ovšem běžně označuje <i>quadruple precision</i> či
jen <i>quad precision</i>. Tento formát je založen na slovech širokých 128 bitů
(16 bajtů), která jsou rozdělena takto:</p>

<table>
<tr><th>bit</th><td>127</td><td>126 ... 112</td><td>111 ... 0</td></tr>
<tr><th>význam</th><td>s</td><td>exponent (15 bitů)</td><td>mantisa (112 bitů)</td></tr>
</table>

<p>Exponent je v&nbsp;tomto případě posunutý o hodnotu
<strong>bias=16383</strong>. Dekadická přesnost u tohoto formátu dosahuje 34
cifer!</p>

<p>Jen krátce se zmiňme o poslední variantě FP formátu, který se nazývá
<i>binary256</i> či méně formálně <i>octuple precision</i>. Tento formát
využívá slova o šířce plných 256 bitů (32 bajtů) s&nbsp;následujícím
rozdělením:</p>

<table>
<tr><th>bit</th><td>255</td><td>254 ... 236</td><td>235 ... 0</td></tr>
<tr><th>význam</th><td>s</td><td>exponent (19 bitů)</td><td>mantisa (235 bitů)</td></tr>
</table>

<p>Exponent je v&nbsp;tomto případě posunutý o hodnotu
<strong>bias=262143</strong>. Dekadická přesnost u tohoto formátu dosahuje 71
cifer, nejmenší (nenormalizovaná) reprezentovatelná hodnota rozdílná od nuly je
přibližně 10<sup>−78984</sup>, maximální hodnota pak 1.611
&times;10<sup>78913</sup> (těžko říct, zda je takový rozsah vůbec reálně
využitelný).</p>



<p><a name="k05"></a></p>
<h2 id="k05">5. Operace s&nbsp;hodnotami typu <i>single</i> a <i>double</i></h2>

<p>Matematický koprocesor je u architektury AArch64 volitelný, ale oproti 32bitovým ARMům došlo ke zjednodušení &ndash; už neexistuje rozdělení ABI na soft floating point a hard floating point, protože pro předávání hodnot typu float a double jsou vždy použity FP registry popsané <a href="#k06">v&nbsp;navazující kapitole</a>. Z&nbsp;technologického hlediska sice není soft floating point špatné řešení, ale prakticky způsobovalo (a dodnes způsobuje) množství problémů při distribuci knihoven i aplikací.</p>

<p>Samostatná sada pracovních registrů je používána při operacích s&nbsp;typy <i>single/float</i> a <i>double</i> (tedy s&nbsp;operandy reprezentovanými v&nbsp;systému plovoucí řádové čárky), u SIMD operací a taktéž kryptografickým modulem:</p>

<table>
<tr><th>Jméno</th><th>Význam</th></tr>
<tr><td>v0..v31</td><td>128bitové registry</td></tr>
<tr><td>d0..d31</td><td>spodních 64 bitů registrů v0..v31, použito pro hodnoty typu <i>double</i></td></tr>
<tr><td>s0..s31</td><td>spodních 32 bitů registrů v0..v31, použito pro hodnoty typu <i>single/float</i></td></tr>
</table>

<p>Pro SIMD operace, tj.&nbsp;operace pracující s&nbsp;vektory, se registry <strong>vn</strong> rozdělují následujícím způsobem:</p>

<table>
<tr><th>Tvar (shape)</th><th>Celkem</th><th>Pojmenování v&nbsp;assembleru</th></tr>
<tr><td>8b&times;8</td><td>64b</td><td>Vn.8B</td></tr>
<tr><td>8b&times;16</td><td>128b</td><td>Vn.16B</td></tr>
<tr><td>16b&times;4</td><td>64b</td><td>Vn.4H</td></tr>
<tr><td>16b&times;8</td><td>128b</td><td>Vn.8H</td></tr>
<tr><td>32b&times;2</td><td>64b</td><td>Vn.2S</td></tr>
<tr><td>32b&times;4</td><td>128b</td><td>Vn.4S</td></tr>
<tr><td>64b&times;1</td><td>64b</td><td>Vn.1D</td></tr>
<tr><td>64b&times;2</td><td>128b</td><td>Vn.2D</td></tr>
</table>

<p><div class="rs-tip-major">Poznámka: Povšimněte si, že &ndash; na rozdíl od mnoha jiných architektur &ndash; nedochází k&nbsp;tomu, že by se například dva single registry mapovaly do jednoho double registru atd.</div></p>

<p>Poznámka: většina instrukcí známých ze sady VFP (ARM32) byla přejmenována, ovšem prakticky každá z&nbsp;původních instrukcí má svůj nový ekvivalent. Jen pro upřesnění si vypišme některé původní instrukce VFP:</p>

<p>Aritmetické operace:</p>

<table>
<tr><th>#</th><th>Instrukce</th><th>Význam</th><th>Prováděný výpočet</th></tr>
<tr><td> 1</td><td>VADD  Fd, Fn, Fm</td><td>součet</td><td>Fd := Fn + Fm</td></tr>
<tr><td> 2</td><td>VSUB  Fd, Fn, Fm</td><td>rozdíl</td><td>Fd := Fn - Fm</td></tr>
<tr><td> 3</td><td>VNEG  Fd, Fm</td><td>změna znaménka</td><td>Fd := - Fm</td></tr>
<tr><td> 4</td><td>VABS  Fd, Fm</td><td>absolutní hodnota</td><td>Fd := abs(Fm)</td></tr>
<tr><td> 5</td><td>VSQRT Fd, Fm</td><td>druhá odmocnina</td><td>Fd := sqrt(Fm)</td></tr>
<tr><td> 6</td><td>VDIV  Fd, Fn, Fm</td><td>dělení</td><td>Fd := Fn / Fm</td></tr>
<tr><td> 7</td><td>VMUL  Fd, Fn, Fm</td><td>násobení</td><td>Fd := Fn * Fm</td></tr>
<tr><td> 8</td><td>VMLA  Fd, Fn, Fm</td><td>násobení + akumulace</td><td>Fd := Fd + (Fn * Fm)</td></tr>
<tr><td> 9</td><td>VMLS  Fd, Fn, Fm</td><td>odečtení součinu</td><td>Fd := Fd - (Fn * Fm)</td></tr>
<tr><td>10</td><td>VNMUL Fd, Fn, Fm</td><td>násobení + změna znaménka</td><td>Fn := - (Fn * Fm)</td></tr>
<tr><td>11</td><td>VNMLA Fd, Fn, Fm</td><td>kombinace VNMUL a VMLA</td><td>Fd := - Fd - (Fn * Fm)</td></tr>
<tr><td>12</td><td>VNMLS Fd, Fn, Fm</td><td>kombinace VNMUL a VMLS</td><td>Fd := - Fd + (Fn * Fm)</td></tr>
</table>

<p>Porovnání:</p>

<table>
<tr><th>#</th><th>Instrukce</th><th>Význam</th><th>Prováděný výpočet</th></tr>
<tr><td>1</td><td>VCMP Fd, Fm</td><td>Porovnání obsahu dvou registrů</td><td>Fd - Fm</td></tr>
<tr><td>2</td><td>VCMP Fd, #0.0</td><td>Porovnání jednoho registru s nulou</td><td>Fd - 0.0</td></tr>
</table>

<p>Přesuny dat:</p>

<table>
<tr><th>#</th><th>Instrukce</th><th>Význam</th></tr>
<tr><td> 1</td><td>VCVT{C}.F64.F32 Dd, Sm</td><td>Konverze single na double</td></tr>
<tr><td> 2</td><td>VCVT{C}.F32.F64 Sd, Dm</td><td>Konverze double na single</td></tr>
<tr><td> 3</td><td>VCVT{C}.F32/F64.U32 Fd, Sm</td><td>Konverze unsigned integer na float</td></tr>
<tr><td> 4</td><td>VCVT{C}.F32/F64.S32 Fd, Sm</td><td>Konverze signed integer na float</td></tr>
<tr><td> 5</td><td>VCVT{R}{C}.U32.F32/F64 Sd, Fm</td><td>Konverze float na unsigned integer</td></tr>
<tr><td> 6</td><td>VCVT{R}{C}.S32.F32/F64 Sd, Fm</td><td>Konverze float na signed integer</td></tr>
<tr><td> 7</td><td>VCVT.F32/F64.typ Fd, Fd, #bitů</td><td>Konverze fixed-point na float (volitelná pozice tečky)</td></tr>
<tr><td> 8</td><td>VCVT.typ.F32/F64 Fd, Fd, #bitů</td><td>Konverze float na fixed-point (volitelná pozice tečky)</td></tr>
<tr><td> 9</td><td>VCVTT.F16.F32 Sd,Sm</td><td>Konverze single na half (do horních 16 bitů registru)</td></tr>
<tr><td>10</td><td>VCVTB.F16.F32 Sd,Sm</td><td>Konverze single na half (do spodních 16 bitů registru)</td></tr>
<tr><td>11</td><td>VCVTT.F32.F16 Sd,Sm</td><td>Konverze half na single</td></tr>
<tr><td>12</td><td>VCVTB.F32.F16 Sd,Sm</td><td>Konverze half na single</td></tr>
<tr><td>13</td><td>VMOV.F32/F64 Fd, Fm</td><td>Fd := Fm (prostá kopie)</td></tr>
<tr><td>14</td><td>VMOV Sn, Rd</td><td>Sn := Rd (Rd = registr ARM procesoru)</td></tr>
<tr><td>15</td><td>VMOV Rd, Sn</td><td>Rd := Sn (Rd = registr ARM procesoru)</td></tr>
<tr><td>16</td><td>VMOV Sn, Sm, Rd, Rn</td><td>Sn := Rd, Sm := Rn (kopie dvou registrů)</td></tr>
<tr><td>17</td><td>VMOV Rd, Rn, Sn, Sm</td><td>Rd := Sn, Rn := Sm (kopie dvou registrů)</td></tr>
<tr><td>18</td><td>VMOV Dm, Rd, Rn</td><td>Dm[31:0] := Rd, Dm[63:32] := Rn (pro double jsou zapotřebí dva ARM registry)</td></tr>
<tr><td>19</td><td>VMOV Rd, Rn, Dm</td><td>Rd := Dm[31:0], Rn := Dm[63:32]  (pro double jsou zapotřebí dva ARM registry)</td></tr>
<tr><td>20</td><td>VMOV Dn[0], Rd</td><td>Dn[31:0] := Rd  (pouze spodní polovina double)</td></tr>
<tr><td>21</td><td>VMOV Rd, Dn[0]</td><td>Rd := Dn[31:0]  (pouze spodní polovina double)</td></tr>
<tr><td>22</td><td>VMOV Dn[1], Rd</td><td>Dn[63:32] := Rd  (pouze horní polovina double)</td></tr>
<tr><td>23</td><td>VMOV Rd, Dn[1]</td><td>Rd := Dn[63:32]  (pouze horní polovina double)</td></tr>
<tr><td>24</td><td>VMRS APSR_nzcv, FPSCR</td><td>APSR flags := FPSCR flags (přenos příznaků)</td></tr>
</table>



<p><a name="k06"></a></p>
<h2 id="k06">6. Základní operace s&nbsp;FP hodnotami &ndash; načtení konstanty do FP registru</h2>


<p><a name="k07"></a></p>
<h2 id="k07">7. </h2>

<pre>
<i># asmsyntax=as</i>
&nbsp;
<i># Načtení FP konstanty do registru d1</i>
<i># v assembleru GNU AS pro architekturu AArch64.</i>
<i>#</i>
<i># Autor: Pavel Tišnovský</i>
&nbsp;
&nbsp;
&nbsp;
<i># Linux kernel system call table</i>
sys_exit=93
&nbsp;
<i># List of syscalls for AArch64:</i>
<i># https://github.com/torvalds/linux/blob/master/include/uapi/asm-generic/unistd.h</i>
&nbsp;
&nbsp;
&nbsp;
<i>#-----------------------------------------------------------------------------</i>
.section .data
&nbsp;
&nbsp;
&nbsp;
<i>#-----------------------------------------------------------------------------</i>
.section .bss
&nbsp;
&nbsp;
&nbsp;
<i>#-----------------------------------------------------------------------------</i>
.section .text
        .global _start          <i>// tento symbol má být dostupný i z linkeru</i>
&nbsp;
_start:
        fmov d1, #1.00          <i>// načtení konstanty do registru</i>
&nbsp;
        mov  x8, #sys_exit      <i>// číslo sycallu pro funkci "exit"</i>
        mov  x0, #0             <i>// exit code = 0</i>
        svc  0                  <i>// volání Linuxového kernelu</i>
</pre>

<pre>
<i># objdump -d a</i>
&nbsp;
a:     file format elf64-littleaarch64
&nbsp;
&nbsp;
Disassembly of section .text:
&nbsp;
0000000000400078 &lt;_start&gt;:
  400078:       1e6e1001        fmov    d1, #1.000000000000000000e+00
  40007c:       d2800ba8        mov     x8, #0x5d                       <i>// #93</i>
  400080:       d2800000        mov     x0, #0x0                        <i>// #0</i>
  400084:       d4000001        svc     #0x0
</pre>

<pre>
# asmsyntax=as

# Načtení FP konstanty do registru s1
# v assembleru GNU AS pro architekturu AArch64.
#
# Autor: Pavel Tišnovský



# Linux kernel system call table
sys_exit=93

# List of syscalls for AArch64:
# https://github.com/torvalds/linux/blob/master/include/uapi/asm-generic/unistd.h



#-----------------------------------------------------------------------------
.section .data



#-----------------------------------------------------------------------------
.section .bss



#-----------------------------------------------------------------------------
.section .text
        .global _start          // tento symbol má být dostupný i z linkeru

_start:
        fmov s1, #1.00          // načtení konstanty do registru

        mov  x8, #sys_exit      // číslo sycallu pro funkci "exit"
        mov  x0, #0             // exit code = 0
        svc  0                  // volání Linuxového kernelu

</pre>

<pre>
<i># objdump -d a</i>
&nbsp;
a:     file format elf64-littleaarch64
&nbsp;
&nbsp;
Disassembly of section .text:
&nbsp;
0000000000400078 &lt;_start&gt;:
  400078:       1e2e1001        fmov    s1, #1.000000000000000000e+00
  40007c:       d2800ba8        mov     x8, #0x5d                       <i>// #93</i>
  400080:       d2800000        mov     x0, #0x0                        <i>// #0</i>
  400084:       d4000001        svc     #0x0
</pre>
&nbsp;
&nbsp;
&nbsp;
<p><a name="k08"></a></p>
<h2 id="k08">8. </h2>
&nbsp;
<pre>
.section .text
        .global _start          <i>// tento symbol má být dostupný i z linkeru</i>
&nbsp;
_start:
        fmov s1, #0.00          <i>// načtení konstanty do registru</i>
&nbsp;
        mov  x8, #sys_exit      <i>// číslo sycallu pro funkci "exit"</i>
        mov  x0, #0             <i>// exit code = 0</i>
        svc  0                  <i>// volání Linuxového kernelu</i>
</pre>

<pre>
fmov3.s: Assembler messages:
fmov3.s:33: Error: invalid floating-point constant at operand 2 -- `fmov s1,#0.00'
</pre>

<pre>
<i># asmsyntax=as</i>

<i># Načtení FP konstanty do registru s1</i>
<i># v assembleru GNU AS pro architekturu AArch64.</i>
<i>#</i>
<i># Autor: Pavel Tišnovský</i>



<i># Linux kernel system call table</i>
sys_exit=93

<i># List of syscalls for AArch64:</i>
<i># https://github.com/torvalds/linux/blob/master/include/uapi/asm-generic/unistd.h</i>



<i>#-----------------------------------------------------------------------------</i>
.section .data



<i>#-----------------------------------------------------------------------------</i>
.section .bss



<i>#-----------------------------------------------------------------------------</i>
.section .text
        .global _start          <i>// tento symbol má být dostupný i z linkeru</i>

_start:
        fmov s1, wzr            <i>// načtení konstanty do registru</i>

        mov  x8, #sys_exit      <i>// číslo sycallu pro funkci "exit"</i>
        mov  x0, #0             <i>// exit code = 0</i>
        svc  0                  <i>// volání Linuxového kernelu</i>

</pre>

<pre>
$ objdump -d a

a:     file format elf64-littleaarch64


Disassembly of section .text:

0000000000400078 &lt;_start&gt;:
  400078:       1e2703e1        fmov    s1, wzr
  40007c:       d2800ba8        mov     x8, #0x5d                       <i>// #93</i>
  400080:       d2800000        mov     x0, #0x0                        <i>// #0</i>
  400084:       d4000001        svc     #0x0
</pre>

<pre>
<i># asmsyntax=as</i>

<i># Načtení FP konstanty do registru d1</i>
<i># v assembleru GNU AS pro architekturu AArch64.</i>
<i>#</i>
<i># Autor: Pavel Tišnovský</i>



<i># Linux kernel system call table</i>
sys_exit=93

<i># List of syscalls for AArch64:</i>
<i># https://github.com/torvalds/linux/blob/master/include/uapi/asm-generic/unistd.h</i>



<i>#-----------------------------------------------------------------------------</i>
.section .data



<i>#-----------------------------------------------------------------------------</i>
.section .bss



<i>#-----------------------------------------------------------------------------</i>
.section .text
        .global _start          <i>// tento symbol má být dostupný i z linkeru</i>

_start:
        fmov d1, xzr            <i>// načtení konstanty do registru</i>

        mov  x8, #sys_exit      <i>// číslo sycallu pro funkci "exit"</i>
        mov  x0, #0             <i>// exit code = 0</i>
        svc  0                  <i>// volání Linuxového kernelu</i>

</pre>

<pre>
$ objdump -d a

a:     file format elf64-littleaarch64


Disassembly of section .text:

0000000000400078 &lt;_start&gt;:
  400078:       9e6703e1        fmov    d1, xzr
  40007c:       d2800ba8        mov     x8, #0x5d                       <i>// #93</i>
  400080:       d2800000        mov     x0, #0x0                        <i>// #0</i>
  400084:       d4000001        svc     #0x0
</pre>



<p><a name="k09"></a></p>
<h2 id="k09">9. </h2>


https://www.h-schmidt.net/FloatConverter/IEEE754.html

3.14

0x4048f5c3

<pre>
<i># asmsyntax=as</i>
&nbsp;
<i># Načtení FP konstanty do registru d1</i>
<i># v assembleru GNU AS pro architekturu AArch64.</i>
<i>#</i>
<i># Autor: Pavel Tišnovský</i>
&nbsp;
&nbsp;
&nbsp;
<i># Linux kernel system call table</i>
sys_exit=93
&nbsp;
<i># List of syscalls for AArch64:</i>
<i># https://github.com/torvalds/linux/blob/master/include/uapi/asm-generic/unistd.h</i>
&nbsp;
&nbsp;
&nbsp;
<i>#-----------------------------------------------------------------------------</i>
.section .data
&nbsp;
&nbsp;
&nbsp;
<i>#-----------------------------------------------------------------------------</i>
.section .bss
&nbsp;
&nbsp;
&nbsp;
<i>#-----------------------------------------------------------------------------</i>
.section .text
        .global _start          <i>// tento symbol má být dostupný i z linkeru</i>
&nbsp;
_start:
        ldr  d1, =0x4048f5c3    <i>// načtení konstanty do registru</i>
&nbsp;
&nbsp;
        mov  x8, #sys_exit      <i>// číslo sycallu pro funkci "exit"</i>
        mov  x0, #0             <i>// exit code = 0</i>
        svc  0                  <i>// volání Linuxového kernelu</i>
</pre>

<pre>
$ <strong>objdump -d a</strong>
&nbsp;
a:     file format elf64-littleaarch64
&nbsp;
&nbsp;
Disassembly of section .text:
&nbsp;
0000000000400078 &lt;_start&gt;:
  400078:       5c000081        ldr     d1, 400088 &lt;_start+0x10&gt;
  40007c:       d2800ba8        mov     x8, #0x5d                       <i>// #93</i>
  400080:       d2800000        mov     x0, #0x0                        <i>// #0</i>
  400084:       d4000001        svc     #0x0
  400088:       4048f5c3        .word   0x4048f5c3
  40008c:       00000000        .word   0x00000000
</pre>



<p><a name="k10"></a></p>
<h2 id="k10">10. </h2>



<p><a name="k11"></a></p>
<h2 id="k11">11. </h2>



<p><a name="k12"></a></p>
<h2 id="k12">12. </h2>



<p><a name="k13"></a></p>
<h2 id="k13">13. </h2>



<p><a name="k14"></a></p>
<h2 id="k14">14. </h2>



<p><a name="k15"></a></p>
<h2 id="k15">15. </h2>



<p><a name="k16"></a></p>
<h2 id="k16">16. </h2>



<p><a name="k17"></a></p>
<h2 id="k17">17. </h2>



<p><a name="k18"></a></p>
<h2 id="k18">18. Repositář s&nbsp;demonstračními příklady</h2>

<p>Všechny <a
href="https://www.root.cz/clanky/specificke-vlastnosti-procesoru-aarch64-podminene-a-nepodminene-skoky-adresovani-dat/">minule</a>
i dnes popisované demonstrační příklady byly společně s&nbsp;podpůrným souborem
<strong>Makefile</strong> určeným pro jejich překlad či naopak pro
disassembling, uloženy do GIT repositáře dostupného na adrese <a
href="https://github.com/tisnik/presentations/">https://github.com/tisnik/presentations/</a>.
Všechny příklady jsou určeny pro standardní <i>GNU Assembler</i> a používají
výchozí syntaxi procesorů AArch64. Následuje tabulka s&nbsp;odkazy na zdrojové
kódy příkladů i na již zmíněné podpůrné skripty:</p>

<table>
<tr><th> #</th><th>Příklad</th><th>Popis</th><th>Zdrojový kód</th></tr>
<tr><td> 1</td><td>template.s</td><td>šablona pro programy psané v&nbsp;assembleru</td><td><a href="https://github.com/tisnik/presentations/blob/master/assembler/aarch64/template.s">https://github.com/tisnik/presentations/blob/master/assembler/aarch64/template.s</a></td></tr>
<tr><td> 2</td><td>template_2.s</td><td>šablona pro programy psané v&nbsp;assembleru, založeno na makrech</td><td><a href="https://github.com/tisnik/presentations/blob/master/assembler/aarch64/template_2.s">https://github.com/tisnik/presentations/blob/master/assembler/aarch64/template_2.s</a></td></tr>
<tr><td> 3</td><td>hello_world_1.s</td><td>základní podoba programu typu &bdquo;Hello, world!&ldquo;</td><td><a href="https://github.com/tisnik/presentations/blob/master/assembler/aarch64/hello_world_1.s">https://github.com/tisnik/presentations/blob/master/assembler/aarch64/hello_world_1.s</a></td></tr>
<tr><td> 4</td><td>hello_world_2.s</td><td>přepis tištěného řetězce</td><td><a href="https://github.com/tisnik/presentations/blob/master/assembler/aarch64/hello_world_2.s">https://github.com/tisnik/presentations/blob/master/assembler/aarch64/hello_world_2.s</a></td></tr>
<tr><td> 5</td><td>hello_world_3.s</td><td>refaktoring, použití maker</td><td><a href="https://github.com/tisnik/presentations/blob/master/assembler/aarch64/hello_world_3.s">https://github.com/tisnik/presentations/blob/master/assembler/aarch64/hello_world_3.s</a></td></tr>
<tr><td> 6</td><td>aritmetic1.s</td><td>základní aritmetické operace</td><td><a href="https://github.com/tisnik/presentations/blob/master/assembler/aarch64/aritmetic1.s">https://github.com/tisnik/presentations/blob/master/assembler/aarch64/aritmetic1.s</a></td></tr>
<tr><td> 7</td><td>infinite_loop.s</td><td>nekonečná programová smyčka realizovaná instrukcí <strong>b</strong></td><td><a href="https://github.com/tisnik/presentations/blob/master/assembler/aarch64/infinite_loop.s">https://github.com/tisnik/presentations/blob/master/assembler/aarch64/infinite_loop.s</a></td></tr>
<tr><td> 8</td><td>loop1-aarch64-v1.s</td><td>základní varianta počítané programové smyčky</td><td><a href="https://github.com/tisnik/presentations/blob/master/assembler/aarch64/loop1-aarch64-v1.s">https://github.com/tisnik/presentations/blob/master/assembler/aarch64/loop1-aarch64-v1.s</a></td></tr>
<tr><td> 9</td><td>loop1-aarch64-v2.s</td><td>optimalizace &ndash; odstranění instrukce <strong>CMP</strong></td><td><a href="https://github.com/tisnik/presentations/blob/master/assembler/aarch64/loop1-aarch64-v2.s">https://github.com/tisnik/presentations/blob/master/assembler/aarch64/loop1-aarch64-v2.s</a></td></tr>
<tr><td>10</td><td>loop1-aarch64-v3.s</td><td>optimalizace &ndash; použití instrukce <strong>CBNZ</strong></td><td><a href="https://github.com/tisnik/presentations/blob/master/assembler/aarch64/loop1-aarch64-v3.s">https://github.com/tisnik/presentations/blob/master/assembler/aarch64/loop1-aarch64-v3.s</a></td></tr>
<tr><td>11</td><td>loop1-aarch64-v4.s</td><td>automatické zvýšení adresy (ukazatele)</td><td><a href="https://github.com/tisnik/presentations/blob/master/assembler/aarch64/loop1-aarch64-v4.s">https://github.com/tisnik/presentations/blob/master/assembler/aarch64/loop1-aarch64-v4.s</a></td></tr>
<tr><td>12</td><td>move1.s</td><td>přesun bloku dat</td><td><a href="https://github.com/tisnik/presentations/blob/master/assembler/aarch64/move1.s">https://github.com/tisnik/presentations/blob/master/assembler/aarch64/move1.s</a></td></tr>
<tr><td>13</td><td>move2.s</td><td>přepis s&nbsp;využitím maker</td><td><a href="https://github.com/tisnik/presentations/blob/master/assembler/aarch64/move2.s">https://github.com/tisnik/presentations/blob/master/assembler/aarch64/move2.s</a></td></tr>
<tr><td>14</td><td>move3.s</td><td>problém s&nbsp;vícenásobným použitím makra</td><td><a href="https://github.com/tisnik/presentations/blob/master/assembler/aarch64/move3.s">https://github.com/tisnik/presentations/blob/master/assembler/aarch64/move3.s</a></td></tr>
<tr><td>15</td><td>move4.s</td><td>vyřešení předchozího problému</td><td><a href="https://github.com/tisnik/presentations/blob/master/assembler/aarch64/move4.s">https://github.com/tisnik/presentations/blob/master/assembler/aarch64/move4.s</a></td></tr>
<tr><td>16</td><td>move5.s</td><td>jednoduchý benchmark &ndash; přesun bloků po bajtech</td><td><a href="https://github.com/tisnik/presentations/blob/master/assembler/aarch64/move5.s">https://github.com/tisnik/presentations/blob/master/assembler/aarch64/move5.s</a></td></tr>
<tr><td>17</td><td>move6.s</td><td>jednoduchý benchmark &ndash; přesun bloků po slovech</td><td><a href="https://github.com/tisnik/presentations/blob/master/assembler/aarch64/move6.s">https://github.com/tisnik/presentations/blob/master/assembler/aarch64/move6.s</a></td></tr>
<tr><td>18</td><td>move7.s</td><td>jednoduchý benchmark &ndash; přesun bloků po dvojicích slov</td><td><a href="https://github.com/tisnik/presentations/blob/master/assembler/aarch64/move7.s">https://github.com/tisnik/presentations/blob/master/assembler/aarch64/move7.s</a></td></tr>
<tr><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td></tr>
<tr><td>19</td><td>fmov1.s</td><td></td><td><a href="https://github.com/tisnik/presentations/blob/master/assembler/aarch64/fmov1.s">https://github.com/tisnik/presentations/blob/master/assembler/aarch64/fmov1.s</a></td></tr>
<tr><td>20</td><td>fmov2.s</td><td></td><td><a href="https://github.com/tisnik/presentations/blob/master/assembler/aarch64/fmov2.s">https://github.com/tisnik/presentations/blob/master/assembler/aarch64/fmov2.s</a></td></tr>
<tr><td>21</td><td>fmov3.s</td><td></td><td><a href="https://github.com/tisnik/presentations/blob/master/assembler/aarch64/fmov3.s">https://github.com/tisnik/presentations/blob/master/assembler/aarch64/fmov3.s</a></td></tr>
<tr><td>22</td><td>fmov4.s</td><td></td><td><a href="https://github.com/tisnik/presentations/blob/master/assembler/aarch64/fmov4.s">https://github.com/tisnik/presentations/blob/master/assembler/aarch64/fmov4.s</a></td></tr>
<tr><td>23</td><td>fmov5.s</td><td></td><td><a href="https://github.com/tisnik/presentations/blob/master/assembler/aarch64/fmov5.s">https://github.com/tisnik/presentations/blob/master/assembler/aarch64/fmov5.s</a></td></tr>
<tr><td>24</td><td>fmov6.s</td><td></td><td><a href="https://github.com/tisnik/presentations/blob/master/assembler/aarch64/fmov6.s">https://github.com/tisnik/presentations/blob/master/assembler/aarch64/fmov6.s</a></td></tr>
<tr><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td></tr>
<tr><td>2x</td><td>Makefile</td><td>soubor pro překlad všech příkladů nástrojem <strong>make</strong></td><td><a href="https://github.com/tisnik/presentations/blob/master/assembler/aarch64/Makefile">https://github.com/tisnik/presentations/blob/master/assembler/aarch64/Makefile</a></td></tr>
</table>



<p><a name="k19"></a></p>
<h2 id="k19">19. Předchozí články o architektuře AArch64</h2>

<p>S&nbsp;architekturou AArch64 jsme se již na stránkách Roota setkali, a to
konkrétně v&nbsp;následujících článcích, z&nbsp;nichž dnes vycházíme:</p>

<ol>

<li>64bitové mikroprocesory s architekturou AArch64<br />
<a href="https://www.root.cz/clanky/64bitove-mikroprocesory-s-architekturou-aarch64/">https://www.root.cz/clanky/64bitove-mikroprocesory-s-architekturou-aarch64/</a>
</li>

<li>Instrukční sada AArch64<br />
<a href="https://www.root.cz/clanky/instrukcni-sada-aarch64/">https://www.root.cz/clanky/instrukcni-sada-aarch64/</a>
</li>

<li>Instrukční sada AArch64 (2.část)<br />
<a href="https://www.root.cz/clanky/instrukcni-sada-aarch64-2-cast/">https://www.root.cz/clanky/instrukcni-sada-aarch64-2-cast/</a>
</li>

<li>Tvorba a ladění programů v&nbsp;assembleru mikroprocesorů AArch64<br />
<a href="https://www.root.cz/clanky/tvorba-a-ladeni-programu-v-assembleru-mikroprocesoru-aarch64/">https://www.root.cz/clanky/tvorba-a-ladeni-programu-v-assembleru-mikroprocesoru-aarch64/</a>
</li>

<li>Instrukční sada AArch64: technologie NEON<br />
<a href="https://www.root.cz/clanky/instrukcni-sada-aarch64-technologie-neon/">https://www.root.cz/clanky/instrukcni-sada-aarch64-technologie-neon/</a>
</li>

<li>Specifické vlastnosti procesorů AArch64: základní instrukce<br />
<a href="https://www.root.cz/clanky/specificke-vlastnosti-procesoru-aarch64-zakladni-instrukce/">https://www.root.cz/clanky/specificke-vlastnosti-procesoru-aarch64-zakladni-instrukce/</a>
</li>

<li>Specifické vlastnosti procesorů AArch64: podmíněné a nepodmíněné skoky, adresování dat<br />
<a href="https://www.root.cz/clanky/specificke-vlastnosti-procesoru-aarch64-podminene-a-nepodminene-skoky-adresovani-dat/">https://www.root.cz/clanky/specificke-vlastnosti-procesoru-aarch64-podminene-a-nepodminene-skoky-adresovani-dat/</a>
</li>

<li>Specifické vlastnosti procesorů AArch64: přenos bloků dat a instrukce s podmínkou<br />
<a href="https://www.root.cz/clanky/specificke-vlastnosti-procesoru-aarch64-prenos-bloku-dat-a-instrukce-s-podminkou/">https://www.root.cz/clanky/specificke-vlastnosti-procesoru-aarch64-prenos-bloku-dat-a-instrukce-s-podminkou/</a>
</li>

</ol>



<p><a name="k20"></a></p>
<h2 id="k20">20. Odkazy na Internetu</h2>

<ol>

<li>Arm Architecture Reference Manual for A-profile architecture<br />
<a href="https://developer.arm.com/documentation/ddi0487/latest">https://developer.arm.com/documentation/ddi0487/latest</a>
</li>

<li>The GNU Assembler - macros<br />
<a href="http://tigcc.ticalc.org/doc/gnuasm.html#SEC109">http://tigcc.ticalc.org/doc/gnuasm.html#SEC109</a>
</li>

<li>GNU Binutils<br />
<a href="https://sourceware.org/binutils/">https://sourceware.org/binutils/</a>
</li>

<li>Documentation for binutils 2.38<br />
<a href="https://sourceware.org/binutils/docs-2.38/">https://sourceware.org/binutils/docs-2.38/</a>
</li>

<li>AArch64 Instruction Set Architecture<br />
<a href="https://developer.arm.com/architectures/learn-the-architecture/aarch64-instruction-set-architecture/instruction-sets-in-the-arm-architecture">https://developer.arm.com/architectures/learn-the-architecture/aarch64-instruction-set-architecture/instruction-sets-in-the-arm-architecture</a>
</li>

<li>Arm Armv8-A A32/T32 Instruction Set Architecture<br />
<a href="https://developer.arm.com/documentation/ddi0597/2021-12/?lang=en">https://developer.arm.com/documentation/ddi0597/2021-12/?lang=en</a>
</li>

<li>Comparison of ARMv8-A cores<br />
<a href="https://en.wikipedia.org/wiki/Comparison_of_ARMv8-A_cores">https://en.wikipedia.org/wiki/Comparison_of_ARMv8-A_cores</a>
</li>

<li>Cortex-A32 Processor<br />
<a href="https://www.arm.com/products/processors/cortex-a/cortex-a32-processor.php">https://www.arm.com/products/processors/cortex-a/cortex-a32-processor.php</a>
</li>

<li>Cortex-A35 Processor<br />
<a href="https://www.arm.com/products/processors/cortex-a/cortex-a35-processor.php">https://www.arm.com/products/processors/cortex-a/cortex-a35-processor.php</a>
</li>

<li>Cortex-A53 Processor<br />
<a href="https://www.arm.com/products/processors/cortex-a/cortex-a53-processor.php">https://www.arm.com/products/processors/cortex-a/cortex-a53-processor.php</a>
</li>

<li>Cortex-A57 Processor<br />
<a href="https://www.arm.com/products/processors/cortex-a/cortex-a57-processor.php">https://www.arm.com/products/processors/cortex-a/cortex-a57-processor.php</a>
</li>

<li>Cortex-A72 Processor<br />
<a href="https://www.arm.com/products/processors/cortex-a/cortex-a72-processor.php">https://www.arm.com/products/processors/cortex-a/cortex-a72-processor.php</a>
</li>

<li>Cortex-A73 Processor<br />
<a href="https://www.arm.com/products/processors/cortex-a/cortex-a73-processor.php">https://www.arm.com/products/processors/cortex-a/cortex-a73-processor.php</a>
</li>

<li>Apple A7 (SoC založen na CPU Cyclone)<br />
<a href="https://en.wikipedia.org/wiki/Apple_A7">https://en.wikipedia.org/wiki/Apple_A7</a>
</li>

<li>System cally pro AArch64 na Linuxu<br />
<a href="https://github.com/torvalds/linux/blob/master/include/uapi/asm-generic/unistd.h">https://github.com/torvalds/linux/blob/master/include/uapi/asm-generic/unistd.h</a>
</li>

<li>Architectures/AArch64 (FedoraProject.org)<br />
<a href="https://fedoraproject.org/wiki/Architectures/AArch64">https://fedoraproject.org/wiki/Architectures/AArch64</a>
</li>

<li>SIG pro AArch64 (CentOS)<br />
<a href="https://wiki.centos.org/SpecialInterestGroup/AltArch/AArch64">https://wiki.centos.org/SpecialInterestGroup/AltArch/AArch64</a>
</li>

<li>The ARMv8 instruction sets<br />
<a href="http://infocenter.arm.com/help/index.jsp?topic=/com.arm.doc.den0024a/ch05s01.html">http://infocenter.arm.com/help/index.jsp?topic=/com.arm.doc.den0024a/ch05s01.html</a>
</li>

<li>A64 Instruction Set<br />
<a href="https://developer.arm.com/products/architecture/instruction-sets/a64-instruction-set">https://developer.arm.com/products/architecture/instruction-sets/a64-instruction-set</a>
</li>

<li>Switching between the instruction sets<br />
<a href="http://infocenter.arm.com/help/index.jsp?topic=/com.arm.doc.den0024a/ch05s01.html">http://infocenter.arm.com/help/index.jsp?topic=/com.arm.doc.den0024a/ch05s01.html</a>
</li>

<li>The A64 instruction set<br />
<a href="http://infocenter.arm.com/help/index.jsp?topic=/com.arm.doc.den0024a/ch05s01.html">http://infocenter.arm.com/help/index.jsp?topic=/com.arm.doc.den0024a/ch05s01.html</a>
</li>

<li>Introduction to ARMv8 64-bit Architecture<br />
<a href="https://quequero.org/2014/04/introduction-to-arm-architecture/">https://quequero.org/2014/04/introduction-to-arm-architecture/</a>
</li>

<li>MCU market turns to 32-bits and ARM<br />
<a href="http://www.eetimes.com/document.asp?doc_id=1280803">http://www.eetimes.com/document.asp?doc_id=1280803</a>
</li>

<li>Cortex-M0 Processor (ARM Holdings)<br />
<a href="http://www.arm.com/products/processors/cortex-m/cortex-m0.php">http://www.arm.com/products/processors/cortex-m/cortex-m0.php</a>
</li>

<li>Cortex-M0+ Processor (ARM Holdings)<br />
<a href="http://www.arm.com/products/processors/cortex-m/cortex-m0plus.php">http://www.arm.com/products/processors/cortex-m/cortex-m0plus.php</a>
</li>

<li>ARM Processors in a Mixed Signal World<br />
<a href="http://www.eeweb.com/blog/arm/arm-processors-in-a-mixed-signal-world">http://www.eeweb.com/blog/arm/arm-processors-in-a-mixed-signal-world</a>
</li>

<li>ARM Architecture (Wikipedia)<br />
<a href="https://en.wikipedia.org/wiki/ARM_architecture">https://en.wikipedia.org/wiki/ARM_architecture</a>
</li>

<li>DSP for Cortex-M<br />
<a href="https://developer.arm.com/technologies/dsp/dsp-for-cortex-m">https://developer.arm.com/technologies/dsp/dsp-for-cortex-m</a>
</li>

<li>Cortex-M processors in DSP applications? Why not?!<br />
<a href="https://community.arm.com/processors/b/blog/posts/cortex-m-processors-in-dsp-applications-why-not">https://community.arm.com/processors/b/blog/posts/cortex-m-processors-in-dsp-applications-why-not</a>
</li>

<li>White Paper - DSP capabilities of Cortex-M4 and Cortex-M7<br />
<a href="https://community.arm.com/processors/b/blog/posts/white-paper-dsp-capabilities-of-cortex-m4-and-cortex-m7">https://community.arm.com/processors/b/blog/posts/white-paper-dsp-capabilities-of-cortex-m4-and-cortex-m7</a>
</li>

<li>Q (number format)<br />
<a href="https://en.wikipedia.org/wiki/Q_%28number_format%29">https://en.wikipedia.org/wiki/Q_%28number_format%29</a>
</li>

<li>TriCore Architecture &amp; Core<br />
<a href="http://www.infineon.com/cms/en/product/microcontroller/32-bit-tricore-tm-microcontroller/tricore-tm-architecture-and-core/channel.html?channel=ff80808112ab681d0112ab6b73d40837">http://www.infineon.com/cms/en/product/microcontroller/32-bit-tricore-tm-microcontroller/tricore-tm-architecture-and-core/channel.html?channel=ff80808112ab681d0112ab6b73d40837</a>
</li>

<li>TriCoreTM V1.6 Instruction Set: 32-bit Unified Processor Core<br />
<a href="http://www.infineon.com/dgdl/tc_v131_instructionset_v138.pdf?fileId=db3a304412b407950112b409b6dd0352">http://www.infineon.com/dgdl/tc_v131_instructionset_v138.pdf?fileId=db3a304412b407950112b409b6dd0352</a>
</li>

<li>TriCore v2.2 C Compiler, Assembler, Linker Reference Manual<br />
<a href="http://tasking.com/support/tricore/tc_reference_guide_v2.2.pdf">http://tasking.com/support/tricore/tc_reference_guide_v2.2.pdf</a>
</li>

<li>Infineon TriCore (Wikipedia)<br />
<a href="https://en.wikipedia.org/wiki/Infineon_TriCore">https://en.wikipedia.org/wiki/Infineon_TriCore</a>
</li>

<li>C166®S V2 Architecture &amp; Core<br />
<a href="http://www.infineon.com/cms/en/product/microcontroller/16-bit-c166-microcontroller/c166-s-v2-architecture-and-core/channel.html?channel=db3a304312bef5660112c3011c7d01ae">http://www.infineon.com/cms/en/product/microcontroller/16-bit-c166-microcontroller/c166-s-v2-architecture-and-core/channel.html?channel=db3a304312bef5660112c3011c7d01ae</a>
</li>

<li>Comparing four 32-bit soft processor cores<br />
<a href="http://www.eetimes.com/author.asp?section_id=14&doc_id=1286116">http://www.eetimes.com/author.asp?section_id=14&doc_id=1286116</a>
</li>

<li>RISC-V Instruction Set<br />
<a href="http://riscv.org/download.html#spec_compressed_isa">http://riscv.org/download.html#spec_compressed_isa</a>
</li>

<li>RISC-V Spike (ISA Simulator)<br />
<a href="http://riscv.org/download.html#isa-sim">http://riscv.org/download.html#isa-sim</a>
</li>

<li>RISC-V (Wikipedia)<br />
<a href="https://en.wikipedia.org/wiki/RISC-V">https://en.wikipedia.org/wiki/RISC-V</a>
</li>

<li>David Patterson (Wikipedia)<br />
<a href="https://en.wikipedia.org/wiki/David_Patterson_(computer_scientist)">https://en.wikipedia.org/wiki/David_Patterson_(computer_scientist)</a>
</li>

<li>OpenRISC (oficiální stránky projektu)<br />
<a href="http://openrisc.io/">http://openrisc.io/</a>
</li>

<li>OpenRISC architecture<br />
<a href="http://openrisc.io/architecture.html">http://openrisc.io/architecture.html</a>
</li>

<li>Emulátor OpenRISC CPU v JavaScriptu<br />
<a href="http://s-macke.github.io/jor1k/demos/main.html">http://s-macke.github.io/jor1k/demos/main.html</a>
</li>

<li>OpenRISC (Wikipedia)<br />
<a href="https://en.wikipedia.org/wiki/OpenRISC">https://en.wikipedia.org/wiki/OpenRISC</a>
</li>

<li>OpenRISC - instrukce<br />
<a href="http://sourceware.org/cgen/gen-doc/openrisc-insn.html">http://sourceware.org/cgen/gen-doc/openrisc-insn.html</a>
</li>

<li>OpenRISC - slajdy z přednášky o projektu<br />
<a href="https://iis.ee.ethz.ch/~gmichi/asocd/lecturenotes/Lecture6.pdf">https://iis.ee.ethz.ch/~gmichi/asocd/lecturenotes/Lecture6.pdf</a>
</li>

<li>Berkeley RISC<br />
<a href="http://en.wikipedia.org/wiki/Berkeley_RISC">http://en.wikipedia.org/wiki/Berkeley_RISC</a>
</li>

<li>Great moments in microprocessor history<br />
<a href="http://www.ibm.com/developerworks/library/pa-microhist.html">http://www.ibm.com/developerworks/library/pa-microhist.html</a>
</li>

<li>Microprogram-Based Processors<br />
<a href="http://research.microsoft.com/en-us/um/people/gbell/Computer_Structures_Principles_and_Examples/csp0167.htm">http://research.microsoft.com/en-us/um/people/gbell/Computer_Structures_Principles_and_Examples/csp0167.htm</a>
</li>

<li>Great Microprocessors of the Past and Present<br />
<a href="http://www.cpushack.com/CPU/cpu1.html">http://www.cpushack.com/CPU/cpu1.html</a>
</li>

<li>A Brief History of Microprogramming<br />
<a href="http://www.cs.clemson.edu/~mark/uprog.html">http://www.cs.clemson.edu/~mark/uprog.html</a>
</li>

<li>What is RISC?<br />
<a href="http://www-cs-faculty.stanford.edu/~eroberts/courses/soco/projects/2000-01/risc/whatis/">http://www-cs-faculty.stanford.edu/~eroberts/courses/soco/projects/2000-01/risc/whatis/</a>
</li>

<li>RISC vs. CISC<br />
<a href="http://www-cs-faculty.stanford.edu/~eroberts/courses/soco/projects/2000-01/risc/risccisc/">http://www-cs-faculty.stanford.edu/~eroberts/courses/soco/projects/2000-01/risc/risccisc/</a>
</li>

<li>RISC and CISC definitions:<br />
<a href="http://www.cpushack.com/CPU/cpuAppendA.html">http://www.cpushack.com/CPU/cpuAppendA.html</a>
</li>

<li>FPGA<br />
<a href="https://cs.wikipedia.org/wiki/Programovateln%C3%A9_hradlov%C3%A9_pole">https://cs.wikipedia.org/wiki/Programovateln%C3%A9_hradlov%C3%A9_pole</a>
</li>

<li>The Evolution of RISC<br />
<a href="http://www.ibm.com/developerworks/library/pa-microhist.html#sidebar1">http://www.ibm.com/developerworks/library/pa-microhist.html#sidebar1</a>
</li>

<li>disasm.pro<br />
<a href="https://disasm.pro/">https://disasm.pro/</a>
</li>

<li>Exploring AArch64 assembler &ndash; Chapter 5<br />
<a href="https://thinkingeek.com/2016/11/13/exploring-aarch64-assembler-chapter-5/">https://thinkingeek.com/2016/11/13/exploring-aarch64-assembler-chapter-5/</a>
</li>

<li>Brain Floating Point &ndash; nový formát uložení čísel pro strojové učení a chytrá čidla<br />
<a href="https://www.root.cz/clanky/brain-floating-point-ndash-novy-format-ulozeni-cisel-pro-strojove-uceni-a-chytra-cidla/">https://www.root.cz/clanky/brain-floating-point-ndash-novy-format-ulozeni-cisel-pro-strojove-uceni-a-chytra-cidla/</a>
</li>

<li>Why Intel is betting on BFLOAT16 to be a game changer for deep learning training? Hint: Range trumps Precision<br />
<a href="https://hub.packtpub.com/why-intel-is-betting-on-bfloat16-to-be-a-game-changer-for-deep-learning-training-hint-range-trumps-precision/">https://hub.packtpub.com/why-intel-is-betting-on-bfloat16-to-be-a-game-changer-for-deep-learning-training-hint-range-trumps-precision/</a>
</li>

<li>half-rs (pro Rust)<br />
<a href="https://github.com/starkat99/half-rs">https://github.com/starkat99/half-rs</a>
</li>

<li>float16 (pro Go)<br />
<a href="https://github.com/x448/float16">https://github.com/x448/float16</a>
</li>

<li>bfloat16 - Hardware Numerics Definition<br />
<a href="https://software.intel.com/en-us/download/bfloat16-hardware-numerics-definition">https://software.intel.com/en-us/download/bfloat16-hardware-numerics-definition</a>
</li>

<li>Intel Prepares To Graft Google’s Bfloat16 Onto Processors<br />
<a href="https://www.nextplatform.com/2019/07/15/intel-prepares-to-graft-googles-bfloat16-onto-processors/">https://www.nextplatform.com/2019/07/15/intel-prepares-to-graft-googles-bfloat16-onto-processors/</a>
</li>

<li>Norma IEEE 754 a příbuzní: formáty plovoucí řádové tečky<br />
<a href="https://www.root.cz/clanky/norma-ieee-754-a-pribuzni-formaty-plovouci-radove-tecky/">https://www.root.cz/clanky/norma-ieee-754-a-pribuzni-formaty-plovouci-radove-tecky/</a>
</li>

<li>IEEE-754 Floating-Point Conversion<br />
<a href="http://babbage.cs.qc.cuny.edu/IEEE-754.old/32bit.html">http://babbage.cs.qc.cuny.edu/IEEE-754.old/32bit.html</a>
</li>

<li>Small Float Formats<br />
<a href="https://www.khronos.org/opengl/wiki/Small_Float_Formats">https://www.khronos.org/opengl/wiki/Small_Float_Formats</a>
</li>

<li>Binary-coded decimal<br />
<a href="https://en.wikipedia.org/wiki/Binary-coded_decimal">https://en.wikipedia.org/wiki/Binary-coded_decimal</a>
</li>

<li>Chen–Ho encoding<br />
<a href="https://en.wikipedia.org/wiki/Chen%E2%80%93Ho_encoding">https://en.wikipedia.org/wiki/Chen%E2%80%93Ho_encoding</a>
</li>

<li>Densely packed decimal<br />
<a href="https://en.wikipedia.org/wiki/Densely_packed_decimal">https://en.wikipedia.org/wiki/Densely_packed_decimal</a>
</li>

<li>A Summary of Chen-Ho Decimal Data encoding<br />
<a href="http://speleotrove.com/decimal/chen-ho.html">http://speleotrove.com/decimal/chen-ho.html</a>
</li>

<li>Art of Assembly language programming: The 80x87 Floating Point Coprocessors<br />
<a href="https://courses.engr.illinois.edu/ece390/books/artofasm/CH14/CH14-3.html">https://courses.engr.illinois.edu/ece390/books/artofasm/CH14/CH14-3.html</a>
</li>

<li>Art of Assembly language programming: The FPU Instruction Set<br />
<a href="https://courses.engr.illinois.edu/ece390/books/artofasm/CH14/CH14-4.html">https://courses.engr.illinois.edu/ece390/books/artofasm/CH14/CH14-4.html</a>
</li>

<li>INTEL 80387 PROGRAMMER'S REFERENCE MANUAL<br />
<a href="http://www.ragestorm.net/downloads/387intel.txt">http://www.ragestorm.net/downloads/387intel.txt</a>
</li>

<li>Floating-Point Formats<br />
<a href="http://www.quadibloc.com/comp/cp0201.htm">http://www.quadibloc.com/comp/cp0201.htm</a>
</li>

<li>Floating Point Numbers<br />
<a href="https://floating-point-gui.de/formats/fp/">https://floating-point-gui.de/formats/fp/</a>
</li>

<li>Float exposed<br />
<a href="https://float.exposed/0x40490000">https://float.exposed/0x40490000</a>
</li>

<li>Float Toy<br />
<a href="http://evanw.github.io/float-toy/">http://evanw.github.io/float-toy/</a>
</li>

<li>IEEE-754 visualization<br />
<a href="https://bartaz.github.io/ieee754-visualization/">https://bartaz.github.io/ieee754-visualization/</a>
</li>

</ol>



<p></p><p></p>
<p><small>Autor: <a href="http://www.fit.vutbr.cz/~tisnovpa">Pavel Tišnovský</a> &nbsp; 2022</small></p>
</body>
</html>

