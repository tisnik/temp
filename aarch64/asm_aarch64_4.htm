<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
        "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html>
<head>
<title></title>
<meta name="Author" content="Pavel Tisnovsky" />
<meta name="Generator" content="vim" />
<meta http-equiv="content-type" content="text/html; charset=utf-8" />
<style type="text/css">
         body {color:#000000; background:#ffffff;}
         h1  {font-family: arial, helvetica, sans-serif; color:#ffffff; background-color:#c00000; text-align:center; padding-left:1em}
         h2  {font-family: arial, helvetica, sans-serif; color:#ffffff; background-color:#0000c0; padding-left:1em; text-align:left}
         h3  {font-family: arial, helvetica, sans-serif; color:#000000; background-color:#c0c0c0; padding-left:1em; text-align:left}
         h4  {font-family: arial, helvetica, sans-serif; color:#000000; background-color:#e0e0e0; padding-left:1em; text-align:left}
         a   {font-family: arial, helvetica, sans-serif;}
         li  {font-family: arial, helvetica, sans-serif; color:#000000; text-align:justify; width:450px;}
         ol  {font-family: arial, helvetica, sans-serif; color:#000000; text-align:justify; width:450px;}
         ul  {font-family: arial, helvetica, sans-serif; color:#000000; text-align:justify; width:450px;}
         p   {font-family: arial, helvetica, sans-serif; color:#000000; text-align:justify;}
         pre {background:#e0e0e0}
</style>
</head>

<body>

<h1></h1>

<h3>Pavel Tišnovský</h3>

<p></p>

<h1>Úvodník</h1>

<p></p>



<h2>Obsah</h2>

<p><a href="#k01">1. Aritmetické operace s&nbsp;celočíselnými typy i s&nbsp;hodnotami s&nbsp;plovoucí řádovou čárkou</a></p>
<p><a href="#k02">2. Specifické vlastnosti aritmeticko-logické jednotky</a></p>
<p><a href="#k03">3. Hodnoty typu <i>single</i> a <i>double</i></a></p>
<p><a href="#k04">4. Formát plovoucí řádové binární tečky a norma IEEE 754</a></p>
<p><a href="#k05">5. Operace s&nbsp;hodnotami typu <i>single</i> a <i>double</i></a></p>
<p><a href="#k06">6. Základní operace s&nbsp;FP hodnotami &ndash; načtení konstanty do FP registru</a></p>
<p><a href="#k07">7. Praktický příklad &ndash; načtení konstant do registrů <strong>D1</strong> a <strong>S1</strong></a></p>
<p><a href="#k08">*** 8. Nepodporované konstanty aneb (logické) omezení možností RISCových instrukcí</a></p>
<p><a href="#k09">9. Vynulování registrů <strong>Dx</strong> a <strong>Sx</strong></a></p>
<p><a href="#k10">10. Nepřímé načtení konstant s&nbsp;libovolnou hodnotou do registrů <strong>Dx</strong> a <strong>Sx</strong></a></p>
<p><a href="#k11">11. Přenos operandů mezi registry</a></p>
<p><a href="#k12">12. Ukázka přenosu mezi celočíselným a FP registrem</a></p>
<p><a href="#k13">13. Konverze mezi různými formáty</a></p>
<p><a href="#k14">14. Převod FP hodnot na celá čísla (zaokrouhlení)</a></p>
<p><a href="#k15">15. Základní aritmetické operace s&nbsp;hodnotami s&nbsp;plovoucí řádovou čárkou</a></p>
<p><a href="#k16">16. Porovnání operandů s&nbsp;hodnotami s&nbsp;plovoucí řádovou čárkou</a></p>
<p><a href="#k17">17. SIMD operace</a></p>
<p><a href="#k18">18. Repositář s&nbsp;demonstračními příklady</a></p>
<p><a href="#k19">19. Předchozí články o architektuře AArch64</a></p>
<p><a href="#k20">20. Odkazy na Internetu</a></p>



<p><a name="k01"></a></p>
<h2 id="k01">1. Aritmetické operace s&nbsp;celočíselnými typy i s&nbsp;hodnotami s&nbsp;plovoucí řádovou čárkou</h2>

<p>Nová instrukční sada mikroprocesorů s&nbsp;architekturou <i>AArch64</i>
obsahuje instrukce, které je možné rozdělit do několika oblastí podle toho,
jaká jednotka implementovaná uvnitř mikroprocesoru tyto instrukce skutečně
spouští. Podívejme se na následující tabulku:</p>

<table>
<tr><th>Skupina</th><th>Další dělení</th></tr>
<tr><td>Load-Store</td><td>Load-Store pro jeden registr</td></tr>
<tr><td>&nbsp;</td><td>Load-Store pro dvojici registrů (již jsme si ukázali)</td></tr>
<tr><td>&nbsp;</td><td>Prefetch</td></tr>
<tr><td>&nbsp;</td><td>&nbsp;</td></tr>
<tr><td>Skoky</td><td>Nepodmíněné skoky</td></tr>
<tr><td>&nbsp;</td><td>Nepodmíněný skok na adresu v&nbsp;registru (popsáno)</td></tr>
<tr><td>&nbsp;</td><td>Podmíněné skoky (popsáno)</td></tr>
<tr><td>&nbsp;</td><td>&nbsp;</td></tr>
<tr><td>ALU operace</td><td>Základní aritmetické instrukce</td></tr>
<tr><td>&nbsp;</td><td>Násobení a dělení</td></tr>
<tr><td>&nbsp;</td><td>Logické instrukce</td></tr>
<tr><td>&nbsp;</td><td>Znaménkové rozšíření operandu či rozšíření o nuly</td></tr>
<tr><td>&nbsp;</td><td>Bitové operace</td></tr>
<tr><td>&nbsp;</td><td>Extrakce dat</td></tr>
<tr><td>&nbsp;</td><td>Bitové posuny</td></tr>
<tr><td>&nbsp;</td><td>Aritmetické posuny</td></tr>
<tr><td>&nbsp;</td><td>Podmíněné zpracování dat (popsáno)</td></tr>
<tr><td>&nbsp;</td><td>Podmíněné porovnání</td></tr>
<tr><td>&nbsp;</td><td>&nbsp;</td></tr>
<tr><td>FP operace</td><td>Přenos operandů mezi registry</td></tr>
<tr><td>&nbsp;</td><td>Konverze mezi různými formáty</td></tr>
<tr><td>&nbsp;</td><td>Převod na celá čísla (zaokrouhlení)</td></tr>
<tr><td>&nbsp;</td><td>Základní aritmetické operace</td></tr>
<tr><td>&nbsp;</td><td>Výpočet minima a maxima</td></tr>
<tr><td>&nbsp;</td><td>MAC (Multiply Accumulate)</td></tr>
<tr><td>&nbsp;</td><td>Porovnání operandů</td></tr>
<tr><td>&nbsp;</td><td>Podmíněný výběr operandu</td></tr>
<tr><td>&nbsp;</td><td>&nbsp;</td></tr>
<tr><td>SIMD operace</td><td>Aritmetické operace se skaláry</td></tr>
<tr><td>&nbsp;</td><td>Aritmetické operace s&nbsp;vektory</td></tr>
<tr><td>&nbsp;</td><td>Permutace vektorů</td></tr>
<tr><td>&nbsp;</td><td>Konverze dat</td></tr>
<tr><td>&nbsp;</td><td>Instrukce z&nbsp;crypto extension (patří do SIMD)</td></tr>
<tr><td>&nbsp;</td><td>&nbsp;</td></tr>
<tr><td>Systémové instrukce</td><td>Zpracování výjimek</td></tr>
<tr><td>&nbsp;</td><td>Přístup k&nbsp;systémovým registrům</td></tr>
<tr><td>&nbsp;</td><td>Implementace bariér</td></tr>
<tr><td>&nbsp;</td><td>Instrukce pro jádro systému</td></tr>
</table>

<p>Ve čtvrté části miniseriálu o specifických vlastnostech mikroprocesorů
s&nbsp;architekturou <i>AArch64</i> se budeme zabývat převážně instrukcemi
určenými pro provádění aritmetických operací. Tyto instrukce se jak
z&nbsp;historických tak i technických důvodů rozdělují na instrukce určené pro
celočíselné datové typy (bajt, 16bitové slovo, 32bitové slovo, 64bitové slovo)
a na instrukce, které provádějí operace s&nbsp;hodnotami s&nbsp;plovoucí
řádovou čárkou (tedy ponejvíce s&nbsp;hodnotami <i>single</i> a <i>double</i>,
i když se v&nbsp;této oblasti nově objevil například formát <i>blfoat</i>).
Další dělení je možné podle toho, zda instrukce prování operaci s&nbsp;jedinou
dvojicí operandů, nebo s&nbsp;dvojicí vektorů (ovšem sada registrů zůstává
v&nbsp;tomto případě pořád stejná &ndash; konkrétně se jedná o registry
<strong>V0</strong> až <strong>V31</strong>,).</p>



<p><a name="k02"></a></p>
<h2 id="k02">2. Specifické vlastnosti aritmeticko-logické jednotky</h2>

<p>Kromě toho, že aritmeticko-logická jednotka byla (v&nbsp;porovnání
s&nbsp;původní architekturou ARM neboli dnes A32 a T32) rozšířena pro
zpracování 64bitových operandů u prakticky všech instrukcí, došlo k&nbsp;jejímu
doplnění o vylepšenou násobičku a děličku. Násobička může kromě běžných operací
pro násobení provádět i operace typu <i>MAC</i> (<i>Multiply Accumulate</i>),
které typicky najdeme u DSP. U AArchu64 je zde ovšem jedna podstatná změna
&ndash; namísto akumulátoru se může použít odlišný vstupní a odlišný výstupní
registr, což konkrétně znamená, že DSP operace:</p>

<pre>
acc += op2 &times; op3
</pre>

<p>dokáže AArch64 provést:</p>

<pre>
op1 = op2 &times; op3 + op4
</pre>

<p>Podívejme se nyní, které instrukce provádí násobička a dělička:</p>

<table>
<tr><th>#</th><th>Instrukce</th><th>Stručný popis</th></tr>
<tr><td>1</td><td>MUL</td><td>32bitové či 64bitové násobení</td></tr>
<tr><td>2</td><td>MADD</td><td>výsledek = op2 &times; op3 + op4</td></tr>
<tr><td>3</td><td>MSUB</td><td>výsledek = op4 - op2 &times; op3</td></tr>
<tr><td>4</td><td>MNEG</td><td>výsledek = - op2 &times; op3</td></tr>
<tr><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td></tr>
<tr><td>5</td><td>SMULL</td><td>násobení hodnot se znaménkem (32&times;32 &rarr; 64)</td></tr>
<tr><td>6</td><td>SMADDL</td><td>MADD hodnot se znaménkem pro (32&times;32 &rarr; 64)</td></tr>
<tr><td>7</td><td>SMSUBL</td><td>MSUB hodnot se znaménkem pro (32&times;32 &rarr; 64)</td></tr>
<tr><td>8</td><td>SMNEGL</td><td>MNEG hodnot se znaménkem pro (32&times;32 &rarr; 64)</td></tr>
<tr><td>9</td><td>SMULH</td><td>násobení 64&times;64, z&nbsp;výsledku se vezme jen horních 64 bitů ze 128</td></tr>
<tr><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td></tr>
<tr><td>10</td><td>UMULL</td><td>násobení hodnot bez znaménka (32&times;32 &rarr; 64)</td></tr>
<tr><td>11</td><td>UMADDL</td><td>MADD hodnot bez znaménka pro (32&times;32 &rarr; 64)</td></tr>
<tr><td>12</td><td>UMSUBL</td><td>MSUB hodnot bez znaménka pro (32&times;32 &rarr; 64)</td></tr>
<tr><td>13</td><td>UMNEGL</td><td>MNEG hodnot bez znaménka pro (32&times;32 &rarr; 64)</td></tr>
<tr><td>14</td><td>UMULH</td><td>násobení 64&times;64, z&nbsp;výsledku se vezme jen horních 64 bitů ze 128</td></tr>
<tr><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td></tr>
<tr><td>15</td><td>SDIV</td><td>32bitové či 64bitové dělení hodnot se znaménkem</td></tr>
<tr><td>16</td><td>UDIV</td><td>32bitové či 64bitové dělení hodnot bez znaménka</td></tr>
</table>

<p><div class="rs-tip-major">Poznámka: ve skutečnosti je instrukce
<strong>MUL</strong>, tedy z&nbsp;pohledu programátora &bdquo;běžné
násobení&ldquo; aliasem pro instrukci <strong>MADD</strong>, v&nbsp;níž je
třetím vstupním operandem registr <strong>WZR</strong> či <strong>XZR</strong>,
tedy &bdquo;konstantní nula&ldquo;. Prakticky totéž platí pro instrukci
<strong>MNEG</strong>, která vznikla z&nbsp;instrukce <strong>MSUB</strong>, u
níž je opět posledním vstupním operandem nulový registr.</div></p>

<table>
<tr><th>Operace</th><th>Vstupní operandy</th><th>Výsledek</th></tr>
<tr><td>MUL</td><td>32&times;32 bitů</td><td>32 bitů</td></tr>
<tr><td>MUL</td><td>64&times;64 bitů</td><td>64 bitů</td></tr>
<tr><td>MUL</td><td>32&times;32 bitů</td><td>64 bitů (rozšíření)</td></tr>
<tr><td>MUL</td><td>64&times;64 bitů</td><td>horních 64 bitů (rozšíření)</td></tr>
<tr><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td></tr>
<tr><td>MAC</td><td>32&pm;32&times;32 bitů</td><td>32 bitů</td></tr>
<tr><td>MAC</td><td>64&pm;64&times;64 bitů</td><td>64 bitů</td></tr>
<tr><td>MAC</td><td>64&pm;32&times;32 bitů</td><td>64 bitů (rozšíření)</td></tr>
</table>

<p><div class="rs-tip-major">Poznámka: se všemi výše zmíněnými instrukcemi se
ještě jednou setkáme příště; jejich praktické studium totiž již vyžaduje
znalost práce s&nbsp;debuggerem.</div></p>

<p>V&nbsp;navazujících kapitolách se zaměříme na registry a instrukce určené
pro zpracování numerických hodnot s&nbsp;plovoucí řádovou čárkou.</p>



<p><a name="k03"></a></p>
<h2 id="k03">3. Hodnoty typu <i>single</i> a <i>double</i></h2>

<p>Uložení racionálních čísel ve formátu plovoucí řádové tečky (někdy se taktéž
setkáme s&nbsp;označením &bdquo;FP formát&ldquo;) se od celočíselného formátu
nebo formátu s&nbsp;pevnou řádovou tečkou (v&nbsp;ČR spíše řádovou čárkou)
odlišuje především v&nbsp;tom, že si každá numerická hodnota sama v&nbsp;sobě
nese aktuální polohu řádové tečky (zatímco v&nbsp;případě, že je tečka/čárka
pevně nastavena, je tato informace součástí programu a nikoli hodnoty).
Z&nbsp;tohoto důvodu je kromě bitů, které musí být rezervovány pro uložení
významných číslic numerické hodnoty, nutné pro každou numerickou hodnotu
rezervovat i další bity, v&nbsp;nichž je určena mocnina o nějakém základu
(typicky 2, 8, 10 či 16), kterou musí být významné číslice vynásobeny
resp.&nbsp;vyděleny. První část čísla uloženého v&nbsp;FP formátu se nazývá
<strong>mantisa</strong>, druhá část <strong>exponent</strong> (navíc se ještě
přidává informace o znaménku). Obecný formát uložení a způsob získání původního
čísla je následující:</p>

<p><i>x<sub>FP</sub>=b<sup>e</sup>&times;m</i></p>

<p>přičemž význam jednotlivých symbolů je následující:</p>

<ol>
<li><i>x<sub>FX</sub></i> značí reprezentovanou numerickou hodnotu z&nbsp;podmnožiny reálných čísel</li>
<li><i>b</i> je báze, někdy také nazývaná <i>radix</i></li>
<li><i>e</i> je hodnota exponentu (může být i záporná)</li>
<li><i>m</i> je mantisa, která může být i záporná</li>
</ol>

<p><div class="rs-tip-major">Poznámka: většinou požadujeme i práci se zápornými
hodnotami, proto se zavádí další bit <i>s</i> pro uložení znaménka. To
mj.&nbsp;znamená, že lze reprezentovat kladnou i zápornou nulu, což lze
považovat za výhodu &ndash; je třeba velký rozdíl v&nbsp;tom dělit kladnou
nulou či nulou zápornou.</div></p>

<p>Konkrétní formát numerických hodnot reprezentovaných v&nbsp;systému plovoucí
řádové tečky závisí především na volbě báze (<strong>radixu</strong>) a také na
počtu bitů rezervovaných pro uložení mantisy a exponentu. V&nbsp;minulosti
existovalo značné množství různých formátů plovoucí řádové tečky (vzpomíná si
někdo například na <strong>Turbo Pascal</strong> s&nbsp;jeho šestibajtovým
datovým typem <i>real</i>?), v&nbsp;relativně nedávné minulosti se však
ustálilo použití formátů specifikovaných v&nbsp;normě IEEE 754 (ta sama je
ovšem postupně rozšiřována). Ovšem, jak uvidíme dále, se ukazuje, že původní
formáty definované v&nbsp;IEEE 754 nedostačují všem požadavkům, a to na obou
stranách spektra (někdo požaduje vyšší přesnost/rozsah, jiný zase rychlost
výpočtů a malé paměťové nároky). Proto došlo k&nbsp;rozšíření této normy o nové
formáty a nezávisle na tom i na vývoji formátu <strong>bfloat16</strong>.
Nicméně nás dnes budou v&nbsp;souvislosti s&nbsp;procesory AArch64 zajímat
především formáty s&nbsp;jednoduchou a dvojitou přesností, neboli <i>single
(float)</i> a <i>double</i>.</p>



<p><a name="k04"></a></p>
<h2 id="k04">4. Formát plovoucí řádové binární tečky a norma IEEE 754</h2>

<p>V&nbsp;oblasti FP formátů se dnes nejčastěji setkáme s&nbsp;výše zmíněnou
normou IEEE 754 popř.&nbsp;jejími rozšířenými variantami. Norma IEEE 754 je
velmi užitečná v&nbsp;tom, že specifikuje nejenom vlastní formát uložení
numerických hodnot v&nbsp;systému plovoucí řádové tečky, ale (a to je celkem
neznámá skutečnost) i pravidla implementace operací s&nbsp;těmito hodnotami,
včetně konverzí. Konkrétně je v&nbsp;této normě popsáno:</p>

<ol>
<li>Základní (<i>basic</i>) a rozšířený (<i>extended</i>) formát uložení numerických hodnot.</li>
<li>Způsob provádění základních matematických operací:
    <ul>
    <li>součet</li>
    <li>rozdíl</li>
    <li>součin</li>
    <li>podíl</li>
    <li>zbytek po dělení</li>
    <li>druhá odmocnina</li>
    <li>porovnání</li>
    </ul></li>
<li>Režimy zaokrouhlování.</li>
<li>Způsob práce s&nbsp;takzvanými <i>denormalizovanými</i> hodnotami.</li>
<li>Pravidla konverze mezi celočíselnými formáty (<i>integer</i> bez a se znaménkem) a formáty s&nbsp;plovoucí řádovou čárkou.</li>
<li>Způsob konverze mezi různými formáty s&nbsp;plovoucí řádovou čárkou (<i>single</i> &rarr; <i>double</i> atd.).</li>
<li>Způsob konverze základního formátu s&nbsp;plovoucí řádovou čárkou na řetězec číslic (včetně nekonečen a nečíselných hodnot).</li>
<li>Práce s&nbsp;hodnotami NaN (<i>not a number</i>) a výjimkami, které mohou při výpočtech za určitých předpokladů vzniknout (NaN totiž ve skutečnosti <strong>jsou</strong> čísla :-).</li>
</ol>

<a href="https://www.root.cz/obrazek/305587/"><img src="https://i.iinfo.cz/images/346/fp-number-chaos-2-1-prev.jpg" class="image-305587" alt="&#160;" width="370" height="134" /></a>
<p><i>Obrázek 1: První čip, který používal formát definovaný v&nbsp;IEEE 754
&ndash; Intel 8087.<br />
Zdroj: Wikipedia, Autor: Dirk Oppelt</i></p>

<p>V&nbsp;normě (přesněji řečeno v&nbsp;její rozšířené variantě IEEE 754-2008
resp.&nbsp;její poslední úpravě IEEE 754-2019) nalezneme mj.&nbsp;i tyto FP
formáty:</p>

<table>
<tr><th>Označení</th><th>Šířka (b)</th><th>Báze</th><th>Exponent (b)</th><th>Mantisa (b)</th></tr>
<tr><td>IEEE 754 half</td><td>16</td><td>2</td><td>5</td><td>10+1</td></tr>
<tr><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td></tr>
<tr><td>IEEE 754 single</td><td>32</td><td>2</td><td>8</td><td>23+1</td></tr>
<tr><td>IEEE 754 double</td><td>64</td><td>2</td><td>11</td><td>52+1</td></tr>
<tr><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td></tr>
<tr><td>IEEE 754 double extended</td><td>80</td><td>2</td><td>15</td><td>64</td></tr>
<tr><td>IEEE 754 quadruple</td><td>128</td><td>2</td><td>15</td><td>112+1</td></tr>
<tr><td>IEEE 754 octuple</td><td>256</td><td>2</td><td>19</td><td>236+1</td></tr>
</table>

<img src="http://i.iinfo.cz/images/21/pc157-1.jpg" alt="foobar" width="450" height="448" />
<p><i>Obrázek 2: Mikroprocesory Pentium i všechny další čipy řady 80x86 již
implicitně obsahují plnohodnotný FPU. Zlé jazyky tvrdí, že u první řady Pentií
byl FPU tak rychlý jen proto, že <a
href="https://en.wikipedia.org/wiki/Pentium_FDIV_bug">výsledky pouze
odhadoval</a> :-)</i></p>

<p>Nás však budou v&nbsp;dalším textu zajímat především formáty <i>single</i> a
<i>double</i>.</p>

<p>Typ <i>single</i> (nebo <i>float</i> popř.&nbsp;<i>float32</i>) vypadá
takto:</p>

<table>
<tr><th>bit</th><td>31</td><td>30 &nbsp; 29 ... 24 &nbsp; 23</td><td>22 &nbsp; 21 ... 3 &nbsp; 2 &nbsp; 1 &nbsp; 0</td></tr>
<tr><th>význam</th><td>s</td><td>exponent (8 bitů)</td><td>mantisa (23 bitů)</td></tr>
</table>

<p>Exponent je přitom posunutý o hodnotu <strong>bias</strong>, která je
nastavena na 127, protože je použit výše uvedený vztah:</p>

<p><i>bias=2<sup>eb-1</sup>-1</i></p>

<p>a po dosazení <i>eb=8 (bitů)</i> dostaneme:</p>

<p><i>bias=2<sup>8-1</sup>-1=2<sup>7</sup>-1=128-1=</i><strong>127</strong></p>

<p>Vzorec pro vyjádření reálné hodnoty vypadá následovně:</p>

<p><i>X<sub>single</sub>=(-1)<sup>s</sup>&nbsp;&times;&nbsp;2<sup>exp-127</sup>&nbsp;&times;&nbsp;m</i></p>

<p>Rozsah hodnot, které je možné reprezentovat ve formátu jednoduché přesnosti
v&nbsp;normalizovaném tvaru je -3,4&times;10<sup>38</sup> až
3,4&times;10<sup>38</sup>. Nejnižší reprezentovatelná (normalizovaná) hodnota
je rovna 1,17549&times;10<sup>-38</sup>, denormalizovaná pak
1,40129&times;10<sup>-45</sup>. Jak jsme k&nbsp;těmto hodnotám došli? Zkuste se
podívat na následující vztahy:</p>

<table>
<tr><th>hexadecimální hodnota</th><th>výpočet FP</th><th>dekadický výsledek</th><th>normalizováno</th></tr>
<tr><td>0x00000001</td><td>2<sup>-126</sup>&times;2<sup>-23</sup></td><td>1,40129&times;10<sup>-45</sup></td><td>ne</td></tr>
<tr><td>0x00800000</td><td>2<sup>-126</sup></td><td>1,17549&times;10<sup>-38</sup></td><td>ano</td></tr>
<tr><td>0x7F7FFFFF</td><td>(2-2<sup>-23</sup>)&times;2<sup>127</sup></td><td>3,4&times;10<sup>38</sup></td><td>ano</td></tr>
</table>

<p>Formát s&nbsp;dvojitou přesností (<strong>double</strong>), který je
definovaný taktéž normou IEEE 754, se v&nbsp;mnoha ohledech podobá formátu
s&nbsp;jednoduchou přesností (<strong>single</strong>), pouze se zdvojnásobil
celkový počet bitů, ve kterých je hodnota uložena, tj.&nbsp;místo 32 bitů se
používá plných 64 bitů:</p>

<table>
<tr><th>bit</th><td>63</td><td>62 ... 52</td><td>51 ... 0</td></tr>
<tr><th>význam</th><td>s</td><td>exponent (11 bitů)</td><td>mantisa (52 bitů)</td></tr>
</table>

<p>Exponent je v&nbsp;tomto případě posunutý o hodnotu
<strong>bias=2047</strong> a vzorec pro výpočet reálné hodnoty vypadá
takto:</p>

<p><i>X<sub>double</sub>=(-1)<sup>s</sup>&nbsp;&times;&nbsp;2<sup>exp-2047</sup>&nbsp;&times;&nbsp;m</i></p>

<p>Přičemž hodnotu mantisy je možné pro normalizované hodnoty získat pomocí
vztahu:</p>

<p><i>m=1+m<sub>51</sub><sup>-1</sup>+m<sub>50</sub><sup>-2</sup>+m<sub>49</sub><sup>-3</sup>+...+m<sub>0</sub><sup>-52</sup></i></p>

<p>(<i>m<sub>x</sub></i> představuje <i>x</i>-tý bit mantisy)</p>

<p>Rozsah hodnot ukládaných ve dvojité přesnosti je
-1,7&times;10<sup>308</sup>..1,7&times;10<sup>308</sup>, nejmenší možná
nenulová hodnota je rovna 2,2&times;10<sup>-308</sup>.</p>

<p>V&nbsp;novější normě IEEE 754-2008 je specifikován nepovinný formát nazvaný
<i>binary128</i>, který se ovšem běžně označuje <i>quadruple precision</i> či
jen <i>quad precision</i>. Tento formát je založen na slovech širokých 128 bitů
(16 bajtů), která jsou rozdělena takto:</p>

<table>
<tr><th>bit</th><td>127</td><td>126 ... 112</td><td>111 ... 0</td></tr>
<tr><th>význam</th><td>s</td><td>exponent (15 bitů)</td><td>mantisa (112 bitů)</td></tr>
</table>

<p>Exponent je v&nbsp;tomto případě posunutý o hodnotu
<strong>bias=16383</strong>. Dekadická přesnost u tohoto formátu dosahuje 34
cifer!</p>

<p>Jen krátce se zmiňme o poslední variantě FP formátu, který se nazývá
<i>binary256</i> či méně formálně <i>octuple precision</i>. Tento formát
využívá slova o šířce plných 256 bitů (32 bajtů) s&nbsp;následujícím
rozdělením:</p>

<table>
<tr><th>bit</th><td>255</td><td>254 ... 236</td><td>235 ... 0</td></tr>
<tr><th>význam</th><td>s</td><td>exponent (19 bitů)</td><td>mantisa (235 bitů)</td></tr>
</table>

<p>Exponent je v&nbsp;tomto případě posunutý o hodnotu
<strong>bias=262143</strong>. Dekadická přesnost u tohoto formátu dosahuje 71
cifer, nejmenší (nenormalizovaná) reprezentovatelná hodnota rozdílná od nuly je
přibližně 10<sup>−78984</sup>, maximální hodnota pak 1.611
&times;10<sup>78913</sup> (těžko říct, zda je takový rozsah vůbec reálně
využitelný).</p>



<p><a name="k05"></a></p>
<h2 id="k05">5. Operace s&nbsp;hodnotami typu <i>single</i> a <i>double</i></h2>

<p>Matematický koprocesor je sice u architektury AArch64 volitelný (u
desktopových procesorů ho najdete vždy), ale oproti 32bitovým ARMům došlo
k&nbsp;určitému zjednodušení &ndash; už neexistuje rozdělení ABI na soft
floating point a hard floating point, protože pro předávání hodnot typu
<i>single/float</i> a <i>double</i> jsou vždy použity FP registry popsané <a
href="#k06">v&nbsp;navazující kapitole</a>. Z&nbsp;technologického hlediska
sice není soft floating point špatné řešení, ale prakticky způsobovalo (a
dodnes způsobuje) množství problémů při distribuci knihoven i aplikací.</p>

<p>Samostatná sada pracovních registrů je používána při operacích s&nbsp;typy
<i>single/float</i> a <i>double</i> (tedy s&nbsp;operandy reprezentovanými
v&nbsp;systému plovoucí řádové čárky), u SIMD operací a taktéž kryptografickým
modulem:</p>

<table>
<tr><th>Jméno</th><th>Význam</th></tr>
<tr><td>v0..v31</td><td>128bitové registry</td></tr>
<tr><td>d0..d31</td><td>spodních 64 bitů registrů v0..v31, použito pro hodnoty typu <i>double</i></td></tr>
<tr><td>s0..s31</td><td>spodních 32 bitů registrů v0..v31, použito pro hodnoty typu <i>single/float</i></td></tr>
</table>

<p>Pro SIMD operace, tj.&nbsp;operace pracující s&nbsp;vektory, se výše uvedené
registry <strong>Vn</strong> rozdělují následujícím způsobem:</p>

<table>
<tr><th>Tvar (shape)</th><th>Celkem</th><th>Pojmenování v&nbsp;assembleru</th></tr>
<tr><td>8b&times;8</td><td>64b</td><td>Vn.8B</td></tr>
<tr><td>8b&times;16</td><td>128b</td><td>Vn.16B</td></tr>
<tr><td>16b&times;4</td><td>64b</td><td>Vn.4H</td></tr>
<tr><td>16b&times;8</td><td>128b</td><td>Vn.8H</td></tr>
<tr><td>32b&times;2</td><td>64b</td><td>Vn.2S</td></tr>
<tr><td>32b&times;4</td><td>128b</td><td>Vn.4S</td></tr>
<tr><td>64b&times;1</td><td>64b</td><td>Vn.1D</td></tr>
<tr><td>64b&times;2</td><td>128b</td><td>Vn.2D</td></tr>
</table>

<p><div class="rs-tip-major">Poznámka: Povšimněte si, že &ndash; na rozdíl od
mnoha jiných architektur &ndash; nedochází k&nbsp;tomu, že by se například dva
single registry mapovaly do jednoho double registru atd.</div></p>

<p><div class="rs-tip-major">Poznámka<sup>2</sup>: většina instrukcí známých ze
sady VFP (ARM32) byla přejmenována, ovšem prakticky každá z&nbsp;původních
instrukcí má svůj nový ekvivalent. Jen pro upřesnění si vypišme některé původní
instrukce VFP:</div></p>

<p>Aritmetické operace:</p>

<table>
<tr><th>#</th><th>Instrukce</th><th>Význam</th><th>Prováděný výpočet</th></tr>
<tr><td> 1</td><td>VADD  Fd, Fn, Fm</td><td>součet</td><td>Fd := Fn + Fm</td></tr>
<tr><td> 2</td><td>VSUB  Fd, Fn, Fm</td><td>rozdíl</td><td>Fd := Fn - Fm</td></tr>
<tr><td> 3</td><td>VNEG  Fd, Fm</td><td>změna znaménka</td><td>Fd := - Fm</td></tr>
<tr><td> 4</td><td>VABS  Fd, Fm</td><td>absolutní hodnota</td><td>Fd := abs(Fm)</td></tr>
<tr><td> 5</td><td>VSQRT Fd, Fm</td><td>druhá odmocnina</td><td>Fd := sqrt(Fm)</td></tr>
<tr><td> 6</td><td>VDIV  Fd, Fn, Fm</td><td>dělení</td><td>Fd := Fn / Fm</td></tr>
<tr><td> 7</td><td>VMUL  Fd, Fn, Fm</td><td>násobení</td><td>Fd := Fn * Fm</td></tr>
<tr><td> 8</td><td>VMLA  Fd, Fn, Fm</td><td>násobení + akumulace</td><td>Fd := Fd + (Fn * Fm)</td></tr>
<tr><td> 9</td><td>VMLS  Fd, Fn, Fm</td><td>odečtení součinu</td><td>Fd := Fd - (Fn * Fm)</td></tr>
<tr><td>10</td><td>VNMUL Fd, Fn, Fm</td><td>násobení + změna znaménka</td><td>Fn := - (Fn * Fm)</td></tr>
<tr><td>11</td><td>VNMLA Fd, Fn, Fm</td><td>kombinace VNMUL a VMLA</td><td>Fd := - Fd - (Fn * Fm)</td></tr>
<tr><td>12</td><td>VNMLS Fd, Fn, Fm</td><td>kombinace VNMUL a VMLS</td><td>Fd := - Fd + (Fn * Fm)</td></tr>
</table>

<p>Porovnání:</p>

<table>
<tr><th>#</th><th>Instrukce</th><th>Význam</th><th>Prováděný výpočet</th></tr>
<tr><td>1</td><td>VCMP Fd, Fm</td><td>Porovnání obsahu dvou registrů</td><td>Fd - Fm</td></tr>
<tr><td>2</td><td>VCMP Fd, #0.0</td><td>Porovnání jednoho registru s nulou</td><td>Fd - 0.0</td></tr>
</table>

<p>Přesuny dat:</p>

<table>
<tr><th>#</th><th>Instrukce</th><th>Význam</th></tr>
<tr><td> 1</td><td>VCVT{C}.F64.F32 Dd, Sm</td><td>Konverze single na double</td></tr>
<tr><td> 2</td><td>VCVT{C}.F32.F64 Sd, Dm</td><td>Konverze double na single</td></tr>
<tr><td> 3</td><td>VCVT{C}.F32/F64.U32 Fd, Sm</td><td>Konverze unsigned integer na float</td></tr>
<tr><td> 4</td><td>VCVT{C}.F32/F64.S32 Fd, Sm</td><td>Konverze signed integer na float</td></tr>
<tr><td> 5</td><td>VCVT{R}{C}.U32.F32/F64 Sd, Fm</td><td>Konverze float na unsigned integer</td></tr>
<tr><td> 6</td><td>VCVT{R}{C}.S32.F32/F64 Sd, Fm</td><td>Konverze float na signed integer</td></tr>
<tr><td> 7</td><td>VCVT.F32/F64.typ Fd, Fd, #bitů</td><td>Konverze fixed-point na float (volitelná pozice tečky)</td></tr>
<tr><td> 8</td><td>VCVT.typ.F32/F64 Fd, Fd, #bitů</td><td>Konverze float na fixed-point (volitelná pozice tečky)</td></tr>
<tr><td> 9</td><td>VCVTT.F16.F32 Sd,Sm</td><td>Konverze single na half (do horních 16 bitů registru)</td></tr>
<tr><td>10</td><td>VCVTB.F16.F32 Sd,Sm</td><td>Konverze single na half (do spodních 16 bitů registru)</td></tr>
<tr><td>11</td><td>VCVTT.F32.F16 Sd,Sm</td><td>Konverze half na single</td></tr>
<tr><td>12</td><td>VCVTB.F32.F16 Sd,Sm</td><td>Konverze half na single</td></tr>
<tr><td>13</td><td>VMOV.F32/F64 Fd, Fm</td><td>Fd := Fm (prostá kopie)</td></tr>
<tr><td>14</td><td>VMOV Sn, Rd</td><td>Sn := Rd (Rd = registr ARM procesoru)</td></tr>
<tr><td>15</td><td>VMOV Rd, Sn</td><td>Rd := Sn (Rd = registr ARM procesoru)</td></tr>
<tr><td>16</td><td>VMOV Sn, Sm, Rd, Rn</td><td>Sn := Rd, Sm := Rn (kopie dvou registrů)</td></tr>
<tr><td>17</td><td>VMOV Rd, Rn, Sn, Sm</td><td>Rd := Sn, Rn := Sm (kopie dvou registrů)</td></tr>
<tr><td>18</td><td>VMOV Dm, Rd, Rn</td><td>Dm[31:0] := Rd, Dm[63:32] := Rn (pro double jsou zapotřebí dva ARM registry)</td></tr>
<tr><td>19</td><td>VMOV Rd, Rn, Dm</td><td>Rd := Dm[31:0], Rn := Dm[63:32]  (pro double jsou zapotřebí dva ARM registry)</td></tr>
<tr><td>20</td><td>VMOV Dn[0], Rd</td><td>Dn[31:0] := Rd  (pouze spodní polovina double)</td></tr>
<tr><td>21</td><td>VMOV Rd, Dn[0]</td><td>Rd := Dn[31:0]  (pouze spodní polovina double)</td></tr>
<tr><td>22</td><td>VMOV Dn[1], Rd</td><td>Dn[63:32] := Rd  (pouze horní polovina double)</td></tr>
<tr><td>23</td><td>VMOV Rd, Dn[1]</td><td>Rd := Dn[63:32]  (pouze horní polovina double)</td></tr>
<tr><td>24</td><td>VMRS APSR_nzcv, FPSCR</td><td>APSR flags := FPSCR flags (přenos příznaků)</td></tr>
</table>



<p><a name="k06"></a></p>
<h2 id="k06">6. Základní operace s&nbsp;FP hodnotami &ndash; načtení konstanty do FP registru</h2>

<p>Pro načtení konstanty typu <i>single/float</i> a <i>double</i> do jednoho
z&nbsp;pracovních registrů <strong>Sx</strong> či <strong>Dx</strong> se
používá instrukce nazvaná <strong>FMOV</strong>. Ovšem vzhledem k&nbsp;tomu, že
jak instrukční slovo, tak i konstanta mají dohromady pouhých 32 bitů (jako
všechny ostatní RISCové instrukce), je zřejmé, že tímto způsobem není možné
načíst libovolné číslo, ale pouze hodnotu odpovídající určitým pravidlům.
Reprezentovatelná hodnota odpovídá výrazu &pm;n&div;16&times;2<sup>r</sup>, kde
<i>n</i> je celé číslo 16 &le; n &le; 31 a <i>r</i> je taktéž celé číslo -3
&le; r &le; 4. Tato čísla jsou reprezentována čtyřmi resp.&nbsp;třemi bity,
další bit slouží pro uložení znaménka v&nbsp;instrukčním slovu (k&nbsp;tomuto
omezení se ještě vrátíme):</p>

<table>
<tr><th>#</th><th>Instrukce</th><th>Stručný popis</th></tr>
<tr><td>1</td><td>FMOV Sd, #fpimm</td><td>načtení konstanty typu <i>single/float</i> do registru <strong>Sx</strong></td></tr>
<tr><td>2</td><td>FMOV Dd, #fpimm</td><td>načtení konstanty typu <i>double</i> do registru <strong>Dx</strong></td></tr>
</table>

<p>Speciálním případem je načtení nuly, které se provede jednoduše &ndash;
použitím registrů <strong>XZR</strong> či <strong>WZR</strong>, které obsahují
nulu a konstanta nula (0,0) je ve formátu IEEE 754 taktéž reprezentována samými
nulovými bity (což je jedna z&nbsp;mnoha vychytávek IEEE 754).</p>

<p>Následující úryvek céčkového kódu:</p>

<pre>
float  x = 0.0;
double y = 0.0;
</pre>

<p>se přeloží následovně (jedná se o lokální proměnné ukládané na zásobníkový
rámec, tedy relativně vůči <strong>SP</strong>):</p>

<pre>
<i>// float x = 0.0</i>
str  wzr, [sp, 28]
&nbsp;
<i>// double y = 0.0</i>
str  xzr, [sp, 16]
</pre>

<p>Další instrukce slouží pro načtení operandu z&nbsp;paměti a pro uložení
operandů zpět do paměti. Tyto instrukce již známe, pouze došlo k&nbsp;jejich
rozšíření i pro použití s&nbsp;FP registry. Operace s&nbsp;jednotlivými bajty
se používají u vektorových operací. Samozřejmě nesmíme zapomenout ani na
instrukce pro načtení a uložení registrového páru:</p>

<table>
<tr><th>#</th><th>Instrukce</th><th>Stručný popis</th></tr>
<tr><td>1</td><td>LDR Bt, adresa</td><td>načtení spodních osmi bitů</td></tr>
<tr><td>2</td><td>LDR Ht, adresa</td><td>načtení spodních šestnácti bitů</td></tr>
<tr><td>3</td><td>LDR St, adresa</td><td>načtení 32 bitů (<i>float</i>)</td></tr>
<tr><td>4</td><td>LDR Dt, adresa</td><td>načtení 64 bitů (<i>double</i>)</td></tr>
<tr><td>5</td><td>LDR Qt, adresa</td><td>načtení 128 bitů (<i>quad</i>)</td></tr>
<tr><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td></tr>
<tr><td>6</td><td>STR Bt, adresa</td><td>uložení spodních osmi bitů</td></tr>
<tr><td>7</td><td>STR Ht, adresa</td><td>uložení spodních šestnácti bitů</td></tr>
<tr><td>8</td><td>STR St, adresa</td><td>uložení 32 bitů (<i>float</i>)</td></tr>
<tr><td>9</td><td>STR Dt, adresa</td><td>uložení 64 bitů (<i>double</i>)</td></tr>
<tr><td>10</td><td>STR Qt, adresa</td><td>uložení 128 bitů (<i>quad</i>)</td></tr>
<tr><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td></tr>
<tr><td>11</td><td>LDP S1, S2, adresa</td><td>načtení registrového páru (<i>single</i>)</td></tr>
<tr><td>12</td><td>LDP D1, D2, adresa</td><td>načtení registrového páru (<i>double</i>)</td></tr>
<tr><td>13</td><td>LDP Q1, Q2, adresa</td><td>načtení registrového páru (<i>quad</i>)</td></tr>
<tr><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td></tr>
<tr><td>14</td><td>STP S1, S2, adresa</td><td>uložení registrového páru (<i>single</i>)</td></tr>
<tr><td>15</td><td>STP D1, D2, adresa</td><td>uložení registrového páru (<i>double</i>)</td></tr>
<tr><td>16</td><td>STP Q1, Q2, adresa</td><td>uložení registrového páru (<i>quad</i>)</td></tr>
</table>

<p>Podívejme se opět na jednoduchý příklad využití těchto instrukcí
v&nbsp;praxi. Následující fragment céčkového kódu s&nbsp;inicializací čtyř
lokálních proměnných:</p>

<pre>
float  x = 1.0;
float  y = 10.0;
float  z = 100.0;
float  w = 1000.0;
</pre>

<p>se přeloží takto:</p>

<pre>
<i>// float  x = 1.0;</i>
fmov    s0, 1.0e+0
str     s0, [sp, 12]
&nbsp;
<i>// float  y = 10.0;</i>
fmov    s0, 1.0e+1
str     s0, [sp, 8]
&nbsp;
<i>// float  z = 100.0;</i>
adrp    x0, .LC0
add     x0, x0, :lo12:.LC0
ldr     s0, [x0]
str     s0, [sp, 4]
&nbsp;
<i>// float  w = 1000.0;</i>
adrp    x0, .LC1
add     x0, x0, :lo12:.LC1
ldr     s0, [x0]
str     s0, [sp]
</pre>

<p>První proměnné lze načíst přímo instrukcí <strong>FMOV</strong> (konstanta
je součástí instrukce), další pouze nepřímo z&nbsp;operační paměti.</p>

<p>Konstanty uložené v&nbsp;operační paměti:</p>

<pre>
.LC0:
        .word   1120403456
.LC1:
        .word   1148846080
</pre>



<p><a name="k07"></a></p>
<h2 id="k07">7. Praktický příklad &ndash; načtení konstant do registrů <strong>D1</strong> a <strong>S1</strong></h2>

<p>Použití instrukcí <strong>FMOV</strong> pro načtení konstanty je snadné
v&nbsp;případě, že je konstantu možné uložit přímo do instrukčního slova.
Nejdříve načteme konstantu 1.0 do registru <strong>D1</strong> (typu
<i>double</i>):</p>

<pre>
<i># asmsyntax=as</i>
&nbsp;
<i># Načtení FP konstanty do registru d1</i>
<i># v assembleru GNU AS pro architekturu AArch64.</i>
<i>#</i>
<i># Autor: Pavel Tišnovský</i>
&nbsp;
&nbsp;
&nbsp;
<i># Linux kernel system call table</i>
sys_exit=93
&nbsp;
<i># List of syscalls for AArch64:</i>
<i># https://github.com/torvalds/linux/blob/master/include/uapi/asm-generic/unistd.h</i>
&nbsp;
&nbsp;
&nbsp;
<i>#-----------------------------------------------------------------------------</i>
.section .data
&nbsp;
&nbsp;
&nbsp;
<i>#-----------------------------------------------------------------------------</i>
.section .bss
&nbsp;
&nbsp;
&nbsp;
<i>#-----------------------------------------------------------------------------</i>
.section .text
        .global _start          <i>// tento symbol má být dostupný i z linkeru</i>
&nbsp;
_start:
        <strong>fmov d1, #1.00</strong>          <i>// načtení konstanty do registru</i>
&nbsp;
        mov  x8, #sys_exit      <i>// číslo sycallu pro funkci "exit"</i>
        mov  x0, #0             <i>// exit code = 0</i>
        svc  0                  <i>// volání Linuxového kernelu</i>
</pre>

<p>Obsah výsledného binárního souboru po překladu a slinkování:</p>

<pre>
<strong>$ objdump -d a.out</strong>
&nbsp;
a.out:     file format elf64-littleaarch64
&nbsp;
&nbsp;
Disassembly of section .text:
&nbsp;
0000000000400078 &lt;_start&gt;:
  400078:       1e6e1001        fmov    d1, #1.000000000000000000e+00
  40007c:       d2800ba8        mov     x8, #0x5d                       <i>// #93</i>
  400080:       d2800000        mov     x0, #0x0                        <i>// #0</i>
  400084:       d4000001        svc     #0x0
</pre>

<p>Podobný příklad, ovšem pro registr <strong>S1</strong> a tudíž konstantu
typu <i>single</i>:</p>

<pre>
<i># asmsyntax=as</i>
&nbsp;
<i># Načtení FP konstanty do registru s1</i>
<i># v assembleru GNU AS pro architekturu AArch64.</i>
<i>#</i>
<i># Autor: Pavel Tišnovský</i>
&nbsp;
&nbsp;
&nbsp;
<i># Linux kernel system call table</i>
sys_exit=93
&nbsp;
<i># List of syscalls for AArch64:</i>
<i># https://github.com/torvalds/linux/blob/master/include/uapi/asm-generic/unistd.h</i>
&nbsp;
&nbsp;
&nbsp;
<i>#-----------------------------------------------------------------------------</i>
.section .data
&nbsp;
&nbsp;
&nbsp;
<i>#-----------------------------------------------------------------------------</i>
.section .bss
&nbsp;
&nbsp;
&nbsp;
<i>#-----------------------------------------------------------------------------</i>
.section .text
        .global _start          <i>// tento symbol má být dostupný i z linkeru</i>
&nbsp;
_start:
        <strong>fmov s1, #1.00</strong>          <i>// načtení konstanty do registru</i>
&nbsp;
        mov  x8, #sys_exit      <i>// číslo sycallu pro funkci "exit"</i>
        mov  x0, #0             <i>// exit code = 0</i>
        svc  0                  <i>// volání Linuxového kernelu</i>

</pre>

<p>Obsah výsledného binárního souboru po překladu a slinkování je nyní poněkud
odlišný:</p>

<pre>
<strong>$ objdump -d a.out</strong>
&nbsp;
a.out:     file format elf64-littleaarch64
&nbsp;
&nbsp;
Disassembly of section .text:
&nbsp;
0000000000400078 &lt;_start&gt;:
  400078:       1e2e1001        fmov    s1, #1.000000000000000000e+00
  40007c:       d2800ba8        mov     x8, #0x5d                       <i>// #93</i>
  400080:       d2800000        mov     x0, #0x0                        <i>// #0</i>
  400084:       d4000001        svc     #0x0
</pre>



<p><a name="k08"></a></p>
<h2 id="k08">8. Nepodporované konstanty aneb (logické) omezení možností RISCových instrukcí</h2>

<p>Některé konstanty (přesněji řečeno jejich naprostou většinu) není možné
uložit do instrukčního slova instrukce <strong>FMOV</strong>, o čemž se můžeme
velmi snadno přesvědčit:</p>

<pre>
.section .text
        .global _start          <i>// tento symbol má být dostupný i z linkeru</i>
&nbsp;
_start:
        <strong>fmov s1, #0.00</strong>          <i>// načtení konstanty do registru</i>
&nbsp;
        mov  x8, #sys_exit      <i>// číslo sycallu pro funkci "exit"</i>
        mov  x0, #0             <i>// exit code = 0</i>
        svc  0                  <i>// volání Linuxového kernelu</i>
</pre>


<pre>
fmov3.s: Assembler messages:
fmov3.s:33: Error: invalid floating-point constant at operand 2 -- `fmov s1,#0.00'
</pre>



<p><a name="k09"></a></p>
<h2 id="k09">9. Vynulování registrů <strong>Dx</strong> a <strong>Sx</strong></h2>

<p><a href="#k06">V&nbsp;šesté kapitole</a> jsme si řekli, že vynulování
registrů <strong>Dx</strong> či <strong>Sx</strong> dosáhneme přesunem nulové
hodnoty z&nbsp;registru <strong>XZR</strong> resp.&nbsp;<strong>WZR</strong>.
Nejdříve si ukažme vynulování registru <strong>S1</strong>, tedy typu
<i>single</i>:</p>

<pre>
<i># asmsyntax=as</i>
&nbsp;
<i># Načtení FP konstanty do registru s1</i>
<i># v assembleru GNU AS pro architekturu AArch64.</i>
<i>#</i>
<i># Autor: Pavel Tišnovský</i>
&nbsp;
&nbsp;
&nbsp;
<i># Linux kernel system call table</i>
sys_exit=93
&nbsp;
<i># List of syscalls for AArch64:</i>
<i># https://github.com/torvalds/linux/blob/master/include/uapi/asm-generic/unistd.h</i>
&nbsp;
&nbsp;
&nbsp;
<i>#-----------------------------------------------------------------------------</i>
.section .data
&nbsp;
&nbsp;
&nbsp;
<i>#-----------------------------------------------------------------------------</i>
.section .bss
&nbsp;
&nbsp;
&nbsp;
<i>#-----------------------------------------------------------------------------</i>
.section .text
        .global _start          <i>// tento symbol má být dostupný i z linkeru</i>
&nbsp;
_start:
        <strong>fmov s1, wzr</strong>            <i>// načtení konstanty do registru</i>
&nbsp;
        mov  x8, #sys_exit      <i>// číslo sycallu pro funkci "exit"</i>
        mov  x0, #0             <i>// exit code = 0</i>
        svc  0                  <i>// volání Linuxového kernelu</i>
</pre>

<p>Způsob překladu:</p>

<pre>
$ <strong>objdump -d a.out</strong>
&nbsp;
a.out:     file format elf64-littleaarch64
&nbsp;
&nbsp;
Disassembly of section .text:
&nbsp;
0000000000400078 &lt;_start&gt;:
  400078:       1e2703e1        fmov    s1, wzr
  40007c:       d2800ba8        mov     x8, #0x5d                       <i>// #93</i>
  400080:       d2800000        mov     x0, #0x0                        <i>// #0</i>
  400084:       d4000001        svc     #0x0
</pre>

<p>A vynulování registru <strong>D1</strong>, tedy typu <i>double</i>:</p>

<pre>
<i># asmsyntax=as</i>
&nbsp;
<i># Načtení FP konstanty do registru d1</i>
<i># v assembleru GNU AS pro architekturu AArch64.</i>
<i>#</i>
<i># Autor: Pavel Tišnovský</i>
&nbsp;
&nbsp;
&nbsp;
<i># Linux kernel system call table</i>
sys_exit=93
&nbsp;
<i># List of syscalls for AArch64:</i>
<i># https://github.com/torvalds/linux/blob/master/include/uapi/asm-generic/unistd.h</i>
&nbsp;
&nbsp;
&nbsp;
<i>#-----------------------------------------------------------------------------</i>
.section .data
&nbsp;
&nbsp;
&nbsp;
<i>#-----------------------------------------------------------------------------</i>
.section .bss
&nbsp;
&nbsp;
&nbsp;
<i>#-----------------------------------------------------------------------------</i>
.section .text
        .global _start          <i>// tento symbol má být dostupný i z linkeru</i>
&nbsp;
_start:
        <strong>fmov d1, xzr</strong>            <i>// načtení konstanty do registru</i>
&nbsp;
        mov  x8, #sys_exit      <i>// číslo sycallu pro funkci "exit"</i>
        mov  x0, #0             <i>// exit code = 0</i>
        svc  0                  <i>// volání Linuxového kernelu</i>
</pre>

<p>A způsob překladu do objektového kódu:</p>

<pre>
$ <strong>objdump -d a.out</strong>
&nbsp;
a.out:     file format elf64-littleaarch64
&nbsp;
&nbsp;
Disassembly of section .text:
&nbsp;
0000000000400078 &lt;_start&gt;:
  400078:       9e6703e1        fmov    d1, xzr
  40007c:       d2800ba8        mov     x8, #0x5d                       <i>// #93</i>
  400080:       d2800000        mov     x0, #0x0                        <i>// #0</i>
  400084:       d4000001        svc     #0x0
</pre>



<p><a name="k10"></a></p>
<h2 id="k10">10. Nepřímé načtení konstant s&nbsp;libovolnou hodnotou do registrů <strong>Dx</strong> a <strong>Sx</strong></h2>

<p>Konstanty, které nelze zakódovat do instrukčního slova instrukce
<strong>FMOV</strong>, se většinou celé (32 bitů či 64 bitů) ukládají do paměti
a načítají instrukcí <strong>LDR</strong>. Jediný problém spočívá v&nbsp;tom,
že assembler (resp.&nbsp;GNU Assembler) nedokáže rozpoznat konstanty typu
<i>single</i> či <i>double</i>, takže je nutné hodnotu nejdříve získat konverzí
do decimálního či hexadecimálního tvaru. K&nbsp;tomuto účelu lze použít
aplikaci dostupnou na adrese <a
href="https://baseconvert.com/ieee-754-floating-point">https://baseconvert.com/ieee-754-floating-point</a>.</p>

<p>Konkrétně může načtení 64bitové konstanty do registru <strong>D1</strong>
vypadat takto:</p>

<pre>
ldr  d1, =0x3FF0000000000000 <i>// načtení konstanty do registru</i>
</pre>

<p>Následuje příklad použití:</p>

<pre>
<i># asmsyntax=as</i>
&nbsp;
<i># Načtení FP konstanty do registru d1</i>
<i># v assembleru GNU AS pro architekturu AArch64.</i>
<i>#</i>
<i># Autor: Pavel Tišnovský</i>
&nbsp;
&nbsp;
&nbsp;
<i># Linux kernel system call table</i>
sys_exit=93
&nbsp;
<i># List of syscalls for AArch64:</i>
<i># https://github.com/torvalds/linux/blob/master/include/uapi/asm-generic/unistd.h</i>
&nbsp;
&nbsp;
&nbsp;
<i>#-----------------------------------------------------------------------------</i>
.section .data
&nbsp;
&nbsp;
&nbsp;
<i>#-----------------------------------------------------------------------------</i>
.section .bss
&nbsp;
&nbsp;
&nbsp;
<i>#-----------------------------------------------------------------------------</i>
.section .text
        .global _start          <i>// tento symbol má být dostupný i z linkeru</i>
&nbsp;
_start:
        <strong>ldr  d1, =0x3FF0000000000000</strong> <i>// načtení konstanty do registru</i>
&nbsp;
&nbsp;
        mov  x8, #sys_exit      <i>// číslo sycallu pro funkci "exit"</i>
        mov  x0, #0             <i>// exit code = 0</i>
        svc  0                  <i>// volání Linuxového kernelu</i>
</pre>

<p>Způsob překladu do strojového kódu je v&nbsp;tomto případě velmi zajímavý,
protože samotná konstanta je uložena za samotným kódem a je načtena
s&nbsp;využitím &bdquo;krátké&ldquo; adresy uložené přímo v&nbsp;instrukčním
slovu instrukce <strong>ldr</strong>:</p>

<pre>
$ <strong>objdump -d a.out</strong>
&nbsp;
a.out:     file format elf64-littleaarch64
&nbsp;
&nbsp;
Disassembly of section .text:
&nbsp;
0000000000400078 &lt;_start&gt;:
  400078:       5c000081        ldr     d1, 400088 &lt;_start+0x10&gt;
  40007c:       d2800ba8        mov     x8, #0x5d                       <i>// #93</i>
  400080:       d2800000        mov     x0, #0x0                        <i>// #0</i>
  400084:       d4000001        svc     #0x0
  400088:       4048f5c3        .word   0x4048f5c3
  40008c:       00000000        .word   0x00000000
</pre>



<p><a name="k11"></a></p>
<h2 id="k11">11. Přenos operandů mezi registry</h2>

<p>Další skupina instrukcí mikroprocesorů s&nbsp;architekturou AArch64 sice
taktéž používá mnemotechnickou zkratku <strong>FMOV</strong>, ovšem neslouží
k&nbsp;načtení konstanty, ale k&nbsp;přenosu operandu (tedy konkrétní hodnoty)
mezi různými registry. Zajímavé je, že je možné přenášet operandy mezi
celočíselnými registry a FP registry; v&nbsp;takovém případě se přenese přesný
bitový obraz uloženého čísla a neprovádí se žádné konverze (zaokrouhlení atd.).
Poslední dvě instrukce jsou užitečné pro přenos 64 bitů do nebo naopak ze 128
bitového registru <strong>Vd</strong>:</p>

<table>
<tr><th>#</th><th>Instrukce</th><th>Stručný popis</th></tr>
<tr><td>1</td><td>FMOV Sd, Sn</td><td>přenos mezi registry (oba typu <i>single</i>)</td></tr>
<tr><td>2</td><td>FMOV Wd, Sn</td><td>přenos mezi registry (32bitový <i>integer</i>, <i>single</i>)</td></tr>
<tr><td>3</td><td>FMOV Sd, Wn</td><td>přenos mezi registry (32bitový <i>integer</i>, <i>single</i>)</td></tr>
<tr><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td></tr>
<tr><td>4</td><td>FMOV Dd, Dn</td><td>přenos mezi registry (oba typu <i>double</i>)</td></tr>
<tr><td>5</td><td>FMOV Xd, Dn</td><td>přenos mezi registry (64bitový <i>integer</i>, <i>double</i>)</td></tr>
<tr><td>6</td><td>FMOV Dd, Xn</td><td>přenos mezi registry (64bitový <i>integer</i>, <i>double</i>)</td></tr>
<tr><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td></tr>
<tr><td>7</td><td>FMOV Xd, Vn.D[1]</td><td>přenos 64 bitů Vn&lt;127:64&gt; &rarr; Xd</td></tr>
<tr><td>8</td><td>FMOV Vd.D[1], Xn</td><td>přenos 64 bitů Xn &rarr; Vd&lt;127:64&gt;, ostatní bity Vd se nezmění</td></tr>
</table>

<p><div class="rs-tip-major">Poznámka: povšimněte si, že až na 64bitové
platformě konečně došlo k&nbsp;unifikaci mezi celočíselnými registry a FP
registry s&nbsp;ohledem na bitovou šířku operandů a rozlišením jednoduchá
přesnost/poloviční slovo a dvojitá přesnost/celé slovo..</div></p>



<p><a name="k12"></a></p>
<h2 id="k12">12. Ukázka přenosu mezi celočíselným a FP registrem</h2>

<p>V&nbsp;dalším demonstračním příkladu je ukázán způsob přenosu dat mezi
registry <strong>X1</strong>, <strong>D1</strong> a <strong>X2</strong>
s&nbsp;využitím instrukce <strong>FMOV</strong>:</p>

<pre>
<i># asmsyntax=as</i>
&nbsp;
<i># Přesuny mezi celočíselnými a FP registry</i>
<i># v assembleru GNU AS pro architekturu AArch64.</i>
<i>#</i>
<i># Autor: Pavel Tišnovský</i>
&nbsp;
&nbsp;
&nbsp;
<i># Linux kernel system call table</i>
sys_exit=93
&nbsp;
<i># List of syscalls for AArch64:</i>
<i># https://github.com/torvalds/linux/blob/master/include/uapi/asm-generic/unistd.h</i>
&nbsp;
&nbsp;
&nbsp;
<i>#-----------------------------------------------------------------------------</i>
.section .data
&nbsp;
&nbsp;
&nbsp;
<i>#-----------------------------------------------------------------------------</i>
.section .bss
&nbsp;
&nbsp;
&nbsp;
<i>#-----------------------------------------------------------------------------</i>
.section .text
        .global _start          <i>// tento symbol má být dostupný i z linkeru</i>
&nbsp;
_start:
        <strong>mov  x1, #0x1234</strong>        <i>// načtení celočíselné konstanty</i>
        <strong>fmov d1, x1</strong>             <i>// přenos do FP registru</i>
        <strong>fmov x2, d1</strong>             <i>// zpětný přenos do celočíselného registru</i>
&nbsp;
        mov  x8, #sys_exit      <i>// číslo sycallu pro funkci "exit"</i>
        mov  x0, #0             <i>// exit code = 0</i>
        svc  0                  <i>// volání Linuxového kernelu</i>
</pre>

<p>Přenosy si můžeme ověřit &bdquo;naživo&ldquo; v&nbsp;GNU Debuggeru. Pro
tento účel se provede překlad s&nbsp;využitím přepínače
<strong>-g</strong>:</p>

<pre>
$ <strong>as -g -o a.o src.s</strong>
$ <strong>ld -g -o a.out a.o</strong>
</pre>

<p>Výsledný binární soubor načteme do GNU Debuggeru:</p>

<pre>
$ <strong>gdb a.out</strong>
</pre>

<p>Nastavíme breakpoint na začátek kódu, tedy na návěští
<strong>_start</strong>:</p>

<pre>
(gdb) <strong>b _start</strong>
</pre>

<p>Následně program spustíme:</p>

<pre>
(gdb) <strong>r</strong>
</pre>

<p>Program se zastaví na první instrukci (díky breakpointu), takže si zobrazíme
obsah pracovních registrů:</p>

<pre>
(gdb) <strong>info registers</strong>
</pre>

<pre>
x0             0x0                 0
x1             0x0                 0
x2             0x0                 0
...
...
...
</pre>

<p>Další instrukce se provede příkazem <strong>n</strong> (<i>next</i>). Opět
si zobrazíme obsah registrů:</p>

<pre>
(gdb) <strong>info registers</strong>
</pre>

<pre>
x0             0x0                 0
x1             0x1234              4660
x2             0x0                 0
...
...
...
</pre>

<p>Další instrukce provádí přenos do <strong>D1</strong>, takže si musíme
zobrazit obsah registrů matematického koprocesoru:</p>

<pre>
(gdb) <strong>info float</strong>
</pre>

<pre>
d0             {f = 0x0, u = 0x0, s = 0x0} {f = 0, u = 0, s = 0}
d1             {f = 0x0, u = 0x1234, s = 0x1234} {f = 2.3023459096202089e-320, u = 4660, s = 4660}
d2             {f = 0x0, u = 0x0, s = 0x0} {f = 0, u = 0, s = 0}
...
...
...
</pre>

<p>A poslední instrukce přenese stejná data do celočíselného registru
<strong>X2</strong>:</p>

<pre>
(gdb) <strong>info registers</strong>
</pre>

<pre>
x0             0x0                 0
x1             0x1234              4660
x2             0x1234              4660
x3             0x0                 0
...
...
...
</pre>



<p><a name="k13"></a></p>
<h2 id="k13">13. Konverze mezi různými formáty</h2>

<p>Pro konverzi hodnot mezi různými numerickými formáty s&nbsp;plovoucí řádovou
čárkou (<i>half float</i>, <i>single</i>, <i>double</i>) slouží instrukce
nazvaná <strong>FCVT</strong> (neboli <i>float convert</i>). Některé převody
lze provést bez problémů (neztratí se tedy ani přesnost ani rozsah), u dalších
převodů buď ztratíme přesnost nebo bude hodnota převedena na &infin; nebo
-&infin; (což je ovšem očekávané chování):</p>

<table>
<tr><th>#</th><th>Instrukce</th><th>Stručný popis</th></tr>
<tr><td>1</td><td>FCVT Sd, Hn</td><td>převod mezi formátem <i>half float</i> a <i>single</i> (bez ztráty)</td></tr>
<tr><td>2</td><td>FCVT Hd, Sn</td><td>převod mezi formátem <i>single</i> a <i>half float</i> (ztráta přesnosti a/nebo rozsahu)</td></tr>
<tr><td>3</td><td>FCVT Dd, Hn</td><td>převod mezi formátem <i>half float</i> a <i>double</i> (bez ztráty)</td></tr>
<tr><td>4</td><td>FCVT Hd, Dn</td><td>převod mezi formátem <i>double</i> a <i>half float</i> (ztráta přesnosti a/nebo rozsahu)</td></tr>
<tr><td>5</td><td>FCVT Dd, Sn</td><td>převod mezi formátem <i>single</i> a <i>double</i> (bez ztráty)</td></tr>
<tr><td>6</td><td>FCVT Sd, Dn</td><td>převod mezi formátem <i>double</i> a <i>single</i> (ztráta přesnosti a/nebo rozsahu)</td></tr>
</table>

<p>Opět se podívejme na prozatím velmi jednoduchý příklad použití při konverzi
mezi hodnotami lokálních proměnných:</p>

<pre>
float  x = 1.0;
double y = 1.0;
double z = x;
float  w = y;
</pre>

<p>Překlad tohoto úryvku kódu do assembleru:</p>

<pre>
<i>// float  x = 1.0;</i>
fmov    s0, 1.0e+0
str     s0, [sp, 28]
&nbsp;
<i>// double y = 1.0;</i>
fmov    d0, 1.0e+0
str     d0, [sp, 16]
&nbsp;
<i>// double z = x;</i>
ldr     s0, [sp, 28]
fcvt    d0, s0
str     d0, [sp, 8]
&nbsp;
<i>// float  w = y;</i>
ldr     d0, [sp, 16]
fcvt    s0, d0
str     s0, [sp, 4]
</pre>



<p><a name="k14"></a></p>
<h2 id="k14">14. Převod FP hodnot na celá čísla (zaokrouhlení)</h2>

<p>Poměrně rozsáhlá skupina strojových instrukcí slouží pro převod FP hodnot
(tedy numerických hodnot reprezentovaných v&nbsp;systému plovoucí řádové čárky)
na celá čísla. Podívejme se na tabulku se seznamem těchto instrukcí:</p>

<table>
<tr><th>#</th><th>Instrukce</th><th>Stručný popis</th></tr>
<tr><td>1</td><td>FCVTAS</td><td>konverze FP na typ <i>signed integer</i> (tedy se znaménkem), zaokrouhlení směrem k&nbsp;nekonečnům</td></tr>
<tr><td>2</td><td>FCVTAU</td><td>dtto, ale konverze na datový typ <i>unsigned integer</i></td></tr>
<tr><td>3</td><td>FCVTMS</td><td>konverze FP hodnoty na <i>signed integer</i> se zaokrouhlením směrem k&nbsp;-&infin;</td></tr>
<tr><td>4</td><td>FCVTMU</td><td>konverze FP hodnoty na <i>unsigned integer</i> se zaokrouhlením směrem k&nbsp;-&infin;</td></tr>
<tr><td>5</td><td>FCVTNS</td><td>konverze FP hodnoty se zaokrouhlením na nejbližší sudé číslo</td></tr>
<tr><td>6</td><td>FCVTNU</td><td>dtto, ovšem nyní pro <i>unsigned integer</i></td></tr>
<tr><td>7</td><td>FCVTPS</td><td>konverze FP hodnoty na <i>signed integer</i> se zaokrouhlením směrem k&nbsp;+&infin;</td></tr>
<tr><td>8</td><td>FCVTPU</td><td>konverze FP hodnoty na <i>unsigned integer</i> se zaokrouhlením směrem k&nbsp;+&infin;</td></tr>
<tr><td>9</td><td>FCVTZS</td><td>konverze FP hodnoty na <i>signed integer</i> se zaokrouhlením směrem k&nbsp;nule</td></tr>
<tr><td>10</td><td>FCVTZU</td><td>konverze na <i>unsigned integer</i> se zaokrouhlením směrem k&nbsp;nule</td></tr>
<tr><td>11</td><td>SCVTF</td><td>zpětná konverze na FP hodnotu (desetinná část bude pochopitelně nulová)</td></tr>
<tr><td>12</td><td>UCVTF</td><td>zpětná konverze na FP hodnotu (desetinná část bude pochopitelně nulová)</td></tr>
</table>

<p>Instrukce <strong>FCVTNS</strong> a <strong>FCVTNU</strong> zaokrouhlují na
nejbližší sudé číslo ty hodnoty, které leží přesně v&nbsp;polovině intervalu
(1/2).</p>

<p>Nezapomeneme si samozřejmě ukázat, jak tyto instrukce používá překladač
v&nbsp;praxi:</p>

<pre>
float  x = 1.0;
double y = 2.0;
int    i = x;
int    j = y;
</pre>

<p>Způsob překladu tohoto programového bloku do assembleru vypadá
následovně:</p>

<pre>
<i>// float  x = 1.0;</i>
fmov    s0, 1.0e+0
str     s0, [sp, 28]
&nbsp;
<i>// double y = 2.0;</i>
fmov    d0, 2.0e+0
str     d0, [sp, 16]
&nbsp;
<i>// int    i = x;</i>
ldr     s0, [sp, 28]
fcvtzs  w0, s0
str     w0, [sp, 12]
&nbsp;
<i>// int    j = y;</i>
ldr     d0, [sp, 16]
fcvtzs  w0, d0
str     w0, [sp, 8]
</pre>



<p><a name="k15"></a></p>
<h2 id="k15">15. Základní aritmetické operace s&nbsp;hodnotami s&nbsp;plovoucí řádovou čárkou</h2>

<p>Poměrně rozsáhlá je skupina instrukcí určených pro provádění základních
aritmetických operací, k&nbsp;nimž navíc přidáváme instrukce pro výpočet
absolutní hodnoty, odmocniny, minima, maxima atd.:</p>

<table>
<tr><th>#</th><th>Instrukce</th><th>Stručný popis</th></tr>
<tr><td>1</td><td>FABS</td><td>výpočet absolutní hodnoty (jeden zdrojový operand)</td></tr>
<tr><td>2</td><td>FNEG</td><td>negace hodnoty (jeden zdrojový operand)</td></tr>
<tr><td>3</td><td>FSQRT</td><td>výpočet druhé odmocniny (jeden zdrojový operand)</td></tr>
<tr><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td></tr>
<tr><td>4</td><td>FADD</td><td>součet</td></tr>
<tr><td>5</td><td>FSUB</td><td>rozdíl</td></tr>
<tr><td>6</td><td>FMUL</td><td>součin</td></tr>
<tr><td>7</td><td>FNMUL</td><td>součin a následná změna znaménka výsledku</td></tr>
<tr><td>8</td><td>FDIV</td><td>podíl</td></tr>
<tr><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td></tr>
<tr><td>9</td><td>FMIN</td><td>výpočet minima, pokud je jeden ze zdrojových operandů NaN, vrací NaN</td></tr>
<tr><td>10</td><td>FMAX</td><td>výpočet maxima, pokud je jeden ze zdrojových operandů NaN, vrací NaN</td></tr>
<tr><td>11</td><td>FMINNUM</td><td>výpočet minima, pokud je jeden ze zdrojových operandů NaN, vrací druhý operand</td></tr>
<tr><td>12</td><td>FMAXNUM</td><td>výpočet maxima, pokud je jeden ze zdrojových operandů NaN, vrací druhý operand</td></tr>
<tr><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td></tr>
<tr><td>13</td><td>FMADD</td><td>(MAC) cíl = zdroj1 + zdroj2 &times; zdroj3</td></tr>
<tr><td>14</td><td>FMSUB</td><td>cíl = zdroj1 - zdroj2 &times; zdroj3</td></tr>
<tr><td>15</td><td>FNMADD</td><td>cíl = -zdroj1 + zdroj2 &times; zdroj3</td></tr>
<tr><td>16</td><td>FNMSUB</td><td>cíl = -zdroj1 - zdroj2 &times; zdroj3</td></tr>
</table>

<p><div class="rs-tip-major">Poznámka: stále se ovšem jedná o koncept RISC,
pouze došlo k&nbsp;určitému posunu ve významu slova &bdquo;Reduced&ldquo;
v&nbsp;této zkratce.</div></p>

<p>Opět se podívejme na příklad, tentokrát s&nbsp;nepatrně složitějším
výpočtem:</p>

<pre>
float  x = 1.0;
float  y = 2.0;
float  z = 3.0;
float  w = x*y + y/z + fabs(z);
</pre>

<p>Tento příklad se (bez optimalizací) přeloží následovně:</p>

<pre>
<i>// float  x = 1.0;</i>
fmov    s0, 1.0e+0
str     s0, [sp, 12]
&nbsp;
<i>// float  y = 2.0;</i>
fmov    s0, 2.0e+0
str     s0, [sp, 8]
&nbsp;
<i>// float  w = x*y + y/z + fabs(z);</i>
fmov    s0, 3.0e+0
str     s0, [sp, 4]
&nbsp;
<i>// float  w = x*y + y/z + fabs(z);</i>
ldr     s1, [sp, 12]
ldr     s0, [sp, 8]
fmul    s1, s1, s0 <i>// x*y</i>
ldr     s2, [sp, 8]
ldr     s0, [sp, 4]
fdiv    s0, s2, s0 <i>// y/z</i>
fadd    s1, s1, s0
ldr     s0, [sp, 4]
fabs    s0, s0
fadd    s0, s1, s0
</pre>

<p>Kombinace aritmetické operace s&nbsp;konverzí výsledku:</p>

<pre>
float  x = 1.0;
double y = 1.0;
float  z = x+y;
</pre>

<p>Se může přeložit takto:</p>

<pre>
<i>// float  x = 1.0;</i>
fmov    s0, 1.0e+0
str     s0, [sp, 28]
&nbsp;
<i>// double y = 1.0;</i>
fmov    d0, 1.0e+0
str     d0, [sp, 16]
&nbsp;
<i>// float  z = x+y;</i>
ldr     s0, [sp, 28]
fcvt    d1, s0
ldr     d0, [sp, 16]
fadd    d0, d1, d0
fcvt    s0, d0
str     s0, [sp, 12]
</pre>

<p><div class="rs-tip-major">Poznámka: demonstrační příklad bude uveden
příště.</div></p>



<p><a name="k16"></a></p>
<h2 id="k16">16. Porovnání operandů s&nbsp;hodnotami s&nbsp;plovoucí řádovou čárkou</h2>

<p>Instrukce, které slouží pro porovnání obsahu dvou FP registrů, nastavují
příznakové bity <strong>N</strong>, <strong>V</strong>, <strong>Z</strong> a
<strong>C</strong> (prakticky stejným způsobem, jako instrukce celočíselné). To
znamená, že tyto instrukce je možné přímo zkombinovat například
s&nbsp;podmíněnými skoky:</p>

<table>
<tr><th>#</th><th>Instrukce</th><th>Stručný popis</th></tr>
<tr><td>1</td><td>FCMP</td><td>porovnání dvou FP operandů na rovnost, popř.&nbsp;porovnání s&nbsp;nulou</td></tr>
<tr><td>2</td><td>FCMPE</td><td>dtto, ovšem pokud je jeden z&nbsp;operandů NaN, dojde k&nbsp;výjimce</td></tr>
<tr><td>3</td><td>FCCMP</td><td>pokud je podmínka splněna, provede se porovnání, jinak se příznakové bity nastaví na určenou konstantu</td></tr>
<tr><td>4</td><td>FCCMPE</td><td>dtto ale s&nbsp;kontrolou operandů na NaN</td></tr>
<tr><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td></tr>
<tr><td>5</td><td>FCSEL</td><td>obdoba CSEL, ovšem pro FP operandy (čtvrtým parametrem je podmínka)</td></tr>
</table>

<p>Podívejme se nyní na jednoduchý demonstrační příklad, opět využívající
lokální proměnné uložené na zásobníkovém rámci:</p>

<pre>
float  x = 1.0;
float  y = 10.0;
float  z = 20.0;
int i = x == y;
int j = x &lt; y;
int k = x &lt;= y;
int l = x != y;
int m = x &gt; y;
</pre>

<p>Způsob překladu neoptimalizujícím překladačem:</p>

<pre>
<i>float  x = 1.0;</i>
fmov    s0, 1.0e+0
str     s0, [sp, 28]
&nbsp;
<i>// float  y = 10.0;</i>
fmov    s0, 1.0e+1
str     s0, [sp, 24]
&nbsp;
<i>// float  z = 20.0;</i>
fmov    s0, 2.0e+1
str     s0, [sp, 20]
&nbsp;
<i>// int i = x == y;</i>
ldr     s1, [sp, 28]
ldr     s0, [sp, 24]
fcmp    s1, s0
cset    w0, eq         <i>// testuje se příznakový bit Z (zero)</i>
uxtb    w0, w0         <i>// rozšíření osmibitové hodnoty na 32 bitů</i>
str     w0, [sp, 16]
&nbsp;
<i>// int j = x &lt; y;</i>
ldr     s1, [sp, 28]
ldr     s0, [sp, 24]
fcmpe   s1, s0
cset    w0, mi
uxtb    w0, w0         <i>// rozšíření osmibitové hodnoty na 32 bitů</i>
str     w0, [sp, 12]
&nbsp;
<i>// int k = x &lt;= y;</i>
ldr     s1, [sp, 28]
ldr     s0, [sp, 24]
fcmpe   s1, s0
cset    w0, ls
uxtb    w0, w0         <i>// rozšíření osmibitové hodnoty na 32 bitů</i>
str     w0, [sp, 8]
&nbsp;
<i>// int l = x != y;</i>
ldr     s1, [sp, 28]
ldr     s0, [sp, 24]
fcmp    s1, s0
cset    w0, ne         <i>// testuje se příznakový bit Z (zero)</i>
uxtb    w0, w0         <i>// rozšíření osmibitové hodnoty na 32 bitů</i>
str     w0, [sp, 4]
&nbsp;
<i>// int m = x &gt; y;</i>
ldr     s1, [sp, 28]
ldr     s0, [sp, 24]
fcmpe   s1, s0
cset    w0, gt
uxtb    w0, w0         <i>// rozšíření osmibitové hodnoty na 32 bitů</i>
</pre>

<p><div class="rs-tip-major">Poznámka: demonstrační příklad bude opět uveden až
příště.</div></p>



<p><a name="k17"></a></p>
<h2 id="k17">17. SIMD operace</h2>

<p>Zbývá nám si popsat &bdquo;maličkost&ldquo; a to konkrétně SIMD operace,
které umožňují provádět výpočty nad celými vektory hodnot. Ve skutečnosti je
počet &bdquo;vektorových&ldquo; instrukcí větší, než počet všech zbývajících
instrukcí (včetně instrukcí matematického koprocesoru), takže si na jejich
popis vyhradíme celý článek.</p>

<p><div class="rs-tip-major">Poznámka: použití těchto instrukcí má velký vliv
na celkovou výkonnost aplikace, což na druhou stranu představuje problém,
protože záleží jak na překladači, tak i na programátorovi (<i>intrinsic</i>),
jakým způsobem a jak efektivně dokáže této vlastnosti mikroprocesorů AArch64
využít.</div></p>



<p><a name="k18"></a></p>
<h2 id="k18">18. Repositář s&nbsp;demonstračními příklady</h2>

<p>Všechny <a
href="https://www.root.cz/clanky/specificke-vlastnosti-procesoru-aarch64-podminene-a-nepodminene-skoky-adresovani-dat/">minule</a>
i dnes popisované demonstrační příklady byly společně s&nbsp;podpůrným souborem
<strong>Makefile</strong> určeným pro jejich překlad či naopak pro
disassembling, uloženy do GIT repositáře dostupného na adrese <a
href="https://github.com/tisnik/presentations/">https://github.com/tisnik/presentations/</a>.
Všechny příklady jsou určeny pro standardní <i>GNU Assembler</i> a používají
výchozí syntaxi procesorů AArch64. Následuje tabulka s&nbsp;odkazy na zdrojové
kódy příkladů i na již zmíněné podpůrné skripty:</p>

<table>
<tr><th> #</th><th>Příklad</th><th>Popis</th><th>Zdrojový kód</th></tr>
<tr><td> 1</td><td>template.s</td><td>šablona pro programy psané v&nbsp;assembleru</td><td><a href="https://github.com/tisnik/presentations/blob/master/assembler/aarch64/template.s">https://github.com/tisnik/presentations/blob/master/assembler/aarch64/template.s</a></td></tr>
<tr><td> 2</td><td>template_2.s</td><td>šablona pro programy psané v&nbsp;assembleru, založeno na makrech</td><td><a href="https://github.com/tisnik/presentations/blob/master/assembler/aarch64/template_2.s">https://github.com/tisnik/presentations/blob/master/assembler/aarch64/template_2.s</a></td></tr>
<tr><td> 3</td><td>hello_world_1.s</td><td>základní podoba programu typu &bdquo;Hello, world!&ldquo;</td><td><a href="https://github.com/tisnik/presentations/blob/master/assembler/aarch64/hello_world_1.s">https://github.com/tisnik/presentations/blob/master/assembler/aarch64/hello_world_1.s</a></td></tr>
<tr><td> 4</td><td>hello_world_2.s</td><td>přepis tištěného řetězce</td><td><a href="https://github.com/tisnik/presentations/blob/master/assembler/aarch64/hello_world_2.s">https://github.com/tisnik/presentations/blob/master/assembler/aarch64/hello_world_2.s</a></td></tr>
<tr><td> 5</td><td>hello_world_3.s</td><td>refaktoring, použití maker</td><td><a href="https://github.com/tisnik/presentations/blob/master/assembler/aarch64/hello_world_3.s">https://github.com/tisnik/presentations/blob/master/assembler/aarch64/hello_world_3.s</a></td></tr>
<tr><td> 6</td><td>aritmetic1.s</td><td>základní aritmetické operace</td><td><a href="https://github.com/tisnik/presentations/blob/master/assembler/aarch64/aritmetic1.s">https://github.com/tisnik/presentations/blob/master/assembler/aarch64/aritmetic1.s</a></td></tr>
<tr><td> 7</td><td>infinite_loop.s</td><td>nekonečná programová smyčka realizovaná instrukcí <strong>b</strong></td><td><a href="https://github.com/tisnik/presentations/blob/master/assembler/aarch64/infinite_loop.s">https://github.com/tisnik/presentations/blob/master/assembler/aarch64/infinite_loop.s</a></td></tr>
<tr><td> 8</td><td>loop1-aarch64-v1.s</td><td>základní varianta počítané programové smyčky</td><td><a href="https://github.com/tisnik/presentations/blob/master/assembler/aarch64/loop1-aarch64-v1.s">https://github.com/tisnik/presentations/blob/master/assembler/aarch64/loop1-aarch64-v1.s</a></td></tr>
<tr><td> 9</td><td>loop1-aarch64-v2.s</td><td>optimalizace &ndash; odstranění instrukce <strong>CMP</strong></td><td><a href="https://github.com/tisnik/presentations/blob/master/assembler/aarch64/loop1-aarch64-v2.s">https://github.com/tisnik/presentations/blob/master/assembler/aarch64/loop1-aarch64-v2.s</a></td></tr>
<tr><td>10</td><td>loop1-aarch64-v3.s</td><td>optimalizace &ndash; použití instrukce <strong>CBNZ</strong></td><td><a href="https://github.com/tisnik/presentations/blob/master/assembler/aarch64/loop1-aarch64-v3.s">https://github.com/tisnik/presentations/blob/master/assembler/aarch64/loop1-aarch64-v3.s</a></td></tr>
<tr><td>11</td><td>loop1-aarch64-v4.s</td><td>automatické zvýšení adresy (ukazatele)</td><td><a href="https://github.com/tisnik/presentations/blob/master/assembler/aarch64/loop1-aarch64-v4.s">https://github.com/tisnik/presentations/blob/master/assembler/aarch64/loop1-aarch64-v4.s</a></td></tr>
<tr><td>12</td><td>move1.s</td><td>přesun bloku dat</td><td><a href="https://github.com/tisnik/presentations/blob/master/assembler/aarch64/move1.s">https://github.com/tisnik/presentations/blob/master/assembler/aarch64/move1.s</a></td></tr>
<tr><td>13</td><td>move2.s</td><td>přepis s&nbsp;využitím maker</td><td><a href="https://github.com/tisnik/presentations/blob/master/assembler/aarch64/move2.s">https://github.com/tisnik/presentations/blob/master/assembler/aarch64/move2.s</a></td></tr>
<tr><td>14</td><td>move3.s</td><td>problém s&nbsp;vícenásobným použitím makra</td><td><a href="https://github.com/tisnik/presentations/blob/master/assembler/aarch64/move3.s">https://github.com/tisnik/presentations/blob/master/assembler/aarch64/move3.s</a></td></tr>
<tr><td>15</td><td>move4.s</td><td>vyřešení předchozího problému</td><td><a href="https://github.com/tisnik/presentations/blob/master/assembler/aarch64/move4.s">https://github.com/tisnik/presentations/blob/master/assembler/aarch64/move4.s</a></td></tr>
<tr><td>16</td><td>move5.s</td><td>jednoduchý benchmark &ndash; přesun bloků po bajtech</td><td><a href="https://github.com/tisnik/presentations/blob/master/assembler/aarch64/move5.s">https://github.com/tisnik/presentations/blob/master/assembler/aarch64/move5.s</a></td></tr>
<tr><td>17</td><td>move6.s</td><td>jednoduchý benchmark &ndash; přesun bloků po slovech</td><td><a href="https://github.com/tisnik/presentations/blob/master/assembler/aarch64/move6.s">https://github.com/tisnik/presentations/blob/master/assembler/aarch64/move6.s</a></td></tr>
<tr><td>18</td><td>move7.s</td><td>jednoduchý benchmark &ndash; přesun bloků po dvojicích slov</td><td><a href="https://github.com/tisnik/presentations/blob/master/assembler/aarch64/move7.s">https://github.com/tisnik/presentations/blob/master/assembler/aarch64/move7.s</a></td></tr>
<tr><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td></tr>
<tr><td>19</td><td>fmov1.s</td><td>načtení konstanty typu <i>double</i> do registru <strong>d1</strong></td><td><a href="https://github.com/tisnik/presentations/blob/master/assembler/aarch64/fmov1.s">https://github.com/tisnik/presentations/blob/master/assembler/aarch64/fmov1.s</a></td></tr>
<tr><td>20</td><td>fmov2.s</td><td>načtení konstanty typu <i>single</i> do registru <strong>s1</strong></td><td><a href="https://github.com/tisnik/presentations/blob/master/assembler/aarch64/fmov2.s">https://github.com/tisnik/presentations/blob/master/assembler/aarch64/fmov2.s</a></td></tr>
<tr><td>21</td><td>fmov3.s</td><td>použití nekorektní konstanty</td><td><a href="https://github.com/tisnik/presentations/blob/master/assembler/aarch64/fmov3.s">https://github.com/tisnik/presentations/blob/master/assembler/aarch64/fmov3.s</a></td></tr>
<tr><td>22</td><td>fmov4.s</td><td>načtení nuly do registru <strong>s1</strong></td><td><a href="https://github.com/tisnik/presentations/blob/master/assembler/aarch64/fmov4.s">https://github.com/tisnik/presentations/blob/master/assembler/aarch64/fmov4.s</a></td></tr>
<tr><td>23</td><td>fmov5.s</td><td>načtení nuly do registru <strong>d1</strong></td><td><a href="https://github.com/tisnik/presentations/blob/master/assembler/aarch64/fmov5.s">https://github.com/tisnik/presentations/blob/master/assembler/aarch64/fmov5.s</a></td></tr>
<tr><td>24</td><td>fmov6.s</td><td>nepřímé načtení konstanty instrukcí <strong>ldr</strong></td><td><a href="https://github.com/tisnik/presentations/blob/master/assembler/aarch64/fmov6.s">https://github.com/tisnik/presentations/blob/master/assembler/aarch64/fmov6.s</a></td></tr>
<tr><td>25</td><td>fmov7.s</td><td>přesuny mezi celočíselnými a FP registry</td><td><a href="https://github.com/tisnik/presentations/blob/master/assembler/aarch64/fmov7.s">https://github.com/tisnik/presentations/blob/master/assembler/aarch64/fmov7.s</a></td></tr>
<tr><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td></tr>
<tr><td>26</td><td>Makefile</td><td>soubor pro překlad všech příkladů nástrojem <strong>make</strong></td><td><a href="https://github.com/tisnik/presentations/blob/master/assembler/aarch64/Makefile">https://github.com/tisnik/presentations/blob/master/assembler/aarch64/Makefile</a></td></tr>
</table>



<p><a name="k19"></a></p>
<h2 id="k19">19. Předchozí články o architektuře AArch64</h2>

<p>S&nbsp;architekturou AArch64 jsme se již na stránkách Roota setkali, a to
konkrétně v&nbsp;následujících článcích, z&nbsp;nichž v&nbsp;dnešním článku
vycházíme:</p>

<ol>

<li>64bitové mikroprocesory s architekturou AArch64<br />
<a href="https://www.root.cz/clanky/64bitove-mikroprocesory-s-architekturou-aarch64/">https://www.root.cz/clanky/64bitove-mikroprocesory-s-architekturou-aarch64/</a>
</li>

<li>Instrukční sada AArch64<br />
<a href="https://www.root.cz/clanky/instrukcni-sada-aarch64/">https://www.root.cz/clanky/instrukcni-sada-aarch64/</a>
</li>

<li>Instrukční sada AArch64 (2.část)<br />
<a href="https://www.root.cz/clanky/instrukcni-sada-aarch64-2-cast/">https://www.root.cz/clanky/instrukcni-sada-aarch64-2-cast/</a>
</li>

<li>Tvorba a ladění programů v&nbsp;assembleru mikroprocesorů AArch64<br />
<a href="https://www.root.cz/clanky/tvorba-a-ladeni-programu-v-assembleru-mikroprocesoru-aarch64/">https://www.root.cz/clanky/tvorba-a-ladeni-programu-v-assembleru-mikroprocesoru-aarch64/</a>
</li>

<li>Instrukční sada AArch64: technologie NEON<br />
<a href="https://www.root.cz/clanky/instrukcni-sada-aarch64-technologie-neon/">https://www.root.cz/clanky/instrukcni-sada-aarch64-technologie-neon/</a>
</li>

<li>Specifické vlastnosti procesorů AArch64: základní instrukce<br />
<a href="https://www.root.cz/clanky/specificke-vlastnosti-procesoru-aarch64-zakladni-instrukce/">https://www.root.cz/clanky/specificke-vlastnosti-procesoru-aarch64-zakladni-instrukce/</a>
</li>

<li>Specifické vlastnosti procesorů AArch64: podmíněné a nepodmíněné skoky, adresování dat<br />
<a href="https://www.root.cz/clanky/specificke-vlastnosti-procesoru-aarch64-podminene-a-nepodminene-skoky-adresovani-dat/">https://www.root.cz/clanky/specificke-vlastnosti-procesoru-aarch64-podminene-a-nepodminene-skoky-adresovani-dat/</a>
</li>

<li>Specifické vlastnosti procesorů AArch64: přenos bloků dat a instrukce s&nbsp;podmínkou<br />
<a href="https://www.root.cz/clanky/specificke-vlastnosti-procesoru-aarch64-prenos-bloku-dat-a-instrukce-s-podminkou/">https://www.root.cz/clanky/specificke-vlastnosti-procesoru-aarch64-prenos-bloku-dat-a-instrukce-s-podminkou/</a>
</li>

</ol>



<p><a name="k20"></a></p>
<h2 id="k20">20. Odkazy na Internetu</h2>

<ol>

<li>Arm Architecture Reference Manual for A-profile architecture<br />
<a href="https://developer.arm.com/documentation/ddi0487/latest">https://developer.arm.com/documentation/ddi0487/latest</a>
</li>

<li>The GNU Assembler - macros<br />
<a href="http://tigcc.ticalc.org/doc/gnuasm.html#SEC109">http://tigcc.ticalc.org/doc/gnuasm.html#SEC109</a>
</li>

<li>GNU Binutils<br />
<a href="https://sourceware.org/binutils/">https://sourceware.org/binutils/</a>
</li>

<li>Documentation for binutils 2.38<br />
<a href="https://sourceware.org/binutils/docs-2.38/">https://sourceware.org/binutils/docs-2.38/</a>
</li>

<li>AArch64 Instruction Set Architecture<br />
<a href="https://developer.arm.com/architectures/learn-the-architecture/aarch64-instruction-set-architecture/instruction-sets-in-the-arm-architecture">https://developer.arm.com/architectures/learn-the-architecture/aarch64-instruction-set-architecture/instruction-sets-in-the-arm-architecture</a>
</li>

<li>Arm Armv8-A A32/T32 Instruction Set Architecture<br />
<a href="https://developer.arm.com/documentation/ddi0597/2021-12/?lang=en">https://developer.arm.com/documentation/ddi0597/2021-12/?lang=en</a>
</li>

<li>Comparison of ARMv8-A cores<br />
<a href="https://en.wikipedia.org/wiki/Comparison_of_ARMv8-A_cores">https://en.wikipedia.org/wiki/Comparison_of_ARMv8-A_cores</a>
</li>

<li>Cortex-A32 Processor<br />
<a href="https://www.arm.com/products/processors/cortex-a/cortex-a32-processor.php">https://www.arm.com/products/processors/cortex-a/cortex-a32-processor.php</a>
</li>

<li>Cortex-A35 Processor<br />
<a href="https://www.arm.com/products/processors/cortex-a/cortex-a35-processor.php">https://www.arm.com/products/processors/cortex-a/cortex-a35-processor.php</a>
</li>

<li>Cortex-A53 Processor<br />
<a href="https://www.arm.com/products/processors/cortex-a/cortex-a53-processor.php">https://www.arm.com/products/processors/cortex-a/cortex-a53-processor.php</a>
</li>

<li>Cortex-A57 Processor<br />
<a href="https://www.arm.com/products/processors/cortex-a/cortex-a57-processor.php">https://www.arm.com/products/processors/cortex-a/cortex-a57-processor.php</a>
</li>

<li>Cortex-A72 Processor<br />
<a href="https://www.arm.com/products/processors/cortex-a/cortex-a72-processor.php">https://www.arm.com/products/processors/cortex-a/cortex-a72-processor.php</a>
</li>

<li>Cortex-A73 Processor<br />
<a href="https://www.arm.com/products/processors/cortex-a/cortex-a73-processor.php">https://www.arm.com/products/processors/cortex-a/cortex-a73-processor.php</a>
</li>

<li>Apple A7 (SoC založen na CPU Cyclone)<br />
<a href="https://en.wikipedia.org/wiki/Apple_A7">https://en.wikipedia.org/wiki/Apple_A7</a>
</li>

<li>System cally pro AArch64 na Linuxu<br />
<a href="https://github.com/torvalds/linux/blob/master/include/uapi/asm-generic/unistd.h">https://github.com/torvalds/linux/blob/master/include/uapi/asm-generic/unistd.h</a>
</li>

<li>Architectures/AArch64 (FedoraProject.org)<br />
<a href="https://fedoraproject.org/wiki/Architectures/AArch64">https://fedoraproject.org/wiki/Architectures/AArch64</a>
</li>

<li>SIG pro AArch64 (CentOS)<br />
<a href="https://wiki.centos.org/SpecialInterestGroup/AltArch/AArch64">https://wiki.centos.org/SpecialInterestGroup/AltArch/AArch64</a>
</li>

<li>The ARMv8 instruction sets<br />
<a href="http://infocenter.arm.com/help/index.jsp?topic=/com.arm.doc.den0024a/ch05s01.html">http://infocenter.arm.com/help/index.jsp?topic=/com.arm.doc.den0024a/ch05s01.html</a>
</li>

<li>A64 Instruction Set<br />
<a href="https://developer.arm.com/products/architecture/instruction-sets/a64-instruction-set">https://developer.arm.com/products/architecture/instruction-sets/a64-instruction-set</a>
</li>

<li>Switching between the instruction sets<br />
<a href="http://infocenter.arm.com/help/index.jsp?topic=/com.arm.doc.den0024a/ch05s01.html">http://infocenter.arm.com/help/index.jsp?topic=/com.arm.doc.den0024a/ch05s01.html</a>
</li>

<li>The A64 instruction set<br />
<a href="http://infocenter.arm.com/help/index.jsp?topic=/com.arm.doc.den0024a/ch05s01.html">http://infocenter.arm.com/help/index.jsp?topic=/com.arm.doc.den0024a/ch05s01.html</a>
</li>

<li>Introduction to ARMv8 64-bit Architecture<br />
<a href="https://quequero.org/2014/04/introduction-to-arm-architecture/">https://quequero.org/2014/04/introduction-to-arm-architecture/</a>
</li>

<li>MCU market turns to 32-bits and ARM<br />
<a href="http://www.eetimes.com/document.asp?doc_id=1280803">http://www.eetimes.com/document.asp?doc_id=1280803</a>
</li>

<li>Cortex-M0 Processor (ARM Holdings)<br />
<a href="http://www.arm.com/products/processors/cortex-m/cortex-m0.php">http://www.arm.com/products/processors/cortex-m/cortex-m0.php</a>
</li>

<li>Cortex-M0+ Processor (ARM Holdings)<br />
<a href="http://www.arm.com/products/processors/cortex-m/cortex-m0plus.php">http://www.arm.com/products/processors/cortex-m/cortex-m0plus.php</a>
</li>

<li>ARM Processors in a Mixed Signal World<br />
<a href="http://www.eeweb.com/blog/arm/arm-processors-in-a-mixed-signal-world">http://www.eeweb.com/blog/arm/arm-processors-in-a-mixed-signal-world</a>
</li>

<li>ARM Architecture (Wikipedia)<br />
<a href="https://en.wikipedia.org/wiki/ARM_architecture">https://en.wikipedia.org/wiki/ARM_architecture</a>
</li>

<li>DSP for Cortex-M<br />
<a href="https://developer.arm.com/technologies/dsp/dsp-for-cortex-m">https://developer.arm.com/technologies/dsp/dsp-for-cortex-m</a>
</li>

<li>Cortex-M processors in DSP applications? Why not?!<br />
<a href="https://community.arm.com/processors/b/blog/posts/cortex-m-processors-in-dsp-applications-why-not">https://community.arm.com/processors/b/blog/posts/cortex-m-processors-in-dsp-applications-why-not</a>
</li>

<li>White Paper - DSP capabilities of Cortex-M4 and Cortex-M7<br />
<a href="https://community.arm.com/processors/b/blog/posts/white-paper-dsp-capabilities-of-cortex-m4-and-cortex-m7">https://community.arm.com/processors/b/blog/posts/white-paper-dsp-capabilities-of-cortex-m4-and-cortex-m7</a>
</li>

<li>Q (number format)<br />
<a href="https://en.wikipedia.org/wiki/Q_%28number_format%29">https://en.wikipedia.org/wiki/Q_%28number_format%29</a>
</li>

<li>TriCore Architecture &amp; Core<br />
<a href="http://www.infineon.com/cms/en/product/microcontroller/32-bit-tricore-tm-microcontroller/tricore-tm-architecture-and-core/channel.html?channel=ff80808112ab681d0112ab6b73d40837">http://www.infineon.com/cms/en/product/microcontroller/32-bit-tricore-tm-microcontroller/tricore-tm-architecture-and-core/channel.html?channel=ff80808112ab681d0112ab6b73d40837</a>
</li>

<li>TriCoreTM V1.6 Instruction Set: 32-bit Unified Processor Core<br />
<a href="http://www.infineon.com/dgdl/tc_v131_instructionset_v138.pdf?fileId=db3a304412b407950112b409b6dd0352">http://www.infineon.com/dgdl/tc_v131_instructionset_v138.pdf?fileId=db3a304412b407950112b409b6dd0352</a>
</li>

<li>TriCore v2.2 C Compiler, Assembler, Linker Reference Manual<br />
<a href="http://tasking.com/support/tricore/tc_reference_guide_v2.2.pdf">http://tasking.com/support/tricore/tc_reference_guide_v2.2.pdf</a>
</li>

<li>Infineon TriCore (Wikipedia)<br />
<a href="https://en.wikipedia.org/wiki/Infineon_TriCore">https://en.wikipedia.org/wiki/Infineon_TriCore</a>
</li>

<li>C166®S V2 Architecture &amp; Core<br />
<a href="http://www.infineon.com/cms/en/product/microcontroller/16-bit-c166-microcontroller/c166-s-v2-architecture-and-core/channel.html?channel=db3a304312bef5660112c3011c7d01ae">http://www.infineon.com/cms/en/product/microcontroller/16-bit-c166-microcontroller/c166-s-v2-architecture-and-core/channel.html?channel=db3a304312bef5660112c3011c7d01ae</a>
</li>

<li>Comparing four 32-bit soft processor cores<br />
<a href="http://www.eetimes.com/author.asp?section_id=14&doc_id=1286116">http://www.eetimes.com/author.asp?section_id=14&doc_id=1286116</a>
</li>

<li>RISC-V Instruction Set<br />
<a href="http://riscv.org/download.html#spec_compressed_isa">http://riscv.org/download.html#spec_compressed_isa</a>
</li>

<li>RISC-V Spike (ISA Simulator)<br />
<a href="http://riscv.org/download.html#isa-sim">http://riscv.org/download.html#isa-sim</a>
</li>

<li>RISC-V (Wikipedia)<br />
<a href="https://en.wikipedia.org/wiki/RISC-V">https://en.wikipedia.org/wiki/RISC-V</a>
</li>

<li>David Patterson (Wikipedia)<br />
<a href="https://en.wikipedia.org/wiki/David_Patterson_(computer_scientist)">https://en.wikipedia.org/wiki/David_Patterson_(computer_scientist)</a>
</li>

<li>OpenRISC (oficiální stránky projektu)<br />
<a href="http://openrisc.io/">http://openrisc.io/</a>
</li>

<li>OpenRISC architecture<br />
<a href="http://openrisc.io/architecture.html">http://openrisc.io/architecture.html</a>
</li>

<li>Emulátor OpenRISC CPU v JavaScriptu<br />
<a href="http://s-macke.github.io/jor1k/demos/main.html">http://s-macke.github.io/jor1k/demos/main.html</a>
</li>

<li>OpenRISC (Wikipedia)<br />
<a href="https://en.wikipedia.org/wiki/OpenRISC">https://en.wikipedia.org/wiki/OpenRISC</a>
</li>

<li>OpenRISC - instrukce<br />
<a href="http://sourceware.org/cgen/gen-doc/openrisc-insn.html">http://sourceware.org/cgen/gen-doc/openrisc-insn.html</a>
</li>

<li>OpenRISC - slajdy z přednášky o projektu<br />
<a href="https://iis.ee.ethz.ch/~gmichi/asocd/lecturenotes/Lecture6.pdf">https://iis.ee.ethz.ch/~gmichi/asocd/lecturenotes/Lecture6.pdf</a>
</li>

<li>Berkeley RISC<br />
<a href="http://en.wikipedia.org/wiki/Berkeley_RISC">http://en.wikipedia.org/wiki/Berkeley_RISC</a>
</li>

<li>Great moments in microprocessor history<br />
<a href="http://www.ibm.com/developerworks/library/pa-microhist.html">http://www.ibm.com/developerworks/library/pa-microhist.html</a>
</li>

<li>Microprogram-Based Processors<br />
<a href="http://research.microsoft.com/en-us/um/people/gbell/Computer_Structures_Principles_and_Examples/csp0167.htm">http://research.microsoft.com/en-us/um/people/gbell/Computer_Structures_Principles_and_Examples/csp0167.htm</a>
</li>

<li>Great Microprocessors of the Past and Present<br />
<a href="http://www.cpushack.com/CPU/cpu1.html">http://www.cpushack.com/CPU/cpu1.html</a>
</li>

<li>A Brief History of Microprogramming<br />
<a href="http://www.cs.clemson.edu/~mark/uprog.html">http://www.cs.clemson.edu/~mark/uprog.html</a>
</li>

<li>What is RISC?<br />
<a href="http://www-cs-faculty.stanford.edu/~eroberts/courses/soco/projects/2000-01/risc/whatis/">http://www-cs-faculty.stanford.edu/~eroberts/courses/soco/projects/2000-01/risc/whatis/</a>
</li>

<li>RISC vs. CISC<br />
<a href="http://www-cs-faculty.stanford.edu/~eroberts/courses/soco/projects/2000-01/risc/risccisc/">http://www-cs-faculty.stanford.edu/~eroberts/courses/soco/projects/2000-01/risc/risccisc/</a>
</li>

<li>RISC and CISC definitions:<br />
<a href="http://www.cpushack.com/CPU/cpuAppendA.html">http://www.cpushack.com/CPU/cpuAppendA.html</a>
</li>

<li>FPGA<br />
<a href="https://cs.wikipedia.org/wiki/Programovateln%C3%A9_hradlov%C3%A9_pole">https://cs.wikipedia.org/wiki/Programovateln%C3%A9_hradlov%C3%A9_pole</a>
</li>

<li>The Evolution of RISC<br />
<a href="http://www.ibm.com/developerworks/library/pa-microhist.html#sidebar1">http://www.ibm.com/developerworks/library/pa-microhist.html#sidebar1</a>
</li>

<li>disasm.pro<br />
<a href="https://disasm.pro/">https://disasm.pro/</a>
</li>

<li>Exploring AArch64 assembler &ndash; Chapter 5<br />
<a href="https://thinkingeek.com/2016/11/13/exploring-aarch64-assembler-chapter-5/">https://thinkingeek.com/2016/11/13/exploring-aarch64-assembler-chapter-5/</a>
</li>

<li>Brain Floating Point &ndash; nový formát uložení čísel pro strojové učení a chytrá čidla<br />
<a href="https://www.root.cz/clanky/brain-floating-point-ndash-novy-format-ulozeni-cisel-pro-strojove-uceni-a-chytra-cidla/">https://www.root.cz/clanky/brain-floating-point-ndash-novy-format-ulozeni-cisel-pro-strojove-uceni-a-chytra-cidla/</a>
</li>

<li>Why Intel is betting on BFLOAT16 to be a game changer for deep learning training? Hint: Range trumps Precision<br />
<a href="https://hub.packtpub.com/why-intel-is-betting-on-bfloat16-to-be-a-game-changer-for-deep-learning-training-hint-range-trumps-precision/">https://hub.packtpub.com/why-intel-is-betting-on-bfloat16-to-be-a-game-changer-for-deep-learning-training-hint-range-trumps-precision/</a>
</li>

<li>half-rs (pro Rust)<br />
<a href="https://github.com/starkat99/half-rs">https://github.com/starkat99/half-rs</a>
</li>

<li>float16 (pro Go)<br />
<a href="https://github.com/x448/float16">https://github.com/x448/float16</a>
</li>

<li>bfloat16 - Hardware Numerics Definition<br />
<a href="https://software.intel.com/en-us/download/bfloat16-hardware-numerics-definition">https://software.intel.com/en-us/download/bfloat16-hardware-numerics-definition</a>
</li>

<li>Intel Prepares To Graft Google’s Bfloat16 Onto Processors<br />
<a href="https://www.nextplatform.com/2019/07/15/intel-prepares-to-graft-googles-bfloat16-onto-processors/">https://www.nextplatform.com/2019/07/15/intel-prepares-to-graft-googles-bfloat16-onto-processors/</a>
</li>

<li>Norma IEEE 754 a příbuzní: formáty plovoucí řádové tečky<br />
<a href="https://www.root.cz/clanky/norma-ieee-754-a-pribuzni-formaty-plovouci-radove-tecky/">https://www.root.cz/clanky/norma-ieee-754-a-pribuzni-formaty-plovouci-radove-tecky/</a>
</li>

<li>IEEE-754 Floating-Point Conversion<br />
<a href="http://babbage.cs.qc.cuny.edu/IEEE-754.old/32bit.html">http://babbage.cs.qc.cuny.edu/IEEE-754.old/32bit.html</a>
</li>

<li>Small Float Formats<br />
<a href="https://www.khronos.org/opengl/wiki/Small_Float_Formats">https://www.khronos.org/opengl/wiki/Small_Float_Formats</a>
</li>

<li>Binary-coded decimal<br />
<a href="https://en.wikipedia.org/wiki/Binary-coded_decimal">https://en.wikipedia.org/wiki/Binary-coded_decimal</a>
</li>

<li>Chen–Ho encoding<br />
<a href="https://en.wikipedia.org/wiki/Chen%E2%80%93Ho_encoding">https://en.wikipedia.org/wiki/Chen%E2%80%93Ho_encoding</a>
</li>

<li>Densely packed decimal<br />
<a href="https://en.wikipedia.org/wiki/Densely_packed_decimal">https://en.wikipedia.org/wiki/Densely_packed_decimal</a>
</li>

<li>A Summary of Chen-Ho Decimal Data encoding<br />
<a href="http://speleotrove.com/decimal/chen-ho.html">http://speleotrove.com/decimal/chen-ho.html</a>
</li>

<li>Art of Assembly language programming: The 80x87 Floating Point Coprocessors<br />
<a href="https://courses.engr.illinois.edu/ece390/books/artofasm/CH14/CH14-3.html">https://courses.engr.illinois.edu/ece390/books/artofasm/CH14/CH14-3.html</a>
</li>

<li>Art of Assembly language programming: The FPU Instruction Set<br />
<a href="https://courses.engr.illinois.edu/ece390/books/artofasm/CH14/CH14-4.html">https://courses.engr.illinois.edu/ece390/books/artofasm/CH14/CH14-4.html</a>
</li>

<li>INTEL 80387 PROGRAMMER'S REFERENCE MANUAL<br />
<a href="http://www.ragestorm.net/downloads/387intel.txt">http://www.ragestorm.net/downloads/387intel.txt</a>
</li>

<li>Floating-Point Formats<br />
<a href="http://www.quadibloc.com/comp/cp0201.htm">http://www.quadibloc.com/comp/cp0201.htm</a>
</li>

<li>Floating Point Numbers<br />
<a href="https://floating-point-gui.de/formats/fp/">https://floating-point-gui.de/formats/fp/</a>
</li>

<li>Float exposed<br />
<a href="https://float.exposed/0x40490000">https://float.exposed/0x40490000</a>
</li>

<li>Float Toy<br />
<a href="http://evanw.github.io/float-toy/">http://evanw.github.io/float-toy/</a>
</li>

<li>IEEE-754 visualization<br />
<a href="https://bartaz.github.io/ieee754-visualization/">https://bartaz.github.io/ieee754-visualization/</a>
</li>

<li>IEEE-754 Floating Point Converter<br />
<a href="https://www.h-schmidt.net/FloatConverter/IEEE754.html">https://www.h-schmidt.net/FloatConverter/IEEE754.html</a>
</li>

<li>IEEE 754 Calculator<br />
<a href="http://weitz.de/ieee/">http://weitz.de/ieee/</a>
</li>

<li>IEEE-754 Float Calculator<br />
<a href="https://mason.cc/float/">https://mason.cc/float/</a>
</li>

</ol>



<p></p><p></p>
<p><small>Autor: <a href="http://www.fit.vutbr.cz/~tisnovpa">Pavel Tišnovský</a> &nbsp; 2022</small></p>
</body>
</html>

