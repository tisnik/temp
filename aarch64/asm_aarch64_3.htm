<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
        "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html>
<head>
<title></title>
<meta name="Author" content="Pavel Tisnovsky" />
<meta name="Generator" content="vim" />
<meta http-equiv="content-type" content="text/html; charset=utf-8" />
<style type="text/css">
         body {color:#000000; background:#ffffff;}
         h1  {font-family: arial, helvetica, sans-serif; color:#ffffff; background-color:#c00000; text-align:center; padding-left:1em}
         h2  {font-family: arial, helvetica, sans-serif; color:#ffffff; background-color:#0000c0; padding-left:1em; text-align:left}
         h3  {font-family: arial, helvetica, sans-serif; color:#000000; background-color:#c0c0c0; padding-left:1em; text-align:left}
         h4  {font-family: arial, helvetica, sans-serif; color:#000000; background-color:#e0e0e0; padding-left:1em; text-align:left}
         a   {font-family: arial, helvetica, sans-serif;}
         li  {font-family: arial, helvetica, sans-serif; color:#000000; text-align:justify; width:450px;}
         ol  {font-family: arial, helvetica, sans-serif; color:#000000; text-align:justify; width:450px;}
         ul  {font-family: arial, helvetica, sans-serif; color:#000000; text-align:justify; width:450px;}
         p   {font-family: arial, helvetica, sans-serif; color:#000000; text-align:justify;}
         pre {background:#e0e0e0}
</style>
</head>

<body>

<h1></h1>

<h3>Pavel Tišnovský</h3>

<p></p>

<h1>Úvodník</h1>

<p></p>



<h2>Obsah</h2>

<p><a href="#k01">*** 1. </a></p>
<p><a href="#k02">*** 2. </a></p>
<p><a href="#k03">*** 3. </a></p>
<p><a href="#k04">*** 4. </a></p>
<p><a href="#k05">*** 5. </a></p>
<p><a href="#k06">*** 6. </a></p>
<p><a href="#k07">*** 7. </a></p>
<p><a href="#k08">*** 8. </a></p>
<p><a href="#k09">*** 9. </a></p>
<p><a href="#k10">*** 10. </a></p>
<p><a href="#k11">*** 11. </a></p>
<p><a href="#k12">*** 12. </a></p>
<p><a href="#k13">*** 13. </a></p>
<p><a href="#k14">*** 14. </a></p>
<p><a href="#k15">*** 15. </a></p>
<p><a href="#k16">*** 16. </a></p>
<p><a href="#k17">*** 17. </a></p>
<p><a href="#k18">*** 18. Repositář s&nbsp;demonstračními příklady</a></p>
<p><a href="#k19">*** 19. </a></p>
<p><a href="#k20">*** 20. Odkazy na Internetu</a></p>



<p><a name="k01"></a></p>
<h2 id="k01">1. </h2>

<pre>
</pre>

<pre>
# asmsyntax=as

# Presun bloku dat po jednotlivych bajtech.
#
# Autor: Pavel Tisnovsky



# Linux kernel system call table
sys_exit=93
sys_write=64

# List of syscalls for AArch64:
# https://github.com/torvalds/linux/blob/master/include/uapi/asm-generic/unistd.h

# pocet bajtu pro blokove presuny
rep_count  = 448


# Deklarace makra pro ukonceni aplikace
.macro exit
        mov  x8, #sys_exit      // cislo sycallu pro funkci "exit"
        mov  x0, #0             // exit code = 0
        svc  0                  // volani Linuxoveho kernelu
.endm



# Deklarace makra pro vytisteni zpravy na standardni vystup
.macro writeMessage message,messageLength
        mov  x8, #sys_write       // cislo sycallu pro funkci "write"
        mov  x0, #1               // standardni vystup
        ldr  x1, =\message        // adresa retezce, ktery se ma vytisknout
        mov  x2, #\messageLength  // pocet znaku, ktere se maji vytisknout
        svc  0                    // volani Linuxoveho kernelu
.endm


# Deklarace makra pro presun bloku po bajtech
.macro moveBlockByBytes from, to, length
        ldr   x1, =\from        // adresa bloku pro cteni
        ldr   x2, =\to          // adresa bloku pro zapis
        mov   x4, #\length      // pocet bajtu
loop\@:
        ldrb  w3, [x1], 1       // cteni bajtu
        strb  w3, [x2], 1       // zapis bajtu
        sub   x4, x4, #1        // zmenseni pocitadla
        cbnz  x4, loop\@        // pokud jsme se nedostali k nule, skok na zacatek smycky
.endm


.balign 8

#-----------------------------------------------------------------------------
.section .data

hello_lbl:
        .string "Lorem ipsum dolor sit amet, consectetur adipiscing elit, sed do eiusmod tempor incididunt ut labore et dolore magna aliqua. Ut enim ad minim veniam, quis nostrud exercitation ullamco laboris nisi ut aliquip ex ea commodo consequat. Duis aute irure dolor in reprehenderit in voluptate velit esse cillum dolore eu fugiat nulla pariatur. Excepteur sint occaecat cupidatat non proident, sunt in culpa qui officia deserunt mollit anim id est laborum<pad>"


#-----------------------------------------------------------------------------
.section .bss

        .lcomm buffer, rep_count     // rezervace bufferu pro vystup



#-----------------------------------------------------------------------------
.section .text
        .global _start          // tento symbol ma byt dostupny i linkeru

_start:
        writeMessage buffer, rep_count

        mov   x10, #50000       // pocet opakovani blokoveho presunu
        lsl   x10, x10, #8      // jeste zvetsime pocet opakovani
loop:
        moveBlockByBytes hello_lbl, buffer, rep_count
        sub   x10, x10, #1      // snizeni hodnoty pocitadla
        cbnz  x10, loop         // pokud se nedosahlo nuly, opakovat

        writeMessage buffer, rep_count

        exit
</pre>

<pre>
</pre>

<pre>
</pre>

<p>Ve druhé části dnešního článku se zaměříme prozatím relativně novou oblast. Jedná se o speciální instrukce implementované na moderní mikroprocesorové architektuře AArch64, které prování specifikovanou činnost pouze za předpokladu, že je splněna nějaká zadaná podmínka (kód podmínky je přitom součástí instrukčního slova). Připomeňme si, že na rozdíl od <a href="https://mojefedora.cz/pouziti-assembleru-v-linuxu-podminky-rozvetveni-a-programove-smycky-na-procesorech-arm/">původní 32bitové architektury ARM</a> (dnes označované ARM32) <strong>ne</strong>mají všechny instrukce na AArch64 rezervovány čtyři nejvyšší bity pro specifikaci podmínky. Tato vlastnost byla na základě analýzy existujících programových strojových kódů zrušena a podmínky je tak možné použít jen u vybrané množiny instrukcí. Do této množiny byly zahrnuty i zcela nové instrukce, které na ARM32 nenalezneme, což je opět důsledek analýzy stávajících strojových kódů, ale i studia funkce překladačů.</p>

<p>Poznámka: <a href="http://yarchive.net/comp/carry_bit.html">podle některých vývojářů</a> může mít extenzivní použití příznakových bitů negativní vliv na výkonnost procesoru, což je však téma, které je řešeno nejenom na AArch64, ale i na x86-64.</p>

<p>Připomeňme si, že na procesorové architektuře AArch64 je použito celkem čtrnáct různých podmínek, k&nbsp;nimž se někdy přidává i pseudopodmínka <strong>AL</strong> neboli <i>Any/Always</i>. V&nbsp;tomto případě se samozřejmě o žádnou skutečnou podmínku nejedná, neboť je instrukce provedena v&nbsp;každém případě.</p>

<p>Prvních šest podmínek testuje hodnotu pouze jediného bitového příznaku, a to <strong>N (negative)</strong>, <strong>Z (zero)</strong> či <strong>V (overflow)</strong>:</p>

<table>
<tr><th>Kód</th><th>Přípona</th><th>Význam</th><th>Testovaná podmínka</th></tr>
<tr><td>0000</td><td>EQ</td><td>Z = 1</td><td>rovnost po porovnání (či nulový výsledek)</td></tr>
<tr><td>0001</td><td>NE</td><td>Z = 0</td><td>nerovnost po porovnání (či nenulový výsledek)</td></tr>
<tr><td>0100</td><td>MI</td><td>N = 1</td><td>výsledek je záporný</td></tr>
<tr><td>0101</td><td>PL</td><td>N = 0</td><td>výsledek je kladný či nulový</td></tr>
<tr><td>0110</td><td>VS</td><td>V = 1</td><td>nastalo přetečení (<i>overflow</i>)</td></tr>
<tr><td>0111</td><td>VC</td><td>V = 0</td><td>nenastalo přetečení (<i>overflow</i>)</td></tr>
<tr><td>1110</td><td>AL</td><td>Any/Always</td><td>většinou se nezapisuje, implicitní podmínka</td></tr>
</table>

<p>Další čtyři podmínkové kódy se většinou používají při porovnávání dvou hodnot bez znaménka (<i>unsigned</i>). V&nbsp;těchto případech se testují stavy příznakových bitů <strong>C (carry)</strong> a <strong>Z (zero)</strong>, přesněji řečeno kombinace těchto bitů:</p>

<table>
<tr><th>Kód </th><th>Přípona</th><th>Význam</th><th>Testovaná podmínka</th></tr>
<tr><td>0010</td><td>CS/HS</td><td>C = 1</td><td>&ge;</td></tr>
<tr><td>0011</td><td>CC/LO</td><td>C = 0</td><td>&lt;</td></tr>
<tr><td>1000</td><td>HI</td><td>C = 1 &amp; Z = 0</td><td>&gt;</td></tr>
<tr><td>1001</td><td>LS</td><td>C = 0 | Z = 1 </td><td>&le;</td></tr>
</table>

<p>Poslední čtyři podmínkové kódy se používají pro porovnávání hodnot se znaménkem (<i>signed</i>). V&nbsp;těchto případech se namísto příznakových bitů <strong>(C) carry</strong> a <strong>(Z) zero</strong> testují kombinace bitů <strong>(N) negative</strong>, <strong>(V) overflow</strong> a <strong>(Z) zero</strong>:</p>

<table>
<tr><th>Kód </th><th>Přípona</th><th>Význam</th><th>Testovaná podmínka</th></tr>
<tr><td>1010</td><td>GE</td><td>N == V</td><td>&ge;</td></tr>
<tr><td>1011</td><td>LT</td><td>N &ne; V </td><td>&lt;</td></tr>
<tr><td>1100</td><td>GT</td><td>Z = 0, N = V </td><td>&gt;</td></tr>
<tr><td>1101</td><td>LE</td><td>Z = 1, N &ne; V</td><td>&le;</td></tr>
</table>

<p>Důležité je, že všechny dále popsané instrukce podporují všechny podmínky. Výjimku tvoří minule popsané instrukce <strong>CBZ</strong> a <strong>CBNZ</strong>, které pouze testovaly nulovost či naopak nenulovost vybraného pracovního registru.</p>
<table>
<tr><th>Instrukce</th><th>Stručný popis instrukce</th></tr>
<tr><td>B.podmínka návěští</td><td>podmíněný skok po splnění podmínky na zadané návěští (kódy podmínek byly uvedeny výše)</td></tr>
<tr><td>CBZ Wn, návěští</td><td>pokud platí Wn=0, skok na zadané návěští</td></tr>
<tr><td>CBZ Xn, návěští</td><td>pokud platí Xn=0, skok na zadané návěští</td></tr>
<tr><td>CBNZ Wn, návěští</td><td>pokud platí Wn&ne;0, skok na zadané návěští</td></tr>
<tr><td>CBNZ Xn, návěští</td><td>pokud platí Xn&ne;0, skok na zadané návěští</td></tr>
</table>

<p>Tyto instrukce jsou (ve své variantě s&nbsp;32bitovými registry) zpětně kompatibilní s&nbsp;instrukcemi známými z&nbsp;32bitové architektury ARM32.</p>



<p><a name="k02"></a></p>
<h2 id="k02">2. Nové instrukce s&nbsp;podmínkami</h2>

<p>Mezi nové instrukce s&nbsp;podmínkou, které lze použít na architektuře AArch64, patří především:</p>

<table>
<tr><th>Instrukce</th><th>Význam mnemotechnického kódu</th><th>Kapitola</th></tr>
<tr><td>CSET </td><td>Conditional Set</td><td><a href="#k04">4</a></td></tr>
<tr><td>CSETM</td><td>Conditional Set Mask</td><td><a href="#k05">5</a></td></tr>
<tr><td>CSEL </td><td>Conditional Select</td><td><a href="#k06">6</a></td></tr>
<tr><td>CSINV</td><td>Conditional Select Invert</td><td><a href="#k07">7</a></td></tr>
<tr><td>CSINC</td><td>Conditional Select Increment</td><td><a href="#k08">8</a></td></tr>
<tr><td>CSNEG</td><td>Conditional Select Negate</td><td><a href="#k09">9</a></td></tr>
<tr><td>CINC</td><td>Conditional Increment</td><td><a href="#k10">10</a></td></tr>
<tr><td>CINV</td><td>Conditional Invert</td><td><a href="#k11">11</a></td></tr>
<tr><td>CNEG</td><td>Conditional Negate</td><td><a href="#k12">12</a></td></tr>
<tr><td>TBZ </td><td>Test and Branch if Zero</td><td><a href="#k13">13</a></td></tr>
<tr><td>TBNZ</td><td>Test and Branch if not zero</td><td><a href="#k13">13</a></td></tr>
</table>



<p><a name="k03"></a></p>
<h2 id="k03">3. Instrukce <strong>CSET</strong> &ndash; Conditional Set</h2>

<p>První novou instrukcí, s&nbsp;níž se dnes seznámíme, je instrukce nazvaná <strong>CSET</strong> neboli <i>Conditional Set</i>. Tato instrukce vlastně přímo odpovídá požadavkům kladeným na datový typ <i>boolean</i> v&nbsp;mnoha programovacích jazycích, v&nbsp;nichž je hodnota <i>true</i> interně reprezentována jedničkou a hodnota <i>false</i> nulou. Tato instrukce existuje ve dvou variantách, přičemž první varianta pracuje s&nbsp;32bitovým a druhá varianta s&nbsp;64bitovým operandem):</p>

<pre>
CSET Wd, condition
CSET Xd, condition
</pre>

<p>Například:</p>

<pre>
CSET W3, EQ
CSET W4, MI
CSET X5, HI
</pre>

<p>Tato instrukce pracuje následujícím způsobem &ndash; v&nbsp;případě, že je podmínka zapsaná ve druhém operandu <i>cond</i> splněna, uloží se do cílového registru <strong>Wd</strong> či do registru <strong>Xd</strong> hodnota 1. Pokud podmínka naopak splněna není, uloží se do registru <strong>Wd</strong> či <strong>Xd</strong> hodnota 0:</p>

<pre>
cíl = condition ? 1 : 0;
</pre>

<p>Ve skutečnosti se v&nbsp;případě <strong>CSET</strong> jedná o alias pro instrukci <strong>CSINC</strong> popsanou dále (podmínka ovšem musí být v&nbsp;tomto případě negována):</p>

<pre>
CSINC Wd, WZR, WZR, invert(condition)
CSINC Xd, XZR, XZR, invert(condition)
</pre>

<p>neboli:</p>

<pre>
cíl = invert(condition) ? 0 : 0+1;
</pre>



<p><a name="k04"></a></p>
<h2 id="k04">4. Demonstrační příklad</h2>



<p><a name="k05"></a></p>
<h2 id="k05">5. Instrukce <strong>CSETM</strong> &ndash; Conditional Set Mask</h2>

<p>V&nbsp;některých případech je nutné ukládat pravdivostní hodnoty odlišným způsobem &ndash; <i>true</i> bude reprezentováno hodnotou, v&nbsp;níž jsou všechny bity nastaveny na jedničku (v&nbsp;případě celých čísel se znaménkem to odpovídá hodnotě -1), <i>false</i> naopak hodnotou, v&nbsp;níž jsou všechny bity nulové. V&nbsp;tomto případě lze pro nastavení použít instrukci <strong>CSETM</strong>:</p>

<pre>
CSETM Wd, condition
CSETM Xd, condition
</pre>

<p>Ve vyšším programovacím jazyce by bylo možné napsat:</p>

<pre>
cíl = condition ? -1 : 0;
</pre>

<p>Poznámka: u 32bitového registru odpovídá -1 hodnotě 0xffff&nbsp;ffff, u 64bitového registru pak hodnotě 0xffff&nbsp;ffff&nbsp;ffff&nbsp;ffff.</p>

<p>Opět se jedná o aliasy, tentokrát ovšem na instrukci <strong>CSINV</strong>:</p>

<pre>
CSINV Wd, WZR, WZR, invert(condition)
CSINV Xd, XZR, XZR, invert(condition)
</pre>

<p>Poznámka: slovo &bdquo;mask&ldquo; v&nbsp;názvu instrukce skutečně poměrně přesně odpovídá jednomu způsobu použití, protože pokud platí <i>true=-1</i> a <i>false=0</i>, lze s&nbsp;těmito hodnotami provádět logický součin a součet bit po bitu, a to i v&nbsp;případě, kdy je druhým operandem odlišná hodnota.</p>



<p><a name="k06"></a></p>
<h2 id="k06">6. </h2>



<p><a name="k07"></a></p>
<h2 id="k07">7. Instrukce <strong>CSEL</strong> &ndash; Conditional Select</h2>

<p>Další užitečnou instrukcí s&nbsp;podmínkou je instrukce zapisovaná mnemotechnickým kódem <strong>CSEL</strong> neboli <i>Conditional Select</i>. I tato instrukce existuje ve dvou variantách &ndash; 32bitové a 64bitové:</p>

<pre>
CSEL Wd, Wn, Wm, condition
CSEL Xd, Xn, Xm, condition
</pre>

<p>Tato instrukce pracuje následovně: pokud je podmínka splněna, uloží se do cílového registru <strong>Wd</strong> či <strong>Xd</strong> hodnota z&nbsp;prvního zdrojového registru <strong>Wn</strong> nebo <strong>Xn</strong>. Pokud podmínka splněna není, je do cílového registru <strong>Wd/Xd</strong> uložena hodnota z&nbsp;druhého zdrojového registru <strong>Wm/Xm</strong>.</p>

<p>Instrukce <strong>CSEL</strong> tedy nahrazuje programovou konstrukci typu:</p>

<pre>
cíl = condition ? zdroj1 : zdroj2;
</pre>



<p><a name="k08"></a></p>
<h2 id="k08">8. </h2>



<p><a name="k09"></a></p>
<h2 id="k09">9. Instrukce <strong>CSINV</strong> &ndash; Conditional Select Invert</h2>

<p>Alternativní formou instrukce <strong>CSEL</strong> je instrukce <strong>CSINV</strong> neboli <i>Conditional Select Invert</i>:</p>

<pre>
CSINV Wd, Wn, Wm, condition
CSINV Xd, Xn, Xm, condition
</pre>

<p>Tato instrukce pracuje následovně: pokud je podmínka splněna, uloží se do cílového registru <strong>Wd</strong> či <strong>Xd</strong> hodnota z&nbsp;prvního zdrojového registru <strong>Wn</strong> nebo <strong>Xn</strong>. Pokud podmínka splněna není, je do cílového registru <strong>Wd/Xd</strong> uložena negovaná hodnota přečtená z&nbsp;druhého zdrojového registru <strong>Wm/Xm</strong>.</p>

<p>Instrukce <strong>CSINV</strong> tedy nahrazuje programovou konstrukci typu:</p>

<pre>
cíl = condition ? zdroj1 : ~zdroj2;
</pre>

<p>Poznámka: znak ~ je používán v&nbsp;programovacím jazyku C a od něj odvozených jazycích pro zápis unárního operátoru negace všech bitů (jedničkový doplněk).</p>



<p><a name="k10"></a></p>
<h2 id="k10">10. </h2>



<p><a name="k11"></a></p>
<h2 id="k11">11. Instrukce <strong>CSINC</strong> &ndash; Conditional Select Increment</h2>

<p>Zajímavá je instrukce <strong>CSINC</strong>, která kombinuje možnosti instrukce <strong>CINC</strong> a <strong>CSEL</strong>:</p>

<pre>
CSINC Wd, Wn, Wm, condition
CSINC Xd, Xn, Xm, condition
</pre>

<p>Tato instrukce provádí následující činnost:</p>

<pre>
Wd = condition ? Wn : Wm+1;
Xd = condition ? Xn : Xm+1;
</pre>

<p>Jak jsme si již řekli <a href="#k04">ve čtvrté kapitole</a>, je touto instrukcí realizována i pseudoinstrukce <strong>CSET</strong>, a to tehdy, pokud jsou oba zdrojové registry nulové (<strong>WZR</strong> a <strong>XZR</strong>). V&nbsp;tomto případě se do cílového registru dosadí 0 či 0+1=1:</p>

<pre>
CSINC Wd, WZR, WZR, invert(condition)
CSINC Xd, XZR, XZR, invert(condition)
</pre>



<p><a name="k12"></a></p>
<h2 id="k12">12. </h2>



<p><a name="k13"></a></p>
<h2 id="k13">13. Instrukce <strong>CSNEG</strong> &ndash; Conditional Select Negate</h2>

<p>Instrukce nazvaná <strong>CSNEG</strong> se do jisté míry podobá instrukci <strong>CSINV</strong>, ovšem s&nbsp;tím rozdílem, že se namísto jedničkového doplňku (negace) používá při nesplnění podmínky dvojkový doplněk:</p>

<pre>
CSNEG Wd, Wn, Wm, condition
CSNEG Xd, Xn, Xm, condition
</pre>

<p>Tato instrukce pracuje následovně: pokud je podmínka splněna, uloží se do cílového registru <strong>Wd</strong> či <strong>Xd</strong> hodnota z&nbsp;prvního zdrojového registru <strong>Wn</strong> nebo <strong>Xn</strong>. Pokud podmínka splněna není, je do cílového registru <strong>Wd/Xd</strong> uložena hodnota přečtená z&nbsp;druhého zdrojového registru <strong>Wm/Xm</strong>, u které se nejdříve změní znaménko (onen zmíněný dvojkový doplněk).</p>

<p>Tato instrukce tedy nahrazuje programovou konstrukci typu:</p>

<pre>
cíl = condition ? zdroj1 : -zdroj2;
</pre>



<p><a name="k14"></a></p>
<h2 id="k14">14. Instrukce <strong>CINC</strong> &ndash; Conditional Increment</h2>

<p>Instrukce <strong>CINC</strong> je aliasem pro instrukci <strong>CSINC</strong>, ovšem s&nbsp;převrácenou podmínkou a shodnými zdrojovými registry:</p>

<pre>
CINC Wd, Wn, condition
CINC Xd, Xn, condition
</pre>

<p>Tato instrukce provádí následující činnost (je zde jen jediný zdrojový registr):</p>

<pre>
Wd = condition ? Wn+1 : Wn;
Xd = condition ? Xn+1 : Xn;
</pre>

<p>Použití této instrukce je různé, může se například použít pro realizaci příkazu <strong>continue</strong> v&nbsp;programovacím jazyku C.</p>



<p><a name="k15"></a></p>
<h2 id="k15">15. Instrukce <strong>CINV</strong> &ndash; Conditional Invert</h2>

<p>Podobná instrukce taktéž s&nbsp;jedním zdrojovým registrem se jmenuje <strong>CINV</strong>:</p>

<pre>
CINV Wd, Wn, condition
CINV Xd, Xn, condition
</pre>

<p>Prováděná činnost je následující (tilda znamená negaci bit po bitu):</p>

<pre>
Wd = condition ? ~Wn : Wn;
Xd = condition ? ~Xn : Xn;
</pre>

<p>Ve skutečnosti se opět jedná o instrukční alias rozpoznávaný assemblery. V&nbsp;tomto případě lze <strong>CINV</strong> nahradit instrukcí <strong>CSINV</strong> s&nbsp;oběma zdrojovými registry totožnými:</p>

<pre>
CSINV Wd, Wn, Wn, invert(condition)
CSINV Xd, Xn, Xn, invert(condition)
</pre>



<p><a name="k16"></a></p>
<h2 id="k16">16. Instrukce <strong>CNEG</strong> &ndash; Conditional Negate</h2>

<p>Poslední instrukce, přesněji řečeno (opět) instrukční alias se jmenuje <strong>CNEG</strong>:</p>

<pre>
CNEG Wd, Wn, condition
CNEG Xd, Xn, condition
</pre>

<p>Prováděná činnost:</p>

<pre>
Wd = condition ? -Wn : Wn;
Xd = condition ? -Xn : Xn;
</pre>

<p>Tento alias lze nahradit za <strong>CSNEG</strong> s&nbsp;totožnými zdrojovými registry a opačně zapsanou podmínkou:</p>

<pre>
CSNEG Wd, Wn, Wn, invert(condition)
CSNEG Xd, Xn, Xn, invert(condition)
</pre>



<p><a name="k17"></a></p>
<h2 id="k17">17. Instrukce <strong>TBZ</strong> a <strong>TBNZ</strong> (Test and Branch...)</h2>

<p>Poslední dvě instrukce, které si dnes popíšeme, spadají do kategorie podmíněných skoků. Tyto instrukce se jmenují <strong>TBZ</strong> (<i>Test and Branch if Zero</i>) a <strong>TBNZ</strong> (<i>Test and Branch if Not Zero</i>). Způsob zápisu těchto instrukcí je následující:</p>

<pre>
TBZ  Xn, #konstanta, návěští
TBZ  Wn, #konstanta, návěští
TBNZ Xn, #konstanta, návěští
TBNZ Wn, #konstanta, návěští
</pre>

<p>Konstanta má šířku pouze šest bitů, protože je v&nbsp;ní uložen index bitu pracovního registru, který se testuje na nulu či jedničku (u registrů Wn by stačilo jen pět bitů). V&nbsp;případě instrukce <strong>TBZ</strong> &ndash; pokud je n-tý bit registru <strong>Xn/Wn</strong> nastavený na nulu, provede se skok, v&nbsp;opačném případě se řízení přenese na další instrukci. V&nbsp;případě instrukce <strong>TBNZ</strong> je bit testován na nulu. Vzhledem k&nbsp;tomu, že v&nbsp;instrukčním slovu je nutné kromě adresy cíle (návěští) specifikovat i číslo pracovního registru a index bitu, je tento typ skoku omezen na rozsah &pm;32kB, což by ovšem v&nbsp;praxi mělo být více než dostačující (v&nbsp;opačném případě lze <strong>TBZ/TBNZ</strong> zkombinovat s&nbsp;absolutním skokem <strong>B</strong>).</p>


<p><a name="k18"></a></p>
<h2 id="k18">18. Repositář s&nbsp;demonstračními příklady</h2>

<p>Všechny dnes popisované demonstrační příklady byly společně s&nbsp;podpůrným
souborem <strong>Makefile</strong> určeným pro jejich překlad či naopak pro
disassembling, uloženy do GIT repositáře dostupného na adrese <a
href="https://github.com/tisnik/presentations/">https://github.com/tisnik/presentations/</a>.
Všechny příklady jsou určeny pro GNU Assembler a používají výchozí syntaxi
procesorů Aarch64. Následuje tabulka s&nbsp;odkazy na zdrojové kódy příkladů i
na již zmíněné podpůrné skripty:</p>

<table>
<tr><th>Příklad</th><th>Popis</th><th>Zdrojový kód</th></tr>
<tr><td>template.s</td><td>šablona pro programy psané v&nbsp;assembleru</td><td><a href="https://github.com/tisnik/presentations/blob/master/assembler/aarch64/template.s">https://github.com/tisnik/presentations/blob/master/assembler/aarch64/template.s</a></td></tr>
<tr><td>template_2.s</td><td>šablona pro programy psané v&nbsp;assembleru, založeno na makrech</td><td><a href="https://github.com/tisnik/presentations/blob/master/assembler/aarch64/template_2.s">https://github.com/tisnik/presentations/blob/master/assembler/aarch64/template_2.s</a></td></tr>
<tr><td>hello_world_1.s</td><td>základní podoba programu typu &bdquo;Hello, world!&ldquo;</td><td><a href="https://github.com/tisnik/presentations/blob/master/assembler/aarch64/hello_world_1.s">https://github.com/tisnik/presentations/blob/master/assembler/aarch64/hello_world_1.s</a></td></tr>
<tr><td>hello_world_2.s</td><td>přepis tištěného řetězce</td><td><a href="https://github.com/tisnik/presentations/blob/master/assembler/aarch64/hello_world_2.s">https://github.com/tisnik/presentations/blob/master/assembler/aarch64/hello_world_2.s</a></td></tr>
<tr><td>hello_world_3.s</td><td>refaktoring, použití maker</td><td><a href="https://github.com/tisnik/presentations/blob/master/assembler/aarch64/hello_world_3.s">https://github.com/tisnik/presentations/blob/master/assembler/aarch64/hello_world_3.s</a></td></tr>
<tr><td>aritmetic1.s</td><td>základní aritmetické operace</td><td><a href="https://github.com/tisnik/presentations/blob/master/assembler/aarch64/aritmetic1.s">https://github.com/tisnik/presentations/blob/master/assembler/aarch64/aritmetic1.s</a></td></tr>
<tr><td>infinite_loop.s</td><td>nekonečná programová smyčka realizovaná instrukcí <strong>b</strong></td><td><a href="https://github.com/tisnik/presentations/blob/master/assembler/aarch64/infinite_loop.s">https://github.com/tisnik/presentations/blob/master/assembler/aarch64/infinite_loop.s</a></td></tr>
<tr><td>loop1-aarch64-v1.s</td><td>základní varianta počítané programové smyčky</td><td><a href="https://github.com/tisnik/presentations/blob/master/assembler/aarch64/loop1-aarch64-v1.s">https://github.com/tisnik/presentations/blob/master/assembler/aarch64/loop1-aarch64-v1.s</a></td></tr>
<tr><td>loop1-aarch64-v2.s</td><td>optimalizace &ndash; odstranění instrukce <strong>CMP</strong></td><td><a href="https://github.com/tisnik/presentations/blob/master/assembler/aarch64/loop1-aarch64-v2.s">https://github.com/tisnik/presentations/blob/master/assembler/aarch64/loop1-aarch64-v2.s</a></td></tr>
<tr><td>loop1-aarch64-v3.s</td><td>optimalizace &ndash; použití instrukce <strong>CBNZ</strong></td><td><a href="https://github.com/tisnik/presentations/blob/master/assembler/aarch64/loop1-aarch64-v3.s">https://github.com/tisnik/presentations/blob/master/assembler/aarch64/loop1-aarch64-v3.s</a></td></tr>
<tr><td>loop1-aarch64-v4.s</td><td>automatické zvýšení adresy (ukazatele)</td><td><a href="https://github.com/tisnik/presentations/blob/master/assembler/aarch64/loop1-aarch64-v4.s">https://github.com/tisnik/presentations/blob/master/assembler/aarch64/loop1-aarch64-v4.s</a></td></tr>
<tr><td>move1.s</td><td>přesun bloku dat</td><td><a href="https://github.com/tisnik/presentations/blob/master/assembler/aarch64/move1.s">https://github.com/tisnik/presentations/blob/master/assembler/aarch64/move1.s</a></td></tr>
<tr><td>move2.s</td><td>přepis s&nbsp;využitím maker</td><td><a href="https://github.com/tisnik/presentations/blob/master/assembler/aarch64/move2.s">https://github.com/tisnik/presentations/blob/master/assembler/aarch64/move2.s</a></td></tr>
<tr><td>move3.s</td><td>problém s&nbsp;vícenásobným použitím makra</td><td><a href="https://github.com/tisnik/presentations/blob/master/assembler/aarch64/move3.s">https://github.com/tisnik/presentations/blob/master/assembler/aarch64/move3.s</a></td></tr>
<tr><td>move4.s</td><td>vyřešení předchozího problému</td><td><a href="https://github.com/tisnik/presentations/blob/master/assembler/aarch64/move4.s">https://github.com/tisnik/presentations/blob/master/assembler/aarch64/move4.s</a></td></tr>
<tr><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td></tr>
<tr><td>Makefile</td><td>soubor pro překlad všech příkladů nástrojem <strong>make</strong></td><td><a href="https://github.com/tisnik/presentations/blob/master/assembler/aarch64/Makefile">https://github.com/tisnik/presentations/blob/master/assembler/aarch64/Makefile</a></td></tr>
</table>



<p><a name="k19"></a></p>
<h2 id="k19">19. Předchozí články o architektuře AArch64</h2>

<p>S&nbsp;architekturou AArch64 jsme se již na stránkách Roota setkali, a to
konkrétně v&nbsp;následující pětici článků, z&nbsp;nichž dnes vycházíme:</p>

<ol>

<li>64bitové mikroprocesory s architekturou AArch64<br />
<a href="https://www.root.cz/clanky/64bitove-mikroprocesory-s-architekturou-aarch64/">https://www.root.cz/clanky/64bitove-mikroprocesory-s-architekturou-aarch64/</a>
</li>

<li>Instrukční sada AArch64<br />
<a href="https://www.root.cz/clanky/instrukcni-sada-aarch64/">https://www.root.cz/clanky/instrukcni-sada-aarch64/</a>
</li>

<li>Instrukční sada AArch64 (2.část)<br />
<a href="https://www.root.cz/clanky/instrukcni-sada-aarch64-2-cast/">https://www.root.cz/clanky/instrukcni-sada-aarch64-2-cast/</a>
</li>

<li>Tvorba a ladění programů v&nbsp;assembleru mikroprocesorů AArch64<br />
<a href="https://www.root.cz/clanky/tvorba-a-ladeni-programu-v-assembleru-mikroprocesoru-aarch64/">https://www.root.cz/clanky/tvorba-a-ladeni-programu-v-assembleru-mikroprocesoru-aarch64/</a>
</li>

<li>Instrukční sada AArch64: technologie NEON<br />
<a href="https://www.root.cz/clanky/instrukcni-sada-aarch64-technologie-neon/">https://www.root.cz/clanky/instrukcni-sada-aarch64-technologie-neon/</a>
</li>

</ol>



<p><a name="k20"></a></p>
<h2 id="k20">20. Odkazy na Internetu</h2>

<ol>

<li>Arm Architecture Reference Manual for A-profile architecture<br />
<a href="https://developer.arm.com/documentation/ddi0487/latest">https://developer.arm.com/documentation/ddi0487/latest</a>
</li>

<li>The GNU Assembler - macros<br />
<a href="http://tigcc.ticalc.org/doc/gnuasm.html#SEC109">http://tigcc.ticalc.org/doc/gnuasm.html#SEC109</a>
</li>

<li>GNU Binutils<br />
<a href="https://sourceware.org/binutils/">https://sourceware.org/binutils/</a>
</li>

<li>Documentation for binutils 2.38<br />
<a href="https://sourceware.org/binutils/docs-2.38/">https://sourceware.org/binutils/docs-2.38/</a>
</li>

<li>AArch64 Instruction Set Architecture<br />
<a href="https://developer.arm.com/architectures/learn-the-architecture/aarch64-instruction-set-architecture/instruction-sets-in-the-arm-architecture">https://developer.arm.com/architectures/learn-the-architecture/aarch64-instruction-set-architecture/instruction-sets-in-the-arm-architecture</a>
</li>

<li>Arm Armv8-A A32/T32 Instruction Set Architecture<br />
<a href="https://developer.arm.com/documentation/ddi0597/2021-12/?lang=en">https://developer.arm.com/documentation/ddi0597/2021-12/?lang=en</a>
</li>

<li>Comparison of ARMv8-A cores<br />
<a href="https://en.wikipedia.org/wiki/Comparison_of_ARMv8-A_cores">https://en.wikipedia.org/wiki/Comparison_of_ARMv8-A_cores</a>
</li>

<li>Cortex-A32 Processor<br />
<a href="https://www.arm.com/products/processors/cortex-a/cortex-a32-processor.php">https://www.arm.com/products/processors/cortex-a/cortex-a32-processor.php</a>
</li>

<li>Cortex-A35 Processor<br />
<a href="https://www.arm.com/products/processors/cortex-a/cortex-a35-processor.php">https://www.arm.com/products/processors/cortex-a/cortex-a35-processor.php</a>
</li>

<li>Cortex-A53 Processor<br />
<a href="https://www.arm.com/products/processors/cortex-a/cortex-a53-processor.php">https://www.arm.com/products/processors/cortex-a/cortex-a53-processor.php</a>
</li>

<li>Cortex-A57 Processor<br />
<a href="https://www.arm.com/products/processors/cortex-a/cortex-a57-processor.php">https://www.arm.com/products/processors/cortex-a/cortex-a57-processor.php</a>
</li>

<li>Cortex-A72 Processor<br />
<a href="https://www.arm.com/products/processors/cortex-a/cortex-a72-processor.php">https://www.arm.com/products/processors/cortex-a/cortex-a72-processor.php</a>
</li>

<li>Cortex-A73 Processor<br />
<a href="https://www.arm.com/products/processors/cortex-a/cortex-a73-processor.php">https://www.arm.com/products/processors/cortex-a/cortex-a73-processor.php</a>
</li>

<li>Apple A7 (SoC založen na CPU Cyclone)<br />
<a href="https://en.wikipedia.org/wiki/Apple_A7">https://en.wikipedia.org/wiki/Apple_A7</a>
</li>

<li>System cally pro AArch64 na Linuxu<br />
<a href="https://github.com/torvalds/linux/blob/master/include/uapi/asm-generic/unistd.h">https://github.com/torvalds/linux/blob/master/include/uapi/asm-generic/unistd.h</a>
</li>

<li>Architectures/AArch64 (FedoraProject.org)<br />
<a href="https://fedoraproject.org/wiki/Architectures/AArch64">https://fedoraproject.org/wiki/Architectures/AArch64</a>
</li>

<li>SIG pro AArch64 (CentOS)<br />
<a href="https://wiki.centos.org/SpecialInterestGroup/AltArch/AArch64">https://wiki.centos.org/SpecialInterestGroup/AltArch/AArch64</a>
</li>

<li>The ARMv8 instruction sets<br />
<a href="http://infocenter.arm.com/help/index.jsp?topic=/com.arm.doc.den0024a/ch05s01.html">http://infocenter.arm.com/help/index.jsp?topic=/com.arm.doc.den0024a/ch05s01.html</a>
</li>

<li>A64 Instruction Set<br />
<a href="https://developer.arm.com/products/architecture/instruction-sets/a64-instruction-set">https://developer.arm.com/products/architecture/instruction-sets/a64-instruction-set</a>
</li>

<li>Switching between the instruction sets<br />
<a href="http://infocenter.arm.com/help/index.jsp?topic=/com.arm.doc.den0024a/ch05s01.html">http://infocenter.arm.com/help/index.jsp?topic=/com.arm.doc.den0024a/ch05s01.html</a>
</li>

<li>The A64 instruction set<br />
<a href="http://infocenter.arm.com/help/index.jsp?topic=/com.arm.doc.den0024a/ch05s01.html">http://infocenter.arm.com/help/index.jsp?topic=/com.arm.doc.den0024a/ch05s01.html</a>
</li>

<li>Introduction to ARMv8 64-bit Architecture<br />
<a href="https://quequero.org/2014/04/introduction-to-arm-architecture/">https://quequero.org/2014/04/introduction-to-arm-architecture/</a>
</li>

<li>MCU market turns to 32-bits and ARM<br />
<a href="http://www.eetimes.com/document.asp?doc_id=1280803">http://www.eetimes.com/document.asp?doc_id=1280803</a>
</li>

<li>Cortex-M0 Processor (ARM Holdings)<br />
<a href="http://www.arm.com/products/processors/cortex-m/cortex-m0.php">http://www.arm.com/products/processors/cortex-m/cortex-m0.php</a>
</li>

<li>Cortex-M0+ Processor (ARM Holdings)<br />
<a href="http://www.arm.com/products/processors/cortex-m/cortex-m0plus.php">http://www.arm.com/products/processors/cortex-m/cortex-m0plus.php</a>
</li>

<li>ARM Processors in a Mixed Signal World<br />
<a href="http://www.eeweb.com/blog/arm/arm-processors-in-a-mixed-signal-world">http://www.eeweb.com/blog/arm/arm-processors-in-a-mixed-signal-world</a>
</li>

<li>ARM Architecture (Wikipedia)<br />
<a href="https://en.wikipedia.org/wiki/ARM_architecture">https://en.wikipedia.org/wiki/ARM_architecture</a>
</li>

<li>DSP for Cortex-M<br />
<a href="https://developer.arm.com/technologies/dsp/dsp-for-cortex-m">https://developer.arm.com/technologies/dsp/dsp-for-cortex-m</a>
</li>

<li>Cortex-M processors in DSP applications? Why not?!<br />
<a href="https://community.arm.com/processors/b/blog/posts/cortex-m-processors-in-dsp-applications-why-not">https://community.arm.com/processors/b/blog/posts/cortex-m-processors-in-dsp-applications-why-not</a>
</li>

<li>White Paper - DSP capabilities of Cortex-M4 and Cortex-M7<br />
<a href="https://community.arm.com/processors/b/blog/posts/white-paper-dsp-capabilities-of-cortex-m4-and-cortex-m7">https://community.arm.com/processors/b/blog/posts/white-paper-dsp-capabilities-of-cortex-m4-and-cortex-m7</a>
</li>

<li>Q (number format)<br />
<a href="https://en.wikipedia.org/wiki/Q_%28number_format%29">https://en.wikipedia.org/wiki/Q_%28number_format%29</a>
</li>

<li>TriCore Architecture &amp; Core<br />
<a href="http://www.infineon.com/cms/en/product/microcontroller/32-bit-tricore-tm-microcontroller/tricore-tm-architecture-and-core/channel.html?channel=ff80808112ab681d0112ab6b73d40837">http://www.infineon.com/cms/en/product/microcontroller/32-bit-tricore-tm-microcontroller/tricore-tm-architecture-and-core/channel.html?channel=ff80808112ab681d0112ab6b73d40837</a>
</li>

<li>TriCoreTM V1.6 Instruction Set: 32-bit Unified Processor Core<br />
<a href="http://www.infineon.com/dgdl/tc_v131_instructionset_v138.pdf?fileId=db3a304412b407950112b409b6dd0352">http://www.infineon.com/dgdl/tc_v131_instructionset_v138.pdf?fileId=db3a304412b407950112b409b6dd0352</a>
</li>

<li>TriCore v2.2 C Compiler, Assembler, Linker Reference Manual<br />
<a href="http://tasking.com/support/tricore/tc_reference_guide_v2.2.pdf">http://tasking.com/support/tricore/tc_reference_guide_v2.2.pdf</a>
</li>

<li>Infineon TriCore (Wikipedia)<br />
<a href="https://en.wikipedia.org/wiki/Infineon_TriCore">https://en.wikipedia.org/wiki/Infineon_TriCore</a>
</li>

<li>C166®S V2 Architecture &amp; Core<br />
<a href="http://www.infineon.com/cms/en/product/microcontroller/16-bit-c166-microcontroller/c166-s-v2-architecture-and-core/channel.html?channel=db3a304312bef5660112c3011c7d01ae">http://www.infineon.com/cms/en/product/microcontroller/16-bit-c166-microcontroller/c166-s-v2-architecture-and-core/channel.html?channel=db3a304312bef5660112c3011c7d01ae</a>
</li>

<li>Comparing four 32-bit soft processor cores<br />
<a href="http://www.eetimes.com/author.asp?section_id=14&doc_id=1286116">http://www.eetimes.com/author.asp?section_id=14&doc_id=1286116</a>
</li>

<li>RISC-V Instruction Set<br />
<a href="http://riscv.org/download.html#spec_compressed_isa">http://riscv.org/download.html#spec_compressed_isa</a>
</li>

<li>RISC-V Spike (ISA Simulator)<br />
<a href="http://riscv.org/download.html#isa-sim">http://riscv.org/download.html#isa-sim</a>
</li>

<li>RISC-V (Wikipedia)<br />
<a href="https://en.wikipedia.org/wiki/RISC-V">https://en.wikipedia.org/wiki/RISC-V</a>
</li>

<li>David Patterson (Wikipedia)<br />
<a href="https://en.wikipedia.org/wiki/David_Patterson_(computer_scientist)">https://en.wikipedia.org/wiki/David_Patterson_(computer_scientist)</a>
</li>

<li>OpenRISC (oficiální stránky projektu)<br />
<a href="http://openrisc.io/">http://openrisc.io/</a>
</li>

<li>OpenRISC architecture<br />
<a href="http://openrisc.io/architecture.html">http://openrisc.io/architecture.html</a>
</li>

<li>Emulátor OpenRISC CPU v JavaScriptu<br />
<a href="http://s-macke.github.io/jor1k/demos/main.html">http://s-macke.github.io/jor1k/demos/main.html</a>
</li>

<li>OpenRISC (Wikipedia)<br />
<a href="https://en.wikipedia.org/wiki/OpenRISC">https://en.wikipedia.org/wiki/OpenRISC</a>
</li>

<li>OpenRISC - instrukce<br />
<a href="http://sourceware.org/cgen/gen-doc/openrisc-insn.html">http://sourceware.org/cgen/gen-doc/openrisc-insn.html</a>
</li>

<li>OpenRISC - slajdy z přednášky o projektu<br />
<a href="https://iis.ee.ethz.ch/~gmichi/asocd/lecturenotes/Lecture6.pdf">https://iis.ee.ethz.ch/~gmichi/asocd/lecturenotes/Lecture6.pdf</a>
</li>

<li>Berkeley RISC<br />
<a href="http://en.wikipedia.org/wiki/Berkeley_RISC">http://en.wikipedia.org/wiki/Berkeley_RISC</a>
</li>

<li>Great moments in microprocessor history<br />
<a href="http://www.ibm.com/developerworks/library/pa-microhist.html">http://www.ibm.com/developerworks/library/pa-microhist.html</a>
</li>

<li>Microprogram-Based Processors<br />
<a href="http://research.microsoft.com/en-us/um/people/gbell/Computer_Structures_Principles_and_Examples/csp0167.htm">http://research.microsoft.com/en-us/um/people/gbell/Computer_Structures_Principles_and_Examples/csp0167.htm</a>
</li>

<li>Great Microprocessors of the Past and Present<br />
<a href="http://www.cpushack.com/CPU/cpu1.html">http://www.cpushack.com/CPU/cpu1.html</a>
</li>

<li>A Brief History of Microprogramming<br />
<a href="http://www.cs.clemson.edu/~mark/uprog.html">http://www.cs.clemson.edu/~mark/uprog.html</a>
</li>

<li>What is RISC?<br />
<a href="http://www-cs-faculty.stanford.edu/~eroberts/courses/soco/projects/2000-01/risc/whatis/">http://www-cs-faculty.stanford.edu/~eroberts/courses/soco/projects/2000-01/risc/whatis/</a>
</li>

<li>RISC vs. CISC<br />
<a href="http://www-cs-faculty.stanford.edu/~eroberts/courses/soco/projects/2000-01/risc/risccisc/">http://www-cs-faculty.stanford.edu/~eroberts/courses/soco/projects/2000-01/risc/risccisc/</a>
</li>

<li>RISC and CISC definitions:<br />
<a href="http://www.cpushack.com/CPU/cpuAppendA.html">http://www.cpushack.com/CPU/cpuAppendA.html</a>
</li>

<li>FPGA<br />
<a href="https://cs.wikipedia.org/wiki/Programovateln%C3%A9_hradlov%C3%A9_pole">https://cs.wikipedia.org/wiki/Programovateln%C3%A9_hradlov%C3%A9_pole</a>
</li>

<li>The Evolution of RISC<br />
<a href="http://www.ibm.com/developerworks/library/pa-microhist.html#sidebar1">http://www.ibm.com/developerworks/library/pa-microhist.html#sidebar1</a>
</li>

<li>disasm.pro<br />
<a href="https://disasm.pro/">https://disasm.pro/</a>
</li>

<li>Exploring AArch64 assembler &ndash; Chapter 5<br />
<a href="https://thinkingeek.com/2016/11/13/exploring-aarch64-assembler-chapter-5/">https://thinkingeek.com/2016/11/13/exploring-aarch64-assembler-chapter-5/</a>
</li>

</ol>



<p></p><p></p>
<p><small>Autor: <a href="http://www.fit.vutbr.cz/~tisnovpa">Pavel Tišnovský</a> &nbsp; 2022</small></p>
</body>
</html>

