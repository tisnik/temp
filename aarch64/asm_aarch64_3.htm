<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
        "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html>
<head>
<title></title>
<meta name="Author" content="Pavel Tisnovsky" />
<meta name="Generator" content="vim" />
<meta http-equiv="content-type" content="text/html; charset=utf-8" />
<style type="text/css">
         body {color:#000000; background:#ffffff;}
         h1  {font-family: arial, helvetica, sans-serif; color:#ffffff; background-color:#c00000; text-align:center; padding-left:1em}
         h2  {font-family: arial, helvetica, sans-serif; color:#ffffff; background-color:#0000c0; padding-left:1em; text-align:left}
         h3  {font-family: arial, helvetica, sans-serif; color:#000000; background-color:#c0c0c0; padding-left:1em; text-align:left}
         h4  {font-family: arial, helvetica, sans-serif; color:#000000; background-color:#e0e0e0; padding-left:1em; text-align:left}
         a   {font-family: arial, helvetica, sans-serif;}
         li  {font-family: arial, helvetica, sans-serif; color:#000000; text-align:justify; width:450px;}
         ol  {font-family: arial, helvetica, sans-serif; color:#000000; text-align:justify; width:450px;}
         ul  {font-family: arial, helvetica, sans-serif; color:#000000; text-align:justify; width:450px;}
         p   {font-family: arial, helvetica, sans-serif; color:#000000; text-align:justify;}
         pre {background:#e0e0e0}
</style>
</head>

<body>

<h1></h1>

<h3>Pavel Tišnovský</h3>

<p></p>

<h1>Úvodník</h1>

<p>Třetí článek o specifických vlastnostech instrukční sady procesorů AArch64 je věnován dvěma důležitým tématům: přenosům dat a taktéž problematice provedení některých operací za předpokladu, že je splněna nějaká podmínka. AArch64 nabízí kromě podmíněných skoků i celou řadu dalších instrukcí.</p>



<h2>Obsah</h2>

<p><a href="#k01">1. Problematika blokových přenosů dat</a></p>
<p><a href="#k02">2. Blokový přenos po jednotlivých bajtech</a></p>
<p><a href="#k03">3. Blokový přenos po 64bitových slovech</a></p>
<p><a href="#k04">*** 4. Přenos po dvojici 64bitových slov &ndash; instrukce <strong>LDP</strong> a <strong>STP</strong></a></p>
<p><a href="#k05">*** 5. Výsledky benchmarků</a></p>
<p><a href="#k06">6. Problematika provedení instrukcí při splnění určité podmínky</a></p>
<p><a href="#k07">*** 7. Nové instrukce s&nbsp;podmínkami</a></p>
<p><a href="#k08">8. Instrukce <strong>CSET</strong> &ndash; Conditional Set</a></p>
<p><a href="#k09">9. Instrukce <strong>CSETM</strong> &ndash; Conditional Set Mask</a></p>
<p><a href="#k10">10. Instrukce <strong>CSEL</strong> &ndash; Conditional Select</a></p>
<p><a href="#k11">*** 11. Instrukce <strong>CSINC</strong> &ndash; Conditional Select Increment</a></p>
<p><a href="#k12">*** 12. Instrukce <strong>CSNEG</strong> &ndash; Conditional Select Negate</a></p>
<p><a href="#k13">*** 13. Instrukce <strong>CINC</strong> &ndash; Conditional Increment</a></p>
<p><a href="#k14">*** 14. Instrukce <strong>CINV</strong> &ndash; Conditional Invert</a></p>
<p><a href="#k15">*** 15. Instrukce <strong>CNEG</strong> &ndash; Conditional Negate</a></p>
<p><a href="#k16">*** 16. Instrukce <strong>TBZ</strong> a <strong>TBNZ</strong> (Test and Branch...)</a></p>
<p><a href="#k17">*** 17. </a></p>
<p><a href="#k18">18. Repositář s&nbsp;demonstračními příklady</a></p>
<p><a href="#k19">19. Předchozí články o architektuře AArch64</a></p>
<p><a href="#k20">20. Odkazy na Internetu</a></p>



<p><a name="k01"></a></p>
<h2 id="k01">1. Problematika blokových přenosů dat</h2>

<p>V&nbsp;závěrečné části <a
href="https://www.root.cz/clanky/specificke-vlastnosti-procesoru-aarch64-podminene-a-nepodminene-skoky-adresovani-dat/">předchozího
článku</a> jsme si ukázali, jakým způsobem je možné přenášet blok dat
z&nbsp;jedné oblasti operační paměti do oblasti jiné. Připomeňme si, že jsme si
pro tento účel vytvořili pomocné makro, které tuto operaci provede. Toto makro
přenáší data po jednotlivých bajtech a lze ho použít vícekrát, protože návěští
(<i>label</i>) <strong>loop</strong> je doplněno automaticky generovaným
pořadovým číslem:</p>

<pre>
.macro <strong>moveBlockByBytes</strong> from, to, length
        ldr   x1, =\from        <i>// adresa bloku pro čtení</i>
        ldr   x2, =\to          <i>// adresa bloku pro zápis</i>
        mov   x4, #\length      <i>// počet bajtu</i>
loop\@:
        ldrb  w3, [x1], 1       <i>// čtení bajtu</i>
        strb  w3, [x2], 1       <i>// zápis bajtu</i>
        sub   x4, x4, #1        <i>// zmenšení počitadla</i>
        cbnz  x4, loop\@        <i>// pokud jsme se nedostali k nule, skok na zacatek smycky</i>
.endm
</pre>

<p>Ze zápisu tohoto makra je patrné, že smyčka, v&nbsp;níž k&nbsp;přenosu
dochází, obsahuje čtveřici instrukcí. První dvě instrukce načtou bajt, který
následně uloží (písmeno <strong>b</strong> na konci jména instrukce určuje, že
se pracuje jen s&nbsp;osmi bity registru <strong>w3</strong>). Současně jsou
zvýšeny i hodnoty registrů <strong>x1</strong> a <strong>x2</strong>
obsahujících adresu dalšího čteného resp.&nbsp;zapisovaného bajtu. Třetí
instrukce snižuje hodnotu počitadla (počet zbývajících bajtů, které se mají
přenést) a poslední instrukcí je podmíněný skok &ndash; v&nbsp;případě, že je
hodnota registru <strong>x4</strong> (tedy počitadla) nenulová, provede se
další iterace.</p>



<p><a name="k02"></a></p>
<h2 id="k02">2. Blokový po jednotlivých bajtech</h2>

<p>Přenos dat je proveden po jednotlivých bajtech, což i přes (relativní)
krátkost programové smyčky znamená, že se ani zdaleka nevyužijí možnosti
nabízené 64bitovým mikroprocesorem, který je mnohdy vybaven plnohodnotnou
64bitovou externí datovou sběrnicí. Bylo by tedy dobré zjistit rychlost
blokových přenosů. K&nbsp;tomuto účelu si vytvoříme jednoduchý benchmark, který
bude přenášet větší blok (ideálně o délce dělitelné šestnácti), a to tolikrát,
aby bylo možné dobu běhu změřit standardním nástrojem <strong>time</strong>. Na
konkrétním počítači, na němž byl benchmark odladěn, je přenos řízen touto
počítanou programovou smyčkou:</p>

<pre>
        mov   x10, #50000       <i>// počet opakování blokového přesunu</i>
        lsl   x10, x10, #8      <i>// ještě zvětšíme počet opakování</i>
loop:
        <strong>moveBlockByBytes hello_lbl, buffer, rep_count</strong>
        sub   x10, x10, #1      <i>// snížení hodnoty počitadla</i>
        cbnz  x10, loop         <i>// pokud se nedosáhlo nuly, opakovat</i>
</pre>

<p><div class="rs-tip-major">Poznámka: instrukce typu <strong>mov registr,
#konstanta</strong> dokáže pracovat pouze s&nbsp;omezenou velikostí konstanty
přenášené do registru &ndash; tato konstanta může být jen 16bitová (viz též <a
href="https://www.root.cz/clanky/specificke-vlastnosti-procesoru-aarch64-zakladni-instrukce/">úvodní
článek</a>). Z&nbsp;tohoto důvodu zapisovanou konstantu (50000) navíc ještě
posuneme o osm bitů doleva, tedy ji osmkrát vynásobíme dvěma. Výsledný počet
opakování smyčky je roven 12800000. Přenáší se blok o velikosti 448 bajtů,
celkově se tedy přenese 5,34 GB.</div></p>

<p>Úplný zdrojový kód prvního benchmarku vypadá následovně:</p>

<pre>
<i># asmsyntax=as</i>
&nbsp;
<i># Přesun bloku dat po jednotlivých bajtech.</i>
<i>#</i>
<i># Autor: Pavel Tišnovský</i>
&nbsp;
&nbsp;
&nbsp;
<i># Linux kernel system call table</i>
sys_exit=93
sys_write=64
&nbsp;
<i># List of syscalls for AArch64:</i>
<i># https://github.com/torvalds/linux/blob/master/include/uapi/asm-generic/unistd.h</i>
&nbsp;
<i># počet bajtu pro blokové přesuny</i>
rep_count  = 448
&nbsp;
&nbsp;
<i># Deklarace makra pro ukončení aplikace</i>
.macro <strong>exit</strong>
        mov  x8, #sys_exit      <i>// číslo sycallu pro funkci "exit"</i>
        mov  x0, #0             <i>// exit code = 0</i>
        svc  0                  <i>// volání Linuxového kernelu</i>
.endm
&nbsp;
&nbsp;
&nbsp;
<i># Deklarace makra pro vytištění zprávy na standardní výstup</i>
.macro <strong>writeMessage</strong> message, messageLength
        mov  x8, #sys_write       <i>// číslo sycallu pro funkci "write"</i>
        mov  x0, #1               <i>// standardní výstup</i>
        ldr  x1, =\message        <i>// adresa řetězce, který se má vytisknout</i>
        mov  x2, #\messageLength  <i>// počet znaků, které se mají vytisknout</i>
        svc  0                    <i>// volání Linuxového kernelu</i>
.endm
&nbsp;
&nbsp;
&nbsp;
<i># Deklarace makra pro přesun bloku po bajtech</i>
.macro <strong>moveBlockByBytes</strong> from, to, length
        ldr   x1, =\from        <i>// adresa bloku pro čtení</i>
        ldr   x2, =\to          <i>// adresa bloku pro zápis</i>
        mov   x4, #\length      <i>// počet bajtu</i>
loop\@:
        ldrb  w3, [x1], 1       <i>// čtení bajtu</i>
        strb  w3, [x2], 1       <i>// zápis bajtu</i>
        sub   x4, x4, #1        <i>// zmenšení počitadla</i>
        cbnz  x4, loop\@        <i>// pokud jsme se nedostali k nule, skok na začátek smyčky</i>
.endm
&nbsp;
&nbsp;
.balign 8
&nbsp;
<i>#-----------------------------------------------------------------------------</i>
.section .data
&nbsp;
hello_lbl:
        .string "Lorem ipsum dolor sit amet, consectetur adipiscing elit, sed
        do eiusmod tempor incididunt ut labore et dolore magna aliqua. Ut enim
        ad minim veniam, quis nostrud exercitation ullamco laboris nisi ut
        aliquip ex ea commodo consequat. Duis aute irure dolor in reprehenderit
        in voluptate velit esse cillum dolore eu fugiat nulla pariatur.
        Excepteur sint occaecat cupidatat non proident, sunt in culpa qui
        officia deserunt mollit anim id est laborum&lt;pad&gt;"
&nbsp;
&nbsp;
<i>#-----------------------------------------------------------------------------</i>
.section .bss
&nbsp;
        .lcomm buffer, rep_count     <i>// rezervace bufferu pro výstup</i>
&nbsp;
&nbsp;
&nbsp;
<i>#-----------------------------------------------------------------------------</i>
.section .text
        .global _start          <i>// tento symbol má být dostupný i linkeru</i>
&nbsp;
_start:
        writeMessage buffer, rep_count
&nbsp;
        mov   x10, #50000       <i>// počet opakování blokového přesunu</i>
        lsl   x10, x10, #8      <i>// ještě zvětšíme počet opakování</i>
loop:
        moveBlockByBytes hello_lbl, buffer, rep_count
        sub   x10, x10, #1      <i>// snížení hodnoty počitadla</i>
        cbnz  x10, loop         <i>// pokud se nedosáhlo nuly, opakovat</i>
&nbsp;
        writeMessage buffer, rep_count
&nbsp;
        exit
</pre>



<p><a name="k03"></a></p>
<h2 id="k03">3. Blokový přenos po 64bitových slovech</h2>

<p>Plného využití možností 64bitových mikroprocesorů s&nbsp;64bitovou externí
sběrnicí dosáhneme pouze tehdy, pokud budeme blokové přenosy provádět po
64bitových slovech a nikoli po jednotlivých bajtech. Nejprve je vhodné zajistit
zarovnání dat assemblerem:</p>

<pre>
.balign 8
</pre>

<p>Následně můžeme makro pro blokový přenos upravit takovým způsobem, aby se
data přenášela po celých slovech, konkrétně přes registr <strong>x3</strong>.
Povšimněte si, že adresy v&nbsp;registrech <strong>x1</strong> a
<strong>x2</strong> zvyšujeme po osmi a počitadlo smyčky naopak snižujeme o
konstantu 8. Jedinou další úpravou je náhrada instrukcí <strong>LDRP</strong> a
<strong>STRP</strong> za &bdquo;plnohodnotné&ldquo; 64bitové instrukce
<strong>LDR</strong> a <strong>STR</strong>:</p>

<pre>
<i># Deklarace makra pro přesun bloku po osmi bajtech</i>
.macro <strong>moveBlockByWords</strong> from, to, length
        ldr   x1, =\from        <i>// adresa bloku pro čtení</i>
        ldr   x2, =\to          <i>// adresa bloku pro zápis</i>
        mov   x4, #\length      <i>// počet bajtů, které se mají přenést</i>
loop\@:
        ldr   x3, [x1], 8       <i>// čtení osmi bajtů</i>
        str   x3, [x2], 8       <i>// zápis osmi bajtů</i>
        sub   x4, x4, #8        <i>// zmenšení počitadla</i>
        cbnz  x4, loop\@        <i>// pokud jsme se nedostali k nule, skok na začátek smyčky</i>
.endm
</pre>

<p>Další změny v&nbsp;benchmarku již není nutné provádět, ale stejně si pro
jistotu ukažme jeho plnou verzi:</p>

<pre>
<i># asmsyntax=as</i>
&nbsp;
<i># Presun bloku dat po osmi bajtech.</i>
<i>#</i>
<i># Autor: Pavel Tišnovský</i>
&nbsp;
&nbsp;
&nbsp;
<i># Linux kernel system call table</i>
sys_exit=93
sys_write=64
&nbsp;
<i># List of syscalls for AArch64:</i>
<i># https://github.com/torvalds/linux/blob/master/include/uapi/asm-generic/unistd.h</i>
&nbsp;
<i># počet bajtů pro blokové přesuny</i>
rep_count  = 448
&nbsp;
&nbsp;
<i># Deklarace makra pro ukončení aplikace</i>
.macro <strong>exit</strong>
        mov  x8, #sys_exit      <i>// číslo sycallu pro funkci "exit"</i>
        mov  x0, #0             <i>// exit code = 0</i>
        svc  0                  <i>// volání Linuxového kernelu</i>
.endm
&nbsp;
&nbsp;
&nbsp;
<i># Deklarace makra pro vytištění zprávy na standardní výstup</i>
.macro <strong>writeMessage</strong> message, messageLength
        mov  x8, #sys_write       <i>// číslo sycallu pro funkci "write"</i>
        mov  x0, #1               <i>// standardní výstup</i>
        ldr  x1, =\message        <i>// adresa řetězce, který se má vytisknout</i>
        mov  x2, #\messageLength  <i>// počet znaků, které se mají vytisknout</i>
        svc  0                    <i>// volání Linuxového kernelu</i>
.endm
&nbsp;
&nbsp;
&nbsp;
<i># Deklarace makra pro presun bloku po osmi bajtech</i>
.macro <strong>moveBlockByWords</strong> from, to, length
        ldr   x1, =\from        <i>// adresa bloku pro čtení</i>
        ldr   x2, =\to          <i>// adresa bloku pro zápis</i>
        mov   x4, #\length      <i>// počet bajtu</i>
loop\@:
        ldr   x3, [x1], 8       <i>// čtení osmi bajtů</i>
        str   x3, [x2], 8       <i>// zápis osmi bajtů</i>
        sub   x4, x4, #8        <i>// zmenšení počitadla</i>
        cbnz  x4, loop\@        <i>// pokud jsme se nedostali k nule, skok na začátek smyčky</i>
.endm
&nbsp;
&nbsp;
.balign 8
&nbsp;
<i>#-----------------------------------------------------------------------------</i>
.section .data
&nbsp;
hello_lbl:
        .string "Lorem ipsum dolor sit amet, consectetur adipiscing elit, sed
        do eiusmod tempor incididunt ut labore et dolore magna aliqua. Ut enim
        ad minim veniam, quis nostrud exercitation ullamco laboris nisi ut
        aliquip ex ea commodo consequat. Duis aute irure dolor in reprehenderit
        in voluptate velit esse cillum dolore eu fugiat nulla pariatur.
        Excepteur sint occaecat cupidatat non proident, sunt in culpa qui
        officia deserunt mollit anim id est laborum&lt;pad&gt;"
&nbsp;
&nbsp;
<i>#-----------------------------------------------------------------------------</i>
.section .bss
&nbsp;
        .lcomm buffer, rep_count     <i>// rezervace bufferu pro výstup</i>
&nbsp;
&nbsp;
&nbsp;
<i>#-----------------------------------------------------------------------------</i>
.section .text
        .global _start          <i>// tento symbol má byt dostupný i linkeru</i>
&nbsp;
_start:
        writeMessage buffer, rep_count
&nbsp;
        mov   x10, #50000       <i>// počet opakování blokového přesunu</i>
        lsl   x10, x10, #8      <i>// ještě zvětšíme počet opakování</i>
loop:
        moveBlockByWords hello_lbl, buffer, rep_count
        sub   x10, x10, #1      <i>// snížení hodnoty počitadla</i>
        cbnz  x10, loop         <i>// pokud se nedosáhlo nuly, opakovat</i>
&nbsp;
        writeMessage buffer, rep_count
&nbsp;
        exit
</pre>



<p><a name="k04"></a></p>
<h2 id="k04">4. Přenos po dvojici 64bitových slov &ndash; instrukce <strong>LDP</strong> a <strong>STP</strong></h2>

<pre>
<i># Deklarace makra pro presun bloku po dvou slovech</i>
.macro <strong>moveBlockByTwoWords</strong> from, to, length
        ldr   x1, =\from        <i>// adresa bloku pro čtení</i>
        ldr   x2, =\to          <i>// adresa bloku pro zápis</i>
        mov   x5, #\length      <i>// počet bajtu</i>
loop\@:
        ldp   x3, x4, [x1], 16  <i>// čtení 2x osmi bajtů</i>
        stp   x3, x4, [x2], 16  <i>// zápis 2x osmi bajtů</i>
        sub   x5, x5, #16       <i>// zmenšení počitadla</i>
        cbnz  x5, loop\@        <i>// pokud jsme se nedostali k nule, skok na začátek smyčky</i>
.endm
</pre>

<pre>
<i># asmsyntax=as</i>
&nbsp;
<i># Presun bloku dat po 2x osmi bajtech.</i>
<i>#</i>
<i># Autor: Pavel Tišnovský</i>
&nbsp;
&nbsp;
&nbsp;
<i># Linux kernel system call table</i>
sys_exit=93
sys_write=64
&nbsp;
<i># List of syscalls for AArch64:</i>
<i># https://github.com/torvalds/linux/blob/master/include/uapi/asm-generic/unistd.h</i>
&nbsp;
<i># počet bajtu pro blokove presuny</i>
rep_count  = 448
&nbsp;
&nbsp;
<i># Deklarace makra pro ukončení aplikace</i>
.macro <strong>exit</strong>
        mov  x8, #sys_exit      <i>// číslo sycallu pro funkci "exit"</i>
        mov  x0, #0             <i>// exit code = 0</i>
        svc  0                  <i>// volání Linuxového kernelu</i>
.endm
&nbsp;
&nbsp;
&nbsp;
<i># Deklarace makra pro vytištění zprávy na standardní výstup</i>
.macro <strong>writeMessage</strong> message, messageLength
        mov  x8, #sys_write       <i>// číslo sycallu pro funkci "write"</i>
        mov  x0, #1               <i>// standardní výstup</i>
        ldr  x1, =\message        <i>// adresa řetězce, který se má vytisknout</i>
        mov  x2, #\messageLength  <i>// počet znaků, které se mají vytisknout</i>
        svc  0                    <i>// volání Linuxového kernelu</i>
.endm
&nbsp;
&nbsp;
<i># Deklarace makra pro presun bloku po dvou slovech</i>
.macro <strong>moveBlockByTwoWords</strong> from, to, length
        ldr   x1, =\from        <i>// adresa bloku pro čtení</i>
        ldr   x2, =\to          <i>// adresa bloku pro zápis</i>
        mov   x5, #\length      <i>// počet bajtu</i>
loop\@:
        ldp   x3, x4, [x1], 16  <i>// čtení 2x osmi bajtů</i>
        stp   x3, x4, [x2], 16  <i>// zápis 2x osmi bajtů</i>
        sub   x5, x5, #16       <i>// zmenšení počitadla</i>
        cbnz  x5, loop\@        <i>// pokud jsme se nedostali k nule, skok na začátek smyčky</i>
.endm
&nbsp;
&nbsp;
.balign 8
&nbsp;
<i>#-----------------------------------------------------------------------------</i>
.section .data
&nbsp;
hello_lbl:
        .string "Lorem ipsum dolor sit amet, consectetur adipiscing elit, sed
        do eiusmod tempor incididunt ut labore et dolore magna aliqua. Ut enim
        ad minim veniam, quis nostrud exercitation ullamco laboris nisi ut
        aliquip ex ea commodo consequat. Duis aute irure dolor in reprehenderit
        in voluptate velit esse cillum dolore eu fugiat nulla pariatur.
        Excepteur sint occaecat cupidatat non proident, sunt in culpa qui
        officia deserunt mollit anim id est laborum&lt;pad&gt;"
&nbsp;
&nbsp;
<i>#-----------------------------------------------------------------------------</i>
.section .bss
&nbsp;
        .lcomm buffer, rep_count     <i>// rezervace bufferu pro výstup</i>
&nbsp;
&nbsp;
&nbsp;
<i>#-----------------------------------------------------------------------------</i>
.section .text
        .global _start          <i>// tento symbol ma byt dostupny i linkeru</i>
&nbsp;
_start:
        writeMessage buffer, rep_count
&nbsp;
        mov   x10, #50000       <i>// počet opakování blokového přesunu</i>
        lsl   x10, x10, #8      <i>// ještě zvětšíme počet opakování</i>
loop:
        moveBlockByTwoWords hello_lbl, buffer, rep_count
        sub   x10, x10, #1      <i>// snížení hodnoty počitadla</i>
        cbnz  x10, loop         <i>// pokud se nedosáhlo nuly, opakovat</i>
&nbsp;
        writeMessage buffer, rep_count
&nbsp;
        exit
</pre>



<p><a name="k05"></a></p>
<h2 id="k05">5. Výsledky benchmarků</h2>

<pre>
$ <strong>time ./move5</strong>
&nbsp;
real    0m3.909s
user    0m3.908s
sys     0m0.000s
</pre>

<pre>
$ <strong>time ./move6</strong>
&nbsp;
real    0m0.498s
user    0m0.498s
sys     0m0.000s
</pre>

<pre>
$ <strong>time ./move7</strong>
&nbsp;
real    0m0.258s
user    0m0.257s
sys     0m0.000s
</pre>



<p><a name="k06"></a></p>
<h2 id="k06">6. Problematika provedení instrukcí při splnění určité podmínky</h2>

<p>Ve druhé části dnešního článku se zaměříme na prozatím relativně novou
oblast. Jedná se o speciální instrukce implementované na moderní
mikroprocesorové architektuře AArch64, které provádí specifikovanou činnost
(nastavení registru na určitou hodnotu, inverze obsahu registru atd.), ale
pouze za předpokladu, že je splněna nějaká zadaná podmínka (kód podmínky je
přitom součástí instrukčního slova). Připomeňme si, že na rozdíl od <a
href="https://mojefedora.cz/pouziti-assembleru-v-linuxu-podminky-rozvetveni-a-programove-smycky-na-procesorech-arm/">původní
32bitové architektury ARM</a> (dnes označované <i>ARM32</i> nebo též jen
<i>A32</i>) <strong>ne</strong>mají všechny instrukce na AArch64 rezervovány
čtyři nejvyšší bity pro specifikaci podmínky. Tato vlastnost byla na základě
analýzy existujících programových strojových kódů, které za dobu existence
platformy ARM vznikly, zrušena a podmínky je tak možné použít pouze u vybrané
množiny instrukcí. Do této množiny byly zahrnuty i zcela nové instrukce, které
na původní platformě ARM32 nenalezneme, což je opět důsledek analýzy
stávajících strojových kódů, ale i studia funkce překladačů.</p>

<p><div class="rs-tip-major">Poznámka: <a
href="http://yarchive.net/comp/carry_bit.html">podle některých vývojářů</a>
může mít extenzivní použití příznakových bitů negativní vliv na výkonnost
procesoru, což je však téma, které je řešeno nejenom na AArch64, ale i na
platformě x86-64 (výjimkou je například architektura MIPS, která příznakové
bity nepoužívá).</div></p>

<p>Připomeňme si, že na procesorové architektuře AArch64 je použito celkem
čtrnáct různých podmínek, k&nbsp;nimž se někdy přidává i pseudopodmínka
<strong>AL</strong> neboli <i>Any/Always</i>. V&nbsp;tomto případě se
samozřejmě o žádnou skutečnou podmínku nejedná, neboť je instrukce provedena
v&nbsp;každém případě, tedy nezávisle na aktuálním stavu příznakových bitů.</p>

<p>Prvních šest podmínek testuje hodnotu pouze jediného bitového příznaku, a to
<strong>N (negative)</strong>, <strong>Z (zero)</strong> či <strong>V
(overflow)</strong>:</p>

<table>
<tr><th>Kód</th><th>Přípona</th><th>Význam</th><th>Testovaná podmínka</th></tr>
<tr><td>0000</td><td>EQ</td><td>Z = 1</td><td>rovnost po porovnání (či nulový výsledek)</td></tr>
<tr><td>0001</td><td>NE</td><td>Z = 0</td><td>nerovnost po porovnání (či nenulový výsledek)</td></tr>
<tr><td>0100</td><td>MI</td><td>N = 1</td><td>výsledek je záporný</td></tr>
<tr><td>0101</td><td>PL</td><td>N = 0</td><td>výsledek je kladný či nulový</td></tr>
<tr><td>0110</td><td>VS</td><td>V = 1</td><td>nastalo přetečení (<i>overflow</i>)</td></tr>
<tr><td>0111</td><td>VC</td><td>V = 0</td><td>nenastalo přetečení (<i>overflow</i>)</td></tr>
<tr><td>1110</td><td>AL</td><td>Any/Always</td><td>většinou se nezapisuje, implicitní podmínka</td></tr>
</table>

<p><div class="rs-tip-major">Poznámka: příznakové bity jsou nastavovány jak
32bitovými, tak i 64bitovými operacemi, a to naprosto stejným
způsobem.</div></p>

<p>Další čtyři podmínkové kódy se většinou používají při porovnávání dvou
hodnot bez znaménka (<i>unsigned</i>). V&nbsp;těchto případech se testují stavy
příznakových bitů <strong>C (carry)</strong> a <strong>Z (zero)</strong>,
přesněji řečeno kombinace těchto bitů:</p>

<table>
<tr><th>Kód </th><th>Přípona</th><th>Význam</th><th>Testovaná podmínka</th></tr>
<tr><td>0010</td><td>CS/HS</td><td>C = 1</td><td>&ge;</td></tr>
<tr><td>0011</td><td>CC/LO</td><td>C = 0</td><td>&lt;</td></tr>
<tr><td>1000</td><td>HI</td><td>C = 1 &amp; Z = 0</td><td>&gt;</td></tr>
<tr><td>1001</td><td>LS</td><td>C = 0 | Z = 1 </td><td>&le;</td></tr>
</table>

<p>Poslední čtyři podmínkové kódy se používají pro porovnávání hodnot se
znaménkem (<i>signed</i>). V&nbsp;těchto případech se namísto příznakových bitů
<strong>(C) carry</strong> a <strong>(Z) zero</strong> testují kombinace bitů
<strong>(N) negative</strong>, <strong>(V) overflow</strong> a <strong>(Z)
zero</strong>:</p>

<table>
<tr><th>Kód </th><th>Přípona</th><th>Význam</th><th>Testovaná podmínka</th></tr>
<tr><td>1010</td><td>GE</td><td>N == V</td><td>&ge;</td></tr>
<tr><td>1011</td><td>LT</td><td>N &ne; V </td><td>&lt;</td></tr>
<tr><td>1100</td><td>GT</td><td>Z = 0, N = V </td><td>&gt;</td></tr>
<tr><td>1101</td><td>LE</td><td>Z = 1, N &ne; V</td><td>&le;</td></tr>
</table>

<p>Důležité přitom je, že všechny dále popsané instrukce podporují všechny výše
zmíněné podmínky. Výjimku tvoří minule popsané instrukce <strong>CBZ</strong> a
<strong>CBNZ</strong>, které pouze testovaly nulovost či naopak nenulovost
vybraného pracovního registru.</p>

<table>
<tr><th>Instrukce</th><th>Stručný popis instrukce</th></tr>
<tr><td>B.podmínka návěští</td><td>podmíněný skok po splnění podmínky na zadané návěští (kódy podmínek byly uvedeny výše)</td></tr>
<tr><td>CBZ Wn, návěští</td><td>pokud platí Wn=0, skok na zadané návěští</td></tr>
<tr><td>CBZ Xn, návěští</td><td>pokud platí Xn=0, skok na zadané návěští</td></tr>
<tr><td>CBNZ Wn, návěští</td><td>pokud platí Wn&ne;0, skok na zadané návěští</td></tr>
<tr><td>CBNZ Xn, návěští</td><td>pokud platí Xn&ne;0, skok na zadané návěští</td></tr>
</table>

<p><div class="rs-tip-major">Poznámka: tyto instrukce jsou (ve své variantě
s&nbsp;32bitovými registry) zpětně kompatibilní s&nbsp;instrukcemi známými
z&nbsp;32bitové architektury ARM32.</div></p>



<p><a name="k07"></a></p>
<h2 id="k07">7. Nové instrukce s&nbsp;podmínkami</h2>

<p>Mezi nové instrukce s&nbsp;podmínkou, které lze použít na architektuře AArch64, patří především:</p>

<table>
<tr><th>Instrukce</th><th>Význam mnemotechnického kódu instrukce</th><th>Kapitola</th></tr>
<tr><td>CSET</td><td>Conditional Set</td><td><a href="#k08">8</a></td></tr>
<tr><td>CSETM</td><td>Conditional Set Mask</td><td><a href="#k09">9</a></td></tr>
<tr><td>CSEL</td><td>Conditional Select</td><td><a href="#k10">10</a></td></tr>

<tr><td>CSINV</td><td>Conditional Select Invert</td><td><a href="#k07">7</a></td></tr>
<tr><td>CSINC</td><td>Conditional Select Increment</td><td><a href="#k08">8</a></td></tr>
<tr><td>CSNEG</td><td>Conditional Select Negate</td><td><a href="#k09">9</a></td></tr>
<tr><td>CINC</td><td>Conditional Increment</td><td><a href="#k10">10</a></td></tr>
<tr><td>CINV</td><td>Conditional Invert</td><td><a href="#k11">11</a></td></tr>
<tr><td>CNEG</td><td>Conditional Negate</td><td><a href="#k12">12</a></td></tr>
<tr><td>TBZ </td><td>Test and Branch if Zero</td><td><a href="#k13">13</a></td></tr>
<tr><td>TBNZ</td><td>Test and Branch if not zero</td><td><a href="#k13">13</a></td></tr>
</table>



<p><a name="k08"></a></p>
<h2 id="k08">8. Instrukce <strong>CSET</strong> &ndash; Conditional Set</h2>

<p>První novou instrukcí s&nbsp;podmínkou, s&nbsp;níž se v&nbsp;dnešním článku
seznámíme, je instrukce nazvaná <strong>CSET</strong>, což je mnemotechnická
zkratka celého názvu <i>Conditional Set</i>. Tato instrukce vlastně přímo
odpovídá požadavkům kladeným na datový typ <i>boolean</i> v&nbsp;mnoha
programovacích jazycích, v&nbsp;nichž je hodnota <i>true</i> interně
reprezentována jedničkou a hodnota <i>false</i> nulou. Tato instrukce existuje
ve dvou variantách, přičemž první varianta pracuje s&nbsp;32bitovým a druhá
varianta s&nbsp;64bitovým operandem. Zápis této instrukce v&nbsp;assembleru
(včetně GNU Assembleru) může vypadat následovně:</p>

<pre>
<strong>CSET</strong> Wd, podmínka
<strong>CSET</strong> Xd, podmínka
</pre>

<p>Například (ukázka pro různé podmínky):</p>

<pre>
<strong>CSET</strong> W3, EQ
<strong>CSET</strong> W4, MI
<strong>CSET</strong> X5, HI
</pre>

<p>Tato instrukce pracuje následujícím způsobem &ndash; v&nbsp;případě, že je
podmínka zapsaná ve druhém operandu <i>cond</i> splněna (tedy pokud mají
podmínkové/příznakové bity očekávané hodnoty), uloží se do cílového 32bitového
registru <strong>Wd</strong> či do 64bitového registru <strong>Xd</strong>
hodnota 1. Pokud podmínka naopak splněna není, uloží se do registru
<strong>Wd</strong> či <strong>Xd</strong> hodnota 0:</p>

<pre>
cíl = condition ? 1 : 0;
</pre>

<p>Ve skutečnosti se v&nbsp;případě instrukce <strong>CSET</strong> jedná o
alias pro instrukci <strong>CSINC</strong> popsanou dále (podmínka ovšem musí
být v&nbsp;tomto případě negována):</p>

<pre>
<strong>CSINC</strong> Wd, WZR, WZR, invert(podmínka)
<strong>CSINC</strong> Xd, XZR, XZR, invert(podmínka)
</pre>

<p>neboli:</p>

<pre>
cíl = invert(condition) ? 0 : 0+1;
</pre>

<p><div class="rs-tip-major">Poznámka: opět zde můžeme vidět, že zavedení
registrů <strong>WZR</strong> a <strong>XZR</strong>, které (pro operaci čtení)
vždy vrací nulu, umožňuje do instrukční sady prakticky zadarmo přidávat nové
zajímavé a užitečné instrukce.</div></p>



<p><a name="k09"></a></p>
<h2 id="k09">9. Instrukce <strong>CSETM</strong> &ndash; Conditional Set Mask</h2>

<p>V&nbsp;některých případech je nutné ukládat pravdivostní hodnoty <i>true</i>
a <i>false</i> odlišným způsobem &ndash; pravdivostní hodnota <i>true</i> bude
reprezentována konstantou, v&nbsp;níž jsou všechny bity nastaveny na jedničku
(v&nbsp;případě celých čísel se znaménkem to odpovídá hodnotě -1), hodnota
<i>false</i> naopak konstantou, v&nbsp;níž jsou všechny bity nulové.
V&nbsp;tomto případě je možné pro nastavení pravdivostní hodnoty na základě
podmínky použít instrukci s&nbsp;mnemotechnickou zkratkou
<strong>CSETM</strong> neboli <i>Conditional Set Mask</i>:</p>

<pre>
<strong>CSETM</strong> Wd, podmínka
<strong>CSETM</strong> Xd, podmínka
</pre>

<p>Ve vyšším programovacím jazyce by bylo možné napsat:</p>

<pre>
cíl = condition ? -1 : 0;
</pre>

<p><div class="rs-tip-major">Poznámka: u 32bitového registru odpovídá dekadická
hodnota -1 hexadecimální hodnotě 0xffff&nbsp;ffff, u 64bitového registru pak
hodnotě 0xffff&nbsp;ffff&nbsp;ffff&nbsp;ffff.</div></p>

<p>V&nbsp;případě instrukce <strong>CSETM</strong> se opět jedná o aliasy,
tentokrát ovšem na instrukci <strong>CSINV</strong> a nikoli
<strong>CSINC</strong>:</p>

<pre>
<strong>CSINV</strong> Wd, WZR, WZR, invert(podmínka)
<strong>CSINV</strong> Xd, XZR, XZR, invert(podmínka)
</pre>

<p><div class="rs-tip-major">Poznámka: slovo &bdquo;mask&ldquo; v&nbsp;názvu
instrukce skutečně poměrně přesně odpovídá jednomu způsobu jejího použití,
protože pokud platí <i>true=-1</i> a <i>false=0</i>, lze s&nbsp;těmito
hodnotami provádět logický součin a součet bit po bitu, a to i v&nbsp;případě,
kdy je druhým operandem odlišná hodnota.</div></p>



<p><a name="k10"></a></p>
<h2 id="k10">10. Instrukce <strong>CSEL</strong> &ndash; Conditional Select</h2>

<p>Další v&nbsp;praxi užitečnou instrukcí s&nbsp;podmínkou je instrukce
zapisovaná mnemotechnickým kódem <strong>CSEL</strong> neboli plným jménem
<i>Conditional Select</i>. I tato instrukce existuje ve dvou variantách &ndash;
32bitové a 64bitové:</p>

<pre>
<strong>CSEL</strong> Wd, Wn, Wm, podmínka
<strong>CSEL</strong> Xd, Xn, Xm, podmínka
</pre>

<p>Instrukce <strong>CSEL</strong> pracuje následovně: v&nbsp;případě, že je
podmínka splněna, uloží se do cílového registru <strong>Wd</strong> či
<strong>Xd</strong> hodnota z&nbsp;prvního zdrojového registru
<strong>Wn</strong> nebo <strong>Xn</strong>. Pokud podmínka splněna není, je
do cílového registru <strong>Wd/Xd</strong> uložena hodnota z&nbsp;druhého
zdrojového registru <strong>Wm/Xm</strong>.</p>

<p>Instrukce <strong>CSEL</strong> tedy nahrazuje programovou konstrukci
typu:</p>

<pre>
cíl = condition ? zdroj1 : zdroj2;
</pre>

<p><div class="rs-tip-major">Poznámka: je vhodné si uvědomit, jak by se tato
operace musela řešit v&nbsp;případě, že by instrukce <strong>CSEL</strong>
neexistovala. Musela by být nahrazena (přibližně) tímto kódem, který
v&nbsp;každém případě vede k&nbsp;jedné instrukci skoku:</div></p>

<pre>
if:
        B.neg_podmínka else
        MOV Wd, Wn
        B endif
else:
        MOV Wd, Wm
endif:
</pre>



<p><a name="k09"></a></p>
<h2 id="k09">9. Instrukce <strong>CSINV</strong> &ndash; Conditional Select Invert</h2>

<p>Alternativní formou instrukce <strong>CSEL</strong> je instrukce <strong>CSINV</strong> neboli <i>Conditional Select Invert</i>:</p>

<pre>
CSINV Wd, Wn, Wm, condition
CSINV Xd, Xn, Xm, condition
</pre>

<p>Tato instrukce pracuje následovně: pokud je podmínka splněna, uloží se do cílového registru <strong>Wd</strong> či <strong>Xd</strong> hodnota z&nbsp;prvního zdrojového registru <strong>Wn</strong> nebo <strong>Xn</strong>. Pokud podmínka splněna není, je do cílového registru <strong>Wd/Xd</strong> uložena negovaná hodnota přečtená z&nbsp;druhého zdrojového registru <strong>Wm/Xm</strong>.</p>

<p>Instrukce <strong>CSINV</strong> tedy nahrazuje programovou konstrukci typu:</p>

<pre>
cíl = condition ? zdroj1 : ~zdroj2;
</pre>

<p>Poznámka: znak ~ je používán v&nbsp;programovacím jazyku C a od něj odvozených jazycích pro zápis unárního operátoru negace všech bitů (jedničkový doplněk).</p>



<p><a name="k10"></a></p>
<h2 id="k10">10. </h2>



<p><a name="k11"></a></p>
<h2 id="k11">11. Instrukce <strong>CSINC</strong> &ndash; Conditional Select Increment</h2>

<p>Zajímavá je instrukce <strong>CSINC</strong>, která kombinuje možnosti instrukce <strong>CINC</strong> a <strong>CSEL</strong>:</p>

<pre>
CSINC Wd, Wn, Wm, condition
CSINC Xd, Xn, Xm, condition
</pre>

<p>Tato instrukce provádí následující činnost:</p>

<pre>
Wd = condition ? Wn : Wm+1;
Xd = condition ? Xn : Xm+1;
</pre>

<p>Jak jsme si již řekli <a href="#k04">ve čtvrté kapitole</a>, je touto instrukcí realizována i pseudoinstrukce <strong>CSET</strong>, a to tehdy, pokud jsou oba zdrojové registry nulové (<strong>WZR</strong> a <strong>XZR</strong>). V&nbsp;tomto případě se do cílového registru dosadí 0 či 0+1=1:</p>

<pre>
CSINC Wd, WZR, WZR, invert(condition)
CSINC Xd, XZR, XZR, invert(condition)
</pre>



<p><a name="k12"></a></p>
<h2 id="k12">12. </h2>



<p><a name="k13"></a></p>
<h2 id="k13">13. Instrukce <strong>CSNEG</strong> &ndash; Conditional Select Negate</h2>

<p>Instrukce nazvaná <strong>CSNEG</strong> se do jisté míry podobá instrukci <strong>CSINV</strong>, ovšem s&nbsp;tím rozdílem, že se namísto jedničkového doplňku (negace) používá při nesplnění podmínky dvojkový doplněk:</p>

<pre>
CSNEG Wd, Wn, Wm, condition
CSNEG Xd, Xn, Xm, condition
</pre>

<p>Tato instrukce pracuje následovně: pokud je podmínka splněna, uloží se do cílového registru <strong>Wd</strong> či <strong>Xd</strong> hodnota z&nbsp;prvního zdrojového registru <strong>Wn</strong> nebo <strong>Xn</strong>. Pokud podmínka splněna není, je do cílového registru <strong>Wd/Xd</strong> uložena hodnota přečtená z&nbsp;druhého zdrojového registru <strong>Wm/Xm</strong>, u které se nejdříve změní znaménko (onen zmíněný dvojkový doplněk).</p>

<p>Tato instrukce tedy nahrazuje programovou konstrukci typu:</p>

<pre>
cíl = condition ? zdroj1 : -zdroj2;
</pre>



<p><a name="k14"></a></p>
<h2 id="k14">14. Instrukce <strong>CINC</strong> &ndash; Conditional Increment</h2>

<p>Instrukce <strong>CINC</strong> je aliasem pro instrukci <strong>CSINC</strong>, ovšem s&nbsp;převrácenou podmínkou a shodnými zdrojovými registry:</p>

<pre>
CINC Wd, Wn, condition
CINC Xd, Xn, condition
</pre>

<p>Tato instrukce provádí následující činnost (je zde jen jediný zdrojový registr):</p>

<pre>
Wd = condition ? Wn+1 : Wn;
Xd = condition ? Xn+1 : Xn;
</pre>

<p>Použití této instrukce je různé, může se například použít pro realizaci příkazu <strong>continue</strong> v&nbsp;programovacím jazyku C.</p>



<p><a name="k15"></a></p>
<h2 id="k15">15. Instrukce <strong>CINV</strong> &ndash; Conditional Invert</h2>

<p>Podobná instrukce taktéž s&nbsp;jedním zdrojovým registrem se jmenuje <strong>CINV</strong>:</p>

<pre>
CINV Wd, Wn, condition
CINV Xd, Xn, condition
</pre>

<p>Prováděná činnost je následující (tilda znamená negaci bit po bitu):</p>

<pre>
Wd = condition ? ~Wn : Wn;
Xd = condition ? ~Xn : Xn;
</pre>

<p>Ve skutečnosti se opět jedná o instrukční alias rozpoznávaný assemblery. V&nbsp;tomto případě lze <strong>CINV</strong> nahradit instrukcí <strong>CSINV</strong> s&nbsp;oběma zdrojovými registry totožnými:</p>

<pre>
CSINV Wd, Wn, Wn, invert(condition)
CSINV Xd, Xn, Xn, invert(condition)
</pre>



<p><a name="k16"></a></p>
<h2 id="k16">16. Instrukce <strong>CNEG</strong> &ndash; Conditional Negate</h2>

<p>Poslední instrukce, přesněji řečeno (opět) instrukční alias se jmenuje <strong>CNEG</strong>:</p>

<pre>
CNEG Wd, Wn, condition
CNEG Xd, Xn, condition
</pre>

<p>Prováděná činnost:</p>

<pre>
Wd = condition ? -Wn : Wn;
Xd = condition ? -Xn : Xn;
</pre>

<p>Tento alias lze nahradit za <strong>CSNEG</strong> s&nbsp;totožnými zdrojovými registry a opačně zapsanou podmínkou:</p>

<pre>
CSNEG Wd, Wn, Wn, invert(condition)
CSNEG Xd, Xn, Xn, invert(condition)
</pre>



<p><a name="k17"></a></p>
<h2 id="k17">17. Instrukce <strong>TBZ</strong> a <strong>TBNZ</strong> (Test and Branch...)</h2>

<p>Poslední dvě instrukce, které si dnes popíšeme, spadají do kategorie podmíněných skoků. Tyto instrukce se jmenují <strong>TBZ</strong> (<i>Test and Branch if Zero</i>) a <strong>TBNZ</strong> (<i>Test and Branch if Not Zero</i>). Způsob zápisu těchto instrukcí je následující:</p>

<pre>
TBZ  Xn, #konstanta, návěští
TBZ  Wn, #konstanta, návěští
TBNZ Xn, #konstanta, návěští
TBNZ Wn, #konstanta, návěští
</pre>

<p>Konstanta má šířku pouze šest bitů, protože je v&nbsp;ní uložen index bitu pracovního registru, který se testuje na nulu či jedničku (u registrů Wn by stačilo jen pět bitů). V&nbsp;případě instrukce <strong>TBZ</strong> &ndash; pokud je n-tý bit registru <strong>Xn/Wn</strong> nastavený na nulu, provede se skok, v&nbsp;opačném případě se řízení přenese na další instrukci. V&nbsp;případě instrukce <strong>TBNZ</strong> je bit testován na nulu. Vzhledem k&nbsp;tomu, že v&nbsp;instrukčním slovu je nutné kromě adresy cíle (návěští) specifikovat i číslo pracovního registru a index bitu, je tento typ skoku omezen na rozsah &pm;32kB, což by ovšem v&nbsp;praxi mělo být více než dostačující (v&nbsp;opačném případě lze <strong>TBZ/TBNZ</strong> zkombinovat s&nbsp;absolutním skokem <strong>B</strong>).</p>



<p><a name="k18"></a></p>
<h2 id="k18">18. Repositář s&nbsp;demonstračními příklady</h2>

<p>Všechny <a
href="https://www.root.cz/clanky/specificke-vlastnosti-procesoru-aarch64-podminene-a-nepodminene-skoky-adresovani-dat/">minule</a>
i dnes popisované demonstrační příklady byly společně s&nbsp;podpůrným souborem
<strong>Makefile</strong> určeným pro jejich překlad či naopak pro
disassembling, uloženy do GIT repositáře dostupného na adrese <a
href="https://github.com/tisnik/presentations/">https://github.com/tisnik/presentations/</a>.
Všechny příklady jsou určeny pro standardní <i>GNU Assembler</i> a používají
výchozí syntaxi procesorů AArch64. Následuje tabulka s&nbsp;odkazy na zdrojové
kódy příkladů i na již zmíněné podpůrné skripty:</p>

<table>
<tr><th> #</th><th>Příklad</th><th>Popis</th><th>Zdrojový kód</th></tr>
<tr><td> 1</td><td>template.s</td><td>šablona pro programy psané v&nbsp;assembleru</td><td><a href="https://github.com/tisnik/presentations/blob/master/assembler/aarch64/template.s">https://github.com/tisnik/presentations/blob/master/assembler/aarch64/template.s</a></td></tr>
<tr><td> 2</td><td>template_2.s</td><td>šablona pro programy psané v&nbsp;assembleru, založeno na makrech</td><td><a href="https://github.com/tisnik/presentations/blob/master/assembler/aarch64/template_2.s">https://github.com/tisnik/presentations/blob/master/assembler/aarch64/template_2.s</a></td></tr>
<tr><td> 3</td><td>hello_world_1.s</td><td>základní podoba programu typu &bdquo;Hello, world!&ldquo;</td><td><a href="https://github.com/tisnik/presentations/blob/master/assembler/aarch64/hello_world_1.s">https://github.com/tisnik/presentations/blob/master/assembler/aarch64/hello_world_1.s</a></td></tr>
<tr><td> 4</td><td>hello_world_2.s</td><td>přepis tištěného řetězce</td><td><a href="https://github.com/tisnik/presentations/blob/master/assembler/aarch64/hello_world_2.s">https://github.com/tisnik/presentations/blob/master/assembler/aarch64/hello_world_2.s</a></td></tr>
<tr><td> 5</td><td>hello_world_3.s</td><td>refaktoring, použití maker</td><td><a href="https://github.com/tisnik/presentations/blob/master/assembler/aarch64/hello_world_3.s">https://github.com/tisnik/presentations/blob/master/assembler/aarch64/hello_world_3.s</a></td></tr>
<tr><td> 6</td><td>aritmetic1.s</td><td>základní aritmetické operace</td><td><a href="https://github.com/tisnik/presentations/blob/master/assembler/aarch64/aritmetic1.s">https://github.com/tisnik/presentations/blob/master/assembler/aarch64/aritmetic1.s</a></td></tr>
<tr><td> 7</td><td>infinite_loop.s</td><td>nekonečná programová smyčka realizovaná instrukcí <strong>b</strong></td><td><a href="https://github.com/tisnik/presentations/blob/master/assembler/aarch64/infinite_loop.s">https://github.com/tisnik/presentations/blob/master/assembler/aarch64/infinite_loop.s</a></td></tr>
<tr><td> 8</td><td>loop1-aarch64-v1.s</td><td>základní varianta počítané programové smyčky</td><td><a href="https://github.com/tisnik/presentations/blob/master/assembler/aarch64/loop1-aarch64-v1.s">https://github.com/tisnik/presentations/blob/master/assembler/aarch64/loop1-aarch64-v1.s</a></td></tr>
<tr><td> 9</td><td>loop1-aarch64-v2.s</td><td>optimalizace &ndash; odstranění instrukce <strong>CMP</strong></td><td><a href="https://github.com/tisnik/presentations/blob/master/assembler/aarch64/loop1-aarch64-v2.s">https://github.com/tisnik/presentations/blob/master/assembler/aarch64/loop1-aarch64-v2.s</a></td></tr>
<tr><td>10</td><td>loop1-aarch64-v3.s</td><td>optimalizace &ndash; použití instrukce <strong>CBNZ</strong></td><td><a href="https://github.com/tisnik/presentations/blob/master/assembler/aarch64/loop1-aarch64-v3.s">https://github.com/tisnik/presentations/blob/master/assembler/aarch64/loop1-aarch64-v3.s</a></td></tr>
<tr><td>11</td><td>loop1-aarch64-v4.s</td><td>automatické zvýšení adresy (ukazatele)</td><td><a href="https://github.com/tisnik/presentations/blob/master/assembler/aarch64/loop1-aarch64-v4.s">https://github.com/tisnik/presentations/blob/master/assembler/aarch64/loop1-aarch64-v4.s</a></td></tr>
<tr><td>12</td><td>move1.s</td><td>přesun bloku dat</td><td><a href="https://github.com/tisnik/presentations/blob/master/assembler/aarch64/move1.s">https://github.com/tisnik/presentations/blob/master/assembler/aarch64/move1.s</a></td></tr>
<tr><td>13</td><td>move2.s</td><td>přepis s&nbsp;využitím maker</td><td><a href="https://github.com/tisnik/presentations/blob/master/assembler/aarch64/move2.s">https://github.com/tisnik/presentations/blob/master/assembler/aarch64/move2.s</a></td></tr>
<tr><td>14</td><td>move3.s</td><td>problém s&nbsp;vícenásobným použitím makra</td><td><a href="https://github.com/tisnik/presentations/blob/master/assembler/aarch64/move3.s">https://github.com/tisnik/presentations/blob/master/assembler/aarch64/move3.s</a></td></tr>
<tr><td>15</td><td>move4.s</td><td>vyřešení předchozího problému</td><td><a href="https://github.com/tisnik/presentations/blob/master/assembler/aarch64/move4.s">https://github.com/tisnik/presentations/blob/master/assembler/aarch64/move4.s</a></td></tr>
<tr><td>16</td><td>move5.s</td><td>jednoduchý benchmark &ndash; přesun bloků po bajtech</td><td><a href="https://github.com/tisnik/presentations/blob/master/assembler/aarch64/move5.s">https://github.com/tisnik/presentations/blob/master/assembler/aarch64/move5.s</a></td></tr>
<tr><td>17</td><td>move6.s</td><td>jednoduchý benchmark &ndash; přesun bloků po slovech</td><td><a href="https://github.com/tisnik/presentations/blob/master/assembler/aarch64/move6.s">https://github.com/tisnik/presentations/blob/master/assembler/aarch64/move6.s</a></td></tr>
<tr><td>18</td><td>move7.s</td><td>jednoduchý benchmark &ndash; přesun bloků po dvojicích slov</td><td><a href="https://github.com/tisnik/presentations/blob/master/assembler/aarch64/move7.s">https://github.com/tisnik/presentations/blob/master/assembler/aarch64/move7.s</a></td></tr>
<tr><td>19</td><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td></tr>
<tr><td>20</td><td>Makefile</td><td>soubor pro překlad všech příkladů nástrojem <strong>make</strong></td><td><a href="https://github.com/tisnik/presentations/blob/master/assembler/aarch64/Makefile">https://github.com/tisnik/presentations/blob/master/assembler/aarch64/Makefile</a></td></tr>
</table>



<p><a name="k19"></a></p>
<h2 id="k19">19. Předchozí články o architektuře AArch64</h2>

<p>S&nbsp;architekturou AArch64 jsme se již na stránkách Roota setkali, a to
konkrétně v&nbsp;následujících článcích, z&nbsp;nichž dnes vycházíme:</p>

<ol>

<li>64bitové mikroprocesory s architekturou AArch64<br />
<a href="https://www.root.cz/clanky/64bitove-mikroprocesory-s-architekturou-aarch64/">https://www.root.cz/clanky/64bitove-mikroprocesory-s-architekturou-aarch64/</a>
</li>

<li>Instrukční sada AArch64<br />
<a href="https://www.root.cz/clanky/instrukcni-sada-aarch64/">https://www.root.cz/clanky/instrukcni-sada-aarch64/</a>
</li>

<li>Instrukční sada AArch64 (2.část)<br />
<a href="https://www.root.cz/clanky/instrukcni-sada-aarch64-2-cast/">https://www.root.cz/clanky/instrukcni-sada-aarch64-2-cast/</a>
</li>

<li>Tvorba a ladění programů v&nbsp;assembleru mikroprocesorů AArch64<br />
<a href="https://www.root.cz/clanky/tvorba-a-ladeni-programu-v-assembleru-mikroprocesoru-aarch64/">https://www.root.cz/clanky/tvorba-a-ladeni-programu-v-assembleru-mikroprocesoru-aarch64/</a>
</li>

<li>Instrukční sada AArch64: technologie NEON<br />
<a href="https://www.root.cz/clanky/instrukcni-sada-aarch64-technologie-neon/">https://www.root.cz/clanky/instrukcni-sada-aarch64-technologie-neon/</a>
</li>

<li>Specifické vlastnosti procesorů AArch64: základní instrukce<br />
<a href="https://www.root.cz/clanky/specificke-vlastnosti-procesoru-aarch64-zakladni-instrukce/">https://www.root.cz/clanky/specificke-vlastnosti-procesoru-aarch64-zakladni-instrukce/</a>
</li>

<li>Specifické vlastnosti procesorů AArch64: podmíněné a nepodmíněné skoky, adresování dat<br />
<a href="https://www.root.cz/clanky/specificke-vlastnosti-procesoru-aarch64-podminene-a-nepodminene-skoky-adresovani-dat/">https://www.root.cz/clanky/specificke-vlastnosti-procesoru-aarch64-podminene-a-nepodminene-skoky-adresovani-dat/</a>
</li>

</ol>



<p><a name="k20"></a></p>
<h2 id="k20">20. Odkazy na Internetu</h2>

<ol>

<li>Arm Architecture Reference Manual for A-profile architecture<br />
<a href="https://developer.arm.com/documentation/ddi0487/latest">https://developer.arm.com/documentation/ddi0487/latest</a>
</li>

<li>The GNU Assembler - macros<br />
<a href="http://tigcc.ticalc.org/doc/gnuasm.html#SEC109">http://tigcc.ticalc.org/doc/gnuasm.html#SEC109</a>
</li>

<li>GNU Binutils<br />
<a href="https://sourceware.org/binutils/">https://sourceware.org/binutils/</a>
</li>

<li>Documentation for binutils 2.38<br />
<a href="https://sourceware.org/binutils/docs-2.38/">https://sourceware.org/binutils/docs-2.38/</a>
</li>

<li>AArch64 Instruction Set Architecture<br />
<a href="https://developer.arm.com/architectures/learn-the-architecture/aarch64-instruction-set-architecture/instruction-sets-in-the-arm-architecture">https://developer.arm.com/architectures/learn-the-architecture/aarch64-instruction-set-architecture/instruction-sets-in-the-arm-architecture</a>
</li>

<li>Arm Armv8-A A32/T32 Instruction Set Architecture<br />
<a href="https://developer.arm.com/documentation/ddi0597/2021-12/?lang=en">https://developer.arm.com/documentation/ddi0597/2021-12/?lang=en</a>
</li>

<li>Comparison of ARMv8-A cores<br />
<a href="https://en.wikipedia.org/wiki/Comparison_of_ARMv8-A_cores">https://en.wikipedia.org/wiki/Comparison_of_ARMv8-A_cores</a>
</li>

<li>Cortex-A32 Processor<br />
<a href="https://www.arm.com/products/processors/cortex-a/cortex-a32-processor.php">https://www.arm.com/products/processors/cortex-a/cortex-a32-processor.php</a>
</li>

<li>Cortex-A35 Processor<br />
<a href="https://www.arm.com/products/processors/cortex-a/cortex-a35-processor.php">https://www.arm.com/products/processors/cortex-a/cortex-a35-processor.php</a>
</li>

<li>Cortex-A53 Processor<br />
<a href="https://www.arm.com/products/processors/cortex-a/cortex-a53-processor.php">https://www.arm.com/products/processors/cortex-a/cortex-a53-processor.php</a>
</li>

<li>Cortex-A57 Processor<br />
<a href="https://www.arm.com/products/processors/cortex-a/cortex-a57-processor.php">https://www.arm.com/products/processors/cortex-a/cortex-a57-processor.php</a>
</li>

<li>Cortex-A72 Processor<br />
<a href="https://www.arm.com/products/processors/cortex-a/cortex-a72-processor.php">https://www.arm.com/products/processors/cortex-a/cortex-a72-processor.php</a>
</li>

<li>Cortex-A73 Processor<br />
<a href="https://www.arm.com/products/processors/cortex-a/cortex-a73-processor.php">https://www.arm.com/products/processors/cortex-a/cortex-a73-processor.php</a>
</li>

<li>Apple A7 (SoC založen na CPU Cyclone)<br />
<a href="https://en.wikipedia.org/wiki/Apple_A7">https://en.wikipedia.org/wiki/Apple_A7</a>
</li>

<li>System cally pro AArch64 na Linuxu<br />
<a href="https://github.com/torvalds/linux/blob/master/include/uapi/asm-generic/unistd.h">https://github.com/torvalds/linux/blob/master/include/uapi/asm-generic/unistd.h</a>
</li>

<li>Architectures/AArch64 (FedoraProject.org)<br />
<a href="https://fedoraproject.org/wiki/Architectures/AArch64">https://fedoraproject.org/wiki/Architectures/AArch64</a>
</li>

<li>SIG pro AArch64 (CentOS)<br />
<a href="https://wiki.centos.org/SpecialInterestGroup/AltArch/AArch64">https://wiki.centos.org/SpecialInterestGroup/AltArch/AArch64</a>
</li>

<li>The ARMv8 instruction sets<br />
<a href="http://infocenter.arm.com/help/index.jsp?topic=/com.arm.doc.den0024a/ch05s01.html">http://infocenter.arm.com/help/index.jsp?topic=/com.arm.doc.den0024a/ch05s01.html</a>
</li>

<li>A64 Instruction Set<br />
<a href="https://developer.arm.com/products/architecture/instruction-sets/a64-instruction-set">https://developer.arm.com/products/architecture/instruction-sets/a64-instruction-set</a>
</li>

<li>Switching between the instruction sets<br />
<a href="http://infocenter.arm.com/help/index.jsp?topic=/com.arm.doc.den0024a/ch05s01.html">http://infocenter.arm.com/help/index.jsp?topic=/com.arm.doc.den0024a/ch05s01.html</a>
</li>

<li>The A64 instruction set<br />
<a href="http://infocenter.arm.com/help/index.jsp?topic=/com.arm.doc.den0024a/ch05s01.html">http://infocenter.arm.com/help/index.jsp?topic=/com.arm.doc.den0024a/ch05s01.html</a>
</li>

<li>Introduction to ARMv8 64-bit Architecture<br />
<a href="https://quequero.org/2014/04/introduction-to-arm-architecture/">https://quequero.org/2014/04/introduction-to-arm-architecture/</a>
</li>

<li>MCU market turns to 32-bits and ARM<br />
<a href="http://www.eetimes.com/document.asp?doc_id=1280803">http://www.eetimes.com/document.asp?doc_id=1280803</a>
</li>

<li>Cortex-M0 Processor (ARM Holdings)<br />
<a href="http://www.arm.com/products/processors/cortex-m/cortex-m0.php">http://www.arm.com/products/processors/cortex-m/cortex-m0.php</a>
</li>

<li>Cortex-M0+ Processor (ARM Holdings)<br />
<a href="http://www.arm.com/products/processors/cortex-m/cortex-m0plus.php">http://www.arm.com/products/processors/cortex-m/cortex-m0plus.php</a>
</li>

<li>ARM Processors in a Mixed Signal World<br />
<a href="http://www.eeweb.com/blog/arm/arm-processors-in-a-mixed-signal-world">http://www.eeweb.com/blog/arm/arm-processors-in-a-mixed-signal-world</a>
</li>

<li>ARM Architecture (Wikipedia)<br />
<a href="https://en.wikipedia.org/wiki/ARM_architecture">https://en.wikipedia.org/wiki/ARM_architecture</a>
</li>

<li>DSP for Cortex-M<br />
<a href="https://developer.arm.com/technologies/dsp/dsp-for-cortex-m">https://developer.arm.com/technologies/dsp/dsp-for-cortex-m</a>
</li>

<li>Cortex-M processors in DSP applications? Why not?!<br />
<a href="https://community.arm.com/processors/b/blog/posts/cortex-m-processors-in-dsp-applications-why-not">https://community.arm.com/processors/b/blog/posts/cortex-m-processors-in-dsp-applications-why-not</a>
</li>

<li>White Paper - DSP capabilities of Cortex-M4 and Cortex-M7<br />
<a href="https://community.arm.com/processors/b/blog/posts/white-paper-dsp-capabilities-of-cortex-m4-and-cortex-m7">https://community.arm.com/processors/b/blog/posts/white-paper-dsp-capabilities-of-cortex-m4-and-cortex-m7</a>
</li>

<li>Q (number format)<br />
<a href="https://en.wikipedia.org/wiki/Q_%28number_format%29">https://en.wikipedia.org/wiki/Q_%28number_format%29</a>
</li>

<li>TriCore Architecture &amp; Core<br />
<a href="http://www.infineon.com/cms/en/product/microcontroller/32-bit-tricore-tm-microcontroller/tricore-tm-architecture-and-core/channel.html?channel=ff80808112ab681d0112ab6b73d40837">http://www.infineon.com/cms/en/product/microcontroller/32-bit-tricore-tm-microcontroller/tricore-tm-architecture-and-core/channel.html?channel=ff80808112ab681d0112ab6b73d40837</a>
</li>

<li>TriCoreTM V1.6 Instruction Set: 32-bit Unified Processor Core<br />
<a href="http://www.infineon.com/dgdl/tc_v131_instructionset_v138.pdf?fileId=db3a304412b407950112b409b6dd0352">http://www.infineon.com/dgdl/tc_v131_instructionset_v138.pdf?fileId=db3a304412b407950112b409b6dd0352</a>
</li>

<li>TriCore v2.2 C Compiler, Assembler, Linker Reference Manual<br />
<a href="http://tasking.com/support/tricore/tc_reference_guide_v2.2.pdf">http://tasking.com/support/tricore/tc_reference_guide_v2.2.pdf</a>
</li>

<li>Infineon TriCore (Wikipedia)<br />
<a href="https://en.wikipedia.org/wiki/Infineon_TriCore">https://en.wikipedia.org/wiki/Infineon_TriCore</a>
</li>

<li>C166®S V2 Architecture &amp; Core<br />
<a href="http://www.infineon.com/cms/en/product/microcontroller/16-bit-c166-microcontroller/c166-s-v2-architecture-and-core/channel.html?channel=db3a304312bef5660112c3011c7d01ae">http://www.infineon.com/cms/en/product/microcontroller/16-bit-c166-microcontroller/c166-s-v2-architecture-and-core/channel.html?channel=db3a304312bef5660112c3011c7d01ae</a>
</li>

<li>Comparing four 32-bit soft processor cores<br />
<a href="http://www.eetimes.com/author.asp?section_id=14&doc_id=1286116">http://www.eetimes.com/author.asp?section_id=14&doc_id=1286116</a>
</li>

<li>RISC-V Instruction Set<br />
<a href="http://riscv.org/download.html#spec_compressed_isa">http://riscv.org/download.html#spec_compressed_isa</a>
</li>

<li>RISC-V Spike (ISA Simulator)<br />
<a href="http://riscv.org/download.html#isa-sim">http://riscv.org/download.html#isa-sim</a>
</li>

<li>RISC-V (Wikipedia)<br />
<a href="https://en.wikipedia.org/wiki/RISC-V">https://en.wikipedia.org/wiki/RISC-V</a>
</li>

<li>David Patterson (Wikipedia)<br />
<a href="https://en.wikipedia.org/wiki/David_Patterson_(computer_scientist)">https://en.wikipedia.org/wiki/David_Patterson_(computer_scientist)</a>
</li>

<li>OpenRISC (oficiální stránky projektu)<br />
<a href="http://openrisc.io/">http://openrisc.io/</a>
</li>

<li>OpenRISC architecture<br />
<a href="http://openrisc.io/architecture.html">http://openrisc.io/architecture.html</a>
</li>

<li>Emulátor OpenRISC CPU v JavaScriptu<br />
<a href="http://s-macke.github.io/jor1k/demos/main.html">http://s-macke.github.io/jor1k/demos/main.html</a>
</li>

<li>OpenRISC (Wikipedia)<br />
<a href="https://en.wikipedia.org/wiki/OpenRISC">https://en.wikipedia.org/wiki/OpenRISC</a>
</li>

<li>OpenRISC - instrukce<br />
<a href="http://sourceware.org/cgen/gen-doc/openrisc-insn.html">http://sourceware.org/cgen/gen-doc/openrisc-insn.html</a>
</li>

<li>OpenRISC - slajdy z přednášky o projektu<br />
<a href="https://iis.ee.ethz.ch/~gmichi/asocd/lecturenotes/Lecture6.pdf">https://iis.ee.ethz.ch/~gmichi/asocd/lecturenotes/Lecture6.pdf</a>
</li>

<li>Berkeley RISC<br />
<a href="http://en.wikipedia.org/wiki/Berkeley_RISC">http://en.wikipedia.org/wiki/Berkeley_RISC</a>
</li>

<li>Great moments in microprocessor history<br />
<a href="http://www.ibm.com/developerworks/library/pa-microhist.html">http://www.ibm.com/developerworks/library/pa-microhist.html</a>
</li>

<li>Microprogram-Based Processors<br />
<a href="http://research.microsoft.com/en-us/um/people/gbell/Computer_Structures_Principles_and_Examples/csp0167.htm">http://research.microsoft.com/en-us/um/people/gbell/Computer_Structures_Principles_and_Examples/csp0167.htm</a>
</li>

<li>Great Microprocessors of the Past and Present<br />
<a href="http://www.cpushack.com/CPU/cpu1.html">http://www.cpushack.com/CPU/cpu1.html</a>
</li>

<li>A Brief History of Microprogramming<br />
<a href="http://www.cs.clemson.edu/~mark/uprog.html">http://www.cs.clemson.edu/~mark/uprog.html</a>
</li>

<li>What is RISC?<br />
<a href="http://www-cs-faculty.stanford.edu/~eroberts/courses/soco/projects/2000-01/risc/whatis/">http://www-cs-faculty.stanford.edu/~eroberts/courses/soco/projects/2000-01/risc/whatis/</a>
</li>

<li>RISC vs. CISC<br />
<a href="http://www-cs-faculty.stanford.edu/~eroberts/courses/soco/projects/2000-01/risc/risccisc/">http://www-cs-faculty.stanford.edu/~eroberts/courses/soco/projects/2000-01/risc/risccisc/</a>
</li>

<li>RISC and CISC definitions:<br />
<a href="http://www.cpushack.com/CPU/cpuAppendA.html">http://www.cpushack.com/CPU/cpuAppendA.html</a>
</li>

<li>FPGA<br />
<a href="https://cs.wikipedia.org/wiki/Programovateln%C3%A9_hradlov%C3%A9_pole">https://cs.wikipedia.org/wiki/Programovateln%C3%A9_hradlov%C3%A9_pole</a>
</li>

<li>The Evolution of RISC<br />
<a href="http://www.ibm.com/developerworks/library/pa-microhist.html#sidebar1">http://www.ibm.com/developerworks/library/pa-microhist.html#sidebar1</a>
</li>

<li>disasm.pro<br />
<a href="https://disasm.pro/">https://disasm.pro/</a>
</li>

<li>Exploring AArch64 assembler &ndash; Chapter 5<br />
<a href="https://thinkingeek.com/2016/11/13/exploring-aarch64-assembler-chapter-5/">https://thinkingeek.com/2016/11/13/exploring-aarch64-assembler-chapter-5/</a>
</li>

</ol>



<p></p><p></p>
<p><small>Autor: <a href="http://www.fit.vutbr.cz/~tisnovpa">Pavel Tišnovský</a> &nbsp; 2022</small></p>
</body>
</html>

