<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
        "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html>
<head>
<title>Zpracování hodnot typu half float (fp16) na platformě AArch64</title>
<meta name="Author" content="Pavel Tisnovsky" />
<meta name="Generator" content="vim" />
<meta http-equiv="content-type" content="text/html; charset=utf-8" />
<style type="text/css">
         body {color:#000000; background:#ffffff;}
         h1  {font-family: arial, helvetica, sans-serif; color:#ffffff; background-color:#c00000; text-align:center; padding-left:1em}
         h2  {font-family: arial, helvetica, sans-serif; color:#ffffff; background-color:#0000c0; padding-left:1em; text-align:left}
         h3  {font-family: arial, helvetica, sans-serif; color:#000000; background-color:#c0c0c0; padding-left:1em; text-align:left}
         h4  {font-family: arial, helvetica, sans-serif; color:#000000; background-color:#e0e0e0; padding-left:1em; text-align:left}
         a   {font-family: arial, helvetica, sans-serif;}
         li  {font-family: arial, helvetica, sans-serif; color:#000000; text-align:justify; width:450px;}
         ol  {font-family: arial, helvetica, sans-serif; color:#000000; text-align:justify; width:450px;}
         ul  {font-family: arial, helvetica, sans-serif; color:#000000; text-align:justify; width:450px;}
         p   {font-family: arial, helvetica, sans-serif; color:#000000; text-align:justify;}
         pre {background:#e0e0e0}
</style>
</head>

<body>

<h1>Zpracování hodnot typu half float (fp16) na platformě AArch64</h1>

<h3>Pavel Tišnovský</h3>

<p></p>

<h1>Úvodník</h1>

<p></p>



<h2>Obsah</h2>

<p><a href="#k01">*** 1. Zpracování hodnot typu <i>half float</i> (<i>fp16</i>) na platformě AArch64</a></p>
<p><a href="#k02">2. Podpora technologie NEON v&nbsp;ARMovských jádrech AArch64</a></p>
<p><a href="#k03">3. Pracovní registry používané instrukcemi NEON</a></p>
<p><a href="#k04">4. Podporované formáty prvků vektorů</a></p>
<p><a href="#k05">5. Vrácení hodnoty prvního resp.&nbsp;druhého parametru typu <i>half float</i></a></p>
<p><a href="#k06">6. Překlad operace součtu dvou hodnot typu <i>half float</i></a></p>
<p><a href="#k07">7. Překlad využívající instrukce pro přímé operace s&nbsp;hodnotami typu <i>half float</i></a></p>
<p><a href="#k08">8. Způsob překladu všech čtyř základních aritmetických operací nad hodnotami typu <i>half float</i></a></p>
<p><a href="#k09">9. Překlad operací pro porovnání dvou hodnot typu <i>half float</i></a></p>
<p><a href="#k10">10. NEON a operace nad celými vektory</a></p>
<p><a href="#k11">11. Přičtení konstanty ke všem prvkům pole</a></p>
<p><a href="#k12">12. Součet odpovídajících si prvků polí typu <i>half float</i></a></p>
<p><a href="#k13">13. Pomáháme překladači: klíčové slovo <strong>restrict</strong></a></p>
<p><a href="#k14">14. Překlad součtu polí s&nbsp;menším počtem prvků</a></p>
<p><a href="#k15">*** 15. Intrinsic pro provádění operací s&nbsp;hodnotami typu <i>half float</i></a></p>
<p><a href="#k16">*** 16. Realizace součtu dvou hodnot typu <i>half float</i> přes intrinsic funkci</a></p>
<p><a href="#k17">*** 17. Základní aritmetické operace s&nbsp;hodnotami typu <i>half float</i> realizované přes intrinsic</a></p>
<p><a href="#k18">*** 18. </a></p>
<p><a href="#k19">*** 19. Repositář s&nbsp;demonstračními příklady</a></p>
<p><a href="#k20">20. Odkazy na Internetu</a></p>



<p><a name="k01"></a></p>
<h2 id="k01">1. Zpracování hodnot typu <i>half float</i> (<i>fp16</i>) na platformě AArch64</h2>

<p>Formát <i>half float</i>, jenž je dnes standardizován v&nbsp;<i>IEEE
754-2008</i>, používá pro ukládání hodnot s&nbsp;plovoucí řádovou čárkou
pouhých šestnáct bitů, tj.&nbsp;dva byty. Maximální hodnota je rovna 65504,
minimální hodnota (větší než nula) přibližně 5,9&times;10<sup>-8</sup>.
Předností tohoto formátu je malá bitová šířka (umožňuje paralelní přenos po
interních sběrnicích GPU) a také větší rychlost zpracování základních operací,
protože pro tak malou bitovou šířku mantisy je možné některé operace
&bdquo;zadrátovat&ldquo; a nepočítat pomocí ALU. Také některé iterativní
výpočty (sin, cos, sqrt) mohou být provedeny rychleji, než v&nbsp;případě
plnohodnotných typů <strong>float</strong> a <strong>single</strong>.</p>

<table>
<tr><td>Celkový počet bitů (bytů):</td><td>16 (2)</td></tr>
<tr><td>Bitů pro znaménko:</td><td>1</td></tr>
<tr><td>Bitů pro exponent:</td><td>5</td></tr>
<tr><td>Bitů pro mantisu:</td><td>10</td></tr>
<tr><td>BIAS (offset exponentu):</td><td>15</td></tr>
<tr><td>Přesnost:</td><td>5-6 číslic</td></tr>
<tr><td>Maximální hodnota:</td><td>65504</td></tr>
<tr><td>Minimální hodnota:</td><td>-65504</td></tr>
<tr><td>Nejmenší kladná nenulová hodnota:</td><td>5,96&times;10<sup>-8</sup></td></tr>
<tr><td>Nejmenší kladná normalizovaná hodnota:</td><td>6,104&times;10<sup>-5</sup></td></tr>
<tr><td>Podpora záporné nuly:</td><td>ano</td></tr>
<tr><td>Podpora +&infin;:</td><td>ano</td></tr>
<tr><td>Podpora -&infin;:</td><td>ano</td></tr>
<tr><td>Podpora NaN:</td><td>ano</td></tr>
</table>
<p>Pokud se podíváme na historii mikroprocesorů ARM, zjistíme, že cesta k&nbsp;technologii NEON na jádrech AArch64 vlastně nebyla vůbec přímočará.  První implementace &bdquo;vektorových&ldquo; operací pro procesory ARM používaly rozhraní pro koprocesory, takže se vlastně používala paralelní/doplňková instrukční sada. Konkrétně se jednalo o technologii nazvanou <i>VFP</i> neboli <i>Vector Floating Point</i>. Touto technologií, která je stále na některých ARMovských jádrech podporována, jsme se již v&nbsp;seriálu o architekturách počítačů <a href="https://www.root.cz/clanky/mikroprocesory-arm-a-architektura-vfp-vector-floating-point/">zabývali</a>.  Na tomto místě je vhodné zdůraznit, že i přesto, že se v&nbsp;názvu VFP používá termín &bdquo;vector&ldquo;, nejednalo se o implementaci skutečných SIMD operací, protože se prvky vektorů zpracovávaly postupně, tedy sekvenčně (stále se však jednalo o vylepšení, protože se ušetřilo načtení instrukce a její dekódování). Z&nbsp;tohoto důvodu byl &bdquo;vektorový režim&ldquo; VFP poměrně rychle nahrazen novou technologií nazvanou NEON označovanou též Advanced SIMD.  Dnes se s&nbsp;VFP můžeme na některých ARMovských jádrech setkat, další jádra pak podporují jen <i>VFPLite</i>, kde však každá operace trvá zhruba deset strojových cyklů!</p>

<p>Technologie NEON již podporovala plnohodnotné SIMD operace, při použití vektorů s&nbsp;nejmenšími prvky o velikosti jednoho bajtu až šestnáct operací (například součtu) paralelně. Díky tomu bylo možné implementovat například dekodér pro známý formát MP3 na mikroprocesoru s&nbsp;taktem pouhých 10 MHz popř.&nbsp;implementovat <a href="https://cs.wikipedia.org/wiki/AMR_%28kodek%29">AMR kodek</a> na podobném čipu, ovšem s&nbsp;hodinovým taktem 13 MHz. Při použití klasických výpočtů se skalárními hodnotami by bylo nutné použít čip s&nbsp;vyšší hodinovou frekvencí či naopak &ndash; tento výkonný čip by již neměl dostatek výkonu pro provádění dalších činností. Pro ukázku: ještě mikroprocesory 486DX2 s&nbsp;hodinovou frekvencí 66 MHz měly s&nbsp;dekódováním MP3 velké problémy a zvládaly jen menší bitrate a monofonní výstup). Právě díky NEONu se začaly čipy ARM používat i v&nbsp;některých oblastech, které byly dříve vyhrazeny digitálním signálovým procesorům.</p>

<p>Mimo VFP a NEON bylo pro některá (dnes již notně stará) jádra ARM vyvinuto rozšíření pro <i>DSP</i> operace. Konkrétně se jednalo o jádra <i>ARMv5TE</i>.  Nové instrukce byly využitelné například při kódování a dekódování videa, při zpracování zvukového signálu (včetně zvukové syntézy), práci s&nbsp;rastrovými obrazy (<i>image processing</i>) atd. Instrukce typu <i>Load &amp; Store</i> mohly pracovat s&nbsp;registrovými páry, zavedeny byly nové adresovací režimy, aritmetika se saturací (tj.&nbsp;bez přetečení) a taktéž instrukce typu &bdquo;multiply and accumulate (<strong>MAC</strong>)&ldquo; 16&times;16 bitů a 32&times;16 bitů, které mohly být v&nbsp;instrukční pipeline vykonány v&nbsp;rozmezí jednoho taktu (v&nbsp;jejich průběhu se tedy mohly začít zpracovávat další instrukce). Uvádí se, že při zpracování signálů byla výkonnost nových instrukcí v&nbsp;jádrech <i>ARMv5TE</i> dvakrát až třikrát vyšší, než při použití &bdquo;běžných&ldquo; jader <i>ARMv5</i> (samozřejmě za předpokladu ruční optimalizace kódu, což ostatně až na některé výjimky platí dodnes, protože <i>intrinsic</i> nejsou samospasitelné).</p>

<p>Další odbočkou byla technologie <i>SIMD extensions for multimedia</i> pro jádra ARMv6, která byla později nahrazena Advanced SIMD (NEONem).</p>

<p>Poznámka: skutečná míra paralelnosti SIMD operací se na různých ARM jádrech lišila. Například na Cortex-A8 se sice stále daly provádět operace se 128bitovými registry obsahujícími prvky vektorů (viz navazující kapitoly), ovšem ve skutečnosti se v&nbsp;daný okamžik zpracovávalo jen 64 bitů, tj.&nbsp;každá operace se musela provádět dvakrát. Naproti tomu na Cortex-15 se již zpracovávaly celé 128bitové registry.</p>



<p><a name="k02"></a></p>
<h2 id="k02">2. Podpora technologie NEON v&nbsp;ARMovských jádrech AArch64</h2>

<p>Na základě specifikace by všechny <a
href="http://infocenter.arm.com/help/index.jsp?topic=/com.arm.doc.den0024a/BABIGHEB.html">standardní
implementace jader ARMv8 (s&nbsp;instrukční sadou A64 a s&nbsp;možností
přepnutí do režimu AArch64) měly technologii NEON podporovat</a>, stejně jako
operace s&nbsp;FP hodnotami. Jinými slovy &ndash; na těchto jádrech už typicky
není nutné řešit například problém &bdquo;hardfp versus softfp&ldquo;. Ovšem
v&nbsp;budoucnosti se pravděpodobně setkáme i se specializovanými jádry
nakonfigurovanými odlišným způsobem, například:</p>

<ul>
<li>NEON nebude vůbec podporován.</li>
<li>FP operace nebudou vůbec podporovány.</li>
<li>NEON+FP budou podporovány, ale bez zpracování výjimek u FP operací.</li>
</ul>

<p>V&nbsp;tomto článku nás ovšem nejvíce zajímá podpora pro <i>half float</i>. Ta existuje ve dvou verzích:</p>

<ul>
<li>Pouze konverzní operace mezi hodnotami uloženými v&nbsp;registrech <strong>H.</strong> (viz další kapitolu)</li>
<li>Podpora pro základní aritmetické operace prováděné přímo s&nbsp;hodnotami typu <i>half float</i></li>
</ul>

<p><div class="rs-tip-major">Poznámka: kvůli tomu, že podpora pro typy <i>half
float</i> nemusí být vždy plně realizována, vyžaduje překladač GCC přesné
uvedení architektury jádra. V&nbsp;opačném případě nebude výsledek překladu
dokonalý, jak ostatně uvidíme v&nbsp;praktické části dnešního článku.</div></p>



<p><a name="k03"></a></p>
<h2 id="k03">3. Pracovní registry používané instrukcemi NEON</h2>

<p>Původní technologie NEON, která byla implementovaná na 32bitových jádrech
ARM, používala sadu třiceti dvou nových pracovních registrů, přičemž každý
takový registr měl šířku 64 bitů. Tato sada byla oddělena od klasických
celočíselných pracovních registrů, což samozřejmě zvýšilo možnosti překladače
při optimalizacích kódu (a teoreticky to mohlo umožnit souběžné provádění
výpočtů). Nové registry byly pojmenovány <strong>D0</strong> až
<strong>D31</strong> (písmeno <strong>D</strong> v&nbsp;tomto případě značí
<i>double</i>), popř.&nbsp;mohly být vždy dva sousední registry spojeny do
jednoho 128bitového registru (ty byly pojmenovány <strong>Q0</strong> až
<strong>Q15</strong>, písmeno <strong>Q</strong> v&nbsp;tomto případě znamená
<i>quad</i>). Pokud jádro kromě NEONu podporovalo i výše zmíněnou VFP
(konkrétně VFPv3 nebo VFPv4), byly registry <strong>D0</strong> až
<strong>D31</strong> sdíleny mezi oběma jednotkami.</p>

<p>U jader ARMv8-A s&nbsp;novou instrukční sadou A64 došlo v&nbsp;této oblasti
k&nbsp;poměrně důležitému vylepšení, protože programátoři mají nově
k&nbsp;dispozici 32 pracovních registrů, ovšem nyní se jedná o plnohodnotné
128bitové registry. Tyto registry jsou současně používány i při běžných
matematických operacích s&nbsp;hodnotami uloženými v&nbsp;systému plovoucí
řádové čárky a taktéž kryptografickým modulem. Došlo ještě k&nbsp;další změně
&ndash; již nedochází k&nbsp;rozdělení jednoho registru pro typ <i>double</i>
do dvou registrů pro hodnotu typu <i>single/float</i>, jako tomu bylo u <a
href="https://www.root.cz/clanky/mikroprocesory-arm-a-architektura-vfp-vector-floating-point/#k02">VFP</a>.
Nově je možné každý registr použít jako 128bitový vektor, pro uložení hodnoty
<i>double</i> (spodních 64 bitů), uložení hodnoty typu <i>single/float</i>
(spodních 32 bitů) popř.&nbsp;(což nás dnes zajímá nejvíce) pro uložení hodnoty
typu <i>half float</i> (spodních 16 bitů).</p>

<p>Horní bity jsou při čtení ignorovány, při zápisu nulovány:</p>

<p>Používá se následující pojmenování registrů:</p>

<table>
<tr><th>Jméno</th><th>Význam</th></tr>
<tr><td>v0..v31</td><td>128bitové registry (využívá se celá jejich bitová šířka)</td></tr>
<tr><td>d0..d31</td><td>spodních 64 bitů registrů v0..v31, použito pro hodnoty typu <i>double</i></td></tr>
<tr><td>s0..s31</td><td>spodních 32 bitů registrů v0..v31, použito pro hodnoty typu <i>single/float</i></td></tr>
<tr><td>h0..h31</td><td>spodních 16 bitů registrů v0..v31, použito pro hodnoty typu <i>half float</i></td></tr>
</table>



<p><a name="k04"></a></p>
<h2 id="k04">4. Podporované formáty prvků vektorů</h2>

<p>Ještě před popisem toho, jakým způsobem se registry používají ve funkci
vektorů, se zmiňme o použitých výrazech. U technologie NEON se používá
následující terminologie:</p>

<ol>

<li><i>Vector</i> vždy značí 64bitovou či 128bitovou část pracovního registru
<strong>Vn</strong>, která je rozdělena na prvky různých typů (s&nbsp;obecně
menším počtem bitů, než má celý vektor).</li>

<li><i>Element</i> je prvek vektoru.</li>

<li><i>Lane</i> označuje index prvku vektoru. U mnoha operací se kombinují
prvky z&nbsp;různých vektorů, které mají shodný index. Příkladem je součet
vektorů, který je (logicky) prováděn po odpovídajících si prvcích.</li>

</ol>

<p>Indexy jednotlivých <i>lanes</i> se zvyšují směrem od nejnižšího bitu
k&nbsp;bitu nejvyššímu. Pro pracovní registry <strong>V0</strong> až
<strong>V31</strong> a použitý typ prvků mohou indexy nabývat těchto
hodnot:</p>

<table>
<tr><th>Vektor</th><th>Indexy jednotlivých lanes</th></tr>
<tr><td>128bitový registr</td><td>&times;</td></tr>
<tr><td>2&times;64 bitů</td><td>1, 0</td></tr>
<tr><td>4&times;32 bitů</td><td>3, 2, 1, 0</td></tr>
<tr><td>8&times;16 bitů</td><td>7, 6, ..0</td></tr>
<tr><td>16&times;8 bitů</td><td>15..0</td></tr>
</table>

<p>Víme již, že je možné namísto 128bitových vektorů používat i vektory
64bitové, tj.&nbsp;registrové aliasy <strong>D0</strong> až
<strong>D31</strong>. Zde samozřejmě bude k&nbsp;dispozici jen polovina indexů,
resp.&nbsp;jen polovina prvků vektorů:</p>

<table>
<tr><th>Vektor</th><th>Indexy jednotlivých lanes</th></tr>
<tr><td>64bitový registr</td><td>&times;</td></tr>
<tr><td>1&times;64 bitů</td><td>0</td></tr>
<tr><td>2&times;32 bitů</td><td>1, 0</td></tr>
<tr><td>4&times;16 bitů</td><td>3, 2, 1, 0</td></tr>
<tr><td>8&times;8 bitů</td><td>7, 6, ..0</td></tr>
</table>



<p><a name="k05"></a></p>
<h2 id="k05">5. Vrácení hodnoty prvního resp.&nbsp;druhého parametru typu <i>half float</i></h2>

<p>Nejprve si ukážeme naprosté základy práce s&nbsp;hodnotami typu <i>half
float</i>, které jsou v&nbsp;jazyku C popsány jako typ
<strong>_Float16</strong> (můžete se ovšem setkat i s&nbsp;použitím
<strong>__fp16</strong>). Hodnoty typu <i>half float</i> jsou předávány přes
registry <strong>Vxx</strong> popsané výše: první parametr v&nbsp;registru
<strong>V0</strong>, druhý v&nbsp;registru <strong>V1</strong> atd. Návratová
hodnota typu <i>half float</i> (pokud funkce hodnotu tohoto typu vrací) je
uložena v&nbsp;registru <strong>V0</strong>:</p>

<pre>
_Float16 <strong>fp16_first</strong>(_Float16 x, _Float16 y) {
    return x;
}
&nbsp;
_Float16 <strong>fp16_second</strong>(_Float16 x, _Float16 y) {
    return y;
}
</pre>

<p>První z&nbsp;těchto funkcí je přeložena do jediné instrukce
<strong>RET</strong>, protože jak první parametr, tak i výsledek funkce je
předáván přes stejný registr <strong>V0</strong>:</p>

<pre>
<strong>fp16_first</strong>:
        ret
</pre>

<p>Druhá funkce obsahuje pouze operaci přesunu jedné hodnoty typu <i>half
float</i> z&nbsp;registru <strong>V1</strong> (druhý parametr) do registru
<strong>V0</strong> (návratová hodnota):</p>

<pre>
<strong>fp16_second</strong>:
        mov     v0.h[0], v1.h[0]
        ret
</pre>



<p><a name="k06"></a></p>
<h2 id="k06">6. Překlad operace součtu dvou hodnot typu <i>half float</i></h2>

<p>Pokusme se nyní přeložit velmi jednoduchou funkci, která provede součet
dvojice hodnot typu <i>half float</i>. Tento typ se v&nbsp;GCC jmenuje
<strong>_Float16</strong>. Realizace takové funkce je triviální:</p>

<pre>
_Float16 <strong>fp16_add</strong>(_Float16 x, _Float16 y) {
    _Float16 z = x + y;
    return z;
}
</pre>

<p>Překlad pro platformu AArch64 může dopadnout následovně:</p>

<pre>
<strong>fp16_add</strong>:
        fcvt    s1, h1
        fcvt    s0, h0
        fadd    s0, s0, s1
        fcvt    h0, s0
        ret
</pre>

<p><div class="rs-tip-major">Poznámka: při překladu bude vždy zvolen maximální
stupeň optimalizace.</div></p>

<p>Povšimněte si, že se nejdříve instrukcemi <strong>FCVT</strong> provede
převod obou operandů předaných v&nbsp;registrech <strong>H0</strong> a
<strong>H1</strong> na typ <i>single</i>, následně se instrukci
<strong>FADD</strong> provede součet obou hodnot typu <i>single</i> a posléze
se provede převod zpět na typ <i>half float</i>, a to opět instrukcí
<strong>FCVT</strong>.</p>



<p><a name="k07"></a></p>
<h2 id="k07">7. Překlad využívající instrukce pro přímé operace s&nbsp;hodnotami typu <i>half float</i></h2>

<p><a href="k05">Výše uvedený</a> výsledek překladu pochopitelně není ideální,
protože se provádí konverze z&nbsp;typu <i>half float</i> na <i>single</i> a
zpět. Ovšem pokud překladači naznačíme, že cílová platforma umožňuje přímé
provádění (některých) operací s&nbsp;hodnotami typu <i>half float</i>, bude
situace odlišná. Podpora pro <i>half float</i> byla přidána do ARMv8.2, kterou
mnohá existující ARM jádra splňují. Upravíme tedy příkaz pro překlad &ndash;
předáme následující přepínače:</p>

<pre>
-O9 -ffast-math -march=armv8.2-a+fp16
</pre>

<p>Nyní se ve vygenerovaném strojovém kódu nebudou žádné konverze provádět a
pouze se přímo sečtou obě předané hodnoty typu <i>half float</i> s&nbsp;tím, že
výsledkem je opět hodnota stejného typu:</p>

<pre>
<strong>fp16_add</strong>(_Float16, _Float16):
        fadd    h0, h0, h1
        ret
</pre>



<p><a name="k08"></a></p>
<h2 id="k08">8. Způsob překladu všech čtyř základních aritmetických operací nad hodnotami typu <i>half float</i></h2>

<p>Pro úplnost se ještě podívejme na to, jakým způsobem se přeloží všechny
čtyři základní aritmetické operace, tj.&nbsp;nikoli pouze operace součtu, ale i
rozdílu, součinu a podílu (modulo není pro typy s&nbsp;plovoucí řádovou čárkou
definována):</p>

<pre>
_Float16 <strong>fp16_add</strong>(_Float16 x, _Float16 y) {
    return x+y;
}

_Float16 <strong>fp16_sub</strong>(_Float16 x, _Float16 y) {
    return x-y;
}

_Float16 <strong>fp16_mul</strong>(_Float16 x, _Float16 y) {
    return x*y;
}

_Float16 <strong>fp16_div</strong>(_Float16 x, _Float16 y) {
    return x/y;
}
</pre>

<p>Překlad v&nbsp;případě, že nebudeme přímo a explicitně vyžadovat použití
instrukcí <i>half float</i>, bude opět používat převody mezi typy <i>half
float</i> a <i>single</i>:</p>

<pre>
<strong>fp16_add</strong>:
        fcvt    s1, h1
        fcvt    s0, h0
        fadd    s0, s0, s1
        fcvt    h0, s0
        ret
&nbsp;
<strong>fp16_sub</strong>:
        fcvt    s1, h1
        fcvt    s0, h0
        fsub    s0, s0, s1
        fcvt    h0, s0
        ret
&nbsp;
<strong>fp16_mul</strong>:
        fcvt    s1, h1
        fcvt    s0, h0
        fmul    s0, s0, s1
        fcvt    h0, s0
        ret
&nbsp;
<strong>fp16_div</strong>:
        fcvt    s1, h1
        fcvt    s0, h0
        fdiv    s0, s0, s1
        fcvt    h0, s0
        ret
</pre>

<p>Pokud naopak použijeme přepínač <strong>-march=armv8.2-a+fp16</strong> (nebo
i vyšší verzi architektury), bude výsledkem překladu skutečně optimalizovaný
strojový kód:</p>

<pre>
<strong>fp16_add</strong>(_Float16, _Float16):
        fadd    h0, h0, h1
        ret
&nbsp;
<strong>fp16_sub</strong>(_Float16, _Float16):
        fsub    h0, h0, h1
        ret
&nbsp;
<strong>fp16_mul</strong>(_Float16, _Float16):
        fmul    h0, h0, h1
        ret
&nbsp;
<strong>fp16_div</strong>(_Float16, _Float16):
        fdiv    h0, h0, h1
        ret
</pre>



<p><a name="k09"></a></p>
<h2 id="k09">9. Překlad operací pro porovnání dvou hodnot typu <i>half float</i></h2>

<p>Kromě provádění základních aritmetických operací se v&nbsp;praxi velmi často
porovnávají dvě hodnoty na relaci &bdquo;je rovno&ldquo;,
&bdquo;nerovno&ldquo;, &bdquo;větší než&ldquo;, &bdquo;větší nebo rovno&ldquo;,
&bdquo;menší než&ldquo; a &bdquo;menší nebo rovno&ldquo;. Programovací jazyk C
má pro tyto operace vyhrazenu šestici operátorů a v&nbsp;případě GCC je možné
tyto operace provádět i s&nbsp;hodnotami typu <i>half float</i> (v&nbsp;GCC
<strong>_Float16</strong>).</p>

<p>Ostatně si můžeme tyto operace jednoduše otestovat:</p>

<pre>
bool <strong>fp16_eq</strong>(_Float16 x, _Float16 y) {
    return x == y;
}
&nbsp;
bool <strong>fp16_ne</strong>(_Float16 x, _Float16 y) {
    return x != y;
}
&nbsp;
bool <strong>fp16_gt</strong>(_Float16 x, _Float16 y) {
    return x &gt; y;
}
&nbsp;
bool <strong>fp16_ge</strong>(_Float16 x, _Float16 y) {
    return x &gt;= y;
}
&nbsp;
bool <strong>fp16_lt</strong>(_Float16 x, _Float16 y) {
    return x &lt; y;
}
&nbsp;
bool <strong>fp16_le</strong>(_Float16 x, _Float16 y) {
    return x &lt;= y;
}
</pre>

<p>Překlad bez povolení přímých manipulací s&nbsp;hodnotami typu <i>half
float</i> bude opět založen na konverzi těchto hodnot na typy <i>single</i>.
Následně je provedena instrukce <strong>FCMP</strong> nebo
<strong>FCMPE</strong> a do registru <strong>W0</strong> je uložen výsledek
porovnání (získaný z&nbsp;příznakových bitů):</p>

<pre>
<strong>fp16_eq</strong>(_Float16, _Float16):
        fcvt    s0, h0
        fcvt    s1, h1
        fcmp    s0, s1
        cset    w0, eq
        ret
&nbsp;
<strong>fp16_ne</strong>(_Float16, _Float16):
        fcvt    s0, h0
        fcvt    s1, h1
        fcmp    s0, s1
        cset    w0, ne
        ret
&nbsp;
<strong>fp16_gt</strong>(_Float16, _Float16):
        fcvt    s0, h0
        fcvt    s1, h1
        fcmpe   s0, s1
        cset    w0, gt
        ret
&nbsp;
<strong>fp16_ge</strong>(_Float16, _Float16):
        fcvt    s0, h0
        fcvt    s1, h1
        fcmpe   s0, s1
        cset    w0, ge
        ret
&nbsp;
<strong>fp16_lt</strong>(_Float16, _Float16):
        fcvt    s0, h0
        fcvt    s1, h1
        fcmpe   s0, s1
        cset    w0, mi
        ret
&nbsp;
<strong>fp16_le</strong>(_Float16, _Float16):
        fcvt    s0, h0
        fcvt    s1, h1
        fcmpe   s0, s1
        cset    w0, ls
        ret
</pre>

<p>Mohlo by se zdát, že pokud povolíme přímé manipulace s&nbsp;typem <i>half
float</i>, bude výsledný strojový kód kratší (a tím pádem i rychlejší),
tj.&nbsp;vynechají se konverzní instrukce <strong>FCVT</strong> atd. Ovšem není
tomu tak, o čemž se můžeme snadno přesvědčit:</p>

<pre>
<strong>fp16_eq</strong>(_Float16, _Float16):
        fcvt    s0, h0
        fcvt    s1, h1
        fcmp    s0, s1
        cset    w0, eq
        ret
&nbsp;
<strong>fp16_ne</strong>(_Float16, _Float16):
        fcvt    s0, h0
        fcvt    s1, h1
        fcmp    s0, s1
        cset    w0, ne
        ret
&nbsp;
<strong>fp16_gt</strong>(_Float16, _Float16):
        fcvt    s0, h0
        fcvt    s1, h1
        fcmpe   s0, s1
        cset    w0, gt
        ret
&nbsp;
<strong>fp16_ge</strong>(_Float16, _Float16):
        fcvt    s0, h0
        fcvt    s1, h1
        fcmpe   s0, s1
        cset    w0, ge
        ret
&nbsp;
<strong>fp16_lt</strong>(_Float16, _Float16):
        fcvt    s0, h0
        fcvt    s1, h1
        fcmpe   s0, s1
        cset    w0, mi
        ret
&nbsp;
<strong>fp16_le</strong>(_Float16, _Float16):
        fcvt    s0, h0
        fcvt    s1, h1
        fcmpe   s0, s1
        cset    w0, ls
        ret
</pre>



<p><a name="k10"></a></p>
<h2 id="k10">10. NEON a operace nad celými vektory</h2>

<p>Instrukce NEON na 64bitových mikroprocesorech AArch64 podporují vektory
s&nbsp;elementy (prvky) těchto typů:</p>

<table>
<tr><th>Typ</th><th>Šířka</th><th>Poznámka</th></tr>
<tr><td>float</td><td>32 bitů</td><td>hodnota s&nbsp;plovoucí řádovou čárkou, jednoduchá přesnost</td></tr>
<tr><td>double</td><td>64 bitů</td><td>hodnota s&nbsp;plovoucí řádovou čárkou, dvojitá přesnost</td></tr>
<tr><td>half</td><td>32 bitů</td><td>hodnota s&nbsp;plovoucí řádovou čárkou, poloviční přesnost (jen převody)</td></tr>
<tr><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td></tr>
<tr><td>int8</td><td>8 bitů</td><td>osmibitové celé číslo se znaménkem, obecné použití</td></tr>
<tr><td>int16</td><td>16 bitů</td><td>16bitové celé číslo se znaménkem, obecné použití</td></tr>
<tr><td>int32</td><td>32 bitů</td><td>32bitové celé číslo se znaménkem, obecné použití</td></tr>
<tr><td>int64</td><td>64 bitů</td><td>64bitové celé číslo se znaménkem, obecné použití</td></tr>
<tr><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td></tr>
<tr><td>uint8</td><td>8 bitů</td><td>osmibitové celé číslo bez znaménka, typicky barvová složka pixelu</td></tr>
<tr><td>uint16</td><td>16 bitů</td><td>16bitové celé číslo bez znaménka, typicky zvukový vzorek</td></tr>
<tr><td>uint32</td><td>32 bitů</td><td>32bitové celé číslo bez znaménka, obecné použití</td></tr>
<tr><td>uint64</td><td>64 bitů</td><td>64bitové celé číslo bez znaménka, obecné použití</td></tr>
<tr><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td></tr>
<tr><td>polynomial</td><td>8 bitů</td><td>používán pro výpočty korekcí chyb atd.</td></tr>
<tr><td>polynomial</td><td>16 bitů</td><td>používán pro výpočty korekcí chyb atd.</td></tr>
</table>

<p><div class="rs-tip-major">Poznámka: některé typy (formáty) jsou dostupné jen
pro NEON implementovaný na mikroprocesorech s&nbsp;architekturou AArch64. Týká
se to zejména použití vektorů s&nbsp;elementy typu <i>double</i>.</div></p>

<p>Nás nyní budou zajímat především &bdquo;vektorizace&ldquo; operací
prováděných na poli obsahujícími prvky typu <i>half float</i>.</p>



<p><a name="k11"></a></p>
<h2 id="k11">11. Přičtení konstanty ke všem prvkům pole</h2>

<p>V&nbsp;dalším ukázkovém příkladu je realizována funkce, která ke všem prvkům
pole s&nbsp;prvky typu <i>half float</i> o známé délce přičítá konstantu
předanou formou argumentu. Celý příklad je naprogramován naivním způsobem, bez
jakékoli snahy o optimalizace na úrovni céčkovského zdrojového kódu:</p>

<pre>
#define LENGTH 32
&nbsp;
void <strong>fp16_delta</strong>(_Float16 values[LENGTH], _Float16 delta) {
    int i;
    for (i=0; i&lt;LENGTH; i++) {
        values[i] += delta;
    }
}
</pre>

<p>V&nbsp;případě, že není povoleno rozšíření instrukční sady o <i>fp16</i>,
bude výsledkem překladu explicitně vygenerovaná programová smyčka, ve které se
(v&nbsp;každé iteraci) provádí dvojice konverzí instrukcí
<strong>FCVT</strong>: z&nbsp;<i>half float</i> na <i>single</i> a naopak ze
<i>single</i> na <i>half float</i>. Výsledek tedy nebude příliš rychlý:</p>

<pre>
<strong>fp16_delta</strong>:
        fcvt    s0, h0
        add     x1, x0, 64
.L2:
        ldr     h31, [x0]
        fcvt    s31, h31
        fadd    s31, s31, s0
        fcvt    h31, s31
        str     h31, [x0], 2
        cmp     x0, x1
        bne     .L2
        ret
</pre>

<p>Pokud jsou operace <i>fp16</i> povoleny, bude překlad proveden odlišným
způsobem. Součet 32 prvků pole je rozdělen do čtyř vektorových instrukcí
<strong>FADD</strong>. Povšimněte si, jak se &bdquo;role&ldquo; registrů mění
pro různé operace &ndash; někdy se pracuje s&nbsp;celými 128bitovými registry
<strong>Qx</strong>, jindy se stejným registrem, ovšem tak, že jeho obsah bude
považován za vektor osmi 16bitových hodnot typu <i>half float</i>
(<strong>Vx.8h</strong>):</p>

<pre>
<strong>fp16_delta</strong>(_Float16*, _Float16):
        dup     v0.8h, v0.h[0]
        ldp     q3, q2, [x0]
        ldp     q1, q31, [x0, 32]
        fadd    v3.8h, v3.8h, v0.8h
        fadd    v2.8h, v2.8h, v0.8h
        fadd    v1.8h, v1.8h, v0.8h
        fadd    v31.8h, v31.8h, v0.8h
        stp     q3, q2, [x0]
        stp     q1, q31, [x0, 32]
        ret
</pre>

<p><div class="rs-tip-major">Poznámka: instrukce <strong>LDP</strong> a
<strong>STP</strong> dokážou pracovat s&nbsp;párem registrů &ndash; je to
částečná náhrada za instrukce <strong>LDM</strong> a <strong>STM</strong>,
které v&nbsp;instrukční sadě A64 neexistují.</div></p>



<p><a name="k12"></a></p>
<h2 id="k12">12. Součet odpovídajících si prvků polí typu <i>half float</i></h2>

<p>Zajímavé bude taktéž zjistit, jakým způsobem bude přeložena funkce, která
provede součet odpovídajících si prvků polí, tedy vlastně klasický vektorový
součet. Pokud si tento problém značně zjednodušíme tím, že nebudeme předávat
délku polí (a kontrolovat, zda mají obě pole stejnou délku atd.) ani používat
přístup k&nbsp;prvkům přes ukazatele, je možné součet napsat následovně:</p>

<pre>
#define SIZE 32
&nbsp;
void <strong>add_arrays</strong>(_Float16 *a, _Float16 *b) {
    int i;
    for (i=0; i&lt;SIZE; i++) {
        a[i] += b[i];
    }
}
</pre>

<p>Pokud nebude povolena přímá manipulace s&nbsp;hodnotami typu <i>half
float</i>, bude překlad proveden do formy počítané programové smyčky, zde
konkrétně s&nbsp;počitadlem uloženým v&nbsp;registru <strong>X2</strong>, které
se zvyšuje o dvojku, protože je tento registr současně použitý pro výpočet
offsetu:</p>

<pre>
        mov     x2, 0
.L2:
        ...
        ...
        ...
        add     x2, x2, 2
        cmp     x2, 64
        bne     .L2
</pre>

<p>Uvnitř těla smyčky se oba prvky načtou z&nbsp;adres <strong>X0+X2</strong> a
<strong>X1+X2</strong>, převedou na hodnoty typu <i>single</i>, sečtou a uloží
na adresu <strong>X0+X2</strong>:</p>

<pre>
        ldr     h31, [x0, x2]
        ldr     h30, [x1, x2]
        fcvt    s31, h31
        fcvt    s30, h30
        fadd    s30, s31, s30
        fcvt    h30, s30
        str     h30, [x0, x2]
</pre>

<p>Výsledek vypadá následovně:</p>

<pre>
<strong>add_arrays</strong>(_Float16*, _Float16*):
        mov     x2, 0
.L2:
        ldr     h31, [x0, x2]
        ldr     h30, [x1, x2]
        fcvt    s31, h31
        fcvt    s30, h30
        fadd    s30, s31, s30
        fcvt    h30, s30
        str     h30, [x0, x2]
        add     x2, x2, 2
        cmp     x2, 64
        bne     .L2
        ret
</pre>

<p>Při povolení přímé manipulace s&nbsp;hodnotami typu <i>half float</i>
překladač zjistí, jestli se pole nepřekrývají. Pokud ano, skočí do běžné
smyčky, ve které se již neprovádí převody hodnot:</p>

<pre>
        mov     x2, 0
.L2:
        ldr     h23, [x0, x2]
        ldr     h22, [x1, x2]
        fadd    h22, h23, h22
        str     h22, [x0, x2]
        add     x2, x2, 2
        cmp     x2, 64
        bne     .L2
</pre>

<p>Pokud se smyčky nepřekrývají, je celý výpočet rozbalen a proveden po
vektorech se čtyřmi prvky:</p>

<pre>
        ldr     q24, [x1]
        ldp     q25, q27, [x0]
        ldp     q29, q31, [x0, 32]
        fadd    v24.8h, v25.8h, v24.8h
        str     q24, [x0]
        ldr     q26, [x1, 16]
        fadd    v26.8h, v27.8h, v26.8h
        str     q26, [x0, 16]
        ldr     q28, [x1, 32]
        fadd    v28.8h, v29.8h, v28.8h
        str     q28, [x0, 32]
        ldr     q30, [x1, 48]
        fadd    v30.8h, v31.8h, v30.8h
        str     q30, [x0, 48]
</pre>

<p>Celkový výsledek vypadá takto:</p>

<pre>
<strong>add_arrays</strong>(_Float16*, _Float16*):
        sub     x2, x0, x1
        sub     x2, x2, #2
        cmp     x2, 12
        bls     .L4
        ldr     q24, [x1]
        ldp     q25, q27, [x0]
        ldp     q29, q31, [x0, 32]
        fadd    v24.8h, v25.8h, v24.8h
        str     q24, [x0]
        ldr     q26, [x1, 16]
        fadd    v26.8h, v27.8h, v26.8h
        str     q26, [x0, 16]
        ldr     q28, [x1, 32]
        fadd    v28.8h, v29.8h, v28.8h
        str     q28, [x0, 32]
        ldr     q30, [x1, 48]
        fadd    v30.8h, v31.8h, v30.8h
        str     q30, [x0, 48]
        ret
.L4:
        mov     x2, 0
.L2:
        ldr     h23, [x0, x2]
        ldr     h22, [x1, x2]
        fadd    h22, h23, h22
        str     h22, [x0, x2]
        add     x2, x2, 2
        cmp     x2, 64
        bne     .L2
        ret
</pre>



<p><a name="k13"></a></p>
<h2 id="k13">13. Pomáháme překladači: klíčové slovo <strong>restrict</strong></h2>

<p>V&nbsp;případě, že sčítáme dvě rozdílná pole, by bylo vhodné překladači
nějakým způsobem napovědět, že nemusí do výsledného kódu vkládat i variantu
s&nbsp;překrývajícími se poli. Pokud by byla pole odlišného typu
(resp.&nbsp;pokud by ukazatele byly odlišného typu), je řešení snadné &ndash;
podle normy je chování překladače nedefinované :-). Ovšem naše pole mají shodný
typ (přesněji řečeno oba ukazatele mají totožný typ <strong>_Float16
*</strong>), takže překladač musí předpokládat, že se může jednat o stejné
ukazatele nebo že se budou oblasti překrývat. Jak překladači napovědět, že
k&nbsp;této situaci nedojde a nemusí se jí zabývat? V&nbsp;jazyku C, konkrétně
ve verzi C99 a vyšší, je pro tento účel rezervováno slovo
<strong>restrict</strong>, které se používá následujícím způsobem (pro ANSI C
lze v&nbsp;GCC použít i <strong>__restrict__</strong>):</p>

<pre>
#define SIZE 32
&nbsp;
void <strong>add_arrays</strong>(_Float16 * restrict a, _Float16 * restrict b) {
    int i;
    for (i=0; i&lt;SIZE; i++) {
        a[i] += b[i];
    }
}
</pre>

<p>Překladač v&nbsp;tomto případě může provést optimalizace předpokládající, že
se sčítají odlišná pole a výsledek bude mnohem kratší a pro nás i čitelnější
&ndash; jen čtyři &bdquo;vektorové&ldquo; součty:</p>

<pre>
<strong>add_arrays</strong>:
        ldp     q24, q26, [x1]
        ldp     q28, q30, [x1, 32]
        ldp     q25, q27, [x0]
        ldp     q29, q31, [x0, 32]
        fadd    v24.8h, v25.8h, v24.8h
        fadd    v26.8h, v27.8h, v26.8h
        fadd    v28.8h, v29.8h, v28.8h
        fadd    v30.8h, v31.8h, v30.8h
        stp     q24, q26, [x0]
        stp     q28, q30, [x0, 32]
        ret
</pre>



<p><a name="k14"></a></p>
<h2 id="k14">14. Překlad součtu polí s&nbsp;menším počtem prvků</h2>

<p>V&nbsp;případě, že je počet prvků sčítaných polí relativně malý a pokud jsou
povoleny maximální optimalizace, může se překladač rozhodnout, že celou smyčku
s&nbsp;výpočtem rozbalí. Opět si to pochopitelně otestujeme:</p>

<pre>
#define SIZE 16
&nbsp;
void <strong>add_arrays</strong>(_Float16 *a, _Float16 *b) {
    int i;
    for (i=0; i&lt;SIZE; i++) {
        a[i] += b[i];
    }
}
</pre>

<p>Překlad za předpokladu, že nejsou povoleny přímé manipulace s&nbsp;prvky
typu <i>half float</i>. Došlo k&nbsp;rozbalení smyčky, ovšem stále můžeme vidět
stejný vzor: <strong>FCVT+FCVF+FADD+FCVT</strong>:</p>

<pre>
<strong>add_arrays</strong>(_Float16*, _Float16*):
        ldr     h24, [x1]
        ldr     h25, [x0]
        ldr     h27, [x0, 2]
        fcvt    s24, h24
        ldr     h29, [x0, 4]
        fcvt    s25, h25
        ldr     h31, [x0, 6]
        fcvt    s27, h27
        ldr     h1, [x0, 8]
        fcvt    s29, h29
        ldr     h3, [x0, 10]
        fcvt    s31, h31
        ldr     h5, [x0, 12]
        fadd    s24, s25, s24
        fcvt    s1, h1
        fcvt    s3, h3
        ldr     h7, [x0, 14]
        fcvt    s5, h5
        ldr     h17, [x0, 16]
        ldr     h19, [x0, 18]
        fcvt    h24, s24
        fcvt    s7, h7
        fcvt    s17, h17
        ldr     h21, [x0, 20]
        fcvt    s19, h19
        str     h24, [x0]
        fcvt    s21, h21
        ldr     h26, [x1, 2]
        fcvt    s26, h26
        fadd    s26, s27, s26
        fcvt    h26, s26
        str     h26, [x0, 2]
        ldr     h28, [x1, 4]
        fcvt    s28, h28
        fadd    s28, s29, s28
        fcvt    h28, s28
        str     h28, [x0, 4]
        ldr     h30, [x1, 6]
        fcvt    s30, h30
        fadd    s30, s31, s30
        fcvt    h30, s30
        str     h30, [x0, 6]
        ldr     h0, [x1, 8]
        fcvt    s0, h0
        fadd    s0, s1, s0
        fcvt    h0, s0
        str     h0, [x0, 8]
        ldr     h2, [x1, 10]
        fcvt    s2, h2
        fadd    s2, s3, s2
        fcvt    h2, s2
        str     h2, [x0, 10]
        ldr     h4, [x1, 12]
        fcvt    s4, h4
        fadd    s4, s5, s4
        fcvt    h4, s4
        str     h4, [x0, 12]
        ldr     h6, [x1, 14]
        fcvt    s6, h6
        fadd    s6, s7, s6
        fcvt    h6, s6
        str     h6, [x0, 14]
        ldr     h16, [x1, 16]
        fcvt    s16, h16
        fadd    s16, s17, s16
        fcvt    h16, s16
        str     h16, [x0, 16]
        ldr     h18, [x1, 18]
        fcvt    s18, h18
        fadd    s18, s19, s18
        fcvt    h18, s18
        str     h18, [x0, 18]
        ldr     h20, [x1, 20]
        fcvt    s20, h20
        fadd    s20, s21, s20
        fcvt    h20, s20
        str     h20, [x0, 20]
        ldr     h22, [x1, 22]
        ldr     h23, [x0, 22]
        ldr     h25, [x0, 24]
        fcvt    s22, h22
        ldr     h27, [x0, 26]
        fcvt    s23, h23
        ldr     h29, [x0, 28]
        fcvt    s25, h25
        ldr     h31, [x0, 30]
        fcvt    s27, h27
        fcvt    s29, h29
        fadd    s22, s23, s22
        fcvt    s31, h31
        fcvt    h22, s22
        str     h22, [x0, 22]
        ldr     h24, [x1, 24]
        fcvt    s24, h24
        fadd    s24, s25, s24
        fcvt    h24, s24
        str     h24, [x0, 24]
        ldr     h26, [x1, 26]
        fcvt    s26, h26
        fadd    s26, s27, s26
        fcvt    h26, s26
        str     h26, [x0, 26]
        ldr     h28, [x1, 28]
        fcvt    s28, h28
        fadd    s28, s29, s28
        fcvt    h28, s28
        str     h28, [x0, 28]
        ldr     h30, [x1, 30]
        fcvt    s30, h30
        fadd    s30, s31, s30
        fcvt    h30, s30
        str     h30, [x0, 30]
        ret
</pre>

<p>Definice, že se pole nepřekrývají + povolení práce s&nbsp;hodnotami typu
<i>half float</i> vede k&nbsp;mnohem kratšímu a pochopitelně i rychlejšímu
kódu:</p>

<pre>
<strong>add_arrays</strong>:
        ldp     q29, q31, [x0]
        ldp     q28, q30, [x1]
        fadd    v28.8h, v29.8h, v28.8h
        fadd    v30.8h, v31.8h, v30.8h
        stp     q28, q30, [x0]
        ret
</pre>



<p><a name="k15"></a></p>
<h2 id="k15">15. Intrinsic pro provádění operací s&nbsp;hodnotami typu <i>half float</i></h2>

https://developer.arm.com/architectures/instruction-sets/intrinsics/



<p><a name="k16"></a></p>
<h2 id="k16">16. Realizace součtu dvou hodnot typu <i>half float</i> přes intrinsic funkci</h2>

<p></p>

<pre>
#include &lt;arm_fp16.h&gt;
&nbsp;
_Float16 <strong>fp16_add</strong>(_Float16 x, _Float16 y) {
    return vaddh_f16(x, y);
}
</pre>

<p></p>

<pre>
<strong>fp16_add</strong>(_Float16, _Float16):
        fadd    h0, h0, h1
        ret
</pre>



<p><a name="k17"></a></p>
<h2 id="k17">17. Základní aritmetické operace s&nbsp;hodnotami typu <i>half float</i> realizované přes intrinsic</h2>

<pre>
#include &lt;arm_fp16.h&gt;
&nbsp;
_Float16 <strong>fp16_add</strong>(_Float16 x, _Float16 y) {
    return vaddh_f16(x, y);
}
&nbsp;
_Float16 <strong>fp16_sub</strong>(_Float16 x, _Float16 y) {
    return vsubh_f16(x, y);
}
&nbsp;
_Float16 <strong>fp16_mul</strong>(_Float16 x, _Float16 y) {
    return vmulh_f16(x, y);
}
&nbsp;
_Float16 <strong>fp16_div</strong>(_Float16 x, _Float16 y) {
    return vdivh_f16(x, y);
}
</pre>

<p></p>

<pre>
<strong>fp16_add</strong>(_Float16, _Float16):
        fadd    h0, h0, h1
        ret

<strong>fp16_sub</strong>(_Float16, _Float16):
        fsub    h0, h0, h1
        ret

<strong>fp16_mul</strong>(_Float16, _Float16):
        fmul    h0, h0, h1
        ret

<strong>fp16_div</strong>(_Float16, _Float16):
        fdiv    h0, h0, h1
        ret
</pre>



<p><a name="k18"></a></p>
<h2 id="k18">18. </h2>

<pre>
#include <arm_fp16.h>

bool fp16_eq(_Float16 x, _Float16 y) {
    return vceqh_f16(x, y);
}

bool fp16_ne(_Float16 x, _Float16 y) {
    return !vceqh_f16(x, y);
}

bool fp16_gt(_Float16 x, _Float16 y) {
    return vcgth_f16(x, y);
}

bool fp16_ge(_Float16 x, _Float16 y) {
    return vcgeh_f16(x, y);
}

bool fp16_lt(_Float16 x, _Float16 y) {
    return vclth_f16(x, y);
}

bool fp16_le(_Float16 x, _Float16 y) {
    return vcleh_f16(x, y);
}
</pre>

<pre>
fp16_eq(_Float16, _Float16):
        fcmeq   h31, h0, h1
        umov    w0, v31.h[0]
        tst     w0, 65535
        cset    w0, ne
        ret

fp16_ne(_Float16, _Float16):
        fcmeq   h31, h0, h1
        umov    w0, v31.h[0]
        tst     w0, 65535
        cset    w0, eq
        ret

fp16_gt(_Float16, _Float16):
        fcmgt   h31, h0, h1
        umov    w0, v31.h[0]
        tst     w0, 65535
        cset    w0, ne
        ret

fp16_ge(_Float16, _Float16):
        fcmge   h31, h0, h1
        umov    w0, v31.h[0]
        tst     w0, 65535
        cset    w0, ne
        ret

fp16_lt(_Float16, _Float16):
        fcmgt   h31, h1, h0
        umov    w0, v31.h[0]
        tst     w0, 65535
        cset    w0, ne
        ret

fp16_le(_Float16, _Float16):
        fcmge   h31, h1, h0
        umov    w0, v31.h[0]
        tst     w0, 65535
        cset    w0, ne
        ret
</pre>



<p><a name="k19"></a></p>
<h2 id="k19">19. Repositář s&nbsp;demonstračními příklady</h2>

<p>Demonstrační příklady napsané v&nbsp;jazyku C, které jsou určené pro překlad
s&nbsp;využitím překladače <strong>gcc</strong> pro platformu AArch64, byly
uloženy do Git repositáře, který je dostupný na adrese <a
href="https://github.com/tisnik/8bit-fame">https://github.com/tisnik/8bit-fame</a>.
Jednotlivé demonstrační příklady si můžete v&nbsp;případě potřeby stáhnout i
jednotlivě bez nutnosti klonovat celý (dnes již poměrně rozsáhlý)
repositář:</p>

<table>
<tr><th> #</th><th>Příklad</th><th>Stručný popis</th><th>Adresa</th></tr>
<tr><td> 1</td><td>fp16_add.c</td><td>operace součtu dvou hodnot typu <i>half float</i></td><td><a href="https://github.com/tisnik/8bit-fame/blob/master/fp/fp16_add.c">https://github.com/tisnik/8bit-fame/blob/master/fp/fp16_add.c</a></td></tr>
<tr><td> 2</td><td>fp16_add.asm</td><td>překlad operace součtu dvou hodnot typu <i>half float</i></td><td><a href="https://github.com/tisnik/8bit-fame/blob/master/fp/fp16_add.asm">https://github.com/tisnik/8bit-fame/blob/master/fp/fp16_add.asm</a></td></tr>
<tr><td> 3</td><td>fp16_add_fp16.asm</td><td>překlad využívající instrukce pro přímé operace s&nbsp;hodnotami typu <i>half float</i></td><td><a href="https://github.com/tisnik/8bit-fame/blob/master/fp/fp16_add_fp16.asm">https://github.com/tisnik/8bit-fame/blob/master/fp/fp16_add_fp16.asm</a></td></tr>
<tr><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td></tr>
<tr><td> 4</td><td>fp16_arith.c</td><td>všechny čtyři základní aritmetické operace nad typy <i>half float</i></td><td><a href="https://github.com/tisnik/8bit-fame/blob/master/fp/fp16_arith.c">https://github.com/tisnik/8bit-fame/blob/master/fp/fp16_arith.c</a></td></tr>
<tr><td> 5</td><td>fp16_arith.asm</td><td>překlad všech čtyř základních aritmetických operací</td><td><a href="https://github.com/tisnik/8bit-fame/blob/master/fp/fp16_arith.asm">https://github.com/tisnik/8bit-fame/blob/master/fp/fp16_arith.asm</a></td></tr>
<tr><td> 6</td><td>fp16_arith_fp16.asm</td><td>překlad všech čtyř základních aritmetických operací s&nbsp;přímými instrukcemi pro <i>half float</i></td><td><a href="https://github.com/tisnik/8bit-fame/blob/master/fp/fp16_arith_fp16.asm">https://github.com/tisnik/8bit-fame/blob/master/fp/fp16_arith_fp16.asm</a></td></tr>
<tr><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td></tr>
<tr><td> 7</td><td>fp16_comparison.c</td><td>realizace všech šesti operací pro porovnání dvou hodnot typu <i>half float</i></td><td><a href="https://github.com/tisnik/8bit-fame/blob/master/fp/fp16_comparison.c">https://github.com/tisnik/8bit-fame/blob/master/fp/fp16_comparison.c</a></td></tr>
<tr><td> 8</td><td>fp16_comparison.asm</td><td>překlad operací pro porovnání dvou hodnot typu <i>half float</i></td><td><a href="https://github.com/tisnik/8bit-fame/blob/master/fp/fp16_comparison.asm">https://github.com/tisnik/8bit-fame/blob/master/fp/fp16_comparison.asm</a></td></tr>
<tr><td> 9</td><td>fp16_comparison_fp16.asm</td><td>překlad operací pro porovnání dvou hodnot typu <i>half float</i> s&nbsp;přímými instrukcemi</td><td><a href="https://github.com/tisnik/8bit-fame/blob/master/fp/fp16_comparison_fp16.asm">https://github.com/tisnik/8bit-fame/blob/master/fp/fp16_comparison_fp16.asm</a></td></tr>
<tr><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td></tr>
<tr><td>10</td><td>fp16_add_delta.c               </td><td></td><td><a href="https://github.com/tisnik/8bit-fame/blob/master/fp/fp16_add_delta.c">https://github.com/tisnik/8bit-fame/blob/master/fp/fp16_add_delta.c</a></td></tr>
<tr><td>11</td><td>fp16_add_delta.asm             </td><td></td><td><a href="https://github.com/tisnik/8bit-fame/blob/master/fp/fp16_add_delta.asm">https://github.com/tisnik/8bit-fame/blob/master/fp/fp16_add_delta.asm</a></td></tr>
<tr><td>12</td><td>fp16_add_delta_fp16.asm        </td><td></td><td><a href="https://github.com/tisnik/8bit-fame/blob/master/fp/fp16_add_delta_fp16.asm">https://github.com/tisnik/8bit-fame/blob/master/fp/fp16_add_delta_fp16.asm</a></td></tr>
<tr><td>13</td><td>fp16_add_arrays_32.c           </td><td></td><td><a href="https://github.com/tisnik/8bit-fame/blob/master/fp/fp16_add_arrays_32.c">https://github.com/tisnik/8bit-fame/blob/master/fp/fp16_add_arrays_32.c</a></td></tr>
<tr><td>14</td><td>fp16_add_arrays_32.asm         </td><td></td><td><a href="https://github.com/tisnik/8bit-fame/blob/master/fp/fp16_add_arrays_32.asm">https://github.com/tisnik/8bit-fame/blob/master/fp/fp16_add_arrays_32.asm</a></td></tr>
<tr><td>15</td><td>fp16_add_arrays_32_fp16.asm    </td><td></td><td><a href="https://github.com/tisnik/8bit-fame/blob/master/fp/fp16_add_arrays_32_fp16.asm">https://github.com/tisnik/8bit-fame/blob/master/fp/fp16_add_arrays_32_fp16.asm</a></td></tr>
<tr><td>16</td><td>fp16_add_arrays_32_restrict.c  </td><td></td><td><a href="https://github.com/tisnik/8bit-fame/blob/master/fp/fp16_add_arrays_32_restrict.c">https://github.com/tisnik/8bit-fame/blob/master/fp/fp16_add_arrays_32_restrict.c</a></td></tr>
<tr><td>17</td><td>fp16_add_arrays_32_restrict.asm</td><td></td><td><a href="https://github.com/tisnik/8bit-fame/blob/master/fp/fp16_add_arrays_32_restrict.asm">https://github.com/tisnik/8bit-fame/blob/master/fp/fp16_add_arrays_32_restrict.asm</a></td></tr>
<tr><td>18</td><td>fp16_add_arrays_16.c           </td><td></td><td><a href="https://github.com/tisnik/8bit-fame/blob/master/fp/fp16_add_arrays_16.c">https://github.com/tisnik/8bit-fame/blob/master/fp/fp16_add_arrays_16.c</a></td></tr>
<tr><td>19</td><td>fp16_add_arrays_16.asm         </td><td></td><td><a href="https://github.com/tisnik/8bit-fame/blob/master/fp/fp16_add_arrays_16.asm">https://github.com/tisnik/8bit-fame/blob/master/fp/fp16_add_arrays_16.asm</a></td></tr>
<tr><td>20</td><td>fp16_add_arrays_16_fp16.asm    </td><td></td><td><a href="https://github.com/tisnik/8bit-fame/blob/master/fp/fp16_add_arrays_16_fp16.asm">https://github.com/tisnik/8bit-fame/blob/master/fp/fp16_add_arrays_16_fp16.asm</a></td></tr>
<tr><td>21</td><td>fp16_add_arrays_16_restrict.c  </td><td></td><td><a href="https://github.com/tisnik/8bit-fame/blob/master/fp/fp16_add_arrays_16_restrict.c">https://github.com/tisnik/8bit-fame/blob/master/fp/fp16_add_arrays_16_restrict.c</a></td></tr>
<tr><td>22</td><td>fp16_add_arrays_16_restrict.asm</td><td></td><td><a href="https://github.com/tisnik/8bit-fame/blob/master/fp/fp16_add_arrays_16_restrict.asm">https://github.com/tisnik/8bit-fame/blob/master/fp/fp16_add_arrays_16_restrict.asm</a></td></tr>
<tr><td>23</td><td>fp16_first_second.c            </td><td></td><td><a href="https://github.com/tisnik/8bit-fame/blob/master/fp/fp16_first_second.c">https://github.com/tisnik/8bit-fame/blob/master/fp/fp16_first_second.c</a></td></tr>
<tr><td>24</td><td>fp16_first_second.asm          </td><td></td><td><a href="https://github.com/tisnik/8bit-fame/blob/master/fp/fp16_first_second.asm">https://github.com/tisnik/8bit-fame/blob/master/fp/fp16_first_second.asm</a></td></tr>
<tr><td>25</td><td>fp16_add_intrinsic.c           </td><td></td><td><a href="https://github.com/tisnik/8bit-fame/blob/master/fp/fp16_add_intrinsic.c">https://github.com/tisnik/8bit-fame/blob/master/fp/fp16_add_intrinsic.c</a></td></tr>
<tr><td>26</td><td>fp16_add_intrinsic.asm         </td><td></td><td><a href="https://github.com/tisnik/8bit-fame/blob/master/fp/fp16_add_intrinsic.asm">https://github.com/tisnik/8bit-fame/blob/master/fp/fp16_add_intrinsic.asm</a></td></tr>
<tr><td>27</td><td>fp16_arith_intrinsic.c         </td><td></td><td><a href="https://github.com/tisnik/8bit-fame/blob/master/fp/fp16_arith_intrinsic.c">https://github.com/tisnik/8bit-fame/blob/master/fp/fp16_arith_intrinsic.c</a></td></tr>
<tr><td>28</td><td>fp16_arith_intrinsic.asm       </td><td></td><td><a href="https://github.com/tisnik/8bit-fame/blob/master/fp/fp16_arith_intrinsic.asm">https://github.com/tisnik/8bit-fame/blob/master/fp/fp16_arith_intrinsic.asm</a></td></tr>
<tr><td>29</td><td>fp16_comparison_intrinsic.c    </td><td></td><td><a href="https://github.com/tisnik/8bit-fame/blob/master/fp/fp16_comparison_intrinsic.c">https://github.com/tisnik/8bit-fame/blob/master/fp/fp16_comparison_intrinsic.c</a></td></tr>
<tr><td>30</td><td>fp16_comparison_intrinsic.asm  </td><td></td><td><a href="https://github.com/tisnik/8bit-fame/blob/master/fp/fp16_comparison_intrinsic.asm">https://github.com/tisnik/8bit-fame/blob/master/fp/fp16_comparison_intrinsic.asm</a></td></tr>
</table>



<p><a name="k20"></a></p>
<h2 id="k20">20. Odkazy na Internetu</h2>

<ol>

<li>NEON Technology (stránky ARM)<br />
<a href="https://developer.arm.com/technologies/neon">https://developer.arm.com/technologies/neon</a>
</li>

<li>SIMD Assembly Tutorial: ARM NEON - Xiph.org<br />
<a href="https://people.xiph.org/~tterribe/daala/neon_tutorial.pdf">https://people.xiph.org/~tterribe/daala/neon_tutorial.pdf</a>
</li>

<li>Ne10<br />
<a href="http://projectne10.github.io/Ne10/">http://projectne10.github.io/Ne10/</a>
</li>

<li>NEON and Floating-Point architecture<br />
<a href="http://infocenter.arm.com/help/index.jsp?topic=/com.arm.doc.den0024a/BABIGHEB.html">http://infocenter.arm.com/help/index.jsp?topic=/com.arm.doc.den0024a/BABIGHEB.html</a>
</li>

<li>An Introduction to ARM NEON<br />
<a href="http://peterdn.com/post/an-introduction-to-ARM-NEON.aspx">http://peterdn.com/post/an-introduction-to-ARM-NEON.aspx</a>
</li>

<li>ARM NEON Intrinsics Reference<br />
<a href="http://infocenter.arm.com/help/topic/com.arm.doc.ihi0073a/IHI0073A_arm_neon_intrinsics_ref.pdf">http://infocenter.arm.com/help/topic/com.arm.doc.ihi0073a/IHI0073A_arm_neon_intrinsics_ref.pdf</a>
</li>

<li>Arm Neon Intrinsics vs hand assembly<br />
<a href="https://stackoverflow.com/questions/9828567/arm-neon-intrinsics-vs-hand-assembly">https://stackoverflow.com/questions/9828567/arm-neon-intrinsics-vs-hand-assembly</a>
</li>

<li>ARM NEON Optimization. An Example<br />
<a href="http://hilbert-space.de/?p=22">http://hilbert-space.de/?p=22</a>
</li>

<li>AArch64 NEON instruction format<br />
<a href="https://developer.arm.com/docs/den0024/latest/7-aarch64-floating-point-and-neon/73-aarch64-neon-instruction-format">https://developer.arm.com/docs/den0024/latest/7-aarch64-floating-point-and-neon/73-aarch64-neon-instruction-format</a>
</li>

<li>Vektorové procesory aneb další pokus o zvýšení výpočetního výkonu počítačů<br />
<a href="http://www.root.cz/clanky/vektorove-procesory-aneb-dalsi-pokus-o-zvyseni-vypocetniho-vykonu-pocitacu/">http://www.root.cz/clanky/vektorove-procesory-aneb-dalsi-pokus-o-zvyseni-vypocetniho-vykonu-pocitacu/</a>
</li>

<li>SIMD instrukce využívané v moderních mikroprocesorech řady x86<br />
<a href="http://www.root.cz/clanky/simd-instrukce-vyuzivane-v-modernich-mikroprocesorech-rady-x86/">http://www.root.cz/clanky/simd-instrukce-vyuzivane-v-modernich-mikroprocesorech-rady-x86/</a>
</li>

<li>SIMD instrukce v moderních mikroprocesorech řady x86 (2.část: SSE)<br />
<a href="http://www.root.cz/clanky/simd-instrukce-v-modernich-mikroprocesorech-rady-x86-2-cast-sse/">http://www.root.cz/clanky/simd-instrukce-v-modernich-mikroprocesorech-rady-x86-2-cast-sse/</a>
</li>

<li>SIMD instrukce v moderních mikroprocesorech řady x86 (3.část: SSE2)<br />
<a href="http://www.root.cz/clanky/simd-instrukce-v-modernich-mikroprocesorech-rady-x86-3-cast-sse2/">http://www.root.cz/clanky/simd-instrukce-v-modernich-mikroprocesorech-rady-x86-3-cast-sse2/</a>
</li>

<li>Instrukce typu SIMD na mikroprocesorech RISC<br />
<a href="http://www.root.cz/clanky/instrukce-typu-simd-na-mikroprocesorech-risc/">http://www.root.cz/clanky/instrukce-typu-simd-na-mikroprocesorech-risc/</a>
</li>

<li>Instrukce typu SIMD na mikroprocesorech RISC (2. část)<br />
<a href="http://www.root.cz/clanky/instrukce-typu-simd-na-mikroprocesorech-risc-2-cast/">http://www.root.cz/clanky/instrukce-typu-simd-na-mikroprocesorech-risc-2-cast/</a>
</li>

<li>Instrukce typu SIMD na mikroprocesorech RISC (3.část - MIPS-3D a VIS)<br />
<a href="http://www.root.cz/clanky/instrukce-typu-simd-na-mikroprocesorech-risc-3-cast-mips-3d-a-vis/">http://www.root.cz/clanky/instrukce-typu-simd-na-mikroprocesorech-risc-3-cast-mips-3d-a-vis/</a>
</li>

<li>Trasování a ladění nativních aplikací v&nbsp;Linuxu<br />
<a href="https://www.root.cz/clanky/trasovani-a-ladeni-nativnich-aplikaci-v-linuxu/">https://www.root.cz/clanky/trasovani-a-ladeni-nativnich-aplikaci-v-linuxu/</a>
</li>

<li>Trasování a ladění nativních aplikací v&nbsp;Linuxu: použití GDB a jeho nadstaveb<br />
<a href="https://www.root.cz/clanky/trasovani-a-ladeni-nativnich-aplikaci-v-linuxu-pouziti-gdb-a-jeho-nadstaveb/">https://www.root.cz/clanky/trasovani-a-ladeni-nativnich-aplikaci-v-linuxu-pouziti-gdb-a-jeho-nadstaveb/</a>
</li>

<li>Debuggery a jejich nadstavby v Linuxu (3): Nemiver<br />
<a href="http://mojefedora.cz/debuggery-a-jejich-nadstavby-v-linuxu-3-nemiver/">http://mojefedora.cz/debuggery-a-jejich-nadstavby-v-linuxu-3-nemiver/</a>
</li>

<li>Debuggery a jejich nadstavby v Linuxu (4): KDbg<br />
<a href="http://mojefedora.cz/debuggery-a-jejich-nadstavby-v-linuxu-4-kdbg/">http://mojefedora.cz/debuggery-a-jejich-nadstavby-v-linuxu-4-kdbg/</a>
</li>

<li>Debuggery a jejich nadstavby v Linuxu (5): ladění aplikací v&nbsp;editorech Emacs a Vim<br />
<a href="http://mojefedora.cz/debuggery-a-jejich-nadstavby-v-linuxu-5-ladeni-aplikaci-v-editorech-emacs-a-vim/">http://mojefedora.cz/debuggery-a-jejich-nadstavby-v-linuxu-5-ladeni-aplikaci-v-editorech-emacs-a-vim/</a>
</li>

<li>Tracing (software)<br />
<a href="https://en.wikipedia.org/wiki/Tracing_%28software%29">https://en.wikipedia.org/wiki/Tracing_%28software%29</a>
</li>

<li>cgdb: the curses debugger<br />
<a href="https://cgdb.github.io/">https://cgdb.github.io/</a>
</li>

<li>cgdb: dokumentace<br />
<a href="https://cgdb.github.io/docs/cgdb-split.html">https://cgdb.github.io/docs/cgdb-split.html</a>
</li>

<li>strace(1) - Linux man page<br />
<a href="http://linux.die.net/man/1/strace">http://linux.die.net/man/1/strace</a>
</li>

<li>strace (stránka projektu na SourceForge)<br />
<a href="https://sourceforge.net/projects/strace/">https://sourceforge.net/projects/strace/</a>
</li>

<li>strace (Wikipedia)<br />
<a href="https://en.wikipedia.org/wiki/Strace">https://en.wikipedia.org/wiki/Strace</a>
</li>

<li>GDB - Dokumentace<br />
<a href="http://sourceware.org/gdb/current/onlinedocs/gdb/">http://sourceware.org/gdb/current/onlinedocs/gdb/</a>
</li>

<li>GDB - Supported Languages<br />
<a href="http://sourceware.org/gdb/current/onlinedocs/gdb/Supported-Languages.html#Supported-Languages">http://sourceware.org/gdb/current/onlinedocs/gdb/Supported-Languages.html#Supported-Languages</a>
</li>

<li>GNU Debugger (Wikipedia)<br />
<a href="https://en.wikipedia.org/wiki/GNU_Debugger">https://en.wikipedia.org/wiki/GNU_Debugger</a>
</li>

<li>The LLDB Debugger<br />
<a href="http://lldb.llvm.org/">http://lldb.llvm.org/</a>
</li>

<li>Debugger (Wikipedia)<br />
<a href="https://en.wikipedia.org/wiki/Debugger">https://en.wikipedia.org/wiki/Debugger</a>
</li>

<li>Comparison of ARMv8-A cores<br />
<a href="https://en.wikipedia.org/wiki/Comparison_of_ARMv8-A_cores">https://en.wikipedia.org/wiki/Comparison_of_ARMv8-A_cores</a>
</li>

<li>A64 General Instructions<br />
<a href="http://www.keil.com/support/man/docs/armclang_asm/armclang_asm_pge1427898258836.htm">http://www.keil.com/support/man/docs/armclang_asm/armclang_asm_pge1427898258836.htm</a>
</li>

<li>ARMv8 (AArch64) Instruction Encoding<br />
<a href="http://kitoslab-eng.blogspot.cz/2012/10/armv8-aarch64-instruction-encoding.html">http://kitoslab-eng.blogspot.cz/2012/10/armv8-aarch64-instruction-encoding.html</a>
</li>

<li>Cortex-A32 Processor<br />
<a href="https://www.arm.com/products/processors/cortex-a/cortex-a32-processor.php">https://www.arm.com/products/processors/cortex-a/cortex-a32-processor.php</a>
</li>

<li>Cortex-A35 Processor<br />
<a href="https://www.arm.com/products/processors/cortex-a/cortex-a35-processor.php">https://www.arm.com/products/processors/cortex-a/cortex-a35-processor.php</a>
</li>

<li>Cortex-A53 Processor<br />
<a href="https://www.arm.com/products/processors/cortex-a/cortex-a53-processor.php">https://www.arm.com/products/processors/cortex-a/cortex-a53-processor.php</a>
</li>

<li>Cortex-A57 Processor<br />
<a href="https://www.arm.com/products/processors/cortex-a/cortex-a57-processor.php">https://www.arm.com/products/processors/cortex-a/cortex-a57-processor.php</a>
</li>

<li>Cortex-A72 Processor<br />
<a href="https://www.arm.com/products/processors/cortex-a/cortex-a72-processor.php">https://www.arm.com/products/processors/cortex-a/cortex-a72-processor.php</a>
</li>

<li>Cortex-A73 Processor<br />
<a href="https://www.arm.com/products/processors/cortex-a/cortex-a73-processor.php">https://www.arm.com/products/processors/cortex-a/cortex-a73-processor.php</a>
</li>

<li>Apple A7 (SoC založen na CPU Cyclone)<br />
<a href="https://en.wikipedia.org/wiki/Apple_A7">https://en.wikipedia.org/wiki/Apple_A7</a>
</li>

<li>System cally pro AArch64 na Linuxu<br />
<a href="https://github.com/torvalds/linux/blob/master/include/uapi/asm-generic/unistd.h">https://github.com/torvalds/linux/blob/master/include/uapi/asm-generic/unistd.h</a>
</li>

<li>Architectures/AArch64 (FedoraProject.org)<br />
<a href="https://fedoraproject.org/wiki/Architectures/AArch64">https://fedoraproject.org/wiki/Architectures/AArch64</a>
</li>

<li>SIG pro AArch64 (CentOS)<br />
<a href="https://wiki.centos.org/SpecialInterestGroup/AltArch/AArch64">https://wiki.centos.org/SpecialInterestGroup/AltArch/AArch64</a>
</li>

<li>The ARMv8 instruction sets<br />
<a href="http://infocenter.arm.com/help/index.jsp?topic=/com.arm.doc.den0024a/ch05s01.html">http://infocenter.arm.com/help/index.jsp?topic=/com.arm.doc.den0024a/ch05s01.html</a>
</li>

<li>A64 Instruction Set<br />
<a href="https://developer.arm.com/products/architecture/instruction-sets/a64-instruction-set">https://developer.arm.com/products/architecture/instruction-sets/a64-instruction-set</a>
</li>

<li>Switching between the instruction sets<br />
<a href="http://infocenter.arm.com/help/index.jsp?topic=/com.arm.doc.den0024a/ch05s01.html">http://infocenter.arm.com/help/index.jsp?topic=/com.arm.doc.den0024a/ch05s01.html</a>
</li>

<li>The A64 instruction set<br />
<a href="http://infocenter.arm.com/help/index.jsp?topic=/com.arm.doc.den0024a/ch05s01.html">http://infocenter.arm.com/help/index.jsp?topic=/com.arm.doc.den0024a/ch05s01.html</a>
</li>

<li>Introduction to ARMv8 64-bit Architecture<br />
<a href="https://quequero.org/2014/04/introduction-to-arm-architecture/">https://quequero.org/2014/04/introduction-to-arm-architecture/</a>
</li>

<li>MCU market turns to 32-bits and ARM<br />
<a href="http://www.eetimes.com/document.asp?doc_id=1280803">http://www.eetimes.com/document.asp?doc_id=1280803</a>
</li>

<li>Cortex-M0 Processor (ARM Holdings)<br />
<a href="http://www.arm.com/products/processors/cortex-m/cortex-m0.php">http://www.arm.com/products/processors/cortex-m/cortex-m0.php</a>
</li>

<li>Cortex-M0+ Processor (ARM Holdings)<br />
<a href="http://www.arm.com/products/processors/cortex-m/cortex-m0plus.php">http://www.arm.com/products/processors/cortex-m/cortex-m0plus.php</a>
</li>

<li>ARM Processors in a Mixed Signal World<br />
<a href="http://www.eeweb.com/blog/arm/arm-processors-in-a-mixed-signal-world">http://www.eeweb.com/blog/arm/arm-processors-in-a-mixed-signal-world</a>
</li>

<li>ARM Architecture (Wikipedia)<br />
<a href="https://en.wikipedia.org/wiki/ARM_architecture">https://en.wikipedia.org/wiki/ARM_architecture</a>
</li>

<li>DSP for Cortex-M<br />
<a href="https://developer.arm.com/technologies/dsp/dsp-for-cortex-m">https://developer.arm.com/technologies/dsp/dsp-for-cortex-m</a>
</li>

<li>Cortex-M processors in DSP applications? Why not?!<br />
<a href="https://community.arm.com/processors/b/blog/posts/cortex-m-processors-in-dsp-applications-why-not">https://community.arm.com/processors/b/blog/posts/cortex-m-processors-in-dsp-applications-why-not</a>
</li>

<li>White Paper - DSP capabilities of Cortex-M4 and Cortex-M7<br />
<a href="https://community.arm.com/processors/b/blog/posts/white-paper-dsp-capabilities-of-cortex-m4-and-cortex-m7">https://community.arm.com/processors/b/blog/posts/white-paper-dsp-capabilities-of-cortex-m4-and-cortex-m7</a>
</li>

<li>Q (number format)<br />
<a href="https://en.wikipedia.org/wiki/Q_%28number_format%29">https://en.wikipedia.org/wiki/Q_%28number_format%29</a>
</li>

<li>TriCore Architecture &amp; Core<br />
<a href="http://www.infineon.com/cms/en/product/microcontroller/32-bit-tricore-tm-microcontroller/tricore-tm-architecture-and-core/channel.html?channel=ff80808112ab681d0112ab6b73d40837">http://www.infineon.com/cms/en/product/microcontroller/32-bit-tricore-tm-microcontroller/tricore-tm-architecture-and-core/channel.html?channel=ff80808112ab681d0112ab6b73d40837</a>
</li>

<li>TriCoreTM V1.6 Instruction Set: 32-bit Unified Processor Core<br />
<a href="http://www.infineon.com/dgdl/tc_v131_instructionset_v138.pdf?fileId=db3a304412b407950112b409b6dd0352">http://www.infineon.com/dgdl/tc_v131_instructionset_v138.pdf?fileId=db3a304412b407950112b409b6dd0352</a>
</li>

<li>TriCore v2.2 C Compiler, Assembler, Linker Reference Manual<br />
<a href="http://tasking.com/support/tricore/tc_reference_guide_v2.2.pdf">http://tasking.com/support/tricore/tc_reference_guide_v2.2.pdf</a>
</li>

<li>Infineon TriCore (Wikipedia)<br />
<a href="https://en.wikipedia.org/wiki/Infineon_TriCore">https://en.wikipedia.org/wiki/Infineon_TriCore</a>
</li>

<li>C166®S V2 Architecture &amp; Core<br />
<a href="http://www.infineon.com/cms/en/product/microcontroller/16-bit-c166-microcontroller/c166-s-v2-architecture-and-core/channel.html?channel=db3a304312bef5660112c3011c7d01ae">http://www.infineon.com/cms/en/product/microcontroller/16-bit-c166-microcontroller/c166-s-v2-architecture-and-core/channel.html?channel=db3a304312bef5660112c3011c7d01ae</a>
</li>

<li>Comparing four 32-bit soft processor cores<br />
<a href="http://www.eetimes.com/author.asp?section_id=14&doc_id=1286116">http://www.eetimes.com/author.asp?section_id=14&doc_id=1286116</a>
</li>

<li>RISC-V Instruction Set<br />
<a href="http://riscv.org/download.html#spec_compressed_isa">http://riscv.org/download.html#spec_compressed_isa</a>
</li>

<li>RISC-V Spike (ISA Simulator)<br />
<a href="http://riscv.org/download.html#isa-sim">http://riscv.org/download.html#isa-sim</a>
</li>

<li>RISC-V (Wikipedia)<br />
<a href="https://en.wikipedia.org/wiki/RISC-V">https://en.wikipedia.org/wiki/RISC-V</a>
</li>

<li>David Patterson (Wikipedia)<br />
<a href="https://en.wikipedia.org/wiki/David_Patterson_(computer_scientist)">https://en.wikipedia.org/wiki/David_Patterson_(computer_scientist)</a>
</li>

<li>OpenRISC (oficiální stránky projektu)<br />
<a href="http://openrisc.io/">http://openrisc.io/</a>
</li>

<li>OpenRISC architecture<br />
<a href="http://openrisc.io/architecture.html">http://openrisc.io/architecture.html</a>
</li>

<li>Emulátor OpenRISC CPU v JavaScriptu<br />
<a href="http://s-macke.github.io/jor1k/demos/main.html">http://s-macke.github.io/jor1k/demos/main.html</a>
</li>

<li>OpenRISC (Wikipedia)<br />
<a href="https://en.wikipedia.org/wiki/OpenRISC">https://en.wikipedia.org/wiki/OpenRISC</a>
</li>

<li>OpenRISC - instrukce<br />
<a href="http://sourceware.org/cgen/gen-doc/openrisc-insn.html">http://sourceware.org/cgen/gen-doc/openrisc-insn.html</a>
</li>

<li>OpenRISC - slajdy z přednášky o projektu<br />
<a href="https://iis.ee.ethz.ch/~gmichi/asocd/lecturenotes/Lecture6.pdf">https://iis.ee.ethz.ch/~gmichi/asocd/lecturenotes/Lecture6.pdf</a>
</li>

<li>Berkeley RISC<br />
<a href="http://en.wikipedia.org/wiki/Berkeley_RISC">http://en.wikipedia.org/wiki/Berkeley_RISC</a>
</li>

<li>Great moments in microprocessor history<br />
<a href="http://www.ibm.com/developerworks/library/pa-microhist.html">http://www.ibm.com/developerworks/library/pa-microhist.html</a>
</li>

<li>Microprogram-Based Processors<br />
<a href="http://research.microsoft.com/en-us/um/people/gbell/Computer_Structures_Principles_and_Examples/csp0167.htm">http://research.microsoft.com/en-us/um/people/gbell/Computer_Structures_Principles_and_Examples/csp0167.htm</a>
</li>

<li>Great Microprocessors of the Past and Present<br />
<a href="http://www.cpushack.com/CPU/cpu1.html">http://www.cpushack.com/CPU/cpu1.html</a>
</li>

<li>A Brief History of Microprogramming<br />
<a href="http://www.cs.clemson.edu/~mark/uprog.html">http://www.cs.clemson.edu/~mark/uprog.html</a>
</li>

<li>What is RISC?<br />
<a href="http://www-cs-faculty.stanford.edu/~eroberts/courses/soco/projects/2000-01/risc/whatis/">http://www-cs-faculty.stanford.edu/~eroberts/courses/soco/projects/2000-01/risc/whatis/</a>
</li>

<li>RISC vs. CISC<br />
<a href="http://www-cs-faculty.stanford.edu/~eroberts/courses/soco/projects/2000-01/risc/risccisc/">http://www-cs-faculty.stanford.edu/~eroberts/courses/soco/projects/2000-01/risc/risccisc/</a>
</li>

<li>RISC and CISC definitions:<br />
<a href="http://www.cpushack.com/CPU/cpuAppendA.html">http://www.cpushack.com/CPU/cpuAppendA.html</a>
</li>

<li>FPGA<br />
<a href="https://cs.wikipedia.org/wiki/Programovateln%C3%A9_hradlov%C3%A9_pole">https://cs.wikipedia.org/wiki/Programovateln%C3%A9_hradlov%C3%A9_pole</a>
</li>

<li>The Evolution of RISC<br />
<a href="http://www.ibm.com/developerworks/library/pa-microhist.html#sidebar1">http://www.ibm.com/developerworks/library/pa-microhist.html#sidebar1</a>
</li>

<li>List of ARM instructions implementing half-precision floating-point arithmetic<br />
<a href="https://stackoverflow.com/questions/76255632/list-of-arm-instructions-implementing-half-precision-floating-point-arithmetic">https://stackoverflow.com/questions/76255632/list-of-arm-instructions-implementing-half-precision-floating-point-arithmetic</a>
</li>

<li>Half-Precision Floating Point (GCC)<br />
<a href="https://gcc.gnu.org/onlinedocs/gcc/Half-Precision.html">https://gcc.gnu.org/onlinedocs/gcc/Half-Precision.html</a>
</li>

<li>Additional Floating Types (GCC)<br />
<a href="https://gcc.gnu.org/onlinedocs/gcc/Floating-Types.html">https://gcc.gnu.org/onlinedocs/gcc/Floating-Types.html</a>
</li>

<li>Advanced SIMD (Neon)<br />
<a href="https://en.wikipedia.org/wiki/ARM_architecture_family#Advanced_SIMD_(NEON)">https://en.wikipedia.org/wiki/ARM_architecture_family#Advanced_SIMD_(NEON)</a>
</li>

<li>GCC: ARM options<br />
<a href="https://gcc.gnu.org/onlinedocs/gcc/ARM-Options.html">https://gcc.gnu.org/onlinedocs/gcc/ARM-Options.html</a>
</li>

<li>Compile ARM Neon intrinsics on macos (M3 chipsets) using clang<br />
<a href="https://stackoverflow.com/questions/79056335/compile-arm-neon-intrinsics-on-macos-m3-chipsets-using-clang">https://stackoverflow.com/questions/79056335/compile-arm-neon-intrinsics-on-macos-m3-chipsets-using-clang</a>
</li>

<li>Intrinsics - Arm Developer<br />
<a href="https://developer.arm.com/architectures/instruction-sets/intrinsics/">https://developer.arm.com/architectures/instruction-sets/intrinsics/</a>
</li>

</ol>



<p></p><p></p>
<p><small>Autor: <a href="https://github.com/tisnik/">Pavel Tišnovský</a> &nbsp; 2025</small></p>
</body>
</html>

