<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
        "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html>
<head>
<title>Specifické vlastnosti procesorů AArch64: úvod</title>
<meta name="Author" content="Pavel Tisnovsky" />
<meta name="Generator" content="vim" />
<meta http-equiv="content-type" content="text/html; charset=utf-8" />
<style type="text/css">
         body {color:#000000; background:#ffffff;}
         h1  {font-family: arial, helvetica, sans-serif; color:#ffffff; background-color:#c00000; text-align:center; padding-left:1em}
         h2  {font-family: arial, helvetica, sans-serif; color:#ffffff; background-color:#0000c0; padding-left:1em; text-align:left}
         h3  {font-family: arial, helvetica, sans-serif; color:#000000; background-color:#c0c0c0; padding-left:1em; text-align:left}
         h4  {font-family: arial, helvetica, sans-serif; color:#000000; background-color:#e0e0e0; padding-left:1em; text-align:left}
         a   {font-family: arial, helvetica, sans-serif;}
         li  {font-family: arial, helvetica, sans-serif; color:#000000; text-align:justify; width:450px;}
         ol  {font-family: arial, helvetica, sans-serif; color:#000000; text-align:justify; width:450px;}
         ul  {font-family: arial, helvetica, sans-serif; color:#000000; text-align:justify; width:450px;}
         p   {font-family: arial, helvetica, sans-serif; color:#000000; text-align:justify;}
         pre {background:#e0e0e0}
</style>
</head>

<body>

<h1>Specifické vlastnosti procesorů AArch64: úvod</h1>

<h3>Pavel Tišnovský</h3>

<p></p>

<h1>Úvodník</h1>

<p>Instrukční sada procesorů s architekturou AArch64 má některé zajímavé vlastnosti, s nimiž se můžeme postupně seznámit s využitím těch nejzákladnějších nástrojů - assembleru, linkeru a v pozdějších fázích i debuggeru. Dnes si ukážeme několik plně funkčních příkladů založených na několika základních instrukcích.</p>



<h2>Obsah</h2>

<p><a href="#k01">1. Specifické vlastnosti procesorů AArch64: úvod</a></p>
<p><a href="#k02">2. Použitý počítač</a></p>
<p><a href="#k03">3. Instalace základních vývojářských nástrojů</a></p>
<p><a href="#k04">4. Sada pracovních registrů mikroprocesorů s&nbsp;architekturou AArch64</a></p>
<p><a href="#k05">5. Instrukce <strong>MOV</strong> a <strong>SVC</strong></a></p>
<p><a href="#k06">6. Nejjednodušší korektní program zapsaný v&nbsp;assembleru</a></p>
<p><a href="#k07">7. Kódování instrukcí <strong>MOV</strong> a <strong>SVC</strong> u architektury AArch64</a></p>
<p><a href="#k08">8. Instrukce typu Load-Store</a></p>
<p><a href="#k09">9. Program typu &bdquo;Hello, world!&ldquo; v&nbsp;assembleru</a></p>
<p><a href="#k10">10. Uložení adresy načítané instrukcí <strong>LDR</strong></a></p>
<p><a href="#k11">11. Zápis do datového segmentu</a></p>
<p><a href="#k12">12. Základní aritmetické instrukce</a></p>
<p><a href="#k13">13. Použití aritmetických instrukcí</a></p>
<p><a href="#k14">14. Nepodmíněné skoky a skoky do subrutiny (<i>branch with link</i>)</a></p>
<p><a href="#k15">15. Podmíněné skoky</a></p>
<p><a href="#k16">16. Další varianty podmíněných skoků</a></p>
<p><a href="#k17">17. Ukázka programové smyčky</a></p>
<p><a href="#k18">18. Obsah následujícího článku</a></p>
<p><a href="#k19">19. Předchozí články o architektuře AArch64</a></p>
<p><a href="#k20">20. Odkazy na Internetu</a></p>



<p><a name="k01"></a></p>
<h2 id="k01">1. Specifické vlastnosti procesorů AArch64: úvod</h2>

<p>Na <a href="#k19">předchozí (poněkud starší) pětici článků</a> o
architektuře AArch64 dnes navážeme. Ukážeme si, jakým způsobem se používají
základní instrukce z&nbsp;instrukční sady této velmi zajímavé architektury.
Prozatím si většinou vystačíme s&nbsp;assemblerem (a linkerem), protože pro
studijní účely je vhodné používat co nejjednodušší (resp.&nbsp;nejvíce
transparentní) nástroje. Ovšem od assembleru je jen relativně malý krok
k&nbsp;programům, které jsou zapsány v&nbsp;jazyku C, což je pochopitelně téma,
na které v&nbsp;navazujících článcích nezapomeneme.</p>

<p>Dnes se budeme zabývat jen těmi nejzákladnějšími instrukcemi, které ovšem
postačují pro tvorbu jednodušších prográmků:</p>

<ul>
<li>Přenosy dat instrukcí <strong>MOV</strong></li>
<li>Načtení dat instrukcí <strong>LDR</strong> (v&nbsp;mnoha obměnách)</li>
<li>Uložení dat instrukcí <strong>STR</strong> (taktéž v&nbsp;mnoha obměnách)</li>
<li>Součet a rozdíl realizovaný instrukcemi <strong>ADD</strong> a <strong>SUB</strong></li>
<li>Porovnání dvou hodnot pseudoinstrukcí <strong>CMP</strong></li>
<li>Nepodmíněný skok <strong>B</strong></li>
<li>Podmíněný skok <strong>B.podmínka</strong></li>
<li>Volání služby jádra instrukcí <strong>SVC</strong></li>
</ul>


<p><a name="k02"></a></p>
<h2 id="k02">2. Použitý počítač</h2>

<p>Otestování všech dále popsaných demonstračních příkladů bylo provedeno na
počítači osazeném poměrně výkonným mikroprocesorem s&nbsp;architekturou
AArch64. Bližší informace o použitém procesoru lze zjistit přímo
z&nbsp;příkazové řádky:</p>

<pre>
$ <strong>lscpu</strong>
</pre>

<p>S&nbsp;výsledkem:</p>

<pre>
&nbsp;
Architecture:                    aarch64
CPU op-mode(s):                  64-bit
Byte Order:                      Little Endian
CPU(s):                          4
On-line CPU(s) list:             0-3
Thread(s) per core:              1
Core(s) per socket:              4
Socket(s):                       1
NUMA node(s):                    1
Vendor ID:                       Cavium
Model:                           1
Model name:                      ThunderX2 99xx
Stepping:                        0x1
BogoMIPS:                        400.00
NUMA node0 CPU(s):               0-3
Vulnerability Itlb multihit:     Not affected
Vulnerability L1tf:              Not affected
Vulnerability Mds:               Not affected
Vulnerability Meltdown:          Not affected
Vulnerability Spec store bypass: Mitigation; Speculative Store Bypass disabled via prctl
Vulnerability Spectre v1:        Mitigation; __user pointer sanitization
Vulnerability Spectre v2:        Mitigation; Branch predictor hardening
Vulnerability Srbds:             Not affected
Vulnerability Tsx async abort:   Not affected
Flags:                           fp asimd evtstrm aes pmull sha1 sha2 crc32 atomics cpuid asimdrdm
</pre>

<p>Informace o dostupných jádrech:</p>

<pre>
# <strong>lscpu -a -e=socket,cpu,core,online</strong>
&nbsp;
SOCKET CPU CORE ONLINE
     0   0    0    yes
     0   1    1    yes
     0   2    2    yes
     0   3    3    yes
</pre>

<p>A podrobnější informace o jednotlivých jádrech tak, jak je vidí operační
systém:</p>

<pre>
$ <strong>cat /proc/cpuinfo</strong>
</pre>

<pre>
processor       : 0
BogoMIPS        : 400.00
Features        : fp asimd evtstrm aes pmull sha1 sha2 crc32 atomics cpuid asimdrdm
CPU implementer : 0x43
CPU architecture: 8
CPU variant     : 0x1
CPU part        : 0x0af
CPU revision    : 1
&nbsp;
processor       : 1
BogoMIPS        : 400.00
Features        : fp asimd evtstrm aes pmull sha1 sha2 crc32 atomics cpuid asimdrdm
CPU implementer : 0x43
CPU architecture: 8
CPU variant     : 0x1
CPU part        : 0x0af
CPU revision    : 1
&nbsp;
processor       : 2
BogoMIPS        : 400.00
Features        : fp asimd evtstrm aes pmull sha1 sha2 crc32 atomics cpuid asimdrdm
CPU implementer : 0x43
CPU architecture: 8
CPU variant     : 0x1
CPU part        : 0x0af
CPU revision    : 1
&nbsp;
processor       : 3
BogoMIPS        : 400.00
Features        : fp asimd evtstrm aes pmull sha1 sha2 crc32 atomics cpuid asimdrdm
CPU implementer : 0x43
CPU architecture: 8
CPU variant     : 0x1
CPU part        : 0x0af
CPU revision    : 1
</pre>



<p><a name="k03"></a></p>
<h2 id="k03">3. Instalace základních vývojářských nástrojů</h2>

<p>V&nbsp;navazujících kapitolách si ukážeme několik demonstračních příkladů
naprogramovaných v&nbsp;assembleru, konkrétně s&nbsp;využitím syntaxe
podporované GNU Assemblerem. Budeme tedy potřebovat nainstalovat všechny
potřebné nástroje, což je minimálně překladač assembleru, disassembler a
linker. Všechny tyto nástroje (a mnohé další) jsou nabízeny v&nbsp;balíčku
<strong>binutils</strong> (který není &ndash; tedy s&nbsp;ohledem na dnešní
poměry &ndash; nijak velký). Na Fedoře/RHELu se instalace tohoto balíčku
provede standardním způsobem:</p>

<pre>
# <strong>dnf install binutils</strong>
</pre>

<p>Průběh instalace na Fedoře 33 Server:</p>

<pre>
Last metadata expiration check: 0:13:15 ago on Sat 19 Feb 2022 07:05:31 AM EST.
Dependencies resolved.
===============================================================================================================================================================
 Package                                  Architecture                       Version                                  Repository                          Size
===============================================================================================================================================================
Installing:
 binutils                                 aarch64                            2.35-18.fc33                             updates                            5.8 M
Installing dependencies:
 binutils-gold                            aarch64                            2.35-18.fc33                             updates                            937 k
&nbsp;
Transaction Summary
===============================================================================================================================================================
Install  2 Packages
&nbsp;
Total download size: 6.7 M
Installed size: 30 M
Is this ok [y/N]: y
</pre>

<p>Seznam nástrojů, které se skutečně z&nbsp;tohoto balíčku nainstalovaly,
můžeme získat například takto:</p>

<pre>
$ <strong>dnf repoquery -l binutils | grep "/usr/bin" | sort |uniq</strong>
&nbsp;
/usr/bin/addr2line
/usr/bin/ar
/usr/bin/as
/usr/bin/c++filt
/usr/bin/dwp
/usr/bin/elfedit
/usr/bin/gprof
/usr/bin/ld
/usr/bin/ld.bfd
/usr/bin/nm
/usr/bin/objcopy
/usr/bin/objdump
/usr/bin/ranlib
/usr/bin/readelf
/usr/bin/size
/usr/bin/strings
/usr/bin/strip
</pre>

<p><div class="rs-tip-major">Poznámka: v&nbsp;rámci instalace se vytvořily i
manuálové stránky pro všechny výše vypsané nástroje. Z&nbsp;nich nás dnes budou
zajímat především <strong>as</strong>, <strong>ld</strong>,
<strong>objcopy</strong>, <strong>strings</strong> a
<strong>strip</strong>.</div></p>



<p><a name="k04"></a></p>
<h2 id="k04">4. Sada pracovních registrů mikroprocesorů s&nbsp;architekturou AArch64</h2>

<p>V&nbsp;navazujících kapitolách si ukážeme několik (prozatím) velmi
jednoduchých programů vytvořených v&nbsp;assembleru <i>GAS</i> pro
mikroprocesory s&nbsp;architekturou AArch64. Ovšem aby bylo zřejmé, jak jsou
tyto programy strukturovány, je nutné znát alespoň minimální informace o
pracovních registrech, speciálních registrech i o instrukční sadě AArch64.
Začněme tedy zmínkou o pracovních registrech a speciálních registrech, protože
mj.&nbsp;i v&nbsp;tomto ohledu se AArch64 odlišuje od původní 32bitové
architektury mikroprocesorů ARM.</p>

<p>Původních patnáct pracovních registrů pojmenovaných <strong>R0</strong> až
<strong>R14</strong>, které známe z&nbsp;dnes již klasických 32bitových
procesorů ARM, bylo rozšířeno na celkem 31 registrů, z&nbsp;nichž každý má nyní
šířku 64 bitů. Z&nbsp;tohoto důvodu muselo dojít k&nbsp;úpravě pojmenování
registrů způsobem, který je naznačený v&nbsp;následující tabulce a který
ostatně uvidíme i v&nbsp;dále uvedených demonstračních příkladech:</p>

<table>
<tr><th>Jméno</th><th>Význam</th></tr>
<tr><td>r0..r30</td><td>použito například v&nbsp;dokumentaci, popisu ABI atd.</td></tr>
<tr><td>x0..x30</td><td>celý 64bitový registr použitý jako zdroj či cíl pro prováděné operace</td></tr>
<tr><td>w0..w30</td><td>spodních 32 bitů registru (horních 32 bitů výsledku je buď vynulováno nebo znaménkově rozšířeno)</td></tr>
</table>

<p>Všechny tyto pracovní registry přitom mají v&nbsp;instrukční sadě stejné
postavení, na rozdíl od instrukční sady Thumb (přesněji dnes T32), v&nbsp;níž
se pro některé instrukce může použít jen spodních osm registrů. Ostatně nemělo
by se jednat o žádné překvapení, protože v&nbsp;&bdquo;pravých&ldquo; RISCových
procesorech je zvykem používat všechny pracovní registry shodným způsobem a
nerozlišovat například akumulátory, indexové registry, ukazatele na bázovou
adresu na zásobníku, čítače programových smyček atd.</p>

<p>Další sada pracovních registrů je používána při operacích s&nbsp;datovými
typy <i>single/float</i> a <i>double</i> (tedy s&nbsp;operandy reprezentovanými
v&nbsp;systému plovoucí řádové čárky), u SIMD operací a taktéž kryptografickým
modulem, o němž se blíže zmíníme v&nbsp;samostatném článku:</p>

<table>
<tr><th>Jméno</th><th>Význam</th></tr>
<tr><td>v0..v31</td><td>128bitové registry</td></tr>
<tr><td>d0..d31</td><td>spodních 64 bitů registrů v0..v31, použito pro hodnoty typu <i>double</i></td></tr>
<tr><td>s0..s31</td><td>spodních 32 bitů registrů v0..v31, použito pro hodnoty typu <i>single/float</i></td></tr>
</table>

<p>Pro SIMD operace, tj.&nbsp;operace pracující s&nbsp;vektory, se registry
<strong>vn</strong> rozdělují takto:</p>

<table>
<tr><th>Tvar (shape)</th><th>Celkem</th><th>Pojmenování v&nbsp;assembleru</th></tr>
<tr><td>8b&times;8</td><td>64b</td><td>Vn.8B</td></tr>
<tr><td>8b&times;16</td><td>128b</td><td>Vn.16B</td></tr>
<tr><td>16b&times;4</td><td>64b</td><td>Vn.4H</td></tr>
<tr><td>16b&times;8</td><td>128b</td><td>Vn.8H</td></tr>
<tr><td>32b&times;2</td><td>64b</td><td>Vn.2S</td></tr>
<tr><td>32b&times;4</td><td>128b</td><td>Vn.4S</td></tr>
<tr><td>64b&times;1</td><td>64b</td><td>Vn.1D</td></tr>
<tr><td>64b&times;2</td><td>128b</td><td>Vn.2D</td></tr>
</table>

<p>Povšimněte si, že &ndash; na rozdíl od mnoha jiných mikroprocesorových
architektur &ndash; nedochází k&nbsp;tomu, že by se například dva <i>single</i>
registry mapovaly do jednoho <i>double</i> registru atd.</p>

<p>Mezi speciální registry patří především:</p>

<table>
<tr><th>Jméno</th><th>Význam zkratky</th></tr>
<tr><td>SCTLR_ELn</td><td>System Control Register</td></tr>
<tr><td>ACTLR_ELn</td><td>Auxiliary Control Register</td></tr>
<tr><td>SCR_EL3</td><td>Secure Configuration Register</td></tr>
<tr><td>HCR_EL2</td><td>Hypervisor Configuration Register</td></tr>
<tr><td>MIDR_EL1</td><td>Main ID Register</td></tr>
<tr><td>MPIDR_EL1</td><td>Multiprocessor Affinity Register</td></tr>
</table>
 
<p>Význam těchto registrů bude popsán v&nbsp;navazujících článcích.</p>

<p>V&nbsp;pořadí třicátý druhý pracovní registr, tj.&nbsp;registr se jménem
<strong>x31</strong> či <strong>w31</strong>, není ve skutečnosti běžným
pracovním registrem, protože má dva speciální významy. V&nbsp;případě použití
tohoto registru v&nbsp;aritmetických či logických instrukcích se při použití ve
funkci vstupního operandu tento registr chová jako konstantní nula a při
použití ve funkci operandu výstupního jako /dev/null (výsledek se zahodí a
neovlivní skutečnou hodnotu uloženou do registru). Proto se v&nbsp;assembleru
může pro pojmenování tohoto registru použít jméno <strong>xzr</strong> či
<strong>wzr</strong> (<i>extended zero register</i>, <i>working zero
register</i>). U instrukcí pracujících se zásobníkem se tento registr chová
jako ukazatel na vrchol zásobníku a proto se pro něj v&nbsp;assembleru používá
jméno <strong>rsp</strong> či jen <strong>SP</strong> (na velikosti písmen u
jmen registrů samozřejmě nezáleží).</p>

<p><div class="rs-tip-major">Poznámka: s&nbsp;&bdquo;nulovým&ldquo; registrem
se setkáme i v&nbsp;dalších RISCových architekturách. Jeho existence velmi
často vede ke zjednodušení instrukční sady, dekodéru instrukcí i vlastního
mikroprocesoru.</div></p>

<p>Některé registry mají i další funkce:</p>

<ol>
<li>Registr <strong>x30</strong> se používá ve funkci <strong>LR</strong> (<i>Link Register</i>).</li>
<li>Registr <strong>PC</strong> není přímo dostupný. Toto je jeden z&nbsp;největších viditelných rozdílů mezi ARM 32 a AArch64.</li>
</ol>



<p><a name="k05"></a></p>
<h2 id="k05">5. Instrukce <strong>MOV</strong> a <strong>SVC</strong></h2>

<p>V&nbsp;demonstračním příkladu, který bude ukázán <a href="#k06">v&nbsp;další
kapitole</a>, si vystačíme s&nbsp;pouhými dvěma typy instrukcí. Jedná se o
instrukci nazvanou <strong>MOV</strong> a o instrukci pojmenovanou
<strong>SVC</strong>. Instrukce <strong>MOV</strong> slouží k&nbsp;přesunu dat
mezi pracovními registry i pro načtení konstanty do registru. Ve skutečnosti
existuje větší množství variant instrukce <strong>MOV</strong>, přičemž nás
bude konkrétně zajímat varianta, která dokáže do zvoleného pracovního registru
uložit konstantu. V&nbsp;assembleru je registr, do něhož se konstanta ukládá,
použit jako první operand, za nímž následuje vlastní konstanta zapisovaná
s&nbsp;křížkem na začátku (to aby se odlišila konstanta od adresy):</p>

<pre>
<i># Linux kernel system call table</i>
sys_exit=93
&nbsp;
mov  x8, #sys_exit      <i>// cislo sycallu pro funkci "exit"</i>
mov  x0, #0             <i>// exit code = 0</i>
</pre>

<p><div class="rs-tip-major">Poznámka: GNU assembler rozeznává instrukci
<strong>MOV</strong>, ovšem ve skutečnosti se jedná o pseudoinstrukci, zde
konkrétně o alias instrukce <strong>MOVI</strong>.</div></p>

<p>Název instrukce <strong>SVC</strong> vznikl ze sousloví <i>SuperVisor
Call</i> a (minimálně na Linuxu) slouží k&nbsp;volání služeb jádra. Tato
instrukce má jeden operand určující typ volání. Opět se podívejme na způsob
zápisu této funkce v&nbsp;assembleru::</p>

<pre>
svc  0                  <i>// volani Linuxoveho kernelu</i>
</pre>



<p><a name="k06"></a></p>
<h2 id="k06">6. Nejjednodušší korektní program zapsaný v&nbsp;assembleru</h2>

<p>Podívejme se nyní, jak by mohl vypadat program (pravděpodobně dokonce
nejjednodušší funkční program vůbec), který po svém spuštění pouze zavolá
službu jádra nazvanou <strong>exit</strong>, která program ukončí a předá
volajícímu (rodičovskému) procesu návratový kód. Celý program obsahuje pouze
tři instrukce, přičemž první instrukce slouží pro naplnění registru
obsahujícího číslo služby jádra (liší se podle použité architektury!), druhá
instrukce naplní registr s&nbsp;návratovým kódem a třetí instrukce skutečně
zavolá jádro, které vykoná zvolenou službu.</p>

<p>V&nbsp;GNU assembleru lze takový program zapsat následovně (jedná se o
šablonu, takže obsahuje i nepotřebné bloky):</p>

<pre>
<i># asmsyntax=as</i>
&nbsp;
<i># Sablona pro zdrojovy kod Linuxoveho programu naprogramovaneho</i>
<i># v assembleru GNU AS pro architekturu AArch64.</i>
<i>#</i>
<i># Autor: Pavel Tisnovsky</i>
&nbsp;
&nbsp;
&nbsp;
<i># Linux kernel system call table</i>
sys_exit=93
&nbsp;
<i># List of syscalls for AArch64:</i>
<i># https://github.com/torvalds/linux/blob/master/include/uapi/asm-generic/unistd.h</i>
&nbsp;
&nbsp;
&nbsp;
<i>#-----------------------------------------------------------------------------</i>
.section .data
&nbsp;
&nbsp;
&nbsp;
<i>#-----------------------------------------------------------------------------</i>
.section .bss
&nbsp;
&nbsp;
&nbsp;
<i>#-----------------------------------------------------------------------------</i>
.section .text
        .global _start          <i>// tento symbol ma byt dostupny i z linkeru</i>
&nbsp;
_start:
        mov  x8, #sys_exit      <i>// cislo sycallu pro funkci "exit"</i>
        mov  x0, #0             <i>// exit code = 0</i>
        svc  0                  <i>// volani Linuxoveho kernelu</i>
</pre>

<p>Překlad tohoto demonstračního příkladu a jeho slinkování se provede
standardním způsobem, tedy s&nbsp;použitím nástrojů <strong>as</strong> (GNU
Assembler &ndash; GAS) a <strong>ld</strong> (GNU Linker), které byly
nainstalovány v&nbsp;rámci úvodních kapitol:</p>

<pre>
$ <strong>as aarch64.s -o aarch64.o</strong>
$ <strong>ld -s aarch64.o</strong>
</pre>

<p>Výsledkem bude soubor nazvaný <strong>a.out</strong>, který je možné
spustit:</p>

<pre>
$ <strong>./a.out</strong>
</pre>

<p>Program by měl okamžitě skončit, a to bez chyby nebo pádu.</p>

<p>Zastavme se na chvíli u významu obsahu registru <strong>x0</strong>. Při
volání funkce jádra <strong>exit</strong> obsahuje tento registr hodnotu,
kterou proces vrátí do volajícího procesu, typicky do shellu. Můžeme si to
snadno otestovat nepatrnou úpravou našeho programu:</p>

<pre>
.section .text
        .global _start          <i>// tento symbol ma byt dostupny i z linkeru</i>
&nbsp;
_start:
        mov  x8, #sys_exit      <i>// cislo sycallu pro funkci "exit"</i>
        mov  x0, #42
        svc  0                  <i>// volani Linuxoveho kernelu</i>
</pre>

<p>Překlad a otestování nové varianty:</p>

<pre>
$ <strong>as aarch64.s -o aarch64.o</strong>
$ <strong>ld -s aarch64.o</strong>
$ <strong>./a.out</strong>
$ <strong>echo $?</strong>
42
</pre>

<p>Vidíme, že se skutečně vrátila hodnota 42.</p>

<p><div class="rs-tip-major">Poznámka: jen pro porovnání se můžeme podívat na
variantu určenou pro architekturu x86, v&nbsp;níž jsou použita odlišná čísla
služeb jádra, pro volání jádra se používá instrukce <strong>int</strong> a liší
se mj.&nbsp;i značení a pořadí operandů u instrukcí:</div></p>

<pre>
<i># Linux kernel system call table</i>
sys_exit=1
&nbsp;
<i>#-----------------------------------------------------------------------------</i>
.section .data
&nbsp;
<i>#-----------------------------------------------------------------------------</i>
.section .bss
<i>#-----------------------------------------------------------------------------</i>
.section .text
        .global _start          <i># tento symbol ma byt dostupny i linkeru</i>
&nbsp;
_start:
        movl  $sys_exit,%eax    <i># cislo sycallu pro funkci "exit"</i>
        movl  $0,%ebx           <i># exit code = 0</i>
        int   $0x80             <i># volani Linuxoveho kernelu</i>
</pre>



<p><a name="k07"></a></p>
<h2 id="k07">7. Kódování instrukcí <strong>MOV</strong> a <strong>SVC</strong> u architektury AArch64</h2>

<p>U architektury AArch64 se používají instrukce o pevné délce čtyři bajty, což
má mj.&nbsp;i dalekosáhlé praktické důsledky &ndash; načítání konstant, rozsah
cílů skoků atd. (na druhou stranu se zjednodušil a urychlil dekodér instrukcí).
Bude tedy zajímavé zjistit, jakým způsobem se vlastně přeložila naše trojice
instrukcí. Pro tento účel použijeme nástroj <strong>objdump</strong>, jenž byl
nainstalován v&nbsp;rámci úvodních kapitol v&nbsp;balíčku <i>binutils</i>:</p>

<pre>
$ <strong>objdump -f -d -t -h a.out</strong>
</pre>

<p>Takto volaný příkaz nejprve zobrazí základní informace o obsahu souboru,
následně jednotlivé sekce (segmenty), dále tabulku symbolů (ta je v&nbsp;našem
případě prázdná) a konečně i disassemblovaný kód nalezený v&nbsp;sekci/sektoru
nazvaném <strong>.text</strong> (taktéž se používá označení
<strong>code</strong>):</p>

<pre>
a.out:     file format elf64-littleaarch64
architecture: aarch64, flags 0x00000102:
EXEC_P, D_PAGED
start address 0x0000000000400078
&nbsp;
Sections:
Idx Name          Size      VMA               LMA               File off  Algn
  0 .text         0000000c  0000000000400078  0000000000400078  00000078  2**2
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
SYMBOL TABLE:
no symbols
&nbsp;
&nbsp;
&nbsp;
Disassembly of section .text:
&nbsp;
0000000000400078 &lt;.text&gt;:
  400078:       d2800ba8        mov     x8, #0x5d                       // #93
  40007c:       d2800000        mov     x0, #0x0                        // #0
  400080:       d4000001        svc     #0x0
</pre>

<p>Vidíme, že počáteční (startovní) adresa je rovna 0x0000000000400078, což je
posléze ve výpisu adres instrukcí zkracováno na 4000xx. Dále je ve druhém
sloupci u každé instrukce uvedena sekvence bajtů se zakódovanou instrukcí i se
zakódovanými operandy této instrukce. Z&nbsp;výpisu je patrné, že všechny
instrukce mají skutečně šířku čtyři bajty.</p>

<p>Podívejme se nyní na způsob zakódování instrukcí <strong>mov registr,
#konstanta</strong>. Tato instrukce je zakódována ve čtyřech bajtech, a to
včetně šestnáctibitové konstanty a čísla pracovního registru. To
mj.&nbsp;znamená, že instrukce:</p>

<pre>
mov x8, #0x5d
</pre>

<p>Je zakódována do této sekvence bajtů:</p>

<pre>
d2 80 0b a8
</pre>

<p>Binárně pak:</p>

<pre>
1 1 0 1 | 0 0 1 0 | 1 0 0 0 | 0 0 0 0 | 0 0 0 0 | 1 0 1 1 | 1 0 1 0 | 1 0 0 0
</pre>

<p>Instrukce <strong>MOV registr, #konstanta</strong> používá toto kódování:</p>

<pre>
| sf | 1 0 | 1 0 0 1 0 1 | hw | imm16 | Rd |
</pre>

<p>kde:</p>

<ul>
<li>sf = 0 pro 32bitovou operaci</li>
<li>sf = 1 pro 64bitovou operaci</li>
<li>hw = 00 (dva bity)</li>
<li>imm16 = 16bitová konstanta</li>
<li>Rd = číslo pracovního registru, do kterého se má konstanta uložit</li>
</ul>

<p>Zkusme tedy dosadit hodnoty pro instrukci:</p>

<pre>
mov x8, #0x5d
</pre>

<ul>
<li>sf = 1</li>
<li>imm16 = 0x5d (01011101)</li>
<li>Rd = 8 (01000)</li>
</ul>

<p>Binárně a hexadecimálně:</p>

<pre>
1 1 0 1 |0 0 1 0 | 1 0 0 0| 0 0 0 0 | 0 0 0 0 | 1 0 1 1 | 1 0 1 0 | 1 0 0 0
   d        2         8        0         0         b         a         8
</pre>

<p>Což plně odpovídá:</p>

<pre>
d2 80 0b a8
</pre>

<p>Instrukce <strong>SVC</strong> má tento formát:</p>

<pre>
| 1 1 0 1 0 1 0 0 0 0 0 | imm16 | 0 0 0 0 1 |
</pre>

<p>V&nbsp;našem konkrétním případě je 16bitová konstanta <strong>imm16</strong>
nastavena na nulu, takže:</p>

<pre>
| 1 1 0 1 | 0 1 0 0 | 0 0 0 0 | 0 0 0 0 | 0 0 0 0 | 0 0 0 0 | 0 0 0 0 | 0 0 0 1 |
     d         4         0         0         0         0         0         1
</pre>

<p><div class="rs-tip-major">Poznámka: celý instrukční soubor má teoreticky
2<sup>32</sup> instrukčních kódů (ne všechny jsou však obsazené). Vysvětlením
instrukce <strong>mov Rd, #konstanta</strong> jsme již pokryli minimálně
2<sup>16+5</sup>=2<sup>21</sup> ze všech možných kombinací.</div></p>



<p><a name="k08"></a></p>
<h2 id="k08">8. Instrukce typu Load-Store</h2>

<p>Jak je u RISCové architektury obvyklé, nalezneme v&nbsp;instrukční sadě i
několik instrukcí určených pro načítání dat z&nbsp;paměti do registrů a naopak
pro ukládání obsahu registrů do paměti. Navíc některé instrukce umožňují práci
nejenom s&nbsp;32bitovými a 64bitovými slovy, ale i s&nbsp;menšími bloky dat
&ndash; s&nbsp;bajty a šestnáctibitovými &bdquo;půlslovy&ldquo; (což je
důležité například při zpracování řetězců, obrázků, zvukových samplů atd.):</p>

<table>
<tr><th>#</th><th>Instrukce</th><th>Stručný popis</th></tr>
<tr><td>1</td><td>LDR</td><td>načtení 32bitového či 64bitového registru z&nbsp;paměti</td></tr>
<tr><td>2</td><td>LDRB</td><td>načtení bajtu a s&nbsp;rozšířením na slovo (doplňují se nuly)</td></tr>
<tr><td>3</td><td>LDRSB</td><td>načtení bajtu se znaménkovým rozšířením</td></tr>
<tr><td>4</td><td>LDRH</td><td>načtení šestnáctibitového &bdquo;půlslova&ldquo; s&nbsp;rozšířením o nuly</td></tr>
<tr><td>5</td><td>LDRSH</td><td>načtení šestnáctibitového &bdquo;půlslova&ldquo; se znaménkovým rozšířením</td></tr>
<tr><td>6</td><td>LDRSW</td><td>načtení 32bitového slova se znaménkovým rozšířením do 64bitového registru</td></tr>
<tr><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td></tr>
<tr><td>7</td><td>STR</td><td>uložení 32bitového či 64bitového registru do paměti</td></tr>
<tr><td>8</td><td>STRB</td><td>uložení bajtu z&nbsp;vybraného 32bitového registru</td></tr>
<tr><td>9</td><td>STRH</td><td>uložení šestnáctibitového &bdquo;půlslova&ldquo; z&nbsp;vybraného 32bitového registru</td></tr>
</table>

<p>Poznámka: zdánlivě chybějící instrukce <strong>LDRW</strong> a
<strong>STRW</strong> jsou již obsaženy v&nbsp;základních instrukcích
<strong>LDR</strong> a <strong>STR</strong> pokud použijeme 32bitový registr (u
<strong>LDR</strong> se horních 32 bitů vynuluje).</p>

<p>Mezi podporované adresovací režimy patří i použití offsetu vůči vybranému
registru či SP. Navíc je možné zajistit takzvaný <i>pre-index</i> a
<i>post-index</i>, tj.&nbsp;změnu obsahu registru obsahujícího adresu před či
po provedení operace LOAD/STORE. Toho lze využít například při práci
s&nbsp;poli nebo s&nbsp;řetězci:</p>

<pre>
ldr X1, [X2, #4]! <i>// X1 ← *(X2 + 4)</i>
                  <i>// X2 ← X2 + 4</i>
</pre>

<pre>
ldr X1, [X2], #4  <i>// X1 ← *X2</i>
                  <i>// X2 ← X2 + 4</i>
</pre>

<p><div class="rs-tip-major">Poznámka: právě tuto variantu instrukce
<strong>str</strong> (konkrétně <strong>strb</strong>) použijeme v&nbsp;dalším
textu.</div></p>



<p><a name="k09"></a></p>
<h2 id="k09">9. Program typu &bdquo;Hello, world!&ldquo; v&nbsp;assembleru</h2>

<p>Druhý demonstrační příklad, který si dnes ukážeme, je nepatrně složitější,
protože se jedná o aplikaci typu &bdquo;Hello, world!&ldquo;, v&nbsp;níž musíme
volat dvě funkce jádra &ndash; <strong>sys_write</strong> určenou pro zápis na
standardní výstup (to v&nbsp;našem případě &ndash; obecně se jedná o zápis
binárních dat do otevřeného kanálu) a <strong>sys_exit</strong> pro ukončení
aplikace. Způsob volání funkcí jádra s&nbsp;předáváním hodnot v&nbsp;pracovních
registrech by nás již neměl ničím překvapit. Nová je však instrukce
<strong>ldr</strong>, přesněji řečeno způsob určení adresy, která se má do
zvoleného pracovního registru načíst. Ke způsobu překladu této instrukce se
dostaneme v&nbsp;navazující kapitole. Další novinkou je definice dat
v&nbsp;sekci/segmentu <strong>data</strong>. Jedná se o řetězec, který se má
vypsat na terminál:</p>

<pre>
<i># asmsyntax=as</i>
&nbsp;
<i># Jednoducha aplikace typu "Hello world!" naprogramovana</i>
<i># v assembleru GNU as.</i>
<i>#</i>
<i># Autor: Pavel Tisnovsky</i>
&nbsp;
&nbsp;
&nbsp;
<i># Linux kernel system call table</i>
sys_exit=93
sys_write=64
&nbsp;
<i># List of syscalls for AArch64:</i>
<i># https://github.com/torvalds/linux/blob/master/include/uapi/asm-generic/unistd.h</i>
&nbsp;
&nbsp;
&nbsp;
<i>#-----------------------------------------------------------------------------</i>
.section .data
&nbsp;
hello_lbl:
        .string "Hello World!\n"
&nbsp;
<i>#-----------------------------------------------------------------------------</i>
.section .bss
&nbsp;
&nbsp;
&nbsp;
<i>#-----------------------------------------------------------------------------</i>
.section .text
        .global _start          <i>// tento symbol ma byt dostupny i linkeru</i>
&nbsp;
_start:
        mov  x8, #sys_write     <i>// cislo sycallu pro funkci "write"</i>
        mov  x0, #1             <i>// standardni vystup</i>
        ldr  x1, =hello_lbl     <i>// adresa retezce, ktery se ma vytisknout</i>
        mov  x2, #13            <i>// pocet znaku, ktere se maji vytisknout</i>
        svc  0                  <i>// volani Linuxoveho kernelu</i>
&nbsp;
        mov  x8, #sys_exit      <i>// cislo sycallu pro funkci "exit"</i>
        mov  x0, #0             <i>// exit code = 0</i>
        svc  0                  <i>// volani Linuxoveho kernelu</i>
</pre>

<p><div class="rs-tip-major">Poznámka: povšimněte si, že systémová funkce
<strong>sys_write</strong> vyžaduje zadání tří parametrů: určení kanálu
(například otevřeného souboru), do kterého se budou data zapisovat, dále
počáteční adresu bloku dat a konečně počet zapisovaných bajtů. Jedná se tedy o
obecnou funkci, u které si musíme dát pozor na to, že nebere v&nbsp;úvahu
například způsoby ukončení standardních céčkovských řetězců.</div></p>



<p><a name="k10"></a></p>
<h2 id="k10">10. Uložení adresy načítané instrukcí <strong>LDR</strong></h2>

<p>Opět se podívejme na způsob překladu druhého demonstračního příkladu do
strojového kódu. Poznámky budou uvedeny pod výpisem zdrojového kódu:</p>

<pre>
$ <strong>objdump -f -d -t -h a.out</strong>
</pre>

<pre>
a.out:     file format elf64-littleaarch64
architecture: aarch64, flags 0x00000102:
EXEC_P, D_PAGED
start address 0x00000000004000b0
&nbsp;
Sections:
Idx Name          Size      VMA               LMA               File off  Algn
  0 .text         00000028  00000000004000b0  00000000004000b0  000000b0  2**3
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  1 .data         0000000e  00000000004100d8  00000000004100d8  000000d8  2**0
                  CONTENTS, ALLOC, LOAD, DATA
SYMBOL TABLE:
no symbols
&nbsp;
&nbsp;
&nbsp;
Disassembly of section .text:
&nbsp;
00000000004000b0 &ld;.text&gt;:
  4000b0:       d2800808        mov     x8, #0x40                       // #64
  4000b4:       d2800020        mov     x0, #0x1                        // #1
  4000b8:       580000c1        ldr     x1, 0x4000d0
  4000bc:       d28001a2        mov     x2, #0xd                        // #13
  4000c0:       d4000001        svc     #0x0
  4000c4:       d2800ba8        mov     x8, #0x5d                       // #93
  4000c8:       d2800000        mov     x0, #0x0                        // #0
  4000cc:       d4000001        svc     #0x0
  4000d0:       004100d8        .inst   0x004100d8 ; undefined
  4000d4:       00000000        udf     #0
</pre>

<p>Nově se ve spustitelném kódu objevuje segment/sekce <strong>data</strong>,
ve které je uložen řetězec, který se má vypsat na obrazovku. Ovšem zajímavější
je instrukce <strong>LDR</strong>, která je zakódována následovně:</p>

<pre>
  4000b8:       580000c1        ldr     x1, 0x4000d0
</pre>

<p>Povšimněte si, že tato instrukce říká, že se obsah pracovního registru
<strong>x1</strong> má naplnit z&nbsp;paměťových buněk uložených na adresách
0x4000d0 až 0x4000d7 (jedná se totiž o 64bitový registr). Tyto adresy jsou ve
skutečnosti součástí segmentu/sekce <strong>text</strong> a jsou tedy jakoby
součástí programového kódu. A skutečně &ndash; jedná se o poslední dva řádky ve
výpisu:</p>

<pre>
  4000d0:       004100d8        .inst   0x004100d8 ; undefined
  4000d4:       00000000        udf     #0
</pre>

<p><div class="rs-tip-major">Poznámka: <strong>objdump</strong> se snaží obsah
interpretovat jako instrukce, což se mu nedaří a dařit ani nemůže.</div></p>

<p>Obsah výše zmíněných paměťových buněk je tedy 0x00000000 a 0x004100d8.
Podívejme se ještě jednou na sekce nalezené v&nbsp;binárním souboru:</p>

<pre>
Sections:
Idx Name          Size      VMA               LMA               File off  Algn
  0 .text         00000028  00000000004000b0  00000000004000b0  000000b0  2**3
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  1 .data         <strong>0000000e</strong>  <strong>00000000004100d8</strong>  00000000004100d8  000000d8  2**0
                  CONTENTS, ALLOC, LOAD, DATA
</pre>

<p>Vidíme, že obsah těchto buněk skutečně obsahuje počáteční adresu sekce
<strong>data</strong>, v&nbsp;níž je uložen řetězec. A jedná se o jediná data
zde uložená a proto má sekce délku 0x0000000e bajtů neboli 14 bajtů. To opět
přesně odpovídá kódu v&nbsp;assembleru:</p>

<pre>
hello_lbl:
        .string "Hello World!\n"
</pre>

<p><div class="rs-tip-major">Poznámka: s&nbsp;tímto trikem se setkáme poměrně
často i u některých dalších RISCových architektur. Jedná se o to, že
v&nbsp;32bitovém instrukčním slovu není (a nemůže být) místo pro uložení plné
adresy a ještě navíc instrukčního kódu. Z&nbsp;tohoto důvodu je adresa uložena
v&nbsp;blízkém dosahu a je adresována relativně.</div></p>



<p><a name="k11"></a></p>
<h2 id="k11">11. Zápis do datového segmentu</h2>

<p>Potřetí se podívejme na informace o segmentech, z&nbsp;nichž se skládá
binární spustitelný soubor:</p>

<pre>
Sections:
Idx Name          Size      VMA               LMA               File off  Algn
  0 .text         00000028  00000000004000b0  00000000004000b0  000000b0  2**3
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  1 .data         <strong>0000000e</strong>  <strong>00000000004100d8</strong>  00000000004100d8  000000d8  2**0
                  CONTENTS, ALLOC, LOAD, DATA
</pre>

<p>Zajímavé je, že segment <strong>text</strong> je určen pouze pro čtení,
takže proces nemůže provádět žádné modifikace (tedy nelze vytvořit
automodifikující se kód, což je asi jen dobře). Naproti tomu segment
<strong>data</strong> je určen i pro zápis, o což se můžeme pokusit.
V&nbsp;programovém kódu nejprve změníme obsah řetězce, který se má vytisknout a
teprve poté řetězec vytiskneme. Abychom si neukazovali pouze
&bdquo;obyčejnou&ldquo; instrukci <strong>STRB</strong> (zápis bajtu),
použijeme adresování s&nbsp;offsetem. Jinými slovy &ndash; zapíšeme nový bajt
nikoli na začátek řetězce, ale na offsetu 5, a to bez výpočtu této adresy.
Samotný výpočet offsetu, tj.&nbsp;adresy složené z&nbsp;obsahu pracovního
registru <strong>x1</strong> s&nbsp;offsetem 5 je proveden za běhu:</p>

<pre>
ldr  x1, =hello_lbl     <i>// adresa retezce, ktery se ma modifikovat</i>
mov  w2, #'*'           <i>// znak ktery zapiseme do retezce</i>
strb w2, [x1, 5]        <i>// zapis znaku s vyuzitim offsetu (prepiseme mezeru v retezci)</i>
</pre>

<p>Upravený zdrojový kód tohoto příkladu vypadá následovně:</p>

<pre>
<i># Linux kernel system call table</i>
sys_exit=93
sys_write=64
&nbsp;
<i># List of syscalls for AArch64:</i>
<i># https://github.com/torvalds/linux/blob/master/include/uapi/asm-generic/unistd.h</i>
&nbsp;
&nbsp;
&nbsp;
<i>#-----------------------------------------------------------------------------</i>
.section .data
&nbsp;
hello_lbl:
        .string "Hello World!\n"
&nbsp;
<i>#-----------------------------------------------------------------------------</i>
.section .bss
&nbsp;
&nbsp;
&nbsp;
<i>#-----------------------------------------------------------------------------</i>
.section .text
        .global _start          <i>// tento symbol ma byt dostupny i linkeru</i>
&nbsp;
_start:
        ldr  x1, =hello_lbl     <i>// adresa retezce, ktery se ma vytisknout</i>
        mov  w2, #'*'           <i>// znak ktery zapiseme do retezce</i>
        strb w2, [x1, 5]        <i>// zapis znaku s vyuzitim offsetu</i>
&nbsp;
        mov  x8, #sys_write     <i>// cislo sycallu pro funkci "write"</i>
        mov  x0, #1             <i>// standardni vystup</i>
        ldr  x1, =hello_lbl     <i>// adresa retezce, ktery se ma vytisknout</i>
        mov  x2, #13            <i>// pocet znaku, ktere se maji vytisknout</i>
        svc  0                  <i>// volani Linuxoveho kernelu</i>
&nbsp;
        mov  x8, #sys_exit      <i>// cislo sycallu pro funkci "exit"</i>
        mov  x0, #0             <i>// exit code = 0</i>
        svc  0                  <i>// volani Linuxoveho kernelu</i>
</pre>

<p>Po překladu a spuštění by se mělo vypsat:</p>

<pre>
Hello*World!
</pre>

<p>(s&nbsp;odřádkováním na konci)</p>



<p><a name="k12"></a></p>
<h2 id="k12">12. Základní aritmetické instrukce</h2>

<p>V&nbsp;následujícím demonstračním příkladu budou využity některé aritmetické
instrukce, s&nbsp;nimiž se ve stručnosti seznámíme v&nbsp;této kapitole. Mezi
základní aritmetické instrukce samozřejmě patří součet a rozdíl. Existují vždy
čtyři varianty každé z&nbsp;těchto operací, které se od sebe liší podle toho,
zda se při výpočtu nastavují příznaky (všechny čtyři &ndash; přetečení, přenos,
nulovost a zápornost) a zda se po součtu či rozdílu ještě k&nbsp;výsledku
přičte předchozí hodnota příznaku <i>carry</i>:</p>

<table>
<tr><th>#</th><th>Instrukce</th><th>Stručný popis</th></tr>
<tr><td>1</td><td>ADD</td><td>32bitový či 64bitový součet</td></tr>
<tr><td>2</td><td>ADC</td><td>32bitový či 64bitový součet s&nbsp;carry</td></tr>
<tr><td>3</td><td>ADDS</td><td>jako ADD, ovšem navíc nastaví příznakové bity</td></tr>
<tr><td>4</td><td>ADCS</td><td>jako ADC, ovšem navíc nastaví příznakové bity</td></tr>
<tr><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td></tr>
<tr><td>5</td><td>SUB</td><td>32bitový či 64bitový rozdíl</td></tr>
<tr><td>6</td><td>SBC</td><td>rozdíl s&nbsp;přičtením carry a odečtením jedničky</td></tr>
<tr><td>7</td><td>SUBS</td><td>jako SUB, ovšem navíc nastaví příznakové bity</td></tr>
<tr><td>8</td><td>SBCS</td><td>jako SBC, ovšem navíc nastaví příznakové bity</td></tr>
</table>

<p>Kromě toho existuje hned několik instrukčních aliasů, které je možné
používat v&nbsp;assemblerech a které jsou rozpoznány i v&nbsp;disassemblerech a
debuggerech. Tyto aliasy využívají registr <strong>WZR</strong> (32 bitů) či
<strong>XZR</strong> (64 bitů). Připomeňme si, že tento registr je při čtení
vždy nulový, což je v&nbsp;tomto případě výhodné, protože vlastně zadarmo
získáme velké množství užitečných instrukcí:</p>

<table>
<tr><th>#</th><th>Instrukce</th><th>Stručný popis</th></tr>
<tr><td>1</td><td>NEG</td><td>alias pro SUB op1, xZR, op2 (op1 = 0 - op2)</td></tr>
<tr><td>2</td><td>NEGS</td><td>alias pro SUBS op1, xZR, op2 (op1 = 0 - op2 + nastavení příznaků)</td></tr>
<tr><td>3</td><td>NGC</td><td>alias pro SBC op1, xZR, op2 (op1 = 0 - op2 + carry - 1)</td></tr>
<tr><td>4</td><td>NGCS</td><td>kombinace předchozích dvou instrukcí</td></tr>
<tr><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td></tr>
<tr><td>5</td><td>CMP</td><td>alias pro SUBS xZR, op1, op2 (tj.výsledek se zahodí, protože do registrů WZR/XZR se nezapisuje)</td></tr>
<tr><td>6</td><td>CMN</td><td>alias pro ADDS xZR, op1, op2 (dtto jako předchozí instrukce)</td></tr>
<tr><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td></tr>
<tr><td>7</td><td>MOV</td><td>alias pro ADD reg1, reg2, #0 (platí je při přesunu dat mezi registry)</td></tr>
</table>

<p>Poznámka: v&nbsp;praxi se setkáte především s&nbsp;aliasy
<strong>CMP</strong>, <strong>CMN</strong> a hlavně pak <strong>MOV</strong>
(resp.&nbsp;přesněji řečeno je toto jedna z&nbsp;mnoha variant pseudoinstrukce
<strong>MOV</strong>).</p>



<p><a name="k13"></a></p>
<h2 id="k13">13. Použití aritmetických instrukcí</h2>

<p>Ukažme si nyní příklad použití základních aritmetických instrukcí součtu a
rozdílu. Nejdříve provedeme součet dvou hodnot. V&nbsp;RISCové instrukční sadě
je nutné nejdříve operandy načíst do pracovních registrů a teprve poté provést
příslušnou operaci. Aritmetické operace přitom používají takzvaný
<i>tříadresový kód</i>, protože se v&nbsp;instrukci uvádí jak oba vstupní
operandy, tak i registr, do kterého se provádí zápis (tj.&nbsp;takto je
obsazeno 3&times;5=15 bitů instrukčního slova):</p>

<pre>
mov  x0, #1             <i>// prvni operand</i>
mov  x1, #2             <i>// druhy operand</i>
add  x0, x0, x1         <i>// operace souctu</i>
</pre>

<p>Podobně je realizován rozdíl:</p>

<pre>
mov  x0, #1000          <i>// prvni operand</i>
mov  x1, #995           <i>// druhy operand</i>
sub  x0, x0, x1         <i>// operace souctu</i>
</pre>

<p>V&nbsp;obou případech byl výsledek operace uložen zpět do registru
<strong>x0</strong>. Nejnižší cifru výsledku zobrazíme relativně snadno &ndash;
přičteme k&nbsp;ní hodnotu ASCII znaku "0" a výsledek (jediný bajt) uložíme do
bloku paměti s&nbsp;předpřipraveným řetězcem &ndash; v&nbsp;podstatě nahradíme
znaky "?" za vypočtené výsledky:</p>

<pre>
.section .data
&nbsp;
result_lbl:
        <strong>.string "x=?\ny=?\n"</strong>
&nbsp;
&nbsp;
<i>ldr  x3, =result_lbl    // adresa retezce, ktery se ma vytisknout</i>
&nbsp;
<i># výsledek součtu</i>
<i>mov  x2, #'0'           // prvni cifra v ASCII kodu</i>
<i>add  x0, x0, x2         // převod na ASCII</i>
<i>strb w0, [x3, 2]        // zapis znaku s vyuzitim offsetu</i>
&nbsp;
<i># výsledek rozdílu</i>
<i>mov  x2, #'0'           // prvni cifra v ASCII kodu</i>
<i>add  x0, x0, x2         // převod na ASCII</i>
<i>strb w0, [x3, 6]        // zapis znaku s vyuzitim offsetu</i>
</pre>

<p><div class="rs-tip-major">Poznámka: takto jednoduše lze ovšem pracovat pouze
s&nbsp;jedinou cifrou výsledku, nikoli například s&nbsp;pěticiferným
výsledkem!</div></p>

<p>Ukažme si nyní úplný zdrojový kód upraveného demonstračního příkladu:</p>

<pre>
<i># asmsyntax=as</i>
&nbsp;
<i># Zakladni aritmeticke instrukce</i>
<i># v assembleru GNU as.</i>
<i>#</i>
<i># Autor: Pavel Tisnovsky</i>
&nbsp;
&nbsp;
&nbsp;
<i># Linux kernel system call table</i>
sys_exit=93
sys_write=64
&nbsp;
<i># List of syscalls for AArch64:</i>
<i># https://github.com/torvalds/linux/blob/master/include/uapi/asm-generic/unistd.h</i>
&nbsp;
&nbsp;
&nbsp;
<i>#-----------------------------------------------------------------------------</i>
.section .data
&nbsp;
result_lbl:
        .string "x=?\ny=?\n"
&nbsp;
<i>#-----------------------------------------------------------------------------</i>
.section .bss
&nbsp;
&nbsp;
&nbsp;
<i>#-----------------------------------------------------------------------------</i>
.section .text
        .global _start          <i>// tento symbol ma byt dostupny i linkeru</i>
&nbsp;
_start:
        ldr  x3, =result_lbl    <i>// adresa retezce, ktery se ma vytisknout</i>
&nbsp;
        mov  x0, #1             <i>// prvni operand</i>
        mov  x1, #2             <i>// druhy operand</i>
        add  x0, x0, x1         <i>// operace souctu</i>
&nbsp;
        mov  x2, #'0'           <i>// prvni cifra v ASCII kodu</i>
        add  x0, x0, x2         <i>// převod na ASCII</i>
        strb w0, [x3, 2]        <i>// zapis znaku s vyuzitim offsetu</i>
&nbsp;
        mov  x0, #1000          <i>// prvni operand</i>
        mov  x1, #995           <i>// druhy operand</i>
        sub  x0, x0, x1         <i>// operace souctu</i>
&nbsp;
        mov  x2, #'0'           <i>// prvni cifra v ASCII kodu</i>
        add  x0, x0, x2         <i>// převod na ASCII</i>
        strb w0, [x3, 6]        <i>// zapis znaku s vyuzitim offsetu</i>
&nbsp;
        mov  x8, #sys_write     <i>// cislo sycallu pro funkci "write"</i>
        mov  x0, #1             <i>// standardni vystup</i>
        ldr  x1, =result_lbl    <i>// adresa retezce, ktery se ma vytisknout</i>
        mov  x2, #8             <i>// pocet znaku, ktere se maji vytisknout</i>
        svc  0                  <i>// volani Linuxoveho kernelu</i>
&nbsp;
        mov  x8, #sys_exit      <i>// cislo sycallu pro funkci "exit"</i>
        mov  x0, #0             <i>// exit code = 0</i>
        svc  0                  <i>// volani Linuxoveho kernelu</i>
</pre>

<p>Po překladu a spuštění by se měly zobrazit vypočtené výsledky:</p>

<pre>
x=3
y=5
</pre>



<p><a name="k14"></a></p>
<h2 id="k14">14. Nepodmíněné skoky a skoky do subrutiny (<i>branch with link</i>)</h2>

<p>U instrukční sady AArch64 je zajímavé (a současně i velmi užitečné), že
základní skoková instrukce <strong>B</strong> neprovádí skok na zadanou
absolutní adresu, ale na adresu relativní vůči aktuální hodnotě PC. Rozsah
skoku je v&nbsp;takovém případě &pm;128 MB; větší konstantu není možné
v&nbsp;dané konfiguraci instrukčního slova uložit. Dále pak instrukční soubor
obsahuje instrukci pro skok do podprogramu s&nbsp;uložením návratové adresy do
registru X30 (nikoli na zásobník, používáme RISCový čip) a skok na absolutní
adresu uloženou ve vybraném registru. Tato instrukce existuje ve dvou
variantách, které se od sebe odlišují pouze hintem pro CPU, zda se právě
realizuje návrat z&nbsp;podprogramu (subrutiny) či obyčejný skok:</p>

<table>
<tr><th>#</th><th>Instrukce</th><th>Stručný popis</th></tr>
<tr><td>1</td><td>B</td><td>skok na adresu vypočtenou z&nbsp;offsetu vůči PC v&nbsp;rozsahu &pm;128 MB</td></tr>
<tr><td>2</td><td>BL</td><td>branch and link, stejné jako předchozí instrukce, ovšem původní hodnota PC se uloží do X30</td></tr>
<tr><td>3</td><td>BR</td><td>skok na adresu uloženou v&nbsp;registru s&nbsp;hintem, že se nejedná o výskok z&nbsp;podprogramu</td></tr>
<tr><td>4</td><td>RET</td><td>jako BR, ovšem s&nbsp;hintem, že se jedná o výskok z&nbsp;podprogramu</td></tr>
<tr><td>5</td><td>BRL</td><td>kombinace BR + BL, tj.&nbsp;skok na adresu uloženou v&nbsp;registru + původní PC do X30</td></tr>
</table>

<p>Nekonečnou smyčku lze realizovat příkazem <strong>B</strong> (program se
potom musí ukončit stiskem klávesy <strong>Ctrl+C</strong> nebo příkazem
<strong>kill</strong>):</p>

<pre>
<i># asmsyntax=as</i>
&nbsp;
<i># Nekonečná smyčka</i>
<i># v assembleru GNU as.</i>
<i>#</i>
<i># Autor: Pavel Tisnovsky</i>
&nbsp;
&nbsp;
&nbsp;
<i># Linux kernel system call table</i>
sys_exit=93
sys_write=64
&nbsp;
<i># List of syscalls for AArch64:</i>
<i># https://github.com/torvalds/linux/blob/master/include/uapi/asm-generic/unistd.h</i>
&nbsp;
&nbsp;
&nbsp;
<i>#-----------------------------------------------------------------------------</i>
.section .data
&nbsp;
message:
        .string "Diamons are forever!\n"
end_string:
&nbsp;
<i>#-----------------------------------------------------------------------------</i>
.section .bss
&nbsp;
&nbsp;
&nbsp;
<i>#-----------------------------------------------------------------------------</i>
.section .text
        .global _start          <i>// tento symbol ma byt dostupny i linkeru</i>
&nbsp;
_start:
&nbsp;
loop:
        mov  x8, #sys_write     <i>// cislo sycallu pro funkci "write"</i>
        mov  x0, #1             <i>// standardni vystup</i>
        ldr  x1, =message       <i>// adresa retezce, ktery se ma vytisknout</i>
        mov  x2, #(end_string-message)   <i>// pocet znaku, ktere se maji vytisknout</i>
        svc  0                  <i>// volani Linuxoveho kernelu</i>
&nbsp;
        b    loop               <i>// dokolecka dokola</i>
</pre>

<p>Dvě poznámky k&nbsp;ukázanému kódu:</p>

<ol>

<li>Zcela chybí volání služby jádra pro ukončení aplikace. To je logické,
protože do této části by se program nikdy nedostal.</li>

<li>Povšimněte si malého triku, jak lze vypočítat délku řetězce už v&nbsp;čase
překladu s&nbsp;využitím dvou návěští (<i>label</i>).</li>

</ol>



<p><a name="k15"></a></p>
<h2 id="k15">15. Podmíněné skoky</h2>

<p>Instrukční sada AArch64 je hned v&nbsp;několika ohledech odlišná od původní
32bitové RISCové instrukční sady ARM32 (či zkráceně pouze A32).  Zásadní a na
první pohled viditelná odlišnost spočívá v&nbsp;tom, že se zredukoval počet
těch strojových instrukcí, u nichž je možné použít podmínkové bity. Jen ve
stručnosti si připomeňme, že v&nbsp;instrukční sadě ARM32 jsou v&nbsp;každém
instrukčním slovu (každé má bez výjimky konstantní šířku třiceti dvou bitů)
rezervovány čtyři nejvyšší bity, v&nbsp;nichž je zapsán kód podmínky, při
jejímž splnění se instrukce provede. Díky této vlastnosti bylo možné
v&nbsp;mnoha algoritmech zredukovat počet podmíněných skoků, což je
v&nbsp;případě (dnes už nejenom) RISCových procesorů poměrně důležité.</p>

<a href="https://www.root.cz/obrazek/293042/"><img src="https://i.iinfo.cz/images/98/arm-32-instrukce-1-prev.png" class="image-293042" alt="&#160;" width="356" height="270" /></a>
<p><i>Obrázek 1: Formáty instrukčních slov u původní 32bitové architektury ARM.
Povšimněte si, že v&nbsp;každém instrukčním slovu jsou nejvyšší čtyři bity
vyhrazeny pro uložení kódu podmínky.</i></p>

<p>Všechny podmínky jsou vyhodnoceny na základě hodnoty jednoho či (častěji)
kombinací většího množství příznaků (<i>flags</i>). První sada podmínkových
kódů se používá pro provedení či naopak neprovedení instrukce na základě
hodnoty jednoho z&nbsp;příznakových bitů <strong>Z (zero)</strong>, <strong>V
(overflow)</strong> či <strong>N (negative)</strong>. Poslední podmínkový kód
z&nbsp;této skupiny má název <strong>AL</strong> (<i>Any/Always</i>) a značí,
že se instrukce provede v&nbsp;každém případě. Tento podmínkový kód se tudíž
většinou v&nbsp;assembleru ani nezapisuje, protože je považován za
implicitní:</p>

<table>
<tr><th>Kód</th><th>Přípona</th><th>Význam</th><th>Testovaná podmínka</th></tr>
<tr><td>0000</td><td>EQ</td><td>Z == 1</td><td>rovnost při porovnání či nulový výsledek poslední ALU operace</td></tr>
<tr><td>0001</td><td>NE</td><td>Z == 0</td><td>nerovnost při porovnání či nenulový výsledek poslední ALU operace</td></tr>
<tr><td>0100</td><td>MI</td><td>N == 1</td><td>výsledek je záporný</td></tr>
<tr><td>0101</td><td>PL</td><td>N == 0</td><td>výsledek je kladný či 0</td></tr>
<tr><td>0110</td><td>VS</td><td>V == 1</td><td>nastalo přetečení</td></tr>
<tr><td>0111</td><td>VC</td><td>V == 0</td><td>nenastalo přetečení</td></tr>
<tr><td>1110</td><td>AL</td><td>Any/Always</td><td>většinou se nezapisuje, implicitní podmínka</td></tr>
</table>

<p>Další čtyři podmínkové kódy se většinou používají při porovnávání dvou
celých hodnot bez znaménka (<i>unsigned integer</i>). V&nbsp;těchto případech
se testují stavy příznakových bitů <strong>C (carry)</strong> a <strong>Z
(zero)</strong>, přesněji řečeno kombinace těchto bitů:</p>

<table>
<tr><th>Kód </th><th>Přípona</th><th>Význam</th><th>Testovaná podmínka</th></tr>
<tr><td>0010</td><td>CS/HS</td><td>C == 1</td><td>&ge;</td></tr>
<tr><td>0011</td><td>CC/LO</td><td>C == 0</td><td>&lt;</td></tr>
<tr><td>1000</td><td>HI</td><td>C == 1 &amp; Z == 0</td><td>&gt;</td></tr>
<tr><td>1001</td><td>LS</td><td>C == 0 | Z == 1 </td><td>&le;</td></tr>
</table>

<p>Poslední čtyři podmínkové kódy se používají pro porovnávání hodnot se
znaménkem (signed). V&nbsp;těchto případech se namísto příznakových bitů
<strong>(C) carry</strong> a <strong>(Z) zero</strong> testují kombinace bitů
<strong>(N) negative</strong>, <strong>(V) overflow</strong> a <strong>(Z)
zero</strong>:</p>

<table>
<tr><th>Kód </th><th>Přípona</th><th>Význam</th><th>Testovaná podmínka</th></tr>
<tr><td>1010</td><td>GE</td><td>N == V</td><td>&ge;</td></tr>
<tr><td>1011</td><td>LT</td><td>N &ne; V </td><td>&lt;</td></tr>
<tr><td>1100</td><td>GT</td><td>Z = 0, N = V </td><td>&gt;</td></tr>
<tr><td>1101</td><td>LE</td><td>Z = 1, N &ne; V</td><td>&le;</td></tr>
</table>

<p>Procesory s&nbsp;architekturou AArch64 sice používají shodné podmínkové
bity, ty jsou ovšem použity jen v&nbsp;několika pečlivě vybraných instrukcích.
Příznak přetečení je, podobně jako u mnoha dalších typů procesorů, používán při
aritmetických operacích (ovšem ne implicitně &ndash; jen u instrukcí končících
na <strong>S</strong> &ndash; set) a testy podmínkových bitů lze provádět
především u podmíněných skoků, tj.&nbsp;u instrukcí, jejichž mnemotechnická
zkratka začíná znakem <strong>B</strong> od slova &bdquo;Branch&ldquo;.
Rozeznáváme následující typy nepodmíněných podmíněných skoků:</p>

<table>
<tr><th>#</th><th>Instrukce</th><th>Alternativní zápis</th></tr>
<tr><td>1</td><td>B</td><td>BAL</td></tr>
<tr><td>2</td><td>B.EQ</td><td>BEQ</td></tr>
<tr><td>3</td><td>B.NE</td><td>BNE</td></tr>
<tr><td>4</td><td>B.MI</td><td>BMI</td></tr>
<tr><td>5</td><td>B.PL</td><td>BPL</td></tr>
<tr><td>6</td><td>B.VS</td><td>BVS</td></tr>
<tr><td>7</td><td>B.VC</td><td>BVC</td></tr>
<tr><td>8</td><td>B.CS</td><td>BCS</td></tr>
<tr><td>9</td><td>B.CC</td><td>BCC</td></tr>
<tr><td>10</td><td>B.HI</td><td>BHI</td></tr>
<tr><td>11</td><td>B.LS</td><td>BLS</td></tr>
<tr><td>12</td><td>B.GE</td><td>BGE</td></tr>
<tr><td>13</td><td>B.LT</td><td>BLT</td></tr>
<tr><td>14</td><td>B.GT</td><td>BGT</td></tr>
<tr><td>15</td><td>B.LE</td><td>BLE</td></tr>
</table>

<p><div class="rs-tip-major">Poznámka: alternativní zápis je podporován
například GNU Assemblerem, většinou však můžete používat obě varianty
zápisu.</div></p>



<p><a name="k16"></a></p>
<h2 id="k16">16. Další varianty podmíněných skoků</h2>

<p>Další dva typy skoků jsou odvozeny od instrukcí, které známe
z&nbsp;instrukční sady Thumb. Dochází zde k&nbsp;porovnání vybraného pracovního
registru s&nbsp;nulou:</p>

<table>
<tr><th>#</th><th>Instrukce</th><th>Stručný popis</th></tr>
<tr><td>1</td><td>CBZ </td><td>Compare and Branch if Zero</td></tr>
<tr><td>2</td><td>CBNZ</td><td>Compare and Branch if Not Zero</td></tr>
</table>

<p>Existují ještě další dvě instrukce pro podmíněné skoky, které se jmenují
<strong>TBZ</strong> (<i>Test and Branch if Zero</i>) a <strong>TBNZ</strong>
(<i>Test and Branch if Not Zero</i>). Ty provádí test hodnoty vybraného bitu
registru na nulu:</p>

<table>
<tr><th>#</th><th>Instrukce</th><th>Stručný popis</th></tr>
<tr><td>1</td><td>TBZ </td><td>Test and Branch if Zero</td></tr>
<tr><td>2</td><td>TBNZ</td><td>Test and Branch if Not Zero</td></tr>
</table>

<p>Způsob zápisu těchto instrukcí je následující:</p>

<pre>
TBZ  Xn, #konstanta, návěští
TBZ  Wn, #konstanta, návěští
TBNZ Xn, #konstanta, návěští
TBNZ Wn, #konstanta, návěští
</pre>

<p>Konstanta má šířku pouze šest bitů, protože je v&nbsp;ní uložen index bitu
pracovního registru, který se testuje na nulu či jedničku (u registrů Wn by
stačilo jen pět bitů). V&nbsp;případě instrukce <strong>TBZ</strong> &ndash;
pokud je n-tý bit registru <strong>Xn/Wn</strong> nastavený na nulu, provede se
skok, v&nbsp;opačném případě se řízení přenese na další instrukci.
V&nbsp;případě instrukce <strong>TBNZ</strong> je bit testován na jedničku.
Vzhledem k&nbsp;tomu, že v&nbsp;instrukčním slovu je nutné kromě adresy cíle
(návěští) specifikovat i číslo pracovního registru a index bitu, je tento typ
skoku omezen na rozsah &pm;32kB, což by ovšem v&nbsp;praxi mělo být více než
dostačující (v&nbsp;opačném případě lze <strong>TBZ/TBNZ</strong> zkombinovat
s&nbsp;absolutním skokem <strong>B</strong>).</p>



<p><a name="k17"></a></p>
<h2 id="k17">17. Ukázka programové smyčky</h2>

<p>V&nbsp;dalším demonstračním příkladu jsou ukázány dvě nové vlastnosti.
Zejména se jedná a použití sekce/sektoru <strong>bss</strong>, v&nbsp;němž jsou
neinicializovaná data. Tato sekce není ve výsledném binárním programu plně
alokována, což znamená, že i když budete chtít v&nbsp;assembleru pracovat
s&nbsp;obrovskými poli, nebude se velikost binárního programu zvětšovat (tedy
například 1MB pole v&nbsp;<strong>bss</strong> nezpůsobí zvětšení binárního
souboru o 1MB):</p>

<pre>
<i># pocet opakovani znaku</i>
rep_count  = 40
&nbsp; 
.section .bss
        .lcomm buffer, rep_count     <i>// rezervace bufferu pro vystup</i>
</pre>

<p>A druhou vlastností, kterou si zde ukážeme, je programová smyčka založená na
podmíněném skoku. Nejprve je porovnána hodnota pracovního registru
<strong>x2</strong> s&nbsp;nulou (což je řešeno pseudoinstrukcí
<strong>CMP</strong>). Tím se nastaví (či nenastaví) příznak <strong>Z</strong>
(<i>zero</i>). A posléze následuje podmíněný skok na začátek smyčky ve chvíli,
kdy příznak ještě není nastaven:</p>

<pre>
        mov   w3, #'*'               <i>// zapisovany znak</i>
&nbsp;
<strong>loop</strong>:
        strb  w3, [x1]               <i>// zapis znaku do bufferu</i>
        add   x1, x1, #1             <i>// uprava ukazatele do bufferu</i>
        sub   x2, x2, #1             <i>// zmenseni pocitadla</i>
        cmp   x2, #0                 <i>// otestovani, zda jsme jiz nedosahli nuly</i>
        bne   <strong>loop</strong>                   <i>// pokud jsme se nedostali k nule, skok na zacatek smycky</i>
</pre>

<p>Tato smyčka vyplní oblast paměti alokované v&nbsp;<strong>bss</strong>
hvězdičkami, které jsou následně vypsány na standardní výstup:</p>

<pre>
        mov   x8, #sys_write         <i>// cislo syscallu pro funkci "write"</i>
        mov   x0, #std_output        <i>// standardni vystup</i>
        ldr   x1, =buffer            <i>// adresa retezce, ktery se ma vytisknout</i>
        mov   x2, #rep_count         <i>// pocet znaku, ktere se maji vytisknout</i>
        svc   0                      <i>// volani Linuxoveho kernelu</i>
</pre>

<p>Úplný tvar tohoto demonstračního příkladu vypadá následovně:</p>

<pre>
<i># asmsyntax=as</i>
&nbsp;
<i># Testovaci program naprogramovany v assembleru GNU as</i>
<i># - pocitana programova smycka</i>
<i># - uprava pro mikroprocesory s architekturou AArch64</i>
<i>#</i>
<i># Autor: Pavel Tisnovsky</i>
&nbsp;
&nbsp;
&nbsp;
<i># Linux kernel system call table</i>
sys_exit   = 93
sys_write  = 64
&nbsp;
<i># List of syscalls for AArch64:</i>
<i># https://github.com/torvalds/linux/blob/master/include/uapi/asm-generic/unistd.h</i>
&nbsp;
<i># Dalsi konstanty pouzite v programu - standardni streamy</i>
std_input  = 0
std_output = 1
&nbsp;
<i># pocet opakovani znaku</i>
rep_count  = 40
&nbsp;
&nbsp;
&nbsp;
<i>#-----------------------------------------------------------------------------</i>
.section .data
&nbsp;
&nbsp;
&nbsp;
<i>#-----------------------------------------------------------------------------</i>
.section .bss
        .lcomm buffer, rep_count     <i>// rezervace bufferu pro vystup</i>
&nbsp;
&nbsp;
&nbsp;
<i>#-----------------------------------------------------------------------------</i>
.section .text
        .global _start               <i>// tento symbol ma byt dostupny i linkeru</i>
&nbsp;
_start:
        ldr   x1, =buffer            <i>// zapis se bude provadet do tohoto bufferu</i>
        mov   x2, #rep_count         <i>// pocet opakovani znaku</i>
        mov   w3, #'*'               <i>// zapisovany znak</i>
loop:
        strb  w3, [x1]               <i>// zapis znaku do bufferu</i>
        add   x1, x1, #1             <i>// uprava ukazatele do bufferu</i>
        sub   x2, x2, #1             <i>// zmenseni pocitadla</i>
        cmp   x2, #0                 <i>// otestovani, zda jsme jiz nedosahli nuly</i>
        bne   loop                   <i>// pokud jsme se nedostali k nule, skok na zacatek smycky</i>
&nbsp;
        mov   x8, #sys_write         <i>// cislo syscallu pro funkci "write"</i>
        mov   x0, #std_output        <i>// standardni vystup</i>
        ldr   x1, =buffer            <i>// adresa retezce, ktery se ma vytisknout</i>
        mov   x2, #rep_count         <i>// pocet znaku, ktere se maji vytisknout</i>
        svc   0                      <i>// volani Linuxoveho kernelu</i>
&nbsp;
        mov   x8, #sys_exit          <i>// cislo sycallu pro funkci "exit"</i>
        mov   x0, #0                 <i>// exit code = 0</i>
        svc   0                      <i>// volani Linuxoveho kernelu</i>
</pre>



<p><a name="k18"></a></p>
<h2 id="k18">18. Obsah následujícího článku</h2>

<p>Programová smyčka v&nbsp;posledním demonstračním příkladu není ve
skutečnosti napsána příliš optimálně. V&nbsp;navazující části článku si tedy
ukážeme, jak tuto smyčku zapsat s&nbsp;využitím menšího počtu instrukcí a
taktéž s&nbsp;využitím dalších adresovacích režimů, které umožňují automaticky
zvýšit adresu (ukazatel) před či po provedení operace čtení/zápisu. Právě
takové optimalizace musí provádět i překladače, aby plně využily možností
nabízených architekturou AArch64.</p>



<p><a name="k19"></a></p>
<h2 id="k19">19. Předchozí články o architektuře AArch64</h2>

<p>S&nbsp;architekturou AArch64 jsme se již na stránkách Roota setkali, a to
konkrétně v&nbsp;následující pětici článků, z&nbsp;nichž dnes vycházíme:</p>

<ol>

<li>64bitové mikroprocesory s architekturou AArch64<br />
<a href="https://www.root.cz/clanky/64bitove-mikroprocesory-s-architekturou-aarch64/">https://www.root.cz/clanky/64bitove-mikroprocesory-s-architekturou-aarch64/</a>
</li>

<li>Instrukční sada AArch64<br />
<a href="https://www.root.cz/clanky/instrukcni-sada-aarch64/">https://www.root.cz/clanky/instrukcni-sada-aarch64/</a>
</li>

<li>Instrukční sada AArch64 (2.část)<br />
<a href="https://www.root.cz/clanky/instrukcni-sada-aarch64-2-cast/">https://www.root.cz/clanky/instrukcni-sada-aarch64-2-cast/</a>
</li>

<li>Tvorba a ladění programů v&nbsp;assembleru mikroprocesorů AArch64<br />
<a href="https://www.root.cz/clanky/tvorba-a-ladeni-programu-v-assembleru-mikroprocesoru-aarch64/">https://www.root.cz/clanky/tvorba-a-ladeni-programu-v-assembleru-mikroprocesoru-aarch64/</a>
</li>

<li>Instrukční sada AArch64: technologie NEON<br />
<a href="https://www.root.cz/clanky/instrukcni-sada-aarch64-technologie-neon/">https://www.root.cz/clanky/instrukcni-sada-aarch64-technologie-neon/</a>
</li>

</ol>



<p><a name="k20"></a></p>
<h2 id="k20">20. Odkazy na Internetu</h2>

<ol>

<li>Arm Architecture Reference Manual for A-profile architecture<br />
<a href="https://developer.arm.com/documentation/ddi0487/latest">https://developer.arm.com/documentation/ddi0487/latest</a>
</li>

<li>GNU Binutils<br />
<a href="https://sourceware.org/binutils/">https://sourceware.org/binutils/</a>
</li>

<li>Documentation for binutils 2.38<br />
<a href="https://sourceware.org/binutils/docs-2.38/">https://sourceware.org/binutils/docs-2.38/</a>
</li>

<li>AArch64 Instruction Set Architecture<br />
<a href="https://developer.arm.com/architectures/learn-the-architecture/aarch64-instruction-set-architecture/instruction-sets-in-the-arm-architecture">https://developer.arm.com/architectures/learn-the-architecture/aarch64-instruction-set-architecture/instruction-sets-in-the-arm-architecture</a>
</li>

<li>Arm Armv8-A A32/T32 Instruction Set Architecture<br />
<a href="https://developer.arm.com/documentation/ddi0597/2021-12/?lang=en">https://developer.arm.com/documentation/ddi0597/2021-12/?lang=en</a>
</li>

<li>Comparison of ARMv8-A cores<br />
<a href="https://en.wikipedia.org/wiki/Comparison_of_ARMv8-A_cores">https://en.wikipedia.org/wiki/Comparison_of_ARMv8-A_cores</a>
</li>

<li>Cortex-A32 Processor<br />
<a href="https://www.arm.com/products/processors/cortex-a/cortex-a32-processor.php">https://www.arm.com/products/processors/cortex-a/cortex-a32-processor.php</a>
</li>

<li>Cortex-A35 Processor<br />
<a href="https://www.arm.com/products/processors/cortex-a/cortex-a35-processor.php">https://www.arm.com/products/processors/cortex-a/cortex-a35-processor.php</a>
</li>

<li>Cortex-A53 Processor<br />
<a href="https://www.arm.com/products/processors/cortex-a/cortex-a53-processor.php">https://www.arm.com/products/processors/cortex-a/cortex-a53-processor.php</a>
</li>

<li>Cortex-A57 Processor<br />
<a href="https://www.arm.com/products/processors/cortex-a/cortex-a57-processor.php">https://www.arm.com/products/processors/cortex-a/cortex-a57-processor.php</a>
</li>

<li>Cortex-A72 Processor<br />
<a href="https://www.arm.com/products/processors/cortex-a/cortex-a72-processor.php">https://www.arm.com/products/processors/cortex-a/cortex-a72-processor.php</a>
</li>

<li>Cortex-A73 Processor<br />
<a href="https://www.arm.com/products/processors/cortex-a/cortex-a73-processor.php">https://www.arm.com/products/processors/cortex-a/cortex-a73-processor.php</a>
</li>

<li>Apple A7 (SoC založen na CPU Cyclone)<br />
<a href="https://en.wikipedia.org/wiki/Apple_A7">https://en.wikipedia.org/wiki/Apple_A7</a>
</li>

<li>System cally pro AArch64 na Linuxu<br />
<a href="https://github.com/torvalds/linux/blob/master/include/uapi/asm-generic/unistd.h">https://github.com/torvalds/linux/blob/master/include/uapi/asm-generic/unistd.h</a>
</li>

<li>Architectures/AArch64 (FedoraProject.org)<br />
<a href="https://fedoraproject.org/wiki/Architectures/AArch64">https://fedoraproject.org/wiki/Architectures/AArch64</a>
</li>

<li>SIG pro AArch64 (CentOS)<br />
<a href="https://wiki.centos.org/SpecialInterestGroup/AltArch/AArch64">https://wiki.centos.org/SpecialInterestGroup/AltArch/AArch64</a>
</li>

<li>The ARMv8 instruction sets<br />
<a href="http://infocenter.arm.com/help/index.jsp?topic=/com.arm.doc.den0024a/ch05s01.html">http://infocenter.arm.com/help/index.jsp?topic=/com.arm.doc.den0024a/ch05s01.html</a>
</li>

<li>A64 Instruction Set<br />
<a href="https://developer.arm.com/products/architecture/instruction-sets/a64-instruction-set">https://developer.arm.com/products/architecture/instruction-sets/a64-instruction-set</a>
</li>

<li>Switching between the instruction sets<br />
<a href="http://infocenter.arm.com/help/index.jsp?topic=/com.arm.doc.den0024a/ch05s01.html">http://infocenter.arm.com/help/index.jsp?topic=/com.arm.doc.den0024a/ch05s01.html</a>
</li>

<li>The A64 instruction set<br />
<a href="http://infocenter.arm.com/help/index.jsp?topic=/com.arm.doc.den0024a/ch05s01.html">http://infocenter.arm.com/help/index.jsp?topic=/com.arm.doc.den0024a/ch05s01.html</a>
</li>

<li>Introduction to ARMv8 64-bit Architecture<br />
<a href="https://quequero.org/2014/04/introduction-to-arm-architecture/">https://quequero.org/2014/04/introduction-to-arm-architecture/</a>
</li>

<li>MCU market turns to 32-bits and ARM<br />
<a href="http://www.eetimes.com/document.asp?doc_id=1280803">http://www.eetimes.com/document.asp?doc_id=1280803</a>
</li>

<li>Cortex-M0 Processor (ARM Holdings)<br />
<a href="http://www.arm.com/products/processors/cortex-m/cortex-m0.php">http://www.arm.com/products/processors/cortex-m/cortex-m0.php</a>
</li>

<li>Cortex-M0+ Processor (ARM Holdings)<br />
<a href="http://www.arm.com/products/processors/cortex-m/cortex-m0plus.php">http://www.arm.com/products/processors/cortex-m/cortex-m0plus.php</a>
</li>

<li>ARM Processors in a Mixed Signal World<br />
<a href="http://www.eeweb.com/blog/arm/arm-processors-in-a-mixed-signal-world">http://www.eeweb.com/blog/arm/arm-processors-in-a-mixed-signal-world</a>
</li>

<li>ARM Architecture (Wikipedia)<br />
<a href="https://en.wikipedia.org/wiki/ARM_architecture">https://en.wikipedia.org/wiki/ARM_architecture</a>
</li>

<li>DSP for Cortex-M<br />
<a href="https://developer.arm.com/technologies/dsp/dsp-for-cortex-m">https://developer.arm.com/technologies/dsp/dsp-for-cortex-m</a>
</li>

<li>Cortex-M processors in DSP applications? Why not?!<br />
<a href="https://community.arm.com/processors/b/blog/posts/cortex-m-processors-in-dsp-applications-why-not">https://community.arm.com/processors/b/blog/posts/cortex-m-processors-in-dsp-applications-why-not</a>
</li>

<li>White Paper - DSP capabilities of Cortex-M4 and Cortex-M7<br />
<a href="https://community.arm.com/processors/b/blog/posts/white-paper-dsp-capabilities-of-cortex-m4-and-cortex-m7">https://community.arm.com/processors/b/blog/posts/white-paper-dsp-capabilities-of-cortex-m4-and-cortex-m7</a>
</li>

<li>Q (number format)<br />
<a href="https://en.wikipedia.org/wiki/Q_%28number_format%29">https://en.wikipedia.org/wiki/Q_%28number_format%29</a>
</li>

<li>TriCore Architecture &amp; Core<br />
<a href="http://www.infineon.com/cms/en/product/microcontroller/32-bit-tricore-tm-microcontroller/tricore-tm-architecture-and-core/channel.html?channel=ff80808112ab681d0112ab6b73d40837">http://www.infineon.com/cms/en/product/microcontroller/32-bit-tricore-tm-microcontroller/tricore-tm-architecture-and-core/channel.html?channel=ff80808112ab681d0112ab6b73d40837</a>
</li>

<li>TriCoreTM V1.6 Instruction Set: 32-bit Unified Processor Core<br />
<a href="http://www.infineon.com/dgdl/tc_v131_instructionset_v138.pdf?fileId=db3a304412b407950112b409b6dd0352">http://www.infineon.com/dgdl/tc_v131_instructionset_v138.pdf?fileId=db3a304412b407950112b409b6dd0352</a>
</li>

<li>TriCore v2.2 C Compiler, Assembler, Linker Reference Manual<br />
<a href="http://tasking.com/support/tricore/tc_reference_guide_v2.2.pdf">http://tasking.com/support/tricore/tc_reference_guide_v2.2.pdf</a>
</li>

<li>Infineon TriCore (Wikipedia)<br />
<a href="https://en.wikipedia.org/wiki/Infineon_TriCore">https://en.wikipedia.org/wiki/Infineon_TriCore</a>
</li>

<li>C166®S V2 Architecture &amp; Core<br />
<a href="http://www.infineon.com/cms/en/product/microcontroller/16-bit-c166-microcontroller/c166-s-v2-architecture-and-core/channel.html?channel=db3a304312bef5660112c3011c7d01ae">http://www.infineon.com/cms/en/product/microcontroller/16-bit-c166-microcontroller/c166-s-v2-architecture-and-core/channel.html?channel=db3a304312bef5660112c3011c7d01ae</a>
</li>

<li>Comparing four 32-bit soft processor cores<br />
<a href="http://www.eetimes.com/author.asp?section_id=14&doc_id=1286116">http://www.eetimes.com/author.asp?section_id=14&doc_id=1286116</a>
</li>

<li>RISC-V Instruction Set<br />
<a href="http://riscv.org/download.html#spec_compressed_isa">http://riscv.org/download.html#spec_compressed_isa</a>
</li>

<li>RISC-V Spike (ISA Simulator)<br />
<a href="http://riscv.org/download.html#isa-sim">http://riscv.org/download.html#isa-sim</a>
</li>

<li>RISC-V (Wikipedia)<br />
<a href="https://en.wikipedia.org/wiki/RISC-V">https://en.wikipedia.org/wiki/RISC-V</a>
</li>

<li>David Patterson (Wikipedia)<br />
<a href="https://en.wikipedia.org/wiki/David_Patterson_(computer_scientist)">https://en.wikipedia.org/wiki/David_Patterson_(computer_scientist)</a>
</li>

<li>OpenRISC (oficiální stránky projektu)<br />
<a href="http://openrisc.io/">http://openrisc.io/</a>
</li>

<li>OpenRISC architecture<br />
<a href="http://openrisc.io/architecture.html">http://openrisc.io/architecture.html</a>
</li>

<li>Emulátor OpenRISC CPU v JavaScriptu<br />
<a href="http://s-macke.github.io/jor1k/demos/main.html">http://s-macke.github.io/jor1k/demos/main.html</a>
</li>

<li>OpenRISC (Wikipedia)<br />
<a href="https://en.wikipedia.org/wiki/OpenRISC">https://en.wikipedia.org/wiki/OpenRISC</a>
</li>

<li>OpenRISC - instrukce<br />
<a href="http://sourceware.org/cgen/gen-doc/openrisc-insn.html">http://sourceware.org/cgen/gen-doc/openrisc-insn.html</a>
</li>

<li>OpenRISC - slajdy z přednášky o projektu<br />
<a href="https://iis.ee.ethz.ch/~gmichi/asocd/lecturenotes/Lecture6.pdf">https://iis.ee.ethz.ch/~gmichi/asocd/lecturenotes/Lecture6.pdf</a>
</li>

<li>Berkeley RISC<br />
<a href="http://en.wikipedia.org/wiki/Berkeley_RISC">http://en.wikipedia.org/wiki/Berkeley_RISC</a>
</li>

<li>Great moments in microprocessor history<br />
<a href="http://www.ibm.com/developerworks/library/pa-microhist.html">http://www.ibm.com/developerworks/library/pa-microhist.html</a>
</li>

<li>Microprogram-Based Processors<br />
<a href="http://research.microsoft.com/en-us/um/people/gbell/Computer_Structures_Principles_and_Examples/csp0167.htm">http://research.microsoft.com/en-us/um/people/gbell/Computer_Structures_Principles_and_Examples/csp0167.htm</a>
</li>

<li>Great Microprocessors of the Past and Present<br />
<a href="http://www.cpushack.com/CPU/cpu1.html">http://www.cpushack.com/CPU/cpu1.html</a>
</li>

<li>A Brief History of Microprogramming<br />
<a href="http://www.cs.clemson.edu/~mark/uprog.html">http://www.cs.clemson.edu/~mark/uprog.html</a>
</li>

<li>What is RISC?<br />
<a href="http://www-cs-faculty.stanford.edu/~eroberts/courses/soco/projects/2000-01/risc/whatis/">http://www-cs-faculty.stanford.edu/~eroberts/courses/soco/projects/2000-01/risc/whatis/</a>
</li>

<li>RISC vs. CISC<br />
<a href="http://www-cs-faculty.stanford.edu/~eroberts/courses/soco/projects/2000-01/risc/risccisc/">http://www-cs-faculty.stanford.edu/~eroberts/courses/soco/projects/2000-01/risc/risccisc/</a>
</li>

<li>RISC and CISC definitions:<br />
<a href="http://www.cpushack.com/CPU/cpuAppendA.html">http://www.cpushack.com/CPU/cpuAppendA.html</a>
</li>

<li>FPGA<br />
<a href="https://cs.wikipedia.org/wiki/Programovateln%C3%A9_hradlov%C3%A9_pole">https://cs.wikipedia.org/wiki/Programovateln%C3%A9_hradlov%C3%A9_pole</a>
</li>

<li>The Evolution of RISC<br />
<a href="http://www.ibm.com/developerworks/library/pa-microhist.html#sidebar1">http://www.ibm.com/developerworks/library/pa-microhist.html#sidebar1</a>
</li>

<li>disasm.pro<br />
<a href="https://disasm.pro/">https://disasm.pro/</a>
</li>

<li>Exploring AArch64 assembler &ndash; Chapter 5<br />
<a href="https://thinkingeek.com/2016/11/13/exploring-aarch64-assembler-chapter-5/">https://thinkingeek.com/2016/11/13/exploring-aarch64-assembler-chapter-5/</a>
</li>

</ol>



<p></p><p></p>
<p><small>Autor: <a href="http://www.fit.vutbr.cz/~tisnovpa">Pavel Tišnovský</a> &nbsp; 2022</small></p>
</body>
</html>

<!--
    06:00 - 07:00       51000
    07:00 - 08:00       52000
    08:00 - 09:00       53000
    09:00 - 10:00       54000
    11:00 - 11:00       55000
    11:00 - 12:00       56000
    12:00 - 13:00       57000
    13:00 - 14:00       58000
    14:00 - 15:00       59000
    15:00 - 16:00       60000
    -->
