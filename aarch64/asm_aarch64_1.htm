<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
        "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html>
<head>
<title>Specifické vlastnosti procesorů AArch64: úvod</title>
<meta name="Author" content="Pavel Tisnovsky" />
<meta name="Generator" content="vim" />
<meta http-equiv="content-type" content="text/html; charset=utf-8" />
<style type="text/css">
         body {color:#000000; background:#ffffff;}
         h1  {font-family: arial, helvetica, sans-serif; color:#ffffff; background-color:#c00000; text-align:center; padding-left:1em}
         h2  {font-family: arial, helvetica, sans-serif; color:#ffffff; background-color:#0000c0; padding-left:1em; text-align:left}
         h3  {font-family: arial, helvetica, sans-serif; color:#000000; background-color:#c0c0c0; padding-left:1em; text-align:left}
         h4  {font-family: arial, helvetica, sans-serif; color:#000000; background-color:#e0e0e0; padding-left:1em; text-align:left}
         a   {font-family: arial, helvetica, sans-serif;}
         li  {font-family: arial, helvetica, sans-serif; color:#000000; text-align:justify; width:450px;}
         ol  {font-family: arial, helvetica, sans-serif; color:#000000; text-align:justify; width:450px;}
         ul  {font-family: arial, helvetica, sans-serif; color:#000000; text-align:justify; width:450px;}
         p   {font-family: arial, helvetica, sans-serif; color:#000000; text-align:justify;}
         pre {background:#e0e0e0}
</style>
</head>

<body>

<h1>Specifické vlastnosti procesorů AArch64: úvod</h1>

<h3>Pavel Tišnovský</h3>

<p></p>

<h1>Úvodník</h1>

<p>Instrukční sada procesorů s architekturou AArch64 má některé zajímavé vlastnosti, s nimiž se můžeme postupně seznámit s využitím těch nejzákladnějších nástrojů - assembleru, linkeru a v pozdějších fázích i debuggeru. Dnes si ukážeme několik plně funkčních příkladů založených na několika základních instrukcích.</p>



<h2>Obsah</h2>

<p><a href="#k01">1. Specifické vlastnosti procesorů AArch64: úvod</a></p>
<p><a href="#k02">2. Použitý počítač</a></p>
<p><a href="#k03">3. Instalace základních vývojářských nástrojů</a></p>
<p><a href="#k04">4. Sada pracovních registrů mikroprocesorů s&nbsp;architekturou AArch64</a></p>
<p><a href="#k05">5. Instrukce <strong>MOV</strong> a <strong>SVC</strong></a></p>
<p><a href="#k06">6. Nejjednodušší korektní program zapsaný v&nbsp;assembleru</a></p>
<p><a href="#k07">7. Kódování instrukcí <strong>MOV</strong> a <strong>SVC</strong> u architektury AArch64</a></p>
<p><a href="#k08">8. Instrukce typu Load-Store</a></p>
<p><a href="#k09">9. Program typu &bdquo;Hello, world!&ldquo; v&nbsp;assembleru</a></p>
<p><a href="#k10">10. Uložení adresy načítané instrukcí <strong>LDR</strong></a></p>
<p><a href="#k11">11. Zápis do datového segmentu</a></p>
<p><a href="#k12">12. Základní aritmetické instrukce</a></p>
<p><a href="#k13">13. Použití aritmetických instrukcí</a></p>
<p><a href="#k14">14. Nepodmíněné skoky a skoky do subrutiny (<i>branch with link</i>)</a></p>
<p><a href="#k15">15. Podmíněné skoky</a></p>
<p><a href="#k16">16. Další varianty podmíněných skoků</a></p>
<p><a href="#k17">17. Ukázka programové smyčky</a></p>
<p><a href="#k18">18. Obsah následujícího článku</a></p>
<p><a href="#k19">19. Předchozí články o architektuře AArch64</a></p>
<p><a href="#k20">20. Odkazy na Internetu</a></p>



<p><a name="k01"></a></p>
<h2 id="k01">1. Specifické vlastnosti procesorů AArch64: úvod</h2>

<p>Na <a href="#k19">předchozí (poněkud starší) pětici článků</a> o
architektuře AArch64 dnes navážeme. Ukážeme si, jakým způsobem se používají
základní instrukce z&nbsp;instrukční sady této velmi zajímavé architektury.
Prozatím si většinou vystačíme s&nbsp;assemblerem (a linkerem), protože pro
studijní účely je vhodné používat co nejjednodušší (resp.&nbsp;nejvíce
transparentní) nástroje. Ovšem od assembleru je jen relativně malý krok
k&nbsp;programům, které jsou zapsány v&nbsp;jazyku C, což je pochopitelně téma,
na které v&nbsp;navazujících článcích nezapomeneme.</p>

<p>Dnes se budeme zabývat jen těmi nejzákladnějšími instrukcemi, které ovšem
postačují pro tvorbu jednodušších prográmků:</p>

<ul>
<li>Přenosy dat instrukcí <strong>MOV</strong></li>
<li>Načtení dat instrukcí <strong>LDR</strong> (v&nbsp;mnoha obměnách)</li>
<li>Uložení dat instrukcí <strong>STR</strong> (taktéž v&nbsp;mnoha obměnách)</li>
<li>Součet a rozdíl realizovaný instrukcemi <strong>ADD</strong> a <strong>SUB</strong></li>
<li>Porovnání dvou hodnot pseudoinstrukcí <strong>CMP</strong></li>
<li>Nepodmíněný skok <strong>B</strong></li>
<li>Podmíněný skok <strong>B.podmínka</strong></li>
<li>Volání služby jádra instrukcí <strong>SVC</strong></li>
</ul>


<p><a name="k02"></a></p>
<h2 id="k02">2. Použitý počítač</h2>

<p>Otestování všech dále popsaných demonstračních příkladů bylo provedeno na
počítači osazeném poměrně výkonným mikroprocesorem s&nbsp;architekturou
AArch64. Bližší informace o použitém procesoru lze zjistit přímo
z&nbsp;příkazové řádky:</p>

<pre>
$ <strong>lscpu</strong>
</pre>

<p>S&nbsp;výsledkem:</p>

<pre>
&nbsp;
Architecture:                    aarch64
CPU op-mode(s):                  64-bit
Byte Order:                      Little Endian
CPU(s):                          4
On-line CPU(s) list:             0-3
Thread(s) per core:              1
Core(s) per socket:              4
Socket(s):                       1
NUMA node(s):                    1
Vendor ID:                       Cavium
Model:                           1
Model name:                      ThunderX2 99xx
Stepping:                        0x1
BogoMIPS:                        400.00
NUMA node0 CPU(s):               0-3
Vulnerability Itlb multihit:     Not affected
Vulnerability L1tf:              Not affected
Vulnerability Mds:               Not affected
Vulnerability Meltdown:          Not affected
Vulnerability Spec store bypass: Mitigation; Speculative Store Bypass disabled via prctl
Vulnerability Spectre v1:        Mitigation; __user pointer sanitization
Vulnerability Spectre v2:        Mitigation; Branch predictor hardening
Vulnerability Srbds:             Not affected
Vulnerability Tsx async abort:   Not affected
Flags:                           fp asimd evtstrm aes pmull sha1 sha2 crc32 atomics cpuid asimdrdm
</pre>

<pre>
# <strong>lscpu -a -e=socket,cpu,core,online</strong>
&nbsp;
SOCKET CPU CORE ONLINE
     0   0    0    yes
     0   1    1    yes
     0   2    2    yes
     0   3    3    yes
</pre>

<pre>
$ <strong>cat /proc/cpuinfo</strong>
</pre>

<pre>
processor       : 0
BogoMIPS        : 400.00
Features        : fp asimd evtstrm aes pmull sha1 sha2 crc32 atomics cpuid asimdrdm
CPU implementer : 0x43
CPU architecture: 8
CPU variant     : 0x1
CPU part        : 0x0af
CPU revision    : 1
&nbsp;
processor       : 1
BogoMIPS        : 400.00
Features        : fp asimd evtstrm aes pmull sha1 sha2 crc32 atomics cpuid asimdrdm
CPU implementer : 0x43
CPU architecture: 8
CPU variant     : 0x1
CPU part        : 0x0af
CPU revision    : 1
&nbsp;
processor       : 2
BogoMIPS        : 400.00
Features        : fp asimd evtstrm aes pmull sha1 sha2 crc32 atomics cpuid asimdrdm
CPU implementer : 0x43
CPU architecture: 8
CPU variant     : 0x1
CPU part        : 0x0af
CPU revision    : 1
&nbsp;
processor       : 3
BogoMIPS        : 400.00
Features        : fp asimd evtstrm aes pmull sha1 sha2 crc32 atomics cpuid asimdrdm
CPU implementer : 0x43
CPU architecture: 8
CPU variant     : 0x1
CPU part        : 0x0af
CPU revision    : 1
</pre>



<p><a name="k03"></a></p>
<h2 id="k03">3. Instalace základních vývojářských nástrojů</h2>

<p>V&nbsp;navazujících kapitolách si ukážeme několik demonstračních příkladů
naprogramovaných v&nbsp;assembleru, konkrétně s&nbsp;využitím syntaxe
podporované GNU Assemblerem. Budeme tedy potřebovat nainstalovat všechny
potřebné nástroje, což je minimálně překladač assembleru, disassembler a
linker. Všechny tyto nástroje (a mnohé další) jsou nabízeny v&nbsp;balíčku
<strong>binutils</strong> (který není &ndash; tedy s&nbsp;ohledem na dnešní
poměry &ndash; nijak velký). Na Fedoře/RHELu se instalace tohoto balíčku
provede standardním způsobem:</p>

<pre>
# <strong>dnf install binutils</strong>
</pre>

<p></p>

<pre>
Last metadata expiration check: 0:13:15 ago on Sat 19 Feb 2022 07:05:31 AM EST.
Dependencies resolved.
===============================================================================================================================================================
 Package                                  Architecture                       Version                                  Repository                          Size
===============================================================================================================================================================
Installing:
 binutils                                 aarch64                            2.35-18.fc33                             updates                            5.8 M
Installing dependencies:
 binutils-gold                            aarch64                            2.35-18.fc33                             updates                            937 k
&nbsp;
Transaction Summary
===============================================================================================================================================================
Install  2 Packages
&nbsp;
Total download size: 6.7 M
Installed size: 30 M
Is this ok [y/N]: y
</pre>

<p>Seznam nástrojů, které se skutečně z&nbsp;tohoto balíčku nainstalovaly,
můžeme získat například takto:</p>

<pre>
$ <strong>dnf repoquery -l binutils | grep "/usr/bin" | sort |uniq</strong>
&nbsp;
/usr/bin/addr2line
/usr/bin/ar
/usr/bin/as
/usr/bin/c++filt
/usr/bin/dwp
/usr/bin/elfedit
/usr/bin/gprof
/usr/bin/ld
/usr/bin/ld.bfd
/usr/bin/nm
/usr/bin/objcopy
/usr/bin/objdump
/usr/bin/ranlib
/usr/bin/readelf
/usr/bin/size
/usr/bin/strings
/usr/bin/strip
</pre>

<p><div class="rs-tip-major">Poznámka: v&nbsp;rámci instalace se vytvořily i
manuálové stránky pro všechny výše vypsané nástroje. Z&nbsp;nich nás dnes budou
zajímat především <strong>as</strong>, <strong>ld</strong>,
<strong>objcopy</strong>, <strong>strings</strong> a
<strong>strip</strong>.</div></p>



<p><a name="k04"></a></p>
<h2 id="k04">4. Sada pracovních registrů mikroprocesorů s&nbsp;architekturou AArch64</h2>

<p>V&nbsp;navazujících kapitolách si ukážeme několik (prozatím) velmi
jednoduchých programů vytvořených v&nbsp;assembleru <i>GAS</i> pro
mikroprocesory s&nbsp;architekturou AArch64. Ovšem aby bylo zřejmé, jak jsou
tyto programy strukturovány, je nutné znát alespoň minimální informace o
pracovních registrech, speciálních registrech i o instrukční sadě AArch64.
Začněme tedy zmínkou o pracovních registrech a speciálních registrech, protože
mj.&nbsp;i v&nbsp;tomto ohledu se AArch64 odlišuje od původní 32bitové
architektury mikroprocesorů ARM.</p>

<p>Původních patnáct pracovních registrů pojmenovaných <strong>R0</strong> až
<strong>R14</strong>, které známe z&nbsp;dnes již klasických 32bitových
procesorů ARM, bylo rozšířeno na celkem 31 registrů, z&nbsp;nichž každý má nyní
šířku 64 bitů. Z&nbsp;tohoto důvodu muselo dojít k&nbsp;úpravě pojmenování
registrů způsobem, který je naznačený v&nbsp;následující tabulce a který
ostatně uvidíme i v&nbsp;dále uvedených demonstračních příkladech:</p>

<table>
<tr><th>Jméno</th><th>Význam</th></tr>
<tr><td>r0..r30</td><td>použito například v&nbsp;dokumentaci, popisu ABI atd.</td></tr>
<tr><td>x0..x30</td><td>celý 64bitový registr použitý jako zdroj či cíl pro prováděné operace</td></tr>
<tr><td>w0..w30</td><td>spodních 32 bitů registru (horních 32 bitů výsledku je buď vynulováno nebo znaménkově rozšířeno)</td></tr>
</table>

<p>Všechny tyto pracovní registry přitom mají v&nbsp;instrukční sadě stejné
postavení, na rozdíl od instrukční sady Thumb (přesněji dnes T32), v&nbsp;níž
se pro některé instrukce může použít jen spodních osm registrů. Ostatně nemělo
by se jednat o žádné překvapení, protože v&nbsp;&bdquo;pravých&ldquo; RISCových
procesorech je zvykem používat všechny pracovní registry shodným způsobem a
nerozlišovat například akumulátory, indexové registry, ukazatele na bázovou
adresu na zásobníku, čítače programových smyček atd.</p>

<p>Další sada pracovních registrů je používána při operacích s&nbsp;datovými
typy <i>single/float</i> a <i>double</i> (tedy s&nbsp;operandy reprezentovanými
v&nbsp;systému plovoucí řádové čárky), u SIMD operací a taktéž kryptografickým
modulem, o němž se blíže zmíníme v&nbsp;samostatném článku:</p>

<table>
<tr><th>Jméno</th><th>Význam</th></tr>
<tr><td>v0..v31</td><td>128bitové registry</td></tr>
<tr><td>d0..d31</td><td>spodních 64 bitů registrů v0..v31, použito pro hodnoty typu <i>double</i></td></tr>
<tr><td>s0..s31</td><td>spodních 32 bitů registrů v0..v31, použito pro hodnoty typu <i>single/float</i></td></tr>
</table>

<p>Pro SIMD operace, tj.&nbsp;operace pracující s&nbsp;vektory, se registry
<strong>vn</strong> rozdělují takto:</p>

<table>
<tr><th>Tvar (shape)</th><th>Celkem</th><th>Pojmenování v&nbsp;assembleru</th></tr>
<tr><td>8b&times;8</td><td>64b</td><td>Vn.8B</td></tr>
<tr><td>8b&times;16</td><td>128b</td><td>Vn.16B</td></tr>
<tr><td>16b&times;4</td><td>64b</td><td>Vn.4H</td></tr>
<tr><td>16b&times;8</td><td>128b</td><td>Vn.8H</td></tr>
<tr><td>32b&times;2</td><td>64b</td><td>Vn.2S</td></tr>
<tr><td>32b&times;4</td><td>128b</td><td>Vn.4S</td></tr>
<tr><td>64b&times;1</td><td>64b</td><td>Vn.1D</td></tr>
<tr><td>64b&times;2</td><td>128b</td><td>Vn.2D</td></tr>
</table>

<p>Povšimněte si, že &ndash; na rozdíl od mnoha jiných mikroprocesorových
architektur &ndash; nedochází k&nbsp;tomu, že by se například dva <i>single</i>
registry mapovaly do jednoho <i>double</i> registru atd.</p>

<p>Mezi speciální registry patří především:</p>

<table>
<tr><th>Jméno</th><th>Význam zkratky</th></tr>
<tr><td>SCTLR_ELn</td><td>System Control Register</td></tr>
<tr><td>ACTLR_ELn</td><td>Auxiliary Control Register</td></tr>
<tr><td>SCR_EL3</td><td>Secure Configuration Register</td></tr>
<tr><td>HCR_EL2</td><td>Hypervisor Configuration Register</td></tr>
<tr><td>MIDR_EL1</td><td>Main ID Register</td></tr>
<tr><td>MPIDR_EL1</td><td>Multiprocessor Affinity Register</td></tr>
</table>
 
<p>Význam těchto registrů bude popsán v&nbsp;navazujících článcích.</p>

<p>V&nbsp;pořadí třicátý druhý pracovní registr, tj.&nbsp;registr se jménem
<strong>x31</strong> či <strong>w31</strong>, není ve skutečnosti běžným
pracovním registrem, protože má dva speciální významy. V&nbsp;případě použití
tohoto registru v&nbsp;aritmetických či logických instrukcích se při použití ve
funkci vstupního operandu tento registr chová jako konstantní nula a při
použití ve funkci operandu výstupního jako /dev/null (výsledek se zahodí a
neovlivní skutečnou hodnotu uloženou do registru). Proto se v&nbsp;assembleru
může pro pojmenování tohoto registru použít jméno <strong>xzr</strong> či
<strong>wzr</strong> (<i>extended zero register</i>, <i>working zero
register</i>). U instrukcí pracujících se zásobníkem se tento registr chová
jako ukazatel na vrchol zásobníku a proto se pro něj v&nbsp;assembleru používá
jméno <strong>rsp</strong> či jen <strong>SP</strong> (na velikosti písmen u
jmen registrů samozřejmě nezáleží).</p>

<p><div class="rs-tip-major">Poznámka: s&nbsp;&bdquo;nulovým&ldquo; registrem
se setkáme i v&nbsp;dalších RISCových architekturách. Jeho existence velmi
často vede ke zjednodušení instrukční sady, dekodéru instrukcí i vlastního
mikroprocesoru.</div></p>

<p>Některé registry mají i další funkce:</p>

<ol>
<li>Registr <strong>x30</strong> se používá ve funkci <strong>LR</strong> (<i>Link Register</i>).</li>
<li>Registr <strong>PC</strong> není přímo dostupný. Toto je jeden z&nbsp;největších viditelných rozdílů mezi ARM 32 a AArch64.</li>
</ol>



<p><a name="k05"></a></p>
<h2 id="k05">5. Instrukce <strong>MOV</strong> a <strong>SVC</strong></h2>

<p>V&nbsp;demonstračním příkladu, který bude ukázán <a href="#k06">v&nbsp;další
kapitole</a>, si vystačíme s&nbsp;pouhými dvěma typy instrukcí. Jedná se o
instrukci nazvanou <strong>MOV</strong> a o instrukci pojmenovanou
<strong>SVC</strong>. Instrukce <strong>MOV</strong> slouží k&nbsp;přesunu dat
mezi pracovními registry i pro načtení konstanty do registru. Ve skutečnosti
existuje větší množství variant instrukce <strong>MOV</strong>, přičemž nás
bude konkrétně zajímat varianta, která dokáže do zvoleného pracovního registru
uložit konstantu. V&nbsp;assembleru je registr, do něhož se konstanta ukládá,
použit jako první operand, za nímž následuje vlastní konstanta zapisovaná
s&nbsp;křížkem na začátku (to aby se odlišila konstanta od adresy):</p>

<pre>
<i># Linux kernel system call table</i>
sys_exit=93
&nbsp;
mov  x8, #sys_exit      <i>// cislo sycallu pro funkci "exit"</i>
mov  x0, #0             <i>// exit code = 0</i>
</pre>

<p><div class="rs-tip-major">Poznámka: GNU assembler rozeznává instrukci
<strong>MOV</strong>, ovšem ve skutečnosti se jedná o pseudoinstrukci, zde
konkrétně o alias instrukce <strong>MOVI</strong>.</div></p>

<p>Název instrukce <strong>SVC</strong> vznikl ze sousloví <i>SuperVisor
Call</i> a (minimálně na Linuxu) slouží k&nbsp;volání služeb jádra. Tato
instrukce má jeden operand určující typ volání. Opět se podívejme na způsob
zápisu této funkce v&nbsp;assembleru::</p>

<pre>
svc  0                  <i>// volani Linuxoveho kernelu</i>
</pre>



<p><a name="k06"></a></p>
<h2 id="k06">6. Nejjednodušší korektní program zapsaný v&nbsp;assembleru</h2>

<p>Podívejme se nyní, jak by mohl vypadat program (pravděpodobně dokonce
nejjednodušší funkční program vůbec), který po svém spuštění pouze zavolá
službu jádra nazvanou <strong>exit</strong>, která program ukončí a předá
volajícímu (rodičovskému) procesu návratový kód. Celý program obsahuje pouze
tři instrukce, přičemž první instrukce slouží pro naplnění registru
obsahujícího číslo služby jádra (liší se podle použité architektury!), druhá
instrukce naplní registr s&nbsp;návratovým kódem a třetí instrukce skutečně
zavolá jádro, které vykoná zvolenou službu.</p>

<p>V&nbsp;GNU assembleru lze takový program zapsat následovně (jedná se o
šablonu, takže obsahuje i nepotřebné bloky):</p>

<pre>
<i># asmsyntax=as</i>
&nbsp;
<i># Sablona pro zdrojovy kod Linuxoveho programu naprogramovaneho</i>
<i># v assembleru GNU AS pro architekturu AArch64.</i>
<i>#</i>
<i># Autor: Pavel Tisnovsky</i>
&nbsp;
&nbsp;
&nbsp;
<i># Linux kernel system call table</i>
sys_exit=93
&nbsp;
<i># List of syscalls for AArch64:</i>
<i># https://github.com/torvalds/linux/blob/master/include/uapi/asm-generic/unistd.h</i>
&nbsp;
&nbsp;
&nbsp;
<i>#-----------------------------------------------------------------------------</i>
.section .data
&nbsp;
&nbsp;
&nbsp;
<i>#-----------------------------------------------------------------------------</i>
.section .bss
&nbsp;
&nbsp;
&nbsp;
<i>#-----------------------------------------------------------------------------</i>
.section .text
        .global _start          <i>// tento symbol ma byt dostupny i z linkeru</i>
&nbsp;
_start:
        mov  x8, #sys_exit      <i>// cislo sycallu pro funkci "exit"</i>
        mov  x0, #0             <i>// exit code = 0</i>
        svc  0                  <i>// volani Linuxoveho kernelu</i>
</pre>

<p>Překlad tohoto demonstračního příkladu a jeho slinkování se provede
standardním způsobem, tedy s&nbsp;použitím nástrojů <strong>as</strong> (GNU
Assembler &ndash; GAS) a <strong>ld</strong> (GNU Linker), které byly
nainstalovány v&nbsp;rámci úvodních kapitol:</p>

<pre>
$ <strong>as aarch64.s -o aarch64.o</strong>
$ <strong>ld -s aarch64.o</strong>
</pre>

<p>Výsledkem bude soubor nazvaný <strong>a.out</strong>, který je možné
spustit:</p>

<pre>
$ <strong>./a.out</strong>
</pre>

<p>Program by měl okamžitě skončit, a to bez chyby nebo pádu.</p>

<p>Zastavme se na chvíli u významu obsahu registru <strong>x0</strong>. Při
volání funkce jádra <strong>exit</strong> obsahuje tento registr hodnotu,
kterou proces vrátí do volajícího procesu, typicky do shellu. Můžeme si to
snadno otestovat nepatrnou úpravou našeho programu:</p>

<pre>
.section .text
        .global _start          <i>// tento symbol ma byt dostupny i z linkeru</i>
&nbsp;
_start:
        mov  x8, #sys_exit      <i>// cislo sycallu pro funkci "exit"</i>
        mov  x0, #42
        svc  0                  <i>// volani Linuxoveho kernelu</i>
</pre>

<p>Překlad a otestování nové varianty:</p>

<pre>
$ <strong>as aarch64.s -o aarch64.o</strong>
$ <strong>ld -s aarch64.o</strong>
$ <strong>./a.out</strong>
$ <strong>echo $?</strong>
42
</pre>

<p>Vidíme, že se skutečně vrátila hodnota 42.</p>

<p><div class="rs-tip-major">Poznámka: jen pro porovnání se můžeme podívat na
variantu určenou pro architekturu x86, v&nbsp;níž jsou použita odlišná čísla
služeb jádra, pro volání jádra se používá instrukce <strong>int</strong> a liší
se mj.&nbsp;i značení a pořadí operandů u instrukcí:</div></p>

<pre>
<i># Linux kernel system call table</i>
sys_exit=1
&nbsp;
<i>#-----------------------------------------------------------------------------</i>
.section .data
&nbsp;
<i>#-----------------------------------------------------------------------------</i>
.section .bss
<i>#-----------------------------------------------------------------------------</i>
.section .text
        .global _start          <i># tento symbol ma byt dostupny i linkeru</i>
&nbsp;
_start:
        movl  $sys_exit,%eax    <i># cislo sycallu pro funkci "exit"</i>
        movl  $0,%ebx           <i># exit code = 0</i>
        int   $0x80             <i># volani Linuxoveho kernelu</i>
</pre>



<p><a name="k07"></a></p>
<h2 id="k07">7. Kódování instrukcí <strong>MOV</strong> a <strong>SVC</strong> u architektury AArch64</h2>

<p>U architektury AArch64 se používají instrukce o pevné délce čtyři bajty, což
má mj.&nbsp;i dalekosáhlé praktické důsledky &ndash; načítání konstant, rozsah
cílů skoků atd. (na druhou stranu se zjednodušil a urychlil dekodér instrukcí).
Bude tedy zajímavé zjistit, jakým způsobem se vlastně přeložila naše trojice
instrukcí. Pro tento účel použijeme nástroj <strong>objdump</strong>, jenž byl
nainstalován v&nbsp;rámci úvodních kapitol v&nbsp;balíčku <i>binutils</i>:</p>

<pre>
$ <strong>objdump -f -d -t -h a.out</strong>
</pre>

<p>Takto volaný příkaz nejprve zobrazí základní informace o obsahu souboru,
následně jednotlivé sekce (segmenty), dále tabulku symbolů (ta je v&nbsp;našem
případě prázdná) a konečně i disassemblovaný kód nalezený v&nbsp;sekci/sektoru
nazvaném <strong>.text</strong> (taktéž se používá označení
<strong>code</strong>):</p>

<pre>
a.out:     file format elf64-littleaarch64
architecture: aarch64, flags 0x00000102:
EXEC_P, D_PAGED
start address 0x0000000000400078
&nbsp;
Sections:
Idx Name          Size      VMA               LMA               File off  Algn
  0 .text         0000000c  0000000000400078  0000000000400078  00000078  2**2
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
SYMBOL TABLE:
no symbols
&nbsp;
&nbsp;
&nbsp;
Disassembly of section .text:
&nbsp;
0000000000400078 &lt;.text&gt;:
  400078:       d2800ba8        mov     x8, #0x5d                       // #93
  40007c:       d2800000        mov     x0, #0x0                        // #0
  400080:       d4000001        svc     #0x0
</pre>

<p>Vidíme, že počáteční (startovní) adresa je rovna 0x0000000000400078, což je
posléze ve výpisu adres instrukcí zkracováno na 4000xx. Dále je ve druhém
sloupci u každé instrukce uvedena sekvence bajtů se zakódovanou instrukcí i se
zakódovanými operandy této instrukce. Z&nbsp;výpisu je patrné, že všechny
instrukce mají skutečně šířku čtyři bajty.</p>

<p>Podívejme se nyní na způsob zakódování instrukcí <strong>mov registr,
#konstanta</strong>. Tato instrukce je zakódována ve čtyřech bajtech, a to
včetně šestnáctibitové konstanty a čísla pracovního registru. To
mj.&nbsp;znamená, že instrukce:</p>

<pre>
mov x8, #0x5d
</pre>

<p>Je zakódována do této sekvence bajtů:</p>

<pre>
d2 80 0b a8
</pre>

<p>Binárně pak:</p>

<pre>
1 1 0 1 | 0 0 1 0 | 1 0 0 0 | 0 0 0 0 | 0 0 0 0 | 1 0 1 1 | 1 0 1 0 | 1 0 0 0
</pre>

<p>Instrukce <strong>MOV registr, #konstanta</strong> používá toto kódování:</p>

<pre>
| sf | 1 0 | 1 0 0 1 0 1 | hw | imm16 | Rd |
</pre>

<p>kde:</p>

<ul>
<li>sf = 0 pro 32bitovou operaci</li>
<li>sf = 1 pro 64bitovou operaci</li>
<li>hw = 00 (dva bity)</li>
<li>imm16 = 16bitová konstanta</li>
<li>Rd = číslo pracovního registru, do kterého se má konstanta uložit</li>
</ul>

<p>Zkusme tedy dosadit hodnoty pro instrukci:</p>

<pre>
mov x8, #0x5d
</pre>

<ul>
<li>sf = 1</li>
<li>imm16 = 0x5d (01011101)</li>
<li>Rd = 8 (01000)</li>
</ul>

<p>Binárně a hexadecimálně:</p>

<pre>
1 1 0 1 |0 0 1 0 | 1 0 0 0| 0 0 0 0 | 0 0 0 0 | 1 0 1 1 | 1 0 1 0 | 1 0 0 0
   d        2         8        0         0         b         a         8
</pre>

<p>Což plně odpovídá:</p>

<pre>
d2 80 0b a8
</pre>

<p>Instrukce <strong>SVC</strong> má tento formát:</p>

<pre>
| 1 1 0 1 0 1 0 0 0 0 0 | imm16 | 0 0 0 0 1 |
</pre>

<p>V&nbsp;našem konkrétním případě je 16bitová konstanta <strong>imm16</strong>
nastavena na nulu, takže:</p>

<pre>
| 1 1 0 1 | 0 1 0 0 | 0 0 0 0 | 0 0 0 0 | 0 0 0 0 | 0 0 0 0 | 0 0 0 0 | 0 0 0 1 |
     d         4         0         0         0         0         0         1
</pre>

<p><div class="rs-tip-major">Poznámka: celý instrukční soubor má teoreticky
2<sup>32</sup> instrukčních kódů (ne všechny jsou však obsazené). Vysvětlením
instrukce <strong>mov Rd, #konstanta</strong> jsme již pokryli minimálně
2<sup>16+5</sup>=2<sup>21</sup> ze všech možných kombinací.</div></p>



<p><a name="k08"></a></p>
<h2 id="k08">8. Instrukce typu Load-Store</h2>

<p>Jak je u RISCové architektury obvyklé, nalezneme v&nbsp;instrukční sadě i
několik instrukcí určených pro načítání dat z&nbsp;paměti do registrů a naopak
pro ukládání obsahu registrů do paměti. Navíc některé instrukce umožňují práci
nejenom s&nbsp;32bitovými a 64bitovými slovy, ale i s&nbsp;menšími bloky dat
&ndash; s&nbsp;bajty a šestnáctibitovými &bdquo;půlslovy&ldquo; (což je
důležité například při zpracování řetězců, obrázků, zvukových samplů atd.):</p>

<table>
<tr><th>#</th><th>Instrukce</th><th>Stručný popis</th></tr>
<tr><td>1</td><td>LDR</td><td>načtení 32bitového či 64bitového registru z&nbsp;paměti</td></tr>
<tr><td>2</td><td>LDRB</td><td>načtení bajtu a s&nbsp;rozšířením na slovo (doplňují se nuly)</td></tr>
<tr><td>3</td><td>LDRSB</td><td>načtení bajtu se znaménkovým rozšířením</td></tr>
<tr><td>4</td><td>LDRH</td><td>načtení šestnáctibitového &bdquo;půlslova&ldquo; s&nbsp;rozšířením o nuly</td></tr>
<tr><td>5</td><td>LDRSH</td><td>načtení šestnáctibitového &bdquo;půlslova&ldquo; se znaménkovým rozšířením</td></tr>
<tr><td>6</td><td>LDRSW</td><td>načtení 32bitového slova se znaménkovým rozšířením do 64bitového registru</td></tr>
<tr><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td></tr>
<tr><td>7</td><td>STR</td><td>uložení 32bitového či 64bitového registru do paměti</td></tr>
<tr><td>8</td><td>STRB</td><td>uložení bajtu z&nbsp;vybraného 32bitového registru</td></tr>
<tr><td>9</td><td>STRH</td><td>uložení šestnáctibitového &bdquo;půlslova&ldquo; z&nbsp;vybraného 32bitového registru</td></tr>
</table>

<p>Poznámka: zdánlivě chybějící instrukce <strong>LDRW</strong> a
<strong>STRW</strong> jsou již obsaženy v&nbsp;základních instrukcích
<strong>LDR</strong> a <strong>STR</strong> pokud použijeme 32bitový registr (u
<strong>LDR</strong> se horních 32 bitů vynuluje).</p>

<p>Mezi podporované adresovací režimy patří i použití offsetu vůči vybranému
registru či SP. Navíc je možné zajistit takzvaný <i>pre-index</i> a
<i>post-index</i>, tj.&nbsp;změnu obsahu registru obsahujícího adresu před či
po provedení operace LOAD/STORE. Toho lze využít například při práci
s&nbsp;poli nebo s&nbsp;řetězci:</p>

<pre>
ldr X1, [X2, #4]! <i>// X1 ← *(X2 + 4)</i>
                  <i>// X2 ← X2 + 4</i>
</pre>

<pre>
ldr X1, [X2], #4  <i>// X1 ← *X2</i>
                  <i>// X2 ← X2 + 4</i>
</pre>

<p><div class="rs-tip-major">Poznámka: právě tuto variantu instrukce
<strong>str</strong> (konkrétně <strong>strb</strong>) použijeme v&nbsp;dalším
textu.</div></p>



<p><a name="k09"></a></p>
<h2 id="k09">9. Program typu &bdquo;Hello, world!&ldquo; v&nbsp;assembleru</h2>

<p>Druhý demonstrační příklad, který si dnes ukážeme, je nepatrně složitější,
protože se jedná o aplikaci typu &bdquo;Hello, world!&ldquo;, v&nbsp;níž musíme
volat dvě funkce jádra &ndash; <strong>sys_write</strong> určenou pro zápis na
standardní výstup (to v&nbsp;našem případě &ndash; obecně se jedná o zápis
binárních dat do otevřeného kanálu) a <strong>sys_exit</strong> pro ukončení
aplikace. Způsob volání funkcí jádra s&nbsp;předáváním hodnot v&nbsp;pracovních
registrech by nás již neměl ničím překvapit. Nová je však instrukce
<strong>ldr</strong>, přesněji řečeno způsob určení adresy, která se má do
zvoleného pracovního registru načíst. Ke způsobu překladu této instrukce se
dostaneme v&nbsp;navazující kapitole. Další novinkou je definice dat
v&nbsp;sekci/segmentu <strong>data</strong>. Jedná se o řetězec, který se má
vypsat na terminál:</p>

<pre>
<i># asmsyntax=as</i>

<i># Jednoducha aplikace typu "Hello world!" naprogramovana</i>
<i># v assembleru GNU as.</i>
<i>#</i>
<i># Autor: Pavel Tisnovsky</i>



<i># Linux kernel system call table</i>
sys_exit=93
sys_write=64

<i># List of syscalls for AArch64:</i>
<i># https://github.com/torvalds/linux/blob/master/include/uapi/asm-generic/unistd.h</i>



#-----------------------------------------------------------------------------
.section .data

hello_lbl:
        .string "Hello World!\n"

#-----------------------------------------------------------------------------
.section .bss



#-----------------------------------------------------------------------------
.section .text
        .global _start          // tento symbol ma byt dostupny i linkeru

_start:
        mov  x8, #sys_write     // cislo sycallu pro funkci "write"
        mov  x0, #1             // standardni vystup
        ldr  x1, =hello_lbl     // adresa retezce, ktery se ma vytisknout
        mov  x2, #13            // pocet znaku, ktere se maji vytisknout
        svc  0                  // volani Linuxoveho kernelu

        mov  x8, #sys_exit      // cislo sycallu pro funkci "exit"
        mov  x0, #0             // exit code = 0
        svc  0                  // volani Linuxoveho kernelu
</pre>

<p><div class="rs-tip-major">Poznámka: povšimněte si, že systémová funkce
<strong>sys_write</strong> vyžaduje zadání tří parametrů: určení kanálu
(například otevřeného souboru), do kterého se budou data zapisovat, dále
počáteční adresu bloku dat a konečně počet zapisovaných bajtů. Jedná se tedy o
obecnou funkci, u které si musíme dát pozor na to, že nebere v&nbsp;úvahu
například způsoby ukončení standardních céčkovských řetězců.</div></p>



<p><a name="k10"></a></p>
<h2 id="k10">10. Uložení adresy načítané instrukcí <strong>LDR</strong></h2>

<p>Opět se podívejme na způsob překladu druhého demonstračního příkladu do
strojového kódu. Poznámky budou uvedeny pod výpisem zdrojového kódu:</p>

<pre>
$ <strong>objdump -f -d -t -h a.out</strong>
</pre>

<pre>
a.out:     file format elf64-littleaarch64
architecture: aarch64, flags 0x00000102:
EXEC_P, D_PAGED
start address 0x00000000004000b0

Sections:
Idx Name          Size      VMA               LMA               File off  Algn
  0 .text         00000028  00000000004000b0  00000000004000b0  000000b0  2**3
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  1 .data         0000000e  00000000004100d8  00000000004100d8  000000d8  2**0
                  CONTENTS, ALLOC, LOAD, DATA
SYMBOL TABLE:
no symbols



Disassembly of section .text:

00000000004000b0 &ld;.text&gt;:
  4000b0:       d2800808        mov     x8, #0x40                       // #64
  4000b4:       d2800020        mov     x0, #0x1                        // #1
  4000b8:       580000c1        ldr     x1, 0x4000d0
  4000bc:       d28001a2        mov     x2, #0xd                        // #13
  4000c0:       d4000001        svc     #0x0
  4000c4:       d2800ba8        mov     x8, #0x5d                       // #93
  4000c8:       d2800000        mov     x0, #0x0                        // #0
  4000cc:       d4000001        svc     #0x0
  4000d0:       004100d8        .inst   0x004100d8 ; undefined
  4000d4:       00000000        udf     #0
</pre>



<p><a name="k10"></a></p>
<h2 id="k10">10. </h2>



<p><a name="k11"></a></p>
<h2 id="k11">11. </h2>

<p>Potřetí se podívejme na informace o segmentech, z&nbsp;nichž se skládá
binární spustitelný soubor:</p>

<pre>
Sections:
Idx Name          Size      VMA               LMA               File off  Algn
  0 .text         00000028  00000000004000b0  00000000004000b0  000000b0  2**3
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  1 .data         <strong>0000000e</strong>  <strong>00000000004100d8</strong>  00000000004100d8  000000d8  2**0
                  CONTENTS, ALLOC, LOAD, DATA
</pre>

<p>Zajímavé je, že segment <strong>text</strong> je určen pouze pro čtení,
takže proces nemůže provádět žádné modifikace (tedy nelze vytvořit
automodifikující se kód, což je asi jen dobře). Naproti tomu segment
<strong>data</strong> je určen i pro zápis, o což se můžeme pokusit.
V&nbsp;programovém kódu nejprve změníme obsah řetězce, který se má vytisknout a
teprve poté řetězec vytiskneme. Abychom si neukazovali pouze
&bdquo;obyčejnou&ldquo; instrukci <strong>STRB</strong> (zápis bajtu),
použijeme adresování s&nbsp;offsetem. Jinými slovy &ndash; zapíšeme nový bajt
nikoli na začátek řetězce, ale na offsetu 5, a to bez výpočtu této adresy.
Samotný výpočet offsetu, tj.&nbsp;adresy složené z&nbsp;obsahu pracovního
registru <strong>x1</strong> s&nbsp;offsetem 5 je proveden za běhu:</p>

<pre>
# asmsyntax=as
 
# Testovaci program naprogramovany v assembleru GNU as
# - pocitana programova smycka
# - uprava pro mikroprocesory s architekturou AArch64
#
# Autor: Pavel Tisnovsky
 
 
 
# Linux kernel system call table
sys_exit   = 93
sys_write  = 64

# List of syscalls for AArch64:
# https://github.com/torvalds/linux/blob/master/include/uapi/asm-generic/unistd.h
 
# Dalsi konstanty pouzite v programu - standardni streamy
std_input  = 0
std_output = 1

# pocet opakovani znaku
rep_count  = 40
 
 
 
#-----------------------------------------------------------------------------
.section .data
 
 
 
#-----------------------------------------------------------------------------
.section .bss
        .lcomm buffer, rep_count     // rezervace bufferu pro vystup
 
 
 
#-----------------------------------------------------------------------------
.section .text
        .global _start               // tento symbol ma byt dostupny i linkeru
 
_start:
        ldr   x1, =buffer            // zapis se bude provadet do tohoto bufferu
        mov   x2, #rep_count         // pocet opakovani znaku
        mov   w3, #'*'               // zapisovany znak
loop:
        strb  w3, [x1]               // zapis znaku do bufferu
        add   x1, x1, #1             // uprava ukazatele do bufferu
        sub   x2, x2, #1             // zmenseni pocitadla
        cmp   x2, #0                 // otestovani, zda jsme jiz nedosahli nuly
        bne   loop                   // pokud jsme se nedostali k nule, skok na zacatek smycky
 
        mov   x8, #sys_write         // cislo syscallu pro funkci "write"
        mov   x0, #std_output        // standardni vystup
        ldr   x1, =buffer            // adresa retezce, ktery se ma vytisknout
        mov   x2, #rep_count         // pocet znaku, ktere se maji vytisknout
        svc   0                      // volani Linuxoveho kernelu
 
        mov   x8, #sys_exit          // cislo sycallu pro funkci "exit"
        mov   x0, #0                 // exit code = 0
        svc   0                      // volani Linuxoveho kernelu
</pre>



<p><a name="k13"></a></p>
<h2 id="k13">13. Použití aritmetických instrukcí</h2>

<p>Ukažme si nyní příklad použití základních aritmetických instrukcí součtu a
rozdílu. Nejdříve provedeme součet dvou hodnot. V&nbsp;RISCové instrukční sadě
je nutné nejdříve operandy načíst do pracovních registrů a teprve poté provést
příslušnou operaci. Aritmetické operace přitom používají takzvaný
<i>tříadresový kód</i>, protože se v&nbsp;instrukci uvádí jak oba vstupní
operandy, tak i registr, do kterého se provádí zápis (tj.&nbsp;takto je
obsazeno 3&times;5=15 bitů instrukčního slova):</p>

<pre>
$ objdump -f -d -t -h a.out
</pre>

<pre>
a.out:     file format elf64-littleaarch64
architecture: aarch64, flags 0x00000102:
EXEC_P, D_PAGED
start address 0x00000000004000b0

Sections:
Idx Name          Size      VMA               LMA               File off  Algn
  0 .text         00000048  00000000004000b0  00000000004000b0  000000b0  2**3
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  1 .bss          00000028  00000000004100f8  00000000004100f8  000000f8  2**3
                  ALLOC
SYMBOL TABLE:
no symbols



Disassembly of section .text:

00000000004000b0 <.text>:
  4000b0:       58000201        ldr     x1, 0x4000f0
  4000b4:       d2800502        mov     x2, #0x28                       // #40
  4000b8:       52800543        mov     w3, #0x2a                       // #42
  4000bc:       39000023        strb    w3, [x1]
  4000c0:       91000421        add     x1, x1, #0x1
  4000c4:       d1000442        sub     x2, x2, #0x1
  4000c8:       f100005f        cmp     x2, #0x0
  4000cc:       54ffff81        b.ne    0x4000bc  // b.any
  4000d0:       d2800808        mov     x8, #0x40                       // #64
  4000d4:       d2800020        mov     x0, #0x1                        // #1
  4000d8:       580000c1        ldr     x1, 0x4000f0
  4000dc:       d2800502        mov     x2, #0x28                       // #40
  4000e0:       d4000001        svc     #0x0
  4000e4:       d2800ba8        mov     x8, #0x5d                       // #93
  4000e8:       d2800000        mov     x0, #0x0                        // #0
  4000ec:       d4000001        svc     #0x0
  4000f0:       004100f8        .inst   0x004100f8 ; undefined
  4000f4:       00000000        udf     #0
</pre>



<p><a name="k14"></a></p>
<h2 id="k14">14. </h2>



<p><a name="k15"></a></p>
<h2 id="k15">15. </h2>

<pre>
# asmsyntax=as
 
# Testovaci program naprogramovany v assembleru GNU as
# - pocitana programova smycka
# - uprava pro mikroprocesory s architekturou AArch64
#
# Autor: Pavel Tisnovsky
 
 
 
# Linux kernel system call table
sys_exit   = 93
sys_write  = 64

# List of syscalls for AArch64:
# https://github.com/torvalds/linux/blob/master/include/uapi/asm-generic/unistd.h
 
# Dalsi konstanty pouzite v programu - standardni streamy
std_input  = 0
std_output = 1

# pocet opakovani znaku
rep_count  = 40
 
 
 
#-----------------------------------------------------------------------------
.section .data
 
 
 
#-----------------------------------------------------------------------------
.section .bss
        .lcomm buffer, rep_count     // rezervace bufferu pro vystup
 
 
 
#-----------------------------------------------------------------------------
.section .text
        .global _start               // tento symbol ma byt dostupny i linkeru
 
_start:
        ldr   x1, =buffer            // zapis se bude provadet do tohoto bufferu
        mov   x2, #rep_count         // pocet opakovani znaku
        mov   w3, #'*'               // zapisovany znak
loop:
        strb  w3, [x1]               // zapis znaku do bufferu
        add   x1, x1, #1             // uprava ukazatele do bufferu
        subs  x2, x2, #1             // zmenseni pocitadla a soucasne nastaveni priznaku
        bne   loop                   // pokud jsme se nedostali k nule, skok na zacatek smycky
 
        mov   x8, #sys_write         // cislo syscallu pro funkci "write"
        mov   x0, #std_output        // standardni vystup
        ldr   x1, =buffer            // adresa retezce, ktery se ma vytisknout
        mov   x2, #rep_count         // pocet znaku, ktere se maji vytisknout
        svc   0                      // volani Linuxoveho kernelu
 
        mov   x8, #sys_exit          // cislo sycallu pro funkci "exit"
        mov   x0, #0                 // exit code = 0
        svc   0                      // volani Linuxoveho kernelu

</pre>


<p><a name="k16"></a></p>
<h2 id="k16">16. </h2>



<p><a name="k17"></a></p>
<h2 id="k17">17. </h2>

<pre>
<i># pocet opakovani znaku</i>
rep_count  = 40
&nbsp; 
.section .bss
        .lcomm buffer, rep_count     <i>// rezervace bufferu pro vystup</i>
</pre>

<p>A druhou vlastností, kterou si zde ukážeme, je programová smyčka založená na
podmíněném skoku. Nejprve je porovnána hodnota pracovního registru
<strong>x2</strong> s&nbsp;nulou (což je řešeno pseudoinstrukcí
<strong>CMP</strong>). Tím se nastaví (či nenastaví) příznak <strong>Z</strong>
(<i>zero</i>). A posléze následuje podmíněný skok na začátek smyčky ve chvíli,
kdy příznak ještě není nastaven:</p>

<pre>
        mov   w3, #'*'               <i>// zapisovany znak</i>
&nbsp;
<strong>loop</strong>:
        strb  w3, [x1]               <i>// zapis znaku do bufferu</i>
        add   x1, x1, #1             <i>// uprava ukazatele do bufferu</i>
        sub   x2, x2, #1             <i>// zmenseni pocitadla</i>
        cmp   x2, #0                 <i>// otestovani, zda jsme jiz nedosahli nuly</i>
        bne   <strong>loop</strong>                   <i>// pokud jsme se nedostali k nule, skok na zacatek smycky</i>
</pre>

<p>Tato smyčka vyplní oblast paměti alokované v&nbsp;<strong>bss</strong>
hvězdičkami, které jsou následně vypsány na standardní výstup:</p>

<pre>
        mov   x8, #sys_write         <i>// cislo syscallu pro funkci "write"</i>
        mov   x0, #std_output        <i>// standardni vystup</i>
        ldr   x1, =buffer            <i>// adresa retezce, ktery se ma vytisknout</i>
        mov   x2, #rep_count         <i>// pocet znaku, ktere se maji vytisknout</i>
        svc   0                      <i>// volani Linuxoveho kernelu</i>
</pre>

<p>Úplný tvar tohoto demonstračního příkladu vypadá následovně:</p>

<pre>
<i># asmsyntax=as</i>
&nbsp;
<i># Testovaci program naprogramovany v assembleru GNU as</i>
<i># - pocitana programova smycka</i>
<i># - uprava pro mikroprocesory s architekturou AArch64</i>
<i>#</i>
<i># Autor: Pavel Tisnovsky</i>
&nbsp;
&nbsp;
&nbsp;
<i># Linux kernel system call table</i>
sys_exit   = 93
sys_write  = 64
&nbsp;
<i># List of syscalls for AArch64:</i>
<i># https://github.com/torvalds/linux/blob/master/include/uapi/asm-generic/unistd.h</i>
&nbsp;
<i># Dalsi konstanty pouzite v programu - standardni streamy</i>
std_input  = 0
std_output = 1

# pocet opakovani znaku
rep_count  = 40
&nbsp;
&nbsp;
&nbsp;
<i>#-----------------------------------------------------------------------------</i>
.section .data
&nbsp;
&nbsp;
&nbsp;
<i>#-----------------------------------------------------------------------------</i>
.section .bss
        .lcomm buffer, rep_count     <i>// rezervace bufferu pro vystup</i>
&nbsp;
&nbsp;
&nbsp;
<i>#-----------------------------------------------------------------------------</i>
.section .text
        .global _start               <i>// tento symbol ma byt dostupny i linkeru</i>
&nbsp;
_start:
        ldr   x1, =buffer            <i>// zapis se bude provadet do tohoto bufferu</i>
        mov   x2, #rep_count         <i>// pocet opakovani znaku</i>
        mov   w3, #'*'               <i>// zapisovany znak</i>
loop:
        strb  w3, [x1]               <i>// zapis znaku do bufferu</i>
        add   x1, x1, #1             <i>// uprava ukazatele do bufferu</i>
        sub   x2, x2, #1             <i>// zmenseni pocitadla</i>
        cmp   x2, #0                 <i>// otestovani, zda jsme jiz nedosahli nuly</i>
        bne   loop                   <i>// pokud jsme se nedostali k nule, skok na zacatek smycky</i>
&nbsp;
        mov   x8, #sys_write         <i>// cislo syscallu pro funkci "write"</i>
        mov   x0, #std_output        <i>// standardni vystup</i>
        ldr   x1, =buffer            <i>// adresa retezce, ktery se ma vytisknout</i>
        mov   x2, #rep_count         <i>// pocet znaku, ktere se maji vytisknout</i>
        svc   0                      <i>// volani Linuxoveho kernelu</i>
&nbsp;
        mov   x8, #sys_exit          <i>// cislo sycallu pro funkci "exit"</i>
        mov   x0, #0                 <i>// exit code = 0</i>
        svc   0                      <i>// volani Linuxoveho kernelu</i>
</pre>



<p><a name="k18"></a></p>
<h2 id="k18">18. Obsah následujícího článku</h2>

<p>Programová smyčka v&nbsp;posledním demonstračním příkladu není ve
skutečnosti napsána příliš optimálně. V&nbsp;navazující části článku si tedy
ukážeme, jak tuto smyčku zapsat s&nbsp;využitím menšího počtu instrukcí a
taktéž s&nbsp;využitím dalších adresovacích režimů, které umožňují automaticky
zvýšit adresu (ukazatel) před či po provedení operace čtení/zápisu. Právě
takové optimalizace musí provádět i překladače, aby plně využily možností
nabízených architekturou AArch64.</p>



<p><a name="k19"></a></p>
<h2 id="k19">19. Předchozí články o architektuře AArch64</h2>

<p>S&nbsp;architekturou AArch64 jsme se již na stránkách Roota setkali, a to
konkrétně v&nbsp;následující pětici článků, z&nbsp;nichž dnes vycházíme:</p>

<ol>

<li>64bitové mikroprocesory s architekturou AArch64<br />
<a href="https://www.root.cz/clanky/64bitove-mikroprocesory-s-architekturou-aarch64/">https://www.root.cz/clanky/64bitove-mikroprocesory-s-architekturou-aarch64/</a>
</li>

<li>Instrukční sada AArch64<br />
<a href="https://www.root.cz/clanky/instrukcni-sada-aarch64/">https://www.root.cz/clanky/instrukcni-sada-aarch64/</a>
</li>

<li>Instrukční sada AArch64 (2.část)<br />
<a href="https://www.root.cz/clanky/instrukcni-sada-aarch64-2-cast/">https://www.root.cz/clanky/instrukcni-sada-aarch64-2-cast/</a>
</li>

<li>Tvorba a ladění programů v&nbsp;assembleru mikroprocesorů AArch64<br />
<a href="https://www.root.cz/clanky/tvorba-a-ladeni-programu-v-assembleru-mikroprocesoru-aarch64/">https://www.root.cz/clanky/tvorba-a-ladeni-programu-v-assembleru-mikroprocesoru-aarch64/</a>
</li>

<li>Instrukční sada AArch64: technologie NEON<br />
<a href="https://www.root.cz/clanky/instrukcni-sada-aarch64-technologie-neon/">https://www.root.cz/clanky/instrukcni-sada-aarch64-technologie-neon/</a>
</li>

</ol>



<p><a name="k20"></a></p>
<h2 id="k20">20. Odkazy na Internetu</h2>

<ol>

<li>Arm Architecture Reference Manual for A-profile architecture<br />
<a href="https://developer.arm.com/documentation/ddi0487/latest">https://developer.arm.com/documentation/ddi0487/latest</a>
</li>

<li>GNU Binutils<br />
<a href="https://sourceware.org/binutils/">https://sourceware.org/binutils/</a>
</li>

<li>Documentation for binutils 2.38<br />
<a href="https://sourceware.org/binutils/docs-2.38/">https://sourceware.org/binutils/docs-2.38/</a>
</li>

<li>AArch64 Instruction Set Architecture<br />
<a href="https://developer.arm.com/architectures/learn-the-architecture/aarch64-instruction-set-architecture/instruction-sets-in-the-arm-architecture">https://developer.arm.com/architectures/learn-the-architecture/aarch64-instruction-set-architecture/instruction-sets-in-the-arm-architecture</a>
</li>

<li>Arm Armv8-A A32/T32 Instruction Set Architecture<br />
<a href="https://developer.arm.com/documentation/ddi0597/2021-12/?lang=en">https://developer.arm.com/documentation/ddi0597/2021-12/?lang=en</a>
</li>

<li>Comparison of ARMv8-A cores<br />
<a href="https://en.wikipedia.org/wiki/Comparison_of_ARMv8-A_cores">https://en.wikipedia.org/wiki/Comparison_of_ARMv8-A_cores</a>
</li>

<li>Cortex-A32 Processor<br />
<a href="https://www.arm.com/products/processors/cortex-a/cortex-a32-processor.php">https://www.arm.com/products/processors/cortex-a/cortex-a32-processor.php</a>
</li>

<li>Cortex-A35 Processor<br />
<a href="https://www.arm.com/products/processors/cortex-a/cortex-a35-processor.php">https://www.arm.com/products/processors/cortex-a/cortex-a35-processor.php</a>
</li>

<li>Cortex-A53 Processor<br />
<a href="https://www.arm.com/products/processors/cortex-a/cortex-a53-processor.php">https://www.arm.com/products/processors/cortex-a/cortex-a53-processor.php</a>
</li>

<li>Cortex-A57 Processor<br />
<a href="https://www.arm.com/products/processors/cortex-a/cortex-a57-processor.php">https://www.arm.com/products/processors/cortex-a/cortex-a57-processor.php</a>
</li>

<li>Cortex-A72 Processor<br />
<a href="https://www.arm.com/products/processors/cortex-a/cortex-a72-processor.php">https://www.arm.com/products/processors/cortex-a/cortex-a72-processor.php</a>
</li>

<li>Cortex-A73 Processor<br />
<a href="https://www.arm.com/products/processors/cortex-a/cortex-a73-processor.php">https://www.arm.com/products/processors/cortex-a/cortex-a73-processor.php</a>
</li>

<li>Apple A7 (SoC založen na CPU Cyclone)<br />
<a href="https://en.wikipedia.org/wiki/Apple_A7">https://en.wikipedia.org/wiki/Apple_A7</a>
</li>

<li>System cally pro AArch64 na Linuxu<br />
<a href="https://github.com/torvalds/linux/blob/master/include/uapi/asm-generic/unistd.h">https://github.com/torvalds/linux/blob/master/include/uapi/asm-generic/unistd.h</a>
</li>

<li>Architectures/AArch64 (FedoraProject.org)<br />
<a href="https://fedoraproject.org/wiki/Architectures/AArch64">https://fedoraproject.org/wiki/Architectures/AArch64</a>
</li>

<li>SIG pro AArch64 (CentOS)<br />
<a href="https://wiki.centos.org/SpecialInterestGroup/AltArch/AArch64">https://wiki.centos.org/SpecialInterestGroup/AltArch/AArch64</a>
</li>

<li>The ARMv8 instruction sets<br />
<a href="http://infocenter.arm.com/help/index.jsp?topic=/com.arm.doc.den0024a/ch05s01.html">http://infocenter.arm.com/help/index.jsp?topic=/com.arm.doc.den0024a/ch05s01.html</a>
</li>

<li>A64 Instruction Set<br />
<a href="https://developer.arm.com/products/architecture/instruction-sets/a64-instruction-set">https://developer.arm.com/products/architecture/instruction-sets/a64-instruction-set</a>
</li>

<li>Switching between the instruction sets<br />
<a href="http://infocenter.arm.com/help/index.jsp?topic=/com.arm.doc.den0024a/ch05s01.html">http://infocenter.arm.com/help/index.jsp?topic=/com.arm.doc.den0024a/ch05s01.html</a>
</li>

<li>The A64 instruction set<br />
<a href="http://infocenter.arm.com/help/index.jsp?topic=/com.arm.doc.den0024a/ch05s01.html">http://infocenter.arm.com/help/index.jsp?topic=/com.arm.doc.den0024a/ch05s01.html</a>
</li>

<li>Introduction to ARMv8 64-bit Architecture<br />
<a href="https://quequero.org/2014/04/introduction-to-arm-architecture/">https://quequero.org/2014/04/introduction-to-arm-architecture/</a>
</li>

<li>MCU market turns to 32-bits and ARM<br />
<a href="http://www.eetimes.com/document.asp?doc_id=1280803">http://www.eetimes.com/document.asp?doc_id=1280803</a>
</li>

<li>Cortex-M0 Processor (ARM Holdings)<br />
<a href="http://www.arm.com/products/processors/cortex-m/cortex-m0.php">http://www.arm.com/products/processors/cortex-m/cortex-m0.php</a>
</li>

<li>Cortex-M0+ Processor (ARM Holdings)<br />
<a href="http://www.arm.com/products/processors/cortex-m/cortex-m0plus.php">http://www.arm.com/products/processors/cortex-m/cortex-m0plus.php</a>
</li>

<li>ARM Processors in a Mixed Signal World<br />
<a href="http://www.eeweb.com/blog/arm/arm-processors-in-a-mixed-signal-world">http://www.eeweb.com/blog/arm/arm-processors-in-a-mixed-signal-world</a>
</li>

<li>ARM Architecture (Wikipedia)<br />
<a href="https://en.wikipedia.org/wiki/ARM_architecture">https://en.wikipedia.org/wiki/ARM_architecture</a>
</li>

<li>DSP for Cortex-M<br />
<a href="https://developer.arm.com/technologies/dsp/dsp-for-cortex-m">https://developer.arm.com/technologies/dsp/dsp-for-cortex-m</a>
</li>

<li>Cortex-M processors in DSP applications? Why not?!<br />
<a href="https://community.arm.com/processors/b/blog/posts/cortex-m-processors-in-dsp-applications-why-not">https://community.arm.com/processors/b/blog/posts/cortex-m-processors-in-dsp-applications-why-not</a>
</li>

<li>White Paper - DSP capabilities of Cortex-M4 and Cortex-M7<br />
<a href="https://community.arm.com/processors/b/blog/posts/white-paper-dsp-capabilities-of-cortex-m4-and-cortex-m7">https://community.arm.com/processors/b/blog/posts/white-paper-dsp-capabilities-of-cortex-m4-and-cortex-m7</a>
</li>

<li>Q (number format)<br />
<a href="https://en.wikipedia.org/wiki/Q_%28number_format%29">https://en.wikipedia.org/wiki/Q_%28number_format%29</a>
</li>

<li>TriCore Architecture &amp; Core<br />
<a href="http://www.infineon.com/cms/en/product/microcontroller/32-bit-tricore-tm-microcontroller/tricore-tm-architecture-and-core/channel.html?channel=ff80808112ab681d0112ab6b73d40837">http://www.infineon.com/cms/en/product/microcontroller/32-bit-tricore-tm-microcontroller/tricore-tm-architecture-and-core/channel.html?channel=ff80808112ab681d0112ab6b73d40837</a>
</li>

<li>TriCoreTM V1.6 Instruction Set: 32-bit Unified Processor Core<br />
<a href="http://www.infineon.com/dgdl/tc_v131_instructionset_v138.pdf?fileId=db3a304412b407950112b409b6dd0352">http://www.infineon.com/dgdl/tc_v131_instructionset_v138.pdf?fileId=db3a304412b407950112b409b6dd0352</a>
</li>

<li>TriCore v2.2 C Compiler, Assembler, Linker Reference Manual<br />
<a href="http://tasking.com/support/tricore/tc_reference_guide_v2.2.pdf">http://tasking.com/support/tricore/tc_reference_guide_v2.2.pdf</a>
</li>

<li>Infineon TriCore (Wikipedia)<br />
<a href="https://en.wikipedia.org/wiki/Infineon_TriCore">https://en.wikipedia.org/wiki/Infineon_TriCore</a>
</li>

<li>C166®S V2 Architecture &amp; Core<br />
<a href="http://www.infineon.com/cms/en/product/microcontroller/16-bit-c166-microcontroller/c166-s-v2-architecture-and-core/channel.html?channel=db3a304312bef5660112c3011c7d01ae">http://www.infineon.com/cms/en/product/microcontroller/16-bit-c166-microcontroller/c166-s-v2-architecture-and-core/channel.html?channel=db3a304312bef5660112c3011c7d01ae</a>
</li>

<li>Comparing four 32-bit soft processor cores<br />
<a href="http://www.eetimes.com/author.asp?section_id=14&doc_id=1286116">http://www.eetimes.com/author.asp?section_id=14&doc_id=1286116</a>
</li>

<li>RISC-V Instruction Set<br />
<a href="http://riscv.org/download.html#spec_compressed_isa">http://riscv.org/download.html#spec_compressed_isa</a>
</li>

<li>RISC-V Spike (ISA Simulator)<br />
<a href="http://riscv.org/download.html#isa-sim">http://riscv.org/download.html#isa-sim</a>
</li>

<li>RISC-V (Wikipedia)<br />
<a href="https://en.wikipedia.org/wiki/RISC-V">https://en.wikipedia.org/wiki/RISC-V</a>
</li>

<li>David Patterson (Wikipedia)<br />
<a href="https://en.wikipedia.org/wiki/David_Patterson_(computer_scientist)">https://en.wikipedia.org/wiki/David_Patterson_(computer_scientist)</a>
</li>

<li>OpenRISC (oficiální stránky projektu)<br />
<a href="http://openrisc.io/">http://openrisc.io/</a>
</li>

<li>OpenRISC architecture<br />
<a href="http://openrisc.io/architecture.html">http://openrisc.io/architecture.html</a>
</li>

<li>Emulátor OpenRISC CPU v JavaScriptu<br />
<a href="http://s-macke.github.io/jor1k/demos/main.html">http://s-macke.github.io/jor1k/demos/main.html</a>
</li>

<li>OpenRISC (Wikipedia)<br />
<a href="https://en.wikipedia.org/wiki/OpenRISC">https://en.wikipedia.org/wiki/OpenRISC</a>
</li>

<li>OpenRISC - instrukce<br />
<a href="http://sourceware.org/cgen/gen-doc/openrisc-insn.html">http://sourceware.org/cgen/gen-doc/openrisc-insn.html</a>
</li>

<li>OpenRISC - slajdy z přednášky o projektu<br />
<a href="https://iis.ee.ethz.ch/~gmichi/asocd/lecturenotes/Lecture6.pdf">https://iis.ee.ethz.ch/~gmichi/asocd/lecturenotes/Lecture6.pdf</a>
</li>

<li>Berkeley RISC<br />
<a href="http://en.wikipedia.org/wiki/Berkeley_RISC">http://en.wikipedia.org/wiki/Berkeley_RISC</a>
</li>

<li>Great moments in microprocessor history<br />
<a href="http://www.ibm.com/developerworks/library/pa-microhist.html">http://www.ibm.com/developerworks/library/pa-microhist.html</a>
</li>

<li>Microprogram-Based Processors<br />
<a href="http://research.microsoft.com/en-us/um/people/gbell/Computer_Structures_Principles_and_Examples/csp0167.htm">http://research.microsoft.com/en-us/um/people/gbell/Computer_Structures_Principles_and_Examples/csp0167.htm</a>
</li>

<li>Great Microprocessors of the Past and Present<br />
<a href="http://www.cpushack.com/CPU/cpu1.html">http://www.cpushack.com/CPU/cpu1.html</a>
</li>

<li>A Brief History of Microprogramming<br />
<a href="http://www.cs.clemson.edu/~mark/uprog.html">http://www.cs.clemson.edu/~mark/uprog.html</a>
</li>

<li>What is RISC?<br />
<a href="http://www-cs-faculty.stanford.edu/~eroberts/courses/soco/projects/2000-01/risc/whatis/">http://www-cs-faculty.stanford.edu/~eroberts/courses/soco/projects/2000-01/risc/whatis/</a>
</li>

<li>RISC vs. CISC<br />
<a href="http://www-cs-faculty.stanford.edu/~eroberts/courses/soco/projects/2000-01/risc/risccisc/">http://www-cs-faculty.stanford.edu/~eroberts/courses/soco/projects/2000-01/risc/risccisc/</a>
</li>

<li>RISC and CISC definitions:<br />
<a href="http://www.cpushack.com/CPU/cpuAppendA.html">http://www.cpushack.com/CPU/cpuAppendA.html</a>
</li>

<li>FPGA<br />
<a href="https://cs.wikipedia.org/wiki/Programovateln%C3%A9_hradlov%C3%A9_pole">https://cs.wikipedia.org/wiki/Programovateln%C3%A9_hradlov%C3%A9_pole</a>
</li>

<li>The Evolution of RISC<br />
<a href="http://www.ibm.com/developerworks/library/pa-microhist.html#sidebar1">http://www.ibm.com/developerworks/library/pa-microhist.html#sidebar1</a>
</li>

<li>disasm.pro<br />
<a href="https://disasm.pro/">https://disasm.pro/</a>
</li>

<li>Exploring AArch64 assembler &ndash; Chapter 5<br />
<a href="https://thinkingeek.com/2016/11/13/exploring-aarch64-assembler-chapter-5/">https://thinkingeek.com/2016/11/13/exploring-aarch64-assembler-chapter-5/</a>
</li>

</ol>



<p></p><p></p>
<p><small>Autor: <a href="http://www.fit.vutbr.cz/~tisnovpa">Pavel Tišnovský</a> &nbsp; 2022</small></p>
</body>
</html>

<!--
    06:00 - 07:00       51000
    07:00 - 08:00       52000
    08:00 - 09:00       53000
    09:00 - 10:00       54000
    11:00 - 11:00       55000
    11:00 - 12:00       56000
    12:00 - 13:00       57000
    13:00 - 14:00       58000
    14:00 - 15:00       59000
    15:00 - 16:00       60000
    -->
