<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
        "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html>
<head>
<title></title>
<meta name="Author" content="Pavel Tisnovsky" />
<meta name="Generator" content="vim" />
<meta http-equiv="content-type" content="text/html; charset=utf-8" />
<style type="text/css">
         body {color:#000000; background:#ffffff;}
         h1  {font-family: arial, helvetica, sans-serif; color:#ffffff; background-color:#c00000; text-align:center; padding-left:1em}
         h2  {font-family: arial, helvetica, sans-serif; color:#ffffff; background-color:#0000c0; padding-left:1em; text-align:left}
         h3  {font-family: arial, helvetica, sans-serif; color:#000000; background-color:#c0c0c0; padding-left:1em; text-align:left}
         h4  {font-family: arial, helvetica, sans-serif; color:#000000; background-color:#e0e0e0; padding-left:1em; text-align:left}
         a   {font-family: arial, helvetica, sans-serif;}
         li  {font-family: arial, helvetica, sans-serif; color:#000000; text-align:justify; width:450px;}
         ol  {font-family: arial, helvetica, sans-serif; color:#000000; text-align:justify; width:450px;}
         ul  {font-family: arial, helvetica, sans-serif; color:#000000; text-align:justify; width:450px;}
         p   {font-family: arial, helvetica, sans-serif; color:#000000; text-align:justify;}
         pre {background:#e0e0e0}
</style>
</head>

<body>

<h1></h1>

<h3>Pavel Tišnovský</h3>

<p></p>

<h1>Úvodník</h1>

<p></p>



<h2>Obsah</h2>

<p><a href="#k01">*** 1. </a></p>
<p><a href="#k02">*** 2. Použitý počítač</a></p>
<p><a href="#k03">*** 3. Instalace základních vývojářských nástrojů</a></p>
<p><a href="#k04">*** 4. Sada pracovních registrů mikroprocesorů s&nbsp;architekturou AArch64</a></p>
<p><a href="#k05">*** 5. Instrukce <strong>MOV</strong> a <strong>SVC</strong></a></p>
<p><a href="#k06">*** 6. Nejjednodušší korektní program zapsaný v&nbsp;assembleru</a></p>
<p><a href="#k07">*** 7. </a></p>
<p><a href="#k08">*** 8. </a></p>
<p><a href="#k09">*** 9. </a></p>
<p><a href="#k10">*** 10. </a></p>
<p><a href="#k11">*** 11. </a></p>
<p><a href="#k12">*** 12. </a></p>
<p><a href="#k13">*** 13. </a></p>
<p><a href="#k14">*** 14. </a></p>
<p><a href="#k15">*** 15. </a></p>
<p><a href="#k16">*** 16. </a></p>
<p><a href="#k17">*** 17. </a></p>
<p><a href="#k18">*** 18. </a></p>
<p><a href="#k19">*** 19. Předchozí články o architektuře AArch64</a></p>
<p><a href="#k20">*** 20. Odkazy na Internetu</a></p>



<p><a name="k01"></a></p>
<h2 id="k01">1. </h2>

<p>Na <a href="#k19">předchozí pětici článků</a> o architektuře AArch64 dnes navážeme. Ukážeme si, jakým způsobem se používají základní instrukce z&nbsp;instrukční sady této velmi zajímavé architektury. Prozatím si většinou vystačíme s&nbsp;assemblerem (a linkerem), protože pro studijní účely je vhodné používat co nejjednodušší (resp.&nbsp;nejvíce transparentní) nástroje. Ovšem od assembleru je jen relativně malý krok k&nbsp;programům, které jsou zapsány v&nbsp;jazyku C, což je pochopitelně téma, na které nezapomeneme.</p>



<p><a name="k02"></a></p>
<h2 id="k02">2. Použitý počítač</h2>

<pre>
$ <strong>lscpu</strong>
</pre>

<pre>
&nbsp;
Architecture:                    aarch64
CPU op-mode(s):                  64-bit
Byte Order:                      Little Endian
CPU(s):                          4
On-line CPU(s) list:             0-3
Thread(s) per core:              1
Core(s) per socket:              4
Socket(s):                       1
NUMA node(s):                    1
Vendor ID:                       Cavium
Model:                           1
Model name:                      ThunderX2 99xx
Stepping:                        0x1
BogoMIPS:                        400.00
NUMA node0 CPU(s):               0-3
Vulnerability Itlb multihit:     Not affected
Vulnerability L1tf:              Not affected
Vulnerability Mds:               Not affected
Vulnerability Meltdown:          Not affected
Vulnerability Spec store bypass: Mitigation; Speculative Store Bypass disabled via prctl
Vulnerability Spectre v1:        Mitigation; __user pointer sanitization
Vulnerability Spectre v2:        Mitigation; Branch predictor hardening
Vulnerability Srbds:             Not affected
Vulnerability Tsx async abort:   Not affected
Flags:                           fp asimd evtstrm aes pmull sha1 sha2 crc32 atomics cpuid asimdrdm
</pre>

<pre>
# <strong>lscpu -a -e=socket,cpu,core,online</strong>
&nbsp;
SOCKET CPU CORE ONLINE
     0   0    0    yes
     0   1    1    yes
     0   2    2    yes
     0   3    3    yes
</pre>

<pre>
$ <strong>cat /proc/cpuinfo</strong>
</pre>

<pre>
processor       : 0
BogoMIPS        : 400.00
Features        : fp asimd evtstrm aes pmull sha1 sha2 crc32 atomics cpuid asimdrdm
CPU implementer : 0x43
CPU architecture: 8
CPU variant     : 0x1
CPU part        : 0x0af
CPU revision    : 1
&nbsp;
processor       : 1
BogoMIPS        : 400.00
Features        : fp asimd evtstrm aes pmull sha1 sha2 crc32 atomics cpuid asimdrdm
CPU implementer : 0x43
CPU architecture: 8
CPU variant     : 0x1
CPU part        : 0x0af
CPU revision    : 1
&nbsp;
processor       : 2
BogoMIPS        : 400.00
Features        : fp asimd evtstrm aes pmull sha1 sha2 crc32 atomics cpuid asimdrdm
CPU implementer : 0x43
CPU architecture: 8
CPU variant     : 0x1
CPU part        : 0x0af
CPU revision    : 1
&nbsp;
processor       : 3
BogoMIPS        : 400.00
Features        : fp asimd evtstrm aes pmull sha1 sha2 crc32 atomics cpuid asimdrdm
CPU implementer : 0x43
CPU architecture: 8
CPU variant     : 0x1
CPU part        : 0x0af
CPU revision    : 1
</pre>



<p><a name="k03"></a></p>
<h2 id="k03">3. Instalace základních vývojářských nástrojů</h2>

<pre>
# <strong>dnf install binutils</strong>
</pre>

<pre>
Last metadata expiration check: 0:13:15 ago on Sat 19 Feb 2022 07:05:31 AM EST.
Dependencies resolved.
===============================================================================================================================================================
 Package                                  Architecture                       Version                                  Repository                          Size
===============================================================================================================================================================
Installing:
 binutils                                 aarch64                            2.35-18.fc33                             updates                            5.8 M
Installing dependencies:
 binutils-gold                            aarch64                            2.35-18.fc33                             updates                            937 k
&nbsp;
Transaction Summary
===============================================================================================================================================================
Install  2 Packages
&nbsp;
Total download size: 6.7 M
Installed size: 30 M
Is this ok [y/N]: y
</pre>



<p><a name="k04"></a></p>
<h2 id="k04">4. Sada pracovních registrů mikroprocesorů s&nbsp;architekturou AArch64</h2>

<p>V&nbsp;navazujících kapitolách si ukážeme několik jednoduchých programů
vytvořených v&nbsp;assembleru AArch64. Aby bylo zřejmé, jak jsou tyto programy
strukturovány, je nutné znát alespoň minimální informace o pracovních
registrech, speciálních registrech i o instrukční sadě AArch64. Začněme tedy
zmínkou o pracovních registrech a speciálních registrech.</p>

<p>Původních patnáct pracovních registrů pojmenovaných <strong>R0</strong> až
<strong>R14</strong>, které známe z&nbsp;dnes již klasických 32bitových
procesorů ARM, bylo rozšířeno na celkem 31 registrů, z&nbsp;nichž každý má nyní
šířku 64 bitů. Z&nbsp;tohoto důvodu muselo dojít k&nbsp;úpravě pojmenování
registrů způsobem, který je naznačený v&nbsp;následující tabulce a který
ostatně uvidíme i v&nbsp;dále uvedených demonstračních příkladech:</p>

<table>
<tr><th>Jméno</th><th>Význam</th></tr>
<tr><td>r0..r30</td><td>použito například v&nbsp;dokumentaci, popisu ABI atd.</td></tr>
<tr><td>x0..x30</td><td>celý 64bitový registr použitý jako zdroj či cíl pro prováděné operace</td></tr>
<tr><td>w0..w30</td><td>spodních 32 bitů registru (horních 32 bitů výsledku je buď vynulováno nebo znaménkově rozšířeno)</td></tr>
</table>

<p>Všechny tyto pracovní registry přitom mají v&nbsp;instrukční sadě stejné
postavení, na rozdíl od instrukční sady Thumb (přesněji dnes T32), v&nbsp;níž
se pro některé instrukce může použít jen spodních osm registrů. Ostatně nejedná
se o žádné překvapení, protože v&nbsp;&bdquo;pravých&ldquo; RISCových
procesorech je zvykem používat všechny pracovní registry shodným způsobem a
nerozlišovat například akumulátory, indexové registry, ukazatele na bázovou
adresu na zásobníku atd.</p>

<p>Další sada pracovních registrů je používána při operacích s&nbsp;datovými
typy <i>single/float</i> a <i>double</i> (tedy s&nbsp;operandy reprezentovanými
v&nbsp;systému plovoucí řádové čárky), u SIMD operací a taktéž kryptografickým
modulem:</p>

<table>
<tr><th>Jméno</th><th>Význam</th></tr>
<tr><td>v0..v31</td><td>128bitové registry</td></tr>
<tr><td>d0..d31</td><td>spodních 64 bitů registrů v0..v31, použito pro hodnoty typu <i>double</i></td></tr>
<tr><td>s0..s31</td><td>spodních 32 bitů registrů v0..v31, použito pro hodnoty typu <i>single/float</i></td></tr>
</table>

<p>Pro SIMD operace, tj.&nbsp;operace pracující s&nbsp;vektory, se registry
<strong>vn</strong> rozdělují takto:</p>

<table>
<tr><th>Tvar (shape)</th><th>Celkem</th><th>Pojmenování v&nbsp;assembleru</th></tr>
<tr><td>8b&times;8</td><td>64b</td><td>Vn.8B</td></tr>
<tr><td>8b&times;16</td><td>128b</td><td>Vn.16B</td></tr>
<tr><td>16b&times;4</td><td>64b</td><td>Vn.4H</td></tr>
<tr><td>16b&times;8</td><td>128b</td><td>Vn.8H</td></tr>
<tr><td>32b&times;2</td><td>64b</td><td>Vn.2S</td></tr>
<tr><td>32b&times;4</td><td>128b</td><td>Vn.4S</td></tr>
<tr><td>64b&times;1</td><td>64b</td><td>Vn.1D</td></tr>
<tr><td>64b&times;2</td><td>128b</td><td>Vn.2D</td></tr>
</table>

<p>Povšimněte si, že &ndash; na rozdíl od mnoha jiných mikroprocesorových
architektur &ndash; nedochází k&nbsp;tomu, že by se například dva <i>single</i>
registry mapovaly do jednoho <i>double</i> registru atd.</p>

<p>Mezi speciální registry patří především:</p>

<table>
<tr><th>Jméno</th><th>Význam zkratky</th></tr>
<tr><td>SCTLR_ELn</td><td>System Control Register</td></tr>
<tr><td>ACTLR_ELn</td><td>Auxiliary Control Register</td></tr>
<tr><td>SCR_EL3</td><td>Secure Configuration Register</td></tr>
<tr><td>HCR_EL2</td><td>Hypervisor Configuration Register</td></tr>
<tr><td>MIDR_EL1</td><td>Main ID Register</td></tr>
<tr><td>MPIDR_EL1</td><td>Multiprocessor Affinity Register</td></tr>
</table>
 
<p>Význam těchto registrů bude popsán v&nbsp;navazujících článcích.</p>

<p>V&nbsp;pořadí třicátý druhý registr, tj.&nbsp;registr se jménem
<strong>x31</strong> či <strong>w31</strong>, není ve skutečnosti běžným
pracovním registrem, protože má dva speciální významy. V&nbsp;případě použití
tohoto registru v&nbsp;aritmetických či logických instrukcích se při použití ve
funkci vstupního operandu tento registr chová jako konstantní nula a při
použití ve funkci operandu výstupního jako /dev/null (výsledek se zahodí a
neovlivní skutečnou hodnotu uloženou do registru). Proto se v&nbsp;assembleru
může pro pojmenování tohoto registru použít jméno <strong>xzr</strong> či
<strong>wzr</strong> (<i>extended zero register</i>, <i>working zero
register</i>). U instrukcí pracujících se zásobníkem se tento registr chová
jako ukazatel na vrchol zásobníku a proto se pro něj v&nbsp;assembleru používá
jméno <strong>rsp</strong> či jen <strong>SP</strong> (na velikosti písmen u
jmen registrů samozřejmě nezáleží).</p>

<p>Poznámky:</p>

<ol>
<li>Registr <strong>x30</strong> se používá ve funkci <strong>LR</strong> (<i>Link Register</i>).</li>
<li>Registr <strong>PC</strong> není přímo dostupný. Toto je jeden z&nbsp;největších viditelných rozdílů mezi ARM 32 a AArch64.</li>
</ol>



<p><a name="k05"></a></p>
<h2 id="k05">5. Instrukce <strong>MOV</strong> a <strong>SVC</strong></h2>

<p>V&nbsp;demonstračním příkladu, který bude ukázán <a href="#k06">v&nbsp;další kapitole</a>, si vystačíme s&nbsp;pouhými dvěma instrukcemi. Jedná se o instrukci nazvanou <strong>MOV</strong> a o instrukci <strong>SVC</strong>. Instrukce <strong>MOV</strong> slouží k&nbsp;přesunu dat mezi pracovními registry i pro načtení konstanty do registru. Ve skutečnosti existuje více variant instrukce <strong>MOV</strong>, nás bude konkrétně zajímat varianta, která dokáže do zvoleného pracovního registru uložit konstantu. V&nbsp;assembleru je registr, do něhož se konstanta ukládá, použit jako první operand, za nímž následuje vlastní konstanta zapisovaná s&nbsp;křížkem na začátku (aby se odlišila konstanta od adresy):</p>

<pre>
<i># Linux kernel system call table</i>
sys_exit=93
&nbsp;
mov  x8, #sys_exit      <i>// cislo sycallu pro funkci "exit"</i>
mov  x0, #0             <i>// exit code = 0</i>
</pre>

<p><div class="rs-tip-major">Poznámka: GNU assembler rozeznává instrukci <strong>MOV</strong>, ovšem ve skutečnosti se jedná o pseudoinstrukci, zde konkrétně o alias instrukce <strong>MOVI</strong>.</div></p>

<p>Název instrukce <strong>SVC</strong> vznikl ze sousloví <i>SuperVisor Call</i> a (minimálně na Linuxu) slouží k&nbsp;volání služeb jádra. Tato instrukce má jeden operand určující typ volání. Opět se podívejme na způsob zápisu této funkce v&nbsp;assembleru::</p>

<pre>
svc  0                  <i>// volani Linuxoveho kernelu</i>
</pre>



<p><a name="k06"></a></p>
<h2 id="k06">6. Nejjednodušší korektní program zapsaný v&nbsp;assembleru</h2>

<p>Podívejme se nyní, jak by vypadal program (pravděpodobně dokonce nejjednodušší program vůbec), který po svém spuštění pouze zavolá službu jádra, která program ukončí a předá volajícímu (rodičovskému) procesu návratový kód.  Celý program obsahuje pouze tři instrukce, přičemž první instrukce slouží pro naplnění registru obsahujícího číslo služby jádra, druhá instrukce naplní registr s&nbsp;návratovým kódem a třetí instrukce skutečně zavolá jádro (<strong>svc</strong> znamená <i>supervisor call</i>)</p>

<pre>
# asmsyntax=as

# Sablona pro zdrojovy kod Linuxoveho programu naprogramovaneho
# v assembleru GNU AS pro architekturu AArch64.
#
# Autor: Pavel Tisnovsky



# Linux kernel system call table
sys_exit=93

# List of syscalls for AArch64:
# https://github.com/torvalds/linux/blob/master/include/uapi/asm-generic/unistd.h



#-----------------------------------------------------------------------------
.section .data



#-----------------------------------------------------------------------------
.section .bss



#-----------------------------------------------------------------------------
.section .text
        .global _start          // tento symbol ma byt dostupny i z linkeru

_start:
        mov  x8, #sys_exit      // cislo sycallu pro funkci "exit"
        mov  x0, #0             // exit code = 0
        svc  0                  // volani Linuxoveho kernelu

</pre>



<p><a name="k07"></a></p>
<h2 id="k07">7. </h2>

<pre>
$ <strong>objdump -f -d -t -h a.out</strong>
</pre>

<pre>
a.out:     file format elf64-littleaarch64
architecture: aarch64, flags 0x00000102:
EXEC_P, D_PAGED
start address 0x0000000000400078
&nbsp;
Sections:
Idx Name          Size      VMA               LMA               File off  Algn
  0 .text         0000000c  0000000000400078  0000000000400078  00000078  2**2
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
SYMBOL TABLE:
no symbols
&nbsp;
&nbsp;
&nbsp;
Disassembly of section .text:
&nbsp;
0000000000400078 &lt;.text&gt;:
  400078:       d2800ba8        mov     x8, #0x5d                       // #93
  40007c:       d2800000        mov     x0, #0x0                        // #0
  400080:       d4000001        svc     #0x0
</pre>

<p></p>

<pre>
mov x8, #0x5d
</pre>

<pre>
d200ba8
</pre>

| sf | 1 0 | 1 0 0 1 0 1 | hw | imm16 | Rd |
sf=1 pro 64bit
Rd = 8 (01000)
imm16 = 0x5d (01011101)

1 1 0 1 |0 0 1 0 | 1 0 0 0| 0 0 0 0 | 0 0 0 0 | 1 0 1 1 | 1 0 1 0 | 1 0 0 0
   d        2         8        0         0         b         a         8


<p><a name="k08"></a></p>
<h2 id="k08">8. </h2>

<pre>
# asmsyntax=as

# Jednoducha aplikace typu "Hello world!" naprogramovana
# v assembleru GNU as.
#
# Autor: Pavel Tisnovsky



# Linux kernel system call table
sys_exit=93
sys_write=64

# List of syscalls for AArch64:
# https://github.com/torvalds/linux/blob/master/include/uapi/asm-generic/unistd.h



#-----------------------------------------------------------------------------
.section .data

hello_lbl:
        .string "Hello World!\n"

#-----------------------------------------------------------------------------
.section .bss



#-----------------------------------------------------------------------------
.section .text
        .global _start          // tento symbol ma byt dostupny i linkeru

_start:
        mov  x8, #sys_write     // cislo sycallu pro funkci "write"
        mov  x0, #1             // standardni vystup
        ldr  x1, =hello_lbl     // adresa retezce, ktery se ma vytisknout
        mov  x2, #13            // pocet znaku, ktere se maji vytisknout
        svc  0                  // volani Linuxoveho kernelu

        mov  x8, #sys_exit      // cislo sycallu pro funkci "exit"
        mov  x0, #0             // exit code = 0
        svc  0                  // volani Linuxoveho kernelu
</pre>



<p><a name="k09"></a></p>
<h2 id="k09">9. </h2>

<pre>
[root@hpe-apollo-cn99xx-14-vm-09 x]# objdump -f -d -t -h a.out

a.out:     file format elf64-littleaarch64
architecture: aarch64, flags 0x00000102:
EXEC_P, D_PAGED
start address 0x00000000004000b0

Sections:
Idx Name          Size      VMA               LMA               File off  Algn
  0 .text         00000028  00000000004000b0  00000000004000b0  000000b0  2**3
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  1 .data         0000000e  00000000004100d8  00000000004100d8  000000d8  2**0
                  CONTENTS, ALLOC, LOAD, DATA
SYMBOL TABLE:
no symbols



Disassembly of section .text:

00000000004000b0 &ld;.text&gt;:
  4000b0:       d2800808        mov     x8, #0x40                       // #64
  4000b4:       d2800020        mov     x0, #0x1                        // #1
  4000b8:       580000c1        ldr     x1, 0x4000d0
  4000bc:       d28001a2        mov     x2, #0xd                        // #13
  4000c0:       d4000001        svc     #0x0
  4000c4:       d2800ba8        mov     x8, #0x5d                       // #93
  4000c8:       d2800000        mov     x0, #0x0                        // #0
  4000cc:       d4000001        svc     #0x0
  4000d0:       004100d8        .inst   0x004100d8 ; undefined
  4000d4:       00000000        udf     #0
</pre>



<p><a name="k10"></a></p>
<h2 id="k10">10. </h2>



<p><a name="k11"></a></p>
<h2 id="k11">11. </h2>



<p><a name="k12"></a></p>
<h2 id="k12">12. </h2>

<pre>
# asmsyntax=as
 
# Testovaci program naprogramovany v assembleru GNU as
# - pocitana programova smycka
# - uprava pro mikroprocesory s architekturou AArch64
#
# Autor: Pavel Tisnovsky
 
 
 
# Linux kernel system call table
sys_exit   = 93
sys_write  = 64

# List of syscalls for AArch64:
# https://github.com/torvalds/linux/blob/master/include/uapi/asm-generic/unistd.h
 
# Dalsi konstanty pouzite v programu - standardni streamy
std_input  = 0
std_output = 1

# pocet opakovani znaku
rep_count  = 40
 
 
 
#-----------------------------------------------------------------------------
.section .data
 
 
 
#-----------------------------------------------------------------------------
.section .bss
        .lcomm buffer, rep_count     // rezervace bufferu pro vystup
 
 
 
#-----------------------------------------------------------------------------
.section .text
        .global _start               // tento symbol ma byt dostupny i linkeru
 
_start:
        ldr   x1, =buffer            // zapis se bude provadet do tohoto bufferu
        mov   x2, #rep_count         // pocet opakovani znaku
        mov   w3, #'*'               // zapisovany znak
loop:
        strb  w3, [x1]               // zapis znaku do bufferu
        add   x1, x1, #1             // uprava ukazatele do bufferu
        sub   x2, x2, #1             // zmenseni pocitadla
        cmp   x2, #0                 // otestovani, zda jsme jiz nedosahli nuly
        bne   loop                   // pokud jsme se nedostali k nule, skok na zacatek smycky
 
        mov   x8, #sys_write         // cislo syscallu pro funkci "write"
        mov   x0, #std_output        // standardni vystup
        ldr   x1, =buffer            // adresa retezce, ktery se ma vytisknout
        mov   x2, #rep_count         // pocet znaku, ktere se maji vytisknout
        svc   0                      // volani Linuxoveho kernelu
 
        mov   x8, #sys_exit          // cislo sycallu pro funkci "exit"
        mov   x0, #0                 // exit code = 0
        svc   0                      // volani Linuxoveho kernelu
</pre>



<p><a name="k13"></a></p>
<h2 id="k13">13. </h2>

<pre>
$ objdump -f -d -t -h a.out
</pre>

<pre>
a.out:     file format elf64-littleaarch64
architecture: aarch64, flags 0x00000102:
EXEC_P, D_PAGED
start address 0x00000000004000b0

Sections:
Idx Name          Size      VMA               LMA               File off  Algn
  0 .text         00000048  00000000004000b0  00000000004000b0  000000b0  2**3
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  1 .bss          00000028  00000000004100f8  00000000004100f8  000000f8  2**3
                  ALLOC
SYMBOL TABLE:
no symbols



Disassembly of section .text:

00000000004000b0 <.text>:
  4000b0:       58000201        ldr     x1, 0x4000f0
  4000b4:       d2800502        mov     x2, #0x28                       // #40
  4000b8:       52800543        mov     w3, #0x2a                       // #42
  4000bc:       39000023        strb    w3, [x1]
  4000c0:       91000421        add     x1, x1, #0x1
  4000c4:       d1000442        sub     x2, x2, #0x1
  4000c8:       f100005f        cmp     x2, #0x0
  4000cc:       54ffff81        b.ne    0x4000bc  // b.any
  4000d0:       d2800808        mov     x8, #0x40                       // #64
  4000d4:       d2800020        mov     x0, #0x1                        // #1
  4000d8:       580000c1        ldr     x1, 0x4000f0
  4000dc:       d2800502        mov     x2, #0x28                       // #40
  4000e0:       d4000001        svc     #0x0
  4000e4:       d2800ba8        mov     x8, #0x5d                       // #93
  4000e8:       d2800000        mov     x0, #0x0                        // #0
  4000ec:       d4000001        svc     #0x0
  4000f0:       004100f8        .inst   0x004100f8 ; undefined
  4000f4:       00000000        udf     #0
</pre>



<p><a name="k14"></a></p>
<h2 id="k14">14. </h2>



<p><a name="k15"></a></p>
<h2 id="k15">15. </h2>

<pre>
# asmsyntax=as
 
# Testovaci program naprogramovany v assembleru GNU as
# - pocitana programova smycka
# - uprava pro mikroprocesory s architekturou AArch64
#
# Autor: Pavel Tisnovsky
 
 
 
# Linux kernel system call table
sys_exit   = 93
sys_write  = 64

# List of syscalls for AArch64:
# https://github.com/torvalds/linux/blob/master/include/uapi/asm-generic/unistd.h
 
# Dalsi konstanty pouzite v programu - standardni streamy
std_input  = 0
std_output = 1

# pocet opakovani znaku
rep_count  = 40
 
 
 
#-----------------------------------------------------------------------------
.section .data
 
 
 
#-----------------------------------------------------------------------------
.section .bss
        .lcomm buffer, rep_count     // rezervace bufferu pro vystup
 
 
 
#-----------------------------------------------------------------------------
.section .text
        .global _start               // tento symbol ma byt dostupny i linkeru
 
_start:
        ldr   x1, =buffer            // zapis se bude provadet do tohoto bufferu
        mov   x2, #rep_count         // pocet opakovani znaku
        mov   w3, #'*'               // zapisovany znak
loop:
        strb  w3, [x1]               // zapis znaku do bufferu
        add   x1, x1, #1             // uprava ukazatele do bufferu
        subs  x2, x2, #1             // zmenseni pocitadla a soucasne nastaveni priznaku
        bne   loop                   // pokud jsme se nedostali k nule, skok na zacatek smycky
 
        mov   x8, #sys_write         // cislo syscallu pro funkci "write"
        mov   x0, #std_output        // standardni vystup
        ldr   x1, =buffer            // adresa retezce, ktery se ma vytisknout
        mov   x2, #rep_count         // pocet znaku, ktere se maji vytisknout
        svc   0                      // volani Linuxoveho kernelu
 
        mov   x8, #sys_exit          // cislo sycallu pro funkci "exit"
        mov   x0, #0                 // exit code = 0
        svc   0                      // volani Linuxoveho kernelu

</pre>


<p><a name="k16"></a></p>
<h2 id="k16">16. </h2>



<p><a name="k17"></a></p>
<h2 id="k17">17. </h2>

<pre>
# asmsyntax=as
 
# Testovaci program naprogramovany v assembleru GNU as
# - pocitana programova smycka realizovana instrukci CBNZ
# - uprava pro mikroprocesory s architekturou AArch64
#
# Autor: Pavel Tisnovsky
 
 
 
# Linux kernel system call table
sys_exit   = 93
sys_write  = 64

# List of syscalls for AArch64:
# https://github.com/torvalds/linux/blob/master/include/uapi/asm-generic/unistd.h
 
# Dalsi konstanty pouzite v programu - standardni streamy
std_input  = 0
std_output = 1

# pocet opakovani znaku
rep_count  = 40
 
 
 
#-----------------------------------------------------------------------------
.section .data
 
 
 
#-----------------------------------------------------------------------------
.section .bss
        .lcomm buffer, rep_count     // rezervace bufferu pro vystup
 
 
 
#-----------------------------------------------------------------------------
.section .text
        .global _start               // tento symbol ma byt dostupny i linkeru
 
_start:
        ldr   x1, =buffer            // zapis se bude provadet do tohoto bufferu
        mov   x2, #rep_count         // pocet opakovani znaku
        mov   w3, #'*'               // zapisovany znak
loop:
        strb  w3, [x1]               // zapis znaku do bufferu
        add   x1, x1, #1             // uprava ukazatele do bufferu
        sub   x2, x2, #1             // zmenseni pocitadla a soucasne nastaveni priznaku
        cbnz  x2, loop               // pokud jsme se nedostali k nule, skok na zacatek smycky
 
        mov   x8, #sys_write         // cislo syscallu pro funkci "write"
        mov   x0, #std_output        // standardni vystup
        ldr   x1, =buffer            // adresa retezce, ktery se ma vytisknout
        mov   x2, #rep_count         // pocet znaku, ktere se maji vytisknout
        svc   0                      // volani Linuxoveho kernelu
 
        mov   x8, #sys_exit          // cislo sycallu pro funkci "exit"
        mov   x0, #0                 // exit code = 0
        svc   0                      // volani Linuxoveho kernelu
</pre>



<p><a name="k18"></a></p>
<h2 id="k18">18. </h2>



<p><a name="k19"></a></p>
<h2 id="k19">19. Předchozí články o architektuře AArch64</h2>

<ol>

<li>64bitové mikroprocesory s architekturou AArch64<br />
<a href="https://www.root.cz/clanky/64bitove-mikroprocesory-s-architekturou-aarch64/">https://www.root.cz/clanky/64bitove-mikroprocesory-s-architekturou-aarch64/</a>
</li>

<li>Instrukční sada AArch64<br />
<a href="https://www.root.cz/clanky/instrukcni-sada-aarch64/">https://www.root.cz/clanky/instrukcni-sada-aarch64/</a>
</li>

<li>Instrukční sada AArch64 (2.část)<br />
<a href="https://www.root.cz/clanky/instrukcni-sada-aarch64-2-cast/">https://www.root.cz/clanky/instrukcni-sada-aarch64-2-cast/</a>
</li>

<li>Tvorba a ladění programů v&nbsp;assembleru mikroprocesorů AArch64<br />
<a href="https://www.root.cz/clanky/tvorba-a-ladeni-programu-v-assembleru-mikroprocesoru-aarch64/">https://www.root.cz/clanky/tvorba-a-ladeni-programu-v-assembleru-mikroprocesoru-aarch64/</a>
</li>

<li>Instrukční sada AArch64: technologie NEON<br />
<a href="https://www.root.cz/clanky/instrukcni-sada-aarch64-technologie-neon/">https://www.root.cz/clanky/instrukcni-sada-aarch64-technologie-neon/</a>
</li>

</ol>



<p><a name="k20"></a></p>
<h2 id="k20">20. Odkazy na Internetu</h2>

<ol>

<li>Arm Architecture Reference Manual for A-profile architecture<br />
<a href="https://developer.arm.com/documentation/ddi0487/latest">https://developer.arm.com/documentation/ddi0487/latest</a>
</li>

<li>GNU Binutils<br />
<a href="https://sourceware.org/binutils/">https://sourceware.org/binutils/</a>
</li>

<li>Documentation for binutils 2.38<br />
<a href="https://sourceware.org/binutils/docs-2.38/">https://sourceware.org/binutils/docs-2.38/</a>
</li>

<li>AArch64 Instruction Set Architecture<br />
<a href="https://developer.arm.com/architectures/learn-the-architecture/aarch64-instruction-set-architecture/instruction-sets-in-the-arm-architecture">https://developer.arm.com/architectures/learn-the-architecture/aarch64-instruction-set-architecture/instruction-sets-in-the-arm-architecture</a>
</li>

<li>Arm Armv8-A A32/T32 Instruction Set Architecture<br />
<a href="https://developer.arm.com/documentation/ddi0597/2021-12/?lang=en">https://developer.arm.com/documentation/ddi0597/2021-12/?lang=en</a>
</li>

<li>Comparison of ARMv8-A cores<br />
<a href="https://en.wikipedia.org/wiki/Comparison_of_ARMv8-A_cores">https://en.wikipedia.org/wiki/Comparison_of_ARMv8-A_cores</a>
</li>

<li>Cortex-A32 Processor<br />
<a href="https://www.arm.com/products/processors/cortex-a/cortex-a32-processor.php">https://www.arm.com/products/processors/cortex-a/cortex-a32-processor.php</a>
</li>

<li>Cortex-A35 Processor<br />
<a href="https://www.arm.com/products/processors/cortex-a/cortex-a35-processor.php">https://www.arm.com/products/processors/cortex-a/cortex-a35-processor.php</a>
</li>

<li>Cortex-A53 Processor<br />
<a href="https://www.arm.com/products/processors/cortex-a/cortex-a53-processor.php">https://www.arm.com/products/processors/cortex-a/cortex-a53-processor.php</a>
</li>

<li>Cortex-A57 Processor<br />
<a href="https://www.arm.com/products/processors/cortex-a/cortex-a57-processor.php">https://www.arm.com/products/processors/cortex-a/cortex-a57-processor.php</a>
</li>

<li>Cortex-A72 Processor<br />
<a href="https://www.arm.com/products/processors/cortex-a/cortex-a72-processor.php">https://www.arm.com/products/processors/cortex-a/cortex-a72-processor.php</a>
</li>

<li>Cortex-A73 Processor<br />
<a href="https://www.arm.com/products/processors/cortex-a/cortex-a73-processor.php">https://www.arm.com/products/processors/cortex-a/cortex-a73-processor.php</a>
</li>

<li>Apple A7 (SoC založen na CPU Cyclone)<br />
<a href="https://en.wikipedia.org/wiki/Apple_A7">https://en.wikipedia.org/wiki/Apple_A7</a>
</li>

<li>System cally pro AArch64 na Linuxu<br />
<a href="https://github.com/torvalds/linux/blob/master/include/uapi/asm-generic/unistd.h">https://github.com/torvalds/linux/blob/master/include/uapi/asm-generic/unistd.h</a>
</li>

<li>Architectures/AArch64 (FedoraProject.org)<br />
<a href="https://fedoraproject.org/wiki/Architectures/AArch64">https://fedoraproject.org/wiki/Architectures/AArch64</a>
</li>

<li>SIG pro AArch64 (CentOS)<br />
<a href="https://wiki.centos.org/SpecialInterestGroup/AltArch/AArch64">https://wiki.centos.org/SpecialInterestGroup/AltArch/AArch64</a>
</li>

<li>The ARMv8 instruction sets<br />
<a href="http://infocenter.arm.com/help/index.jsp?topic=/com.arm.doc.den0024a/ch05s01.html">http://infocenter.arm.com/help/index.jsp?topic=/com.arm.doc.den0024a/ch05s01.html</a>
</li>

<li>A64 Instruction Set<br />
<a href="https://developer.arm.com/products/architecture/instruction-sets/a64-instruction-set">https://developer.arm.com/products/architecture/instruction-sets/a64-instruction-set</a>
</li>

<li>Switching between the instruction sets<br />
<a href="http://infocenter.arm.com/help/index.jsp?topic=/com.arm.doc.den0024a/ch05s01.html">http://infocenter.arm.com/help/index.jsp?topic=/com.arm.doc.den0024a/ch05s01.html</a>
</li>

<li>The A64 instruction set<br />
<a href="http://infocenter.arm.com/help/index.jsp?topic=/com.arm.doc.den0024a/ch05s01.html">http://infocenter.arm.com/help/index.jsp?topic=/com.arm.doc.den0024a/ch05s01.html</a>
</li>

<li>Introduction to ARMv8 64-bit Architecture<br />
<a href="https://quequero.org/2014/04/introduction-to-arm-architecture/">https://quequero.org/2014/04/introduction-to-arm-architecture/</a>
</li>

<li>MCU market turns to 32-bits and ARM<br />
<a href="http://www.eetimes.com/document.asp?doc_id=1280803">http://www.eetimes.com/document.asp?doc_id=1280803</a>
</li>

<li>Cortex-M0 Processor (ARM Holdings)<br />
<a href="http://www.arm.com/products/processors/cortex-m/cortex-m0.php">http://www.arm.com/products/processors/cortex-m/cortex-m0.php</a>
</li>

<li>Cortex-M0+ Processor (ARM Holdings)<br />
<a href="http://www.arm.com/products/processors/cortex-m/cortex-m0plus.php">http://www.arm.com/products/processors/cortex-m/cortex-m0plus.php</a>
</li>

<li>ARM Processors in a Mixed Signal World<br />
<a href="http://www.eeweb.com/blog/arm/arm-processors-in-a-mixed-signal-world">http://www.eeweb.com/blog/arm/arm-processors-in-a-mixed-signal-world</a>
</li>

<li>ARM Architecture (Wikipedia)<br />
<a href="https://en.wikipedia.org/wiki/ARM_architecture">https://en.wikipedia.org/wiki/ARM_architecture</a>
</li>

<li>DSP for Cortex-M<br />
<a href="https://developer.arm.com/technologies/dsp/dsp-for-cortex-m">https://developer.arm.com/technologies/dsp/dsp-for-cortex-m</a>
</li>

<li>Cortex-M processors in DSP applications? Why not?!<br />
<a href="https://community.arm.com/processors/b/blog/posts/cortex-m-processors-in-dsp-applications-why-not">https://community.arm.com/processors/b/blog/posts/cortex-m-processors-in-dsp-applications-why-not</a>
</li>

<li>White Paper - DSP capabilities of Cortex-M4 and Cortex-M7<br />
<a href="https://community.arm.com/processors/b/blog/posts/white-paper-dsp-capabilities-of-cortex-m4-and-cortex-m7">https://community.arm.com/processors/b/blog/posts/white-paper-dsp-capabilities-of-cortex-m4-and-cortex-m7</a>
</li>

<li>Q (number format)<br />
<a href="https://en.wikipedia.org/wiki/Q_%28number_format%29">https://en.wikipedia.org/wiki/Q_%28number_format%29</a>
</li>

<li>TriCore Architecture &amp; Core<br />
<a href="http://www.infineon.com/cms/en/product/microcontroller/32-bit-tricore-tm-microcontroller/tricore-tm-architecture-and-core/channel.html?channel=ff80808112ab681d0112ab6b73d40837">http://www.infineon.com/cms/en/product/microcontroller/32-bit-tricore-tm-microcontroller/tricore-tm-architecture-and-core/channel.html?channel=ff80808112ab681d0112ab6b73d40837</a>
</li>

<li>TriCoreTM V1.6 Instruction Set: 32-bit Unified Processor Core<br />
<a href="http://www.infineon.com/dgdl/tc_v131_instructionset_v138.pdf?fileId=db3a304412b407950112b409b6dd0352">http://www.infineon.com/dgdl/tc_v131_instructionset_v138.pdf?fileId=db3a304412b407950112b409b6dd0352</a>
</li>

<li>TriCore v2.2 C Compiler, Assembler, Linker Reference Manual<br />
<a href="http://tasking.com/support/tricore/tc_reference_guide_v2.2.pdf">http://tasking.com/support/tricore/tc_reference_guide_v2.2.pdf</a>
</li>

<li>Infineon TriCore (Wikipedia)<br />
<a href="https://en.wikipedia.org/wiki/Infineon_TriCore">https://en.wikipedia.org/wiki/Infineon_TriCore</a>
</li>

<li>C166®S V2 Architecture &amp; Core<br />
<a href="http://www.infineon.com/cms/en/product/microcontroller/16-bit-c166-microcontroller/c166-s-v2-architecture-and-core/channel.html?channel=db3a304312bef5660112c3011c7d01ae">http://www.infineon.com/cms/en/product/microcontroller/16-bit-c166-microcontroller/c166-s-v2-architecture-and-core/channel.html?channel=db3a304312bef5660112c3011c7d01ae</a>
</li>

<li>Comparing four 32-bit soft processor cores<br />
<a href="http://www.eetimes.com/author.asp?section_id=14&doc_id=1286116">http://www.eetimes.com/author.asp?section_id=14&doc_id=1286116</a>
</li>

<li>RISC-V Instruction Set<br />
<a href="http://riscv.org/download.html#spec_compressed_isa">http://riscv.org/download.html#spec_compressed_isa</a>
</li>

<li>RISC-V Spike (ISA Simulator)<br />
<a href="http://riscv.org/download.html#isa-sim">http://riscv.org/download.html#isa-sim</a>
</li>

<li>RISC-V (Wikipedia)<br />
<a href="https://en.wikipedia.org/wiki/RISC-V">https://en.wikipedia.org/wiki/RISC-V</a>
</li>

<li>David Patterson (Wikipedia)<br />
<a href="https://en.wikipedia.org/wiki/David_Patterson_(computer_scientist)">https://en.wikipedia.org/wiki/David_Patterson_(computer_scientist)</a>
</li>

<li>OpenRISC (oficiální stránky projektu)<br />
<a href="http://openrisc.io/">http://openrisc.io/</a>
</li>

<li>OpenRISC architecture<br />
<a href="http://openrisc.io/architecture.html">http://openrisc.io/architecture.html</a>
</li>

<li>Emulátor OpenRISC CPU v JavaScriptu<br />
<a href="http://s-macke.github.io/jor1k/demos/main.html">http://s-macke.github.io/jor1k/demos/main.html</a>
</li>

<li>OpenRISC (Wikipedia)<br />
<a href="https://en.wikipedia.org/wiki/OpenRISC">https://en.wikipedia.org/wiki/OpenRISC</a>
</li>

<li>OpenRISC - instrukce<br />
<a href="http://sourceware.org/cgen/gen-doc/openrisc-insn.html">http://sourceware.org/cgen/gen-doc/openrisc-insn.html</a>
</li>

<li>OpenRISC - slajdy z přednášky o projektu<br />
<a href="https://iis.ee.ethz.ch/~gmichi/asocd/lecturenotes/Lecture6.pdf">https://iis.ee.ethz.ch/~gmichi/asocd/lecturenotes/Lecture6.pdf</a>
</li>

<li>Berkeley RISC<br />
<a href="http://en.wikipedia.org/wiki/Berkeley_RISC">http://en.wikipedia.org/wiki/Berkeley_RISC</a>
</li>

<li>Great moments in microprocessor history<br />
<a href="http://www.ibm.com/developerworks/library/pa-microhist.html">http://www.ibm.com/developerworks/library/pa-microhist.html</a>
</li>

<li>Microprogram-Based Processors<br />
<a href="http://research.microsoft.com/en-us/um/people/gbell/Computer_Structures_Principles_and_Examples/csp0167.htm">http://research.microsoft.com/en-us/um/people/gbell/Computer_Structures_Principles_and_Examples/csp0167.htm</a>
</li>

<li>Great Microprocessors of the Past and Present<br />
<a href="http://www.cpushack.com/CPU/cpu1.html">http://www.cpushack.com/CPU/cpu1.html</a>
</li>

<li>A Brief History of Microprogramming<br />
<a href="http://www.cs.clemson.edu/~mark/uprog.html">http://www.cs.clemson.edu/~mark/uprog.html</a>
</li>

<li>What is RISC?<br />
<a href="http://www-cs-faculty.stanford.edu/~eroberts/courses/soco/projects/2000-01/risc/whatis/">http://www-cs-faculty.stanford.edu/~eroberts/courses/soco/projects/2000-01/risc/whatis/</a>
</li>

<li>RISC vs. CISC<br />
<a href="http://www-cs-faculty.stanford.edu/~eroberts/courses/soco/projects/2000-01/risc/risccisc/">http://www-cs-faculty.stanford.edu/~eroberts/courses/soco/projects/2000-01/risc/risccisc/</a>
</li>

<li>RISC and CISC definitions:<br />
<a href="http://www.cpushack.com/CPU/cpuAppendA.html">http://www.cpushack.com/CPU/cpuAppendA.html</a>
</li>

<li>FPGA<br />
<a href="https://cs.wikipedia.org/wiki/Programovateln%C3%A9_hradlov%C3%A9_pole">https://cs.wikipedia.org/wiki/Programovateln%C3%A9_hradlov%C3%A9_pole</a>
</li>

<li>The Evolution of RISC<br />
<a href="http://www.ibm.com/developerworks/library/pa-microhist.html#sidebar1">http://www.ibm.com/developerworks/library/pa-microhist.html#sidebar1</a>
</li>

<li>disasm.pro<br />
<a href="https://disasm.pro/">https://disasm.pro/</a>
</li>

</ol>



<p></p><p></p>
<p><small>Autor: <a href="http://www.fit.vutbr.cz/~tisnovpa">Pavel Tišnovský</a> &nbsp; 2022</small></p>
</body>
</html>

