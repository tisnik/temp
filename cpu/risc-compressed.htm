<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
        "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html>
<head>
<title>RISCové mikroprocesory s komprimovanými instrukčními sadami</title>
<meta name="Author" content="Pavel Tisnovsky" />
<meta name="Generator" content="vim" />
<meta http-equiv="content-type" content="text/html; charset=utf-8" />
<style type="text/css">
         body {color:#000000; background:#ffffff;}
         h1  {font-family: arial, helvetica, sans-serif; color:#ffffff; background-color:#c00000; text-align:center; padding-left:1em}
         h2  {font-family: arial, helvetica, sans-serif; color:#ffffff; background-color:#0000c0; padding-left:1em; text-align:left}
         h3  {font-family: arial, helvetica, sans-serif; color:#000000; background-color:#c0c0c0; padding-left:1em; text-align:left}
         h4  {font-family: arial, helvetica, sans-serif; color:#000000; background-color:#e0e0e0; padding-left:1em; text-align:left}
         a   {font-family: arial, helvetica, sans-serif;}
         li  {font-family: arial, helvetica, sans-serif; color:#000000; text-align:justify; width:450px;}
         ol  {font-family: arial, helvetica, sans-serif; color:#000000; text-align:justify; width:450px;}
         ul  {font-family: arial, helvetica, sans-serif; color:#000000; text-align:justify; width:450px;}
         p   {font-family: arial, helvetica, sans-serif; color:#000000; text-align:justify;}
         pre {background:#e0e0e0}
</style>
</head>

<body>

<h1>RISCové mikroprocesory s komprimovanými instrukčními sadami</h1>

<h3>Pavel Tišnovský</h3>

<p></p>

<h1>Úvodník</h1>

<p>Při popisu mikroprocesorů s RISCovou architekturou jsme se již několikrát zmínili o použití těchto čipů v mikrořadičích či SoC (System on Chip), což je oblast, pro kterou původní RISCy nebyly navrhnuty. A právě v oblasti mikrořadičů a SoC se ukazuje, že může být výhodné používat instrukční sady s kratšími &bdquo;komprimovanými&ldquo; instrukcemi.</p>



<h2>Obsah</h2>

<p><a href="#k01">1. RISCové mikroprocesory s&nbsp;komprimovanými instrukčními sadami</a></p>
<p><a href="#k02">2. Stručná charakteristika &bdquo;klasických&ldquo; RISCových architektur</a></p>
<p><a href="#k03">3. Přednosti &bdquo;klasických&ldquo; RISCových architektur</a></p>
<p><a href="#k04">4. Přechod do světa embedded CPU a mikrořadičů</a></p>
<p><a href="#k05">5. Umění kompromisu</a></p>
<p><a href="#k06">6. Způsoby přepínání mezi klasickou a komprimovanou instrukční sadou</a></p>
<p><a href="#k07">7. Instrukční sada MIPS16e</a></p>
<p><a href="#k08">8. Pracovní a speciální registry používané v&nbsp;instrukční sadě MIPS16e</a></p>
<p><a href="#k09">9. Speciální instrukce <strong>EXTEND</strong></a></p>
<p><a href="#k10">10. Podmíněné skoky v&nbsp;instrukční sadě MIPS16e</a></p>
<p><a href="#k11">11. Seznam instrukcí v&nbsp;sadě MIPS16e</a></p>
<p><a href="#k12">12. Odkazy na Internetu</a></p>



<p><a name="k01"></a></p>
<h2 id="k01">1. RISCové mikroprocesory s&nbsp;komprimovanými instrukčními sadami</h2>

<p>Již v&nbsp;několika článcích, v&nbsp;nichž jsme se věnovali problematice
mikroprocesorových jader s&nbsp;architekturou <i>RISC</i>, jsme se zmínili o
použití těchto mikroprocesorů v&nbsp;různých embedded zařízeních, mikrořadičích
(MCU) či SoC (System on Chip). Tato aplikační oblast se hned v&nbsp;několika
ohledech liší od oblasti, pro kterou byla původní &bdquo;klasická&ldquo;
RISCová architektura navržena, tj.&nbsp;pro výkonné pracovní stanice, servery a
počítače specializované na provádění rychlých výpočtů. Právě z&nbsp;tohoto
určitého rozporu v&nbsp;použití procesorů RISC v&nbsp;současnosti plyne i snaha
použít v&nbsp;moderních RISC různé &bdquo;komprimované&ldquo; instrukční sady,
což je označení pro takové instrukční sady (či mnohem častěji doplnění
původních instrukčních sad), v&nbsp;nichž se vyskytují instrukce
s&nbsp;kratšími instrukčními slovy o šířce šestnáct bitů, zatímco klasické
RISCové architektury používají 32bitová instrukční slova. V&nbsp;dnešním článku
i navazujícím článku se zmíníme o některých vlastnostech komprimovaných
instrukčních sad <i>MIPS16e</i>, <i>ARM Thumb</i> a <i>RISC-V
&bdquo;C&ldquo;</i>.</p>

<a href="http://i.iinfo.cz/images/377/pc107-1.jpg"><img src="http://i.iinfo.cz/images/377/pc107-1-prev.jpg" width="370" height="204" alt="pc107" /></a>
<p><i>Obrázek 1: Jedna z&nbsp;prvních verzí v&nbsp;minulosti velmi oblíbeného
osmibitového mikroprocesoru Zilog Z80 s&nbsp;komplexní instrukční sadou
(CISC).</i></p>



<p><a name="k02"></a></p>
<h2 id="k02">2. Stručná charakteristika &bdquo;klasických&ldquo; RISCových architektur</h2>

<p>Při zpětném pohledu do historie mikroprocesorů a jejich instrukčních sad je
zajímavé si položit otázku, co vlastně vedlo ke vzniku architektury
<i>RISC</i>, když minimálně první tři generace mikroprocesorů byly většinou
založeny na mikroprogramovém řadiči a <i>CISC</i> instrukcích s&nbsp;mnohdy
velmi komplikovaným kódováním a chováním, které (alespoň teoreticky) mohly
přiblížit assembler k&nbsp;vyšším programovacím jazykům.</p>

<img src="http://i.iinfo.cz/images/51/pc140-1.jpg" width="400" height="403" alt=" " />
<p><i>Obrázek 2: I 32bitový mikroprocesor AMD 386DX je typickým zástupcem
mikroprocesorů s&nbsp;komplexní instrukční sadou &ndash; CISC.</i></p>

<p>Na základě několika paralelně běžících výzkumů provedených jak
v&nbsp;akademických institucích, tak i například vedených interně ve firmě
<i>IBM</i> a <i>CDC</i> se zjistilo, že většina vývojářů programujících
v&nbsp;assembleru a navíc i naprostá většina <i>tehdejších</i> překladačů
nevyužívá ani zdaleka všechny dostupné instrukce a jejich adresní režimy
&ndash; na mnoha platformách se využívalo přibližně jen 30% všech možných
instrukčních kódů. Konstruktéři procesorů, resp.&nbsp;přesněji řečeno návrháři
instrukčních sad si uvědomili, že investice do složitého procesoru typu
<i>CISC</i> je vlastně v&nbsp;mnoha případech zbytečná, protože jeho velká část
zůstane nevyužita. Navíc byly <i>CISC</i> procesory kvůli mikroprogramovému
řadiči poměrně složité (i když mnohem méně složité, než v&nbsp;případě použití
obvodového řadiče) a tak se některé firmy i akademické instituce začaly
poohlížet po odlišné konstrukci procesorů &ndash; tyto procesory byly teprve o
několik let později souhrnně označeny zkratkou <i>RISC</i> neboli <i>Reduced
Instruction Set Code</i> (v&nbsp;některých případech se tato zkratka taktéž
používala ve významu <i>Reduced Instruction Set Computer</i>).</p>

<img src="http://i.iinfo.cz/images/394/pc146-2.png" width="450" height="457" alt=" " />
<p><i>Obrázek 3: Mikroprocesor PA RISC firmy Hewlett-Packard, který je zde
zobrazen spolu s&nbsp;dalšími podpůrnými obvody a paměťmi cache.</i></p>

<p>Zatímco při návrhu procesorů typu <i>CISC</i> se jejich konstruktéři řídili
filozofií &bdquo;more is better&ldquo; (asi nejvíce se tato koncepce uplatnila
v&nbsp;<i>SYMBOL Machine</i>), začala se v&nbsp;případě procesorů typu
<i>RISC</i> uplatňovat přesně opačná filozofie &bdquo;less is better&ldquo;.
Mělo se tedy jednat o procesory s&nbsp;jednoduchou interní architekturou a
malým množstvím instrukcí. Mnohdy byla instrukční sada osekána pouze na 32
instrukcí, zatímco u procesorů <i>CISC</i> se v&nbsp;některých případech
jednalo i o stovky více či méně složitých instrukcí s&nbsp;mnoha adresními
režimy. Ovšem z&nbsp;toho, že procesory <i>RISC</i> mají jednoduchou
architekturu a velmi malý instrukční soubor v&nbsp;žádném případě nevyplývá, že
by byly méně výkonné, než procesory <i>CISC</i> vyráběné porovnatelnou
technologií. Ve skutečnosti tomu bylo právě naopak, protože první komerčně
dostupné mikroprocesory <i>RISC</i> měly vyšší výpočetní rychlost než jakékoli
v&nbsp;té době dostupné mikroprocesory <i>CISC</i>.  Důvodů pro tuto vysokou
výkonnost je více; o některých z&nbsp;nich se zmíníme v&nbsp;následující
kapitole.</p>

<img src="http://i.iinfo.cz/images/394/pc146-3.png" width="441" height="439" alt=" " />
<p><i>Obrázek 4: Mikroprocesor s&nbsp;instrukční sadou MIPS. Čipy obsahující
jádra těchto RISCových mikroprocesorů se dnes používají v&nbsp;mnoha
vestavěných zařízeních, například přehrávačích videa, routerech atd.</i></p>



<p><a name="k03"></a></p>
<h2 id="k03">3. Přednosti &bdquo;klasických&ldquo; RISCových architektur</h2>

<p>První vlastností, která nejvíce odlišuje původní procesory
s&nbsp;architekturou <i>CISC</i> od procesorů <i>RISC</i> je velmi malý počet
instrukcí tvořících instrukční sadu procesorů <i>RISC</i> a taktéž striktní
oddělení instrukcí pro načítání/ukládání dat do operační paměti a na druhé
straně instrukcí pro provádění aritmetických a logických operací &ndash; i
z&nbsp;tohoto důvodu se někdy procesory <i>RISC</i> nazývají procesory
s&nbsp;architekturou <i>Load&ndash;Store</i>.</p>

<p>Zatímco instrukce určené pro načítání a ukládání dat do operační paměti
pracují s&nbsp;přímou adresou čteného či zapisovaného slova, pracují instrukce
aritmetické a logické striktně pouze s&nbsp;pracovními registry. Díky tomu se
významně zjednodušuje <i>instrukční dekodér</i> a taktéž má naprostá většina
instrukcí shodnou délku, protože například není nutné počítat s&nbsp;tím, že
některý z&nbsp;operandů instrukce <strong>ADD</strong> může být zadán
s&nbsp;využitím složitého adresního režimu (to u <i>RISC</i> není možné).
Z&nbsp;konstantní délky všech instrukcí taktéž nepřímo vyplývá to, že některé
procesory <i>RISC</i> načítají z&nbsp;operační paměti celá 16bitová nebo
32bitová slova a vůbec neobsahují možnost adresování jednotlivých bajtů, což
ještě více zjednodušuje interní architekturu procesoru.</p>

<p>Druhou typickou vlastností procesorů s&nbsp;architekturou <i>RISC</i> je
použití velkého množství pracovních registrů. V&nbsp;závislosti na použité
instrukční sadě se většinou jedná o 16, 32 nebo 64 v&nbsp;dané chvíli
dostupných registrů, přičemž jejich celkový počet může být i vyšší díky použití
registrových oken. Konstruktéři procesorů <i>RISC</i> přistoupili
k&nbsp;použití většího množství pracovních registrů z&nbsp;více důvodů.
Například měli díky neexistenci mikroprogramového řadiče k&nbsp;dispozici
dostatečnou plochu čipu na realizaci pracovních registrů, protože při použití
32 registrů po 32 bitech to znamená nutnost realizovat pouze 1024 bitů pomocí
klopných obvodů.</p>

<img src="http://i.iinfo.cz/images/394/pc146-5.png" width="450" height="450" alt=" " />
<p><i>Obrázek 5: Vývoj osmibitových mikroprocesorů CISC, na němž je patrné, že
i tyto v&nbsp;podstatě velmi jednoduché mikroprocesory byly implementovány
s&nbsp;využitím poměrně velkého množství tranzistorů.</i></p>

<p>Navíc lze do jednodušší instrukční sady relativně snadno zakomponovat i bity
nutné pro adresování pracovních registrů (5 bitů v&nbsp;případě 32 registrů,
tj.&nbsp;10 bitů u dvouadresového kódu). Třetí důvod je však mnohem
důležitější: operace prováděné s&nbsp;pracovními registry jsou mnohem rychlejší
při porovnání s&nbsp;operacemi prováděnými s&nbsp;daty načítanými
z&nbsp;operační paměti, už jen z&nbsp;toho důvodu, že se neblokuje externí
datová a adresová sběrnice. A navíc &ndash; v&nbsp;rozporu s&nbsp;očekáváními
konstruktérů čipů <i>CISC</i> &ndash; se v&nbsp;případě velkého množství
pracovních registrů zjednodušuje práce překladače, který si například může
některé registry rezervovat pro předávání argumentů, jiné ponechat pro
počitadla smyček atd. (to byl alespoň prvotní předpoklad, který však nemusí být
vždy splněn, viz též následující kapitoly).</p>

<img src="http://i.iinfo.cz/images/394/pc146-4.png" width="220" height="220" alt=" " />
<p><i>Obrázek 6: Ultra SPARC II &ndash; další v&nbsp;minulosti velmi často
používaný mikroprocesor s&nbsp;architekturou RISC<br />Zdroj:
Wikipedia.</i></p>



<p><a name="k04"></a></p>
<h2 id="k04">4. Přechod do světa embedded CPU a mikrořadičů</h2>

<p>Vzhledem k&nbsp;vysokému výpočetnímu výkonu mikroprocesorů <i>RISC</i> není
divu, že prakticky všechny výkonné grafické a pracovní stanice procesory
s&nbsp;touto architekturou používaly. Připomeňme si, že na začátku tohoto
období ještě byla hodinová frekvence mikroprocesorů srovnatelná s&nbsp;dobou
přístupu k&nbsp;DRAM, takže se první generace procesorů RISC obešla bez
nutnosti použití instrukčních cache. Posléze se však hodinová frekvence
mikroprocesorů zvyšovala a tak bylo nutné do počítače (či dokonce přímo na čip
s&nbsp;CPU) přidat instrukční cache, což nebylo velkým problémem
v&nbsp;pracovních stanicích (kde se do ceny započítával i drahý disk, velká
DRAM, grafický subsystém atd.), ale pro mnohé další aplikační oblasti bylo toto
řešení již méně akceptovatelné.</p>

<img src="http://i.iinfo.cz/images/188/arm1.jpg" class="image-222275" alt="&#160;" height="220" width="220" />
<p><i>Obrázek 7: Čipy StrongARM založené na architektuře ARMv4 byly
v&nbsp;minulosti velmi oblíbené. Zajímavé je, že původně tyto čipy vyvinula
společnost Digital Equipment Corporation ve spolupráci s&nbsp;firmou ARM a
později byla tato technologie prodána Intelu. Současně se jedná o dobrý příklad
použití RISCových procesorů v&nbsp;jiné oblasti, než jsou výkonné pracovní a
grafické stanice.</i></p>

<p>Touto novou aplikační oblastí jsou mikrořadiče, embedded procesory a SoC.
V&nbsp;této oblasti, především u mikrořadičů, můžeme sledovat vývoj, který
(s&nbsp;mnohaletým zpožděním) kopíruje vývoj, který se stal v&nbsp;oblasti
pracovních stanic a později desktopů, tj.&nbsp;přechod od osmibitových a
16bitových CPU k&nbsp;CPU 32bitovým (to taktéž koresponduje se změnou kernelů a
používaných programovacích jazyků). Oblast osmibitových a 16bitových MCU se zdá
být saturovaná a poměrně stabilní, zatímco trh s&nbsp;32bitovými čipy poměrně
rychle roste. To představuje pro výrobce RISCových procesorů velmi důležitou
oblast, v&nbsp;níž se mohou projevit výhody komprimovaných instrukčních sad, a
to především z&nbsp;toho důvodu, že MCU mívají užší datovou sběrnici, menší
kapacitu instrukční cache a především pak ROM s&nbsp;instrukcemi
implementovanou relativně pomalou technologií Flash. Je zde tedy patrná snaha o
dosažení větší hustoty strojového kódu.</p>

<img src="http://i.iinfo.cz/images/47/arm5.jpg" class="image-222279" alt="&#160;" height="234" width="390" />
<p><i>Obrázek 8: Čipy XMC4000 založené na jádru Cortex-M0. Aplikační oblast:
embedded zařízení.<br />
Autor původní fotky: Davewave88.</i></p>



<p><a name="k05"></a></p>
<h2 id="k05">5. Umění kompromisu</h2>

<p>Cílem autorů &bdquo;komprimovaných&ldquo; instrukčních sad bylo na jedné
straně zachování většiny výhod původních RISCových čipů (jednoduchá pipeline,
vyšší frekvence hodin, obecně vyšší výpočetní výkon, jednoduchá struktura
čipu), na straně druhé pak umožnění zakódování vybraných instrukcí
v&nbsp;16bitových slovech a nikoli ve slovech 32bitových. Už jen z&nbsp;těchto
dvou požadavků plyne, že bylo nutné udělat množství kompromisů, protože je
pochopitelné, že v&nbsp;2<sup>16</sup> možných kódech není možné reprezentovat
všech teoretických 2<sup>32</sup> kombinací.</p>

<img src="http://i.iinfo.cz/images/640/arm6.jpg" class="image-222280" alt="&#160;" height="211" width="336" />
<p><i>Obrázek 9: Jiné zapouzdření čipů XMC4000 založených na jádru Cortex-M0.<br />
Autor původní fotky: Davewave88.</i></p>

<p>Podívejme se, jak tento problém vyřešili tvůrci komprimované instrukční sady
<i>MIPS16e</i>. Ti navrhli instrukce takovým způsobem, že většinu z&nbsp;nich
bylo možné jednoduchým dekodérem rozšířit na původní 32bitové instrukce, takže
samotný dekodér znamenal jen velmi malé zvýšení složitosti CPU (povšimněte si,
že se jedná o zcela odlišný přístup, než který byl z&nbsp;druhé strany řešen u
architektury x86, kde se mnohdy velmi složité CISC instrukce rozkládají na
jednoduší mikrooperace, ale nikoli pouhým dekódováním). Vraťme se však
k&nbsp;<i>MIPS16e</i>. To, že většina komprimovaných instrukcí je obrazem
původních 32bitových instrukcí současně znamená i možnost provedení relativně
malých úprav v&nbsp;překladačích. Zbývá tak určit, jak vlastní komprimaci
provést:</p>

<ol>
<li>Snížením počtu bitů operačního kódu (reprezentovat lze jen některé instrukce)</li>
<li>Snížením počtu registrů v&nbsp;instrukčním slově</li>
<li>Zmenšením šířky konstant v&nbsp;instrukčním slově</li>
</ol>

<p>První bod byl vyřešen s&nbsp;využitím statické analýzy existujících
binárních souborů, což je jediná rozumná možnost, která však na druhou stranu
reflektuje jen současný stav překladačů. Druhý bod byl řešen taktéž na základě
analýzy, kde se ukázalo, že překladače v&nbsp;rámci jedné funkci používají
typicky osm či méně pracovních registrů (což je zvláštní, protože při návrhu
RISC se počítalo s&nbsp;přesným opakem). Proto sice byla zachována možnost
práce se všemi 32 registry, ale pouze osm z&nbsp;nich je dostupných ve všech
operacích. Navíc se musel zmenšit původně tříadresový kód na dvouadresový.
Třetí bod, tj.&nbsp;zmenšení šířky konstant, si vyžádal zavedení nové zvláštní
instrukce <strong>EXTEND</strong> popsané dále.</p>

<img src="http://i.iinfo.cz/images/610/arm7.jpg" class="image-222281" alt="&#160;" height="344" width="390" />
<p><i>Obrázek 10: Mezi další čipy založené na jádru Cortex-M0 patří integrované
obvody STM32 F0.</i></p>



<p><a name="k06"></a></p>
<h2 id="k06">6. Způsoby přepínání mezi klasickou a komprimovanou instrukční sadou</h2>

<p>Tvůrci komprimovaných instrukčních sad museli nalézt vhodný způsob přepínání
mezi novou instrukční sadou a původní RISCovou sadou. Na hardwarové úrovni je
to (pravděpodobně) jednoduché &ndash; na základě stavového bitu se pouze vyřadí
z&nbsp;činnosti výše zmíněný dekodér instrukcí. Na úrovni instrukční sady do
značné míry záleží na tom, zda původní instrukční sada obsahuje možnost
několika bity vyjádřit, že instrukce je jen 16bitová. U původních RISCových
procesorů se s&nbsp;ničím takovým nepočítalo, což znamená, že instrukční sady
<i>MIPS16e</i> a <i>ARM Thumb</i> je nutné povolit nějakou speciální instrukcí,
kterou je typicky instrukce skoku. Mnohem větší možnosti nabízí instrukční sady
v&nbsp;architektuře <i>RISC-V</i>, které jsou od začátku navrhnuty takovým
způsobem, aby se na základě hodnoty dvou nejnižších bitů instrukce dalo
rozhodnout, zda se jedná o 16bitovou instrukci či o instrukci delší. Díky tomu
lze oba způsoby kódování instrukcí &bdquo;mixovat&ldquo; i v&nbsp;rámci jedné
funkce a to bez nutnosti pamatovat si stav procesoru (u ARMu: RISC Mode/Thumb
Mode) a provádět speciální skoky. Nezávisle na způsobu přepínání však existence
jak původní RISCové sady, tak i sady &bdquo;komprimované&ldquo; dovoluje velkou
flexibilitu.</p>

<table>
<tr><th>#</th><th>Architektura</th><th>Způsob přepnutí ISA</th></tr>
<tr><td>1</td><td>MIPS</td><td>spec. instrukce skoku, návrat ze subrutiny, zpracování přerušení</td></tr>
<tr><td>2</td><td>ARM</td><td>spec. instrukce skoku, zpracování přerušení</td></tr>
<tr><td>3</td><td>RISC-V</td><td>každá instrukce má dva bity pro rozlišení mezi ISA</td></tr>
</table>



<p><a name="k07"></a></p>
<h2 id="k07">7. Instrukční sada MIPS16e</h2>

<p>První komprimovanou instrukční sadou, s&nbsp;níž se dnes seznámíme, je sada
nazvaná <i>MIPS16e</i>. Některé informace o této instrukční sadě jsme si již
řekli v&nbsp;předchozích kapitolách, ovšem další informace je nutné doplnit.
Tato instrukční sada doplňuje instrukce MIPS I a MIPS II (32bitové operandy) i
MIPS III (64bitové operandy). Připomeňme si, že původní RISCová MIPS pracuje
s&nbsp;32 registry, z&nbsp;nichž každý má šířku 32 bitů a operační kódy
instrukcí jsou taktéž 32bitové. Tato velká šířka instrukcí umožnila, aby byla
většina ALU instrukcí doplněna o bitový posun operandu; samozřejmě byl
podporován tříadresový kód, tj.&nbsp;použití dvou zdrojových registrů a jednoho
registru cílového. Kvůli snížení počtu instrukcí je jeden z&nbsp;pracovních
registrů nulový (konstantní nula) a navíc se nepoužívají žádné příznakové bity,
protože podmíněný skok je proveden pouze na základě toho, zda je vybraný
pracovní registr roven jinému registru či nikoli. Speciální význam mají dva
registry <strong>HI</strong> a <strong>LO</strong> používané v&nbsp;násobičce a
děličce. Naprostá většina těchto vlastností musela být s&nbsp;přechodem na
<i>MIPS16e</i> změněna.</p>

<a href="http://www.root.cz/obrazek/231682/"><img src="http://i.iinfo.cz/images/686/mips16e-prev.png" class="image-231682" alt="&#160;" height="186" width="370" /></a>
<p><i>Obrázek 11: Zjednodušené schéma překódování instrukcí MIPS16e a MIPS
I,II,III.</i></p>



<p><a name="k08"></a></p>
<h2 id="k08">8. Pracovní a speciální registry používané v&nbsp;instrukční sadě MIPS16e</h2>

<p>V&nbsp;instrukční sadě <i>MIPS16e</i> se naproti tomu možnosti použití
registrů snížily, protože většina ALU instrukcí používá dvouadresový kód (jeden
ze zdrojových registrů je současně i registrem cílovým) a navíc mnoho operací
dokáže pracovat jen s&nbsp;osmi registry r0..r7 mapovanými na původní registry
$16, $17, $2..$7 (první dva registry jsou tedy mapovány jinak, než posledních
šest registrů, a to kvůli používané volací konvenci). Navíc se používá původní
registr $24 ve významu nového podmínkového registru <strong>T</strong>. Aby
bylo možné pracovat se všemi původními pracovními registry, mají programátoři
k&nbsp;dispozici instrukce <strong>MOV32R</strong> a <strong>MOVR32</strong>
pro přenosy dat. Přidány byly i možnosti relativního adresování s&nbsp;využitím
registru <strong>SP</strong> či <strong>PC</strong> jakožto bázového registru,
což například zjednodušilo návrh céčkových zásobníkových rámců a PIC (Position
Independent Code). Poslední dva registry nazvané <strong>HI</strong> a
<strong>LO</strong> jsou využívány násobičkou a děličkou pro uložení
výsledků:</p>

<table>
<tr><th>Režim MIPS16e</th><th>MIPS I,II,III</th></tr>
<tr><td>r0</td><td>$16</td></tr>
<tr><td>r1</td><td>$17</td></tr>
<tr><td>r2</td><td>$2</td></tr>
<tr><td>r3</td><td>$3</td></tr>
<tr><td>r4</td><td>$4</td></tr>
<tr><td>r5</td><td>$5</td></tr>
<tr><td>r6</td><td>$6</td></tr>
<tr><td>r7</td><td>$7</td></tr>
<tr><td>T </td><td>$24</td></tr>
<tr><td>HI</td><td>HI</td></tr>
<tr><td>LO</td><td>LO</td></tr>
</table>



<p><a name="k09"></a></p>
<h2 id="k09">9. Speciální instrukce <strong>EXTEND</strong></h2>

<p>V&nbsp;kontextu RISCových instrukčních sad je poměrně zajímavá existence
instrukce pojmenované <strong>EXTEND</strong>. Tato šestnáctibitová instrukce
(tj.&nbsp;instrukce, jejíž slovo má šířku šestnáct bitů) obsahuje konstantu o
šířce 11 bitů, která se pouze zapamatuje (= pravděpodobně uloží do záchytného
registru, který je součástí dekodéru); žádný další vliv tato instrukce na
činnost mikroprocesoru nemá. Další instrukce, která následuje za
<strong>EXTEND</strong>, může těchto 11 bitů použít k&nbsp;rozšíření velikosti
konstanty, protože v&nbsp;<i>MIPS16e</i> je pro uložení konstanty možné použít
pouze pět bitů v&nbsp;instrukčním slově, což je pro mnoho operací nedostatečné.
Díky <strong>EXTEND</strong> se tedy možnosti použití konstant rozšiřují na 16
bitů, tj.&nbsp;na stejnou velikost, jakou již měla původní instrukční sada
<i>MIPS</i>.</p>

<img src="http://i.iinfo.cz/images/582/pc9903.jpg" width="400" height="285" alt="pc9903" />
<p><i>Obrázek 12: Výkonná a na dobu svého vzniku revoluční grafická stanice Onyx
2 vybavená systémem Infinite Reality. Tato grafická stanice je postavena na
bázi mikroprocesorů R10000 vycházejících z&nbsp;původní architektury
MIPS.</i></p>



<p><a name="k10"></a></p>
<h2 id="k10">10. Podmíněné skoky v&nbsp;instrukční sadě MIPS16e</h2>

<p>Připomeňme si, že původní instrukční sada mikroprocesorů MIPS se vyznačuje
dvěma zvláštnostmi. První z&nbsp;nich je absence registru příznaků
(<i>flags</i>), protože konstruktéři tohoto mikroprocesoru usoudili, že by
používání příznaků typu <i>zero</i>, <i>carry</i>, <i>overflow</i> atd. mohlo
vést ke vzniku konfliktů, kdy by na výsledek jedné instrukce čekala instrukce
další. Kvůli absenci příznaků jsou v&nbsp;původní RISCové instrukční sadě pouze
dva podmíněné skoky <strong>beq</strong> (<i>branch on equal</i>) a
<strong>bne</strong> (<i>branch on not equal</i>), při nichž se skok
provede/neprovede na základě porovnání obsahu dvou pracovních registrů, jejichž
indexy jsou přímo součástí instrukčního slova &ndash; jedná se tedy o instrukce
<i>I-type</i>. Povšimněte si, že díky existenci registru <strong>$zero</strong>
se vlastně zadarmo instrukční sada rozšiřuje o pseudoinstrukce
<strong>bz</strong> (<i>branch on zero</i>) a <strong>bnz</strong> (<i>branch
on non zero</i>). Dále se použití příznaků nahradilo logickými instrukcemi
<strong>slt</strong> (<i>set on less than</i>) a <strong>slti</strong> (<i>set
on less than immediate</i>).</p>

<p>U komprimované instrukční sady <i>MIPS16e</i> by toto schéma podmíněných
skoků nemělo moc velký význam, a to zejména proto, že po zakódování dvou
registrů pro porovnání (2&times;3 bity) by již v&nbsp;instrukčním slovu zbylo
jen málo bitů na uložení relativní adresy skoku (offsetu). Z&nbsp;tohoto důvodu
tvůrci sady <i>MIPS16e</i> zvolili zajímavé řešení, kterým se vlastně částečně
vrátili zpět k&nbsp;některým CISCovým procesorům &ndash; přidali podporu pro
registr nazvaný <strong>T</strong>, do něhož se ukládá výsledek porovnání.
V&nbsp;závislosti na tom, zda je hodnota uložená do registru <strong>T</strong>
nulová či nikoli, je možné provést podmíněný skok s&nbsp;využitím instrukcí
nazvaných <strong>bteqz</strong> (<i>Branch on T Equal to Zero</i>) a
<strong>btnez</strong> (<i>Branch on T Not Equal to Zero</i>). Navíc je možné
provést podmíněný skok na základě porovnání jakéhokoli pracovního registru
<strong>r0</strong> až <strong>r7</strong> s&nbsp;nulou, a to s&nbsp;využitím
instrukcí <strong>beqz</strong> (<i>Branch on Equal to Zero</i>) a
<strong>bnez</strong> (<i>Branch on Not Equal to Zero</i>).</p>

<p>Podmíněné skoky stále doplňují instrukce <strong>slti</strong>,
<strong>sltiu</strong> a <strong>cmpi</strong>, v&nbsp;nichž se porovnává
hodnota vybraného pracovního registru s&nbsp;konstantou. Dále se pro nastavení
hodnoty registru <strong>T</strong> používají instrukce <strong>cmp</strong>,
<strong>slt</strong> a <strong>sltu</strong>.</p>

<a href="http://i.iinfo.cz/images/411/pc9906.jpg"><img src="http://i.iinfo.cz/images/411/pc9906-prev.jpg" width="370" height="95" alt="pc9906" /></a>
<p><i>Obrázek 13: Laboratoř specializovaná na simulace a vizualizace, jejíž
nezbytnou součástí jsou stroje Onyx 2 Infinite Reality, což znamená, že se
jedná o další způsob využití mikroprocesorů s&nbsp;architekturou RISC.</i></p>



<p><a name="k11"></a></p>
<h2 id="k11">11. Seznam instrukcí v&nbsp;sadě MIPS16e</h2>

<p>V&nbsp;této kapitole budou zmíněny všechny instrukce, které je možné
reprezentovat v&nbsp;instrukční sadě MIPS16e. Instrukce jsou podle své funkce
rozděleny do několika kategorií.</p>

<h3>Instrukce typu Load a Store</h3>

<table>
<tr><th>#</th><th>Zkratka</th><th>Význam</th></tr>
<tr><td>1</td><td>LB </td><td>load byte (8bit)</td></tr>
<tr><td>2</td><td>LBU</td><td>load byte unsigned</td></tr>
<tr><td>3</td><td>LH </td><td>load half word (16bit) </td></tr>
<tr><td>4</td><td>LHU</td><td>load half word unsigned</td></tr>
<tr><td>5</td><td>LW </td><td>load word (32bit)</td></tr>
<tr><td>6</td><td>SB </td><td>store byte (8bit)</td></tr>
<tr><td>7</td><td>SH </td><td>store half word (16bit)</td></tr>
<tr><td>8</td><td>SW </td><td>store word (32bit)</td></tr>
</table>



<h3>Instrukce obsahující konstantu (immediate)</h3>

<p>U těchto instrukcí je konstanta součástí instrukčního slova a její šířku je
možné rozšířit s&nbsp;využitím prefixové instrukce <strong>EXTEND</strong>:</p>

<table>
<tr><th>#</th><th>Zkratka</th><th>Význam</th></tr>
<tr><td>1</td><td>ADDIU</td><td>Add Immediate Unsigned</td></tr>
<tr><td>2</td><td>CMPI </td><td>Compare Immediate</td></tr>
<tr><td>3</td><td>LI   </td><td>Load Immediate</td></tr>
<tr><td>4</td><td>SLTI </td><td>Set on Less Than Immediate</td></tr>
<tr><td>5</td><td>SLTIU</td><td>Set on Less Than Immediate Unsigned</td></tr>
</table>



<h3>ALU instrukce pracující s&nbsp;dvojicí registrů</h3>

<table>
<tr><th> #</th><th>Zkratka</th><th>Význam</th></tr>
<tr><td> 1</td><td>ADD </td><td>Add Unsigned</td></tr>
<tr><td> 2</td><td>AND </td><td>AND</td></tr>
<tr><td> 3</td><td>CMP </td><td>Compare</td></tr>
<tr><td> 4</td><td>MOVE</td><td>Move</td></tr>
<tr><td> 5</td><td>NEG </td><td>Negate</td></tr>
<tr><td> 6</td><td>NOT </td><td>Not</td></tr>
<tr><td> 7</td><td>OR  </td><td>OR</td></tr>
<tr><td> 8</td><td>SEB </td><td>Sign-Extend Byte</td></tr>
<tr><td> 9</td><td>SEH </td><td>Sign-Extend Halfword</td></tr>
<tr><td>10</td><td>SLT </td><td>Set on Less Than</td></tr>
<tr><td>11</td><td>SLTU</td><td>Set on Less Than Unsigned</td></tr>
<tr><td>12</td><td>SUBU</td><td>Subtract Unsigned</td></tr>
<tr><td>13</td><td>XOR </td><td>Exclusive OR</td></tr>
<tr><td>14</td><td>ZEB </td><td>Zero-extend Byte</td></tr>
<tr><td>15</td><td>ZEH </td><td>Zero-Extend Halfword</td></tr>
</table>



<h3>Násobení a dělení, přesuny dat do registrů HI a LO</h3>

<p>Při násobení a dělení se používají pro uložení výsledků speciální registry
nazvané <strong>HI</strong> a <strong>LO</strong>, protože násobička a dělička
může (ale nemusí!) pracovat nezávisle na ALU. Proto musí existovat instrukce
umožňující přenos dat z&nbsp;těchto dvou speciálních registrů:</p>

<table>
<tr><th>#</th><th>Zkratka</th><th>Význam</th></tr>
<tr><td>1</td><td>DIV  </td><td>Divide</td></tr>
<tr><td>2</td><td>DIVU </td><td>Divide Unsigned</td></tr>
<tr><td>3</td><td>MFHI </td><td>Move From HI</td></tr>
<tr><td>4</td><td>MFLO </td><td>Move From LO</td></tr>
<tr><td>5</td><td>MULT </td><td>Multiply</td></tr>
<tr><td>6</td><td>MULTU</td><td>Multiply Unsigned</td></tr>
</table>



<h3>Aritmetické a logické posuny</h3>

<table>
<tr><th>#</th><th>Zkratka</th><th>Význam</th></tr>
<tr><td>1</td><td>SRA </td><td>Shift Right Arithmetic</td></tr>
<tr><td>2</td><td>SRAV</td><td>Shift Right Arithmetic Variable</td></tr>
<tr><td>3</td><td>SLL </td><td>Shift Left Logical</td></tr>
<tr><td>4</td><td>SLLV</td><td>Shift Left Logical Variable</td></tr>
<tr><td>5</td><td>SRL </td><td>Shift Right Logical</td></tr>
<tr><td>6</td><td>SRLV</td><td>Shift Right Logical Variable</td></tr>
</table>



<h3>Skoky a podmíněné větvení</h3>

<table>
<tr><th> #</th><th>Zkratka</th><th>Význam</th></tr>
<tr><td> 1</td><td>B    </td><td>Branch Unconditional</td></tr>
<tr><td> 2</td><td>BEQZ </td><td>Branch on Equal to Zero</td></tr>
<tr><td> 3</td><td>BNEZ </td><td>Branch on Not Equal to Zero</td></tr>
<tr><td> 4</td><td>BTEQZ</td><td>Branch on T Equal to Zero</td></tr>
<tr><td> 5</td><td>BTNEZ</td><td>Branch on T Not Equal to Zero</td></tr>
<tr><td> 6</td><td>JAL  </td><td>Jump and Link</td></tr>
<tr><td> 7</td><td>JALR </td><td>Jump and Link Register</td></tr>
<tr><td> 8</td><td>JALRC</td><td>Jump and Link Register Compact</td></tr>
<tr><td> 9</td><td>JALX </td><td>Jump and Link Exchange</td></tr>
<tr><td>10</td><td>JR   </td><td>Jump Register</td></tr>
<tr><td>11</td><td>JRC  </td><td>Jump Register Compact</td></tr>
</table>



<h3>Ostatní instrukce</h3>

<table>
<tr><th>#</th><th>Zkratka</th><th>Význam</th></tr>
<tr><td>1</td><td>RESTORE</td><td>restore registers</td></tr>
<tr><td>2</td><td>SAVE   </td><td>save registers</td></tr>
<tr><td>3</td><td>BREAK  </td><td>break</td></tr>
<tr><td>4</td><td>EXTEND </td><td>rozšíření šířky konstanty další instrukce</td></tr>
</table>

<img src="http://i.iinfo.cz/images/1/pc9910.jpg" width="165" height="244" alt="pc9910" />
<p><i>Obrázek 14: Server s&nbsp;architekturou Onyx 3000.</i></p>



<p><a name="k12"></a></p>
<h2 id="k12">12. Odkazy na Internetu</h2>

<ol>

<li>An Introduction to Lock-Free Programming<br />
<a href="http://preshing.com/20120612/an-introduction-to-lock-free-programming/">http://preshing.com/20120612/an-introduction-to-lock-free-programming/</a>
</li>

<li>Sequential consistency<br />
<a href="https://en.wikipedia.org/wiki/Sequential_consistency">https://en.wikipedia.org/wiki/Sequential_consistency</a>
</li>

<li>Understanding Atomic Operations<br />
<a href="https://jfdube.wordpress.com/2011/11/30/understanding-atomic-operations/">https://jfdube.wordpress.com/2011/11/30/understanding-atomic-operations/</a>
</li>

<li>Load-link/store-conditional<br />
<a href="https://en.wikipedia.org/wiki/Load-link/store-conditional">https://en.wikipedia.org/wiki/Load-link/store-conditional</a>
</li>

<li>The RISC-V Compressed Instruction Set Manual<br />
<a href="http://riscv.org/spec/riscv-compressed-spec-v1.7.pdf">http://riscv.org/spec/riscv-compressed-spec-v1.7.pdf</a>
</li>

<li>Carry bits, The Architect's Trap<br />
<a href="http://yarchive.net/comp/carry_bit.html">http://yarchive.net/comp/carry_bit.html</a>
</li>

<li>Microprocessor Design/ALU Flags<br />
<a href="https://en.wikibooks.org/wiki/Microprocessor_Design/ALU_Flags">https://en.wikibooks.org/wiki/Microprocessor_Design/ALU_Flags</a>
</li>

<li>Flags register in an out-of-order processor<br />
<a href="http://cs.stackexchange.com/questions/42095/flags-register-in-an-out-of-order-processor">http://cs.stackexchange.com/questions/42095/flags-register-in-an-out-of-order-processor</a>
</li>

<li>AMD Am29000<br />
<a href="https://en.wikipedia.org/wiki/AMD_Am29000">https://en.wikipedia.org/wiki/AMD_Am29000</a>
</li>

<li>Status register<br />
<a href="https://en.wikipedia.org/wiki/Status_register">https://en.wikipedia.org/wiki/Status_register</a>
</li>

<li>AMD Am29000 microprocessor family<br />
<a href="http://www.cpu-world.com/CPUs/29000/">http://www.cpu-world.com/CPUs/29000/</a>
</li>

<li>AMD 29k (Streamlined Instruction Processor) ID Guide<br />
<a href="http://www.cpushack.com/Am29k.html">http://www.cpushack.com/Am29k.html</a>
</li>

<li>AMD Am29000 (Wikipedia)<br />
<a href="http://en.wikipedia.org/wiki/AMD_Am29000">http://en.wikipedia.org/wiki/AMD_Am29000</a>
</li>

<li>AMD K5 ("K5" / "5k86")<br />
<a href="http://www.pcguide.com/ref/cpu/fam/g5K5-c.html">http://www.pcguide.com/ref/cpu/fam/g5K5-c.html</a>
</li>

<li>Comparing four 32-bit soft processor cores<br />
<a href="http://www.eetimes.com/author.asp?section_id=14&doc_id=1286116">http://www.eetimes.com/author.asp?section_id=14&doc_id=1286116</a>
</li>

<li>RISC-V Instruction Set<br />
<a href="http://riscv.org/download.html#spec_compressed_isa">http://riscv.org/download.html#spec_compressed_isa</a>
</li>

<li>RISC-V Spike (ISA Simulator)<br />
<a href="http://riscv.org/download.html#isa-sim">http://riscv.org/download.html#isa-sim</a>
</li>

<li>RISC-V (Wikipedia)<br />
<a href="https://en.wikipedia.org/wiki/RISC-V">https://en.wikipedia.org/wiki/RISC-V</a>
</li>

<li>David Patterson (Wikipedia)<br />
<a href="https://en.wikipedia.org/wiki/David_Patterson_(computer_scientist)">https://en.wikipedia.org/wiki/David_Patterson_(computer_scientist)</a>
</li>

<li>OpenRISC (oficiĂĄlnĂ­ strĂĄnky projektu)<br />
<a href="http://openrisc.io/">http://openrisc.io/</a>
</li>

<li>OpenRISC architecture<br />
<a href="http://openrisc.io/architecture.html">http://openrisc.io/architecture.html</a>
</li>

<li>EmulĂĄtor OpenRISC CPU v JavaScriptu<br />
<a href="http://s-macke.github.io/jor1k/demos/main.html">http://s-macke.github.io/jor1k/demos/main.html</a>
</li>

<li>OpenRISC (Wikipedia)<br />
<a href="https://en.wikipedia.org/wiki/OpenRISC">https://en.wikipedia.org/wiki/OpenRISC</a>
</li>

<li>OpenRISC - instrukce<br />
<a href="http://sourceware.org/cgen/gen-doc/openrisc-insn.html">http://sourceware.org/cgen/gen-doc/openrisc-insn.html</a>
</li>

<li>OpenRISC - slajdy z&nbsp;pĹednĂĄĹĄky o projektu<br />
<a href="https://iis.ee.ethz.ch/~gmichi/asocd/lecturenotes/Lecture6.pdf">https://iis.ee.ethz.ch/~gmichi/asocd/lecturenotes/Lecture6.pdf</a>
</li>

<li>Maska mikroprocesoru RISC 1<br />
<a href="http://www.cs.berkeley.edu/~pattrsn/Arch/RISC1.jpg">http://www.cs.berkeley.edu/~pattrsn/Arch/RISC1.jpg</a>
</li>

<li>Maska mikroprocesoru RISC 2<br />
<a href="http://www.cs.berkeley.edu/~pattrsn/Arch/RISC2.jpg">http://www.cs.berkeley.edu/~pattrsn/Arch/RISC2.jpg</a>
</li>

<li>C.E. Sequin and D.A.Patterson: Design and Implementation of RISC I<br />
<a href="http://www.eecs.berkeley.edu/Pubs/TechRpts/1982/CSD-82-106.pdf">http://www.eecs.berkeley.edu/Pubs/TechRpts/1982/CSD-82-106.pdf</a>
</li>

<li>Berkeley RISC<br />
<a href="http://en.wikipedia.org/wiki/Berkeley_RISC">http://en.wikipedia.org/wiki/Berkeley_RISC</a>
</li>

<li>Great moments in microprocessor history<br />
<a href="http://www.ibm.com/developerworks/library/pa-microhist.html">http://www.ibm.com/developerworks/library/pa-microhist.html</a>
</li>

<li>Microprogram-Based Processors<br />
<a href="http://research.microsoft.com/en-us/um/people/gbell/Computer_Structures_Principles_and_Examples/csp0167.htm">http://research.microsoft.com/en-us/um/people/gbell/Computer_Structures_Principles_and_Examples/csp0167.htm</a>
</li>

<li>Great Microprocessors of the Past and Present<br />
<a href="http://www.cpushack.com/CPU/cpu1.html">http://www.cpushack.com/CPU/cpu1.html</a>
</li>

<li>A Brief History of Microprogramming<br />
<a href="http://www.cs.clemson.edu/~mark/uprog.html">http://www.cs.clemson.edu/~mark/uprog.html</a>
</li>

<li>What is RISC?<br />
<a href="http://www-cs-faculty.stanford.edu/~eroberts/courses/soco/projects/2000-01/risc/whatis/">http://www-cs-faculty.stanford.edu/~eroberts/courses/soco/projects/2000-01/risc/whatis/</a>
</li>

<li>RISC vs. CISC<br />
<a href="http://www-cs-faculty.stanford.edu/~eroberts/courses/soco/projects/2000-01/risc/risccisc/">http://www-cs-faculty.stanford.edu/~eroberts/courses/soco/projects/2000-01/risc/risccisc/</a>
</li>

<li>RISC and CISC definitions:<br />
<a href="http://www.cpushack.com/CPU/cpuAppendA.html">http://www.cpushack.com/CPU/cpuAppendA.html</a>
</li>

<li>FPGA<br />
<a href="https://cs.wikipedia.org/wiki/Programovateln%C3%A9_hradlov%C3%A9_pole">https://cs.wikipedia.org/wiki/Programovateln%C3%A9_hradlov%C3%A9_pole</a>
</li>

<li>The Evolution of RISC<br />
<a href="http://www.ibm.com/developerworks/library/pa-microhist.html#sidebar1">http://www.ibm.com/developerworks/library/pa-microhist.html#sidebar1</a>
</li>

<li>SPARC Processor Family Photo<br />
<a href="http://thenetworkisthecomputer.com/site/?p=243">http://thenetworkisthecomputer.com/site/?p=243</a>
</li>

<li>SPARC: Decades of Continuous Technical Innovation<br />
<a href="http://blogs.oracle.com/ontherecord/entry/sparc_decades_of_continuous_technical">http://blogs.oracle.com/ontherecord/entry/sparc_decades_of_continuous_technical</a>
</li>

<li>The SPARC processors<br />
<a href="http://www.top500.org/2007_overview_recent_supercomputers/sparc_processors">http://www.top500.org/2007_overview_recent_supercomputers/sparc_processors</a>
</li>

<li>Reduced instruction set computing (Wikipedia)<br />
<a href="http://en.wikipedia.org/wiki/Reduced_instruction_set_computer">http://en.wikipedia.org/wiki/Reduced_instruction_set_computer</a>
</li>

<li>MIPS architecture (Wikipedia)<br />
<a href="http://en.wikipedia.org/wiki/MIPS_architecture">http://en.wikipedia.org/wiki/MIPS_architecture</a>
</li>

<li>Very long instruction word (Wikipedia)<br />
<a href="http://en.wikipedia.org/wiki/Very_long_instruction_word">http://en.wikipedia.org/wiki/Very_long_instruction_word</a>
</li>

<li>Classic RISC pipeline (Wikipedia)<br />
<a href="http://en.wikipedia.org/wiki/Classic_RISC_pipeline">http://en.wikipedia.org/wiki/Classic_RISC_pipeline</a>
</li>

<li>R2000 Microprocessor (Wikipedia)<br />
<a href="http://en.wikipedia.org/wiki/R2000_(microprocessor)">http://en.wikipedia.org/wiki/R2000_(microprocessor)</a>
</li>

<li>R3000 Microprocessor (Wikipedia)<br />
<a href="http://en.wikipedia.org/wiki/R3000">http://en.wikipedia.org/wiki/R3000</a>
</li>

<li>R4400 Microprocessor (Wikipedia)<br />
<a href="http://en.wikipedia.org/wiki/R4400">http://en.wikipedia.org/wiki/R4400</a>
</li>

<li>R8000 Microprocessor (Wikipedia)<br />
<a href="http://en.wikipedia.org/wiki/R8000">http://en.wikipedia.org/wiki/R8000</a>
</li>

<li>R10000 Microprocessor (Wikipedia)<br />
<a href="http://en.wikipedia.org/wiki/R10000">http://en.wikipedia.org/wiki/R10000</a>
</li>

<li>SPARC (Wikipedia)<br />
<a href="http://en.wikipedia.org/wiki/Sparc">http://en.wikipedia.org/wiki/Sparc</a>
</li>

<li>CPU design (Wikipedia)<br />
<a href="http://en.wikipedia.org/wiki/CPU_design">http://en.wikipedia.org/wiki/CPU_design</a>
</li>

<li>Control unit (Wikipedia)<br />
<a href="http://en.wikipedia.org/wiki/Control_unit">http://en.wikipedia.org/wiki/Control_unit</a>
</li>

</ol>



<p></p><p></p>
<p><small>Autor: <a href="http://www.fit.vutbr.cz/~tisnovpa">Pavel Tišnovský</a> &nbsp; 2015</small></p>
</body>
</html>

