<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
        "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html>
<head>
<title>Osmibitové mikrořadiče Rabbit: praví dědicové mikroprocesoru Zilog Z80</title>
<meta name="Author" content="Pavel Tisnovsky" />
<meta name="Generator" content="vim" />
<meta http-equiv="content-type" content="text/html; charset=utf-8" />
<style type="text/css">
         body {color:#000000; background:#ffffff;}
         h1  {font-family: arial, helvetica, sans-serif; color:#ffffff; background-color:#c00000; text-align:center; padding-left:1em}
         h2  {font-family: arial, helvetica, sans-serif; color:#ffffff; background-color:#0000c0; padding-left:1em; text-align:left}
         h3  {font-family: arial, helvetica, sans-serif; color:#000000; background-color:#c0c0c0; padding-left:1em; text-align:left}
         h4  {font-family: arial, helvetica, sans-serif; color:#000000; background-color:#e0e0e0; padding-left:1em; text-align:left}
         a   {font-family: arial, helvetica, sans-serif;}
         li  {font-family: arial, helvetica, sans-serif; color:#000000; text-align:justify; width:450px;}
         ol  {font-family: arial, helvetica, sans-serif; color:#000000; text-align:justify; width:450px;}
         ul  {font-family: arial, helvetica, sans-serif; color:#000000; text-align:justify; width:450px;}
         p   {font-family: arial, helvetica, sans-serif; color:#000000; text-align:justify;}
         pre {background:#e0e0e0}
</style>
</head>

<body>

<h1>Osmibitové mikrořadiče Rabbit: praví dědicové mikroprocesoru Zilog Z80</h1>

<h3>Pavel Tišnovský</h3>

<p></p>

<h1>Úvodník</h1>

<p>V předchozím článku jsme si popsali osmibitové mikrořadiče řady Z8 a eZ8 navržené společností Zilog. Tyto mikrořadiče navázaly na legendární čip Zilog Z80, ovšem jen nepřímo. Skutečný a nefalšovaný základ Z80 nalezneme v konkurenčních mikrořadičích Rabbit.</p>



<h2>Obsah</h2>

<p><a href="#k01">1. Osmibitové mikrořadiče Rabbit: praví dědicové mikroprocesoru Zilog Z80</a></p>
<p><a href="#k02">2. Zilog Z80 versus procesory Rabbit</a></p>
<p><a href="#k03">3. Registry mikrořadičů Rabbit</a></p>
<p><a href="#k04">4. Registry používané pro adresování instrukcí a operandů</a></p>
<p><a href="#k05">5. Mapa paměti</a></p>
<p><a href="#k06">6. Použití registrů XPC a PC u programů delších než 64 kB</a></p>
<p><a href="#k07">7. Registry určené pro určení tabulky vektorů interních a externích přerušení i pro nastavení priority přerušení</a></p>
<p><a href="#k08">8. Příznakový registr</a></p>
<p><a href="#k09">9. Subsystém pro obsluhu přerušení</a></p>
<p><a href="#k10">10. Instrukční soubor mikrořadičů Rabbit</a></p>
<p><a href="#k11">11. Užitečná rozšíření instrukční sady</a></p>
<p><a href="#k12">12. Šestnáctibitové operace</a></p>
<p><a href="#k13">13. Instrukce, které byly odstraněny</a></p>
<p><a href="#k14">14. Odkazy na Internetu</a></p>



<p><a name="k01"></a></p>
<h2 id="k01">1. Osmibitové mikrořadiče Rabbit: praví dědicové mikroprocesoru Zilog Z80</h2>

<p>Osmibitové mikrořadiče s&nbsp;jádry Z8 a eZ8, s&nbsp;nimiž jsme se seznámili
<a
href="https://www.root.cz/clanky/mikroradice-ez8-aneb-potomek-legendarniho-z80/">v&nbsp;předchozí
části</a> <a href="https://www.root.cz/serialy/co-se-deje-v-pocitaci/">seriálu
o architekturách počítačů a procesorů</a>, byly navrženy ve společnosti Zilog,
tedy ve stejné firmě, v&nbsp;níž dříve vznikl legendární osmibitový
mikroprocesor Zilog Z80 (ten byl posléze vyráběn i dalšími firmami, ať již
s&nbsp;platnou licencí, tak i neoficiálně, což je případ U880 z&nbsp;DDR či
КР1858ВМ1 ze SSSR). Ovšem jádra Z8 a eZ8 se od původní &bdquo;zet
osmdesátky&ldquo; v&nbsp;mnoha ohledech odlišují, což bylo způsobeno odlišnými
požadavky na jednoduchý a málo výkonný mikrořadič s&nbsp;omezenou kapacitou RAM
(do 4kB včetně řídicích registrů). To ale neznamená, že by dnes neexistovaly
žádné nové čipy, které přímo navazují na Z80. Model Z80 i jeho do jisté míry
upravená instrukční sada jsou totiž použity v&nbsp;osmibitových mikrořadičích,
které navrhla společnost Rabbit a nabízí je na svých deskách určených především
pro použití v&nbsp;průmyslu a pro zajištění komunikace mezi různými systémy
(proto jsou mnohé desky Rabbit osazeny Ethernetem a/nebo Wifi modulem).</p>

<p>Mikrořadiče Rabbit jsou poměrně dobře podporovány; existuje pro ně dokonce i
zajímavý překladač Dynamic C, o němž se ještě zmíním v&nbsp;souvislosti
s&nbsp;vývojovými prostředky pro mikrořadiče.</p>

<p>Poznámka: ještě se naposledy zmiňme o současných aktivitách čipů vyráběných
pod značkou Zilog společností IXYS. Kromě řady Z8 a eZ8 se firma orientuje i na
výrobu osmibitových mikrořadičů s&nbsp;jádry S3 a taktéž mikrořadičů odvozených
od známé architektury Intel 8051. Tato jádra nesou jméno Z8051 a od původní
řady 8051 se v&nbsp;mnoha ohledech odlišují, především pak tím, že většina
instrukcí je provedena ve dvou hodinových cyklech a instrukce se mohou
překrývat (podobně jako na prakticky všech moderních CPU). Samozřejmě se zcela
odlišuje výrobní technologie, protože Z8051 je vyráběna 0,18&micro;m
technologií, napájecí napětí může být v&nbsp;rozsahu 1,8V až 5,5V, maximální
frekvence hodinového signálu 16MHz a kapacity paměti se zvýšily na 64 kB Flash
a až 3250 bajtů paměti RAM. Počet čítačů/časovačů se zvýšil na max. 6 a kromě
klasických čtyř portů s&nbsp;GPIO se nově objevuje pátý port a rozhraní pro
řízení LCD, modul pro PWM  (jinými slovy: parametry jsou velmi podobné dalším
mikroprocesorům, které jsou od 8051 taktéž odvozeny).</p>



<p><a name="k02"></a></p>
<h2 id="k02">2. Zilog Z80 versus procesory Rabbit</h2>

<p>Jak jsme si již řekli v&nbsp;perexu tohoto článku, jsou osmibitové
mikrořadiče Rabbit nepřímo založeny na architektuře známých a v&nbsp;minulosti
velmi populárních osmibitových mikroprocesorů Zilog Z80. Ovšem od dob Z80 se
poněkud pozměnila situace na trhu s&nbsp;osmibitovými mikrořadiči, protože dnes
se mj.&nbsp;vyžaduje, aby i osmibitové mikrořadiče dokázaly více či méně
efektivně spouštět aplikace naprogramované v&nbsp;jazyku C (v&nbsp;minulosti
také EC++). Z&nbsp;tohoto důvodu byla částečně pozměněna instrukční sada
&ndash; některé instrukce byly přidány a některé nadbytečné instrukce naopak
odebrány (díky tomu se uvolnilo několik instrukčních kódů, které mohly být
následně použity pro jiné instrukce).</p>

<p>Kvůli změně instrukční sady nejsou procesory Rabbit zpětně binárně
kompatibilní se Z80, ovšem většina aplikací je přenositelná na úrovni
zdrojových (assemblerovských) kódů s&nbsp;případnou náhradou chybějících
instrukcí za volání podprogramů (BCD apod.). Výjimku tvoří ty aplikace, které
intenzivně používají samomodifikující se kód a také aplikace používající I/O
instrukce, protože I/O systém byl kompletně pozměněn.</p>

<p>Mikrořadiče Rabbit jsou v&nbsp;některých ohledech výkonnější, než původní
Z80, a to jak díky použití vyšší hodinové frekvence (od 6 MHz do 30 MHz), tak i
díky tomu, že se samotné instrukce vykonávají v&nbsp;menším počtu cyklů.
V&nbsp;dalších kapitolách se zmíníme i o některých nových adresovacích
režimech, například <strong>LD HL,(SP+offset)</strong> či <strong>LD
(IY+offset),HL</strong>, které mohou být generovány překladačem céčka,
v&nbsp;němž je obvyklé ve funkcích vytvářet zásobníkové rámce,
popř.&nbsp;adresovat prvky struktury předané ukazatelem.</p>

<p>Další změna souvisí se zavedením stránkování, které umožňuje rozšíření
adresového rozsahu z&nbsp;64 kB na jeden megabajt.</p>



<p><a name="k03"></a></p>
<h2 id="k03">3. Pracovní registry mikrořadičů Rabbit</h2>

<p>Vzhledem k&nbsp;tomu, že mikrořadiče Rabbit jsou na úrovni zdrojového kódu
zpětně kompatibilní se Z80, nepřekvapí nás, že se u obou čipů používá stejná
sada pracovních registrů. Jedná se o sedm registrů nazvaných
<strong>A</strong>, <strong>B</strong>, <strong>C</strong>, <strong>D</strong>,
<strong>H</strong> a <strong>L</strong>. Každý z&nbsp;těchto registrů má šířku
osm bitů, ovšem pro některé operace je možné vždy dva registry spojit do
šestnáctibitového páru. Takto vznikají páry <strong>BC</strong>,
<strong>DE</strong> a <strong>HL</strong>. První registr <strong>A</strong>
(akumulátor) se spojuje s&nbsp;příznakovým registrem <strong>F</strong> a tvoří
tak registrový pár <strong>AF</strong>:</p>

<table>
<tr><th>#</th><th>Registr 1</th><th>Registr 2</th><th>16bitový pár</th></tr>
<tr><td>1</td><td>A</td><td>F</td><td>AF</td></tr>
<tr><td>2</td><td>B</td><td>C</td><td>BC</td></tr>
<tr><td>3</td><td>D</td><td>E</td><td>DE</td></tr>
<tr><td>4</td><td>H</td><td>L</td><td>HL</td></tr>
</table>

<p>Všech sedm pracovních registrů i registr příznaků jsou ve skutečnosti
zdvojeny, protože existuje ještě druhá banka s&nbsp;těmito registry. Původní
mikroprocesor Z80 byl totiž určen pro řízení tiskáren, chytrých terminálů
(dobové jméno) apod., kde se mnohdy vyžadovaly rychlé přerušovací rutiny, které
mohly využívat právě druhou banku registrů (banku lze přepnout jednou či dvěma
instrukcemi, což je rychlejší, než snaha o uložení všech registrů na zásobník
popř.&nbsp;obnova registrů na konci rutiny). Ovšem po vzniku domácích
osmibitových mikropočítačů se začala druhá banka využívat i v&nbsp;běžných
programech, což je samozřejmě možné i u mikrořadičů Rabbit:</p>

<table>
<tr><th>#</th><th>Registr 1</th><th>Registr 2</th><th>16bitový pár</th></tr>
<tr><td>1</td><td>A'</td><td>F'</td><td>AF'</td></tr>
<tr><td>2</td><td>B'</td><td>C'</td><td>BC'</td></tr>
<tr><td>3</td><td>D'</td><td>E'</td><td>DE'</td></tr>
<tr><td>4</td><td>H'</td><td>L'</td><td>HL'</td></tr>
</table>



<p><a name="k04"></a></p>
<h2 id="k04">4. Registry používané pro adresování instrukcí a operandů</h2>

<p>Další skupina registrů slouží pro adresování instrukcí a operandů.
Programátoři mají k&nbsp;dispozici dva šestnáctibitové index registry nazvané
<strong>IX</strong> a <strong>IY</strong>, ovšem i registrový pár
<strong>HL</strong> může sloužit jako další indexový registr. Při ukládání
operandů a návratových adres na zásobník je využíván šestnáctibitový ukazatel
na vrchol zásobníku <strong>SP</strong>. Pro adresování instrukcí se používá
taktéž šestnáctibitový registr <strong>PC</strong>, který je navíc doplněn
registrem <strong>XPC</strong>, jehož přesný význam si vysvětlíme
v&nbsp;následujících dvou kapitolách:</p>

<table>
<tr><th>#</th><th>Jméno registru</th><th>Šířka</th><th>Význam</th></tr>
<tr><td>1</td><td>IX</td><td>16 bitů</td><td>index registr</td></tr>
<tr><td>2</td><td>IY</td><td>16 bitů</td><td>index registr</td></tr>
<tr><td>3</td><td>HL</td><td>16 bitů</td><td>registrový pár použitelný jako index registr (viz <a href="#k03">předchozí kapitolu</a>)</td></tr>
<tr><td>4</td><td>SP</td><td>16 bitů</td><td>ukazatel na vrchol zásobníku</td></tr>
<tr><td>5</td><td>PC</td><td>16 bitů</td><td>programový čítač</td></tr>
<tr><td>6</td><td>XPC</td><td>8 bitů</td><td>rozšíření programového čítače (viz <a href="#k05">následující kapitolu</a>)</td></tr>
</table>



<p><a name="k05"></a></p>
<h2 id="k05">5. Mapa paměti</h2>

<p>Registr <strong>XPC</strong> umožňuje zvětšení paměti s&nbsp;programovým
kódem z&nbsp;64 kB až na jeden megabajt. V&nbsp;tomto případě je ovšem nutné
používat adresy o šířce 20 bitů a nikoli pouze 16 bitů. Právě k&nbsp;tomuto
účelu je používán <strong>XPC</strong>, protože ten určuje právě aktivní
<i>stránku</i> v&nbsp;paměti programu. Pro vysvětlení, jak aktivní stránky
fungují, se nejdříve podívejme, jak vypadá mapa paměti z&nbsp;pohledu
programátora (jedná se o logický adresový prostor):</p>

<pre>
FFFF +----------------+
     |                | 4kB
F000 |..XPC segment...|
     |                | 4kB
E000 +----------------+
     |                |
     |  stack segment | 4kB
     |                |
D000 +----------------+
     |                |
     |                |
     |  data segment  | 24 kB
     |                |
     |                |
     |                |
7000 +----------------+
     |                |
     |                |
     |                |
     |  root segment  | 28 kB
     |                |
     |                |
     |                |
0000 +----------------+
</pre>

<p>Vidíme, že adresovatelná oblast 64 kB je rozdělena do čtyř takzvaných
segmentů s&nbsp;následujícím významem:</p>

<ol>

<li>V&nbsp;<i>root segmentu</i>, který je nejrozsáhlejší, je uložen programový
kód. Pokud je celý program (a konstanty) menší než 28 kB, je vhodné ho uložit
právě do root segmentu, protože načítání z&nbsp;této oblasti paměti je
rychlejší, než při použití <i>XPC segmentu</i>. Tato oblast je většinou fyzicky
mapována do FLASH EEPROM, ovšem program lze spouštět i z&nbsp;RAM, například
při ladění apod.</li>

<li><i>Data segment</i> má velikost maximálně 24 kB a jedná se pochopitelně o
oblast fyzicky mapovanou do RAM. Teoreticky je možné, aby byla kapacita RAM
ještě větší, v&nbsp;tomto případě se používá stránkování (u většiny čipů je
však kapacita RAM spíše menší).</li>

<li><i>Stack segment</i> je opět představován RAM a právě do této oblasti
ukazuje registr <strong>SP</strong>.</li>

<li><i>XPC segment</i> o velikosti 8 kB je rozdělena do dvou menších oblastí
(oken), kde každé okno má velikost 4 kB. Tato logická paměťová oblast je
mapována do fyzické paměti FLASH EEPROM o maximální kapacitě 1 MB.</li>

</ol>

<p>Poznámka: u některých čipů jsou hranice mezi datovým a root segmentem
konfigurovatelné. Můžeme nalézt i čipy, kde je hranice nastavena na adrese
0x6000, tj.&nbsp;root segment je o 4kB menší a datový segment naopak o 4kB
větší.</p>



<p><a name="k06"></a></p>
<h2 id="k06">6. Použití registrů XPC a PC u programů delších než 64 kB</h2>

<p>Jak jsme si řekli v&nbsp;předchozí kapitole, představuje nejvyšších osm
kilobajtů adresovatelné <i>logické paměti</i> takzvané <i>okno</i>
(<i>window</i>) do paměti fyzické. Granularita je přitom nastavena na čtyři
kilobajty, tj.&nbsp;okno se po fyzické paměti o maximální kapacitě 1 MB
posunuje po skocích o velikosti 4096 adres. Lze snadno spočítat, že existuje
přesně 256 těchto oken a index právě aktivního okna (mapovaného na logické
adresy 0xE000 až 0xEFFF) je uložen do registru <strong>XPC</strong>. Okno
s&nbsp;indexem n+1 je mapováno na adresy 0xF000 až 0xFFFF.</p>

<p>Všechny běžné instrukce skoků, volání subrutin i návratů ze subrutin pracují
v&nbsp;rámci logického šestnáctibitového prostoru a tudíž nijak nemění
<strong>XPC</strong>. Ovšem existují takzvané &bdquo;dlouhé&ldquo; skoky a
volání (<strong>LJP</strong>, <strong>LCALL</strong> a <strong>LRET</strong>),
které již <strong>XPC</strong> dokážou měnit resp.&nbsp;obnovit. Typické
chování procesoru je takové, že při skoku nad adresu 0xF000 dojde ke zvýšení
indexu okna o jedničku (&bdquo;sliding window&ldquo;).</p>

<p>Poznámka: povšimněte si, že se jedná o jiný způsob adresování, než je způsob
(nechvalně) známý z&nbsp;procesorů Intel 8086. U 8086 se totiž používalo
adresování typu segment+offset pro všechny instrukce a pro celý adresový
rozsah. U mikrořadičů Rabbit se okno do fyzické paměti uplatňuje pouze
v&nbsp;případě použití horních osmi kilobajtů.</p>



<p><a name="k07"></a></p>
<h2 id="k07">7. Registry určené pro určení tabulky vektorů interních a externích přerušení i pro nastavení priority přerušení</h2>

<p>Další tři registry mají speciální význam, protože slouží pro ovládání
subsystému určeného pro práci s&nbsp;interními i externími přerušeními. Zatímco
původní mikroprocesor Z80 obsahoval jen jediný registr nazvaný
<strong>I</strong> (do něj se zapisovalo horních osm bitů adresy, na níž se
nacházely vektory &ndash; šestnáctibitové cílové adresy &ndash; přerušovacích
rutin), jsou mikrořadiče v&nbsp;tomto ohledu nepatrně složitější, což souvisí
s&nbsp;větším množstvím interních a externích periferií. Z&nbsp;registru
<strong>I</strong> byly vytvořeny dva samostatné registry nazvané
<strong>EIR</strong> a <strong>IIR</strong> s&nbsp;podobnou funkcí, ovšem
<strong>EIR</strong> je určen pro specifikaci tabulky vektorů obsluhy externích
přerušení (až 128 vstupů), kdežto <strong>IIR</strong> pro interní přerušení
(taktéž 128 vstupů resp.&nbsp;přesněji řečeno zdrojů). Interně se tato změna
projevila tak, že se <strong>EIR</strong> v&nbsp;instrukcích adresuje stejně
jako původní registr <strong>I</strong>, zatímco <strong>IIR</strong> se adresuje
podobně jako již neexistující registr <strong>R</strong>.</p>

<p>Poslední (nový) registr, který se jmenuje <strong>IP</strong>, je taktéž
osmibitový. Tento registr je rozdělen do čtyř bitových polí, každé má tedy
šířku dva bity. Hodnoty zapsané do těchto bitových polí zaznamenávají historii
priorit přerušení, což je téma, které si vysvětlíme v&nbsp;dalším textu.</p>

<table>
<tr><th>Jméno registru</th><th>Šířka</th><th>Význam</th></tr>
<tr><td>IIR</td><td>8 bitů</td><td>Internal Interrupt Register</td></tr>
<tr><td>EIR</td><td>8 bitů</td><td>External Interrupt Register</td></tr>
<tr><td>IP</td><td>8 bitů (4&times;2 bity)</td><td>Interrupt Priority Register</td></tr>
</table>



<p><a name="k08"></a></p>
<h2 id="k08">8. Příznakový registr</h2>

<p>Příznakový registr <strong>F</strong> je osmibitový, ovšem pouze čtyři bity
jsou nastavovány (vybranými) instrukcemi. Další bity lze modifikovat nepřímo
instrukcí <strong>POP AF</strong>:</p>

<table>
<tr><th>Bit</th><th>Označení</th><th>Jméno</th><th>Význam</th></tr>
<tr><td>0</td><td>C</td><td>carry</td><td>příznak přenosu</td></tr>
<tr><td>1</td><td>&times;</td><td>nepoužit</td><td>nepoužit</td></tr>
<tr><td>2</td><td>V</td><td>overflow</td><td>příznak přetečení</td></tr>
<tr><td>3</td><td>&times;</td><td>nepoužit</td><td>nepoužit</td></tr>
<tr><td>4</td><td>&times;</td><td>nepoužit</td><td>nepoužit</td></tr>
<tr><td>5</td><td>&times;</td><td>nepoužit</td><td>nepoužit</td></tr>
<tr><td>6</td><td>Z</td><td>zero</td><td>příznak nulovosti</td></tr>
<tr><td>7</td><td>S</td><td>sign</td><td>příznak znaménka</td></tr>
</table>

<p>Povšimněte si, že není použit ani příznak <strong>N</strong> ani příznak
<strong>H</strong>. Absence příznaku <strong>H</strong> vlastně znamená, že
nelze použít instrukci <strong>DAA</strong>, která skutečně byla
z&nbsp;instrukčního souboru odstraněna, o čemž se zmiňujeme <a
href="#k13">v&nbsp;kapitole 13</a>.</p>

<p>Poznámka: pamětníci, kteří znají assembler původního mikroprocesoru Z80, si
pravděpodobně povšimli, že nebyl popsán registr <strong>R</strong>. Tento
registr skutečně není v&nbsp;mikrořadičích Rabbit použit, protože se zcela
změnil způsob práce s&nbsp;paměťovými čipy. Opět se jedná o jednu
z&nbsp;několika nekompatibilit, která může ovlivnit ten software, který
používal registr <strong>R</strong> jako generátor pseudonáhodných čísel atd.
(v&nbsp;praxi to však pravděpodobně nebude tak časté, protože takový software
by byl stejně pevně svázán s&nbsp;dalším hardware a navíc i s&nbsp;původní
hodinovou frekvencí; příkladem může být &bdquo;čítač&ldquo; implementovaný
v&nbsp;ZX 81).</p>



<p><a name="k09"></a></p>
<h2 id="k09">9. Subsystém pro obsluhu přerušení</h2>

<p>Subsystém, který se stará o obsluhu přerušení, prošel poměrně velkým
redesignem, protože původní přerušovací subsystém procesorů Z80 podporoval
pouze dvě priority přerušení &ndash; nemaskovatelná přerušení a přerušení
maskovatelná. U procesorů Rabbit existují celkem tři priority přerušení (1, 2 a
3) a samotný procesor se může nacházet v&nbsp;jedné ze čtyř úrovní (0, 1, 2 a
3). V&nbsp;případě, že dojde ke vzniku externího či interního přerušení
(resp.&nbsp;přesněji řečeno k&nbsp;požadavku na reakci na přerušení), obvody
v&nbsp;CPU porovnají prioritu tohoto přerušení a aktuální úrovně, v&nbsp;níž se
procesor nachází. Pokud je priorita přerušení (ostře) větší, než aktuální
úroveň, v&nbsp;níž se procesor nachází, začne se v&nbsp;další instrukci
vykonávat přerušovací rutina s&nbsp;touto vyšší prioritou, jak je to ostatně
naznačeno v&nbsp;následující tabulce. Běžný programový kód je prováděn
v&nbsp;úrovni 0, což znamená, že jakékoli přerušení vyvolá přerušovací
rutinu:</p>

<table>
<tr><th>Úroveň procesoru</th><th>Chování při příchodu přerušení</th></tr>
<tr><td>0</td><td>všechna přerušení s&nbsp;prioritami 1, 2 a 3 jsou zpracována</td></tr>
<tr><td>1</td><td>přednostně zpracována jsou přerušení s&nbsp;prioritami 2 a 3</td></tr>
<tr><td>2</td><td>přednostně zpracována jsou přerušení s&nbsp;prioritou 3</td></tr>
<tr><td>3</td><td>žádná přerušení kromě instrukcí RST nemají přednost</td></tr>
</table>

<p>V&nbsp;praxi má většina přerušení prioritu 1, pouze u těch zařízení, které
vyžadují velmi rychlou odezvu, se úroveň nastavuje na 2 či dokonce na 3
(rychlou odezvou se v&nbsp;kontextu mikrořadičů Rabbit myslí reakce do 20
hodinových cyklů).</p>

<p>S&nbsp;úrovněmi, na kterých se může nacházet procesor, úzce souvisí obsah
registru <strong>IP</strong>. Ten můžeme považovat za zásobník s&nbsp;maximálně
čtyřmi prvky (každý má dva bity), do něhož se ukládají a z&nbsp;něhož se
obnovují úrovně, ve kterých se procesor nacházel. Pro obnovu předchozího stavu
se používá instrukce <strong>IPRES</strong> a vzhledem k&nbsp;tomu, že pouhé
čtyři prvky nemusí dostačovat, obsahuje instrukční sada nové instrukce
<strong>PUSH IP</strong> a <strong>POP IP</strong>, které použijí skutečný
zásobník. Nová priorita se do <strong>IP</strong> uloží instrukcí <strong>IPSET
[0..3]</strong>.</p>



<p><a name="k10"></a></p>
<h2 id="k10">10. Instrukční soubor mikrořadičů Rabbit</h2>

<p>Jak již víme z&nbsp;předchozího textu, je instrukční soubor osmibitových
mikrořadičů Rabbit odvozen od instrukčního souboru procesorů Zilog Z80 a jeho
vylepšené (přesněji řečeno upravené) varianty Zilog Z180. Většina běžných
instrukcí zůstala zachována, ovšem 25 instrukcí bylo odstraněno, což je téma,
kterému se věnujeme <a href="#k13">ve třinácté kapitole</a>. Naproti tomu byly
některé instrukce přidány a &ndash; co je v&nbsp;praxi důležitější &ndash; se
další instrukce rozšířily o nové adresovací režimy a/nebo o možnost používat
šestnáctibitové operandy uložené v&nbsp;registrovém páru.</p>

<p>Pro připomenutí si ukažme všechny původní instrukce procesoru Z80, a to
v&nbsp;abecedním pořadí:</p>

<table>
<tr><th>Instrukce</th><th>Původní název</th></tr>
<tr><td>ADC A,s   </td><td>Add with Carry</td></tr>
<tr><td>ADC HL,ss </td><td>Add with Carry</td></tr>
<tr><td>ADD A,s   </td><td>Add</td></tr>
<tr><td>ADD HL,ss </td><td>Add</td></tr>
<tr><td>ADD IX,pp </td><td>Add</td></tr>
<tr><td>ADD IY,rr </td><td>Add</td></tr>
<tr><td>AND s     </td><td>Logical AND</td></tr>
<tr><td>BIT b,m   </td><td>Test Bit</td></tr>
<tr><td>CALL cc,nn</td><td>Conditional Call</td></tr>
<tr><td>CALL nn   </td><td>Unconditional Call</td></tr>
<tr><td>CCF       </td><td>Complement Carry Flag</td></tr>
<tr><td>CP s      </td><td>Compare</td></tr>
<tr><td>CPD       </td><td>Compare and Decrement</td></tr>
<tr><td>CPDR      </td><td>Compare, Decrement, Repeat</td></tr>
<tr><td>CPI       </td><td>Compare and Increment</td></tr>
<tr><td>CPIR      </td><td>Compare, Decrement, Repeat</td></tr>
<tr><td>CPL       </td><td>Complement</td></tr>
<tr><td>DAA       </td><td>Decimal Adjust Accumulator</td></tr>
<tr><td>DEC s     </td><td>Decrement</td></tr>
<tr><td>DEC xx    </td><td>Decrement</td></tr>
<tr><td>DEC ss    </td><td>Decrement</td></tr>
<tr><td>DI        </td><td>Disable Interrupts</td></tr>
<tr><td>DJNZ e    </td><td>Decrement, Jump Non-Zero</td></tr>
<tr><td>EI        </td><td>Enable Interrupts</td></tr>
<tr><td>EX [SP],HL</td><td>Exchange</td></tr>
<tr><td>EX [SP],xx</td><td>Exchange</td></tr>
<tr><td>EX AF,AF' </td><td>Exchange</td></tr>
<tr><td>EX DE,HL  </td><td>Exchange</td></tr>
<tr><td>EXX       </td><td>Exchange</td></tr>
<tr><td>HALT      </td><td>Halt</td></tr>
<tr><td>IM n      </td><td>Interrupt Mode</td></tr>
<tr><td>IN A,[n]  </td><td>Input</td></tr>
<tr><td>IN r,[C]  </td><td>Input</td></tr>
<tr><td>INC r     </td><td>Increment</td></tr>
<tr><td>INC [HL]  </td><td>Increment</td></tr>
<tr><td>INC xx    </td><td>Increment</td></tr>
<tr><td>INC [xx+d]</td><td>Increment</td></tr>
<tr><td>INC ss    </td><td>Increment</td></tr>
<tr><td>IND       </td><td>Input and Decrement</td></tr>
<tr><td>INDR      </td><td>Input, Decrement, Repeat</td></tr>
<tr><td>INI       </td><td>Input and Increment</td></tr>
<tr><td>INIR      </td><td>Input, Decrement, Repeat</td></tr>
<tr><td>JP [HL]   </td><td>Unconditional Jump</td></tr>
<tr><td>JP [xx]   </td><td>Unconditional Jump</td></tr>
<tr><td>JP nn     </td><td>Unconditional Jump</td></tr>
<tr><td>JP cc,nn  </td><td>Conditional Jump</td></tr>
<tr><td>JR e      </td><td>Unconditional Jump</td></tr>
<tr><td>JR cc,e   </td><td>Conditional Jump</td></tr>
<tr><td>LD dst,src</td><td>Load</td></tr>
<tr><td>LD A,i    </td><td>Load</td></tr>
<tr><td>LDD       </td><td>Load and Decrement</td></tr>
<tr><td>LDDR      </td><td>Load, Decrement, Repeat</td></tr>
<tr><td>LDI       </td><td>Load and Increment</td></tr>
<tr><td>LDIR      </td><td>Load, Increment, Repeat</td></tr>
<tr><td>NEG       </td><td>Negate</td></tr>
<tr><td>NOP       </td><td>No Operation</td></tr>
<tr><td>OR s      </td><td>Logical inclusive OR</td></tr>
<tr><td>OTDR      </td><td>Output, Decrement, Repeat</td></tr>
<tr><td>OTIR      </td><td>Output, Increment, Repeat</td></tr>
<tr><td>OUT [C],r </td><td>Output</td></tr>
<tr><td>OUT [n],A </td><td>Output</td></tr>
<tr><td>OUTD      </td><td>Output and Decrement</td></tr>
<tr><td>OUTI      </td><td>Output and Increment</td></tr>
<tr><td>POP xx    </td><td>Pop</td></tr>
<tr><td>POP qq    </td><td>Pop</td></tr>
<tr><td>PUSH xx   </td><td>Push</td></tr>
<tr><td>PUSH qq   </td><td>Push</td></tr>
<tr><td>RES b,m   </td><td>Reset bit</td></tr>
<tr><td>RET       </td><td>Return</td></tr>
<tr><td>RET cc    </td><td>Conditional Return</td></tr>
<tr><td>RETI      </td><td>Return from Interrupt</td></tr>
<tr><td>RETN      </td><td>Return from NMI</td></tr>
<tr><td>RL m      </td><td>Rotate Left</td></tr>
<tr><td>RLA       </td><td>Rotate Left Accumulator</td></tr>
<tr><td>RLC m     </td><td>Rotate Left Circular</td></tr>
<tr><td>RLCA      </td><td>Rotate Left Circular</td></tr>
<tr><td>RLD       </td><td>Rotate Left 4 bits</td></tr>
<tr><td>RR m      </td><td>Rotate Right</td></tr>
<tr><td>RRA       </td><td>Rotate Right Accumulator</td></tr>
<tr><td>RRC m     </td><td>Rotate Right Circular</td></tr>
<tr><td>RRCA      </td><td>Rotate Right Circular</td></tr>
<tr><td>RRD       </td><td>Rotate Right 4 bits</td></tr>
<tr><td>RST p     </td><td>Restart</td></tr>
<tr><td>SBC A,s   </td><td>Subtract with Carry</td></tr>
<tr><td>SBC HL,ss </td><td>Subtract with Carry</td></tr>
<tr><td>SCF       </td><td>Set Carry Flag</td></tr>
<tr><td>SET b,m   </td><td>Set bit</td></tr>
<tr><td>SLA m     </td><td>Shift Left Arithmetic</td></tr>
<tr><td>SRA m     </td><td>Shift Right Arithmetic</td></tr>
<tr><td>SRL m     </td><td>Shift Right Logical</td></tr>
<tr><td>SUB s     </td><td>Subtract</td></tr>
<tr><td>XOR s     </td><td>Logical Exclusive OR</td></tr>
</table>

<p>Význam malých písmen u operandů:</p>

<table>
<tr><th>Zkratka</th><th>Význam</th></tr>
<tr><td>b  </td><td>index bitu 0..7</td></tr>
<tr><td>cc </td><td>kód podmínky u skoků</td></tr>
<tr><td>m  </td><td>pracovní registr r, [HL] nebo [xx+d]</td></tr>
<tr><td>pp </td><td>registrový pár BC, DE, IX nebo SP</td></tr>
<tr><td>qq </td><td>registrový pár AF, BC, DE nebo HL</td></tr>
<tr><td>qq'</td><td>registrový pár AF, BC, DE nebo HL z druhé banky</td></tr>
<tr><td>r  </td><td>pracovní registr A, B, C, D, E, H nebo L</td></tr>
<tr><td>rr </td><td>registrový pár BC, DE, IY nebo SP</td></tr>
<tr><td>s  </td><td>pracovní registr r, hodnota n, [HL] nebo [xx+d]</td></tr>
<tr><td>ss </td><td>registrový pár BC, DE, HL nebo SP</td></tr>
<tr><td>xx </td><td>index registr IX nebo IY</td></tr>
</table>



<p><a name="k11"></a></p>
<h2 id="k11">11. Užitečná rozšíření instrukční sady</h2>

<p>Pro efektivní běh programů napsaných v&nbsp;céčku jsou užitečné adresovací
režimy používající offset přičtený k&nbsp;SP, IX, IY či k&nbsp;HL; tyto režimy
nově podporují i práci se šestnáctibitovými operandy (cílem či zdrojem je
vždycky dvojice HL či HL'):</p>

<pre>
LD HL, (SP+offset)
LD (SP+offset), HL
LD HL, (IX+offset)
LD HL', (IY+offset)
LD HL, (HL+offset)
</pre>

<p>Taktéž došlo k&nbsp;rozšíření možností instrukcí určených pro přenos dat
mezi základní sadou registrů a druhou bankou A', B' ... L' (kupodivu však
neexistují všechny kombinace přenosu zdroj&rarr;cíl u registrových párů):</p>

<pre>
LD A, B    ; každý z registrů A..L může být zdrojem
LD A', B
LD B', B
</pre>

<p>Některé kombinace však nejsou povoleny:</p>

<pre>
LD B', C'  ; možnosti specifikace cílového registru jsou více omezeny
LD A, B'
</pre>

<p>Taktéž došlo k&nbsp;rozšíření sémantiky instrukce <strong>EX</strong>
(prohození obsahu registrových párů):</p>

<pre>
EX DE', HL
EX DE, HL'
EX DE', HL'
EX (SP), HL
EX (SP), IX
EX (SP), IY
</pre>

<p>Načtení konstanty je nyní možné do všech pracovních registrů a do většiny
registrových párů, včetně druhé banky:</p>

<pre>
LD L',  42
LD BC', 1234
LD HL', (1234)   ; použití adresy
</pre>

<p>Poznámka: u některých dalších instrukcí lze použít prefix
<strong>ALTD</strong> pro výběr registru či registrového páru z&nbsp;druhé
banky.</p>

<p>O některých dalších nových instrukcích jsme se již zmínili:
&bdquo;dlouhé&ldquo; skoky a volání subrutin, práce s&nbsp;prioritami přerušení
a registrem <strong>IP</strong> apod.</p>



<p><a name="k12"></a></p>
<h2 id="k12">12. Šestnáctibitové operace</h2>

<p>Již původní mikroprocesory Z80 podporovaly provádění některých operací se
šestnáctibitovými operandy (<strong>ADD HL, xx</strong>, <strong>ADD IX,
xx</strong>, <strong>DEC IX</strong> atd.) což je samozřejmě v&nbsp;mnoha
ohledech užitečné. U procesorů Rabbit se tyto možnosti ještě rozšířily,
například o následující kombinace instrukcí a operandů:</p>

<pre>
RR  HL       ; rotace registrového páru HL přes příznak carry
ADD HL, HL   ; rotace doprava, bez carry na vstupu
ADC HL, HL   ; taktéž rotace doprava, s carry na vstupu
RL  DE
AND IX, DE   ; logické operace
AND IY, DE
AND HL, DE
OR  IX, DE
OR  IY, DE
OR  HL, DE
</pre>

<p>Pro použití v&nbsp;přeložených céčkových programech byla navržena instrukce
<strong>BOOL</strong>, která nastavuje hodnotu registrového páru
<strong>HL</strong> či zvoleného index registru <strong>IX/IY</strong> na
jedničku či nulu (0x0001 resp.&nbsp;0x0000) na základě toho, zda je původně
v&nbsp;registrovém páru/index registru nulová či nenulová hodnota:</p>

<pre>
BOOL HL
BOOL IX
BOOL IY
</pre>

<p>Přidána byla také instrukce <strong>MUL</strong> určená pro vynásobení
obsahu registrového páru <strong>BC</strong> s&nbsp;registrovým párem
<strong>DE</strong>. Výsledek je uložen do
&bdquo;čtyřregistru&ldquo;<strong>HL:BC</strong> a celá instrukce je dokončena
ve dvanácti hodinových cyklech (tato instrukce nemá žádné operandy, zdrojové
registry i registry cílové jsou pevně určeny).</p>



<p><a name="k13"></a></p>
<h2 id="k13">13. Instrukce, které byly odstraněny</h2>

<p>Následující instrukce, které pravděpodobně znají pamětníci mikroprocesorů
Z80 (a taktéž Z180), již nejsou na mikrořadičích Rabbit podporovány:</p>

<table>
<tr><th>Instrukce</th></tr>
<tr><td>DAA </td><td>IN  </td><td>OTIR</td></tr>
<tr><td>HALT</td><td>OUT0</td><td>INDR</td></tr>
<tr><td>DI  </td><td>IN0 </td><td>OTDR</td></tr>
<tr><td>EI  </td><td>SLP </td><td>RRD </td></tr>
<tr><td>IM 0</td><td>OUTI</td><td>RLD </td></tr>
<tr><td>IM 1</td><td>IND </td><td>CPI </td></tr>
<tr><td>IM 2</td><td>OUTD</td><td>CPIR</td></tr>
<tr><td>OUT </td><td>INIR</td><td>CPD </td></tr>
<tr><td>&nbsp;</td><td>&nbsp;</td><td>CPDR</td></tr>
</table>

<p>Tyto nepodporované instrukce lze rozdělit do několika skupin:</p>

<ol>

<li>Některé (vlastně většina) z&nbsp;odstraněných instrukcí souvisí s&nbsp;I/O
systémem Z80, který byl zcela přepracován, takže tyto instrukce již nejsou
zapotřebí. To ovšem znamená, že některé starší aplikace je zapotřebí přepsat
(otázkou je, kolik aplikací pro původní Z80 má smysl reálně provozovat na
deskách s&nbsp;procesory Rabbit).</li>

<li>Další tři instrukce <strong>DAA</strong>, <strong>RRD</strong> a
<strong>RLD</strong> lze v&nbsp;případě potřeby nahradit vhodným podprogramem,
což bude nejvíce problematické u instrukce <strong>DAA</strong> kvůli nutnosti
simulace příznaku H (absence BCD aritmetiky je u mikrořadičů orientovaných na
použití jazyka C vcelku pochopitelná).</li>

<li>Čtyři instrukce <strong>CPI</strong>, <strong>CPIR</strong>,
<strong>CPD</strong> a <strong>CPDR</strong> bylo možné na původním
mikroprocesoru Z80 použít pro porovnání obsahu bloku paměti (maximálně však
<strong>BC</strong> bajtů) s&nbsp;registrem <strong>A</strong>. Podle designérů
procesorů Rabbit nejsou tyto instrukce příliš užitečné, protože koncovou
podmínkou je rovnost dvou prvků (při rovnosti <strong>A=(HL)</strong> se
porovnávání u instrukcí <strong>CPIR/CPDR</strong> zastaví), nikoli nerovnost.
S&nbsp;tímto tvrzením by se dalo úspěšně polemizovat (hledání adresy konce
céčkového řetězce, výpočet délky řetězce apod.), ovšem faktem je, že i tyto
instrukce je nutné nahradit vhodným (delším) programovým kódem.</li>

</ol>

<p>Poznámka: blokové přenosy, tj.&nbsp;instrukce <strong>LDIR</strong> a
<strong>LDDR</strong>, jsou na mikrořadičích Rabbit podporovány.</p>



<p><a name="k14"></a></p>
<h2 id="k14">14. Odkazy na Internetu</h2>

<ol>

<li>Rabbit 2000 Microprocessor<br />
<a href="https://www.digi.com/support/productdetail?pid=4667&amp;type=documentation">https://www.digi.com/support/productdetail?pid=4667&amp;type=documentation</a>
</li>

<li>Rabbit selection guide<br />
<a href="https://www.digi.com/pdf/rabbit-selection-guide.pdf">https://www.digi.com/pdf/rabbit-selection-guide.pdf</a>
</li>

<li>Rabbit Processor Embedded Systems<br />
<a href="https://www.digi.com/products/embedded-systems/rabbitprocessor">https://www.digi.com/products/embedded-systems/rabbitprocessor</a>
</li>

<li>Rabbit Products<br />
<a href="https://www.digi.com/products/rabbit">https://www.digi.com/products/rabbit</a>
</li>

<li>Rabbit 2000 (Wikipedia)<br />
<a href="https://en.wikipedia.org/wiki/Rabbit_2000">https://en.wikipedia.org/wiki/Rabbit_2000</a>
</li>

<li>SDCC - Small Device C Compiler (homepage)<br />
<a href="http://sdcc.sourceforge.net/">http://sdcc.sourceforge.net/</a>
</li>

<li>Small Device C Compiler (Wikipedia)<br />
<a href="https://en.wikipedia.org/wiki/Small_Device_C_Compiler">https://en.wikipedia.org/wiki/Small_Device_C_Compiler</a>
</li>

<li>Dynamic C<br />
<a href="https://en.wikipedia.org/wiki/Rabbit_Semiconductor#Dynamic_C">https://en.wikipedia.org/wiki/Rabbit_Semiconductor#Dynamic_C</a>
</li>

<li>Z80 info<br />
<a href="http://www.z80.info/">http://www.z80.info/</a>
</li>

<li>Zilog (stránka firmy)<br />
<a href="http://www.zilog.com/">http://www.zilog.com/</a>
</li>

<li>Řada Z8 Encore<br />
<a href="http://www.zilog.com/index.php?option=com_product&task=product&businessLine=1&id=2&parent_id=2&Itemid=56">http://www.zilog.com/index.php?option=com_product&task=product&businessLine=1&id=2&parent_id=2&Itemid=56</a>
</li>

<li>New Zilog Z8051 Microcontrollers (už ne "new", článek je z roku 2012)<br />
<a href="http://microcontroller.com/news/Zilog_Z8051.asp">http://microcontroller.com/news/Zilog_Z8051.asp</a>
</li>

<li>Zilog: The First Decade: Z80, Z8 and the Z8000<br />
<a href="http://www.cpushack.com/2010/10/15/zilog-the-first-decade-z80-z8-and-the-z8000/">http://www.cpushack.com/2010/10/15/zilog-the-first-decade-z80-z8-and-the-z8000/</a>
</li>

<li>Docs for: Z8 Microcontroller (archivní stránka)<br />
<a href="http://www.oocities.org/siliconvalley/peaks/3938/z8_home.htm">http://www.oocities.org/siliconvalley/peaks/3938/z8_home.htm</a>
</li>

<li>8-BIT MCU Relevancy in 2011<br />
<a href="http://www.eeweb.com/blog/steve_darrough/8-bit-mcu-relevancy-in-2011">http://www.eeweb.com/blog/steve_darrough/8-bit-mcu-relevancy-in-2011</a>
</li>

<li>Zilog Z8 (Wikipedia)<br />
<a href="https://en.wikipedia.org/wiki/Zilog_Z8">https://en.wikipedia.org/wiki/Zilog_Z8</a>
</li>

<li>8-bit S08<br />
<a href="http://www.nxp.com/products/microcontrollers-and-processors/more-processors/8-16-bit-mcus/8-bit-s08:HCS08">http://www.nxp.com/products/microcontrollers-and-processors/more-processors/8-16-bit-mcus/8-bit-s08:HCS08</a>
</li>

<li>S08QB: 8-bit QB MCUs<br />
<a href="http://www.nxp.com/products/microcontrollers-and-processors/more-processors/8-16-bit-mcus/8-bit-s08/8-bit-s08-3.6v-mcus/8-bit-qb-mcus:S08QB">http://www.nxp.com/products/microcontrollers-and-processors/more-processors/8-16-bit-mcus/8-bit-s08/8-bit-s08-3.6v-mcus/8-bit-qb-mcus:S08QB</a>
</li>

<li>8-bit RS08<br />
<a href="http://www.nxp.com/products/microcontrollers-and-processors/more-processors/8-16-bit-mcus/8-bit-rs08:RS08FAMILY">http://www.nxp.com/products/microcontrollers-and-processors/more-processors/8-16-bit-mcus/8-bit-rs08:RS08FAMILY</a>
</li>

<li>Wikipedia: Motorola 68HC05<br />
<a href="http://en.wikipedia.org/wiki/Motorola_68HC05">http://en.wikipedia.org/wiki/Motorola_68HC05</a>
</li>

<li>Wikipedia: Freescale 68HC08<br />
<a href="http://en.wikipedia.org/wiki/68HC08">http://en.wikipedia.org/wiki/68HC08</a>
</li>

<li>Wikipedia: Freescale 68HC11<br />
<a href="http://en.wikipedia.org/wiki/68HC11">http://en.wikipedia.org/wiki/68HC11</a>
</li>

<li>Wikipedia: Freescale 68HC12<br />
<a href="http://en.wikipedia.org/wiki/Freescale_68HC12">http://en.wikipedia.org/wiki/Freescale_68HC12</a>
</li>

<li>HC05 Processor Families<br />
<a href="http://www.freescale.com/webapp/sps/site/overview.jsp?nodeId=01624684498633">http://www.freescale.com/webapp/sps/site/overview.jsp?nodeId=01624684498633</a>
</li>

<li>HC08 Processor Families<br />
<a href="http://www.freescale.com/webapp/sps/site/overview.jsp?nodeId=01624684497663">http://www.freescale.com/webapp/sps/site/overview.jsp?nodeId=01624684497663</a>
</li>

<li>Digital Core Design 68HC08 - HDL IP Core <br />
<a href="http://www.dcd.pl/acore.php?idcore=82">http://www.dcd.pl/acore.php?idcore=82</a>
</li>

<li>Freescale 68HC11<br />
<a href="http://www.freescale.com/webapp/sps/site/taxonomy.jsp?nodeId=01624684498635">http://www.freescale.com/webapp/sps/site/taxonomy.jsp?nodeId=01624684498635</a>
</li>

<li>Lifecycle of a CPU:<br />
<a href="http://www.cpushack.net/life-cycle-of-cpu.html">http://www.cpushack.net/life-cycle-of-cpu.html</a>
</li>

<li>Great Microprocessors of the Past and Present (V 13.4.0)<br />
<a href="http://jbayko.sasktelwebsite.net/cpu.html">http://jbayko.sasktelwebsite.net/cpu.html</a>
</li>

<li>SPI interface tutorial<br />
<a href="http://www.best-microcontroller-projects.com/spi-interface.html">http://www.best-microcontroller-projects.com/spi-interface.html</a></li>

<li>Serial Peripheral Interface Bus<br />
<a href="http://en.wikipedia.org/wiki/Serial_Peripheral_Interface_Bus">http://en.wikipedia.org/wiki/Serial_Peripheral_Interface_Bus</a></li>

<li>What is SPI?<br />
<a href="http://www.fpga4fun.com/SPI1.html">http://www.fpga4fun.com/SPI1.html</a></li>

<li>SPI - A simple implementation<br />
<a href="http://www.fpga4fun.com/SPI2.html">http://www.fpga4fun.com/SPI2.html</a></li>

<li>Bit-banging<br />
<a href="http://en.wikipedia.org/wiki/Bit-banging">http://en.wikipedia.org/wiki/Bit-banging</a></li>

<li>Joint Test Action Group<br />
<a href="http://en.wikipedia.org/wiki/JTAG">http://en.wikipedia.org/wiki/JTAG</a></li>

<li>I<sup>2</sup>C<br />
<a href="http://en.wikipedia.org/wiki/I2C">http://en.wikipedia.org/wiki/I2C</a></li>

<li>I<sup>2</sup> Background<br />
<a href="http://www.microport.tw/blognew.php?blog_no=7#theory">http://www.microport.tw/blognew.php?blog_no=7#theory</a></li>

<li>H8/3802, 38002S, 38004, 38104 (manuály k&nbsp;čipům)<br />
<a href="https://www.renesas.com/en-us/document/hw-manual?hwLayerShowFlg=true&prdLayerId=184&layerName=H8%252F3802%252C%2B38002S%252C%2B38004%252C%2B38104&coronrService=document-prd-search&hwDocUrl=%2Fen-us%2Fdoc%2Fproducts%2Fmpumcu%2F001%2Frej09b0024_h83802.pdf&hashKey=c5e1fa0a18c01e6c789bc7b5c0184ed9">https://www.renesas.com/en-us/document/hw-manual?hwLayerShowFlg=true&prdLayerId=184&layerName=H8%252F3802%252C%2B38002S%252C%2B38004%252C%2B38104&coronrService=document-prd-search&hwDocUrl=%2Fen-us%2Fdoc%2Fproducts%2Fmpumcu%2F001%2Frej09b0024_h83802.pdf&hashKey=c5e1fa0a18c01e6c789bc7b5c0184ed9</a>
</li>

<li>Addressing mode (Wikipedia)<br />
<a href="https://en.wikipedia.org/wiki/Addressing_mode">https://en.wikipedia.org/wiki/Addressing_mode</a>
</li>

<li>Renesas SH Instruction Set Summary<br />
<a href="http://shared-ptr.com/sh_insns.html">http://shared-ptr.com/sh_insns.html</a>
</li>

<li>SH-4 RISC Processor by HITACHI<br />
<a href="http://www.cs.umd.edu/~meesh/cmsc411/website/projects/risc/risc.htm">http://www.cs.umd.edu/~meesh/cmsc411/website/projects/risc/risc.htm</a>
</li>

<li>SH-4 RISC Processor<br />
<a href="http://www.cs.umd.edu/~meesh/cmsc411/website/projects/risc/sh-4.htm">http://www.cs.umd.edu/~meesh/cmsc411/website/projects/risc/sh-4.htm</a>
</li>

<li>SuperH RISC engine Family Features<br />
<a href="https://www.renesas.com/en-us/products/microcontrollers-microprocessors/superh/superh-features.html">https://www.renesas.com/en-us/products/microcontrollers-microprocessors/superh/superh-features.html</a>
</li>

<li>Orthogonal instruction set<br />
<a href="https://en.wikipedia.org/wiki/Orthogonal_instruction_set">https://en.wikipedia.org/wiki/Orthogonal_instruction_set</a>
</li>

<li>An introduction to the TI MSP430 low-power microcontrollers<br />
<a href="http://mspgcc.sourceforge.net/manual/c68.html">http://mspgcc.sourceforge.net/manual/c68.html</a>
</li>

<li>MSP430 LaunchPad Tutorials<br />
<a href="http://processors.wiki.ti.com/index.php/MSP430_LaunchPad_Tutorials">http://processors.wiki.ti.com/index.php/MSP430_LaunchPad_Tutorials</a>
</li>

<li>LaunchPad MSP430 Assembly Language Tutorial<br />
<a href="http://robotics.hobbizine.com/asmlau.html">http://robotics.hobbizine.com/asmlau.html</a>
</li>

<li>TI 16-bit and 32-bit microcontrollers<br />
<a href="http://www.ti.com/lsds/ti/microcontrollers_16-bit_32-bit/overview.page">http://www.ti.com/lsds/ti/microcontrollers_16-bit_32-bit/overview.page</a>
</li>

<li>Z86E04 Tutorial<br />
<a href="https://tiktakx.wordpress.com/2010/05/04/z86e04-tutorial/">https://tiktakx.wordpress.com/2010/05/04/z86e04-tutorial/</a>
</li>

<li>Z80 Instruction Set<br />
<a href="http://clrhome.org/table/">http://clrhome.org/table/</a>
</li>

<li>8080/Z80 Instruction Set<br />
<a href="http://nemesis.lonestar.org/computers/tandy/software/apps/m4/qd/opcodes.html">http://nemesis.lonestar.org/computers/tandy/software/apps/m4/qd/opcodes.html</a>
</li>

<li>CPDR<br />
<a href="http://z80-heaven.wikidot.com/instructions-set:cpdr">http://z80-heaven.wikidot.com/instructions-set:cpdr</a>
</li>

<li>Z80 MICROPROCESSOR Instruction Set Summary<br />
<a href="http://www.z80.info/z80-op.txt">http://www.z80.info/z80-op.txt</a>
</li>

</ol>



<p></p><p></p>
<p><small>Autor: <a href="http://www.fit.vutbr.cz/~tisnovpa">Pavel Tišnovský</a> &nbsp; 2016</small></p>
</body>
</html>

