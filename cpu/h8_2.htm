<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
        "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html>
<head>
<title>Rodina mikroprocesorů a mikrořadičů H8 (2.část - řada 300H)</title>
<meta name="Author" content="Pavel Tisnovsky" />
<meta name="Generator" content="vim" />
<meta http-equiv="content-type" content="text/html; charset=utf-8" />
<style type="text/css">
         body {color:#000000; background:#ffffff;}
         h1  {font-family: arial, helvetica, sans-serif; color:#ffffff; background-color:#c00000; text-align:center; padding-left:1em}
         h2  {font-family: arial, helvetica, sans-serif; color:#ffffff; background-color:#0000c0; padding-left:1em; text-align:left}
         h3  {font-family: arial, helvetica, sans-serif; color:#000000; background-color:#c0c0c0; padding-left:1em; text-align:left}
         h4  {font-family: arial, helvetica, sans-serif; color:#000000; background-color:#e0e0e0; padding-left:1em; text-align:left}
         a   {font-family: arial, helvetica, sans-serif;}
         li  {font-family: arial, helvetica, sans-serif; color:#000000; text-align:justify; width:450px;}
         ol  {font-family: arial, helvetica, sans-serif; color:#000000; text-align:justify; width:450px;}
         ul  {font-family: arial, helvetica, sans-serif; color:#000000; text-align:justify; width:450px;}
         p   {font-family: arial, helvetica, sans-serif; color:#000000; text-align:justify;}
         pre {background:#e0e0e0}
</style>
</head>

<body>

<h1>Rodina mikroprocesorů a mikrořadičů H8 (2.část - řada 300H)</h1>

<h3>Pavel Tišnovský</h3>

<p></p>

<h1>Úvodník</h1>

<p>Po popisu osmibitových mikroprocesorů a mikrořadičů z rodiny H8, tj. čipů z řady 300 a 300L, se začneme zabývat výkonnějšími čipy postavenými na jádrech 300H. Jedná se o šestnáctibitová jádra, přičemž některé operace mohou probíhat i s 32bitovými operandy.</p>



<h2>Obsah</h2>

<p><a href="#k01">1. Rodina mikroprocesorů a mikrořadičů H8 (2.část - řada 300H)</a></p>
<p><a href="#k02">2. Nejmarkantnější rozdíly mezi řadami 300, 300L a 300H</a></p>
<p><a href="#k03">3. Sada pracovních registrů</a></p>
<p><a href="#k04">4. Programový čítač (PC) a ukazatel na vrchol zásobníku (SP)</a></p>
<p><a href="#k05">5. Stavový a řídicí registr (CCR)</a></p>
<p><a href="#k06">6. Adresovací režimy</a></p>
<p><a href="#k07">7. Změny provedené v&nbsp;instrukční sadě</a></p>
<p><a href="#k08">8. Instrukce nově podporující šestnáctibitové operandy</a></p>
<p><a href="#k09">9. Instrukce nově podporující 32bitové operandy</a></p>
<p><a href="#k10">10. Nové aritmetické instrukce</a></p>
<p><a href="#k11">11. Rozšíření sémantiky instrukce <strong>EEPMOV</strong></a></p>
<p><a href="#k12">12. Další moduly, které lze nalézt na mikrořadiči</a></p>
<p><a href="#k13">13. Sériové porty</a></p>
<p><a href="#k14">14. PWM a ADC</a></p>
<p><a href="#k15">15. Čítače a časovače</a></p>
<p><a href="#k16">16. Odkazy na Internetu</a></p>



<p><a name="k01"></a></p>
<h2 id="k01">1. Rodina mikroprocesorů a mikrořadičů H8 (2.část - řada 300H)</h2>

<p><a
href="https://www.root.cz/clanky/rodina-mikroprocesoru-a-mikroradicu-h8/">V&nbsp;předchozí
části</a> &bdquo;nekonečného&ldquo; seriálu <a
href="https://www.root.cz/serialy/co-se-deje-v-pocitaci/">Co se děje
v&nbsp;počítači</a> jsme se seznámili s&nbsp;mikroprocesorovými a
mikrořadičovými jádry H8/300 a H8/300L. Připomeňme si, že se v&nbsp;obou
případech jedná o osmibitová jádra, přičemž ovšem ve skutečnosti některé
instrukce dokážou pracovat i se šestnáctibitovými operandy. Osmibitové
mikrořadiče se v&nbsp;současnosti stále používají a v&nbsp;některých oblastech
se s&nbsp;velkou pravděpodobností budou používat i nadále, protože pořád
existují požadavky na sice málo výkonný, ale levný čip s&nbsp;malou spotřebou
(ostatně i v&nbsp;amatérské oblasti se tyto čipy prosadily, viz například
populární <i>Arduino</i>). Ovšem ve chvíli, kdy se začínají tvořit rozsáhlejší
aplikace (či řídicí systémy), poměrně brzy narazíme na některé limity
osmibitových mikrořadičů &ndash; ať již se to týká jejich výpočetního výkonu
(což nemusí být tak kritické), tak i maximální kapacity adresovatelné paměti
(typicky max.&nbsp;64 kB). A právě z&nbsp;těchto důvodů nalezneme v&nbsp;rodině
H8 i poněkud výkonnější jádra H8/300H.</p>

<p>Na následujícím obrázku je naznačen postupný vývoj mikroprocesorů a
mikrořadičů patřících do rodiny H8. Svůj původ mají tyto čipy
v&nbsp;osmibitovém jádru H8/300 (bez dalšího písmena na konci). Z&nbsp;tohoto
jádra se vyvinulo taktéž osmibitové jádro H8/300L a 16/32bitové jádro H8/300H.
Dalším odvozením vznikla jádra H8S, která jsou rychlejší a nalezneme u nich
větší množství přídavných modulů, například více čítačů/časovačů,
programovatelný generátor pulsů a zejména pak CAN bus (právě podpora této
sběrnice je prakticky nezbytná pro použití čipů H8 ve vozidlech, ovšem CAN
dnes nalezneme i v&nbsp;dalších aplikacích).</p>

<a href="https://www.root.cz/obrazek/269041/"><img src="https://i.iinfo.cz/images/57/h8-1.png" class="image-269041" alt="&#160;" width="251" height="76" /></a>
<p><i>Obrázek 1: Základní řady mikroprocesorů a mikrořadičů z&nbsp;rodiny H8.
Žlutě jsou zvýrazněny osmibitové čipy (s&nbsp;omezeným repertoárem
šestnáctibitových operací), zeleně pak čipy šestnáctibitové (s&nbsp;omezeným
repertoárem 32bitových operací).</i></p>



<p><a name="k02"></a></p>
<h2 id="k02">2. Nejmarkantnější rozdíly mezi řadami 300, 300L a 300H</h2>

<p>I přes mnoho společných vlastností, které jádra z&nbsp;rodiny H8 sdílí
(podobná a zpětně kompatibilní instrukční sada, kódování instrukcí, stavový a
řídicí registr atd.) samozřejmě nalezneme mezi osmibitovými jádry H8/300 a
H8/300L na straně jedné a H8/300H na straně druhé poměrně velké množství
rozdílů. Nejmarkantnější je rozšíření adresového rozsahu, protože u čipů řady
H8/300H lze adresovat až šestnáct megabajtů RAM/ROM (tyto změny se projevily i
v&nbsp;nabídce adresovacích režimů). Pochopitelně se rozšířily i možnosti
aritmeticko-logické jednotky, protože většinu operací je možné provádět
s&nbsp;osmibitovými i šestnáctibitovými operandy, některé operace dokonce
s&nbsp;operandy o šířce plných 32 bitů. Jak si řekneme hned <a
href="#k03">v&nbsp;navazující kapitole</a>, došlo i k&nbsp;rozšíření množiny
pracovních registrů, ke kterým je možné přistupovat různým způsobem (osmibitové
páry, 16bitový registr, 32bitový registr). I přes tyto rozdíly je zachována
zpětná kompatibilita, takže na jádrech H8/300H lze v&nbsp;případě potřeby
spouštět kód původně přeložený pro osmibitová jádra H8.</p>

<p>Poznámka: v&nbsp;případě potřeby ještě výkonnějších čipů již zpětná
kompatibilita není zachována, protože řada SuperH má i přes některé podobnosti
s&nbsp;H8 odlišnou instrukční sadu.</p>



<p><a name="k03"></a></p>
<h2 id="k03">3. Sada pracovních registrů</h2>

<p>Připomeňme si nejdříve, jak vlastně vypadala sada pracovních registrů na
osmibitových jádrech H8/300. K&nbsp;dispozici bylo celkem šestnáct osmibitových
pracovních registrů rozdělených do dvou skupin RxH a RxL. Vždy dva registry se
stejným indexem, tedy například R1H a R1L bylo možné v&nbsp;některých
instrukcích použít ve funkci šestnáctibitového registru (zde R1):</p>

<table>
<tr><th>8bit registr</th><th>8bit registr</th><th>16bitový pár</th></tr>
<tr><td>R0H</td><td>R0L</td><td>R0</td></tr>
<tr><td>R1H</td><td>R1L</td><td>R1</td></tr>
<tr><td>R2H</td><td>R2L</td><td>R2</td></tr>
<tr><td>R3H</td><td>R3L</td><td>R3</td></tr>
<tr><td>R4H</td><td>R4L</td><td>R4</td></tr>
<tr><td>R5H</td><td>R5L</td><td>R5</td></tr>
<tr><td>R6H</td><td>R6L</td><td>R6</td></tr>
<tr><td>R7H</td><td>R7L</td><td>R7 (též SP)</td></tr>
</table>

<p>U jader H8/300H došlo k&nbsp;důležitému rozšíření, protože
k&nbsp;osmibitovým registrům RxH a RxL bylo přidáno dalších osm registrů Ex
(x=0..7), z&nbsp;nichž každý má šířku šestnáct bitů. Vždy tři registry se
shodným indexem, tedy například E2+R2H+R2L tvoří jeden 32bitový registr nazvaný
ER2. Podívejme se na následující tabulku, která vzájemné vztahy mezi pracovními
registry možná osvětlí:</p>

<table>
<tr><th>16bit registr</th><th>8bit registr</th><th>8bit registr</th><th>16bitový pár</th><th>32bitový registr</th></tr>
<tr><td>E0</td><td>R0H</td><td>R0L</td><td>R0=R0H+R0L</td><td>ER0=E0+R0H+R0L</td></tr>
<tr><td>E1</td><td>R1H</td><td>R1L</td><td>R1=R1H+R1L</td><td>ER1=E1+R1H+R1L</td></tr>
<tr><td>E2</td><td>R2H</td><td>R2L</td><td>R2=R2H+R2L</td><td>ER2=E2+R2H+R2L</td></tr>
<tr><td>E3</td><td>R3H</td><td>R3L</td><td>R3=R3H+R3L</td><td>ER3=E3+R3H+R3L</td></tr>
<tr><td>E4</td><td>R4H</td><td>R4L</td><td>R4=R4H+R4L</td><td>ER4=E4+R4H+R4L</td></tr>
<tr><td>E5</td><td>R5H</td><td>R5L</td><td>R5=R5H+R5L</td><td>ER5=E5+R5H+R5L</td></tr>
<tr><td>E6</td><td>R6H</td><td>R6L</td><td>R6=R6H+R6L</td><td>ER6=E6+R6H+R6L</td></tr>
<tr><td>E7</td><td>R7H</td><td>R7L</td><td>R7=R7H+R7L</td><td>ER7=E7+R7H+R7L</td></tr>
</table>

<p>Je tedy možné říci, že se počet pracovních registrů zdvojnásobil, protože
k&nbsp;dispozici je celkem šestnáct šestnáctibitových registrů: E0..E7 a
R0..R7, které lze v&nbsp;případě potřeby v&nbsp;některých instrukcích spojit do
32bitových registrů ER0..ER7 či naopak některé registry rozdělit na osmibitové
části R0H..R7H a R0L..R7L.</p>

<p>Poznámka: můžeme zde vidět jistou podobnost s&nbsp;architekturou i386, kde
taktéž existuje možnost přistupovat k&nbsp;nejnižším osmi bitům registru EAX
přes alias AL, k&nbsp;vyšším osmi bitům přes alias AH a k&nbsp;nižším šestnácti
bitům přes alias AX. Ovšem již zde není možné explicitně přistoupit
k&nbsp;vyšším 16bitům (něco na způsob AXH) a navíc toto dělení platí pouze pro
čtyři pracovní registry EAX, EBX, ECX a EDX.</p>



<p><a name="k04"></a></p>
<h2 id="k04">4. Programový čítač (PC) a ukazatel na vrchol zásobníku (SP)</h2>

<p>Tato kapitola bude velmi stručná, protože činnost programového čítače
zůstala zachována, pouze se podle očekávání změnila jeho šířka. Původně měl
registr <strong>PC</strong> šířku šestnácti bitů a umožňoval tak adresovat
maximálně 64kB RAM+ROM (H8 nemá oddělené prostory pro RAM a ROM), u jader
H8/300H i H8S byla šířka registru <strong>PC</strong> rozšířena na 24 bitů a
umožňuje tedy adresovat maximálně 16MB paměti. Ukazatel na vrchol zásobníku je
tvořen registrem <strong>ER7</strong>, ovšem opět platí, že zásobník musí ležet
v&nbsp;adresovém rozsahu 16MB, takže by <strong>SP</strong> měl mít nejvyšších
osm bitů vynulovaných (<strong>ER7</strong> slouží jako <strong>SP</strong>
pouze u několika instrukcí, jinak ho lze použít jako běžný pracovní registr;
zde samozřejmě může být v&nbsp;horních osmi bitech libovolná hodnota).</p>



<p><a name="k05"></a></p>
<h2 id="k05">5. Stavový a řídicí registr (CCR)</h2>

<p>Stavový a řídicí registr (<i>Condition Code Register</i>) zůstal prakticky
beze změn, takže má stále šířku osmi bitů, což je zde více než dostatečné:</p>

<pre>
  7   6   5   4   3   2   1   0
+---+---+---+---+---+---+---+---+
| I | U | H | U | N | Z | V | C |
+---+---+---+---+---+---+---+---+
</pre>

<p>Význam jednotlivých bitů stavového a řídicího registru je popsán
v&nbsp;následující tabulce:</p>

<table>
<tr><th>Index</th><th>Příznak</th><th>Význam zkratky</th><th>Poznámka</th></tr>
<tr><td>7</td><td>I</td><td>interrupt</td><td>maskování neboli zákaz IRQ (přerušení)</td></tr>
<tr><td>6</td><td>U</td><td>user bit</td><td>bit, který lze nastavit či testovat instrukcemi LDC, STC, ANDC, ORC a XORC</td></tr>
<tr><td>5</td><td>H</td><td>half carry</td><td>přenos z bitu číslo 3 do bitu číslo 4 (použit instrukcemi DAA a DAS)</td></tr>
<tr><td>4</td><td>U</td><td>user bit</td><td>bit, který lze nastavit či testovat instrukcemi LDC, STC, ANDC, ORC a XORC</td></tr>
<tr><td>3</td><td>N</td><td>negative</td><td>výsledek ALU operace je záporný</td></tr>
<tr><td>2</td><td>Z</td><td>zero</td><td>výsledek ALU operace je nulový</td></tr>
<tr><td>1</td><td>V</td><td>overflow</td><td>přetečení (znaménková aritmetika, signed)</td></tr>
<tr><td>0</td><td>C</td><td>carry</td><td>přenos (bezznaménková aritmetika, unsigned)</td></tr>
</table>



<p><a name="k06"></a></p>
<h2 id="k06">6. Adresovací režimy</h2>

<p>Změny nastaly v&nbsp;nabídce adresovacích režimů, což je vlastně logické,
protože tyto změny velmi úzce souvisí s&nbsp;rozšířením adres z&nbsp;šestnácti
bitů na 24 bitů i s&nbsp;rozšířením šířky pracovních registrů. Dostupné
adresovací režimy jsou shrnuty v&nbsp;následující tabulce:</p>

<table>
<tr><th>Název režimu</th><th>Zápis v&nbsp;asm</th><th>Význam</th></tr>
<tr><td>Register direct</td><td>Rn</td><td>většina instrukcí akceptuje osmibitový i šestnáctibitový registr</td></tr>
<tr><td>Register indirect</td><td>@ERn</td><td>ERn je 32bitový registr obsahující adresu (24 bitů)</td></tr>
<tr><td>Register indirect with displacement</td><td>@(d:16,ERn)</td><td>jako předchozí režim, ovšem navíc se 16bitovým offsetem</td></tr>
<tr><td>Register indirect with displacement</td><td>@(d:24,ERn)</td><td>jako předchozí režim, ovšem navíc s 24bitovým offsetem</td></tr>
<tr><td>Register indirect with post-increment</td><td>@ERn+</td><td>pro instrukce MOV, posun o jeden, dva či čtyři bajty podle typu přenosu</td></tr>
<tr><td>Register indirect with pre-decrement </td><td>@-ERn</td><td>pro instrukce MOV, posun o jeden, dva či čtyři bajty podle typu přenosu</td></tr>
<tr><td>Absolute address</td><td>@aa:8</td><td>za instrukcí následuje osmibitová konstanta, přičte se k&nbsp;ní 0xffff00</td></tr>
<tr><td>Absolute address</td><td>@aa:16</td><td>za instrukcí následuje šestnáctibitová konstanta (prvních 32kB a posledních 32kB ze 16MB)</td></tr>
<tr><td>Absolute address</td><td>@aa:24</td><td>za instrukcí následuje 24bitová konstanta</td></tr>
<tr><td>Immediate</td><td>#xx:8</td><td>za instrukcí následuje osmibitová konstanta</td></tr>
<tr><td>Immediate</td><td>#xx:16</td><td>za instrukcí následuje šestnáctibitová konstanta</td></tr>
<tr><td>Immediate</td><td>#xx:32</td><td>za instrukcí následuje 32bitová konstanta</td></tr>
<tr><td>Program-counter relative</td><td>@(d:8,PC)</td><td>použito pro relativní skoky v rozsahu -126 do 128</td></tr>
<tr><td>Program-counter relative</td><td>@(d:16,PC)</td><td>použito pro relativní skoky v rozsahu -32766 do 32768</td></tr>
<tr><td>Memory indirect</td><td>@@aa:8</td><td>použito u JMP a JSR, na adrese je uložen cíl skoku</td></tr>
</table>

<p>Zajímavý je režim @aa:16, který díky 16bitové konstantě umožňuje adresovat
prvních 32kB paměti (nejvyšší bit konstanty je 0) a posledních 32kB (nejvyšší
bit konstanty je 1). To souvisí s&nbsp;mapováním RAM a ((E)P)ROM do adresního
rozsahu; toto adresování nepreferuje ani RAM ani ROM, ale umožňuje relativně
krátkou instrukcí obsáhnout části obou pamětí.</p>



<p><a name="k07"></a></p>
<h2 id="k07">7. Změny provedené v&nbsp;instrukční sadě</h2>

<p>Instrukční sada i formát instrukčních slov zůstal z&nbsp;důvodů zpětné
kompatibility sice zachován, ale i přesto můžeme v&nbsp;jádrech H8/300H najít
některé změny. Původních 57 (55) instrukcí bylo rozšířeno na 64 (62) instrukcí,
takže nárůst ve skutečnosti není tak velký (čísla v&nbsp;závorkách udávají
počet instrukcí ve chvíli, kdy budeme <strong>PUSH</strong> a
<strong>POP</strong> považovat za pouhé aliasy k&nbsp;instrukci
<strong>MOV</strong> s&nbsp;post-inkrementem či pre-dekrementem adresy).
Instrukce opět můžeme podle jejich funkce rozdělit do devíti kategorií. Tučně
jsou zvýrazněny nové instrukce:</p>

<table>
<tr><th>Skupina</th><th>Instrukce</th><th>Počet</th></tr>
<tr><td>Přenos dat</td><td>MOV, PUSH, POP, MOVTPE, MOVFPE</td><td>5 (3)</td></tr>
<tr><td>Aritmetické</td><td>ADD, SUB, ADDX, SUBX, INC, DEC, ADDS, SUBS, DAA, DAS, MULXU, <strong>MULXS</strong>, DIVXU, <strong>DIVXS</strong>, CMP, NEG, <strong>EXTS</strong>, <strong>EXTU</strong></td><td>18</td></tr>
<tr><td>Logické</td><td>AND, OR, XOR, NOT</td><td>4</td></tr>
<tr><td>Posuny a rotace</td><td>SHAL, SHAR, SHLL, SHLR, ROTL, ROTR, ROTXL, ROTXR</td><td>8</td></tr>
<tr><td>Bitové manipulace</td><td>BSET, BCLR, BNOT, BTST, BAND, BIAND, BOR, BIOR, BXOR, BIXOR, BLD, BILD, BST, BIST</td><td>14</td></tr>
<tr><td>Nepodmíněné skoky</td><td>JMP, BSR, JSR, RTS</td><td>4</td></tr>
<tr><td>Podmíněné skoky</td><td>Bcc (celkem 16 variant)</td><td>1</td></tr>
<tr><td>Řízení procesoru</td><td><strong>TRAPA</strong>, RTE, SLEEP, LDC, STC, ANDC, ORC, XORC, NOP</td><td>9</td></tr>
<tr><td>Blokové přenosy</td><td>EEPMOV</td><td>1</td></tr>
<tr><th>Celkem</th><th>&nbsp;</th><th>64 (62)</th></tr>
</table>

<p>Poznámka: instrukce <strong>MOVTPE</strong> a <strong>MOVFPE</strong> na
zcela původních jádrech H8/300 taktéž nenalezneme.</p>



<p><a name="k08"></a></p>
<h2 id="k08">8. Instrukce nově podporující 16bitové operandy</h2>

<p>Minule jsme si popsali několik instrukcí, které dokázaly pracovat pouze
s&nbsp;osmibitovými pracovními registry či osmibitovými konstantami. Většina
instrukcí však byla rozšířena i pro zpracování šestnáctibitových operandů, což
přispělo k&nbsp;ortogonalitě instrukční sady. Jedná se o následující
instrukce:</p>

<table>
<tr><th> #</th><th>Instrukce</th><th>Popis</th><th>Poznámka</th></tr>
<tr><td> 1</td><td>ADD</td><td>součet Rd = Rd + konstanta</td><td>i pro 16bitový registr</td></tr>
<tr><td> 2</td><td>SUB</td><td>rozdíl Rd = Rd - konstanta</td><td>i pro 16bitový registr</td></tr>
<tr><td> 3</td><td>INC</td><td>inkrementace Rd = Rd + 1</td><td>i pro 16bitový registr</td></tr>
<tr><td> 4</td><td>DEC</td><td>dekrementace Rd = Rd - 1</td><td>i pro 16bitový registr</td></tr>
<tr><td> 5</td><td>MULXU</td><td>součin Rd = Rd &times; Rs</td><td>8bit&times;8bit či 16bit&times;16bit</td></tr>
<tr><td> 6</td><td>DIVXU</td><td>podíl Rd = Rd &divide; Rs</td><td>dtto</td></tr>
<tr><td> 7</td><td>NEG</td><td>výpočet Rd = -Rd</td><td>jen pro osmibitový cílový registr</td></tr>
<tr><td> 8</td><td>CMP</td><td>Rd – konstanta s&nbsp;nastavením příznaků</td><td>i pro 16bitový registr</td></tr>
<tr><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td></tr>
<tr><td> 9</td><td>AND</td><td>Rd = Rd &and; Rs</td><td>i pro 16bitové registry</td></tr>
<tr><td>10</td><td>AND</td><td>Rd = Rd &and; konstanta</td><td>16bitová konstanta</td></tr>
<tr><td>11</td><td>OR </td><td>Rd = Rd &or; Rs</td><td>i pro 16bitové registry</td></tr>
<tr><td>12</td><td>OR </td><td>Rd = Rd &or; konstanta</td><td>16bitová konstanta</td></tr>
<tr><td>13</td><td>XOR</td><td>Rd = Rd &oplus; Rs</td><td>i pro 16bitové registry</td></tr>
<tr><td>14</td><td>XOR</td><td>Rd = Rd &oplus; konstanta</td><td>16bitová konstanta</td></tr>
<tr><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td></tr>
<tr><td>15</td><td>NOT</td><td>Rd = &not; Rd</td><td>i pro 16bitový registr</td></tr>
<tr><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td></tr>
<tr><td>16</td><td>SHAL </td><td>aritmetický posun registru Rd doleva</td><td>i pro 16bitový registr</td></tr>
<tr><td>17</td><td>SHAR </td><td>aritmetický posun registru Rd doprava</td><td>i pro 16bitový registr</td></tr>
<tr><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td></tr>
<tr><td>18</td><td>SHLL </td><td>logický posun registru Rd doleva</td><td>i pro 16bitový registr</td></tr>
<tr><td>19</td><td>SHLR </td><td>logický posun registru Rd doprava</td><td>i pro 16bitový registr</td></tr>
<tr><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td></tr>
<tr><td>20</td><td>ROTL </td><td>rotace registru Rd doleva</td><td>i pro 16bitový registr</td></tr>
<tr><td>21</td><td>ROTR </td><td>rotace registru Rd doprava</td><td>i pro 16bitový registr</td></tr>
<tr><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td></tr>
<tr><td>22</td><td>ROTXL</td><td>rotace registru Rd doleva přes carry flag</td><td>i pro 16bitový registr</td></tr>
<tr><td>23</td><td>ROTXR</td><td>rotace registru Rd doprava přes carry flag</td><td>i pro 16bitový registr</td></tr>
</table>



<p><a name="k09"></a></p>
<h2 id="k09">9. Instrukce nově podporující 32bitové operandy</h2>

<p>Některé instrukce byly navíc rozšířeny takovým způsobem, aby mohly pracovat
se dvěma 32bitovými registry popř.&nbsp;s&nbsp;jedním 32bitovým registrem a
32bitovou konstantou či hodnotou načtenou z&nbsp;operační paměti. Tyto
instrukce jsou vypsány v&nbsp;následující tabulce (už bez podrobnějšího
popisu):</p>

<table>
<tr><th> #</th><th>Instrukce</th><th>Adresovací režimy</th></tr>
<tr><td> 1</td><td>MOV </td><td>#konstanta, Rn, @ERn, @(d:16,ERn), @(d:24,ERn), @ERn+, @-ERn, @aa:16, @aa:24</td></tr>
<tr><td> 2</td><td>ADD </td><td>#konstanta, Rn</td></tr>
<tr><td> 3</td><td>SUB </td><td>#konstanta, Rn</td></tr>
<tr><td> 4</td><td>CMP </td><td>#konstanta, Rn</td></tr>
<tr><td> 5</td><td>INC </td><td>Rn</td></tr>
<tr><td> 6</td><td>DEC </td><td>Rn</td></tr>
<tr><td> 7</td><td>NEG </td><td>Rn</td></tr>
<tr><td> 8</td><td>AND </td><td>#konstanta, Rn</td></tr>
<tr><td> 9</td><td>OR  </td><td>#konstanta, Rn</td></tr>
<tr><td>10</td><td>XOR </td><td>#konstanta, Rn</td></tr>
<tr><td>11</td><td>NOT </td><td>Rn</td></tr>
<tr><td>12</td><td>SHAL</td><td>Rn</td></tr>
<tr><td>13</td><td>SHAR</td><td>Rn</td></tr>
<tr><td>14</td><td>SHLL</td><td>Rn</td></tr>
<tr><td>15</td><td>SHLR</td><td>Rn</td></tr>
<tr><td>16</td><td>ROTL</td><td>Rn</td></tr>
<tr><td>17</td><td>ROTR</td><td>Rn</td></tr>
<tr><td>18</td><td>ROTXL</td><td>Rn</td></tr>
<tr><td>19</td><td>ROTXR</td><td>Rn</td></tr>
</table>

<p>Poznámka: z&nbsp;této tabulky mj.&nbsp;vyplývá, že většina pokročilejších
adresovacích režimů je dostupná pouze pro instrukci <strong>MOV</strong>.</p>



<p><a name="k10"></a></p>
<h2 id="k10">10. Nové aritmetické instrukce</h2>

<p>Mezi nové aritmetické instrukce patří konverzní instrukce nazvané
<strong>EXTU</strong> a <strong>EXTS</strong>. Tyto instrukce dokážou rozšířit
původně osmibitovou hodnotu uloženou v&nbsp;pracovním registru na šestnáct bitů
(pokud je operandem registr Rn) popř.&nbsp;rozšířit původně šestnáctibitovou
hodnotu na 32 bitů (pokud je operandem registr ERn). Instrukce
<strong>EXTU</strong> je jednodušší, protože provádí bezznaménkové rozšíření,
tedy vlastně vynulování horních osmi resp.&nbsp;šestnácti bitů. Instrukce
<strong>EXTS</strong> naproti tomu dokáže provést rozšíření znaménka,
tj.&nbsp;kopii původního nejvyššího bitu čísla do horní poloviny slova či
dvojslova.</p>

<p>Další dvě nové instrukce se jmenují <strong>MULXS</strong> a
<strong>DIVXS</strong>. Jedná se o obdobu nám již známých instrukcí nazvaných
<strong>MULXU</strong> a <strong>DIVXU</strong>, ovšem oba operandy jsou nyní
chápány jako čísla se znaménkem (signed). Pozor je zapotřebí dát na to, že
všechny čtyři instrukce <strong>MULXx</strong> a <strong>DIVXx</strong> dokážou
pracovat buď s&nbsp;osmibitovými či šestnáctibitovými operandy, nikoli již
s&nbsp;operandy 32bitovými.</p>



<p><a name="k11"></a></p>
<h2 id="k11">11. Rozšíření sémantiky instrukce <strong>EEPMOV</strong></h2>

<p>I sémantika instrukce <strong>EEPMOV</strong> byla rozšířena. Původní funkce
této instrukce se dala popsat následujícím pseudokódem:</p>

<pre>
while R4L &gt; 0:
    @R6+ = @R5+  ; přenos z adresy uložené v R5 na adresu uloženou v R6
    R4L--
</pre>

<p>Nově se při adresování používá plně 24bitová adresa (tedy registry ER5 a
ER6) a počitadlo může být buď osmibitové (R4L) či šestnáctibitové (R4). Chování
instrukce <strong>EEPMOV</strong> tedy můžeme popsat takto:</p>

<pre>
while R4L &gt; 0:
    @ER6+ = @ER5+  ; přenos z adresy uložené v ER5 na adresu uloženou v ER6
    R4L--
</pre>

<p>popř.:</p>

<pre>
while R4 &gt; 0:
    @ER6+ = @ER5+  ; přenos z adresy uložené v ER5 na adresu uloženou v ER6
    R4--
</pre>



<p><a name="k12"></a></p>
<h2 id="k12">12. Další moduly, které lze nalézt na mikrořadiči</h2>

<p>Většina mikrořadičů postavených na jádrech H8/300H obsahuje velmi podobně
koncipované přídavné moduly, protože právě tyto moduly dělají mikrořadič tak
užitečným, což se ostatně ukázalo již na úspěchu prvních osmibitových
mikrořadičů (TMS1000 a Intel 8048).  Některé z&nbsp;těchto modulů si popíšeme
v&nbsp;navazujících kapitolách. Některé další moduly, například I<sup>2</sup>C
či ovladač LCD, dnes nebudou podrobněji popsány.</p>



<p><a name="k13"></a></p>
<h2 id="k13">13. Sériové porty</h2>

<p>Modul pro sériovou komunikaci podporuje jak asynchronní přenos
(tj.&nbsp;UART &ndash; Universal Asynchronous Receiver/Transmitter), tak i
režim synchronní, tj.&nbsp;řízený hodinovým signálem. V&nbsp;asynchronním
režimu lze samozřejmě volit přenosovou rychlost a to v&nbsp;poměrně širokém
rozmezí (rychlost je odvozena od frekvence krystalu děličkou). Dále pak lze
nakonfigurovat počet datových bitů (5, 7 nebo 8), počet stop bitů (1 nebo 2) a
paritní bit (sudá parita, lichá parita či žádný paritní bit). Při konfiguraci
sériového synchronního přenosu se volí pouze přenosová rychlost, protože data
jsou v&nbsp;tomto případě vždy přenášena po celých bajtech. Některé čipy
obsahují podporu pro dva nezávisle na sobě pracující asynchronní sériové porty,
takže na čipu nalezneme dvojici pinů RXD a TXD, které jsou doplněny dvojicí
pinů SCK (hodiny pro synchronní režim přenosu).</p>



<p><a name="k14"></a></p>
<h2 id="k14">14. PWM a ADC</h2>

<p>Čipy postavené na jádrech H8/300H typicky obsahují čtrnáctibitový PWM
(<i>pulse width modulator</i>) se dvěma na sobě nezávislými výstupními kanály.
Generovaný signál je opět odvozen od frekvence hodinového signálu, který je
vydělen konstantou 2, 4, 8 či 16. Po připojení dolní propusti je možné PWM
použít i ve funkci jednoduchého D/A převodníku (ovšem záleží na konkrétní
aplikaci i na kvalitě dolní propusti).</p>

<p>Analogově-digitální převodník má osm přepínatelných vstupů, rozlišení 10
bitů a poměrně rychlé sledování analogové veličiny (cca 12 mikrosekund na každý
kanál). V&nbsp;praxi však bývá rozlišení nižší, počítat lze s&nbsp;8 až 9
bity (to ale platí i pro mnoho dalších ADC implementovaných přímo na jednom
čipu s&nbsp;mikrořadičem).</p>



<p><a name="k15"></a></p>
<h2 id="k15">15. Čítače a časovače</h2>

<p>Jednotlivé čipy s&nbsp;jádrem H8/300H se od sebe v&nbsp;několika ohledech
liší; týká se to i konfigurace čítačů a časovačů. Na většině mikrořadičů však
najdeme alespoň dvojici plně šestnáctibitových čítačů/časovačů, jejichž
možnosti konfigurace jsou poměrně široké. Mohou například začít automaticky
generovat jiný výstupní signál po dosažení určitého času (včetně PWM), na
základě zadaných podmínek se může generovat přerušení, přečíst aktuální hodnoty
na vstupních pinech atd. U dalších čipů nalezneme i větší množství čítačů
(3-4).</p>



<p><a name="k16"></a></p>
<h2 id="k16">16. Odkazy na Internetu</h2>

<ol>

<li>H8/300H Series Software Manual<br />
<a href="https://www.renesas.com/en-us/doc/products/mpumcu/001/rej09b0213_h8300h.pdf">https://www.renesas.com/en-us/doc/products/mpumcu/001/rej09b0213_h8300h.pdf</a>
</li>

<li>Renesas H8/300H Series Manuals<br />
<a href="https://www.manualslib.com/products/Renesas-H8-300h-Series-2312446.html">https://www.manualslib.com/products/Renesas-H8-300h-Series-2312446.html</a>
</li>

<li>H8 Family<br />
<a href="https://en.wikipedia.org/wiki/H8_Family">https://en.wikipedia.org/wiki/H8_Family</a>
</li>

<li>H8/300 and H8/300L<br />
<a href="http://nah6.com/~itsme/download/ibutton/h8_8bit.pdf">http://nah6.com/~itsme/download/ibutton/h8_8bit.pdf</a>
</li>

<li>H8 Family<br />
<a href="https://www.renesas.com/en-us/products/microcontrollers-microprocessors/h8.html">https://www.renesas.com/en-us/products/microcontrollers-microprocessors/h8.html</a>
</li>

<li>(GCC) Status of Supported Architectures from Maintainers' Point of View<br />
<a href="https://gcc.gnu.org/backends.html">https://gcc.gnu.org/backends.html</a>
</li>

<li>(GCC) H8/300 Options<br />
<a href="https://gcc.gnu.org/onlinedocs/gcc/H8_002f300-Options.html#H8_002f300-Options">https://gcc.gnu.org/onlinedocs/gcc/H8_002f300-Options.html#H8_002f300-Options</a>
</li>

<li>GCC for SuperH,H8/300,AVR<br />
<a href="http://mes.osdn.jp/h8/gcc.html">http://mes.osdn.jp/h8/gcc.html</a>
</li>

<li>H8/3802, 38002S, 38004, 38104 (manuály k&nbsp;čipům)<br />
<a href="https://www.renesas.com/en-us/document/hw-manual?hwLayerShowFlg=true&prdLayerId=184&layerName=H8%252F3802%252C%2B38002S%252C%2B38004%252C%2B38104&coronrService=document-prd-search&hwDocUrl=%2Fen-us%2Fdoc%2Fproducts%2Fmpumcu%2F001%2Frej09b0024_h83802.pdf&hashKey=c5e1fa0a18c01e6c789bc7b5c0184ed9">https://www.renesas.com/en-us/document/hw-manual?hwLayerShowFlg=true&prdLayerId=184&layerName=H8%252F3802%252C%2B38002S%252C%2B38004%252C%2B38104&coronrService=document-prd-search&hwDocUrl=%2Fen-us%2Fdoc%2Fproducts%2Fmpumcu%2F001%2Frej09b0024_h83802.pdf&hashKey=c5e1fa0a18c01e6c789bc7b5c0184ed9</a>
</li>

<li>Addressing mode (Wikipedia)<br />
<a href="https://en.wikipedia.org/wiki/Addressing_mode">https://en.wikipedia.org/wiki/Addressing_mode</a>
</li>

<li>Renesas SH Instruction Set Summary<br />
<a href="http://shared-ptr.com/sh_insns.html">http://shared-ptr.com/sh_insns.html</a>
</li>

<li>SH-4 RISC Processor by HITACHI<br />
<a href="http://www.cs.umd.edu/~meesh/cmsc411/website/projects/risc/risc.htm">http://www.cs.umd.edu/~meesh/cmsc411/website/projects/risc/risc.htm</a>
</li>

<li>SH-4 RISC Processor<br />
<a href="http://www.cs.umd.edu/~meesh/cmsc411/website/projects/risc/sh-4.htm">http://www.cs.umd.edu/~meesh/cmsc411/website/projects/risc/sh-4.htm</a>
</li>

<li>SuperH RISC engine Family Features<br />
<a href="https://www.renesas.com/en-us/products/microcontrollers-microprocessors/superh/superh-features.html">https://www.renesas.com/en-us/products/microcontrollers-microprocessors/superh/superh-features.html</a>
</li>

<li>Orthogonal instruction set<br />
<a href="https://en.wikipedia.org/wiki/Orthogonal_instruction_set">https://en.wikipedia.org/wiki/Orthogonal_instruction_set</a>
</li>

<li>Status Register<br />
<a href="https://en.wikipedia.org/wiki/Status_register">https://en.wikipedia.org/wiki/Status_register</a>
</li>

<li>6800 Instruction Set<br />
<a href="http://www.electronics.dit.ie/staff/tscarff/6800/Instructions/instructions.htm">http://www.electronics.dit.ie/staff/tscarff/6800/Instructions/instructions.htm</a>
</li>

<li>Assembly language today<br />
<a href="http://beust.com/weblog/2004/06/23/assembly-language-today/">http://beust.com/weblog/2004/06/23/assembly-language-today/</a>
</li>

<li>Calling subroutines<br />
<a href="http://infocenter.arm.com/help/index.jsp?topic=/com.arm.doc.kui0100a/armasm_cihcfigg.htm">http://infocenter.arm.com/help/index.jsp?topic=/com.arm.doc.kui0100a/armasm_cihcfigg.htm</a>
</li>

<li>Art of Assembly - Arithmetic Instructions<br />
<a href="http://oopweb.com/Assembly/Documents/ArtOfAssembly/Volume/Chapter_6/CH06-2.html">http://oopweb.com/Assembly/Documents/ArtOfAssembly/Volume/Chapter_6/CH06-2.html</a>
</li>

<li>X86 Assembly/Arithmetic<br />
<a href="https://en.wikibooks.org/wiki/X86_Assembly/Arithmetic">https://en.wikibooks.org/wiki/X86_Assembly/Arithmetic</a>
</li>

<li>ARM subroutines &amp; program stack<br />
<a href="http://www.toves.org/books/armsub/">http://www.toves.org/books/armsub/</a>
</li>

<li>Programming from the Ground Up Book - Summary<br />
<a href="http://savannah.nongnu.org/projects/pgubook/">http://savannah.nongnu.org/projects/pgubook/</a>
</li>

<li>The 6502 overflow flag explained mathematically <br />
<a href="http://www.righto.com/2012/12/the-6502-overflow-flag-explained.html">http://www.righto.com/2012/12/the-6502-overflow-flag-explained.html</a>
</li>

</ol>



<p></p><p></p>
<p><small>Autor: <a href="http://www.fit.vutbr.cz/~tisnovpa">Pavel Tišnovský</a> &nbsp; 2016</small></p>
</body>
</html>

