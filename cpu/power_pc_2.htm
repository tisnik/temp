<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
        "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html>
<head>
<title>RISCová architektura PowerPC (pokračování)</title>
<meta name="Author" content="Pavel Tisnovsky" />
<meta name="Generator" content="vim" />
<meta http-equiv="content-type" content="text/html; charset=utf-8" />
<style type="text/css">
         body {color:#000000; background:#ffffff;}
         h1  {font-family: arial, helvetica, sans-serif; color:#ffffff; background-color:#c00000; text-align:center; padding-left:1em}
         h2  {font-family: arial, helvetica, sans-serif; color:#ffffff; background-color:#0000c0; padding-left:1em; text-align:left}
         h3  {font-family: arial, helvetica, sans-serif; color:#000000; background-color:#c0c0c0; padding-left:1em; text-align:left}
         h4  {font-family: arial, helvetica, sans-serif; color:#000000; background-color:#e0e0e0; padding-left:1em; text-align:left}
         a   {font-family: arial, helvetica, sans-serif;}
         li  {font-family: arial, helvetica, sans-serif; color:#000000; text-align:justify; width:450px;}
         ol  {font-family: arial, helvetica, sans-serif; color:#000000; text-align:justify; width:450px;}
         ul  {font-family: arial, helvetica, sans-serif; color:#000000; text-align:justify; width:450px;}
         p   {font-family: arial, helvetica, sans-serif; color:#000000; text-align:justify;}
         pre {background:#e0e0e0}
</style>
</head>

<body>

<h1>RISCová architektura PowerPC (pokračování)</h1>

<h3>Pavel Tišnovský</h3>

<p></p>

<h1>Úvodník</h1>

<p>Ve druhé části článku o RISCové architektuře PowerPC nejprve dokončíme popis modulu určeného pro provádění podmíněných i nepodmíněných skoků a následně se zaměříme na celočíselné instrukce prováděné v&nbsp;aritmeticko-logické jednotce.</p>



<h2>Obsah</h2>

<p><a href="#k01">1. RISCová architektura PowerPC (pokračování)</a></p>
<p><a href="#k02">2. Varianty skokových instrukcí</a></p>
<p><a href="#k03">3. Operace s&nbsp;příznaky uloženými v&nbsp;registru CR (<i>Condition Register</i>)</a></p>
<p><a href="#k04">4. Modul určený pro vykonávání celočíselných operací</a></p>
<p><a href="#k05">5. Instrukce typu LOAD a STORE</a></p>
<p><a href="#k06">6. Základní aritmetické operace</a></p>
<p><a href="#k07">7. Instrukce určené pro násobení a dělení</a></p>
<p><a href="#k08">8. Instrukce pro porovnání operandů</a></p>
<p><a href="#k09">9. Bitové rotace a posuny</a></p>
<p><a href="#k10">10. Odkazy na Internetu</a></p>



<p><a name="k01"></a></p>
<h2 id="k01">1. RISCová architektura PowerPC (pokračování)</h2>

<p><a
href="http://www.root.cz/clanky/riscova-architektura-powerpc/">V&nbsp;první
části článku</a> o RISCové architektuře PowerPC jsme se seznámili především
s&nbsp;programátorským pohledem na tyto procesory. Kromě stručného popisu
formátu instrukcí a univerzálních pracovních registrů jsme si popsali čtveřici
registrů, které na této architektuře mají speciální význam. Jednalo se o
<i>Condition Register</i>, <i>Fixed-Point Exception Register</i>, <i>Link
Register</i> a <i>Count Register</i>. Podrobnější popis se týkal především
<i>Condition Registru</i>, protože jeho struktura je navržena takovým způsobem,
aby byl používán nejenom pro řízení běhu programů (rozeskoky, programové
smyčky), ale i pro realizaci některých složitějších logických výrazů, což je
téma, o kterém se zmíníme <a href="#k03">ve třetí kapitole</a>.  Dále jsme si
řekli, jakým způsobem jsou realizovány instrukce podmíněného i nepodmíněného
skoku v&nbsp;modulu nazvaném <i>Branch Processor</i>. Dnes si popíšeme funkce
dalšího modulu, tj.&nbsp;konkrétně modulu určeného pro provádění aritmetických
a logických operací s&nbsp;celočíselnými operandy.</p>



<p><a name="k02"></a></p>
<h2 id="k02">2. Varianty skokových instrukcí</h2>

<p>Vraťme se ještě na chvíli k&nbsp;instrukcím určeným pro provádění skoků.
V&nbsp;prvním článku jsme si řekli, že skokové instrukce i některé další
instrukce určené pro řízení běhu programu jsou vykonávány jednotkou nazvanou
<i>Branch Processor</i>. Existuje poměrně velké množství různých variant
skokových instrukcí, protože kromě nepodmíněných skoků lze použít skok vykonaný
na základě hodnoty některého stavového registru &ndash; <i>Condition
Register</i> <strong>CR</strong>, <i>Link Register</i> <strong>LR</strong> a
<i>Count Register</i> <strong>CTR</strong>. Následuje výpis možných variant
různých podmínek, které mohou být testovány a při jejichž splnění se skok
provede (pro úplnost je na prvním řádku zapsán i nepodmíněný skok):</p>

<table>
<tr><th>#</th><th>Provedená operace před testem</th><th>Testovaná podmínka</th></tr>
<tr><td>1</td><td>&times;</td><td>&times; skok se provede vždy (branch always)</td></tr>
<tr><td>2</td><td>&times;</td><td>test, zda vybraný bit CR == 0</td></tr>
<tr><td>3</td><td>&times;</td><td>test, zda vybraný bit CR == 1</td></tr>
<tr><td>4</td><td>snížení hodnoty CTR o 1</td><td>CTR==0</td></tr>
<tr><td>5</td><td>snížení hodnoty CTR o 1</td><td>CTR!=0</td></tr>
<tr><td>6</td><td>snížení hodnoty CTR o 1</td><td>CTR==0 a současně vybraný bit CR == 0</td></tr>
<tr><td>7</td><td>snížení hodnoty CTR o 1</td><td>CTR==0 a současně vybraný bit CR == 1</td></tr>
<tr><td>8</td><td>snížení hodnoty CTR o 1</td><td>CTR!=0 a současně vybraný bit CR == 0</td></tr>
<tr><td>9</td><td>snížení hodnoty CTR o 1</td><td>CTR!=0 a současně vybraný bit CR == 1</td></tr>
</table>

<p>Dále se (ortogonálně, tj.&nbsp;nezávisle na typu testu) může zvolit způsob
výpočtu adresy skoku:</p>

<table>
<tr><th>#</th><th>Adresa skoku</th></tr>
<tr><td>1</td><td>absolutní</td></tr>
<tr><td>2</td><td>relativní vůči aktuální poloze v&nbsp;kódu</td></tr>
<tr><td>3</td><td>adresa je uložená v&nbsp;registru <strong>LR</strong> (<i>Link Register</i>)</td></tr>
<tr><td>4</td><td>adresa je uložená v&nbsp;registru <strong>CTR</strong> (<i>Count Register</i>)</td></tr>
</table>

<p>O dvou bitech, které mohou napomoci činnosti prediktoru skoků, jsme se již
taktéž zmínili minule (zkráceně &ndash; pokud si je překladač jistý tím, že se
nějaký skok velmi pravděpodobně provede či naopak velmi pravděpodobně
neprovede, může nastavit příslušné dva bity). Ovšem u skoků používajících
adresu uloženou v&nbsp;registru <strong>LR</strong> nebo <strong>CTR</strong>
se navíc používá další poněkud odlišně koncipované bitové pole (opět o
velikosti dvou bitů), které blíže tyto skoky popisuje:</p>

<table>
<tr><th>Kombinace bitů</th><th>Cíl je v&nbsp;LR</th><th>Cíl je v&nbsp;CTR</th></tr>
<tr><td>00</td><td>návrat ze subrutiny</td><td>velmi pravděpodobně se použije stejná adresa, jako v&nbsp;minulém skoku</td></tr>
<tr><td>01</td><td>nejedná se o návrat ze subrutiny</td><td>rezervováno</td></tr>
<tr><td>10</td><td>rezervováno</td><td>rezervováno</td></tr>
<tr><td>11</td><td>skok nelze staticky predikovat</td><td>skok nelze staticky predikovat</td></tr>
</table>

<p>Poznámka: tyto nápovědy pro prediktor skoků se mohou kombinovat
s&nbsp;dvojicí bitů popsaných minule, takže lze například zkonstruovat skok
typu &bdquo;velmi nepravděpodobný návrat ze subrutiny na adresu uloženou
v&nbsp;registru <strong>LR</strong>, který se provede za předpokladu, že
registr <strong>CTR</strong> je po svém snížení o jedničku nulový&ldquo;.</p>



<p><a name="k03"></a></p>
<h2 id="k03">3. Operace s&nbsp;příznaky uloženými v&nbsp;registru CR (<i>Condition Register</i>)</h2>

<p>Registr <strong>CR</strong> (<i>Condition Register</i>) jsme si již popsali
minule, takže si dnes pouze ve stručnosti připomeňme, že tento 32bitový registr
je rozdělen do osmi čtyřbitových polí označovaných symboly <strong>CR0</strong>
až <strong>CR7</strong>, přičemž pole <strong>CR0</strong> má speciální význam,
neboť jeho první tři bity v&nbsp;něm jsou nastavovány běžnými celočíselnými
instrukcemi (sčítání atd.) a to konkrétně porovnáním výsledku operace
s&nbsp;nulou. I druhé pole se jménem <strong>CR1</strong>, tj.&nbsp;bity 4 až 7
z&nbsp;příznakového registru <strong>CR</strong>, má speciální význam, neboť
bity v&nbsp;něm jsou nastavovány při operacích s&nbsp;hodnotami s&nbsp;plovoucí
řádovou čárkou.</p>

<p>Kromě skokových operací, které mohou testovat hodnotu libovolného bitu
registru <strong>CR</strong> existuje na architektuře PowerPC i sada instrukcí
určených pro vzájemné kombinace hodnot vybraných bitů tohoto registru. Tím je
(alespoň teoreticky) umožněna snadná realizace některých podmínek zapsaných
v&nbsp;některém vyšším programovacím jazyce. Tyto instrukce navíc trošku
připomínají Booleovský procesor známý například z&nbsp;platformy Intel
8051:</p>

<table>
<tr><th>#</th><th>Instrukce</th><th>Význam</th></tr>
<tr><td>1</td><td>crand </td><td>bitová operace AND (logický součin)</td></tr>
<tr><td>2</td><td>cror  </td><td>bitová operace OR (logický součet)</td></tr>
<tr><td>3</td><td>crxor </td><td>bitová operace XOR (nonekvivalence)</td></tr>
<tr><td>4</td><td>crnand</td><td>bitová operace NAND (negace logického součinu)</td></tr>
<tr><td>5</td><td>crnor </td><td>bitová operace NOR (negace logického součtu)</td></tr>
<tr><td>6</td><td>creqv </td><td>bitová operace EQV (ekvivalence)</td></tr>
<tr><td>7</td><td>crandc</td><td>bitová operace AND s&nbsp;prvním bitem a negací druhého bitu</td></tr>
<tr><td>8</td><td>crorc </td><td>bitová operace OR s&nbsp;prvním bitem a negací druhého bitu</td></tr>
</table>

<p>Všechny tyto instrukce ve svém instrukčním slově obsahují trojici
pětibitových adres BA, BB a BT. Díky tomu je možné operaci provést
s&nbsp;libovolnými dvěma bity registru CR a uložit výsledek opět do libovolného
bitu tohoto registru (2<sup>5</sup>=32).</p>



<p><a name="k04"></a></p>
<h2 id="k04">4. Modul určený pro vykonávání celočíselných operací</h2>

<p>Druhým modulem, z&nbsp;nichž se skládají procesory typu PowerPC, je modul
určený pro vykonávání celočíselných operací. V&nbsp;originální dokumentaci se
sice tento modul nazývá <i>Fixed-Point Processor</i>, ovšem ve skutečnosti se
jedná o běžnou RISCovou aritmeticko-logickou jednotku. Pro celočíselné operace
je možné jako operandy použít sadu třiceti dvou pracovních registrů nazvaných
<strong>GPR0</strong> až <strong>GPR31</strong> (<i>General-Purpose
Registers</i>), z&nbsp;nichž každý má šířku 64bitů (stále se bavíme o 64bitovém
režimu PowerPC). Tato sada pracovních registrů je doplněna již výše zmíněným
registrem nazvaným <strong>XER</strong> (<i>Fixed-Point Exception Register</i>)
obsahujícím bitové příznaky nastavované při většině aritmetických operací.
Některé další příznaky se pak ukládají do druhého stavového registru
<strong>CR</strong> (<i>Condition Register</i>), jehož bity lze testovat
s&nbsp;využitím <a href="#k02">výše zmíněných</a> instrukcí pro podmíněný skok
a upravovat s&nbsp;využitím <a href="#k03">logických operací</a>.</p>



<p><a name="k05"></a></p>
<h2 id="k05">5. Instrukce typu LOAD a STORE</h2>

<p>Na architektuře PowerPC samozřejmě, jako ostatně na všech dalších RISCových
architekturách, nalezneme instrukce určené pro načítání operandů
z&nbsp;operační paměti i pro uložení výsledků operací zpět do operační paměti.
Programátoři a autoři překladačů mají k&nbsp;dispozici poměrně velké množství
variant instrukcí typu <strong>LOAD</strong> a <strong>STORE</strong>, přičemž
jednotlivé varianty se od sebe odlišují adresními režimy i šířkou
načítaných/ukládaných operandů. Adresa, resp.&nbsp;přesněji řečeno efektivní
adresa, může být vypočítána mnoha různými způsoby, většinou se ale jedná o
kombinaci obsahu některého pracovního registru (<strong>GPR</strong>)
s&nbsp;šestnáctibitovou konstantou, která je přímo součástí instrukčního slova.
U některých instrukcí má navíc speciální význam nulový index registru &ndash;
v&nbsp;tomto případě se použije odlišný adresní režim.</p>

<p>Načítat je možné jednotlivé bajty, šestnáctibitová slova, 32bitová slova i
64bitová slova. Typ načítaného operandu se jednoduše pozná podle druhého
písmene v&nbsp;mnemotechnické zkratce instrukce &ndash; <strong>lb??</strong>
značí načtení bajtu, <strong>lh??</strong> načtení šestnáctibitového slova,
<strong>lw??</strong> načtení 32bitového slova a konečně <strong>ld?</strong>
načtení slova 64bitového. Třetí písmeno v&nbsp;instrukci může označovat, jaká
se provede konverze při rozšiřování načtených dat do plné šířky 64 bitů. To
například znamená, že <strong>lhz?</strong> znamená instrukci pro načtení
16bitového slova s&nbsp;rozšířením na 64bitů tak, že se horních 48 bitů
jednoduše vynuluje, zatímco instrukce <strong>lha?</strong> značí rozšíření
znaménka (<i>sign extension</i>, v&nbsp;newspeaku PowerPC však <i>algebraic
extension</i>).</p>

<p>Další jeden až dva znaky ve jménu instrukce pak označuje konkrétní typ
výpočtu efektivní adresy: registr+16bitová konstanta, registr+registr atd.
Navíc je možné, aby se výsledná adresa automaticky uložila zpět do registru
použitého pro adresování (update &ndash; poslední znak instrukce bude
<strong>u</strong>). Tuto vlastnost lze použít mnoha způsoby, například díky
adresování registr+16bitová konstanta pro procházení polem prvek po prvku.</p>

<p>Podporovány jsou i speciální režimy při načítání a ukládání, například změna
pořadí bajtů či blokové načítání/ukládání do většího množství registrů.</p>



<p><a name="k06"></a></p>
<h2 id="k06">6. Základní aritmetické operace</h2>

<p>Mezi základní aritmetické operace samozřejmě patří sčítání a odčítání. Na
mikroprocesorech s&nbsp;architekturou PowerPC mají programátoři používající
tyto instrukce poměrně velkou flexibilitu při výběru operandů, protože některé
formy instrukcí obsahují ve svém slovu 16bitovou konstantu, kterou lze použít
jako jeden vstupní operand. Mimochodem &ndash; právě tato technika se používá
pro načtení konstanty do některého pracovního registru, protože například
operace <strong>addi Rx, 0, hodnota</strong> je ekvivalentní instrukci
<strong>li Rx, hodnota</strong> (<strong>addi</strong> značí <i>Add
Immediate</i> a <strong>li</strong> pak <i>Load Immediate</i>). Podobných
aliasů instrukcí nalezneme na architektuře PowerPC celou řadu. Podívejme se,
které základní aritmetické instrukce typu &bdquo;součet&ldquo; jsou podporovány
(ve skutečnosti jsou možné i další kombinace):</p>

<table>
<tr><th>#</th><th>Instrukce</th><th>Význam</th></tr>
<tr><td>1</td><td>add</td><td>Rd=Rs1+Rs2 (nejběžnější forma nenastavující příznaky)</td></tr>
<tr><td>2</td><td>add.</td><td>Rd=Rs1+Rs2 (nastavuje bity v CR0)</td></tr>
<tr><td>3</td><td>addo</td><td>Rd=Rs1+Rs2 (nastavuje bity SO a OV)</td></tr>
<tr><td>4</td><td>addo.</td><td>kombinace předchozích dvou instrukcí</td></tr>
<tr><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td></tr>
<tr><td>5</td><td>addi</td><td>Rd=Rs+konstanta</td></tr>
<tr><td>6</td><td>addi</td><td>Rd=konstanta (Rs==0)</td></tr>
<tr><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td></tr>
<tr><td>7</td><td>addis</td><td>Rd=Rs+(konstanta&lt;&lt;16)</td></tr>
<tr><td>8</td><td>addis</td><td>Rd=Rs+(konstanta&lt;&lt;16) (Rs==0)</td></tr>
<tr><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td></tr>
<tr><td>9</td><td>addc</td><td>add + nastavení bitu CA (příznak přenosu)</td></tr>
<tr><td>10</td><td>addic</td><td>addi + nastavení bitu CA (příznak přenosu)</td></tr>
<tr><td>10</td><td>adde</td><td>Rd=Rs1+Rs2+CA</td></tr>
<tr><td>11</td><td>addze</td><td>Rd=CA (jen přičtení příznaku přenosu)</td></tr>
</table>

<p>Poznámka: suffixy <strong>.</strong> a <strong>o</strong> jsou uvedeny jen u
první instrukce <strong>add</strong>, ale lze je ve skutečnosti použít i u
dalších instrukcí pro určení toho, které příznakové bity se mají nastavit.</p>



<p><a name="k07"></a></p>
<h2 id="k07">7. Instrukce určené pro násobení a dělení</h2>

<p>Procesory PowerPC obsahují i násobičku a děličku (přesněji řečeno
specifikace popisuje násobičku a děličku, ovšem záleží pouze na konkrétní
implementaci, zda budou tyto operace prováděny hardwarově či nějakou formou
mikroinstrukcí). Čtenáře předchozích kapitol pravděpodobně nepřekvapí, že i
v&nbsp;tomto případě mají instrukce velkou flexibilitu, a to jak co se týče
velikosti operandů, tak i způsobu nastavování příznakových bitů. Násobit je
možné jak dva registry, tak i vybraný pracovní registr a 16bitovou konstantu,
která je součástí instrukčního slova. Totéž samozřejmě platí i pro instrukce
určené pro děličku, ostatně podívejme se na následující dvě tabulky.</p>

<p>Nejprve je uvedena tabulka s&nbsp;instrukcemi pro násobení dvou
operandů:</p>

<table>
<tr><th>#</th><th>Instrukce</th><th>Význam</th></tr>
<tr><td>1</td><td>mulli</td><td>násobení 64&times;64=64 Rd=Rs*konstanta (uloží se jen spodních 64 bitů výsledku)</td></tr>
<tr><td>2</td><td>mulld</td><td>násobení 64&times;64=64 Rd=Rs1*Rs2 (uloží se jen spodních 64 bitů výsledku)</td></tr>
<tr><td>3</td><td>mullw</td><td>násobení 32&times;32=64 Rd=Rs1*Rs2 (vstupem je dolní polovina 64bitových registrů)</td></tr>
<tr><td>4</td><td>mulhd</td><td>jako mulli, ale uloží se horních 64 bitů výsledku</td></tr>
<tr><td>5</td><td>mulhw</td><td>jako mulld, ale pouze horních 32 bitů 64bitového výsledku se uloží do Rd</td></tr>
<tr><td>6</td><td>mulhdu</td><td>jako mulli, ale uloží se horních 64 bitů výsledku, násobení čísel bez znaménka</td></tr>
<tr><td>7</td><td>mulhwu</td><td>jako mulhw, ale opět se jedná o násobení čísel bez znaménka</td></tr>
</table>

<p>Instrukce pro dělení:</p>

<table>
<tr><th>#</th><th>Instrukce</th><th>Význam</th></tr>
<tr><td>1</td><td>divd</td><td>dělení dvou 64bitových čísel (se znaménkem)</td></tr>
<tr><td>2</td><td>divw</td><td>dělení dvou 32bitových čísel</td></tr>
<tr><td>3</td><td>divdu</td><td>jako divd, ale pro čísla bez znaménka</td></tr>
<tr><td>4</td><td>divwu</td><td>jako diwv, ale pro čísla bez znaménka</td></tr>
</table>

<p>Poznámka: u těchto instrukcí lze použít suffix <strong>o</strong>
popř.&nbsp;<strong>.</strong> pro určení, zda a jak se mají nastavovat
příznakové bity. Je to velmi podobné kombinacím, o nichž jsme se zmínili u
aritmetických instrukcí.</p>

<p>Poznámka 2: pro výpočet zbytku po dělení je nutné použít například
následující sekvenci:</p>

<pre>
divd Rd, Rs1, Rs2    # podíl po celočíselném dělení
mulld Rd, Rd, Rs2    # podíl po celočíselném dělení * dělitel
subf  Rd, Rd, Rs1    # zbytek po dělení
</pre>



<p><a name="k08"></a></p>
<h2 id="k08">8. Instrukce pro porovnání operandů</h2>

<p>Zajímavě jsou na architektuře PowerPC pojaty instrukce pro porovnání
operandů. Na mnoha jiných typech mikroprocesorů jsou při porovnávání nastaveny
příznakové bity <strong>ZF</strong> (příznak nulovosti), <strong>CF</strong>
(příznak přenosu) a <strong>OF</strong> (příznak přetečení). U PowerPC je tomu
jinak, protože je vždy nastaven pouze jeden ze tří bitů uložených do registru
CR:</p>

<table>
<tr><th>Bit v CR0</th><th>Zkratka</th><th>Význam</th></tr>
<tr><td>0</td><td>LT</td><td>Negative (kladný výsledek při porovnání/rozdílu)</td></tr>
<tr><td>1</td><td>GT</td><td>Positive (záporný výsledek při porovnání/rozdílu)</td></tr>
<tr><td>2</td><td>EQ</td><td>Zero (nulový výsledek při porovnání/rozdílu)</td></tr>
</table>

<p>Jak se s&nbsp;těmito bity pracuje již víme &ndash; buď se použijí při
provedení podmíněného skoku nebo je možné tyto příznaky libovolným způsobem
zkombinovat instrukcemi popsanými <a href="#k03">ve třetí kapitole</a> (a poté
je použít při podmíněném skoku).</p>

<p>Podporované instrukce pro porovnání operandů jsou zmíněny
v&nbsp;tabulce:</p>

<table>
<tr><th>#</th><th>Instrukce</th><th>Význam</th></tr>
<tr><td>1</td><td>cmp</td><td>porovnání obsahu dvou pracovních registrů</td></tr>
<tr><td>2</td><td>cmpi</td><td>porovnání registru s&nbsp;16bitovou konstantou</td></tr>
<tr><td>3</td><td>cmpl</td><td>porovnání 32bitových operandů chápaných jako hodnoty bez znaménka</td></tr>
<tr><td>4</td><td>cmpli</td><td>porovnání 32bitových operandů chápaných jako hodnoty bez znaménka</td></tr>
</table>

<p>Poznámka: v&nbsp;instrukčním slově lze zvolit, které bitové pole registru
<strong>CR</strong> bude použito pro zápis příznaků.</p>



<p><a name="k09"></a></p>
<h2 id="k09">9. Bitové rotace a posuny</h2>

<p>Nejkomplikovanější jsou instrukce určené pro provádění bitových rotací a
posunů. Tyto instrukce jsou velmi flexibilní, ovšem některé z&nbsp;nich mají ve
svém 32bitovém instrukčním slovu zakódováno až pět operandů, protože kromě
zdrojového a cílového registru je možné specifikovat masku, se kterou se po
dokončení rotace provede bitové operace AND, tj.&nbsp;bitový součin. Podívejme
se na příklad: instrukce s&nbsp;nevyslovitelným jménem <strong>rldicl</strong>
má čtyři operandy:</p>

<ol>
<li>Zdrojový registr Rs</li>
<li>Cílový registr Rd</li>
<li>Počet míst, o které se bude rotovat</li>
<li>Počáteční bit masky pro operaci AND (koncový bit je vždy shodný)</li>
</ol>

<p>Naproti tomu instrukce <strong>rlwimi</strong> má pět operandů:</p>

<ol>
<li>Zdrojový registr Rs</li>
<li>Cílový registr Rd</li>
<li>Počet míst, o které se bude rotovat</li>
<li>Počáteční bit masky pro operaci AND</li>
<li>Koncový bit masky pro operaci AND</li>
</ol>

<p>Maska je zkonstruována následovně: bity 64bitové masky ležící mezi
počátečním a koncovým bitem jsou nastaveny na jedničku, ostatní bity jsou
nulové. Pokud je však index počátečního bitu ostře větší, než index bitu
koncového, je maska negována (&bdquo;uprostřed&ldquo; ní jsou nuly). Tyto
operace jsou opět velmi flexibilní a v&nbsp;assembleru pro ně existuje několik
jmenných aliasů. Příklad použití: dekódování složky RGB jedinou instrukcí.</p>



<p><a name="k10"></a></p>
<h2 id="k10">10. Odkazy na Internetu</h2>

<ol>

<li>Simplified PowerPC Instruction Set<br />
<a href="http://www.ds.ewi.tudelft.nl/vakken/in101/labcourse/instruction-set/">http://www.ds.ewi.tudelft.nl/vakken/in101/labcourse/instruction-set/</a>
</li>

<li>Assembly language for Power Architecture, Part 1: Programming concepts and beginning PowerPC instructions<br />
<a href="http://www.ibm.com/developerworks/linux/library/l-powasm1/index.html">http://www.ibm.com/developerworks/linux/library/l-powasm1/index.html</a>
</li>

<li>Assembly language for Power Architecture, Part 2: The art of loading and storing on PowerPC<br />
<a href="http://www.ibm.com/developerworks/linux/library/l-powasm2/index.html">http://www.ibm.com/developerworks/linux/library/l-powasm2/index.html</a>
</li>

<li>Assembly language for Power Architecture, Part 3: Programming with the PowerPC branch processor<br />
<a href="http://www.ibm.com/developerworks/library/l-powasm3/index.html">http://www.ibm.com/developerworks/library/l-powasm3/index.html</a>
</li>

<li>Assembly language for Power Architecture, Part 4: Function calls and the PowerPC 64-bit ABI<br />
<a href="http://www.ibm.com/developerworks/linux/library/l-powasm4/index.html">http://www.ibm.com/developerworks/linux/library/l-powasm4/index.html</a>
</li>

<li>PowerPC overview (poněkud starší materiály z&nbsp;roku 2006)<br />
<a href="http://titancity.com/articles/ppc.html">http://titancity.com/articles/ppc.html</a>
</li>

<li>PowerPC (Wikipedia)<br />
<a href="https://en.wikipedia.org/wiki/PowerPC">https://en.wikipedia.org/wiki/PowerPC</a>
</li>

<li>Status Register<br />
<a href="https://en.wikipedia.org/wiki/Status_register">https://en.wikipedia.org/wiki/Status_register</a>
</li>

<li>Why Learn Assembly Language?<br />
<a href="http://www.codeproject.com/Articles/89460/Why-Learn-Assembly-Language">http://www.codeproject.com/Articles/89460/Why-Learn-Assembly-Language</a>
</li>

<li>Is Assembly still relevant?<br />
<a href="http://programmers.stackexchange.com/questions/95836/is-assembly-still-relevant">http://programmers.stackexchange.com/questions/95836/is-assembly-still-relevant</a>
</li>

<li>Why Learning Assembly Language Is Still a Good Idea<br />
<a href="http://www.onlamp.com/pub/a/onlamp/2004/05/06/writegreatcode.html">http://www.onlamp.com/pub/a/onlamp/2004/05/06/writegreatcode.html</a>
</li>

<li>Assembly language today<br />
<a href="http://beust.com/weblog/2004/06/23/assembly-language-today/">http://beust.com/weblog/2004/06/23/assembly-language-today/</a>
</li>

<li>RISC-V Draft Sompressed ISA Version 1.9 Released<br />
<a href="https://blog.riscv.org/2015/11/risc-v-draft-compressed-isa-version-1-9-released/">https://blog.riscv.org/2015/11/risc-v-draft-compressed-isa-version-1-9-released/</a>
</li>

<li>RISC vs. CISC: the Post-RISC Era<br />
<a href="http://archive.arstechnica.com/cpu/4q99/risc-cisc/rvc-1.html">http://archive.arstechnica.com/cpu/4q99/risc-cisc/rvc-1.html</a>
</li>

<li>Introduction to ARM Thumb<br />
<a href="http://www.embedded.com/electronics-blogs/beginner-s-corner/4024632/Introduction-to-ARM-thumb">http://www.embedded.com/electronics-blogs/beginner-s-corner/4024632/Introduction-to-ARM-thumb</a>
</li>

<li>Code Size – a comprehensive comparison of microMIPS32 and Thumb code size using many Megabytes of customer code<br />
<a href="https://community.arm.com/groups/processors/blog/2014/04/28/code-size-a-comprehensive-comparison-of-micromips32-and-thumb-code-size-using-many-megabytes-of-customer-code">https://community.arm.com/groups/processors/blog/2014/04/28/code-size-a-comprehensive-comparison-of-micromips32-and-thumb-code-size-using-many-megabytes-of-customer-code</a>
</li>

<li>MIPS MCUs Outrun ARM<br />
<a href="http://www.linleygroup.com/newsletters/newsletter_detail.php?num=5117">http://www.linleygroup.com/newsletters/newsletter_detail.php?num=5117</a>
</li>

<li>Improving Energy Efficiency and Reducing Code Size with RISC-V Compressed<br />
<a href="http://www.eecs.berkeley.edu/~waterman/papers/ms-thesis.pdf">http://www.eecs.berkeley.edu/~waterman/papers/ms-thesis.pdf</a>
</li>

<li>An Introduction to Lock-Free Programming<br />
<a href="http://preshing.com/20120612/an-introduction-to-lock-free-programming/">http://preshing.com/20120612/an-introduction-to-lock-free-programming/</a>
</li>

<li>Sequential consistency<br />
<a href="https://en.wikipedia.org/wiki/Sequential_consistency">https://en.wikipedia.org/wiki/Sequential_consistency</a>
</li>

<li>Understanding Atomic Operations<br />
<a href="https://jfdube.wordpress.com/2011/11/30/understanding-atomic-operations/">https://jfdube.wordpress.com/2011/11/30/understanding-atomic-operations/</a>
</li>

<li>Load-link/store-conditional<br />
<a href="https://en.wikipedia.org/wiki/Load-link/store-conditional">https://en.wikipedia.org/wiki/Load-link/store-conditional</a>
</li>

<li>The RISC-V Compressed Instruction Set Manual (Pozor: verze 1.7)<br />
<a href="http://riscv.org/spec/riscv-compressed-spec-v1.7.pdf">http://riscv.org/spec/riscv-compressed-spec-v1.7.pdf</a>
</li>

<li>Carry bits, The Architect's Trap<br />
<a href="http://yarchive.net/comp/carry_bit.html">http://yarchive.net/comp/carry_bit.html</a>
</li>

<li>Microprocessor Design/ALU Flags<br />
<a href="https://en.wikibooks.org/wiki/Microprocessor_Design/ALU_Flags">https://en.wikibooks.org/wiki/Microprocessor_Design/ALU_Flags</a>
</li>

<li>Flags register in an out-of-order processor<br />
<a href="http://cs.stackexchange.com/questions/42095/flags-register-in-an-out-of-order-processor">http://cs.stackexchange.com/questions/42095/flags-register-in-an-out-of-order-processor</a>
</li>

<li>AMD Am29000<br />
<a href="https://en.wikipedia.org/wiki/AMD_Am29000">https://en.wikipedia.org/wiki/AMD_Am29000</a>
</li>

<li>Status register<br />
<a href="https://en.wikipedia.org/wiki/Status_register">https://en.wikipedia.org/wiki/Status_register</a>
</li>

<li>AMD Am29000 microprocessor family<br />
<a href="http://www.cpu-world.com/CPUs/29000/">http://www.cpu-world.com/CPUs/29000/</a>
</li>

<li>AMD 29k (Streamlined Instruction Processor) ID Guide<br />
<a href="http://www.cpushack.com/Am29k.html">http://www.cpushack.com/Am29k.html</a>
</li>

<li>AMD Am29000 (Wikipedia)<br />
<a href="http://en.wikipedia.org/wiki/AMD_Am29000">http://en.wikipedia.org/wiki/AMD_Am29000</a>
</li>

<li>AMD K5 ("K5" / "5k86")<br />
<a href="http://www.pcguide.com/ref/cpu/fam/g5K5-c.html">http://www.pcguide.com/ref/cpu/fam/g5K5-c.html</a>
</li>

<li>Comparing four 32-bit soft processor cores<br />
<a href="http://www.eetimes.com/author.asp?section_id=14&doc_id=1286116">http://www.eetimes.com/author.asp?section_id=14&doc_id=1286116</a>
</li>

<li>RISC-V Instruction Set<br />
<a href="http://riscv.org/download.html#spec_compressed_isa">http://riscv.org/download.html#spec_compressed_isa</a>
</li>

<li>RISC-V Spike (ISA Simulator)<br />
<a href="http://riscv.org/download.html#isa-sim">http://riscv.org/download.html#isa-sim</a>
</li>

<li>RISC-V (Wikipedia)<br />
<a href="https://en.wikipedia.org/wiki/RISC-V">https://en.wikipedia.org/wiki/RISC-V</a>
</li>

<li>David Patterson (Wikipedia)<br />
<a href="https://en.wikipedia.org/wiki/David_Patterson_(computer_scientist)">https://en.wikipedia.org/wiki/David_Patterson_(computer_scientist)</a>
</li>

<li>OpenRISC (oficiální­ stránky tohoto projektu)<br />
<a href="http://openrisc.io/">http://openrisc.io/</a>
</li>

<li>OpenRISC architecture<br />
<a href="http://openrisc.io/architecture.html">http://openrisc.io/architecture.html</a>
</li>

<li>Emulátor OpenRISC CPU v JavaScriptu<br />
<a href="http://s-macke.github.io/jor1k/demos/main.html">http://s-macke.github.io/jor1k/demos/main.html</a>
</li>

<li>OpenRISC (Wikipedia)<br />
<a href="https://en.wikipedia.org/wiki/OpenRISC">https://en.wikipedia.org/wiki/OpenRISC</a>
</li>

<li>OpenRISC - instrukce<br />
<a href="http://sourceware.org/cgen/gen-doc/openrisc-insn.html">http://sourceware.org/cgen/gen-doc/openrisc-insn.html</a>
</li>

<li>OpenRISC - slajdy z&nbsp;přednášky o tomto projektu<br />
<a href="https://iis.ee.ethz.ch/~gmichi/asocd/lecturenotes/Lecture6.pdf">https://iis.ee.ethz.ch/~gmichi/asocd/lecturenotes/Lecture6.pdf</a>
</li>

<li>Maska mikroprocesoru RISC 1<br />
<a href="http://www.cs.berkeley.edu/~pattrsn/Arch/RISC1.jpg">http://www.cs.berkeley.edu/~pattrsn/Arch/RISC1.jpg</a>
</li>

<li>Maska mikroprocesoru RISC 2<br />
<a href="http://www.cs.berkeley.edu/~pattrsn/Arch/RISC2.jpg">http://www.cs.berkeley.edu/~pattrsn/Arch/RISC2.jpg</a>
</li>

<li>C.E. Sequin and D.A.Patterson: Design and Implementation of RISC I<br />
<a href="http://www.eecs.berkeley.edu/Pubs/TechRpts/1982/CSD-82-106.pdf">http://www.eecs.berkeley.edu/Pubs/TechRpts/1982/CSD-82-106.pdf</a>
</li>

<li>Berkeley RISC<br />
<a href="http://en.wikipedia.org/wiki/Berkeley_RISC">http://en.wikipedia.org/wiki/Berkeley_RISC</a>
</li>

<li>Great moments in microprocessor history<br />
<a href="http://www.ibm.com/developerworks/library/pa-microhist.html">http://www.ibm.com/developerworks/library/pa-microhist.html</a>
</li>

<li>Microprogram-Based Processors<br />
<a href="http://research.microsoft.com/en-us/um/people/gbell/Computer_Structures_Principles_and_Examples/csp0167.htm">http://research.microsoft.com/en-us/um/people/gbell/Computer_Structures_Principles_and_Examples/csp0167.htm</a>
</li>

<li>Great Microprocessors of the Past and Present<br />
<a href="http://www.cpushack.com/CPU/cpu1.html">http://www.cpushack.com/CPU/cpu1.html</a>
</li>

<li>A Brief History of Microprogramming<br />
<a href="http://www.cs.clemson.edu/~mark/uprog.html">http://www.cs.clemson.edu/~mark/uprog.html</a>
</li>

<li>What is RISC?<br />
<a href="http://www-cs-faculty.stanford.edu/~eroberts/courses/soco/projects/2000-01/risc/whatis/">http://www-cs-faculty.stanford.edu/~eroberts/courses/soco/projects/2000-01/risc/whatis/</a>
</li>

<li>RISC vs. CISC<br />
<a href="http://www-cs-faculty.stanford.edu/~eroberts/courses/soco/projects/2000-01/risc/risccisc/">http://www-cs-faculty.stanford.edu/~eroberts/courses/soco/projects/2000-01/risc/risccisc/</a>
</li>

<li>RISC and CISC definitions:<br />
<a href="http://www.cpushack.com/CPU/cpuAppendA.html">http://www.cpushack.com/CPU/cpuAppendA.html</a>
</li>

<li>FPGA<br />
<a href="https://cs.wikipedia.org/wiki/Programovateln%C3%A9_hradlov%C3%A9_pole">https://cs.wikipedia.org/wiki/Programovateln%C3%A9_hradlov%C3%A9_pole</a>
</li>

<li>The Evolution of RISC<br />
<a href="http://www.ibm.com/developerworks/library/pa-microhist.html#sidebar1">http://www.ibm.com/developerworks/library/pa-microhist.html#sidebar1</a>
</li>

<li>SPARC Processor Family Photo<br />
<a href="http://thenetworkisthecomputer.com/site/?p=243">http://thenetworkisthecomputer.com/site/?p=243</a>
</li>

<li>SPARC: Decades of Continuous Technical Innovation<br />
<a href="http://blogs.oracle.com/ontherecord/entry/sparc_decades_of_continuous_technical">http://blogs.oracle.com/ontherecord/entry/sparc_decades_of_continuous_technical</a>
</li>

<li>The SPARC processors<br />
<a href="http://www.top500.org/2007_overview_recent_supercomputers/sparc_processors">http://www.top500.org/2007_overview_recent_supercomputers/sparc_processors</a>
</li>

<li>Reduced instruction set computing (Wikipedia)<br />
<a href="http://en.wikipedia.org/wiki/Reduced_instruction_set_computer">http://en.wikipedia.org/wiki/Reduced_instruction_set_computer</a>
</li>

<li>MIPS architecture (Wikipedia)<br />
<a href="http://en.wikipedia.org/wiki/MIPS_architecture">http://en.wikipedia.org/wiki/MIPS_architecture</a>
</li>

<li>Very long instruction word (Wikipedia)<br />
<a href="http://en.wikipedia.org/wiki/Very_long_instruction_word">http://en.wikipedia.org/wiki/Very_long_instruction_word</a>
</li>

<li>Classic RISC pipeline (Wikipedia)<br />
<a href="http://en.wikipedia.org/wiki/Classic_RISC_pipeline">http://en.wikipedia.org/wiki/Classic_RISC_pipeline</a>
</li>

<li>R2000 Microprocessor (Wikipedia)<br />
<a href="http://en.wikipedia.org/wiki/R2000_(microprocessor)">http://en.wikipedia.org/wiki/R2000_(microprocessor)</a>
</li>

<li>R3000 Microprocessor (Wikipedia)<br />
<a href="http://en.wikipedia.org/wiki/R3000">http://en.wikipedia.org/wiki/R3000</a>
</li>

<li>R4400 Microprocessor (Wikipedia)<br />
<a href="http://en.wikipedia.org/wiki/R4400">http://en.wikipedia.org/wiki/R4400</a>
</li>

<li>R8000 Microprocessor (Wikipedia)<br />
<a href="http://en.wikipedia.org/wiki/R8000">http://en.wikipedia.org/wiki/R8000</a>
</li>

<li>R10000 Microprocessor (Wikipedia)<br />
<a href="http://en.wikipedia.org/wiki/R10000">http://en.wikipedia.org/wiki/R10000</a>
</li>

<li>SPARC (Wikipedia)<br />
<a href="http://en.wikipedia.org/wiki/Sparc">http://en.wikipedia.org/wiki/Sparc</a>
</li>

<li>CPU design (Wikipedia)<br />
<a href="http://en.wikipedia.org/wiki/CPU_design">http://en.wikipedia.org/wiki/CPU_design</a>
</li>

<li>Control unit (Wikipedia)<br />
<a href="http://en.wikipedia.org/wiki/Control_unit">http://en.wikipedia.org/wiki/Control_unit</a>
</li>

</ol>



<p></p><p></p>
<p><small>Autor: <a href="http://www.fit.vutbr.cz/~tisnovpa">Pavel Tišnovský</a> &nbsp; 2016</small></p>
</body>
</html>

