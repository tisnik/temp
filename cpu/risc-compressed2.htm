<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
        "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html>
<head>
<title>RISCové mikroprocesory s komprimovanými instrukčními sadami (2)</title>
<meta name="Author" content="Pavel Tisnovsky" />
<meta name="Generator" content="vim" />
<meta http-equiv="content-type" content="text/html; charset=utf-8" />
<style type="text/css">
         body {color:#000000; background:#ffffff;}
         h1  {font-family: arial, helvetica, sans-serif; color:#ffffff; background-color:#c00000; text-align:center; padding-left:1em}
         h2  {font-family: arial, helvetica, sans-serif; color:#ffffff; background-color:#0000c0; padding-left:1em; text-align:left}
         h3  {font-family: arial, helvetica, sans-serif; color:#000000; background-color:#c0c0c0; padding-left:1em; text-align:left}
         h4  {font-family: arial, helvetica, sans-serif; color:#000000; background-color:#e0e0e0; padding-left:1em; text-align:left}
         a   {font-family: arial, helvetica, sans-serif;}
         li  {font-family: arial, helvetica, sans-serif; color:#000000; text-align:justify; width:450px;}
         ol  {font-family: arial, helvetica, sans-serif; color:#000000; text-align:justify; width:450px;}
         ul  {font-family: arial, helvetica, sans-serif; color:#000000; text-align:justify; width:450px;}
         p   {font-family: arial, helvetica, sans-serif; color:#000000; text-align:justify;}
         pre {background:#e0e0e0}
</style>
</head>

<body>

<h1>RISCové mikroprocesory s komprimovanými instrukčními sadami (2)</h1>

<h3>Pavel Tišnovský</h3>

<p></p>

<h1>Úvodník</h1>

<p>V předchozí části článku o mikroprocesorech s RISCovou architekturou jsme si uvedli důvody, které vedly návrháře RISCových procesorů k zavedení takzvaných &bdquo;komprimovaných&ldquo; instrukcí. Kromě minule popsané sady MIPS16e samozřejmě existují i sady další, především pak RVC (RISC-V &bdquo;C&ldquo;) a populární Thumb.</p>



<h2>Obsah</h2>

<p><a href="#k01">1. RISCové mikroprocesory s&nbsp;komprimovanými instrukčními sadami (2)</a></p>
<p><a href="#k02">2. RVC (RISC-V &ndash; C)</a></p>
<p><a href="#k03">3. Kódování instrukcí různé šířky v&nbsp;architektuře RISC-V</a></p>
<p><a href="#k04">4. Kódování instrukcí při použití RVC</a></p>
<p><a href="#k05">5. Formát instrukcí typu CL (LOAD)</a></p>
<p><a href="#k06">6. Formát instrukcí typu CS (STORE)</a></p>
<p><a href="#k07">7. Formát instrukcí typu CB (BRANCH)</a></p>
<p><a href="#k08">8. Formát instrukcí typu CJ (JUMP)</a></p>
<p><a href="#k09">9. Formát instrukcí typu CR (REGISTER)</a></p>
<p><a href="#k10">10. Formát instrukcí typu CI (IMMEDIATE)</a></p>
<p><a href="#k11">11. Formát instrukcí typu CCS (stack-relative store)</a></p>
<p><a href="#k12">12. Formát instrukcí typu CIW (WIDE IMMEDIATE)</a></p>
<p><a href="#k13">13. Výsledky měření: zmenšení velikosti kódu použitím RVC</a></p>
<p><a href="#k14">14. Odkazy na Internetu</a></p>



<p><a name="k01"></a></p>
<h2 id="k01">1. RISCové mikroprocesory s&nbsp;komprimovanými instrukčními sadami (2)</h2>

<p><i>&bdquo;The majority of today's processors can’t rightfully be called
completely RISC or completely CISC. The two textbook architectures have evolved
towards each other to such an extent that there’s no longer a clear distinction
between their respective approaches to increasing performance and
efficiency.&ldquo;</i></p>

<p><a
href="http://www.root.cz/clanky/riscove-mikroprocesory-s-komprimovanymi-instrukcnimi-sadami/">V&nbsp;předchozí
části</a> seriálu o mikroprocesorech s&nbsp;architekturou RISC jsme si uvedli
několik důvodů, proč se u některých RISCových architektur (většinou těch
komerčně úspěšných, což pravděpodobně nebude úplná náhoda :-) kromě původní
čistě RISCové instrukční sady zavedla i instrukční sada
s&nbsp;&bdquo;komprimovanými&ldquo; instrukcemi, což v&nbsp;kontextu klasických
RISCových mikroprocesorů znamená instrukce s&nbsp;šířkou osmi, ovšem většinou
šestnácti bitů (alternativně též kombinace 16bitových a 32bitových instrukcí).
Tyto komprimované instrukční sady se zpočátku začaly uplatňovat především
v&nbsp;těch oblastech, kde lze použít pouze cache o relativně malé kapacitě a
kde je přístup do paměti instrukcí pomalý (to platí zejména pro embedded
zařízení vybavená Flash ROM, přeneseně pak i pro mikrořadiče). Zajímavé však
je, že dnes tyto instrukční sady našly své uplatnění i v&nbsp;dalších
oblastech, například u tabletů atd. To souvisí mj.&nbsp;i s&nbsp;neustále se
zvětšujícím rozdílem mezi rychlostí CPU a dobou přístupu do pamětí (tento
rozdíl se vlastně ještě násobí s&nbsp;tím, jak roste počet procesorových
jader).</p>

<p>První popsanou &bdquo;komprimovanou&ldquo; instrukční sadou byla sada
<i>MIPS16e</i> používaná u některých mikroprocesorů s&nbsp;architekturou MIPS.
Dnes si přiblížíme zejména možnosti, které v&nbsp;této oblasti nabízí
progresivní architektura <i>RISC-V</i>, jejíž možnosti se neustále rozvíjejí a
především je navržena tak, aby se <i>RISC-V</i> mohla rozvíjet několika směry.
Popisem architektury <i>RISC-V</i> z&nbsp;pohledu programátora jsme se již
zabývali v&nbsp;předchozích částech tohoto seriálu [<a
href="http://www.root.cz/clanky/otevrene-riscove-architektury-openrisc-a-risc-v/">1</a>]
[<a
href="http://www.root.cz/clanky/instrukcni-sada-procesorovych-jader-s-otevrenou-architekturou-risc-v/">2</a>]
[<a
href="http://www.root.cz/clanky/rozsireni-instrukcni-sady-procesorovych-jader-s-otevrenou-architekturou-risc-v/">3</a>]
a [<a
href="http://www.root.cz/clanky/instrukcni-sady-procesorovych-jader-s-otevrenou-architekturou-risc-v-dokonceni/">4</a>].
Vysvětlili jsme si princip kódování instrukcí i způsob vytváření nových
rozšiřujících instrukčních sad. Poměrně specifická je v&nbsp;tomto ohledu
především instrukční sada označená písmenem &bdquo;C&ldquo;, která je též
nazývána <i>RVC (RISC-V Compressed)</i>. Specifičnost instrukční sady
&bdquo;C&ldquo; spočívá v&nbsp;tom, že se v&nbsp;ní pracuje s&nbsp;instrukcemi
o šířce šestnácti bitů a nikoli 32 bitů; navíc se v&nbsp;instrukčních slovech
aktivně používají i nejnižší dva bity kódu instrukce (ty mají pro 32bitové
instrukce hodnotu 11).</p>

<p>Pro malé připomenutí: v&nbsp;rámci projektu <i>RISC-V</i> již bylo navrženo
a implementováno větší množství vzájemně se doplňujících instrukčních sad,
zejména pak:</p>

<table>
<tr><th>Označení</th><th>Význam</th></tr>
<tr><td>&nbsp;</td><th>Oficiální sady instrukcí</th></tr>
<tr><td>I</td><td>aritmetické instrukce (32/64 bit), load/store, skoky, rozvětvení, speciální operace</td></tr>
<tr><td>M</td><td>rozšíření o instrukce pro násobení a dělení</td></tr>
<tr><td>A</td><td>atomické operace typu read-modify-write (využitelné zejména pro multicore)</td></tr>
<tr><td>F</td><td>operace s&nbsp;hodnotami typu float/single (jednoduchá přesnost)</td></tr>
<tr><td>D</td><td>operace s&nbsp;hodnotami typu double (dvojitá přesnost)</td></tr>
<tr><td>&nbsp;</td><th>Další rozšíření</th></tr>
<tr><td>Q</td><td>operace s&nbsp;hodnotami typu quad (čtyřnásobná přesnost)</td></tr>
<tr><td>L</td><td>decimální aritmetika</td></tr>
<tr><td>C</td><td><strong>komprimované instrukce (viz též navazující kapitoly)</strong></td></tr>
<tr><td>B</td><td>bitové operace</td></tr>
<tr><td>T</td><td>podpora pro transakční paměť</td></tr>
<tr><td>P</td><td>SIMD operace</td></tr>
</table>



<p><a name="k02"></a></p>
<h2 id="k02">2. RVC (RISC-V &ndash; C)</h2>

<p><i>"Leveraging 25 years of hindsight, RISC-V was designed to support
compressed instructions from the start, leaving enough opcode space for RVC and
many other extensions"</i></p>

<p>Tvůrci formátu instrukcí pro mikroprocesory <i>RISC-V</i> nezapomněli ani na
to, že se tato procesorová jádra budou s&nbsp;velkou pravděpodobností používat
mj.&nbsp;i v&nbsp;embedded systémech, kde se z&nbsp;různých důvodů (již zmíněná
pomalá paměť Flash, relativně malá kapacita instrukční cache apod.) preferuje
mít možnost vytvářet kód s&nbsp;větší hustotou, a to i za cenu menší výkonnosti
celého čipu. Pro tyto účely byla navržena prozatím neoficiální instrukční sada
&bdquo;C&ldquo; nazývaná též <i>RVC (RISC-V Compressed)</i> s&nbsp;instrukcemi
o šířce 16 bitů a nikoli 32 bitů. Tato instrukční sada byla vytvořena
s&nbsp;tím, že se bude jednat o doplněk ke stávajícím instrukčním sadám, nebude
tedy nutné provádět přepínání mezi různými režimy činnosti (na rozdíl od Thumb
atd.).</p>

<p>Designéři architektury <i>RISC-V</i> se tak poučili z&nbsp;některých
problémů, které dříve doprovázely jejich konkurenty, a to jak ARM (nutnost
explicitního přepínání mezi A32 a Thumb, opuštění této kombinace
v&nbsp;AArch64) tak i x86_64 (komplikace mikroprocesoru s&nbsp;instrukční sadou
s&nbsp;instrukcemi proměnné délky). Podle soudobých měření se zdá, že
instrukční sada &bdquo;C&ldquo; může přinést zmenšení strojového kódu o
přibližně 25 až 30%, což dále vede ke snížení výpadků instrukční cache o 20 až
25% (zde je ovšem nutné podotknout, že do značné míry záleží na podpoře
v&nbsp;překladačích a JIT, tato podpora stále není dokonalá, takže lze
předpokládat další zlepšení).</p>

<p>Mimochodem, podobně jako je dnes většinou nemožné najít prakticky používaný
mikroprocesor s&nbsp;čistým CISC designem či naopak čistý RISC procesor, je i
problematika měření hustoty binárních aplikací poměrně komplikovaná a jako
taková je možné i měření provést šikovně takovým způsobem, aby bylo možné
prosazovat vlastní výrobek (mikroprocesor) na úkor konkurence. Pěkně je to
vidět například na následujících dvou zprávách, které se bez dalších
podrobností zmiňují o rozdílech mezi architekturami ARM a MIPS: [<a
href="http://www.linleygroup.com/newsletters/newsletter_detail.php?num=5117">1</a>]
[<a
href="https://community.arm.com/groups/processors/blog/2014/04/28/code-size-a-comprehensive-comparison-of-micromips32-and-thumb-code-size-using-many-megabytes-of-customer-code">2</a>].
I z&nbsp;tohoto důvodu je nutné počkat na měření založeném na široké bázi
projektů (například celé Linuxové distro) a porovnat vlastnosti RVC
s&nbsp;Thumb, Thumb 2 či MIPS16e.</p>



<p><a name="k03"></a></p>
<h2 id="k03">3. Kódování instrukcí různé šířky v&nbsp;architektuře RISC-V</h2>

<p><i>&bdquo;Size matters.&ldquo;</i></p>

<p>Připomeňme si nejprve již zmíněný způsob kódování instrukcí
v&nbsp;mikroprocesorových jádrech s&nbsp;architekturou <i>RISC-V</i>. Ten je
navržen takovým způsobem, aby byla instrukční sada velmi snadno rozšiřitelná, a
to i kdykoli v&nbsp;budoucnosti. V&nbsp;<i>RISC-V</i> se pro základní rozlišení
mezi &bdquo;komprimovanými&ldquo; šestnáctibitovými instrukcemi a instrukcemi
větší šířky používají nejnižší dva bity instrukčního slova, které pro
plnohodnotné RISCové 32bitové instrukce obsahují dvojici jedniček a pro
komprimované instrukce 16bitové pak jednu z&nbsp;kombinací 00, 01, 10. Dekodér
tedy může jen na základě hodnot těchto dvou bitů velmi snadno určit, jakým
způsobem má instrukci zpracovat (<i>RISC-V</i> je little endian, což je zde
poměrně důležité):</p>

<pre>
 15             0
+----------------+
|xxxxxxxxxxxxxxaa| aa != 11
+----------------+
</pre>

<p>Ve skutečnosti však jdou možnosti <i>RISC-V</i> ještě mnohem zajímavější (i
když prozatím příliš nevyužívané), neboť z&nbsp;dalších bitů operačního kódu
instrukce lze zjistit, zda má instrukce šířku 32bitů či zda je dokonce ještě
širší. Používá se následující způsob kódování, který teoreticky umožňuje tvořit
instrukce o šířce až 320bitů, což by pravděpodobně vedlo k&nbsp;monstróznímu
čipu s&nbsp;architekturou <i>VLIW</i> (i když: těžko říct, možnosti překladačů
jsou dnes dosti značné v&nbsp;porovnání s&nbsp;dobou, kdy <i>VLIW</i>
začínalo). Nás bude samozřejmě zajímat především kódování 32bitových operačních
kódů, které vypadá následovně:</p>

<pre>
 31            16 15             0
+----------------+----------------+
|xxxxxxxxxxxxxxxx|xxxxxxxxxxxbbb11| bb != 111
+----------------+----------------+
</pre>

<p>Pro (prozatím) teoretické instrukce o šířce 48 bitů, které dnes neexistují,
se používá tento formát:</p>

<pre>
 47            32 31            16 15             0
+----------------+----------------+----------------+
|xxxxxxxxxxxxxxxx|xxxxxxxxxxxxxxxx|xxxxxxxxxx011111|
+----------------+----------------+----------------+
</pre>

<p>A konečně pro instrukce s&nbsp;operačním kódem dlouhým 64 bitů by se použil
následující formát:</p>

<pre>
 63            48 47            32 31            16 15             0
+----------------+----------------+----------------+----------------+
|xxxxxxxxxxxxxxxx|xxxxxxxxxxxxxxxx|xxxxxxxxxxxxxxxx|xxxxxxxxx0111111|
+----------------+----------------+----------------+----------------+
</pre>

<p>Poznámka: šířka operačních kódů instrukcí žádným způsobem neurčuje šířku
operandů. To, že základní instrukční sada <i>RISC-V</i>, resp.&nbsp;přesněji
řečeno <i>RVI32</i>, používá instrukce o šířce 32 bitů a operandy o šířce
taktéž 32 bitů, je z&nbsp;tohoto pohledu vlastně &bdquo;náhoda&ldquo;. Ostatně
vzpomeňme například na již zmíněnou architekturu A32 (ARM) s&nbsp;instrukční
sadou <i>Thumb</i> (32bitové operandy, 16bitové instrukce) či A64
(<i>AArch64</i>) s&nbsp;64bitovými operandy a 32bitovými instrukcemi.</p>



<p><a name="k04"></a></p>
<h2 id="k04">4. Kódování instrukcí při použití RVC</h2>

<p>Aby bylo možné zakódovat instrukce, které měly původně šířku 32 bitů do
pouhých šestnácti bitů, museli tvůrci provést stejné změny v&nbsp;instrukční
sadě, s&nbsp;jakými jsme se již setkali minule:</p>

<ul>
<li>Zmenšit počet pracovních registrů použitelných u některých instrukcí (někdy
se jedná pouze o osm registrů x8 až x15, jiné instrukce pracují se všemi 32
registry, tj.&nbsp;včetně nulového registru).</li>
<li>Zmenšit šířku konstant, některé konstanty jsou automaticky násobeny
4&times; či 8&times;.</li>
<li>Sjednotit jeden zdrojový registr s&nbsp;registrem cílovým (dvouadresový
kód).</li>
<li>Některé instrukce bylo nutné vynechat (musí se tedy použít jejich
&bdquo;široká&ldquo; varianta).</li>
</ul>

<p>Najdeme zde ovšem i poměrně důležitou změnu: v&nbsp;instrukční sadě jsou
zahrnuty instrukce pro načtení a ukládání dat do registrů matematického
koprocesoru. Tvůrci instrukční sady argumentují tím, že tyto instrukce jsou
používány velmi často a proto si zaslouží být součástí komprimované instrukční
sady. I zde bylo nutné snížit počet adresovatelných registrů, a to konkrétně na
registry <strong>f8</strong> až <strong>f15</strong> (což koreluje
s&nbsp;podmnožinou celočíselných registrů <strong>x8</strong> až
<strong>x15</strong>).</p>

<p>V&nbsp;rámci komprimované instrukční sady &bdquo;C&ldquo; se používá celkem
osm různých formátů instrukčních slov:</p>

<table>
<tr><th>#</th><th>Zkratka</th><th>Význam</th><th>Poznámka</th></tr>
<tr><td>1</td><td>CL </td><td>instrukce typu LOAD</td><td>lze použít osm pracovních registrů x8..x15</td></tr>
<tr><td>2</td><td>CS </td><td>instrukce typu STORE</td><td>lze použít osm pracovních registrů x8..x15</td></tr>
<tr><td>3</td><td>CB </td><td>rozvětvení (BRANCH)</td><td>lze použít osm pracovních registrů x8..x15</td></tr>
<tr><td>4</td><td>CJ </td><td>skok (JUMP)</td><td>nepoužívá se žádný registr, pouze adresa skoku</td></tr>
<tr><td>5</td><td>CR </td><td>operace s registry (REGISTER)</td><td>lze použít jakýkoli registr</td></tr>
<tr><td>6</td><td>CI </td><td>operace s konstantou (IMMEDIATE)</td><td>lze použít jakýkoli registr</td></tr>
<tr><td>7</td><td>CCS</td><td>stack-relative store</td><td>lze použít jakýkoli registr</td></tr>
<tr><td>8</td><td>CIW</td><td>WIDE IMMEDIATE</td><td>lze použít osm pracovních registrů x8..x15</td></tr>
</table>

<p>Jednotlivé formáty instrukcí jsou podrobněji popsány v&nbsp;navazujících
kapitolách.</p>



<p><a name="k05"></a></p>
<h2 id="k05">5. Formát instrukcí typu CL (LOAD)</h2>

<p>První formát instrukcí, s&nbsp;nímž se dnes setkáme, je formát používaný
většinou základních instrukcí typu LOAD, tj.&nbsp;instrukcí, které slouží pro
načtení operandu do vybraného pracovního registru. Instrukce používající formát
<strong>CL</strong> mají instrukční slovo rozděleno na tato bitová pole:</p>

<pre>
 15 14 13 12 11 10  9  8  7  6  5  4  3  2  1  0
+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+
|function|  imm   |   rs1  | imm |   rd   | op  |
+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+
</pre>

<p>Význam jednotlivých bitových polí:</p>

<table>
<tr><th>#</th><th>Bitové pole</th><th>Význam</th></tr>
<tr><td>1</td><td>function</td><td>kód prováděné operace</td></tr>
<tr><td>2</td><td>imm</td><td>offset rozdělený na dvě části</td></tr>
<tr><td>3</td><td>rs1</td><td>index registru, v&nbsp;němž je uložena bázová adresa, může se jednat o registr x8 až x15</td></tr>
<tr><td>4</td><td>rd</td><td>index cílového registru, do něhož se uloží načtená data, registry x8 až x15 či f8 až f15</td></tr>
<tr><td>5</td><td>op</td><td>obsahuje kód C0</td></tr>
</table>

<p>Podporovány jsou tyto instrukce:</p>

<table>
<tr><th>#</th><th>Instrukce</th><th>Popis</th></tr>
<tr><td>1</td><td>C.LW</td><td>načtení 32bitového slova z adresy offset&times;4+rs1</td></tr>
<tr><td>2</td><td>C.LD</td><td>načtení 64bitového slova z adresy offset&times;8+rs1</td></tr>
<tr><td>3</td><td>C.LQ</td><td>načtení 128bitového slova z adresy offset&times;16+rs1</td></tr>
<tr><td>4</td><td>C.FLW</td><td>načtení 32bitové hodnoty typu <i>float</i> z adresy offset&times;4+rs1</td></tr>
<tr><td>5</td><td>C.FLD</td><td>načtení 64bitové hodnoty typu <i>double</i> z adresy offset&times;8+rs1</td></tr>
</table>

<p>Na tomto místě je důležité si uvědomit, že pouze některé instrukce mohou být
podporovány zvoleným čipem (což ostatně platí i pro dále popsané instrukce).
Například jen čipy s&nbsp;matematickým koprocesorem podporují instrukce
<strong>C.FLW</strong> a <strong>C.FLD</strong>, na čistě 32bitových čipech
nebudou podporovány instrukce <strong>C.LD</strong> a <strong>C.LQ</strong>
atd. Jediná univerzální instrukce je zde <strong>C.LW</strong>.</p>



<p><a name="k06"></a></p>
<h2 id="k06">6. Formát instrukcí typu CS (STORE)</h2>

<p>Opakem instrukcí typu LOAD jsou samozřejmě instrukce typu STORE sloužící pro
uložení obsahu vybraného pracovního registru (či registru matematického
koprocesoru) na zvolenou adresu operační paměti:</p>

<pre>
 15 14 13 12 11 10  9  8  7  6  5  4  3  2  1  0
+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+
|function|  imm   |   rs1  | imm |   rs2  | op  |
+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+
</pre>

<p>Význam jednotlivých bitových polí:</p>

<table>
<tr><th>#</th><th>Bitové pole</th><th>Význam</th></tr>
<tr><td>1</td><td>function</td><td>kód prováděné operace</td></tr>
<tr><td>2</td><td>imm</td><td>offset rozdělený na dvě části</td></tr>
<tr><td>3</td><td>rs1</td><td>index registru, v&nbsp;němž je uložena bázová adresa, může se jednat o registr x8 až x15</td></tr>
<tr><td>4</td><td>rs2</td><td>index registru obsahujícího data, která se mají uložit, registry x8 až x15 či f8 až f15</td></tr>
<tr><td>5</td><td>op</td><td>obsahuje kód C0</td></tr>
</table>

<p>Podporovány jsou tyto instrukce:</p>

<table>
<tr><th>#</th><th>Instrukce</th><th>Popis</th></tr>
<tr><td>1</td><td>C.SW</td><td>uložení 32bitového slova na adresu offset&times;4+rs1</td></tr>
<tr><td>2</td><td>C.SD</td><td>uložení 64bitového slova na adresu offset&times;8+rs1</td></tr>
<tr><td>3</td><td>C.SQ</td><td>uložení 128bitového slova na adresu offset&times;16+rs1</td></tr>
<tr><td>4</td><td>C.FSW</td><td>uložení 32bitové hodnoty typu <i>float</i> na adresu offset&times;4+rs1</td></tr>
<tr><td>5</td><td>C.FSD</td><td>uložení 64bitové hodnoty typu <i>double</i> na adresu offset&times;8+rs1</td></tr>
</table>

<p>Navíc sem spadají i aritmeticko-logické instrukce používající jen registry x8 až x15:</p>

<table>
<tr><th>#</th><th>Instrukce</th><th>Popis</th></tr>
<tr><td>1</td><td>C.AND</td><td>operace AND</td></tr>
<tr><td>2</td><td>C.OR</td><td>operace OR</td></tr>
<tr><td>3</td><td>C.XOR</td><td>operace XOR</td></tr>
<tr><td>4</td><td>C.SUB</td><td>rozdíl</td></tr>
<tr><td>5</td><td>C.ADDW</td><td>součet se znaménkovým rozšířením výsledku před zápisem</td></tr>
<tr><td>6</td><td>C.SUBW</td><td>rozdíl se znaménkovým rozšířením výsledku před zápisem</td></tr>
</table>



<p><a name="k07"></a></p>
<h2 id="k07">7. Formát instrukcí typu CB (BRANCH)</h2>

<p>Instrukce sloužící pro provedení podmíněného rozvětvení, tj.&nbsp;instrukce
typu BRANCH, používají další specifický instrukční formát, který se odlišuje od
již popsaných formátů:</p>

<pre>
 15 14 13 12 11 10  9  8  7  6  5  4  3  2  1  0
+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+
|function| offset |   rs1  |    offset    | op  |
+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+
</pre>

<p>Význam jednotlivých bitových polí:</p>

<table>
<tr><th>#</th><th>Bitové pole</th><th>Význam</th></tr>
<tr><td>1</td><td>function</td><td>kód prováděné operace</td></tr>
<tr><td>2</td><td>offset</td><td>offset rozdělený na dvě části</td></tr>
<tr><td>3</td><td>rs1</td><td>index registru, jehož hodnota je porovnána s&nbsp;nulou</td></tr>
<tr><td>4</td><td>op</td><td>obsahuje kód C1</td></tr>
</table>

<p>Tento formát je podporovaný dvěma instrukcemi:</p>

<table>
<tr><th>#</th><th>Instrukce</th><th>Popis</th></tr>
<tr><td>1</td><td>C.BEQZ</td><td>pokud je registr rs1 roven nule, provede se skok na adresu PC+offset (&plusm;256 bajtů)</td></tr>
<tr><td>2</td><td>C.BNEZ</td><td>pokud není registr rs1 roven nule, provede se skok na adresu PC+offset (&plusm;256 bajtů)</td></tr>
</table>

<p>Povšimněte si, že další skoky (či větvení) s&nbsp;podmínkou nejsou
v&nbsp;instrukční sadě &bdquo;C&ldquo; podporovány; navíc zde existuje omezení
na skoky v&nbsp;relativním rozsahu &plusm;256 bajtů. Pokud je zapotřebí skočit
dál, musí překladač sám použít buď dvojici C.J+BxxZ či se uchýlit
k&nbsp;použití &bdquo;plnohodnotné&ldquo; instrukce RV32I či RV64I.</p>

<p>Navíc se tento formát používá i u instrukcí pro posun doprava (tyto
instrukce se již nikam jinam nevešly, proto je část operačního kódu uložena
v&nbsp;prvním bitovém poli s&nbsp;offsetem):</p>

<table>
<tr><th>#</th><th>Instrukce</th><th>Popis</th></tr>
<tr><td>1</td><td>C.SRLI</td><td>bitový posun registru rd/rs1 doprava</td></tr>
<tr><td>2</td><td>C.SRAI</td><td>aritmetický posun registru rd/rs1 doprava</td></tr>
<tr><td>3</td><td>C.ANDI</td><td>bitový součin</td></tr>
</table>



<p><a name="k08"></a></p>
<h2 id="k08">8. Formát instrukcí typu CJ (JUMP)</h2>

<p>Instrukce pro nepodmíněný skok používají odlišný formát, než tomu bylo u
instrukcí typu BRANCH. Povšimněte si, že se zde již nepoužívá žádný index
zdrojového registru:</p>

<pre>
 15 14 13 12 11 10  9  8  7  6  5  4  3  2  1  0
+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+
|function|          adresa skoku          | op  |
+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+
</pre>

<p>Význam jednotlivých bitových polí:</p>

<table>
<tr><th>#</th><th>Bitové pole</th><th>Význam</th></tr>
<tr><td>1</td><td>function</td><td>kód prováděné operace</td></tr>
<tr><td>2</td><td>adresa skoku (relativní v&nbsp;rozsahu &plusm;2kB)</td><td></td></tr>
<tr><td>3</td><td>op</td><td>obsahuje kód C1</td></tr>
</table>

<p>Tento formát je opět podporovaný pouze dvěma instrukcemi, a to konkrétně
instrukcemi <strong>C.J</strong> a <strong>C.JAL</strong>:</p>

<table>
<tr><th>#</th><th>Instrukce</th><th>Popis</th></tr>
<tr><td>1</td><td>C.J</td><td>provede se skok na adresu PC+offset (&plusm;2kB)</td></tr>
<tr><td>2</td><td>C.JAL</td><td>provede se skok na adresu PC+offset (&plusm;2kB) + uložení návratové adresy do registru x1</td></tr>
</table>

<p>Instrukce <strong>C.JAL</strong> je zajímavá, protože implicitně adresuje
registr x1 pro uložení návratové adresy. V&nbsp;případě, že se mají skoky
provádět na libovolnou adresu, je nutné použít instrukce <strong>C.JR</strong>
a <strong>C.JALR</strong>, které však využívají odlišný instrukční formát.</p>



<p><a name="k09"></a></p>
<h2 id="k09">9. Formát instrukcí typu CR (REGISTER)</h2>

<p>Tento formát je využíván mnoha instrukcemi, které potřebují adresovat dva
zdrojové registry popř.&nbsp;jeden zdrojový registr a jeden registr cílový.
Speciálním případem jsou instrukce skoku <strong>C.JR</strong> a
<strong>C.JALR</strong>, u nichž se používá jen jediný zdrojový registr (druhý
zdrojový registr je nulový):</p>

<pre>
 15 14 13 12 11 10  9  8  7  6  5  4  3  2  1  0
+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+
|  function |    rd/rs1    |      rs2     |  op |
+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+
</pre>

<p>Význam jednotlivých bitových polí:</p>

<table>
<tr><th>#</th><th>Bitové pole</th><th>Význam</th></tr>
<tr><td>1</td><td>function</td><td>kód prováděné operace</td></tr>
<tr><td>2</td><td>rd/rs1</td><td>první zdrojový registr či cílový registr</td></tr>
<tr><td>3</td><td>rs2</td><td>druhý zdrojový registr či nula (u skoků)</td></tr>
<tr><td>4</td><td>op</td><td>obsahuje kód C0 či C2</td></tr>
</table>

<p>Tento formát používají instrukce provádějící různé operace, proto je tabulka
složitější, než v&nbsp;předchozích kapitolách:</p>

<table>
<tr><th>#</th><th>Instrukce</th><th>Popis</th></tr>
<tr><td>1</td><td>C.JR</td><td>skok na adresu uloženou v registru rs1, rs2 musí být nulový</td></tr>
<tr><td>2</td><td>C.JALR</td><td>podobně C.JR, jen navíc uloží návratovou hodnotu do registru x1</td></tr>
<tr><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td></tr>
<tr><td>3</td><td>C.MV</td><td>přesun dat mezi registry, kromě x0</td></tr>
<tr><td>4</td><td>C.ADD</td><td>součet (kromě x0, což je logické)</td></tr>
<tr><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td></tr>
<tr><td>5</td><td>C.EBREAK</td><td>kódován jako C.ADD s x0,x0</td></tr>
</table>

<p>Poznámky:</p>

<ol>
<li>Zdrojový registr může být jakýkoli, tj.&nbsp;x0 až x31.</li>
<li>Cílový registr může být jakýkoli kromě nuly, tj.&nbsp;x1 až x31.</li>
<li>U instrukcí skoků <strong>C.JR</strong> a <strong>C.JALR</strong> musí být
index registru rs2 nulový, jinak by se změnil operační kód instrukce.</li>
</ol>



<p><a name="k10"></a></p>
<h2 id="k10">10. Formát instrukcí typu CI (IMMEDIATE)</h2>

<p>Všechny instrukce, u nichž je zapotřebí použít jeden zdrojový nebo cílový
registr a konstantu, používají formát CI:</p>

<pre>
 15 14 13 12 11 10  9  8  7  6  5  4  3  2  1  0
+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+
|function|im|    rd/rs1    |      imm     | op  |
+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+
</pre>

<p>Význam jednotlivých bitových polí:</p>

<table>
<tr><th>#</th><th>Bitové pole</th><th>Význam</th></tr>
<tr><td>1</td><td>function</td><td>kód prováděné operace</td></tr>
<tr><td>2</td><td>imm</td><td>konstanta (má různý význam podle typu instrukce)</td></tr>
<tr><td>3</td><td>rd/rs1</td><td>index zdrojového nebo cílového registru</td></tr>
<tr><td>4</td><td>op</td><td>obsahuje kód C1 nebo C2</td></tr>
</table>

<p>Tento formát používají instrukce provádějící různé operace, proto je tabulka
opět složitější, než v&nbsp;předchozích kapitolách:</p>

<table>
<tr><th>#</th><th>Instrukce</th><th>Popis</th></tr>
<tr><td>1</td><td>C.LWSP </td><td>načtení 32bitového slova z&nbsp;adresy x2+offset&times;4 s&nbsp;uložením výsledku do registru rd</td></tr>
<tr><td>2</td><td>C.LDSP </td><td>načtení 64bitového slova z&nbsp;adresy x2+offset&times;8 s&nbsp;uložením výsledku do registru rd</td></tr>
<tr><td>3</td><td>C.LQSP </td><td>načtení 128bitového slova z&nbsp;adresy x2+offset&times;16 s&nbsp;uložením výsledku do registru rd</td></tr>
<tr><td>4</td><td>C.FLWSP</td><td>načtení 32bitového slova (<i>float</i>) z&nbsp;adresy x2+offset&times;4 s&nbsp;uložením výsledku do registru rd</td></tr>
<tr><td>5</td><td>C.FLDSP</td><td>načtení 64bitového slova (<i>double</i>) z&nbsp;adresy x2+offset&times;8 s&nbsp;uložením výsledku do registru rd</td></tr>
<tr><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td></tr>
<tr><td>6</td><td>C.LI</td><td>znaménkové rozšíření šestibitové konstanty a uložení do registru rd</td></tr>
<tr><td>7</td><td>C.LUI</td><td>bezznaménkové rozšíření šestibitové konstanty a uložení do registru rd na bity 12..17</td></tr>
<tr><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td></tr>
<tr><td>8</td><td>C.ADDI</td><td>přičtení konstanty (zdrojový registr=cílový registr)</td></tr>
<tr><td>9</td><td>C.ADDIW</td><td>přičtení konstanty a rozšíření na 64bitů (zdrojový registr=cílový registr)</td></tr>
<tr><td>10</td><td>C.ADDI16SP</td><td>podobné C.LUI, výsledek je x2, konstanta je však násobena 16ti</td></tr>
<tr><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td></tr>
<tr><td>11</td><td>C.SLLI</td><td>bitový posun registru rd/rs1 doleva</td></tr>
<tr><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td></tr>
<tr><td>12</td><td>C.NOP</td><td>rd/rs1=0, imm=0</td></tr>
</table>

<p>Poznámky:</p>

<ol>
<li>U prvních tří instrukcí platí, že registr rd nesmí být x0 (to by změnilo
operační kód instrukce, navíc nemá význam ukládat nic do registru
s&nbsp;konstantní nulou).</li>
<li>U instrukce <strong>C.LI</strong> nesmí být rd=x0</li>
<li>U instrukce <strong>C.LUI</strong> nesmí být rd=x0 či x2</li>
<li>Instrukce <strong>C.SLLI</strong> dokáže pracovat se všemi registry, ovšem
instrukce pro posun doprava nikoli. Je tomu tak z&nbsp;toho důvodu, že posuny
doleva jsou častější, proto dostaly v&nbsp;instrukčním souboru prioritu.</li>
</ol>



<p><a name="k11"></a></p>
<h2 id="k11">11. Formát instrukcí typu CCS (stack-relative store)</h2>

<p>Tento instrukční formát je využit u specializovaných instrukcí, u nichž se
pro určení bázové adresy implicitně používá registr x2. Pokud se tento registr
využívá ve funkci ukazatele na vrchol zásobníkového rámce, mohou instrukce
z&nbsp;této skupiny sloužit pro přístup k&nbsp;lokálním proměnným uloženým
právě na zásobníkovém rámci:</p>

<pre>
 15 14 13 12 11 10  9  8  7  6  5  4  3  2  1  0
+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+
|function|       offset       |      rs2     | op  |
+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+
</pre>

<p>Význam jednotlivých bitových polí:</p>

<table>
<tr><th>#</th><th>Bitové pole</th><th>Význam</th></tr>
<tr><td>1</td><td>function</td><td>kód prováděné operace</td></tr>
<tr><td>2</td><td>offset</td><td>konstanta použitá pro výpočet adresy na zásobníku</td></tr>
<tr><td>3</td><td>rs2</td><td>zdrojový registr (libovolný, včetně x0!)</td></tr>
<tr><td>4</td><td>op</td><td>obsahuje kód C2</td></tr>
</table>

<p>Tento formát může být podporovaný až pěti instrukcemi, v&nbsp;závislosti na
schopnostech konkrétního čipu:</p>

<table>
<tr><th>#</th><th>Instrukce</th><th>Popis</th></tr>
<tr><td>1</td><td>C.SWSP </td><td>uložení obsahu registru rs2 (32bitového slova) na adresu x2+offset&times;4</td></tr>
<tr><td>2</td><td>C.SDSP </td><td>uložení obsahu registru rs2 (64bitového slova) na adresu x2+offset&times;8</td></tr>
<tr><td>3</td><td>C.SQSP </td><td>uložení obsahu registru rs2 (128bitového slova) na adresu x2+offset&times;16</td></tr>
<tr><td>4</td><td>C.FSWSP</td><td>uložení obsahu FP registru rs2 (<i>float</i>) na adresu x2+offset&times;4</td></tr>
<tr><td>5</td><td>C.FSDSP</td><td>uložení obsahu FP registru rs2 (<i>double</i>) na adresu x2+offset&times;8</td></tr>
</table>



<p><a name="k12"></a></p>
<h2 id="k12">12. Formát instrukcí typu CIW (WIDE IMMEDIATE)</h2>

<p>Tento formát používá pouze jediná instrukce <strong>C.ADDI4SPN</strong>:</p>

<pre>
 15 14 13 12 11 10  9  8  7  6  5  4  3  2  1  0
+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+
|function|         imm           |   rd   | op  |
+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+
</pre>

<p>Význam jednotlivých bitových polí:</p>

<table>
<tr><th>#</th><th>Bitové pole</th><th>Význam</th></tr>
<tr><td>1</td><td>function</td><td>kód prováděné operace</td></tr>
<tr><td>2</td><td>imm</td><td>konstanta</td></tr>
<tr><td>3</td><td>rd</td><td>cílový registr</td></tr>
<tr><td>4</td><td>op</td><td>obsahuje kód C0</td></tr>
</table>

<p>Instrukce <strong>C.ADDI4SPN</strong> vypočte offset&times;4, přičte k&nbsp;němu obsah registru x2 a uloží výsledek do cílového registru.</p>



<p><a name="k13"></a></p>
<h2 id="k13">13. Výsledky měření: zmenšení velikosti kódu použitím RVC</h2>

<p>Podívejme se nyní na výsledky měření, konkrétně na to, jak se zmenšil
64bitový Linuxový kernel a které instrukce na zmenšení měly největší vliv (ve
skutečnosti máme k&nbsp;dispozici více výsledků měření, ty se však týkaly
především benchmarků, což není tak praktický příklad jako v&nbsp;případě
kernelu):</p>

<table>
<tr><th>Instrukce</th><th>% zmenšení</th></tr>
<tr><td>C.MV  </td><td>5,00 %</td></tr>
<tr><td>C.LDSP</td><td>4,44 %</td></tr>
<tr><td>C.SDSP</td><td>3,79 %</td></tr>
<tr><td>C.LI  </td><td>2,86 %</td></tr>
<tr><td>C.LD  </td><td>2,09 %</td></tr>
<tr><td>C.J   </td><td>1,53 %</td></tr>
<tr><td>C.BEQZ</td><td>1,24 %</td></tr>
<tr><td>C.JR  </td><td>1,05 %</td></tr>
<tr><td>C.ADDI</td><td>0,95 %</td></tr>
<tr><td>C.ADD </td><td>0,91 %</td></tr>
<tr><td>&nbsp;</td><td>&nbsp;</td></tr>
<tr><td>Celkově:</td><td>31,11 % (všechny instrukce)</td></tr>
</table>

<p>Osobně mi tyto výsledky přijdou být velmi zajímavé, protože se ukazuje, že
ve statickém kódu se nejčastěji vyskytují instrukce pro přenosy dat (prvních
pět řádků), teprve poté podmíněné a nepodmíněné skoky a v&nbsp;první desítce
nalezneme pouze dvě ALU instrukce, a to sčítání!</p>

<p>Ovšem dynamické měření (tj.&nbsp;počet <strong>provedených</strong>)
instrukcí nám dá zcela odlišné výsledky:</p>

<table>
<tr><th>Instrukce</th><th>% zmenšení</th></tr>
<tr><td>C.BNEZ</td><td>3,62 %</td></tr>
<tr><td>C.LD  </td><td>3,29 %</td></tr>
<tr><td>C.LI  </td><td>2,73 %</td></tr>
<tr><td>C.ADD </td><td>1,84 %</td></tr>
<tr><td>C.MV  </td><td>1,37 %</td></tr>
<tr><td>C.J   </td><td>1,35 %</td></tr>
<tr><td>C.LDSP</td><td>1,31 %</td></tr>
<tr><td>C.ADDI</td><td>1,26 %</td></tr>
<tr><td>C.SDSP</td><td>1,18 %</td></tr>
<tr><td>C.SD  </td><td>1,13 %</td></tr>
<tr><td>&nbsp;</td><td>&nbsp;</td></tr>
<tr><td>Celkově:</td><td>26,11 % (všechny instrukce)</td></tr>
</table>

<p>Asi podle očekávání toto měření &bdquo;vyhrála&ldquo; instrukce pro
podmíněný skok, která je (logicky) součástí většiny smyček.</p>



<p><a name="k14"></a></p>
<h2 id="k14">14. Odkazy na Internetu</h2>

<ol>

<li>RISC-V Draft Sompressed ISA Version 1.9 Released<br />
<a href="https://blog.riscv.org/2015/11/risc-v-draft-compressed-isa-version-1-9-released/">https://blog.riscv.org/2015/11/risc-v-draft-compressed-isa-version-1-9-released/</a>
</li>

<li>RISC vs. CISC: the Post-RISC Era<br />
<a href="http://archive.arstechnica.com/cpu/4q99/risc-cisc/rvc-1.html">http://archive.arstechnica.com/cpu/4q99/risc-cisc/rvc-1.html</a>
</li>

<li>Introduction to ARM Thumb<br />
<a href="http://www.embedded.com/electronics-blogs/beginner-s-corner/4024632/Introduction-to-ARM-thumb">http://www.embedded.com/electronics-blogs/beginner-s-corner/4024632/Introduction-to-ARM-thumb</a>
</li>

<li>Code Size – a comprehensive comparison of microMIPS32 and Thumb code size using many Megabytes of customer code<br />
<a href="https://community.arm.com/groups/processors/blog/2014/04/28/code-size-a-comprehensive-comparison-of-micromips32-and-thumb-code-size-using-many-megabytes-of-customer-code">https://community.arm.com/groups/processors/blog/2014/04/28/code-size-a-comprehensive-comparison-of-micromips32-and-thumb-code-size-using-many-megabytes-of-customer-code</a>
</li>

<li>MIPS MCUs Outrun ARM<br />
<a href="http://www.linleygroup.com/newsletters/newsletter_detail.php?num=5117">http://www.linleygroup.com/newsletters/newsletter_detail.php?num=5117</a>
</li>

<li>Improving Energy Efficiency and Reducing Code Size with RISC-V Compressed<br />
<a href="http://www.eecs.berkeley.edu/~waterman/papers/ms-thesis.pdf">http://www.eecs.berkeley.edu/~waterman/papers/ms-thesis.pdf</a>
</li>

<li>An Introduction to Lock-Free Programming<br />
<a href="http://preshing.com/20120612/an-introduction-to-lock-free-programming/">http://preshing.com/20120612/an-introduction-to-lock-free-programming/</a>
</li>

<li>Sequential consistency<br />
<a href="https://en.wikipedia.org/wiki/Sequential_consistency">https://en.wikipedia.org/wiki/Sequential_consistency</a>
</li>

<li>Understanding Atomic Operations<br />
<a href="https://jfdube.wordpress.com/2011/11/30/understanding-atomic-operations/">https://jfdube.wordpress.com/2011/11/30/understanding-atomic-operations/</a>
</li>

<li>Load-link/store-conditional<br />
<a href="https://en.wikipedia.org/wiki/Load-link/store-conditional">https://en.wikipedia.org/wiki/Load-link/store-conditional</a>
</li>

<li>The RISC-V Compressed Instruction Set Manual (Pozor: verze 1.7)<br />
<a href="http://riscv.org/spec/riscv-compressed-spec-v1.7.pdf">http://riscv.org/spec/riscv-compressed-spec-v1.7.pdf</a>
</li>

<li>Carry bits, The Architect's Trap<br />
<a href="http://yarchive.net/comp/carry_bit.html">http://yarchive.net/comp/carry_bit.html</a>
</li>

<li>Microprocessor Design/ALU Flags<br />
<a href="https://en.wikibooks.org/wiki/Microprocessor_Design/ALU_Flags">https://en.wikibooks.org/wiki/Microprocessor_Design/ALU_Flags</a>
</li>

<li>Flags register in an out-of-order processor<br />
<a href="http://cs.stackexchange.com/questions/42095/flags-register-in-an-out-of-order-processor">http://cs.stackexchange.com/questions/42095/flags-register-in-an-out-of-order-processor</a>
</li>

<li>AMD Am29000<br />
<a href="https://en.wikipedia.org/wiki/AMD_Am29000">https://en.wikipedia.org/wiki/AMD_Am29000</a>
</li>

<li>Status register<br />
<a href="https://en.wikipedia.org/wiki/Status_register">https://en.wikipedia.org/wiki/Status_register</a>
</li>

<li>AMD Am29000 microprocessor family<br />
<a href="http://www.cpu-world.com/CPUs/29000/">http://www.cpu-world.com/CPUs/29000/</a>
</li>

<li>AMD 29k (Streamlined Instruction Processor) ID Guide<br />
<a href="http://www.cpushack.com/Am29k.html">http://www.cpushack.com/Am29k.html</a>
</li>

<li>AMD Am29000 (Wikipedia)<br />
<a href="http://en.wikipedia.org/wiki/AMD_Am29000">http://en.wikipedia.org/wiki/AMD_Am29000</a>
</li>

<li>AMD K5 ("K5" / "5k86")<br />
<a href="http://www.pcguide.com/ref/cpu/fam/g5K5-c.html">http://www.pcguide.com/ref/cpu/fam/g5K5-c.html</a>
</li>

<li>Comparing four 32-bit soft processor cores<br />
<a href="http://www.eetimes.com/author.asp?section_id=14&doc_id=1286116">http://www.eetimes.com/author.asp?section_id=14&doc_id=1286116</a>
</li>

<li>RISC-V Instruction Set<br />
<a href="http://riscv.org/download.html#spec_compressed_isa">http://riscv.org/download.html#spec_compressed_isa</a>
</li>

<li>RISC-V Spike (ISA Simulator)<br />
<a href="http://riscv.org/download.html#isa-sim">http://riscv.org/download.html#isa-sim</a>
</li>

<li>RISC-V (Wikipedia)<br />
<a href="https://en.wikipedia.org/wiki/RISC-V">https://en.wikipedia.org/wiki/RISC-V</a>
</li>

<li>David Patterson (Wikipedia)<br />
<a href="https://en.wikipedia.org/wiki/David_Patterson_(computer_scientist)">https://en.wikipedia.org/wiki/David_Patterson_(computer_scientist)</a>
</li>

<li>OpenRISC (oficiální­ stránky tohoto projektu)<br />
<a href="http://openrisc.io/">http://openrisc.io/</a>
</li>

<li>OpenRISC architecture<br />
<a href="http://openrisc.io/architecture.html">http://openrisc.io/architecture.html</a>
</li>

<li>Emulátor OpenRISC CPU v JavaScriptu<br />
<a href="http://s-macke.github.io/jor1k/demos/main.html">http://s-macke.github.io/jor1k/demos/main.html</a>
</li>

<li>OpenRISC (Wikipedia)<br />
<a href="https://en.wikipedia.org/wiki/OpenRISC">https://en.wikipedia.org/wiki/OpenRISC</a>
</li>

<li>OpenRISC - instrukce<br />
<a href="http://sourceware.org/cgen/gen-doc/openrisc-insn.html">http://sourceware.org/cgen/gen-doc/openrisc-insn.html</a>
</li>

<li>OpenRISC - slajdy z&nbsp;přednášky o tomto projektu<br />
<a href="https://iis.ee.ethz.ch/~gmichi/asocd/lecturenotes/Lecture6.pdf">https://iis.ee.ethz.ch/~gmichi/asocd/lecturenotes/Lecture6.pdf</a>
</li>

<li>Maska mikroprocesoru RISC 1<br />
<a href="http://www.cs.berkeley.edu/~pattrsn/Arch/RISC1.jpg">http://www.cs.berkeley.edu/~pattrsn/Arch/RISC1.jpg</a>
</li>

<li>Maska mikroprocesoru RISC 2<br />
<a href="http://www.cs.berkeley.edu/~pattrsn/Arch/RISC2.jpg">http://www.cs.berkeley.edu/~pattrsn/Arch/RISC2.jpg</a>
</li>

<li>C.E. Sequin and D.A.Patterson: Design and Implementation of RISC I<br />
<a href="http://www.eecs.berkeley.edu/Pubs/TechRpts/1982/CSD-82-106.pdf">http://www.eecs.berkeley.edu/Pubs/TechRpts/1982/CSD-82-106.pdf</a>
</li>

<li>Berkeley RISC<br />
<a href="http://en.wikipedia.org/wiki/Berkeley_RISC">http://en.wikipedia.org/wiki/Berkeley_RISC</a>
</li>

<li>Great moments in microprocessor history<br />
<a href="http://www.ibm.com/developerworks/library/pa-microhist.html">http://www.ibm.com/developerworks/library/pa-microhist.html</a>
</li>

<li>Microprogram-Based Processors<br />
<a href="http://research.microsoft.com/en-us/um/people/gbell/Computer_Structures_Principles_and_Examples/csp0167.htm">http://research.microsoft.com/en-us/um/people/gbell/Computer_Structures_Principles_and_Examples/csp0167.htm</a>
</li>

<li>Great Microprocessors of the Past and Present<br />
<a href="http://www.cpushack.com/CPU/cpu1.html">http://www.cpushack.com/CPU/cpu1.html</a>
</li>

<li>A Brief History of Microprogramming<br />
<a href="http://www.cs.clemson.edu/~mark/uprog.html">http://www.cs.clemson.edu/~mark/uprog.html</a>
</li>

<li>What is RISC?<br />
<a href="http://www-cs-faculty.stanford.edu/~eroberts/courses/soco/projects/2000-01/risc/whatis/">http://www-cs-faculty.stanford.edu/~eroberts/courses/soco/projects/2000-01/risc/whatis/</a>
</li>

<li>RISC vs. CISC<br />
<a href="http://www-cs-faculty.stanford.edu/~eroberts/courses/soco/projects/2000-01/risc/risccisc/">http://www-cs-faculty.stanford.edu/~eroberts/courses/soco/projects/2000-01/risc/risccisc/</a>
</li>

<li>RISC and CISC definitions:<br />
<a href="http://www.cpushack.com/CPU/cpuAppendA.html">http://www.cpushack.com/CPU/cpuAppendA.html</a>
</li>

<li>FPGA<br />
<a href="https://cs.wikipedia.org/wiki/Programovateln%C3%A9_hradlov%C3%A9_pole">https://cs.wikipedia.org/wiki/Programovateln%C3%A9_hradlov%C3%A9_pole</a>
</li>

<li>The Evolution of RISC<br />
<a href="http://www.ibm.com/developerworks/library/pa-microhist.html#sidebar1">http://www.ibm.com/developerworks/library/pa-microhist.html#sidebar1</a>
</li>

<li>SPARC Processor Family Photo<br />
<a href="http://thenetworkisthecomputer.com/site/?p=243">http://thenetworkisthecomputer.com/site/?p=243</a>
</li>

<li>SPARC: Decades of Continuous Technical Innovation<br />
<a href="http://blogs.oracle.com/ontherecord/entry/sparc_decades_of_continuous_technical">http://blogs.oracle.com/ontherecord/entry/sparc_decades_of_continuous_technical</a>
</li>

<li>The SPARC processors<br />
<a href="http://www.top500.org/2007_overview_recent_supercomputers/sparc_processors">http://www.top500.org/2007_overview_recent_supercomputers/sparc_processors</a>
</li>

<li>Reduced instruction set computing (Wikipedia)<br />
<a href="http://en.wikipedia.org/wiki/Reduced_instruction_set_computer">http://en.wikipedia.org/wiki/Reduced_instruction_set_computer</a>
</li>

<li>MIPS architecture (Wikipedia)<br />
<a href="http://en.wikipedia.org/wiki/MIPS_architecture">http://en.wikipedia.org/wiki/MIPS_architecture</a>
</li>

<li>Very long instruction word (Wikipedia)<br />
<a href="http://en.wikipedia.org/wiki/Very_long_instruction_word">http://en.wikipedia.org/wiki/Very_long_instruction_word</a>
</li>

<li>Classic RISC pipeline (Wikipedia)<br />
<a href="http://en.wikipedia.org/wiki/Classic_RISC_pipeline">http://en.wikipedia.org/wiki/Classic_RISC_pipeline</a>
</li>

<li>R2000 Microprocessor (Wikipedia)<br />
<a href="http://en.wikipedia.org/wiki/R2000_(microprocessor)">http://en.wikipedia.org/wiki/R2000_(microprocessor)</a>
</li>

<li>R3000 Microprocessor (Wikipedia)<br />
<a href="http://en.wikipedia.org/wiki/R3000">http://en.wikipedia.org/wiki/R3000</a>
</li>

<li>R4400 Microprocessor (Wikipedia)<br />
<a href="http://en.wikipedia.org/wiki/R4400">http://en.wikipedia.org/wiki/R4400</a>
</li>

<li>R8000 Microprocessor (Wikipedia)<br />
<a href="http://en.wikipedia.org/wiki/R8000">http://en.wikipedia.org/wiki/R8000</a>
</li>

<li>R10000 Microprocessor (Wikipedia)<br />
<a href="http://en.wikipedia.org/wiki/R10000">http://en.wikipedia.org/wiki/R10000</a>
</li>

<li>SPARC (Wikipedia)<br />
<a href="http://en.wikipedia.org/wiki/Sparc">http://en.wikipedia.org/wiki/Sparc</a>
</li>

<li>CPU design (Wikipedia)<br />
<a href="http://en.wikipedia.org/wiki/CPU_design">http://en.wikipedia.org/wiki/CPU_design</a>
</li>

<li>Control unit (Wikipedia)<br />
<a href="http://en.wikipedia.org/wiki/Control_unit">http://en.wikipedia.org/wiki/Control_unit</a>
</li>

</ol>



<p></p><p></p>
<p><small>Autor: <a href="http://www.fit.vutbr.cz/~tisnovpa">Pavel Tišnovský</a> &nbsp; 2015</small></p>
</body>
</html>

