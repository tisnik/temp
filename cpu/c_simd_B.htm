<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
        "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html>
<head>
<title>Instrukční sady SIMD a automatické vektorizace prováděné překladačem GCC (3)</title>
<meta name="Author" content="Pavel Tisnovsky" />
<meta name="Generator" content="vim" />
<meta http-equiv="content-type" content="text/html; charset=utf-8" />
<style type="text/css">
         body {color:#000000; background:#ffffff;}
         h1  {font-family: arial, helvetica, sans-serif; color:#ffffff; background-color:#c00000; text-align:center; padding-left:1em}
         h2  {font-family: arial, helvetica, sans-serif; color:#ffffff; background-color:#0000c0; padding-left:1em; text-align:left}
         h3  {font-family: arial, helvetica, sans-serif; color:#000000; background-color:#c0c0c0; padding-left:1em; text-align:left}
         h4  {font-family: arial, helvetica, sans-serif; color:#000000; background-color:#e0e0e0; padding-left:1em; text-align:left}
         a   {font-family: arial, helvetica, sans-serif;}
         li  {font-family: arial, helvetica, sans-serif; color:#000000; text-align:justify; width:450px;}
         ol  {font-family: arial, helvetica, sans-serif; color:#000000; text-align:justify; width:450px;}
         ul  {font-family: arial, helvetica, sans-serif; color:#000000; text-align:justify; width:450px;}
         p   {font-family: arial, helvetica, sans-serif; color:#000000; text-align:justify;}
         pre {background:#e0e0e0}
</style>
</head>

<body>

<h1>Instrukční sady SIMD a automatické vektorizace prováděné překladačem GCC (3)</h1>

<h3>Pavel Tišnovský</h3>

<p></p>

<h1>Úvodník</h1>

<p>Dnes se budeme zabývat vektorizací programových smyček, v nichž se zpracovávají pole (vektory) s prvky typu byte, double atd., což vyžaduje instrukce SSE2. Důležité bude taktéž zjištění, jak je vektorizován přístup k prvkům pole s krokem (stride).</p>



<h2>Obsah</h2>

<p><a href="#k01">1. Instrukční sady SIMD a automatické vektorizace prováděné překladačem GCC (3)</a></p>
<p><a href="#k02">2. Vynulování pole s&nbsp;prvky typu <i>byte</i></a></p>
<p><a href="#k03">3. Vynulování pole s&nbsp;prvky typu <i>double</i></a></p>
<p><a href="#k04">4. Přičtení konstanty ke všem prvkům pole typu <i>byte</i></a></p>
<p><a href="#k05">5. Vysvětlení postupu výpočtu</a></p>
<p><a href="#k06">6. Přičtení konstanty ke všem prvkům pole typu <i>double</i></a></p>
<p><a href="#k07">7. Součet dvou polí stejné délky s&nbsp;prvky typu <i>byte</i></a></p>
<p><a href="#k08">8. Výsledek překladu s&nbsp;povolenou autovektorizací</a></p>
<p><a href="#k09">9. Zajištění, že předané ukazatele budou ukazovat na odlišná pole</a></p>
<p><a href="#k10">10. Výsledek překladu s&nbsp;povolenou autovektorizací</a></p>
<p><a href="#k11">11. Vyplatí se přistupovat k&nbsp;prvkům polí od nejnižšího nebo nejvyššího indexu?</a></p>
<p><a href="#k12">12. Vynulování prvků pole od posledního prvku směrem k&nbsp;prvku prvnímu</a></p>
<p><a href="#k13">13. Součet prvků dvou polí: varianta s&nbsp;obecnými ukazateli</a></p>
<p><a href="#k14">14. Součet prvků polí: varianta s&nbsp;nepřekrývajícími se ukazateli</a></p>
<p><a href="#k15">15. Přístup k&nbsp;prvkům polí s&nbsp;krokem rozdílným od jedné (<i>stride</i>)</a></p>
<p><a href="#k16">16. Překlad funkcí pro přístup k&nbsp;jedné barvové složce všech pixelů do assembleru</a></p>
<p><a href="#k17">17. Zápis jedné barvové složky do všech pixelů</a></p>
<p><a href="#k18">18. Repositář s&nbsp;demonstračními příklady</a></p>
<p><a href="#k19">19. Seznam všech předchozích částí tohoto seriálu a článků o SIMD instrukcích</a></p>
<p><a href="#k20">20. Odkazy na Internetu</a></p>



<p><a name="k01"></a></p>
<h2 id="k01">1. Instrukční sady SIMD a automatické vektorizace prováděné překladačem GCC (3)</h2>

<p>Na úvodní dvojici článků o instrukčních sadách SIMD a automatické
vektorizaci kódu prováděné překladačem GCC [<a
href="https://www.root.cz/clanky/instrukcni-sady-simd-a-automaticke-vektorizace-provadene-prekladacem-gcc/">1</a>],
[<a
href="https://www.root.cz/clanky/instrukcni-sady-simd-a-automaticke-vektorizace-provadene-prekladacem-gcc-2/">2</a>]
dnes navážeme. Zabývat se totiž budeme vektorizací programových smyček,
v&nbsp;nichž se zpracovávají pole (vektory) s&nbsp;prvky, jejichž typy jsou
odlišné od FP typu <i>single</i>. To vlastně znamená, že namísto instrukční
sady SSE bude nutné, aby překladač vygeneroval instrukce ze sady SSE2 atd.
Ovšem to je pouhé rozšíření schopností, o nichž jsme se již zmiňovali.</p>

<p>Zajímavé je, že dnešní verze překladače GCC dokážou vektorizovat i
složitější programové konstrukce, například přístup k&nbsp;polím
s&nbsp;přeskakováním prvků (<i>stride</i>). V&nbsp;praxi se totiž poměrně často
setkáme s&nbsp;tím, že se z&nbsp;pole čte (nebo do něj zapisuje) každý druhý,
třetí resp.&nbsp;obecně n-tý prvek. A i takové varianty programových smyček je
nutné optimalizovat. Zmínit se musíme ještě o jedné vlastnosti automatických
vektorizací kódu &ndash; zpracování programových smyček, ve kterých se
k&nbsp;prvkům pole přistupuje sice sekvenčně, ale nikoli od prvku prvního, ale
naopak od prvku posledního (což je obecně špatný přístup). Uvidíme zda a jakým
způsobem vektorizace dopadne v&nbsp;těchto případech.</p>



<p><a name="k02"></a></p>
<h2 id="k02">2. Vynulování pole s&nbsp;prvky typu <i>byte</i></h2>

<p>Dnešní první funkcí, kterou si necháme přeložit z&nbsp;jazyka C do
strojového kódu (resp.&nbsp;do assembleru pro lepší čitelnost), bude funkce,
která vynuluje všechny prvky z&nbsp;pole obsahujícího 32 bajtů. Překlad budeme
provádět s&nbsp;povolením instrukčních sad SSEx (nejenom SSE1) pro platformu
x86-64:</p>

<pre>
void <strong>clear</strong>(unsigned char *a) {
    #define SIZE 32
    int i;
    for (i=0; i&lt;SIZE; i++) {
        a[i] = 0;
    }
}
</pre>

<p>Překladač v&nbsp;tomto případě nebude tvořit programovou smyčku, ale pouze
vynuluje obsah registru XMM0 a zapíše tento registr na začátek pole a taktéž na
adresu posunutou o offset 16. Toto řešení je plně funkční, protože do jednoho
XMM registru lze uložit šestnáct bajtů:</p>

<pre>
<strong>clear</strong>:
        pxor    xmm0, xmm0
        movups  XMMWORD PTR [rdi], xmm0
        movups  XMMWORD PTR [rdi+16], xmm0
        ret     
</pre>

<p>Zkusme zjistit, kde je limit proto, aby překladač skutečně použil
programovou smyčku. Nulované pole zvětšíme na 64 bajtů:</p>

<pre>
<strong>clear</strong>:
        pxor    xmm0, xmm0
        movups  XMMWORD PTR [rdi], xmm0
        movups  XMMWORD PTR [rdi+16], xmm0
        movups  XMMWORD PTR [rdi+32], xmm0
        movups  XMMWORD PTR [rdi+48], xmm0
        ret     
</pre>

<p>K&nbsp;vytvoření smyčky stále nedošlo, takže pole rozšíříme na 128 bajtů
s&nbsp;tímto výsledkem:</p>

<pre>
<strong>clear</strong>:
        mov     QWORD PTR [rdi], 0
        mov     rax, rdi
        lea     rdi, [rdi+8]
        mov     QWORD PTR [rdi+112], 0
        and     rdi, -8
        sub     rax, rdi
        lea     ecx, [rax+128]
        xor     eax, eax
        shr     ecx, 3
        rep     stosq
        ret     
</pre>

<p>Nyní je situace zajímavá, protože překladač &bdquo;vzdal&ldquo; snahu o
použití instrukcí SSE a namísto toho zapisuje 16 bajtů opakující se instrukcí
<strong>STOSQ</strong> s&nbsp;konstantou nula (<strong>REP STOSQ</strong>).
Zápise je proveden na adresu uchovanou v&nbsp;registru <strong>RDI</strong> (ta
se postupně zvyšuje).</p>



<p><a name="k03"></a></p>
<h2 id="k03">3. Vynulování pole s&nbsp;prvky typu <i>double</i></h2>

<p>Ve druhém demonstračním příkladu vynulujeme pole obsahující prvky typu
<i>double</i>. Opět začneme malým polem (vektorem), které obsahuje pouze osm
prvků:</p>

<pre>
void <strong>clear</strong>(double *a) {
    #define SIZE 8
    int i;
    for (i=0; i&lt;SIZE; i++) {
        a[i] = 0.0;
    }
}
</pre>

<p>Výsledek překladu do assembleru s&nbsp;povolenou vektorizací opět využívá
rozbalené smyčky &ndash; do paměti se uloží vynulovaný vektor XMM0, a to celkem
čtyřikrát, protože každý zápis vynuluje v&nbsp;poli dva prvky:</p>

<pre>
clear:
        pxor    xmm0, xmm0
        movups  XMMWORD PTR [rdi], xmm0
        movups  XMMWORD PTR [rdi+16], xmm0
        movups  XMMWORD PTR [rdi+32], xmm0
        movups  XMMWORD PTR [rdi+48], xmm0
        ret     
</pre>

<p>Zajímavé je, že při zvětšení pole na 16 prvků typu <i>double</i> překladač
namísto SSE instrukcí opět použije pouze celočíselné registry a pro vynulování
prvků opakuje instrukci <strong>STOSQ</strong>:</p>

<pre>
clear:
        mov     QWORD PTR [rdi], 0
        mov     rax, rdi
        lea     rdi, [rdi+8]
        mov     QWORD PTR [rdi+112], 0
        and     rdi, -8 # tmp105,
        sub     rax, rdi
        lea     ecx, [rax+128]
        xor     eax, eax
        shr     ecx, 3
        rep     stosq
        ret     
</pre>



<p><a name="k04"></a></p>
<h2 id="k04">4. Přičtení konstanty ke všem prvkům pole typu <i>byte</i></h2>

<p>Ve třetím demonstračním příkladu budeme realizovat přičtení konstanty ke
všem prvkům pole typu <i>byte</i>. Opět nejdříve začneme krátkým polem
s&nbsp;pouhými šestnácti prvky:</p>

<pre>
void <strong>add_delta</strong>(unsigned char *a, unsigned char delta) {
    #define SIZE 16
    int i;
    for (i=0; i&lt;SIZE; i++) {
        a[i] += delta;
    }
}
</pre>

<p>Způsob překladu je zajímavý, protože se zde využívá kombinace instrukcí pro
proložení prvků vektorů s&nbsp;přesunem prvků. Musíme totiž dosáhnout stavu,
kdy bude vektor obsahovat 16 stejných konstant. Posléze je již možné použít
jedinou instrukci <strong>PADDB</strong> realizující vektorový součet:</p>

<pre>
<strong>add_delta</strong>:
        movd       xmm0, esi
        movdqu     xmm1, XMMWORD PTR [rdi]
        punpcklbw  xmm0, xmm0
        punpcklwd  xmm0, xmm0
        pshufd     xmm0, xmm0, 0
        paddb      xmm0, xmm1
        movups     XMMWORD PTR [rdi], xmm0
        ret     
</pre>

<p><div class="rs-tip-major">Poznámka: v&nbsp;navazující kapitole bude ukázáno,
proč se použila právě tato sekvence instrukcí a jak se výpočet provádí krok za
krokem.</div></p>

<p>Po zvětšení pole na 32 prvků (bajtů) bude výsledek vypadat takto:</p>

<pre>
<strong>add_delta</strong>:
        movd       xmm0, esi
        movdqu     xmm1, XMMWORD PTR [rdi]
        movdqu     xmm2, XMMWORD PTR [rdi+16]
        punpcklbw  xmm0, xmm0
        punpcklwd  xmm0, xmm0
        pshufd     xmm0, xmm0, 0
        paddb      xmm1, xmm0
        paddb      xmm0, xmm2
        movups     XMMWORD PTR [rdi], xmm1
        movups     XMMWORD PTR [rdi+16], xmm0
        ret     
</pre>

<p>Cílem je stále snaha o &bdquo;rozšíření&ldquo; konstanty do všech prvků
registru XMM0 tak, aby bylo možné provést vektorový součet.</p>

<p>Po zvětšení pole na 64 prvků (bajtů) již překladač donutíme
k&nbsp;vygenerování nerozbalené programové smyčky:</p>

<pre>
<strong>add_delta</strong>:
        movd       xmm1, esi
        lea        rax, [rdi+64]
        punpcklbw  xmm1, xmm1
        punpcklwd  xmm1, xmm1
        pshufd     xmm1, xmm1, 0
.L2:
        movdqu     xmm0, XMMWORD PTR [rdi]
        add        rdi, 16
        paddb      xmm0, xmm1
        movups     XMMWORD PTR [rdi-16], xmm0
        cmp        rax, rdi
        jne        .L2
        ret     
</pre>



<p><a name="k05"></a></p>
<h2 id="k05">5. Vysvětlení postupu výpočtu</h2>

<p>Předchozí programy přeložené do assembleru obsahovaly zajímavou sekvenci
instrukcí, která vede k&nbsp;tomu, že se původně jedna jednobajtová konstanta
rozkopíruje celkem 16&times; do celého vektoru, což ve výsledku umožní provést
vektorový součet instrukcí <strong>PADDB</strong>. Jedná se o zajímavou
techniku, kterou si vysvětlíme po jednotlivých instrukcích.</p>

<p>Nejprve do registru XMM1 načteme vektor s&nbsp;hodnotami od 0 do 15 (což se
dobře vizualizuje):</p>

<pre>
0F 0E 0D 0C 0B 0A 09 08 07 06 05 04 03 02 01 00
</pre>

<p>Následně dvojicí instrukcí zajistíme zápis konstanty do nejnižšího bitu
registru XMM0:</p>

<pre>
        mov esi, 1                   <i>; konstanta, kterou budeme pricitat</i>
        movd xmm0, esi               <i>; nacteni konstanty do druheho vektoru</i>
</pre>

<p>Výsledek bude vypadat takto:</p>

<pre>
00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 01
</pre>

<p>V&nbsp;dalších krocích musíme onen jediný bajt na konci registru XMM0
rozkopírovat do všech ostatních patnácti bajtů. Instrukce
<strong>PUNPCKLBW</strong> provede první krok &ndash; zkopírování do druhého
prvku (ve skutečnosti se překopírují všechny sudé prvky, ovšem ty jsou nulové a
nezajímaí nás):</p>

<pre>
00 00 00 00 00 00 00 00 00 00 00 00 00 00 01 01
</pre>

<p>Nyní tedy registr XMM0 obsahuje ve spodních dvou bajtech totožnou konstantu.
Instrukcí <strong>PUNPCKLWD</strong> (ta pracuje po slovech, nikoli po bajtech)
provedeme kopii nejnižších dvou prvků do prvků s&nbsp;indexy 2 a 3 (indexuje se
od nuly). Opět platí, že podobná operace proběhne i pro vyšší prvky, ale ty nás
nezajímají:</p>

<pre>
00 00 00 00 00 00 00 00 00 00 00 00 01 01 01 01
</pre>

<p>Již se blížíme ke konci, protože nyní spodní dvojslovo obsahuje konstantu,
kterou musíme rozkopírovat do dalších třech dvojslov. A to lze provést jedinou
instrukcí <strong>PSHUFD</strong>. Ta je sice určena pro hodnoty typu
<i>float/single</i>, ovšem jedná se o pouhé kopie bez dalších FP manipulací.
Výsledkem bude vektor:</p>

<pre>
01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01
</pre>

<p>Nyní nám již zbývá provést instrukci <strong>PADDB</strong>, která paralelně
sečte všech šestnáct dvojic prvků a výsledkem bude vektor:</p>

<pre>
10 0F 0E 0D 0C 0B 0A 09 08 07 06 05 04 03 02 01
</pre>

<p>Úplný program (přeložitelný pro Linux), který provede součet a zobrazí
přitom všechny mezivýsledky, vypadá takto:</p>

<pre>
[bits 32]
&nbsp; 
%include "linux_macros.asm"
&nbsp;
<i>;-----------------------------------------------------------------------------</i>
section .data
&nbsp;
<strong>hex_message</strong>:
         times 8 db '?'
         db ' '
         hex_message_length equ $ - hex_message
&nbsp;
align 16
<strong>sse_val_1</strong> db 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15
&nbsp;
<i>;-----------------------------------------------------------------------------</i>
section .bss
sse_tmp resb 16
&nbsp;
&nbsp;
<i>;-----------------------------------------------------------------------------</i>
section .text
        global _start                <i>; tento symbol ma byt dostupny i linkeru</i>
&nbsp;
<strong>_start</strong>:
        mov ebx, sse_val_1
        movdqu xmm1, [ebx]           <i>; nacteni puvodniho vektoru do registru XMM0</i>
        print_sse_reg_as_hex xmm1    <i>; tisk hodnoty registru XMM0</i>
&nbsp;
        mov esi, 1                   <i>; konstanta, kterou budeme pricitat</i>
        movd xmm0, esi               <i>; nacteni konstanty do druheho vektoru</i>
        print_sse_reg_as_hex xmm0    <i>; tisk hodnoty registru XMM0</i>
&nbsp;
        punpcklbw xmm0, xmm0         <i>; prolozeni hodnot, zdrojem je jediny registr</i>
        print_sse_reg_as_hex xmm0    <i>; tisk hodnoty registru XMM0</i>
&nbsp;
        punpcklwd xmm0, xmm0         <i>; prolozeni hodnot, zdrojem je jediny registr</i>
        print_sse_reg_as_hex xmm0    <i>; tisk hodnoty registru XMM0</i>
&nbsp;
        pshufd xmm0, xmm0, 0         <i>; rozkopirovani spodnich osmi bajtu do celeho vektoru</i>
        print_sse_reg_as_hex xmm0    <i>; tisk hodnoty registru XMM0</i>
&nbsp;
        paddb xmm0, xmm1             <i>; vektorovy soucet</i>
        print_sse_reg_as_hex xmm0    <i>; tisk hodnoty registru XMM0</i>
&nbsp;
        exit                         <i>; ukonceni procesu</i>
&nbsp;
&nbsp;
%include "hex2string.asm"
</pre>



<p><a name="k06"></a></p>
<h2 id="k06">6. Přičtení konstanty ke všem prvkům pole typu <i>double</i></h2>

<p>Pro úplnost si ještě ukažme, jakým způsobem se přeloží funkce, která bude
přičítat konstantu ke všem prvkům pole typu <i>double</i>. Kvůli použití tohoto
datového typu opět překladač &bdquo;donutíme&ldquo; k&nbsp;tomu, aby používal
instrukce z&nbsp;instrukční sady SSE2 a nikoli z&nbsp;původní sady SSE. Nejprve
provedeme operaci přičtení konstanty ke všem prvkům pole o délce 4 prvky:</p>

<pre>
void <strong>add_delta</strong>(double *a, double delta) {
    #define SIZE 4
    int i;
    for (i=0; i&lt;SIZE; i++) {
        a[i] += delta;
    }
}
</pre>

<p>Při pohledu na přeložený kód je zřejmé, že se nejdříve instrukcí
<strong>UNPCKLPD</strong> (oba operandy jsou stejné) provede kopie spodního
prvku dvouprvkového vektoru do horního prvku. Po provedení této instrukce tedy
budou v&nbsp;registru XMM0 uloženy dvě stejné hodnoty typu <i>double</i>.
V&nbsp;dalších krocích je již možné provést vektorový součet instrukcí
<strong>ADDPD</strong> &ndash; každá instrukce sečte vždy dvojice prvků
z&nbsp;prvního a druhého pole:</p>

<pre>
<strong>add_delta</strong>:
        movupd     xmm1, XMMWORD PTR [rdi]
        movupd     xmm2, XMMWORD PTR [rdi+16]
        unpcklpd   xmm0, xmm0
        addpd      xmm1, xmm0
        addpd      xmm0, xmm2
        movups     XMMWORD PTR [rdi], xmm1
        movups     XMMWORD PTR [rdi+16], xmm0
        ret     
</pre>

<p>Zkusme si nyní zvětšit obě pole na délku osmi prvků, abychom zjistili, od
jaké meze se překladač uchýlí k&nbsp;vygenerování programové smyčky:</p>

<pre>
void <strong>add_delta</strong>(double *a, double delta) {
    #define SIZE 8
    int i;
    for (i=0; i&lt;SIZE; i++) {
        a[i] += delta;
    }
}
</pre>

<p>Nyní je z&nbsp;výsledného kódu patrné, že se skutečně vygenerovala
programová smyčka, která v&nbsp;každé iteraci sečte dvojici hodnot typu
<i>double</i>. Konstanta (resp.&nbsp;dvojice konstant) pro přičtení je
pochopitelně vypočtena ještě před vstupem do smyčky:</p>

<pre>
<strong>add_delta</strong>:
        unpcklpd   xmm0, xmm0
        lea        rax, [rdi+64]
.L2:
        movupd     xmm1, XMMWORD PTR [rdi]
        add        rdi, 16
        addpd      xmm1, xmm0
        movups     XMMWORD PTR [rdi-16], xmm1
        cmp        rax, rdi
        jne        .L2
        ret     
</pre>



<p><a name="k07"></a></p>
<h2 id="k07">7. Součet dvou polí stejné délky s&nbsp;prvky typu <i>byte</i></h2>

<p>V&nbsp;dalším příkladu se pokusíme o provedení součtu prvků dvou polí stejné
délky. Pole (resp.&nbsp;přesněji řečeno jejich prvky) budou typu <i>byte</i>,
takže překladač pravděpodobně použije rozšířené operace MMX &ndash; tedy
operace, které již existovaly v&nbsp;instrukční sadě MMX, ale díky SSE/SSE2 je
je možné použít i pro vektory obsahující šestnáct hodnot a nikoli pouze osm
hodnot.</p>

<p>Součet dvou polí, z&nbsp;nichž každé obsahuje šestnáct prvků typu
<i>byte</i>:</p>

<pre>
void <strong>add_arrays</strong>(unsigned char *a, unsigned char *b) {
    #define SIZE 16
    int i;
    for (i=0; i&lt;SIZE; i++) {
        a[i] += b[i];
    }
}
</pre>

<p>Součet dvou polí, z&nbsp;nichž každé obsahuje 32 prvků typu <i>byte</i>:</p>

<pre>
void add_arrays(unsigned char *a, unsigned char *b) {
    #define SIZE 32
    int i;
    for (i=0; i&lt;SIZE; i++) {
        a[i] += b[i];
    }
}
</pre>

<p><div class="rs-tip-major">Poznámka: povšimněte si, že se jedná o jednoduché
programové smyčky, ve kterých se žádným způsobem nepokoušíme o nějaké
optimalizace.</div></p>



<p><a name="k08"></a></p>
<h2 id="k08">8. Výsledek překladu s&nbsp;povolenou autovektorizací</h2>

<p>Vzhledem k&nbsp;tomu, že součet dvou vektorů se šestnácti prvky typu
<i>byte</i> je možné realizovat jedinou instrukcí <strong>PADDB</strong>, by se
mohlo zdát, že se předchozí funkce přeloží do několika instrukcí: načtení
vektorů, vektorový součet, uložení výsledku. Ve skutečnosti to není tak
jednoduché, protože překladač musí počítat s&nbsp;tím, že se obě pole mohou
překrývat. A právě tato větev je realizována ve smyčce začínající lokálním
návěštím (<i>label</i>) <strong>.L4</strong>:</p>

<pre>
<strong>add_arrays</strong>:
        lea     rdx, [rsi+1]
        mov     rax, rdi
        sub     rax, rdx
        cmp     rax, 14
        jbe     .L4
        movdqu  xmm0, XMMWORD PTR [rsi]
        movdqu  xmm1, XMMWORD PTR [rdi]
        paddb   xmm0, xmm1
        movups  XMMWORD PTR [rdi], xmm0
        ret     
&nbsp;
.L4:
        xor     eax, eax
.L2:
        movzx   edx, BYTE PTR [rsi+rax]
        add     BYTE PTR [rdi+rax], dl
        add     rax, 1
        cmp     rax, 16
        jne     .L2
        ret     
</pre>

<p>Podobně je tomu i u funkce, která má sečíst 32prvková pole s&nbsp;prvky typu
<i>byte</i>:</p>

<pre>
<strong>add_arrays</strong>:
        lea     rdx, [rsi+1]
        mov     rax, rdi
        sub     rax, rdx
        cmp     rax, 14
        jbe     .L4
        movdqu  xmm1, XMMWORD PTR [rsi]
        movdqu  xmm0, XMMWORD PTR [rdi]
        movdqu  xmm2, XMMWORD PTR [rdi+16]
        paddb   xmm0, xmm1
        movups  XMMWORD PTR [rdi], xmm0
        movdqu  xmm0, XMMWORD PTR [rsi+16]
        paddb   xmm0, xmm2
        movups  XMMWORD PTR [rdi+16], xmm0
        ret     
.L4:
        xor     eax, eax
.L2:
        movzx   edx, BYTE PTR [rsi+rax]
        add     BYTE PTR [rdi+rax], dl
        add     rax, 1
        cmp     rax, 32
        jne     .L2
        ret     
</pre>

<p><div class="rs-tip-major">Poznámka: proč tomu tak je zjistíte snadno, pokud
tyto funkce zavoláte tak, že jim předáte ukazatel na nějaké pole a ukazatel o
jedničku vyšší.</div></p>



<p><a name="k09"></a></p>
<h2 id="k09">9. Zajištění, že předané ukazatele budou ukazovat na odlišná pole</h2>

<p>Jakým způsobem lze eliminovat přidané programové smyčky, již víme &ndash;
musíme překladači jazyka C oznámit, že se pole nebudou překrývat. To se provede
klíčovým slovem <strong>restrict</strong>, které je sice poněkud neznámé, ale o
to důležitější:</p>

<pre>
void <strong>add_arrays</strong>(unsigned char *<u>restrict</u> a, unsigned char *<u>restrict</u> b) {
    #define SIZE 16
    int i;
    for (i=0; i&lt;SIZE; i++) {
        a[i] += b[i];
    }
}
</pre>

<pre>
void <strong>add_arrays</strong>(unsigned char *<u>restrict</u> a, unsigned char *<u>restrict</u> b) {
    #define SIZE 32
    int i;
    for (i=0; i&lt;SIZE; i++) {
        a[i] += b[i];
    }
}
</pre>



<p><a name="k10"></a></p>
<h2 id="k10">10. Výsledek překladu s&nbsp;povolenou autovektorizací</h2>

<p>Opět se podívejme na to, jak dopadne překlad s&nbsp;autovektorizací obou
funkcí, jejichž zdrojové kódy byly ukázány <a href="#k09">v&nbsp;předchozí
kapitole</a>. Překladač má nyní jistotu, že oba ukazatele předávané do funkcí
budou odlišné a bude tedy moci ve vygenerovaném kódu odstranit podmínky a větev
určenou právě pro tyto případy. I z&nbsp;tohoto důvodu se součet šestnácti
prvků typu byte provede jedinou instrukcí <strong>PADDB</strong>:</p>

<pre>
<strong>add_arrays</strong>:
        movdqu  xmm1, XMMWORD PTR [rdi]
        movdqu  xmm0, XMMWORD PTR [rsi]
        paddb   xmm0, xmm1
        movups  XMMWORD PTR [rdi], xmm0
        ret     
</pre>

<p>A varianta sčítající 32 prvků typu byte je stále realizována bez (obecně
pomalé) programové smyčky, protože výpočet byl rozbalen. Pokud pomineme přesuny
operandů mezi pamětí a registry, bude celý součet realizován dvojicí funkcí
<strong>PADDB</strong>:</p>

<pre>
<strong>add_arrays</strong>:
        movdqu  xmm0, XMMWORD PTR [rdi]
        movdqu  xmm1, XMMWORD PTR [rsi]
        movdqu  xmm2, XMMWORD PTR [rdi+16]
        paddb   xmm0, xmm1
        movups  XMMWORD PTR [rdi], xmm0
        movdqu  xmm0, XMMWORD PTR [rsi+16]
        paddb   xmm0, xmm2
        movups  XMMWORD PTR [rdi+16], xmm0
        ret     
</pre>

<p><div class="rs-tip-major">Poznámka: to ovšem neznamená, že by předchozí kód
vytvořený překladačem byl ideální a že ho nelze dále urychlit. Překladač totiž
neví, jak jsou pole zarovnána a proto musí vygenerovat instrukce
<strong>MOVDQU</strong> a <strong>MOVUPS</strong>. Pokud by ovšem věděl, že
pole jsou zarovnána na násobky šestnácti bajtů, bude moci využít instrukce
<strong>MOVDQA</strong> a <strong>MOVAPS</strong>, které mohou být mnohem
rychlejší (jediný přenos po sběrnici).</div></p>



<p><a name="k11"></a></p>
<h2 id="k11">11. Vyplatí se přistupovat k&nbsp;prvkům polí od nejnižšího nebo nejvyššího indexu?</h2>

<p>Většina programových smyček, které ve zdrojových kódech popisují nějaký
pravidelný průchod polem, zpracovává pole od prvního prvku (s&nbsp;indexem 0)
až k&nbsp;prvku poslednímu. Ovšem někdy se můžeme setkat i s&nbsp;opačným
průchodem polem. Ten je realizován buď z&nbsp;toho důvodu, že to dobře odpovídá
řešenému problému (nalezení posledního prvku odpovídajícího nějaké podmínce
atd.) nebo si vývojář zvolil druhý typ smyčky na základě předpokladu, že je
vlastně jedno, zda se polem prochází směrem dopředu nebo zezadu. V&nbsp;praxi
se ovšem oba přístupy liší a mají vliv na výkon celé aplikace. V&nbsp;první
řadě se liší způsob využití vyrovnávacích pamětí a taktéž (před)načtení
jednotlivých stránek paměti v&nbsp;případě, že se využívá stránkování
(<i>paging</i>). To je sice zajímavá problematika, ale vybočuje z&nbsp;tématu
dnešního článku.</p>

<p>Nás dnes bude primárně zajímat to, zda a jak dokáže autovektorizační
technika přeložit a optimalizovat zdrojové kódy, v&nbsp;nichž se prochází polem
opačným směrem.</p>



<p><a name="k12"></a></p>
<h2 id="k12">12. Vynulování prvků pole od posledního prvku směrem k&nbsp;prvku prvnímu</h2>

<p>Začneme jednoduchým příkladem &ndash; vynulováním prvků pole v&nbsp;opačném
pořadí:</p>

<pre>
void <strong>clear</strong>(float *a) {
    #define SIZE 8
    int i;
    for (i=SIZE-1; i&gt;=0; i--) {
        a[i] = 0.0;
    }
}
</pre>

<p>Překlad do assembleru dopadne následovně:</p>

<pre>
<strong>clear</strong>:
        pxor    xmm0, xmm0
        movups  XMMWORD PTR [rdi], xmm0
        movups  XMMWORD PTR [rdi+16], xmm0
        ret     
</pre>

<p>V&nbsp;tomto případě je tedy zcela jedno, jak je smyčka napsána; navíc se
v&nbsp;assembleru prvky nulují v&nbsp;pořadí od prvního směrem
k&nbsp;poslednímu prvku.</p>



<p><a name="k13"></a></p>
<h2 id="k13">13. Součet prvků dvou polí: varianta s&nbsp;obecnými ukazateli</h2>

<p>Další programový kód provádí součet odpovídajících si prvků dvou polí. Tato
varianta prozatím používá obecné ukazatele, což překladači neumožní provést
všechny možné optimalizace:</p>

<pre>
void <strong>add_delta</strong>(float *a, float *b) {
    #define SIZE 16
    int i;
    for (i=SIZE-1; i&gt;=0; i--) {
        a[i] += b[i];
    }
}
</pre>

<p>Výsledek:</p>

<pre>
<strong>add_delta</strong>:
        mov     rax, rdi
        sub     rax, rsi
        add     rax, 12
        cmp     rax, 8
        jbe     .L5
        mov     eax, 48
.L3:
        movups  xmm0, XMMWORD PTR [rdi+rax]
        movups  xmm1, XMMWORD PTR [rsi+rax]
        shufps  xmm0, xmm0, 27
        shufps  xmm1, xmm1, 27
        addps   xmm0, xmm1
        shufps  xmm0, xmm0, 27
        movups  XMMWORD PTR [rdi+rax], xmm0
        sub     rax, 16
        cmp     rax, -16
        jne     .L3
        ret     
.L5:
        mov     eax, 60
.L2:
        movss   xmm0, DWORD PTR [rdi+rax]
        addss   xmm0, DWORD PTR [rsi+rax]
        movss   DWORD PTR [rdi+rax], xmm0
        sub     rax, 4
        cmp     rax, -4
        jne     .L2
        ret     
</pre>

<p>Povšimněte si, že jsou vlastně realizovány dvě větve. První z&nbsp;nich je
vektorizovaná a prochází polem opačným směrem:</p>

<pre>
.L3:
        movups  xmm0, XMMWORD PTR [rdi+rax]
        movups  xmm1, XMMWORD PTR [rsi+rax]
        shufps  xmm0, xmm0, 27
        shufps  xmm1, xmm1, 27
        addps   xmm0, xmm1
        shufps  xmm0, xmm0, 27
        movups  XMMWORD PTR [rdi+rax], xmm0
        sub     rax, 16
        cmp     rax, -16
        jne     .L3
</pre>

<p>Druhá větev vektorizovaná není a realizuje se v&nbsp;ní výpočet pro překryv
polí. Ovšem i zde se polem prochází opačným směrem:</p>

<pre>
.L2:
        movss   xmm0, DWORD PTR [rdi+rax]
        addss   xmm0, DWORD PTR [rsi+rax]
        movss   DWORD PTR [rdi+rax], xmm0
        sub     rax, 4
        cmp     rax, -4
        jne     .L2
        ret     
</pre>

<p><div class="rs-tip-major">Poznámka: při porovnání s&nbsp;původní verzí
smyčky vlastně nedošlo k&nbsp;větším změnám a pokud nebudeme uvažovat horší
využití cache či stránek, budou i výsledné doby běhu podobné.</div></p>



<p><a name="k14"></a></p>
<h2 id="k14">14. Součet prvků polí: varianta s&nbsp;nepřekrývajícími se ukazateli</h2>

<p>Zajímavější bude zjistit způsob překladu funkce, v&nbsp;níž je pomocí
klíčového slova <strong>restrict</strong> umožněno překladači provádět další
optimalizace &ndash; ignorovat možnost překryvu:</p>

<pre>
void <strong>add_arrays</strong>(float *<u>restrict</u> a, float *<u>restrict</u> b) {
    #define SIZE 16
    int i;
    for (i=SIZE-1; i&gt;=0; i--) {
        a[i] += b[i];
    }
}
</pre>

<p>Z&nbsp;přeloženého kódu je patrné, že i nyní se polem skutečně prochází
směrem od posledního prvku směrem k&nbsp;prvku prvnímu:</p>

<pre>
<strong>add_arrays</strong>:
        mov     eax, 48
.L2:
        movups  xmm0, XMMWORD PTR [rdi+rax]
        movups  xmm1, XMMWORD PTR [rsi+rax]
        shufps  xmm0, xmm0, 27
        shufps  xmm1, xmm1, 27
        addps   xmm0, xmm1
        shufps  xmm0, xmm0, 27
        movups  XMMWORD PTR [rdi+rax], xmm0
        sub     rax, 16
        cmp     rax, -16
        jne     .L2
        ret     
</pre>

<p><div class="rs-tip-major">Poznámka: zajímavá je už samotná existence
programové smyčky v&nbsp;assembleru. Varianta procházející polem od prvního
prvku totiž byla přeložena odlišně &ndash; bez přeskládání prvků pomocí
<strong>SHUFPS</strong>. Předchozí výsledek tedy bude pomalejší:</div></p>

<pre>
<strong>add_arrays</strong>:
        xor     eax, eax
.L2:
        movups  xmm0, XMMWORD PTR [rdi+rax]
        movups  xmm1, XMMWORD PTR [rsi+rax]
        addps   xmm0, xmm1
        movups  XMMWORD PTR [rdi+rax], xmm0
        add     rax, 16
        cmp     rax, 64
        jne     .L2
        ret     
</pre>



<p><a name="k15"></a></p>
<h2 id="k15">15. Přístup k&nbsp;prvkům polí s&nbsp;krokem rozdílným od jedné (<i>stride</i>)</h2>

<p>Poměrně často se v&nbsp;reálných aplikacích sice zpracovávají prvky nějakého
pole, ovšem jedná se o každý <i>n</i>-tý prvek, přičemž hodnota <i>n</i> (krok)
je v&nbsp;tomto případě větší než 1. Typickým příkladem takového problému je
práce s&nbsp;rastrovými obrázky, v&nbsp;nichž je každý pixel uložen formou tří
barvových složek RGB a každá tato složka má jeden bajt. Dalším příkladem je
zpracování audio signálu se šestnáctibitovými vzorky uloženými tak, že každý
lichý vzorek patří pravému kanálu a každý lichý vzorek kanálu levému (nebo
naopak &ndash; na principu se však nic nemění). A našly by se i další podobné
příklady.</p>

<p>Překladač by tedy měl nějakým způsobem umět optimalizovat i tyto algoritmy.
Mimochodem &ndash; krok <i>n</i>, který jsme zmiňovali v&nbsp;předchozím
odstavci (byl nastaven na hodnotu 4 pro bitmapy a na hodnotu 2 pro audio
signál) se nazývá <i>stride</i> a i příslušná autovektorizace se jmenuje
<i>stride access autovectorization</i>.</p>

<p>Povídejme se na jednoduchý příklad. Je v&nbsp;něm definována trojice funkcí,
z&nbsp;nichž každá získá z&nbsp;pole o velikosti SIZE obsahujícího barvy pixelů
ve formátu RGB vždy jen jedinou barvovou složku. Celý kód jsem pro jednoduchost
rozepsal do tří funkcí, i když by bylo možné napsat jen jedinou funkci, která
by navíc akceptovala offset 0, 1 nebo 2 a namísto funkcí by se použila makra
(mimochodem &ndash; SIZE je nedělitelné třemi &ndash; sami si vyzkoušejte
variantu se SIZE = 15; bude se výsledek lišit?). Ovšem pro větší čitelnost
výsledného assembleru použijeme definice tří samostatných funkcí, které se od
sebe odlišují pouze konstantou použitou při výpočtu indexů do pole
<strong>rgb</strong>:</p>

<pre>
void <strong>get_red_component</strong>(float *restrict red, float *restrict rgb) {
    #define SIZE 16
    int i;
    for (i=0; i&lt;SIZE/3; i++) {
        red[i] = rgb[3*i];
    }
}
&nbsp;
void <strong>get_green_component</strong>(float *restrict green, float *restrict rgb) {
    #define SIZE 16
    int i;
    for (i=0; i&lt;SIZE/3; i++) {
        green[i] = rgb[3*i+1];
    }
}
&nbsp;
void <strong>get_blue_component</strong>(float *restrict blue, float *restrict rgb) {
    #define SIZE 16
    int i;
    for (i=0; i&lt;SIZE/3; i++) {
        blue[i] = rgb[3*i+2];
    }
}
</pre>

<p><div class="rs-tip-major">Poznámka: povšimněte si, že u parametrů všech
funkcí je použito klíčové slovo <strong>restrict</strong>, kterým překladači
naznačujeme, že se nebude jednat o stejná pole nebo o překrývající se pole.
Překladač tedy bude moci kód optimalizovat &ndash; vynechat specifickou větev
pro překrývající se pole.</div></p>



<p><a name="k16"></a></p>
<h2 id="k16">16. Překlad funkcí pro přístup k&nbsp;jedné barvové složce všech pixelů do assembleru</h2>

<p>Nyní se podívejme na způsob překladu výše vypsaných funkcí, které získají
vždy jednu barvovou složku pro všechny pixely v&nbsp;rastrovém obrázku (který
je reprezentován 1D či 2D polem &ndash; to již nemusíme řešit). Díky tomu, že
jsme barvové složky reprezentovali hodnotami typu <i>float</i> (což má svůj
význam), bylo možné, aby překladač použit instrukci <strong>SHUFPS</strong>
z&nbsp;instrukční sady SSE. Překladač tak pro naše krátké vstupní pole obešel
nutnost vygenerovat programovou smyčku, pouze musel zajistit získání každého
třetího prvku z&nbsp;pole instrukcí <strong>SHUFPS</strong>, což je, <a
href="https://www.root.cz/clanky/pokrocilejsi-sse-operace-preskupeni-promichani-a-rozbalovani-prvku-vektoru/#k05">jak
již víme</a>, pravděpodobně nejsložitější a současně i velmi užitečná instrukce
SSE:</p>

<pre>
<strong>get_red_component</strong>:
        movups  xmm0, XMMWORD PTR [rsi]
        movups  xmm1, XMMWORD PTR [rsi+16]
        shufps  xmm1, xmm0, 10
        shufps  xmm0, xmm1, 140
        movq    xmm1, QWORD PTR [rsi+32]
        shufps  xmm1, xmm0, 165
        shufps  xmm0, xmm1, 36
        movups  XMMWORD PTR [rdi], xmm0
        movss   xmm0, DWORD PTR [rsi+48]
        movss   DWORD PTR [rdi+16], xmm0
        ret     
</pre>

<p>U funkce pro získání zelených barvových složek se jen posunul offset o
hodnotu 4 (u všech adres). 4 bajty odpovídají šířce hodnoty typu <i>float</i>
v&nbsp;bajtech:</p>

<pre>
<strong>get_green_component</strong>:
        movups  xmm0, XMMWORD PTR [rsi+4]
        movups  xmm1, XMMWORD PTR [rsi+20]
        shufps  xmm1, xmm0, 10
        shufps  xmm0, xmm1, 140
        movq    xmm1, QWORD PTR [rsi+36]
        shufps  xmm1, xmm0, 165
        shufps  xmm0, xmm1, 36
        movups  XMMWORD PTR [rdi], xmm0
        movss   xmm0, DWORD PTR [rsi+52]
        movss   DWORD PTR [rdi+16], xmm0
        ret     
</pre>

<p>Totéž platí u funkce pro získání modrých barvových složek, pouze s&nbsp;tím
rozdílem, že se pracuje s&nbsp;offset 8 (tedy dvě hodnoty typu
<i>float</i>):</p>

<pre>
<strong>get_blue_component</strong>:
        movups  xmm0, XMMWORD PTR [rsi+8]
        movups  xmm1, XMMWORD PTR [rsi+24]
        shufps  xmm1, xmm0, 10
        shufps  xmm0, xmm1, 140
        movq    xmm1, QWORD PTR [rsi+40]
        shufps  xmm1, xmm0, 165
        shufps  xmm0, xmm1, 36
        movups  XMMWORD PTR [rdi], xmm0
        movss   xmm0, DWORD PTR [rsi+56]
        movss   DWORD PTR [rdi+16], xmm0
        ret     
</pre>

<p><div class="rs-tip-major">Poznámka: příště si ukážeme skutečnou vektorizaci
podobného kódu u delších polí/vektorů.</div></p>



<p><a name="k17"></a></p>
<h2 id="k17">17. Zápis jedné barvové složky do všech pixelů</h2>

<p>Nyní zkusme namísto funkcí určených pro <i>čtení</i> jedné zvolené barvové
složky všech pixelů naprogramovat funkce, které provádí <i>zápis</i>
(modifikaci) jedné vybrané barvové složky u všech pixelů. Vstupem je tedy
například sekvence hodnot červené barvové složky, která se má propsat do
výsledného rastrového obrázku. Opět jsem pro větší čitelnost všechny tři funkce
napsal samostatně:</p>

<pre>
void <strong>set_red_component</strong>(float *restrict red, float *restrict rgb) {
    #define SIZE 16
    int i;
    for (i=0; i&lt;SIZE/3; i++) {
        rgb[3*i] = red[i];
    }
}
&nbsp;
void <strong>set_green_component</strong>(float *restrict green, float *restrict rgb) {
    #define SIZE 16
    int i;
    for (i=0; i&lt;SIZE/3; i++) {
        rgb[3*i+1] = green[i];
    }
}
&nbsp;
void <strong>set_blue_component</strong>(float *restrict blue, float *restrict rgb) {
    #define SIZE 16
    int i;
    for (i=0; i&lt;SIZE/3; i++) {
        rgb[3*i+2] = blue[i];
    }
}
</pre>

<p>Nyní je realizace zápisu řešena &bdquo;nevektorizovaně&ldquo;, tedy
triviálním zápisem skalárních hodnot do pole s&nbsp;rastrovým obrázkem:</p>

<pre>
<strong>set_red_component</strong>:
        movss   xmm0, DWORD PTR [rdi+12]
        movss   xmm1, DWORD PTR [rdi+8]
        movss   xmm2, DWORD PTR [rdi+4]
        movss   xmm3, DWORD PTR [rdi]
        movss   DWORD PTR [rsi+36], xmm0
        movss   xmm0, DWORD PTR [rdi+16]
        movss   DWORD PTR [rsi], xmm3
        movss   DWORD PTR [rsi+12], xmm2
        movss   DWORD PTR [rsi+24], xmm1
        movss   DWORD PTR [rsi+48], xmm0
        ret     
</pre>

<p>Posun offsetů u zápisu u další barvové složky u poslední trojice instrukcí
<strong>MOVSS</strong>:</p>

<pre>
<strong>set_green_component</strong>:
        movss   xmm0, DWORD PTR [rdi+12]
        movss   xmm1, DWORD PTR [rdi+8]
        movss   xmm2, DWORD PTR [rdi+4]
        movss   xmm3, DWORD PTR [rdi]
        movss   DWORD PTR [rsi+40], xmm0
        movss   xmm0, DWORD PTR [rdi+16]
        movss   DWORD PTR [rsi+4], xmm3
        movss   DWORD PTR [rsi+16], xmm2
        movss   DWORD PTR [rsi+28], xmm1
        movss   DWORD PTR [rsi+52], xmm0
        ret     
</pre>

<p>Dtto pro třetí barvovou složku:</p>

<pre>
<strong>set_blue_component</strong>:
        movss   xmm0, DWORD PTR [rdi+12]
        movss   xmm1, DWORD PTR [rdi+8]
        movss   xmm2, DWORD PTR [rdi+4]
        movss   xmm3, DWORD PTR [rdi]
        movss   DWORD PTR [rsi+44], xmm0
        movss   xmm0, DWORD PTR [rdi+16]
        movss   DWORD PTR [rsi+8], xmm3
        movss   DWORD PTR [rsi+20], xmm2
        movss   DWORD PTR [rsi+32], xmm1
        movss   DWORD PTR [rsi+56], xmm0
        ret     
</pre>



<p><a name="k18"></a></p>
<h2 id="k18">18. Repositář s&nbsp;demonstračními příklady</h2>

<p>Demonstrační příklady naprogramované v&nbsp;jazyku, které jsou určené pro
překlad s&nbsp;využitím assembleru <strong>gcc</strong>, byly uloženy do Git
repositáře, který je dostupný na adrese <a
href="https://github.com/tisnik/8bit-fame">https://github.com/tisnik/8bit-fame</a>.
Kromě zdrojových kódů příkladů jsou do repositáře přidány i výsledky překladu
do assembleru v&nbsp;syntaxi kompatibilní s&nbsp;Intelem. Jednotlivé
demonstrační příklady si můžete v&nbsp;případě potřeby stáhnout i jednotlivě
bez nutnosti klonovat celý (dnes již poměrně rozsáhlý) repositář:</p>

<table>
<tr><th> #</th><th>Příklad</th><th>Stručný popis</th><th>Adresa</th></tr>
<tr><td> 1</td><td>array_clear_size_8.c</td><td>smazání obsahu pole s&nbsp;osmi prvky typu <strong>float</strong></td><td><a href="https://github.com/tisnik/8bit-fame/blob/master/gcc-simd/array_clear_size_8.c">https://github.com/tisnik/8bit-fame/blob/master/gcc-simd/array_clear_size_8.c</a></td></tr>
<tr><td> 2</td><td>array_clear_size_8_non_vect.asm</td><td>výsledek překladu do assembleru se zákazem vektorizace</td><td><a href="https://github.com/tisnik/8bit-fame/blob/master/gcc-simd/array_clear_size_8_non_vect.asm">https://github.com/tisnik/8bit-fame/blob/master/gcc-simd/array_clear_size_8_non_vect.asm</a></td></tr>
<tr><td> 3</td><td>array_clear_size_8_no_sse.asm</td><td>výsledek překladu do assembleru se zákazem SSE instrukcí</td><td><a href="https://github.com/tisnik/8bit-fame/blob/master/gcc-simd/array_clear_size_8_no_sse.asm">https://github.com/tisnik/8bit-fame/blob/master/gcc-simd/array_clear_size_8_no_sse.asm</a></td></tr>
<tr><td> 4</td><td>array_clear_size_8_vect.asm</td><td>výsledek překladu do assembleru s&nbsp;povolením vektorizace</td><td><a href="https://github.com/tisnik/8bit-fame/blob/master/gcc-simd/array_clear_size_8_vect.asm">https://github.com/tisnik/8bit-fame/blob/master/gcc-simd/array_clear_size_8_vect.asm</a></td></tr>
<tr><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td></tr>
<tr><td> 5</td><td>array_clear_size_16.c</td><td>smazání obsahu pole se šestnácti prvky typu <strong>float</strong></td><td><a href="https://github.com/tisnik/8bit-fame/blob/master/gcc-simd/array_clear_size_16.c">https://github.com/tisnik/8bit-fame/blob/master/gcc-simd/array_clear_size_16.c</a></td></tr>
<tr><td> 6</td><td>array_clear_size_16_non_vect.asm</td><td>výsledek překladu do assembleru se zákazem vektorizace</td><td><a href="https://github.com/tisnik/8bit-fame/blob/master/gcc-simd/array_clear_size_16_non_vect.asm">https://github.com/tisnik/8bit-fame/blob/master/gcc-simd/array_clear_size_16_non_vect.asm</a></td></tr>
<tr><td> 7</td><td>array_clear_size_16_vect.asm</td><td>výsledek překladu do assembleru s&nbsp;povolením vektorizace</td><td><a href="https://github.com/tisnik/8bit-fame/blob/master/gcc-simd/array_clear_size_16_vect.asm">https://github.com/tisnik/8bit-fame/blob/master/gcc-simd/array_clear_size_16_vect.asm</a></td></tr>
<tr><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td></tr>
<tr><td> 8</td><td>array_clear_size_18.c</td><td>smazání obsahu pole se sedmnácti prvky typu <strong>float</strong></td><td><a href="https://github.com/tisnik/8bit-fame/blob/master/gcc-simd/array_clear_size_18.c">https://github.com/tisnik/8bit-fame/blob/master/gcc-simd/array_clear_size_18.c</a></td></tr>
<tr><td> 9</td><td>array_clear_size_18_non_vect.asm</td><td>výsledek překladu do assembleru se zákazem vektorizace</td><td><a href="https://github.com/tisnik/8bit-fame/blob/master/gcc-simd/array_clear_size_18_non_vect.asm">https://github.com/tisnik/8bit-fame/blob/master/gcc-simd/array_clear_size_18_non_vect.asm</a></td></tr>
<tr><td>10</td><td>array_clear_size_18_vect.asm</td><td>výsledek překladu do assembleru s&nbsp;povolením vektorizace</td><td><a href="https://github.com/tisnik/8bit-fame/blob/master/gcc-simd/array_clear_size_18_vect.asm">https://github.com/tisnik/8bit-fame/blob/master/gcc-simd/array_clear_size_18_vect.asm</a></td></tr>
<tr><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td></tr>
<tr><td>11</td><td>add_delta_size_16.c</td><td>přičtení konstanty ke všem prvkům pole obsahujícího 16 hodnot typu <strong>float</strong></td><td><a href="https://github.com/tisnik/8bit-fame/blob/master/gcc-simd/add_delta_size_16.c">https://github.com/tisnik/8bit-fame/blob/master/gcc-simd/add_delta_size_16.c</a></td></tr>
<tr><td>12</td><td>add_delta_size_16_non_vect.asm</td><td>výsledek překladu do assembleru se zákazem vektorizace</td><td><a href="https://github.com/tisnik/8bit-fame/blob/master/gcc-simd/add_delta_size_16_non_vect.asm">https://github.com/tisnik/8bit-fame/blob/master/gcc-simd/add_delta_size_16_non_vect.asm</a></td></tr>
<tr><td>13</td><td>add_delta_size_16_vect.asm</td><td>výsledek překladu do assembleru s&nbsp;povolením vektorizace</td><td><a href="https://github.com/tisnik/8bit-fame/blob/master/gcc-simd/add_delta_size_16_vect.asm">https://github.com/tisnik/8bit-fame/blob/master/gcc-simd/add_delta_size_16_vect.asm</a></td></tr>
<tr><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td></tr>
<tr><td>14</td><td>add_delta_size_17.c</td><td>přičtení konstanty ke všem prvkům pole obsahujícího 17 hodnot typu <strong>float</strong></td><td><a href="https://github.com/tisnik/8bit-fame/blob/master/gcc-simd/add_delta_size_17.c">https://github.com/tisnik/8bit-fame/blob/master/gcc-simd/add_delta_size_17.c</a></td></tr>
<tr><td>15</td><td>add_delta_size_17_non_vect.asm</td><td>výsledek překladu do assembleru se zákazem vektorizace</td><td><a href="https://github.com/tisnik/8bit-fame/blob/master/gcc-simd/add_delta_size_17_non_vect.asm">https://github.com/tisnik/8bit-fame/blob/master/gcc-simd/add_delta_size_17_non_vect.asm</a></td></tr>
<tr><td>16</td><td>add_delta_size_17_vect.asm</td><td>výsledek překladu do assembleru s&nbsp;povolením vektorizace</td><td><a href="https://github.com/tisnik/8bit-fame/blob/master/gcc-simd/add_delta_size_17_vect.asm">https://github.com/tisnik/8bit-fame/blob/master/gcc-simd/add_delta_size_17_vect.asm</a></td></tr>
<tr><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td></tr>
<tr><td>17</td><td>add_delta_size_24.c</td><td>přičtení konstanty ke všem prvkům pole obsahujícího 24 hodnot typu <strong>float</strong></td><td><a href="https://github.com/tisnik/8bit-fame/blob/master/gcc-simd/add_delta_size_24.c">https://github.com/tisnik/8bit-fame/blob/master/gcc-simd/add_delta_size_24.c</a></td></tr>
<tr><td>18</td><td>add_delta_size_24_non_vect.asm</td><td>výsledek překladu do assembleru se zákazem vektorizace</td><td><a href="https://github.com/tisnik/8bit-fame/blob/master/gcc-simd/add_delta_size_24_non_vect.asm">https://github.com/tisnik/8bit-fame/blob/master/gcc-simd/add_delta_size_24_non_vect.asm</a></td></tr>
<tr><td>19</td><td>add_delta_size_24_vect.asm</td><td>výsledek překladu do assembleru s&nbsp;povolením vektorizace</td><td><a href="https://github.com/tisnik/8bit-fame/blob/master/gcc-simd/add_delta_size_24_vect.asm">https://github.com/tisnik/8bit-fame/blob/master/gcc-simd/add_delta_size_24_vect.asm</a></td></tr>
<tr><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td></tr>
<tr><td>20</td><td>array_sqrt.c</td><td>výpočet druhé odmocniny všech prvků polí</td><td><a href="https://github.com/tisnik/8bit-fame/blob/master/gcc-simd/array_sqrt.c">https://github.com/tisnik/8bit-fame/blob/master/gcc-simd/array_sqrt.c</a></td></tr>
<tr><td>21</td><td>array_sqrt_non_vect.asm</td><td>výsledek překladu do assembleru se zákazem vektorizace</td><td><a href="https://github.com/tisnik/8bit-fame/blob/master/gcc-simd/array_sqrt_non_vect.asm">https://github.com/tisnik/8bit-fame/blob/master/gcc-simd/array_sqrt_non_vect.asm</a></td></tr>
<tr><td>22</td><td>array_sqrt_vect.asm</td><td>výsledek překladu do assembleru s&nbsp;povolením vektorizace</td><td><a href="https://github.com/tisnik/8bit-fame/blob/master/gcc-simd/array_sqrt_vect.asm">https://github.com/tisnik/8bit-fame/blob/master/gcc-simd/array_sqrt_vect.asm</a></td></tr>
<tr><td>23</td><td>array_sqrt_vect_fast_math.asm</td><td>výsledek překladu do assembleru s&nbsp;povolením vektorizace a nepřesných výpočtů</td><td><a href="https://github.com/tisnik/8bit-fame/blob/master/gcc-simd/array_sqrt_vect_fast_math.asm">https://github.com/tisnik/8bit-fame/blob/master/gcc-simd/array_sqrt_vect_fast_math.asm</a></td></tr>
<tr><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td></tr>
<tr><td>24</td><td>dot_product_4.c</td><td>skalární součin vektorů, z&nbsp;nichž každý má délku čtyři prvky</td><td><a href="https://github.com/tisnik/8bit-fame/blob/master/gcc-simd/dot_product_4.c">https://github.com/tisnik/8bit-fame/blob/master/gcc-simd/dot_product_4.c</a></td></tr>
<tr><td>25</td><td>dot_product_4_non_vect.asm</td><td>výsledek překladu do assembleru se zákazem vektorizace</td><td><a href="https://github.com/tisnik/8bit-fame/blob/master/gcc-simd/dot_product_4_non_vect.asm">https://github.com/tisnik/8bit-fame/blob/master/gcc-simd/dot_product_4_non_vect.asm</a></td></tr>
<tr><td>26</td><td>dot_product_4_vect.asm</td><td>výsledek překladu do assembleru s&nbsp;povolením vektorizace</td><td><a href="https://github.com/tisnik/8bit-fame/blob/master/gcc-simd/dot_product_4_vect.asm">https://github.com/tisnik/8bit-fame/blob/master/gcc-simd/dot_product_4_vect.asm</a></td></tr>
<tr><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td></tr>
<tr><td>27</td><td>dot_product_8.c</td><td>skalární součin vektorů, z&nbsp;nichž každý má délku osmi prvků</td><td><a href="https://github.com/tisnik/8bit-fame/blob/master/gcc-simd/dot_product_8.c">https://github.com/tisnik/8bit-fame/blob/master/gcc-simd/dot_product_8.c</a></td></tr>
<tr><td>28</td><td>dot_product_8_non_vect.asm</td><td>výsledek překladu do assembleru se zákazem vektorizace</td><td><a href="https://github.com/tisnik/8bit-fame/blob/master/gcc-simd/dot_product_8_non_vect.asm">https://github.com/tisnik/8bit-fame/blob/master/gcc-simd/dot_product_8_non_vect.asm</a></td></tr>
<tr><td>29</td><td>dot_product_8_vect.asm</td><td>výsledek překladu do assembleru s&nbsp;povolením vektorizace</td><td><a href="https://github.com/tisnik/8bit-fame/blob/master/gcc-simd/dot_product_8_vect.asm">https://github.com/tisnik/8bit-fame/blob/master/gcc-simd/dot_product_8_vect.asm</a></td></tr>
<tr><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td></tr>
<tr><td>30</td><td>dot_product_100.c</td><td>skalární součin vektorů, z&nbsp;nichž každý má délku 100 prvků</td><td><a href="https://github.com/tisnik/8bit-fame/blob/master/gcc-simd/dot_product_100.c">https://github.com/tisnik/8bit-fame/blob/master/gcc-simd/dot_product_100.c</a></td></tr>
<tr><td>31</td><td>dot_product_100_non_vect.asm</td><td>výsledek překladu do assembleru se zákazem vektorizace</td><td><a href="https://github.com/tisnik/8bit-fame/blob/master/gcc-simd/dot_product_100_non_vect.asm">https://github.com/tisnik/8bit-fame/blob/master/gcc-simd/dot_product_100_non_vect.asm</a></td></tr>
<tr><td>32</td><td>dot_product_100_vect.asm</td><td>výsledek překladu do assembleru s&nbsp;povolením vektorizace</td><td><a href="https://github.com/tisnik/8bit-fame/blob/master/gcc-simd/dot_product_100_vect.asm">https://github.com/tisnik/8bit-fame/blob/master/gcc-simd/dot_product_100_vect.asm</a></td></tr>
<tr><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td></tr>
<tr><td>33</td><td>add_arrays_size_4.c</td><td>součet prvků dvojice polí typu <strong>float</strong>, pole mají délku 4 prvků</td><td><a href="https://github.com/tisnik/8bit-fame/blob/master/gcc-simd/add_arrays_size_4.c">https://github.com/tisnik/8bit-fame/blob/master/gcc-simd/add_arrays_size_4.c</a></td></tr>
<tr><td>34</td><td>add_arrays_size_4_non_vect.asm</td><td>výsledek překladu do assembleru se zákazem vektorizace</td><td><a href="https://github.com/tisnik/8bit-fame/blob/master/gcc-simd/add_arrays_size_4_non_vect.asm">https://github.com/tisnik/8bit-fame/blob/master/gcc-simd/add_arrays_size_4_non_vect.asm</a></td></tr>
<tr><td>35</td><td>add_arrays_size_4_vect.asm</td><td>výsledek překladu do assembleru s&nbsp;povolením vektorizace</td><td><a href="https://github.com/tisnik/8bit-fame/blob/master/gcc-simd/add_arrays_size_4_vect.asm">https://github.com/tisnik/8bit-fame/blob/master/gcc-simd/add_arrays_size_4_vect.asm</a></td></tr>
<tr><td>36</td><td>add_arrays_size_16.c</td><td>součet prvků dvojice polí typu <strong>float</strong>, pole mají délku 16 prvků</td><td><a href="https://github.com/tisnik/8bit-fame/blob/master/gcc-simd/add_arrays_size_16.c">https://github.com/tisnik/8bit-fame/blob/master/gcc-simd/add_arrays_size_16.c</a></td></tr>
<tr><td>37</td><td>add_arrays_size_16_non_vect.asm</td><td>výsledek překladu do assembleru se zákazem vektorizace</td><td><a href="https://github.com/tisnik/8bit-fame/blob/master/gcc-simd/add_arrays_size_16_non_vect.asm">https://github.com/tisnik/8bit-fame/blob/master/gcc-simd/add_arrays_size_16_non_vect.asm</a></td></tr>
<tr><td>38</td><td>add_arrays_size_16_vect.asm</td><td>výsledek překladu do assembleru s&nbsp;povolením vektorizace</td><td><a href="https://github.com/tisnik/8bit-fame/blob/master/gcc-simd/add_arrays_size_16_vect.asm">https://github.com/tisnik/8bit-fame/blob/master/gcc-simd/add_arrays_size_16_vect.asm</a></td></tr>
<tr><td>39</td><td>add_arrays_size_17.c</td><td>součet prvků dvojice polí typu <strong>float</strong>, pole mají délku 17 prvků</td><td><a href="https://github.com/tisnik/8bit-fame/blob/master/gcc-simd/add_arrays_size_17.c">https://github.com/tisnik/8bit-fame/blob/master/gcc-simd/add_arrays_size_17.c</a></td></tr>
<tr><td>40</td><td>add_arrays_size_17_non_vect.asm</td><td>výsledek překladu do assembleru se zákazem vektorizace</td><td><a href="https://github.com/tisnik/8bit-fame/blob/master/gcc-simd/add_arrays_size_17_non_vect.asm">https://github.com/tisnik/8bit-fame/blob/master/gcc-simd/add_arrays_size_17_non_vect.asm</a></td></tr>
<tr><td>41</td><td>add_arrays_size_17_vect.asm</td><td>výsledek překladu do assembleru s&nbsp;povolením vektorizace</td><td><a href="https://github.com/tisnik/8bit-fame/blob/master/gcc-simd/add_arrays_size_17_vect.asm">https://github.com/tisnik/8bit-fame/blob/master/gcc-simd/add_arrays_size_17_vect.asm</a></td></tr>
<tr><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td></tr>
<tr><td>42</td><td>add_arrays_restrict_size_4.c</td><td>součet prvků polí se čtyřmi prvky, pole se nepřekrývají</td><td><a href="https://github.com/tisnik/8bit-fame/blob/master/gcc-simd/add_arrays_restrict_size_4.c">https://github.com/tisnik/8bit-fame/blob/master/gcc-simd/add_arrays_restrict_size_4.c</a></td></tr>
<tr><td>43</td><td>add_arrays_restrict_size_4_non_vect.asm</td><td>výsledek překladu do assembleru se zákazem vektorizace</td><td><a href="https://github.com/tisnik/8bit-fame/blob/master/gcc-simd/add_arrays_restrict_size_4_non_vect.asm">https://github.com/tisnik/8bit-fame/blob/master/gcc-simd/add_arrays_restrict_size_4_non_vect.asm</a></td></tr>
<tr><td>44</td><td>add_arrays_restrict_size_4_vect.asm</td><td>výsledek překladu do assembleru s&nbsp;povolením vektorizace</td><td><a href="https://github.com/tisnik/8bit-fame/blob/master/gcc-simd/add_arrays_restrict_size_4_vect.asm">https://github.com/tisnik/8bit-fame/blob/master/gcc-simd/add_arrays_restrict_size_4_vect.asm</a></td></tr>
<tr><td>45</td><td>add_arrays_restrict_size_16.c</td><td>součet prvků polí se šestnácti prvky, pole se nepřekrývají</td><td><a href="https://github.com/tisnik/8bit-fame/blob/master/gcc-simd/add_arrays_restrict_size_16.c">https://github.com/tisnik/8bit-fame/blob/master/gcc-simd/add_arrays_restrict_size_16.c</a></td></tr>
<tr><td>46</td><td>add_arrays_restrict_size_16_non_vect.asm</td><td>výsledek překladu do assembleru se zákazem vektorizace</td><td><a href="https://github.com/tisnik/8bit-fame/blob/master/gcc-simd/add_arrays_restrict_size_16_non_vect.asm">https://github.com/tisnik/8bit-fame/blob/master/gcc-simd/add_arrays_restrict_size_16_non_vect.asm</a></td></tr>
<tr><td>47</td><td>add_arrays_restrict_size_16_vect.asm</td><td>výsledek překladu do assembleru s&nbsp;povolením vektorizace</td><td><a href="https://github.com/tisnik/8bit-fame/blob/master/gcc-simd/add_arrays_restrict_size_16_vect.asm">https://github.com/tisnik/8bit-fame/blob/master/gcc-simd/add_arrays_restrict_size_16_vect.asm</a></td></tr>
<tr><td>48</td><td>add_arrays_restrict_size_17.c</td><td>součet prvků polí se sedmnácti prvky, pole se nepřekrývají</td><td><a href="https://github.com/tisnik/8bit-fame/blob/master/gcc-simd/add_arrays_restrict_size_17.c">https://github.com/tisnik/8bit-fame/blob/master/gcc-simd/add_arrays_restrict_size_17.c</a></td></tr>
<tr><td>49</td><td>add_arrays_restrict_size_17_non_vect.asm</td><td>výsledek překladu do assembleru se zákazem vektorizace</td><td><a href="https://github.com/tisnik/8bit-fame/blob/master/gcc-simd/add_arrays_restrict_size_17_non_vect.asm">https://github.com/tisnik/8bit-fame/blob/master/gcc-simd/add_arrays_restrict_size_17_non_vect.asm</a></td></tr>
<tr><td>50</td><td>add_arrays_restrict_size_17_vect.asm</td><td>výsledek překladu do assembleru s&nbsp;povolením vektorizace</td><td><a href="https://github.com/tisnik/8bit-fame/blob/master/gcc-simd/add_arrays_restrict_size_17_vect.asm">https://github.com/tisnik/8bit-fame/blob/master/gcc-simd/add_arrays_restrict_size_17_vect.asm</a></td></tr>
<tr><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td></tr>
<tr><td>51</td><td>array_sum_4.c</td><td>součet všech prvků v&nbsp;poli se čtyřmi prvky</td><td><a href="https://github.com/tisnik/8bit-fame/blob/master/gcc-simd/array_sum_4.c">https://github.com/tisnik/8bit-fame/blob/master/gcc-simd/array_sum_4.c</a></td></tr>
<tr><td>52</td><td>array_sum_4_non_vect.asm</td><td>výsledek překladu do assembleru se zákazem vektorizace</td><td><a href="https://github.com/tisnik/8bit-fame/blob/master/gcc-simd/array_sum_4_non_vect.asm">https://github.com/tisnik/8bit-fame/blob/master/gcc-simd/array_sum_4_non_vect.asm</a></td></tr>
<tr><td>53</td><td>array_sum_4_vect.asm</td><td>výsledek překladu do assembleru s&nbsp;povolením vektorizace</td><td><a href="https://github.com/tisnik/8bit-fame/blob/master/gcc-simd/array_sum_4_vect.asm">https://github.com/tisnik/8bit-fame/blob/master/gcc-simd/array_sum_4_vect.asm</a></td></tr>
<tr><td>54</td><td>array_sum_8.c</td><td>součet všech prvků v&nbsp;poli s&nbsp;osmi prvky</td><td><a href="https://github.com/tisnik/8bit-fame/blob/master/gcc-simd/array_sum_8.c">https://github.com/tisnik/8bit-fame/blob/master/gcc-simd/array_sum_8.c</a></td></tr>
<tr><td>55</td><td>array_sum_8_non_vect.asm</td><td>výsledek překladu do assembleru se zákazem vektorizace</td><td><a href="https://github.com/tisnik/8bit-fame/blob/master/gcc-simd/array_sum_8_non_vect.asm">https://github.com/tisnik/8bit-fame/blob/master/gcc-simd/array_sum_8_non_vect.asm</a></td></tr>
<tr><td>56</td><td>array_sum_8_vect.asm</td><td>výsledek překladu do assembleru s&nbsp;povolením vektorizace</td><td><a href="https://github.com/tisnik/8bit-fame/blob/master/gcc-simd/array_sum_8_vect.asm">https://github.com/tisnik/8bit-fame/blob/master/gcc-simd/array_sum_8_vect.asm</a></td></tr>
<tr><td>57</td><td>array_sum_100.c</td><td>součet všech prvků polí se 100 prvky</td><td><a href="https://github.com/tisnik/8bit-fame/blob/master/gcc-simd/array_sum_100.c">https://github.com/tisnik/8bit-fame/blob/master/gcc-simd/array_sum_100.c</a></td></tr>
<tr><td>58</td><td>array_sum_100_non_vect.asm</td><td>výsledek překladu do assembleru se zákazem vektorizace</td><td><a href="https://github.com/tisnik/8bit-fame/blob/master/gcc-simd/array_sum_100_non_vect.asm">https://github.com/tisnik/8bit-fame/blob/master/gcc-simd/array_sum_100_non_vect.asm</a></td></tr>
<tr><td>59</td><td>array_sum_100_vect.asm</td><td>výsledek překladu do assembleru s&nbsp;povolením vektorizace</td><td><a href="https://github.com/tisnik/8bit-fame/blob/master/gcc-simd/array_sum_100_vect.asm">https://github.com/tisnik/8bit-fame/blob/master/gcc-simd/array_sum_100_vect.asm</a></td></tr>
<tr><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td></tr>
<tr><td>60</td><td>find_max_4.c</td><td>vyhledání největšího prvku v&nbsp;poli se čtyřmi prvky</td><td><a href="https://github.com/tisnik/8bit-fame/blob/master/gcc-simd/find_max_4.c">https://github.com/tisnik/8bit-fame/blob/master/gcc-simd/find_max_4.c</a></td></tr>
<tr><td>61</td><td>find_max_4_non_vect.asm</td><td>výsledek překladu do assembleru se zákazem vektorizace</td><td><a href="https://github.com/tisnik/8bit-fame/blob/master/gcc-simd/find_max_4_non_vect.asm">https://github.com/tisnik/8bit-fame/blob/master/gcc-simd/find_max_4_non_vect.asm</a></td></tr>
<tr><td>62</td><td>find_max_4_vect.asm</td><td>výsledek překladu do assembleru s&nbsp;povolením vektorizace</td><td><a href="https://github.com/tisnik/8bit-fame/blob/master/gcc-simd/find_max_4_vect.asm">https://github.com/tisnik/8bit-fame/blob/master/gcc-simd/find_max_4_vect.asm</a></td></tr>
<tr><td>63</td><td>find_max_8.c</td><td>vyhledání největšího prvku v&nbsp;poli s&nbsp;osmi prvky</td><td><a href="https://github.com/tisnik/8bit-fame/blob/master/gcc-simd/find_max_8.c">https://github.com/tisnik/8bit-fame/blob/master/gcc-simd/find_max_8.c</a></td></tr>
<tr><td>64</td><td>find_max_8_non_vect.asm</td><td>výsledek překladu do assembleru se zákazem vektorizace</td><td><a href="https://github.com/tisnik/8bit-fame/blob/master/gcc-simd/find_max_8_non_vect.asm">https://github.com/tisnik/8bit-fame/blob/master/gcc-simd/find_max_8_non_vect.asm</a></td></tr>
<tr><td>65</td><td>find_max_8_vect.asm</td><td>výsledek překladu do assembleru s&nbsp;povolením vektorizace</td><td><a href="https://github.com/tisnik/8bit-fame/blob/master/gcc-simd/find_max_8_vect.asm">https://github.com/tisnik/8bit-fame/blob/master/gcc-simd/find_max_8_vect.asm</a></td></tr>
<tr><td>66</td><td>find_max_100.c</td><td>vyhledání největšího prvku v&nbsp;poli se 100 prvky</td><td><a href="https://github.com/tisnik/8bit-fame/blob/master/gcc-simd/find_max_100.c">https://github.com/tisnik/8bit-fame/blob/master/gcc-simd/find_max_100.c</a></td></tr>
<tr><td>67</td><td>find_max_100_non_vect.asm</td><td>výsledek překladu do assembleru se zákazem vektorizace</td><td><a href="https://github.com/tisnik/8bit-fame/blob/master/gcc-simd/find_max_100_non_vect.asm">https://github.com/tisnik/8bit-fame/blob/master/gcc-simd/find_max_100_non_vect.asm</a></td></tr>
<tr><td>68</td><td>find_max_100_vect.asm</td><td>výsledek překladu do assembleru s&nbsp;povolením vektorizace</td><td><a href="https://github.com/tisnik/8bit-fame/blob/master/gcc-simd/find_max_100_vect.asm">https://github.com/tisnik/8bit-fame/blob/master/gcc-simd/find_max_100_vect.asm</a></td></tr>
<tr><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td></tr>
<tr><td>69</td><td>array_clear_32_bytes.c</td><td>vynulování pole s&nbsp;prvky typu <i>byte</i> o délce 32 prvků</td><td><a href="https://github.com/tisnik/8bit-fame/blob/master/gcc-simd/array_clear_32_bytes.c">https://github.com/tisnik/8bit-fame/blob/master/gcc-simd/array_clear_32_bytes.c</a></td></tr>
<tr><td>70</td><td>array_clear_32_bytes.asm</td><td>výsledek překladu do assembleru s&nbsp;povolením vektorizace</td><td><a href="https://github.com/tisnik/8bit-fame/blob/master/gcc-simd/array_clear_32_bytes.asm">https://github.com/tisnik/8bit-fame/blob/master/gcc-simd/array_clear_32_bytes.asm</a></td></tr>
<tr><td>71</td><td>array_clear_64_bytes.c</td><td>vynulování pole s&nbsp;prvky typu <i>byte</i> o délce 64 prvků</td><td><a href="https://github.com/tisnik/8bit-fame/blob/master/gcc-simd/array_clear_64_bytes.c">https://github.com/tisnik/8bit-fame/blob/master/gcc-simd/array_clear_64_bytes.c</a></td></tr>
<tr><td>72</td><td>array_clear_64_bytes.asm</td><td>výsledek překladu do assembleru s&nbsp;povolením vektorizace</td><td><a href="https://github.com/tisnik/8bit-fame/blob/master/gcc-simd/array_clear_64_bytes.asm">https://github.com/tisnik/8bit-fame/blob/master/gcc-simd/array_clear_64_bytes.asm</a></td></tr>
<tr><td>73</td><td>array_clear_128_bytes.c</td><td>vynulování pole s&nbsp;prvky typu <i>byte</i> o délce 128 prvků</td><td><a href="https://github.com/tisnik/8bit-fame/blob/master/gcc-simd/array_clear_128_bytes.c">https://github.com/tisnik/8bit-fame/blob/master/gcc-simd/array_clear_128_bytes.c</a></td></tr>
<tr><td>74</td><td>array_clear_128_bytes.asm</td><td>výsledek překladu do assembleru s&nbsp;povolením vektorizace</td><td><a href="https://github.com/tisnik/8bit-fame/blob/master/gcc-simd/array_clear_128_bytes.asm">https://github.com/tisnik/8bit-fame/blob/master/gcc-simd/array_clear_128_bytes.asm</a></td></tr>
<tr><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td></tr>
<tr><td>75</td><td>array_clear_8_doubles.c</td><td>vynulování pole s&nbsp;prvky typu <i>double</i> o délce osmi prvků</td><td><a href="https://github.com/tisnik/8bit-fame/blob/master/gcc-simd/array_clear_8_doubles.c">https://github.com/tisnik/8bit-fame/blob/master/gcc-simd/array_clear_8_doubles.c</a></td></tr>
<tr><td>76</td><td>array_clear_8_doubles.asm</td><td>výsledek překladu do assembleru s&nbsp;povolením vektorizace</td><td><a href="https://github.com/tisnik/8bit-fame/blob/master/gcc-simd/array_clear_8_doubles.asm">https://github.com/tisnik/8bit-fame/blob/master/gcc-simd/array_clear_8_doubles.asm</a></td></tr>
<tr><td>77</td><td>array_clear_16_doubles.c</td><td>vynulování pole s&nbsp;prvky typu <i>double</i> o délce 16 prvků</td><td><a href="https://github.com/tisnik/8bit-fame/blob/master/gcc-simd/array_clear_16_doubles.c">https://github.com/tisnik/8bit-fame/blob/master/gcc-simd/array_clear_16_doubles.c</a></td></tr>
<tr><td>78</td><td>array_clear_16_doubles.asm</td><td>výsledek překladu do assembleru s&nbsp;povolením vektorizace</td><td><a href="https://github.com/tisnik/8bit-fame/blob/master/gcc-simd/array_clear_16_doubles.asm">https://github.com/tisnik/8bit-fame/blob/master/gcc-simd/array_clear_16_doubles.asm</a></td></tr>
<tr><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td></tr>
<tr><td>79</td><td>add_delta_16_bytes.c</td><td>přičtení konstanty ke všem prvkům pole typu <i>byte</i> o délce 16 prvků</td><td><a href="https://github.com/tisnik/8bit-fame/blob/master/gcc-simd/add_delta_16_bytes.c">https://github.com/tisnik/8bit-fame/blob/master/gcc-simd/add_delta_16_bytes.c</a></td></tr>
<tr><td>80</td><td>add_delta_16_bytes.asm</td><td>výsledek překladu do assembleru s&nbsp;povolením vektorizace</td><td><a href="https://github.com/tisnik/8bit-fame/blob/master/gcc-simd/add_delta_16_bytes.asm">https://github.com/tisnik/8bit-fame/blob/master/gcc-simd/add_delta_16_bytes.asm</a></td></tr>
<tr><td>81</td><td>add_delta_32_bytes.c</td><td>přičtení konstanty ke všem prvkům pole typu <i>byte</i> o délce 32 prvků</td><td><a href="https://github.com/tisnik/8bit-fame/blob/master/gcc-simd/add_delta_32_bytes.c">https://github.com/tisnik/8bit-fame/blob/master/gcc-simd/add_delta_32_bytes.c</a></td></tr>
<tr><td>82</td><td>add_delta_32_bytes.asm</td><td>výsledek překladu do assembleru s&nbsp;povolením vektorizace</td><td><a href="https://github.com/tisnik/8bit-fame/blob/master/gcc-simd/add_delta_32_bytes.asm">https://github.com/tisnik/8bit-fame/blob/master/gcc-simd/add_delta_32_bytes.asm</a></td></tr>
<tr><td>83</td><td>add_delta_64_bytes.c</td><td>přičtení konstanty ke všem prvkům pole typu <i>byte</i> o délce 64 prvků</td><td><a href="https://github.com/tisnik/8bit-fame/blob/master/gcc-simd/add_delta_64_bytes.c">https://github.com/tisnik/8bit-fame/blob/master/gcc-simd/add_delta_64_bytes.c</a></td></tr>
<tr><td>84</td><td>add_delta_64_bytes.asm</td><td>výsledek překladu do assembleru s&nbsp;povolením vektorizace</td><td><a href="https://github.com/tisnik/8bit-fame/blob/master/gcc-simd/add_delta_64_bytes.asm">https://github.com/tisnik/8bit-fame/blob/master/gcc-simd/add_delta_64_bytes.asm</a></td></tr>
<tr><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td></tr>
<tr><td>85</td><td>add_delta_4_doubles.c</td><td>přičtení konstanty ke všem prvkům pole typu <i>double</i> o délce čtyř prvků</td><td><a href="https://github.com/tisnik/8bit-fame/blob/master/gcc-simd/add_delta_4_doubles.c">https://github.com/tisnik/8bit-fame/blob/master/gcc-simd/add_delta_4_doubles.c</a></td></tr>
<tr><td>86</td><td>add_delta_4_doubles.asm</td><td>výsledek překladu do assembleru s&nbsp;povolením vektorizace</td><td><a href="https://github.com/tisnik/8bit-fame/blob/master/gcc-simd/add_delta_4_doubles.asm">https://github.com/tisnik/8bit-fame/blob/master/gcc-simd/add_delta_4_doubles.asm</a></td></tr>
<tr><td>87</td><td>add_delta_8_doubles.c</td><td>přičtení konstanty ke všem prvkům pole typu <i>double</i> o délce osmi prvků</td><td><a href="https://github.com/tisnik/8bit-fame/blob/master/gcc-simd/add_delta_8_doubles.c">https://github.com/tisnik/8bit-fame/blob/master/gcc-simd/add_delta_8_doubles.c</a></td></tr>
<tr><td>88</td><td>add_delta_8_doubles.asm</td><td>výsledek překladu do assembleru s&nbsp;povolením vektorizace</td><td><a href="https://github.com/tisnik/8bit-fame/blob/master/gcc-simd/add_delta_8_doubles.asm">https://github.com/tisnik/8bit-fame/blob/master/gcc-simd/add_delta_8_doubles.asm</a></td></tr>
<tr><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td></tr>
<tr><td>89</td><td>add_arrays_16_bytes.c</td><td>součet prvků dvou polí se 16 prvky typu <i>byte</i>: varianta s&nbsp;obecnými ukazateli</td><td><a href="https://github.com/tisnik/8bit-fame/blob/master/gcc-simd/add_arrays_16_bytes.c">https://github.com/tisnik/8bit-fame/blob/master/gcc-simd/add_arrays_16_bytes.c</a></td></tr>
<tr><td>90</td><td>add_arrays_16_bytes.asm</td><td>výsledek překladu do assembleru s&nbsp;povolením vektorizace</td><td><a href="https://github.com/tisnik/8bit-fame/blob/master/gcc-simd/add_arrays_16_bytes.asm">https://github.com/tisnik/8bit-fame/blob/master/gcc-simd/add_arrays_16_bytes.asm</a></td></tr>
<tr><td>91</td><td>add_arrays_32_bytes.c</td><td>součet prvků dvou polí s&nbsp;32 prvky typu <i>byte</i>: varianta s&nbsp;obecnými ukazateli</td><td><a href="https://github.com/tisnik/8bit-fame/blob/master/gcc-simd/add_arrays_32_bytes.c">https://github.com/tisnik/8bit-fame/blob/master/gcc-simd/add_arrays_32_bytes.c</a></td></tr>
<tr><td>92</td><td>add_arrays_32_bytes.asm</td><td>výsledek překladu do assembleru s&nbsp;povolením vektorizace</td><td><a href="https://github.com/tisnik/8bit-fame/blob/master/gcc-simd/add_arrays_32_bytes.asm">https://github.com/tisnik/8bit-fame/blob/master/gcc-simd/add_arrays_32_bytes.asm</a></td></tr>
<tr><td>93</td><td>add_arrays_16_bytes_restrict.c</td><td>součet prvků polí se 16 prvky typu <i>byte</i>: varianta s&nbsp;nepřekrývajícími se ukazateli</td><td><a href="https://github.com/tisnik/8bit-fame/blob/master/gcc-simd/add_arrays_16_bytes_restrict.c">https://github.com/tisnik/8bit-fame/blob/master/gcc-simd/add_arrays_16_bytes_restrict.c</a></td></tr>
<tr><td>94</td><td>add_arrays_16_bytes_restrict.asm</td><td>výsledek překladu do assembleru s&nbsp;povolením vektorizace</td><td><a href="https://github.com/tisnik/8bit-fame/blob/master/gcc-simd/add_arrays_16_bytes_restrict.asm">https://github.com/tisnik/8bit-fame/blob/master/gcc-simd/add_arrays_16_bytes_restrict.asm</a></td></tr>
<tr><td>95</td><td>add_arrays_32_bytes_restrict.c</td><td>součet prvků polí s&nbsp;32 prvky typu <i>byte</i>: varianta s&nbsp;nepřekrývajícími se ukazateli</td><td><a href="https://github.com/tisnik/8bit-fame/blob/master/gcc-simd/add_arrays_32_bytes_restrict.c">https://github.com/tisnik/8bit-fame/blob/master/gcc-simd/add_arrays_32_bytes_restrict.c</a></td></tr>
<tr><td>96</td><td>add_arrays_32_bytes_restrict.asm</td><td>výsledek překladu do assembleru s&nbsp;povolením vektorizace</td><td><a href="https://github.com/tisnik/8bit-fame/blob/master/gcc-simd/add_arrays_32_bytes_restrict.asm">https://github.com/tisnik/8bit-fame/blob/master/gcc-simd/add_arrays_32_bytes_restrict.asm</a></td></tr>
<tr><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td></tr>
<tr><td> 97</td><td>array_clear_size_8_backward.c</td><td>součet prvků dvou polí v&nbsp;pořadí od posledního prvku k&nbsp;prvku prvnímu</td><td><a href="https://github.com/tisnik/8bit-fame/blob/master/gcc-simd/array_clear_size_8_backward.c">https://github.com/tisnik/8bit-fame/blob/master/gcc-simd/array_clear_size_8_backward.c</a></td></tr>
<tr><td> 98</td><td>array_clear_size_8_backward.asm</td><td>výsledek překladu do assembleru s&nbsp;povolením vektorizace</td><td><a href="https://github.com/tisnik/8bit-fame/blob/master/gcc-simd/array_clear_size_8_backward.asm">https://github.com/tisnik/8bit-fame/blob/master/gcc-simd/array_clear_size_8_backward.asm</a></td></tr>
<tr><td> 99</td><td>add_arrays_size_16_backward.c</td><td>součet prvků dvou polí v&nbsp;pořadí od posledního prvku k&nbsp;prvku prvnímu</td><td><a href="https://github.com/tisnik/8bit-fame/blob/master/gcc-simd/add_arrays_size_16_backward.c">https://github.com/tisnik/8bit-fame/blob/master/gcc-simd/add_arrays_size_16_backward.c</a></td></tr>
<tr><td>100</td><td>add_arrays_size_16_backward.asm</td><td>výsledek překladu do assembleru s&nbsp;povolením vektorizace</td><td><a href="https://github.com/tisnik/8bit-fame/blob/master/gcc-simd/add_arrays_size_16_backward.asm">https://github.com/tisnik/8bit-fame/blob/master/gcc-simd/add_arrays_size_16_backward.asm</a></td></tr>
<tr><td>101</td><td>add_arrays_restrict_size_16_backward.c</td><td>součet prvků polí: varianta s&nbsp;nepřekrývajícími se ukazateli</td><td><a href="https://github.com/tisnik/8bit-fame/blob/master/gcc-simd/add_arrays_restrict_size_16_backward.c">https://github.com/tisnik/8bit-fame/blob/master/gcc-simd/add_arrays_restrict_size_16_backward.c</a></td></tr>
<tr><td>102</td><td>add_arrays_restrict_size_16_backward.asm</td><td>výsledek překladu do assembleru s&nbsp;povolením vektorizace</td><td><a href="https://github.com/tisnik/8bit-fame/blob/master/gcc-simd/add_arrays_restrict_size_16_backward.asm">https://github.com/tisnik/8bit-fame/blob/master/gcc-simd/add_arrays_restrict_size_16_backward.asm</a></td></tr>
<tr><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td></tr>
<tr><td>103</td><td>get_color_component.c</td><td>získání jedné barvové složky ze všech pixelů</td><td><a href="https://github.com/tisnik/8bit-fame/blob/master/gcc-simd/get_color_component.c">https://github.com/tisnik/8bit-fame/blob/master/gcc-simd/get_color_component.c</a></td></tr>
<tr><td>104</td><td>get_color_component.asm</td><td>výsledek překladu do assembleru s&nbsp;povolením vektorizace</td><td><a href="https://github.com/tisnik/8bit-fame/blob/master/gcc-simd/get_color_component.asm">https://github.com/tisnik/8bit-fame/blob/master/gcc-simd/get_color_component.asm</a></td></tr>
<tr><td>105</td><td>set_color_component.c</td><td>zápis jedné barvové složky do všech pixelů</td><td><a href="https://github.com/tisnik/8bit-fame/blob/master/gcc-simd/set_color_component.c">https://github.com/tisnik/8bit-fame/blob/master/gcc-simd/set_color_component.c</a></td></tr>
<tr><td>106</td><td>set_color_component.asm</td><td>výsledek překladu do assembleru s&nbsp;povolením vektorizace</td><td><a href="https://github.com/tisnik/8bit-fame/blob/master/gcc-simd/set_color_component.asm">https://github.com/tisnik/8bit-fame/blob/master/gcc-simd/set_color_component.asm</a></td></tr>
</table>



<p><a name="k19"></a></p>
<h2 id="k19">19. Seznam všech předchozích částí tohoto seriálu a článků o SIMD instrukcích</h2>

<p>Podporou SIMD instrukcí na úrovni <i>intrinsic</i> jsme se už na Rootu
zabývali, stejně jako samotnými SIMD instrukcemi na úrovni assembleru. Pro
úplnost jsou v&nbsp;této příloze uvedeny odkazy na příslušné články:</p>

<ol>

<li>Užitečné rozšíření GCC: podpora SIMD (vektorových) instrukcí<br />
<a href="https://www.root.cz/clanky/uzitecne-rozsireni-gcc-podpora-simd-vektorovych-instrukci/">https://www.root.cz/clanky/uzitecne-rozsireni-gcc-podpora-simd-vektorovych-instrukci/</a>
</li>

<li>Užitečné rozšíření GCC – podpora SIMD (vektorových) instrukcí: nedostatky technologie<br />
<a href="https://www.root.cz/clanky/uzitecne-rozsireni-gcc-podpora-simd-vektorovych-instrukci-nedostatky-technologie/">https://www.root.cz/clanky/uzitecne-rozsireni-gcc-podpora-simd-vektorovych-instrukci-nedostatky-technologie/</a>
</li>

<li>Podpora SIMD (vektorových) instrukcí na RISCových procesorech<br />
<a href="https://www.root.cz/clanky/podpora-simd-vektorovych-instrukci-na-riscovych-procesorech/">https://www.root.cz/clanky/podpora-simd-vektorovych-instrukci-na-riscovych-procesorech/</a>
</li>

<li>Podpora SIMD operací v&nbsp;GCC s&nbsp;využitím intrinsic pro nízkoúrovňové optimalizace<br />
<a href="https://www.root.cz/clanky/podpora-simd-operaci-v-gcc-s-vyuzitim-intrinsic-pro-nizkourovnove-optimalizace/">https://www.root.cz/clanky/podpora-simd-operaci-v-gcc-s-vyuzitim-intrinsic-pro-nizkourovnove-optimalizace/</a>
</li>

<li>Podpora SIMD operací v&nbsp;GCC s&nbsp;využitím intrinsic: technologie SSE<br />
<a href="https://www.root.cz/clanky/podpora-simd-operaci-v-gcc-s-vyuzitim-intrinsic-technologie-sse/">https://www.root.cz/clanky/podpora-simd-operaci-v-gcc-s-vyuzitim-intrinsic-technologie-sse/</a>
</li>

<li>Rozšíření instrukční sady „Advanced Vector Extensions“ na platformě x86–64<br />
<a href="https://www.root.cz/clanky/rozsireni-instrukcni-sady-advanced-vector-extensions-na-platforme-x86-64/">https://www.root.cz/clanky/rozsireni-instrukcni-sady-advanced-vector-extensions-na-platforme-x86-64/</a>
</li>

<li>Rozšíření instrukční sady F16C, FMA a AVX-512 na platformě x86–64<br />
<a href="https://www.root.cz/clanky/rozsireni-instrukcni-sady-f16c-fma-a-avx-512-na-platforme-x86-64/">https://www.root.cz/clanky/rozsireni-instrukcni-sady-f16c-fma-a-avx-512-na-platforme-x86-64/</a>
</li>

<li>Rozšíření instrukční sady AVX-512 na platformě x86–64 (dokončení)<br />
<a href="https://www.root.cz/clanky/rozsireni-instrukcni-sady-avx-512-na-platforme-x86-64-dokonceni/">https://www.root.cz/clanky/rozsireni-instrukcni-sady-avx-512-na-platforme-x86-64-dokonceni/</a>
</li>

<li>SIMD instrukce na platformě 80×86: instrukční sada MMX<br />
<a href="https://www.root.cz/clanky/simd-instrukce-na-platforme-80x86-instrukcni-sada-mmx/">https://www.root.cz/clanky/simd-instrukce-na-platforme-80x86-instrukcni-sada-mmx/</a>
</li>

<li>SIMD instrukce na 80×86: dokončení popisu MMX, instrukce 3DNow! <br />
<a href="https://www.root.cz/clanky/simd-instrukce-na-80-86-dokonceni-popisu-mmx-instrukce-3dnow/">https://www.root.cz/clanky/simd-instrukce-na-80-86-dokonceni-popisu-mmx-instrukce-3dnow/</a>
</li>

<li>SIMD instrukce v rozšíření SSE<br />
<a href="https://www.root.cz/clanky/simd-instrukce-v-rozsireni-sse/">https://www.root.cz/clanky/simd-instrukce-v-rozsireni-sse/</a>
</li>

<li>SIMD instrukce v rozšíření SSE (2. část)<br />
<a href="https://www.root.cz/clanky/simd-instrukce-v-rozsireni-sse-2-cast/">https://www.root.cz/clanky/simd-instrukce-v-rozsireni-sse-2-cast/</a>
</li>

<li>Pokročilejší SSE operace: přeskupení, promíchání a rozbalování prvků vektorů<br />
<a href="https://www.root.cz/clanky/pokrocilejsi-sse-operace-preskupeni-promichani-a-rozbalovani-prvku-vektoru/">https://www.root.cz/clanky/pokrocilejsi-sse-operace-preskupeni-promichani-a-rozbalovani-prvku-vektoru/</a>
</li>

<li>Od instrukční sady SSE k sadě SSE2<br />
<a href="https://www.root.cz/clanky/od-instrukcni-sady-sse-k-sade-sse2/">https://www.root.cz/clanky/od-instrukcni-sady-sse-k-sade-sse2/</a>
</li>

<li>Instrukční sady SIMD a automatické vektorizace prováděné překladačem GCC<br />
<a href="https://www.root.cz/clanky/instrukcni-sady-simd-a-automaticke-vektorizace-provadene-prekladacem-gcc/">https://www.root.cz/clanky/instrukcni-sady-simd-a-automaticke-vektorizace-provadene-prekladacem-gcc/</a>
</li>

<li>Instrukční sady SIMD a automatické vektorizace prováděné překladačem GCC (2)<br />
<a href="https://www.root.cz/clanky/instrukcni-sady-simd-a-automaticke-vektorizace-provadene-prekladacem-gcc-2/">https://www.root.cz/clanky/instrukcni-sady-simd-a-automaticke-vektorizace-provadene-prekladacem-gcc-2/</a>
</li>

</ol>



<p><a name="k20"></a></p>
<h2 id="k20">20. Odkazy na Internetu</h2>

<ol>

<li>Auto-vectorization in GCC<br />
<a href="https://gcc.gnu.org/projects/tree-ssa/vectorization.html">https://gcc.gnu.org/projects/tree-ssa/vectorization.html</a>
</li>

<li>GCC documentation: Extensions to the C Language Family<br />
<a href="https://gcc.gnu.org/onlinedocs/gcc/C-Extensions.html#C-Extensions">https://gcc.gnu.org/onlinedocs/gcc/C-Extensions.html#C-Extensions</a>
</li>

<li>GCC documentation: Using Vector Instructions through Built-in Functions<br />
<a href="https://gcc.gnu.org/onlinedocs/gcc/Vector-Extensions.html">https://gcc.gnu.org/onlinedocs/gcc/Vector-Extensions.html</a>
</li>

<li>SSE (Streaming SIMD Extentions)<br />
<a href="http://www.songho.ca/misc/sse/sse.html">http://www.songho.ca/misc/sse/sse.html</a>
</li>

<li>Timothy A. Chagnon: SSE and SSE2<br />
<a href="http://www.cs.drexel.edu/~tc365/mpi-wht/sse.pdf">http://www.cs.drexel.edu/~tc365/mpi-wht/sse.pdf</a>
</li>

<li>Intel corporation: Extending the Worldr's Most Popular Processor Architecture<br />
<a href="http://download.intel.com/technology/architecture/new-instructions-paper.pdf">http://download.intel.com/technology/architecture/new-instructions-paper.pdf</a>
</li>

<li>SIMD architectures:<br />
<a href="http://arstechnica.com/old/content/2000/03/simd.ars/">http://arstechnica.com/old/content/2000/03/simd.ars/</a>
</li>

<li>Tour of the Black Holes of Computing!: Floating Point<br />
<a href="http://www.cs.hmc.edu/~geoff/classes/hmc.cs105.../slides/class02_floats.ppt">http://www.cs.hmc.edu/~geoff/classes/hmc.cs105.../slides/class02_floats.ppt</a>
</li>

<li>3Dnow! Technology Manual<br />
AMD Inc., 2000</li>

<li>Intel MMX<sup>TM</sup> Technology Overview<br />
Intel corporation, 1996</li>

<li>MultiMedia eXtensions<br />
<a href="http://softpixel.com/~cwright/programming/simd/mmx.php">http://softpixel.com/~cwright/programming/simd/mmx.php</a>i
</li>

<li>AMD K5 ("K5" / "5k86")<br />
<a href="http://www.pcguide.com/ref/cpu/fam/g5K5-c.html">http://www.pcguide.com/ref/cpu/fam/g5K5-c.html</a>
</li>

<li>Sixth Generation Processors<br />
<a href="http://www.pcguide.com/ref/cpu/fam/g6.htm">http://www.pcguide.com/ref/cpu/fam/g6.htm</a>
</li>

<li>Great Microprocessors of the Past and Present<br />
<a href="http://www.cpushack.com/CPU/cpu1.html">http://www.cpushack.com/CPU/cpu1.html</a>
</li>

<li>Very long instruction word (Wikipedia)<br />
<a href="http://en.wikipedia.org/wiki/Very_long_instruction_word">http://en.wikipedia.org/wiki/Very_long_instruction_word</a>
</li>

<li>CPU design (Wikipedia)<br />
<a href="http://en.wikipedia.org/wiki/CPU_design">http://en.wikipedia.org/wiki/CPU_design</a>
</li>

<li>Bulldozer (microarchitecture)<br />
<a href="https://en.wikipedia.org/wiki/Bulldozer_(microarchitecture)">https://en.wikipedia.org/wiki/Bulldozer_(microarchitecture)</a>
</li>

<li>SIMD Instructions Considered Harmful<br />
<a href="https://www.sigarch.org/simd-instructions-considered-harmful/">https://www.sigarch.org/simd-instructions-considered-harmful/</a>
</li>

<li>GCC Compiler Intrinsics<br />
<a href="https://iq.opengenus.org/gcc-compiler-intrinsics/">https://iq.opengenus.org/gcc-compiler-intrinsics/</a>
</li>

<li>Scalable_Vector_Extension_(SVE)<br />
<a href="https://en.wikipedia.org/wiki/AArch64#Scalable_Vector_Extension_(SVE)">https://en.wikipedia.org/wiki/AArch64#Scalable_Vector_Extension_(SVE)</a>
</li>

<li>Improve the Multimedia User Experience<br />
<a href="https://www.arm.com/technologies/neon">https://www.arm.com/technologies/neon</a>
</li>

<li>NEON Technology (stránky ARM)<br />
<a href="https://developer.arm.com/technologies/neon">https://developer.arm.com/technologies/neon</a>
</li>

<li>SIMD Assembly Tutorial: ARM NEON - Xiph.org<br />
<a href="https://people.xiph.org/~tterribe/daala/neon_tutorial.pdf">https://people.xiph.org/~tterribe/daala/neon_tutorial.pdf</a>
</li>

<li>Ne10<br />
<a href="http://projectne10.github.io/Ne10/">http://projectne10.github.io/Ne10/</a>
</li>

<li>NEON and Floating-Point architecture<br />
<a href="http://infocenter.arm.com/help/index.jsp?topic=/com.arm.doc.den0024a/BABIGHEB.html">http://infocenter.arm.com/help/index.jsp?topic=/com.arm.doc.den0024a/BABIGHEB.html</a>
</li>

<li>An Introduction to ARM NEON<br />
<a href="http://peterdn.com/post/an-introduction-to-ARM-NEON.aspx">http://peterdn.com/post/an-introduction-to-ARM-NEON.aspx</a>
</li>

<li>ARM NEON Intrinsics Reference<br />
<a href="http://infocenter.arm.com/help/topic/com.arm.doc.ihi0073a/IHI0073A_arm_neon_intrinsics_ref.pdf">http://infocenter.arm.com/help/topic/com.arm.doc.ihi0073a/IHI0073A_arm_neon_intrinsics_ref.pdf</a>
</li>

<li>Arm Neon Intrinsics vs hand assembly<br />
<a href="https://stackoverflow.com/questions/9828567/arm-neon-intrinsics-vs-hand-assembly">https://stackoverflow.com/questions/9828567/arm-neon-intrinsics-vs-hand-assembly</a>
</li>

<li>ARM NEON Optimization. An Example<br />
<a href="http://hilbert-space.de/?p=22">http://hilbert-space.de/?p=22</a>
</li>

<li>AArch64 NEON instruction format<br />
<a href="https://developer.arm.com/docs/den0024/latest/7-aarch64-floating-point-and-neon/73-aarch64-neon-instruction-format">https://developer.arm.com/docs/den0024/latest/7-aarch64-floating-point-and-neon/73-aarch64-neon-instruction-format</a>
</li>

<li>ARM SIMD instructions<br />
<a href="https://developer.arm.com/documentation/dht0002/a/Introducing-NEON/What-is-SIMD-/ARM-SIMD-instructions">https://developer.arm.com/documentation/dht0002/a/Introducing-NEON/What-is-SIMD-/ARM-SIMD-instructions</a>
</li>

<li>Learn the architecture - Migrate Neon to SVE Version 1.0<br />
<a href="https://developer.arm.com/documentation/102131/0100/?lang=en">https://developer.arm.com/documentation/102131/0100/?lang=en</a>
</li>

<li>1.2.2. Comparison between NEON technology and other SIMD solutions<br />
<a href="https://developer.arm.com/documentation/den0018/a/Introduction/Comparison-between-ARM-NEON-technology-and-other-implementations/Comparison-between-NEON-technology-and-other-SIMD-solutions?lang=en">https://developer.arm.com/documentation/den0018/a/Introduction/Comparison-between-ARM-NEON-technology-and-other-implementations/Comparison-between-NEON-technology-and-other-SIMD-solutions?lang=en</a>
</li>

<li>NEON Programmer’s Guide<br />
<a href="https://documentation-service.arm.com/static/63299276e68c6809a6b41308">https://documentation-service.arm.com/static/63299276e68c6809a6b41308</a>
</li>

<li>Brain Floating Point – nový formát uložení čísel pro strojové učení a chytrá čidla<br />
<a href="https://www.root.cz/clanky/brain-floating-point-ndash-novy-format-ulozeni-cisel-pro-strojove-uceni-a-chytra-cidla/">https://www.root.cz/clanky/brain-floating-point-ndash-novy-format-ulozeni-cisel-pro-strojove-uceni-a-chytra-cidla/</a>
</li>

<li>Other Built-in Functions Provided by GCC<br />
<a href="https://gcc.gnu.org/onlinedocs/gcc/Other-Builtins.html">https://gcc.gnu.org/onlinedocs/gcc/Other-Builtins.html</a>
</li>

<li>GCC: 6.60 Built-in Functions Specific to Particular Target Machines<br />
<a href="https://gcc.gnu.org/onlinedocs/gcc/Target-Builtins.html#Target-Builtins">https://gcc.gnu.org/onlinedocs/gcc/Target-Builtins.html#Target-Builtins</a>
</li>

<li>Advanced Vector Extensions<br />
<a href="https://en.wikipedia.org/wiki/Advanced_Vector_Extensions">https://en.wikipedia.org/wiki/Advanced_Vector_Extensions</a>
</li>

<li>Top 10 Craziest Assembly Language Instructions<br />
<a href="https://www.youtube.com/watch?v=Wz_xJPN7lAY">https://www.youtube.com/watch?v=Wz_xJPN7lAY</a>
</li>

<li>Intel x86: let's take a look at one of the most complex instruction set!<br />
<a href="https://www.youtube.com/watch?v=KBLy23B38-c">https://www.youtube.com/watch?v=KBLy23B38-c</a>
</li>

<li>x64 Assembly Tutorial 58: Intro to AVX<br />
<a href="https://www.youtube.com/watch?v=yAvuHd8cBJY">https://www.youtube.com/watch?v=yAvuHd8cBJY</a>
</li>

<li>AVX512 (1 of 3): Introduction and Overview<br />
<a href="https://www.youtube.com/watch?v=D-mM6X5xnTY">https://www.youtube.com/watch?v=D-mM6X5xnTY</a>
</li>

<li>AVX512 (2 of 3): Programming AVX512 in 3 Different Ways<br />
<a href="https://www.youtube.com/watch?v=I3efQKLgsjM">https://www.youtube.com/watch?v=I3efQKLgsjM</a>
</li>

<li>AVX512 (3 of 3): Deep Dive into AVX512 Mechanisms<br />
<a href="https://www.youtube.com/watch?v=543a1b-cPmU">https://www.youtube.com/watch?v=543a1b-cPmU</a>
</li>

<li>AVX-512<br />
<a href="https://en.wikipedia.org/wiki/AVX-512">https://en.wikipedia.org/wiki/AVX-512</a>
</li>

<li>AVX-512<br />
<a href="https://iq.opengenus.org/avx512/">https://iq.opengenus.org/avx512/</a>
</li>

<li>SIMD Algorithms Youtube course<br />
<a href="https://denisyaroshevskiy.github.io/presentations/">https://denisyaroshevskiy.github.io/presentations/</a>
</li>

<li>Compiler explorer<br />
<a href="https://godbolt.org/">https://godbolt.org/</a>
</li>

<li>Restricting pointers<br />
<a href="https://gcc.gnu.org/onlinedocs/gcc/Restricted-Pointers.html">https://gcc.gnu.org/onlinedocs/gcc/Restricted-Pointers.html</a>
</li>

<li>Does the restrict keyword provide significant benefits in gcc/g++<br />
<a href="https://stackoverflow.com/questions/1965487/does-the-restrict-keyword-provide-significant-benefits-in-gcc-g">https://stackoverflow.com/questions/1965487/does-the-restrict-keyword-provide-significant-benefits-in-gcc-g</a>
</li>

<li>Demystifying The Restrict Keyword<br />
<a href="https://cellperformance.beyond3d.com/articles/2006/05/demystifying-the-restrict-keyword.html">https://cellperformance.beyond3d.com/articles/2006/05/demystifying-the-restrict-keyword.html</a>
</li>

<li>Basics of Vectorization for Fortran Applications<br />
<a href="https://inria.hal.science/hal-01688488/document">https://inria.hal.science/hal-01688488/document</a>
</li>

<li>What does the restrict keyword mean in C++?<br />
<a href="https://stackoverflow.com/questions/776283/what-does-the-restrict-keyword-mean-in-c">https://stackoverflow.com/questions/776283/what-does-the-restrict-keyword-mean-in-c</a>
</li>

<li>restrict keyword (Wikipedia)<br />
<a href="https://en.wikipedia.org/wiki/Restrict">https://en.wikipedia.org/wiki/Restrict</a>
</li>

<li>Reduction operator<br />
<a href="https://en.wikipedia.org/wiki/Reduction_operator">https://en.wikipedia.org/wiki/Reduction_operator</a>
</li>

<li>The Power of the Dot Product in Artificial Intelligence<br />
<a href="https://medium.com/data-science/the-power-of-the-dot-product-in-artificial-intelligence-c002331e1829">https://medium.com/data-science/the-power-of-the-dot-product-in-artificial-intelligence-c002331e1829</a>
</li>

<li>Can any one explain why dot product is used in neural network and what is the intitutive thought of dot product<br />
<a href="https://stats.stackexchange.com/questions/291680/can-any-one-explain-why-dot-product-is-used-in-neural-network-and-what-is-the-in">https://stats.stackexchange.com/questions/291680/can-any-one-explain-why-dot-product-is-used-in-neural-network-and-what-is-the-in</a>
</li>

<li>Aligned and unaligned memory accesses?<br />
<a href="https://stackoverflow.com/questions/1063809/aligned-and-unaligned-memory-accesses">https://stackoverflow.com/questions/1063809/aligned-and-unaligned-memory-accesses</a>
</li>

</ol>



<p></p><p></p>
<p><small>Autor: <a href="https://github.com/tisnik/">Pavel Tišnovský</a> &nbsp; 2024</small></p>
</body>
</html>

