<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
        "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html>
<head>
<title>Instrukční sady procesorových jader s otevřenou architekturou RISC-V (dokončení)</title>
<meta name="Author" content="Pavel Tisnovsky" />
<meta name="Generator" content="vim" />
<meta http-equiv="content-type" content="text/html; charset=utf-8" />
<style type="text/css">
         body {color:#000000; background:#ffffff;}
         h1  {font-family: arial, helvetica, sans-serif; color:#ffffff; background-color:#c00000; text-align:center; padding-left:1em}
         h2  {font-family: arial, helvetica, sans-serif; color:#ffffff; background-color:#0000c0; padding-left:1em; text-align:left}
         h3  {font-family: arial, helvetica, sans-serif; color:#000000; background-color:#c0c0c0; padding-left:1em; text-align:left}
         h4  {font-family: arial, helvetica, sans-serif; color:#000000; background-color:#e0e0e0; padding-left:1em; text-align:left}
         a   {font-family: arial, helvetica, sans-serif;}
         li  {font-family: arial, helvetica, sans-serif; color:#000000; text-align:justify; width:450px;}
         ol  {font-family: arial, helvetica, sans-serif; color:#000000; text-align:justify; width:450px;}
         ul  {font-family: arial, helvetica, sans-serif; color:#000000; text-align:justify; width:450px;}
         p   {font-family: arial, helvetica, sans-serif; color:#000000; text-align:justify;}
         pre {background:#e0e0e0}
</style>
</head>

<body>

<h1>Instrukční sady procesorových jader s otevřenou architekturou RISC-V (dokončení)</h1>

<h3>Pavel Tišnovský</h3>

<p></p>

<h1>Úvodník</h1>

<p>V dnešní části článku o otevřené architektuře RISCových jader RISC-V dokončíme popis instrukčních sad rozšiřujících základní 32bitovou instrukční sadu RV32I. Seznámíme se s&nbsp;rozšířením &bdquo;D&ldquo; (operace s&nbsp;čísly double), &bdquo;Q&ldquo; (čísla se čtyřnásobnou přesností), &bdquo;A&ldquo; (atomické operace), 64bitovou instrukční sadou i s&nbsp;rozšířením &bdquo;C&ldquo; (komprimované instrukce).</p>



<h2>Obsah</h2>

<p><a href="#k01">1. Instrukční sady procesorových jader s&nbsp;otevřenou architekturou RISC-V (dokončení)</a></p>
<p><a href="#k02">2. Dokončení popisu rozšíření instrukční sady &bdquo;F&ldquo;</a></p>
<p><a href="#k03">3. Instrukce určené pro modifikaci znaménka výsledku</a></p>
<p><a href="#k04">4. Rozdíl mezi konverzí FP hodnoty na celé číslo a kopií bitového vzorku</a></p>
<p><a href="#k05">5. Rozšíření instrukční sady &bdquo;D&ldquo; &ndash; podpora pro hodnoty s&nbsp;dvojitou přesností</a></p>
<p><a href="#k06">6. Rozšíření instrukční sady &bdquo;Q&ldquo; &ndash; podpora pro hodnoty se čtyřnásobnou přesností</a></p>
<p><a href="#k07">7. Rozšíření instrukční sady &bdquo;A&ldquo; &ndash; podpora pro atomické operace</a></p>
<p><a href="#k08">8. AMO: Atomic Memory Operation</a></p>
<p><a href="#k09">9. 64bitová instrukční sada RV64I</a></p>
<p><a href="#k10">10. Neoficiální rozšíření instrukční sady &bdquo;C&ldquo; &ndash; komprimované instrukce</a></p>
<p><a href="#k11">11. Odkazy na Internetu</a></p>



<p><a name="k01"></a></p>
<h2 id="k01">1. Instrukční sady procesorových jader s&nbsp;otevřenou architekturou RISC-V (dokončení)</h2>

<p>V&nbsp;předchozích dvou částech [<a
href="http://www.root.cz/clanky/instrukcni-sada-procesorovych-jader-s-otevrenou-architekturou-risc-v/">1</a>][<a
href="http://www.root.cz/clanky/rozsireni-instrukcni-sady-procesorovych-jader-s-otevrenou-architekturou-risc-v/">2</a>]
seriálu o otevřené architektuře RISCových procesorových jader <i>RISC-V</i>
jsme se seznámili jak se základní 32bitovou instrukční sadou pojmenovanou
jednoduše <i>RV32I</i> (RISC-V 32bit Instructions), tak i s&nbsp;jejím
rozšířením označeným písmenem &bdquo;M&ldquo;, které obsahuje nové instrukce
určené pro provedení operací násobení a dělení. Teoreticky tedy tyto instrukce
vyžadují hardwarovou násobičku a děličku, i když ve skutečnosti se může jednat
i o implementaci založenou na ne-RISCovém mikroprogramovém řadiči. Taktéž jsme
se ve stručnosti zmínili o rozšíření označeném písmenem &bdquo;F&ldquo;,
tj.&nbsp;vlastně o matematickém koprocesoru určeném pro zpracování numerických
hodnot s&nbsp;jednoduchou přesností (<i>single/float</i>). Termín
&bdquo;koprocesor&ldquo; zde používám z&nbsp;toho důvodu, že používá vlastní
instrukční sadu i vlastní sadu registrů, i když fyzicky se velmi pravděpodobně
bude jednat o totožný čip, na němž bude implementováno i RISCové jádro (a L1
cache).<p>

<p>Z&nbsp;předchozích dvou článků taktéž víme, že kromě rozšíření instrukční
sady &bdquo;M&ldquo; a &bdquo;F&ldquo; jsou specifikována i další rozšíření,
která mohou (ale nemusí) být na čipech RISC-V podporována. Jedná se především o
rozšíření &bdquo;D&ldquo;, v&nbsp;němž jsou definovány instrukce provádějící
operace s&nbsp;numerickými hodnotami s&nbsp;dvojnásobnou přesností
(<i>double</i>), dále pak o rozšíření &bdquo;Q&ldquo; pro operace
s&nbsp;numerickými hodnotami s&nbsp;přesností čtyřnásobnou (<i>quadruple</i>) a
taktéž o rozšíření &bdquo;A&ldquo; s&nbsp;atomickými instrukcemi
(resp.&nbsp;přesněji řečeno s&nbsp;instrukcemi, s&nbsp;jejichž využitím lze
některé atomické operace provést, což je velmi důležitá vlastnost
v&nbsp;případě použití většího množství paralelně běžících procesorových
jader). Zapomenout nesmíme ani na sadu pojmenovanou <i>RV64I</i>
s&nbsp;instrukcemi s&nbsp;64bitovými operandy (64bitovými pracovními registry)
a taktéž na prozatím neoficiální sadu &bdquo;C&ldquo; s&nbsp;komprimovanými
instrukcemi, které se vzdáleně podobají sadě Thumb známé z&nbsp;mikroprocesorů
s&nbsp;architekturou ARM. Právě touto problematikou se budeme zabývat
v&nbsp;dnešním článku.</p>



<p><a name="k02"></a></p>
<h2 id="k02">2. Dokončení popisu rozšíření instrukční sady &bdquo;F&ldquo;</h2>

<p>Před popisem dalších rozšíření instrukčních sad nejprve dokončeme popis
rozšířené instrukční sady označené písmenem &bdquo;F&ldquo;, jemuž jsme se
věnovali minule. Připomeňme si, že se jedná o instrukce určené pro provádění
operací s&nbsp;numerickými hodnotami s&nbsp;plovoucí řádovou čárkou
s&nbsp;jednoduchou přesností (<i>single/float</i>). Jak tyto operace, tak i
formát čísel je specifikován ve známé normě <i>IEEE 754</i>, která se
v&nbsp;roce 2008 dočkala své úpravy a zpřesnění. Právě této upravené normě
odpovídají i instrukce v&nbsp;rozšíření &bdquo;F&ldquo;. Vzhledem k&nbsp;tomu,
že se počítá s&nbsp;existencí matematického koprocesoru pracujícího
v&nbsp;ideálním případě paralelně s&nbsp;hlavním CPU, využívá se i oddělená
sada pracovních registrů, které jsou pojmenovány <strong>f0</strong> až
<strong>f31</strong>. Každý z&nbsp;těchto registrů má šířku 32 bitů, což přesně
odpovídá požadavkům datových typů <i>single/float</i>. Navíc se u většiny
operací používá i stavový a řídicí registr nazvaný <strong>fcrs</strong>.
K&nbsp;dispozici jsou pseudoinstrukce <strong>FRCSR</strong> a
<strong>FSCSR</strong> sloužící pro přenos obsahu stavového a řídicího registru
do libovolného pracovního registru celočíselné části mikroprocesoru
(<strong>R</strong>=Read, <strong>S</strong>=Store).</p>

<p>Minule jsme si již popsali i většinu instrukcí podporovaných tímto
matematickým koprocesorem. Zejména se jednalo o následující instrukce
(vynechávám jen některé instrukce určené pro přenos dat, které popsané
níže):</p>

<table>
<tr><th> #</th><th>Instrukce</th><th>Význam</th></tr>
<tr><td> 1</td><td>FLW</td><td>načtení FP hodnoty z&nbsp;paměti (adresa rs+offset)</td></tr>
<tr><td> 2</td><td>FSW</td><td>uložení FP hodnoty do paměti (adresa rs+offset)</td></tr>
<tr><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td></tr>
<tr><td> 3</td><td>FADD.S</td><td>součet dvou FP hodnot (tříadresový kód)</td></tr>
<tr><td> 4</td><td>FSUB.S</td><td>rozdíl dvou FP hodnot</td></tr>
<tr><td> 5</td><td>FMUL.S</td><td>součin dvou FP hodnot</td></tr>
<tr><td> 6</td><td>FDIV.S</td><td>podíl dvou FP hodnot</td></tr>
<tr><td> 7</td><td>FMIN.S</td><td>vrací menší z&nbsp;obou FP hodnot</td></tr>
<tr><td> 8</td><td>FMAX.S</td><td>vrací větší z&nbsp;obou FP hodnot</td></tr>
<tr><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td></tr>
<tr><td> 9</td><td>FSQRT.S</td><td>druhá odmocnina (použity jsou jen dva registry)</td></tr>
<tr><td>10</td><td>FMADD.S</td><td>rs1&times;rs2+rs3 (multiply-add, čtyřadresový kód!)</td></tr>
<tr><td>11</td><td>FMSUB.S</td><td>rs1&times;rs2-rs3</td></tr>
<tr><td>12</td><td>FNMADD.S</td><td>-(rs1&times;rs2+rs3)</td></tr>
<tr><td>13</td><td>FNMSUB.S</td><td>-(rs1&times;rs2-rs3)</td></tr>
<tr><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td></tr>
<tr><td>14</td><td>FLT.S</td><td>porovnání dvou FP hodnot, zápis 0 či 1 do integer registru</td></tr>
<tr><td>15</td><td>FLE.S</td><td>porovnání dvou FP hodnot, zápis 0 či 1 do integer registru</td></tr>
<tr><td>16</td><td>FEQ.S</td><td>porovnání dvou FP hodnot, zápis 0 či 1 do integer registru</td></tr>
<tr><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td></tr>
<tr><td>17</td><td>FCLASS</td><td>zjistí &bdquo;třídu&ldquo; FP hodnoty a nastaví deset bitů podle následující tabulky</td></tr>
</table>



<p><a name="k03"></a></p>
<h2 id="k03">3. Instrukce určené pro modifikaci znaménka výsledku</h2>

<p>Mezi další instrukce provádějících operace s&nbsp;hodnotami s&nbsp;plovoucí
řádovou čárkou, které jsme si doposud nepopsali, patří především operace
sloužící pro manipulaci se znaménkem výsledku. Tyto operace lze použít
k&nbsp;mnoha účelům, typicky pro implementaci výpočtu absolutní hodnoty, negaci
výsledku, popř.&nbsp;jen pro pouhý přesun dat atd. Všechny tři dále popsané
instrukce mají ve svém slovu místo pro určení indexů dvou zdrojových registrů
<i>src1</i>, <i>src2</i> a jednoho registru cílového <i>dest</i>:</p>

<table>
<tr><th>#</th><th>Instrukce</th><th>Význam</th></tr>
<tr><td>1</td><td>FSGNJ.S </td><td>kopie z&nbsp;registru <i>src1</i> do <i>dest</i>, ovšem kromě znaménka; to je přečteno ze <i>src2</i></td></tr>
<tr><td>2</td><td>FSGNJN.S</td><td>kopie z&nbsp;registru <i>src1</i> do <i>dest</i>, ovšem kromě znaménka; to je přečteno ze <i>src2</i> a znegováno</td></tr>
<tr><td>3</td><td>FSGNJX.S</td><td>kopie z&nbsp;registru <i>src1</i> do <i>dest</i>, ovšem kromě znaménka; to je získáno ze <i>src1</i> i <i>src2</i> s&nbsp;využitím operace XOR</td></tr>
</table>

<p>Některé kombinace zdrojových registrů a cílového registru vedou
k&nbsp;provedení operace, která má vlastní pseudoinstrukci (jen alias využívaný
v&nbsp;assembleru):</p>

<table>
<tr><th>Instrukce</th><th>Pseudoinstrukce</th><th>Význam</th></tr>
<tr><td>FSGNJ.S  rx, ry, ry</td><td>FMV.S  rx, ry</td><td>přesun dat (oba zdrojové registry jsou totožné)</td></tr>
<tr><td>FSGNJN.S rx, ry, ry</td><td>FNEG.S rx, ry</td><td>přesun dat s&nbsp;negací</td></tr>
<tr><td>FSGNJX.S rx, ry, ry</td><td>FABS,S rx, ry</td><td>výpočet absolutní hodnoty (XOR stejné hodnoty se vždy rovná nule)</td></tr>
</table>



<p><a name="k04"></a></p>
<h2 id="k04">4. Rozdíl mezi konverzí FP hodnoty na celé číslo a kopií bitového vzorku</h2>

<p>Vraťme se ještě na chvíli k&nbsp;instrukcím, které slouží pro přesuny dat
mezi registry hlavního mikroprocesoru (tj.&nbsp;mezi celočíselnými registry) a
mezi registry procesoru matematického. V&nbsp;případě hlavního mikroprocesoru
má programátor k&nbsp;dispozici celkem 31 registrů pojmenovaných
<strong>x1</strong> až <strong>x31</strong> doplněných o &bdquo;konstantní
nulu&ldquo; reprezentovanou registrem <strong>x0</strong>. Matematický
koprocesor má registry pojmenované <strong>f0</strong> až <strong>f31</strong>.
Existují celkem dva typy instrukcí zajišťujících přesuny dat. Prvním typem jsou
konverzní instrukce <strong>FCVT</strong> doplněné o typ konvertovaných dat (W
&ndash; 32bitové slovo se znaménkem, WU &ndash; 32bitové slovo bez znaménka, S
&ndash; single) a samozřejmě i o směr konverze. Druhým typem jsou instrukce
provádějící bitové kopie dat bez jakékoli konverze. Tyto instrukce (jsou dvě)
se jmenují <strong>FMV</strong>:</p>

<table>
<tr><th>#</th><th>Instrukce</th><th>Význam</th></tr>
<tr><td>1</td><td>FCVT.W.S</td><td>převod FP na integer</td></tr>
<tr><td>2</td><td>FCVT.S.W</td><td>převod integer na FP</td></tr>
<tr><td>3</td><td>FCVT.WU.S</td><td>převod FP na unsigned integer</td></tr>
<tr><td>4</td><td>FCVT.S.WU</td><td>převod unsigned integer na FP</td></tr>
<tr><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td></tr>
<tr><td>5</td><td>FMV.X.S</td><td>pouze přesun mezi integer registrem a FP registrem (nikoli konverze)</td></tr>
<tr><td>6</td><td>FMV.S.X</td><td>pouze přesun mezi FP registrem a integer registrem (nikoli konverze)</td></tr>
</table>

<p>Konverzní instrukce zhruba odpovídají konverzím dat v&nbsp;jazyku C:</p>

<pre>
float f = fooBarBaz(...);
int   i = (int) f;
</pre>

<p>Bitové kopie se dají provést například s&nbsp;využitím unií (i když to
přesně neodpovídá specifikaci):</p>

<pre>
union {
    int   i;
    float f;
} converter;
&nbsp;
converter.f = 3.1415f;
int x = converter.i;
</pre>



<p><a name="k05"></a></p>
<h2 id="k05">5. Rozšíření instrukční sady &bdquo;D&ldquo; &ndash; podpora pro hodnoty s&nbsp;dvojitou přesností</h2>

<p>Další rozšíření základní instrukční sady nese označení &bdquo;D&ldquo;,
takže asi nebude velkým překvapením, že tato rozšiřující instrukční sada slouží
pro provádění operací s&nbsp;numerickými hodnotami s&nbsp;dvojitou přesností
(typ <i>double</i>), což jsou opět operace specifikované v&nbsp;normě IEEE 754.
Pokud mikroprocesor s&nbsp;architekturou RISC-V podporuje tuto instrukční sadu,
budou použity registry pojmenované <strong>f0</strong> až <strong>f31</strong>,
což jsou stejně pojmenované registry, jaké již známe z&nbsp;rozšíření
&bdquo;F&ldquo;. Je zde ovšem jeden podstatný rozdíl &ndash; nyní budou mít
registry šířku 64 bitů a nikoli pouze 32 bitů. I instrukční sady
&bdquo;F&ldquo; a &bdquo;D&ldquo; jsou si v&nbsp;mnoha ohledech podobné, i když
zde narazíme na některé pochopitelné rozdíly. Především došlo k&nbsp;přidání
dvou nových instrukcí sloužících pro načtení resp.&nbsp;pro uložení numerické
hodnoty do paměti:</p>

<table>
<tr><th>#</th><th>Instrukce</th><th>Význam</th></tr>
<tr><td>1</td><td>FLD</td><td>načtení FP hodnoty z&nbsp;paměti (adresa rs+offset)</td></tr>
<tr><td>2</td><td>FSD</td><td>uložení FP hodnoty do paměti (adresa rs+offset)</td></tr>
</table>

<p>Je zřejmé, že tyto instrukce jsou obdobou původních 32bitových instrukcí
<strong>FLW</strong> a <strong>FSW</strong>.</p>

<p>Základní aritmetické operace jsou prakticky stejné, pouze mají odlišný
postfix:</p>

<table>
<tr><th>#</th><th>Instrukce</th><th>Význam</th></tr>
<tr><td>1</td><td>FADD.D</td><td>součet dvou FP hodnot (tříadresový kód)</td></tr>
<tr><td>2</td><td>FSUB.D</td><td>rozdíl dvou FP hodnot</td></tr>
<tr><td>3</td><td>FMUL.D</td><td>součin dvou FP hodnot</td></tr>
<tr><td>4</td><td>FDIV.D</td><td>podíl dvou FP hodnot</td></tr>
<tr><td>5</td><td>FMIN.D</td><td>vrací menší z&nbsp;obou FP hodnot</td></tr>
<tr><td>6</td><td>FMAX.D</td><td>vrací větší z&nbsp;obou FP hodnot</td></tr>
<tr><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td></tr>
<tr><td>7</td><td>FSQRT.D</td><td>druhá odmocnina (použity jsou jen dva registry)</td></tr>
</table>

<p>Dále jsou definovány konverzní operace mezi hodnotami s&nbsp;jednoduchou
přesností a přesností dvojitou:</p>

<table>
<tr><th>#</th><th>Instrukce</th><th>Význam</th></tr>
<tr><td>1</td><td>FCVT.S.D</td><td>double na single (provádí se zaokrouhlení)</td></tr>
<tr><td>2</td><td>FCVT.D.S</td><td>single na double (hodnota se nezmění)</td></tr>
</table>

<p>Zapomenout nesmíme ani na konverzi mezi hodnotami typu <i>integer</i> a
<i>double</i>, ovšem některé konverze lze provádět pouze na 64bitových
procesorech s&nbsp;instrukční sadou <i>RV64I</i> (už jen z&nbsp;toho důvodu, že
na 32bitových procesorech nejsou k&nbsp;dispozici dostatečně široké pracovní
registry):</p>

<table>
<tr><th>#</th><th>Instrukce</th><th>Význam</th></tr>
<tr><td>1</td><td>FCVT.W.D</td><td>double &rarr; 32bit signed integer</td></tr>
<tr><td>2</td><td>FCVT.L.D</td><td>double &rarr; 64bit signed integer</td></tr>
<tr><td>3</td><td>FCVT.WU.D</td><td>double &rarr; 32bit unsigned integer</td></tr>
<tr><td>4</td><td>FCVT.LU.D</td><td>double &rarr; 64bit unsigned integer</td></tr>
<tr><td>5</td><td>FCVT.D.W</td><td>32bit signed integer &rarr; double</td></tr>
<tr><td>6</td><td>FCVT.D.L</td><td>64bit signed integer &rarr; double</td></tr>
<tr><td>7</td><td>FCVT.D.WU</td><td>32bit unsigned integer &rarr; double</td></tr>
<tr><td>8</td><td>FCVT.D.LU</td><td>64bit unsigned integer &rarr; double</td></tr>
</table>

<p>I instrukce pro práci se znaménky mají svoji 64bitovou obdobu:</p>

<table>
<tr><th>#</th><th>Instrukce</th><th>Význam</th></tr>
<tr><td>1</td><td>FSGNJ.D </td><td>kopie z&nbsp;registru <i>src1</i> do <i>dest</i>, ovšem kromě znaménka; to je přečteno ze <i>src2</i></td></tr>
<tr><td>2</td><td>FSGNJN.D</td><td>kopie z&nbsp;registru <i>src1</i> do <i>dest</i>, ovšem kromě znaménka; to je přečteno ze <i>src2</i> a znegováno</td></tr>
<tr><td>3</td><td>FSGNJX.D</td><td>kopie z&nbsp;registru <i>src1</i> do <i>dest</i>, ovšem kromě znaménka; to je získáno ze <i>src1</i> i <i>src2</i> s&nbsp;využitím operace XOR</td></tr>
</table>

<p>Stejně jako přesuny bitové kopie mezi celočíselným registrem a FP registrem
(opět platí pouze pro 64bitovou instrukční sadu):</p>

<table>
<tr><th>#</th><th>Instrukce</th><th>Význam</th></tr>
<tr><td>1</td><td>FMV.X.D</td><td>pouze přesun mezi integer registrem a FP registrem (nikoli konverze)</td></tr>
<tr><td>1</td><td>FMV.D.X</td><td>pouze přesun mezi FP registrem a integer registrem (nikoli konverze)</td></tr>
</table>



<p><a name="k06"></a></p>
<h2 id="k06">6. Rozšíření instrukční sady &bdquo;Q&ldquo; &ndash; podpora pro hodnoty se čtyřnásobnou přesností</h2>

<p>Dalším rozšířením instrukčních sad je rozšíření označené písmenem
&bdquo;Q&ldquo;. To přidává možnost práce s&nbsp;numerickými hodnotami
s&nbsp;plovoucí řádovou čárkou se čtyřnásobnou přesností. Formát uložení těchto
hodnot je specifikován v&nbsp;již několikrát zmíněné normě <i>IEEE
754-2008</i>. Ostatně podívejme se na následující tabulku, v&nbsp;níž jsou
vypsány vybrané formáty numerických hodnot, které jsou v&nbsp;této normě
specifikovány (vynechávám takzvané &bdquo;decimální&ldquo; formáty) a jak se
tyto formáty mapují na rozšířené instrukční sady mikroprocesorů RISC-V:</p>

<table>
<tr><th>Oficiální jméno</th><th>Známo též jako</th><th>Znaménko</th><th>Exponent</th><th>Mantisa</th><th>Celkem</th><th>Decimálních číslic</th><th>RISV-5</th></tr>
<tr><td>binary16 </td><td>half        </td><td>1</td><td> 5b</td><td>10b</td><td>16b</td><td>cca 3,3</td><td>není</td></tr>
<tr><td>binary32 </td><td>single/float</td><td>1</td><td> 8b</td><td>23b</td><td>32b</td><td>cca 7,2</td><td>&bdquo;F&ldquo;</td></tr>
<tr><td>binary64 </td><td>double      </td><td>1</td><td>11b</td><td>52b</td><td>64b</td><td>cca 15,9</td><td>&bdquo;D&ldquo;</td></tr>
<tr><td>binary128</td><td>quadruple   </td><td>1</td><td>15b</td><td>112b</td><td>128b</td><td>cca 34,0</td><td>&bdquo;Q&ldquo;</td></tr>
</table>

<p>Jak je z&nbsp;této tabulky patrné, tak &ndash; alespoň prozatím &ndash; není
podporován první formát, což je trošku škoda, protože při zpracování signálů i
v&nbsp;počítačové grafice tento formát nalezl své uplatnění.</p>

<p>Rozšíření &bdquo;Q&ldquo; lze implementovat jen na 64bitových
mikroprocesorech s&nbsp;instrukční sadou <i>RV64I</i>, které navíc podporují
jak rozšíření &bdquo;F&ldquo;, tak i rozšíření &bdquo;D&ldquo;. Opět došlo ke
zvětšení šířky FP registrů, a to na 128 bitů. Většina původních FP instrukcí
zůstala zachována, pouze se změnil jejich postfix určující typ zpracovávaných
numerických hodnot. Jediné instrukce, které byly odstraněny, jsou instrukce pro
bitovou kopii dat mezi celočíselným registrem a FP registrem (což je vlastně
pochopitelné), což znamená nutnost načítání a ukládání operandů přímo do
operační paměti. V&nbsp;instrukční sadě &bdquo;Q&ldquo; tedy neexistují tyto
dvě instrukce: <strong>FMV.X.Q</strong> a <strong>FMV.Q.X</strong>.</p>

<p>Nové instrukce pro načítání a ukládání operandů do operační paměti:</p>

<table>
<tr><th>#</th><th>Instrukce</th><th>Význam</th></tr>
<tr><td>1</td><td>FLQ</td><td>načtení FP hodnoty z&nbsp;paměti (adresa rs+offset)</td></tr>
<tr><td>2</td><td>FSQ</td><td>uložení FP hodnoty do paměti (adresa rs+offset)</td></tr>
</table>

<p>Základní aritmetické operace jsou (opět) prakticky stejné, pouze mají
odlišný postfix:</p>

<table>
<tr><th>#</th><th>Instrukce</th><th>Význam</th></tr>
<tr><td>1</td><td>FADD.Q</td><td>součet dvou FP hodnot (tříadresový kód)</td></tr>
<tr><td>2</td><td>FSUB.Q</td><td>rozdíl dvou FP hodnot</td></tr>
<tr><td>3</td><td>FMUL.Q</td><td>součin dvou FP hodnot</td></tr>
<tr><td>4</td><td>FDIV.Q</td><td>podíl dvou FP hodnot</td></tr>
<tr><td>5</td><td>FMIN.Q</td><td>vrací menší z&nbsp;obou FP hodnot</td></tr>
<tr><td>6</td><td>FMAX.Q</td><td>vrací větší z&nbsp;obou FP hodnot</td></tr>
<tr><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td></tr>
<tr><td>7</td><td>FSQRT.Q</td><td>druhá odmocnina (použity jsou jen dva registry)</td></tr>
</table>

<p>Konverze mezi typy <i>single</i>, <i>float</i> a <i>quadruple</i>:</p>

<table>
<tr><th>#</th><th>Instrukce</th><th>Význam</th></tr>
<tr><td>1</td><td>FCVT.S.Q</td><td>quadruple &rarr; single</td></tr>
<tr><td>2</td><td>FCVT.Q.S</td><td>single &rarr; quadruple</td></tr>
<tr><td>3</td><td>FCVT.D.Q</td><td>quadruple &rarr; double</td></tr>
<tr><td>4</td><td>FCVT.Q.D</td><td>double &rarr; quadruple</td></tr>
</table>

<p>Operace se znaménkem:</p>

<table>
<tr><th>#</th><th>Instrukce</th><th>Význam</th></tr>
<tr><td>1</td><td>FSGNJ.Q </td><td>kopie z&nbsp;registru <i>src1</i> do <i>dest</i>, ovšem kromě znaménka; to je přečteno ze <i>src2</i></td></tr>
<tr><td>2</td><td>FSGNJN.Q</td><td>kopie z&nbsp;registru <i>src1</i> do <i>dest</i>, ovšem kromě znaménka; to je přečteno ze <i>src2</i> a znegováno</td></tr>
<tr><td>3</td><td>FSGNJX.Q</td><td>kopie z&nbsp;registru <i>src1</i> do <i>dest</i>, ovšem kromě znaménka; to je získáno ze <i>src1</i> i <i>src2</i> s&nbsp;využitím operace XOR</td></tr>
</table>



<p><a name="k07"></a></p>
<h2 id="k07">7. Rozšíření instrukční sady &bdquo;A&ldquo; &ndash; podpora pro atomické operace</h2>

<p>Pro čipy s&nbsp;větším počtem jader či pro potřeby multiprocesorových
systémů je určeno rozšíření instrukční sady &bdquo;A&ldquo; s&nbsp;podporou
atomických operací. Účelem instrukcí z&nbsp;rozšíření &bdquo;A&ldquo; je
zajištění kooperace mezi vlákny, a to ideálně bez nutnosti použití mutexů či
signálů pro zamčení celé sběrnice (<i>lock</i>). Některé z&nbsp;dále popsaných
instrukcí mají svou obdobu v&nbsp;instrukčních sadách MIPS, PowerPC, Alpha či
ARM. Mezi dvě základní instrukce patří instrukce typu <i>Load-Reserved</i>
(korektněji load and reserve) a <i>Store-Conditional</i>. Instrukce typu
<i>Load-Reserved</i> slouží pro načtení slova z&nbsp;operační paměti
z&nbsp;adresy uložené ve zdrojovém registru, uložení načtených dat do cílového
registru a současně i &bdquo;rezervace&ldquo; tohoto místa v&nbsp;paměti pro
aktivní vlákno. Naproti tomu instrukce <i>Store-Conditional</i> provede zápis
do paměti na určenou adresu, pokud je slovo (adresa) rezervováno (+ zrušení
rezervace). Podle výsledku této operace se do cílového registru zapíše hodnota
0 či 1, kterou lze snadno otestovat například pomocí instrukce BEQ.</p>

<p>Důležité je, že <i>Store-Conditional</i> správně rozpozná zápis do dané
lokace jiným vláknem, takže zde nenastane ABA problém, kdy cizí vlákno zapíše
jinou hodnotu, kterou následně přepíše na hodnotu původní (může se jednat
například o dvojí negaci). Naproti tomu &bdquo;alternativní &ldquo;operace typu
CAS/compare-and-swap tento stav rozpoznat nedokáže.</p>

<p>U obou zmíněných operací se ještě nastavují dva řídicí bity pojmenované
&bdquo;aq&ldquo; a &bdquo;rl&ldquo;. Nastavení bitu &bdquo;aq&ldquo; na hodnotu
1 zajistí, že žádné další operace s&nbsp;pamětí probíhající v&nbsp;aktivním
vláknu nebudou viditelné před &bdquo;aq&ldquo; operací (či naopak: efekt
&bdquo;aq&ldquo; operace bude viditelný před všemi následujícími operacemi
s&nbsp;pamětí). Bit &bdquo;aq&ldquo; tedy ovlivňuje chování budoucích operací.
Naproti tomu nastavení bitu &bdquo;rl&ldquo; zajistí, že všechny předchozí
operace budou viditelné před &bdquo;rl&ldquo; operací, ovlivňuje se tedy
chování minulých operací. Samozřejmě lze nastavit i oba bity
(&bdquo;aq&ldquo;==1, &bdquo;rl&ldquo;==1), takové operace jsou sekvenčně
konzistentní.</p>

<p>Poznámka: při kooperaci mezi více CPU nás skutečně zajímá jen obsah operační
paměti (viditelný dalšími CPU), nikoli stav pracovních registrů.</p>



<p><a name="k08"></a></p>
<h2 id="k08">8. AMO: Atomic Memory Operation</h2>

<p>V&nbsp;instrukční sadě &bdquo;A&ldquo; nalezneme i několik instrukcí
označovaných zkratkou <i>AMO</i> neboli <i>Atomic Memory Operation</i>. Jedná
se o operace typu read-modify-write, tj.&nbsp;o operace, které načtou hodnotu
z&nbsp;paměti, nějak ji modifikují a následně ji znovu uloží do paměti. Všechny
<i>AMO</i> instrukce používají tříadresový kód, což konkrétně znamená, že se
v&nbsp;instrukčním slově nachází indexy tří registrů <i>rs1</i>, <i>rs2</i> a
<i>rd</i>. Každá <i>AMO</i> operace se skládá ze tří částí:</p>

<ol>
<li>Načtení slova z&nbsp;adresy uložené v&nbsp;registru <i>rs1</i>.</li>
<li>Uložení této hodnoty do registru <i>rd</i>.</li>
<li>Aplikace zvolené operace s&nbsp;načtenou hodnotou a hodnotou z&nbsp;registru <i>rs2</i>.</li>
<li>Uložení výsledku zpět do paměti na adresu uložené v&nbsp;registru <i>rs1</i>.</li>
</ol>

<p>Mezi podporované operace patří:</p>

<table>
<tr><th>#</th><th>Operace</th></tr>
<tr><td>1</td><td>SWAP</td></tr>
<tr><td>2</td><td>ADD</td></tr>
<tr><td>3</td><td>AND</td></tr>
<tr><td>4</td><td>OR</td></tr>
<tr><td>5</td><td>XOR</td></tr>
<tr><td>6</td><td>MAX</td></tr>
<tr><td>7</td><td>MIN</td></tr>
</table>

<p>Některé kombinace registrů jsou podporovány i v&nbsp;pseudoinstrukcích (aliasech):</p>

<pre>
<strong>AMOADD</strong> pro load (s využitím registru x0)
<strong>AMOSWAP</strong> pro store (výsledek se uloží do registru x0)
</pre>



<p><a name="k09"></a></p>
<h2 id="k09">9. 64bitová instrukční sada RV64I</h2>

<p>Kromě základní 32bitové instrukční sady <i>RV32I</i> je specifikována i
64bitová instrukční sada <i>RV64I</i>. Instrukce specifikované v&nbsp;této sadě
pracují se 64bitovými operandy, i když šířka operačních kódů instrukcí zůstává
nastavena na 32. V&nbsp;rámci <i>RV64I</i> je definováno patnáct nových
instrukcí resp.&nbsp;úprav již existujících instrukcí:</p>

<table>
<tr><th> #</th><th>Instrukce</th></tr>
<tr><td> 1</td><td>LWU  rd,rs1,imm</td></tr>
<tr><td> 2</td><td>LD   rd,rs1,imm</td></tr>
<tr><td> 3</td><td>SD   rs1,rs2,imm</td></tr>
<tr><td>&nbsp;</td><td>&nbsp;</td></tr>
<tr><td> 4</td><td>SLLI rd,rs1,shamt</td></tr>
<tr><td> 5</td><td>SRLI rd,rs1,shamt</td></tr>
<tr><td> 6</td><td>SRAI rd,rs1,shamt</td></tr>
<tr><td>&nbsp;</td><td>&nbsp;</td></tr>
<tr><td> 7</td><td>ADDIW rd,rs1,imm</td></tr>
<tr><td>&nbsp;</td><td>&nbsp;</td></tr>
<tr><td> 8</td><td>SLLIW rd,rs1,shamt</td></tr>
<tr><td> 9</td><td>SRLIW rd,rs1,shamt</td></tr>
<tr><td>10</td><td>SRAIW rd,rs1,shamt</td></tr>
<tr><td>11</td><td>ADDW rd,rs1,rs2</td></tr>
<tr><td>12</td><td>SUBW rd,rs1,rs2</td></tr>
<tr><td>13</td><td>SLLW rd,rs1,rs2</td></tr>
<tr><td>14</td><td>SRLW rd,rs1,rs2</td></tr>
<tr><td>15</td><td>SRAW rd,rs1,rs2</td></tr>
</table>

<p>Většina instrukcí z&nbsp;výše uvedené tabulky má suffix <strong>W</strong>
značící, že tyto instrukce pracují s&nbsp;32bitovými hodnotami (ignoruje se
horních 32bitů pracovních registrů a výsledek je 32bitová hodnota se
znaménkem), zatímco všechny původní instrukce pracují s&nbsp;hodnotami
64bitovými.</p>

<p>Pojďme si jednotlivé instrukce z&nbsp;horní tabulky popsat podrobněji.</p>

<p>Instrukce typu Load a Store:</p>

<table>
<tr><th>Instrukce</th><th>Význam</th></tr>
<tr><td>LWU  rd,rs1,imm</td><td>načtení slova a jeho rozšíření na 64 bitů nulami (rozdíl oproti LW)</td></tr>
<tr><td>(LW  rd,rs1,imm)</td><td>načtení slova a jeho znaménkové rozšíření na 64 bitů (rozdíl oproti LWU)</td></tr>
<tr><td>LD   rd,rs1,imm</td><td>načtení 64bitového slova z&nbsp;paměti</td></tr>
<tr><td>SD   rs1,rs2,imm</td><td>zápis 64bitového slova do paměti</td></tr>
</table>

<p>64bitové posuny a rotace:</p>

<table>
<tr><th>Instrukce</th><th>Význam</th></tr>
<tr><td>SLLI rd,rs1,shamt</td><td>počet bitů posunu je uložen v&nbsp;6 bitech (původně dostačovalo v&nbsp;pěti)</td></tr>
<tr><td>SRLI rd,rs1,shamt</td><td>počet bitů posunu je uložen v&nbsp;6 bitech (původně dostačovalo v&nbsp;pěti)</td></tr>
<tr><td>SRAI rd,rs1,shamt</td><td>počet bitů posunu je uložen v&nbsp;6 bitech (původně dostačovalo v&nbsp;pěti)</td></tr>
</table>

<p>32bitové posuny a rotace:</p>

<table>
<tr><th>Instrukce</th><th>Význam</th></tr>
<tr><td>SLLW rd,rs1,rs2</td><td>posun v&nbsp;rámci spodních 32bitů</td></tr>
<tr><td>SRLW rd,rs1,rs2</td><td>posun v&nbsp;rámci spodních 32bitů</td></tr>
<tr><td>SRAW rd,rs1,rs2</td><td>posun v&nbsp;rámci spodních 32bitů</td></tr>
<tr><td>SLLIW rd,rs1,shamt</td><td>posun v&nbsp;rámci spodních 32bitů</td></tr>
<tr><td>SRLIW rd,rs1,shamt</td><td>posun v&nbsp;rámci spodních 32bitů</td></tr>
<tr><td>SRAIW rd,rs1,shamt</td><td>posun v&nbsp;rámci spodních 32bitů</td></tr>
</table>

<p>Aritmetické operace s&nbsp;operandy uloženými v&nbsp;registrech:</p>

<table>
<tr><th>Instrukce</th><th>Význam</th></tr>
<tr><td>ADDW rd,rs1,rs2</td><td>výpočet pouze v&nbsp;dolních 32 bitech bez přetečení</td></tr>
<tr><td>SUBW rd,rs1,rs2</td><td>výpočet pouze v&nbsp;dolních 32 bitech bez přetečení</td></tr>
</table>

<p>Aritmetické operace s&nbsp;konstantou:</p>

<table>
<tr><th>Instrukce</th><th>Význam</th></tr>
<tr><td>ADDIW rd,rs1,imm</td><td>přičtení 12bitové konstanty ke zdrojovému registru, 32bitový výsledek se uloží do registru cílového se znaménkovým rozšířením</td></tr>
</table>

<p>Tuto instrukci (<strong>ADDIW</strong>) je možné použít ke konverzi 32bit &rarr;, když se přičte 0.</p>



<p><a name="k10"></a></p>
<h2 id="k10">10. Neoficiální rozšíření instrukční sady &bdquo;C&ldquo; &ndash; komprimované instrukce</h2>

<p><i>"Leveraging 25 years of hindsight, RISC-V was designed to support
compressed instructions from the start, leaving enough opcode space for RVC and
many other extensions"</i></p>

<p>Tvůrci formátu instrukcí pro mikroprocesory <i>RISC-V</i> nezapomněli ani na
to, že se tato procesorová jádra budou s&nbsp;velkou pravděpodobností používat
mj.&nbsp;i v&nbsp;embedded systémech, kde se z&nbsp;různých důvodů (pomalá
paměť Flash, relativně malá kapacita instrukční cache apod.) preferuje mít
možnost vytvářet kód s&nbsp;větší hustotou, a to i za cenu menší výkonnosti
celého čipu. Pro tyto účely byla navržena prozatím neoficiální instrukční sada
&bdquo;C&ldquo; nazývaná též <i>RVC (RISC-V Compressed)</i> s&nbsp;instrukcemi
o šířce 16 bitů a nikoli 32 bitů. Tato instrukční sada byla vytvořena
s&nbsp;tím, že se bude jednat o doplněk ke stávajícím instrukčním sadám, nebude
tedy nutné provádět přepínání mezi různými režimy činnosti (na rozdíl od Thumb
atd.).</p>

<p>Designéři se tak poučili z&nbsp;některých problémů, které doprovázely
konkurenty, a to jak ARM (nutnost explicitního přepínání mezi A32 a Thumb,
opuštění této kombinace v&nbsp;AArch64) tak i x86_64 (komplikace mikroprocesoru
s&nbsp;instrukční sadou s&nbsp;instrukcemi proměnné délky). Podle soudobých
měření se zdá, že instrukční sada &bdquo;C&ldquo; může přinést zmenšení
strojového kódu o přibližně 25 až 30%, což dále vede ke snížení výpadků
instrukční cache o 20 až 25% (zde je ovšem nutné podotknout, že do značné míry
záleží na podpoře v&nbsp;překladačích a JIT, tato podpora stále není dokonalá,
takže lze předpokládat další zlepšení). Podrobnějším popisem této zajímavé
technologie se budeme zabývat příště.</p>



<p><a name="k11"></a></p>
<h2 id="k11">11. Odkazy na Internetu</h2>

<ol>

<li>An Introduction to Lock-Free Programming<br />
<a href="http://preshing.com/20120612/an-introduction-to-lock-free-programming/">http://preshing.com/20120612/an-introduction-to-lock-free-programming/</a>
</li>

<li>Sequential consistency<br />
<a href="https://en.wikipedia.org/wiki/Sequential_consistency">https://en.wikipedia.org/wiki/Sequential_consistency</a>
</li>

<li>Understanding Atomic Operations<br />
<a href="https://jfdube.wordpress.com/2011/11/30/understanding-atomic-operations/">https://jfdube.wordpress.com/2011/11/30/understanding-atomic-operations/</a>
</li>

<li>Load-link/store-conditional<br />
<a href="https://en.wikipedia.org/wiki/Load-link/store-conditional">https://en.wikipedia.org/wiki/Load-link/store-conditional</a>
</li>

<li>The RISC-V Compressed Instruction Set Manual<br />
<a href="http://riscv.org/spec/riscv-compressed-spec-v1.7.pdf">http://riscv.org/spec/riscv-compressed-spec-v1.7.pdf</a>
</li>

<li>Carry bits, The Architect's Trap<br />
<a href="http://yarchive.net/comp/carry_bit.html">http://yarchive.net/comp/carry_bit.html</a>
</li>

<li>Microprocessor Design/ALU Flags<br />
<a href="https://en.wikibooks.org/wiki/Microprocessor_Design/ALU_Flags">https://en.wikibooks.org/wiki/Microprocessor_Design/ALU_Flags</a>
</li>

<li>Flags register in an out-of-order processor<br />
<a href="http://cs.stackexchange.com/questions/42095/flags-register-in-an-out-of-order-processor">http://cs.stackexchange.com/questions/42095/flags-register-in-an-out-of-order-processor</a>
</li>

<li>AMD Am29000<br />
<a href="https://en.wikipedia.org/wiki/AMD_Am29000">https://en.wikipedia.org/wiki/AMD_Am29000</a>
</li>

<li>Status register<br />
<a href="https://en.wikipedia.org/wiki/Status_register">https://en.wikipedia.org/wiki/Status_register</a>
</li>

<li>AMD Am29000 microprocessor family<br />
<a href="http://www.cpu-world.com/CPUs/29000/">http://www.cpu-world.com/CPUs/29000/</a>
</li>

<li>AMD 29k (Streamlined Instruction Processor) ID Guide<br />
<a href="http://www.cpushack.com/Am29k.html">http://www.cpushack.com/Am29k.html</a>
</li>

<li>AMD Am29000 (Wikipedia)<br />
<a href="http://en.wikipedia.org/wiki/AMD_Am29000">http://en.wikipedia.org/wiki/AMD_Am29000</a>
</li>

<li>AMD K5 ("K5" / "5k86")<br />
<a href="http://www.pcguide.com/ref/cpu/fam/g5K5-c.html">http://www.pcguide.com/ref/cpu/fam/g5K5-c.html</a>
</li>

<li>Comparing four 32-bit soft processor cores<br />
<a href="http://www.eetimes.com/author.asp?section_id=14&doc_id=1286116">http://www.eetimes.com/author.asp?section_id=14&doc_id=1286116</a>
</li>

<li>RISC-V Instruction Set<br />
<a href="http://riscv.org/download.html#spec_compressed_isa">http://riscv.org/download.html#spec_compressed_isa</a>
</li>

<li>RISC-V Spike (ISA Simulator)<br />
<a href="http://riscv.org/download.html#isa-sim">http://riscv.org/download.html#isa-sim</a>
</li>

<li>RISC-V (Wikipedia)<br />
<a href="https://en.wikipedia.org/wiki/RISC-V">https://en.wikipedia.org/wiki/RISC-V</a>
</li>

<li>David Patterson (Wikipedia)<br />
<a href="https://en.wikipedia.org/wiki/David_Patterson_(computer_scientist)">https://en.wikipedia.org/wiki/David_Patterson_(computer_scientist)</a>
</li>

<li>OpenRISC (oficiální stránky projektu)<br />
<a href="http://openrisc.io/">http://openrisc.io/</a>
</li>

<li>OpenRISC architecture<br />
<a href="http://openrisc.io/architecture.html">http://openrisc.io/architecture.html</a>
</li>

<li>Emulátor OpenRISC CPU v JavaScriptu<br />
<a href="http://s-macke.github.io/jor1k/demos/main.html">http://s-macke.github.io/jor1k/demos/main.html</a>
</li>

<li>OpenRISC (Wikipedia)<br />
<a href="https://en.wikipedia.org/wiki/OpenRISC">https://en.wikipedia.org/wiki/OpenRISC</a>
</li>

<li>OpenRISC - instrukce<br />
<a href="http://sourceware.org/cgen/gen-doc/openrisc-insn.html">http://sourceware.org/cgen/gen-doc/openrisc-insn.html</a>
</li>

<li>OpenRISC - slajdy z&nbsp;přednášky o projektu<br />
<a href="https://iis.ee.ethz.ch/~gmichi/asocd/lecturenotes/Lecture6.pdf">https://iis.ee.ethz.ch/~gmichi/asocd/lecturenotes/Lecture6.pdf</a>
</li>

<li>Maska mikroprocesoru RISC 1<br />
<a href="http://www.cs.berkeley.edu/~pattrsn/Arch/RISC1.jpg">http://www.cs.berkeley.edu/~pattrsn/Arch/RISC1.jpg</a>
</li>

<li>Maska mikroprocesoru RISC 2<br />
<a href="http://www.cs.berkeley.edu/~pattrsn/Arch/RISC2.jpg">http://www.cs.berkeley.edu/~pattrsn/Arch/RISC2.jpg</a>
</li>

<li>C.E. Sequin and D.A.Patterson: Design and Implementation of RISC I<br />
<a href="http://www.eecs.berkeley.edu/Pubs/TechRpts/1982/CSD-82-106.pdf">http://www.eecs.berkeley.edu/Pubs/TechRpts/1982/CSD-82-106.pdf</a>
</li>

<li>Berkeley RISC<br />
<a href="http://en.wikipedia.org/wiki/Berkeley_RISC">http://en.wikipedia.org/wiki/Berkeley_RISC</a>
</li>

<li>Great moments in microprocessor history<br />
<a href="http://www.ibm.com/developerworks/library/pa-microhist.html">http://www.ibm.com/developerworks/library/pa-microhist.html</a>
</li>

<li>Microprogram-Based Processors<br />
<a href="http://research.microsoft.com/en-us/um/people/gbell/Computer_Structures_Principles_and_Examples/csp0167.htm">http://research.microsoft.com/en-us/um/people/gbell/Computer_Structures_Principles_and_Examples/csp0167.htm</a>
</li>

<li>Great Microprocessors of the Past and Present<br />
<a href="http://www.cpushack.com/CPU/cpu1.html">http://www.cpushack.com/CPU/cpu1.html</a>
</li>

<li>A Brief History of Microprogramming<br />
<a href="http://www.cs.clemson.edu/~mark/uprog.html">http://www.cs.clemson.edu/~mark/uprog.html</a>
</li>

<li>What is RISC?<br />
<a href="http://www-cs-faculty.stanford.edu/~eroberts/courses/soco/projects/2000-01/risc/whatis/">http://www-cs-faculty.stanford.edu/~eroberts/courses/soco/projects/2000-01/risc/whatis/</a>
</li>

<li>RISC vs. CISC<br />
<a href="http://www-cs-faculty.stanford.edu/~eroberts/courses/soco/projects/2000-01/risc/risccisc/">http://www-cs-faculty.stanford.edu/~eroberts/courses/soco/projects/2000-01/risc/risccisc/</a>
</li>

<li>RISC and CISC definitions:<br />
<a href="http://www.cpushack.com/CPU/cpuAppendA.html">http://www.cpushack.com/CPU/cpuAppendA.html</a>
</li>

<li>FPGA<br />
<a href="https://cs.wikipedia.org/wiki/Programovateln%C3%A9_hradlov%C3%A9_pole">https://cs.wikipedia.org/wiki/Programovateln%C3%A9_hradlov%C3%A9_pole</a>
</li>

<li>The Evolution of RISC<br />
<a href="http://www.ibm.com/developerworks/library/pa-microhist.html#sidebar1">http://www.ibm.com/developerworks/library/pa-microhist.html#sidebar1</a>
</li>

<li>SPARC Processor Family Photo<br />
<a href="http://thenetworkisthecomputer.com/site/?p=243">http://thenetworkisthecomputer.com/site/?p=243</a>
</li>

<li>SPARC: Decades of Continuous Technical Innovation<br />
<a href="http://blogs.oracle.com/ontherecord/entry/sparc_decades_of_continuous_technical">http://blogs.oracle.com/ontherecord/entry/sparc_decades_of_continuous_technical</a>
</li>

<li>The SPARC processors<br />
<a href="http://www.top500.org/2007_overview_recent_supercomputers/sparc_processors">http://www.top500.org/2007_overview_recent_supercomputers/sparc_processors</a>
</li>

<li>Reduced instruction set computing (Wikipedia)<br />
<a href="http://en.wikipedia.org/wiki/Reduced_instruction_set_computer">http://en.wikipedia.org/wiki/Reduced_instruction_set_computer</a>
</li>

<li>MIPS architecture (Wikipedia)<br />
<a href="http://en.wikipedia.org/wiki/MIPS_architecture">http://en.wikipedia.org/wiki/MIPS_architecture</a>
</li>

<li>Very long instruction word (Wikipedia)<br />
<a href="http://en.wikipedia.org/wiki/Very_long_instruction_word">http://en.wikipedia.org/wiki/Very_long_instruction_word</a>
</li>

<li>Classic RISC pipeline (Wikipedia)<br />
<a href="http://en.wikipedia.org/wiki/Classic_RISC_pipeline">http://en.wikipedia.org/wiki/Classic_RISC_pipeline</a>
</li>

<li>R2000 Microprocessor (Wikipedia)<br />
<a href="http://en.wikipedia.org/wiki/R2000_(microprocessor)">http://en.wikipedia.org/wiki/R2000_(microprocessor)</a>
</li>

<li>R3000 Microprocessor (Wikipedia)<br />
<a href="http://en.wikipedia.org/wiki/R3000">http://en.wikipedia.org/wiki/R3000</a>
</li>

<li>R4400 Microprocessor (Wikipedia)<br />
<a href="http://en.wikipedia.org/wiki/R4400">http://en.wikipedia.org/wiki/R4400</a>
</li>

<li>R8000 Microprocessor (Wikipedia)<br />
<a href="http://en.wikipedia.org/wiki/R8000">http://en.wikipedia.org/wiki/R8000</a>
</li>

<li>R10000 Microprocessor (Wikipedia)<br />
<a href="http://en.wikipedia.org/wiki/R10000">http://en.wikipedia.org/wiki/R10000</a>
</li>

<li>SPARC (Wikipedia)<br />
<a href="http://en.wikipedia.org/wiki/Sparc">http://en.wikipedia.org/wiki/Sparc</a>
</li>

<li>CPU design (Wikipedia)<br />
<a href="http://en.wikipedia.org/wiki/CPU_design">http://en.wikipedia.org/wiki/CPU_design</a>
</li>

<li>Control unit (Wikipedia)<br />
<a href="http://en.wikipedia.org/wiki/Control_unit">http://en.wikipedia.org/wiki/Control_unit</a>
</li>

</ol>



<p></p><p></p>
<p><small>Autor: <a href="http://www.fit.vutbr.cz/~tisnovpa">Pavel Tišnovský</a> &nbsp; 2015</small></p>
</body>
</html>

