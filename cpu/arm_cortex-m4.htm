<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
        "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html>
<head>
<title>Architektura mikrořadičů s jádry ARM Cortex-M4</title>
<meta name="Author" content="Pavel Tisnovsky" />
<meta name="Generator" content="vim" />
<meta http-equiv="content-type" content="text/html; charset=utf-8" />
<style type="text/css">
         body {color:#000000; background:#ffffff;}
         h1  {font-family: arial, helvetica, sans-serif; color:#ffffff; background-color:#c00000; text-align:center; padding-left:1em}
         h2  {font-family: arial, helvetica, sans-serif; color:#ffffff; background-color:#0000c0; padding-left:1em; text-align:left}
         h3  {font-family: arial, helvetica, sans-serif; color:#000000; background-color:#c0c0c0; padding-left:1em; text-align:left}
         h4  {font-family: arial, helvetica, sans-serif; color:#000000; background-color:#e0e0e0; padding-left:1em; text-align:left}
         a   {font-family: arial, helvetica, sans-serif;}
         li  {font-family: arial, helvetica, sans-serif; color:#000000; text-align:justify; width:450px;}
         ol  {font-family: arial, helvetica, sans-serif; color:#000000; text-align:justify; width:450px;}
         ul  {font-family: arial, helvetica, sans-serif; color:#000000; text-align:justify; width:450px;}
         p   {font-family: arial, helvetica, sans-serif; color:#000000; text-align:justify;}
         pre {background:#e0e0e0}
</style>
</head>

<body>

<h1>Architektura mikrořadičů s jádry ARM Cortex-M3</h1>

<h3>Pavel Tišnovský</h3>

<p></p>

<h1>Úvodník</h1>

<p>Čtvrtý článek o mikrořadičích založených na RISCových jádrech s architekturou ARM je věnován popisu jader řady Cortex-M4 a taktéž Cortex-M4F. Čipy obsahující tato jádra se některými svými vlastnostmi podobají již dříve popsaným jádrům Cortex-M3, ovšem ve skutečnosti mají jádra Cortex-M4 mnoho společného i s minule popsanými nejvýkonnějšími mikrořadiči Cortex-M7.</p>



<h2>Obsah</h2>

<p><a href="#k01">1. Architektura mikrořadičů s&nbsp;jádry ARM Cortex-M4</a></p>
<p><a href="#k02">2. Rozdíly mezi jádry Cortex-M</a></p>
<p><a href="#k03">3. Segmenty trhu, pro něž jsou jednotlivá jádra Cortex-M určena</a></p>
<p><a href="#k04">4. Nejdůležitější vlastnosti mikrořadičových jader Cortex-M4</a></p>
<p><a href="#k05">5. Instrukční sada jader Cortex-M4</a></p>
<p><a href="#k06">6. Základní instrukce</a></p>
<p><a href="#k07">7. Instrukce orientované na zpracování signálu</a></p>
<p><a href="#k08">8. Sčítání a odečítání se saturací</a></p>
<p><a href="#k09">9. Bitový příznak Q</a></p>
<p><a href="#k10">10. Násobička</a></p>
<p><a href="#k11">11. Jádra Cortex-M4F</a></p>
<p><a href="#k12">12. Operace podporované matematickým koprocesorem</a></p>
<p><a href="#k13">13. Operace ze standardu IEEE 754, které nejsou implementovány</a></p>
<p><a href="#k14">14. Odkazy na Internetu</a></p>



<p><a name="k01"></a></p>
<h2 id="k01">1. Architektura mikrořadičů s&nbsp;jádry ARM Cortex-M4</h2>

<p>V&nbsp;předchozí čtveřici článků o ARMovských (a tedy RISCových)
mikrořadičových jádrech <i>Cortex-M</i> jsme si již popsali vlastnosti
(v&nbsp;současnosti) nejmenších a energeticky nejméně náročných jader řady
<i>Cortex-M0</i> a <i>Cortex-M0+</i> [<a
href="http://www.root.cz/clanky/architektura-mikroradicu-s-jadry-arm-cortex-m0-a-arm-cortex-m0/">1</a>],
základní vlastnosti výkonnějších jader <i>Cortex-M3</i> [<a
href="http://www.root.cz/clanky/architektura-mikroradicu-s-jadry-arm-cortex-m3/">2</a>],
zabývali jsme se i nejvýkonnějšími jádry <i>Cortex-M7</i> [<a
href="http://www.root.cz/clanky/nejvykonnejsi-mcu-aneb-architektura-mikroradicu-s-jadry-arm-cortex-m7/">3</a>]
a dokonce jsme si i popsali, v&nbsp;jakých aplikačních oblastech a čipech se
tato mikroprocesorová jádra používají v&nbsp;praxi [<a
href="http://www.root.cz/clanky/pouziti-mikroradicu-s-jadrem-cortex-m-na-realnych-cipech/">4</a>].
Jediná dvě &bdquo;mikrořadičová&ldquo; jádra, kterými jsme se doposud
podrobněji nezabývali, jsou jádra řady <i>Cortex-M1</i>, která dnes nachází
uplatnění pouze v&nbsp;FPGA (a budeme se jimi zabývat v&nbsp;odlišně zaměřeném
seriálu) a taktéž jádra řady <i>Cortex-M4</i>, jejichž možnosti leží na pomezí
mezi řadou <i>Cortex-M3</i> a <i>Cortex-M7</i>.</p>

<p>V&nbsp;dnešním článku tedy téma mikrořadičových RISCových jader
<i>Cortex-M</i> uzavřeme, protože si popíšeme základní vlastnosti obvodů řady
<i>Cortex-M4</i> (jednodušší, levnější a energeticky méně náročná varianta) i
jader <i>Cortex-M4F</i> (pod tímto označením nalezneme mikrořadičová jádra
obsahující kromě celočíselné aritmeticko-logické jednotky i matematický
koprocesor zpracovávající numerické údaje ve formátu single/float). Tato jádra
se uplatní zejména v&nbsp;těch oblastech, kde se zpracovává číslicový signál,
protože na čipech s&nbsp;jádry <i>Cortex-M4</i> lze používat i instrukce pro
sčítání a odčítání se saturací, je zde použita rychlá násobička a
v&nbsp;případě potřeby lze zvolit mikrořadič obsahující již zmíněný matematický
koprocesor.</p>



<p><a name="k02"></a></p>
<h2 id="k02">2. Rozdíly mezi jádry Cortex-M</h2>

<p>Vzhledem k&nbsp;tomu, že v&nbsp;tomto článku dokončíme popis všech typů
procesorových (resp.&nbsp;přesněji řečeno mikrořadičových) jader
<i>Cortex-M</i>, nebude na škodu si zopakovat, čím se vlastně jednotlivá
&bdquo;emková&ldquo; jádra od sebe odlišují. Zaměříme se především na
vlastnosti samotných procesorových jednotek (CPU) a nikoli na vlastnosti
periferních zařízení, protože je logické, že například minimalistická jádra
<i>Cortex-M0</i> a <i>Cortex-M0+</i> budou v&nbsp;naprosté většině aplikací
vybavena jen relativně malým množstvím podpůrných jednotek v&nbsp;porovnání
s&nbsp;většími jádry <i>Cortex-M7</i>. V&nbsp;první tabulce jsou jednotlivá
jádra všech řad <i>Cortex-M</i> rozdělena podle toho, do jaké architektury ARM
spadají. Povšimněte si, že menší jádra používají starší, ale stále oblíbenou
architekturu ARMv6-M, zatímco ta nejvýkonnější jádra přešla na novější
architekturu ARMv7E-M. Na pomezí pak stojí minule popsaná jádra
<i>Cortex-M3</i> s&nbsp;architekturou ARMv7-M:</p>

<table>
<tr><th>#</th><th>Jádro (řada)</th><th>Architektura ARM</th><th>Architektura CPU/MCU</th></tr>
<tr><td>1</td><td>Cortex-M0 </td><td>ARMv6-M</td><td>Von Neumannova</td></tr>
<tr><td>2</td><td>Cortex-M0+</td><td>ARMv6-M</td><td>Von Neumannova</td></tr>
<tr><td>3</td><td>Cortex-M1 </td><td>ARMv6-M</td><td>Von Neumannova</td></tr>
<tr><td>4</td><td>Cortex-M3 </td><td>ARMv7-M</td><td>Harvardská</td></tr>
<tr><td>5</td><td>Cortex-M4 </td><td>ARMv7E-M</td><td>Harvardská</td></tr>
<tr><td>6</td><td>Cortex-M7 </td><td>ARMv7E-M</td><td>Harvardská</td></tr>
</table>
 
<p>Při pohledu na druhou tabulku se dozvíme, kolik řezů mají pipeline
v&nbsp;jednotlivých jádrech a taktéž kolik vstupů přerušení je možné maximálně
obsloužit. Na tomto místě stojí za připomenutí, že větší počet řezů
v&nbsp;RISCových procesorech na jednu stranu může zvýšit jejich výpočetní výkon
(zvětšení frekvence), na stranu druhou však zvětšuje plochu samotného CPU,
reakce na přerušení se musí řešit složitějším způsobem (u některých čipů
dosahuje latence reakce na přerušení až 12 cyklů) a taktéž se při špatné
predikci skoků může zhoršit celkový výkon. U jader <i>Cortex-M</i> je patrné,
že se designéři snažili o vybalancování všech veličin a vlastností (právě
z&nbsp;tohoto důvodu se například dnes namísto papírově výkonnějších jader
<i>Cortex-M0</i> používají jádra <i>Cortex-M0+</i> s&nbsp;jednodušší strukturou
pipeline):</p>

<table>
<tr><th>#</th><th>Jádro     </th><th>Pipeline</th><th>Přerušení</th></tr>
<tr><td>1</td><td>Cortex-M0 </td><td>3 řezy</td><td>1-32 + NMI</td></tr>
<tr><td>2</td><td>Cortex-M0+</td><td>2 řezy</td><td>1-32 + NMI</td></tr>
<tr><td>3</td><td>Cortex-M1 </td><td>3 řezy</td><td>1-32 + NMI</td></tr>
<tr><td>4</td><td>Cortex-M3 </td><td>3 řezy</td><td>1-240 + NMI</td></tr>
<tr><td>5</td><td>Cortex-M4 </td><td>3 řezy</td><td>1-240 + NMI</td></tr>
<tr><td>6</td><td>Cortex-M7 </td><td>6 řezů</td><td>1-240 + NMI</td></tr>
</table>
 
<p>V&nbsp;poslední tabulce jsou shrnuty vlastnosti instrukčních sad, které si
sice jsou v&nbsp;některých ohledech velmi podobné (například absencí původních
32bitových &bdquo;RISCových&ldquo; instrukcí ARM), ovšem je patrné, že některé
vlastnosti jsou dostupné až u větších, výkonnějších a nutno říci, že taktéž
energeticky náročnějších jader:</p>

<table>
<tr><th>#</th><th>Jádro     </th><th>Instrukční sada</th><th>HW násobička</th><th>HW dělička</th><th>Sat.ADD/SUB</th><th>DSP</th><th>FPU</th></tr>
<tr><td>1</td><td>Cortex-M0 </td><td>Thumb       </td><td>32bit   </td><td>ne </td><td>ne </td><td>ne </td><td>ne </td></tr>
<tr><td>2</td><td>Cortex-M0+</td><td>Thumb       </td><td>32bit   </td><td>ne </td><td>ne </td><td>ne </td><td>ne </td></tr>
<tr><td>3</td><td>Cortex-M1 </td><td>Thumb       </td><td>32bit   </td><td>ne </td><td>ne </td><td>ne </td><td>ne </td></tr>
<tr><td>4</td><td>Cortex-M3 </td><td>Thumb+Thumb2</td><td>32/64bit</td><td>ano</td><td>ano</td><td>ne </td><td>ne </td></tr>
<tr><td>5</td><td>Cortex-M4 </td><td>Thumb+Thumb2</td><td>32/64bit</td><td>ano</td><td>ano</td><td>ano</td><td>opt</td></tr>
<tr><td>6</td><td>Cortex-M7 </td><td>Thumb+Thumb2</td><td>32/64bit</td><td>ano</td><td>ano</td><td>ano</td><td>opt</td></tr>
</table>
 
<p>Poznámky k&nbsp;předchozí tabulce:</p>

<ul>
<li>Jádra Cortex-M0/M0+/M1 obsahují většinu instrukcí Thumb kromě trojice
instrukcí <strong>CBZ</strong>, <strong>CBNZ</strong> a prefixu
<strong>IT</strong>. Taktéž obsahují šest vybraných instrukcí ze sady
Thumb-2.</li>
<li>Ve sloupci &bdquo;HW násobička&ldquo; je napsáno, zda je výsledek násobení
dvou 32bitových čísel taktéž 32bitový (spodní polovina výsledku) či 64bitový. U
některých čipů lze zvolit, zda je násobička sériová (pomalý výpočet, malá
plocha čipu, malá spotřeba) či paralelní (rychlý výpočet, ovšem na úkor větší
plochy čipy a taktéž vyšší spotřeby).</li>
</ul>



<p><a name="k03"></a></p>
<h2 id="k03">3. Segmenty trhu, pro něž jsou jednotlivá jádra Cortex-M určena</h2>

<p>Typické použití mikrořadičových jader je zobrazeno na diagramu, který je
dostupný na adrese <a
href="http://www.arm.com/assets/images/tpl/compare-Cortex-M-diagramLG.png">http://www.arm.com/assets/images/tpl/compare-Cortex-M-diagramLG.png</a>.
Zkusme si toto rozdělení shrnout v&nbsp;několika větách:</p>

<ol>

<li>Jádro <i>Cortex-M0</i> tvoří základ pro čipy, u nichž je žádoucí dosáhnout
co nejnižší výrobní ceny, malých rozměrů a především pak malého příkonu
(s&nbsp;tím samozřejmě souvisí i příslušně nízký výpočetní výkon, ovšem možnost
dlouhodobě provozovat stále relativně výkonný čip z&nbsp;baterie je jistě
lákavá). Tato jádra by měla postupně nahrazovat některé aplikace, v&nbsp;nichž
se nyní používají osmibitové či šestnáctibitové mikrořadiče (PIC, řada 8051,
68HC11/68HC12 atd.). Malé plochy čipu se inženýrům ze společnosti ARM skutečně
podařilo dosáhnout, protože nejmenší vyráběný integrovaný obvod s&nbsp;jádrem
<i>Cortex-M0</i> má plochu přibližně 1,6&times;2 mm.</li>

<li>Na mikrořadiče s&nbsp;jádry <i>Cortex-M0+</i> se z&nbsp;pohledu
programátora můžeme dívat jako na pouhá vylepšení původních jader
<i>Cortex-M0</i>. Interně se ovšem jedná o odlišně navržená jádra, protože
<i>Cortex-M0+</i> obsahuje pipeline pouze se dvěma řezy a nikoli s&nbsp;řezy
třemi (vlastně se tak vracíme na samotný začátek platformy ARM, což však u
takto malých čipů má význam). Co je však pro případné uživatele důležitější
&ndash; i díky zmenšenému počtu řezů pipeline se podařilo dále snížit spotřebu
a přitom zachovat obousměrnou kompatibilitu s&nbsp;původními jádry
<i>Cortex-M0</i>.</li>

<li>Mezi základní cíl při návrhu jader <i>Cortex-M3</i> patřilo vytvoření CPU
s&nbsp;co nejmenší latencí, což znamená, že reakce na přerušení by měla
proběhnout ideálně v&nbsp;jediném taktu. Navíc měly mít tyto procesory či
mikrořadiče relativně dobrý výpočetní výkon, čehož bylo dosaženo hned několika
způsoby. Především mají jádra <i>Cortex-M3</i> Harvardskou architekturu
umožňující mj.&nbsp;provádět současné čtení další instrukce společně se čtením
či zápisem dat (zde ovšem závisí na konkrétním výrobci čipu, jak bude
koncipovat interní sběrnice připojené k&nbsp;pamětem, samotné jádro rozdělení
umožňuje). Dále je použita pipeline se třemi řezy (klasické RISCové fetch,
decode, execute) a nalezneme zde i modul určený pro dopředné čtení instrukcí
(<i>PFU &ndash; Prefetch Unit</i>) a další modul pro pozdržení zápisu jednoho
slova do datové paměti (ovšem pouze pro ty regiony paměti, které jsou označeny
příznakem &bdquo;bufferable&ldquo;, aby se zajistil okamžitý zápis do GPIO
apod.).</li>

<li>Mikrořadiče s&nbsp;jádry <i>Cortex-M4</i> jsou popsány <a
href="#k04">v&nbsp;navazující kapitole</a>.</li>

<li>Mikrořadičová jádra, která nesou označení <i>Cortex-M7</i>, jsou založena
na architektuře <i>ARMv7E-M</i>, na rozdíl od čipů <i>Cortex-M0/Cortex-M0+</i>
s&nbsp;jednodušší architekturou <i>ARMv6-M</i> či <i>Cortex-M3</i>
s&nbsp;architekturou <i>ARMv7-M</i>. Tato jádra jsou podporována paměťovým
subsystémem s&nbsp;cache i se zápisovým bufferem, používá se u nich matematický
koprocesor, který může podporovat jak operace s&nbsp;operandy typu
single/float, tak i s&nbsp;operandy typu double (což je v&nbsp;této aplikační
oblasti poněkud neobvyklé) a podporovány jsou samozřejmě i operace používané
při zpracování digitálního signálu, tj.&nbsp;například sčítání se saturací
apod.</li>

</ol>



<p><a name="k04"></a></p>
<h2 id="k04">4. Nejdůležitější vlastnosti mikrořadičových jader Cortex-M4</h2>

<p>Mikroprocesory a mikrořadiče s&nbsp;jádry <i>Cortex-M4</i> jsou určeny pro
ty aplikační oblasti, v&nbsp;nichž je vyžadováno zpracování digitálního signálu
(může se jednat o osmibitové, šestnáctibitové či dokonce o 32bitové vzorky)
popř.&nbsp;práce s&nbsp;daty uloženými v&nbsp;systému plovoucí řádové čárky
(float/single). V&nbsp;těchto oblastech totiž již možnosti menších jader
<i>Cortex-M3</i> přestávají stačit a na druhou stranu jádra <i>Cortex-M7</i>
mohou být zbytečně drahá a/nebo mít zbytečně velké energetické nároky. Pokud je
ovšem vyžadováno zpracování numerických hodnot typu double (tj.&nbsp;čísel
s&nbsp;plovoucí řádovou čárkou s&nbsp;takzvanou dvojitou přesností), je nutné
použít čipy s&nbsp;jádrem <i>Cortex-M7</i> nebo se spokojit se softwarovou
implementací všech operací s&nbsp;čísly typu double. Opět zde tedy můžeme vidět
snahu o vybalancování vlastností se spotřebou a cenou.</p>

<p>Mezi další vlastnosti Cortex-M4 patří:</p>

<ul>

<li>Podpora pro bit-banding, tj.&nbsp;pro přístup k&nbsp;jednotlivým bitům
jednoho či dvou regionů paměti. Jedná se o vylepšenou podporu Booleovského
procesoru známého z&nbsp;řady mikrořadičů Intel 8051 (které dnes vyrábí snad
prakticky všichni významní výrobci polovodičových součástek kromě Intelu
:-).</li>

<li>Volitelně je možné použít jednotku pro správu paměti (<i>MPU &ndash; Memory
Protection Unit</i>). Paměť může být rozdělena do regionů s&nbsp;volitelnými
právy přístupu (teoreticky tak lze realizovat i virtuální paměť, což však
v&nbsp;aplikační oblasti Cortex-M4 asi nemá význam).</li>

<li>Lze použít i write buffer (pro jedno zapisované slovo), čímž se zajistí, že
poslední řez pipeline nebude muset čekat na skutečný zápis dat do paměti.</li>

<li>Volitelně je k&nbsp;dispozici modul zajišťující použití konfigurovatelných
watchpointů (watchpoint jde dokonce nastavit i na časovač či PC).</li>

<li>Hned několik volitelných modulů je určeno pro ladění: ITM (rozhraní pro
připojení čipu k&nbsp;počítači, kde běží debugger), FPB (Flash path and
Breakpoint unit) a AHB-AP (zajišťuje ladicím prostředkům přístup do operační
paměti, k&nbsp;řídicím registrům a dokonce i k&nbsp;registrům samotného
CPU).</li>

</ul>



<p><a name="k05"></a></p>
<h2 id="k05">5. Instrukční sada jader Cortex-M4</h2>

<p>Základní instrukce zpracovávané jádry <i>Cortex-M4</i> jsou shodné
s&nbsp;čipy <i>Cortex-M3</i> i <i>Cortex-M7</i>, protože je podporována jak
instrukční sada Thumb s&nbsp;šestnáctibitovými operačními kódy, tak i
instrukční sada Thumb-2, v&nbsp;níž kromě šestnáctibitových operačních kódů
nalezneme i instrukce s&nbsp;32bitovým slovem. Naproti tomu původní
&bdquo;čistě RISCová&ldquo; 32bitová instrukční sada ARM podporována není. Tato
vlastnost však platí pro celou řadu Cortex-M, takže to pro nás pravděpodobně
nebude příliš překvapivé. Ovšem v&nbsp;oblasti zpracování číslicových signálů
je nutné, aby aritmeticko-logická jednotka podporovala kromě základních
aritmetických instrukcí s&nbsp;32bitovými operandy i další instrukce, zejména
pak sčítání a odčítání se saturací či mnoho kombinací násobení dvou operandů. I
tyto instrukce jádra <i>Cortex-M4</i> dokážou zpracovat, o čemž se ostatně
přesvědčíme v&nbsp;navazujících kapitolách.</p>



<p><a name="k06"></a></p>
<h2 id="k06">6. Základní instrukce</h2>

<p>Vzhledem k&nbsp;tomu, že instrukční sady Thumb a Thumb-2 jsou navrženy
zejména s&nbsp;ohledem na dosažení vysoké hustoty výsledného strojového kódu a
méně už s&nbsp;ohledem na eleganci či dokonce ortogonalitu, je instrukční sada
v&nbsp;porovnání s&nbsp;původní RISCovou instrukční sadou (dnes pro odlišení
nazývanou ARM32) značně odlišná; najdeme zde mnoho ad-hoc instrukcí i některé
instrukce, které už nejsou čistě RISCové. To se týká zejména prefixu
<strong>IT{podmínka}</strong> a taktéž instrukcí určených pro načtení či
uložení většího množství registrů <strong>LDM</strong> a <strong>STM</strong>.
Význam některých méně obvyklých instrukcí bude vysvětlen v&nbsp;poznámkách:</p>

<table>
<tr><th>Prováděná operace</th><th>Instrukce patřící do skupiny</th></tr>
<tr><td>Přesuny dat</td><td>MOV, MNV, MOVW, MOVT, MRS, BSR</td></tr>
<tr><td>Konverze dat</td><td>SXTB, SXTH, UXTB, UXTH</td></tr>
<tr><td>&nbsp;</td><td>&nbsp;</td></tr>
<tr><td>Součet (celočíselný)</td><td>ADD, ADC, ADR</td></tr>
<tr><td>Rozdíl (celočíselný)</td><td>SUB, SBC, RSB</td></tr>
<tr><td>Součin (celočíselný)</td><td>MUL, MLA, MLS, SMULL, UMULL, SMLAL, UMLAL</td></tr>
<tr><td>Podíl (celočíselný)</td><td>SDIV, UDIV</td></tr>
<tr><td>&nbsp;</td><td>&nbsp;</td></tr>
<tr><td>Porovnání a testy</td><td>CMP, CMN, TST, TEQ, CLZ</td></tr>
<tr><td>Logické operace</td><td>AND, ORR, ORN, EOR</td></tr>
<tr><td>Bitové operace</td><td>BIC</td></tr>
<tr><td>Logické a aritmetické posuny</td><td>LSL, LSR, ASR</td></tr>
<tr><td>Bitové rotace</td><td>ROR, RRX</td></tr>
<tr><td>Posuny se saturací</td><td>SSAT, USAT</td></tr>
<tr><td>Otočení bitů</td><td>REV, REV16, REVSH, RBIT</td></tr>
<tr><td>Bitová pole</td><td>UBFX, SBFX, BFC, BFI</td></tr>
<tr><td>&nbsp;</td><td>&nbsp;</td></tr>
<tr><td>Load (jeden registr)</td><td>LDR, LDRH, LDRB, LDRSH, LDRSB, LDRT, LDRHT, LDRBT, LDRSHT, LDRSBT, LDRD</td></tr>
<tr><td>Load (více registrů)</td><td>LDM</td></tr>
<tr><td>Store (jeden registr)</td><td>STR, STRH, STRB, STRSH, STRSB, STRT, STRHT, STRBT, STRSHT, STRSBT, STRD</td></tr>
<tr><td>Store (více registrů)</td><td>STM</td></tr>
<tr><td>&nbsp;</td><td>&nbsp;</td></tr>
<tr><td>Práce se zásobníkem</td><td>PUSH, POP</td></tr>
<tr><td>Skoky</td><td>B, BL, BX, BLX, TBB, TBH</td></tr>
<tr><td>Větvení</td><td>B{podmínka}, CBZ, CBNZ</td></tr>
<tr><td>&nbsp;</td><td>&nbsp;</td></tr>
<tr><td>Události a přerušení</td><td>SEV, WFE, WFI, CPSID, CPSIE</td></tr>
<tr><td>Práce s bariérami</td><td>ISB, DMB, DSB</td></tr>
<tr><td>Práce se semafory</td><td>LDREX, LDREXH, LDREXB, STREX, STREXH, STREXB, CLREX</td></tr>
<tr><td>&nbsp;</td><td>&nbsp;</td></tr>
<tr><td>Ostatní instrukce</td><td>NOP, SVC, IT{podmínka}, BKPT</td></tr>
</table>

<p>Poznámky:</p>

<ul>

<li>Instrukce <strong>SVC</strong> se mj.&nbsp;používá pro volání služeb
kernelu.</li>

<li>Instrukce <strong>SSAT</strong> a <strong>USAT</strong> se používají pro
posun operandu s&nbsp;následnou saturací na zvolený počet bitů.
<strong>SSAT</strong> provádí znaménkovou operaci, zatímco
<strong>USAT</strong> provádí operaci bezznaménkovou.</li>

<li>Instrukce <strong>TBB</strong> (<i>Table Branch Byte</i>) a
<strong>TBH</strong> (<i>Table Branch Halfword)</i> mohou být použity například
při překladu aplikací napsaných ve vyšších programovacích jazycích, typicky
céčka s&nbsp;jazykovou konstrukcí typu <strong>switch</strong>. Tyto instrukce
jsme si již popsali v&nbsp;rámci článku o jádrech <i>Cortex-M7</i>.</li>

<li>Instrukce <strong>CBZ</strong> a <strong>CBNZ</strong> slouží
k&nbsp;provedení skoku (rozvětvení), v&nbsp;případě, že je vybraný pracovní
registr nulový či naopak nenulový (<i>compare and branch if [not]
zero</i>).</li>

<li>Instrukční prefix <strong>IT{podmínka}</strong> může být aplikován na jednu
až čtyři instrukce následující za prefixem. Ihned za prefixem
<strong>IT</strong> se (bez mezery) udává, zda má být daná instrukce provedena
při splnění podmínky (<strong>T</strong> &ndash; <i>then</i>) či naopak při
jejím nesplnění (<strong>E</strong> &ndash; <i>else</i>). U první instrukce je
automaticky předpokládáno <strong>T</strong>, tudíž se při práci
v&nbsp;assembleru uvádí maximálně tři kombinace znaků T/E. Samozřejmě je taktéž
nutné zapsat i testovanou podmínku &ndash; může se jednat o kódy používané jak
u podmíněných skoků, tak i v&nbsp;podmínkových bitech.</li>

<li>Instrukce <strong>REV</strong> a <strong>REV16</strong> otáčí pořadí
<i>bajtů</i> ve 32bitovém či 16bitovém slovu (lze použít pro konverzi
little-big endian atd.), zatímco instrukce <strong>RBIT</strong> otočí pořadí
všech <i>bitů</i> ve 32bitovém slovu. To je docela užitečná operace, zejména
v&nbsp;oblasti zpracování signálů.</li>

<li>U instrukcí <strong>LDM</strong> a <strong>STM</strong> je součástí
instrukčního slova i bitové pole určující, které pracovní registry mají být
načteny či naopak uloženy do operační paměti.</li>

</ul>



<p><a name="k07"></a></p>
<h2 id="k07">7. Instrukce orientované na zpracování signálu</h2>

<p>Jak jsme si již řekli v&nbsp;předchozích kapitolách, jsou mikrořadičová
jádra navržena takovým způsobem, aby je bylo možné efektivně použít při
zpracování digitálních signálů. S&nbsp;tím samozřejmě souvisí i podpora pro
některé specializované instrukce, o nichž se ve stručnosti zmíníme
v&nbsp;následujících odstavcích. Mezi instrukce určené pro zpracování signálu
patří především:</p>

<ol>

<li><a href="#k08">Sčítání a odčítání se saturací</a>.</li>

<li>Instrukce <strong>MLA</strong> (<i>Multiply and Accumulate</i>) a
<strong>MLS</strong> (<i>Multiply and Subtract</i>), kde především první
instrukce je používaná například v&nbsp;číslicových filtrech.</li>

<li>Varianty <strong>MLA</strong> s&nbsp;64bitovým výsledkem, rozlišuje se
znaménkové a bezznaménkové násobení atd. (viz <a
href="#k10">násobička</a>).</li>

<li>Již výše zmíněné instrukce <strong>SSAT</strong> a
<strong>USAT</strong>.</li>

<li>Instrukce <strong>RBIT</strong> pro algoritmus výpočtu FFT apod.</li>

<li>Instrukce pro konverze dat (protože mnoho vstupních číslicových dat používá
osmibitové či šestnáctibitové vzorky).</li>

</ol>



<p><a name="k08"></a></p>
<h2 id="k08">8. Sčítání a odečítání se saturací</h2>

<p>Kromě běžných aritmetických operací je možné u čipů s&nbsp;jádry
<i>Cortex-M4</i> použít i operace se saturací. Při využití těchto operací
nedojde k&nbsp;přetečení přes maximální či minimální 8bitovou, 16bitovou či
32bitovou hodnotu (se znaménkem či bez znaménka), ale výpočet se
&bdquo;zasekne&ldquo; na minimální či maximální hodnotě.</p>

<table>
<tr><th> #</th><th>Instrukce</th><th>Typ</th><th>Šířka operandů</th><th>Poznámka</th></tr>
<tr><td> 1</td><td>SSAT   </td><td>Signed  </td><td>32 bitů        </td><td>posun operandu před výpočtem</td></tr>
<tr><td> 2</td><td>SSAT16 </td><td>Signed  </td><td>2&times;16 bitů</td><td>posun operandu před výpočtem</td></tr>
<tr><td> 3</td><td>USAT   </td><td>Unsigned</td><td>32 bitů        </td><td>posun operandu před výpočtem</td></tr>
<tr><td> 4</td><td>USAT16 </td><td>Unsigned</td><td>2&times;16 bitů</td><td>posun operandu před výpočtem</td></tr>
<tr><td> 5</td><td>QADD   </td><td>Signed  </td><td>32 bitů        </td><td>součet se saturací</td></tr>
<tr><td> 6</td><td>QADD8  </td><td>Signed  </td><td>4&times;8 bitů </td><td>součet se saturací</td></tr>
<tr><td> 7</td><td>QADD16 </td><td>Signed  </td><td>2&times;16 bitů</td><td>součet se saturací</td></tr>
<tr><td> 8</td><td>QSUB   </td><td>Signed  </td><td>32 bitů        </td><td>rozdíl se saturací</td></tr>
<tr><td> 9</td><td>QSUB8  </td><td>Signed  </td><td>4&times;8 bitů </td><td>rozdíl se saturací</td></tr>
<tr><td>10</td><td>QSUB16 </td><td>Signed  </td><td>2&times;16 bitů</td><td>rozdíl se saturací</td></tr>
<tr><td>11</td><td>QASX   </td><td>Signed  </td><td>32 bitů        </td><td>add + exchange</td></tr>
<tr><td>12</td><td>QSAX   </td><td>Signed  </td><td>32 bitů        </td><td>sub + exchange</td></tr>
<tr><td>13</td><td>QDADD  </td><td>Signed  </td><td>32 bitů        </td><td>druhý operand je před výpočtem vynásoben dvěma</td></tr>
<tr><td>14</td><td>QDSUB  </td><td>Signed  </td><td>32 bitů        </td><td>druhý operand je před výpočtem vynásoben dvěma</td></tr>
<tr><td>15</td><td>UQADD8 </td><td>Unsigned</td><td>4&times;8 bitů </td><td>součet se saturací</td></tr>
<tr><td>16</td><td>UQADD16</td><td>Unsigned</td><td>2&times;16 bitů</td><td>součet se saturací</td></tr>
<tr><td>17</td><td>UQSUB8 </td><td>Unsigned</td><td>4&times;8 bitů </td><td>rozdíl se saturací</td></tr>
<tr><td>18</td><td>UQSUB16</td><td>Unsigned</td><td>2&times;16 bitů</td><td>rozdíl se saturací</td></tr>
<tr><td>19</td><td>UQASX  </td><td>Unsigned</td><td>32 bitů        </td><td>add + exchange</td></tr>
<tr><td>20</td><td>UQSAX  </td><td>Unsigned</td><td>32 bitů        </td><td>add + exchange</td></tr>
</table>                                                                    



<p><a name="k09"></a></p>
<h2 id="k09">9. Bitový příznak Q</h2>

<p>Proč se vlastně ve jménech většiny instrukcí, které byly vypsány
v&nbsp;předchozí tabulce, objevuje znak <strong>Q</strong>? Souvisí to
s&nbsp;bitovým příznakem označeným (překvapivě) <strong>Q</strong>, který je
taktéž nazýván <i>sticky flag</i> či <i>sticky overflow bit</i> (což není zcela
přesné). Slovo &bdquo;sticky&ldquo; se používá z&nbsp;toho důvodu, že pokud
jednou dojde k&nbsp;jeho nastavení (na jedničku), musí se o jeho vynulování
explicitně postarat programátor, na rozdíl od ostatních příznaků
(<strong>Z</strong>, <strong>V</strong>, <strong>C</strong> apod.), které se
mění s&nbsp;každou relevantní instrukcí. Příznak <strong>Q</strong> je nastaven
ve chvíli, kdy při nějaké aritmetické operaci dojde k&nbsp;saturaci. To lze
použít například k&nbsp;detekci špatně nastavených parametrů při zpracování
signálu (příliš velké zesílení apod.). Díky tomu, že příznak <strong>Q</strong>
není běžnými instrukcemi nulován, není nutné jeho nastavení testovat po každé
aritmetické operaci, ale například až po zpracování celého bloku dat či po
aplikaci celého filtru na jeden vzorek, což je rychlejší a většinou i
dostačující.</p>



<p><a name="k10"></a></p>
<h2 id="k10">10. Násobička</h2>

<p>Násobička všech mikrořadičových jader <i>Cortex-M4</i> podporuje takřka
nepřeberné množství instrukcí pro násobení celočíselných operandů typu
<i>signed</i> či <i>unsigned</i> (se znaménkem, bez znaménka) s&nbsp;tím, že
výsledek je buď 32bitová hodnota či hodnota 64bitová. Navíc je možné určit, zda
se má výsledek násobení přičíst k&nbsp;mezivýsledku a provést tak
v&nbsp;oblasti digitálního zpracování signálů velmi užitečnou operaci nazývanou
&bdquo;Multiply&amp;Accumulate&ldquo; (přičemž akumulátor má většinou šířku 32
bitů či 64 bitů, zatímco vstupní operand může být v&nbsp;některých instrukcích
pouze šestnáctibitový). Následuje tabulka se základními operacemi
násobičky:</p>

<table>
<tr><th> #</th><th>Instrukce</th><th>Operandy</th><th>Výsledek</th><th>Počet cyklů</th><th>Operace</th></tr>
<tr><td> 1</td><td>MUL</td><td>32bit&times;32bit</td><td>32bit</td><td>1</td><td>násobení</td></tr>
<tr><td> 2</td><td>MAL</td><td>32bit&times;32bit</td><td>32bit</td><td>2</td><td>násobení a přičtení výsledku (Multiply and Accumulate)</td></tr>
<tr><td> 3</td><td>MLS</td><td>32bit&times;32bit</td><td>32bit</td><td>2</td><td>násobení a odečtení výsledku (Multiply and Subtract)</td></tr>
<tr><td> 4</td><td>SMULL</td><td>32bit&times;32bit</td><td>64bit</td><td>1</td><td>násobení hodnot se znaménkem</td></tr>
<tr><td> 5</td><td>SMLAL</td><td>32bit&times;32bit</td><td>64bit</td><td>1</td><td>Multiply and Accumulate (se znaménkem)</td></tr>
<tr><td> 6</td><td>UMULL</td><td>32bit&times;32bit</td><td>64bit</td><td>1</td><td>násobení hodnot bez znaménka</td></tr>
<tr><td> 7</td><td>UMLAL</td><td>32bit&times;32bit</td><td>64bit</td><td>1</td><td>Multiply and Accumulate (bez znaménka)</td></tr>
<tr><td> 8</td><td>UMAAL</td><td>32bit&times;32bit+32+32</td><td>64bit</td><td>1</td><td>Multiply and Accumulate long (bez znaménka)</td></tr>
<tr><td> 9</td><td>SMLAD</td><td>16bit&times;16bit</td><td>32bit</td><td>1</td><td>násobení dvouprvkových vektorů</td></tr>
<tr><td>10</td><td>SMLADX</td><td>16bit&times;16bit</td><td>32bit</td><td>1</td><td>násobení dvouprvkových vektorů</td></tr>
</table>

<p>DSP operace (povšimněte si zejména konstantního počtu cyklů pro zahájení či
dokončení operace):</p>

<table>
<tr><th> #</th><th>Instrukce</th><th>Počet cyklů</th><th>Operace</th></tr>
<tr><td> 1</td><td>SMLALD</td><td>1</td><td>Signed Multiply Accumulate Long Dual (16bit&times;64bit)</td></tr>
<tr><td> 2</td><td>SMLAWB</td><td>1</td><td>Signed Multiply Accumulate (word by halfword)</td></tr>
<tr><td> 3</td><td>SMLAWT</td><td>1</td><td>Signed Multiply Accumulate (word by halfword)</td></tr>
<tr><td> 4</td><td>SMLSD</td><td>1</td><td>Signed Multiply Subtract Dual</td></tr>
<tr><td> 5</td><td>SMLSLD</td><td>1</td><td>Signed Multiply Subtract Long Dual</td></tr>
<tr><td> 6</td><td>SMMLA</td><td>1</td><td>Signed Most Significant Word Multiply Accumulate</td></tr>
<tr><td> 7</td><td>SMMLS</td><td>1</td><td>Signed Most Significant Word Multiply Subtract</td></tr>
<tr><td> 8</td><td>SMUAD</td><td>1</td><td>Signed Dual Multiply Add</td></tr>
<tr><td> 9</td><td>SMMUL</td><td>1</td><td>Signed Most Significant Word Multiply</td></tr>
<tr><td>10</td><td>SMULWB</td><td>1</td><td>Signed Multiply (word by halfword)</td></tr>
<tr><td>11</td><td>SMMLAR</td><td>1</td><td>32-bit multiply with rounded 32-most-significant-bit accumulate</td></tr>
<tr><td>12</td><td>SMMLSR</td><td>1</td><td>32-bit multiply with rounded 32-most-significant-bit subtract</td></tr>
<tr><td>13</td><td>SMMULR</td><td>1</td><td>32-bit multiply returning rounded 32-most-significant-bits</td></tr>
<tr><td>14</td><td>SMLABB</td><td>1</td><td>Q setting 16-bit signed multiply with 32-bit accumulate, bottom by bottom</td></tr>
<tr><td>15</td><td>SMLABT</td><td>1</td><td>Q setting 16-bit signed multiply with 32-bit accumulate, bottom by top</td></tr>
<tr><td>16</td><td>SMLALBB</td><td>1</td><td>16-bit signed multiply with 64-bit accumulate, bottom by bottom</td></tr>
<tr><td>17</td><td>SMLALBT</td><td>1</td><td>16-bit signed multiply with 64-bit accumulate, bottom by top</td></tr>
<tr><td>18</td><td>SMLALTB</td><td>1</td><td>16-bit signed multiply with 64-bit accumulate, top by bottom</td></tr>
<tr><td>19</td><td>SMLALTT</td><td>1</td><td>16-bit signed multiply with 64-bit accumulate, top by top</td></tr>
<tr><td>20</td><td>SMULBB</td><td>1</td><td>16-bit signed multiply yielding 32-bit result, bottom by bottom</td></tr>
<tr><td>21</td><td>SMULBT</td><td>1</td><td>16-bit signed multiply yielding 32-bit result, bottom by top</td></tr>
<tr><td>22</td><td>SMULTB</td><td>1</td><td>16-bit signed multiply yielding 32-bit result, top by bottom</td></tr>
<tr><td>23</td><td>SMULTT</td><td>1</td><td>16-bit signed multiply yielding 32-bit result, top by bottom</td></tr>
<tr><td>24</td><td>SMULWT</td><td>1</td><td>16-bit by 32-bit signed multiply returning 32-most-significant-bits, top</td></tr>
<tr><td>25</td><td>SMUSD</td><td>1</td><td>Dual 16-bit signed multiply returning difference </td></tr>
<tr><td>26</td><td>SMLATB</td><td>1</td><td>Q setting 16-bit signed multiply with 32-bit accumulate, top by bottom</td></tr>
<tr><td>27</td><td>SMLATT</td><td>1</td><td>Q setting 16-bit signed multiply with 32-bit accumulate, top by top</td></tr>
</table>

<p>Neříkal někdo, že zkratka RISC je odvozena od &bdquo;Reduced Instruction
Set&ldquo;? :-)</p>



<p><a name="k11"></a></p>
<h2 id="k11">11. Jádra Cortex-M4F</h2>

<p>Základní mikrořadičová jádra označovaná pouze jménem <i>Cortex-M4</i>
(tj.&nbsp;bez znaku &bdquo;F&ldquo; na konci) neobsahují žádný matematický
koprocesor, který by dokázal nativně pracovat s&nbsp;numerickými hodnotami
s&nbsp;plovoucí řádovou čárkou. To je pochopitelné, protože existuje poměrně
mnoho aplikací, v&nbsp;nichž si vystačíme pouze s&nbsp;operacemi nad celými
čísly popř.&nbsp;s&nbsp;vlastní implementací výpočtů s&nbsp;fixní řádovou
čárkou (FX, fixed point). Pokud je však v&nbsp;nějaké aplikaci většina výpočtů
prováděna s&nbsp;numerickými hodnotami typu single/float, může být výhodnější
namísto jádra <i>Cortex-M4</i> použít jádro <i>Cortex-M4F</i>, které již
matematický koprocesor obsahuje &ndash; ovšem s&nbsp;několika omezeními, na
která je zapotřebí si dávat pozor, a to zejména při portaci aplikací. Jedno
z&nbsp;největších omezení spočívá v&nbsp;tom, že matematický koprocesor
skutečně podporuje pouze typ single/float a nikoli double (což v&nbsp;některých
případech nemusí vadit, ostatně své použití mají i šestnáctibitové formáty
s&nbsp;plovoucí řádovou čárkou).</p>

<p>Poznámka: ve skutečnosti je několik operací pro práci s&nbsp;dvojitou
přesností přece jen implementováno, což uvidíme v&nbsp;tabulce v&nbsp;další
kapitole.</p>

<p>Matematický koprocesor implementovaný v&nbsp;jádrech <i>Cortex-M4F</i> se
v&nbsp;mnoha ohledech odlišuje například od &bdquo;klasických&ldquo;
koprocesorů řady 80x87 (v&nbsp;nichž výpočty interně probíhají s&nbsp;hodnotami
rozšířenými na plných 80 bitů, což mj.&nbsp;dovoluje bezeztrátovou konverzi
mezi celočíselnými hodnotami <i>long</i> a interně používaným formátem
koprocesoru). Především se v&nbsp;RISCovém matematickém koprocesoru operandy
ukládají do sady registrů označených jmény <i>S0</i> až <i>S31</i>, na které
existují aliasy <i>D0</i> až <i>D15</i> (vždy dva registry, které původně nesly
informace o numerické hodnotě typu float/single jsou použity pro uložení
hodnoty typu double). Dále je možné zvolit tři režimy činnosti koprocesoru,
které mají vliv na prováděné výpočty: režim odpovídající normě IEEE 754
(<i>Full-compliance mode</i>), režim při kterém jsou denormalizované hodnoty
považovány za nulu (<i>Flush to zero mode</i>) a konečně režim, při kterém
všechny operace, u nichž je jeden či oba vstupní operandy roven NaN (<i>Not a
Number</i>), taktéž vrací NaN (naopak v&nbsp;režimu kompatibility s&nbsp;normou
IEEE 754 se hodnoty NaN zpracovávají podle specifikace).</p>



<p><a name="k12"></a></p>
<h2 id="k12">12. Operace podporované matematickým koprocesorem</h2>

<p>Operace, které jsou podporovány matematickým koprocesorem, jsou vypsány
v&nbsp;následující tabulce:</p>

<table>
<tr><th> #</th><th>Skupina</th><th>Instrukce</th><th>Počet cyklů</th><th>Popis</th><th>Prováděný výpočet</th></tr>
<tr><td> 1</td><td>Aritmetické operace</td><td>VADD.F32  Fd, Fn, Fm</td><td> 1</td><td>součet</td><td>Fd := Fn + Fm</td></tr>
<tr><td> 2</td><td>Aritmetické operace</td><td>VSUB.F32  Fd, Fn, Fm</td><td> 1</td><td>rozdíl</td><td>Fd := Fn - Fm</td></tr>
<tr><td> 3</td><td>Aritmetické operace</td><td>VNEG.F32  Fd, Fm    </td><td> 1</td><td>změna znaménka</td><td>Fd := - Fm</td></tr>
<tr><td> 4</td><td>Aritmetické operace</td><td>VABS.F32  Fd, Fm    </td><td> 1</td><td>absolutní hodnota</td><td>Fd := abs(Fm)</td></tr>
<tr><td> 5</td><td>Aritmetické operace</td><td>VSQRT.F32 Fd, Fm    </td><td>14</td><td>druhá odmocnina</td><td>Fd := sqrt(Fm)</td></tr>
<tr><td> 6</td><td>Aritmetické operace</td><td>VDIV.F32  Fd, Fn, Fm</td><td>14</td><td>dělení</td><td>Fd := Fn / Fm</td></tr>
<tr><td> 7</td><td>Aritmetické operace</td><td>VMUL.F32  Fd, Fn, Fm</td><td> 1</td><td>násobení</td><td>Fd := Fn * Fm</td></tr>
<tr><td> 8</td><td>Aritmetické operace</td><td>VMLA.F32  Fd, Fn, Fm</td><td> 3</td><td>násobení + akumulace</td><td>Fd := Fd + (Fn * Fm)</td></tr>
<tr><td> 9</td><td>Aritmetické operace</td><td>VMLS.F32  Fd, Fn, Fm</td><td> 3</td><td>odečtení součinu</td><td>Fd := Fd - (Fn * Fm)</td></tr>
<tr><td>10</td><td>Aritmetické operace</td><td>VNMUL.F32 Fd, Fn, Fm</td><td> 1</td><td>násobení + změna znaménka</td><td>Fn := - (Fn * Fm)</td></tr>
<tr><td>11</td><td>Aritmetické operace</td><td>VNMLA.F32 Fd, Fn, Fm</td><td> 3</td><td>kombinace VNMUL a VMLA</td><td>Fd := - Fd - (Fn * Fm)</td></tr>
<tr><td>12</td><td>Aritmetické operace</td><td>VNMLS.F32 Fd, Fn, Fm</td><td> 3</td><td>kombinace VNMUL a VMLS</td><td>Fd := - Fd + (Fn * Fm)</td></tr>
<tr><td>13</td><td>Aritmetické operace</td><td>VFMA.F32  Fd, Fn, Fm</td><td> 3</td><td>fused multiply and accumulate (jedno zaokrouhlení)</td><td>Fd := Fd + (Fn * Fm)</td></tr>
<tr><td>14</td><td>Aritmetické operace</td><td>VFMS.F32  Fd, Fn, Fm</td><td> 3</td><td>dtto + odečtení součinu</td><td>Fd := Fd - (Fn * Fm</td></tr>
<tr><td>15</td><td>Aritmetické operace</td><td>VFNMA.F32 Fd, Fn, Fm</td><td> 3</td><td>fused VNMLA</td><td>Fd := - Fd - (Fn * Fm)</td></tr>
<tr><td>16</td><td>Aritmetické operace</td><td>VFNMS.F32 Fd, Fn, Fm</td><td> 3</td><td>fused VNMLS</td><td>Fd := - Fd + (Fn * Fm)</td></tr>
<tr><td>17</td><td>Porovnání  </td><td>VCMP.F32 Fd, Fm     </td><td> 1</td><td>porovnání obsahu dvou registrů</td><td>Fd - Fm</td></tr>
<tr><td>18</td><td>Porovnání  </td><td>VCMP Fd, #0.0       </td><td> 1</td><td>porovnání jednoho registru s nulou</td><td>Fd - 0.0</td></tr>
<tr><td>19</td><td>Konverze   </td><td>VCVT.F32            </td><td> 1</td><td>konverze integer &rarr; single</td><td>&nbsp;</td></tr>
<tr><td>20</td><td>Přesuny dat</td><td>VMOV Sn, Rd         </td><td> 1</td><td>přesun dat do registru koprocesoru</td><td>Sn := Rd (Rd = registr ARM procesoru)</td></tr>
<tr><td>21</td><td>Přesuny dat</td><td>VMOV Rd, Sn         </td><td> 1</td><td>přesun dat do registru CPU</td><td>Rd := Sn (Rd = registr ARM procesoru)</td></tr>
<tr><td>22</td><td>Přesuny dat</td><td>VMOV Sn, #          </td><td> 1</td><td>načtení konstanty</td><td>Sd := #</td></tr>
<tr><td>23</td><td>Přesuny dat</td><td>VMOV Dn, Rd         </td><td> 2</td><td>přesun double</td><td>(jsou zapotřebí dva CPU registry)</td></tr>
<tr><td>24</td><td>Přesuny dat</td><td>VMOV Rd, Dn         </td><td> 2</td><td>přesun double</td><td>(jsou zapotřebí dva CPU registry)</td></tr>
<tr><td>25</td><td>Přesuny dat</td><td>VMRS APSR_nzcv, FPSCR</td><td> 1</td><td>APSR flags := FPSCR flags (přenos příznaků)</td><td>&nbsp;</td></tr>
<tr><td>26</td><td>Přesuny dat</td><td>VSMR FPSCR, APSR_nzcv</td><td> 1</td><td>opak předchozí instrukce</td><td>&nbsp;</td></tr>
<tr><td>27</td><td>Přesuny dat</td><td>VLDR.32             </td><td> 2</td><td>načtení jednoho registru typu single</td><td>&nbsp;</td></tr>
<tr><td>28</td><td>Přesuny dat</td><td>VLDR.64             </td><td> 3</td><td>načtení jednoho registru typu double</td><td>&nbsp;</td></tr>
<tr><td>29</td><td>Přesuny dat</td><td>VLDM.32             </td><td>1+N</td><td>načtení jednoho až N registrů typu single</td><td>&nbsp;</td></tr>
<tr><td>30</td><td>Přesuny dat</td><td>VLDM.64             </td><td>1+2&times;N</td><td>načtení jednoho až N registrů typu double</td><td>&nbsp;</td></tr>
<tr><td>31</td><td>Přesuny dat</td><td>VSTR.32             </td><td> 2</td><td>uložení jednoho registru typu single</td><td>&nbsp;</td></tr>
<tr><td>32</td><td>Přesuny dat</td><td>VSTR.64             </td><td> 3</td><td>uložení jednoho registru typu double</td><td>&nbsp;</td></tr>
<tr><td>33</td><td>Přesuny dat</td><td>VSTM.32             </td><td>1+N</td><td>uložení jednoho až N registrů typu single</td><td>&nbsp;</td></tr>
<tr><td>34</td><td>Přesuny dat</td><td>VSTM.64             </td><td>1+2&times;N</td><td>uložení jednoho až N registrů typu double</td><td>&nbsp;</td></tr>
<tr><td>35</td><td>Operace se zásobníkem</td><td>VPUSH.32  </td><td>1+N</td><td>uložení N registrů na zásobník</td><td>&nbsp;</td></tr>
<tr><td>36</td><td>Operace se zásobníkem</td><td>VPUSH.64  </td><td>1+2&times;N</td><td>uložení registrů na zásobník</td><td>&nbsp;</td></tr>
<tr><td>37</td><td>Operace se zásobníkem</td><td>VPOP.32   </td><td>1+N</td><td>přečtení N registrů ze zásobníku</td><td>&nbsp;</td></tr>
<tr><td>38</td><td>Operace se zásobníkem</td><td>VPOP.64   </td><td>1+2&times;N</td><td>přečtení N registrů ze zásobníku</td><td>&nbsp;</td></tr>
</table>



<p><a name="k13"></a></p>
<h2 id="k13">13. Operace ze standardu IEEE 754, které nejsou implementovány</h2>

<p>Některé operace, které jsou (velmi přesně) definovány v&nbsp;normě IEEE 754
resp.&nbsp;v&nbsp;její novější úpravě IEEE 754-2008, ve skutečnosti nejsou na
jádrech <i>Cortex-M4F</i> implementovány, což znamená, že pokud se dané operace
objeví ve zdrojových kódech překládaných programů, musí překladač namísto
vygenerování pouhých několika instrukcí koprocesoru volat knihovní funkce, což
je samozřejmě pomalejší (a taktéž je nutné pro tyto funkce vyhradit dostatečnou
kapacitu paměti ROM). Mezi nepodporované operace či instrukce patří
především:</p>

<ul>

<li>Výpočet zbytku po dělení.</li>

<li>Zaokrouhlení hodnoty s&nbsp;plovoucí řádovou čárkou na celočíselnou hodnotu
uloženou zpět do registru koprocesoru.</li>

<li>Porovnání hodnoty typu single s&nbsp;hodnotou typu double a naopak.</li>

<li>Konverze mezi desítkovým a binárním formátem. Desítkový formát používá jako
základ exponentu konstantu 10 a nikoli 2, norma IEEE 754 definuje tři takového
formáty: decimal32, decimal64 a decimal128.</li>

<li>Zpětná konverze mezi binárním a desítkovým formátem.</li>

</ul>



<p><a name="k14"></a></p>
<h2 id="k14">14. Odkazy na Internetu</h2>

<ol>

<li>A tour of the Cortex-M3 core:<br />
<a href="http://community.arm.com/groups/processors/blog/2013/11/04/a-tour-of-the-cortex-m3-core">http://community.arm.com/groups/processors/blog/2013/11/04/a-tour-of-the-cortex-m3-core</a>
</li>

<li>Five things you may not know about ARM Cortex-M:<br />
<a href="http://community.arm.com/docs/DOC-6912">http://community.arm.com/docs/DOC-6912</a>
</li>

<li>Divide and Conquer:<br />
<a href="http://community.arm.com/docs/DOC-8059">http://community.arm.com/docs/DOC-8059</a>
</li>

<li>MCU market turns to 32-bits and ARM<br />
<a href="http://www.eetimes.com/document.asp?doc_id=1280803">http://www.eetimes.com/document.asp?doc_id=1280803</a>
</li>

<li>Cortex-M0 Processor (ARM Holdings)<br />
<a href="http://www.arm.com/products/processors/cortex-m/cortex-m0.php">http://www.arm.com/products/processors/cortex-m/cortex-m0.php</a>
</li>

<li>Cortex-M0+ Processor (ARM Holdings)<br />
<a href="http://www.arm.com/products/processors/cortex-m/cortex-m0plus.php">http://www.arm.com/products/processors/cortex-m/cortex-m0plus.php</a>
</li>

<li>ARM Processors in a Mixed Signal World<br />
<a href="http://www.eeweb.com/blog/arm/arm-processors-in-a-mixed-signal-world">http://www.eeweb.com/blog/arm/arm-processors-in-a-mixed-signal-world</a>
</li>

<li>ARM Architecture (Wikipedia)<br />
<a href="https://en.wikipedia.org/wiki/ARM_architecture">https://en.wikipedia.org/wiki/ARM_architecture</a>
</li>

<li>Cortex-M0 (Wikipedia)<br />
<a href="https://en.wikipedia.org/wiki/ARM_Cortex-M0">https://en.wikipedia.org/wiki/ARM_Cortex-M0</a>
</li>

<li>Cortex-M0+ (Wikipedia)<br />
<a href="https://en.wikipedia.org/wiki/ARM_Cortex-M#Cortex-M0.2B">https://en.wikipedia.org/wiki/ARM_Cortex-M#Cortex-M0.2B</a>
</li>

<li>Improving ARM Code Density and Performance<br />
<a href="New Thumb Extensions to the ARM Architecture Richard Phelan">New Thumb Extensions to the ARM Architecture Richard Phelan</a>
</li>

<li>The ARM Processor Architecture<br />
<a href="http://www.arm.com/products/processors/technologies/instruction-set-architectures.php">http://www.arm.com/products/processors/technologies/instruction-set-architectures.php</a>
</li>

<li>Thumb-2 instruction set<br />
<a href="http://infocenter.arm.com/help/index.jsp?topic=/com.arm.doc.ddi0344c/Beiiegaf.html">http://infocenter.arm.com/help/index.jsp?topic=/com.arm.doc.ddi0344c/Beiiegaf.html</a>
</li>

<li>Introduction to ARM thumb<br />
<a href="http://www.eetimes.com/discussion/other/4024632/Introduction-to-ARM-thumb">http://www.eetimes.com/discussion/other/4024632/Introduction-to-ARM-thumb</a>
</li>

<li>ARM, Thumb, and ThumbEE instruction sets<br />
<a href="http://www.keil.com/support/man/docs/armasm/armasm_CEGBEIJB.htm">http://www.keil.com/support/man/docs/armasm/armasm_CEGBEIJB.htm</a>
</li>

<li>An Introduction to ARM Assembly Language<br />
<a href="http://dev.emcelettronica.com/introduction-to-arm-assembly-language">http://dev.emcelettronica.com/introduction-to-arm-assembly-language</a>
</li>

<li>Processors - ARM<br />
<a href="http://www.arm.com/products/processors/index.php">http://www.arm.com/products/processors/index.php</a>
</li>

<li>The ARM Instruction Set<br />
<a href="http://simplemachines.it/doc/arm_inst.pdf">http://simplemachines.it/doc/arm_inst.pdf</a>
</li>

<li>Instrukce typu SIMD na mikroprocesorech RISC<br />
<a href="http://www.root.cz/clanky/instrukce-typu-simd-na-mikroprocesorech-risc/">http://www.root.cz/clanky/instrukce-typu-simd-na-mikroprocesorech-risc/</a>
</li>

<li>Instrukce typu SIMD na mikroprocesorech RISC (2. část)<br />
<a href="http://www.root.cz/clanky/instrukce-typu-simd-na-mikroprocesorech-risc-2-cast/">http://www.root.cz/clanky/instrukce-typu-simd-na-mikroprocesorech-risc-2-cast/</a>
</li>

<li>Instrukce typu SIMD na mikroprocesorech RISC (3.část - MIPS-3D a VIS)<br />
<a href="http://www.root.cz/clanky/instrukce-typu-simd-na-mikroprocesorech-risc-3-cast-mips-3d-a-vis/">http://www.root.cz/clanky/instrukce-typu-simd-na-mikroprocesorech-risc-3-cast-mips-3d-a-vis/</a>
</li>

</ol>



<p></p><p></p>
<p><small>Autor: <a href="http://www.fit.vutbr.cz/~tisnovpa">Pavel Tišnovský</a> &nbsp; 2015</small></p>
</body>
</html>

