<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
        "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html>
<head>
<title>Mikrořadiče eZ8 aneb potomek legendárního Z80</title>
<meta name="Author" content="Pavel Tisnovsky" />
<meta name="Generator" content="vim" />
<meta http-equiv="content-type" content="text/html; charset=utf-8" />
<style type="text/css">
         body {color:#000000; background:#ffffff;}
         h1  {font-family: arial, helvetica, sans-serif; color:#ffffff; background-color:#c00000; text-align:center; padding-left:1em}
         h2  {font-family: arial, helvetica, sans-serif; color:#ffffff; background-color:#0000c0; padding-left:1em; text-align:left}
         h3  {font-family: arial, helvetica, sans-serif; color:#000000; background-color:#c0c0c0; padding-left:1em; text-align:left}
         h4  {font-family: arial, helvetica, sans-serif; color:#000000; background-color:#e0e0e0; padding-left:1em; text-align:left}
         a   {font-family: arial, helvetica, sans-serif;}
         li  {font-family: arial, helvetica, sans-serif; color:#000000; text-align:justify; width:450px;}
         ol  {font-family: arial, helvetica, sans-serif; color:#000000; text-align:justify; width:450px;}
         ul  {font-family: arial, helvetica, sans-serif; color:#000000; text-align:justify; width:450px;}
         p   {font-family: arial, helvetica, sans-serif; color:#000000; text-align:justify;}
         pre {background:#e0e0e0}
</style>
</head>

<body>

<h1>Mikrořadiče eZ8 aneb potomek legendárního Z80</h1>

<h3>Pavel Tišnovský</h3>

<p></p>

<h1>Úvodník</h1>

<p>Další řada osmibitových mikrořadičů, kterou si v dnešním článku stručně popíšeme, nese označení eZ8. Podobnost s legendárními mikroprocesory Z80 není náhodná, protože i mikrořadiče eZ8 jsou vyráběny společností Zilog.</p>



<h2>Obsah</h2>

<p><a href="#k01">1. Mikrořadiče eZ8 aneb potomek legendárního Z80</a></p>
<p><a href="#k02">2. Mnemotechnické zkratky instrukcí inspirované instrukční sadou Z80</a></p>
<p><a href="#k03">3. Programátorský pohled na mikrořadiče eZ8</a></p>
<p><a href="#k04">4. Registry a adresovací režimy</a></p>
<p><a href="#k05">5. Instrukční soubor mikrořadičů eZ8</a></p>
<p><a href="#k06">6. Aritmetické instrukce</a></p>
<p><a href="#k07">7. Logické instrukce</a></p>
<p><a href="#k08">8. Aritmetické posuny, bitové posuny a rotace</a></p>
<p><a href="#k09">9. Podmíněné i nepodmíněné skoky, skoky a návraty z&nbsp;podprogramů</a></p>
<p><a href="#k10">10. Instrukce Booleovského procesoru</a></p>
<p><a href="#k11">11. Instrukce pro přenosy dat</a></p>
<p><a href="#k12">12. Blokové přenosy</a></p>
<p><a href="#k13">13. Práce s&nbsp;příznakovými bity</a></p>
<p><a href="#k14">14. Instrukce pro řízení CPU</a></p>
<p><a href="#k15">15. Odkazy na Internetu</a></p>



<p><a name="k01"></a></p>
<h2 id="k01">1. Mikrořadiče eZ8 aneb potomek legendárního Z80</h2>

<p><i>&bdquo;Certainly, 32-bit or even 16-bit MCUs are not needed for end
points such as wall plugs, switches, smart ballasts, even certain lighting
fixtures. When examining deployment ratios, it is apparent that there are many
more end points in many of these designs, and thus a large demand for our
beloved 8-bit microcontrollers. They are not gone, and they most certainly are
not forgotten!&ldquo;</i></p>

<p>Další řada osmibitových mikrořadičů, s&nbsp;níž se <a
href="https://www.root.cz/serialy/co-se-deje-v-pocitaci/">v&nbsp;seriálu o
architekturách počítačů a procesorů</a> alespoň ve stručnosti seznámíme, je
postavena na jádrech <i>Z8</i> a <i>eZ8</i>. Mikrořadiče s&nbsp;jádry Z8 patří
do skupiny původních osmibitových mikrořadičů navržených již na konci
sedmdesátých let minulého století či na samotném začátku let osmdesátých (do
této skupiny můžeme zařadit i původní architektury PIC, Motorolu 68HC05/08,
Intel 8048 i Intel 8051). Jádra <i>eZ8</i>, která jsou již novější a
modernější, vznikla rozšířením osmibitových mikrořadičů <i>Z8</i> o několik
nových instrukcí a taktéž rozšířením adresovacích režimů. Navíc byla
architektura čipu upravena takovým způsobem, že se většina strojových instrukcí
provede v&nbsp;menším počtu hodinových cyklů a navíc dochází i k&nbsp;většímu
překryvu instrukcí &ndash; u původních jader <i>Z8</i> se překrývala pouze fáze
<i>write back</i> (zápis výsledků) s&nbsp;fází <i>instruction fetch</i> (a to
ještě pouze z&nbsp;toho důvodu, že paměť s&nbsp;programem byla oddělena od
datové paměti).</p>

<a href="http://i.iinfo.cz/images/241/pc6702.jpg"><img src="http://i.iinfo.cz/images/241/pc6702-prev.jpg" width="370" height="247" alt="pc6702" /></a>
<p><i>Obrázek 1: Domácí osmibitový mikropočítač ZX80. V&nbsp;průběhu jediného
roku, kdy byl tento počítač vyráběn, se prodalo cca 70000 kusů, což je na
tehdejší dobu velmi vysoké číslo.</i></p>

<p>Za vývojem mikrořadičů s&nbsp;jádry Z8 stojí společnost Zilog, kterou si
velmi dobře pamatují zejména uživatelé domácích osmibitových mikropočítačů,
protože v&nbsp;mnoha těchto strojích se používal mikroprocesor Intel Z80, který
byl zpětně kompatibilní s&nbsp;v&nbsp;mnoha ohledem horším čipem Intel 8080,
ovšem navíc nabízel rozšířenou sadu registrů, vylepšenou sadu instrukcí,
jednodušší způsob zapojení mikropočítače se Z80 (snížení počtu VLSI čipů o dva)
atd. Kromě toho však Zilog Z80 můžeme najít i v&nbsp;dalších zařízeních, ať již
se jedná o herní automaty či naopak o profesionální počítače vybavené operačním
systémem CP/M. Po velkém úspěchu Z80 se firma Zilog snažila prosadit i na trhu
se šestnáctibitovými mikroprocesory (což se příliš nezdařilo) a taktéž na trhu
s&nbsp;osmibitovými mikrořadiči, pro něž vyrábí právě řadu Z8 (úspěch však není
příliš oslnivý kvůli velké konkurenci), nověji řadu eZ8, ale i čipy postavené
na starodávné, nicméně stále používané architektuře 8051 (mikrořadiče ...).</p>

<a href="http://www.root.cz/obrazek/210818/"><img src="http://i.iinfo.cz/images/462/dev-8bit-14-prev.png" class="image-210818" width="283" height="270" alt="&#160;" /></a>
<p><i>Obrázek 2: Obal na kazetu se Zeus Assemblerem pro ZX Spectrum a tím pádem
samozřejmě pro mikroprocesory Zilog Z80.</i></p>



<p><a name="k02"></a></p>
<h2 id="k02">2. Mnemotechnické zkratky instrukcí inspirované instrukční sadou Z80</h2>

<p>Instrukční soubor osmibitových mikrořadičů Z8/eZ8 se sice v&nbsp;mnoha
ohledech odlišuje od původního mikroprocesoru Zilog Z80, ovšem mnemotechnické
zkratky instrukcí zůstaly do velké míry zachovány, což znamená, že se programy
psané v&nbsp;assembleru Z8/eZ8 do značné míry podobají například původním
programům pro ZX Spectrum či pro další domácí počítače na Z80 postavené
(mimochodem: firma Zilog musela z&nbsp;licenčních důvodů pro svůj Z80 použít
odlišné zkratky instrukcí, než jaké nalezneme na zpětně kompatibilním čipu
Intel 8080). Musíme však mít na paměti, že největší rozdíly mezi mikroprocesory
Z80 a mikrořadiči Z8/eZ8 spočívají v&nbsp;použití zcela odlišného způsobu
adresování pracovních registrů, což je téma, kterému se budeme více věnovat
v&nbsp;navazujících kapitolách.</p>

<p>Jen pro zajímavost se podívejme na shodné i rozdílné mnemotechnické zkratky
instrukcí u Z80 a Z8 (podrobnější přehled instrukcí bude opět uveden
v&nbsp;dalších kapitolách; tabulka nezohledňuje to, že některé instrukce byly
přejmenovány):</p>

<pre>
Z8             Z80
-------------------
ADC            ADC
ADCX             
ADD            ADD
ADDX             
AND            AND
ANDX             
ATM
               BIT
BCLR
BIT
BRK
BSET
BSWAP
BTJ
BTJNZ
BTJZ
CALL           CALL
CCF            CCF
CLR
COM
CP             CP
CPC
CPCX
               CPD
               CPDR
               CPI
               CPIR
               CPL
CPX
DA
               DAA
DEC            DEC
DECW
DI             DI
DJNZ           DJNZ
EI             EI
               EX
HALT           HALT
               IM
               IN
INC            INC
INCW
               IND
               INDR
               INI
               INIR
IRET
JP             JP
JR             JR
LD             LD
LDC
LDCI
               LDD
               LDDR
LDE
LDEI
               LDI
               LDIR
LDWX
LDX
LEA
MULT
               NEG
NOP            NOP
OR             OR
ORX
               OUT
               OUTD
               OTDR
               OUTI
               OTIR
POP            POP
POP            PUSHX
PUSH
PUSHX
RCF
               RES
RET            RET
               RETI
               RETN
               RLA
RL             RL
RLC            RLC
               RLCA
               RLD
               RRA
RR             RR
               RRCA
RRC            RRC
               RRD
               RST
SBC            SBC
SBCX
SCF            SCF
               SET
               SLA
SRA            SRA
               SLL
SRL            SRL
SRP
STOP
SUB            SUB
SUBX
SWAP
TCM
TCMX
TM
TMX
TRAP
WDT
XOR            XOR
XORX
</pre>



<p><a name="k03"></a></p>
<h2 id="k03">3. Programátorský pohled na mikrořadiče eZ8</h2>

<p>Mikrořadiče eZ8 mají Harvardskou architekturu, což znamená, že paměť
s&nbsp;uloženým programem je oddělená od datové paměti. Navíc jen velmi malé
množství instrukcí dokáže pracovat s&nbsp;daty (konstantami) uloženými
v&nbsp;paměti programu; naproti tomu možnosti adresování dat v&nbsp;datové
paměti jsou nepoměrně větší, což je samozřejmě chování založené na reálných
požadavcích.</p>

<p>Programová paměť může mít maximální kapacitu 64 kB, ovšem reálné čipy
většinou obsahují FLASH s&nbsp;menší kapacitou, typicky od 1kB do 16kB.
V&nbsp;prvních dvou bajtech je uložena konfigurace FLASH, za níž následuje
vektor pro RESET (vektor=cílová adresa, která se použije po signálu RESET). Od
adresy 0x0004 jsou uloženy vektory (cílové adresy) jednotlivých rutin přerušení
(počet je proměnný) a za těmito vektory je již vlastní paměť s&nbsp;programem a
konstantními daty.</p>

<p>Datová paměť je rozdělená mnohem zajímavěji. Její maximální kapacita je 4096
bajtů (4kB). Těchto 4096 adres je rozděleno do šestnácti <i>banků</i> (každý má
velikost 256 bajtů) a každý bank je rozdělen do šestnácti <i>skupin</i> po
šestnácti adresách. Vybraný <i>bank</i> lze adresovat s&nbsp;použitím
osmibitové konstanty či osmibitového registru a vybranou skupinu procesor
považuje za aktivní <i>pracovní registry</i>, které jsou adresovány (vybírány)
pouhými čtyřmi bity v&nbsp;instrukci (výběr banku a skupiny se provádí
instrukcí <strong>SRP</strong>). Díky tomuto rozdělení na banky a skupiny bylo
možné zcela odstranit koncept klasického akumulátoru i pracovních registrů;
navíc je možné pro přerušovací rutiny (či pro běžné subrutiny) vyhradit
samostatné skupiny adres, což zcela odstraní nutnost manipulace se zásobníkem.
Do datové paměti jsou navíc mapovány i řídicí registry, což je ovšem téma pro
navazující článek.</p>

<p>Na adrese 0xfc je uložen bajt obsahující příznakové bity
(<strong>FLAGS</strong>):</p>

<table>
<tr><th>Příznak</th><th>Název</th></tr>
<tr><td>C</td><td>carry</td></tr>
<tr><td>Z</td><td>zero</td></tr>
<tr><td>S</td><td>sign</td></tr>
<tr><td>V</td><td>overflow</td></tr>
<tr><td>D</td><td>decimal adjust</td></tr>
<tr><td>H</td><td>half carry</td></tr>
</table>

<img src="https://i.iinfo.cz/images/308/pacman-1.png" class="image-273005" alt="&#160;" width="224" height="288" />
<p><i>Obrázek 3: Automat se hrou Pac-Man je taktéž postaven na mikroprocesorech
Zilog Z80.</i></p>



<p><a name="k04"></a></p>
<h2 id="k04">4. Registry a adresovací režimy</h2>

<p>Unikátní architektura eZ8 nabízí programátorům následující adresovací
režimy:</p>

<ol>
<li>Pracovní registr ve vybrané skupině (4bitový index)</li>
<li>Registr ve vybraném banku (256 adres)</li>
<li>Registrový pár (sudé adresy 0..254)</li>
<li>Nepřímý pracovní registr @r</li>
<li>Nepřímý registr ve vybraném banku @R</li>
<li>Nepřímý registrový pár @RR</li>
<li>Relativní adresa (8 bitů pro skoky)</li>
<li>Rozšířená adresa (12 bitů pro datovou paměť)</li>
<li>Absolutní adresa (16 bitů pro externí paměť či paměť programu)</li>
<li>Pracovní registr použitý jako index</li>
</ol>



<p><a name="k05"></a></p>
<h2 id="k05">5. Instrukční soubor mikrořadičů eZ8</h2>

<p>Instrukce mikrořadičů s&nbsp;jádry eZ8 obsahují 60 resp.&nbsp;74 instrukcí,
a to v&nbsp;závislosti na tom, zda instrukce s&nbsp;rozšířeným adresováním
budeme považovat za nové instrukce či za modifikaci již existujících instrukcí.
Následující kapitoly jsou pojmenovány podobně, jako tomu bylo <a
href="https://www.root.cz/clanky/osmibitove-mikroradice-s-jadry-s08-a-rs08/">v&nbsp;předminulém</a>
i <a
href="https://www.root.cz/clanky/minimalisticke-osmibitove-mikroradice-s-jadry-rs08/">minulém
článku</a>, takže si můžete rozdíly mezi instrukčními sadami snadno
porovnat:</p>

<table>
<tr><th>Skupina</th><th>Základních instrukcí</th><th>Rozšířené adresování</th><th>Celkem</th></tr>
<tr><td><a href="#k06">Aritmetické instrukce</a></td><td>11</td><td>6</td><th>17</th></tr>
<tr><td><a href="#k07">Logické instrukce</a></td><td>4</td><td>3</td><th>7</th></tr>
<tr><td><a href="#k08">Aritmetické posuny, bitové posuny a rotace</a></td><td>8</td><td>0</td><th>8</th></tr>
<tr><td><a href="#k09">Podmíněné i nepodmíněné skoky, skoky a návraty z&nbsp;podprogramů</a></td><td>9</td><td>0</td><th>9</th></tr>
<tr><td><a href="#k10">Instrukce Booleovského procesoru</a></td><td>5</td><td>2</td><th>7</th></tr>
<tr><td><a href="#k11">Instrukce pro přenosy dat</a></td><td>8</td><td>3</td><th>11</th></tr>
<tr><td><a href="#k12">Blokové přenosy</a></td><td>2</td><td>0</td><th>2</th></tr>
<tr><td><a href="#k13">Práce s&nbsp;příznakovými bity</a></td><td>3</td><td>0</td><th>3</th></tr>
<tr><td><a href="#k14">Instrukce pro řízení CPU</a></td><td>10</td><td>0</td><th>10</th></tr>
<tr><th>Celkem:</th><th>60</th><th>14</th><th>74</th></tr>
</table>



<p><a name="k06"></a></p>
<h2 id="k06">6. Aritmetické instrukce</h2>

<p>Do sady aritmetických instrukcí patří samozřejmě instrukce pro součet a
rozdíl dvou operandů. V&nbsp;závislosti na tom, zda se při výpočtu použije
příznak <i>carry</i> rozlišujeme instrukce
<strong>ADD</strong>/<strong>ADC</strong> a
<strong>SUB</strong>/<strong>SBC</strong> (zde se <i>carry</i> použije ve
smyslu výpůjčky, tedy <i>borrow</i> i přesto, že se instrukce nejmenuje
<strong>SBB</strong>). Následují instrukce pro zvýšení či snížení operandu o
jedničku. Zde stojí za povšimnutí fakt, že můžeme inkrementovat či
dekrementovat obsah registrového páru, tj.&nbsp;šestnáctibitového operandu,
zatímco většina ostatních instrukcí pracuje jen s&nbsp;osmibitovými operandy
(ovšem inkrementace a dekrementace se provádí i u ukazatelů, takže se tyto
instrukce v&nbsp;praxi hodí). Následuje instrukce <strong>MULT</strong> pro
vynásobení osmibitových operandů se šestnáctibitovým výsledkem, instrukce pro
porovnání operandů s&nbsp;nastavením příznakových bitů a konečně instrukce
<strong>DA</strong> pro desítkovou korekci předchozí operace součtu či rozdílu
ve chvíli, kdy se pracuje v&nbsp;kódu BCD (korekce se provede na základě
příznakového bitu H/half carry):</p>

<table>
<tr><th> #</th><th>Instrukce</th><th>Operandy</th><th>Stručný popis</th></tr>
<tr><td> 1</td><td>ADD </td><td>dst,src</td><td>součet dst ← dst + src</td></tr>
<tr><td> 2</td><td>ADC </td><td>dst,src</td><td>součet dst ← dst + src + C</td></tr>
<tr><td> 3</td><td>SUB </td><td>dst,src</td><td>rozdíl dst ← dst - src</td></tr>
<tr><td> 4</td><td>SBC </td><td>dst,src</td><td>rozdíl dst ← dst - src - C</td></tr>
<tr><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td></tr>
<tr><td> 5</td><td>INC </td><td>dst</td><td>inkrementace dst (osmibitový operand)</td></tr>
<tr><td> 6</td><td>INCW</td><td>dst</td><td>inkrementace dst (šestnáctibitový operand)</td></tr>
<tr><td> 7</td><td>DEC </td><td>dst</td><td>dekrementace dst (osmibitový operand)</td></tr>
<tr><td> 8</td><td>DECW</td><td>dst</td><td>dekrementace dst (šestnáctibitový operand)</td></tr>
<tr><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td></tr>
<tr><td> 9</td><td>MULT</td><td>dst</td><td>násobení 8&times;8bit: dst[15:0] ← dst[15:8] &times; dst[7:0]</td></tr>
<tr><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td></tr>
<tr><td>10</td><td>CP  </td><td>dst,src</td><td>rozdíl dst - src (pouze se nastaví příznaky, výsledek se neuloží)</td></tr>
<tr><td>11</td><td>CPC </td><td>dst,src</td><td>rozdíl dst - src - C (pouze se nastaví příznaky, výsledek se neuloží)</td></tr>
<tr><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td></tr>
<tr><td>11</td><td>DA  </td><td>dst</td><td>korekce po operacích ADD a SUB, pokud jsou výpočty prováděny v&nbsp;BCD kódu</td></tr>
</table>

<p>Některé často používané instrukce mají další varianty, které používají
&bdquo;rozšířené&ldquo; adresovací režimy. Operandem <i>dst</i> je v&nbsp;tomto
případě dvanáctibitová adresa v&nbsp;rozsahu 0x000 až 0xfff, operandem
<i>src</i> pak taktéž dvanáctibitová adresa popř.&nbsp;osmibitová
konstanta:</p>

<table>
<tr><th>#</th><th>Instrukce</th><th>Rozšířená varianta</th></tr>
<tr><td>1</td><td>ADD</td><td>ADDX</td></tr>
<tr><td>2</td><td>ADC</td><td>ADCX</td></tr>
<tr><td>3</td><td>SUB</td><td>SUBX</td></tr>
<tr><td>4</td><td>SBC</td><td>SBCX</td></tr>
<tr><td>5</td><td>CP</td><td>CPX</td></tr>
<tr><td>6</td><td>CPC</td><td>CPCX</td></tr>
</table>



<p><a name="k07"></a></p>
<h2 id="k07">7. Logické instrukce</h2>

<p>Mezi logickými instrukcemi samozřejmě nalezneme instrukce
<strong>AND</strong> (logický součin) a <strong>OR</strong> (logický součet)
doplněné o instrukci <strong>XOR</strong> (nonekvivalence) a taktéž o instrukci
<strong>COM</strong> určenou pro negaci všech bitů operandu. Všechny tyto
instrukce pracují pouze s&nbsp;osmibitovými operandy:</p>

<table>
<tr><th>#</th><th>Instrukce</th><th>Operandy</th><th>Stručný popis</th></tr>
<tr><td>1</td><td>AND</td><td>dst,src</td><td>dst ← dst &and; src + nastavení příznaků Z a S</td></tr>
<tr><td>2</td><td>OR </td><td>dst,src</td><td>dst ← dst &or; src + nastavení příznaků Z a S</td></tr>
<tr><td>3</td><td>XOR</td><td>dst,src</td><td>dst ← dst &oplus; src + nastavení příznaků Z a S</td></tr>
<tr><td>4</td><td>COM</td><td>dst    </td><td>dst ← ~dst + nastavení příznaků Z a S</td></tr>
</table>

<p>Podobně jako u aritmetických instrukcí, i u instrukcí logických (přesněji
řečeno u těch instrukcí, které mají dva operandy) nalezneme varianty
s&nbsp;rozšířeným adresováním (instrukce <strong>COM</strong> však nemá
rozšířený ekvivalent):</p>

<table>
<tr><th>#</th><th>Instrukce</th><th>Rozšířená varianta</th></tr>
<tr><td>1</td><td>AND</td><td>ANDX</td></tr>
<tr><td>2</td><td>OR </td><td>ORX </td></tr>
<tr><td>3</td><td>XOR</td><td>XORX</td></tr>
</table>



<p><a name="k08"></a></p>
<h2 id="k08">8. Aritmetické posuny, bitové posuny a rotace</h2>

<p>Mikrořadiče Z8 podporují instrukce pro rotaci operandu doprava i doleva
s&nbsp;výběrem, zda se má rotace provést bez příznaku <i>carry</i> (rotace osmi
bitů) či naopak s&nbsp;příznakem <i>carry</i> (rotace přes devět bitů).
Existují i instrukce pro aritmetický a logický posun doprava
<strong>SRL</strong> a <strong>SRA</strong>, ovšem podobné instrukce pro posun
doprava nenalezneme, protože je lze snadno nahradit součtem. Všechny rotace a
posuny jsou provedeny vždy o jediný bit. Výjimkou je instrukce
<strong>SWAP</strong>, která prohodí horní a spodní čtveřici bitů a je tedy
shodná s&nbsp;opakováním instrukce <strong>RL</strong> či <strong>RR</strong>
čtyřikrát po sobě. Instrukce <strong>BSWAP</strong> otočí všechny bity
v&nbsp;operandů, takže do této skupiny spadá jen částečně:</p>

<table>
<tr><th>#</th><th>Instrukce</th><th>Operandy</th><th>Stručný popis</th></tr>
<tr><td>1</td><td>RL   </td><td>dst</td><td>rotace doleva</td></tr>
<tr><td>2</td><td>RLC  </td><td>dst</td><td>rotace doleva přes příznak <i>carry</i></td></tr>
<tr><td>3</td><td>RR   </td><td>dst</td><td>rotace doprava</td></tr>
<tr><td>4</td><td>RRC  </td><td>dst</td><td>rotace doprava přes příznak <i>carry</i></td></tr>
<tr><td>5</td><td>SRL  </td><td>dst</td><td>logický posun doprava</td></tr>
<tr><td>6</td><td>SRA  </td><td>dst</td><td>aritmetický posun doprava</td></tr>
<tr><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td></tr>
<tr><td>7</td><td>SWAP </td><td>dst</td><td>prohození čtyř horních bitů se spodními čtyřmi bity</td></tr>
<tr><td>8</td><td>BSWAP</td><td>dst</td><td>otočení všech bitů v&nbsp;operandu</td></tr>
</table>

<p>Instrukce <strong>RL</strong>:</p>

<pre>
+-------+
+ Carry |
+-------+
    ^
    |     +---+---+---+---+---+---+---+---+
    +---&lt;-| 7 | 6 | 5 | 4 | 3 | 2 | 1 | 0 |
    |     +---+---+---+---+---+---+---+---+
    |                                   ^
    v                                   |
    +-----------------------------------+
</pre>

<p>Instrukce <strong>RR</strong>:</p>

<pre>
+-------+
+ Carry |
+-------+
    ^
    |     +---+---+---+---+---+---+---+---+
    +--&gt;--| 7 | 6 | 5 | 4 | 3 | 2 | 1 | 0 |
    |     +---+---+---+---+---+---+---+---+
    ^                                   |
    |                                   v
    +-----------------------------------+
</pre>

<p>Instrukce <strong>RLC</strong>:</p>

<pre>
+-------+       +---+---+---+---+---+---+---+---+
+ Carry |---&lt;---| 7 | 6 | 5 | 4 | 3 | 2 | 1 | 0 |
+-------+       +---+---+---+---+---+---+---+---+
    |                                         ^
    v                                         |
    +-----------------------------------------+
</pre>

<p>Instrukce <strong>RRC</strong>:</p>

<pre>
+-------+       +---+---+---+---+---+---+---+---+
+ Carry |---&gt;---| 7 | 6 | 5 | 4 | 3 | 2 | 1 | 0 |
+-------+       +---+---+---+---+---+---+---+---+
    ^                                         |
    |                                         v
    +-----------------------------------------+
</pre>

<p>Instrukce <strong>SRL</strong>:</p>

<pre>
+---+       +---+---+---+---+---+---+---+---+       +-------+
+ 0 |---&gt;---| 7 | 6 | 5 | 4 | 3 | 2 | 1 | 0 |---&gt;---+ Carry |
+---+       +---+---+---+---+---+---+---+---+       +-------+
</pre>

<p>Instrukce <strong>SRA</strong>:</p>

<pre>
+---&lt;----+
|        |
|      +-+-+---+---+---+---+---+---+---+       +-------+
+--&gt;---| 7 | 6 | 5 | 4 | 3 | 2 | 1 | 0 |---&gt;---+ Carry |
       +---+---+---+---+---+---+---+---+       +-------+
</pre>



<p><a name="k09"></a></p>
<h2 id="k09">9. Podmíněné i nepodmíněné skoky, skoky a návraty z&nbsp;podprogramů</h2>

<p>Mezi další skupinu instrukcí patří různé typy skoků, včetně instrukcí
určených pro skok do podprogramu a návrat z&nbsp;podprogramu. Při popisu
skokových instrukcí si musíme uvědomit, že se v&nbsp;nich musí použít
adresovací režimy odlišné od režimů použitých při adresování operandů
aritmetických a logických instrukcí. Je to vlastně očekávaná vlastnost, protože
operandy běžných instrukcí jsou uloženy v&nbsp;datové paměti (o maximální
kapacitě 4096 bajtů), kdežto paměť programu je od datové paměti oddělena a její
běžný adresový rozsah je 64 kB (s&nbsp;možností jeho zvětšení s&nbsp;využitím
stránkování). Základní instrukce pro podmíněné a nepodmíněné skoky se jmenuje
<strong>JP</strong> (absolutní skok) a <strong>JR</strong> (relativní skok),
pro skok do podprogramu a návrat z&nbsp;podprogramu se používají instrukce
<strong>CALL</strong> a <strong>RET</strong>, Booleovský procesor je doplněn
instrukcemi <strong>BTJ</strong>, <strong>BTJZ</strong> a
<strong>BTJNZ</strong> a zapomenout nesmíme ani na instrukci
<strong>DJNZ</strong>, kterou lze použít pro implementaci počítaných
programových smyček:</p>

<table>
<tr><th>#</th><th>Instrukce</th><th>Operandy</th><th>Stručný popis</th></tr>
<tr><td>1</td><td>JP</td><td>cc,dst</td><td>absolutní skok (s&nbsp;volitelnou podmínkou)</td></tr>
<tr><td>2</td><td>JR</td><td>cc,dst</td><td>relativní skok (s&nbsp;volitelnou podmínkou)</td></tr>
<tr><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td></tr>
<tr><td>3</td><td>DJNZ</td><td>dst,src</td><td>snížení dst o 1 a skok v&nbsp;případě, že je dst nulový</td></tr>
<tr><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td></tr>
<tr><td>4</td><td>BTJ  </td><td>p, bit, src, dst</td><td>skok za podmínky, že je src<sub>bit</sub>=p</td></tr>
<tr><td>5</td><td>BTJZ </td><td>bit, src, dst</td><td>skok za podmínky, že je src<sub>bit</sub>=0</td></tr>
<tr><td>6</td><td>BTJNZ</td><td>bit, src, dst</td><td>skok za podmínky, že je src<sub>bit</sub>=1</td></tr>
<tr><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td></tr>
<tr><td>7</td><td>CALL</td><td>dst</td><td>volání podprogramu (lze použít absolutní adresu či registrový pár)</td></tr>
<tr><td>8</td><td>RET </td><td>&nbsp;</td><td>návrat z&nbsp;podprogramu</td></tr>
<tr><td>9</td><td>IRET</td><td>&nbsp;</td><td>návrat z&nbsp;přerušovací rutiny (obnoví FLAGS i IRQCTL)</td></tr>
</table>

<p>U instrukcí skoku je v&nbsp;operandu <strong>dst</strong> uložena přímá či
nepřímá cílová adresa skoku.</p>

<p>U instrukcí <strong>JP</strong> a <strong>JR</strong> je možné do pole
<strong>cc</strong> specifikovat podmínku, při jejímž splnění se skok provede.
Pokud podmínka není zapsána, provede se skok v&nbsp;každém případě (druhý řádek
tabulky):</p>

<table>
<tr><th>Kód (cc)</th><th>Plný název</th><th>Testovaná podmínka</th></tr>
<tr><td>F    </td><td>always false                  </td><td>&times;</td></tr>
<tr><td>(nic)</td><td>always true                   </td><td>&times;</td></tr>
<tr><td>C    </td><td>carry                         </td><td>C=1</td></tr>
<tr><td>NC   </td><td>no carry                      </td><td>C=0</td></tr>
<tr><td>Z    </td><td>zero                          </td><td>Z=1</td></tr>
<tr><td>NZ   </td><td>non zero                      </td><td>Z=0</td></tr>
<tr><td>PL   </td><td>plus                          </td><td>S=0</td></tr>
<tr><td>MI   </td><td>minus                         </td><td>S=1</td></tr>
<tr><td>OV   </td><td>overflow                      </td><td>V=1</td></tr>
<tr><td>NOV  </td><td>no overflow                   </td><td>V=0</td></tr>
<tr><td>EQ   </td><td>equal                         </td><td>Z=1</td></tr>
<tr><td>NE   </td><td>not equal                     </td><td>Z=0</td></tr>
<tr><td>GE   </td><td>greater than or equal         </td><td>(S &oplus; V)=0</td></tr>
<tr><td>LT   </td><td>less than                     </td><td>(S &oplus; V)=1</td></tr>
<tr><td>GT   </td><td>greater than                  </td><td>(Z &or; (S &oplus; V))=0</td></tr>
<tr><td>LE   </td><td>less than or equal            </td><td>(Z &or; (S &oplus; V))=1</td></tr>
<tr><td>UGE  </td><td>unsigned greater than or equal</td><td>C=0</td></tr>
<tr><td>ULT  </td><td>unsigned less than            </td><td>C=1</td></tr>
<tr><td>UGT  </td><td>unsigned greater than         </td><td>(C=0 &and; Z=0)=1</td></tr>
<tr><td>ULE  </td><td>unsigned less than or equal   </td><td>(C &or; Z)=1</td></tr>
</table>

<p>Poznámka: povšimněte si, že některé kódy jsou vlastně pouze aliasy na jiné
kódy. Příkladem může být kód <strong>C</strong> a <strong>UGE</strong>. Ve
skutečnosti existuje pouze čtrnáct unikátních podmínek doplněných o dvě
&bdquo;konstantní podmínky&ldquo; <i>always true</i> a <i>always false</i>.</p>



<p><a name="k10"></a></p>
<h2 id="k10">10. Instrukce Booleovského procesoru</h2>

<p>Podobně jako u mnoha dalších mikrořadičů nalezneme i u jader eZ8 instrukce,
které lze použít pro manipulaci s&nbsp;jednotlivými bity, popř.&nbsp;pro
aplikaci nějaké masky na celý bajt. Tyto instrukce jsou vypsány
v&nbsp;následující tabulce, navíc k&nbsp;nim můžeme přidat i výše popsané
podmíněné skoky <strong>BTJ</strong>, <strong>BTJZ</strong> a
<strong>BTJNZ</strong>:</p>

<table>
<tr><th>#</th><th>Instrukce</th><th>Operandy</th><th>Stručný popis</th></tr>
<tr><td>1</td><td>TM  </td><td>dst,src</td><td>(NOT dst) AND src s&nbsp;nastavením příznaků <i>zero</i> a <i>sign</i></td></tr>
<tr><td>2</td><td>TCM </td><td>dst,src</td><td>(NOT dst) AND src s&nbsp;nastavením příznaků <i>zero</i> a <i>sign</i></td></tr>
<tr><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td></tr>
<tr><td>3</td><td>BSET</td><td>bit, dst</td><td>nastavení bitu s&nbsp;indexem <i>bit</i> na jedničku</td></tr>
<tr><td>4</td><td>BCLR</td><td>bit, dst</td><td>vynulování bitu s&nbsp;indexem <i>bit</i></td></tr>
<tr><td>5</td><td>BIT </td><td>p, bit, dst</td><td>nastavení bitu s&nbsp;indexem <i>bit</i> na hodnotu <i>p</i></td></tr>
</table>

<p>I v&nbsp;této skupině nalezneme instrukce s&nbsp;rozšířenými adresovacími
režimy, které dokážou přistupovat do celé dostupné RAM:</p>

<table>
<tr><th>#</th><th>Instrukce</th><th>Rozšířená varianta</th></tr>
<tr><td>1</td><td>TM </td><td>TMX</td></tr>
<tr><td>2</td><td>TCM</td><td>TCMX</td></tr>
</table>



<p><a name="k11"></a></p>
<h2 id="k11">11. Instrukce pro přenosy dat</h2>

<p>Skupina instrukcí pro přenos dat je poměrně rozsáhlá, a to z&nbsp;toho
důvodu, že je nutné rozlišit čtení/zápis do běžné datové paměti, čtení/zápis do
externí datové paměti (samozřejmě pokud je připojena) a konečně čtení
popř.&nbsp;v&nbsp;některém případě i zápis do paměti programu. Navíc si
povšimněte, že všechny přenosové instrukce se jmenují <strong>LD</strong>
(<i>load</i>), i když současně provádí i zápis (eZ8 má i pracovní registry
uloženy v&nbsp;paměti):</p>

<table>
<tr><th>#</th><th>Instrukce</th><th>Operandy</th><th>Stručný popis</th></tr>
<tr><td>1</td><td>LD  </td><td>dst,src</td><td>přenos bajtu v&nbsp;rámci datové paměti</td></tr>
<tr><td>2</td><td>LDC </td><td>dst,src</td><td>načtení konstanty z&nbsp;programové paměti</td></tr>
<tr><td>3</td><td>LDE </td><td>dst,src</td><td>přenos dat z/do externí datové paměti</td></tr>
<tr><td>4</td><td>LDWX</td><td>dst,src</td><td>načtení 16bitového slova</td></tr>
<tr><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td></tr>
<tr><td>5</td><td>LEA </td><td>dst,X(src)</td><td>výpočet dst ← src + X</td></tr>
<tr><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td></tr>
<tr><td>6</td><td>PUSH</td><td>src</td><td>uložení operandu <i>src</i> na zásobník</td></tr>
<tr><td>7</td><td>POP </td><td>dst</td><td>načtení operandu ze zásobníku a uložení na <i>dst</i></td></tr>
<tr><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td></tr>
<tr><td>8</td><td>CLR </td><td>dst</td><td>vynulování <i>dst</i></td></tr>
</table>

<p>Poznámka: při programování FLASH paměti může být cílovým operandem
<strong>LDC</strong> i paměť programu.</p>

<p>I v&nbsp;této skupině nalezneme instrukce s&nbsp;rozšířenými adresovacími
režimy, které dokážou přistupovat do celé dostupné RAM:</p>

<table>
<tr><th>#</th><th>Instrukce</th><th>Rozšířená varianta</th></tr>
<tr><td>1</td><td>PUSH</td><td>PUSHX</td></tr>
<tr><td>2</td><td>POP</td><td>POPX</td></tr>
<tr><td>3</td><td>LD</td><td>LDX</td></tr>
</table>



<p><a name="k12"></a></p>
<h2 id="k12">12. Blokové přenosy</h2>

<p>Předchozí skupinu instrukcí doplňují ještě dvě další instrukce pojmenované
<strong>LDCI</strong> a <strong>LDEI</strong>. Tyto instrukce dokážou načíst
data z&nbsp;programové paměti resp.&nbsp;z&nbsp;externí datové paměti a posléze
inkrementují adresu, z&nbsp;níž bylo načtení provedeno i adresu, na níž se
operand uložil. Tyto instrukce je tedy možné použít pro blokové přenosy dat,
například kombinací instrukcí <strong>LDCI</strong>+<strong>DJNZ</strong> či
<strong>LDEI</strong>+<strong>DJNZ</strong>:</p>

<table>
<tr><th>#</th><th>Instrukce</th><th>Operandy</th><th>Stručný popis</th></tr>
<tr><td>1</td><td>LDCI</td><td>dst,src</td><td>načtení konstanty z&nbsp;programové paměti + inkrementace adresy</td></tr>
<tr><td>2</td><td>LDEI</td><td>dst,src</td><td>načtení konstanty z&nbsp;externí datové paměti + inkrementace adresy</td></tr>
</table>

<p>Poznámka: při programování FLASH paměti může být cílovým operandem
<strong>LDCI</strong> i paměť programu.</p>



<p><a name="k13"></a></p>
<h2 id="k13">13. Práce s&nbsp;příznaky</h2>

<p>Mikrořadiče Z8 obsahují pouze tři instrukce, které umožňují přímou
manipulaci s&nbsp;příznakovými bity, konkrétně pouze s&nbsp;příznakem
<i>carry</i>. Všechny tyto instrukce mají délku instrukčního slova jeden bajt.
Pokud je nutné manipulovat i s&nbsp;ostatními příznakovými bity, lze to provést
přímým zápisem do registru <strong>FLAGS</strong>, který je umístěn na adrese
0xfc (ovšem zaplatíme za to nepatrně delším a pomalejším programem):</p>

<table>
<tr><th>#</th><th>Instrukce</th><th>Operandy</th><th>Stručný popis</th></tr>
<tr><td>1</td><td>RCF</td><td>&times;</td><td>vynulování příznaku <i>carry</i></td></tr>
<tr><td>2</td><td>SCF</td><td>&times;</td><td>nastavení příznaku <i>carry</i> na 1</td></tr>
<tr><td>3</td><td>CCF</td><td>&times;</td><td>negace příznaku <i>carry</i></td></tr>
</table>

<p>Tyto tři instrukce existují z&nbsp;toho důvodu, že se s&nbsp;<i>carry</i>
bitem manipuluje před provedením rotací.</p>



<p><a name="k14"></a></p>
<h2 id="k14">14. Instrukce pro řízení CPU</h2>

<p>Poslední skupinu tvoří instrukce určené pro řízení procesoru. Nalezneme zde
například instrukce pro povolení či zákaz přerušení (přerušení je však
registrováno v&nbsp;každém případě, i když je zakázáno), nastavení aktuálně
používané banky registrů, práce s&nbsp;watchdogem, zastavení procesoru
apod.:</p>

<table>
<tr><th> #</th><th>Instrukce</th><th>Operandy</th><th>Stručný popis</th></tr>
<tr><td> 1</td><td>EI  </td><td>&nbsp;</td><td>povolení přerušení</td></tr>
<tr><td> 2</td><td>DI  </td><td>&nbsp;</td><td>zákaz přerušení</td></tr>
<tr><td> 3</td><td>ATM </td><td>&nbsp;</td><td>zákaz přerušení a DMA přenosů pro další tři instrukce</td></tr>
<tr><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td></tr>
<tr><td> 4</td><td>NOP </td><td>&nbsp;</td><td>přeskok na následující instrukci</td></tr>
<tr><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td></tr>
<tr><td> 5</td><td>SRP </td><td>src</td><td>nastavení aktuálně používané banky registrů</td></tr>
<tr><td> 6</td><td>WDT </td><td>&nbsp;</td><td>znovunaplnění čítače watchdogu</td></tr>
<tr><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td></tr>
<tr><td> 7</td><td>STOP</td><td>&nbsp;</td><td>režim STOP</td></tr>
<tr><td> 8</td><td>HALT</td><td>&nbsp;</td><td>režim HALT</td></tr>
<tr><td> 9</td><td>BRK </td><td>&nbsp;</td><td>pozastavení (v&nbsp;debug režimu)</td></tr>
<tr><td>10</td><td>TRAP</td><td>vektor</td><td>uložení PC a FLAGS na zásobník, skok na adresu uloženou na @vector</td></tr>
</table>



<p><a name="k15"></a></p>
<h2 id="k15">15. Odkazy na Internetu</h2>

<ol>

<li>Z80 info<br />
<a href="http://www.z80.info/">http://www.z80.info/</a>
</li>

<li>Zilog (stránka firmy)<br />
<a href="http://www.zilog.com/">http://www.zilog.com/</a>
</li>

<li>Řada Z8 Encore<br />
<a href="http://www.zilog.com/index.php?option=com_product&task=product&businessLine=1&id=2&parent_id=2&Itemid=56">http://www.zilog.com/index.php?option=com_product&task=product&businessLine=1&id=2&parent_id=2&Itemid=56</a>
</li>

<li>New Zilog Z8051 Microcontrollers (už ne "new", článek je z roku 2012)<br />
<a href="http://microcontroller.com/news/Zilog_Z8051.asp">http://microcontroller.com/news/Zilog_Z8051.asp</a>
</li>

<li>Zilog: The First Decade: Z80, Z8 and the Z8000<br />
<a href="http://www.cpushack.com/2010/10/15/zilog-the-first-decade-z80-z8-and-the-z8000/">http://www.cpushack.com/2010/10/15/zilog-the-first-decade-z80-z8-and-the-z8000/</a>
</li>

<li>Docs for: Z8 Microcontroller (archivní stránka)<br />
<a href="http://www.oocities.org/siliconvalley/peaks/3938/z8_home.htm">http://www.oocities.org/siliconvalley/peaks/3938/z8_home.htm</a>
</li>

<li>8-BIT MCU Relevancy in 2011<br />
<a href="http://www.eeweb.com/blog/steve_darrough/8-bit-mcu-relevancy-in-2011">http://www.eeweb.com/blog/steve_darrough/8-bit-mcu-relevancy-in-2011</a>
</li>

<li>Zilog Z8 (Wikipedia)<br />
<a href="https://en.wikipedia.org/wiki/Zilog_Z8">https://en.wikipedia.org/wiki/Zilog_Z8</a>
</li>

<li>8-bit S08<br />
<a href="http://www.nxp.com/products/microcontrollers-and-processors/more-processors/8-16-bit-mcus/8-bit-s08:HCS08">http://www.nxp.com/products/microcontrollers-and-processors/more-processors/8-16-bit-mcus/8-bit-s08:HCS08</a>
</li>

<li>S08QB: 8-bit QB MCUs<br />
<a href="http://www.nxp.com/products/microcontrollers-and-processors/more-processors/8-16-bit-mcus/8-bit-s08/8-bit-s08-3.6v-mcus/8-bit-qb-mcus:S08QB">http://www.nxp.com/products/microcontrollers-and-processors/more-processors/8-16-bit-mcus/8-bit-s08/8-bit-s08-3.6v-mcus/8-bit-qb-mcus:S08QB</a>
</li>

<li>8-bit RS08<br />
<a href="http://www.nxp.com/products/microcontrollers-and-processors/more-processors/8-16-bit-mcus/8-bit-rs08:RS08FAMILY">http://www.nxp.com/products/microcontrollers-and-processors/more-processors/8-16-bit-mcus/8-bit-rs08:RS08FAMILY</a>
</li>

<li>Wikipedia: Motorola 68HC05<br />
<a href="http://en.wikipedia.org/wiki/Motorola_68HC05">http://en.wikipedia.org/wiki/Motorola_68HC05</a>
</li>

<li>Wikipedia: Freescale 68HC08<br />
<a href="http://en.wikipedia.org/wiki/68HC08">http://en.wikipedia.org/wiki/68HC08</a>
</li>

<li>Wikipedia: Freescale 68HC11<br />
<a href="http://en.wikipedia.org/wiki/68HC11">http://en.wikipedia.org/wiki/68HC11</a>
</li>

<li>Wikipedia: Freescale 68HC12<br />
<a href="http://en.wikipedia.org/wiki/Freescale_68HC12">http://en.wikipedia.org/wiki/Freescale_68HC12</a>
</li>

<li>HC05 Processor Families<br />
<a href="http://www.freescale.com/webapp/sps/site/overview.jsp?nodeId=01624684498633">http://www.freescale.com/webapp/sps/site/overview.jsp?nodeId=01624684498633</a>
</li>

<li>HC08 Processor Families<br />
<a href="http://www.freescale.com/webapp/sps/site/overview.jsp?nodeId=01624684497663">http://www.freescale.com/webapp/sps/site/overview.jsp?nodeId=01624684497663</a>
</li>

<li>Digital Core Design 68HC08 - HDL IP Core <br />
<a href="http://www.dcd.pl/acore.php?idcore=82">http://www.dcd.pl/acore.php?idcore=82</a>
</li>

<li>Freescale 68HC11<br />
<a href="http://www.freescale.com/webapp/sps/site/taxonomy.jsp?nodeId=01624684498635">http://www.freescale.com/webapp/sps/site/taxonomy.jsp?nodeId=01624684498635</a>
</li>

<li>Lifecycle of a CPU:<br />
<a href="http://www.cpushack.net/life-cycle-of-cpu.html">http://www.cpushack.net/life-cycle-of-cpu.html</a>
</li>

<li>Great Microprocessors of the Past and Present (V 13.4.0)<br />
<a href="http://jbayko.sasktelwebsite.net/cpu.html">http://jbayko.sasktelwebsite.net/cpu.html</a>
</li>

<li>SPI interface tutorial<br />
<a href="http://www.best-microcontroller-projects.com/spi-interface.html">http://www.best-microcontroller-projects.com/spi-interface.html</a></li>

<li>Serial Peripheral Interface Bus<br />
<a href="http://en.wikipedia.org/wiki/Serial_Peripheral_Interface_Bus">http://en.wikipedia.org/wiki/Serial_Peripheral_Interface_Bus</a></li>

<li>What is SPI?<br />
<a href="http://www.fpga4fun.com/SPI1.html">http://www.fpga4fun.com/SPI1.html</a></li>

<li>SPI - A simple implementation<br />
<a href="http://www.fpga4fun.com/SPI2.html">http://www.fpga4fun.com/SPI2.html</a></li>

<li>Bit-banging<br />
<a href="http://en.wikipedia.org/wiki/Bit-banging">http://en.wikipedia.org/wiki/Bit-banging</a></li>

<li>Joint Test Action Group<br />
<a href="http://en.wikipedia.org/wiki/JTAG">http://en.wikipedia.org/wiki/JTAG</a></li>

<li>I<sup>2</sup>C<br />
<a href="http://en.wikipedia.org/wiki/I2C">http://en.wikipedia.org/wiki/I2C</a></li>

<li>I<sup>2</sup> Background<br />
<a href="http://www.microport.tw/blognew.php?blog_no=7#theory">http://www.microport.tw/blognew.php?blog_no=7#theory</a></li>

<li>H8/3802, 38002S, 38004, 38104 (manuály k&nbsp;čipům)<br />
<a href="https://www.renesas.com/en-us/document/hw-manual?hwLayerShowFlg=true&prdLayerId=184&layerName=H8%252F3802%252C%2B38002S%252C%2B38004%252C%2B38104&coronrService=document-prd-search&hwDocUrl=%2Fen-us%2Fdoc%2Fproducts%2Fmpumcu%2F001%2Frej09b0024_h83802.pdf&hashKey=c5e1fa0a18c01e6c789bc7b5c0184ed9">https://www.renesas.com/en-us/document/hw-manual?hwLayerShowFlg=true&prdLayerId=184&layerName=H8%252F3802%252C%2B38002S%252C%2B38004%252C%2B38104&coronrService=document-prd-search&hwDocUrl=%2Fen-us%2Fdoc%2Fproducts%2Fmpumcu%2F001%2Frej09b0024_h83802.pdf&hashKey=c5e1fa0a18c01e6c789bc7b5c0184ed9</a>
</li>

<li>Addressing mode (Wikipedia)<br />
<a href="https://en.wikipedia.org/wiki/Addressing_mode">https://en.wikipedia.org/wiki/Addressing_mode</a>
</li>

<li>Renesas SH Instruction Set Summary<br />
<a href="http://shared-ptr.com/sh_insns.html">http://shared-ptr.com/sh_insns.html</a>
</li>

<li>SH-4 RISC Processor by HITACHI<br />
<a href="http://www.cs.umd.edu/~meesh/cmsc411/website/projects/risc/risc.htm">http://www.cs.umd.edu/~meesh/cmsc411/website/projects/risc/risc.htm</a>
</li>

<li>SH-4 RISC Processor<br />
<a href="http://www.cs.umd.edu/~meesh/cmsc411/website/projects/risc/sh-4.htm">http://www.cs.umd.edu/~meesh/cmsc411/website/projects/risc/sh-4.htm</a>
</li>

<li>SuperH RISC engine Family Features<br />
<a href="https://www.renesas.com/en-us/products/microcontrollers-microprocessors/superh/superh-features.html">https://www.renesas.com/en-us/products/microcontrollers-microprocessors/superh/superh-features.html</a>
</li>

<li>Orthogonal instruction set<br />
<a href="https://en.wikipedia.org/wiki/Orthogonal_instruction_set">https://en.wikipedia.org/wiki/Orthogonal_instruction_set</a>
</li>

<li>An introduction to the TI MSP430 low-power microcontrollers<br />
<a href="http://mspgcc.sourceforge.net/manual/c68.html">http://mspgcc.sourceforge.net/manual/c68.html</a>
</li>

<li>MSP430 LaunchPad Tutorials<br />
<a href="http://processors.wiki.ti.com/index.php/MSP430_LaunchPad_Tutorials">http://processors.wiki.ti.com/index.php/MSP430_LaunchPad_Tutorials</a>
</li>

<li>LaunchPad MSP430 Assembly Language Tutorial<br />
<a href="http://robotics.hobbizine.com/asmlau.html">http://robotics.hobbizine.com/asmlau.html</a>
</li>

<li>TI 16-bit and 32-bit microcontrollers<br />
<a href="http://www.ti.com/lsds/ti/microcontrollers_16-bit_32-bit/overview.page">http://www.ti.com/lsds/ti/microcontrollers_16-bit_32-bit/overview.page</a>
</li>

<li>Z86E04 Tutorial<br />
<a href="https://tiktakx.wordpress.com/2010/05/04/z86e04-tutorial/">https://tiktakx.wordpress.com/2010/05/04/z86e04-tutorial/</a>
</li>

<li>Z80 Instruction Set<br />
<a href="http://clrhome.org/table/">http://clrhome.org/table/</a>
</li>

<li>8080/Z80 Instruction Set<br />
<a href="http://nemesis.lonestar.org/computers/tandy/software/apps/m4/qd/opcodes.html">http://nemesis.lonestar.org/computers/tandy/software/apps/m4/qd/opcodes.html</a>
</li>

</ol>



<p></p><p></p>
<p><small>Autor: <a href="http://www.fit.vutbr.cz/~tisnovpa">Pavel Tišnovský</a> &nbsp; 2016</small></p>
</body>
</html>

