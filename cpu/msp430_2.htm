<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
        "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html>
<head>
<title>Šestnáctibitové mikrořadiče TI řady MSP430 - instrukční sada a periferní moduly</title>
<meta name="Author" content="Pavel Tisnovsky" />
<meta name="Generator" content="vim" />
<meta http-equiv="content-type" content="text/html; charset=utf-8" />
<style type="text/css">
         body {color:#000000; background:#ffffff;}
         h1  {font-family: arial, helvetica, sans-serif; color:#ffffff; background-color:#c00000; text-align:center; padding-left:1em}
         h2  {font-family: arial, helvetica, sans-serif; color:#ffffff; background-color:#0000c0; padding-left:1em; text-align:left}
         h3  {font-family: arial, helvetica, sans-serif; color:#000000; background-color:#c0c0c0; padding-left:1em; text-align:left}
         h4  {font-family: arial, helvetica, sans-serif; color:#000000; background-color:#e0e0e0; padding-left:1em; text-align:left}
         a   {font-family: arial, helvetica, sans-serif;}
         li  {font-family: arial, helvetica, sans-serif; color:#000000; text-align:justify; width:450px;}
         ol  {font-family: arial, helvetica, sans-serif; color:#000000; text-align:justify; width:450px;}
         ul  {font-family: arial, helvetica, sans-serif; color:#000000; text-align:justify; width:450px;}
         p   {font-family: arial, helvetica, sans-serif; color:#000000; text-align:justify;}
         pre {background:#e0e0e0}
</style>
</head>

<body>

<h1>Šestnáctibitové mikrořadiče TI řady MSP430 - instrukční sada a periferní moduly</h1>

<h3>Pavel Tišnovský</h3>

<p></p>

<h1>Úvodník</h1>

<p>Popis šestnáctibitových mikrořadičů MSP430 společnosti Texas Instruments, s nimiž jsme se seznámili v předchozím článku, dnes dokončíme. Kromě podrobnějšího popisu instrukční sady se zmíníme i o základních periferních modulech, jimiž bývají tyto čipy vybaveny.</p>



<h2>Obsah</h2>

<p><a href="#k01">1. Šestnáctibitové mikrořadiče TI řady MSP430 &ndash; instrukční sada a periferní moduly</a></p>
<p><a href="#k02">2. Instrukce pro přesuny dat</a></p>
<p><a href="#k03">3. Aritmetické instrukce</a></p>
<p><a href="#k04">4. Logické instrukce</a></p>
<p><a href="#k05">5. Manipulace s&nbsp;jednotlivými bity (maskování)</a></p>
<p><a href="#k06">6. Bitové rotace a aritmetické posuny</a></p>
<p><a href="#k07">7. Podmíněné a nepodmíněné skoky</a></p>
<p><a href="#k08">8. Základní periferní moduly čipů řady MSP430</a></p>
<p><a href="#k09">9. Hardwarová násobička</a></p>
<p><a href="#k10">10. Ovládání vstupně-výstupních pinů</a></p>
<p><a href="#k11">11. UART</a></p>
<p><a href="#k12">12. SPI</a></p>
<p><a href="#k13">13. I<sup>2</sup>C</a></p>
<p><a href="#k14">14. Obsah další části seriálu</a></p>
<p><a href="#k15">15. Odkazy na Internetu</a></p>



<p><a name="k01"></a></p>
<h2 id="k01">1. Šestnáctibitové mikrořadiče TI řady MSP430 &ndash; instrukční sada a periferní moduly</h2>

<p><a
href="https://www.root.cz/clanky/sestnactibitove-mikroradice-ti-rady-msp430/">V&nbsp;předchozí
části</a> <a href="http://www.root.cz/serialy/co-se-deje-v-pocitaci/">seriálu o
architekturách počítačů</a> jsme se seznámili se základními vlastnostmi
šestnáctibitových mikrořadičů MSP430 vyráběných společností Texas Instruments.
Dnes si nejprve podrobněji popíšeme instrukční sadu těchto čipů a ve druhé
části článku se budeme zabývat základními periferními moduly, kterými jsou tyto
čipy většinou vybaveny.</p>

<p>Již minule jsme si řekli, že instrukční sada MSP430 je pojata velmi
minimalisticky, protože obsahuje pouze 27 instrukcí. Ovšem díky tomu, že
zdrojovým či cílovým operandem instrukcí může být i nějaký speciální registr
(typicky stavový a řídicí registr) a taktéž díky čtyřem adresovacím režimům je
možné, aby oněch &bdquo;pouhých&ldquo; 27 instrukcí ve skutečnosti mohlo
nahradit i velké množství dalších instrukcí, které zdánlivě v&nbsp;instrukční
sadě chybí. V&nbsp;následující tabulce jsou vypsány všechny základní instrukce,
v&nbsp;navazujících kapitolách se pak seznámíme i s&nbsp;různými aliasy, které
jsou standardně podporovány assemblery a lze je tedy použít i v&nbsp;reálných
programech.</p>

<table>
<tr><th>Skupina</th><th>Instrukce</th><th>Celkem</th></tr>
<tr><td><a href="#k02">Instrukce pro přesuny dat</a></td><td>MOV, SWPB, PUSH</td><td>3</td></tr>
<tr><td><a href="#k03">Aritmetické instrukce</a></td><td>ADD, ADDC, SUB, SUBC, CMP, DADD, SXT</td><td>7</td></tr>
<tr><td><a href="#k04">Logické instrukce</a></td><td>AND, XOR</td><td>2</td></tr>
<tr><td><a href="#k05">Manipulace s&nbsp;jednotlivými bity</a></td><td>BIT, BIC, BIS</td><td>3</td></tr>
<tr><td><a href="#k06">Bitové rotace a posuny</a></td><td>RRC, RRA</td><td>2</td></tr>
<tr><td><a href="#k07">Podmíněné a nepodmíněné skoky</a></td><td>CALL, RETI, JEQ, JNE, JC, JNC, JN, JGE, JL, JMP</td><td>10</td></tr>
<tr><td>Celkem:</td><td>&nbsp;</td><th>27</th></tr>
</table>

<p>Na úvod si ještě připomeňme možnosti, které programátorům poskytují
adresovací režimy:</p>

<h3>Adresovací režimy pro zdrojový operand</h3>

<table>
<tr><th>Bity v instrukci</th><th>Zápis v&nbsp;assembleru</th><th>Název režimu</th><th>Stručný popis</th></tr>
<tr><td>00</td><td>Rn</td><td>Register direct</td><td>registr Rn obsahuje zdrojový operand</td></tr>
<tr><td>01</td><td>offset(Rn)</td><td>Register indexed</td><td>zdrojový operand je uložen na adrese Rn+offset</td></tr>
<tr><td>10</td><td>@Rn</td><td>Register indirect</td><td>registr Rn je použit ve funkci ukazatele</td></tr>
<tr><td>11</td><td>@Rn+</td><td>Register indirect with post-increment</td><td>stejné jako předchozí režim, ovšem registr je po provedení operace zvýšen o 1 či 2 podle typu operandů (bajt či slovo)</td></tr>
</table>

<p>V&nbsp;případě, že je použit režim <strong>offset(Rn)</strong>, je ihned za
instrukčním slovem uložen šestnáctibitový offset. Instrukce tedy mohou mít
proměnnou délku.</p>



<h3>Adresovací režimy pro cílový operand</h3>

<table>
<tr><th>Bity v instrukci</th><th>Zápis v&nbsp;assembleru</th><th>Název režimu</th><th>Stručný popis</th></tr>
<tr><td>0</td><td>Rn</td><td>Register direct</td><td>do registru Rn je zapsán výsledek operace</td></tr>
<tr><td>1</td><td>offset(Rn)</td><td>Register indexed</td><td>výsledek operace bude uložen na adresu Rn+offset</td></tr>
</table>

<p>Opět platí, že pokud je použit režim <strong>offset(Rn)</strong>, je ihned
za instrukčním slovem uložen šestnáctibitový offset.</p>



<p><a name="k02"></a></p>
<h2 id="k02">2. Instrukce pro přesuny dat</h2>

<p>Skupina instrukcí určených pro přenosy dat je velmi malá, protože v&nbsp;ní
nalezneme pouhé tři instrukce. První instrukce slouží pro přenos dat mezi
registry či mezi různými adresami paměti (v&nbsp;závislosti na použitých
adresovacích režimech). Druhá instrukce slouží k&nbsp;prohození vyššího a
nižšího bajtu operandu (opět registru popř.&nbsp;adresy v&nbsp;operační paměti)
a instrukce třetí uloží osmibitový či šestnáctibitový operand na zásobník
adresovaný registrem R1:</p>

<table>
<tr><th>Instrukce</th><th>Operandy</th><th>Šířka operandů</th><th>Význam instrukce</th></tr>
<tr><td>MOV </td><td>src, dest</td><td>8/16bit</td><td>přesun bajtu či slova mezi registry a/nebo operační pamětí</td></tr>
<tr><td>SWPB</td><td>dest</td><td>16bit</td><td>prohození horního bajtu operandu s&nbsp;bajtem spodním</td></tr>
<tr><td>PUSH</td><td>src</td><td>8/16bit</td><td>uložení operandu na zásobník</td></tr>
</table>

<p>Vhodnou kombinací adresovacích režimů popř.&nbsp;registrů se speciálním
způsobem použití lze instrukcí <strong>MOV</strong> simulovat i další
instrukce. Běžné assemblery rozpoznávají následující čtveřici instrukčních
aliasů:</p>

<table>
<tr><th>Alias</th><th>Skutečná instrukce</th><th>Význam instrukce</th></tr>
<tr><td>CLR dest</td><td>MOV #0, dest</td><td>vynulování operandu</td></tr>
<tr><td>NOP     </td><td>MOV #0, R3</td><td>vynulování nulového registru (tudíž se stav MCU nezmění)</td></tr>
<tr><td>POP dest</td><td>MOV @SP+, dest</td><td>obnovení operandu ze zásobníku</td></tr>
<tr><td>RET     </td><td>MOV @SP+, PC</td><td>obnovení PC ze zásobníku</td></tr>
</table>

<p>Poznámka: obsah registru R3 se při zápisu nemění &ndash; stále obsahuje
nulu.</p>



<p><a name="k03"></a></p>
<h2 id="k03">3. Aritmetické instrukce</h2>

<p>Skupina aritmetických instrukcí je již rozsáhlejší, neboť zde nalezneme jak
základní aritmetické instrukce pro součet a rozdíl (při výpočtu rozdílu se
příznak carry chápe v&nbsp;negativním významu, tj.&nbsp;jako borrow), tak i
instrukci pro součet hodnot uložených v&nbsp;BCD kódu. Poslední instrukce
slouží pro znaménkové rozšíření bajtu na šestnáctibitové slovo (původní
nejvyšší bit bajtu je rozšířen do horní poloviny šestnáctibitového slova):</p>

<table>
<tr><th>Instrukce</th><th>Operandy</th><th>Šířka operandů</th><th>Význam instrukce</th></tr>
<tr><td>ADD </td><td>src, dest</td><td>8/16bit</td><td>výpočet dest+src &rarr; dest, nastavení příznaků</td></tr>
<tr><td>ADDC</td><td>src, dest</td><td>8/16bit</td><td>výpočet dest+src+carry &rarr; dest, nastavení příznaků</td></tr>
<tr><td>SUB </td><td>src, dest</td><td>8/16bit</td><td>výpočet dest-src &rarr; dest, nastavení příznaků</td></tr>
<tr><td>SUBC</td><td>src, dest</td><td>8/16bit</td><td>výpočet dest-src-1+carry &rarr; dest, nastavení příznaků</td></tr>
<tr><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td></tr>
<tr><td>CMP </td><td>src, dest</td><td>8/16bit</td><td>jako ADD, ovšem pouze dojde k&nbsp;nastavení operandů bez uložení výsledku</td></tr>
<tr><td>DADD</td><td>src, dest</td><td>8/16bit</td><td>součet, ovšem v&nbsp;kódu BCD</td></tr>
<tr><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td></tr>
<tr><td>SXT</td><td>dest</td><td>8bit&rarr;16bit</td><td>znaménkové rozšíření bajtu na slovo</td></tr>
</table>

<p>Assemblery dále rozeznávají několik dalších aliasů instrukcí, což jsou
vlastně pseudoinstrukce, které se interně překládají do obecnějších instrukcí.
U těchto instrukcí si povšimněte, že je použito <i>generátorů konstant</i>, o
nichž jsme se zmínili minule:</p>

<table>
<tr><th>Alias</th><th>Skutečná instrukce</th><th>Význam instrukce</th></tr>
<tr><td>ADC dest </td><td>ADDC #0, dest</td><td>přičtení příznaku carry k&nbsp;operandu</td></tr>
<tr><td>SBC dest </td><td>SUBC #0, dest</td><td>odečtení příznaku carry k&nbsp;operandu</td></tr>
<tr><td>DADC dest</td><td>DADD #0, dest</td><td>přičtení příznaku carry k&nbsp;operandu (decimální mód)</td></tr>
<tr><td>INC      </td><td>ADD #1, dest</td><td>inkrementace operandu</td></tr>
<tr><td>INCD     </td><td>ADD #2, dest</td><td>inkrementace operandu (o dvojku)</td></tr>
<tr><td>DEC      </td><td>SUB #1, dest</td><td>dekrementace operandu</td></tr>
<tr><td>DECD     </td><td>SUB #2, dest</td><td>dekrementace operandu (o dvojku)</td></tr>
<tr><td>TST      </td><td>CMP #0, dest</td><td>porovnání operandu s&nbsp;nulou + nastavení příznaků</td></tr>
</table>

<p>Poznámka: výpočty v&nbsp;kódu BCD (tj.&nbsp;dvě číslice v&nbsp;případě bajtu
a čtyři číslice v&nbsp;případě 16bitového slova) se používají například ve
chvíli, kdy má mikrořadič ovládat LCD atd., protože u těchto displejů se mnohdy
používá právě BCD a nikoli binární kód.</p>



<p><a name="k04"></a></p>
<h2 id="k04">4. Logické instrukce</h2>

<p>Skupina logických instrukcí je (ovšem opět pouze zdánlivě) velmi malá,
protože zde nalezneme pouhé dvě základní instrukce vypsané v&nbsp;následující
tabulce:</p>

<table>
<tr><th>Instrukce</th><th>Operandy</th><th>Šířka operandů</th><th>Význam instrukce</th></tr>
<tr><td>AND</td><td>src, dest</td><td>8/16bit</td><td>logický součin bit po bitu + nastavení příznaků</td></tr>
<tr><td>XOR</td><td>src, dest</td><td>8/16bit</td><td>logická nonekvivalence bit po bitu + nastavení příznaků</td></tr>
</table>

<p>Poznámka: zdánlivě chybějící instrukce <strong>OR</strong> má ve skutečnosti
odlišné jméno, viz též následující kapitolu.</p>

<p>Jedním z&nbsp;možných aliasů je instrukce pro negaci operandu, ať již
osmibitového či šestnáctibitového. Konstanta -1 (tedy 0xffff) je vytvořena
generátorem konstant:</p>

<table>
<tr><th>Alias</th><th>Skutečná instrukce</th><th>Význam instrukce</th></tr>
<tr><td>INV.B dest</td><td>XOR #0ff, dest</td><td>negace operandu</td></tr>
<tr><td>INV dest </td><td>XOR #0ffff, dest</td><td>negace operandu</td></tr>
</table>



<p><a name="k05"></a></p>
<h2 id="k05">5. Manipulace s&nbsp;jednotlivými bity (maskování)</h2>

<p>Skupina dalších tří instrukcí vlastně rozšiřuje možnosti logických instrukcí
popsaných v&nbsp;předchozí kapitole. Instrukce <strong>BIT</strong> je obdobou
instrukce <strong>AND</strong>, ovšem výsledek operace se nikam neuloží; dojde
pouze k&nbsp;ovlivnění příznakových bitů. Instrukce <strong>BIC</strong> může
sloužit k&nbsp;maskování (vynulování) vybraných bitů na základě zadané masky.
Ta je nejprve znegována, takže jedničkové bity v&nbsp;masce skutečně slouží
k&nbsp;určení toho, které bity mají být vynulovány. Opakem je instrukce
<strong>BIS</strong>, která provádí prostý logický součet bit po bitu a tudíž
tato instrukce nahrazuje běžné <strong>OR</strong>:</p>

<table>
<tr><th>Instrukce</th><th>Operandy</th><th>Šířka operandů</th><th>Význam instrukce</th></tr>
<tr><td>BIT</td><td>src, dest</td><td>8/16bit</td><td>logický součin bit po bitu bez uložení výsledku + nastavení příznaků</td></tr>
<tr><td>BIC</td><td>src, dest</td><td>8/16bit</td><td>logický součin dest := ~src &amp; dest</td></tr>
<tr><td>BIS</td><td>src, dest</td><td>8/16bit</td><td>logický součet dest := src | dest</td></tr>
</table>

<p>Opět se podívejme na (na první pohled možná poněkud skryté) možnosti těchto
instrukcí, například při manipulaci s&nbsp;příznakovými bity uloženými
v&nbsp;registru R2:</p>

<table>
<tr><th>Alias</th><th>Skutečná instrukce</th><th>Význam instrukce</th></tr>
<tr><td>CLRC</td><td>BIC #1, SR</td><td>vynulování příznaku carry</td></tr>
<tr><td>CLRN</td><td>BIC #4, SR</td><td>vynulování příznaku negative</td></tr>
<tr><td>CLRZ</td><td>BIC #2, SR</td><td>vynulování příznaku zero</td></tr>
<tr><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td></tr>
<tr><td>SETC</td><td>BIS #1, SR</td><td>nastavení příznaku carry</td></tr>
<tr><td>SETN</td><td>BIS #4, SR</td><td>nastavení příznaku negative</td></tr>
<tr><td>SETZ</td><td>BIS #2, SR</td><td>nastavení příznaku zero</td></tr>
<tr><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td></tr>
<tr><td>DINT</td><td>BIC #8, SR</td><td>zákaz přerušení</td></tr>
<tr><td>EINT</td><td>BIS #8, SR</td><td>povolení přerušení</td></tr>
</table>

<p>Můžeme zde vidět, že kombinace minimalistické instrukční sady, adresovacích
režimů, speciálních registrů &bdquo;vložených&ldquo; do sady běžných registrů a
generátorů adres může být velmi elegantní.</p>



<p><a name="k06"></a></p>
<h2 id="k06">6. Bitové rotace a aritmetické posuny</h2>

<p>Instrukce pro bitové rotace a aritmetické posuny jsou ve skutečnosti pouze
dvě. Jedná se o bitovou rotaci bajtu či slova doprava, a to přes příznak carry.
To znamená, že rotace vypadá následovně:</p>

<pre>
+---+---+---+---+---+---+---+---+       +-------+
| 7 | 6 | 5 | 4 | 3 | 2 | 1 | 0 |---&gt;---| Carry |
+---+---+---+---+---+---+---+---+       +-------+
  ^                                         |
  |                                         v
  +-----------------------------------------+
</pre>

<p>Aritmetický posun doprava zachovává znaménko a současně je nejnižší bit
nasunut do příznaku carry:</p>

<pre>
    +---+---+---+---+---+---+---+---+       +-------+
+-&gt;-| 7 | 6 | 5 | 4 | 3 | 2 | 1 | 0 |---&gt;---| Carry |
|   +---+---+---+---+---+---+---+---+       +-------+
|     |
|     v
+-----+
</pre>

<p>Obě zmíněné instrukce jsou vypsány v&nbsp;následující tabulce:</p>

<table>
<tr><th>Instrukce</th><th>Operandy</th><th>Šířka operandů</th><th>Význam instrukce</th></tr>
<tr><td>RRC</td><td></td><td>8/16bit</td><td>bitová rotace doprava přes carry</td></tr>
<tr><td>RRA</td><td></td><td>8/16bit</td><td>aritmetický posun doprava</td></tr>
</table>

<p>Zajímavá a pro minimalistickou instrukční sadu jader MSP430 vlastně dosti
typická je absence instrukcí pro posun a rotaci doleva. Tyto instrukce totiž
mohou být snadno emulovány instrukcemi pro součet, takže assemblery sice
rozeznávají instrukce <strong>RLC</strong> a <strong>RLA</strong>, ovšem tyto
instrukce jsou při překladu nahrazeny instrukcemi <strong>ADDC</strong> a
<strong>ADD</strong>:</p>

<table>
<tr><th>Alias</th><th>Skutečná instrukce</th><th>Význam instrukce</th></tr>
<tr><td>RLC dest</td><td>ADDC dest,dest</td><td>rotace doleva přes příznak carry</td></tr>
<tr><td>RLA dest</td><td>ADD  dest dest</td><td>aritmetický posun doleva</td></tr>
</table>

<p>Poznámka: aliasy jsou platné jak pro osmibitové operandy, tak i pro operandy
šestnáctibitové.</p>



<p><a name="k07"></a></p>
<h2 id="k07">7. Podmíněné a nepodmíněné skoky</h2>

<p>Zbylých deset instrukcí slouží pro provádění podmíněných a nepodmíněných
skoků, popř.&nbsp;pro volání podprogramů (subrutin) a návratu z&nbsp;přerušení.
Pro volání subrutin s&nbsp;uložením návratové adresy slouží instrukce
<strong>CALL</strong>, která může použít jak adresu uloženou v&nbsp;registru,
tak i v&nbsp;operační paměti (jsou povoleny všechny adresovací režimy).
Speciální instrukce bez operandů nazvaná <strong>RETI</strong> pak slouží
k&nbsp;obnovení registrů PC a SR, což v&nbsp;dalším taktu způsobí návrat
z&nbsp;přerušovací rutiny (přerušení je většinou vyvoláno hardwarově):</p>

<table>
<tr><th>Instrukce</th><th>Operandy</th><th>Šířka operandů</th><th>Význam instrukce</th></tr>
<tr><td>CALL</td><td>dest</td><td>16bit</td><td>uložení PC + skok na adresu specifikovanou v&nbsp;operandu</td></tr>
<tr><td>RETI</td><td>&times;</td><td>&times;</td><td>obnovení registrů PC + SR, návrat z&nbsp;přerušení</td></tr>
</table>

<p>O podmíněných a nepodmíněných skocích jsme se již zmínili minule, takže si
jen stručně připomeňme, že se u těchto instrukcí specifikuje testovaná podmínka
(resp.&nbsp;přesněji řečeno sedm podmínek + jeden nepodmíněný skok, tak i
desetibitový offset vůči registru PC. Offset je před použitím vynásoben dvěma,
protože instrukce mohou začínat vždy pouze na sudé adrese. Rozsah offsetu je
tedy PC-1022 až PC+1024:</p>

<table>
<tr><th>#</th><th>Instrukce</th><th>Operandy</th><th>Alias</th><th>Význam instrukce</th></tr>
<tr><td>000</td><td>JEQ</td><td>10bit offset</td><td>JZ </td><td>skok při podmínce zero_flag==1</td></tr>
<tr><td>001</td><td>JNE</td><td>10bit offset</td><td>JNZ</td><td>skok při podmínce zero_flag==0</td></tr>
<tr><td>010</td><td>JC </td><td>10bit offset</td><td>JHS</td><td>skok při podmínce carry_flag==1</td></tr>
<tr><td>011</td><td>JNC</td><td>10bit offset</td><td>JLO</td><td>skok při podmínce carry_flag==0</td></tr>
<tr><td>100</td><td>JN </td><td>10bit offset</td><td>&times;</td><td>skok při podmínce negative_flag==1 (obrácená podmínka neexistuje)</td></tr>
<tr><td>101</td><td>JGE</td><td>10bit offset</td><td>&times;</td><td>skok při podmínce negative_flag &oplus; overflow_flag==0</td></tr>
<tr><td>110</td><td>JL </td><td>10bit offset</td><td>&times;</td><td>skok při podmínce negative_flag &oplus; overflow_flag==1</td></tr>
<tr><td>111</td><td>JMP</td><td>10bit offset</td><td>&times;</td><td>nepodmíněný skok</td></tr>
</table>

<p>Poslední instrukční alias je vlastně skutečným absolutním skokem na zadanou
adresu (kdežto <strong>JMP</strong> je v&nbsp;kontextu tohoto mikrořadiče skok
relativní):</p>

<table>
<tr><th>Alias</th><th>Skutečná instrukce</th><th>Význam instrukce</th></tr>
<tr><td>BR dest</td><td>MOV dest, PC</td><td></td></tr>
</table>



<p><a name="k08"></a></p>
<h2 id="k08">8. Základní periferní moduly čipů řady MSP430</h2>

<p>Čipy řady MSP430 jsou v&nbsp;současnosti používány v&nbsp;těch zařízeních, u
nichž je kritickým faktorem spotřeba popř.&nbsp;velikost čipu. I z&nbsp;tohoto
důvodu v&nbsp;této řadě nalezneme velké množství čipů (cca 450) s&nbsp;různou
konfigurací, takže si konstruktéři zařízení mohou vybrat ten mikrořadič, který
nejlépe odpovídá jejich potřebám, tj.&nbsp;obsahuje jen ty moduly, které jsou
skutečně zapotřebí. Jeden z&nbsp;nejméně výkonných mikrořadičů MSP430 má při
taktovací frekvenci 16 MHz (dříve 4MHz) 128 bajtů RAM, 2kB programovatelné ROM,
10 GPIO pinů, jeden časovač, jednu sběrnici I<sup>2</sup>C a SPI a watchdog. Na
druhé straně výkonnostního spektra nalezneme čipy s&nbsp;frekvencí 25 MHz, 32
kB RAM a 90 GPIO piny (typická mez je však 48 GPIO organizovaných do šesti
portů). Z&nbsp;těchto důvodů plyne, že dále uvedený popis periferních modulů
není platný pro všechny existující mikrořadiče řady MSP430, nicméně většinu
modulů (typicky sériové sběrnice, časovače a watchdog) nalezneme u většiny
čipů.</p>



<p><a name="k09"></a></p>
<h2 id="k09">9. Hardwarová násobička</h2>

<p>Při popisu instrukční sady jste si mohli povšimnout, že sada aritmetických
instrukcí vlastně ve skutečnosti obsahuje pouze instrukce pro součet a rozdíl,
nikoli již například instrukce sloužící pro vynásobení operandů. To je pravda,
protože násobička je na jádrech MSP430 jedním z&nbsp;přídavných hardwarových
modulů a ovládá se přes SFR (speciální funkční registry) a nikoli přímo
programovým kódem. Toto řešení sice může vypadat minimálně zvláštně, ve
skutečnosti však MSP430 nejsou jediná procesorová jádra, která s&nbsp;tímto
řešením přišla; ostatně násobička se ovládá speciálním způsobem i u původních
RISCových mikroprocesorů MIPS apod.</p>

<p>Násobička se skutečně chová jako samostatný modul, což znamená, že procesor
může nezávisle na činnosti násobičky provádět jiné instrukce, číst výsledky
násobení atd. K&nbsp;násobičce jsou přiřazeny čtyři šestnáctibitové registry
pro vstup operandů a čtyři další registry (výsledek operace, rozšíření znaménka
atd.)</p>

<p>Mezi podporované operace patří:</p>

<ol>
<li>Vynásobení dvou celých čísel bez znaménka (<i>unsigned</i>).</li>
<li>Vynásobení dvou celých čísel se znaménkem (<i>signed</i>).</li>
<li>Operace typu MAC (multiply accumulate) s&nbsp;typem <i>unsigned</i>.</li>
<li>Operace typu MAC (multiply accumulate) s&nbsp;typem <i>signed</i>.</li>
</ol>

<p>Při násobení lze navíc kombinovat šířku operandů:</p>

<ol>
<li>8&times;8 bitů</li>
<li>8&times;16 bitů</li>
<li>16&times;8 bitů</li>
<li>16&times;16 bitů (výsledek násobení či MAC je 32bitový)</li>
</ol>



<p><a name="k10"></a></p>
<h2 id="k10">10. Ovládání vstupně-výstupních pinů</h2>

<p>Podobně, jako prakticky všechny ostatní mikrořadiče, obsahují i čipy
s&nbsp;jádry MSP430 podporu pro programové ovládání vstupně-výstupních pinů
(GPIO). Vstupně-výstupní piny jsou organizovány takovým způsobem, že každá
osmice tvoří jeden I/O port, přičemž čipy MSP430 mohou podle své konfigurace
obsahovat jeden až šest portů označovaných jmény P1 až P6 (některé porty navíc
nemusí být úplné, tj.&nbsp;nemusí pro ně existovat všech osm pinů). Porty mají
společné vlastnosti, některé vlastnosti jsou však unikátní pro první a druhý
port:</p>

<ul>

<li>Každý I/O pin portu je konfigurovatelný nezávisle na ostatních pinech.</li>

<li>Každý pin může být přepnutý do výstupního režimu či do režimu
vstupního.</li>

<li>Navíc je možné u některých pinů vybrat jejich funkci, protože u mnoha
mikrořadičů je funkce pinu sdílena více moduly (GPIO+IIC, GPIO+DAC+PWM
atd.)</li>

<li>U portů P1 a P2 je možné zvolit, za jakých okolností dojde
k&nbsp;přerušení. Například je možné reagovat na úroveň signálu, hranu signálu
atd. Přerušení pro port P1 je odlišné od přerušení pro port P2.</li>

</ul>



<p><a name="k11"></a></p>
<h2 id="k11">11. UART</h2>

<p>Na čipech MSP430 můžeme najít i jedno či dvě rozhraní <i>USART</i>
(<i>Universal Synchronous/Asynchronous Receive/Transmit</i>), které může
pracovat buď v&nbsp;synchronním režimu či v&nbsp;režimu asynchronním
<i>UART</i> (<i>Universal Asynchronous Receive/Transmit</i>). Při asynchronním
přenosu dat se používá známý protokol bez použití samostatného hodinového
signálu, v&nbsp;němž přenos začíná start bitem, pokračuje datovými bity,
následuje volitelný paritní bit a celý přenos končí stop bitem či stop bity.
Přitom je možné pomocí konfiguračních voleb zapisovaných do SFR nastavit
následující parametry přenosu:</p>

<ol>

<li>Počet datových bitů: 7 nebo 8 (některé jiné UARTy podporují i 5 bitů, tento
režim se však příliš často nepoužívá).</li>

<li>Význam paritního bitu: sudá parita, lichá parita, bez paritního bitu.</li>

<li>Počet stop bitů: jeden či dva (opět platí, že některé jiné UARTy podporují
i 1,5 stop bitu).</li>

<li>Rychlost přenosu (baud rate), včetně typických rychlostí 1200, 2400, 4800,
9600, 38400 i 115200 baudů (ve skutečnosti není rychlost vypočtena zcela
přesně, záleží na konkrétní volbě frekvence hodinového signálu, z&nbsp;něhož se
dělením získává rychlost přenosu).</li>

</ol>

<p>Poznámka: na rozdíl od známého sériového portu RS-232C se na fyzické úrovni
používají logické úrovně signálu odvozené od napájecího napětí. Naproti tomu se
u RS-232C setkáme s&nbsp;napětími až &plusmn;15V (typicky &plusmn;3 až
&plusmn;12).</p>

<img src="https://i.iinfo.cz/images/101/msp430-1.png" class="image-270208" alt="&#160;" width="440" height="331" />
<p><i>Obrázek 1: V&nbsp;asynchronním režimu je nutné každý přijímaný bit
několikrát samplovat, aby mohlo dojít k&nbsp;synchronizaci hodin. Ve spodní
části obrázku je ukázáno, co se stane, když se hodiny vysílače a přijímače
rozsynchronizují (v&nbsp;režimu UART se hodinový signál nepřenáší).</i></p>



<p><a name="k12"></a></p>
<h2 id="k12">12. SPI</h2>

<p>Sběrnice <i>SPI</i> (<i>Serial Peripheral Interface</i>) představuje jednu
z&nbsp;forem sériových externích sběrnic sloužících pro vzájemné propojení dvou
či více komunikujících uzlů, přičemž jeden uzel obvykle vystupuje v&nbsp;roli
takzvaného řadiče sběrnice (<i>master</i>), ostatní uzly pracují v&nbsp;režimu
<i>slave</i>. Uzel, který pracuje jako <i>master</i>, obsahuje generátor
hodinového signálu, který je rozveden do všech ostatních uzlů, čímž je umožněn
zcela synchronní (navíc ještě obousměrný) přenos dat. Hodinový signál je
rozváděn vodičem označovaným symbolem <i>SCK</i>. Kromě vodiče s&nbsp;hodinovým
signálem jsou uzly propojeny dvojicí vodičů označovaných většinou symboly
<i>MISO</i> (Master In, Slave Out) a <i>MOSI</i> (Master Out, Slave In), pomocí
nichž se obousměrně (full duplex) přenáší data. Posledním signálem, který se u
této sběrnice používá, je signál <i>SSEL</i> (Slave Select), jenž slouží
&ndash; jak již jeho název napovídá &ndash; k&nbsp;výběru některého uzlu
pracujícího v&nbsp;režimu <i>slave</i>. Všechny čtyři signály &ndash;
<i>SCK</i>, <i>MISO</i>, <i>MOSI</i> i <i>SSEL</i>, pro svoji funkci vyžadují
pouze jednosměrné porty, což přispívá k&nbsp;jednoduché a především levné
implementaci této sběrnice; proto ji najdeme u většiny mikrořadičů.</p>

<img src="https://i.iinfo.cz/images/101/msp430-2.jpg" class="image-270209" alt="&#160;" width="314" height="380" />
<p><i>Obrázek 2: Převaděč mezi universální sériovou sběrnicí (USB) a sběrnicí
SPI. Pomocí tohoto či podobného přípravku je možné i z&nbsp;běžného osobního
počítače ovládat mnoho existujících typů zařízení určených pro sběrnici
SPI.</i></p>

<p>U čipů MSP430 se používá nepatrně odlišné označení signálů &ndash;
<i>SIMO</i>, <i>SOMI</i>, <i>UCLK</i> a <i>STE</i>, ovšem jejich význam je
shodný se signály zmíněnými v&nbsp;předchozím odstavci. Mikrořadiče MSP430
mohou být nakonfigurovány buď do režimu master (<i>SIMO</i> je výstupním
signálem, <i>SOMI</i> signálem vstupním, <i>UCLK</i> je výstupním signálem)
nebo do režimu slave (<i>SIMO</i> je vstupním signálem, <i>SOMI</i> je přepnut
na výstup, <i>UCLK</i> vstup od masteru a signálem <i>STE</i> se vybírá
konkrétní slave). Konfigurace <i>SPI</i> se na MSP430 v&nbsp;mnoha ohledech
podobají ostatním mikrořadičům &ndash; lze zvolit počet datových bitů (sedm či
osm), režim master či slave, polaritu hodinového signálu a samozřejmě i
frekvenci hodinového signálu (v&nbsp;režimu master). Jak vysílací, tak i
přijímací část mají své vlastní buffery, takže je možné <i>SPI</i> celkem bez
problémů použít i ve chvíli, kdy je CPU uspán.</p>

<img src="https://i.iinfo.cz/images/101/msp430-3.jpg" class="image-270210" alt="&#160;" width="544" height="399" />
<p><i>Obrázek 3: Textový LCD ovládaný přes sběrnici SPI. Textové LCD tohoto
typu obsahují RAM paměť, ve které je uchováván zobrazený text a některou
z&nbsp;forem pamětí ROM (EPROM, EEROM, Flash) pro uložení znakové sady,
tj.&nbsp;bitových map jednotlivých zobrazitelných znaků. Komunikační rozhraní
bývá různé &ndash; může se jednat o některou z&nbsp;forem paralelního portu,
sériového portu (UART) nebo právě sběrnici SPI.</i></p>



<p><a name="k13"></a></p>
<h2 id="k13">13. I<sup>2</sup>C</h2>

<p>Další sběrnicí, kterou čipy MSP430 (a samozřejmě i další mikrořadiče)
podporují, je sběrnice označovaná poněkud neobvykle symbolem
<i>I<sup>2</sup>C</i>, což je zkratka z&nbsp;celého názvu <i>Inter-Integrated
Circuit</i>. V&nbsp;určitých ohledech se jedná o sběrnici podobnou <i>SPI</i>
(existence hodinového signálu, jediný uzel typu <i>master</i>), ovšem některé
vlastnosti těchto sběrnic jsou odlišné. Zatímco u sběrnice <i>SPI</i> byl
umožněn obousměrný přenos dat díky použití dvojice vodičů <i>MISO</i> a
<i>MOSI</i>, je sběrnice <i>I<sup>2</sup>C</i> vybavena &bdquo;pouze&ldquo;
jedním datovým vodičem <i>SDA</i>, z&nbsp;čehož vyplývá, že se data přenáší
poloduplexně. Také to znamená poněkud složitější interní strukturu všech
připojených zařízení, protože příslušné piny musí být možné přepínat ze
vstupního režimu na režim výstupní.</p>

<img src="https://i.iinfo.cz/images/101/msp430-4.jpg" class="image-270211" alt="&#160;" width="476" height="164" />
<p><i>Obrázek 4: Zapojení uzlů na sběrnici I<sup>2</sup>C.</i></p>

<p>Dalším rozdílem je, že zde není použit výběr zařízení typu <i>slave</i>
pomocí zvláštních signálů, protože každému uzlu je přiřazena jednoznačná adresa
&ndash; kromě elektrických charakteristik je totiž přesně stanoven i
komunikační protokol, což je další rozdíl oproti výše popsané sběrnici
<i>SPI</i>. Obecně je možné říci, že <i>I<sup>2</sup>C</i> je sice poněkud
složitější, ale zato flexibilnější sběrnice, která se velmi často používá i pro
komunikaci na delší vzdálenosti (řádově metry, viz například <i>DDC</i> u
monitorů), než tomu je u sběrnice <i>SPI</i>.</p>

<img src="https://i.iinfo.cz/images/101/msp430-5.jpg" class="image-270212" alt="&#160;" width="476" height="81" />
<p><i>Obrázek 5: Komunikace probíhající na sběrnici I<sup>2</sup>C, při níž je
pomocí sedmi bitů vybráno jedno ze zařízení, které pracuje v&nbsp;režimu slave.
Po sedmi bitech adresy je navíc přenesen jeden bit, kterým je určeno, zda bude
zařízení typu &bdquo;master&ldquo; data posílat či naopak přijímat. Každá
osmice bitů (bajt, znak) je potvrzována, přenesení osmi bitů je tedy provedeno
za devět hodinových cyklů (devátý cyklus slouží k&nbsp;přenesení potvrzovacího
bitu &ndash; ACK).</i></p>

<p>Čipy MSP430 podporují jak použití sedmibitové adresy zařízení, tak i
desetibitové adresy (obě možnosti se stále používají). Rychlost přenosu je
možné zvolit, podporována je jak standardní rychlost 100 kb/sec, tak i vyšší
rychlosti až do 400 kb/sec. Podobně jako u <i>SPI</i>, i u sběrnice
<i>I<sup>2</sup>C</i> jsou použity buffery připojené na přijímací a vysílací
posuvné registry. Celý přenos je možné v&nbsp;případě potřeby řídit pouze
z&nbsp;přerušovací rutiny (všechny události mohou vygenerovat přerušení).</p>

<a href="https://www.root.cz/obrazek/270213/"><img src="https://i.iinfo.cz/images/101/msp430-6-prev.png" class="image-270213" alt="&#160;" width="370" height="70" /></a></p>
<p><i>Obrázek 6: Průběh komunikace při adresování uzlů pomocí desetibitové
adresy (příjem dat zařízením typu slave).</i></p>



<p><a name="k14"></a></p>
<h2 id="k14">14. Obsah další části seriálu</h2>

<p>V&nbsp;navazující části tohoto seriálu dokončíme popis čipů MSP430. Nejprve
si popíšeme další periferní moduly, mezi něž patří A/D a D/A převodníky i PWM a
posléze se seznámíme s&nbsp;několika konkrétními čipy, od minimalisticky
pojatých integrovaných obvodů s&nbsp;pouhými několika piny až po relativně
výkonné mikrořadiče. Zmíníme se i o velmi zajímavé technologii FRAM.</p>



<p><a name="k15"></a></p>
<h2 id="k15">15. Odkazy na Internetu</h2>

<ol>

<li>MSP430 Development Hardware<br />
<a href="http://www.argenox.com/library/msp430/msp430-development-hardware-chapter-1/">http://www.argenox.com/library/msp430/msp430-development-hardware-chapter-1/</a>
</li>

<li>MSP430™ ultra-low-power Microcontrollers<br />
<a href="http://www.ti.com/lsds/ti/microcontrollers_16-bit_32-bit/msp/overview.page?HQS=msp430">http://www.ti.com/lsds/ti/microcontrollers_16-bit_32-bit/msp/overview.page?HQS=msp430</a>
</li>

<li>An introduction to the TI MSP430 low-power microcontrollers<br />
<a href="http://mspgcc.sourceforge.net/manual/c68.html">http://mspgcc.sourceforge.net/manual/c68.html</a>
</li>

<li>MSP430 LaunchPad Tutorials<br />
<a href="http://processors.wiki.ti.com/index.php/MSP430_LaunchPad_Tutorials">http://processors.wiki.ti.com/index.php/MSP430_LaunchPad_Tutorials</a>
</li>

<li>LaunchPad MSP430 Assembly Language Tutorial<br />
<a href="http://robotics.hobbizine.com/asmlau.html">http://robotics.hobbizine.com/asmlau.html</a>
</li>

<li>TI 16-bit and 32-bit microcontrollers<br />
<a href="http://www.ti.com/lsds/ti/microcontrollers_16-bit_32-bit/overview.page">http://www.ti.com/lsds/ti/microcontrollers_16-bit_32-bit/overview.page</a>
</li>

<li>TI MSP430 (Wikipedia)<br />
<a href="https://en.wikipedia.org/wiki/TI_MSP430">https://en.wikipedia.org/wiki/TI_MSP430</a>
</li>

<li>Introduction to Getting Started with MSP430<br />
<a href="http://www.argenox.com/library/msp430/msp430-preface-intro/">http://www.argenox.com/library/msp430/msp430-preface-intro/</a>
</li>

<li>H8/300H Series Software Manual<br />
<a href="https://www.renesas.com/en-us/doc/products/mpumcu/001/rej09b0213_h8300h.pdf">https://www.renesas.com/en-us/doc/products/mpumcu/001/rej09b0213_h8300h.pdf</a>
</li>

<li>Renesas H8/300H Series Manuals<br />
<a href="https://www.manualslib.com/products/Renesas-H8-300h-Series-2312446.html">https://www.manualslib.com/products/Renesas-H8-300h-Series-2312446.html</a>
</li>

<li>H8 Family<br />
<a href="https://en.wikipedia.org/wiki/H8_Family">https://en.wikipedia.org/wiki/H8_Family</a>
</li>

<li>H8/300 and H8/300L<br />
<a href="http://nah6.com/~itsme/download/ibutton/h8_8bit.pdf">http://nah6.com/~itsme/download/ibutton/h8_8bit.pdf</a>
</li>

<li>H8 Family<br />
<a href="https://www.renesas.com/en-us/products/microcontrollers-microprocessors/h8.html">https://www.renesas.com/en-us/products/microcontrollers-microprocessors/h8.html</a>
</li>

<li>(GCC) Status of Supported Architectures from Maintainers' Point of View<br />
<a href="https://gcc.gnu.org/backends.html">https://gcc.gnu.org/backends.html</a>
</li>

<li>(GCC) H8/300 Options<br />
<a href="https://gcc.gnu.org/onlinedocs/gcc/H8_002f300-Options.html#H8_002f300-Options">https://gcc.gnu.org/onlinedocs/gcc/H8_002f300-Options.html#H8_002f300-Options</a>
</li>

<li>GCC for SuperH,H8/300,AVR<br />
<a href="http://mes.osdn.jp/h8/gcc.html">http://mes.osdn.jp/h8/gcc.html</a>
</li>

<li>H8/3802, 38002S, 38004, 38104 (manuály k&nbsp;čipům)<br />
<a href="https://www.renesas.com/en-us/document/hw-manual?hwLayerShowFlg=true&prdLayerId=184&layerName=H8%252F3802%252C%2B38002S%252C%2B38004%252C%2B38104&coronrService=document-prd-search&hwDocUrl=%2Fen-us%2Fdoc%2Fproducts%2Fmpumcu%2F001%2Frej09b0024_h83802.pdf&hashKey=c5e1fa0a18c01e6c789bc7b5c0184ed9">https://www.renesas.com/en-us/document/hw-manual?hwLayerShowFlg=true&prdLayerId=184&layerName=H8%252F3802%252C%2B38002S%252C%2B38004%252C%2B38104&coronrService=document-prd-search&hwDocUrl=%2Fen-us%2Fdoc%2Fproducts%2Fmpumcu%2F001%2Frej09b0024_h83802.pdf&hashKey=c5e1fa0a18c01e6c789bc7b5c0184ed9</a>
</li>

<li>Addressing mode (Wikipedia)<br />
<a href="https://en.wikipedia.org/wiki/Addressing_mode">https://en.wikipedia.org/wiki/Addressing_mode</a>
</li>

<li>Renesas SH Instruction Set Summary<br />
<a href="http://shared-ptr.com/sh_insns.html">http://shared-ptr.com/sh_insns.html</a>
</li>

<li>SH-4 RISC Processor by HITACHI<br />
<a href="http://www.cs.umd.edu/~meesh/cmsc411/website/projects/risc/risc.htm">http://www.cs.umd.edu/~meesh/cmsc411/website/projects/risc/risc.htm</a>
</li>

<li>SH-4 RISC Processor<br />
<a href="http://www.cs.umd.edu/~meesh/cmsc411/website/projects/risc/sh-4.htm">http://www.cs.umd.edu/~meesh/cmsc411/website/projects/risc/sh-4.htm</a>
</li>

<li>SuperH RISC engine Family Features<br />
<a href="https://www.renesas.com/en-us/products/microcontrollers-microprocessors/superh/superh-features.html">https://www.renesas.com/en-us/products/microcontrollers-microprocessors/superh/superh-features.html</a>
</li>

<li>Orthogonal instruction set<br />
<a href="https://en.wikipedia.org/wiki/Orthogonal_instruction_set">https://en.wikipedia.org/wiki/Orthogonal_instruction_set</a>
</li>

<li>Status Register<br />
<a href="https://en.wikipedia.org/wiki/Status_register">https://en.wikipedia.org/wiki/Status_register</a>
</li>

<li>6800 Instruction Set<br />
<a href="http://www.electronics.dit.ie/staff/tscarff/6800/Instructions/instructions.htm">http://www.electronics.dit.ie/staff/tscarff/6800/Instructions/instructions.htm</a>
</li>

<li>Assembly language today<br />
<a href="http://beust.com/weblog/2004/06/23/assembly-language-today/">http://beust.com/weblog/2004/06/23/assembly-language-today/</a>
</li>

<li>Calling subroutines<br />
<a href="http://infocenter.arm.com/help/index.jsp?topic=/com.arm.doc.kui0100a/armasm_cihcfigg.htm">http://infocenter.arm.com/help/index.jsp?topic=/com.arm.doc.kui0100a/armasm_cihcfigg.htm</a>
</li>

<li>Art of Assembly - Arithmetic Instructions<br />
<a href="http://oopweb.com/Assembly/Documents/ArtOfAssembly/Volume/Chapter_6/CH06-2.html">http://oopweb.com/Assembly/Documents/ArtOfAssembly/Volume/Chapter_6/CH06-2.html</a>
</li>

<li>X86 Assembly/Arithmetic<br />
<a href="https://en.wikibooks.org/wiki/X86_Assembly/Arithmetic">https://en.wikibooks.org/wiki/X86_Assembly/Arithmetic</a>
</li>

<li>ARM subroutines &amp; program stack<br />
<a href="http://www.toves.org/books/armsub/">http://www.toves.org/books/armsub/</a>
</li>

<li>Programming from the Ground Up Book - Summary<br />
<a href="http://savannah.nongnu.org/projects/pgubook/">http://savannah.nongnu.org/projects/pgubook/</a>
</li>

<li>The 6502 overflow flag explained mathematically <br />
<a href="http://www.righto.com/2012/12/the-6502-overflow-flag-explained.html">http://www.righto.com/2012/12/the-6502-overflow-flag-explained.html</a>
</li>

</ol>



<p></p><p></p>
<p><small>Autor: <a href="http://www.fit.vutbr.cz/~tisnovpa">Pavel Tišnovský</a> &nbsp; 2016</small></p>
</body>
</html>

