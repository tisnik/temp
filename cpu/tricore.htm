<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
        "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html>
<head>
<title>Mikrořadičová jádra TriCore: kombinace MCU, DSP a RISCu</title>
<meta name="Author" content="Pavel Tisnovsky" />
<meta name="Generator" content="vim" />
<meta http-equiv="content-type" content="text/html; charset=utf-8" />
<style type="text/css">
         body {color:#000000; background:#ffffff;}
         h1  {font-family: arial, helvetica, sans-serif; color:#ffffff; background-color:#c00000; text-align:center; padding-left:1em}
         h2  {font-family: arial, helvetica, sans-serif; color:#ffffff; background-color:#0000c0; padding-left:1em; text-align:left}
         h3  {font-family: arial, helvetica, sans-serif; color:#000000; background-color:#c0c0c0; padding-left:1em; text-align:left}
         h4  {font-family: arial, helvetica, sans-serif; color:#000000; background-color:#e0e0e0; padding-left:1em; text-align:left}
         a   {font-family: arial, helvetica, sans-serif;}
         li  {font-family: arial, helvetica, sans-serif; color:#000000; text-align:justify; width:450px;}
         ol  {font-family: arial, helvetica, sans-serif; color:#000000; text-align:justify; width:450px;}
         ul  {font-family: arial, helvetica, sans-serif; color:#000000; text-align:justify; width:450px;}
         p   {font-family: arial, helvetica, sans-serif; color:#000000; text-align:justify;}
         pre {background:#e0e0e0}
</style>
</head>

<body>

<h1>Mikrořadičová jádra TriCore: kombinace MCU, DSP a RISCu</h1>

<h3>Pavel Tišnovský</h3>

<p></p>

<h1>Úvodník</h1>

<p>Kromě osmibitových a šestnáctibitových mikrořadičů vyrábí firma Infineon i výkonnější čipy s&nbsp;jádry nazvanými TriCore. Název TriCore bylo zvolen z&nbsp;toho důvodu, že tato jádra vznikla sloučením tří technologií: RISCového mikroprocesoru, mikrořadiče a digitálního signálového procesoru.</p>



<h2>Obsah</h2>

<p><a href="#k01">1. Mikrořadičová jádra TriCore: kombinace MCU, DSP a RISCu</a></p>
<p><a href="#k02">2. Plně 32bitové jádro</a></p>
<p><a href="#k03">3. Pracovní a adresové registry</a></p>
<p><a href="#k04">4. Stavové a řídicí registry</a></p>
<p><a href="#k05">5. DSP Modul</a></p>
<p><a href="#k06">6. Instrukční soubor jader TriCore</a></p>
<p><a href="#k07">7. Podskupina šestnáctibitových instrukcí</a></p>
<p><a href="#k08">8. Aritmetické instrukce</a></p>
<p><a href="#k09">9. Aritmetické instrukce s&nbsp;podmínkou</a></p>
<p><a href="#k10">10. Násobení</a></p>
<p><a href="#k11">11. Operace MAC (Multiply-Accumulate)</a></p>
<p><a href="#k12">12. Dělení</a></p>
<p><a href="#k13">13. Instrukce <strong>SEL</strong> &ndash; Conditional Select</a></p>
<p><a href="#k14">14. SIMD neboli operace s&nbsp;krátkými vektory</a></p>
<p><a href="#k15">15. Odkazy na Internetu</a></p>



<p><a name="k01"></a></p>
<h2 id="k01">1. Mikrořadičová jádra TriCore: kombinace MCU, DSP a RISCu</h2>

<p>Pro ty aplikace, v&nbsp;nichž je nutné zkombinovat schopnosti výkonného
mikrořadiče a digitálního signálového procesoru, navrhla společnost Infineon
čipy nazvané <i>TriCore</i>, jejichž součástí je 32bitové RISCové jádro se
šestnácti datovými a šestnácti adresovými registry doplněné o digitální
signálový procesor a taktéž o instrukce, které si většinou spojujeme
s&nbsp;klasickými mikrořadiči (operace nad jednotlivými bity atd.). Instrukční
soubor je unifikovaný a je založen na 32bitové RISCové instrukční sadě (i když
ne tak jednoduché a přímočaré, jako je tomu u architektur RISC či MIPS)
zkombinované s&nbsp;vybranými instrukcemi, které jsou zakódovány do <a
href="#k07">šestnáctibitových instrukčních slov</a>. Díky tomu je možné vyvíjet
a především kombinovat jak výkonné algoritmy s&nbsp;většími nároky na
programovou paměť (a vyrovnávací paměť), tak i ty části programu, kde je dbán
větší důraz na efektivní využití programové paměti.</p>

<p>Zajímavé je porovnání jader TriCore s&nbsp;již popsanými čipy <a
href="https://www.root.cz/clanky/od-digitalnich-signalovych-procesoru-c5000-k-cipum-omap/#k10">OMAP</a>
a <a
href="https://www.root.cz/clanky/cipy-davinci-aneb-uspesna-kombinace-jader-arm-a-dsp-s-architekturou-vliw/">DaVinci</a>
navrženými společností Texas Instruments. Zatímco v&nbsp;případě OMAP a DaVinci
jsou použity dva oddělené a samostatně pracující subsystémy &ndash; procesor
ARM a digitální signálový procesor (s&nbsp;vlastními akumulátory apod.) &ndash;
je v&nbsp;případě TriCore hlavní procesorové jádro a DSP integrováno do jednoho
celku, takže sice pracuje samostatně, ovšem DSP využívá stejné pracovní
registry jako RISCové jádro. Navíc je unifikován i instrukční soubor, což do
značné míry zjednodušuje vývoj aplikací (je ovšem na druhou stranu značně
závislý na schopnostech céčkového překladače, pokud se programátoři neuchýlí
k&nbsp;použití assembleru).</p>

<a href="https://www.root.cz/obrazek/278461/"><img src="https://i.iinfo.cz/images/138/davinci-1-prev.png" class="image-278461" alt="" width="370" height="204" /></a>
<p><i>Obrázek 1: Modulární struktura čipů DaVinci.</i></p>



<p><a name="k02"></a></p>
<h2 id="k02">2. Plně 32bitové jádro</h2>

<p>Jádro TriCore je plně 32bitové, což se projevilo jak na šířce zpracovávaných
dat (a to včetně operandů vstupujících do modulu DSP), tak i na možnosti
adresování (programu i dat). Procesor dokáže bez problémů adresovat až 4 GB
paměti, takže se zde nesetkáme s&nbsp;problémy, které museli řešit tvůrci
šestnáctibitových čipů, například minule popsaných jader <a
href="https://www.root.cz/clanky/mikroradice-a-dsp-spolecnosti-infineon-vylepsena-sestnactibitova-jadra-c166s-v2/">C166S
V2</a> (už vůbec nemluvě o jádrech osmibitových, například o řadě <a
href="https://www.root.cz/clanky/mikroradice-a-dsp-spolecnosti-infineon/#k03">XC800</a>).
I instrukční soubor je navržen takovým způsobem, že všechny instrukce mají
32bitová instrukční slova (RISCový přístup), ovšem s&nbsp;tím, že u vybrané
skupiny instrukcí existuje ještě zkrácený šestnáctibitový formát, který je
možné používat paralelně s&nbsp;formátem 32bitovým.</p>



<p><a name="k03"></a></p>
<h2 id="k03">3. Pracovní a adresové registry</h2>

<p>Jádra TriCore obsahují celkem šestnáct pracovních registrů, z&nbsp;nichž
každý má šířku 32 bitů (u některých instrukcí se však pracuje jen s&nbsp;horní
či dolní polovinou pracovního registru, zápis je následující:
<strong>DnU</strong> a <strong>DnL</strong>). Tyto registry se jmenují
<strong>D0</strong> až <strong>D15</strong> a jsou podle tzv.&nbsp;kontextu
rozděleny do dvou skupin. Poslední &ndash; šestnáctý &ndash; registr
<strong>D15</strong> je současně i implicitním registrem pro některé operace,
v&nbsp;nichž nejsou všechny registry zmíněny explicitně (jedná se především o
šestnáctibitové operace zmíněné dále):</p>

<table>
<tr><th>Registr</th><th>Šířka</th><th>Kontext</th><th>Plné jméno</th><th>Význam</th></tr>
<tr><td>D0</td><td>32 bitů</td><td>L</td><td>Data Register</td><td>pracovní (datový) registr</td></tr>
<tr><td>D1</td><td>32 bitů</td><td>L</td><td>Data Register</td><td>-//-</td></tr>
<tr><td>D2</td><td>32 bitů</td><td>L</td><td>Data Register</td><td>-//-</td></tr>
<tr><td>D3</td><td>32 bitů</td><td>L</td><td>Data Register</td><td>-//-</td></tr>
<tr><td>D4</td><td>32 bitů</td><td>L</td><td>Data Register</td><td>-//-</td></tr>
<tr><td>D5</td><td>32 bitů</td><td>L</td><td>Data Register</td><td>-//-</td></tr>
<tr><td>D6</td><td>32 bitů</td><td>L</td><td>Data Register</td><td>-//-</td></tr>
<tr><td>D7</td><td>32 bitů</td><td>L</td><td>Data Register</td><td>-//-</td></tr>
<tr><td>D8</td><td>32 bitů</td><td>U</td><td>Data Register</td><td>-//-</td></tr>
<tr><td>D9</td><td>32 bitů</td><td>U</td><td>Data Register</td><td>-//-</td></tr>
<tr><td>D10</td><td>32 bitů</td><td>U</td><td>Data Register</td><td>-//-</td></tr>
<tr><td>D11</td><td>32 bitů</td><td>U</td><td>Data Register</td><td>-//-</td></tr>
<tr><td>D12</td><td>32 bitů</td><td>U</td><td>Data Register</td><td>-//-</td></tr>
<tr><td>D13</td><td>32 bitů</td><td>U</td><td>Data Register</td><td>-//-</td></tr>
<tr><td>D14</td><td>32 bitů</td><td>U</td><td>Data Register</td><td>-//-</td></tr>
<tr><td>D15</td><td>32 bitů</td><td>U</td><td>Implicit Data Register</td><td>implicitní datový registr pro některé operace</td></tr>
</table>

<p>Ve sloupci &bdquo;Kontext&ldquo; je uvedeno, jestli pracovní registr náleží
do takzvaného &bdquo;Upper contextu&ldquo; nebo naopak do &bdquo;Lower
contextu&ldquo;. V&nbsp;instrukční sadě totiž nalezneme několik instrukcí
určených pro rychlé uložení kontextu (tj.&nbsp;všech registrů do něj patřících)
a samozřejmě i pro obnovení kontextu. Příkladem mohou být přerušovací rutiny,
které mohou pracovat jen s&nbsp;registry náležejícími do dolního kontextu. Na
začátku takové rutiny bude instrukce <strong>SVLCX</strong> (<i>Store Lower
Context</i>) nebo <strong>BISR</strong> (<i>Begin Interrupt Service
Routine</i>), na konci pak instrukce <strong>RSLCX</strong> (<i>Restore Lower
Context</i>).</p>

<p>Kromě šestnácti pracovních registrů najdeme v&nbsp;jádrech TriCore i
šestnáct registrů adresových. Tyto registry nesou názvy <strong>A0</strong> až
<strong>A15</strong>. Některé registry z&nbsp;této sady mají speciální význam,
což se týká především registru <strong>A10</strong> sloužícího jako ukazatel na
vrchol zásobníku a taktéž registru <strong>A11</strong> s&nbsp;návratovou
adresou. I adresové registry jsou rozděleny podle kontextu, ovšem do každého
kontextu spadá pouze šest adresových registrů, nikoli osm:</p>

<table>
<tr><th>Registr</th><th>Šířka</th><th>Kontext</th><th>Plné jméno</th><th>Význam</th></tr>
<tr><td>A0</td><td>32 bitů</td><td>-</td><td>Global Address Register</td><td>není obnoven při návratu z&nbsp;ISR</td></tr>
<tr><td>A1</td><td>32 bitů</td><td>-</td><td>Global Address Register</td><td>není obnoven při návratu z&nbsp;ISR</td></tr>
<tr><td>A2</td><td>32 bitů</td><td>L</td><td>Address Register</td><td></td></tr>
<tr><td>A3</td><td>32 bitů</td><td>L</td><td>Address Register</td><td></td></tr>
<tr><td>A4</td><td>32 bitů</td><td>L</td><td>Address Register</td><td></td></tr>
<tr><td>A5</td><td>32 bitů</td><td>L</td><td>Address Register</td><td></td></tr>
<tr><td>A6</td><td>32 bitů</td><td>L</td><td>Address Register</td><td></td></tr>
<tr><td>A7</td><td>32 bitů</td><td>L</td><td>Address Register</td><td></td></tr>
<tr><td>A8</td><td>32 bitů</td><td>-</td><td>Global Address Register</td><td>není obnoven při návratu z&nbsp;ISR</td></tr>
<tr><td>A9</td><td>32 bitů</td><td>-</td><td>Global Address Register</td><td>není obnoven při návratu z&nbsp;ISR</td></tr>
<tr><td>A10</td><td>32 bitů</td><td>U</td><td>Stack Return Register</td><td>použit jako ukazatel na vrchol zásobníku</td></tr>
<tr><td>A11</td><td>32 bitů</td><td>U</td><td>Return Address Register</td><td>obsahuje návratovou adresu</td></tr>
<tr><td>A12</td><td>32 bitů</td><td>U</td><td>Address Register</td><td></td></tr>
<tr><td>A13</td><td>32 bitů</td><td>U</td><td>Address Register</td><td></td></tr>
<tr><td>A14</td><td>32 bitů</td><td>U</td><td>Address Register</td><td></td></tr>
<tr><td>A15</td><td>32 bitů</td><td>U</td><td>Implicit Base Address Register</td><td>implicitní adresový registr</td></tr>
</table>

<p>Povšimněte si, že všechny čtyři registry <i>Global Address Register</i>
nepatří do žádného kontextu. Tyto registry jsou typicky používány operačním
systémem; pokud se používají i v&nbsp;běžných programech, je nutné ošetřit, aby
se obnovovala jejich původní hodnota.</p>



<p><a name="k04"></a></p>
<h2 id="k04">4. Stavové a řídicí registry</h2>

<p>Sada stavových a řídicích registrů je u jader TriCore poměrně malá, protože
zde najdeme jen klasický 32bitový programový čítač, stavový registr a taktéž
registr PCXI s&nbsp;informacemi o předchozím kontextu. Ovšem kromě těchto tří
registrů se u většiny čipů s&nbsp;jádrem TriCore nachází i sada speciálních
funkčních registrů (<i>SFR</i>), kterých může být podle množství periferních
modulů (porty, sběrnice, čítače, watchdogy, převodníky) i několik set:</p>

<table>
<tr><th>Registr</th><th>Šířka</th><th>Kontext</th><th>Plné jméno</th><th>Význam</th></tr>
<tr><td>PC</td><td>32 bitů</td><td>L</td><td>Program Counter</td><td></td></tr>
<tr><td>PSW</td><td>32 bitů</td><td>U</td><td>Procesor Status Word</td><td></td></tr>
<tr><td>PCXI</td><td>32 bitů</td><td>U</td><td>Previous Context Information Register</td><td></td></tr>
</table>

<p>Příznaky je možné ze stavového registru přenést instrukcí
<strong>MFCR</strong> (<i>Move From Core Register</i>), zpětný zápis se provádí
instrukcí <strong>MTCR</strong> (<i>Move To Core Register</i>). Tyto instrukce
pracují i s&nbsp;ostatními speciálními funkčními registry.</p>



<p><a name="k05"></a></p>
<h2 id="k05">5. DSP Modul</h2>

<p>Součástí jader TriCore je i modul DSP, který je mj.&nbsp;osazen rychlou
násobičkou, sčítačkou a barrel shifterem. Tento modul dokáže v&nbsp;každém
taktu dokončit jednu operaci MAC (Multiply Accumulate) s&nbsp;šestnáctibitovými
vstupními operandy a s&nbsp;volitelnou saturací výsledku (po součtu). Mezi
operace prováděné DSP modulem patří:</p>

<ol>
<li>Vynásobení dvou šestnáctibitových operandů uložených ve formátu Q15 (viz
další text).</li>
<li>Automatické posunutí výsledku násobení (tím je 32bitová hodnota).</li>
<li>Součet vynásobeného výsledku s&nbsp;hodnotou uloženou
v&nbsp;akumulátoru. V&nbsp;tomto případě se používá jen jediný
&bdquo;hlídací&ldquo; (guard) bit pro otestování přetečení.</li>
<li>Alternativně je možné akumulovaný výsledek uložit do dvojice registrů a
získat tak 64bitový akumulátor.</li>
<li>Zaokrouhlení výsledku při převodu zpět na 16bitovou hodnotu.</li>
<li>Řízení režimu akumulace &ndash; s&nbsp;přetečením či se saturací.</li>
</ol>

<p>Zajímavé jsou formáty dat, s&nbsp;nimiž DSP modul pracuje. Základní formát
se jmenuje <a
href="https://en.wikipedia.org/wiki/Q_%28number_format%29">Q15</a>; jedná se o
šestnáctibitové slovo, v&nbsp;jehož nejvyšším bitu je uloženo znaménko a
v&nbsp;dalších patnácti bitech pak binární číslice ZA řádovou tečkou (jedná se
o tečku dvojkovou, nikoli desetinnou). I z&nbsp;tohoto důvodu se tento formát
také označuje <i>1.15</i> či <i>fractional</i>:</p>

<pre>
 15 14 13 12 11 10  9  8  7  6  5  4  3  2  1  0
+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+
|s ,                                            |
+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+
</pre>

<p>Minimální reprezentovatelná hodnota je rovna přesně -1, což odpovídá
16bitovému slovu s bitovým vzorkem 0x8000:</p>

<pre>
 15 14 13 12 11 10  9  8  7  6  5  4  3  2  1  0
+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+
|-1, 0  0  0  0  0  0  0  0  0  0  0  0  0  0  0|
+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+
</pre>

<p>Maximální hodnota je rovna 1-2<sup>-15</sup>=.9999694825 (tedy &bdquo;skoro
jedna&ldquo;) a odpovídá 16bitovému slovu s&nbsp;bitovým vzorkem 0x7fff:</p>

<pre>
 15 14 13 12 11 10  9  8  7  6  5  4  3  2  1  0
+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+
| 0, 1  1  1  1  1  1  1  1  1  1  1  1  1  1  1|
+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+
</pre>

<p>Druhý formát je prakticky totožný, ovšem počet binárních číslic za řádovou
tečkou je roven 31 (formát <i>1.31</i> či <i>Q31</i>):</p>

<pre>
31 30 29 28 27 26 25 24 23 22 21 20 19 18 17 16 15 14 13 12 11 10 9  8  7  6  5  4  3  2  1  0
+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+
|s ,                                                                                         |
+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+
</pre>

<p>Existuje ještě meziformát 2.30 získaný násobením dvou hodnot ve formátu
1.15, v&nbsp;němž je za řádovou tečkou 30 binárních číslic a před tečkou dva
bity. Tento meziformát dokáže reprezentovat i hodnotu 1,0 získanou vynásobením
-1,0&times;-1,0 (toto je vlastně jediná hodnota, která by mohla způsobovat
problémy).</p>



<p><a name="k06"></a></p>
<h2 id="k06">6. Instrukční soubor jader TriCore</h2>

<p>Instrukce zpracovávané jádry TriCore jsou sice v&nbsp;některých ohledech
odvozeny od klasických RISCových instrukčních sad, ovšem kvůli zařazení DSP
operací, dále popsaných šestnáctibitových instrukcí atd. je ve skutečnosti
instrukční sada poměrně komplikovaná. Všechny instrukce můžeme rozdělit do
několika kategorií popř.&nbsp;podkategorií:</p>

<ol>
<li>Aritmetické instrukce
    <ul>
        <li><a href="#k08">Celočíselné</a></li>
        <li><a href="#k11">DSP</a></li>
        <li><a href="#k14">SIMD</a></li>
        <li>Adresová aritmetika</li>
    </ul>
</li>
<li>Logické instrukce</li>
<li>Manipulace s&nbsp;jednotlivými bity</li>
<li>Přenosy dat
    <ul>
        <li>Přenosy dat mezi registry</li>
        <li>Podmíněné přenosy dat (CMOV)</li>
        <li>Load/Store</li>
    </ul>
<li>Porovnání hodnot či adres</li>
<li>Skoky
    <ul>
        <li>Nepodmíněné</li>
        <li>Podmíněné</li>
        <li>Instrukce pro programové smyčky</li>
    </ul>
</li>
<li><a href="#k07">Podmnožina šestnáctibitových instrukcí</a></li>
<li>Systémové instrukce (začátek rutiny pro obsluhu přerušení, debug režim ...)</li>
</ol>

<p>Poznámka: v&nbsp;následujících kapitolách si popíšeme jen poměrně omezenou
sadu vybraných instrukcí. Podrobnější popis instrukční sady, adresovacích
režimů apod.  bude uveden až v&nbsp;navazujícím článku</p>



<p><a name="k07"></a></p>
<h2 id="k07">7. Podskupina šestnáctibitových instrukcí</h2>

<p>Jádra TriCore kromě běžných (pseudo)RISCových instrukcí s&nbsp;32bitovým
instrukčním slovem obsahují i podskupinu instrukcí, jejichž šířka je poloviční
(šestnáct bitů). Prefixy těchto instrukcí se odlišují od 32bitových instrukcí,
takže je možné obě skupiny instrukcí libovolným způsobem mixovat, na rozdíl od
režimů ARM a Thumb známých z&nbsp;mikroprocesorů a mikrořadičů ARM. Díky
rozšíření instrukční sady o instrukce s&nbsp;šířkou šestnácti bitů je umožněno
snížení velikosti programu o přibližně jednu třetinu.</p>

<p>Kvůli zmenšení velikosti instrukčních slov na polovinu bylo nutné
v&nbsp;šestnáctibitových instrukcích udělat mnoho kompromisů, například:</p>

<ol>
<li>Konstanty v&nbsp;instrukcích mohou mít jen nízké hodnoty.</li>
<li>Offsety při adresování jsou taktéž menší.</li>
<li>Při určování registrů je kombinuje jeden zdrojový registr s&nbsp;registrem
cílovým (dva operandy, nikoli tři).</li>
<li>V&nbsp;některých případech se používá implicitní datový registr
<strong>D15</strong>.</li>
<li>Podobně to platí i u implicitního adresového registru
<strong>A15</strong>.</li>
</ol>

<p>Skupina šestnáctibitových instrukcí je poměrně malá, což je ostatně patrné
z&nbsp;následující tabulky:</p>

<table>
<tr><td>Aritmetické instrukce</td><td>ADD, ADDSC, SUB, CADD, CADDN, SAT</td></tr>
<tr><td>Logické instrukce</td><td>AND, OR</td></tr>
<tr><td>Posuny</td><td>SH, SHA</td></tr>
<tr><td>Porovnání</td><td>EQ, LT</td></tr>
<tr><td>Přenosy dat a podmíněné přenosy dat</td><td>MOV, CMOV, CMOVN</td></tr>
<tr><td>Skoky (podmíněné i nepodmíněné)</td><td>J, JEQ, JGEZ, JGTZ, JI, JLEZ, JLTZ, JNE, JNZ, JZ</td></tr>
<tr><td>Implementace programových smyček</td><td>LOOP, LOOPU</td></tr>
<tr><td>Ostatní instrukce</td><td>BISR, BSPLIT, DEBUG, NOP, RET, RFE, ST</td></tr>
</table>



<p><a name="k08"></a></p>
<h2 id="k08">8. Aritmetické instrukce</h2>

<p>Sada aritmetických instrukcí je poměrně rozsáhlá, protože kromě běžných
instrukcí zde najdeme i varianty součtu a rozdílu prováděných se saturací (jak
se znaménkem, tak bez znaménka). Navíc je možné zvolit, jakým způsobem se bude
pracovat s&nbsp;příznakem <i>carry</i> (přenos), který je součástí <a
href="#k04">stavového registru PSW</a>. Pokud je totiž zapotřebí implementovat
víceslovní aritmetiku, je první součet proveden instrukcí <strong>ADDX</strong>
(<i>Add Extended</i>) nastavující příznak <i>carry</i> a další slova pak sčítat
instrukcí <strong>ADDC</strong> (<i>Add with Carry</i>). Pokud je zapotřebí
přičíst k&nbsp;obsahu vybraného registru konstantu, lze zvolit instrukci
<strong>ADDI</strong> pro přičtení 16bitové konstanty popř.&nbsp;instrukci
<strong>ADDIH</strong> pro přičtení taktéž šestnáctibitové konstanty, ovšem
posunuté o šestnáct bitů doleva (takže se přičítá k&nbsp;hornímu půlslovu).
Důvod k&nbsp;existenci dvou instrukcí namísto instrukce jediné
(s&nbsp;32bitovou konstantou) je u všech RISCových procesorů stejný &ndash;
instrukční kód i vlastní konstanta se musí nějakým způsobem vměstnat do
&bdquo;pouhých&ldquo; třiceti dvou bitů instrukčního slova.</p>



<p><a name="k09"></a></p>
<h2 id="k09">9. Aritmetické instrukce s&nbsp;podmínkou</h2>

<p>Užitečné jsou i aritmetické instrukce s&nbsp;podmínkou, protože díky jejich
existenci je možné do jisté míry omezit počet podmíněných skoků (se všemi
problémy, které jejich použití v&nbsp;RISCových jádrech přináší). Tyto
instrukce nejdříve otestují obsah vybraného pracovního registru &ndash;
nenulová hodnota je považována za <i>true</i>, nulová hodnota za <i>false</i>
(tedy opět stejně, jako je tomu v&nbsp;céčku). Mezi aritmetické instrukce
s&nbsp;podmínkou patří především:</p>

<table>
<tr><th>Instrukce</th><th>Význam</th></tr>
<tr><td>CADD</td><td>součet, pokud je obsah vybraného pracovního registru nenulový</td></tr>
<tr><td>CADDN</td><td>součet, pokud je obsah vybraného pracovního registru nulový</td></tr>
<tr><td>CSUB</td><td>rozdíl, pokud je obsah vybraného pracovního registru nenulový</td></tr>
<tr><td>CSUBN</td><td>rozdíl, pokud je obsah vybraného pracovního registru nulový</td></tr>
</table>



<p><a name="k10"></a></p>
<h2 id="k10">10. Násobení</h2>

<p>Pro násobení &ndash; což jsou instrukce oddělené od DSP modulu (jsou totiž
prováděné v&nbsp;aritmeticko-logické jednotce) &ndash; se používají tyto tři
instrukce s&nbsp;32bitovým či 64bitovým výsledkem:</p>

<table>
<tr><th>Instrukce</th><th>Význam</th></tr>
<tr><td>MUL   </td><td>násobení dvou hodnot se znaménkem (s&nbsp;32bitovým či 64bitovým výsledkem)</td></tr>
<tr><td>MULS  </td><td>násobení dvou hodnot se znaménkem a se saturací</td></tr>
<tr><td>MULS.U</td><td>násobení dvou hodnot bez znaménka a se saturací</td></tr>
</table>

<p>Šířka výsledku je určena na základě typů operandů. Tyto instrukce produkují
výsledky kompatibilní s&nbsp;céčkovskou operací * aplikovanou na celá čísla (na
rozdíl od instrukcí popsaných <a href="#k11">v&nbsp;navazující
kapitole</a>)-</p>



<p><a name="k11"></a></p>
<h2 id="k11">11. Operace MAC (Multiply-Accumulate)</h2>

<p>Již <a href="#k05">výše zmíněná</a> jednotka určená pro DSP operace je
podporována instrukcemi <strong>MUL.Q</strong> (<i>Multiply Q format</i>),
<strong>MULR.Q</strong> (<i>Multiply Q format with Rounding</i>),
<strong>MADD.Q</strong> (<i>Multiply-Add Q format</i>),
<strong>MADDS.Q</strong> (<i>Multiply-Add Q format with Saturation</i>) a
variantami <strong>MADD.Q</strong> se zaokrouhlením. Šířka vstupních i
výstupních dat je určena z&nbsp;typů operandů:</p>

<table>
<tr><th>Vstupní operand</th><th>Vstupní operand</th><th>Výstupní operand</th><th>Výpočet</th></tr>
<tr><td>DnU</td><td>DmU</td><td>Dz</td><td>16&times;16 &rarr; 32</td></tr>
<tr><td>DnL</td><td>DmL</td><td>Dz</td><td>16&times;16 &rarr; 32</td></tr>
<tr><td>DnU</td><td>Dm</td><td>Dz</td><td>16&times;32 &rarr; 32</td></tr>
<tr><td>DnL</td><td>Dm</td><td>Dz</td><td>16&times;32 &rarr; 32</td></tr>
<tr><td>Dn</td><td>Dm</td><td>Dz</td><td>32&times;32 &rarr; 32</td></tr>
<tr><td>DnU</td><td>Dm</td><td>Ez</td><td>16&times;32 &rarr; 64</td></tr>
<tr><td>DnL</td><td>Dm</td><td>Ez</td><td>16&times;32 &rarr; 64</td></tr>
<tr><td>Dn</td><td>Dm</td><td>Ez</td><td>32&times;32 &rarr; 64</td></tr>
</table>

<p>Značení vstupních a výstupních operandů je následující:</p>

<ul>
<li>Běžný pracovní registr se v&nbsp;assembleru zapisuje <strong>Dn</strong>,
kde n=0..15.</li>
<li>Spodní polovina pracovního registru <strong>Dn</strong> se zapisuje
<strong>DnL</strong>.</li>
<li>Horní polovina pracovního registru <strong>Dn</strong> se zapisuje
<strong>DnU</strong>.</li>
<li>Registrový pár <strong>Dn+1 | Dn</strong> se zapisuje
<strong>En</strong>.</li>
</ul>

<p>Poznámka: povšimněte si další zajímavé vlastnosti jader TriCore &ndash;
jádro DSP je plně integrováno do hlavního procesoru a nenachází se zde žádné
speciální vstupní registry do DSP, akumulátory atd. Z&nbsp;pohledu programátora
se tedy jedná o velmi snadno použitelný čip, na rozdíl od (např.) čipů OMAP,
kde je DSP od ARMovského jádra odděleno.</p>



<p><a name="k12"></a></p>
<h2 id="k12">12. Dělení</h2>

<p>Dělení je složitější, neboť se celá operace rozděluje do několika kroků. Při
inicializaci si dělička připravuje obsahy interních registrů používaných při
dělení, provádí konverze (bitové posuny) atd. Následuje jeden až čtyři kroky
dělení, přičemž se v&nbsp;každém kroku vyprodukuje osm bitů výsledku. Na závěr
je někdy nutné provést instrukci <strong>DVADJ</strong>; tu lze vynechat ve
chvíli, kdy je jisté, že je dělenec i dělitel kladný:</p>

<table>
<tr><th>Instrukce</th><th>Význam</th></tr>
<tr><td>DVINIT</td><td>inicializace děličky (očekává se 32bitový podíl, dělení se znaménkem)</td></tr>
<tr><td>DVINIT.H</td><td>inicializace děličky (očekává se 16bitový podíl, dělení se znaménkem)</td></tr>
<tr><td>DVINIT.B</td><td>inicializace děličky (očekává se osmibitový podíl, dělení se znaménkem)</td></tr>
<tr><td>&nbsp;</td><td>&nbsp;</td></tr>
<tr><td>DVINIT.U</td><td>inicializace děličky (očekává se 32bitový podíl, dělení bez znaménka)</td></tr>
<tr><td>DVINIT.HU</td><td>inicializace děličky (očekává se 16bitový podíl, dělení bez znaménka)</td></tr>
<tr><td>DVINIT.BU</td><td>inicializace děličky (očekává se osmibitový podíl, dělení bez znaménka)</td></tr>
<tr><td>&nbsp;</td><td>&nbsp;</td></tr>
<tr><td>DVSTEP</td><td>jeden krok dělení, který vyprodukuje osm bitů výsledku (tento krok se opakuje 1&times;, 2&times;, 4&times;)</td></tr>
<tr><td>DVSTEP.U</td><td>jeden krok dělení, který vyprodukuje osm bitů výsledku (tento krok se opakuje 1&times;, 2&times;, 4&times;)</td></tr>
<tr><td>&nbsp;</td><td>&nbsp;</td></tr>
<tr><td>DVADJ</td><td>nutné provést pro dělení se znaménkem, když dělenec či dělitel může být záporný</td></tr>
</table>

<p>Rozdělení do několika kroků je vynuceno typickým použitím jader TriCore
&ndash; je nutné rychle reagovat na přerušení, takže si většinou vývojáři
nemohou dovolit, aby nějaká instrukce trvala příliš dlouho.</p>



<p><a name="k13"></a></p>
<h2 id="k13">13. Instrukce <strong>SEL</strong> &ndash; Conditional Select</h2>

<p>Další užitečnou instrukcí s&nbsp;podmínkou (testem nulovosti či nenulovosti
datového registru) je instrukce zapisovaná mnemotechnickým kódem
<strong>SEL</strong> neboli <i>(Conditional) Select</i>. Tato instrukce pracuje
následovně: pokud je podmínka splněna, uloží se do zvoleného cílového registru
hodnota z&nbsp;prvního zdrojového registru. Pokud podmínka naopak splněna není,
je do cílového registru uložena hodnota z&nbsp;druhého zdrojového registru.
Jinými slovy to znamená, že instrukce <strong>SEL</strong> nahrazuje
programovou konstrukci typu:</p>

<pre>
cíl = condition ? zdroj1 : zdroj2;
</pre>

<p>Pokud je jeden ze zdrojových registrů totožný s&nbsp;registrem cílovým,
odpovídá to příkazu:</p>

<pre>
if (condition) cíl = zdroj1 nebo zdroj2;
</pre>

<p>Kromě instrukce <strong>SEL</strong> existuje i instrukce
<strong>SELN</strong> neboli <i>(Conditional) Select-Not</i> s&nbsp;opačně
chápanou podmínkou.</p>

<p>Poznámka: podobně koncipované instrukce nalezneme i u mikroprocesorů
s&nbsp;architekturou AArch64, zde se ovšem tyto instrukce jmenují
<strong>CSEL</strong> a <strong>CSINV</strong>.</p>



<p><a name="k14"></a></p>
<h2 id="k14">14. SIMD neboli operace s&nbsp;krátkými vektory</h2>

<p>Všechny základní aritmetické a logické instrukce jsou určeny pro zpracování
dvou 32bitových vstupních operandů s&nbsp;taktéž 32bitovým výsledkem. Ovšem u
některých instrukcí podporují jádra TriCore i &bdquo;vektorové&ldquo;
zpracování, přičemž vektor může obsahovat buď dva šestnáctibitové prvky či
čtyři prvky osmibitové (se znaménkem či bez znaménka). Příkladem použití může
být zpracování signálů (výstupem A/D převodníků bývají osmibitové, desetibitové
či právě šestnáctibitové hodnoty), práce s&nbsp;rastrovými obrázky (což pro
TriCore ovšem není typický příklad použití) apod.</p>

<a href="http://i.iinfo.cz/images/311/pc158-8.jpg"><img src="http://i.iinfo.cz/images/311/pc158-8-prev.jpg" width="370" height="155" alt="&#160;" /></a>
<p><i>Obrázek 2: Typy vektorů, s&nbsp;nimiž pracují jádra TriCore.</i></p>

<p>Vybrané instrukce podporující práci s&nbsp;vektory mohou používat prefixy
<strong>.B</strong>, <strong>.H</strong>, <strong>.BU</strong> a
<strong>.HU</strong> pro rozlišení, zda jsou operandy osmibitové (<i>Byte</i>)
či šestnáctibitové (<i>Half-word</i>) a taktéž pro rozlišení mezi operací
s&nbsp;bezznaménkovými či znaménkovými operandy. Taktéž je možné zvolit, zda se
například operace součtu bude provádět s&nbsp;přetečením či se saturací.
Speciálním případem jsou DSP operace <strong>MUL.H/MULR.H/MULM.H</strong>
pracující s&nbsp;vektory obsahujícími dva šestnáctibitové operandy. Jedná se o
dodatkové instrukce k&nbsp;DSP instrukcím popsaným <a
href="#k11">v&nbsp;jedenácté kapitole</a>.</p>

<img src="http://i.iinfo.cz/images/503/pc160-6.png" width="450" height="304" alt="&#160;" />
<p><i>Obrázek 3: Vektorové operace podporované instrukční sadou SSE.</i></p>



<p><a name="k15"></a></p>
<h2 id="k15">15. Odkazy na Internetu</h2>

<ol>

<li>Q (number format)<br />
<a href="https://en.wikipedia.org/wiki/Q_%28number_format%29">https://en.wikipedia.org/wiki/Q_%28number_format%29</a>
</li>

<li>TriCore Architecture &amp; Core<br />
<a href="http://www.infineon.com/cms/en/product/microcontroller/32-bit-tricore-tm-microcontroller/tricore-tm-architecture-and-core/channel.html?channel=ff80808112ab681d0112ab6b73d40837">http://www.infineon.com/cms/en/product/microcontroller/32-bit-tricore-tm-microcontroller/tricore-tm-architecture-and-core/channel.html?channel=ff80808112ab681d0112ab6b73d40837</a>
</li>

<li>TriCoreTM V1.6 Instruction Set: 32-bit Unified Processor Core<br />
<a href="http://www.infineon.com/dgdl/tc_v131_instructionset_v138.pdf?fileId=db3a304412b407950112b409b6dd0352">http://www.infineon.com/dgdl/tc_v131_instructionset_v138.pdf?fileId=db3a304412b407950112b409b6dd0352</a>
</li>

<li>TriCore v2.2 C Compiler, Assembler, Linker Reference Manual<br />
<a href="http://tasking.com/support/tricore/tc_reference_guide_v2.2.pdf">http://tasking.com/support/tricore/tc_reference_guide_v2.2.pdf</a>
</li>

<li>Infineon TriCore (Wikipedia)<br />
<a href="https://en.wikipedia.org/wiki/Infineon_TriCore">https://en.wikipedia.org/wiki/Infineon_TriCore</a>
</li>

<li>C166®S V2 Architecture &amp; Core<br />
<a href="http://www.infineon.com/cms/en/product/microcontroller/16-bit-c166-microcontroller/c166-s-v2-architecture-and-core/channel.html?channel=db3a304312bef5660112c3011c7d01ae">http://www.infineon.com/cms/en/product/microcontroller/16-bit-c166-microcontroller/c166-s-v2-architecture-and-core/channel.html?channel=db3a304312bef5660112c3011c7d01ae</a>
</li>

<li>Memory segmentation<br />
<a href="https://en.wikipedia.org/wiki/Memory_segmentation">https://en.wikipedia.org/wiki/Memory_segmentation</a>
</li>

<li>Bus mastering<br />
<a href="https://en.wikipedia.org/wiki/Bus_mastering">https://en.wikipedia.org/wiki/Bus_mastering</a>
</li>

<li>ST10 16-bit MCUs<br />
<a href="http://www.st.com/en/microcontrollers/st10-16-bit-mcus.html?querycriteria=productId=LN1111">http://www.st.com/en/microcontrollers/st10-16-bit-mcus.html?querycriteria=productId=LN1111</a>
</li>

<li>XC800 family<br />
<a href="https://en.wikipedia.org/wiki/XC800_family">https://en.wikipedia.org/wiki/XC800_family</a>
</li>

<li>C166 (stránky společnosti Infineon)<br />
<a href="https://www.infineon.com/cms/en/product/microcontroller/16-bit-c166-microcontroller/channel.html?channel=ff80808112ab681d0112ab6b2eaf0759#ispnTab3">https://www.infineon.com/cms/en/product/microcontroller/16-bit-c166-microcontroller/channel.html?channel=ff80808112ab681d0112ab6b2eaf0759#ispnTab3</a>
</li>

<li>C166 Family<br />
<a href="https://en.wikipedia.org/wiki/C166_family">https://en.wikipedia.org/wiki/C166_family</a>
</li>

<li>Permanent Magnet Synchronous Motor<br />
<a href="https://en.wikipedia.org/wiki/Synchronous_motor#Permanent_magnet_motors">https://en.wikipedia.org/wiki/Synchronous_motor#Permanent_magnet_motors</a>
</li>

<li>Implementing field oriented control of a brushless DC motor<br />
<a href="http://www.eetimes.com/document.asp?doc_id=1279321">http://www.eetimes.com/document.asp?doc_id=1279321</a>
</li>

<li>Vector control (motor)<br />
<a href="https://en.wikipedia.org/wiki/Vector_control_(motor)">https://en.wikipedia.org/wiki/Vector_control_(motor)</a>
</li>

<li>Motorola DSP56k<br />
<a href="https://www.rockbox.org/wiki/MotorolaDSP56k">https://www.rockbox.org/wiki/MotorolaDSP56k</a>
</li>

<li>Motorola 56000 (Wikipedia)<br />
<a href="http://en.wikipedia.org/wiki/Motorola_56000">http://en.wikipedia.org/wiki/Motorola_56000</a>
</li>

<li>Using the Motorola DSP56002EVM for Amateur Radio DSP Projects<br />
<a href="http://www.johanforrer.net/EVM/article.html">http://www.johanforrer.net/EVM/article.html</a>
</li>

<li>The Atari Falcon030 "Personal Integrated Media System"<br />
<a href="http://www.atarimuseum.com/computers/16bits/falcon030.html">http://www.atarimuseum.com/computers/16bits/falcon030.html</a>
</li>

<li>Turtle Beach Corporation (stránky společnosti)<br />
<a href="http://www.turtlebeach.com/">http://www.turtlebeach.com/</a>
</li>

<li>Turtle Beach Corporation (Wikipedia)<br />
<a href="https://en.wikipedia.org/wiki/Turtle_Beach_Corporation">https://en.wikipedia.org/wiki/Turtle_Beach_Corporation</a>
</li>

<li>Atari Falcon 030 DSP 3D engine test<br />
<a href="http://www.digiti.info/video/WHQwMjNRaExfLWs=/atari_falcon_030_dsp_3d_engine_test">http://www.digiti.info/video/WHQwMjNRaExfLWs=/atari_falcon_030_dsp_3d_engine_test</a>
</li>

<li>Atari Falcon030 (německy)<br />
<a href="http://www.maedicke.de/atari/hardware/falcon.htm">http://www.maedicke.de/atari/hardware/falcon.htm</a>
</li>

<li>Old-computers.com: Atari Falcon030<br />
<a href="http://www.old-computers.com/museum/computer.asp?c=125&st=1">http://www.old-computers.com/museum/computer.asp?c=125&st=1</a>
</li>

<li>Atari Falcon030 (Wikipedia)<br />
<a href="http://en.wikipedia.org/wiki/Atari_Falcon">http://en.wikipedia.org/wiki/Atari_Falcon</a>
</li>

<li>Past and current projects (including Falcon stuff)<br />
<a href="http://os.inf.tu-dresden.de/~nf2/projects/projects.html">http://os.inf.tu-dresden.de/~nf2/projects/projects.html</a>
</li>

<li>Atari Falcon 030: The Case For The Defence<br />
<a href="http://www.soundonsound.com/sos/1994_articles/sep94/atarifalcon.html">http://www.soundonsound.com/sos/1994_articles/sep94/atarifalcon.html</a>
</li>

<li>DaVinci processor family<br />
<a href="http://www.ti.com/general/docs/datasheetdiagram.tsp?genericPartNumber=TMS320DM365&diagramId=64193">http://www.ti.com/general/docs/datasheetdiagram.tsp?genericPartNumber=TMS320DM365&diagramId=64193</a>
</li>

<li>Texas Instruments DaVinci<br />
<a href="https://en.wikipedia.org/wiki/Texas_Instruments_DaVinci">https://en.wikipedia.org/wiki/Texas_Instruments_DaVinci</a>
</li>

<li>TMS320DM6446 (DaVinci)<br />
<a href="http://www.ti.com/product/tms320dm6446">http://www.ti.com/product/tms320dm6446</a>
</li>

<li>Digital Media Video Processors (TI)<br />
<a href="http://www.ti.com/lsds/ti/processors/dsp/media_processors/davinci/products.page#">http://www.ti.com/lsds/ti/processors/dsp/media_processors/davinci/products.page#</a>
</li>

<li>TI Wiki<br />
<a href="http://processors.wiki.ti.com/index.php/Main_Page">http://processors.wiki.ti.com/index.php/Main_Page</a>
</li>

<li>C5000 ultra-low-power DSP<br />
<a href="http://www.ti.com/lsds/ti/processors/dsp/c5000_dsp/overview.page">http://www.ti.com/lsds/ti/processors/dsp/c5000_dsp/overview.page</a>
</li>

<li>OMAP (Wikipedia)<br />
<a href="https://en.wikipedia.org/wiki/OMAP">https://en.wikipedia.org/wiki/OMAP</a>
</li>

<li>OMAP - TI Wiki<br />
<a href="http://processors.wiki.ti.com/index.php/OMAP">http://processors.wiki.ti.com/index.php/OMAP</a>
</li>

<li>Why OMAP can't compete in smartphones<br />
<a href="http://www.eetimes.com/author.asp?section_id=40&doc_id=1286602">http://www.eetimes.com/author.asp?section_id=40&doc_id=1286602</a>
</li>

<li>Applications Processors – The Heart of the Smartphone<br />
<a href="http://www.engineering.com/ElectronicsDesign/ElectronicsDesignArticles/ArticleID/5791/Applications-Processors-The-Heart-of-the-Smartphone.aspx">http://www.engineering.com/ElectronicsDesign/ElectronicsDesignArticles/ArticleID/5791/Applications-Processors-The-Heart-of-the-Smartphone.aspx</a>
</li>

<li>TI cuts 1,700 jobs in OMAP shift<br />
<a href="http://www.eetimes.com/document.asp?doc_id=1262782">http://www.eetimes.com/document.asp?doc_id=1262782</a>
</li>

<li>VLIW: Very Long Instruction Word: Texas Instruments TMS320C6x<br />
<a href="http://www.ecs.umass.edu/ece/koren/architecture/VLIW/2/ti1.html">http://www.ecs.umass.edu/ece/koren/architecture/VLIW/2/ti1.html</a>
</li>

<li>An Introduction To Very-Long Instruction Word (VLIW) Computer Architecture<br />
Philips Semiconductors
</li>

<li>VLIW Architectures for DSP: A Two-Part Lecture (PDF, slajdy)<br />
<a href="http://www.bdti.com/MyBDTI/pubs/vliw_icspat99.pdf">http://www.bdti.com/MyBDTI/pubs/vliw_icspat99.pdf</a>
</li>

<li>Very long instruction word (Wikipedia)<br />
<a href="https://en.wikipedia.org/wiki/Very_long_instruction_word">https://en.wikipedia.org/wiki/Very_long_instruction_word</a>
</li>

<li>A VLIW Approach to Architecture, Compilers and Tools<br />
<a href="http://www.vliw.org/book/">http://www.vliw.org/book/</a>
</li>

<li>VEX Toolchain (VEX = VLIW Example)<br />
<a href="http://www.hpl.hp.com/downloads/vex/">http://www.hpl.hp.com/downloads/vex/</a>
</li>

<li>Elbrus (computer)<br />
<a href="https://en.wikipedia.org/wiki/Elbrus_%28computer%29">https://en.wikipedia.org/wiki/Elbrus_%28computer%29</a>
</li>

<li>Super Harvard Architecture Single-Chip Computer<br />
<a href="https://en.wikipedia.org/wiki/Super_Harvard_Architecture_Single-Chip_Computer">https://en.wikipedia.org/wiki/Super_Harvard_Architecture_Single-Chip_Computer</a>
</li>

<li>Digital Signal Processors (stránky TI)<br />
<a href="http://www.ti.com/lsds/ti/processors/dsp/overview.page">http://www.ti.com/lsds/ti/processors/dsp/overview.page</a>
</li>

<li>C674x Low Power DSP (stránky TI)<br />
<a href="http://www.ti.com/lsds/ti/processors/dsp/c6000_dsp/c674x/overview.page">http://www.ti.com/lsds/ti/processors/dsp/c6000_dsp/c674x/overview.page</a>
</li>

<li>TMS320C30 (stránky TI)<br />
<a href="http://www.ti.com/product/tms320c30">http://www.ti.com/product/tms320c30</a>
</li>

<li>TMS320C6722B<br />
<a href="http://www.ti.com/product/tms320c6722b/description">http://www.ti.com/product/tms320c6722b/description</a>
</li>

<li>Introduction to DSP<br />
<a href="http://www.ti.com/lit/wp/spry281/spry281.pdf">http://www.ti.com/lit/wp/spry281/spry281.pdf</a>
</li>

<li>The Evolution of TMS (Family of DSPs)<br />
<a href="http://www.slideshare.net/moto_modx/theevo1">http://www.slideshare.net/moto_modx/theevo1</a>
</li>

<li>Datasheet k TMS32010<br />
<a href="http://www.datasheetarchive.com/dlmain/49326c32a52050140abffe6f0ac4894aa09889/M/TMS32010">http://www.datasheetarchive.com/dlmain/49326c32a52050140abffe6f0ac4894aa09889/M/TMS32010</a>
</li>

<li>1979: Single Chip Digital Signal Processor Introduced<br />
<a href="http://www.computerhistory.org/siliconengine/single-chip-digital-signal-processor-introduced/">http://www.computerhistory.org/siliconengine/single-chip-digital-signal-processor-introduced/</a>
</li>

<li>The TMS32010. The DSP chip that changed the destiny of a semiconductor giant<br />
<a href="http://www.tihaa.org/historian/TMS32010-12.pdf">http://www.tihaa.org/historian/TMS32010-12.pdf</a>
</li>

<li>Texas Instruments TMS320 (Wikipedia)<br />
<a href="https://en.wikipedia.org/wiki/Texas_Instruments_TMS320">https://en.wikipedia.org/wiki/Texas_Instruments_TMS320</a>
</li>

<li>Great Microprocessors of the Past and Present: Part IX: Signetics 8x300, Early cambrian DSP ancestor (1978):<br />
<a href="http://www.cpushack.com/CPU/cpu2.html#Sec2Part9">http://www.cpushack.com/CPU/cpu2.html#Sec2Part9</a>
</li>

<li>Great Microprocessors of the Past and Present (V 13.4.0)<br />
<a href="http://jbayko.sasktelwebsite.net/cpu.html">http://jbayko.sasktelwebsite.net/cpu.html</a>
</li>

<li>Introduction to DSP - DSP processors:<br />
<a href="http://www.bores.com/courses/intro/chips/index.htm">http://www.bores.com/courses/intro/chips/index.htm</a>
</li>

<li>The Scientist and Engineer's Guide to Digital Signal Processing:<br />
<a href="http://www.dspguide.com/">http://www.dspguide.com/</a>
</li>

<li>Digital signal processor (Wikipedia EN)<br />
<a href="http://en.wikipedia.org/wiki/Digital_signal_processor">http://en.wikipedia.org/wiki/Digital_signal_processor</a>
</li>

<li>Digitální signálový procesor (Wikipedia CZ)<br />
<a href="http://cs.wikipedia.org/wiki/Digitální_signálový_procesor">http://cs.wikipedia.org/wiki/Digitální_signálový_procesor</a>
</li>

<li>Digital Signal Processing FAQs<br />
<a href="http://dspguru.com/dsp/faqs">http://dspguru.com/dsp/faqs</a>
</li>

<li>Reprezentace numerických hodnot ve formátech FX a FP<br />
<a href="http://www.root.cz/clanky/fixed-point-arithmetic/">http://www.root.cz/clanky/fixed-point-arithmetic/</a>
</li>

<li>IEEE 754 a její příbuzenstvo: FP formáty<br />
<a href="http://www.root.cz/clanky/norma-ieee-754-a-pribuzni-formaty-plovouci-radove-tecky/">http://www.root.cz/clanky/norma-ieee-754-a-pribuzni-formaty-plovouci-radove-tecky/</a>
</li>

<li>Čtyři základní způsoby uložení čísel pomocí FX formátů<br />
<a href="http://www.root.cz/clanky/binarni-reprezentace-numerickych-hodnot-v-fx-formatu/">http://www.root.cz/clanky/binarni-reprezentace-numerickych-hodnot-v-fx-formatu/</a>
</li>

<li>Základní aritmetické operace prováděné v FX formátu<br />
<a href="http://www.root.cz/clanky/zakladni-aritmeticke-operace-provadene-ve-formatu-fx/">http://www.root.cz/clanky/zakladni-aritmeticke-operace-provadene-ve-formatu-fx/</a>
</li>

<li>Aritmetické operace s hodnotami uloženými ve formátu FP<br />
<a href="http://www.root.cz/clanky/aritmeticke-operace-s-hodnotami-ve-formatu-plovouci-radove-carky/">http://www.root.cz/clanky/aritmeticke-operace-s-hodnotami-ve-formatu-plovouci-radove-carky/</a>
</li>

<li>FIR Filter FAQ<br />
<a href="http://dspguru.com/dsp/faqs/fir">http://dspguru.com/dsp/faqs/fir</a>
</li>

<li>Finite impulse response (Wikipedia)<br />
<a href="http://en.wikipedia.org/wiki/Finite_impulse_response">http://en.wikipedia.org/wiki/Finite_impulse_response</a>
</li>

<li>DSPRelated<br />
<a href="http://www.dsprelated.com/">http://www.dsprelated.com/</a>
</li>

<li>Addressing mode (Wikipedia)<br />
<a href="https://en.wikipedia.org/wiki/Addressing_mode">https://en.wikipedia.org/wiki/Addressing_mode</a>
</li>

<li>Orthogonal instruction set<br />
<a href="https://en.wikipedia.org/wiki/Orthogonal_instruction_set">https://en.wikipedia.org/wiki/Orthogonal_instruction_set</a>
</li>

<li>TI 16-bit and 32-bit microcontrollers<br />
<a href="http://www.ti.com/lsds/ti/microcontrollers_16-bit_32-bit/overview.page">http://www.ti.com/lsds/ti/microcontrollers_16-bit_32-bit/overview.page</a>
</li>

<li>TMS 32010 Assembly Language Programmer's Guide (kniha na Amazonu)<br />
<a href="https://www.amazon.com/32010-Assembly-Language-Programmers-Guide/dp/0904047423">https://www.amazon.com/32010-Assembly-Language-Programmers-Guide/dp/0904047423</a>
</li>

<li>COSC2425: PC Architecture and Machine Language, PC Assembly Language<br />
<a href="http://www.austincc.edu/rblack/courses/COSC2425/index.html">http://www.austincc.edu/rblack/courses/COSC2425/index.html</a>
</li>

</ol>



<p></p><p></p>
<p><small>Autor: <a href="http://www.fit.vutbr.cz/~tisnovpa">Pavel Tišnovský</a> &nbsp; 2017</small></p>
</body>
</html>

