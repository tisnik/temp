<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
        "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html>
<head>
<title>RISCová architektura PowerPC: operace s vektory</title>
<meta name="Author" content="Pavel Tisnovsky" />
<meta name="Generator" content="vim" />
<meta http-equiv="content-type" content="text/html; charset=utf-8" />
<style type="text/css">
         body {color:#000000; background:#ffffff;}
         h1  {font-family: arial, helvetica, sans-serif; color:#ffffff; background-color:#c00000; text-align:center; padding-left:1em}
         h2  {font-family: arial, helvetica, sans-serif; color:#ffffff; background-color:#0000c0; padding-left:1em; text-align:left}
         h3  {font-family: arial, helvetica, sans-serif; color:#000000; background-color:#c0c0c0; padding-left:1em; text-align:left}
         h4  {font-family: arial, helvetica, sans-serif; color:#000000; background-color:#e0e0e0; padding-left:1em; text-align:left}
         a   {font-family: arial, helvetica, sans-serif;}
         li  {font-family: arial, helvetica, sans-serif; color:#000000; text-align:justify; width:450px;}
         ol  {font-family: arial, helvetica, sans-serif; color:#000000; text-align:justify; width:450px;}
         ul  {font-family: arial, helvetica, sans-serif; color:#000000; text-align:justify; width:450px;}
         p   {font-family: arial, helvetica, sans-serif; color:#000000; text-align:justify;}
         pre {background:#e0e0e0}
</style>
</head>

<body>

<h1>RISCová architektura PowerPC: operace s vektory</h1>

<h3>Pavel Tišnovský</h3>

<p></p>

<h1>Úvodník</h1>

<p>Prakticky u všech RISCových architektur, které jsme si prozatím v tomto seriálu popsali, nalezneme rozšíření původní instrukční sady určená pro provádění operací s vektory dat. Podobné rozšíření najdeme i u architektury PowerPC, a to pod různými názvy: AltiVec, Velocity Engine či Vector Multimedia Extension.</p>



<h2>Obsah</h2>

<p><a href="#k01">1. RISCová architektura PowerPC: operace s&nbsp;vektory</a></p>
<p><a href="#k02">2. Rozšíření instrukčních sad RISCových procesorů umožňující práci s&nbsp;vektory</a></p>
<p><a href="#k03">3. Sada registrů určená pro vektorové operace na procesorech PowerPC</a></p>
<p><a href="#k04">4. Vektorové pracovní registry VR0 až VR31</a></p>
<p><a href="#k05">5. VSCR &ndash; Vector Status and Control Register</a></p>
<p><a href="#k06">6. Vyřešení problému s&nbsp;přepínáním kontextu: registr VRSAVE</a></p>
<p><a href="#k07">7. Podporované formáty vektorů</a></p>
<p><a href="#k08">8. Blok Vector Permute Unit (VPU)</a></p>
<p><a href="#k09">9. Blok Vector Arithmetic Logic Unit (VALU)</a></p>
<p><a href="#k10">10. Instrukce pro načtení či uložení vektorů, vyřešení problémů se zarovnáním dat</a></p>
<p><a href="#k11">11. Celočíselné vektorové operace</a></p>
<p><a href="#k12">12. Saturace v&nbsp;celočíselných operacích</a></p>
<p><a href="#k13">13. Jména instrukcí</a></p>
<p><a href="#k14">14. Obsah druhého pokračování článku</a></p>
<p><a href="#k15">15. Odkazy na Internetu</a></p>



<p><a name="k01"></a></p>
<h2 id="k01">1. RISCová architektura PowerPC: operace s&nbsp;vektory</h2>

<p>Klasické RISCové architektury, s&nbsp;nimiž jsme se až doposud setkali, byly
většinou již v&nbsp;devadesátých letech minulého století rozšířeny o nové sady
instrukcí určených pro provádění operací nad vektory. Pod pojmem
&bdquo;vektor&ldquo; se v&nbsp;této oblasti skrývá datová struktura o šířce
typicky 64 či 128 bitů, která je rozdělena do prvků, z&nbsp;nichž každý mívá
šířku 8, 16, 32 či 64 bitů a je do něj uložena celočíselná hodnota (se
znaménkem či bez znaménka) popř.&nbsp;hodnota reprezentovaná ve formátu
plovoucí řádové čárky. Nad takto reprezentovanými datovými strukturami je
vystavěna sada specializovaných instrukcí, které například dokážou sečíst dva
vektory s&nbsp;formátem 4 prvky po 16bitech, provést permutaci prvků
v&nbsp;jednom vektoru, výběr prvků na základě bitového pole atd. Důležité je,
že zvolená operace se vždy provádí paralelně nad všemi prvky vektoru (vektorů),
což je odlišné chování od prapůvodních <i>vektorových procesorů</i>, které byly
založeny na sekvenčním provádění operací a velmi hluboké pipeline (příkladem
původního konceptu mohou být první modely superpočítačů <i>Cray</i>).</p>

<p>V&nbsp;dnešním článku se budeme zabývat popisem technologie nazývané
<i>AltiVec</i>, kterou mohou (ale nutně nemusí) být vybaveny mikroprocesory
s&nbsp;architekturou PowerPC. Ve skutečnosti není <i>AltiVec</i> jediným názvem
této technologie, protože se můžeme setkat taktéž s&nbsp;označením <i>Velocity
Engine</i> či <i>Vector Multimedia Extension</i>. Důvodem, proč se tato
technologie může jmenovat různě, spočívá v&nbsp;tom, že <i>AltiVec</i> je
ochrannou známkou společnosti FreeScale, takže například firma Apple, která
čipy PowerPC používala ve svých počítačích, začala namísto <i>AltiVec</i>
prosazovat jméno <i>Velocity Engine</i> a IBM pak <i>VMX</i> neboli <i>Vector
Multimedia Extension</i>. Pojmenování IBM je sice příliš dlouhé a není příliš
&bdquo;cool&ldquo;, ale zato poměrně přesně vystihuje určení této technologie
&ndash; 3D grafika (dnes již pravděpodobně bezpředmětné), kodeky, obecné
zpracování signálů atd.</p>



<p><a name="k02"></a></p>
<h2 id="k02">2. Rozšíření instrukčních sad RISCových procesorů umožňující práci s&nbsp;vektory</h2>

<p>S&nbsp;rozšířením instrukčních sad mikroprocesorů s&nbsp;původně čistě
RISCovou instrukční sadou o vektorové operace (přesněji řečeno i SIMD operace)
jsme se již v&nbsp;tomto seriálu setkali, a to dokonce hned několikrát. Jen pro
krátké připomenutí:</p>

<ol>

<li>Typickým příkladem čistého RISCového mikroprocesoru byla původní
architektura MIPS představovaná mikroprocesory <i>R2000</i> (rok vzniku 1985) a
<i>R3000</i> (rok vzniku 1988). Aby bylo možné každý krok instrukce provést
v&nbsp;pětiřezové instrukční pipeline za jediný takt, neobsahovaly tyto
mikroprocesory ani instrukce se složitými adresovacími režimy, ani instrukce
pro celočíselné násobení a dělení. V&nbsp;dalších revizích architektury
<i>MIPS</i> však docházelo k&nbsp;postupnému rozšiřování instrukční sady a tím
pádem i k&nbsp;přidávání dalších funkčních jednotek buď přímo na čip
s&nbsp;mikroprocesorem, nebo na další pomocné čipy (koprocesory). V&nbsp;roce
1996 byly představeny první čipy implementující rozšiřující instrukční sadu
<i>MDMX</i> neboli <i>MIPS Digital Media eXtension</i>. Tato instrukční sada
byla o tři roky později následována další rozšiřující instrukční sadou
s&nbsp;všeříkajícím názvem <i>MIPS-3D</i>.</li>

<li>Rozšíření označované <i>MDMX</i> neboli <i>MadMax</i> je orientováno na
celočíselné operace, včetně sčítání a odčítání se saturací. Vektory mají
v&nbsp;tomto případě šířku 64bitů a mohou být rozděleny na prvky o menší bitové
šířce (bajt atd.).</li>

<li>Naproti tomu <i>MIPS-3D</i> obsahuje 13 nových instrukcí orientovaných na
3D grafiku: transformace vertexů, normalizaci vektorů, aplikaci perspektivní
projekce atd. V&nbsp;současnosti je sice možné provádění těchto operací
přenechat grafickému akcelerátoru, ale v&nbsp;době vzniku technologie
<i>MIPS-3D</i> byly grafické akcelerátory určeny především pro rasterizaci
trojúhelníků a řešení viditelnosti pomocí paměti hloubky (<i>Z-bufferu</i>),
zatímco základní zpracování trojrozměrné scény bylo ponecháno na
mikroprocesoru.</li>

<li>Podobný &bdquo;osud&ldquo; čekal i RISCové mikroprocesory PA-RISC. Prvním
rozšířením instrukční sady o SIMD operace je technologie nazvaná <i>Multimedia
Acceleration eXtensions 1 (MAX-1)</i>, která z&nbsp;pohledu programátora
instrukční sadu rozšířila o pouhých devět pečlivě vybraných instrukcí. Nové
instrukce byly určeny pro zpracování šestnáctibitových slov nazývaných
&bdquo;subword data&ldquo;, popř.&nbsp;&bdquo;halfword data&ldquo; (označením
&bdquo;word&ldquo; jsou v&nbsp;případě 32bitových mikroprocesorů PA-RISC
samozřejmě myšlena 32bitová slova, menší informační jednotky se původně
neadresovaly). Vždy dvojice šestnáctibitových slov mohla být uložena do
libovolného pracovního registru <strong>GR1</strong> až <strong>GR31</strong>,
protože registr <strong>GR0</strong> obsahoval konstantu 0, jak je tomu ostatně
u RISCových procesorů zvykem. Vzhledem k&nbsp;tomu, že každý pracovní registr
mohl v&nbsp;případě nových instrukcí <i>MAX-1</i> obsahovat dva prvky,
znamenalo to dvojnásobné urychlení některých základních aritmetických operací.
Ve skutečnosti však bylo možné díky párování ALU instrukcí pro dvě paralelně
pracující aritmeticko-logické jednotky dosáhnout až čtyřnásobného urychlení.
Jinými slovy: pokud nenastaly kolize při přístupu k&nbsp;pracovním registrům,
bylo možné v&nbsp;každém taktu dokončit čtyři ALU operace prováděné nad
šestnáctibitovými půlslovy (halfword). V&nbsp;době vzniku technologie
<i>MAX-1</i>, kdy se výpočetní výkon mikroprocesorů pohyboval na hraně
použitelnosti pro multimediální aplikace (například pro přehrávání videa ve
formátu <i>MPEG-1</i>) se tedy jednalo o dosti výraznou pomoc.</li>

<li>Další řadou RISCových mikroprocesorů je po <i>MIPS</i> a <i>PA-RISC</i>
architektura <i>SPARC</i>, resp.&nbsp;přesněji <i>UltraSPARC</i>. Tyto
mikroprocesory začaly být doplňovány technologií nazvanou <i>VIS</i>, což je
zkratka plného názvu &bdquo;Visual Instruction Set&ldquo;. Instrukční sada
<i>VIS</i> se v&nbsp;mnoha ohledech odlišuje od výše popsané sady
<i>MIPS-3D</i>, což však není překvapivé, protože se jedná o instrukční sadu
určenou pro jiné účely. V&nbsp;rámci <i>VIS</i> byly mikroprocesory
<i>UltraSPARC</i> obohaceny o přibližně padesát nových instrukcí, které
implementovaly aritmetické operace, logické operace, rozbalení a zabalení dat
ve vektorech, změnu zarovnání dat ve vektorech, datové konverze a na závěr i
operace zjednodušující adresování jednorozměrných, dvourozměrných a
trojrozměrných polí. Nesmíme zapomenout ani na blokové operace, které
v&nbsp;době vzniku této technologie umožňovaly blokový přenos dat rychlostí až
300 MB/sekundu, a to při libovolném zarovnání.</li>

<li>Dostáváme se k&nbsp;asi nejznámějším RISCovým procesorům současnosti
&ndash; k&nbsp;čipům ARM. Pro tyto čipy bylo navrženo rozšíření instrukční sady
známé pod jménem <i>Vector Floating Point</i>. Technologie <i>VFP</i> byla
navržena takovým způsobem, aby ji bylo možné použít v&nbsp;mnoha aplikačních
oblastech, například v&nbsp;řídicích jednotkách automobilů, pro zpracování
obrazu (konvoluční filtry, rychlá Fourierova transformace, rasterizace a další
operace prováděné v&nbsp;tiskových procesorech), při zpracování řeči (kodeky) a
taktéž pro provádění různých 3D operací (transformace) &ndash; právě
v&nbsp;těchto oblastech lze totiž využít práci nikoli pouze se skalárními
hodnotami, ale taktéž s&nbsp;vektory o dvou až osmi prvcích. Zajímavé je, že
později došlo ke sloučení <i>VFP</i> s&nbsp;architekturou <i>NEON</i>.</li>

<li>Původní architektura <i>VFPv1</i> je již dnes považována za překonanou a
v&nbsp;žádných současných čipech se s&nbsp;níž již nesetkáme. Druhá verze této
architektury <i>VFPv2</i> začala být používána na některých čipech ARMv5E,
ARMv5TEJ a taktéž na ARMv6 &ndash; instrukce <i>VFP</i> v&nbsp;tomto případě
rozšiřovaly původní instrukční sady <i>ARM</i>. Zajímavější je dnes třetí verze
architektury <i>VFP</i> značená <i>VFPv3</i> používaná od <i>ARMv7</i>
(samozřejmě jen u vybraných čipů &ndash; zdaleka ne všechny aplikační oblasti
totiž nutně vyžadují matematický koprocesor). V&nbsp;tomto případě lze nové
&bdquo;vektorové&ldquo; instrukce používat v&nbsp;instrukční sadě ARM, Thumb i
ThumbEE (pozn.&nbsp;původně se prvky vektorů zpracovávaly sekvenčně kvůli
internímu omezení na jedinou FPU jednotku).</li>

<li>V&nbsp;některých čipech ARM je použita technologie <i>NEON</i>, která dosti
revolučním způsobem mění i konfiguraci interních bloků mikroprocesorů, zavádí
přibližně 100 nových instrukcí <i>SIMD</i> a taktéž rozšiřuje původní sadu
pracovních registrů o 32 nových registrů, z&nbsp;nichž každý má šířku 64 bitů.
Při návrhu technologie <i>NEON</i> se její tvůrci zaměřili na implementaci těch
operací, které se v&nbsp;praxi skutečně provádí, takže je například poměrně
snadné (a především efektivní) pracovat s&nbsp;různými formáty rastrových
bitmap, zpracovávat 16bitové zvukové vzorky při práci se stereo signálem atd.
V&nbsp;rámci technologie <i>NEON</i> byla původní sada registrů mikroprocesorů
<i>ARM</i> rozšířena o 32 nových 64bitových registrů nazvaných <i>d0</i> až
<i>d31</i>. Tyto registry se mohou u některých instrukcí sdružovat do párů a
vytvářet tak sadu 128bitových registrů nazvaných <i>q0</i> až <i>q15</i>
(<i>d0+d1</i> vytvoří registr <i>q0</i> atd.)</li>

</ol>

<p>Vidíme, že vektorové (SIMD) operace nejsou v&nbsp;oblasti RISCových (ale ani
CISCových) mikroprocesorů žádnou novinkou. To samé platí i pro PowerPC a
<i>AltiVec</i>. V&nbsp;navazujících kapitolách si možnosti <i>AltiVecu</i>
popíšeme podrobněji.</p>



<p><a name="k03"></a></p>
<h2 id="k03">3. Sada registrů určená pro vektorové operace na procesorech PowerPC</h2>

<p>Po shrnutí základních vlastností rozšíření vektorových instrukčních sad ve
vybraných &bdquo;konkurenčních&ldquo; RISCových mikroprocesorech se nyní
konečně můžeme vrátit k&nbsp;popisu architektury <i>AltiVec</i>. Pokud
mikroprocesory PowerPC toto rozšíření podporují, rozšiřuje se nám již známá
sada pracovních registrů o dalších 34 registrů. Základní charakteristiky těchto
nových registrů jsou shrnuty v&nbsp;následující tabulce:</p>

<table>
<tr><th>#</th><th>Zkratka</th><th>Bitová šířka</th><th>Význam zkratky</th><th>Stručný popis</th></tr>
<tr><td>1</td><td>VR0..VR31 (později až VR63)</td><td>128 bitů</td><td>Vector Register</td><td>(32 nebo 64 registrů) používaných jako zdroj a cíl většiny vektorových operací</td></tr>
<tr><td>2</td><td>VSCR</td><td>32 bitů</td><td>Vector Status and Control Register</td><td>stavový a řídicí registr</td></tr>
<tr><td>3</td><td>VRSAVE</td><td>32 bitů</td><td>VR Save Register</td><td>určení, které VR0..VR31 je zapotřebí uložit při přepnutí kontextu</td></tr>
</table>

<p>Poznámka: ze zkratkami registrů se setkáme jak v&nbsp;assembleru, tak i
v&nbsp;debuggerech.</p>



<p><a name="k04"></a></p>
<h2 id="k04">4. Vektorové pracovní registry VR0 až VR31</h2>

<p>Programátor běžných aplikací běžících v&nbsp;uživatelském prostoru se setká
především s&nbsp;první sadou nových (pracovních) registrů, které jsou
v&nbsp;assembleru či debuggerech označovány zkratkami <strong>VR0</strong> až
<strong>VR31</strong>. Každý z&nbsp;těchto třiceti dvou registrů má šířku 128
bitů a může obsahovat několik prvků vektorů. Počet prvků, které lze uložit do
128 bitů, je samozřejmě odvozen od jejich šířky, takže se může
v&nbsp;extrémních případech jednat o jediný prvek (<i>quad word</i>), ale též o
šestnáct prvků (<i>unsigned/signed byte</i>). Původní originální návrh
technologie <i>AltiVec</i> počítal skutečně s&nbsp;použitím třiceti dvou nových
vektorových pracovních registrů (tak, jak je to popsáno v&nbsp;Power ISA
v2.03), ovšem v&nbsp;rámci novější specifikace Power ISA v2.06 se tato sada
rozšířila na 64 registrů. Navíc ještě existuje ne zcela kompatibilní rozšíření
VMX128 se 128 registry. Toto rozšíření bylo použito v&nbsp;procesoru Xenon ve
známé herní konzoli Xbox 360 (podrobnější popis tohoto zajímavého čipu si
pravděpodobně vyžádá samostatný článek).</p>



<p><a name="k05"></a></p>
<h2 id="k05">5. VSCR &ndash; Vector Status and Control Register</h2>

<p>Na druhém řádku tabulky vidíme registr nazvaný <strong>VSCR</strong> neboli
<i>Vector Status and Control Register</i>. Jedná se o 32bitový registr,
v&nbsp;němž je ovšem ve skutečnosti využito pouze několik bitů, takže si
inženýři nechali prostor pro další bezproblémové rozšiřování. Jedním bitem je
řízen režim činnosti vektorového procesoru při zpracování hodnot
s&nbsp;plovoucí řádovou čárkou &ndash; lze povolit či zakázat použití režimu
plně kompatibilního se specifikací Javy (meziukládání výsledků, modifikátor
<strong>strictfp</strong> atd.). Další bit je použit při provádění
aritmetických operací se saturací. Pokud k&nbsp;saturaci dojde, je tento bit
nastaven na jedničku a zůstane tak nastaven až do doby, kdy je programově (tedy
explicitně) vynulován. Tím se chování tohoto bitu odlišuje od klasických
stavových (příznakových) bitů. Pro přenos dat mezi registrem
<strong>VSCR</strong> a vybraným vektorovým registrem <strong>VR0..31</strong>
slouží instrukce nazvané <strong>mfvscr</strong> a <strong>mtvscr</strong>,
které samozřejmě zpracovávají jen 32 bitů (ostatní bity
<strong>VR0..31</strong> jsou vynulovány).</p>



<p><a name="k06"></a></p>
<h2 id="k06">6. Vyřešení problému s&nbsp;přepínáním kontextu: registr VRSAVE</h2>

<p>Při přepínání kontextu mezi několika procesy či při volání služby jádra
operačního systému atd. je nutné uložit (a následně obnovit) stav pracovních i
stavových registrů procesoru. Týká se to i vektorových registrů
<strong>VR0..VR31</strong>, což však může potenciálně vést k&nbsp;výkonnostním
problémům, protože je teoreticky nutné přenést 32&times;128=4096 bitů (512
bajtů) při každém přepnutí kontextu. Aby se tato hodnota snížila, je
v&nbsp;technologii <i>AltiVec</i> použit speciální registr nazvaný příznačně
<strong>VRSAVE</strong>. Tento registr má šířku 32 bitů a obsahuje bitové
příznaky určující, které vektorové registry <strong>VR0..VR31</strong> se mají
skutečně uložit a které je naopak možné ignorovat (pro každý vektorový registr
je tedy ve <strong>VRSAVE</strong> rezervován jediný bit). Jedná se o poměrně
elegantní řešení celého problému, protože překladač (nebo i programátor) má
v&nbsp;každém okamžiku přesné informace o tom, jak jsou jednotlivé registry
využity (tuto informaci má již v&nbsp;době překladu, pokud se samozřejmě
nebavíme o JIT).</p>



<p><a name="k07"></a></p>
<h2 id="k07">7. Podporované formáty vektorů</h2>

<p>Již v&nbsp;předchozích kapitolách jsme si řekli, že vektorové registry mají
šířku 128 bitů. Do těchto 128 bitů je možné uložit různé typy prvků; vektor
však vždy obsahuje prvky stejného typu. Podporovány jsou následující
formáty:</p>

<table>
<tr><th>Typ prvku</th><th>Bitová šířka</th><th>Počet prvků ve vektoru</th></tr>
<tr><td>unsigned byte     </td><td>8 bitů</td><td>16</td></tr>
<tr><td>signed byte       </td><td>8 bitů</td><td>16</td></tr>
<tr><td>unsigned half word</td><td>16 bitů</td><td>8</td></tr>
<tr><td>signed half word  </td><td>16 bitů</td><td>8</td></tr>
<tr><td>unsigned word     </td><td>32 bitů</td><td>4</td></tr>
<tr><td>signed word       </td><td>32 bitů</td><td>4</td></tr>
<tr><td>unsigned quad word</td><td>128 bitů</td><td>1</td></tr>
<tr><td>signed quad word  </td><td>128 bitů</td><td>1</td></tr>
<tr><td>float/single      </td><td>32 bitů</td><td>4</td></tr>
</table>

<p>Formát rozdělení 128bitového vektorového registru si můžeme naznačit i
následujícím způsobem:</p>

<pre>
&nbsp;
+-------------------------------------------------------------------------------+
|                                    quadword                                   |
+-------------------+-------------------+-------------------+-------------------+
|      float0       |      float1       |      float2       |      float3       |
+-------------------+-------------------+-------------------+-------------------+
|       word0       |       word1       |       word2       |       word3       |
+---------+---------+---------+---------+---------+---------+---------+---------+
|  half0  |  half1  |  half2  |  half3  |  half4  |  half5  |  half6  |  half7  |
+----+----+----+----+----+----+----+----+----+----+----+----+----+----+----+----+
| b0 | b1 | b2 | b3 | b4 | b5 | b6 | b7 | b8 | b9 | b10|b11 |b12 |b13 |b14 |b15 |
+----+----+----+----+----+----+----+----+----+----+----+----+----+----+----+----+
:                                                                               :
:                                                                               :
:                                                                               :
bit0                                                                          bit127
&nbsp;
</pre>



<p><a name="k08"></a></p>
<h2 id="k08">8. Blok Vector Permute Unit (VPU)</h2>

<p>Některé čipy s&nbsp;architekturu PowerPC (G4 atd.) neprovádí vektorové
operace v&nbsp;jediném monolitickém &bdquo;vektorovém procesoru&ldquo;, ale ve
větším množství modulů, které mohou při dodržení určitých podmínek pracovat
samostatně a nezávisle na ostatních modulech. Prvním blokem je <i>Vector
Permute Unit</i> neboli zkráceně <i>VPU</i>. V&nbsp;tomto modulu se provádí
operace konverze vektorů, dosazení konstant do prvků vektorů, permutace prvků
(velmi užitečná a přitom univerzálně použitelná instrukce) atd. Důležité je, že
tento modul může běžet skutečně nezávisle na dalších modulech (a tedy provádět
instrukce téměř paralelně, přesněji řečeno tak rychle, jak jsou vkládány do
pipeline), ovšem pouze za předpokladu, že nedojde ke kolizi použitých registrů
s&nbsp;jiným modulem (zápis či čtení ze shodných registrů). O to, aby ke
kolizím nedocházelo, nebo aby k&nbsp;nim docházelo jen s&nbsp;nízkou frekvencí,
se musí postarat překladač, kterému samozřejmě pomáhá fakt, že má
k&nbsp;dispozici plných 32 vektorových registrů.</p>



<p><a name="k09"></a></p>
<h2 id="k09">9. Blok Vector Arithmetic Logic Unit (VALU)</h2>

<p>Druhým blokem vektorového procesoru je <i>VALU</i> neboli <i>Vector
Arithmetic Logic Unit</i>. V&nbsp;tomto bloku se provádí většina operací nad
prvky vektorů a vzhledem k&nbsp;tomu, že jsou podporovány jak celočíselné
operace, tak i operace s&nbsp;plovoucí řádovou čárkou, rozděluje se <i>VALU</i>
do několika jednotek:</p>

<table>
<tr><th>#</th><th>Jednotka</th><th>Plné jméno</th><th>Význam</th></tr>
<tr><td>1</td><td>VSIU</td><td>vector simple integer unit</td><td>součet, rozdíl, průměr, rotace, porovnání</td></tr>
<tr><td>2</td><td>VCIU</td><td>vector complex integer unit</td><td>delší instrukce typu násobení a dělení, MAC atd.</td></tr>
<tr><td>3</td><td>VFPU</td><td>vector floating-point unit</td><td>všechny FP operace</td></tr>
</table>

<p>Důvodem pro rozdělení na <strong>VSIU</strong> a <strong>VCIU</strong> je
fakt, že <strong>VSIU</strong> je realizován jedním řezem pipeline, kdežto
<strong>VCIU</strong> minimálně třemi řezy (větší latence).</p>



<p><a name="k10"></a></p>
<h2 id="k10">10. Instrukce pro načtení či uložení vektorů, vyřešení problémů se zarovnáním dat</h2>

<p>Pro načtení či uložení prvků vektorů slouží osm instrukcí, které jsou
vypsány v&nbsp;následující tabulce:</p>

<table>
<tr><th>#</th><th>Instrukce</th><th>Popis</th></tr>
<tr><td>1</td><td>lvebx </td><td>načtení bajtu</td></tr>
<tr><td>2</td><td>lvehx </td><td>načtení polovičního slova (<i>half word</i>)</td></tr>
<tr><td>3</td><td>lvewx </td><td>načtení celého slova či typu float</td></tr>
<tr><td>4</td><td>lvx   </td><td>načtení vektoru (<i>quad word</i>)</td></tr>
<tr><td>5</td><td>stvebx</td><td>uložení bajtu</td></tr>
<tr><td>6</td><td>stvehx</td><td>uložení polovičního slova (<i>half word</i>)</td></tr>
<tr><td>7</td><td>stvewx</td><td>uložení celého slova či typu float</td></tr>
<tr><td>8</td><td>stvx  </td><td>uložení vektoru (<i>quad word</i>)</td></tr>
</table>

<p>V&nbsp;instrukčním slovu o šířce 32 bitů se nachází tři bitová pole, která
slouží pro specifikaci zdrojového či cílového vektorového registru a taktéž pro
určení dvou pracovních registrů použitých pro adresování prvků v&nbsp;operační
paměti. Se způsobem adresování jsme se již setkali:</p>

<ol>

<li>Pokud je index prvního registru RA roven nule, je adresa určena přímo
druhým registrem RB</li>

<li>Pokud je index prvního registru RA nenulový, je adresa určena součtem
RA+RB</li>

</ol>

<p>Navíc se ještě spodních n-bitů adresy používá pro určení indexu prvku
vektoru, který se má načíst/uložit (pro tento účel nám postačují čtyři
bity).</p>



<p><a name="k11"></a></p>
<h2 id="k11">11. Celočíselné vektorové operace</h2>

<p>Podívejme se nyní na základní celočíselné operace prováděné s&nbsp;prvky
uloženými ve vektorech. Většina instrukcí obsahuje ve svém instrukčním slovu
specifikaci dvou zdrojových vektorových registrů a jednoho registru cílového
(jedná se tedy o takzvaný tříadresový kód):</p>

<table>
<tr><th> #</th><th>Instrukce</th><th>Popis</th></tr>
<tr><td> 1</td><td>vaddcuw</td><td>součet slov (bez znaménka)</td></tr>
<tr><td> 2</td><td>vaddubm</td><td>součet bajtů (bez znaménka) s&nbsp;přetečením</td></tr>
<tr><td> 3</td><td>vadduhm</td><td>dtto pro typ halfword (16 bitů)</td></tr>
<tr><td> 4</td><td>vadduwm</td><td>dtto pro typ word (32 bitů)</td></tr>
<tr><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td></tr>
<tr><td> 5</td><td>vsubcuw</td><td>rozdíl slov (bez znaménka)</td></tr>
<tr><td> 6</td><td>vsububm</td><td>rozdíl bajtů (bez znaménka) s&nbsp;přetečením</td></tr>
<tr><td> 7</td><td>vsubuhm</td><td>dtto pro typ halfword (16 bitů)</td></tr>
<tr><td> 8</td><td>vsubuwm</td><td>dtto pro typ word (32 bitů)</td></tr>
<tr><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td></tr>
<tr><td> 9</td><td>vmulesb</td><td>součin bajtů (sudé prvky vektorů &ndash; výsledkem jsou 16bitové hodnoty)</td></tr>
<tr><td>10</td><td>vmuleub</td><td>dtto, ale bez znaménka</td></tr>
<tr><td>11</td><td>vmulesh</td><td>součin halfword (sudé prvky vektorů &ndash; výsledkem jsou 32bitové hodnoty)</td></tr>
<tr><td>12</td><td>vmuleuh</td><td>dtto, ale bez znaménka</td></tr>
<tr><td>13</td><td>vmulosb</td><td>součin bajtů (liché prvky vektorů &ndash; výsledkem jsou 16bitové hodnoty)</td></tr>
<tr><td>14</td><td>vmuloub</td><td>dtto, ale bez znaménka</td></tr>
<tr><td>15</td><td>vmulosh</td><td>součin halfword (liché prvky vektorů &ndash; výsledkem jsou 32bitové hodnoty)</td></tr>
<tr><td>16</td><td>vmulouh</td><td>dtto, ale bez znaménka</td></tr>
</table>

<p>U operací násobení je výsledek uložen ve dvojnásobném počtu bitů. Je to
ostatně logické, protože například prvek typu <i>unsigned byte</i> může
obsahovat maximální hodnotu 255 a součin 255&times;255=65025, což je hodnota,
pro jejíž reprezentaci potřebujeme minimálně šestnáct bitů. Proto jsou výsledky
vždy uloženy ve dvou sousedních prvcích vektorů; resp.&nbsp;se provede konverze
byte&rarr;halfword&rarr;word.</p>



<p><a name="k12"></a></p>
<h2 id="k12">12. Saturace v&nbsp;celočíselných operacích</h2>

<p>Mnoho aritmetických operací existuje ve dvou variantách. V&nbsp;první
variantě zmíněné v&nbsp;předchozí kapitole mohou výsledky přetékat, což
například znamená, že ve chvíli, kdy se sčítají prvky typu <i>unsigned byte</i>
a mají se sečíst dva prvky s&nbsp;hodnotami 200 a 100, je výsledkem hodnota 44
a nikoli 300. Při saturaci je naopak výsledkem maximální reprezentovatelná
hodnota, tedy 255:</p>

<table>
<tr><th> #</th><th>Instrukce</th><th>Popis</th></tr>
<tr><td> 1</td><td>vaddsbs</td><td>součet bajtů (se znaménkem) se saturací</td></tr>
<tr><td> 2</td><td>vaddshs</td><td>dtto pro typ halfword (16 bitů)</td></tr>
<tr><td> 3</td><td>vaddsws</td><td>dtto pro typ word (32 bitů)</td></tr>
<tr><td> 4</td><td>vaddubs</td><td>součet bajtů (bez znaménka) se saturací</td></tr>
<tr><td> 5</td><td>vadduhs</td><td>dtto pro typ halfword (16 bitů)</td></tr>
<tr><td> 6</td><td>vadduws</td><td>dtto pro typ word (32 bitů)</td></tr>
<tr><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td></tr>
<tr><td> 7</td><td>vsubsbs</td><td>rozdíl bajtů (se znaménkem) se saturací</td></tr>
<tr><td> 8</td><td>vsubshs</td><td>dtto pro typ halfword (16 bitů)</td></tr>
<tr><td> 9</td><td>vsubsws</td><td>dtto pro typ word (32 bitů)</td></tr>
<tr><td>10</td><td>vsububs</td><td>rozdíl bajtů (bez znaménka) se saturací</td></tr>
<tr><td>11</td><td>vsubuhs</td><td>dtto pro typ halfword (16 bitů)</td></tr>
<tr><td>12</td><td>vsubuws</td><td>dtto pro typ word (32 bitů)</td></tr>
</table>



<p><a name="k13"></a></p>
<h2 id="k13">13. Jména instrukcí</h2>

<p>Jména instrukcí určených pro operaci s&nbsp;vektory jsou sice velmi dlouhá,
ale jsou (většinou) sestavená logicky:</p>

<ol>

<li>První písmeno je ve všech případech <strong>v</strong>, pochopitelně od
slova <i>vector</i>.</li>

<li>Následuje jméno operace, například <strong>add</strong> či
<strong>sub</strong>.</li>

<li>Písmeno <strong>u</strong> značí typ <i>unsigned</i>, <strong>s</strong>
pak <i>signed</i> (ovšem pokud se nepoužije saturace, není v&nbsp;prováděných
operacích žádný rozdíl).</li>

<li>Písmeno <strong>e</strong> značí sudé prvky (<i>even</i>),
<strong>o</strong> pak liché prvky (<i>odd</i>), což platí například pro
operace násobení, kdy je výsledek uložen v&nbsp;dvojnásobném počtu bitů.</li>

<li>Další znak označuje typ &ndash; <strong>b</strong>yte,
<strong>h</strong>alfword či <strong>w</strong>ord.</li>

<li>Pokud je posledním písmenem <strong>m</strong>, jedná se o operaci typu
&bdquo;modulo&ldquo;, tedy s&nbsp;případným přetečením výsledků.</li>

</ol>



<p><a name="k14"></a></p>
<h2 id="k14">14. Obsah druhého pokračování článku</h2>

<p>Ve druhé (a současně i závěrečné) části tohoto článku popis technologie
<i>AltiVec</i> dokončíme. Věnovat se budeme různým instrukcím určeným pro
permutaci prvků ve vektorech (<i>permute</i>, <i>merge</i>, <i>splat</i>,
<i>select</i>), dále pak instrukcím pracujícím se speciálním typem
&bdquo;pixel&ldquo; (to je dosti zajímavá část <i>AltiVecu</i>) a samozřejmě
nezapomeneme ani na zbývající aritmetické instrukce typu MAC (Multiply and
Accumulate), operace s&nbsp;hodnotami s&nbsp;plovoucí řádovou čárkou atd.</p>



<p><a name="k15"></a></p>
<h2 id="k15">15. Odkazy na Internetu</h2>

<ol>

<li>G4 Overview<br />
<a href="https://www.cs.umd.edu/class/fall2001/cmsc411/proj01/g4/">https://www.cs.umd.edu/class/fall2001/cmsc411/proj01/g4/</a>
</li>

<li>Unrolling AltiVec, Part 1: Introducing the PowerPC SIMD unit<br />
<a href="http://www.ibm.com/developerworks/library/pa-unrollav1/index.html">http://www.ibm.com/developerworks/library/pa-unrollav1/index.html</a>
</li>

<li>SIMD architectures<br />
<a href="http://arstechnica.com/features/2000/03/simd/">http://arstechnica.com/features/2000/03/simd/</a>
</li>

<li>Procesory RISC v pracovních stanicích a serverech - architektura SPARC V8 a<br />
<a href="http://www.root.cz/clanky/procesory-risc-v-pracovnich-stanicich-a-serverech-architektura-sparc-v8-a-v9/">http://www.root.cz/clanky/procesory-risc-v-pracovnich-stanicich-a-serverech-architektura-sparc-v8-a-v9/</a>
</li>

<li>Procesory RISC v pracovních stanicích a serverech - architektura PA-RISC<br />
<a href="http://www.root.cz/clanky/procesory-risc-v-pracovnich-stanicich-a-serverech-architektura-pa-risc/">http://www.root.cz/clanky/procesory-risc-v-pracovnich-stanicich-a-serverech-architektura-pa-risc/</a>
</li>

<li>Rozšíření instrukční sady procesorových jader s otevřenou architekturou RISC-V<br />
<a href="http://www.root.cz/clanky/rozsireni-instrukcni-sady-procesorovych-jader-s-otevrenou-architekturou-risc-v/">http://www.root.cz/clanky/rozsireni-instrukcni-sady-procesorovych-jader-s-otevrenou-architekturou-risc-v/</a>
</li>

<li>Práce s hodnotami s plovoucí řádovou čárkou na mikroprocesorech ARM<br />
<a href="http://www.root.cz/clanky/prace-s-hodnotami-s-plovouci-radovou-carkou-na-mikroprocesorech-arm/">http://www.root.cz/clanky/prace-s-hodnotami-s-plovouci-radovou-carkou-na-mikroprocesorech-arm/</a>
</li>

<li>Simplified PowerPC Instruction Set<br />
<a href="http://www.ds.ewi.tudelft.nl/vakken/in101/labcourse/instruction-set/">http://www.ds.ewi.tudelft.nl/vakken/in101/labcourse/instruction-set/</a>
</li>

<li>Assembly language for Power Architecture, Part 1: Programming concepts and beginning PowerPC instructions<br />
<a href="http://www.ibm.com/developerworks/linux/library/l-powasm1/index.html">http://www.ibm.com/developerworks/linux/library/l-powasm1/index.html</a>
</li>

<li>Assembly language for Power Architecture, Part 2: The art of loading and storing on PowerPC<br />
<a href="http://www.ibm.com/developerworks/linux/library/l-powasm2/index.html">http://www.ibm.com/developerworks/linux/library/l-powasm2/index.html</a>
</li>

<li>Assembly language for Power Architecture, Part 3: Programming with the PowerPC branch processor<br />
<a href="http://www.ibm.com/developerworks/library/l-powasm3/index.html">http://www.ibm.com/developerworks/library/l-powasm3/index.html</a>
</li>

<li>Assembly language for Power Architecture, Part 4: Function calls and the PowerPC 64-bit ABI<br />
<a href="http://www.ibm.com/developerworks/linux/library/l-powasm4/index.html">http://www.ibm.com/developerworks/linux/library/l-powasm4/index.html</a>
</li>

<li>PowerPC overview (poněkud starší materiály z&nbsp;roku 2006)<br />
<a href="http://titancity.com/articles/ppc.html">http://titancity.com/articles/ppc.html</a>
</li>

<li>PowerPC (Wikipedia)<br />
<a href="https://en.wikipedia.org/wiki/PowerPC">https://en.wikipedia.org/wiki/PowerPC</a>
</li>

<li>Status Register<br />
<a href="https://en.wikipedia.org/wiki/Status_register">https://en.wikipedia.org/wiki/Status_register</a>
</li>

<li>Why Learn Assembly Language?<br />
<a href="http://www.codeproject.com/Articles/89460/Why-Learn-Assembly-Language">http://www.codeproject.com/Articles/89460/Why-Learn-Assembly-Language</a>
</li>

<li>Is Assembly still relevant?<br />
<a href="http://programmers.stackexchange.com/questions/95836/is-assembly-still-relevant">http://programmers.stackexchange.com/questions/95836/is-assembly-still-relevant</a>
</li>

<li>Why Learning Assembly Language Is Still a Good Idea<br />
<a href="http://www.onlamp.com/pub/a/onlamp/2004/05/06/writegreatcode.html">http://www.onlamp.com/pub/a/onlamp/2004/05/06/writegreatcode.html</a>
</li>

<li>Assembly language today<br />
<a href="http://beust.com/weblog/2004/06/23/assembly-language-today/">http://beust.com/weblog/2004/06/23/assembly-language-today/</a>
</li>

<li>RISC-V Draft Sompressed ISA Version 1.9 Released<br />
<a href="https://blog.riscv.org/2015/11/risc-v-draft-compressed-isa-version-1-9-released/">https://blog.riscv.org/2015/11/risc-v-draft-compressed-isa-version-1-9-released/</a>
</li>

<li>RISC vs. CISC: the Post-RISC Era<br />
<a href="http://archive.arstechnica.com/cpu/4q99/risc-cisc/rvc-1.html">http://archive.arstechnica.com/cpu/4q99/risc-cisc/rvc-1.html</a>
</li>

<li>Introduction to ARM Thumb<br />
<a href="http://www.embedded.com/electronics-blogs/beginner-s-corner/4024632/Introduction-to-ARM-thumb">http://www.embedded.com/electronics-blogs/beginner-s-corner/4024632/Introduction-to-ARM-thumb</a>
</li>

<li>Code Size – a comprehensive comparison of microMIPS32 and Thumb code size using many Megabytes of customer code<br />
<a href="https://community.arm.com/groups/processors/blog/2014/04/28/code-size-a-comprehensive-comparison-of-micromips32-and-thumb-code-size-using-many-megabytes-of-customer-code">https://community.arm.com/groups/processors/blog/2014/04/28/code-size-a-comprehensive-comparison-of-micromips32-and-thumb-code-size-using-many-megabytes-of-customer-code</a>
</li>

<li>MIPS MCUs Outrun ARM<br />
<a href="http://www.linleygroup.com/newsletters/newsletter_detail.php?num=5117">http://www.linleygroup.com/newsletters/newsletter_detail.php?num=5117</a>
</li>

<li>Improving Energy Efficiency and Reducing Code Size with RISC-V Compressed<br />
<a href="http://www.eecs.berkeley.edu/~waterman/papers/ms-thesis.pdf">http://www.eecs.berkeley.edu/~waterman/papers/ms-thesis.pdf</a>
</li>

<li>An Introduction to Lock-Free Programming<br />
<a href="http://preshing.com/20120612/an-introduction-to-lock-free-programming/">http://preshing.com/20120612/an-introduction-to-lock-free-programming/</a>
</li>

<li>Sequential consistency<br />
<a href="https://en.wikipedia.org/wiki/Sequential_consistency">https://en.wikipedia.org/wiki/Sequential_consistency</a>
</li>

<li>Understanding Atomic Operations<br />
<a href="https://jfdube.wordpress.com/2011/11/30/understanding-atomic-operations/">https://jfdube.wordpress.com/2011/11/30/understanding-atomic-operations/</a>
</li>

<li>Load-link/store-conditional<br />
<a href="https://en.wikipedia.org/wiki/Load-link/store-conditional">https://en.wikipedia.org/wiki/Load-link/store-conditional</a>
</li>

<li>The RISC-V Compressed Instruction Set Manual (Pozor: verze 1.7)<br />
<a href="http://riscv.org/spec/riscv-compressed-spec-v1.7.pdf">http://riscv.org/spec/riscv-compressed-spec-v1.7.pdf</a>
</li>

<li>Carry bits, The Architect's Trap<br />
<a href="http://yarchive.net/comp/carry_bit.html">http://yarchive.net/comp/carry_bit.html</a>
</li>

<li>Microprocessor Design/ALU Flags<br />
<a href="https://en.wikibooks.org/wiki/Microprocessor_Design/ALU_Flags">https://en.wikibooks.org/wiki/Microprocessor_Design/ALU_Flags</a>
</li>

<li>Flags register in an out-of-order processor<br />
<a href="http://cs.stackexchange.com/questions/42095/flags-register-in-an-out-of-order-processor">http://cs.stackexchange.com/questions/42095/flags-register-in-an-out-of-order-processor</a>
</li>

<li>AMD Am29000<br />
<a href="https://en.wikipedia.org/wiki/AMD_Am29000">https://en.wikipedia.org/wiki/AMD_Am29000</a>
</li>

<li>Status register<br />
<a href="https://en.wikipedia.org/wiki/Status_register">https://en.wikipedia.org/wiki/Status_register</a>
</li>

<li>AMD Am29000 microprocessor family<br />
<a href="http://www.cpu-world.com/CPUs/29000/">http://www.cpu-world.com/CPUs/29000/</a>
</li>

<li>AMD 29k (Streamlined Instruction Processor) ID Guide<br />
<a href="http://www.cpushack.com/Am29k.html">http://www.cpushack.com/Am29k.html</a>
</li>

<li>AMD Am29000 (Wikipedia)<br />
<a href="http://en.wikipedia.org/wiki/AMD_Am29000">http://en.wikipedia.org/wiki/AMD_Am29000</a>
</li>

<li>AMD K5 ("K5" / "5k86")<br />
<a href="http://www.pcguide.com/ref/cpu/fam/g5K5-c.html">http://www.pcguide.com/ref/cpu/fam/g5K5-c.html</a>
</li>

<li>Comparing four 32-bit soft processor cores<br />
<a href="http://www.eetimes.com/author.asp?section_id=14&doc_id=1286116">http://www.eetimes.com/author.asp?section_id=14&doc_id=1286116</a>
</li>

<li>RISC-V Instruction Set<br />
<a href="http://riscv.org/download.html#spec_compressed_isa">http://riscv.org/download.html#spec_compressed_isa</a>
</li>

<li>RISC-V Spike (ISA Simulator)<br />
<a href="http://riscv.org/download.html#isa-sim">http://riscv.org/download.html#isa-sim</a>
</li>

<li>RISC-V (Wikipedia)<br />
<a href="https://en.wikipedia.org/wiki/RISC-V">https://en.wikipedia.org/wiki/RISC-V</a>
</li>

<li>David Patterson (Wikipedia)<br />
<a href="https://en.wikipedia.org/wiki/David_Patterson_(computer_scientist)">https://en.wikipedia.org/wiki/David_Patterson_(computer_scientist)</a>
</li>

<li>OpenRISC (oficiální­ stránky tohoto projektu)<br />
<a href="http://openrisc.io/">http://openrisc.io/</a>
</li>

<li>OpenRISC architecture<br />
<a href="http://openrisc.io/architecture.html">http://openrisc.io/architecture.html</a>
</li>

<li>Emulátor OpenRISC CPU v JavaScriptu<br />
<a href="http://s-macke.github.io/jor1k/demos/main.html">http://s-macke.github.io/jor1k/demos/main.html</a>
</li>

<li>OpenRISC (Wikipedia)<br />
<a href="https://en.wikipedia.org/wiki/OpenRISC">https://en.wikipedia.org/wiki/OpenRISC</a>
</li>

<li>OpenRISC - instrukce<br />
<a href="http://sourceware.org/cgen/gen-doc/openrisc-insn.html">http://sourceware.org/cgen/gen-doc/openrisc-insn.html</a>
</li>

<li>OpenRISC - slajdy z&nbsp;přednášky o tomto projektu<br />
<a href="https://iis.ee.ethz.ch/~gmichi/asocd/lecturenotes/Lecture6.pdf">https://iis.ee.ethz.ch/~gmichi/asocd/lecturenotes/Lecture6.pdf</a>
</li>

<li>Maska mikroprocesoru RISC 1<br />
<a href="http://www.cs.berkeley.edu/~pattrsn/Arch/RISC1.jpg">http://www.cs.berkeley.edu/~pattrsn/Arch/RISC1.jpg</a>
</li>

<li>Maska mikroprocesoru RISC 2<br />
<a href="http://www.cs.berkeley.edu/~pattrsn/Arch/RISC2.jpg">http://www.cs.berkeley.edu/~pattrsn/Arch/RISC2.jpg</a>
</li>

<li>C.E. Sequin and D.A.Patterson: Design and Implementation of RISC I<br />
<a href="http://www.eecs.berkeley.edu/Pubs/TechRpts/1982/CSD-82-106.pdf">http://www.eecs.berkeley.edu/Pubs/TechRpts/1982/CSD-82-106.pdf</a>
</li>

<li>Berkeley RISC<br />
<a href="http://en.wikipedia.org/wiki/Berkeley_RISC">http://en.wikipedia.org/wiki/Berkeley_RISC</a>
</li>

<li>Great moments in microprocessor history<br />
<a href="http://www.ibm.com/developerworks/library/pa-microhist.html">http://www.ibm.com/developerworks/library/pa-microhist.html</a>
</li>

<li>Microprogram-Based Processors<br />
<a href="http://research.microsoft.com/en-us/um/people/gbell/Computer_Structures_Principles_and_Examples/csp0167.htm">http://research.microsoft.com/en-us/um/people/gbell/Computer_Structures_Principles_and_Examples/csp0167.htm</a>
</li>

<li>Great Microprocessors of the Past and Present<br />
<a href="http://www.cpushack.com/CPU/cpu1.html">http://www.cpushack.com/CPU/cpu1.html</a>
</li>

<li>A Brief History of Microprogramming<br />
<a href="http://www.cs.clemson.edu/~mark/uprog.html">http://www.cs.clemson.edu/~mark/uprog.html</a>
</li>

<li>What is RISC?<br />
<a href="http://www-cs-faculty.stanford.edu/~eroberts/courses/soco/projects/2000-01/risc/whatis/">http://www-cs-faculty.stanford.edu/~eroberts/courses/soco/projects/2000-01/risc/whatis/</a>
</li>

<li>RISC vs. CISC<br />
<a href="http://www-cs-faculty.stanford.edu/~eroberts/courses/soco/projects/2000-01/risc/risccisc/">http://www-cs-faculty.stanford.edu/~eroberts/courses/soco/projects/2000-01/risc/risccisc/</a>
</li>

<li>RISC and CISC definitions:<br />
<a href="http://www.cpushack.com/CPU/cpuAppendA.html">http://www.cpushack.com/CPU/cpuAppendA.html</a>
</li>

<li>FPGA<br />
<a href="https://cs.wikipedia.org/wiki/Programovateln%C3%A9_hradlov%C3%A9_pole">https://cs.wikipedia.org/wiki/Programovateln%C3%A9_hradlov%C3%A9_pole</a>
</li>

<li>The Evolution of RISC<br />
<a href="http://www.ibm.com/developerworks/library/pa-microhist.html#sidebar1">http://www.ibm.com/developerworks/library/pa-microhist.html#sidebar1</a>
</li>

<li>SPARC Processor Family Photo<br />
<a href="http://thenetworkisthecomputer.com/site/?p=243">http://thenetworkisthecomputer.com/site/?p=243</a>
</li>

<li>SPARC: Decades of Continuous Technical Innovation<br />
<a href="http://blogs.oracle.com/ontherecord/entry/sparc_decades_of_continuous_technical">http://blogs.oracle.com/ontherecord/entry/sparc_decades_of_continuous_technical</a>
</li>

<li>The SPARC processors<br />
<a href="http://www.top500.org/2007_overview_recent_supercomputers/sparc_processors">http://www.top500.org/2007_overview_recent_supercomputers/sparc_processors</a>
</li>

<li>Reduced instruction set computing (Wikipedia)<br />
<a href="http://en.wikipedia.org/wiki/Reduced_instruction_set_computer">http://en.wikipedia.org/wiki/Reduced_instruction_set_computer</a>
</li>

<li>MIPS architecture (Wikipedia)<br />
<a href="http://en.wikipedia.org/wiki/MIPS_architecture">http://en.wikipedia.org/wiki/MIPS_architecture</a>
</li>

<li>Very long instruction word (Wikipedia)<br />
<a href="http://en.wikipedia.org/wiki/Very_long_instruction_word">http://en.wikipedia.org/wiki/Very_long_instruction_word</a>
</li>

<li>Classic RISC pipeline (Wikipedia)<br />
<a href="http://en.wikipedia.org/wiki/Classic_RISC_pipeline">http://en.wikipedia.org/wiki/Classic_RISC_pipeline</a>
</li>

<li>R2000 Microprocessor (Wikipedia)<br />
<a href="http://en.wikipedia.org/wiki/R2000_(microprocessor)">http://en.wikipedia.org/wiki/R2000_(microprocessor)</a>
</li>

<li>R3000 Microprocessor (Wikipedia)<br />
<a href="http://en.wikipedia.org/wiki/R3000">http://en.wikipedia.org/wiki/R3000</a>
</li>

<li>R4400 Microprocessor (Wikipedia)<br />
<a href="http://en.wikipedia.org/wiki/R4400">http://en.wikipedia.org/wiki/R4400</a>
</li>

<li>R8000 Microprocessor (Wikipedia)<br />
<a href="http://en.wikipedia.org/wiki/R8000">http://en.wikipedia.org/wiki/R8000</a>
</li>

<li>R10000 Microprocessor (Wikipedia)<br />
<a href="http://en.wikipedia.org/wiki/R10000">http://en.wikipedia.org/wiki/R10000</a>
</li>

<li>SPARC (Wikipedia)<br />
<a href="http://en.wikipedia.org/wiki/Sparc">http://en.wikipedia.org/wiki/Sparc</a>
</li>

<li>CPU design (Wikipedia)<br />
<a href="http://en.wikipedia.org/wiki/CPU_design">http://en.wikipedia.org/wiki/CPU_design</a>
</li>

<li>Control unit (Wikipedia)<br />
<a href="http://en.wikipedia.org/wiki/Control_unit">http://en.wikipedia.org/wiki/Control_unit</a>
</li>

</ol>



<p></p><p></p>
<p><small>Autor: <a href="http://www.fit.vutbr.cz/~tisnovpa">Pavel Tišnovský</a> &nbsp; 2016</small></p>
</body>
</html>

