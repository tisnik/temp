<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
        "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html>
<head>
<title>RISCová architektura PowerPC: matematický koprocesor</title>
<meta name="Author" content="Pavel Tisnovsky" />
<meta name="Generator" content="vim" />
<meta http-equiv="content-type" content="text/html; charset=utf-8" />
<style type="text/css">
         body {color:#000000; background:#ffffff;}
         h1  {font-family: arial, helvetica, sans-serif; color:#ffffff; background-color:#c00000; text-align:center; padding-left:1em}
         h2  {font-family: arial, helvetica, sans-serif; color:#ffffff; background-color:#0000c0; padding-left:1em; text-align:left}
         h3  {font-family: arial, helvetica, sans-serif; color:#000000; background-color:#c0c0c0; padding-left:1em; text-align:left}
         h4  {font-family: arial, helvetica, sans-serif; color:#000000; background-color:#e0e0e0; padding-left:1em; text-align:left}
         a   {font-family: arial, helvetica, sans-serif;}
         li  {font-family: arial, helvetica, sans-serif; color:#000000; text-align:justify; width:450px;}
         ol  {font-family: arial, helvetica, sans-serif; color:#000000; text-align:justify; width:450px;}
         ul  {font-family: arial, helvetica, sans-serif; color:#000000; text-align:justify; width:450px;}
         p   {font-family: arial, helvetica, sans-serif; color:#000000; text-align:justify;}
         pre {background:#e0e0e0}
</style>
</head>

<body>

<h1>RISCová architektura PowerPC: matematický koprocesor</h1>

<h3>Pavel Tišnovský</h3>

<p></p>

<h1>Úvodník</h1>

<p>Třetí a současně i poslední část článku o mikroprocesorech s architekturou PowerPC je věnována popisu instrukcí používaných při práci s numerickými hodnotami s plovoucí řádovou čárkou (floating point).</p>



<h2>Obsah</h2>

<p><a href="#k01">1. RISCová architektura PowerPC: matematický koprocesor</a></p>
<p><a href="#k02">2. Podporované formáty numerických hodnot s&nbsp;plovoucí řádovou čárkou</a></p>
<p><a href="#k03">3. Pracovní registry používané matematickým koprocesorem</a></p>
<p><a href="#k04">4. Zaokrouhlovací režimy vybírané při práci s&nbsp;plovoucí řádovou čárkou</a></p>
<p><a href="#k05">5. Výjimky, které mohou při výpočtech nastat</a></p>
<p><a href="#k06">6. Instrukce typu LOAD a STORE s&nbsp;FP registry</a></p>
<p><a href="#k07">7. Základní aritmetické instrukce s&nbsp;FP registry</a></p>
<p><a href="#k08">8. Přesuny dat mezi pracovními registry s&nbsp;provedením vybrané operace</a></p>
<p><a href="#k09">9. Instrukce typu Multiply-Add a Multiply-Subtract</a></p>
<p><a href="#k10">10. Porovnání operandů a nastavení příznakových bitů</a></p>
<p><a href="#k11">11. Konverze dat</a></p>
<p><a href="#k12">12. Odkazy na Internetu</a></p>



<p><a name="k01"></a></p>
<h2 id="k01">1. RISCová architektura PowerPC: matematický koprocesor</h2>

<p>V&nbsp;dnešní části článku o mikroprocesorech s&nbsp;architekturou PowerPC
si popíšeme základní vlastnosti třetího (a současně i posledního) modulu CPU,
který je určen pro provádění operací s&nbsp;numerickými hodnotami
s&nbsp;plovoucí řádovou čárkou (první modul se staral o provádění skoků a modul
druhý o operace s&nbsp;celočíselnými hodnotami). Mikroprocesory
s&nbsp;architekturou PowerPC podporují práci s&nbsp;formáty <i>single</i> i
<i>double</i> definované ve známé normě IEEE 754, která je mimochodem
v&nbsp;platnosti již od roku 1985 a teprve relativně nedávno se dočkala svého
doplnění a upřesnění. V&nbsp;normě IEEE 754 jsou specifikovány nejenom vlastní
formáty uložení numerických hodnot v&nbsp;systému pohyblivé/plovoucí řádové
čárky (FP formátu), ale i pravidla pro implementaci aritmetických operací
s&nbsp;těmito hodnotami, včetně některých konverzí a zaokrouhlování. Konkrétně
je v&nbsp;této normě popsáno:</p>

<ol>
<li>Základní (<i>basic</i>) a rozšířený (<i>extended</i>) formát uložení numerických hodnot.</li>
<li>Způsob provádění základních matematických operací:
    <ul>
    <li>součet</li>
    <li>rozdíl</li>
    <li>součin</li>
    <li>podíl</li>
    <li>zbytek po dělení</li>
    <li>druhá odmocnina</li>
    <li>porovnání</li>
    </ul></li>
<li>Pravidla pro konverze prováděné mezi celočíselnými formáty (<i>integer</i>) a formáty s&nbsp;plovoucí řádovou čárkou.</li>
<li>Způsob konverze mezi různými formáty s&nbsp;plovoucí řádovou čárkou (<i>single</i> &rarr; <i>double</i> atd.).</li>
<li>Způsob konverze základního formátu s&nbsp;plovoucí řádovou čárkou na řetězec číslic (včetně nekonečen a nečíselných hodnot).</li>
<li>Práce s&nbsp;hodnotami <i>NaN</i> (<i>Not a Number</i>) a výjimkami. Viz též další kapitoly, kde se těmito vlastnostmi budeme zabývat z&nbsp;pohledu procesorů PowerPC.</li>
</ol>



<p><a name="k02"></a></p>
<h2 id="k02">2. Podporované formáty numerických hodnot s&nbsp;plovoucí řádovou čárkou</h2>

<p>Vybraná podmnožina racionálních čísel může být vyjádřena vztahem:</p>

<p><strong>X<sub>FP</sub>=(-1)<sup>s</sup>&nbsp;&times;&nbsp;2<sup>exp-bias</sup>&nbsp;&times;&nbsp;m</strong></p>

<p>kde:</p>

<ul>

<li><strong>X<sub>FP</sub></strong> značí reprezentovanou numerickou hodnotu
z&nbsp;podmnožiny racionálních čísel (ta je zase podmnožinou čísel reálných).
Díky vyhrazeným (speciálním) hodnotám je možné rozlišit kladnou a zápornou nulu
a dokonce i kladné a záporné nekonečno. Také se může reprezentovat nečíselná
hodnota: <i>NaN &ndash; (Not a Number)</i>, která je výsledkem některých
matematicky nedefinovaných operací, například 0/0 nebo 0<sup>0</sup> (opět viz
navazující kapitoly).</li>

<li><strong>2</strong> je <i>báze</i>, někdy také nazývaná <i>radix</i>, u IEEE
754 je to vždy dvojka, protože výpočty s&nbsp;bází dvě jsou pro číslicové
obvody nejjednodušší. V&nbsp;minulosti se používaly i jiné báze, například 8,
16 nebo i 10.</li>

<li><strong>exp</strong> je vždy kladná hodnota exponentu posunutého o hodnotu
<strong>bias</strong></li>

<li><strong>bias</strong> je hodnota, díky které je uložený exponent vždy
kladný. Tato hodnota se většinou volí dle vztahu:
<i>bias=2<sup>eb-1</sup>-1</i>, kde <i>eb</i> je počet bitů vyhrazených pro
exponent. Pro specifické účely je však možné zvolit i jinou hodnotu.</li>

<li><strong>m</strong> je mantisa, která je u formátů IEEE 754 vždy kladná</li>

<li><strong>s</strong> je znaménkový bit nabývající hodnoty 0 nebo 1. Pokud je
tento bit nulový, je reprezentovaná hodnota <strong>X<sub>FP</sub></strong>
kladná, v&nbsp;opačném případě se jedná o zápornou hodnotu. Vzhledem
k&nbsp;tomu, že je jeden bit vyhrazen na uložení znaménka, je možné rozlišit
kladnou a zápornou nulu.</li>

</ul>

<p>Podle bitové šířky čísel <strong>exp</strong>, <strong>bias</strong> a
<strong>m</strong> se rozlišují základní a rozšířené formáty FP čísel; norma
IEEE 754 přitom explicitně zmiňuje dva základní formáty: jednoduchá přesnost
(<i>single</i>, též jen <i>float</i>) a dvojitá přesnost (<i>double</i>).</p>

<p>Formát <i>single</i> používá pro uložení numerických hodnot 32 bitová slova,
přičemž oněch 32 bitů je rozděleno do třech částí. V&nbsp;první části
(představované nejvyšším bitem) je uloženo znaménko, následuje osm bitů pro
uložení posunutého exponentu a za nimi je zbývajících 23 bitů, které slouží pro
uložení mantisy. Celé třiceti dvoubitové slovo s&nbsp;FP hodnotou tedy vypadá
následovně:</p></p>

<table>
<tr><th>bit</th><td>31</td><td>30 &nbsp; 29 ... 24 &nbsp; 23</td><td>22 &nbsp; 21 ... 3 &nbsp; 2 &nbsp; 1 &nbsp; 0</td></tr>
<tr><th>význam</th><td>s</td><td>exponent (8 bitů)</td><td>mantisa (23 bitů)</td></tr>
</table>

<p>FP formát dvojité přesnosti (<strong>double</strong>), jež je definovaný
taktéž normou IEEE 754, se v&nbsp;mnohém podobá formátu s&nbsp;jednoduchou
přesností (<strong>single</strong>), pouze se zdvojnásobil celkový počet bitů,
ve kterých je hodnota uložena, tj.&nbsp;místo 32 bitů se používá 64 bitů. Právě
to je příčinou, proč se tento formát nazývá double, ve skutečnosti je přesnost
více než dvojnásobná. 64 bitů alokovaných pro FP hodnotu je v&nbsp;tomto
případě rozděleno následujícím způsobem:</p>

<ol>
<li>1 bit pro znaménko</li>
<li>11 bitů pro exponent</li>
<li>52 bitů pro mantisu</li>
</ol>

<p>Bitově vypadá rozdělení následovně:</p>

<table>
<tr><th>bit</th><td>63</td><td>62 ... 52</td><td>51 ... 0</td></tr>
<tr><th>význam</th><td>s</td><td>exponent (11 bitů)</td><td>mantisa 52( bitů)</td></tr>
</table>

<p>Povšimněte si, že díky tomu, že nejvyšší bit přímo udává znaménko uložené
hodnoty, je provedení operace typu -x, abs(x) či -abs(x) velmi snadné. Právě
tyto operace jsou na architektuře PowerPC dostupné &bdquo;zadarmo&ldquo; při
přenosech dat. Podrobnosti si řekneme <a href="#k08">v&nbsp;osmé
kapitole</a>.</p>



<p><a name="k03"></a></p>
<h2 id="k03">3. Pracovní registry používané matematickým koprocesorem</h2>

<p>Podobně, jako je tomu u mnoha (přesněji řečeno u převážné většiny) dalších
RISCových architektur, například u architektury <a
href="http://www.root.cz/clanky/procesory-risc-v-pracovnich-stanicich-a-serverech-architektura-sparc-v8-a-v9/#k06">SPARC</a>,
<a
href="http://www.root.cz/clanky/procesory-risc-v-pracovnich-stanicich-a-serverech-architektura-pa-risc/#k08">PA-RISC</a>,
<a
href="http://www.root.cz/clanky/rozsireni-instrukcni-sady-procesorovych-jader-s-otevrenou-architekturou-risc-v/#k08">RISC-V</a>
a samozřejmě i <a
href="http://www.root.cz/clanky/prace-s-hodnotami-s-plovouci-radovou-carkou-na-mikroprocesorech-arm/">ARM</a>,
se i v&nbsp;PowerPC všechny aritmetické operace s&nbsp;numerickými hodnotami
s&nbsp;plovoucí řádovou čárkou provádí nad obsahem pracovních registrů a nikoli
(například) nad položkami uloženými v&nbsp;zásobníku operandů, jak se to
provádělo například u originálního matematického koprocesoru Intel 8087. Pokud
se tedy má aplikovat jakákoli FP operace, je nejdříve nutné načíst příslušné
operandy do vybraných pracovních registrů, aplikovat požadované operace a
popř.&nbsp;provést zpětný zápis do operační paměti.</p>

<p>Pro FP operace se používá sada třiceti dvou pracovních registrů nazvaných
<strong>FPR0</strong> až <strong>FPR31</strong>, přičemž každý z&nbsp;těchto
registrů má šířku 64 bitů a umožňuje tedy nativně provádět veškeré operace
s&nbsp;dvojnásobnou přesností (<i>double</i>). Interně se většina operací (až
na vybrané operace aritmetické) provádí právě s&nbsp;hodnotami typu
<i>double</i>, přičemž některé instrukce typu LOAD a STORE dokážou při načítání
či naopak ukládání numerických dat automaticky provést konverzi
<i>single&rarr;double</i> či <i>double&rarr;single</i>. Vzhledem k&nbsp;počtu
pracovních registrů je v&nbsp;instrukčních slovech pro uložení indexu registru
popř.&nbsp;registrů, s&nbsp;nimiž se má provést nějaká operace, rezervováno pět
bitů.</p>



<p><a name="k04"></a></p>
<h2 id="k04">4. Zaokrouhlovací režimy vybírané při práci s&nbsp;plovoucí řádovou čárkou</h2>

<p>U mnoha aritmetických operací je nutné provést zaokrouhlení výsledku před
jeho uložením zpět do vybraného pracovního registru. Vzhledem k&nbsp;tomu, že
zaokrouhlování může poměrně zásadním způsobem ovlivnit výsledky některých
výpočtů (iterativní součet mnoha členů nějaké řady atd.), lze na architektuře
PowerPC zvolit, jakým způsobem se má zaokrouhlování provádět. Samozřejmě se
nejedná o zaokrouhlování na celá čísla, ale &ndash; poněkud zjednodušeně řečeno
&ndash; o volbu hodnoty posledního bitu mantisy. Ve stavovém a řídicím registru
<strong>FPSCR</strong> je zaokrouhlovací režim určen dvěma bity, jejichž
kombinací lze vybrat tyto režimy:</p>

<table>
<tr><th>#</th><th>Bitová kombinace</th><th>Význam</th></tr>
<tr><td>1</td><td>00</td><td>zaokrouhlení k&nbsp;nejbližší reprezentovatelné hodnotě</td></tr>
<tr><td>2</td><td>01</td><td>zaokrouhlení směrem k&nbsp;nule</td></tr>
<tr><td>3</td><td>10</td><td>zaokrouhlení směrem k&nbsp;+&infin;</td></tr>
<tr><td>4</td><td>11</td><td>zaokrouhlení směrem k&nbsp;-&infin;</td></tr>
</table>

<p>V&nbsp;případě prvního režimu může nastat situace, kdy jsou obě
&bdquo;nejbližší&ldquo; reprezentovatelné hodnoty od výsledku vzdáleny stejně.
Potom se vybere ta hodnota, jejíž nejnižší bit je nulový.</p>



<p><a name="k05"></a></p>
<h2 id="k05">5. Výjimky, které mohou při výpočtech nastat</h2>

<p>Při výpočtech s&nbsp;FP hodnotami může nastat hned několik výjimek, které se
na procesorech s&nbsp;architekturou PowerPC budou korektně detekovat a nastaví
se příslušné bity v&nbsp;řídicím a příznakovém registru <strong>FPSCR</strong>.
Jedná se o následující typy výjimek:</p>

<table>
<tr><th>#</th><th>Operace, která vyvolá výjimku</th></tr>
<tr><td>1</td><td>Operace s&nbsp;hodnotou SNaN (Signalling Nan), která vznikla v&nbsp;důsledku nějaké předchozí nepovolené operace</td></tr>
<tr><td>2</td><td>Operace &infin;-&infin; (rozdíl dvou nekonečen)</td></tr>
<tr><td>3</td><td>Operace &infin;/&infin; (podíl dvou nekonečen)</td></tr>
<tr><td>4</td><td>Operace 0/0 (podíl dvou nul)</td></tr>
<tr><td>5</td><td>Operace &infin;&times;0</td></tr>
<tr><td>6</td><td>Porovnání libovolné hodnoty s&nbsp;NaN</td></tr>
<tr><td>7</td><td>Druhá odmocnina ze záporné hodnoty</td></tr>
<tr><td>8</td><td>Konverze příliš velké hodnoty (vznikne NaN nebo nekonečno)</td></tr>
</table>

<p>Poznámka: kladné i záporné nekonečno je výsledkem mnoha přesně definovaných
operací (například dělení libovolné nenulové hodnoty nulou) a kromě zmíněných
speciálních případů se nekonečno může v&nbsp;aritmetických operacích bez
větších problémů použít. To znamená, že následující operace lze aplikovat
bez vzniku výjimky:</p>

<table>
<tr><th>#</th><th>Operace, která nevyvolá výjimku</th></tr>
<tr><td>1</td><td>Operace &infin;+&infin; (součet dvou nekonečen)</td></tr>
<tr><td>2</td><td>Operace &infin;*&infin; (součin dvou nekonečen)</td></tr>
<tr><td>3</td><td>Operace x/0 (x!=0)</td></tr>
<tr><td>4</td><td>Operace &infin;&times;x (x!=0)</td></tr>
</table>

<p>Poznámka: pokud x&gt;0, pak je výsledkem operace x/0 hodnota &infin;, pokud
x&lt;0, pak je výsledkem podle očekávání hodnota -&infin;. Totéž platí i pro
operaci &infin;&times;x.</p>



<p><a name="k06"></a></p>
<h2 id="k06">6. Instrukce typu LOAD a STORE s&nbsp;FP registry</h2>

<p>Instrukce, které slouží pro přenos numerických hodnot reprezentovaných
v&nbsp;systému plovoucí řádové čárky mezi registry a operační pamětí, lze
rozdělit podle směru přenosu (LOAD a STORE), typu operandů uložených
v&nbsp;operační paměti (<i>single</i>, <i>double</i>), adresového režimu
(Rx+offset, Rx+Ry) a taktéž podle toho, zda se registr určený pro adresování
naplní novou hodnotou či nikoli (autoinkrementace, autodekrementace). Nejprve
si uveďme tabulku s&nbsp;instrukcemi určenými pro načtení hodnot
z&nbsp;operační paměti:</p>

<table>
<tr><th>#</th><th>Instrukce</th><th>Význam</th></tr>
<tr><td>1</td><td><strong>lfs</strong>  </td><td>načtení a konverze hodnoty typu <i>single</i> z adresy Rx+offset</td></tr>
<tr><td>2</td><td><strong>lfsx</strong> </td><td>načtení a konverze hodnoty typu <i>single</i> z adresy Rx+Ry</td></tr>
<tr><td>3</td><td><strong>lfsu</strong> </td><td>jako instrukce <strong>lfs</strong>, ovšem dojde k&nbsp;úpravě registru Rx (Rx=Rx+D)</td></tr>
<tr><td>4</td><td><strong>lfsux</strong></td><td>jako instrukce <strong>lfsx</strong>, ovšem dojde k&nbsp;úpravě registru Rx (Rx=Rx+Ry)</td></tr>
<tr><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td></tr>
<tr><td>5</td><td><strong>lfd</strong>  </td><td>načtení hodnoty typu <i>double</i> z adresy Rx+offset</td></tr>
<tr><td>6</td><td><strong>lfdx</strong> </td><td>načtení hodnoty typu <i>double</i> z adresy Rx+Ry</td></tr>
<tr><td>7</td><td><strong>lfdu</strong> </td><td>jako instrukce <strong>lfd</strong>, ovšem dojde k&nbsp;úpravě registru Rx (Rx=Rx+D)</td></tr>
<tr><td>8</td><td><strong>lfdux</strong></td><td>jako instrukce <strong>lfdx</strong>, ovšem dojde k&nbsp;úpravě registru Rx (Rx=Rx+Ry)</td></tr>
</table>

<p>Offset je šestnáctibitová konstanta uložená přímo v&nbsp;instrukčním slovu a
lze ji použít pro autoinkrementaci či autodekrementaci registru Rx, například
při průchodu polem (D=4 nebo 8).</p>

<p>Následují instrukce určené pro uložení operandů do operační paměti:</p>

<table>
<tr><th>#</th><th>Instrukce</th><th>Význam</th></tr>
<tr><td>1</td><td><strong>stfs</strong>  </td><td>konverze na <i>single</i> a uložení hodnoty na adresu Rx+offset</td></tr>
<tr><td>2</td><td><strong>stfsx</strong> </td><td>konverze na <i>single</i> a uložení hodnoty na adresu Rx+Ry</td></tr>
<tr><td>3</td><td><strong>stfsu</strong> </td><td>jako instrukce <strong>stfs</strong>, ovšem dojde k&nbsp;úpravě registru Rx (Rx=Rx+D)</td></tr>
<tr><td>4</td><td><strong>stfsux</strong></td><td>jako instrukce <strong>stfsx</strong>, ovšem dojde k&nbsp;úpravě registru Rx (Rx=Rx+Ry)</td></tr>
<tr><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td></tr>
<tr><td>5</td><td><strong>stfd</strong>  </td><td>odpovídá <strong>stfs</strong>, ovšem pro typ <i>double</i></td></tr>
<tr><td>6</td><td><strong>stfdx</strong> </td><td>odpovídá <strong>stfsx</strong>, ovšem pro typ <i>double</i></td></tr>
<tr><td>7</td><td><strong>stfdu</strong> </td><td>odpovídá <strong>stfsu</strong>, ovšem pro typ <i>double</i></td></tr>
<tr><td>8</td><td><strong>stfdux</strong></td><td>odpovídá <strong>stfsux</strong>, ovšem pro typ <i>double</i></td></tr>
</table>

<p>I u těchto instrukcí můžeme vidět použití offsetu společně s&nbsp;operací
&bdquo;update&ldquo; (instrukce, které obsahují znak <strong>u</strong> ve svém
názvu.</p>



<p><a name="k07"></a></p>
<h2 id="k07">7. Základní aritmetické instrukce s&nbsp;FP registry</h2>

<p>Nabídka základních aritmetických operací pravděpodobně nebude příliš
překvapivá, protože na architektuře PowerPC nalezneme všechny čtyři základní
operace: součet, rozdíl, součet i podíl. Povšimněte si, že je možné si vybrat,
zda bude výsledek reprezentován typem <i>single</i> či <i>double</i> (a to i
když pracovní registry mají konstantní šířku 64 bitů). Všechny základní
aritmetické operace používají tři pracovní registry &ndash; dva registry
zdrojové a jeden registr cílový:</p>

<table>
<tr><th>#</th><th>Instrukce</th><th>Význam</th></tr>
<tr><td>1</td><td><strong>fadd</strong></td><td>provedení operace FPRt=FPRa+FPRb</td></tr>
<tr><td>2</td><td><strong>fadds</strong></td><td>provedení operace FPRt=FPRa+FPRb (<i>single</i>)</td></tr>
<tr><td>3</td><td><strong>fsub</strong></td><td>provedení operace FPRt=FPRa-FPRb</td></tr>
<tr><td>4</td><td><strong>fsubs</strong></td><td>provedení operace FPRt=FPRa-FPRb (<i>single</i>)</td></tr>
<tr><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td></tr>
<tr><td>5</td><td><strong>fmul</strong></td><td>provedení operace FPRt=FPRa*FPRb</td></tr>
<tr><td>6</td><td><strong>fmuls</strong></td><td>provedení operace FPRt=FPRa*FPRb (<i>single</i>)</td></tr>
<tr><td>7</td><td><strong>fdiv</strong></td><td>provedení operace FPRt=FPRa/FPRb</td></tr>
<tr><td>8</td><td><strong>fdivs</strong></td><td>provedení operace FPRt=FPRa/FPRb (<i>single</i>)</td></tr>
</table>

<p>Následuje seznam volitelných instrukcí, které můžeme (ale taktéž nemusíme)
na procesorech PowerPC nalézt. Zajímavé jsou instrukce, které rychle odhadnou
výsledek operace se zaručenou minimální přesností:</p>

<table>
<tr><th>#</th><th>Instrukce</th><th>Význam</th></tr>
<tr><td>1</td><td><strong>fsqrt</strong></td><td>provedení operace FPRt=FPRa+FPRb</td></tr>
<tr><td>2</td><td><strong>fsqrts</strong></td><td>provedení operace FPRt=FPRa+FPRb (<i>single</i>)</td></tr>
<tr><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td></tr>
<tr><td>3</td><td><strong>fre</strong></td><td>odhad operace FPRt=1/FPRa se známou přesností</td></tr>
<tr><td>4</td><td><strong>fres</strong></td><td>odhad operace FPRt=1/FPRa (<i>single</i>)</td></tr>
<tr><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td></tr>
<tr><td>5</td><td><strong>frsqrte</strong></td><td>odhad operace FPRt=FPRa+FPRb</td></tr>
<tr><td>6</td><td><strong>frsqrtes</strong></td><td>odhad operace FPRt=FPRa+FPRb (<i>single</i>)</td></tr>
</table>



<p><a name="k08"></a></p>
<h2 id="k08">8. Přesuny dat mezi pracovními registry s&nbsp;provedením vybrané operace</h2>

<p>Zajímavé jsou instrukce, které jsou určené pro přesuny dat mezi pracovními
registry <strong>FPRx</strong>. V&nbsp;instrukčních slovech těchto instrukcí je
uložen index zdrojového registru a index registru cílového. Ovšem kromě toho je
v&nbsp;případě potřeby možné při přesunu dat na hodnotu aplikovat jednu ze tří
jednoduchých a tudíž i rychlých operací:</p>

<table>
<tr><th>#</th><th>Instrukce</th><th>Význam</th></tr>
<tr><td>1</td><td><strong>fmr</strong>  </td><td>provedení operace FPRt=FPRx</td></tr>
<tr><td>2</td><td><strong>fneg</strong> </td><td>provedení operace FPRt=-FPRx</td></tr>
<tr><td>3</td><td><strong>fabs</strong> </td><td>provedení operace FPRt=abs(FPRx)</td></tr>
<tr><td>4</td><td><strong>fnabs</strong></td><td>provedení operace FPRt=-abs(FPRx)</td></tr>
</table>

<p>Povšimněte si, že všechny prováděné operace pouze manipulují se znaménkem (nejvyšším bitem):</p>

<table>
<tr><th>#</th><th>Instrukce</th><th>Bit <strong>s</strong></th></tr>
<tr><td>1</td><td><strong>fmr</strong>  </td><td>kopie</td></tr>
<tr><td>2</td><td><strong>fneg</strong> </td><td>negace</td></tr>
<tr><td>3</td><td><strong>fabs</strong> </td><td>vynulování</td></tr>
<tr><td>4</td><td><strong>fnabs</strong></td><td>nastavení (na 1)</td></tr>
</table>



<p><a name="k09"></a></p>
<h2 id="k09">9. Instrukce typu Multiply-Add a Multiply-Subtract</h2>

<p>Na mikroprocesorech s&nbsp;architekturou PowerPC nalezneme i v&nbsp;mnoha
případech velmi užitečné instrukce, v&nbsp;nichž se provádí operace násobení
společně s&nbsp;operací součtu či rozdílu. Tyto instrukce je možné využít
v&nbsp;několika aplikačních oblastech, například při implementaci různých
číslicových filtrů atd. Zajímavé je, že všechny instrukce tohoto typu mají
v&nbsp;instrukčním slově zakódovány indexy hned čtyř pracovních registrů
&ndash; tří registrů zdrojových a jednoho registru cílového. Bližší informace
jsou uvedeny v&nbsp;následující tabulce:</p>

<table>
<tr><th>#</th><th>Instrukce</th><th>Prováděný výpočet</th></tr>
<tr><td>1</td><td><strong>fmadd</strong></td><td>FPRt = FPRa&times;FPRc + FPRb</td></tr>
<tr><td>2</td><td><strong>fmadds</strong></td><td>dtto pro <i>single</i></td></tr>
<tr><td>3</td><td><strong>fmsub</strong></td><td>FPRt = FPRa&times;FPRc - FPRb</td></tr>
<tr><td>4</td><td><strong>fmsubs</strong></td><td>dtto pro <i>single</i></td></tr>
<tr><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td></tr>
<tr><td>1</td><td><strong>fnmadd</strong></td><td>FPRt = -(FPRa&times;FPRc + FPRb)</td></tr>
<tr><td>2</td><td><strong>fnmadds</strong></td><td>dtto pro <i>single</i></td></tr>
<tr><td>3</td><td><strong>fnmsub</strong></td><td>FPRt = -(FPRa&times;FPRc - FPRb)</td></tr>
<tr><td>4</td><td><strong>fnmsubs</strong></td><td>dtto pro <i>single</i></td></tr>
</table>

<p>Číslicový filtr lze tedy realizovat například kombinací instrukcí
<strong>lfdu</strong>, <strong>fmadd</strong> a <strong>stfdu</strong>.</p>



<p><a name="k10"></a></p>
<h2 id="k10">10. Porovnání operandů a nastavení příznakových bitů</h2>

<p>V&nbsp;instrukční sadě nalezneme i dvojici instrukcí určených pro porovnání
obsahu dvou pracovních registrů a nastavení příslušných příznaků
v&nbsp;příznakovém registru FPCC. Jedná se o následující dvě instrukce:</p>

<table>
<tr><th>#</th><th>Instrukce</th><th>Význam</th></tr>
<tr><td>1</td><td><strong>fcmpu</strong></td><td>porovnání obsahu dvou pracovních registrů</td></tr>
<tr><td>2</td><td><strong>fcmpo</strong></td><td>porovnání obsahu dvou pracovních registrů, odlišné zpracování NaN</td></tr>
</table>

<p>Nastavované příznaky (porovnání dvou hodnot odlišných od NaN):</p>

<table>
<tr><th>Bit v FPCC.CR</th><th>Jméno</th><th>Význam</th></tr>
<tr><td>0</td><td>FL</td><td>FPRa &lt; FPRb</td></tr>
<tr><td>1</td><td>FG</td><td>FPRa &gt; FPRb</td></tr>
<tr><td>2</td><td>FE</td><td>FPRa == FPRb</td></tr>
<tr><td>3</td><td>FU</td><td>nelze porovnat (unordered)</td></tr>
</table>

<p>Poznámka 1: za všech okolností je vždy nastaven pouze jeden z&nbsp;těchto
příznaků, ostatní tři příznaky jsou vynulovány.</p>

<p>Poznámka 2: bit FU se nastaví ve chvíli, kdy je alespoň jedna
z&nbsp;porovnávaných hodnot NaN. To platí i ve chvíli, kdy se porovnávají dvě
hodnoty NaN (jinými slovy platí NaN != NaN).</p>



<p><a name="k11"></a></p>
<h2 id="k11">11. Konverze dat</h2>

<p>Poslední skupinou instrukcí jsou instrukce sloužící pro konverzi dat. Těchto
instrukcí existuje celá řada a jsou vypsány v&nbsp;následující tabulce. Každá
instrukce obsahuje specifikaci zdrojového a cílového registru (konverzi tedy
není nutné provádět &bdquo;in situ&ldquo;):</p>

<table>
<tr><th>#</th><th>Instrukce</th><th>Význam</th></tr>
<tr><td>1</td><td><strong>frsp</strong></td><td>konverze <i>double&rarr;single</i></td></tr>
<tr><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td></tr>
<tr><td>2</td><td><strong>fctid</strong></td><td>konverze <i>double&rarr;integer</i> (64bit integer)</td></tr>
<tr><td>3</td><td><strong>fctidz</strong></td><td>dtto, ale vždy se provede zaokrouhlení směrem k&nbsp;nule</td></tr>
<tr><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td></tr>
<tr><td>4</td><td><strong>fctiw</strong></td><td>konverze <i>double&rarr;integer</i> (32bit integer)</td></tr>
<tr><td>5</td><td><strong>fctidz</strong></td><td>dtto, ale vždy se provede zaokrouhlení směrem k&nbsp;nule</td></tr>
<tr><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td></tr>
<tr><td>6</td><td><strong>fcfid</strong></td><td>konverze <i>integer&rarr;double</i> (64bit integer)</td></tr>
</table>

<p>U instrukcí <strong>fctid</strong> a <strong>fctiw</strong> je použit
zaokrouhlovací režim nastavený globálně.</p>



<p><a name="k12"></a></p>
<h2 id="k12">12. Odkazy na Internetu</h2>

<ol>

<li>Procesory RISC v pracovních stanicích a serverech - architektura SPARC V8 a<br />
<a href="http://www.root.cz/clanky/procesory-risc-v-pracovnich-stanicich-a-serverech-architektura-sparc-v8-a-v9/">http://www.root.cz/clanky/procesory-risc-v-pracovnich-stanicich-a-serverech-architektura-sparc-v8-a-v9/</a>
</li>

<li>Procesory RISC v pracovních stanicích a serverech - architektura PA-RISC<br />
<a href="http://www.root.cz/clanky/procesory-risc-v-pracovnich-stanicich-a-serverech-architektura-pa-risc/">http://www.root.cz/clanky/procesory-risc-v-pracovnich-stanicich-a-serverech-architektura-pa-risc/</a>
</li>

<li>Rozšíření instrukční sady procesorových jader s otevřenou architekturou RISC-V<br />
<a href="http://www.root.cz/clanky/rozsireni-instrukcni-sady-procesorovych-jader-s-otevrenou-architekturou-risc-v/">http://www.root.cz/clanky/rozsireni-instrukcni-sady-procesorovych-jader-s-otevrenou-architekturou-risc-v/</a>
</li>

<li>Práce s hodnotami s plovoucí řádovou čárkou na mikroprocesorech ARM<br />
<a href="http://www.root.cz/clanky/prace-s-hodnotami-s-plovouci-radovou-carkou-na-mikroprocesorech-arm/">http://www.root.cz/clanky/prace-s-hodnotami-s-plovouci-radovou-carkou-na-mikroprocesorech-arm/</a>
</li>

<li>Simplified PowerPC Instruction Set<br />
<a href="http://www.ds.ewi.tudelft.nl/vakken/in101/labcourse/instruction-set/">http://www.ds.ewi.tudelft.nl/vakken/in101/labcourse/instruction-set/</a>
</li>

<li>Assembly language for Power Architecture, Part 1: Programming concepts and beginning PowerPC instructions<br />
<a href="http://www.ibm.com/developerworks/linux/library/l-powasm1/index.html">http://www.ibm.com/developerworks/linux/library/l-powasm1/index.html</a>
</li>

<li>Assembly language for Power Architecture, Part 2: The art of loading and storing on PowerPC<br />
<a href="http://www.ibm.com/developerworks/linux/library/l-powasm2/index.html">http://www.ibm.com/developerworks/linux/library/l-powasm2/index.html</a>
</li>

<li>Assembly language for Power Architecture, Part 3: Programming with the PowerPC branch processor<br />
<a href="http://www.ibm.com/developerworks/library/l-powasm3/index.html">http://www.ibm.com/developerworks/library/l-powasm3/index.html</a>
</li>

<li>Assembly language for Power Architecture, Part 4: Function calls and the PowerPC 64-bit ABI<br />
<a href="http://www.ibm.com/developerworks/linux/library/l-powasm4/index.html">http://www.ibm.com/developerworks/linux/library/l-powasm4/index.html</a>
</li>

<li>PowerPC overview (poněkud starší materiály z&nbsp;roku 2006)<br />
<a href="http://titancity.com/articles/ppc.html">http://titancity.com/articles/ppc.html</a>
</li>

<li>PowerPC (Wikipedia)<br />
<a href="https://en.wikipedia.org/wiki/PowerPC">https://en.wikipedia.org/wiki/PowerPC</a>
</li>

<li>Status Register<br />
<a href="https://en.wikipedia.org/wiki/Status_register">https://en.wikipedia.org/wiki/Status_register</a>
</li>

<li>Why Learn Assembly Language?<br />
<a href="http://www.codeproject.com/Articles/89460/Why-Learn-Assembly-Language">http://www.codeproject.com/Articles/89460/Why-Learn-Assembly-Language</a>
</li>

<li>Is Assembly still relevant?<br />
<a href="http://programmers.stackexchange.com/questions/95836/is-assembly-still-relevant">http://programmers.stackexchange.com/questions/95836/is-assembly-still-relevant</a>
</li>

<li>Why Learning Assembly Language Is Still a Good Idea<br />
<a href="http://www.onlamp.com/pub/a/onlamp/2004/05/06/writegreatcode.html">http://www.onlamp.com/pub/a/onlamp/2004/05/06/writegreatcode.html</a>
</li>

<li>Assembly language today<br />
<a href="http://beust.com/weblog/2004/06/23/assembly-language-today/">http://beust.com/weblog/2004/06/23/assembly-language-today/</a>
</li>

<li>RISC-V Draft Sompressed ISA Version 1.9 Released<br />
<a href="https://blog.riscv.org/2015/11/risc-v-draft-compressed-isa-version-1-9-released/">https://blog.riscv.org/2015/11/risc-v-draft-compressed-isa-version-1-9-released/</a>
</li>

<li>RISC vs. CISC: the Post-RISC Era<br />
<a href="http://archive.arstechnica.com/cpu/4q99/risc-cisc/rvc-1.html">http://archive.arstechnica.com/cpu/4q99/risc-cisc/rvc-1.html</a>
</li>

<li>Introduction to ARM Thumb<br />
<a href="http://www.embedded.com/electronics-blogs/beginner-s-corner/4024632/Introduction-to-ARM-thumb">http://www.embedded.com/electronics-blogs/beginner-s-corner/4024632/Introduction-to-ARM-thumb</a>
</li>

<li>Code Size – a comprehensive comparison of microMIPS32 and Thumb code size using many Megabytes of customer code<br />
<a href="https://community.arm.com/groups/processors/blog/2014/04/28/code-size-a-comprehensive-comparison-of-micromips32-and-thumb-code-size-using-many-megabytes-of-customer-code">https://community.arm.com/groups/processors/blog/2014/04/28/code-size-a-comprehensive-comparison-of-micromips32-and-thumb-code-size-using-many-megabytes-of-customer-code</a>
</li>

<li>MIPS MCUs Outrun ARM<br />
<a href="http://www.linleygroup.com/newsletters/newsletter_detail.php?num=5117">http://www.linleygroup.com/newsletters/newsletter_detail.php?num=5117</a>
</li>

<li>Improving Energy Efficiency and Reducing Code Size with RISC-V Compressed<br />
<a href="http://www.eecs.berkeley.edu/~waterman/papers/ms-thesis.pdf">http://www.eecs.berkeley.edu/~waterman/papers/ms-thesis.pdf</a>
</li>

<li>An Introduction to Lock-Free Programming<br />
<a href="http://preshing.com/20120612/an-introduction-to-lock-free-programming/">http://preshing.com/20120612/an-introduction-to-lock-free-programming/</a>
</li>

<li>Sequential consistency<br />
<a href="https://en.wikipedia.org/wiki/Sequential_consistency">https://en.wikipedia.org/wiki/Sequential_consistency</a>
</li>

<li>Understanding Atomic Operations<br />
<a href="https://jfdube.wordpress.com/2011/11/30/understanding-atomic-operations/">https://jfdube.wordpress.com/2011/11/30/understanding-atomic-operations/</a>
</li>

<li>Load-link/store-conditional<br />
<a href="https://en.wikipedia.org/wiki/Load-link/store-conditional">https://en.wikipedia.org/wiki/Load-link/store-conditional</a>
</li>

<li>The RISC-V Compressed Instruction Set Manual (Pozor: verze 1.7)<br />
<a href="http://riscv.org/spec/riscv-compressed-spec-v1.7.pdf">http://riscv.org/spec/riscv-compressed-spec-v1.7.pdf</a>
</li>

<li>Carry bits, The Architect's Trap<br />
<a href="http://yarchive.net/comp/carry_bit.html">http://yarchive.net/comp/carry_bit.html</a>
</li>

<li>Microprocessor Design/ALU Flags<br />
<a href="https://en.wikibooks.org/wiki/Microprocessor_Design/ALU_Flags">https://en.wikibooks.org/wiki/Microprocessor_Design/ALU_Flags</a>
</li>

<li>Flags register in an out-of-order processor<br />
<a href="http://cs.stackexchange.com/questions/42095/flags-register-in-an-out-of-order-processor">http://cs.stackexchange.com/questions/42095/flags-register-in-an-out-of-order-processor</a>
</li>

<li>AMD Am29000<br />
<a href="https://en.wikipedia.org/wiki/AMD_Am29000">https://en.wikipedia.org/wiki/AMD_Am29000</a>
</li>

<li>Status register<br />
<a href="https://en.wikipedia.org/wiki/Status_register">https://en.wikipedia.org/wiki/Status_register</a>
</li>

<li>AMD Am29000 microprocessor family<br />
<a href="http://www.cpu-world.com/CPUs/29000/">http://www.cpu-world.com/CPUs/29000/</a>
</li>

<li>AMD 29k (Streamlined Instruction Processor) ID Guide<br />
<a href="http://www.cpushack.com/Am29k.html">http://www.cpushack.com/Am29k.html</a>
</li>

<li>AMD Am29000 (Wikipedia)<br />
<a href="http://en.wikipedia.org/wiki/AMD_Am29000">http://en.wikipedia.org/wiki/AMD_Am29000</a>
</li>

<li>AMD K5 ("K5" / "5k86")<br />
<a href="http://www.pcguide.com/ref/cpu/fam/g5K5-c.html">http://www.pcguide.com/ref/cpu/fam/g5K5-c.html</a>
</li>

<li>Comparing four 32-bit soft processor cores<br />
<a href="http://www.eetimes.com/author.asp?section_id=14&doc_id=1286116">http://www.eetimes.com/author.asp?section_id=14&doc_id=1286116</a>
</li>

<li>RISC-V Instruction Set<br />
<a href="http://riscv.org/download.html#spec_compressed_isa">http://riscv.org/download.html#spec_compressed_isa</a>
</li>

<li>RISC-V Spike (ISA Simulator)<br />
<a href="http://riscv.org/download.html#isa-sim">http://riscv.org/download.html#isa-sim</a>
</li>

<li>RISC-V (Wikipedia)<br />
<a href="https://en.wikipedia.org/wiki/RISC-V">https://en.wikipedia.org/wiki/RISC-V</a>
</li>

<li>David Patterson (Wikipedia)<br />
<a href="https://en.wikipedia.org/wiki/David_Patterson_(computer_scientist)">https://en.wikipedia.org/wiki/David_Patterson_(computer_scientist)</a>
</li>

<li>OpenRISC (oficiální­ stránky tohoto projektu)<br />
<a href="http://openrisc.io/">http://openrisc.io/</a>
</li>

<li>OpenRISC architecture<br />
<a href="http://openrisc.io/architecture.html">http://openrisc.io/architecture.html</a>
</li>

<li>Emulátor OpenRISC CPU v JavaScriptu<br />
<a href="http://s-macke.github.io/jor1k/demos/main.html">http://s-macke.github.io/jor1k/demos/main.html</a>
</li>

<li>OpenRISC (Wikipedia)<br />
<a href="https://en.wikipedia.org/wiki/OpenRISC">https://en.wikipedia.org/wiki/OpenRISC</a>
</li>

<li>OpenRISC - instrukce<br />
<a href="http://sourceware.org/cgen/gen-doc/openrisc-insn.html">http://sourceware.org/cgen/gen-doc/openrisc-insn.html</a>
</li>

<li>OpenRISC - slajdy z&nbsp;přednášky o tomto projektu<br />
<a href="https://iis.ee.ethz.ch/~gmichi/asocd/lecturenotes/Lecture6.pdf">https://iis.ee.ethz.ch/~gmichi/asocd/lecturenotes/Lecture6.pdf</a>
</li>

<li>Maska mikroprocesoru RISC 1<br />
<a href="http://www.cs.berkeley.edu/~pattrsn/Arch/RISC1.jpg">http://www.cs.berkeley.edu/~pattrsn/Arch/RISC1.jpg</a>
</li>

<li>Maska mikroprocesoru RISC 2<br />
<a href="http://www.cs.berkeley.edu/~pattrsn/Arch/RISC2.jpg">http://www.cs.berkeley.edu/~pattrsn/Arch/RISC2.jpg</a>
</li>

<li>C.E. Sequin and D.A.Patterson: Design and Implementation of RISC I<br />
<a href="http://www.eecs.berkeley.edu/Pubs/TechRpts/1982/CSD-82-106.pdf">http://www.eecs.berkeley.edu/Pubs/TechRpts/1982/CSD-82-106.pdf</a>
</li>

<li>Berkeley RISC<br />
<a href="http://en.wikipedia.org/wiki/Berkeley_RISC">http://en.wikipedia.org/wiki/Berkeley_RISC</a>
</li>

<li>Great moments in microprocessor history<br />
<a href="http://www.ibm.com/developerworks/library/pa-microhist.html">http://www.ibm.com/developerworks/library/pa-microhist.html</a>
</li>

<li>Microprogram-Based Processors<br />
<a href="http://research.microsoft.com/en-us/um/people/gbell/Computer_Structures_Principles_and_Examples/csp0167.htm">http://research.microsoft.com/en-us/um/people/gbell/Computer_Structures_Principles_and_Examples/csp0167.htm</a>
</li>

<li>Great Microprocessors of the Past and Present<br />
<a href="http://www.cpushack.com/CPU/cpu1.html">http://www.cpushack.com/CPU/cpu1.html</a>
</li>

<li>A Brief History of Microprogramming<br />
<a href="http://www.cs.clemson.edu/~mark/uprog.html">http://www.cs.clemson.edu/~mark/uprog.html</a>
</li>

<li>What is RISC?<br />
<a href="http://www-cs-faculty.stanford.edu/~eroberts/courses/soco/projects/2000-01/risc/whatis/">http://www-cs-faculty.stanford.edu/~eroberts/courses/soco/projects/2000-01/risc/whatis/</a>
</li>

<li>RISC vs. CISC<br />
<a href="http://www-cs-faculty.stanford.edu/~eroberts/courses/soco/projects/2000-01/risc/risccisc/">http://www-cs-faculty.stanford.edu/~eroberts/courses/soco/projects/2000-01/risc/risccisc/</a>
</li>

<li>RISC and CISC definitions:<br />
<a href="http://www.cpushack.com/CPU/cpuAppendA.html">http://www.cpushack.com/CPU/cpuAppendA.html</a>
</li>

<li>FPGA<br />
<a href="https://cs.wikipedia.org/wiki/Programovateln%C3%A9_hradlov%C3%A9_pole">https://cs.wikipedia.org/wiki/Programovateln%C3%A9_hradlov%C3%A9_pole</a>
</li>

<li>The Evolution of RISC<br />
<a href="http://www.ibm.com/developerworks/library/pa-microhist.html#sidebar1">http://www.ibm.com/developerworks/library/pa-microhist.html#sidebar1</a>
</li>

<li>SPARC Processor Family Photo<br />
<a href="http://thenetworkisthecomputer.com/site/?p=243">http://thenetworkisthecomputer.com/site/?p=243</a>
</li>

<li>SPARC: Decades of Continuous Technical Innovation<br />
<a href="http://blogs.oracle.com/ontherecord/entry/sparc_decades_of_continuous_technical">http://blogs.oracle.com/ontherecord/entry/sparc_decades_of_continuous_technical</a>
</li>

<li>The SPARC processors<br />
<a href="http://www.top500.org/2007_overview_recent_supercomputers/sparc_processors">http://www.top500.org/2007_overview_recent_supercomputers/sparc_processors</a>
</li>

<li>Reduced instruction set computing (Wikipedia)<br />
<a href="http://en.wikipedia.org/wiki/Reduced_instruction_set_computer">http://en.wikipedia.org/wiki/Reduced_instruction_set_computer</a>
</li>

<li>MIPS architecture (Wikipedia)<br />
<a href="http://en.wikipedia.org/wiki/MIPS_architecture">http://en.wikipedia.org/wiki/MIPS_architecture</a>
</li>

<li>Very long instruction word (Wikipedia)<br />
<a href="http://en.wikipedia.org/wiki/Very_long_instruction_word">http://en.wikipedia.org/wiki/Very_long_instruction_word</a>
</li>

<li>Classic RISC pipeline (Wikipedia)<br />
<a href="http://en.wikipedia.org/wiki/Classic_RISC_pipeline">http://en.wikipedia.org/wiki/Classic_RISC_pipeline</a>
</li>

<li>R2000 Microprocessor (Wikipedia)<br />
<a href="http://en.wikipedia.org/wiki/R2000_(microprocessor)">http://en.wikipedia.org/wiki/R2000_(microprocessor)</a>
</li>

<li>R3000 Microprocessor (Wikipedia)<br />
<a href="http://en.wikipedia.org/wiki/R3000">http://en.wikipedia.org/wiki/R3000</a>
</li>

<li>R4400 Microprocessor (Wikipedia)<br />
<a href="http://en.wikipedia.org/wiki/R4400">http://en.wikipedia.org/wiki/R4400</a>
</li>

<li>R8000 Microprocessor (Wikipedia)<br />
<a href="http://en.wikipedia.org/wiki/R8000">http://en.wikipedia.org/wiki/R8000</a>
</li>

<li>R10000 Microprocessor (Wikipedia)<br />
<a href="http://en.wikipedia.org/wiki/R10000">http://en.wikipedia.org/wiki/R10000</a>
</li>

<li>SPARC (Wikipedia)<br />
<a href="http://en.wikipedia.org/wiki/Sparc">http://en.wikipedia.org/wiki/Sparc</a>
</li>

<li>CPU design (Wikipedia)<br />
<a href="http://en.wikipedia.org/wiki/CPU_design">http://en.wikipedia.org/wiki/CPU_design</a>
</li>

<li>Control unit (Wikipedia)<br />
<a href="http://en.wikipedia.org/wiki/Control_unit">http://en.wikipedia.org/wiki/Control_unit</a>
</li>

</ol>



<p></p><p></p>
<p><small>Autor: <a href="http://www.fit.vutbr.cz/~tisnovpa">Pavel Tišnovský</a> &nbsp; 2016</small></p>
</body>
</html>

