<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
        "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html>
<head>
<title>Superskalární RISCová jádra SH-4 a SH-4A použitá v mikroprocesorech i mikrořadičích</title>
<meta name="Author" content="Pavel Tisnovsky" />
<meta name="Generator" content="vim" />
<meta http-equiv="content-type" content="text/html; charset=utf-8" />
<style type="text/css">
         body {color:#000000; background:#ffffff;}
         h1  {font-family: arial, helvetica, sans-serif; color:#ffffff; background-color:#c00000; text-align:center; padding-left:1em}
         h2  {font-family: arial, helvetica, sans-serif; color:#ffffff; background-color:#0000c0; padding-left:1em; text-align:left}
         h3  {font-family: arial, helvetica, sans-serif; color:#000000; background-color:#c0c0c0; padding-left:1em; text-align:left}
         h4  {font-family: arial, helvetica, sans-serif; color:#000000; background-color:#e0e0e0; padding-left:1em; text-align:left}
         a   {font-family: arial, helvetica, sans-serif;}
         li  {font-family: arial, helvetica, sans-serif; color:#000000; text-align:justify; width:450px;}
         ol  {font-family: arial, helvetica, sans-serif; color:#000000; text-align:justify; width:450px;}
         ul  {font-family: arial, helvetica, sans-serif; color:#000000; text-align:justify; width:450px;}
         p   {font-family: arial, helvetica, sans-serif; color:#000000; text-align:justify;}
         pre {background:#e0e0e0}
</style>
</head>

<body>

<h1>Superskalární RISCová jádra SH-4 a SH-4A použitá v mikroprocesorech i mikrořadičích</h1>

<h3>Pavel Tišnovský</h3>

<p></p>

<h1>Úvodník</h1>

<p>V pátém a současně i posledním článku o čipech s&nbsp;architekturou SuperH si popíšeme vlastnosti superskalárních RISCových jader nazvaných SH-4 a SH-4A. Tato jádra dnes nalezneme jak v&nbsp;mikroprocesorech tak i mikrořadičích vyráběných společností Renesas.</p>



<h2>Obsah</h2>

<p><a href="#k01">1. Superskalární RISCová jádra SH-4 a SH-4A použitá v&nbsp;mikroprocesorech i mikrořadičích</a></p>
<p><a href="#k02">2. Základní pipeline použité v&nbsp;architektuře SH-4</a></p>
<p><a href="#k03">3. Pipeline určené pro operace s&nbsp;plovoucí řádovou čárkou</a></p>
<p><a href="#k04">4. Paralelní vykonávání instrukcí</a></p>
<p><a href="#k05">5. Instrukční sada jader SH-4</a></p>
<p><a href="#k06">6. Instrukce pro SH-2A, které nejsou podporovány v&nbsp;jádru SH-4</a></p>
<p><a href="#k07">7. Jádra SH-4</a></p>
<p><a href="#k08">8. Pipeline použité v&nbsp;architektuře SH-4A</a></p>
<p><a href="#k09">9. Pipeline pro FPU operace</a></p>
<p><a href="#k10">10. Instrukce matematického koprocesoru určené pro urychlení grafických operací</a></p>
<p><a href="#k11">11. Obsah následující části seriálu</a></p>
<p><a href="#k12">12. Odkazy na Internetu</a></p>



<p><a name="k01"></a></p>
<h2 id="k01">1. Superskalární RISCová jádra SH-4 a SH-4A použitá v&nbsp;mikroprocesorech i mikrořadičích</h2>

<p>V&nbsp;předchozích částech tohoto seriálu jsme se seznámili s&nbsp;RISCovými
jádry nazvanými SH-1, SH-2 a SH-2A. Ve všech případech se jedná o 32bitová
RISCová jádra, která se od většiny ostatních mikroprocesorů
s&nbsp;architekturou RISC odlišují především tím, že instrukční slova mají
šířku šestnáct bitů, zatímco u klasických RISCových architektur nalezneme slova
o šířce 32 bitů. Tento rozdíl je pravděpodobně nejvíce markantní v&nbsp;oblasti
mikrořadičů, takže není divu, že čipy SH (SuperH) nalezneme právě v&nbsp;této
aplikační oblasti (na tomto místě je však nutné upozornit na fakt, že u SH-2(A)
nalezneme několik instrukcí uložených do dvou slov, ovšem stále se jedná o
několik výjimek a nikoli o pravidlo, jak je tomu například na typických
architekturách CISC x86 a 68k). Od jader SH-1 a SH-2 jsou odvozeny další dvě
řady: SH-3 (tato jádra se dnes již příliš nepoužívají) a SH-4. A právě popisem
jader SH-4 a jejich vylepšené varianty SH-4A se budeme zabývat v&nbsp;dnešním
článku, kterým celé téma čipů SuperH dokončíme.</p>

<p>Původní varianta jádra SH-4 je použita například v&nbsp;následujících
mikroprocesorech:</p>

<table>
<tr><th>Čip</th><th>Max frekvence</th><th>Pinů</th><th>Napájení</th></tr>
<tr><td>SH7750R</td><td>240 MHz</td><td>208-292</td><td>3-3,6V</td></tr>
<tr><td>SH7750S</td><td>200 MHz</td><td>208-264</td><td>3-3,6V</td></tr>
<tr><td>SH7751 </td><td>167 MHz</td><td>256    </td><td>3-3,6V</td></tr>
<tr><td>SH7751R</td><td>240 MHz</td><td>256-292</td><td>3-3,6V</td></tr>
<tr><td>SH7760 </td><td>200 MHz</td><td>256    </td><td>3-3,6V</td></tr>
</table>

<p>Poznámka: poměrně nízká hodinová frekvence nemusí být limitujícím faktorem,
protože tyto čipy nejsou v&nbsp;žádném případě určeny pro použití
v&nbsp;desktopech ani v&nbsp;klasických serverech (což můžeme chápat i tak, že
v&nbsp;těchto oblastech nejsou či nebyly konkurenceschopné :-). Spíše je
zajímavé sledovat údaj o spotřebě, který dosahuje hodnoty až 1,2 W (při vyšším
napájecím napětí).</p>

<p>V&nbsp;některých mikrořadičích nalezneme jádra SH-4A, která mají odlišnou
konstrukci pipeline i upravenou sadu instrukcí. Jedná se především o řadu
SH7450 s&nbsp;těmito variantami čipů:</p>

<table>
<tr><th>Čip</th><th>Max frekvence</th><th>Pinů</th><th>Napájení</th><th>RAM</th><th>Flash ROM</th></tr>
<tr><td>SH7450, SH7451</td><td>240 MHz</td><td>292</td><td>3-5,5 V</td><td>536 kB</td><td>1536-2048 kB</td></tr>
<tr><td>SH7455, SH7456</td><td>160 MHz</td><td>176</td><td>3-5,5 V</td><td>280 kB</td><td>1024 kB</td></tr>
<tr><td>SH7457, SH7459</td><td>240 MHz</td><td>176</td><td>3-5,5 V</td><td>280-536 kB</td><td>1024-1536 kB</td></tr>
</table>



<p><a name="k02"></a></p>
<h2 id="k02">2. Základní pipeline použité v&nbsp;architektuře SH-4</h2>

<p>V&nbsp;marketingových materiálech společnosti Renesas se můžeme dočíst, že
jádra SH-4 dokážou díky použití pipeline a superskalární architektury dokončit
v&nbsp;každém hodinovém taktu dvě instrukce (přičemž se bez dalších
podrobnějších informací dodává &bdquo;včetně FPU operací&ldquo;). Ve
skutečnosti je ovšem tato výpočetní rychlost pouze teoretická, protože
v&nbsp;SH-4 nalezneme hned několik pravidel, která se týkají jak překryvu
instrukcí v&nbsp;pipeline, tak i v&nbsp;omezené kombinaci instrukcí, které je
možné spustit paralelně. Prakticky se dostáváme k&nbsp;hodnotám okolo 1,5
instrukce/takt. S&nbsp;některými omezeními se seznámíme v&nbsp;následujícím
textu.</p>

<p>Čipy postavené na jádru SH-4 používají tři typy pipeline. První typ je
využit u operací typu load and store, u všech operací pracujících
s&nbsp;celočíselnou aritmeticko-logickou jednotkou, u skoků i u instrukcí
pracujících s&nbsp;příznakovým bitem T. Zvláštní konfigurace pipeline nalezneme
u matematického koprocesoru, kde je nutné vyhradit větší počet řezů na samotné
provedení požadované operace (u ALU operací je to jen jeden takt), na druhou
stranu se však u těchto operací neprovádí zápis zpět do operační paměti, takže
se vynechává fáze/modul WB (<i>Write Back</i>).</p>

<p>Nejprve se však věnujme konfiguraci pipeline prvního typu. Tato pipeline má
pět řezů, což je typické i pro mnoho dalších konkurenčních RISCových procesorů.
Jaké konkrétní činnosti se v&nbsp;každém řezu provedou závisí na typu
instrukce, takže se nyní na jednotlivé možnosti podívejme podrobněji.</p>

<p>Operace typu load and store (včetně FPUL, MOV, FMOV, LDS) jsou provedeny
v&nbsp;asi nejklasičtějším režimu pipeline, protože se v&nbsp;něm používají
fáze Instruction Fetch, Instruction Decode, Execute, Memory Access a Write
Back:</p>

<pre>
+----+----+----+----+----+
| IF | ID | EX | MA | WB |
+----+----+----+----+----+
</pre>

<p>Většina operací s&nbsp;ALU (ADD, CMP, DT, NEG, ...) + skoky nepotřebuje
provést zpětný zápis výsledku do operační paměti:</p>

<pre>
+----+----+----+----+----+
| IF | ID | EX | NA | WB |
+----+----+----+----+----+
</pre>

<p>Přesuny dat s&nbsp;využitím adresování přes GBR (Global Base Register)
používají odlišný třetí řez, což se projeví v&nbsp;možností překryvu
instrukcí:</p>

<pre>
+----+----+----+----+----+
| IF | ID | SX | NA | WB |
+----+----+----+----+----+
</pre>

<p>Load a store operace s&nbsp;využitím registru GBR:</p>

<pre>
+----+----+----+----+----+
| IF | ID | SX | MA | WB |
+----+----+----+----+----+
</pre>

<p>Význam zkratek použitých ve schématech pipeline:</p>

<table>
<tr><td>IF</td><td>Instruction Fetch</td></tr>
<tr><td>ID</td><td>Instruction Decode (+ čtení z registrů)</td></tr>
<tr><td>EX</td><td>Execute, provedení ALU operace atd.</td></tr>
<tr><td>NA</td><td>Non-memory Data Access (nebo jen přenos dat do další fáze)</td></tr>
<tr><td>MA</td><td>Memory Access, přístup do operační paměti</td></tr>
<tr><td>WB</td><td>Write Back, opět přístup do registrů</td></tr>
</table>

<p>U naprosté většiny instrukcí se mohou jednotlivé (samozřejmě navzájem
odlišné, tj.&nbsp;minimálně o takt posunuté) fáze pipeline překrývat, pokud
samozřejmě nedochází ke konfliktům při přístupu k&nbsp;pracovním registrům
a/nebo při přístupu do operační paměti. Vzhledem k&nbsp;tomu, že samotný CPU je
propojen s&nbsp;cache paměťmi s&nbsp;použitím oddělených sběrnic pro data a
instrukce (a i cache je rozdělena na instrukční cache a datovou cache), je
minimalizován konflikt mezi fází <strong>IF</strong> a <strong>MA</strong>,
ovšem jiným konfliktům to samozřejmě nezabrání (zde se může negativně projevit
relativně malý počet pracovních registrů v&nbsp;porovnání s&nbsp;některými
dalšími RISCovými procesory, jejichž banky registrů bývají dvojnásobné).</p>



<p><a name="k03"></a></p>
<h2 id="k03">3. Pipeline určené pro operace s&nbsp;plovoucí řádovou čárkou</h2>

<p>Pipeline používaná u operací s&nbsp;plovoucí řádovou čárkou má poněkud
odlišnou strukturu, protože se zde nemusí použít zpětný zápis výsledku operace
do operační paměti. U &bdquo;jednoduchých&ldquo; operací se setkáme
s&nbsp;pětiřezovou pipeline, v&nbsp;níž symboly <strong>F1</strong> a
<strong>F2</strong> reprezentují různé na sebe navazující fáze výpočtu a
<strong>FS</strong> je zpětný zápis výsledku do vybraného pracovního
registru:</p>

<pre>
+----+----+----+----+----+
| IF | ID | F1 | F2 | FS |
+----+----+----+----+----+
</pre>

<p>Některé FPU instrukce mají nepatrně prodlouženou dobu výpočtu, takže celá
pipeline má šest řezů:</p>

<pre>
+----+----+----+----+----+----+
| IF | ID | F0 | F1 | F2 | FS |
+----+----+----+----+----+----+
</pre>

<p>Specialitou jsou pak dvě instrukce nazvané <strong>FDIV</strong> a
<strong>FSQRT</strong>, o nichž již z&nbsp;předchozího článku víme, že jejich
doba trvání je 10 a 9 cyklů pro typ <i>single</i> a 23 a 22 cyklů pro typ
<i>double</i> &ndash; zde je tedy pipeline značně &bdquo;natažena&ldquo; a
provádí se mnohem větší množství fází Fn. Navíc se prodlužuje i doba operací
s&nbsp;čísly s&nbsp;dvojnásobnou přesností, a to z&nbsp;toho důvodu, že přenosy
dat se provádí po 32bitových sběrnicích (výjimkou je jen přenos mezi FPU a
datovou cache s&nbsp;šířkou 64 bitů, což odpovídá typu double).</p>



<p><a name="k04"></a></p>
<h2 id="k04">4. Paralelní vykonávání instrukcí</h2>

<p>Jak jsme si již řekli v&nbsp;úvodních kapitolách, mají jádra SH-4
superskalární architekturu, což zde konkrétně znamená, že v&nbsp;ideálním
případě je možné spustit vykonávání dvou instrukcí současně, což dále (společně
s&nbsp;překryvem různých fází v&nbsp;pipeline) vede či může vést
k&nbsp;urychlení běhu programu. Protože zdaleka ne všechny bloky na čipu jsou
skutečně zdvojeny (někdy to ani není možné &ndash; například v&nbsp;případě
paměti atd.), je zavedeno několik omezení pro paralelní běh instrukcí. Všechny
instrukce jsou rozděleny do šesti skupin, přičemž je stanoveno, za jakých
okolností je možné instrukce párovat (spouštět skutečně paralelně). Například
platí, že lze párovat jakoukoli ALU instrukci s&nbsp;instrukcí podmíněného
skoku, instrukcí přenosu dat (load/store) či s&nbsp;instrukcí matematického
koprocesoru. Naproti tomu není možné párovat dvě ALU instrukce, dvě instrukce
matematického koprocesoru atd. Jen instrukce z&nbsp;první skupiny mohou tvořit
pár, jinak je vždy nutné párovat instrukce ze dvou odlišných skupin. Speciální
skupinu pak tvoří několik instrukcí, které se nepárují nikdy (mohou však
samozřejmě být postupně spouštěny v&nbsp;jediné pipeline)</p>

<p>Poznámka: jádra SH-4 mají v&nbsp;oblasti paralelního spouštění instrukcí
větší množství <strong>teoretických</strong> omezení, než například původní
čipy Pentium se dvěma pipeline nazvanými U a V. To však souvisí například
s&nbsp;tím, že v&nbsp;poměrně minimalisticky pojatém SH-4 je použita pouze
jedna plnohodnotná ALU s&nbsp;barrel shifterem, která je doplněna samostatným
blokem pro porovnání dvou operandů (Pentium mělo dvě ALU, i když ta druhá
neměla barrel shifter). Totéž porovnání lze samozřejmě provést i v&nbsp;ALU,
což znamená, že párování operací CMP/xx+ADD (například) je možné provést
prakticky za všech okolností, dokonce lze i párovat operace CMP/xx+CMP/xx (což
však nemá praktický význam). Nemožnost párování dvou ALU operací nemusí být
kritická ve chvíli, kdy se navíc provádí přenosy dat popř.&nbsp;příprava dat
v&nbsp;pracovních registrech, protože ALU operaci+load/store či ALU operaci+MOV
provést paralelně lze.</p>



<p><a name="k05"></a></p>
<h2 id="k05">5. Instrukční sada jader SH-4</h2>

<p>Počet instrukcí použitých v&nbsp;RISCových jádrech řady SuperH postupně
narůstal, takže se původní sada 56 RISCových instrukcí v&nbsp;jádru SH-1
rozrostla až na trojnásobek v&nbsp;jádrech s&nbsp;podporou DSP operací (SH-2
DSP a SH-3 DSP). V&nbsp;následující tabulce jsou vypsány počty instrukcí u
základních řad procesorových jader SuperH:</p>

<table>
<tr><th>Jádro</th><th>Počet instrukcí</th></tr>
<tr><td>SH-1    </td><td> 56</td></tr>
<tr><td>SH-2    </td><td> 62</td></tr>
<tr><td>SH-3    </td><td> 68</td></tr>
<tr><td>SH-4    </td><td> 91</td></tr>
<tr><td>SH-2A   </td><td> 97</td></tr>
<tr><td>SH-2 DSP</td><td>154</td></tr>
<tr><td>SH-3 DSP</td><td>160</td></tr>
</table>

<p>Důležité upozornění: instrukční sady se ve skutečnosti zcela nepřekrývají,
což se týká především porovnání <i>SH-2A</i> a <i>SH-4</i>, i když obě tato
jádra ideově vychází z&nbsp;jádra <i>SH-2</i>.</p>

<p>V&nbsp;následujících tabulkách jsou vypsány všechny instrukce podporované
jádry <i>SH-4</i>. Tučně jsou zvýrazněny ty instrukce, které byly nově přidány
(v&nbsp;porovnání s&nbsp;řadou <i>SH-2</i>).</p>

<p>Přenosy dat:</p>

<table>
<tr><th>Instrukce</th><th>Popis</th></tr>
<tr><td>MOV   </td><td>přesun dat do registru popř.&nbsp;uložení do operační paměti (mnoho adresovacích režimů)</td></tr>
<tr><td>MOVA  </td><td>výpočet disp &times; 4 + PC &rarr; R0 (užitečné při načítání 32bitových konstant)</td></tr>
<tr><td>LDC   </td><td>přenos dat mezi pracovním registrem Rs a speciálním registrem SR, GBR či VBR</td></tr>
<tr><td>LDS   </td><td>přenos dat mezi pracovním registrem Rs a speciálním registrem PR, MACH či MACL</td></tr>
<tr><td>STC   </td><td>přenos dat mezi speciálním registrem SR, GBR či VBR a pracovním registrem Rs</td></tr>
<tr><td>STS   </td><td>přenos dat mezi speciálním registrem PR, MACH či MACL a pracovním registrem Rd</td></tr>
<tr><td>SWAP  </td><td>prohození dvou nejnižších bajtů či dvou 16bitových slov (lze použít dva registry)</td></tr>
<tr><td>XTRCT </td><td>prostředních 32 bitů z registrového páru Rs:Rd se uloží do Rd</td></tr>
<tr><td>EXTS  </td><td>znaménkové rozšíření bajtu či 16bitového slova na 32bitové slovo</td></tr>
<tr><td>EXTU  </td><td>bezznaménkové rozšíření bajtu či 16bitového slova na 32bitové slovo (horních 24/16 bitů se vynuluje)</td></tr>
</table>

<p>Aritmetické instrukce:</p>

<table>
<tr><th>Zkratka</th><th>Popis</th></tr>
<tr><td>ADD </td><td>součet registr+registr či registr+konstanta</td></tr>
<tr><td>ADDC</td><td>součet registr+registr+<strong>T</strong>, přenos (<i>carry</i>) se uloží do <strong>T</strong></td></tr>
<tr><td>ADDV</td><td>součet registr+registr, přetečení (<i>overflow</i>) se uloží do <strong>T</strong></td></tr>
<tr><td>SUB </td><td>rozdíl registr-registr či registr-konstanta</td></tr>
<tr><td>SUBC</td><td>rozdíl registr-registr-<strong>T</strong>, výpůjčka (<i>borrow</i>) se uloží do <strong>T</strong></td></tr>
<tr><td>SUBV</td><td>rozdíl registr-registr, podtečení (<i>underflow</i>) se uloží do <strong>T</strong></td></tr>
<tr><td>NEG </td><td>rozdíl 0-registr</td></tr>
<tr><td>NEGC</td><td>rozdíl 0-registr-<strong>T</strong>, výpůjčka (<i>borrow</i>) se uloží do <strong>T</strong></td></tr>
<tr><td>MUL </td><td>násobení 16bitových či 32bitových operandů s&nbsp;32bitovým výsledkem</td></tr>
<tr><td>MULS</td><td>násobení 16bitových operandů s&nbsp;32bitovým výsledkem (signed)</td></tr>
<tr><td>MULU</td><td>násobení 16bitových operandů s&nbsp;32bitovým výsledkem (unsigned)</td></tr>
<tr><td>MAC </td><td>(Rn)*(Rm)+MAC &rarr; MAC, Rn++, Rm++ (posun v&nbsp;poli)</td></tr>
<tr><td>DMULS</td><td>násobení 32bitových operandů s&nbsp;64bitovým výsledkem (signed)</td></tr>
<tr><td>DMULU</td><td>násobení 32bitových operandů s&nbsp;64bitovým výsledkem (unsigned)</td></tr>
<tr><td>DIV1 </td><td>jeden krok dělení Rs/Rd</td></tr>
<tr><td>DIV0S</td><td>příprava na dělení dvou čísel se znaménkem (nastavení bitů M, Q a T)</td></tr>
<tr><td>DIV0U</td><td>příprava na dělení dvou čísel bez znaménka (nastavení bitů M, Q a T)</td></tr>
</table>

<p>Logické instrukce:</p>

<table>
<tr><th>Zkratka</th><th>Popis</th></tr>
<tr><td>AND</td><td>provedení operace Rs &amp; Rd či Rs &amp; konstanta</td></tr>
<tr><td>OR </td><td>provedení operace Rs | Rd či Rs | konstanta</td></tr>
<tr><td>XOR</td><td>provedení operace Rs &oplus; Rd či Rs &oplus; konstanta</td></tr>
<tr><td>NOT</td><td>negace bitů zdrojového registru Rs</td></tr>
</table>

<p>Bitové posuny a rotace:</p>

<table>
<tr><th>Zkratka</th><th>Popis</th></tr>
<tr><td>ROTL </td><td>rotace registru doleva, do <strong>T</strong> se uloží původní nejvyšší bit</td></tr>
<tr><td>ROTR </td><td>rotace registru doprava, do <strong>T</strong> se uloží původní nejnižší bit</td></tr>
<tr><td>ROTCL</td><td>rotace registru doleva přes bit <strong>T</strong> (33 bitů)</td></tr>
<tr><td>ROTCR</td><td>rotace registru doprava přes bit <strong>T</strong> (33 bitů)</td></tr>
<tr><td>SHAL </td><td>aritmetický posun doleva (nasouvá se nula, nejvyšší bit se kopíruje do <strong>T</strong>)</td></tr>
<tr><td>SHAR </td><td>aritmetický posun doprava (nejvyšší bit se klonuje, nejnižší se přesouvá do <strong>T</strong>)</td></tr>
<tr><td>SHLL </td><td>bitový posun doleva, <strong>T</strong> se nemění</td></tr>
<tr><td>SHLLn</td><td>bitový posun doleva o 2, 8 či 16 bitů, <strong>T</strong> se nemění</td></tr>
<tr><td>SHLR </td><td>bitový posun doprava, <strong>T</strong> se nemění</td></tr>
<tr><td>SHLRn</td><td>bitový posun doprava o 2, 8 či 16 bitů, <strong>T</strong> se nemění</td></tr>
<tr><td><strong>SHAD</strong></td><td>pokud Rn&ge;0 posun doleva o Rm, pokud Rn&lt;0 aritmetický posun doprava</td></tr>
<tr><td><strong>SHLD</strong></td><td>pokud Rn&ge;0 posun doleva o Rm, pokud Rn&lt;0 bitový posun doprava</td></tr>
</table>

<p>Porovnání či další operace nastavující bit <strong>T</strong>:</p>

<table>
<tr><th>Zkratka</th><th>Popis</th></tr>
<tr><td>CMP/EQ</td><td>nastavení 1&rarr;<strong>T</strong> za podmínky Rs=Rd</td></tr>
<tr><td>CMP/HS</td><td>nastavení 1&rarr;<strong>T</strong> za podmínky Rs&ge;Rd (unsigned)</td></tr>
<tr><td>CMP/GE</td><td>nastavení 1&rarr;<strong>T</strong> za podmínky Rs&ge;Rd (signed)</td></tr>
<tr><td>CMP/HI</td><td>nastavení 1&rarr;<strong>T</strong> za podmínky Rs&gt;Rd (unsigned)</td></tr>
<tr><td>CMP/GT</td><td>nastavení 1&rarr;<strong>T</strong> za podmínky Rs&gt;Rd (signed)</td></tr>
<tr><td>CMP/PZ</td><td>nastavení 1&rarr;<strong>T</strong> za podmínky Rs&ge;0</td></tr>
<tr><td>CMP/PL</td><td>nastavení 1&rarr;<strong>T</strong> za podmínky Rs&gt;0</td></tr>
<tr><td>CMP/STR</td><td>nastavení 1&rarr;<strong>T</strong> za podmínky Rs=Rd (jen spodní bajt)</td></tr>
<tr><td>TAS</td><td>nastavení 1&rarr;<strong>T</strong> za podmínky (Rs)=0 (buňka v&nbsp;paměti)</td></tr>
<tr><td>TST</td><td>nastavení 1&rarr;<strong>T</strong> za podmínky Rs &amp; Rd == 0</td></tr>
<tr><td>DT</td><td>snížení obsahu registru o 1 a nastavení 1&rarr;<strong>T</strong> pokud Rs==0</td></tr>
</table>

<p>Operace s&nbsp;bity <strong>T</strong> a <strong>S</strong>:</p>

<table>
<tr><th>Zkratka</th><th>Popis</th></tr>
<tr><td>MOVT</td><td>uložení bitu <strong>T</strong> do registru Rn</td></tr>
<tr><td>CLRT</td><td>vynulování bitu 0&rarr;<strong>T</strong></td></tr>
<tr><td>SETT</td><td>nastavení bitu 1&rarr;<strong>T</strong></td></tr>
<tr><td><strong>CLRS</strong></td><td>uložení 0 do bitu <strong>S</strong></td></tr>
<tr><td><strong>SETS</strong></td><td>nastavení bitu 1&rarr;<strong>S</strong></td></tr>
</table>

<p>Poznámka: bit <strong>S</strong> je používán instrukcemi typu multiply and
accumulate.</p>

<p>Podmíněné a nepodmíněné skoky, vstup a návrat z&nbsp;podprogramu:</p>

<table>
<tr><th>Zkratka</th><th>Popis</th></tr>
<tr><td>JMP </td><td>skok na adresu Rs</td></tr>
<tr><td>BRA </td><td>skok na adresu PC+displacement*2</td></tr>
<tr><td>BRAF</td><td>skok na adresu PC+Rs</td></tr>
<tr><td>JSR </td><td>uložení PC do registru PR, skok na adresu Rs</td></tr>
<tr><td>RTS </td><td>skok na adresu v&nbsp;PR</td></tr>
<tr><td>BSR </td><td>uložení PC do registru PR, skok na adresu PC+displacement*2</td></tr>
<tr><td>BSRF</td><td>uložení PC do registru PR, skok na adresu PC+Rs</td></tr>
<tr><td>BF  </td><td>skok na adresu PC+disp pokud platí <strong>T==0</strong></td></tr>
<tr><td>BT  </td><td>skok na adresu PC+disp pokud platí <strong>T==0</strong></td></tr>
<tr><td>BF/S</td><td>totéž jako BF, ale bez branch delay slotu</td></tr>
<tr><td>BT/S</td><td>totéž jako BF, ale bez branch delay slotu</td></tr>
</table>

<p>Další instrukce:</p>

<table>
<tr><th>Zkratka</th><th>Popis</th></tr>
<tr><td>NOP   </td><td>neprovede žádnou operaci</td></tr>
<tr><td>CLRMAC</td><td>vynulování registrů MACH a MACL (například před aplikací číslicového filtru)</td></tr>
<tr><td>RTE   </td><td>návrat z&nbsp;přerušení atd. (obnovení SR a PC ze zásobníku)</td></tr>
<tr><td>SLEEP </td><td>přepnutí do stavu sleep (pouze u mikrořadičů SH-2)</td></tr>
<tr><td>TRAPA </td><td>příprava zásobníkového rámce, skok na adresu VBR+konstanta</td></tr>
<tr><td><strong>LDTLB</strong></td><td>registry PTEH a PTEL se uloží do TLB (translation lookaside buffer)</td></tr>
<tr><td><strong>MOVCA.L R0,@Rn</strong></td><td>uložení registru R0 do paměti, ovšem bez načtení bloku z&nbsp;paměti, když není v&nbsp;cache</td></tr>
<tr><td><strong>OCBI @Rn</strong></td><td>invalidace bloku v&nbsp;cache (vynuluje bit V)</td></tr>
<tr><td><strong>OCBP @Rn</strong></td><td>zápis+invalidace bloku v&nbsp;cache</td></tr>
<tr><td><strong>OCBWB @Rn</strong></td><td>vynucení zápisu bloku z&nbsp;cache do paměti</td></tr>
<tr><td><strong>PREFI @Rn</strong></td><td>načtení bloku (32 bajtů) do instrukční cache</td></tr>
</table>



<p><a name="k06"></a></p>
<h2 id="k06">6. Instrukce pro SH-2A, které nejsou podporovány v&nbsp;jádru SH-4</h2>

<p><a href="#k05">V&nbsp;páté kapitole</a> jsme si řekli, že instrukční sada
SH-4 se přesně nepřekrývá s&nbsp;již popsanou instrukční sadou SH-2A. Konkrétně
to znamená, že na SH-4 nenajdeme následující instrukce, které se týkají práce
s&nbsp;bankami registrů (ty jsou řešeny odlišným způsobem) a především pak
operací Booleovského procesoru (bitové operace):</p>

<table>
<tr><th>Zkratka</th><th>Popis</th></tr>
<tr><td>MOVI20 </td><td>přenos konstanty o šířce 20 bitů do registru Rn</td></tr>
<tr><td>MOVI20S</td><td>dtto, ale konstanta je posunuta o osm bitů doleva</td></tr>
<tr><td>&nbsp;</td><td>&nbsp;</td></tr>
<tr><td>MOVML.L Rm,@-R15</td><td>zápis registrů R0..Rm do paměti adresované R15</td></tr>
<tr><td>MOVML.L @R15+,Rn</td><td>přečtení registrů R0..Rn z paměti adresované R15</td></tr>
<tr><td>MOVMU.L Rm,@-R15</td><td>zápis PR a registrů Rn..R14 do paměti adresované R15</td></tr>
<tr><td>MOVMU.L @R15+,Rn</td><td>přečtení registrů PR a Rn..R14 z paměti adresované R15</td></tr>
<tr><td>&nbsp;</td><td>&nbsp;</td></tr>
<tr><td>RESBANK</td><td>přepnutí banky registrů a tím pádem přepsání všech 19 výše zmíněných registrů</td></tr>
<tr><td>STBANK</td><td>uložení registru R0 do vybrané banky registrů</td></tr>
<tr><td>LDBANK</td><td>načtení registru R0 z&nbsp;vybrané banky registrů</td></tr>
<tr><td>&nbsp;</td><td>&nbsp;</td></tr>
<tr><td>BCLR</td><td>vynulování i-tého bitu registru Rn</td></tr>
<tr><td>BSET</td><td>nastavení i-tého bitu registru Rn (na 1)</td></tr>
<tr><td>BLD</td><td>přenos i-tého bitu registru Rn do příznakového bitu <strong>T</strong></td></tr>
<tr><td>BST</td><td>přenos příznakového bitu <strong>T</strong> do i-tého bitu registru Rn</td></tr>
<tr><td>BCLR.B</td><td>uložení 0 na i-tý bit na adrese (disp + Rn))</td></tr>
<tr><td>BSET.B</td><td>uložení 1 na i-tý bit na adrese (disp + Rn))</td></tr>
<tr><td>BLD.B</td><td>načtení i-tého bitu z&nbsp;adresy (disp + Rn) a uložení do T</td></tr>
<tr><td>BLDNOT.B</td><td>negace předchozího výpočtu</td></tr>
<tr><td>BST.B</td><td>uložení T do i-tého bitu na adrese (disp + Rn)</td></tr>
<tr><td>BAND.B</td><td>(i-tý bit z&nbsp;adresy (disp + Rn)) &and; T &rarr; T</td></tr>
<tr><td>BANDNOT.B</td><td>negace předchozího výpočtu</td></tr>
<tr><td>BOR.B</td><td>(i-tý bit z&nbsp;adresy (disp + Rn)) | T &rarr; T</td></tr>
<tr><td>BORNOT.B</td><td>negace předchozího výpočtu</td></tr>
<tr><td>BXOR.B</td><td>(i-tý bit z&nbsp;adresy (disp + Rn)) &oplus; T &rarr; T</td></tr>
<tr><td>&nbsp;</td><td>&nbsp;</td></tr>
<tr><td>CLIPS.B Rn</td><td>když Rn &gt; 127, zapiš do Rn 127 a nastav CS<br>totéž pro podmínku Rn &lt; -128</td></tr>
<tr><td>CLIPS.W Rn</td><td>když Rn &gt; 32767, zapiš do Rn 127 a nastav CS<br>totéž pro podmínku Rn &lt; -32768</td></tr>
<tr><td>CLIPU.B Rn</td><td>když Rn &gt; 255, zapiš do Rn 255 a nastav CS</td></tr>
<tr><td>CLIPU.W Rn</td><td>když Rn &gt; 65535, zapiš do Rn 65535 a nastav CS</td></tr>
<tr><td>&nbsp;</td><td>&nbsp;</td></tr>
<tr><td>MULR</td><td>operace Rn &times; R0 &rarr; Rn</td></tr>
<tr><td>DIVU</td><td>operace Rn &div; R0 &rarr; Rn (hodnoty bez znaménka)</td></tr>
<tr><td>DIVS</td><td>operace Rn &div; R0 &rarr; Rn (hodnoty se znaménkem)</td></tr>
<tr><td>&nbsp;</td><td>&nbsp;</td></tr>
<tr><td>MOVRT</td><td>přenos negovaného bitu <strong>T</strong> do vybraného registru Rn</td></tr>
<tr><td>NOTT</td><td>negace stavového bitu; <strong>T=~T</strong></td></tr>
<tr><td>&nbsp;</td><td>&nbsp;</td></tr>
<tr><td>JSR/N</td><td>skok do subrutiny (ovšem bez branch delay slotu)</td></tr>
<tr><td>RTS/N</td><td>návrat ze subrutiny (opět bez branch delay slotu)</td></tr>
<tr><td>RTV/N</td><td>uložení vybraného registru do R0 a návrat ze subrutiny (opět bez branch delay slotu)</td></tr>
</table>



<p><a name="k07"></a></p>
<h2 id="k07">7. Jádra SH-4A</h2>

<p>Architektura <i>SH-4A</i> by se sice podle svého jména měla podobat
architektuře <i>SH-4</i>, ve skutečnosti se ovšem vnitřní uspořádání procesoru
v&nbsp;některých ohledech odlišuje. Poznáme to například <a href="#k08">při
pohledu na pipeline</a>, která již nemá pouhých pět řezů, ale řezů osm. To na
jednu stranu sice znamená, že doba trvání jedné instrukce je delší (pokud
počítáme strojové cykly a nikoli nutně reálný čas), na stranu druhou je však
možné současně vykonávat větší množství instrukcí; navíc jsou jednotlivé řezy
provedeny za kratší dobu (jsou jednodušší). Pravděpodobně důležitější je však
vylepšení superskalární architektury a zavedení forwardingu do pipeline (tím se
zmenší počet případných konfliktů).</p>



<p><a name="k08"></a></p>
<h2 id="k08">8. Pipeline použité v&nbsp;architektuře SH-4A</h2>

<p>Základní pipeline procesoru s&nbsp;jádry SH-4A vypadá následovně:</p>

<pre>
+----+----+----+----+----+----+----+----+
| I1 | I2 | I3 | ID | E1 | E2 | E3 | WB |
+----+----+----+----+----+----+----+----+
</pre>

<p>První dvě fáze <strong>I1</strong> a <strong>I2</strong> provádí načtení
instrukce, ve fázích <strong>I3</strong> a <strong>ID</strong> dochází
k&nbsp;dekódování instrukce a ke čtení vybraného registru/registrů (například
do latche ALU). Pro instrukce typu load a store se ve fázi <strong>E1</strong>
vypočte adresa a ve fázích <strong>E2+E3</strong> se přistupuje k&nbsp;operační
paměti (čtení či zápis). Pokud se však jedná o ALU operace, provádí se ve
fázích <strong>E2+E3</strong> výpočty a fáze <strong>E1</strong> je rezervována
pro případný <a
href="https://en.wikipedia.org/wiki/Pipeline_forwarding">forwarding</a> (to je
na těchto jádrech užitečná novinka!).</p>



<p><a name="k09"></a></p>
<h2 id="k09">9. Pipeline pro FPU operace</h2>

<p>Pipeline určená pro FPU operace má minimálně devět řezů:</p>

<pre>
+----+----+----+----+----+----+----+----+----+
| I1 | I2 | I3 | ID | FS1| FS2| FS3| FS4| FS |
+----+----+----+----+----+----+----+----+----+
</pre>

<p>Rozdílem oproti předchozí konfiguraci pipeline je, že čtení pracovních
registrů se provádí až ve fázi <strong>FS1</strong> (nikoli
<strong>ID</strong>), současně je možné v&nbsp;téže fázi provést forwarding.
Fáze <strong>FS2-FS4</strong> slouží pro vlastní výpočet.</p>

<p>Složitější instrukce (kromě <strong>FDIV</strong> či <strong>FSQRT</strong>)
mají pipeline ještě delší:</p>

<pre>
+----+----+----+----+----+----+----+----+----+----+----+
| I1 | I2 | I3 | ID | FS1| FS2| FS3| FS4| FS5| FS6| FS |
+----+----+----+----+----+----+----+----+----+----+----+
</pre>

<p>Opět platí, že několik instrukcí, zejména pak <strong>FDIV</strong> a
<strong>FSQRT</strong>, trvají ještě delší dobu</p>



<p><a name="k10"></a></p>
<h2 id="k10">10. Instrukce matematického koprocesoru určené pro urychlení grafických operací</h2>

<p>Matematický koprocesor kromě základních instrukcí podporuje i čtyři (SH-4)
či dokonce sedm (SH-4A) nových instrukcí, které jsou určeny pro urychlení
některých grafických operací. Jedná se o následující instrukce:</p>

<table>
<tr><th>Zkratka</th><th>Jádro</th><th>Popis</th></tr>
<tr><td><strong>FIPR</strong></td><td>SH-4</td><td>výpočet skalárního součinu popř.&nbsp;součtu čtverců prvků vektorů</td></tr>
<tr><td><strong>FTRV</strong></td><td>SH-4</td><td>příprava pro maticové násobení či vynásobení matice vektorem (čtyřprvkovým)</td></tr>
<tr><td><strong>FSRRA</strong></td><td>SH-4A</td><td>výpočet hodnoty 1/sqrt(FR)</td></tr>
<tr><td><strong>FSCA</strong></td><td>SH-4A</td><td>FRn=sin(FPUL), FRn+1=cos(FPUL)</td></tr>
<tr><td><strong>FRCHG</strong></td><td>SH-4</td><td>negace bitu FPSCR.FR</td></tr>
<tr><td><strong>FSCHG</strong></td><td>SH-4</td><td>negace bitu FPSCR.SZ</td></tr>
<tr><td><strong>FPCHG</strong></td><td>SH-4A</td><td>negace bitu FPSCR.PR</td></tr>
</table>

<p>Užitečná je především první operace <strong>FIPR</strong>, protože ji lze
použít jak na výpočet délky vektoru (oba vstupní vektory jsou shodné), tak i
pro operace s&nbsp;polygony atd. Pro první účel, pokud je tedy skutečně nutné
vypočítat délku vektoru, se může použít kombinace instrukcí
<strong>FIPR+FSRRA</strong>. Zajímavá instrukce <strong>FSCA</strong> se
používá například při výpočtu rotací, konkrétně při vyplňování transformační
matice rotace. Operace <strong>FTRV</strong> sice neprovádí přímo maticové
násobení, ale připravuje (extrahuje) prvky z&nbsp;matice 4&times;4 do
vektoru.</p>

<p>Poslední čtyři instrukce lze použít pro rychlé přepínání režimu koprocesoru,
protože bit <strong>FPSCR.FR</strong> přepíná banku registrů, bit
<strong>FPSCR.ZF</strong> určuje, zda se budou přenášet hodnoty single či
double a konečně bit <strong>FPSCR.PR</strong> přepíná režim výpočtů
(single/double).</p>

<p>Pro maticové operace byla sada pracovních registrů rozšířena o nových
šestnáct registrů pojmenovaných XF0 až XF15, které tvoří matici XMTRX o
velikosti 4&times;4 prvky. Bitem <strong>FPSRC.FR</strong> je možné přepnutí
mezi původními pracovními registry a &bdquo;maticovými registry&ldquo;, o
&bdquo;projekci&ldquo; čtyř prvků z&nbsp;matice se postará již zmíněná operace
<strong>FTRV</strong>.</p>



<p><a name="k11"></a></p>
<h2 id="k11">11. Obsah následující části seriálu</h2>

<p>V&nbsp;navazujícím článku se budeme zabývat popisem dalších čipů, které byly
v&nbsp;minulosti navrženy a vyráběny společností Hitachi, ovšem dnes je
prakticky celý tento segment vlastněn firmou Renesas Technology. Bude se jednat
o čipy patřící do rodiny nazvané H8, která zahrnuje osmibitové, šestnáctibitové
a dokonce i 32bitové mikrořadiče. Tyto čipy se však &ndash; i přes poněkud
podobný název s&nbsp;řadou SuperH &ndash; v&nbsp;mnoha podstatných věcech
odlišují. Týká se to jak jejich vnitřního uspořádání (pipeline, velikost sady
pracovních registrů, podpora či naopak nepodpora superkalárního zpracování,
podpora pro branch delay sloty apod.), tak i instrukční sady, která je u řady
H8 v&nbsp;některých ohledech inspirována <a
href="https://en.wikipedia.org/wiki/Orthogonal_instruction_set">ortogonálními</a>
(tedy de facto neRISCovými) instrukčními sadami počítačů DEC PDP-11.</p>

<p>Poznámka: teoreticky by bylo možné pokračovat popisem architektury SH-5, což
je/byl (další) poměrně neúspěšný pokus o vytvoření 64bitového RISCového
procesoru, ovšem tato architektura není podporována v&nbsp;reálných čipech ani
v&nbsp;překladačích.</p>



<p><a name="k12"></a></p>
<h2 id="k12">12. Odkazy na Internetu</h2>

<ol>

<li>Renesas SH Instruction Set Summary<br />
<a href="http://shared-ptr.com/sh_insns.html">http://shared-ptr.com/sh_insns.html</a>
</li>

<li>SH-4 RISC Processor by HITACHI<br />
<a href="http://www.cs.umd.edu/~meesh/cmsc411/website/projects/risc/risc.htm">http://www.cs.umd.edu/~meesh/cmsc411/website/projects/risc/risc.htm</a>
</li>

<li>SH-4 RISC Processor<br />
<a href="http://www.cs.umd.edu/~meesh/cmsc411/website/projects/risc/sh-4.htm">http://www.cs.umd.edu/~meesh/cmsc411/website/projects/risc/sh-4.htm</a>
</li>

<li>Superscalar processor (Wikipedia)<br />
<a href="https://en.wikipedia.org/wiki/Superscalar_processor">https://en.wikipedia.org/wiki/Superscalar_processor</a>
</li>

<li>Category:Parallel computing (Wikipedia)<br />
<a href="https://en.wikipedia.org/wiki/Category:Parallel_computing">https://en.wikipedia.org/wiki/Category:Parallel_computing</a>
</li>

<li>SH7750R<br />
<a href="https://www.renesas.com/en-us/document/hw-manual?hwLayerShowFlg=true&prdLayerId=1060&layerName=SH7750R&coronrService=document-prd-search&hwDocUrl=%2Fen-us%2Fdoc%2Fproducts%2Fmpumcu%2F001%2Fr01uh0456ej0702_sh7750.pdf&hashKey=fb85df425a5b14b0b3c982f71d0ac1c7">https://www.renesas.com/en-us/document/hw-manual?hwLayerShowFlg=true&prdLayerId=1060&layerName=SH7750R&coronrService=document-prd-search&hwDocUrl=%2Fen-us%2Fdoc%2Fproducts%2Fmpumcu%2F001%2Fr01uh0456ej0702_sh7750.pdf&hashKey=fb85df425a5b14b0b3c982f71d0ac1c7</a>
</li>

<li>SH7201 Group User's Manual: Hardware<br />
<a href="https://www.renesas.com/en-us/document/hw-manual?hwLayerShowFlg=true&amp;prdLayerId=2038&amp;layerName=SH7201&amp;coronrService=document-prd-search&amp;hwDocUrl=%2Fen-us%2Fdoc%2Fproducts%2Fmpumcu%2Fdoc%2Fsuperh%2Fr01uh0026ej_sh7201_hm.pdf&amp;hashKey=4d1ed116961466babf99bc7cf1d2cdec">https://www.renesas.com/en-us/document/hw-manual?hwLayerShowFlg=true&amp;prdLayerId=2038&amp;layerName=SH7201&amp;coronrService=document-prd-search&amp;hwDocUrl=%2Fen-us%2Fdoc%2Fproducts%2Fmpumcu%2Fdoc%2Fsuperh%2Fr01uh0026ej_sh7201_hm.pdf&amp;hashKey=4d1ed116961466babf99bc7cf1d2cdec</a>
</li>

<li>SH7203 Group User's Manual: Hardware<br />
<a href="https://www.renesas.com/en-us/document/hw-manual?hwLayerShowFlg=true&amp;prdLayerId=2126&amp;layerName=SH7203&amp;coronrService=document-prd-search&amp;hwDocUrl=%2Fen-us%2Fdoc%2Fproducts%2Fmpumcu%2F001%2Fr01uh0458ej0400_sh7203.pdf&amp;hashKey=68baf3ad6c52e9e2616e44024589e8cf">https://www.renesas.com/en-us/document/hw-manual?hwLayerShowFlg=true&amp;prdLayerId=2126&amp;layerName=SH7203&amp;coronrService=document-prd-search&amp;hwDocUrl=%2Fen-us%2Fdoc%2Fproducts%2Fmpumcu%2F001%2Fr01uh0458ej0400_sh7203.pdf&amp;hashKey=68baf3ad6c52e9e2616e44024589e8cf</a>
</li>

<li>SuperH RISC engine Family Features<br />
<a href="https://www.renesas.com/en-us/products/microcontrollers-microprocessors/superh/superh-features.html">https://www.renesas.com/en-us/products/microcontrollers-microprocessors/superh/superh-features.html</a>
</li>

<li>Orthogonal instruction set<br />
<a href="https://en.wikipedia.org/wiki/Orthogonal_instruction_set">https://en.wikipedia.org/wiki/Orthogonal_instruction_set</a>
</li>

<li>Konkurence procesorů s mikroprogramovým řadičem - RISC<br />
<a href="http://www.root.cz/clanky/konkurence-procesoru-s-mikroprogramovym-radicem-architektura-risc/">http://www.root.cz/clanky/konkurence-procesoru-s-mikroprogramovym-radicem-architektura-risc/</a>
</li>

<li>Mikroprocesory s architekturou RISC I<br />
<a href="http://www.root.cz/clanky/mikroprocesory-s-architekturou-risc-i/">http://www.root.cz/clanky/mikroprocesory-s-architekturou-risc-i/</a>
</li>

<li>Procesory RISC v pracovních stanicích a serverech<br />
<a href="http://www.root.cz/clanky/procesory-s-architekturou-risc-v-pracovnich-stanicich-a-serverech/">http://www.root.cz/clanky/procesory-s-architekturou-risc-v-pracovnich-stanicich-a-serverech/</a>
</li>

<li>Procesory RISC v pracovních stanicích a serverech - architektura SPARC V8 a<br />
<a href="http://www.root.cz/clanky/procesory-risc-v-pracovnich-stanicich-a-serverech-architektura-sparc-v8-a-v9/">http://www.root.cz/clanky/procesory-risc-v-pracovnich-stanicich-a-serverech-architektura-sparc-v8-a-v9/</a>
</li>

<li>Procesory RISC v pracovních stanicích a serverech - architektura PA-RISC<br />
<a href="http://www.root.cz/clanky/procesory-risc-v-pracovnich-stanicich-a-serverech-architektura-pa-risc/">http://www.root.cz/clanky/procesory-risc-v-pracovnich-stanicich-a-serverech-architektura-pa-risc/</a>
</li>

<li>Rozšíření instrukční sady procesorových jader s otevřenou architekturou RISC-V<br />
<a href="http://www.root.cz/clanky/rozsireni-instrukcni-sady-procesorovych-jader-s-otevrenou-architekturou-risc-v/">http://www.root.cz/clanky/rozsireni-instrukcni-sady-procesorovych-jader-s-otevrenou-architekturou-risc-v/</a>
</li>

<li>Sega documentation<br />
<a
href="http://koti.kapsi.fi/~antime/sega/docs.html">http://koti.kapsi.fi/~antime/sega/docs.html</a>
</li>

<li>1995 Programming on the Sega Saturn<br />
<a
href="http://cowboyprogramming.com/2010/06/03/1995-programming-on-the-sega-saturn/">http://cowboyprogramming.com/2010/06/03/1995-programming-on-the-sega-saturn/</a>
</li>

<li>Sega Myths-Saturn was the most difficult console to program for of 5th Gen<br />
<a href="http://forums.sega.com/showthread.php?313485-Sega-Myths-Saturn-was-the-most-difficult-console-to-program-for-of-5th-Gen">http://forums.sega.com/showthread.php?313485-Sega-Myths-Saturn-was-the-most-difficult-console-to-program-for-of-5th-Gen</a>
</li>

<li>SuperH RISC engine Family<br />
<a href="http://www.renesas.com/products/mpumcu/superh/index.jsp">http://www.renesas.com/products/mpumcu/superh/index.jsp</a>
</li>

<li>Sega Saturn<br />
<a href="http://en.wikipedia.org/wiki/Sega_saturn">http://en.wikipedia.org/wiki/Sega_saturn</a>
</li>

<li>Fourth-Generation Consoles<br />
<a href="http://gaming.wikia.com/wiki/Fourth-Generation_Consoles">http://gaming.wikia.com/wiki/Fourth-Generation_Consoles</a>
</li>

<li>Fifth-Generation Consoles<br />
<a href="http://gaming.wikia.com/wiki/Fifth-Generation_Consoles">http://gaming.wikia.com/wiki/Fifth-Generation_Consoles</a>
</li>

<li>History of video game consoles (fifth generation)<br />
<a href="http://en.wikipedia.org/wiki/History_of_video_game_consoles_(fifth_generation)">http://en.wikipedia.org/wiki/History_of_video_game_consoles_(fifth_generation)</a>
</li>

<li>Sega Mega Drive<br />
<a href="http://sega.jp/archive/segahard/md/">http://sega.jp/archive/segahard/md/</a>
</li>

<li>Sega Archives<br />
<a href="http://sega.jp/archive/segahard/">http://sega.jp/archive/segahard/</a>
</li>

<li>Sega Genesis<br />
<a href="http://www.dmoz.org/Games/Video_Games/Console_Platforms/Sega/Genesis/">http://www.dmoz.org/Games/Video_Games/Console_Platforms/Sega/Genesis/</a>
</li>

<li>The Sega Mega Drive/Genesis<br />
<a href="http://www.captainwilliams.co.uk/sega/megadrive/megadrive.php">http://www.captainwilliams.co.uk/sega/megadrive/megadrive.php</a>
</li>

<li>Sega Master System Museum<br />
<a href="http://alexkidd.com/">http://alexkidd.com/</a>
</li>

<li>Jadeite's Sega Master System Museum<br />
<a href="http://rp_gamer.tripod.com/SMS/1.html">http://rp_gamer.tripod.com/SMS/1.html</a>
</li>

<li>Sega Master System (Wikipedia)<br />
<a href="http://en.wikipedia.org/wiki/Sega_Master_System">http://en.wikipedia.org/wiki/Sega_Master_System</a>
</li>

<li>Sega Card (Wikipedia)<br />
<a href="http://en.wikipedia.org/wiki/Sega_Card">http://en.wikipedia.org/wiki/Sega_Card</a>
</li>

<li>Sega Master System VDP documentation<br />
<a href="http://www.smspower.org/uploads/Development/msvdp-20021112.txt?sid=28c370e1fcac51d5774319979bf96f4c">http://www.smspower.org/uploads/Development/msvdp-20021112.txt?sid=28c370e1fcac51d5774319979bf96f4c</a>
</li>

<li>The16bit Era Of Console Video Games<br />
<a href="http://tvtropes.org/pmwiki/pmwiki.php/Main/The16bitEraOfConsoleVideoGames">http://tvtropes.org/pmwiki/pmwiki.php/Main/The16bitEraOfConsoleVideoGames</a>
</li>

<li>The Console Wars<br />
<a href="http://www.cracked.com/funny-2590-the-console-wars/">http://www.cracked.com/funny-2590-the-console-wars/</a>
</li>

<li>Console Wars<br />
<a href="http://tvtropes.org/pmwiki/pmwiki.php/Main/ConsoleWars">http://tvtropes.org/pmwiki/pmwiki.php/Main/ConsoleWars</a>
</li>

<li>Era of the "Bit Wars"<br />
<a href="http://www.gtplanet.net/forum/threads/era-of-the-bit-wars.119796/">http://www.gtplanet.net/forum/threads/era-of-the-bit-wars.119796/</a>
</li>

<li>Rez Wars: How the Bit Wars never really ended<br />
<a href="http://www.ign.com/blogs/beastmastertoad/2013/01/31/rez-wars-how-the-bit-wars-never-really-ended">http://www.ign.com/blogs/beastmastertoad/2013/01/31/rez-wars-how-the-bit-wars-never-really-ended</a>
</li>

<li>Which system ended the "Bit Wars"?<br />
<a href="http://atariage.com/forums/topic/199163-which-system-ended-the-bit-wars/">http://atariage.com/forums/topic/199163-which-system-ended-the-bit-wars/</a>
</li>

<li>Status Register<br />
<a href="https://en.wikipedia.org/wiki/Status_register">https://en.wikipedia.org/wiki/Status_register</a>
</li>

<li>Introduction to ARM Thumb<br />
<a href="http://www.embedded.com/electronics-blogs/beginner-s-corner/4024632/Introduction-to-ARM-thumb">http://www.embedded.com/electronics-blogs/beginner-s-corner/4024632/Introduction-to-ARM-thumb</a>
</li>

<li>Code Size – a comprehensive comparison of microMIPS32 and Thumb code size using many Megabytes of customer code<br />
<a href="https://community.arm.com/groups/processors/blog/2014/04/28/code-size-a-comprehensive-comparison-of-micromips32-and-thumb-code-size-using-many-megabytes-of-customer-code">https://community.arm.com/groups/processors/blog/2014/04/28/code-size-a-comprehensive-comparison-of-micromips32-and-thumb-code-size-using-many-megabytes-of-customer-code</a>
</li>

<li>MIPS MCUs Outrun ARM<br />
<a href="http://www.linleygroup.com/newsletters/newsletter_detail.php?num=5117">http://www.linleygroup.com/newsletters/newsletter_detail.php?num=5117</a>
</li>

<li>Carry bits, The Architect's Trap<br />
<a href="http://yarchive.net/comp/carry_bit.html">http://yarchive.net/comp/carry_bit.html</a>
</li>

<li>Microprocessor Design/ALU Flags<br />
<a href="https://en.wikibooks.org/wiki/Microprocessor_Design/ALU_Flags">https://en.wikibooks.org/wiki/Microprocessor_Design/ALU_Flags</a>
</li>

<li>Flags register in an out-of-order processor<br />
<a href="http://cs.stackexchange.com/questions/42095/flags-register-in-an-out-of-order-processor">http://cs.stackexchange.com/questions/42095/flags-register-in-an-out-of-order-processor</a>
</li>

<li>Berkeley RISC<br />
<a href="http://en.wikipedia.org/wiki/Berkeley_RISC">http://en.wikipedia.org/wiki/Berkeley_RISC</a>
</li>

<li>Great moments in microprocessor history<br />
<a href="http://www.ibm.com/developerworks/library/pa-microhist.html">http://www.ibm.com/developerworks/library/pa-microhist.html</a>
</li>

<li>RISC vs. CISC<br />
<a href="http://www-cs-faculty.stanford.edu/~eroberts/courses/soco/projects/2000-01/risc/risccisc/">http://www-cs-faculty.stanford.edu/~eroberts/courses/soco/projects/2000-01/risc/risccisc/</a>
</li>

<li>RISC and CISC definitions:<br />
<a href="http://www.cpushack.com/CPU/cpuAppendA.html">http://www.cpushack.com/CPU/cpuAppendA.html</a>
</li>

<li>The Evolution of RISC<br />
<a href="http://www.ibm.com/developerworks/library/pa-microhist.html#sidebar1">http://www.ibm.com/developerworks/library/pa-microhist.html#sidebar1</a>
</li>

<li>The VFP architecture<br />
<a href="http://infocenter.arm.com/help/index.jsp?topic=/com.arm.doc.dui0056d/Bcfibfha.html">http://infocenter.arm.com/help/index.jsp?topic=/com.arm.doc.dui0056d/Bcfibfha.html</a>
</li>

<li>NEON<br />
<a href="http://www.arm.com/products/processors/technologies/neon.php">http://www.arm.com/products/processors/technologies/neon.php</a>
</li>

<li>ARM Floating Point Accelerator (ARM FPA)<br />
<a href="http://vswww.kaist.ac.kr/ver4.0/index.php/research/past-research/arm-fpa.html">http://vswww.kaist.ac.kr/ver4.0/index.php/research/past-research/arm-fpa.html</a>
</li>

</ol>



<p></p><p></p>
<p><small>Autor: <a href="http://www.fit.vutbr.cz/~tisnovpa">Pavel Tišnovský</a> &nbsp; 2016</small></p>
</body>
</html>

