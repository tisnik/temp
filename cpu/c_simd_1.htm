<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
        "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html>
<head>
<title>Užitečné rozšíření GCC - podpora SIMD (vektorových) instrukcí</title>
<meta name="Author" content="Pavel Tisnovsky" />
<meta name="Generator" content="vim" />
<meta http-equiv="content-type" content="text/html; charset=utf-8" />
<style type="text/css">
         body {color:#000000; background:#ffffff;}
         h1  {font-family: arial, helvetica, sans-serif; color:#ffffff; background-color:#c00000; text-align:center; padding-left:1em}
         h2  {font-family: arial, helvetica, sans-serif; color:#ffffff; background-color:#0000c0; padding-left:1em; text-align:left}
         h3  {font-family: arial, helvetica, sans-serif; color:#000000; background-color:#c0c0c0; padding-left:1em; text-align:left}
         h4  {font-family: arial, helvetica, sans-serif; color:#000000; background-color:#e0e0e0; padding-left:1em; text-align:left}
         a   {font-family: arial, helvetica, sans-serif;}
         li  {font-family: arial, helvetica, sans-serif; color:#000000; text-align:justify; width:450px;}
         ol  {font-family: arial, helvetica, sans-serif; color:#000000; text-align:justify; width:450px;}
         ul  {font-family: arial, helvetica, sans-serif; color:#000000; text-align:justify; width:450px;}
         p   {font-family: arial, helvetica, sans-serif; color:#000000; text-align:justify;}
         pre {background:#e0e0e0}
</style>
</head>

<body>

<h1>Užitečné rozšíření GCC - podpora SIMD (vektorových) instrukcí</h1>

<h3>Pavel Tišnovský</h3>

<p></p>

<h1>Úvodník</h1>

<p></p>



<h2>Obsah</h2>

<p><a href="#k01">*** 1. Nepřímý důsledek Moorova zákona &ndash; SIMD instrukce</a></p>
<p><a href="#k02">*** 2. Od klasické von Neumannovy architektury k&nbsp;paralelním výpočtům</a></p>
<p><a href="#k03">*** 3. Architektura x86-64 s&nbsp;nepřeberným množstvím skupin SIMD instrukcí</a></p>
<p><a href="#k04">*** 4. Instrukční sada MMX: první pokus o použití SIMD na platformě x86</a></p>
<p><a href="#k05">*** 5. Registry MMX, vztah ke standardnímu matematickému koprocesoru</a></p>
<p><a href="#k06">*** 6. SIMD instrukce v&nbsp;instrukční sadě 3DNow!</a></p>
<p><a href="#k07">*** 7. Registry používané v&nbsp;rozšíření 3DNow!</a></p>
<p><a href="#k08">*** 8. Nové SIMD instrukce v&nbsp;rozšíření 3DNow!</a></p>
<p><a href="#k09">*** 9. SIMD instrukce v&nbsp;rozšíření SSE</a></p>
<p><a href="#k10">*** 10. </a></p>
<p><a href="#k11">*** 11. </a></p>
<p><a href="#k12">*** 12. </a></p>
<p><a href="#k13">*** 13. </a></p>
<p><a href="#k14">*** 14. </a></p>
<p><a href="#k15">*** 15. </a></p>
<p><a href="#k16">*** 16. </a></p>
<p><a href="#k17">*** 17. </a></p>
<p><a href="#k18">*** 18. </a></p>
<p><a href="#k19">*** 19. Repositář s&nbsp;demonstračními příklady</a></p>
<p><a href="#k20">*** 20. Odkazy na Internetu</a></p>



<p><a name="k01"></a></p>
<h2 id="k01">1. Nepřímý důsledek Moorova zákona &ndash; SIMD instrukce</h2>

<p><i>"...sequential computers are approaching a fundamental physical limit on
their potential power. Such a limit is the speed of light..."</i></p>

<p>V&nbsp;dnešním článku si ukážeme, jakým způsobem je možné v&nbsp;GCC (přesněji v&nbsp;překladači C z&nbsp;rodiny překladačů GCC) používat SIMD instrukce, které jsou zde souhrnně nazývány <i>vektorové instrukce</i>. Přitom SIMD/vektorové instrukce dnes patří ke standardní výbavě prakticky všech moderních mikroprocesorů. Připomeňme si, že z&nbsp;hlediska dosahovaného výpočetního výkonu leží na samém &bdquo;výkonnostním dně&ldquo; klasické mikroprocesory s&nbsp;architekturou <i>CISC</i>, které vykonávají všechny instrukce postupně a dokončení jedné instrukce může v&nbsp;závislosti na jejich složitosti trvat i několik desítek strojových taktů. Předností těchto procesorů může být poměrně velká informační hustota instrukční sady (například i díky tomu, že operandy některých instrukcí jsou zadány implicitně), což mj.&nbsp;znamená, že se procesory tohoto typu po poměrně dlouhou dobu obešly bez nutnosti využití drahých vyrovnávacích pamětí první a druhé úrovně (<i>L1 cache</i>, <i>L2 cache</i>). Klasické procesory s&nbsp;architekturou <i>CISC</i> byly založeny na mikroprogramovém řadiči vybaveném pamětí mikroinstrukcí a teprve později začaly být tyto procesory doplňovány technologiemi získanými z&nbsp;jiných architektur &ndash; instrukční pipeline, prediktorem skoků, vektorovými instrukcemi atd.</p>

<img src="http://i.iinfo.cz/images/311/pc158-1.png" width="450" height="310" alt="&#160;" />
<p><i>Obrázek 1: Ukázka časování instrukce ADC (Add with carry) osmibitového mikroprocesoru MOS 6502 s&nbsp;architekturou CISC. V&nbsp;závislosti na zvoleném adresním režimu se liší počty strojových cyklů od dvou do šesti. Liší se samozřejmě i počet bajtů nutných pro zakódování instrukce, protože některé adresní režimy vyžadují zápis absolutní 16bitové adresy a jiné režimy používají jen 8bitový offset, popř.&nbsp;osmibitovou adresu v&nbsp;rámci takzvané nulté stránky (zero page).</i></p>

<p>Výpočetní výkon mikroprocesorů se podařilo poměrně výrazným způsobem zvýšit u architektury <i>RISC</i> s&nbsp;instrukční pipeline. Provedení jedné instrukce sice stále trvalo větší počet strojových cyklů, ovšem díky rozfázování operací v&nbsp;instrukční pipeline bylo umožněno překrývání většího množství instrukcí, a to bez nutnosti zavádění skutečné paralelizace (která vede k&nbsp;velkému nárůstu složitosti a tím i ceny čipu). Spolu se zavedením mikroprocesorů <i>RISC</i> se skutečně stalo, že reálný i špičkový výpočetní výkon procesorů vzrostl, ale relativně brzy bylo nutné k&nbsp;těmto čipům přidat vyrovnávací paměti (<i>cache</i>), jelikož rychlost procesorů rostla mnohem rychleji, než vybavovací doba pamětí. Tento rozpor mezi rychlostmi obou nejdůležitějších součástí moderních počítačů ostatně trvá dodnes. Pro další zvýšení výpočetního výkonu však bylo nutné použít další technologie, například minule zmíněnou instrukční sadu <i>VLIW</i>, která však &ndash; opět &ndash; měla velké nároky na rychlost pamětí. Podobně jako u procesorů <i>RISC</i>, i u <i>VLIW</i> bylo pro zmírnění požadavků na rychlost pamětí možné použít Harvardskou architekturu, tj.&nbsp;odděleni paměti programu od paměti dat (programová paměť navíc mohla mít větší šířku datové sběrnice odpovídající šířce instrukčních slov).</p>



<p><a name="k02"></a></p>
<h2 id="k02">2. Od klasické von Neumannovy architektury k&nbsp;paralelním výpočtům</h2>

<p>Všechny CISCové mikroprocesory firmy Intel řady <i>80x86</i>, od ještě z&nbsp;poloviny osmibitového čipu <i>Intel 8088</i> až po model <i>Intel 80486</i> (včetně) byly založeny na skalární architektuře <i>SISD</i>, stejně jako velké množství mikrořadičů či digitálních signálových procesorů (<i>DSP &ndash; Digital Signal Processor</i>). Nevýhodou systémů <strong>SISD</strong> ovšem je, že rychlost načítání a tím i zpracování instrukcí je shora omezena a že ani s&nbsp;využitím velmi dlouhé instrukční pipeline se nedá &ndash; vcelku logicky &ndash; překonat limit jedné zpracované instrukce za jeden takt. Příliš velké množství řezů (<i>slices</i>) pipeline má naopak i své zápory, především při zpracování skoků, návratů z&nbsp;podprogramů či odezvy na přerušení &ndash; ve všech těchto případech je nutné vyřešit problém, co se má udělat s&nbsp;instrukcemi, které se nachází v&nbsp;rozpracovaném stavu v&nbsp;pipeline (mohou se buď zahodit nebo naopak dokončit, podle toho, jakým způsobem byl lineární běh programu přerušen).</p>

<a href="http://i.iinfo.cz/images/311/pc158-5.png"><img src="http://i.iinfo.cz/images/311/pc158-5-prev.png" width="259" height="270" alt="&#160;" /></a>
<p><i>Obrázek 5: Schéma systému patřícího do kategorie SISD.</i></p>

<p>V&nbsp;současnosti se těší značné popularitě procesory patřící do kategorie <strong>SIMD</strong>, jejíž kořeny ovšem sahají hluboko do minulosti, konkrétně do šedesátých a sedmdesátých let minulého století (tato oblast výpočetní techniky je spojena se <i>Symourem Crayem</i> a jeho superpočítači).  Do této kategorie patří ty architektury procesorů, u kterých se pomocí jedné instrukce může zpracovat větší množství dat. Například u rozšířené instrukční sady <strong>MMX</strong> je možné pomocí jediné instrukce provést součet dvou vektorů číselných hodnot. Může se jednat o osm osmibitových hodnot uložených v&nbsp;jednom vektoru, čtyři šestnáctibitové hodnoty v&nbsp;jednom vektoru atd.  Této vlastnosti se dá v&nbsp;mnoha případech využít pro urychlení běhu programů, protože některé algoritmy (ve skutečnosti je těchto algoritmů možná až udivující počet) provádí velké množství stejných operací s&nbsp;rozsáhlým objemem dat &ndash; například se může jednat o aplikaci konvolučního filtru na rastrový obrázek, zpracování zvukového signálu, vynásobení matice vektorem, vynásobení dvou matic atd.</p>

<a href="http://i.iinfo.cz/images/311/pc158-7.png"><img src="http://i.iinfo.cz/images/311/pc158-7-prev.png" width="205" height="270" alt="&#160;" /></a>
<p><i>Obrázek 7: Schéma systému patřícího do kategorie SIMD.</i></p>

<p>Mezi přednosti čipů náležejících do kategorie <strong>SIMD</strong> patří jak relativně kompaktní instrukční sada, tak i paralelní a tím pádem i rychlý běh mnoha algoritmů, ovšem za cenu větších nároků kladených na programátora, popř.&nbsp;na překladač. Stále jen velmi malé množství programovacích jazyků totiž umožňuje explicitně vyjádřit vektorové či maticové operace (například u překladače Fortranu určeného pro superpočítače <i>Cray</i> bylo v&nbsp;manuálu explicitně řečeno, které jazykové konstrukce se budou skutečně provádět ve vektorové &ndash; <strong>SISD</strong> &ndash; jednotce). Z&nbsp;tohoto důvodu také není možné většinu <strong>SIMD</strong> konstrukcí zapsat v&nbsp;konvenčním vyšším programovacím jazyce: musí se použít buď hotová makra, ručně optimalizované knihovní funkce nebo specializované programovací jazyky.  Určitou, ale nezanedbatelnou výjimku představují <strong>GPU</strong> na grafických akcelerátorech, které explicitně pracují s&nbsp;2D a 3D vektory, přičemž programátor může předem zjistit, které operace budou skutečně provedeny paralelně.</p>

<a href="http://i.iinfo.cz/images/311/pc158-8.jpg"><img src="http://i.iinfo.cz/images/311/pc158-8-prev.jpg" width="370" height="155" alt="&#160;" /></a>
<p><i>Obrázek 8: Typy vektorů, s&nbsp;nimiž pracují instrukce MMX.</i></p>



<p><a name="k03"></a></p>
<h2 id="k03">3. Architektura x86-64 s&nbsp;nepřeberným množstvím skupin SIMD instrukcí</h2>

<p>Jak jsme se již několikrát zmínili v&nbsp;předchozích odstavcích, jsou v&nbsp;soudobých typech mikroprocesorů implementovány i některé vektorové instrukce (popravdě řečeno již celkový počet vektorových instrukcí pravděpodobně překročil počet instrukcí skalárních :-). Pokud prozatím zůstaneme u platformy <i>x86</i>, tak historicky první instrukční sadou (přesněji řečeno doplněním původní instrukční sady) s&nbsp;podporou vektorových operací byla sada instrukcí <strong>MMX</strong>, s&nbsp;níž přišla firma Intel. Tato sada sice umožňovala provádění vektorových operací, ale měla celou řadu omezení, především nízký počet &bdquo;vektorových&ldquo; registrů, které navíc měly malou bitovou šířku a z&nbsp;toho vycházející nízký počet prvků ve vektorech atd. Nevýhodné taktéž bylo, že se pro instrukce <strong>MMX</strong> používaly registry určené původně pro práci s&nbsp;matematickým koprocesorem (FPU), takže současné provádění FP operací a MMX operací bylo minimálně složité. Ovšem poměrně brzy po uvedení sady <strong>MMX</strong> se objevila konkurenční instrukční sada <strong>3Dnow!</strong> firmy AMD, která byla následovaná již zmíněnými sadami <strong>SSE</strong> až <strong>SSE5</strong>. Podrobnější informace o všech těchto instrukčních sadách si řekneme v&nbsp;navazující části tohoto miniseriálu.</p>

<img src="http://i.iinfo.cz/images/311/pc158-13.png" width="200" height="150" alt="&#160;" />
<p><i>Obrázek 15: Dnes již historický mikroprocesor AMD K6-2 implementující mj.&nbsp;i rozšíření instrukční sady nazvané poněkud zvláštně 3Dnow!</i></p>


<table>
<tr><th>Technologie</th><th>Rok uvedení</th><th>Společnost</th><th>Poprvé použito v&nbsp;čipu</th></tr>
<tr><td><a href="#k04">MMX</a></td><td>1996</td><td>Intel</td><td>Intel Pentium P5</td></tr>
<tr><td><a href="#k06">3DNow!</a></td><td>1998</td><td>AMD</td><td>AMD K6-2</td></tr>
<tr><td>SSE  </td><td>1999</td><td>Intel</td><td>Intel Pentium III (mikroarchitektura P6)</td></tr>
<tr><td>SSE2 </td><td>2001</td><td>Intel</td><td>Intel Pentium 4 (mikroarchitektura NetBurst)</td></tr>
<tr><td>SSE3 </td><td>2004</td><td>Intel</td><td>Intel Pentium 4 (Prescott)</td></tr>
<tr><td>SSSE3</td><td>2006</td><td>Intel</td><td>mikroarchitektura Intel Core</td></tr>
<tr><td>SSE4</td><td>2006</td><td>Intel+AMD</td><td>AMD K10 (SSE4a) , mikroarchitektura Intel Core</td></tr>
<tr><td>SSE5</td><td>2007</td><td>AMD</td><td>(nakonec rozděleno do menších celků), mikroarchitektura Bulldozer</td></tr>
<tr><td>AVX</td><td>2008</td><td>Intel</td><td>mikroarchitektura Sandy Bridge</td></tr>
<tr><td>F16C (CVT16)</td><td>2009</td><td>AMD</td><td>Jaguar, Puma, Bulldozer atd.</td></tr>
<tr><td>XOP </td><td>2009</td><td>AMD</td><td>mikroarchitektura Bulldozer</td></tr>
<tr><td>FMA3</td><td>2012</td><td>AMD</td><td>mikroarchitektura Piledriver, Intel: Haswell a Broadwell</td></tr>
<tr><td>FMA4</td><td>2011</td><td>AMD</td><td>mikroarchitektura Bulldozer (pozdější architektury po Zen 1 již ne)</td></tr>
<tr><td>AVX2</td><td>2013</td><td>Intel</td><td>mikroarchitektura Haswell</td></tr>
<tr><td>AVX-512</td><td>2013</td><td>Intel</td><td>Knights Landing</td></tr>
<tr><td>AMX</td><td>2020</td><td>Intel</td><td>Sapphire Rapids</td></tr>
</table>

<p></p>

<pre>
$ <strong>cat /proc/cpuinfo</strong>
</pre>

<pre>
flags           : fpu vme de pse tsc msr pae mce cx8 apic sep mtrr pge mca cmov
pat pse36 clflush dts acpi mmx fxsr sse sse2 ss ht tm pbe syscall nx pdpe1gb
rdtscp lm constant_tsc art arch_perfmon pebs bts rep_good nopl xtopology
nonstop_tsc cpuid aperfmperf pni pclmulqdq dtes64 monitor ds_cpl vmx smx est
tm2 ssse3 sdbg fma cx16 xtpr pdcm pcid sse4_1 sse4_2 x2apic movbe popcnt
tsc_deadline_timer aes xsave avx f16c rdrand lahf_lm abm 3dnowprefetch
cpuid_fault epb invpcid_single ssbd ibrs ibpb stibp ibrs_enhanced tpr_shadow
vnmi flexpriority ept vpid ept_ad fsgsbase tsc_adjust bmi1 avx2 smep bmi2 erms
invpcid mpx rdseed adx smap clflushopt intel_pt xsaveopt xsavec xgetbv1 xsaves
dtherm ida arat pln pts hwp hwp_notify hwp_act_window hwp_epp md_clear
flush_l1d arch_capabilities
</pre>

<p>Pro někoho může být taktéž zajímavá i informace o tom, jak velké změny v&nbsp;instrukční sadě mikroprocesorů byly vlastně při přidávání nových &bdquo;vektorových&ldquo; rozšiřujících instrukčních sad typu <i>SIMD</i> provedeny. To nám ukáže další tabulka. Je pouze nutné dát pozor na to, že počty nových instrukcí zavedených v&nbsp;rámci těchto nových technologií, které jsou vypsány v&nbsp;tabulce pod odstavcem, nemusí přesně souhlasit s&nbsp;počty uváděnými v&nbsp;jiných informačních materiálech. Je tomu tak především z&nbsp;toho důvodu, že se v&nbsp;některých případech rozlišuje i datový typ, s&nbsp;nímž instrukce pracují (například se může jednat o součet vektoru s&nbsp;32 bitovými hodnotami nebo 64bitovými hodnotami reprezentovanými v&nbsp;obou případech ve formátu s&nbsp;plovoucí řádovou čárkou) a někdy se taková instrukce do celkové sumy započítává pouze jedenkrát. Nicméně údaje vypsané v&nbsp;níže uvedené tabulce by měly být konzistentní, protože se jedná o počty nově přidaných operačních kódů instrukcí (například u dále popsané instrukční sady <i>SSE2</i> končí instrukce znakem <strong>D</strong>, <strong>S</strong>, <strong>I</strong> či <strong>Q</strong> podle typu zpracovávaných dat/operandů):</p>

<table>
<tr><th>Název technologie</th><th>Počet nových instrukcí</th></tr>
<tr><td>MMX</td><td> 56</td></tr>
<tr><td>3DNow!</td><td> 21</td></tr>
<tr><td>SSE</td><td> 70</td></tr>
<tr><td>SSE2</td><td>144</td></tr>
<tr><td>SSE3</td><td> 13</td></tr>
<tr><td>SSSE3</td><td> 32 (ve skutečnosti vlastně jen 16 instrukcí, ovšem pro dva datové typy)</td></tr>
<tr><td>SSE4</td><td> 54 (z&nbsp;toho 47 v&nbsp;rámci SSE4.1, zbytek v&nbsp;rámci SSE4.2)</td></tr>
<tr><td>SSE5</td><td>170 (z&nbsp;toho 46 základních instrukcí)</td></tr>
<tr><td>F16C</td><td> 4</td></tr>
</table>



<p><a name="k04"></a></p>
<h2 id="k04">4. Instrukční sada MMX: první pokus o použití SIMD na platformě x86</h2>

<p>První rozšiřující instrukční sadou obsahující <i>SIMD</i> operace, kterou si v&nbsp;tomto článku alespoň stručně popíšeme, je sada instrukcí nazvaná <i>MMX</i> (<i>MultiMedia eXtension</i>, později taktéž rozepisováno jako <i>Matrix Math eXtension</i>). Tato sada byla navržena v&nbsp;roce 1996 ve firmě Intel a od roku 1997 jí začaly být vybavovány prakticky všechny nové procesory této firmy, které patřily do rodiny <i>x86</i> (připomeňme si, že se jednalo o 32bitové mikroprocesory, protože k&nbsp;rozšíření na 64bitovou ALU došlo u mainstreamových čipů až o několik let později). Prvním procesorem s&nbsp;podporou <i>MMX</i> byl čip <i>Pentium P55C</i> nabízený od začátku roku 1997. Později došlo k&nbsp;implementaci <i>MMX</i> i na čipy <i>Pentium II</i> a procesory konkurenčních společností, konkrétně na čipy <i>AMD K6</i> a taktéž na <i>Cyrix M2 (6x86MX</i>) a <i>IDT C6</i>. Na tomto místě je nutné říci, že se vlastně nejednalo o nijak přelomovou technologii, protože v&nbsp;instrukční sadě <i>MMX</i> jsou použity instrukce  analogické instrukcím ze <i>SPARC VIS</i> (VIS=Visual Instruction Set), <i>MIPS MDMX</i> či <i>HP-PA MAX-1</i> a <i>HP-PA MAX-2</i> (opět se tedy jedná o technologii inspirovanou RISCovými procesory).</p>

<img src="http://i.iinfo.cz/images/161/pc159-1.png" width="282" height="150" alt="&#160;" />
<p><i>Obrázek 3: Jedna z&nbsp;poměrně složitých, ale užitečných instrukcí z&nbsp;instrukční sady MMX. Jedná se o instrukci <strong>PMADDWD</strong>, která provádí paralelní součin čtveřice šestnáctibitových hodnot s&nbsp;32 bitovým mezivýsledkem, s&nbsp;následným součtem prvního + druhého a třetího + čtvrtého mezivýsledku.  Tuto instrukci lze použít například při implementaci konvolučních filtrů.<br />
(Zdroj: Intel MMX<sup>TM</sup> Technology Overview, Intel corporation, 1996)</i></p>

<p>Jedním z&nbsp;důvodů zavedení těchto nových instrukcí byla snaha firmy Intel o konstrukci osobních počítačů s&nbsp;minimálním množstvím specializovaných čipů na základní desce i na přídavných kartách. Většinu operací měl totiž provádět samotný mikroprocesor, ať již se jednalo o zpracování zvuku (softwarový mix), ovládání periferních zařízení (programová implementace bufferů atd.) tak i o softwarovou implementaci kodeků, včetně kodeků používaných v&nbsp;modemech (právě v&nbsp;té době došlo k&nbsp;rozvoji takzvaných softwarových modemů, jejichž příslušenství se zúžilo na pouhé rozhraní pro analogovou telefonní linku). V&nbsp;rámci instrukční sady <i>MMX</i> se na původně prakticky ryze skalární platformu <i>x86</i> přidalo celkem 57 nových instrukcí a čtyři datové typy, které byly těmito instrukcemi podporovány. Jeden z&nbsp;nově zaváděných datových typů je skalární, další tři nové datové typy jsou představovány dvouprvkovým, čtyřprvkovým a osmiprvkovým vektorem.</p>

<img src="http://i.iinfo.cz/images/161/pc159-2.png" width="438" height="154" alt="&#160;" />
<p><i>Obrázek 4: Ukázka jednoho typu konverzní funkce, kterých se v&nbsp;instrukční sadě MMX nachází několik.<br />
(Zdroj: Intel MMX<sup>TM</sup> Technology Overview, Intel corporation, 1996)</i></p>

<p>Většina nových instrukcí přidaných v&nbsp;rámci sady <i>MMX</i> byla určena pro provádění aritmetických a bitových operací s&nbsp;celočíselnými operandy o šířce 8, 16, 32 či 64 bitů, což pokrývá poměrně širokou oblast multimediálních dat &ndash; osmibitových i šestnáctibitových zvukových vzorků (samplů), barev pixelů (RGB, RGBA) atd. Zatímco při provádění aritmetických operací s&nbsp;využitím klasické aritmeticko-logické jednotky mohlo docházet k&nbsp;přetečení či podtečení hodnot při provádění instrukcí typu <strong>ADD</strong> či <strong>SUB</strong> (součet, rozdíl), je možné u <i>MMX</i> instrukcí zvolit i takzvanou aritmetiku se <i>saturací</i>, což znamená, že v&nbsp;případě přetečení se do výsledku uloží maximální reprezentovatelná hodnota a naopak při podtečení minimální hodnota, což je například při zpracování signálu (většinou) žádoucí chování, V&nbsp;následující tabulce jsou vypsány nově podporované datové typy i způsob jejich uložení ve slovech o šířce 64 bitů, které jsou zpracovávány jednotkou <i>MMX</i>:</p>

<table>
<tr><th>Datový typ</th><th>Bitová šířka operandu</th><th>Počet prvků vektoru</th></tr>
<tr><td>packed byte</td><td>8 bitů</td><td>8</td></tr>
<tr><td>packed word</td><td>16 bitů</td><td>4</td></tr>
<tr><td>packed doubleword</td><td>32 bitů</td><td>2</td></tr>
<tr><td>quadword</td><td>64 bitů</td><td>1</td></tr>
</table>

<img src="http://i.iinfo.cz/images/161/pc159-3.png" width="312" height="156" alt="&#160;" />
<p><i>Obrázek 5: Ukázka chování MMX instrukce <strong>PADDW</strong>, která provádí součet čtveřice šestnáctibitových hodnot s&nbsp;přetečením, což je patrné z&nbsp;posledního sloupce.<br />
(Zdroj: Intel MMX<sup>TM</sup> Technology Overview, Intel corporation, 1996)</i></p>

<p>Kromě přímé manipulace s&nbsp;celočíselnými hodnotami bylo relativně snadné pracovat i s&nbsp;numerickými hodnotami ukládanými ve formátu s&nbsp;pevnou řádovou čárkou (<i>FX &ndash; fixed point</i>), mohlo se například jednat o formáty 8.8 (osm bitů pro uložení celé části a osm bitů za řádovou čárkou), 8.24, 24.8 atd. O případné bitové posuny při normalizaci numerických hodnot se v&nbsp;tomto případě musel starat programátor. Tyto formáty byly a jsou využívány v&nbsp;některých algoritmech implementujících <i>FFT</i> (rychlou Fourierovu transformaci využívanou v&nbsp;mnoha algoritmech pro zpracování signálů), <i>DCT</i> (diskrétní kosinovou transformaci využívanou například ve formátu JFIF-JPEG), <i>FIR</i>, <i>IIR</i> (filtry s&nbsp;konečnou a nekonečnou impulsní odezvou), operacemi nad vektory či operacemi nad maticemi.</p>

<img src="http://i.iinfo.cz/images/161/pc159-4.png" width="312" height="156" alt="&#160;" />
<p><i>Obrázek 6: MMX instrukce <strong>PADDUSW</strong>, která sice také provádí součet čtveřice šestnáctibitových hodnot, ovšem součet je proveden se saturací &ndash; v&nbsp;případě, že se výsledek součtu již nemůže reprezentovat šestnáctibitovou hodnotou, uloží se namísto výsledku hodnota 0xFFFF, tj.&nbsp;nejvyšší šestnáctibitové celé číslo bez znaménka.<br />
(Zdroj: Intel MMX<sup>TM</sup> Technology Overview, Intel corporation, 1996)</i></p>

<p>Všech 57 instrukcí v&nbsp;instrukční sadě <i>MMX</i> lze rozdělit podle jejich funkce do několika skupin vypsaných v&nbsp;následující tabulce:</p>

<table>
<tr><th>#</th><th>Skupina instrukcí</th><th>Příklady instrukcí</th></tr>
<tr><td>1</td><td>Základní aritmetické operace</td><td>PADD, PADDS, PADDUS, PSUBS, PSUBUS, PMULHW, PMULLW</td></tr>
<tr><td>2</td><td>Logické (bitové) operace</td><td>PAND, PANDN, POR, PXOR</td></tr>
<tr><td>3</td><td>Bitové posuny</td><td>PSLL, PSRL, PSRA</td></tr>
<tr><td>4</td><td>Porovnávání</td><td>PCMPEQ, PCMGT</td></tr>
<tr><td>5</td><td>Konverze dat</td><td>PACKUSWB, PACKSS, PUNPCKH, PUNPCKL</td></tr>
<tr><td>6</td><td>Přenosy dat + práce s&nbsp;pamětí</td><td>MOV</td></tr>
<tr><td>7</td><td>Řízení jednotky MMX</td><td>EMMS</td></tr>
</table>

<img src="http://i.iinfo.cz/images/51/pc140-11.png" width="256" height="256" alt=" " />
<p><i>Obrázek 7: Zdrojový rastrový obrázek (známá fotografie Lenny), který tvoří zdroj pro jednoduchý konvoluční (FIR) filtr, jenž zvyšuje hodnoty pixelů o pevně zadanou konstantu (offset).</i></p>

<p>Většina instrukcí uvedených v&nbsp;předchozí tabulce má navíc několik variant v&nbsp;závislosti na tom, s&nbsp;jakými operandy má instrukce ve skutečnosti pracovat. Například u instrukce <strong>PADD</strong> (součet) je možné zvolit, zda se mají sečíst dva osmiprvkové vektory, kde každý prvek má šířku 8 bitů, zda se má provést součet dvou čtyřprvkových vektorů (16bitové prvky), dvou dvouprvkových vektorů (32bitové prvky) či zda se jedná o součet dvojice 64bitových skalárních hodnot. To tedy znamená, že instrukce <strong>PADD</strong> může být reprezentována čtveřicí operačních kódů:</p>

<table>
<tr><th>#</th><th>Instrukce</th><th>Význam</th></tr>
<tr><td>1</td><td>PADDB</td><td>součet dvou vektorů majících osm osmibitových prvků</td></tr>
<tr><td>2</td><td>PADDW</td><td>součet dvou vektorů majících čtyři šestnáctibitové prvky</td></tr>
<tr><td>3</td><td>PADDD</td><td>součet dvou vektorů majících dva 32bitové prvky</td></tr>
<tr><td>4</td><td>PADDQ</td><td>součet dvou 64bitových skalárních hodnot</td></tr>
</table>

<p>Výjimkou z&nbsp;výše uvedeného pravidla jsou instrukce <strong>PAND</strong>, <strong>PANDN</strong>, <strong>POR</strong> a <strong>PXOR</strong>, pomocí nichž lze provádět bitové operace s&nbsp;dvojicí 64bitových slov. Důvod, proč není zapotřebí tyto instrukce dále rozdělovat podle počtu a šířky prvků vektorů, je zřejmý &ndash; tyto operace pracují nad jednotlivými bity, nikoli nad skupinami bitů. Na tomto místě je možná dobré upozornit na instrukci <strong>PANDN</strong> (<i>not-and</i>), která sice není ve většině běžných (skalárních) aritmeticko-logických jednotkách implementována, ovšem v&nbsp;případě zpracování rastrových obrazů se jedná o velmi užitečnou instrukci používanou například při vykreslování spritů atd.</p>

<img src="http://i.iinfo.cz/images/51/pc140-12.png" width="256" height="256" alt=" " />
<p><i>Obrázek 8: Pokud je pro přičtení offsetu použita operace součtu se zanedbáním přenosu (carry), tj.&nbsp;když se počítá systémem &bdquo;modulo N&ldquo; (viz též výše zmíněná instrukce <strong>PADDB</strong>), dochází při překročení maximální hodnoty pixelu (čistě bílá barva) k&nbsp;viditelným chybám.</i></p>



<p><a name="k05"></a></p>
<h2 id="k05">5. Registry MMX, vztah ke standardnímu matematickému koprocesoru</h2>

<p>Inženýři ve firmě <i>Intel</i> stáli při návrhu instrukční sady <i>MMX</i> před požadavkem na vytvoření výkonných instrukcí provádějících SIMD operace, na druhou stranu však bylo nutné šetřit počtem tranzistorů a tím pádem i plochou čipu, na němž byl mikroprocesor vytvořen. Pravděpodobně právě z&nbsp;tohoto důvodu se rozhodli učinit poněkud problematický krok &ndash; navrhli <i>MMX</i> instrukce takovým způsobem, aby mohly pracovat s&nbsp;osmicí 64bitových registrů rozdělených na jeden, dva, čtyři či osm prvků. Ovšem nejednalo se o nové registry rozšiřující původní sadu registrů procesoru Pentium, ale o část registrů využívaných matematickým koprocesorem (<i>FPU</i>). Ten na platformě <i>x86</i> prováděl operace s&nbsp;osmicí 80bitových registrů uspořádaných do zásobníku (u matematického koprocesoru <i>Intel 8087</i> byly používány čistě zásobníkové instrukce, později byly přidány i další adresovací režimy, které umožňovaly registry adresovat přímo, což se ukázalo být výhodnější především kvůli možnostem provádění různých optimalizací).</p>

<img src="http://i.iinfo.cz/images/51/pc140-13.png" width="256" height="256" alt=" " />
<p><i>Obrázek 9: Při použití operace součtu se saturací sice taktéž dojde ke ztrátě informace (vzniknou oblasti s&nbsp;pixely majícími hodnotu 255), ovšem viditelná chyba je mnohem menší, než na předchozím obrázku. Tento filtr by bylo možné realizovat s&nbsp;využitím instrukce <strong>PADDUSB</strong> s&nbsp;rychlostí výpočtu 8 pixelů/instrukci.</i></p>

<p>V&nbsp;případě instrukcí <i>MMX</i> se sice registry adresovaly přímo (popř.&nbsp;se adresovala slova uložená v&nbsp;operační paměti, která mohla tvořit jeden z&nbsp;operandů), ale kvůli tomu, že jak <i>FPU</i>, tak i jednotka <i>MMX</i> pracovala se shodnými registry (horních 16 bitů nebylo využito), bylo současné používání SIMD operací a operací s&nbsp;hodnotami uloženými v&nbsp;systému plovoucí řádové čárky poměrně komplikované, což je škoda, protože právě souběžná práce superskalárního CPU (u mikroprocesorů <i>Pentium</i> byly vytvořeny dvě instrukční pipeline &bdquo;u&ldquo; a &bdquo;v&ldquo;), jednotky <i>MMX</i> a navíc ještě matematického koprocesoru by v&nbsp;mnoha případech mohla vést k&nbsp;citelnému nárůstu výpočetního výkonu. V&nbsp;následující tabulce jsou vypsána jména registrů tak, jak jsou použita v&nbsp;instrukcích matematického koprocesoru, i ve formě používané jednotkou <i>MMX</i>:</p>

<table>
<tr><th>Registr FPU</th><th>bity 79-64</th><th>bity 63-0</th></tr>
<tr><td>ST0</td><td>nepoužito</td><td>MM0</td></tr>
<tr><td>ST1</td><td>nepoužito</td><td>MM1</td></tr>
<tr><td>ST2</td><td>nepoužito</td><td>MM2</td></tr>
<tr><td>ST3</td><td>nepoužito</td><td>MM3</td></tr>
<tr><td>ST4</td><td>nepoužito</td><td>MM4</td></tr>
<tr><td>ST5</td><td>nepoužito</td><td>MM5</td></tr>
<tr><td>ST6</td><td>nepoužito</td><td>MM6</td></tr>
<tr><td>ST7</td><td>nepoužito</td><td>MM7</td></tr>
</table>

<a href="http://i.iinfo.cz/images/311/pc158-8.jpg"><img src="http://i.iinfo.cz/images/311/pc158-8-prev.jpg" width="370" height="155" alt="&#160;" /></a>
<p><i>Obrázek 10: Typy vektorů, s&nbsp;nimiž pracují instrukce MMX.</i></p>



<p><a name="k06"></a></p>
<h2 id="k06">6. SIMD instrukce v&nbsp;instrukční sadě 3DNow!</h2>

<p>Rozšíření instrukční sady procesorů z&nbsp;rodiny <i>x86</i> o instrukce <i>MMX</i> bylo poměrně razantní &ndash; jednalo se v&nbsp;podstatě o největší změnu této architektury od vzniku procesoru <i>80386</i>, tj.&nbsp;od zavedení virtuálního režimu, 32bitových registrů a operací s&nbsp;32 bitovými hodnotami.  Z&nbsp;hlediska společnosti <i>Intel</i> se samozřejmě jednalo o nemalou konkurenční výhodu získanou  nad firmami <i>AMD</i>, <i>Cyrix</i> či <i>IDT</i>, zejména poté, co se podpora <i>MMX</i> operací zařadila do některých programových produktů (například do zásuvných modulů Photoshopu). Ovšem tehdejší druhý největší výrobce čipů <i>x86</i> &ndash; společnost <i>AMD</i> &ndash; o necelé dva roky později představila vlastní rozšíření instrukční sady, které bylo označeno poměrně nabubřelým názvem <i>3DNow!</i> (včetně onoho vykřičníku na konci). Toto rozšíření instrukční sady bylo poprvé implementováno v&nbsp;mikroprocesoru <i>AMD K6-2</i> a později též v&nbsp;<i>AMD K6-3</i> a <i>Athlon</i>.</p>

<img src="http://i.iinfo.cz/images/311/pc158-13.png" width="200" height="150" alt="&#160;" />
<p><i>Obrázek 11: Mikroprocesor AMD K6-2 implementující mj.&nbsp;i instrukční sadu 3DNow!</i></p>

<p>Inženýři z&nbsp;firmy <i>AMD</i> použili a současně i rozšířili instrukční
sadu <i>MMX</i> o několik nových celočíselných instrukcí, ovšem hlavní
konkurenční výhodou (a to poměrně podstatnou) byly nové instrukce pro práci
s&nbsp;čísly reprezentovanými 32bitovými hodnotami s&nbsp;plovoucí řádovou
čárkou. Kromě toho bylo do instrukční sady <i>3DNow!</i> přidáno několik
operací sloužících pro přečtení bloku dat do vyrovnávací paměti (cache). U
některých typů procesorů (<i>Athlon</i>) bylo navíc možné určit, zda je blok
dat načtených do vyrovnávací paměti určený pro čtení nebo i pro zápis (pokud se
jednalo o blok určený pro zápis, byl mu nastaven atribut <i>modified</i>).</p>

<img src="http://i.iinfo.cz/images/161/pc159-5.jpg" width="242" height="208" alt="&#160;" />
<p><i>Obrázek 12: Další pohled na mikroprocesor AMD K6-2 s&nbsp;implementací instrukční sady 3DNow!.</i></p>



<p><a name="k07"></a></p>
<h2 id="k07">7. Registry používané v&nbsp;rozšíření 3DNow!</h2>

<p>Již <a href="#k06">v&nbsp;předchozí kapitole</a> jsme se zmínili o tom, že instrukční sada <i>3DNow!</i> byla vlastně rozšířením instrukční sady <i>MMX</i>. To mj.&nbsp;znamená, že byly podporovány všechny datové typy <i>MMX</i>, tj.&nbsp;osmiprvkové vektory s&nbsp;osmibitovými hodnotami, čtyřprvkové vektory s&nbsp;16bitovými hodnotami, dvouprvkové vektory s&nbsp;32bitovými hodnotami a konečně i 64bitové skalární hodnoty. Navíc však bylo možné do 64bitových registrů MMX uložit dvojici 32bitových čísel s&nbsp;plovoucí řádovou čárkou odpovídající formátu <i>single precision</i> definovaném v&nbsp;normě <i>IEEE 754</i>. Zavedení tohoto nového typu dvouprvkového vektoru s&nbsp;sebou přinášelo dvě výhody: mnohé FP operace se mohly provádět paralelně (součet prvků vektorů atd.) a navíc bylo velmi snadné kombinovat původní celočíselné MMX operace s&nbsp;operacemi nad reálnými čísly. To nebylo u původní implementace <i>MMX</i> snadné, protože se muselo provádět přepínání mezi činností matematického koprocesoru a jednotkou MMX.</p>

<a href="http://i.iinfo.cz/images/161/pc159-6.png"><img src="http://i.iinfo.cz/images/161/pc159-6-prev.png" width="370" height="232" alt="&#160;" /></a>
<p><i>Obrázek 13: Mikroprocesor Intel Atom sice implementuje instrukční sadu MMX, ale nikoli 3Dnow!, což je ovšem kompenzováno podporou SSE a SSE2.</i></p>

<p>V&nbsp;případě instrukční sady <i>3DNow!</i> se toto přepínání provádět nemuselo (pokud tedy nebylo nutné pracovat s&nbsp;hodnotami s&nbsp;dvojitou či rozšířenou přesností, tj.&nbsp;s&nbsp;datovými typy <i>double</i> a <i>extended</i>), navíc měli programátoři k&nbsp;dispozici konverzní instrukce <strong>PI2FD</strong> a <strong>PF2ID</strong> pro převod celočíselných 32bitových hodnot na hodnoty s&nbsp;plovoucí řádovou čárkou (se zaokrouhlením) a naopak. Mimochodem: pro přepnutí kontextu mezi FPU operacemi a MMX/3DNow!  operacemi bylo možné použít instrukci <strong>FEMMS</strong> pro rychlé přepnutí kontextu. Tato operace je rychlejší, než původní instrukce <strong>EMMS</strong> ze sady <i>MMX</i>, ovšem po přepnutí je obsah pracovních registrů nedefinovaný (což většinou nevadí).</p>

<a href="http://i.iinfo.cz/images/161/pc159-7.png"><img src="http://i.iinfo.cz/images/161/pc159-7-prev.png" width="370" height="75" alt="&#160;" /></a>
<p><i>Obrázek 14: Uložení dvou 32bitových čísel s&nbsp;plovoucí řádovou čárkou v&nbsp;64bitovém registru.<br />
(Zdroj: 3Dnow! Technology Manual, AMD Inc.)</i></p>



<p><a name="k08"></a></p>
<h2 id="k08">8. Nové SIMD instrukce v&nbsp;rozšíření 3DNow!</h2>

<p>Všechny vektorové instrukce provádějící operace s&nbsp;32bitovými numerickými hodnotami s&nbsp;plovoucí řádovou čárkou, které jsou implementovány v&nbsp;instrukční sadě <i>3DNow!</i>, jsou vypsány v&nbsp;následující tabulce:</p>

<table>
<tr><th> #</th><th>Instrukce</th><th>Popis</th></tr>
<tr><td> 1</td><td>PI2FD   </td><td>převod 32bitových celočíselných hodnot na FP hodnoty</td></tr>
<tr><td> 2</td><td>PF2ID   </td><td>převod 32bitových FP hodnot na celočíselné hodnoty</td></tr>
<tr><td> 3</td><td>PFCMPGE </td><td>porovnání na relaci &bdquo;větší nebo rovno&ldquo;</td></tr>
<tr><td> 4</td><td>PFCMPGT </td><td>porovnání na relaci &bdquo;větší než&ldquo;</td></tr>
<tr><td> 5</td><td>PFCMPEQ </td><td>porovnání na relaci &bdquo;rovnost&ldquo;</td></tr>
<tr><td> 6</td><td>PFACC   </td><td>součet obou prvků zdrojového registru i obou prvků cílového registru</td></tr>
<tr><td> 7</td><td>PFADD   </td><td>součet dvou dvouprvkových vektorů</td></tr>
<tr><td> 8</td><td>PFSUB   </td><td>rozdíl dvou dvouprvkových vektorů</td></tr>
<tr><td> 9</td><td>PFSUBR  </td><td>rozdíl dvou dvouprvkových vektorů s&nbsp;prohozením operandů</td></tr>
<tr><td>10</td><td>PFMIN   </td><td>výpočet minima (vždy mezi příslušnými prvky vektorů)</td></tr>
<tr><td>11</td><td>PFMAX   </td><td>výpočet maxima (vždy mezi příslušnými prvky vektorů)</td></tr>
<tr><td>12</td><td>PFMUL   </td><td>součin dvou dvouprvkových vektorů</td></tr>
<tr><td>13</td><td>PFRCP   </td><td>výpočet aproximace převrácené hodnoty</td></tr>
<tr><td>14</td><td>PFRSQRT </td><td>výpočet aproximace druhé odmocniny</td></tr>
<tr><td>15</td><td>PFRCPIT1</td><td>první krok přesného výpočtu převrácené hodnoty</td></tr>
<tr><td>16</td><td>PFRSQIT1</td><td>první krok přesného výpočtu druhé odmocniny</td></tr>
<tr><td>17</td><td>PFRCPIT2</td><td>další krok výpočtu převrácené hodnoty či druhé odmocniny</td></tr>
</table>

<a href="http://i.iinfo.cz/images/161/pc159-8.png"><img src="http://i.iinfo.cz/images/161/pc159-8-prev.png" width="370" height="119" alt="&#160;" /></a>
<p><i>Obrázek 15: Formát 32bitových čísel s&nbsp;plovoucí řádovou čárkou podporovaný instrukcemi 3Dnow!)<br />
(Zdroj: 3Dnow! Technology Manual, AMD Inc.)</i></p>

<p>Při provádění porovnání prvků dvou vektorů, tj.&nbsp;při provádění instrukcí <strong>PFCMPGE</strong>, <strong>PFCMPGT</strong> a <strong>PFCMPEQ</strong>, je výsledkem této operace nový dvouprvkový vektor obsahující pouze hodnoty 0x0000_0000 a 0xFFFF_FFFF. U porovnávání se navíc nerozlišuje kladná a záporná nula.</p>

<p>Pravděpodobně nejzajímavější je poslední pětice instrukcí nazvaných <strong>PFRCP</strong>, <strong>PFRSQRT</strong>, <strong>PFRCPIT1</strong>, <strong>PFRSQIT1</strong> a <strong>PFRCPIT2</strong>. Instrukce <strong>PFRCP</strong> slouží k&nbsp;rychlému výpočtu převrácené hodnoty, ovšem pouze s&nbsp;přesností na 14 bitů. Pokud tato přesnost není dostatečná (pro mnoho účelů však stačí), musí být použita následující sekvence:</p>

<pre>
PFRCP      ; první přiblížení k výsledku s přesností 14 bitů
PFCPIT1    ; první krok přesného výpočtu převrácené hodnoty
PFRCPIT2   ; druhý krok přesného výpočtu převrácené hodnoty
</pre>

<p>Důležité je, že první přiblížení se k&nbsp;výsledku je provedeno velmi rychle, konkrétně pouze ve dvou taktech, protože se využívá tabulky výsledků umístěné v&nbsp;paměti ROM. Teprve další dvojice instrukcí využívá pomalejší iterační výpočet. Podobný princip platí i pro rychlý vs.&nbsp;přesný výpočet druhé odmocniny.</p>

<a href="http://i.iinfo.cz/images/161/pc159-9.png"><img src="http://i.iinfo.cz/images/161/pc159-9-prev.png" width="370" height="96" alt="&#160;" /></a>
<p><i>Obrázek 16: Subrutina pro operaci dělení s&nbsp;24 bitovou přesností implementovanou pomocí instrukcí 3Dnow!.<br />
(Zdroj: 3Dnow! Technology Manual, AMD Inc.)</i></p>



<p><a name="k09"></a></p>
<h2 id="k09">9. SIMD instrukce v&nbsp;rozšíření SSE</h2>

<p>Po úspěšném a relativně bezproblémovém zavedení rozšíření <i>MMX</i> i <i>3DNow!</i> do praxe není divu, že obě nejvýznamnější společnosti podnikající v&nbsp;oblasti návrhu a prodeje mikroprocesorů patřících do rodiny <i>x86</i>, tj.&nbsp;firmy <i>Intel</i> a <i>AMD</i>, začaly pro tyto typy mikroprocesorů navrhovat i další rozšiřující instrukční sady s&nbsp;&bdquo;vektorovými&ldquo; instrukcemi typu <i>SIMD</i>. V&nbsp;následující tabulce jsou tyto rozšiřující instrukční sady vypsány, včetně roku vzniku dané technologie i informace o tom, v&nbsp;jakém mikroprocesoru byla ta která technologie zpočátku využita. Některé z&nbsp;níže zmíněných technologií byly použity v&nbsp;mikroprocesorech vyráběných jednou společností (což je především případ <i>3DNow!</i>), ovšem v&nbsp;současnosti můžeme vidět oboustranné snahy o zavádění rozšíření instrukční sady <i>x86</i> podle jednotného schématu a navíc tak, aby ho bylo možné používat na mikroprocesorech vyráběných oběma zmíněnými společnostmi. To je poměrně velký rozdíl oproti ad-hoc řešením, s&nbsp;nimiž jsme se setkali v&nbsp;případě <i>MMX</i> i <i>3DNow!</i> (kde navíc byli výrobci čipů svázaní snahou o zachování zpětné kompatibility s&nbsp;existujícími operačními systémy).</p>

<p>Pro programátory je důležitá především technologie <i>SSE</i>, což je zkratka znamenající <i>Streaming SIMD Extension</i>. Na <i>SSE</i> se můžeme dívat buď jako na zcela nové rozšíření instrukční sady o <i>SIMD</i> instrukce, nebo jako na určité propojení předností obou předchozích technologií, tj.&nbsp;jak <i>MMX</i> (relativně velký počet prvků uložených ve vektorech, ovšem podpora pouze pro celočíselné operace nad prvky vektorů), tak i <i>3DNow!</i> (práce s&nbsp;reálnými čísly, ovšem uloženými pouze v&nbsp;dvouprvkových vektorech, z&nbsp;čehož vyplývají menší možnosti paralelizace výpočtů). V&nbsp;případě <i>SSE</i> je navíc umožněna souběžná práce jednotky <i>MMX</i> či <i>FPU</i>.  Ve specifikaci <i>SSE</i> jsou popsány jak významy všech nových instrukcí, tak i různé režimy využívané při aritmetických operacích. Specifikace taktéž říká, jaké registry se u nových instrukcí používají.</p>

<p>Nejprve se zaměřme na registry využívané v&nbsp;technologii <i>SSE</i>. U mikroprocesorů implementujících instrukční sadu <i>SSE</i> je využita nová sada registrů pojmenovaných <strong>XMM0</strong> až <strong>XMM7</strong>. Na 64bitové platformě (architektura AMD 64) navíc došlo k&nbsp;přidání dalších osmi registrů se jmény <strong>XMM8</strong> až <strong>XMM15</strong> využitelných pouze v&nbsp;64bitovém režimu. Všechny nové registry mají šířku 128 bitů, tj.&nbsp;jsou dvakrát širší, než registry používané v&nbsp;<i>MMX</i> i <i>3DNow!</i> a čtyřikrát širší, než běžné pracovní registry na platformě <i>x86</i> (bavíme se o 32bitovém režimu). Do každého registru je možné uložit čtveřici reálných numerických hodnot reprezentovaných v&nbsp;systému plovoucí řádové tečky podle normy <i>IEEE 754</i>, přičemž tato norma je dodržována přesněji, než v&nbsp;případě <i>3DNow!</i> (různé zaokrouhlovací režimy či práce s&nbsp;denormalizovanými čísly sice mohou vypadat trošku jako černá magie, ovšem například v&nbsp;knihovnách pro numerické výpočty, které musí vždy za specifikovaných okolností dát stejný výsledek, se jedná o velmi důležitou vlastnost). K&nbsp;osmi či šestnácti novým registrům <strong>XMM*</strong> byl ještě přidán jeden 32bitový registr nazvaný <strong>MXCSR</strong>, jenž byl určený pro nastavení (řízení) režimů výpočtu.</p>

<img src="http://i.iinfo.cz/images/503/pc160-3.jpg" width="220" height="194" alt="&#160;" />
<p><i>Obrázek 5: Sada nových pracovních registrů přidaných v&nbsp;rámci rozšíření instrukční sady SSE.</i></p>



<p><a name="k10"></a></p>
<h2 id="k10">10. Sada registrů použitelná vývojáři pracujícími s&nbsp;procesory podporujícími SSE</h2>

<p>Díky zavedení rozšíření instrukční sady <i>SSE</i> do praxe začali mít programátoři vytvářející aplikace na 32bitové platformě <i>x86</i>, jejíž začátek se datuje od dnes již spíše historického mikroprocesoru <i>Intel 80386</i>, k&nbsp;dispozici nejenom 64bitové registry (jednotka <i>MMX</i>), ale i registry 128bitové, což je zajisté užitečné. Přitom i přes zavedení rozšířených instrukčních sad <i>MMX/3DNow!/SSE</i> stále zůstávala zachována binární zpětná i dopředná kompatibilita s&nbsp;předchozími typy mikroprocesorů (nejedná se tedy o takovou změnu, jako v&nbsp;případě přechodu 16-&gt;32-&gt;64 bitů). Zde je myšlena především možnost běhu starších aplikací na novějších mikroprocesorech, protože program přeložený s&nbsp;podporou <i>SSE</i> nebude na procesoru bez této technologie pracovat korektně, i když by pravděpodobně bylo možné <i>SSE</i> emulovat pomocí podprogramů spouštěných při zavolání neplatného operačního kódu (tj.&nbsp;operačního kódu SSE instrukce, která je samozřejmě pro ne-SSE procesor neznámým kódem).</p>

<p>Pro zajímavost se podívejme, jak se společně se zavedením instrukční sady <i>SSE</i> prakticky zdvojnásobila celková kapacita všech využitelných registrů na 32bitové platformě <i>x86</i> (na 64bitové <i>x86_64</i> je situace odlišná). V&nbsp;následující tabulce jsou kromě univerzálních pracovních registrů, indexových registrů a bázových registrů vypsány i registry se speciálním významem:</p>

<table>
<tr><th> #</th><th>Typ registrů</th><th>Počet registrů</th><th>Bitová šířka registru</th><th>Příklady</th></tr>
<tr><td> 1</td><td>Univerzální registry </td><td>4</td><td> 32 bitů</td><td>EAX, EBX, ECX, EDX</td></tr>
<tr><td> 2</td><td>Indexové registry    </td><td>3</td><td> 32 bitů</td><td>ESI, EDI, EIP</td></tr>
<tr><td> 3</td><td>Bázové registry      </td><td>2</td><td> 32 bitů</td><td>EBP, ESP</td></tr>
<tr><td> 4</td><td>Segmentové registry  </td><td>6</td><td> 16 bitů</td><td>CS, DS, ES, FS, GS, SS</td></tr>
<tr><td> 5</td><td>Příznakový registr   </td><td>1</td><td> 32 bitů</td><td>EFLAGS (původně 16bitový FLAGS)</td></tr>
<tr><td> 6</td><td>Registry pro ladění  </td><td>8</td><td> 32 bitů</td><td>DR0..DR7</td></tr>
<tr><td> 7</td><td>Řídicí registry      </td><td>4</td><td> 32 bitů</td><td>CR0, CR2, CR3, CR4</td></tr>
<tr><td> 8</td><td>Další spec. registry </td><td>12?</td><td> 32 bitů</td><td>TR1...TR12</td></tr>
<tr><td> 9</td><td>Registry MMX/3DNow!  </td><td>8</td><td> 64 bitů</td><td>shodné s&nbsp;FPU registry st(x), resp.&nbsp;se spodními 64 bity st(x)</td></tr>
<tr><td>10</td><td>Pracovní registry SSE</td><td>8</td><td>128 bitů</td><td>XMM0 .. XMM7</td></tr>
<tr><td>11</td><td>Řídicí registr SSE   </td><td>1</td><td> 32 bitů</td><td>MXCSR</td></tr>
</table>

<img src="http://i.iinfo.cz/images/503/pc160-4.jpg" width="353" height="143" alt="&#160;" />
<p><i>Obrázek 6: Zjednodušený programátorský model architektury x86
v&nbsp;32bitovém režimu.</i></p>



<p><a name="k11"></a></p>
<h2 id="k11">11. </h2>



<p><a name="k12"></a></p>
<h2 id="k12">12. </h2>



<p><a name="k13"></a></p>
<h2 id="k13">13. </h2>



<p><a name="k14"></a></p>
<h2 id="k14">14. </h2>



<p><a name="k15"></a></p>
<h2 id="k15">15. </h2>



<p><a name="k16"></a></p>
<h2 id="k16">16. </h2>



<p><a name="k17"></a></p>
<h2 id="k17">17. </h2>



<p><a name="k18"></a></p>
<h2 id="k18">18. </h2>



<p><a name="k19"></a></p>
<h2 id="k19">19. </h2>



<p><a name="k20"></a></p>
<h2 id="k20">20. Odkazy na Internetu</h2>

<ol>

<li>SSE (Streaming SIMD Extentions)<br />
<a href="http://www.songho.ca/misc/sse/sse.html">http://www.songho.ca/misc/sse/sse.html</a>
</li>

<li>Timothy A. Chagnon: SSE and SSE2<br />
<a href="http://www.cs.drexel.edu/~tc365/mpi-wht/sse.pdf">http://www.cs.drexel.edu/~tc365/mpi-wht/sse.pdf</a>
</li>

<li>Intel corporation: Extending the Worldr's Most Popular Processor Architecture<br />
<a href="http://download.intel.com/technology/architecture/new-instructions-paper.pdf">http://download.intel.com/technology/architecture/new-instructions-paper.pdf</a>
</li>

<li>
SIMD architectures:<br />
<a href="http://arstechnica.com/old/content/2000/03/simd.ars/">http://arstechnica.com/old/content/2000/03/simd.ars/</a>
</li>

<li>
Tour of the Black Holes of Computing!: Floating Point<br />
<a href="http://www.cs.hmc.edu/~geoff/classes/hmc.cs105.../slides/class02_floats.ppt">http://www.cs.hmc.edu/~geoff/classes/hmc.cs105.../slides/class02_floats.ppt</a>
</li>

<li>3Dnow! Technology Manual<br />
AMD Inc., 2000</li>

<li>Intel MMX<sup>TM</sup> Technology Overview<br />
Intel corporation, 1996</li>

<li>MultiMedia eXtensions<br />
<a href="http://softpixel.com/~cwright/programming/simd/mmx.php">http://softpixel.com/~cwright/programming/simd/mmx.php</a>i
</li>

<li>AMD K5 ("K5" / "5k86")<br />
<a href="http://www.pcguide.com/ref/cpu/fam/g5K5-c.html">http://www.pcguide.com/ref/cpu/fam/g5K5-c.html</a>
</li>

<li>Sixth Generation Processors<br />
<a href="http://www.pcguide.com/ref/cpu/fam/g6.htm">http://www.pcguide.com/ref/cpu/fam/g6.htm</a>
</li>

<li>Great Microprocessors of the Past and Present<br />
<a href="http://www.cpushack.com/CPU/cpu1.html">http://www.cpushack.com/CPU/cpu1.html</a>
</li>

<li>Very long instruction word (Wikipedia)<br />
<a href="http://en.wikipedia.org/wiki/Very_long_instruction_word">http://en.wikipedia.org/wiki/Very_long_instruction_word</a>
</li>

<li>CPU design (Wikipedia)<br />
<a href="http://en.wikipedia.org/wiki/CPU_design">http://en.wikipedia.org/wiki/CPU_design</a>
</li>

<li>Bulldozer (microarchitecture)<br />
<a href="https://en.wikipedia.org/wiki/Bulldozer_(microarchitecture)">https://en.wikipedia.org/wiki/Bulldozer_(microarchitecture)</a>
</li>

</ol>



<p></p><p></p>
<p><small>Autor: <a href="http://www.fit.vutbr.cz/~tisnovpa">Pavel Tišnovský</a> &nbsp; 2022</small></p>
</body>
</html>

