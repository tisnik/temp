<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
        "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html>
<head>
<title></title>
<meta name="Author" content="Pavel Tisnovsky" />
<meta name="Generator" content="vim" />
<meta http-equiv="content-type" content="text/html; charset=utf-8" />
<style type="text/css">
         body {color:#000000; background:#ffffff;}
         h1  {font-family: arial, helvetica, sans-serif; color:#ffffff; background-color:#c00000; text-align:center; padding-left:1em}
         h2  {font-family: arial, helvetica, sans-serif; color:#ffffff; background-color:#0000c0; padding-left:1em; text-align:left}
         h3  {font-family: arial, helvetica, sans-serif; color:#000000; background-color:#c0c0c0; padding-left:1em; text-align:left}
         h4  {font-family: arial, helvetica, sans-serif; color:#000000; background-color:#e0e0e0; padding-left:1em; text-align:left}
         a   {font-family: arial, helvetica, sans-serif;}
         li  {font-family: arial, helvetica, sans-serif; color:#000000; text-align:justify; width:450px;}
         ol  {font-family: arial, helvetica, sans-serif; color:#000000; text-align:justify; width:450px;}
         ul  {font-family: arial, helvetica, sans-serif; color:#000000; text-align:justify; width:450px;}
         p   {font-family: arial, helvetica, sans-serif; color:#000000; text-align:justify;}
         pre {background:#e0e0e0}
</style>
</head>

<body>

<h1></h1>

<h3>Pavel Tišnovský</h3>

<p></p>

<h1>Úvodník</h1>

<p></p>



<h2>Obsah</h2>

<p><a href="#k01">*** 1. </a></p>
<p><a href="#k02">*** 2. </a></p>
<p><a href="#k03">*** 3. Architektura x86-64 s&nbsp;nepřeberným množstvím skupin SIMD instrukcí</a></p>
<p><a href="#k04">*** 4. Instrukční sada MMX: první pokus o použití SIMD na platformě x86</a></p>
<p><a href="#k05">*** 5. Registry MMX, vztah ke standardnímu matematickému koprocesoru</a></p>
<p><a href="#k06">*** 6. SIMD instrukce v&nbsp;instrukční sadě 3DNow!</a></p>
<p><a href="#k07">*** 7. </a></p>
<p><a href="#k08">*** 8. </a></p>
<p><a href="#k09">*** 9. </a></p>
<p><a href="#k10">*** 10. </a></p>
<p><a href="#k11">*** 11. </a></p>
<p><a href="#k12">*** 12. </a></p>
<p><a href="#k13">*** 13. </a></p>
<p><a href="#k14">*** 14. </a></p>
<p><a href="#k15">*** 15. </a></p>
<p><a href="#k16">*** 16. </a></p>
<p><a href="#k17">*** 17. </a></p>
<p><a href="#k18">*** 18. </a></p>
<p><a href="#k19">*** 19. Repositář s&nbsp;demonstračními příklady</a></p>
<p><a href="#k20">*** 20. Odkazy na Internetu</a></p>



<p><a name="k01"></a></p>
<h2 id="k01">1. </h2>

<p><i>"...sequential computers are approaching a fundamental physical limit on
their potential power. Such a limit is the speed of light..."</i></p>

<p>V&nbsp;dnešním článku si ukážeme, jakým způsobem je možné v&nbsp;GCC (přesněji v&nbsp;překladači C z&nbsp;rodiny překladačů GCC) používat SIMD instrukce, které jsou zde souhrnně nazývány <i>vektorové instrukce</i>. Přitom SIMD/vektorové instrukce dnes patří ke standardní výbavě prakticky všech moderních mikroprocesorů. Připomeňme si, že z&nbsp;hlediska dosahovaného výpočetního výkonu leží na samém &bdquo;výkonnostním dně&ldquo; klasické mikroprocesory s&nbsp;architekturou <i>CISC</i>, které vykonávají všechny instrukce postupně a dokončení jedné instrukce může v&nbsp;závislosti na jejich složitosti trvat i několik desítek strojových taktů. Předností těchto procesorů může být poměrně velká informační hustota instrukční sady (například i díky tomu, že operandy některých instrukcí jsou zadány implicitně), což mj.&nbsp;znamená, že se procesory tohoto typu po poměrně dlouhou dobu obešly bez nutnosti využití drahých vyrovnávacích pamětí první a druhé úrovně (<i>L1 cache</i>, <i>L2 cache</i>). Klasické procesory s&nbsp;architekturou <i>CISC</i> byly založeny na mikroprogramovém řadiči vybaveném pamětí mikroinstrukcí a teprve později začaly být tyto procesory doplňovány technologiemi získanými z&nbsp;jiných architektur &ndash; instrukční pipeline, prediktorem skoků, vektorovými instrukcemi atd.</p>

<img src="http://i.iinfo.cz/images/311/pc158-1.png" width="450" height="310" alt="&#160;" />
<p><i>Obrázek 1: Ukázka časování instrukce ADC (Add with carry) osmibitového mikroprocesoru MOS 6502 s&nbsp;architekturou CISC. V&nbsp;závislosti na zvoleném adresním režimu se liší počty strojových cyklů od dvou do šesti. Liší se samozřejmě i počet bajtů nutných pro zakódování instrukce, protože některé adresní režimy vyžadují zápis absolutní 16bitové adresy a jiné režimy používají jen 8bitový offset, popř.&nbsp;osmibitovou adresu v&nbsp;rámci takzvané nulté stránky (zero page).</i></p>

<p>Výpočetní výkon mikroprocesorů se podařilo poměrně výrazným způsobem zvýšit u architektury <i>RISC</i> s&nbsp;instrukční pipeline. Provedení jedné instrukce sice stále trvalo větší počet strojových cyklů, ovšem díky rozfázování operací v&nbsp;instrukční pipeline bylo umožněno překrývání většího množství instrukcí, a to bez nutnosti zavádění skutečné paralelizace (která vede k&nbsp;velkému nárůstu složitosti a tím i ceny čipu). Spolu se zavedením mikroprocesorů <i>RISC</i> se skutečně stalo, že reálný i špičkový výpočetní výkon procesorů vzrostl, ale relativně brzy bylo nutné k&nbsp;těmto čipům přidat vyrovnávací paměti (<i>cache</i>), jelikož rychlost procesorů rostla mnohem rychleji, než vybavovací doba pamětí. Tento rozpor mezi rychlostmi obou nejdůležitějších součástí moderních počítačů ostatně trvá dodnes. Pro další zvýšení výpočetního výkonu však bylo nutné použít další technologie, například minule zmíněnou instrukční sadu <i>VLIW</i>, která však &ndash; opět &ndash; měla velké nároky na rychlost pamětí. Podobně jako u procesorů <i>RISC</i>, i u <i>VLIW</i> bylo pro zmírnění požadavků na rychlost pamětí možné použít Harvardskou architekturu, tj.&nbsp;odděleni paměti programu od paměti dat (programová paměť navíc mohla mít větší šířku datové sběrnice odpovídající šířce instrukčních slov).</p>



<p><a name="k02"></a></p>
<h2 id="k02">2. </h2>

<p>Všechny CISCové mikroprocesory firmy Intel řady <i>80x86</i>, od ještě z&nbsp;poloviny osmibitového čipu <i>Intel 8088</i> až po model <i>Intel 80486</i> (včetně) byly založeny na skalární architektuře <i>SISD</i>, stejně jako velké množství mikrořadičů či digitálních signálových procesorů (<i>DSP &ndash; Digital Signal Processor</i>). Nevýhodou systémů <strong>SISD</strong> ovšem je, že rychlost načítání a tím i zpracování instrukcí je shora omezena a že ani s&nbsp;využitím velmi dlouhé instrukční pipeline se nedá &ndash; vcelku logicky &ndash; překonat limit jedné zpracované instrukce za jeden takt. Příliš velké množství řezů (<i>slices</i>) pipeline má naopak i své zápory, především při zpracování skoků, návratů z&nbsp;podprogramů či odezvy na přerušení &ndash; ve všech těchto případech je nutné vyřešit problém, co se má udělat s&nbsp;instrukcemi, které se nachází v&nbsp;rozpracovaném stavu v&nbsp;pipeline (mohou se buď zahodit nebo naopak dokončit, podle toho, jakým způsobem byl lineární běh programu přerušen).</p>

<a href="http://i.iinfo.cz/images/311/pc158-5.png"><img src="http://i.iinfo.cz/images/311/pc158-5-prev.png" width="259" height="270" alt="&#160;" /></a>
<p><i>Obrázek 5: Schéma systému patřícího do kategorie SISD.</i></p>

<p>V&nbsp;současnosti se těší značné popularitě procesory patřící do kategorie <strong>SIMD</strong>, jejíž kořeny ovšem sahají hluboko do minulosti, konkrétně do šedesátých a sedmdesátých let minulého století (tato oblast výpočetní techniky je spojena se <i>Symourem Crayem</i> a jeho superpočítači).  Do této kategorie patří ty architektury procesorů, u kterých se pomocí jedné instrukce může zpracovat větší množství dat. Například u rozšířené instrukční sady <strong>MMX</strong> je možné pomocí jediné instrukce provést součet dvou vektorů číselných hodnot. Může se jednat o osm osmibitových hodnot uložených v&nbsp;jednom vektoru, čtyři šestnáctibitové hodnoty v&nbsp;jednom vektoru atd.  Této vlastnosti se dá v&nbsp;mnoha případech využít pro urychlení běhu programů, protože některé algoritmy (ve skutečnosti je těchto algoritmů možná až udivující počet) provádí velké množství stejných operací s&nbsp;rozsáhlým objemem dat &ndash; například se může jednat o aplikaci konvolučního filtru na rastrový obrázek, zpracování zvukového signálu, vynásobení matice vektorem, vynásobení dvou matic atd.</p>

<a href="http://i.iinfo.cz/images/311/pc158-7.png"><img src="http://i.iinfo.cz/images/311/pc158-7-prev.png" width="205" height="270" alt="&#160;" /></a>
<p><i>Obrázek 7: Schéma systému patřícího do kategorie SIMD.</i></p>

<p>Mezi přednosti čipů náležejících do kategorie <strong>SIMD</strong> patří jak relativně kompaktní instrukční sada, tak i paralelní a tím pádem i rychlý běh mnoha algoritmů, ovšem za cenu větších nároků kladených na programátora, popř.&nbsp;na překladač. Stále jen velmi malé množství programovacích jazyků totiž umožňuje explicitně vyjádřit vektorové či maticové operace (například u překladače Fortranu určeného pro superpočítače <i>Cray</i> bylo v&nbsp;manuálu explicitně řečeno, které jazykové konstrukce se budou skutečně provádět ve vektorové &ndash; <strong>SISD</strong> &ndash; jednotce). Z&nbsp;tohoto důvodu také není možné většinu <strong>SIMD</strong> konstrukcí zapsat v&nbsp;konvenčním vyšším programovacím jazyce: musí se použít buď hotová makra, ručně optimalizované knihovní funkce nebo specializované programovací jazyky.  Určitou, ale nezanedbatelnou výjimku představují <strong>GPU</strong> na grafických akcelerátorech, které explicitně pracují s&nbsp;2D a 3D vektory, přičemž programátor může předem zjistit, které operace budou skutečně provedeny paralelně.</p>

<a href="http://i.iinfo.cz/images/311/pc158-8.jpg"><img src="http://i.iinfo.cz/images/311/pc158-8-prev.jpg" width="370" height="155" alt="&#160;" /></a>
<p><i>Obrázek 8: Typy vektorů, s&nbsp;nimiž pracují instrukce MMX.</i></p>



<p><a name="k03"></a></p>
<h2 id="k03">3. Architektura x86-64 s&nbsp;nepřeberným množstvím skupin SIMD instrukcí</h2>

<p>Jak jsme se již několikrát zmínili v&nbsp;předchozích odstavcích, jsou v&nbsp;soudobých typech mikroprocesorů implementovány i některé vektorové instrukce (popravdě řečeno již celkový počet vektorových instrukcí pravděpodobně překročil počet instrukcí skalárních :-). Pokud prozatím zůstaneme u platformy <i>x86</i>, tak historicky první instrukční sadou (přesněji řečeno doplněním původní instrukční sady) s&nbsp;podporou vektorových operací byla sada instrukcí <strong>MMX</strong>, s&nbsp;níž přišla firma Intel. Tato sada sice umožňovala provádění vektorových operací, ale měla celou řadu omezení, především nízký počet &bdquo;vektorových&ldquo; registrů, které navíc měly malou bitovou šířku a z&nbsp;toho vycházející nízký počet prvků ve vektorech atd. Nevýhodné taktéž bylo, že se pro instrukce <strong>MMX</strong> používaly registry určené původně pro práci s&nbsp;matematickým koprocesorem (FPU), takže současné provádění FP operací a MMX operací bylo minimálně složité. Ovšem poměrně brzy po uvedení sady <strong>MMX</strong> se objevila konkurenční instrukční sada <strong>3Dnow!</strong> firmy AMD, která byla následovaná již zmíněnými sadami <strong>SSE</strong> až <strong>SSE5</strong>. Podrobnější informace o všech těchto instrukčních sadách si řekneme v&nbsp;navazující části tohoto miniseriálu.</p>

<img src="http://i.iinfo.cz/images/311/pc158-13.png" width="200" height="150" alt="&#160;" />
<p><i>Obrázek 15: Dnes již historický mikroprocesor AMD K6-2 implementující mj.&nbsp;i rozšíření instrukční sady nazvané poněkud zvláštně 3Dnow!</i></p>


<table>
<tr><th>Technologie</th><th>Rok uvedení</th></tr>
<tr><td><a href="#k04">MMX</a></td><td>1996</td></tr>
<tr><td>3DNow!</td><td>1998</td></tr>
<tr><td>SSE</td><td>1999</td></tr>
<tr><td>SSE2</td><td>2001</td></tr>
<tr><td>SSE3</td><td>2004</td></tr>
<tr><td>SSSE3</td><td>2006</td></tr>
<tr><td>SSE4</td><td>2006</td></tr>
<tr><td>SSE5</td><td>2007</td></tr>
<tr><td>AVX</td><td>2008</td></tr>
<tr><td>F16C</td><td>2009</td></tr>
<tr><td>XOP </td><td>2009</td></tr>
<tr><td>FMA4</td><td>2011</td></tr>
<tr><td>FMA3</td><td>2012</td></tr>
<tr><td>AVX2</td><td>2013</td></tr>
<tr><td>AVX-512</td><td>2015</td></tr>
<tr><td>AMX</td><td>2022</td></tr>
</table>

<p></p>

<pre>
$ <strong>cat /proc/cpuinfo</strong>
</pre>

<pre>
flags           : fpu vme de pse tsc msr pae mce cx8 apic sep mtrr pge mca cmov
pat pse36 clflush dts acpi mmx fxsr sse sse2 ss ht tm pbe syscall nx pdpe1gb
rdtscp lm constant_tsc art arch_perfmon pebs bts rep_good nopl xtopology
nonstop_tsc cpuid aperfmperf pni pclmulqdq dtes64 monitor ds_cpl vmx smx est
tm2 ssse3 sdbg fma cx16 xtpr pdcm pcid sse4_1 sse4_2 x2apic movbe popcnt
tsc_deadline_timer aes xsave avx f16c rdrand lahf_lm abm 3dnowprefetch
cpuid_fault epb invpcid_single ssbd ibrs ibpb stibp ibrs_enhanced tpr_shadow
vnmi flexpriority ept vpid ept_ad fsgsbase tsc_adjust bmi1 avx2 smep bmi2 erms
invpcid mpx rdseed adx smap clflushopt intel_pt xsaveopt xsavec xgetbv1 xsaves
dtherm ida arat pln pts hwp hwp_notify hwp_act_window hwp_epp md_clear
flush_l1d arch_capabilities
</pre>



<p><a name="k04"></a></p>
<h2 id="k04">4. Instrukční sada MMX: první pokus o použití SIMD na platformě x86</h2>

<p>První rozšiřující instrukční sadou obsahující <i>SIMD</i> operace, kterou si v&nbsp;tomto článku alespoň stručně popíšeme, je sada instrukcí nazvaná <i>MMX</i> (<i>MultiMedia eXtension</i>, později taktéž rozepisováno jako <i>Matrix Math eXtension</i>). Tato sada byla navržena v&nbsp;roce 1996 ve firmě Intel a od roku 1997 jí začaly být vybavovány prakticky všechny nové procesory této firmy, které patřily do rodiny <i>x86</i> (připomeňme si, že se jednalo o 32bitové mikroprocesory, protože k&nbsp;rozšíření na 64bitovou ALU došlo u mainstreamových čipů až o několik let později). Prvním procesorem s&nbsp;podporou <i>MMX</i> byl čip <i>Pentium P55C</i> nabízený od začátku roku 1997. Později došlo k&nbsp;implementaci <i>MMX</i> i na čipy <i>Pentium II</i> a procesory konkurenčních společností, konkrétně na čipy <i>AMD K6</i> a taktéž na <i>Cyrix M2 (6x86MX</i>) a <i>IDT C6</i>. Na tomto místě je nutné říci, že se vlastně nejednalo o nijak přelomovou technologii, protože v&nbsp;instrukční sadě <i>MMX</i> jsou použity instrukce  analogické instrukcím ze <i>SPARC VIS</i> (VIS=Visual Instruction Set), <i>MIPS MDMX</i> či <i>HP-PA MAX-1</i> a <i>HP-PA MAX-2</i> (opět se tedy jedná o technologii inspirovanou RISCovými procesory).</p>

<img src="http://i.iinfo.cz/images/161/pc159-1.png" width="282" height="150" alt="&#160;" />
<p><i>Obrázek 3: Jedna z&nbsp;poměrně složitých, ale užitečných instrukcí z&nbsp;instrukční sady MMX. Jedná se o instrukci <strong>PMADDWD</strong>, která provádí paralelní součin čtveřice šestnáctibitových hodnot s&nbsp;32 bitovým mezivýsledkem, s&nbsp;následným součtem prvního + druhého a třetího + čtvrtého mezivýsledku.  Tuto instrukci lze použít například při implementaci konvolučních filtrů.<br />
(Zdroj: Intel MMX<sup>TM</sup> Technology Overview, Intel corporation, 1996)</i></p>

<p>Jedním z&nbsp;důvodů zavedení těchto nových instrukcí byla snaha firmy Intel o konstrukci osobních počítačů s&nbsp;minimálním množstvím specializovaných čipů na základní desce i na přídavných kartách. Většinu operací měl totiž provádět samotný mikroprocesor, ať již se jednalo o zpracování zvuku (softwarový mix), ovládání periferních zařízení (programová implementace bufferů atd.) tak i o softwarovou implementaci kodeků, včetně kodeků používaných v&nbsp;modemech (právě v&nbsp;té době došlo k&nbsp;rozvoji takzvaných softwarových modemů, jejichž příslušenství se zúžilo na pouhé rozhraní pro analogovou telefonní linku). V&nbsp;rámci instrukční sady <i>MMX</i> se na původně prakticky ryze skalární platformu <i>x86</i> přidalo celkem 57 nových instrukcí a čtyři datové typy, které byly těmito instrukcemi podporovány. Jeden z&nbsp;nově zaváděných datových typů je skalární, další tři nové datové typy jsou představovány dvouprvkovým, čtyřprvkovým a osmiprvkovým vektorem.</p>

<img src="http://i.iinfo.cz/images/161/pc159-2.png" width="438" height="154" alt="&#160;" />
<p><i>Obrázek 4: Ukázka jednoho typu konverzní funkce, kterých se v&nbsp;instrukční sadě MMX nachází několik.<br />
(Zdroj: Intel MMX<sup>TM</sup> Technology Overview, Intel corporation, 1996)</i></p>

<p>Většina nových instrukcí přidaných v&nbsp;rámci sady <i>MMX</i> byla určena pro provádění aritmetických a bitových operací s&nbsp;celočíselnými operandy o šířce 8, 16, 32 či 64 bitů, což pokrývá poměrně širokou oblast multimediálních dat &ndash; osmibitových i šestnáctibitových zvukových vzorků (samplů), barev pixelů (RGB, RGBA) atd. Zatímco při provádění aritmetických operací s&nbsp;využitím klasické aritmeticko-logické jednotky mohlo docházet k&nbsp;přetečení či podtečení hodnot při provádění instrukcí typu <strong>ADD</strong> či <strong>SUB</strong> (součet, rozdíl), je možné u <i>MMX</i> instrukcí zvolit i takzvanou aritmetiku se <i>saturací</i>, což znamená, že v&nbsp;případě přetečení se do výsledku uloží maximální reprezentovatelná hodnota a naopak při podtečení minimální hodnota, což je například při zpracování signálu (většinou) žádoucí chování, V&nbsp;následující tabulce jsou vypsány nově podporované datové typy i způsob jejich uložení ve slovech o šířce 64 bitů, které jsou zpracovávány jednotkou <i>MMX</i>:</p>

<table>
<tr><th>Datový typ</th><th>Bitová šířka operandu</th><th>Počet prvků vektoru</th></tr>
<tr><td>packed byte</td><td>8 bitů</td><td>8</td></tr>
<tr><td>packed word</td><td>16 bitů</td><td>4</td></tr>
<tr><td>packed doubleword</td><td>32 bitů</td><td>2</td></tr>
<tr><td>quadword</td><td>64 bitů</td><td>1</td></tr>
</table>

<img src="http://i.iinfo.cz/images/161/pc159-3.png" width="312" height="156" alt="&#160;" />
<p><i>Obrázek 5: Ukázka chování MMX instrukce <strong>PADDW</strong>, která provádí součet čtveřice šestnáctibitových hodnot s&nbsp;přetečením, což je patrné z&nbsp;posledního sloupce.<br />
(Zdroj: Intel MMX<sup>TM</sup> Technology Overview, Intel corporation, 1996)</i></p>

<p>Kromě přímé manipulace s&nbsp;celočíselnými hodnotami bylo relativně snadné pracovat i s&nbsp;numerickými hodnotami ukládanými ve formátu s&nbsp;pevnou řádovou čárkou (<i>FX &ndash; fixed point</i>), mohlo se například jednat o formáty 8.8 (osm bitů pro uložení celé části a osm bitů za řádovou čárkou), 8.24, 24.8 atd. O případné bitové posuny při normalizaci numerických hodnot se v&nbsp;tomto případě musel starat programátor. Tyto formáty byly a jsou využívány v&nbsp;některých algoritmech implementujících <i>FFT</i> (rychlou Fourierovu transformaci využívanou v&nbsp;mnoha algoritmech pro zpracování signálů), <i>DCT</i> (diskrétní kosinovou transformaci využívanou například ve formátu JFIF-JPEG), <i>FIR</i>, <i>IIR</i> (filtry s&nbsp;konečnou a nekonečnou impulsní odezvou), operacemi nad vektory či operacemi nad maticemi.</p>

<img src="http://i.iinfo.cz/images/161/pc159-4.png" width="312" height="156" alt="&#160;" />
<p><i>Obrázek 6: MMX instrukce <strong>PADDUSW</strong>, která sice také provádí součet čtveřice šestnáctibitových hodnot, ovšem součet je proveden se saturací &ndash; v&nbsp;případě, že se výsledek součtu již nemůže reprezentovat šestnáctibitovou hodnotou, uloží se namísto výsledku hodnota 0xFFFF, tj.&nbsp;nejvyšší šestnáctibitové celé číslo bez znaménka.<br />
(Zdroj: Intel MMX<sup>TM</sup> Technology Overview, Intel corporation, 1996)</i></p>

<p>Všech 57 instrukcí v&nbsp;instrukční sadě <i>MMX</i> lze rozdělit podle jejich funkce do několika skupin vypsaných v&nbsp;následující tabulce:</p>

<table>
<tr><th>#</th><th>Skupina instrukcí</th><th>Příklady instrukcí</th></tr>
<tr><td>1</td><td>Základní aritmetické operace</td><td>PADD, PADDS, PADDUS, PSUBS, PSUBUS, PMULHW, PMULLW</td></tr>
<tr><td>2</td><td>Logické (bitové) operace</td><td>PAND, PANDN, POR, PXOR</td></tr>
<tr><td>3</td><td>Bitové posuny</td><td>PSLL, PSRL, PSRA</td></tr>
<tr><td>4</td><td>Porovnávání</td><td>PCMPEQ, PCMGT</td></tr>
<tr><td>5</td><td>Konverze dat</td><td>PACKUSWB, PACKSS, PUNPCKH, PUNPCKL</td></tr>
<tr><td>6</td><td>Přenosy dat + práce s&nbsp;pamětí</td><td>MOV</td></tr>
<tr><td>7</td><td>Řízení jednotky MMX</td><td>EMMS</td></tr>
</table>

<img src="http://i.iinfo.cz/images/51/pc140-11.png" width="256" height="256" alt=" " />
<p><i>Obrázek 7: Zdrojový rastrový obrázek (známá fotografie Lenny), který tvoří zdroj pro jednoduchý konvoluční (FIR) filtr, jenž zvyšuje hodnoty pixelů o pevně zadanou konstantu (offset).</i></p>

<p>Většina instrukcí uvedených v&nbsp;předchozí tabulce má navíc několik variant v&nbsp;závislosti na tom, s&nbsp;jakými operandy má instrukce ve skutečnosti pracovat. Například u instrukce <strong>PADD</strong> (součet) je možné zvolit, zda se mají sečíst dva osmiprvkové vektory, kde každý prvek má šířku 8 bitů, zda se má provést součet dvou čtyřprvkových vektorů (16bitové prvky), dvou dvouprvkových vektorů (32bitové prvky) či zda se jedná o součet dvojice 64bitových skalárních hodnot. To tedy znamená, že instrukce <strong>PADD</strong> může být reprezentována čtveřicí operačních kódů:</p>

<table>
<tr><th>#</th><th>Instrukce</th><th>Význam</th></tr>
<tr><td>1</td><td>PADDB</td><td>součet dvou vektorů majících osm osmibitových prvků</td></tr>
<tr><td>2</td><td>PADDW</td><td>součet dvou vektorů majících čtyři šestnáctibitové prvky</td></tr>
<tr><td>3</td><td>PADDD</td><td>součet dvou vektorů majících dva 32bitové prvky</td></tr>
<tr><td>4</td><td>PADDQ</td><td>součet dvou 64bitových skalárních hodnot</td></tr>
</table>

<p>Výjimkou z&nbsp;výše uvedeného pravidla jsou instrukce <strong>PAND</strong>, <strong>PANDN</strong>, <strong>POR</strong> a <strong>PXOR</strong>, pomocí nichž lze provádět bitové operace s&nbsp;dvojicí 64bitových slov. Důvod, proč není zapotřebí tyto instrukce dále rozdělovat podle počtu a šířky prvků vektorů, je zřejmý &ndash; tyto operace pracují nad jednotlivými bity, nikoli nad skupinami bitů. Na tomto místě je možná dobré upozornit na instrukci <strong>PANDN</strong> (<i>not-and</i>), která sice není ve většině běžných (skalárních) aritmeticko-logických jednotkách implementována, ovšem v&nbsp;případě zpracování rastrových obrazů se jedná o velmi užitečnou instrukci používanou například při vykreslování spritů atd.</p>

<img src="http://i.iinfo.cz/images/51/pc140-12.png" width="256" height="256" alt=" " />
<p><i>Obrázek 8: Pokud je pro přičtení offsetu použita operace součtu se zanedbáním přenosu (carry), tj.&nbsp;když se počítá systémem &bdquo;modulo N&ldquo; (viz též výše zmíněná instrukce <strong>PADDB</strong>), dochází při překročení maximální hodnoty pixelu (čistě bílá barva) k&nbsp;viditelným chybám.</i></p>



<p><a name="k05"></a></p>
<h2 id="k05">5. Registry MMX, vztah ke standardnímu matematickému koprocesoru</h2>

<p>Inženýři ve firmě <i>Intel</i> stáli při návrhu instrukční sady <i>MMX</i> před požadavkem na vytvoření výkonných instrukcí provádějících SIMD operace, na druhou stranu však bylo nutné šetřit počtem tranzistorů a tím pádem i plochou čipu, na němž byl mikroprocesor vytvořen. Pravděpodobně právě z&nbsp;tohoto důvodu se rozhodli učinit poněkud problematický krok &ndash; navrhli <i>MMX</i> instrukce takovým způsobem, aby mohly pracovat s&nbsp;osmicí 64bitových registrů rozdělených na jeden, dva, čtyři či osm prvků. Ovšem nejednalo se o nové registry rozšiřující původní sadu registrů procesoru Pentium, ale o část registrů využívaných matematickým koprocesorem (<i>FPU</i>). Ten na platformě <i>x86</i> prováděl operace s&nbsp;osmicí 80bitových registrů uspořádaných do zásobníku (u matematického koprocesoru <i>Intel 8087</i> byly používány čistě zásobníkové instrukce, později byly přidány i další adresovací režimy, které umožňovaly registry adresovat přímo, což se ukázalo být výhodnější především kvůli možnostem provádění různých optimalizací).</p>

<img src="http://i.iinfo.cz/images/51/pc140-13.png" width="256" height="256" alt=" " />
<p><i>Obrázek 9: Při použití operace součtu se saturací sice taktéž dojde ke ztrátě informace (vzniknou oblasti s&nbsp;pixely majícími hodnotu 255), ovšem viditelná chyba je mnohem menší, než na předchozím obrázku. Tento filtr by bylo možné realizovat s&nbsp;využitím instrukce <strong>PADDUSB</strong> s&nbsp;rychlostí výpočtu 8 pixelů/instrukci.</i></p>

<p>V&nbsp;případě instrukcí <i>MMX</i> se sice registry adresovaly přímo (popř.&nbsp;se adresovala slova uložená v&nbsp;operační paměti, která mohla tvořit jeden z&nbsp;operandů), ale kvůli tomu, že jak <i>FPU</i>, tak i jednotka <i>MMX</i> pracovala se shodnými registry (horních 16 bitů nebylo využito), bylo současné používání SIMD operací a operací s&nbsp;hodnotami uloženými v&nbsp;systému plovoucí řádové čárky poměrně komplikované, což je škoda, protože právě souběžná práce superskalárního CPU (u mikroprocesorů <i>Pentium</i> byly vytvořeny dvě instrukční pipeline &bdquo;u&ldquo; a &bdquo;v&ldquo;), jednotky <i>MMX</i> a navíc ještě matematického koprocesoru by v&nbsp;mnoha případech mohla vést k&nbsp;citelnému nárůstu výpočetního výkonu. V&nbsp;následující tabulce jsou vypsána jména registrů tak, jak jsou použita v&nbsp;instrukcích matematického koprocesoru, i ve formě používané jednotkou <i>MMX</i>:</p>

<table>
<tr><th>Registr FPU</th><th>bity 79-64</th><th>bity 63-0</th></tr>
<tr><td>ST0</td><td>nepoužito</td><td>MM0</td></tr>
<tr><td>ST1</td><td>nepoužito</td><td>MM1</td></tr>
<tr><td>ST2</td><td>nepoužito</td><td>MM2</td></tr>
<tr><td>ST3</td><td>nepoužito</td><td>MM3</td></tr>
<tr><td>ST4</td><td>nepoužito</td><td>MM4</td></tr>
<tr><td>ST5</td><td>nepoužito</td><td>MM5</td></tr>
<tr><td>ST6</td><td>nepoužito</td><td>MM6</td></tr>
<tr><td>ST7</td><td>nepoužito</td><td>MM7</td></tr>
</table>

<a href="http://i.iinfo.cz/images/311/pc158-8.jpg"><img src="http://i.iinfo.cz/images/311/pc158-8-prev.jpg" width="370" height="155" alt="&#160;" /></a>
<p><i>Obrázek 10: Typy vektorů, s&nbsp;nimiž pracují instrukce MMX.</i></p>



<p><a name="k06"></a></p>
<h2 id="k06">6. SIMD instrukce v&nbsp;instrukční sadě 3DNow!</h2>

<p>Rozšíření instrukční sady procesorů z&nbsp;rodiny <i>x86</i> o instrukce <i>MMX</i> bylo poměrně razantní &ndash; jednalo se v&nbsp;podstatě o největší změnu této architektury od vzniku procesoru <i>80386</i>, tj.&nbsp;od zavedení virtuálního režimu, 32bitových registrů a operací s&nbsp;32 bitovými hodnotami.  Z&nbsp;hlediska společnosti <i>Intel</i> se samozřejmě jednalo o nemalou konkurenční výhodu získanou  nad firmami <i>AMD</i>, <i>Cyrix</i> či <i>IDT</i>, zejména poté, co se podpora <i>MMX</i> operací zařadila do některých programových produktů (například do zásuvných modulů Photoshopu). Ovšem tehdejší druhý největší výrobce čipů <i>x86</i> &ndash; společnost <i>AMD</i> &ndash; o necelé dva roky později představila vlastní rozšíření instrukční sady, které bylo označeno poměrně nabubřelým názvem <i>3DNow!</i> (včetně onoho vykřičníku na konci). Toto rozšíření instrukční sady bylo poprvé implementováno v&nbsp;mikroprocesoru <i>AMD K6-2</i> a později též v&nbsp;<i>AMD K6-3</i> a <i>Athlon</i>.</p>



<p><a name="k07"></a></p>
<h2 id="k07">7. </h2>



<p><a name="k08"></a></p>
<h2 id="k08">8. </h2>



<p><a name="k09"></a></p>
<h2 id="k09">9. </h2>



<p><a name="k10"></a></p>
<h2 id="k10">10. </h2>



<p><a name="k11"></a></p>
<h2 id="k11">11. </h2>



<p><a name="k12"></a></p>
<h2 id="k12">12. </h2>



<p><a name="k13"></a></p>
<h2 id="k13">13. </h2>



<p><a name="k14"></a></p>
<h2 id="k14">14. </h2>



<p><a name="k15"></a></p>
<h2 id="k15">15. </h2>



<p><a name="k16"></a></p>
<h2 id="k16">16. </h2>



<p><a name="k17"></a></p>
<h2 id="k17">17. </h2>



<p><a name="k18"></a></p>
<h2 id="k18">18. </h2>



<p><a name="k19"></a></p>
<h2 id="k19">19. Repositář s&nbsp;demonstračními příklady</h2>



<p><a name="k20"></a></p>
<h2 id="k20">20. Odkazy na Internetu</h2>

<ol>
</ol>



<p></p><p></p>
<p><small>Autor: <a href="http://www.fit.vutbr.cz/~tisnovpa">Pavel Tišnovský</a> &nbsp; 2022</small></p>
</body>
</html>

