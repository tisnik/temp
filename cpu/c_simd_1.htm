<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
        "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html>
<head>
<title>Užitečné rozšíření GCC - podpora SIMD (vektorových) instrukcí</title>
<meta name="Author" content="Pavel Tisnovsky" />
<meta name="Generator" content="vim" />
<meta http-equiv="content-type" content="text/html; charset=utf-8" />
<style type="text/css">
         body {color:#000000; background:#ffffff;}
         h1  {font-family: arial, helvetica, sans-serif; color:#ffffff; background-color:#c00000; text-align:center; padding-left:1em}
         h2  {font-family: arial, helvetica, sans-serif; color:#ffffff; background-color:#0000c0; padding-left:1em; text-align:left}
         h3  {font-family: arial, helvetica, sans-serif; color:#000000; background-color:#c0c0c0; padding-left:1em; text-align:left}
         h4  {font-family: arial, helvetica, sans-serif; color:#000000; background-color:#e0e0e0; padding-left:1em; text-align:left}
         a   {font-family: arial, helvetica, sans-serif;}
         li  {font-family: arial, helvetica, sans-serif; color:#000000; text-align:justify; width:450px;}
         ol  {font-family: arial, helvetica, sans-serif; color:#000000; text-align:justify; width:450px;}
         ul  {font-family: arial, helvetica, sans-serif; color:#000000; text-align:justify; width:450px;}
         p   {font-family: arial, helvetica, sans-serif; color:#000000; text-align:justify;}
         pre {background:#e0e0e0}
</style>
</head>

<body>

<h1>Užitečné rozšíření GCC - podpora SIMD (vektorových) instrukcí</h1>

<h3>Pavel Tišnovský</h3>

<p></p>

<h1>Úvodník</h1>

<p>S rostoucím počtem tranzistorů na ploše mikroprocesorů (Moorův zákon) se postupně mění i jejich architektura. Kromě přidávání procesorových jader dochází k zavádění SIMD instrukcí, které dokážou jednu operaci provádět s celým vektorem dat. Dnes si ukážeme, jak tyto instrukce využít v GCC.</p>



<h2>Obsah</h2>

<p><a href="#k01">1. Nepřímý důsledek Moorova zákona &ndash; SIMD instrukce</a></p>
<p><a href="#k02">2. Od klasické von Neumannovy architektury k&nbsp;paralelním výpočtům</a></p>
<p><a href="#k03">3. Architektura x86-64 s&nbsp;nepřeberným množstvím skupin SIMD instrukcí</a></p>
<p><a href="#k04">4. Instrukční sada MMX: první pokus o použití SIMD na platformě x86</a></p>
<p><a href="#k05">5. Registry MMX, vztah ke standardnímu matematickému koprocesoru</a></p>
<p><a href="#k06">6. SIMD instrukce v&nbsp;rozšiřující instrukční sadě 3DNow!</a></p>
<p><a href="#k07">7. Registry používané v&nbsp;rozšíření 3DNow!</a></p>
<p><a href="#k08">8. Nové SIMD instrukce v&nbsp;rozšíření 3DNow!</a></p>
<p><a href="#k09">9. SIMD instrukce v&nbsp;rozšíření SSE</a></p>
<p><a href="#k10">10. Sada registrů použitelná vývojáři pracujícími s&nbsp;procesory podporujícími SSE</a></p>
<p><a href="#k11">11. Nové instrukce přidané v&nbsp;technologii SSE</a></p>
<p><a href="#k12">12. Rozšíření instrukční sady SSE2</a></p>
<p><a href="#k13">13. Nové instrukce přidané v&nbsp;rámci rozšíření instrukční sady SSE2</a></p>
<p><a href="#k14">14. Seznam všech instrukcí SSE2</a></p>
<p><a href="#k15">15. Podpora SIMD instrukcí v&nbsp;GCC &ndash; vektorová rozšíření</a></p>
<p><a href="#k16">16. Základní aritmetické operace s&nbsp;vektory</a></p>
<p><a href="#k17">17. Přístup k&nbsp;prvkům vektorů</a></p>
<p><a href="#k18">18. Vektory s&nbsp;hodnotami s&nbsp;plovoucí řádovou čárkou</a></p>
<p><a href="#k19">19. Repositář s&nbsp;demonstračními příklady</a></p>
<p><a href="#k20">20. Odkazy na Internetu</a></p>



<p><a name="k01"></a></p>
<h2 id="k01">1. Nepřímý důsledek Moorova zákona &ndash; SIMD instrukce</h2>

<p><i>"...sequential computers are approaching a fundamental physical limit on
their potential power. Such a limit is the speed of light..."</i></p>

<p>V&nbsp;dnešním článku si ukážeme, jakým způsobem je možné v&nbsp;GCC
(přesněji řečeno v&nbsp;překladači C, který patří do rodiny překladačů GCC)
používat SIMD instrukce, které jsou zde souhrnně nazývány (i když ne zcela
přesně) <i>vektorové instrukce</i>. Přitom SIMD/vektorové instrukce
v&nbsp;současnosti patří ke standardní výbavě prakticky všech variant moderních
mikroprocesorů. Připomeňme si, že z&nbsp;hlediska dosahovaného výpočetního
výkonu leží na samém &bdquo;výkonnostním dně&ldquo; klasické mikroprocesory
s&nbsp;architekturou <i>CISC</i>, které vykonávají všechny instrukce postupně a
dokončení jedné instrukce může v&nbsp;závislosti na jejich složitosti trvat i
několik desítek strojových taktů. Předností těchto procesorů může být poměrně
velká informační hustota instrukční sady (například i díky tomu, že operandy
některých instrukcí jsou zadány implicitně), což mj.&nbsp;znamená, že se
procesory tohoto typu po poměrně dlouhou dobu obešly bez nutnosti využití
drahých vyrovnávacích pamětí první a druhé úrovně (<i>L1 cache</i>, <i>L2
cache</i>). Klasické procesory s&nbsp;architekturou <i>CISC</i> byly založeny
na mikroprogramovém řadiči vybaveném pamětí mikroinstrukcí a teprve později
začaly být tyto procesory doplňovány technologiemi získanými z&nbsp;jiných
architektur &ndash; instrukční pipeline, prediktorem skoků, vektorovými
instrukcemi (což byly oblasti klasických RISCových architektur) atd.</p>

<img src="http://i.iinfo.cz/images/311/pc158-1.png" width="450" height="310" alt="&#160;" />
<p><i>Obrázek 1: Ukázka časování instrukce ADC (Add with carry) dnes již
klasického osmibitového mikroprocesoru MOS 6502 s&nbsp;architekturou CISC.
V&nbsp;závislosti na zvoleném adresním režimu se liší počty strojových cyklů od
dvou do šesti. Liší se samozřejmě i počet bajtů nutných pro zakódování
instrukce, protože některé adresní režimy vyžadují zápis absolutní 16bitové
adresy a jiné režimy používají jen 8bitový offset, popř.&nbsp;osmibitovou
adresu v&nbsp;rámci takzvané nulté stránky (zero page).</i></p>

<p>Výpočetní výkon mikroprocesorů se podařilo poměrně výrazným způsobem zvýšit
u architektury <i>RISC</i> zavedením <i>instrukční pipeline</i>. Provedení
jedné instrukce sice stále trvalo větší počet strojových cyklů, ovšem díky
rozfázování operací v&nbsp;instrukční pipeline bylo umožněno překrývání většího
množství instrukcí, a to bez nutnosti zavádění skutečné paralelizace (která
vede k&nbsp;velkému nárůstu složitosti a tím i ceny čipu). Spolu se zavedením
mikroprocesorů <i>RISC</i> se skutečně stalo, že reálný i špičkový výpočetní
výkon procesorů vzrostl, ale relativně brzy bylo nutné k&nbsp;těmto čipům
přidat vyrovnávací paměti (<i>cache</i>), jelikož rychlost procesorů rostla
mnohem rychleji, než vybavovací doba pamětí. Tento rozpor mezi rychlostmi obou
nejdůležitějších součástí moderních počítačů ostatně trvá dodnes.</p>

<p>Pro další zvýšení výpočetního výkonu však bylo nutné použít další
technologie, například instrukční sadu <i>VLIW</i>, která však &ndash; opět
&ndash; měla velké nároky na rychlost pamětí. Podobně jako u procesorů
<i>RISC</i>, i u <i>VLIW</i> bylo pro zmírnění požadavků na rychlost pamětí
možné použít Harvardskou architekturu, tj.&nbsp;odděleni paměti programu od
paměti dat (programová paměť navíc mohla mít větší šířku datové sběrnice
odpovídající šířce instrukčních slov). Další zvýšení výkonu umožňují právě
vektorové instrukce (SIMD), které ale mají jeden poměrně zásadní nedostatek
&ndash; sémantickou mezeru mezi imperativním &bdquo;skalárním&ldquo; kódem
psaným například v&nbsp;C (C++ atd.) a instrukční sadou, která je SIMD (jinými
slovy &ndash; běžné programovací jazyky neumožňují dostatečně popsat vektorové
operace). Tuto mezeru do určité míry vyplňuje právě rozšíření GCC, kterému se
budeme věnovat.</p>



<p><a name="k02"></a></p>
<h2 id="k02">2. Od klasické von Neumannovy architektury k&nbsp;paralelním výpočtům</h2>

<p>Všechny CISCové mikroprocesory firmy Intel řady <i>80x86</i>, od ještě
z&nbsp;poloviny osmibitového čipu <i>Intel 8088</i> (právě ten byl použit
v&nbsp;IBM PC, které tak není čistě 16bitovou architekturou), až po model
<i>Intel 80486</i> (včetně) byly založeny na skalární architektuře <i>SISD</i>,
stejně jako velké množství dobových mikrořadičů či digitálních signálových
procesorů (<i>DSP &ndash; Digital Signal Processor</i>). Nevýhodou systémů
<strong>SISD</strong> ovšem je, že rychlost načítání a tím i zpracování
instrukcí je shora omezena a že ani s&nbsp;využitím velmi dlouhé instrukční
pipeline se nedá &ndash; vcelku logicky &ndash; překonat limit jedné zpracované
instrukce za jeden takt. Příliš velké množství řezů (<i>slices</i>) pipeline má
naopak i své zápory, především při zpracování skoků, návratů z&nbsp;podprogramů
či odezvy na přerušení &ndash; ve všech těchto případech je nutné vyřešit
problém, co se má udělat s&nbsp;instrukcemi, které se nachází
v&nbsp;rozpracovaném stavu v&nbsp;pipeline (mohou se buď zahodit nebo naopak
dokončit, podle toho, jakým způsobem byl lineární běh programu přerušen).  To
čipy komplikuje, vyžaduje kvalitní prediktory skoků, kvalitní překladače
atd.</p>

<a href="http://i.iinfo.cz/images/311/pc158-5.png"><img src="http://i.iinfo.cz/images/311/pc158-5-prev.png" width="259" height="270" alt="&#160;" /></a>
<p><i>Obrázek 2: Schéma systému patřícího do kategorie SISD.</i></p>

<p>V&nbsp;současnosti se těší značné popularitě mikroprocesory patřící do
kategorie <strong>SIMD</strong>, jejíž kořeny ovšem sahají hluboko do
minulosti, konkrétně do šedesátých a sedmdesátých let minulého století (tato
oblast výpočetní techniky je spojena se <i>Symourem Crayem</i> a jeho slavnými
superpočítači &ndash; ty byly skutečně <i>vektorové</i>). Do této kategorie
patří ty architektury procesorů, u kterých se s&nbsp;využitím jediné instrukce
může zpracovat větší množství dat. Například u rozšířené instrukční sady
<strong>MMX</strong>, s&nbsp;níž se seznámíme níže, je možné pomocí jediné
instrukce provést součet dvou vektorů číselných hodnot. Může se jednat o osm
osmibitových hodnot uložených v&nbsp;jednom vektoru, čtyři šestnáctibitové
hodnoty v&nbsp;jednom vektoru atd. A u SSE/SSE2 jsou délky vektorů ještě
násobně větší. Této vlastnosti se dá v&nbsp;mnoha případech využít pro
urychlení běhu programů, protože některé algoritmy (ve skutečnosti je těchto
algoritmů možná až udivující počet) provádí velké množství stejných operací
s&nbsp;rozsáhlým objemem dat &ndash; například se může jednat o aplikaci
konvolučního filtru na rastrový obrázek, zpracování zvukového signálu,
vynásobení matice vektorem, vynásobení dvou matic atd.</p>

<a href="http://i.iinfo.cz/images/311/pc158-7.png"><img src="http://i.iinfo.cz/images/311/pc158-7-prev.png" width="205" height="270" alt="&#160;" /></a>
<p><i>Obrázek 3: Schéma systému patřícího do kategorie SIMD.</i></p>

<p>Mezi přednosti čipů náležejících do kategorie <strong>SIMD</strong> patří
jak relativně kompaktní instrukční sada (což ovšem není případ x86 a x86-64!),
tak i paralelní a tím pádem i rychlý běh mnoha algoritmů, ovšem za cenu větších
nároků kladených na programátora, popř.&nbsp;na překladač. Stále jen poměrně
velmi malé množství programovacích jazyků totiž umožňuje explicitně vyjádřit
vektorové či maticové operace (například u překladače Fortranu určeného pro
superpočítače <i>Cray</i> bylo v&nbsp;manuálu explicitně řečeno, které jazykové
konstrukce se budou skutečně provádět ve vektorové &ndash;
<strong>SIMD</strong> &ndash; jednotce). Z&nbsp;tohoto důvodu také není možné
většinu <strong>SIMD</strong> konstrukcí zapsat v&nbsp;konvenčním vyšším
programovacím jazyce: musí se použít buď hotová makra, ručně optimalizované
knihovní funkce nebo specializované programovací jazyky (popř.&nbsp;de facto
rozšíření typového systému, které si uvedeme v&nbsp;dnešním článku). Určitou,
ale nezanedbatelnou výjimku představují <strong>GPU</strong> na grafických
akcelerátorech, které explicitně pracují s&nbsp;2D a 3D vektory, přičemž
programátor může předem zjistit, které operace budou skutečně provedeny
paralelně.</p>

<a href="http://i.iinfo.cz/images/311/pc158-8.jpg"><img src="http://i.iinfo.cz/images/311/pc158-8-prev.jpg" width="370" height="155" alt="&#160;" /></a>
<p><i>Obrázek 4: Typy vektorů, s&nbsp;nimiž pracují instrukce MMX.</i></p>



<p><a name="k03"></a></p>
<h2 id="k03">3. Architektura x86-64 s&nbsp;nepřeberným množstvím skupin SIMD instrukcí</h2>

<p>Jak jsme se již několikrát zmínili v&nbsp;předchozích odstavcích, jsou
v&nbsp;soudobých typech mikroprocesorů implementovány i některé vektorové
instrukce (popravdě řečeno již celkový počet vektorových instrukcí
pravděpodobně překročil počet instrukcí skalárních, a to pravděpodobně
několikanásobně :-). Pokud prozatím zůstaneme u platformy <i>x86</i>, tak
historicky první instrukční sadou (přesněji řečeno doplněním původní instrukční
sady) s&nbsp;podporou vektorových operací byla sada instrukcí
<strong>MMX</strong>, s&nbsp;níž přišla firma Intel. Tato sada sice umožňovala
provádění vektorových operací, ale měla celou řadu omezení, především nízký
počet &bdquo;vektorových&ldquo; registrů, které navíc měly (z&nbsp;dnešního
pohledu) malou bitovou šířku a z&nbsp;toho vycházející nízký počet prvků
umístitelných ve vektorech atd. Nevýhodné taktéž bylo, že se pro instrukce
<strong>MMX</strong> používaly registry určené původně pro práci
s&nbsp;matematickým koprocesorem (FPU), takže současné provádění FP operací a
MMX operací bylo minimálně složité; většinou i zcela nepraktické. Ovšem poměrně
brzy po uvedení sady <strong>MMX</strong> se objevila konkurenční instrukční
sada <strong>3Dnow!</strong> firmy AMD, která byla následovaná již zmíněnými
sadami <strong>SSE</strong> až <strong>SSE5</strong>. Podrobnější informace o
všech těchto instrukčních sadách si řekneme v&nbsp;navazujících kapitolách.</p>

<img src="http://i.iinfo.cz/images/311/pc158-13.png" width="200" height="150" alt="&#160;" />
<p><i>Obrázek 5: Dnes již historický mikroprocesor AMD K6-2 implementující mj.&nbsp;i rozšíření instrukční sady nazvané poněkud zvláštně 3Dnow!</i></p>

<p>Zkusme se nyní podívat na seznam různých SIMD (neboli nesprávně řečeno
&bdquo;vektorových&ldquo;) rozšíření původní instrukční sady x86:</p>

<table>
<tr><th>Technologie</th><th>Rok uvedení</th><th>Společnost</th><th>Poprvé použito v&nbsp;čipu</th></tr>
<tr><td><a href="#k04">MMX</a></td><td>1996</td><td>Intel</td><td>Intel Pentium P5</td></tr>
<tr><td><a href="#k06">3DNow!</a></td><td>1998</td><td>AMD</td><td>AMD K6-2</td></tr>
<tr><td><a href="#k09">SSE</a></td><td>1999</td><td>Intel</td><td>Intel Pentium III (mikroarchitektura P6)</td></tr>
<tr><td><a href="#k12">SSE2</a></td><td>2001</td><td>Intel</td><td>Intel Pentium 4 (mikroarchitektura NetBurst)</td></tr>
<tr><td>SSE3</td><td>2004</td><td>Intel</td><td>Intel Pentium 4 (Prescott)</td></tr>
<tr><td>SSSE3</td><td>2006</td><td>Intel</td><td>mikroarchitektura Intel Core</td></tr>
<tr><td>SSE4</td><td>2006</td><td>Intel+AMD</td><td>AMD K10 (SSE4a) , mikroarchitektura Intel Core</td></tr>
<tr><td>SSE5</td><td>2007</td><td>AMD</td><td>(nakonec rozděleno do menších celků), mikroarchitektura Bulldozer</td></tr>
<tr><td>AVX</td><td>2008</td><td>Intel</td><td>mikroarchitektura Sandy Bridge</td></tr>
<tr><td>F16C (CVT16)</td><td>2009</td><td>AMD</td><td>Jaguar, Puma, Bulldozer atd.</td></tr>
<tr><td>XOP</td><td>2009</td><td>AMD</td><td>mikroarchitektura Bulldozer</td></tr>
<tr><td>FMA3</td><td>2012</td><td>AMD</td><td>mikroarchitektura Piledriver, Intel: Haswell a Broadwell</td></tr>
<tr><td>FMA4</td><td>2011</td><td>AMD</td><td>mikroarchitektura Bulldozer (pozdější architektury po Zen 1 již ne)</td></tr>
<tr><td>AVX2</td><td>2013</td><td>Intel</td><td>mikroarchitektura Haswell</td></tr>
<tr><td>AVX-512</td><td>2013</td><td>Intel</td><td>Knights Landing</td></tr>
<tr><td>AMX</td><td>2020</td><td>Intel</td><td>Sapphire Rapids</td></tr>
</table>

<p>To, jaká rozšíření instrukční sady podporuje váš mikroprocesor, lze získat
snadno:</p>

<pre>
$ <strong>cat /proc/cpuinfo</strong>
</pre>

<p>V&nbsp;mém konkrétním případě (Intel(R) Core(TM) i7-8665U CPU @ 1.90GHz) se
vypíšou následující vlastnosti CPU. Z&nbsp;těchto příznaků jsem zdůraznil
příznaky odpovídající SIMD instrukcím:</p>

<pre>
flags           : fpu vme de pse tsc msr pae mce cx8 apic sep mtrr pge mca cmov
pat pse36 clflush dts acpi <strong>mmx</strong> fxsr <strong>sse</strong> <strong>sse2</strong> ss ht tm pbe syscall nx pdpe1gb
rdtscp lm constant_tsc art arch_perfmon pebs bts rep_good nopl xtopology
nonstop_tsc cpuid aperfmperf pni pclmulqdq dtes64 monitor ds_cpl vmx smx est
tm2 <strong>ssse3</strong> sdbg <strong>fma</strong> cx16 xtpr pdcm pcid <strong>sse4_1</strong> <strong>sse4_2</strong> x2apic movbe popcnt
tsc_deadline_timer aes xsave <strong>avx</strong> <strong>f16c</strong> rdrand lahf_lm abm <strong>3dnowprefetch</strong>
cpuid_fault epb invpcid_single ssbd ibrs ibpb stibp ibrs_enhanced tpr_shadow
vnmi flexpriority ept vpid ept_ad fsgsbase tsc_adjust bmi1 <strong>avx2</strong> smep bmi2 erms
invpcid mpx rdseed adx smap clflushopt intel_pt xsaveopt xsavec xgetbv1 xsaves
dtherm ida arat pln pts hwp hwp_notify hwp_act_window hwp_epp md_clear
flush_l1d arch_capabilities
</pre>

<p>Pro někoho může být taktéž zajímavá i informace o tom, jak velké změny
v&nbsp;instrukční sadě mikroprocesorů byly vlastně při přidávání nových
&bdquo;vektorových&ldquo; rozšiřujících instrukčních sad typu <i>SIMD</i>
provedeny. To nám ukáže další tabulka. Je pouze nutné dát si pozor na to, že
počty nových instrukcí zavedených v&nbsp;rámci těchto nových technologií, které
jsou vypsány v&nbsp;tabulce pod odstavcem, nemusí přesně souhlasit s&nbsp;počty
uváděnými v&nbsp;jiných informačních materiálech. Je tomu tak především
z&nbsp;toho důvodu, že se v&nbsp;některých případech rozlišuje i datový typ,
s&nbsp;nímž instrukce pracují (například se může jednat o součet vektoru
s&nbsp;32 bitovými hodnotami nebo 64bitovými hodnotami reprezentovanými
v&nbsp;obou případech ve formátu s&nbsp;plovoucí řádovou čárkou) a někdy se
taková instrukce do celkové sumy započítává pouze jedenkrát. Nicméně údaje
vypsané v&nbsp;níže uvedené tabulce by měly být konzistentní, protože se jedná
o počty nově přidaných operačních kódů instrukcí (například u dále popsané
instrukční sady <i>SSE2</i> končí instrukce znakem <strong>D</strong>,
<strong>S</strong>, <strong>I</strong> či <strong>Q</strong> podle typu
zpracovávaných dat/operandů):</p>

<table>
<tr><th>Název technologie</th><th>Počet nových instrukcí</th></tr>
<tr><td>MMX</td><td> 56</td></tr>
<tr><td>3DNow!</td><td> 21</td></tr>
<tr><td>SSE</td><td> 70</td></tr>
<tr><td>SSE2</td><td>144</td></tr>
<tr><td>SSE3</td><td> 13</td></tr>
<tr><td>SSSE3</td><td> 32 (ve skutečnosti vlastně jen 16 instrukcí, ovšem pro dva datové typy)</td></tr>
<tr><td>SSE4</td><td> 54 (z&nbsp;toho 47 v&nbsp;rámci SSE4.1, zbytek v&nbsp;rámci SSE4.2)</td></tr>
<tr><td>SSE5</td><td>170 (z&nbsp;toho 46 základních instrukcí)</td></tr>
<tr><td>F16C</td><td> 4</td></tr>
</table>

<p><div class="rs-tip-major">Poznámka: samostatnou kapitolu představuje
<i>AVX</i> (<i>Advanced Vector Extensions</i>), které bude věnován samostatný
článek.</div></p>



<p><a name="k04"></a></p>
<h2 id="k04">4. Instrukční sada MMX: první pokus o použití SIMD na platformě x86</h2>

<p>První rozšiřující instrukční sadou navrženou pro procesory na platformě x86
(tedy nikoli ještě x86-64), která obsahovala <i>SIMD</i> operace, je sada
instrukcí nazvaná <i>MMX</i> (<i>MultiMedia eXtension</i>, později taktéž
rozepisováno jako <i>Matrix Math eXtension</i>). Tato sada byla navržena již
v&nbsp;roce 1996 ve společnosti Intel a od roku 1997 jí začaly být vybavovány
prakticky všechny nové mikroprocesory této firmy, přesněji řečeno ty
mikroprocesory, které patřily do rodiny <i>x86</i> (připomeňme si, že se
jednalo o 32bitové mikroprocesory, protože k&nbsp;rozšíření na 64bitovou ALU
došlo u mainstreamových čipů až o několik let později). Prvním mikroprocesorem
s&nbsp;plnou podporou <i>MMX</i> byl čip <i>Pentium P55C</i> nabízený od
začátku roku 1997. Později došlo k&nbsp;implementaci instrukční sady <i>MMX</i>
i na čipy <i>Pentium II</i> a procesory konkurenčních společností, konkrétně na
čipy <i>AMD K6</i> a taktéž na <i>Cyrix M2 (6x86MX</i>) a <i>IDT C6</i>.</p>

<p><div class="rs-tip-major">Poznámka: na tomto místě je nutné poznamenat, že
se vlastně nejednalo o nijak přelomovou technologii, protože v&nbsp;instrukční
sadě <i>MMX</i> jsou použity instrukce analogické instrukcím ze <i>SPARC
VIS</i> (VIS=Visual Instruction Set), <i>MIPS MDMX</i> či <i>HP-PA MAX-1</i> a
<i>HP-PA MAX-2</i> (opět se tedy jedná o technologii inspirovanou RISCovými
procesory &ndash; což není nic nového, protože prakticky všechny pokročilejší
techniky byly získány z&nbsp;tohoto zdroje).</div></p>

<img src="http://i.iinfo.cz/images/161/pc159-1.png" width="282" height="150" alt="&#160;" />
<p><i>Obrázek 6: Jedna z&nbsp;poměrně složitých, ale užitečných instrukcí
z&nbsp;instrukční sady MMX. Jedná se konkrétně o instrukci
<strong>PMADDWD</strong>, která provádí paralelní součin čtveřice
šestnáctibitových hodnot s&nbsp;32 bitovým mezivýsledkem, s&nbsp;následným
součtem prvního + druhého a třetího + čtvrtého mezivýsledku. Tuto instrukci lze
použít například při implementaci konvolučních filtrů.<br />
(Zdroj: Intel MMX<sup>TM</sup> Technology Overview, Intel corporation, 1996)</i></p>

<p>Jedním z&nbsp;důvodů zavedení těchto nových instrukcí byla snaha společnosti
Intel o konstrukci osobních počítačů s&nbsp;minimálním množstvím
specializovaných čipů na základní desce i na přídavných kartách. Většinu
operací měl totiž (podle tehdejších představ) provádět samotný mikroprocesor,
ať již se jednalo o zpracování zvuku (softwarový mix), ovládání periferních
zařízení (programová implementace bufferů atd.) tak i o softwarovou
implementaci kodeků, včetně kodeků používaných v&nbsp;modemech (právě v&nbsp;té
době došlo k&nbsp;rozvoji takzvaných softwarových modemů, jejichž příslušenství
se zúžilo na pouhé elektrické rozhraní pro analogovou telefonní linku).
V&nbsp;rámci instrukční sady <i>MMX</i> se na původně prakticky ryze skalární
platformu <i>x86</i> přidalo celkem <strong>57 nových instrukcí</strong> a
čtyři datové typy, které byly těmito instrukcemi podporovány. Jeden z&nbsp;nově
zaváděných datových typů je skalární, další tři nové datové typy jsou
představovány dvouprvkovým, čtyřprvkovým a osmiprvkovým vektorem.</p>

<img src="http://i.iinfo.cz/images/161/pc159-2.png" width="438" height="154" alt="&#160;" />
<p><i>Obrázek 7: Ukázka jednoho typu konverzní funkce, kterých se
v&nbsp;instrukční sadě MMX nachází několik.<br />
(Zdroj: Intel MMX<sup>TM</sup> Technology Overview, Intel corporation, 1996)</i></p>

<p>Většina nových instrukcí přidaných v&nbsp;rámci sady <i>MMX</i> byla určena
pro provádění aritmetických a bitových operací s&nbsp;celočíselnými operandy o
šířce 8, 16, 32 či 64 bitů, což pokrývá poměrně širokou oblast multimediálních
dat &ndash; osmibitových i šestnáctibitových zvukových vzorků (samplů), barev
pixelů (RGB, RGBA) atd. Zatímco při provádění aritmetických operací
s&nbsp;využitím klasické aritmeticko-logické jednotky mohlo docházet
k&nbsp;přetečení či podtečení hodnot při provádění instrukcí typu
<strong>ADD</strong> či <strong>SUB</strong> (součet, rozdíl), je možné u
<i>MMX</i> instrukcí zvolit i takzvanou aritmetiku se <i>saturací</i>, což
znamená, že v&nbsp;případě přetečení se do výsledku uloží maximální
reprezentovatelná hodnota a naopak při podtečení minimální hodnota, což je
například při zpracování signálu (většinou) žádoucí chování, V&nbsp;následující
tabulce jsou vypsány nově podporované datové typy i způsob jejich uložení ve
slovech o šířce 64 bitů, které jsou zpracovávány jednotkou <i>MMX</i>:</p>

<table>
<tr><th>Datový typ</th><th>Bitová šířka operandu</th><th>Počet prvků vektoru</th></tr>
<tr><td>packed byte</td><td>8 bitů</td><td>8</td></tr>
<tr><td>packed word</td><td>16 bitů</td><td>4</td></tr>
<tr><td>packed doubleword</td><td>32 bitů</td><td>2</td></tr>
<tr><td>quadword</td><td>64 bitů</td><td>1</td></tr>
</table>

<img src="http://i.iinfo.cz/images/161/pc159-3.png" width="312" height="156" alt="&#160;" />
<p><i>Obrázek 8: Ukázka chování MMX instrukce nazvané <strong>PADDW</strong>,
která provádí součet čtveřice šestnáctibitových hodnot s&nbsp;přetečením, což
je patrné z&nbsp;posledního sloupce.<br />
(Zdroj: Intel MMX<sup>TM</sup> Technology Overview, Intel corporation, 1996)</i></p>

<p>Kromě přímé manipulace s&nbsp;celočíselnými hodnotami bylo relativně snadné
pracovat i s&nbsp;numerickými hodnotami ukládanými ve formátu s&nbsp;pevnou
řádovou čárkou (<i>FX &ndash; fixed point</i>), mohlo se například jednat o
formáty 8.8 (osm bitů pro uložení celé části a osm bitů za řádovou čárkou),
8.24, 24.8 atd. O případné bitové posuny při normalizaci numerických hodnot se
v&nbsp;tomto případě ovšem musel postarat programátor. Tyto formáty byly a jsou
využívány v&nbsp;některých algoritmech implementujících <i>FFT</i> (rychlou
Fourierovu transformaci využívanou v&nbsp;mnoha algoritmech pro zpracování
signálů), <i>DCT</i> (diskrétní kosinovou transformaci využívanou například ve
formátu JFIF-JPEG), <i>FIR</i>, <i>IIR</i> (filtry s&nbsp;konečnou a nekonečnou
impulsní odezvou), operacemi nad vektory či operacemi nad maticemi.</p>

<img src="http://i.iinfo.cz/images/161/pc159-4.png" width="312" height="156" alt="&#160;" />
<p><i>Obrázek 9: MMX instrukce nazvaná <strong>PADDUSW</strong>, která sice
také provádí součet čtveřice šestnáctibitových hodnot, ovšem součet je proveden
se saturací &ndash; v&nbsp;případě, že se výsledek součtu již nemůže
reprezentovat šestnáctibitovou hodnotou, uloží se namísto výsledku hodnota
0xFFFF, tj.&nbsp;nejvyšší šestnáctibitové celé číslo bez znaménka.<br />
(Zdroj: Intel MMX<sup>TM</sup> Technology Overview, Intel corporation, 1996)</i></p>

<p>Všech 57 instrukcí zavedených v&nbsp;instrukční sadě <i>MMX</i> lze rozdělit
podle jejich funkce do několika skupin vypsaných v&nbsp;následující
tabulce:</p>

<table>
<tr><th>#</th><th>Skupina instrukcí</th><th>Příklady instrukcí</th></tr>
<tr><td>1</td><td>Základní aritmetické operace</td><td>PADD, PADDS, PADDUS, PSUBS, PSUBUS, PMULHW, PMULLW</td></tr>
<tr><td>2</td><td>Logické (bitové) operace</td><td>PAND, PANDN, POR, PXOR</td></tr>
<tr><td>3</td><td>Bitové posuny</td><td>PSLL, PSRL, PSRA</td></tr>
<tr><td>4</td><td>Porovnávání</td><td>PCMPEQ, PCMGT</td></tr>
<tr><td>5</td><td>Konverze dat</td><td>PACKUSWB, PACKSS, PUNPCKH, PUNPCKL</td></tr>
<tr><td>6</td><td>Přenosy dat + práce s&nbsp;pamětí</td><td>MOV</td></tr>
<tr><td>7</td><td>Řízení jednotky MMX</td><td>EMMS</td></tr>
</table>

<img src="http://i.iinfo.cz/images/51/pc140-11.png" width="256" height="256" alt=" " />
<p><i>Obrázek 10: Zdrojový rastrový obrázek (známá fotografie Lenny), který
tvoří zdroj pro jednoduchý konvoluční (FIR) filtr, jenž zvyšuje hodnoty pixelů
o pevně zadanou konstantu (offset).</i></p>

<p>Většina instrukcí uvedených v&nbsp;předchozí tabulce má navíc několik
variant v&nbsp;závislosti na tom, s&nbsp;jakými operandy má instrukce ve
skutečnosti pracovat. Například u instrukce <strong>PADD</strong> (tedy operace
součtu) je možné zvolit, zda se mají sečíst dva osmiprvkové vektory, kde každý
prvek má šířku 8 bitů, zda se má provést součet dvou čtyřprvkových vektorů
(16bitové prvky), dvou dvouprvkových vektorů (32bitové prvky) či zda se jedná o
součet dvojice 64bitových skalárních hodnot. To tedy znamená, že instrukce
<strong>PADD</strong> může být reprezentována čtveřicí různých operačních
kódů:</p>

<table>
<tr><th>#</th><th>Instrukce</th><th>Význam</th></tr>
<tr><td>1</td><td>PADDB</td><td>součet dvou vektorů majících osm osmibitových prvků</td></tr>
<tr><td>2</td><td>PADDW</td><td>součet dvou vektorů majících čtyři šestnáctibitové prvky</td></tr>
<tr><td>3</td><td>PADDD</td><td>součet dvou vektorů majících dva 32bitové prvky</td></tr>
<tr><td>4</td><td>PADDQ</td><td>součet dvou 64bitových skalárních hodnot</td></tr>
</table>

<p>Výjimkou z&nbsp;výše uvedeného pravidla jsou instrukce nazvané
<strong>PAND</strong>, <strong>PANDN</strong>, <strong>POR</strong> a
<strong>PXOR</strong>, pomocí nichž lze provádět bitové operace s&nbsp;dvojicí
64bitových slov. Důvod, proč není zapotřebí tyto instrukce dále rozdělovat
podle počtu a šířky prvků vektorů, je zřejmý &ndash; tyto operace pracují nad
jednotlivými bity, nikoli nad skupinami bitů. Na tomto místě je možná dobré
upozornit na instrukci <strong>PANDN</strong> (<i>not-and</i>), která sice není
ve většině běžných (skalárních) aritmeticko-logických jednotkách
implementována, ovšem v&nbsp;případě zpracování rastrových obrazů se jedná o
velmi užitečnou instrukci používanou například při vykreslování spritů atd.</p>

<img src="http://i.iinfo.cz/images/51/pc140-12.png" width="256" height="256" alt=" " />
<p><i>Obrázek 11: Pokud je pro přičtení offsetu použita operace součtu se
zanedbáním přenosu (carry), tj.&nbsp;když se počítá systémem &bdquo;modulo
N&ldquo; (viz též výše zmíněná instrukce <strong>PADDB</strong>), dochází při
překročení maximální hodnoty pixelu (čistě bílá barva) k&nbsp;viditelným
chybám.</i></p>

<p><div class="rs-tip-major">Shrnutí: MMX je relativně snadno použitelné
rozšíření instrukční sady, které zejména u multimediálních operací vede
k&nbsp;poměrně razantnímu zvýšení výpočetního výkonu.</div></p>



<p><a name="k05"></a></p>
<h2 id="k05">5. Registry MMX, vztah ke standardnímu matematickému koprocesoru</h2>

<p>Inženýři ve firmě <i>Intel</i> stáli při návrhu instrukční sady <i>MMX</i>
před požadavkem na vytvoření výkonných instrukcí provádějících SIMD operace, na
druhou stranu však bylo nutné šetřit počtem tranzistorů a tím pádem i plochou
čipu, na němž byl mikroprocesor vytvořen. Navíc bylo nutné zachovat
kompatibilitu s&nbsp;existujícími programy a operačními systémy, zejména při
ukládání registrů na zásobník v&nbsp;subrutinách atd. Pravděpodobně právě
z&nbsp;tohoto důvodu se rozhodli učinit poněkud problematický krok &ndash;
navrhli <i>MMX</i> instrukce takovým způsobem, aby mohly pracovat s&nbsp;osmicí
64bitových registrů rozdělených na jeden, dva, čtyři či osm prvků. Ovšem
nejednalo se, jak by se dalo předpokládat, o nové registry rozšiřující původní
sadu registrů procesoru Pentium, ale o část registrů využívaných matematickým
koprocesorem (<i>FPU</i>). Ten na platformě <i>x86</i> prováděl operace
s&nbsp;osmicí 80bitových registrů uspořádaných do zásobníku (u matematického
koprocesoru <i>Intel 8087</i> byly používány čistě zásobníkové instrukce,
později byly přidány i další adresovací režimy, které umožňovaly registry
adresovat přímo, což se ukázalo být výhodnější především kvůli možnostem
provádění různých optimalizací).</p>

<img src="http://i.iinfo.cz/images/51/pc140-13.png" width="256" height="256" alt=" " />
<p><i>Obrázek 12: Při použití operace součtu se saturací sice taktéž dojde ke
ztrátě informace (vzniknou oblasti s&nbsp;pixely majícími hodnotu 255), ovšem
viditelná chyba je mnohem menší, než na předchozím obrázku, kde docházelo
k&nbsp;přetečení. Tento filtr by bylo možné realizovat s&nbsp;využitím
instrukce <strong>PADDUSB</strong> s&nbsp;rychlostí výpočtu 8 pixelů/instrukci
při bitové hloubce 8bpp.</i></p>

<p>V&nbsp;případě instrukcí <i>MMX</i> se sice registry adresovaly přímo
(popř.&nbsp;se adresovala slova uložená v&nbsp;operační paměti, která mohla
tvořit jeden z&nbsp;operandů instrukce), ale kvůli tomu, že jak <i>FPU</i>, tak
i jednotka <i>MMX</i> pracovala se shodnými registry (horních 16 bitů těchto
registrů nebylo v&nbsp;MMX využito), bylo současné používání SIMD operací a
operací s&nbsp;hodnotami uloženými v&nbsp;systému plovoucí řádové čárky poměrně
komplikované, což je škoda, protože právě souběžná práce superskalárního CPU (u
mikroprocesorů <i>Pentium</i> byly vytvořeny dvě instrukční pipeline
&bdquo;u&ldquo; a &bdquo;v&ldquo;), jednotky <i>MMX</i> a navíc ještě
matematického koprocesoru by v&nbsp;mnoha případech mohla vést k&nbsp;citelnému
nárůstu výpočetního výkonu. V&nbsp;následující tabulce jsou vypsána jména
registrů tak, jak jsou použita v&nbsp;instrukcích matematického koprocesoru, i
ve formě používané jednotkou <i>MMX</i>::</p>

<table>
<tr><th>Registr FPU</th><th>bity 79-64</th><th>bity 63-0</th></tr>
<tr><td>ST0</td><td>nepoužito</td><td>MM0</td></tr>
<tr><td>ST1</td><td>nepoužito</td><td>MM1</td></tr>
<tr><td>ST2</td><td>nepoužito</td><td>MM2</td></tr>
<tr><td>ST3</td><td>nepoužito</td><td>MM3</td></tr>
<tr><td>ST4</td><td>nepoužito</td><td>MM4</td></tr>
<tr><td>ST5</td><td>nepoužito</td><td>MM5</td></tr>
<tr><td>ST6</td><td>nepoužito</td><td>MM6</td></tr>
<tr><td>ST7</td><td>nepoužito</td><td>MM7</td></tr>
</table>

<p><div class="rs-tip-major">Poznámka: s&nbsp;těmito názvy se můžeme setkat
v&nbsp;disassemblovaném kódu, v&nbsp;debuggeru, nebo přímo při programování
v&nbsp;assembleru.</div></p>

<a href="http://i.iinfo.cz/images/311/pc158-8.jpg"><img src="http://i.iinfo.cz/images/311/pc158-8-prev.jpg" width="370" height="155" alt="&#160;" /></a>
<p><i>Obrázek 13: Typy vektorů, s&nbsp;nimiž pracují instrukce MMX.</i></p>



<p><a name="k06"></a></p>
<h2 id="k06">6. SIMD instrukce v&nbsp;rozšiřující instrukční sadě 3DNow!</h2>

<p>Rozšíření instrukční sady mikroprocesorů z&nbsp;rodiny <i>x86</i> o
instrukce <i>MMX</i> popsané v&nbsp;předchozích kapitolách bylo poměrně
razantní &ndash; jednalo se v&nbsp;podstatě o největší změnu této architektury
od vzniku procesoru <i>80386</i>, tj.&nbsp;od zavedení virtuálního režimu,
32bitových pracovních registrů a pochopitelně i operací s&nbsp;32 bitovými
hodnotami. Z&nbsp;hlediska společnosti <i>Intel</i> se samozřejmě jednalo o
nemalou konkurenční výhodu získanou nad firmami <i>AMD</i>, <i>Cyrix</i> či
<i>IDT</i> (tedy tehdejšími konkurenty v&nbsp;segmentu), zejména poté, co se
podpora <i>MMX</i> operací zařadila do některých programových produktů
(například do zásuvných modulů Photoshopu, kde měla velký vliv). Ovšem tehdejší
druhý největší výrobce čipů řady <i>x86</i> &ndash; společnost <i>AMD</i>
&ndash; o necelé dva roky později představila vlastní rozšíření instrukční
sady, které bylo označeno poměrně nabubřelým názvem <i>3DNow!</i> (a to včetně
onoho vykřičníku na konci). Toto rozšíření instrukční sady bylo poprvé
implementováno v&nbsp;mikroprocesoru <i>AMD K6-2</i> a později též v&nbsp;čipu
<i>AMD K6-3</i> a <i>Athlon</i>.</p>

<img src="http://i.iinfo.cz/images/311/pc158-13.png" width="200" height="150" alt="&#160;" />
<p><i>Obrázek 14: Mikroprocesor AMD K6-2 implementující mj.&nbsp;i instrukční
sadu 3DNow!</i></p>

<p>Inženýři ze společnosti <i>AMD</i> použili a současně i rozšířili instrukční
sadu <i>MMX</i> o několik nových celočíselných instrukcí, ovšem hlavní
konkurenční výhodou (a to poměrně podstatnou) byly nové instrukce pro práci
s&nbsp;čísly reprezentovanými 32bitovými hodnotami s&nbsp;plovoucí řádovou
čárkou (<i>floating point</i>). Kromě toho bylo do instrukční sady
<i>3DNow!</i> přidáno několik operací sloužících pro přečtení bloku dat do
vyrovnávací paměti (cache). U některých typů mikroprocesorů (<i>Athlon</i>)
bylo navíc možné určit, zda je blok dat načtených do vyrovnávací paměti určený
pro čtení nebo i pro zápis (pokud se jednalo o blok určený pro zápis, byl mu
nastaven atribut <i>modified</i>). To ovšem již vyžadovalo poměrně razantní
zásahy do překladačů.</p>

<img src="http://i.iinfo.cz/images/161/pc159-5.jpg" width="242" height="208" alt="&#160;" />
<p><i>Obrázek 15: Další pohled na mikroprocesor AMD K6-2 s&nbsp;implementací
instrukční sady 3DNow!.</i></p>



<p><a name="k07"></a></p>
<h2 id="k07">7. Registry používané v&nbsp;rozšíření 3DNow!</h2>

<p>Již <a href="#k06">v&nbsp;předchozí kapitole</a> jsme se zmínili o tom, že
instrukční sada <i>3DNow!</i> byla vlastně rozšířením konkurenční instrukční
sady <i>MMX</i>. To mj.&nbsp;znamená, že v&nbsp;<i>3DNow!</i> byly podporovány
všechny datové typy <i>MMX</i>, tj.&nbsp;konkrétně osmiprvkové vektory
s&nbsp;osmibitovými hodnotami, čtyřprvkové vektory s&nbsp;16bitovými hodnotami,
dvouprvkové vektory s&nbsp;32bitovými hodnotami a konečně i 64bitové skalární
hodnoty. Navíc však bylo možné do 64bitových registrů MMX uložit dvojici
32bitových čísel s&nbsp;plovoucí řádovou čárkou odpovídající formátu <i>single
precision</i> definovaném v&nbsp;normě <i>IEEE 754</i>. Zavedení tohoto nového
typu dvouprvkového vektoru s&nbsp;sebou přinášelo dvě výhody: mnohé FP operace
se mohly provádět paralelně (součet prvků vektorů atd.) a navíc bylo velmi
snadné kombinovat původní celočíselné MMX operace s&nbsp;operacemi nad reálnými
čísly. To nebylo u původní implementace <i>MMX</i> snadné, protože se muselo
provádět přepínání mezi činností matematického koprocesoru a jednotkou MMX, jak
jsme si již ostatně řekli v&nbsp;předchozím textu.</p>

<a href="http://i.iinfo.cz/images/161/pc159-6.png"><img src="http://i.iinfo.cz/images/161/pc159-6-prev.png" width="370" height="232" alt="&#160;" /></a>
<p><i>Obrázek 16: Mikroprocesor Intel Atom sice implementuje instrukční sadu
MMX, ale nikoli 3Dnow!, což je ovšem více než kompenzováno podporou SSE a
SSE2.</i></p>

<p>V&nbsp;případě instrukční sady <i>3DNow!</i> se toto přepínání provádět
nemuselo (pokud tedy nebylo nutné pracovat s&nbsp;hodnotami s&nbsp;dvojitou či
rozšířenou přesností, tj.&nbsp;s&nbsp;datovými typy <i>double</i> a
<i>extended</i>), navíc měli programátoři k&nbsp;dispozici konverzní instrukce
nazvané <strong>PI2FD</strong> a <strong>PF2ID</strong> a určené pro převod
celočíselných 32bitových hodnot na hodnoty s&nbsp;plovoucí řádovou čárkou (se
zaokrouhlením) a naopak. Mimochodem: pro přepnutí kontextu mezi FPU operacemi a
MMX/3DNow! operacemi bylo možné použít instrukci <strong>FEMMS</strong> určenou
pro rychlé přepnutí kontextu. Tato operace je rychlejší, než původní instrukce
<strong>EMMS</strong> ze sady <i>MMX</i>, ovšem po přepnutí je obsah pracovních
registrů nedefinovaný (což v&nbsp;naprosté většině případů vůbec nevadí).</p>

<a href="http://i.iinfo.cz/images/161/pc159-7.png"><img src="http://i.iinfo.cz/images/161/pc159-7-prev.png" width="370" height="75" alt="&#160;" /></a>
<p><i>Obrázek 17: Uložení dvou 32bitových čísel s&nbsp;plovoucí řádovou čárkou
v&nbsp;64bitovém registru.<br />
(Zdroj: 3Dnow! Technology Manual, AMD Inc.)</i></p>



<p><a name="k08"></a></p>
<h2 id="k08">8. Nové SIMD instrukce v&nbsp;rozšíření 3DNow!</h2>

<p>Všechny vektorové instrukce provádějící operace s&nbsp;32bitovými
numerickými hodnotami s&nbsp;plovoucí řádovou čárkou, které jsou implementovány
v&nbsp;rámci instrukční sady <i>3DNow!</i>, jsou pro větší přehlednost vypsány
v&nbsp;následující tabulce:</p>

<table>
<tr><th> #</th><th>Instrukce</th><th>Popis</th></tr>
<tr><td> 1</td><td>PI2FD</td><td>převod 32bitových celočíselných hodnot na FP hodnoty</td></tr>
<tr><td> 2</td><td>PF2ID</td><td>převod 32bitových FP hodnot na celočíselné hodnoty</td></tr>
<tr><td> 3</td><td>PFCMPGE</td><td>porovnání na relaci &bdquo;větší nebo rovno&ldquo;</td></tr>
<tr><td> 4</td><td>PFCMPGT</td><td>porovnání na relaci &bdquo;větší než&ldquo;</td></tr>
<tr><td> 5</td><td>PFCMPEQ</td><td>porovnání na relaci &bdquo;rovnost&ldquo;</td></tr>
<tr><td> 6</td><td>PFACC</td><td>součet obou prvků zdrojového registru i obou prvků cílového registru</td></tr>
<tr><td> 7</td><td>PFADD</td><td>součet dvou dvouprvkových vektorů</td></tr>
<tr><td> 8</td><td>PFSUB</td><td>rozdíl dvou dvouprvkových vektorů</td></tr>
<tr><td> 9</td><td>PFSUBR</td><td>rozdíl dvou dvouprvkových vektorů s&nbsp;prohozením operandů</td></tr>
<tr><td>10</td><td>PFMIN</td><td>výpočet minima (vždy mezi příslušnými prvky vektorů)</td></tr>
<tr><td>11</td><td>PFMAX</td><td>výpočet maxima (vždy mezi příslušnými prvky vektorů)</td></tr>
<tr><td>12</td><td>PFMUL</td><td>součin dvou dvouprvkových vektorů</td></tr>
<tr><td>13</td><td>PFRCP</td><td>výpočet aproximace převrácené hodnoty</td></tr>
<tr><td>14</td><td>PFRSQRT</td><td>výpočet aproximace druhé odmocniny</td></tr>
<tr><td>15</td><td>PFRCPIT1</td><td>první krok přesného výpočtu převrácené hodnoty</td></tr>
<tr><td>16</td><td>PFRSQIT1</td><td>první krok přesného výpočtu druhé odmocniny</td></tr>
<tr><td>17</td><td>PFRCPIT2</td><td>další krok výpočtu převrácené hodnoty či druhé odmocniny</td></tr>
</table>

<a href="http://i.iinfo.cz/images/161/pc159-8.png"><img src="http://i.iinfo.cz/images/161/pc159-8-prev.png" width="370" height="119" alt="&#160;" /></a>
<p><i>Obrázek 18: Formát 32bitových čísel s&nbsp;plovoucí řádovou čárkou
podporovaný instrukcemi 3Dnow!)<br />
(Zdroj: 3Dnow! Technology Manual, AMD Inc.)</i></p>

<p>Při provádění porovnání prvků dvou vektorů, tj.&nbsp;při provádění instrukcí
pojmenovaných <strong>PFCMPGE</strong>, <strong>PFCMPGT</strong> a
<strong>PFCMPEQ</strong>, je výsledkem této operace nový dvouprvkový vektor
obsahující pouze hodnoty 0x0000_0000 a 0xFFFF_FFFF. U porovnávání se navíc
nerozlišuje kladná a záporná nula, což je pro naprostou většinu výpočtů zcela
korektní.</p>

<p>Pravděpodobně nejzajímavější je poslední pětice instrukcí nazvaných
<strong>PFRCP</strong>, <strong>PFRSQRT</strong>, <strong>PFRCPIT1</strong>,
<strong>PFRSQIT1</strong> a <strong>PFRCPIT2</strong>. Instrukce
<strong>PFRCP</strong> slouží k&nbsp;rychlému výpočtu převrácené hodnoty, ovšem
pouze s&nbsp;přesností na 14 bitů. V&nbsp;případě, že tato přesnost není
dostatečná (pro mnoho účelů, například grafiku, však stačí), musí být použita
následující sekvence:</p>

<pre>
PFRCP      <i>; první přiblížení k výsledku s přesností 14 bitů</i>
PFCPIT1    <i>; první krok přesného výpočtu převrácené hodnoty</i>
PFRCPIT2   <i>; druhý krok přesného výpočtu převrácené hodnoty</i>
</pre>

<p>Důležité přitom je, že první přiblížení se k&nbsp;výsledku je provedeno
velmi rychle, konkrétně pouze ve dvou taktech, protože se využívá tabulky
výsledků umístěné v&nbsp;paměti ROM. Teprve další dvojice instrukcí využívá
pomalejší iterační výpočet. Podobný princip platí i pro rychlý vs.&nbsp;přesný
výpočet druhé odmocniny (opět lze využít například v&nbsp;grafice).</p>

<a href="http://i.iinfo.cz/images/161/pc159-9.png"><img src="http://i.iinfo.cz/images/161/pc159-9-prev.png" width="370" height="96" alt="&#160;" /></a>
<p><i>Obrázek 19: Subrutina pro operaci dělení s&nbsp;24 bitovou přesností
implementovanou pomocí instrukcí 3Dnow!.<br />
(Zdroj: 3Dnow! Technology Manual, AMD Inc.)</i></p>



<p><a name="k09"></a></p>
<h2 id="k09">9. SIMD instrukce v&nbsp;rozšíření SSE</h2>

<p>Po úspěšném a relativně bezproblémovém zavedení rozšíření <i>MMX</i> i
<i>3DNow!</i> do praxe není divu, že obě nejvýznamnější společnosti podnikající
v&nbsp;oblasti návrhu a prodeje mikroprocesorů patřících do rodiny <i>x86</i>,
tj.&nbsp;tehdy už prakticky jen dvojice firem <i>Intel</i> a <i>AMD</i>, začaly
pro tyto typy mikroprocesorů navrhovat i další rozšiřující instrukční sady
s&nbsp;&bdquo;vektorovými&ldquo; instrukcemi typu <i>SIMD</i>. Některé
z&nbsp;dále zmíněných technologií byly použity v&nbsp;mikroprocesorech
vyráběných jednou společností (což je především případ <i>3DNow!</i>), ovšem
v&nbsp;současnosti můžeme vidět oboustranné snahy o zavádění rozšíření
instrukční sady <i>x86</i> podle jednotného schématu a navíc tak, aby ho bylo
možné používat na mikroprocesorech vyráběných oběma zmíněnými společnostmi. To
je poměrně velký rozdíl oproti ad-hoc řešením, s&nbsp;nimiž jsme se setkali
v&nbsp;případě <i>MMX</i> i <i>3DNow!</i> (kde navíc byli výrobci čipů svázaní
snahou o zachování zpětné kompatibility s&nbsp;existujícími operačními
systémy).</p>

<p>Pro programátory je důležitá především dnes již zcela zavedená a široce
podporovaná technologie <i>SSE</i>, což je zkratka znamenající <i>Streaming
SIMD Extension</i>. Na <i>SSE</i> se můžeme dívat buď jako na zcela nové
rozšíření instrukční sady o <i>SIMD</i> instrukce, nebo jako na určité
propojení předností obou předchozích technologií, tj.&nbsp;jak <i>MMX</i>
(relativně velký počet prvků uložených ve vektorech, ovšem podpora pouze pro
celočíselné operace nad prvky vektorů), tak i <i>3DNow!</i> (práce
s&nbsp;reálnými čísly, ovšem uloženými pouze v&nbsp;dvouprvkových vektorech,
z&nbsp;čehož vyplývají menší možnosti paralelizace výpočtů). V&nbsp;případě
<i>SSE</i> je navíc umožněna souběžná práce jednotky <i>MMX</i> či <i>FPU</i>.
Ve specifikaci <i>SSE</i> jsou popsány jak významy všech nových instrukcí, tak
i různé režimy využívané při aritmetických operacích. Specifikace taktéž říká,
jaké pracovní registry se u nových instrukcí používají.</p>

<p>Nejprve se zaměřme na registry využívané v&nbsp;technologii <i>SSE</i>. U
mikroprocesorů implementujících instrukční sadu <i>SSE</i> je využita nová sada
registrů pojmenovaných <strong>XMM0</strong> až <strong>XMM7</strong>. Na
64bitové platformě (původně architektura AMD 64, dnes pochopitelně podporováno
i Intelem) navíc došlo k&nbsp;přidání dalších osmi registrů se jmény
<strong>XMM8</strong> až <strong>XMM15</strong> využitelných pouze
v&nbsp;64bitovém režimu. Všechny nové registry mají šířku 128 bitů,
tj.&nbsp;jsou dvakrát širší, než registry používané v&nbsp;<i>MMX</i> i
<i>3DNow!</i> a čtyřikrát širší, než běžné pracovní registry na platformě
<i>x86</i> (bavíme se o dnes již překonaném 32bitovém režimu). Do každého
registru je možné uložit čtveřici reálných numerických hodnot reprezentovaných
v&nbsp;systému plovoucí řádové tečky podle normy <i>IEEE 754</i>, přičemž tato
norma je dodržována přesněji, než v&nbsp;případě <i>3DNow!</i> (různé
zaokrouhlovací režimy či práce s&nbsp;denormalizovanými čísly sice mohou
vypadat trošku jako černá magie, ovšem například v&nbsp;knihovnách pro
numerické výpočty, které musí vždy za specifikovaných okolností dát stejný
výsledek, se jedná o velmi důležitou vlastnost). K&nbsp;osmi či šestnácti novým
registrům <strong>XMM*</strong> byl ještě přidán jeden 32bitový registr nazvaný
<strong>MXCSR</strong>, jenž byl určený pro nastavení (řízení) režimů
výpočtu.</p>

<img src="http://i.iinfo.cz/images/503/pc160-3.jpg" width="220" height="194" alt="&#160;" />
<p><i>Obrázek 20: Sada nových pracovních registrů přidaných v&nbsp;rámci
rozšíření instrukční sady SSE.</i></p>



<p><a name="k10"></a></p>
<h2 id="k10">10. Sada registrů použitelná vývojáři pracujícími s&nbsp;procesory podporujícími SSE</h2>

<p>Díky zavedení rozšíření instrukční sady <i>SSE</i> do praxe začali mít
programátoři vytvářející aplikace na tehdy 32bitové platformě <i>x86</i>, jejíž
začátek se datuje od dnes již spíše historického mikroprocesoru <i>Intel
80386</i>, k&nbsp;dispozici nejenom 64bitové registry (jednotka <i>MMX</i>),
ale nyní už dokonce i registry 128bitové, což je zajisté užitečné. Přitom i
přes zavedení rozšířených instrukčních sad <i>MMX/3DNow!/SSE</i> stále
zůstávala zachována binární zpětná i dopředná kompatibilita s&nbsp;předchozími
typy mikroprocesorů (nejedná se tedy o takovou změnu, jako v&nbsp;případě
přechodu 16-&gt;32-&gt;64 bitů, která se týkala celé ALU). Zde je myšlena
především možnost běhu starších aplikací na novějších mikroprocesorech, protože
program přeložený s&nbsp;podporou <i>SSE</i> nebude na procesoru bez této
technologie pracovat korektně, i když by pravděpodobně bylo možné <i>SSE</i>
emulovat s&nbsp;využitím podprogramů spouštěných při zavolání neplatného
operačního kódu (tj.&nbsp;operačního kódu SSE instrukce, která je samozřejmě
pro ne-SSE procesor neznámým kódem).</p>

<p>Pro zajímavost se nyní podívejme, jak se společně se zavedením instrukční
sady <i>SSE</i> prakticky zdvojnásobila celková kapacita všech využitelných
pracovních registrů na 32bitové platformě <i>x86</i> (na 64bitové <i>x86_64</i>
je situace odlišná, SSE je dnes její nedílnou součástí). V&nbsp;následující
tabulce jsou kromě univerzálních pracovních registrů, indexových registrů a
bázových registrů vypsány i registry se speciálním významem:</p>

<table>
<tr><th> #</th><th>Typ registrů</th><th>Počet registrů</th><th>Bitová šířka registru</th><th>Příklady</th></tr>
<tr><td> 1</td><td>Univerzální registry </td><td>4</td><td> 32 bitů</td><td>EAX, EBX, ECX, EDX</td></tr>
<tr><td> 2</td><td>Indexové registry    </td><td>3</td><td> 32 bitů</td><td>ESI, EDI, EIP</td></tr>
<tr><td> 3</td><td>Bázové registry      </td><td>2</td><td> 32 bitů</td><td>EBP, ESP</td></tr>
<tr><td> 4</td><td>Segmentové registry  </td><td>6</td><td> 16 bitů</td><td>CS, DS, ES, FS, GS, SS</td></tr>
<tr><td> 5</td><td>Příznakový registr   </td><td>1</td><td> 32 bitů</td><td>EFLAGS (původně 16bitový FLAGS)</td></tr>
<tr><td> 6</td><td>Registry pro ladění  </td><td>8</td><td> 32 bitů</td><td>DR0..DR7</td></tr>
<tr><td> 7</td><td>Řídicí registry      </td><td>4</td><td> 32 bitů</td><td>CR0, CR2, CR3, CR4</td></tr>
<tr><td> 8</td><td>Další spec. registry </td><td>12?</td><td> 32 bitů</td><td>TR1...TR12</td></tr>
<tr><td> 9</td><td>Registry MMX/3DNow!  </td><td>8</td><td> 64 bitů</td><td>shodné s&nbsp;FPU registry st(x), resp.&nbsp;se spodními 64 bity st(x)</td></tr>
<tr><td>10</td><td>Pracovní registry SSE</td><td>8</td><td>128 bitů</td><td>XMM0 .. XMM7</td></tr>
<tr><td>11</td><td>Řídicí registr SSE   </td><td>1</td><td> 32 bitů</td><td>MXCSR</td></tr>
</table>

<img src="http://i.iinfo.cz/images/503/pc160-4.jpg" width="353" height="143" alt="&#160;" />
<p><i>Obrázek 21: Zjednodušený programátorský model architektury x86
v&nbsp;32bitovém režimu.</i></p>



<p><a name="k11"></a></p>
<h2 id="k11">11. Nové instrukce přidané v&nbsp;technologii SSE</h2>

<p>V&nbsp;rámci technologie <i>SSE</i> byla instrukční sada x86 (a později
x86-64) rozšířena o několik typů instrukcí, které většinou pracovaly s&nbsp;již
výše zmíněnými registry <strong>XMM*</strong>, popř.&nbsp;taktéž
s&nbsp;operační pamětí nebo s&nbsp;obecnými celočíselnými 32bitovými registry
procesorů <i>x86</i>, tj.&nbsp;například s&nbsp;registrem <strong>EAX</strong>.
Všechny nové instrukce je možné rozdělit do několika kategorií:</p>

<table>
<tr><th> #</th><th>Kategorie</th><th>Příklad instrukce</th></tr>
<tr><td> 1</td><td>Přenosy dat</td><td>MOVUPS, MOVAPS, MOVHPS, MOVLPS...</td></tr>
<tr><td> 2</td><td>Aritmetické operace</td><td>ADDPS, SUBPS, MULPS, DIVPS, RCPPS...</td></tr>
<tr><td> 3</td><td>Porovnání</td><td>CMPEQSS, CMPEQPS, CMPLTSS, CMPNLTSS, ...</td></tr>
<tr><td> 4</td><td>Logické operace</td><td>ANDPS, ANDNPS, ORPS, XORPS</td></tr>
<tr><td> 5</td><td>Přenosy mezi prvky vektorů (shuffle) a konverze</td><td>SHUFPS, UNPCKHPS, UNPCKLPS</td></tr>
<tr><td> 6</td><td>Načtení dat do cache</td><td>PREFETCH0, ...</td></tr>
</table>

<img src="http://i.iinfo.cz/images/503/pc160-5.png" width="450" height="311" alt="&#160;" />
<p><i>Obrázek 22: Některé instrukce zavedené v&nbsp;rámci SSE pracují pouze s&nbsp;dvojicí skalárních hodnot.</i></p>

<p>Zajímavá je podpora jak skalárních operací, tak i operací vektorových
(přesněji řečeno SIMD) v&nbsp;instrukční sadě <i>SSE</i>. Příkladem může být
například skalární instrukce součtu <strong>ADDSS</strong> (SS=single scalar),
která může mít dvojí podobu:</p>

<pre>
ADDSS xmm1, xmm2     <i>; instrukce pracující s dvojicí registrů SSE</i>
ADDSS xmm1, mem32    <i>; instrukce pracující s registrem SSE a paměťovým místem (32 bitů)</i>
</pre>

<p>Naproti tomu &bdquo;vektorová&ldquo; podoba instrukce součtu
<strong>ADDPS</strong> (PS=parallel scalar) pracuje s&nbsp;čtyřprvkovými
vektory a zajímavé je, že operační kód této instrukce je o jeden prefixový bajt
kratší, než je tomu u dříve zmíněné instrukce <strong>ADDSS</strong> (to dává
smysl, protože častěji používané vektorové instrukce zaberou v&nbsp;operační
paměti menší objem, je větší pravděpodobnost jejich načtení z&nbsp;cache
atd.):</p>

<pre>
ADDPS xmm1, xmm2     <i>; instrukce pracující s dvojicí registrů SSE</i>
ADDPS xmm1, mem128   <i>; instrukce pracující s registrem SSE a paměťovým místem (128 bitů)</i>
</pre>

<p>Taktéž stojí za zdůraznění fakt, že se v&nbsp;instrukční sadě <i>SSE</i>
nenachází žádné instrukce, v&nbsp;jejichž operačním kódu by se nacházela
konstanta. Ta musí být vždy uložena v&nbsp;operační paměti nebo přenesena
z&nbsp;obecných registrů (což trošku připomíná klasické RISCové procesory).</p>

<img src="http://i.iinfo.cz/images/503/pc160-6.png" width="450" height="304" alt="&#160;" />
<p><i>Obrázek 23: Vektorové operace podporované instrukční sadou SSE.</i></p>

<p>Nejdůležitější skupinou <i>SSE</i> instrukcí jsou instrukce určené pro
provádění aritmetických výpočtů. Tyto instrukce, které jsou vypsány
v&nbsp;následující tabulce, pracují buď s&nbsp;dvojicí skalárních hodnot typu
<i>float/single</i> umístěných v&nbsp;nejnižších 32 bitech 128bitového
registru, nebo naopak s&nbsp;dvojicí vektorů, z&nbsp;nichž každý obsahuje čtyři
32bitové hodnoty opět typu <i>float/single</i>:</p>

<table>
<tr><th> #</th><th>Instrukce se skalárními operandy</th><th>Instrukce pracující s&nbsp;vektory</th><th>Význam instrukce</th></tr>
<tr><td> 1</td><td>ADDSS</td><td>ADDPS</td><td>součet</td></tr>
<tr><td> 2</td><td>SUBSS</td><td>SUBPS</td><td>rozdíl</td></tr>
<tr><td> 3</td><td>MULSS</td><td>MULPS</td><td>součin</td></tr>
<tr><td> 4</td><td>DIVSS</td><td>DIVPS</td><td>podíl</td></tr>
<tr><td> 5</td><td>RCPSS</td><td>RCPPS</td><td>převrácená hodnota</td></tr>
<tr><td> 6</td><td>SQRTSS</td><td>SQRTPS</td><td>druhá odmocnina</td></tr>
<tr><td> 7</td><td>RSQRTSS</td><td>RSQRTPS</td><td>převrácená hodnota z&nbsp;druhé odmocniny</td></tr>
<tr><td> 8</td><td>MAXSS</td><td>MAXPS</td><td>výpočet maxima</td></tr>
<tr><td> 9</td><td>MINSS</td><td>MINPS</td><td>výpočet minima</td></tr>
</table>

<a href="http://i.iinfo.cz/images/503/pc160-7.jpg"><img src="http://i.iinfo.cz/images/503/pc160-7-prev.jpg" width="370" height="75" alt="&#160;" /></a>
<p><i>Obrázek 24: Formát 32bitových slov obsahujících hodnoty s&nbsp;plovoucí
řádovou čárkou podle IEEE 754 (single/float).</i></p>



<p><a name="k12"></a></p>
<h2 id="k12">12. Rozšíření instrukční sady SSE2</h2>

<p>Poměrně záhy po uvedení instrukční sady <i>SSE</i> se mnozí vývojáři začali
ptát, proč se vlastně většina nově přidaných instrukcí omezuje pouze na práci
s&nbsp;numerickými hodnotami s&nbsp;jednoduchou přesností, když je mnoho
aplikací založených na celočíselných datech (osmibitových bajtech,
šestnáctibitových slovech, 32bitových slovech atd.), které by tak mohly
využívat všech možností nabízených novými 128bitovými registry technologie
<i>SSE</i>. Vývojáři pracující především na vývoji algoritmů z&nbsp;oblasti
numerické matematiky by naopak uvítali práci s&nbsp;čísly s&nbsp;dvojitou
přesností (<i>double</i>) uloženými v&nbsp;64 bitech (tj.&nbsp;v&nbsp;případě
128bitových registrů by bylo možné do těchto registrů ukládat dvojice čísel
s&nbsp;dvojitou přesností &ndash; i to by mohlo představovat významné zvýšení
výpočetního výkonu). Odpovědí na oba v&nbsp;podstatě protichůdné požadavky byla
instrukční sada pojmenovaná jednoduše <i>SSE2</i>, která pochází z&nbsp;roku
2001. Tato sada byla zpočátku použita v&nbsp;mikroprocesorech <i>Intel Pentium
4</i> a <i>Intel Xeon</i>, později se však rozšířila i na procesory firmy
<i>AMD</i> (<i>Athlon64</i>, <i>Opteron</i>).</p>

<p>Technologie <i>SSE2</i> vývojářům přinesla nové instrukce a samozřejmě i
podstatné změny v&nbsp;interní struktuře vektorové výpočetní jednotky, ovšem
počet registrů ani jejich bitová šířka se nijak nezměnila. Programátoři
používající, ať již přímo či nepřímo, rozšíření instrukční sady <i>SSE2</i>
mohli do osmice 128bitových registrů pojmenovaných <i>XMM*</i> ukládat celkem
šest různých typů vektorů. Základ zůstal nezměněn &ndash; jednalo se o
čtyřprvkové vektory obsahující čísla reprezentovaná ve formátu plovoucí řádové
čárky, přičemž každé číslo bylo uloženo v&nbsp;32 bitech (4&times;32=128 bitů),
což odpovídá typu <i>single/float</i> definovanému v&nbsp;normě <i>IEEE
754</i>. Kromě toho byly v&nbsp;rámci <i>SSE2</i> ještě zavedeny dvouprvkové
vektory obsahující taktéž hodnoty reprezentované ve formátu plovoucí řádové
čárky, ovšem tentokrát se jedná o čísla uložená v&nbsp;64 bitech
(2&times;64=128) odpovídající dvojité přesnosti (<i>double</i>) z&nbsp;normy
<i>IEEE 754</i>.</p>

<p>Zbývají nám ovšem ještě čtyři další podporované datové typy. Jedná se o
vektory s&nbsp;celočíselnými prvky: šestnáctiprvkové vektory
s&nbsp;osmibitovými hodnotami, osmiprvkové vektory s&nbsp;šestnáctibitovými
hodnotami, čtyřprvkové vektory s&nbsp;32bitovými hodnotami a konečně
dvouprvkové vektory s&nbsp;64bitovými celočíselnými hodnotami.</p>

<a href="http://i.iinfo.cz/images/221/pc161-03.png"><img src="http://i.iinfo.cz/images/221/pc161-03-prev.png" width="370" height="178" alt="&#160;" /></a>
<p><i>Obrázek 25: Nové typy vektorů, s&nbsp;kterými je nově možné nativně
pracovat na mikroprocesorech podporujících technologii SSE2.</i></p>

<p>Instrukce <i>SSE2</i> je možné využít i v&nbsp;některých oblastech numerické
matematiky, i když je na tomto místě nutné říct, že přímo v&nbsp;<i>SSE2</i>
nejsou podporována čísla s&nbsp;rozšířenou přesností (<i>extended</i>), takže
v&nbsp;některých případech může dojít při výpočtech v&nbsp;jednotce <i>SSE2</i>
(a nikoli <i>FPU</i>) ke kumulaci chyb ve výsledku. Nicméně kombinace instrukcí
určených pro matematický koprocesor s&nbsp;instrukcemi určenými pro funkční
jednotku <i>SSE2</i> byla možná a v&nbsp;mnoha případech dokonce nutná, protože
matematický koprocesor kromě základních aritmetických operací podporuje
například i výpočet goniometrických funkcí, logaritmů atd.</p>



<p><a name="k13"></a></p>
<h2 id="k13">13. Nové instrukce přidané v&nbsp;rámci rozšíření instrukční sady SSE2</h2>

<p>Zatímco se v&nbsp;rozšiřující instrukční sadě <i>SSE</i> popsané
v&nbsp;předchozích kapitolách nachází &bdquo;pouze&ldquo; <strong>70 nových
instrukcí</strong>, byli tvůrci instrukční sady <i>SSE2</i> mnohem
velkorysejší, protože navrhli a posléze i implementovali hned <strong>144
nových instrukcí</strong>, což přibližně odpovídá počtu všech základních
instrukcí procesorů <i>x86</i> (pokud samozřejmě nepočítáme všechny povolené
adresní režimy a další instrukce, které byly na tuto architekturu postupně
&bdquo;nabaleny&ldquo;). Tento velký počet nových instrukcí souvisí jak
s&nbsp;jíž zmíněnou podporou šesti datových typů popsaných <a
href="#k12">v&nbsp;předchozí kapitole</a> (včetně více než dvaceti zcela nových
konverzních funkcí), tak i s&nbsp;novými režimy přístupu k&nbsp;prvkům uloženým
ve vektorech a se zcela novými operacemi, které byly navrženy pro podporu
algoritmů pro 3D grafiku a práci s&nbsp;videem. Všechny instrukce, které byly
přidány v&nbsp;rozšiřující instrukční sadě <i>SSE2</i>, je možné rozdělit do
několika kategorií:</p>

<ol>
<li>Aritmetické operace prováděné s&nbsp;celými čísly (včetně součtu a rozdílu se saturací)</li>
<li>Aritmetické operace prováděné s&nbsp;čísly s&nbsp;plovoucí řádovou čárkou</li>
<li>Logické operace (některé jsou prováděny pro všech 128 bitů)</li>
<li>Bitové posuny prvků o různé bitové šířce</li>
<li>Porovnávací (komparační, relační) operace</li>
<li>Konverzní funkce</li>
<li>Konverze prvků uložených ve vektorech (zvýšení či snížení bitové šířky, shuffling apod.)</li>
<li>Načítání a ukládání dat do operační paměti</li>
<li>Řízení vyrovnávací paměti (cache)</li>
</ol>

<p>O těchto instrukcích se zmíníme <a href="#k14">v&nbsp;navazující kapitole</a>.</p>

<img src="http://i.iinfo.cz/images/75/pc161-04.png" width="500" height="300" alt="&#160;" />
<p><i>Obrázek 26: Ukázka urychlení operace součtu 1024 číselných prvků
reprezentovaných ve formátu s&nbsp;plovoucí řádovou čárkou. Celkem byly použity
čtyři algoritmy pro součet:<br />
1 - využití instrukcí FPU<br />
2 - využití instrukcí FPU s&nbsp;rozbalením smyčky<br />
3 - využití vektorových operací SSE/SSE2<br />
4 - využití vektorových operací SSE/SSE2 s&nbsp;rozbalením smyčky</i></p>



<p><a name="k14"></a></p>
<h2 id="k14">14. Seznam všech instrukcí SSE2</h2>

<p>Podobně jako u rozšiřujících instrukčních sad <i>MMX</i>, <i>3DNow!</i> a
<i>SSE</i>, tvoří i u instrukční sady <i>SSE2</i> nejpodstatnější část nové
instrukce určené pro provádění aritmetických operací nad vektory prvků různých
datových typů. Všechny nové operace implementované v&nbsp;rámci <i>SSE2</i>
jsou vypsány v&nbsp;následující tabulce. Ve třetím sloupci je naznačeno, jaké
vektory jsou danou operací zpracovávány, přičemž první číslo znamená počet
prvků vektoru, za nímž následuje bitová šířka jednotlivých prvků:</p>

<table>
<tr><th>#</th><th>Instrukce</th><th>Operace/funkce</th><th>Struktura vektoru</th><th>Datový typ</th><th>Saturace?</th><th>Poznámka</th></tr>
<tr><td> 1</td><td>addpd</td><td>součet</td><td>2&times;64bit</td><td>double</td><td>&times;</td><td>&nbsp;</td></tr>
<tr><td> 2</td><td>addsd</td><td>součet</td><td>1&times;64bit</td><td>double</td><td>&times;</td><td>operace provedena jen s&nbsp;pravým prvkem vektorů</td></tr>
<tr><td> 3</td><td>subpd</td><td>rozdíl</td><td>2&times;64bit</td><td>double</td><td>&times;</td><td>&nbsp;</td></tr>
<tr><td> 4</td><td>subsd</td><td>rozdíl</td><td>1&times;64bit</td><td>double</td><td>&times;</td><td>operace provedena jen s&nbsp;pravým prvkem vektorů</td></tr>
<tr><td> 5</td><td>mulpd</td><td>součin</td><td>2&times;64bit</td><td>double</td><td>&times;</td><td>&nbsp;</td></tr>
<tr><td> 6</td><td>mulsd</td><td>součin</td><td>1&times;64bit</td><td>double</td><td>&times;</td><td>operace provedena jen s&nbsp;pravým prvkem vektorů</td></tr>
<tr><td> 7</td><td>divpd</td><td>podíl</td><td>2&times;64bit</td><td>double</td><td>&times;</td><td>&nbsp;</td></tr>
<tr><td> 8</td><td>divsd</td><td>podíl</td><td>1&times;64bit</td><td>double</td><td>&times;</td><td>operace provedena jen s&nbsp;pravým prvkem vektorů</td></tr>
<tr><td> 9</td><td>paddb</td><td>součet</td><td>16&times;8bit</td><td>integer</td><td>ne </td><td>&nbsp;</td></tr>
<tr><td>10</td><td>paddw</td><td>součet</td><td>8&times;16bit</td><td>integer</td><td>ne </td><td>&nbsp;</td></tr>
<tr><td>11</td><td>paddd</td><td>součet</td><td>4&times;32bit</td><td>integer</td><td>ne </td><td>&nbsp;</td></tr>
<tr><td>12</td><td>paddq</td><td>součet</td><td>2&times;64bit</td><td>integer</td><td>ne </td><td>&nbsp;</td></tr>
<tr><td>13</td><td>paddsb</td><td>součet</td><td>16&times;8bit</td><td>integer</td><td>ano</td><td>&nbsp;</td></tr>
<tr><td>14</td><td>paddsw</td><td>součet</td><td>8&times;16bit</td><td>integer</td><td>ano</td><td>&nbsp;</td></tr>
<tr><td>15</td><td>paddusb</td><td>součet</td><td>16&times;8bit</td><td>unsigned</td><td>ano</td><td>&nbsp;</td></tr>
<tr><td>16</td><td>paddusw</td><td>součet</td><td>8&times;16bit</td><td>unsigned</td><td>ano</td><td>&nbsp;</td></tr>
<tr><td>17</td><td>psubb</td><td>rozdíl</td><td>16&times;8bit</td><td>integer</td><td>ne </td><td>&nbsp;</td></tr>
<tr><td>18</td><td>psubw</td><td>rozdíl</td><td>8&times;16bit</td><td>integer</td><td>ne </td><td>&nbsp;</td></tr>
<tr><td>19</td><td>psubd</td><td>rozdíl</td><td>4&times;32bit</td><td>integer</td><td>ne </td><td>&nbsp;</td></tr>
<tr><td>20</td><td>psubq</td><td>rozdíl</td><td>2&times;64bit</td><td>integer</td><td>ne </td><td>&nbsp;</td></tr>
<tr><td>21</td><td>psubsb</td><td>rozdíl</td><td>16&times;8bit</td><td>integer</td><td>ano</td><td>&nbsp;</td></tr>
<tr><td>22</td><td>psubsw</td><td>rozdíl</td><td>8&times;16bit</td><td>integer</td><td>ano</td><td>&nbsp;</td></tr>
<tr><td>23</td><td>psubusb</td><td>rozdíl</td><td>16&times;8bit</td><td>unsigned</td><td>ano</td><td>&nbsp;</td></tr>
<tr><td>24</td><td>psubusw</td><td>rozdíl</td><td>8&times;16bit</td><td>unsigned</td><td>ano</td><td>&nbsp;</td></tr>
<tr><td>25</td><td>maxpd</td><td>maximu</td><td>2&times;64bit</td><td>double</td><td>&times;</td><td>&nbsp;</td></tr>
<tr><td>26</td><td>maxsd</td><td>maximum</td><td>2&times;64bit</td><td>double</td><td>&times;</td><td>operace provedena jen s&nbsp;pravým prvkem vektorů</td></tr>
<tr><td>27</td><td>minpd</td><td>minimum</td><td>2&times;64bit</td><td>double</td><td>&times;</td><td>&nbsp;</td></tr>
<tr><td>28</td><td>minsd</td><td>minimum</td><td>2&times;64bit</td><td>double</td><td>&times;</td><td>operace provedena jen s&nbsp;pravým prvkem vektorů</td></tr>
<tr><td>29</td><td>pmaddwd</td><td>součin/add</td><td>8&times;16bit</td><td>integer </td><td>&times;</td><td>&nbsp;</td></tr>
<tr><td>30</td><td>pmulhw</td><td>součin</td><td>8&times;16bit</td><td>integer</td><td>&times;</td><td>vrací vektor horních 16 bitů výsledků</td></tr>
<tr><td>31</td><td>pmullw</td><td>součin</td><td>8&times;16bit</td><td>integer</td><td>&times;</td><td>vrací vektor dolních 16 bitů výsledků</td></tr>
<tr><td>32</td><td>pmuludq</td><td>součin</td><td>4&times;32bit</td><td>integer</td><td>&times;</td><td>64 bitový výsledek pro každý součin  </td></tr>
<tr><td>33</td><td>rcpps</td><td>převrácená hodnota</td><td>4&times;32bit</td><td>single</td><td>&times;</td><td>aproximace</td></tr>
<tr><td>34</td><td>rcpss</td><td>převrácená hodnota</td><td>4&times;32bit</td><td>single</td><td>&times;</td><td>operace provedena jen s&nbsp;pravým prvkem vektorů</td></tr>
<tr><td>35</td><td>sqrtpd</td><td>druhá odmocnina</td><td>2&times;64bit</td><td>double</td><td>&times;</td><td>&nbsp;                                                   </td></tr>
<tr><td>36</td><td>sqrtsd</td><td>druhá odmocnina</td><td>2&times;64bit</td><td>double</td><td>&times;</td><td>&nbsp; operace provedena jen s&nbsp;pravým prvkem vektorů</td></tr>
</table>

<img src="http://i.iinfo.cz/images/612/pc161-05.png" width="500" height="300" alt="&#160;" />
<p><i>Obrázek 27: Ukázka urychlení operace výpočtu skalárního součinu pro 1024
trojrozměrných vektorů. Prvky vektorů jsou opět reprezentovány ve formátu
s&nbsp;plovoucí řádovou čárkou. Celkem byly použity čtyři algoritmy pro
součet:<br />
1 - využití instrukcí FPU<br />
2 - využití instrukcí FPU s&nbsp;rozbalením smyčky<br />
3 - využití vektorových operací SSE/SSE2<br />
4 - využití vektorových operací SSE/SSE2 s&nbsp;rozbalením smyčky<br />
Důvod, proč ze došlo k&nbsp;většímu urychlení při použití SSE/SSE2 je
jednoduchý: s&nbsp;jednou načtenými daty (vektory) se provádělo větší množství
operací, takže se zde v&nbsp;menší míře projevila latence operačních pamětí a
další externí vlivy. Sice je možné najít i algoritmy, u nichž je dosaženo ještě
většího urychlení výpočtů, ale v&nbsp;praxi je zhruba trojnásobné urychlení
(podobně jako na tomto grafu) považováno za velký úspěch.</i></p>

<p>V&nbsp;instrukční sadě <i>SSE2</i> můžeme najít i nové logické instrukce a
instrukce pro provádění logických či aritmetických posunů. Ve skutečnosti se
vlastně jedná o pouhé rozšíření stávajících instrukcí <i>MMX</i> takovým
způsobem, aby bylo možné pracovat s&nbsp;novými 128bitovými vektory,
popř.&nbsp;s&nbsp;daty uloženými v&nbsp;operační paměti v&nbsp;bloku šestnácti
bajtů (16&times;8=128 bitů). Nejprve si popišme instrukce pro aritmetické a
logické posuny. Ty dokážou pracovat s&nbsp;celočíselnými hodnotami o velikosti
16, 32, 64 či 128 bitů, tj.&nbsp;každá část vektoru se posouvá zvlášť (je tedy
rozdíl mezi posunem jednoho 128bitového čísla a dvojice 64bitových čísel). Při
logických posunech se do nového bitu nasouvá vždy logická nula (nikoli příznak
<i>carry</i>), u aritmetických posunů se opakuje hodnota původního nejvyššího
bitu, tj.&nbsp;instrukce pracují přesně tak, jak to programátoři očekávají:</p>

<table>
<tr><th>#</th><th>Instrukce</th><th>Operace/funkce</th><th>Struktura vektoru</th><th>Datový typ</th><th>Poznámka</th></tr>
<tr><td> 1</td><td>pslldq</td><td>logický posun doleva</td><td>1&times;128bitů</td><td>integer</td><td>&nbsp;</td></tr>
<tr><td> 2</td><td>psllq</td><td>logický posun doleva</td><td>2&times;64bitů </td><td>integer</td><td>&nbsp;</td></tr>
<tr><td> 3</td><td>pslld</td><td>logický posun doleva</td><td>4&times;32bitů </td><td>integer</td><td>&nbsp;</td></tr>
<tr><td> 4</td><td>psllw</td><td>logický posun doleva</td><td>8&times;16bitů </td><td>integer</td><td>&nbsp;</td></tr>
<tr><td> 5</td><td>psrldq</td><td>logický posun doprava</td><td>1&times;128bitů</td><td>integer</td><td>&nbsp;</td></tr>
<tr><td> 6</td><td>psrlq</td><td>logický posun doprava</td><td>2&times;64bitů </td><td>integer</td><td>&nbsp;</td></tr>
<tr><td> 7</td><td>psrld</td><td>logický posun doprava</td><td>4&times;32bitů </td><td>integer</td><td>&nbsp;</td></tr>
<tr><td> 8</td><td>psrlw</td><td>logický posun doprava</td><td>8&times;16bitů </td><td>integer</td><td>&nbsp;</td></tr>
<tr><td> 9</td><td>psrad</td><td>aritmetický posun doprava</td><td>4&times;32bitů </td><td>integer</td><td>&nbsp;</td></tr>
<tr><td>10</td><td>psraw</td><td>aritmetický posun doprava</td><td>8&times;16bitů </td><td>integer</td><td>&nbsp;</td></tr>
</table>

<p>Následuje seznam instrukcí určených pro provádění logických operací nad
vektory různé délky. V&nbsp;některých případech (<strong>PAND, POR,
PXOR</strong>) se jedná o rozšíření původních <i>MMX</i> instrukcí takovým
způsobem, aby tyto instrukce mohly pracovat se 128bitovými vektory. Dokonce i
operační kódy instrukcí zůstávají stejné, ovšem v&nbsp;případě <i>SSE2</i> je
před vlastním instrukčním kódem uveden prefix 0x66, takže jsou instrukce o
jeden bajt delší (to ostatně platí i pro aritmetické operace popsané o několik
odstavců výše):</p>

<table>
<tr><th>#</th><th>Instrukce</th><th>Operace/funkce</th><th>Struktura vektoru</th><th>Datový typ</th><th>Poznámka</th></tr>
<tr><td> 1</td><td>pand</td><td>and</td><td>1&times;128 bitů</td><td>integer</td><td>&nbsp;</td></tr>
<tr><td> 2</td><td>pandn</td><td>not and</td><td>1&times;128 bitů</td><td>integer</td><td>první operand je negován</td></tr>
<tr><td> 3</td><td>por</td><td>or</td><td>1&times;128 bitů</td><td>integer</td><td>&nbsp;</td></tr>
<tr><td> 4</td><td>pxor</td><td>xor</td><td>1&times;128 bitů</td><td>integer</td><td>&nbsp;</td></tr>
<tr><td> 5</td><td>andpd</td><td>and</td><td>2&times;64 bitů </td><td>double </td><td>&nbsp;</td></tr>
<tr><td> 6</td><td>orpd</td><td>or</td><td>2&times;64 bitů </td><td>double </td><td>&nbsp;</td></tr>
<tr><td> 7</td><td>xorpd</td><td>xor</td><td>2&times;64 bitů </td><td>double </td><td>&nbsp;</td></tr>
<tr><td> 8</td><td>andnpd</td><td>not and</td><td>2&times;64 bitů </td><td>double </td><td>první operand je negován</td></tr>
<tr><td> 9</td><td>andnps</td><td>not and</td><td>4&times;32 bitů </td><td>single </td><td>první operand je negován</td></tr>
</table>

<p>Při implementaci mnoha algoritmů, především pak při zpracování obrazových a
zvukových datových toků, se mnohdy programátoři dostanou do situace, kdy
potřebují zkonvertovat data do jiného formátu, než v&nbsp;jakém byla původně
uložena. Pro tyto účely jsou v&nbsp;instrukční sadě <i>SSE2</i>
k&nbsp;dispozici dvě desítky konverzních instrukcí začínajících prefixem
<strong>cvt</strong>, vypsaných v&nbsp;tabulce pod tímto odstavcem. Opět platí,
že konverze jsou prováděny paralelně:</p>

<table>
<tr><th>#</th><th>Instrukce</th><th>Konverze z...</th><th>Konverze do...</th></tr>
<tr><td> 1</td><td>cvtdq2pd</td><td>2&times;32bitový integer</td><td>2&times;64bitový double</td></tr>
<tr><td> 2</td><td>cvtdq2ps</td><td>4&times;32bitový integer</td><td>4&times;32bitový single</td></tr>
<tr><td> 3</td><td>cvtpd2pi</td><td>2&times;64bitový double </td><td>2&times;32bitový integer v&nbsp;MMX registru</td></tr>
<tr><td> 4</td><td>cvtpd2dq</td><td>2&times;64bitový double </td><td>2&times;32bitový integer ve spodní polovině MMX registru</td></tr>
<tr><td> 5</td><td>cvtpd2ps</td><td>2&times;64bitový double </td><td>2&times;32bitový single ve spodní polovině MMX registru</td></tr>
<tr><td> 6</td><td>cvtpi2pd</td><td>2&times;32bitový integer</td><td>2&times;32bitový single ve spodní polovině MMX registru</td></tr>
<tr><td> 7</td><td>cvtps2dq</td><td>4&times;32bitový single </td><td>4&times;32bitový integer</td></tr>
<tr><td> 8</td><td>cvtps2pd</td><td>2&times;32bitový single </td><td>2&times;64bitový double</td></tr>
<tr><td> 9</td><td>cvtsd2si</td><td>1&times;64bitový double </td><td>1&times;32bitový integer v&nbsp;pracovním registru (CPU)</td></tr>
<tr><td>10</td><td>cvttpd2pi</td><td>2&times;64bitový double </td><td>2&times;32bitový integer (odseknutí desetinné části)</td></tr>
<tr><td>11</td><td>cvttpd2dq</td><td>2&times;64bitový double </td><td>2&times;32bitový integer (odseknutí desetinné části)</td></tr>
<tr><td>12</td><td>cvttps2dq</td><td>4&times;32bitový single </td><td>4&times;32bitový integer (odseknutí desetinné části)</td></tr>
<tr><td>13</td><td>cvttps2pi</td><td>2&times;32bitový single </td><td>2&times;32bitový integer (odseknutí desetinné části) v&nbsp;MMX registru</td></tr>
<tr><td>14</td><td>cvttsd2si</td><td>1&times;64bitový double </td><td>1&times;32bitový integer (odseknutí desetinné části) v&nbsp;pracovním registru</td></tr>
<tr><td>15</td><td>cvttss2si</td><td>1&times;32bitový single </td><td>1&times;32bitový integer (odseknutí desetinné části) v&nbsp;pracovním registru</td></tr>
<tr><td>16</td><td>cvtsi2sd</td><td>1&times;32bitový integer</td><td>1&times;64bitový double</td></tr>
<tr><td>17</td><td>cvtsi2ss</td><td>1&times;32bitový integer</td><td>1&times;32bitový single</td></tr>
<tr><td>18</td><td>cvtsd2ss</td><td>1&times;64bitový double </td><td>1&times;32bitový single (horní polovina registru se nemění)</td></tr>
<tr><td>19</td><td>cvtss2sd</td><td>1&times;32bitový single </td><td>1&times;64bitový double</td></tr>
<tr><td>20</td><td>cvtss2si</td><td>1&times;32bitový single </td><td>1&times;32bitový integer v&nbsp;pracovním registru (CPU)</td></tr>
</table>

<a href="http://i.iinfo.cz/images/486/pc161-06.png"><img src="http://i.iinfo.cz/images/486/pc161-06-prev.png" width="370" height="182" alt="&#160;" /></a>
<p><i>Obrázek 28: Univerzální konverzní funkce PSHUF byla v&nbsp;instrukční
sadě SSE2 rozšířena tak, aby dokázala pracovat i se 128bitovými
registry.</i></p>

<p><div class="rs-tip-major">Poznámka: popravdě řečeno by se pro mnoho
serverových aplikací hodily ještě instrukce pro konverzi mezi <i>UTF-8</i> a
<i>UCS-4</i>, což je po obvodové stránce poměrně jednoduchá bitová
transformace, ovšem obtížně reprezentovatelná v&nbsp;reálně existujících
strojových instrukcích.</div></p>

<img src="http://i.iinfo.cz/images/572/pc161-07.png" width="329" height="330" alt="&#160;" />
<p><i>Obrázek 29: V&nbsp;rámci instrukční sady Intel AVX došlo k&nbsp;dalšímu
zvýšení bitové šířky &bdquo;vektorových&ldquo; registrů na 256 bitů.</i></p>



<p><a name="k15"></a></p>
<h2 id="k15">15. Podpora SIMD instrukcí v&nbsp;GCC &ndash; vektorová rozšíření</h2>

<p>Pokud jste článek dočetli až sem, musíte si asi říkat, jaký instrukční
Babylon v&nbsp;oblasti x86/x86-64 vládne. To je pravda a ani vývojářům a ani
autorům překladačů to nijak neulehčuje život. Jedno z&nbsp;řešení tohoto stavu
spočívá v&nbsp;tom, že překladače začnou podporovat <i>obecné vektorové
operace</i>. A jednou z&nbsp;realizací této myšlenky je rozšíření GCC C (a C++)
o de facto nové datové typy &bdquo;vektor určité bajtové délky&ldquo;.</p>

<p>Podívejme se na následující příklad, v&nbsp;němž je definován nový typ
nazvaný <strong>v16us</strong> (jméno může být pochopitelně jakékoli). Jedná se
o vektor o délce šestnácti bajtů, který obsahuje prvky typu <strong>short
int</strong>, což zde konkrétně může znamenat, že se do vektoru vejde celkem
osm těchto prvků za předpokladu, že <strong>sizeof(unsighed short
int)==2</strong>:</p>

<pre>
#include &lt;stdio.h&gt;
&nbsp;
typedef unsigned short int v16us __attribute__((vector_size(16)));
&nbsp;
int main(void)
{
    printf("scalar: %ld bytes\n", sizeof(unsigned short int));
    printf("vector: %ld bytes\n", sizeof(v16us));
&nbsp;
    return 0;
}
</pre>

<p>Výsledek:</p>

<pre>
scalar: 2 bytes
vector: 16 bytes
</pre>

<p>Vyzkoušet si můžeme i další vektory o celkové délce 16 bajtů, jejichž prvky
budou různých typů a tudíž i délka vektoru měřená v&nbsp;počtu prvků bude
odlišná:</p>

<pre>
#include &lt;stdio.h&gt;
&nbsp;
typedef unsigned char v16ub __attribute__((vector_size(16)));
typedef unsigned short int v16us __attribute__((vector_size(16)));
typedef unsigned int v16ui __attribute__((vector_size(16)));
typedef unsigned long int v16ul __attribute__((vector_size(16)));
&nbsp;
int main(void)
{
    printf("unsigned char:  %ld bytes\n", sizeof(unsigned char));
    printf("unsigned short: %ld bytes\n", sizeof(unsigned short int));
    printf("unsigned int:   %ld bytes\n", sizeof(unsigned int));
    printf("unsigned long:  %ld bytes\n", sizeof(unsigned long int));
&nbsp;
    printf("vector unsigned char:  %ld bytes\n", sizeof(v16ub));
    printf("vector unsigned short: %ld bytes\n", sizeof(v16us));
    printf("vector unsigned int:   %ld bytes\n", sizeof(v16ui));
    printf("vector unsigned long:  %ld bytes\n", sizeof(v16ul));
&nbsp;
    return 0;
}
</pre>

<p>Výsledek:</p>

<pre>
unsigned char:  1 bytes
unsigned short: 2 bytes
unsigned int:   4 bytes
unsigned long:  8 bytes
vector unsigned char:  16 bytes
vector unsigned short: 16 bytes
vector unsigned int:   16 bytes
vector unsigned long:  16 bytes
</pre>

<p>Totéž platí i pro vektory s&nbsp;prvky se znaménkem:</p>

<pre>
#include &lt;stdio.h&gt;
&nbsp;
typedef signed char v16ub __attribute__((vector_size(16)));
typedef signed short int v16us __attribute__((vector_size(16)));
typedef signed int v16ui __attribute__((vector_size(16)));
typedef signed long int v16ul __attribute__((vector_size(16)));
&nbsp;
int main(void)
{
    printf("signed char:  %ld bytes\n", sizeof(signed char));
    printf("signed short: %ld bytes\n", sizeof(signed short int));
    printf("signed int:   %ld bytes\n", sizeof(signed int));
    printf("signed long:  %ld bytes\n", sizeof(signed long int));
&nbsp;
    printf("vector signed char:  %ld bytes\n", sizeof(v16ub));
    printf("vector signed short: %ld bytes\n", sizeof(v16us));
    printf("vector signed int:   %ld bytes\n", sizeof(v16ui));
    printf("vector signed long:  %ld bytes\n", sizeof(v16ul));
&nbsp;
    return 0;
}
</pre>

<p>Výsledky:</p>

<pre>
signed char:  1 bytes
signed short: 2 bytes
signed int:   4 bytes
signed long:  8 bytes
vector signed char:  16 bytes
vector signed short: 16 bytes
vector signed int:   16 bytes
vector signed long:  16 bytes
</pre>



<p><a name="k16"></a></p>
<h2 id="k16">16. Základní aritmetické operace s&nbsp;vektory</h2>

<p>S&nbsp;celými vektory lze pochopitelně provádět i základní aritmetické
operace, což je ukázáno na dalším příkladu, společně s&nbsp;ukázkou toho, jak
se vlastně vektory naplní daty:</p>

<pre>
typedef unsigned short int v16us __attribute__((vector_size(16)));
&nbsp;
int main(void)
{
    v16us x = { 1, 2, 3, 4, 5, 6, 7, 8 };
    v16us y = { 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff };
    v16us z = x + y;
&nbsp;
    return 0;
}
</pre>

<p>Překlad s&nbsp;povolením SSE dopadne následovně:</p>

<pre>
simd04_2.o:     file format elf64-x86-64
&nbsp;
&nbsp;
Disassembly of section .text:
&nbsp;
0000000000000000 &lt;main&gt;:
typedef unsigned short int v16us __attribute__((vector_size(16)));
&nbsp;
int main(void)
{
   0:   f3 0f 1e fa             endbr64 
   4:   55                      push   rbp
   5:   48 89 e5                mov    rbp,rsp
    v16us x = { 1, 2, 3, 4, 5, 6, 7, 8 };
   8:   66 0f 6f 05 00 00 00    movdqa xmm0,XMMWORD PTR [rip+0x0]
   f:   00 
  10:   0f 29 45 d0             movaps XMMWORD PTR [rbp-0x30],xmm0
    v16us y = { 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff };
  14:   66 0f 6f 05 00 00 00    movdqa xmm0,XMMWORD PTR [rip+0x0]
  1b:   00 
  1c:   0f 29 45 e0             movaps XMMWORD PTR [rbp-0x20],xmm0
    v16us z = x + y;
  20:   66 0f 6f 45 d0          movdqa xmm0,XMMWORD PTR [rbp-0x30]
  25:   66 0f fd 45 e0          <strong>paddw  xmm0,XMMWORD PTR [rbp-0x20]</strong>
  2a:   0f 29 45 f0             movaps XMMWORD PTR [rbp-0x10],xmm0
&nbsp;
    return 0;
  2e:   b8 00 00 00 00          mov    eax,0x0
}
  33:   5d                      pop    rbp
  34:   c3                      ret    
</pre>

<p>Důležitá je z&nbsp;našeho pohledu instrukce <strong>paddw</strong>, kterou
jsme si již popsali v&nbsp;rámci předchozích kapitol. Tato funkce provede
součet dvou vektorů majících čtyři šestnáctibitové prvky, což je přesně ta
instrukce, kterou bychom zde očekávali.</p>

<p>Vyzkoušejme si nyní i další typy vektorů:</p>

<pre>
#include &lt;stdio.h&gt;
&nbsp;
typedef signed char v16ub __attribute__((vector_size(16)));
typedef signed short int v16us __attribute__((vector_size(16)));
typedef signed int v16ui __attribute__((vector_size(16)));
typedef signed long int v16ul __attribute__((vector_size(16)));
&nbsp;
int main(void)
{
    {
        v16ub x = { 1, 2, 3, 4, 5, 6, 7, 8 };
        v16ub y = { 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff };
        v16ub z = x + y;
    }
&nbsp;
    {
        v16us x = { 1, 2, 3, 4, 5, 6, 7, 8 };
        v16us y = { 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff };
        v16us z = x + y;
    }
&nbsp;
    {
        v16ui x = { 1, 2, 3, 4 };
        v16ui y = { 0xff, 0xff, 0xff, 0xff };
        v16ui z = x + y;
    }
&nbsp;
    {
        v16ui x = { 1, 2 };
        v16ui y = { 0xff, 0xff };
        v16ui z = x + y;
    }
&nbsp;
    return 0;
}
</pre>

<p>Překlad do &bdquo;vektorového&ldquo; kódu se zvýrazněním SIMD instrukcí:</p>

<pre>
simd04B_2.o:     file format elf64-x86-64
&nbsp;
&nbsp;
Disassembly of section .text:
&nbsp;
0000000000000000 &lt;main&gt;:
typedef signed short int v16us __attribute__((vector_size(16)));
typedef signed int v16ui __attribute__((vector_size(16)));
typedef signed long int v16ul __attribute__((vector_size(16)));
&nbsp;
int main(void)
{
   0:   f3 0f 1e fa             endbr64 
   4:   55                      push   rbp
   5:   48 89 e5                mov    rbp,rsp
   8:   48 83 ec 48             sub    rsp,0x48
    {
        v16ub x = { 1, 2, 3, 4, 5, 6, 7, 8 };
   c:   66 0f 6f 05 00 00 00    movdqa xmm0,XMMWORD PTR [rip+0x0]
  13:   00 
  14:   0f 29 85 40 ff ff ff    movaps XMMWORD PTR [rbp-0xc0],xmm0
        v16ub y = { 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff };
  1b:   66 0f 6f 05 00 00 00    movdqa xmm0,XMMWORD PTR [rip+0x0]
  22:   00 
  23:   0f 29 85 50 ff ff ff    movaps XMMWORD PTR [rbp-0xb0],xmm0
        v16ub z = x + y;
  2a:   66 0f 6f 85 40 ff ff    movdqa xmm0,XMMWORD PTR [rbp-0xc0]
  31:   ff 
  32:   66 0f fc 85 50 ff ff    <strong>paddb  xmm0,XMMWORD PTR [rbp-0xb0]</strong>
  39:   ff 
  3a:   0f 29 85 60 ff ff ff    movaps XMMWORD PTR [rbp-0xa0],xmm0
    }
&nbsp;
    {
        v16us x = { 1, 2, 3, 4, 5, 6, 7, 8 };
  41:   66 0f 6f 05 00 00 00    movdqa xmm0,XMMWORD PTR [rip+0x0]
  48:   00 
  49:   0f 29 85 70 ff ff ff    movaps XMMWORD PTR [rbp-0x90],xmm0
        v16us y = { 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff };
  50:   66 0f 6f 05 00 00 00    movdqa xmm0,XMMWORD PTR [rip+0x0]
  57:   00 
  58:   0f 29 45 80             movaps XMMWORD PTR [rbp-0x80],xmm0
        v16us z = x + y;
  5c:   66 0f 6f 85 70 ff ff    movdqa xmm0,XMMWORD PTR [rbp-0x90]
  63:   ff 
  64:   66 0f fd 45 80          <strong>paddw  xmm0,XMMWORD PTR [rbp-0x80]</strong>
  69:   0f 29 45 90             movaps XMMWORD PTR [rbp-0x70],xmm0
    }
&nbsp;
    {
        v16ui x = { 1, 2, 3, 4 };
  6d:   66 0f 6f 05 00 00 00    movdqa xmm0,XMMWORD PTR [rip+0x0]
  74:   00 
  75:   0f 29 45 a0             movaps XMMWORD PTR [rbp-0x60],xmm0
        v16ui y = { 0xff, 0xff, 0xff, 0xff };
  79:   66 0f 6f 05 00 00 00    movdqa xmm0,XMMWORD PTR [rip+0x0]
  80:   00 
  81:   0f 29 45 b0             movaps XMMWORD PTR [rbp-0x50],xmm0
        v16ui z = x + y;
  85:   66 0f 6f 45 a0          movdqa xmm0,XMMWORD PTR [rbp-0x60]
  8a:   66 0f fe 45 b0          <strong>paddd  xmm0,XMMWORD PTR [rbp-0x50]</strong>
  8f:   0f 29 45 c0             movaps XMMWORD PTR [rbp-0x40],xmm0
    }
&nbsp;
    {
        v16ui x = { 1, 2 };
  93:   66 0f 6f 05 00 00 00    movdqa xmm0,XMMWORD PTR [rip+0x0]
  9a:   00 
  9b:   0f 29 45 d0             movaps XMMWORD PTR [rbp-0x30],xmm0
        v16ui y = { 0xff, 0xff };
  9f:   66 0f 6f 05 00 00 00    movdqa xmm0,XMMWORD PTR [rip+0x0]
  a6:   00 
  a7:   0f 29 45 e0             movaps XMMWORD PTR [rbp-0x20],xmm0
        v16ui z = x + y;
  ab:   66 0f 6f 45 d0          movdqa xmm0,XMMWORD PTR [rbp-0x30]
  b0:   66 0f fe 45 e0          <strong>paddd  xmm0,XMMWORD PTR [rbp-0x20]</strong>
  b5:   0f 29 45 f0             movaps XMMWORD PTR [rbp-0x10],xmm0
    }
&nbsp;
&nbsp;
    return 0;
  b9:   b8 00 00 00 00          mov    eax,0x0
}
  be:   c9                      leave  
  bf:   c3                      ret    
</pre>

<p><div class="rs-tip-major">Poznámka: povšimněte si různé šířky instrukcí,
ovšem stejného prefixu:</div></p>

<pre>
66 0f fc 85 50 ff ff    <strong>paddb  xmm0,XMMWORD PTR [rbp-0xb0]</strong>
66 0f fd 45 80          <strong>paddw  xmm0,XMMWORD PTR [rbp-0x80]</strong>
66 0f fe 45 b0          <strong>paddd  xmm0,XMMWORD PTR [rbp-0x50]</strong>
66 0f fe 45 e0          <strong>paddd  xmm0,XMMWORD PTR [rbp-0x20]</strong>
</pre>



<p><a name="k17"></a></p>
<h2 id="k17">17. Přístup k&nbsp;prvkům vektorů</h2>

<p>V&nbsp;případě potřeby je možné k&nbsp;prvkům vektorů přistupovat tak,
jakoby se jednalo o běžné pole:</p>

<pre>
#include &lt;stdio.h&gt;
&nbsp;
typedef unsigned short int v16us __attribute__((vector_size(16)));
&nbsp;
int main(void)
{
    v16us x = { 1, 2, 3, 4, 5, 6, 7, 8 };
    v16us y = { 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff };
    v16us z = x + y;
&nbsp;
    int i;
&nbsp;
    for (i = 0; i &lt; 8; i++) {
        printf("%d %d\n", i, z[i]);
    }
&nbsp;
    return 0;
}
</pre>

<p>S&nbsp;výsledkem:</p>

<pre>
0 256
1 257
2 258
3 259
4 260
5 261
6 262
7 263
</pre>

<p><div class="rs-tip-major">Poznámka: zde by bylo lepší nahradit osmičku za
výpočet s&nbsp;využitím <strong>sizeof</strong>:</div></p>

<pre>
#include &lt;stdio.h&gt;
&nbsp;
typedef unsigned short int v16us __attribute__((vector_size(16)));
&nbsp;
int main(void)
{
    v16us x = { 1, 2, 3, 4, 5, 6, 7, 8 };
    v16us y = { 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff };
    v16us z = x + y;
&nbsp;
    int i;
&nbsp;
    for (i = 0; i &lt; sizeof(v16us)/sizeof(unsigned short int); i++) {
        printf("%d %d\n", i, z[i]);
    }
&nbsp;
    return 0;
}
</pre>

<p>nebo možná ještě lépe za:</p>

<pre>
#include &lt;stdio.h&gt;
&nbsp;
typedef unsigned short int item;
typedef item v16us __attribute__((vector_size(16)));
&nbsp;
int main(void)
{
    v16us x = { 1, 2, 3, 4, 5, 6, 7, 8 };
    v16us y = { 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff };
    v16us z = x + y;
&nbsp;
    int i;
&nbsp;
    for (i = 0; i &lt; sizeof(v16us)/sizeof(item); i++) {
        printf("%d %d\n", i, z[i]);
    }
&nbsp;
    return 0;
}
</pre>



<p><a name="k18"></a></p>
<h2 id="k18">18. Vektory s&nbsp;hodnotami s&nbsp;plovoucí řádovou čárkou</h2>

<p>Vektory mohou být tvořeny i prvky s&nbsp;numerickými hodnotami
s&nbsp;plovoucí řádovou čárkou, tedy konkrétně hodnotami typu
<strong>single/float</strong> a <strong>double</strong>. Šířku těchto datových
typů si můžeme velmi snadno ověřit:</p>

<pre>
#include &lt;stdio.h&gt;
&nbsp;
typedef float v16f __attribute__((vector_size(16)));
typedef double v16d __attribute__((vector_size(16)));
&nbsp;
int main(void)
{
    printf("scalar float:  %ld bytes\n", sizeof(float));
    printf("vector float:  %ld bytes\n", sizeof(v16f));
&nbsp;
    printf("scalar double: %ld bytes\n", sizeof(double));
    printf("vector double: %ld bytes\n", sizeof(v16d));
&nbsp;
    return 0;
}
</pre>

<p>Z&nbsp;výpočtů je patrné, že první vektor bude obsahovat čtyři prvky typu
<strong>float</strong> a druhý vektor dva prvky typu
<strong>double</strong>:</p>

<pre>
scalar float:  4 bytes
vector float:  16 bytes
scalar double: 8 bytes
vector double: 16 bytes
</pre>

<p>Pokusme se nyní sečíst dva čtyřprvkové vektory:</p>

<pre>
typedef float v16f __attribute__((vector_size(16)));
&nbsp;
int main(void)
{
    v16f x = { 1, 2, 3, 4 };
    v16f y = { 0.1, 0.1, 0.1, 0.1 };
    v16f z = x + y;
&nbsp;
    return 0;
}
</pre>

<p>Pokud povolíme SSE při překladu (dnes výchozí nastavení), bude výsledek
tento:</p>

<pre>
simd07_2.o:     file format elf64-x86-64
&nbsp;
&nbsp;
Disassembly of section .text:
&nbsp;
0000000000000000 &lt;main&gt;:
typedef float v16f __attribute__((vector_size(16)));
&nbsp;
int main(void)
{
   0:   f3 0f 1e fa             endbr64 
   4:   55                      push   rbp
   5:   48 89 e5                mov    rbp,rsp
    v16f x = { 1, 2, 3, 4 };
   8:   0f 28 05 00 00 00 00    movaps xmm0,XMMWORD PTR [rip+0x0]
   f:   0f 29 45 d0             movaps XMMWORD PTR [rbp-0x30],xmm0
    v16f y = { 0.1, 0.1, 0.1, 0.1 };
  13:   0f 28 05 00 00 00 00    movaps xmm0,XMMWORD PTR [rip+0x0]
  1a:   0f 29 45 e0             movaps XMMWORD PTR [rbp-0x20],xmm0
    v16f z = x + y;
  1e:   0f 28 45 d0             movaps xmm0,XMMWORD PTR [rbp-0x30]
  22:   0f 58 45 e0             <strong>addps  xmm0,XMMWORD PTR [rbp-0x20]</strong>
  26:   0f 29 45 f0             movaps XMMWORD PTR [rbp-0x10],xmm0
&nbsp;
    return 0;
  2a:   b8 00 00 00 00          mov    eax,0x0
}
  2f:   5d                      pop    rbp
  30:   c3                      ret    
</pre>

<p>Použita je zde instrukce <strong>ADDPS</strong> neboli &bdquo;add
parallel-scalar&ldquo;, která pracuje s&nbsp;čtyřprvkovými vektory. Tato
instrukce je zakódována na pouhých čtyřech bajtech, což je na platformě x86-64
úspěch :-)</p>

<p>Podobný příklad, ovšem se čtyřprvkovým vektorem, kde prvky jsou typu
<strong>double</strong>:</p>

<pre>
typedef double v16d __attribute__((vector_size(16)));
&nbsp;
int main(void)
{
    v16d x = { 1, 2 };
    v16d y = { 0.1, 0.1 };
    v16d z = x + y;
&nbsp;
    return 0;
}
</pre>

<p>Výsledek překladu do assembleru:</p>

<pre>
&nbsp;
simd08_2.o:     file format elf64-x86-64
&nbsp;
&nbsp;
Disassembly of section .text:
&nbsp;
0000000000000000 &lt;main&gt;:
typedef double v16d __attribute__((vector_size(16)));
&nbsp;
int main(void)
{
   0:   f3 0f 1e fa             endbr64 
   4:   55                      push   rbp
   5:   48 89 e5                mov    rbp,rsp
    v16d x = { 1, 2 };
   8:   66 0f 28 05 00 00 00    movapd xmm0,XMMWORD PTR [rip+0x0]
   f:   00 
  10:   0f 29 45 d0             movaps XMMWORD PTR [rbp-0x30],xmm0
    v16d y = { 0.1, 0.1 };
  14:   66 0f 28 05 00 00 00    movapd xmm0,XMMWORD PTR [rip+0x0]
  1b:   00 
  1c:   0f 29 45 e0             movaps XMMWORD PTR [rbp-0x20],xmm0
    v16d z = x + y;
  20:   66 0f 28 45 d0          movapd xmm0,XMMWORD PTR [rbp-0x30]
  25:   66 0f 58 45 e0          <strong>addpd  xmm0,XMMWORD PTR [rbp-0x20]</strong>
  2a:   0f 29 45 f0             movaps XMMWORD PTR [rbp-0x10],xmm0
&nbsp;
    return 0;
  2e:   b8 00 00 00 00          mov    eax,0x0
}
  33:   5d                      pop    rbp
  34:   c3                      ret    
</pre>

<p>Zde je použita instrukce <strong>addpd</strong>, což je obdoba
<strong>addps</strong>, ovšem pro prvky typu <strong>double</strong> a nikoli
<strong>float/single</strong></p>

<p><div class="rs-tip-major">Poznámka: mnohem zajímavější je použití delších
vektorů, paralelní převody hodnot atd. To je téma, kterému se budeme věnovat
příště.</div></p>



<p><a name="k19"></a></p>
<h2 id="k19">19. Repositář s&nbsp;demonstračními příklady</h2>

<p>Demonstrační příklady napsané v&nbsp;jazyku C, které jsou určené pro překlad
pomocí překladače <strong>GCC C</strong>, byly uložen do Git repositáře, který
je dostupný na adrese <a
href="https://github.com/tisnik/presentations">https://github.com/tisnik/presentations</a>.
Jednotlivé demonstrační příklady si můžete v&nbsp;případě potřeby stáhnout i
jednotlivě bez nutnosti klonovat celý (dnes již velmi rozsáhlý) repositář:</p>

<table>
<tr><th> #</th><th>Příklad</th><th>Stručný popis</th><th>Adresa</th></tr>
<tr><td> 1</td><td>simd01.c</td><td>vektor celých čísel typu <strong>short int</strong></td><td><a href="https://github.com/tisnik/presentations/blob/master/SIMD/simd01.c">https://github.com/tisnik/presentations/blob/master/SIMD/simd01.c</a></td></tr>
<tr><td> 2</td><td>simd02.c</td><td>ukázka použití vektorů s&nbsp;celočíselnými typy bez znaménka</td><td><a href="https://github.com/tisnik/presentations/blob/master/SIMD/simd02.c">https://github.com/tisnik/presentations/blob/master/SIMD/simd02.c</a></td></tr>
<tr><td> 3</td><td>simd03.c</td><td>ukázka použití vektorů s&nbsp;celočíselnými typy se znaménkem</td><td><a href="https://github.com/tisnik/presentations/blob/master/SIMD/simd03.c">https://github.com/tisnik/presentations/blob/master/SIMD/simd03.c</a></td></tr>
<tr><td> 4</td><td>simd04.c</td><td>paralelní součet celočíselných prvků vektorů</td><td><a href="https://github.com/tisnik/presentations/blob/master/SIMD/simd04.c">https://github.com/tisnik/presentations/blob/master/SIMD/simd04.c</a></td></tr>
<tr><td> 5</td><td>simd05.c</td><td>přístup k&nbsp;jednotlivým prvkům vektorů</td><td><a href="https://github.com/tisnik/presentations/blob/master/SIMD/simd05.c">https://github.com/tisnik/presentations/blob/master/SIMD/simd05.c</a></td></tr>
<tr><td> 6</td><td>simd06.c</td><td>vektor čísel s&nbsp;plovoucí řádovou čárkou</td><td><a href="https://github.com/tisnik/presentations/blob/master/SIMD/simd06.c">https://github.com/tisnik/presentations/blob/master/SIMD/simd06.c</a></td></tr>
<tr><td> 7</td><td>simd07.c</td><td>paralelní součet prvků vektorů (typ <strong>float</strong>)</td><td><a href="https://github.com/tisnik/presentations/blob/master/SIMD/simd07.c">https://github.com/tisnik/presentations/blob/master/SIMD/simd07.c</a></td></tr>
<tr><td> 8</td><td>simd08.c</td><td>paralelní součet prvků vektorů (typ <strong>double</strong>)</td><td><a href="https://github.com/tisnik/presentations/blob/master/SIMD/simd08.c">https://github.com/tisnik/presentations/blob/master/SIMD/simd08.c</a></td></tr>
<tr><td> 9</td><td>simd09.c</td><td>překročení délky vektoru</td><td><a href="https://github.com/tisnik/presentations/blob/master/SIMD/simd09.c">https://github.com/tisnik/presentations/blob/master/SIMD/simd09.c</a></td></tr>
<tr><td>10</td><td>simd10.c</td><td>přístup k&nbsp;jednotlivým prvkům vektorů</td><td><a href="https://github.com/tisnik/presentations/blob/master/SIMD/simd10.c">https://github.com/tisnik/presentations/blob/master/SIMD/simd10.c</a></td></tr>
<tr><td>11</td><td>simd11.c</td><td>překročení délky vektoru</td><td><a href="https://github.com/tisnik/presentations/blob/master/SIMD/simd11.c">https://github.com/tisnik/presentations/blob/master/SIMD/simd11.c</a></td></tr>
<tr><td>12</td><td>simd12.c</td><td>dlouhý vektor s&nbsp;256 bajty</td><td><a href="https://github.com/tisnik/presentations/blob/master/SIMD/simd12.c">https://github.com/tisnik/presentations/blob/master/SIMD/simd12.c</a></td></tr>
<tr><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td></tr>
<tr><td>13</td><td>Makefile</td><td>Makefile pro překlad demonstračních příkladů</td><td><a href="https://github.com/tisnik/presentations/blob/master/SIMD/Makefile">https://github.com/tisnik/presentations/blob/master/SIMD/Makefile</a></td></tr>
</table>



<p><a name="k20"></a></p>
<h2 id="k20">20. Odkazy na Internetu</h2>

<ol>

<li>GCC documentation: Extensions to the C Language Family<br />
<a href="https://gcc.gnu.org/onlinedocs/gcc/C-Extensions.html#C-Extensions">https://gcc.gnu.org/onlinedocs/gcc/C-Extensions.html#C-Extensions</a>
</li>

<li>GCC documentation: Using Vector Instructions through Built-in Functions<br />
<a href="https://gcc.gnu.org/onlinedocs/gcc/Vector-Extensions.html">https://gcc.gnu.org/onlinedocs/gcc/Vector-Extensions.html</a>
</li>

<li>SSE (Streaming SIMD Extentions)<br />
<a href="http://www.songho.ca/misc/sse/sse.html">http://www.songho.ca/misc/sse/sse.html</a>
</li>

<li>Timothy A. Chagnon: SSE and SSE2<br />
<a href="http://www.cs.drexel.edu/~tc365/mpi-wht/sse.pdf">http://www.cs.drexel.edu/~tc365/mpi-wht/sse.pdf</a>
</li>

<li>Intel corporation: Extending the Worldr's Most Popular Processor Architecture<br />
<a href="http://download.intel.com/technology/architecture/new-instructions-paper.pdf">http://download.intel.com/technology/architecture/new-instructions-paper.pdf</a>
</li>

<li>SIMD architectures:<br />
<a href="http://arstechnica.com/old/content/2000/03/simd.ars/">http://arstechnica.com/old/content/2000/03/simd.ars/</a>
</li>

<li>Tour of the Black Holes of Computing!: Floating Point<br />
<a href="http://www.cs.hmc.edu/~geoff/classes/hmc.cs105.../slides/class02_floats.ppt">http://www.cs.hmc.edu/~geoff/classes/hmc.cs105.../slides/class02_floats.ppt</a>
</li>

<li>3Dnow! Technology Manual<br />
AMD Inc., 2000</li>

<li>Intel MMX<sup>TM</sup> Technology Overview<br />
Intel corporation, 1996</li>

<li>MultiMedia eXtensions<br />
<a href="http://softpixel.com/~cwright/programming/simd/mmx.php">http://softpixel.com/~cwright/programming/simd/mmx.php</a>i
</li>

<li>AMD K5 ("K5" / "5k86")<br />
<a href="http://www.pcguide.com/ref/cpu/fam/g5K5-c.html">http://www.pcguide.com/ref/cpu/fam/g5K5-c.html</a>
</li>

<li>Sixth Generation Processors<br />
<a href="http://www.pcguide.com/ref/cpu/fam/g6.htm">http://www.pcguide.com/ref/cpu/fam/g6.htm</a>
</li>

<li>Great Microprocessors of the Past and Present<br />
<a href="http://www.cpushack.com/CPU/cpu1.html">http://www.cpushack.com/CPU/cpu1.html</a>
</li>

<li>Very long instruction word (Wikipedia)<br />
<a href="http://en.wikipedia.org/wiki/Very_long_instruction_word">http://en.wikipedia.org/wiki/Very_long_instruction_word</a>
</li>

<li>CPU design (Wikipedia)<br />
<a href="http://en.wikipedia.org/wiki/CPU_design">http://en.wikipedia.org/wiki/CPU_design</a>
</li>

<li>Bulldozer (microarchitecture)<br />
<a href="https://en.wikipedia.org/wiki/Bulldozer_(microarchitecture)">https://en.wikipedia.org/wiki/Bulldozer_(microarchitecture)</a>
</li>

</ol>



<p></p><p></p>
<p><small>Autor: <a href="http://www.fit.vutbr.cz/~tisnovpa">Pavel Tišnovský</a> &nbsp; 2022</small></p>
</body>
</html>

