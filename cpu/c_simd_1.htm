<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
        "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html>
<head>
<title>Užitečné rozšíření GCC - podpora SIMD (vektorových) instrukcí</title>
<meta name="Author" content="Pavel Tisnovsky" />
<meta name="Generator" content="vim" />
<meta http-equiv="content-type" content="text/html; charset=utf-8" />
<style type="text/css">
         body {color:#000000; background:#ffffff;}
         h1  {font-family: arial, helvetica, sans-serif; color:#ffffff; background-color:#c00000; text-align:center; padding-left:1em}
         h2  {font-family: arial, helvetica, sans-serif; color:#ffffff; background-color:#0000c0; padding-left:1em; text-align:left}
         h3  {font-family: arial, helvetica, sans-serif; color:#000000; background-color:#c0c0c0; padding-left:1em; text-align:left}
         h4  {font-family: arial, helvetica, sans-serif; color:#000000; background-color:#e0e0e0; padding-left:1em; text-align:left}
         a   {font-family: arial, helvetica, sans-serif;}
         li  {font-family: arial, helvetica, sans-serif; color:#000000; text-align:justify; width:450px;}
         ol  {font-family: arial, helvetica, sans-serif; color:#000000; text-align:justify; width:450px;}
         ul  {font-family: arial, helvetica, sans-serif; color:#000000; text-align:justify; width:450px;}
         p   {font-family: arial, helvetica, sans-serif; color:#000000; text-align:justify;}
         pre {background:#e0e0e0}
</style>
</head>

<body>

<h1>Užitečné rozšíření GCC - podpora SIMD (vektorových) instrukcí</h1>

<h3>Pavel Tišnovský</h3>

<p></p>

<h1>Úvodník</h1>

<p></p>



<h2>Obsah</h2>

<p><a href="#k01">*** 1. Nepřímý důsledek Moorova zákona &ndash; SIMD instrukce</a></p>
<p><a href="#k02">*** 2. Od klasické von Neumannovy architektury k&nbsp;paralelním výpočtům</a></p>
<p><a href="#k03">*** 3. Architektura x86-64 s&nbsp;nepřeberným množstvím skupin SIMD instrukcí</a></p>
<p><a href="#k04">*** 4. Instrukční sada MMX: první pokus o použití SIMD na platformě x86</a></p>
<p><a href="#k05">*** 5. Registry MMX, vztah ke standardnímu matematickému koprocesoru</a></p>
<p><a href="#k06">*** 6. SIMD instrukce v&nbsp;instrukční sadě 3DNow!</a></p>
<p><a href="#k07">*** 7. Registry používané v&nbsp;rozšíření 3DNow!</a></p>
<p><a href="#k08">*** 8. Nové SIMD instrukce v&nbsp;rozšíření 3DNow!</a></p>
<p><a href="#k09">*** 9. SIMD instrukce v&nbsp;rozšíření SSE</a></p>
<p><a href="#k10">*** 10. Sada registrů použitelná vývojáři pracujícími s&nbsp;procesory podporujícími SSE</a></p>
<p><a href="#k11">*** 11. Nové instrukce přidané v&nbsp;technologii SSE</a></p>
<p><a href="#k12">*** 12. Rozšíření instrukční sady SSE2</a></p>
<p><a href="#k13">*** 13. Nové instrukce přidané v&nbsp;rámci rozšíření instrukční sady SSE2</a></p>
<p><a href="#k14">*** 14. Seznam všech instrukcí SSE2</a></p>
<p><a href="#k15">*** 15. Podpora SIMD instrukcí v&nbsp;GCC</a></p>
<p><a href="#k16">*** 16. </a></p>
<p><a href="#k17">*** 17. </a></p>
<p><a href="#k18">*** 18. </a></p>
<p><a href="#k19">*** 19. Repositář s&nbsp;demonstračními příklady</a></p>
<p><a href="#k20">*** 20. Odkazy na Internetu</a></p>



<p><a name="k01"></a></p>
<h2 id="k01">1. Nepřímý důsledek Moorova zákona &ndash; SIMD instrukce</h2>

<p><i>"...sequential computers are approaching a fundamental physical limit on
their potential power. Such a limit is the speed of light..."</i></p>

<p>V&nbsp;dnešním článku si ukážeme, jakým způsobem je možné v&nbsp;GCC (přesněji v&nbsp;překladači C z&nbsp;rodiny překladačů GCC) používat SIMD instrukce, které jsou zde souhrnně nazývány <i>vektorové instrukce</i>. Přitom SIMD/vektorové instrukce dnes patří ke standardní výbavě prakticky všech moderních mikroprocesorů. Připomeňme si, že z&nbsp;hlediska dosahovaného výpočetního výkonu leží na samém &bdquo;výkonnostním dně&ldquo; klasické mikroprocesory s&nbsp;architekturou <i>CISC</i>, které vykonávají všechny instrukce postupně a dokončení jedné instrukce může v&nbsp;závislosti na jejich složitosti trvat i několik desítek strojových taktů. Předností těchto procesorů může být poměrně velká informační hustota instrukční sady (například i díky tomu, že operandy některých instrukcí jsou zadány implicitně), což mj.&nbsp;znamená, že se procesory tohoto typu po poměrně dlouhou dobu obešly bez nutnosti využití drahých vyrovnávacích pamětí první a druhé úrovně (<i>L1 cache</i>, <i>L2 cache</i>). Klasické procesory s&nbsp;architekturou <i>CISC</i> byly založeny na mikroprogramovém řadiči vybaveném pamětí mikroinstrukcí a teprve později začaly být tyto procesory doplňovány technologiemi získanými z&nbsp;jiných architektur &ndash; instrukční pipeline, prediktorem skoků, vektorovými instrukcemi atd.</p>

<img src="http://i.iinfo.cz/images/311/pc158-1.png" width="450" height="310" alt="&#160;" />
<p><i>Obrázek 1: Ukázka časování instrukce ADC (Add with carry) osmibitového mikroprocesoru MOS 6502 s&nbsp;architekturou CISC. V&nbsp;závislosti na zvoleném adresním režimu se liší počty strojových cyklů od dvou do šesti. Liší se samozřejmě i počet bajtů nutných pro zakódování instrukce, protože některé adresní režimy vyžadují zápis absolutní 16bitové adresy a jiné režimy používají jen 8bitový offset, popř.&nbsp;osmibitovou adresu v&nbsp;rámci takzvané nulté stránky (zero page).</i></p>

<p>Výpočetní výkon mikroprocesorů se podařilo poměrně výrazným způsobem zvýšit u architektury <i>RISC</i> s&nbsp;instrukční pipeline. Provedení jedné instrukce sice stále trvalo větší počet strojových cyklů, ovšem díky rozfázování operací v&nbsp;instrukční pipeline bylo umožněno překrývání většího množství instrukcí, a to bez nutnosti zavádění skutečné paralelizace (která vede k&nbsp;velkému nárůstu složitosti a tím i ceny čipu). Spolu se zavedením mikroprocesorů <i>RISC</i> se skutečně stalo, že reálný i špičkový výpočetní výkon procesorů vzrostl, ale relativně brzy bylo nutné k&nbsp;těmto čipům přidat vyrovnávací paměti (<i>cache</i>), jelikož rychlost procesorů rostla mnohem rychleji, než vybavovací doba pamětí. Tento rozpor mezi rychlostmi obou nejdůležitějších součástí moderních počítačů ostatně trvá dodnes. Pro další zvýšení výpočetního výkonu však bylo nutné použít další technologie, například minule zmíněnou instrukční sadu <i>VLIW</i>, která však &ndash; opět &ndash; měla velké nároky na rychlost pamětí. Podobně jako u procesorů <i>RISC</i>, i u <i>VLIW</i> bylo pro zmírnění požadavků na rychlost pamětí možné použít Harvardskou architekturu, tj.&nbsp;odděleni paměti programu od paměti dat (programová paměť navíc mohla mít větší šířku datové sběrnice odpovídající šířce instrukčních slov).</p>



<p><a name="k02"></a></p>
<h2 id="k02">2. Od klasické von Neumannovy architektury k&nbsp;paralelním výpočtům</h2>

<p>Všechny CISCové mikroprocesory firmy Intel řady <i>80x86</i>, od ještě z&nbsp;poloviny osmibitového čipu <i>Intel 8088</i> až po model <i>Intel 80486</i> (včetně) byly založeny na skalární architektuře <i>SISD</i>, stejně jako velké množství mikrořadičů či digitálních signálových procesorů (<i>DSP &ndash; Digital Signal Processor</i>). Nevýhodou systémů <strong>SISD</strong> ovšem je, že rychlost načítání a tím i zpracování instrukcí je shora omezena a že ani s&nbsp;využitím velmi dlouhé instrukční pipeline se nedá &ndash; vcelku logicky &ndash; překonat limit jedné zpracované instrukce za jeden takt. Příliš velké množství řezů (<i>slices</i>) pipeline má naopak i své zápory, především při zpracování skoků, návratů z&nbsp;podprogramů či odezvy na přerušení &ndash; ve všech těchto případech je nutné vyřešit problém, co se má udělat s&nbsp;instrukcemi, které se nachází v&nbsp;rozpracovaném stavu v&nbsp;pipeline (mohou se buď zahodit nebo naopak dokončit, podle toho, jakým způsobem byl lineární běh programu přerušen).</p>

<a href="http://i.iinfo.cz/images/311/pc158-5.png"><img src="http://i.iinfo.cz/images/311/pc158-5-prev.png" width="259" height="270" alt="&#160;" /></a>
<p><i>Obrázek 5: Schéma systému patřícího do kategorie SISD.</i></p>

<p>V&nbsp;současnosti se těší značné popularitě procesory patřící do kategorie <strong>SIMD</strong>, jejíž kořeny ovšem sahají hluboko do minulosti, konkrétně do šedesátých a sedmdesátých let minulého století (tato oblast výpočetní techniky je spojena se <i>Symourem Crayem</i> a jeho superpočítači).  Do této kategorie patří ty architektury procesorů, u kterých se pomocí jedné instrukce může zpracovat větší množství dat. Například u rozšířené instrukční sady <strong>MMX</strong> je možné pomocí jediné instrukce provést součet dvou vektorů číselných hodnot. Může se jednat o osm osmibitových hodnot uložených v&nbsp;jednom vektoru, čtyři šestnáctibitové hodnoty v&nbsp;jednom vektoru atd.  Této vlastnosti se dá v&nbsp;mnoha případech využít pro urychlení běhu programů, protože některé algoritmy (ve skutečnosti je těchto algoritmů možná až udivující počet) provádí velké množství stejných operací s&nbsp;rozsáhlým objemem dat &ndash; například se může jednat o aplikaci konvolučního filtru na rastrový obrázek, zpracování zvukového signálu, vynásobení matice vektorem, vynásobení dvou matic atd.</p>

<a href="http://i.iinfo.cz/images/311/pc158-7.png"><img src="http://i.iinfo.cz/images/311/pc158-7-prev.png" width="205" height="270" alt="&#160;" /></a>
<p><i>Obrázek 7: Schéma systému patřícího do kategorie SIMD.</i></p>

<p>Mezi přednosti čipů náležejících do kategorie <strong>SIMD</strong> patří jak relativně kompaktní instrukční sada, tak i paralelní a tím pádem i rychlý běh mnoha algoritmů, ovšem za cenu větších nároků kladených na programátora, popř.&nbsp;na překladač. Stále jen velmi malé množství programovacích jazyků totiž umožňuje explicitně vyjádřit vektorové či maticové operace (například u překladače Fortranu určeného pro superpočítače <i>Cray</i> bylo v&nbsp;manuálu explicitně řečeno, které jazykové konstrukce se budou skutečně provádět ve vektorové &ndash; <strong>SISD</strong> &ndash; jednotce). Z&nbsp;tohoto důvodu také není možné většinu <strong>SIMD</strong> konstrukcí zapsat v&nbsp;konvenčním vyšším programovacím jazyce: musí se použít buď hotová makra, ručně optimalizované knihovní funkce nebo specializované programovací jazyky.  Určitou, ale nezanedbatelnou výjimku představují <strong>GPU</strong> na grafických akcelerátorech, které explicitně pracují s&nbsp;2D a 3D vektory, přičemž programátor může předem zjistit, které operace budou skutečně provedeny paralelně.</p>

<a href="http://i.iinfo.cz/images/311/pc158-8.jpg"><img src="http://i.iinfo.cz/images/311/pc158-8-prev.jpg" width="370" height="155" alt="&#160;" /></a>
<p><i>Obrázek 8: Typy vektorů, s&nbsp;nimiž pracují instrukce MMX.</i></p>



<p><a name="k03"></a></p>
<h2 id="k03">3. Architektura x86-64 s&nbsp;nepřeberným množstvím skupin SIMD instrukcí</h2>

<p>Jak jsme se již několikrát zmínili v&nbsp;předchozích odstavcích, jsou v&nbsp;soudobých typech mikroprocesorů implementovány i některé vektorové instrukce (popravdě řečeno již celkový počet vektorových instrukcí pravděpodobně překročil počet instrukcí skalárních :-). Pokud prozatím zůstaneme u platformy <i>x86</i>, tak historicky první instrukční sadou (přesněji řečeno doplněním původní instrukční sady) s&nbsp;podporou vektorových operací byla sada instrukcí <strong>MMX</strong>, s&nbsp;níž přišla firma Intel. Tato sada sice umožňovala provádění vektorových operací, ale měla celou řadu omezení, především nízký počet &bdquo;vektorových&ldquo; registrů, které navíc měly malou bitovou šířku a z&nbsp;toho vycházející nízký počet prvků ve vektorech atd. Nevýhodné taktéž bylo, že se pro instrukce <strong>MMX</strong> používaly registry určené původně pro práci s&nbsp;matematickým koprocesorem (FPU), takže současné provádění FP operací a MMX operací bylo minimálně složité. Ovšem poměrně brzy po uvedení sady <strong>MMX</strong> se objevila konkurenční instrukční sada <strong>3Dnow!</strong> firmy AMD, která byla následovaná již zmíněnými sadami <strong>SSE</strong> až <strong>SSE5</strong>. Podrobnější informace o všech těchto instrukčních sadách si řekneme v&nbsp;navazující části tohoto miniseriálu.</p>

<img src="http://i.iinfo.cz/images/311/pc158-13.png" width="200" height="150" alt="&#160;" />
<p><i>Obrázek 15: Dnes již historický mikroprocesor AMD K6-2 implementující mj.&nbsp;i rozšíření instrukční sady nazvané poněkud zvláštně 3Dnow!</i></p>


<table>
<tr><th>Technologie</th><th>Rok uvedení</th><th>Společnost</th><th>Poprvé použito v&nbsp;čipu</th></tr>
<tr><td><a href="#k04">MMX</a></td><td>1996</td><td>Intel</td><td>Intel Pentium P5</td></tr>
<tr><td><a href="#k06">3DNow!</a></td><td>1998</td><td>AMD</td><td>AMD K6-2</td></tr>
<tr><td>SSE  </td><td>1999</td><td>Intel</td><td>Intel Pentium III (mikroarchitektura P6)</td></tr>
<tr><td>SSE2 </td><td>2001</td><td>Intel</td><td>Intel Pentium 4 (mikroarchitektura NetBurst)</td></tr>
<tr><td>SSE3 </td><td>2004</td><td>Intel</td><td>Intel Pentium 4 (Prescott)</td></tr>
<tr><td>SSSE3</td><td>2006</td><td>Intel</td><td>mikroarchitektura Intel Core</td></tr>
<tr><td>SSE4</td><td>2006</td><td>Intel+AMD</td><td>AMD K10 (SSE4a) , mikroarchitektura Intel Core</td></tr>
<tr><td>SSE5</td><td>2007</td><td>AMD</td><td>(nakonec rozděleno do menších celků), mikroarchitektura Bulldozer</td></tr>
<tr><td>AVX</td><td>2008</td><td>Intel</td><td>mikroarchitektura Sandy Bridge</td></tr>
<tr><td>F16C (CVT16)</td><td>2009</td><td>AMD</td><td>Jaguar, Puma, Bulldozer atd.</td></tr>
<tr><td>XOP </td><td>2009</td><td>AMD</td><td>mikroarchitektura Bulldozer</td></tr>
<tr><td>FMA3</td><td>2012</td><td>AMD</td><td>mikroarchitektura Piledriver, Intel: Haswell a Broadwell</td></tr>
<tr><td>FMA4</td><td>2011</td><td>AMD</td><td>mikroarchitektura Bulldozer (pozdější architektury po Zen 1 již ne)</td></tr>
<tr><td>AVX2</td><td>2013</td><td>Intel</td><td>mikroarchitektura Haswell</td></tr>
<tr><td>AVX-512</td><td>2013</td><td>Intel</td><td>Knights Landing</td></tr>
<tr><td>AMX</td><td>2020</td><td>Intel</td><td>Sapphire Rapids</td></tr>
</table>

<p></p>

<pre>
$ <strong>cat /proc/cpuinfo</strong>
</pre>

<pre>
flags           : fpu vme de pse tsc msr pae mce cx8 apic sep mtrr pge mca cmov
pat pse36 clflush dts acpi mmx fxsr sse sse2 ss ht tm pbe syscall nx pdpe1gb
rdtscp lm constant_tsc art arch_perfmon pebs bts rep_good nopl xtopology
nonstop_tsc cpuid aperfmperf pni pclmulqdq dtes64 monitor ds_cpl vmx smx est
tm2 ssse3 sdbg fma cx16 xtpr pdcm pcid sse4_1 sse4_2 x2apic movbe popcnt
tsc_deadline_timer aes xsave avx f16c rdrand lahf_lm abm 3dnowprefetch
cpuid_fault epb invpcid_single ssbd ibrs ibpb stibp ibrs_enhanced tpr_shadow
vnmi flexpriority ept vpid ept_ad fsgsbase tsc_adjust bmi1 avx2 smep bmi2 erms
invpcid mpx rdseed adx smap clflushopt intel_pt xsaveopt xsavec xgetbv1 xsaves
dtherm ida arat pln pts hwp hwp_notify hwp_act_window hwp_epp md_clear
flush_l1d arch_capabilities
</pre>

<p>Pro někoho může být taktéž zajímavá i informace o tom, jak velké změny v&nbsp;instrukční sadě mikroprocesorů byly vlastně při přidávání nových &bdquo;vektorových&ldquo; rozšiřujících instrukčních sad typu <i>SIMD</i> provedeny. To nám ukáže další tabulka. Je pouze nutné dát pozor na to, že počty nových instrukcí zavedených v&nbsp;rámci těchto nových technologií, které jsou vypsány v&nbsp;tabulce pod odstavcem, nemusí přesně souhlasit s&nbsp;počty uváděnými v&nbsp;jiných informačních materiálech. Je tomu tak především z&nbsp;toho důvodu, že se v&nbsp;některých případech rozlišuje i datový typ, s&nbsp;nímž instrukce pracují (například se může jednat o součet vektoru s&nbsp;32 bitovými hodnotami nebo 64bitovými hodnotami reprezentovanými v&nbsp;obou případech ve formátu s&nbsp;plovoucí řádovou čárkou) a někdy se taková instrukce do celkové sumy započítává pouze jedenkrát. Nicméně údaje vypsané v&nbsp;níže uvedené tabulce by měly být konzistentní, protože se jedná o počty nově přidaných operačních kódů instrukcí (například u dále popsané instrukční sady <i>SSE2</i> končí instrukce znakem <strong>D</strong>, <strong>S</strong>, <strong>I</strong> či <strong>Q</strong> podle typu zpracovávaných dat/operandů):</p>

<table>
<tr><th>Název technologie</th><th>Počet nových instrukcí</th></tr>
<tr><td>MMX</td><td> 56</td></tr>
<tr><td>3DNow!</td><td> 21</td></tr>
<tr><td>SSE</td><td> 70</td></tr>
<tr><td>SSE2</td><td>144</td></tr>
<tr><td>SSE3</td><td> 13</td></tr>
<tr><td>SSSE3</td><td> 32 (ve skutečnosti vlastně jen 16 instrukcí, ovšem pro dva datové typy)</td></tr>
<tr><td>SSE4</td><td> 54 (z&nbsp;toho 47 v&nbsp;rámci SSE4.1, zbytek v&nbsp;rámci SSE4.2)</td></tr>
<tr><td>SSE5</td><td>170 (z&nbsp;toho 46 základních instrukcí)</td></tr>
<tr><td>F16C</td><td> 4</td></tr>
</table>



<p><a name="k04"></a></p>
<h2 id="k04">4. Instrukční sada MMX: první pokus o použití SIMD na platformě x86</h2>

<p>První rozšiřující instrukční sadou obsahující <i>SIMD</i> operace, kterou si v&nbsp;tomto článku alespoň stručně popíšeme, je sada instrukcí nazvaná <i>MMX</i> (<i>MultiMedia eXtension</i>, později taktéž rozepisováno jako <i>Matrix Math eXtension</i>). Tato sada byla navržena v&nbsp;roce 1996 ve firmě Intel a od roku 1997 jí začaly být vybavovány prakticky všechny nové procesory této firmy, které patřily do rodiny <i>x86</i> (připomeňme si, že se jednalo o 32bitové mikroprocesory, protože k&nbsp;rozšíření na 64bitovou ALU došlo u mainstreamových čipů až o několik let později). Prvním procesorem s&nbsp;podporou <i>MMX</i> byl čip <i>Pentium P55C</i> nabízený od začátku roku 1997. Později došlo k&nbsp;implementaci <i>MMX</i> i na čipy <i>Pentium II</i> a procesory konkurenčních společností, konkrétně na čipy <i>AMD K6</i> a taktéž na <i>Cyrix M2 (6x86MX</i>) a <i>IDT C6</i>. Na tomto místě je nutné říci, že se vlastně nejednalo o nijak přelomovou technologii, protože v&nbsp;instrukční sadě <i>MMX</i> jsou použity instrukce  analogické instrukcím ze <i>SPARC VIS</i> (VIS=Visual Instruction Set), <i>MIPS MDMX</i> či <i>HP-PA MAX-1</i> a <i>HP-PA MAX-2</i> (opět se tedy jedná o technologii inspirovanou RISCovými procesory).</p>

<img src="http://i.iinfo.cz/images/161/pc159-1.png" width="282" height="150" alt="&#160;" />
<p><i>Obrázek 3: Jedna z&nbsp;poměrně složitých, ale užitečných instrukcí z&nbsp;instrukční sady MMX. Jedná se o instrukci <strong>PMADDWD</strong>, která provádí paralelní součin čtveřice šestnáctibitových hodnot s&nbsp;32 bitovým mezivýsledkem, s&nbsp;následným součtem prvního + druhého a třetího + čtvrtého mezivýsledku.  Tuto instrukci lze použít například při implementaci konvolučních filtrů.<br />
(Zdroj: Intel MMX<sup>TM</sup> Technology Overview, Intel corporation, 1996)</i></p>

<p>Jedním z&nbsp;důvodů zavedení těchto nových instrukcí byla snaha firmy Intel o konstrukci osobních počítačů s&nbsp;minimálním množstvím specializovaných čipů na základní desce i na přídavných kartách. Většinu operací měl totiž provádět samotný mikroprocesor, ať již se jednalo o zpracování zvuku (softwarový mix), ovládání periferních zařízení (programová implementace bufferů atd.) tak i o softwarovou implementaci kodeků, včetně kodeků používaných v&nbsp;modemech (právě v&nbsp;té době došlo k&nbsp;rozvoji takzvaných softwarových modemů, jejichž příslušenství se zúžilo na pouhé rozhraní pro analogovou telefonní linku). V&nbsp;rámci instrukční sady <i>MMX</i> se na původně prakticky ryze skalární platformu <i>x86</i> přidalo celkem 57 nových instrukcí a čtyři datové typy, které byly těmito instrukcemi podporovány. Jeden z&nbsp;nově zaváděných datových typů je skalární, další tři nové datové typy jsou představovány dvouprvkovým, čtyřprvkovým a osmiprvkovým vektorem.</p>

<img src="http://i.iinfo.cz/images/161/pc159-2.png" width="438" height="154" alt="&#160;" />
<p><i>Obrázek 4: Ukázka jednoho typu konverzní funkce, kterých se v&nbsp;instrukční sadě MMX nachází několik.<br />
(Zdroj: Intel MMX<sup>TM</sup> Technology Overview, Intel corporation, 1996)</i></p>

<p>Většina nových instrukcí přidaných v&nbsp;rámci sady <i>MMX</i> byla určena pro provádění aritmetických a bitových operací s&nbsp;celočíselnými operandy o šířce 8, 16, 32 či 64 bitů, což pokrývá poměrně širokou oblast multimediálních dat &ndash; osmibitových i šestnáctibitových zvukových vzorků (samplů), barev pixelů (RGB, RGBA) atd. Zatímco při provádění aritmetických operací s&nbsp;využitím klasické aritmeticko-logické jednotky mohlo docházet k&nbsp;přetečení či podtečení hodnot při provádění instrukcí typu <strong>ADD</strong> či <strong>SUB</strong> (součet, rozdíl), je možné u <i>MMX</i> instrukcí zvolit i takzvanou aritmetiku se <i>saturací</i>, což znamená, že v&nbsp;případě přetečení se do výsledku uloží maximální reprezentovatelná hodnota a naopak při podtečení minimální hodnota, což je například při zpracování signálu (většinou) žádoucí chování, V&nbsp;následující tabulce jsou vypsány nově podporované datové typy i způsob jejich uložení ve slovech o šířce 64 bitů, které jsou zpracovávány jednotkou <i>MMX</i>:</p>

<table>
<tr><th>Datový typ</th><th>Bitová šířka operandu</th><th>Počet prvků vektoru</th></tr>
<tr><td>packed byte</td><td>8 bitů</td><td>8</td></tr>
<tr><td>packed word</td><td>16 bitů</td><td>4</td></tr>
<tr><td>packed doubleword</td><td>32 bitů</td><td>2</td></tr>
<tr><td>quadword</td><td>64 bitů</td><td>1</td></tr>
</table>

<img src="http://i.iinfo.cz/images/161/pc159-3.png" width="312" height="156" alt="&#160;" />
<p><i>Obrázek 5: Ukázka chování MMX instrukce <strong>PADDW</strong>, která provádí součet čtveřice šestnáctibitových hodnot s&nbsp;přetečením, což je patrné z&nbsp;posledního sloupce.<br />
(Zdroj: Intel MMX<sup>TM</sup> Technology Overview, Intel corporation, 1996)</i></p>

<p>Kromě přímé manipulace s&nbsp;celočíselnými hodnotami bylo relativně snadné pracovat i s&nbsp;numerickými hodnotami ukládanými ve formátu s&nbsp;pevnou řádovou čárkou (<i>FX &ndash; fixed point</i>), mohlo se například jednat o formáty 8.8 (osm bitů pro uložení celé části a osm bitů za řádovou čárkou), 8.24, 24.8 atd. O případné bitové posuny při normalizaci numerických hodnot se v&nbsp;tomto případě musel starat programátor. Tyto formáty byly a jsou využívány v&nbsp;některých algoritmech implementujících <i>FFT</i> (rychlou Fourierovu transformaci využívanou v&nbsp;mnoha algoritmech pro zpracování signálů), <i>DCT</i> (diskrétní kosinovou transformaci využívanou například ve formátu JFIF-JPEG), <i>FIR</i>, <i>IIR</i> (filtry s&nbsp;konečnou a nekonečnou impulsní odezvou), operacemi nad vektory či operacemi nad maticemi.</p>

<img src="http://i.iinfo.cz/images/161/pc159-4.png" width="312" height="156" alt="&#160;" />
<p><i>Obrázek 6: MMX instrukce <strong>PADDUSW</strong>, která sice také provádí součet čtveřice šestnáctibitových hodnot, ovšem součet je proveden se saturací &ndash; v&nbsp;případě, že se výsledek součtu již nemůže reprezentovat šestnáctibitovou hodnotou, uloží se namísto výsledku hodnota 0xFFFF, tj.&nbsp;nejvyšší šestnáctibitové celé číslo bez znaménka.<br />
(Zdroj: Intel MMX<sup>TM</sup> Technology Overview, Intel corporation, 1996)</i></p>

<p>Všech 57 instrukcí v&nbsp;instrukční sadě <i>MMX</i> lze rozdělit podle jejich funkce do několika skupin vypsaných v&nbsp;následující tabulce:</p>

<table>
<tr><th>#</th><th>Skupina instrukcí</th><th>Příklady instrukcí</th></tr>
<tr><td>1</td><td>Základní aritmetické operace</td><td>PADD, PADDS, PADDUS, PSUBS, PSUBUS, PMULHW, PMULLW</td></tr>
<tr><td>2</td><td>Logické (bitové) operace</td><td>PAND, PANDN, POR, PXOR</td></tr>
<tr><td>3</td><td>Bitové posuny</td><td>PSLL, PSRL, PSRA</td></tr>
<tr><td>4</td><td>Porovnávání</td><td>PCMPEQ, PCMGT</td></tr>
<tr><td>5</td><td>Konverze dat</td><td>PACKUSWB, PACKSS, PUNPCKH, PUNPCKL</td></tr>
<tr><td>6</td><td>Přenosy dat + práce s&nbsp;pamětí</td><td>MOV</td></tr>
<tr><td>7</td><td>Řízení jednotky MMX</td><td>EMMS</td></tr>
</table>

<img src="http://i.iinfo.cz/images/51/pc140-11.png" width="256" height="256" alt=" " />
<p><i>Obrázek 7: Zdrojový rastrový obrázek (známá fotografie Lenny), který tvoří zdroj pro jednoduchý konvoluční (FIR) filtr, jenž zvyšuje hodnoty pixelů o pevně zadanou konstantu (offset).</i></p>

<p>Většina instrukcí uvedených v&nbsp;předchozí tabulce má navíc několik variant v&nbsp;závislosti na tom, s&nbsp;jakými operandy má instrukce ve skutečnosti pracovat. Například u instrukce <strong>PADD</strong> (součet) je možné zvolit, zda se mají sečíst dva osmiprvkové vektory, kde každý prvek má šířku 8 bitů, zda se má provést součet dvou čtyřprvkových vektorů (16bitové prvky), dvou dvouprvkových vektorů (32bitové prvky) či zda se jedná o součet dvojice 64bitových skalárních hodnot. To tedy znamená, že instrukce <strong>PADD</strong> může být reprezentována čtveřicí operačních kódů:</p>

<table>
<tr><th>#</th><th>Instrukce</th><th>Význam</th></tr>
<tr><td>1</td><td>PADDB</td><td>součet dvou vektorů majících osm osmibitových prvků</td></tr>
<tr><td>2</td><td>PADDW</td><td>součet dvou vektorů majících čtyři šestnáctibitové prvky</td></tr>
<tr><td>3</td><td>PADDD</td><td>součet dvou vektorů majících dva 32bitové prvky</td></tr>
<tr><td>4</td><td>PADDQ</td><td>součet dvou 64bitových skalárních hodnot</td></tr>
</table>

<p>Výjimkou z&nbsp;výše uvedeného pravidla jsou instrukce <strong>PAND</strong>, <strong>PANDN</strong>, <strong>POR</strong> a <strong>PXOR</strong>, pomocí nichž lze provádět bitové operace s&nbsp;dvojicí 64bitových slov. Důvod, proč není zapotřebí tyto instrukce dále rozdělovat podle počtu a šířky prvků vektorů, je zřejmý &ndash; tyto operace pracují nad jednotlivými bity, nikoli nad skupinami bitů. Na tomto místě je možná dobré upozornit na instrukci <strong>PANDN</strong> (<i>not-and</i>), která sice není ve většině běžných (skalárních) aritmeticko-logických jednotkách implementována, ovšem v&nbsp;případě zpracování rastrových obrazů se jedná o velmi užitečnou instrukci používanou například při vykreslování spritů atd.</p>

<img src="http://i.iinfo.cz/images/51/pc140-12.png" width="256" height="256" alt=" " />
<p><i>Obrázek 8: Pokud je pro přičtení offsetu použita operace součtu se zanedbáním přenosu (carry), tj.&nbsp;když se počítá systémem &bdquo;modulo N&ldquo; (viz též výše zmíněná instrukce <strong>PADDB</strong>), dochází při překročení maximální hodnoty pixelu (čistě bílá barva) k&nbsp;viditelným chybám.</i></p>



<p><a name="k05"></a></p>
<h2 id="k05">5. Registry MMX, vztah ke standardnímu matematickému koprocesoru</h2>

<p>Inženýři ve firmě <i>Intel</i> stáli při návrhu instrukční sady <i>MMX</i> před požadavkem na vytvoření výkonných instrukcí provádějících SIMD operace, na druhou stranu však bylo nutné šetřit počtem tranzistorů a tím pádem i plochou čipu, na němž byl mikroprocesor vytvořen. Pravděpodobně právě z&nbsp;tohoto důvodu se rozhodli učinit poněkud problematický krok &ndash; navrhli <i>MMX</i> instrukce takovým způsobem, aby mohly pracovat s&nbsp;osmicí 64bitových registrů rozdělených na jeden, dva, čtyři či osm prvků. Ovšem nejednalo se o nové registry rozšiřující původní sadu registrů procesoru Pentium, ale o část registrů využívaných matematickým koprocesorem (<i>FPU</i>). Ten na platformě <i>x86</i> prováděl operace s&nbsp;osmicí 80bitových registrů uspořádaných do zásobníku (u matematického koprocesoru <i>Intel 8087</i> byly používány čistě zásobníkové instrukce, později byly přidány i další adresovací režimy, které umožňovaly registry adresovat přímo, což se ukázalo být výhodnější především kvůli možnostem provádění různých optimalizací).</p>

<img src="http://i.iinfo.cz/images/51/pc140-13.png" width="256" height="256" alt=" " />
<p><i>Obrázek 9: Při použití operace součtu se saturací sice taktéž dojde ke ztrátě informace (vzniknou oblasti s&nbsp;pixely majícími hodnotu 255), ovšem viditelná chyba je mnohem menší, než na předchozím obrázku. Tento filtr by bylo možné realizovat s&nbsp;využitím instrukce <strong>PADDUSB</strong> s&nbsp;rychlostí výpočtu 8 pixelů/instrukci.</i></p>

<p>V&nbsp;případě instrukcí <i>MMX</i> se sice registry adresovaly přímo (popř.&nbsp;se adresovala slova uložená v&nbsp;operační paměti, která mohla tvořit jeden z&nbsp;operandů), ale kvůli tomu, že jak <i>FPU</i>, tak i jednotka <i>MMX</i> pracovala se shodnými registry (horních 16 bitů nebylo využito), bylo současné používání SIMD operací a operací s&nbsp;hodnotami uloženými v&nbsp;systému plovoucí řádové čárky poměrně komplikované, což je škoda, protože právě souběžná práce superskalárního CPU (u mikroprocesorů <i>Pentium</i> byly vytvořeny dvě instrukční pipeline &bdquo;u&ldquo; a &bdquo;v&ldquo;), jednotky <i>MMX</i> a navíc ještě matematického koprocesoru by v&nbsp;mnoha případech mohla vést k&nbsp;citelnému nárůstu výpočetního výkonu. V&nbsp;následující tabulce jsou vypsána jména registrů tak, jak jsou použita v&nbsp;instrukcích matematického koprocesoru, i ve formě používané jednotkou <i>MMX</i>:</p>

<table>
<tr><th>Registr FPU</th><th>bity 79-64</th><th>bity 63-0</th></tr>
<tr><td>ST0</td><td>nepoužito</td><td>MM0</td></tr>
<tr><td>ST1</td><td>nepoužito</td><td>MM1</td></tr>
<tr><td>ST2</td><td>nepoužito</td><td>MM2</td></tr>
<tr><td>ST3</td><td>nepoužito</td><td>MM3</td></tr>
<tr><td>ST4</td><td>nepoužito</td><td>MM4</td></tr>
<tr><td>ST5</td><td>nepoužito</td><td>MM5</td></tr>
<tr><td>ST6</td><td>nepoužito</td><td>MM6</td></tr>
<tr><td>ST7</td><td>nepoužito</td><td>MM7</td></tr>
</table>

<a href="http://i.iinfo.cz/images/311/pc158-8.jpg"><img src="http://i.iinfo.cz/images/311/pc158-8-prev.jpg" width="370" height="155" alt="&#160;" /></a>
<p><i>Obrázek 10: Typy vektorů, s&nbsp;nimiž pracují instrukce MMX.</i></p>



<p><a name="k06"></a></p>
<h2 id="k06">6. SIMD instrukce v&nbsp;instrukční sadě 3DNow!</h2>

<p>Rozšíření instrukční sady procesorů z&nbsp;rodiny <i>x86</i> o instrukce <i>MMX</i> bylo poměrně razantní &ndash; jednalo se v&nbsp;podstatě o největší změnu této architektury od vzniku procesoru <i>80386</i>, tj.&nbsp;od zavedení virtuálního režimu, 32bitových registrů a operací s&nbsp;32 bitovými hodnotami.  Z&nbsp;hlediska společnosti <i>Intel</i> se samozřejmě jednalo o nemalou konkurenční výhodu získanou  nad firmami <i>AMD</i>, <i>Cyrix</i> či <i>IDT</i>, zejména poté, co se podpora <i>MMX</i> operací zařadila do některých programových produktů (například do zásuvných modulů Photoshopu). Ovšem tehdejší druhý největší výrobce čipů <i>x86</i> &ndash; společnost <i>AMD</i> &ndash; o necelé dva roky později představila vlastní rozšíření instrukční sady, které bylo označeno poměrně nabubřelým názvem <i>3DNow!</i> (včetně onoho vykřičníku na konci). Toto rozšíření instrukční sady bylo poprvé implementováno v&nbsp;mikroprocesoru <i>AMD K6-2</i> a později též v&nbsp;<i>AMD K6-3</i> a <i>Athlon</i>.</p>

<img src="http://i.iinfo.cz/images/311/pc158-13.png" width="200" height="150" alt="&#160;" />
<p><i>Obrázek 11: Mikroprocesor AMD K6-2 implementující mj.&nbsp;i instrukční sadu 3DNow!</i></p>

<p>Inženýři z&nbsp;firmy <i>AMD</i> použili a současně i rozšířili instrukční
sadu <i>MMX</i> o několik nových celočíselných instrukcí, ovšem hlavní
konkurenční výhodou (a to poměrně podstatnou) byly nové instrukce pro práci
s&nbsp;čísly reprezentovanými 32bitovými hodnotami s&nbsp;plovoucí řádovou
čárkou. Kromě toho bylo do instrukční sady <i>3DNow!</i> přidáno několik
operací sloužících pro přečtení bloku dat do vyrovnávací paměti (cache). U
některých typů procesorů (<i>Athlon</i>) bylo navíc možné určit, zda je blok
dat načtených do vyrovnávací paměti určený pro čtení nebo i pro zápis (pokud se
jednalo o blok určený pro zápis, byl mu nastaven atribut <i>modified</i>).</p>

<img src="http://i.iinfo.cz/images/161/pc159-5.jpg" width="242" height="208" alt="&#160;" />
<p><i>Obrázek 12: Další pohled na mikroprocesor AMD K6-2 s&nbsp;implementací instrukční sady 3DNow!.</i></p>



<p><a name="k07"></a></p>
<h2 id="k07">7. Registry používané v&nbsp;rozšíření 3DNow!</h2>

<p>Již <a href="#k06">v&nbsp;předchozí kapitole</a> jsme se zmínili o tom, že instrukční sada <i>3DNow!</i> byla vlastně rozšířením instrukční sady <i>MMX</i>. To mj.&nbsp;znamená, že byly podporovány všechny datové typy <i>MMX</i>, tj.&nbsp;osmiprvkové vektory s&nbsp;osmibitovými hodnotami, čtyřprvkové vektory s&nbsp;16bitovými hodnotami, dvouprvkové vektory s&nbsp;32bitovými hodnotami a konečně i 64bitové skalární hodnoty. Navíc však bylo možné do 64bitových registrů MMX uložit dvojici 32bitových čísel s&nbsp;plovoucí řádovou čárkou odpovídající formátu <i>single precision</i> definovaném v&nbsp;normě <i>IEEE 754</i>. Zavedení tohoto nového typu dvouprvkového vektoru s&nbsp;sebou přinášelo dvě výhody: mnohé FP operace se mohly provádět paralelně (součet prvků vektorů atd.) a navíc bylo velmi snadné kombinovat původní celočíselné MMX operace s&nbsp;operacemi nad reálnými čísly. To nebylo u původní implementace <i>MMX</i> snadné, protože se muselo provádět přepínání mezi činností matematického koprocesoru a jednotkou MMX.</p>

<a href="http://i.iinfo.cz/images/161/pc159-6.png"><img src="http://i.iinfo.cz/images/161/pc159-6-prev.png" width="370" height="232" alt="&#160;" /></a>
<p><i>Obrázek 13: Mikroprocesor Intel Atom sice implementuje instrukční sadu MMX, ale nikoli 3Dnow!, což je ovšem kompenzováno podporou SSE a SSE2.</i></p>

<p>V&nbsp;případě instrukční sady <i>3DNow!</i> se toto přepínání provádět nemuselo (pokud tedy nebylo nutné pracovat s&nbsp;hodnotami s&nbsp;dvojitou či rozšířenou přesností, tj.&nbsp;s&nbsp;datovými typy <i>double</i> a <i>extended</i>), navíc měli programátoři k&nbsp;dispozici konverzní instrukce <strong>PI2FD</strong> a <strong>PF2ID</strong> pro převod celočíselných 32bitových hodnot na hodnoty s&nbsp;plovoucí řádovou čárkou (se zaokrouhlením) a naopak. Mimochodem: pro přepnutí kontextu mezi FPU operacemi a MMX/3DNow!  operacemi bylo možné použít instrukci <strong>FEMMS</strong> pro rychlé přepnutí kontextu. Tato operace je rychlejší, než původní instrukce <strong>EMMS</strong> ze sady <i>MMX</i>, ovšem po přepnutí je obsah pracovních registrů nedefinovaný (což většinou nevadí).</p>

<a href="http://i.iinfo.cz/images/161/pc159-7.png"><img src="http://i.iinfo.cz/images/161/pc159-7-prev.png" width="370" height="75" alt="&#160;" /></a>
<p><i>Obrázek 14: Uložení dvou 32bitových čísel s&nbsp;plovoucí řádovou čárkou v&nbsp;64bitovém registru.<br />
(Zdroj: 3Dnow! Technology Manual, AMD Inc.)</i></p>



<p><a name="k08"></a></p>
<h2 id="k08">8. Nové SIMD instrukce v&nbsp;rozšíření 3DNow!</h2>

<p>Všechny vektorové instrukce provádějící operace s&nbsp;32bitovými numerickými hodnotami s&nbsp;plovoucí řádovou čárkou, které jsou implementovány v&nbsp;instrukční sadě <i>3DNow!</i>, jsou vypsány v&nbsp;následující tabulce:</p>

<table>
<tr><th> #</th><th>Instrukce</th><th>Popis</th></tr>
<tr><td> 1</td><td>PI2FD   </td><td>převod 32bitových celočíselných hodnot na FP hodnoty</td></tr>
<tr><td> 2</td><td>PF2ID   </td><td>převod 32bitových FP hodnot na celočíselné hodnoty</td></tr>
<tr><td> 3</td><td>PFCMPGE </td><td>porovnání na relaci &bdquo;větší nebo rovno&ldquo;</td></tr>
<tr><td> 4</td><td>PFCMPGT </td><td>porovnání na relaci &bdquo;větší než&ldquo;</td></tr>
<tr><td> 5</td><td>PFCMPEQ </td><td>porovnání na relaci &bdquo;rovnost&ldquo;</td></tr>
<tr><td> 6</td><td>PFACC   </td><td>součet obou prvků zdrojového registru i obou prvků cílového registru</td></tr>
<tr><td> 7</td><td>PFADD   </td><td>součet dvou dvouprvkových vektorů</td></tr>
<tr><td> 8</td><td>PFSUB   </td><td>rozdíl dvou dvouprvkových vektorů</td></tr>
<tr><td> 9</td><td>PFSUBR  </td><td>rozdíl dvou dvouprvkových vektorů s&nbsp;prohozením operandů</td></tr>
<tr><td>10</td><td>PFMIN   </td><td>výpočet minima (vždy mezi příslušnými prvky vektorů)</td></tr>
<tr><td>11</td><td>PFMAX   </td><td>výpočet maxima (vždy mezi příslušnými prvky vektorů)</td></tr>
<tr><td>12</td><td>PFMUL   </td><td>součin dvou dvouprvkových vektorů</td></tr>
<tr><td>13</td><td>PFRCP   </td><td>výpočet aproximace převrácené hodnoty</td></tr>
<tr><td>14</td><td>PFRSQRT </td><td>výpočet aproximace druhé odmocniny</td></tr>
<tr><td>15</td><td>PFRCPIT1</td><td>první krok přesného výpočtu převrácené hodnoty</td></tr>
<tr><td>16</td><td>PFRSQIT1</td><td>první krok přesného výpočtu druhé odmocniny</td></tr>
<tr><td>17</td><td>PFRCPIT2</td><td>další krok výpočtu převrácené hodnoty či druhé odmocniny</td></tr>
</table>

<a href="http://i.iinfo.cz/images/161/pc159-8.png"><img src="http://i.iinfo.cz/images/161/pc159-8-prev.png" width="370" height="119" alt="&#160;" /></a>
<p><i>Obrázek 15: Formát 32bitových čísel s&nbsp;plovoucí řádovou čárkou podporovaný instrukcemi 3Dnow!)<br />
(Zdroj: 3Dnow! Technology Manual, AMD Inc.)</i></p>

<p>Při provádění porovnání prvků dvou vektorů, tj.&nbsp;při provádění instrukcí <strong>PFCMPGE</strong>, <strong>PFCMPGT</strong> a <strong>PFCMPEQ</strong>, je výsledkem této operace nový dvouprvkový vektor obsahující pouze hodnoty 0x0000_0000 a 0xFFFF_FFFF. U porovnávání se navíc nerozlišuje kladná a záporná nula.</p>

<p>Pravděpodobně nejzajímavější je poslední pětice instrukcí nazvaných <strong>PFRCP</strong>, <strong>PFRSQRT</strong>, <strong>PFRCPIT1</strong>, <strong>PFRSQIT1</strong> a <strong>PFRCPIT2</strong>. Instrukce <strong>PFRCP</strong> slouží k&nbsp;rychlému výpočtu převrácené hodnoty, ovšem pouze s&nbsp;přesností na 14 bitů. Pokud tato přesnost není dostatečná (pro mnoho účelů však stačí), musí být použita následující sekvence:</p>

<pre>
PFRCP      ; první přiblížení k výsledku s přesností 14 bitů
PFCPIT1    ; první krok přesného výpočtu převrácené hodnoty
PFRCPIT2   ; druhý krok přesného výpočtu převrácené hodnoty
</pre>

<p>Důležité je, že první přiblížení se k&nbsp;výsledku je provedeno velmi rychle, konkrétně pouze ve dvou taktech, protože se využívá tabulky výsledků umístěné v&nbsp;paměti ROM. Teprve další dvojice instrukcí využívá pomalejší iterační výpočet. Podobný princip platí i pro rychlý vs.&nbsp;přesný výpočet druhé odmocniny.</p>

<a href="http://i.iinfo.cz/images/161/pc159-9.png"><img src="http://i.iinfo.cz/images/161/pc159-9-prev.png" width="370" height="96" alt="&#160;" /></a>
<p><i>Obrázek 16: Subrutina pro operaci dělení s&nbsp;24 bitovou přesností implementovanou pomocí instrukcí 3Dnow!.<br />
(Zdroj: 3Dnow! Technology Manual, AMD Inc.)</i></p>



<p><a name="k09"></a></p>
<h2 id="k09">9. SIMD instrukce v&nbsp;rozšíření SSE</h2>

<p>Po úspěšném a relativně bezproblémovém zavedení rozšíření <i>MMX</i> i <i>3DNow!</i> do praxe není divu, že obě nejvýznamnější společnosti podnikající v&nbsp;oblasti návrhu a prodeje mikroprocesorů patřících do rodiny <i>x86</i>, tj.&nbsp;firmy <i>Intel</i> a <i>AMD</i>, začaly pro tyto typy mikroprocesorů navrhovat i další rozšiřující instrukční sady s&nbsp;&bdquo;vektorovými&ldquo; instrukcemi typu <i>SIMD</i>. V&nbsp;následující tabulce jsou tyto rozšiřující instrukční sady vypsány, včetně roku vzniku dané technologie i informace o tom, v&nbsp;jakém mikroprocesoru byla ta která technologie zpočátku využita. Některé z&nbsp;níže zmíněných technologií byly použity v&nbsp;mikroprocesorech vyráběných jednou společností (což je především případ <i>3DNow!</i>), ovšem v&nbsp;současnosti můžeme vidět oboustranné snahy o zavádění rozšíření instrukční sady <i>x86</i> podle jednotného schématu a navíc tak, aby ho bylo možné používat na mikroprocesorech vyráběných oběma zmíněnými společnostmi. To je poměrně velký rozdíl oproti ad-hoc řešením, s&nbsp;nimiž jsme se setkali v&nbsp;případě <i>MMX</i> i <i>3DNow!</i> (kde navíc byli výrobci čipů svázaní snahou o zachování zpětné kompatibility s&nbsp;existujícími operačními systémy).</p>

<p>Pro programátory je důležitá především technologie <i>SSE</i>, což je zkratka znamenající <i>Streaming SIMD Extension</i>. Na <i>SSE</i> se můžeme dívat buď jako na zcela nové rozšíření instrukční sady o <i>SIMD</i> instrukce, nebo jako na určité propojení předností obou předchozích technologií, tj.&nbsp;jak <i>MMX</i> (relativně velký počet prvků uložených ve vektorech, ovšem podpora pouze pro celočíselné operace nad prvky vektorů), tak i <i>3DNow!</i> (práce s&nbsp;reálnými čísly, ovšem uloženými pouze v&nbsp;dvouprvkových vektorech, z&nbsp;čehož vyplývají menší možnosti paralelizace výpočtů). V&nbsp;případě <i>SSE</i> je navíc umožněna souběžná práce jednotky <i>MMX</i> či <i>FPU</i>.  Ve specifikaci <i>SSE</i> jsou popsány jak významy všech nových instrukcí, tak i různé režimy využívané při aritmetických operacích. Specifikace taktéž říká, jaké registry se u nových instrukcí používají.</p>

<p>Nejprve se zaměřme na registry využívané v&nbsp;technologii <i>SSE</i>. U mikroprocesorů implementujících instrukční sadu <i>SSE</i> je využita nová sada registrů pojmenovaných <strong>XMM0</strong> až <strong>XMM7</strong>. Na 64bitové platformě (architektura AMD 64) navíc došlo k&nbsp;přidání dalších osmi registrů se jmény <strong>XMM8</strong> až <strong>XMM15</strong> využitelných pouze v&nbsp;64bitovém režimu. Všechny nové registry mají šířku 128 bitů, tj.&nbsp;jsou dvakrát širší, než registry používané v&nbsp;<i>MMX</i> i <i>3DNow!</i> a čtyřikrát širší, než běžné pracovní registry na platformě <i>x86</i> (bavíme se o 32bitovém režimu). Do každého registru je možné uložit čtveřici reálných numerických hodnot reprezentovaných v&nbsp;systému plovoucí řádové tečky podle normy <i>IEEE 754</i>, přičemž tato norma je dodržována přesněji, než v&nbsp;případě <i>3DNow!</i> (různé zaokrouhlovací režimy či práce s&nbsp;denormalizovanými čísly sice mohou vypadat trošku jako černá magie, ovšem například v&nbsp;knihovnách pro numerické výpočty, které musí vždy za specifikovaných okolností dát stejný výsledek, se jedná o velmi důležitou vlastnost). K&nbsp;osmi či šestnácti novým registrům <strong>XMM*</strong> byl ještě přidán jeden 32bitový registr nazvaný <strong>MXCSR</strong>, jenž byl určený pro nastavení (řízení) režimů výpočtu.</p>

<img src="http://i.iinfo.cz/images/503/pc160-3.jpg" width="220" height="194" alt="&#160;" />
<p><i>Obrázek 5: Sada nových pracovních registrů přidaných v&nbsp;rámci rozšíření instrukční sady SSE.</i></p>



<p><a name="k10"></a></p>
<h2 id="k10">10. Sada registrů použitelná vývojáři pracujícími s&nbsp;procesory podporujícími SSE</h2>

<p>Díky zavedení rozšíření instrukční sady <i>SSE</i> do praxe začali mít programátoři vytvářející aplikace na 32bitové platformě <i>x86</i>, jejíž začátek se datuje od dnes již spíše historického mikroprocesoru <i>Intel 80386</i>, k&nbsp;dispozici nejenom 64bitové registry (jednotka <i>MMX</i>), ale i registry 128bitové, což je zajisté užitečné. Přitom i přes zavedení rozšířených instrukčních sad <i>MMX/3DNow!/SSE</i> stále zůstávala zachována binární zpětná i dopředná kompatibilita s&nbsp;předchozími typy mikroprocesorů (nejedná se tedy o takovou změnu, jako v&nbsp;případě přechodu 16-&gt;32-&gt;64 bitů). Zde je myšlena především možnost běhu starších aplikací na novějších mikroprocesorech, protože program přeložený s&nbsp;podporou <i>SSE</i> nebude na procesoru bez této technologie pracovat korektně, i když by pravděpodobně bylo možné <i>SSE</i> emulovat pomocí podprogramů spouštěných při zavolání neplatného operačního kódu (tj.&nbsp;operačního kódu SSE instrukce, která je samozřejmě pro ne-SSE procesor neznámým kódem).</p>

<p>Pro zajímavost se podívejme, jak se společně se zavedením instrukční sady <i>SSE</i> prakticky zdvojnásobila celková kapacita všech využitelných registrů na 32bitové platformě <i>x86</i> (na 64bitové <i>x86_64</i> je situace odlišná). V&nbsp;následující tabulce jsou kromě univerzálních pracovních registrů, indexových registrů a bázových registrů vypsány i registry se speciálním významem:</p>

<table>
<tr><th> #</th><th>Typ registrů</th><th>Počet registrů</th><th>Bitová šířka registru</th><th>Příklady</th></tr>
<tr><td> 1</td><td>Univerzální registry </td><td>4</td><td> 32 bitů</td><td>EAX, EBX, ECX, EDX</td></tr>
<tr><td> 2</td><td>Indexové registry    </td><td>3</td><td> 32 bitů</td><td>ESI, EDI, EIP</td></tr>
<tr><td> 3</td><td>Bázové registry      </td><td>2</td><td> 32 bitů</td><td>EBP, ESP</td></tr>
<tr><td> 4</td><td>Segmentové registry  </td><td>6</td><td> 16 bitů</td><td>CS, DS, ES, FS, GS, SS</td></tr>
<tr><td> 5</td><td>Příznakový registr   </td><td>1</td><td> 32 bitů</td><td>EFLAGS (původně 16bitový FLAGS)</td></tr>
<tr><td> 6</td><td>Registry pro ladění  </td><td>8</td><td> 32 bitů</td><td>DR0..DR7</td></tr>
<tr><td> 7</td><td>Řídicí registry      </td><td>4</td><td> 32 bitů</td><td>CR0, CR2, CR3, CR4</td></tr>
<tr><td> 8</td><td>Další spec. registry </td><td>12?</td><td> 32 bitů</td><td>TR1...TR12</td></tr>
<tr><td> 9</td><td>Registry MMX/3DNow!  </td><td>8</td><td> 64 bitů</td><td>shodné s&nbsp;FPU registry st(x), resp.&nbsp;se spodními 64 bity st(x)</td></tr>
<tr><td>10</td><td>Pracovní registry SSE</td><td>8</td><td>128 bitů</td><td>XMM0 .. XMM7</td></tr>
<tr><td>11</td><td>Řídicí registr SSE   </td><td>1</td><td> 32 bitů</td><td>MXCSR</td></tr>
</table>

<img src="http://i.iinfo.cz/images/503/pc160-4.jpg" width="353" height="143" alt="&#160;" />
<p><i>Obrázek 6: Zjednodušený programátorský model architektury x86
v&nbsp;32bitovém režimu.</i></p>



<p><a name="k11"></a></p>
<h2 id="k11">11. Nové instrukce přidané v&nbsp;technologii SSE</h2>

<p>V&nbsp;rámci technologie <i>SSE</i> byla instrukční sada rozšířena o několik typů instrukcí, které většinou pracovaly s&nbsp;již výše zmíněnými registry <strong>XMM*</strong>, popř.&nbsp;taktéž s&nbsp;operační pamětí nebo s&nbsp;obecnými celočíselnými 32bitovými registry procesorů <i>x86</i>, tj.&nbsp;například s&nbsp;registrem <strong>EAX</strong>. Všechny instrukce je možné rozdělit do několika kategorií:</p>

<table>
<tr><th> #</th><th>Kategorie</th><th>Příklad instrukce</th></tr>
<tr><td> 1</td><td>Přenosy dat</td><td>MOVUPS, MOVAPS, MOVHPS, MOVLPS...</td></tr>
<tr><td> 2</td><td>Aritmetické operace</td><td>ADDPS, SUBPS, MULPS, DIVPS, RCPPS...</td></tr>
<tr><td> 3</td><td>Porovnání</td><td>CMPEQSS, CMPEQPS, CMPLTSS, CMPNLTSS, ...</td></tr>
<tr><td> 4</td><td>Logické operace</td><td>ANDPS, ANDNPS, ORPS, XORPS</td></tr>
<tr><td> 5</td><td>Přenosy mezi prvky vektorů (shuffle) a konverze</td><td>SHUFPS, UNPCKHPS, UNPCKLPS</td></tr>
<tr><td> 6</td><td>Načtení dat do cache</td><td>PREFETCH0, ...</td></tr>
</table>

<img src="http://i.iinfo.cz/images/503/pc160-5.png" width="450" height="311" alt="&#160;" />
<p><i>Obrázek 7: Některé instrukce zavedené v&nbsp;rámci SSE pracují pouze s&nbsp;dvojicí skalárních hodnot.</i></p>

<p>Zajímavá je podpora jak skalárních operací, tak i operací vektorových v&nbsp;instrukční sadě <i>SSE</i>. Příkladem může být například skalární instrukce součtu <strong>ADDSS</strong> (SS=single scalar), která může mít dvojí podobu:</p>

<pre>
ADDSS xmm1, xmm2     ; instrukce pracující s dvojicí registrů SSE
ADDSS xmm1, mem32    ; instrukce pracující s registrem SSE a paměťovým místem (32 bitů)
</pre>

<p>Naproti tomu &bdquo;vektorová&ldquo; podoba instrukce součtu <strong>ADDPS</strong> (PS=parallel scalar) pracuje s&nbsp;čtyřprvkovými vektory a zajímavé je, že operační kód této instrukce je o jeden prefixový bajt kratší, než je tomu u dříve zmíněné instrukce <strong>ADDSS</strong> (to dává smysl, protože častěji používané vektorové instrukce zaberou v&nbsp;operační paměti menší objem):</p>

<pre>
ADDPS xmm1, xmm2     ; instrukce pracující s dvojicí registrů SSE
ADDPS xmm1, mem128   ; instrukce pracující s registrem SSE a paměťovým místem (128 bitů)
</pre>

<p>Taktéž stojí za zdůraznění fakt, že se v&nbsp;instrukční sadě <i>SSE</i> nenachází žádné instrukce, v&nbsp;jejichž operačním kódu by se nacházela konstanta. Ta musí být vždy uložena v&nbsp;operační paměti nebo přenesena z&nbsp;obecných registrů.</p>

<img src="http://i.iinfo.cz/images/503/pc160-6.png" width="450" height="304" alt="&#160;" />
<p><i>Obrázek 8: Vektorové operace podporované instrukční sadou SSE.</i></p>

<p>Nejdůležitější skupinou <i>SSE</i> instrukcí jsou instrukce pro provádění aritmetických výpočtů. Tyto instrukce, které jsou vypsány v&nbsp;následující tabulce, pracují buď s&nbsp;dvojicí skalárních hodnot typu <i>float/single</i> umístěných v&nbsp;nejnižších 32 bitech 128bitového registru, nebo naopak s&nbsp;dvojicí vektorů, z&nbsp;nichž každý obsahuje čtyři 32bitové hodnoty opět typu <i>float/single</i>:</p>

<table>
<tr><th> #</th><th>Instrukce se skalárními operandy</th><th>Instrukce pracující s&nbsp;vektory</th><th>Význam instrukce</th></tr>
<tr><td> 1</td><td>ADDSS  </td><td>ADDPS  </td><td>součet</td></tr>
<tr><td> 2</td><td>SUBSS  </td><td>SUBPS  </td><td>rozdíl</td></tr>
<tr><td> 3</td><td>MULSS  </td><td>MULPS  </td><td>součin</td></tr>
<tr><td> 4</td><td>DIVSS  </td><td>DIVPS  </td><td>podíl</td></tr>
<tr><td> 5</td><td>RCPSS  </td><td>RCPPS  </td><td>převrácená hodnota</td></tr>
<tr><td> 6</td><td>SQRTSS </td><td>SQRTPS </td><td>druhá odmocnina</td></tr>
<tr><td> 7</td><td>RSQRTSS</td><td>RSQRTPS</td><td>převrácená hodnota z&nbsp;druhé odmocniny</td></tr>
<tr><td> 8</td><td>MAXSS  </td><td>MAXPS  </td><td>výpočet maxima</td></tr>
<tr><td> 9</td><td>MINSS  </td><td>MINPS  </td><td>výpočet minima</td></tr>
</table>

<a href="http://i.iinfo.cz/images/503/pc160-7.jpg"><img src="http://i.iinfo.cz/images/503/pc160-7-prev.jpg" width="370" height="75" alt="&#160;" /></a>
<p><i>Obrázek 9: Formát 32bitových slov obsahujících hodnoty s&nbsp;plovoucí
řádovou čárkou podle IEEE 754 (single/float).</i></p>



<p><a name="k12"></a></p>
<h2 id="k12">12. Rozšíření instrukční sady SSE2</h2>

<p>Poměrně záhy po uvedení instrukční sady <i>SSE</i> se mnozí vývojáři začali ptát, proč se většina instrukcí omezuje pouze na práci s&nbsp;čísly s&nbsp;jednoduchou přesností, když je mnoho aplikací založených na celočíselných datech (osmibitových bajtech, šestnáctibitových slovech, 32bitových slovech atd.), které by tak mohly využívat všech možností nabízených novými 128bitovými registry technologie <i>SSE</i>. Vývojáři pracující především na vývoji algoritmů z&nbsp;oblasti numerické matematiky by naopak uvítali práci s&nbsp;čísly s&nbsp;dvojitou přesností (<i>double</i>) uloženými v&nbsp;64 bitech (tj.&nbsp;v&nbsp;případě 128bitových registrů by bylo možné do těchto registrů ukládat dvojice čísel s&nbsp;dvojitou přesností). Odpovědí na oba v&nbsp;podstatě protichůdné požadavky byla instrukční sada pojmenovaná jednoduše <i>SSE2</i> z&nbsp;roku 2001. Tato sada byla zpočátku použita v&nbsp;mikroprocesorech <i>Intel Pentium 4</i> a <i>Intel Xeon</i>, později se však rozšířila i na procesory firmy <i>AMD</i> (<i>Athlon64</i>, <i>Opteron</i>).</p>

<p>Technologie <i>SSE2</i> přinesla nové instrukce a samozřejmě i podstatné změny v&nbsp;interní struktuře vektorové jednotky, ovšem počet registrů ani jejich bitová šířka se nijak nezměnila. Programátoři používající, ať již přímo či nepřímo, rozšíření instrukční sady <i>SSE2</i> mohli do osmice 128bitových registrů pojmenovaných <i>XMM*</i> ukládat celkem šest různých typů vektorů.  Základ zůstal nezměněn &ndash; jednalo se o čtyřprvkové vektory obsahující čísla reprezentovaná ve formátu plovoucí řádové čárky, přičemž každé číslo bylo uloženo v&nbsp;32 bitech (4&times;32=128 bitů), což odpovídá typu <i>single/float</i> definovanému v&nbsp;normě <i>IEEE 754</i>. Kromě toho byly v&nbsp;rámci <i>SSE2</i> ještě zavedeny dvouprvkové vektory obsahující taktéž hodnoty reprezentované ve formátu plovoucí řádové čárky, ovšem tentokrát se jedná o čísla uložená v&nbsp;64 bitech (2&times;64=128) odpovídající dvojité přesnosti (<i>double</i>) z&nbsp;normy <i>IEEE 754</i>. Zbývají nám čtyři další podporované datové typy. Jedná se o vektory s&nbsp;celočíselnými prvky: šestnáctiprvkové vektory s&nbsp;osmibitovými hodnotami, osmiprvkové vektory s&nbsp;šestnáctibitovými hodnotami, čtyřprvkové vektory s&nbsp;32bitovými hodnotami a konečně dvouprvkové vektory s&nbsp;64bitovými celočíselnými hodnotami.</p>

<a href="http://i.iinfo.cz/images/221/pc161-03.png"><img src="http://i.iinfo.cz/images/221/pc161-03-prev.png" width="370" height="178" alt="&#160;" /></a>
<p><i>Obrázek 5: Nové typy vektorů, s&nbsp;kterými je nově možné nativně
pracovat na mikroprocesorech podporujících technologii SSE2.</i></p>

<p>Instrukce <i>SSE2</i> je možné využít i v&nbsp;některých oblastech numerické matematiky, i když je na tomto místě nutné říct, že přímo v&nbsp;<i>SSE2</i> nejsou podporována čísla s&nbsp;rozšířenou přesností (<i>extended</i>), takže v&nbsp;některých případech může dojít při výpočtech v&nbsp;jednotce <i>SSE2</i> (a nikoli <i>FPU</i>) ke kumulaci chyb ve výsledku. Nicméně kombinace instrukcí určených pro matematický koprocesor s&nbsp;instrukcemi určenými pro funkční jednotku <i>SSE2</i> byla možná a v&nbsp;mnoha případech dokonce nutná, protože matematický koprocesor kromě základních aritmetických operací podporuje například i výpočet goniometrických funkcí, logaritmů atd.</p>



<p><a name="k13"></a></p>
<h2 id="k13">13. Nové instrukce přidané v&nbsp;rámci rozšíření instrukční sady SSE2</h2>

<p>Zatímco se v&nbsp;rozšiřující instrukční sadě <i>SSE</i> popsané v&nbsp;předchozích kapitolách &bdquo;pouze&ldquo; 70 nových instrukcí, byli tvůrci instrukční sady <i>SSE2</i> mnohem velkorysejší, protože navrhli a posléze i implementovali hned 144 nových instrukcí, což přibližně odpovídá počtu všech základních instrukcí procesorů <i>x86</i> (pokud samozřejmě nepočítáme všechny povolené adresní režimy). Tento velký počet nových instrukcí souvisí jak s&nbsp;podporou šesti datových typů popsaných v&nbsp;předchozí kapitole (včetně více než dvaceti konverzních funkcí), tak i s&nbsp;novými režimy přístupu k&nbsp;prvkům uloženým ve vektorech a se zcela novými operacemi, které byly navrženy pro podporu algoritmů pro 3D grafiku a práci s&nbsp;videem. Všechny instrukce, které byly přidány v&nbsp;rozšiřující instrukční sadě <i>SSE2</i>, je možné rozdělit do několika kategorií:</p>

<ol>
<li>Aritmetické operace prováděné s&nbsp;celými čísly (včetně součtu a rozdílu se saturací)</li>
<li>Aritmetické operace prováděné s&nbsp;čísly s&nbsp;plovoucí řádovou čárkou</li>
<li>Logické operace (některé jsou prováděny pro všech 128 bitů)</li>
<li>Bitové posuny prvků o různé bitové šířce</li>
<li>Porovnávací (komparační, relační) operace</li>
<li>Konverzní funkce</li>
<li>Konverze prvků uložených ve vektorech (zvýšení či snížení bitové šířky, shuffling apod.)</li>
<li>Načítání a ukládání dat do operační paměti</li>
<li>Řízení vyrovnávací paměti (cache)</li>
</ol>

<img src="http://i.iinfo.cz/images/75/pc161-04.png" width="500" height="300" alt="&#160;" />
<p><i>Obrázek 7: Ukázka urychlení operace součtu 1024 číselných prvků
reprezentovaných ve formátu s&nbsp;plovoucí řádovou čárkou. Celkem byly použity
čtyři algoritmy pro součet:<br />
1 - využití instrukcí FPU<br />
2 - využití instrukcí FPU s&nbsp;rozbalením smyčky<br />
3 - využití vektorových operací SSE/SSE2<br />
4 - využití vektorových operací SSE/SSE2 s&nbsp;rozbalením smyčky</i></p>



<p><a name="k14"></a></p>
<h2 id="k14">14. Seznam všech instrukcí SSE2</h2>

<p>Podobně jako u rozšiřujících instrukčních sad <i>MMX</i>, <i>3DNow!</i> a <i>SSE</i>, tvoří i u instrukční sady <i>SSE2</i> nejpodstatnější část instrukce určené pro provádění aritmetických operací nad vektory prvků různých datových typů. Všechny nové operace implementované v&nbsp;<i>SSE2</i> jsou vypsány v&nbsp;následující tabulce. Ve třetím sloupci je naznačeno, jaké vektory jsou danou operací zpracovávány, přičemž první číslo znamená počet prvků vektoru, za nímž následuje bitová šířka jednotlivých prvků:</p>

<table>
<tr><th>#</th><th>Instrukce</th><th>Operace/funkce</th><th>Struktura vektoru</th><th>Datový typ</th><th>Saturace?</th><th>Poznámka</th></tr>
<tr><td> 1</td><td>addpd</td><td>součet</td><td>2&times;64bit</td><td>double</td><td>&times;</td><td>&nbsp;</td></tr>
<tr><td> 2</td><td>addsd</td><td>součet</td><td>1&times;64bit</td><td>double</td><td>&times;</td><td>operace provedena jen s&nbsp;pravým prvkem vektorů</td></tr>
<tr><td> 3</td><td>subpd</td><td>rozdíl</td><td>2&times;64bit</td><td>double</td><td>&times;</td><td>&nbsp;</td></tr>
<tr><td> 4</td><td>subsd</td><td>rozdíl</td><td>1&times;64bit</td><td>double</td><td>&times;</td><td>operace provedena jen s&nbsp;pravým prvkem vektorů</td></tr>
<tr><td> 5</td><td>mulpd</td><td>součin</td><td>2&times;64bit</td><td>double</td><td>&times;</td><td>&nbsp;</td></tr>
<tr><td> 6</td><td>mulsd</td><td>součin</td><td>1&times;64bit</td><td>double</td><td>&times;</td><td>operace provedena jen s&nbsp;pravým prvkem vektorů</td></tr>
<tr><td> 7</td><td>divpd</td><td>podíl</td><td>2&times;64bit</td><td>double</td><td>&times;</td><td>&nbsp;</td></tr>
<tr><td> 8</td><td>divsd</td><td>podíl</td><td>1&times;64bit</td><td>double</td><td>&times;</td><td>operace provedena jen s&nbsp;pravým prvkem vektorů</td></tr>
<tr><td> 9</td><td>paddb</td><td>součet</td><td>16&times;8bit</td><td>integer</td><td>ne </td><td>&nbsp;</td></tr>
<tr><td>10</td><td>paddw</td><td>součet</td><td>8&times;16bit</td><td>integer</td><td>ne </td><td>&nbsp;</td></tr>
<tr><td>11</td><td>paddd</td><td>součet</td><td>4&times;32bit</td><td>integer</td><td>ne </td><td>&nbsp;</td></tr>
<tr><td>12</td><td>paddq</td><td>součet</td><td>2&times;64bit</td><td>integer</td><td>ne </td><td>&nbsp;</td></tr>
<tr><td>13</td><td>paddsb</td><td>součet</td><td>16&times;8bit</td><td>integer</td><td>ano</td><td>&nbsp;</td></tr>
<tr><td>14</td><td>paddsw</td><td>součet</td><td>8&times;16bit</td><td>integer</td><td>ano</td><td>&nbsp;</td></tr>
<tr><td>15</td><td>paddusb</td><td>součet</td><td>16&times;8bit</td><td>unsigned</td><td>ano</td><td>&nbsp;</td></tr>
<tr><td>16</td><td>paddusw</td><td>součet</td><td>8&times;16bit</td><td>unsigned</td><td>ano</td><td>&nbsp;</td></tr>
<tr><td>17</td><td>psubb</td><td>rozdíl</td><td>16&times;8bit</td><td>integer</td><td>ne </td><td>&nbsp;</td></tr>
<tr><td>18</td><td>psubw</td><td>rozdíl</td><td>8&times;16bit</td><td>integer</td><td>ne </td><td>&nbsp;</td></tr>
<tr><td>19</td><td>psubd</td><td>rozdíl</td><td>4&times;32bit</td><td>integer</td><td>ne </td><td>&nbsp;</td></tr>
<tr><td>20</td><td>psubq</td><td>rozdíl</td><td>2&times;64bit</td><td>integer</td><td>ne </td><td>&nbsp;</td></tr>
<tr><td>21</td><td>psubsb</td><td>rozdíl</td><td>16&times;8bit</td><td>integer</td><td>ano</td><td>&nbsp;</td></tr>
<tr><td>22</td><td>psubsw</td><td>rozdíl</td><td>8&times;16bit</td><td>integer</td><td>ano</td><td>&nbsp;</td></tr>
<tr><td>23</td><td>psubusb</td><td>rozdíl</td><td>16&times;8bit</td><td>unsigned</td><td>ano</td><td>&nbsp;</td></tr>
<tr><td>24</td><td>psubusw</td><td>rozdíl</td><td>8&times;16bit</td><td>unsigned</td><td>ano</td><td>&nbsp;</td></tr>
<tr><td>25</td><td>maxpd</td><td>maximu</td><td>2&times;64bit</td><td>double</td><td>&times;</td><td>&nbsp;</td></tr>
<tr><td>26</td><td>maxsd</td><td>maximum</td><td>2&times;64bit</td><td>double</td><td>&times;</td><td>operace provedena jen s&nbsp;pravým prvkem vektorů</td></tr>
<tr><td>27</td><td>minpd</td><td>minimum</td><td>2&times;64bit</td><td>double</td><td>&times;</td><td>&nbsp;</td></tr>
<tr><td>28</td><td>minsd</td><td>minimum</td><td>2&times;64bit</td><td>double</td><td>&times;</td><td>operace provedena jen s&nbsp;pravým prvkem vektorů</td></tr>
<tr><td>29</td><td>pmaddwd</td><td>součin/add</td><td>8&times;16bit</td><td>integer </td><td>&times;</td><td>&nbsp;</td></tr>
<tr><td>30</td><td>pmulhw</td><td>součin</td><td>8&times;16bit</td><td>integer</td><td>&times;</td><td>vrací vektor horních 16 bitů výsledků</td></tr>
<tr><td>31</td><td>pmullw</td><td>součin</td><td>8&times;16bit</td><td>integer</td><td>&times;</td><td>vrací vektor dolních 16 bitů výsledků</td></tr>
<tr><td>32</td><td>pmuludq</td><td>součin</td><td>4&times;32bit</td><td>integer</td><td>&times;</td><td>64 bitový výsledek pro každý součin  </td></tr>
<tr><td>33</td><td>rcpps</td><td>převrácená hodnota</td><td>4&times;32bit</td><td>single</td><td>&times;</td><td>aproximace</td></tr>
<tr><td>34</td><td>rcpss</td><td>převrácená hodnota</td><td>4&times;32bit</td><td>single</td><td>&times;</td><td>operace provedena jen s&nbsp;pravým prvkem vektorů</td></tr>
<tr><td>35</td><td>sqrtpd</td><td>druhá odmocnina</td><td>2&times;64bit</td><td>double</td><td>&times;</td><td>&nbsp;                                                   </td></tr>
<tr><td>36</td><td>sqrtsd</td><td>druhá odmocnina</td><td>2&times;64bit</td><td>double</td><td>&times;</td><td>&nbsp; operace provedena jen s&nbsp;pravým prvkem vektorů</td></tr>
</table>

<img src="http://i.iinfo.cz/images/612/pc161-05.png" width="500" height="300" alt="&#160;" />
<p><i>Obrázek 8: Ukázka urychlení operace výpočtu skalárního součinu pro 1024
trojrozměrných vektorů. Prvky vektorů jsou opět reprezentovány ve formátu
s&nbsp;plovoucí řádovou čárkou. Celkem byly použity čtyři algoritmy pro
součet:<br />
1 - využití instrukcí FPU<br />
2 - využití instrukcí FPU s&nbsp;rozbalením smyčky<br />
3 - využití vektorových operací SSE/SSE2<br />
4 - využití vektorových operací SSE/SSE2 s&nbsp;rozbalením smyčky<br />
Důvod, proč ze došlo k&nbsp;většímu urychlení při použití SSE/SSE2 je
jednoduchý: s&nbsp;jednou načtenými daty (vektory) se provádělo větší množství
operací, takže se zde v&nbsp;menší míře projevila latence operačních pamětí a
další externí vlivy. Sice je možné najít i algoritmy, u nichž je dosaženo ještě
většího urychlení výpočtů, ale v&nbsp;praxi je zhruba trojnásobné urychlení
(podobně jako na tomto grafu) považováno za velký úspěch.</i></p>

<p>V&nbsp;instrukční sadě <i>SSE2</i> můžeme najít i nové logické instrukce a instrukce pro provádění logických či aritmetických posunů. Ve skutečnosti se vlastně jedná o pouhé rozšíření stávajících instrukcí <i>MMX</i> takovým způsobem, aby bylo možné pracovat s&nbsp;novými 128bitovými vektory, popř.&nbsp;s&nbsp;daty uloženými v&nbsp;operační paměti v&nbsp;bloku šestnácti bajtů (16&times;8=128 bitů). Nejprve si popišme instrukce pro aritmetické a logické posuny. Ty dokážou pracovat s&nbsp;celočíselnými hodnotami o velikosti 16, 32, 64 či 128 bitů, tj.&nbsp;každá část vektoru se posouvá zvlášť (je tedy rozdíl mezi posunem jednoho 128bitového čísla a dvojice 64bitových čísel). Při logických posunech se do nového bitu nasouvá vždy logická nula (nikoli příznak <i>carry</i>), u aritmetických posunů se opakuje hodnota původního nejvyššího bitu, tj.&nbsp;instrukce pracují přesně tak, jak to programátoři očekávají:</p>

<table>
<tr><th>#</th><th>Instrukce</th><th>Operace/funkce</th><th>Struktura vektoru</th><th>Datový typ</th><th>Poznámka</th></tr>
<tr><td> 1</td><td>pslldq</td><td>logický posun doleva</td><td>1&times;128bitů</td><td>integer</td><td>&nbsp;</td></tr>
<tr><td> 2</td><td>psllq </td><td>logický posun doleva</td><td>2&times;64bitů </td><td>integer</td><td>&nbsp;</td></tr>
<tr><td> 3</td><td>pslld </td><td>logický posun doleva</td><td>4&times;32bitů </td><td>integer</td><td>&nbsp;</td></tr>
<tr><td> 4</td><td>psllw </td><td>logický posun doleva</td><td>8&times;16bitů </td><td>integer</td><td>&nbsp;</td></tr>
<tr><td> 5</td><td>psrldq</td><td>logický posun doprava</td><td>1&times;128bitů</td><td>integer</td><td>&nbsp;</td></tr>
<tr><td> 6</td><td>psrlq </td><td>logický posun doprava</td><td>2&times;64bitů </td><td>integer</td><td>&nbsp;</td></tr>
<tr><td> 7</td><td>psrld </td><td>logický posun doprava</td><td>4&times;32bitů </td><td>integer</td><td>&nbsp;</td></tr>
<tr><td> 8</td><td>psrlw </td><td>logický posun doprava</td><td>8&times;16bitů </td><td>integer</td><td>&nbsp;</td></tr>
<tr><td> 9</td><td>psrad </td><td>aritmetický posun doprava</td><td>4&times;32bitů </td><td>integer</td><td>&nbsp;</td></tr>
<tr><td>10</td><td>psraw </td><td>aritmetický posun doprava</td><td>8&times;16bitů </td><td>integer</td><td>&nbsp;</td></tr>
</table>



<p><a name="k15"></a></p>
<h2 id="k15">15. Podpora SIMD instrukcí v&nbsp;GCC</h2>

<pre>
#include <stdio.h>

typedef unsigned short int v16us __attribute__((vector_size(16)));

int main(void)
{
    printf("scalar: %ld bytes\n", sizeof(unsigned short int));
    printf("vector: %ld bytes\n", sizeof(v16us));

    return 0;
}
</pre>

<pre>
#include <stdio.h>

typedef unsigned char v16ub __attribute__((vector_size(16)));
typedef unsigned short int v16us __attribute__((vector_size(16)));
typedef unsigned int v16ui __attribute__((vector_size(16)));
typedef unsigned long int v16ul __attribute__((vector_size(16)));

int main(void)
{
    printf("unsigned char:  %ld bytes\n", sizeof(unsigned char));
    printf("unsigned short: %ld bytes\n", sizeof(unsigned short int));
    printf("unsigned int:   %ld bytes\n", sizeof(unsigned int));
    printf("unsigned long:  %ld bytes\n", sizeof(unsigned long int));

    printf("vector unsigned char:  %ld bytes\n", sizeof(v16ub));
    printf("vector unsigned short: %ld bytes\n", sizeof(v16us));
    printf("vector unsigned int:   %ld bytes\n", sizeof(v16ui));
    printf("vector unsigned long:  %ld bytes\n", sizeof(v16ul));

    return 0;
}
</pre>

<pre>
#include <stdio.h>

typedef signed char v16ub __attribute__((vector_size(16)));
typedef signed short int v16us __attribute__((vector_size(16)));
typedef signed int v16ui __attribute__((vector_size(16)));
typedef signed long int v16ul __attribute__((vector_size(16)));

int main(void)
{
    printf("signed char:  %ld bytes\n", sizeof(signed char));
    printf("signed short: %ld bytes\n", sizeof(signed short int));
    printf("signed int:   %ld bytes\n", sizeof(signed int));
    printf("signed long:  %ld bytes\n", sizeof(signed long int));

    printf("vector signed char:  %ld bytes\n", sizeof(v16ub));
    printf("vector signed short: %ld bytes\n", sizeof(v16us));
    printf("vector signed int:   %ld bytes\n", sizeof(v16ui));
    printf("vector signed long:  %ld bytes\n", sizeof(v16ul));

    return 0;
}
</pre>



<p><a name="k16"></a></p>
<h2 id="k16">16. Základní aritmetické operace s&nbsp;vektory</h2>

<pre>
typedef unsigned short int v16us __attribute__((vector_size(16)));

int main(void)
{
    v16us x = { 1, 2, 3, 4, 5, 6, 7, 8 };
    v16us y = { 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff };
    v16us z = x + y;

    return 0;
}
</pre>

<pre>
simd04_1.o:     file format elf64-x86-64


Disassembly of section .text:

0000000000000000 <main>:
typedef unsigned short int v16us __attribute__((vector_size(16)));

int main(void)
{
   0:   f3 0f 1e fa             endbr64 
   4:   55                      push   rbp
   5:   48 89 e5                mov    rbp,rsp
    v16us x = { 1, 2, 3, 4, 5, 6, 7, 8 };
   8:   48 b8 01 00 02 00 03    movabs rax,0x4000300020001
   f:   00 04 00 
  12:   48 ba 05 00 06 00 07    movabs rdx,0x8000700060005
  19:   00 08 00 
  1c:   48 89 45 d0             mov    QWORD PTR [rbp-0x30],rax
  20:   48 89 55 d8             mov    QWORD PTR [rbp-0x28],rdx
    v16us y = { 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff };
  24:   48 b8 ff 00 ff 00 ff    movabs rax,0xff00ff00ff00ff
  2b:   00 ff 00 
  2e:   48 ba ff 00 ff 00 ff    movabs rdx,0xff00ff00ff00ff
  35:   00 ff 00 
  38:   48 89 45 e0             mov    QWORD PTR [rbp-0x20],rax
  3c:   48 89 55 e8             mov    QWORD PTR [rbp-0x18],rdx
  40:   48 b8 00 01 01 01 02    movabs rax,0x103010201010100
  47:   01 03 01 
  4a:   48 ba 04 01 05 01 06    movabs rdx,0x107010601050104
  51:   01 07 01 
    v16us z = x + y;
  54:   48 89 45 f0             mov    QWORD PTR [rbp-0x10],rax
  58:   48 89 55 f8             mov    QWORD PTR [rbp-0x8],rdx

    return 0;
  5c:   b8 00 00 00 00          mov    eax,0x0
}
  61:   5d                      pop    rbp
  62:   c3                      ret    
</pre>

<pre>
simd04_2.o:     file format elf64-x86-64


Disassembly of section .text:

0000000000000000 <main>:
typedef unsigned short int v16us __attribute__((vector_size(16)));

int main(void)
{
   0:   f3 0f 1e fa             endbr64 
   4:   55                      push   rbp
   5:   48 89 e5                mov    rbp,rsp
    v16us x = { 1, 2, 3, 4, 5, 6, 7, 8 };
   8:   66 0f 6f 05 00 00 00    movdqa xmm0,XMMWORD PTR [rip+0x0]        # 10 <main+0x10>
   f:   00 
  10:   0f 29 45 d0             movaps XMMWORD PTR [rbp-0x30],xmm0
    v16us y = { 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff };
  14:   66 0f 6f 05 00 00 00    movdqa xmm0,XMMWORD PTR [rip+0x0]        # 1c <main+0x1c>
  1b:   00 
  1c:   0f 29 45 e0             movaps XMMWORD PTR [rbp-0x20],xmm0
    v16us z = x + y;
  20:   66 0f 6f 45 d0          movdqa xmm0,XMMWORD PTR [rbp-0x30]
  25:   66 0f fd 45 e0          paddw  xmm0,XMMWORD PTR [rbp-0x20]
  2a:   0f 29 45 f0             movaps XMMWORD PTR [rbp-0x10],xmm0

    return 0;
  2e:   b8 00 00 00 00          mov    eax,0x0
}
  33:   5d                      pop    rbp
  34:   c3                      ret    
</pre>



<p><a name="k17"></a></p>
<h2 id="k17">17. Přístup k&nbsp;prvkům vektorů</h2>

<pre>
#include <stdio.h>

typedef unsigned short int v16us __attribute__((vector_size(16)));

int main(void)
{
    v16us x = { 1, 2, 3, 4, 5, 6, 7, 8 };
    v16us y = { 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff };
    v16us z = x + y;

    int i;

    for (i = 0; i < 8; i++) {
        printf("%d %d\n", i, z[i]);
    }

    return 0;
}
</pre>



<p><a name="k18"></a></p>
<h2 id="k18">18. </h2>

<pre>
#include <stdio.h>

typedef float v16f __attribute__((vector_size(16)));
typedef double v16d __attribute__((vector_size(16)));

int main(void)
{
    printf("scalar float:  %ld bytes\n", sizeof(float));
    printf("vector float:  %ld bytes\n", sizeof(v16f));

    printf("scalar double: %ld bytes\n", sizeof(double));
    printf("vector double: %ld bytes\n", sizeof(v16d));

    return 0;
}
</pre>

<pre>
typedef float v16f __attribute__((vector_size(16)));

int main(void)
{
    v16f x = { 1, 2, 3, 4 };
    v16f y = { 0.1, 0.1, 0.1, 0.1 };
    v16f z = x + y;

    return 0;
}
</pre>

<pre>
simd07_1.o:     file format elf64-x86-64


Disassembly of section .text:

0000000000000000 <main>:

int main(void)
{
   0:   f3 0f 1e fa             endbr64 
   4:   55                      push   rbp
   5:   48 89 e5                mov    rbp,rsp
    v16f x = { 1, 2, 3, 4 };
   8:   d9 e8                   fld1   
   a:   d9 5d d0                fstp   DWORD PTR [rbp-0x30]
   d:   d9 05 00 00 00 00       fld    DWORD PTR [rip+0x0]        # 13 <main+0x13>
  13:   d9 5d d4                fstp   DWORD PTR [rbp-0x2c]
  16:   d9 05 00 00 00 00       fld    DWORD PTR [rip+0x0]        # 1c <main+0x1c>
  1c:   d9 5d d8                fstp   DWORD PTR [rbp-0x28]
  1f:   d9 05 00 00 00 00       fld    DWORD PTR [rip+0x0]        # 25 <main+0x25>
  25:   d9 5d dc                fstp   DWORD PTR [rbp-0x24]
    v16f y = { 0.1, 0.1, 0.1, 0.1 };
  28:   d9 05 00 00 00 00       fld    DWORD PTR [rip+0x0]        # 2e <main+0x2e>
  2e:   d9 5d e0                fstp   DWORD PTR [rbp-0x20]
  31:   d9 05 00 00 00 00       fld    DWORD PTR [rip+0x0]        # 37 <main+0x37>
  37:   d9 5d e4                fstp   DWORD PTR [rbp-0x1c]
  3a:   d9 05 00 00 00 00       fld    DWORD PTR [rip+0x0]        # 40 <main+0x40>
  40:   d9 5d e8                fstp   DWORD PTR [rbp-0x18]
  43:   d9 05 00 00 00 00       fld    DWORD PTR [rip+0x0]        # 49 <main+0x49>
  49:   d9 5d ec                fstp   DWORD PTR [rbp-0x14]
    v16f z = x + y;
  4c:   d9 05 00 00 00 00       fld    DWORD PTR [rip+0x0]        # 52 <main+0x52>
  52:   d9 5d f0                fstp   DWORD PTR [rbp-0x10]
  55:   d9 05 00 00 00 00       fld    DWORD PTR [rip+0x0]        # 5b <main+0x5b>
  5b:   d9 5d f4                fstp   DWORD PTR [rbp-0xc]
  5e:   d9 05 00 00 00 00       fld    DWORD PTR [rip+0x0]        # 64 <main+0x64>
  64:   d9 5d f8                fstp   DWORD PTR [rbp-0x8]
  67:   d9 05 00 00 00 00       fld    DWORD PTR [rip+0x0]        # 6d <main+0x6d>
  6d:   d9 5d fc                fstp   DWORD PTR [rbp-0x4]

    return 0;
  70:   b8 00 00 00 00          mov    eax,0x0
}
  75:   5d                      pop    rbp
  76:   c3                      ret    
</pre>

<pre>
simd08_1.o:     file format elf64-x86-64


Disassembly of section .text:

0000000000000000 <main>:
typedef double v16d __attribute__((vector_size(16)));

int main(void)
{
   0:   f3 0f 1e fa             endbr64 
   4:   55                      push   rbp
   5:   48 89 e5                mov    rbp,rsp
    v16d x = { 1, 2 };
   8:   d9 e8                   fld1   
   a:   dd 5d d0                fstp   QWORD PTR [rbp-0x30]
   d:   dd 05 00 00 00 00       fld    QWORD PTR [rip+0x0]        # 13 <main+0x13>
  13:   dd 5d d8                fstp   QWORD PTR [rbp-0x28]
    v16d y = { 0.1, 0.1 };
  16:   dd 05 00 00 00 00       fld    QWORD PTR [rip+0x0]        # 1c <main+0x1c>
  1c:   dd 5d e0                fstp   QWORD PTR [rbp-0x20]
  1f:   dd 05 00 00 00 00       fld    QWORD PTR [rip+0x0]        # 25 <main+0x25>
  25:   dd 5d e8                fstp   QWORD PTR [rbp-0x18]
    v16d z = x + y;
  28:   dd 05 00 00 00 00       fld    QWORD PTR [rip+0x0]        # 2e <main+0x2e>
  2e:   dd 5d f0                fstp   QWORD PTR [rbp-0x10]
  31:   dd 05 00 00 00 00       fld    QWORD PTR [rip+0x0]        # 37 <main+0x37>
  37:   dd 5d f8                fstp   QWORD PTR [rbp-0x8]

    return 0;
  3a:   b8 00 00 00 00          mov    eax,0x0
}
  3f:   5d                      pop    rbp
  40:   c3                      ret    
</pre>



<p><a name="k19"></a></p>
<h2 id="k19">19. </h2>



<p><a name="k20"></a></p>
<h2 id="k20">20. Odkazy na Internetu</h2>

<ol>

<li>SSE (Streaming SIMD Extentions)<br />
<a href="http://www.songho.ca/misc/sse/sse.html">http://www.songho.ca/misc/sse/sse.html</a>
</li>

<li>Timothy A. Chagnon: SSE and SSE2<br />
<a href="http://www.cs.drexel.edu/~tc365/mpi-wht/sse.pdf">http://www.cs.drexel.edu/~tc365/mpi-wht/sse.pdf</a>
</li>

<li>Intel corporation: Extending the Worldr's Most Popular Processor Architecture<br />
<a href="http://download.intel.com/technology/architecture/new-instructions-paper.pdf">http://download.intel.com/technology/architecture/new-instructions-paper.pdf</a>
</li>

<li>
SIMD architectures:<br />
<a href="http://arstechnica.com/old/content/2000/03/simd.ars/">http://arstechnica.com/old/content/2000/03/simd.ars/</a>
</li>

<li>
Tour of the Black Holes of Computing!: Floating Point<br />
<a href="http://www.cs.hmc.edu/~geoff/classes/hmc.cs105.../slides/class02_floats.ppt">http://www.cs.hmc.edu/~geoff/classes/hmc.cs105.../slides/class02_floats.ppt</a>
</li>

<li>3Dnow! Technology Manual<br />
AMD Inc., 2000</li>

<li>Intel MMX<sup>TM</sup> Technology Overview<br />
Intel corporation, 1996</li>

<li>MultiMedia eXtensions<br />
<a href="http://softpixel.com/~cwright/programming/simd/mmx.php">http://softpixel.com/~cwright/programming/simd/mmx.php</a>i
</li>

<li>AMD K5 ("K5" / "5k86")<br />
<a href="http://www.pcguide.com/ref/cpu/fam/g5K5-c.html">http://www.pcguide.com/ref/cpu/fam/g5K5-c.html</a>
</li>

<li>Sixth Generation Processors<br />
<a href="http://www.pcguide.com/ref/cpu/fam/g6.htm">http://www.pcguide.com/ref/cpu/fam/g6.htm</a>
</li>

<li>Great Microprocessors of the Past and Present<br />
<a href="http://www.cpushack.com/CPU/cpu1.html">http://www.cpushack.com/CPU/cpu1.html</a>
</li>

<li>Very long instruction word (Wikipedia)<br />
<a href="http://en.wikipedia.org/wiki/Very_long_instruction_word">http://en.wikipedia.org/wiki/Very_long_instruction_word</a>
</li>

<li>CPU design (Wikipedia)<br />
<a href="http://en.wikipedia.org/wiki/CPU_design">http://en.wikipedia.org/wiki/CPU_design</a>
</li>

<li>Bulldozer (microarchitecture)<br />
<a href="https://en.wikipedia.org/wiki/Bulldozer_(microarchitecture)">https://en.wikipedia.org/wiki/Bulldozer_(microarchitecture)</a>
</li>

</ol>



<p></p><p></p>
<p><small>Autor: <a href="http://www.fit.vutbr.cz/~tisnovpa">Pavel Tišnovský</a> &nbsp; 2022</small></p>
</body>
</html>

