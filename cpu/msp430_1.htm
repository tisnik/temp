<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
        "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html>
<head>
<title>Šestnáctibitové mikrořadiče TI řady MSP430</title>
<meta name="Author" content="Pavel Tisnovsky" />
<meta name="Generator" content="vim" />
<meta http-equiv="content-type" content="text/html; charset=utf-8" />
<style type="text/css">
         body {color:#000000; background:#ffffff;}
         h1  {font-family: arial, helvetica, sans-serif; color:#ffffff; background-color:#c00000; text-align:center; padding-left:1em}
         h2  {font-family: arial, helvetica, sans-serif; color:#ffffff; background-color:#0000c0; padding-left:1em; text-align:left}
         h3  {font-family: arial, helvetica, sans-serif; color:#000000; background-color:#c0c0c0; padding-left:1em; text-align:left}
         h4  {font-family: arial, helvetica, sans-serif; color:#000000; background-color:#e0e0e0; padding-left:1em; text-align:left}
         a   {font-family: arial, helvetica, sans-serif;}
         li  {font-family: arial, helvetica, sans-serif; color:#000000; text-align:justify; width:450px;}
         ol  {font-family: arial, helvetica, sans-serif; color:#000000; text-align:justify; width:450px;}
         ul  {font-family: arial, helvetica, sans-serif; color:#000000; text-align:justify; width:450px;}
         p   {font-family: arial, helvetica, sans-serif; color:#000000; text-align:justify;}
         pre {background:#e0e0e0}
</style>
</head>

<body>

<h1>Šestnáctibitové mikrořadiče TI řady MSP430</h1>

<h3>Pavel Tišnovský</h3>

<p></p>

<h1>Úvodník</h1>

<p>Po popisu osmibitových i šestnáctibitových mikrořadičů z rodiny H8 přichází na řadu další oblíbené a často používané mikrořadiče, které se v některých ohledech rodině H8 podobají. Jedná se o šestnáctibitové mikrořadiče MSP430 společnosti Texas Instruments.</p>



<h2>Obsah</h2>

<p><a href="#k01">1. Šestnáctibitové mikrořadiče TI řady MSP430</a></p>
<p><a href="#k02">2. Režimy činnosti MSP430</a></p>
<p><a href="#k03">3. Organizace operační paměti</a></p>
<p><a href="#k04">4. Pracovní registry mikroprocesoru</a></p>
<p><a href="#k05">5. Struktura stavového registru</a></p>
<p><a href="#k06">6. Instrukční sada čipů MSP430</a></p>
<p><a href="#k07">7. Adresovací režimy</a></p>
<p><a href="#k08">8. Adresování s&nbsp;registrem R0 (PC)</a></p>
<p><a href="#k09">9. Speciální adresovací režimy při použití registrů R2 a R3 &ndash; generátory konstant</a></p>
<p><a href="#k10">10. Adresování bajtů či slov</a></p>
<p><a href="#k11">11. Formát instrukčních slov</a></p>
<p><a href="#k12">12. Instrukce skoku (kód I)</a></p>
<p><a href="#k13">13. Instrukce s&nbsp;dvojicí operandů</a></p>
<p><a href="#k14">14. Instrukce s&nbsp;jedním operandem</a></p>
<p><a href="#k15">15. Odkazy na Internetu</a></p>



<p><a name="k01"></a></p>
<h2 id="k01">1. Šestnáctibitové mikrořadiče TI řady MSP430</h2>

<p>Při popisu mikrořadičů nesmíme zapomenout na oblíbenou a poměrně často
používanou řadu šestnáctibitových čipů založených na jádru <i>MSP430</i>. Tyto
čipy vyrábí společnost Texas Instruments, do jejíhož portfolia náleží i další
(architektonicky zcela odlišné) čipy &ndash; digitální signálové procesory
(<i>TMS320Cxx</i> a další) i <i>MSP432</i> (i přes podobné jméno jsou tyto čipy
založeny na ARMovském jádru Cortex-M4F). Popis mikroprocesorových a
mikrořadičových jader <i>MSP430</i> jsem schválně zařadil ihned za popis jader
<i>H8</i>, protože tyto architektury mají mnoho vlastností společných.</p>

<p>U jader řady <i>MSP430</i> můžeme vidět inspiraci jak v&nbsp;RISCových
procesorech, tak i v&nbsp;oblíbených čipech s&nbsp;architekturou CISC, mezi něž
v&nbsp;tomto případě počítám především Motorolu 68000 či osmibitový procesor
Motorola 6809. Mezi &bdquo;RISCové&ldquo; vlastnosti patří především
minimalisticky pojatá instrukční sada s&nbsp;pouhými 27 instrukcemi a poměrně
rozsáhlá množina pracovních registrů se šestnácti 16bitovými registry (ovšem
pouze dvanáct těchto registrů je skutečně obecně použitelných, protože první
čtyři registry mají odlišné funkce).</p>

<p>Naopak mezi &bdquo;CISCové&ldquo; vlastnosti můžeme zařadit ortogonalitu
instrukční sady, protože prakticky každá instrukce může využít libovolný
dostupný adresovací režim. Z&nbsp;toho mj.&nbsp;vyplývá i další typicky CISCová
vlastnost &ndash; existence instrukcí, které dokážou pracovat s&nbsp;operandy
uloženými v&nbsp;operační paměti, aniž by bylo nutné jeden či oba operandy
nejprve přenést do nějakého pracovního registru (v&nbsp;tomto případě ovšem
instrukce pochopitelně trvají delší dobu; základní doba trvání je totiž pouhý
jeden takt). V&nbsp;tomto ohledu jsou čipy MSP430 pro programátory mnohem
příjemnější, než například řada 8086, kde je patrné, že vznikla vývojem
z&nbsp;osmibitových mikroprocesorů s&nbsp;akumulátorem.</p>



<p><a name="k02"></a></p>
<h2 id="k02">2. Režimy činnosti MSP430</h2>

<p>Šestnáctibitové mikrořadiče jsou v&nbsp;praxi používány mj.&nbsp;i
z&nbsp;toho důvodu, že jsou (alespoň většinou) navrženy pro použití
v&nbsp;režimech nízké spotřeby, což je důležité například u aplikací napájených
z&nbsp;monočlánků, solárních článků či z&nbsp;akumulátorů s&nbsp;malou
kapacitou (klasickým příkladem jsou termostaty či různá další
&bdquo;inteligentní&ldquo;čidla). U mikrořadičů <i>MSP430</i> má programátor
k&nbsp;dispozici hned několik režimů činnosti, mezi kterými se může explicitně
(programově) či automaticky (na základě externí události či při
&bdquo;probuzení&ldquo; watchdogu) přepínat. <a href="#k05">V&nbsp;páté
kapitole</a> si popíšeme strukturu stavového registru, v&nbsp;němž se
mj.&nbsp;nachází i čtyři bity s&nbsp;označením <strong>CPUOFF</strong>,
<strong>OSCOFF</strong>, <strong>SCG0</strong> a <strong>SCG1</strong>, jejichž
modifikací lze zajistit přepnutí mezi takzvaným aktivním režimem a jedním
z&nbsp;pěti režimů s&nbsp;nízkou spotřebou (v&nbsp;originální dokumentaci se
poněkud nadneseně nazývají <i>ultralow-power</i>).</p>

<p>Proč jsou vlastně tyto bity součástí stavového registru? Je to poměrně
elegantní řešení mnoha problémů, protože při příchodu přerušení, které mnohdy
vede k&nbsp;nutnosti přepnutí režimu mikrořadiče, je celý obsah stavového
registru uložen na zásobník a na konci přerušovací rutiny je tento registr
automaticky obnoven, čímž se celý čip vrátí do původního programátorem
zvoleného módu.</p>



<p><a name="k03"></a></p>
<h2 id="k03">3. Organizace operační paměti</h2>

<p>Původní čipy <i>MSP430</i> (bez X na konci) dokážou adresovat 64 kB paměti.
Tento rozsah je rozdělen do několika oblastí, které jsou naznačeny na
následujícím obrázku:</p>

<pre>
       +------------------------------+
0xffff |                              |
       | Tabulka pro vektory přerušení|
       |                              |
0xffe0 +------------------------------+
0xffdf |                              |
       |           Flash/ROM          |
       |                              |
0x???? +------------------------------+
       |                              |
       |             RAM              |
       |                              |
0x0200 +------------------------------+
0x01ff |                              |
       |  Oblast, do které se mapují  |
       |  buffery atd. HW modulů      | adresováno po slovech
       |                              |
0x0100 +------------------------------+
0x00ff |                              |
       |  Oblast, do které se mapují  |
       |  buffery atd. HW modulů      | adresováno po bajtech
       |                              |
0x0010 +------------------------------+
0x000f |                              |
       | SFR - oblast řídicích a      |
       |       stavových registrů HW  | adresováno po bajtech
       |                              |
0x0000 +------------------------------+
</pre>

<p>Poznámka: u některých čipů nalezneme taktéž oblast ROM o kapacitě jednoho
kilobajtu. Tato ROM obsahuje bootloader (pro přenos OS přes sériovou linku) a
je mapována na adresy 0x0c00 až 0x0fff.</p>



<p><a name="k04"></a></p>
<h2 id="k04">4. Pracovní registry mikroprocesoru</h2>

<p>Vzhledem k&nbsp;tomu, že procesory a mikrořadiče řady <i>MSP430</i> zdědily
některé své vlastnosti z&nbsp;RISCových procesorů, asi nás příliš nepřekvapí,
že počet pracovních registrů je poměrně vysoký. Programátoři mají
k&nbsp;dispozici celkem šestnáct pracovních registrů, přičemž každý registr má
šířku šestnácti bitů. Ve skutečnosti je však pouze dvanáct těchto registrů
skutečně univerzálně použitelných, neboť další čtyři registry mají či mohou mít
speciální význam. Konkrétní vlastnosti jednotlivých pracovních registrů nám
ukáže následující tabulka:</p>

<table>
<tr><th>Označení registru</th><th>Jméno</th><th>Stručný popis</th></tr>
<tr><td>R0, PC</td><td>Program Counter</td><td>programový čítač</td></tr>
<tr><td>R1, SP</td><td>Stack Pointer</td><td>ukazatel na vrchol zásobníku</td></tr>
<tr><td>R2, SR, CG1</td><td>Status Register</td><td>stavový registr + generátor konstant</td></tr>
<tr><td>R3, ZR, CG2</td><td>Zero Register</td><td>nulový registr + generátor konstant</td></tr>
<tr><td>R4</td><td>General Purpose</td><td>běžný pracovní registr</td></tr>
<tr><td>R5</td><td>General Purpose</td><td>běžný pracovní registr</td></tr>
<tr><td>R6</td><td>General Purpose</td><td>běžný pracovní registr</td></tr>
<tr><td>R7</td><td>General Purpose</td><td>běžný pracovní registr</td></tr>
<tr><td>R8</td><td>General Purpose</td><td>běžný pracovní registr</td></tr>
<tr><td>R9</td><td>General Purpose</td><td>běžný pracovní registr</td></tr>
<tr><td>R10</td><td>General Purpose</td><td>běžný pracovní registr</td></tr>
<tr><td>R11</td><td>General Purpose</td><td>běžný pracovní registr</td></tr>
<tr><td>R12</td><td>General Purpose</td><td>běžný pracovní registr</td></tr>
<tr><td>R13</td><td>General Purpose</td><td>běžný pracovní registr</td></tr>
<tr><td>R14</td><td>General Purpose</td><td>běžný pracovní registr</td></tr>
<tr><td>R15</td><td>General Purpose</td><td>běžný pracovní registr</td></tr>
</table>

<p>Poznámka: mnoho instrukcí dokáže pracovat s&nbsp;osmibitovými či
šestnáctibitovými operandy. Při použití osmibitových operandů je použita jen
polovina pracovního registru.</p>

<p>Poznámka 2: zápis do registru <strong>R3</strong> nemění jeho hodnotu, stále
zde bude uložena nula. Toho bylo možné využít při snížení počtu instrukcí
procesoru.</p>



<p><a name="k05"></a></p>
<h2 id="k05">5. Struktura stavového registru</h2>

<p>Registr <strong>R2</strong> obsahuje čtyři stavové bity (příznaky)
obsahující informace o právě dokončené aritmetické operaci (<i>overflow</i>,
<i>negative</i>, <i>carry</i> a <i>zero</i>), čtyři řídicí bity určené pro
volbu režimu činnosti procesoru a další řídicí bit, kterým se povolují či
naopak zakazují všechna maskovatelná přerušení. Zbývajících sedm bitů stavového
registru <strong>R2</strong> je rezervováno pro pozdější využití. Podívejme se
nyní na přesnou strukturu stavového registru:</p>

<table>
<tr><th>Bit</th><th>Označení</th><th>Význam zkratky</th><th>Stručný popis</th></tr>
<tr><td>15</td><td>&times;</td><td>&times;</td><td>rezervováno</td></tr>
<tr><td>14</td><td>&times;</td><td>&times;</td><td>rezervováno</td></tr>
<tr><td>13</td><td>&times;</td><td>&times;</td><td>rezervováno</td></tr>
<tr><td>12</td><td>&times;</td><td>&times;</td><td>rezervováno</td></tr>
<tr><td>11</td><td>&times;</td><td>&times;</td><td>rezervováno</td></tr>
<tr><td>10</td><td>&times;</td><td>&times;</td><td>rezervováno</td></tr>
<tr><td> 9</td><td>&times;</td><td>&times;</td><td>rezervováno</td></tr>
<tr><td> 8</td><td>V</td><td>overflow</td><td>přetečení při práci s čísly se znaménkem</td></tr>
<tr><td> 7</td><td>SCG1</td><td>System Clock Generator</td><td>povolení či zákaz SMCLK (Sub-system Master Clock)</td></tr>
<tr><td> 6</td><td>SCG0</td><td>System Clock Generator</td><td>povolení či zákaz DCO (Digitally Controlled Oscillator)</td></tr>
<tr><td> 5</td><td>OSCOFF</td><td>OSCillator OFF</td><td>povolení či zákaz oscilátoru LFXT1 (podrobnější vysvětlení příště)</td></tr>
<tr><td> 4</td><td>CPUOFF</td><td>CPU OFF</td><td>vypnutí CPU (čip bude čekat na přerušení, watchdog atd.)</td></tr>
<tr><td> 3</td><td>GIE</td><td>General Interrupt Enable</td><td>povolení či zákaz všech maskovatelných přerušení</td></tr>
<tr><td> 2</td><td>N</td><td>negative</td><td>příznak záporného výsledku předchozí operace</td></tr>
<tr><td> 1</td><td>Z</td><td>zero</td><td>příznak nulového výsledku předchozí operace</td></tr>
<tr><td> 0</td><td>C</td><td>carry</td><td>příznak přenosu při práci s&nbsp;čísly bez znaménka</td></tr>
</table>

<p>Poznámka: všechny čtyři stavové bity (příznaky) <i>overflow</i>,
<i>negative</i>, <i>carry</i> a <i>zero</i> jsou nastaveny korektně bez ohledu
na to, zda byla ALU operace provedena s&nbsp;bajty či se šestnáctibitovými
slovy.</p>



<p><a name="k06"></a></p>
<h2 id="k06">6. Instrukční sada čipů MSP430</h2>

<p>Instrukční sada čipů <i>MSP430</i> je z&nbsp;pohledu programátora velmi
snadno pochopitelná, protože obsahuje pouze 27 různých instrukcí. Význam
některých instrukcí se však může změnit (resp.&nbsp;přesněji řečeno rozšířit)
při použití určitého adresovacího režimu, protože nesmíme zapomenout na to, že
v&nbsp;sadě pracovních registrů se nachází i programový čítač
<strong>PC</strong>, ukazatel na vrchol zásobníku <strong>SP</strong> a
registry <strong>R2</strong> a <strong>R3</strong>, které se používají jako
takzvané <a href="#k09">generátory konstant</a>. V&nbsp;určitém ohledu můžeme
<i>MSP430</i> považovat za RISCové procesory, ovšem oproti klasickým RISCovým
architekturám se v&nbsp;případě <i>MSP430</i> setkáme s&nbsp;některými
odlišnostmi &ndash; komplikovanějšími adresovacími režimy, použitím instrukcí
s&nbsp;proměnnou délkou, možností používat jako zdrojový či cílový operand
buňku v&nbsp;operační paměti atd.</p>

<p>Poznámka: assemblery pro procesory <i>MSP430</i> akceptují použití aliasů
některých instrukcí (<strong>CLR</strong> atd.) i použití zápisu typu
<strong>mov #1234, R4</strong>, což sice striktně řečeno není validní
instrukce, ale lze ji snadno nahradit již plně validní instrukcí <strong>mov
@R0+, R4</strong>, za níž následuje šestnáctibitová konstanta 1234 (pro více
informací viz navazující kapitoly).</p>



<p><a name="k07"></a></p>
<h2 id="k07">7. Adresovací režimy</h2>

<p>Většina instrukcí pracuje s&nbsp;dvojicí zdrojových operandů a jedním
operandem cílovým. Ovšem vzhledem k&nbsp;tomu, že instrukční slova mají šířku
pouze šestnáct bitů, není možné použít takzvaný <i>tříadresový kód</i>, který
známe z&nbsp;některých 32bitových RISCových architektur (příkladem může být
architektura MIPS, u níž se ale při použití instrukčních slov o šířce třiceti
dvou bitů mnohdy zbytečně plýtvá pamětí). Z&nbsp;tohoto důvodu je vždy jeden ze
zdrojových operandů současně i operandem cílovým. Navíc se ještě počet
adresovacích režimů (alespoň zdánlivě) snížil, zejména při porovnání
s&nbsp;konkurenčními procesory H8, jejichž osmibitové varianty nabízí jedenáct
adresovacích režimů. Čipy <i>MSP430</i> sice nabízí programátorům pouze čtyři
základní adresovací režimy, ovšem tento na první pohled malý počet je ve
skutečnosti vyvážen tím, že mezi pracovními registry je i <strong>PC</strong>
(<i>Program Counter</i>) a <strong>SP</strong> (<i>Stack Pointer</i>), což vede
k&nbsp;některým zajímavým důsledkům, o nichž se zmíníme <a
href="#k08">v&nbsp;navazující kapitole</a>. Adresovací režimy se odlišují podle
toho, zda jsou použity pro zdrojový či pro cílový operand.</p>

<p>Podívejme se nyní na následující dvojici tabulek, které jednotlivé režimy
popisují (povšimněte si, jak se zápis v&nbsp;assembleru podobá zápisu
používaném u čipů H8):</p>

<h3>Adresovací režimy pro zdrojový operand</h3>

<table>
<tr><th>Bity v instrukci</th><th>Zápis v&nbsp;assembleru</th><th>Název režimu</th><th>Stručný popis</th></tr>
<tr><td>00</td><td>Rn</td><td>Register direct</td><td>registr Rn obsahuje zdrojový operand</td></tr>
<tr><td>01</td><td>offset(Rn)</td><td>Register indexed</td><td>zdrojový operand je uložen na adrese Rn+offset</td></tr>
<tr><td>10</td><td>@Rn</td><td>Register indirect</td><td>registr Rn je použit ve funkci ukazatele</td></tr>
<tr><td>11</td><td>@Rn+</td><td>Register indirect with post-increment</td><td>stejné jako předchozí režim, ovšem registr je po provedení operace zvýšen o 1 či 2 podle typu operandů (bajt či slovo)</td></tr>
</table>

<p>V&nbsp;případě, že je použit režim <strong>offset(Rn)</strong>, je ihned za
instrukčním slovem uložen šestnáctibitový offset. Instrukce tedy mohou mít
proměnnou délku.</p>



<h3>Adresovací režimy pro cílový operand</h3>

<table>
<tr><th>Bity v instrukci</th><th>Zápis v&nbsp;assembleru</th><th>Název režimu</th><th>Stručný popis</th></tr>
<tr><td>0</td><td>Rn</td><td>Register direct</td><td>do registru Rn je zapsán výsledek operace</td></tr>
<tr><td>1</td><td>offset(Rn)</td><td>Register indexed</td><td>výsledek operace bude uložen na adresu Rn+offset</td></tr>
</table>

<p>Opět platí, že pokud je použit režim <strong>offset(Rn)</strong>, je ihned
za instrukčním slovem uložen šestnáctibitový offset. Tato vlastnost je
zachována i při použití různých offsetů pro zdrojový a cílový operand,
například:</p>

<pre>
mov 2(R5), 1234(R6)
</pre>

<p>V&nbsp;tomto případě má celá instrukce délku šesti bajtů (tří slov) a její
význam je zhruba následující (ve skutečnosti se jednotlivé kroky mohou částečně
překrývat):</p>

<ol>
<li>Vypočti ADDR1=R5+2</li>
<li>Vypočti ADDR2=R6+1234</li>
<li>Přečti slovo z&nbsp;adresy ADDR1</li>
<li>Ulož toto slovo na adresu ADDR2</li>
<li>Zvyš PC/R0 o hodnotu 6 (krok na další instrukci)</li>
</ol>



<p><a name="k08"></a></p>
<h2 id="k08">8. Adresování s&nbsp;registrem R0 (PC)</h2>

<p>Zápis <strong>offset(PC)</strong> může ve skutečnosti označovat jakoukoli
přesně definovanou adresu v&nbsp;operační paměti, protože assembler již při
překladu programu ví, jaká je při spuštění této instrukce hodnota registru PC
(programy obecně nejsou realokovatelné). To například znamená, že při
programování v&nbsp;assembleru můžeme použít i následující zápis popisující
instrukci pro přenos slova mezi dvěma absolutními adresami označenými návěštími
(<i>labels</i>) <strong>FOO</strong> a <strong>BAR</strong>:</p>

<pre>
mov FOO, BAR
</pre>

<p>Assembler z&nbsp;tohoto zápisu automaticky vygeneruje instrukci:</p>

<pre>
mov x(PC), y(PC)
</pre>

<p>Neboli</p>

<pre>
mov x(R0), y(R0)
</pre>

<p>Kde <strong>x</strong> a <strong>y</strong> jsou assemblerem vypočteny
takovým způsobem, aby platilo x=FOO-PC a y=BAR-PC.</p>

<p>Zápis <strong>@R0</strong> označuje další slovo uložené za instrukcí, které
je možné použít ve funkci vstupního operandu. Ovšem kdyby se například jednalo
o instrukci pro součet, znamenalo by to, že po provedení součtu by se
mikrořadič pokusil přečíst další slovo (obsahující konstantu pro součet) a
interpretovat ho jako instrukci, takže se pravděpodobně se zápisem
<strong>@R0</strong> příliš často nesetkáme.</p>

<p>Ovšem mnohem zajímavější je zápis <strong>@R0+</strong>, který lze použít
pro zdrojový operand ve významu: &bdquo;přečti šestnáctibitové slovo
následující za instrukcí, použij ho jako zdrojový operand a poté posuň PC/R0 až
<strong>za</strong> toto slovo&ldquo;. Tímto jednoduchým trikem vlastně
dokážeme jako zdrojový operand použít šestnáctibitovou konstantu, která je
uložena přesně tam, kde ji potřebujeme mít &ndash; v&nbsp;paměti ROM/EPROM, a
to ihned u instrukce. Dále se ušetří nutnost použití konstanty vyjadřující
adresu zdrojového operandy (ušetří se dva bajty). Podle mého názoru se jedná o
velmi elegantní způsob, který například zabraňuje problémům, s&nbsp;nimiž se
setkávají programátoři používající procesory ARM, u nichž se musí obecné
konstanty (které nelze snadno vypočítat v&nbsp;instrukcích MOV a MVN) přidávat
až za vlastní subrutiny.</p>

<p>Poznámka: assemblery procesorů MSP430 obvykle rozeznávají zápis konstanty ve
tvaru <strong>#1234</strong>, který je převeden na výše uvedené adresování
registrem PC/R0. Tento režim se v&nbsp;manuálech nazývá <i>immediate
mode</i>.</p>



<p><a name="k09"></a></p>
<h2 id="k09">9. Speciální adresovací režimy při použití registrů R2 a R3 &ndash; generátory konstant</h2>

<p>Registry <strong>R2</strong> a <strong>R3</strong> mohou mít ve chvíli, kdy
jsou použity jako zdrojové operandy, význam takzvaných <i>generátorů
konstant</i>, Připomeňme si, že registr <strong>R2</strong> je aliasem pro
stavový registr a <strong>R3</strong> pro registr obsahující konstantní nulu.
To ovšem platí jen ve chvíli, kdy jsou tyto registry použity v&nbsp;adresovacím
režimu <i>Register Mode</i>, tj.&nbsp;když se přímo čte jejich obsah. Pokud je
použit odlišný adresovací režim, je chování registrů <strong>R2</strong> a
<strong>R3</strong> odlišné, neboť mohou generovat pět různých konstant (šestou
konstantou je nula při použití <strong>R3</strong> jako přímého zdrojového
operandu. Podívejme se tedy na vliv jednotlivých adresovacích režimů při
použití registrů <strong>R2</strong> a <strong>R3</strong>:</p>

<table>
<tr><th>Bity v instrukci</th><th>Zdrojový registr</th><th>Konstanta</th><th>Stručný popis</th></tr>
<tr><td>00</td><td>R2</td><td>&times;</td><td>běžný přístup k&nbsp;obsahu registru R2 (Register mode)</td></tr>
<tr><td>01</td><td>R2</td><td>(0)</td><td>absolutní adresování, 16bitová adresa je uložena ihned za instrukčním slovem</td></tr>
<tr><td>10</td><td>R2</td><td>#4</td><td></td></tr>
<tr><td>11</td><td>R2</td><td>#8</td><td></td></tr>
<tr><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td></tr>
<tr><td>00</td><td>R3</td><td>#0</td><td></td></tr>
<tr><td>01</td><td>R3</td><td>#1</td><td></td></tr>
<tr><td>10</td><td>R3</td><td>#2</td><td></td></tr>
<tr><td>11</td><td>R3</td><td>#-1 (0xffff)</td><td></td></tr>
</table>

<p>Poznámka: povšimněte si, že vlastně žádnou funkcionalitu neztrácíme, protože
ani <strong>R2</strong> ani <strong>R3</strong> nemají v&nbsp;režimech @Rn atd.
žádný praktický význam.</p>

<p>Díky existenci těchto adresovacích režimů je možné v&nbsp;programech
používat šestici výše zmíněných konstant, které nevyžadují, aby se za
instrukčním slovem nacházela skutečná konstanta (to zajistí assembler
automaticky). Program je tak kratší a je prováděn rychleji. Navíc díky tomu, že
registry R2 a R3 generují &bdquo;vhodné&ldquo; konstanty, dokáže assembler
nahradit zápis <strong>INC dest</strong> za <strong>ADD 0(R3), dest</strong>
(konstanta #1 v&nbsp;předchozí tabulce), <strong>CLR dest</strong> je možné
nahradit za <strong>MOV R3, dest</strong> (konstanta #0 v&nbsp;předchozí
tabulce) atd.</p>

<p>Ve výsledku obsahuje instrukční soubor jen 27 instrukcí, ovšem dalších 24
instrukcí je emulováno právě použitím registrů R2 a R3 a jejich speciálního
významu při použití ve funkci zdrojového operandu.</p>



<p><a name="k10"></a></p>
<h2 id="k10">10. Adresování bajtů či slov</h2>

<p>V&nbsp;assembleru je možné u některých instrukcí zvolit, zda se mají operace
provádět s&nbsp;hodnotami typu bajt či šestnáctibitové slovo. Odlišení se
provádí systémem, který jsme již viděli u procesorů H8 &ndash; připojením
postfixu &bdquo;.b&ldquo; či &bdquo;.w&ldquo; k&nbsp;mnemotechnickému kódu
instrukce.  Přitom platí, že výchozím režimem je práce se šestnáctibitovými
slovy, takže se vlastně &bdquo;.w&ldquo; nemusí uvádět a v&nbsp;praxi se ani
neuvádí (uvidíme ho pouze při debugování či disassemblingu).</p>



<p><a name="k11"></a></p>
<h2 id="k11">11. Formát instrukčních slov</h2>

<p>Instrukce procesorů a mikrořadičů <i>MSP430</i> můžeme podle formátu
instrukčních slov rozdělit do pouhých tří skupin, což opět připomíná dělení
instrukcí v&nbsp;čistě RISCových procesorech MIPS. Jednotlivé skupiny instrukcí
budou podrobněji popsány v&nbsp;navazující trojici kapitol.</p>

<p>Všechny instrukce mají shodnou šířku šestnácti bitů, ovšem v&nbsp;některých
režimech adresace se za instrukčním slovem může objevit jedna či dokonce dvě
šestnáctibitové konstanty. Instrukční slova jsou rozdělena do několika bitových
polí (samozřejmě ne všechna pole jsou vždy přítomna):</p>

<ul>
<li>Operační kód instrukce (použit vždy)</li>
<li>Kód podmínky skoku (podmíněné a nepodmíněné skoky)</li>
<li>Offset vůči registru PC (použit u skoků)</li>
<li>Index registru pro zdrojový operand (4 bity)</li>
<li>Index registru pro cílový operand (4 bity)</li>
<li>Adresovací režim pro zdrojový operand (2 bity)</li>
<li>Adresovací režim pro cílový operand (1 bit)</li>
<li>Režim výpočtu nad bajty či slovy (1 bit)</li>
</ul>



<p><a name="k12"></a></p>
<h2 id="k12">12. Instrukce skoku (kód I)</h2>

<p>Začneme instrukcemi skoku, které obsahují jak kód podmínky (sedm podmínek +
jeden nepodmíněný skok), tak i desetibitový offset vůči registru PC, offset je
před použitím vynásoben dvěma, protože instrukce mohou začínat vždy pouze na
sudé adrese. Rozsah offsetu je tedy PC-1022 až PC+1024:</p>

<pre>
 15 14 13 12 11 10  9  8  7  6  5  4  3  2  1  0
+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+
| op.kód |podmínka|   offset vůči registru PC   |
+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+
</pre>

<p>Povšimněte si, že operační kód instrukce má pouze tři bity, zatímco u dále
popsaných formátů jsou to čtyři bity resp.&nbsp;dokonce devět bitů. U skoků to
však nijak nevadí, protože všech osm instrukcí skoku používá naprosto stejný
operační kód.</p>

<p>Tři bity podmínky dovolují specifikovat již zmíněných sedm skutečných
podmínek a jeden nepodmíněný skok:</p>

<table>
<tr><th>#</th><th>Instrukce</th><th>Alias</th><th>Význam</th></tr>
<tr><td>000</td><td>JEQ</td><td>JZ </td><td>skok při podmínce zero_flag==1</td></tr>
<tr><td>001</td><td>JNE</td><td>JNZ</td><td>skok při podmínce zero_flag==0</td></tr>
<tr><td>010</td><td>JC </td><td>&times;</td><td>skok při podmínce carry_flag==1</td></tr>
<tr><td>011</td><td>JNC</td><td>&times;</td><td>skok při podmínce carry_flag==0</td></tr>
<tr><td>100</td><td>JN </td><td>&times;</td><td>skok při podmínce negative_flag==1 (obrácená podmínka neexistuje)</td></tr>
<tr><td>101</td><td>JGE</td><td>&times;</td><td>skok při podmínce negative_flag &oplus; overflow_flag==0</td></tr>
<tr><td>110</td><td>JL </td><td>&times;</td><td>skok při podmínce negative_flag &oplus; overflow_flag==1</td></tr>
<tr><td>111</td><td>JMP</td><td>&times;</td><td>nepodmíněný skok</td></tr>
</table>

<p>Poznámka: pokud je zapotřebí provést nepodmíněný skok na <i>jakoukoli</i>
adresu, lze samozřejmě použít instrukci <strong>mov #konstanta,
PC</strong>.</p>



<p><a name="k13"></a></p>
<h2 id="k13">13. Instrukce s&nbsp;dvojicí operandů</h2>

<p>Většina aritmetických a logických instrukcí obsahuje v&nbsp;instrukčním
slovu specifikaci zdrojového operandu i operandu cílového. Zdrojový operand je
specifikován <a href="#k07">adresovacím režimem</a> (2 bity) a indexem
registru, protože všechny čtyři dostupné adresovací režimy pracují
s&nbsp;libovolným zdrojovým registrem. Cílový operand je taktéž specifikován
adresovacím režimem (pouze jeden bit) a opět indexem pracovního registru. Kromě
toho je nutné jedním bitem zvolit, zda se mají operace provádět s&nbsp;bajty
nebo se šestnáctibitovými slovy:</p>

<pre>
 15 14 13 12 11 10  9  8  7  6  5  4  3  2  1  0
+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+
|  op.kód   |zdr.registr|AD|BW| AS  |cíl.registr|
+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+
</pre>

<p>Význam jednotlivých bitových polí:</p>

<ul>
<li>Operační kód instrukce</li>
<li>Index registru pro první zdrojový operand (4 bity)</li>
<li><strong>AD</strong>: adresovací režim pro zdrojový operand (2 bity)</li>
<li><strong>BW</strong>: režim výpočtu nad bajty či slovy (1 bit)</li>
<li><strong>AS</strong>: adresovací režim pro cílový operand (1 bit)</li>
<li>Index registru pro druhý zdrojový a současně i cílový operand (4 bity)</li>
</ul>

<p>Poznámka: cílový registr (a adresovací režim) samozřejmě platí i pro druhý
operand &ndash; není zde použit tříadresový kód.</p>



<p><a name="k14"></a></p>
<h2 id="k14">14. Instrukce s&nbsp;jedním operandem</h2>

<p>Sedm instrukcí využívá pouze jediný zdrojový a/nebo cílový operand, takže
v&nbsp;tomto případě mohlo dojít k&nbsp;dosti podstatnému zjednodušení
instrukčního slova, jehož formát vypadá následovně:</p>

<pre>
 15 14 13 12 11 10  9  8  7  6  5  4  3  2  1  0
+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+
|  operační kód instrukce  |BW| AD  |  registr  |
+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+
</pre>

<p>Význam jednotlivých bitových polí:</p>

<ul>
<li>Operační kód instrukce</li>
<li><strong>BW</strong>: režim výpočtu nad bajty či slovy (1 bit)</li>
<li><strong>AD</strong>: adresovací režim pro zdrojový i cílový operand (2 bity)</li>
<li>Index registru pro zdrojový a současně i cílový operand (4 bity)</li>
</ul>

<p>Poznámka: podrobnější popis jednotlivých instrukcí a současně i popis
standardních modulů (časovače, A/D, D/A atd.) bude uveden v&nbsp;pokračování
tohoto článku.</p>



<p><a name="k15"></a></p>
<h2 id="k15">15. Odkazy na Internetu</h2>

<ol>

<li>MSP430 Development Hardware<br />
<a href="http://www.argenox.com/library/msp430/msp430-development-hardware-chapter-1/">http://www.argenox.com/library/msp430/msp430-development-hardware-chapter-1/</a>
</li>

<li>MSP430™ ultra-low-power Microcontrollers<br />
<a href="http://www.ti.com/lsds/ti/microcontrollers_16-bit_32-bit/msp/overview.page?HQS=msp430">http://www.ti.com/lsds/ti/microcontrollers_16-bit_32-bit/msp/overview.page?HQS=msp430</a>
</li>

<li>An introduction to the TI MSP430 low-power microcontrollers<br />
<a href="http://mspgcc.sourceforge.net/manual/c68.html">http://mspgcc.sourceforge.net/manual/c68.html</a>
</li>

<li>MSP430 LaunchPad Tutorials<br />
<a href="http://processors.wiki.ti.com/index.php/MSP430_LaunchPad_Tutorials">http://processors.wiki.ti.com/index.php/MSP430_LaunchPad_Tutorials</a>
</li>

<li>LaunchPad MSP430 Assembly Language Tutorial<br />
<a href="http://robotics.hobbizine.com/asmlau.html">http://robotics.hobbizine.com/asmlau.html</a>
</li>

<li>TI 16-bit and 32-bit microcontrollers<br />
<a href="http://www.ti.com/lsds/ti/microcontrollers_16-bit_32-bit/overview.page">http://www.ti.com/lsds/ti/microcontrollers_16-bit_32-bit/overview.page</a>
</li>

<li>TI MSP430 (Wikipedia)<br />
<a href="https://en.wikipedia.org/wiki/TI_MSP430">https://en.wikipedia.org/wiki/TI_MSP430</a>
</li>

<li>Introduction to Getting Started with MSP430<br />
<a href="http://www.argenox.com/library/msp430/msp430-preface-intro/">http://www.argenox.com/library/msp430/msp430-preface-intro/</a>
</li>

<li>H8/300H Series Software Manual<br />
<a href="https://www.renesas.com/en-us/doc/products/mpumcu/001/rej09b0213_h8300h.pdf">https://www.renesas.com/en-us/doc/products/mpumcu/001/rej09b0213_h8300h.pdf</a>
</li>

<li>Renesas H8/300H Series Manuals<br />
<a href="https://www.manualslib.com/products/Renesas-H8-300h-Series-2312446.html">https://www.manualslib.com/products/Renesas-H8-300h-Series-2312446.html</a>
</li>

<li>H8 Family<br />
<a href="https://en.wikipedia.org/wiki/H8_Family">https://en.wikipedia.org/wiki/H8_Family</a>
</li>

<li>H8/300 and H8/300L<br />
<a href="http://nah6.com/~itsme/download/ibutton/h8_8bit.pdf">http://nah6.com/~itsme/download/ibutton/h8_8bit.pdf</a>
</li>

<li>H8 Family<br />
<a href="https://www.renesas.com/en-us/products/microcontrollers-microprocessors/h8.html">https://www.renesas.com/en-us/products/microcontrollers-microprocessors/h8.html</a>
</li>

<li>(GCC) Status of Supported Architectures from Maintainers' Point of View<br />
<a href="https://gcc.gnu.org/backends.html">https://gcc.gnu.org/backends.html</a>
</li>

<li>(GCC) H8/300 Options<br />
<a href="https://gcc.gnu.org/onlinedocs/gcc/H8_002f300-Options.html#H8_002f300-Options">https://gcc.gnu.org/onlinedocs/gcc/H8_002f300-Options.html#H8_002f300-Options</a>
</li>

<li>GCC for SuperH,H8/300,AVR<br />
<a href="http://mes.osdn.jp/h8/gcc.html">http://mes.osdn.jp/h8/gcc.html</a>
</li>

<li>H8/3802, 38002S, 38004, 38104 (manuály k&nbsp;čipům)<br />
<a href="https://www.renesas.com/en-us/document/hw-manual?hwLayerShowFlg=true&prdLayerId=184&layerName=H8%252F3802%252C%2B38002S%252C%2B38004%252C%2B38104&coronrService=document-prd-search&hwDocUrl=%2Fen-us%2Fdoc%2Fproducts%2Fmpumcu%2F001%2Frej09b0024_h83802.pdf&hashKey=c5e1fa0a18c01e6c789bc7b5c0184ed9">https://www.renesas.com/en-us/document/hw-manual?hwLayerShowFlg=true&prdLayerId=184&layerName=H8%252F3802%252C%2B38002S%252C%2B38004%252C%2B38104&coronrService=document-prd-search&hwDocUrl=%2Fen-us%2Fdoc%2Fproducts%2Fmpumcu%2F001%2Frej09b0024_h83802.pdf&hashKey=c5e1fa0a18c01e6c789bc7b5c0184ed9</a>
</li>

<li>Addressing mode (Wikipedia)<br />
<a href="https://en.wikipedia.org/wiki/Addressing_mode">https://en.wikipedia.org/wiki/Addressing_mode</a>
</li>

<li>Renesas SH Instruction Set Summary<br />
<a href="http://shared-ptr.com/sh_insns.html">http://shared-ptr.com/sh_insns.html</a>
</li>

<li>SH-4 RISC Processor by HITACHI<br />
<a href="http://www.cs.umd.edu/~meesh/cmsc411/website/projects/risc/risc.htm">http://www.cs.umd.edu/~meesh/cmsc411/website/projects/risc/risc.htm</a>
</li>

<li>SH-4 RISC Processor<br />
<a href="http://www.cs.umd.edu/~meesh/cmsc411/website/projects/risc/sh-4.htm">http://www.cs.umd.edu/~meesh/cmsc411/website/projects/risc/sh-4.htm</a>
</li>

<li>SuperH RISC engine Family Features<br />
<a href="https://www.renesas.com/en-us/products/microcontrollers-microprocessors/superh/superh-features.html">https://www.renesas.com/en-us/products/microcontrollers-microprocessors/superh/superh-features.html</a>
</li>

<li>Orthogonal instruction set<br />
<a href="https://en.wikipedia.org/wiki/Orthogonal_instruction_set">https://en.wikipedia.org/wiki/Orthogonal_instruction_set</a>
</li>

<li>Status Register<br />
<a href="https://en.wikipedia.org/wiki/Status_register">https://en.wikipedia.org/wiki/Status_register</a>
</li>

<li>6800 Instruction Set<br />
<a href="http://www.electronics.dit.ie/staff/tscarff/6800/Instructions/instructions.htm">http://www.electronics.dit.ie/staff/tscarff/6800/Instructions/instructions.htm</a>
</li>

<li>Assembly language today<br />
<a href="http://beust.com/weblog/2004/06/23/assembly-language-today/">http://beust.com/weblog/2004/06/23/assembly-language-today/</a>
</li>

<li>Calling subroutines<br />
<a href="http://infocenter.arm.com/help/index.jsp?topic=/com.arm.doc.kui0100a/armasm_cihcfigg.htm">http://infocenter.arm.com/help/index.jsp?topic=/com.arm.doc.kui0100a/armasm_cihcfigg.htm</a>
</li>

<li>Art of Assembly - Arithmetic Instructions<br />
<a href="http://oopweb.com/Assembly/Documents/ArtOfAssembly/Volume/Chapter_6/CH06-2.html">http://oopweb.com/Assembly/Documents/ArtOfAssembly/Volume/Chapter_6/CH06-2.html</a>
</li>

<li>X86 Assembly/Arithmetic<br />
<a href="https://en.wikibooks.org/wiki/X86_Assembly/Arithmetic">https://en.wikibooks.org/wiki/X86_Assembly/Arithmetic</a>
</li>

<li>ARM subroutines &amp; program stack<br />
<a href="http://www.toves.org/books/armsub/">http://www.toves.org/books/armsub/</a>
</li>

<li>Programming from the Ground Up Book - Summary<br />
<a href="http://savannah.nongnu.org/projects/pgubook/">http://savannah.nongnu.org/projects/pgubook/</a>
</li>

<li>The 6502 overflow flag explained mathematically <br />
<a href="http://www.righto.com/2012/12/the-6502-overflow-flag-explained.html">http://www.righto.com/2012/12/the-6502-overflow-flag-explained.html</a>
</li>

</ol>



<p></p><p></p>
<p><small>Autor: <a href="http://www.fit.vutbr.cz/~tisnovpa">Pavel Tišnovský</a> &nbsp; 2016</small></p>
</body>
</html>

