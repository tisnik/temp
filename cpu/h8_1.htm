<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
        "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html>
<head>
<title>Rodina mikroprocesorů a mikrořadičů H8</title>
<meta name="Author" content="Pavel Tisnovsky" />
<meta name="Generator" content="vim" />
<meta http-equiv="content-type" content="text/html; charset=utf-8" />
<style type="text/css">
         body {color:#000000; background:#ffffff;}
         h1  {font-family: arial, helvetica, sans-serif; color:#ffffff; background-color:#c00000; text-align:center; padding-left:1em}
         h2  {font-family: arial, helvetica, sans-serif; color:#ffffff; background-color:#0000c0; padding-left:1em; text-align:left}
         h3  {font-family: arial, helvetica, sans-serif; color:#000000; background-color:#c0c0c0; padding-left:1em; text-align:left}
         h4  {font-family: arial, helvetica, sans-serif; color:#000000; background-color:#e0e0e0; padding-left:1em; text-align:left}
         a   {font-family: arial, helvetica, sans-serif;}
         li  {font-family: arial, helvetica, sans-serif; color:#000000; text-align:justify; width:450px;}
         ol  {font-family: arial, helvetica, sans-serif; color:#000000; text-align:justify; width:450px;}
         ul  {font-family: arial, helvetica, sans-serif; color:#000000; text-align:justify; width:450px;}
         p   {font-family: arial, helvetica, sans-serif; color:#000000; text-align:justify;}
         pre {background:#e0e0e0}
</style>
</head>

<body>

<h1>Rodina mikroprocesorů a mikrořadičů H8</h1>

<h3>Pavel Tišnovský</h3>

<p></p>

<h1>Úvodník</h1>

<p>Po popisu RISCových jader SuperH se seznámíme s další rodinou mikroprocesorů a mikrořadičů navržených společností Hitachi. Jedná se o jádra z rodiny H8, v níž nalezneme celou řadu čipů &ndash; od osmibitových mikrořadičů až po výkonné 32bitové integrované obvody.</p>



<h2>Obsah</h2>

<p><a href="#k01">1. Osmibitové mikrořadiče H8/300 a H8/300L</a></p>
<p><a href="#k02">2. Organizace operační paměti</a></p>
<p><a href="#k03">3. Pracovní registry</a></p>
<p><a href="#k04">4. Speciální registry</a></p>
<p><a href="#k05">5. Podporované adresovací režimy</a></p>
<p><a href="#k06">6. Instrukční sada osmibitových mikrořadičů H8/300 a H8/300L</a></p>
<p><a href="#k07">7. Instrukce pro přenosy dat</a></p>
<p><a href="#k08">8. Aritmetické operace</a></p>
<p><a href="#k09">9. Logické operace</a></p>
<p><a href="#k10">10. Bitové posuny a rotace</a></p>
<p><a href="#k11">11. Booleovský procesor &ndash; manipulace s&nbsp;jednotlivými bity</a></p>
<p><a href="#k12">12. Nepodmíněné skoky, vstup a výstup z&nbsp;podprogramů (subrutin)</a></p>
<p><a href="#k13">13. Podmíněné skoky</a></p>
<p><a href="#k14">14. Instrukce pro řízení procesoru</a></p>
<p><a href="#k15">15. Instrukce pro blokový přenos dat</a></p>
<p><a href="#k16">16. Odkazy na Internetu</a></p>



<p><a name="k01"></a></p>
<h2 id="k01">1. Osmibitové mikrořadiče H8/300 a H8/300L</h2>

<p>Po popisu RISCových mikroprocesorů patřících do rodiny čipů SuperH se na
chvíli budeme věnovat architektuře H8, která se sice od SuperH v&nbsp;několika
ohledech liší, ale například již při letmém pohledu do instrukčních sad je
patrné, že za vznikem obou těchto architektur stála stejná firma &ndash;
Hitachi. Architektura H8 je ve skutečnosti tvořena několika řadami (rodinami)
čipů s&nbsp;různou šířkou zpracovávaných operandů. Dnes se budeme věnovat čipům
patřícím do rodiny H8/300 a H8/300L, což jsou interně osmibitové čipy, které
však u některých instrukcí (zdaleka ne však u všech instrukcí) dokážou využít i
šestnáctibitové operandy. Do rodiny H8/300 a H8/300L dnes patří především
osmibitové mikrořadiče, které na čipu mají nainstalovánu i RAM (typická
kapacita začíná na jednom kilobajtu) a ((E)P)ROM o kapacitě typicky 16
kilobajtů. Podobně jako u některých dalších mikrořadičů se i v&nbsp;řadě H8/300
a H8/300L používá několik instrukcí určených pro manipulaci s&nbsp;jednotlivými
bity a pro kombinaci jednotlivých bitů s&nbsp;příznakem Carry flag.</p>

<p>Zajímavý je pohled z&nbsp;pozice programátora v&nbsp;assembleru, protože
instrukční sada H8/300 kombinuje jak některé prvky známé z&nbsp;klasických
osmibitových mikroprocesorů a mikrořadičů (&bdquo;nultá&ldquo; stránka paměti
inspirovaná slavným MOS 6502, Booleovský procesor od 8051, nepřímé adresování
taktéž převzaté z&nbsp;MOS 6502), tak i pokročilejší techniky typu
post-inkrement adresy, pre-decrement adresy (ideální při zpracování polí,
použito například v&nbsp;Motorole 6809 a Motorole 68000) nebo dokonce instrukci
pro blokový přenos dat (známe ze slavného Zilogu Z80). K&nbsp;tomu připočtěme
některé &bdquo;RISCové&ldquo; vlastnosti &ndash; počet pracovních registrů
dosáhl hodnoty šestnáct, většina instrukcí má pevnou šířku šestnácti bitů, jen
některé instrukce mají šířku dvojnásobnou. Instrukční soubor je taktéž do
značné míry ortogonální, což společně s&nbsp;velkým množstvím pracovních
registrů vede k&nbsp;tomu, že se pro tuto rodinu procesorů mohou bez problémů
používat i optimalizující céčkové překladače.</p>

<p>Najdeme samozřejmě i nevýhody; s&nbsp;některými z&nbsp;nich se seznámíme
příště.</p>



<p><a name="k02"></a></p>
<h2 id="k02">2. Organizace operační paměti</h2>

<p>Vzhledem k&nbsp;tomu, že čipy řady H8/300 A H8/300L používají
šestnáctibitové adresování a paměť RAM i ROM využívá stejný adresový prostor
(nejedná se o Harvardskou architekturu), je možné adresovat buňky
v&nbsp;rozsahu 64kB, tj.&nbsp;používat lze adresy 0x0000 až 0xffff. Tento
adresní prostor je rozdělen do několika bloků &ndash; 128 bajtů pro
vstupně/výstupní registry (mikrořadiče), RAM umístěná přímo na čipu o velikosti
typicky začínající na 1kB, ((E)P)ROM umístěná taktéž na čipu o typické
velikosti 16kB a konečně 42 bajtů obsahujících vektory používané při přerušení
(ovšem u některých mikrořadičů nemusí být všechny vektory obsazeny). Paměť RAM
je mapována na horní adresy a pro posledních 256 bajtů lze použít adresování
s&nbsp;použitím osmibitové adresy. Ušetří se tím programový kód (kratší
instrukce) i několik taktů při běhu programu. ROM je naproti tomu umístěna na
nižších adresách. Zásobník je samozřejmě mapován do RAM a roste směrem
k&nbsp;nižším adresám:</p>

<pre>
 0x0000  +--------------------------------+
         |  vektory přerušovacích rutin   |
 0x002A  +--------------------------------+
         |                                |
         |                                |
         | oblast s namapovanou (E(P))ROM |
         |                                |
         |                                |
 0x4000  +--------------------------------+ (hranice se může lišit)
         |                                |
         |                                |
         |         prázdná oblast         |
         |                                |
         |                                |
 0xfb00  +--------------------------------+ (hranice se může lišit)
         |                                |
         |                                |
         |    oblast s namapovanou RAM    |
(0xff00) |                                | začátek oblasti adresované přes osmibitovou konstantu
         |                                |
 0xff80  +--------------------------------+ (může se lišit)
         |    I/O registry (128 bajtů)    |
 0xffff  +--------------------------------+
</pre>



<p><a name="k03"></a></p>
<h2 id="k03">3. Pracovní registry</h2>

<p>Jádra řady H/300 a H/300L obsahují šestnáct osmibitových pracovních
registrů, přičemž vždy dva sousední registry mohou tvořit šestnáctibitový
registrový pár. Ostatně nejedná se o žádnou novinku, protože podobný koncept se
objevil i v&nbsp;procesorech Intel 8080 a později byl rozšířen o možnosti
dalšího párování registrů na architektuře i386. Nicméně se vraťme k&nbsp;řadě
H8. Pojmenování pracovních registrů je zřejmé z&nbsp;následující tabulky:</p>

<table>
<tr><th>8bit registr</th><th>8bit registr</th><th>16bitový pár</th></tr>
<tr><td>R0H</td><td>R0L</td><td>R0</td></tr>
<tr><td>R1H</td><td>R1L</td><td>R1</td></tr>
<tr><td>R2H</td><td>R2L</td><td>R2</td></tr>
<tr><td>R3H</td><td>R3L</td><td>R3</td></tr>
<tr><td>R4H</td><td>R4L</td><td>R4</td></tr>
<tr><td>R5H</td><td>R5L</td><td>R5</td></tr>
<tr><td>R6H</td><td>R6L</td><td>R6</td></tr>
<tr><td>R7H</td><td>R7L</td><td>R7 (též SP)</td></tr>
</table>

<p>Poslední registrový pár lze použít i ve funkci šestnáctibitového ukazatele
na vrchol zásobníku (zásobník roste od vyšších adres směrem k&nbsp;adresám
nižším).</p>



<p><a name="k04"></a></p>
<h2 id="k04">4. Speciální registry</h2>

<p>Kromě pracovních registrů u těchto procesorů nalezneme i obligátní registr
<strong>PC</strong>, který zde má šířku šestnácti bitů a dokáže tedy adresovat
celých 64 kB.</p>

<p>Posledním registrem je registr <strong>CCR</strong> (<i>Condition Code
Register</i>), přičemž každý bit tohoto registru má odlišný význam:</p>

<pre>
  7   6   5   4   3   2   1   0
+---+---+---+---+---+---+---+---+
| I | U | H | U | N | Z | V | C |
+---+---+---+---+---+---+---+---+
</pre>

<p>Význam jednotlivých bitů stavového a řídicího registru je popsán
v&nbsp;následující tabulce:</p>

<table>
<tr><th>Index</th><th>Příznak</th><th>Význam zkratky</th><th>Poznámka</th></tr>
<tr><td>7</td><td>I</td><td>interrupt</td><td>maskování neboli zákaz IRQ (přerušení)</td></tr>
<tr><td>6</td><td>U</td><td>user bit</td><td>bit, který lze nastavit či testovat instrukcemi LDC, STC, ANDC, ORC a XORC</td></tr>
<tr><td>5</td><td>H</td><td>half carry</td><td>přenos z bitu číslo 3 do bitu číslo 4 (použit instrukcemi DAA a DAS)</td></tr>
<tr><td>4</td><td>U</td><td>user bit</td><td>bit, který lze nastavit či testovat instrukcemi LDC, STC, ANDC, ORC a XORC</td></tr>
<tr><td>3</td><td>N</td><td>negative</td><td>výsledek ALU operace je záporný</td></tr>
<tr><td>2</td><td>Z</td><td>zero</td><td>výsledek ALU operace je nulový</td></tr>
<tr><td>1</td><td>V</td><td>overflow</td><td>přetečení (znaménková aritmetika, signed)</td></tr>
<tr><td>0</td><td>C</td><td>carry</td><td>přenos (bezznaménková aritmetika, unsigned)</td></tr>
</table>

<p>Povšimněte si, že počet pracovních registrů je na osmibitový procesor velmi
vysoký, což dále umocňuje fakt, že se každý z&nbsp;pracovních registrů (či
párů) může použít i pro adresování &ndash; neexistují zde tedy rozdíly mezi
&bdquo;akumulátorem&ldquo; a &bdquo;indexovým registrem&ldquo;.</p>



<p><a name="k05"></a></p>
<h2 id="k05">5. Podporované adresovací režimy</h2>

<p>Adresovací režimy podporované v&nbsp;procesorech řady H8/300 a H8/300L se
v&nbsp;mnoha ohledech podobají režimům, které jsme si již popsali u RISCových
procesorů SuperH, samozřejmě s&nbsp;tím rozdílem, že adresy jsou zde pouze
šestnáctibitové a v&nbsp;několika případech dokonce jen osmibitové. Ostatně se
podívejme na následující tabulku s&nbsp;výčtem všech podporovaných adresovacích
režimů:</p>

<table>
<tr><th>Název režimu</th><th>Zápis v&nbsp;asm</th><th>Význam</th></tr>
<tr><td>Register direct</td><td>Rn</td><td>většina instrukcí akceptuje pouze osmibitový registr</td></tr>
<tr><td>Register indirect</td><td>@Rn</td><td>Rn je šestnáctibitový registr obsahující adresu</td></tr>
<tr><td>Register indirect with displacement</td><td>@(d:16,Rn)</td><td>jako předchozí režim, ovšem navíc se 16bitovým offsetem</td></tr>
<tr><td>Register indirect with post-increment</td><td>@Rn+</td><td>pro instrukce MOV, posun o jeden či dva bajty podle typu přenosu</td></tr>
<tr><td>Register indirect with pre-decrement </td><td>@-Rn</td><td>pro instrukce MOV, posun o jeden či dva bajty podle typu přenosu</td></tr>
<tr><td>Absolute address</td><td>@aa:8</td><td>za instrukcí následuje osmibitová konstanta, přičte se k&nbsp;ní 0xff00</td></tr>
<tr><td>Absolute address</td><td>@aa:16</td><td>za instrukcí následuje šestnáctibitová konstanta</td></tr>
<tr><td>Immediate</td><td>#xx:8</td><td>za instrukcí následuje osmibitová konstanta</td></tr>
<tr><td>Immediate</td><td>#xx:16</td><td>za instrukcí následuje šestnáctibitová konstanta</td></tr>
<tr><td>Program-counter relative</td><td>@(d:8,PC)</td><td>použito pro relativní skoky v rozsahu -126 do 128</td></tr>
<tr><td>Memory indirect</td><td>@@aa:8</td><td>použito u JMP a JSR, na adrese je uložen cíl skoku</td></tr>
</table>

<p>Zajímavý je režim s&nbsp;osmibitovou absolutní adresou. V&nbsp;tomto režimu
lze adresovat jen paměť na adresách 0xff00 až 0xffff, což je RAM. Naproti tomu
poslední režim používá adresy skoků uložené na adresách 0x0000 až 0x00ff, kde
je mapována ROM. Mimochodem, oba dva zmíněné režimy připomínají adresování přes
nultou stránku paměti známé z&nbsp;mikroprocesorů MOS 6502.</p>



<p><a name="k06"></a></p>
<h2 id="k06">6. Instrukční sada osmibitových mikrořadičů H8/300 a H8/300L</h2>

<p>Osmibitové mikrořadiče řady H8/300 a H8/300L obsahují celkem 57 instrukcí, i
když způsob počítání instrukcí se nám může v&nbsp;některých případech zdát
poněkud zvláštní (instrukce <strong>PUSH</strong> a <strong>POP</strong> jsou
vlastně interně reprezentovány instrukcí <strong>MOV</strong>, všechny varianty
podmíněných skoků jsou započteny jen jednou atd.). Instrukce můžeme podle
jejich funkce rozdělit do několika kategorií vypsaných v&nbsp;následující
tabulce:</p>

<table>
<tr><th>Skupina</th><th>Instrukce</th><th>Počet</th></tr>
<tr><td><a href="#k07">Přenos dat</a></td><td>MOV, PUSH, POP</td><td>3 (1)</td></tr>
<tr><td><a href="#k08">Aritmetické</a></td><td>ADD, SUB, ADDX, SUBX, INC, DEC, ADDS, SUBS, DAA, DAS, MULXU, DIVXU, CMP, NEG</td><td>14</td></tr>
<tr><td><a href="#k09">Logické</a></td><td>AND, OR, XOR, NOT</td><td>4</td></tr>
<tr><td><a href="#k10">Posuny a rotace</a></td><td>SHAL, SHAR, SHLL, SHLR, ROTL, ROTR, ROTXL, ROTXR</td><td>8</td></tr>
<tr><td><a href="#k11">Bitové manipulace</a></td><td>BSET, BCLR, BNOT, BTST, BAND, BIAND, BOR, BIOR, BXOR, BIXOR, BLD, BILD, BST, BIST</td><td>14</td></tr>
<tr><td><a href="#k12">Nepodmíněné skoky</a></td><td>JMP, BSR, JSR, RTS</td><td>4</td></tr>
<tr><td><a href="#k13">Podmíněné skoky</a></td><td>Bcc (celkem 16 variant)</td><td>1</td></tr>
<tr><td><a href="#k14">Řízení procesoru</a></td><td>RTE, SLEEP, LDC, STC, ANDC, ORC, XORC, NOP</td><td>8</td></tr>
<tr><td><a href="#k15">Blokové přenosy</a></td><td>EEPMOV</td><td>1</td></tr>
<tr><th>Celkem</th><th>&nbsp;</th><th>57 (55)</th></tr>
</table>



<p><a name="k07"></a></p>
<h2 id="k07">7. Instrukce pro přenosy dat</h2>

<p>Podrobnější vysvětlení jednotlivých instrukcí z&nbsp;instrukční sady začneme
popisem těch instrukcí, které jsou primárně určeny pro přenosy dat, a to jak
mezi pracovními registry, tak i mezi vybraným pracovním registrem a bajtem (či
dvěma sousedními bajty) uloženými v&nbsp;operační paměti. Do této skupiny
instrukcí patří zejména instrukce <strong>MOV</strong>, resp.&nbsp;přesněji
řečeno její varianty <strong>MOV.B</strong> a <strong>MOV.W</strong>, a taktéž
dvojice instrukcí <strong>PUSH</strong> a <strong>POP</strong>. Tyto dvě
instrukce vždy pracují s&nbsp;šestnáctibitovými registry, nikoli
s&nbsp;registry osmibitovými:</p>

<table>
<tr><th>#</th><th>Instrukce</th><th>Popis</th><th>Poznámka</th></tr>
<tr><td>1</td><td>MOV.B</td><td>přenos dat mezi osmibitovými registry či registrem a pamětí</td><td>lze použít i adresování @aa:8</td></tr>
<tr><td>2</td><td>MOV.W</td><td>přenos dat mezi 16bitovými registry či registrem a pamětí</td><td>lze použít i adresování @-Rn či @Rn+</td></tr>
<tr><td>3</td><td>MOV.B #xx, Rn</td><td>uložení osmibitové konstanty do registru</td><td>šířka slova je 16 bitů</td></tr>
<tr><td>4</td><td>MOV.W #xxxx, Rn</td><td>uložení šestnáctibitové konstanty do registru</td><td>šířka slova je 32 bitů</td></tr>
<tr><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td></tr>
<tr><td>5</td><td>PUSH </td><td>uložení 16bitového registru na zásobník</td><td>ekvivalentem je instrukce <strong>MOV.W Rn, @-SP</strong></td></tr>
<tr><td>6</td><td>POP  </td><td>obnovení 16bitového registru ze zásobníku</td><td>ekvivalentem je instrukce <strong>MOV.W@SP+, Rn</strong></td></tr>
</table>

<p>U instrukcí <strong>PUSH</strong> a <strong>POP</strong> si povšimněte, že
zásobník skutečně roste směrem k&nbsp;nižším adresám, podobně jako je tomu i u
mnoha dalších procesorových architektur.</p>

<p>Ve skutečnosti ještě existuje jedna další instrukce určená pro přenosy dat.
Jedná se o instrukci nazvanou <strong>EEPMOV</strong>, která je kvůli své
výjimečnosti samostatně popsána <a href="#k15">v&nbsp;patnácté
kapitole</a>.</p>



<p><a name="k08"></a></p>
<h2 id="k08">8. Aritmetické operace</h2>

<p>Skupina aritmetických instrukcí je na procesorech H8/300 poměrně rozsáhlá,
což je ostatně patrné i při letmém pohledu na následující tabulky. Většina
instrukcí je omezena na osmibitové operandy, jen několik vybraných instrukcí
dokáže pracovat i se šestnáctibitovými pracovními registry. Základ samozřejmě
tvoří instrukce pro součet a rozdíl. Povšimněte si, že tyto instrukce existují
v&nbsp;několika variantách, a to podle toho, jakého typu jsou operandy (může se
jednat o osmibitový či šestnáctibitový registr popř.&nbsp;o osmibitovou
konstantu) či zda se má při sčítání navíc přičíst i příznak přenosu a při
odečítání naopak odečíst tzv.&nbsp;výpůjčka (<i>borrow</i> je svým významem
negace <i>carry</i>). Instrukce <strong>ADDS</strong> a <strong>SUBS</strong>
jsou vlastně obdobou instrukcí s&nbsp;osmibitovou konstantou, ovšem s&nbsp;tím
rozdílem, že prvním operandem je šestnáctibitový registr a druhým operandem
konstanta 1 či 2 (větší konstanty se do instrukčního slova již nevlezou):</p>

<table>
<tr><th> #</th><th>Instrukce</th><th>Popis</th><th>Poznámka</th></tr>
<tr><td> 1</td><td>ADD</td><td>součet Rd = Rd + Rs</td><td>8bit i 16bit</td></tr>
<tr><td> 2</td><td>ADD</td><td>součet Rd = Rd + konstanta</td><td>jen pro osmibitový cílový registr (konstanta je ve spodním bajtu instrukce)</td></tr>
<tr><td> 3</td><td>ADDX</td><td>součet Rd = Rd + Rs + Carry</td><td>8bit i 16bit</td></tr>
<tr><td> 4</td><td>ADDX</td><td>součet Rd = Rd + konstanta + Carry</td><td>dtto jako ADD</td></tr>
<tr><td> 5</td><td>ADDS</td><td>součet Rd = Rd + 1 nebo Rd = Rd + 2</td><td>16bit, konstanta je uložena v&nbsp;instrukci</td></tr>
<tr><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td></tr>
<tr><td> 6</td><td>SUB</td><td>rozdíl Rd = Rd - Rs</td><td>8bit i 16bit</td></tr>
<tr><td> 7</td><td>SUB</td><td>rozdíl Rd = Rd - konstanta</td><td>jen pro osmibitový cílový registr (konstanta je ve spodním bajtu instrukce)</td></tr>
<tr><td> 8</td><td>SUBX</td><td>rozdíl Rd = Rd - Rs - Carry</td><td>8bit i 16bit</td></tr>
<tr><td> 9</td><td>SUBX</td><td>rozdíl Rd = Rd - konstanta - Carry</td><td>dtto jako ADD</td></tr>
<tr><td>10</td><td>SUBS</td><td>rozdíl Rd = Rd - 1 nebo Rd = Rd - 2</td><td>16bit, konstanta je uložena v&nbsp;instrukci</td></tr>
</table>

<p>Pro podporu výpočtů s&nbsp;hodnotami reprezentovanými v&nbsp;BCD kódu
(dvojice číslic 00 až 99) jsou určeny instrukce pro úpravu výsledků součtu a
rozdílu na základě hodnoty stavového bitu <i>half carry</i>. Z&nbsp;určitého
pohledu se sice jedná o anachronismus, nicméně i dnes nalezneme čipy (RTC,
některé čtečky čárových kódů, některé numerické displeje), které BCD stále
používají:</p>

<table>
<tr><th> #</th><th>Instrukce</th><th>Popis</th><th>Poznámka</th></tr>
<tr><td>11</td><td>DAA</td><td>úprava výsledku po součtu dvou BCD čísel</td><td>jen pro osmibitový cílový registr</td></tr>
<tr><td>12</td><td>DAS</td><td>úprava výsledku po rozdílu dvou BCD čísel</td><td>jen pro osmibitový cílový registr</td></tr>
</table>

<p>Při implementaci programových smyček je možné s&nbsp;výhodou použít
instrukce <strong>INC</strong> a <strong>DEC</strong>, které zvýší či sníží
obsah vybraného osmibitového pracovního registru o jedničku a
popř.&nbsp;nastaví příznak nulovosti. Tyto instrukce se naopak NEpoužívají při
adresování polí, protože procesory H8/300 mají speciální adresovací režimy
s&nbsp;post-inkrementem a pre-dekremenentem adresy:</p>

<table>
<tr><th> #</th><th>Instrukce</th><th>Popis</th><th>Poznámka</th></tr>
<tr><td>13</td><td>INC</td><td>inkrementace Rd = Rd + 1</td><td>jen pro osmibitový cílový registr</td></tr>
<tr><td>14</td><td>DEC</td><td>dekrementace Rd = Rd - 1</td><td>jen pro osmibitový cílový registr</td></tr>
</table>

<p>Instrukce pro násobení a dělení jsou omezeny na násobení dvou osmibitových
operandů se šestnáctibitovým výsledkem. Dělení naopak používá šestnáctibitový
dělenec a výsledkem dělení je podíl i zbytek (oba jen osmibitové, což znamená,
že ne všechny vstupy do této instrukce jsou korektní):</p>

<table>
<tr><th> #</th><th>Instrukce</th><th>Popis</th><th>Poznámka</th></tr>
<tr><td>15</td><td>MULXU</td><td>součin Rd = Rd &times; Rs</td><td>vstupem jsou osmibitové registry, výstup 16bitový</td></tr>
<tr><td>16</td><td>DIVXU</td><td>podíl Rd = Rd &divide; Rs</td><td>vstupem je 16bitový registr, výstup 8bit podíl+8bit zbytek</td></tr>
</table>

<p>Zbývající dvě instrukce slouží pro porovnání obsahů dvou registrů
popř.&nbsp;pro porovnání obsahu osmibitového registru s&nbsp;konstantou. Po
porovnání se nastaví příznaky stejným způsobem, jako při výpočtu rozdílu.
Poslední instrukce je velmi jednoduchá, protože slouží pro změnu znaménka
hodnoty uložené ve vybraném osmibitovém pracovním registru:</p>

<table>
<tr><th> #</th><th>Instrukce</th><th>Popis</th><th>Poznámka</th></tr>
<tr><td>17</td><td>CMP</td><td>Rd – Rs s&nbsp;nastavením příznaků</td><td>8bit i 16bit</td></tr>
<tr><td>18</td><td>CMP</td><td>Rd – konstanta s&nbsp;nastavením příznaků</td><td>jen pro osmibitový cílový registr</td></tr>
<tr><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td></tr>
<tr><td>19</td><td>NEG</td><td>výpočet Rd = -Rd</td><td>jen pro osmibitový cílový registr</td></tr>
</table>



<p><a name="k09"></a></p>
<h2 id="k09">9. Logické operace</h2>

<p>Instrukce pro provedení logických operací tvoří velmi malou skupinu, protože
v&nbsp;ní nalezneme pouze čtyři instrukce, přičemž první tři instrukce existují
ve dvou variantách. Všechny logické operace probíhají nad osmibitovými
operandy, přičemž prvním zdrojovým a současně i cílovým operandem je osmibitový
pracovní registr a druhým operandem může být taktéž pracovní registr
popř.&nbsp;osmibitová konstanta (ta je součástí šestnáctibitového instrukčního
slova):</p>

<table>
<tr><th>#</th><th>Instrukce</th><th>Popis</th><th>Poznámka</th></tr>
<tr><td>1</td><td>AND</td><td>Rd = Rd &and; Rs</td><td>jen osmibitové registry</td></tr>
<tr><td>2</td><td>AND</td><td>Rd = Rd &and; konstanta</td><td>konstanta tvoří spodní bajt instrukce</td></tr>
<tr><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td></tr>
<tr><td>3</td><td>OR </td><td>Rd = Rd &or; Rs</td><td>jen osmibitové registry</td></tr>
<tr><td>4</td><td>OR </td><td>Rd = Rd &or; konstanta</td><td>konstanta tvoří spodní bajt instrukce</td></tr>
<tr><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td></tr>
<tr><td>5</td><td>XOR</td><td>Rd = Rd &oplus; Rs</td><td>jen osmibitové registry</td></tr>
<tr><td>6</td><td>XOR</td><td>Rd = Rd &oplus; konstanta</td><td>konstanta tvoří spodní bajt instrukce</td></tr>
<tr><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td></tr>
<tr><td>7</td><td>NOT</td><td>Rd = &not; Rd</td><td>jen osmibitový registr</td></tr>
</table>



<p><a name="k10"></a></p>
<h2 id="k10">10. Bitové posuny a rotace</h2>

<p>V&nbsp;assembleru se poměrně často používají instrukce provádějící takzvané
<i>bitové rotace</i>. O co se vlastně jedná? Jde o posun všech bitů
v&nbsp;některém z&nbsp;pracovních registrů (na H8/300 pouze osmibitových),
ovšem takovým způsobem, že se jedná o uzavřenou smyčku, tj.&nbsp;obsah bitu,
který by se provedením posunu ztratil (byl by vysunut), je naopak zkopírován na
vstup. Pro takto chápanou bitovou rotaci existují dvě instrukce, první pro
rotaci obsahu pracovního registru doleva a druhá pro rotaci doprava. Každá
instrukce způsobí rotaci pouze o jeden bit. Nákres rotace doleva i doprava, je
naznačen na obrázku:</p>

<pre>
+---+---+---+---+---+---+---+---+
| 7 | 6 | 5 | 4 | 3 | 2 | 1 | 0 |--&gt;--+
+---+---+---+---+---+---+---+---+     |
  ^                                   |
  |                                   |
  +-----------------------------------+
</pre>

<pre>
      +---+---+---+---+---+---+---+---+
+--&lt;--| 7 | 6 | 5 | 4 | 3 | 2 | 1 | 0 |
|     +---+---+---+---+---+---+---+---+
|                                   ^
|                                   |
+-----------------------------------+
</pre>

<p>Kromě běžných bitových rotací popsaných v&nbsp;předchozím odstavci se
setkáme i s&nbsp;rotacemi prováděnými přes příznak přenosu (<i>Carry flag</i>).
V&nbsp;podstatě se jedná o rozšíření bitové šířky rotovaného registru o jeden
bit, který je představovaný právě příznakem přenosu, tj.&nbsp;neprovádí se
rotace osmi bitů, ale bitů devíti. Použití těchto typů rotací spočívá například
v&nbsp;implementaci víceslovní aritmetiky (rotuje se přes větší množství slov),
popř.&nbsp;při požadavku na vložení hodnoty příznaku přenosu do určeného bitu
pracovního registru (booleovské operace). Nákres rotace doleva i doprava přes
příznak přenosu, je naznačen na obrázku:</p>

<pre>
+---+---+---+---+---+---+---+---+       +-------+
| 7 | 6 | 5 | 4 | 3 | 2 | 1 | 0 |---&gt;---| Carry |
+---+---+---+---+---+---+---+---+       +-------+
  ^                                         |
  |                                         v
  +-----------------------------------------+
</pre>

<pre>
+-------+       +---+---+---+---+---+---+---+---+
+ Carry |---&lt;---| 7 | 6 | 5 | 4 | 3 | 2 | 1 | 0 |
+-------+       +---+---+---+---+---+---+---+---+
    |                                         ^
    |                                         |
    +-----------------------------------------+
</pre>

<p>Další dvě strojové instrukce provádějí bitový posun doleva a doprava. Od
rotací se bitové posuny odliší především tím, že se při posunu doleva do
nejnižšího bitu vždy vloží nula a při posunu doprava se do nejvyššího bitu
taktéž uloží nula (při rotacích se naproti tomu namísto nuly použil příznak
přenosu či zrovna vysunutý bit). K&nbsp;čemu je možné tyto instrukce využít?
Typickým příkladem je optimalizace násobení mocninou dvou či naopak dělení
mocninou dvou (instrukce <strong>SHLR</strong>). Musíme však mít na paměti
důležitý fakt, že <strong>SHLR</strong> lze použít pouze pro hodnoty bez
znaménka (<i>unsigned</i>).</p>

<p>K&nbsp;výše popsané šestici bitových rotací a posunů přidejme ještě
aritmetické posuny. Ty jsou podobné logickým posunům, ovšem při aritmetickém
posunu doprava obsah nejvyššího bitu zůstává za všech okolností zachován (a
samozřejmě je ještě zkopírován do druhého nejvyššího bitu). Pokud si uvědomíme,
jakým způsobem jsou reprezentovány hodnoty v&nbsp;systému dvojkového doplňku,
je zřejmé, že tato instrukce ve většině případů (99,99% u osmibitových čísel)
provádí dělení dvěma, a to i pro záporné hodnoty.</p>

<p>Ve skupině instrukcí určených pro bitové posuny a rotace nalezneme celkem
osm různých variant, které jsou vypsány v&nbsp;následující tabulce. Podobně
jako tomu bylo v&nbsp;případě logických instrukcí, i tato skupina operací
manipuluje s&nbsp;osmibitovými registry, navíc jsou všechny posuny a rotace
provedeny o jediný bit (v&nbsp;instrukčním slovu není dostatek místa pro
uložení počtu bitů, navíc procesor pravděpodobně ani neobsahuje <i>barrel
shifter</i> s&nbsp;potřebnými propojeními):</p>

<table>
<tr><th>#</th><th>Instrukce</th><th>Popis</th><th>Poznámka</th></tr>
<tr><td>1</td><td>SHAL </td><td>aritmetický posun registru Rd doleva</td><td></td></tr>
<tr><td>2</td><td>SHAR </td><td>aritmetický posun registru Rd doprava</td><td></td></tr>
<tr><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td></tr>
<tr><td>3</td><td>SHLL </td><td>logický posun registru Rd doleva</td><td></td></tr>
<tr><td>4</td><td>SHLR </td><td>logický posun registru Rd doprava</td><td></td></tr>
<tr><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td></tr>
<tr><td>5</td><td>ROTL </td><td>rotace registru Rd doleva</td><td></td></tr>
<tr><td>6</td><td>ROTR </td><td>rotace registru Rd doprava</td><td></td></tr>
<tr><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td></tr>
<tr><td>7</td><td>ROTXL</td><td>rotace registru Rd doleva přes carry flag</td><td></td></tr>
<tr><td>8</td><td>ROTXR</td><td>rotace registru Rd doprava přes carry flag</td><td></td></tr>
</table>



<p><a name="k11"></a></p>
<h2 id="k11">11. Booleovský procesor &ndash; manipulace s&nbsp;jednotlivými bity</h2>

<p>V&nbsp;instrukční sadě nalezneme i čtrnáct instrukcí, s&nbsp;jejichž
využitím je na jádrech H/300 a H/300L implementován takzvaný Booleovský
procesor, tj.&nbsp;(zjednodušeně řečeno) procesor omezený na manipulaci
s&nbsp;jednotlivými bity. Tento procesor používá namísto akumulátoru příznakový
bit <i>Carry Flag</i>, který se využívá jak ve funkci jednoho vstupního
operandu, tak i pro uložení výsledku operace (v&nbsp;jednom případě se používá
i <i>Zero flag</i>). Podívejme se nyní, které instrukce patří do této
skupiny:</p>

<table>
<tr><th> #</th><th>Instrukce</th><th>Popis</th></tr>
<tr><td> 1</td><td>BCLR </td><td>bit<sub>n</sub> cíle = 0</td></tr>
<tr><td> 2</td><td>BSET </td><td>bit<sub>n</sub> cíle = 1</td></tr>
<tr><td> 3</td><td>BNOT </td><td>bit<sub>n</sub> cíle = &not; bit<sub>n</sub> cíle</td></tr>
<tr><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td></tr>
<tr><td> 4</td><td>BTST </td><td>Zero flag = &not; bit<sub>n</sub> cíle</td></tr>
<tr><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td></tr>
<tr><td> 5</td><td>BAND </td><td>Carry flag = Carry flag &and; bit<sub>n</sub> cíle</td></tr>
<tr><td> 6</td><td>BIAND</td><td>Carry flag = Carry flag &and; &not; bit<sub>n</sub> cíle</td></tr>
<tr><td> 7</td><td>BOR  </td><td>Carry flag = Carry flag &or; bit<sub>n</sub> cíle</td></tr>
<tr><td> 8</td><td>BIOR </td><td>Carry flag = Carry flag &or; &not; bit<sub>n</sub> cíle</td></tr>
<tr><td> 9</td><td>BXOR </td><td>Carry flag = Carry flag &oplus; bit<sub>n</sub> cíle</td></tr>
<tr><td>10</td><td>BIXOR</td><td>Carry flag = Carry flag &oplus; &not; bit<sub>n</sub> cíle</td></tr>
<tr><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td></tr>
<tr><td>11</td><td>BLD  </td><td>Carry flag = bit<sub>n</sub> cíle</td></tr>
<tr><td>12</td><td>BILD </td><td>Carry flag = &not; bit<sub>n</sub> cíle</td></tr>
<tr><td>13</td><td>BST  </td><td>bit<sub>n</sub> cíle = Carry flag</td></tr>
<tr><td>14</td><td>BIST </td><td>bit<sub>n</sub> cíle = &not; Carry flag</td></tr>
</table>

<p>Poznámka: <i>n</i> může být specifikováno konstantou 0 &ndash; 7 (je uložena
v&nbsp;instrukčním slovu) či v&nbsp;pracovním registru.</p>



<p><a name="k12"></a></p>
<h2 id="k12">12. Nepodmíněné skoky, vstup a výstup z&nbsp;podprogramů (subrutin)</h2>

<p>Další čtyři instrukce slouží pro provedení nepodmíněného skoku, skoku do
podprogramu a návratu z&nbsp;podprogramu. Instrukce skoku má mnemotechnickou
zkratku <strong>JMP</strong> a provádí skok na zadanou adresu, která může být
specifikována buď přímo (16 bitů) či nepřímo (v&nbsp;registru). Alternativně
lze použít instrukci <strong>BSR</strong>, v&nbsp;níž je adresa skoku zadaná
pouze relativně osmibitovým offsetem, což umožňuje jak konstrukci kódu
nezávislého na hodnotě své počáteční adresy (PIC), tak i zkrácené skoky
v&nbsp;rámci jednoho podprogramu. Instrukce pro skok do podprogramu
<strong>JSR</strong> provede před vlastním skokem uložení 16bitové návratové
adresy na zásobník. O návrat z&nbsp;podprogramu, tj.&nbsp;o vyzvednutí
návratové adresy ze zásobníku a skoku na tuto adresu, se stará instrukce
nazvaná <strong>RTS</strong> (tato instrukce je podle očekávání bez
operandů).</p>

<table>
<tr><th>#</th><th>Instrukce</th><th>Popis</th><th>Poznámka</th></tr>
<tr><td>1</td><td>JMP</td><td>nepodmíněný skok</td><td>adresa: registr, @aa:16, @@aa:8</td></tr>
<tr><td>2</td><td>BSR</td><td>skok do podprogramu</td><td>relativní osmibitová adresa</td></tr>
<tr><td>3</td><td>JSR</td><td>skok do podprogramu</td><td>adresa: registr, @aa:16, @@aa:8</td></tr>
<tr><td>4</td><td>RTS</td><td>návrat z podprogramu</td><td>&nbsp;</td></tr>
</table>

<p>Poznámka: pokud se v&nbsp;instrukcích <strong>JMP</strong> a
<strong>JSR</strong> použije šestnáctibitová adresa, má celá instrukce délku 32
bitů, protože druhých šestnáct bitů je pochopitelně nutné rezervovat pro
uložení adresy skoku.</p>



<p><a name="k13"></a></p>
<h2 id="k13">13. Podmíněné skoky</h2>

<p>Podmíněné skoky se u architektury H8/300 jmenují <i>branch</i>, nikoli
<i>jump</i>, což ostatně platí i pro celou řadu dalších mikroprocesorů,
počínaje Motorolou 6800 a MOS 6502 až po výkonné 32bitové RISCové čipy.
V&nbsp;instrukčním souboru nalezneme celkem šestnáct instrukcí pro podmíněné
skoky, ovšem první dvě instrukce vlastně ve skutečnosti žádnou podmínku
netestují, protože <strong>BRA</strong> je proveden vždy a <strong>BRN</strong>
naopak nikdy. Další skupina podmíněných skoků se používá pro test provedení či
naopak neprovedení skoku hodnotu jednoho z&nbsp;příznakových bitů <i>zero</i>,
<i>overflow</i> či <i>negative</i>. Další čtyři podmíněné skoky se většinou
používají při porovnávání dvou hodnot bez znaménka (unsigned). V&nbsp;těchto
případech se testují stavy příznakových bitů <i>carry</i> a <i>zero</i>,
přesněji řečeno kombinace těchto bitů. Poslední čtyři podmíněné skoky se
používají pro porovnávání hodnot se znaménkem (signed). V&nbsp;těchto případech
se namísto příznakových bitů <i>carry</i> a <i>zero</i> testují kombinace bitů
<i>negative</i>, <i>overflow</i> a <i>zero</i>:</p>

<table>
<tr><th> #</th><th>Instrukce</th><th>Význam zkratky</th><th>Podmínka</th><th>Typ</th></tr>
<tr><td> 1</td><td>BRA</td><td>Always</td><td>vždy (true)</td><td>skok proveden vždy</td></tr>
<tr><td> 2</td><td>BRN</td><td>Never</td><td>nikdy (false)</td><td>skok neproveden</td></tr>
<tr><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td></tr>
<tr><td> 3</td><td>BHI</td><td>High</td><td>C or Z == 0</td><td>&gt; unsigned aritmetika</td></tr>
<tr><td> 4</td><td>BLS</td><td>Low or Same</td><td>C or Z == 1</td><td>&le; unsigned aritmetika</td></tr>
<tr><td> 5</td><td>BCC</td><td>Carry Clear</td><td>C == 0</td><td>&lt; unsigned aritmetika</td></tr>
<tr><td> 6</td><td>BCS</td><td>Carry Set</td><td>C == 1</td><td>&ge; unsigned aritmetika</td></tr>
<tr><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td></tr>
<tr><td> 7</td><td>BNE</td><td>Not Equal</td><td>Z == 0</td><td>= nerovnost operandů</td></tr>
<tr><td> 8</td><td>BEQ</td><td>Equal</td><td>Z == 1</td><td>&ne; rovnost operandů</td></tr>
<tr><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td></tr>
<tr><td> 9</td><td>BVC</td><td>Overflow Clear</td><td>V == 0</td><td>test jediného příznaku</td></tr>
<tr><td>10</td><td>BVS</td><td>Overflow Set</td><td>V == 1</td><td>test jediného příznaku</td></tr>
<tr><td>11</td><td>BPL</td><td>Plus</td><td>N == 0</td><td>test jediného příznaku</td></tr>
<tr><td>12</td><td>BMI</td><td>Minus</td><td>N == 1</td><td>test jediného příznaku</td></tr>
<tr><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td></tr>
<tr><td>13</td><td>BGE</td><td>Greater or Equal</td><td>N &oplus; V == 0</td><td>&ge; signed aritmetika</td></tr>
<tr><td>14</td><td>BLT</td><td>Less Than</td><td>N &oplus; V == 1</td><td>&lt; signed aritmetika</td></tr>
<tr><td>15</td><td>BGT</td><td>Greater Than</td><td>Z ∨ (N &oplus; V) == 0</td><td>&gt; signed aritmetika</td></tr>
<tr><td>16</td><td>BLE</td><td>Less or Equal</td><td>Z ∨ (N &oplus; V) == 1</td><td>&le; signed aritmetika</td></tr>
</table>



<p><a name="k14"></a></p>
<h2 id="k14">14. Instrukce pro řízení procesoru</h2>

<p>V&nbsp;této kapitole jsou popsány různé instrukce určené pro řízení
procesoru. Jak je z&nbsp;tabulky patrné, nachází se zde ve skutečnosti několik
skupin instrukcí, přičemž poslední skupina slouží pro manipulaci
s&nbsp;příznakovým registrem <strong>CCR</strong>:</p>

<table>
<tr><th>#</th><th>Instrukce</th><th>Popis</th></tr>
<tr><td>1</td><td>NOP</td><td>pouhé zvýšení hodnoty PC o 2</td></tr>
<tr><td>2</td><td>RTE</td><td>návrat z&nbsp;rutiny pro obsluhu výjimek</td></tr>
<tr><td>3</td><td>SLEEP</td><td>přepnutí do režimu nízké spotřeby (mikrořadiče)</td></tr>
<tr><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td></tr>
<tr><td>4</td><td>LDC</td><td>přenos osmibitového registru či konstanty do CCR</td></tr>
<tr><td>5</td><td>STC</td><td>uložení CCR do vybraného osmibitového registru</td></tr>
<tr><td>6</td><td>ANDC</td><td>CCR = CCR &and; osmibitová konstanta (maska pro nulování bitů)</td></tr>
<tr><td>7</td><td>ORC</td><td>CCR = CCR &or; osmibitová konstanta (maska pro nastavení bitů)</td></tr>
<tr><td>8</td><td>XORC</td><td>CCR = CCR &oplus; osmibitová konstanta (maska pro negaci bitů)</td></tr>
</table>



<p><a name="k15"></a></p>
<h2 id="k15">15. Instrukce pro blokový přenos dat</h2>

<p>Nejsložitější instrukce se jmenuje <strong>EEPMOV</strong> a slouží pro
implementaci blokového přenosu dat:</p>

<table>
<tr><th>#</th><th>Instrukce</th><th>Popis</th></tr>
<tr><td>1</td><td>EEPMOV</td><td>blokový přenos dat</td></tr>
</table>

<p>Tato instrukce využívá trojici pracovních registrů, a to následovně:</p>

<pre>
while R4L &gt; 0:
    @R6+ = @R5+  ; přenos z adresy uložené v R5 na adresu uloženou v R6
    R4L--
</pre>

<p>Jinými slovy:</p>

<ul>
<li>R4L na začátku obsahuje počet přenesených prvků (max 256 slov)</li>
<li>R5 obsahuje počáteční adresu přenášeného bloku</li>
<li>R6 obsahuje počáteční adresu cíle přenosu</li>
</ul>



<p><a name="k16"></a></p>
<h2 id="k16">16. Odkazy na Internetu</h2>

<ol>

<li>H8 Family<br />
<a href="https://en.wikipedia.org/wiki/H8_Family">https://en.wikipedia.org/wiki/H8_Family</a>
</li>

<li>H8/300 and H8/300L<br />
<a href="http://nah6.com/~itsme/download/ibutton/h8_8bit.pdf">http://nah6.com/~itsme/download/ibutton/h8_8bit.pdf</a>
</li>

<li>H8 Family<br />
<a href="https://www.renesas.com/en-us/products/microcontrollers-microprocessors/h8.html">https://www.renesas.com/en-us/products/microcontrollers-microprocessors/h8.html</a>
</li>

<li>(GCC) Status of Supported Architectures from Maintainers' Point of View<br />
<a href="https://gcc.gnu.org/backends.html">https://gcc.gnu.org/backends.html</a>
</li>

<li>(GCC) H8/300 Options<br />
<a href="https://gcc.gnu.org/onlinedocs/gcc/H8_002f300-Options.html#H8_002f300-Options">https://gcc.gnu.org/onlinedocs/gcc/H8_002f300-Options.html#H8_002f300-Options</a>
</li>

<li>GCC for SuperH,H8/300,AVR<br />
<a href="http://mes.osdn.jp/h8/gcc.html">http://mes.osdn.jp/h8/gcc.html</a>
</li>

<li>H8/3802, 38002S, 38004, 38104 (manuály k&nbsp;čipům)<br />
<a href="https://www.renesas.com/en-us/document/hw-manual?hwLayerShowFlg=true&prdLayerId=184&layerName=H8%252F3802%252C%2B38002S%252C%2B38004%252C%2B38104&coronrService=document-prd-search&hwDocUrl=%2Fen-us%2Fdoc%2Fproducts%2Fmpumcu%2F001%2Frej09b0024_h83802.pdf&hashKey=c5e1fa0a18c01e6c789bc7b5c0184ed9">https://www.renesas.com/en-us/document/hw-manual?hwLayerShowFlg=true&prdLayerId=184&layerName=H8%252F3802%252C%2B38002S%252C%2B38004%252C%2B38104&coronrService=document-prd-search&hwDocUrl=%2Fen-us%2Fdoc%2Fproducts%2Fmpumcu%2F001%2Frej09b0024_h83802.pdf&hashKey=c5e1fa0a18c01e6c789bc7b5c0184ed9</a>
</li>

<li>Addressing mode (Wikipedia)<br />
<a href="https://en.wikipedia.org/wiki/Addressing_mode">https://en.wikipedia.org/wiki/Addressing_mode</a>
</li>

<li>Renesas SH Instruction Set Summary<br />
<a href="http://shared-ptr.com/sh_insns.html">http://shared-ptr.com/sh_insns.html</a>
</li>

<li>SH-4 RISC Processor by HITACHI<br />
<a href="http://www.cs.umd.edu/~meesh/cmsc411/website/projects/risc/risc.htm">http://www.cs.umd.edu/~meesh/cmsc411/website/projects/risc/risc.htm</a>
</li>

<li>SH-4 RISC Processor<br />
<a href="http://www.cs.umd.edu/~meesh/cmsc411/website/projects/risc/sh-4.htm">http://www.cs.umd.edu/~meesh/cmsc411/website/projects/risc/sh-4.htm</a>
</li>

<li>SuperH RISC engine Family Features<br />
<a href="https://www.renesas.com/en-us/products/microcontrollers-microprocessors/superh/superh-features.html">https://www.renesas.com/en-us/products/microcontrollers-microprocessors/superh/superh-features.html</a>
</li>

<li>Orthogonal instruction set<br />
<a href="https://en.wikipedia.org/wiki/Orthogonal_instruction_set">https://en.wikipedia.org/wiki/Orthogonal_instruction_set</a>
</li>

<li>Status Register<br />
<a href="https://en.wikipedia.org/wiki/Status_register">https://en.wikipedia.org/wiki/Status_register</a>
</li>

<li>6800 Instruction Set<br />
<a href="http://www.electronics.dit.ie/staff/tscarff/6800/Instructions/instructions.htm">http://www.electronics.dit.ie/staff/tscarff/6800/Instructions/instructions.htm</a>
</li>

<li>Assembly language today<br />
<a href="http://beust.com/weblog/2004/06/23/assembly-language-today/">http://beust.com/weblog/2004/06/23/assembly-language-today/</a>
</li>

<li>Calling subroutines<br />
<a href="http://infocenter.arm.com/help/index.jsp?topic=/com.arm.doc.kui0100a/armasm_cihcfigg.htm">http://infocenter.arm.com/help/index.jsp?topic=/com.arm.doc.kui0100a/armasm_cihcfigg.htm</a>
</li>

<li>Art of Assembly - Arithmetic Instructions<br />
<a href="http://oopweb.com/Assembly/Documents/ArtOfAssembly/Volume/Chapter_6/CH06-2.html">http://oopweb.com/Assembly/Documents/ArtOfAssembly/Volume/Chapter_6/CH06-2.html</a>
</li>

<li>X86 Assembly/Arithmetic<br />
<a href="https://en.wikibooks.org/wiki/X86_Assembly/Arithmetic">https://en.wikibooks.org/wiki/X86_Assembly/Arithmetic</a>
</li>

<li>ARM subroutines &amp; program stack<br />
<a href="http://www.toves.org/books/armsub/">http://www.toves.org/books/armsub/</a>
</li>

<li>Programming from the Ground Up Book - Summary<br />
<a href="http://savannah.nongnu.org/projects/pgubook/">http://savannah.nongnu.org/projects/pgubook/</a>
</li>

<li>The 6502 overflow flag explained mathematically <br />
<a href="http://www.righto.com/2012/12/the-6502-overflow-flag-explained.html">http://www.righto.com/2012/12/the-6502-overflow-flag-explained.html</a>
</li>

</ol>



<p></p><p></p>
<p><small>Autor: <a href="http://www.fit.vutbr.cz/~tisnovpa">Pavel Tišnovský</a> &nbsp; 2016</small></p>
</body>
</html>

