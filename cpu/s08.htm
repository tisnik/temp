<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
        "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html>
<head>
<title>Osmibitové mikrořadiče s jádry S08 a RS08</title>
<meta name="Author" content="Pavel Tisnovsky" />
<meta name="Generator" content="vim" />
<meta http-equiv="content-type" content="text/html; charset=utf-8" />
<style type="text/css">
         body {color:#000000; background:#ffffff;}
         h1  {font-family: arial, helvetica, sans-serif; color:#ffffff; background-color:#c00000; text-align:center; padding-left:1em}
         h2  {font-family: arial, helvetica, sans-serif; color:#ffffff; background-color:#0000c0; padding-left:1em; text-align:left}
         h3  {font-family: arial, helvetica, sans-serif; color:#000000; background-color:#c0c0c0; padding-left:1em; text-align:left}
         h4  {font-family: arial, helvetica, sans-serif; color:#000000; background-color:#e0e0e0; padding-left:1em; text-align:left}
         a   {font-family: arial, helvetica, sans-serif;}
         li  {font-family: arial, helvetica, sans-serif; color:#000000; text-align:justify; width:450px;}
         ol  {font-family: arial, helvetica, sans-serif; color:#000000; text-align:justify; width:450px;}
         ul  {font-family: arial, helvetica, sans-serif; color:#000000; text-align:justify; width:450px;}
         p   {font-family: arial, helvetica, sans-serif; color:#000000; text-align:justify;}
         pre {background:#e0e0e0}
</style>
</head>

<body>

<h1>Osmibitové mikrořadiče s jádry S08 a RS08</h1>

<h3>Pavel Tišnovský</h3>

<p></p>

<h1>Úvodník</h1>

<p>I přes velký úspěch 32bitových mikrořadičů postavených na architektuře ARM Cortex-M se v praxi často setkáme i s různými osmibitovými mikrořadiči. Mezi rozšířené čipy patří i mikrořadiče s jádry S08 a RS08, jejichž prapředkem je mikroprocesor Motorola 6800.</p>



<h2>Obsah</h2>

<p><a href="#k01">1. Osmibitové mikrořadiče s&nbsp;jádry S08 a RS08</a></p>
<p><a href="#k02">2. Předchůdci jader S08 a RS08</a></p>
<p><a href="#k03">3. Motorola 68HC05</a></p>
<p><a href="#k04">4. Motorola 68HC08</a></p>
<p><a href="#k05">5. Odlišná větev vývoje &ndash; Motorola 68HC11</a></p>
<p><a href="#k06">6. Programátorský pohled na jádra S08</a></p>
<p><a href="#k07">7. Adresovací režimy jader S08</a></p>
<p><a href="#k08">8. Instrukční sada mikrořadičových jader S08</a></p>
<p><a href="#k09">9. Aritmetické instrukce</a></p>
<p><a href="#k10">10. Logické instrukce</a></p>
<p><a href="#k11">11. Aritmetické posuny, bitové posuny a rotace</a></p>
<p><a href="#k12">12. Podmíněné i nepodmíněné skoky</a></p>
<p><a href="#k13">13. Instrukce Booleovského procesoru</a></p>
<p><a href="#k14">14. Přesuny dat a další operace</a></p>
<p><a href="#k15">15. Odkazy na Internetu</a></p>



<p><a name="k01"></a></p>
<h2 id="k01">1. Osmibitové mikrořadiče s&nbsp;jádry S08 a RS08</h2>

<p>V&nbsp;seriálu o architekturách počítačů a mikroprocesorů jsme si již
popsali hned několik typů osmibitových mikrořadičů. Mj.&nbsp;se jednalo i o
mikrořadiče s&nbsp;jádrem <i>H8/300</i> a <i>H8/300L</i>, které byly navrženy
ve společnosti Hitachi. Dnes se budeme zabývat taktéž osmibitovými mikrořadiči,
které však budou od zmíněné <i>H8/300</i> v&nbsp;mnoha ohledech odlišné (řada
H8 má mnoho charakteristik RISCové architektury, což se o dnes popisovaných
čipech říci nedá). Jedná se o mikrořadiče s&nbsp;jádry <i>S08</i>
popř.&nbsp;<i>RS08</i>. Tato jádra jsou odvozena od &bdquo;prastarého&ldquo;
mikroprocesoru <i>Motorola 6800</i> (1974), na jehož základě vznikly první
mikrořadiče nabízené společností Motorola. Později se celý segment výroby
polovodičových čipů od Motoroly oddělil do samostatné firmy Freescale
Semiconductor, která je dnes vlastněna společností NXP. Proto všechny
v&nbsp;současnosti vyráběné osmibitové mikrořadiče s&nbsp;jádry S08 a RS08
nalezneme právě na stránkách této společnosti.</p>

<a href="https://www.root.cz/obrazek/272118/"><img src="https://i.iinfo.cz/images/86/s08-1-prev.png" class="image-272118" alt="&#160;" width="370" height="98" /></a>
<p><i>Obrázek 1: V&nbsp;současnosti mají nejmenší čipy s&nbsp;jádry RS08 pouze
osm pinů a jsou tedy v&nbsp;tomto ohledu (a to i cenově) srovnatelné
s&nbsp;řadou PIC10F popř.&nbsp;s&nbsp;nepatrně výkonnější řadou PIC12.</i></p>

<p>Mikrořadiče, které jsou založeny na jádrech <i>S08</i> a především pak na
jádrech <i>RS08</i>, dnes obsazují zejména tu oblast trhu, kde se požadují
jednoduché mikrořadiče s&nbsp;malým výkonem, malými rozměry a především pak
nízkým příkonem (zařízení napájená monočlánkem apod.). Těmto požadavkům
odpovídá i cena čipů, která začíná na 37 centech, což znamená, že tyto čipy
mohou konkurovat řadě PIC10F (což jsou vlastně &bdquo;programovatelné
součástky&ldquo;). Podívejme se na dvě typické konfigurace:</p>

<ul>

<li>Jádro RS08, čip s&nbsp;šesti až 20 piny, frekvence CPU 10MHz, kapacita
FLASH ROM 1 až 8 kB, kapacita RAM 64, 128 nebo 256 bajtů, 2-18 GPIO,
komparátor, volitelný ADC, volitelný I<sup>2</sup>C, volitelný časovač a
interní hodiny. Cena od 37 centů.</li>

<li>Jádro S08, frekvence CPU 20 MHz až 40 MHz, počet GPIO zvýšen až na 20,
přidán PWM, volitelně další časovač, SPI, SCI atd. Cena cca 68 centů a výše
(podle konkrétního vybavení).</li>

</ul>

<a href="https://www.root.cz/obrazek/272119/"><img src="https://i.iinfo.cz/images/86/s08-2-prev.png" class="image-272119" alt="&#160;" width="317" height="270" /></a>.
<p><i>Obrázek 2: Největší čipy s&nbsp;jádry S08 vlastně již částečně zasahují
do segmentu, v&nbsp;němž se setkáme se 16bitovými mikrořadiči a taktéž se
slavnými RISCovými jádry ARM Cortex M (32bitové čipy).<br />
Zdroj: Freescale Semiconductor, Data Sheet, Document Number: MC9S08LC60</i></p>



<p><a name="k02"></a></p>
<h2 id="k02">2. Předchůdci jader S08 a RS08</h2>

<p>Mikrořadičová jádra <i>S08</i> a <i>RS08</i> jsou odvozena od
mikrořadičových jader <i>68HC08</i> navržených a vyráběných ještě ve
společnosti Motorola. Samotná řada <i>68HC08</i> je odvozena od starších a dnes
již nevyráběných mikrořadičů s&nbsp;jádry <i>68HC05</i>, které vznikly
zjednodušením slavných osmibitových mikroprocesorů <i>Motorola 6800</i>.
Nesmíme zapomenout ani na čip <i>68HC11</i> (taktéž již nevyvíjený), který však
není s&nbsp;řadou <i>S08</i> plně kompatibilní a je zde uveden jen pro úplnost.
V&nbsp;následující tabulce jsou uvedeny rozdíly mezi &bdquo;programátorskými
modely&ldquo; jednotlivých mikrořadičů a mikroprocesorů:</p>

<table>
<tr><th>Čip   </th><th>Typ</th><th>Akumulátor(y) </th><th>D=A+B (16b)</th><th>Index registr(y)</th><th>Čítač instrukcí</th><th>Zásobníkové registry</th><th>Spec. registry</th></tr>
<tr><td>MC6800</td><td>CPU</td><td>A (8b), B (8b)</td><td>ne </td><td>X (16b)</td><td>PC (16b)</td><td>SP (16b)</td><td>CCR (6b)</td></tr>
<tr><td>68HC05</td><td>MCU</td><td>A (8b)</td><td>ne </td><td>X (8b)</td><td>PC (13b)</td><td>SP (13b)</td><td>CCR (5b)</td></tr>
<tr><td>68HC08</td><td>MCU</td><td>A (8b)</td><td>ne </td><td>H:X (16b)</td><td>PC (16b)</td><td>SP (16b)</td><td>CCR (6b)</td></tr>
<tr><td>68HC11</td><td>MCU</td><td>A (8b), B (8b)</td><td>ano</td><td>X (16b), Y (16b)</td><td>PC (16b)</td><td>SP (16b)</td><td>CCR (8b)</td></tr>
<tr><td>S08</td><td>MCU</td><td>A (8b)</td><td>ne</td><td>H:X (16b)</td><td>PC (16b)</td><td>SP (16b)</td><td>CCR (6b)</td></tr>
<tr><td>RS08</td><td>MCU</td><td>A (8b)</td><td>ne</td><td>X (8b)</td><td>PC (14b) + SPS (14bit)</td><td>&times;</td><td>CCR (2b)</td></tr>
</table>

<p>Můžeme zde vidět, že sada registrů je pojata minimalisticky, na rozdíl od
již zmíněných čipů H8/300. I z&nbsp;tohoto důvodu nemusí být binární kód
generovaný překladači céčka pro procesory S08/RS08 příliš efektivní (ostatně
totéž platí i pro MCS-51 a mnohé další osmibitové mikrořadiče, které vznikly na
základě architektur navržených před třiceti či dokonce čtyřiceti lety.</p>

<p>Poznámka: instrukční sady jsou částečně kompatibilní, ale především na
úrovni zdrojových kódů (psaných v&nbsp;assembleru). Instrukční sady se totiž
postupně vyvíjely. Největší změny se týkají použití různých adresovacích
režimů, podpory pro instrukce Booleovského procesoru, rozšíření sady registrů
(asi nejznámější jsou prefixy instrukcí u 68HC11 při použití index registru Y)
apod.</p>

<img src="https://i.iinfo.cz/images/86/s08-3.png" class="image-272120" alt="&#160;" width="501" height="124" /></a>
<p><i>Obrázek 3: Vývoj osmibitových a později i šestnáctibitových
mikroprocesorů a mikrořadičů společnosti Motorola (později Freescale, nyní
NXP).</i></p>



<p><a name="k03"></a></p>
<h2 id="k03">3. Motorola 68HC05</h2>

<p>Po vzniku osmibitového mikroprocesoru (nikoli mikrořadiče!) <i>MC6800</i>
firma Motorola navrhla a posléze i realizovala dvě další varianty tohoto čipu,
které se některými svými vlastnostmi blížily plnohodnotným mikrořadičům. Prvním
z&nbsp;těchto čipů byl <i>MC6802</i> z&nbsp;roku 1977 (pozor, neplést
s&nbsp;<i>MOS 6502</i>), který obsahoval kromě vlastního řadiče a CPU i 128
bajtů paměti RAM, interní oscilátor (nemusel se tedy připojovat externí zdroj
hodinových signálů, postačoval pouze 4 MHz krystal pro synchronizaci) a spolu
s&nbsp;čipem označeným <i>MC6846</i> (2kB paměti ROM, osmibitový obousměrný
port a časovač) bylo možné vytvořit jednoduchý dvoučipový mikropočítač, což se
již v&nbsp;mnoha ohledech blížilo ke klasickému mikrořadiči.</p>

<p>Následoval čip <i>MC6801</i> (číslování je, pravda, poněkud neobvyklé),
který obsahoval taktéž 128 bajtů paměti RAM, navíc však na tomto čipu byla
přítomna i paměť ROM s&nbsp;kapacitou 2 kB (zpočátku jen PROM programovatelná
jedenkrát), šestnáctibitový časovač, sériový port a 31 programovatelných I/O
linek (dnes by se označovaly GPIO). Jednalo se o jeden z&nbsp;prvních
mikroprocesorů (nebo vlastně už mikrořadičů), u nichž bylo možné oba osmibitové
akumulátory <strong>A</strong> a <strong>B</strong> spojit do jednoho
šestnáctibitového akumulátoru označovaného písmenem <strong>D</strong>
(<i>double accumulator</i>).</p>

<p>Ovšem tento čip (s&nbsp;cca 35000 tranzistory) byl poměrně drahý a proto se
používal pouze v&nbsp;automobilovém průmyslu a nikoli ve spotřební elektronice.
Společnost Motorola proto posléze tento čip poměrně podstatným způsobem
zjednodušila a začala ho nabízet pod novým označením <i>MC6805</i>. Od tohoto
mikrořadiče je již malý krůček k&nbsp;<i>68HC05</i>, jímž se budeme zabývat
v&nbsp;následujícím textu. Jak jsme si již řekli, jedná se o zjednodušenou
variantu čipu <i>MC6801</i>, což mj.&nbsp;znamená, že se počet pracovních
registrů zmenšil na pět (je použit jen jeden osmibitový akumulátor), indexový
registr má šířku pouze osm bitů a taktéž čítač instrukcí má sníženou šířku na
13 bitů, protože paměť nainstalovaná na mikrořadiči má menší kapacitu než
teoreticky dosažitelných 64 kB (podobné umělé zmenšení adresových registrů
nebylo nijak neobvyklé):</p>

<table>
<tr><th>Označení</th><th>Šířka</th><th>Název registru </th><th>Význam registru</th></tr>
<tr><td>A  </td><td>8 b </td><td>accumulator A</td><td>jediný universální pracovní registr</td></tr>
<tr><td>X  </td><td>8 b </td><td>index register</td><td>používán při adresování operandů</td></tr>
<tr><td>PC </td><td>16 b (13 použito)</td><td>program counter</td><td>používán při adresování instrukcí</td></tr>
<tr><td>SP </td><td>16 b</td><td>stack pointer</td><td>použit při operacích se zásobníkem</td></tr>
<tr><td>CCR</td><td>5 b </td><td>condition code register</td><td>obsahuje příznakové bity</td></tr>
</table>

<a href="http://i.iinfo.cz/images/212/pc132-8.png"><img src="http://i.iinfo.cz/images/212/pc132-8-prev.png" width="251" height="270" alt=" " /></a>
<p><i>Obrázek 4: Interní struktura mikrořadičů M68HC05 popisovaných v&nbsp;této kapitole.<br />
(Zdroj: Freescale Semiconductor, Ltd. MC68HC05B6/D Rev. 4.1 08/2005)</i></p>

<p>Instrukční soubor se u čipů <i>68HC05</i> taktéž v&nbsp;některých ohledech
odlišoval od původní <i>MC6800</i>. Zejména byla přidána instrukce pro
celočíselné násobení (X:A = A&times;X) trvající 11 cyklů a navíc se objevily
instrukce (podobné instrukcím známým z&nbsp;<i>MCS-51</i>), které umožňovaly
přímou manipulaci s&nbsp;jednotlivými bity uloženými v&nbsp;prvních 256 bajtech
paměti: <strong>BSET</strong> (<i>bit set</i>), <strong>BCLR</strong> (<i>bit
clear</i>), <strong>BRSET</strong> (<i>branch if bit is set</i>) a
<strong>BRCLR</strong> (<i>branch if bit is clear</i>). Taktéž možnosti
adresování byly poněkud odlišné: bylo možné provádět přímé adresování prvních
256 bajtů, rozšířené adresování (16 bitů adresy), adresování přes index registr
a adresování přes index registr a osmibitový či šestnáctibitový posun
(offset).</p>

<a href="http://i.iinfo.cz/images/212/pc132-9.png"><img src="http://i.iinfo.cz/images/212/pc132-9-prev.png" width="257" height="270" alt=" " /></a>
<p><i>Obrázek 5: Základní zapojení mikrořadiče M68HC05.<br />
(Zdroj: Freescale Semiconductor, Ltd. MC68HC05B6/D Rev. 4.1 08/2005)</i></p>

<p>Základní model procesoru <i>68HC05</i> měl na jediném čipu 176 bajtů RAM,
5936 bajtů ROM, 256 bajtů EEPROM, tři osmibitové I/O porty, šestnáctibitový
čítač/časovač, sériové rozhraní SCI, jeden osmibitový A/D převodník a konečně
modul pro PWM (pulsní šířkovou modulaci). Existovaly však i další varianty
tohoto procesoru, z&nbsp;nichž některé měly až 32 kB ROM či EPROM, větší
kapacitu paměti RAM, nainstalovanou rutinu ve firmware, která umožňovala
komunikaci s&nbsp;PC přes sériový port (později se tato rutina vyvinula ve
známé <i>BUFFALO</i>) atd.</p>

<a href="http://i.iinfo.cz/images/212/pc132-10.png"><img src="http://i.iinfo.cz/images/212/pc132-10-prev.png" width="370" height="242" alt=" " /></a>
<p><i>Obrázek 6: Instrukční sada mikrořadiče M68HC05.<br />
(Zdroj: Freescale Semiconductor, Ltd. MC68HC05B6/D Rev. 4.1 08/2005)</i></p>



<p><a name="k04"></a></p>
<h2 id="k04">4. Motorola 68HC08</h2>

<p>Dalším osmibitovým mikrořadičem, který byl navržen firmou <i>Motorola</i> a
který je kupodivu nabízen dodnes (i když s&nbsp;celkem logickým dovětkem
&bdquo;Not Recommended for New Design&ldquo;) je mikrořadič nesoucí označení
<i>68HC08</i>. Jedná se o v&nbsp;mnoha směrech vylepšenou variantu původního
mikrořadiče <i>68HC05</i>, který svým uživatelům nabízel jak větší množství
vstupně-výstupních portů, více časovačů a osmikanálový analogově-digitální
převodník, tak i rozšířenou kapacitu pamětí ROM a RAM.</p>

<a href="http://i.iinfo.cz/images/57/pc133-6.png"><img src="http://i.iinfo.cz/images/57/pc133-6-prev.png" width="276" height="270" alt=" " /></a>
<p><i>Obrázek 7: Zapojení pinů osmibitového mikrořadiče 68HC08 popsaného v&nbsp;této kapitole.<br />
(Zdroj: Technical Data &ndash; MC68HC08AB16A, Freescale Semiconductor)</i></p>

<p>Došlo i ke změně v&nbsp;konfiguraci registrů a rozšíření instrukční sady
tohoto mikrořadiče &ndash; zejména byly přidány nové adresní režimy, které
umožňovaly lépe využít zvětšenou kapacitu pamětí ROM a RAM. V&nbsp;následující
tabulce jsou vypsány všechny registry centrální procesorové jednotky, které
mohly být využity při programování v&nbsp;assembleru. Povšimněte si především
toho, že došlo k&nbsp;rozšíření původně osmibitového indexového registru
<strong>X</strong> na šestnáctibitový registr <strong>H:X</strong>, jehož obě
osmibitové části lze v&nbsp;případě potřeby zpracovávat odděleně. Taktéž se
rozšířila bitová šířka registrů <strong>PC</strong> a <strong>SP</strong> na
plných šestnáct bitů:</p>

<table>
<tr><th>Označení</th><th>Šířka (b)</th><th>Využito bitů</th><th>Název registru </th><th>Význam registru</th></tr>
<tr><td>A  </td><td> 8</td><td> 8</td><td>accumulator A</td><td>jediný universální pracovní registr</td></tr>
<tr><td>H:X</td><td>16</td><td>16</td><td>index register</td><td>používán při adresování operandů</td></tr>
<tr><td>PC </td><td>16</td><td>16</td><td>program counter</td><td>používán při adresování instrukcí</td></tr>
<tr><td>SP </td><td>16</td><td>16</td><td>stack pointer</td><td>použit při operacích se zásobníkem</td></tr>
<tr><td>CCR</td><td> 8</td><td> 6</td><td>condition code register</td><td>obsahuje příznakové bity</td></tr>
</table>

<a href="http://i.iinfo.cz/images/57/pc133-7.png"><img src="http://i.iinfo.cz/images/57/pc133-7-prev.png" width="321" height="270" alt=" " /></a>
<p><i>Obrázek 8: Interní struktura mikrořadiče 68HC08.<br />
(Zdroj: Technical Data &ndash; MC68HC08AB16A, Freescale Semiconductor)</i></p>

<p>Došlo i k&nbsp;rozšíření počtu příznaků uložených v&nbsp;registru
<strong>CCR</strong> &ndash; nyní již bylo možné používat příznak
<strong>V</strong> (<i>overflow</i>) nastavovaný mnoha aritmetickými
operacemi.</p>

<a href="http://i.iinfo.cz/images/57/pc133-8.png"><img src="http://i.iinfo.cz/images/57/pc133-8-prev.png" width="364" height="270" alt=" " /></a>
<p><i>Obrázek 9: Instrukční sada mikrořadiče 68HC08.<br />
(Zdroj: Technical Data &ndash; MC68HC08AB16A, Freescale Semiconductor)</i></p>



<p><a name="k05"></a></p>
<h2 id="k05">5. Odlišná větev vývoje &ndash; Motorola 68HC11</h2>

<p>Částečně paralelně s&nbsp;větví 68HC05 &rarr; 68HC08 &rarr; S08 se vyvíjely
mikrořadiče s&nbsp;označením <i>68HC11</i>, které patřily mezi nejpoužívanější
mikrořadiče vůbec. Jádra <i>68HC11</i> jsou sice interně, podobně jako jejich
předchůdci, postavena na osmibitovém jádru (aritmeticko-logická jednotka +
řadič zpracovávající instrukce s&nbsp;osmibitovými operačními kódy), ovšem
z&nbsp;programátorského hlediska se jedná o čip umožňující provádění některých
výpočtů i adresování se šestnáctibitovými operandy. Z&nbsp;tohoto hlediska se
jedná o přechod mezi čistě osmibitovým a 16bitovým mikrořadičem, což může být
výhodné, protože programátor není (například při adresování) omezován nutností
používat osmibitové adresy či osmibitové indexové registry, ale celková cena
čipu (a taktéž jeho příkon!) je díky převážně osmibitové aritmeticko-logické
jednotce stále velmi příznivá, v&nbsp;čemž lze spatřovat jeden z&nbsp;důvodů,
proč se osmibitové mikrořadiče stále používají.</p>

<a href="http://i.iinfo.cz/images/683/pc13405.png"><img src="http://i.iinfo.cz/images/683/pc13405-prev.png" width="274" height="270" alt=" " /></a>
<p><i>Obrázek 10: Mikrořadič 68HC11 řady E v&nbsp;64pinovém pouzdru typu
QFP.</i></p>

<p>Programátoři vytvářející programy pro mikrořadič <i>68HC11</i> mohou
používat dvojici osmibitových pracovních registrů <strong>A</strong> a
<strong>B</strong>, které se však u některých instrukcí spojují do jediného
šestnáctibitového registru nazvaného <strong>D</strong> (<i>double
accumulator</i>). Kromě těchto registrů, které jsou převážně používány jako
operandy aritmetických, logických a bitových instrukcí, je možné využít i
indexové registry <strong>IX</strong> a <strong>IY</strong> (někdy jsou tyto
registry pojmenované pouze <strong>X</strong> a <strong>Y</strong>), jež se
používají především při adresování operandů ležících v&nbsp;paměti,
popř.&nbsp;jako čítače programových smyček.</p>

<img src="http://i.iinfo.cz/images/133/pc13406.png" width="389" height="516" alt=" " />
<p><i>Obrázek 11: Mikrořadič 68HC11 řady E v&nbsp;48pinovém pouzdru typu
DIP.</i></p>

<p>V&nbsp;množině registrů použitelných vývojáři samozřejmě najdeme i
šestnáctibitový programový čítač <strong>PC</strong> (<i>program counter</i>),
taktéž šestnáctibitový ukazatel na vrchol zásobníku <strong>SP</strong>
(<i>stack pointer</i>) a osmibitový registr <strong>CCR</strong> (<i>condition
codes register</i>), který v&nbsp;sobě sdružuje osmici jednobitových příznaků
vyžívaných například při konstrukci podmínek (což je obvykle nějaký test
následovaný podmíněným skokem). Na tomto místě možná stojí za připomenutí, že
mikrořadič <i>68HC11</i> je založen na původním osmibitovém mikroprocesoru
<i>MC6800</i>; nikoli tedy na mikroprocesoru <i>MC6809</i>. To je trošku škoda,
protože mikroprocesor <i>MC6809</i> byl kvůli své téměř ortogonální instrukční
sadě, existenci rozmanitých adresních režimů i přítomnosti druhého ukazatele na
vrchol zásobníku <strong>U</strong> z&nbsp;programátorského hlediska mnohem
flexibilnějším čipem (traduje se, že se jednalo o jeden z&nbsp;posledních
mikroprocesorů s&nbsp;ručně optimalizovaným a &bdquo;zadrátovaným&ldquo;
mikrořadičem).</p>



<p><a name="k06"></a></p>
<h2 id="k06">6. Programátorský pohled na jádra S08</h2>

<p>Důležitá poznámka: nyní se budeme zabývat především jádry S08, protože jádra
RS08 mají odlišné vlastnosti, jejichž popisu bude věnován samostatný
článek.</p>

<p>Programátorský model mikrořadičových jader S08 se nijak zásadně
neliší od 68HC08. To mj.&nbsp;znamená, že k&nbsp;dispozici je šest registrů
(z&nbsp;toho pouze jeden akumulátor), přičemž indexové registry
<strong>H</strong> a <strong>X</strong> je možné spojit a vytvořit tak
šestnáctibitový indexový registr, s&nbsp;nímž je možné adresovat jakoukoli
paměťovou buňku v&nbsp;rozsahu 0..64kB. Totéž platí o čítači instrukcí
(<strong>PC</strong>) i ukazateli na vrchol zásobníku
(<strong>SP</strong>):</p>

<table>
<tr><th>Označení</th><th>Šířka (b)</th><th>Využito bitů</th><th>Název registru </th><th>Význam registru</th></tr>
<tr><td>A  </td><td> 8</td><td> 8</td><td>accumulator A</td><td>jediný universální pracovní registr</td></tr>
<tr><td>H:X</td><td>16</td><td>16</td><td>index register</td><td>používán při adresování operandů</td></tr>
<tr><td>PC </td><td>16</td><td>16</td><td>program counter</td><td>používán při adresování instrukcí</td></tr>
<tr><td>SP </td><td>16</td><td>16</td><td>stack pointer</td><td>použit při operacích se zásobníkem</td></tr>
<tr><td>CCR</td><td> 8</td><td> 6</td><td>condition code register</td><td>obsahuje příznakové bity</td></tr>
</table>

<p>V&nbsp;registru <strong>CCR</strong> jsou uloženy příznakové bity. Tento
registr má sice šířku osmi bitů, ovšem jen šest bitů je skutečně využito pro
uložení příznaků. Zbylé dva bity jsou nastaveny na jedničku:</p>

<table>
<tr><th>Bit#</th><th>Označení příznaku</th><th>Jméno příznaku</th><th>Význam</th></tr>
<tr><td>7</td><td>V</td><td>Overflow</td><td>tento příznak je nastavený při přenosu ze šestého do sedmého bitu, což v&nbsp;případě znaménkové aritmetiky značí přetečení hodnoty čísla do bitu vyhrazeného pro znaménko</td></tr>
<tr><td>6</td><td>&times;</td><td>&times;</td><td>neobsazeno, trvale nastaveno na 1</td></tr>
<tr><td>5</td><td>&times;</td><td>&times;</td><td>neobsazeno, trvale nastaveno na 1</td></tr>
<tr><td>4</td><td>H</td><td>Half-Carry Flag</td><td>nastavený při přenosu ze třetího do čtvrtého bitu; tento příznak je použit při BCD aritmetice</td></tr>
<tr><td>3</td><td>I</td><td>Interrupt Mask</td><td>příznak, pomocí něhož lze povolit či naopak zakázat maskovatelné přerušení (IRQ)</td></tr>
<tr><td>2</td><td>N</td><td>Negative Flag</td><td>tento příznak je nastaven, pokud poslední aritmetická či logická operace vygenerovala záporný výsledek, tj.&nbsp;bajt s&nbsp;nejvyšším bitem rovným jedničce (0x80 až 0xFF)</td></tr>
<tr><td>1</td><td>Z</td><td>Zero Flag</td><td>tento příznak se nastaví, pokud poslední aritmetická či logická operace vygenerovala osmibitovou hodnotu 0x00, spolu s&nbsp;předchozím příznakem lze zjišťovat relace typu: &lt;0 &le;0 =0 &ge;0 &gt;0 &ne;0</td></tr>
<tr><td>0</td><td>C</td><td>Carry Flag</td><td>přetečení ze sedmého do (neexistujícího) osmého bitu při mnoha operacích (rotace, aritmetické operace); tento příznak je taktéž nastavovaný nebo nulovaný při bitových operacích v&nbsp;prvních 256 bajtech paměti</td></tr>
</table>

<p>Poznámka: u jader RS08 je registr <strong>CCR</strong> omezen na pouhé dva
bity &ndash; <i>Carry flag</i> a <i>Zero flag</i>. Navíc zde nenalezneme
registr H a i adresovací režimy jsou odlišné.</p>



<p><a name="k07"></a></p>
<h2 id="k07">7. Adresovací režimy jader S08</h2>

<p><a href="#k06">V&nbsp;předchozí kapitole</a> jsme mohli vidět, že počet
použitelných pracovních registrů je skutečně minimální. To mj.&nbsp;znamená, že
se registry používají poněkud odlišným způsobem, než například na klasických
RISCových procesorech či na mikrořadičích, které se RISCovým procesorům alespoň
částečně podobají (H8/300, MSP430 atd.). Zásadní rozdíl spočívá v&nbsp;tom, že
jeden z&nbsp;operandů je typicky uložen v&nbsp;akumulátoru, zatímco operand
druhý je umístěn v&nbsp;operační paměti či v&nbsp;ROM (to je přesný opak
RISCové architektury typu <i>load &amp; store</i>). Tento druhý operand musí
být efektivně dosažitelný; z&nbsp;tohoto důvodu podporují mikrořadičová jádra
S08 a RS08 velké množství adresovacích režimů. Všechny podporované adresovací
režimy jsou vypsány v&nbsp;následující tabulce:</p>

<table>
<tr><th>#</th><th>Název</th><th>Zkratka</th><th>Stručný popis</th></tr>
<tr><td> 1</td><td>Inherent</td><td>INH</td><td>operand je umístěn v&nbsp;registru</td></tr>
<tr><td> 2</td><td>Relative</td><td>REL</td><td>za instrukcí je osmibitový offset připočtený k&nbsp;PC</td></tr>
<tr><td> 3</td><td>Immediate</td><td>IMM</td><td>za instrukcí je umístěna 8bit/16bit konstanta</td></tr>
<tr><td> 4</td><td>Direct</td><td>DIR</td><td>za instrukcí je umístěna osmibitová adresa do nulté stránky</td></tr>
<tr><td> 5</td><td>Extended</td><td>EXT</td><td>za instrukcí je umístěna 16bitová absolutní adresa</td></tr>
<tr><td> 6</td><td>Indexed</td><td>IX</td><td>operand je adresován dvojicí H:X</td></tr>
<tr><td> 7</td><td>Indexed with Post Increment</td><td>IX+</td><td>dtto, ale dvojice H:X je zvýšena o jedničku</td></tr>
<tr><td> 8</td><td>Indexed, 8-Bit Offset</td><td>IX1</td><td>k&nbsp;hodnotě H:X je připočten osmibitový offset</td></tr>
<tr><td> 9</td><td>Indexed, 16-Bit Offset</td><td>IX2</td><td>k&nbsp;hodnotě H:X je připočten 16bitový offset</td></tr>
<tr><td>10</td><td>Indexed, 8-Bit Offset with Post Increment</td><td>IX1+</td><td>kombinace (IX+) a (IX1)</td></tr>
<tr><td>11</td><td>SP-Relative, 8-Bit Offset</td><td>SP1</td><td>podobné (REL), ovšem offset je přičten k&nbsp;SP</td></tr>
<tr><td>12</td><td>SP-Relative, 16-Bit Offset</td><td>SP2</td><td>podobné (REL), ovšem offset je přičten k&nbsp;SP</td></tr>
</table>

<p>Z&nbsp;předchozí tabulky nepřímo vyplývá, že instrukce mají proměnlivou
délku, a to z&nbsp;toho důvodu, že za kód instrukce je nutné uložit i
konstantu, osmibitový offset či šestnáctibitový offset.</p>



<p><a name="k08"></a></p>
<h2 id="k08">8. Instrukční sada mikrořadičových jader S08</h2>

<p>Instrukční soubor mikrořadičových jader S08 je sice relativně malý, ovšem
celkový počet instrukčních kódů narůstá kvůli použití většího množství
adresovacích režimů. To je ostatně jeden z&nbsp;důvodů, proč některé instrukce
(není jich ovšem mnoho) používají jednobajtový prefix. Podobný koncept, i když
pro jiné instrukce, bylo nutné použít i u výše zmiňovaných mikrořadičů
<i>68HC11</i>, u nichž se prefix používal u většiny instrukcí pracujících
s&nbsp;indexovým registrem IY. U S08 naprostá většina instrukcí používá pro
zakódování instrukce jediný bajt, který je v&nbsp;případě některých <a
href="#k07">adresovacích režimů</a> doplněn o osmibitový či šestnáctibitový
offset.</p>

<p>V&nbsp;následující tabulce jsou instrukce jader S08 rozděleny podle své
funkce do různých kategorií:</p>

<table>
<tr><th>Skupina</th><th>Počet instrukcí</th></tr>
<tr><td><a href="#k09">Aritmetické instrukce</a></td><td>17</td></tr>
<tr><td><a href="#k10">Logické instrukce</a></td><td>5</td></tr>
<tr><td><a href="#k11">Posuny a rotace</a></td><td>6</td></tr>
<tr><td><a href="#k12">Podmíněné a nepodmíněné skoky</a></td><td>27</td></tr>
<tr><td><a href="#k13">Instrukce Booleovského procesoru</a></td><td>4</td></tr>
<tr><td><a href="#k14">Přesuny dat a další operace</a></td><td>27</td></tr>
<tr><th>Celkem:</th><th>76</th></tr>
</table>

<p>Z&nbsp;dále uvedeného seznamu instrukcí je patrné, jak zásadně je instrukční
sada ovlivněna tím, že namísto sady pracovních registrů je k&nbsp;dispozici jen
jediný akumulátor. Výhodou jsou kratší instrukční kódy, zásadní nevýhodou pak
nutnost použití většího množství instrukcí při implementaci algoritmů
(v&nbsp;porovnání s&nbsp;RISCovými sadami).</p>



<p><a name="k09"></a></p>
<h2 id="k09">9. Aritmetické instrukce</h2>

<p>Aritmetické instrukce obsahují základní operace pro součet a rozdíl, přičemž
u instrukcí se dvěma operandy je jedním operandem vždy akumulátor a výsledek je
taktéž uložen do akumulátoru.  Poněkud netypické instrukce pro součin a podíl
používají registry H a X, které jsou jinak použité především pro indexování.
Další dvě instrukce pak zajišťují operace s&nbsp;ukazatelem na vrchol zásobníku
a s&nbsp;indexovým &bdquo;dvojregistrem&ldquo;:</p>

<table>
<tr><th> #</th><th>Instrukce</th><th>Stručný popis</th></tr>
<tr><td> 1</td><td>ADD</td><td>součet A = A + mem</td></tr>
<tr><td> 2</td><td>ADC</td><td>součet A = A + mem + carry</td></tr>
<tr><td> 3</td><td>SUB</td><td>rozdíl A = A - mem</td></tr>
<tr><td> 4</td><td>SBC</td><td>rozdíl A = A - mem - carry</td></tr>
<tr><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td></tr>
<tr><td> 5</td><td>MUL</td><td>součin X:A = X &times; A</td></tr>
<tr><td> 6</td><td>DIV</td><td>podíl A = H:A / X, H = zbytek</td></tr>
<tr><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td></tr>
<tr><td> 7</td><td>AIS</td><td>SP = SP + konstanta</td></tr>
<tr><td> 8</td><td>AIX</td><td>H:X = H:X + mem</td></tr>
<tr><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td></tr>
<tr><td> 9</td><td>INC</td><td>inkrementace A, X, nebo mem</td></tr>
<tr><td>10</td><td>DEC</td><td>dekrementace A, X, nebo mem</td></tr>
<tr><td>11</td><td>CLR</td><td>vynulování A, X, nebo mem</td></tr>
<tr><td>12</td><td>NEG</td><td>změna znaménka A, X, nebo mem</td></tr>
<tr><td>13</td><td>TST</td><td>porovnání A, X nebo mem s&nbsp;nulou</td></tr>
<tr><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td></tr>
<tr><td>14</td><td>CMP</td><td>jako SUB, ale bez změny A</td></tr>
<tr><td>15</td><td>CPX</td><td>porovnání X s&nbsp;mem</td></tr>
<tr><td>16</td><td>CPHX</td><td>porovnání H:X s&nbsp;mem</td></tr>
<tr><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td></tr>
<tr><td>17</td><td>DAA</td><td>korekce výsledku pro součet v&nbsp;kódu BCD</td></tr>
</table>

<p>Poznámka: <i>mem</i> je obsah paměti adresované některým z&nbsp;adresovacích
režimů.</p>



<p><a name="k10"></a></p>
<h2 id="k10">10. Logické instrukce</h2>

<p>Kromě trojice klasických instrukcí AND, ORA a EOR (někde XOR) nalezneme
v&nbsp;této skupině i instrukci pro negaci všech bitů v&nbsp;akumulátoru či
v&nbsp;buňce operační paměti. Taktéž zde nalezneme instrukci BIT, která provádí
tutéž operaci jako AND, ovšem změní pouze příznaky a nikoli již obsah
akumulátoru:</p>

<table>
<tr><th>#</th><th>Instrukce</th><th>Stručný popis</th></tr>
<tr><td>1</td><td>AND</td><td>logický součin bit po bitu: A = A &amp; mem</td></tr>
<tr><td>2</td><td>ORA</td><td>logické součet bit po bitu: A = A | mem</td></tr>
<tr><td>3</td><td>EOR</td><td>logická nonekvivalence: A = A &oplus; memm</td></tr>
<tr><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td></tr>
<tr><td>4</td><td>COM</td><td>negace A, X nebo mem</td></tr>
<tr><td>5</td><td>BIT</td><td>jako AND ovšem beze změny A</td></tr>
</table>



<p><a name="k11"></a></p>
<h2 id="k11">11. Aritmetické posuny, bitové posuny a rotace</h2>

<p>Všechny instrukce pro aritmetické i bitové posuny a rotace dokážou operand
posunout o jediný bit, což mj.&nbsp;znamená, že tyto instrukce vyžadují pouze
jediný operand. U aritmetických a logických posunů se přebytečný bit přesouvá
do příznaku <i>carry</i>, u obou instrukcí pro rotaci je <i>carry</i> naopak
devátým bitem v&nbsp;&bdquo;posuvném registru&ldquo;:</p>

<table>
<tr><th>#</th><th>Instrukce</th><th>Stručný popis</th></tr>
<tr><td>1</td><td>LSL</td><td>logický posun doleva (lze posouvat A, X či mem)</td></tr>
<tr><td>2</td><td>LSR</td><td>logický posun doprava (-//-)</td></tr>
<tr><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td></tr>
<tr><td>3</td><td>ASL</td><td>pouze alias k&nbsp;instrukci LSL</td></tr>
<tr><td>4</td><td>ASR</td><td>aritmetický posun doprava</td></tr>
<tr><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td></tr>
<tr><td>5</td><td>ROL</td><td>rotace doleva přes příznak <i>carry</i></td></tr>
<tr><td>6</td><td>ROR</td><td>rotace doprava přes příznak <i>carry</i></td></tr>
</table>



<p><a name="k12"></a></p>
<h2 id="k12">12. Podmíněné i nepodmíněné skoky</h2>

<p>Jediná instrukce nepodmíněného skoku JMP je zvláštní tím, že podporuje hned
pět adresovacích režimů, včetně použití indexového registru. To
mj.&nbsp;znamená, že tuto instrukci lze použít pro implementaci rozhodovacích
tabulek apod. U instrukcí podmíněného skoku se používá vždy jen relativní
adresování s&nbsp;osmibitovým offsetem. Instrukce BRA je vlastně jen variantou
instrukce JMP, ovšem s&nbsp;jiným adresovacím režimem:</p>

<table>
<tr><th> #</th><th>Instrukce</th><th>Stručný popis</th></tr>
<tr><td> 1</td><td>JMP </td><td>nepodmíněný skok</td></tr>
<tr><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td></tr>
<tr><td> 2</td><td>BRA </td><td>nepodmíněný skok</td></tr>
<tr><td> 3</td><td>BRN </td><td>v podstatě instrukce NOP</td></tr>
<tr><td> 4</td><td>BEQ </td><td>skok za podmínky Z = 1</td></tr>
<tr><td> 5</td><td>BNE </td><td>skok za podmínky Z = 0</td></tr>
<tr><td> 6</td><td>BCC </td><td>skok za podmínky C = 0</td></tr>
<tr><td> 7</td><td>BCS </td><td>skok za podmínky C = 1</td></tr>
<tr><td> 8</td><td>BPL </td><td>skok za podmínky N = 0</td></tr>
<tr><td> 9</td><td>BMI </td><td>skok za podmínky N = 1</td></tr>
<tr><td>10</td><td>BIL </td><td>skok za podmínky IRQ pin = 0</td></tr>
<tr><td>11</td><td>BIH </td><td>skok za podmínky IRQ pin = 1</td></tr>
<tr><td>12</td><td>BMC </td><td>skok za podmínky I = 0</td></tr>
<tr><td>13</td><td>BMS </td><td>skok za podmínky I = 1</td></tr>
<tr><td>14</td><td>BHCC</td><td>skok za podmínky H = 0</td></tr>
<tr><td>15</td><td>BHCS</td><td>skok za podmínky H = 1</td></tr>
<tr><td>16</td><td>BLT </td><td>skok za podmínky N &oplus; V = 1</td></tr>
<tr><td>17</td><td>BLE </td><td>skok za podmínky Z | (N &oplus; V) = 1</td></tr>
<tr><td>18</td><td>BGE </td><td>skok za podmínky N &oplus; V = 0</td></tr>
<tr><td>19</td><td>BGT </td><td>skok za podmínky Z | (N &oplus; V) = )</td></tr>
<tr><td>20</td><td>BLS </td><td>C | Z = 1</td></tr>
<tr><td>21</td><td>BHI </td><td>C | Z = 0</td></tr>
<tr><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td></tr>
<tr><td>22</td><td>CBEQ</td><td>skok pokud A = mem</td></tr>
<tr><td>23</td><td>DBNZ</td><td>dekrementace A, X nebo M se skokem, pokud je výsledek nenulový</td></tr>
<tr><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td></tr>
<tr><td>24</td><td>JSR</td><td>skok do podprogramu</td></tr>
<tr><td>25</td><td>BSR</td><td>relativní skok do podprogramu</td></tr>
<tr><td>26</td><td>RTS</td><td>návrat z&nbsp;podprogramu</td></tr>
<tr><td>27</td><td>RTI</td><td>návrat z&nbsp;přerušovací rutiny</td></tr>
</table>

<p>Užitečné jsou instrukce <strong>CBEQ</strong> (<i>compare and branch if
equal</i>), což je instrukce odpovídající (až na negaci podmínky) instrukci
<strong>CJNE</strong> známé z&nbsp;mikrořadičů <i>MCS-51</i>. Taktéž užitečná
je instrukce <strong>DBNZ</strong> (<i>decrement and branch if not zero</i>),
kterou lze použít pro implementaci počítaných programových smyček.</p>



<p><a name="k13"></a></p>
<h2 id="k13">13. Instrukce Booleovského procesoru</h2>

<p>Čtveřice instrukce je určena pro manipulaci s&nbsp;prvními 256 bajty paměti
na úrovni jednotlivých bitů. Jedná se o instrukci <strong>BCLR</strong>
sloužící pro vynulování vybraného bitu, dále o instrukci <strong>BSET</strong>
pro nastavení bitu do stavu logické jedničky. Hodnotu libovolného bitu lze
testovat instrukcemi <strong>BRCLR</strong> (<i>branch if clear</i>) a
<strong>BRSET</strong> (<i>branch if set</i>) &ndash; na základě hodnoty
příslušného bitu je proveden relativní skok v&nbsp;rámci +- 127 bajtů a navíc
je nastaven příznak <i>carry</i>. Každá ze zmíněných instrukcí je v&nbsp;sadě
instrukcí použita osmkrát, protože součástí operačního kódu je i index
nastavovaného, nulovaného či testovaného bitu. Tyto instrukce jsou, jako
podobně navržené instrukce u mikrořadičů <i>MCS-51</i>, velmi užitečné, protože
do prvních 256 adres paměti jsou adresovány řídicí registry (jejichž jednotlivé
bity mají různý význam) i část uživatelské RAM.</p>

<table>
<tr><th>#</th><th>Instrukce</th><th>Stručný popis</th></tr>
<tr><td>1</td><td>BCLR</td><td>vynulování bitu v&nbsp;paměti</td></tr>
<tr><td>2</td><td>BSET</td><td>nastavení bitu v&nbsp;paměti</td></tr>
<tr><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td></tr>
<tr><td>3</td><td>BRCLR</td><td>skok, pokud je bit v&nbsp;paměti nulový</td></tr>
<tr><td>4</td><td>BRSET</td><td>skok, pokud je bit v&nbsp;paměti nastavený na 1</td></tr>
</table>



<p><a name="k14"></a></p>
<h2 id="k14">14. Přesuny dat a další operace</h2>

<p>Zbylé instrukce slouží většinou pro přesuny dat mezi registry a pamětí,
popř.&nbsp;pro jiné operace:</p>

<table>
<tr><th> #</th><th>Instrukce</th><th>Stručný popis</th></tr>
<tr><td> 1</td><td>LDA </td><td>načtení bajtu do akumulátoru A</td></tr>
<tr><td> 2</td><td>LDX </td><td>načtení bajtu do index registru X</td></tr>
<tr><td> 3</td><td>LDHX</td><td>načtení dvou bajtů do H:X</td></tr>
<tr><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td></tr>
<tr><td> 4</td><td>STA </td><td>uložení akumulátoru do mem</td></tr>
<tr><td> 5</td><td>STX </td><td>uložení index registru X do mem</td></tr>
<tr><td> 6</td><td>STHX</td><td>uložení dvojice H:X do mem</td></tr>
<tr><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td></tr>
<tr><td> 7</td><td>TAX </td><td>přesun X=A</td></tr>
<tr><td> 8</td><td>TXA </td><td>přesun A=X</td></tr>
<tr><td> 9</td><td>TAP </td><td>přesun CCR=A</td></tr>
<tr><td>10</td><td>TPA </td><td>přesun A=CCR</td></tr>
<tr><td>11</td><td>TXS </td><td>přesun SP=H:X</td></tr>
<tr><td>12</td><td>TSX </td><td>přesun H:X=SP</td></tr>
<tr><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td></tr>
<tr><td>13</td><td>NSA </td><td>prohození horních a spodních čtyř bitů v&nbsp;A</td></tr>
<tr><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td></tr>
<tr><td>14</td><td>PSHA</td><td>uložení akumulátoru A na zásobník</td></tr>
<tr><td>15</td><td>PSHX</td><td>uložení index registru X na zásobník</td></tr>
<tr><td>16</td><td>PSHH</td><td>uložení index registru H na zásobník</td></tr>
<tr><td>17</td><td>PULA</td><td>obnovení akumulátoru A ze zásobníku</td></tr>
<tr><td>18</td><td>PULX</td><td>obnovení index registru X ze zásobníku</td></tr>
<tr><td>19</td><td>PULH</td><td>obnovení index registru H ze zásobníku</td></tr>
<tr><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td></tr>
<tr><td>20</td><td>NOP</td><td>NOP (na rozdíl od BRN má jen jeden bajt)</td></tr>
<tr><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td></tr>
<tr><td>21</td><td>SEC</td><td>nastavení C=1</td></tr>
<tr><td>22</td><td>CLC</td><td>vynulování C=0</td></tr>
<tr><td>23</td><td>SEI</td><td>nastavení I=1</td></tr>
<tr><td>24</td><td>CLI</td><td>vynulování I=0</td></tr>
<tr><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td></tr>
<tr><td>25</td><td>BGND</td><td>pozastavení běhu programu</td></tr>
<tr><td>26</td><td>WAIT</td><td>čekání na přerušení</td></tr>
<tr><td>27</td><td>STOP</td><td>ukončení běhu programu a čekání na přerušení</td></tr>
</table>



<p><a name="k15"></a></p>
<h2 id="k15">15. Odkazy na Internetu</h2>

<ol>

<li>8-bit S08<br />
<a href="http://www.nxp.com/products/microcontrollers-and-processors/more-processors/8-16-bit-mcus/8-bit-s08:HCS08">http://www.nxp.com/products/microcontrollers-and-processors/more-processors/8-16-bit-mcus/8-bit-s08:HCS08</a>
</li>

<li>S08QB: 8-bit QB MCUs<br />
<a href="http://www.nxp.com/products/microcontrollers-and-processors/more-processors/8-16-bit-mcus/8-bit-s08/8-bit-s08-3.6v-mcus/8-bit-qb-mcus:S08QB">http://www.nxp.com/products/microcontrollers-and-processors/more-processors/8-16-bit-mcus/8-bit-s08/8-bit-s08-3.6v-mcus/8-bit-qb-mcus:S08QB</a>
</li>

<li>8-bit RS08<br />
<a href="http://www.nxp.com/products/microcontrollers-and-processors/more-processors/8-16-bit-mcus/8-bit-rs08:RS08FAMILY">http://www.nxp.com/products/microcontrollers-and-processors/more-processors/8-16-bit-mcus/8-bit-rs08:RS08FAMILY</a>
</li>

<li>Wikipedia: Motorola 68HC05<br />
<a href="http://en.wikipedia.org/wiki/Motorola_68HC05">http://en.wikipedia.org/wiki/Motorola_68HC05</a>
</li>

<li>Wikipedia: Freescale 68HC08<br />
<a href="http://en.wikipedia.org/wiki/68HC08">http://en.wikipedia.org/wiki/68HC08</a>
</li>

<li>Wikipedia: Freescale 68HC11<br />
<a href="http://en.wikipedia.org/wiki/68HC11">http://en.wikipedia.org/wiki/68HC11</a>
</li>

<li>Wikipedia: Freescale 68HC12<br />
<a href="http://en.wikipedia.org/wiki/Freescale_68HC12">http://en.wikipedia.org/wiki/Freescale_68HC12</a>
</li>

<li>HC05 Processor Families<br />
<a href="http://www.freescale.com/webapp/sps/site/overview.jsp?nodeId=01624684498633">http://www.freescale.com/webapp/sps/site/overview.jsp?nodeId=01624684498633</a>
</li>

<li>HC08 Processor Families<br />
<a href="http://www.freescale.com/webapp/sps/site/overview.jsp?nodeId=01624684497663">http://www.freescale.com/webapp/sps/site/overview.jsp?nodeId=01624684497663</a>
</li>

<li>Digital Core Design 68HC08 - HDL IP Core <br />
<a href="http://www.dcd.pl/acore.php?idcore=82">http://www.dcd.pl/acore.php?idcore=82</a>
</li>

<li>Freescale 68HC11<br />
<a href="http://www.freescale.com/webapp/sps/site/taxonomy.jsp?nodeId=01624684498635">http://www.freescale.com/webapp/sps/site/taxonomy.jsp?nodeId=01624684498635</a>
</li>

<li>Lifecycle of a CPU:<br />
<a href="http://www.cpushack.net/life-cycle-of-cpu.html">http://www.cpushack.net/life-cycle-of-cpu.html</a>
</li>

<li>Great Microprocessors of the Past and Present (V 13.4.0)<br />
<a href="http://jbayko.sasktelwebsite.net/cpu.html">http://jbayko.sasktelwebsite.net/cpu.html</a>
</li>

<li>SPI interface tutorial<br />
<a href="http://www.best-microcontroller-projects.com/spi-interface.html">http://www.best-microcontroller-projects.com/spi-interface.html</a></li>

<li>Serial Peripheral Interface Bus<br />
<a href="http://en.wikipedia.org/wiki/Serial_Peripheral_Interface_Bus">http://en.wikipedia.org/wiki/Serial_Peripheral_Interface_Bus</a></li>

<li>What is SPI?<br />
<a href="http://www.fpga4fun.com/SPI1.html">http://www.fpga4fun.com/SPI1.html</a></li>

<li>SPI - A simple implementation<br />
<a href="http://www.fpga4fun.com/SPI2.html">http://www.fpga4fun.com/SPI2.html</a></li>

<li>Bit-banging<br />
<a href="http://en.wikipedia.org/wiki/Bit-banging">http://en.wikipedia.org/wiki/Bit-banging</a></li>

<li>Joint Test Action Group<br />
<a href="http://en.wikipedia.org/wiki/JTAG">http://en.wikipedia.org/wiki/JTAG</a></li>

<li>I<sup>2</sup>C<br />
<a href="http://en.wikipedia.org/wiki/I2C">http://en.wikipedia.org/wiki/I2C</a></li>

<li>I<sup>2</sup> Background<br />
<a href="http://www.microport.tw/blognew.php?blog_no=7#theory">http://www.microport.tw/blognew.php?blog_no=7#theory</a></li>

<li>H8/3802, 38002S, 38004, 38104 (manuály k&nbsp;čipům)<br />
<a href="https://www.renesas.com/en-us/document/hw-manual?hwLayerShowFlg=true&prdLayerId=184&layerName=H8%252F3802%252C%2B38002S%252C%2B38004%252C%2B38104&coronrService=document-prd-search&hwDocUrl=%2Fen-us%2Fdoc%2Fproducts%2Fmpumcu%2F001%2Frej09b0024_h83802.pdf&hashKey=c5e1fa0a18c01e6c789bc7b5c0184ed9">https://www.renesas.com/en-us/document/hw-manual?hwLayerShowFlg=true&prdLayerId=184&layerName=H8%252F3802%252C%2B38002S%252C%2B38004%252C%2B38104&coronrService=document-prd-search&hwDocUrl=%2Fen-us%2Fdoc%2Fproducts%2Fmpumcu%2F001%2Frej09b0024_h83802.pdf&hashKey=c5e1fa0a18c01e6c789bc7b5c0184ed9</a>
</li>

<li>Addressing mode (Wikipedia)<br />
<a href="https://en.wikipedia.org/wiki/Addressing_mode">https://en.wikipedia.org/wiki/Addressing_mode</a>
</li>

<li>Renesas SH Instruction Set Summary<br />
<a href="http://shared-ptr.com/sh_insns.html">http://shared-ptr.com/sh_insns.html</a>
</li>

<li>SH-4 RISC Processor by HITACHI<br />
<a href="http://www.cs.umd.edu/~meesh/cmsc411/website/projects/risc/risc.htm">http://www.cs.umd.edu/~meesh/cmsc411/website/projects/risc/risc.htm</a>
</li>

<li>SH-4 RISC Processor<br />
<a href="http://www.cs.umd.edu/~meesh/cmsc411/website/projects/risc/sh-4.htm">http://www.cs.umd.edu/~meesh/cmsc411/website/projects/risc/sh-4.htm</a>
</li>

<li>SuperH RISC engine Family Features<br />
<a href="https://www.renesas.com/en-us/products/microcontrollers-microprocessors/superh/superh-features.html">https://www.renesas.com/en-us/products/microcontrollers-microprocessors/superh/superh-features.html</a>
</li>

<li>Orthogonal instruction set<br />
<a href="https://en.wikipedia.org/wiki/Orthogonal_instruction_set">https://en.wikipedia.org/wiki/Orthogonal_instruction_set</a>
</li>

<li>An introduction to the TI MSP430 low-power microcontrollers<br />
<a href="http://mspgcc.sourceforge.net/manual/c68.html">http://mspgcc.sourceforge.net/manual/c68.html</a>
</li>

<li>MSP430 LaunchPad Tutorials<br />
<a href="http://processors.wiki.ti.com/index.php/MSP430_LaunchPad_Tutorials">http://processors.wiki.ti.com/index.php/MSP430_LaunchPad_Tutorials</a>
</li>

<li>LaunchPad MSP430 Assembly Language Tutorial<br />
<a href="http://robotics.hobbizine.com/asmlau.html">http://robotics.hobbizine.com/asmlau.html</a>
</li>

<li>TI 16-bit and 32-bit microcontrollers<br />
<a href="http://www.ti.com/lsds/ti/microcontrollers_16-bit_32-bit/overview.page">http://www.ti.com/lsds/ti/microcontrollers_16-bit_32-bit/overview.page</a>
</li>

</ol>



<p></p><p></p>
<p><small>Autor: <a href="http://www.fit.vutbr.cz/~tisnovpa">Pavel Tišnovský</a> &nbsp; 2016</small></p>
</body>
</html>

