<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
        "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html>
<head>
<title>Mikrořadičová jádra TriCore: dokončení popisu instrukční sady</title>
<meta name="Author" content="Pavel Tisnovsky" />
<meta name="Generator" content="vim" />
<meta http-equiv="content-type" content="text/html; charset=utf-8" />
<style type="text/css">
         body {color:#000000; background:#ffffff;}
         h1  {font-family: arial, helvetica, sans-serif; color:#ffffff; background-color:#c00000; text-align:center; padding-left:1em}
         h2  {font-family: arial, helvetica, sans-serif; color:#ffffff; background-color:#0000c0; padding-left:1em; text-align:left}
         h3  {font-family: arial, helvetica, sans-serif; color:#000000; background-color:#c0c0c0; padding-left:1em; text-align:left}
         h4  {font-family: arial, helvetica, sans-serif; color:#000000; background-color:#e0e0e0; padding-left:1em; text-align:left}
         a   {font-family: arial, helvetica, sans-serif;}
         li  {font-family: arial, helvetica, sans-serif; color:#000000; text-align:justify; width:450px;}
         ol  {font-family: arial, helvetica, sans-serif; color:#000000; text-align:justify; width:450px;}
         ul  {font-family: arial, helvetica, sans-serif; color:#000000; text-align:justify; width:450px;}
         p   {font-family: arial, helvetica, sans-serif; color:#000000; text-align:justify;}
         pre {background:#e0e0e0}
</style>
</head>

<body>

<h1></h1>

<h3>Pavel Tišnovský</h3>

<p></p>

<h1>Úvodník</h1>

<p>Popis mikrořadičových jader TriCore, v&nbsp;nichž se kombinují možnosti mikrořadičů, digitálních signálových procesorů a RISCových procesorů, dnes dokončíme. Zabývat se budeme především zajímavými vlastnostmi instrukční sady těchto čipů.</p>



<h2>Obsah</h2>

<p><a href="#k01">1. Mikrořadičová jádra TriCore: dokončení popisu instrukční sady</a></p>
<p><a href="#k02">2. Seznam všech instrukcí jader TriCore (bez FPU)</a></p>
<p><a href="#k03">3. Základní aritmetické instrukce</a></p>
<p><a href="#k04">4. Logické instrukce</a></p>
<p><a href="#k05">5. Aritmetické a logické posuny</a></p>
<p><a href="#k06">6. Instrukce typu Load &amp; Store</a></p>
<p><a href="#k07">7. Nepodmíněné skoky</a></p>
<p><a href="#k08">8. Podmíněné skoky</a></p>
<p><a href="#k09">9. Skoky do podprogramů a návraty z&nbsp;podprogramů</a></p>
<p><a href="#k10">10. Instrukce pro programové smyčky</a></p>
<p><a href="#k11">11. Instrukce s&nbsp;podmínkou</a></p>
<p><a href="#k12">12. Instrukce pro práci s&nbsp;bitovými poli</a></p>
<p><a href="#k13">13. Instrukce booleovského procesoru</a></p>
<p><a href="#k14">14. Tříadresové instrukce booleovského procesoru</a></p>
<p><a href="#k15">15. Uložení a obnovení kontextu</a></p>
<p><a href="#k16">16. Odkazy na Internetu</a></p>



<p><a name="k01"></a></p>
<h2 id="k01">1. Mikrořadičová jádra TriCore: dokončení popisu instrukční sady</h2>

<p>V&nbsp;dnešním článku dokončíme popis instrukční sady jader TriCore.
Připomeňme si <a
href="https://www.root.cz/clanky/mikroradicova-jadra-tricore-kombinace-mcu-dsp-a-riscu/">z&nbsp;předchozí
části</a>, že instrukce zpracovávané jádry TriCore jsou sice v&nbsp;některých
ohledech odvozeny od klasických RISCových instrukčních sad, ovšem kvůli
zařazení DSP operací, dále popsaných šestnáctibitových instrukcí atd. je ve
skutečnosti instrukční sada poměrně komplikovaná (navíc jsou některé instrukce
složitější, ty se však neprovádí v&nbsp;hlavním CPU). Všechny instrukce můžeme
rozdělit do několika kategorií popř.&nbsp;podkategorií:</p>

<ol>
<li>Aritmetické instrukce
    <ul>
        <li><a href="#k03">Celočíselné</a></li>
        <li>DSP (popsané minule)</li>
        <li>SIMD (popsané minule)</li>
        <li>Adresová aritmetika</li>
    </ul>
</li>
<li><a href="#k04">Logické instrukce</a></li>
<li><a href="#k05">Bitové posuny</a></li>
<li><a href="#k13">Manipulace s&nbsp;jednotlivými bity</a></li>
<li>Přenosy dat
    <ul>
        <li>Přenosy dat mezi registry</li>
        <li><a href="#k11">Podmíněné přenosy dat (CMOV)</a></li>
        <li><a href="#k06">Load/Store</a></li>
    </ul>
<li>Porovnání hodnot či adres</li>
<li>Skoky
    <ul>
        <li><a href="#k07">Nepodmíněné</a></li>
        <li><a href="#k08">Podmíněné</a></li>
        <li><a href="#k09">Skoky a návraty z&nbsp;podprogramů</a></li>
        <li><a href="#k10">Instrukce pro programové smyčky</a></li>
    </ul>
</li>
<li>Podmnožina šestnáctibitových instrukcí (popsané minule)</li>
<li>Systémové instrukce (začátek rutiny pro obsluhu přerušení, debug režim ...)</li>
</ol>



<p><a name="k02"></a></p>
<h2 id="k02">2. Seznam všech instrukcí jader TriCore (bez FPU)</h2>

<p>V&nbsp;tabulce zobrazené pod tímto odstavcem jsou vypsány všechny základní
instrukce jader TriCore. I když je počet instrukcí poměrně vysoký, stále se
jedná o procesorové jádro s&nbsp;RISCovou architekturou, protože ty
nejsložitější instrukce (uložení kontextu, násobení, programové smyčky apod.)
jsou prováděny paralelně k&nbsp;tomu vytvořených modulech a nikoli přímo
v&nbsp;hlavním CPU:</p>

<table>
<tr><th>Instrukce</th><th>Význam mnemotechnické zkratky</th></tr>
<tr><td>ABS</td><td>Absolute value</td></tr>
<tr><td>ABSDIF</td><td>Absolute value of difference</td></tr>
<tr><td>ABSDIFS</td><td>Absolute value of difference with saturation</td></tr>
<tr><td>ABSS</td><td>Absolute value with saturation</td></tr>
<tr><td>ADD</td><td>Add</td></tr>
<tr><td>ADDC</td><td>Add carry</td></tr>
<tr><td>ADDI</td><td>Add immediate</td></tr>
<tr><td>ADDIH</td><td>Add immediate high word</td></tr>
<tr><td>ADDS</td><td>Add with saturation</td></tr>
<tr><td>ADDSC</td><td>Add scaled address</td></tr>
<tr><td>ADDX</td><td>Add and generate carry</td></tr>
<tr><td>AND</td><td>Logical AND</td></tr>
<tr><td>AND.comp</td><td>Compare, AND and accumulate</td></tr>
<tr><td>AND.logic</td><td>Bit and logical accumulate</td></tr>
<tr><td>ANDN</td><td>Logical AND Not</td></tr>
<tr><td>BISR</td><td>Begin ISR</td></tr>
<tr><td>BMERGE</td><td>Merges even/odd</td></tr>
<tr><td>BSPLIT</td><td>Split in even/odd</td></tr>
<tr><td>CACHEA.I</td><td>Cache Address Invalidate</td></tr>
<tr><td>CACHEA.W</td><td>Cache Address Writeback</td></tr>
<tr><td>CACHEA.WI</td><td>Cache Address Writeback and Invalidate</td></tr>
<tr><td>CADD</td><td>Conditional ADD</td></tr>
<tr><td>CADDN</td><td>Conditional ADD Not</td></tr>
<tr><td>CALL</td><td>Call</td></tr>
<tr><td>CALLA</td><td>Call absolute</td></tr>
<tr><td>CALLI</td><td>Call indirect</td></tr>
<tr><td>CLO</td><td>Count leading ones</td></tr>
<tr><td>CLS</td><td>Count leading signs</td></tr>
<tr><td>CLZ</td><td>Count leading zeros</td></tr>
<tr><td>CMOV</td><td>Conditional move</td></tr>
<tr><td>CMOVN</td><td>Conditional move Not</td></tr>
<tr><td>CSUB</td><td>Conditional subtract</td></tr>
<tr><td>CSUBN</td><td>Conditional subtract Not</td></tr>
<tr><td>DEBUG</td><td>Debug</td></tr>
<tr><td>DEXTR</td><td>Double extract</td></tr>
<tr><td>DISABLE</td><td>Disable interrupt</td></tr>
<tr><td>DSYNC</td><td>Synchronize data</td></tr>
<tr><td>DVADJ</td><td>Divide adjust</td></tr>
<tr><td>DVINIT</td><td>Divide initialization word</td></tr>
<tr><td>DVSTEP</td><td>Divide step</td></tr>
<tr><td>ENABLE</td><td>Enable interrupt</td></tr>
<tr><td>EQ</td><td>Equal</td></tr>
<tr><td>EQANY</td><td>Multiple compare</td></tr>
<tr><td>EQZ</td><td>Equal zero address</td></tr>
<tr><td>EXTR</td><td>Extract bit field</td></tr>
<tr><td>GE</td><td>Greater than or equal</td></tr>
<tr><td>IMASK</td><td>Insert mask</td></tr>
<tr><td>INS</td><td>Insert bit</td></tr>
<tr><td>INSERT</td><td>Insert</td></tr>
<tr><td>INSN</td><td>Insert bit Not</td></tr>
<tr><td>ISYNC</td><td>Synchronize instructions</td></tr>
<tr><td>IXMAX</td><td>Finds maximum value in signed array</td></tr>
<tr><td>IXMAX.U</td><td>Finds maximum value in unsigned array</td></tr>
<tr><td>IXMIN</td><td>Finds minimum value in signed array</td></tr>
<tr><td>IXMIN.U</td><td>Finds minimum value in unsigned array</td></tr>
<tr><td>J</td><td>Jump unconditional</td></tr>
<tr><td>JA</td><td>Jump unconditional absolute</td></tr>
<tr><td>JEQ</td><td>Jump if equal</td></tr>
<tr><td>JGE</td><td>Jump if greater than or equal</td></tr>
<tr><td>JGEZ</td><td>Jump if greater than or equal to zero</td></tr>
<tr><td>JGTZ</td><td>Jump if greater than zero</td></tr>
<tr><td>JI</td><td>Jump indirect</td></tr>
<tr><td>JL</td><td>Jump and link</td></tr>
<tr><td>JLA</td><td>Jump and link absolute</td></tr>
<tr><td>JLEZ</td><td>Jump if less than or equal to zero</td></tr>
<tr><td>JLI</td><td>Jump and link immediate</td></tr>
<tr><td>JLT</td><td>Jump if less than</td></tr>
<tr><td>JLTZ</td><td>Jump if less than zero</td></tr>
<tr><td>JNE</td><td>Jump if not equal</td></tr>
<tr><td>JNED</td><td>Jump if not equal and decrement</td></tr>
<tr><td>JNEI</td><td>Jump if not equal and increment</td></tr>
<tr><td>JNZ</td><td>Jump if not equal to zero</td></tr>
<tr><td>JZ</td><td>Jump if zero</td></tr>
<tr><td>LD</td><td>Load</td></tr>
<tr><td>LDLCX</td><td>Load lower context</td></tr>
<tr><td>LDMDST</td><td>Load modify store</td></tr>
<tr><td>LDUCX</td><td>Load upper context</td></tr>
<tr><td>LEA</td><td>Load Effective address</td></tr>
<tr><td>LOOP</td><td>Loop</td></tr>
<tr><td>LOOPU</td><td>Loop unconditional</td></tr>
<tr><td>LT</td><td>Less than</td></tr>
<tr><td>MADD(S)</td><td>Multiply-Add (S = with Saturation)</td></tr>
<tr><td>MADDM(S).H</td><td>Packed Multiply-Add Q Format - Multiprecision</td></tr>
<tr><td>MADDR(S).H</td><td>Packed Multiply-Add Q Format w/ Rounding</td></tr>
<tr><td>MADDR(S).Q</td><td>Multiply-Add Q Format with Rounding</td></tr>
<tr><td>MADDSU(S).H</td><td>Packed Multiply-Add/Sub Q Format</td></tr>
<tr><td>MADDSUM(S).H</td><td>Packed Multiply-Add/Sub Q Format - Multiprecision</td></tr>
<tr><td>MADDSUR(S).H</td><td>Packed Multiply-Add/Sub Q Format w/ Rounding</td></tr>
<tr><td>MAX</td><td>Maximum value</td></tr>
<tr><td>MFCR</td><td>Move from Core Register</td></tr>
<tr><td>MIN</td><td>Minimum value</td></tr>
<tr><td>MOV</td><td>Move</td></tr>
<tr><td>MOVH(.A)</td><td>Move halfword to address</td></tr>
<tr><td>MSUB(S)</td><td>Multiply-Subtract (S = with Saturation)</td></tr>
<tr><td>MSUBAD(S).H</td><td>Packed Multiply-Sub/Add Q Format</td></tr>
<tr><td>MSUBADM(S).H</td><td>Packed Multiply-Sub/Add Q Format - Multiprecision</td></tr>
<tr><td>MSUBADR(S).H</td><td>Packed Multiply-Sub/Add Q Format w/ Rounding</td></tr>
<tr><td>MSUBM(S).H</td><td>Packed Multiply-Subtract Q Format - Multiprecision</td></tr>
<tr><td>MSUBR(S).H</td><td>Packed Multiply-Subtract Q Format w/ Rounding</td></tr>
<tr><td>MSUBR(S).Q</td><td>Multiply-Subtract Q Format w/ Rounding</td></tr>
<tr><td>MTCR</td><td>Move to Core Register</td></tr>
<tr><td>MUL(S)</td><td>Multiply (S = with Saturation)</td></tr>
<tr><td>MUL(S).U</td><td>Multiply Unsigned (S = with Saturation)</td></tr>
<tr><td>MUL.H</td><td>Packed Multiply Q Format</td></tr>
<tr><td>MUL.Q</td><td>Multiply Q Format</td></tr>
<tr><td>MULM.H</td><td>Packed Multiply Q Format - Multiprecision</td></tr>
<tr><td>MULR.H</td><td>Packed Multiply Q Format with Rounding</td></tr>
<tr><td>MULR.Q</td><td>Multiply Q Format with Rounding</td></tr>
<tr><td>NAND</td><td>Logical NAND</td></tr>
<tr><td>NE</td><td>Not equal</td></tr>
<tr><td>NEZ.A</td><td>Not equal zero address</td></tr>
<tr><td>NOP</td><td>No operation</td></tr>
<tr><td>NOR</td><td>Logical NOR</td></tr>
<tr><td>NOT</td><td>Bitwise complement</td></tr>
<tr><td>OR</td><td>Logical OR</td></tr>
<tr><td>OR.comp</td><td>Compare, OR and accumulate</td></tr>
<tr><td>OR.logic</td><td>Bit OR logical accumulate</td></tr>
<tr><td>ORN</td><td>Logical OR Not</td></tr>
<tr><td>PACK</td><td>Translates in floating-point format</td></tr>
<tr><td>PARITY</td><td>Computes parity</td></tr>
<tr><td>RET</td><td>Return from call</td></tr>
<tr><td>RFE</td><td>Return from Exception</td></tr>
<tr><td>RSLCX</td><td>Restore lower context</td></tr>
<tr><td>RSTV</td><td>Reset overflow flags</td></tr>
<tr><td>RSUB</td><td>Reverse subtract</td></tr>
<tr><td>RSUBS</td><td>Reverse subtract with saturation</td></tr>
<tr><td>SAT</td><td>Saturate result</td></tr>
<tr><td>SEL</td><td>Select</td></tr>
<tr><td>SELN</td><td>Select Not</td></tr>
<tr><td>SH</td><td>Shift</td></tr>
<tr><td>SH.comp</td><td>Compare accumulate and shift</td></tr>
<tr><td>SH.logic</td><td>Bit shift logical accumulate</td></tr>
<tr><td>SHA</td><td>Arithmetic shift</td></tr>
<tr><td>SHAS</td><td>Arithmetic shift with saturation</td></tr>
<tr><td>ST</td><td>Store</td></tr>
<tr><td>STLCX</td><td>Store lower context</td></tr>
<tr><td>STUCX</td><td>Store upper context</td></tr>
<tr><td>SUB</td><td>Subtract</td></tr>
<tr><td>SUBC</td><td>Subtract with carry</td></tr>
<tr><td>SUBS</td><td>Subtract signed with saturation</td></tr>
<tr><td>SUBX</td><td>Subtract extended</td></tr>
<tr><td>SVLCX</td><td>Save lower context</td></tr>
<tr><td>SWAP</td><td>Swap</td></tr>
<tr><td>SYSCALL</td><td>System call</td></tr>
<tr><td>TLBDEMAP</td><td>Uninstall a mapping in the MMU</td></tr>
<tr><td>TLBFLUSH</td><td>Flush mappings from MMU</td></tr>
<tr><td>TLBMAP</td><td>Install a mapping in the MMU</td></tr>
<tr><td>TLBPROBE.A</td><td>Probe the MMU for a virtual address</td></tr>
<tr><td>TRAPSV</td><td>Trap on sticky overflow</td></tr>
<tr><td>TRAPV</td><td>Trap on overflow</td></tr>
<tr><td>UNPACK</td><td>Translates from floating-point format</td></tr>
<tr><td>XNOR</td><td>Logical exclusive NOR</td></tr>
<tr><td>XOR</td><td>Logical exclusive OR</td></tr>
<tr><td>XOR.comp</td><td>Compare, XOR and accumulate</td></tr>
</table>



<p><a name="k03"></a></p>
<h2 id="k03">3. Základní aritmetické instrukce</h2>

<p>Některé základní aritmetické instrukce jsme si již <a
href="https://www.root.cz/clanky/mikroradicova-jadra-tricore-kombinace-mcu-dsp-a-riscu/#k08">popsali
minule</a>, takže si nyní pouze uvedeme jejich souhrn. Povšimněte si, že jsou
podporovány jak instrukce s&nbsp;přetečením výsledků (to odpovídá zvykům
z&nbsp;jiných architektur), tak i se saturací, což je výhodnější ve chvíli, kdy
se zpracovávají různé signály. Programátor si taktéž může zvolit, jestli se má
použít carry bit uložený v&nbsp;registru <strong>PSW</strong> či nikoli. Ve
spodní části tabulky můžeme vidět instrukce sloužící pro výpočet absolutní
hodnoty, výběr maxima či minima ze dvou operandů a taktéž instrukci pro převod
32bitové hodnoty na hodnotu šestnáctibitovou či osmibitovou se saturací
(zachová se znaménko, horních 16 či 24 bitů se vynuluje atd.):</p>

<table>
<tr><th>Instrukce</th><th>Stručný popis</th></tr>
<tr><td>ADD</td><td>součet (bez saturace, s&nbsp;přetečením)</td></tr>
<tr><td>ADDC</td><td>součet + přičtení bitu carry z&nbsp;PSW</td></tr>
<tr><td>ADDX</td><td>součet s&nbsp;přetečením, nastavuje se carry bit v&nbsp;PSW</td></tr>
<tr><td>ADDS</td><td>součet se saturací (signed)</td></tr>
<tr><td>ADDS.U</td><td>součet se saturací (unsigned)</td></tr>
<tr><td>ADDI</td><td>součet s&nbsp;konstantou (16 bitů rozšířených na 32 bitů)</td></tr>
<tr><td>ADDIH</td><td>součet s&nbsp;konstantou (16 bitů posunutých doleva)</td></tr>
<tr><td>&nbsp;</td><td>&nbsp;</td></tr>
<tr><td>SUB</td><td>rozdíl (bez saturace, s&nbsp;podtečením)</td></tr>
<tr><td>SUBC</td><td>rozdíl + použití bitu carry z&nbsp;PSW</td></tr>
<tr><td>SUBS</td><td>rozdíl se saturací</td></tr>
<tr><td>SUBX</td><td>rozdíl, nastavení carry bitu v&nbsp;PSW</td></tr>
<tr><td>RSUB</td><td>jako SUB, ale s&nbsp;otočením operandů</td></tr>
<tr><td>RSUBS</td><td>jako SUBS, ale s&nbsp;otočením operandů</td></tr>
<tr><td>&nbsp;</td><td>&nbsp;</td></tr>
<tr><td>ABS</td><td>výpočet absolutní hodnoty operandu</td></tr>
<tr><td>MIN</td><td>výpočet minima</td></tr>
<tr><td>MAX</td><td>výpočet maxima</td></tr>
<tr><td>&nbsp;</td><td>&nbsp;</td></tr>
<tr><td>SAT</td><td>saturace při převodu 32bit &rarr; 16bit nebo 8bit</td></tr>
</table>



<p><a name="k04"></a></p>
<h2 id="k04">4. Logické instrukce</h2>

<p>U většiny běžných mikroprocesorů najdeme poměrně omezenou skupinu logických
operací, typicky čtveřici <strong>NOT</strong>, <strong>AND</strong>,
<strong>OR</strong> a <strong>XOR</strong>. U jader TriCore je tomu poněkud
jinak, protože zde je sada logických instrukcí rozšířena o instrukce
s&nbsp;negací vypočteného výsledku (<strong>NAND</strong>,
<strong>NOR</strong>, <strong>XNOR</strong>) a taktéž o instrukce, u nichž je
nejdříve negován jeden vstupní operand (<strong>ANDN</strong> a
<strong>ORN</strong>, tato varianta je u <strong>XOR</strong> zbytečná):</p>

<table>
<tr><th>Instrukce</th><th>Stručný popis</th></tr>
<tr><td>NOT</td><td>negace bit po bitu</td></tr>
<tr><td>&nbsp;</td><td>&nbsp;</td></tr>
<tr><td>AND</td><td>logická operace AND (logický součin)</td></tr>
<tr><td>OR</td><td>logická operace OR (logický součet)</td></tr>
<tr><td>XOR</td><td>logická operace XOR (logická nonekvivalence)</td></tr>
<tr><td>&nbsp;</td><td>&nbsp;</td></tr>
<tr><td>NAND</td><td>logická operace NAND (negace AND)</td></tr>
<tr><td>NOR</td><td>logická operace NOR (negace OR)</td></tr>
<tr><td>XNOR</td><td>logická operace exclusive NOR (negace XOR)</td></tr>
<tr><td>&nbsp;</td><td>&nbsp;</td></tr>
<tr><td>ANDN</td><td>logická operace AND (logický součin) s&nbsp;jedním operandem negovaným</td></tr>
<tr><td>ORN</td><td>logická operace OR (logický součet) s&nbsp;jedním operandem negovaným</td></tr>
</table>

<p>Poznámka: první instrukce implementuje logický unární operátor s&nbsp;jedním
vstupním operandem, další instrukce jsou binární, tj.&nbsp;se dvěma vstupními
operandy a jedním operandem výstupním.</p>



<p><a name="k05"></a></p>
<h2 id="k05">5. Aritmetické a logické posuny</h2>

<p>Skupina základních instrukcí pro posuny je poměrně malá, protože obsahuje
jen tři instrukce. Jádra TriCore nemusí rozlišovat speciální instrukce pro
posun doleva a doprava, protože samotný posun je představován číslem se
znaménkem. Ovšem, na rozdíl od mnoha jiných platforem, je k&nbsp;dispozici
posun doleva se saturací výsledku, tj.&nbsp;bez přetečení:</p>

<table>
<tr><th>Instrukce</th><th>Stručný popis</th></tr>
<tr><td>SH</td><td>logický posun doprava či doleva</td></tr>
<tr><td>SHA</td><td>aritmetický posun doprava či doleva</td></tr>
<tr><td>SHAS</td><td>dtto, ale při posunu doleva se navíc výsledek saturuje (nepřeteče)</td></tr>
</table>

<p>Poznámka: aritmetický posun doleva je shodný s&nbsp;logickým posunem.</p>



<p><a name="k06"></a></p>
<h2 id="k06">6. Instrukce typu Load &amp; Store</h2>

<p>Instrukce typu Load &amp; Store existují v&nbsp;několika variantách podle
toho, zda se přenáší operandy o velikosti bajtu, 16bitového slova či 32bitového
slova a taktéž podle způsobu uložení &ndash; adresový či datový registr.
Všechny možnosti jsou vypsány v&nbsp;následující tabulce:</p>

<table>
<tr><th>Instrukce</th><th>Stručný popis</th></tr>
<tr><td>LD.W</td><td>načtení hodnoty z&nbsp;paměti do 32bitového datového registru</td></tr>
<tr><td>LD.A</td><td>načtení hodnoty z&nbsp;paměti do 32bitového adresového registru</td></tr>
<tr><td>&nbsp;</td><td>&nbsp;</td></tr>
<tr><td>LD.B</td><td>načtení bajtu do pracovního registru se znaménkovým rozšířením</td></tr>
<tr><td>LD.BU</td><td>načtení bajtu do pracovního registru, horních 24 bitů se vynuluje</td></tr>
<tr><td>LD.H</td><td>načtení 16bitového slova do pracovního registru se znaménkovým rozšířením</td></tr>
<tr><td>LD.HU</td><td>načtení 16bitového slova do pracovního registru, horní polovina se vynuluje</td></tr>
<tr><td>LD.Q</td><td>načtení 16bitového slova do horní poloviny pracovního registru, spodní polovina se vynuluje</td></tr>
<tr><td>LD.D</td><td>načtení 64bitové hodnoty z&nbsp;paměti do dvou 32bitových datových registrů</td></tr>
<tr><td>LD.DA</td><td>načtení 64bitové hodnoty z&nbsp;paměti do dvou 32bitových adresových registrů</td></tr>
<tr><td>&nbsp;</td><td>&nbsp;</td></tr>
<tr><td>ST.W</td><td>uložení datového registru do paměti</td></tr>
<tr><td>ST.A</td><td>uložení adresového registru do paměti</td></tr>
<tr><td>&nbsp;</td><td>&nbsp;</td></tr>
<tr><td>ST.B</td><td>uložení spodních osmi bitů registru do paměti</td></tr>
<tr><td>ST.H</td><td>uložení spodních 16 bitů registru do paměti</td></tr>
<tr><td>ST.Q</td><td>uložení horních 16 bitů registru do paměti</td></tr>
<tr><td>ST.D</td><td>uložení registrového páru (datové registry)</td></tr>
<tr><td>ST.DA</td><td>uložení registrového páru (adresové registry)</td></tr>
</table>



<p><a name="k07"></a></p>
<h2 id="k07">7. Nepodmíněné skoky</h2>

<p>Nepodmíněné skoky existují ve čtyřech variantách. Základní instrukce nazvaná
jednoduše <strong>J</strong> (<i>jump</i>) obsahuje buď 24bitový či pouze
osmibitový offset, který je po vynásobení dvěma (instrukce totiž vždy leží na
sudých adresách) přičten k&nbsp;aktuální hodnotě registru <strong>PC</strong>
(programový čítač, <i>program counter</i>). Varianta instrukce
<strong>J</strong> s&nbsp;osmibitovým offsetem má šířku jen 16bitů (obdoba
&bdquo;Thumb&ldquo; u procesorů ARM). Instrukce <strong>JI</strong> (<i>jump
indirect</i>) skočí na adresu uloženou ve vybraném adresním registru (nejnižší
bit je ignorován, protože musí být nulový) a konečně instrukce
<strong>JA</strong> (<i>jump absolute</i>) použije absolutní 24bitovou adresu,
kterou vynásobí dvěma a navíc horní čtyři bity posune na indexy 31..28 (za nimi
je sedm nulových bitů, což poněkud omezuje cíl skoku):</p>

<table>
<tr><th>Instrukce</th><th>Stručný popis</th></tr>
<tr><td>J</td><td>relativní skok, offset je 24bitový (vynásobený dvěma)</td></tr>
<tr><td>J</td><td>varianta předchozí instrukce, offset je osmibitový (vynásobený dvěma)</td></tr>
<tr><td>JI</td><td>skok na adresu uloženou ve vybraném adresovém registru</td></tr>
<tr><td>JA</td><td>absolutní skok, adresa je 24bitová</td></tr>
</table>



<p><a name="k08"></a></p>
<h2 id="k08">8. Podmíněné skoky</h2>

<p>Instrukce podmíněných skoků jsou rozděleny do několika skupin. V&nbsp;první
skupině jsou skoky, v&nbsp;nichž se porovnává obsah operandu s&nbsp;osmibitovou
konstantou, která je znaménkově či beznaménkově rozšířena na 32bitové číslo.
Relativní adresa skoku má šířku 15 bitů:</p>

<table>
<tr><th>Instrukce</th><th>Stručný popis</th></tr>
<tr><td>JEQ</td><td>skok při rovnosti</td></tr>
<tr><td>JNE</td><td>skok při nerovnosti</td></tr>
<tr><td>JLT</td><td>skok za podmínky &lt;</td></tr>
<tr><td>JLT.U</td><td>skok za podmínky &lt; (unsigned)</td></tr>
<tr><td>JGE</td><td>skok za podmínky &ge;</td></tr>
<tr><td>JGE.U</td><td>skok za podmínky &ge; (unsigned)</td></tr>
</table>

<p>Další instrukce jsou šestnáctibitové (tj.&nbsp;obdoba Thumb instrukcí u
ARMu). Tyto instrukce pracují s&nbsp;implicitním datovým registrem D15 (viz
předchozí část seriálu), který je buď porovnáván s&nbsp;nulou nebo se
čtyřbitovou konstantou znaménkově rozšířenou na 32 bitů. U prvních dvou
instrukcí je relativní adresa osmibitová, u dalších instrukcí jen čtyřbitová,
protože další čtyři bity jsou použity pro již zmíněnou konstantu:</p>

<table>
<tr><th>Instrukce</th><th>Stručný popis</th></tr>
<tr><td>JZ </td><td>skok když D15==0</td></tr>
<tr><td>JNZ</td><td>skok když D15&ne;0</td></tr>
<tr><td>JEQ</td><td>skok když D15=konstanta</td></tr>
<tr><td>JNE</td><td>skok když D15&ne;konstanta</td></tr>
</table>

<p>Třetí skupina podmíněných skoků je taktéž zakódována do šestnácti bitů. Může
se zde použít libovolný pracovní registr, ovšem relativní adresa skoku je jen
čtyřbitová (ze stejného důvodu, jaký byl naznačen v&nbsp;předchozím
odstavci):</p>

<table>
<tr><th>Instrukce</th><th>Stručný popis</th></tr>
<tr><td>JZ  </td><td>skok když Dx==0</td></tr>
<tr><td>JNZ </td><td>skok když Dx&ne;0</td></tr>
<tr><td>JLTZ</td><td>skok když Dx&lt;0</td></tr>
<tr><td>JLEZ</td><td>skok když Dx&le;0</td></tr>
<tr><td>JGTZ</td><td>skok když Dx&gt;0</td></tr>
<tr><td>JGEZ</td><td>skok když Dx&ge;0</td></tr>
</table>

<p>Poslední skupina podmíněných skoků pracuje s&nbsp;adresovými registry
&ndash; vybraný registr je buď porovnán s&nbsp;konstantou nebo
s&nbsp;nulou:</p>

<table>
<tr><th>Instrukce</th><th>Stručný popis</th></tr>
<tr><td>JEQ.A</td><td>skok když Ax==konstanta</td></tr>
<tr><td>JNE.A</td><td>skok když Ax&ne;konstanta</td></tr>
<tr><td>JZ.A </td><td>skok když Ax==0</td></tr>
<tr><td>JNZ.A</td><td>skok když Ax&ne;0</td></tr>
</table>



<p><a name="k09"></a></p>
<h2 id="k09">9. Skoky do podprogramů a návraty z&nbsp;podprogramů</h2>

<p>Pro volání podprogramů se používá hned několik typů instrukcí. V&nbsp;první
řadě se jedná o instrukce typu <strong>JL</strong> (<i>jump and link</i>),
které odpovídají klasickým nepodmíněným skokům, ovšem navíc se návratová adresa
ukládá do link registru <strong>A11</strong>. Dále zde nalezneme instrukce
<strong>CALL</strong>, které navíc uloží celý &bdquo;horní kontext&ldquo;
(<i>upper context</i>) do oblasti paměti nazvané <i>CSA</i> (<i>Context Save
Area</i>). Opakem je instrukce <strong>RET</strong>, která obnoví &bdquo;horní
kontext&ldquo; a nahradí <strong>PC</strong> za hodnotu uloženou
v&nbsp;registru <strong>A11</strong>:</p>

<table>
<tr><th>Instrukce</th><th>Stručný popis</th></tr>
<tr><td>JL</td><td>obdoba instrukce J, ovšem návratová adresa se uloží do registru A11 (RA)</td></tr>
<tr><td>JLA</td><td>obdoba instrukce JA, ovšem návratová adresa se uloží do registru A11 (RA)</td></tr>
<tr><td>JLI</td><td>obdoba instrukce JI, ovšem návratová adresa se uloží do registru A11 (RA)</td></tr>
<tr><td>&nbsp;</td><td>&nbsp;</td></tr>
<tr><td>CALL</td><td>jako JL, ovšem navíc uloží &bdquo;horní kontext&ldquo; do CSA</td></tr>
<tr><td>CALLA</td><td>jako JLA, ovšem navíc uloží &bdquo;horní kontext&ldquo; do CSA</td></tr>
<tr><td>CALLI</td><td>jako JLI, ovšem navíc uloží &bdquo;horní kontext&ldquo; do CSA</td></tr>
<tr><td>&nbsp;</td><td>&nbsp;</td></tr>
<tr><td>RET</td><td>návrat z&nbsp;podprogramu, obnoví horní kontext z&nbsp;CSA</td></tr>
</table>

<p>Poznámka: do &bdquo;horního kontextu&ldquo; patří pracovní registry
<strong>D8</strong> až <strong>D15</strong> i adresové registry
<strong>A10</strong> až <strong>A15</strong>.</p>



<p><a name="k10"></a></p>
<h2 id="k10">10. Instrukce pro programové smyčky</h2>

<p>Pro efektivní implementaci programových smyček existují čtyři instrukce.
První dvě instrukce odpovídají podmíněnému skoku <strong>JNE</strong>, ovšem
testovaný registr se nezávisle na splnění či nesplnění podmínky zvýší či sníží
o jedničku, což umožňuje implementaci klasických počítaných programových
smyček. Další instrukce <strong>LOOP</strong> je velmi užitečná, protože je
prováděna ve vlastní jednotce nezávisle na ALU a proto každá další iterace
probíhá v&nbsp;nulovém počtu cyklů (z&nbsp;pohledu programátora). Tato
instrukce jako počitadlo používá adresový registr, což je výhodné při
implementaci různých filtrů, které stejně musí operandy načítat a ukládat do
polí. Poslední instrukce <strong>LOOPU</strong> provádí nepodmíněný skok, ovšem
opět ve specializované jednotce (za &bdquo;nula&ldquo; cyklů). Tato instrukce
ukončuje smyčku typu <i>while</i>:</p>

<table>
<tr><th>Instrukce</th><th>Stručný popis</th></tr>
<tr><td>JNEI</td><td>odpovídá instrukci JNE, ovšem první registr je zvýšen o jedničku (nezávisle na splnění či nesplnění podmínky)</td></tr>
<tr><td>JNED</td><td>odpovídá instrukci JNE, ovšem první registr je snížen o jedničku (nezávisle na splnění či nesplnění podmínky)</td></tr>
<tr><td>LOOP</td><td>hardwarově optimalizovaná počítaná programová smyčka</td></tr>
<tr><td>LOOPU</td><td>hardwarově optimalizovaný skok na zadanou adresu</td></tr>
</table>

<p>Následující příklad ukazuje implementaci počítané programové smyčky,
v&nbsp;níž se ve funkci počitadla používá registr <strong>D10</strong>. Smyčka
proběhne s&nbsp;hodnotou počitadla 1 až 100 (to proto, že se hodnota počitadla
zvýší PO vyhodnocení podmínky skoku):</p>

<pre>
        lea d10, 1
loopA:  ...
        ...
        ...
        jnei d10, 100, loopA
</pre>

<p>Následuje příklad smyčky, která po první iteraci nebude v&nbsp;praxi
vyžadovat žádné další strojové cykly, neboť vyhodnocení konce smyčky bude
provedeno paralelně s&nbsp;jejím tělem. Počitadlo je umístěno v&nbsp;adresovém
registru <strong>A10</strong>:</p>

<pre>
        mova a10, 99
loopB:  ...
        ...
        ...
        loop a10, loopB
</pre>



<p><a name="k11"></a></p>
<h2 id="k11">11. Instrukce s&nbsp;podmínkou</h2>

<p>Již <a
href="https://www.root.cz/clanky/mikroradicova-jadra-tricore-kombinace-mcu-dsp-a-riscu/">minule</a>
jsme se zmínili o instrukcích nazvaných <strong>SEL</strong> a
<strong>SELN</strong> pro podmíněný výběr výsledku, ovšem v&nbsp;instrukční
sadě jader TriCore nalezneme i další instrukce, v&nbsp;nichž se provádí
rozhodování na základě nějaké podmínky. Kromě podmíněných skoků se jedná o
instrukce, které testují nulovost či nenulovost jednoho z&nbsp;pracovních
registrů a na tomto základě potom provedou nějakou operaci. Instrukce
<strong>CMOV</strong> a <strong>CMOVN</strong> provede <strong>MOV</strong>
(přenos dat) pokud je testovaný registr nulový či naopak nenulový. Další čtyři
instrukce jsou složitější, protože mají <i>čtyři</i> operandy &ndash; testovaný
registr, dva registry zdrojové a registr cílový. Podívejme se na tabulku:</p>


<table>
<tr><th>Instrukce</th><th>Stručný popis</th></tr>
<tr><td>CMOV</td><td>pokud je první operand nenulový, přenes zdrojový registr do registru cílového</td></tr>
<tr><td>CMOVN</td><td>pokud je první operand nulový, přenes zdrojový registr do registru cílového</td></tr>
<tr><td>CADD</td><td>pokud je první operand nenulový, vypočti součet, jinak do cílového registru ulož první zdrojový registr</td></tr>
<tr><td>CADDN</td><td>pokud je první operand nulový, vypočti součet, jinak do cílového registru ulož první zdrojový registr</td></tr>
<tr><td>CSUB</td><td>pokud je první operand nenulový, vypočti rozdíl, jinak do cílového registru ulož první zdrojový registr</td></tr>
<tr><td>CSUBN</td><td>pokud je první operand nulový, vypočti rozdíl, jinak do cílového registru ulož první zdrojový registr</td></tr>
</table>

<p>Poznámka: instrukce <strong>CMOV</strong> a <strong>CMOVN</strong>
implementují &bdquo;polovinu funkcionality&ldquo; instrukcí
<strong>SEL</strong> a <strong>SELN</strong>.</p>



<p><a name="k12"></a></p>
<h2 id="k12">12. Instrukce pro práci s&nbsp;bitovými poli</h2>

<p>Dosti neobvyklé jsou instrukce určené pro práci s&nbsp;bitovými poli. Tyto
instrukce obsahují zdrojový operand, kterým je 32bitový registr a taktéž
dvojici hodnot <i>pos</i> a <i>width</i>. Tato dvojice určuje bitové pole (bity
pos+width až pos) ze zdrojového registru, které se přenesou do registru
cílového do jeho spodní části. Přitom může či nemusí dojít ke znaménkovému
rozšíření. Poslední instrukce je zvláštní tím, že zdrojem není jeden 32bitový
registr, ale 64bitový registrový pár:</p>

<table>
<tr><th>Instrukce</th><th>Stručný popis</th></tr>
<tr><td>EXTR</td><td>ze zdrojového registru přečte bity n až m</td></tr>
<tr><td>EXTR.U</td><td>dtto, ale neprovádí se znaménkové rozšíření</td></tr>
<tr><td>DEXTR</td><td>jako EXTR, je zdrojem jsou dva registry tvořící 64bitové pole</td></tr>
</table>



<p><a name="k13"></a></p>
<h2 id="k13">13. Instrukce booleovského procesoru</h2>

<p>Logické instrukce popsané ve <a href="#k04">čtvrté kapitole</a> existují i
v&nbsp;&bdquo;bitové&ldquo; variantě počítající s&nbsp;vybranými bity vstupních
operandů. U každého vstupního operandu (registru) lze zvolit odlišný index bitu
vstupujícího do operace, tedy například D10.31 a D9.0. Výsledek se vždy ukládá
do nejnižšího bitu výstupního registru, zbylých 31 bitů je vynulováno:</p>

<table>
<tr><th>Instrukce</th><th>Stručný popis</th></tr>
<tr><td>AND.T</td><td>logická operace AND (logický součin)</td></tr>
<tr><td>OR.T</td><td>logická operace OR (logický součet)</td></tr>
<tr><td>XOR.T</td><td>logická operace XOR (logická nonekvivalence)</td></tr>
<tr><td>&nbsp;</td><td>&nbsp;</td></tr>
<tr><td>NAND.T</td><td>logická operace NAND (negace AND)</td></tr>
<tr><td>NOR.T</td><td>logická operace NOR (negace OR)</td></tr>
<tr><td>XNOR.T</td><td>logická operace exclusive NOR (negace XOR)</td></tr>
<tr><td>&nbsp;</td><td>&nbsp;</td></tr>
<tr><td>ANDN.T</td><td>logická operace AND (logický součin) s&nbsp;jedním operandem negovaným</td></tr>
<tr><td>ORN.T</td><td>logická operace OR (logický součet) s&nbsp;jedním operandem negovaným</td></tr>
</table>



<p><a name="k14"></a></p>
<h2 id="k14">14. Tříadresové instrukce booleovského procesoru</h2>

<p>V&nbsp;instrukční sadě jader TriCore najdeme i booleovské instrukce se třemi
vstupními registry (jeden z&nbsp;těchto registrů je současně i cílovým
registrem). Tyto instrukce provádí dvojici logických operací, přičemž první
operace je provedena naprosto stejným způsobem, jaký byl popsán
v&nbsp;předchozí kapitole, tj.&nbsp;vybrané bity ze vstupních registrů tvoří
vstupní operandy. Ovšem druhá část je odlišná, neboť se mezivýsledek
z&nbsp;této operace neuloží přímo do nejnižšího bitu výstupního registru, ale
naopak se provede druhá operace (jen <strong>AND</strong> či
<strong>OR</strong>) mezi nejnižším bitem výstupního registru a
mezivýsledkem:</p>

<table>
<tr><th>Instrukce</th><th>Stručný popis</th></tr>
<tr><td>AND.AND.T </td><td>odpovídá instrukci AND.T, ovšem posléze se provede AND mezivýsledku a nejnižšího bitu cílového registru</td></tr>
<tr><td>AND.ANDN.T</td><td>odpovídá instrukci ANDN.T, ovšem posléze se provede AND mezivýsledku a nejnižšího bitu cílového registru </td></tr>
<tr><td>AND.NOR.T</td><td>odpovídá instrukci NOR.T, ovšem posléze se provede AND mezivýsledku a nejnižšího bitu cílového registru</td></tr>
<tr><td>AND.OR.T</td><td>odpovídá instrukci OR.T, ovšem posléze se provede AND mezivýsledku a nejnižšího bitu cílového registru</td></tr>
<tr><td>OR.AND.T</td><td>odpovídá instrukci AND.T, ovšem posléze se provede OR mezivýsledku a nejnižšího bitu cílového registru</td></tr>
<tr><td>OR.ANDN.T</td><td>odpovídá instrukci ANDN.T, ovšem posléze se provede OR mezivýsledku a nejnižšího bitu cílového registru</td></tr>
<tr><td>OR.NOR.T</td><td>odpovídá instrukci NOR.T, ovšem posléze se provede OR mezivýsledku a nejnižšího bitu cílového registru</td></tr>
<tr><td>OR.OR.T</td><td>odpovídá instrukci OR.T, ovšem posléze se provede OR mezivýsledku a nejnižšího bitu cílového registru</td></tr>
</table>



<p><a name="k15"></a></p>
<h2 id="k15">15. Uložení a obnovení kontextu</h2>

<p>Poslední instrukce, o nichž se dnes zmíníme, slouží pro uložení a obnovení
kontextu, tj.&nbsp;vybrané skupiny registrů. Kontext se ukládá do k&nbsp;tomu
určené oblasti operační paměti <i>CSA</i> (první dvě instrukce) nebo od určené
adresy. Do &bdquo;horního kontextu&ldquo; patří pracovní registry
<strong>D8</strong> až <strong>D15</strong> i adresové registry
<strong>A10</strong> až <strong>A15</strong>, do &bdquo;kontextu
spodního&ldquo; pak pracovní registry <strong>D0</strong> až
<strong>D7</strong> a adresové registry <strong>A2</strong> až
<strong>A7</strong>:</p>

<table>
<tr><th>Instrukce</th><th>Stručný popis</th></tr>
<tr><td>SVLCX</td><td>uložení spodního kontextu do CSA</td></tr>
<tr><td>RSLCX</td><td>obnovení spodního kontextu z&nbsp;CSA</td></tr>
<tr><td>STLCX</td><td>uložení spodního kontextu</td></tr>
<tr><td>STUCX</td><td>uložení horního kontextu</td></tr>
<tr><td>LDLCX</td><td>načtení spodního kontextu</td></tr>
<tr><td>LDUCX</td><td>načtení horního kontextu</td></tr>
</table>



<p><a name="k16"></a></p>
<h2 id="k16">16. Odkazy na Internetu</h2>

<ol>

<li>Q (number format)<br />
<a href="https://en.wikipedia.org/wiki/Q_%28number_format%29">https://en.wikipedia.org/wiki/Q_%28number_format%29</a>
</li>

<li>TriCore Architecture &amp; Core<br />
<a href="http://www.infineon.com/cms/en/product/microcontroller/32-bit-tricore-tm-microcontroller/tricore-tm-architecture-and-core/channel.html?channel=ff80808112ab681d0112ab6b73d40837">http://www.infineon.com/cms/en/product/microcontroller/32-bit-tricore-tm-microcontroller/tricore-tm-architecture-and-core/channel.html?channel=ff80808112ab681d0112ab6b73d40837</a>
</li>

<li>TriCoreTM V1.6 Instruction Set: 32-bit Unified Processor Core<br />
<a href="http://www.infineon.com/dgdl/tc_v131_instructionset_v138.pdf?fileId=db3a304412b407950112b409b6dd0352">http://www.infineon.com/dgdl/tc_v131_instructionset_v138.pdf?fileId=db3a304412b407950112b409b6dd0352</a>
</li>

<li>TriCore v2.2 C Compiler, Assembler, Linker Reference Manual<br />
<a href="http://tasking.com/support/tricore/tc_reference_guide_v2.2.pdf">http://tasking.com/support/tricore/tc_reference_guide_v2.2.pdf</a>
</li>

<li>Infineon TriCore (Wikipedia)<br />
<a href="https://en.wikipedia.org/wiki/Infineon_TriCore">https://en.wikipedia.org/wiki/Infineon_TriCore</a>
</li>

<li>C166®S V2 Architecture &amp; Core<br />
<a href="http://www.infineon.com/cms/en/product/microcontroller/16-bit-c166-microcontroller/c166-s-v2-architecture-and-core/channel.html?channel=db3a304312bef5660112c3011c7d01ae">http://www.infineon.com/cms/en/product/microcontroller/16-bit-c166-microcontroller/c166-s-v2-architecture-and-core/channel.html?channel=db3a304312bef5660112c3011c7d01ae</a>
</li>

<li>Memory segmentation<br />
<a href="https://en.wikipedia.org/wiki/Memory_segmentation">https://en.wikipedia.org/wiki/Memory_segmentation</a>
</li>

<li>Bus mastering<br />
<a href="https://en.wikipedia.org/wiki/Bus_mastering">https://en.wikipedia.org/wiki/Bus_mastering</a>
</li>

<li>ST10 16-bit MCUs<br />
<a href="http://www.st.com/en/microcontrollers/st10-16-bit-mcus.html?querycriteria=productId=LN1111">http://www.st.com/en/microcontrollers/st10-16-bit-mcus.html?querycriteria=productId=LN1111</a>
</li>

<li>XC800 family<br />
<a href="https://en.wikipedia.org/wiki/XC800_family">https://en.wikipedia.org/wiki/XC800_family</a>
</li>

<li>C166 (stránky společnosti Infineon)<br />
<a href="https://www.infineon.com/cms/en/product/microcontroller/16-bit-c166-microcontroller/channel.html?channel=ff80808112ab681d0112ab6b2eaf0759#ispnTab3">https://www.infineon.com/cms/en/product/microcontroller/16-bit-c166-microcontroller/channel.html?channel=ff80808112ab681d0112ab6b2eaf0759#ispnTab3</a>
</li>

<li>C166 Family<br />
<a href="https://en.wikipedia.org/wiki/C166_family">https://en.wikipedia.org/wiki/C166_family</a>
</li>

<li>Permanent Magnet Synchronous Motor<br />
<a href="https://en.wikipedia.org/wiki/Synchronous_motor#Permanent_magnet_motors">https://en.wikipedia.org/wiki/Synchronous_motor#Permanent_magnet_motors</a>
</li>

<li>Implementing field oriented control of a brushless DC motor<br />
<a href="http://www.eetimes.com/document.asp?doc_id=1279321">http://www.eetimes.com/document.asp?doc_id=1279321</a>
</li>

<li>Vector control (motor)<br />
<a href="https://en.wikipedia.org/wiki/Vector_control_(motor)">https://en.wikipedia.org/wiki/Vector_control_(motor)</a>
</li>

<li>Motorola DSP56k<br />
<a href="https://www.rockbox.org/wiki/MotorolaDSP56k">https://www.rockbox.org/wiki/MotorolaDSP56k</a>
</li>

<li>Motorola 56000 (Wikipedia)<br />
<a href="http://en.wikipedia.org/wiki/Motorola_56000">http://en.wikipedia.org/wiki/Motorola_56000</a>
</li>

<li>Using the Motorola DSP56002EVM for Amateur Radio DSP Projects<br />
<a href="http://www.johanforrer.net/EVM/article.html">http://www.johanforrer.net/EVM/article.html</a>
</li>

<li>The Atari Falcon030 "Personal Integrated Media System"<br />
<a href="http://www.atarimuseum.com/computers/16bits/falcon030.html">http://www.atarimuseum.com/computers/16bits/falcon030.html</a>
</li>

<li>Turtle Beach Corporation (stránky společnosti)<br />
<a href="http://www.turtlebeach.com/">http://www.turtlebeach.com/</a>
</li>

<li>Turtle Beach Corporation (Wikipedia)<br />
<a href="https://en.wikipedia.org/wiki/Turtle_Beach_Corporation">https://en.wikipedia.org/wiki/Turtle_Beach_Corporation</a>
</li>

<li>Atari Falcon 030 DSP 3D engine test<br />
<a href="http://www.digiti.info/video/WHQwMjNRaExfLWs=/atari_falcon_030_dsp_3d_engine_test">http://www.digiti.info/video/WHQwMjNRaExfLWs=/atari_falcon_030_dsp_3d_engine_test</a>
</li>

<li>Atari Falcon030 (německy)<br />
<a href="http://www.maedicke.de/atari/hardware/falcon.htm">http://www.maedicke.de/atari/hardware/falcon.htm</a>
</li>

<li>Old-computers.com: Atari Falcon030<br />
<a href="http://www.old-computers.com/museum/computer.asp?c=125&st=1">http://www.old-computers.com/museum/computer.asp?c=125&st=1</a>
</li>

<li>Atari Falcon030 (Wikipedia)<br />
<a href="http://en.wikipedia.org/wiki/Atari_Falcon">http://en.wikipedia.org/wiki/Atari_Falcon</a>
</li>

<li>Past and current projects (including Falcon stuff)<br />
<a href="http://os.inf.tu-dresden.de/~nf2/projects/projects.html">http://os.inf.tu-dresden.de/~nf2/projects/projects.html</a>
</li>

<li>Atari Falcon 030: The Case For The Defence<br />
<a href="http://www.soundonsound.com/sos/1994_articles/sep94/atarifalcon.html">http://www.soundonsound.com/sos/1994_articles/sep94/atarifalcon.html</a>
</li>

<li>DaVinci processor family<br />
<a href="http://www.ti.com/general/docs/datasheetdiagram.tsp?genericPartNumber=TMS320DM365&diagramId=64193">http://www.ti.com/general/docs/datasheetdiagram.tsp?genericPartNumber=TMS320DM365&diagramId=64193</a>
</li>

<li>Texas Instruments DaVinci<br />
<a href="https://en.wikipedia.org/wiki/Texas_Instruments_DaVinci">https://en.wikipedia.org/wiki/Texas_Instruments_DaVinci</a>
</li>

<li>TMS320DM6446 (DaVinci)<br />
<a href="http://www.ti.com/product/tms320dm6446">http://www.ti.com/product/tms320dm6446</a>
</li>

<li>Digital Media Video Processors (TI)<br />
<a href="http://www.ti.com/lsds/ti/processors/dsp/media_processors/davinci/products.page#">http://www.ti.com/lsds/ti/processors/dsp/media_processors/davinci/products.page#</a>
</li>

<li>TI Wiki<br />
<a href="http://processors.wiki.ti.com/index.php/Main_Page">http://processors.wiki.ti.com/index.php/Main_Page</a>
</li>

<li>C5000 ultra-low-power DSP<br />
<a href="http://www.ti.com/lsds/ti/processors/dsp/c5000_dsp/overview.page">http://www.ti.com/lsds/ti/processors/dsp/c5000_dsp/overview.page</a>
</li>

<li>OMAP (Wikipedia)<br />
<a href="https://en.wikipedia.org/wiki/OMAP">https://en.wikipedia.org/wiki/OMAP</a>
</li>

<li>OMAP - TI Wiki<br />
<a href="http://processors.wiki.ti.com/index.php/OMAP">http://processors.wiki.ti.com/index.php/OMAP</a>
</li>

<li>Why OMAP can't compete in smartphones<br />
<a href="http://www.eetimes.com/author.asp?section_id=40&doc_id=1286602">http://www.eetimes.com/author.asp?section_id=40&doc_id=1286602</a>
</li>

<li>Applications Processors – The Heart of the Smartphone<br />
<a href="http://www.engineering.com/ElectronicsDesign/ElectronicsDesignArticles/ArticleID/5791/Applications-Processors-The-Heart-of-the-Smartphone.aspx">http://www.engineering.com/ElectronicsDesign/ElectronicsDesignArticles/ArticleID/5791/Applications-Processors-The-Heart-of-the-Smartphone.aspx</a>
</li>

<li>TI cuts 1,700 jobs in OMAP shift<br />
<a href="http://www.eetimes.com/document.asp?doc_id=1262782">http://www.eetimes.com/document.asp?doc_id=1262782</a>
</li>

<li>VLIW: Very Long Instruction Word: Texas Instruments TMS320C6x<br />
<a href="http://www.ecs.umass.edu/ece/koren/architecture/VLIW/2/ti1.html">http://www.ecs.umass.edu/ece/koren/architecture/VLIW/2/ti1.html</a>
</li>

<li>An Introduction To Very-Long Instruction Word (VLIW) Computer Architecture<br />
Philips Semiconductors
</li>

<li>VLIW Architectures for DSP: A Two-Part Lecture (PDF, slajdy)<br />
<a href="http://www.bdti.com/MyBDTI/pubs/vliw_icspat99.pdf">http://www.bdti.com/MyBDTI/pubs/vliw_icspat99.pdf</a>
</li>

<li>Very long instruction word (Wikipedia)<br />
<a href="https://en.wikipedia.org/wiki/Very_long_instruction_word">https://en.wikipedia.org/wiki/Very_long_instruction_word</a>
</li>

<li>A VLIW Approach to Architecture, Compilers and Tools<br />
<a href="http://www.vliw.org/book/">http://www.vliw.org/book/</a>
</li>

<li>VEX Toolchain (VEX = VLIW Example)<br />
<a href="http://www.hpl.hp.com/downloads/vex/">http://www.hpl.hp.com/downloads/vex/</a>
</li>

<li>Elbrus (computer)<br />
<a href="https://en.wikipedia.org/wiki/Elbrus_%28computer%29">https://en.wikipedia.org/wiki/Elbrus_%28computer%29</a>
</li>

<li>Super Harvard Architecture Single-Chip Computer<br />
<a href="https://en.wikipedia.org/wiki/Super_Harvard_Architecture_Single-Chip_Computer">https://en.wikipedia.org/wiki/Super_Harvard_Architecture_Single-Chip_Computer</a>
</li>

<li>Digital Signal Processors (stránky TI)<br />
<a href="http://www.ti.com/lsds/ti/processors/dsp/overview.page">http://www.ti.com/lsds/ti/processors/dsp/overview.page</a>
</li>

<li>C674x Low Power DSP (stránky TI)<br />
<a href="http://www.ti.com/lsds/ti/processors/dsp/c6000_dsp/c674x/overview.page">http://www.ti.com/lsds/ti/processors/dsp/c6000_dsp/c674x/overview.page</a>
</li>

<li>TMS320C30 (stránky TI)<br />
<a href="http://www.ti.com/product/tms320c30">http://www.ti.com/product/tms320c30</a>
</li>

<li>TMS320C6722B<br />
<a href="http://www.ti.com/product/tms320c6722b/description">http://www.ti.com/product/tms320c6722b/description</a>
</li>

<li>Introduction to DSP<br />
<a href="http://www.ti.com/lit/wp/spry281/spry281.pdf">http://www.ti.com/lit/wp/spry281/spry281.pdf</a>
</li>

<li>The Evolution of TMS (Family of DSPs)<br />
<a href="http://www.slideshare.net/moto_modx/theevo1">http://www.slideshare.net/moto_modx/theevo1</a>
</li>

<li>Datasheet k TMS32010<br />
<a href="http://www.datasheetarchive.com/dlmain/49326c32a52050140abffe6f0ac4894aa09889/M/TMS32010">http://www.datasheetarchive.com/dlmain/49326c32a52050140abffe6f0ac4894aa09889/M/TMS32010</a>
</li>

<li>1979: Single Chip Digital Signal Processor Introduced<br />
<a href="http://www.computerhistory.org/siliconengine/single-chip-digital-signal-processor-introduced/">http://www.computerhistory.org/siliconengine/single-chip-digital-signal-processor-introduced/</a>
</li>

<li>The TMS32010. The DSP chip that changed the destiny of a semiconductor giant<br />
<a href="http://www.tihaa.org/historian/TMS32010-12.pdf">http://www.tihaa.org/historian/TMS32010-12.pdf</a>
</li>

<li>Texas Instruments TMS320 (Wikipedia)<br />
<a href="https://en.wikipedia.org/wiki/Texas_Instruments_TMS320">https://en.wikipedia.org/wiki/Texas_Instruments_TMS320</a>
</li>

<li>Great Microprocessors of the Past and Present: Part IX: Signetics 8x300, Early cambrian DSP ancestor (1978):<br />
<a href="http://www.cpushack.com/CPU/cpu2.html#Sec2Part9">http://www.cpushack.com/CPU/cpu2.html#Sec2Part9</a>
</li>

<li>Great Microprocessors of the Past and Present (V 13.4.0)<br />
<a href="http://jbayko.sasktelwebsite.net/cpu.html">http://jbayko.sasktelwebsite.net/cpu.html</a>
</li>

<li>Introduction to DSP - DSP processors:<br />
<a href="http://www.bores.com/courses/intro/chips/index.htm">http://www.bores.com/courses/intro/chips/index.htm</a>
</li>

<li>The Scientist and Engineer's Guide to Digital Signal Processing:<br />
<a href="http://www.dspguide.com/">http://www.dspguide.com/</a>
</li>

<li>Digital signal processor (Wikipedia EN)<br />
<a href="http://en.wikipedia.org/wiki/Digital_signal_processor">http://en.wikipedia.org/wiki/Digital_signal_processor</a>
</li>

<li>Digitální signálový procesor (Wikipedia CZ)<br />
<a href="http://cs.wikipedia.org/wiki/Digitální_signálový_procesor">http://cs.wikipedia.org/wiki/Digitální_signálový_procesor</a>
</li>

<li>Digital Signal Processing FAQs<br />
<a href="http://dspguru.com/dsp/faqs">http://dspguru.com/dsp/faqs</a>
</li>

<li>Reprezentace numerických hodnot ve formátech FX a FP<br />
<a href="http://www.root.cz/clanky/fixed-point-arithmetic/">http://www.root.cz/clanky/fixed-point-arithmetic/</a>
</li>

<li>IEEE 754 a její příbuzenstvo: FP formáty<br />
<a href="http://www.root.cz/clanky/norma-ieee-754-a-pribuzni-formaty-plovouci-radove-tecky/">http://www.root.cz/clanky/norma-ieee-754-a-pribuzni-formaty-plovouci-radove-tecky/</a>
</li>

<li>Čtyři základní způsoby uložení čísel pomocí FX formátů<br />
<a href="http://www.root.cz/clanky/binarni-reprezentace-numerickych-hodnot-v-fx-formatu/">http://www.root.cz/clanky/binarni-reprezentace-numerickych-hodnot-v-fx-formatu/</a>
</li>

<li>Základní aritmetické operace prováděné v FX formátu<br />
<a href="http://www.root.cz/clanky/zakladni-aritmeticke-operace-provadene-ve-formatu-fx/">http://www.root.cz/clanky/zakladni-aritmeticke-operace-provadene-ve-formatu-fx/</a>
</li>

<li>Aritmetické operace s hodnotami uloženými ve formátu FP<br />
<a href="http://www.root.cz/clanky/aritmeticke-operace-s-hodnotami-ve-formatu-plovouci-radove-carky/">http://www.root.cz/clanky/aritmeticke-operace-s-hodnotami-ve-formatu-plovouci-radove-carky/</a>
</li>

<li>FIR Filter FAQ<br />
<a href="http://dspguru.com/dsp/faqs/fir">http://dspguru.com/dsp/faqs/fir</a>
</li>

<li>Finite impulse response (Wikipedia)<br />
<a href="http://en.wikipedia.org/wiki/Finite_impulse_response">http://en.wikipedia.org/wiki/Finite_impulse_response</a>
</li>

<li>DSPRelated<br />
<a href="http://www.dsprelated.com/">http://www.dsprelated.com/</a>
</li>

<li>Addressing mode (Wikipedia)<br />
<a href="https://en.wikipedia.org/wiki/Addressing_mode">https://en.wikipedia.org/wiki/Addressing_mode</a>
</li>

<li>Orthogonal instruction set<br />
<a href="https://en.wikipedia.org/wiki/Orthogonal_instruction_set">https://en.wikipedia.org/wiki/Orthogonal_instruction_set</a>
</li>

<li>TI 16-bit and 32-bit microcontrollers<br />
<a href="http://www.ti.com/lsds/ti/microcontrollers_16-bit_32-bit/overview.page">http://www.ti.com/lsds/ti/microcontrollers_16-bit_32-bit/overview.page</a>
</li>

<li>TMS 32010 Assembly Language Programmer's Guide (kniha na Amazonu)<br />
<a href="https://www.amazon.com/32010-Assembly-Language-Programmers-Guide/dp/0904047423">https://www.amazon.com/32010-Assembly-Language-Programmers-Guide/dp/0904047423</a>
</li>

<li>COSC2425: PC Architecture and Machine Language, PC Assembly Language<br />
<a href="http://www.austincc.edu/rblack/courses/COSC2425/index.html">http://www.austincc.edu/rblack/courses/COSC2425/index.html</a>
</li>

</ol>



<p></p><p></p>
<p><small>Autor: <a href="http://www.fit.vutbr.cz/~tisnovpa">Pavel Tišnovský</a> &nbsp; 2017</small></p>
</body>
</html>

