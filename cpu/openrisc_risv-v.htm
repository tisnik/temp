<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
        "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html>
<head>
<title>Otevřené RISCové architektury OpenRISC a RISC-V</title>
<meta name="Author" content="Pavel Tisnovsky" />
<meta name="Generator" content="vim" />
<meta http-equiv="content-type" content="text/html; charset=utf-8" />
<style type="text/css">
         body {color:#000000; background:#ffffff;}
         h1  {font-family: arial, helvetica, sans-serif; color:#ffffff; background-color:#c00000; text-align:center; padding-left:1em}
         h2  {font-family: arial, helvetica, sans-serif; color:#ffffff; background-color:#0000c0; padding-left:1em; text-align:left}
         h3  {font-family: arial, helvetica, sans-serif; color:#000000; background-color:#c0c0c0; padding-left:1em; text-align:left}
         h4  {font-family: arial, helvetica, sans-serif; color:#000000; background-color:#e0e0e0; padding-left:1em; text-align:left}
         a   {font-family: arial, helvetica, sans-serif;}
         li  {font-family: arial, helvetica, sans-serif; color:#000000; text-align:justify; width:450px;}
         ol  {font-family: arial, helvetica, sans-serif; color:#000000; text-align:justify; width:450px;}
         ul  {font-family: arial, helvetica, sans-serif; color:#000000; text-align:justify; width:450px;}
         p   {font-family: arial, helvetica, sans-serif; color:#000000; text-align:justify;}
         pre {background:#e0e0e0}
</style>
</head>

<body>

<h1>Otevřené RISCové architektury OpenRISC a RISC-V</h1>

<h3>Pavel Tišnovský</h3>

<p></p>

<h1>Úvodník</h1>

<p>Ve světě open-source hardware (OSH) se již poměrně dlouho rozvíjí dva velmi zajímavé projekty. Jedná se o &bdquo;otevřené&ldquo; RISCové architektury nazvané OpenRISC a RISC-V. Dnes se seznámíme jak s&nbsp;prvním zmíněným projektem používajícím licence GPL a LGPL, tak i s&nbsp;projektem RISC-V, který je z&nbsp;hlediska designu mnohem promyšlenější.</p>



<h2>Obsah</h2>

<p><a href="#k01">1. Otevřené RISCové architektury OpenRISC a RISC-V</a></p>
<p><a href="#k02">2. Instrukční sada: základ specifikace mikroprocesorů</a></p>
<p><a href="#k03">3. Společný ideový předek projektů OpenRISC i RISC-V: architektura MIPS</a></p>
<p><a href="#k04">4. Programátorský model a instrukční sada mikroprocesorů s&nbsp;architekturou MIPS I</a></p>
<p><a href="#k05">5. Projekt OpenRISC</a></p>
<p><a href="#k06">6. Programátorský model OpenRISC</a></p>
<p><a href="#k07">7. Instrukční sady použité v&nbsp;projektu OpenRISC</a></p>
<p><a href="#k08">8. ORBIS32: OpenRISC Basic Instruction Set</a></p>
<p><a href="#k09">9. Projekt RISC-V: budoucnost čistě RISCových čipů?</a></p>
<p><a href="#k10">10. Instrukční sady použité v&nbsp;projektu RISC-V</a></p>
<p><a href="#k11">11. Nejdůležitější rozdíly RISC-V oproti architektuře MIPS a OpenRISC</a></p>
<p><a href="#k12">12. Odkazy na Internetu</a></p>



<p><a name="k01"></a></p>
<h2 id="k01">1. Otevřené RISCové architektury OpenRISC a RISC-V</h2>

<p><i>&bdquo;It's called hardware because it's hard.&ldquo;</i></p>

<p>Myšlenky open source a s&nbsp;ním souvisejících licencí pravděpodobně není
nutné čtenářům serveru Root.cz podrobněji představovat a vysvětlovat. Zajímavé
ovšem je, že tyto myšlenky postupně pronikají i do dalších oblastí, například i
do světa hardware, kde se stále častěji mluví o <i>open-source hardware</i>,
neboli zkráceně o <i>OSH</i>. Ostatně právě otevřený hardware je jedním
z&nbsp;posledních dílů ve &bdquo;skládačce&ldquo; open source technologií,
protože k&nbsp;dispozici jsou jak propracované a úspěšné open source operační
systémy a vývojářské nástroje, tak i aplikace pro servery, kanceláře i
domácnosti (opět pravděpodobně není nutné zabíhat do podrobností). V&nbsp;rámci
<i>open-source hardware</i> vzniklo již poměrně velké množství designů různých
čipů. Například se jedná o grafické akcelerátory, reimplementace některých
populárních typů mikroprocesorů apod. Designem je zde skutečně myšlen zdrojový
kód, protože návrhy čipů se provádí většinou v&nbsp;nějakém HDL, například
v&nbsp;jazycích VHDL, Verilogu či Chiselu.</p>

<p>Zdrojový kód popisující zapojení jednotlivých modulů čipu (typicky na vyšší
úrovni, než jsou jednotlivá hradla či dokonce tranzistory) je pak možné použít
při jeho implementaci v&nbsp;FPGA či při návrhu masky skutečného zákaznického
integrovaného obvodu. Velmi zajímavou oblastí <i>OSH</i> je návrh
mikroprocesorů (popř.&nbsp;jejich instrukčních sad), protože
z&nbsp;<i>open-source hardware</i> mohou v&nbsp;této oblasti profitovat
prakticky všechny zúčastněné strany: uživatelé (ti mohou či budou moci použít
otevřenou platformu bez různých zadních vrátek), pracovníci ve výzkumu
překladačů či instrukčních sad a v&nbsp;neposlední řadě taktéž výrobci čipů,
protože licence některých open-source hardware mikroprocesorů umožňují jejich
použití v&nbsp;komerčních integrovaných obvodech (zatímco za použití
mikroprocesorových jader MIPS či ARM se musí platit, což evidentně
nepředstavuje problém pro větší společnosti typu nVidie, Samsungu, Qualcommu,
Texas Instruments apod., ovšem například pro startupy se může jednat o
nepřekonatelný problém, dtto pro školy &ndash; zde bude problém spíše
morální).</p>



<p><a name="k02"></a></p>
<h2 id="k02">2. Instrukční sada: základ specifikace mikroprocesorů</h2>

<p>V&nbsp;dnešním článku si ve stručnosti popíšeme dva projekty spadající právě
do oblasti <i>open-source hardware</i>. Tyto projekty byly vybrány především
z&nbsp;toho důvodu, že mají &ndash; samozřejmě podle názoru autora :-) &ndash;
poměrně velkou naději na úspěch a současně jsou tyto technologie vzájemně dobře
porovnatelné. Jedná se o projekt nazvaný jednoduše a výstižně <i>OpenRISC</i> a
taktéž o projekt s&nbsp;názvem <i>RISC-V</i>. Při popisu projektů
<i>OpenRISC</i> i <i>RISC-V</i> je zapotřebí zdůraznit, že se tyto projekty
vždy skládají z&nbsp;několika částí. Základem je specifikace instrukční sady
(<i>ISA &ndash; Instruction Set Architecture</i>), protože právě instrukční
sada určuje vlastnosti čipů a do značné míry může ovlivnit i způsob jejich
designu (například počet řezů pipeline, existenci branch delay slotů, nutnosti
použít víceportové paměti pro implementaci matice registrů atd.). Dále se pak
jedná o konkrétní designy mikroprocesorových jader; příkladem může být projekt
<i>OpenRISC 1200</i> či o návrh jádra <i>RISC-V Rocket</i>.</p> 

<p>Dnes se budeme zabývat především vlastnostmi instrukčních sad
specifikovaných v&nbsp;rámci projektů <i>OpenRISC</i> a <i>RISC-V</i>. Jak si
řekneme v&nbsp;navazujících kapitolách, má minimálně jedna z&nbsp;těchto dvou
architektur poměrně dobrou šanci na to, aby se stala základem pro RISCové
mikroprocesory nové generace, protože návrh její instrukční sady je postaven na
současných požadavcích a možnostech (důraz na čipy s&nbsp;mnoha jednoduchými
jádry). Co je možná ještě důležitější &ndash; tento návrh není zatížen žádnou
snahou o dosažení zpětné kompatibility s&nbsp;původními &ndash; dnes již
vlastně několik desítek let starými &ndash; instrukčními sadami. Evidentní je
to zejména při porovnání návrhu instrukční sady procesorů <i>RISC-V</i>
s&nbsp;instrukční sadou x86, ale paradoxně i s&nbsp;RISCových instrukčními
sadami mikroprocesorových architektur PowerPC, SPARC, MIPS či dokonce
architektury ARM. Navíc je každé rozhodnutí o struktuře instrukcí velmi
detailně popsáno společně se zmínkou o alternativním (tj.&nbsp;horším :-)
řešení, což je pravděpodobně světový unikát.</p>



<p><a name="k03"></a></p>
<h2 id="k03">3. Společný ideový předek projektů OpenRISC i RISC-V: architektura MIPS</h2>

<p>Vzhledem k&nbsp;tomu, že open-source hardware by měl být v&nbsp;ideálním
případě co nejjednodušší (aby šel syntetizovat i na levnějších FPGA atd.) a
současně i dostatečně výkonný, nebude pravděpodobně žádným překvapením, že se
při návrhu OHS procesorů jejich tvůrci uchýlili k&nbsp;implementaci základních
myšlenek architektury <i>RISC</i> neboli <i>Reduced Instruction Set Code</i>
(v&nbsp;některých případech se tato zkratka taktéž používala ve významu
<i>Reduced Instruction Set Computer</i>). Nutno podotknout, že význam této
zkratky je mnohdy chápán mylně: ve skutečnosti mají některé RISCové procesory
více instrukcí, než &bdquo;konkurenční&ldquo; procesory CISCové, ovšem RISCové
instrukce jsou obecně implementačně mnohem jednodušší a nevyžadují použití
mikroprogramového řadiče (kromě několika výjimek, to se však netýká dnes
popisovaných projektů). Zajímavé je, že jak v&nbsp;případě projektu
<i>OpenRISC</i>, tak i u projektu <i>RISC-V</i> můžeme najít jejich společného
ideového předka, kterým je architektura <i>MIPS (Microprocessor without
Interlocked Pipeline Stages)</i>.</p>

<p>Práce na návrhu architektury <i>MIPS</i> začala již v&nbsp;roce 1981, kdy
<i>John L.&nbsp;Hennessy</i> z&nbsp;univerzity ve Stanfordu spolu se svým týmem
navrhl koncept procesoru, v&nbsp;němž by se sice využívala pipeline
s&nbsp;poměrně velkým množstvím řezů (typicky pěti), ovšem zpracování části
instrukce v&nbsp;každém řezu by trvalo konstantní dobu, ideálně jeden hodinový
takt. To mj.&nbsp;znamenalo, že takový procesor nemohl obsahovat instrukce
s&nbsp;dlouhotrvajícími operacemi, například násobením a dělením. Tyto operace
by totiž zcela jistě trvaly déle než jeden hodinový takt, což by znamenalo
nutnost mít v&nbsp;procesoru rozvedeny signály pro pozastavení provádění
dalších instrukcí (interlock). Hennessy si uvědomil, že tyto signály rozváděné
po celém procesoru limitují maximální hodinovou frekvenci a proto jím navržený
procesor neobsahoval žádné dlouhotrvající instrukce, pouze jednoduché součty,
rozdíly a bitové operace. Navíc tento procesor &ndash; na rozdíl od mnoha
dalších procesorů s&nbsp;architekturou <i>RISC</i> &ndash; neobsahoval
registrová okna, protože Hennesy správně odhadl, že je výhodnější neomezovat
počet současně použitelných pracovních registrů, protože jejich efektivní
alokaci pro předávání parametrů lze ponechat na překladači.</p>

<p>Mikroprocesory patřící do této rodiny byly v&nbsp;minulosti použity jak u
výkonných grafických stanic firmy <i>SGI</i> i v&nbsp;některých
superpočítačích, tak i na zcela opačném segmentu trhu: v&nbsp;embedded
aplikacích, přehrávačích DVD, herních konzolích Nintendo 64, Sony PlayStation,
PlayStation 2 atd. Čínští výrobci elektronických zařízení mají svoji verzi MIPS
označovanou jako <i>Godson</i> popř.&nbsp;v&nbsp;anglicky mluvících zemích
<i>Dragon</i>. Důvod velké oblíbenosti mikroprocesorů postavených na jádru
<i>MIPS</i> spočívá především v&nbsp;možnosti propojení jádra mikroprocesoru
s&nbsp;dalšími obvody na jednom čipu, což je velmi často využíváno zejména
v&nbsp;embedded aplikacích. V&nbsp;praxi to znamená možnost mít celé zařízení
(například dekodér videa či router) umístěné na jednom jediném čipu a
programovat přitom na známé, výkonné a mnoha lety praxe odladěné architektuře.
Navíc je možné použít některé &bdquo;nadstavbové&ldquo; instrukční sady,
například v&nbsp;oblasti DSP, zpracování videa apod.</p>



<p><a name="k04"></a></p>
<h2 id="k04">4. Programátorský model a instrukční sada mikroprocesorů s&nbsp;architekturou MIPS I</h2>

<p>Poznámka: tato kapitola je zde uvedena kvůli kontextu, lze ji samozřejmě <a
href="#k05">bez problémů přeskočit</a>.</p>

<p>Programátorský model 32bitových procesorů s&nbsp;architekturou <i>MIPS</i>
je ve skutečnosti velmi jednoduchý. Programátoři mají k&nbsp;dispozici 32
pracovních registrů, z&nbsp;nichž každý má šířku 32 bitů. Navíc se při načítání
instrukcí z&nbsp;operační paměti používá čítač instrukcí (<i>PC &ndash; Program
Counter</i>), jehož obsah však není programátorům přímo přístupný; mění se
nepřímo operacemi skoku a volání subrutiny. První z&nbsp;pracovních registrů,
který je označovaný jménem <strong>r0</strong> nebo též přezdívkou
(<i>aliasem</i>) <strong>$zero</strong>, má speciální význam, protože obsahuje
vždy nulovou hodnotu, nezávisle na tom, jaká hodnota je do registru zapisována
(zápis však nebyl zakázán). Existence registru obsahujícího nulovou konstantu
umožnila zmenšit počet instrukcí v&nbsp;instrukční sadě. Dalším 31 pracovním
registrům sice nebyla při konstrukci mikroprocesoru přiřazena žádná určitá
funkce, ale vývojáři operačních systémů i překladačů vyšších programovacích
jazyků začali některým registrům přiřazovat zvláštní význam.</p>

<p>Pracovní registry s&nbsp;indexy 2 a 3 se používaly pro předání návratových
hodnot programovému kódu, který volal subrutinu. Aliasy těchto registrů byly
<strong>$v0</strong> a <strong>$v1</strong> (<strong>v</strong> &ndash;
<i>value</i>). Pracovní registry s&nbsp;indexy 4 až 7 se používaly pro předání
prvních čtyř argumentů volaným funkcím; z&nbsp;tohoto důvodu byla pro jejich
aliasy zvolena jména <strong>$a0</strong> až <strong>$a3</strong>
(<strong>a</strong> &ndash; <i>argument</i>). Pokud se do volané funkce
předávalo větší množství parametrů, mohly se použít i další pracovní registry,
nebo taktéž programově vytvořený zásobníkový rámec (<i>stack frame</i>),
k&nbsp;jehož adresaci se používaly pracovní registry číslo 29 (alias
<strong>$sp</strong> &ndash; <i>stack pointer</i>) a 30 (alias
<strong>$fp</strong> &ndash; <i>frame pointer</i>). Dalších osm pracovních
registrů s&nbsp;aliasy <strong>$s0</strong> až <strong>$s7</strong>
(<strong>s</strong> &ndash; <i>saved</i>) bylo vyhrazeno pro hodnoty, jejichž
hodnota by při návratu z&nbsp;volané subrutiny neměla být změněna.
V&nbsp;subrutině se tyto registry samozřejmě mohly používat, ovšem jejich
původní hodnoty se většinou v&nbsp;tomto případě ukládaly do aktivačního
záznamu subrutiny.</p>

<p>Deset pracovních registrů s&nbsp;aliasy <strong>$t0</strong> až
<strong>$t9</strong> mohla volaná subrutina využívat pro své vlastní účely,
typicky pro provádění aritmetických a logických operací. Hodnoty těchto
registrů tedy nemusely být zachovány při návratu ze subrutiny
(<strong>t</strong> &ndash; <i>temporary</i>). Zbylých šest pracovních registrů
mělo následující význam: <strong>$zero</strong> &ndash; nulová konstanta
v&nbsp;registru s&nbsp;indexem 0, registr <strong>$at</strong> používal
assembler při provádění pseudoinstrukcí (<i>assembler temporary</i>),
<strong>$k0</strong> a <strong>$k1</strong> jsou registry používané při volání
funkcí jádra (<i>kernel</i>), popř.&nbsp;při zpracování přerušení,
v&nbsp;registru s&nbsp;aliasem <strong>$gp</strong> byl uložen ukazatel na
globální data (<i>global pointer</i>) a konečně v&nbsp;registru
<strong>$ra</strong> byla uložena adresa zajišťující návrat ze subrutiny
(<i>return address</i>), protože mikroprocesory <i>MIPS</i> neobsahovaly
klasický zásobník s&nbsp;návratovými adresami.</p>

<p>Všechny instrukce mikroprocesorů <i>R2000</i> měly konstantní šířku 32bitů,
což mj.&nbsp;taktéž znamenalo, že instrukce byly v&nbsp;operační paměti vždy
zarovnány na násobek čtyř bajtů, takže každá instrukce byla načtena
v&nbsp;jediném strojovém taktu. Podle způsobu rozdělení bitových polí
v&nbsp;32bitovém slovu se instrukce dělily pouze do třech kategorií &ndash;
<i>I-type (Immediate)</i>, <i>J-type (Jump)</i> a <i>R-Type (register)</i>.</p>

<p>U prvního typu instrukcí (<i>I-type</i>) je přímo v&nbsp;instrukčním slovu
uložena šestnáctibitová konstanta chápaná podle konkrétní instrukce buď jako
šestnáctibitové slovo bez znaménka (0..65535) či šestnáctibitové slovo se
znaménkem (-32768..32767). Ve zbývajících šestnácti bitech byl uložen
šestibitový operační kód, pětibitový index zdrojového registru a taktéž
pětibitový index registru cílového:</p>

<pre>
  I-Type (immediate)
  ------------------------------------------------------------
  | 31  26     | 25  21 | 20  16 | 15                      0 |
  ------------------------------------------------------------
  | opcode (6) | rs (5) | rt (5) | offset/konstanta (16)     |
  ------------------------------------------------------------
</pre>

<p>Formát instrukcí typu <i>J (Jump)</i> je ještě jednodušší než formát
předchozí, protože za šestibitovým operačním kódem následuje pouze 26 bitů
tvořících adresu skoku (skutečná adresa se získá vynásobením konstanty čtyřmi,
resp.&nbsp;bitovým posuvem o dva bity doleva):</p>

<pre>
  J-Type (jump)
  ------------------------------------------------------------
  | 31  26     | 25                                        0 |
  ------------------------------------------------------------
  | opcode (6) | adresa (26)                                 |
  ------------------------------------------------------------
</pre>

<p>Poslední instrukční formát je využíván u aritmetických a logických
instrukcí, které používají takzvaný tříadresový kód, tj.&nbsp;instrukce je
provedena se dvěma operandy (zdrojovými registry) a do třetího registru je
uložen výsledek operace. Kromě operačního kódu jsou v&nbsp;instrukčním slovu
uloženy pětibitové indexy obou zdrojových registrů (<i>rs, rt</i>) i registru
cílového (<i>rd</i>), šestibitový kód operace a taktéž pětibitová hodnota
posunu (<i>shift</i>) použitá u bitových posunů a rotací:</p>

<pre>
  R-Type (register)
  ------------------------------------------------------------
  | 31  26     | 25  21 | 20  16 | 15  11 | 10  6 | 5      0 |
  ------------------------------------------------------------
  | opcode (6) | rs (5) | rt (5) | rd (5) | shift | operace  |
  ------------------------------------------------------------
</pre>

<p>Vlastní instrukční sada mikroprocesorů <i>R2000</i> se vyznačuje dvěma
zvláštnostmi. První z&nbsp;nich je absence registru příznaků (<i>flags</i>),
protože konstruktéři tohoto mikroprocesoru (zcela správně :-)) usoudili, že by
používání příznaků typu <i>zero</i>, <i>carry</i>, <i>overflow</i> atd. mohlo
vést ke vzniku konfliktů, kdy by na výsledek jedné instrukce čekala instrukce
další. Kvůli absenci příznaků jsou v&nbsp;instrukční sadě pouze dva podmíněné
skoky <strong>beq</strong> (<i>branch on equal</i>) a <strong>bne</strong>
(<i>branch on not equal</i>), při nichž se skok provede/neprovede na základě
porovnání obsahu dvou pracovních registrů, jejichž indexy jsou přímo součástí
instrukčního slova &ndash; jedná se tedy o instrukce <i>I-type</i>. Povšimněte
si, že díky existenci registru <strong>$zero</strong> se vlastně zadarmo
instrukční sada rozšiřuje o pseudoinstrukce <strong>bz</strong> (<i>branch on
zero</i>) a <strong>bnz</strong> (<i>branch on non zero</i>). Dále se použití
příznaků nahradilo logickými instrukcemi <strong>slt</strong> (<i>set on less
than</i>) a <strong>slti</strong> (<i>set on less than immediate</i>). To již
není tak skvělá myšlenka a v&nbsp;projektu <i>RISC-V</i> byla zavržena :-)</p>



<p><a name="k05"></a></p>
<h2 id="k05">5. Projekt OpenRISC</h2>

<p>Konečně se dostáváme k&nbsp;prvnímu projektu <i>open-source hardware</i>
mikroprocesoru, konkrétně k&nbsp;projektu s&nbsp;názvem <i>OpenRISC</i>.
V&nbsp;rámci tohoto projektu je zveřejněn design procesoru pod licencí LGPL,
případný firmware pak pod licencí GPL (což je docela dobrý kompromis mezi
zajištěním otevřenosti celé platformy a současně to umožňuje komerční využití,
i když ne v&nbsp;takové míře, jako u <i>RISC-V</i>). Projekt počítá jak
s&nbsp;možností implementace &bdquo;pouhých&ldquo; 32bitových čipů, tak i čipů
s&nbsp;64bitovými sběrnicemi a aritmeticko-logickou jednotkou. Navíc je možné
si při implementaci zvolit, zda bude mikroprocesor obsahovat i matematický
koprocesor (pro hodnoty s&nbsp;plovoucí řádovou čárkou typu float/single,
double či obojí) popř.&nbsp;je možné na čip s&nbsp;mikroprocesorem přidat i
koprocesor určený pro zpracování hodnot uložených v&nbsp;krátkých
vektorech.</p>

<p>V&nbsp;návrhu se počítá se čtyřřezovou pipeline (&bdquo;klasické
RISCové&ldquo; fáze IF, ID, EX, WB), kde se jednotlivé fáze různých instrukcí
samozřejmě mohou překrývat. Zajímavé je, že se počítá s&nbsp;existencí branch
delay slotu (provedení instrukce za skokem), což je další rozdíl
v&nbsp;porovnání s&nbsp;architekturou <i>RISC-V</i>. Celkový návrh
<i>OpenRISCu</i> působí dojmem, že na prvním místě byla snaha o navržení
open-source hardware za každou cenu, zatímco hlubší analýza některých
technických detailů se neprováděla (což ostatně zmiňuje i zakladatel projektu
<i>LowRisc</i> Alex Bradbury). Výsledek sice vůbec není špatný, ale
v&nbsp;porovnání s&nbsp;<i>RISC-V</i> je odlišný přístup k&nbsp;řešení celé
problematiky jasně patrný.</p>



<p><a name="k06"></a></p>
<h2 id="k06">6. Programátorský model OpenRISC</h2>

<p>Popišme si nyní programátorský model mikroprocesorů <i>OpenRISC</i>.
Podobně, jako tomu bylo u výše zmíněné architektury <i>MIPS</i>, i zde mají
programátoři k&nbsp;dispozici 16 či (častěji) 32 pracovních registrů o šířce 32
bitů popř.&nbsp;64 bitů. Registry jsou pojmenované <strong>r0</strong> až
<strong>r15</strong>. V&nbsp;následující tabulce jsou vypsány funkce
jednotlivých registrů, ovšem s&nbsp;tou poznámkou, že tyto funkce jsou založeny
pouze na konvenci (kromě prvního registru, který je konstantně nulový, opět viz
popis architektury <i>MIPS</i>):</p>

<table>
<tr><th>Registr(y)</th><th>Význam</th></tr>
<tr><td>r0</td><td>tento registr obsahuje konstantně nulu, díky němu lze zjednodušit instrukční sadu</td></tr>
<tr><td>r1</td><td>používá se jako ukazatel na vrchol zásobníku</td></tr>
<tr><td>r9</td><td>link registr, používá se pro uchování návratové adresy volající subrutiny</td></tr>
<tr><td>r11</td><td>return registr, používá se pro předání návratové hodnoty do volající subrutiny</td></tr>
<tr><td>r12</td><td>return registr, používá se pro předání návratové hodnoty do volající subrutiny</td></tr>
</table>

<p>Kromě těchto obecných registrů je ve specifikaci popsáno i několik registrů
se speciálními funkcemi (například registr s&nbsp;hodnotou časovače).
V&nbsp;kontextu programátorského modelu je z&nbsp;těchto registrů důležitý
především stavový registr obsahující mimo jiné i tyto tři jednobitové
příznaky:</p>

<table>
<tr><th>Příznak</th><th>Význam</th></tr>
<tr><td>carry</td><td>příznak přenosu při aritmetických operacích</td></tr>
<tr><td>overflow</td><td>příznak přetečení při aritmetických operacích (typ signed)</td></tr>
<tr><td>branch</td><td>příznak použitý pro implementaci podmíněných skoků</td></tr>
</table>

<p>Zajímavé je, že pro podmíněné skoky lze přímo využít jen příznak
<strong>branch</strong> (označovaný i jako <strong>F</strong>). Ten je
nastavován některou instrukcí pro porovnání dvou registrů, takže podmíněný skok
je v&nbsp;praxi implementován vždy dvěma instrukcemi.</p>



<p><a name="k07"></a></p>
<h2 id="k07">7. Instrukční sady použité v&nbsp;projektu OpenRISC</h2>

<p>Vzhledem k&nbsp;tomu, že se předpokládá použití mikroprocesorových jader
s&nbsp;architekturou <i>OpenRISC</i> v&nbsp;různých zařízeních, od jednodušších
řídicích systémů přes zpracování signálů až například po servery, je instrukční
sada navržena modulárně. V&nbsp;současnosti existuje pět základních
&bdquo;sad&ldquo; instrukcí s&nbsp;předpokladem, že další sady bude možné
navrhnout a implementovat v&nbsp;budoucnosti. Jediné, s&nbsp;čím se
v&nbsp;architektuře <i>OpenRISC</i> přímo nepočítá, je podpora instrukcí
proměnné délky, tj.&nbsp;obdoby sad <i>Thumb</i> známých z&nbsp;konkurenční
architektury <i>ARM</i>. V&nbsp;následující tabulce je vypsáno všech pět
prozatím oficiálně popsaných sad instrukcí architektury <i>OpenRISC</i>:</p>

<table>
<tr><th>#</th><th>Zkratka</th><th>Celé jméno</th><th>Stručný popis</th></tr>
<tr><td>1</td><td>ORBIS32</td><td>OpenRISC Basic Instruction Set</td><td>zpracování 32bitových operandů, skoky, podmínky, bitové operace</td></tr>
<tr><td>2</td><td>ORBIS64</td><td>OpenRISC Basic Instruction Set</td><td>rozšíření na 64bitové operandy</td></tr>
<tr><td>3</td><td>ORFPX32</td><td>OpenRISC Floating Point eXtension</td><td>operace s&nbsp;numerickými hodnotami typu float/single (jednoduchá přesnost)</td></tr>
<tr><td>4</td><td>ORFPX64</td><td>OpenRISC Floating Point eXtension</td><td>operace s&nbsp;numerickými hodnotami typu double (dvojitá přesnost)</td></tr>
<tr><td>5</td><td>ORVDX64</td><td>OpenRISC Vector/DSP eXtension</td><td>zpracování hodnot uložených v&nbsp;64bitových vektorech</td></tr>
</table>

<p>Pro vytvoření reálně pracujícího mikroprocesoru postačuje implementovat
pouze první sadu, tj.&nbsp;<strong>ORBIS32</strong>, samozřejmě s&nbsp;tím
omezením, že zpracování 64bitových celých čísel či reálných čísel typu single a
double bude prováděno softwarově (za pomoci subrutin). Vlastnostmi této
instrukční sady se budeme zabývat v&nbsp;navazující kapitole.</p>



<p><a name="k08"></a></p>
<h2 id="k08">8. ORBIS32: OpenRISC Basic Instruction Set</h2>

<p>Základní instrukční sada <strong>ORBIS32</strong> se v&nbsp;několika
ohledech podobá instrukční sadě mikroprocesorů <i>MIPS</i>. I zde totiž najdeme
instrukce s&nbsp;konstantní šířkou 32bitů, které jsou v&nbsp;paměti vždy
zarovnány na adresu dělitelnou čtyřmi. Díky tomu se u skoků nemusí specifikovat
nejnižší dva bity adresy či offsetu, neboť tyto bity jsou vždy nulové. Tak,
jako je tomu u <i>MIPS</i>, i zde mají instrukce tři formáty. První formát se
označuje písmenem <strong>R</strong> a používá se pro většinu aritmetických,
logických a porovnávacích operací prováděných se dvěma zdrojovými registry a
jedním registrem cílovým. Další formát se jmenuje <strong>I</strong> a používá
se pro instrukce, v&nbsp;nichž se pracuje se dvěma registry (zdrojový+cílový) a
šestnáctibitovou konstantou. Třetí formát se jmenuje <strong>J</strong> a
používá se u skoků, neboť součástí instrukčního slova je 26bitová konstanta.
Pokud vám názvy <strong>R</strong>, <strong>I</strong> a <strong>J</strong>
připadají povědomé, je to díky tomu, že jsme se o nich zmiňovali <a
href="#k04">ve čtvrté kapitole</a> v&nbsp;souvislosti s&nbsp;architekturou
<i>MIPS</i>.</p>

<p>Vzhledem k&nbsp;tomu, že všechny aritmetické a logické operace pracují
s&nbsp;hodnotami uloženými v&nbsp;registrech, je množina instrukcí pro přesuny
dat do a z&nbsp;paměti poměrně malá. <i>OpenRISC</i> podporuje instrukce typu
<strong>load</strong> a <strong>store</strong>, které mohou zpracovávat bajty,
16bitová slova či 32bitová slova. Při načítání bajtů a 16bitových slov se
provádí rozšíření na plných 32 bitů se znaménkem (doplnění podle nejvyššího
bitu načítané hodnoty) či bez znaménka (doplnění nul). To je v&nbsp;mnoha
ohledech praktické, neboť i ty nejmodernější 64bitové mikroprocesory mnohdy
tráví většinu času zpracováním řetězců.</p>

<p>Mezi aritmetickými instrukcemi najdeme například sčítání s&nbsp;carry či bez
carry, násobení a dělení (se znaménkem či bez znaménka), operace typu
&bdquo;multiply and accumulate&ldquo; a &bdquo;multiply and subtract&ldquo; a
dokonce instrukce <strong>ff1</strong> (find first 1) a <strong>fl1</strong>
(find last 1). Už na tomto krátkém výčtu je patrné, že instrukční sada je
poměrně rozsáhlá a implementace &bdquo;na křemíku&ldquo; patřičně komplikovaná
(měřeno plochou čipu).</p>

<p>Za zmínku stojí taktéž instrukce začínající prefixem <strong>sf</strong>.
Tyto instrukce nastavují příznakový bit <strong>branch/F</strong> na základě
výsledku porovnání dvou registrů či porovnání registru s&nbsp;šestnáctibitovou
konstantou. Hodnota příznakového bitu je následně využita v&nbsp;podmíněném
skoku. Příkladem může být instrukce <strong>sfeq</strong> nastavující
<strong>F&larr;1</strong> jen tehdy, pokud mají oba registry shodnou hodnotu.
Nezapomeňme navíc na registr <strong>r0</strong> s&nbsp;&bdquo;trvalou
nulou&ldquo;, díky jehož existenci automaticky získáváme instrukce
<strong>sfzero</strong>. Alternativou k&nbsp;<strong>sfeq</strong> je instrukce
<strong>sfeqi</strong> pro porovnání registru s&nbsp;konstantou. Existují i
další alternativy, kde se namísto &bdquo;eq&ldquo; používá &bdquo;gt&ldquo;
(větší než), &bdquo;ge&ldquo; (větší nebo rovno) atd.</p>

<p>Za zmínku stojí taktéž skoky:</p>

<table>
<tr><th>Instrukce</th><th>Význam</th></tr>
<tr><td>j</td><td>skok na adresu PC+konstanta</td></tr>
<tr><td>jal</td><td>skok na adresu PC+konstanta, návratová adresa se uloží do registru r9</td></tr>
<tr><td>jr</td><td>skok na adresu uloženou ve specifikovaném registru</td></tr>
<tr><td>jalr</td><td>kombinace jal+jr (skok na adresu v&nbsp;registru, návratová adresa &rarr; r9)</td></tr>
<tr><td>bf</td><td>skok na PC+konstanta pokud je <strong>F</strong> nastaven</td></tr>
<tr><td>bnf</td><td>skok na PC+konstanta pokud je <strong>F</strong> vynulován</td></tr>
</table>

<p>Poslední instrukcí, o níž se zmíníme, je instrukce <strong>cmov</strong>
používající taktéž tříadresový kód (indexy tří registrů). Tato instrukce může
v&nbsp;některých případech nahradit podmíněné skoky:</p>

<ol>
<li>Pokud je F==1, proveď <strong>mov D,A</strong></li>
<li>Pokud je F==0, proveď <strong>mov D,B</strong></li>
</ol>



<p><a name="k09"></a></p>
<h2 id="k09">9. Projekt RISC-V: budoucnost čistě RISCových čipů?</h2>

<p>Druhým projektem, o němž se dnes alespoň stručně zmíníme, je projekt nazvaný
<i>RISC-V</i>. Cílem tohoto projektu bylo navrhnout zcela novou instrukční sadu
použitelnou ve všech typech aplikací, tj.&nbsp;jak v&nbsp;open-source hardware
projektech, tak i v&nbsp;komerčních čipech. Z&nbsp;tohoto důvodu byla zvolena
BSD Licence a nikoli dvojice GPL+LGPL tak, jako tomu je u projektu
<i>OpenRISC</i>. V&nbsp;rámci <i>RISC-V</i> se počítá s&nbsp;32bitovými,
64bitovými a v&nbsp;budoucnu dokonce se 128bitovými čipy, přičemž specifikace
je psána takovým způsobem, že předpokládá všechny možnosti. Návrh <i>RISC-V</i>
je velmi čistý a jednoduchý. To se týká jak formátu instrukcí (indexy registrů
jsou vždy na stejném místě, což zjednodušuje dekodér), tak i samotné instrukční
sady (čistý RISC v&nbsp;původním významu). Čistota návrhu se týká i různých
maličkostí; například způsobu uložení konstant v&nbsp;instrukčním slovu,
způsobu řešení dělení nulou u instrukcí typu <strong>div</strong> a
<strong>rem</strong>, absence příznakových bitů apod.</p>

<p>Programátorský model procesorů <i>RISC-V</i> se v&nbsp;mnoha ohledech podobá
modelu procesorů <i>MIPS</i> i <i>OpenRISC</i>. I zde je k&nbsp;dispozici 32
registrů <strong>x0</strong> až <strong>x31</strong> o šířce 32, 64 či
alternativně 128 bitů, přičemž registr s&nbsp;indexem 0 (<strong>x0</strong>)
obsahuje konstantní nulu a registr <strong>x1</strong> se používá pro uložení
návratové adresy (link registr). Kromě toho je k&nbsp;dispozici i registr
<strong>PC</strong>. V&nbsp;případě implementace matematického koprocesoru se
sada registrů rozrůstá o registry <strong>f0</strong> až <strong>f31</strong>
doplněné o stavový registr <strong>fsr</strong>. Specifikace taktéž uvádí
několik speciálních registrů používaných ve funkci čítačů. Podrobnosti o této
problematice si řekneme příště.</p>



<p><a name="k10"></a></p>
<h2 id="k10">10. Instrukční sady použité v&nbsp;projektu RISC-V</h2>

<p>Podobně, jako je tomu u výše popsaného projektu <i>OpenRISC</i>, i
v&nbsp;čipech založených na architektuře <i>RISC-V</i> je možné použít několik
instrukčních sad. Díky návrhu kódování instrukcí není nutné provádět přepínání
mezi jednotlivými sadami způsobem, jaký znají například programátoři
mikroprocesorů s&nbsp;architekturou <i>ARM</i> (přepínání
A32&rarr;Thumb&rarr;A32 atd.). To, že je možné zcela libovolně mixovat
instrukce z&nbsp;různých sad, je velmi zajímavé a rozšiřitelné řešení.
V&nbsp;následující tabulce jsou zmíněna jména základních (oficiálních)
instrukčních sad i dalších rozšíření, ovšem s&nbsp;tím doplněním, že
v&nbsp;tabulce operačních kódů zbývá místo i na další &ndash; oficiální či
privátní &ndash; instrukce (což je jen dobře, že tvůrci
&bdquo;nezaplácali&ldquo; všechny operační kódy):</p>

<table>
<tr><th>Označení</th><th>Význam</th></tr>
<tr><td>&nbsp;</td><th>Oficiální sady instrukcí</th></tr>
<tr><td>I</td><td>aritmetické instrukce (32/64 bit), load/store, skoky</td></tr>
<tr><td>M</td><td>rozšíření o instrukce pro násobení a dělení</td></tr>
<tr><td>A</td><td>atomické operace typu read-modify-write (pro multicore)</td></tr>
<tr><td>F</td><td>operace s&nbsp;hodnotami typu float/single (jednoduchá přesnost)</td></tr>
<tr><td>D</td><td>operace s&nbsp;hodnotami typu double (dvojitá přesnost)</td></tr>
<tr><td>&nbsp;</td><th>Další rozšíření</th></tr>
<tr><td>Q</td><td>operace s&nbsp;hodnotami typu quad (čtyřnásobná přesnost)</td></tr>
<tr><td>L</td><td>decimální aritmetika</td></tr>
<tr><td>C</td><td>komprimované instrukce (viz poznámka pod tabulkou)</td></tr>
<tr><td>B</td><td>bitové operace</td></tr>
<tr><td>T</td><td>podpora pro transakční paměť</td></tr>
<tr><td>P</td><td>SIMD operace</td></tr>
</table>

<p>Poznámka: operační kódy instrukcí jsou konstruovány takovým způsobem, aby
bylo v&nbsp;budoucnu možné používat i instrukce proměnné délky, tj.&nbsp;jak
instrukce kratší než 32 bitů (obdoba <i>Thumb</i>), tak i například nějakou
variantu <i>VLIW</i>.</p>

<p>Poznámka<sup>2</sup>: prvních pět sad IMAFD se označuje symbolem
<strong>G</strong> znamenající univerzální mikroprocesor.</p>



<p><a name="k11"></a></p>
<h2 id="k11">11. Nejdůležitější rozdíly RISC-V oproti architektuře MIPS a OpenRISC</h2>

<p>Architektura <i>RISC-V</i> se v&nbsp;několika ohledech odlišuje jak od
architektury <i>MIPS</i>, tak i od <i>OpenRISC</i>. Asi nejvíce je to patrné u
podpory podmíněných skoků. Zatímco u <i>MIPS</i> existovaly jen dvě instrukce
pro podmíněné skoky (<strong>beq</strong>, <strong>bne</strong>) doplněné o
instrukce <strong>slt</strong> a <strong>slti</strong>), spoléhají se čipy
<i>OpenRISC</i> na porovnávací operace nastavující příznak <strong>F</strong>.
Naproti tomu se u architektury <i>RISC-V</i> příznaky nepoužívají vůbec a sada
podmíněných skoků byla doplněna na <strong>beq</strong>, <strong>bne</strong>,
<strong>blt</strong> a <strong>bge</strong>, přičemž další kombinace
(<strong>bgt</strong> apod.) vzniknou jednoduše prohozením obsahu prvního a
druhého registru. Opět nesmíme zapomenout na registr <strong>x0</strong>
s&nbsp;konstantní nulou, který umožňuje realizovat skoky typu
<strong>bz</strong> a <strong>bnz</strong>.</p>

<p>Liší se vlastní implementace skoků na čipu, protože <i>RISC-V</i> neobsahuje
branch delay slot a navíc se u skoků předpokládá, že na čipu bude implementován
statický a dynamický prediktor skoků. Statický prediktor bude u prozatím
neznámé skokové instrukce předpokládat, že skok směrem dozadu se provede a skok
dopředu nikoli, dynamický prediktor pak může vést přesnější statistiku.</p>

<p>Vzhledem k&nbsp;rozsáhlosti tohoto tématu se dalšími vlastnostmi
architektury <i>RISC-V</i> budeme zabývat příště.</p>



<p><a name="k12"></a></p>
<h2 id="k12">12. Odkazy na Internetu</h2>

<ol>

<li>Comparing four 32-bit soft processor cores<br />
<a href="http://www.eetimes.com/author.asp?section_id=14&doc_id=1286116">http://www.eetimes.com/author.asp?section_id=14&doc_id=1286116</a>
</li>

<li>RISC-V Instruction Set<br />
<a href="http://riscv.org/download.html#spec_compressed_isa">http://riscv.org/download.html#spec_compressed_isa</a>
</li>

<li>RISC-V Spike (ISA Simulator)<br />
<a href="http://riscv.org/download.html#isa-sim">http://riscv.org/download.html#isa-sim</a>
</li>

<li>RISC-V (Wikipedia)<br />
<a href="https://en.wikipedia.org/wiki/RISC-V">https://en.wikipedia.org/wiki/RISC-V</a>
</li>

<li>David Patterson (Wikipedia)<br />
<a href="https://en.wikipedia.org/wiki/David_Patterson_(computer_scientist)">https://en.wikipedia.org/wiki/David_Patterson_(computer_scientist)</a>
</li>

<li>OpenRISC (oficiální stránky)<br />
<a href="http://openrisc.io/">http://openrisc.io/</a>
</li>

<li>OpenRISC architecture<br />
<a href="http://openrisc.io/architecture.html">http://openrisc.io/architecture.html</a>
</li>

<li>Emulátor OpenRISC CPU v JavaScriptu<br />
<a href="http://s-macke.github.io/jor1k/demos/main.html">http://s-macke.github.io/jor1k/demos/main.html</a>
</li>

<li>OpenRISC (Wikipedia)<br />
<a href="https://en.wikipedia.org/wiki/OpenRISC">https://en.wikipedia.org/wiki/OpenRISC</a>
</li>

<li>OpenRISC - instrukce<br />
<a href="http://sourceware.org/cgen/gen-doc/openrisc-insn.html">http://sourceware.org/cgen/gen-doc/openrisc-insn.html</a>
</li>

<li>OpenRISC - slajdy z přednášky<br />
<a href="https://iis.ee.ethz.ch/~gmichi/asocd/lecturenotes/Lecture6.pdf">https://iis.ee.ethz.ch/~gmichi/asocd/lecturenotes/Lecture6.pdf</a>
</li>

<li>Maska mikroprocesoru RISC 1<br />
<a href="http://www.cs.berkeley.edu/~pattrsn/Arch/RISC1.jpg">http://www.cs.berkeley.edu/~pattrsn/Arch/RISC1.jpg</a>
</li>

<li>Maska mikroprocesoru RISC 2<br />
<a href="http://www.cs.berkeley.edu/~pattrsn/Arch/RISC2.jpg">http://www.cs.berkeley.edu/~pattrsn/Arch/RISC2.jpg</a>
</li>

<li>C.E. Sequin and D.A.Patterson: Design and Implementation of RISC I<br />
<a href="http://www.eecs.berkeley.edu/Pubs/TechRpts/1982/CSD-82-106.pdf">http://www.eecs.berkeley.edu/Pubs/TechRpts/1982/CSD-82-106.pdf</a>
</li>

<li>Berkeley RISC<br />
<a href="http://en.wikipedia.org/wiki/Berkeley_RISC">http://en.wikipedia.org/wiki/Berkeley_RISC</a>
</li>

<li>Great moments in microprocessor history<br />
<a href="http://www.ibm.com/developerworks/library/pa-microhist.html">http://www.ibm.com/developerworks/library/pa-microhist.html</a>
</li>

<li>Microprogram-Based Processors<br />
<a href="http://research.microsoft.com/en-us/um/people/gbell/Computer_Structures_Principles_and_Examples/csp0167.htm">http://research.microsoft.com/en-us/um/people/gbell/Computer_Structures_Principles_and_Examples/csp0167.htm</a>
</li>

<li>Great Microprocessors of the Past and Present<br />
<a href="http://www.cpushack.com/CPU/cpu1.html">http://www.cpushack.com/CPU/cpu1.html</a>
</li>

<li>A Brief History of Microprogramming<br />
<a href="http://www.cs.clemson.edu/~mark/uprog.html">http://www.cs.clemson.edu/~mark/uprog.html</a>
</li>

<li>What is RISC?<br />
<a href="http://www-cs-faculty.stanford.edu/~eroberts/courses/soco/projects/2000-01/risc/whatis/">http://www-cs-faculty.stanford.edu/~eroberts/courses/soco/projects/2000-01/risc/whatis/</a>
</li>

<li>RISC vs. CISC<br />
<a href="http://www-cs-faculty.stanford.edu/~eroberts/courses/soco/projects/2000-01/risc/risccisc/">http://www-cs-faculty.stanford.edu/~eroberts/courses/soco/projects/2000-01/risc/risccisc/</a>
</li>

<li>RISC and CISC definitions:<br />
<a href="http://www.cpushack.com/CPU/cpuAppendA.html">http://www.cpushack.com/CPU/cpuAppendA.html</a>
</li>

<li>FPGA<br />
<a href="https://cs.wikipedia.org/wiki/Programovateln%C3%A9_hradlov%C3%A9_pole">https://cs.wikipedia.org/wiki/Programovateln%C3%A9_hradlov%C3%A9_pole</a>
</li>

<li>The Evolution of RISC<br />
<a href="http://www.ibm.com/developerworks/library/pa-microhist.html#sidebar1">http://www.ibm.com/developerworks/library/pa-microhist.html#sidebar1</a>
</li>

<li>SPARC Processor Family Photo<br />
<a href="http://thenetworkisthecomputer.com/site/?p=243">http://thenetworkisthecomputer.com/site/?p=243</a>
</li>

<li>SPARC: Decades of Continuous Technical Innovation<br />
<a href="http://blogs.oracle.com/ontherecord/entry/sparc_decades_of_continuous_technical">http://blogs.oracle.com/ontherecord/entry/sparc_decades_of_continuous_technical</a>
</li>

<li>The SPARC processors<br />
<a href="http://www.top500.org/2007_overview_recent_supercomputers/sparc_processors">http://www.top500.org/2007_overview_recent_supercomputers/sparc_processors</a>
</li>

<li>Reduced instruction set computing (Wikipedia)<br />
<a href="http://en.wikipedia.org/wiki/Reduced_instruction_set_computer">http://en.wikipedia.org/wiki/Reduced_instruction_set_computer</a>
</li>

<li>MIPS architecture (Wikipedia)<br />
<a href="http://en.wikipedia.org/wiki/MIPS_architecture">http://en.wikipedia.org/wiki/MIPS_architecture</a>
</li>

<li>Very long instruction word (Wikipedia)<br />
<a href="http://en.wikipedia.org/wiki/Very_long_instruction_word">http://en.wikipedia.org/wiki/Very_long_instruction_word</a>
</li>

<li>Classic RISC pipeline (Wikipedia)<br />
<a href="http://en.wikipedia.org/wiki/Classic_RISC_pipeline">http://en.wikipedia.org/wiki/Classic_RISC_pipeline</a>
</li>

<li>R2000 Microprocessor (Wikipedia)<br />
<a href="http://en.wikipedia.org/wiki/R2000_(microprocessor)">http://en.wikipedia.org/wiki/R2000_(microprocessor)</a>
</li>

<li>R3000 Microprocessor (Wikipedia)<br />
<a href="http://en.wikipedia.org/wiki/R3000">http://en.wikipedia.org/wiki/R3000</a>
</li>

<li>R4400 Microprocessor (Wikipedia)<br />
<a href="http://en.wikipedia.org/wiki/R4400">http://en.wikipedia.org/wiki/R4400</a>
</li>

<li>R8000 Microprocessor (Wikipedia)<br />
<a href="http://en.wikipedia.org/wiki/R8000">http://en.wikipedia.org/wiki/R8000</a>
</li>

<li>R10000 Microprocessor (Wikipedia)<br />
<a href="http://en.wikipedia.org/wiki/R10000">http://en.wikipedia.org/wiki/R10000</a>
</li>

<li>SPARC (Wikipedia)<br />
<a href="http://en.wikipedia.org/wiki/Sparc">http://en.wikipedia.org/wiki/Sparc</a>
</li>

<li>CPU design (Wikipedia)<br />
<a href="http://en.wikipedia.org/wiki/CPU_design">http://en.wikipedia.org/wiki/CPU_design</a>
</li>

<li>Control unit (Wikipedia)<br />
<a href="http://en.wikipedia.org/wiki/Control_unit">http://en.wikipedia.org/wiki/Control_unit</a>
</li>

</ol>



<p></p><p></p>
<p><small>Autor: <a href="http://www.fit.vutbr.cz/~tisnovpa">Pavel Tišnovský</a> &nbsp; 2015</small></p>
</body>
</html>

