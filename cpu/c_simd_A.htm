<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
        "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html>
<head>
<title>Instrukční sady SIMD a automatické vektorizace prováděné překladačem GCC (2)</title>
<meta name="Author" content="Pavel Tisnovsky" />
<meta name="Generator" content="vim" />
<meta http-equiv="content-type" content="text/html; charset=utf-8" />
<style type="text/css">
         body {color:#000000; background:#ffffff;}
         h1  {font-family: arial, helvetica, sans-serif; color:#ffffff; background-color:#c00000; text-align:center; padding-left:1em}
         h2  {font-family: arial, helvetica, sans-serif; color:#ffffff; background-color:#0000c0; padding-left:1em; text-align:left}
         h3  {font-family: arial, helvetica, sans-serif; color:#000000; background-color:#c0c0c0; padding-left:1em; text-align:left}
         h4  {font-family: arial, helvetica, sans-serif; color:#000000; background-color:#e0e0e0; padding-left:1em; text-align:left}
         a   {font-family: arial, helvetica, sans-serif;}
         li  {font-family: arial, helvetica, sans-serif; color:#000000; text-align:justify; width:450px;}
         ol  {font-family: arial, helvetica, sans-serif; color:#000000; text-align:justify; width:450px;}
         ul  {font-family: arial, helvetica, sans-serif; color:#000000; text-align:justify; width:450px;}
         p   {font-family: arial, helvetica, sans-serif; color:#000000; text-align:justify;}
         pre {background:#e0e0e0}
</style>
</head>

<body>

<h1>Instrukční sady SIMD a automatické vektorizace prováděné překladačem GCC (2)</h1>

<h3>Pavel Tišnovský</h3>

<p></p>

<h1>Úvodník</h1>

<p>Na úvodní článek o automatických vektorizacích prováděných překladači dnes navážeme. Opět se zaměříme na autovektorizace prováděné překladačem GCC, dnes si ale otestujeme poněkud komplikovanější funkce, které se mají optimalizovat.</p>



<h2>Obsah</h2>

<p><a href="#k01">1. Instrukční sady SIMD a automatické vektorizace prováděné překladačem GCC (2)</a></p>
<p><a href="#k02">2. První příklad: součet všech prvků v&nbsp;krátkém jednorozměrném poli se čtyřmi prvky</a></p>
<p><a href="#k03">3. Výsledek překladu se zákazem i povolením automatické vektorizace</a></p>
<p><a href="#k04">4. Automatická vektorizace po specifikaci přepínače <strong>-ffast-math</strong></a></p>
<p><a href="#k05">5. Vysvětlení postupu výpočtu</a></p>
<p><a href="#k06">6. Druhý příklad: součet všech prvků v&nbsp;krátkém jednorozměrném poli s&nbsp;osmi prvky</a></p>
<p><a href="#k07">7. Výsledné kódy vygenerované překladačem: &bdquo;skalární&ldquo; i &bdquo;vektorová&ldquo; varianta</a></p>
<p><a href="#k08">8. Třetí příklad: součet pole se 100 prvky</a></p>
<p><a href="#k09">9. Výsledné kódy vygenerované překladačem: &bdquo;skalární&ldquo; i &bdquo;vektorová&ldquo; varianta</a></p>
<p><a href="#k10">10. Čtvrtý příklad: vyhledání největšího prvku v&nbsp;poli</a></p>
<p><a href="#k11">11. Nevektorizovaná a vektorizovaná podoba výsledného kódu</a></p>
<p><a href="#k12">12. Vliv velikosti pole na výsledný vygenerovaný kód</a></p>
<p><a href="#k13">13. Jeden z&nbsp;nejdůležitějších algoritmů současnosti</a></p>
<p><a href="#k14">14. Pátý příklad: skalární součin dvou krátkých polí se čtyřmi prvky</a></p>
<p><a href="#k15">15. Nevektorizovaná a vektorizovaná podoba výsledného kódu</a></p>
<p><a href="#k16">16. Další možné optimalizace výpočtů skalárního součinu</a></p>
<p><a href="#k17">*** 17. Vysvětlení postupu výpočtu</a></p>
<p><a href="#k18">18. Repositář s&nbsp;demonstračními příklady</a></p>
<p><a href="#k19">19. Seznam všech předchozích částí tohoto seriálu a článků o SIMD instrukcích</a></p>
<p><a href="#k20">20. Odkazy na Internetu</a></p>



<p><a name="k01"></a></p>
<h2 id="k01">1. Instrukční sady SIMD a automatické vektorizace prováděné překladačem GCC (2)</h2>

<p><a
href="https://www.root.cz/clanky/instrukcni-sady-simd-a-automaticke-vektorizace-provadene-prekladacem-gcc/">V&nbsp;úvodním
článku</a> o technologii automatické vektorizace prováděné při překladu
zdrojových kódů do strojového kódu (nebo do assembleru) jsme si ukázali
základní techniky podporované překladačem GCC v&nbsp;případě, že se nějaká
operace provádí se všemi prvky pole (resp.&nbsp;v&nbsp;terminologii SSE
vektoru). Jednalo se například o operace vynulování všech prvků pole, přičtení
hodnoty ke všem prvkům pole nebo součet odpovídajících si prvků dvou polí.</p>

<p>Ovšem technologie automatické vektorizace dokáže v&nbsp;některých případech
korektně zpracovat i smyčky, ve kterých se provádí &bdquo;redukce&ldquo;
&ndash; součet všech prvků v&nbsp;poli, nalezení nejmenšího nebo naopak
největšího prvku v&nbsp;poli, ale i výpočet skalárního součinu atd. A právě na
způsob překladu takových zdrojových kódů se zaměříme dnes. Pro jednoduchost se
stále budeme omezovat na instrukce SSE.</p>



<p><a name="k02"></a></p>
<h2 id="k02">2. První příklad: součet všech prvků v&nbsp;krátkém jednorozměrném poli se čtyřmi prvky</h2>

<p>V&nbsp;dnešním prvním demonstračním příkladu si otestujeme, jakým způsobem
je možné vektorizovat zdrojový kód, ve kterém se sice zpracovávají všechny
prvky nějakého pole (resp.&nbsp;vektoru), ovšem výsledkem tohoto zpracování
bude jediná skalární hodnota vzniklá zkombinováním hodnot všech prvků.
Nejjednodušší takový příklad počítá sumu všech prvků pole a realizovat je ho
možné velmi snadno. Začneme tím nejmenším možným případem, který je ještě možné
vektorizovat &ndash; součtem všech (čtyř) prvků čtyřprvkového pole:</p>

<pre>
float <strong>array_sum_4</strong>(float *a) {
    #define SIZE 4
    int i;
    float result = 0.0;
    for (i=0; i&lt;SIZE; i++) {
        result += a[i];
    }
    return result;
}
</pre>

<p>Překladač tedy musí umět rozeznat, že se provádí nějaká forma algoritmu typu
<i>reduce</i> (někdy se setkáme s&nbsp;označením <i>reduction operator</i>,
které je přesnější).</p>



<p><a name="k03"></a></p>
<h2 id="k03">3. Výsledek překladu se zákazem i povolením automatické vektorizace</h2>

<p>Podívejme se nyní, jak bude vypadat výsledek překladu céčkovského kódu do
assembleru (resp.&nbsp;později do strojového kódu). První kód byl překladačem
vytvořen ve chvíli, kdy byly zakázány veškeré optimalizace (neuvedli jsme totiž
přepínač <strong>-O2</strong>). Povšimněte si, že je realizována počítaná
programová smyčka, ve které se volají &bdquo;skalární&ldquo; instrukce
<strong>MOVSS</strong> a <strong>ADDSS</strong>. Dokonce ani nedošlo
k&nbsp;pokusu o rozbalení této smyčky (což je dobře, když jsme optimalizace
zakázali):</p>

<pre>
<strong>array_sum</strong>:
        push    rbp
        mov     rbp, rsp
        mov     QWORD PTR [rbp-24], rdi
        pxor    xmm0, xmm0
        movss   DWORD PTR [rbp-8], xmm0
        mov     DWORD PTR [rbp-4], 0
        jmp     .L2
.L3:
        mov     eax, DWORD PTR [rbp-4]
        cdqe
        lea     rdx, [0+rax*4]
        mov     rax, QWORD PTR [rbp-24]
        add     rax, rdx
        movss   xmm0, DWORD PTR [rax]
        movss   xmm1, DWORD PTR [rbp-8]
        addss   xmm0, xmm1
        movss   DWORD PTR [rbp-8], xmm0
        add     DWORD PTR [rbp-4], 1
.L2:
        cmp     DWORD PTR [rbp-4], 3
        jle     .L3
        movss   xmm0, DWORD PTR [rbp-8]
        pop     rbp
        ret
</pre>

<p>Po povolení optimalizací, ovšem bez povolení automatické vektorizace, je
výsledek mnohem lepší. Namísto programové smyčky se pouze provede součet všech
prvků pole. Zajímavé je, že se stále začíná s&nbsp;nulovou hodnotou uloženou do
registru XMM0, i když by teoreticky bylo možné do tohoto registru uložit přímo
první prvek pole (vyžadujeme ovšem chování podle normy IEEEE 754):</p>

<pre>
<strong>array_sum</strong>:
        pxor    xmm0, xmm0
        addss   xmm0, DWORD PTR [rdi]
        addss   xmm0, DWORD PTR [rdi+4]
        addss   xmm0, DWORD PTR [rdi+8]
        addss   xmm0, DWORD PTR [rdi+12]
        ret
</pre>

<p>Zajímavé je, že i když automatickou vektorizaci povolíme, výsledný kód se
nijak nezmění a bude stále používat &bdquo;skalární&ldquo; instrukce:</p>

<pre>
<strong>array_sum</strong>:
        pxor    xmm0, xmm0
        addss   xmm0, DWORD PTR [rdi]
        addss   xmm0, DWORD PTR [rdi+4]
        addss   xmm0, DWORD PTR [rdi+8]
        addss   xmm0, DWORD PTR [rdi+12]
        ret
</pre>



<p><a name="k04"></a></p>
<h2 id="k04">4. Automatická vektorizace po specifikaci přepínače <strong>-ffast-math</strong></h2>

<p>Jak ovšem dosáhneme toho, aby se náš zdrojový kód přeložil do
&bdquo;vektorizované&ldquo; podoby? V&nbsp;tomto případě budeme muset použít
přepínač <strong>-ffast-math</strong>, který překladači umožní vložit do
výsledného kódu instrukce, jejichž chování nebude přesně odpovídat normě
IEEE754 (pořadí operací, práce s&nbsp;denormalizovanými hodnotami atd.), takže
může nastat situace, kdy ten stejný výpočet (na úrovni původního zdrojového
kódu) povede k&nbsp;nepatrně odlišným výsledkům. To nám ovšem mnohdy
nevadí.</p>

<p>Výsledná vektorizovaná podoba vypadá takto:</p>

<pre>
<strong>array_sum</strong>:
        movups  xmm0, XMMWORD PTR [rdi]
        movaps  xmm1, xmm0
        movhlps xmm1, xmm0
        addps   xmm1, xmm0
        movaps  xmm0, xmm1
        shufps  xmm0, xmm1, 85
        addps   xmm0, xmm1
        ret
</pre>



<p><a name="k05"></a></p>
<h2 id="k05">5. Vysvětlení postupu výpočtu</h2>

<p>Co vlastně výše uvedená sekvence instrukcí znamená? Zkusme si ji popsat
postupně, a to na vstupním vektoru obsahujícím hodnoty [1000, 100, 10, 1]
(schválně nepoužívám hodnoty 1, 2, 3, 4, protože jejich mezisoučty jsou
nejasné). Nejdříve se čtveřice hodnot [1000, 100, 10, 1] přesune do registru
XMM0 a posléze i do registru XMM1. Obsah obou registrů tedy bude vypadat
následovně:</p>

<pre>
XMM0: 00001000 00000100 00000010 00000001
XMM1: 00001000 00000100 00000010 00000001
</pre>

<p>Posléze se instrukcí <strong>MOVHLPS</strong> přenesou nejvyšší dva prvky
z&nbsp;registru XMM0 do spodních dvou prvků registru XMM1, takže obsah registrů
bude vypadat takto:</p>

<pre>
XMM0: 00001000 00000100 00000010 00000001
XMM1: 00001000 00000100 00001000 00000100
</pre>

<p>Po vektorovém součtu instrukcí <strong>ADDPS</strong> bude v&nbsp;registru
XMM1 uložen vektor s&nbsp;prvky [2000, 200, 1010, 101], tj.&nbsp;spodní dva
prvky již budou obsahovat dva mezisoučty (označme 101 jako první mezisoučet a
1010 jako mezisoučet druhý):</p>

<pre>
XMM0: 00001000 00000100 00000010 00000001
XMM1: 00002000 00000200 00001010 00000101
</pre>

<p>Instrukcemi <strong>MOVAPS XMM0, XMM1</strong> a <strong>SHUFPS xmm0, xmm1,
01010101</strong> se do registru XMM0 uloží prvky s&nbsp;indexem jedna
z&nbsp;registrů XMM0 a XMM1, tj.&nbsp;konkrétně druhý mezisoučet 1010.
V&nbsp;registru XMM1 je v&nbsp;horních prvcích uloženo smetí a v&nbsp;nejnižším
prvku pak stále máme první mezisoučet 101:</p>

<pre>
XMM0: 00001010 00001010 00001010 00001010
XMM1: 00002000 00000200 00001010 00000101
</pre>

<p>Poslední součet instrukcí <strong>ADDPS</strong> nám již dá v&nbsp;nejnižším
prvku vektoru XMM0 kýžený výsledek:</p>

<pre>
XMM0: 00003010 00001210 00002020 00001111
</pre>

<p><div class="rs-tip-major">Poznámka: zde by postačovalo použít instrukci
<strong>ADDSS</strong> a nikoli <strong>ADDPS</strong>.</div></p>

<p>Vše si můžeme otestovat tímto kódem (přeložitelným v&nbsp;Linuxu):</p>

<pre>
[bits 32]
&nbsp; 
%include "linux_macros.asm"
&nbsp; 
<i>;-----------------------------------------------------------------------------</i>
section .data
&nbsp; 
<strong>hex_message</strong>:
         times 8 db '?'
         db ' '
         hex_message_length equ $ - hex_message
&nbsp; 
align 16
<strong>sse_val_1</strong> dd 0x1, 0x10, 0x100, 0x1000
&nbsp;
<i>;-----------------------------------------------------------------------------</i>
section .bss
sse_tmp resb 16
&nbsp;
&nbsp;
<i>;-----------------------------------------------------------------------------</i>
section .text
        global _start                <i>; tento symbol ma byt dostupny i linkeru</i>
&nbsp;
<strong>_start</strong>:
        mov ebx, sse_val_1
        movaps xmm0, [ebx]           <i>; nacteni prvni hodnoty do registru XMM0</i>
&nbsp;
        movaps  xmm1, xmm0           <i>; xmm1 := xmm0</i>
        print_sse_reg_as_hex xmm0    <i>; tisk hodnoty registru XMM0</i>
        print_sse_reg_as_hex xmm1    <i>; tisk hodnoty registru XMM1</i>
&nbsp;
        movhlps xmm1, xmm0           <i>; přesun nejvyšších dvou prvků vektoru</i>
        print_sse_reg_as_hex xmm0    <i>; tisk hodnoty registru XMM0</i>
        print_sse_reg_as_hex xmm1    <i>; tisk hodnoty registru XMM1</i>
&nbsp;
        addps   xmm1, xmm0           <i>; vektorový součet</i>
        print_sse_reg_as_hex xmm0    <i>; tisk hodnoty registru XMM0</i>
        print_sse_reg_as_hex xmm1    <i>; tisk hodnoty registru XMM1</i>
&nbsp;
        movaps  xmm0, xmm1
        shufps  xmm0, xmm1, 85       <i>; proložení prvků vektorů</i>
        print_sse_reg_as_hex xmm0    <i>; tisk hodnoty registru XMM0</i>
        print_sse_reg_as_hex xmm1    <i>; tisk hodnoty registru XMM1</i>
&nbsp;
        addps   xmm0, xmm1           <i>; vektorový součet</i>
        print_sse_reg_as_hex xmm0    <i>; tisk hodnoty registru XMM0</i>
&nbsp;
        exit                         <i>; ukonceni procesu</i>
&nbsp;
&nbsp;
%include "hex2string.asm"
</pre>

<p><div class="rs-tip-major">Poznámka: pro jednoduchost jsem zde použil
hexadecimální hodnoty, které na způsobu výpočtu nic nemění.</div></p>



<p><a name="k06"></a></p>
<h2 id="k06">6. Druhý příklad: součet všech prvků v&nbsp;krátkém jednorozměrném poli s&nbsp;osmi prvky</h2>

<p>Zkusme si nyní celé pole, jehož prvky se sčítají, zvětšit ze čtyř prvků na
prvků osm. Tím donutíme překladač, aby součet provedl minimálně dvakrát,
protože do XMM registru je možné uložit maximálně čtyři prvky typu
<i>single/float</i>. Příklad je upraven pouze nepatrně &ndash; pozměnili jsme
konstantu <strong>SIZE</strong>:</p>

<pre>
float <strong>array_sum_8</strong>(float *a) {
    #define SIZE 8
    int i;
    float result = 0.0;
    for (i=0; i&lt;SIZE; i++) {
        result += a[i];
    }
    return result;
}
</pre>



<p><a name="k07"></a></p>
<h2 id="k07">7. Výsledné kódy vygenerované překladačem: &bdquo;skalární&ldquo; i &bdquo;vektorová&ldquo; varianta</h2>

<p>Opět se podívejme na výsledné sekvence instrukcí vygenerovaných překladačem.
V&nbsp;případě, že jsou optimalizace zakázány, je výsledkem (podle očekávání)
stále stejná neoptimalizovaná počítaná programová smyčka:</p>

<pre>
<strong>array_sum</strong>:
        push    rbp
        mov     rbp, rsp
        mov     QWORD PTR [rbp-24], rdi
        pxor    xmm0, xmm0
        movss   DWORD PTR [rbp-8], xmm0
        mov     DWORD PTR [rbp-4], 0
        jmp     .L2
.L3:
        mov     eax, DWORD PTR [rbp-4]
        cdqe
        lea     rdx, [0+rax*4]
        mov     rax, QWORD PTR [rbp-24]
        add     rax, rdx
        movss   xmm0, DWORD PTR [rax]
        movss   xmm1, DWORD PTR [rbp-8]
        addss   xmm0, xmm1
        movss   DWORD PTR [rbp-8], xmm0
        add     DWORD PTR [rbp-4], 1
.L2:
        cmp     DWORD PTR [rbp-4], 7
        jle     .L3
        movss   xmm0, DWORD PTR [rbp-8]
        pop     rbp
        ret
</pre>

<p>Při zapnutí optimalizací, ovšem bez použití autovektorizace, nyní získáme
počítanou smyčku; sice krátkou a efektivní, ale jedná se o smyčku:</p>

<pre>
<strong>array_sum</strong>:
        lea     rax, [rdi+32]
        pxor    xmm0, xmm0
.L2:
        addss   xmm0, DWORD PTR [rdi]
        add     rdi, 8
        addss   xmm0, DWORD PTR [rdi-4]
        cmp     rdi, rax
        jne     .L2
        ret
</pre>

<p>Ovšem při povolení automatické vektorizace a současně i výpočtů
neodpovídajících přesně normě IEEE 754 (&bdquo;rychlá matematika&ldquo;) je
výsledek mnohem lepší. Dostaneme vlastně podobný kód, jako u pole se čtyřmi
prvky, nyní ovšem hned na začátku proběhne součet prvku číslo 0 s&nbsp;prvkem
číslo 4, dále prvku číslo 1 s&nbsp;prvkem číslo 5 atd. &ndash; tedy první
mezisoučet, jehož výsledkem jsou čtyři částečné součty. A následnou sekvenci
instrukcí již známe:</p>

<pre>
<strong>array_sum</strong>:
        movups  xmm1, XMMWORD PTR [rdi+16]
        movups  xmm0, XMMWORD PTR [rdi]
        addps   xmm0, xmm1
        movaps  xmm1, xmm0
        movhlps xmm1, xmm0
        addps   xmm1, xmm0
        movaps  xmm0, xmm1
        shufps  xmm0, xmm1, 85
        addps   xmm0, xmm1
        ret
</pre>



<p><a name="k08"></a></p>
<h2 id="k08">8. Třetí příklad: součet pole se 100 prvky</h2>

<p>Naposledy se ještě podívejme na problematiku součtu prvků polí, tentokrát
pro rozsáhlé pole se sto prvky. Takový počet by již překladač měl donutit
k&nbsp;vygenerování programové smyčky (i když si dovedu představit situaci, kdy
bude vhodnější celý kód rozbalit). Naivní a nijak neoptimalizovaná funkce pro
součet prvků pole o délce 100 bude vypadat takto:</p>

<pre>
float <strong>array_sum_100</strong>(float *a) {
    #define SIZE 100
    int i;
    float result = 0.0;
    for (i=0; i&lt;SIZE; i++) {
        result += a[i];
    }
    return result;
}
</pre>



<p><a name="k09"></a></p>
<h2 id="k09">9. Výsledné kódy vygenerované překladačem: &bdquo;skalární&ldquo; i &bdquo;vektorová&ldquo; varianta</h2>

<p>Skalární, ovšem optimalizovaná varianta výpočtu, bude vypadat poněkud
zajímavě, protože z&nbsp;ní můžeme vyčíst, že se v&nbsp;jedné iteraci smyčky
provádí přičtení hodnoty dvou prvků. Smyčka je tedy částečně rozbalena. Taktéž
je užitečné, že se hodnota registru <strong>RDI</strong> (adresa prvku) zvyšuje
před provedením součtu, což sice poněkud komplikuje adresování, ale po součtu
již bude možné novou hodnotu porovnat s&nbsp;mezní hodnotou. Tím se vynechá
(překryje) čekání na výsledek přičtení osmičky k&nbsp;RDI:</p>

<pre>
<strong>array_sum100</strong>:
        lea     rax, [rdi+400]
        pxor    xmm0, xmm0
.L2:
        addss   xmm0, DWORD PTR [rdi]
        add     rdi, 8
        addss   xmm0, DWORD PTR [rdi-4]
        cmp     rdi, rax
        jne     .L2
        ret
</pre>

<p>Vektorová varianta je vlastně variací na známé téma, tentokrát je ovšem
akumulátor (výsledek celého součtu) uložen v&nbsp;registru XMM0 a vektorové
součty se provádí s&nbsp;registry XMM1 a XMM2:</p>

<pre>
<strong>array_sum100</strong>:
        lea     rax, [rdi+400]
        pxor    xmm0, xmm0
.L2:
        movups  xmm2, XMMWORD PTR [rdi]
        add     rdi, 16
        addps   xmm0, xmm2
        cmp     rax, rdi
        jne     .L2
        movaps  xmm1, xmm0
        movhlps xmm1, xmm0
        addps   xmm1, xmm0
        movaps  xmm0, xmm1
        shufps  xmm0, xmm1, 85
        addps   xmm0, xmm1
        ret
</pre>



<p><a name="k10"></a></p>
<h2 id="k10">10. Čtvrtý příklad: vyhledání největšího prvku v&nbsp;poli</h2>

<p>Další ukázkou operace typu <i>reduce</i> je vyhledání největšího prvku
v&nbsp;poli. To vlastně znamená opakované testování hodnoty prvků vůči
předchozí maximální hodnotě, takže bude zajímavé zjistit, zda i tento kód je
možné vektorizovat, resp.&nbsp;jestli to dokáže překladač GCC. Začneme opět tím
nejjednodušším možným případem: polem se čtyřmi prvky:</p>

<pre>
#include &lt;float.h&gt;
&nbsp;
float <strong>find_max_4</strong>(float *a) {
    #define SIZE 4
    int i;
    float max = FLT_MIN_EXP;
    for (i=0; i&lt;SIZE; i++) {
        if (a[i] &gt; max) {
            max = a[i];
        }
    }
    return max;
}
</pre>



<p><a name="k11"></a></p>
<h2 id="k11">11. Nevektorizovaná a vektorizovaná podoba výsledného kódu</h2>

<p>Podobně jako u předchozích demonstračních příkladů se i nyní podíváme na
výsledný kód vygenerovaný překladačem GCC. Nejprve je ukázána skalární varianta
založená na programové smyčce, ve které se volá &bdquo;skalární&ldquo;
instrukce <strong>MAXSS</strong>, s&nbsp;níž jsme se již setkali.</p>

<pre>
find_max_4:
        movss   xmm0, DWORD PTR .LC0[rip]
        lea     rax, [rdi+16]
.L2:
        movss   xmm1, DWORD PTR [rdi]
        add     rdi, 4
        maxss   xmm1, xmm0
        movaps  xmm0, xmm1
        cmp     rdi, rax
        jne     .L2
        ret
.LC0:
        .long   -1023803392
</pre>

<p>Optimalizovaná skalární varianta explicitně zavolá instrukci
<strong>MAXSS</strong> postupně pro všechny prvky pole. Jedná se tedy o
rozbalenou variantu programové smyčky, což je pochopitelně rychlejší
řešení:</p>

<pre>
find_max_4:
        movss   xmm0, DWORD PTR [rdi]
        movss   xmm1, DWORD PTR [rdi+8]
        maxss   xmm0, DWORD PTR [rdi+4]
        maxss   xmm1, DWORD PTR .LC0[rip]
        maxss   xmm0, DWORD PTR [rdi+12]
        maxss   xmm0, xmm1
        ret
.LC0:
        .long   -1023803392
</pre>

<p>A konečně se podívejme na vektorizovanou variantu. Povšimněte si, jak se
tato varianta podobá výpočtu součtu prvků čtyřprvkového pole &ndash; ovšem
pochopitelně se nyní namísto instrukce <strong>ADDPS</strong> volá instrukce
<strong>MAXPS</strong>:</p>

<pre>
find_max_4:
        movups  xmm0, XMMWORD PTR [rdi]
        movaps  xmm1, xmm0
        movhlps xmm1, xmm0
        maxps   xmm1, xmm0
        movaps  xmm0, xmm1
        shufps  xmm0, xmm1, 85
        maxps   xmm0, xmm1
        maxss   xmm0, DWORD PTR .LC0[rip]
        ret
.LC0:
        .long   -1023803392
</pre>

<p>Pro zajímavost si oba vektorizované výpočty porovnejme po jednotlivých
instrukcích, aby ještě více vynikla jejich podobnost:</p>

<pre>
součet všech prvků pole
movups  xmm0, XMMWORD PTR [rdi]  movups  xmm0, XMMWORD PTR [rdi]
movaps  xmm1, xmm0               movaps  xmm1, xmm0
movhlps xmm1, xmm0               movhlps xmm1, xmm0
addps   xmm1, xmm0               maxps   xmm1, xmm0
movaps  xmm0, xmm1               movaps  xmm0, xmm1
shufps  xmm0, xmm1, 85           shufps  xmm0, xmm1, 85
addps   xmm0, xmm1               maxps   xmm0, xmm1
ret                              maxss   xmm0, DWORD PTR .LC0[rip]
                                 ret
</pre>



<p><a name="k12"></a></p>
<h2 id="k12">12. Vliv velikosti pole na výsledný vygenerovaný kód</h2>

<p>Samozřejmě si otestujeme, jaký vliv bude mít velikost pole (vektoru) na
vygenerovaný strojový kód nebo assembler. Pro pole o počtu prvků osm dostaneme
následující výsledky.</p>

<p>Skalární varianta, ve které se už používá programová smyčka a v&nbsp;každé
iteraci se zpracují dva prvky pole:</p>

<pre>
<strong>find_max_8</strong>:
        movss   xmm0, DWORD PTR .LC0[rip]
        lea     rax, [rdi+32]
.L2:
        maxss   xmm0, DWORD PTR [rdi]
        add     rdi, 8
        maxss   xmm0, DWORD PTR [rdi-4]
        cmp     rdi, rax
        jne     .L2
        ret
.LC0:
        .long   -1023803392
</pre>

<p>Vektorová varianta, ve které překladač smyčku rozbalil, ovšem stále
potřebuje čtyři instrukce <strong>MAXPS</strong>:</p>

<pre>
<strong>find_max_8</strong>:
        movss   xmm0, DWORD PTR .LC1[rip]
        movups  xmm1, XMMWORD PTR [rdi]
        shufps  xmm0, xmm0, 0
        maxps   xmm1, xmm0
        movups  xmm0, XMMWORD PTR [rdi+16]
        maxps   xmm0, xmm1
        movaps  xmm1, xmm0
        movhlps xmm1, xmm0
        maxps   xmm1, xmm0
        movaps  xmm0, xmm1
        shufps  xmm0, xmm1, 85
        maxps   xmm0, xmm1
        ret
.LC1:
        .long   -1023803392
</pre>

<p>Následuje výsledek překladu s&nbsp;automatickou vektorizací pro pole, které
obsahuje 100 prvků. To již pochopitelně vede k&nbsp;vygenerování programové
smyčky namísto jejího rozbalení. Nicméně stále se v&nbsp;jedné iteraci nalezne
maximální hodnota čtyř nových prvků a porovná se s&nbsp;průběžně
&bdquo;akumulovanou&ldquo; maximální hodnotou:</p>

<pre>
<strong>find_max_100</strong>:
        movss   xmm0, DWORD PTR .LC1[rip]
        lea     rax, [rdi+400]
        shufps  xmm0, xmm0, 0
.L2:
        movups  xmm2, XMMWORD PTR [rdi]
        add     rdi, 16
        maxps   xmm0, xmm2
        cmp     rax, rdi
        jne     .L2
        movaps  xmm1, xmm0
        movhlps xmm1, xmm0
        maxps   xmm1, xmm0
        movaps  xmm0, xmm1
        shufps  xmm0, xmm1, 85
        maxps   xmm0, xmm1
        ret
.LC1:
        .long   -1023803392
</pre>



<p><a name="k13"></a></p>
<h2 id="k13">13. Jeden z&nbsp;nejdůležitějších algoritmů současnosti</h2>

<p>S&nbsp;rozvojem neuronových sítí a umělé inteligence (ale nejenom zde) se
začal masivně využívat známý algoritmus pro výpočet skalárního součinu (<i>dot
product</i>, <i>scalar product</i>). Tento algoritmus se používá v&nbsp;oblasti
velkých jazykových modelů (LLM) pro zjišťování podobnosti dlouhých vektorů
s&nbsp;numerickými hodnotami (<i>vector similarity</i>). Kromě klasického
skalárního součinu se v&nbsp;této oblasti používá i tzv.&nbsp;<i>cosinus
similarity</i>, což je varianta skalárního součinu, v&nbsp;níž nezáleží na
délce vektorů, ale pouze na jejich vzájemné orientaci (výpočet je tedy doplněn
o normalizaci vektorů). A toto porovnávání vektorů se v&nbsp;LLM provádí
neustále a většinou je optimalizováno a výpočty běží na GPU.</p>

<p>To však není zdaleka vše. Pokud se zaměříme na oblast klasických neuronových
sítí (<i>NN &ndash; neural networks</i>), zjistíme, že se tyto sítě skládají
z&nbsp;takzvaných <i>perceptronů</i>, což je vlastně značně zjednodušený model
neuronu. A na vstup perceptronu se přivádí nějaké množství numerických vstupů.
Každý z&nbsp;těchto vstupů je váhován, tj.&nbsp;vynásoben určitou konstantou a
výsledky tohoto váhování jsou nakonec sečteny. Když se ovšem nad touto operací
zamyslíme, zjistíme, že se vlastně nejedná o nic jiného, než o aplikaci výpočtu
skalárního součinu. První z&nbsp;vektorů, který do tohoto součinu vstupuje jako
operand, jsou vstupy do neuronu, druhým vektorem je pak vektor vah, které si
neuron zapamatoval. A samotný trénink neuronové sítě vlastně není nic jiného,
než rekonfigurace těchto vah &ndash; vektorů:</p>

<img src="https://i.iinfo.cz/images/329/torch-nn1-1.png" class="image-312261" alt="" width="459" height="140">
<p><i>Obrázek 1: Idealizovaný model neuronu.</i></p>

<img src="https://i.iinfo.cz/images/329/torch-nn1-2.png" class="image-312262" alt="" width="465" height="145">
<p><i>Obrázek 2: Idealizovaný model neuronu s biasem.</i></p>

<p><div class="rs-tip-major">Poznámka: neuronovými sítěmi tohoto typu jsme se
podrobněji zabývali v&nbsp;seriálu o knihovně <i>Scilik-learn</i>. Odkazy na
příslušné články naleznete <a href="#k19">v&nbsp;předposlední poslední
kapitole</a>.</div></p>



<p><a name="k14"></a></p>
<h2 id="k14">14. Pátý příklad: skalární součin dvou krátkých polí se čtyřmi prvky</h2>

<p>V&nbsp;dnešním pátém ukázkovém příkladu je realizován algoritmus pro výpočet
skalárního součinu dvou čtyřprvkových vektorů. Funkce
<strong>dot_product_4</strong> je přitom napsána zcela naivním způsobem, bez
jakékoli snahy o její optimalizaci na úrovni céčkového kódu:</p>

<pre>
float <strong>dot_product_4</strong>(float *a, float *b) {
    #define SIZE 4
    int i;
    float result = 0.0;
    for (i=0; i&lt;SIZE; i++) {
        result += a[i] * b[i];
    }
    return result;
}
</pre>



<p><a name="k15"></a></p>
<h2 id="k15">15. Nevektorizovaná a vektorizovaná podoba výsledného kódu</h2>

<p>Opět se, podobně jako u předchozích příkladů, podíváme na výsledek překladu
<a href="#k14">výše uvedeného výpočtu</a> do strojového kódu. Nejprve je
uvedena nevektorizovaná varianta. Ta je v&nbsp;praxi dosti nezajímavá &ndash;
moc pomalá, protože provádí čtyři součiny a čtyři součty:</p>

<pre>
<strong>dot_product_4</strong>:
        xor     eax, eax
        pxor    xmm1, xmm1
.L2:
        movss   xmm0, DWORD PTR [rdi+rax]
        mulss   xmm0, DWORD PTR [rsi+rax]
        add     rax, 4
        addss   xmm1, xmm0
        cmp     rax, 16
        jne     .L2
        movaps  xmm0, xmm1
        ret
</pre>

<p>Vektorizovaná varianta vypadá následovně. Jedná se o variantu kompatibilní
s&nbsp;normou IEEE 754:</p>

<pre>
<strong>dot_product_4</strong>:
        movups  xmm0, XMMWORD PTR [rsi]
        movups  xmm1, XMMWORD PTR [rdi]
        pxor    xmm2, xmm2
        mulps   xmm1, xmm0
        movaps  xmm0, xmm1
        addss   xmm0, xmm2
        movaps  xmm2, xmm1
        shufps  xmm2, xmm1, 85
        addss   xmm0, xmm2
        movaps  xmm2, xmm1
        unpckhps        xmm2, xmm1
        shufps  xmm1, xmm1, 255
        addss   xmm0, xmm2
        addss   xmm0, xmm1
        ret
</pre>



<p><a name="k16"></a></p>
<h2 id="k16">16. Další možné optimalizace výpočtů skalárního součinu</h2>

<p>Nejkratší kód (bez smyčky) dostaneme v&nbsp;případě povolení autovektorizace
a současně i povolením režimu &bdquo;rychlé matematiky&ldquo;
(<i>fast-math</i>), takže výsledky obecně nemusí přesně odpovídat normě IEEE
754. Tato varianta je založena na součinu prvků vektorů, součtu prvků vektorů a
následně ještě jednoho součtu, který vrátí výslednou skalární hodnotu:</p>

<pre>
<strong>dot_product_4</strong>:
        movups  xmm1, XMMWORD PTR [rsi]
        movups  xmm0, XMMWORD PTR [rdi]
        mulps   xmm0, xmm1
        movaps  xmm1, xmm0
        movhlps xmm1, xmm0
        addps   xmm1, xmm0
        movaps  xmm0, xmm1
        shufps  xmm0, xmm1, 85
        addps   xmm0, xmm1
        ret
</pre>



<p><a name="k17"></a></p>
<h2 id="k17">17. Vysvětlení postupu výpočtu</h2>

<p></p>

<pre>
a = (1, 2, 3, 4)
b = (5, 6, 7, 1)
&nbsp;
a · b = a1·b1 + a2·b2 + a3·b3 + a4·b4 = 1·5 + 2·6 + 3·7 + 4·1 = 5 + 12 + 21 + 4 = 42
</pre>

<p><div class="rs-tip-major">Poznámka: 42 je samozřejmě v&nbsp;tomto vesmíru
očekávaný výsledek.</div></p>

<pre>
XMM0:   40A00000 40C00000 40E00000 3F800000    5.0  6.0  7.0  1.0 
XMM1:   3F800000 40000000 40400000 40800000    1.0  2.0  3.0  4.0 

XMM0:   40A00000 41400000 41A80000 40800000    5.0  12.0  21.0  4.0 
XMM1:   3F800000 40000000 40400000 40800000    1.0  2.0  3.0  4.0 

XMM0:   40A00000 41400000 41A80000 40800000    5.0  12.0  21.0  4.0 
XMM1:   40A00000 41400000 41A80000 40800000    5.0  12.0  21.0  4.0 

XMM0:   40A00000 41400000 41A80000 40800000    5.0  12.0  21.0  4.0 
XMM1:   40A00000 41400000 40A00000 41400000    5.0  12.0  5.0  12.0 

XMM0:   40A00000 41400000 41A80000 40800000    5.0  12.0  21.0  4.0 
XMM1:   41200000 41C00000 41D00000 41800000    10.0  24.0  26.0  16.0 

XMM0:   41D00000 41D00000 41D00000 41D00000    26.0  26.0  26.0  26.0 
XMM1:   41200000 41C00000 41D00000 41800000    10.0  24.0  26.0  16.0 

XMM0:   42100000 42480000 42500000 42280000    36.0  50.0  52.0  42.0 
XMM1:   41200000 41C00000 41D00000 41800000    10.0  24.0  26.0  16.0 
</pre>



<p><a name="k18"></a></p>
<h2 id="k18">18. Repositář s&nbsp;demonstračními příklady</h2>

<p>Demonstrační příklady naprogramované v&nbsp;jazyku, které jsou určené pro
překlad s&nbsp;využitím assembleru <strong>gcc</strong>, byly uloženy do Git
repositáře, který je dostupný na adrese <a
href="https://github.com/tisnik/8bit-fame">https://github.com/tisnik/8bit-fame</a>.
Kromě zdrojových kódů příkladů jsou do repositáře přidány i výsledky překladu
do assembleru v&nbsp;syntaxi kompatibilní s&nbsp;Intelem. Jednotlivé
demonstrační příklady si můžete v&nbsp;případě potřeby stáhnout i jednotlivě
bez nutnosti klonovat celý (dnes již poměrně rozsáhlý) repositář:</p>

<table>
<tr><th> #</th><th>Příklad</th><th>Stručný popis</th><th>Adresa</th></tr>
<tr><td> 1</td><td>array_clear_size_8.c</td><td>smazání obsahu pole s&nbsp;osmi prvky typu <strong>float</strong></td><td><a href="https://github.com/tisnik/8bit-fame/blob/master/gcc-simd/array_clear_size_8.c">https://github.com/tisnik/8bit-fame/blob/master/gcc-simd/array_clear_size_8.c</a></td></tr>
<tr><td> 2</td><td>array_clear_size_8_non_vect.asm</td><td>výsledek překladu se zákazem vektorizace</td><td><a href="https://github.com/tisnik/8bit-fame/blob/master/gcc-simd/array_clear_size_8_non_vect.asm">https://github.com/tisnik/8bit-fame/blob/master/gcc-simd/array_clear_size_8_non_vect.asm</a></td></tr>
<tr><td> 3</td><td>array_clear_size_8_no_sse.asm</td><td>výsledek překladu se zákazem SSE instrukcí</td><td><a href="https://github.com/tisnik/8bit-fame/blob/master/gcc-simd/array_clear_size_8_no_sse.asm">https://github.com/tisnik/8bit-fame/blob/master/gcc-simd/array_clear_size_8_no_sse.asm</a></td></tr>
<tr><td> 4</td><td>array_clear_size_8_vect.asm</td><td>výsledek překladu s&nbsp;povolením vektorizace</td><td><a href="https://github.com/tisnik/8bit-fame/blob/master/gcc-simd/array_clear_size_8_vect.asm">https://github.com/tisnik/8bit-fame/blob/master/gcc-simd/array_clear_size_8_vect.asm</a></td></tr>
<tr><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td></tr>
<tr><td> 5</td><td>array_clear_size_16.c</td><td>smazání obsahu pole se šestnácti prvky typu <strong>float</strong></td><td><a href="https://github.com/tisnik/8bit-fame/blob/master/gcc-simd/array_clear_size_16.c">https://github.com/tisnik/8bit-fame/blob/master/gcc-simd/array_clear_size_16.c</a></td></tr>
<tr><td> 6</td><td>array_clear_size_16_non_vect.asm</td><td>výsledek překladu se zákazem vektorizace</td><td><a href="https://github.com/tisnik/8bit-fame/blob/master/gcc-simd/array_clear_size_16_non_vect.asm">https://github.com/tisnik/8bit-fame/blob/master/gcc-simd/array_clear_size_16_non_vect.asm</a></td></tr>
<tr><td> 7</td><td>array_clear_size_16_vect.asm</td><td>výsledek překladu s&nbsp;povolením vektorizace</td><td><a href="https://github.com/tisnik/8bit-fame/blob/master/gcc-simd/array_clear_size_16_vect.asm">https://github.com/tisnik/8bit-fame/blob/master/gcc-simd/array_clear_size_16_vect.asm</a></td></tr>
<tr><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td></tr>
<tr><td> 8</td><td>array_clear_size_18.c</td><td>smazání obsahu pole se sedmnácti prvky typu <strong>float</strong></td><td><a href="https://github.com/tisnik/8bit-fame/blob/master/gcc-simd/array_clear_size_18.c">https://github.com/tisnik/8bit-fame/blob/master/gcc-simd/array_clear_size_18.c</a></td></tr>
<tr><td> 9</td><td>array_clear_size_18_non_vect.asm</td><td>výsledek překladu se zákazem vektorizace</td><td><a href="https://github.com/tisnik/8bit-fame/blob/master/gcc-simd/array_clear_size_18_non_vect.asm">https://github.com/tisnik/8bit-fame/blob/master/gcc-simd/array_clear_size_18_non_vect.asm</a></td></tr>
<tr><td>10</td><td>array_clear_size_18_vect.asm</td><td>výsledek překladu s&nbsp;povolením vektorizace</td><td><a href="https://github.com/tisnik/8bit-fame/blob/master/gcc-simd/array_clear_size_18_vect.asm">https://github.com/tisnik/8bit-fame/blob/master/gcc-simd/array_clear_size_18_vect.asm</a></td></tr>
<tr><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td></tr>
<tr><td>11</td><td>add_delta_size_16.c</td><td>přičtení konstanty ke všem prvkům pole obsahujícího 16 hodnot typu <strong>float</strong></td><td><a href="https://github.com/tisnik/8bit-fame/blob/master/gcc-simd/add_delta_size_16.c">https://github.com/tisnik/8bit-fame/blob/master/gcc-simd/add_delta_size_16.c</a></td></tr>
<tr><td>12</td><td>add_delta_size_16_non_vect.asm</td><td>výsledek překladu se zákazem vektorizace</td><td><a href="https://github.com/tisnik/8bit-fame/blob/master/gcc-simd/add_delta_size_16_non_vect.asm">https://github.com/tisnik/8bit-fame/blob/master/gcc-simd/add_delta_size_16_non_vect.asm</a></td></tr>
<tr><td>13</td><td>add_delta_size_16_vect.asm</td><td>výsledek překladu s&nbsp;povolením vektorizace</td><td><a href="https://github.com/tisnik/8bit-fame/blob/master/gcc-simd/add_delta_size_16_vect.asm">https://github.com/tisnik/8bit-fame/blob/master/gcc-simd/add_delta_size_16_vect.asm</a></td></tr>
<tr><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td></tr>
<tr><td>14</td><td>add_delta_size_17.c</td><td>přičtení konstanty ke všem prvkům pole obsahujícího 17 hodnot typu <strong>float</strong></td><td><a href="https://github.com/tisnik/8bit-fame/blob/master/gcc-simd/add_delta_size_17.c">https://github.com/tisnik/8bit-fame/blob/master/gcc-simd/add_delta_size_17.c</a></td></tr>
<tr><td>15</td><td>add_delta_size_17_non_vect.asm</td><td>výsledek překladu se zákazem vektorizace</td><td><a href="https://github.com/tisnik/8bit-fame/blob/master/gcc-simd/add_delta_size_17_non_vect.asm">https://github.com/tisnik/8bit-fame/blob/master/gcc-simd/add_delta_size_17_non_vect.asm</a></td></tr>
<tr><td>16</td><td>add_delta_size_17_vect.asm</td><td>výsledek překladu s&nbsp;povolením vektorizace</td><td><a href="https://github.com/tisnik/8bit-fame/blob/master/gcc-simd/add_delta_size_17_vect.asm">https://github.com/tisnik/8bit-fame/blob/master/gcc-simd/add_delta_size_17_vect.asm</a></td></tr>
<tr><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td></tr>
<tr><td>17</td><td>add_delta_size_24.c</td><td>přičtení konstanty ke všem prvkům pole obsahujícího 24 hodnot typu <strong>float</strong></td><td><a href="https://github.com/tisnik/8bit-fame/blob/master/gcc-simd/add_delta_size_24.c">https://github.com/tisnik/8bit-fame/blob/master/gcc-simd/add_delta_size_24.c</a></td></tr>
<tr><td>18</td><td>add_delta_size_24_non_vect.asm</td><td>výsledek překladu se zákazem vektorizace</td><td><a href="https://github.com/tisnik/8bit-fame/blob/master/gcc-simd/add_delta_size_24_non_vect.asm">https://github.com/tisnik/8bit-fame/blob/master/gcc-simd/add_delta_size_24_non_vect.asm</a></td></tr>
<tr><td>19</td><td>add_delta_size_24_vect.asm</td><td>výsledek překladu s&nbsp;povolením vektorizace</td><td><a href="https://github.com/tisnik/8bit-fame/blob/master/gcc-simd/add_delta_size_24_vect.asm">https://github.com/tisnik/8bit-fame/blob/master/gcc-simd/add_delta_size_24_vect.asm</a></td></tr>
<tr><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td></tr>
<tr><td>20</td><td>array_sqrt.c</td><td>výpočet druhé odmocniny všech prvků polí</td><td><a href="https://github.com/tisnik/8bit-fame/blob/master/gcc-simd/array_sqrt.c">https://github.com/tisnik/8bit-fame/blob/master/gcc-simd/array_sqrt.c</a></td></tr>
<tr><td>21</td><td>array_sqrt_non_vect.asm</td><td>výsledek překladu se zákazem vektorizace</td><td><a href="https://github.com/tisnik/8bit-fame/blob/master/gcc-simd/array_sqrt_non_vect.asm">https://github.com/tisnik/8bit-fame/blob/master/gcc-simd/array_sqrt_non_vect.asm</a></td></tr>
<tr><td>22</td><td>array_sqrt_vect.asm</td><td>výsledek překladu s&nbsp;povolením vektorizace</td><td><a href="https://github.com/tisnik/8bit-fame/blob/master/gcc-simd/array_sqrt_vect.asm">https://github.com/tisnik/8bit-fame/blob/master/gcc-simd/array_sqrt_vect.asm</a></td></tr>
<tr><td>23</td><td>array_sqrt_vect_fast_math.asm</td><td>výsledek překladu s&nbsp;povolením vektorizace a nepřesných výpočtů</td><td><a href="https://github.com/tisnik/8bit-fame/blob/master/gcc-simd/array_sqrt_vect_fast_math.asm">https://github.com/tisnik/8bit-fame/blob/master/gcc-simd/array_sqrt_vect_fast_math.asm</a></td></tr>
<tr><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td></tr>
<tr><td>24</td><td>dot_product_4.c</td><td>skalární součin vektorů, z&nbsp;nichž každý má délku čtyři prvky</td><td><a href="https://github.com/tisnik/8bit-fame/blob/master/gcc-simd/dot_product_4.c">https://github.com/tisnik/8bit-fame/blob/master/gcc-simd/dot_product_4.c</a></td></tr>
<tr><td>25</td><td>dot_product_4_non_vect.asm</td><td>výsledek překladu se zákazem vektorizace</td><td><a href="https://github.com/tisnik/8bit-fame/blob/master/gcc-simd/dot_product_4_non_vect.asm">https://github.com/tisnik/8bit-fame/blob/master/gcc-simd/dot_product_4_non_vect.asm</a></td></tr>
<tr><td>26</td><td>dot_product_4_vect.asm</td><td>výsledek překladu s&nbsp;povolením vektorizace</td><td><a href="https://github.com/tisnik/8bit-fame/blob/master/gcc-simd/dot_product_4_vect.asm">https://github.com/tisnik/8bit-fame/blob/master/gcc-simd/dot_product_4_vect.asm</a></td></tr>
<tr><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td></tr>
<tr><td>27</td><td>dot_product_8.c</td><td>skalární součin vektorů, z&nbsp;nichž každý má délku osmi prvků</td><td><a href="https://github.com/tisnik/8bit-fame/blob/master/gcc-simd/dot_product_8.c">https://github.com/tisnik/8bit-fame/blob/master/gcc-simd/dot_product_8.c</a></td></tr>
<tr><td>28</td><td>dot_product_8_non_vect.asm</td><td>výsledek překladu se zákazem vektorizace</td><td><a href="https://github.com/tisnik/8bit-fame/blob/master/gcc-simd/dot_product_8_non_vect.asm">https://github.com/tisnik/8bit-fame/blob/master/gcc-simd/dot_product_8_non_vect.asm</a></td></tr>
<tr><td>29</td><td>dot_product_8_vect.asm</td><td>výsledek překladu s&nbsp;povolením vektorizace</td><td><a href="https://github.com/tisnik/8bit-fame/blob/master/gcc-simd/dot_product_8_vect.asm">https://github.com/tisnik/8bit-fame/blob/master/gcc-simd/dot_product_8_vect.asm</a></td></tr>
<tr><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td></tr>
<tr><td>30</td><td>dot_product_100.c</td><td>skalární součin vektorů, z&nbsp;nichž každý má délku 100 prvků</td><td><a href="https://github.com/tisnik/8bit-fame/blob/master/gcc-simd/dot_product_100.c">https://github.com/tisnik/8bit-fame/blob/master/gcc-simd/dot_product_100.c</a></td></tr>
<tr><td>31</td><td>dot_product_100_non_vect.asm</td><td>výsledek překladu se zákazem vektorizace</td><td><a href="https://github.com/tisnik/8bit-fame/blob/master/gcc-simd/dot_product_100_non_vect.asm">https://github.com/tisnik/8bit-fame/blob/master/gcc-simd/dot_product_100_non_vect.asm</a></td></tr>
<tr><td>32</td><td>dot_product_100_vect.asm</td><td>výsledek překladu s&nbsp;povolením vektorizace</td><td><a href="https://github.com/tisnik/8bit-fame/blob/master/gcc-simd/dot_product_100_vect.asm">https://github.com/tisnik/8bit-fame/blob/master/gcc-simd/dot_product_100_vect.asm</a></td></tr>
<tr><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td></tr>
<tr><td>33</td><td>add_arrays_size_4.c</td><td>součet prvků dvojice polí typu <strong>float</strong>, pole mají délku 4 prvků</td><td><a href="https://github.com/tisnik/8bit-fame/blob/master/gcc-simd/add_arrays_size_4.c">https://github.com/tisnik/8bit-fame/blob/master/gcc-simd/add_arrays_size_4.c</a></td></tr>
<tr><td>34</td><td>add_arrays_size_4_non_vect.asm</td><td>výsledek překladu se zákazem vektorizace</td><td><a href="https://github.com/tisnik/8bit-fame/blob/master/gcc-simd/add_arrays_size_4_non_vect.asm">https://github.com/tisnik/8bit-fame/blob/master/gcc-simd/add_arrays_size_4_non_vect.asm</a></td></tr>
<tr><td>35</td><td>add_arrays_size_4_vect.asm</td><td>výsledek překladu s&nbsp;povolením vektorizace</td><td><a href="https://github.com/tisnik/8bit-fame/blob/master/gcc-simd/add_arrays_size_4_vect.asm">https://github.com/tisnik/8bit-fame/blob/master/gcc-simd/add_arrays_size_4_vect.asm</a></td></tr>
<tr><td>36</td><td>add_arrays_size_16.c</td><td>součet prvků dvojice polí typu <strong>float</strong>, pole mají délku 16 prvků</td><td><a href="https://github.com/tisnik/8bit-fame/blob/master/gcc-simd/add_arrays_size_16.c">https://github.com/tisnik/8bit-fame/blob/master/gcc-simd/add_arrays_size_16.c</a></td></tr>
<tr><td>37</td><td>add_arrays_size_16_non_vect.asm</td><td>výsledek překladu se zákazem vektorizace</td><td><a href="https://github.com/tisnik/8bit-fame/blob/master/gcc-simd/add_arrays_size_16_non_vect.asm">https://github.com/tisnik/8bit-fame/blob/master/gcc-simd/add_arrays_size_16_non_vect.asm</a></td></tr>
<tr><td>38</td><td>add_arrays_size_16_vect.asm</td><td>výsledek překladu s&nbsp;povolením vektorizace</td><td><a href="https://github.com/tisnik/8bit-fame/blob/master/gcc-simd/add_arrays_size_16_vect.asm">https://github.com/tisnik/8bit-fame/blob/master/gcc-simd/add_arrays_size_16_vect.asm</a></td></tr>
<tr><td>39</td><td>add_arrays_size_17.c</td><td>součet prvků dvojice polí typu <strong>float</strong>, pole mají délku 17 prvků</td><td><a href="https://github.com/tisnik/8bit-fame/blob/master/gcc-simd/add_arrays_size_17.c">https://github.com/tisnik/8bit-fame/blob/master/gcc-simd/add_arrays_size_17.c</a></td></tr>
<tr><td>40</td><td>add_arrays_size_17_non_vect.asm</td><td>výsledek překladu se zákazem vektorizace</td><td><a href="https://github.com/tisnik/8bit-fame/blob/master/gcc-simd/add_arrays_size_17_non_vect.asm">https://github.com/tisnik/8bit-fame/blob/master/gcc-simd/add_arrays_size_17_non_vect.asm</a></td></tr>
<tr><td>41</td><td>add_arrays_size_17_vect.asm</td><td>výsledek překladu s&nbsp;povolením vektorizace</td><td><a href="https://github.com/tisnik/8bit-fame/blob/master/gcc-simd/add_arrays_size_17_vect.asm">https://github.com/tisnik/8bit-fame/blob/master/gcc-simd/add_arrays_size_17_vect.asm</a></td></tr>
<tr><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td></tr>
<tr><td>42</td><td>add_arrays_restrict_size_4.c</td><td>součet prvků polí se čtyřmi prvky, pole se nepřekrývají</td><td><a href="https://github.com/tisnik/8bit-fame/blob/master/gcc-simd/add_arrays_restrict_size_4.c">https://github.com/tisnik/8bit-fame/blob/master/gcc-simd/add_arrays_restrict_size_4.c</a></td></tr>
<tr><td>43</td><td>add_arrays_restrict_size_4_non_vect.asm</td><td>výsledek překladu se zákazem vektorizace</td><td><a href="https://github.com/tisnik/8bit-fame/blob/master/gcc-simd/add_arrays_restrict_size_4_non_vect.asm">https://github.com/tisnik/8bit-fame/blob/master/gcc-simd/add_arrays_restrict_size_4_non_vect.asm</a></td></tr>
<tr><td>44</td><td>add_arrays_restrict_size_4_vect.asm</td><td>výsledek překladu s&nbsp;povolením vektorizace</td><td><a href="https://github.com/tisnik/8bit-fame/blob/master/gcc-simd/add_arrays_restrict_size_4_vect.asm">https://github.com/tisnik/8bit-fame/blob/master/gcc-simd/add_arrays_restrict_size_4_vect.asm</a></td></tr>
<tr><td>45</td><td>add_arrays_restrict_size_16.c</td><td>součet prvků polí se šestnácti prvky, pole se nepřekrývají</td><td><a href="https://github.com/tisnik/8bit-fame/blob/master/gcc-simd/add_arrays_restrict_size_16.c">https://github.com/tisnik/8bit-fame/blob/master/gcc-simd/add_arrays_restrict_size_16.c</a></td></tr>
<tr><td>46</td><td>add_arrays_restrict_size_16_non_vect.asm</td><td>výsledek překladu se zákazem vektorizace</td><td><a href="https://github.com/tisnik/8bit-fame/blob/master/gcc-simd/add_arrays_restrict_size_16_non_vect.asm">https://github.com/tisnik/8bit-fame/blob/master/gcc-simd/add_arrays_restrict_size_16_non_vect.asm</a></td></tr>
<tr><td>47</td><td>add_arrays_restrict_size_16_vect.asm</td><td>výsledek překladu s&nbsp;povolením vektorizace</td><td><a href="https://github.com/tisnik/8bit-fame/blob/master/gcc-simd/add_arrays_restrict_size_16_vect.asm">https://github.com/tisnik/8bit-fame/blob/master/gcc-simd/add_arrays_restrict_size_16_vect.asm</a></td></tr>
<tr><td>48</td><td>add_arrays_restrict_size_17.c</td><td>součet prvků polí se sedmnácti prvky, pole se nepřekrývají</td><td><a href="https://github.com/tisnik/8bit-fame/blob/master/gcc-simd/add_arrays_restrict_size_17.c">https://github.com/tisnik/8bit-fame/blob/master/gcc-simd/add_arrays_restrict_size_17.c</a></td></tr>
<tr><td>49</td><td>add_arrays_restrict_size_17_non_vect.asm</td><td>výsledek překladu se zákazem vektorizace</td><td><a href="https://github.com/tisnik/8bit-fame/blob/master/gcc-simd/add_arrays_restrict_size_17_non_vect.asm">https://github.com/tisnik/8bit-fame/blob/master/gcc-simd/add_arrays_restrict_size_17_non_vect.asm</a></td></tr>
<tr><td>50</td><td>add_arrays_restrict_size_17_vect.asm</td><td>výsledek překladu s&nbsp;povolením vektorizace</td><td><a href="https://github.com/tisnik/8bit-fame/blob/master/gcc-simd/add_arrays_restrict_size_17_vect.asm">https://github.com/tisnik/8bit-fame/blob/master/gcc-simd/add_arrays_restrict_size_17_vect.asm</a></td></tr>
<tr><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td></tr>
<tr><td>51</td><td>array_sum_4.c</td><td>součet všech prvků v&nbsp;poli se čtyřmi prvky</td><td><a href="https://github.com/tisnik/8bit-fame/blob/master/gcc-simd/array_sum_4.c">https://github.com/tisnik/8bit-fame/blob/master/gcc-simd/array_sum_4.c</a></td></tr>
<tr><td>52</td><td>array_sum_4_non_vect.asm</td><td>výsledek překladu se zákazem vektorizace</td><td><a href="https://github.com/tisnik/8bit-fame/blob/master/gcc-simd/array_sum_4_non_vect.asm">https://github.com/tisnik/8bit-fame/blob/master/gcc-simd/array_sum_4_non_vect.asm</a></td></tr>
<tr><td>53</td><td>array_sum_4_vect.asm</td><td>výsledek překladu s&nbsp;povolením vektorizace</td><td><a href="https://github.com/tisnik/8bit-fame/blob/master/gcc-simd/array_sum_4_vect.asm">https://github.com/tisnik/8bit-fame/blob/master/gcc-simd/array_sum_4_vect.asm</a></td></tr>
<tr><td>54</td><td>array_sum_8.c</td><td>součet všech prvků v&nbsp;poli s&nbsp;osmi prvky</td><td><a href="https://github.com/tisnik/8bit-fame/blob/master/gcc-simd/array_sum_8.c">https://github.com/tisnik/8bit-fame/blob/master/gcc-simd/array_sum_8.c</a></td></tr>
<tr><td>55</td><td>array_sum_8_non_vect.asm</td><td>výsledek překladu se zákazem vektorizace</td><td><a href="https://github.com/tisnik/8bit-fame/blob/master/gcc-simd/array_sum_8_non_vect.asm">https://github.com/tisnik/8bit-fame/blob/master/gcc-simd/array_sum_8_non_vect.asm</a></td></tr>
<tr><td>56</td><td>array_sum_8_vect.asm</td><td>výsledek překladu s&nbsp;povolením vektorizace</td><td><a href="https://github.com/tisnik/8bit-fame/blob/master/gcc-simd/array_sum_8_vect.asm">https://github.com/tisnik/8bit-fame/blob/master/gcc-simd/array_sum_8_vect.asm</a></td></tr>
<tr><td>57</td><td>array_sum_100.c</td><td>součet všech prvků polí se 100 prvky</td><td><a href="https://github.com/tisnik/8bit-fame/blob/master/gcc-simd/array_sum_100.c">https://github.com/tisnik/8bit-fame/blob/master/gcc-simd/array_sum_100.c</a></td></tr>
<tr><td>58</td><td>array_sum_100_non_vect.asm</td><td>výsledek překladu se zákazem vektorizace</td><td><a href="https://github.com/tisnik/8bit-fame/blob/master/gcc-simd/array_sum_100_non_vect.asm">https://github.com/tisnik/8bit-fame/blob/master/gcc-simd/array_sum_100_non_vect.asm</a></td></tr>
<tr><td>59</td><td>array_sum_100_vect.asm</td><td>výsledek překladu s&nbsp;povolením vektorizace</td><td><a href="https://github.com/tisnik/8bit-fame/blob/master/gcc-simd/array_sum_100_vect.asm">https://github.com/tisnik/8bit-fame/blob/master/gcc-simd/array_sum_100_vect.asm</a></td></tr>
<tr><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td></tr>
<tr><td>60</td><td>find_max_4.c</td><td>vyhledání největšího prvku v&nbsp;poli se čtyřmi prvky</td><td><a href="https://github.com/tisnik/8bit-fame/blob/master/gcc-simd/find_max_4.c">https://github.com/tisnik/8bit-fame/blob/master/gcc-simd/find_max_4.c</a></td></tr>
<tr><td>61</td><td>find_max_4_non_vect.asm</td><td>výsledek překladu se zákazem vektorizace</td><td><a href="https://github.com/tisnik/8bit-fame/blob/master/gcc-simd/find_max_4_non_vect.asm">https://github.com/tisnik/8bit-fame/blob/master/gcc-simd/find_max_4_non_vect.asm</a></td></tr>
<tr><td>62</td><td>find_max_4_vect.asm</td><td>výsledek překladu s&nbsp;povolením vektorizace</td><td><a href="https://github.com/tisnik/8bit-fame/blob/master/gcc-simd/find_max_4_vect.asm">https://github.com/tisnik/8bit-fame/blob/master/gcc-simd/find_max_4_vect.asm</a></td></tr>
<tr><td>63</td><td>find_max_8.c</td><td>vyhledání největšího prvku v&nbsp;poli s&nbsp;osmi prvky</td><td><a href="https://github.com/tisnik/8bit-fame/blob/master/gcc-simd/find_max_8.c">https://github.com/tisnik/8bit-fame/blob/master/gcc-simd/find_max_8.c</a></td></tr>
<tr><td>64</td><td>find_max_8_non_vect.asm</td><td>výsledek překladu se zákazem vektorizace</td><td><a href="https://github.com/tisnik/8bit-fame/blob/master/gcc-simd/find_max_8_non_vect.asm">https://github.com/tisnik/8bit-fame/blob/master/gcc-simd/find_max_8_non_vect.asm</a></td></tr>
<tr><td>65</td><td>find_max_8_vect.asm</td><td>výsledek překladu s&nbsp;povolením vektorizace</td><td><a href="https://github.com/tisnik/8bit-fame/blob/master/gcc-simd/find_max_8_vect.asm">https://github.com/tisnik/8bit-fame/blob/master/gcc-simd/find_max_8_vect.asm</a></td></tr>
<tr><td>66</td><td>find_max_100.c</td><td>vyhledání největšího prvku v&nbsp;poli se 100 prvky</td><td><a href="https://github.com/tisnik/8bit-fame/blob/master/gcc-simd/find_max_100.c">https://github.com/tisnik/8bit-fame/blob/master/gcc-simd/find_max_100.c</a></td></tr>
<tr><td>67</td><td>find_max_100_non_vect.asm</td><td>výsledek překladu se zákazem vektorizace</td><td><a href="https://github.com/tisnik/8bit-fame/blob/master/gcc-simd/find_max_100_non_vect.asm">https://github.com/tisnik/8bit-fame/blob/master/gcc-simd/find_max_100_non_vect.asm</a></td></tr>
<tr><td>68</td><td>find_max_100_vect.asm</td><td>výsledek překladu s&nbsp;povolením vektorizace</td><td><a href="https://github.com/tisnik/8bit-fame/blob/master/gcc-simd/find_max_100_vect.asm">https://github.com/tisnik/8bit-fame/blob/master/gcc-simd/find_max_100_vect.asm</a></td></tr>
</table>



<p><a name="k19"></a></p>
<h2 id="k19">19. Seznam všech předchozích částí tohoto seriálu a článků o SIMD instrukcích</h2>

<p>Podporou SIMD instrukcí na úrovni <i>intrinsic</i> jsme se už na Rootu
zabývali, stejně jako samotnými SIMD instrukcemi na úrovni assembleru. Pro
úplnost jsou v&nbsp;této příloze uvedeny odkazy na příslušné články:</p>

<ol>

<li>Užitečné rozšíření GCC: podpora SIMD (vektorových) instrukcí<br />
<a href="https://www.root.cz/clanky/uzitecne-rozsireni-gcc-podpora-simd-vektorovych-instrukci/">https://www.root.cz/clanky/uzitecne-rozsireni-gcc-podpora-simd-vektorovych-instrukci/</a>
</li>

<li>Užitečné rozšíření GCC – podpora SIMD (vektorových) instrukcí: nedostatky technologie<br />
<a href="https://www.root.cz/clanky/uzitecne-rozsireni-gcc-podpora-simd-vektorovych-instrukci-nedostatky-technologie/">https://www.root.cz/clanky/uzitecne-rozsireni-gcc-podpora-simd-vektorovych-instrukci-nedostatky-technologie/</a>
</li>

<li>Podpora SIMD (vektorových) instrukcí na RISCových procesorech<br />
<a href="https://www.root.cz/clanky/podpora-simd-vektorovych-instrukci-na-riscovych-procesorech/">https://www.root.cz/clanky/podpora-simd-vektorovych-instrukci-na-riscovych-procesorech/</a>
</li>

<li>Podpora SIMD operací v&nbsp;GCC s&nbsp;využitím intrinsic pro nízkoúrovňové optimalizace<br />
<a href="https://www.root.cz/clanky/podpora-simd-operaci-v-gcc-s-vyuzitim-intrinsic-pro-nizkourovnove-optimalizace/">https://www.root.cz/clanky/podpora-simd-operaci-v-gcc-s-vyuzitim-intrinsic-pro-nizkourovnove-optimalizace/</a>
</li>

<li>Podpora SIMD operací v&nbsp;GCC s&nbsp;využitím intrinsic: technologie SSE<br />
<a href="https://www.root.cz/clanky/podpora-simd-operaci-v-gcc-s-vyuzitim-intrinsic-technologie-sse/">https://www.root.cz/clanky/podpora-simd-operaci-v-gcc-s-vyuzitim-intrinsic-technologie-sse/</a>
</li>

<li>Rozšíření instrukční sady „Advanced Vector Extensions“ na platformě x86–64<br />
<a href="https://www.root.cz/clanky/rozsireni-instrukcni-sady-advanced-vector-extensions-na-platforme-x86-64/">https://www.root.cz/clanky/rozsireni-instrukcni-sady-advanced-vector-extensions-na-platforme-x86-64/</a>
</li>

<li>Rozšíření instrukční sady F16C, FMA a AVX-512 na platformě x86–64<br />
<a href="https://www.root.cz/clanky/rozsireni-instrukcni-sady-f16c-fma-a-avx-512-na-platforme-x86-64/">https://www.root.cz/clanky/rozsireni-instrukcni-sady-f16c-fma-a-avx-512-na-platforme-x86-64/</a>
</li>

<li>Rozšíření instrukční sady AVX-512 na platformě x86–64 (dokončení)<br />
<a href="https://www.root.cz/clanky/rozsireni-instrukcni-sady-avx-512-na-platforme-x86-64-dokonceni/">https://www.root.cz/clanky/rozsireni-instrukcni-sady-avx-512-na-platforme-x86-64-dokonceni/</a>
</li>

<li>SIMD instrukce na platformě 80×86: instrukční sada MMX<br />
<a href="https://www.root.cz/clanky/simd-instrukce-na-platforme-80x86-instrukcni-sada-mmx/">https://www.root.cz/clanky/simd-instrukce-na-platforme-80x86-instrukcni-sada-mmx/</a>
</li>

<li>SIMD instrukce na 80×86: dokončení popisu MMX, instrukce 3DNow! <br />
<a href="https://www.root.cz/clanky/simd-instrukce-na-80-86-dokonceni-popisu-mmx-instrukce-3dnow/">https://www.root.cz/clanky/simd-instrukce-na-80-86-dokonceni-popisu-mmx-instrukce-3dnow/</a>
</li>

<li>SIMD instrukce v rozšíření SSE<br />
<a href="https://www.root.cz/clanky/simd-instrukce-v-rozsireni-sse/">https://www.root.cz/clanky/simd-instrukce-v-rozsireni-sse/</a>
</li>

<li>SIMD instrukce v rozšíření SSE (2. část)<br />
<a href="https://www.root.cz/clanky/simd-instrukce-v-rozsireni-sse-2-cast/">https://www.root.cz/clanky/simd-instrukce-v-rozsireni-sse-2-cast/</a>
</li>

<li>Pokročilejší SSE operace: přeskupení, promíchání a rozbalování prvků vektorů<br />
<a href="https://www.root.cz/clanky/pokrocilejsi-sse-operace-preskupeni-promichani-a-rozbalovani-prvku-vektoru/">https://www.root.cz/clanky/pokrocilejsi-sse-operace-preskupeni-promichani-a-rozbalovani-prvku-vektoru/</a>
</li>

<li>Od instrukční sady SSE k sadě SSE2<br />
<a href="https://www.root.cz/clanky/od-instrukcni-sady-sse-k-sade-sse2/">https://www.root.cz/clanky/od-instrukcni-sady-sse-k-sade-sse2/</a>
</li>

<li>Instrukční sady SIMD a automatické vektorizace prováděné překladačem GCC<br />
<a href="https://www.root.cz/clanky/instrukcni-sady-simd-a-automaticke-vektorizace-provadene-prekladacem-gcc/">https://www.root.cz/clanky/instrukcni-sady-simd-a-automaticke-vektorizace-provadene-prekladacem-gcc/</a>
</li>

</ol>



<p><a name="k20"></a></p>
<h2 id="k20">20. Odkazy na Internetu</h2>

<ol>

<li>Auto-vectorization in GCC<br />
<a href="https://gcc.gnu.org/projects/tree-ssa/vectorization.html">https://gcc.gnu.org/projects/tree-ssa/vectorization.html</a>
</li>

<li>GCC documentation: Extensions to the C Language Family<br />
<a href="https://gcc.gnu.org/onlinedocs/gcc/C-Extensions.html#C-Extensions">https://gcc.gnu.org/onlinedocs/gcc/C-Extensions.html#C-Extensions</a>
</li>

<li>GCC documentation: Using Vector Instructions through Built-in Functions<br />
<a href="https://gcc.gnu.org/onlinedocs/gcc/Vector-Extensions.html">https://gcc.gnu.org/onlinedocs/gcc/Vector-Extensions.html</a>
</li>

<li>SSE (Streaming SIMD Extentions)<br />
<a href="http://www.songho.ca/misc/sse/sse.html">http://www.songho.ca/misc/sse/sse.html</a>
</li>

<li>Timothy A. Chagnon: SSE and SSE2<br />
<a href="http://www.cs.drexel.edu/~tc365/mpi-wht/sse.pdf">http://www.cs.drexel.edu/~tc365/mpi-wht/sse.pdf</a>
</li>

<li>Intel corporation: Extending the Worldr's Most Popular Processor Architecture<br />
<a href="http://download.intel.com/technology/architecture/new-instructions-paper.pdf">http://download.intel.com/technology/architecture/new-instructions-paper.pdf</a>
</li>

<li>SIMD architectures:<br />
<a href="http://arstechnica.com/old/content/2000/03/simd.ars/">http://arstechnica.com/old/content/2000/03/simd.ars/</a>
</li>

<li>Tour of the Black Holes of Computing!: Floating Point<br />
<a href="http://www.cs.hmc.edu/~geoff/classes/hmc.cs105.../slides/class02_floats.ppt">http://www.cs.hmc.edu/~geoff/classes/hmc.cs105.../slides/class02_floats.ppt</a>
</li>

<li>3Dnow! Technology Manual<br />
AMD Inc., 2000</li>

<li>Intel MMX<sup>TM</sup> Technology Overview<br />
Intel corporation, 1996</li>

<li>MultiMedia eXtensions<br />
<a href="http://softpixel.com/~cwright/programming/simd/mmx.php">http://softpixel.com/~cwright/programming/simd/mmx.php</a>i
</li>

<li>AMD K5 ("K5" / "5k86")<br />
<a href="http://www.pcguide.com/ref/cpu/fam/g5K5-c.html">http://www.pcguide.com/ref/cpu/fam/g5K5-c.html</a>
</li>

<li>Sixth Generation Processors<br />
<a href="http://www.pcguide.com/ref/cpu/fam/g6.htm">http://www.pcguide.com/ref/cpu/fam/g6.htm</a>
</li>

<li>Great Microprocessors of the Past and Present<br />
<a href="http://www.cpushack.com/CPU/cpu1.html">http://www.cpushack.com/CPU/cpu1.html</a>
</li>

<li>Very long instruction word (Wikipedia)<br />
<a href="http://en.wikipedia.org/wiki/Very_long_instruction_word">http://en.wikipedia.org/wiki/Very_long_instruction_word</a>
</li>

<li>CPU design (Wikipedia)<br />
<a href="http://en.wikipedia.org/wiki/CPU_design">http://en.wikipedia.org/wiki/CPU_design</a>
</li>

<li>Bulldozer (microarchitecture)<br />
<a href="https://en.wikipedia.org/wiki/Bulldozer_(microarchitecture)">https://en.wikipedia.org/wiki/Bulldozer_(microarchitecture)</a>
</li>

<li>SIMD Instructions Considered Harmful<br />
<a href="https://www.sigarch.org/simd-instructions-considered-harmful/">https://www.sigarch.org/simd-instructions-considered-harmful/</a>
</li>

<li>GCC Compiler Intrinsics<br />
<a href="https://iq.opengenus.org/gcc-compiler-intrinsics/">https://iq.opengenus.org/gcc-compiler-intrinsics/</a>
</li>

<li>Scalable_Vector_Extension_(SVE)<br />
<a href="https://en.wikipedia.org/wiki/AArch64#Scalable_Vector_Extension_(SVE)">https://en.wikipedia.org/wiki/AArch64#Scalable_Vector_Extension_(SVE)</a>
</li>

<li>Improve the Multimedia User Experience<br />
<a href="https://www.arm.com/technologies/neon">https://www.arm.com/technologies/neon</a>
</li>

<li>NEON Technology (stránky ARM)<br />
<a href="https://developer.arm.com/technologies/neon">https://developer.arm.com/technologies/neon</a>
</li>

<li>SIMD Assembly Tutorial: ARM NEON - Xiph.org<br />
<a href="https://people.xiph.org/~tterribe/daala/neon_tutorial.pdf">https://people.xiph.org/~tterribe/daala/neon_tutorial.pdf</a>
</li>

<li>Ne10<br />
<a href="http://projectne10.github.io/Ne10/">http://projectne10.github.io/Ne10/</a>
</li>

<li>NEON and Floating-Point architecture<br />
<a href="http://infocenter.arm.com/help/index.jsp?topic=/com.arm.doc.den0024a/BABIGHEB.html">http://infocenter.arm.com/help/index.jsp?topic=/com.arm.doc.den0024a/BABIGHEB.html</a>
</li>

<li>An Introduction to ARM NEON<br />
<a href="http://peterdn.com/post/an-introduction-to-ARM-NEON.aspx">http://peterdn.com/post/an-introduction-to-ARM-NEON.aspx</a>
</li>

<li>ARM NEON Intrinsics Reference<br />
<a href="http://infocenter.arm.com/help/topic/com.arm.doc.ihi0073a/IHI0073A_arm_neon_intrinsics_ref.pdf">http://infocenter.arm.com/help/topic/com.arm.doc.ihi0073a/IHI0073A_arm_neon_intrinsics_ref.pdf</a>
</li>

<li>Arm Neon Intrinsics vs hand assembly<br />
<a href="https://stackoverflow.com/questions/9828567/arm-neon-intrinsics-vs-hand-assembly">https://stackoverflow.com/questions/9828567/arm-neon-intrinsics-vs-hand-assembly</a>
</li>

<li>ARM NEON Optimization. An Example<br />
<a href="http://hilbert-space.de/?p=22">http://hilbert-space.de/?p=22</a>
</li>

<li>AArch64 NEON instruction format<br />
<a href="https://developer.arm.com/docs/den0024/latest/7-aarch64-floating-point-and-neon/73-aarch64-neon-instruction-format">https://developer.arm.com/docs/den0024/latest/7-aarch64-floating-point-and-neon/73-aarch64-neon-instruction-format</a>
</li>

<li>ARM SIMD instructions<br />
<a href="https://developer.arm.com/documentation/dht0002/a/Introducing-NEON/What-is-SIMD-/ARM-SIMD-instructions">https://developer.arm.com/documentation/dht0002/a/Introducing-NEON/What-is-SIMD-/ARM-SIMD-instructions</a>
</li>

<li>Learn the architecture - Migrate Neon to SVE Version 1.0<br />
<a href="https://developer.arm.com/documentation/102131/0100/?lang=en">https://developer.arm.com/documentation/102131/0100/?lang=en</a>
</li>

<li>1.2.2. Comparison between NEON technology and other SIMD solutions<br />
<a href="https://developer.arm.com/documentation/den0018/a/Introduction/Comparison-between-ARM-NEON-technology-and-other-implementations/Comparison-between-NEON-technology-and-other-SIMD-solutions?lang=en">https://developer.arm.com/documentation/den0018/a/Introduction/Comparison-between-ARM-NEON-technology-and-other-implementations/Comparison-between-NEON-technology-and-other-SIMD-solutions?lang=en</a>
</li>

<li>NEON Programmer’s Guide<br />
<a href="https://documentation-service.arm.com/static/63299276e68c6809a6b41308">https://documentation-service.arm.com/static/63299276e68c6809a6b41308</a>
</li>

<li>Brain Floating Point – nový formát uložení čísel pro strojové učení a chytrá čidla<br />
<a href="https://www.root.cz/clanky/brain-floating-point-ndash-novy-format-ulozeni-cisel-pro-strojove-uceni-a-chytra-cidla/">https://www.root.cz/clanky/brain-floating-point-ndash-novy-format-ulozeni-cisel-pro-strojove-uceni-a-chytra-cidla/</a>
</li>

<li>Other Built-in Functions Provided by GCC<br />
<a href="https://gcc.gnu.org/onlinedocs/gcc/Other-Builtins.html">https://gcc.gnu.org/onlinedocs/gcc/Other-Builtins.html</a>
</li>

<li>GCC: 6.60 Built-in Functions Specific to Particular Target Machines<br />
<a href="https://gcc.gnu.org/onlinedocs/gcc/Target-Builtins.html#Target-Builtins">https://gcc.gnu.org/onlinedocs/gcc/Target-Builtins.html#Target-Builtins</a>
</li>

<li>Advanced Vector Extensions<br />
<a href="https://en.wikipedia.org/wiki/Advanced_Vector_Extensions">https://en.wikipedia.org/wiki/Advanced_Vector_Extensions</a>
</li>

<li>Top 10 Craziest Assembly Language Instructions<br />
<a href="https://www.youtube.com/watch?v=Wz_xJPN7lAY">https://www.youtube.com/watch?v=Wz_xJPN7lAY</a>
</li>

<li>Intel x86: let's take a look at one of the most complex instruction set!<br />
<a href="https://www.youtube.com/watch?v=KBLy23B38-c">https://www.youtube.com/watch?v=KBLy23B38-c</a>
</li>

<li>x64 Assembly Tutorial 58: Intro to AVX<br />
<a href="https://www.youtube.com/watch?v=yAvuHd8cBJY">https://www.youtube.com/watch?v=yAvuHd8cBJY</a>
</li>

<li>AVX512 (1 of 3): Introduction and Overview<br />
<a href="https://www.youtube.com/watch?v=D-mM6X5xnTY">https://www.youtube.com/watch?v=D-mM6X5xnTY</a>
</li>

<li>AVX512 (2 of 3): Programming AVX512 in 3 Different Ways<br />
<a href="https://www.youtube.com/watch?v=I3efQKLgsjM">https://www.youtube.com/watch?v=I3efQKLgsjM</a>
</li>

<li>AVX512 (3 of 3): Deep Dive into AVX512 Mechanisms<br />
<a href="https://www.youtube.com/watch?v=543a1b-cPmU">https://www.youtube.com/watch?v=543a1b-cPmU</a>
</li>

<li>AVX-512<br />
<a href="https://en.wikipedia.org/wiki/AVX-512">https://en.wikipedia.org/wiki/AVX-512</a>
</li>

<li>AVX-512<br />
<a href="https://iq.opengenus.org/avx512/">https://iq.opengenus.org/avx512/</a>
</li>

<li>SIMD Algorithms Youtube course<br />
<a href="https://denisyaroshevskiy.github.io/presentations/">https://denisyaroshevskiy.github.io/presentations/</a>
</li>

<li>Compiler explorer<br />
<a href="https://godbolt.org/">https://godbolt.org/</a>
</li>

<li>Restricting pointers<br />
<a href="https://gcc.gnu.org/onlinedocs/gcc/Restricted-Pointers.html">https://gcc.gnu.org/onlinedocs/gcc/Restricted-Pointers.html</a>
</li>

<li>Does the restrict keyword provide significant benefits in gcc/g++<br />
<a href="https://stackoverflow.com/questions/1965487/does-the-restrict-keyword-provide-significant-benefits-in-gcc-g">https://stackoverflow.com/questions/1965487/does-the-restrict-keyword-provide-significant-benefits-in-gcc-g</a>
</li>

<li>Demystifying The Restrict Keyword<br />
<a href="https://cellperformance.beyond3d.com/articles/2006/05/demystifying-the-restrict-keyword.html">https://cellperformance.beyond3d.com/articles/2006/05/demystifying-the-restrict-keyword.html</a>
</li>

<li>Basics of Vectorization for Fortran Applications<br />
<a href="https://inria.hal.science/hal-01688488/document">https://inria.hal.science/hal-01688488/document</a>
</li>

<li>What does the restrict keyword mean in C++?<br />
<a href="https://stackoverflow.com/questions/776283/what-does-the-restrict-keyword-mean-in-c">https://stackoverflow.com/questions/776283/what-does-the-restrict-keyword-mean-in-c</a>
</li>

<li>restrict keyword (Wikipedia)<br />
<a href="https://en.wikipedia.org/wiki/Restrict">https://en.wikipedia.org/wiki/Restrict</a>
</li>

<li>Reduction operator<br />
<a href="https://en.wikipedia.org/wiki/Reduction_operator">https://en.wikipedia.org/wiki/Reduction_operator</a>
</li>

<li>The Power of the Dot Product in Artificial Intelligence<br />
<a href="https://medium.com/data-science/the-power-of-the-dot-product-in-artificial-intelligence-c002331e1829">https://medium.com/data-science/the-power-of-the-dot-product-in-artificial-intelligence-c002331e1829</a>
</li>

<li>Can any one explain why dot product is used in neural network and what is the intitutive thought of dot product<br />
<a href="https://stats.stackexchange.com/questions/291680/can-any-one-explain-why-dot-product-is-used-in-neural-network-and-what-is-the-in">https://stats.stackexchange.com/questions/291680/can-any-one-explain-why-dot-product-is-used-in-neural-network-and-what-is-the-in</a>
</li>

</ol>



<p></p><p></p>
<p><small>Autor: <a href="https://github.com/tisnik/">Pavel Tišnovský</a> &nbsp; 2024</small></p>
</body>
</html>

