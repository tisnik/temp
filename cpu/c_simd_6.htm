<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
        "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html>
<head>
<title>Rozšíření instrukční sady &bdquo;Advanced Vector Extensions&ldquo; na platformě x86-64</title>
<meta name="Author" content="Pavel Tisnovsky" />
<meta name="Generator" content="vim" />
<meta http-equiv="content-type" content="text/html; charset=utf-8" />
<style type="text/css">
         body {color:#000000; background:#ffffff;}
         h1  {font-family: arial, helvetica, sans-serif; color:#ffffff; background-color:#c00000; text-align:center; padding-left:1em}
         h2  {font-family: arial, helvetica, sans-serif; color:#ffffff; background-color:#0000c0; padding-left:1em; text-align:left}
         h3  {font-family: arial, helvetica, sans-serif; color:#000000; background-color:#c0c0c0; padding-left:1em; text-align:left}
         h4  {font-family: arial, helvetica, sans-serif; color:#000000; background-color:#e0e0e0; padding-left:1em; text-align:left}
         a   {font-family: arial, helvetica, sans-serif;}
         li  {font-family: arial, helvetica, sans-serif; color:#000000; text-align:justify; width:450px;}
         ol  {font-family: arial, helvetica, sans-serif; color:#000000; text-align:justify; width:450px;}
         ul  {font-family: arial, helvetica, sans-serif; color:#000000; text-align:justify; width:450px;}
         p   {font-family: arial, helvetica, sans-serif; color:#000000; text-align:justify;}
         pre {background:#e0e0e0}
</style>
</head>

<body>

<h1>Rozšíření instrukční sady &bdquo;Advanced Vector Extensions&ldquo; na platformě x86-64</h1>

<h3>Pavel Tišnovský</h3>

<p></p>

<h1>Úvodník</h1>

<p>Šestý článek o podpoře SIMD operací v překladači GCC C je věnován rozšíření instrukční sady &bdquo;Advanced Vector Extension&ldquo; neboli AVX. Oproti MMX či SSE se jedná o výrazné vylepšení podpory SIMD operací s delšími vektory a novými instrukcemi.</p>



<h2>Obsah</h2>

<p><a href="#k01">1. Rozšíření instrukční sady &bdquo;Advanced Vector Extensions&ldquo; na platformě x86-64</a></p>
<p><a href="#k02">2. Od SSE k&nbsp;AVX a posléze k&nbsp;AVX-512</a></p>
<p><a href="#k03">3. Datové typy podporované v&nbsp;instrukčních sadách AVX a AVX2</a></p>
<p><a href="#k04">4. Tříadresový kód</a></p>
<p><a href="#k05">5. Nový způsob kódování instrukcí</a></p>
<p><a href="#k06">6. Praktická část</a></p>
<p><a href="#k07">7. Operace součtu vektorů o délce 256 bitů s&nbsp;celočíselnými prvky bez znaménka</a></p>
<p><a href="#k08">8. Překlad příkladu do assembleru s&nbsp;využitím instrukcí SSE, AVX, nebo AVX2</a></p>
<p><a href="#k09">9. Operace součtu vektorů o délce 256 bitů s&nbsp;celočíselnými prvky se znaménkem</a></p>
<p><a href="#k10">10. Překlad příkladu do assembleru s&nbsp;využitím instrukcí SSE, AVX, nebo AVX2</a></p>
<p><a href="#k11">11. Operace součtu vektorů o délce 256 bitů s&nbsp;prvky typu <i>float</i> a <i>double</i></a></p>
<p><a href="#k12">12. Překlad příkladu do assembleru s&nbsp;využitím instrukcí SSE, AVX, nebo AVX2 &ndash; varianta pro <i>float</i></a></p>
<p><a href="#k13">13. Překlad příkladu do assembleru s&nbsp;využitím instrukcí SSE, AVX, nebo AVX2 &ndash; varianta pro <i>double</i></a></p>
<p><a href="#k14">14. Intrinsic v&nbsp;GCC pro instrukce AVX</a></p>
<p><a href="#k15">15. Intrinsic v&nbsp;GCC pro instrukce AVX2</a></p>
<p><a href="#k16">16. Intrinsic <strong>__builtin_ia32_addps256</strong> &ndash; součet vektorů s&nbsp;prvky typu <i>float</i></a></p>
<p><a href="#k17">17. Intrinsic <strong>__builtin_ia32_addpd256</strong> &ndash; součet vektorů s&nbsp;prvky typu <i>double</i></a></p>
<p><a href="#k18">18. Výběr prvků do cílového vektoru pomocí intrinsic <strong>__builtin_ia32_blendps256</strong></a></p>
<p><a href="#k19">19. Repositář s&nbsp;demonstračními příklady</a></p>
<p><a href="#k20">20. Odkazy na Internetu</a></p>



<p><a name="k01"></a></p>
<h2 id="k01">1. Rozšíření instrukční sady &bdquo;Advanced Vector Extensions&ldquo; na platformě x86-64</h2>

<p>V&nbsp;pořadí již šestý článek o podpoře SIMD operací <a
href="https://gcc.gnu.org/">v&nbsp;překladači GCC C</a> je věnován rozšíření
instrukční sady nazvané &bdquo;Advanced Vector Extension&ldquo; neboli zkráceně
pouze <i>AVX</i>. Oproti již popsaným rozšířením <i>MMX</i> či <i>SSE</i> se
jedná o výrazné vylepšení podpory SIMD operací, které se mj.&nbsp;projevilo
prodloužením vektorů a zcela novými instrukcemi, takže slovo
&bdquo;advanced&ldquo; je zde namístě. Původní technologie <i>AVX</i> byla
představena v&nbsp;roce 2008, přičemž první mikroprocesory vybavené tímto
rozšířením začaly být ve větších sériích prodávány v&nbsp;roce 2011. Jedná se
tedy o (z&nbsp;pohledu vývojáře) relativně novou technologii, která je však
v&nbsp;samotném hardware dnes již široce podporována a lze ji bez větších
problémů začít využívat.</p>

<p>Původní rozšíření <i>AVX</i> bylo v&nbsp;roce 2013 doplněno rozšířením
nazvaným <i>AVX2</i> a jen o několik měsíců později byla představena
specifikace nazvaná <i>AVX-512</i>. V&nbsp;tomto případě se nejedná o jediné
rozšíření instrukční sady, ale o specifikaci hned několika rozšíření, které
mohou být (ale nemusí) všechny implementovány (většinou bude implementována jen
určitá podmnožina AVX-512). <i>AVX-512</i> je v&nbsp;mnoha ohledech stejně
přelomové jako přechod na <i>AVX</i>, ovšem prozatím ho doprovází technické
problémy &ndash; některé procesory se při vykonávání nových instrukcí
<i>AVX-512</i> zpomalují, a to mnohdy až na 60% svého limitu (to však již
poněkud předbíháme).</p>



<p><a name="k02"></a></p>
<h2 id="k02">2. Od SSE k&nbsp;AVX a posléze k&nbsp;AVX-512</h2>

<p>Na technologii <i>AVX</i> se můžeme dívat jako na další krok, kterým se
původně čistě skalární architektura <i>x86</i> postupně rozšiřuje o vektorové
operace. V&nbsp;souladu <a
href="https://en.wikipedia.org/wiki/Moore%27s_law">s&nbsp;Moorovým zákonem</a>
totiž mohou výrobci mikroprocesorů vytvářet na čipech nové (a delší) registry,
zvětšovat počet aritmeticko-logických jednotek atd., což nepřímo přináší i
nutnost změn (rozšíření) instrukční sady. A přesně tento postupný vývoj můžeme
vidět i na platformě x86 a x86-64, která byla rozšířena o MMX, SSE(x), AVX(x) a
nyní o AVX-512. Kromě rozšíření instrukční sady se postupně zvětšoval i počet
pracovních registrů a taktéž jejich šířka. Ostatně tyto změny jsou patrné i
z&nbsp;následující tabulky:</p>

<table>
<tr><th> #</th><th>Typ registrů</th><th>Počet registrů (x86)</th><th>Počet registrů (x86-64)</th><th>Bitová šířka registru</th><th>Jména registrů</th></tr>
<tr><td>1</td><td>Pracovní registry MMX</td><td>8</td><td>8</td><td>64 bitů</td><td>MM0 .. MM7</td></tr>
<tr><td>2</td><td>Pracovní registry SSE</td><td>8</td><td>16</td><td>128 bitů</td><td>XMM0 .. XMM7 (XMM15)</td></tr>
<tr><td>3</td><td>Pracovní registry AVX</td><td>8</td><td>16</td><td>256 bitů</td><td>YMM0 .. YMM7 (YMM15)</td></tr>
<tr><td>4</td><td>Pracovní registry AVX-512</td><td>32</td><td>32</td><td>512 bitů</td><td>ZMM0 .. ZMM31</td></tr>
</table>

<p>Z&nbsp;výše uvedené tabulky je patrný dramatický skok v&nbsp;případě
AVX-512, kdy se zdvojnásobil (zečtyřnásobil) počet registrů a současně se i
zdvojnásobila jejich bitová šířka. Ve skutečnosti vznikly nové registry
<i>AVX</i> se jmény <strong>YMMx</strong> i registry <i>AVX-512</i> se jmény
<strong>ZMMx</strong> rozšířením registrů <i>SSE</i> na 256 nebo 512 bitů a
přidáním nových registrů. To například znamená, že operace s&nbsp;registrem
<strong>XMM0</strong> ve skutečnosti může změnit spodních 128 bitů registru
<strong>YMM0</strong> i <strong>ZMM0</strong>:</p>

<table>
<tr><th>512..256</th><th>255..128</th><th>127..0</th></tr>
<tr><td> ZMM0</td><td> YMM0</td><td> XMM0</td></tr>
<tr><td> ZMM1</td><td> YMM1</td><td> XMM1</td></tr>
<tr><td> ZMM2</td><td> YMM2</td><td> XMM2</td></tr>
<tr><td> ZMM3</td><td> YMM3</td><td> XMM3</td></tr>
<tr><td> ZMM4</td><td> YMM4</td><td> XMM4</td></tr>
<tr><td> ZMM5</td><td> YMM5</td><td> XMM5</td></tr>
<tr><td> ZMM6</td><td> YMM6</td><td> XMM6</td></tr>
<tr><td> ZMM7</td><td> YMM7</td><td> XMM7</td></tr>
<tr><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td></tr>
<tr><td> ZMM8</td><td> YMM8</td><td> XMM8</td></tr>
<tr><td> ZMM9</td><td> YMM9</td><td> XMM9</td></tr>
<tr><td>ZMM10</td><td>YMM10</td><td>XMM10</td></tr>
<tr><td>ZMM11</td><td>YMM11</td><td>XMM11</td></tr>
<tr><td>ZMM12</td><td>YMM12</td><td>XMM12</td></tr>
<tr><td>ZMM13</td><td>YMM13</td><td>XMM13</td></tr>
<tr><td>ZMM14</td><td>YMM14</td><td>XMM14</td></tr>
<tr><td>ZMM15</td><td>YMM15</td><td>XMM15</td></tr>
<tr><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td></tr>
<tr><td>ZMM16</td><td>YMM16</td><td>XMM16</td></tr>
<tr><td>ZMM17</td><td>YMM17</td><td>XMM17</td></tr>
<tr><td>ZMM18</td><td>YMM18</td><td>XMM18</td></tr>
<tr><td>ZMM19</td><td>YMM19</td><td>XMM19</td></tr>
<tr><td>ZMM20</td><td>YMM20</td><td>XMM20</td></tr>
<tr><td>ZMM21</td><td>YMM21</td><td>XMM21</td></tr>
<tr><td>ZMM22</td><td>YMM22</td><td>XMM22</td></tr>
<tr><td>ZMM23</td><td>YMM23</td><td>XMM23</td></tr>
<tr><td>ZMM24</td><td>YMM24</td><td>XMM24</td></tr>
<tr><td>ZMM25</td><td>YMM25</td><td>XMM25</td></tr>
<tr><td>ZMM26</td><td>YMM26</td><td>XMM26</td></tr>
<tr><td>ZMM27</td><td>YMM27</td><td>XMM27</td></tr>
<tr><td>ZMM28</td><td>YMM28</td><td>XMM28</td></tr>
<tr><td>ZMM29</td><td>YMM29</td><td>XMM29</td></tr>
<tr><td>ZMM30</td><td>YMM30</td><td>XMM30</td></tr>
<tr><td>ZMM31</td><td>YMM31</td><td>XMM31</td></tr>
</table>

<p><div class="rs-tip-major">Poznámka: vzhledem ke způsobu pojmenování
<strong>XMMx</strong> &rarr; <strong>YMMx</strong> &rarr; <strong>ZMMx</strong>
není zřejmé, jaká budou jména registrů v&nbsp;budoucím rozšíření. Podle ASCII
tabulky by jména měla začínat na <strong>[MMx</strong> :-)</div></p>



<p><a name="k03"></a></p>
<h2 id="k03">3. Datové typy podporované v&nbsp;instrukčních sadách AVX a AVX2</h2>

<p>Při použití technologie AVX se používají vektory o šířce 256 bitů. Tyto
vektory je možné rozdělit na celočíselné prvky popř.&nbsp;na prvky
s&nbsp;hodnotami reprezentovanými s&nbsp;využitím systému plovoucí řádové
čárky. V&nbsp;následující tabulce jsou všechny možné a podporované kombinace
vypsány:</p>

<table>
<tr><th>Typ v&nbsp;C</th><th>Význam</th><th>Deklarace</th></tr>
<tr><td>_v32qi</td><td>32 celočíselných prvků, každý o šířce 8bitů (pro C++)</td><td>typedef char __v32qi __attribute__ ((__vector_size__ (32)));</td></tr>
<tr><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td></tr>
<tr><td>_v32qs</td><td>32 celočíselných prvků se znaménkem, každý o šířce 8bitů</td><td>typedef signed char __v32qs __attribute__ ((__vector_size__ (32)));</td></tr>
<tr><td>_v16hi</td><td>16 celočíselných prvků se znaménkem, každý o šířce 16bitů</td><td>typedef short __v16hi __attribute__ ((__vector_size__ (32)));</td></tr>
<tr><td>_v8si</td><td>8 celočíselných prvků se znaménkem, každý o šířce 32bitů</td><td>typedef int __v8si __attribute__ ((__vector_size__ (32)));</td></tr>
<tr><td>_v4di</td><td>4 celočíselné prvky se znaménkem, každý o šířce 64bitů</td><td>typedef long long __v4di __attribute__ ((__vector_size__ (32)));</td></tr>
<tr><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td></tr>
<tr><td>_v32qu</td><td>32 celočíselných prvků bez znaménka, každý o šířce 8bitů</td><td>typedef unsigned char __v32qu __attribute__ ((__vector_size__ (32)));</td></tr>
<tr><td>_v16hu</td><td>16 celočíselných prvků bez znaménka, každý o šířce 16bitů</td><td>typedef unsigned short __v16hu __attribute__ ((__vector_size__ (32)));</td></tr>
<tr><td>_v8su</td><td>8 celočíselných prvků bez znaménka, každý o šířce 32bitů</td><td>typedef unsigned int __v8su __attribute__ ((__vector_size__ (32)));</td></tr>
<tr><td>_v4du</td><td>4 celočíselné prvky bez znaménka, každý o šířce 64bitů</td><td>typedef unsigned long long __v4du __attribute__ ((__vector_size__ (32)));</td></tr>
<tr><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td></tr>
<tr><td>_v8sf</td><td>osm prvků typu <i>float</i></td><td>typedef float __v8sf __attribute__ ((__vector_size__ (32)));</td></tr>
<tr><td>_v4df</td><td>čtyři prvky typu <i>double</i></td><td>typedef double __v4df __attribute__ ((__vector_size__ (32)));</td></tr>
</table>

<p>Což je vhodný doplněk ke (stále podporovaným) datovým typům pro SSE:</p>

<table>
<tr><th>Typ v&nbsp;C</th><th>Význam</th><th>Deklarace</th></tr>
<tr><td>_v16qi</td><td>16 celočíselných prvků, každý o šířce 8bitů (pro C++)</td><td>typedef char __v16qi __attribute__ ((__vector_size__ (16)));</td></tr>
<tr><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td></tr>
<tr><td>_v16qs</td><td>16 celočíselných prvků se znaménkem, každý o šířce 8bitů</td><td>typedef signed char __v16qs __attribute__ ((__vector_size__ (16)));</td></tr>
<tr><td>_v8hi</td><td>8 celočíselných prvků se znaménkem, každý o šířce 16bitů</td><td>typedef short __v8hi __attribute__ ((__vector_size__ (16)));</td></tr>
<tr><td>_v4si</td><td>4 celočíselné prvky se znaménkem, každý o šířce 32bitů</td><td>typedef int __v4si __attribute__ ((__vector_size__ (16)));</td></tr>
<tr><td>_v2di</td><td>2 celočíselné prvky se znaménkem, každý o šířce 64bitů</td><td>typedef long long __v2di __attribute__ ((__vector_size__ (16)));</td></tr>
<tr><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td></tr>
<tr><td>_v16qu</td><td>16 celočíselných prvků bez znaménka, každý o šířce 8bitů</td><td>typedef unsigned char __v16qu __attribute__ ((__vector_size__ (16)));</td></tr>
<tr><td>_v8hu</td><td>8 celočíselných prvků bez znaménka, každý o šířce 16bitů</td><td>typedef unsigned short __v8hu __attribute__ ((__vector_size__ (16)));</td></tr>
<tr><td>_v4su</td><td>4 celočíselné prvky bez znaménka, každý o šířce 32bitů</td><td>typedef unsigned int __v4su __attribute__ ((__vector_size__ (16)));</td></tr>
<tr><td>_v2du</td><td>2 celočíselné prvky bez znaménka, každý o šířce 64bitů</td><td>typedef unsigned long long __v2du __attribute__ ((__vector_size__ (16)));</td></tr>
<tr><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td></tr>
<tr><td>_v4sf</td><td>čtyři prvky typu <i>float</i></td><td>typedef float __v4sf __attribute__ ((__vector_size__ (16)));</td></tr>
<tr><td>_v2df</td><td>dva prvky typu <i>double</i></td><td>typedef double __v2df __attribute__ ((__vector_size__ (16)));</td></tr>
</table>



<p><a name="k04"></a></p>
<h2 id="k04">4. Tříadresový kód</h2>

<p>&bdquo;Novým objevem&ldquo; (ve skutečnosti starým přibližně padesát let) je
použití takzvaného <i>tříadresového kódu</i> v&nbsp;AVX instrukcích. Co to
znamená? V&nbsp;instrukčním slovu jsou zakódovány jak dva zdrojové operandy
(registry popř.&nbsp;adresa), tak i jeden cílový operand. To znamená, že
&ndash; na rozdíl od SSE &ndash; není jeden ze zdrojových operandů (konkrétně
registr) i operandem cílovým &ndash; není tedy přepsán výsledkem operace. To
může pomoci překladači s&nbsp;alokací registrů, ovšem navíc se mnohdy ušetří
operace kopie dat mezi dvojicí registrů.</p>

<p>Podívejme se na rozdíly mezi dvouadresovým a tříadresovým kódem u instrukce
součtu. Ve dvouadresovém kódu je jeden ze zdrojových registrů i registrem
cílovým:</p>

<pre>
   c:   0f 28 4d 10             movaps xmm1,XMMWORD PTR [rbp+0x10]
  10:   0f 28 45 30             movaps xmm0,XMMWORD PTR [rbp+0x30]
  14:   0f 58 c8                <strong>addps  xmm1,xmm0</strong>
</pre>

<p>U tříadresového kódu tomu tak není (navíc je jedním ze zdrojů adresa a
nikoli registr):</p>

<pre>
  1d:   c5 fc 28 44 24 e0       vmovaps ymm1,YMMWORD PTR [rsp-0x20]
  23:   c5 fc 58 44 24 c0       <strong>vaddps ymm0,ymm1,YMMWORD PTR [rsp-0x40]</strong>
</pre>

<p><div class="rs-tip-major">Poznámka: samozřejmě je nutné použít širší
instrukční slova, protože je nutné zakódovat index jednoho ze třiceti dvou
pracovních registrů.</div></p>



<p><a name="k05"></a></p>
<h2 id="k05">5. Nový způsob kódování instrukcí</h2>

<p>V&nbsp;souvislosti s&nbsp;AVX byl navržen nový (kolikátý už? asi osmý?)
způsob kódování instrukcí nazvaný <i>VEX</i>. Díky tomuto rozšíření bylo
umožněno jak zvýšení počtu instrukcí (s&nbsp;prostorem pro další rozšiřování),
tak i rozšíření vektorů ze 128 bitů na 256 bitů a v&nbsp;neposlední řadě je
taktéž ve VAX implementován <a href="#k04">výše zmíněný</a> <i>tříadresový
kód</i>.</p>

<p>Instrukce mají proměnnou délku (až jedenáct bajtů, nepočítaje v&nbsp;to
možné prefixy), jejich kódování je <i>velmi složité</i> a navíc existují kolize
v&nbsp;32bitovém režimu:</p>

<table>
<tr><th>Část</th><th>Délka v&nbsp;bajtech</th></tr>
<tr><td>prefixy</td><td>proměnná</td></tr>
<tr><td>VEX</td><td>0, 2 nebo 3</td></tr>
<tr><td>OPCODE</td><td>1</td></tr>
<tr><td>ModR/M</td><td>1</td></tr>
<tr><td>SIB</td><td>0 nebo 1</td></tr>
<tr><td>DISP</td><td>0, 1, 2 nebo 4</td></tr>
<tr><td>IMM</td><td>0 nebo 1</td></tr>
</table>

<p>V&nbsp;ModR/M je zakódován způsob adresování operandů, které muselo být
rozšířeno o SIB, v&nbsp;němž se specifikuje adresování přes index registr,
bázový registr nebo vynásobení offsetu krátkou konstantou (2, 4, ...). Navíc se
na x86-64 zavádí prefix REX, který modifikuje význam ModR/M tak, že lze použít
nové pracovní registry (uff). Krátce: dnes již nemá význam pokoušet se o
dekódování instrukcí ručně; lepší je se spolehnout na debuggery, disassemblery
nebo nástroj <strong>objdump</strong>.</p>

<p><div class="rs-tip-major">Poznámka: další rozšíření bylo zavedeno
v&nbsp;rámci AVX-512 a jmenuje se <i>EVEX</i>.</div></p>



<p><a name="k06"></a></p>
<h2 id="k06">6. Praktická část</h2>

<p>V&nbsp;praktické části dnešního článku si ve stručnosti ukážeme, jakým
způsobem jsou instrukce z&nbsp;rozšířené instrukční sady <i>AVX</i> a
<i>AVX2</i> podporovány v&nbsp;překladači GNU C, přičemž na tomto místě je
vhodné poznamenat, že velmi podobné konstrukce nalezneme i v&nbsp;dalších
překladačích (jedná se například <i>clang</i> pro <i>LLVM</i>, překladač
<i>icc</i> atd.). Nejdříve si řekneme, do jaké míry rozšíření GCC pro vektory
podporuje nové instrukce a nové vektory o délce 256 bitů (prozatím jsme
používali vektory o délce 128 bitů) a posléze si ukážeme i využití základních
<i>intrinsic</i>, tedy pseudofunkcí dostupných překladači, jejichž použití vede
k&nbsp;vložení nějaké instrukce <i>AVX</i> nebo <i>AVX2</i> do generovaného
strojového kódu (popř.&nbsp;do kódu v&nbsp;assembleru). Všechny dále uvedené
demonstrační příklady jsou pochopitelně otestovány, a to konkrétně na počítači
s&nbsp;mikroprocesorem <i>i7</i> s&nbsp;osmi (shodnými) jádry:</p>

<pre>
processor       : 0
vendor_id       : GenuineIntel
cpu family      : 6
model           : 142
model name      : Intel(R) Core(TM) i7-8665U CPU @ 1.90GHz
stepping        : 12
microcode       : 0xf0
cpu MHz         : 802.091
cache size      : 8192 KB
physical id     : 0
siblings        : 8
core id         : 0
cpu cores       : 4
apicid          : 0
initial apicid  : 0
fpu             : yes
fpu_exception   : yes
cpuid level     : 22
wp              : yes
flags           : fpu vme de pse tsc msr pae mce cx8 apic sep mtrr pge mca cmov pat pse36 clflush dts acpi mmx fxsr sse sse2 ss ht tm pbe syscall nx pdpe1gb rdtscp lm constant_tsc art arch_perfmon pebs bts rep_good nopl xtopology nonstop_tsc cpuid aperfmperf pni pclmulqdq dtes64 monitor ds_cpl vmx smx est tm2 ssse3 sdbg fma cx16 xtpr pdcm pcid sse4_1 sse4_2 x2apic movbe popcnt tsc_deadline_timer aes xsave <strong>avx</strong> f16c rdrand lahf_lm abm 3dnowprefetch cpuid_fault epb invpcid_single ssbd ibrs ibpb stibp ibrs_enhanced tpr_shadow vnmi flexpriority ept vpid ept_ad fsgsbase tsc_adjust bmi1 <strong>avx2</strong> smep bmi2 erms invpcid mpx rdseed adx smap clflushopt intel_pt xsaveopt xsavec xgetbv1 xsaves dtherm ida arat pln pts hwp hwp_notify hwp_act_window hwp_epp md_clear flush_l1d arch_capabilities
bugs            : spectre_v1 spectre_v2 spec_store_bypass swapgs taa itlb_multihit srbds mmio_stale_data
bogomips        : 4199.88
clflush size    : 64
cache_alignment : 64
address sizes   : 39 bits physical, 48 bits virtual
power management:
&nbsp;
processor       : 1
vendor_id       : GenuineIntel
cpu family      : 6
model           : 142
model name      : Intel(R) Core(TM) i7-8665U CPU @ 1.90GHz
stepping        : 12
microcode       : 0xf0
cpu MHz         : 800.618
cache size      : 8192 KB
physical id     : 0
siblings        : 8
core id         : 1
cpu cores       : 4
apicid          : 2
initial apicid  : 2
fpu             : yes
fpu_exception   : yes
cpuid level     : 22
wp              : yes
flags           : fpu vme de pse tsc msr pae mce cx8 apic sep mtrr pge mca cmov pat pse36 clflush dts acpi mmx fxsr sse sse2 ss ht tm pbe syscall nx pdpe1gb rdtscp lm constant_tsc art arch_perfmon pebs bts rep_good nopl xtopology nonstop_tsc cpuid aperfmperf pni pclmulqdq dtes64 monitor ds_cpl vmx smx est tm2 ssse3 sdbg fma cx16 xtpr pdcm pcid sse4_1 sse4_2 x2apic movbe popcnt tsc_deadline_timer aes xsave <strong>avx</strong> f16c rdrand lahf_lm abm 3dnowprefetch cpuid_fault epb invpcid_single ssbd ibrs ibpb stibp ibrs_enhanced tpr_shadow vnmi flexpriority ept vpid ept_ad fsgsbase tsc_adjust bmi1 <strong>avx2</strong> smep bmi2 erms invpcid mpx rdseed adx smap clflushopt intel_pt xsaveopt xsavec xgetbv1 xsaves dtherm ida arat pln pts hwp hwp_notify hwp_act_window hwp_epp md_clear flush_l1d arch_capabilities
bugs            : spectre_v1 spectre_v2 spec_store_bypass swapgs taa itlb_multihit srbds mmio_stale_data
bogomips        : 4199.88
clflush size    : 64
cache_alignment : 64
address sizes   : 39 bits physical, 48 bits virtual
power management:
&nbsp;
processor       : 2
vendor_id       : GenuineIntel
cpu family      : 6
model           : 142
model name      : Intel(R) Core(TM) i7-8665U CPU @ 1.90GHz
stepping        : 12
microcode       : 0xf0
cpu MHz         : 804.468
cache size      : 8192 KB
physical id     : 0
siblings        : 8
core id         : 2
cpu cores       : 4
apicid          : 4
initial apicid  : 4
fpu             : yes
fpu_exception   : yes
cpuid level     : 22
wp              : yes
flags           : fpu vme de pse tsc msr pae mce cx8 apic sep mtrr pge mca cmov pat pse36 clflush dts acpi mmx fxsr sse sse2 ss ht tm pbe syscall nx pdpe1gb rdtscp lm constant_tsc art arch_perfmon pebs bts rep_good nopl xtopology nonstop_tsc cpuid aperfmperf pni pclmulqdq dtes64 monitor ds_cpl vmx smx est tm2 ssse3 sdbg fma cx16 xtpr pdcm pcid sse4_1 sse4_2 x2apic movbe popcnt tsc_deadline_timer aes xsave <strong>avx</strong> f16c rdrand lahf_lm abm 3dnowprefetch cpuid_fault epb invpcid_single ssbd ibrs ibpb stibp ibrs_enhanced tpr_shadow vnmi flexpriority ept vpid ept_ad fsgsbase tsc_adjust bmi1 <strong>avx2</strong> smep bmi2 erms invpcid mpx rdseed adx smap clflushopt intel_pt xsaveopt xsavec xgetbv1 xsaves dtherm ida arat pln pts hwp hwp_notify hwp_act_window hwp_epp md_clear flush_l1d arch_capabilities
bugs            : spectre_v1 spectre_v2 spec_store_bypass swapgs taa itlb_multihit srbds mmio_stale_data
bogomips        : 4199.88
clflush size    : 64
cache_alignment : 64
address sizes   : 39 bits physical, 48 bits virtual
power management:
&nbsp;
processor       : 3
vendor_id       : GenuineIntel
cpu family      : 6
model           : 142
model name      : Intel(R) Core(TM) i7-8665U CPU @ 1.90GHz
stepping        : 12
microcode       : 0xf0
cpu MHz         : 827.064
cache size      : 8192 KB
physical id     : 0
siblings        : 8
core id         : 3
cpu cores       : 4
apicid          : 6
initial apicid  : 6
fpu             : yes
fpu_exception   : yes
cpuid level     : 22
wp              : yes
flags           : fpu vme de pse tsc msr pae mce cx8 apic sep mtrr pge mca cmov pat pse36 clflush dts acpi mmx fxsr sse sse2 ss ht tm pbe syscall nx pdpe1gb rdtscp lm constant_tsc art arch_perfmon pebs bts rep_good nopl xtopology nonstop_tsc cpuid aperfmperf pni pclmulqdq dtes64 monitor ds_cpl vmx smx est tm2 ssse3 sdbg fma cx16 xtpr pdcm pcid sse4_1 sse4_2 x2apic movbe popcnt tsc_deadline_timer aes xsave <strong>avx</strong> f16c rdrand lahf_lm abm 3dnowprefetch cpuid_fault epb invpcid_single ssbd ibrs ibpb stibp ibrs_enhanced tpr_shadow vnmi flexpriority ept vpid ept_ad fsgsbase tsc_adjust bmi1 <strong>avx2</strong> smep bmi2 erms invpcid mpx rdseed adx smap clflushopt intel_pt xsaveopt xsavec xgetbv1 xsaves dtherm ida arat pln pts hwp hwp_notify hwp_act_window hwp_epp md_clear flush_l1d arch_capabilities
bugs            : spectre_v1 spectre_v2 spec_store_bypass swapgs taa itlb_multihit srbds mmio_stale_data
bogomips        : 4199.88
clflush size    : 64
cache_alignment : 64
address sizes   : 39 bits physical, 48 bits virtual
power management:
&nbsp;
processor       : 4
vendor_id       : GenuineIntel
cpu family      : 6
model           : 142
model name      : Intel(R) Core(TM) i7-8665U CPU @ 1.90GHz
stepping        : 12
microcode       : 0xf0
cpu MHz         : 803.579
cache size      : 8192 KB
physical id     : 0
siblings        : 8
core id         : 0
cpu cores       : 4
apicid          : 1
initial apicid  : 1
fpu             : yes
fpu_exception   : yes
cpuid level     : 22
wp              : yes
flags           : fpu vme de pse tsc msr pae mce cx8 apic sep mtrr pge mca cmov pat pse36 clflush dts acpi mmx fxsr sse sse2 ss ht tm pbe syscall nx pdpe1gb rdtscp lm constant_tsc art arch_perfmon pebs bts rep_good nopl xtopology nonstop_tsc cpuid aperfmperf pni pclmulqdq dtes64 monitor ds_cpl vmx smx est tm2 ssse3 sdbg fma cx16 xtpr pdcm pcid sse4_1 sse4_2 x2apic movbe popcnt tsc_deadline_timer aes xsave <strong>avx</strong> f16c rdrand lahf_lm abm 3dnowprefetch cpuid_fault epb invpcid_single ssbd ibrs ibpb stibp ibrs_enhanced tpr_shadow vnmi flexpriority ept vpid ept_ad fsgsbase tsc_adjust bmi1 <strong>avx2</strong> smep bmi2 erms invpcid mpx rdseed adx smap clflushopt intel_pt xsaveopt xsavec xgetbv1 xsaves dtherm ida arat pln pts hwp hwp_notify hwp_act_window hwp_epp md_clear flush_l1d arch_capabilities
bugs            : spectre_v1 spectre_v2 spec_store_bypass swapgs taa itlb_multihit srbds mmio_stale_data
bogomips        : 4199.88
clflush size    : 64
cache_alignment : 64
address sizes   : 39 bits physical, 48 bits virtual
power management:
&nbsp;
processor       : 5
vendor_id       : GenuineIntel
cpu family      : 6
model           : 142
model name      : Intel(R) Core(TM) i7-8665U CPU @ 1.90GHz
stepping        : 12
microcode       : 0xf0
cpu MHz         : 805.257
cache size      : 8192 KB
physical id     : 0
siblings        : 8
core id         : 1
cpu cores       : 4
apicid          : 3
initial apicid  : 3
fpu             : yes
fpu_exception   : yes
cpuid level     : 22
wp              : yes
flags           : fpu vme de pse tsc msr pae mce cx8 apic sep mtrr pge mca cmov pat pse36 clflush dts acpi mmx fxsr sse sse2 ss ht tm pbe syscall nx pdpe1gb rdtscp lm constant_tsc art arch_perfmon pebs bts rep_good nopl xtopology nonstop_tsc cpuid aperfmperf pni pclmulqdq dtes64 monitor ds_cpl vmx smx est tm2 ssse3 sdbg fma cx16 xtpr pdcm pcid sse4_1 sse4_2 x2apic movbe popcnt tsc_deadline_timer aes xsave <strong>avx</strong> f16c rdrand lahf_lm abm 3dnowprefetch cpuid_fault epb invpcid_single ssbd ibrs ibpb stibp ibrs_enhanced tpr_shadow vnmi flexpriority ept vpid ept_ad fsgsbase tsc_adjust bmi1 <strong>avx2</strong> smep bmi2 erms invpcid mpx rdseed adx smap clflushopt intel_pt xsaveopt xsavec xgetbv1 xsaves dtherm ida arat pln pts hwp hwp_notify hwp_act_window hwp_epp md_clear flush_l1d arch_capabilities
bugs            : spectre_v1 spectre_v2 spec_store_bypass swapgs taa itlb_multihit srbds mmio_stale_data
bogomips        : 4199.88
clflush size    : 64
cache_alignment : 64
address sizes   : 39 bits physical, 48 bits virtual
power management:
&nbsp;
processor       : 6
vendor_id       : GenuineIntel
cpu family      : 6
model           : 142
model name      : Intel(R) Core(TM) i7-8665U CPU @ 1.90GHz
stepping        : 12
microcode       : 0xf0
cpu MHz         : 803.016
cache size      : 8192 KB
physical id     : 0
siblings        : 8
core id         : 2
cpu cores       : 4
apicid          : 5
initial apicid  : 5
fpu             : yes
fpu_exception   : yes
cpuid level     : 22
wp              : yes
flags           : fpu vme de pse tsc msr pae mce cx8 apic sep mtrr pge mca cmov pat pse36 clflush dts acpi mmx fxsr sse sse2 ss ht tm pbe syscall nx pdpe1gb rdtscp lm constant_tsc art arch_perfmon pebs bts rep_good nopl xtopology nonstop_tsc cpuid aperfmperf pni pclmulqdq dtes64 monitor ds_cpl vmx smx est tm2 ssse3 sdbg fma cx16 xtpr pdcm pcid sse4_1 sse4_2 x2apic movbe popcnt tsc_deadline_timer aes xsave <strong>avx</strong> f16c rdrand lahf_lm abm 3dnowprefetch cpuid_fault epb invpcid_single ssbd ibrs ibpb stibp ibrs_enhanced tpr_shadow vnmi flexpriority ept vpid ept_ad fsgsbase tsc_adjust bmi1 <strong>avx2</strong> smep bmi2 erms invpcid mpx rdseed adx smap clflushopt intel_pt xsaveopt xsavec xgetbv1 xsaves dtherm ida arat pln pts hwp hwp_notify hwp_act_window hwp_epp md_clear flush_l1d arch_capabilities
bugs            : spectre_v1 spectre_v2 spec_store_bypass swapgs taa itlb_multihit srbds mmio_stale_data
bogomips        : 4199.88
clflush size    : 64
cache_alignment : 64
address sizes   : 39 bits physical, 48 bits virtual
power management:
&nbsp;
processor       : 7
vendor_id       : GenuineIntel
cpu family      : 6
model           : 142
model name      : Intel(R) Core(TM) i7-8665U CPU @ 1.90GHz
stepping        : 12
microcode       : 0xf0
cpu MHz         : 799.372
cache size      : 8192 KB
physical id     : 0
siblings        : 8
core id         : 3
cpu cores       : 4
apicid          : 7
initial apicid  : 7
fpu             : yes
fpu_exception   : yes
cpuid level     : 22
wp              : yes
flags           : fpu vme de pse tsc msr pae mce cx8 apic sep mtrr pge mca cmov pat pse36 clflush dts acpi mmx fxsr sse sse2 ss ht tm pbe syscall nx pdpe1gb rdtscp lm constant_tsc art arch_perfmon pebs bts rep_good nopl xtopology nonstop_tsc cpuid aperfmperf pni pclmulqdq dtes64 monitor ds_cpl vmx smx est tm2 ssse3 sdbg fma cx16 xtpr pdcm pcid sse4_1 sse4_2 x2apic movbe popcnt tsc_deadline_timer aes xsave <strong>avx</strong> f16c rdrand lahf_lm abm 3dnowprefetch cpuid_fault epb invpcid_single ssbd ibrs ibpb stibp ibrs_enhanced tpr_shadow vnmi flexpriority ept vpid ept_ad fsgsbase tsc_adjust bmi1 <strong>avx2</strong> smep bmi2 erms invpcid mpx rdseed adx smap clflushopt intel_pt xsaveopt xsavec xgetbv1 xsaves dtherm ida arat pln pts hwp hwp_notify hwp_act_window hwp_epp md_clear flush_l1d arch_capabilities
bugs            : spectre_v1 spectre_v2 spec_store_bypass swapgs taa itlb_multihit srbds mmio_stale_data
bogomips        : 4199.88
clflush size    : 64
cache_alignment : 64
address sizes   : 39 bits physical, 48 bits virtual
power management:
</pre>
</pre>



<p><a name="k07"></a></p>
<h2 id="k07">7. Operace součtu vektorů o délce 256 bitů s&nbsp;celočíselnými prvky bez znaménka</h2>

<p>Nejprve si pro jednoduchost ukažme, jakým způsobem je možné provádět součty
256bitových vektorů (tedy vektorů o šířce třiceti dvou bajtů), v&nbsp;nichž
jsou uloženy celočíselné prvky. Na výběr jsou čtyři typy těchto vektorů
(minimálně v&nbsp;případě, že vynecháme celočíselný typ se šířkou 128 bitů,
který se příliš nepoužívá):</p>

<ol>
<li>32 prvků s&nbsp;šířkou 8bitů (<strong>unsigned char</strong>)</li>
<li>16 prvků s&nbsp;šířkou 16bitů (<strong>unsigned short</strong>)</li>
<li>8 prvků s&nbsp;šířkou 32bitů (<strong>unsigned int</strong>)</li>
<li>4 prvky s&nbsp;šířkou 64bitů (<strong>unsigned long</strong>)</li>
</ol>

<p>Všechny operace součtu jsou realizovány v&nbsp;tomto zdrojovém kódu:</p>

<pre>
#include &lt;stdio.h&gt;
&nbsp;
typedef unsigned char <strong>v32ub</strong> __attribute__((vector_size(32)));
&nbsp;
void add32ub(v32ub x, v32ub y, v32ub * z)
{
    *z = x + y;
}
&nbsp;
typedef unsigned short <strong>v32us</strong> __attribute__((vector_size(32)));
&nbsp;
void add32us(v32us x, v32us y, v32us * z)
{
    *z = x + y;
}
&nbsp;
typedef unsigned int <strong>v32ui</strong> __attribute__((vector_size(32)));
&nbsp;
void add32ui(v32ui x, v32ui y, v32ui * z)
{
    *z = x + y;
}
&nbsp;
typedef unsigned long int <strong>v32ul</strong> __attribute__((vector_size(32)));
&nbsp;
void add32ul(v32ul x, v32ul y, v32ul * z)
{
    *z = x + y;
}
&nbsp;
int main(void)
{
    {
        v32ub x =
            { 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17,
          18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31 };
        v32ub y =
            { 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
          0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
          0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
};
        v32ub z;
&nbsp;
        add32ub(x, y, &amp;z);
&nbsp;
        int i;
&nbsp;
        puts("vector of unsigned chars");

        for (i = 0; i &lt; sizeof(v32ub) / sizeof(unsigned char); i++) {
            printf("%d %u\n", i, z[i]);
        }
    }
&nbsp;
    putchar('\n');
&nbsp;
    {
        v32us x = { 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15 };
        v32us y =
            { 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,
          0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,
          0xffff };
        v32us z;
&nbsp;
        add32us(x, y, &amp;z);
&nbsp;
        int i;
&nbsp;
        puts("vector of unsigned short ints");
&nbsp;
        for (i = 0; i &lt; sizeof(v32us) / sizeof(unsigned short); i++) {
            printf("%d %u\n", i, z[i]);
        }
    }
&nbsp;
    putchar('\n');
&nbsp;
    {
        v32ui x = { 0, 1, 2, 3, 4, 5, 6, 7 };
        v32ui y =
            { 0xffffffff, 0xffffffff, 0xffffffff, 0xffffffff, 0xffffffff,
          0xffffffff, 0xffffffff, 0xffffffff };
        v32ui z;
&nbsp;
        add32ui(x, y, &amp;z);
&nbsp;
        int i;
&nbsp;
        puts("vector of unsigned ints");
&nbsp;
        for (i = 0; i &lt; sizeof(v32ui) / sizeof(unsigned int); i++) {
            printf("%d %u\n", i, z[i]);
        }
    }
&nbsp;
    putchar('\n');
&nbsp;
    {
        v32ul x = { 0, 1, 2, 3 };
        v32ul y =
            { 0xffffffffffffffff, 0xffffffffffffffff, 0xffffffffffffffff,
          0xffffffffffffffff };
        v32ul z;
&nbsp;
        add32ul(x, y, &amp;z);
&nbsp;
        int i;
&nbsp;
        puts("vector of unsigned longs");

        for (i = 0; i &lt; sizeof(v32ul) / sizeof(unsigned long); i++) {
            printf("%d %lu\n", i, z[i]);
        }
    }
&nbsp;
    return 0;
}
</pre>

<p>Výsledek získaný po překladu a spuštění tohoto demonstračního příkladu
ukazuje, jak (mj.&nbsp;) dochází k&nbsp;přetečení hodnot příslušných prvků, což
je očekávaná vlastnost:</p>

<pre>
vector of unsigned chars
0 255
1 0
2 1
3 2
4 3
5 4
6 5
7 6
8 7
9 8
10 9
11 10
12 11
13 12
14 13
15 14
16 15
17 16
18 17
19 18
20 19
21 20
22 21
23 22
24 23
25 24
26 25
27 26
28 27
29 28
30 29
31 30
&nbsp;
vector of unsigned short ints
0 65535
1 0
2 1
3 2
4 3
5 4
6 5
7 6
8 7
9 8
10 9
11 10
12 11
13 12
14 13
15 14
&nbsp;
vector of unsigned ints
0 4294967295
1 0
2 1
3 2
4 3
5 4
6 5
7 6
&nbsp;
vector of unsigned longs
0 18446744073709551615
1 0
2 1
3 2
</pre>



<p><a name="k08"></a></p>
<h2 id="k08">8. Překlad příkladu do assembleru s&nbsp;využitím instrukcí SSE, AVX, nebo AVX2</h2>

<p>Zdrojový kód zmíněný <a href="#k08">v&nbsp;předchozí kapitole</a> přeložíme
třemi způsoby:</p>

<ol>
<li>S&nbsp;využitím instrukční sady SSE, ale nikoli AVX</li>
<li>S&nbsp;využitím instrukční sady AVX</li>
<li>S&nbsp;využitím instrukční sady AVX2</li>
</ol>

<p>Vyzkoušejme si nejdřív překlad s&nbsp;využitím pouze SSE, nikoli ovšem
AVX:</p>

<pre>
$ <strong>gcc -c -O0 -msse -mno-avx -g</strong>
</pre>

<p>V&nbsp;tomto případě je každý součet implementován dvojicí instrukcí pro
součet 128bitových vektorů. Konkrétně se jedná o instrukce
<strong>paddb</strong>, <strong>paddw</strong>, <strong>paddd</strong> a
<strong>paddq</strong>. Povšimněte si, že se pracuje s&nbsp;registry
<strong>XMMx</strong>, konkrétně s&nbsp;registry <strong>XMM0</strong>,
<strong>XMM1</strong> a <strong>XMM2</strong>:</p>

<pre>
void add32ub(v32ub x, v32ub y, v32ub * z)
    *z = x + y;
   c:   66 0f 6f 4d 10          movdqa xmm1,XMMWORD PTR [rbp+0x10]
  11:   66 0f 6f 45 30          movdqa xmm0,XMMWORD PTR [rbp+0x30]
  16:   66 0f fc c8             <strong>paddb  xmm1,xmm0</strong>
  1a:   66 0f 6f 55 20          movdqa xmm2,XMMWORD PTR [rbp+0x20]
  1f:   66 0f 6f 45 40          movdqa xmm0,XMMWORD PTR [rbp+0x40]
  24:   66 0f fc c2             <strong>paddb  xmm0,xmm2</strong>
  28:   0f 29 4d a0             movaps XMMWORD PTR [rbp-0x60],xmm1
  2c:   0f 29 45 b0             movaps XMMWORD PTR [rbp-0x50],xmm0
&nbsp;
&nbsp;
&nbsp;
void add32us(v32us x, v32us y, v32us * z)
    *z = x + y;
  82:   66 0f 6f 4d 10          movdqa xmm1,XMMWORD PTR [rbp+0x10]
  87:   66 0f 6f 45 30          movdqa xmm0,XMMWORD PTR [rbp+0x30]
  8c:   66 0f fd c8             <strong>paddw  xmm1,xmm0</strong>
  90:   66 0f 6f 55 20          movdqa xmm2,XMMWORD PTR [rbp+0x20]
  95:   66 0f 6f 45 40          movdqa xmm0,XMMWORD PTR [rbp+0x40]
  9a:   66 0f fd c2             <strong>paddw  xmm0,xmm2</strong>
  9e:   0f 29 4d a0             movaps XMMWORD PTR [rbp-0x60],xmm1
  a2:   0f 29 45 b0             movaps XMMWORD PTR [rbp-0x50],xmm0
&nbsp;
&nbsp;
&nbsp;
void add32ui(v32ui x, v32ui y, v32ui * z)
    *z = x + y;
  f8:   66 0f 6f 4d 10          movdqa xmm1,XMMWORD PTR [rbp+0x10]
  fd:   66 0f 6f 45 30          movdqa xmm0,XMMWORD PTR [rbp+0x30]
 102:   66 0f fe c8             <strong>paddd  xmm1,xmm0</strong>
 106:   66 0f 6f 55 20          movdqa xmm2,XMMWORD PTR [rbp+0x20]
 10b:   66 0f 6f 45 40          movdqa xmm0,XMMWORD PTR [rbp+0x40]
 110:   66 0f fe c2             <strong>paddd  xmm0,xmm2</strong>
 114:   0f 29 4d a0             movaps XMMWORD PTR [rbp-0x60],xmm1
 118:   0f 29 45 b0             movaps XMMWORD PTR [rbp-0x50],xmm0
&nbsp;
&nbsp;
&nbsp;
void add32ul(v32ul x, v32ul y, v32ul * z)
    *z = x + y;
 16e:   66 0f 6f 4d 10          movdqa xmm1,XMMWORD PTR [rbp+0x10]
 173:   66 0f 6f 45 30          movdqa xmm0,XMMWORD PTR [rbp+0x30]
 178:   66 0f d4 c8             <strong>paddq  xmm1,xmm0</strong>
 17c:   66 0f 6f 55 20          movdqa xmm2,XMMWORD PTR [rbp+0x20]
 181:   66 0f 6f 45 40          movdqa xmm0,XMMWORD PTR [rbp+0x40]
 186:   66 0f d4 c2             <strong>paddq  xmm0,xmm2</strong>
 18a:   0f 29 4d a0             movaps XMMWORD PTR [rbp-0x60],xmm1
 18e:   0f 29 45 b0             movaps XMMWORD PTR [rbp-0x50],xmm0
</pre>

<p>Překlad s&nbsp;využitím instrukční sady AVX, ale nikoli AVX2:</p>

<pre>
$ <strong>gcc -c -O0 -mavx -g</strong>
</pre>

<p>V&nbsp;tomto případě se stále používají pracovní registry nazvané
<strong>XMM0</strong>, <strong>XMM1</strong> a <strong>XMM2</strong> a
pracující se 128bitovými vektory. Jedná se však o odlišné instrukce, konkrétně
o instrukce <strong>vpaddb</strong>, <strong>vpaddw</strong>,
<strong>vpaddd</strong> a <strong>vpaddq</strong>:</p>

<pre>
void add32ub(v32ub x, v32ub y, v32ub * z)
    *z = x + y;
  1d:   c5 f9 6f 4c 24 e0       vmovdqa xmm1,XMMWORD PTR [rsp-0x20]
  23:   c5 f9 6f 44 24 c0       vmovdqa xmm0,XMMWORD PTR [rsp-0x40]
  29:   c5 f1 fc c0             <strong>vpaddb xmm0,xmm1,xmm0</strong>
  2d:   c5 f9 6f 54 24 f0       vmovdqa xmm2,XMMWORD PTR [rsp-0x10]
  33:   c5 f9 6f 4c 24 d0       vmovdqa xmm1,XMMWORD PTR [rsp-0x30]
  39:   c5 e9 fc c9             <strong>vpaddb xmm1,xmm2,xmm1</strong>
&nbsp;
&nbsp;
&nbsp;
void add32us(v32us x, v32us y, v32us * z)
    *z = x + y;
  6c:   c5 f9 6f 4c 24 e0       vmovdqa xmm1,XMMWORD PTR [rsp-0x20]
  72:   c5 f9 6f 44 24 c0       vmovdqa xmm0,XMMWORD PTR [rsp-0x40]
  78:   c5 f1 fd c0             <strong>vpaddw xmm0,xmm1,xmm0</strong>
  7c:   c5 f9 6f 54 24 f0       vmovdqa xmm2,XMMWORD PTR [rsp-0x10]
  82:   c5 f9 6f 4c 24 d0       vmovdqa xmm1,XMMWORD PTR [rsp-0x30]
  88:   c5 e9 fd c9             <strong>vpaddw xmm1,xmm2,xmm1</strong>
&nbsp;
&nbsp;
&nbsp;
void add32ui(v32ui x, v32ui y, v32ui * z)
    *z = x + y;
  bb:   c5 f9 6f 4c 24 e0       vmovdqa xmm1,XMMWORD PTR [rsp-0x20]
  c1:   c5 f9 6f 44 24 c0       vmovdqa xmm0,XMMWORD PTR [rsp-0x40]
  c7:   c5 f1 fe c0             <strong>vpaddd xmm0,xmm1,xmm0</strong>
  cb:   c5 f9 6f 54 24 f0       vmovdqa xmm2,XMMWORD PTR [rsp-0x10]
  d1:   c5 f9 6f 4c 24 d0       vmovdqa xmm1,XMMWORD PTR [rsp-0x30]
  d7:   c5 e9 fe c9             <strong>vpaddd xmm1,xmm2,xmm1</strong>
&nbsp;
&nbsp;
&nbsp;
void add32ul(v32ul x, v32ul y, v32ul * z)
    *z = x + y;
 10a:   c5 f9 6f 4c 24 e0       vmovdqa xmm1,XMMWORD PTR [rsp-0x20]
 110:   c5 f9 6f 44 24 c0       vmovdqa xmm0,XMMWORD PTR [rsp-0x40]
 116:   c5 f1 d4 c0             <strong>vpaddq xmm0,xmm1,xmm0</strong>
 11a:   c5 f9 6f 54 24 f0       vmovdqa xmm2,XMMWORD PTR [rsp-0x10]
 120:   c5 f9 6f 4c 24 d0       vmovdqa xmm1,XMMWORD PTR [rsp-0x30]
 126:   c5 e9 d4 c9             <strong>vpaddq xmm1,xmm2,xmm1</strong>
</pre>

<p>Překlad s&nbsp;využitím instrukční sady AVX2:</p>

<pre>
$ <strong>gcc -c -O0 -mavx2 -g</strong>
</pre>

<p>Teprve nyní můžeme vidět použití 256bitových registrů <strong>YMMx</strong>
a dokonce i použití tříadresového kódu. Využívají se zde instrukce
<strong>vpaddb</strong>, <strong>vpaddw</strong>, <strong>vpaddd</strong> a
<strong>vpaddq</strong>:</p>

<pre>
void add32ub(v32ub x, v32ub y, v32ub * z)
    *z = x + y;
  1d:   c5 fd 6f 44 24 e0       vmovdqa ymm0,YMMWORD PTR [rsp-0x20]
  23:   c5 fd fc 44 24 c0       <strong>vpaddb ymm0,ymm0,YMMWORD PTR [rsp-0x40]</strong>
  29:   48 8b 44 24 b8          mov    rax,QWORD PTR [rsp-0x48]
  2e:   c5 fd 7f 00             vmovdqa YMMWORD PTR [rax],ymm0
&nbsp;
&nbsp;
&nbsp;
void add32us(v32us x, v32us y, v32us * z)
    *z = x + y;
  52:   c5 fd 6f 44 24 e0       vmovdqa ymm0,YMMWORD PTR [rsp-0x20]
  58:   c5 fd fd 44 24 c0       <strong>vpaddw ymm0,ymm0,YMMWORD PTR [rsp-0x40]</strong>
  5e:   48 8b 44 24 b8          mov    rax,QWORD PTR [rsp-0x48]
  63:   c5 fd 7f 00             vmovdqa YMMWORD PTR [rax],ymm0
&nbsp;
&nbsp;
&nbsp;
void add32ui(v32ui x, v32ui y, v32ui * z)
    *z = x + y;
  87:   c5 fd 6f 44 24 e0       vmovdqa ymm0,YMMWORD PTR [rsp-0x20]
  8d:   c5 fd fe 44 24 c0       <strong>vpaddd ymm0,ymm0,YMMWORD PTR [rsp-0x40]</strong>
  93:   48 8b 44 24 b8          mov    rax,QWORD PTR [rsp-0x48]
  98:   c5 fd 7f 00             vmovdqa YMMWORD PTR [rax],ymm0
&nbsp;
&nbsp;
&nbsp;
void add32ul(v32ul x, v32ul y, v32ul * z)
    *z = x + y;
  bc:   c5 fd 6f 44 24 e0       vmovdqa ymm0,YMMWORD PTR [rsp-0x20]
  c2:   c5 fd d4 44 24 c0       <strong>vpaddq ymm0,ymm0,YMMWORD PTR [rsp-0x40]</strong>
  c8:   48 8b 44 24 b8          mov    rax,QWORD PTR [rsp-0x48]
  cd:   c5 fd 7f 00             vmovdqa YMMWORD PTR [rax],ymm0
</pre>



<p><a name="k09"></a></p>
<h2 id="k09">9. Operace součtu vektorů o délce 256 bitů s&nbsp;celočíselnými prvky se znaménkem</h2>

<p>Demonstrační příklad <a href="#k07">ze sedmé kapitoly</a> je možné
velmi snadno přepsat takovým způsobem, že se do vektorů o délce 256 bitů uloží
celočíselné prvky se znaménkem. Opět se může jednat o čtyři standardní
kombinace:</p>

<ol>
<li>32 prvků s&nbsp;šířkou 8bitů (<strong>signed char</strong>)</li>
<li>16 prvků s&nbsp;šířkou 16bitů (<strong>signed short</strong>)</li>
<li>8 prvků s&nbsp;šířkou 32bitů (<strong>signed int</strong>)</li>
<li>4 prvky s&nbsp;šířkou 64bitů (<strong>signed long</strong>)</li>
</ol>

<p>Všechny operace součtu jsou realizovány v&nbsp;tomto zdrojovém kódu:</p>

<pre>
#include &lt;stdio.h&gt;
&nbsp;
typedef signed char <strong>v32sb</strong> __attribute__((vector_size(32)));
&nbsp;
void add32sb(v32sb x, v32sb y, v32sb * z)
{
    *z = x + y;
}
&nbsp;
typedef signed short <strong>v32ss</strong> __attribute__((vector_size(32)));
&nbsp;
void add32ss(v32ss x, v32ss y, v32ss * z)
{
    *z = x + y;
}
&nbsp;
typedef signed int <strong>v32si</strong> __attribute__((vector_size(32)));
&nbsp;
void add32si(v32si x, v32si y, v32si * z)
{
    *z = x + y;
}
&nbsp;
typedef signed long int <strong>v32sl</strong> __attribute__((vector_size(32)));
&nbsp;
void add32sl(v32sl x, v32sl y, v32sl * z)
{
    *z = x + y;
}
&nbsp;
int main(void)
{
    {
        v32sb x =
            { 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17,
          18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31 };
        v32sb y =
            { 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
          0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
          0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
};
        v32sb z;
&nbsp;
        add32sb(x, y, &amp;z);
&nbsp;
        int i;
&nbsp;
        puts("vector of signed chars");

        for (i = 0; i &lt; sizeof(v32sb) / sizeof(signed char); i++) {
            printf("%d %d\n", i, z[i]);
        }
    }
&nbsp;
    putchar('\n');
&nbsp;
    {
        v32ss x = { 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15 };
        v32ss y =
            { 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,
          0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,
          0xffff };
        v32ss z;
&nbsp;
        add32ss(x, y, &amp;z);
&nbsp;
        int i;
&nbsp;
        puts("vector of signed short ints");
&nbsp;
        for (i = 0; i &lt; sizeof(v32ss) / sizeof(signed short); i++) {
            printf("%d %d\n", i, z[i]);
        }
    }
&nbsp;
    putchar('\n');
&nbsp;
    {
        v32si x = { 0, 1, 2, 3, 4, 5, 6, 7 };
        v32si y =
            { 0xffffffff, 0xffffffff, 0xffffffff, 0xffffffff, 0xffffffff,
          0xffffffff, 0xffffffff, 0xffffffff };
        v32si z;
&nbsp;
        add32si(x, y, &amp;z);
&nbsp;
        int i;
&nbsp;
        puts("vector of signed ints");
&nbsp;
        for (i = 0; i &lt; sizeof(v32si) / sizeof(signed int); i++) {
            printf("%d %d\n", i, z[i]);
        }
    }
&nbsp;
    putchar('\n');
&nbsp;
    {
        v32sl x = { 0, 1, 2, 3 };
        v32sl y =
            { 0x7fffffffffffffff, 0x7fffffffffffffff, 0x7fffffffffffffff,
          0x7fffffffffffffff };
        v32sl z;
&nbsp;
        add32sl(x, y, &amp;z);
&nbsp;
        int i;
&nbsp;
        puts("vector of signed longs");
&nbsp;
        for (i = 0; i &lt; sizeof(v32sl) / sizeof(signed long); i++) {
            printf("%d %ld\n", i, z[i]);
        }
    }
&nbsp;
    return 0;
}
</pre>

<p>Výsledek získaný po překladu a spuštění tohoto demonstračního příkladu opět
ukazuje, jak dochází k&nbsp;přetečení hodnot (zde očekávanému):</p>

<pre>
vector of signed chars
0 -1
1 0
2 1
3 2
4 3
5 4
6 5
7 6
8 7
9 8
10 9
11 10
12 11
13 12
14 13
15 14
16 15
17 16
18 17
19 18
20 19
21 20
22 21
23 22
24 23
25 24
26 25
27 26
28 27
29 28
30 29
31 30
&nbsp;
vector of signed short ints
0 -1
1 0
2 1
3 2
4 3
5 4
6 5
7 6
8 7
9 8
10 9
11 10
12 11
13 12
14 13
15 14
&nbsp;
vector of signed ints
0 -1
1 0
2 1
3 2
4 3
5 4
6 5
7 6
&nbsp;
vector of signed longs
0 9223372036854775807
1 -9223372036854775808
2 -9223372036854775807
3 -9223372036854775806
</pre>



<p><a name="k10"></a></p>
<h2 id="k10">10. Překlad příkladu do assembleru s&nbsp;využitím instrukcí SSE, AVX, nebo AVX2</h2>

<p>Opět se podívejme na způsob překladu <a href="#k10">výše uvedeného
demonstračního příkladu</a> do assembleru, a to pro tři varianty zmíněné
výše:</p>

<ol>
<li>S&nbsp;využitím instrukční sady SSE, ale nikoli AVX</li>
<li>S&nbsp;využitím instrukční sady AVX</li>
<li>S&nbsp;využitím instrukční sady AVX2</li>
</ol>

<p>Překlad pro SSE opět využívá instrukce <strong>paddb</strong>,
<strong>paddw</strong>, <strong>paddd</strong> a <strong>paddq</strong> a
pracuje se 128bitovými registry <strong>XMMx</strong>, konkrétně
s&nbsp;registry <strong>XMM0</strong>, <strong>XMM1</strong> a
<strong>XMM2</strong>:</p>

<pre>
void add32sb(v32sb x, v32sb y, v32sb * z)
    *z = x + y;
   c:   66 0f 6f 4d 10          movdqa xmm1,XMMWORD PTR [rbp+0x10]
  11:   66 0f 6f 45 30          movdqa xmm0,XMMWORD PTR [rbp+0x30]
  16:   66 0f fc c8             <strong>paddb  xmm1,xmm0</strong>
  1a:   66 0f 6f 55 20          movdqa xmm2,XMMWORD PTR [rbp+0x20]
  1f:   66 0f 6f 45 40          movdqa xmm0,XMMWORD PTR [rbp+0x40]
  24:   66 0f fc c2             <strong>paddb  xmm0,xmm2</strong>
&nbsp;
&nbsp;
&nbsp;
void add32ss(v32ss x, v32ss y, v32ss * z)
    *z = x + y;
  82:   66 0f 6f 4d 10          movdqa xmm1,XMMWORD PTR [rbp+0x10]
  87:   66 0f 6f 45 30          movdqa xmm0,XMMWORD PTR [rbp+0x30]
  8c:   66 0f fd c8             <strong>paddw  xmm1,xmm0</strong>
  90:   66 0f 6f 55 20          movdqa xmm2,XMMWORD PTR [rbp+0x20]
  95:   66 0f 6f 45 40          movdqa xmm0,XMMWORD PTR [rbp+0x40]
  9a:   66 0f fd c2             <strong>paddw  xmm0,xmm2</strong>
&nbsp;
&nbsp;
&nbsp;
void add32si(v32si x, v32si y, v32si * z)
    *z = x + y;
  f8:   66 0f 6f 4d 10          movdqa xmm1,XMMWORD PTR [rbp+0x10]
  fd:   66 0f 6f 45 30          movdqa xmm0,XMMWORD PTR [rbp+0x30]
 102:   66 0f fe c8             <strong>paddd  xmm1,xmm0</strong>
 106:   66 0f 6f 55 20          movdqa xmm2,XMMWORD PTR [rbp+0x20]
 10b:   66 0f 6f 45 40          movdqa xmm0,XMMWORD PTR [rbp+0x40]
 110:   66 0f fe c2             <strong>paddd  xmm0,xmm2</strong>
&nbsp;
&nbsp;
&nbsp;
void add32sl(v32sl x, v32sl y, v32sl * z)
    *z = x + y;
 16e:   66 0f 6f 4d 10          movdqa xmm1,XMMWORD PTR [rbp+0x10]
 173:   66 0f 6f 45 30          movdqa xmm0,XMMWORD PTR [rbp+0x30]
 178:   66 0f d4 c8             <strong>paddq  xmm1,xmm0</strong>
 17c:   66 0f 6f 55 20          movdqa xmm2,XMMWORD PTR [rbp+0x20]
 181:   66 0f 6f 45 40          movdqa xmm0,XMMWORD PTR [rbp+0x40]
 186:   66 0f d4 c2             <strong>paddq  xmm0,xmm2</strong>
</pre>

<p>Překlad pro AVX je založen na použití registrů <strong>XMM0</strong>,
<strong>XMM1</strong> a <strong>XMM2</strong> pracujících se 128bitovými
vektory. Použity jsou ovšem instrukce <strong>vpaddb</strong>,
<strong>vpaddw</strong>, <strong>vpaddd</strong> a <strong>vpaddq</strong>:</p>

<pre>
typedef signed char v32sb __attribute__((vector_size(32)));
    *z = x + y;
  1d:   c5 f9 6f 4c 24 e0       vmovdqa xmm1,XMMWORD PTR [rsp-0x20]
  23:   c5 f9 6f 44 24 c0       vmovdqa xmm0,XMMWORD PTR [rsp-0x40]
  29:   c5 f1 fc c0             <strong>vpaddb xmm0,xmm1,xmm0</strong>
  2d:   c5 f9 6f 54 24 f0       vmovdqa xmm2,XMMWORD PTR [rsp-0x10]
  33:   c5 f9 6f 4c 24 d0       vmovdqa xmm1,XMMWORD PTR [rsp-0x30]
  39:   c5 e9 fc c9             <strong>vpaddb xmm1,xmm2,xmm1</strong>
&nbsp;
&nbsp;
&nbsp;
void add32ss(v32ss x, v32ss y, v32ss * z)
    *z = x + y;
  6c:   c5 f9 6f 4c 24 e0       vmovdqa xmm1,XMMWORD PTR [rsp-0x20]
  72:   c5 f9 6f 44 24 c0       vmovdqa xmm0,XMMWORD PTR [rsp-0x40]
  78:   c5 f1 fd c0             <strong>vpaddw xmm0,xmm1,xmm0</strong>
  7c:   c5 f9 6f 54 24 f0       vmovdqa xmm2,XMMWORD PTR [rsp-0x10]
  82:   c5 f9 6f 4c 24 d0       vmovdqa xmm1,XMMWORD PTR [rsp-0x30]
  88:   c5 e9 fd c9             <strong>vpaddw xmm1,xmm2,xmm1</strong>
&nbsp;
&nbsp;
&nbsp;
void add32si(v32si x, v32si y, v32si * z)
    *z = x + y;
  bb:   c5 f9 6f 4c 24 e0       vmovdqa xmm1,XMMWORD PTR [rsp-0x20]
  c1:   c5 f9 6f 44 24 c0       vmovdqa xmm0,XMMWORD PTR [rsp-0x40]
  c7:   c5 f1 fe c0             <strong>vpaddd xmm0,xmm1,xmm0</strong>
  cb:   c5 f9 6f 54 24 f0       vmovdqa xmm2,XMMWORD PTR [rsp-0x10]
  d1:   c5 f9 6f 4c 24 d0       vmovdqa xmm1,XMMWORD PTR [rsp-0x30]
  d7:   c5 e9 fe c9             <strong>vpaddd xmm1,xmm2,xmm1</strong>
&nbsp;
&nbsp;
&nbsp;
void add32sl(v32sl x, v32sl y, v32sl * z)
    *z = x + y;
 10a:   c5 f9 6f 4c 24 e0       vmovdqa xmm1,XMMWORD PTR [rsp-0x20]
 110:   c5 f9 6f 44 24 c0       vmovdqa xmm0,XMMWORD PTR [rsp-0x40]
 116:   c5 f1 d4 c0             <strong>vpaddq xmm0,xmm1,xmm0</strong>
 11a:   c5 f9 6f 54 24 f0       vmovdqa xmm2,XMMWORD PTR [rsp-0x10]
 120:   c5 f9 6f 4c 24 d0       vmovdqa xmm1,XMMWORD PTR [rsp-0x30]
 126:   c5 e9 d4 c9             <strong>vpaddq xmm1,xmm2,xmm1</strong>
</pre>

<p>Překlad pro AVX2 s&nbsp;využitím instrukcí <strong>vpaddb</strong>,
<strong>vpaddw</strong>, <strong>vpaddd</strong> a <strong>vpaddq</strong>,
tříadresového kódu a 256bitových registrů:</p>

<pre>
void add32sb(v32sb x, v32sb y, v32sb * z)
    *z = x + y;
  1d:   c5 fd 6f 44 24 e0       vmovdqa ymm0,YMMWORD PTR [rsp-0x20]
  23:   c5 fd fc 44 24 c0       <strong>vpaddb ymm0,ymm0,YMMWORD PTR [rsp-0x40]</strong>
  29:   48 8b 44 24 b8          mov    rax,QWORD PTR [rsp-0x48]
  2e:   c5 fd 7f 00             vmovdqa YMMWORD PTR [rax],ymm0
&nbsp;
&nbsp;
&nbsp;
void add32ss(v32ss x, v32ss y, v32ss * z)
    *z = x + y;
  52:   c5 fd 6f 44 24 e0       vmovdqa ymm0,YMMWORD PTR [rsp-0x20]
  58:   c5 fd fd 44 24 c0       <strong>vpaddw ymm0,ymm0,YMMWORD PTR [rsp-0x40]</strong>
  5e:   48 8b 44 24 b8          mov    rax,QWORD PTR [rsp-0x48]
  63:   c5 fd 7f 00             vmovdqa YMMWORD PTR [rax],ymm0
&nbsp;
&nbsp;
&nbsp;
void add32si(v32si x, v32si y, v32si * z)
    *z = x + y;
  87:   c5 fd 6f 44 24 e0       vmovdqa ymm0,YMMWORD PTR [rsp-0x20]
  8d:   c5 fd fe 44 24 c0       <strong>vpaddd ymm0,ymm0,YMMWORD PTR [rsp-0x40]</strong>
  93:   48 8b 44 24 b8          mov    rax,QWORD PTR [rsp-0x48]
  98:   c5 fd 7f 00             vmovdqa YMMWORD PTR [rax],ymm0
&nbsp;
&nbsp;
&nbsp;
void add32sl(v32sl x, v32sl y, v32sl * z)
    *z = x + y;
  bc:   c5 fd 6f 44 24 e0       vmovdqa ymm0,YMMWORD PTR [rsp-0x20]
  c2:   c5 fd d4 44 24 c0       <strong>vpaddq ymm0,ymm0,YMMWORD PTR [rsp-0x40]</strong>
  c8:   48 8b 44 24 b8          mov    rax,QWORD PTR [rsp-0x48]
  cd:   c5 fd 7f 00             vmovdqa YMMWORD PTR [rax],ymm0
</pre>



<p><a name="k11"></a></p>
<h2 id="k11">11. Operace součtu vektorů o délce 256 bitů s&nbsp;prvky typu <i>float</i> a <i>double</i></h2>

<p>Posledním demonstračním příkladem, v&nbsp;němž budeme používat standardní
jazyk C rozšířený pouze o datový typ &bdquo;vektor zadané délky&ldquo; bude
příklad, v&nbsp;němž se provádí součet dvou vektorů o délce 256 bitů
s&nbsp;prvky typu <i>float</i> (první část příkladu) a <i>double</i> (druhá
část příkladu):</p>

<pre>
#include &lt;stdio.h&gt;
&nbsp;
typedef float <strong>v32float</strong> __attribute__((vector_size(32)));
&nbsp;
void add32float(v32float x, v32float y, v32float * z)
{
    *z = x + y;
}
&nbsp;
typedef double <strong>v32double</strong> __attribute__((vector_size(32)));
&nbsp;
void add32double(v32double x, v32double y, v32double * z)
{
    *z = x + y;
}
&nbsp;
int main(void)
{
    {
        v32float x = { 1.0, 2.0, 3.0, 4.0, 5.0, 6.0, 7.0, 8.0 };
        v32float y = { 0.5, 0.5, 0.5, 0.5, 0.5, 0.5, 0.5, 0.5 };
        v32float z;
        int i;
&nbsp;
        add32float(x, y, &amp;z);
&nbsp;
        puts("vector of floats");
&nbsp;
        for (i = 0; i &lt; sizeof(v32float) / sizeof(float); i++) {
            printf("%d     %f + %f = %f\n", i, x[i], y[i], z[i]);
        }
    }
&nbsp;
    putchar('\n');
&nbsp;
    {
        v32double x = { 1.0, 2.0, 3.0, 4.0 };
        v32double y = { 0.5, 0.5, 0.5, 0.5 };
        v32double z;
        int i;
&nbsp;
        add32double(x, y, &amp;z);
&nbsp;
        puts("vector of doubles");
&nbsp;
        for (i = 0; i &lt; sizeof(v32double) / sizeof(double); i++) {
            printf("%d     %f + %f = %f\n", i, x[i], y[i], z[i]);
        }
    }
&nbsp;
    return 0;
}
</pre>

<p>Výsledky získané po spuštění tohoto demonstračního příkladu by měly vypadat
následovně:</p>

<pre>
vector of floats
0     1.000000 + 0.500000 = 1.500000
1     2.000000 + 0.500000 = 2.500000
2     3.000000 + 0.500000 = 3.500000
3     4.000000 + 0.500000 = 4.500000
4     5.000000 + 0.500000 = 5.500000
5     6.000000 + 0.500000 = 6.500000
6     7.000000 + 0.500000 = 7.500000
7     8.000000 + 0.500000 = 8.500000
&nbsp;
vector of doubles
0     1.000000 + 0.500000 = 1.500000
1     2.000000 + 0.500000 = 2.500000
2     3.000000 + 0.500000 = 3.500000
3     4.000000 + 0.500000 = 4.500000
</pre>



<p><a name="k12"></a></p>
<h2 id="k12">12. Překlad příkladu do assembleru s&nbsp;využitím instrukcí SSE, AVX, nebo AVX2 &ndash; varianta pro <i>float</i></h2>

<p>Podívejme se nejdříve na překlad operací součtu v&nbsp;případě použití
instrukční sady SSE. V&nbsp;této variantě je použita dvojice instrukcí
<strong>addps</strong>, z&nbsp;nichž každá sečte 128bitový vektor:</p>

<pre>
void add32float(v32float x, v32float y, v32float * z)
    *z = x + y;
   c:   0f 28 4d 10             movaps xmm1,XMMWORD PTR [rbp+0x10]
  10:   0f 28 45 30             movaps xmm0,XMMWORD PTR [rbp+0x30]
  14:   0f 58 c8                <strong>addps  xmm1,xmm0</strong>
  17:   0f 28 55 20             movaps xmm2,XMMWORD PTR [rbp+0x20]
  1b:   0f 28 45 40             movaps xmm0,XMMWORD PTR [rbp+0x40]
  1f:   0f 58 c2                <strong>addps  xmm0,xmm2</strong>
  22:   0f 29 4d a0             movaps XMMWORD PTR [rbp-0x60],xmm1
  26:   0f 29 45 b0             movaps XMMWORD PTR [rbp-0x50],xmm0
</pre>

<p>Dále si ukážeme, jakým způsobem je součet vektorů implementován
s&nbsp;využitím instrukční sady AVX. Výpočet je založen na použití jediné
instrukce <strong>vaddps</strong> s&nbsp;tříadresovým kódem a 256bitovými
registry <strong>YMMx</strong>:</p>

<pre>
void add32float(v32float x, v32float y, v32float * z)
    *z = x + y;
  1d:   c5 fc 28 44 24 e0       vmovaps ymm0,YMMWORD PTR [rsp-0x20]
  23:   c5 fc 58 44 24 c0       <strong>vaddps ymm0,ymm0,YMMWORD PTR [rsp-0x40]</strong>
  29:   48 8b 44 24 b8          mov    rax,QWORD PTR [rsp-0x48]
  2e:   c5 fc 29 00             vmovaps YMMWORD PTR [rax],ymm0
</pre>

<p>A konečně se podíváme na to, jakým způsobem je součet vektorů implementován
s&nbsp;využitím instrukční sady AVX2. Zde je naprosto stejný, jako při použití
AVX!:</p>

<pre>
void add32float(v32float x, v32float y, v32float * z)
    *z = x + y;
  1d:   c5 fc 28 44 24 e0       vmovaps ymm0,YMMWORD PTR [rsp-0x20]
  23:   c5 fc 58 44 24 c0       <strong>vaddps ymm0,ymm0,YMMWORD PTR [rsp-0x40]</strong>
  29:   48 8b 44 24 b8          mov    rax,QWORD PTR [rsp-0x48]
  2e:   c5 fc 29 00             vmovaps YMMWORD PTR [rax],ymm0
</pre>



<p><a name="k13"></a></p>
<h2 id="k13">13. Překlad příkladu do assembleru s&nbsp;využitím instrukcí SSE, AVX, nebo AVX2 &ndash; varianta pro <i>double</i></h2>

<p>Překlad s&nbsp;využitím instrukcí SSE (a nikoli AVX) vede k&nbsp;použití
dvojice instrukcí <strong>addpd</strong>, z&nbsp;nichž každá sečte 128bitový
vektor:</p>

<pre>
void add32double(v32double x, v32double y, v32double * z)
    *z = x + y;
  7c:   66 0f 28 4d 10          movapd xmm1,XMMWORD PTR [rbp+0x10]
  81:   66 0f 28 45 30          movapd xmm0,XMMWORD PTR [rbp+0x30]
  86:   66 0f 58 c8             <strong>addpd  xmm1,xmm0</strong>
  8a:   66 0f 28 55 20          movapd xmm2,XMMWORD PTR [rbp+0x20]
  8f:   66 0f 28 45 40          movapd xmm0,XMMWORD PTR [rbp+0x40]
  94:   66 0f 58 c2             <strong>addpd  xmm0,xmm2</strong>
  98:   0f 29 4d a0             movaps XMMWORD PTR [rbp-0x60],xmm1
  9c:   0f 29 45 b0             movaps XMMWORD PTR [rbp-0x50],xmm0
</pre>

<p>Realizace výpočtu s&nbsp;využitím AVX se (jak uvidíme o odstavec níže) nijak
neliší od AVX2. Vše je založeno na instrukci <strong>vaddpd</strong>:</p>

<pre>
void add32double(v32double x, v32double y, v32double * z)
    *z = x + y;
  52:   c5 fd 28 44 24 e0       vmovapd ymm0,YMMWORD PTR [rsp-0x20]
  58:   c5 fd 58 44 24 c0       <strong>vaddpd ymm0,ymm0,YMMWORD PTR [rsp-0x40]</strong>
  5e:   48 8b 44 24 b8          mov    rax,QWORD PTR [rsp-0x48]
  63:   c5 fd 29 00             vmovapd YMMWORD PTR [rax],ymm0
</pre>

<p>Součet realizovaný instrukcemi ze sady AVX2 je založen na operaci
<strong>vaddpd</strong>, jinak se (opět) neliší od varianty <i>float</i>:</p>

<pre>
void add32double(v32double x, v32double y, v32double * z)
    *z = x + y;
  52:   c5 fd 28 44 24 e0       vmovapd ymm0,YMMWORD PTR [rsp-0x20]
  58:   c5 fd 58 44 24 c0       <strong>vaddpd ymm0,ymm0,YMMWORD PTR [rsp-0x40]</strong>
  5e:   48 8b 44 24 b8          mov    rax,QWORD PTR [rsp-0x48]
  63:   c5 fd 29 00             vmovapd YMMWORD PTR [rax],ymm0
</pre>



<p><a name="k14"></a></p>
<h2 id="k14">14. Intrinsic v&nbsp;GCC pro instrukce AVX</h2>

<p>V&nbsp;případě, že se při překladu zdrojových kódů s&nbsp;využitím GCC C
použije přepínač <strong>-mavx</strong>, bude mít vývojář automaticky
k&nbsp;dispozici následující nové <i>intrinsic</i>:</p>

<pre>
v4df __builtin_ia32_addpd256 (v4df,v4df);
v8sf __builtin_ia32_addps256 (v8sf,v8sf);
v4df __builtin_ia32_addsubpd256 (v4df,v4df);
v8sf __builtin_ia32_addsubps256 (v8sf,v8sf);
v4df __builtin_ia32_andnpd256 (v4df,v4df);
v8sf __builtin_ia32_andnps256 (v8sf,v8sf);
v4df __builtin_ia32_andpd256 (v4df,v4df);
v8sf __builtin_ia32_andps256 (v8sf,v8sf);
v4df __builtin_ia32_blendpd256 (v4df,v4df,int);
v8sf __builtin_ia32_blendps256 (v8sf,v8sf,int);
v4df __builtin_ia32_blendvpd256 (v4df,v4df,v4df);
v8sf __builtin_ia32_blendvps256 (v8sf,v8sf,v8sf);
v2df __builtin_ia32_cmppd (v2df,v2df,int);
v4df __builtin_ia32_cmppd256 (v4df,v4df,int);
v4sf __builtin_ia32_cmpps (v4sf,v4sf,int);
v8sf __builtin_ia32_cmpps256 (v8sf,v8sf,int);
v2df __builtin_ia32_cmpsd (v2df,v2df,int);
v4sf __builtin_ia32_cmpss (v4sf,v4sf,int);
v4df __builtin_ia32_cvtdq2pd256 (v4si);
v8sf __builtin_ia32_cvtdq2ps256 (v8si);
v4si __builtin_ia32_cvtpd2dq256 (v4df);
v4sf __builtin_ia32_cvtpd2ps256 (v4df);
v8si __builtin_ia32_cvtps2dq256 (v8sf);
v4df __builtin_ia32_cvtps2pd256 (v4sf);
v4si __builtin_ia32_cvttpd2dq256 (v4df);
v8si __builtin_ia32_cvttps2dq256 (v8sf);
v4df __builtin_ia32_divpd256 (v4df,v4df);
v8sf __builtin_ia32_divps256 (v8sf,v8sf);
v8sf __builtin_ia32_dpps256 (v8sf,v8sf,int);
v4df __builtin_ia32_haddpd256 (v4df,v4df);
v8sf __builtin_ia32_haddps256 (v8sf,v8sf);
v4df __builtin_ia32_hsubpd256 (v4df,v4df);
v8sf __builtin_ia32_hsubps256 (v8sf,v8sf);
v32qi __builtin_ia32_lddqu256 (pcchar);
v32qi __builtin_ia32_loaddqu256 (pcchar);
v4df __builtin_ia32_loadupd256 (pcdouble);
v8sf __builtin_ia32_loadups256 (pcfloat);
v2df __builtin_ia32_maskloadpd (pcv2df,v2df);
v4df __builtin_ia32_maskloadpd256 (pcv4df,v4df);
v4sf __builtin_ia32_maskloadps (pcv4sf,v4sf);
v8sf __builtin_ia32_maskloadps256 (pcv8sf,v8sf);
void __builtin_ia32_maskstorepd (pv2df,v2df,v2df);
void __builtin_ia32_maskstorepd256 (pv4df,v4df,v4df);
void __builtin_ia32_maskstoreps (pv4sf,v4sf,v4sf);
void __builtin_ia32_maskstoreps256 (pv8sf,v8sf,v8sf);
v4df __builtin_ia32_maxpd256 (v4df,v4df);
v8sf __builtin_ia32_maxps256 (v8sf,v8sf);
v4df __builtin_ia32_minpd256 (v4df,v4df);
v8sf __builtin_ia32_minps256 (v8sf,v8sf);
v4df __builtin_ia32_movddup256 (v4df);
int __builtin_ia32_movmskpd256 (v4df);
int __builtin_ia32_movmskps256 (v8sf);
v8sf __builtin_ia32_movshdup256 (v8sf);
v8sf __builtin_ia32_movsldup256 (v8sf);
v4df __builtin_ia32_mulpd256 (v4df,v4df);
v8sf __builtin_ia32_mulps256 (v8sf,v8sf);
v4df __builtin_ia32_orpd256 (v4df,v4df);
v8sf __builtin_ia32_orps256 (v8sf,v8sf);
v2df __builtin_ia32_pd_pd256 (v4df);
v4df __builtin_ia32_pd256_pd (v2df);
v4sf __builtin_ia32_ps_ps256 (v8sf);
v8sf __builtin_ia32_ps256_ps (v4sf);
int __builtin_ia32_ptestc256 (v4di,v4di,ptest);
int __builtin_ia32_ptestnzc256 (v4di,v4di,ptest);
int __builtin_ia32_ptestz256 (v4di,v4di,ptest);
v8sf __builtin_ia32_rcpps256 (v8sf);
v4df __builtin_ia32_roundpd256 (v4df,int);
v8sf __builtin_ia32_roundps256 (v8sf,int);
v8sf __builtin_ia32_rsqrtps_nr256 (v8sf);
v8sf __builtin_ia32_rsqrtps256 (v8sf);
v4df __builtin_ia32_shufpd256 (v4df,v4df,int);
v8sf __builtin_ia32_shufps256 (v8sf,v8sf,int);
v4si __builtin_ia32_si_si256 (v8si);
v8si __builtin_ia32_si256_si (v4si);
v4df __builtin_ia32_sqrtpd256 (v4df);
v8sf __builtin_ia32_sqrtps_nr256 (v8sf);
v8sf __builtin_ia32_sqrtps256 (v8sf);
void __builtin_ia32_storedqu256 (pchar,v32qi);
void __builtin_ia32_storeupd256 (pdouble,v4df);
void __builtin_ia32_storeups256 (pfloat,v8sf);
v4df __builtin_ia32_subpd256 (v4df,v4df);
v8sf __builtin_ia32_subps256 (v8sf,v8sf);
v4df __builtin_ia32_unpckhpd256 (v4df,v4df);
v8sf __builtin_ia32_unpckhps256 (v8sf,v8sf);
v4df __builtin_ia32_unpcklpd256 (v4df,v4df);
v8sf __builtin_ia32_unpcklps256 (v8sf,v8sf);
v4df __builtin_ia32_vbroadcastf128_pd256 (pcv2df);
v8sf __builtin_ia32_vbroadcastf128_ps256 (pcv4sf);
v4df __builtin_ia32_vbroadcastsd256 (pcdouble);
v4sf __builtin_ia32_vbroadcastss (pcfloat);
v8sf __builtin_ia32_vbroadcastss256 (pcfloat);
v2df __builtin_ia32_vextractf128_pd256 (v4df,int);
v4sf __builtin_ia32_vextractf128_ps256 (v8sf,int);
v4si __builtin_ia32_vextractf128_si256 (v8si,int);
v4df __builtin_ia32_vinsertf128_pd256 (v4df,v2df,int);
v8sf __builtin_ia32_vinsertf128_ps256 (v8sf,v4sf,int);
v8si __builtin_ia32_vinsertf128_si256 (v8si,v4si,int);
v4df __builtin_ia32_vperm2f128_pd256 (v4df,v4df,int);
v8sf __builtin_ia32_vperm2f128_ps256 (v8sf,v8sf,int);
v8si __builtin_ia32_vperm2f128_si256 (v8si,v8si,int);
v2df __builtin_ia32_vpermil2pd (v2df,v2df,v2di,int);
v4df __builtin_ia32_vpermil2pd256 (v4df,v4df,v4di,int);
v4sf __builtin_ia32_vpermil2ps (v4sf,v4sf,v4si,int);
v8sf __builtin_ia32_vpermil2ps256 (v8sf,v8sf,v8si,int);
v2df __builtin_ia32_vpermilpd (v2df,int);
v4df __builtin_ia32_vpermilpd256 (v4df,int);
v4sf __builtin_ia32_vpermilps (v4sf,int);
v8sf __builtin_ia32_vpermilps256 (v8sf,int);
v2df __builtin_ia32_vpermilvarpd (v2df,v2di);
v4df __builtin_ia32_vpermilvarpd256 (v4df,v4di);
v4sf __builtin_ia32_vpermilvarps (v4sf,v4si);
v8sf __builtin_ia32_vpermilvarps256 (v8sf,v8si);
int __builtin_ia32_vtestcpd (v2df,v2df,ptest);
int __builtin_ia32_vtestcpd256 (v4df,v4df,ptest);
int __builtin_ia32_vtestcps (v4sf,v4sf,ptest);
int __builtin_ia32_vtestcps256 (v8sf,v8sf,ptest);
int __builtin_ia32_vtestnzcpd (v2df,v2df,ptest);
int __builtin_ia32_vtestnzcpd256 (v4df,v4df,ptest);
int __builtin_ia32_vtestnzcps (v4sf,v4sf,ptest);
int __builtin_ia32_vtestnzcps256 (v8sf,v8sf,ptest);
int __builtin_ia32_vtestzpd (v2df,v2df,ptest);
int __builtin_ia32_vtestzpd256 (v4df,v4df,ptest);
int __builtin_ia32_vtestzps (v4sf,v4sf,ptest);
int __builtin_ia32_vtestzps256 (v8sf,v8sf,ptest);
void __builtin_ia32_vzeroall (void);
void __builtin_ia32_vzeroupper (void);
v4df __builtin_ia32_xorpd256 (v4df,v4df);
v8sf __builtin_ia32_xorps256 (v8sf,v8sf);
</pre>



<p><a name="k15"></a></p>
<h2 id="k15">15. Intrinsic v&nbsp;GCC pro instrukce AVX2</h2>

<p>Dalších několik desítek <i>intrinsic</i> bude k&nbsp;dispozici
v&nbsp;případě, že se použije přepínač <strong>-mavx2</strong>; pochopitelně za
předpokladu, že cílový procesor bude tyto instrukce rozpoznávat a provádět:</p>

<pre>
v32qi __builtin_ia32_mpsadbw256 (v32qi,v32qi,int);
v32qi __builtin_ia32_pabsb256 (v32qi);
v16hi __builtin_ia32_pabsw256 (v16hi);
v8si __builtin_ia32_pabsd256 (v8si);
v16hi __builtin_ia32_packssdw256 (v8si,v8si);
v32qi __builtin_ia32_packsswb256 (v16hi,v16hi);
v16hi __builtin_ia32_packusdw256 (v8si,v8si);
v32qi __builtin_ia32_packuswb256 (v16hi,v16hi);
v32qi __builtin_ia32_paddb256 (v32qi,v32qi);
v16hi __builtin_ia32_paddw256 (v16hi,v16hi);
v8si __builtin_ia32_paddd256 (v8si,v8si);
v4di __builtin_ia32_paddq256 (v4di,v4di);
v32qi __builtin_ia32_paddsb256 (v32qi,v32qi);
v16hi __builtin_ia32_paddsw256 (v16hi,v16hi);
v32qi __builtin_ia32_paddusb256 (v32qi,v32qi);
v16hi __builtin_ia32_paddusw256 (v16hi,v16hi);
v4di __builtin_ia32_palignr256 (v4di,v4di,int);
v4di __builtin_ia32_andsi256 (v4di,v4di);
v4di __builtin_ia32_andnotsi256 (v4di,v4di);
v32qi __builtin_ia32_pavgb256 (v32qi,v32qi);
v16hi __builtin_ia32_pavgw256 (v16hi,v16hi);
v32qi __builtin_ia32_pblendvb256 (v32qi,v32qi,v32qi);
v16hi __builtin_ia32_pblendw256 (v16hi,v16hi,int);
v32qi __builtin_ia32_pcmpeqb256 (v32qi,v32qi);
v16hi __builtin_ia32_pcmpeqw256 (v16hi,v16hi);
v8si __builtin_ia32_pcmpeqd256 (c8si,v8si);
v4di __builtin_ia32_pcmpeqq256 (v4di,v4di);
v32qi __builtin_ia32_pcmpgtb256 (v32qi,v32qi);
v16hi __builtin_ia32_pcmpgtw256 (16hi,v16hi);
v8si __builtin_ia32_pcmpgtd256 (v8si,v8si);
v4di __builtin_ia32_pcmpgtq256 (v4di,v4di);
v16hi __builtin_ia32_phaddw256 (v16hi,v16hi);
v8si __builtin_ia32_phaddd256 (v8si,v8si);
v16hi __builtin_ia32_phaddsw256 (v16hi,v16hi);
v16hi __builtin_ia32_phsubw256 (v16hi,v16hi);
v8si __builtin_ia32_phsubd256 (v8si,v8si);
v16hi __builtin_ia32_phsubsw256 (v16hi,v16hi);
v32qi __builtin_ia32_pmaddubsw256 (v32qi,v32qi);
v16hi __builtin_ia32_pmaddwd256 (v16hi,v16hi);
v32qi __builtin_ia32_pmaxsb256 (v32qi,v32qi);
v16hi __builtin_ia32_pmaxsw256 (v16hi,v16hi);
v8si __builtin_ia32_pmaxsd256 (v8si,v8si);
v32qi __builtin_ia32_pmaxub256 (v32qi,v32qi);
v16hi __builtin_ia32_pmaxuw256 (v16hi,v16hi);
v8si __builtin_ia32_pmaxud256 (v8si,v8si);
v32qi __builtin_ia32_pminsb256 (v32qi,v32qi);
v16hi __builtin_ia32_pminsw256 (v16hi,v16hi);
v8si __builtin_ia32_pminsd256 (v8si,v8si);
v32qi __builtin_ia32_pminub256 (v32qi,v32qi);
v16hi __builtin_ia32_pminuw256 (v16hi,v16hi);
v8si __builtin_ia32_pminud256 (v8si,v8si);
int __builtin_ia32_pmovmskb256 (v32qi);
v16hi __builtin_ia32_pmovsxbw256 (v16qi);
v8si __builtin_ia32_pmovsxbd256 (v16qi);
v4di __builtin_ia32_pmovsxbq256 (v16qi);
v8si __builtin_ia32_pmovsxwd256 (v8hi);
v4di __builtin_ia32_pmovsxwq256 (v8hi);
v4di __builtin_ia32_pmovsxdq256 (v4si);
v16hi __builtin_ia32_pmovzxbw256 (v16qi);
v8si __builtin_ia32_pmovzxbd256 (v16qi);
v4di __builtin_ia32_pmovzxbq256 (v16qi);
v8si __builtin_ia32_pmovzxwd256 (v8hi);
v4di __builtin_ia32_pmovzxwq256 (v8hi);
v4di __builtin_ia32_pmovzxdq256 (v4si);
v4di __builtin_ia32_pmuldq256 (v8si,v8si);
v16hi __builtin_ia32_pmulhrsw256 (v16hi, v16hi);
v16hi __builtin_ia32_pmulhuw256 (v16hi,v16hi);
v16hi __builtin_ia32_pmulhw256 (v16hi,v16hi);
v16hi __builtin_ia32_pmullw256 (v16hi,v16hi);
v8si __builtin_ia32_pmulld256 (v8si,v8si);
v4di __builtin_ia32_pmuludq256 (v8si,v8si);
v4di __builtin_ia32_por256 (v4di,v4di);
v16hi __builtin_ia32_psadbw256 (v32qi,v32qi);
v32qi __builtin_ia32_pshufb256 (v32qi,v32qi);
v8si __builtin_ia32_pshufd256 (v8si,int);
v16hi __builtin_ia32_pshufhw256 (v16hi,int);
v16hi __builtin_ia32_pshuflw256 (v16hi,int);
v32qi __builtin_ia32_psignb256 (v32qi,v32qi);
v16hi __builtin_ia32_psignw256 (v16hi,v16hi);
v8si __builtin_ia32_psignd256 (v8si,v8si);
v4di __builtin_ia32_pslldqi256 (v4di,int);
v16hi __builtin_ia32_psllwi256 (16hi,int);
v16hi __builtin_ia32_psllw256(v16hi,v8hi);
v8si __builtin_ia32_pslldi256 (v8si,int);
v8si __builtin_ia32_pslld256(v8si,v4si);
v4di __builtin_ia32_psllqi256 (v4di,int);
v4di __builtin_ia32_psllq256(v4di,v2di);
v16hi __builtin_ia32_psrawi256 (v16hi,int);
v16hi __builtin_ia32_psraw256 (v16hi,v8hi);
v8si __builtin_ia32_psradi256 (v8si,int);
v8si __builtin_ia32_psrad256 (v8si,v4si);
v4di __builtin_ia32_psrldqi256 (v4di, int);
v16hi __builtin_ia32_psrlwi256 (v16hi,int);
v16hi __builtin_ia32_psrlw256 (v16hi,v8hi);
v8si __builtin_ia32_psrldi256 (v8si,int);
v8si __builtin_ia32_psrld256 (v8si,v4si);
v4di __builtin_ia32_psrlqi256 (v4di,int);
v4di __builtin_ia32_psrlq256(v4di,v2di);
v32qi __builtin_ia32_psubb256 (v32qi,v32qi);
v32hi __builtin_ia32_psubw256 (v16hi,v16hi);
v8si __builtin_ia32_psubd256 (v8si,v8si);
v4di __builtin_ia32_psubq256 (v4di,v4di);
v32qi __builtin_ia32_psubsb256 (v32qi,v32qi);
v16hi __builtin_ia32_psubsw256 (v16hi,v16hi);
v32qi __builtin_ia32_psubusb256 (v32qi,v32qi);
v16hi __builtin_ia32_psubusw256 (v16hi,v16hi);
v32qi __builtin_ia32_punpckhbw256 (v32qi,v32qi);
v16hi __builtin_ia32_punpckhwd256 (v16hi,v16hi);
v8si __builtin_ia32_punpckhdq256 (v8si,v8si);
v4di __builtin_ia32_punpckhqdq256 (v4di,v4di);
v32qi __builtin_ia32_punpcklbw256 (v32qi,v32qi);
v16hi __builtin_ia32_punpcklwd256 (v16hi,v16hi);
v8si __builtin_ia32_punpckldq256 (v8si,v8si);
v4di __builtin_ia32_punpcklqdq256 (v4di,v4di);
v4di __builtin_ia32_pxor256 (v4di,v4di);
v4di __builtin_ia32_movntdqa256 (pv4di);
v4sf __builtin_ia32_vbroadcastss_ps (v4sf);
v8sf __builtin_ia32_vbroadcastss_ps256 (v4sf);
v4df __builtin_ia32_vbroadcastsd_pd256 (v2df);
v4di __builtin_ia32_vbroadcastsi256 (v2di);
v4si __builtin_ia32_pblendd128 (v4si,v4si);
v8si __builtin_ia32_pblendd256 (v8si,v8si);
v32qi __builtin_ia32_pbroadcastb256 (v16qi);
v16hi __builtin_ia32_pbroadcastw256 (v8hi);
v8si __builtin_ia32_pbroadcastd256 (v4si);
v4di __builtin_ia32_pbroadcastq256 (v2di);
v16qi __builtin_ia32_pbroadcastb128 (v16qi);
v8hi __builtin_ia32_pbroadcastw128 (v8hi);
v4si __builtin_ia32_pbroadcastd128 (v4si);
v2di __builtin_ia32_pbroadcastq128 (v2di);
v8si __builtin_ia32_permvarsi256 (v8si,v8si);
v4df __builtin_ia32_permdf256 (v4df,int);
v8sf __builtin_ia32_permvarsf256 (v8sf,v8sf);
v4di __builtin_ia32_permdi256 (v4di,int);
v4di __builtin_ia32_permti256 (v4di,v4di,int);
v4di __builtin_ia32_extract128i256 (v4di,int);
v4di __builtin_ia32_insert128i256 (v4di,v2di,int);
v8si __builtin_ia32_maskloadd256 (pcv8si,v8si);
v4di __builtin_ia32_maskloadq256 (pcv4di,v4di);
v4si __builtin_ia32_maskloadd (pcv4si,v4si);
v2di __builtin_ia32_maskloadq (pcv2di,v2di);
void __builtin_ia32_maskstored256 (pv8si,v8si,v8si);
void __builtin_ia32_maskstoreq256 (pv4di,v4di,v4di);
void __builtin_ia32_maskstored (pv4si,v4si,v4si);
void __builtin_ia32_maskstoreq (pv2di,v2di,v2di);
v8si __builtin_ia32_psllv8si (v8si,v8si);
v4si __builtin_ia32_psllv4si (v4si,v4si);
v4di __builtin_ia32_psllv4di (v4di,v4di);
v2di __builtin_ia32_psllv2di (v2di,v2di);
v8si __builtin_ia32_psrav8si (v8si,v8si);
v4si __builtin_ia32_psrav4si (v4si,v4si);
v8si __builtin_ia32_psrlv8si (v8si,v8si);
v4si __builtin_ia32_psrlv4si (v4si,v4si);
v4di __builtin_ia32_psrlv4di (v4di,v4di);
v2di __builtin_ia32_psrlv2di (v2di,v2di);
v2df __builtin_ia32_gathersiv2df (v2df, pcdouble,v4si,v2df,int);
v4df __builtin_ia32_gathersiv4df (v4df, pcdouble,v4si,v4df,int);
v2df __builtin_ia32_gatherdiv2df (v2df, pcdouble,v2di,v2df,int);
v4df __builtin_ia32_gatherdiv4df (v4df, pcdouble,v4di,v4df,int);
v4sf __builtin_ia32_gathersiv4sf (v4sf, pcfloat,v4si,v4sf,int);
v8sf __builtin_ia32_gathersiv8sf (v8sf, pcfloat,v8si,v8sf,int);
v4sf __builtin_ia32_gatherdiv4sf (v4sf, pcfloat,v2di,v4sf,int);
v4sf __builtin_ia32_gatherdiv4sf256 (v4sf, pcfloat,v4di,v4sf,int);
v2di __builtin_ia32_gathersiv2di (v2di, pcint64,v4si,v2di,int);
v4di __builtin_ia32_gathersiv4di (v4di, pcint64,v4si,v4di,int);
v2di __builtin_ia32_gatherdiv2di (v2di, pcint64,v2di,v2di,int);
v4di __builtin_ia32_gatherdiv4di (v4di, pcint64,v4di,v4di,int);
v4si __builtin_ia32_gathersiv4si (v4si, pcint,v4si,v4si,int);
v8si __builtin_ia32_gathersiv8si (v8si, pcint,v8si,v8si,int);
v4si __builtin_ia32_gatherdiv4si (v4si, pcint,v2di,v4si,int);
v4si __builtin_ia32_gatherdiv4si256 (v4si, pcint,v4di,v4si,int);
</pre>



<p><a name="k16"></a></p>
<h2 id="k16">16. Intrinsic <strong>__builtin_ia32_addps256</strong> &ndash; součet vektorů s&nbsp;prvky typu <i>float</i></h2>

<p>Pro součet dvou 256bitových vektorů obsahujících osm prvků typu <i>float</i>
je v&nbsp;GCC C k&nbsp;dispozici intrinsic nazvaná
<strong>__builtin_ia32_addps256</strong>. Tuto intrinsic si můžeme velmi snadno
otestovat:</p>

<pre>
#include &lt;stdio.h&gt;
#include &lt;immintrin.h&gt;
&nbsp;
int main(void)
{
    __v8sf x = { 1.0, 2.0, 3.0, 4.0, 5.0, 6.0, 7.0, 8.0 };
    __v8sf y = { 0.1, 0.1, 0.1, 0.1, 0.1, 0.1, 0.1, 0.1 };
    __v8sf z;
    int i;
&nbsp;
    z = <strong>__builtin_ia32_addps256(x, y)</strong>;
&nbsp;
    for (i = 0; i &lt; sizeof(x) / sizeof(float); i++) {
        printf("%2d %f %f %f\n", i, x[i], y[i], z[i]);
    }
}
</pre>

<p>S&nbsp;výsledkem:</p>

<pre>
 0 1.000000 0.100000 1.100000
 1 2.000000 0.100000 2.100000
 2 3.000000 0.100000 3.100000
 3 4.000000 0.100000 4.100000
 4 5.000000 0.100000 5.100000
 5 6.000000 0.100000 6.100000
 6 7.000000 0.100000 7.100000
 7 8.000000 0.100000 8.100000
</pre>

<p>Překlad této instrukce do assembleru je přímočarý:</p>

<pre>
    z = __builtin_ia32_addps256(x, y);
  4a:   c5 fc 28 45 90          vmovaps ymm0,YMMWORD PTR [rbp-0x70]
  4f:   c5 fc 28 8d 70 ff ff    vmovaps ymm1,YMMWORD PTR [rbp-0x90]
  56:   ff 
  57:   c5 f4 58 c0             <strong>vaddps ymm0,ymm1,ymm0</strong>
  5b:   c5 fc 29 45 b0          vmovaps YMMWORD PTR [rbp-0x50],ymm0
</pre>

<p><div class="rs-tip-major">Poznámka: povšimněte si, že je sice použit
tříadresový kód, ovšem registr <strong>YMM0</strong> je současně registrem
zdrojovým i cílovým.</div></p>



<p><a name="k17"></a></p>
<h2 id="k17">17. Intrinsic <strong>__builtin_ia32_addpd256</strong> &ndash; součet vektorů s&nbsp;prvky typu <i>double</i></h2>

<p>V&nbsp;případě, že se má sečíst dvojice vektorů popř.&nbsp;matic
s&nbsp;prvky typu <i>double</i>, můžeme takovou operaci rozdělit na součet po
čtveřicích hodnot typu <i>double</i>. V&nbsp;tomto případě se tedy bude
v&nbsp;každé iteraci sčítat vektor o délce 256 bitů a použije se intrinsic
<strong>__builtin_ia32_addpd256</strong>:</p>

<pre>
#include &lt;stdio.h&gt;
#include &lt;immintrin.h&gt;
&nbsp;
int main(void)
{
    __v4df x = { 1.0, 2.0, 3.0, 4.0 };
    __v4df y = { 0.1, 0.1, 0.1, 0.1 };
    __v4df z;
    int i;
&nbsp;
    z = <strong>__builtin_ia32_addpd256(x, y)</strong>;
&nbsp;
    for (i = 0; i &lt; sizeof(x) / sizeof(double); i++) {
        printf("%2d %f %f %f\n", i, x[i], y[i], z[i]);
    }
}
</pre>

<p>Výsledek:</p>

<pre>
 0 1.000000 0.100000 1.100000
 1 2.000000 0.100000 2.100000
 2 3.000000 0.100000 3.100000
 3 4.000000 0.100000 4.100000
</pre>

<p>A takto vypadá překlad intrinsic do assembleru:</p>

<pre>
    z = __builtin_ia32_addpd256(x, y);
  4a:   c5 fd 28 45 90          vmovapd ymm0,YMMWORD PTR [rbp-0x70]
  4f:   c5 fd 28 8d 70 ff ff    vmovapd ymm1,YMMWORD PTR [rbp-0x90]
  56:   ff 
  57:   c5 f5 58 c0             <strong>vaddpd ymm0,ymm1,ymm0</strong>
  5b:   c5 fd 29 45 b0          vmovapd YMMWORD PTR [rbp-0x50],ymm0
</pre>



<p><a name="k18"></a></p>
<h2 id="k18">18. Výběr prvků do cílového vektoru pomocí intrinsic <strong>__builtin_ia32_blendps256</strong></h2>

<p>V&nbsp;rozšíření instrukční sady AVX nalezneme celou řadu zajímavých
instrukcí, z&nbsp;nichž mnohé mají poněkud matoucí jméno. Týká se to například
instrukce nazvané <a
href="https://www.felixcloutier.com/x86/blendps">BLENDPS</a> pro typ
<i>single/float</i> a <a
href="https://www.felixcloutier.com/x86/blendpd">BLENDPD</a> pro typ
<i>double</i>. Tato instrukce, i když to její název naznačuje, ovšem neprovádí
<i>blending</i> hodnot uložených ve dvou vektorech na základě zadané váhy
(<i>blending factor</i>, což může být u obrázků <i>alfa kanál</i>). Tato
instrukce sice skutečně &bdquo;michá&ldquo; prvky dvou vektorů, ovšem na
základě celočíselné konstanty, která obsahuje binárně zakódované
<i>selektory</i>. Nejlépe se prováděná operace ukáže na dvou vektorech,
z&nbsp;nichž každý obsahuje osm prvků typu <i>single/float</i>. Celočíselná
konstanta v&nbsp;tomto případě obsahuje osm významových bitů, z&nbsp;nichž
každý bit určuje, zda se daný <i>n-tý</i> prvek výsledného vektoru získá
z&nbsp;vektoru prvního nebo naopak z&nbsp;vektoru druhého.</p>

<p>Podívejme se nyní na příklad, v&nbsp;němž se postupně používají
konstanty/selektory 0x55 (tedy 0b01010101) 0xf0 (0b11110000) a 0x0f
(0b00001111):</p>

<pre>
#include &lt;stdio.h&gt;
#include &lt;immintrin.h&gt;
&nbsp;
int main(void)
{
    __v8sf x = { 1.0, 2.0, 3.0, 4.0, 5.0, 6.0, 7.0, 8.0 };
    __v8sf y = { 0.1, 0.2, 0.3, 0.4, 0.5, 0.6, 0.7, 0.8 };
    __v8sf z;
    int i;
&nbsp;
    z = <strong>__builtin_ia32_blendps256(x, y, 0x55)</strong>;
&nbsp;
    for (i = 0; i &lt; sizeof(x) / sizeof(float); i++) {
        printf("%2d %f %f %f\n", i, x[i], y[i], z[i]);
    }
&nbsp;
    putchar('\n');
&nbsp;
    z = <strong>__builtin_ia32_blendps256(x, y, 0xf0)</strong>;
&nbsp;
    for (i = 0; i &lt; sizeof(x) / sizeof(float); i++) {
        printf("%2d %f %f %f\n", i, x[i], y[i], z[i]);
    }
&nbsp;
    putchar('\n');
&nbsp;
    z = <strong>__builtin_ia32_blendps256(x, y, 0x0f)</strong>;
&nbsp;
    for (i = 0; i &lt; sizeof(x) / sizeof(float); i++) {
        printf("%2d %f %f %f\n", i, x[i], y[i], z[i]);
    }
}
</pre>

<p>Výsledek výpočtů vypadá následovně (hodnoty z&nbsp;prvního vektoru, které se
dostaly do výsledku, jsou zvýrazněny):</p>

<pre>
 0 1.000000 0.100000 0.100000
 1 2.000000 0.200000 <strong>2.000000</strong>
 2 3.000000 0.300000 0.300000
 3 4.000000 0.400000 <strong>4.000000</strong>
 4 5.000000 0.500000 0.500000
 5 6.000000 0.600000 <strong>6.000000</strong>
 6 7.000000 0.700000 0.700000
 7 8.000000 0.800000 <strong>8.000000</strong>
&nbsp;
 0 1.000000 0.100000 <strong>1.000000</strong>
 1 2.000000 0.200000 <strong>2.000000</strong>
 2 3.000000 0.300000 <strong>3.000000</strong>
 3 4.000000 0.400000 <strong>4.000000</strong>
 4 5.000000 0.500000 0.500000
 5 6.000000 0.600000 0.600000
 6 7.000000 0.700000 0.700000
 7 8.000000 0.800000 0.800000
&nbsp;
 0 1.000000 0.100000 0.100000
 1 2.000000 0.200000 0.200000
 2 3.000000 0.300000 0.300000
 3 4.000000 0.400000 0.400000
 4 5.000000 0.500000 <strong>5.000000</strong>
 5 6.000000 0.600000 <strong>6.000000</strong>
 6 7.000000 0.700000 <strong>7.000000</strong>
 7 8.000000 0.800000 <strong>8.000000</strong>
</pre>

<p>Způsob překladu této intrinsic do assembleru je založen na použití instrukce
<strong>vblendps</strong> (nebo jen <strong>blendps</strong>), kde
<strong>s</strong> na konci značí operaci s&nbsp;vektorem s&nbsp;prvky typu
<i>single</i> neboli <i>float</i>:</p>

<pre>
    z = __builtin_ia32_blendps256(x, y, 0x55);
  4a:   c5 fc 28 4d 90          vmovaps ymm1,YMMWORD PTR [rbp-0x70]
  4f:   c5 fc 28 85 70 ff ff    vmovaps ymm0,YMMWORD PTR [rbp-0x90]
  56:   ff 
  57:   c4 e3 7d 0c c1 55       <strong>vblendps ymm0,ymm0,ymm1,0x55</strong>
  5d:   c5 fc 29 45 b0          vmovaps YMMWORD PTR [rbp-0x50],ymm0
&nbsp;
    z = __builtin_ia32_blendps256(x, y, 0xf0);
  dc:   c5 fc 28 4d 90          vmovaps ymm1,YMMWORD PTR [rbp-0x70]
  e1:   c5 fc 28 85 70 ff ff    vmovaps ymm0,YMMWORD PTR [rbp-0x90]
  e8:   ff 
  e9:   c4 e3 7d 0c c1 f0       <strong>vblendps ymm0,ymm0,ymm1,0xf0</strong>
  ef:   c5 fc 29 45 b0          vmovaps YMMWORD PTR [rbp-0x50],ymm0
&nbsp;
    z = __builtin_ia32_blendps256(x, y, 0x0f);
 16e:   c5 fc 28 4d 90          vmovaps ymm1,YMMWORD PTR [rbp-0x70]
 173:   c5 fc 28 85 70 ff ff    vmovaps ymm0,YMMWORD PTR [rbp-0x90]
 17a:   ff 
 17b:   c4 e3 7d 0c c1 0f       <strong>vblendps ymm0,ymm0,ymm1,0xf</strong>
 181:   c5 fc 29 45 b0          vmovaps YMMWORD PTR [rbp-0x50],ymm0
</pre>



<p><a name="k19"></a></p>
<h2 id="k19">19. Repositář s&nbsp;demonstračními příklady</h2>

<p>Demonstrační příklady napsané v&nbsp;jazyku C, které jsou určené pro překlad
pomocí překladače <strong>GCC C</strong>, byly uložen do Git repositáře, který
je dostupný na adrese <a
href="https://github.com/tisnik/presentations">https://github.com/tisnik/presentations</a>.
Jednotlivé demonstrační příklady si můžete v&nbsp;případě potřeby stáhnout i
jednotlivě bez nutnosti klonovat celý (dnes již poměrně velmi rozsáhlý)
repositář:</p>

<table>
<tr><th> #</th><th>Příklad</th><th>Stručný popis</th><th>Adresa</th></tr>
<tr><td> 1</td><td>simd01.c</td><td>vektor celých čísel typu <strong>short int</strong></td><td><a href="https://github.com/tisnik/presentations/blob/master/SIMD/simd01.c">https://github.com/tisnik/presentations/blob/master/SIMD/simd01.c</a></td></tr>
<tr><td> 2</td><td>simd02.c</td><td>ukázka použití vektorů s&nbsp;celočíselnými typy bez znaménka</td><td><a href="https://github.com/tisnik/presentations/blob/master/SIMD/simd02.c">https://github.com/tisnik/presentations/blob/master/SIMD/simd02.c</a></td></tr>
<tr><td> 3</td><td>simd03.c</td><td>ukázka použití vektorů s&nbsp;celočíselnými typy se znaménkem</td><td><a href="https://github.com/tisnik/presentations/blob/master/SIMD/simd03.c">https://github.com/tisnik/presentations/blob/master/SIMD/simd03.c</a></td></tr>
<tr><td> 4</td><td>simd04.c</td><td>paralelní součet celočíselných prvků vektorů</td><td><a href="https://github.com/tisnik/presentations/blob/master/SIMD/simd04.c">https://github.com/tisnik/presentations/blob/master/SIMD/simd04.c</a></td></tr>
<tr><td> 5</td><td>simd04B.c</td><td>úprava pro další datové typy</td><td><a href="https://github.com/tisnik/presentations/blob/master/SIMD/simd04B.c">https://github.com/tisnik/presentations/blob/master/SIMD/simd04B.c</a></td></tr>
<tr><td> 6</td><td>simd05.c</td><td>přístup k&nbsp;jednotlivým prvkům vektorů</td><td><a href="https://github.com/tisnik/presentations/blob/master/SIMD/simd05.c">https://github.com/tisnik/presentations/blob/master/SIMD/simd05.c</a></td></tr>
<tr><td> 7</td><td>simd05B.c</td><td>korektnější výpočet počtu prvků vektoru</td><td><a href="https://github.com/tisnik/presentations/blob/master/SIMD/simd05B.c">https://github.com/tisnik/presentations/blob/master/SIMD/simd05B.c</a></td></tr>
<tr><td> 8</td><td>simd05C.c</td><td>definice typu vektoru</td><td><a href="https://github.com/tisnik/presentations/blob/master/SIMD/simd05C.c">https://github.com/tisnik/presentations/blob/master/SIMD/simd05C.c</a></td></tr>
<tr><td> 9</td><td>simd06.c</td><td>vektor čísel s&nbsp;plovoucí řádovou čárkou</td><td><a href="https://github.com/tisnik/presentations/blob/master/SIMD/simd06.c">https://github.com/tisnik/presentations/blob/master/SIMD/simd06.c</a></td></tr>
<tr><td>10</td><td>simd07.c</td><td>paralelní součet prvků vektorů (typ <strong>float</strong>)</td><td><a href="https://github.com/tisnik/presentations/blob/master/SIMD/simd07.c">https://github.com/tisnik/presentations/blob/master/SIMD/simd07.c</a></td></tr>
<tr><td>11</td><td>simd08.c</td><td>paralelní součet prvků vektorů (typ <strong>double</strong>)</td><td><a href="https://github.com/tisnik/presentations/blob/master/SIMD/simd08.c">https://github.com/tisnik/presentations/blob/master/SIMD/simd08.c</a></td></tr>
<tr><td>12</td><td>simd09.c</td><td>překročení délky vektoru</td><td><a href="https://github.com/tisnik/presentations/blob/master/SIMD/simd09.c">https://github.com/tisnik/presentations/blob/master/SIMD/simd09.c</a></td></tr>
<tr><td>13</td><td>simd10.c</td><td>přístup k&nbsp;jednotlivým prvkům vektorů</td><td><a href="https://github.com/tisnik/presentations/blob/master/SIMD/simd10.c">https://github.com/tisnik/presentations/blob/master/SIMD/simd10.c</a></td></tr>
<tr><td>14</td><td>simd11.c</td><td>překročení délky vektoru</td><td><a href="https://github.com/tisnik/presentations/blob/master/SIMD/simd11.c">https://github.com/tisnik/presentations/blob/master/SIMD/simd11.c</a></td></tr>
<tr><td>15</td><td>simd12.c</td><td>dlouhý vektor s&nbsp;256 bajty</td><td><a href="https://github.com/tisnik/presentations/blob/master/SIMD/simd12.c">https://github.com/tisnik/presentations/blob/master/SIMD/simd12.c</a></td></tr>
<tr><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td></tr>
<tr><td>16</td><td>simd13.c</td><td>operace součtu pro vektory s&nbsp;celočíselnými prvky rozličné bitové šířky bez znaménka</td><td><a href="https://github.com/tisnik/presentations/blob/master/SIMD/simd13.c">https://github.com/tisnik/presentations/blob/master/SIMD/simd13.c</a></td></tr>
<tr><td>17</td><td>simd14.c</td><td>operace součtu pro vektory s&nbsp;celočíselnými prvky rozličné bitové šířky se znaménkem</td><td><a href="https://github.com/tisnik/presentations/blob/master/SIMD/simd14.c">https://github.com/tisnik/presentations/blob/master/SIMD/simd14.c</a></td></tr>
<tr><td>18</td><td>simd15.c</td><td>operace součtu pro vektory s&nbsp;prvky rozličné bitové šířky s&nbsp;plovoucí řádovou čárkou</td><td><a href="https://github.com/tisnik/presentations/blob/master/SIMD/simd15.c">https://github.com/tisnik/presentations/blob/master/SIMD/simd15.c</a></td></tr>
<tr><td>19</td><td>simd16.c</td><td>operace součtu pro dlouhé vektory s&nbsp;prvky rozličné bitové šířky s&nbsp;plovoucí řádovou čárkou</td><td><a href="https://github.com/tisnik/presentations/blob/master/SIMD/simd16.c">https://github.com/tisnik/presentations/blob/master/SIMD/simd16.c</a></td></tr>
<tr><td>20</td><td>simd17.c</td><td>všechny podporované binární operace nad vektory s&nbsp;celočíselnými prvky se znaménkem</td><td><a href="https://github.com/tisnik/presentations/blob/master/SIMD/simd17.c">https://github.com/tisnik/presentations/blob/master/SIMD/simd17.c</a></td></tr>
<tr><td>21</td><td>simd18.c</td><td>všechny podporované binární operace nad vektory s&nbsp;prvky typu <strong>float</strong></td><td><a href="https://github.com/tisnik/presentations/blob/master/SIMD/simd18.c">https://github.com/tisnik/presentations/blob/master/SIMD/simd18.c</a></td></tr>
<tr><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td></tr>
<tr><td>23</td><td>intrinsic_mmx_1.c</td><td>intrinsic pro technologii MMX: instrukce <strong>paddb</strong></td><td><a href="https://github.com/tisnik/presentations/blob/master/SIMD/intrinsic_mmx_1.c">https://github.com/tisnik/presentations/blob/master/SIMD/intrinsic_mmx_1.c</a></td></tr>
<tr><td>24</td><td>intrinsic_mmx_2.c</td><td>intrinsic pro technologii MMX: instrukce <strong>paddw</strong></td><td><a href="https://github.com/tisnik/presentations/blob/master/SIMD/intrinsic_mmx_2.c">https://github.com/tisnik/presentations/blob/master/SIMD/intrinsic_mmx_2.c</a></td></tr>
<tr><td>25</td><td>intrinsic_mmx_3.c</td><td>intrinsic pro technologii MMX: instrukce <strong>paddb</strong> (přetečení)</td><td><a href="https://github.com/tisnik/presentations/blob/master/SIMD/intrinsic_mmx_3.c">https://github.com/tisnik/presentations/blob/master/SIMD/intrinsic_mmx_3.c</a></td></tr>
<tr><td>26</td><td>intrinsic_mmx_4.c</td><td>intrinsic pro technologii MMX: instrukce <strong>paddsb</strong> (saturace)</td><td><a href="https://github.com/tisnik/presentations/blob/master/SIMD/intrinsic_mmx_4.c">https://github.com/tisnik/presentations/blob/master/SIMD/intrinsic_mmx_4.c</a></td></tr>
<tr><td>27</td><td>intrinsic_mmx_5.c</td><td>intrinsic pro technologii MMX: instrukce <strong>pupckhbw</strong> (kombinace dvou vektorů)</td><td><a href="https://github.com/tisnik/presentations/blob/master/SIMD/intrinsic_mmx_5.c">https://github.com/tisnik/presentations/blob/master/SIMD/intrinsic_mmx_5.c</a></td></tr>
<tr><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td></tr>
<tr><td>28</td><td>intrinsic_sse_1.c</td><td>součet dvou vektorů s&nbsp;šestnácti prvky typu <strong>char</strong> instrukcí <strong>paddb128</strong></td><td><a href="https://github.com/tisnik/presentations/blob/master/SIMD/intrinsic_sse_1.c">https://github.com/tisnik/presentations/blob/master/SIMD/intrinsic_sse_1.c</a></td></tr>
<tr><td>29</td><td>intrinsic_sse_2.c</td><td>součet dvou vektorů s&nbsp;osmi prvky typu <strong>short</strong> instrukcí <strong>paddw128</strong></td><td><a href="https://github.com/tisnik/presentations/blob/master/SIMD/intrinsic_sse_2.c">https://github.com/tisnik/presentations/blob/master/SIMD/intrinsic_sse_2.c</a></td></tr>
<tr><td>30</td><td>intrinsic_sse_3.c</td><td>součet dvou vektorů se čtyřmi prvky typu <strong>int</strong> instrukcí <strong>paddd128</strong></td><td><a href="https://github.com/tisnik/presentations/blob/master/SIMD/intrinsic_sse_3.c">https://github.com/tisnik/presentations/blob/master/SIMD/intrinsic_sse_3.c</a></td></tr>
<tr><td>31</td><td>intrinsic_sse_4.c</td><td>součet dvou vektorů se dvěma prvky typu <strong>long</strong> instrukcí <strong>paddq128</strong></td><td><a href="https://github.com/tisnik/presentations/blob/master/SIMD/intrinsic_sse_4.c">https://github.com/tisnik/presentations/blob/master/SIMD/intrinsic_sse_4.c</a></td></tr>
<tr><td>32</td><td>intrinsic_sse_5.c</td><td>součet dvou vektorů se čtyřmi prvky typu <strong>float</strong> instrukcí <strong>addps</strong></td><td><a href="https://github.com/tisnik/presentations/blob/master/SIMD/intrinsic_sse_5.c">https://github.com/tisnik/presentations/blob/master/SIMD/intrinsic_sse_5.c</a></td></tr>
<tr><td>33</td><td>intrinsic_sse_6.c</td><td>součet dvou vektorů se dvěma prvky typu <strong>double</strong> instrukcí <strong>addpd</strong></td><td><a href="https://github.com/tisnik/presentations/blob/master/SIMD/intrinsic_sse_6.c">https://github.com/tisnik/presentations/blob/master/SIMD/intrinsic_sse_6.c</a></td></tr>
<tr><td>34</td><td>intrinsic_sse_7.c</td><td>porovnání celočíselných prvků instrukcemi <strong>pcmpeqb128</strong> a <strong>pcmpgtb128</strong></td><td><a href="https://github.com/tisnik/presentations/blob/master/SIMD/intrinsic_sse_7.c">https://github.com/tisnik/presentations/blob/master/SIMD/intrinsic_sse_7.c</a></td></tr>
<tr><td>35</td><td>intrinsic_sse_8.c</td><td>všech šest relačních operací pro vektory s&nbsp;prvky typu <strong>float</strong></td><td><a href="https://github.com/tisnik/presentations/blob/master/SIMD/intrinsic_sse_8.c">https://github.com/tisnik/presentations/blob/master/SIMD/intrinsic_sse_8.c</a></td></tr>
<tr><td>36</td><td>intrinsic_sse_9.c</td><td>unární operace pro výpočet převrácené hodnoty, druhé odmocniny a převrácené hodnoty druhé odmocniny</td><td><a href="https://github.com/tisnik/presentations/blob/master/SIMD/intrinsic_sse_9.c">https://github.com/tisnik/presentations/blob/master/SIMD/intrinsic_sse_9.c</a></td></tr>
<tr><td>37</td><td>intrinsic_sse_A.c</td><td>instrukce <strong>shufps</strong> a její intrinsic</td><td><a href="https://github.com/tisnik/presentations/blob/master/SIMD/intrinsic_sse_A.c">https://github.com/tisnik/presentations/blob/master/SIMD/intrinsic_sse_A.c</a></td></tr>
<tr><td>38</td><td>intrinsic_sse_B.c</td><td>instrukce <strong>unpckhps</strong> a <strong>unpcklps</strong> a jejich intrinsics</td><td><a href="https://github.com/tisnik/presentations/blob/master/SIMD/intrinsic_sse_B.c">https://github.com/tisnik/presentations/blob/master/SIMD/intrinsic_sse_B.c</a></td></tr>
<tr><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td></tr>
<tr><td>39</td><td>simd19.c</td><td>operace součtu vektorů o délce 256 bitů s&nbsp;celočíselnými prvky bez znaménka</td><td><a href="https://github.com/tisnik/presentations/blob/master/SIMD/simd19.c">https://github.com/tisnik/presentations/blob/master/SIMD/simd19.c</a></td></tr>
<tr><td>40</td><td>simd20.c</td><td>operace součtu vektorů o délce 256 bitů s&nbsp;celočíselnými prvky se znaménkem</td><td><a href="https://github.com/tisnik/presentations/blob/master/SIMD/simd20.c">https://github.com/tisnik/presentations/blob/master/SIMD/simd20.c</a></td></tr>
<tr><td>41</td><td>simd21.c</td><td>operace součtu vektorů o délce 256 bitů s&nbsp;prvky typu <i>float</i> a <i>double</i></td><td><a href="https://github.com/tisnik/presentations/blob/master/SIMD/simd21.c">https://github.com/tisnik/presentations/blob/master/SIMD/simd21.c</a></td></tr>
<tr><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td></tr>
<tr><td>42</td><td>intrinsic_avx_1.c</td><td>operace součtu vektorů o délce 256 bitů s&nbsp;prvky typu <i>float</i></td><td><a href="https://github.com/tisnik/presentations/blob/master/SIMD/intrinsic_avx_1.c">https://github.com/tisnik/presentations/blob/master/SIMD/intrinsic_avx_1.c</a></td></tr>
<tr><td>43</td><td>intrinsic_avx_2.c</td><td>operace součtu vektorů o délce 256 bitů s&nbsp;prvky typu <i>double</i></td><td><a href="https://github.com/tisnik/presentations/blob/master/SIMD/intrinsic_avx_2.c">https://github.com/tisnik/presentations/blob/master/SIMD/intrinsic_avx_2.c</a></td></tr>
<tr><td>44</td><td>intrinsic_avx_3.c</td><td>operace výběru prvků z&nbsp;vektorů o délce 256 bitů s&nbsp;prvky typu <i>float</i></td><td><a href="https://github.com/tisnik/presentations/blob/master/SIMD/intrinsic_avx_3.c">https://github.com/tisnik/presentations/blob/master/SIMD/intrinsic_avx_3.c</a></td></tr>
<tr><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td></tr>
<tr><td>45</td><td>Makefile</td><td>Makefile pro překlad demonstračních příkladů</td><td><a href="https://github.com/tisnik/presentations/blob/master/SIMD/Makefile">https://github.com/tisnik/presentations/blob/master/SIMD/Makefile</a></td></tr>
</table>

<p>Soubory vzniklé překladem z&nbsp;jazyka C do assembleru procesorů x86-64:</p>

<table>
<tr><th> #</th><th>Příklad</th><th>Stručný popis</th><th>Adresa</th></tr>
<tr><td> 1</td><td>simd04_1.lst</td><td>překlad zdrojového kódu <strong>simd04_1.c</strong> s&nbsp;přepínači <strong>-O0 -mno-sse -g</strong></td><td><a href="https://github.com/tisnik/presentations/blob/master/SIMD/simd04_1.lst">https://github.com/tisnik/presentations/blob/master/SIMD/simd04_1.lst</a></td></tr>
<tr><td> 2</td><td>simd04_2.lst</td><td>překlad zdrojového kódu <strong>simd04_2.c</strong> s&nbsp;přepínači <strong>-O0 -g</strong></td><td><a href="https://github.com/tisnik/presentations/blob/master/SIMD/simd04_2.lst">https://github.com/tisnik/presentations/blob/master/SIMD/simd04_2.lst</a></td></tr>
<tr><td> 3</td><td>simd04B_1.lst</td><td>překlad zdrojového kódu <strong>simd04B_1.c</strong> s&nbsp;přepínači <strong>-O0 -mno-sse -g</strong></td><td><a href="https://github.com/tisnik/presentations/blob/master/SIMD/simd04B_1.lst">https://github.com/tisnik/presentations/blob/master/SIMD/simd04B_1.lst</a></td></tr>
<tr><td> 4</td><td>simd04B_2.lst</td><td>překlad zdrojového kódu <strong>simd04B_2.c</strong> s&nbsp;přepínači <strong>-O0 -g</strong></td><td><a href="https://github.com/tisnik/presentations/blob/master/SIMD/simd04B_2.lst">https://github.com/tisnik/presentations/blob/master/SIMD/simd04B_2.lst</a></td></tr>
<tr><td> 5</td><td>simd07_1.lst</td><td>překlad zdrojového kódu <strong>simd07_1.c</strong> s&nbsp;přepínači <strong>-mno-sse -g</strong></td><td><a href="https://github.com/tisnik/presentations/blob/master/SIMD/simd07_1.lst">https://github.com/tisnik/presentations/blob/master/SIMD/simd07_1.lst</a></td></tr>
<tr><td> 6</td><td>simd07_2.lst</td><td>překlad zdrojového kódu <strong>simd07_2.c</strong> s&nbsp;přepínači <strong>-g</strong></td><td><a href="https://github.com/tisnik/presentations/blob/master/SIMD/simd07_2.lst">https://github.com/tisnik/presentations/blob/master/SIMD/simd07_2.lst</a></td></tr>
<tr><td> 7</td><td>simd08_1.lst</td><td>překlad zdrojového kódu <strong>simd08_1.c</strong> s&nbsp;přepínači <strong>-mno-sse -g</strong></td><td><a href="https://github.com/tisnik/presentations/blob/master/SIMD/simd08_1.lst">https://github.com/tisnik/presentations/blob/master/SIMD/simd08_1.lst</a></td></tr>
<tr><td> 8</td><td>simd08_2.lst</td><td>překlad zdrojového kódu <strong>simd08_2.c</strong> s&nbsp;přepínači <strong>-g</strong></td><td><a href="https://github.com/tisnik/presentations/blob/master/SIMD/simd08_2.lst">https://github.com/tisnik/presentations/blob/master/SIMD/simd08_2.lst</a></td></tr>
<tr><td> 9</td><td>simd12_1.lst</td><td>překlad zdrojového kódu <strong>simd12_1.c</strong> s&nbsp;přepínači <strong>-O0 -mno-sse -g </strong></td><td><a href="https://github.com/tisnik/presentations/blob/master/SIMD/simd12_1.lst">https://github.com/tisnik/presentations/blob/master/SIMD/simd12_1.lst</a></td></tr>
<tr><td>10</td><td>simd12_2.lst</td><td>překlad zdrojového kódu <strong>simd12_2.c</strong> s&nbsp;přepínači <strong>-O0 -g </strong></td><td><a href="https://github.com/tisnik/presentations/blob/master/SIMD/simd12_2.lst">https://github.com/tisnik/presentations/blob/master/SIMD/simd12_2.lst</a></td></tr>
<tr><td>11</td><td>simd13_1.lst</td><td>překlad zdrojového kódu <strong>simd13_1.c</strong> s&nbsp;přepínači <strong>-O0 -mno-sse -g</strong></td><td><a href="https://github.com/tisnik/presentations/blob/master/SIMD/simd13_1.lst">https://github.com/tisnik/presentations/blob/master/SIMD/simd13_1.lst</a></td></tr>
<tr><td>12</td><td>simd13_2.lst</td><td>překlad zdrojového kódu <strong>simd13_2.c</strong> s&nbsp;přepínači <strong>-O0 -g</strong></td><td><a href="https://github.com/tisnik/presentations/blob/master/SIMD/simd13_2.lst">https://github.com/tisnik/presentations/blob/master/SIMD/simd13_2.lst</a></td></tr>
<tr><td>13</td><td>simd13_3.lst</td><td>překlad zdrojového kódu <strong>simd13_3.c</strong> s&nbsp;přepínači <strong>-O3 -mno-sse -g</strong></td><td><a href="https://github.com/tisnik/presentations/blob/master/SIMD/simd13_3.lst">https://github.com/tisnik/presentations/blob/master/SIMD/simd13_3.lst</a></td></tr>
<tr><td>14</td><td>simd13_4.lst</td><td>překlad zdrojového kódu <strong>simd13_4.c</strong> s&nbsp;přepínači <strong>-O3 -g</strong></td><td><a href="https://github.com/tisnik/presentations/blob/master/SIMD/simd13_4.lst">https://github.com/tisnik/presentations/blob/master/SIMD/simd13_4.lst</a></td></tr>
<tr><td>15</td><td>simd14_1.lst</td><td>překlad zdrojového kódu <strong>simd14_1.c</strong> s&nbsp;přepínači <strong>-O0 -mno-sse -g</strong></td><td><a href="https://github.com/tisnik/presentations/blob/master/SIMD/simd14_1.lst">https://github.com/tisnik/presentations/blob/master/SIMD/simd14_1.lst</a></td></tr>
<tr><td>16</td><td>simd14_2.lst</td><td>překlad zdrojového kódu <strong>simd14_2.c</strong> s&nbsp;přepínači <strong>-O0 -g</strong></td><td><a href="https://github.com/tisnik/presentations/blob/master/SIMD/simd14_2.lst">https://github.com/tisnik/presentations/blob/master/SIMD/simd14_2.lst</a></td></tr>
<tr><td>17</td><td>simd14_3.lst</td><td>překlad zdrojového kódu <strong>simd14_3.c</strong> s&nbsp;přepínači <strong>-O3 -mno-sse -g</strong></td><td><a href="https://github.com/tisnik/presentations/blob/master/SIMD/simd14_3.lst">https://github.com/tisnik/presentations/blob/master/SIMD/simd14_3.lst</a></td></tr>
<tr><td>18</td><td>simd14_4.lst</td><td>překlad zdrojového kódu <strong>simd14_4.c</strong> s&nbsp;přepínači <strong>-O3 -g</strong></td><td><a href="https://github.com/tisnik/presentations/blob/master/SIMD/simd14_4.lst">https://github.com/tisnik/presentations/blob/master/SIMD/simd14_4.lst</a></td></tr>
<tr><td>19</td><td>simd15_1.lst</td><td>překlad zdrojového kódu <strong>simd15_1.c</strong> s&nbsp;přepínači <strong>-O0 -mno-sse -g</strong></td><td><a href="https://github.com/tisnik/presentations/blob/master/SIMD/simd15_1.lst">https://github.com/tisnik/presentations/blob/master/SIMD/simd15_1.lst</a></td></tr>
<tr><td>20</td><td>simd15_2.lst</td><td>překlad zdrojového kódu <strong>simd15_2.c</strong> s&nbsp;přepínači <strong>-O0 -g</strong></td><td><a href="https://github.com/tisnik/presentations/blob/master/SIMD/simd15_2.lst">https://github.com/tisnik/presentations/blob/master/SIMD/simd15_2.lst</a></td></tr>
<tr><td>21</td><td>simd15_3.lst</td><td>překlad zdrojového kódu <strong>simd15_3.c</strong> s&nbsp;přepínači <strong>-O3 -mno-sse -g</strong></td><td><a href="https://github.com/tisnik/presentations/blob/master/SIMD/simd15_3.lst">https://github.com/tisnik/presentations/blob/master/SIMD/simd15_3.lst</a></td></tr>
<tr><td>22</td><td>simd15_4.lst</td><td>překlad zdrojového kódu <strong>simd15_4.c</strong> s&nbsp;přepínači <strong>-O3 -g</strong></td><td><a href="https://github.com/tisnik/presentations/blob/master/SIMD/simd15_4.lst">https://github.com/tisnik/presentations/blob/master/SIMD/simd15_4.lst</a></td></tr>
<tr><td>23</td><td>simd16_1.lst</td><td>překlad zdrojového kódu <strong>simd16_1.c</strong> s&nbsp;přepínači <strong>-O0 -mno-sse -g</strong></td><td><a href="https://github.com/tisnik/presentations/blob/master/SIMD/simd16_1.lst">https://github.com/tisnik/presentations/blob/master/SIMD/simd16_1.lst</a></td></tr>
<tr><td>24</td><td>simd16_2.lst</td><td>překlad zdrojového kódu <strong>simd16_2.c</strong> s&nbsp;přepínači <strong>-O0 -g</strong></td><td><a href="https://github.com/tisnik/presentations/blob/master/SIMD/simd16_2.lst">https://github.com/tisnik/presentations/blob/master/SIMD/simd16_2.lst</a></td></tr>
<tr><td>25</td><td>simd16_3.lst</td><td>překlad zdrojového kódu <strong>simd16_3.c</strong> s&nbsp;přepínači <strong>-O3 -mno-sse -g</strong></td><td><a href="https://github.com/tisnik/presentations/blob/master/SIMD/simd16_3.lst">https://github.com/tisnik/presentations/blob/master/SIMD/simd16_3.lst</a></td></tr>
<tr><td>26</td><td>simd16_4.lst</td><td>překlad zdrojového kódu <strong>simd16_4.c</strong> s&nbsp;přepínači <strong>-O3 -g</strong></td><td><a href="https://github.com/tisnik/presentations/blob/master/SIMD/simd16_4.lst">https://github.com/tisnik/presentations/blob/master/SIMD/simd16_4.lst</a></td></tr>
<tr><td>27</td><td>simd17_1.lst</td><td>překlad zdrojového kódu <strong>simd17_1.c</strong> s&nbsp;přepínači <strong>-O0 -mno-sse -g</strong></td><td><a href="https://github.com/tisnik/presentations/blob/master/SIMD/simd17_1.lst">https://github.com/tisnik/presentations/blob/master/SIMD/simd17_1.lst</a></td></tr>
<tr><td>28</td><td>simd17_2.lst</td><td>překlad zdrojového kódu <strong>simd17_2.c</strong> s&nbsp;přepínači <strong>-O0 -g</strong></td><td><a href="https://github.com/tisnik/presentations/blob/master/SIMD/simd17_2.lst">https://github.com/tisnik/presentations/blob/master/SIMD/simd17_2.lst</a></td></tr>
<tr><td>29</td><td>simd17_3.lst</td><td>překlad zdrojového kódu <strong>simd17_3.c</strong> s&nbsp;přepínači <strong>-O3 -mno-sse -g</strong></td><td><a href="https://github.com/tisnik/presentations/blob/master/SIMD/simd17_3.lst">https://github.com/tisnik/presentations/blob/master/SIMD/simd17_3.lst</a></td></tr>
<tr><td>30</td><td>simd17_4.lst</td><td>překlad zdrojového kódu <strong>simd17_4.c</strong> s&nbsp;přepínači <strong>-O3 -g</strong></td><td><a href="https://github.com/tisnik/presentations/blob/master/SIMD/simd17_4.lst">https://github.com/tisnik/presentations/blob/master/SIMD/simd17_4.lst</a></td></tr>
<tr><td>31</td><td>simd18_1.lst</td><td>překlad zdrojového kódu <strong>simd18_1.c</strong> s&nbsp;přepínači <strong>-O0 -mno-sse -g</strong></td><td><a href="https://github.com/tisnik/presentations/blob/master/SIMD/simd18_1.lst">https://github.com/tisnik/presentations/blob/master/SIMD/simd18_1.lst</a></td></tr>
<tr><td>32</td><td>simd18_2.lst</td><td>překlad zdrojového kódu <strong>simd18_2.c</strong> s&nbsp;přepínači <strong>-O0 -g</strong></td><td><a href="https://github.com/tisnik/presentations/blob/master/SIMD/simd18_2.lst">https://github.com/tisnik/presentations/blob/master/SIMD/simd18_2.lst</a></td></tr>
<tr><td>33</td><td>simd18_3.lst</td><td>překlad zdrojového kódu <strong>simd18_3.c</strong> s&nbsp;přepínači <strong>-O3 -mno-sse -g</strong></td><td><a href="https://github.com/tisnik/presentations/blob/master/SIMD/simd18_3.lst">https://github.com/tisnik/presentations/blob/master/SIMD/simd18_3.lst</a></td></tr>
<tr><td>34</td><td>simd18_4.lst</td><td>překlad zdrojového kódu <strong>simd18_4.c</strong> s&nbsp;přepínači <strong>-O3 -g</strong></td><td><a href="https://github.com/tisnik/presentations/blob/master/SIMD/simd18_4.lst">https://github.com/tisnik/presentations/blob/master/SIMD/simd18_4.lst</a></td></tr>
<tr><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td></tr>
<tr><td>35</td><td>intrinsic_mmx_1.lst</td><td>překlad zdrojového kódu <strong>intrinsic_mmx_1.c</strong></td><td><a href="https://github.com/tisnik/presentations/blob/master/SIMD/intrinsic_mmx_1.lst">https://github.com/tisnik/presentations/blob/master/SIMD/intrinsic_mmx_1.lst</a></td></tr>
<tr><td>36</td><td>intrinsic_mmx_2.lst</td><td>překlad zdrojového kódu <strong>intrinsic_mmx_2.c</strong></td><td><a href="https://github.com/tisnik/presentations/blob/master/SIMD/intrinsic_mmx_2.lst">https://github.com/tisnik/presentations/blob/master/SIMD/intrinsic_mmx_2.lst</a></td></tr>
<tr><td>37</td><td>intrinsic_mmx_3.lst</td><td>překlad zdrojového kódu <strong>intrinsic_mmx_3.c</strong></td><td><a href="https://github.com/tisnik/presentations/blob/master/SIMD/intrinsic_mmx_3.lst">https://github.com/tisnik/presentations/blob/master/SIMD/intrinsic_mmx_3.lst</a></td></tr>
<tr><td>39</td><td>intrinsic_mmx_5.lst</td><td>překlad zdrojového kódu <strong>intrinsic_mmx_5.c</strong></td><td><a href="https://github.com/tisnik/presentations/blob/master/SIMD/intrinsic_mmx_5.lst">https://github.com/tisnik/presentations/blob/master/SIMD/intrinsic_mmx_5.lst</a></td></tr>
<tr><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td></tr>
<tr><td>40</td><td>intrinsic_sse_1.lst</td><td>překlad zdrojového kódu <strong>intrinsic_sse_1.c</strong></td><td><a href="https://github.com/tisnik/presentations/blob/master/SIMD/intrinsic_sse_1.lst">https://github.com/tisnik/presentations/blob/master/SIMD/intrinsic_sse_1.lst</a></td></tr>
<tr><td>41</td><td>intrinsic_sse_2.lst</td><td>překlad zdrojového kódu <strong>intrinsic_sse_2.c</strong></td><td><a href="https://github.com/tisnik/presentations/blob/master/SIMD/intrinsic_sse_2.lst">https://github.com/tisnik/presentations/blob/master/SIMD/intrinsic_sse_2.lst</a></td></tr>
<tr><td>42</td><td>intrinsic_sse_3.lst</td><td>překlad zdrojového kódu <strong>intrinsic_sse_3.c</strong></td><td><a href="https://github.com/tisnik/presentations/blob/master/SIMD/intrinsic_sse_3.lst">https://github.com/tisnik/presentations/blob/master/SIMD/intrinsic_sse_3.lst</a></td></tr>
<tr><td>43</td><td>intrinsic_sse_4.lst</td><td>překlad zdrojového kódu <strong>intrinsic_sse_4.c</strong></td><td><a href="https://github.com/tisnik/presentations/blob/master/SIMD/intrinsic_sse_4.lst">https://github.com/tisnik/presentations/blob/master/SIMD/intrinsic_sse_4.lst</a></td></tr>
<tr><td>44</td><td>intrinsic_sse_5.lst</td><td>překlad zdrojového kódu <strong>intrinsic_sse_5.c</strong></td><td><a href="https://github.com/tisnik/presentations/blob/master/SIMD/intrinsic_sse_5.lst">https://github.com/tisnik/presentations/blob/master/SIMD/intrinsic_sse_5.lst</a></td></tr>
<tr><td>45</td><td>intrinsic_sse_6.lst</td><td>překlad zdrojového kódu <strong>intrinsic_sse_6.c</strong></td><td><a href="https://github.com/tisnik/presentations/blob/master/SIMD/intrinsic_sse_6.lst">https://github.com/tisnik/presentations/blob/master/SIMD/intrinsic_sse_6.lst</a></td></tr>
<tr><td>46</td><td>intrinsic_sse_7.lst</td><td>překlad zdrojového kódu <strong>intrinsic_sse_7.c</strong></td><td><a href="https://github.com/tisnik/presentations/blob/master/SIMD/intrinsic_sse_7.lst">https://github.com/tisnik/presentations/blob/master/SIMD/intrinsic_sse_7.lst</a></td></tr>
<tr><td>47</td><td>intrinsic_sse_8.lst</td><td>překlad zdrojového kódu <strong>intrinsic_sse_8.c</strong></td><td><a href="https://github.com/tisnik/presentations/blob/master/SIMD/intrinsic_sse_8.lst">https://github.com/tisnik/presentations/blob/master/SIMD/intrinsic_sse_8.lst</a></td></tr>
<tr><td>48</td><td>intrinsic_sse_9.lst</td><td>překlad zdrojového kódu <strong>intrinsic_sse_9.c</strong></td><td><a href="https://github.com/tisnik/presentations/blob/master/SIMD/intrinsic_sse_9.lst">https://github.com/tisnik/presentations/blob/master/SIMD/intrinsic_sse_9.lst</a></td></tr>
<tr><td>49</td><td>intrinsic_sse_A.lst</td><td>překlad zdrojového kódu <strong>intrinsic_sse_A.c</strong></td><td><a href="https://github.com/tisnik/presentations/blob/master/SIMD/intrinsic_sse_A.lst">https://github.com/tisnik/presentations/blob/master/SIMD/intrinsic_sse_A.lst</a></td></tr>
<tr><td>50</td><td>intrinsic_sse_B.lst</td><td>překlad zdrojového kódu <strong>intrinsic_sse_B.c</strong></td><td><a href="https://github.com/tisnik/presentations/blob/master/SIMD/intrinsic_sse_B.lst">https://github.com/tisnik/presentations/blob/master/SIMD/intrinsic_sse_B.lst</a></td></tr>
<tr><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td></tr>
<tr><td>51</td><td>simd19_sse.lst</td><td>překlad zdrojového kódu <strong>simd19.c</strong> s&nbsp;přepínačem <strong>-msse -mno-avx</strong></td><td><a href="https://github.com/tisnik/presentations/blob/master/SIMD/simd19_sse.lst">https://github.com/tisnik/presentations/blob/master/SIMD/simd19_sse.lst</a></td></tr>
<tr><td>52</td><td>simd19_avx.lst</td><td>překlad zdrojového kódu <strong>simd19.c</strong> s&nbsp;přepínačem <strong>-mavx</strong></td><td><a href="https://github.com/tisnik/presentations/blob/master/SIMD/simd19_avx.lst">https://github.com/tisnik/presentations/blob/master/SIMD/simd19_avx.lst</a></td></tr>
<tr><td>53</td><td>simd19_avx2.lst</td><td>překlad zdrojového kódu <strong>simd19.c</strong> s&nbsp;přepínačem <strong>-mavx2</strong></td><td><a href="https://github.com/tisnik/presentations/blob/master/SIMD/simd19_avx2.lst">https://github.com/tisnik/presentations/blob/master/SIMD/simd19_avx2.lst</a></td></tr>
<tr><td>54</td><td>simd20_sse.lst</td><td>překlad zdrojového kódu <strong>simd20.c</strong> s&nbsp;přepínačem <strong>-msse -mno-avx</strong></td><td><a href="https://github.com/tisnik/presentations/blob/master/SIMD/simd20_sse.lst">https://github.com/tisnik/presentations/blob/master/SIMD/simd20_sse.lst</a></td></tr>
<tr><td>55</td><td>simd20_avx.lst</td><td>překlad zdrojového kódu <strong>simd20.c</strong> s&nbsp;přepínačem <strong>-mavx</strong></td><td><a href="https://github.com/tisnik/presentations/blob/master/SIMD/simd20_avx.lst">https://github.com/tisnik/presentations/blob/master/SIMD/simd20_avx.lst</a></td></tr>
<tr><td>56</td><td>simd20_avx2.lst</td><td>překlad zdrojového kódu <strong>simd20.c</strong> s&nbsp;přepínačem <strong>-mavx2</strong></td><td><a href="https://github.com/tisnik/presentations/blob/master/SIMD/simd20_avx2.lst">https://github.com/tisnik/presentations/blob/master/SIMD/simd20_avx2.lst</a></td></tr>
<tr><td>57</td><td>simd21_sse.lst</td><td>překlad zdrojového kódu <strong>simd21.c</strong> s&nbsp;přepínačem <strong>-msse -mno-avx</strong></td><td><a href="https://github.com/tisnik/presentations/blob/master/SIMD/simd21_sse.lst">https://github.com/tisnik/presentations/blob/master/SIMD/simd21_sse.lst</a></td></tr>
<tr><td>58</td><td>simd21_avx.lst</td><td>překlad zdrojového kódu <strong>simd21.c</strong> s&nbsp;přepínačem <strong>-mavx</strong></td><td><a href="https://github.com/tisnik/presentations/blob/master/SIMD/simd21_avx.lst">https://github.com/tisnik/presentations/blob/master/SIMD/simd21_avx.lst</a></td></tr>
<tr><td>59</td><td>simd21_avx2.lst</td><td>překlad zdrojového kódu <strong>simd21.c</strong> s&nbsp;přepínačem <strong>-mavx3</strong></td><td><a href="https://github.com/tisnik/presentations/blob/master/SIMD/simd20_avx2.lst">https://github.com/tisnik/presentations/blob/master/SIMD/simd21_avx2.lst</a></td></tr>
</table>



<p><a name="k20"></a></p>
<h2 id="k20">20. Odkazy na Internetu</h2>

<ol>

<li>GCC documentation: Extensions to the C Language Family<br />
<a href="https://gcc.gnu.org/onlinedocs/gcc/C-Extensions.html#C-Extensions">https://gcc.gnu.org/onlinedocs/gcc/C-Extensions.html#C-Extensions</a>
</li>

<li>GCC documentation: Using Vector Instructions through Built-in Functions<br />
<a href="https://gcc.gnu.org/onlinedocs/gcc/Vector-Extensions.html">https://gcc.gnu.org/onlinedocs/gcc/Vector-Extensions.html</a>
</li>

<li>SSE (Streaming SIMD Extentions)<br />
<a href="http://www.songho.ca/misc/sse/sse.html">http://www.songho.ca/misc/sse/sse.html</a>
</li>

<li>Timothy A. Chagnon: SSE and SSE2<br />
<a href="http://www.cs.drexel.edu/~tc365/mpi-wht/sse.pdf">http://www.cs.drexel.edu/~tc365/mpi-wht/sse.pdf</a>
</li>

<li>Intel corporation: Extending the Worldr's Most Popular Processor Architecture<br />
<a href="http://download.intel.com/technology/architecture/new-instructions-paper.pdf">http://download.intel.com/technology/architecture/new-instructions-paper.pdf</a>
</li>

<li>SIMD architectures:<br />
<a href="http://arstechnica.com/old/content/2000/03/simd.ars/">http://arstechnica.com/old/content/2000/03/simd.ars/</a>
</li>

<li>Tour of the Black Holes of Computing!: Floating Point<br />
<a href="http://www.cs.hmc.edu/~geoff/classes/hmc.cs105.../slides/class02_floats.ppt">http://www.cs.hmc.edu/~geoff/classes/hmc.cs105.../slides/class02_floats.ppt</a>
</li>

<li>3Dnow! Technology Manual<br />
AMD Inc., 2000</li>

<li>Intel MMX<sup>TM</sup> Technology Overview<br />
Intel corporation, 1996</li>

<li>MultiMedia eXtensions<br />
<a href="http://softpixel.com/~cwright/programming/simd/mmx.php">http://softpixel.com/~cwright/programming/simd/mmx.php</a>i
</li>

<li>AMD K5 ("K5" / "5k86")<br />
<a href="http://www.pcguide.com/ref/cpu/fam/g5K5-c.html">http://www.pcguide.com/ref/cpu/fam/g5K5-c.html</a>
</li>

<li>Sixth Generation Processors<br />
<a href="http://www.pcguide.com/ref/cpu/fam/g6.htm">http://www.pcguide.com/ref/cpu/fam/g6.htm</a>
</li>

<li>Great Microprocessors of the Past and Present<br />
<a href="http://www.cpushack.com/CPU/cpu1.html">http://www.cpushack.com/CPU/cpu1.html</a>
</li>

<li>Very long instruction word (Wikipedia)<br />
<a href="http://en.wikipedia.org/wiki/Very_long_instruction_word">http://en.wikipedia.org/wiki/Very_long_instruction_word</a>
</li>

<li>CPU design (Wikipedia)<br />
<a href="http://en.wikipedia.org/wiki/CPU_design">http://en.wikipedia.org/wiki/CPU_design</a>
</li>

<li>Bulldozer (microarchitecture)<br />
<a href="https://en.wikipedia.org/wiki/Bulldozer_(microarchitecture)">https://en.wikipedia.org/wiki/Bulldozer_(microarchitecture)</a>
</li>

<li>SIMD Instructions Considered Harmful<br />
<a href="https://www.sigarch.org/simd-instructions-considered-harmful/">https://www.sigarch.org/simd-instructions-considered-harmful/</a>
</li>

<li>GCC Compiler Intrinsics<br />
<a href="https://iq.opengenus.org/gcc-compiler-intrinsics/">https://iq.opengenus.org/gcc-compiler-intrinsics/</a>
</li>

<li>Scalable_Vector_Extension_(SVE)<br />
<a href="https://en.wikipedia.org/wiki/AArch64#Scalable_Vector_Extension_(SVE)">https://en.wikipedia.org/wiki/AArch64#Scalable_Vector_Extension_(SVE)</a>
</li>

<li>FADD/FADDP/FIADD — Add<br />
<a href="https://www.felixcloutier.com/x86/fadd:faddp:fiadd">https://www.felixcloutier.com/x86/fadd:faddp:fiadd</a>
</li>

<li>ADDPS — Add Packed Single-Precision Floating-Point Values<br />
<a href="https://www.felixcloutier.com/x86/addps">https://www.felixcloutier.com/x86/addps</a>
</li>

<li>ADDPD — Add Packed Double-Precision Floating-Point Values<br />
<a href="https://www.felixcloutier.com/x86/addpd">https://www.felixcloutier.com/x86/addpd</a>
</li>

<li>FDIV/FDIVP/FIDIV — Divide<br />
<a href="https://www.felixcloutier.com/x86/fdiv:fdivp:fidiv">https://www.felixcloutier.com/x86/fdiv:fdivp:fidiv</a>
</li>

<li>IDIV — Signed Divide<br />
<a href="https://www.felixcloutier.com/x86/idiv">https://www.felixcloutier.com/x86/idiv</a>
</li>

<li>PADDB/PADDW/PADDD/PADDQ — Add Packed Integers<br />
<a href="https://www.felixcloutier.com/x86/paddb:paddw:paddd:paddq">https://www.felixcloutier.com/x86/paddb:paddw:paddd:paddq</a>
</li>

<li>PSUBB/PSUBW/PSUBD — Subtract Packed Integers<br />
<a href="https://www.felixcloutier.com/x86/psubb:psubw:psubd">https://www.felixcloutier.com/x86/psubb:psubw:psubd</a>
</li>

<li>PMULLW — Multiply Packed Signed Integers and Store Low Result<br />
<a href="https://www.felixcloutier.com/x86/pmullw">https://www.felixcloutier.com/x86/pmullw</a>
</li>

<li>PUNPCKLBW/PUNPCKLWD/PUNPCKLDQ/PUNPCKLQDQ — Unpack Low Data<br />
<a href="https://www.felixcloutier.com/x86/punpcklbw:punpcklwd:punpckldq:punpcklqdq">https://www.felixcloutier.com/x86/punpcklbw:punpcklwd:punpckldq:punpcklqdq</a>
</li>

<li>PUNPCKHBW/PUNPCKHWD/PUNPCKHDQ/PUNPCKHQDQ — Unpack High Data<br />
<a href="https://www.felixcloutier.com/x86/punpckhbw:punpckhwd:punpckhdq:punpckhqdq">https://www.felixcloutier.com/x86/punpckhbw:punpckhwd:punpckhdq:punpckhqdq</a>
</li>

<li>PACKUSWB — Pack with Unsigned Saturation<br />
<a href="https://www.felixcloutier.com/x86/packuswb">https://www.felixcloutier.com/x86/packuswb</a>
</li>

<li>ADDPS — Add Packed Single-Precision Floating-Point Values<br />
<a href="https://www.felixcloutier.com/x86/addps">https://www.felixcloutier.com/x86/addps</a>
</li>

<li>SUBPS — Subtract Packed Single-Precision Floating-Point Values<br />
<a href="https://www.felixcloutier.com/x86/subps">https://www.felixcloutier.com/x86/subps</a>
</li>

<li>MULPS — Multiply Packed Single-Precision Floating-Point Values<br />
<a href="https://www.felixcloutier.com/x86/mulps">https://www.felixcloutier.com/x86/mulps</a>
</li>

<li>DIVPS — Divide Packed Single-Precision Floating-Point Values<br />
<a href="https://www.felixcloutier.com/x86/divps">https://www.felixcloutier.com/x86/divps</a>
</li>

<li>CBW/CWDE/CDQE — Convert Byte to Word/Convert Word to Doubleword/Convert Doubleword to Quadword<br />
<a href="https://www.felixcloutier.com/x86/cbw:cwde:cdqe">https://www.felixcloutier.com/x86/cbw:cwde:cdqe</a>
</li>

<li>PAND — Logical AND<br />
<a href="https://www.felixcloutier.com/x86/pand">https://www.felixcloutier.com/x86/pand</a>
</li>

<li>POR — Bitwise Logical OR<br />
<a href="https://www.felixcloutier.com/x86/por">https://www.felixcloutier.com/x86/por</a>
</li>

<li>PXOR — Logical Exclusive OR<br />
<a href="https://www.felixcloutier.com/x86/pxor">https://www.felixcloutier.com/x86/pxor</a>
</li>

<li>Improve the Multimedia User Experience<br />
<a href="https://www.arm.com/technologies/neon">https://www.arm.com/technologies/neon</a>
</li>

<li>NEON Technology (stránky ARM)<br />
<a href="https://developer.arm.com/technologies/neon">https://developer.arm.com/technologies/neon</a>
</li>

<li>SIMD Assembly Tutorial: ARM NEON - Xiph.org<br />
<a href="https://people.xiph.org/~tterribe/daala/neon_tutorial.pdf">https://people.xiph.org/~tterribe/daala/neon_tutorial.pdf</a>
</li>

<li>Ne10<br />
<a href="http://projectne10.github.io/Ne10/">http://projectne10.github.io/Ne10/</a>
</li>

<li>NEON and Floating-Point architecture<br />
<a href="http://infocenter.arm.com/help/index.jsp?topic=/com.arm.doc.den0024a/BABIGHEB.html">http://infocenter.arm.com/help/index.jsp?topic=/com.arm.doc.den0024a/BABIGHEB.html</a>
</li>

<li>An Introduction to ARM NEON<br />
<a href="http://peterdn.com/post/an-introduction-to-ARM-NEON.aspx">http://peterdn.com/post/an-introduction-to-ARM-NEON.aspx</a>
</li>

<li>ARM NEON Intrinsics Reference<br />
<a href="http://infocenter.arm.com/help/topic/com.arm.doc.ihi0073a/IHI0073A_arm_neon_intrinsics_ref.pdf">http://infocenter.arm.com/help/topic/com.arm.doc.ihi0073a/IHI0073A_arm_neon_intrinsics_ref.pdf</a>
</li>

<li>Arm Neon Intrinsics vs hand assembly<br />
<a href="https://stackoverflow.com/questions/9828567/arm-neon-intrinsics-vs-hand-assembly">https://stackoverflow.com/questions/9828567/arm-neon-intrinsics-vs-hand-assembly</a>
</li>

<li>ARM NEON Optimization. An Example<br />
<a href="http://hilbert-space.de/?p=22">http://hilbert-space.de/?p=22</a>
</li>

<li>AArch64 NEON instruction format<br />
<a href="https://developer.arm.com/docs/den0024/latest/7-aarch64-floating-point-and-neon/73-aarch64-neon-instruction-format">https://developer.arm.com/docs/den0024/latest/7-aarch64-floating-point-and-neon/73-aarch64-neon-instruction-format</a>
</li>

<li>ARM SIMD instructions<br />
<a href="https://developer.arm.com/documentation/dht0002/a/Introducing-NEON/What-is-SIMD-/ARM-SIMD-instructions">https://developer.arm.com/documentation/dht0002/a/Introducing-NEON/What-is-SIMD-/ARM-SIMD-instructions</a>
</li>

<li>Learn the architecture - Migrate Neon to SVE Version 1.0<br />
<a href="https://developer.arm.com/documentation/102131/0100/?lang=en">https://developer.arm.com/documentation/102131/0100/?lang=en</a>
</li>

<li>1.2.2. Comparison between NEON technology and other SIMD solutions<br />
<a href="https://developer.arm.com/documentation/den0018/a/Introduction/Comparison-between-ARM-NEON-technology-and-other-implementations/Comparison-between-NEON-technology-and-other-SIMD-solutions?lang=en">https://developer.arm.com/documentation/den0018/a/Introduction/Comparison-between-ARM-NEON-technology-and-other-implementations/Comparison-between-NEON-technology-and-other-SIMD-solutions?lang=en</a>
</li>

<li>NEON Programmer’s Guide<br />
<a href="https://documentation-service.arm.com/static/63299276e68c6809a6b41308">https://documentation-service.arm.com/static/63299276e68c6809a6b41308</a>
</li>

<li>Brain Floating Point – nový formát uložení čísel pro strojové učení a chytrá čidla<br />
<a href="https://www.root.cz/clanky/brain-floating-point-ndash-novy-format-ulozeni-cisel-pro-strojove-uceni-a-chytra-cidla/">https://www.root.cz/clanky/brain-floating-point-ndash-novy-format-ulozeni-cisel-pro-strojove-uceni-a-chytra-cidla/</a>
</li>

<li>Other Built-in Functions Provided by GCC<br />
<a href="https://gcc.gnu.org/onlinedocs/gcc/Other-Builtins.html">https://gcc.gnu.org/onlinedocs/gcc/Other-Builtins.html</a>
</li>

<li>GCC: 6.60 Built-in Functions Specific to Particular Target Machines<br />
<a href="https://gcc.gnu.org/onlinedocs/gcc/Target-Builtins.html#Target-Builtins">https://gcc.gnu.org/onlinedocs/gcc/Target-Builtins.html#Target-Builtins</a>
</li>

<li>Advanced Vector Extensions<br />
<a href="https://en.wikipedia.org/wiki/Advanced_Vector_Extensions">https://en.wikipedia.org/wiki/Advanced_Vector_Extensions</a>
</li>

<li>AVX-512<br />
<a href="https://en.wikipedia.org/wiki/AVX-512">https://en.wikipedia.org/wiki/AVX-512</a>
</li>

<li>AVX-512<br />
<a href="https://iq.opengenus.org/avx512/">https://iq.opengenus.org/avx512/</a>
</li>

<li>Downclocking pro AVX-512<br />
<a href="https://en.wikipedia.org/wiki/Advanced_Vector_Extensions#Downclocking">https://en.wikipedia.org/wiki/Advanced_Vector_Extensions#Downclocking</a>
</li>

<li>BLENDPS — Blend Packed Single Precision Floating-Point Values<br />
<a href="https://www.felixcloutier.com/x86/blendps">https://www.felixcloutier.com/x86/blendps</a>
</li>

<li>BLENDPD — Blend Packed Double Precision Floating-Point Values<br />
<a href="https://www.felixcloutier.com/x86/blendpd">https://www.felixcloutier.com/x86/blendpd</a>
</li>

</ol>



<p></p><p></p>
<p><small>Autor: <a href="http://www.fit.vutbr.cz/~tisnovpa">Pavel Tišnovský</a> &nbsp; 2022</small></p>
</body>
</html>
