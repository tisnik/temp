<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
        "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html>
<head>
<title>Užitečné rozšíření GCC - podpora SIMD (vektorových) instrukcí: nedostatky</title>
<meta name="Author" content="Pavel Tisnovsky" />
<meta name="Generator" content="vim" />
<meta http-equiv="content-type" content="text/html; charset=utf-8" />
<style type="text/css">
         body {color:#000000; background:#ffffff;}
         h1  {font-family: arial, helvetica, sans-serif; color:#ffffff; background-color:#c00000; text-align:center; padding-left:1em}
         h2  {font-family: arial, helvetica, sans-serif; color:#ffffff; background-color:#0000c0; padding-left:1em; text-align:left}
         h3  {font-family: arial, helvetica, sans-serif; color:#000000; background-color:#c0c0c0; padding-left:1em; text-align:left}
         h4  {font-family: arial, helvetica, sans-serif; color:#000000; background-color:#e0e0e0; padding-left:1em; text-align:left}
         a   {font-family: arial, helvetica, sans-serif;}
         li  {font-family: arial, helvetica, sans-serif; color:#000000; text-align:justify; width:450px;}
         ol  {font-family: arial, helvetica, sans-serif; color:#000000; text-align:justify; width:450px;}
         ul  {font-family: arial, helvetica, sans-serif; color:#000000; text-align:justify; width:450px;}
         p   {font-family: arial, helvetica, sans-serif; color:#000000; text-align:justify;}
         pre {background:#e0e0e0}
</style>
</head>

<body>

<h1>Užitečné rozšíření GCC - podpora SIMD (vektorových) instrukcí: nedostatky</h1>

<h3>Pavel Tišnovský</h3>

<p></p>

<h1>Úvodník</h1>

<p>Podpora SIMD operací v rozšíření GCC je ve skutečnosti pouze částečná a má mnohé nedostatky, o nichž se dnes zmíníme. Taktéž si ukážeme, že vektory zavedené v rámci tohoto rozšíření není vhodné slepě používat namísto polí, neboť to nevede k optimálnímu kódu.</p>



<h2>Obsah</h2>

<p><a href="#k01">1. Užitečné rozšíření GCC &ndash; podpora SIMD (vektorových) instrukcí: nedostatky</a></p>
<p><a href="#k02">2. Vyplatí se používat dlouhé vektory?</a></p>
<p><a href="#k03">3. Předání vektorů do funkce hodnotou vs.&nbsp;referencí</a></p>
<p><a href="#k04">4. Způsob překladu vektorových operací do assembleru</a></p>
<p><a href="#k05">5. Tytéž operace, ovšem prováděné s&nbsp;prvky se znaménkem</a></p>
<p><a href="#k06">6. Způsob překladu vektorových operací do assembleru</a></p>
<p><a href="#k07">7. Vektorové operace nad vektory s&nbsp;prvky typu <strong>float</strong> a <strong>double</strong></a></p>
<p><a href="#k08">8. Překlad do assembleru</a></p>
<p><a href="#k09">9. Vektor není libovolně velké pole &ndash; omezení GCC</a></p>
<p><a href="#k10">10. Způsob překladu operace s&nbsp;dlouhým vektorem do assembleru</a></p>
<p><a href="#k11">11. Ne všechny operace mohou být v&nbsp;SIMD podporovány</a></p>
<p><a href="#k12">12. Výsledek překladu předchozího programu do kódu se SIMD operacemi</a></p>
<p><a href="#k13">13. Základní aritmetické operace s&nbsp;prvky vektorů typu <strong>float</strong></a></p>
<p><a href="#k14">14. Překlad bez použití instrukcí SIMD</a></p>
<p><a href="#k15">*** 15. Překlad do strojového kódu s&nbsp;použitím instrukcí SIMD</a></p>
<p><a href="#k16">16. Zásadní omezení rozšíření (sic) GCC</a></p>
<p><a href="#k17">17. SIMD a vektorové operace na architekturách AArch64 a RISC-V</a></p>
<p><a href="#k18">18. Příloha &ndash; soubor Makefile použitý v&nbsp;dnešním článku</a></p>
<p><a href="#k19">19. Repositář s&nbsp;demonstračními příklady</a></p>
<p><a href="#k20">20. Odkazy na Internetu</a></p>



<p><a name="k01"></a></p>
<h2 id="k01">1. Užitečné rozšíření GCC &ndash; podpora SIMD (vektorových) instrukcí: nedostatky</h2>

<p>Na <a
href="https://www.root.cz/clanky/uzitecne-rozsireni-gcc-podpora-simd-vektorovych-instrukci/">úvodní
článek o problematice využití SIMD operací na moderních mikroprocesorech
v&nbsp;jazyku C</a> dnes navážeme. Prozatím jsme si řekli, jaké SIMD operace
můžeme nalézt v&nbsp;rozšíření instrukčních sad pojmenovaných MMX, 3DNow!, SSE
a SSE2, což jsou (kromě zastaralé 3DNow!) rozšíření, která nalezneme
v&nbsp;prakticky všech dnes používaných čipech s&nbsp;architekturou x86
(x86-64) a bylo by dobré je začít ve vyšší míře nějakým způsobem používat.
Taktéž víme, že <a
href="https://gcc.gnu.org/onlinedocs/gcc/Vector-Extensions.html">rozšíření
překladače GCC C</a> dokáže do určité míry tyto rozšířené instrukční sady
skutečně využívat, protože programátorům nabízí základní aritmetické a logické
operace prováděné s&nbsp;vektory.</p>

<p>Ovšem toto řešení je ve skutečnosti pouze částečné, neboť má mnohé
nedostatky, o nichž se zmíníme v&nbsp;dnešním článku. Taktéž si ukážeme, že
vektory zavedené v&nbsp;rámci tohoto rozšíření není vhodné slepě používat
namísto polí (o předem zadané délce), neboť to nemusí vést k&nbsp;optimálnímu
kódu.</p>



<p><a name="k02"></a></p>
<h2 id="k02">2. Vyplatí se používat dlouhé vektory?</h2>

<p>Podívejme se nyní na následující demonstrační příklad, v&nbsp;němž je použit
relativně dlouhý vektor s&nbsp;celkem 256/4 = 64 prvky typu
<strong>float</strong>. Vektor zde tedy používáme ve funkci pole:</p>

<pre>
typedef <strong>float</strong> v256f <strong>__attribute__((vector_size(256)))</strong>;
&nbsp;
int <strong>main</strong>(void)
{
    v256f x = { 1.0 };
    v256f y = { 1.0 };
    v256f z = x + y;
&nbsp;
    return 0;
}
</pre>

<p>Tento demonstrační příklad je sice plně funkční, ovšem i tak je potenciálně
problematický. Na jeden problém narazíme vcelku rychle &ndash; tímto způsobem
lze totiž tvořit a používat pouze vektory s&nbsp;délkou, jenž je celočíselnou
mocninou dvojky. O tomto omezení se můžeme snadno přesvědčit ve chvíli, kdy se
pokusíme délku vektoru zvětšit o jeden prvek typu <strong>float</strong>, tedy
celkem o čtyři bajty (z&nbsp;256 bajtů na 260 bajtů):</p>

<pre>
typedef <strong>float</strong> v260f <strong>__attribute__((vector_size(260)))</strong>;
&nbsp;
int <strong>main</strong>(void)
{
    v260f x = { 1.0 };
    v260f y = { 1.0 };
    v260f z = x + y;
&nbsp;
    return 0;
}
</pre>

<p>Při pokusu o překlad tohoto zdrojového kódu nahlásí překladač chybu:</p>

<pre>
simd12B.c:1:1: error: number of components of the vector not a power of two
    1 | typedef float v260f __attribute__((vector_size(260)));
      | ^~~~~~~
</pre>

<p>Ovšem problémů je ve skutečnosti více &ndash; vektory se implicitně
předávají hodnotou a nikoli referencí (jako pole), vektorové operace se (na
x86-64) vždy provádí sekvencí instrukcí bez smyček atd. Tyto potenciální
problémy, které vlastně rostou s&nbsp;délkou vektorů, si popíšeme
v&nbsp;navazujících kapitolách.</p>



<p><a name="k03"></a></p>
<h2 id="k03">3. Předání vektorů do funkce hodnotou vs.&nbsp;referencí</h2>

<p>Pole se v&nbsp;programovacím jazyku C předávají referencí, o čemž se můžeme
velmi snadno přesvědčit překladem a spuštěním následujícího demonstračního
příkladu:</p>

<pre>
#include &lt;stdio.h&gt;
&nbsp;
typedef int <strong>array</strong>[4];
&nbsp;
void <strong>foo</strong>(array a)
{
    a[1] = 42;
}
&nbsp;
int <strong>main</strong>(void)
{
    array x = { 1, 2, 3, 4 };
&nbsp;
    printf("%d %d %d %d\n", x[0], x[1], x[2], x[3]);
&nbsp;
    foo(x);
    printf("%d %d %d %d\n", x[0], x[1], x[2], x[3]);
}
</pre>

<p>Pokud by se pole předávalo hodnotou, pracovala by funkce
<strong>foo</strong> s&nbsp;kopií pole a zobrazené zprávy by měly vypadat
takto:</p>

<pre>
1 2 3 4
1 2 3 4
</pre>

<p>Ve skutečnosti se pole předává referencí a proto je možné ve funkci
<strong>foo</strong> modifikovat jeho prvky:</p>

<pre>
1 2 3 4
1 42 3 4
</pre>

<p>U vektorů je tomu však jinak, o čemž se opět můžeme velmi snadno
přesvědčit:</p>

<pre>
#include &lt;stdio.h&gt;
&nbsp;
typedef int <strong>vector</strong> __attribute__((vector_size(16)));
&nbsp;
void <strong>foo</strong>(vector v)
{
    v[1] = 42;
}
&nbsp;
int <strong>main</strong>(void)
{
    vector x = { 1, 2, 3, 4 };
&nbsp;
    printf("%d %d %d %d\n", x[0], x[1], x[2], x[3]);
&nbsp;
    foo(x);
    printf("%d %d %d %d\n", x[0], x[1], x[2], x[3]);
}
</pre>

<p>Zde při překladu a spuštění dostaneme:</p>

<pre>
1 2 3 4
1 2 3 4
</pre>

<p>Tento výsledek ukazuje, že se vektory předávají hodnotou, což může být
náročná operace, zejména u delších vektorů.</p>



<p><a name="k04"></a></p>
<h2 id="k04">4. Způsob překladu vektorových operací do assembleru</h2>

<p>Vyzkoušejme si nyní, jak se přeloží funkce provádějící součet vektorů do
assembleru. Vše si otestujeme na funkcích, které sčítají vektory s&nbsp;prvky
typu <strong>unsigned char</strong>, <strong>unsigned short</strong>,
<strong>unsigned int</strong> a <strong>unsigned long</strong>:</p>

<pre>
#include &lt;stdio.h&gt;
&nbsp;
typedef unsigned char <strong>v16ub</strong> __attribute__((vector_size(16)));
&nbsp;
void <strong>add16ub</strong>(v16ub x, v16ub y, v16ub * z)
{
    *z = x + y;
}
&nbsp;
typedef unsigned short <strong>v16us</strong> __attribute__((vector_size(16)));
&nbsp;
void <strong>add16us</strong>(v16us x, v16us y, v16us * z)
{
    *z = x + y;
}
&nbsp;
typedef unsigned int <strong>v16ui</strong> __attribute__((vector_size(16)));
&nbsp;
void <strong>add16ui</strong>(v16ui x, v16ui y, v16ui * z)
{
    *z = x + y;
}
&nbsp;
typedef unsigned long int <strong>v16ul</strong> __attribute__((vector_size(16)));
&nbsp;
void <strong>add16ul</strong>(v16ul x, v16ul y, v16ul * z)
{
    *z = x + y;
}
&nbsp;
int <strong>main</strong>(void)
{
    {
        v16ub x = { 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15 };
        v16ub y =
            { 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
            0xff, 0xff, 0xff, 0xff, 0xff, 0xff
        };
        v16ub z;
&nbsp;
        add16ub(x, y, &nbsp;z);
&nbsp;
        int i;
&nbsp;
        puts("vector of unsigned chars");
&nbsp;
        for (i = 0; i &lt; sizeof(v16ub) / sizeof(unsigned char); i++) {
            printf("%d %u\n", i, z[i]);
        }
    }
&nbsp;
    putchar('\n');
&nbsp;
    {
        v16us x = { 0, 1, 2, 3, 4, 5, 6, 7 };
        v16us y = { 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,
            0xffff
        };
        v16us z;
&nbsp;
        add16us(x, y, &nbsp;z);
&nbsp;
        int i;
&nbsp;
        puts("vector of unsigned short ints");
&nbsp;
        for (i = 0; i &lt; sizeof(v16us) / sizeof(unsigned short); i++) {
            printf("%d %u\n", i, z[i]);
        }
    }
&nbsp;
    putchar('\n');
&nbsp;
    {
        v16ui x = { 0, 1, 2, 3 };
        v16ui y = { 0xffffffff, 0xffffffff, 0xffffffff, 0xffffffff };
        v16ui z;
&nbsp;
        add16ui(x, y, &nbsp;z);
&nbsp;
        int i;
&nbsp;
        puts("vector of unsigned ints");
&nbsp;
        for (i = 0; i &lt; sizeof(v16ui) / sizeof(unsigned int); i++) {
            printf("%d %u\n", i, z[i]);
        }
    }
&nbsp;
    putchar('\n');
&nbsp;
    {
        v16ul x = { 0, 1 };
        v16ul y = { 0xffffffffffffffff, 0xffffffffffffffff };
        v16ul z;
&nbsp;
        add16ul(x, y, &nbsp;z);
&nbsp;
        int i;
&nbsp;
        puts("vector of unsigned longs");
&nbsp;
        for (i = 0; i &lt; sizeof(v16ul) / sizeof(unsigned long); i++) {
            printf("%d %lu\n", i, z[i]);
        }
    }
&nbsp;
    return 0;
}
</pre>

<p>S&nbsp;výsledky:</p>

<pre>
vector of unsigned chars
0 255
1 0
2 1
3 2
4 3
5 4
6 5
7 6
8 7
9 8
10 9
11 10
12 11
13 12
14 13
15 14
&nbsp;
vector of unsigned short ints
0 65535
1 0
2 1
3 2
4 3
5 4
6 5
7 6
&nbsp;
vector of unsigned ints
0 4294967295
1 0
2 1
3 2
&nbsp;
vector of unsigned longs
0 18446744073709551615
1 0
</pre>

<p><div class="rs-tip-major">Poznámka: povšimněte si přetečení výsledků, které
je očekávatelné.</div></p>

<p>Překlad výše uvedeného kódu do assembleru vypadá takto.</p>

<p>Nejdříve se při zákazu SIMD operací provede maskování bajtů, 16bitových slov
nebo 32bitových slov a paralelní výpočty v&nbsp;rámci 64bitových registrů. Tím
se simuluje součet po bajtech, 16bitových slovech a 32bitových slovech:</p>

<pre>
   c:   48 8b 45 10             mov    rax,QWORD PTR [rbp+0x10]
  10:   48 8b 55 20             mov    rdx,QWORD PTR [rbp+0x20]
  14:   48 89 c6                mov    rsi,rax
  17:   48 31 d6                xor    rsi,rdx
  1a:   48 b9 7f 7f 7f 7f 7f    movabs rcx,0x7f7f7f7f7f7f7f7f
  21:   7f 7f 7f 
  24:   48 21 d1                <strong>and    rcx,rdx</strong>
  27:   48 ba 7f 7f 7f 7f 7f    movabs rdx,0x7f7f7f7f7f7f7f7f
  2e:   7f 7f 7f 
  31:   48 21 d0                <strong>and    rax,rdx</strong>
  34:   48 ba 80 80 80 80 80    movabs rdx,0x8080808080808080
  3b:   80 80 80 
  3e:   48 21 f2                and    rdx,rsi
  41:   48 01 c8                add    rax,rcx
  44:   48 89 d6                mov    rsi,rdx
  47:   48 31 c6                xor    rsi,rax
  4a:   48 8b 45 18             mov    rax,QWORD PTR [rbp+0x18]
  4e:   48 8b 55 28             mov    rdx,QWORD PTR [rbp+0x28]
  52:   48 89 c7                mov    rdi,rax
  55:   48 31 d7                xor    rdi,rdx
  58:   48 b9 7f 7f 7f 7f 7f    movabs rcx,0x7f7f7f7f7f7f7f7f
  5f:   7f 7f 7f 
  62:   48 21 d1                <strong>and    rcx,rdx</strong>
  65:   48 ba 7f 7f 7f 7f 7f    movabs rdx,0x7f7f7f7f7f7f7f7f
  6c:   7f 7f 7f 
  6f:   48 21 d0                <strong>and    rax,rdx</strong>
  72:   48 ba 80 80 80 80 80    movabs rdx,0x8080808080808080
  79:   80 80 80 
  7c:   48 21 fa                and    rdx,rdi
  7f:   48 01 c8                add    rax,rcx
  82:   48 89 d1                mov    rcx,rdx
  85:   48 31 c1                xor    rcx,rax
  88:   b8 00 00 00 00          mov    eax,0x0
  8d:   ba 00 00 00 00          mov    edx,0x0
  92:   48 89 f0                mov    rax,rsi
  95:   48 89 ca                mov    rdx,rcx
  98:   48 8b 4d f8             mov    rcx,QWORD PTR [rbp-0x8]
  9c:   48 89 01                mov    QWORD PTR [rcx],rax
  9f:   48 89 51 08             mov    QWORD PTR [rcx+0x8],rdx
</pre>

<p><div class="rs-tip-major">Poznámka: výše uvedená ukázka platí pro součet
prvků typu <strong>unsigned char</strong>. Podobně &ndash; akorát se širší
maskou &ndash; tomu bude u prvků typu <strong>unsigned short</strong> i
<strong>unsigned int</strong>.</div></p>

<p>Nás však zajímají &bdquo;vektorové&ldquo; výpočty.</p>

<p>Součet vektorů s&nbsp;prvky typu <strong>unsigned char</strong> zajišťuje
instrukce <a
href="https://www.felixcloutier.com/x86/paddb:paddw:paddd:paddq">PADDB</a>:</p>

<pre>
   8:   0f 29 45 f0             movaps XMMWORD PTR [rbp-0x10],xmm0
   c:   0f 29 4d e0             movaps XMMWORD PTR [rbp-0x20],xmm1
  10:   48 89 7d d8             mov    QWORD PTR [rbp-0x28],rdi
    *z = x + y;
  14:   66 0f 6f 45 f0          movdqa xmm0,XMMWORD PTR [rbp-0x10]
  19:   66 0f fc 45 e0          <strong>paddb  xmm0,XMMWORD PTR [rbp-0x20]</strong>
  1e:   48 8b 45 d8             mov    rax,QWORD PTR [rbp-0x28]
  22:   0f 29 00                movaps XMMWORD PTR [rax],xmm0
</pre>

<p>Součet vektorů s&nbsp;prvky typu <strong>unsigned short</strong> (neboli
v&nbsp;assembleru &bdquo;word&ldquo;) zajišťuje instrukce
<strong>PADDW</strong>:</p>

<pre>
  30:   0f 29 45 f0             movaps XMMWORD PTR [rbp-0x10],xmm0
  34:   0f 29 4d e0             movaps XMMWORD PTR [rbp-0x20],xmm1
  38:   48 89 7d d8             mov    QWORD PTR [rbp-0x28],rdi
    *z = x + y;
  3c:   66 0f 6f 45 f0          movdqa xmm0,XMMWORD PTR [rbp-0x10]
  41:   66 0f fd 45 e0          <strong>paddw  xmm0,XMMWORD PTR [rbp-0x20]</strong>
  46:   48 8b 45 d8             mov    rax,QWORD PTR [rbp-0x28]
  4a:   0f 29 00                movaps XMMWORD PTR [rax],xmm0
</pre>

<p>Součet po 32bitových &bdquo;dvouslovech&ldquo; (&bdquo;double word&ldquo;)
je vykonán instrukcí <strong>PADDD</strong>:</p>

<pre>
  58:   0f 29 45 f0             movaps XMMWORD PTR [rbp-0x10],xmm0
  5c:   0f 29 4d e0             movaps XMMWORD PTR [rbp-0x20],xmm1
  60:   48 89 7d d8             mov    QWORD PTR [rbp-0x28],rdi
    *z = x + y;
  64:   66 0f 6f 45 f0          movdqa xmm0,XMMWORD PTR [rbp-0x10]
  69:   66 0f fe 45 e0          <strong>paddd  xmm0,XMMWORD PTR [rbp-0x20]</strong>
  6e:   48 8b 45 d8             mov    rax,QWORD PTR [rbp-0x28]
  72:   0f 29 00                movaps XMMWORD PTR [rax],xmm0
</pre>

<p>A konečně součet po &bdquo;čtyřslovech&ldquo; (&bdquo;quad word&ldquo;) je
realizován instrukcí <strong>PADDQ</strong>:</p>

<pre>
  80:   0f 29 45 f0             movaps XMMWORD PTR [rbp-0x10],xmm0
  84:   0f 29 4d e0             movaps XMMWORD PTR [rbp-0x20],xmm1
  88:   48 89 7d d8             mov    QWORD PTR [rbp-0x28],rdi
    *z = x + y;
  8c:   66 0f 6f 45 f0          movdqa xmm0,XMMWORD PTR [rbp-0x10]
  91:   66 0f d4 45 e0          paddq  xmm0,XMMWORD PTR [rbp-0x20]
  96:   48 8b 45 d8             mov    rax,QWORD PTR [rbp-0x28]
  9a:   0f 29 00                movaps XMMWORD PTR [rax],xmm0
</pre>

<p><div class="rs-tip-major">Poznámka: zde jsou tedy vektorové operace
přeloženy do velmi efektivního kódu.</div></p>



<p><a name="k05"></a></p>
<h2 id="k05">5. Tytéž operace, ovšem prováděné s&nbsp;prvky se znaménkem</h2>

<p>V&nbsp;této kapitole si ukážeme podobný příklad, jako byl ten <a
href="#k04">z&nbsp;předchozí kapitoly</a>, nyní ovšem s&nbsp;vektory, jejichž
prvky jsou typu <strong>signed char/short/int/long</strong>:</p>

<pre>
#include &lt;stdio.h&gt;
&nbsp;
typedef signed char <strong>v16sb</strong> __attribute__((vector_size(16)));
&nbsp;
void <strong>add16ub</strong>(v16sb x, v16sb y, v16sb * z)
{
    *z = x + y;
}
&nbsp;
typedef signed short <strong>v16ss</strong> __attribute__((vector_size(16)));
&nbsp;
void <strong>add16us</strong>(v16ss x, v16ss y, v16ss * z)
{
    *z = x + y;
}
&nbsp;
typedef signed int <strong>v16si</strong> __attribute__((vector_size(16)));
&nbsp;
void <strong>add16ui</strong>(v16si x, v16si y, v16si * z)
{
    *z = x + y;
}
&nbsp;
typedef signed long int <strong>v16sl</strong> __attribute__((vector_size(16)));
&nbsp;
void <strong>add16ul</strong>(v16sl x, v16sl y, v16sl * z)
{
    *z = x + y;
}
&nbsp;
int <strong>main</strong>(void)
{
    {
        v16sb x = { 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15 };
        v16sb y =
            { 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
            0xff, 0xff, 0xff, 0xff, 0xff, 0xff
        };
        v16sb z;
&nbsp;
        add16ub(x, y, &nbsp;z);
&nbsp;
        int i;
&nbsp;
        puts("vector of signed chars");
&nbsp;
        for (i = 0; i &lt; sizeof(v16sb) / sizeof(signed char); i++) {
            printf("%d %d\n", i, z[i]);
        }
    }
&nbsp;
    putchar('\n');
&nbsp;
    {
        v16ss x = { 0, 1, 2, 3, 4, 5, 6, 7 };
        v16ss y = { 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,
            0xffff
        };
        v16ss z;
&nbsp;
        add16us(x, y, &nbsp;z);
&nbsp;
        int i;
&nbsp;
        puts("vector of signed short ints");
&nbsp;
        for (i = 0; i &lt; sizeof(v16ss) / sizeof(signed short); i++) {
            printf("%d %d\n", i, z[i]);
        }
    }
&nbsp;
    putchar('\n');
&nbsp;
    {
        v16si x = { 0, 1, 2, 3 };
        v16si y = { 0xffffffff, 0xffffffff, 0xffffffff, 0xffffffff };
        v16si z;
&nbsp;
        add16ui(x, y, &nbsp;z);
&nbsp;
        int i;
&nbsp;
        puts("vector of signed ints");
&nbsp;
        for (i = 0; i &lt; sizeof(v16si) / sizeof(signed int); i++) {
            printf("%d %d\n", i, z[i]);
        }
    }
&nbsp;
    putchar('\n');
&nbsp;
    {
        v16sl x = { 0, 1 };
        v16sl y = { 0xffffffffffffffff, 0xffffffffffffffff };
        v16sl z;
&nbsp;
        add16ul(x, y, &nbsp;z);
&nbsp;
        int i;
&nbsp;
        puts("vector of signed longs");
&nbsp;
        for (i = 0; i &lt; sizeof(v16sl) / sizeof(signed long); i++) {
            printf("%d %ld\n", i, z[i]);
        }
    }
&nbsp;
    return 0;
}
</pre>

<p>Výsledky všech čtyř vektorových operací vypadají následovně:</p>

<pre>
vector of signed chars
0 -1
1 0
2 1
3 2
4 3
5 4
6 5
7 6
8 7
9 8
10 9
11 10
12 11
13 12
14 13
15 14
&nbsp;
vector of signed short ints
0 -1
1 0
2 1
3 2
4 3
5 4
6 5
7 6
&nbsp;
vector of signed ints
0 -1
1 0
2 1
3 2
&nbsp;
vector of signed longs
0 -1
1 0
</pre>



<p><a name="k06"></a></p>
<h2 id="k06">6. Způsob překladu vektorových operací do assembleru</h2>

<p>Vytištěné výsledky jsou sice značně odlišné (ostatně podle očekávání), ale
jak se odlišuje sekvence instrukcí získaná přeložením těchto příkladů.</p>

<p>&bdquo;Nevektorová varianta&ldquo;:</p>

<pre>
    *z = x + y;
   c:   48 8b 45 10             mov    rax,QWORD PTR [rbp+0x10]
  10:   48 8b 55 20             mov    rdx,QWORD PTR [rbp+0x20]
  14:   48 89 c6                mov    rsi,rax
  17:   48 31 d6                xor    rsi,rdx
  1a:   48 b9 7f 7f 7f 7f 7f    movabs rcx,0x7f7f7f7f7f7f7f7f
  21:   7f 7f 7f 
  24:   48 21 d1                and    rcx,rdx
  27:   48 ba 7f 7f 7f 7f 7f    movabs rdx,0x7f7f7f7f7f7f7f7f
  2e:   7f 7f 7f 
  31:   48 21 d0                and    rax,rdx
  34:   48 ba 80 80 80 80 80    movabs rdx,0x8080808080808080
  3b:   80 80 80 
  3e:   48 21 f2                and    rdx,rsi
  41:   48 01 c8                add    rax,rcx
  44:   48 89 d6                mov    rsi,rdx
  47:   48 31 c6                xor    rsi,rax
  4a:   48 8b 45 18             mov    rax,QWORD PTR [rbp+0x18]
  4e:   48 8b 55 28             mov    rdx,QWORD PTR [rbp+0x28]
  52:   48 89 c7                mov    rdi,rax
  55:   48 31 d7                xor    rdi,rdx
  58:   48 b9 7f 7f 7f 7f 7f    movabs rcx,0x7f7f7f7f7f7f7f7f
  5f:   7f 7f 7f 
  62:   48 21 d1                and    rcx,rdx
  65:   48 ba 7f 7f 7f 7f 7f    movabs rdx,0x7f7f7f7f7f7f7f7f
  6c:   7f 7f 7f 
  6f:   48 21 d0                and    rax,rdx
  72:   48 ba 80 80 80 80 80    movabs rdx,0x8080808080808080
  79:   80 80 80 
  7c:   48 21 fa                and    rdx,rdi
  7f:   48 01 c8                add    rax,rcx
  82:   48 89 d1                mov    rcx,rdx
  85:   48 31 c1                xor    rcx,rax
  88:   b8 00 00 00 00          mov    eax,0x0
  8d:   ba 00 00 00 00          mov    edx,0x0
  92:   48 89 f0                mov    rax,rsi
  95:   48 89 ca                mov    rdx,rcx
  98:   48 8b 4d f8             mov    rcx,QWORD PTR [rbp-0x8]
  9c:   48 89 01                mov    QWORD PTR [rcx],rax
  9f:   48 89 51 08             mov    QWORD PTR [rcx+0x8],rdx
</pre>

<p>Součet vektorů s&nbsp;prvky typu <strong>signed char</strong>:</p>

<pre>
   8:   0f 29 45 f0             movaps XMMWORD PTR [rbp-0x10],xmm0
   c:   0f 29 4d e0             movaps XMMWORD PTR [rbp-0x20],xmm1
  10:   48 89 7d d8             mov    QWORD PTR [rbp-0x28],rdi
    *z = x + y;
  14:   66 0f 6f 45 f0          movdqa xmm0,XMMWORD PTR [rbp-0x10]
  19:   66 0f fc 45 e0          <strong>paddb  xmm0,XMMWORD PTR [rbp-0x20]</strong>
  1e:   48 8b 45 d8             mov    rax,QWORD PTR [rbp-0x28]
  22:   0f 29 00                movaps XMMWORD PTR [rax],xmm0
</pre>

<p>Součet vektorů s&nbsp;prvky typu <strong>signed short</strong>:</p>

<pre>
  30:   0f 29 45 f0             movaps XMMWORD PTR [rbp-0x10],xmm0
  34:   0f 29 4d e0             movaps XMMWORD PTR [rbp-0x20],xmm1
  38:   48 89 7d d8             mov    QWORD PTR [rbp-0x28],rdi
    *z = x + y;
  3c:   66 0f 6f 45 f0          movdqa xmm0,XMMWORD PTR [rbp-0x10]
  41:   66 0f fd 45 e0          <strong>paddw  xmm0,XMMWORD PTR [rbp-0x20]</strong>
  46:   48 8b 45 d8             mov    rax,QWORD PTR [rbp-0x28]
  4a:   0f 29 00                movaps XMMWORD PTR [rax],xmm0
</pre>

<p>Součet vektorů s&nbsp;prvky typu <strong>signed int</strong>:</p>

<pre>
  58:   0f 29 45 f0             movaps XMMWORD PTR [rbp-0x10],xmm0
  5c:   0f 29 4d e0             movaps XMMWORD PTR [rbp-0x20],xmm1
  60:   48 89 7d d8             mov    QWORD PTR [rbp-0x28],rdi
    *z = x + y;
  64:   66 0f 6f 45 f0          movdqa xmm0,XMMWORD PTR [rbp-0x10]
  69:   66 0f fe 45 e0          <strong>paddd  xmm0,XMMWORD PTR [rbp-0x20]</strong>
  6e:   48 8b 45 d8             mov    rax,QWORD PTR [rbp-0x28]
  72:   0f 29 00                movaps XMMWORD PTR [rax],xmm0
</pre>

<p>A konečně součet vektorů s&nbsp;prvky typu <strong>signed long</strong>:</p>

<pre>
  80:   0f 29 45 f0             movaps XMMWORD PTR [rbp-0x10],xmm0
  84:   0f 29 4d e0             movaps XMMWORD PTR [rbp-0x20],xmm1
  88:   48 89 7d d8             mov    QWORD PTR [rbp-0x28],rdi
    *z = x + y;
  8c:   66 0f 6f 45 f0          movdqa xmm0,XMMWORD PTR [rbp-0x10]
  91:   66 0f d4 45 e0          <strong>paddq  xmm0,XMMWORD PTR [rbp-0x20]</strong>
  96:   48 8b 45 d8             mov    rax,QWORD PTR [rbp-0x28]
  9a:   0f 29 00                movaps XMMWORD PTR [rax],xmm0
</pre>

<p><div class="rs-tip-major">Poznámka: na tomto příkladu je patrné, že se
výsledné sekvence instrukcí nijak neliší.</div></p>



<p><a name="k07"></a></p>
<h2 id="k07">7. Vektorové operace nad vektory s&nbsp;prvky typu <strong>float</strong> a <strong>double</strong></h2>

<p>Zbývá nám zjistit, jakým způsobem se přeloží kód s&nbsp;vektory, jejichž
prvky jsou typu <strong>float</strong> a <strong>double</strong>:</p>

<pre>
#include &lt;stdio.h&gt;
&nbsp;
typedef float <strong>v16float</strong> __attribute__((vector_size(16)));
&nbsp;
void <strong>add16float</strong>(v16float x, v16float y, v16float * z)
{
    *z = x + y;
}
&nbsp;
typedef double <strong>v16double</strong> __attribute__((vector_size(16)));
&nbsp;
void <strong>add16double</strong>(v16double x, v16double y, v16double * z)
{
    *z = x + y;
}
&nbsp;
int <strong>main</strong>(void)
{
    {
        v16float x = { 0, 1, 2, 3 };
        v16float y = { 0.1, 0.1, 0.1, 0.1 };
        v16float z;
&nbsp;
        add16float(x, y, &nbsp;z);
&nbsp;
        int i;
&nbsp;
        puts("vector of floats");
&nbsp;
        for (i = 0; i &lt; sizeof(v16float) / sizeof(float); i++) {
            printf("%d %f\n", i, z[i]);
        }
    }
&nbsp;
    putchar('\n');
&nbsp;
    {
        v16double x = { 0, 1 };
        v16double y = { 0.1, 0.1 };
        v16double z;
&nbsp;
        add16double(x, y, &nbsp;z);
&nbsp;
        int i;
&nbsp;
        puts("vector of doubles");
&nbsp;
        for (i = 0; i &lt; sizeof(v16double) / sizeof(double); i++) {
            printf("%d %f\n", i, z[i]);
        }
    }
    return 0;
}
</pre>

<p>Výsledky získané po překladu a spuštění tohoto jednoduchého demonstračního
příkladu:</p>

<pre>
vector of floats
0 0.100000
1 1.100000
2 2.100000
3 3.100000
&nbsp;
vector of doubles
0 0.100000
1 1.100000
</pre>



<p><a name="k08"></a></p>
<h2 id="k08">8. Překlad do assembleru</h2>

<p>Pokud jsou SIMD instrukce při překladu zakázány, jsou vektory sčítány prvek
po prvku, zde konkrétně s&nbsp;využitím instrukce matematického koprocesoru <a
href="https://www.felixcloutier.com/x86/fadd:faddp:fiadd">FADDP</a>. Pro
původní prvky typu <strong>float</strong> se musí provést čtyři součty:</p>

<pre>
    *z = x + y;
   c:   d9 45 10                fld    DWORD PTR [rbp+0x10]
   f:   d9 45 20                fld    DWORD PTR [rbp+0x20]
  12:   de c1                   <strong>faddp  st(1),st</strong>
  14:   d9 45 14                fld    DWORD PTR [rbp+0x14]
  17:   d9 45 24                fld    DWORD PTR [rbp+0x24]
  1a:   de c1                   <strong>faddp  st(1),st</strong>
  1c:   d9 45 18                fld    DWORD PTR [rbp+0x18]
  1f:   d9 45 28                fld    DWORD PTR [rbp+0x28]
  22:   de c1                   <strong>faddp  st(1),st</strong>
  24:   d9 45 1c                fld    DWORD PTR [rbp+0x1c]
  27:   d9 45 2c                fld    DWORD PTR [rbp+0x2c]
  2a:   de c1                   <strong>faddp  st(1),st</strong>
  2c:   d9 cb                   fxch   st(3)
  2e:   d9 5d d0                fstp   DWORD PTR [rbp-0x30]
  31:   d9 c9                   fxch   st(1)
  33:   d9 5d d4                fstp   DWORD PTR [rbp-0x2c]
  36:   d9 5d d8                fstp   DWORD PTR [rbp-0x28]
  39:   d9 5d dc                fstp   DWORD PTR [rbp-0x24]
  3c:   48 8b 45 d0             mov    rax,QWORD PTR [rbp-0x30]
  40:   48 89 45 f0             mov    QWORD PTR [rbp-0x10],rax
  44:   48 8b 45 d8             mov    rax,QWORD PTR [rbp-0x28]
  48:   48 89 45 f8             mov    QWORD PTR [rbp-0x8],rax
  4c:   48 8b 45 e8             mov    rax,QWORD PTR [rbp-0x18]
  50:   48 8b 55 f0             mov    rdx,QWORD PTR [rbp-0x10]
  54:   48 89 10                mov    QWORD PTR [rax],rdx
  57:   48 8b 55 f8             mov    rdx,QWORD PTR [rbp-0x8]
  5b:   48 89 50 08             mov    QWORD PTR [rax+0x8],rdx
</pre>

<p>Pro prvky vektorů typu <strong>double</strong> se použijí pouze dvě operace
součtu, protože celková délka vektoru je 2&times;sizeof(double)=16 bajtů:</p>

<pre>
  6e:   dd 45 10                fld    QWORD PTR [rbp+0x10]
  71:   dd 45 20                fld    QWORD PTR [rbp+0x20]
  74:   de c1                   <strong>faddp  st(1),st</strong>
  76:   dd 45 18                fld    QWORD PTR [rbp+0x18]
  79:   dd 45 28                fld    QWORD PTR [rbp+0x28]
  7c:   de c1                   <strong>faddp  st(1),st</strong>
  7e:   d9 c9                   fxch   st(1)
  80:   dd 5d d0                fstp   QWORD PTR [rbp-0x30]
  83:   dd 5d d8                fstp   QWORD PTR [rbp-0x28]
  86:   48 8b 45 d0             mov    rax,QWORD PTR [rbp-0x30]
  8a:   48 89 45 f0             mov    QWORD PTR [rbp-0x10],rax
  8e:   48 8b 45 d8             mov    rax,QWORD PTR [rbp-0x28]
  92:   48 89 45 f8             mov    QWORD PTR [rbp-0x8],rax
  96:   48 8b 45 e8             mov    rax,QWORD PTR [rbp-0x18]
  9a:   48 8b 55 f0             mov    rdx,QWORD PTR [rbp-0x10]
  9e:   48 89 10                mov    QWORD PTR [rax],rdx
  a1:   48 8b 55 f8             mov    rdx,QWORD PTR [rbp-0x8]
  a5:   48 89 50 08             mov    QWORD PTR [rax+0x8],rdx
</pre>

<p>Pro nás je dnes pochopitelně mnohem zajímavější překlad využívající SIMD
instrukce. Součet prvků vektoru typu <strong>float</strong> je realizován takto
&ndash; instrukcí <a href="https://www.felixcloutier.com/x86/addps">ADDPS</a>
(viz též úvodní článek):</p>

<pre>
    *z = x + y;
  14:   0f 28 45 f0             movaps xmm0,XMMWORD PTR [rbp-0x10]
  18:   0f 58 45 e0             <strong>addps  xmm0,XMMWORD PTR [rbp-0x20]</strong>
  1c:   48 8b 45 d8             mov    rax,QWORD PTR [rbp-0x28]
  20:   0f 29 00                movaps XMMWORD PTR [rax],xmm0
</pre>

<p>A pro vektory s&nbsp;prvky typu <strong>double</strong> vypadá jejich součet
následovně &ndash; je realizován instrukcí <a
href="https://www.felixcloutier.com/x86/addpd">ADDPD</a>:</p>

<pre>
  3a:   66 0f 28 45 f0          movapd xmm0,XMMWORD PTR [rbp-0x10]
  3f:   66 0f 58 45 e0          <strong>addpd  xmm0,XMMWORD PTR [rbp-0x20]</strong>
  44:   48 8b 45 d8             mov    rax,QWORD PTR [rbp-0x28]
  48:   0f 29 00                movaps XMMWORD PTR [rax],xmm0
</pre>



<p><a name="k09"></a></p>
<h2 id="k09">9. Vektor není libovolně velké pole &ndash; omezení GCC</h2>

<p>Z&nbsp;předchozího textu by se mohlo zdát, že vektory zavedené v&nbsp;rámci
rozšíření GCC jsou vlastně určitou formou polí a že je možné nebo vhodné
nahradit pole (předem známé délky) právě za vektory, bez ohledu na jejich
velikost. Teoreticky to samozřejmě možné je, ale výsledná sekvence instrukcí
vygenerovaná překladačem nás může nepříjemně překvapit, zejména ve chvíli, kdy
se například pokusíme vytvořit vektor se všemi pixely obrázku atd.</p>

<p>Vyzkoušejme si to na příkladu, v&nbsp;němž je použit vektor s&nbsp;délkou
1024 bajtů (což je vlastně s&nbsp;ohledem na další možné varianty ještě velmi
krátký vektor):</p>

<pre>
typedef <strong>float</strong> v1024f <strong>__attribute__((vector_size(1024)))</strong>;
&nbsp;
void addVectors(v1024f * x, v1024f * y, v1024f * z)
{
    *z = *x + *y;
}
&nbsp;
int main(void)
{
    v1024f x = { 1.0 };
    v1024f y = { 1.0 };
    v1024f z;
&nbsp;
    addVectors(&nbsp;x, &nbsp;y, &nbsp;z);
&nbsp;
    return 0;
}
</pre>

<p><div class="rs-tip-major">Poznámka: povšimněte si, že zdrojové vektory
předáváme přes ukazatel a nikoli hodnotou &ndash; to by v&nbsp;žádném případě
nebylo efektivní. Navíc namísto cílové hodnoty opět používáme předávání přes
ukazatel, a to ze stejného důvodu (navíc by si překladač stěžoval na problém
vrácení zarovnané 1024 bajtové hodnoty).</div></p>



<p><a name="k10"></a></p>
<h2 id="k10">10. Způsob překladu operace s&nbsp;dlouhým vektorem do assembleru</h2>

<p>Nyní se můžeme podívat na výsledek překladu předchozího demonstračního
příkladu v&nbsp;případě, že je překlad proveden s&nbsp;vypnutím SIMD instrukcí
(zde konkrétně se použil přepínač <strong>-mno-sse</strong>). Přeložená funkce
je v&nbsp;tomto případě obrovská, protože strojový kód přesahuje pět kilobajtů.
Nejprve můžeme vidět dva blokové přesuny dat, přičemž každý blok má velikost
1024 bajtů (přesouvá se 128&times;8 bajtů). Tyto přesuny jsou realizovány
instrukcí <strong>movs</strong> s&nbsp;prefixem <strong>rep</strong>:</p>

<pre>
      3a:       48 8b 94 24 80 0b 00    mov    rdx,QWORD PTR [rsp+0xb80]
      41:       00 
      42:       48 8d 84 24 88 0b 00    lea    rax,[rsp+0xb88]
      49:       00 
      4a:       48 89 d6                mov    rsi,rdx
      4d:       ba 80 00 00 00          mov    edx,0x80
      52:       48 89 c7                mov    rdi,rax
      55:       48 89 d1                mov    rcx,rdx
      58:       f3 48 a5                <strong>rep movs QWORD PTR es:[rdi],QWORD PTR ds:[rsi]</strong>
      5b:       48 8b 94 24 78 0b 00    mov    rdx,QWORD PTR [rsp+0xb78]
      62:       00 
      63:       48 8d 84 24 88 0f 00    lea    rax,[rsp+0xf88]
      6a:       00 
      6b:       48 89 d6                mov    rsi,rdx
      6e:       ba 80 00 00 00          mov    edx,0x80
      73:       48 89 c7                mov    rdi,rax
      76:       48 89 d1                mov    rcx,rdx
      79:       f3 48 a5                <strong>rep movs QWORD PTR es:[rdi],QWORD PTR ds:[rsi]</strong>
</pre>

<p>Dále můžeme v&nbsp;kódu vidět opakující se sekvenci čtveřice instrukcí
<strong>fld+fld+faddp+fstp</strong>, což znamená, že se na zásobník
<strong>ST</strong> uloží dvojice operandů typu <strong>float</strong>, ty se
sečtou s&nbsp;uložením výsledku zpět na zásobník a nakonec se výsledek uloží
instrukcí <strong>fstp</strong> (písmeno &bdquo;p&ldquo; na konci znamená
&bdquo;pop&ldquo; a nikoli &bdquo;parallel&ldquo;, jako je tomu
v&nbsp;SSE):</p>

<pre>
      7c:       d9 84 24 88 0b 00 00    fld    DWORD PTR [rsp+0xb88]
      83:       d9 84 24 88 0f 00 00    fld    DWORD PTR [rsp+0xf88]
      8a:       de c1                   faddp  st(1),st
      8c:       d9 9c 24 64 07 00 00    fstp   DWORD PTR [rsp+0x764]
</pre>

<pre>
      93:       d9 84 24 8c 0b 00 00    fld    DWORD PTR [rsp+0xb8c]
      9a:       d9 84 24 8c 0f 00 00    fld    DWORD PTR [rsp+0xf8c]
      a1:       de c1                   faddp  st(1),st
      a3:       d9 9c 24 60 07 00 00    fstp   DWORD PTR [rsp+0x760]
</pre>

<pre>
      aa:       d9 84 24 90 0b 00 00    fld    DWORD PTR [rsp+0xb90]
      b1:       d9 84 24 90 0f 00 00    fld    DWORD PTR [rsp+0xf90]
      b8:       de c1                   faddp  st(1),st
      ba:       d9 9c 24 5c 07 00 00    fstp   DWORD PTR [rsp+0x75c]
</pre>

<p>Tato sekvence se opakuje 256&times; (!), což přesně odpovídá počtu prvků
vektoru. Na konci je sekvence instrukcí poněkud odlišná, neboť výsledky
zůstávají na zásobníku (pro osm prvků):</p>

<pre>
    171b:       d9 84 24 7c 0f 00 00    fld    DWORD PTR [rsp+0xf7c]
    1722:       d9 84 24 7c 13 00 00    fld    DWORD PTR [rsp+0x137c]
    1729:       de c1                   faddp  st(1),st
    172b:       d9 84 24 80 0f 00 00    fld    DWORD PTR [rsp+0xf80]
    1732:       d9 84 24 80 13 00 00    fld    DWORD PTR [rsp+0x1380]
    1739:       de c1                   faddp  st(1),st
    173b:       d9 84 24 84 0f 00 00    fld    DWORD PTR [rsp+0xf84]
    1742:       d9 84 24 84 13 00 00    fld    DWORD PTR [rsp+0x1384]
    1749:       de c1                   faddp  st(1),st
    174b:       d9 84 24 64 07 00 00    fld    DWORD PTR [rsp+0x764]
    1752:       d9 9c 24 68 07 00 00    fstp   DWORD PTR [rsp+0x768]
</pre>

<p><div class="rs-tip-major">Poznámka: podobný kód, pokud by se měl často
opakovat v&nbsp;dalších variantách, by mohl vést k&nbsp;tomu, že by se zbytečně
zaplňovala L1 cache mikroprocesoru.</div></p>

<p>Při zapnutí optimalizací dostaneme nepatrně lepší kód, v&nbsp;němž se na
zásobník ukládá pouze jeden z&nbsp;operandů. Ono opakování výpočtu 256&times;
je zde stále použito, stejně jako oba blokové přesuny na začátku:</p>

<pre>
      4f:       d9 84 24 88 03 00 00    fld    DWORD PTR [rsp+0x388]
      56:       d8 84 24 88 07 00 00    fadd   DWORD PTR [rsp+0x788]
      5d:       d9 5c 24 88             fstp   DWORD PTR [rsp-0x78]
      61:       d9 84 24 8c 03 00 00    fld    DWORD PTR [rsp+0x38c]
      68:       d8 84 24 8c 07 00 00    fadd   DWORD PTR [rsp+0x78c]
      6f:       d9 5c 24 8c             fstp   DWORD PTR [rsp-0x74]
</pre>

<p>až:</p>

<pre>
    147f:       d9 84 24 84 07 00 00    fld    DWORD PTR [rsp+0x784]
    1486:       d8 84 24 84 0b 00 00    fadd   DWORD PTR [rsp+0xb84]
    148d:       d9 9c 24 84 03 00 00    fstp   DWORD PTR [rsp+0x384]
</pre>

<p>Mohlo by se zdát, že po povolení SIMD operací (zde to bude SSE) se situace
značně zlepší. Ovšem i zde můžeme na začátku vidět dvojici blokových přenosů o
celkové velikosti dvou kilobajtů:</p>

<pre>
  3a:   48 8b 94 24 80 07 00    mov    rdx,QWORD PTR [rsp+0x780]
  41:   00 
  42:   48 8d 84 24 88 07 00    lea    rax,[rsp+0x788]
  49:   00 
  4a:   48 89 d6                mov    rsi,rdx
  4d:   ba 80 00 00 00          mov    edx,0x80
  52:   48 89 c7                mov    rdi,rax
  55:   48 89 d1                mov    rcx,rdx
  58:   f3 48 a5                <strong>rep movs QWORD PTR es:[rdi],QWORD PTR ds:[rsi]</strong>
  5b:   48 8b 94 24 78 07 00    mov    rdx,QWORD PTR [rsp+0x778]
  62:   00 
  63:   48 8d 84 24 88 0b 00    lea    rax,[rsp+0xb88]
  6a:   00 
  6b:   48 89 d6                mov    rsi,rdx
  6e:   ba 80 00 00 00          mov    edx,0x80
  73:   48 89 c7                mov    rdi,rax
  76:   48 89 d1                mov    rcx,rdx
  79:   f3 48 a5                <strong>rep movs QWORD PTR es:[rdi],QWORD PTR ds:[rsi]</strong>
</pre>

<p>Samotný výpočet je realizován čtveřicí instrukcí
<strong>movaps+movaps+addps+movaps</strong>:</p>

<pre>
  7c:   0f 28 8c 24 88 07 00    movaps xmm1,XMMWORD PTR [rsp+0x788]
  83:   00 
  84:   0f 28 84 24 88 0b 00    movaps xmm0,XMMWORD PTR [rsp+0xb88]
  8b:   00 
  8c:   0f 58 c8                <strong>addps  xmm1,xmm0</strong>
  8f:   0f 29 8c 24 58 03 00    movaps XMMWORD PTR [rsp+0x358],xmm1
</pre>

<p>Jedná se o opakující se sekvenci instrukcí, která končí takto:</p>

<pre>
 78e:   0f 28 8c 24 58 0b 00    movaps xmm1,XMMWORD PTR [rsp+0xb58]
 795:   00 
 796:   0f 28 84 24 58 0f 00    movaps xmm0,XMMWORD PTR [rsp+0xf58]
 79d:   00 
 79e:   0f 28 d9                movaps xmm3,xmm1
 7a1:   0f 58 d8                <strong>addps  xmm3,xmm0</strong>
 7a4:   0f 28 8c 24 68 0b 00    movaps xmm1,XMMWORD PTR [rsp+0xb68]
 7ab:   00 
 7ac:   0f 28 84 24 68 0f 00    movaps xmm0,XMMWORD PTR [rsp+0xf68]
</pre>

<p><div class="rs-tip-major">Poznámka: tato sekvence se opakuje 64&times; a
nikoli 256&times;, protože výpočet je proveden vždy se čtyřmi prvky vektoru
paralelně. Takže se jedná o určité zlepšení.</div></p>

<p>Po optimalizaci získáme kratší kód. Celý výpočet začíná následovně:</p>

<pre>
  4f:   0f 28 84 24 88 03 00    movaps xmm0,XMMWORD PTR [rsp+0x388]
  56:   00 
  57:   0f 58 84 24 88 07 00    <strong>addps  xmm0,XMMWORD PTR [rsp+0x788]</strong>
  5e:   00 
  5f:   0f 29 44 24 88          movaps XMMWORD PTR [rsp-0x78],xmm0
</pre>

<p>...</p>

<pre>
  64:   0f 28 84 24 98 03 00    movaps xmm0,XMMWORD PTR [rsp+0x398]
  6b:   00 
  6c:   0f 58 84 24 98 07 00    <strong>addps  xmm0,XMMWORD PTR [rsp+0x798]</strong>
  73:   00 
  74:   0f 29 44 24 98          movaps XMMWORD PTR [rsp-0x68],xmm0
</pre>

<p>a končí takto:</p>

<pre>
 607:   0f 28 84 24 78 07 00    movaps xmm0,XMMWORD PTR [rsp+0x778]
 60e:   00 
 60f:   0f 58 84 24 78 0b 00    <strong>addps  xmm0,XMMWORD PTR [rsp+0xb78]</strong>
 616:   00 
 617:   0f 29 84 24 78 03 00    movaps XMMWORD PTR [rsp+0x378],xmm0
</pre>

<p><div class="rs-tip-major">Poznámka: mohlo by se zdát, že se vlastně jedná o
brutálně provedené rozbalení smyčky, ovšem zde na úkor kompaktnosti kódu, který
v&nbsp;důsledku musí být uložen na disku, načten do paměti a spuštěn z&nbsp;L1
cache. Mimochodem se můžeme podívat na to, jak kód roste prakticky nade všechny
meze:</div></p>

<pre>
typedef float v1024f <strong>__attribute__((vector_size(65536)))</strong>;
&nbsp;
void addVectors(v1024f * x, v1024f * y, v1024f * z)
{
    *z = *x + *y;
}
&nbsp;
int main(void)
{
    v1024f x = { 1.0 };
    v1024f y = { 1.0 };
    v1024f z;
&nbsp;
    addVectors(&amp;x, &amp;y, &amp;z);
&nbsp;
    return 0;
}
</pre>

<p>Výsledkem překladu bude tento absurdně velký objektový kód:</p>

<pre>
$ <strong>ls -lh simd16_1.o</strong>
&nbsp;
-rw-rw-r-- 1 ptisnovs ptisnovs 193K Oct  9 09:23 simd16B.o
</pre>

<p><div class="rs-tip-major">Poznámka: nehledě na to, že překlad bude velmi
pomalý &ndash; desítky sekund.</div></p>



<p><a name="k11"></a></p>
<h2 id="k11">11. Ne všechny operace mohou být v&nbsp;SIMD podporovány</h2>

<p>Rozšíření GCC umožňuje provádět následující operace s&nbsp;prvky
celočíselných vektorů (předpokládá se použití dvojice vektorů stejné
délky):</p>

<pre>
+, -, *, /, unární minus, ^, |, &amp;, ~, %, &lt;&lt; a &gt;&gt;
</pre>

<p>Pokud by se jednalo o prvky typu <strong>float</strong> nebo
<strong>double</strong>, jsou povoleny tyto operace:</p>

<pre>
+, -, *, / a unární minus
</pre>

<p>Ovšem samotné rozšíření GCC žádným způsobem nespecifikuje, jakým způsobem se
vlastně &bdquo;vektorové operace&ldquo; přeloží do výsledného strojového kódu.
Můžeme si to otestovat na následujícím demonstračním příkladu, v&nbsp;němž jsou
použity všechny podporované binární operace pro celočíselné prvky vektorů:</p>

<pre>
#include &lt;stdio.h&gt;
&nbsp;
typedef signed char v16ib __attribute__((vector_size(16)));
&nbsp;
void <strong>add16ib</strong>(v16ib x, v16ib y, v16ib * z)
{
    *z = x + y;
}
&nbsp;
void <strong>sub16ib</strong>(v16ib x, v16ib y, v16ib * z)
{
    *z = x - y;
}
&nbsp;
void <strong>mul16ib</strong>(v16ib x, v16ib y, v16ib * z)
{
    *z = x * y;
}
&nbsp;
void <strong>div16ib</strong>(v16ib x, v16ib y, v16ib * z)
{
    *z = x / y;
}
&nbsp;
void <strong>mod16ib</strong>(v16ib x, v16ib y, v16ib * z)
{
    *z = x % y;
}
&nbsp;
void <strong>and16ib</strong>(v16ib x, v16ib y, v16ib * z)
{
    *z = x &amp; y;
}
&nbsp;
void <strong>or16ib</strong>(v16ib x, v16ib y, v16ib * z)
{
    *z = x | y;
}
&nbsp;
void <strong>xor16ib</strong>(v16ib x, v16ib y, v16ib * z)
{
    *z = x ^ y;
}
&nbsp;
void <strong>rshift16ib</strong>(v16ib x, v16ib y, v16ib * z)
{
    *z = x &gt;&gt; y;
}
&nbsp;
void <strong>lshift16ib</strong>(v16ib x, v16ib y, v16ib * z)
{
    *z = x &lt;&lt; y;
}
&nbsp;
void <strong>print_vectors</strong>(const char *message, const char *op, v16ib *x,v16ib  *y,v16ib  *z)
{
    int i;
&nbsp;
    puts(message);
    for (i = 0; i &lt; sizeof(v16ib) / sizeof(signed char); i++) {
        printf("%2d    %d %s %d = %d\n", i, (*x)[i], op, (*y)[i], (*z)[i]);
    }
&nbsp;
    putchar('\n');
}
&nbsp;
int <strong>main</strong>(void)
{
    v16ib x;
    v16ib y;
    v16ib z;
    int i;
&nbsp;
    for (i = 0; i &lt; sizeof(v16ib) / sizeof(signed char); i++) {
        x[i] = i*2;
        y[i] = 16-i;
    }
&nbsp;
    add16ib(x, y, &amp;z);
    print_vectors("vector addition", "+", &amp;x, &amp;y, &amp;z);
&nbsp;
    sub16ib(x, y, &amp;z);
    print_vectors("vector subtraction", "-", &amp;x, &amp;y, &amp;z);
&nbsp;
    mul16ib(x, y, &amp;z);
    print_vectors("vector multiply", "*", &amp;x, &amp;y, &amp;z);
&nbsp;
    div16ib(x, y, &amp;z);
    print_vectors("vector divide", "/", &amp;x, &amp;y, &amp;z);
&nbsp;
    mod16ib(x, y, &amp;z);
    print_vectors("vector modulo", "%", &amp;x, &amp;y, &amp;z);
&nbsp;
    and16ib(x, y, &amp;z);
    print_vectors("vector bitwise and", "&amp;", &amp;x, &amp;y, &amp;z);
&nbsp;
    or16ib(x, y, &amp;z);
    print_vectors("vector bitwise or", "|", &amp;x, &amp;y, &amp;z);
&nbsp;
    xor16ib(x, y, &amp;z);
    print_vectors("vector bitwise xor", "^", &amp;x, &amp;y, &amp;z);
&nbsp;
    rshift16ib(x, y, &amp;z);
    print_vectors("vector right shift", "&gt;&gt;", &amp;x, &amp;y, &amp;z);
&nbsp;
    lshift16ib(x, y, &amp;z);
    print_vectors("vector left shift", "&lt;&lt;", &amp;x, &amp;y, &amp;z);
&nbsp;
    return 0;
}
</pre>

<p>S&nbsp;těmito výsledky:</p>

<pre>
vector addition
 0    0 + 16 = 16
 1    2 + 15 = 17
 2    4 + 14 = 18
 3    6 + 13 = 19
 4    8 + 12 = 20
 5    10 + 11 = 21
 6    12 + 10 = 22
 7    14 + 9 = 23
 8    16 + 8 = 24
 9    18 + 7 = 25
10    20 + 6 = 26
11    22 + 5 = 27
12    24 + 4 = 28
13    26 + 3 = 29
14    28 + 2 = 30
15    30 + 1 = 31
&nbsp;
vector subtraction
 0    0 - 16 = -16
 1    2 - 15 = -13
 2    4 - 14 = -10
 3    6 - 13 = -7
 4    8 - 12 = -4
 5    10 - 11 = -1
 6    12 - 10 = 2
 7    14 - 9 = 5
 8    16 - 8 = 8
 9    18 - 7 = 11
10    20 - 6 = 14
11    22 - 5 = 17
12    24 - 4 = 20
13    26 - 3 = 23
14    28 - 2 = 26
15    30 - 1 = 29
&nbsp;
vector multiply
 0    0 * 16 = 0
 1    2 * 15 = 30
 2    4 * 14 = 56
 3    6 * 13 = 78
 4    8 * 12 = 96
 5    10 * 11 = 110
 6    12 * 10 = 120
 7    14 * 9 = 126
 8    16 * 8 = -128
 9    18 * 7 = 126
10    20 * 6 = 120
11    22 * 5 = 110
12    24 * 4 = 96
13    26 * 3 = 78
14    28 * 2 = 56
15    30 * 1 = 30
&nbsp;
vector divide
 0    0 / 16 = 0
 1    2 / 15 = 0
 2    4 / 14 = 0
 3    6 / 13 = 0
 4    8 / 12 = 0
 5    10 / 11 = 0
 6    12 / 10 = 1
 7    14 / 9 = 1
 8    16 / 8 = 2
 9    18 / 7 = 2
10    20 / 6 = 3
11    22 / 5 = 4
12    24 / 4 = 6
13    26 / 3 = 8
14    28 / 2 = 14
15    30 / 1 = 30
&nbsp;
vector modulo
 0    0 % 16 = 0
 1    2 % 15 = 2
 2    4 % 14 = 4
 3    6 % 13 = 6
 4    8 % 12 = 8
 5    10 % 11 = 10
 6    12 % 10 = 2
 7    14 % 9 = 5
 8    16 % 8 = 0
 9    18 % 7 = 4
10    20 % 6 = 2
11    22 % 5 = 2
12    24 % 4 = 0
13    26 % 3 = 2
14    28 % 2 = 0
15    30 % 1 = 0
&nbsp;
vector bitwise and
 0    0 &amp; 16 = 0
 1    2 &amp; 15 = 2
 2    4 &amp; 14 = 4
 3    6 &amp; 13 = 4
 4    8 &amp; 12 = 8
 5    10 &amp; 11 = 10
 6    12 &amp; 10 = 8
 7    14 &amp; 9 = 8
 8    16 &amp; 8 = 0
 9    18 &amp; 7 = 2
10    20 &amp; 6 = 4
11    22 &amp; 5 = 4
12    24 &amp; 4 = 0
13    26 &amp; 3 = 2
14    28 &amp; 2 = 0
15    30 &amp; 1 = 0
&nbsp;
vector bitwise or
 0    0 | 16 = 16
 1    2 | 15 = 15
 2    4 | 14 = 14
 3    6 | 13 = 15
 4    8 | 12 = 12
 5    10 | 11 = 11
 6    12 | 10 = 14
 7    14 | 9 = 15
 8    16 | 8 = 24
 9    18 | 7 = 23
10    20 | 6 = 22
11    22 | 5 = 23
12    24 | 4 = 28
13    26 | 3 = 27
14    28 | 2 = 30
15    30 | 1 = 31
&nbsp;
vector bitwise xor
 0    0 ^ 16 = 16
 1    2 ^ 15 = 13
 2    4 ^ 14 = 10
 3    6 ^ 13 = 11
 4    8 ^ 12 = 4
 5    10 ^ 11 = 1
 6    12 ^ 10 = 6
 7    14 ^ 9 = 7
 8    16 ^ 8 = 24
 9    18 ^ 7 = 21
10    20 ^ 6 = 18
11    22 ^ 5 = 19
12    24 ^ 4 = 28
13    26 ^ 3 = 25
14    28 ^ 2 = 30
15    30 ^ 1 = 31
&nbsp;
vector right shift
 0    0 &gt;&gt; 16 = 0
 1    2 &gt;&gt; 15 = 0
 2    4 &gt;&gt; 14 = 0
 3    6 &gt;&gt; 13 = 0
 4    8 &gt;&gt; 12 = 0
 5    10 &gt;&gt; 11 = 0
 6    12 &gt;&gt; 10 = 0
 7    14 &gt;&gt; 9 = 0
 8    16 &gt;&gt; 8 = 0
 9    18 &gt;&gt; 7 = 0
10    20 &gt;&gt; 6 = 0
11    22 &gt;&gt; 5 = 0
12    24 &gt;&gt; 4 = 1
13    26 &gt;&gt; 3 = 3
14    28 &gt;&gt; 2 = 7
15    30 &gt;&gt; 1 = 15
&nbsp;
vector left shift
 0    0 &lt;&lt; 16 = 0
 1    2 &lt;&lt; 15 = 0
 2    4 &lt;&lt; 14 = 0
 3    6 &lt;&lt; 13 = 0
 4    8 &lt;&lt; 12 = 0
 5    10 &lt;&lt; 11 = 0
 6    12 &lt;&lt; 10 = 0
 7    14 &lt;&lt; 9 = 0
 8    16 &lt;&lt; 8 = 0
 9    18 &lt;&lt; 7 = 0
10    20 &lt;&lt; 6 = 0
11    22 &lt;&lt; 5 = -64
12    24 &lt;&lt; 4 = -128
13    26 &lt;&lt; 3 = -48
14    28 &lt;&lt; 2 = 112
15    30 &lt;&lt; 1 = 60
</pre>



<p><a name="k12"></a></p>
<h2 id="k12">12. Výsledek překladu předchozího programu do kódu se SIMD operacemi</h2>

<p>Podívejme se nyní postupně na způsob překladu předchozího programu ve
chvíli, kdy jsou při překladu povoleny SIMD operace. Pro stručnost si uvedeme
jen &bdquo;výpočetní část&ldquo; každé z&nbsp;funkcí, tedy bez přípravy
operandů a bez úklidu zásobníku na konci každé funkce.</p>

<p>Vektorový součet je realizován jedinou instrukcí <a
href="https://www.felixcloutier.com/x86/paddb:paddw:paddd:paddq">PADDB</a>:</p>

<pre>
  14:   66 0f 6f 45 f0          movdqa xmm0,XMMWORD PTR [rbp-0x10]
  19:   66 0f fc 45 e0          <strong>paddb  xmm0,XMMWORD PTR [rbp-0x20]</strong>
  1e:   48 8b 45 d8             mov    rax,QWORD PTR [rbp-0x28]
  22:   0f 29 00                movaps XMMWORD PTR [rax],xmm0
</pre>

<p>Vektorový rozdíl je realizován jedinou instrukcí <a
href="https://www.felixcloutier.com/x86/psubb:psubw:psubd">PSUBB</a>:</p>

<pre>
  3c:   66 0f 6f 45 f0          movdqa xmm0,XMMWORD PTR [rbp-0x10]
  41:   66 0f f8 45 e0          psubb  xmm0,XMMWORD PTR [rbp-0x20]
  46:   48 8b 45 d8             mov    rax,QWORD PTR [rbp-0x28]
  4a:   0f 29 00                movaps XMMWORD PTR [rax],xmm0
</pre>

<p>Součin prvků vektorů již není tak triviální, jak by se možná mohlo na první
pohled zdát, neboť je nutné zajistit, aby každý výsledný prvek měl opět pouze
osm bitů výsledku a nikoli šestnáct bitů. Nejdříve se prvky vektorů instrukcemi
<a
href="https://www.felixcloutier.com/x86/punpcklbw:punpcklwd:punpckldq:punpcklqdq">PUNPCKLBW</a>
a <a
href="https://www.felixcloutier.com/x86/punpckhbw:punpckhwd:punpckhdq:punpckhqdq">PUNPCKHBW</a>
rozdělí na vektory šestnáctibitových slov, provede se výpočet instrukcí <a
href="https://www.felixcloutier.com/x86/pmullw">PMULLW</a> (tedy skutečně
násobení šestnáctibitových hodnot) a poté se výsledky opět
&bdquo;zkomprimují&ldquo; instrukcí <a
href="https://www.felixcloutier.com/x86/packuswb">PACKUSWB</a></p>

<pre>
  64:   66 0f 6f 45 f0          movdqa xmm0,XMMWORD PTR [rbp-0x10]
  69:   66 0f 6f 4d e0          movdqa xmm1,XMMWORD PTR [rbp-0x20]
  6e:   66 0f 6f d9             movdqa xmm3,xmm1
  72:   66 0f 60 d9             <strong>punpcklbw xmm3,xmm1</strong>
  76:   66 0f 6f d1             movdqa xmm2,xmm1
  7a:   66 0f 68 d1             <strong>punpckhbw xmm2,xmm1</strong>
  7e:   66 0f 6f c8             movdqa xmm1,xmm0
  82:   66 0f 60 c8             <strong>punpcklbw xmm1,xmm0</strong>
  86:   66 0f 68 c0             <strong>punpckhbw xmm0,xmm0</strong>
  8a:   66 0f 6f e1             movdqa xmm4,xmm1
  8e:   66 0f 6f cb             movdqa xmm1,xmm3
  92:   66 0f d5 cc             <strong>pmullw xmm1,xmm4</strong>
  96:   66 0f 6f d8             movdqa xmm3,xmm0
  9a:   66 0f 6f c2             movdqa xmm0,xmm2
  9e:   66 0f 6f d3             movdqa xmm2,xmm3
  a2:   66 0f d5 d0             <strong>pmullw xmm2,xmm0</strong>
  a6:   66 0f 6f 05 00 00 00    movdqa xmm0,XMMWORD PTR [rip+0x0]        # ae <mul16ib+0x5e>
  ad:   00 
  ae:   66 0f db c8             pand   xmm1,xmm0
  b2:   66 0f db c2             pand   xmm0,xmm2
  b6:   66 0f 6f e9             movdqa xmm5,xmm1
  ba:   66 0f 67 e8             <strong>packuswb xmm5,xmm0</strong>
  be:   66 0f 6f c5             movdqa xmm0,xmm5
  c2:   48 8b 45 d8             mov    rax,QWORD PTR [rbp-0x28]
  c6:   0f 29 00                movaps XMMWORD PTR [rax],xmm0
</pre>

<p>Další operací je podíl prvků vektorů, který je složitý a pomalý, protože je
realizován sekvenčně, konkrétně standardní instrukcí <a
href="https://www.felixcloutier.com/x86/idiv">IDIV</a> (!), předtím je ještě
nutné operand převést z&nbsp;bajtu na 16bitové slovo instrukcí <a
href="https://www.felixcloutier.com/x86/cbw:cwde:cdqe">CBW</a> (uff):</p>

<pre>
  e9:   0f b6 45 c0             movzx  eax,BYTE PTR [rbp-0x40]
  ed:   0f b6 55 b0             movzx  edx,BYTE PTR [rbp-0x50]
  f1:   66 98                   <strong>cbw</strong>
  f3:   f6 fa                   <strong>idiv   dl</strong>
  f5:   41 89 c7                mov    r15d,eax
  f8:   0f b6 45 c1             movzx  eax,BYTE PTR [rbp-0x3f]
  fc:   0f b6 55 b1             movzx  edx,BYTE PTR [rbp-0x4f]
 100:   66 98                   <strong>cbw</strong>
 102:   f6 fa                   <strong>idiv   dl</strong>
 104:   88 45 90                mov    BYTE PTR [rbp-0x70],al
 107:   0f b6 45 c2             movzx  eax,BYTE PTR [rbp-0x3e]
 10b:   0f b6 55 b2             movzx  edx,BYTE PTR [rbp-0x4e]
 10f:   66 98                   <strong>cbw</strong>
 111:   f6 fa                   <strong>idiv   dl</strong>
 113:   88 45 a7                mov    BYTE PTR [rbp-0x59],al
 116:   0f b6 45 c3             movzx  eax,BYTE PTR [rbp-0x3d]
 11a:   0f b6 55 b3             movzx  edx,BYTE PTR [rbp-0x4d]
 11e:   66 98                   <strong>cbw</strong>
 120:   f6 fa                   <strong>idiv   dl</strong>
 122:   88 45 a6                mov    BYTE PTR [rbp-0x5a],al
 125:   0f b6 45 c4             movzx  eax,BYTE PTR [rbp-0x3c]
 129:   0f b6 55 b4             movzx  edx,BYTE PTR [rbp-0x4c]
 12d:   66 98                   <strong>cbw</strong>
 12f:   f6 fa                   <strong>idiv   dl</strong>
 131:   88 45 a5                mov    BYTE PTR [rbp-0x5b],al
 134:   0f b6 45 c5             movzx  eax,BYTE PTR [rbp-0x3b]
 138:   0f b6 55 b5             movzx  edx,BYTE PTR [rbp-0x4b]
 13c:   66 98                   <strong>cbw</strong>
 13e:   f6 fa                   <strong>idiv   dl</strong>
 140:   41 89 c2                mov    r10d,eax
 143:   0f b6 45 c6             movzx  eax,BYTE PTR [rbp-0x3a]
 147:   0f b6 55 b6             movzx  edx,BYTE PTR [rbp-0x4a]
 14b:   66 98                   <strong>cbw</strong>
 14d:   f6 fa                   <strong>idiv   dl</strong>
 14f:   41 89 c0                mov    r8d,eax
 152:   0f b6 45 c7             movzx  eax,BYTE PTR [rbp-0x39]
 156:   0f b6 55 b7             movzx  edx,BYTE PTR [rbp-0x49]
 15a:   66 98                   <strong>cbw</strong>
 15c:   f6 fa                   <strong>idiv   dl</strong>
 15e:   89 c7                   mov    edi,eax
 160:   0f b6 45 c8             movzx  eax,BYTE PTR [rbp-0x38]
 164:   0f b6 55 b8             movzx  edx,BYTE PTR [rbp-0x48]
 168:   66 98                   <strong>cbw</strong>
 16a:   f6 fa                   <strong>idiv   dl</strong>
 16c:   41 89 c3                mov    r11d,eax
 16f:   0f b6 45 c9             movzx  eax,BYTE PTR [rbp-0x37]
 173:   0f b6 55 b9             movzx  edx,BYTE PTR [rbp-0x47]
 177:   66 98                   <strong>cbw</strong>
 179:   f6 fa                   <strong>idiv   dl</strong>
 17b:   89 c3                   mov    ebx,eax
 17d:   0f b6 45 ca             movzx  eax,BYTE PTR [rbp-0x36]
 181:   0f b6 55 ba             movzx  edx,BYTE PTR [rbp-0x46]
 185:   66 98                   <strong>cbw</strong>
 187:   f6 fa                   <strong>idiv   dl</strong>
 189:   41 89 c4                mov    r12d,eax
 18c:   0f b6 45 cb             movzx  eax,BYTE PTR [rbp-0x35]
 190:   0f b6 55 bb             movzx  edx,BYTE PTR [rbp-0x45]
 194:   66 98                   <strong>cbw</strong>
 196:   f6 fa                   <strong>idiv   dl</strong>
 198:   41 89 c5                mov    r13d,eax
 19b:   0f b6 45 cc             movzx  eax,BYTE PTR [rbp-0x34]
 19f:   0f b6 55 bc             movzx  edx,BYTE PTR [rbp-0x44]
 1a3:   66 98                   <strong>cbw</strong>
 1a5:   f6 fa                   <strong>idiv   dl</strong>
 1a7:   41 89 c6                mov    r14d,eax
 1aa:   0f b6 45 cd             movzx  eax,BYTE PTR [rbp-0x33]
 1ae:   0f b6 55 bd             movzx  edx,BYTE PTR [rbp-0x43]
 1b2:   66 98                   <strong>cbw</strong>
 1b4:   f6 fa                   <strong>idiv   dl</strong>
 1b6:   41 89 c1                mov    r9d,eax
 1b9:   0f b6 45 ce             movzx  eax,BYTE PTR [rbp-0x32]
 1bd:   0f b6 55 be             movzx  edx,BYTE PTR [rbp-0x42]
 1c1:   66 98                   <strong>cbw</strong>
 1c3:   f6 fa                   <strong>idiv   dl</strong>
 1c5:   89 c6                   mov    esi,eax
 1c7:   0f b6 45 cf             movzx  eax,BYTE PTR [rbp-0x31]
 1cb:   0f b6 55 bf             movzx  edx,BYTE PTR [rbp-0x41]
 1cf:   66 98                   <strong>cbw</strong>
 1d1:   f6 fa                   <strong>idiv   dl</strong>
</pre>

<p>Aplikace operátoru &amp; na prvky vektoru s&nbsp;využitím instrukce <a
href="https://www.felixcloutier.com/x86/pand">PAND</a>:</p>

<pre>
    *z = x &amp; y;
 4a2:   66 0f 6f 45 f0          movdqa xmm0,XMMWORD PTR [rbp-0x10]
 4a7:   66 0f db 45 e0          <strong>pand   xmm0,XMMWORD PTR [rbp-0x20]</strong>
 4ac:   48 8b 45 d8             mov    rax,QWORD PTR [rbp-0x28]
 4b0:   0f 29 00                movaps XMMWORD PTR [rax],xmm0
</pre>

<p>Aplikace operátoru | na prvky vektoru s&nbsp;využitím instrukce <a
href="https://www.felixcloutier.com/x86/por">POR</a>:</p>

<pre>
    *z = x | y;
 4ca:   66 0f 6f 45 f0          movdqa xmm0,XMMWORD PTR [rbp-0x10]
 4cf:   66 0f eb 45 e0          <strong>por    xmm0,XMMWORD PTR [rbp-0x20]</strong>
 4d4:   48 8b 45 d8             mov    rax,QWORD PTR [rbp-0x28]
 4d8:   0f 29 00                movaps XMMWORD PTR [rax],xmm0
</pre>

<p>Aplikace operátoru ^ na prvky vektoru s&nbsp;využitím instrukce <a
href="https://www.felixcloutier.com/x86/pxor">PXOR</a>:</p>

<pre>
    *z = x ^ y;
 4f2:   66 0f 6f 45 f0          movdqa xmm0,XMMWORD PTR [rbp-0x10]
 4f7:   66 0f ef 45 e0          <strong>pxor   xmm0,XMMWORD PTR [rbp-0x20]</strong>
 4fc:   48 8b 45 d8             mov    rax,QWORD PTR [rbp-0x28]
 500:   0f 29 00                movaps XMMWORD PTR [rax],xmm0
</pre>

<p>Překlad funkce, v&nbsp;níž se provádí bitový posun prvků jednoho vektoru na
základě hodnot uložených ve druhém vektoru, je stejně tristní, jako tomu bylo u
dělení prvků &ndash; žádné vektorové (přesněji řečen SIMD) instrukce zde nejsou
použity:</p>

<pre>
523:    0f b6 55 c0             movzx  edx,BYTE PTR [rbp-0x40]
 527:   0f b6 45 b0             movzx  eax,BYTE PTR [rbp-0x50]
 52b:   0f be c0                movsx  eax,al
 52e:   89 c1                   mov    ecx,eax
 530:   d2 fa                   <strong>sar    dl,cl</strong>
 ...
 ...
 ...
 634:   0f be c0                movsx  eax,al
 637:   89 d7                   mov    edi,edx
 639:   89 c1                   mov    ecx,eax
 63b:   40 d2 ff                <strong>sar    dil,cl</strong>
 63e:   0f b6 55 cf             movzx  edx,BYTE PTR [rbp-0x31]
 642:   0f b6 45 bf             movzx  eax,BYTE PTR [rbp-0x41]
</pre>

<p><div class="rs-tip-major">Poznámka: prakticky stejně je tomu v&nbsp;případě
posunu doleva.</div></p>



<p><a name="k13"></a></p>
<h2 id="k13">13. Základní aritmetické operace s&nbsp;prvky vektorů typu <strong>float</strong></h2>

<p>Nyní se podívejme na to, jakým způsobem se s&nbsp;využitím SIMD operací
přeloží následující demonstrační příklad, v&nbsp;němž jsou použity všechny
&bdquo;vektorové operátory&ldquo; pro vektory s&nbsp;prvky typu
<strong>float</strong>, tedy s&nbsp;numerickými hodnotami uloženými
v&nbsp;systému plovoucí řádové tečky/čárky (těchto operátorů je mnohem méně,
v&nbsp;porovnání s&nbsp;celočíselnými prvky vektorů):</p>

<pre>
#include &lt;stdio.h&gt;
&nbsp;
typedef <strong>float</strong> v16float <strong>__attribute__((vector_size(16)))</strong>;
&nbsp;
void <strong>add16float</strong>(v16float x, v16float y, v16float * z)
{
    *z = x + y;
}
&nbsp;
void <strong>sub16float</strong>(v16float x, v16float y, v16float * z)
{
    *z = x - y;
}
&nbsp;
void <strong>mul16float</strong>(v16float x, v16float y, v16float * z)
{
    *z = x * y;
}
&nbsp;
void <strong>div16float</strong>(v16float x, v16float y, v16float * z)
{
    *z = x / y;
}
&nbsp;
void <strong>print_vectors</strong>(const char *message, const char op, v16float * x,
                   v16float * y, v16float * z)
{
    int i;
&nbsp;
    puts(message);
    for (i = 0; i &lt; sizeof(v16float) / sizeof(float); i++) {
        printf("%2d    %5.3f %c %5.3f = %5.3f\n", i, (*x)[i], op, (*y)[i], (*z)[i]);
    }
&nbsp;
    putchar('\n');
}
&nbsp;
int <strong>main</strong>(void)
{
    v16float x;
    v16float y;
    v16float z;
    int i;
&nbsp;
    for (i = 0; i &lt; sizeof(v16float) / sizeof(float); i++) {
        x[i] = i;
        y[i] = i + 0.1;
    }
&nbsp;
    add16float(x, y, &amp;z);
    print_vectors("vector addition", '+', &amp;x, &amp;y, &amp;z);
&nbsp;
    sub16float(x, y, &amp;z);
    print_vectors("vector subtraction", '-', &amp;x, &amp;y, &amp;z);
&nbsp;
    mul16float(x, y, &amp;z);
    print_vectors("vector multiply", '*', &amp;x, &amp;y, &amp;z);
&nbsp;
    div16float(x, y, &amp;z);
    print_vectors("vector divide", '/', &amp;x, &amp;y, &amp;z);
&nbsp;
    return 0;
}
</pre>

<p>S&nbsp;výsledky:</p>

<pre>
vector addition
 0    0.000 + 0.100 = 0.100
 1    1.000 + 1.100 = 2.100
 2    2.000 + 2.100 = 4.100
 3    3.000 + 3.100 = 6.100
&nbsp;
vector subtraction
 0    0.000 - 0.100 = -0.100
 1    1.000 - 1.100 = -0.100
 2    2.000 - 2.100 = -0.100
 3    3.000 - 3.100 = -0.100
&nbsp;
vector multiply
 0    0.000 * 0.100 = 0.000
 1    1.000 * 1.100 = 1.100
 2    2.000 * 2.100 = 4.200
 3    3.000 * 3.100 = 9.300
&nbsp;
vector divide
 0    0.000 / 0.100 = 0.000
 1    1.000 / 1.100 = 0.909
 2    2.000 / 2.100 = 0.952
 3    3.000 / 3.100 = 0.968
</pre>



<p><a name="k14"></a></p>
<h2 id="k14">14. Překlad bez použití instrukcí SIMD</h2>

<p>Nejprve se podívejme na způsob překladu tohoto demonstračního příkladu ve
chvíli, kdy nejsou povoleny SIMD instrukce (tedy v&nbsp;našem případě SSE).
Neoptimalizovaný kód součtu dvou čtyřprvkových vektorů je (nepřekvapivě)
založen na instrukci <a
href="https://www.felixcloutier.com/x86/fadd:faddp:fiadd">FADDP</a>:</p>

<pre>
   c:   d9 45 10                fld    DWORD PTR [rbp+0x10]
   f:   d9 45 20                fld    DWORD PTR [rbp+0x20]
  12:   de c1                   <strong>faddp  st(1),st</strong>
  14:   d9 45 14                fld    DWORD PTR [rbp+0x14]
  17:   d9 45 24                fld    DWORD PTR [rbp+0x24]
  1a:   de c1                   <strong>faddp  st(1),st</strong>
  1c:   d9 45 18                fld    DWORD PTR [rbp+0x18]
  1f:   d9 45 28                fld    DWORD PTR [rbp+0x28]
  22:   de c1                   <strong>faddp  st(1),st</strong>
  24:   d9 45 1c                fld    DWORD PTR [rbp+0x1c]
  27:   d9 45 2c                fld    DWORD PTR [rbp+0x2c]
  2a:   de c1                   <strong>faddp  st(1),st</strong>
  2c:   d9 cb                   fxch   st(3)
  2e:   d9 5d d0                fstp   DWORD PTR [rbp-0x30]
  31:   d9 c9                   fxch   st(1)
  33:   d9 5d d4                fstp   DWORD PTR [rbp-0x2c]
  36:   d9 5d d8                fstp   DWORD PTR [rbp-0x28]
  39:   d9 5d dc                fstp   DWORD PTR [rbp-0x24]
  3c:   48 8b 45 d0             mov    rax,QWORD PTR [rbp-0x30]
  40:   48 89 45 f0             mov    QWORD PTR [rbp-0x10],rax
  44:   48 8b 45 d8             mov    rax,QWORD PTR [rbp-0x28]
  48:   48 89 45 f8             mov    QWORD PTR [rbp-0x8],rax
  4c:   48 8b 45 e8             mov    rax,QWORD PTR [rbp-0x18]
  50:   48 8b 55 f0             mov    rdx,QWORD PTR [rbp-0x10]
  54:   48 89 10                mov    QWORD PTR [rax],rdx
  57:   48 8b 55 f8             mov    rdx,QWORD PTR [rbp-0x8]
  5b:   48 89 50 08             mov    QWORD PTR [rax+0x8],rdx
</pre>

<p>Po optimalizaci dostaneme tento kód:</p>

<pre>
   4:   d9 44 24 08             fld    DWORD PTR [rsp+0x8]
   8:   d8 44 24 18             <strong>fadd   DWORD PTR [rsp+0x18]</strong>
   c:   d9 5c 24 d8             fstp   DWORD PTR [rsp-0x28]
  10:   d9 44 24 0c             fld    DWORD PTR [rsp+0xc]
  14:   d8 44 24 1c             <strong>fadd   DWORD PTR [rsp+0x1c]</strong>
  18:   d9 5c 24 dc             fstp   DWORD PTR [rsp-0x24]
  1c:   d9 44 24 10             fld    DWORD PTR [rsp+0x10]
  20:   d8 44 24 20             <strong>fadd   DWORD PTR [rsp+0x20]</strong>
  24:   48 8b 44 24 d8          mov    rax,QWORD PTR [rsp-0x28]
  29:   48 89 07                mov    QWORD PTR [rdi],rax
  2c:   d9 5c 24 e0             fstp   DWORD PTR [rsp-0x20]
  30:   d9 44 24 14             fld    DWORD PTR [rsp+0x14]
  34:   d8 44 24 24             <strong>fadd   DWORD PTR [rsp+0x24]</strong>
  38:   d9 5c 24 e4             fstp   DWORD PTR [rsp-0x1c]
  3c:   48 8b 44 24 e0          mov    rax,QWORD PTR [rsp-0x20]
  41:   48 89 47 08             mov    QWORD PTR [rdi+0x8],rax
</pre>

<p>Dělení je realizováno instrukcí <a
href="https://www.felixcloutier.com/x86/fdiv:fdivp:fidiv">FDIV</a>:</p>

<pre>
  f8:   d8 74 24 18             <strong>fdiv   DWORD PTR [rsp+0x18]</strong>
  fc:   d9 5c 24 d8             fstp   DWORD PTR [rsp-0x28]
 100:   d9 44 24 0c             fld    DWORD PTR [rsp+0xc]
 104:   d8 74 24 1c             <strong>fdiv   DWORD PTR [rsp+0x1c]</strong>
 108:   d9 5c 24 dc             fstp   DWORD PTR [rsp-0x24]
 10c:   d9 44 24 10             fld    DWORD PTR [rsp+0x10]
 110:   d8 74 24 20             <strong>fdiv   DWORD PTR [rsp+0x20]</strong>
 114:   48 8b 44 24 d8          mov    rax,QWORD PTR [rsp-0x28]
 119:   48 89 07                mov    QWORD PTR [rdi],rax
 11c:   d9 5c 24 e0             fstp   DWORD PTR [rsp-0x20]
 120:   d9 44 24 14             fld    DWORD PTR [rsp+0x14]
 124:   d8 74 24 24             <strong>fdiv   DWORD PTR [rsp+0x24]</strong>
 128:   d9 5c 24 e4             fstp   DWORD PTR [rsp-0x1c]
 12c:   48 8b 44 24 e0          mov    rax,QWORD PTR [rsp-0x20]
 131:   48 89 47 08             mov    QWORD PTR [rdi+0x8],rax
</pre>



<p><a name="k15"></a></p>
<h2 id="k15">15. Překlad do strojového kódu s&nbsp;použitím instrukcí SIMD</h2>

<p>Součet odpovídajících si prvků vektorů je realizován instrukcí <a href=""></a>:</p>

<pre>
  14:   0f 28 45 f0             movaps xmm0,XMMWORD PTR [rbp-0x10]
  18:   0f 58 45 e0             <strong>addps  xmm0,XMMWORD PTR [rbp-0x20]</strong>
  1c:   48 8b 45 d8             mov    rax,QWORD PTR [rbp-0x28]
  20:   0f 29 00                movaps XMMWORD PTR [rax],xmm0
</pre>

<p>Rozdíl odpovídajících si prvků vektorů je realizován instrukcí <a href=""></a>:</p>

<pre>
  3a:   0f 28 45 f0             movaps xmm0,XMMWORD PTR [rbp-0x10]
  3e:   0f 5c 45 e0             <strong>subps  xmm0,XMMWORD PTR [rbp-0x20]</strong>
  42:   48 8b 45 d8             mov    rax,QWORD PTR [rbp-0x28]
  46:   0f 29 00                movaps XMMWORD PTR [rax],xmm0
</pre>

<p>Součin odpovídajících si prvků vektorů je realizován instrukcí <a href=""></a>:</p>

<pre>
  60:   0f 28 45 f0             movaps xmm0,XMMWORD PTR [rbp-0x10]
  64:   0f 59 45 e0             <strong>mulps  xmm0,XMMWORD PTR [rbp-0x20]</strong>
  68:   48 8b 45 d8             mov    rax,QWORD PTR [rbp-0x28]
  6c:   0f 29 00                movaps XMMWORD PTR [rax],xmm0
</pre>

<p>Podíl odpovídajících si prvků vektorů <a href=""></a>:</p>

<pre>
  86:   0f 28 45 f0             movaps xmm0,XMMWORD PTR [rbp-0x10]
  8a:   0f 5e 45 e0             <strong>divps  xmm0,XMMWORD PTR [rbp-0x20]</strong>
  8e:   48 8b 45 d8             mov    rax,QWORD PTR [rbp-0x28]
  92:   0f 29 00                movaps XMMWORD PTR [rax],xmm0
</pre>

<p>Po optimalizaci (-O3) se samotné výpočty zkrátí &ndash; nemusí se provádět
zbytečné přesuny dat:</p>

<p>Součet odpovídajících si prvků vektorů:</p>

<pre>
   4:   0f 58 c1                <strong>addps  xmm0,xmm1</strong>
   7:   0f 29 07                movaps XMMWORD PTR [rdi],xmm0
</pre>

<p>Rozdíl odpovídajících si prvků vektorů:</p>

<pre>
  14:   0f 5c c1                <strong>subps  xmm0,xmm1</strong>
  17:   0f 29 07                movaps XMMWORD PTR [rdi],xmm0
</pre>

<p>Součin odpovídajících si prvků vektorů:</p>

<pre>
  24:   0f 59 c1                <strong>mulps  xmm0,xmm1</strong>
  27:   0f 29 07                movaps XMMWORD PTR [rdi],xmm0
</pre>

<p>Podíl odpovídajících si prvků vektorů:</p>

<pre>
  34:   0f 5e c1                <strong>divps  xmm0,xmm1</strong>
  37:   0f 29 07                movaps XMMWORD PTR [rdi],xmm0
</pre>



<p><a name="k16"></a></p>
<h2 id="k16">16. Zásadní omezení rozšíření (sic) GCC</h2>

<p>V&nbsp;instrukčním souboru všech moderních mikroprocesorů x86-64 nalezneme
celou řadu potenciálně velmi užitečných instrukcí, například instrukci
<strong>PMADDWS</strong>, která provádí paralelní součin čtveřice
šestnáctibitových hodnot s&nbsp;32 bitovým mezivýsledkem, s&nbsp;následným
součtem prvního + druhého a třetího + čtvrtého mezivýsledku. Užitečné jsou i
původní MMX instrukce využitelné při práci s&nbsp;rastrovými obrázky nebo
zvukovými vzorky (PACKUSWB, PACKSS, PUNPCKH, PUNPCKL). Podobně nalezneme
v&nbsp;SSE instrukce <strong>SHUFPS, UNPCKHPS, UNPCKLPS</strong>,
popř.&nbsp;různé výpočty:</p>

<ul>
<li>SQRTSS, SQRTPS: druhá odmocnina</li>
<li>RSQRTSS, RSQRTPS: převrácená hodnota z druhé odmocniny</li>
<li>MAXSS, MAXPS: výpočet maxima</li>
<li>MINSS, MINPS: výpočet minima</li>
</ul>

<p>Pro přímé využití těchto (a mnoha dalších podobných) instrukcí se musíme
uchýlit k&nbsp;použití <i>intrinsic</i>, což je téma na samostatný článek.</p>



<p><a name="k17"></a></p>
<h2 id="k17">17. SIMD a vektorové operace na architekturách AArch64 a RISC-V</h2>

<p>Prakticky každá významnější společnost (v&nbsp;případě mikroprocesorů řady
PowerPC pak dokonce aliance několika společností) navrhující mikroprocesory
s&nbsp;architekturou <i>RISC</i> přišla dříve či později na trh
s&nbsp;instrukční sadou obsahující &bdquo;vektorové&ldquo; instrukce, které
jsou dnes souhrnně označovány zkratkou <i>SIMD</i> (původní vektorové instrukce
používané na superpočítačích jsou v&nbsp;některých ohledech flexibilnější,
proto budeme používat spíše poněkud přesnější zkratku <i>SIMD</i> znamenající
&bdquo;single instruction &ndash; multiple data&ldquo;, viz též <a
href="https://www.root.cz/clanky/uzitecne-rozsireni-gcc-podpora-simd-vektorovych-instrukci/">předchozí
článek</a>). Rozšiřující instrukční sady byly pojmenovávány nejrůznějšími názvy
a zkratkami a nikdy vlastně nedošlo &ndash; částečně na rozdíl od platformy
<i>x86</i> &ndash; ke sjednocení těchto instrukcí do jediné skupiny &bdquo;SIMD
pro RISC&ldquo;, což je vlastně logické, protože procesory <i>RISC</i> jsou
mnohdy určeny pro specializované oblasti použití, od vestavných (embedded)
systémů přes smartphony a tablety až po superpočítače.</p>

<p>Nejvýznamnější implementace instrukcí typu <i>SIMD</i> na mikroprocesorech
s&nbsp;architekturou <i>RISC</i>, ať již se jedná o instrukce určené pro
operace s&nbsp;celými čísly či s&nbsp;čísly reálnými (přesněji řečeno
s&nbsp;plovoucí řádovou čárkou), jsou vypsány v&nbsp;následující tabulce:</p>

<table>
<tr><th>#</th><th>Zkratka/název</th><th>Plný název</th><th>Rodina procesorů</th></tr>
<tr><td>1</td><td>MAX-1</td><td>Multimedia Acceleration eXtensions v1</td><td>HP-PA RISC</td></tr>
<tr><td>2</td><td>MAX-2</td><td>Multimedia Acceleration eXtensions v2</td><td>HP-PA RISC</td></tr>
<tr><td>3</td><td>VIS 1</td><td>Visual Instruction v1</td><td>Set SPARC V9</td></tr>
<tr><td>4</td><td>VIS 2</td><td>Visual Instruction v2</td><td>Set SPARC V9</td></tr>
<tr><td>5</td><td>AltiVec</td><td>(obchodní názvy Velocity Engine, VMX)</td><td>PowerPC</td></tr>
<tr><td>6</td><td>MDMX</td><td>MIPS Digital Media eXtension (MaDMaX)</td><td>MIPS</td></tr>
<tr><td>7</td><td>MIPS-3D</td><td>MIPS-3D</td><td>MIPS</td></tr>
<tr><td>8</td><td>MVI</td><td>Motion Video Instructions</td><td>DEC Alpha</td></tr>
<tr><td>9</td><td>NEON</td><td>Advanced SIMD</td><td>Cortex (ARMv7, ARMv8)</td></tr>
<tr><td>10</td><td>Packed SIMD</td><td>Packed SIMD</td><td>RISC-V</td></tr>
<tr><td>11</td><td>Vector Set</td><td>Vector Set</td><td>RISC-V</td></tr>
<tr><td>12</td><td>Scalable Vector Extension (SVE)</td><td>ARMv8.2-A a novější</td></tr>
</table>

<p>V&nbsp;navazujícím článku se budeme zabývat těmi SIMD/vektorovými
instrukcemi, které jsou implementovány na architekturách AArch64 (NEON) a
RISC-V.</p>



<p><a name="k18"></a></p>
<h2 id="k18">18. Příloha &ndash; soubor Makefile použitý v&nbsp;dnešním článku</h2>

<p>Následující soubor <strong>Makefile</strong> byl použit pro překlad
zdrojových kódů všech výše uvedených demonstračních příkladů do objektového
kódu jeho s&nbsp;následným disassemblingem do assembleru (resp.&nbsp;přesněji
řečeno do assembleru zkombinovaného s&nbsp;hexadecimálním výpisem obsahu
souboru s&nbsp;objektovým kódem):</p>

<pre>
CC=gcc
OBJDUMP=objdump
&nbsp;
all:    simd04_1.lst simd04_2.lst \
        simd04B_1.lst simd04B_2.lst \
        simd07_1.lst simd07_2.lst \
        simd08_1.lst simd08_2.lst \
        simd12_1.lst simd12_2.lst \
        simd13_1.lst simd13_2.lst simd13_3.lst simd13_4.lst \
        simd14_1.lst simd14_2.lst simd14_3.lst simd14_4.lst \
        simd15_1.lst simd15_2.lst simd15_3.lst simd15_4.lst \
        simd16_1.lst simd16_2.lst simd16_3.lst simd16_4.lst \
        simd17_1.lst simd17_2.lst simd17_3.lst simd17_4.lst \
        simd18_1.lst simd18_2.lst simd18_3.lst simd18_4.lst
&nbsp;
clean:
        rm *.lst
        rm *.o

%.lst:  %.o
        objdump -d -M intel -S $&lt; &gt; $@ 
&nbsp;
simd04_1.o:     simd04.c
        gcc -c -O0 -mno-sse -g -o $@ $&lt;
&nbsp;
simd04_2.o:     simd04.c
        gcc -c -O0 -g -o $@ $&lt;
&nbsp;
simd04B_1.o:    simd04B.c
        gcc -c -O0 -mno-sse -g -o $@ $&lt;
&nbsp;
simd04B_2.o:    simd04B.c
        gcc -c -O0 -g -o $@ $&lt;
&nbsp;
simd07_1.o:     simd07.c
        gcc -c -mno-sse -g -o $@ $&lt;
&nbsp;
simd07_2.o:     simd07.c
        gcc -c -g -o $@ $&lt;
&nbsp;
simd08_1.o:     simd08.c
        gcc -c -mno-sse -g -o $@ $&lt;
&nbsp;
simd08_2.o:     simd08.c
        gcc -c -g -o $@ $&lt;
&nbsp;
simd12_1.o:     simd12.c
        gcc -c -O0 -mno-sse -g -o $@ $&lt;
&nbsp;
simd12_2.o:     simd12.c
        gcc -c -O0 -g -o $@ $&lt;
&nbsp;
simd13_1.o:     simd13.c
        gcc -c -O0 -mno-sse -g -o $@ $&lt;
&nbsp;
simd13_2.o:     simd13.c
        gcc -c -O0 -g -o $@ $&lt;
&nbsp;
simd13_3.o:     simd13.c
        gcc -c -O3 -mno-sse -g -o $@ $&lt;
&nbsp;
simd13_4.o:     simd13.c
        gcc -c -O3 -g -o $@ $&lt;
&nbsp;
simd14_1.o:     simd14.c
        gcc -c -O0 -mno-sse -g -o $@ $&lt;
&nbsp;
simd14_2.o:     simd14.c
        gcc -c -O0 -g -o $@ $&lt;
&nbsp;
simd14_3.o:     simd14.c
        gcc -c -O3 -mno-sse -g -o $@ $&lt;
&nbsp;
simd14_4.o:     simd14.c
        gcc -c -O3 -g -o $@ $&lt;
&nbsp;
simd15_1.o:     simd15.c
        gcc -c -O0 -mno-sse -g -o $@ $&lt;
&nbsp;
simd15_2.o:     simd15.c
        gcc -c -O0 -g -o $@ $&lt;
&nbsp;
simd15_3.o:     simd15.c
        gcc -c -O3 -mno-sse -g -o $@ $&lt;
&nbsp;
simd15_4.o:     simd15.c
        gcc -c -O3 -g -o $@ $&lt;
&nbsp;
simd16_1.o:     simd16.c
        gcc -c -O0 -mno-sse -g -o $@ $&lt;
&nbsp;
simd16_2.o:     simd16.c
        gcc -c -O0 -g -o $@ $&lt;
&nbsp;
simd16_3.o:     simd16.c
        gcc -c -O3 -mno-sse -g -o $@ $&lt;
&nbsp;
simd16_4.o:     simd16.c
        gcc -c -O3 -g -o $@ $&lt;
&nbsp;
simd17_1.o:     simd17.c
        gcc -c -O0 -mno-sse -g -o $@ $&lt;
&nbsp;
simd17_2.o:     simd17.c
        gcc -c -O0 -g -o $@ $&lt;
&nbsp;
simd17_3.o:     simd17.c
        gcc -c -O3 -mno-sse -g -o $@ $&lt;
&nbsp;
simd17_4.o:     simd17.c
        gcc -c -O3 -g -o $@ $&lt;
&nbsp;
simd18_1.o:     simd18.c
        gcc -c -O0 -mno-sse -g -o $@ $&lt;
&nbsp;
simd18_2.o:     simd18.c
        gcc -c -O0 -g -o $@ $&lt;
&nbsp;
simd18_3.o:     simd18.c
        gcc -c -O3 -mno-sse -g -o $@ $&lt;
&nbsp;
simd18_4.o:     simd18.c
        gcc -c -O3 -g -o $@ $&lt;
</pre>



<p><a name="k19"></a></p>
<h2 id="k19">19. Repositář s&nbsp;demonstračními příklady</h2>

<p>Demonstrační příklady napsané v&nbsp;jazyku C, které jsou určené pro překlad
pomocí překladače <strong>GCC C</strong>, byly uložen do Git repositáře, který
je dostupný na adrese <a
href="https://github.com/tisnik/presentations">https://github.com/tisnik/presentations</a>.
Jednotlivé demonstrační příklady si můžete v&nbsp;případě potřeby stáhnout i
jednotlivě bez nutnosti klonovat celý (dnes již velmi rozsáhlý) repositář:</p>

<table>
<tr><th> #</th><th>Příklad</th><th>Stručný popis</th><th>Adresa</th></tr>
<tr><td> 1</td><td>simd01.c</td><td>vektor celých čísel typu <strong>short int</strong></td><td><a href="https://github.com/tisnik/presentations/blob/master/SIMD/simd01.c">https://github.com/tisnik/presentations/blob/master/SIMD/simd01.c</a></td></tr>
<tr><td> 2</td><td>simd02.c</td><td>ukázka použití vektorů s&nbsp;celočíselnými typy bez znaménka</td><td><a href="https://github.com/tisnik/presentations/blob/master/SIMD/simd02.c">https://github.com/tisnik/presentations/blob/master/SIMD/simd02.c</a></td></tr>
<tr><td> 3</td><td>simd03.c</td><td>ukázka použití vektorů s&nbsp;celočíselnými typy se znaménkem</td><td><a href="https://github.com/tisnik/presentations/blob/master/SIMD/simd03.c">https://github.com/tisnik/presentations/blob/master/SIMD/simd03.c</a></td></tr>
<tr><td> 4</td><td>simd04.c</td><td>paralelní součet celočíselných prvků vektorů</td><td><a href="https://github.com/tisnik/presentations/blob/master/SIMD/simd04.c">https://github.com/tisnik/presentations/blob/master/SIMD/simd04.c</a></td></tr>
<tr><td> 5</td><td>simd04B.c</td><td>úprava pro další datové typy</td><td><a href="https://github.com/tisnik/presentations/blob/master/SIMD/simd04B.c">https://github.com/tisnik/presentations/blob/master/SIMD/simd04B.c</a></td></tr>
<tr><td> 6</td><td>simd05.c</td><td>přístup k&nbsp;jednotlivým prvkům vektorů</td><td><a href="https://github.com/tisnik/presentations/blob/master/SIMD/simd05.c">https://github.com/tisnik/presentations/blob/master/SIMD/simd05.c</a></td></tr>
<tr><td> 7</td><td>simd05B.c</td><td>korektnější výpočet počtu prvků vektoru</td><td><a href="https://github.com/tisnik/presentations/blob/master/SIMD/simd05B.c">https://github.com/tisnik/presentations/blob/master/SIMD/simd05B.c</a></td></tr>
<tr><td> 8</td><td>simd05C.c</td><td>definice typu vektoru</td><td><a href="https://github.com/tisnik/presentations/blob/master/SIMD/simd05C.c">https://github.com/tisnik/presentations/blob/master/SIMD/simd05C.c</a></td></tr>
<tr><td> 9</td><td>simd06.c</td><td>vektor čísel s&nbsp;plovoucí řádovou čárkou</td><td><a href="https://github.com/tisnik/presentations/blob/master/SIMD/simd06.c">https://github.com/tisnik/presentations/blob/master/SIMD/simd06.c</a></td></tr>
<tr><td>10</td><td>simd07.c</td><td>paralelní součet prvků vektorů (typ <strong>float</strong>)</td><td><a href="https://github.com/tisnik/presentations/blob/master/SIMD/simd07.c">https://github.com/tisnik/presentations/blob/master/SIMD/simd07.c</a></td></tr>
<tr><td>11</td><td>simd08.c</td><td>paralelní součet prvků vektorů (typ <strong>double</strong>)</td><td><a href="https://github.com/tisnik/presentations/blob/master/SIMD/simd08.c">https://github.com/tisnik/presentations/blob/master/SIMD/simd08.c</a></td></tr>
<tr><td>12</td><td>simd09.c</td><td>překročení délky vektoru</td><td><a href="https://github.com/tisnik/presentations/blob/master/SIMD/simd09.c">https://github.com/tisnik/presentations/blob/master/SIMD/simd09.c</a></td></tr>
<tr><td>13</td><td>simd10.c</td><td>přístup k&nbsp;jednotlivým prvkům vektorů</td><td><a href="https://github.com/tisnik/presentations/blob/master/SIMD/simd10.c">https://github.com/tisnik/presentations/blob/master/SIMD/simd10.c</a></td></tr>
<tr><td>14</td><td>simd11.c</td><td>překročení délky vektoru</td><td><a href="https://github.com/tisnik/presentations/blob/master/SIMD/simd11.c">https://github.com/tisnik/presentations/blob/master/SIMD/simd11.c</a></td></tr>
<tr><td>15</td><td>simd12.c</td><td>dlouhý vektor s&nbsp;256 bajty</td><td><a href="https://github.com/tisnik/presentations/blob/master/SIMD/simd12.c">https://github.com/tisnik/presentations/blob/master/SIMD/simd12.c</a></td></tr>
<tr><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td></tr>
<tr><td>16</td><td>simd13.c</td><td>operace součtu pro vektory s&nbsp;celočíselnými prvky rozličné bitové šířky bez znaménka</td><td><a href="https://github.com/tisnik/presentations/blob/master/SIMD/simd13.c">https://github.com/tisnik/presentations/blob/master/SIMD/simd13.c</a></td></tr>
<tr><td>17</td><td>simd14.c</td><td>operace součtu pro vektory s&nbsp;celočíselnými prvky rozličné bitové šířky se znaménkem</td><td><a href="https://github.com/tisnik/presentations/blob/master/SIMD/simd14.c">https://github.com/tisnik/presentations/blob/master/SIMD/simd14.c</a></td></tr>
<tr><td>18</td><td>simd15.c</td><td>operace součtu pro vektory s&nbsp;prvky rozličné bitové šířky s&nbsp;plovoucí řádovou čárkou</td><td><a href="https://github.com/tisnik/presentations/blob/master/SIMD/simd15.c">https://github.com/tisnik/presentations/blob/master/SIMD/simd15.c</a></td></tr>
<tr><td>19</td><td>simd16.c</td><td>operace součtu pro dlouhé vektory s&nbsp;prvky rozličné bitové šířky s&nbsp;plovoucí řádovou čárkou</td><td><a href="https://github.com/tisnik/presentations/blob/master/SIMD/simd16.c">https://github.com/tisnik/presentations/blob/master/SIMD/simd16.c</a></td></tr>
<tr><td>20</td><td>simd17.c</td><td>všechny podporované binární operace nad vektory s&nbsp;celočíselnými prvky se znaménkem</td><td><a href="https://github.com/tisnik/presentations/blob/master/SIMD/simd17.c">https://github.com/tisnik/presentations/blob/master/SIMD/simd17.c</a></td></tr>
<tr><td>21</td><td>simd18.c</td><td>všechny podporované binární operace nad vektory s&nbsp;prvky typu <strong>float</strong></td><td><a href="https://github.com/tisnik/presentations/blob/master/SIMD/simd18.c">https://github.com/tisnik/presentations/blob/master/SIMD/simd18.c</a></td></tr>
<tr><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td></tr>
<tr><td>22</td><td>Makefile</td><td>Makefile pro překlad demonstračních příkladů</td><td><a href="https://github.com/tisnik/presentations/blob/master/SIMD/Makefile">https://github.com/tisnik/presentations/blob/master/SIMD/Makefile</a></td></tr>
</table>

<p>Soubory vzniklé překladem z&nbsp;jazyka C do assembleru:</p>

<table>
<tr><th> #</th><th>Příklad</th><th>Stručný popis</th><th>Adresa</th></tr>
<tr><td> 1</td><td>simd04_1.lst</td><td>překlad zdrojového kódu <strong>simd04_1.c</strong> s&nbsp;přepínači <strong>-O0 -mno-sse -g</strong></td><td><a href="https://github.com/tisnik/presentations/blob/master/SIMD/simd04_1.lst">https://github.com/tisnik/presentations/blob/master/SIMD/simd04_1.lst</a></td></tr>
<tr><td> 2</td><td>simd04_2.lst</td><td>překlad zdrojového kódu <strong>simd04_2.c</strong> s&nbsp;přepínači <strong>-O0 -g</strong></td><td><a href="https://github.com/tisnik/presentations/blob/master/SIMD/simd04_2.lst">https://github.com/tisnik/presentations/blob/master/SIMD/simd04_2.lst</a></td></tr>
<tr><td> 3</td><td>simd04B_1.lst</td><td>překlad zdrojového kódu <strong>simd04B_1.c</strong> s&nbsp;přepínači <strong>-O0 -mno-sse -g</strong></td><td><a href="https://github.com/tisnik/presentations/blob/master/SIMD/simd04B_1.lst">https://github.com/tisnik/presentations/blob/master/SIMD/simd04B_1.lst</a></td></tr>
<tr><td> 4</td><td>simd04B_2.lst</td><td>překlad zdrojového kódu <strong>simd04B_2.c</strong> s&nbsp;přepínači <strong>-O0 -g</strong></td><td><a href="https://github.com/tisnik/presentations/blob/master/SIMD/simd04B_2.lst">https://github.com/tisnik/presentations/blob/master/SIMD/simd04B_2.lst</a></td></tr>
<tr><td> 5</td><td>simd07_1.lst</td><td>překlad zdrojového kódu <strong>simd07_1.c</strong> s&nbsp;přepínači <strong>-mno-sse -g</strong></td><td><a href="https://github.com/tisnik/presentations/blob/master/SIMD/simd07_1.lst">https://github.com/tisnik/presentations/blob/master/SIMD/simd07_1.lst</a></td></tr>
<tr><td> 6</td><td>simd07_2.lst</td><td>překlad zdrojového kódu <strong>simd07_2.c</strong> s&nbsp;přepínači <strong>-g</strong></td><td><a href="https://github.com/tisnik/presentations/blob/master/SIMD/simd07_2.lst">https://github.com/tisnik/presentations/blob/master/SIMD/simd07_2.lst</a></td></tr>
<tr><td> 7</td><td>simd08_1.lst</td><td>překlad zdrojového kódu <strong>simd08_1.c</strong> s&nbsp;přepínači <strong>-mno-sse -g</strong></td><td><a href="https://github.com/tisnik/presentations/blob/master/SIMD/simd08_1.lst">https://github.com/tisnik/presentations/blob/master/SIMD/simd08_1.lst</a></td></tr>
<tr><td> 8</td><td>simd08_2.lst</td><td>překlad zdrojového kódu <strong>simd08_2.c</strong> s&nbsp;přepínači <strong>-g</strong></td><td><a href="https://github.com/tisnik/presentations/blob/master/SIMD/simd08_2.lst">https://github.com/tisnik/presentations/blob/master/SIMD/simd08_2.lst</a></td></tr>
<tr><td> 9</td><td>simd12_1.lst</td><td>překlad zdrojového kódu <strong>simd12_1.c</strong> s&nbsp;přepínači <strong>-O0 -mno-sse -g </strong></td><td><a href="https://github.com/tisnik/presentations/blob/master/SIMD/simd12_1.lst">https://github.com/tisnik/presentations/blob/master/SIMD/simd12_1.lst</a></td></tr>
<tr><td>10</td><td>simd12_2.lst</td><td>překlad zdrojového kódu <strong>simd12_2.c</strong> s&nbsp;přepínači <strong>-O0 -g </strong></td><td><a href="https://github.com/tisnik/presentations/blob/master/SIMD/simd12_2.lst">https://github.com/tisnik/presentations/blob/master/SIMD/simd12_2.lst</a></td></tr>
<tr><td>11</td><td>simd13_1.lst</td><td>překlad zdrojového kódu <strong>simd13_1.c</strong> s&nbsp;přepínači <strong>-O0 -mno-sse -g</strong></td><td><a href="https://github.com/tisnik/presentations/blob/master/SIMD/simd13_1.lst">https://github.com/tisnik/presentations/blob/master/SIMD/simd13_1.lst</a></td></tr>
<tr><td>12</td><td>simd13_2.lst</td><td>překlad zdrojového kódu <strong>simd13_2.c</strong> s&nbsp;přepínači <strong>-O0 -g</strong></td><td><a href="https://github.com/tisnik/presentations/blob/master/SIMD/simd13_2.lst">https://github.com/tisnik/presentations/blob/master/SIMD/simd13_2.lst</a></td></tr>
<tr><td>13</td><td>simd13_3.lst</td><td>překlad zdrojového kódu <strong>simd13_3.c</strong> s&nbsp;přepínači <strong>-O3 -mno-sse -g</strong></td><td><a href="https://github.com/tisnik/presentations/blob/master/SIMD/simd13_3.lst">https://github.com/tisnik/presentations/blob/master/SIMD/simd13_3.lst</a></td></tr>
<tr><td>14</td><td>simd13_4.lst</td><td>překlad zdrojového kódu <strong>simd13_4.c</strong> s&nbsp;přepínači <strong>-O3 -g</strong></td><td><a href="https://github.com/tisnik/presentations/blob/master/SIMD/simd13_4.lst">https://github.com/tisnik/presentations/blob/master/SIMD/simd13_4.lst</a></td></tr>
<tr><td>15</td><td>simd14_1.lst</td><td>překlad zdrojového kódu <strong>simd14_1.c</strong> s&nbsp;přepínači <strong>-O0 -mno-sse -g</strong></td><td><a href="https://github.com/tisnik/presentations/blob/master/SIMD/simd14_1.lst">https://github.com/tisnik/presentations/blob/master/SIMD/simd14_1.lst</a></td></tr>
<tr><td>16</td><td>simd14_2.lst</td><td>překlad zdrojového kódu <strong>simd14_2.c</strong> s&nbsp;přepínači <strong>-O0 -g</strong></td><td><a href="https://github.com/tisnik/presentations/blob/master/SIMD/simd14_2.lst">https://github.com/tisnik/presentations/blob/master/SIMD/simd14_2.lst</a></td></tr>
<tr><td>17</td><td>simd14_3.lst</td><td>překlad zdrojového kódu <strong>simd14_3.c</strong> s&nbsp;přepínači <strong>-O3 -mno-sse -g</strong></td><td><a href="https://github.com/tisnik/presentations/blob/master/SIMD/simd14_3.lst">https://github.com/tisnik/presentations/blob/master/SIMD/simd14_3.lst</a></td></tr>
<tr><td>18</td><td>simd14_4.lst</td><td>překlad zdrojového kódu <strong>simd14_4.c</strong> s&nbsp;přepínači <strong>-O3 -g</strong></td><td><a href="https://github.com/tisnik/presentations/blob/master/SIMD/simd14_4.lst">https://github.com/tisnik/presentations/blob/master/SIMD/simd14_4.lst</a></td></tr>
<tr><td>19</td><td>simd15_1.lst</td><td>překlad zdrojového kódu <strong>simd15_1.c</strong> s&nbsp;přepínači <strong>-O0 -mno-sse -g</strong></td><td><a href="https://github.com/tisnik/presentations/blob/master/SIMD/simd15_1.lst">https://github.com/tisnik/presentations/blob/master/SIMD/simd15_1.lst</a></td></tr>
<tr><td>20</td><td>simd15_2.lst</td><td>překlad zdrojového kódu <strong>simd15_2.c</strong> s&nbsp;přepínači <strong>-O0 -g</strong></td><td><a href="https://github.com/tisnik/presentations/blob/master/SIMD/simd15_2.lst">https://github.com/tisnik/presentations/blob/master/SIMD/simd15_2.lst</a></td></tr>
<tr><td>21</td><td>simd15_3.lst</td><td>překlad zdrojového kódu <strong>simd15_3.c</strong> s&nbsp;přepínači <strong>-O3 -mno-sse -g</strong></td><td><a href="https://github.com/tisnik/presentations/blob/master/SIMD/simd15_3.lst">https://github.com/tisnik/presentations/blob/master/SIMD/simd15_3.lst</a></td></tr>
<tr><td>22</td><td>simd15_4.lst</td><td>překlad zdrojového kódu <strong>simd15_4.c</strong> s&nbsp;přepínači <strong>-O3 -g</strong></td><td><a href="https://github.com/tisnik/presentations/blob/master/SIMD/simd15_4.lst">https://github.com/tisnik/presentations/blob/master/SIMD/simd15_4.lst</a></td></tr>
<tr><td>23</td><td>simd16_1.lst</td><td>překlad zdrojového kódu <strong>simd16_1.c</strong> s&nbsp;přepínači <strong>-O0 -mno-sse -g</strong></td><td><a href="https://github.com/tisnik/presentations/blob/master/SIMD/simd16_1.lst">https://github.com/tisnik/presentations/blob/master/SIMD/simd16_1.lst</a></td></tr>
<tr><td>24</td><td>simd16_2.lst</td><td>překlad zdrojového kódu <strong>simd16_2.c</strong> s&nbsp;přepínači <strong>-O0 -g</strong></td><td><a href="https://github.com/tisnik/presentations/blob/master/SIMD/simd16_2.lst">https://github.com/tisnik/presentations/blob/master/SIMD/simd16_2.lst</a></td></tr>
<tr><td>25</td><td>simd16_3.lst</td><td>překlad zdrojového kódu <strong>simd16_3.c</strong> s&nbsp;přepínači <strong>-O3 -mno-sse -g</strong></td><td><a href="https://github.com/tisnik/presentations/blob/master/SIMD/simd16_3.lst">https://github.com/tisnik/presentations/blob/master/SIMD/simd16_3.lst</a></td></tr>
<tr><td>26</td><td>simd16_4.lst</td><td>překlad zdrojového kódu <strong>simd16_4.c</strong> s&nbsp;přepínači <strong>-O3 -g</strong></td><td><a href="https://github.com/tisnik/presentations/blob/master/SIMD/simd16_4.lst">https://github.com/tisnik/presentations/blob/master/SIMD/simd16_4.lst</a></td></tr>
<tr><td>27</td><td>simd17_1.lst</td><td>překlad zdrojového kódu <strong>simd17_1.c</strong> s&nbsp;přepínači <strong>-O0 -mno-sse -g</strong></td><td><a href="https://github.com/tisnik/presentations/blob/master/SIMD/simd17_1.lst">https://github.com/tisnik/presentations/blob/master/SIMD/simd17_1.lst</a></td></tr>
<tr><td>28</td><td>simd17_2.lst</td><td>překlad zdrojového kódu <strong>simd17_2.c</strong> s&nbsp;přepínači <strong>-O0 -g</strong></td><td><a href="https://github.com/tisnik/presentations/blob/master/SIMD/simd17_2.lst">https://github.com/tisnik/presentations/blob/master/SIMD/simd17_2.lst</a></td></tr>
<tr><td>29</td><td>simd17_3.lst</td><td>překlad zdrojového kódu <strong>simd17_3.c</strong> s&nbsp;přepínači <strong>-O3 -mno-sse -g</strong></td><td><a href="https://github.com/tisnik/presentations/blob/master/SIMD/simd17_3.lst">https://github.com/tisnik/presentations/blob/master/SIMD/simd17_3.lst</a></td></tr>
<tr><td>30</td><td>simd17_4.lst</td><td>překlad zdrojového kódu <strong>simd17_4.c</strong> s&nbsp;přepínači <strong>-O3 -g</strong></td><td><a href="https://github.com/tisnik/presentations/blob/master/SIMD/simd17_4.lst">https://github.com/tisnik/presentations/blob/master/SIMD/simd17_4.lst</a></td></tr>
<tr><td>31</td><td>simd18_1.lst</td><td>překlad zdrojového kódu <strong>simd18_1.c</strong> s&nbsp;přepínači <strong>-O0 -mno-sse -g</strong></td><td><a href="https://github.com/tisnik/presentations/blob/master/SIMD/simd18_1.lst">https://github.com/tisnik/presentations/blob/master/SIMD/simd18_1.lst</a></td></tr>
<tr><td>32</td><td>simd18_2.lst</td><td>překlad zdrojového kódu <strong>simd18_2.c</strong> s&nbsp;přepínači <strong>-O0 -g</strong></td><td><a href="https://github.com/tisnik/presentations/blob/master/SIMD/simd18_2.lst">https://github.com/tisnik/presentations/blob/master/SIMD/simd18_2.lst</a></td></tr>
<tr><td>33</td><td>simd18_3.lst</td><td>překlad zdrojového kódu <strong>simd18_3.c</strong> s&nbsp;přepínači <strong>-O3 -mno-sse -g</strong></td><td><a href="https://github.com/tisnik/presentations/blob/master/SIMD/simd18_3.lst">https://github.com/tisnik/presentations/blob/master/SIMD/simd18_3.lst</a></td></tr>
<tr><td>34</td><td>simd18_4.lst</td><td>překlad zdrojového kódu <strong>simd18_4.c</strong> s&nbsp;přepínači <strong>-O3 -g</strong></td><td><a href="https://github.com/tisnik/presentations/blob/master/SIMD/simd18_4.lst">https://github.com/tisnik/presentations/blob/master/SIMD/simd18_4.lst</a></td></tr>
</table>



<p><a name="k20"></a></p>
<h2 id="k20">20. Odkazy na Internetu</h2>

<ol>

<li>GCC documentation: Extensions to the C Language Family<br />
<a href="https://gcc.gnu.org/onlinedocs/gcc/C-Extensions.html#C-Extensions">https://gcc.gnu.org/onlinedocs/gcc/C-Extensions.html#C-Extensions</a>
</li>

<li>GCC documentation: Using Vector Instructions through Built-in Functions<br />
<a href="https://gcc.gnu.org/onlinedocs/gcc/Vector-Extensions.html">https://gcc.gnu.org/onlinedocs/gcc/Vector-Extensions.html</a>
</li>

<li>SSE (Streaming SIMD Extentions)<br />
<a href="http://www.songho.ca/misc/sse/sse.html">http://www.songho.ca/misc/sse/sse.html</a>
</li>

<li>Timothy A. Chagnon: SSE and SSE2<br />
<a href="http://www.cs.drexel.edu/~tc365/mpi-wht/sse.pdf">http://www.cs.drexel.edu/~tc365/mpi-wht/sse.pdf</a>
</li>

<li>Intel corporation: Extending the Worldr's Most Popular Processor Architecture<br />
<a href="http://download.intel.com/technology/architecture/new-instructions-paper.pdf">http://download.intel.com/technology/architecture/new-instructions-paper.pdf</a>
</li>

<li>SIMD architectures:<br />
<a href="http://arstechnica.com/old/content/2000/03/simd.ars/">http://arstechnica.com/old/content/2000/03/simd.ars/</a>
</li>

<li>Tour of the Black Holes of Computing!: Floating Point<br />
<a href="http://www.cs.hmc.edu/~geoff/classes/hmc.cs105.../slides/class02_floats.ppt">http://www.cs.hmc.edu/~geoff/classes/hmc.cs105.../slides/class02_floats.ppt</a>
</li>

<li>3Dnow! Technology Manual<br />
AMD Inc., 2000</li>

<li>Intel MMX<sup>TM</sup> Technology Overview<br />
Intel corporation, 1996</li>

<li>MultiMedia eXtensions<br />
<a href="http://softpixel.com/~cwright/programming/simd/mmx.php">http://softpixel.com/~cwright/programming/simd/mmx.php</a>i
</li>

<li>AMD K5 ("K5" / "5k86")<br />
<a href="http://www.pcguide.com/ref/cpu/fam/g5K5-c.html">http://www.pcguide.com/ref/cpu/fam/g5K5-c.html</a>
</li>

<li>Sixth Generation Processors<br />
<a href="http://www.pcguide.com/ref/cpu/fam/g6.htm">http://www.pcguide.com/ref/cpu/fam/g6.htm</a>
</li>

<li>Great Microprocessors of the Past and Present<br />
<a href="http://www.cpushack.com/CPU/cpu1.html">http://www.cpushack.com/CPU/cpu1.html</a>
</li>

<li>Very long instruction word (Wikipedia)<br />
<a href="http://en.wikipedia.org/wiki/Very_long_instruction_word">http://en.wikipedia.org/wiki/Very_long_instruction_word</a>
</li>

<li>CPU design (Wikipedia)<br />
<a href="http://en.wikipedia.org/wiki/CPU_design">http://en.wikipedia.org/wiki/CPU_design</a>
</li>

<li>Bulldozer (microarchitecture)<br />
<a href="https://en.wikipedia.org/wiki/Bulldozer_(microarchitecture)">https://en.wikipedia.org/wiki/Bulldozer_(microarchitecture)</a>
</li>

<li>SIMD Instructions Considered Harmful<br />
<a href="https://www.sigarch.org/simd-instructions-considered-harmful/">https://www.sigarch.org/simd-instructions-considered-harmful/</a>
</li>

<li>GCC Compiler Intrinsics<br />
<a href="https://iq.opengenus.org/gcc-compiler-intrinsics/">https://iq.opengenus.org/gcc-compiler-intrinsics/</a>
</li>

<li>Scalable_Vector_Extension_(SVE)<br />
<a href="https://en.wikipedia.org/wiki/AArch64#Scalable_Vector_Extension_(SVE)">https://en.wikipedia.org/wiki/AArch64#Scalable_Vector_Extension_(SVE)</a>
</li>

<li>FADD/FADDP/FIADD — Add<br />
<a href="https://www.felixcloutier.com/x86/fadd:faddp:fiadd">https://www.felixcloutier.com/x86/fadd:faddp:fiadd</a>
</li>

<li>ADDPS — Add Packed Single-Precision Floating-Point Values<br />
<a href="https://www.felixcloutier.com/x86/addps">https://www.felixcloutier.com/x86/addps</a>
</li>

<li>ADDPD — Add Packed Double-Precision Floating-Point Values<br />
<a href="https://www.felixcloutier.com/x86/addpd">https://www.felixcloutier.com/x86/addpd</a>
</li>

<li>FDIV/FDIVP/FIDIV — Divide<br />
<a href="https://www.felixcloutier.com/x86/fdiv:fdivp:fidiv">https://www.felixcloutier.com/x86/fdiv:fdivp:fidiv</a>
</li>

<li>IDIV — Signed Divide<br />
<a href="https://www.felixcloutier.com/x86/idiv">https://www.felixcloutier.com/x86/idiv</a>
</li>

<li>PADDB/PADDW/PADDD/PADDQ — Add Packed Integers<br />
<a href="https://www.felixcloutier.com/x86/paddb:paddw:paddd:paddq">https://www.felixcloutier.com/x86/paddb:paddw:paddd:paddq</a>
</li>

<li>PSUBB/PSUBW/PSUBD — Subtract Packed Integers<br />
<a href="https://www.felixcloutier.com/x86/psubb:psubw:psubd">https://www.felixcloutier.com/x86/psubb:psubw:psubd</a>
</li>

<li>PMULLW — Multiply Packed Signed Integers and Store Low Result<br />
<a href="https://www.felixcloutier.com/x86/pmullw">https://www.felixcloutier.com/x86/pmullw</a>
</li>

<li>PUNPCKLBW/PUNPCKLWD/PUNPCKLDQ/PUNPCKLQDQ — Unpack Low Data<br />
<a href="https://www.felixcloutier.com/x86/punpcklbw:punpcklwd:punpckldq:punpcklqdq">https://www.felixcloutier.com/x86/punpcklbw:punpcklwd:punpckldq:punpcklqdq</a>
</li>

<li>PUNPCKHBW/PUNPCKHWD/PUNPCKHDQ/PUNPCKHQDQ — Unpack High Data<br />
<a href="https://www.felixcloutier.com/x86/punpckhbw:punpckhwd:punpckhdq:punpckhqdq">https://www.felixcloutier.com/x86/punpckhbw:punpckhwd:punpckhdq:punpckhqdq</a>
</li>

<li>PACKUSWB — Pack with Unsigned Saturation<br />
<a href="https://www.felixcloutier.com/x86/packuswb">https://www.felixcloutier.com/x86/packuswb</a>
</li>

<li>DIVPS — Divide Packed Single-Precision Floating-Point Values<br />
<a href="https://www.felixcloutier.com/x86/divps">https://www.felixcloutier.com/x86/divps</a>
</li>

<li>CBW/CWDE/CDQE — Convert Byte to Word/Convert Word to Doubleword/Convert Doubleword to Quadword<br />
<a href="https://www.felixcloutier.com/x86/cbw:cwde:cdqe">https://www.felixcloutier.com/x86/cbw:cwde:cdqe</a>
</li>

<li>PAND — Logical AND<br />
<a href="https://www.felixcloutier.com/x86/pand">https://www.felixcloutier.com/x86/pand</a>
</li>

<li>POR — Bitwise Logical OR<br />
<a href="https://www.felixcloutier.com/x86/por">https://www.felixcloutier.com/x86/por</a>
</li>

<li>PXOR — Logical Exclusive OR<br />
<a href="https://www.felixcloutier.com/x86/pxor">https://www.felixcloutier.com/x86/pxor</a>
</li>

</ol>



<p></p><p></p>
<p><small>Autor: <a href="http://www.fit.vutbr.cz/~tisnovpa">Pavel Tišnovský</a> &nbsp; 2022</small></p>
</body>
</html>
