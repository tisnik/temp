<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
        "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html>
<head>
<title>Mikroprocesory a mikrořadiče s jádrem SH-2A a koprocesorem SH2A-FPU</title>
<meta name="Author" content="Pavel Tisnovsky" />
<meta name="Generator" content="vim" />
<meta http-equiv="content-type" content="text/html; charset=utf-8" />
<style type="text/css">
         body {color:#000000; background:#ffffff;}
         h1  {font-family: arial, helvetica, sans-serif; color:#ffffff; background-color:#c00000; text-align:center; padding-left:1em}
         h2  {font-family: arial, helvetica, sans-serif; color:#ffffff; background-color:#0000c0; padding-left:1em; text-align:left}
         h3  {font-family: arial, helvetica, sans-serif; color:#000000; background-color:#c0c0c0; padding-left:1em; text-align:left}
         h4  {font-family: arial, helvetica, sans-serif; color:#000000; background-color:#e0e0e0; padding-left:1em; text-align:left}
         a   {font-family: arial, helvetica, sans-serif;}
         li  {font-family: arial, helvetica, sans-serif; color:#000000; text-align:justify; width:450px;}
         ol  {font-family: arial, helvetica, sans-serif; color:#000000; text-align:justify; width:450px;}
         ul  {font-family: arial, helvetica, sans-serif; color:#000000; text-align:justify; width:450px;}
         p   {font-family: arial, helvetica, sans-serif; color:#000000; text-align:justify;}
         pre {background:#e0e0e0}
</style>
</head>

<body>

<h1>Mikroprocesory a mikrořadiče s jádrem SH-2A a koprocesorem SH2A-FPU</h1>

<h3>Pavel Tišnovský</h3>

<p></p>

<h1>Úvodník</h1>

<p>Mikroprocesory a mikrořadiče založené na RISCovém jádru SH-2A mohou být doplněny o matematický koprocesor SH2A-FPU. Dnes se seznámíme s vlastnostmi tohoto koprocesoru a pro doplnění a shrnutí si ještě porovnáme jeho možnosti s dalšími již popsanými RISCovými procesory.</p>



<h2>Obsah</h2>

<p><a href="#k01">1. Mikroprocesory a mikrořadiče s&nbsp;jádrem SH-2A a koprocesorem SH2A-FPU</a></p>
<p><a href="#k02">2. Pracovní registry matematického koprocesoru</a></p>
<p><a href="#k03">3. Registr FPUL používaný při přenosu dat</a></p>
<p><a href="#k04">4. Stavový a řídicí registr FPSCR</a></p>
<p><a href="#k05">5. Formáty zpracovávaných hodnot s&nbsp;plovoucí řádovou čárkou</a></p>
<p><a href="#k06">6. Speciální hodnoty a jejich význam</a></p>
<p><a href="#k07">7. Režimy zaokrouhlování</a></p>
<p><a href="#k08">8. Výjimky, které mohou vzniknout při FP operacích</a></p>
<p><a href="#k09">9. Seznam instrukcí matematického koprocesoru</a></p>
<p><a href="#k10">10. Základní aritmetické operace</a></p>
<p><a href="#k11">11. Funkce s&nbsp;jedním vstupním operandem</a></p>
<p><a href="#k12">12. Porovnání operandů s&nbsp;nastavením bitu T</a></p>
<p><a href="#k13">13. Načtení konstanty a konverze</a></p>
<p><a href="#k14">14. Přenos FP hodnot mezi matematickým koprocesorem a pamětí</a></p>
<p><a href="#k15">15. Porovnání možností SH2A-FPU s&nbsp;dalšími RISCovými čipy</a></p>
<p><a href="#k16">16. SPARC</a></p>
<p><a href="#k17">17. PA-RISC</a></p>
<p><a href="#k18">18. ARM VFP</a></p>
<p><a href="#k19">19. RISC-V</a></p>
<p><a href="#k20">20. Odkazy na Internetu</a></p>



<p><a name="k01"></a></p>
<h2 id="k01">1. Mikroprocesory a mikrořadiče s&nbsp;jádrem SH-2A a koprocesorem SH2A-FPU</h2>

<p>V&nbsp;předchozích třech částech tohoto seriálu jsme si popsali RISCové
procesory s&nbsp;architekturou <i>SH-2</i> i s&nbsp;její rozšířenou variantou
<i>SH-2A</i>. Obě tyto architektury jsou používány doposud a nalezneme je
především v&nbsp;čipech vyráběných společností Renesas, která vývoj i výrobu
převzala od firmy Hitachi. Vzhledem k&nbsp;tomu, že mnohé moderní čipy musí být
připraveny pro zpracování různých typů dat a mnohdy i pro komplikovanější
výpočty, nás asi nepřekvapí, že u některých mikroprocesorů a mikrořadičů
s&nbsp;architekturou <i>SH-2A</i> nalezneme i matematický koprocesor
(realizovaný samozřejmě na stejném čipu). Tento mikroprocesor má vlastní sadu
pracovních registrů, stavový a řídicí registr, registr určený pro přenosy dat a
pracuje nezávisle na hlavní ALU. Dnes si tento matematický koprocesor popíšeme
a navíc si v&nbsp;poslední třetině článku porovnáme jeho možnosti
s&nbsp;dalšími RISCovými čipy, což by mohlo být zajímavé, protože jednotlivé
RISCové čipy se používaly v&nbsp;mnohdy zcela odlišných oblastech, od
mikrořadičů přes grafické pracovní stanice až po superpočítače.</p>



<p><a name="k02"></a></p>
<h2 id="k02">2. Pracovní registry matematického koprocesoru</h2>

<p>Matematický koprocesor má vlastní sadu šestnácti 32bitových pracovních
registrů pojmenovaných FPR0 až FPR15. Na základě nastaveného režimu je možné
tyto registry použít pro uložení hodnot s&nbsp;plovoucí řádovou čárkou
s&nbsp;jednoduchou přesností (<i>single</i>) či s&nbsp;dvojitou přesností
(<i>double</i>). Při použití jednoduché přesnosti se sada šestnácti pracovních
registrů označuje v&nbsp;assembleru jmény <strong>FP0</strong> až
<strong>FP15</strong> (vypadlo písmeno R), zatímco při použití dvojité
přesnosti se sada registrů zmenšuje na polovinu: <strong>DR0</strong>,
<strong>DR2</strong>, <strong>DR4</strong> až <strong>DR14</strong> (každý
z&nbsp;těchto pseudoregistrů má šířku 64 bitů a zabírá dva původní registry
<strong>FPRn+FPRn+1</strong>). Režim výpočtů a režim přenosu dat se ovládá bity
<strong>PR</strong> a <strong>SZ</strong> v&nbsp;řídicím a stavovém registru
<strong>FPSCR</strong> popsaném v&nbsp;dalších kapitolách.</p>



<p><a name="k03"></a></p>
<h2 id="k03">3. Registr FPUL používaný při přenosu dat</h2>

<p>Hodnoty je možné do matematického koprocesoru přenášet dvěma způsoby. Buď je
lze přímo načítat z&nbsp;operační paměti s&nbsp;využitím instrukcí
<strong>FMOV.S</strong> a <strong>FMOV.D</strong>, nebo je možné využít
speciální registr <strong>FPUL</strong> (<i>Floating-Point Communication
Register</i>), který tvoří rozhraní mezi hlavním procesorem a matematickým
koprocesorem. K&nbsp;dispozici jsou čtyři instrukce určené pro načtení či
uložení hodnoty do tohoto registru:</p>

<table>
<tr><th>Instrukce</th><th>Operandy</th><th>Význam</th></tr>
<tr><td>LDS</td><td>Rm,FPUL</td><td>FPUL=Rm</td></tr>
<tr><td>LDS.L</td><td>@Rm+, FPUL</td><td>FPUL=(Rm), Rm=Rm+4</td></tr>
<tr><td>STS</td><td>FPUL,Rn</td><td>Rn=FPUL</td></tr>
<tr><td>STS.L</td><td>FPUL,@-Rn</td><td>Rn=Rn-4, (Rn)=FPUL</td></tr>
</table>

<p>Jakmile je FP hodnota umístěna v&nbsp;registru <strong>FPUL</strong>,
použijí se na straně matematického koprocesoru instrukce popsané <a
href="#k13">ve třinácté kapitole</a>, které dokážou provádět konverze, prosté
uložení hodnoty do zvoleného FP registru apod.</p>



<p><a name="k04"></a></p>
<h2 id="k04">4. Stavový a řídicí registr FPSCR</h2>

<p>Kromě sady pracovních registrů a speciálního registru <strong>FPUL</strong>
se při použití matematického koprocesoru využívá stavový a řídicí registr
nazvaný <strong>FPSCR</strong> (podobný registr nalezneme i u mnoha dalších
mikroprocesorových architektur). Registr <strong>FPSCR</strong> je 32bitový,
ovšem pouze některé jeho bity jsou skutečně využity. Navíc jsou některé bity
určeny pouze pro čtení, protože se nastavují automaticky při provádění
některých operací:</p>

<table>
<tr><th>Bity</th><th>Označení</th><th>Přístup</th><th>Stručný popis</th></tr>
<tr><td>0..1</td><td>RM</td><td>R/W</td><td>volba zaokrouhlovacího režimu</td></tr>
<tr><td>2..6</td><td>Flag</td><td>R/W</td><td>bitové pole s&nbsp;&bdquo;trvalým&ldquo; pamatováním příznaků výjimek</td></tr>
<tr><td>7..11</td><td>Enable</td><td>R/W</td><td>bitové pole pro povolení jednotlivých typů výjimek</td></tr>
<tr><td>12..17</td><td>Cause</td><td>R/W</td><td>bitové pole pro uložení příznaků výjimek</td></tr>
<tr><td>18</td><td>DN </td><td>R  </td><td>detekce denormalizované hodnoty při provedení operace</td></tr>
<tr><td>19</td><td>PR </td><td>R/W</td><td>řízení režimu výpočtů: single/double</td></tr>
<tr><td>20</td><td>SZ </td><td>R/W</td><td>řízení režimu přenosu pro instrukce FMOV: single/double</td></tr>
<tr><td>22</td><td>QIS</td><td>R/W</td><td>nastavení režimu zpracování hodnot qNaN a nekonečen</td></tr>
</table>

<p>Zajímavý je rozdíl mezi bitovým polem <strong>Flag</strong> a
<strong>Cause</strong>. Příznaky výjimky v&nbsp;bitovém poli
<strong>Cause</strong> se vždy vynulují před provedením další FP operace, což
znamená, že pokud se provede například dělení 0/0 a posléze součet dvou jiných
čísel, už se o dělení nulou nedozvíme. Naproti tomu bity v&nbsp;bitovém poli
<strong>Flag</strong> jsou do jedničky nastaveny trvale, přesněji řečeno až do
doby, dokud nejsou vynulovány programem (zápisem do registru
<strong>FPSCR</strong>). Díky tomu lze provést delší výpočet a až poté
zkontrolovat, zda proběhl správně, a to bez nutnosti implementace relativně
složitého mechanismu obsluhy výjimek.</p>

<p>Poznámka: ve skutečnosti je v&nbsp;poli <strong>Cause</strong> šest bitů,
protože zde nalezneme i bit FPU Error (E). Ostatní dvě korespondující bitová
pole mají jen pět bitů. FPU Error nemá na SH2-FPU význam a ani ho nelze
zakázat.</p>

<p>Pro načtení hodnoty tohoto registru či naopak pro jeho uložení lze použít
následující instrukce:</p>

<table>
<tr><th>Instrukce</th><th>Operandy</th><th>Význam</th></tr>
<tr><td>LDS</td><td>Rm,FPSCR</td><td>FPSCR=Rm</td></tr>
<tr><td>LDS.L</td><td>@Rm+, FPSCR</td><td>FPSCR=(Rm), Rm=Rm+4</td></tr>
<tr><td>STS</td><td>FPSCR,Rn</td><td>Rn=FPSCR</td></tr>
<tr><td>STS.L</td><td>FPSCR,@-Rn</td><td>Rn=Rn-4, (Rn)=FPSCR</td></tr>
</table>



<p><a name="k05"></a></p>
<h2 id="k05">5. Formáty zpracovávaných hodnot s&nbsp;plovoucí řádovou čárkou</h2>

<p>V&nbsp;této kapitole si ve stručnosti popíšeme bitové podoby obou formátů
numerických hodnot uložených v&nbsp;systému plovoucí řádové čárky,
tj.&nbsp;hodnot zpracovávaných v&nbsp;<i>SH2A-FPU</i>. U obou formátů je
použita shodná struktura &ndash; v&nbsp;jednom bitu je uloženo znaménko čísla,
následuje (dvojkový) exponent a ve třetím bitovém poli je uložena mantisa.
Formát <i>single</i> odpovídá normě <i>IEEE 754</i>, a to včetně speciálních
hodnoty typu nekonečna, denormalizovaných čísel či <i>NaN</i>. 32bitové slovo
je rozděleno následovně:</p>

<pre>
 +-+--------+-----------------------+
 |s|exponent|  mantisa, bity 0..22  |
 +-+--------+-----------------------+
31 30     23 22                     0
</pre>

<p>U formátu <i>double</i>, který taktéž odpovídá specifikaci popsané
v&nbsp;normě <i>IEEE 754</i>, je rozšířen jak exponent (což zvyšuje rozsah
reprezentovatelných hodnot), tak i mantisa (což naopak zvyšuje přesnost
uložených hodnot). Číselné hodnoty jsou v&nbsp;operační paměti uloženy ve dvou
32bitových slovech, protože čipy SH-2A k&nbsp;paměti přistupují po 32bitové
sběrnici:</p>

<pre>
 +-+-----------+--------------------+
 |s| exponent  |mantisa, bity 32..51|
 +-+-----------+--------------------+
31 30        20 19                  0

 +----------------------------------+
 |        mantisa, bity 0..31       |
 +----------------------------------+
31                                  0
</pre>

<p>Základní vlastnosti obou podporovaných formátů jsou shrnuty
v&nbsp;následující tabulce:</p>

<table>
<tr><th>Vlastnost</th><th>Jednoduchá přesnost</th><th>Dvojitá přesnost</th></tr>
<tr><td>Znaménko</td><td>1 bit</td><td>1 bit</td></tr>
<tr><td>Exponent</td><td>8 bitů</td><td>11 bitů</td></tr>
<tr><td>Mantisa</td><td>23 bitů</td><td>52 bitů</td></tr>
<tr><td>Celkem</td><td>32 bitů</td><td>64 bitů</td></tr>
<tr><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td></tr>
<tr><td>Bias</td><td>+127</td><td>+1023</td></tr>
</table>



<p><a name="k06"></a></p>
<h2 id="k06">6. Speciální hodnoty a jejich význam</h2>

<p>Kromě běžných (normalizovaných) hodnot je možné v&nbsp;registrech
matematického koprocesoru ukládat i několik speciálních hodnot, které například
mohou být výsledkem některých matematických operací. Jedná se především o
kladné a záporné nekonečno (výsledek dělení nulou), dále lze rozlišit kladnou a
zápornou nulu, takzvaná denormalizovaná čísla (ta mají sníženou přesnost kvůli
omezení velikosti exponentu) a taktéž hodnoty <i>NaN (Not a Number)</i>, které
vzniknou například po operaci 0/0 či &infin;+&infin;. Podívejme se na některé
možnosti v&nbsp;případě použití jednoduché přesnosti (32bitových registrů):</p>

<table>
<tr><th>Hodnota (hex)</th><th>Význam</th></tr>
<tr><td>0x0000 0000</td><td>kladná nula</td></tr>
<tr><td>0x8000 0000</td><td>záporná nula</td></tr>
<tr><td>0x7f80 0000</td><td>kladné nekonečno</td></tr>
<tr><td>0xff80 0000</td><td>záporné nekonečno</td></tr>
<tr><td>0x007f ffff až 0x0000 0001</td><td>kladná denormalizovaná čísla</td></tr>
<tr><td>0x8000 0001 až 0x807f ffff</td><td>záporná denormalizovaná čísla</td></tr>
<tr><td>0xff8? ????</td><td>NaN</td></tr>
</table>



<p><a name="k07"></a></p>
<h2 id="k07">7. Režimy zaokrouhlování</h2>

<p>Na rozdíl od mnoha dalších typů matematických koprocesorů lze u
<i>SH2A-FPU</i> zvolit zaokrouhlovací režim pouze ze dvou variant (běžnější
jsou čtyři varianty odpovídající normě IEEE 754). Jedná se o zaokrouhlení na
nejbližší reprezentovatelné číslo nebo zaokrouhlení směrem k&nbsp;nule
(samozřejmě v&nbsp;závislosti na tom, zda se zaokrouhluje kladná či záporná
hodnota). Zajímavé je, že v&nbsp;řídicím registru <strong>FPSCR</strong> jsou
pro volbu zaokrouhlovacího režimu rezervovány dva bity, takže zde existuje
prostor pro případné další rozšiřování.</p>



<p><a name="k08"></a></p>
<h2 id="k08">8. Výjimky, které mohou vzniknout při FP operacích</h2>

<p>Při provádění FP operací může vzniknout několik typů výjimek, jejichž
příznaky jsou uloženy do bitových polí <strong>Flag</strong> a
<strong>Cause</strong> registru <strong>FPSCR</strong> (viz též <a
href="#k04">čtvrtou kapitolu</a>):</p>

<table>
<tr><th>Příznak</th><th>Význam</th></tr>
<tr><td>Invalid Operation</td><td>vstupem do operace je NaN, či podobný typ chyby</td></tr>
<tr><td>Division by Zero </td><td>dělení nulou, ovšem kromě operace 0/0</td></tr>
<tr><td>Overflow         </td><td>přetečení (výsledek nelze reprezentovat)</td></tr>
<tr><td>Underflow        </td><td>podtečení (výsledek je tak blízko nuly, že nelze reprezentovat)</td></tr>
<tr><td>Inexact          </td><td>došlo k&nbsp;přetečení, podtečení či nutnosti zaokrouhlení</td></tr>
</table>

<p>Poznámka: termínem zaokrouhlení se zde myslí změna posledního
reprezentovatelného bitu mantisy, nikoli zaokrouhlení na celé číslo.</p>



<p><a name="k09"></a></p>
<h2 id="k09">9. Seznam instrukcí matematického koprocesoru</h2>

<p>V&nbsp;následujících pěti kapitolách si popíšeme všechny instrukce, které
jsou určeny pro ovládání matematického koprocesoru <i>SH2A-FPU</i>. Instrukce
můžeme rozdělit jak podle typu operandů (hodnoty s&nbsp;jednoduchou nebo
dvojitou přesností), tak i podle funkce či operace, kterou tyto instrukce
provádí. <a href="#k10">V&nbsp;kapitole desáté</a> nalezneme instrukce určené
pro provádění základních aritmetických operací se dvěma zdrojovými operandy a
jedním operandem cílovým. Podporované unární operace budou popsány <a
href="#k11">v&nbsp;jedenácté kapitole</a>. Důležité jsou samozřejmě i operace
určené pro porovnání dvou operandů a nastavení příznakového bitu
<strong>T</strong>; tyto operace jsou popsány <a href="#k12">v&nbsp;kapitole
číslo 12</a>. <a href="#k13">V&nbsp;navazující kapitole</a> se seznámíme
s&nbsp;konverzními funkcemi i instrukcemi určenými pro načtení konstant. A
konečně si <a href="#k14">ve čtrnácté kapitole</a> popíšeme instrukce určené
pro přenos hodnot mezi matematickým koprocesorem a operační pamětí.</p>



<p><a name="k10"></a></p>
<h2 id="k10">10. Základní aritmetické operace</h2>

<p>Mezi základní aritmetické operace podporované matematickými koprocesory
<i>SH2A-FPU</i> patří podle očekávání součet, rozdíl, součin a podíl,
k&nbsp;nimž ještě připočtěme operaci typu <i>multiply and accumulate</i> (ta je
prováděná jen s&nbsp;typem float/single, což je však pravděpodobně pro většinu
aplikací dostačující). Povšimněte si, že součet, rozdíl a součin trvá
v&nbsp;případě použití operandů s&nbsp;jednoduchou přesností pouhý jeden takt,
zatímco u operandů s&nbsp;dvojitou přesností šest taktů. Operace dělení je
mnohem delší &ndash; deset popř.&nbsp;celých 23 hodinových cyklů:</p>

<table>
<tr><th>Instrukce</th><th>Operandy</th><th>Prováděná činnost</th><th>Počet cyklů</th></tr>
<tr><td>FADD</td><td>FRm, FRn</td><td>FRn=FRn+FRm</td><td>1</td></tr>
<tr><td>FADD</td><td>DRm, DRn</td><td>DRn=DRn+DRm</td><td>6</td></tr>
<tr><td>FSUB</td><td>FRm, FRn</td><td>FRn=FRn-FRm</td><td>1</td></tr>
<tr><td>FSUB</td><td>DRm, DRn</td><td>DRn=DRn-DRm</td><td>6</td></tr>
<tr><td>FMUL</td><td>FRm, FRn</td><td>FRn=FRn&times;FRm</td><td>1</td></tr>
<tr><td>FMUL</td><td>DRm, DRn</td><td>DRn=DRn&times;DRm</td><td>6</td></tr>
<tr><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td></tr>
<tr><td>FDIV</td><td>FRm, FRn</td><td>FRn=FRn-FRm</td><td>10</td></tr>
<tr><td>FDIV</td><td>DRm, DRn</td><td>DRn=DRn-DRm</td><td>23</td></tr>
<tr><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td></tr>
<tr><td>FMAC</td><td>FR0,FRm,FRn</td><td>FRn=FR0&times;FRm+FRn</td><td>1</td></tr>
</table>



<p><a name="k11"></a></p>
<h2 id="k11">11. Funkce s&nbsp;jedním vstupním operandem</h2>

<p>Následuje trojice operací, které mají pouze jediný vstupní operand. Dvě
z&nbsp;těchto instrukcí jsou velmi jednoduché, protože pouze mění nejvyšší
(znaménkový) bit mantisy, takže není překvapující, že tyto instrukce jsou
dokončeny v&nbsp;jediném taktu. Ovšem třetí instrukce, která počítá druhou
odmocninu, je již nepoměrně složitější, čemuž také odpovídá potřebný počet
cyklů na dokončení &ndash; 9 hodinových cyklů pro jednoduchou přesnost a
dokonce celých 22 hodinových cyklů pro přesnost dvojitou:</p>

<table>
<tr><th>Instrukce</th><th>Operandy</th><th>Prováděná činnost</th><th>Počet cyklů</th></tr>
<tr><td>FABS</td><td>FRn</td><td>FRn=|FRn|</td><td>1</td></tr>
<tr><td>FABS</td><td>DRn</td><td>DRn=|DRn|</td><td>1</td></tr>
<tr><td>FNEG</td><td>FRn</td><td>FRn=-FRn</td><td>1</td></tr>
<tr><td>FNEG</td><td>DRn</td><td>DRn=-DRn</td><td>1</td></tr>
<tr><td>FSQRT</td><td>FRn</td><td>FRn=&radic;FRn</td><td>9</td></tr>
<tr><td>FSQRT</td><td>DRn</td><td>DRn=&radic;DRn</td><td>22</td></tr>
</table>



<p><a name="k12"></a></p>
<h2 id="k12">12. Porovnání operandů s&nbsp;nastavením bitu T</h2>

<p>Další dvě operace se jmenují <strong>FCMP/EQ</strong> a
<strong>FCMP/GT</strong>. Tyto operace porovnají obsahy dvou pracovních
registrů (ať již FR či DR) a na základě splnění či naopak nesplnění podmínky
(&bdquo;rovnost&ldquo;, &bdquo;větší než&ldquo;) nastaví příznakový bit
<strong>T</strong>, s&nbsp;jehož významem jsme se seznámili předminule a
minule. Povšimněte si, že v&nbsp;případě porovnání registrů obsahujících
hodnoty s&nbsp;dvojitou přesností je instrukce dokončena až za dva takty:</p>

<table>
<tr><th>Instrukce</th><th>Operandy</th><th>Prováděná činnost</th><th>Počet cyklů</th></tr>
<tr><td>FCMP/EQ</td><td>FRm, FRn</td><td>T=(FRn=FRm)</td><td>1</td></tr>
<tr><td>FCMP/EQ</td><td>DRm, DRn</td><td>T=(DRn=DRm)</td><td>2</td></tr>
<tr><td>FCMP/GT</td><td>FRm, FRn</td><td>T=(FRn&gt;FRm)</td><td>1</td></tr>
<tr><td>FCMP/GT</td><td>DRm, DRn</td><td>T=(DRn&gt;DRm)</td><td>2</td></tr>
</table>

<p>Poznámka: vzhledem k&nbsp;tomu, že existují podmíněné skoky provedené při
T==1 či naopak T==0, nebylo nutné implementovat instrukci
<strong>FCMP/NE</strong> či <strong>FCMP/LE</strong>. Zbylé dvě možnosti
<strong>FCMP/LT</strong> či <strong>FCMP/GE</strong> je však nutné
v&nbsp;případě potřeby implementovat pomocí většího množství instrukcí.</p>



<p><a name="k13"></a></p>
<h2 id="k13">13. Načtení konstanty a konverze</h2>

<p>Instrukce zmíněné v&nbsp;této kapitole je možné rozdělit do dvou podskupin.
V&nbsp;první podskupině se nachází jediné dvě instrukce, které dokážou přímo
načíst konstantu do zvoleného pracovního registru matematického koprocesoru.
První z&nbsp;těchto instrukcí <strong>FLDI0</strong> načte hodnotu odpovídající
nule, druhá instrukce <strong>FLDI1</strong> načte (normalizovanou) jedničku
(což je samozřejmě něco jiného než hodnota 0x00000001). Dalších osm instrukcí
pak slouží pro přenos dat mezi speciálním registrem <strong>FPUL</strong>
popsaným výše a zvoleným pracovním registrem. Při přenosu dat je možné provést
konverzi, což například umožňuje provádět převody mezi celými 32bitovými čísly
a hodnotami typu single a double a naopak. Povšimněte si, že všechny tyto
instrukce jsou velmi rychlé, což je v&nbsp;kontrastu s&nbsp;jinými typy
matematických koprocesorů, v&nbsp;nichž jsou konverze relativně pomalými
operacemi:</p>

<table>
<tr><th>Instrukce</th><th>Operandy</th><th>Prováděná činnost</th><th>Počet cyklů</th></tr>
<tr><td>FLDI0 </td><td>FRn</td><td>FRn=0x00000000</td><td>1</td></tr>
<tr><td>FLDI1 </td><td>FRn</td><td>FRn=0x3F800000</td><td>1</td></tr>
<tr><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td></tr>
<tr><td>FLDS  </td><td>FRm,FPUL</td><td>FPUL=FRm</td><td>1</td></tr>
<tr><td>FSTS  </td><td>FPUL,FRn</td><td>FPUL=FRn</td><td>1</td></tr>
<tr><td>FLOAT </td><td>FPUL,FRn</td><td>FRn=(float)FPUL</td><td>1</td></tr>
<tr><td>FLOAT </td><td>FPUL,DRn</td><td>DRn=(double)FPUL</td><td>2</td></tr>
<tr><td>FCNVDS</td><td>DRm,FPUL</td><td>FPUL=(float)DRm (konverze)</td><td>2</td></tr>
<tr><td>FCNVSD</td><td>FPUL,DRn</td><td>DRn=(double)FPUL (konverze)</td><td>2</td></tr>
<tr><td>FTRC</td><td>FRm</td><td>FPUL=(long)FRm (konverze)</td><td>1</td></tr>
<tr><td>FTRC</td><td>DRm</td><td>FPUL=(long)DRm (konverze)</td><td>2</td></tr>
</table>



<p><a name="k14"></a></p>
<h2 id="k14">14. Přenos FP hodnot mezi matematickým koprocesorem a pamětí</h2>

<p>Poslední skupinu instrukcí matematického koprocesoru tvoří instrukce, které
se používají buď pro přenos hodnot mezi pracovními registry koprocesoru nebo
mezi pracovními registry a operační pamětí. Při přístupu do operační paměti je
adresa uložena v&nbsp;libovolném celočíselném pracovním registru, ve dvou
registrech R0+Rm či je vypočtena na základě součtu dvanáctibitové konstanty a
vybraného pracovního registru. Povšimněte si, že je k&nbsp;dispozici i adresní
režim s&nbsp;autoinkrementací či autodekrementací adresy, čehož je možné využít
například při zpracování polí:</p>

<table>
<tr><th>Instrukce</th><th>Operandy</th><th>Prováděná činnost</th><th>Počet cyklů</th></tr>
<tr><td>FMOV  </td><td>FRm, FRn         </td><td>FRn=FRm</td><td>1</td></tr>
<tr><td>FMOV  </td><td>DRm, DRn         </td><td>DRn=DRm</td><td>2</td></tr>
<tr><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td></tr>
<tr><td>FMOV.S</td><td>@Rm, FRn         </td><td>FRn=(Rm)</td><td>1</td></tr>
<tr><td>FMOV.D</td><td>@Rm, DRn         </td><td>DRn=(Rm)</td><td>2</td></tr>
<tr><td>FMOV.S</td><td>@(R0, Rm), FRn   </td><td>FRn=(R0+Rm)</td><td>1</td></tr>
<tr><td>FMOV.D</td><td>@(R0, Rm), DRn   </td><td>DRn=(R0+Rm)</td><td>2</td></tr>
<tr><td>FMOV.S</td><td>@Rm+, FRn        </td><td>FRn=(Rm), Rm+=4</td><td>1</td></tr>
<tr><td>FMOV.D</td><td>@Rm+, DRn        </td><td>DRn=(Rm), Rm+=8</td><td>2</td></tr>
<tr><td>FMOV.S</td><td>@(disp12,Rm),FRn </td><td>FRn=(disp&times;4+Rm)</td><td>1</td></tr>
<tr><td>FMOV.D</td><td>@(disp12,Rm),DRn </td><td>DRn=(disp&times;8+Rm)</td><td>2</td></tr>
<tr><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td></tr>
<tr><td>FMOV.S</td><td>FRm, @Rn         </td><td>(Rn)=FRm</td><td>1</td></tr>
<tr><td>FMOV.D</td><td>DRm, @Rn         </td><td>(Rn)=DRm</td><td>2</td></tr>
<tr><td>FMOV.S</td><td>FRm, @(R0,Rn)    </td><td>(R0+Rn)=FRm</td><td>1</td></tr>
<tr><td>FMOV.D</td><td>DRm, @(R0,Rn)    </td><td>(R0+Rn)=DRm</td><td>2</td></tr>
<tr><td>FMOV.S</td><td>FRm, @-Rn        </td><td>Rn-=4, (Rn)=FRm</td><td>1</td></tr>
<tr><td>FMOV.D</td><td>DRm, @-Rn        </td><td>Rn-=8, (Rn)=DRm</td><td>2</td></tr>
<tr><td>FMOV.S</td><td>FRm, @(disp12,Rn)</td><td>(disp&times;4+Rn)=FRm</td><td>1</td></tr>
<tr><td>FMOV.D</td><td>DRm, @(disp12,Rn)</td><td>(disp&times;8+Rn)=DRm</td><td>2</td></tr>
</table>

<p>Poznámka: opět platí, že instrukce pracující s&nbsp;64bitovými hodnotami
jsou zpracovány ve dvojnásobném množství taktů, což souvisí s&nbsp;interní
stavbou koprocesoru.</p>



<p><a name="k15"></a></p>
<h2 id="k15">15. Porovnání možností SH2A-FPU s&nbsp;dalšími RISCovými čipy</h2>

<p>V&nbsp;následujících čtyřech kapitolách bude uvedeno krátké shrnutí
vlastností matematických koprocesorů u dalších typů RISCových procesorů. Dále
uvedené údaje, s&nbsp;nimiž jsme se již ostatně v&nbsp;tomto seriálu seznámili,
nám pomohou si uvědomit, že u některých mikroprocesorových architektur byl
matematický koprocesor velmi důležitou součástí čipu (což například souvisí
s&nbsp;tím, že některé čipy byly použity ve výkonných a taktéž patřičně drahých
grafických pracovních stanicích), zatímco u dalších architektur je patrné, že
tento doplněk nebyl až tak důležitý. Taktéž si povšimněte, jaké operace jsou
podporovány &ndash; v&nbsp;některých případech se jedná o základní aritmetické
operace doplněné například o výpočet druhé odmocniny, u dalších koprocesorů pak
nalezneme mnohem větší repertoár instrukcí.</p>



<p><a name="k16"></a></p>
<h2 id="k16">16. SPARC</h2>

<p>Architektura SPARC-V8 obsahovala FPU, který pracoval nezávisle na hlavním
procesoru. FPU používal 32 registrů, z&nbsp;nichž každý měl šířku 32 bitů,
podobně jako registry používané centrální procesorovou jednotkou (V8).
V&nbsp;32bitových registrech se uchovávaly hodnoty ve formátu <i>single</i>
specifikovaném v&nbsp;<i>IEEE 754</i>. Pokud rozsah a/nebo přesnost formátu
<i>single</i> nedostačovala pro řešení dané úlohy, mohly se vždy dva sousední
registry spojit a vytvořit tak 64bitový dvouregistr, v&nbsp;němž byly uloženy
hodnoty ve formátu <i>double</i> (současně bylo možné využít šestnáct těchto
dvouregistrů), opět podle <i>IEEE 754</i>. Dokonce bylo možné spojit čtyři
pracovní registry a vytvořit tak 128bitovou hodnotu ve formátu <i>quad</i>
(současně se jich mohlo použít osm).</p>

<p>Instrukční sada <i>FPU</i> byla navržena s&nbsp;ohledem na všeprostupující
filozofii RISC, tj.&nbsp;obsahuje pouze základní operace s&nbsp;numerickými
hodnotami a navíc poněkud komplexnější, ale o to používanější instrukci pro
výpočet druhé odmocniny, nikoli například instrukce sloužící pro výpočty
goniometrických či logaritmických funkcí (v&nbsp;tom spočívá poměrně zásadní
odlišnost od matematických koprocesorů řady <i>80x87</i>, které navíc původně
pracovaly pouze s&nbsp;osmicí registrů tvořících zásobník). Instrukce používají
tříadresový kód, protože šířka instrukčního slova je stále 32 bitů.</p>

<p>Seznam podporovaných instrukcí:</p>

<table>
<tr><th>#</th><th>Instrukce</th><th>Význam</th></tr>
<tr><td> 1</td><td>FsTOd</td><td>konverze single na double</td></tr>
<tr><td> 2</td><td>FsTOq</td><td>konverze single na quad</td></tr>
<tr><td> 3</td><td>FdTOs</td><td>konverze double na single</td></tr>
<tr><td> 4</td><td>FdTOq</td><td>konverze double na quad</td></tr>
<tr><td> 5</td><td>FqTOs</td><td>konverze quad na single</td></tr>
<tr><td> 6</td><td>FqTOd</td><td>konverze quad na double</td></tr>
<tr><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td></tr>
<tr><td> 7</td><td>FSQRTs</td><td>druhá odmocnina (pro typ single)</td></tr>
<tr><td> 8</td><td>FSQRTd</td><td>druhá odmocnina (pro typ double)</td></tr>
<tr><td> 9</td><td>FSQRTq</td><td>druhá odmocnina (pro typ quad)</td></tr>
<tr><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td></tr>
<tr><td>10</td><td>FADDs</td><td>součet single</td></tr>
<tr><td>11</td><td>FADDd</td><td>součet double</td></tr>
<tr><td>12</td><td>FADDq</td><td>součet quad</td></tr>
<tr><td>13</td><td>FSUBs</td><td>rozdíl single</td></tr>
<tr><td>14</td><td>FSUBd</td><td>rozdíl double</td></tr>
<tr><td>15</td><td>FSUBq</td><td>rozdíl quad</td></tr>
<tr><td>16</td><td>FMULs</td><td>součin single</td></tr>
<tr><td>17</td><td>FMULd</td><td>součin double</td></tr>
<tr><td>18</td><td>FMULq</td><td>součin quad</td></tr>
<tr><td>19</td><td>FsMULd</td><td>součin single na double</td></tr>
<tr><td>20</td><td>FdMULq</td><td>součin double na quad</td></tr>
<tr><td>21</td><td>FDIVs</td><td>podíl single</td></tr>
<tr><td>22</td><td>FDIVd</td><td>podíl double</td></tr>
<tr><td>23</td><td>FDIVq</td><td>podíl quad</td></tr>
<tr><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td></tr>
<tr><td>24</td><td>FCMPs</td><td>porovnání single</td></tr>
<tr><td>25</td><td>FCMPd</td><td>porovnání double</td></tr>
<tr><td>26</td><td>FCMPq</td><td>porovnání quad</td></tr>
<tr><td>27</td><td>FCMPEs</td><td>porovnání single (s vyvoláním výjimky při NaN)</td></tr>
<tr><td>28</td><td>FCMPEd</td><td>porovnání double (s vyvoláním výjimky při NaN)</td></tr>
<tr><td>29</td><td>FCMPEq</td><td>porovnání quad (s vyvoláním výjimky při NaN)</td></tr>
</table>



<p><a name="k17"></a></p>
<h2 id="k17">17. PA-RISC</h2>

<p>První verze matematických koprocesorů pro mikroprocesory <i>PA-RISC</i> měly
poměrně jednoduchou instrukční sadu obsahující instrukce pro provádění
základních aritmetických operací s&nbsp;registry <strong>FPR0</strong> až
<strong>FPR15</strong> a později též s&nbsp;registry <strong>FPR16</strong> až
<strong>FPR31</strong> (všechny tyto registry měly šířku 64 bitů, což je
v&nbsp;kontrastu s&nbsp;SH2A-FPU). Kromě čtveřice aritmetických operací součtu,
rozdílu, součinu a mocniny měli programátoři k&nbsp;dispozici operaci pro
výpočet absolutní hodnoty a taktéž instrukci pro výpočet druhé odmocniny.
Kromě toho dokázal matematický koprocesor provádět různé konverze, zejména
převody mezi numerickými hodnotami uloženými v&nbsp;systému plovoucí řádové
čárky (<i>FP &ndash; Floating Point</i>) a hodnotami s&nbsp;pevnou řádovou
čárkou (<i>FX &ndash; Fixed Point</i>). Všechny tyto operace, včetně operace
pro zaokrouhlení výsledku či pro porovnání dvou číselných hodnot
(k&nbsp;dispozici bylo všech šest testů na relace mezi dvojicí numerických
hodnot), jsou vypsány v&nbsp;následující tabulce:</p>

<table>
<tr><th>#</th><th>Instrukce</th><th>Význam</th></tr>
<tr><td> 1</td><td>COPR</td><td>Identifikace koprocesoru</td></tr>
<tr><td> 2</td><td>FCPY</td><td>Kopie hodnoty</td></tr>
<tr><td> 3</td><td>FABS</td><td>Výpočet absolutní hodnoty</td></tr>
<tr><td> 4</td><td>FSQRT</td><td>Výpočet druhé odmocniny</td></tr>
<tr><td> 5</td><td>FRND</td><td>Zaokrouhlení na celé číslo</td></tr>
<tr><td> 6</td><td>FCNVFF</td><td>Konverze FP na FP</td></tr>
<tr><td> 7</td><td>FCNVXF</td><td>Konverze FX na FP</td></tr>
<tr><td> 8</td><td>FCNVFX</td><td>Konverze FP na FX</td></tr>
<tr><td> 9</td><td>FCNVFXT</td><td>Konverze FP na FX s&nbsp;explicitním zaokrouhlením směrem k&nbsp;nule</td></tr>
<tr><td>10</td><td>FCMP</td><td>Porovnání dvou hodnot</td></tr>
<tr><td>11</td><td>FTEST</td><td>Test příznakových bitů</td></tr>
<tr><td>12</td><td>FADD</td><td>Součet dvou hodnot</td></tr>
<tr><td>13</td><td>FSUB</td><td>Rozdíl dvou hodnot</td></tr>
<tr><td>14</td><td>FMPY</td><td>Součin dvou hodnot</td></tr>
<tr><td>15</td><td>FDIV</td><td>Podíl dvou hodnot</td></tr>
</table>



<p><a name="k18"></a></p>
<h2 id="k18">18. ARM VFP</h2>

<p>Na procesorech <i>ARM</i> se můžeme setkat hned s&nbsp;několika různými typy
matematických koprocesorů. První technologií je <i>FPA (Floating Point
Architecture)</i>. Alternativní a dnes dokonce častěji používanou technologií
je <i>VFP</i>, což je zkratka odvozená od <i>Vector Floating Point</i> (jedná
se o označení, jež je v&nbsp;současnosti možná již poněkud zavádějící).
Technologie <i>VFP</i> byla navržena takovým způsobem, aby ji bylo možné použít
v&nbsp;mnoha aplikačních oblastech, například v&nbsp;řídicích jednotkách
automobilů, pro zpracování obrazu (konvoluční filtry, rychlá Fourierova
transformace, rasterizace a další operace prováděné v&nbsp;tiskových
procesorech), při zpracování řeči (kodeky) a taktéž pro provádění různých 3D
operací (transformace) &ndash; právě v&nbsp;těchto oblastech lze totiž využít
práci nikoli pouze se skalárními hodnotami, ale taktéž s&nbsp;vektory o dvou až
osmi prvcích. Tyto prvky se však zpracovávají postupně, nikoli paralelně.</p>

<p>Matematické koprocesory <i>VFP</i> obecně obsahují šestnáct pracovních
registrů, každý o šířce 64 bitů. Tyto registry lze použít buď pro práci
s&nbsp;hodnotami s&nbsp;dvojitou přesností (<i>double</i>) &ndash; potom se
tyto registry v&nbsp;assembleru označují jmény <strong>d0</strong> až
<strong>d15</strong>. Ovšem taktéž je možné libovolný registr rozdělit na dva
registry o šířce 32 bitů, z&nbsp;nichž každý dokáže pojmout číselnou hodnotu
s&nbsp;jednoduchou přesností (<i>single/float</i>). Díky tomuto rozdělení se
počet registrů pro formát <i>single</i> zvětšil na dvojnásobek &ndash; tyto
registry jsou v&nbsp;assembleru pojmenovány <strong>s0</strong> až
<strong>s31</strong>. Podle konvence dodržované jak překladači, tak i
v&nbsp;programových knihovnách se při volání subrutin používají registry
<strong>d0</strong> až <strong>d7</strong> pro předávání parametrů subrutině,
popř.&nbsp;pro získání návratových hodnot ze subrutiny. Samozřejmě se tyto
registry taktéž používají při výpočtech v&nbsp;subrutině. Ostatní registry lze
taktéž použít, ovšem jejich hodnota by měla být při návratu ze subrutiny
obnovena.</p>

<p>V&nbsp;následující tabulce jsou vypsány základní aritmetické operace:</p>

<table>
<tr><th>#</th><th>Instrukce</th><th>Význam</th><th>Prováděný výpočet</th></tr>
<tr><td> 1</td><td>VADD  Fd, Fn, Fm</td><td>součet</td><td>Fd := Fn + Fm</td></tr>
<tr><td> 2</td><td>VSUB  Fd, Fn, Fm</td><td>rozdíl</td><td>Fd := Fn - Fm</td></tr>
<tr><td> 3</td><td>VNEG  Fd, Fm</td><td>změna znaménka</td><td>Fd := - Fm</td></tr>
<tr><td> 4</td><td>VABS  Fd, Fm</td><td>absolutní hodnota</td><td>Fd := abs(Fm)</td></tr>
<tr><td> 5</td><td>VSQRT Fd, Fm</td><td>druhá odmocnina</td><td>Fd := sqrt(Fm)</td></tr>
<tr><td> 6</td><td>VDIV  Fd, Fn, Fm</td><td>dělení</td><td>Fd := Fn / Fm</td></tr>
<tr><td> 7</td><td>VMUL  Fd, Fn, Fm</td><td>násobení</td><td>Fd := Fn * Fm</td></tr>
<tr><td> 8</td><td>VMLA  Fd, Fn, Fm</td><td>násobení + akumulace</td><td>Fd := Fd + (Fn * Fm)</td></tr>
<tr><td> 9</td><td>VMLS  Fd, Fn, Fm</td><td>odečtení součinu</td><td>Fd := Fd - (Fn * Fm)</td></tr>
<tr><td>10</td><td>VNMUL Fd, Fn, Fm</td><td>násobení + změna znaménka</td><td>Fn := - (Fn * Fm)</td></tr>
<tr><td>11</td><td>VNMLA Fd, Fn, Fm</td><td>kombinace VNMUL a VMLA</td><td>Fd := - Fd - (Fn * Fm)</td></tr>
<tr><td>12</td><td>VNMLS Fd, Fn, Fm</td><td>kombinace VNMUL a VMLS</td><td>Fd := - Fd + (Fn * Fm)</td></tr>
<tr><td>13</td><td>VCMP Fd, Fm</td><td>Porovnání obsahu dvou registrů</td><td>Fd - Fm</td></tr>
<tr><td>14</td><td>VCMP Fd, #0.0</td><td>Porovnání jednoho registru s nulou</td><td>Fd - 0.0</td></tr>
<tr><td>15</td><td>VCVT{C}.F64.F32 Dd, Sm</td><td>Konverze single na double</td></tr>
<tr><td>16</td><td>VCVT{C}.F32.F64 Sd, Dm</td><td>Konverze double na single</td></tr>
<tr><td>17</td><td>VCVT{C}.F32/F64.U32 Fd, Sm</td><td>Konverze unsigned integer na float</td></tr>
<tr><td>18</td><td>VCVT{C}.F32/F64.S32 Fd, Sm</td><td>Konverze signed integer na float</td></tr>
<tr><td>19</td><td>VCVT{R}{C}.U32.F32/F64 Sd, Fm</td><td>Konverze float na unsigned integer</td></tr>
<tr><td>20</td><td>VCVT{R}{C}.S32.F32/F64 Sd, Fm</td><td>Konverze float na signed integer</td></tr>
<tr><td>21</td><td>VCVT.F32/F64.typ Fd, Fd, #bitů</td><td>Konverze fixed-point na float (volitelná pozice tečky)</td></tr>
<tr><td>22</td><td>VCVT.typ.F32/F64 Fd, Fd, #bitů</td><td>Konverze float na fixed-point (volitelná pozice tečky)</td></tr>
<tr><td>23</td><td>VCVTT.F16.F32 Sd,Sm</td><td>Konverze single na half (do horních 16 bitů registru)</td></tr>
<tr><td>24</td><td>VCVTB.F16.F32 Sd,Sm</td><td>Konverze single na half (do spodních 16 bitů registru)</td></tr>
<tr><td>25</td><td>VCVTT.F32.F16 Sd,Sm</td><td>Konverze half na single</td></tr>
<tr><td>26</td><td>VCVTB.F32.F16 Sd,Sm</td><td>Konverze half na single</td></tr>
<tr><td>27</td><td>VMOV.F32/F64 Fd, Fm</td><td>Fd := Fm (prostá kopie)</td></tr>
<tr><td>28</td><td>VMOV Sn, Rd</td><td>Sn := Rd (Rd = registr ARM procesoru)</td></tr>
<tr><td>29</td><td>VMOV Rd, Sn</td><td>Rd := Sn (Rd = registr ARM procesoru)</td></tr>
<tr><td>30</td><td>VMOV Sn, Sm, Rd, Rn</td><td>Sn := Rd, Sm := Rn (kopie dvou registrů)</td></tr>
<tr><td>31</td><td>VMOV Rd, Rn, Sn, Sm</td><td>Rd := Sn, Rn := Sm (kopie dvou registrů)</td></tr>
<tr><td>32</td><td>VMOV Dm, Rd, Rn</td><td>Dm[31:0] := Rd, Dm[63:32] := Rn (pro double jsou zapotřebí dva ARM registry)</td></tr>
<tr><td>33</td><td>VMOV Rd, Rn, Dm</td><td>Rd := Dm[31:0], Rn := Dm[63:32]  (pro double jsou zapotřebí dva ARM registry)</td></tr>
<tr><td>34</td><td>VMOV Dn[0], Rd</td><td>Dn[31:0] := Rd  (pouze spodní polovina double)</td></tr>
<tr><td>35</td><td>VMOV Rd, Dn[0]</td><td>Rd := Dn[31:0]  (pouze spodní polovina double)</td></tr>
<tr><td>36</td><td>VMOV Dn[1], Rd</td><td>Dn[63:32] := Rd  (pouze horní polovina double)</td></tr>
<tr><td>37</td><td>VMOV Rd, Dn[1]</td><td>Rd := Dn[63:32]  (pouze horní polovina double)</td></tr>
<tr><td>38</td><td>VMRS APSR_nzcv, FPSCR</td><td>APSR flags := FPSCR flags (přenos příznaků)</td></tr>
</table>



<p><a name="k19"></a></p>
<h2 id="k19">19. RISC-V</h2>

<p>Otevřená specifikace mikroprocesorů <i>RISC-V</i> umožňuje rozšiřovat
instrukční sadu pomocí standardních rozšíření, z&nbsp;nichž nás dnes bude
zajímat především rozšíření &bdquo;F&ldquo;, &bdquo;D&ldquo; a &bdquo;Q&ldquo;.
První rozšíření se jmenuje &bdquo;F&ldquo;, protože specifikuje instrukce
s&nbsp;hodnotami typu <i>single/float</i>, tj.&nbsp;s&nbsp;čísly
s&nbsp;jednoduchou přesností podle normy IEEE 754-2008 (jedná se o zpřesnění
původní slavné normy IEEE 754). Druhé rozšíření se podle očekávání jmenuje
&bdquo;D&ldquo;, protože předepisuje operace s&nbsp;hodnotami typu
<i>double</i>, tj.&nbsp;s&nbsp;čísly s&nbsp;přesností dvojitou. Třetí rozšíření
nese název &bdquo;Q&ldquo; a je určeno pro instrukce zpracovávající hodnoty se
čtyřnásobnou přesností (<i>quad</i>).</p>

<p>Pro rozšíření &bdquo;F&ldquo; se používá nová sada pracovních registrů. Tyto
registry jsou pojmenovány <strong>f0</strong> až <strong>f31</strong> a každý
z&nbsp;těchto registrů má šířku 32 bitů. Navíc se u většiny operací používá i
stavový a řídicí registr nazvaný <strong>fcrs</strong>. K&nbsp;dispozici jsou
pseudoinstrukce <strong>FRCSR</strong> a <strong>FSCSR</strong> sloužící pro
přenos obsahu stavového a řídicího registru do libovolného pracovního registru
celočíselné části mikroprocesoru (tedy samozřejmě kromě nulového registru).</p>

<p>Podporované instrukce:</p>

<table>
<tr><th> #</th><th>Instrukce</th><th>Význam</th></tr>
<tr><td> 1</td><td>FLW</td><td>načtení FP hodnoty z&nbsp;paměti (adresa rs+offset)</td></tr>
<tr><td> 2</td><td>FSW</td><td>uložení FP hodnoty do paměti (adresa rs+offset)</td></tr>
<tr><td> 3</td><td>FADD.S</td><td>součet dvou FP hodnot (tříadresový kód)</td></tr>
<tr><td> 4</td><td>FSUB.S</td><td>rozdíl dvou FP hodnot</td></tr>
<tr><td> 5</td><td>FMUL.S</td><td>součin dvou FP hodnot</td></tr>
<tr><td> 6</td><td>FDIV.S</td><td>podíl dvou FP hodnot</td></tr>
<tr><td> 7</td><td>FMIN.S</td><td>vrací menší z&nbsp;obou FP hodnot</td></tr>
<tr><td> 8</td><td>FMAX.S</td><td>vrací větší z&nbsp;obou FP hodnot</td></tr>
<tr><td> 9</td><td>FSQRT.S</td><td>druhá odmocnina (použity jsou jen dva registry)</td></tr>
<tr><td>10</td><td>FMADD.S</td><td>rs1&times;rs2+rs3 (multiply-add, čtyřadresový kód!)</td></tr>
<tr><td>11</td><td>FMSUB.S</td><td>rs1&times;rs2-rs3</td></tr>
<tr><td>12</td><td>FNMADD.S</td><td>-(rs1&times;rs2+rs3)</td></tr>
<tr><td>13</td><td>FNMSUB.S</td><td>-(rs1&times;rs2-rs3)</td></tr>
<tr><td>14</td><td>FCVT.W.S</td><td>převod FP na integer</td></tr>
<tr><td>15</td><td>FCVT.S.W</td><td>převod integer na FP</td></tr>
<tr><td>16</td><td>FCVT.WU.S</td><td>převod FP na unsigned integer</td></tr>
<tr><td>17</td><td>FCVT.S.WU</td><td>převod unsigned integer na FP</td></tr>
<tr><td>18</td><td>FMV.X.S</td><td>pouze přesun mezi integer registrem a FP registrem (nikoli konverze)</td></tr>
<tr><td>19</td><td>FMV.S.X</td><td>pouze přesun mezi FP registrem a integer registrem (nikoli konverze)</td></tr>
<tr><td>20</td><td>FLT.S</td><td>porovnání dvou FP hodnot, zápis 0 či 1 do integer registru</td></tr>
<tr><td>21</td><td>FLE.S</td><td>porovnání dvou FP hodnot, zápis 0 či 1 do integer registru</td></tr>
<tr><td>22</td><td>FEQ.S</td><td>porovnání dvou FP hodnot, zápis 0 či 1 do integer registru</td></tr>
<tr><td>21</td><td>FCLASS</td><td>zjistí &bdquo;třídu&ldquo; FP hodnoty a nastaví deset bitů podle následující tabulky</td></tr>
<tr><td>22</td><td>FSGNJ.S </td><td>kopie z&nbsp;registru <i>src1</i> do <i>dest</i>, ovšem kromě znaménka; to je přečteno ze <i>src2</i></td></tr>
<tr><td>23</td><td>FSGNJN.S</td><td>kopie z&nbsp;registru <i>src1</i> do <i>dest</i>, ovšem kromě znaménka; to je přečteno ze <i>src2</i> a znegováno</td></tr>
<tr><td>24</td><td>FSGNJX.S</td><td>kopie z&nbsp;registru <i>src1</i> do <i>dest</i>, ovšem kromě znaménka; to je získáno ze <i>src1</i> i <i>src2</i> s&nbsp;využitím operace XOR</td></tr>
</table>

<p>Další rozšíření základní instrukční sady nese označení &bdquo;D&ldquo;.
Pokud mikroprocesor s&nbsp;architekturou RISC-V podporuje tuto instrukční sadu,
budou použity registry pojmenované <strong>f0</strong> až <strong>f31</strong>,
což jsou stejně pojmenované registry, jaké již známe z&nbsp;rozšíření
&bdquo;F&ldquo;. Je zde ovšem jeden podstatný rozdíl &ndash; nyní budou mít
registry šířku 64 bitů a nikoli pouze 32 bitů. I instrukční sady
&bdquo;F&ldquo; a &bdquo;D&ldquo; jsou si v&nbsp;mnoha ohledech podobné, i když
zde narazíme na některé pochopitelné rozdíly:</p>

<table>
<tr><th> #</th><th>Instrukce</th><th>Význam</th></tr>
<tr><td>1</td><td>FLD</td><td>načtení FP hodnoty z&nbsp;paměti (adresa rs+offset)</td></tr>
<tr><td>2</td><td>FSD</td><td>uložení FP hodnoty do paměti (adresa rs+offset)</td></tr>
<tr><td>3</td><td>FADD.D</td><td>součet dvou FP hodnot (tříadresový kód)</td></tr>
<tr><td>4</td><td>FSUB.D</td><td>rozdíl dvou FP hodnot</td></tr>
<tr><td>5</td><td>FMUL.D</td><td>součin dvou FP hodnot</td></tr>
<tr><td>6</td><td>FDIV.D</td><td>podíl dvou FP hodnot</td></tr>
<tr><td>7</td><td>FMIN.D</td><td>vrací menší z&nbsp;obou FP hodnot</td></tr>
<tr><td>8</td><td>FMAX.D</td><td>vrací větší z&nbsp;obou FP hodnot</td></tr>
<tr><td>9</td><td>FSQRT.D</td><td>druhá odmocnina (použity jsou jen dva registry)</td></tr>
<tr><td>10</td><td>FCVT.S.D</td><td>double na single (provádí se zaokrouhlení)</td></tr>
<tr><td>11</td><td>FCVT.D.S</td><td>single na double (hodnota se nezmění)</td></tr>
<tr><td>12</td><td>FCVT.W.D</td><td>double &rarr; 32bit signed integer</td></tr>
<tr><td>13</td><td>FCVT.L.D</td><td>double &rarr; 64bit signed integer</td></tr>
<tr><td>14</td><td>FCVT.WU.D</td><td>double &rarr; 32bit unsigned integer</td></tr>
<tr><td>15</td><td>FCVT.LU.D</td><td>double &rarr; 64bit unsigned integer</td></tr>
<tr><td>16</td><td>FCVT.D.W</td><td>32bit signed integer &rarr; double</td></tr>
<tr><td>17</td><td>FCVT.D.L</td><td>64bit signed integer &rarr; double</td></tr>
<tr><td>18</td><td>FCVT.D.WU</td><td>32bit unsigned integer &rarr; double</td></tr>
<tr><td>19</td><td>FCVT.D.LU</td><td>64bit unsigned integer &rarr; double</td></tr>
<tr><td>20</td><td>FSGNJ.D </td><td>kopie z&nbsp;registru <i>src1</i> do <i>dest</i>, ovšem kromě znaménka; to je přečteno ze <i>src2</i></td></tr>
<tr><td>21</td><td>FSGNJN.D</td><td>kopie z&nbsp;registru <i>src1</i> do <i>dest</i>, ovšem kromě znaménka; to je přečteno ze <i>src2</i> a znegováno</td></tr>
<tr><td>22</td><td>FSGNJX.D</td><td>kopie z&nbsp;registru <i>src1</i> do <i>dest</i>, ovšem kromě znaménka; to je získáno ze <i>src1</i> i <i>src2</i> s&nbsp;využitím operace XOR</td></tr>
<tr><td>23</td><td>FMV.X.D</td><td>pouze přesun mezi integer registrem a FP registrem (nikoli konverze)</td></tr>
<tr><td>24</td><td>FMV.D.X</td><td>pouze přesun mezi FP registrem a integer registrem (nikoli konverze)</td></tr>
</table>

<p>Dalším rozšířením instrukčních sad je rozšíření označené písmenem
&bdquo;Q&ldquo;. To přidává možnost práce s&nbsp;numerickými hodnotami
s&nbsp;plovoucí řádovou čárkou se čtyřnásobnou přesností. Formát uložení těchto
hodnot je specifikován v&nbsp;již několikrát zmíněné normě <i>IEEE
754-2008</i>:</p>

<table>
<tr><th>#</th><th>Instrukce</th><th>Význam</th></tr>
<tr><td>1</td><td>FLQ</td><td>načtení FP hodnoty z&nbsp;paměti (adresa rs+offset)</td></tr>
<tr><td>2</td><td>FSQ</td><td>uložení FP hodnoty do paměti (adresa rs+offset)</td></tr>
<tr><td>3</td><td>FADD.Q</td><td>součet dvou FP hodnot (tříadresový kód)</td></tr>
<tr><td>4</td><td>FSUB.Q</td><td>rozdíl dvou FP hodnot</td></tr>
<tr><td>5</td><td>FMUL.Q</td><td>součin dvou FP hodnot</td></tr>
<tr><td>6</td><td>FDIV.Q</td><td>podíl dvou FP hodnot</td></tr>
<tr><td>7</td><td>FMIN.Q</td><td>vrací menší z&nbsp;obou FP hodnot</td></tr>
<tr><td>8</td><td>FMAX.Q</td><td>vrací větší z&nbsp;obou FP hodnot</td></tr>
<tr><td>9</td><td>FSQRT.Q</td><td>druhá odmocnina (použity jsou jen dva registry)</td></tr>
<tr><td>10</td><td>FCVT.S.Q</td><td>quadruple &rarr; single</td></tr>
<tr><td>11</td><td>FCVT.Q.S</td><td>single &rarr; quadruple</td></tr>
<tr><td>12</td><td>FCVT.D.Q</td><td>quadruple &rarr; double</td></tr>
<tr><td>13</td><td>FCVT.Q.D</td><td>double &rarr; quadruple</td></tr>
<tr><td>14</td><td>FSGNJ.Q </td><td>kopie z&nbsp;registru <i>src1</i> do <i>dest</i>, ovšem kromě znaménka; to je přečteno ze <i>src2</i></td></tr>
<tr><td>15</td><td>FSGNJN.Q</td><td>kopie z&nbsp;registru <i>src1</i> do <i>dest</i>, ovšem kromě znaménka; to je přečteno ze <i>src2</i> a znegováno</td></tr>
<tr><td>16</td><td>FSGNJX.Q</td><td>kopie z&nbsp;registru <i>src1</i> do <i>dest</i>, ovšem kromě znaménka; to je získáno ze <i>src1</i> i <i>src2</i> s&nbsp;využitím operace XOR</td></tr>
</table>



<p><a name="k20"></a></p>
<h2 id="k20">20. Odkazy na Internetu</h2>

<ol>

<li>SH7201 Group User's Manual: Hardware<br />
<a href="https://www.renesas.com/en-us/document/hw-manual?hwLayerShowFlg=true&amp;prdLayerId=2038&amp;layerName=SH7201&amp;coronrService=document-prd-search&amp;hwDocUrl=%2Fen-us%2Fdoc%2Fproducts%2Fmpumcu%2Fdoc%2Fsuperh%2Fr01uh0026ej_sh7201_hm.pdf&amp;hashKey=4d1ed116961466babf99bc7cf1d2cdec">https://www.renesas.com/en-us/document/hw-manual?hwLayerShowFlg=true&amp;prdLayerId=2038&amp;layerName=SH7201&amp;coronrService=document-prd-search&amp;hwDocUrl=%2Fen-us%2Fdoc%2Fproducts%2Fmpumcu%2Fdoc%2Fsuperh%2Fr01uh0026ej_sh7201_hm.pdf&amp;hashKey=4d1ed116961466babf99bc7cf1d2cdec</a>
</li>

<li>SH7203 Group User's Manual: Hardware<br />
<a href="https://www.renesas.com/en-us/document/hw-manual?hwLayerShowFlg=true&amp;prdLayerId=2126&amp;layerName=SH7203&amp;coronrService=document-prd-search&amp;hwDocUrl=%2Fen-us%2Fdoc%2Fproducts%2Fmpumcu%2F001%2Fr01uh0458ej0400_sh7203.pdf&amp;hashKey=68baf3ad6c52e9e2616e44024589e8cf">https://www.renesas.com/en-us/document/hw-manual?hwLayerShowFlg=true&amp;prdLayerId=2126&amp;layerName=SH7203&amp;coronrService=document-prd-search&amp;hwDocUrl=%2Fen-us%2Fdoc%2Fproducts%2Fmpumcu%2F001%2Fr01uh0458ej0400_sh7203.pdf&amp;hashKey=68baf3ad6c52e9e2616e44024589e8cf</a>
</li>

<li>SuperH RISC engine Family Features<br />
<a href="https://www.renesas.com/en-us/products/microcontrollers-microprocessors/superh/superh-features.html">https://www.renesas.com/en-us/products/microcontrollers-microprocessors/superh/superh-features.html</a>
</li>

<li>Konkurence procesorů s mikroprogramovým řadičem - RISC<br />
<a href="http://www.root.cz/clanky/konkurence-procesoru-s-mikroprogramovym-radicem-architektura-risc/">http://www.root.cz/clanky/konkurence-procesoru-s-mikroprogramovym-radicem-architektura-risc/</a>
</li>

<li>Mikroprocesory s architekturou RISC I<br />
<a href="http://www.root.cz/clanky/mikroprocesory-s-architekturou-risc-i/">http://www.root.cz/clanky/mikroprocesory-s-architekturou-risc-i/</a>
</li>

<li>Procesory RISC v pracovních stanicích a serverech<br />
<a href="http://www.root.cz/clanky/procesory-s-architekturou-risc-v-pracovnich-stanicich-a-serverech/">http://www.root.cz/clanky/procesory-s-architekturou-risc-v-pracovnich-stanicich-a-serverech/</a>
</li>

<li>Procesory RISC v pracovních stanicích a serverech - architektura SPARC V8 a<br />
<a href="http://www.root.cz/clanky/procesory-risc-v-pracovnich-stanicich-a-serverech-architektura-sparc-v8-a-v9/">http://www.root.cz/clanky/procesory-risc-v-pracovnich-stanicich-a-serverech-architektura-sparc-v8-a-v9/</a>
</li>

<li>Procesory RISC v pracovních stanicích a serverech - architektura PA-RISC<br />
<a href="http://www.root.cz/clanky/procesory-risc-v-pracovnich-stanicich-a-serverech-architektura-pa-risc/">http://www.root.cz/clanky/procesory-risc-v-pracovnich-stanicich-a-serverech-architektura-pa-risc/</a>
</li>

<li>Rozšíření instrukční sady procesorových jader s otevřenou architekturou RISC-V<br />
<a href="http://www.root.cz/clanky/rozsireni-instrukcni-sady-procesorovych-jader-s-otevrenou-architekturou-risc-v/">http://www.root.cz/clanky/rozsireni-instrukcni-sady-procesorovych-jader-s-otevrenou-architekturou-risc-v/</a>
</li>

<li>Sega documentation<br />
<a
href="http://koti.kapsi.fi/~antime/sega/docs.html">http://koti.kapsi.fi/~antime/sega/docs.html</a>
</li>

<li>1995 Programming on the Sega Saturn<br />
<a
href="http://cowboyprogramming.com/2010/06/03/1995-programming-on-the-sega-saturn/">http://cowboyprogramming.com/2010/06/03/1995-programming-on-the-sega-saturn/</a>
</li>

<li>Sega Myths-Saturn was the most difficult console to program for of 5th Gen<br />
<a href="http://forums.sega.com/showthread.php?313485-Sega-Myths-Saturn-was-the-most-difficult-console-to-program-for-of-5th-Gen">http://forums.sega.com/showthread.php?313485-Sega-Myths-Saturn-was-the-most-difficult-console-to-program-for-of-5th-Gen</a>
</li>

<li>SuperH RISC engine Family<br />
<a href="http://www.renesas.com/products/mpumcu/superh/index.jsp">http://www.renesas.com/products/mpumcu/superh/index.jsp</a>
</li>

<li>Sega Saturn<br />
<a href="http://en.wikipedia.org/wiki/Sega_saturn">http://en.wikipedia.org/wiki/Sega_saturn</a>
</li>

<li>Fourth-Generation Consoles<br />
<a href="http://gaming.wikia.com/wiki/Fourth-Generation_Consoles">http://gaming.wikia.com/wiki/Fourth-Generation_Consoles</a>
</li>

<li>Fifth-Generation Consoles<br />
<a href="http://gaming.wikia.com/wiki/Fifth-Generation_Consoles">http://gaming.wikia.com/wiki/Fifth-Generation_Consoles</a>
</li>

<li>History of video game consoles (fifth generation)<br />
<a href="http://en.wikipedia.org/wiki/History_of_video_game_consoles_(fifth_generation)">http://en.wikipedia.org/wiki/History_of_video_game_consoles_(fifth_generation)</a>
</li>

<li>Sega Mega Drive<br />
<a href="http://sega.jp/archive/segahard/md/">http://sega.jp/archive/segahard/md/</a>
</li>

<li>Sega Archives<br />
<a href="http://sega.jp/archive/segahard/">http://sega.jp/archive/segahard/</a>
</li>

<li>Sega Genesis<br />
<a href="http://www.dmoz.org/Games/Video_Games/Console_Platforms/Sega/Genesis/">http://www.dmoz.org/Games/Video_Games/Console_Platforms/Sega/Genesis/</a>
</li>

<li>The Sega Mega Drive/Genesis<br />
<a href="http://www.captainwilliams.co.uk/sega/megadrive/megadrive.php">http://www.captainwilliams.co.uk/sega/megadrive/megadrive.php</a>
</li>

<li>Sega Master System Museum<br />
<a href="http://alexkidd.com/">http://alexkidd.com/</a>
</li>

<li>Jadeite's Sega Master System Museum<br />
<a href="http://rp_gamer.tripod.com/SMS/1.html">http://rp_gamer.tripod.com/SMS/1.html</a>
</li>

<li>Sega Master System (Wikipedia)<br />
<a href="http://en.wikipedia.org/wiki/Sega_Master_System">http://en.wikipedia.org/wiki/Sega_Master_System</a>
</li>

<li>Sega Card (Wikipedia)<br />
<a href="http://en.wikipedia.org/wiki/Sega_Card">http://en.wikipedia.org/wiki/Sega_Card</a>
</li>

<li>Sega Master System VDP documentation<br />
<a href="http://www.smspower.org/uploads/Development/msvdp-20021112.txt?sid=28c370e1fcac51d5774319979bf96f4c">http://www.smspower.org/uploads/Development/msvdp-20021112.txt?sid=28c370e1fcac51d5774319979bf96f4c</a>
</li>

<li>The16bit Era Of Console Video Games<br />
<a href="http://tvtropes.org/pmwiki/pmwiki.php/Main/The16bitEraOfConsoleVideoGames">http://tvtropes.org/pmwiki/pmwiki.php/Main/The16bitEraOfConsoleVideoGames</a>
</li>

<li>The Console Wars<br />
<a href="http://www.cracked.com/funny-2590-the-console-wars/">http://www.cracked.com/funny-2590-the-console-wars/</a>
</li>

<li>Console Wars<br />
<a href="http://tvtropes.org/pmwiki/pmwiki.php/Main/ConsoleWars">http://tvtropes.org/pmwiki/pmwiki.php/Main/ConsoleWars</a>
</li>

<li>Era of the "Bit Wars"<br />
<a href="http://www.gtplanet.net/forum/threads/era-of-the-bit-wars.119796/">http://www.gtplanet.net/forum/threads/era-of-the-bit-wars.119796/</a>
</li>

<li>Rez Wars: How the Bit Wars never really ended<br />
<a href="http://www.ign.com/blogs/beastmastertoad/2013/01/31/rez-wars-how-the-bit-wars-never-really-ended">http://www.ign.com/blogs/beastmastertoad/2013/01/31/rez-wars-how-the-bit-wars-never-really-ended</a>
</li>

<li>Which system ended the "Bit Wars"?<br />
<a href="http://atariage.com/forums/topic/199163-which-system-ended-the-bit-wars/">http://atariage.com/forums/topic/199163-which-system-ended-the-bit-wars/</a>
</li>

<li>Status Register<br />
<a href="https://en.wikipedia.org/wiki/Status_register">https://en.wikipedia.org/wiki/Status_register</a>
</li>

<li>Introduction to ARM Thumb<br />
<a href="http://www.embedded.com/electronics-blogs/beginner-s-corner/4024632/Introduction-to-ARM-thumb">http://www.embedded.com/electronics-blogs/beginner-s-corner/4024632/Introduction-to-ARM-thumb</a>
</li>

<li>Code Size – a comprehensive comparison of microMIPS32 and Thumb code size using many Megabytes of customer code<br />
<a href="https://community.arm.com/groups/processors/blog/2014/04/28/code-size-a-comprehensive-comparison-of-micromips32-and-thumb-code-size-using-many-megabytes-of-customer-code">https://community.arm.com/groups/processors/blog/2014/04/28/code-size-a-comprehensive-comparison-of-micromips32-and-thumb-code-size-using-many-megabytes-of-customer-code</a>
</li>

<li>MIPS MCUs Outrun ARM<br />
<a href="http://www.linleygroup.com/newsletters/newsletter_detail.php?num=5117">http://www.linleygroup.com/newsletters/newsletter_detail.php?num=5117</a>
</li>

<li>Carry bits, The Architect's Trap<br />
<a href="http://yarchive.net/comp/carry_bit.html">http://yarchive.net/comp/carry_bit.html</a>
</li>

<li>Microprocessor Design/ALU Flags<br />
<a href="https://en.wikibooks.org/wiki/Microprocessor_Design/ALU_Flags">https://en.wikibooks.org/wiki/Microprocessor_Design/ALU_Flags</a>
</li>

<li>Flags register in an out-of-order processor<br />
<a href="http://cs.stackexchange.com/questions/42095/flags-register-in-an-out-of-order-processor">http://cs.stackexchange.com/questions/42095/flags-register-in-an-out-of-order-processor</a>
</li>

<li>Berkeley RISC<br />
<a href="http://en.wikipedia.org/wiki/Berkeley_RISC">http://en.wikipedia.org/wiki/Berkeley_RISC</a>
</li>

<li>Great moments in microprocessor history<br />
<a href="http://www.ibm.com/developerworks/library/pa-microhist.html">http://www.ibm.com/developerworks/library/pa-microhist.html</a>
</li>

<li>RISC vs. CISC<br />
<a href="http://www-cs-faculty.stanford.edu/~eroberts/courses/soco/projects/2000-01/risc/risccisc/">http://www-cs-faculty.stanford.edu/~eroberts/courses/soco/projects/2000-01/risc/risccisc/</a>
</li>

<li>RISC and CISC definitions:<br />
<a href="http://www.cpushack.com/CPU/cpuAppendA.html">http://www.cpushack.com/CPU/cpuAppendA.html</a>
</li>

<li>The Evolution of RISC<br />
<a href="http://www.ibm.com/developerworks/library/pa-microhist.html#sidebar1">http://www.ibm.com/developerworks/library/pa-microhist.html#sidebar1</a>
</li>

<li>The VFP architecture<br />
<a href="http://infocenter.arm.com/help/index.jsp?topic=/com.arm.doc.dui0056d/Bcfibfha.html">http://infocenter.arm.com/help/index.jsp?topic=/com.arm.doc.dui0056d/Bcfibfha.html</a>
</li>

<li>NEON<br />
<a href="http://www.arm.com/products/processors/technologies/neon.php">http://www.arm.com/products/processors/technologies/neon.php</a>
</li>

<li>ARM Floating Point Accelerator (ARM FPA)<br />
<a href="http://vswww.kaist.ac.kr/ver4.0/index.php/research/past-research/arm-fpa.html">http://vswww.kaist.ac.kr/ver4.0/index.php/research/past-research/arm-fpa.html</a>
</li>

</ol>



<p></p><p></p>
<p><small>Autor: <a href="http://www.fit.vutbr.cz/~tisnovpa">Pavel Tišnovský</a> &nbsp; 2016</small></p>
</body>
</html>

