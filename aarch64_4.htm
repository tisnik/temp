<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
        "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html>
<head>
<title>Programování v assembleru mikroprocesorů AArch64</title>
<meta name="Author" content="Pavel Tisnovsky" />
<meta name="Generator" content="vim" />
<meta http-equiv="content-type" content="text/html; charset=utf-8" />
<style type="text/css">
         body {color:#000000; background:#ffffff;}
         h1  {font-family: arial, helvetica, sans-serif; color:#ffffff; background-color:#c00000; text-align:center; padding-left:1em}
         h2  {font-family: arial, helvetica, sans-serif; color:#ffffff; background-color:#0000c0; padding-left:1em; text-align:left}
         h3  {font-family: arial, helvetica, sans-serif; color:#000000; background-color:#c0c0c0; padding-left:1em; text-align:left}
         h4  {font-family: arial, helvetica, sans-serif; color:#000000; background-color:#e0e0e0; padding-left:1em; text-align:left}
         a   {font-family: arial, helvetica, sans-serif;}
         li  {font-family: arial, helvetica, sans-serif; color:#000000; text-align:justify; width:450px;}
         ol  {font-family: arial, helvetica, sans-serif; color:#000000; text-align:justify; width:450px;}
         ul  {font-family: arial, helvetica, sans-serif; color:#000000; text-align:justify; width:450px;}
         p   {font-family: arial, helvetica, sans-serif; color:#000000; text-align:justify;}
         pre {background:#e0e0e0}
</style>
</head>

<body>

<h1>Programování v assembleru mikroprocesorů AArch64</h1>

<h3>Pavel Tišnovský</h3>

<p></p>

<h1>Úvodník</h1>

<p>Vzhledem k tomu, že se se 64bitovými mikroprocesory AArch64 setkáváme stále častěji, budeme se v dnešní části seriálu o architekturách počítačů věnovat způsobu programování těchto čipů s využitím GNU Assembleru, linkeru a taktéž GNU Debuggeru s nadstavbou cgdb.</p>



<h2>Obsah</h2>

<p><a href="#k01">1. Programování v&nbsp;assembleru mikroprocesorů AArch64</a></p>
<p><a href="#k02">2. GNU Debugger</a></p>
<p><a href="#k03">*** 3. Složitější příklad: programová smyčka a výpis textu na standardní výstup</a></p>
<p><a href="#k04">4. Překlad a slinkování programu s&nbsp;ladicími symboly i bez ladicích symbolů</a></p>
<p><a href="#k05">5. Překlad se současným výpisem vygenerovaného kódu</a></p>
<p><a href="#k06">6. Informace o spustitelném souboru vypsané nástrojem <i>objdump</i></a></p>
<p><a href="#k07">7. Použití nástroje <i>strace</i></a></p>
<p><a href="#k08">8. Ladění v&nbsp;GNU Debuggeru</a></p>
<p><a href="#k09">9. Spuštění a krokování programu, nastavení breakpointu</a></p>
<p><a href="#k10">10. Zobrazení základních informací o laděném procesu</a></p>
<p><a href="#k11">11. Použití příkazu <strong>display</strong> a <strong>print</strong></a></p>
<p><a href="#k12">12. Použití příkazu <strong>examine</strong> pro prohlížení obsahu paměti</a></p>
<p><a href="#k13">13. Watchpointy</a></p>
<p><a href="#k14">14. Breakpointy s&nbsp;podmínkou</a></p>
<p><a href="#k15">15. Specifikace příkazů vykonaných při vstupu na breakpoint</a></p>
<p><a href="#k16">16. Vzdálené ladění přes <strong>gdbserver</strong></a></p>
<p><a href="#k17">*** 17. TUI &ndash; textové uživatelské rozhraní GNU debuggeru</a></p>
<p><a href="#k18">18. Použití nadstavby nad GNU debuggerem nazvané cgdb</a></p>
<p><a href="#k19">19. Odkazy na Internetu</a></p>



<p><a name="k01"></a></p>
<h2 id="k01">1. Programování v&nbsp;assembleru mikroprocesorů AArch64</h2>

<p>V&nbsp;dnešní části seriálu o architekturách počítačů volně navážeme na <a
href="https://www.root.cz/clanky/instrukcni-sada-aarch64-2-cast/#k13">konec
předchozího článku</a>, v&nbsp;němž jsme si ukázali velmi jednoduchou aplikaci
naprogramovanou v&nbsp;assembleru 64bitových mikroprocesorů AArch64. Dnes si
popíšeme, jak lze trasovat a ladit poněkud složitější aplikaci, což mimochodem
znamená, že navážeme na <a
href="https://www.root.cz/serialy/trasovani-a-ladeni-nativnich-aplikaci-v-linuxu/">starší
miniseriál</a>, ve kterém jsme se věnovali podobnému tématu, ovšem nikoli
s&nbsp;ohledem na AArch64. Poznámka: budeme sice používat nástroje GNU
Assembler, GNU Linker, GNU Debugger a taktéž doplňkové nástroje gdbserver a
cgdb, což však v&nbsp;žádném případě neznamená, že pro AArch64 neexistují <a
href="https://developer.arm.com/products/software-development-tools">komerční
varianty</a>.</p>



<p><a name="k02"></a></p>
<h2 id="k02">2. GNU Debugger</h2>

<p>Kromě komerčních nástrojů je možné i pro 64bitové mikroprocesory AArch64
použít <i>GNU Debugger</i> neboli <i>GDB</i>, jehož první verze vznikla již
v&nbsp;roce 1986, takže se po více než třiceti letech kontinuálního vývoje
jedná o velmi vyzrálý produkt v&nbsp;typickém Unixovém stylu &ndash; rozsáhlá
funkcionalita je skryta za zpočátku těžko ovladatelné uživatelské rozhraní.
<i>GNU Debugger</i> byl v&nbsp;průběhu svého vývoje portován jak na mnoho
operačních systémů (většinou na různé komerční i nekomerční varianty Unixu,
ovšem nalezneme ho například i v&nbsp;systému DOS), tak i na nepřeberné
množství procesorových a mikroprocesorových architektur, z&nbsp;nichž jmenujme
především řadu x86, x86_64, ARM (prakticky všechny 32bitové CPU i nová 64bitová
jádra &ndash; což je ostatně přesně téma, které nás dnes zajímá), Motorola
68HC11, MIPS či PowerPC.</p>

<p>Tento debugger podporuje všechny překladače z&nbsp;rodiny GNU, což
mj.&nbsp;znamená, že dokáže zobrazit a pracovat se zdrojovými kódy
v&nbsp;jazycích Ada, C, C++, Go, Objective-C, D, Fortran, Modula-2, Pascal a
Java (ovšem jen v&nbsp;případě překladu Javy do nativního kódu). Na základě
jazyka, v&nbsp;němž je laděný program napsán, se upravují i zprávy <i>GNU
Debuggeru</i>, takže se například používá správný formát hexadecimálních čísel,
struktur záznamů atd. Taktéž assemblery používané na Linuxu <i>GNU Debugger</i>
přímo podporují (jedná se jak o <strong>as</strong>, tak i o
<strong>NASM</strong> &ndash; druhý jmenovaný assembler však pro AArch64
neexistuje). Ladicí nástroj <i>GNU Debugger</i> primárně používá ke komunikaci
s&nbsp;uživatelem příkazový řádek, alternativně lze použít i protokol pro
nepřímé ovládání debuggeru (tuto technologii používají různé nadstavby nad
debuggerem) a v&nbsp;případě potřeby je možné k&nbsp;laděné aplikaci přidat
relativně krátký &bdquo;stub&ldquo; sloužící pro přímé ladění takové
aplikace. <a href="#k16">Podporováno je i vzdálené ladění</a>.</p>

<p>Většina často používaných příkazů má i svoji zkrácenou podobu
(<i>bt=backtrace</i>, <i>c=continue</i>, <i>f=frame</i>) a navíc je možné
používat klávesu [Tab] pro automatické doplnění celého jména příkazu. Pokud je
správně nastavený terminál, bude fungovat i historie příkazového řádku, a to
stejným způsobem, jaký známe ze shellu. Alternativně je možné využít
<strong>gdbtui</strong> <a href="#k17">s&nbsp;celoobrazovkovým výstupem</a> a
přiblížit se tak (i když jen částečně) možnostem debuggerů s&nbsp;plnohodnotným
grafickým uživatelským rozhraním. Pokud se <i>GNU Debugger</i> používá pro
trasování, lze do kódu vkládat takzvané <i>tracepoints</i>. Ty slouží pro
zjištění stavu programu v&nbsp;nějakém specifikovaném bodu, ovšem bez
(po)zastavení programu. Samotné pozastavení programu totiž může
v&nbsp;některých případech způsobit jeho chybnou činnost či naopak zastínit
některé chyby vyplývající ze špatně implementované synchronizace vláken či při
přístupu ke sdíleným prostředkům. Podpora tracepointů však prozatím pro <a
href="https://www.slideshare.net/linaroorg/bkk16304-the-state-of-gdb-on-aarch64">AArch64
není implementována</a>.</p>

<p>Všechny příkazy GNU Debuggeru jsou popsány v&nbsp;rozsáhlé nápovědě dostupné
přímo z&nbsp;příkazového řádku:</p>

<pre>
(gdb) <strong>help</strong>
List of classes of commands:
&nbsp;
aliases -- Aliases of other commands
breakpoints -- Making program stop at certain points
data -- Examining data
files -- Specifying and examining files
internals -- Maintenance commands
obscure -- Obscure features
running -- Running the program
stack -- Examining the stack
status -- Status inquiries
support -- Support facilities
tracepoints -- Tracing of program execution without stopping the program
user-defined -- User-defined commands
&nbsp;
Type "help" followed by a class name for a list of commands in
that class.
Type "help all" for the list of all commands.
Type "help" followed by command name for full documentation.
Type "apropos word" to search for commands related to "word".
Command name abbreviations are allowed if unambiguous.
</pre>

<p>V&nbsp;seznamu zobrazeném pod tímto odstavcem jsou zmíněny vybrané základní
operace, které je možné v&nbsp;GNU Debuggeru provádět:</p>

<ol>

<li>Ladění přeloženého programu (spuštění procesu přímo z&nbsp;debuggeru),
připojení debuggeru k&nbsp;běžícímu procesu, analýza core dumpu.</li>

<li>Spuštění (<i>run</i>), pozastavení a znovuspuštění laděného programu
(<i>continue</i>). Prakticky tytéž operace je možné provádět
s&nbsp;jednotlivými vlákny.</li>

<li>Krokování programu, přičemž se vývojář může rozhodnout, jestli se mají
volané funkce provést v&nbsp;jednom kroku (<i>step over</i>) či zda se naopak
má přejít i dovnitř těchto funkcí (<i>step into</i>).</li>

<li>Nastavení <i>breakpointů</i> i breakpointů s&nbsp;podmínkou,
tj.&nbsp;breakpointů, které začnou být aktivní až ve chvíli, kdy dojde ke
splnění zadané podmínky (vhodné například při sledování chování programových
smyček či rekurzivních algoritmů).</li>

<li>Nastavení takzvaných <i>watchpointů</i>. Jedná se o speciální případ
breakpointů; program se zastaví ve chvíli, kdy dojde ke změně zadaného výrazu,
v&nbsp;nejjednodušším případě ke změně hodnoty nějaké proměnné
(popř.&nbsp;místa v&nbsp;paměti). Alternativně lze watchpoint nastavit pro
detekci čtení z&nbsp;proměnné. To se samozřejmě týká i položek v&nbsp;záznamech
(record) či prvků polí.</li>

<li>Podpora <i>tracepointů</i>. Zjednodušeně řečeno je možné říci, že
tracepointy slouží pro zjištění stavu programu v&nbsp;nějakém specifikovaném
bodu, ovšem bez (po)zastavení programu. Samotné pozastavení programu totiž může
v&nbsp;některých případech způsobit jeho chybnou činnost či naopak zastínit
některé chyby vyplývající ze špatně implementované synchronizace vláken či při
přístupu ke sdíleným prostředkům. Tracepointy však v&nbsp;současnosti nelze na
Aarch64 použít.</li>

<li>Výpis obsahu zásobníkových rámců (<i>backtrace</i>) a tím pádem i zjištění
historie volaných funkcí (včetně informací o předaných parametrech).</li>

<li>Prohlížení obsahu paměti, k&nbsp;čemuž slouží výkonný příkaz <i>print</i> a
<i>examine</i>, jimž je možné zadat mnohdy i velmi komplikovaný výraz, jehož
výsledek se vypíše na standardní výstup. Lze kombinovat s&nbsp;krokováním.</li>

</ol>



<p><a name="k03"></a></p>
<h2 id="k03">3. Složitější příklad: programová smyčka a výpis textu na standardní výstup</h2>

<pre>
# asmsyntax=as

# Demonstracni priklad naprogramovany v assembleru GNU as
# - pocitana programova smycka realizovana instrukci CBNZ
# - uprava pro mikroprocesory s architekturou AArch64
#
# Autor: Pavel Tisnovsky



# Linux kernel system call table
sys_exit   = 93
sys_write  = 64

# List of syscalls for AArch64:
# https://github.com/torvalds/linux/blob/master/include/uapi/asm-generic/unistd.h

# Dalsi konstanty pouzite v programu - standardni streamy
std_input  = 0
std_output = 1

# pocet opakovani znaku
rep_count  = 40



#-----------------------------------------------------------------------------
.section .data



#-----------------------------------------------------------------------------
.section .bss
        .lcomm buffer, rep_count     // rezervace bufferu pro vystup



#-----------------------------------------------------------------------------
.section .text
        .global _start               // tento symbol ma byt dostupny i linkeru

_start:
        ldr   x1, =buffer            // zapis se bude provadet do tohoto bufferu
        mov   x2, #rep_count         // pocet opakovani znaku
        mov   w3, #'*'               // zapisovany znak
loop:
        strb  w3, [x1]               // zapis znaku do bufferu
        add   x1, x1, #1             // uprava ukazatele do bufferu
        sub   x2, x2, #1             // zmenseni pocitadla a soucasne nastaveni priznaku
        cbnz  x2, loop               // pokud jsme se nedostali k nule, skok na zacatek smycky

        mov   x8, #sys_write         // cislo syscallu pro funkci "write"
        mov   x0, #std_output        // standardni vystup
        ldr   x1, =buffer            // adresa retezce, ktery se ma vytisknout
        mov   x2, #rep_count         // pocet znaku, ktere se maji vytisknout
        svc   0                      // volani Linuxoveho kernelu

        mov   x8, #sys_exit          // cislo sycallu pro funkci "exit"
        mov   x0, #0                 // exit code = 0
        svc   0                      // volani Linuxoveho kernelu

</pre>



<p><a name="k04"></a></p>
<h2 id="k04">4. Překlad a slinkování programu s&nbsp;ladicími symboly i bez ladicích symbolů</h2>

<p>Tato kapitola bude velmi stručná, protože si v&nbsp;ní jen řekneme, že pokud
vyžadujeme překlad výsledné verze aplikace bez ladicích informací, postačuje
zavolat <strong>as</strong> (GNU Assembler) pouze s&nbsp;parametrem
<strong>-o</strong> a specifikací jména výsledného objektového souboru. Naproti
tomu při volání linkeru použijeme parametr <strong>-s</strong> nebo jeho
dlouhou variantu <strong>--strip-all</strong>, díky níž nebude výsledný
spustitelný soubor obsahovat žádné informace o symbolech:</p>

<pre>
as loop-aarch64.s -o loop-aarch64.o
ld -s loop-aarch64.o
</pre>

<p>Pokud je naopak nutné ladicí informace zachovat, například pro potřeby
ladění, musí se při volání GNU Assembleru použít volba <strong>-g</strong> nebo
její delší varianta <strong>--gen-debug</strong>. Taktéž nezapomeňte na
odstranění přepínače <strong>-s</strong> při volání linkeru, protože
v&nbsp;opačném případě by se všechny ladicí informace sice přidaly do
objektového souboru, ale ve výsledném spustitelném souboru by již nebyly
obsaženy:</p>

<pre>
as -g loop-aarch64.s -o loop-aarch64.o
ld loop-aarch64.o
</pre>

<p>Poznámka: u všech dalších příkladů GNU Debuggeru předpokládám, že ladicí
informace jsou zachovány.</p>



<p><a name="k05"></a></p>
<h2 id="k05">5. Překlad se současným výpisem vygenerovaného kódu</h2>

<p>Zejména při zápisu maker či při jejich volání může dojít k&nbsp;situaci, kdy
se makro neexpanduje podle našich předpokladů a je nutné zjistit, kde nastal
problém. GNU Assembler sice neexpanduje makra samostatným preprocesorem (jak je
tomu v&nbsp;céčku a jeho preprocesoru nazvaném <strong>cpp</strong>), ovšem
obsahuje možnost nechat si vygenerovat výpis původního zdrojového kódu
kombinovaného s&nbsp;přeloženým objektovým kódem, přesněji řečeno
s&nbsp;objektovým kódem zapsaným v&nbsp;hexadecimálním tvaru. Jedná se o mnohdy
velmi užitečnou vlastnost, kterou nalezneme u mnoha assemblerů, a to i u
některých starších nástrojů. Takový výpis se na historických mainframech bez
obrazovky většinou posílal přímo na tiskárnu, takže obsahoval i vepsané chyby
nalezené překladačem. A právě v&nbsp;tomto výpisu se mohou objevit expandovaná
makra. Podívejme se, co se stane, pokud při překladu použijeme volbu
<strong>-alm</strong> (resp.&nbsp;volbu <strong>-a</strong> s&nbsp;dalšími
příznaky <strong>l</strong> a <strong>m</strong>) kombinovanou
popř.&nbsp;s&nbsp;volbou <strong>-g</strong>:</p>

<pre>
<strong>as -alm loop-aarch64.s -o loop-aarch64.o</strong>
AARCH64 GAS  loop-aarch64.s                     page 1
&nbsp;
&nbsp;
   1                    # asmsyntax=as
   2
   3                    # Demonstracni priklad naprogramovany v assembleru GNU as
   4                    # - pocitana programova smycka realizovana instrukci CBNZ
   5                    # - uprava pro mikroprocesory s architekturou AArch64
   6
   7                    # Autor: Pavel Tisnovsky
   8
   9
  10
  11                    # Linux kernel system call table
  12                    sys_exit   = 93
  13                    sys_write  = 64
  14
  15                    # List of syscalls for AArch64:
  16                    # https://github.com/torvalds/linux/blob/master/include/uapi/asm-generic/unistd.h
  17
  18                    # Dalsi konstanty pouzite v programu - standardni streamy
  19                    std_input  = 0
  20                    std_output = 1
  21
  22                    # pocet opakovani znaku
  23                    rep_count  = 40
  24
  25
  26
  27                    #-----------------------------------------------------------------------------
  28                    .section .data
  29
  30
  31
  32                    #-----------------------------------------------------------------------------
  33                    .section .bss
  34                            .lcomm buffer, rep_count     // rezervace bufferu pro vystup
  35
  36
  37
  38                    #-----------------------------------------------------------------------------
  39                    .section .text
  40                            .global _start               // tento symbol ma byt dostupny i linkeru
  41
  42                    _start:
  43 0000 01020058              ldr   x1, =buffer            // zapis se bude provadet do tohoto bufferu
  44 0004 020580D2              mov   x2, #rep_count         // pocet opakovani znaku
  45 0008 43058052              mov   w3, #'*'               // zapisovany znak
  46                    loop:
  47 000c 23000039              strb  w3, [x1]               // zapis znaku do bufferu
  48 0010 21040091              add   x1, x1, #1             // uprava ukazatele do bufferu
  49 0014 420400D1              sub   x2, x2, #1             // zmenseni pocitadla a soucasne nastaveni priznaku
  50 0018 A2FFFFB5              cbnz  x2, loop               // pokud jsme se nedostali k nule, skok na zacatek smycky
  51
  52 001c 080880D2              mov   x8, #sys_write         // cislo syscallu pro funkci "write"
  53 0020 200080D2              mov   x0, #std_output        // standardni vystup
  54 0024 E1000058              ldr   x1, =buffer            // adresa retezce, ktery se ma vytisknout
  55 0028 020580D2              mov   x2, #rep_count         // pocet znaku, ktere se maji vytisknout
  56 002c 010000D4              svc   0                      // volani Linuxoveho kernelu
  57
AARCH64 GAS  loop-aarch64.s                     page 2
&nbsp;
&nbsp;
  58 0030 A80B80D2              mov   x8, #sys_exit          // cislo sycallu pro funkci "exit"
  59 0034 000080D2              mov   x0, #0                 // exit code = 0
  60 0038 010000D4              svc   0                      // volani Linuxoveho kernelu
  61 003c 00000000
  61      00000000
  61      00000000
</pre>

<p>Tento výpis může být velmi užitečný při zkoumání vlastností instrukční
sady.</p>



<p><a name="k06"></a></p>
<h2 id="k06">6. Informace o spustitelném souboru vypsané nástrojem <i>objdump</i></h2>

<p>Rozdíl mezi překladem programu bez ladicích informací a s&nbsp;ladicími
informacemi nám ozřejmí nástroj <strong>objdump</strong>. Možnosti tohoto
nástroje jsou skutečně velké (může fungovat i jako disassembler atd.), nás však
bude zajímat především přepínač <strong>-x</strong>, který vypíše i obsah
tabulek symbolů. Pro program přeložený bez ladicích informací získáme stručný
výsledek:</p>

<pre>
<strong>as loop-aarch64.s -o loop-aarch64.o</strong>
<strong>ld -s loop-aarch64.o</strong>
<strong>objdump -x a.out</strong>
&nbsp;
a.out:     file format elf64-littleaarch64
a.out
architecture: aarch64, flags 0x00000102:
EXEC_P, D_PAGED
start address 0x00000000004000b0
&nbsp;
Program Header:
    LOAD off    0x0000000000000000 vaddr 0x0000000000400000 paddr 0x0000000000400000 align 2**16
         filesz 0x00000000000000f8 memsz 0x00000000000000f8 flags r-x
    LOAD off    0x00000000000000f8 vaddr 0x00000000004100f8 paddr 0x00000000004100f8 align 2**16
         filesz 0x0000000000000000 memsz 0x0000000000000028 flags rw-
private flags = 0:
&nbsp;
Sections:
Idx Name          Size      VMA               LMA               File off  Algn
  0 .text         00000048  00000000004000b0  00000000004000b0  000000b0  2**3
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  1 .bss          00000028  00000000004100f8  00000000004100f8  000000f8  2**3
                  ALLOC
SYMBOL TABLE:
no symbols
</pre>

<p>Pokud je však program přeložen s&nbsp;ladicími informacemi, bude tabulka
symbolů obsahovat mj.&nbsp;i všechny symboly, které nalezneme ve zdrojovém kódu
(<strong>sys_exit</strong>, <strong>rep_count</strong>, <strong>buffer</strong>
atd.):</p>

<pre>
<strong>as -g loop-aarch64.s -o loop-aarch64.o</strong>
<strong>ld loop-aarch64.o</strong>
<strong>objdump -x a.out</strong>
&nbsp;
a.out:     file format elf64-littleaarch64
a.out
architecture: aarch64, flags 0x00000112:
EXEC_P, HAS_SYMS, D_PAGED
start address 0x00000000004000b0
&nbsp;
Program Header:
    LOAD off    0x0000000000000000 vaddr 0x0000000000400000 paddr 0x0000000000400000 align 2**16
         filesz 0x00000000000000f8 memsz 0x00000000000000f8 flags r-x
    LOAD off    0x00000000000000f8 vaddr 0x00000000004100f8 paddr 0x00000000004100f8 align 2**16
         filesz 0x0000000000000000 memsz 0x0000000000000028 flags rw-
private flags = 0:
&nbsp;
Sections:
Idx Name          Size      VMA               LMA               File off  Algn
  0 .text         00000048  00000000004000b0  00000000004000b0  000000b0  2**3
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  1 .bss          00000028  00000000004100f8  00000000004100f8  000000f8  2**3
                  ALLOC
  2 .debug_aranges 00000030  0000000000000000  0000000000000000  00000100  2**4
                  CONTENTS, READONLY, DEBUGGING
  3 .debug_info   0000004a  0000000000000000  0000000000000000  00000130  2**0
                  CONTENTS, READONLY, DEBUGGING
  4 .debug_abbrev 00000014  0000000000000000  0000000000000000  0000017a  2**0
                  CONTENTS, READONLY, DEBUGGING
  5 .debug_line   00000050  0000000000000000  0000000000000000  0000018e  2**0
                  CONTENTS, READONLY, DEBUGGING
SYMBOL TABLE:
00000000004000b0 l    d  .text  0000000000000000 .text
00000000004100f8 l    d  .bss   0000000000000000 .bss
0000000000000000 l    d  .debug_aranges 0000000000000000 .debug_aranges
0000000000000000 l    d  .debug_info    0000000000000000 .debug_info
0000000000000000 l    d  .debug_abbrev  0000000000000000 .debug_abbrev
0000000000000000 l    d  .debug_line    0000000000000000 .debug_line
0000000000000000 l    df *ABS*  0000000000000000 loop-aarch64.o
000000000000005d l       *ABS*  0000000000000000 sys_exit
0000000000000040 l       *ABS*  0000000000000000 sys_write
0000000000000000 l       *ABS*  0000000000000000 std_input
0000000000000001 l       *ABS*  0000000000000000 std_output
0000000000000028 l       *ABS*  0000000000000000 rep_count
00000000004100f8 l     O .bss   0000000000000028 buffer
00000000004000bc l       .text  0000000000000000 loop
0000000000410120 g       .bss   0000000000000000 _bss_end__
00000000004100f8 g       .bss   0000000000000000 __bss_start__
0000000000410120 g       .bss   0000000000000000 __bss_end__
00000000004000b0 g       .text  0000000000000000 _start
00000000004100f8 g       .bss   0000000000000000 __bss_start
0000000000410120 g       .bss   0000000000000000 __end__
00000000004100f8 g       .bss   0000000000000000 _edata
0000000000410120 g       .bss   0000000000000000 _end
</pre>

<p>Poznámka: povšimněte si, že některé symboly jsou globální (g) a jiné lokální
(l). Další možností jsou současně lokální i globální symboly (!), unikátní
globální symboly (u) a kupodivu i symboly, které nejsou ani globální ani
lokální ( ).</p>



<p><a name="k07"></a></p>
<h2 id="k07">7. Použití nástroje <i>strace</i></h2>

<p>Užitečný nástroj <i>strace</i> jsme si již na serveru Root.cz <a
href="https://www.root.cz/clanky/trasovani-a-ladeni-nativnich-aplikaci-v-linuxu#k06">popsali</a>,
takže se podívejme, jaká systémová volání vlastně náš miniaturní program
v&nbsp;assembleru používá. Na rozdíl od <a
href="https://www.root.cz/clanky/trasovani-a-ladeni-nativnich-aplikaci-v-linuxu/#k06">céčkového
programu postaveného nad glibc</a> uvidíme pouze tři systémová volání,
z&nbsp;nichž dvě jsou explicitně použity v&nbsp;aplikaci
(<strong>sys_write</strong> a <strong>sys_exit</strong>) a první zavolá
spouštěcí program ihned po <strong>fork</strong>:</p>

<pre>
<strong>strace ./a.out </strong>
&nbsp;
execve("./a.out", ["./a.out"], [/* 50 vars */]) = 0
write(1, "********************************"..., 40****************************************) = 40
exit(0)                                 = ?
+++ exited with 0 +++
</pre>



<p><a name="k08"></a></p>
<h2 id="k08">8. Ladění v&nbsp;GNU Debuggeru</h2>

<p>Informace získané nástrojem <i>strace</i> jsou sice užitečné a důležité,
ovšem pro ladění většiny problémů nedostačující, takže nám nezbývá, než se
obrátit na mnohem mocnější nástroj &ndash; GNU Debugger.</p>

<p>Pokud GNU Debugger spustíme s&nbsp;programem přeloženým BEZ ladicích
informací, bude první vypsaná zpráva vypadat přibližně takto:</p>

<pre>
<strong>as loop-aarch64.s -o loop-aarch64.o</strong>
<strong>ld -s loop-aarch64.o</strong>
<strong>gdb a.out</strong>
&nbsp;
GNU gdb (GDB) Red Hat Enterprise Linux 7.6.1-94.el7
Copyright (C) 2013 Free Software Foundation, Inc.
License GPLv3+: GNU GPL version 3 or later &lt;http://gnu.org/licenses/gpl.html&gt;
This is free software: you are free to change and redistribute it.
There is NO WARRANTY, to the extent permitted by law.  Type "show copying"
and "show warranty" for details.
This GDB was configured as "aarch64-redhat-linux-gnu".
For bug reporting instructions, please see:
&gt;http://www.gnu.org/software/gdb/bugs/&gt;...
Reading symbols from work/a.out...(<strong>no debugging symbols found</strong>)...done.
</pre>

<p>Mnohem praktičtější je používat GNU Debugger pro aplikaci přeloženou se
všemi ladicími informacemi. Poslední řádek první zprávy v&nbsp;takovém případě
neobsahuje poznámku o nedostupných symbolech:</p>

<pre>
<strong>as -g loop-aarch64.s -o loop-aarch64.o</strong>
<strong>ld loop-aarch64.o</strong>
<strong>gdb a.out</strong>
&nbsp;
GNU gdb (GDB) Red Hat Enterprise Linux 7.6.1-94.el7
Copyright (C) 2013 Free Software Foundation, Inc.
License GPLv3+: GNU GPL version 3 or later &lt;http://gnu.org/licenses/gpl.html&gt;
This is free software: you are free to change and redistribute it.
There is NO WARRANTY, to the extent permitted by law.  Type "show copying"
and "show warranty" for details.
This GDB was configured as "aarch64-redhat-linux-gnu".
For bug reporting instructions, please see:
&gt;http://www.gnu.org/software/gdb/bugs/&gt;...
Reading symbols from work/a.out...done.
</pre>



<p><a name="k09"></a></p>
<h2 id="k09">9. Spuštění a krokování programu, nastavení breakpointu</h2>

<p>Program v&nbsp;GNU Debuggeru spustíme jednoduše příkazem
<strong>run</strong> nebo jeho zkrácenou variantou <strong>r</strong> (ještě
jsem ovšem neviděl, že by někdo psal plnou variantu tohoto příkazu :-). Celý
program se vykoná, tj.&nbsp;vypíše řadu hvězdiček a je ukončen:</p>

<pre>
(gdb) <strong>r</strong>
Starting program: work/a.out
****************************************[Inferior 1 (process 27777) exited normally]
(gdb)
</pre>

<p>Pokud aplikaci upravíte tak, aby vracela kód 2, bude výsledek debuggeru
odlišný, protože pouze kód 0 je považován za normální ukončení:</p>

<pre>
(gdb) <strong>r</strong>
Starting program: /root/work/a.out 
****************************************[Inferior 1 (process 28207) exited with code 02]
</pre>

<p>Důležitým příkazem je nastavení breakpointů pomocí <strong>break</strong>
nebo jen <strong>b</strong>. Za tento příkaz je možné (při ladění programu
naprogramovaného v&nbsp;debuggeru) uvést návěští nebo pouhé číslo řádku.
Nastavení breakpointu na začátek naší rutiny tedy proběhne následovně:</p>

<pre>
(gdb) <strong>b _start</strong>
Breakpoint 1 at 0x4000b0: file loop-aarch64.s, line 43.
</pre>

<p>Pokud nyní program spustíme, neproběhne celý, ale zastaví se na prvním
nalezeném breakpointu. Současně se i vypíše instrukce, která se <i>bude</i>
provádět:</p>

<pre>
(gdb) <strong>r</strong>
Starting program: work/a.out
&nbsp;
Breakpoint 1, _start () at loop-aarch64.s:43
43              ldr   x1, =buffer            // zapis se bude provadet do tohoto bufferu
(gdb)
</pre>

<p>Dalším důležitým příkazem je <strong>next</strong> neboli <strong>n</strong>
pro přechod na další instrukci (klasické krokování):</p>

<pre>
(gdb) <strong>n</strong>
44              mov   x2, #rep_count         // pocet opakovani znaku
</pre>

<p>Posledním základním příkazem je <strong>continue</strong> neboli
<strong>c</strong>, které běh programu znovu spustí od místa, které se právě
krokuje (to ovšem neznamená, že program musí doběhnout &ndash; může se zastavit
na dalším breakpointu):</p>

<pre>
(gdb) <strong>c</strong>
Continuing.
****************************************[Inferior 1 (process 27783) exited normally]
</pre>



<p><a name="k10"></a></p>
<h2 id="k10">10. Zobrazení základních informací o laděném procesu</h2>

<p>V&nbsp;průběhu krokování je možné použít příkaz <strong>disassemble</strong>
pro zobrazení instrukce, která se má provést a taktéž několika instrukcí
následujících. Pro programy psané v&nbsp;assembleru to může znamenat, že se
skutečně zobrazí vykonávané instrukce a nikoli například volání maker:</p>

<pre>
(gdb) <strong>disassemble</strong>
Dump of assembler code for function _start:
=&gt; 0x00000000004000b0 &lt;+0&gt;:     ldr     x1, 0x4000f0 &lt;loop+52&gt;
   0x00000000004000b4 &lt;+4&gt;:     mov     x2, #0x28                      // #40
   0x00000000004000b8 &lt;+8&gt;:     mov     w3, #0x2a                      // #42
End of assembler dump.
(gdb)
</pre>

<p>Další příkaz <strong>info frame</strong> zobrazí zásobníkové rámce. Pro naši
assemblerovskou aplikaci to zatím není příliš důležité, ale pro programy psané
ve vyšších programovacích jazycích již ano:</p>

<pre>
(gdb) <strong>info frame</strong>
Stack level 0, frame at 0x3fffffff160:
 pc = 0x4000b4 in _start (loop-aarch64.s:44); saved pc 0x0
 source language asm.
 Arglist at 0x3fffffff160, args:
 Locals at 0x3fffffff160, Previous frame's sp is 0x3fffffff160
</pre>

<p>Příkaz <strong>info registers</strong> zobrazí aktuální obsah všech
pracovních, adresových a dalších registrů procesoru. Sada registrů je
samozřejmě na různých architekturách CPU odlišná, takže následující výsledek
platí jen pro AArch64. Povšimněte si, že <strong>x31</strong> je zde pojmenován
<strong>sp</strong>:</p>

<pre>
(gdb) <strong>info registers</strong>
x0             0x0      0
x1             0x0      0
x2             0x0      0
x3             0x0      0
x4             0x0      0
x5             0x0      0
x6             0x0      0
x7             0x0      0
x8             0x0      0
x9             0x0      0
x10            0x0      0
x11            0x0      0
x12            0x0      0
x13            0x0      0
x14            0x0      0
x15            0x0      0
x16            0x0      0
x17            0x0      0
x18            0x0      0
x19            0x0      0
x20            0x0      0
x21            0x0      0
x22            0x0      0
x23            0x0      0
x24            0x0      0
x25            0x0      0
x26            0x0      0
x27            0x0      0
x28            0x0      0
x29            0x0      0
x30            0x0      0
sp             0x3fffffff160    0x3fffffff160
pc             0x4000b0 0x4000b0 &lt;_start&gt;
cpsr           0x0      0
fpsr           0x0      0
fpcr           0x0      0
</pre>



<p><a name="k11"></a></p>
<h2 id="k11">11. Použití příkazu <strong>display</strong> a <strong>print</strong></h2>

<p>Příkazem <strong>display</strong> lze specifikovat výrazy, jejichž výsledek
se bude automaticky zobrazovat při krokování. Pokud si budeme chtít nechat
zobrazovat hodnoty registrů <strong>x1</strong> a <strong>x2</strong>, stačí
napsat:</p>

<pre>
(gdb) <strong>display $x1</strong>
(gdb) <strong>display $x2</strong>
</pre>

<p>V&nbsp;praxi to může vypadat následovně:</p>

<pre>
(gdb) <strong>n</strong>
x1             0x4100f8 4260088
x2             0x0      0
</pre>

<p>Pro ad-hoc zobrazení obsahu registru je možné použít velmi užitečný příkaz
<strong>print</strong>, který ovšem dokáže vypsat i mnohem složitější výrazy
(pokud je to nutné). Podívejme se nyní pouze na přepínače formátování &ndash;
decimální výstup, hexadecimální výstup a zobrazení obsahu registru
<strong>w3</strong> jako znaku (pokud je to možné):</p>

<pre>
(gdb) <strong>print $w3</strong>
$1 = 42
(gdb) <strong>print/x $w3</strong>
$2 = 0x2a
(gdb) <strong>print/c $w3</strong>
$3 = 42 '*'
</pre>



<p><a name="k12"></a></p>
<h2 id="k12">12. Použití příkazu <strong>examine</strong> pro prohlížení obsahu paměti</h2>

<p>Příkaz <strong>x</strong> (<i>examine</i>) byl popsán <a
href="https://www.root.cz/clanky/trasovani-a-ladeni-nativnich-aplikaci-v-linuxu-pokrocilejsi-moznosti-nabizene-gnu-debuggerem/#k10">zde</a>,
takže si nyní ukažme jeho možnosti při sledování postupného naplňování bufferu
hvězdičkami. Zobrazení s&nbsp;výchozím formátováním není příliš užitečné:</p>

<pre>
(gdb) <strong>x $x1</strong>
0x4100fa &lt;buffer+2&gt;:    0x00000000
(gdb) <strong>x $x1-2</strong>
0x4100f8 &lt;buffer&gt;:      0x00002a2a
(gdb) <strong>x/b $x1-2</strong>
</pre>

<p>Můžeme přepnout režim zobrazení tak, aby se vypsalo deset bajtů (stále ještě
hexadecimálně):</p>

<pre>
(gdb) <strong>x/10b $x1-2</strong>
0x4100f8 &lt;buffer&gt;:      0x2a    0x2a    0x00    0x00    0x00    0x00   0x00     0x00
0x410100 &lt;buffer+8&gt;:    0x00    0x00
</pre>

<p>Vidíme, že za již zapsanými bajty jsou uloženy nuly, takže můžeme buffer
považovat za řetězec a použít speciální režim výpisu řetězců:</p>

<pre>
(gdb) <strong>x/bs $x1-2</strong>
0x4100f8 &lt;buffer&gt;:      "**"
&nbsp;
(gdb) <strong>x/s $x1-2</strong>
0x4100f8 &lt;buffer&gt;:      "**"
</pre>



<p><a name="k13"></a></p>
<h2 id="k13">13. Watchpointy</h2>

<p>Takzvané <i>watchpointy</i> umožňují automaticky sledovat hodnotu nějaké
proměnné či registru a při každé změně vypsat jak původní hodnotu, tak i
hodnotu novou (zapisovanou). Použití je snadné a do značné míry se podobá
použití příkazu <strong>display</strong>. Ostatně podívejme se na příklad,
v&nbsp;němž sledujeme změnu obsahu pracovního registru <strong>x2</strong> (což
je počitadlo smyčky):</p>

<pre>
(gdb) <strong>b _start</strong>
Breakpoint 1 at 0x4000b0: file loop-aarch64.s, line 43.
(gdb) <strong>r</strong>
Starting program: work/a.out
&nbsp;
Breakpoint 1, _start () at loop-aarch64.s:43
43              ldr   x1, =buffer            // zapis se bude provadet do tohoto bufferu
&nbsp;
(gdb) <strong>watch $x2</strong>
Watchpoint 2: $x2
(gdb) <strong>n</strong>
44              mov   x2, #rep_count         // pocet opakovani znaku
(gdb) <strong>n</strong>
Watchpoint 2: $x2
&nbsp;
Old value = 0
New value = 40
_start () at loop-aarch64.s:45
45              mov   w3, #'*'               // zapisovany znak
</pre>

<p>Vidíme, že watchpoint skutečně zareaguje až ve chvíli změny registru, na
rozdíl od funkce příkazu <strong>display</strong>.</p>



<p><a name="k14"></a></p>
<h2 id="k14">14. Breakpointy s&nbsp;podmínkou</h2>

<p>U breakpointů je možné nastavit podmínku určující, kdy breakpoint skutečně
zastaví provádění programu. Taktéž je možné určit, že se několik prvních
průchodů breakpointem bude ignorovat. Ukažme se nejprve tuto možnost pro
breakpoint nastavený na řádek 46 (smyčka):</p>

<pre>
(gdb) <strong>break 46</strong>
Breakpoint 1 at 0x4000c0: file loop-aarch64.s, line 46.
&nbsp;
(gdb) <strong>ignore 1 10</strong>
Will ignore next 10 crossings of breakpoint 1.
</pre>

<p>Při spuštění programu lze snadno zjistit, že se skutečně již nacházíme
v&nbsp;desáté iteraci:</p>

<pre>
(gdb) <strong>r</strong>
Starting program: work/./a.out
&nbsp;
Breakpoint 1, loop () at loop-aarch64.s:48
48              add   x1, x1, #1             // uprava ukazatele do bufferu
(gdb) <strong>print $x2</strong>
$2 = 30
</pre>

<p>Další možností je nastavení konkrétní podmínky příkazem
<strong>condition</strong>. Podmínky mohou být i dosti složité, mohou obsahovat
logické spojky atd:</p>

<pre>
(gdb) <strong>b 48</strong>
Breakpoint 1 at 0x4000c0: file loop-aarch64.s, line 48.
&nbsp;
(gdb) <strong>condition 1 $x2&lt;10</strong>
&nbsp;
(gdb) <strong>r</strong>
Starting program: work/./a.out
&nbsp;
Breakpoint 1, loop () at loop-aarch64.s:48
48              add   x1, x1, #1             // uprava ukazatele do bufferu
(gdb) <strong>print $x2</strong>
$1 = 9
</pre>

<p>Vidíme, že jsme se skutečně dostali do situace, kdy už platí x2&lt;10.</p>

<p>Další možnost nastavení breakpointu používá jeho definici s&nbsp;podmínkou
na jediném řádku:</p>

<pre>
(gdb) <strong>b 48 if $x2&lt;10</strong>
Breakpoint 1 at 0x4000c0: file loop-aarch64.s, line 48.
</pre>



<p><a name="k15"></a></p>
<h2 id="k15">15. Specifikace příkazů vykonaných při vstupu na breakpoint</h2>

<p>GNU Debugger umožňuje, aby se při zastavení programu na breakpointu vykonal
libovolný uživatelem zvolený příkaz či sekvence příkazů. Pro jejich specifikaci
se používá <strong>commands</strong> následované číslem breakpointu:</p>

<pre>
(gdb) <strong>commands 1</strong>
Type commands for breakpoint(s) 1, one per line.
End with a line saying just "end".
print $x2
end
</pre>

<p>Zajímavější je následující trik, kdy přímo v&nbsp;sekvenci příkazů použijeme
<strong>continue</strong>, takže se program automaticky rozběhne. Výsledkem je,
že breakpoint zde slouží ve funkci logování:</p>

<pre>
(gdb) <strong>b 48 if $x2&lt;10</strong>
Breakpoint 1 at 0x4000c0: file loop-aarch64.s, line 48.
&nbsp;
(gdb) <strong>commands</strong>
Type commands for breakpoint(s) 1, one per line.
End with a line saying just "end".
print $x2
cont
end
</pre>

<p>Po spuštění se vypíše tato sekvence řádků (samozřejmě kromě řádku
prvního):</p>

<pre>
(gdb) <strong>r</strong>
Starting program: work/./a.out
&nbsp;
Breakpoint 1, loop () at loop-aarch64.s:48
48              add   x1, x1, #1             // uprava ukazatele do bufferu
$1 = 9
&nbsp;
Breakpoint 1, loop () at loop-aarch64.s:48
48              add   x1, x1, #1             // uprava ukazatele do bufferu
$2 = 8
&nbsp;
Breakpoint 1, loop () at loop-aarch64.s:48
48              add   x1, x1, #1             // uprava ukazatele do bufferu
$3 = 7
&nbsp;
Breakpoint 1, loop () at loop-aarch64.s:48
48              add   x1, x1, #1             // uprava ukazatele do bufferu
$4 = 6
&nbsp;
Breakpoint 1, loop () at loop-aarch64.s:48
</pre>

<p>Poznámka: zde asi začíná být jasné, že GUI nadstavby nad GNU Debuggerem to
mají skutečně složité :-)</p>



<p><a name="k16"></a></p>
<h2 id="k16">16. Vzdálené ladění přes <strong>gdbserver</strong></h2>

<p>V&nbsp;některých případech může být užitečné použít <i>gdbserver</i>
umožňující vzdálené ladění. Program se spustí následovně:</p>

<pre>
<strong>gdbserver :0 ./a.out</strong>
&nbsp;
Process ./a.out created; pid = 27922
Listening on port 38253
Remote debugging from host 127.0.0.1
</pre>

<p>Ve skutečnosti se program nespustil (spustil se pouze stub), ale čeká na
připojení GNU Debuggeru.</p>

<p>GNU Debugger spustíme ve druhém terminálu a jako první příkaz zadáme
<strong>target remote :port</strong>, kde port je získán z&nbsp;předchozího
výstupu:</p>

<pre>
<strong>gdb ./a.out </strong>
&nbsp;
Reading symbols from work/a.out...done.
(gdb) target remote 38253
38253: No such file or directory.
(gdb) <strong>target remote :38253</strong>
Remote debugging using :38253
</pre>

<p>Nyní je již možné nastavit breakpointy, tracepointy (pokud jsou podporovány)
a provádět krokování, ladění atd. Jakmile se aplikace ukončí, dojde i
k&nbsp;odpojení GNU Debuggeru od stubu.</p>



<p><a name="k17"></a></p>
<h2 id="k17">17. TUI &ndash; textové uživatelské rozhraní GNU debuggeru</h2>

<p></p>

<pre>
(gdb) <strong>help layout</strong>
Change the layout of windows.
Usage: layout prev | next | &lt;layout_name&gt;
Layout names are:
   src   : Displays source and command windows.
   asm   : Displays disassembly and command windows.
   split : Displays source, disassembly and command windows.
   regs  : Displays register window. If existing layout
           is source/command or assembly/command, the
           register window is displayed. If the
           source/assembly/command (split) is displayed,
           the register window is displayed with
           the window that has current logical focus.
</pre>

*** image ***
<p><i>Obrázek 1: GDB s&nbsp;TUI spuštěný s&nbsp;naším demonstračním příkladem.</i></p>



<p><a name="k18"></a></p>
<h2 id="k18">18. Použití nadstavby nad GNU debuggerem nazvané cgdb</h2>

<p>Nástroj nazvaný <i>cgdb</i>, o němž jsem se podrobněji zmínil <a
href="https://mojefedora.cz/debuggery-a-jejich-nadstavby-v-linuxu/#k07">zde</a>,
je založený na knihovně <a
href="https://en.wikipedia.org/wiki/Curses_%28programming_library%29">curses</a>
resp. ncurses, tudíž ho je možné využít v&nbsp;terminálu, na stroji připojeném
přes SSH atd. Ve svém základním nastavení nástroj <i>cgdb</i> rozděluje okno
terminálu (konzole) na dvě části. V&nbsp;horní části je zobrazen zdrojový kód
laděné aplikace a v&nbsp;části dolní pak rozhraní samotného GNU Debuggeru,
které již známe z&nbsp;předchozích kapitol. Mezi oběma částmi je možné se
s&nbsp;využitím několika klávesových zkratek přepínat, přičemž je nutné
poznamenat, že většinu složitějších příkazů je možné zadávat jen
v&nbsp;rozhraní GNU Debuggeru. Horní část slouží zejména pro dobrou orientaci
v&nbsp;laděném programu, pro zobrazení nastavených breakpointů
(v&nbsp;základním nastavení je použita červená barva) a taktéž pro zobrazení
místa, v&nbsp;němž se právě nachází laděný program (v&nbsp;základním nastavení
je tento řádek zobrazen zeleně, ale i toto nastavení je samozřejmě možné
změnit).</p>

*** image ***
<p><i>Obrázek 2: Nástroj cgdb spuštěný s&nbsp;naším demonstračním
příkladem.</i></p>

<p>V&nbsp;nástroji <i>cgdb</i> se využívají klávesové zkratky známé především
z&nbsp;textových editorů Vi a Vim, ovšem i ti uživatelé, kteří tyto editory
nepoužívají (a tudíž dané zkratky neznají), nebudou ztraceni, protože se
například ve zdrojovém textu mohou pro přesun kurzoru používat i kurzorové
klávesy atd. <i>cgdb</i> obsahuje i vestavěnou nápovědu dostupnou po stisku
klávesy F1.</p>

<p>Rozhraní <i>cgdb</i> při práci s&nbsp;našim příkladem vypadá následovně.
V&nbsp;horní části vidíme část zdrojového kódu, v&nbsp;části dolní pak rozhraní
GNU Debuggeru. Pro přepínání používejte vi-příkazy <strong>i</strong> a
<strong>Esc</strong>:</p>

<pre>
 4&lt; # - pocitana programova smycka realizovana instrukci CBNZ
 5&lt; # - uprava pro mikroprocesory s architekturou AArch64
 6&lt; #
 7&lt; # Autor: Pavel Tisnovsky
 8&lt;
 9&lt;
10:&gt;
11&lt; # Linux kernel system call table
12&lt; sys_exit   = 93
13&lt; sys_write  = 64
14&lt;
15&lt; # List of syscalls for AArch64:
<strong>/work/loop-aarch64.s</strong>
License GPLv3+: GNU GPL version 3 or later &lt;http://gnu.org/licenses/gpl.
html&gt;
This is free software: you are free to change and redistribute it.
There is NO WARRANTY, to the extent permitted by law.  Type "show copyin
g"
and "show warranty" for details.
This GDB was configured as "aarch64-redhat-linux-gnu".
For bug reporting instructions, please see:
&lt;http://www.gnu.org/software/gdb/bugs/&gt;...
Reading symbols from work/a.out...done.
(gdb)
</pre>

<p>Takto vypadá rozhraní <strong>cgdb</strong> při ladění. Zdrojový kód se
posunuje vždy na to místo, v&nbsp;němž se nachází právě &bdquo;krokovaná&ldquo;
instrukce:</p>

<pre>
39&lt; .section .text
40&lt;         .global _start               // tento symbol ma byt dostupny
41&lt;
42&lt; _start:
43&lt;         ldr   x1, =buffer            // zapis se bude provadet do to
44&lt;         mov   x2, #rep_count         // pocet opakovani znaku
45:&gt;        mov   w3, #'*'               // zapisovany znak
46&lt; loop:
47&lt;         strb  w3, [x1]               // zapis znaku do bufferu
48&lt;         add   x1, x1, #1             // uprava ukazatele do bufferu
49&lt;         sub   x2, x2, #1             // zmenseni pocitadla a soucasn
50&lt;         cbnz  x2, loop               // pokud jsme se nedostali k nu
work/loop-aarch64.s
Breakpoint 1, _start () at loop-aarch64.s:43
(gdb) watch $x2
Watchpoint 2: $x2
(gdb) n
(gdb) n
Watchpoint 2: $x2
&nbsp;
Old value = 0
New value = 40
_start () at loop-aarch64.s:45
</pre>



<p><a name="k19"></a></p>
<h2 id="k19">19. Odkazy na Internetu</h2>

<ol>

<li>Trasování a ladění nativních aplikací v Linuxu<br />
<a href="https://www.root.cz/clanky/trasovani-a-ladeni-nativnich-aplikaci-v-linuxu/">https://www.root.cz/clanky/trasovani-a-ladeni-nativnich-aplikaci-v-linuxu/</a>
</li>

<li>Trasování a ladění nativních aplikací v Linuxu: použití GDB a jeho nadstaveb<br />
<a href="https://www.root.cz/clanky/trasovani-a-ladeni-nativnich-aplikaci-v-linuxu-pouziti-gdb-a-jeho-nadstaveb/">https://www.root.cz/clanky/trasovani-a-ladeni-nativnich-aplikaci-v-linuxu-pouziti-gdb-a-jeho-nadstaveb/</a>
</li>

<li>Debuggery a jejich nadstavby v Linuxu (3): Nemiver<br />
<a href="http://mojefedora.cz/debuggery-a-jejich-nadstavby-v-linuxu-3-nemiver/">http://mojefedora.cz/debuggery-a-jejich-nadstavby-v-linuxu-3-nemiver/</a>
</li>

<li>Debuggery a jejich nadstavby v Linuxu (4): KDbg<br />
<a href="http://mojefedora.cz/debuggery-a-jejich-nadstavby-v-linuxu-4-kdbg/">http://mojefedora.cz/debuggery-a-jejich-nadstavby-v-linuxu-4-kdbg/</a>
</li>

<li>Debuggery a jejich nadstavby v Linuxu (5): ladění aplikací v&nbsp;editorech Emacs a Vim<br />
<a href="http://mojefedora.cz/debuggery-a-jejich-nadstavby-v-linuxu-5-ladeni-aplikaci-v-editorech-emacs-a-vim/">http://mojefedora.cz/debuggery-a-jejich-nadstavby-v-linuxu-5-ladeni-aplikaci-v-editorech-emacs-a-vim/</a>
</li>

<li>Tracing (software)<br />
<a href="https://en.wikipedia.org/wiki/Tracing_%28software%29">https://en.wikipedia.org/wiki/Tracing_%28software%29</a>
</li>

<li>cgdb: the curses debugger<br />
<a href="https://cgdb.github.io/">https://cgdb.github.io/</a>
</li>

<li>cgdb: dokumentace<br />
<a href="https://cgdb.github.io/docs/cgdb-split.html">https://cgdb.github.io/docs/cgdb-split.html</a>
</li>

<li>strace(1) - Linux man page<br />
<a href="http://linux.die.net/man/1/strace">http://linux.die.net/man/1/strace</a>
</li>

<li>strace (stránka projektu na SourceForge)<br />
<a href="https://sourceforge.net/projects/strace/">https://sourceforge.net/projects/strace/</a>
</li>

<li>strace (Wikipedia)<br />
<a href="https://en.wikipedia.org/wiki/Strace">https://en.wikipedia.org/wiki/Strace</a>
</li>

<li>GDB - Dokumentace<br />
<a href="http://sourceware.org/gdb/current/onlinedocs/gdb/">http://sourceware.org/gdb/current/onlinedocs/gdb/</a>
</li>

<li>GDB - Supported Languages<br />
<a href="http://sourceware.org/gdb/current/onlinedocs/gdb/Supported-Languages.html#Supported-Languages">http://sourceware.org/gdb/current/onlinedocs/gdb/Supported-Languages.html#Supported-Languages</a>
</li>

<li>GNU Debugger (Wikipedia)<br />
<a href="https://en.wikipedia.org/wiki/GNU_Debugger">https://en.wikipedia.org/wiki/GNU_Debugger</a>
</li>

<li>The LLDB Debugger<br />
<a href="http://lldb.llvm.org/">http://lldb.llvm.org/</a>
</li>

<li>Debugger (Wikipedia)<br />
<a href="https://en.wikipedia.org/wiki/Debugger">https://en.wikipedia.org/wiki/Debugger</a>
</li>

<li>Comparison of ARMv8-A cores<br />
<a href="https://en.wikipedia.org/wiki/Comparison_of_ARMv8-A_cores">https://en.wikipedia.org/wiki/Comparison_of_ARMv8-A_cores</a>
</li>

<li>A64 General Instructions<br />
<a href="http://www.keil.com/support/man/docs/armclang_asm/armclang_asm_pge1427898258836.htm">http://www.keil.com/support/man/docs/armclang_asm/armclang_asm_pge1427898258836.htm</a>
</li>

<li>ARMv8 (AArch64) Instruction Encoding<br />
<a href="http://kitoslab-eng.blogspot.cz/2012/10/armv8-aarch64-instruction-encoding.html">http://kitoslab-eng.blogspot.cz/2012/10/armv8-aarch64-instruction-encoding.html</a>
</li>

<li>Cortex-A32 Processor<br />
<a href="https://www.arm.com/products/processors/cortex-a/cortex-a32-processor.php">https://www.arm.com/products/processors/cortex-a/cortex-a32-processor.php</a>
</li>

<li>Cortex-A35 Processor<br />
<a href="https://www.arm.com/products/processors/cortex-a/cortex-a35-processor.php">https://www.arm.com/products/processors/cortex-a/cortex-a35-processor.php</a>
</li>

<li>Cortex-A53 Processor<br />
<a href="https://www.arm.com/products/processors/cortex-a/cortex-a53-processor.php">https://www.arm.com/products/processors/cortex-a/cortex-a53-processor.php</a>
</li>

<li>Cortex-A57 Processor<br />
<a href="https://www.arm.com/products/processors/cortex-a/cortex-a57-processor.php">https://www.arm.com/products/processors/cortex-a/cortex-a57-processor.php</a>
</li>

<li>Cortex-A72 Processor<br />
<a href="https://www.arm.com/products/processors/cortex-a/cortex-a72-processor.php">https://www.arm.com/products/processors/cortex-a/cortex-a72-processor.php</a>
</li>

<li>Cortex-A73 Processor<br />
<a href="https://www.arm.com/products/processors/cortex-a/cortex-a73-processor.php">https://www.arm.com/products/processors/cortex-a/cortex-a73-processor.php</a>
</li>

<li>Apple A7 (SoC založen na CPU Cyclone)<br />
<a href="https://en.wikipedia.org/wiki/Apple_A7">https://en.wikipedia.org/wiki/Apple_A7</a>
</li>

<li>System cally pro AArch64 na Linuxu<br />
<a href="https://github.com/torvalds/linux/blob/master/include/uapi/asm-generic/unistd.h">https://github.com/torvalds/linux/blob/master/include/uapi/asm-generic/unistd.h</a>
</li>

<li>Architectures/AArch64 (FedoraProject.org)<br />
<a href="https://fedoraproject.org/wiki/Architectures/AArch64">https://fedoraproject.org/wiki/Architectures/AArch64</a>
</li>

<li>SIG pro AArch64 (CentOS)<br />
<a href="https://wiki.centos.org/SpecialInterestGroup/AltArch/AArch64">https://wiki.centos.org/SpecialInterestGroup/AltArch/AArch64</a>
</li>

<li>The ARMv8 instruction sets<br />
<a href="http://infocenter.arm.com/help/index.jsp?topic=/com.arm.doc.den0024a/ch05s01.html">http://infocenter.arm.com/help/index.jsp?topic=/com.arm.doc.den0024a/ch05s01.html</a>
</li>

<li>A64 Instruction Set<br />
<a href="https://developer.arm.com/products/architecture/instruction-sets/a64-instruction-set">https://developer.arm.com/products/architecture/instruction-sets/a64-instruction-set</a>
</li>

<li>Switching between the instruction sets<br />
<a href="http://infocenter.arm.com/help/index.jsp?topic=/com.arm.doc.den0024a/ch05s01.html">http://infocenter.arm.com/help/index.jsp?topic=/com.arm.doc.den0024a/ch05s01.html</a>
</li>

<li>The A64 instruction set<br />
<a href="http://infocenter.arm.com/help/index.jsp?topic=/com.arm.doc.den0024a/ch05s01.html">http://infocenter.arm.com/help/index.jsp?topic=/com.arm.doc.den0024a/ch05s01.html</a>
</li>

<li>Introduction to ARMv8 64-bit Architecture<br />
<a href="https://quequero.org/2014/04/introduction-to-arm-architecture/">https://quequero.org/2014/04/introduction-to-arm-architecture/</a>
</li>

<li>MCU market turns to 32-bits and ARM<br />
<a href="http://www.eetimes.com/document.asp?doc_id=1280803">http://www.eetimes.com/document.asp?doc_id=1280803</a>
</li>

<li>Cortex-M0 Processor (ARM Holdings)<br />
<a href="http://www.arm.com/products/processors/cortex-m/cortex-m0.php">http://www.arm.com/products/processors/cortex-m/cortex-m0.php</a>
</li>

<li>Cortex-M0+ Processor (ARM Holdings)<br />
<a href="http://www.arm.com/products/processors/cortex-m/cortex-m0plus.php">http://www.arm.com/products/processors/cortex-m/cortex-m0plus.php</a>
</li>

<li>ARM Processors in a Mixed Signal World<br />
<a href="http://www.eeweb.com/blog/arm/arm-processors-in-a-mixed-signal-world">http://www.eeweb.com/blog/arm/arm-processors-in-a-mixed-signal-world</a>
</li>

<li>ARM Architecture (Wikipedia)<br />
<a href="https://en.wikipedia.org/wiki/ARM_architecture">https://en.wikipedia.org/wiki/ARM_architecture</a>
</li>

<li>DSP for Cortex-M<br />
<a href="https://developer.arm.com/technologies/dsp/dsp-for-cortex-m">https://developer.arm.com/technologies/dsp/dsp-for-cortex-m</a>
</li>

<li>Cortex-M processors in DSP applications? Why not?!<br />
<a href="https://community.arm.com/processors/b/blog/posts/cortex-m-processors-in-dsp-applications-why-not">https://community.arm.com/processors/b/blog/posts/cortex-m-processors-in-dsp-applications-why-not</a>
</li>

<li>White Paper - DSP capabilities of Cortex-M4 and Cortex-M7<br />
<a href="https://community.arm.com/processors/b/blog/posts/white-paper-dsp-capabilities-of-cortex-m4-and-cortex-m7">https://community.arm.com/processors/b/blog/posts/white-paper-dsp-capabilities-of-cortex-m4-and-cortex-m7</a>
</li>

<li>Q (number format)<br />
<a href="https://en.wikipedia.org/wiki/Q_%28number_format%29">https://en.wikipedia.org/wiki/Q_%28number_format%29</a>
</li>

<li>TriCore Architecture &amp; Core<br />
<a href="http://www.infineon.com/cms/en/product/microcontroller/32-bit-tricore-tm-microcontroller/tricore-tm-architecture-and-core/channel.html?channel=ff80808112ab681d0112ab6b73d40837">http://www.infineon.com/cms/en/product/microcontroller/32-bit-tricore-tm-microcontroller/tricore-tm-architecture-and-core/channel.html?channel=ff80808112ab681d0112ab6b73d40837</a>
</li>

<li>TriCoreTM V1.6 Instruction Set: 32-bit Unified Processor Core<br />
<a href="http://www.infineon.com/dgdl/tc_v131_instructionset_v138.pdf?fileId=db3a304412b407950112b409b6dd0352">http://www.infineon.com/dgdl/tc_v131_instructionset_v138.pdf?fileId=db3a304412b407950112b409b6dd0352</a>
</li>

<li>TriCore v2.2 C Compiler, Assembler, Linker Reference Manual<br />
<a href="http://tasking.com/support/tricore/tc_reference_guide_v2.2.pdf">http://tasking.com/support/tricore/tc_reference_guide_v2.2.pdf</a>
</li>

<li>Infineon TriCore (Wikipedia)<br />
<a href="https://en.wikipedia.org/wiki/Infineon_TriCore">https://en.wikipedia.org/wiki/Infineon_TriCore</a>
</li>

<li>C166®S V2 Architecture &amp; Core<br />
<a href="http://www.infineon.com/cms/en/product/microcontroller/16-bit-c166-microcontroller/c166-s-v2-architecture-and-core/channel.html?channel=db3a304312bef5660112c3011c7d01ae">http://www.infineon.com/cms/en/product/microcontroller/16-bit-c166-microcontroller/c166-s-v2-architecture-and-core/channel.html?channel=db3a304312bef5660112c3011c7d01ae</a>
</li>

<li>Comparing four 32-bit soft processor cores<br />
<a href="http://www.eetimes.com/author.asp?section_id=14&doc_id=1286116">http://www.eetimes.com/author.asp?section_id=14&doc_id=1286116</a>
</li>

<li>RISC-V Instruction Set<br />
<a href="http://riscv.org/download.html#spec_compressed_isa">http://riscv.org/download.html#spec_compressed_isa</a>
</li>

<li>RISC-V Spike (ISA Simulator)<br />
<a href="http://riscv.org/download.html#isa-sim">http://riscv.org/download.html#isa-sim</a>
</li>

<li>RISC-V (Wikipedia)<br />
<a href="https://en.wikipedia.org/wiki/RISC-V">https://en.wikipedia.org/wiki/RISC-V</a>
</li>

<li>David Patterson (Wikipedia)<br />
<a href="https://en.wikipedia.org/wiki/David_Patterson_(computer_scientist)">https://en.wikipedia.org/wiki/David_Patterson_(computer_scientist)</a>
</li>

<li>OpenRISC (oficiální stránky projektu)<br />
<a href="http://openrisc.io/">http://openrisc.io/</a>
</li>

<li>OpenRISC architecture<br />
<a href="http://openrisc.io/architecture.html">http://openrisc.io/architecture.html</a>
</li>

<li>Emulátor OpenRISC CPU v JavaScriptu<br />
<a href="http://s-macke.github.io/jor1k/demos/main.html">http://s-macke.github.io/jor1k/demos/main.html</a>
</li>

<li>OpenRISC (Wikipedia)<br />
<a href="https://en.wikipedia.org/wiki/OpenRISC">https://en.wikipedia.org/wiki/OpenRISC</a>
</li>

<li>OpenRISC - instrukce<br />
<a href="http://sourceware.org/cgen/gen-doc/openrisc-insn.html">http://sourceware.org/cgen/gen-doc/openrisc-insn.html</a>
</li>

<li>OpenRISC - slajdy z přednášky o projektu<br />
<a href="https://iis.ee.ethz.ch/~gmichi/asocd/lecturenotes/Lecture6.pdf">https://iis.ee.ethz.ch/~gmichi/asocd/lecturenotes/Lecture6.pdf</a>
</li>

<li>Berkeley RISC<br />
<a href="http://en.wikipedia.org/wiki/Berkeley_RISC">http://en.wikipedia.org/wiki/Berkeley_RISC</a>
</li>

<li>Great moments in microprocessor history<br />
<a href="http://www.ibm.com/developerworks/library/pa-microhist.html">http://www.ibm.com/developerworks/library/pa-microhist.html</a>
</li>

<li>Microprogram-Based Processors<br />
<a href="http://research.microsoft.com/en-us/um/people/gbell/Computer_Structures_Principles_and_Examples/csp0167.htm">http://research.microsoft.com/en-us/um/people/gbell/Computer_Structures_Principles_and_Examples/csp0167.htm</a>
</li>

<li>Great Microprocessors of the Past and Present<br />
<a href="http://www.cpushack.com/CPU/cpu1.html">http://www.cpushack.com/CPU/cpu1.html</a>
</li>

<li>A Brief History of Microprogramming<br />
<a href="http://www.cs.clemson.edu/~mark/uprog.html">http://www.cs.clemson.edu/~mark/uprog.html</a>
</li>

<li>What is RISC?<br />
<a href="http://www-cs-faculty.stanford.edu/~eroberts/courses/soco/projects/2000-01/risc/whatis/">http://www-cs-faculty.stanford.edu/~eroberts/courses/soco/projects/2000-01/risc/whatis/</a>
</li>

<li>RISC vs. CISC<br />
<a href="http://www-cs-faculty.stanford.edu/~eroberts/courses/soco/projects/2000-01/risc/risccisc/">http://www-cs-faculty.stanford.edu/~eroberts/courses/soco/projects/2000-01/risc/risccisc/</a>
</li>

<li>RISC and CISC definitions:<br />
<a href="http://www.cpushack.com/CPU/cpuAppendA.html">http://www.cpushack.com/CPU/cpuAppendA.html</a>
</li>

<li>FPGA<br />
<a href="https://cs.wikipedia.org/wiki/Programovateln%C3%A9_hradlov%C3%A9_pole">https://cs.wikipedia.org/wiki/Programovateln%C3%A9_hradlov%C3%A9_pole</a>
</li>

<li>The Evolution of RISC<br />
<a href="http://www.ibm.com/developerworks/library/pa-microhist.html#sidebar1">http://www.ibm.com/developerworks/library/pa-microhist.html#sidebar1</a>
</li>

</ol>



<p></p><p></p>
<p><small>Autor: <a href="http://www.fit.vutbr.cz/~tisnovpa">Pavel Tišnovský</a> &nbsp; 2017</small></p>
</body>
</html>

