<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
        "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html>
<head>
<title>Programovací jazyk Clojure a knihovny pro práci s vektory a maticemi</title>
<meta name="Author" content="Pavel Tisnovsky" />
<meta name="Generator" content="vim" />
<meta http-equiv="content-type" content="text/html; charset=utf-8" />
<style type="text/css">
         body {color:#000000; background:#ffffff;}
         h1  {font-family: arial, helvetica, sans-serif; color:#ffffff; background-color:#c00000; text-align:center; padding-left:1em}
         h2  {font-family: arial, helvetica, sans-serif; color:#ffffff; background-color:#0000c0; padding-left:1em; text-align:left}
         h3  {font-family: arial, helvetica, sans-serif; color:#000000; background-color:#c0c0c0; padding-left:1em; text-align:left}
         h4  {font-family: arial, helvetica, sans-serif; color:#000000; background-color:#e0e0e0; padding-left:1em; text-align:left}
         a   {font-family: arial, helvetica, sans-serif;}
         li  {font-family: arial, helvetica, sans-serif; color:#000000; text-align:justify; width:450px;}
         ol  {font-family: arial, helvetica, sans-serif; color:#000000; text-align:justify; width:450px;}
         ul  {font-family: arial, helvetica, sans-serif; color:#000000; text-align:justify; width:450px;}
         p   {font-family: arial, helvetica, sans-serif; color:#000000; text-align:justify;}
         pre {background:#e0e0e0}
</style>
</head>

<body>

<h1>Programovací jazyk Clojure a knihovny pro práci s vektory a maticemi</h1>

<h3>Pavel Tišnovský</h3>

<p></p>

<h1>Úvodník</h1>

<p>V dnešní části seriálu o programovacím jazyku Clojure i o knihovnách dostupných vývojářům používajícím Clojure, se budeme zabývat knihovnami určenými pro práci s vektory a maticemi. Tato oblast IT, která je někdy nazývána array programming, se neustále rozvíjí a to mj. i díky rozšiřování možností GPU.</p>



<h2>Obsah</h2>

<p><a href="#k01">1. Array programming a specializované programovací jazyky určené pro zpracování matic</a></p>
<p><a href="#k02">2. Programovací jazyk APL</a></p>
<p><a href="#k03">3. Programovací jazyk J</a></p>
<p><a href="#k04">4. Další programovací jazyky podporující práci s&nbsp;vektory a maticemi</a></p>
<p><a href="#k05">5. Programovací jazyk Clojure a knihovny pro práci s vektory a maticemi</a></p>
<p><a href="#k06">6. Knihovna <strong>core.matrix</strong></a></p>
<p><a href="#k07">7. První demonstrační příklad: vítejte v&nbsp;Matrixu</a></p>
<p><a href="#k08">8. Další vlastnosti knihovny <strong>core.matrix</strong> zkoumané s&nbsp;využitím REPLu</a></p>
<p><a href="#k09">9. Repositář s&nbsp;demonstračními příklady</a></p>
<p><a href="#k10">10. Odkazy na předchozí části seriálu</a></p>
<p><a href="#k11">11. Knihy a články o programovacích jazycích APL a J</a></p>
<p><a href="#k12">12. Odkazy na Internetu</a></p>



<p><a name="k01"></a></p>
<h2 id="k01">1. Array programming a specializované programovací jazyky určené pro zpracování matic</h2>

<p>Jednou poměrně rozsáhlou oblastí v&nbsp;IT je zpracování vektorů a matic,
protože s&nbsp;těmito strukturami se můžeme setkat v&nbsp;různých disciplínách,
například ve finančnictví, pojišťovnictví, statistice, zpracování numerických
dat, simulacích atd. Současně se jedná i o velmi zajímavou oblast, neboť právě
kvůli co nejrychlejší práci s&nbsp;velkými maticemi byly vytvořeny speciální
výpočetní bloky v&nbsp;některých superpočítačích (příkladem mohou být
superpočítače <i>Cray</i>). Současné knihovny dokážou v&nbsp;případě potřeby
využít jak některé rozšíření instrukčních sad (SIMD instrukce typu SSE, původně
též MMX či 3DNow!), tak i programovatelné grafické akcelerátory (GPU). Práce
s&nbsp;vektory a maticemi byla (a samozřejmě doposud je) podporována
v&nbsp;překladačích FORTRANu, které začaly být po vzniku superpočítačů vybaveny
algoritmy, které dokázaly převést některé typy programových smyček na
&bdquo;vektorové operace&ldquo;. Paralelně vznikly i specializované jazyky
určené téměř výhradně pro práci s&nbsp;vektory i maticemi &ndash; příkladem
jsou jazyky <i>APL</i> a <i>J</i> zmíněné <a href="#k02">ve druhé</a> a <a
href="#k03">ve třetí kapitole</a>.</p>

<p>My se v&nbsp;dnešním článku budeme zabývat použitím knihovny nazvané
<strong>core.matrix</strong>, která vývojářům pracujícím s&nbsp;programovacím
jazykem Clojure nabízí prakticky všechny potřebné operace, které se při práci
s&nbsp;vektory a maticemi používají (včetně například výpočtu inverzní matice).
Navíc je tato knihovna zajímavá tím, že předepisuje <i>rozhraní</i> pro všechny
operace, ovšem konkrétní implementaci je možné vybrat. To například znamená, že
pokud je řešen nějaký problém, v&nbsp;němž se ve velké míře používají takzvané
řídké matice (pěkným příkladem z&nbsp;praxe může být <i>Google matrix</i>), lze
&ndash; beze změny uživatelského programu &ndash; vybrat takovou reprezentaci
matic a takové algoritmy, které jsou optimalizovány právě pro práci
s&nbsp;řídkými maticemi a nikoli s&nbsp;maticemi uloženými ve formě
dvourozměrného pole.</p>



<p><a name="k02"></a></p>
<h2 id="k02">2. Programovací jazyk APL</h2>

<p>Kanonickým programovacím jazykem orientovaným téměř výhradně právě na
<i>array programming</i> je programovací jazyk nazvaný <i>APL</i>. Historie
<i>APL</i> se začala psát již v&nbsp;roce 1957. Právě tehdy <i>Kenneth
Iverson</i> z&nbsp;Harvardské university vytvořil notaci vhodnou pro jednotný
zápis matematických funkcí i tvorbu funkcí nových. V&nbsp;roce 1962 byla tato
notace popsána v&nbsp;knize &bdquo;A Programming Language&ldquo; a o několik
let později se začaly objevovat skutečné interpretry i překladače
programovacího jazyka používajícího stejné symboly, jaké popsal Iverson ve své
knize. Konkrétně se jednalo o jazyk <i>IVSYS</i> implementovaný v&nbsp;roce
1965, který byl následován jazykem <i>APL\1130</i> z&nbsp;roku 1967, jenž
pracoval na počítači <i>IBM 1130</i>. Další implementace tohoto jazyka vznikly
na mainframech <i>IBM/360</i> a <i>IBM/370</i>, později se různé (ve větší či
menší míře modifikované) verze <i>APL</i> začaly používat i na minipočítačích a
posléze i na mikropočítačích. Dnes existují implementace pro všechny rozšířené
operační systémy mikropočítačů, takže <i>APL</i> je možné použít na Linuxu, Mac
OS i Microsoft Windows</p>

<a href="http://i.iinfo.cz/images/252/apl-1.png"><img src="http://i.iinfo.cz/images/252/apl-1-prev.png" alt="apl" height="171" width="370" /></a>
<p><i>Obrázek 1: Rozložení znaků na klávesnici používané při programování
v&nbsp;jazyku APL. Speciální znaky na klávesnici reprezentují základní
(primitivní) funkce a operátory.</i></p>

<p>Jedním z&nbsp;typických rysů programovacího jazyka <i>APL</i> je jeho
orientace na zpracování vektorů a matic (obecně polí téměř libovolné dimenze,
většina implementací povoluje definovat až 63dimenzionální struktury) bez
nutnosti použití čítačů či programových smyček. Jazyk <i>APL</i> s&nbsp;těmito
datovými strukturami pracuje z&nbsp;hlediska programátora prakticky stejně jako
se skalárními hodnotami (čísly), takže například součet položek dvou polí je
zapisován stejně jako součet dvou číselných hodnot. Dalším typickým rysem je
způsob aplikace funkcí na hodnoty (obecně pole) a vzájemné kombinace funkcí
pomocí operátorů (slovem <i>operátor</i> jsou v&nbsp;jazyce <i>APL</i>
označovány funkce vyššího řádu, tj.&nbsp;funkce vracející jiné funkce;
s&nbsp;funkcemi vyššího řádu se můžeme setkat i v&nbsp;mnoha dalších
programovacích jazycích). Pomocí funkcí a operátorů, které jsou přímo
v&nbsp;<i>APL</i> definovány, je možné nahradit i řídicí struktury &ndash;
podmíněné příkazy a programové smyčky &ndash; které dokonce v&nbsp;prvních
verzích jazyka ani nebylo možné zapisovat (v&nbsp;pozdějších verzích se pro
usnadnění programování tyto řídicí struktury do <i>APL</i> přidaly).</p>

<img src="http://i.iinfo.cz/images/131/j-lang1-3.png" width="436" height="425" alt="j_lang1_3" />
<p><i>Obrázek 2: Zápis idiomů (krátkých, v&nbsp;daném kontextu ustálených
výrazů) v&nbsp;jazyku APL se skutečně odlišuje od naprosté většiny ostatních
programovacích jazyků. Zajímavé je, že programátoři mající dlouhodobější
zkušenosti s&nbsp;APL, tyto idiomy nečtou po jednotlivých symbolech, ale po
jejich větších skupinách či dokonce celý idiom jako celek, tj.&nbsp;podobným
způsobem, jakým lidé čtou běžné texty (v&nbsp;nich taktéž mají pro mozek smysl
skupiny symbolů, nikoli jednotlivé znaky, což lidem umožňuje plynule přečíst i
text, v&nbsp;němž jsou některé znaky zpřeházené či nahrazené jinými
písmeny).</i></p>



<p><a name="k03"></a></p>
<h2 id="k03">3. Programovací jazyk J</h2>

<p>Programovací jazyk <i>APL</i> do vývoje některých typů aplikací
(finančnictví, simulace, ...) přinesl mnoho nových myšlenek (ostatně i proto se
doposud používá), ale i několik nectností, ostatně jako každý programovací
jazyk, který vznikl na samotném začátku vývoje interpretrů a překladačů,
tj.&nbsp;v&nbsp;době, kdy ještě nebyla teorie překladačů tak rozvinutá jako
v&nbsp;pozdějších letech (nejvíce byla neexistence teorie překladačů patrná u
prvního překladače <i>Fortranu</i> firmou IBM, jehož vývoj by byl při uplatnění
dnešních znalostí mnohem rychlejší i levnější). Už při letmém pohledu na
programy napsané v&nbsp;programovacím jazyce <i>APL</i> (obrázek číslo 2) je
zřejmé, že se v&nbsp;něm používá velké množství symbolů, které se nenachází ve
znakové sadě ASCII, což je sice velmi unikátní vlastnost (právě proto mnozí
vývojáři v&nbsp;<i>APL</i> programují čistě pro radost), ale způsobuje poměrně
velké problémy, a to jak při zápisu programů (rozložení znaků na klávesnici),
tak i při jejich úpravách, prezentaci na Internetu, protože zdaleka ne všechny
fonty obsahují všechny požadované symboly.</p>

<p>Z&nbsp;výše uvedených důvodů otec jazyka <i>APL</i> (již zmiňovaný
<i>Kenneth Iverson</i>) na počátku devadesátých let minulého století navrhl
nový programovací jazyk nazvaný jednoduše <i>J</i>, který některé výše zmíněné
nedostatky jazyka <i>APL</i> odstranil a navíc jazyk rozšířil o některé
důležité nové rysy, primitivní funkce i operátory. Programovací jazyk <i>J</i>
je, podobně jako jeho ideový předchůdce <i>APL</i>, určen především pro tvorbu
aplikací, v&nbsp;nichž se zpracovávají data uložená ve vektorech, maticích či
polích s&nbsp;větším počtem dimenzí (může se jednat například o hierarchické
mřížky atd.). Z&nbsp;tohoto důvodu je jazyk <i>J</i> vybaven jak jednoduchou
syntaxí určenou pro zápis vektorů a matic, tak i sadou primitivních
(základních) funkcí, pomocí nichž lze nad vektory i maticemi provádět různé
operace.</p>



<p><a name="k04"></a></p>
<h2 id="k04">4. Další programovací jazyky podporující práci s&nbsp;vektory a maticemi</h2>

<p>Práce s&nbsp;vektory a maticemi ovšem nebyla pouze doménou programovacího
jazyka <i>APL</i>. Nesmíme totiž zapomenout na ideového následníka <i>APL</i>,
jímž je programovací jazyk nazvaný <i>J</i> (viz též <a href="#k11">samostatnou
kapitolu</a> s&nbsp;odkazy na další informační zdroje). Kromě dua <i>APL</i> a
<i>J</i> byly maticové operace součástí programovacího jazyka BASIC, konkrétně
jeho původní &bdquo;originální a jediné pravé&ldquo; varianty nazvané
<i>Dartmouth BASIC</i>, který ve své třetí verzi pocházející z&nbsp;roku 1966
obsahoval deklaraci <strong>MAT</strong> doplňující již dříve používanou
deklaraci pole příkazem <i>DIM</i>. Zajímavé přitom je, že se v&nbsp;BASICu
operace pro deklaraci a práci s&nbsp;maticemi objevily dříve než podpora
řetězců, což bylo pravděpodobně způsobeno především tím, že oba autoři BASICu
(John Kemeny a Thomas Kurtz) byli matematici a současně i vývojáři s&nbsp;velmi
dobrou znalostí programovacího jazyka FORTRAN.</p>

<p>V&nbsp;současnosti je používáno relativně velké množství programovacích
jazyků popř.&nbsp;specializovaných knihoven orientovaných na práci
s&nbsp;vektory a poli. Z&nbsp;komerčních nástrojů je zapotřebí jmenovat
především známý <i>MATLAB</i> vydávaný společností <i>MathWorks</i>, nativní
práci s&nbsp;maticemi a vektory ovšem velmi dobře podporuje také nástroj <a
href="https://www.gnu.org/software/octave/doc/interpreter/Matrices.html">GNU
Octave</a> (<a
href="https://gnu.org/software/octave/">https://gnu.org/software/octave/</a>),
<a href="http://www.ats.ucla.edu/stat/r/library/matrix_alg.htm">jazyk R</a> (<a
href="http://www.r-project.org/">http://www.r-project.org/</a>) a také
relativně nový jazyk <i>Julia</i> (<a
href="http://julialang.org/">http://julialang.org/</a>, zajímavé výsledky
benchmarků lze najít na adrese <a
href="http://julialang.org/benchmarks/">http://julialang.org/benchmarks/</a>).
Z&nbsp;knihoven jmenujme především oblíbenou a dnes dosti intenzivně využívanou
Pythonovskou knihovnu <i>NumPy</i> (<a
href="http://www.numpy.org/">http://www.numpy.org/</a>).</p>



<p><a name="k05"></a></p>
<h2 id="k05">5. Programovací jazyk Clojure a knihovny pro práci s vektory a maticemi</h2>

<p>Pojďme si nyní říci, jakým způsobem je práce s&nbsp;maticemi podporována
v&nbsp;programovacím jazyku <i>Clojure</i>. Při studiu základních knihoven
Clojure lze dojít k&nbsp;závěru, že vlastně jen velmi málo funkcí a maker je
určeno pro práci s&nbsp;těmito datovými typy, i když je samozřejmě možné jak
vektory, tak i matice velmi snadno reprezentovat s&nbsp;využitím základních
sekvenčních datových struktur Clojure &ndash; seznamů a vektorů. Ve skutečnosti
to však není zcela ideální řešení, a to hned z&nbsp;několika důvodů, jejichž
společným rysem je rychlost prováděných operací. Z&nbsp;tohoto důvodu je
v&nbsp;případě implementace algoritmů, v&nbsp;nichž se intenzivně používají
operace s&nbsp;maticemi, mnohem výhodnější využít možností specializovaných
knihoven. My se dnes seznámíme především s&nbsp;elegantně navrženou knihovnou
<strong>core.matrix</strong>. Příště se budeme zabývat ještě výkonnějším
řešením: knihovnou <i>Neanderthal</i>, která využívá vysoce optimalizovanou
nativní knihovnu <i>ATLAS (Automatically Tuned Linear Algebra Software)</i>
s&nbsp;možností využití vysokého výpočetního výkonu současných GPU.</p>

<p>V&nbsp;přednášce nazvané velmi příhodně &bdquo;Enter the Matrix&ldquo;,
která je dostupná na adrese <a
href="http://www.slideshare.net/mikeranderson/2013-1114-enter-thematrix">http://www.slideshare.net/mikeranderson/2013-1114-enter-thematrix</a>,
je mj.&nbsp;ukázáno, jakým způsobem jsou v&nbsp;Clojure implementována různá
paradigmata programování. Díky podpoře maker a způsobu zápisu programového kódu
v&nbsp;Clojure lze velmi snadno implementovat různé doménově specifické jazyky
(DSL), mj.&nbsp;i právě jazyk pro array programming:</p>

<table>
<tr><th>Paradigma</th><th>Jazyk</th><th>Implementace v&nbsp;Clojure</th></tr>
<tr><td>funkcionální</td><td>Haskell</td><td>clojure.core</td></tr>
<tr><td>OOP</td><td>Smalltalk</td><td>clojure.core</td></tr>
<tr><td>metaprogramování</td><td>Lisp</td><td>clojure.core</td></tr>
<tr><td>logické</td><td>Prolog</td><td>core.logic</td></tr>
<tr><td>array programming</td><td>APL, J</td><td>core.matrix</td></tr>
</table>

<p><i>(Poznámka: původní tabulka byla upravena a doplněna)</i></p>



<p><a name="k06"></a></p>
<h2 id="k06">6. Knihovna <strong>core.matrix</strong></h2>

<p>Jak jsme si již řekli <a href="#k01">v&nbsp;úvodní kapitole</a>, je knihovna
nazvaná <strong>core.matrix</strong> určená těm vývojářům, kteří ve svých
projektech potřebují provádět velké množství operací s&nbsp;těmito strukturami,
a to na poměrně vysoké úrovni, tj.&nbsp;bez nutnosti přesně specifikovat, jak
mají být matice uloženy v&nbsp;paměti, jakým způsobem provádět operaci násobení
matic atd. Díky tomuto přístupu a taktéž díky vlastnostem programovacího jazyka
<i>Clojure</i> (existence tzv.&nbsp;threading makra a funkcí vyššího řádu) se
práce s&nbsp;maticemi do značné míry začíná podobat práci v&nbsp;APL, až na ten
rozdíl, že algoritmy zapisované v&nbsp;<i>Clojure</i> jsou pro většinu vývojářů
přece jen čitelnější :-). Taktéž jsme si řekli, že <i>rozhraní</i> definované
v&nbsp;knihovně <strong>core.matrix</strong> může mít několik implementací.
V&nbsp;současnosti se jedná o <i>vectorz-clj</i>, <i>Clatrix</i> a
<i>NDArray</i>. V&nbsp;<strong>core.matrix</strong> navíc došlo
k&nbsp;rozšíření operátorů +, - atd. takovým způsobem, že je lze použít i pro
zpracování vektorů a matic (ve skutečnosti se samozřejmě nejedná o skutečné
operátory, protože tento koncept <i>Clojure</i> nepotřebuje).</p>



<p><a name="k07"></a></p>
<h2 id="k07">7. První demonstrační příklad: vítejte v&nbsp;Matrixu</h2>

<p>Základní možnosti nabízené knihovnou <strong>core.matrix</strong> si ukážeme
v&nbsp;dnešním prvním demonstračním příkladu nazvaném jednoduše
<strong>matrix1</strong>. Nejprve s&nbsp;pomocí nástroje <i>Leiningen</i>
vytvoříme adresář s&nbsp;kostrou projektu, a to následujícím příkazem:</p>

<pre>
<strong>lein new app matrix1</strong>
Generating a project called matrix1 based on the 'app' template.
</pre>

<p>Následně je nutné upravit projektový soubor, tj.&nbsp;soubor nazvaný
<strong>project.clj</strong> takovým způsobem, aby se ve vektoru uloženém pod
klíčem <i>:dependencies</i> objevil i prvek specifikující knihovnu
<strong>core.matrix</strong>. Úprava je velmi jednoduchá, jak je ostatně patrné
i z&nbsp;výpisu:</p>

<pre>
(defproject matrix1 "0.1.0-SNAPSHOT"
  :description "FIXME: write description"
  :url "http://example.com/FIXME"
  :license {:name "Eclipse Public License"
            :url "http://www.eclipse.org/legal/epl-v10.html"}
  :dependencies [[org.clojure/clojure "1.6.0"]
                 <strong>[net.mikera/core.matrix "0.34.0"]</strong>]
  :main ^:skip-aot matrix1.core
  :target-path "target/%s"
  :profiles {:uberjar {:aot :all}})
</pre>

<p>Třetím krokem je stažení knihovny <strong>core.matrix</strong> i všech
dalších knihoven, na nichž <strong>core.matrix</strong> závisí. Tento krok opět
zajistí nástroj <i>Leiningen</i>:</p>

<pre>
<strong>lein deps</strong>
Retrieving net/mikera/core.matrix/0.34.0/core.matrix-0.34.0.pom from clojars
Retrieving net/mikera/clojure-pom/0.4.0/clojure-pom-0.4.0.pom from clojars
Retrieving net/mikera/mikera-pom/0.4.0/mikera-pom-0.4.0.pom from central
Retrieving org/sonatype/oss/oss-parent/9/oss-parent-9.pom from central
Retrieving org/clojure/clojure/1.7.0-alpha6/clojure-1.7.0-alpha6.pom from central
Retrieving org/clojure/tools.macro/0.1.5/tools.macro-0.1.5.pom from central
Retrieving org/clojure/clojure/1.4.0/clojure-1.4.0.pom from central
Retrieving org/sonatype/oss/oss-parent/5/oss-parent-5.pom from central
Retrieving org/clojure/tools.macro/0.1.5/tools.macro-0.1.5.jar from central
Retrieving net/mikera/core.matrix/0.34.0/core.matrix-0.34.0.jar from clojars
</pre>

<p>Vlastní zdrojový kód prvního demonstračního příkladu je taktéž poměrně
jednoduchý. Můžeme v&nbsp;něm vidět dvojici příkazů <strong>use</strong>, které
načtou všechny funkce a všechna makra z&nbsp;jmenných prostorů
<strong>clojure.core.matrix</strong> a
<strong>clojure.core.matrix.operators</strong>. Následně se vytvoří čtvercová
matice nazvaná <strong>M</strong> a dvouprvkový vektor nazvaný
<strong>v</strong>, s&nbsp;nimiž je provedeno několik operací. Funkce
<strong>pm</strong> slouží pro výpis obsahu matice na standardní výstup
v&nbsp;&bdquo;pěkném&ldquo; tvaru (<i>pretty print</i>). Lze samozřejmě použít
i funkci <strong>print</strong> či <strong>println</strong>:</p>

<pre>
(ns matrix1.core
    (:gen-class))
&nbsp;
(use 'clojure.core.matrix)
(use 'clojure.core.matrix.operators)
&nbsp;
(defn -main
  "Vitejte v Matrixu..."
  [&amp; args]
  (let [M (matrix [[1 2] [3 4]])
        v (matrix [1 2])]
        (pm M)
        (pm v)
        (pm (* v 2))
        (pm (mul M v))
        (pm (* M M))
        (pm (inner-product M v))))
</pre>

<p>Po spuštění tohoto příkladu se nejdříve vypíšou varování, že ve jmenném
prostoru <strong>core.matrix.operators</strong> došlo k&nbsp;předeklarování
globálních symbolů *, -, /, + a == a po těchto pěti řádcích se vypíše obsah
matice <strong>M</strong>, vektoru <strong>v</strong>, vektoru
<strong>v</strong> vynásobeného dvěma, součinu <strong>M*v</strong>, součinu
<strong>M*M</strong> atd.:</p>

<pre>
WARNING: * already refers to: #'clojure.core/* in namespace: matrix1.core, being replaced by: #'clojure.core.matrix.operators/*
WARNING: - already refers to: #'clojure.core/- in namespace: matrix1.core, being replaced by: #'clojure.core.matrix.operators/-
WARNING: / already refers to: #'clojure.core// in namespace: matrix1.core, being replaced by: #'clojure.core.matrix.operators//
WARNING: + already refers to: #'clojure.core/+ in namespace: matrix1.core, being replaced by: #'clojure.core.matrix.operators/+
WARNING: == already refers to: #'clojure.core/== in namespace: matrix1.core, being replaced by: #'clojure.core.matrix.operators/==
[[1.000 2.000]
 [3.000 4.000]]
[1.000 2.000]
[2.000 4.000]
[[1.000 4.000]
 [3.000 8.000]]
[[1.000  4.000]
 [9.000 16.000]]
[5.000 11.000]
</pre>



<p><a name="k08"></a></p>
<h2 id="k08">8. Další vlastnosti knihovny <strong>core.matrix</strong> zkoumané s&nbsp;využitím REPLu</h2>

<p>Funkce a makra nabízená knihovnou <strong>core.matrix</strong> nejlépe
prozkoumáme přímo s&nbsp;využitím REPLu, tj.&nbsp;interaktivního rozhraní,
v&nbsp;němž ihned po zadání dochází k&nbsp;expanzi maker a vyhodnocování
funkcí. Pro tyto účely vytvoříme nový demonstrační příklad:</p>

<pre>
<strong>lein new app matrixtest</strong>
Generating a project called matrixtest based on the 'app' template.
</pre>

<p>Soubor <strong>project.clj</strong> bude vypadat následovně:</p>

<pre>
(defproject matrixtest "0.1.0-SNAPSHOT"
  :description "FIXME: write description"
  :url "http://example.com/FIXME"
  :license {:name "Eclipse Public License"
            :url "http://www.eclipse.org/legal/epl-v10.html"}
  :dependencies [[org.clojure/clojure "1.6.0"]
                 <strong>[net.mikera/core.matrix "0.34.0"]</strong>]
  :main ^:skip-aot matrixtest.core
  :target-path "target/%s"
  :profiles {:uberjar {:aot :all}})
</pre>

<p>Vlastní zdrojový kód projektu je pojat minimalisticky, protože slouží jen
pro inicializaci knihoven po spuštění REPLu:</p>

<pre>
(use 'clojure.core.matrix)
(use 'clojure.core.matrix.operators)
&nbsp;
(println "Vitejte v Matrixu")
</pre>

<p>Nyní již můžeme REPL spustit a ihned začít s&nbsp;experimenty:</p>

<pre>
<strong>lein repl</strong>
WARNING: * already refers to: #'clojure.core/* in namespace: matrixtest.core, being replaced by: #'clojure.core.matrix.operators/*
WARNING: - already refers to: #'clojure.core/- in namespace: matrixtest.core, being replaced by: #'clojure.core.matrix.operators/-
WARNING: / already refers to: #'clojure.core// in namespace: matrixtest.core, being replaced by: #'clojure.core.matrix.operators//
WARNING: + already refers to: #'clojure.core/+ in namespace: matrixtest.core, being replaced by: #'clojure.core.matrix.operators/+
WARNING: == already refers to: #'clojure.core/== in namespace: matrixtest.core, being replaced by: #'clojure.core.matrix.operators/==
Vitejte v Matrixu
nREPL server started on port 38018 on host 127.0.0.1 - nrepl://127.0.0.1:38018
REPL-y 0.3.5, nREPL 0.2.6
Clojure 1.6.0
OpenJDK 64-Bit Server VM 1.7.0_79-b14
    Docs: (doc function-name-here)
          (find-doc "part-of-name-here")
  Source: (source function-name-here)
 Javadoc: (javadoc java-object-or-class-here)
    Exit: Control+D or (exit) or (quit)
 Results: Stored in vars *1, *2, *3, an exception in *e
</pre>

<h3>Konstrukce vektorů a matic</h3>

<pre>
<i>; vektor</i>
matrixtest.core=&gt; <strong>(matrix [1 2 3])</strong>
[1 2 3]
&nbsp;
<i>; vektor</i>
matrixtest.core=&gt; <strong>(matrix '(1 2 3))</strong>
[1 2 3]
&nbsp;
<i>; matice</i>
matrixtest.core=&gt; <strong>(matrix [[1 2] [3 4]])</strong>
[[1 2] [3 4]]
&nbsp;
<i>; matice</i>
matrixtest.core=&gt; <strong>(matrix (range 1 10))</strong>
[1 2 3 4 5 6 7 8 9]
&nbsp;
<i>; matice</i>
matrixtest.core=&gt; <strong>(matrix [[1 2 3] [4 5 6] [7 8 9]])</strong>
[[1 2 3] [4 5 6] [7 8 9]]
</pre>

<h3>Pretty printing matic a vektorů</h3>

<pre>
matrixtest.core=&gt; <strong>(pm (matrix [[1 2] [3 4]]))</strong>
[[1.000 2.000]
 [3.000 4.000]]
&nbsp;
matrixtest.core=&gt; <strong>(matrix [[1 2] [3 4]])</strong>
[[1 2] [3 4]]
&nbsp;
<i>; *1 obsahuje výsledek poslední vyhodnocené funkce či symbolu</i>
matrixtest.core=&gt; <strong>(pm *1)</strong>
[[1.000 2.000]
 [3.000 4.000]]
</pre>

<h3>Konstruktory nulové matice a jednotkové matice</h3>

<pre>
matrixtest.core=&gt; <strong>(zero-matrix 2 3)</strong>
[[0.0 0.0 0.0] [0.0 0.0 0.0]]
&nbsp;
matrixtest.core=&gt; <strong>(pm *1)</strong>
[[0.000 0.000 0.000]
 [0.000 0.000 0.000]]
&nbsp;
matrixtest.core=&gt; <strong>(zero-matrix 4 4)</strong>
[[0.0 0.0 0.0 0.0] [0.0 0.0 0.0 0.0] [0.0 0.0 0.0 0.0] [0.0 0.0 0.0 0.0]]
&nbsp;
matrixtest.core=&gt; <strong>(pm *1)</strong>
[[0.000 0.000 0.000 0.000]
 [0.000 0.000 0.000 0.000]
 [0.000 0.000 0.000 0.000]
 [0.000 0.000 0.000 0.000]]
&nbsp;
matrixtest.core=&gt; <strong>(identity-matrix 4 4)</strong>
[[1.0 0.0 0.0 0.0] [0.0 1.0 0.0 0.0] [0.0 0.0 1.0 0.0] [0.0 0.0 0.0 1.0]]
&nbsp;
matrixtest.core=&gt; <strong>(pm *1)</strong>
[[1.000 0.000 0.000 0.000]
 [0.000 1.000 0.000 0.000]
 [0.000 0.000 1.000 0.000]
 [0.000 0.000 0.000 1.000]]
</pre>

<h3>Konstruktor permutační matice</h3>

<pre>
<i>; vektor udává pozice jedniček na jednotlivých řádcích matice</i>
<i>; rozměry matice jsou získány na základě velikosti tohoto vektoru</i>
matrixtest.core=&gt; <strong>(permutation-matrix [1 4 2 3 0])</strong>
#NDArray [[0.0 1.0 0.0 0.0 0.0] [0.0 0.0 0.0 0.0 1.0] [0.0 0.0 1.0 0.0 0.0] [0.0 0.0 0.0 1.0 0.0] [1.0 0.0 0.0 0.0 0.0]]
&nbsp;
matrixtest.core=&gt; <strong>(pm *1)</strong>
[[0.000 1.000 0.000 0.000 0.000]
 [0.000 0.000 0.000 0.000 1.000]
 [0.000 0.000 1.000 0.000 0.000]
 [0.000 0.000 0.000 1.000 0.000]
 [1.000 0.000 0.000 0.000 0.000]]
</pre>

<h3>Transpozice matice</h3>

<pre>
matrixtest.core=&gt; <strong>(def M (matrix [[1 2] [3 4]]))</strong>
#'matrixtest.core/M
&nbsp;
matrixtest.core=&gt; <strong>M</strong>
[[1 2] [3 4]]
&nbsp;
matrixtest.core=&gt; <strong>(pm *1)</strong>
[[1.000 2.000]
 [3.000 4.000]]
&nbsp;
matrixtest.core=&gt; <strong>(transpose M)</strong>
[[1 3] [2 4]]
&nbsp;
<i>; vypíše se hodnota transponované matice, původní matice M se nemění</i>
matrixtest.core=&gt; <strong>(pm *1)</strong>
[[1.000 3.000]
 [2.000 4.000]]
</pre>

<h3>Unární a binární operace nad maticemi</h3>

<pre>
matrixtest.core=&gt; <strong>(def M1 (matrix [[1 2][3 4]]))</strong>
#'matrixtest.core/M1
&nbsp;
matrixtest.core=&gt; <strong>(def M2 (matrix [[5 6][7 8]]))</strong>
#'matrixtest.core/M2
&nbsp;
matrixtest.core=&gt; <strong>(pm (+ M1 M2))</strong>
[[ 6.000  8.000]
 [10.000 12.000]]
&nbsp;
matrixtest.core=&gt; <strong>(pm (- M1 M2))</strong>
[[-4.000 -4.000]
 [-4.000 -4.000]]
&nbsp;
matrixtest.core=&gt; <strong>(pm (* M1 M2))</strong>
[[ 5.000 12.000]
 [21.000 32.000]]
&nbsp;
matrixtest.core=&gt; <strong>(pm (* M1 100))</strong>
[[100.000 200.000]
 [300.000 400.000]]
&nbsp;
<i>; zde se nejdříve vypočte inverzní matice k M1</i>
matrixtest.core=&gt; <strong>(pm (/ M2 M1))</strong>
[[5.000 3.000]
 [2.333 2.000]]
&nbsp;
matrixtest.core=&gt; <strong>(inverse M1)</strong>
#NDArrayDouble [[-1.9999999999999998 1.0] [1.4999999999999998 -0.49999999999999994]]
&nbsp;
matrixtest.core=&gt; <strong>(inverse M2)</strong>
#NDArrayDouble [[-4.000000000000002 3.0000000000000013] [3.5000000000000018 -2.5000000000000013]]
</pre>

<h3>Funkce vracející informaci o tom, zda je hodnota skalárem či maticí</h3>

<pre>
matrixtest.core=&gt; <strong>(def v (matrix [1 2 3 4 5 6]))</strong>
#'matrixtest.core/v
&nbsp;
matrixtest.core=&gt; <strong>(def M (matrix [[1 2] [3 4]]))</strong>
#'matrixtest.core/M
&nbsp;
<i>; jen 42 je skalární hodnota</i>
matrixtest.core=&gt; <strong>(for [obj [42 v M MD]] (array? obj))</strong>
(false true true true)
&nbsp;
<i>; jen 42 je skalární hodnota</i>
matrixtest.core=&gt; <strong>(for [obj [42 v M MD]] (scalar? obj))</strong>
(true false false false)
</pre>

<h3>Funkce vracející informace o maticích (počet dimenzí a tvar)</h3>

<pre>
matrixtest.core=&gt; <strong>(def v (matrix [1 2 3 4 5 6]))</strong>
#'matrixtest.core/v
&nbsp;
matrixtest.core=&gt; <strong>(def M (matrix [[1 2] [3 4]]))</strong>
#'matrixtest.core/M
&nbsp;
<i>; trojrozměrná matice</i>
matrixtest.core=&gt; <strong>(def MD (matrix [[ [1 2] [3 4] ] [ [5 6] [7 8] ] ]))</strong>
#'matrixtest.core/MD
&nbsp;
matrixtest.core=&gt; <strong>(pm MD)</strong>
[[[1.000 2.000]
  [3.000 4.000]]
 [[5.000 6.000]
  [7.000 8.000]]]
&nbsp;
matrixtest.core=&gt; <strong>(dimensionality v)</strong>
1
&nbsp;
matrixtest.core=&gt; <strong>(dimensionality M)</strong>
2
&nbsp;
matrixtest.core=&gt; <strong>(dimensionality MD)</strong>
3
&nbsp;
matrixtest.core=&gt; <strong>(dimensionality 1)</strong>
0
&nbsp;
matrixtest.core=&gt; <strong>(shape M)</strong>
[2 2]
&nbsp;
matrixtest.core=&gt; <strong>(shape v)</strong>
[6]
&nbsp;
matrixtest.core=&gt; <strong>(shape MD)</strong>
[2 2 2]
</pre>

<h3>Přečtení hodnoty prvku matice a získání řezu (slice)</h3>

<pre>
matrixtest.core=&gt; <strong>(mget M 0 0)</strong>
1
&nbsp;
matrixtest.core=&gt; <strong>(slice v 1)</strong>
2
&nbsp;
<i>; řez 2D maticí</i>
matrixtest.core=&gt; <strong>(slice M 1)</strong>
[3 4]
&nbsp;
<i>; řez 3D maticí</i>
matrixtest.core=&gt; <strong>(slice MD 1)</strong>
[[5 6] [7 8]]
&nbsp;
<i>; operace nad řezy</i>
matrixtest.core=&gt; <strong>(for [slice (slices M)] (apply + slice))</strong>
(3 7)
&nbsp;
<i>; vektorová! operace nad řezy</i>
matrixtest.core=&gt; <strong>(apply + (slices M))</strong>
[4 6]
</pre>

<h3>Změna tvaru matice</h3>

<pre>
matrixtest.core=&gt; <strong>(def v (matrix [1 2 3 4 5 6]))</strong>
#'matrixtest.core/v
&nbsp;
matrixtest.core=&gt; <strong>v</strong>
[1 2 3 4 5 6]
&nbsp;
<i>; velmi užitečná funkce převzatá z APL: vektor převeden na matici</i>
matrixtest.core=&gt; <strong>(reshape v [2 3])</strong>
[[1 2 3] [4 5 6]]
&nbsp;
matrixtest.core=&gt; <strong>(pm *1)</strong>
[[1.000 2.000 3.000]
 [4.000 5.000 6.000]]
&nbsp;
<i>; jiný tvar matice</i>
matrixtest.core=&gt; <strong>(reshape v [3 2])</strong>
[[1 2] [3 4] [5 6]]
&nbsp;
matrixtest.core=&gt; <strong>(pm *1)</strong>
[[1.000 2.000]
 [3.000 4.000]
 [5.000 6.000]]
&nbsp;
matrixtest.core=&gt; <strong>(reshape v [1 6])</strong>
[[1 2 3 4 5 6]]
&nbsp;
matrixtest.core=&gt; <strong>(pm *1)</strong>
[[1.000 2.000 3.000 4.000 5.000 6.000]]
&nbsp;
matrixtest.core=&gt; <strong>(reshape v [6 1])</strong>
[[1] [2] [3] [4] [5] [6]]
&nbsp;
<i>; sloupec z&nbsp;vektoru</i>
matrixtest.core=&gt; <strong>(pm *1)</strong>
[[1.000]
 [2.000]
 [3.000]
 [4.000]
 [5.000]
 [6.000]]
</pre>

<h3>Využití makra -&gt; ke kompozici operací</h3>

<pre>
<i>; jedná se o oneliner rozepsaný kvůli větší čitelnosti na čtyři řádky</i>
<strong>(-&gt; (matrix (range 1 101))
    (reshape [10 10])
    transpose
    pm)</strong>
[[ 1.000 11.000 21.000 31.000 41.000 51.000 61.000 71.000 81.000  91.000]
 [ 2.000 12.000 22.000 32.000 42.000 52.000 62.000 72.000 82.000  92.000]
 [ 3.000 13.000 23.000 33.000 43.000 53.000 63.000 73.000 83.000  93.000]
 [ 4.000 14.000 24.000 34.000 44.000 54.000 64.000 74.000 84.000  94.000]
 [ 5.000 15.000 25.000 35.000 45.000 55.000 65.000 75.000 85.000  95.000]
 [ 6.000 16.000 26.000 36.000 46.000 56.000 66.000 76.000 86.000  96.000]
 [ 7.000 17.000 27.000 37.000 47.000 57.000 67.000 77.000 87.000  97.000]
 [ 8.000 18.000 28.000 38.000 48.000 58.000 68.000 78.000 88.000  98.000]
 [ 9.000 19.000 29.000 39.000 49.000 59.000 69.000 79.000 89.000  99.000]
 [10.000 20.000 30.000 40.000 50.000 60.000 70.000 80.000 90.000 100.000]]
&nbsp;
<i>; sekvence operací aplikovaných na matici M1</i>
<strong>(-&gt; M1
    transpose
    inverse
    (* 10000)
    transpose
    (* M2)
    (+ M1)
    pm)</strong>
[[-99999.000  60002.000]
 [105003.000 -39996.000]]
</pre>



<p><a name="k09"></a></p>
<h2 id="k09">9. Repositář s&nbsp;demonstračními příklady</h2>

<p>Oba dva dnes popsané demonstrační příklady byly, podobně jako v&nbsp;minulé
i předminulé části tohoto článku, uloženy do GIT repositáře dostupného na
adrese <a
href="https://github.com/tisnik/clojure-examples">https://github.com/tisnik/clojure-examples</a>
(dříve popsané příklady budou přidány později). V&nbsp;tabulce zobrazené pod
tímto odstavcem naleznete na jednotlivé příklady přímé odkazy:</p>

<table>
<tr><th>#</th><th>Příklad</th><th>Github</th></tr>
<tr><td>1</td><td>matrix1</td><td><a href="https://github.com/tisnik/clojure-examples/tree/master/matrix1">https://github.com/tisnik/clojure-examples/tree/master/matrix1</a></td></tr>
<tr><td>2</td><td>matrixtest</td><td><a href="https://github.com/tisnik/clojure-examples/tree/master/matrixtest">https://github.com/tisnik/clojure-examples/tree/master/matrixtest</a></td></tr>
</table>



<p><a name="k10"></a></p>
<h2 id="k10">10. Odkazy na předchozí části seriálu</h2>

<ol>

<li>Leiningen: nástroj pro správu projektů napsaných v Clojure<br />
<a href="http://www.root.cz/clanky/leiningen-nastroj-pro-spravu-projektu-napsanych-v-clojure/">http://www.root.cz/clanky/leiningen-nastroj-pro-spravu-projektu-napsanych-v-clojure/</a>
</li>

<li>Leiningen: nástroj pro správu projektů napsaných v Clojure (2)<br />
<a href="http://www.root.cz/clanky/leiningen-nastroj-pro-spravu-projektu-napsanych-v-clojure-2/">http://www.root.cz/clanky/leiningen-nastroj-pro-spravu-projektu-napsanych-v-clojure-2/</a>
</li>

<li>Leiningen: nástroj pro správu projektů napsaných v Clojure (3)<br />
<a href="http://www.root.cz/clanky/leiningen-nastroj-pro-spravu-projektu-napsanych-v-clojure-3/">http://www.root.cz/clanky/leiningen-nastroj-pro-spravu-projektu-napsanych-v-clojure-3/</a>
</li>

<li>Leiningen: nástroj pro správu projektů napsaných v Clojure (4)<br />
<a href="http://www.root.cz/clanky/leiningen-nastroj-pro-spravu-projektu-napsanych-v-clojure-4/">http://www.root.cz/clanky/leiningen-nastroj-pro-spravu-projektu-napsanych-v-clojure-4/</a>
</li>

<li>Leiningen: nástroj pro správu projektů napsaných v Clojure (5)<br />
<a href="http://www.root.cz/clanky/leiningen-nastroj-pro-spravu-projektu-napsanych-v-clojure-5/">http://www.root.cz/clanky/leiningen-nastroj-pro-spravu-projektu-napsanych-v-clojure-5/</a>
</li>

<li>Leiningen: nástroj pro správu projektů napsaných v Clojure (6)<br />
<a href="http://www.root.cz/clanky/leiningen-nastroj-pro-spravu-projektu-napsanych-v-clojure-6/">http://www.root.cz/clanky/leiningen-nastroj-pro-spravu-projektu-napsanych-v-clojure-6/</a>
</li>

<li>Programovací jazyk Clojure a databáze (1.část)<br />
<a href="http://www.root.cz/clanky/programovaci-jazyk-clojure-a-databaze-1-cast/">http://www.root.cz/clanky/programovaci-jazyk-clojure-a-databaze-1-cast/</a>
</li>

<li>Pluginy pro Leiningen<br />
<a href="http://www.root.cz/clanky/leiningen-nastroj-pro-spravu-projektu-napsanych-v-clojure-pluginy-pro-leiningen/">http://www.root.cz/clanky/leiningen-nastroj-pro-spravu-projektu-napsanych-v-clojure-pluginy-pro-leiningen/</a>
</li>

</ol>



<p><a name="k11"></a></p>
<h2 id="k11">11. Knihy a články o programovacích jazycích APL a J</h2>

<ol>

<li>Ajay Askoolum, &bdquo;<i>System Building with APL + WIN,</i>&ldquo;<br />Wiley, ISBN: 0-470-03020-8, August 2006.</li>

<li>Brown et. al. &bdquo;<i>APL2 at a Glance,</i>&ldquo;<br />Prentice Hall, ISBN 0-13-038670-7.</li>

<li>T. Budd, &bdquo;<i>An APL Compiler,</i>&ldquo;<br />Springer-Verlag.</li>

<li>Maurice Dalois, &bdquo;<i>Introduction to APL*PLUS PC,</i>&ldquo;</li>

<li>J. Ever and C. Fair, &bdquo;<i>Guidelines for APL Systems,</i>&ldquo;<br />DPD 22 IBM 037301, March 1976.</li>

<li>Gilman and Rose, &bdquo;<i>APL - An Interactive Approach,</i>&ldquo;<br /> Wiley, ISBN 220-471-30022-5.</li>

<li>Ulf Grenander, &bdquo;<i>Mathematical Experiments on the Computer,</i>&ldquo;<br />Academic Press, 1982, ISBN 0-12-301750-5.</li>

<li>Kent Haralson, &bdquo;<i>Useful APL Defined Functions</i>&ldquo;,<br />IBM Technical Report, TR 00.2409, Feb. 8 1973.</li>

<li>Timothy Holls, &bdquo;<i>APL Programming Guide,</i>&ldquo;<br />IBM G320-6103, 1978, and G320-6735, 1981.</li>

<li>IBM, &bdquo;<i>APL2 Programming: Language Reference</i>&ldquo;<br />(Version 2, SH21-1061; Version 1, SH20-9227).</li>

<li>IBM, &bdquo;<i>The APL Handbook of Techniques</i>&ldquo;,<br />IBM publication number S320-5996, April 1978.</li>

<li>IBM, &bdquo;<i>The IBM System Journal, V. 30, No. 4 (1991)</i>&ldquo;,<br />Special Issue Devoted to APL.</li>

<li>MicroAPL, &bdquo;<i>Learning APL with APLX</i>&ldquo;,<br />Version 5.0 July 2009</li>

<li>A.D. Falkoff, K.E Iverson, E.H Sussenguth, &bdquo;<i>A formal description of System/360,</i>&ldquo;<br />The IBM System Journal, V. 3, No. 3 (1964)</li>

<li>K. E. Iverson, &bdquo;<i>A Programming Language</i>&ldquo;,<br />Wiley, 1962.</li>

<li>K. E. Iverson, &bdquo;<i>Algebra : an algorithmic treatment</i>&ldquo;,<br />APL Press 1977, Copyright 1972 by Addison Wesley,<br />Preliminary Edition entitled &bdquo;<i>Elementary Algebra</i>&ldquo;<br />Copyright 1971 by IBM Corporation.</li>

<li>K. E. Iverson, &bdquo;<i>Elementary analysis</i>&ldquo;,<br />APL press 1976, Preliminary Edition &bdquo;<i>Elementary Functions</i>&ldquo;<br />Copyright 1974 by IBM Corporation ISBN 0-917326-01-6</li>

<li>K. E. Iverson, &bdquo;<i>An introduction to APL for Scientists and Engineers</i>&ldquo;,<br />APL Press 1976,<br />First published by IMB Corporation as Technical Report No 320-3019 March 1973 - ISBN 0-917326-04-0</li>

<li>K. E. Iverson, &bdquo;<i>APL in exposition</i>&ldquo;,<br />APL Press 1976,<br />First published by IBM Corporation as Technical Report No 320-3010 March 1973 - ISBN 0-917326-02-4.</li>

<li>K. E. Iverson, &bdquo;<i>Introduction To APL</i>&ldquo;,<br />(1984-APL Press Palo Alto) ISBN 0-917326-14-8.</li>

<li>K. E. Iverson, &bdquo;<i>A personal view of APL,</i>&ldquo;<br />IBM Systems Journal,</li>

<li> K. E. Iverson, &bdquo;<i>Concrete Mathematics Companion</i>&ldquo;.</li>

<li>S. Kamin, &bdquo;<i>Programming Languages: An Interpreter-Based Approach,</i>&ldquo;<br />contains (among other things) toy implementations of Lisp, APL, Scheme, SASL, CLU, Smalltalk, and Prolog, Addison-Wesley, 1990, ISBN 0-201-06824-9.</li>

<li>Bernard LEGRAND, &bdquo;<i>Les APL Etendus,</i>&ldquo;<br />Masson, Paris, 1994. An introduction to modern APL (French).</li>

<li>Jon McGrew, &bdquo;<i>An Introduction to APL2,</i>&ldquo;<br />IBM (SH20-9229).</li>

<li>James A. Mason, &bdquo;<i>Learning APL: An Array Processing Language,</i>&ldquo;<br />Harper &amp; Row Publishers Inc., New York, 1986, ISBN 0-06-044243-3 260 pp.</li>

<li>Peelle, &bdquo;<i>APL an Introduction</i>&ldquo;,<br />Holt, Rinehart &amp; Winston, ISBN 0-03-004953-9.</li>

<li>Reiter &amp; Jones, &bdquo;<i>APL with a Mathematical Accent</i>&ldquo;,<br />Brooks/Cole ISBN 0-534-12864-5, (now being distributed by Chapman &amp; Hall).</li>

<li>C. Reiter, &bdquo;<i>Fractuals Visualization and J</i>&ldquo;,<br />Iverson Software, Inc, 1995 ISBN 1-895721-11-3.</li>

<li>Adrian Smith, &bdquo;<i>APL, A Design Handbook for Commercial Systems,</i>&ldquo;<br />Wiley series in information processing, Wiley &amp; Sons, 1982, ISBN 0-471-10092-7.</li>

<li>D. Stiers, M.J. Goovaerts, J. De Kerf, &bdquo;<i>APL - The Language and its Actuarial Applications</i>&ldquo;</li>

<li>Norman D. Thomson, Raymond P. Polivka, &bdquo;<i>APL2 in Depth,</i>&ldquo;<br />Springer-Verlag, 1995, ISBN 0-387-94213-0.</li>

<li>Jerry R. Turner, &bdquo;<i>APL IS EASY!,</i>&ldquo;<br />Manugistics, 1993.</li>

<li>&bdquo;<i>SHARP APL Reference Manual,</i>&ldquo;<br />2nd ed., Soliton Associates Limited PC Version: Iverson Software, 1993, ISBN 1-895721-07-5.</li>

<li>&bdquo;<i>A Source Book in APL,</i>&ldquo;<br />APL Press, 1981, ISBN 0-917326-10-5.</li>

<li>&bdquo;<i>J Phrases,</i>&ldquo;<br />Iverson Software, 1996, ISBN 1-895721-12-1</li>

<li>&bdquo;<i>Exploring Math</i>&ldquo;, Iverson Software, 1996, ISBN 1-895721-13-X</li>

<li>&bdquo;<i>J Primer,</i>&ldquo;<br />Iverson Software, 1996, ISBN 1-895721-14-8</li>

<li>Linda Alvord and Norman Thomson, &bdquo;<i>Easy-J: An Introduction to the World's most Remarkable Programming Language</i>&ldquo;<br />October 2002</li>

</ol>



<p><a name="k12"></a></p>
<h2 id="k12">12. Odkazy na Internetu</h2>

<ol>

<li>The Clojure Toolbox<br />
<a href="http://www.clojure-toolbox.com/">http://www.clojure-toolbox.com/</a>
</li>

<li>Neanderthal<br />
<a href="http://neanderthal.uncomplicate.org/">http://neanderthal.uncomplicate.org/</a>
</li>

<li>Hello world project<br />
<a href="https://github.com/uncomplicate/neanderthal/blob/master/examples/hello-world/project.clj">https://github.com/uncomplicate/neanderthal/blob/master/examples/hello-world/project.clj</a>
</li>

<li>vectorz-clj<br />
<a href="https://github.com/mikera/vectorz-clj">https://github.com/mikera/vectorz-clj</a>
</li>

<li>vectorz - Examples<br />
<a href="https://github.com/mikera/vectorz-clj/wiki/Examples">https://github.com/mikera/vectorz-clj/wiki/Examples</a>
</li>

<li>gloss<br />
<a href="https://github.com/ztellman/gloss">https://github.com/ztellman/gloss</a>
</li>

<li>HTTP client/server for Clojure<br />
<a href="http://www.http-kit.org/">http://www.http-kit.org/</a>
</li>

<li>Array Programming<br />
<a href="https://en.wikipedia.org/wiki/Array_programming">https://en.wikipedia.org/wiki/Array_programming</a>
</li>

<li>Discovering Array Languages<br />
<a href="http://archive.vector.org.uk/art10008110">http://archive.vector.org.uk/art10008110</a>
</li>

<li>no stinking loops -- Kalothi<br />
<a href="http://www.nsl.com/">http://www.nsl.com/</a>
</li>

<li>Vector (obsahuje odkazy na články, knihy a blogy o programovacích jazycích APL, J a K)<br />
<a href="http://www.vector.org.uk/">http://www.vector.org.uk/</a>
</li>

<li>APL Interpreters<br />
<a href="http://www.vector.org.uk/?area=interpreters">http://www.vector.org.uk/?area=interpreters</a>
</li>

<li>APL_(programming_language<br />
<a href="http://en.wikipedia.org/wiki/APL_(programming_language">http://en.wikipedia.org/wiki/APL_(programming_language</a>
</li>

<li>APL FAQ<br />
<a href="http://www.faqs.org/faqs/apl-faq/">http://www.faqs.org/faqs/apl-faq/</a>
</li>

<li>APL FAQ (nejnovější verze)<br />
<a href="http://home.earthlink.net/~swsirlin/apl.faq.html">http://home.earthlink.net/~swsirlin/apl.faq.html</a>
</li>

<li>A+<br />
<a href="http://www.aplusdev.org/">http://www.aplusdev.org/</a>
</li>

<li>APLX<br />
<a href="http://www.microapl.co.uk/">http://www.microapl.co.uk/</a>
</li>

<li>FreeAPL<br />
<a href="http://www.pyr.fi/apl/index.htm">http://www.pyr.fi/apl/index.htm</a>
</li>

<li>J: a modern, high-level, general-purpose, high-performance programming language<br />
<a href="http://www.jsoftware.com/">http://www.jsoftware.com/</a>
</li>

<li>K, Kdb: an APL derivative for Solaris, Linux, Windows<br />
<a href="http://www.kx.com">http://www.kx.com</a>
</li>

<li>openAPL (GPL)<br />
<a href="http://sourceforge.net/projects/openapl">http://sourceforge.net/projects/openapl</a>
</li>

<li>Parrot APL (GPL)<br />
<a href="http://www.parrotcode.org/">http://www.parrotcode.org/</a>
</li>

<li>Learning J (Roger Stokes)<br />
<a href="http://www.jsoftware.com/help/learning/contents.htm">http://www.jsoftware.com/help/learning/contents.htm</a>
</li>

<li>Rosetta Code<br />
<a href="http://rosettacode.org/wiki/Main_Page">http://rosettacode.org/wiki/Main_Page</a>
</li>

<li>Why APL<br />
<a href="http://www.acm.org/sigapl/whyapl.htm">http://www.acm.org/sigapl/whyapl.htm</a>
</li>

<li>java.jdbc API Reference<br />
<a href="https://clojure.github.io/java.jdbc/">https://clojure.github.io/java.jdbc/</a>
</li>

<li>Hiccup<br />
<a href="https://github.com/weavejester/hiccup">https://github.com/weavejester/hiccup</a>
</li>

<li>Clojure Ring na GitHubu<br />
<a href="https://github.com/ring-clojure/ring">https://github.com/ring-clojure/ring</a>
</li>

<li>A brief overview of the Clojure web stack<br />
<a href="https://brehaut.net/blog/2011/ring_introduction">https://brehaut.net/blog/2011/ring_introduction</a>
</li>

<li>Getting Started with Ring<br />
<a href="http://www.learningclojure.com/2013/01/getting-started-with-ring.html">http://www.learningclojure.com/2013/01/getting-started-with-ring.html</a>
</li>

<li>Getting Started with Ring and Compojure - Clojure Web Programming<br />
<a href="http://www.myclojureadventure.com/2011/03/getting-started-with-ring-and-compojure.html">http://www.myclojureadventure.com/2011/03/getting-started-with-ring-and-compojure.html</a>
</li>

<li>Unit Testing in Clojure<br />
<a href="http://nakkaya.com/2009/11/18/unit-testing-in-clojure/">http://nakkaya.com/2009/11/18/unit-testing-in-clojure/</a>
</li>

<li>Testing in Clojure (Part-1: Unit testing)<br />
<a href="http://blog.knoldus.com/2014/03/22/testing-in-clojure-part-1-unit-testing/">http://blog.knoldus.com/2014/03/22/testing-in-clojure-part-1-unit-testing/</a>
</li>

<li>API for clojure.test - Clojure v1.6 (stable)<br />
<a href="https://clojure.github.io/clojure/clojure.test-api.html">https://clojure.github.io/clojure/clojure.test-api.html</a>
</li>

<li>Leiningen: úvodní stránka<br />
<a href="http://leiningen.org/">http://leiningen.org/</a>
</li>

<li>Leiningen: Git repository<br />
<a href="https://github.com/technomancy/leiningen">https://github.com/technomancy/leiningen</a>
</li>

<li>leiningen-win-installer<br />
<a href="http://leiningen-win-installer.djpowell.net/">http://leiningen-win-installer.djpowell.net/</a>
</li>

<li>Clojure  1: Úvod<br />
<a href="http://www.root.cz/clanky/clojure-aneb-jazyk-umoznujici-tvorbu-bezpecnych-vicevlaknovych-aplikaci-pro-jvm/">http://www.root.cz/clanky/clojure-aneb-jazyk-umoznujici-tvorbu-bezpecnych-vicevlaknovych-aplikaci-pro-jvm/</a>
</li>

<li>Clojure  2: Symboly, kolekce atd.<br />
<a href="http://www.root.cz/clanky/clojure-aneb-jazyk-umoznujici-tvorbu-bezpecnych-vicevlaknovych-aplikaci-pro-jvm-2-cast/">http://www.root.cz/clanky/clojure-aneb-jazyk-umoznujici-tvorbu-bezpecnych-vicevlaknovych-aplikaci-pro-jvm-2-cast/</a>
</li>

<li>Clojure  3: Funkcionální programování<br />
<a href="http://www.root.cz/clanky/clojure-aneb-jazyk-umoznujici-tvorbu-bezpecnych-vicevlaknovych-aplikaci-pro-jvm-3-cast-funkcionalni-programovani/">http://www.root.cz/clanky/clojure-aneb-jazyk-umoznujici-tvorbu-bezpecnych-vicevlaknovych-aplikaci-pro-jvm-3-cast-funkcionalni-programovani/</a>
</li>

<li>Clojure  4: Kolekce, sekvence a lazy sekvence<br />
<a href="http://www.root.cz/clanky/clojure-aneb-jazyk-umoznujici-tvorbu-bezpecnych-vicevlaknovych-aplikaci-pro-jvm-4-cast-kolekce-sekvence-a-lazy-sekvence/">http://www.root.cz/clanky/clojure-aneb-jazyk-umoznujici-tvorbu-bezpecnych-vicevlaknovych-aplikaci-pro-jvm-4-cast-kolekce-sekvence-a-lazy-sekvence/</a>
</li>

<li>Clojure  5: Sekvence, lazy sekvence a paralelní programy<br />
<a href="http://www.root.cz/clanky/clojure-a-bezpecne-aplikace-pro-jvm-sekvence-lazy-sekvence-a-paralelni-programy/">http://www.root.cz/clanky/clojure-a-bezpecne-aplikace-pro-jvm-sekvence-lazy-sekvence-a-paralelni-programy/</a>
</li>

<li>Clojure  6: Podpora pro paralelní programování<br />
<a href="http://www.root.cz/clanky/programovaci-jazyk-clojure-6-futures-nejsou-jen-financni-derivaty/">http://www.root.cz/clanky/programovaci-jazyk-clojure-6-futures-nejsou-jen-financni-derivaty/</a>
</li>

<li>Clojure  7: Další funkce pro paralelní programování<br />
<a href="http://www.root.cz/clanky/programovaci-jazyk-clojure-7-dalsi-podpurne-prostredky-pro-paralelni-programovani/">http://www.root.cz/clanky/programovaci-jazyk-clojure-7-dalsi-podpurne-prostredky-pro-paralelni-programovani/</a>
</li>

<li>Clojure  8: Identity, stavy, neměnné hodnoty a reference<br />
<a href="http://www.root.cz/clanky/programovaci-jazyk-clojure-8-identity-stavy-nemenne-hodnoty-a-referencni-typy/">http://www.root.cz/clanky/programovaci-jazyk-clojure-8-identity-stavy-nemenne-hodnoty-a-referencni-typy/</a>
</li>

<li>Clojure  9: Validátory, pozorovatelé a kooperace s Javou<br />
<a href="http://www.root.cz/clanky/programovaci-jazyk-clojure-9-validatory-pozorovatele-a-kooperace-mezi-clojure-a-javou/">http://www.root.cz/clanky/programovaci-jazyk-clojure-9-validatory-pozorovatele-a-kooperace-mezi-clojure-a-javou/</a>
</li>

<li>Clojure 10: Kooperace mezi Clojure a Javou<br />
<a href="http://www.root.cz/clanky/programovaci-jazyk-clojure-10-kooperace-mezi-clojure-a-javou-pokracovani/">http://www.root.cz/clanky/programovaci-jazyk-clojure-10-kooperace-mezi-clojure-a-javou-pokracovani/</a>
</li>

<li>Clojure 11: Generátorová notace seznamu/list comprehension<br />
<a href="http://www.root.cz/clanky/programovaci-jazyk-clojure-11-generatorova-notace-seznamu-list-comprehension/">http://www.root.cz/clanky/programovaci-jazyk-clojure-11-generatorova-notace-seznamu-list-comprehension/</a>
</li>

<li>Clojure 12: Překlad programů z Clojure do bajtkódu JVM I<br />
<a href="http://www.root.cz/clanky/programovaci-jazyk-clojure-12-preklad-programu-z-clojure-do-bajtkodu-jvm/">http://www.root.cz/clanky/programovaci-jazyk-clojure-12-preklad-programu-z-clojure-do-bajtkodu-jvm/</a>
</li>

<li>Clojure 13: Překlad programů z Clojure do bajtkódu JVM II<br />
<a href="2) http://www.root.cz/clanky/programovaci-jazyk-clojure-13-preklad-programu-z-clojure-do-bajtkodu-jvm-pokracovani/">2) http://www.root.cz/clanky/programovaci-jazyk-clojure-13-preklad-programu-z-clojure-do-bajtkodu-jvm-pokracovani/</a>
</li>

<li>Clojure 14: Základy práce se systémem maker<br />
<a href="http://www.root.cz/clanky/programovaci-jazyk-clojure-14-zaklady-prace-se-systemem-maker/">http://www.root.cz/clanky/programovaci-jazyk-clojure-14-zaklady-prace-se-systemem-maker/</a>
</li>

<li>Clojure 15: Tvorba uživatelských maker<br />
<a href="http://www.root.cz/clanky/programovaci-jazyk-clojure-15-tvorba-uzivatelskych-maker/">http://www.root.cz/clanky/programovaci-jazyk-clojure-15-tvorba-uzivatelskych-maker/</a>
</li>

<li>Clojure 16: Složitější uživatelská makra<br />
<a href="http://www.root.cz/clanky/programovaci-jazyk-clojure-16-slozitejsi-uzivatelska-makra/">http://www.root.cz/clanky/programovaci-jazyk-clojure-16-slozitejsi-uzivatelska-makra/</a>
</li>

<li>Clojure 17: Využití standardních maker v praxi<br />
<a href="http://www.root.cz/clanky/programovaci-jazyk-clojure-17-vyuziti-standardnich-maker-v-praxi/">http://www.root.cz/clanky/programovaci-jazyk-clojure-17-vyuziti-standardnich-maker-v-praxi/</a>
</li>

<li>Clojure 18: Základní techniky optimalizace aplikací<br />
<a href="http://www.root.cz/clanky/programovaci-jazyk-clojure-18-zakladni-techniky-optimalizace-aplikaci/">http://www.root.cz/clanky/programovaci-jazyk-clojure-18-zakladni-techniky-optimalizace-aplikaci/</a>
</li>

<li>Clojure 19: Vývojová prostředí pro Clojure<br />
<a href="http://www.root.cz/clanky/programovaci-jazyk-clojure-19-vyvojova-prostredi-pro-clojure/">http://www.root.cz/clanky/programovaci-jazyk-clojure-19-vyvojova-prostredi-pro-clojure/</a>
</li>

<li>Clojure 20: Vývojová prostředí pro Clojure (Vimu s REPL)<br />
<a href="http://www.root.cz/clanky/programovaci-jazyk-clojure-20-vyvojova-prostredi-pro-clojure-integrace-vimu-s-repl/">http://www.root.cz/clanky/programovaci-jazyk-clojure-20-vyvojova-prostredi-pro-clojure-integrace-vimu-s-repl/</a>
</li>

<li>Clojure 21: ClojureScript aneb překlad Clojure do JS<br />
<a href="http://www.root.cz/clanky/programovaci-jazyk-clojure-21-clojurescript-aneb-preklad-clojure-do-javascriptu/">http://www.root.cz/clanky/programovaci-jazyk-clojure-21-clojurescript-aneb-preklad-clojure-do-javascriptu/</a>
</li>

</ol>



<p></p><p></p>
<p><small>Autor: <a href="http://www.fit.vutbr.cz/~tisnovpa">Pavel Tišnovský</a> &nbsp; 2015</small></p>
</body>
</html>

