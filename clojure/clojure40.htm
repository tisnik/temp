<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
        "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html>
<head>
<title>Validace dat s využitím knihovny spec v Clojure 1.9.0</title>
<meta name="Author" content="Pavel Tisnovsky" />
<meta name="Generator" content="vim" />
<meta http-equiv="content-type" content="text/html; charset=utf-8" />
<style type="text/css">
         body {color:#000000; background:#ffffff;}
         h1  {font-family: arial, helvetica, sans-serif; color:#ffffff; background-color:#c00000; text-align:center; padding-left:1em}
         h2  {font-family: arial, helvetica, sans-serif; color:#ffffff; background-color:#0000c0; padding-left:1em; text-align:left}
         h3  {font-family: arial, helvetica, sans-serif; color:#000000; background-color:#c0c0c0; padding-left:1em; text-align:left}
         h4  {font-family: arial, helvetica, sans-serif; color:#000000; background-color:#e0e0e0; padding-left:1em; text-align:left}
         a   {font-family: arial, helvetica, sans-serif;}
         li  {font-family: arial, helvetica, sans-serif; color:#000000; text-align:justify; width:450px;}
         ol  {font-family: arial, helvetica, sans-serif; color:#000000; text-align:justify; width:450px;}
         ul  {font-family: arial, helvetica, sans-serif; color:#000000; text-align:justify; width:450px;}
         p   {font-family: arial, helvetica, sans-serif; color:#000000; text-align:justify;}
         pre {background:#e0e0e0}
</style>
</head>

<body>

<h1>Validace dat s využitím knihovny spec v Clojure 1.9.0</h1>

<h3>Pavel Tišnovský</h3>

<p></p>

<h1>Úvodník</h1>

<p>V&nbsp;dnešním článku navážeme na text z&nbsp;minulého týdne, v&nbsp;němž jsme si představili hlavní novinky, které vývojářům přinesla nová verze 1.9.0 programovacího jazyka Clojure. Dnes si popíšeme některé další možnosti nabízené knihovnou <strong>spec</strong>.</p>



<h2>Obsah</h2>

<p><a href="#k01">1. Validace dat s&nbsp;využitím knihovny spec v&nbsp;Clojure 1.9.0</a></p>
<p><a href="#k02">2. Proč je validace dat důležitá a užitečná</a></p>
<p><a href="#k03">3. Kontrola dat přímo v&nbsp;těle funkce</a></p>
<p><a href="#k04">4. Kontrola dat využívající vstupní podmínky (pre-condition)</a></p>
<p><a href="#k05">5. Deklarace validátorů pro složitější datovou strukturu (mapu)</a></p>
<p><a href="#k06">6. První demonstrační příklad &ndash; jednoduchá validace mapy, test existence všech klíčů</a></p>
<p><a href="#k07">7. Kontrola hodnot uložených v&nbsp;mapě</a></p>
<p><a href="#k08">8. Validace jména a příjmení</a></p>
<p><a href="#k09">9. Validace jména a příjmení v&nbsp;mapě</a></p>
<p><a href="#k10">10. Druhý demonstrační příklad &ndash; kontrola hodnot uložených v&nbsp;mapě</a></p>
<p><a href="#k11">11. Validace parametrů předávaných funkci, validace návratových hodnot</a></p>
<p><a href="#k12">12. Třetí demonstrační příklad &ndash; validace parametrů předávaných funkci</a></p>
<p><a href="#k13">13. Čtvrtý demonstrační příklad &ndash; chování funkce ve chvíli, kdy není zvalidována její návratová hodnota</a></p>
<p><a href="#k14">14. Volitelné položky v&nbsp;mapě</a></p>
<p><a href="#k15">15. Pátý demonstrační příklad &ndash; validace mapy s&nbsp;volitelnými položkami</a></p>
<p><a href="#k16">16. Validace n-tic, kolekcí a sekvencí</a></p>
<p><a href="#k17">17. Možnosti nabízené makrem <strong>coll-of</strong></p>
<p><a href="#k18">18. Repositář s&nbsp;demonstračními příklady</a></p>
<p><a href="#k19">19. Odkazy na předchozí části tohoto seriálu</a></p>
<p><a href="#k20">20. Odkazy na Internetu</a></p>



<p><a name="k01"></a></p>
<h2 id="k01">1. Validace dat s&nbsp;využitím knihovny spec v&nbsp;Clojure 1.9.0</h2>

<p><a
href="https://www.root.cz/clanky/novinky-v-clojure-verze-1-9-0/">V&nbsp;předchozím
článku</a> jsme si popsali hlavní novinky, s&nbsp;nimiž se mohou vývojáři
setkat <a
href="https://github.com/clojure/clojure/blob/master/changes.md">v&nbsp;Clojure
verze 1.9.0</a>. Připomeňme si jen, že se jedná o prozatím poslední stabilní
verzi tohoto jazyka, protože <a
href="https://clojure.org/community/devchangelog">Clojure 1.10.0</a> je stále
ještě <a
href="https://repo1.maven.org/maven2/org/clojure/clojure/1.10.0-alpha4/">v&nbsp;alfa
stavu</a> (nicméně se již zdá být poměrně stabilní). Jedním důležitým
vylepšením, s&nbsp;nímž se můžeme v&nbsp;Clojure 1.9.0 setkat, je knihovna
nazvaná <strong>spec</strong>. Tato knihovna slouží k&nbsp;deklaraci struktury
dat a následně k&nbsp;jejich validaci. Složitější datové struktury jsou
v&nbsp;jazyku Clojure většinou reprezentovány formou slovníku, který
(rekurzivně) obsahuje další struktury, tj.&nbsp;další slovníky, seznamy,
vektory či množiny. Jen málokdy se v&nbsp;Clojure setkáme s&nbsp;tím, že by
byla datová struktura &bdquo;zabalena&ldquo; do třídy společně
s&nbsp;metodami.</p>

<p>Navíc se v&nbsp;Clojure, podobně jako v&nbsp;dalších jazycích, mnohdy velmi
intenzivně pracuje se strukturovanými daty reprezentovanými <a
href="http://json.org/">v&nbsp;JSONu</a>; výjimkou nejsou ani situace, kdy
k&nbsp;těmto datům není dodáváno <a href="http://json-schema.org/">JSON
schéma</a>. A právě z&nbsp;toho důvodu, že se většinou pracuje s&nbsp;holými
(nezabalenými) datovými strukturami, je nutné nějakým způsobem zajišťovat
validitu dat. Poměrně často se pro tyto účely používala knihovna <a
href="https://github.com/plumatic/schema">Schema</a> (neplést se Scheme :-),
ovšem knihovna <strong>spec</strong> tento problém řeší poněkud <a
href="https://lispcast.com/clojure.spec-vs-schema/">odlišným způsobem</a>.</p>



<p><a name="k02"></a></p>
<h2 id="k02">2. Proč je validace dat důležitá a užitečná</h2>

<p>Ukažme si jednoduchý příklad, na němž si ukážeme, z&nbsp;jakého důvodu je
validace dat důležitá. Představme si, že v&nbsp;aplikaci potřebujeme pracovat
s&nbsp;údaji o osobách, například o zaměstnancích. Datová struktura nesoucí
informace o jedné osobě se vytvoří triviálně &ndash; bude se jednat o obyčejný
slovník (asociativní pole), v&nbsp;němž budou klíče představovány hodnotami
typu <i>keyword</i>, a to z&nbsp;toho důvodu, že je u těchto hodnot zajištěna
jedinečnost:</p>

<pre>
{:id 10
 :name "Rich"
 :surname "Hickey"}
</pre>

<p>Poznámka: samozřejmě je možné použít jakoukoli hodnotu pro klíče, například
i řetězce. V&nbsp;tomto případě se však bude jednat o zbytečné plýtvání
operační pamětí, protože není zaručeno, že každý řetězec (se stejným textem)
bude unikátní:</p>

<pre>
{"id" 10
 "name" "Rich"
 "surname" "Hickey"}
</pre>

<p>Jak by mohla vypadat funkce akceptující tuto datovou strukturu?
V&nbsp;nejjednodušším případě může taková funkce vypadat například následovně.
Zde se konkrétně snažíme o uložení struktury do databázové tabulky (funkce je
součástí projektu, který naleznete na adrese <a
href="https://github.com/tisnik/clojure-examples/tree/master/db-store">https://github.com/tisnik/clojure-examples/tree/master/db-store</a>:</p>

<pre>
(defn <strong>store-user-name</strong>
    [db-spec user-name]
    (jdbc/insert! db-spec "users" user-name))
</pre>

<p>Způsob použití této funkce:</p>

<pre>
(require '[clojure.java.jdbc :as jdbc])
&nbsp;
<i>; struktura reprezentující způsob připojení do vybrané databáze</i>
(def test-db
    {:classname   "org.sqlite.JDBC"
     :subprotocol "sqlite"
     :subname     "test.db"
    })
&nbsp;
(<strong>store-user-name test-db</strong> {:id 1 :name "Rich" :surname "Hickey"})
</pre>

<p>Databázová tabulka byla vytvořena s&nbsp;následující strukturou:</p>

<pre>
create table users (
    id        integer primary key,
    name      text not null,
    surname   text not null
);
</pre>

<p>Zajímavé bude zjistit, co se stane ve chvíli, kdy funkci
<strong>store-user-name</strong> předáme neúplnou datovou struktur, hodnotu
jiného typu popř.&nbsp;strukturu, která sice bude obsahovat všechny dvojice
klíč-hodnota, ale hodnoty nebudou odpovídat schématu databáze.</p>

<p>Hodnota uložená pod klíčem :id není typu <i>integer</i>:</p>

<pre>
(store-user-name test-db {:id "XXXXXXXX" :name "Rich" :surname "Hickey"})
</pre>

<p>Neúplná datová struktura:</p>

<pre>
(store-user-name test-db {:id 2"})
</pre>

<p>Namísto mapy se předává odlišná hodnota:</p>

<pre>
(store-user-name test-db "foobar")
</pre>

<p>Ve všech těchto případech samozřejmě dojde k&nbsp;chybě, neboť není dodržena
struktura vyžadovaná schématem databáze (samotný výpis zásobníkových rámců je
dosti nepřehledný, nicméně chybové hlášení je pochopitelné):</p>

<pre>
Caused by: java.sql.SQLException: [SQLITE_MISMATCH]  Data type mismatch (datatype mismatch)
    at org.sqlite.DB.newSQLException(DB.java:383)
    at org.sqlite.DB.newSQLException(DB.java:387)
    at org.sqlite.DB.execute(DB.java:342)
    at org.sqlite.DB.executeUpdate(DB.java:363)
    at org.sqlite.PrepStmt.executeUpdate(PrepStmt.java:85)
    at clojure.java.jdbc$db_do_prepared_return_keys$exec_and_return_keys__497.invoke(jdbc.clj:692)
    at clojure.java.jdbc$db_do_prepared_return_keys.invokeStatic(jdbc.clj:707)
    at clojure.java.jdbc$db_do_prepared_return_keys.invoke(jdbc.clj:679)
    at clojure.java.jdbc$multi_insert_helper$fn__556.invoke(jdbc.clj:897)
    at clojure.core$map$fn__5587.invoke(core.clj:2747)
    at clojure.lang.LazySeq.sval(LazySeq.java:40)
    at clojure.lang.LazySeq.seq(LazySeq.java:49)
    at clojure.lang.RT.seq(RT.java:528)
    at clojure.core$seq__5124.invokeStatic(core.clj:137)
    at clojure.core$dorun.invokeStatic(core.clj:3125)
    at clojure.core$doall.invokeStatic(core.clj:3140)
    at clojure.core$doall.invoke(core.clj:3140)
    at clojure.java.jdbc$multi_insert_helper.invokeStatic(jdbc.clj:896)
    at clojure.java.jdbc$multi_insert_helper.invoke(jdbc.clj:891)
    at clojure.java.jdbc$insert_helper$fn__559.invoke(jdbc.clj:907)
    at clojure.java.jdbc$db_transaction_STAR_.invokeStatic(jdbc.clj:580)
    at clojure.java.jdbc$db_transaction_STAR_.doInvoke(jdbc.clj:553)
    at clojure.lang.RestFn.invoke(RestFn.java:425)
    at clojure.java.jdbc$insert_helper.invokeStatic(jdbc.clj:907)
    at clojure.java.jdbc$insert_helper.invoke(jdbc.clj:900)
    at clojure.java.jdbc$insert_BANG_.invokeStatic(jdbc.clj:999)
    at clojure.java.jdbc$insert_BANG_.doInvoke(jdbc.clj:984)
    at clojure.lang.RestFn.invoke(RestFn.java:442)
    at db_store.core$store_user_name.invokeStatic(core.clj:14)
    at db_store.core$store_user_name.invoke(core.clj:12)
    at db_store.core$_main.invokeStatic(core.clj:20)
    at db_store.core$_main.doInvoke(core.clj:16)
    at clojure.lang.RestFn.invoke(RestFn.java:397)
    at clojure.lang.Var.invoke(Var.java:377)
    at user$eval139.invokeStatic(form-init5353435627860668704.clj:1)
    at user$eval139.invoke(form-init5353435627860668704.clj:1)
    at clojure.lang.Compiler.eval(Compiler.java:7062)
    at clojure.lang.Compiler.eval(Compiler.java:7052)
    at clojure.lang.Compiler.load(Compiler.java:7514)
    ... 12 more
</pre>



<p><a name="k03"></a></p>
<h2 id="k03">3. Kontrola dat přímo v&nbsp;těle funkce</h2>

<p>Samozřejmě je možné kontrolu dat provádět přímo ve volané funkci, což je
pravděpodobně první možnost, která programátora napadne. Ukažme si to na
typickém &bdquo;školním&ldquo; příkladu. Bude se jednat o funkci pro výpočet
faktoriálu, kterou je možné naprogramovat například tak, že při zadání
záporného čísla vyhodí výjimku:</p>

<pre>
(defn factorial
    [n]
    (if (neg? n)
        (throw (IllegalArgumentException. "negative numbers are not supported!"))
        (apply * (range 1 (inc n)))))
</pre>

<p>Otestování chování je snadné:</p>

<pre>
user=&gt; <strong>(factorial 3)</strong>
6
&nbsp;
user=&gt; <strong>(factorial 2)</strong>
2
&nbsp;
user=&gt; <strong>(factorial 1)</strong>
1
&nbsp;
user=&gt; <strong>(factorial 0)</strong>
1
&nbsp;
user=&gt; <strong>(factorial -1)</strong>
&nbsp;
IllegalArgumentException negative numbers are not supported!  user/factorial (NO_SOURCE_FILE:3)
user=&gt;
</pre>

<p>Jednoduchý test však nezabrání chybám při předání hodnot odlišného typu (zde
nepomůže ani <i>type hint</i>):</p>

<pre>
clojure9-test.core=&gt; <strong>(factorial :x)</strong>
&nbsp;
ClassCastException clojure.lang.Keyword cannot be cast to java.lang.Number  clojure.lang.Numbers.isNeg (Numbers.java:100)
</pre>

<pre>
clojure9-test.core=&gt; <strong>(factorial nil)</strong>
&nbsp;
NullPointerException   clojure.lang.Numbers.ops (Numbers.java:1018)
</pre>

<pre>
clojure9-test.core=&gt; <strong>(factorial "42")</strong>
&nbsp;
ClassCastException java.lang.String cannot be cast to java.lang.Number  clojure.lang.Numbers.isNeg (Numbers.java:100)
</pre>

<p>Další explicitně naprogramovaná kontrol vstupních parametrů vede k&nbsp;již
dosti nečitelnému kódu (příklad je ovšem možné napsat i jinak, například
s&nbsp;využitím nového predikátu <strong>nat-int?</strong>):</p>

<pre>
(defn factorial
    [n]
    (if (int? n)
        (if (neg? n)
            (throw (IllegalArgumentException. "negative numbers are not supported!"))
            (apply * (range 1 (inc n))))
        (throw (IllegalArgumentException. "only integers are accepted!"))))
</pre>

<p>Otestování funkčnosti:</p>

<pre>
clojure9-test.core=&gt; <strong>(factorial 10)</strong>
3628800
</pre>

<pre>
clojure9-test.core=&gt; <strong>(factorial -1)</strong>
&nbsp;
IllegalArgumentException negative numbers are not supported!  clojure9-test.core/factorial (form-init2633858370945804905.clj:4)
</pre>

<pre>
clojure9-test.core=&gt; <strong>(factorial :x)</strong>
&nbsp;
IllegalArgumentException only integers are accepted!  clojure9-test.core/factorial (form-init2633858370945804905.clj:6)
</pre>

<pre>
clojure9-test.core=&gt; <strong>(factorial nil)</strong>
&nbsp;
IllegalArgumentException only integers are accepted!  clojure9-test.core/factorial (form-init2633858370945804905.clj:6)
</pre>



<p><a name="k04"></a></p>
<h2 id="k04">4. Kontrola dat využívající vstupní podmínky (pre-condition)</h2>

<p>Výše uvedený kód sice můžeme poměrně často vidět v&nbsp;mnoha knihovnách,
ovšem ve skutečnosti není pro programovací jazyk Clojure příliš idiomatický. Je
tomu tak z&nbsp;toho důvodu, že jazyk Clojure umožňuje ve funkci deklarovat
vstupní podmínky (<i>pre-condition</i>) a dokonce i podmínky výstupní
(<i>post-condition</i>). Vstupní podmínky jsou pochopitelně kontrolovány při
vstupu do funkce, podmínky výstupní pak automaticky ve všech místech, kde
funkce předává návratovou hodnotu volajícímu kódu (tj.&nbsp;těsně před
implicitně vkládanou instrukcí <strong>RETURN</strong>). Nejprve se opět
podívejme na klasický &bdquo;školní&ldquo; příklad použití vstupní podmínky u
funkce <strong>factorial</strong>, jejíž parametr musí být přirozené číslo:</p>

<pre>
(defn factorial
    [n]
    <strong>{:pre [(pos? n)]}</strong>
    (apply * (range 1 (inc n))))
</pre>

<p>Chování této funkce si můžeme velmi snadno otestovat:</p>

<pre>
user=&gt; <strong>(factorial 3)</strong>
6
</pre>

<pre>
user=&gt; <strong>(factorial 2)</strong>
2
</pre>

<pre>
user=&gt; <strong>(factorial 1)</strong>
1
</pre>

<p>Neočekávané hodnoty (správného typu):</p>

<pre>
user=&gt; <strong>(factorial 0)</strong>
&nbsp;
AssertionError Assert failed: (pos? n)  user/factorial (NO_SOURCE_FILE:1)
</pre>

<pre>
user=&gt; <strong>(factorial -1)</strong>
&nbsp;
AssertionError Assert failed: (pos? n)  user/factorial (NO_SOURCE_FILE:1)
</pre>

<p>Nejzajímavější jsou samozřejmě poslední dva případy, protože v&nbsp;nich je
ukázáno, že se kontrola hodnoty vstupního parametru skutečně provádí.</p>

<p>S&nbsp;existencí <a
href="https://www.root.cz/clanky/novinky-v-clojure-verze-1-9-0/#k13">nových
predikátů přidaných do Clojure 1.9.0</a> navíc můžeme předchozí příklad
nepatrně upravit tak, aby akceptoval i nulu (ve skutečnosti samozřejmě nemusíme
nutně použít nový predikát, je to však elegantnější):</p>

<pre>
(defn factorial
    [n]
    {:pre [(nat-int? n)]}
    (apply * (range 1 (inc n))))
</pre>

<p>Test při předání celých čísel:</p>

<pre>
clojure9-test.core=&gt; <strong>(factorial -1)</strong>
&nbsp;
AssertionError Assert failed: (nat-int? n)  clojure9-test.core/factorial (form-init3895554752445190478.clj:1)
&nbsp;
clojure9-test.core=&gt; <strong>(factorial 0)</strong>
1
&nbsp;
clojure9-test.core=&gt; <strong>(factorial 1)</strong>
1
&nbsp;
clojure9-test.core=&gt; <strong>(factorial 2)</strong>
2
&nbsp;
clojure9-test.core=&gt; <strong>(factorial 10)</strong>
3628800
</pre>

<p>Špatný typ hodnot:</p>

<pre>
clojure9-test.core=&gt; <strong>(factorial nil)</strong>
&nbsp;
AssertionError Assert failed: (nat-int? n)  clojure9-test.core/factorial (form-init8084795436103962898.clj:1)
</pre>

<pre>
clojure9-test.core=&gt; <strong>(factorial "foobar")</strong>
&nbsp;
AssertionError Assert failed: (nat-int? n)  clojure9-test.core/factorial (form-init8084795436103962898.clj:1)
</pre>

<pre>
clojure9-test.core=&gt; <strong>(factorial :42)</strong>
&nbsp;
AssertionError Assert failed: (nat-int? n)  clojure9-test.core/factorial (form-init8084795436103962898.clj:1)
</pre>



<p><a name="k05"></a></p>
<h2 id="k05">5. Deklarace validátorů pro složitější datovou strukturu (mapu)</h2>

<p>Vraťme se nyní k&nbsp;datové struktuře nesoucí informace o jedné osobě.
Nejprve knihovnu <strong>spec</strong> načteme do interaktivní smyčky REPL:</p>

<pre>
user=&gt; <strong>(require '[clojure.spec.alpha :as spec])</strong>
nil
</pre>

<p>Následně můžeme deklarovat kontrolu na existenci <i>klíčů</i> v&nbsp;datové
struktuře. Použijeme přitom již minule popsané makro <strong>spec/def</strong>
a taktéž makro <strong>spec/keys</strong>, kterému se v&nbsp;nejjednodušším
případě předá vektor klíčů. Klíče přitom musí být buď plně kvalifikovány (ve
formátu :jmenný-prostor/klíč) nebo lze použít zápis ::klíč pro klíče platné
v&nbsp;aktuálně platném jmenném prostoru (taktéž se jedná o novinku
v&nbsp;Clojure 1.9.0):</p>

<pre>
user=&gt; <strong>(spec/def ::person? (spec/keys :req [::id ::name ::surname]))</strong>
:user/person?
</pre>

<p>Vyzkoušejme si nyní, jak kontrola probíhá:</p>

<pre>
user=&gt; <strong>(spec/valid? ::person? {:id 1 :name "Name" :surname "Surname"})</strong>
false
&nbsp;
user=&gt; <strong>(spec/valid? ::person? {::id 1 ::name "Name" ::surname "Surname"})</strong>
true
&nbsp;
user=&gt; <strong>(spec/valid? ::person? {::name "Name" ::surname "Surname"})</strong>
false
</pre>

<p>Výsledky jsou možná překvapivé, protože validní je pouze mapa obsahující
klíče v&nbsp;aktuálním jmenném prostoru, před nimiž se zapisuje ::
(&bdquo;čtyřtečka&ldquo;). Ve skutečnosti však bude validní i mapa s&nbsp;plně
kvalifikovanými klíči:</p>

<pre>
user=&gt; <strong>(spec/valid? ::person? {:user/id 1 :user/name "Name" :user/surname "Surname"})</strong>
true
</pre>

<p>Pro klíče z&nbsp;jiného prostoru to však neplatí:</p>

<pre>
user=&gt; <strong>(spec/valid? ::person? {:test/id 1 :test/name "Name" :test/surname "Surname"})</strong>
false
</pre>

<p>Použití plně kvalifikovaných klíčů je sice doporučováno, ovšem v&nbsp;praxi
se mnohem častěji setkáme s&nbsp;datovými strukturami, v&nbsp;nichž jsou
použity klíče &bdquo;obyčejné&ldquo;, tj.&nbsp;bez jmenného prostoru. Pokud
budeme chtít validovat struktury s&nbsp;těmito klíči (a to většinou skutečně
budeme chtít), musí se namísto klauzule <strong>:req</strong> použít klauzule
<strong>:req-un</strong>. Namísto:</p>

<pre>
user=&gt; <strong>(spec/def ::person? (spec/keys :req [::id ::name ::surname]))</strong>
:user/person?
</pre>

<p>Použijeme definici:</p>

<pre>
user=&gt; <strong>(spec/def ::person? (spec/keys :req-un [::id ::name ::surname]))</strong>
:user/person?
</pre>

<p>Nyní se můžeme pokusit zvalidovat několik datových struktur:</p>

<pre>
user=&gt; <strong>(spec/valid? ::person? {::id -10 ::name "Name" ::surname "Surname"})</strong>
false
user=&gt; <strong>(spec/valid? ::person? {::id 10 ::name "Name" ::surname "Surname"})</strong>
false
user=&gt; <strong>(spec/valid? ::person? {:id -10 :name "Name" :surname "Surname"})</strong>
true
user=&gt; <strong>(spec/valid? ::person? {:id 10 :name "Name" :surname "Surname"})</strong>
true
</pre>

<p>U map samozřejmě nezáleží na pořadí dvojic klíč-hodnota:</p>

<pre>
user=&gt; <strong>(spec/valid? ::person? {:name "Name" :surname "Surname" :id 10})</strong>
true
</pre>



<p><a name="k06"></a></p>
<h2 id="k06">6. První demonstrační příklad &ndash; jednoduchá validace mapy, test existence všech klíčů</h2>

<p>V&nbsp;dnešním prvním demonstračním příkladu, jehož úplnou strukturu
naleznete na adrese <a
href="https://github.com/tisnik/clojure-examples/tree/master/spec-demo1">https://github.com/tisnik/clojure-examples/tree/master/spec-demo1</a>,
je ukázán průběh základní validace s&nbsp;využitím plně kvalifikovaných klíčů
popř.&nbsp;klíčů platných pro aktuální jmenný prostor. Povšimněte si, že
namísto jmenného prostoru <strong>user</strong> musíme nyní použít jmenný
prostor odpovídající názvu demonstračního příkladu:</p>

<pre>
(ns spec-demo1.core)
&nbsp;
(require '[clojure.spec.alpha :as spec])
&nbsp;
(defn -main
    [&amp; args]
    <strong>(spec/def ::person? (spec/keys :req [::id ::name ::surname]))</strong>
&nbsp;
    (println "valid?")
    (println "--------------------------------------------------")
    (println (spec/valid? ::person? {:id 1 :name "Name" :surname "Surname"}))
    (println (spec/valid? ::person? {::name "Name" ::surname "Surname"}))
    (println (spec/valid? ::person? {::id 1 ::name "Name" ::surname "Surname"}))
    (println (spec/valid? ::person? {:user/id 1 :user/name "Name" :user/surname "Surname"}))
    (println (spec/valid? ::person? {:spec-demo1.core/id 1 :spec-demo1.core/name "Name" :spec-demo1.core/surname "Surname"}))
    (println (spec/valid? ::person? {:other.namespace/id 1 :other.namespace/name "Name" :other.namespace/surname "Surname"}))
&nbsp;
    (println "\nexplain")
    (println "--------------------------------------------------")
    (println (spec/explain ::person? {:id 1 :name "Name" :surname "Surname"}))
    (println)
    (println (spec/explain ::person? {::name "Name" ::surname "Surname"}))
    (println)
    (println (spec/explain ::person? {::id 1 ::name "Name" ::surname "Surname"}))
    (println)
    (println (spec/explain ::person? {:user/id 1 :user/name "Name" :user/surname "Surname"}))
    (println)
    (println (spec/explain ::person? {:spec-demo1.core/id 1 :spec-demo1.core/name "Name" :spec-demo1.core/surname "Surname"}))
    (println)
    (println (spec/explain ::person? {:other.namespace/id 1 :other.namespace/name "Name" :other.namespace/surname "Surname"})))
</pre>

<p>Po spuštění tohoto příkladu by se na standardním výstupu měly objevit přesně
tyto řádky:</p>

<pre>
valid?
--------------------------------------------------
false
false
true
false
true
false
&nbsp;
explain
--------------------------------------------------
val: {:id 1, :name "Name", :surname "Surname"} fails spec: :spec-demo1.core/person? predicate: (contains? % :spec-demo1.core/id)
val: {:id 1, :name "Name", :surname "Surname"} fails spec: :spec-demo1.core/person? predicate: (contains? % :spec-demo1.core/name)
val: {:id 1, :name "Name", :surname "Surname"} fails spec: :spec-demo1.core/person? predicate: (contains? % :spec-demo1.core/surname)
nil
&nbsp;
val: #:spec-demo1.core{:name "Name", :surname "Surname"} fails spec: :spec-demo1.core/person? predicate: (contains? % :spec-demo1.core/id)
nil
&nbsp;
Success!
nil
&nbsp;
val: #:user{:id 1, :name "Name", :surname "Surname"} fails spec: :spec-demo1.core/person? predicate: (contains? % :spec-demo1.core/id)
val: #:user{:id 1, :name "Name", :surname "Surname"} fails spec: :spec-demo1.core/person? predicate: (contains? % :spec-demo1.core/name)
val: #:user{:id 1, :name "Name", :surname "Surname"} fails spec: :spec-demo1.core/person? predicate: (contains? % :spec-demo1.core/surname)
nil
&nbsp;
Success!
nil
&nbsp;
val: #:other.namespace{:id 1, :name "Name", :surname "Surname"} fails spec: :spec-demo1.core/person? predicate: (contains? % :spec-demo1.core/id)
val: #:other.namespace{:id 1, :name "Name", :surname "Surname"} fails spec: :spec-demo1.core/person? predicate: (contains? % :spec-demo1.core/name)
val: #:other.namespace{:id 1, :name "Name", :surname "Surname"} fails spec: :spec-demo1.core/person? predicate: (contains? % :spec-demo1.core/surname)
nil
</pre>



<p><a name="k07"></a></p>
<h2 id="k07">7. Kontrola hodnot uložených v&nbsp;mapě</h2>

<p>Kontrolu existence <i>klíčů</i> již máme vyřešenou, ovšem samozřejmě nám
zbývá zkontrolovat i <i>hodnoty</i>, aby například nebylo možné pod
<strong>:id</strong> uložit řetězec a pod <strong>:name</strong> prázdné jméno,
číslo nebo vektor. Pro jistotu si znovu zopakujme první validační kritérium,
tj.&nbsp;kontrolu na existenci klíčů v&nbsp;mapě:</p>

<pre>
user=&gt; <strong>(spec/def ::person? (spec/keys :req [::id ::name ::surname]))</strong>
:user/person?
</pre>

<p>V&nbsp;některých dalších knihovnách určených pro validaci dat by nyní
následovala specifikace, jak má vypadat hodnota uložená pod klíčem
<strong>::id</strong>, <strong>::name</strong> atd. V&nbsp;knihovně
<strong>spec</strong> se však používá odlišný postup, protože specifikujeme
validátor přímo pojmenovaný po klíči, tj.&nbsp;uvedený zcela mimo vlastní mapu.
Například můžeme specifikovat validátor pro hodnotu uloženou pod klíčem
<strong>::id</strong>:</p>

<pre>
user=&gt; <strong>(spec/def ::id pos-int?)</strong>
:user/id?
</pre>

<p>Validaci lze provést pro jednotlivé hodnoty, čímž si současně ověříme, zda
je test korektní:</p>

<pre>
user=&gt; <strong>(spec/valid? ::id 10)</strong>
true
user=&gt; <strong>(spec/valid? ::id -10)</strong>
false
</pre>

<p>Navíc se validace začne &bdquo;magicky&ldquo; provádět i pro hodnoty uložené
v&nbsp;mapě:</p>

<pre>
user=&gt; <strong>(spec/valid? ::person? {::id 10 ::name "Name" ::surname "Surname"})</strong>
true
&nbsp;
user=&gt; <strong>(spec/valid? ::person? {::id -10 ::name "Name" ::surname "Surname"})</strong>
false
</pre>

<p>Samozřejmě nejsme omezeni pouze na mapy s&nbsp;plně kvalifikovanými klíči.
Zkusme si nyní napsat pravidla pro validaci map s&nbsp;klíči bez uvedení
jmenného prostoru. Postup je shodný, pouze se namísto klauzule
<strong>:req</strong> použije nám již známá klauzule
<strong>:req.un</strong>:</p>

<pre>
user=&gt; <strong>(spec/def ::person? (spec/keys :req-un [::id ::name ::surname]))</strong>
:user/person?
&nbsp;
user=&gt; <strong>(spec/def ::id pos-int?)</strong>
:user/id
</pre>

<p>Následně otestujeme validaci pro testovací mapy:</p>

<pre>
user=&gt; <strong>(spec/valid? ::person? {:id 10 :name "Name" :surname "Surname"})</strong>
true
&nbsp;
user=&gt; <strong>(spec/valid? ::person? {:id -10 :name "Name" :surname "Surname"})</strong>
false
&nbsp;
user=&gt; <strong>(spec/valid? ::person? {:id 0 :name "Name" :surname "Surname"})</strong>
false
&nbsp;
user=&gt; <strong>(spec/valid? ::person? {:id "foobar" :name "Name" :surname "Surname"})</strong>
false
</pre>



<p><a name="k08"></a></p>
<h2 id="k08">8. Validace jména a příjmení</h2>

<p>Kritéria samozřejmě můžeme rozšířit a kromě testu hodnot uložených pod
klíčem <strong>:id</strong> budeme ověřovat i to, zda je zadáno korektní jméno
a příjmení. Pro zápis nových predikátů se většinou kvůli sevřenějšímu zápisu
používají anonymní funkce, ovšem pokud teprve jednotlivé predikáty ladíme, je
lepší použít běžné (pojmenované) funkce. Příkladem může být funkce pro test,
zda je zadáno jméno začínající velkým písmenem a pokračující písmeny malými.
V&nbsp;tomto případě použijeme běžný regulární výraz:</p>

<pre>
user=&gt; <strong>(defn name? [s] (and (string? s) (re-matches #"[A-Z][a-z]+" s)))</strong>
#'user/name?
</pre>

<p>Otestování nového predikátu je snadné:</p>

<pre>
user=&gt; <strong>(name? 42)</strong>
false
&nbsp;
user=&gt; <strong>(name? "")</strong>
nil
&nbsp;
user=&gt; <strong>(name? "hello")</strong>
nil
&nbsp;
user=&gt; <strong>(name? "Pavel")</strong>
"Pavel"
&nbsp;
user=&gt; <strong>(name? "P")</strong>
nil
</pre>

<p>Pokud budete chtít být precizní a skutečně vracet jen hodnoty
<strong>true</strong> nebo <strong>false</strong> (což ovšem není striktně
vyžadováno), je možné predikát nepatrně upravit:</p>

<pre>
user=&gt; <strong>(defn name? [s] (boolean (and (string? s) (re-matches #"[A-Z][a-z]+" s))))</strong>
#'user/name?
</pre>

<p>Nyní se jedná o funkci, která vždy vrátí pravdivostní hodnotu:</p>

<pre>
user=&gt; <strong>(name? "")</strong>
false
&nbsp;
user=&gt; <strong>(name? "pavel")</strong>
false
&nbsp;
user=&gt; <strong>(name? "Pavel")</strong>
true
&nbsp;
user=&gt; <strong>(name? 42)</strong>
false
&nbsp;
user=&gt; <strong>(name? nil)</strong>
false
</pre>

<p>Podobně můžeme vytvořit i funkci pro kontrolu příjmení, kde ovšem povolíme i
mezery a víceslovná příjmení:</p>

<pre>
user=&gt; <strong>(defn surname? [s] (and (string? s) (re-matches #"[A-Z][A-Za-z ]+" s)))</strong>
#'user/surname?
</pre>

<p>Otestování:</p>

<pre>
user=&gt; <strong>(surname? "Hickey")</strong>
"Hickey"
&nbsp;
user=&gt; <strong>(surname? "De Boor")</strong>
"De Boor"
&nbsp;
user=&gt; <strong>(surname? "foobar")</strong>
nil
&nbsp;
user=&gt; <strong>(surname? 42)</strong>
false
&nbsp;
user=&gt; <strong>(surname? "")</strong>
nil
</pre>

<p>Úprava na striktní predikát:</p>

<pre>
user=&gt; <strong>(defn surname? [s] (boolean (and (string? s) (re-matches #"[A-Z][A-Za-z ]+" s))))</strong>
#'user/surname?
</pre>

<p>Otestování:</p>

<pre>
user=&gt; <strong>(surname? "Hickey")</strong>
true
&nbsp;
user=&gt; <strong>(surname? "De Boor")</strong>
true
&nbsp;
user=&gt; <strong>(surname? "foobar")</strong>
false
&nbsp;
user=&gt; <strong>(surname? 42)</strong>
false
&nbsp;
user=&gt; <strong>(surname? "")</strong>
false
</pre>

<p>Použití predikátů pro validaci jména a příjmení je už jen záležitostí dvou
řádků:</p>

<pre>
user=&gt; <strong>(spec/def ::name name?)</strong>
:user/name
&nbsp;
user=&gt; <strong>(spec/def ::surname surname?)</strong>
:user/surname
</pre>



<p><a name="k09"></a></p>
<h2 id="k09">9. Validace jména a příjmení v&nbsp;mapě</h2>

<p>Nyní již můžeme všechny kontroly provést nad různými testovacími mapami
(nebo nad jinými strukturami).</p>

<p>Specifikace validačních kritérií:</p>

<pre>
clojure9-test.core=&gt; <strong>(ns user)</strong>
nil
&nbsp;
user=&gt; <strong>(require '[clojure.spec.alpha :as spec])</strong>
nil
&nbsp;
user=&gt; <strong>(spec/def ::person? (spec/keys :req-un [::id ::name ::surname]))</strong>
:user/person?
&nbsp;
user=&gt; <strong>(defn name? [s] (boolean (and (string? s) (re-matches #"[A-Z][a-z]+" s))))</strong>
#'user/name?
&nbsp;
user=&gt; <strong>(defn surname? [s] (boolean (and (string? s) (re-matches #"[A-Z][A-Za-z ]+" s))))</strong>
#'user/surname?
&nbsp;
user=&gt; <strong>(spec/def ::id pos-int?)</strong>
:user/id
&nbsp;
user=&gt; <strong>(spec/def ::name name?)</strong>
:user/name
&nbsp;
user=&gt; <strong>(spec/def ::surname surname?)</strong>
:user/surname
</pre>

<p>Otestování, zda validace probíhá tak, jak předpokládáme:</p>

<pre>
user=&gt; <strong>(spec/valid? ::person? nil)</strong>
false
&nbsp;
user=&gt; <strong>(spec/valid? ::person? "")</strong>
false
&nbsp;
user=&gt; <strong>(spec/valid? ::person? [])</strong>
false
&nbsp;
user=&gt; <strong>(spec/valid? ::person? {:id 10 :name "Rich" :surname "Hickey"})</strong>
true
&nbsp;
user=&gt; <strong>(spec/valid? ::person? {:id 10 :name "Carl" :surname "De Boor"})</strong>
true
&nbsp;
user=&gt; <strong>(spec/valid? ::person? {:id 0 :name "carl" :surname "De Boor"})</strong>
false
&nbsp;
user=&gt; <strong>(spec/valid? ::person? {:id 10 :name "carl" :surname "De Boor"})</strong>
false
</pre>

<p>Zjištění, proč nebyla data validována:</p>

<pre>
user=&gt; <strong>(spec/explain ::person? {:id 10 :name "Carl" :surname "De Boor"})</strong>
Success!
nil
&nbsp;
user=&gt; <strong>(spec/explain ::person? {:id -10 :name "Carl" :surname "De Boor"})</strong>
In: [:id] val: -10 fails spec: :user/id at: [:id] predicate: pos-int?
nil
&nbsp;
user=&gt; <strong>(spec/explain ::person? {:id -10 :name "Carl"})</strong>
In: [:id] val: -10 fails spec: :user/id at: [:id] predicate: pos-int?
val: {:id -10, :name "Carl"} fails spec: :user/person? predicate: (contains? % :surname)
nil
&nbsp;
user=&gt; <strong>(spec/explain ::person? "")</strong>
val: "" fails spec: :user/person? predicate: map?
nil
&nbsp;
user=&gt; <strong>(spec/explain ::person? [])</strong>
val: [] fails spec: :user/person? predicate: map?
nil
&nbsp;
user=&gt; <strong>(spec/explain ::person? nil)</strong>
val: nil fails spec: :user/person? predicate: map?
nil
</pre>



<p><a name="k10"></a></p>
<h2 id="k10">10. Druhý demonstrační příklad &ndash; kontrola hodnot uložených v&nbsp;mapě</h2>

<p>Ve druhém demonstračním příkladu je ukázán způsob validace mapy, v&nbsp;níž
se kontroluje jak existence jednotlivých klíčů, tak i hodnot, které jsou na
klíče navázány. Identifikátor musí být celé kladné číslo, jméno musí odpovídat
zadanému regulárnímu výrazu (první velké písmeno, další písmena malá) a
příjmení taktéž musí odpovídat zadanému regulárnímu výrazu. Pro lepší čitelnost
jsou všechny nové predikáty rozepsány do neanonymních funkcí:</p>

<pre>
(ns spec-demo2.core)
&nbsp;
(require '[clojure.spec.alpha :as spec])
&nbsp;
(defn name?
    [s]
    (and (string? s) (re-matches #"[A-Z][a-z]+" s)))
&nbsp;
(defn surname?
    [s]
    (and (string? s) (re-matches #"[A-Z][A-Za-z ]+" s)))
&nbsp;
(defn -main
    [&amp; args]
    <strong>(spec/def ::id pos-int?)</strong>
    <strong>(spec/def ::name name?)</strong>
    <strong>(spec/def ::surname surname?)</strong>
    <strong>(spec/def ::person? (spec/keys :req-un [::id ::name ::surname]))</strong>
&nbsp;
    (println "valid?")
    (println "--------------------------------------------------")
    (println (spec/valid? ::person? {:id 10 :name "Rich" :surname "Hickey"}))
    (println (spec/valid? ::person? {:id 10 :name "rich" :surname "Hickey"}))
    (println (spec/valid? ::person? {:id 10 :name "Rich" :surname "hickey"}))
    (println (spec/valid? ::person? {:id -10 :name "Rich" :surname "Hickey"}))
    (println (spec/valid? ::person? {:id -10 :name "rich" :surname "hickey"}))
&nbsp;
    (println "\nexplain")
    (println "--------------------------------------------------")
    (println (spec/explain ::person? {:id 10 :name "Rich" :surname "Hickey"}))
    (println)
    (println (spec/explain ::person? {:id 10 :name "rich" :surname "Hickey"}))
    (println)
    (println (spec/explain ::person? {:id 10 :name "Rich" :surname "hickey"}))
    (println)
    (println (spec/explain ::person? {:id -10 :name "Rich" :surname "Hickey"}))
    (println)
    (println (spec/explain ::person? {:id -10 :name "rich" :surname "hickey"}))
    (println))
</pre>

<pre>
valid?
--------------------------------------------------
true
false
false
false
false
&nbsp;
explain
--------------------------------------------------
Success!
nil
&nbsp;
In: [:name] val: "rich" fails spec: :spec-demo2.core/name at: [:name] predicate: name?
nil
&nbsp;
In: [:surname] val: "hickey" fails spec: :spec-demo2.core/surname at: [:surname] predicate: surname?
nil
&nbsp;
In: [:id] val: -10 fails spec: :spec-demo2.core/id at: [:id] predicate: pos-int?
nil
&nbsp;
In: [:id] val: -10 fails spec: :spec-demo2.core/id at: [:id] predicate: pos-int?
In: [:name] val: "rich" fails spec: :spec-demo2.core/name at: [:name] predicate: name?
In: [:surname] val: "hickey" fails spec: :spec-demo2.core/surname at: [:surname] predicate: surname?
nil
</pre>



<p><a name="k11"></a></p>
<h2 id="k11">11. Validace parametrů předávaných funkci, validace návratových hodnot</h2>

<p>Jakmile máme v&nbsp;centrálním registru uložené validační kritérium
<strong>::person?</strong>, můžeme si k&nbsp;němu zobrazit i automaticky
vygenerovanou nápovědu:</p>

<pre>
user=&gt; <strong>(doc ::person?)</strong>
-------------------------
:user/person?
Spec
  (keys :req-un [:user/id :user/name :user/surname])
nil
</pre>

<p>Validaci je samozřejmě možné provést i u volaných funkcí. Mějme například
funkci vracející jméno osoby získané z&nbsp;mapy (takovou funkci samozřejmě
není zapotřebí programovat, takže se jedná jen o příklad):</p>

<pre>
(defn get-name
    [person]
    (:name person))
</pre>

<p>Pro validní mapy bude tato funkce vracet i očekávané výsledky:</p>

<pre>
user=&gt; <strong>(spec/explain ::person? {:id 10 :name "Carl" :surname "De Boor"})</strong>
Success!
nil
&nbsp;
user=&gt; <strong>(get-name {:id 10 :name "Carl" :surname "De Boor"})</strong>
"Carl"
</pre>

<p>Ovšem validátor lze použít přímo ve funkci. Můžeme zvalidovat jak vstupní
parametr (mapu), tak i výsledek funkce, a to například následovně:</p>

<pre>
(defn checked-get-name
    [person]
    <strong>{:pre [(spec/valid? ::person? person)]</strong>
    <strong> :post [(spec/valid? ::name %)]}</strong>
    (:name person))
</pre>

<p>Chování si opět můžeme snadno otestovat:</p>

<pre>
user=&gt; <strong>(checked-get-name {:id 10 :name "Carl" :surname "De Boor"})</strong>
"Carl"
&nbsp;
user=&gt; <strong>(checked-get-name {:id 10 :name "carl" :surname "De Boor"})</strong>
AssertionError Assert failed: (spec/valid? :user/person? person)  user/checked-get-name (NO_SOURCE_FILE:27)
</pre>

<p>Pokud například programátor v&nbsp;budoucnu změní způsob generování
návratové hodnoty (přidá prefix &bdquo;Name: &ldquo;, což je opět jednoduchý
příklad; v&nbsp;praxi půjde nejspíše o skutečnou chybu), bude na to ihned
upozorněn a bude muset buď funkci opravit nebo změnit validační kritérium:</p>

<pre>
(defn checked-get-name
    [person]
    {:pre [(spec/valid? ::person? person)]
     :post [(spec/valid? ::name %)]}
    (str "Name: " (:name person)))
</pre>

<pre>
user=&gt; <strong>(checked-get-name {:id 10 :name "Carl" :surname "De Boor"})</strong>
AssertionError Assert failed: (spec/valid? :user/name %)  user/checked-get-name (NO_SOURCE_FILE:33)
</pre>



<p><a name="k12"></a></p>
<h2 id="k12">12. Třetí demonstrační příklad &ndash; validace parametrů předávaných funkci</h2>

<p>Ve třetím příkladu je ukázán způsob validace vstupních parametrů funkce i
návratové hodnoty funkce. Vše je založeno na příkladech z&nbsp;předchozích
kapitol:</p>

<pre>
(ns spec-demo3.core)
&nbsp;
(require '[clojure.spec.alpha :as spec])
&nbsp;
(defn name?
    [s]
    (and (string? s) (re-matches #"[A-Z][a-z]+" s)))
&nbsp;
(defn surname?
    [s]
    (and (string? s) (re-matches #"[A-Z][A-Za-z ]+" s)))
&nbsp;
(spec/def ::id pos-int?)
(spec/def ::name name?)
(spec/def ::surname surname?)
(spec/def ::person? (spec/keys :req-un [::id ::name ::surname]))
&nbsp;
(defn get-name
    [person]
    (:name person))
&nbsp;
(defn checked-get-name
    [person]
    {:pre  [(spec/valid? ::person? person)]
     :post [(spec/valid? ::name %)]}
    (:name person))
&nbsp;
(defn -main
    [&amp; args]
    (println "get-name")
    (println (get-name {:id 10 :name "Rich" :surname "Hickey"}))
    (println (get-name {:id 10 :name "rich" :surname "Hickey"}))
    (println (get-name {:id 10 :name "Rich" :surname "hickey"}))
    (println (get-name {:id -10 :name "Rich" :surname "Hickey"}))
    (println (get-name {:id -10 :name "rich" :surname "hickey"}))
    (println)
    (println "checked-get-name")
    (println (checked-get-name {:id 10 :name "Rich" :surname "Hickey"}))
    (println (checked-get-name {:id 10 :name "rich" :surname "Hickey"}))
    (println (checked-get-name {:id 10 :name "Rich" :surname "hickey"}))
    (println (checked-get-name {:id -10 :name "Rich" :surname "Hickey"}))
    (println (checked-get-name {:id -10 :name "rich" :surname "hickey"})))
</pre>

<p>Po spuštění tohoto demonstračního příkladu by měla úspěšně proběhnout
všechna volání funkce <strong>get-name</strong>, ovšem již druhé volání funkce
<strong>checked-get-name</strong> skončí s&nbsp;chybou vlivem nevalidních
vstupních dat:</p>

<pre>
get-name
Rich
rich
Rich
Rich
rich
&nbsp;
checked-get-name
Rich
Exception in thread "main" java.lang.AssertionError: <strong>Assert failed: (spec/valid? :spec-demo3.core/person? person)</strong>, compiling:(/tmp/form-init5569844852904633983.clj:1:73)
        at clojure.lang.Compiler.load(Compiler.java:7526)
        at clojure.lang.Compiler.loadFile(Compiler.java:7452)
        at clojure.main$load_script.invokeStatic(main.clj:278)
        at clojure.main$init_opt.invokeStatic(main.clj:280)
        at clojure.main$init_opt.invoke(main.clj:280)
        at clojure.main$initialize.invokeStatic(main.clj:311)
        at clojure.main$null_opt.invokeStatic(main.clj:345)
        at clojure.main$null_opt.invoke(main.clj:342)
        at clojure.main$main.invokeStatic(main.clj:424)
        at clojure.main$main.doInvoke(main.clj:387)
        at clojure.lang.RestFn.applyTo(RestFn.java:137)
        at clojure.lang.Var.applyTo(Var.java:702)
        at clojure.main.main(main.java:37)
Caused by: java.lang.AssertionError: Assert failed: (spec/valid? :spec-demo3.core/person? person)
        at spec_demo3.core$checked_get_name.invokeStatic(core.clj:22)
        at spec_demo3.core$checked_get_name.invoke(core.clj:22)
        at spec_demo3.core$_main.invokeStatic(core.clj:39)
        at spec_demo3.core$_main.doInvoke(core.clj:28)
        at clojure.lang.RestFn.invoke(RestFn.java:397)
        at clojure.lang.Var.invoke(Var.java:377)
        at user$eval139.invokeStatic(form-init5569844852904633983.clj:1)
        at user$eval139.invoke(form-init5569844852904633983.clj:1)
        at clojure.lang.Compiler.eval(Compiler.java:7062)
        at clojure.lang.Compiler.eval(Compiler.java:7052)
        at clojure.lang.Compiler.load(Compiler.java:7514)
        ... 12 more
</pre>



<p><a name="k13"></a></p>
<h2 id="k13">13. Čtvrtý demonstrační příklad &ndash; chování funkce ve chvíli, kdy není zvalidována její návratová hodnota</h2>

<p>Předposlední příklad vznikl úpravou příkladu předchozího. Je v&nbsp;něm
definována funkce <strong>broken-checked-get-name</strong>, která sice má podle
zapsané podmínky vracet hodnotu odpovídající validačnímu kritériu
<strong>::name</strong>, ovšem ve skutečnosti programátor udělal chybu a funkce
vrací řetězec, který jménu neodpovídá:</p>

<pre>
(ns spec-demo4.core)
&nbsp;
(require '[clojure.spec.alpha :as spec])
&nbsp;
(defn name?
    [s]
    (and (string? s) (re-matches #"[A-Z][a-z]+" s)))
&nbsp;
(defn surname?
    [s]
    (and (string? s) (re-matches #"[A-Z][A-Za-z ]+" s)))
&nbsp;
(spec/def ::id pos-int?)
(spec/def ::name name?)
(spec/def ::surname surname?)
(spec/def ::person? (spec/keys :req-un [::id ::name ::surname]))
&nbsp;
(defn get-name
    [person]
    (:name person))
&nbsp;
(defn broken-checked-get-name
    [person]
    {:pre  [(spec/valid? ::person? person)]
     :post [(spec/valid? ::name %)]}
    (str "name: " (:name person)))
&nbsp;
(defn -main
    [&amp; args]
    (println "get-name")
    (println (get-name {:id 10 :name "Rich" :surname "Hickey"}))
    (println (get-name {:id 10 :name "rich" :surname "Hickey"}))
    (println (get-name {:id 10 :name "Rich" :surname "hickey"}))
    (println (get-name {:id -10 :name "Rich" :surname "Hickey"}))
    (println (get-name {:id -10 :name "rich" :surname "hickey"}))
    (println)
    (println "broken-checked-get-name")
    (println (broken-checked-get-name {:id 10 :name "Rich" :surname "Hickey"})))
</pre>

<p>Výsledkem je chyba při prvním návratu z&nbsp;funkce
<strong>broken-checked-get-name</strong>:</p>

<pre>
get-name
Rich
rich
Rich
Rich
rich
&nbsp;
broken-checked-get-name
Exception in thread "main" java.lang.AssertionError: Assert failed: (spec/valid? :spec-demo4.core/name %), compiling:(/tmp/form-init6747488402196930090.clj:1:73)
        at clojure.lang.Compiler.load(Compiler.java:7526)
        at clojure.lang.Compiler.loadFile(Compiler.java:7452)
        at clojure.main$load_script.invokeStatic(main.clj:278)
        at clojure.main$init_opt.invokeStatic(main.clj:280)
        at clojure.main$init_opt.invoke(main.clj:280)
        at clojure.main$initialize.invokeStatic(main.clj:311)
        at clojure.main$null_opt.invokeStatic(main.clj:345)
        at clojure.main$null_opt.invoke(main.clj:342)
        at clojure.main$main.invokeStatic(main.clj:424)
        at clojure.main$main.doInvoke(main.clj:387)
        at clojure.lang.RestFn.applyTo(RestFn.java:137)
        at clojure.lang.Var.applyTo(Var.java:702)
        at clojure.main.main(main.java:37)
Caused by: java.lang.AssertionError: Assert failed: (spec/valid? :spec-demo4.core/name %)
        at spec_demo4.core$broken_checked_get_name.invokeStatic(core.clj:22)
        at spec_demo4.core$broken_checked_get_name.invoke(core.clj:22)
        at spec_demo4.core$_main.invokeStatic(core.clj:38)
        at spec_demo4.core$_main.doInvoke(core.clj:28)
        at clojure.lang.RestFn.invoke(RestFn.java:397)
        at clojure.lang.Var.invoke(Var.java:377)
        at user$eval139.invokeStatic(form-init6747488402196930090.clj:1)
        at user$eval139.invoke(form-init6747488402196930090.clj:1)
        at clojure.lang.Compiler.eval(Compiler.java:7062)
        at clojure.lang.Compiler.eval(Compiler.java:7052)
        at clojure.lang.Compiler.load(Compiler.java:7514)
        ... 12 more
</pre>



<p><a name="k14"></a></p>
<h2 id="k14">14. Volitelné položky v&nbsp;mapě</h2>

<p>V&nbsp;mnoha případech se setkáme s&nbsp;daty, které obsahují volitelné
položky. Když se stále budeme držet našeho příkladu s&nbsp;informacemi o
osobách, mohou být těmito volitelnými položkami telefon a e-mailová adresa.
Existuje několik způsobů specifikace volitelných položek, ovšem nejjednodušší
je použití klauzule <strong>opt</strong> či <strong>opt-un</strong>. Za touto
klauzulí následuje vektor s&nbsp;klíči, tj.&nbsp;formát zadání je stejný jako u
klauzule <strong>req</strong> i <strong>req-un</strong>:</p>

<pre>
(spec/def ::person? (spec/keys :req-un [::id ::name ::surname] <strong>:opt-un [::phone ::e-mail]</strong>))
</pre>

<p>Samozřejmě můžete provést definici validačního kritéria i pro mapy
s&nbsp;klíči patřícími do aktuálního jmenného prostoru:</p>

<pre>
(spec/def ::person? (spec/keys :req [::id ::name ::surname] <strong>:opt [::phone ::e-mail]</strong>))
</pre>



<p><a name="k15"></a></p>
<h2 id="k15">15. Pátý demonstrační příklad &ndash; validace mapy s&nbsp;volitelnými položkami</h2>

<p>V&nbsp;dalším demonstračním příkladu je ukázán způsob validace map, které
mohou obsahovat volitelné položky. Povšimněte si, že jsou nadefinovány další
dva predikáty pro telefonní číslo a e-mailovou adresu (regulární výraz pro
adresu jsem si &bdquo;vypůjčil&ldquo; ze Stack Overflow :). Do validační části
vstupuje vektor map, což je pravděpodobně nejtypičtější případ při práci
s&nbsp;relačními databázemi. Následuje zdrojový kód tohoto demonstračního
příkladu:</p>

<pre>
(ns spec-demo5.core)
&nbsp;
(require '[clojure.spec.alpha :as spec])
&nbsp;
(defn name?
    [s]
    (and (string? s) (re-matches #"[A-Z][a-z]+" s)))
&nbsp;
(defn surname?
    [s]
    (and (string? s) (re-matches #"[A-Z][A-Za-z ]+" s)))
&nbsp;
(defn email?
    [s]
    (let [pattern #"[a-z0-9!#$%&amp;'*+/=?^_`{|}~-]+(?:\.[a-z0-9!#$%&amp;'*+/=?^_`{|}~-]+)*@(?:[a-z0-9](?:[a-z0-9-]*[a-z0-9])?\.)+[a-z0-9](?:[a-z0-9-]*[a-z0-9])?"]
        (and (string? s) (re-matches pattern s))))
&nbsp;
<strong>(spec/def ::id      pos-int?)</strong>
<strong>(spec/def ::phone   pos-int?)</strong>
<strong>(spec/def ::name    name?)</strong>
<strong>(spec/def ::surname surname?)</strong>
<strong>(spec/def ::e-mail   email?)</strong>
<strong>(spec/def ::person? (spec/keys :req-un [::id ::name ::surname] :opt-un [::phone ::e-mail]))</strong>
&nbsp;
(defn -main
    "I don't do a whole lot ... yet."
    [&amp; args]
    (let [persons [ {:id 10 :name "Rich" :surname "Hickey"}
                    {:id 10 :name "rich" :surname "Hickey"}
                    {:id 10 :name "Rich" :surname "hickey"}
                    {:id -10 :name "Rich" :surname "Hickey"}
                    {:id -10 :name "rich" :surname "hickey"}
                    {:id 10 :name "Rich" :surname "Hickey" :e-mail "rich@somewhere.org"}
                    {:id 10 :name "Rich" :surname "Hickey" :e-mail "wrong"}
                    {:id 10 :name "Rich" :surname "Hickey" :phone 123456789}
                    {:id 10 :name "Rich" :surname "Hickey" :phone nil}
                    {:id 10 :name "Rich" :surname "Hickey" :phone 987654321 :e-mail "rich@somewhere.org"}
                    {:id -10 :name "rich" :surname "" :phone -5 :e-mail "wrong"}]]
        (println "valid?")
        (println "-------------------------------")
&nbsp;
        (doseq [person persons]
            (println person)
            (println (if (spec/valid? ::person? person) "yes\n" "no\n")))
&nbsp;
        (println "\n\n\n")
        (println "explain")
        (println "-------------------------------")
&nbsp;
        (doseq [person persons]
            (println person)
            (println (spec/explain ::person? person))
&nbsp;
            (println))))
</pre>

<p>Výsledky vypsané při validaci jednotlivých záznamů:</p>

<pre>
valid?
-------------------------------
{:id 10, :name Rich, :surname Hickey}
yes
&nbsp;
{:id 10, :name rich, :surname Hickey}
no
&nbsp;
{:id 10, :name Rich, :surname hickey}
no
&nbsp;
{:id -10, :name Rich, :surname Hickey}
no
&nbsp;
{:id -10, :name rich, :surname hickey}
no
&nbsp;
{:id 10, :name Rich, :surname Hickey, :e-mail rich@somewhere.org}
yes
&nbsp;
{:id 10, :name Rich, :surname Hickey, :e-mail wrong}
no
&nbsp;
{:id 10, :name Rich, :surname Hickey, :phone 123456789}
yes
&nbsp;
{:id 10, :name Rich, :surname Hickey, :phone nil}
no
&nbsp;
{:id 10, :name Rich, :surname Hickey, :phone 987654321, :e-mail rich@somewhere.org}
yes
&nbsp;
{:id -10, :name rich, :surname , :phone -5, :e-mail wrong}
no
</pre>

<p>Výsledky vypsané při zjišťování, proč nebyl záznam zvalidován:</p>

<pre>
explain
-------------------------------
{:id 10, :name Rich, :surname Hickey}
Success!
nil
&nbsp;
{:id 10, :name rich, :surname Hickey}
In: [:name] val: "rich" fails spec: :spec-demo5.core/name at: [:name] predicate: name?
nil
&nbsp;
{:id 10, :name Rich, :surname hickey}
In: [:surname] val: "hickey" fails spec: :spec-demo5.core/surname at: [:surname] predicate: surname?
nil
&nbsp;
{:id -10, :name Rich, :surname Hickey}
In: [:id] val: -10 fails spec: :spec-demo5.core/id at: [:id] predicate: pos-int?
nil
&nbsp;
{:id -10, :name rich, :surname hickey}
In: [:id] val: -10 fails spec: :spec-demo5.core/id at: [:id] predicate: pos-int?
In: [:name] val: "rich" fails spec: :spec-demo5.core/name at: [:name] predicate: name?
In: [:surname] val: "hickey" fails spec: :spec-demo5.core/surname at: [:surname] predicate: surname?
nil
&nbsp;
{:id 10, :name Rich, :surname Hickey, :e-mail rich@somewhere.org}
Success!
nil
&nbsp;
{:id 10, :name Rich, :surname Hickey, :e-mail wrong}
In: [:e-mail] val: "wrong" fails spec: :spec-demo5.core/e-mail at: [:e-mail] predicate: email?
nil
&nbsp;
{:id 10, :name Rich, :surname Hickey, :phone 123456789}
Success!
nil
&nbsp;
{:id 10, :name Rich, :surname Hickey, :phone nil}
In: [:phone] val: nil fails spec: :spec-demo5.core/phone at: [:phone] predicate: pos-int?
nil
&nbsp;
{:id 10, :name Rich, :surname Hickey, :phone 987654321, :e-mail rich@somewhere.org}
Success!
nil
&nbsp;
{:id -10, :name rich, :surname , :phone -5, :e-mail wrong}
In: [:id] val: -10 fails spec: :spec-demo5.core/id at: [:id] predicate: pos-int?
In: [:name] val: "rich" fails spec: :spec-demo5.core/name at: [:name] predicate: name?
In: [:surname] val: "" fails spec: :spec-demo5.core/surname at: [:surname] predicate: surname?
In: [:phone] val: -5 fails spec: :spec-demo5.core/phone at: [:phone] predicate: pos-int?
In: [:e-mail] val: "wrong" fails spec: :spec-demo5.core/e-mail at: [:e-mail] predicate: email?
nil
&nbsp;
</pre>



<p><a name="k16"></a></p>
<h2 id="k16">16. Validace n-tic, kolekcí a sekvencí</h2>

<p>V&nbsp;závěrečné části dnešního článku se seznámíme s&nbsp;dvojicí maker,
která jsou velmi užitečná při validaci n-tic (<i>tuple</i>), kolekcí i obecných
sekvencí. První makro se jmenuje jednoduše <strong>tuple</strong> a najdeme ho
pochopitelně ve jmenném prostoru <strong>spec</strong>:</p>

<pre>
spec-demo5.core=&gt; <strong>(doc spec/tuple)</strong>
-------------------------
clojure.spec.alpha/tuple
([&amp; preds])
Macro
  takes one or more preds and returns a spec for a tuple, a vector
  where each element conforms to the corresponding pred. Each element
  will be referred to in paths using its ordinal.
nil
</pre>

<p>Toto makro je možné použít k&nbsp;otestování typů a popř.&nbsp;i hodnot
prvků n-tice, přičemž si pod jménem n-tice můžeme představit vektor (nikoli
seznam!) s&nbsp;předem známým počtem prvků. Příkladem může být dvourozměrný bod
reprezentovaný dvojicí čísel uložených ve vektoru.</p>

<p>Následuje příklad použití tohoto makra (podobný příklad naleznete
v&nbsp;dokumentaci ke knihovně <strong>spec</strong>):</p>

<pre>
user=&gt; <strong>(spec/def ::point (spec/tuple double? double? double?))</strong>
:user/point
</pre>

<p>Otestování, které dvojice odpovídají dvourozměrnému bodu:</p>

<pre>
user=&gt; <strong>(spec/conform ::point [1.5 2.5 -0.5])</strong>
[1.5 2.5 -0.5]
&nbsp;
user=&gt; <strong>(spec/valid? ::point [1.5 2.5 -0.5])</strong>
true
&nbsp;
user=&gt; <strong>(spec/valid? ::point [1/2 2.5 -0.5])</strong>
false
&nbsp;
user=&gt; <strong>(spec/valid? ::point [1 2 3])</strong>
false
</pre>

<p>Seznam nikdy nebude zvalidován, podobně jako n-tice s&nbsp;jiným počtem
prvků či zcela jiný datový typ:</p>

<pre>
user=&gt; <strong>(spec/conform ::point '(1.2 2.3 3.4))</strong>
:clojure.spec.alpha/invalid
&nbsp;
user=&gt; <strong>(spec/conform ::point [1.2 2.3 3.4 5.6])</strong>
:clojure.spec.alpha/invalid
&nbsp;
user=&gt; <strong>(spec/conform ::point "BOD")</strong>
:clojure.spec.alpha/invalid
&nbsp;
user=&gt; <strong>(spec/conform ::point {:x 1 :y 2})</strong>
:clojure.spec.alpha/invalid
&nbsp;
user=&gt; <strong>(spec/conform ::point nil)</strong>
:clojure.spec.alpha/invalid
</pre>

<p>Druhé makro se jmenuje <strong>coll-of</strong> a jeho použití při validaci
je mnohem flexibilnější. Toto makro je možné použít ve chvíli, kdy potřebujeme
otestovat delší sekvenci, vektor či seznam. Můžeme přitom specifikovat predikát
aplikovaný na prvky sekvence, očekávaný počet prvků v&nbsp;sekvenci, minimální
a maximální očekávaný počet prvků, to, zda se prvky mohou opakovat atd. Dokonce
je možné specifikovat, zda se má sekvence po validaci převést na jiný typ
sekvence (vektor na seznam atd.):</p>

<pre>
spec-demo5.core=&gt; <strong>(doc spec/coll-of)</strong>
-------------------------
clojure.spec.alpha/coll-of
([pred &amp; opts])
Macro
  Returns a spec for a collection of items satisfying pred. Unlike
  'every', coll-of will exhaustively conform every value.
&nbsp;
  Same options as 'every'. conform will produce a collection
  corresponding to :into if supplied, else will match the input collection,
  avoiding rebuilding when possible.
&nbsp;
  See also - every, map-of
</pre>



<p><a name="k17"></a></p>
<h2 id="k17">17. Možnosti nabízené makrem <strong>coll-of</strong></h2>

<p>Podívejme se nyní na způsob použití makra <strong>coll-of</strong>, od těch
nejjednodušších příkladů až po příklady nepatrně složitější.</p>

<p>Validace, zda kolekce nebo sekvence obsahují kladná čísla (a nic jiného):</p>

<pre>
user=&gt; <strong>(spec/conform (spec/coll-of pos-int?) [1 2 3 4])</strong>
[1 2 3 4]
&nbsp;
user=&gt; <strong>(spec/conform (spec/coll-of pos-int?) '(1 2 3 4))</strong>
(1 2 3 4)
&nbsp;
user=&gt; <strong>(spec/conform (spec/coll-of pos-int?) '(-1 2 3 4))</strong>
:clojure.spec.alpha/invalid
</pre>

<p>Test (přesněji řečeno validace) bude provedena i pro generované
sekvence:</p>

<pre>
user=&gt; <strong>(spec/conform (spec/coll-of pos-int?) (range 10))</strong>
:clojure.spec.alpha/invalid
&nbsp;
user=&gt; <strong>(spec/conform (spec/coll-of pos-int?) (map inc (range 10)))</strong>
(1 2 3 4 5 6 7 8 9 10)
</pre>

<p>V&nbsp;případě potřeby je možné specifikovat minimální a maximální počet
prvků v&nbsp;sekvenci, případně přímo počet prvků klauzulí
<strong>:count</strong>:</p>

<pre>
user=&gt; <strong>(spec/conform (spec/coll-of nat-int? :count 10) (range 10))</strong>
(0 1 2 3 4 5 6 7 8 9)
&nbsp;
user=&gt; <strong>(spec/conform (spec/coll-of nat-int? :count 10) (range 9))</strong>
:clojure.spec.alpha/invalid
&nbsp;
user=&gt; <strong>(spec/conform (spec/coll-of nat-int? :count 10) (range 11))</strong>
:clojure.spec.alpha/invalid
&nbsp;
user=&gt; <strong>(spec/conform (spec/coll-of nat-int? :min-count 5 :max-count 20) (range 10))</strong>
(0 1 2 3 4 5 6 7 8 9)
&nbsp;
user=&gt; <strong>(spec/conform (spec/coll-of nat-int? :min-count 5 :max-count 20) (range 30))</strong>
:clojure.spec.alpha/invalid
&nbsp;
user=&gt; <strong>(spec/conform (spec/coll-of nat-int? :min-count 5 :max-count 20) (range 3))</strong>
:clojure.spec.alpha/invalid
</pre>

<p>Další možností je test, jakého typu je vstupní sekvence. Sekvence generovaná
pomocí <strong>range</strong> skutečně není vektorem atd.:</p>

<pre>
user=&gt; <strong>(spec/conform (spec/coll-of nat-int? :min-count 5 :max-count 20 :kind vector?) (range 10))</strong>
:clojure.spec.alpha/invalid
&nbsp;
user=&gt; <strong>(spec/conform (spec/coll-of nat-int? :min-count 5 :max-count 20 :kind vector?) (into [] (range 10)))</strong>
[0 1 2 3 4 5 6 7 8 9]
</pre>

<p>Taktéž je možné testovat, jestli se v&nbsp;sekvenci vyskytují některé prvky
dvakrát či vícekrát:</p>

<pre>
user=&gt; <strong>(spec/conform (spec/coll-of nat-int? :min-count 5 :max-count 20 :kind vector? :distinct true) [1 2 3 4 5 6])</strong>
[1 2 3 4 5 6]
&nbsp;
user=&gt; <strong>(spec/conform (spec/coll-of nat-int? :min-count 5 :max-count 20 :kind vector? :distinct true) [1 2 3 1 5 6])</strong>
:clojure.spec.alpha/invalid
</pre>

<p>Poslední užitečná vlastnost &ndash; automatické převedení na jinou sekvenci
v&nbsp;případě úspěšné validace:</p>

<pre>
user=&gt; <strong>(spec/conform (spec/coll-of nat-int? :min-count 5 :max-count 20 :kind vector? :distinct true :into '()) [1 2 3 4 5 6])</strong>
(1 2 3 4 5 6)
</pre>

<p>V&nbsp;dalším článku si popíšeme poslední velmi užitečnou vlastnost &ndash;
možnost deklarovat validační kritéria způsobem, který používá klauzule podobné
&bdquo;žolíkům&ldquo; z&nbsp;regulárních výrazů.</p>



<p><a name="k18"></a></p>
<h2 id="k18">18. Repositář s&nbsp;demonstračními příklady</h2>

<p>Všechny demonstrační příklady a projekty určené pro Clojure verze 1.9.0 byly
uloženy do repositáře <a
href="https://github.com/tisnik/clojure-examples">https://github.com/tisnik/clojure-examples</a>.
Následují odkazy na jednotlivé projekty:</p>

<table>
<tr><th>Projekt</th><th>Popis</th><th>Odkaz</th></tr>
<tr><td>db-store</td><td>uložení mapy do databáze</td><td><a href="https://github.com/tisnik/clojure-examples/tree/master/db-store">https://github.com/tisnik/clojure-examples/tree/master/db-store</a></td></tr>
<tr><td>spec-demo1</td><td>test existence klíčů v&nbsp;mapě</td><td><a href="https://github.com/tisnik/clojure-examples/tree/master/spec-demo1">https://github.com/tisnik/clojure-examples/tree/master/spec-demo1</a></td></tr>
<tr><td>spec-demo2</td><td>kontrola hodnot uložených v&nbsp;mapě</td><td><a href="https://github.com/tisnik/clojure-examples/tree/master/spec-demo2">https://github.com/tisnik/clojure-examples/tree/master/spec-demo2</a></td></tr>
<tr><td>spec-demo3</td><td>validace parametrů funkce</td><td><a href="https://github.com/tisnik/clojure-examples/tree/master/spec-demo3">https://github.com/tisnik/clojure-examples/tree/master/spec-demo3</a></td></tr>
<tr><td>spec-demo4</td><td>validace návratových hodnot</td><td><a href="https://github.com/tisnik/clojure-examples/tree/master/spec-demo4">https://github.com/tisnik/clojure-examples/tree/master/spec-demo4</a></td></tr>
<tr><td>spec-demo5</td><td>validace návratových hodnot</td><td><a href="https://github.com/tisnik/clojure-examples/tree/master/spec-demo5">https://github.com/tisnik/clojure-examples/tree/master/spec-demo5</a></td></tr>
</table>

<p>Pro spuštění projektů je vyžadován nainstalovaný správce projektů
<i>Leiningen</i>.</p>



<p><a name="k19"></a></p>
<h2 id="k19">19. Odkazy na předchozí části tohoto seriálu</h2>

<ol>

<li>Clojure  1: Úvod<br />
<a href="http://www.root.cz/clanky/clojure-aneb-jazyk-umoznujici-tvorbu-bezpecnych-vicevlaknovych-aplikaci-pro-jvm/">http://www.root.cz/clanky/clojure-aneb-jazyk-umoznujici-tvorbu-bezpecnych-vicevlaknovych-aplikaci-pro-jvm/</a>
</li>

<li>Clojure  2: Symboly, kolekce atd.<br />
<a href="http://www.root.cz/clanky/clojure-aneb-jazyk-umoznujici-tvorbu-bezpecnych-vicevlaknovych-aplikaci-pro-jvm-2-cast/">http://www.root.cz/clanky/clojure-aneb-jazyk-umoznujici-tvorbu-bezpecnych-vicevlaknovych-aplikaci-pro-jvm-2-cast/</a>
</li>

<li>Clojure  3: Funkcionální programování<br />
<a href="http://www.root.cz/clanky/clojure-aneb-jazyk-umoznujici-tvorbu-bezpecnych-vicevlaknovych-aplikaci-pro-jvm-3-cast-funkcionalni-programovani/">http://www.root.cz/clanky/clojure-aneb-jazyk-umoznujici-tvorbu-bezpecnych-vicevlaknovych-aplikaci-pro-jvm-3-cast-funkcionalni-programovani/</a>
</li>

<li>Clojure  4: Kolekce, sekvence a lazy sekvence<br />
<a href="http://www.root.cz/clanky/clojure-aneb-jazyk-umoznujici-tvorbu-bezpecnych-vicevlaknovych-aplikaci-pro-jvm-4-cast-kolekce-sekvence-a-lazy-sekvence/">http://www.root.cz/clanky/clojure-aneb-jazyk-umoznujici-tvorbu-bezpecnych-vicevlaknovych-aplikaci-pro-jvm-4-cast-kolekce-sekvence-a-lazy-sekvence/</a>
</li>

<li>Clojure  5: Sekvence, lazy sekvence a paralelní programy<br />
<a href="http://www.root.cz/clanky/clojure-a-bezpecne-aplikace-pro-jvm-sekvence-lazy-sekvence-a-paralelni-programy/">http://www.root.cz/clanky/clojure-a-bezpecne-aplikace-pro-jvm-sekvence-lazy-sekvence-a-paralelni-programy/</a>
</li>

<li>Clojure  6: Podpora pro paralelní programování<br />
<a href="http://www.root.cz/clanky/programovaci-jazyk-clojure-6-futures-nejsou-jen-financni-derivaty/">http://www.root.cz/clanky/programovaci-jazyk-clojure-6-futures-nejsou-jen-financni-derivaty/</a>
</li>

<li>Clojure  7: Další funkce pro paralelní programování<br />
<a href="http://www.root.cz/clanky/programovaci-jazyk-clojure-7-dalsi-podpurne-prostredky-pro-paralelni-programovani/">http://www.root.cz/clanky/programovaci-jazyk-clojure-7-dalsi-podpurne-prostredky-pro-paralelni-programovani/</a>
</li>

<li>Clojure  8: Identity, stavy, neměnné hodnoty a reference<br />
<a href="http://www.root.cz/clanky/programovaci-jazyk-clojure-8-identity-stavy-nemenne-hodnoty-a-referencni-typy/">http://www.root.cz/clanky/programovaci-jazyk-clojure-8-identity-stavy-nemenne-hodnoty-a-referencni-typy/</a>
</li>

<li>Clojure  9: Validátory, pozorovatelé a kooperace s Javou<br />
<a href="http://www.root.cz/clanky/programovaci-jazyk-clojure-9-validatory-pozorovatele-a-kooperace-mezi-clojure-a-javou/">http://www.root.cz/clanky/programovaci-jazyk-clojure-9-validatory-pozorovatele-a-kooperace-mezi-clojure-a-javou/</a>
</li>

<li>Clojure 10: Kooperace mezi Clojure a Javou<br />
<a href="http://www.root.cz/clanky/programovaci-jazyk-clojure-10-kooperace-mezi-clojure-a-javou-pokracovani/">http://www.root.cz/clanky/programovaci-jazyk-clojure-10-kooperace-mezi-clojure-a-javou-pokracovani/</a>
</li>

<li>Clojure 11: Generátorová notace seznamu/list comprehension<br />
<a href="http://www.root.cz/clanky/programovaci-jazyk-clojure-11-generatorova-notace-seznamu-list-comprehension/">http://www.root.cz/clanky/programovaci-jazyk-clojure-11-generatorova-notace-seznamu-list-comprehension/</a>
</li>

<li>Clojure 12: Překlad programů z Clojure do bajtkódu JVM I:<br />
<a href="http://www.root.cz/clanky/programovaci-jazyk-clojure-12-preklad-programu-z-clojure-do-bajtkodu-jvm/">http://www.root.cz/clanky/programovaci-jazyk-clojure-12-preklad-programu-z-clojure-do-bajtkodu-jvm/</a>
</li>

<li>Clojure 13: Překlad programů z Clojure do bajtkódu JVM II:<br />
<a href="http://www.root.cz/clanky/programovaci-jazyk-clojure-13-preklad-programu-z-clojure-do-bajtkodu-jvm-pokracovani/">http://www.root.cz/clanky/programovaci-jazyk-clojure-13-preklad-programu-z-clojure-do-bajtkodu-jvm-pokracovani/</a>
</li>

<li>Clojure 14: Základy práce se systémem maker<br />
<a href="http://www.root.cz/clanky/programovaci-jazyk-clojure-14-zaklady-prace-se-systemem-maker/">http://www.root.cz/clanky/programovaci-jazyk-clojure-14-zaklady-prace-se-systemem-maker/</a>
</li>

<li>Clojure 15: Tvorba uživatelských maker<br />
<a href="http://www.root.cz/clanky/programovaci-jazyk-clojure-15-tvorba-uzivatelskych-maker/">http://www.root.cz/clanky/programovaci-jazyk-clojure-15-tvorba-uzivatelskych-maker/</a>
</li>

<li>Clojure 16: Složitější uživatelská makra<br />
<a href="http://www.root.cz/clanky/programovaci-jazyk-clojure-16-slozitejsi-uzivatelska-makra/">http://www.root.cz/clanky/programovaci-jazyk-clojure-16-slozitejsi-uzivatelska-makra/</a>
</li>

<li>Clojure 17: Využití standardních maker v praxi<br />
<a href="http://www.root.cz/clanky/programovaci-jazyk-clojure-17-vyuziti-standardnich-maker-v-praxi/">http://www.root.cz/clanky/programovaci-jazyk-clojure-17-vyuziti-standardnich-maker-v-praxi/</a>
</li>

<li>Clojure 18: Základní techniky optimalizace aplikací<br />
<a href="http://www.root.cz/clanky/programovaci-jazyk-clojure-18-zakladni-techniky-optimalizace-aplikaci/">http://www.root.cz/clanky/programovaci-jazyk-clojure-18-zakladni-techniky-optimalizace-aplikaci/</a>
</li>

<li>Clojure 19: Vývojová prostředí pro Clojure<br />
<a href="http://www.root.cz/clanky/programovaci-jazyk-clojure-19-vyvojova-prostredi-pro-clojure/">http://www.root.cz/clanky/programovaci-jazyk-clojure-19-vyvojova-prostredi-pro-clojure/</a>
</li>

<li>Clojure 20: Vývojová prostředí pro Clojure (Vimu s REPL)<br />
<a href="http://www.root.cz/clanky/programovaci-jazyk-clojure-20-vyvojova-prostredi-pro-clojure-integrace-vimu-s-repl/">http://www.root.cz/clanky/programovaci-jazyk-clojure-20-vyvojova-prostredi-pro-clojure-integrace-vimu-s-repl/</a>
</li>

<li>Clojure 21: ClojureScript aneb překlad Clojure do JS<br />
<a href="http://www.root.cz/clanky/programovaci-jazyk-clojure-21-clojurescript-aneb-preklad-clojure-do-javascriptu/">http://www.root.cz/clanky/programovaci-jazyk-clojure-21-clojurescript-aneb-preklad-clojure-do-javascriptu/</a>
</li>

<li>Leiningen: nástroj pro správu projektů napsaných v Clojure<br />
<a href="http://www.root.cz/clanky/leiningen-nastroj-pro-spravu-projektu-napsanych-v-clojure/">http://www.root.cz/clanky/leiningen-nastroj-pro-spravu-projektu-napsanych-v-clojure/</a>
</li>

<li>Leiningen: nástroj pro správu projektů napsaných v Clojure (2)<br />
<a href="http://www.root.cz/clanky/leiningen-nastroj-pro-spravu-projektu-napsanych-v-clojure-2/">http://www.root.cz/clanky/leiningen-nastroj-pro-spravu-projektu-napsanych-v-clojure-2/</a>
</li>

<li>Leiningen: nástroj pro správu projektů napsaných v Clojure (3)<br />
<a href="http://www.root.cz/clanky/leiningen-nastroj-pro-spravu-projektu-napsanych-v-clojure-3/">http://www.root.cz/clanky/leiningen-nastroj-pro-spravu-projektu-napsanych-v-clojure-3/</a>
</li>

<li>Leiningen: nástroj pro správu projektů napsaných v Clojure (4)<br />
<a href="http://www.root.cz/clanky/leiningen-nastroj-pro-spravu-projektu-napsanych-v-clojure-4/">http://www.root.cz/clanky/leiningen-nastroj-pro-spravu-projektu-napsanych-v-clojure-4/</a>
</li>

<li>Leiningen: nástroj pro správu projektů napsaných v Clojure (5)<br />
<a href="http://www.root.cz/clanky/leiningen-nastroj-pro-spravu-projektu-napsanych-v-clojure-5/">http://www.root.cz/clanky/leiningen-nastroj-pro-spravu-projektu-napsanych-v-clojure-5/</a>
</li>

<li>Leiningen: nástroj pro správu projektů napsaných v Clojure (6)<br />
<a href="http://www.root.cz/clanky/leiningen-nastroj-pro-spravu-projektu-napsanych-v-clojure-6/">http://www.root.cz/clanky/leiningen-nastroj-pro-spravu-projektu-napsanych-v-clojure-6/</a>
</li>

<li>Programovací jazyk Clojure a databáze (1.část)<br />
<a href="http://www.root.cz/clanky/programovaci-jazyk-clojure-a-databaze-1-cast/">http://www.root.cz/clanky/programovaci-jazyk-clojure-a-databaze-1-cast/</a>
</li>

<li>Pluginy pro Leiningen<br />
<a href="http://www.root.cz/clanky/leiningen-nastroj-pro-spravu-projektu-napsanych-v-clojure-pluginy-pro-leiningen/">http://www.root.cz/clanky/leiningen-nastroj-pro-spravu-projektu-napsanych-v-clojure-pluginy-pro-leiningen/</a>
</li>

<li>Programovací jazyk Clojure a knihovny pro práci s vektory a maticemi<br />
<a href="http://www.root.cz/clanky/programovaci-jazyk-clojure-a-knihovny-pro-praci-s-vektory-a-maticemi/">http://www.root.cz/clanky/programovaci-jazyk-clojure-a-knihovny-pro-praci-s-vektory-a-maticemi/</a>
</li>

<li>Programovací jazyk Clojure a knihovny pro práci s vektory a maticemi (2)<br />
<a href="http://www.root.cz/clanky/programovaci-jazyk-clojure-a-knihovny-pro-praci-s-vektory-a-maticemi-2/">http://www.root.cz/clanky/programovaci-jazyk-clojure-a-knihovny-pro-praci-s-vektory-a-maticemi-2/</a>
</li>

<li>Programovací jazyk Clojure: syntéza procedurálních textur s využitím knihovny Clisk<br />
<a href="http://www.root.cz/clanky/programovaci-jazyk-clojure-synteza-proceduralnich-textur-s-vyuzitim-knihovny-clisk/">http://www.root.cz/clanky/programovaci-jazyk-clojure-synteza-proceduralnich-textur-s-vyuzitim-knihovny-clisk/</a>
</li>

<li>Programovací jazyk Clojure: syntéza procedurálních textur s využitím knihovny Clisk (2)<br />
<a href="http://www.root.cz/clanky/programovaci-jazyk-clojure-synteza-proceduralnich-textur-s-vyuzitim-knihovny-clisk-2/">http://www.root.cz/clanky/programovaci-jazyk-clojure-synteza-proceduralnich-textur-s-vyuzitim-knihovny-clisk-2/</a>
</li>

<li>Seesaw: knihovna pro snadnou tvorbu GUI v jazyce Clojure<br />
<a href="http://www.root.cz/clanky/seesaw-knihovna-pro-snadnou-tvorbu-gui-v-jazyce-clojure/">http://www.root.cz/clanky/seesaw-knihovna-pro-snadnou-tvorbu-gui-v-jazyce-clojure/</a>
</li>

<li>Seesaw: knihovna pro snadnou tvorbu GUI v jazyce Clojure (2)<br />
<a href="http://www.root.cz/clanky/seesaw-knihovna-pro-snadnou-tvorbu-gui-v-jazyce-clojure-2/">http://www.root.cz/clanky/seesaw-knihovna-pro-snadnou-tvorbu-gui-v-jazyce-clojure-2/</a>
</li>

<li>Seesaw: knihovna pro snadnou tvorbu GUI v jazyce Clojure (3)<br />
<a href="http://www.root.cz/clanky/seesaw-knihovna-pro-snadnou-tvorbu-gui-v-jazyce-clojure-3/">http://www.root.cz/clanky/seesaw-knihovna-pro-snadnou-tvorbu-gui-v-jazyce-clojure-3/</a>
</li>

<li>Programovací jazyk Clojure a práce s Gitem<br />
<a href="http://www.root.cz/clanky/programovaci-jazyk-clojure-a-prace-s-gitem/">http://www.root.cz/clanky/programovaci-jazyk-clojure-a-prace-s-gitem/</a>
</li>

<li>Programovací jazyk Clojure: syntéza procedurálních textur s využitím knihovny Clisk (dokončení)<br />
<a href="http://www.root.cz/clanky/programovaci-jazyk-clojure-synteza-proceduralnich-textur-s-vyuzitim-knihovny-clisk-dokonceni/">http://www.root.cz/clanky/programovaci-jazyk-clojure-synteza-proceduralnich-textur-s-vyuzitim-knihovny-clisk-dokonceni/</a>
</li>

<li>Programovací jazyk Clojure a práce s Gitem (2)<br />
<a href="http://www.root.cz/clanky/programovaci-jazyk-clojure-a-prace-s-gitem-2/">http://www.root.cz/clanky/programovaci-jazyk-clojure-a-prace-s-gitem-2/</a>
</li>

<li>Programovací jazyk Clojure – triky při práci s řetězci<br />
<a href="http://www.root.cz/clanky/programovaci-jazyk-clojure-triky-pri-praci-s-retezci/">http://www.root.cz/clanky/programovaci-jazyk-clojure-triky-pri-praci-s-retezci/</a>
</li>

<li>Programovací jazyk Clojure – triky při práci s kolekcemi<br />
<a href="http://www.root.cz/clanky/programovaci-jazyk-clojure-triky-pri-praci-s-kolekcemi/">http://www.root.cz/clanky/programovaci-jazyk-clojure-triky-pri-praci-s-kolekcemi/</a>
</li>

<li>Programovací jazyk Clojure – práce s mapami a množinami<br />
<a href="http://www.root.cz/clanky/programovaci-jazyk-clojure-prace-s-mapami-a-mnozinami/">http://www.root.cz/clanky/programovaci-jazyk-clojure-prace-s-mapami-a-mnozinami/</a>
</li>

<li>Programovací jazyk Clojure – základy zpracování XML<br />
<a href="http://www.root.cz/clanky/programovaci-jazyk-clojure-zaklady-zpracovani-xml/">http://www.root.cz/clanky/programovaci-jazyk-clojure-zaklady-zpracovani-xml/</a>
</li>

<li>Programovací jazyk Clojure – testování s využitím knihovny Expectations<br />
<a href="http://www.root.cz/clanky/programovaci-jazyk-clojure-testovani-s-vyuzitim-knihovny-expectations/">http://www.root.cz/clanky/programovaci-jazyk-clojure-testovani-s-vyuzitim-knihovny-expectations/</a>
</li>

<li>Programovací jazyk Clojure – některé užitečné triky použitelné (nejenom) v&nbsp;testech<br />
<a href="http://www.root.cz/clanky/programovaci-jazyk-clojure-nektere-uzitecne-triky-pouzitelne-nejenom-v-testech/">http://www.root.cz/clanky/programovaci-jazyk-clojure-nektere-uzitecne-triky-pouzitelne-nejenom-v-testech/</a>
</li>

<li>Enlive – výkonný šablonovací systém pro jazyk Clojure<br/>
<a href="http://www.root.cz/clanky/enlive-vykonny-sablonovaci-system-pro-jazyk-clojure/">http://www.root.cz/clanky/enlive-vykonny-sablonovaci-system-pro-jazyk-clojure/</a>
</li>

<li>Nástroj Leiningen a programovací jazyk Clojure: tvorba vlastních knihoven pro veřejný repositář Clojars<br />
<a href="http://www.root.cz/clanky/nastroj-leiningen-a-programovaci-jazyk-clojure-tvorba-vlastnich-knihoven-pro-verejny-repositar-clojars/">http://www.root.cz/clanky/nastroj-leiningen-a-programovaci-jazyk-clojure-tvorba-vlastnich-knihoven-pro-verejny-repositar-clojars/</a>
</li>

<li>Novinky v Clojure verze 1.8.0<br />
<a href="http://www.root.cz/clanky/novinky-v-clojure-verze-1-8-0/">http://www.root.cz/clanky/novinky-v-clojure-verze-1-8-0/</a>
</li>

<li>Asynchronní programování v&nbsp;Clojure s&nbsp;využitím knihovny core.async<br />
<a href="http://www.root.cz/clanky/asynchronni-programovani-v-clojure-s-vyuzitim-knihovny-core-async/">http://www.root.cz/clanky/asynchronni-programovani-v-clojure-s-vyuzitim-knihovny-core-async/</a>
</li>

<li>Asynchronní programování v&nbsp;Clojure s&nbsp;využitím knihovny core.async (pokračování)<br />
<a href="http://www.root.cz/clanky/asynchronni-programovani-v-clojure-s-vyuzitim-knihovny-core-async-pokracovani/">http://www.root.cz/clanky/asynchronni-programovani-v-clojure-s-vyuzitim-knihovny-core-async-pokracovani/</a>
</li>

<li>Asynchronní programování v Clojure s využitím knihovny core.async (dokončení)<br />
<a href="http://www.root.cz/clanky/asynchronni-programovani-v-clojure-s-vyuzitim-knihovny-core-async-dokonceni/">http://www.root.cz/clanky/asynchronni-programovani-v-clojure-s-vyuzitim-knihovny-core-async-dokonceni/</a>
</li>

<li>Vytváříme IRC bota v programovacím jazyce Clojure<br />
<a href="http://www.root.cz/clanky/vytvarime-irc-bota-v-programovacim-jazyce-clojure/">http://www.root.cz/clanky/vytvarime-irc-bota-v-programovacim-jazyce-clojure/</a>
</li>

<li>Gorilla REPL: interaktivní prostředí pro programovací jazyk Clojure<br />
<a href="https://www.root.cz/clanky/gorilla-repl-interaktivni-prostredi-pro-programovaci-jazyk-clojure/">https://www.root.cz/clanky/gorilla-repl-interaktivni-prostredi-pro-programovaci-jazyk-clojure/</a>
</li>

<li>Multimetody v Clojure aneb polymorfismus bez použití OOP<br />
<a href="https://www.root.cz/clanky/multimetody-v-clojure-aneb-polymorfismus-bez-pouziti-oop/">https://www.root.cz/clanky/multimetody-v-clojure-aneb-polymorfismus-bez-pouziti-oop/</a>
</li>

<li>Práce s externími Java archivy v programovacím jazyku Clojure<br />
<a href="https://www.root.cz/clanky/prace-s-externimi-java-archivy-v-programovacim-jazyku-clojure/">https://www.root.cz/clanky/prace-s-externimi-java-archivy-v-programovacim-jazyku-clojure/</a>
</li>

<li>Pixie: lehký skriptovací jazyk s „kouzelnými“ schopnostmi<br />
<a href="https://www.root.cz/clanky/pixie-lehky-skriptovaci-jazyk-s-kouzelnymi-schopnostmi/">https://www.root.cz/clanky/pixie-lehky-skriptovaci-jazyk-s-kouzelnymi-schopnostmi/</a>
</li>

<li>Programovací jazyk Pixie: funkce ze základní knihovny a použití FFI<br />
<a href="https://www.root.cz/clanky/programovaci-jazyk-pixie-funkce-ze-zakladni-knihovny-a-pouziti-ffi/">https://www.root.cz/clanky/programovaci-jazyk-pixie-funkce-ze-zakladni-knihovny-a-pouziti-ffi/</a>
</li>

<li>Novinky v Clojure verze 1.9.0<br />
<a href="https://www.root.cz/clanky/novinky-v-clojure-verze-1-9-0/">https://www.root.cz/clanky/novinky-v-clojure-verze-1-9-0/</a>
</li>

</ol>



<p><a name="k20"></a></p>
<h2 id="k20">20. Odkazy na Internetu</h2>

<ol>

<li>5 Differences between clojure.spec and Schema<br />
<a href="https://lispcast.com/clojure.spec-vs-schema/">https://lispcast.com/clojure.spec-vs-schema/</a>
</li>

<li>Schema: Clojure(Script) library for declarative data description and validation<br />
<a href="https://github.com/plumatic/schema">https://github.com/plumatic/schema</a>
</li>

<li>Zip archiv s&nbsp;Clojure 1.9.0<br />
<a href="http://repo1.maven.org/maven2/org/clojure/clojure/1.9.0/clojure-1.9.0.zip">http://repo1.maven.org/maven2/org/clojure/clojure/1.9.0/clojure-1.9.0.zip</a>
</li>

<li>Clojure 1.9 is now available<br />
<a href="https://clojure.org/news/2017/12/08/clojure19">https://clojure.org/news/2017/12/08/clojure19</a>
</li>

<li>Deps and CLI Guide<br />
<a href="https://clojure.org/guides/deps_and_cli">https://clojure.org/guides/deps_and_cli</a>
</li>

<li>Changes to Clojure in Version 1.9<br />
<a href="https://github.com/clojure/clojure/blob/master/changes.md">https://github.com/clojure/clojure/blob/master/changes.md</a>
</li>

<li>clojure.spec - Rationale and Overview<br />
<a href="https://clojure.org/about/spec">https://clojure.org/about/spec</a>
</li>

<li>Zip archiv s&nbsp;Clojure 1.8.0<br />
<a href="http://repo1.maven.org/maven2/org/clojure/clojure/1.8.0/clojure-1.8.0.zip">http://repo1.maven.org/maven2/org/clojure/clojure/1.8.0/clojure-1.8.0.zip</a>
</li>

<li>Clojure 1.8 is now available<br />
<a href="http://clojure.org/news/2016/01/19/clojure18">http://clojure.org/news/2016/01/19/clojure18</a>
</li>

<li>Socket Server REPL<br />
<a href="http://dev.clojure.org/display/design/Socket+Server+REPL">http://dev.clojure.org/display/design/Socket+Server+REPL</a>
</li>

<li>CLJ-1671: Clojure socket server<br />
<a href="http://dev.clojure.org/jira/browse/CLJ-1671">http://dev.clojure.org/jira/browse/CLJ-1671</a>
</li>

<li>CLJ-1449: Add clojure.string functions for portability to ClojureScript<br />
<a href="http://dev.clojure.org/jira/browse/CLJ-1449">http://dev.clojure.org/jira/browse/CLJ-1449</a>
</li>

<li>Launching a Socket Server<br />
<a href="http://clojure.org/reference/repl_and_main#_launching_a_socket_server">http://clojure.org/reference/repl_and_main#_launching_a_socket_server</a>
</li>

<li>API for clojure.string<br />
<a href="http://clojure.github.io/clojure/branch-master/clojure.string-api.html">http://clojure.github.io/clojure/branch-master/clojure.string-api.html</a>
</li>

<li>Clojars:<br />
<a href="https://clojars.org/">https://clojars.org/</a>
</li>

<li>Seznam knihoven na Clojars:<br />
<a href="https://clojars.org/projects">https://clojars.org/projects</a>
</li>

<li>Clojure Cookbook: Templating HTML with Enlive<br />
<a href="https://github.com/clojure-cookbook/clojure-cookbook/blob/master/07_webapps/7-11_enlive.asciidoc">https://github.com/clojure-cookbook/clojure-cookbook/blob/master/07_webapps/7-11_enlive.asciidoc</a>
</li>

<li>An Introduction to Enlive<br />
<a href="https://github.com/swannodette/enlive-tutorial/">https://github.com/swannodette/enlive-tutorial/</a>
</li>

<li>Enlive na GitHubu<br />
<a href="https://github.com/cgrand/enlive">https://github.com/cgrand/enlive</a>
</li>

<li>Expectations: příklady atd.<br />
<a href="http://jayfields.com/expectations/">http://jayfields.com/expectations/</a>
</li>

<li>Expectations na GitHubu<br />
<a href="https://github.com/jaycfields/expectations">https://github.com/jaycfields/expectations</a>
</li>

<li>Lein-expectations na GitHubu<br />
<a href="https://github.com/gar3thjon3s/lein-expectations">https://github.com/gar3thjon3s/lein-expectations</a>
</li>

<li>Testing Clojure With Expectations<br />
<a href="https://semaphoreci.com/blog/2014/09/23/testing-clojure-with-expectations.html">https://semaphoreci.com/blog/2014/09/23/testing-clojure-with-expectations.html</a>
</li>

<li>Clojure testing TDD/BDD libraries: clojure.test vs Midje vs Expectations vs Speclj<br />
<a href="https://www.reddit.com/r/Clojure/comments/1viilt/clojure_testing_tddbdd_libraries_clojuretest_vs/">https://www.reddit.com/r/Clojure/comments/1viilt/clojure_testing_tddbdd_libraries_clojuretest_vs/</a>
</li>

<li>Testing: One assertion per test<br />
<a href="http://blog.jayfields.com/2007/06/testing-one-assertion-per-test.html">http://blog.jayfields.com/2007/06/testing-one-assertion-per-test.html</a>
</li>

<li>Rewriting Your Test Suite in Clojure in 24 hours<br />
<a href="http://blog.circleci.com/rewriting-your-test-suite-in-clojure-in-24-hours/">http://blog.circleci.com/rewriting-your-test-suite-in-clojure-in-24-hours/</a>
</li>

<li>Clojure doc: zipper<br />
<a href="http://clojuredocs.org/clojure.zip/zipper">http://clojuredocs.org/clojure.zip/zipper</a>
</li>

<li>Clojure doc: parse<br />
<a href="http://clojuredocs.org/clojure.xml/parse">http://clojuredocs.org/clojure.xml/parse</a>
</li>

<li>Clojure doc: xml-zip<br />
<a href="http://clojuredocs.org/clojure.zip/xml-zip">http://clojuredocs.org/clojure.zip/xml-zip</a>
</li>

<li>Clojure doc: xml-seq<br />
<a href="http://clojuredocs.org/clojure.core/xml-seq">http://clojuredocs.org/clojure.core/xml-seq</a>
</li>

<li>Parsing XML in Clojure<br />
<a href="https://github.com/clojuredocs/guides">https://github.com/clojuredocs/guides</a>
</li>

<li>Clojure Zipper Over Nested Vector<br />
<a href="https://vitalyper.wordpress.com/2010/11/23/clojure-zipper-over-nested-vector/">https://vitalyper.wordpress.com/2010/11/23/clojure-zipper-over-nested-vector/</a>
</li>

<li>Understanding Clojure's PersistentVector implementation<br />
<a href="http://blog.higher-order.net/2009/02/01/understanding-clojures-persistentvector-implementation">http://blog.higher-order.net/2009/02/01/understanding-clojures-persistentvector-implementation</a>
</li>

<li>Understanding Clojure's PersistentHashMap (deftwice...)<br />
<a href="http://blog.higher-order.net/2009/09/08/understanding-clojures-persistenthashmap-deftwice.html">http://blog.higher-order.net/2009/09/08/understanding-clojures-persistenthashmap-deftwice.html</a>
</li>

<li>Assoc and Clojure's PersistentHashMap: part ii<br />
<a href="http://blog.higher-order.net/2010/08/16/assoc-and-clojures-persistenthashmap-part-ii.html">http://blog.higher-order.net/2010/08/16/assoc-and-clojures-persistenthashmap-part-ii.html</a>
</li>

<li>Ideal Hashtrees (paper)<br />
<a href="http://lampwww.epfl.ch/papers/idealhashtrees.pdf">http://lampwww.epfl.ch/papers/idealhashtrees.pdf</a>
</li>

<li>Clojure home page<br />
<a href="http://clojure.org/">http://clojure.org/</a>
</li>

<li>Clojure (downloads)<br />
<a href="http://clojure.org/downloads">http://clojure.org/downloads</a>
</li>

<li>Clojure Sequences<br />
<a href="http://clojure.org/sequences">http://clojure.org/sequences</a>
</li>

<li>Clojure Data Structures<br />
<a href="http://clojure.org/data_structures">http://clojure.org/data_structures</a>
</li>

<li>The Structure and Interpretation of Computer Programs: 2.2.1  Representing Sequences<br />
<a href="http://mitpress.mit.edu/sicp/full-text/book/book-Z-H-15.html#%_sec_2.2.1">http://mitpress.mit.edu/sicp/full-text/book/book-Z-H-15.html#%_sec_2.2.1</a>
</li>

<li>The Structure and Interpretation of Computer Programs: 3.3.1  Mutable List Structure<br />
<a href="http://mitpress.mit.edu/sicp/full-text/book/book-Z-H-22.html#%_sec_3.3.1">http://mitpress.mit.edu/sicp/full-text/book/book-Z-H-22.html#%_sec_3.3.1</a>
</li>

<li>Clojure - Functional Programming for the JVM<br />
<a href="http://java.ociweb.com/mark/clojure/article.html">http://java.ociweb.com/mark/clojure/article.html</a>
</li>

<li>Clojure quick reference<br />
<a href="http://faustus.webatu.com/clj-quick-ref.html">http://faustus.webatu.com/clj-quick-ref.html</a>
</li>

<li>4Clojure<br />
<a href="http://www.4clojure.com/">http://www.4clojure.com/</a>
</li>

<li>ClojureDoc (rozcestník s&nbsp;dokumentací jazyka Clojure)<br />
<a href="http://clojuredocs.org/">http://clojuredocs.org/</a>
</li>

<li>Clojure (na Wikipedia EN)<br />
<a href="http://en.wikipedia.org/wiki/Clojure">http://en.wikipedia.org/wiki/Clojure</a>
</li>

<li>Clojure (na Wikipedia CS)<br />
<a href="http://cs.wikipedia.org/wiki/Clojure">http://cs.wikipedia.org/wiki/Clojure</a>
</li>

<li>SICP (The Structure and Interpretation of Computer Programs)<br />
<a href="http://mitpress.mit.edu/sicp/">http://mitpress.mit.edu/sicp/</a>
</li>

<li>Pure function<br />
<a href="http://en.wikipedia.org/wiki/Pure_function">http://en.wikipedia.org/wiki/Pure_function</a>
</li>

<li>Funkcionální programování<br />
<a href="http://cs.wikipedia.org/wiki/Funkcionální_programování">http://cs.wikipedia.org/wiki/Funkcionální_programování</a>
</li>

<li>Čistě funkcionální (datové struktury, jazyky, programování)<br />
<a href="http://cs.wikipedia.org/wiki/Čistě_funkcionální">http://cs.wikipedia.org/wiki/Čistě_funkcionální</a>
</li>

<li>Clojure Macro Tutorial (Part I, Getting the Compiler to Write Your Code For You)<br />
<a href="http://www.learningclojure.com/2010/09/clojure-macro-tutorial-part-i-getting.html">http://www.learningclojure.com/2010/09/clojure-macro-tutorial-part-i-getting.html</a>
</li>

<li>Clojure Macro Tutorial (Part II: The Compiler Strikes Back)<br />
<a href="http://www.learningclojure.com/2010/09/clojure-macro-tutorial-part-ii-compiler.html">http://www.learningclojure.com/2010/09/clojure-macro-tutorial-part-ii-compiler.html</a>
</li>

<li>Clojure Macro Tutorial (Part III: Syntax Quote)<br />
<a href="http://www.learningclojure.com/2010/09/clojure-macro-tutorial-part-ii-syntax.html">http://www.learningclojure.com/2010/09/clojure-macro-tutorial-part-ii-syntax.html</a>
</li>

<li>Tech behind Tech: Clojure Macros Simplified<br />
<a href="http://techbehindtech.com/2010/09/28/clojure-macros-simplified/">http://techbehindtech.com/2010/09/28/clojure-macros-simplified/</a>
</li>

<li>Fatvat - Exploring functional programming: Clojure Macros<br />
<a href="http://www.fatvat.co.uk/2009/02/clojure-macros.html">http://www.fatvat.co.uk/2009/02/clojure-macros.html</a>
</li>

<li>Eulerovo číslo<br />
<a href="http://cs.wikipedia.org/wiki/Eulerovo_číslo">http://cs.wikipedia.org/wiki/Eulerovo_číslo</a>
</li>

<li>List comprehension<br />
<a href="http://en.wikipedia.org/wiki/List_comprehension">http://en.wikipedia.org/wiki/List_comprehension</a>
</li>

<li>List Comprehensions in Clojure<br />
<a href="http://asymmetrical-view.com/2008/11/18/list-comprehensions-in-clojure.html">http://asymmetrical-view.com/2008/11/18/list-comprehensions-in-clojure.html</a>
</li>

<li>Clojure Programming Concepts: List Comprehension<br />
<a href="http://en.wikibooks.org/wiki/Clojure_Programming/Concepts#List_Comprehension">http://en.wikibooks.org/wiki/Clojure_Programming/Concepts#List_Comprehension</a>
</li>

<li>Clojure core API: for macro<br />
<a href="http://clojure.github.com/clojure/clojure.core-api.html#clojure.core/for">http://clojure.github.com/clojure/clojure.core-api.html#clojure.core/for</a>
</li>

<li>cirrus machina - The Clojure for macro<br />
<a href="http://www.cirrusmachina.com/blog/comment/the-clojure-for-macro/">http://www.cirrusmachina.com/blog/comment/the-clojure-for-macro/</a>
</li>

<li>Riastradh's Lisp Style Rules<br />
<a href="http://mumble.net/~campbell/scheme/style.txt">http://mumble.net/~campbell/scheme/style.txt</a>
</li>

<li>Dynamic Languages Strike Back<br />
<a href="http://steve-yegge.blogspot.cz/2008/05/dynamic-languages-strike-back.html">http://steve-yegge.blogspot.cz/2008/05/dynamic-languages-strike-back.html</a>
</li>

<li>Scripting: Higher Level Programming for the 21st Century<br />
<a href="http://www.tcl.tk/doc/scripting.html">http://www.tcl.tk/doc/scripting.html</a>
</li>

<li>Java Virtual Machine Support for Non-Java Languages<br />
<a href="http://docs.oracle.com/javase/7/docs/technotes/guides/vm/multiple-language-support.html">http://docs.oracle.com/javase/7/docs/technotes/guides/vm/multiple-language-support.html</a>
</li>

<li>Třída java.lang.String<br />
<a href="http://docs.oracle.com/javase/7/docs/api/java/lang/String.html">http://docs.oracle.com/javase/7/docs/api/java/lang/String.html</a>
</li>

<li>Třída java.lang.StringBuffer<br />
<a href="http://docs.oracle.com/javase/7/docs/api/java/lang/StringBuffer.html">http://docs.oracle.com/javase/7/docs/api/java/lang/StringBuffer.html</a>
</li>

<li>Třída java.lang.StringBuilder<br />
<a href="http://docs.oracle.com/javase/7/docs/api/java/lang/StringBuilder.html">http://docs.oracle.com/javase/7/docs/api/java/lang/StringBuilder.html</a>
</li>

<li>StringBuffer versus String<br />
<a href="http://www.javaworld.com/article/2076072/build-ci-sdlc/stringbuffer-versus-string.html">http://www.javaworld.com/article/2076072/build-ci-sdlc/stringbuffer-versus-string.html</a>
</li>

<li>Threading macro (dokumentace k&nbsp;jazyku Clojure)<br />
<a href="https://clojure.github.io/clojure/clojure.core-api.html#clojure.core/-&gt;">https://clojure.github.io/clojure/clojure.core-api.html#clojure.core/-&gt;</a>
</li>

<li>Understanding the Clojure -&gt; macro<br />
<a href="http://blog.fogus.me/2009/09/04/understanding-the-clojure-macro/">http://blog.fogus.me/2009/09/04/understanding-the-clojure-macro/</a>
</li>

<li>clojure.inspector<br />
<a href="http://clojure.github.io/clojure/clojure.inspector-api.html">http://clojure.github.io/clojure/clojure.inspector-api.html</a>
</li>

<li>The Clojure Toolbox<br />
<a href="http://www.clojure-toolbox.com/">http://www.clojure-toolbox.com/</a>
</li>

<li>Unit Testing in Clojure<br />
<a href="http://nakkaya.com/2009/11/18/unit-testing-in-clojure/">http://nakkaya.com/2009/11/18/unit-testing-in-clojure/</a>
</li>

<li>Testing in Clojure (Part-1: Unit testing)<br />
<a href="http://blog.knoldus.com/2014/03/22/testing-in-clojure-part-1-unit-testing/">http://blog.knoldus.com/2014/03/22/testing-in-clojure-part-1-unit-testing/</a>
</li>

<li>API for clojure.test - Clojure v1.6 (stable)<br />
<a href="https://clojure.github.io/clojure/clojure.test-api.html">https://clojure.github.io/clojure/clojure.test-api.html</a>
</li>

<li>Leiningen: úvodní stránka<br />
<a href="http://leiningen.org/">http://leiningen.org/</a>
</li>

<li>Leiningen: Git repository<br />
<a href="https://github.com/technomancy/leiningen">https://github.com/technomancy/leiningen</a>
</li>

<li>leiningen-win-installer<br />
<a href="http://leiningen-win-installer.djpowell.net/">http://leiningen-win-installer.djpowell.net/</a>
</li>

<li>Clojure.org: Vars and the Global Environment<br />
<a href="http://clojure.org/Vars">http://clojure.org/Vars</a>
</li>

<li>Clojure.org: Refs and Transactions<br />
<a href="http://clojure.org/Refs">http://clojure.org/Refs</a>
</li>

<li>Clojure.org: Atoms<br />
<a href="http://clojure.org/Atoms">http://clojure.org/Atoms</a>
</li>

<li>Clojure.org: Agents as Asynchronous Actions<br />
<a href="http://clojure.org/agents">http://clojure.org/agents</a>
</li>

<li>Transient Data Structures
<a href="http://clojure.org/transients">http://clojure.org/transients</a>
</li>

</ol>



<p></p><p></p>
<p><small>Autor: <a href="http://www.fit.vutbr.cz/~tisnovpa">Pavel Tišnovský</a> &nbsp; 2018</small></p>
</body>
</html>

