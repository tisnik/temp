<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
        "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html>
<head>
<title>Propojení světa LISPu se světem JavaScriptu s využitím transpřekladače Wisp</title>
<meta name="Author" content="Pavel Tisnovsky" />
<meta name="Generator" content="vim" />
<meta http-equiv="content-type" content="text/html; charset=utf-8" />
<style type="text/css">
         body {color:#000000; background:#ffffff;}
         h1  {font-family: arial, helvetica, sans-serif; color:#ffffff; background-color:#c00000; text-align:center; padding-left:1em}
         h2  {font-family: arial, helvetica, sans-serif; color:#ffffff; background-color:#0000c0; padding-left:1em; text-align:left}
         h3  {font-family: arial, helvetica, sans-serif; color:#000000; background-color:#c0c0c0; padding-left:1em; text-align:left}
         h4  {font-family: arial, helvetica, sans-serif; color:#000000; background-color:#e0e0e0; padding-left:1em; text-align:left}
         a   {font-family: arial, helvetica, sans-serif;}
         li  {font-family: arial, helvetica, sans-serif; color:#000000; text-align:justify; width:450px;}
         ol  {font-family: arial, helvetica, sans-serif; color:#000000; text-align:justify; width:450px;}
         ul  {font-family: arial, helvetica, sans-serif; color:#000000; text-align:justify; width:450px;}
         p   {font-family: arial, helvetica, sans-serif; color:#000000; text-align:justify;}
         pre {background:#e0e0e0}
</style>
</head>

<body>

<h1>Propojení světa LISPu se světem JavaScriptu s využitím transpřekladače Wisp</h1>

<h3>Pavel Tišnovský</h3>

<p></p>

<h1>Úvodník</h1>

<p>V článku o projektech lua2js a lua.vm.js jsme se seznámili se způsobem využití programovacího jazyka Lua na webových stránkách, a to samozřejmě i v prohlížečích nativně podporujících pouze JavaScript. Dnes se budeme zabývat ambicióznějším nástrojem nazvaným Wisp, jehož cílem je propojení zjednodušené varianty Clojure(Scriptu) s JavaScriptem.</p>



<h2>Obsah</h2>

<p><a href="#k01">1. Propojení světa LISPu se světem JavaScriptu s využitím transpřekladače Wisp</a></p>
<p><a href="#k02">2. Wisp versus ClojureScript</a></p>
<p><a href="#k03">3. Instalace Wispu</a></p>
<p><a href="#k04">4. Podporované datové typy</a></p>
<p><a href="#k05">5. Základ práce s&nbsp;kolekcemi</a></p>
<p><a href="#k06">6. Aritmetické funkce</a></p>
<p><a href="#k07">7. Funkce implementující relační operátory, test na identitu objektů</a></p>
<p><a href="#k08">8. Funkce implementující logické operátory</a></p>
<p><a href="#k09">9. Rozhodování založené na formě &bdquo;if&ldquo; a &bdquo;cond&ldquo;</a></p>
<p><a href="#k10">10. Způsob zápisu funkcí</a></p>
<p><a href="#k11">11. Obsah druhé části článku</a></p>
<p><a href="#k12">12. Repositář s&nbsp;dnešními demonstračními příklady</a></p>
<p><a href="#k13">13. Odkazy na předchozí části tohoto seriálu</a></p>
<p><a href="#k14">14. Odkazy na Internetu</a></p>



<p><a name="k01"></a></p>
<h2 id="k01">1. Propojení světa LISPu se světem JavaScriptu s využitím transpřekladače Wisp</h2>

<p>V&nbsp;článku <a
href="http://www.root.cz/clanky/programovaci-jazyk-lua-v-roli-skriptovaciho-jazyka-pro-www-stranky/">Programovací
jazyk Lua v&nbsp;roli skriptovacího jazyka pro WWW stránky</a>, v&nbsp;němž
jsme se věnovali především popisu projektů nazvaných <i>lua2js</i> a
<i>lua.vm.js</i>, jsme se mj.&nbsp;zmínili i o problematice takzvaných
transpřekladačů (<i>transcompilers, source-to-source compilers</i>). Připomeňme
si, že transpřekladače jsou nástroje sloužící pro překlad algoritmů zapsaných
v&nbsp;nějakém zdrojovém programovacím jazyce do zvoleného cílového jazyka
(ovšem nikoli do nativního kódu či bajtkódu, to je role běžných
překladačů).</p>

<p>Transpřekladače se v&nbsp;informatice používají již po několik desetiletí;
například se stále můžeme setkat s&nbsp;nástroji, které převádí kód
z&nbsp;nějakého vyššího programovacího jazyka do Céčka, které je dnes
s&nbsp;trochou nadsázky chápáno jako &bdquo;univerzální assembler&ldquo;. Asi
nejznámějším příkladem je nástroj nazvaný <strong>web2c</strong>, jenž slouží
pro transformaci zdrojových kódů <i>TeXu</i> do céčka. Transpřekladače se
stávají velmi populární i pro programátory webových aplikací, a to zejména
z&nbsp;toho důvodu, že webové prohlížeče nativně podporují většinou pouze
JavaScript, který je tak přirozeně cílovým jazykem transpřekladačů (proto se mu
také někdy říká &bdquo;assembler pro web&ldquo;).</p>

<p>Při použití JavaScriptu jakožto cílového jazyka se transpřekladač většinou
spouští jen jednou na vývojářském počítači, takže samotní klienti již mají
k&nbsp;dispozici JavaScriptový kód (který může být v&nbsp;závislosti na způsobu
překladu čitelný, optimalizovaný či navíc ještě obfuskovaný). Existuje však i
druhá možnost, kdy je transpřekladač naprogramován v&nbsp;JavaScriptu a
spouštěn přímo ve webovém prohlížeči klientů. Oba přístupy mají své přednosti,
ale pochopitelně i nějaké zápory (například tvůrci uzavřených aplikací
pravděpodobně budou upřednostňovat první možnost, protože výstupy
transcompilerů jsou většinou dosti nečitelné). Z&nbsp;praxe můžeme uvést
například následující projekty založené na transpřekladači:</p>:

<table>
<tr><th>#</th><th>Jazyk či transpřekladač</th><th>Poznámka</th></tr>
<tr><td>1</td><td>CoffeeScript</td><td>přidání syntaktického cukru do JavaScriptu</td></tr>
<tr><td>2</td><td>ClojureScript</td><td>překlad aplikací psaných v&nbsp;Clojure do JavaScriptu</td></tr>
<tr><td>3</td><td>TypeScript</td><td>nadmnožina jazyka JavaScript, přidání datových typů</td></tr>
<tr><td>4</td><td>6to5</td><td>transpřeklad z&nbsp;ECMAScript 6 (nová varianta JavaScriptu) do starší varianty JavaScriptu</td></tr>
<tr><td>5</td><td>Kaffeine</td><td>rozšíření JavaScriptu o nové vlastnosti</td></tr>
<tr><td>6</td><td>RedScript</td><td>jazyk inspirovaný Ruby</td></tr>
<tr><td>7</td><td>GorillaScript</td><td>další rozšíření JavaScriptu</td></tr>
<tr><td>8</td><td>ghcjs</td><td>transpřekladač pro fanoušky programovacího jazyka Haskell</td></tr>
<tr><td>9</td><td>Haxe</td><td>transpřekladač, mezi jehož cílové jazyka patří i Java a JavaScript</td></tr>
<tr><td>10</td><td>Wisp</td><td>transpřekladač, jehož popisem se budeme zabývat v&nbsp;dalších kapitolách</td></tr>
<tr><td>11</td><td>ScriptSharp</td><td>transpřekladač z&nbsp;C# do JavaScriptu</td></tr>
<tr><td>12</td><td>Dart</td><td>transpřekladač z&nbsp;jazyka Dart do JavaScriptu</td></tr>
<tr><td>13</td><td>COBOL &rarr; C</td><td>transpřekladač OpenCOBOL</td></tr>
<tr><td>14</td><td>COBOL &rarr; Java</td><td>transpřekladač P3COBOL</td></tr>
</table>



<p><a name="k02"></a></p>
<h2 id="k02">2. Wisp versus ClojureScript</h2>

<p>Transpřekladač <i>Wisp</i> slouží k&nbsp;překladu programů vytvořených
v&nbsp;programovacím jazyce, který je podmnožinou jazyka <i>Clojure</i> či
<i>ClojureScript</i>, do <i>JavaScriptu</i>. Vzhledem k&nbsp;tomu, že i
<i>ClojureScript</i> je překládán do JavaScriptu (viz též [<a
href="http://www.root.cz/clanky/programovaci-jazyk-clojure-21-clojurescript-aneb-preklad-clojure-do-javascriptu/">1</a>],
nabízí se logická otázka, jaký je vlastně mezi ClojureScriptem a Wispem rozdíl.
Cílem autorů ClojureScriptu je nabídnout vývojářům plnohodnotnou alternativní
implementaci programovacího jazyka Clojure, což se do značné míry daří,
samozřejmě s&nbsp;ohledem na fakt, že současné JavaScriptové enginy nenabízí
některé vlastnosti, které Clojure využívá (to například znamená omezené využití
<i>agentů</i> či <i>futures</i>). ClojureScript je (trans)překládán do
JavaScriptu relativně komplikovaným způsobem; výsledek transpřekladu je dále
optimalizován a většinou i &bdquo;minifikován&ldquo;, takže se ke klientům
dostane již značně nečitelná varianta původního algoritmu (optimalizaci a
minifikaci lze při tvorbě zakázat). Díky tomu, že ClojureScript podporuje
většinu vlastností jazyka Clojure, je možné při vývoji webových aplikací použít
prakticky stejný programovací jazyk jak na straně serveru, tak i na straně
klienta, čehož <a
href="https://github.com/clojure/clojurescript/wiki/Companies-Using-ClojureScript">některé</a>
společnosti s&nbsp;výhodou využívají.</p>

<p>Transpřekladač <i>Wisp</i> je namísto toho navržen takovým způsobem, aby
algoritmus zapsaný v&nbsp;podmnožině jazyka Clojure převedl co nejpřímějším
způsobem do JavaScriptu, ideálně tak, aby původní algoritmus byl jasně
viditelný i ve vygenerovaném kódu (podle názoru autora může být Wisp
z&nbsp;tohoto důvodu takřka ideální učební pomůckou vhodnou pro vysvětlení
principu funkcionálních jazyků). Wisp ovšem zachovává některé vlastnosti jazyka
Clojure, zejména ty vlastnosti, které jsou odvozeny od LISPu &ndash; Wisp je
stále homoikonický jazyk (což znamená, že kód je reprezentován stejným způsobem
jako data a lze s&nbsp;ním i manipulovat jako s&nbsp;daty), nalezneme zde
podporu pro TCO (<i>tail call optimization</i>) a taktéž, což je poměrně
důležité, podporu pro makra. Další vlastnosti jazyka Clojure ovšem již
podporovány nejsou &ndash; protože Wisp používá nativní datové typy
JavaScriptu, nenalezneme v&nbsp;něm například skutečné neměnné
(<i>immutable</i>) datové struktury, transakční paměť (STM) a i podpora pro
líné vyhodnocování (<i>lazy evaluation</i>) je prozatím pouze minimální.</p>



<p><a name="k03"></a></p>
<h2 id="k03">3. Instalace Wispu</h2>

<p>Na rozdíl od ClojureScriptu nepoužívá Wisp ke své činnosti ani Clojure ani
Javu (a tedy ani JVM), požaduje pouze několik JavaScriptových knihoven. Pro
instalaci transpřekladače <i>Wispu</i> je vyžadován nástroj
<strong>npm</strong> (<i>node package manager</i>). Pokud tento nástroj ještě
na svém systému nemáte, lze ho jednoduše nainstalovat například takto:</p>

<pre>
sudo apt-get install npm
</pre>

<p>popř.&nbsp;na distribucích založených na RPM následovně:</p>

<pre>
sudo yum install npm
</pre>

<p>Po instalaci zkontrolujeme, zda se nástroj <strong>npm</strong> skutečně
podařilo korektně nainstalovat a nakonfigurovat:</p>

<pre>
npm -version
1.3.10
</pre>

<p>Dále je nutné nainstalovat balíček <strong>nodejs</strong>:</p>

<pre>
sudo npm install nodejs
</pre>

<p>Následuje samotná instalace <i>Wispu</i>, která může vypadat následovně:</p>

<pre>
sudo npm install -g wisp
npm http GET https://registry.npmjs.org/wisp
npm http 304 https://registry.npmjs.org/wisp
...
...
...
npm http 200 https://registry.npmjs.org/prelude-ls/-/prelude-ls-1.1.2.tgz
/usr/local/bin/wisp -&gt; /usr/local/lib/node_modules/wisp/bin/wisp.js
wisp@0.10.0 /usr/local/lib/node_modules/wisp
├── base64-encode@1.0.1
├── commander@2.9.0 (graceful-readlink@1.0.1)
└── escodegen@1.7.1 (estraverse@1.9.3, esutils@2.0.2, esprima@1.2.5, source-map@0.2.0, optionator@0.5.0)
</pre>

<p>Nyní si můžete zkusit spustit REPL Wispu:</p>

<pre>
wisp
</pre>

<p>Pokud se vypíše chybové hlášení, že nebyl nalezen spustitelný soubor
<strong>node</strong>, je nutné vytvořit symbolický link pojmenovaný
<strong>node</strong> ukazující na <strong>nodejs</strong>:</p>

<pre>
sudo ln -s /usr/bin/nodejs /usr/bin/node
</pre>

<p>Nyní by již měl být REPL spustitelný:</p>

<pre>
wisp
</pre>

<p>Poznámka: v&nbsp;dalším textu budeme Wisp používat skutečně v&nbsp;roli
transpřekladače, tedy přibližně následovně:</p>

<pre>
cat source_file.clj | wisp &gt; target_file.js
</pre>



<p><a name="k04"></a></p>
<h2 id="k04">4. Podporované datové typy</h2>

<p>Programy vytvořené ve Wispu se skládají ze čtyř typů takzvaných forem:</p>

<ol>
<li>literály (numerické hodnoty, pravdivostní hodnoty, znaky, řetězce; vyhodnocují se samy na sebe)</li>
<li>symboly a takzvaná &bdquo;klíčová hesla&ldquo; (<i>keywords</i>)</li>
<li>složené formy (seznamy, vektory, množiny a mapy, seznamy mají navíc zvláštní postavení kvůli způsobu svého vyhodnocení)</li>
<li>speciální formy (podobají se složeným formám &ndash; seznamům, ale interně se vyhodnocují odlišným způsobem)</li>
</ol>

<p>Popišme si nejdříve jednoduché literály. Mezi ně patří především typ (a
současně i hodnota) <strong>nil</strong>, pravdivostní hodnoty
<strong>true</strong> a <strong>false</strong>, numerické hodnoty
s&nbsp;plovoucí řádovou čárkou, řetězce a znaky:</p>

<pre>
<i>; "not in list"</i>
nil
&nbsp;
<i>; pravdivostní hodnoty</i>
true
&nbsp;
false
&nbsp;
<i>; numerické hodnoty</i>
42
&nbsp;
1.2M
&nbsp;
2/3
&nbsp;
<i>; znaky</i>
\a
\@
&nbsp;
<i>; řetězce</i>
"Hello world!"
</pre>

<p>Po transpřekladu do JavaScriptu můžeme vidět, jakým způsobem se literály
přeloží. Zajímavé je, že znaky se přeloží do formy řetězcového literálu:</p>

<pre>
<i>// "not in list", vyhodnotí se jako "undefined" pomocí operátoru void</i>
void 0;
&nbsp;
<i>// pravdivostní hodnoty</i>
true;
false;
&nbsp;
<i>// numerické hodnoty</i>
42;
1.2;
0.6666666666666666;
&nbsp;
<i>// znaky</i>
'a';
'@';
&nbsp;
<i>// řetězce</i>
'Hello world!';
</pre>

<p>V&nbsp;Clojure a taktéž ve Wispu se setkáme i s&nbsp;&bdquo;keywords&ldquo;.
Překlad tohoto slova je poněkud problematický kvůli jeho dvojímu významu
(alespoň v&nbsp;programování), takže se pokusím používat sousloví
&bdquo;klíčová hesla&ldquo;, protože termín &bdquo;keywords&ldquo;
v&nbsp;<i>Clojure/Wispu</i> <strong>ne</strong>znamená, že by se jednalo o
rezervovaná klíčová slova jazyka. Klíčová hesla jsou na použití jednodušší než
symboly, protože se ve smyčce <i>REPL</i> vyhodnocují samy na sebe a nemůže jim
být přiřazena žádná hodnota. Na co se tedy vlastně v&nbsp;praxi tento typ formy
hodí? Jedním z&nbsp;důvodů zavedení tohoto typu formy do programovacího jazyka
<i>Clojure/Wisp</i> byla podpora pro datového typy (kolekce) <i>mapa</i>,
v&nbsp;nichž je možné uchovávat dvojice klíč:hodnota. A jako klíč jsou
s&nbsp;výhodou používána právě klíčová hesla, protože jejich hodnotu nelze
měnit a navíc se jejich hešovací hodnota může vypočítat pouze jedenkrát.
Překladač pozná, že uživatel používá klíčové heslo z&nbsp;toho, že je těsně
před ním napsána dvojtečka:</p>

<pre>
:keyword
</pre>

<p>Poněkud překvapivě se keywords překládají do řetězců, což je ale dostatečné,
protože v&nbsp;rámci jednoho skriptu bude použit identický objekt:</p>

<pre>
'keyword';
</pre>



<p><a name="k05"></a></p>
<h2 id="k05">5. Základ práce s&nbsp;kolekcemi</h2>

<p>V&nbsp;této kapitole si popíšeme takzvané <i>složené formy</i>, protože
právě tyto formy představují, společně s&nbsp;formami speciálními, jeden
z&nbsp;nejdůležitějších prvků jazyka <i>Wisp</i> (a podobně i původního
<i>LISPu</i>). V&nbsp;tradičním <i>LISPu</i> je složenou formou především
seznam (<i>list</i>), což je ovšem jen zjednodušeně zapsaný řetězec takzvaných
tečka-dvojic. Koncept tečka-dvojic byl ve <i>Wispu</i> opuštěn, ovšem
k&nbsp;seznamům navíc přibyly i další způsoby zápisu složených forem, které se
používají (opět v&nbsp;podstatě jako syntaktický cukr) pro zápis následujících
datových struktur: vektoru (<i>vector</i>), množiny (<i>set</i>) a mapy
(<i>map</i>). Všechny čtyři typy složených forem (budeme je dále nazývat
<i>kolekce</i>), ať již se jedná o seznam, vektor, množinu či mapu, jsou
z&nbsp;obou stran uvozeny závorkami, přičemž musí být zachována párovost
závorek (ke každé otevírací závorce přísluší jedna závorka uzavírací).</p>

<p>V&nbsp;předchozím textu bylo napsáno, že základním typem složené formy je
seznam (<i>list</i>), jehož prvky se již tradičně (více než padesát let!)
zapisují do kulatých závorek. Pro zápis vektorů (<i>vector</i>) se používají
hranaté závorky, mapy (<i>map</i>) využívají závorky složené a množiny
(<i>set</i>) taktéž závorky složené, ovšem před otevírací závorkou se musí
napsat křížek (hash, #). V&nbsp;následující tabulce jsou vypsány všechny čtyři
typy složených forem:</p>

<table>
<tr><th>Typ kolekce</th><th>Zápis (syntaktický cukr)</th></tr>
<tr><td>Seznam </td><td>(prvky)</td></tr>
<tr><td>Vektor </td><td>[prvky]</td></tr>
<tr><td>Mapa   </td><td>{dvojice klíč-hodnota}</td></tr>
<tr><td>Množina</td><td>#{unikátní prvky}</td></tr>
</table>

<p>Opět se podívejme na příklady:</p>

<pre>
<i>; Seznamy</i>
&nbsp;
<i>; prázdný seznam</i>
'()
&nbsp;
<i>; seznam čísel</i>
'(1 2 3 4)
&nbsp;
<i>; seznam řetězců</i>
'("prvni" "druhy" "treti")
&nbsp;
<i>; seznam "keywords"</i>
'(:prvni :druhy :treti)
&nbsp;
&nbsp;
<i>; Vektory</i>
&nbsp;
<i>; prázdný vektor</i>
[]
&nbsp;
<i>; vektor čísel</i>
[1 2 3 4]
&nbsp;
<i>; vektor řetězců</i>
["prvni" "druhy" "treti"]
&nbsp;
<i>; vektor "keywords"</i>
[:prvni :druhy :treti]
&nbsp;
<i>; vektor proměnných</i>
[positionX positionY positionZ]
&nbsp;
&nbsp;
<i>; Mapa</i>
&nbsp;
<i>; prázdná mapa</i>
{}
&nbsp;
<i>; mapování typu string-string</i>
{"prvni" "first" "druhy" "second" "treti" "third"}
&nbsp;
<i>; mapa s vyhodnocením proměnných</i>
{"X" positionX "y" positionY "z" positionZ}
&nbsp;
&nbsp;
<i>; Množina</i>
#{"prvni" "druhy" "treti"}
</pre>

<p>Překlad do JavaScriptu je u některých kolekcí možná poněkud překvapivý a
vede k&nbsp;tomuto závěru: pro reprezentaci dat používejte především vektory a
mapy (pro další dvě kolekce je zapotřebí připravit příslušné konstruktory):</p>

<pre>
<i>// seznamy</i>
list();
list(1, 2, 3, 4);
list('prvni', 'druhy', 'treti');
list('\uA789prvni', '\uA789druhy', '\uA789treti');
&nbsp;
<i>// vektory</i>
[];
[
    1,
    2,
    3,
    4
];
[
    'prvni',
    'druhy',
    'treti'
];
[
    'prvni',
    'druhy',
    'treti'
];
[
    positionX,
    positionY,
    positionZ
];
&nbsp;
<i>// mapy</i>
({});
({
    'prvni': 'first',
    'druhy': 'second',
    'treti': 'third'
});
({
    'X': positionX,
    'y': positionY,
    'z': positionZ
});
&nbsp;
<i>// množiny</i>
set('prvni', 'druhy', 'treti');
</pre>



<p><a name="k06"></a></p>
<h2 id="k06">6. Aritmetické funkce</h2>

<p>Seznamy, tj.&nbsp;jeden ze čtyř podporovaných typů kolekcí, mají
v&nbsp;programovacím jazyku <i>Wisp</i> ještě jeden dosti zásadní význam.
Samotný program zapsaný ve <i>Wispu</i> není totiž nic jiného než seznam (či
seznamy), přičemž prvním prvkem seznamu je jméno funkce a zbylé prvky seznamu
jsou chápány jako parametry této funkce.</p>

<p>Vzhledem k&nbsp;tomu, že vyhodnocování seznamů &ndash; volání funkcí &ndash;
představuje důležitou součást programovacího jazyka <i>Wisp</i>, ukážeme si
způsob tohoto vyhodnocování na několika demonstračních příkladech, kde je
představen prefixový zápis aritmetických operátorů. Povšimněte si především
proměnné arity:</p>

<pre>
<i>; operace rozdílu - druhý argument funkce je odečten od prvního</i>
(- 1 2)
&nbsp;
<i>; součet řady čísel</i>
(+ 1 2 3 4 5 6 7 8 9 10)
&nbsp;
<i>; níže uvedený výraz v infixové notaci odpovídá: 1-2-3-4-5....-10:</i>
(- 1 2 3 4 5 6 7 8 9 10)
&nbsp;
<i>; POZOR - závorky v LISPu nemají mnoho společného</i>
<i>; s vyjádřením priority aritmetických operací</i>
<i>; (nelze je použít tak volně jako například v céčku)</i>
(* (+ 1 2) (+ 3 4))
&nbsp;
(+ (* 1 2) (* 3 4))
&nbsp;
<i>; Clojure umí, podobně jako některé implementace LISPu,</i>
<i>; pracovat se zlomky, tj. snaží se racionální</i>
<i>; čísla vyjádřit formou zlomku (ideální jazyk do škol)</i>
<i>; POZOR:</i>
<i>; To však není případ Wispu, ten používá nativní formát</i>
<i>; numerických hodnot JavaScriptu.</i>
(/ 1 2)
&nbsp;
(/ 1 2 3)
&nbsp;
<i>; zkusíme výpočet složitějšího zlomku</i>
(/ (+ 1 2) (+ 3 4))
&nbsp;
<i>; dělení modulo</i>
(mod 10 3)
&nbsp;
<i>; neracionální (reálná) čísla se vypisují tak, jak to</i>
<i>; známe z ostatních programovacích jazyků (samozřejmě</i>
<i>; v případě speciálních požadavků programátora lze použít</i>
<i>; různé formátovací funkce na úpravu výstupu)</i>
(* 0.3 (/ (+ 1 2) (+ 3 4)))
</pre>

<p>Výsledek transpřekladu do JavaScriptu:</p>

<pre>
1 - 2;
1 + 2 + 3 + 4 + 5 + 6 + 7 + 8 + 9 + 10;
1 - 2 - 3 - 4 - 5 - 6 - 7 - 8 - 9 - 10;
(1 + 2) * (3 + 4);
1 * 2 + 3 * 4;
1 / 2;
1 / 2 / 3;
(1 + 2) / (3 + 4);
10 % 3;
0.3 * ((1 + 2) / (3 + 4));
</pre>

<p>Samotný překladač <i>Wispu</i> nedělá rozdíl mezi hodnotou a proměnnou,
takže i následující zápis je korektní:</p>

<pre>
<i>; namísto numerických hodnot lze použít i proměnné</i>
(+ variableA variableB variableC variableD)
(* (+ variableA variableB) (+ variableC variableD))
(+ (* variableA variableB) (* variableC variableD))
(/ (+ variableA variableB) (+ variableC variableD))
(mod sum items)
</pre>

<p>Tyto čtyři formy se transpřeloží takto:</p>

<pre>
variableA + variableB + variableC + variableD;
(variableA + variableB) * (variableC + variableD);
variableA * variableB + variableC * variableD;
(variableA + variableB) / (variableC + variableD);
sum % items;
</pre>

<p>Povšimněte si především toho, že samotný transpřeklad není
&bdquo;otrocký&ldquo;, ale správně bere v&nbsp;potaz prioritu operátorů
v&nbsp;JavaScriptu.</p>



<p><a name="k07"></a></p>
<h2 id="k07">7. Funkce implementující relační operátory, test na identitu objektů</h2>

<p>Programovací jazyk <i>Wisp</i> obsahuje i úplnou sadu relačních operátorů,
které v&nbsp;závislosti na hodnotách předaných parametrů (operandů) vrací
hodnotu <strong>true</strong> (pravda) či <strong>false</strong> (nepravda).
Zde se <i>Wisp</i> spíše podobá <i>Scheme</i> než klasickému <i>LISPu</i>
(s&nbsp;jeho <strong>T</strong> a <strong>nil</strong>), což je ostatně jen
dobře. Za zmínku stojí i funkce pojmenovaná <strong>identical?</strong>, která
se přeloží na JavaScriptový operátor ===, tj.&nbsp;na test, zda dva objekty
jsou skutečně totožné, tj.&nbsp;zda leží na stejném místě v&nbsp;operační
paměti:</p>

<pre>
<i>; porovnání dvou číselných hodnot</i>
<i>; relace "menší než"</i>
(&lt; 1 2)
&nbsp;
<i>; relace "větší než"</i>
(&gt; 1 2)
&nbsp;
<i>; relace "menší nebo rovno"</i>
(&lt;= 1 2)
&nbsp;
<i>; relace "větší nebo rovno"</i>
(&gt;= 1 2)
&nbsp;
<i>; porovnání dvou výrazů na ekvivalenci</i>
(== 1 2)
(== 1 1)
&nbsp;
<i>; pozor na rozdíl mezi = a ==</i>
(= 1 2)
(= 1 1)
&nbsp;
<i>; navíc lze použít i speciální formu identical?</i>
<i>; ta se přeloží na operátor ===</i>
(identical? 1 2)
(identical? [1 2] [3 4])
&nbsp;
<i>; podvýrazy se nejprve vyhodnotí a posléze se porovnají</i>
<i>; vyhodnocené výsledky (v tomto případě dva atomy)</i>
(== (+ 1 1) (/ 4 2))
</pre>

<p>Výsledek transpřekladu do JavaScriptu (zajímavé je porovnání vektorů ==
polí):</p>

<pre>
1 &lt; 2;
1 &gt; 2;
1 &lt;= 2;
1 &gt;= 2;
1 == 2;
1 == 1;
isEqual(1, 2);
isEqual(1, 1);
1 === 2;
[
    1,
    2
] === [
    3,
    4
];
1 + 1 == 4 / 2;
</pre>

<p>Opět platí, že lze použít i proměnné:</p>

<pre>
<i>; namísto numerických hodnot lze použít i proměnné</i>
(&lt; variableA variableB)
(&gt; variableA variableB)
(&lt;= variableA variableB)
(&gt;= variableA variableB)
(== variableA variableB)
(== variableA variableA)
(== (+ variableA variableA) (/ variableC variableD))
(identical? variableA variableB)
</pre>

<p>Výsledek transpřekladu do JavaScriptu:</p>

<pre>
variableA &lt; variableB;
variableA &gt; variableB;
variableA &lt;= variableB;
variableA &gt;= variableB;
variableA == variableB;
variableA == variableA;
variableA + variableA == variableC / variableD;
variableA === variableB;
</pre>



<p><a name="k08"></a></p>
<h2 id="k08">8. Funkce implementující logické operátory</h2>

<p>V&nbsp;JavaScriptu se používají operátory &amp;&amp; a ||. I pro tyto
operátory samozřejmě existuje ve Wispu jejich ekvivalent, ovšem zajímavé je, že
někdy se &amp;&amp; a || generují implicitně, což je příklad těchto zápisů:</p>

<pre>
<i>; porovnání tří hodnot</i>
<i>; relace "menší než"</i>
(&lt; a b c)
&nbsp;
<i>; relace "větší než"</i>
(&gt; a b c)
&nbsp;
<i>; porovnání čtyř hodnot na ekvivalenci</i>
(== 1 2 3 4)
&nbsp;
<i>; pozor! identical? je forma akceptující jen dva parametry!</i>
<i>;(identical? 1 2 3 4)</i>
</pre>

<p>Výsledek transpřekladu do JavaScriptu:</p>

<pre>
a &lt; b &amp;&amp; b &lt; c;
a &gt; b &amp;&amp; b &gt; c;
1 == 2 &amp;&amp; 2 == 3 &amp;&amp; 3 == 4;
</pre>

<p>V&nbsp;případě potřeby se použijí formy <strong>and</strong> a
<strong>or</strong>:</p>

<pre>
<i>; operace and a or</i>
(and true false)
(or true false)
(and a b c d)
(or a b c d)
&nbsp;
<i>; někdy je "if" zbytečné použít</i>
(or podminka "nesplneno")
(and podminka "splneno")
&nbsp;
<i>; různé kombinace</i>
(and (== a b) (== c d))
(and (or a b) (or c d))
&nbsp;
<i>; ještě se neztrácíte?</i>
(and (&gt; (+ a b) 0) (&gt; (+ c d) y))
</pre>

<p>Výsledek transpřekladu do JavaScriptu:</p>

<pre>
true &amp;&amp; false;
true || false;
a &amp;&amp; b &amp;&amp; c &amp;&amp; d;
a || b || c || d;
podminka || 'nesplneno';
podminka &amp;&amp; 'splneno';
&nbsp;
<i>// povšimněte si &bdquo;inteligentního&ldquo; uzávorkování</i>
a == b &amp;&amp; c == d;
(a || b) &amp;&amp; (c || d);
a + b &gt; 0 &amp;&amp; c + d &gt; y;
</pre>



<p><a name="k09"></a></p>
<h2 id="k09">9. Rozhodování založené na formě &bdquo;if&ldquo; a &bdquo;cond&ldquo;</h2>

<p>Další důležitou vlastností programovacího jazyka <i>Wisp</i>, s&nbsp;níž se
v&nbsp;dnešním článku alespoň ve stručnosti seznámíme, je použití takzvaných
<i>speciálních forem</i>. Ze syntaktického hlediska jsou speciální formy
zapisovány naprosto stejným způsobem jako běžné funkce
(tj.&nbsp;v&nbsp;kulatých závorkách je nejprve zapsáno jméno funkce a posléze
její parametry), ovšem existuje zde jeden významný rozdíl &ndash; zatímco u
funkcí jsou všechny jejich parametry nejdříve rekurzivně vyhodnoceny a teprve
posléze je funkce zavolána, u speciálních forem k&nbsp;tomuto vyhodnocení
obecně nedochází, resp.&nbsp;jsou vyhodnoceny pouze některé parametry (které
konkrétně, to závisí na tom, o jakou speciální formu se jedná). K&nbsp;čemu
jsou speciální formy dobré? Typickým a pro praxi naprosto nezbytným příkladem
je zápis podmíněných bloků kódu. V&nbsp;tomto případě potřebujeme, aby se
nějaká část programu vykonala pouze v&nbsp;případě, že je splněna
(popř.&nbsp;nesplněna) nějaká podmínka, v&nbsp;opačném případě nemá být tato
část programu vůbec vykonána.</p>

<p>Pomocí běžných funkcí by nebylo možné tuto funkcionalitu splnit, protože by
se kód (předaný jako parametr &ndash; jinou možnost v&nbsp;<i>Wisp</i> ostatně
prakticky nemáme) vykonal ještě před zavoláním &bdquo;podmínkové&ldquo; funkce.
Z&nbsp;toho vyplývá, že samotná podmínka, i když se syntakticky podobá volání
funkce, je <i>speciální formou</i>. V&nbsp;jazyku <i>Wisp</i> existuje pro
zápis podmíněného příkazu mj.&nbsp;i speciální forma <strong>if</strong>, která
očekává tři parametry:</p>

<ol>
<li>podmínku (výraz=formu, která se vyhodnotí na <strong>true</strong> či <strong>false</strong></li>
<li>formu vyhodnocenou v&nbsp;případě, že je podmínka splněna</li>
<li>formu vyhodnocenou v&nbsp;případě, že podmínka není splněna</li>
</ol>

<p>Příklady použití speciální formy <strong>if</strong>:</p>

<pre>
<i>; na základě podmínky se vyhodnotí (a vrátí jako výsledek)</i>
<i>; buď řetězec "mensi" nebo "vetsi"</i>
(if (&lt; variableA variableB) "mensi" "vetsi")
&nbsp;
<i>; větev "else" lze vynechat, vrací se nil resp. jeho ekvivalent</i>
(if (&lt; variableA variableB) "mensi")
&nbsp;
<i>; samotná speciální forma if může být volána uvnitř složitějšího výrazu</i>
(* 84 (if (== a b) (+ c d) (/ e f)))
&nbsp;
<i>; vnořené formy if</i>
(if (&lt; n 0) "negative"
    (if (&gt; n 0) "positive"
                "zero"))
</pre>

<p>Výsledek transpřekladu do JavaScriptu je možná překvapivý, protože se u
takto jednoduchých forem nepoužije <strong>if-then-else</strong> ale
funkcionálněji pojatý ternární operátor &bdquo;?:&ldquo;:</p>

<pre>
variableA &lt; variableB ? 'mensi' : 'vetsi';
variableA &lt; variableB ? 'mensi' : void 0;
&nbsp;
<i>// ternární operátor uvnitř složitějšího výrazu</i>
84 * (a == b ? c + d : e / f);
&nbsp;
<i>// ternární operátor uvnitř jiného ternárního operátoru</i>
n &lt; 0 ? 'negative' : n &gt; 0 ? 'positive' : 'zero';
</pre>

<p>Při popisu speciální formy <strong>if</strong> nesmíme zapomenout ani na
makro <strong>cond</strong>, které je nedílnou součástí mnoha programovacích
jazyků odvozených od LISPu. Důvod pro tuto oblibu <strong>cond</strong> (ať již
se jedná v&nbsp;konkrétní implementaci jazyka o makro či naopak o speciální
formu) je prostý: v&nbsp;původním návrhu programovacího jazyka <i>LISP</i> byl
tento jazyk kromě smyčky <i>REPL</i> doplněn o sedm základních funkcí a dvě
speciální formy: <strong>atom</strong>, <strong>car</strong>,
<strong>cdr</strong>, <strong>cond</strong>, <strong>cons</strong>,
<strong>eq</strong>, <strong>quote</strong>, <strong>lambda</strong> a
<strong>label</strong>.</p>

<p>Vraťme se však k&nbsp;makru <strong>cond</strong> použitém i
v&nbsp;programovacím jazyku <i>Wisp</i>. Toto makro akceptuje libovolný počet
dvojic test-příkaz. Jednotlivé testy (jde samozřejmě o výrazy &ndash; formy) se
postupně vyhodnocují a v&nbsp;případě, že se vyhodnotí na hodnotu
<strong>true</strong>, vrátí makro <strong>cond</strong> hodnotu vyhodnoceného
příkazu. V&nbsp;opačném případě se vyhodnotí další test atd. Pokud se ani jeden
test nevyhodnotí na logickou hodnotu <strong>true</strong>, vrátí toto makro
hodnotu <strong>nil</strong>:</p>

<pre>
<i>; speciální forma cond</i>
(cond
    (&lt; n 0) "negative"
    (&gt; n 0) "positive"
    :else "zero")
</pre>

<p>Výsledek transpřekladu do JavaScriptu:</p>

<pre>
n &lt; 0 ? 'negative' : n &gt; 0 ? 'positive' : 'else' ? 'zero' : void 0;
</pre>

<p>Závěrečný výraz <strong>void 0</strong> odpovídá <strong>nil</strong>,
řetězec &bdquo;else&ldquo; se samozřejmě vyhodnotí na
<strong>true</strong>.</p>



<p><a name="k10"></a></p>
<h2 id="k10">10. Způsob zápisu funkcí</h2>

<p><i>Wisp</i> je funkcionálním jazykem a proto pro funkce, které jsou
v&nbsp;něm vytvořeny, platí následující vlastnosti:</p>

<ol>

<li>Funkce mohou být vytvořeny kdykoli v&nbsp;čase běhu programu
(<i>runtime</i>). To, jak je funkce v&nbsp;<i>runtime</i> přeložena, je již
interní záležitostí daného programovacího jazyka.</li>

<li>Funkce mohou být uloženy do proměnné (resp.&nbsp;přesněji řečeno navázány
na jméno proměnné) či mohou být uloženy do jakékoli datové struktury (seznam
funkcí, vektor funkcí atd.)</li>

<li>Funkce mohou být předány jako parametr do jiné funkce.</li>

<li>Funkce může být vrácena ve formě návratové hodnoty jiné funkce.</li>

<li>Jméno sice není součástí funkce, ovšem funkce může být na jméno (symbol)
navázána. Toto je pravděpodobně jedna z&nbsp;nejvíce matoucích vlastností
funkcionálních jazyků, protože z&nbsp;jazyků procedurálních jsme zvyklí na to,
že funkce vždy <strong>má</strong> jméno, které je v&nbsp;naprosté většině
případů známé již v&nbsp;době překladu. U jazyků funkcionálních
(popř.&nbsp;jazyků hybridních) se však velmi často používají funkce beze jména,
neboli <i>funkce anonymní</i>.</li>

</ol>

<p>Nyjí již známe alespoň základní vlastnosti funkcí ve Wispu, jak se však
funkce v&nbsp;tomto programovacím jazyku skutečně definují? Pro vytvoření nové
bezejmenné (tj.&nbsp;anonymní) funkce se používá speciální forma nazvaná
<strong>fn</strong>, které se v&nbsp;tom nejjednodušším případě předá vektor
obsahující jména parametrů, za nímž je uveden seznam, jenž představuje tělo
funkce (znalci LISPu patrně znají formu <strong>lambda</strong>, která má
podobný význam). Samozřejmě, že v&nbsp;těle funkce je možné použít symbolická
jména jejích parametrů a návratovou hodnotou funkce je hodnota získaná
vyhodnocením těla funkce:</p>

<pre>
<i>; anonymní funkce</i>
(fn [x y] (+ x y))
</pre>

<p>Výsledek transpřekladu do JavaScriptu pravděpodobně není příliš překvapující
(zajímavější již je, že JavaScript se skutečně může chovat jako částečně
funkcionální jazyk):</p>

<pre>
(function (x, y) {
    return x + y;
});
</pre>

<p>Pro vytvoření pojmenované funkce, tj.&nbsp;funkce navázané na nějaký symbol
(jméno), se používá makro <strong>defn</strong>. Při použití makra
<strong>defn</strong> se v&nbsp;tom nejjednodušším případě předávají tři
parametry: název nově vytvářené funkce, vektor obsahující jména parametrů
funkce a konečně seznam představující tělo této funkce:</p>

<pre>
<i>; funkce navázaná na symbol == pojmenovaná funkce</i>
(defn add
    [x y]
    (+ x y))
</pre>

<p>Při překladu do JavaScriptu se funkce naváže hned na dvě proměnné:</p>

<pre>
var add = exports.add = function add(x, y) {
    return x + y;
};
</pre>

<p>Ve funkcích je možné používat i lokální proměnné a přidávat k&nbsp;funkcím
metadata a dokumentační řetězce:</p>

<pre>
<i>; lokální symboly (proměnné)</i>
(defn add-abs
    [x y]
    (let [abs-x (if (&lt; x 0) (- x) x)
          abs-y (if (&lt; y 0) (- y) y)]
        (+ abs-x abs-y)))
&nbsp;
<i>; dokumentační řetězec a metadata</i>
<i>; (vlastnost převzaná z Clojure)</i>
(defn inc
    "Returns a number one greater than num."
    {:version "1.0"}
    [num]
    (+ num 1))
</pre>

<p>Výsledek transpřekladu do JavaScriptu. V&nbsp;prvním případě se vytvoří a
ihned zavolá interní anonymní funkce. Toto chování je pravděpodobně způsobeno
snahou o podporu uzávěrů:</p>

<pre>
&nbsp;
var addAbs = exports.addAbs = function addAbs(x, y) {
    return function () {
        var absXø¸1 = x &lt; 0 ? 0 - x : x;
        var absYø¸1 = y &lt; 0 ? 0 - y : y;
        return absøĂ¸1 + absøĂ¸1;
    }.call(this);
};
&nbsp;
var inc = exports.inc = function inc(num) {
    return num + 1;
};
</pre>

<p>V&nbsp;programovacím jazyku Wisp lze vytvářet i funkce s&nbsp;proměnným
počtem parametrů (ukážeme si příště) a s&nbsp;proměnnou aritou. Jen pro
zajímavost se nyní podívejme na způsob, jakým se vytvoří funkce
<strong>add</strong>, kterou lze volat bez parametrů, s&nbsp;jedním parametrem,
se dvěma parametry popř.&nbsp;alternativně se třemi parametry. Tělo této funkce
je pokaždé odlišné:</p>

<pre>
<i>; přetěžování funkcí</i>
(defn add
    ([]
     0)
    ([x]
     x)
    ([x y]
     (+ x y))
    ([x y z]
     (+ x y z)))
</pre>

<p>Výsledek transpřekladu do JavaScriptu je založen na použití pole
<strong>arguments</strong> vytvořeného v&nbsp;runtime po zavolání funkce:</p>

<pre>
var add = exports.add = function add() {
    switch (arguments.length) {
    case 0:
        return 0;
    case 1:
        var x = arguments[0];
        return x;
    case 2:
        var x = arguments[0];
        var y = arguments[1];
        return x + y;
    case 3:
        var x = arguments[0];
        var y = arguments[1];
        var z = arguments[2];
        return x + y + z;
    default:
        throw RangeError('Wrong number of arguments passed');
    }
};
</pre>

<p>Na tomto příkladu jsou dobře patrné rozdíly mezi <i>Wispem</i> a
<i>JavaScriptem</i>, minimálně v&nbsp;oblasti stručnosti zápisu a
sémantiky.</p>



<p><a name="k11"></a></p>
<h2 id="k11">11. Obsah druhé části článku</h2>

<p>Ve druhé části tohoto článku dokončíme popis vlastností programovacího
jazyka <i>Wisp</i>. Seznámíme se především se způsobem zápisu programových
smyček s&nbsp;využitím <strong>loop</strong> a <strong>recur</strong> i
s&nbsp;tím, jak je zajištěno, že se tento zápis při transpřekladu skutečně
převede na programovou smyčku a nikoli na rekurzi. Posléze si ukážeme způsob
vyhození popř.&nbsp;naopak zachycení výjimek s&nbsp;využitím speciálních forem
<strong>try</strong>, <strong>catch</strong>, <strong>finally</strong> a
<strong>raise</strong>. Taktéž se seznámíme se syntaxí zápisu volání metod a na
závěr si ukážeme deklaraci a použití maker, protože právě makra mohou být
jedním z&nbsp;důvodů, proč programovací jazyk <i>Wisp</i> použít v&nbsp;praxi
namísto původního JavaScriptu nebo některých jeho &bdquo;jednodušších&ldquo;
nadstaveb typu <i>Dart</i> (které nejsou homoikonické).</p>



<p><a name="k12"></a></p>
<h2 id="k12">12. Repositář s&nbsp;dnešními demonstračními příklady</h2>

<p>Demonstrační příklady, na nichž jsme si ukazovali vlastnosti transpřekladače
Wisp, byly uloženy do Git repositáře dostupného na adrese <a
href="https://github.com/tisnik/clojure-examples">https://github.com/tisnik/clojure-examples</a>.
V&nbsp;tabulce zobrazené pod tímto odstavcem naleznete na zdrojové kódy těchto
příkladů přímé odkazy:</p>

<table>
<tr><th>#</th><th>Příklad/skriptu</th><th>Github</th></tr>
<tr><td>1</td><td>1_data_types.clj</td><td><a href="https://github.com/tisnik/clojure-examples/blob/master/wisp/1_data_types.clj">https://github.com/tisnik/clojure-examples/blob/master/wisp/1_data_types.clj</a></td></tr>
<tr><td>2</td><td>2_collections.clj</td><td><a href="https://github.com/tisnik/clojure-examples/blob/master/wisp/2_collections.clj">https://github.com/tisnik/clojure-examples/blob/master/wisp/2_collections.clj</a></td></tr>
<tr><td>3</td><td>3_arithmetic_functions.clj</td><td><a href="https://github.com/tisnik/clojure-examples/blob/master/wisp/3_arithmetic_functions.clj">https://github.com/tisnik/clojure-examples/blob/master/wisp/3_arithmetic_functions.clj</a></td></tr>
<tr><td>4</td><td>4_relop.clj</td><td><a href="https://github.com/tisnik/clojure-examples/blob/master/wisp/4_relop.clj">https://github.com/tisnik/clojure-examples/blob/master/wisp/4_relop.clj</a></td></tr>
<tr><td>5</td><td>5_boolean_op.clj</td><td><a href="https://github.com/tisnik/clojure-examples/blob/master/wisp/5_boolean_op.clj">https://github.com/tisnik/clojure-examples/blob/master/wisp/5_boolean_op.clj</a></td></tr>
<tr><td>6</td><td>6_conditions.clj</td><td><a href="https://github.com/tisnik/clojure-examples/blob/master/wisp/6_conditions.clj">https://github.com/tisnik/clojure-examples/blob/master/wisp/6_conditions.clj</a></td></tr>
<tr><td>7</td><td>7_functions.clj</td><td><a href="https://github.com/tisnik/clojure-examples/blob/master/wisp/7_functions.clj">https://github.com/tisnik/clojure-examples/blob/master/wisp/7_functions.clj</a></td></tr>
<tr><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td></tr>
<tr><td>9</td><td>Makefile</td><td><a href="https://github.com/tisnik/clojure-examples/blob/master/wisp/Makefile">https://github.com/tisnik/clojure-examples/blob/master/wisp/Makefile</a></td></tr>
</table>

<p>Poznámka 1: zdrojové kódy s&nbsp;demonstračními příklady mají koncovku
<strong>.clj</strong>, takže dojde ke správnému &bdquo;obarvení&ldquo; při
otevření těchto souborů v&nbsp;programátorských editorech. Transpřekladači
<i>Wisp</i> na koncovce nezáleží, i když se v&nbsp;dokumentaci doporučuje
použít koncovku <strong>.wisp</strong>.</p>

<p>Poznámka 2: soubor <strong>Makefile</strong> je možné použít pro překlad
všech zdrojových souborů do JavaScriptu s&nbsp;využitím příkazu
<strong>make</strong>. Při změně obsahu se provede překlad jen změněných
souborů. Pokud potřebujete smazat soubory generované překladačem, lze použít
příkaz <strong>make clean</strong>.</p>



<p><a name="k13"></a></p>
<h2 id="k13">13. Odkazy na předchozí části tohoto seriálu</h2>

<ol>

<li>Leiningen: nástroj pro správu projektů napsaných v Clojure<br />
<a href="http://www.root.cz/clanky/leiningen-nastroj-pro-spravu-projektu-napsanych-v-clojure/">http://www.root.cz/clanky/leiningen-nastroj-pro-spravu-projektu-napsanych-v-clojure/</a>
</li>

<li>Leiningen: nástroj pro správu projektů napsaných v Clojure (2)<br />
<a href="http://www.root.cz/clanky/leiningen-nastroj-pro-spravu-projektu-napsanych-v-clojure-2/">http://www.root.cz/clanky/leiningen-nastroj-pro-spravu-projektu-napsanych-v-clojure-2/</a>
</li>

<li>Leiningen: nástroj pro správu projektů napsaných v Clojure (3)<br />
<a href="http://www.root.cz/clanky/leiningen-nastroj-pro-spravu-projektu-napsanych-v-clojure-3/">http://www.root.cz/clanky/leiningen-nastroj-pro-spravu-projektu-napsanych-v-clojure-3/</a>
</li>

<li>Leiningen: nástroj pro správu projektů napsaných v Clojure (4)<br />
<a href="http://www.root.cz/clanky/leiningen-nastroj-pro-spravu-projektu-napsanych-v-clojure-4/">http://www.root.cz/clanky/leiningen-nastroj-pro-spravu-projektu-napsanych-v-clojure-4/</a>
</li>

<li>Leiningen: nástroj pro správu projektů napsaných v Clojure (5)<br />
<a href="http://www.root.cz/clanky/leiningen-nastroj-pro-spravu-projektu-napsanych-v-clojure-5/">http://www.root.cz/clanky/leiningen-nastroj-pro-spravu-projektu-napsanych-v-clojure-5/</a>
</li>

<li>Leiningen: nástroj pro správu projektů napsaných v Clojure (6)<br />
<a href="http://www.root.cz/clanky/leiningen-nastroj-pro-spravu-projektu-napsanych-v-clojure-6/">http://www.root.cz/clanky/leiningen-nastroj-pro-spravu-projektu-napsanych-v-clojure-6/</a>
</li>

<li>Programovací jazyk Clojure a databáze (1.část)<br />
<a href="http://www.root.cz/clanky/programovaci-jazyk-clojure-a-databaze-1-cast/">http://www.root.cz/clanky/programovaci-jazyk-clojure-a-databaze-1-cast/</a>
</li>

<li>Pluginy pro Leiningen<br />
<a href="http://www.root.cz/clanky/leiningen-nastroj-pro-spravu-projektu-napsanych-v-clojure-pluginy-pro-leiningen/">http://www.root.cz/clanky/leiningen-nastroj-pro-spravu-projektu-napsanych-v-clojure-pluginy-pro-leiningen/</a>
</li>

<li>Programovací jazyk Clojure a knihovny pro práci s vektory a maticemi<br />
<a href="http://www.root.cz/clanky/programovaci-jazyk-clojure-a-knihovny-pro-praci-s-vektory-a-maticemi/">http://www.root.cz/clanky/programovaci-jazyk-clojure-a-knihovny-pro-praci-s-vektory-a-maticemi/</a>
</li>

<li>Programovací jazyk Clojure a knihovny pro práci s vektory a maticemi (2)<br />
<a href="http://www.root.cz/clanky/programovaci-jazyk-clojure-a-knihovny-pro-praci-s-vektory-a-maticemi-2/">http://www.root.cz/clanky/programovaci-jazyk-clojure-a-knihovny-pro-praci-s-vektory-a-maticemi-2/</a>
</li>

<li>Programovací jazyk Clojure: syntéza procedurálních textur s využitím knihovny Clisk<br />
<a href="http://www.root.cz/clanky/programovaci-jazyk-clojure-synteza-proceduralnich-textur-s-vyuzitim-knihovny-clisk/">http://www.root.cz/clanky/programovaci-jazyk-clojure-synteza-proceduralnich-textur-s-vyuzitim-knihovny-clisk/</a>
</li>

<li>Programovací jazyk Clojure: syntéza procedurálních textur s využitím knihovny Clisk (2)<br />
<a href="http://www.root.cz/clanky/programovaci-jazyk-clojure-synteza-proceduralnich-textur-s-vyuzitim-knihovny-clisk-2/">http://www.root.cz/clanky/programovaci-jazyk-clojure-synteza-proceduralnich-textur-s-vyuzitim-knihovny-clisk-2/</a>
</li>

<li>Programovací jazyk Clojure: syntéza procedurálních textur s využitím knihovny Clisk (dokončení)<br />
<a href="http://www.root.cz/clanky/programovaci-jazyk-clojure-synteza-proceduralnich-textur-s-vyuzitim-knihovny-clisk-dokonceni/">http://www.root.cz/clanky/programovaci-jazyk-clojure-synteza-proceduralnich-textur-s-vyuzitim-knihovny-clisk-dokonceni/</a>
</li>

<li>Seesaw: knihovna pro snadnou tvorbu GUI v jazyce Clojure<br />
<a href="http://www.root.cz/clanky/seesaw-knihovna-pro-snadnou-tvorbu-gui-v-jazyce-clojure/">http://www.root.cz/clanky/seesaw-knihovna-pro-snadnou-tvorbu-gui-v-jazyce-clojure/</a>
</li>

<li>Seesaw: knihovna pro snadnou tvorbu GUI v jazyce Clojure (2)<br />
<a href="http://www.root.cz/clanky/seesaw-knihovna-pro-snadnou-tvorbu-gui-v-jazyce-clojure-2/">http://www.root.cz/clanky/seesaw-knihovna-pro-snadnou-tvorbu-gui-v-jazyce-clojure-2/</a>
</li>

<li>Seesaw: knihovna pro snadnou tvorbu GUI v jazyce Clojure (3)<br />
<a href="http://www.root.cz/clanky/seesaw-knihovna-pro-snadnou-tvorbu-gui-v-jazyce-clojure-3/">http://www.root.cz/clanky/seesaw-knihovna-pro-snadnou-tvorbu-gui-v-jazyce-clojure-3/</a>
</li>

<li>Programovací jazyk Clojure a práce s Gitem<br />
<a href="http://www.root.cz/clanky/programovaci-jazyk-clojure-a-prace-s-gitem/">http://www.root.cz/clanky/programovaci-jazyk-clojure-a-prace-s-gitem/</a>
</li>

<li>Programovací jazyk Clojure a práce s Gitem (2)<br />
<a href="http://www.root.cz/clanky/programovaci-jazyk-clojure-a-prace-s-gitem-2/">http://www.root.cz/clanky/programovaci-jazyk-clojure-a-prace-s-gitem-2/</a>
</li>

<li>Programovací jazyk Clojure – triky při práci s řetězci<br />
<a href="http://www.root.cz/clanky/programovaci-jazyk-clojure-triky-pri-praci-s-retezci/">http://www.root.cz/clanky/programovaci-jazyk-clojure-triky-pri-praci-s-retezci/</a>
</li>

<li>Programovací jazyk Clojure – triky při práci s kolekcemi<br />
<a href="http://www.root.cz/clanky/programovaci-jazyk-clojure-triky-pri-praci-s-kolekcemi/">http://www.root.cz/clanky/programovaci-jazyk-clojure-triky-pri-praci-s-kolekcemi/</a>
</li>

<li>Programovací jazyk Clojure – práce s mapami a množinami<br />
<a href="http://www.root.cz/clanky/programovaci-jazyk-clojure-prace-s-mapami-a-mnozinami/">http://www.root.cz/clanky/programovaci-jazyk-clojure-prace-s-mapami-a-mnozinami/</a>
</li>

<li>Programovací jazyk Clojure – základy zpracování XML<br />
<a href="http://www.root.cz/clanky/programovaci-jazyk-clojure-zaklady-zpracovani-xml/">http://www.root.cz/clanky/programovaci-jazyk-clojure-zaklady-zpracovani-xml/</a>
</li>

<li>Programovací jazyk Clojure – testování s využitím knihovny Expectations<br />
<a href="http://www.root.cz/clanky/programovaci-jazyk-clojure-testovani-s-vyuzitim-knihovny-expectations/">http://www.root.cz/clanky/programovaci-jazyk-clojure-testovani-s-vyuzitim-knihovny-expectations/</a>
</li>

<li>Programovací jazyk Clojure – některé užitečné triky použitelné (nejenom) v&nbsp;testech<br />
<a href="http://www.root.cz/clanky/programovaci-jazyk-clojure-nektere-uzitecne-triky-pouzitelne-nejenom-v-testech/">http://www.root.cz/clanky/programovaci-jazyk-clojure-nektere-uzitecne-triky-pouzitelne-nejenom-v-testech/</a>
</li>

<li>Enlive – výkonný šablonovací systém pro jazyk Clojure<br/>
<a href="http://www.root.cz/clanky/enlive-vykonny-sablonovaci-system-pro-jazyk-clojure/">http://www.root.cz/clanky/enlive-vykonny-sablonovaci-system-pro-jazyk-clojure/</a>
</li>

<li>Nástroj Leiningen a programovací jazyk Clojure: tvorba vlastních knihoven pro veřejný repositář Clojars<br />
<a href="http://www.root.cz/clanky/nastroj-leiningen-a-programovaci-jazyk-clojure-tvorba-vlastnich-knihoven-pro-verejny-repositar-clojars/">http://www.root.cz/clanky/nastroj-leiningen-a-programovaci-jazyk-clojure-tvorba-vlastnich-knihoven-pro-verejny-repositar-clojars/</a>
</li>

</ol>



<p><a name="k14"></a></p>
<h2 id="k14">14. Odkazy na Internetu</h2>

<ol>

<li>Wisp na GitHubu<br />
<a href="https://github.com/Gozala/wisp">https://github.com/Gozala/wisp</a>
</li>

<li>Wisp playground<br />
<a href="http://www.jeditoolkit.com/try-wisp/">http://www.jeditoolkit.com/try-wisp/</a>
</li>

<li>REPL v prohlížeči<br />
<a href="http://www.jeditoolkit.com/interactivate-wisp/">http://www.jeditoolkit.com/interactivate-wisp/</a>
</li>

<li>Minification (programming)<br />
<a href="https://en.wikipedia.org/wiki/Minification_(programming)">https://en.wikipedia.org/wiki/Minification_(programming)</a>
</li>

<li>Clojure Macro Tutorial (Part I, Getting the Compiler to Write Your Code For You)<br />
<a href="http://www.learningclojure.com/2010/09/clojure-macro-tutorial-part-i-getting.html">http://www.learningclojure.com/2010/09/clojure-macro-tutorial-part-i-getting.html</a>
</li>

<li>Clojure Macro Tutorial (Part II: The Compiler Strikes Back)<br />
<a href="http://www.learningclojure.com/2010/09/clojure-macro-tutorial-part-ii-compiler.html">http://www.learningclojure.com/2010/09/clojure-macro-tutorial-part-ii-compiler.html</a>
</li>

<li>Clojure Macro Tutorial (Part III: Syntax Quote)<br />
<a href="http://www.learningclojure.com/2010/09/clojure-macro-tutorial-part-ii-syntax.html">http://www.learningclojure.com/2010/09/clojure-macro-tutorial-part-ii-syntax.html</a>
</li>

<li>Tech behind Tech: Clojure Macros Simplified<br />
<a href="http://techbehindtech.com/2010/09/28/clojure-macros-simplified/">http://techbehindtech.com/2010/09/28/clojure-macros-simplified/</a>
</li>

<li>Fatvat - Exploring functional programming: Clojure Macros<br />
<a href="http://www.fatvat.co.uk/2009/02/clojure-macros.html">http://www.fatvat.co.uk/2009/02/clojure-macros.html</a>
</li>

<li>Eulerovo ??slo<br />
<a href="http://cs.wikipedia.org/wiki/Eulerovo_??slo">http://cs.wikipedia.org/wiki/Eulerovo_??slo</a>
</li>

<li>List comprehension<br />
<a href="http://en.wikipedia.org/wiki/List_comprehension">http://en.wikipedia.org/wiki/List_comprehension</a>
</li>

<li>List Comprehensions in Clojure<br />
<a href="http://asymmetrical-view.com/2008/11/18/list-comprehensions-in-clojure.html">http://asymmetrical-view.com/2008/11/18/list-comprehensions-in-clojure.html</a>
</li>

<li>Clojure Programming Concepts: List Comprehension<br />
<a href="http://en.wikibooks.org/wiki/Clojure_Programming/Concepts#List_Comprehension">http://en.wikibooks.org/wiki/Clojure_Programming/Concepts#List_Comprehension</a>
</li>

<li>Clojure core API: for macro<br />
<a href="http://clojure.github.com/clojure/clojure.core-api.html#clojure.core/for">http://clojure.github.com/clojure/clojure.core-api.html#clojure.core/for</a>
</li>

<li>cirrus machina - The Clojure for macro<br />
<a href="http://www.cirrusmachina.com/blog/comment/the-clojure-for-macro/">http://www.cirrusmachina.com/blog/comment/the-clojure-for-macro/</a>
</li>

<li>Clojure.org: Clojure home page<br />
<a href="http://clojure.org/downloads">http://clojure.org/downloads</a>
</li>

<li>Clojure.org: Vars and the Global Environment<br />
<a href="http://clojure.org/Vars">http://clojure.org/Vars</a>
</li>

<li>Clojure.org: Refs and Transactions<br />
<a href="http://clojure.org/Refs">http://clojure.org/Refs</a>
</li>

<li>Clojure.org: Atoms<br />
<a href="http://clojure.org/Atoms">http://clojure.org/Atoms</a>
</li>

<li>Clojure.org: Agents as Asynchronous Actions<br />
<a href="http://clojure.org/agents">http://clojure.org/agents</a>
</li>

<li>A Couple of Clojure Agent Examples<br />
<a href="http://lethain.com/a-couple-of-clojure-agent-examples/">http://lethain.com/a-couple-of-clojure-agent-examples/</a>
</li>

<li>Clojure - Functional Programming for the JVM<br />
<a href="http://java.ociweb.com/mark/clojure/article.html">http://java.ociweb.com/mark/clojure/article.html</a>
</li>

<li>Clojure quick reference<br />
<a href="http://faustus.webatu.com/clj-quick-ref.html">http://faustus.webatu.com/clj-quick-ref.html</a>
</li>

<li>4Clojure<br />
<a href="http://www.4clojure.com/">http://www.4clojure.com/</a>
</li>

<li>ClojureDoc<br />
<a href="http://clojuredocs.org/">http://clojuredocs.org/</a>
</li>

<li>Clojure (Wikipedia EN)<br />
<a href="http://en.wikipedia.org/wiki/Clojure">http://en.wikipedia.org/wiki/Clojure</a>
</li>

<li>Clojure (Wikipedia CS)<br />
<a href="http://cs.wikipedia.org/wiki/Clojure">http://cs.wikipedia.org/wiki/Clojure</a>
</li>

<li>Riastradh's Lisp Style Rules<br />
<a href="http://mumble.net/~campbell/scheme/style.txt">http://mumble.net/~campbell/scheme/style.txt</a>
</li>

<li>Dynamic Languages Strike Back<br />
<a href="http://steve-yegge.blogspot.cz/2008/05/dynamic-languages-strike-back.html">http://steve-yegge.blogspot.cz/2008/05/dynamic-languages-strike-back.html</a>
</li>

<li>Scripting: Higher Level Programming for the 21st Century<br />
<a href="http://www.tcl.tk/doc/scripting.html">http://www.tcl.tk/doc/scripting.html</a>
</li>

<li>Java Virtual Machine Support for Non-Java Languages<br />
<a href="http://docs.oracle.com/javase/7/docs/technotes/guides/vm/multiple-language-support.html">http://docs.oracle.com/javase/7/docs/technotes/guides/vm/multiple-language-support.html</a>
</li>

<li>The Lua VM, on the Web<br />
<a href="https://kripken.github.io/lua.vm.js/lua.vm.js.html">https://kripken.github.io/lua.vm.js/lua.vm.js.html</a>
</li>

<li>Lua.vm.js REPL<br />
<a href="https://kripken.github.io/lua.vm.js/repl.html">https://kripken.github.io/lua.vm.js/repl.html</a>
</li>

<li>lua2js<br />
<a href="https://www.npmjs.com/package/lua2js">https://www.npmjs.com/package/lua2js</a>
</li>

<li>lua2js na GitHubu<br />
<a href="https://github.com/basicer/lua2js-dist">https://github.com/basicer/lua2js-dist</a>
</li>

<li>Seriál o programovacím jazyku Lua<br />
<a href="http://www.root.cz/serialy/programovaci-jazyk-lua/">http://www.root.cz/serialy/programovaci-jazyk-lua/</a>
</li>

<li>Source-to-source compiler<br />
<a href="https://en.wikipedia.org/wiki/Source-to-source_compiler">https://en.wikipedia.org/wiki/Source-to-source_compiler</a>
</li>

<li>JavaScript is Assembly Language for the Web: Sematic Markup is Dead! Clean vs. Machine-coded HTML<br />
<a href="http://www.hanselman.com/blog/JavaScriptIsAssemblyLanguageForTheWebSematicMarkupIsDeadCleanVsMachinecodedHTML.aspx">http://www.hanselman.com/blog/JavaScriptIsAssemblyLanguageForTheWebSematicMarkupIsDeadCleanVsMachinecodedHTML.aspx</a>
</li>

<li>JavaScript is Web Assembly Language and that's OK.<br />
<a href="http://www.hanselman.com/blog/JavaScriptIsWebAssemblyLanguageAndThatsOK.aspx">http://www.hanselman.com/blog/JavaScriptIsWebAssemblyLanguageAndThatsOK.aspx</a>
</li>

<li>Dart<br />
<a href="https://www.dartlang.org/">https://www.dartlang.org/</a>
</li>

<li>CoffeeScript<br />
<a href="http://coffeescript.org/">http://coffeescript.org/</a>
</li>

<li>TypeScript<br />
<a href="http://www.typescriptlang.org/">http://www.typescriptlang.org/</a>
</li>

<li>Lua (programming language)<br />
<a href="http://en.wikipedia.org/wiki/Lua_(programming_language)">http://en.wikipedia.org/wiki/Lua_(programming_language)</a>
</li>

<li>Static single assignment form (SSA)<br />
<a href="http://en.wikipedia.org/wiki/Static_single_assignment_form">http://en.wikipedia.org/wiki/Static_single_assignment_form</a>
</li>

<li>LuaJIT 2.0 SSA IR
<a href="http://wiki.luajit.org/SSA-IR-2.0">http://wiki.luajit.org/SSA-IR-2.0</a>
</li>

<li>The LuaJIT Project<br />
<a href="http://luajit.org/index.html">http://luajit.org/index.html</a>
</li>

<li>LuaJIT FAQ<br />
<a href="http://luajit.org/faq.html">http://luajit.org/faq.html</a>
</li>

<li>LuaJIT Performance Comparison<br />
<a href="http://luajit.org/performance.html">http://luajit.org/performance.html</a>
</li>

<li>LuaJIT 2.0 intellectual property disclosure and research opportunities<br />
<a href="http://article.gmane.org/gmane.comp.lang.lua.general/58908">http://article.gmane.org/gmane.comp.lang.lua.general/58908</a>
</li>

<li>LuaJIT Wiki<br />
<a href="http://wiki.luajit.org/Home">http://wiki.luajit.org/Home</a>
</li>

<li>LuaJIT 2.0 Bytecode Instructions<br />
<a href="http://wiki.luajit.org/Bytecode-2.0">http://wiki.luajit.org/Bytecode-2.0</a>
</li>

<li>Programming in Lua (first edition)<br />
<a href="http://www.lua.org/pil/contents.html">http://www.lua.org/pil/contents.html</a>
</li>

<li>Lua 5.2 sources<br />
<a href="http://www.lua.org/source/5.2/">http://www.lua.org/source/5.2/</a>
</li>

<li>Tcl Plugin Version 3<br />
<a href="http://www.tcl.tk/software/plugin/">http://www.tcl.tk/software/plugin/</a>
</li>

<li>JavaScript: The Web Assembly Language?<br />
<a href="http://www.informit.com/articles/article.aspx?p=1856657">http://www.informit.com/articles/article.aspx?p=1856657</a>
</li>

<li>asm.js<br />
<a href="http://asmjs.org/">http://asmjs.org/</a>
</li>

<li>List of languages that compile to JS<br />
<a href="https://github.com/jashkenas/coffeescript/wiki/List-of-languages-that-compile-to-JS">https://github.com/jashkenas/coffeescript/wiki/List-of-languages-that-compile-to-JS</a>
</li>

<li>REPL<br />
<a href="https://en.wikipedia.org/wiki/Read%E2%80%93eval%E2%80%93print_loop">https://en.wikipedia.org/wiki/Read%E2%80%93eval%E2%80%93print_loop</a>
</li>

<li>The LLVM Compiler Infrastructure<br />
<a href="http://llvm.org/ProjectsWithLLVM/">http://llvm.org/ProjectsWithLLVM/</a>
</li>

<li>clang: a C language family frontend for LLVM<br />
<a href="http://clang.llvm.org/">http://clang.llvm.org/</a>
</li>

<li>emscripten<br />
<a href="http://kripken.github.io/emscripten-site/">http://kripken.github.io/emscripten-site/</a>
</li>

<li>LLVM Backend ("Fastcomp")<br />
<a href="http://kripken.github.io/emscripten-site/docs/building_from_source/LLVM-Backend.html#llvm-backend">http://kripken.github.io/emscripten-site/docs/building_from_source/LLVM-Backend.html#llvm-backend</a>
</li>

<li>Emscripten - Fastcomp na GitHubu<br />
<a href="https://github.com/kripken/emscripten-fastcomp">https://github.com/kripken/emscripten-fastcomp</a>
</li>

<li>Clang (pro Emscripten) na GitHubu<br />
<a href="https://github.com/kripken/emscripten-fastcomp-clang">https://github.com/kripken/emscripten-fastcomp-clang</a>
</li>

<li>Why not use JavaScript?<br />
<a href="https://ckknight.github.io/gorillascript/">https://ckknight.github.io/gorillascript/</a>
</li>

</ol>



<p></p><p></p>
<p><small>Autor: <a href="http://www.fit.vutbr.cz/~tisnovpa">Pavel Tišnovský</a> &nbsp; 2015</small></p>
</body>
</html>

