<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
        "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html>
<head>
<title>Projekt Mori aneb perzistentní datové struktury pro JavaScript (dokončení)</title>
<meta name="Author" content="Pavel Tisnovsky" />
<meta name="Generator" content="vim" />
<meta http-equiv="content-type" content="text/html; charset=utf-8" />
<style type="text/css">
         body {color:#000000; background:#ffffff;}
         h1  {font-family: arial, helvetica, sans-serif; color:#ffffff; background-color:#c00000; text-align:center; padding-left:1em}
         h2  {font-family: arial, helvetica, sans-serif; color:#ffffff; background-color:#0000c0; padding-left:1em; text-align:left}
         h3  {font-family: arial, helvetica, sans-serif; color:#000000; background-color:#c0c0c0; padding-left:1em; text-align:left}
         h4  {font-family: arial, helvetica, sans-serif; color:#000000; background-color:#e0e0e0; padding-left:1em; text-align:left}
         a   {font-family: arial, helvetica, sans-serif;}
         li  {font-family: arial, helvetica, sans-serif; color:#000000; text-align:justify; width:450px;}
         ol  {font-family: arial, helvetica, sans-serif; color:#000000; text-align:justify; width:450px;}
         ul  {font-family: arial, helvetica, sans-serif; color:#000000; text-align:justify; width:450px;}
         p   {font-family: arial, helvetica, sans-serif; color:#000000; text-align:justify;}
         pre {background:#e0e0e0}
</style>
</head>

<body>

<h1>Projekt Mori aneb perzistentní datové struktury pro JavaScript (dokončení)</h1>

<h3>Pavel Tišnovský</h3>

<p></p>

<h1>Úvodník</h1>

<p>Ve druhé a současně i poslední části článku o knihovně Mori, která do JavaScriptu přidává podporu pro perzistentní datové struktury, si představíme funkcionální přístup při zpracování dat. Taktéž si ukážeme práci s perzistentními množinami a mapami, které doplňují dříve popsané seznamy a vektory.</p>



<h2>Obsah</h2>

<p><a href="#k01">1. Projekt Mori aneb perzistentní datové struktury pro JavaScript (dokončení)</a></p>
<p><a href="#k02">2. Zpracování sekvencí v&nbsp;knihovně Mori</a></p>
<p>&nbsp;&nbsp;&nbsp;<a href="#k021">2.1 Malé doplnění k&nbsp;předchozí části: použití funkce <strong>mori.range()</strong></a></p>
<p>&nbsp;&nbsp;&nbsp;<a href="#k022">2.2 Funkce <strong>mori.repeat()</strong></a></p>
<p>&nbsp;&nbsp;&nbsp;<a href="#k023">2.3 Funkce <strong>mori.partition()</strong></a></p>
<p>&nbsp;&nbsp;&nbsp;<a href="#k024">2.4 Funkce <strong>mori.interleave()</strong></a></p>
<p>&nbsp;&nbsp;&nbsp;<a href="#k025">2.5 Demonstrační příklady</a></p>
<p><a href="#k03">3. Použití funkcí vyššího řádu v&nbsp;knihovně Mori při zpracování sekvencí</a></p>
<p>&nbsp;&nbsp;&nbsp;<a href="#k031">3.1 Funkce <strong>mori.partitionBy()</strong></a></p>
<p>&nbsp;&nbsp;&nbsp;<a href="#k032">3.2 Funkce <strong>mori.takeWhile()</strong></a></p>
<p>&nbsp;&nbsp;&nbsp;<a href="#k033">3.3 Funkce <strong>mori.filter()</strong></a></p>
<p>&nbsp;&nbsp;&nbsp;<a href="#k034">3.4 Demonstrační příklad</a></p>
<p><a href="#k04">4. Operace s&nbsp;množinami</a></p>
<p>&nbsp;&nbsp;&nbsp;<a href="#k041">4.1 Funkce <strong>mori.set()</strong> a <strong>mori.sortedSet()</strong></a></p>
<p>&nbsp;&nbsp;&nbsp;<a href="#k042">4.2 Sjednocení, průnik a rozdíl množin</a></p>
<p>&nbsp;&nbsp;&nbsp;<a href="#k043">4.3 Demonstrační příklady</a></p>
<p><a href="#k05">5. Operace s&nbsp;mapami</a></p>
<p>&nbsp;&nbsp;&nbsp;<a href="#k051">5.1 Funkce <strong>mori.hashMap()</strong> a <strong>mori.sortedMap()</strong></a></p>
<p>&nbsp;&nbsp;&nbsp;<a href="#k052">5.2 Získání klíčů, hodnot a sloučení map</a></p>
<p>&nbsp;&nbsp;&nbsp;<a href="#k053">5.3 Funkce <strong>mori.assoc()</strong>, <strong>mori.dissoc()</strong> a <strong>mori.zipmap()</strong></a></p>
<p>&nbsp;&nbsp;&nbsp;<a href="#k054">5.4 Demonstrační příklady</a></p>
<p><a href="#k06">6. Obsah dalšího článku &ndash; porovnání Mori s&nbsp;knihovnou Immutable.js</a></p>
<p><a href="#k07">7. Repositář se zdrojovými kódy všech dnešních demonstračních příkladů</a></p>
<p><a href="#k08">8. Odkazy na Internetu</a></p>



<p><a name="k01"></a></p>
<h2 id="k01">1. Projekt Mori aneb perzistentní datové struktury pro JavaScript (dokončení)</h2>

<p>Knihovna <i>Mori</i>, která je, jak jsme se již dozvěděli <a
href="http://www.root.cz/clanky/projekt-mori-aneb-perzistentni-datove-struktury-pro-javascript/">v&nbsp;první
části tohoto článku</a>, založena na programovém kódu <a
href="http://www.root.cz/clanky/programovaci-jazyk-clojure-21-clojurescript-aneb-preklad-clojure-do-javascriptu/">ClojureScriptu</a>,
přidává do programovacího jazyka JavaScript podporu pro pět strukturovaných a
současně i perzistentních datových typů. Připomeňme si, že se jedná o seznamy,
vektory, fronty, množiny a mapy. Ovšem důležitější, než samotná existence
těchto datových typů, je podpora operací s&nbsp;daty. Právě zde se projevuje
funkcionální přístup, který knihovna <i>Mori</i> zdědila z&nbsp;ClojureScriptu:
nad všemi podporovanými datovými strukturami existuje jednotné rozhraní nazvané
<i>sekvence</i>; namísto metod se používají funkce, které nemodifikují datovou
strukturu, ale vrací strukturu novou a konečně mnoho funkcí z&nbsp;knihovny
<i>Mori</i> akceptuje jako své parametry jiné funkce (funkce vyššího řádu).
Díky těmto vlastnostem je implementace mnoha algoritmů velmi jednoduchá a
přímočará (programy totiž nejsou plné programových smyček, které mnohdy jen
zastiňují prováděnou operaci).</p>



<p><a name="k02"></a></p>
<h2 id="k02">2. Zpracování sekvencí v&nbsp;knihovně Mori</h2>

<p>V&nbsp;mnoha programech je nutné data, se kterými daný program pracuje,
nějakým způsobem transformovat, popř.&nbsp;vytvářet data nová (číselné řady
atd.). V&nbsp;knihovně <i>Mori</i> je k&nbsp;těmto účelům nabízeno velké
množství funkcí. V&nbsp;této kapitole se zaměříme na dvojici funkcí určených
pro vytváření číselných řad popř.&nbsp;sekvence stejných hodnot a taktéž na
funkce určené pro rozdělování i slučování sekvencí.</p>



<p><a name="k021"></a></p>
<h3 id="k021">2.1 Malé doplnění k&nbsp;předchozí části: použití funkce <strong>mori.range()</strong></h3>

<p>S&nbsp;funkcí <strong>mori.range()</strong> jsme se již setkali minule,
ovšem nebylo zcela jasně napsáno, jak se tato funkce chová při zadání různých
parametrů. Podívejme se tedy na pětici příkladů (tučný řádek označuje příkaz,
běžné písmo pak výsledek):</p>

<pre>
<i>// zadány jsou obě meze</i>
<strong>mori.range(1, 10);</strong>
(1 2 3 4 5 6 7 8 9)
&nbsp;
<i>// zadány jsou obě meze a krok</i>
<strong>mori.range(1, 10, 2);</strong>
(1 3 5 7 9)
&nbsp;
<i>// krok může být i záporný</i>
<strong>mori.range(10, 1, -2);</strong>
(10 8 6 4 2)
&nbsp;
<i>// je zadán jen počet prvků</i>
<strong>mori.range(10);</strong>
(0 1 2 3 4 5 6 7 8 9)
&nbsp;
<i>// není zadáno nic, což však nezpůsobí chybu</i>
<strong>mori.range();</strong>
(nekonečná lazy sekvence)
</pre>



<p><a name="k022"></a></p>
<h3 id="k022">2.2 Funkce <strong>mori.repeat()</strong></h3>

<p>Funkce <strong>mori.repeat()</strong> se částečně podobá funkci
<strong>mori.range()</strong>, ovšem s&nbsp;tím rozdílem, že se vytvoří lazy
sekvence obsahující stejné prvky, nikoli číselnou řadu. Pokud se zadá počet
prvků, je výsledkem konečná sekvence, pokud se ovšem zadá jen prvek (jediný
parametr), je vytvořená lazy sekvence nekonečná. Opět se podívejme na několik
příkladů:</p>

<pre>
<i>// počet prvků i hodnota prvku</i>
<strong>mori.repeat(1, 10);</strong>
(10)
&nbsp;
<i>// počet prvků i hodnota prvku</i>
<strong>mori.repeat(10, 1);</strong>
(1 1 1 1 1 1 1 1 1 1)
&nbsp;
<i>// počet prvků i hodnota prvku</i>
<strong>mori.repeat(10, 'hello');</strong>
("hello" "hello" "hello" "hello" "hello" "hello" "hello" "hello" "hello" "hello")
&nbsp;
<i>// u nekonečné sekvence si musíme dát pozor na to, aby nedošlo k jejímu vyhodnocení</i>
<strong>mori.take(42, mori.repeat('*'));</strong>
("*" "*" "*" "*" "*" "*" "*" "*" "*" "*" "*"
 "*" "*" "*" "*" "*" "*" "*" "*" "*" "*" "*"
 "*" "*" "*" "*" "*" "*" "*" "*" "*" "*" "*"
 "*" "*" "*" "*" "*" "*" "*" "*" "*")
&nbsp;
</pre>



<p><a name="k023"></a></p>
<h3 id="k023">2.3 Funkce <strong>mori.partition()</strong></h3>

<p>Funkce <strong>mori.partition()</strong> dokáže rozdělit zadanou sekvenci
(ať již konečnou či nekonečnou) na několik částí, přičemž lze zvolit délky
jednotlivých &bdquo;podsekvencí&ldquo;. Chování této funkce, včetně mezních
případů, nejlépe osvětlí příklady:</p>

<pre>
<i>// sekvence, kterou budeme rozdělovat</i>
<strong>var seq = mori.range(0,12);</strong>
(0 1 2 3 4 5 6 7 8 9 10 11)
&nbsp;
<i>// rozdělení na podsekvence o jednom prvku</i>
<strong>mori.partition(1, seq);</strong>
((0) (1) (2) (3) (4) (5) (6) (7) (8) (9) (10) (11))
&nbsp;
<i>// rozdělení na podsekvence o dvou prvcích</i>
<strong>mori.partition(2, seq);</strong>
((0 1) (2 3) (4 5) (6 7) (8 9) (10 11))
&nbsp;
<i>// rozdělení na podsekvence o třech prvcích</i>
<strong>mori.partition(3, seq);</strong>
((0 1 2) (3 4 5) (6 7 8) (9 10 11))
&nbsp;
<i>// rozdělení na podsekvence o čtyřech prvcích</i>
<strong>mori.partition(4, seq);</strong>
((0 1 2 3) (4 5 6 7) (8 9 10 11))
&nbsp;
<i>// rozdělení na podsekvence o šesti prvcích</i>
<strong>mori.partition(6, seq);</strong>
((0 1 2 3 4 5) (6 7 8 9 10 11))
&nbsp;
<i>// mezní případ</i>
<strong>mori.partition(20, seq);</strong>
()
</pre>



<p><a name="k024"></a></p>
<h3 id="k024">2.4 Funkce <strong>mori.interleave()</strong></h3>

<p>Opakem funkce <strong>mori.partition()</strong> je funkce nazvaná
<strong>mori.interleave()</strong>, která dokáže promíchat prvky ze dvou
sekvencí do jediné výsledné sekvence. Opět se podívejme na příklady:</p>

<pre>
<i>// první sekvence</i>
<strong>var seq1 = mori.range(0,12);</strong>
(0 1 2 3 4 5 6 7 8 9 10 11)
&nbsp;
<i>// druhá sekvence</i>
<strong>var seq2 = mori.repeat(12, '*');</strong>
("*" "*" "*" "*" "*" "*" "*" "*" "*" "*" "*" "*")
&nbsp;
<i>// promíchání obou sekvencí</i>
<strong>mori.interleave(seq1, seq2);</strong>
(0 "*" 1 "*" 2 "*" 3 "*" 4 "*" 5 "*" 6 "*" 7 "*" 8 "*" 9 "*" 10 "*" 11 "*")
</pre>



<p><a name="k025"></a></p>
<h3 id="k025">2.5 Demonstrační příklady</h3>

<p>Výše popsané čtyři funkce jsou součástí trojice demonstračních příkladů,
jejichž zdrojové kódy budou vypsány pod tímto odstavcem, a to včetně HTML
stránek sloužících pro spuštění příkladů ve webovém prohlížeči.</p>

<p><strong>mori_05.js</strong></p>

<pre>
// ------------------------------------------------------------
// Knihovna Mori: demonstracni priklad cislo 5
//
// Otestovani funkce mori.range()
// ------------------------------------------------------------
&nbsp;
&nbsp;
&nbsp;
// vypis informaci o vybrane sekvenci
function printSequenceInfo(declaration) {
    var sequence = eval(declaration);
    console.log("---------------------------------");
    console.log(declaration);
    console.log("length:  " + mori.count(sequence));
    console.log("content: " + sequence);
}
&nbsp;
printSequenceInfo("mori.range(1, 10)");
printSequenceInfo("mori.range(1, 10, 2)");
printSequenceInfo("mori.range(10, 1, -2)");
printSequenceInfo("mori.range(10)");
&nbsp;
&nbsp;
&nbsp;
// ------------------------------------------------------------
// Finito
// ------------------------------------------------------------
</pre>

<p><strong>mori_05.html</strong></p>

<pre>
&lt;!doctype html&gt;
&lt;html&gt;
    &lt;head&gt;
        &lt;title&gt;Mori tests #05&lt;/title&gt;
        &lt;meta charset="utf-8"&gt;
        &lt;script src="mori.js"&gt;&lt;/script&gt;
        &lt;script src="mori_05.js"&gt;&lt;/script&gt;
    &lt;/head&gt;
    &lt;body&gt;
        &lt;h1&gt;Mori tests #05&lt;/h1&gt;
    &lt;/body&gt;
&lt;/html&gt;
</pre>

<p><strong>mori_06.js</strong></p>

<pre>
// ------------------------------------------------------------
// Knihovna Mori: demonstracni priklad cislo 6
//
// Otestovani funkce mori.repeat()
// ------------------------------------------------------------
&nbsp;
&nbsp;
&nbsp;
// vypis informaci o vybrane sekvenci
function printSequenceInfo(declaration) {
    var sequence = eval(declaration);
    console.log("---------------------------------");
    console.log(declaration);
    console.log("length:  " + mori.count(sequence));
    console.log("content: " + sequence);
}
&nbsp;
printSequenceInfo("mori.repeat(1, 10)");
printSequenceInfo("mori.repeat(10, 1)");
printSequenceInfo("mori.repeat(10, 'hello')");
printSequenceInfo("mori.take(42, mori.repeat('*'))");
&nbsp;
&nbsp;
&nbsp;
// ------------------------------------------------------------
// Finito
// ------------------------------------------------------------
</pre>

<p><strong>mori_06.html</strong></p>

<pre>
&lt;!doctype html&gt;
&lt;html&gt;
    &lt;head&gt;
        &lt;title&gt;Mori tests #06&lt;/title&gt;
        &lt;meta charset="utf-8"&gt;
        &lt;script src="mori.js"&gt;&lt;/script&gt;
        &lt;script src="mori_06.js"&gt;&lt;/script&gt;
    &lt;/head&gt;
    &lt;body&gt;
        &lt;h1&gt;Mori tests #06&lt;/h1&gt;
    &lt;/body&gt;
&lt;/html&gt;
</pre>

<p><strong>mori_07.js</strong></p>

<pre>
// ------------------------------------------------------------
// Knihovna Mori: demonstracni priklad cislo 7
//
// Otestovani funkce mori.partition() a mori.interleave()
// ------------------------------------------------------------
&nbsp;
&nbsp;
&nbsp;
// ziskani typu sekvence
function sequenceType(sequence) {
    return mori.isList(sequence)   ? "list" :
           mori.isVector(sequence) ? "vector" :
           mori.isMap(sequence)    ? "map" :
           mori.isSet(sequence)    ? "set" :
           mori.isSeq(sequence)    ? "sequence" :
           "unknown";
}
&nbsp;
&nbsp;
&nbsp;
// vypis informaci o vybrane sekvenci
function printSequenceInfo(declaration) {
    var sequence = eval(declaration);
    var type = sequenceType(sequence);
    console.log("---------------------------------");
    console.log(declaration);
    console.log("type:    " + type);
    console.log("length:  " + mori.count(sequence));
    console.log("content: " + sequence);
}
&nbsp;
var seq = mori.range(0,12);
&nbsp;
printSequenceInfo("mori.partition(1, seq)");
printSequenceInfo("mori.partition(2, seq)");
printSequenceInfo("mori.partition(3, seq)");
printSequenceInfo("mori.partition(4, seq)");
printSequenceInfo("mori.partition(6, seq)");
printSequenceInfo("mori.partition(20, seq)");
&nbsp;
var seq1 = mori.range(0,12);
var seq2 = mori.repeat(12, '*');
&nbsp;
printSequenceInfo("seq1");
printSequenceInfo("seq2");
printSequenceInfo("mori.interleave(seq1, seq2)");
&nbsp;
&nbsp;
&nbsp;
// ------------------------------------------------------------
// Finito
// ------------------------------------------------------------
</pre>

<p><strong>mori_07.html</strong></p>

<pre>
&lt;!doctype html&gt;
&lt;html&gt;
    &lt;head&gt;
        &lt;title&gt;Mori tests #07&lt;/title&gt;
        &lt;meta charset="utf-8"&gt;
        &lt;script src="mori.js"&gt;&lt;/script&gt;
        &lt;script src="mori_07.js"&gt;&lt;/script&gt;
    &lt;/head&gt;
    &lt;body&gt;
        &lt;h1&gt;Mori tests #07&lt;/h1&gt;
    &lt;/body&gt;
&lt;/html&gt;
</pre>



<p><a name="k03"></a></p>
<h2 id="k03">3. Použití funkcí vyššího řádu v&nbsp;knihovně Mori při zpracování sekvencí</h2>

<p>V&nbsp;knihovně <i>Mori</i> se v&nbsp;mnoha funkcích používají i takzvané
funkce vyššího řádu. S&nbsp;jednou takovou funkcí jsme se již setkali minule
&ndash; jednalo se o <strong>mori.map()</strong>. Ve skutečnosti těchto funkcí
existuje více; s&nbsp;třemi z&nbsp;nich se seznámíme v&nbsp;navazujících
podkapitolách.</p>



<p><a name="k031"></a></p>
<h3 id="k031">3.1 Funkce <strong>mori.partitionBy()</strong></h3>

<p>Funkce <strong>mori.partitionBy()</strong> slouží, podobně jako již zmíněná
funkce <strong>mori.partition()</strong>, k&nbsp;rozdělení lazy sekvence do
podsekvencí. Ovšem zde se namísto počtu prvků v&nbsp;podsekvenci při
rozdělování vyhodnocuje zadaná funkce a teprve ve chvíli, kdy tato funkce změní
hodnotu, dojde ke vzniku nové podsekvence. Příklady vše osvětlí:</p>

<pre>
<i>// funkce používaná pro partitionBy</i>
function f0(n) {
    return "konstanta"
}
&nbsp;
<i>// funkce používaná pro partitionBy</i>
function f1(n) {
    return n &lt; 6;
}
&nbsp;
<i>// funkce používaná pro partitionBy</i>
function f2(n) {
    return n % 2 == 1;
}
&nbsp;
<i>// funkce používaná pro partitionBy</i>
function f3(n) {
    return n % 4 == 3;
}
&nbsp;
<i>// funkce používaná pro partitionBy</i>
function f4(n) {
    return Math.random() &lt; 0.5;
}
&nbsp;
<i>// vstupní sekvence</i>
var seq = mori.range(0,12);
(0 1 2 3 4 5 6 7 8 9 10 11)
&nbsp;
<i>// funkce f0 nemění svou výstupní hodnotu NIKDY</i>
<strong>mori.partitionBy(f0, seq)</strong>
((0 1 2 3 4 5 6 7 8 9 10 11))
&nbsp;
<i>// funkce f0 změní výstupní hodnotu ve chvíli, kdy překročíme hodnotu 5</i>
<strong>mori.partitionBy(f1, seq)</strong>
((0 1 2 3 4 5) (6 7 8 9 10 11))
&nbsp;
<i>// funkce f0 mění svou výstupní hodnotu VŽDY (pro daný vstup)</i>
<strong>mori.partitionBy(f2, seq)</strong>
((0) (1) (2) (3) (4) (5) (6) (7) (8) (9) (10) (11))
&nbsp;
<strong>mori.partitionBy(f3, seq)</strong>
((0 1 2) (3) (4 5 6) (7) (8 9 10) (11))
&nbsp;
<i>// náhodné rozdělení na podsekvence</i>
<strong>mori.partitionBy(f4, seq)</strong>
((0 1 2 3 4) (5) (6 7 8 9) (10 11))
</pre>



<p><a name="k032"></a></p>
<h3 id="k032">3.2 Funkce <strong>mori.takeWhile()</strong></h3>

<p>Funkce <strong>mori.takeWhile()</strong> postupně vyhodnocuje prvky vstupní
sekvence a vrací je ve formě nové lazy sekvence, ovšem jen do doby, dokud
volaná uživatelská funkce vrací pravdivostní hodnotu <strong>true</strong>:</p>

<pre>
<i>// funkce používaná pro takeWhile</i>
function f1(n) {
    return n &lt; 6;
}
&nbsp;
<i>// funkce používaná pro takeWhile</i>
function f2(n) {
    return n % 2 == 1;
}
&nbsp;
<i>// funkce používaná pro takeWhile</i>
function f3(n) {
    return n % 4 == 3;
}
&nbsp;
<i>// vstupní sekvence</i>
<strong>var seq = mori.range(0,12);</strong>
(0 1 2 3 4 5 6 7 8 9 10 11)
&nbsp;
<i>// u prvku s hodnotou 6 již f1(6) vrátí false</i>
<strong>mori.takeWhile(f1, seq)</strong>
(0 1 2 3 4 5)
&nbsp;
<strong>mori.takeWhile(f2, seq)</strong>
()
&nbsp;
<strong>mori.takeWhile(f3, seq)</strong>
()
</pre>



<p><a name="k033"></a></p>
<h3 id="k033">3.3 Funkce <strong>mori.filter()</strong></h3>

<p>Funkce <strong>mori.filter()</strong> taktéž prochází vstupní sekvenci a
vytváří výstupní lazy sekvenci z&nbsp;prvků původní sekvence. Ovšem do nové
sekvence jsou zařazeny pouze ty prvky, pro něž volaná uživatelská funkce vrátí
hodnotu <strong>true</strong> či jinou hodnotu odlišnou od
<strong>false</strong> (naproti tomu funkce <strong>mori.takeWhile()</strong>
zpracování na tomto místě zastaví). Je libo příklad?:</p>

<pre>
<i>// funkce používaná pro filter</i>
function f1(n) {
    return n &lt; 6;
}
&nbsp;
<i>// funkce používaná pro filter</i>
function f2(n) {
    return n % 2 == 1;
}
&nbsp;
<i>// funkce používaná pro filter</i>
function f3(n) {
    return n % 4 == 3;
}
&nbsp;
<i>// vstupní sekvence</i>
<strong>var seq = mori.range(0,12);</strong>
(0 1 2 3 4 5 6 7 8 9 10 11)
&nbsp;
<i>// f1 vrací true pouze pro hodnoty menší než 6</i>
<strong>mori.filter(f1, seq)</strong>
(0 1 2 3 4 5)
&nbsp;
<i>// funkce f2 vrací true v závislosti na dělitelnosti 2</i>
<strong>mori.filter(f2, seq)</strong>
(1 3 5 7 9 11)
&nbsp;
<i>// funkce f2 vrací true v závislosti na dělitelnosti 4</i>
<strong>mori.filter(f3, seq)</strong>
(3 7 11)
</pre>



<p><a name="k034"></a></p>
<h3 id="k034">3.4 Demonstrační příklad</h3>

<p>Všechny tři výše popsané funkce jsou použity v&nbsp;demonstračním příkladu
nazvaném <strong>mori_08</strong>:</p>

<p><strong>mori_08.js</strong></p>

<pre>
// ------------------------------------------------------------
// Knihovna Mori: demonstracni priklad cislo 8
//
// Otestovani funkce mori.partitionBy(), mori.takeWhile()
// a mori.filter().
// ------------------------------------------------------------
&nbsp;
&nbsp;
&nbsp;
// ziskani typu sekvence
function sequenceType(sequence) {
    return mori.isList(sequence)   ? "list" :
           mori.isVector(sequence) ? "vector" :
           mori.isMap(sequence)    ? "map" :
           mori.isSet(sequence)    ? "set" :
           mori.isSeq(sequence)    ? "sequence" :
           "unknown";
}
&nbsp;
&nbsp;
&nbsp;
// vypis informaci o vybrane sekvenci
function printSequenceInfo(declaration) {
    var sequence = eval(declaration);
    var type = sequenceType(sequence);
    console.log("---------------------------------");
    console.log(declaration);
    console.log("type:    " + type);
    console.log("length:  " + mori.count(sequence));
    console.log("content: " + sequence);
}
&nbsp;
function f0(n) {
    return "konstanta"
}
&nbsp;
function f1(n) {
    return n &lt; 6;
}
&nbsp;
function f2(n) {
    return n % 2 == 1;
}
&nbsp;
function f3(n) {
    return n % 4 == 3;
}
&nbsp;
function f4(n) {
    return Math.random() &lt; 0.5;
}
&nbsp;
var seq = mori.range(0,12);
&nbsp;
printSequenceInfo("mori.partitionBy(f0, seq)");
printSequenceInfo("mori.partitionBy(f1, seq)");
printSequenceInfo("mori.partitionBy(f2, seq)");
printSequenceInfo("mori.partitionBy(f3, seq)");
printSequenceInfo("mori.partitionBy(f4, seq)");
&nbsp;
printSequenceInfo("mori.takeWhile(f1, seq)");
printSequenceInfo("mori.takeWhile(f2, seq)");
printSequenceInfo("mori.takeWhile(f3, seq)");
&nbsp;
printSequenceInfo("mori.filter(f1, seq)");
printSequenceInfo("mori.filter(f2, seq)");
printSequenceInfo("mori.filter(f3, seq)");
&nbsp;
&nbsp;
&nbsp;
// ------------------------------------------------------------
// Finito
// ------------------------------------------------------------
</pre>

<p><strong>mori_08.html</strong></p>

<pre>
&lt;!doctype html&gt;
&lt;html&gt;
    &lt;head&gt;
        &lt;title&gt;Mori tests #08&lt;/title&gt;
        &lt;meta charset="utf-8"&gt;
        &lt;script src="mori.js"&gt;&lt;/script&gt;
        &lt;script src="mori_08.js"&gt;&lt;/script&gt;
    &lt;/head&gt;
    &lt;body&gt;
        &lt;h1&gt;Mori tests #08&lt;/h1&gt;
    &lt;/body&gt;
&lt;/html&gt;
</pre>



<p><a name="k04"></a></p>
<h2 id="k04">4. Operace s&nbsp;množinami</h2>

<p>Velmi důležitým, i když mnohdy možná poněkud opomíjeným strukturovaným
datovým typem, jsou množiny, neboli <i>sets</i> (mimochodem &ndash; to, že se
množiny nepoužívají tak často, jak to implementace nějakého algoritmu vyžaduje,
je častá chyba, která je pravděpodobně způsobena tím, že množiny jakožto
samostatný datový typ v&nbsp;některých jazycích neexistují). Tento datový typ
skutečně reflektuje některé vlastnosti matematických množin, zejména fakt, že
prvek se stejnou hodnotou může být v&nbsp;množině uložen maximálně jedenkrát
(v&nbsp;knihovně Mori je ekvivalence hodnot řešena opět funkcionálním způsobem,
mj.&nbsp;i rekurzivním porovnáním všech prvků dvou objektů). Vzhledem
k&nbsp;tomu, že v&nbsp;mnoha algoritmech je nutné získat seřazené prvky,
podporuje knihovna <i>Mori</i> dvě implementace množin &ndash; množiny založené
na hešovací tabulce a množiny se setříděnými prvky založené na stromech.</p>



<p><a name="k041"></a></p>
<h3 id="k041">4.1 Funkce <strong>mori.set()</strong> a <strong>mori.sortedSet()</strong></h3>

<p>Podívejme se nyní na konstruktory množin, které jsou představovány funkcemi
<strong>mori.set()</strong> a <strong>mori.sortedSet()</strong>. První
z&nbsp;těchto funkcí vytvoří množinu (založenou na hešovací mapě, ovšem
komplikovanějším způsobem, než je to běžné) ze sekvence, druhá funkce vytvoří
množinu (založenou na stromu) kupodivu nikoli ze sekvence, ale z&nbsp;hodnot,
které jsou této funkci přímo předány. Podívejme se na příklady konstrukce
množin:</p>

<pre>
<i>// množina se čtyřmi prvky</i>
<strong>var set1 = mori.set([1,2,3,4]);</strong>
#{1 2 3 4}
&nbsp;
<i>// množina se čtyřmi prvky</i>
<i>// (pořadí zůstává nezměněno, a to díky interní implementaci množin)</i>
<strong>var set2 = mori.set([4,3,2,1]);</strong>
#{4 3 2 1}
&nbsp;
<i>// zde se projeví první vlastnost množiny: každý prvek je uložen maximálně jedenkrát</i>
<strong>var set3 = mori.set([1,100,1,1]);</strong>
#{1 100}
&nbsp;
<i>// i zde se projeví první vlastnost množiny: každý prvek je uložen maximálně jedenkrát</i>
<strong>var set4 = mori.set(["C", "C++", "Java", "JavaScript", "D", "Lua", "C"])</strong>
#{"C" "C++" "Java" "JavaScript" "D" "Lua"}
&nbsp;
<i>// konstrukce množiny ze sekvence</i>
<i>// (povšimněte si způsobu &bdquo;rozházení&ldquo; prvků)</i>
<strong>var hugeSet = mori.set(mori.range(0,100))</strong>
#{0 32 64 96 1 33 65 97 2 34 66 98 3 35 67 99 4 36 68 5 37
 69 6 38 70 7 39 71 8 40 72 9 41 73 10 42 74 11 43 75 12 44
 76 13 45 77 14 46 78 15 47 79 16 48 80 17 49 81 18 50 82
 19 51 83 20 52 84 21 53 85 22 54 86 23 55 87 24 56 88 25
 57 89 26 58 90 27 59 91 28 60 92 29 61 93 30 62 94 31 63 95}
&nbsp;
<i>// množina se setříděnými prvky</i>
<strong>var set5 = mori.sortedSet(1,2,3,4);</strong>
#{1 2 3 4}
&nbsp;
<i>// množina se setříděnými prvky</i>
<strong>var set6 = mori.sortedSet(4,3,2,1);</strong>
#{1 2 3 4}
&nbsp;
<i>// množina se setříděnými a unikátními prvky</i>
<strong>var set7 = mori.sortedSet(1,100,1,1);</strong>
#{1 100}
&nbsp;
<i>// množina se setříděnými a unikátními prvky</i>
<strong>var set8 = mori.sortedSet("C", "C++", "Java", "JavaScript", "D", "Lua", "C")</strong>
#{"C" "C++" "D" "Java" "JavaScript" "Lua"}
</pre>



<p><a name="k042"></a></p>
<h3 id="k042">4.2 Sjednocení, průnik a rozdíl množin</h3>

<p>Mezi základní operace s&nbsp;množinami patří jejich sjednocení, průnik a
rozdíl, které jsou v&nbsp;knihovně <i>Mori</i> představovány funkcemi
<strong>mori.union()</strong>, <strong>mori.intersection()</strong> a
<strong>mori.difference()</strong>. Chování těchto funkcí by mělo být známé,
nicméně si ho pro jistotu otestujme:</p>

<pre>
<i>// první množina s deseti prvky 0..9</i>
<strong>var set1 = mori.set(mori.range(0,10));</strong>
#{0 1 2 3 4 5 6 7 8 9}
&nbsp;
<i>// druhá množina se šesti prvky 0..5</i>
<strong>var set2 = mori.set(mori.range(0,6));</strong>
#{0 1 2 3 4 5}
&nbsp;
<i>// třetí množina se šesti prvky 4..9</i>
<strong>var set3 = mori.set(mori.range(4,10));</strong>
#{4 5 6 7 8 9}
&nbsp;
<i>// sjednocení množin</i>
<strong>mori.union(set2, set3)</strong>
#{0 1 2 3 4 5 6 7 8 9}
&nbsp;
<i>// průnik množin: množiny set2 a set3 se překrývají prvky 4 a 5</i>
<strong>mori.intersection(set2, set3)</strong>
#{4 5}
&nbsp;
<i>// rozdíl množin, jsou odebrány dva překrývající se prvky</i>
<strong>mori.difference(set2, set3)</strong>
#{0 1 2 3}
&nbsp;
<i>// rozdíl množin, jsou odebrány dva překrývající se prvky</i>
<strong>mori.difference(set3, set2)</strong>
#{6 7 8 9}
&nbsp;
<i>// rozdíl množin, vše co zbývá z množiny set1 po odebrání prvků nalezených i v set2</i>
<strong>mori.difference(set1, set2)</strong>
#{6 7 8 9}
&nbsp;
<i>// rozdíl množin, vše co zbývá z množiny set1 po odebrání prvků nalezených i v set3</i>
<strong>mori.difference(set1, set3)</strong>
#{0 1 2 3}
</pre>



<p><a name="k043"></a></p>
<h3 id="k043">4.3 Demonstrační příklady</h3>

<p>Výše popsané funkce pro práci s&nbsp;množinami jsou součástí dvojice
demonstračních příkladů, jejichž zdrojové kódy budou vypsány pod tímto
odstavcem, a to včetně HTML stránek sloužících pro spuštění příkladů ve webovém
prohlížeči.</p>

<p><strong>mori_9.js</strong></p>

<pre>
// ------------------------------------------------------------
// Knihovna Mori: demonstracni priklad cislo 9
//
// Zakladni vlastnosti mnozin
// ------------------------------------------------------------
&nbsp;
&nbsp;
&nbsp;
// ziskani typu sekvence
function sequenceType(sequence) {
    return mori.isList(sequence)   ? "list" :
           mori.isVector(sequence) ? "vector" :
           mori.isMap(sequence)    ? "map" :
           mori.isSet(sequence)    ? "set" :
           mori.isSeq(sequence)    ? "sequence" :
           "unknown";
}
&nbsp;
&nbsp;
&nbsp;
// vypis informaci o vybrane sekvenci
function printSequenceInfo(declaration) {
    var sequence = eval(declaration);
    var type = sequenceType(sequence);
    console.log("---------------------------------");
    console.log(declaration);
    console.log("type:    " + type);
    console.log("length:  " + mori.count(sequence));
    console.log("content: " + sequence);
}
&nbsp;
var set1 = mori.set([1,2,3,4]);
var set2 = mori.set([4,3,2,1]);
var set3 = mori.set([1,100,1,1]);
var set4 = mori.set(["C", "C++", "Java", "JavaScript", "D", "Lua", "C"])
&nbsp;
var set5 = mori.sortedSet(1,2,3,4);
var set6 = mori.sortedSet(4,3,2,1);
var set7 = mori.sortedSet(1,100,1,1);
var set8 = mori.sortedSet("C", "C++", "Java", "JavaScript", "D", "Lua", "C")
&nbsp;
var hugeSet = mori.set(mori.range(0,100))
&nbsp;
printSequenceInfo("set1");
printSequenceInfo("set2");
printSequenceInfo("set3");
printSequenceInfo("set4");
printSequenceInfo("set5");
printSequenceInfo("set6");
printSequenceInfo("set7");
printSequenceInfo("set8");
printSequenceInfo("hugeSet");
&nbsp;
&nbsp;
&nbsp;
// ------------------------------------------------------------
// Finito
// ------------------------------------------------------------
</pre>

<p><strong>mori_09.html</strong></p>

<pre>
&lt;!doctype html&gt;
&lt;html&gt;
    &lt;head&gt;
        &lt;title&gt;Mori tests #09&lt;/title&gt;
        &lt;meta charset="utf-8"&gt;
        &lt;script src="mori.js"&gt;&lt;/script&gt;
        &lt;script src="mori_09.js"&gt;&lt;/script&gt;
    &lt;/head&gt;
    &lt;body&gt;
        &lt;h1&gt;Mori tests #09&lt;/h1&gt;
    &lt;/body&gt;
&lt;/html&gt;
</pre>

<p><strong>mori_10.js</strong></p>

<pre>
// ------------------------------------------------------------
// Knihovna Mori: demonstracni priklad cislo 10
//
// Operace s mnozinami
// ------------------------------------------------------------
&nbsp;
&nbsp;
&nbsp;
// ziskani typu sekvence
function sequenceType(sequence) {
    return mori.isList(sequence)   ? "list" :
           mori.isVector(sequence) ? "vector" :
           mori.isMap(sequence)    ? "map" :
           mori.isSet(sequence)    ? "set" :
           mori.isSeq(sequence)    ? "sequence" :
           "unknown";
}
&nbsp;
&nbsp;
&nbsp;
// vypis informaci o vybrane sekvenci
function printSequenceInfo(declaration) {
    var sequence = eval(declaration);
    var type = sequenceType(sequence);
    console.log("---------------------------------");
    console.log(declaration);
    console.log("type:    " + type);
    console.log("length:  " + mori.count(sequence));
    console.log("content: " + sequence);
}
&nbsp;
var set1 = mori.set(mori.range(0,10));
var set2 = mori.set(mori.range(0,6));
var set3 = mori.set(mori.range(4,10));
&nbsp;
printSequenceInfo("set1");
printSequenceInfo("set2");
printSequenceInfo("set3");
printSequenceInfo("mori.union(set2, set3)");
printSequenceInfo("mori.intersection(set2, set3)");
printSequenceInfo("mori.difference(set2, set3)");
printSequenceInfo("mori.difference(set3, set2)");
printSequenceInfo("mori.difference(set1, set2)");
printSequenceInfo("mori.difference(set1, set3)");
&nbsp;
&nbsp;
&nbsp;
// ------------------------------------------------------------
// Finito
// ------------------------------------------------------------
</pre>

<p><strong>mori_10.html</strong></p>

<pre>
&lt;!doctype html&gt;
&lt;html&gt;
    &lt;head&gt;
        &lt;title&gt;Mori tests #10&lt;/title&gt;
        &lt;meta charset="utf-8"&gt;
        &lt;script src="mori.js"&gt;&lt;/script&gt;
        &lt;script src="mori_10.js"&gt;&lt;/script&gt;
    &lt;/head&gt;
    &lt;body&gt;
        &lt;h1&gt;Mori tests #10&lt;/h1&gt;
    &lt;/body&gt;
&lt;/html&gt;
</pre>



<p><a name="k05"></a></p>
<h2 id="k05">5. Operace s&nbsp;mapami</h2>

<p>Mapy (asociativní pole) jakožto strukturovaný datový typ pravděpodobně není
nutné čtenářům tohoto článku podrobněji představovat, protože tento datový typ
je podporovaný mnoha různými programovacími jazyky, samozřejmě včetně
JavaScriptu. Podobně jako je tomu u množin, i mapy jsou v&nbsp;knihovně
<i>Mori</i> implementovány dvěma způsoby &ndash; buď s&nbsp;využitím hešovací
mapy či stromem. Záleží tedy pouze na vývojáři, který typ mapy využije, a to
v&nbsp;závislosti na tom, zda je nutné prvky z&nbsp;mapy získávat seřazené
(podle klíče) či v&nbsp;náhodném pořadí. Zajímavé je, že klíče mohou být
jakéhokoli typu, což možná překvapí programátory v&nbsp;Javě, v&nbsp;níž mohou
být klíče pouze objektového typu (reference).</p>



<p><a name="k051"></a></p>
<h3 id="k051">5.1 Funkce <strong>mori.hashMap()</strong> a <strong>mori.sortedMap()</strong></h3>

<p>Nejprve si ukažme způsob konstrukce map, a to jak map založených na hešovací
funkci, tak i map založených na použití stromu:</p>

<pre>
<i>// mapa s nesetříděnými dvojicemi klíč-hodnota</i>
<strong>mori.hashMap("k9", 9, "k8", 8, "k7", 7, "k6", 6, "k5", 5, "k4", 4, "k3", 3, "k2", 2, "k1", 1);</strong>
{"k8" 8, "k7" 7, "k9" 9, "k6" 6, "k5" 5, "k3" 3, "k1" 1, "k4" 4, "k2" 2}
&nbsp;
<i>// mapa se setříděnými dvojicemi klíč-hodnota</i>
<strong>mori.sortedMap("k9", 9, "k8", 8, "k7", 7, "k6", 6, "k5", 5, "k4", 4, "k3", 3, "k2", 2, "k1", 1);</strong>
{"k1" 1, "k2" 2, "k3" 3, "k4" 4, "k5" 5, "k6" 6, "k7" 7, "k8" 8, "k9" 9}
&nbsp;
<i>// mapa s nesetříděnými dvojicemi klíč-hodnota</i>
<i>// (to, že se pořadí prvků nezměnilo, je způsobeno malou velikostí mapy)</i>
<strong>mori.hashMap("first", 1, "second", 2, "third", 3);</strong>
{"first" 1, "second" 2, "third" 3}
</pre>



<p><a name="k052"></a></p>
<h3 id="k052">5.2 Získání klíčů, hodnot a sloučení map</h3>

<p>Pro získání všech klíčů z&nbsp;libovolné mapy slouží funkce
<strong>mori.keys()</strong>, pro získání všech hodnot pak (logicky) funkce
nazvaná <strong>mori.vals()</strong>. Další důležitou funkcí, která se
v&nbsp;programech používá poměrně často, je funkce
<strong>mori.merge()</strong>, která sloučí dvě mapy. Ve chvíli, kdy
v&nbsp;obou slučovaných mapách existují dvojice se stejnými klíči, dostane
přednost dvojice získaná z&nbsp;druhé mapy:</p>

<pre>
<i>// mapa s nesetříděnými dvojicemi klíč-hodnota</i>
<strong>var map1 = mori.hashMap("k9", 9, "k8", 8, "k7", 7, "k6", 6, "k5", 5, "k4", 4, "k3", 3, "k2", 2, "k1", 1);</strong>
&nbsp;
<i>// mapa se setříděnými dvojicemi klíč-hodnota</i>
<strong>var map2 = mori.sortedMap("k9", 9, "k8", 8, "k7", 7, "k6", 6, "k5", 5, "k4", 4, "k3", 3, "k2", 2, "k1", 1);</strong>
&nbsp;
<i>// mapa s nesetříděnými dvojicemi klíč-hodnota</i>
<strong>var map3 = mori.hashMap("first", 1, "second", 2, "third", 3);</strong>
&nbsp;
<i>// klíče z první mapy</i>
<strong>mori.keys(map1)</strong>
("k8" "k7" "k9" "k6" "k5" "k3" "k1" "k4" "k2")
&nbsp;
<i>// klíče (setříděné) z druhé mapy</i>
<strong>mori.keys(map2)</strong>
("k1" "k2" "k3" "k4" "k5" "k6" "k7" "k8" "k9")
&nbsp;
<i>// hodnoty z první mapy</i>
<strong>mori.vals(map1)</strong>
(8 7 9 6 5 3 1 4 2)
&nbsp;
<i>// hodnoty z druhé mapy</i>
<strong>mori.vals(map2)</strong>
(1 2 3 4 5 6 7 8 9)
&nbsp;
<i>// sjednocení map 1 a 3</i>
<strong>mori.merge(map1, map3)</strong>
{"k8" 8, "k7" 7, "k9" 9, "k6" 6, "k5" 5, "second" 2,
 "k3" 3, "third" 3, "k1" 1, "k4" 4, "k2" 2, "first" 1}
</pre>



<p><a name="k053"></a></p>
<h3 id="k053">5.3 Funkce <strong>mori.assoc()</strong>, <strong>mori.dissoc()</strong> a <strong>mori.zipmap()</strong></h3>

<p>Mapy jsou sice, podobně jako i všechny ostatní datové struktury poskytované
knihovnou Mori, perzistentní, ovšem to neznamená, že neexistují funkce, které
dokážou vrátit novou mapu s&nbsp;přidanou dvojicí klíč-hodnota, či naopak
s&nbsp;odebranou dvojicí klíč-hodnota (interně se používá sdílení struktury,
takže se nemusíte bát, že se musí jednat o časově náročné operace). První
z&nbsp;těchto funkcí se jmenuje <strong>mori.assoc()</strong> (přidání dat,
přesněji vrácení nové mapy s&nbsp;přidanou dvojicí klíč-hodnota), druhá funkce
se jmenuje <strong>mori.dissoc</strong> (odebrání dat). U složitějších (vnořených)
map se použije funkce <strong>mori.assocIn()</strong> a
<strong>mori.updateIn()</strong>:</p>

<pre>
<i>// mapa použitá pro přidání a ubrání prvku</i>
<strong>var map2 = mori.sortedMap(1, "first", 2, "second", 3, "third");</strong>
&nbsp;
<i>// výpis obsahu mapy</i>
<strong>map2;</strong>
{1 "first", 2 "second", 3 "third"}
&nbsp;
<i>// přidání dvojice klíč-hodnota do mapy</i>
<strong>mori.assoc(map2, 4, 'fourth', 5, 'fifth');</strong>
{1 "first", 2 "second", 3 "third", 4 "fourth", 5 "fifth"}
&nbsp;
<i>// odebrání vybraných dvojic klíč-hodnota z mapy (dvojice jsou určeny klíči)</i>
<strong>mori.dissoc(map2, 1, 5);</strong>
{2 "second", 3 "third"}
</pre>

<p>Nesmíme zapomenout ani na velmi užitečnou funkci nazvanou
<strong>mori.zipmap()</strong>, která dokáže vytvořit mapu ze dvou sekvencí,
přičemž z&nbsp;první sekvence se získají klíče a ze sekvence druhé pak hodnoty.
Jedná se tedy o jakousi obdobu funkce <strong>mori.interleave()</strong>, ovšem
vytvořenou přesně pro mapy. Podívejme se na příklad použití:</p>

<pre>
// funkce použitá pro výpočet druhé sekvence
function factorial(n) {
    var fac = 1;
    for (var i = 2; i &lt;= n; i++) {
        fac = fac * i;
    }
    return fac;
}
&nbsp;
&nbsp;
&nbsp;
<i>// první sekvence čísel 1 až 10</i>
<strong>var seq1 = mori.range(1,11);</strong>
(1 2 3 4 5 6 7 8 9 10)
&nbsp;
<i>// druhá sekvence obsahuje faktoriály čísel 1 až 10</i>
<strong>var seq2 = mori.map(factorial, seq1);</strong>
(1 2 6 24 120 720 5040 40320 362880 3628800)
&nbsp;
<i>// z obou sekvencí vytvoříme mapu</i>
mori.zipmap(seq1, seq2);
<strong>{1 1, 2 2, 3 6, 4 24, 5 120, 6 720, 7 5040, 8 40320, 9 362880, 10 3628800}</strong>
</pre>



<p><a name="k054"></a></p>
<h3 id="k054">5.4 Demonstrační příklady</h3>

<p>Výše popsané funkce pro práci s&nbsp;mapami jsou součástí dvojice
demonstračních příkladů, jejichž zdrojové kódy budou vypsány pod tímto
odstavcem, a to včetně HTML stránek sloužících pro spuštění příkladů ve webovém
prohlížeči.</p>

<p><strong>mori_11.js</strong></p>

<pre>
// ------------------------------------------------------------
// Knihovna Mori: demonstracni priklad cislo 11
//
// Zakladni vlastnosti map
// ------------------------------------------------------------
&nbsp;
&nbsp;
&nbsp;
// ziskani typu sekvence
function sequenceType(sequence) {
    return mori.isList(sequence)   ? "list" :
           mori.isVector(sequence) ? "vector" :
           mori.isMap(sequence)    ? "map" :
           mori.isSet(sequence)    ? "set" :
           mori.isSeq(sequence)    ? "sequence" :
           "unknown";
}
&nbsp;
&nbsp;
&nbsp;
// vypis informaci o vybrane sekvenci
function printSequenceInfo(declaration) {
    var sequence = eval(declaration);
    var type = sequenceType(sequence);
    console.log("---------------------------------");
    console.log(declaration);
    console.log("type:    " + type);
    console.log("length:  " + mori.count(sequence));
    console.log("content: " + sequence);
}
&nbsp;
var map1 = mori.hashMap  ("k9", 9, "k8", 8, "k7", 7, "k6", 6, "k5", 5, "k4", 4, "k3", 3, "k2", 2, "k1", 1);
var map2 = mori.sortedMap("k9", 9, "k8", 8, "k7", 7, "k6", 6, "k5", 5, "k4", 4, "k3", 3, "k2", 2, "k1", 1);
var map3 = mori.hashMap("first", 1, "second", 2, "third", 3);
&nbsp;
printSequenceInfo("map1");
printSequenceInfo("map2");
printSequenceInfo("mori.keys(map1)");
printSequenceInfo("mori.keys(map2)");
printSequenceInfo("mori.vals(map1)");
printSequenceInfo("mori.vals(map2)");
printSequenceInfo("map3");
printSequenceInfo("mori.merge(map1, map3)");
&nbsp;
&nbsp;
&nbsp;
// ------------------------------------------------------------
// Finito
// ------------------------------------------------------------
</pre>

<p><strong>mori_11.html</strong></p>

<pre>
&lt;!doctype html&gt;
&lt;html&gt;
    &lt;head&gt;
        &lt;title&gt;Mori tests #11&lt;/title&gt;
        &lt;meta charset="utf-8"&gt;
        &lt;script src="mori.js"&gt;&lt;/script&gt;
        &lt;script src="mori_11.js"&gt;&lt;/script&gt;
    &lt;/head&gt;
    &lt;body&gt;
        &lt;h1&gt;Mori tests #11&lt;/h1&gt;
    &lt;/body&gt;
&lt;/html&gt;
</pre>

<p><strong>mori_12.js</strong></p>

<pre>
// ------------------------------------------------------------
// Knihovna Mori: demonstracni priklad cislo 12
//
// Operace s mapami
// ------------------------------------------------------------
&nbsp;
&nbsp;
&nbsp;
// ziskani typu sekvence
function sequenceType(sequence) {
    return mori.isList(sequence)   ? "list" :
           mori.isVector(sequence) ? "vector" :
           mori.isMap(sequence)    ? "map" :
           mori.isSet(sequence)    ? "set" :
           mori.isSeq(sequence)    ? "sequence" :
           "unknown";
}
&nbsp;
&nbsp;
&nbsp;
// vypis informaci o vybrane sekvenci
function printSequenceInfo(declaration) {
    var sequence = eval(declaration);
    var type = sequenceType(sequence);
    console.log("---------------------------------");
    console.log(declaration);
    console.log("type:    " + type);
    console.log("length:  " + mori.count(sequence));
    console.log("content: " + sequence);
}
&nbsp;
function factorial(n) {
    var fac = 1;
    for (var i = 2; i &lt;= n; i++) {
        fac = fac * i;
    }
    return fac;
}
&nbsp;
var seq1 = mori.range(1,11);
var seq2 = mori.map(factorial, seq1);
&nbsp;
var map1 = mori.zipmap(seq1, seq2);
&nbsp;
printSequenceInfo("seq1");
printSequenceInfo("seq2");
printSequenceInfo("mori.zipmap(seq1, seq2);");
&nbsp;
&nbsp;
var map2 = mori.sortedMap(1, "first", 2, "second", 3, "third");
printSequenceInfo("map2");
printSequenceInfo("mori.assoc(map2, 4, 'fourth', 5, 'fifth')");
printSequenceInfo("mori.dissoc(map2, 1, 5)");
&nbsp;
&nbsp;
&nbsp;
// ------------------------------------------------------------
// Finito
// ------------------------------------------------------------
</pre>

<p><strong>mori_12.html</strong></p>

<pre>
&lt;!doctype html&gt;
&lt;html&gt;
    &lt;head&gt;
        &lt;title&gt;Mori tests #12&lt;/title&gt;
        &lt;meta charset="utf-8"&gt;
        &lt;script src="mori.js"&gt;&lt;/script&gt;
        &lt;script src="mori_12.js"&gt;&lt;/script&gt;
    &lt;/head&gt;
    &lt;body&gt;
        &lt;h1&gt;Mori tests #12&lt;/h1&gt;
    &lt;/body&gt;
&lt;/html&gt;
</pre>



<p><a name="k06"></a></p>
<h2 id="k06">6. Obsah dalšího článku &ndash; porovnání Mori s&nbsp;knihovnou Immutable.js</h2>

<p>Knihovna <i>Mori</i> ve skutečnosti (a vlastně i podle očekávání) není
jedinou knihovnou, která do programovacího jazyka JavaScript přidává podporu
pro perzistentní strukturované datové typy. V&nbsp;souvislosti s&nbsp;rostoucí
oblibou funkcionálního programování (resp.&nbsp;přesněji řečeno funkcionálních
technik &bdquo;naroubovaných&ldquo; do mainstreamových programovacích jazyků)
se objevily i další knihovny mající podobný cíl. Druhou známou knihovnou je
JavaScriptová knihovna nazvaná <i>Immutable.js</i>. Shodnými rysy ale i mnohými
rozdíly mezi <i>Mori</i> a <i>Immutable.js</i> se budeme zabývat
v&nbsp;navazujícím článku.</p>



<p><a name="k07"></a></p>
<h2 id="k07">7. Repositář se zdrojovými kódy všech dnešních demonstračních příkladů</h2>

<p>Demonstrační příklady, na nichž jsme si ukazovali vlastnosti knihovny
<i>Mori</i>, byly uloženy do Git repositáře dostupného na adrese <a
href="https://github.com/tisnik/presentations">https://github.com/tisnik/presentations</a>.
V&nbsp;tabulce zobrazené pod tímto odstavcem naleznete na zdrojové kódy těchto
příkladů přímé odkazy:</p>

<table>
<tr><th> #</th><th>Zdrojový soubor</th><th>Odkaz</th></tr>
<tr><td> 1</td><td>mori_05.js</td><td><a href="https://github.com/tisnik/presentations/blob/master/mori/mori_05.js">https://github.com/tisnik/presentations/blob/master/mori/mori_05.js</a></td></tr>
<tr><td> 2</td><td>mori_05.html</td><td><a href="https://github.com/tisnik/presentations/blob/master/mori/mori_05.html">https://github.com/tisnik/presentations/blob/master/mori/mori_05.html</a></td></tr>
<tr><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td></tr>
<tr><td> 3</td><td>mori_06.js</td><td><a href="https://github.com/tisnik/presentations/blob/master/mori/mori_06.js">https://github.com/tisnik/presentations/blob/master/mori/mori_06.js</a></td></tr>
<tr><td> 4</td><td>mori_06.html</td><td><a href="https://github.com/tisnik/presentations/blob/master/mori/mori_06.html">https://github.com/tisnik/presentations/blob/master/mori/mori_06.html</a></td></tr>
<tr><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td></tr>
<tr><td> 5</td><td>mori_07.js</td><td><a href="https://github.com/tisnik/presentations/blob/master/mori/mori_07.js">https://github.com/tisnik/presentations/blob/master/mori/mori_07.js</a></td></tr>
<tr><td> 6</td><td>mori_07.html</td><td><a href="https://github.com/tisnik/presentations/blob/master/mori/mori_07.html">https://github.com/tisnik/presentations/blob/master/mori/mori_07.html</a></td></tr>
<tr><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td></tr>
<tr><td> 7</td><td>mori_08.js</td><td><a href="https://github.com/tisnik/presentations/blob/master/mori/mori_08.js">https://github.com/tisnik/presentations/blob/master/mori/mori_08.js</a></td></tr>
<tr><td> 8</td><td>mori_08.html</td><td><a href="https://github.com/tisnik/presentations/blob/master/mori/mori_08.html">https://github.com/tisnik/presentations/blob/master/mori/mori_08.html</a></td></tr>
<tr><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td></tr>
<tr><td> 9</td><td>mori_09.js</td><td><a href="https://github.com/tisnik/presentations/blob/master/mori/mori_09.js">https://github.com/tisnik/presentations/blob/master/mori/mori_09.js</a></td></tr>
<tr><td>10</td><td>mori_09.html</td><td><a href="https://github.com/tisnik/presentations/blob/master/mori/mori_09.html">https://github.com/tisnik/presentations/blob/master/mori/mori_09.html</a></td></tr>
<tr><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td></tr>
<tr><td>11</td><td>mori_10.js</td><td><a href="https://github.com/tisnik/presentations/blob/master/mori/mori_10.js">https://github.com/tisnik/presentations/blob/master/mori/mori_10.js</a></td></tr>
<tr><td>12</td><td>mori_10.html</td><td><a href="https://github.com/tisnik/presentations/blob/master/mori/mori_10.html">https://github.com/tisnik/presentations/blob/master/mori/mori_10.html</a></td></tr>
<tr><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td></tr>
<tr><td>13</td><td>mori_11.js</td><td><a href="https://github.com/tisnik/presentations/blob/master/mori/mori_11.js">https://github.com/tisnik/presentations/blob/master/mori/mori_11.js</a></td></tr>
<tr><td>14</td><td>mori_11.html</td><td><a href="https://github.com/tisnik/presentations/blob/master/mori/mori_11.html">https://github.com/tisnik/presentations/blob/master/mori/mori_11.html</a></td></tr>
<tr><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td></tr>
<tr><td>15</td><td>mori_12.js</td><td><a href="https://github.com/tisnik/presentations/blob/master/mori/mori_12.js">https://github.com/tisnik/presentations/blob/master/mori/mori_12.js</a></td></tr>
<tr><td>16</td><td>mori_12.html</td><td><a href="https://github.com/tisnik/presentations/blob/master/mori/mori_12.html">https://github.com/tisnik/presentations/blob/master/mori/mori_12.html</a></td></tr>
</table>



<p><a name="k08"></a></p>
<h2 id="k08">8. Odkazy na Internetu</h2>

<ol>

<li>Mori na GitHubu<br />
<a href="https://github.com/swannodette/mori">https://github.com/swannodette/mori</a>
</li>

<li>Mori: popis API (dokumentace)<br />
<a href="http://swannodette.github.io/mori/">http://swannodette.github.io/mori/</a>
</li>

<li>Mori: Benchmarking<br />
<a href="https://github.com/swannodette/mori/wiki/Benchmarking">https://github.com/swannodette/mori/wiki/Benchmarking</a>
</li>

<li>Functional data structures in JavaScript with Mori<br />
<a href="http://sitr.us/2013/11/04/functional-data-structures.html">http://sitr.us/2013/11/04/functional-data-structures.html</a>
</li>

<li>Immutable.js<br />
<a href="https://facebook.github.io/immutable-js/">https://facebook.github.io/immutable-js/</a>
</li>

<li>Persistent data structure<br />
<a href="https://en.wikipedia.org/wiki/Persistent_data_structure">https://en.wikipedia.org/wiki/Persistent_data_structure</a>
</li>

<li>Understanding Clojure's Persistent Vectors, pt. 1<br />
<a href="http://hypirion.com/musings/understanding-persistent-vector-pt-1">http://hypirion.com/musings/understanding-persistent-vector-pt-1</a>
</li>

<li>Hash array mapped trie (Wikipedia)<br />
<a href="https://en.wikipedia.org/wiki/Hash_array_mapped_trie">https://en.wikipedia.org/wiki/Hash_array_mapped_trie</a>
</li>

<li>Java theory and practice: To mutate or not to mutate?<br />
<a href="http://www.ibm.com/developerworks/java/library/j-jtp02183/index.html">http://www.ibm.com/developerworks/java/library/j-jtp02183/index.html</a>
</li>

<li>Efficient persistent (immutable) data structures<br />
<a href="https://persistent.codeplex.com/">https://persistent.codeplex.com/</a>
</li>

<li>Netscape Enterprise Server (Wikipedia)<br />
<a href="https://en.wikipedia.org/wiki/Netscape_Enterprise_Server">https://en.wikipedia.org/wiki/Netscape_Enterprise_Server</a>
</li>

<li>SSJS Reference Guide (Server-Side JavaScript)<br />
<a href="http://docs.oracle.com/cd/E19957-01/816-6410-10/816-6410-10.pdf">http://docs.oracle.com/cd/E19957-01/816-6410-10/816-6410-10.pdf</a>
</li>

<li>Atom: moderní textový editor<br />
<a href="http://www.root.cz/clanky/atom-moderni-textovy-editor/">http://www.root.cz/clanky/atom-moderni-textovy-editor/</a>
</li>

<li>Atom: moderní textový editor (dokončení)<br />
<a href="http://www.root.cz/clanky/atom-moderni-textovy-editor-dokonceni/">http://www.root.cz/clanky/atom-moderni-textovy-editor-dokonceni/</a>
</li>

<li>Propojení světa LISPu se světem JavaScriptu s využitím transpřekladače Wisp<br />
<a href="http://www.root.cz/clanky/propojeni-sveta-lispu-se-svetem-javascriptu-s-vyuzitim-transprekladace-wisp/">http://www.root.cz/clanky/propojeni-sveta-lispu-se-svetem-javascriptu-s-vyuzitim-transprekladace-wisp/</a>
</li>

<li>Propojení světa LISPu se světem JavaScriptu s využitím transpřekladače Wisp (2.část)<br />
<a href="http://www.root.cz/clanky/propojeni-sveta-lispu-se-svetem-javascriptu-s-vyuzitim-transprekladace-wisp-2-cast/">http://www.root.cz/clanky/propojeni-sveta-lispu-se-svetem-javascriptu-s-vyuzitim-transprekladace-wisp-2-cast/</a>
</li>

<li>Wisp na GitHubu<br />
<a href="https://github.com/Gozala/wisp">https://github.com/Gozala/wisp</a>
</li>

<li>Wisp playground<br />
<a href="http://www.jeditoolkit.com/try-wisp/">http://www.jeditoolkit.com/try-wisp/</a>
</li>

<li>REPL v prohlížeči<br />
<a href="http://www.jeditoolkit.com/interactivate-wisp/">http://www.jeditoolkit.com/interactivate-wisp/</a>
</li>

<li>Minification (programming)<br />
<a href="https://en.wikipedia.org/wiki/Minification_(programming)">https://en.wikipedia.org/wiki/Minification_(programming)</a>
</li>

<li>Clojure Macro Tutorial (Part I, Getting the Compiler to Write Your Code For You)<br />
<a href="http://www.learningclojure.com/2010/09/clojure-macro-tutorial-part-i-getting.html">http://www.learningclojure.com/2010/09/clojure-macro-tutorial-part-i-getting.html</a>
</li>

<li>Clojure Macro Tutorial (Part II: The Compiler Strikes Back)<br />
<a href="http://www.learningclojure.com/2010/09/clojure-macro-tutorial-part-ii-compiler.html">http://www.learningclojure.com/2010/09/clojure-macro-tutorial-part-ii-compiler.html</a>
</li>

<li>Clojure Macro Tutorial (Part III: Syntax Quote)<br />
<a href="http://www.learningclojure.com/2010/09/clojure-macro-tutorial-part-ii-syntax.html">http://www.learningclojure.com/2010/09/clojure-macro-tutorial-part-ii-syntax.html</a>
</li>

<li>Tech behind Tech: Clojure Macros Simplified<br />
<a href="http://techbehindtech.com/2010/09/28/clojure-macros-simplified/">http://techbehindtech.com/2010/09/28/clojure-macros-simplified/</a>
</li>

<li>Fatvat - Exploring functional programming: Clojure Macros<br />
<a href="http://www.fatvat.co.uk/2009/02/clojure-macros.html">http://www.fatvat.co.uk/2009/02/clojure-macros.html</a>
</li>

<li>Eulerovo číslo<br />
<a href="http://cs.wikipedia.org/wiki/Eulerovo_??slo">http://cs.wikipedia.org/wiki/Eulerovo_??slo</a>
</li>

<li>List comprehension<br />
<a href="http://en.wikipedia.org/wiki/List_comprehension">http://en.wikipedia.org/wiki/List_comprehension</a>
</li>

<li>List Comprehensions in Clojure<br />
<a href="http://asymmetrical-view.com/2008/11/18/list-comprehensions-in-clojure.html">http://asymmetrical-view.com/2008/11/18/list-comprehensions-in-clojure.html</a>
</li>

<li>Clojure Programming Concepts: List Comprehension<br />
<a href="http://en.wikibooks.org/wiki/Clojure_Programming/Concepts#List_Comprehension">http://en.wikibooks.org/wiki/Clojure_Programming/Concepts#List_Comprehension</a>
</li>

<li>Clojure core API: for macro<br />
<a href="http://clojure.github.com/clojure/clojure.core-api.html#clojure.core/for">http://clojure.github.com/clojure/clojure.core-api.html#clojure.core/for</a>
</li>

<li>cirrus machina - The Clojure for macro<br />
<a href="http://www.cirrusmachina.com/blog/comment/the-clojure-for-macro/">http://www.cirrusmachina.com/blog/comment/the-clojure-for-macro/</a>
</li>

<li>Clojure.org: Clojure home page<br />
<a href="http://clojure.org/downloads">http://clojure.org/downloads</a>
</li>

<li>Clojure.org: Vars and the Global Environment<br />
<a href="http://clojure.org/Vars">http://clojure.org/Vars</a>
</li>

<li>Clojure.org: Refs and Transactions<br />
<a href="http://clojure.org/Refs">http://clojure.org/Refs</a>
</li>

<li>Clojure.org: Atoms<br />
<a href="http://clojure.org/Atoms">http://clojure.org/Atoms</a>
</li>

<li>Clojure.org: Agents as Asynchronous Actions<br />
<a href="http://clojure.org/agents">http://clojure.org/agents</a>
</li>

<li>A Couple of Clojure Agent Examples<br />
<a href="http://lethain.com/a-couple-of-clojure-agent-examples/">http://lethain.com/a-couple-of-clojure-agent-examples/</a>
</li>

<li>Clojure - Functional Programming for the JVM<br />
<a href="http://java.ociweb.com/mark/clojure/article.html">http://java.ociweb.com/mark/clojure/article.html</a>
</li>

<li>Clojure quick reference<br />
<a href="http://faustus.webatu.com/clj-quick-ref.html">http://faustus.webatu.com/clj-quick-ref.html</a>
</li>

<li>4Clojure<br />
<a href="http://www.4clojure.com/">http://www.4clojure.com/</a>
</li>

<li>ClojureDoc<br />
<a href="http://clojuredocs.org/">http://clojuredocs.org/</a>
</li>

<li>Clojure (Wikipedia EN)<br />
<a href="http://en.wikipedia.org/wiki/Clojure">http://en.wikipedia.org/wiki/Clojure</a>
</li>

<li>Clojure (Wikipedia CS)<br />
<a href="http://cs.wikipedia.org/wiki/Clojure">http://cs.wikipedia.org/wiki/Clojure</a>
</li>

<li>Riastradh's Lisp Style Rules<br />
<a href="http://mumble.net/~campbell/scheme/style.txt">http://mumble.net/~campbell/scheme/style.txt</a>
</li>

<li>Dynamic Languages Strike Back<br />
<a href="http://steve-yegge.blogspot.cz/2008/05/dynamic-languages-strike-back.html">http://steve-yegge.blogspot.cz/2008/05/dynamic-languages-strike-back.html</a>
</li>

<li>Scripting: Higher Level Programming for the 21st Century<br />
<a href="http://www.tcl.tk/doc/scripting.html">http://www.tcl.tk/doc/scripting.html</a>
</li>

<li>Java Virtual Machine Support for Non-Java Languages<br />
<a href="http://docs.oracle.com/javase/7/docs/technotes/guides/vm/multiple-language-support.html">http://docs.oracle.com/javase/7/docs/technotes/guides/vm/multiple-language-support.html</a>
</li>

<li>The Lua VM, on the Web<br />
<a href="https://kripken.github.io/lua.vm.js/lua.vm.js.html">https://kripken.github.io/lua.vm.js/lua.vm.js.html</a>
</li>

<li>Lua.vm.js REPL<br />
<a href="https://kripken.github.io/lua.vm.js/repl.html">https://kripken.github.io/lua.vm.js/repl.html</a>
</li>

<li>lua2js<br />
<a href="https://www.npmjs.com/package/lua2js">https://www.npmjs.com/package/lua2js</a>
</li>

<li>lua2js na GitHubu<br />
<a href="https://github.com/basicer/lua2js-dist">https://github.com/basicer/lua2js-dist</a>
</li>

<li>Seriál o programovacím jazyku Lua<br />
<a href="http://www.root.cz/serialy/programovaci-jazyk-lua/">http://www.root.cz/serialy/programovaci-jazyk-lua/</a>
</li>

<li>Source-to-source compiler<br />
<a href="https://en.wikipedia.org/wiki/Source-to-source_compiler">https://en.wikipedia.org/wiki/Source-to-source_compiler</a>
</li>

<li>JavaScript is Assembly Language for the Web: Sematic Markup is Dead! Clean vs. Machine-coded HTML<br />
<a href="http://www.hanselman.com/blog/JavaScriptIsAssemblyLanguageForTheWebSematicMarkupIsDeadCleanVsMachinecodedHTML.aspx">http://www.hanselman.com/blog/JavaScriptIsAssemblyLanguageForTheWebSematicMarkupIsDeadCleanVsMachinecodedHTML.aspx</a>
</li>

<li>JavaScript is Web Assembly Language and that's OK.<br />
<a href="http://www.hanselman.com/blog/JavaScriptIsWebAssemblyLanguageAndThatsOK.aspx">http://www.hanselman.com/blog/JavaScriptIsWebAssemblyLanguageAndThatsOK.aspx</a>
</li>

<li>Dart<br />
<a href="https://www.dartlang.org/">https://www.dartlang.org/</a>
</li>

<li>CoffeeScript<br />
<a href="http://coffeescript.org/">http://coffeescript.org/</a>
</li>

<li>TypeScript<br />
<a href="http://www.typescriptlang.org/">http://www.typescriptlang.org/</a>
</li>

<li>Lua (programming language)<br />
<a href="http://en.wikipedia.org/wiki/Lua_(programming_language)">http://en.wikipedia.org/wiki/Lua_(programming_language)</a>
</li>

<li>Static single assignment form (SSA)<br />
<a href="http://en.wikipedia.org/wiki/Static_single_assignment_form">http://en.wikipedia.org/wiki/Static_single_assignment_form</a>
</li>

<li>LuaJIT 2.0 SSA IR
<a href="http://wiki.luajit.org/SSA-IR-2.0">http://wiki.luajit.org/SSA-IR-2.0</a>
</li>

<li>The LuaJIT Project<br />
<a href="http://luajit.org/index.html">http://luajit.org/index.html</a>
</li>

<li>LuaJIT FAQ<br />
<a href="http://luajit.org/faq.html">http://luajit.org/faq.html</a>
</li>

<li>LuaJIT Performance Comparison<br />
<a href="http://luajit.org/performance.html">http://luajit.org/performance.html</a>
</li>

<li>LuaJIT 2.0 intellectual property disclosure and research opportunities<br />
<a href="http://article.gmane.org/gmane.comp.lang.lua.general/58908">http://article.gmane.org/gmane.comp.lang.lua.general/58908</a>
</li>

<li>LuaJIT Wiki<br />
<a href="http://wiki.luajit.org/Home">http://wiki.luajit.org/Home</a>
</li>

<li>LuaJIT 2.0 Bytecode Instructions<br />
<a href="http://wiki.luajit.org/Bytecode-2.0">http://wiki.luajit.org/Bytecode-2.0</a>
</li>

<li>Programming in Lua (first edition)<br />
<a href="http://www.lua.org/pil/contents.html">http://www.lua.org/pil/contents.html</a>
</li>

<li>Lua 5.2 sources<br />
<a href="http://www.lua.org/source/5.2/">http://www.lua.org/source/5.2/</a>
</li>

<li>Tcl Plugin Version 3<br />
<a href="http://www.tcl.tk/software/plugin/">http://www.tcl.tk/software/plugin/</a>
</li>

<li>JavaScript: The Web Assembly Language?<br />
<a href="http://www.informit.com/articles/article.aspx?p=1856657">http://www.informit.com/articles/article.aspx?p=1856657</a>
</li>

<li>asm.js<br />
<a href="http://asmjs.org/">http://asmjs.org/</a>
</li>

<li>List of languages that compile to JS<br />
<a href="https://github.com/jashkenas/coffeescript/wiki/List-of-languages-that-compile-to-JS">https://github.com/jashkenas/coffeescript/wiki/List-of-languages-that-compile-to-JS</a>
</li>

<li>REPL<br />
<a href="https://en.wikipedia.org/wiki/Read%E2%80%93eval%E2%80%93print_loop">https://en.wikipedia.org/wiki/Read%E2%80%93eval%E2%80%93print_loop</a>
</li>

<li>The LLVM Compiler Infrastructure<br />
<a href="http://llvm.org/ProjectsWithLLVM/">http://llvm.org/ProjectsWithLLVM/</a>
</li>

<li>clang: a C language family frontend for LLVM<br />
<a href="http://clang.llvm.org/">http://clang.llvm.org/</a>
</li>

<li>emscripten<br />
<a href="http://kripken.github.io/emscripten-site/">http://kripken.github.io/emscripten-site/</a>
</li>

<li>LLVM Backend ("Fastcomp")<br />
<a href="http://kripken.github.io/emscripten-site/docs/building_from_source/LLVM-Backend.html#llvm-backend">http://kripken.github.io/emscripten-site/docs/building_from_source/LLVM-Backend.html#llvm-backend</a>
</li>

<li>Emscripten - Fastcomp na GitHubu<br />
<a href="https://github.com/kripken/emscripten-fastcomp">https://github.com/kripken/emscripten-fastcomp</a>
</li>

<li>Clang (pro Emscripten) na GitHubu<br />
<a href="https://github.com/kripken/emscripten-fastcomp-clang">https://github.com/kripken/emscripten-fastcomp-clang</a>
</li>

<li>Why not use JavaScript?<br />
<a href="https://ckknight.github.io/gorillascript/">https://ckknight.github.io/gorillascript/</a>
</li>

</ol>



<p></p><p></p>
<p><small>Autor: <a href="http://www.fit.vutbr.cz/~tisnovpa">Pavel Tišnovský</a> &nbsp; 2016</small></p>
</body>
</html>

