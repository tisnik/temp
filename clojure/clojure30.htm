<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
        "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html>
<head>
<title>Asynchronní programování v Clojure s využitím knihovny core.async</title>
<meta name="Author" content="Pavel Tisnovsky" />
<meta name="Generator" content="vim" />
<meta http-equiv="content-type" content="text/html; charset=utf-8" />
<style type="text/css">
         body {color:#000000; background:#ffffff;}
         h1  {font-family: arial, helvetica, sans-serif; color:#ffffff; background-color:#c00000; text-align:center; padding-left:1em}
         h2  {font-family: arial, helvetica, sans-serif; color:#ffffff; background-color:#0000c0; padding-left:1em; text-align:left}
         h3  {font-family: arial, helvetica, sans-serif; color:#000000; background-color:#c0c0c0; padding-left:1em; text-align:left}
         h4  {font-family: arial, helvetica, sans-serif; color:#000000; background-color:#e0e0e0; padding-left:1em; text-align:left}
         a   {font-family: arial, helvetica, sans-serif;}
         li  {font-family: arial, helvetica, sans-serif; color:#000000; text-align:justify; width:450px;}
         ol  {font-family: arial, helvetica, sans-serif; color:#000000; text-align:justify; width:450px;}
         ul  {font-family: arial, helvetica, sans-serif; color:#000000; text-align:justify; width:450px;}
         p   {font-family: arial, helvetica, sans-serif; color:#000000; text-align:justify;}
         pre {background:#e0e0e0}
</style>
</head>

<body>

<h1>Asynchronní programování v Clojure s využitím knihovny core.async</h1>

<h3>Pavel Tišnovský</h3>

<p></p>

<h1>Úvodník</h1>

<p>V komunitě vývojářů používajících programovací jazyk Clojure se velké popularitě těší knihovna core.async, která do jazyka přidává podporu pro asynchronní kanály známé například z programovacího jazyka Go. Dnes si popíšeme základní možnosti této knihovny.</p>



<h2>Obsah</h2>

<p><a href="#k01">1. Asynchronní programování v&nbsp;Clojure s&nbsp;využitím knihovny core.async</a></p>
<p><a href="#k02">2. Princip, na němž je postaveno <strong>core.async</strong>: CSP</a></p>
<p><a href="#k03">3. Cíle a prostředky použité v&nbsp;<strong>core.async</strong></a></p>
<p><a href="#k04">4. Kdy je vhodné použít <strong>core.async</strong>?</a></p>
<p><a href="#k05">5. Go bloky a základní operace s&nbsp;kanály</a></p>
<p><a href="#k06">6. První demonstrační příklad: producent a konzument</a></p>
<p><a href="#k07">7. Druhý demonstrační příklad: modelování času pomocí <strong>timeout</strong></a></p>
<p><a href="#k08">8. Třetí demonstrační příklad: jednoduchý logger</a></p>
<p><a href="#k09">9. Čtvrtý demonstrační příklad: větší množství producentů</a></p>
<p><a href="#k10">10. Použití funkce <strong>alts!</strong> při obsluze většího množství kanálů</a></p>
<p><a href="#k11">11. Pátý demonstrační příklad: použití funkce <strong>alts!</strong></a></p>
<p><a href="#k12">12. Repositář s&nbsp;demonstračními příklady</a></p>
<p><a href="#k13">13. Odkazy na předchozí části tohoto seriálu</a></p>
<p><a href="#k14">14. Odkazy na Internetu</a></p>



<p><a name="k01"></a></p>
<h2 id="k01">1. Asynchronní programování v&nbsp;Clojure s&nbsp;využitím knihovny core.async</h2>

<p>Knihovny či nové jazykové konstrukce umožňující používání kanálů (či front)
pro asynchronní komunikaci mezi různými částmi vyvíjených aplikací, se
v&nbsp;posledních několika letech těší poměrně velké popularitě. Ta je
způsobena dvěma faktory. První důvod spočívá ve snaze o zjednodušení návrhu (či
porozumění) vyvíjené aplikace, zejména ve chvíli, kdy se v&nbsp;rámci jednoho
programu předávají data (resp.&nbsp;objekty) mezi částmi, jejichž funkce může
být dobře izolována od částí ostatních. Druhý důvod je poněkud prozaičtější
&ndash; v&nbsp;některých situacích je nutné dosáhnout zvýšení efektivity
aplikace (například zvýšit počet odpovědí, které může server vygenerovat za
určitou časovou jednotku) a přitom není možné či vhodné využívat řešení
založené na použití většího množství vláken spravovaných systémem. Naprosto
typickým příkladem jsou virtuální stroje JavaScriptu, které povětšinou umožňují
běh aplikace v&nbsp;jediném vláknu (což je ovšem s&nbsp;ohledem na
&bdquo;kvalitu&ldquo; některých programových kódů spíše výhodou...).</p>

<p>Některé programovací jazyky, zejména pak jazyk <i>Go</i>, obsahují
prostředky sloužící pro zajištění asynchronní komunikace přímo v&nbsp;syntaxi
(a samozřejmě též v&nbsp;sémantice) jazyka. Konkrétně v&nbsp;případě jazyka
<i>Go</i> se jedná o takzvané &bdquo;gorutiny&ldquo; představované klíčovým
slovem <strong>go</strong> a taktéž o operace sloužící pro zápis či čtení dat
z&nbsp;kanálů, které jsou představovány operátorem <strong>&lt;-</strong> (ten
má dva významy v&nbsp;závislosti na tom, zda je před operátorem uveden
identifikátor představující kanál či nikoli). V&nbsp;programovacím jazyku
<i>Clojure</i> však naproti tomu nebylo nutné zavádět speciální syntaxi a
vlastně ani nebylo nutné zasahovat do překladače. Celá knihovna
<strong>core.async</strong> je založena na několika běžných funkcích a hlavně
pak na makrech, které manipulací s&nbsp;předaným programovým kódem dokážou
z&nbsp;běžného příkazového bloku vytvořit blok zpracovávaný asynchronně (opět
se zde ukazuje přednost homoikonických jazyků). Použít ji lze dokonce i
v&nbsp;<i>ClojureScriptu</i>, tedy v&nbsp;implementaci jazyka <i>Clojure</i>
postavené nad &bdquo;jednovláknovým&ldquo; JavaScriptem.</p>



<p><a name="k02"></a></p>
<h2 id="k02">2. Princip, na němž je postaveno <strong>core.async</strong>: CSP</h2>

<p>Použití asynchronních kanálů a z&nbsp;nich odvozených asynchronních
vstupně-výstupních operací (&bdquo;async I/O&ldquo;), se mezi širší
programátorskou komunitu rozšířilo pravděpodobně až s&nbsp;vývojem systému
<strong>node.js</strong>. Ve skutečnosti je však realizovaný princip mnohem
starší, protože sahá až do šedesátých a sedmdesátých let minulého století, kdy
se postupně vyvíjely metody umožňující lepší využití strojového času tehdejších
počítačů (lepším využitím se zde nutně nemyslí škálovatelnost!). Za strojový
čas se tehdy samozřejmě platilo, což přeneseně platí i dnes. Poznatky
vypracovávané v&nbsp;šedesátých a sedmdesátých letech byly formalizovány a
následně shrnuty do teorie popsané v&nbsp;knize nazvané <i>Communicating
Sequential Processes</i>, jejímž autorem je <i>C.A.R Hoare</i>. Kniha byla
vydána v&nbsp;roce 1978 a kvůli její popularitě a známosti se mnohdy setkáme
pouze se zkratkou <i>CSP</i>.</p>



<p><a name="k03"></a></p>
<h2 id="k03">3. Cíle a prostředky použité v&nbsp;<strong>core.async</strong></h2>

<p>Hlavním cílem knihovny <strong>core.async</strong> je implementace
technologie umožňující, aby různá nezávislá vlákna mezi sebou mohla komunikovat
s&nbsp;využitím takzvaných kanálů (<i>channels</i>). Použití kanálů může vést
ke zjednodušení aplikace, v&nbsp;níž komunikuje mnoho objektů. Typicky je
umožněno snadné rozdělení výpočtů (či jak se dnes říká business logiky) od
zobrazení výsledků, oddělení grafického uživatelského rozhraní od spouštění
výpočtů atd., což je zajímavá alternativa k&nbsp;dnes převládající implementaci
aplikace založené na přímém použití callback funkcí. Vlákna přitom mohou být
vytvořena na úrovni systému, a to se všemi klady a zápory, které toto řešení
přináší; či se může jednat o implementaci pseudovláken, s&nbsp;níž se setkáme
zejména v&nbsp;<i>ClojureScriptu</i>. Knihovna <strong>core.async</strong> se
snaží o využití svého thread poolu, tj.&nbsp;zásobníku vláken, které lze po
doběhnutí určité operace použít znovu pro provedení jiné operace, což vede
k&nbsp;efektivnějšímu využití systémových prostředků (s&nbsp;takto
nízkoúrovňovými operacemi se však při použití knihovny většinou nesetkáte).</p>

<p>Knihovna <strong>core.async</strong> je založena na dvou základních
konstrukcích. Jedná se o již zmíněné kanály, které lze v&nbsp;některých
případech nakonfigurovat takovým způsobem, že fungují jako fronty či buffery
(nejjednodušší kanál vlastnosti fronty nemá, proto jsou všechny operace nad ním
blokující). Pro operaci s&nbsp;kanály je vytvořeno několik funkcí: vytvoření
kanálu, zavření kanálu, zápis dat, čtení dat, čtení dat z&nbsp;libovolného
kanálu, čtení dat s&nbsp;určením priority jednotlivých kanálů atd. Kanál lze
použít i jako takzvané synchronizační primitivum a jak uvidíme dále, některé
speciální kanály lze použít například i pro pouhé pozastavení výpočtu. Druhou
konstrukcí jsou takzvané <i>go bloky</i>, které jsou interně implementovány <a
href="https://github.com/clojure/core.async/blob/master/src/main/clojure/clojure/core/async.clj">dosti
složitým makrem</a>, které transformuje uživatelský kód do podoby stavového
automatu.</p>



<p><a name="k04"></a></p>
<h2 id="k04">4. Kdy je vhodné použít <strong>core.async</strong>?</h2>

<p>Podobně, jako je tomu v&nbsp;případě dalších technologií, i u knihovny
<strong>core.async</strong> může nastat situace, že její funkce budou
v&nbsp;aplikacích nadužívány, minimálně do doby, než opadne prvotní nadšení
z&nbsp;nové (velmi důležité) knihovny. Obecně platí, že nejvíce budou
z&nbsp;výhod <strong>core.async</strong> těžit ty aplikace, v&nbsp;nichž by se
běžně vytvářelo velké množství vláken, přičemž každé vlákno by mělo za úkol
zpracovat data dodávaná z&nbsp;jiné části systému. Tato vlákna by tedy
odpovídala takzvaným &bdquo;workerům&ldquo;. V&nbsp;případě, že každý worker
musí čekat na data či například na dokončení nějaké I/O operace, znamená to, že
jeho vlákno není efektivně vytíženo. Může to vypadat zhruba takto:</p>

<pre>
Vlákno 1........worker1........worker1........worker1........worker1
Vlákno 2........worker2........worker2........worker2........worker2
Vlákno 3........worker3........worker3........worker3........worker3
Vlákno 4........worker4........worker4........worker4........worker4
</pre>

<p>Použitím technologií dostupných v&nbsp;knihovně <strong>core.async</strong>
je možné dosáhnout lepšího využití vláken, například takto:</p>

<pre>
Vlákno 1.worker1.worker4.worker1.worker3...worker1.worker3.worker2.worker4
Vlákno 2..worker2.worker3..worker1...worker4.worker2......worker1.worker3
</pre>



<p><a name="k05"></a></p>
<h2 id="k05">5. Go bloky a základní operace s&nbsp;kanály</h2>

<p>Pro předvedení základních možností knihovny <strong>core.async</strong> nám
postačuje použít funkci <strong>chan</strong>, která vytvoří nový kanál,
dvojici operací nazvaných &bdquo;put&ldquo; a &bdquo;take&ldquo; a již
několikrát zmíněné <i>go bloky</i> představované makrem nazvaným
<strong>go</strong>. Operace typu &bdquo;put&ldquo;, tj.&nbsp;vložení dat do
kanálu, se zapisuje znaky &gt;!, operace typu &bdquo;take&ldquo;
(přečtení/příjem dat z&nbsp;kanálu) se zapisuje pomocí znaků &lt;!. Obě operace
musí proběhnout v&nbsp;bloku <strong>go</strong>, což je v&nbsp;makru
kontrolováno. V&nbsp;případě použití běžného kanálu bez bufferu je operace
&bdquo;put&ldquo; blokující (čeká se, až někdo jiný data z&nbsp;kanálu přijme)
a operace &bdquo;take&ldquo; je blokující ve chvíli, kdy je kanál prázdný (čeká
se, až někdo jiný data do kanálu zapíše). Podívejme se na typický příklad typu
producent&ndash;konzument:</p>

<pre>
+-----------+                              +-----------+
| producent |           +-----+            | konzument |
|           |... &gt;! ... |kanál} ... &lt;! ... |           |
| go block  |           +-----+            | go block  |
+-----------+                              +-----------+
</pre>

<p>V&nbsp;interaktivní smyčce REPL lze producenta realizovat v&nbsp;go bloku,
stejně tak i konzumenta:</p>

<pre>
(<strong>require</strong> '[clojure.core.async :refer :all])
&nbsp;
<i>; vytvoření kanálu</i>
(<strong>def</strong> c (chan))
&nbsp;
<i>; asynchronní spuštění producenta</i>
(<strong>go</strong> (&gt;! c "Hello world!"))
&nbsp;
<i>; asynchronní spuštění konzumenta</i>
(<strong>go</strong> (println (&lt;! c)))
</pre>

<p>Konzument může čekat libovolně dlouhou dobu do chvíle, než z&nbsp;kanálu
získá data:</p>

<pre>
<i>; asynchronní spuštění konzumenta</i>
(<strong>go</strong> (println (&lt;! c)))
&nbsp;
...
...
...
čas na kafe
...
...
...
&nbsp;
<i>; asynchronní spuštění producenta</i>
(<strong>go</strong> (&gt;! c "Hello world!"))
&nbsp;
</pre>



<p><a name="k06"></a></p>
<h2 id="k06">6. První demonstrační příklad: producent a konzument</h2>

<p>V&nbsp;dnešním prvním demonstračním příkladu je implementován výše zmíněný
(velmi jednoduchý) model typu producent&ndash;konzument. Kostru příkladu
vytvoříte běžným způsobem, tj.&nbsp;příkazem:</p>

<pre>
lein new app async1
</pre>

<p>Následně je nutné upravit projektový soubor <strong>project.clj</strong>
doplněním knihovny <strong>core.async</strong>. Pro jistotu taktéž změňte verzi
Clojure z&nbsp;1.6.0 na 1.7.0 (pochopitelně pouze tehdy, pokud je náhodou stále
nastavena verze 1.6.0):</p>

<pre>
(<strong>defproject</strong> async1 "0.1.0-SNAPSHOT"
  :description "FIXME: write description"
  :url "http://example.com/FIXME"
  :license {:name "Eclipse Public License"
            :url "http://www.eclipse.org/legal/epl-v10.html"}
  :dependencies [[org.clojure/clojure "<strong>1.7.0</strong>"]
                 <strong>[org.clojure/core.async "0.2.374"]</strong>]
  :main ^:skip-aot async1.core
  :target-path "target/%s"
  :profiles {:uberjar {:aot :all}})
</pre>

<p>Vlastní program se vlastně příliš neliší od sekvence příkazů uvedených
v&nbsp;předchozí kapitole. Pouze se vylepšil import knihovny
<strong>core.async</strong>, protože potřebujeme použít jen čtyři symboly
z&nbsp;této knihovny a současně si nepřepsat další užitečné funkce
(v&nbsp;<strong>core.async</strong> je například deklarována funkce
<strong>map</strong> apod.). Aby se simulovalo pomalé zapisování příkazů
v&nbsp;REPL, používá se v&nbsp;příkladu uživatelská funkce
<strong>wait</strong> ukazující, že bloky <strong>go</strong> jsou skutečně
spuštěny asynchronně:</p>

<pre>
(<strong>ns</strong> async1.core
    (:gen-class))
&nbsp;
<i>; nacteme vsechny potrebne funkce, makra a symboly z knihovny</i>
<i>; (schvalne se nenacitaji vsechny funkce, protoze by jejich jmena</i>
<i>;  prepsala takove zakladni funkce, jako je map apod.)</i>
(<strong>require</strong> '[clojure.core.async :refer (go chan &gt;! &lt;!)])
&nbsp;
(<strong>defn</strong> wait
    "Pozastaveni hlavniho vlakna - simulace interaktivni prace."
    []
    (Thread/sleep 1000))
&nbsp;
(<strong>defn</strong> -main
    "Tato funkce se spusti automaticky nastrojem Leiningen."
    [&amp; args]
    (println "Start")
    <i>; vytvorime kanal</i>
    (<strong>let</strong> [channel (chan)]
        <i>; poslani zpravy do kanaly (go block bude cekat na precteni)</i>
        (<strong>go</strong> (&gt;! channel "Hello world #1!"))
        (wait)
&nbsp;        
        <i>; precteni zpravy z kanalu</i>
        (<strong>go</strong> (println (&lt;! channel)))
        (wait)
&nbsp;        
        <i>; pokus o precteni zpravy z kanalu (ten je prazdny, takze se go block zastavi)</i>
        (<strong>go</strong> (println (&lt;! channel)))
        (wait)
&nbsp;        
        <i>; poslani zpravy do kanalu, na tuto zpravu se jiz netrpelive ceka</i>
        (<strong>go</strong> (&gt;! channel "Hello world #2!"))
        (wait))
&nbsp;        
    (println "Finish"))
</pre>



<p><a name="k07"></a></p>
<h2 id="k07">7. Druhý demonstrační příklad: modelování času pomocí <strong>timeout</strong></h2>

<p>Ve druhém demonstračním příkladu je vytvořen producent, který do kanálu
postupně posílá sekvenci čísel 0 až 9, přičemž mezi čísly je určitý čekací
interval simulující nějaký výpočet či I/O operaci. Producent vypadá
následovně:</p>

<pre>
<i>; kontinualni posilani zprav do kanalu v asynchronnim bloku</i>
(<strong>go</strong>
    (dotimes [i 10]
        (Thread/sleep 1000)
        (&gt;! channel i)))
</pre>

<p>Konzument je realizován nekonečnou smyčkou čekající na data z&nbsp;kanálu.
Pro <strong>go</strong> bloky je typické právě použití smyček, ovšem lze použít
i <strong>go-loop</strong> atd.:</p>

<pre>
(<strong>go</strong>
    (while true
        (println (&lt;! channel))))
</pre>

<p>Pojďme se nyní ukázal úplný zdrojový kód tohoto příkladu. Nejprve projektový
soubor:</p>

<pre>
(<strong>defproject</strong> async2 "0.1.0-SNAPSHOT"
  :description "FIXME: write description"
  :url "http://example.com/FIXME"
  :license {:name "Eclipse Public License"
            :url "http://www.eclipse.org/legal/epl-v10.html"}
  :dependencies [[org.clojure/clojure "1.7.0"]
                 [org.clojure/core.async "0.2.374"]]
  :main ^:skip-aot async2.core
  :target-path "target/%s"
  :profiles {:uberjar {:aot :all}})
</pre>

<p>Následně i vlastní hlavní modul:</p>

<pre>
(<strong>ns</strong> async2.core
    (:gen-class))
&nbsp;
<i>; nacteme vsechny potrebne funkce, makra a symboly z knihovny</i>
<i>; (schvalne se nenacitaji vsechny funkce, protoze by jejich jmena</i>
<i>;  prepsala takove zakladni funkce, jako je map apod.)</i>
(<strong>require</strong> '[clojure.core.async :refer (go chan &gt;! &lt;!])
&nbsp;
(<strong>defn</strong> wait
    "Pozastaveni hlavniho vlakna - simulace interaktivni prace."
    []
    (Thread/sleep 15000))
&nbsp;
(<strong>defn</strong> -main
    "Tato funkce se spusti automaticky nastrojem Leiningen."
    [&amp; args]
    (println "Start")
    <i>; vytvorime kanal</i>
    (<strong>let</strong> [channel (chan)]
        <i>; kontinualni posilani zprav do kanalu v asynchronnim bloku</i>
        (<strong>go</strong>
            (dotimes [i 10]
                (Thread/sleep 1000)
                (&gt;! channel i)))
&nbsp;
        (println "1st go block started")
&nbsp;
        <i>; kontinualni cteni zprav z kanalu v asynchronnim bloku</i>
        (<strong>go</strong>
            (while true
                (println (&lt;! channel))))
&nbsp;
        (println "2nd go block started"))
    <i>; chvili pockame, az se vypise cela sekvence 0 az 9</i>
    (wait)
    (println "Finish"))
</pre>

<p>Ve skutečnosti není použití <strong>(Thread/sleep 1000)</strong> příliš
idiomatické. Mnohem lepší je použití speciálního kanálu vytvořeného zavoláním
<strong>(timeout x)</strong>. Tento kanál je po uplynutí určeného časového
intervalu automaticky uzavřen. Co to znamená? Pokud z&nbsp;kanálu pouze čteme,
jedná se o blokující operaci (to již víme), ovšem po uplynutí určeného času je
kanál uzavřen a vrátí se hodnota <strong>nil</strong>. Čtením z&nbsp;kanálu
typu <strong>timeout</strong> tedy můžeme elegantně realizovat efektivně
implementované čekání. Upravený producent vypadá takto:</p>

<pre>
<i>; kontinualni posilani zprav do kanalu v asynchronnim bloku</i>
(<strong>go</strong>
    (dotimes [i 10]
        <i>;(Thread/sleep 1000)</i>
        (&lt;! (timeout 1000))
        (&gt;! channel i)))
</pre>

<p>Upravený zdrojový kód má následující tvar (povšimněte si nového symbolu
v&nbsp;<strong>require</strong>):</p>

<pre>
(<strong>ns</strong> async2.core
    (:gen-class))
&nbsp;
<i>; nacteme vsechny potrebne funkce, makra a symboly z knihovny</i>
<i>; (schvalne se nenacitaji vsechny funkce, protoze by jejich jmena</i>
<i>;  prepsala takove zakladni funkce, jako je map apod.)</i>
(<strong>require</strong> '[clojure.core.async :refer (go chan &gt;! &lt;! timeout)])
&nbsp;
(<strong>defn</strong> wait
    "Pozastaveni hlavniho vlakna - simulace interaktivni prace."
    []
    (Thread/sleep 15000))
&nbsp;
(<strong>defn</strong> -main
    "Tato funkce se spusti automaticky nastrojem Leiningen."
    [&amp; args]
    (println "Start")
    <i>; vytvorime kanal</i>
    (<strong>let</strong> [channel (chan)]
        <i>; kontinualni posilani zprav do kanalu v asynchronnim bloku</i>
        (<strong>go</strong>
            (dotimes [i 10]
                <i>;(Thread/sleep 1000)</i>
                (&lt;! (timeout 1000))
                (&gt;! channel i)))
&nbsp;
        (println "1st go block started")
&nbsp;
        <i>; kontinualni cteni zprav z kanalu v asynchronnim bloku</i>
        (<strong>go</strong>
            (while true
                (println (&lt;! channel))))
&nbsp;
        (println "2nd go block started"))
    <i>; chvili pockame, az se vypise cela sekvence 0 az 9</i>
    (wait)
    (println "Finish"))
</pre>



<p><a name="k08"></a></p>
<h2 id="k08">8. Třetí demonstrační příklad: jednoduchý logger</h2>

<p>Jedno z&nbsp;možných použití kanálů spočívá v&nbsp;implementaci jednoduchého
loggeru, který může být volán z&nbsp;libovolného počtu vláken, synchronně či
asynchronně. Navíc je možné zvětšit kapacitu kanálu používaného loggerem a
změnit tak jeho chování (kanál se bude chovat jako fronta či buffer), což je
vhodné zejména tehdy, pokud je I/O operace spojená s&nbsp;logováním časově
náročnější (zápis do databáze, zápis na dedikovaný stroj atd.). V&nbsp;našem
případě logger pouze zapisuje data přečtená z&nbsp;kanálu na standardní výstup,
to je však možné snadno změnit:</p>

<pre>
(<strong>ns</strong> async3.core
    (:gen-class))
&nbsp;
<i>; nacteme vsechny potrebne funkce, makra a symboly z knihovny</i>
<i>; (schvalne se nenacitaji vsechny funkce, protoze by jejich jmena</i>
<i>;  prepsala takove zakladni funkce, jako je map apod.)</i>
(<strong>require</strong> '[clojure.core.async :refer (go chan &gt;! &lt;!)])
&nbsp;
(<strong>def</strong> logger (chan))
&nbsp;
(<strong>defn</strong> wait
    "Pozastaveni hlavniho vlakna - simulace interaktivni prace."
    []
    (Thread/sleep 5000))
&nbsp;
(<strong>defn</strong> start-logger
    "Spusteni loggeru."
    []
    (<strong>go</strong>
        (while true
            <i>;(Thread/sleep 1000) ; zkuste odkomentovat</i>
            <i>; vytisteni vsech dat prectenych z kanalu</i>
            (println (&lt;! logger)))))
&nbsp;
(<strong>defn</strong> log
    "Zalogovani zpravy - poslani do kanalu."
    [message]
    (<strong>go</strong> (&gt;! logger message))
    nil)
&nbsp;
(<strong>defn</strong> -main
    "Tato funkce se spusti automaticky nastrojem Leiningen."
    [&amp; args]
    (println "Start")
    (start-logger)
    (log "Hello")
&nbsp;
    (dotimes [i 20]
        (future (log (str "Thread #" i))))
&nbsp;
    (log "world")
&nbsp;
    <i>; chvili pockame, az se vypise cela sekvence 0 az 9</i>
    (wait)
    <i>; dokonceni vsech dalsich vlaken atd.</i>
    (shutdown-agents)
    (println "Finish"))
</pre>

<p>Povšimněte si použití dvaceti různých vláken pro zápis do kanálu. Makrem
<strong>future</strong> se spustí blok v&nbsp;samostatném vláknu:</p>

<pre>
(dotimes [i 20]
    (future (log (str "Thread #" i))))
</pre>

<p>Na konci příkladu je nyní nutné použít volání:</p>

<pre>
(shutdown-agents)
</pre>

<p>zajišťující ukončení všech vláken vytvořených agenty či voláním
<strong>future</strong>.</p>



<p><a name="k09"></a></p>
<h2 id="k09">9. Čtvrtý demonstrační příklad: větší množství producentů</h2>

<p>Kanál může být využíván více producenty (i konzumenty), takže se původní
schéma:</p>

<pre>
+-----------+                              +-----------+
| producent |           +-----+            | konzument |
|           |... &gt;! ... |kanál} ... &lt;! ... |           |
| go block  |           +-----+            | go block  |
+-----------+                              +-----------+
</pre>

<p>Může změnit na poněkud složitější schéma:</p>

<pre>
+-----------+ 
| producent |
|     #1    |... &gt;!.........
| go block  |              :
+-----------+              :
                           :
+-----------+              :               +-----------+
| producent |           +-----+            | konzument |
|     #2    |... &gt;! ... |kanál} ... &lt;! ... |           |
| go block  |           +-----+            | go block  |
+-----------+              :               +-----------+
                           :
+-----------+              :
| producent |              :
|     #3    |... &gt;!........:
| go block  |
+-----------+
</pre>

<p>Toto uspořádání je samozřejmě podporováno, o čemž nás přesvědčí další
programový kód s&nbsp;trojicí producentů a jediným konzumentem:</p>

<pre>
(<strong>ns</strong> async4.core
    (:gen-class))
&nbsp;
<i>; nacteme vsechny potrebne funkce, makra a symboly z knihovny</i>
<i>; (schvalne se nenacitaji vsechny funkce, protoze by jejich jmena</i>
<i>;  prepsala takove zakladni funkce, jako je map apod.)</i>
(<strong>require</strong> '[clojure.core.async :refer (go chan &gt;! &lt;! timeout)])
&nbsp;
(<strong>defn</strong> wait
    "Pozastaveni hlavniho vlakna - simulace interaktivni prace."
    []
    (Thread/sleep 10000))
&nbsp;
(<strong>defn</strong> -main
    "Tato funkce se spusti automaticky nastrojem Leiningen."
    [&amp; args]
    (println "Start")
    <i>; vytvorime kanal</i>
    (<strong>let</strong> [channel (chan)]
        <i>; kontinualni posilani zprav do kanalu v trojici asynchronnich bloku</i>
        (<strong>go</strong>
            (while true
                (&lt;! (timeout 500))
                (&gt;! channel "first")))
&nbsp;
        (<strong>go</strong>
            (while true
                (&lt;! (timeout 1000))
                (&gt;! channel "second")))
&nbsp;
        (<strong>go</strong>
            (while true
                (&lt;! (timeout 2000))
                (&gt;! channel "third")))
&nbsp;
        (println "producers started")
&nbsp;
        <i>; kontinualni cteni zprav z kanalu v asynchronnim bloku</i>
        (<strong>go</strong>
            (while true
                (println (&lt;! channel))))
&nbsp;
        (println "consumer started"))
    <i>; chvili pockame, az se vypise cela sekvence 0 az 9</i>
    (wait)
    (println "Finish")
    (System/exit 0))
</pre>

<p>Příklad výstupu, z&nbsp;něhož je patrné, s&nbsp;jakou frekvencí jednotliví
producenti zapisují zprávy do kanálu:</p>

<pre>
Start
producers started
consumer started
first
second
first
first
third
second
first
first
second
first
first
third
second
first
first
second
first
first
third
second
first
first
second
first
first
third
second
first
first
second
first
first
Finish
</pre>



<p><a name="k10"></a></p>
<h2 id="k10">10. Použití funkce <strong>alts!</strong> při obsluze většího množství kanálů</h2>

<p>Použití většího množství producentů jsme si již ukázali v&nbsp;předchozím
příkladu. Nyní si řekněme, jak může jediný konzument načítat data
z&nbsp;většího množství kanálů. To je možné, ovšem namísto operace &lt;! se
použije funkce <strong>alts!</strong>, které se předá vektor kanálů. Funkce
<strong>alts!</strong> ve výchozím nastavení <i>náhodně</i> vybere kanál, ze
kterého bude číst. Náhodný výběr je zde důležitý, protože pokud by se kanály
neustále vybíraly podle uvedeného pořadí, mohlo by docházet k&nbsp;efektu,
který je znám pod termínem &bdquo;vyhladovění&ldquo; (starvation) u těch
kanálů, které se ve vektoru nachází na posledních pozicích. Kromě dvou již
uvedených schémat tedy ještě přibývá třetí schéma + všechny jeho varianty:</p>

<pre>
+-----------+ 
| producent |           +------+
|     #1    |... &gt;!.....|kanál1}.......
| go block  |           +------+      :
+-----------+                         :
                                      :
+-----------+                         :        +-----------+
| producent |           +------+      :        | konzument |
|     #2    |... &gt;! ... |kanál2} ... alts! ... |           |
| go block  |           +------+      :        | go block  |
+-----------+                         :        +-----------+
                                      :
+-----------+                         :
| producent |           +------+      :
|     #3    |... &gt;!.....|kanál3}......:
| go block  |           +------+
+-----------+
</pre>



<p><a name="k11"></a></p>
<h2 id="k11">11. Pátý demonstrační příklad: použití funkce <strong>alts!</strong></h2>

<p>Funkce <strong>alts!</strong> je použita v&nbsp;pátém demonstračním
příkladu. Povšimněte si, že návratovou hodnotou této funkce je dvojice, protože
je nutné nějakým způsobem vrátit jak referenci na kanál, ze kterého se čte, tak
i vlastní přečtenou hodnotu. My referenci na kanál použijeme ve výstupu pro
určení tisknutého prefixu:</p>

<pre>
(<strong>ns</strong> async5.core
    (:gen-class))
&nbsp;
<i>; nacteme vsechny potrebne funkce, makra a symboly z knihovny</i>
<i>; (schvalne se nenacitaji vsechny funkce, protoze by jejich jmena</i>
<i>;  prepsala takove zakladni funkce, jako je map apod.)</i>
(<strong>require</strong> '[clojure.core.async :refer (go chan &gt;! &lt;! timeout alts!)])
&nbsp;
(<strong>defn</strong> wait
    "Pozastaveni hlavniho vlakna - simulace interaktivni prace."
    []
    (Thread/sleep 10000))
&nbsp;
(<strong>defn</strong> -main
    "Tato funkce se spusti automaticky nastrojem Leiningen."
    [&amp; args]
    (println "Start")
    <i>; vytvorime kanaly</i>
    (<strong>let</strong> [channel1 (chan)
          channel2 (chan)
          channel3 (chan)]
&nbsp;
        <i>; kontinualni posilani zprav do trech kanalu v trojici asynchronnich bloku</i>
        (<strong>go</strong>
            (doseq [i (range)]
                (&lt;! (timeout 500))
                (&gt;! channel1 i)))
&nbsp;
        (<strong>go</strong>
            (doseq [i (range)]
                (&lt;! (timeout 1000))
                (&gt;! channel2 i)))
&nbsp;
        (<strong>go</strong>
            (doseq [i (range)]
                (&lt;! (timeout 2000))
                (&gt;! channel3 i)))
&nbsp;
        (println "producers started")
&nbsp;
        <i>; kontinualni cteni zprav z kanalu v asynchronnim bloku</i>
        (<strong>go</strong>
            (while true
                (<strong>let</strong> [[item channel] (alts! [channel1 channel2 channel3])]
                    (condp = channel
                        channel1 (println "channel #1: " item)
                        channel2 (println "channel #2: " item)
                        channel3 (println "channel #3: " item)))))
&nbsp;
        (println "consumer started"))
    <i>; chvili pockame, az se vypise cela sekvence 0 az 9</i>
    (wait)
    (println "Finish")
    (System/exit 0))
</pre>

<p>Příklad výstupu:</p>

<pre>
Start
producers started
consumer started
channel #1:  0
channel #2:  0
channel #1:  1
channel #1:  2
channel #3:  0
channel #2:  1
channel #1:  3
channel #1:  4
channel #2:  2
channel #1:  5
channel #1:  6
channel #3:  1
channel #2:  3
channel #1:  7
channel #1:  8
channel #2:  4
channel #1:  9
channel #1:  10
channel #3:  2
channel #2:  5
channel #1:  11
channel #1:  12
channel #2:  6
channel #1:  13
channel #1:  14
channel #3:  3
channel #2:  7
channel #1:  15
</pre>



<p><a name="k12"></a></p>
<h2 id="k12">12. Repositář s&nbsp;demonstračními příklady</h2>

<p>Všech pět demonstračních příkladů, které jsme si v&nbsp;dnešním článku
popsali, bylo uloženo do Git repositáře dostupného na adrese <a
href="https://github.com/tisnik/clojure-examples">https://github.com/tisnik/clojure-examples</a>.
V&nbsp;tabulce zobrazené pod tímto odstavcem naleznete na zdrojové kódy
demonstračních příkladů přímé odkazy:</p>

<table>
<tr><th>#</th><th>Příklad/knihovna</th><th>Github</th></tr>
<tr><td>1</td><td>async1</td><td><a href="https://github.com/tisnik/clojure-examples/tree/master/async1">https://github.com/tisnik/clojure-examples/tree/master/async1</a></td></tr>
<tr><td>2</td><td>async2</td><td><a href="https://github.com/tisnik/clojure-examples/tree/master/async2">https://github.com/tisnik/clojure-examples/tree/master/async2</a></td></tr>
<tr><td>3</td><td>async3</td><td><a href="https://github.com/tisnik/clojure-examples/tree/master/async3">https://github.com/tisnik/clojure-examples/tree/master/async3</a></td></tr>
<tr><td>4</td><td>async4</td><td><a href="https://github.com/tisnik/clojure-examples/tree/master/async4">https://github.com/tisnik/clojure-examples/tree/master/async4</a></td></tr>
<tr><td>5</td><td>async5</td><td><a href="https://github.com/tisnik/clojure-examples/tree/master/async5">https://github.com/tisnik/clojure-examples/tree/master/async5</a></td></tr>
</table>



<p><a name="k13"></a></p>
<h2 id="k13">13. Odkazy na předchozí části tohoto seriálu</h2>

<ol>

<li>Clojure  1: Úvod<br />
<a href="http://www.root.cz/clanky/clojure-aneb-jazyk-umoznujici-tvorbu-bezpecnych-vicevlaknovych-aplikaci-pro-jvm/">http://www.root.cz/clanky/clojure-aneb-jazyk-umoznujici-tvorbu-bezpecnych-vicevlaknovych-aplikaci-pro-jvm/</a>
</li>

<li>Clojure  2: Symboly, kolekce atd.<br />
<a href="http://www.root.cz/clanky/clojure-aneb-jazyk-umoznujici-tvorbu-bezpecnych-vicevlaknovych-aplikaci-pro-jvm-2-cast/">http://www.root.cz/clanky/clojure-aneb-jazyk-umoznujici-tvorbu-bezpecnych-vicevlaknovych-aplikaci-pro-jvm-2-cast/</a>
</li>

<li>Clojure  3: Funkcionální programování<br />
<a href="http://www.root.cz/clanky/clojure-aneb-jazyk-umoznujici-tvorbu-bezpecnych-vicevlaknovych-aplikaci-pro-jvm-3-cast-funkcionalni-programovani/">http://www.root.cz/clanky/clojure-aneb-jazyk-umoznujici-tvorbu-bezpecnych-vicevlaknovych-aplikaci-pro-jvm-3-cast-funkcionalni-programovani/</a>
</li>

<li>Clojure  4: Kolekce, sekvence a lazy sekvence<br />
<a href="http://www.root.cz/clanky/clojure-aneb-jazyk-umoznujici-tvorbu-bezpecnych-vicevlaknovych-aplikaci-pro-jvm-4-cast-kolekce-sekvence-a-lazy-sekvence/">http://www.root.cz/clanky/clojure-aneb-jazyk-umoznujici-tvorbu-bezpecnych-vicevlaknovych-aplikaci-pro-jvm-4-cast-kolekce-sekvence-a-lazy-sekvence/</a>
</li>

<li>Clojure  5: Sekvence, lazy sekvence a paralelní programy<br />
<a href="http://www.root.cz/clanky/clojure-a-bezpecne-aplikace-pro-jvm-sekvence-lazy-sekvence-a-paralelni-programy/">http://www.root.cz/clanky/clojure-a-bezpecne-aplikace-pro-jvm-sekvence-lazy-sekvence-a-paralelni-programy/</a>
</li>

<li>Clojure  6: Podpora pro paralelní programování<br />
<a href="http://www.root.cz/clanky/programovaci-jazyk-clojure-6-futures-nejsou-jen-financni-derivaty/">http://www.root.cz/clanky/programovaci-jazyk-clojure-6-futures-nejsou-jen-financni-derivaty/</a>
</li>

<li>Clojure  7: Další funkce pro paralelní programování<br />
<a href="http://www.root.cz/clanky/programovaci-jazyk-clojure-7-dalsi-podpurne-prostredky-pro-paralelni-programovani/">http://www.root.cz/clanky/programovaci-jazyk-clojure-7-dalsi-podpurne-prostredky-pro-paralelni-programovani/</a>
</li>

<li>Clojure  8: Identity, stavy, neměnné hodnoty a reference<br />
<a href="http://www.root.cz/clanky/programovaci-jazyk-clojure-8-identity-stavy-nemenne-hodnoty-a-referencni-typy/">http://www.root.cz/clanky/programovaci-jazyk-clojure-8-identity-stavy-nemenne-hodnoty-a-referencni-typy/</a>
</li>

<li>Clojure  9: Validátory, pozorovatelé a kooperace s Javou<br />
<a href="http://www.root.cz/clanky/programovaci-jazyk-clojure-9-validatory-pozorovatele-a-kooperace-mezi-clojure-a-javou/">http://www.root.cz/clanky/programovaci-jazyk-clojure-9-validatory-pozorovatele-a-kooperace-mezi-clojure-a-javou/</a>
</li>

<li>Clojure 10: Kooperace mezi Clojure a Javou<br />
<a href="http://www.root.cz/clanky/programovaci-jazyk-clojure-10-kooperace-mezi-clojure-a-javou-pokracovani/">http://www.root.cz/clanky/programovaci-jazyk-clojure-10-kooperace-mezi-clojure-a-javou-pokracovani/</a>
</li>

<li>Clojure 11: Generátorová notace seznamu/list comprehension<br />
<a href="http://www.root.cz/clanky/programovaci-jazyk-clojure-11-generatorova-notace-seznamu-list-comprehension/">http://www.root.cz/clanky/programovaci-jazyk-clojure-11-generatorova-notace-seznamu-list-comprehension/</a>
</li>

<li>Clojure 12: Překlad programů z Clojure do bajtkódu JVM I:<br />
<a href="http://www.root.cz/clanky/programovaci-jazyk-clojure-12-preklad-programu-z-clojure-do-bajtkodu-jvm/">http://www.root.cz/clanky/programovaci-jazyk-clojure-12-preklad-programu-z-clojure-do-bajtkodu-jvm/</a>
</li>

<li>Clojure 13: Překlad programů z Clojure do bajtkódu JVM II:<br />
<a href="http://www.root.cz/clanky/programovaci-jazyk-clojure-13-preklad-programu-z-clojure-do-bajtkodu-jvm-pokracovani/">http://www.root.cz/clanky/programovaci-jazyk-clojure-13-preklad-programu-z-clojure-do-bajtkodu-jvm-pokracovani/</a>
</li>

<li>Clojure 14: Základy práce se systémem maker<br />
<a href="http://www.root.cz/clanky/programovaci-jazyk-clojure-14-zaklady-prace-se-systemem-maker/">http://www.root.cz/clanky/programovaci-jazyk-clojure-14-zaklady-prace-se-systemem-maker/</a>
</li>

<li>Clojure 15: Tvorba uživatelských maker<br />
<a href="http://www.root.cz/clanky/programovaci-jazyk-clojure-15-tvorba-uzivatelskych-maker/">http://www.root.cz/clanky/programovaci-jazyk-clojure-15-tvorba-uzivatelskych-maker/</a>
</li>

<li>Clojure 16: Složitější uživatelská makra<br />
<a href="http://www.root.cz/clanky/programovaci-jazyk-clojure-16-slozitejsi-uzivatelska-makra/">http://www.root.cz/clanky/programovaci-jazyk-clojure-16-slozitejsi-uzivatelska-makra/</a>
</li>

<li>Clojure 17: Využití standardních maker v praxi<br />
<a href="http://www.root.cz/clanky/programovaci-jazyk-clojure-17-vyuziti-standardnich-maker-v-praxi/">http://www.root.cz/clanky/programovaci-jazyk-clojure-17-vyuziti-standardnich-maker-v-praxi/</a>
</li>

<li>Clojure 18: Základní techniky optimalizace aplikací<br />
<a href="http://www.root.cz/clanky/programovaci-jazyk-clojure-18-zakladni-techniky-optimalizace-aplikaci/">http://www.root.cz/clanky/programovaci-jazyk-clojure-18-zakladni-techniky-optimalizace-aplikaci/</a>
</li>

<li>Clojure 19: Vývojová prostředí pro Clojure<br />
<a href="http://www.root.cz/clanky/programovaci-jazyk-clojure-19-vyvojova-prostredi-pro-clojure/">http://www.root.cz/clanky/programovaci-jazyk-clojure-19-vyvojova-prostredi-pro-clojure/</a>
</li>

<li>Clojure 20: Vývojová prostředí pro Clojure (Vimu s REPL)<br />
<a href="http://www.root.cz/clanky/programovaci-jazyk-clojure-20-vyvojova-prostredi-pro-clojure-integrace-vimu-s-repl/">http://www.root.cz/clanky/programovaci-jazyk-clojure-20-vyvojova-prostredi-pro-clojure-integrace-vimu-s-repl/</a>
</li>

<li>Clojure 21: ClojureScript aneb překlad Clojure do JS<br />
<a href="http://www.root.cz/clanky/programovaci-jazyk-clojure-21-clojurescript-aneb-preklad-clojure-do-javascriptu/">http://www.root.cz/clanky/programovaci-jazyk-clojure-21-clojurescript-aneb-preklad-clojure-do-javascriptu/</a>
</li>

<li>Leiningen: nástroj pro správu projektů napsaných v Clojure<br />
<a href="http://www.root.cz/clanky/leiningen-nastroj-pro-spravu-projektu-napsanych-v-clojure/">http://www.root.cz/clanky/leiningen-nastroj-pro-spravu-projektu-napsanych-v-clojure/</a>
</li>

<li>Leiningen: nástroj pro správu projektů napsaných v Clojure (2)<br />
<a href="http://www.root.cz/clanky/leiningen-nastroj-pro-spravu-projektu-napsanych-v-clojure-2/">http://www.root.cz/clanky/leiningen-nastroj-pro-spravu-projektu-napsanych-v-clojure-2/</a>
</li>

<li>Leiningen: nástroj pro správu projektů napsaných v Clojure (3)<br />
<a href="http://www.root.cz/clanky/leiningen-nastroj-pro-spravu-projektu-napsanych-v-clojure-3/">http://www.root.cz/clanky/leiningen-nastroj-pro-spravu-projektu-napsanych-v-clojure-3/</a>
</li>

<li>Leiningen: nástroj pro správu projektů napsaných v Clojure (4)<br />
<a href="http://www.root.cz/clanky/leiningen-nastroj-pro-spravu-projektu-napsanych-v-clojure-4/">http://www.root.cz/clanky/leiningen-nastroj-pro-spravu-projektu-napsanych-v-clojure-4/</a>
</li>

<li>Leiningen: nástroj pro správu projektů napsaných v Clojure (5)<br />
<a href="http://www.root.cz/clanky/leiningen-nastroj-pro-spravu-projektu-napsanych-v-clojure-5/">http://www.root.cz/clanky/leiningen-nastroj-pro-spravu-projektu-napsanych-v-clojure-5/</a>
</li>

<li>Leiningen: nástroj pro správu projektů napsaných v Clojure (6)<br />
<a href="http://www.root.cz/clanky/leiningen-nastroj-pro-spravu-projektu-napsanych-v-clojure-6/">http://www.root.cz/clanky/leiningen-nastroj-pro-spravu-projektu-napsanych-v-clojure-6/</a>
</li>

<li>Programovací jazyk Clojure a databáze (1.část)<br />
<a href="http://www.root.cz/clanky/programovaci-jazyk-clojure-a-databaze-1-cast/">http://www.root.cz/clanky/programovaci-jazyk-clojure-a-databaze-1-cast/</a>
</li>

<li>Pluginy pro Leiningen<br />
<a href="http://www.root.cz/clanky/leiningen-nastroj-pro-spravu-projektu-napsanych-v-clojure-pluginy-pro-leiningen/">http://www.root.cz/clanky/leiningen-nastroj-pro-spravu-projektu-napsanych-v-clojure-pluginy-pro-leiningen/</a>
</li>

<li>Programovací jazyk Clojure a knihovny pro práci s vektory a maticemi<br />
<a href="http://www.root.cz/clanky/programovaci-jazyk-clojure-a-knihovny-pro-praci-s-vektory-a-maticemi/">http://www.root.cz/clanky/programovaci-jazyk-clojure-a-knihovny-pro-praci-s-vektory-a-maticemi/</a>
</li>

<li>Programovací jazyk Clojure a knihovny pro práci s vektory a maticemi (2)<br />
<a href="http://www.root.cz/clanky/programovaci-jazyk-clojure-a-knihovny-pro-praci-s-vektory-a-maticemi-2/">http://www.root.cz/clanky/programovaci-jazyk-clojure-a-knihovny-pro-praci-s-vektory-a-maticemi-2/</a>
</li>

<li>Programovací jazyk Clojure: syntéza procedurálních textur s využitím knihovny Clisk<br />
<a href="http://www.root.cz/clanky/programovaci-jazyk-clojure-synteza-proceduralnich-textur-s-vyuzitim-knihovny-clisk/">http://www.root.cz/clanky/programovaci-jazyk-clojure-synteza-proceduralnich-textur-s-vyuzitim-knihovny-clisk/</a>
</li>

<li>Programovací jazyk Clojure: syntéza procedurálních textur s využitím knihovny Clisk (2)<br />
<a href="http://www.root.cz/clanky/programovaci-jazyk-clojure-synteza-proceduralnich-textur-s-vyuzitim-knihovny-clisk-2/">http://www.root.cz/clanky/programovaci-jazyk-clojure-synteza-proceduralnich-textur-s-vyuzitim-knihovny-clisk-2/</a>
</li>

<li>Programovací jazyk Clojure: syntéza procedurálních textur s využitím knihovny Clisk (dokončení)<br />
<a href="http://www.root.cz/clanky/programovaci-jazyk-clojure-synteza-proceduralnich-textur-s-vyuzitim-knihovny-clisk-dokonceni/">http://www.root.cz/clanky/programovaci-jazyk-clojure-synteza-proceduralnich-textur-s-vyuzitim-knihovny-clisk-dokonceni/</a>
</li>

<li>Seesaw: knihovna pro snadnou tvorbu GUI v jazyce Clojure<br />
<a href="http://www.root.cz/clanky/seesaw-knihovna-pro-snadnou-tvorbu-gui-v-jazyce-clojure/">http://www.root.cz/clanky/seesaw-knihovna-pro-snadnou-tvorbu-gui-v-jazyce-clojure/</a>
</li>

<li>Seesaw: knihovna pro snadnou tvorbu GUI v jazyce Clojure (2)<br />
<a href="http://www.root.cz/clanky/seesaw-knihovna-pro-snadnou-tvorbu-gui-v-jazyce-clojure-2/">http://www.root.cz/clanky/seesaw-knihovna-pro-snadnou-tvorbu-gui-v-jazyce-clojure-2/</a>
</li>

<li>Seesaw: knihovna pro snadnou tvorbu GUI v jazyce Clojure (3)<br />
<a href="http://www.root.cz/clanky/seesaw-knihovna-pro-snadnou-tvorbu-gui-v-jazyce-clojure-3/">http://www.root.cz/clanky/seesaw-knihovna-pro-snadnou-tvorbu-gui-v-jazyce-clojure-3/</a>
</li>

<li>Programovací jazyk Clojure a práce s Gitem<br />
<a href="http://www.root.cz/clanky/programovaci-jazyk-clojure-a-prace-s-gitem/">http://www.root.cz/clanky/programovaci-jazyk-clojure-a-prace-s-gitem/</a>
</li>

<li>Programovací jazyk Clojure a práce s Gitem (2)<br />
<a href="http://www.root.cz/clanky/programovaci-jazyk-clojure-a-prace-s-gitem-2/">http://www.root.cz/clanky/programovaci-jazyk-clojure-a-prace-s-gitem-2/</a>
</li>

<li>Programovací jazyk Clojure – triky při práci s řetězci<br />
<a href="http://www.root.cz/clanky/programovaci-jazyk-clojure-triky-pri-praci-s-retezci/">http://www.root.cz/clanky/programovaci-jazyk-clojure-triky-pri-praci-s-retezci/</a>
</li>

<li>Programovací jazyk Clojure – triky při práci s kolekcemi<br />
<a href="http://www.root.cz/clanky/programovaci-jazyk-clojure-triky-pri-praci-s-kolekcemi/">http://www.root.cz/clanky/programovaci-jazyk-clojure-triky-pri-praci-s-kolekcemi/</a>
</li>

<li>Programovací jazyk Clojure – práce s mapami a množinami<br />
<a href="http://www.root.cz/clanky/programovaci-jazyk-clojure-prace-s-mapami-a-mnozinami/">http://www.root.cz/clanky/programovaci-jazyk-clojure-prace-s-mapami-a-mnozinami/</a>
</li>

<li>Programovací jazyk Clojure – základy zpracování XML<br />
<a href="http://www.root.cz/clanky/programovaci-jazyk-clojure-zaklady-zpracovani-xml/">http://www.root.cz/clanky/programovaci-jazyk-clojure-zaklady-zpracovani-xml/</a>
</li>

<li>Programovací jazyk Clojure – testování s využitím knihovny Expectations<br />
<a href="http://www.root.cz/clanky/programovaci-jazyk-clojure-testovani-s-vyuzitim-knihovny-expectations/">http://www.root.cz/clanky/programovaci-jazyk-clojure-testovani-s-vyuzitim-knihovny-expectations/</a>
</li>

<li>Programovací jazyk Clojure – některé užitečné triky použitelné (nejenom) v&nbsp;testech<br />
<a href="http://www.root.cz/clanky/programovaci-jazyk-clojure-nektere-uzitecne-triky-pouzitelne-nejenom-v-testech/">http://www.root.cz/clanky/programovaci-jazyk-clojure-nektere-uzitecne-triky-pouzitelne-nejenom-v-testech/</a>
</li>

<li>Enlive – výkonný šablonovací systém pro jazyk Clojure<br/>
<a href="http://www.root.cz/clanky/enlive-vykonny-sablonovaci-system-pro-jazyk-clojure/">http://www.root.cz/clanky/enlive-vykonny-sablonovaci-system-pro-jazyk-clojure/</a>
</li>

<li>Nástroj Leiningen a programovací jazyk Clojure: tvorba vlastních knihoven pro veřejný repositář Clojars<br />
<a href="http://www.root.cz/clanky/nastroj-leiningen-a-programovaci-jazyk-clojure-tvorba-vlastnich-knihoven-pro-verejny-repositar-clojars/">http://www.root.cz/clanky/nastroj-leiningen-a-programovaci-jazyk-clojure-tvorba-vlastnich-knihoven-pro-verejny-repositar-clojars/</a>
</li>

<li>Novinky v Clojure verze 1.8.0<br />
<a href="http://www.root.cz/clanky/novinky-v-clojure-verze-1-8-0/">http://www.root.cz/clanky/novinky-v-clojure-verze-1-8-0/</a>
</li>

</ol>



<p><a name="k14"></a></p>
<h2 id="k14">14. Odkazy na Internetu</h2>

<ol>

<li>Communicating sequential processes<br />
<a href="https://en.wikipedia.org/wiki/Communicating_sequential_processes">https://en.wikipedia.org/wiki/Communicating_sequential_processes</a>
</li>

<li>Clojure core.async<br />
<a href="http://www.infoq.com/presentations/clojure-core-async">http://www.infoq.com/presentations/clojure-core-async</a>
</li>

<li>core.async API Reference<br />
<a href="https://clojure.github.io/core.async/">https://clojure.github.io/core.async/</a>
</li>

<li>Clojure core.async Channels<br />
<a href="http://clojure.com/blog/2013/06/28/clojure-core-async-channels.html">http://clojure.com/blog/2013/06/28/clojure-core-async-channels.html</a>
</li>

<li>core.async examples<br />
<a href="https://github.com/clojure/core.async/blob/master/examples/walkthrough.clj">https://github.com/clojure/core.async/blob/master/examples/walkthrough.clj</a>
</li>

<li>Timothy Baldridge - Core.Async<br />
<a href="https://www.youtube.com/watch?v=enwIIGzhahw">https://www.youtube.com/watch?v=enwIIGzhahw</a>
</li>

<li>Designing Front End Applications with core.async<br />
<a href="http://go.cognitect.com/core_async_webinar_recording">http://go.cognitect.com/core_async_webinar_recording</a>
</li>

<li>Mastering Concurrent Processes with core.async<br />
<a href="http://www.braveclojure.com/core-async/">http://www.braveclojure.com/core-async/</a>
</li>

<li>LispCast: Clojure core.async<br />
<a href="https://www.youtube.com/watch?v=msv8Fvtd6YQ">https://www.youtube.com/watch?v=msv8Fvtd6YQ</a>
</li>

<li>Julian Gamble - Applying the paradigms of core.async in ClojureScript<br />
<a href="https://www.youtube.com/watch?v=JUrOebC5HmA">https://www.youtube.com/watch?v=JUrOebC5HmA</a>
</li>

<li>Zip archiv s&nbsp;Clojure 1.8.0<br />
<a href="http://repo1.maven.org/maven2/org/clojure/clojure/1.8.0/clojure-1.8.0.zip">http://repo1.maven.org/maven2/org/clojure/clojure/1.8.0/clojure-1.8.0.zip</a>
</li>

<li>Clojure 1.8 is now available<br />
<a href="http://clojure.org/news/2016/01/19/clojure18">http://clojure.org/news/2016/01/19/clojure18</a>
</li>

<li>Changes to Clojure in Version 1.8<br />
<a href="https://github.com/clojure/clojure/blob/master/changes.md">https://github.com/clojure/clojure/blob/master/changes.md</a>
</li>

<li>Socket Server REPL<br />
<a href="http://dev.clojure.org/display/design/Socket+Server+REPL">http://dev.clojure.org/display/design/Socket+Server+REPL</a>
</li>

<li>CLJ-1671: Clojure socket server<br />
<a href="http://dev.clojure.org/jira/browse/CLJ-1671">http://dev.clojure.org/jira/browse/CLJ-1671</a>
</li>

<li>CLJ-1449: Add clojure.string functions for portability to ClojureScript<br />
<a href="http://dev.clojure.org/jira/browse/CLJ-1449">http://dev.clojure.org/jira/browse/CLJ-1449</a>
</li>

<li>Launching a Socket Server<br />
<a href="http://clojure.org/reference/repl_and_main#_launching_a_socket_server">http://clojure.org/reference/repl_and_main#_launching_a_socket_server</a>
</li>

<li>API for clojure.string<br />
<a href="http://clojure.github.io/clojure/branch-master/clojure.string-api.html">http://clojure.github.io/clojure/branch-master/clojure.string-api.html</a>
</li>

<li>Clojars:<br />
<a href="https://clojars.org/">https://clojars.org/</a>
</li>

<li>
Seznam knihoven na Clojars:<br />
<a href="https://clojars.org/projects">https://clojars.org/projects</a>
</li>

<li>Clojure Cookbook: Templating HTML with Enlive<br />
<a href="https://github.com/clojure-cookbook/clojure-cookbook/blob/master/07_webapps/7-11_enlive.asciidoc">https://github.com/clojure-cookbook/clojure-cookbook/blob/master/07_webapps/7-11_enlive.asciidoc</a>
</li>

<li>An Introduction to Enlive<br />
<a href="https://github.com/swannodette/enlive-tutorial/">https://github.com/swannodette/enlive-tutorial/</a>
</li>

<li>Enlive na GitHubu<br />
<a href="https://github.com/cgrand/enlive">https://github.com/cgrand/enlive</a>
</li>

<li>Expectations: příklady atd.<br />
<a href="http://jayfields.com/expectations/">http://jayfields.com/expectations/</a>
</li>

<li>Expectations na GitHubu<br />
<a href="https://github.com/jaycfields/expectations">https://github.com/jaycfields/expectations</a>
</li>

<li>Lein-expectations na GitHubu<br />
<a href="https://github.com/gar3thjon3s/lein-expectations">https://github.com/gar3thjon3s/lein-expectations</a>
</li>

<li>Testing Clojure With Expectations<br />
<a href="https://semaphoreci.com/blog/2014/09/23/testing-clojure-with-expectations.html">https://semaphoreci.com/blog/2014/09/23/testing-clojure-with-expectations.html</a>
</li>

<li>Clojure testing TDD/BDD libraries: clojure.test vs Midje vs Expectations vs Speclj<br />
<a href="https://www.reddit.com/r/Clojure/comments/1viilt/clojure_testing_tddbdd_libraries_clojuretest_vs/">https://www.reddit.com/r/Clojure/comments/1viilt/clojure_testing_tddbdd_libraries_clojuretest_vs/</a>
</li>

<li>Testing: One assertion per test<br />
<a href="http://blog.jayfields.com/2007/06/testing-one-assertion-per-test.html">http://blog.jayfields.com/2007/06/testing-one-assertion-per-test.html</a>
</li>

<li>Rewriting Your Test Suite in Clojure in 24 hours<br />
<a href="http://blog.circleci.com/rewriting-your-test-suite-in-clojure-in-24-hours/">http://blog.circleci.com/rewriting-your-test-suite-in-clojure-in-24-hours/</a>
</li>

<li>Clojure doc: zipper<br />
<a href="http://clojuredocs.org/clojure.zip/zipper">http://clojuredocs.org/clojure.zip/zipper</a>
</li>

<li>Clojure doc: parse<br />
<a href="http://clojuredocs.org/clojure.xml/parse">http://clojuredocs.org/clojure.xml/parse</a>
</li>

<li>Clojure doc: xml-zip<br />
<a href="http://clojuredocs.org/clojure.zip/xml-zip">http://clojuredocs.org/clojure.zip/xml-zip</a>
</li>

<li>Clojure doc: xml-seq<br />
<a href="http://clojuredocs.org/clojure.core/xml-seq">http://clojuredocs.org/clojure.core/xml-seq</a>
</li>

<li>Parsing XML in Clojure<br />
<a href="https://github.com/clojuredocs/guides">https://github.com/clojuredocs/guides</a>
</li>

<li>Clojure Zipper Over Nested Vector<br />
<a href="https://vitalyper.wordpress.com/2010/11/23/clojure-zipper-over-nested-vector/">https://vitalyper.wordpress.com/2010/11/23/clojure-zipper-over-nested-vector/</a>
</li>

<li>Understanding Clojure's PersistentVector implementation<br />
<a href="http://blog.higher-order.net/2009/02/01/understanding-clojures-persistentvector-implementation">http://blog.higher-order.net/2009/02/01/understanding-clojures-persistentvector-implementation</a>
</li>

<li>Understanding Clojure's PersistentHashMap (deftwice...)<br />
<a href="http://blog.higher-order.net/2009/09/08/understanding-clojures-persistenthashmap-deftwice.html">http://blog.higher-order.net/2009/09/08/understanding-clojures-persistenthashmap-deftwice.html</a>
</li>

<li>Assoc and Clojure's PersistentHashMap: part ii<br />
<a href="http://blog.higher-order.net/2010/08/16/assoc-and-clojures-persistenthashmap-part-ii.html">http://blog.higher-order.net/2010/08/16/assoc-and-clojures-persistenthashmap-part-ii.html</a>
</li>

<li>Ideal Hashtrees (paper)<br />
<a href="http://lampwww.epfl.ch/papers/idealhashtrees.pdf">http://lampwww.epfl.ch/papers/idealhashtrees.pdf</a>
</li>

<li>Clojure home page<br />
<a href="http://clojure.org/">http://clojure.org/</a>
</li>

<li>Clojure (downloads)<br />
<a href="http://clojure.org/downloads">http://clojure.org/downloads</a>
</li>

<li>Clojure Sequences<br />
<a href="http://clojure.org/sequences">http://clojure.org/sequences</a>
</li>

<li>Clojure Data Structures<br />
<a href="http://clojure.org/data_structures">http://clojure.org/data_structures</a>
</li>

<li>The Structure and Interpretation of Computer Programs: 2.2.1  Representing Sequences<br />
<a href="http://mitpress.mit.edu/sicp/full-text/book/book-Z-H-15.html#%_sec_2.2.1">http://mitpress.mit.edu/sicp/full-text/book/book-Z-H-15.html#%_sec_2.2.1</a>
</li>

<li>The Structure and Interpretation of Computer Programs: 3.3.1  Mutable List Structure<br />
<a href="http://mitpress.mit.edu/sicp/full-text/book/book-Z-H-22.html#%_sec_3.3.1">http://mitpress.mit.edu/sicp/full-text/book/book-Z-H-22.html#%_sec_3.3.1</a>
</li>

<li>Clojure - Functional Programming for the JVM<br />
<a href="http://java.ociweb.com/mark/clojure/article.html">http://java.ociweb.com/mark/clojure/article.html</a>
</li>

<li>Clojure quick reference<br />
<a href="http://faustus.webatu.com/clj-quick-ref.html">http://faustus.webatu.com/clj-quick-ref.html</a>
</li>

<li>4Clojure<br />
<a href="http://www.4clojure.com/">http://www.4clojure.com/</a>
</li>

<li>ClojureDoc (rozcestník s&nbsp;dokumentací jazyka Clojure)<br />
<a href="http://clojuredocs.org/">http://clojuredocs.org/</a>
</li>

<li>Clojure (na Wikipedia EN)<br />
<a href="http://en.wikipedia.org/wiki/Clojure">http://en.wikipedia.org/wiki/Clojure</a>
</li>

<li>Clojure (na Wikipedia CS)<br />
<a href="http://cs.wikipedia.org/wiki/Clojure">http://cs.wikipedia.org/wiki/Clojure</a>
</li>

<li>SICP (The Structure and Interpretation of Computer Programs)<br />
<a href="http://mitpress.mit.edu/sicp/">http://mitpress.mit.edu/sicp/</a>
</li>

<li>Pure function<br />
<a href="http://en.wikipedia.org/wiki/Pure_function">http://en.wikipedia.org/wiki/Pure_function</a>
</li>

<li>Funkcionální programování<br />
<a href="http://cs.wikipedia.org/wiki/Funkcionální_programování">http://cs.wikipedia.org/wiki/Funkcionální_programování</a>
</li>

<li>Čistě funkcionální (datové struktury, jazyky, programování)<br />
<a href="http://cs.wikipedia.org/wiki/Čistě_funkcionální">http://cs.wikipedia.org/wiki/Čistě_funkcionální</a>
</li>

<li>Clojure Macro Tutorial (Part I, Getting the Compiler to Write Your Code For You)<br />
<a href="http://www.learningclojure.com/2010/09/clojure-macro-tutorial-part-i-getting.html">http://www.learningclojure.com/2010/09/clojure-macro-tutorial-part-i-getting.html</a>
</li>

<li>Clojure Macro Tutorial (Part II: The Compiler Strikes Back)<br />
<a href="http://www.learningclojure.com/2010/09/clojure-macro-tutorial-part-ii-compiler.html">http://www.learningclojure.com/2010/09/clojure-macro-tutorial-part-ii-compiler.html</a>
</li>

<li>Clojure Macro Tutorial (Part III: Syntax Quote)<br />
<a href="http://www.learningclojure.com/2010/09/clojure-macro-tutorial-part-ii-syntax.html">http://www.learningclojure.com/2010/09/clojure-macro-tutorial-part-ii-syntax.html</a>
</li>

<li>Tech behind Tech: Clojure Macros Simplified<br />
<a href="http://techbehindtech.com/2010/09/28/clojure-macros-simplified/">http://techbehindtech.com/2010/09/28/clojure-macros-simplified/</a>
</li>

<li>Fatvat - Exploring functional programming: Clojure Macros<br />
<a href="http://www.fatvat.co.uk/2009/02/clojure-macros.html">http://www.fatvat.co.uk/2009/02/clojure-macros.html</a>
</li>

<li>Eulerovo číslo<br />
<a href="http://cs.wikipedia.org/wiki/Eulerovo_číslo">http://cs.wikipedia.org/wiki/Eulerovo_číslo</a>
</li>

<li>List comprehension<br />
<a href="http://en.wikipedia.org/wiki/List_comprehension">http://en.wikipedia.org/wiki/List_comprehension</a>
</li>

<li>List Comprehensions in Clojure<br />
<a href="http://asymmetrical-view.com/2008/11/18/list-comprehensions-in-clojure.html">http://asymmetrical-view.com/2008/11/18/list-comprehensions-in-clojure.html</a>
</li>

<li>Clojure Programming Concepts: List Comprehension<br />
<a href="http://en.wikibooks.org/wiki/Clojure_Programming/Concepts#List_Comprehension">http://en.wikibooks.org/wiki/Clojure_Programming/Concepts#List_Comprehension</a>
</li>

<li>Clojure core API: for macro<br />
<a href="http://clojure.github.com/clojure/clojure.core-api.html#clojure.core/for">http://clojure.github.com/clojure/clojure.core-api.html#clojure.core/for</a>
</li>

<li>cirrus machina - The Clojure for macro<br />
<a href="http://www.cirrusmachina.com/blog/comment/the-clojure-for-macro/">http://www.cirrusmachina.com/blog/comment/the-clojure-for-macro/</a>
</li>

<li>Riastradh's Lisp Style Rules<br />
<a href="http://mumble.net/~campbell/scheme/style.txt">http://mumble.net/~campbell/scheme/style.txt</a>
</li>

<li>Dynamic Languages Strike Back<br />
<a href="http://steve-yegge.blogspot.cz/2008/05/dynamic-languages-strike-back.html">http://steve-yegge.blogspot.cz/2008/05/dynamic-languages-strike-back.html</a>
</li>

<li>Scripting: Higher Level Programming for the 21st Century<br />
<a href="http://www.tcl.tk/doc/scripting.html">http://www.tcl.tk/doc/scripting.html</a>
</li>

<li>Java Virtual Machine Support for Non-Java Languages<br />
<a href="http://docs.oracle.com/javase/7/docs/technotes/guides/vm/multiple-language-support.html">http://docs.oracle.com/javase/7/docs/technotes/guides/vm/multiple-language-support.html</a>
</li>

<li>Třída java.lang.String<br />
<a href="http://docs.oracle.com/javase/7/docs/api/java/lang/String.html">http://docs.oracle.com/javase/7/docs/api/java/lang/String.html</a>
</li>

<li>Třída java.lang.StringBuffer<br />
<a href="http://docs.oracle.com/javase/7/docs/api/java/lang/StringBuffer.html">http://docs.oracle.com/javase/7/docs/api/java/lang/StringBuffer.html</a>
</li>

<li>Třída java.lang.StringBuilder<br />
<a href="http://docs.oracle.com/javase/7/docs/api/java/lang/StringBuilder.html">http://docs.oracle.com/javase/7/docs/api/java/lang/StringBuilder.html</a>
</li>

<li>StringBuffer versus String<br />
<a href="http://www.javaworld.com/article/2076072/build-ci-sdlc/stringbuffer-versus-string.html">http://www.javaworld.com/article/2076072/build-ci-sdlc/stringbuffer-versus-string.html</a>
</li>

<li>Threading macro (dokumentace k&nbsp;jazyku Clojure)<br />
<a href="https://clojure.github.io/clojure/clojure.core-api.html#clojure.core/-&gt;">https://clojure.github.io/clojure/clojure.core-api.html#clojure.core/-&gt;</a>
</li>

<li>Understanding the Clojure -&gt; macro<br />
<a href="http://blog.fogus.me/2009/09/04/understanding-the-clojure-macro/">http://blog.fogus.me/2009/09/04/understanding-the-clojure-macro/</a>
</li>

<li>clojure.inspector<br />
<a href="http://clojure.github.io/clojure/clojure.inspector-api.html">http://clojure.github.io/clojure/clojure.inspector-api.html</a>
</li>

<li>The Clojure Toolbox<br />
<a href="http://www.clojure-toolbox.com/">http://www.clojure-toolbox.com/</a>
</li>

<li>Unit Testing in Clojure<br />
<a href="http://nakkaya.com/2009/11/18/unit-testing-in-clojure/">http://nakkaya.com/2009/11/18/unit-testing-in-clojure/</a>
</li>

<li>Testing in Clojure (Part-1: Unit testing)<br />
<a href="http://blog.knoldus.com/2014/03/22/testing-in-clojure-part-1-unit-testing/">http://blog.knoldus.com/2014/03/22/testing-in-clojure-part-1-unit-testing/</a>
</li>

<li>API for clojure.test - Clojure v1.6 (stable)<br />
<a href="https://clojure.github.io/clojure/clojure.test-api.html">https://clojure.github.io/clojure/clojure.test-api.html</a>
</li>

<li>Leiningen: úvodní stránka<br />
<a href="http://leiningen.org/">http://leiningen.org/</a>
</li>

<li>Leiningen: Git repository<br />
<a href="https://github.com/technomancy/leiningen">https://github.com/technomancy/leiningen</a>
</li>

<li>leiningen-win-installer<br />
<a href="http://leiningen-win-installer.djpowell.net/">http://leiningen-win-installer.djpowell.net/</a>
</li>

<li>Clojure.org: Vars and the Global Environment<br />
<a href="http://clojure.org/Vars">http://clojure.org/Vars</a>
</li>

<li>Clojure.org: Refs and Transactions<br />
<a href="http://clojure.org/Refs">http://clojure.org/Refs</a>
</li>

<li>Clojure.org: Atoms<br />
<a href="http://clojure.org/Atoms">http://clojure.org/Atoms</a>
</li>

<li>Clojure.org: Agents as Asynchronous Actions<br />
<a href="http://clojure.org/agents">http://clojure.org/agents</a>
</li>

<li>Transient Data Structures
<a href="http://clojure.org/transients">http://clojure.org/transients</a>
</li>

</ol>



<p></p><p></p>
<p><small>Autor: <a href="http://www.fit.vutbr.cz/~tisnovpa">Pavel Tišnovský</a> &nbsp; 2016</small></p>
</body>
</html>

