<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
        "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html>
<head>
<title>Práce s externími Java archivy v programovacím jazyku Clojure</title>
<meta name="Author" content="Pavel Tisnovsky" />
<meta name="Generator" content="vim" />
<meta http-equiv="content-type" content="text/html; charset=utf-8" />
<style type="text/css">
         body {color:#000000; background:#ffffff;}
         h1  {font-family: arial, helvetica, sans-serif; color:#ffffff; background-color:#c00000; text-align:center; padding-left:1em}
         h2  {font-family: arial, helvetica, sans-serif; color:#ffffff; background-color:#0000c0; padding-left:1em; text-align:left}
         h3  {font-family: arial, helvetica, sans-serif; color:#000000; background-color:#c0c0c0; padding-left:1em; text-align:left}
         h4  {font-family: arial, helvetica, sans-serif; color:#000000; background-color:#e0e0e0; padding-left:1em; text-align:left}
         a   {font-family: arial, helvetica, sans-serif;}
         li  {font-family: arial, helvetica, sans-serif; color:#000000; text-align:justify; width:450px;}
         ol  {font-family: arial, helvetica, sans-serif; color:#000000; text-align:justify; width:450px;}
         ul  {font-family: arial, helvetica, sans-serif; color:#000000; text-align:justify; width:450px;}
         p   {font-family: arial, helvetica, sans-serif; color:#000000; text-align:justify;}
         pre {background:#e0e0e0}
</style>
</head>

<body>

<h1>Práce s externími Java archivy v programovacím jazyku Clojure</h1>

<h3>Pavel Tišnovský</h3>

<p></p>

<h1>Úvodník</h1>

<p>Při práci s&nbsp;projekty psanými v&nbsp;programovacím jazyce Clojure se dnes používá nástroj Leiningen, s&nbsp;jehož možnostmi jsme se již v&nbsp;tomto seriálu seznámili. Dnes si ukážeme řešení jednoho problému z&nbsp;praxe &ndash; přidání Java archivů (obsahujících například databázové drivery) do projektu.</p>



<h2>Obsah</h2>

<p><a href="#k01">1. Práce s&nbsp;externími Java archivy v&nbsp;programovacím jazyku Clojure</a></p>
<p><a href="#k02">2. První demonstrační příklad &ndash; malé zopakování: vložení přeložených tříd do projektu</a></p>
<p><a href="#k03">3. Vytvoření a otestování (uber)archivu s&nbsp;projektem</a></p>
<p><a href="#k04">4. Druhý demonstrační příklad &ndash; přidání Java archivu do podadresáře <strong>resources</strong></a></p>
<p><a href="#k05">5. Přímé spuštění projektu nástrojem Leiningen a otestování nastavení CLASSPATH</a></p>
<p><a href="#k06">6. Vytvoření a otestování (uber)archivu s&nbsp;projektem</a></p>
<p><a href="#k07">7. Korektní řešení &ndash; použití lokálního Maven repositáře</a></p>
<p><a href="#k08">8. Pomocný projekt určený pro vložení externího Java archivu do lokálního Maven repositáře</a></p>
<p><a href="#k09">9. Vygenerování artefaktu pro lokální Maven repositář</a></p>
<p><a href="#k10">10. Vytvořený artefakt</a></p>
<p><a href="#k11">11. Třetí demonstrační příklad &ndash; přidání závislosti do našeho projektu</a></p>
<p><a href="#k12">12. Vytvoření a otestování (uber)archivu s&nbsp;projektem</a></p>
<p><a href="#k13">13. Odkazy na předchozí části tohoto seriálu</a></p>
<p><a href="#k14">14. Odkazy na Internetu</a></p>



<p><a name="k01"></a></p>
<h2 id="k01">1. Práce s&nbsp;externími Java archivy v&nbsp;programovacím jazyku Clojure</h2>

<p>V&nbsp;úvodních částech seriálu o programovacím jazyce Clojure jsme se
seznámili s&nbsp;některými možnostmi, které vývojářům nabízí nástroj
<i>Leiningen</i>. Připomeňme si jen ve stručnosti, že se jedná o
multiplatformního správce projektů, který je rozšiřitelný pomocí takzvaných
pluginů a který interně používá Maven, čehož si však mnozí vývojáři ani nemusí
všimnout. Mezi základní úlohy, které nástroj <i>Leiningen</i> vývojářům nabízí,
patří:</p>

<ol>

<li>Vytvoření nového projektu na základě vybrané a předem připravené šablony.
K&nbsp;dispozici jsou šablony běžné aplikace (doplněné o jednotkové testy),
přídavného modulu pro samotný <i>Leiningen</i> atd. Základním příkazem je
<strong>lein new</strong>.</li>

<li>Automatické stažení všech knihoven a jejich závislostí na základě
konfigurace zapsané do souboru <strong>project.clj</strong>. Tuto funkci
zajistí příkaz <strong>lein deps</strong>.</li>

<li>Spuštění projektu s&nbsp;možností předání parametrů příkazového řádku.
Příkaz je v&nbsp;tomto případě jednoduchý: <strong>lein run</strong>.</li>

<li>Spuštění jednotkových testů, které mohou být vytvořeny společně
s&nbsp;projektem (kostra jednoho testu je připravena automaticky). Snadno
uhádnutelný příkaz, který testy spustí, se jmenuje <strong>lein
test</strong>.</li>

<li>Relativně rychlá kontrola syntaxe zdrojových kódů i kontrola existence
volaných metod (<strong>lein check</strong>).</li>

<li>Lokální instalace projektu do specifikovaného adresáře (<strong>lein
install</strong>).</li>

<li>Příprava Java archivu (souboru s&nbsp;koncovkou .jar) takovým způsobem, aby
bylo možné aplikaci nasadit i na jiném počítači. V&nbsp;rámci přípravy archivu
se provádí překlad vybraných modulů do Javovského bajtkódu (<strong>lein
jar</strong>).</li>

<li>Příprava Java archivu obsahujícího i všechny závislé knihovny včetně
samotného <i>Clojure</i>. Takto vytvořený &bdquo;uberjar&ldquo; je posléze
možné nasadit na jakémkoli počítači vybaveném pouze JRE (běhovým prostředím
jazyka Java). Zajistí příkaz <strong>lein uberjar</strong>. Právě některými
vlastnostmi tohoto příkazu se dnes budeme zabývat.</li>

<li>Spuštění smyčky REPL s&nbsp;nastavením cest ke všem potřebným knihovnám a
modulům (<strong>lein repl</strong>).</li>

<li>Diagnostické příkazy, z&nbsp;nichž dnes využijeme především příkaz
<strong>lein classpath</strong> určený pro výpis aktuálně nastaveného seznamu
cest k&nbsp;třídám a dalším zdrojům.</li>

<li>Každý příkaz <i>Leiningenu</i> je v&nbsp;rozumné míře popsán
v&nbsp;nápovědě (<strong>lein help příkaz</strong>).</li>

</ol>



<p><a name="k02"></a></p>
<h2 id="k02">2. První demonstrační příklad &ndash; malé zopakování: vložení přeložených tříd do projektu</h2>

<p>U většiny projektů, které jsou psány v&nbsp;programovacím jazyce Clojure se
nevyhneme nutnosti vhodným způsobem volat metody nějakých tříd vytvořených
v&nbsp;Javě a přeložených do bajtkódu, tedy do souborů <strong>.class</strong>.
Samotné vytváření (konstrukce) objektů, volání jejich metod či přístup
k&nbsp;atributům je v&nbsp;programovacím jazyce Clojure poměrně jednoduchý,
protože lze využít takzvané <i>java interop</i>. Co je ovšem neméně důležité
&ndash; interpret a překladač jazyka Clojure běží nad virtuálním strojem Javy
(JVM), který musí být informován o tom, na kterém místě či místech hledat třídy
přeložené do bajtkódu (jedná se o CLASSPATH, s&nbsp;níž se již pravděpodobně
všichni vývojáři používající Javu setkali). V&nbsp;případě, že se pro správu
projektů psaných v&nbsp;Clojure používá nástroj <i>Leiningen</i>, je nastavení
CLASSPATH ponecháno právě tomuto nástroji, což s&nbsp;sebou může přinášet
některé problémy, které souvisejí s&nbsp;použitím externích Java archivů.
Musíme být totiž schopni:</p>

<ol>

<li>Spustit interaktivní smyčku REPL a přitom mít k&nbsp;dispozici všechny
potřebné třídy a knihovny.</li>

<li>Vytvořit JAR archiv bez dalších závislostí, ty se přidají na
CLASSPATH.</li>

<li>Vytvořit &bdquo;uberjar&ldquo; obsahující naprosto všechny závislosti
(takový archiv vyžaduje ke svému běhu pouze JVM, nic jiného).</li>

</ol>

<p>Podívejme se nejdříve na zjednodušený příklad, v&nbsp;němž budeme potřebovat
volat Javovskou metodu uloženou v&nbsp;bajtkódu (tedy v&nbsp;souboru typu
<strong>class</strong>). Nejdříve vytvoříme kostru nového projektu:</p>

<pre>
<strong>lein new app external-jar-1</strong>
</pre>

<p>Vytvořená kostra projektu je tvořena standardizovanou adresářovou
strukturou:</p>

<pre>
<strong>tree</strong>
&nbsp;
.
├── doc
│   └── intro.md
├── LICENSE
├── project.clj
├── README.md
├── resources
├── src
│   └── external_jar_1
│       └── core.clj
└── test
    └── external_jar_1
        └── core_test.clj
&nbsp;
6 directories, 6 files
</pre>

<p>Nejdůležitější je soubor <strong>project.clj</strong>, protože jeho obsahem
se řídí nástroj <i>Leiningen</i> při provádění všech úkolů:</p>

<pre>
(defproject external-jar-1 "0.1.0-SNAPSHOT"
    :description "FIXME: write description"
    :url "http://example.com/FIXME"
    :license {:name "Eclipse Public License"
              :url "http://www.eclipse.org/legal/epl-v10.html"}
    :dependencies [[org.clojure/clojure "1.6.0"]]
    :main ^:skip-aot external-jar-1.core
    :target-path "target/%s"
    :profiles {:uberjar {:aot :all}})
</pre>

<p>Do projektu přidáme zdrojový kód třídy naprogramované v&nbsp;Javě. Pro
jednoduchost se tento soubor nazvaný <strong>PrintHello</strong> umístí do
podadresáře <strong>resources</strong>:</p>

<pre>
<strong>tree</strong>
&nbsp;
.
├── doc
│   └── intro.md
├── LICENSE
├── project.clj
├── README.md
├── resources
│   └── PrintHello.java
├── src
│   └── external_jar_1
│       └── core.clj
└── test
    └── external_jar_1
        └── core_test.clj
&nbsp;
6 directories, 7 files
</pre>

<p>Soubor <strong>PrintHello.java</strong> obsahuje pro jednoduchost třídu
s&nbsp;jedinou statickou metodou:</p>

<pre>
public class PrintHello {
    public static void printHello() {
        System.out.println("Hello world!");
    }
}
</pre>

<p>Tato statická metoda se volá z&nbsp;hlavního programu
(<strong>core.clj</strong>) následovně:</p>

<pre>
(ns external-jar-1.core
    (:gen-class))
&nbsp;
(defn -main
    "Vstupni bod do aplikace."
    [&amp; args]
    (PrintHello/printHello))
</pre>



<p><a name="k03"></a></p>
<h2 id="k03">3. Vytvoření a otestování (uber)archivu s&nbsp;projektem</h2>

<p>Aby bylo možné metodu ze třídy <strong>PrintHello</strong> použít, musíme
třídu přeložit (ručně nebo z&nbsp;IDE):</p>

<pre>
<strong>pushd resources</strong>
<strong>javac PrintHello.java</strong>
<strong>popd</strong>
</pre>

<p>Následně můžeme program spustit, a to přímo nástrojem Leiningen:</p>

<pre>
<strong>lein run</strong>
&nbsp;
Hello world!
</pre>

<p>Vše funguje v&nbsp;pořádku, a to z&nbsp;toho důvodu, že obsah adresáře
<strong>resources</strong> je automaticky uložen na CLASSPATH, o čemž se můžeme
velmi snadno přesvědčit:</p>

<pre>
<strong>lein classpath</strong>
&nbsp;
/home/tester/temp/clojure-examples/p1/external-jar-1/test:
/home/tester/temp/clojure-examples/p1/external-jar-1/src:
/home/tester/temp/clojure-examples/p1/external-jar-1/dev-resources:
<strong>/home/tester/temp/clojure-examples/p1/external-jar-1/resources</strong>:
/home/tester/temp/clojure-examples/p1/external-jar-1/target/base+system+user+dev/classes:
/home/tester/.m2/repository/clojure-complete/clojure-complete/0.2.3/clojure-complete-0.2.3.jar:
/home/tester/.m2/repository/org/clojure/tools.nrepl/0.2.6/tools.nrepl-0.2.6.jar:
/home/tester/.m2/repository/org/clojure/clojure/1.6.0/clojure-1.6.0.jar
</pre>

<p>Při distribuci programu popř.&nbsp;před jeho nasazením na testovací a
produkční servery se většinou provádí vytvoření &bdquo;uberjaru&ldquo;, který
obsahuje jak vlastní program v&nbsp;Clojure přeložený do bajtkódu, tak i
všechny závislé knihovny, včetně knihoven samotného Clojure. Vytvoření
&bdquo;uberjaru&ldquo; je jednoduché a zajistí ho následující tři příkazy (ve
skutečnosti postačuje použít jen příkaz poslední, ovšem vyčištěním adresáře
<strong>target</strong> se nic nezkazí):</p>

<pre>
<strong>lein clean</strong>
<strong>lein deps</strong>
<strong>lein uberjar</strong>
</pre>

<p>Výsledek je uložený v&nbsp;adresáři <strong>target/uberjar/</strong>, takže
ho lze snadno otestovat:</p>

<pre>
<strong>java -jar target/uberjar/external-jar-1-0.1.0-SNAPSHOT-standalone.jar</strong>
&nbsp;
Hello world!
</pre>

<p>Proč tento program funguje, tj.&nbsp;proč není problém s&nbsp;načtením třídy
<strong>PrintHello</strong> osvětlí náhled do vytvořeného Java archivu:</p>

<pre>
<strong>unzip -l target/uberjar/external-jar-1-0.1.0-SNAPSHOT-standalone.jar |grep PrintHello</strong>
&nbsp;
117  2016-09-12 19:09   PrintHello.java
407  2016-09-12 21:17   PrintHello.class
</pre>



<p><a name="k04"></a></p>
<h2 id="k04">4. Druhý demonstrační příklad &ndash; přidání Java archivu do podadresáře <strong>resources</strong></h2>

<p>Ve druhém demonstračním příkladu si situaci poněkud zesložitíme, protože
namísto pouhých <strong>.class</strong> souborů budeme chtít do projektu přidat
celý Java archiv. Opět si pro začátek vytvoříme kostru nového projektu:</p>

<pre>
<strong>lein new app external-jar-2</strong>
</pre>

<p>Soubor <strong>src/external_jar_2/core.clj</strong> vypadá stále stejně,
samozřejmě až na rozdílné jméno projektu:</p>

<pre>
(ns external-jar-2.core
  (:gen-class))
&nbsp;
(defn -main
    "Vstupni bod do aplikace."
    [&amp; args]
    (PrintHello/printHello))
&nbsp;
</pre>

<p>Do adresáře <strong>resources</strong> však vložíme pouze Java archiv a pro
jistotu vymažeme původní zdrojový kód i vygenerovaný bajtkód:</p>

<pre>
<strong>pushd resources</strong>
<strong>javac PrintHello.java</strong>
<strong>jar cvf PrintHello.jar PrintHello.class </strong>
added manifest
adding: PrintHello.class(in = 407) (out= 278)(deflated 31%)
<strong>rm PrintHello.java PrintHello.class</strong>
<strong>popd</strong>
</pre>

<p>Struktura projektu nyní vypadá následovně:</p>

<pre>
.
├── doc
│   └── intro.md
├── LICENSE
├── project.clj
├── README.md
├── resources
│   └── PrintHello.jar
├── src
│   └── external_jar_2
│       └── core.clj
└── test
    └── external_jar_2
        └── core_test.clj
&nbsp;
6 directories, 7 files
</pre>



<p><a name="k05"></a></p>
<h2 id="k05">5. Přímé spuštění projektu nástrojem Leiningen a otestování nastavení CLASSPATH</h2>

<p>Java archiv s&nbsp;testovací třídou <strong>PrintHello</strong> je vytvořen
a uložen do správného adresáře <strong>resources</strong>, takže by se mohlo
zdát, že je vše v&nbsp;pořádku. Při pokusu o spuštění aplikace však dojde
k&nbsp;chybě:</p>

<pre>
<strong>lein run</strong>
&nbsp;
Exception in thread "main" java.lang.RuntimeException: No such namespace: PrintHello, compiling:(external_jar_2/core.clj:9:5)
        at clojure.lang.Compiler.analyze(Compiler.java:6464)
        at clojure.lang.Compiler.analyze(Compiler.java:6406)
...
...
...
... spousta více či méně neužitečných řádků :-)
...
...
...
        at clojure.main.main(main.java:37)
Caused by: java.lang.RuntimeException: No such namespace: PrintHello
        at clojure.lang.Util.runtimeException(Util.java:221)
        at clojure.lang.Compiler.resolveIn(Compiler.java:6910)
        at clojure.lang.Compiler.resolve(Compiler.java:6884)
        at clojure.lang.Compiler.analyzeSymbol(Compiler.java:6845)
        at clojure.lang.Compiler.analyze(Compiler.java:6427)
        ... 52 more
</pre>

<p>Proč k&nbsp;chybě došlo osvětlí nám již známý diagnostický příkaz:</p>

<pre>
/home/tester/temp/clojure-examples/p1/external-jar-2/test:
/home/tester/temp/clojure-examples/p1/external-jar-2/src:
/home/tester/temp/clojure-examples/p1/external-jar-2/dev-resources:
/home/tester/temp/clojure-examples/p1/external-jar-2/resources:
/home/tester/temp/clojure-examples/p1/external-jar-2/target/base+system+user+dev/classes:
/home/tester/.m2/repository/clojure-complete/clojure-complete/0.2.3/clojure-complete-0.2.3.jar:
/home/tester/.m2/repository/org/clojure/tools.nrepl/0.2.6/tools.nrepl-0.2.6.jar:
/home/tester/.m2/repository/org/clojure/clojure/1.6.0/clojure-1.6.0.jar
</pre>

<p>Vidíme, že nikde není nastavena přímá cesta k&nbsp;souboru
<strong>PrintHello.jar</strong>! Jak ji však lze nastavit? Pokud bychom
spouštěli JVM standardní cestou, stačilo by samozřejmě ruční nastavení
CLASSPATH, ovšem při použití projektu <i>Leiningen</i>, který se stará o
inicializaci JVM, je nutné použít odlišné řešení, a to konkrétně úpravu
projektového souboru <strong>project.clj</strong>. Povšimněte si zvýrazněného
řádku:</p>

<pre>
(defproject external-jar-2 "0.1.0-SNAPSHOT"
    :description "FIXME: write description"
    :url "http://example.com/FIXME"
    :license {:name "Eclipse Public License"
              :url "http://www.eclipse.org/legal/epl-v10.html"}
    :dependencies [[org.clojure/clojure "1.6.0"]]
    :main ^:skip-aot external-jar-2.core
    :target-path "target/%s"
    <strong>:resource-paths ["resources/PrintHello.jar"]</strong>
    :profiles {:uberjar {:aot :all}})
</pre>

<p>Za klíčem <strong>:resource-paths</strong> je vektor cest k&nbsp;Java
archivům i dalším prostředkům. Zkusme test znovu:</p>

<pre>
<strong>lein run</strong>
&nbsp;
Hello world!
</pre>

<p>Výborně, ještě si pro jistotu vypišme nastavení cest:</p>

<pre>
/home/tester/temp/clojure-examples/p1/external-jar-2/test:
/home/tester/temp/clojure-examples/p1/external-jar-2/src:
/home/tester/temp/clojure-examples/p1/external-jar-2/dev-resources:
<strong>/home/tester/temp/clojure-examples/p1/external-jar-2/resources/PrintHello.jar:</strong>
/home/tester/temp/clojure-examples/p1/external-jar-2/target/base+system+user+dev/classes:
/home/tester/.m2/repository/clojure-complete/clojure-complete/0.2.3/clojure-complete-0.2.3.jar:
/home/tester/.m2/repository/org/clojure/tools.nrepl/0.2.6/tools.nrepl-0.2.6.jar:
/home/tester/.m2/repository/org/clojure/clojure/1.6.0/clojure-1.6.0.jar
</pre>

<p>Vše je &ndash; alespoň pro tuto chvíli &ndash; v&nbsp;pořádku.</p>



<p><a name="k06"></a></p>
<h2 id="k06">6. Vytvoření a otestování (uber)archivu s&nbsp;projektem</h2>

<p>Vzhledem k&nbsp;tomu, že přímé spuštění aplikace nástrojem <i>Leiningen</i>
bylo úspěšné, mohlo by se zdát, že stejně úspěšné bude i vytvoření
&bdquo;uberjaru&ldquo; a jeho případné nasazení na testovací server. Pojďme si
tedy celý proces odzkoušet, a to již známými kroky popsanými v&nbsp;předchozích
kapitolách:</p>

<pre>
<strong>lein clean</strong>
<strong>lein deps</strong>
<strong>lein uberjar</strong>
</pre>

<p>Očekávaný &bdquo;uberjar&ldquo; se skutečně vytvořil, a to opět
v&nbsp;podadresáři <strong>targets</strong>, ovšem při pokusu o spuštění
aplikace již nebudeme tak úspěšní:</p>

<pre>
<strong>java -jar target/uberjar/external-jar-2-0.1.0-SNAPSHOT-standalone.jar</strong>
&nbsp;
Exception in thread "main" java.lang.NoClassDefFoundError: PrintHello
        at external_jar_2.core$_main.doInvoke(core.clj:6)
        at clojure.lang.RestFn.invoke(RestFn.java:397)
        at clojure.lang.AFn.applyToHelper(AFn.java:152)
        at clojure.lang.RestFn.applyTo(RestFn.java:132)
        at external_jar_2.core.main(Unknown Source)
Caused by: java.lang.ClassNotFoundException: PrintHello
        at java.net.URLClassLoader$1.run(URLClassLoader.java:366)
        at java.net.URLClassLoader$1.run(URLClassLoader.java:355)
        at java.security.AccessController.doPrivileged(Native Method)
        at java.net.URLClassLoader.findClass(URLClassLoader.java:354)
        at java.lang.ClassLoader.loadClass(ClassLoader.java:425)
        at sun.misc.Launcher$AppClassLoader.loadClass(Launcher.java:308)
        at java.lang.ClassLoader.loadClass(ClassLoader.java:358)
        ... 5 more
</pre>

<p>Příčinu tohoto neúspěchu musíme hledat v&nbsp;tom, že se obsah podadresáře
<strong>resources</strong> při tvorbě Java archivu (&bdquo;uberjaru&ldquo;)
prostě bez dalších zásahů vloží do vytvářeného archivu, takže vlastně získáme
&bdquo;JAR v&nbsp;JARu&ldquo;, což v&nbsp;tomto případě není korektní a zejména
to není příjemné pro případné uživatele aplikace. Ostatně můžeme si to
vyzkoušet sami:</p>

<pre>
<strong>unzip -l target/uberjar/external-jar-2-0.1.0-SNAPSHOT-standalone.jar | grep PrintHello</strong>
&nbsp;
      743  2016-09-12 19:13   PrintHello.jar
</pre>



<p><a name="k07"></a></p>
<h2 id="k07">7. Korektní řešení &ndash; použití lokálního Maven repositáře</h2>

<p>Vzhledem k&nbsp;tomu, že nástroj <i>Leiningen</i> interně používá Maven
repositáře, spočívá (pravděpodobně jediné) korektní řešení v&nbsp;tom, že
z&nbsp;externího Java archivu, který budeme chtít do projektu přidat, vytvoříme
v&nbsp;lokálním Maven repositáři, který většinou nalezneme v&nbsp;adresáři
<strong>~/.m2</strong>, nový artefakt. Tento adresář by měl být vytvořen
minimálně ve chvíli instalace <i>Leiningenu</i>; pokud však adresář
<strong>~/.m2</strong> nemůžete nalézt, vypište si nastavení proměnné prostředí
<strong>M2_HOME</strong>, zda neukazuje na jiný adresář. Vraťme se však
k&nbsp;našemu problému. Pokud máme nějaký Java archiv &ndash; typicky to bývají
databázové drivery, k&nbsp;nimž nutně nemusí existovat zdrojové kódy &ndash; a
potřebujeme ho distribuovat či nasazovat společně s&nbsp;aplikací, lze toho
dosáhnout korektnějším způsobem, než pouhým uložením Java archivu do
podadresáře <strong>resources</strong>. Doporučený způsob se skládá ze čtyř
kroků:</p>

<ol>

<li>Použití pomocného projektu založeného na pluginu nazvaném
<strong>lein-localrepo</strong>.</li>

<li>Vygenerování artefaktu s&nbsp;Java archivem v&nbsp;lokálním Maven
repositáři.</li>

<li>Vložením příslušného řádku se jménem a verzí knihovny do projektového
souboru (klíč <strong>:dependencies</strong> v&nbsp;souboru
<strong>project.clj</strong>).</li>

<li>Vytvořením &bdquo;uberjaru&ldquo;, který nyní bude mít korektní obsah.</li>

</ol>

<p>Jednotlivé kroky si podrobněji popíšeme v&nbsp;navazujících kapitolách.</p>



<p><a name="k08"></a></p>
<h2 id="k08">8. Pomocný projekt určený pro vložení externího Java archivu do lokálního Maven repositáře</h2>

<p>Prvním krokem je vytvoření pomocného projektu, který nám bude sloužit
<i>pouze</i> pro vygenerování lokálních artefaktů. Striktně řečeno vlastně ani
není nezbytně nutné tento pomocný projekt vytvářet a používat, protože
příslušný plugin lze specifikovat v&nbsp;libovolném jiném projektu, ale
striktním oddělením tvorby artefaktu od zbytku &bdquo;hlavního&ldquo; projektu
můžeme celé problematice lépe porozumět. Vytvořme si tedy kostru zpočátku zcela
prázdného projektu:</p>

<pre>
<strong>lein new app maven-artefact-generator</strong>
</pre>

<p>Následně provedeme úpravu projektového souboru přidáním klíče
<strong>:plugins</strong>. Obsahem tohoto klíče je vektor, přičemž každý prvek
vektoru specifikuje jeden plugin pro nástroj <i>Leiningen</i>. Na pluginy se
můžeme dívat také jako na běžné knihovny, které ovšem do <i>Leiningenu</i>
přidávají další cíle (při volání z&nbsp;CLI nové příkazy, ostatně již jsme si
popisovali plugin <strong>codox</strong> či <strong>cloverage</strong>):</p>

<pre>
(defproject teiid-module "0.1.0-SNAPSHOT"
    :description "FIXME: write description"
    :url "http://example.com/FIXME"
    :license {:name "GNU General Public License"
              :url "https://gnu.org/licenses/gpl.html"}
    :dependencies [[org.clojure/clojure "1.7.0"]]
    <strong>:plugins [[lein-localrepo "0.5.3"]]</strong>
    :target-path "target/%s"
    :profiles {:uberjar {:aot :all}})
</pre>

<p>Nově požadovaný plugin si i s&nbsp;jeho závislostmi stáhneme:</p>

<pre>
<strong>lein deps</strong>
</pre>

<p>Nyní je tento pomocný projekt připraven a můžeme ho použít pro vytvoření
artefaktů pro lokální Maven repositář.</p>



<p><a name="k09"></a></p>
<h2 id="k09">9. Vygenerování artefaktu pro lokální Maven repositář</h2>

<p>Podívejme se nyní na způsob vytvoření nového artefaktu. Nejprve do adresáře
pomocného projektu zkopírujeme soubor <strong>PrintHello.jar</strong>, který
jsme vytvořili <a href="#k04">ve čtvrté kapitole</a>. Následně použijeme příkaz
<strong>lein localrepo</strong>. Jak již zajisté tušíte, je tento nový příkaz
zajišťován právě díky pluginu <strong>lein-localrepo</strong> a bude tedy
fungovat pouze tehdy, když se nacházíme v&nbsp;daném projektu (o tom se ostatně
sami můžete přesvědčit spuštěním příkazu <strong>lein</strong> bez parametrů
uvnitř projektu a mimo pomocný projekt).</p>

<p>Příkaz <strong>lein localrepo</strong> nabízí několik variant spuštění. My
konkrétně využijeme variantu <strong>install</strong>, které se předá název
Java archivu, název artefaktu a jeho verze (tyto dva údaje si zapamatujte):</p>

<pre>
<strong>lein localrepo install resources/PrintHello.jar PrintHello 1.0.0</strong>
</pre>

<p>V&nbsp;adresáři s&nbsp;artefakty by se měl po zadání tohoto příkazu objevit
nový podadresář <strong>PrintHello</strong> s&nbsp;následujícím obsahem:</p>

<pre>
<strong>tree ~/.m2/repository/PrintHello</strong>
&nbsp;
/home/tester/.m2/repository/PrintHello
└── PrintHello
    ├── 1.0.0
    │   ├── _maven.repositories
    │   ├── PrintHello-1.0.0.jar
    │   └── PrintHello-1.0.0.pom
    └── maven-metadata-local.xml
&nbsp;
2 directories, 4 files
</pre>



<p><a name="k10"></a></p>
<h2 id="k10">10. Vytvořený artefakt</h2>

<p>Zajímavé (i když nikoli nezbytné!) může být prozkoumání XML souborů
s&nbsp;metadaty o nové knihovně:</p>

<pre>
<strong>cat ~/.m2/repository/PrintHello/PrintHello/maven-metadata-local.xml</strong>
&nbsp;
&lt;?xml version="1.0" encoding="UTF-8"?&gt;
&lt;metadata&gt;
  &lt;groupId&gt;PrintHello&lt;/groupId&gt;
  &lt;artifactId&gt;PrintHello&lt;/artifactId&gt;
  &lt;versioning&gt;
    &lt;release&gt;1.0.0&lt;/release&gt;
    &lt;versions&gt;
      &lt;version&gt;1.0.0&lt;/version&gt;
    &lt;/versions&gt;
    &lt;lastUpdated&gt;20160912174143&lt;/lastUpdated&gt;
  &lt;/versioning&gt;
&lt;/metadata&gt;
</pre>

<p>A dále pak prozkoumání souboru popisujícího artefakt:</p>

<pre>
<strong>cat ~/.m2/repository/PrintHello/PrintHello/1.0.0/PrintHello-1.0.0.pom</strong>
&nbsp;
&lt;?xml version="1.0" encoding="UTF-8"?&gt;
&lt;project xmlns="http://maven.apache.org/POM/4.0.0" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:schemaLocation="http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd"&gt;
  &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt;
  &lt;groupId&gt;PrintHello&lt;/groupId&gt;
  &lt;artifactId&gt;PrintHello&lt;/artifactId&gt;
  &lt;version&gt;1.0.0&lt;/version&gt;
  &lt;name&gt;PrintHello&lt;/name&gt;
&lt;/project&gt;
</pre>



<p><a name="k11"></a></p>
<h2 id="k11">11. Třetí demonstrační příklad &ndash; přidání závislosti do našeho projektu</h2>

<p>Nyní si ukažme, jakým způsobem se vlastně nový modul použije. Je to ve
skutečnosti velmi jednoduché až triviální, protože všechny potřebné znalosti
již známe z&nbsp;dřívějška. Postačuje do projektu vložit zvýrazněný řádek a
současně odstranit předchozí řádek s&nbsp;klíčem
<strong>:resource-paths</strong>. Projektový soubor může vypadat
následovně:</p>

<pre>
(defproject external-jar-3 "0.1.0-SNAPSHOT"
  :description "FIXME: write description"
  :url "http://example.com/FIXME"
  :license {:name "Eclipse Public License"
            :url "http://www.eclipse.org/legal/epl-v10.html"}
  :dependencies [[org.clojure/clojure "1.6.0"]
                 <strong>[PrintHello "1.0.0"]</strong>]
  :main ^:skip-aot external-jar-3.core
  :target-path "target/%s"
  :profiles {:uberjar {:aot :all}})
</pre>

<p>Příkaz <strong>lein deps</strong> se již nebude pokoušet o hledání modulu
<strong>PrintHello</strong>, protože ho v&nbsp;adresáři <strong>~/.m2</strong>
nalezne (samozřejmě musíte použít shodné jméno i číslo verze!).</p>

<p>Projekt půjde přímo spustit:</p>

<pre>
<strong>lein run</strong>
&nbsp;
Hello world!
</pre>

<p>Zajímavé je nastavení CLASSPATH (opět zvýrazním, řádek, který je v&nbsp;tuto
chvíli důležitý):</p>

<pre>
/home/tester/temp/clojure-examples/p1/external-jar-3/test:
/home/tester/temp/clojure-examples/p1/external-jar-3/src:
/home/tester/temp/clojure-examples/p1/external-jar-3/dev-resources:
/home/tester/temp/clojure-examples/p1/external-jar-3/resources:
/home/tester/temp/clojure-examples/p1/external-jar-3/target/base+system+user+dev/classes:
/home/tester/.m2/repository/clojure-complete/clojure-complete/0.2.3/clojure-complete-0.2.3.jar:
/home/tester/.m2/repository/org/clojure/tools.nrepl/0.2.6/tools.nrepl-0.2.6.jar:
<strong>/home/tester/.m2/repository/PrintHello/PrintHello/1.0.0/PrintHello-1.0.0.jar:</strong>
/home/tester/.m2/repository/org/clojure/clojure/1.6.0/clojure-1.6.0.jar
</pre>



<p><a name="k12"></a></p>
<h2 id="k12">12. Vytvoření a otestování (uber)archivu s&nbsp;projektem</h2>

<p>V&nbsp;tento okamžik již <i>Leiningen</i> pracuje s&nbsp;modulem
<strong>PrintHello</strong> stejně, jako s&nbsp;jakýmkoli jiným modulem, takže
můžeme bez problémů vytvořit funkční &bdquo;uberjar&ldquo;:</p>

<pre>
<strong>lein clean</strong>
<strong>lein deps</strong>
<strong>lein uberjar</strong>
</pre>

<p>Spuštění aplikace z&nbsp;vytvořeného Java archivu proběhne bez chyby:</p>

<pre>
<strong>java -jar target/uberjar/external-jar-2-0.1.0-SNAPSHOT-standalone.jar</strong>
&nbsp;
Hello world!
</pre>

<p>Výpisem obsahu Java archivu zjistíme, že v&nbsp;tomto případě již nemáme
&bdquo;JAR v&nbsp;JARu&ldquo;, ale správný obsah:</p>

<pre>
<strong>unzip -l target/uberjar/external-jar-3-0.1.0-SNAPSHOT-standalone.jar | grep PrintHello</strong>
&nbsp;
      407  2016-09-12 19:12   PrintHello.class
</pre>

<p>Poznámka: na rozdíl od prvního příkladu se v&nbsp;Java archivu nenachází
původní zdrojový soubor <strong>PrintHello.java</strong>, a to samozřejmě
z&nbsp;toho důvodu, že tento soubor nebyl uložen do
<strong>PrintHello.jar</strong>.</p>



<p><a name="k13"></a></p>
<h2 id="k13">13. Odkazy na předchozí části tohoto seriálu</h2>

<ol>

<li>Clojure  1: Úvod<br />
<a href="http://www.root.cz/clanky/clojure-aneb-jazyk-umoznujici-tvorbu-bezpecnych-vicevlaknovych-aplikaci-pro-jvm/">http://www.root.cz/clanky/clojure-aneb-jazyk-umoznujici-tvorbu-bezpecnych-vicevlaknovych-aplikaci-pro-jvm/</a>
</li>

<li>Clojure  2: Symboly, kolekce atd.<br />
<a href="http://www.root.cz/clanky/clojure-aneb-jazyk-umoznujici-tvorbu-bezpecnych-vicevlaknovych-aplikaci-pro-jvm-2-cast/">http://www.root.cz/clanky/clojure-aneb-jazyk-umoznujici-tvorbu-bezpecnych-vicevlaknovych-aplikaci-pro-jvm-2-cast/</a>
</li>

<li>Clojure  3: Funkcionální programování<br />
<a href="http://www.root.cz/clanky/clojure-aneb-jazyk-umoznujici-tvorbu-bezpecnych-vicevlaknovych-aplikaci-pro-jvm-3-cast-funkcionalni-programovani/">http://www.root.cz/clanky/clojure-aneb-jazyk-umoznujici-tvorbu-bezpecnych-vicevlaknovych-aplikaci-pro-jvm-3-cast-funkcionalni-programovani/</a>
</li>

<li>Clojure  4: Kolekce, sekvence a lazy sekvence<br />
<a href="http://www.root.cz/clanky/clojure-aneb-jazyk-umoznujici-tvorbu-bezpecnych-vicevlaknovych-aplikaci-pro-jvm-4-cast-kolekce-sekvence-a-lazy-sekvence/">http://www.root.cz/clanky/clojure-aneb-jazyk-umoznujici-tvorbu-bezpecnych-vicevlaknovych-aplikaci-pro-jvm-4-cast-kolekce-sekvence-a-lazy-sekvence/</a>
</li>

<li>Clojure  5: Sekvence, lazy sekvence a paralelní programy<br />
<a href="http://www.root.cz/clanky/clojure-a-bezpecne-aplikace-pro-jvm-sekvence-lazy-sekvence-a-paralelni-programy/">http://www.root.cz/clanky/clojure-a-bezpecne-aplikace-pro-jvm-sekvence-lazy-sekvence-a-paralelni-programy/</a>
</li>

<li>Clojure  6: Podpora pro paralelní programování<br />
<a href="http://www.root.cz/clanky/programovaci-jazyk-clojure-6-futures-nejsou-jen-financni-derivaty/">http://www.root.cz/clanky/programovaci-jazyk-clojure-6-futures-nejsou-jen-financni-derivaty/</a>
</li>

<li>Clojure  7: Další funkce pro paralelní programování<br />
<a href="http://www.root.cz/clanky/programovaci-jazyk-clojure-7-dalsi-podpurne-prostredky-pro-paralelni-programovani/">http://www.root.cz/clanky/programovaci-jazyk-clojure-7-dalsi-podpurne-prostredky-pro-paralelni-programovani/</a>
</li>

<li>Clojure  8: Identity, stavy, neměnné hodnoty a reference<br />
<a href="http://www.root.cz/clanky/programovaci-jazyk-clojure-8-identity-stavy-nemenne-hodnoty-a-referencni-typy/">http://www.root.cz/clanky/programovaci-jazyk-clojure-8-identity-stavy-nemenne-hodnoty-a-referencni-typy/</a>
</li>

<li>Clojure  9: Validátory, pozorovatelé a kooperace s Javou<br />
<a href="http://www.root.cz/clanky/programovaci-jazyk-clojure-9-validatory-pozorovatele-a-kooperace-mezi-clojure-a-javou/">http://www.root.cz/clanky/programovaci-jazyk-clojure-9-validatory-pozorovatele-a-kooperace-mezi-clojure-a-javou/</a>
</li>

<li>Clojure 10: Kooperace mezi Clojure a Javou<br />
<a href="http://www.root.cz/clanky/programovaci-jazyk-clojure-10-kooperace-mezi-clojure-a-javou-pokracovani/">http://www.root.cz/clanky/programovaci-jazyk-clojure-10-kooperace-mezi-clojure-a-javou-pokracovani/</a>
</li>

<li>Clojure 11: Generátorová notace seznamu/list comprehension<br />
<a href="http://www.root.cz/clanky/programovaci-jazyk-clojure-11-generatorova-notace-seznamu-list-comprehension/">http://www.root.cz/clanky/programovaci-jazyk-clojure-11-generatorova-notace-seznamu-list-comprehension/</a>
</li>

<li>Clojure 12: Překlad programů z Clojure do bajtkódu JVM I:<br />
<a href="http://www.root.cz/clanky/programovaci-jazyk-clojure-12-preklad-programu-z-clojure-do-bajtkodu-jvm/">http://www.root.cz/clanky/programovaci-jazyk-clojure-12-preklad-programu-z-clojure-do-bajtkodu-jvm/</a>
</li>

<li>Clojure 13: Překlad programů z Clojure do bajtkódu JVM II:<br />
<a href="http://www.root.cz/clanky/programovaci-jazyk-clojure-13-preklad-programu-z-clojure-do-bajtkodu-jvm-pokracovani/">http://www.root.cz/clanky/programovaci-jazyk-clojure-13-preklad-programu-z-clojure-do-bajtkodu-jvm-pokracovani/</a>
</li>

<li>Clojure 14: Základy práce se systémem maker<br />
<a href="http://www.root.cz/clanky/programovaci-jazyk-clojure-14-zaklady-prace-se-systemem-maker/">http://www.root.cz/clanky/programovaci-jazyk-clojure-14-zaklady-prace-se-systemem-maker/</a>
</li>

<li>Clojure 15: Tvorba uživatelských maker<br />
<a href="http://www.root.cz/clanky/programovaci-jazyk-clojure-15-tvorba-uzivatelskych-maker/">http://www.root.cz/clanky/programovaci-jazyk-clojure-15-tvorba-uzivatelskych-maker/</a>
</li>

<li>Clojure 16: Složitější uživatelská makra<br />
<a href="http://www.root.cz/clanky/programovaci-jazyk-clojure-16-slozitejsi-uzivatelska-makra/">http://www.root.cz/clanky/programovaci-jazyk-clojure-16-slozitejsi-uzivatelska-makra/</a>
</li>

<li>Clojure 17: Využití standardních maker v praxi<br />
<a href="http://www.root.cz/clanky/programovaci-jazyk-clojure-17-vyuziti-standardnich-maker-v-praxi/">http://www.root.cz/clanky/programovaci-jazyk-clojure-17-vyuziti-standardnich-maker-v-praxi/</a>
</li>

<li>Clojure 18: Základní techniky optimalizace aplikací<br />
<a href="http://www.root.cz/clanky/programovaci-jazyk-clojure-18-zakladni-techniky-optimalizace-aplikaci/">http://www.root.cz/clanky/programovaci-jazyk-clojure-18-zakladni-techniky-optimalizace-aplikaci/</a>
</li>

<li>Clojure 19: Vývojová prostředí pro Clojure<br />
<a href="http://www.root.cz/clanky/programovaci-jazyk-clojure-19-vyvojova-prostredi-pro-clojure/">http://www.root.cz/clanky/programovaci-jazyk-clojure-19-vyvojova-prostredi-pro-clojure/</a>
</li>

<li>Clojure 20: Vývojová prostředí pro Clojure (Vimu s REPL)<br />
<a href="http://www.root.cz/clanky/programovaci-jazyk-clojure-20-vyvojova-prostredi-pro-clojure-integrace-vimu-s-repl/">http://www.root.cz/clanky/programovaci-jazyk-clojure-20-vyvojova-prostredi-pro-clojure-integrace-vimu-s-repl/</a>
</li>

<li>Clojure 21: ClojureScript aneb překlad Clojure do JS<br />
<a href="http://www.root.cz/clanky/programovaci-jazyk-clojure-21-clojurescript-aneb-preklad-clojure-do-javascriptu/">http://www.root.cz/clanky/programovaci-jazyk-clojure-21-clojurescript-aneb-preklad-clojure-do-javascriptu/</a>
</li>

<li>Leiningen: nástroj pro správu projektů napsaných v Clojure<br />
<a href="http://www.root.cz/clanky/leiningen-nastroj-pro-spravu-projektu-napsanych-v-clojure/">http://www.root.cz/clanky/leiningen-nastroj-pro-spravu-projektu-napsanych-v-clojure/</a>
</li>

<li>Leiningen: nástroj pro správu projektů napsaných v Clojure (2)<br />
<a href="http://www.root.cz/clanky/leiningen-nastroj-pro-spravu-projektu-napsanych-v-clojure-2/">http://www.root.cz/clanky/leiningen-nastroj-pro-spravu-projektu-napsanych-v-clojure-2/</a>
</li>

<li>Leiningen: nástroj pro správu projektů napsaných v Clojure (3)<br />
<a href="http://www.root.cz/clanky/leiningen-nastroj-pro-spravu-projektu-napsanych-v-clojure-3/">http://www.root.cz/clanky/leiningen-nastroj-pro-spravu-projektu-napsanych-v-clojure-3/</a>
</li>

<li>Leiningen: nástroj pro správu projektů napsaných v Clojure (4)<br />
<a href="http://www.root.cz/clanky/leiningen-nastroj-pro-spravu-projektu-napsanych-v-clojure-4/">http://www.root.cz/clanky/leiningen-nastroj-pro-spravu-projektu-napsanych-v-clojure-4/</a>
</li>

<li>Leiningen: nástroj pro správu projektů napsaných v Clojure (5)<br />
<a href="http://www.root.cz/clanky/leiningen-nastroj-pro-spravu-projektu-napsanych-v-clojure-5/">http://www.root.cz/clanky/leiningen-nastroj-pro-spravu-projektu-napsanych-v-clojure-5/</a>
</li>

<li>Leiningen: nástroj pro správu projektů napsaných v Clojure (6)<br />
<a href="http://www.root.cz/clanky/leiningen-nastroj-pro-spravu-projektu-napsanych-v-clojure-6/">http://www.root.cz/clanky/leiningen-nastroj-pro-spravu-projektu-napsanych-v-clojure-6/</a>
</li>

<li>Programovací jazyk Clojure a databáze (1.část)<br />
<a href="http://www.root.cz/clanky/programovaci-jazyk-clojure-a-databaze-1-cast/">http://www.root.cz/clanky/programovaci-jazyk-clojure-a-databaze-1-cast/</a>
</li>

<li>Pluginy pro Leiningen<br />
<a href="http://www.root.cz/clanky/leiningen-nastroj-pro-spravu-projektu-napsanych-v-clojure-pluginy-pro-leiningen/">http://www.root.cz/clanky/leiningen-nastroj-pro-spravu-projektu-napsanych-v-clojure-pluginy-pro-leiningen/</a>
</li>

<li>Programovací jazyk Clojure a knihovny pro práci s vektory a maticemi<br />
<a href="http://www.root.cz/clanky/programovaci-jazyk-clojure-a-knihovny-pro-praci-s-vektory-a-maticemi/">http://www.root.cz/clanky/programovaci-jazyk-clojure-a-knihovny-pro-praci-s-vektory-a-maticemi/</a>
</li>

<li>Programovací jazyk Clojure a knihovny pro práci s vektory a maticemi (2)<br />
<a href="http://www.root.cz/clanky/programovaci-jazyk-clojure-a-knihovny-pro-praci-s-vektory-a-maticemi-2/">http://www.root.cz/clanky/programovaci-jazyk-clojure-a-knihovny-pro-praci-s-vektory-a-maticemi-2/</a>
</li>

<li>Programovací jazyk Clojure: syntéza procedurálních textur s využitím knihovny Clisk<br />
<a href="http://www.root.cz/clanky/programovaci-jazyk-clojure-synteza-proceduralnich-textur-s-vyuzitim-knihovny-clisk/">http://www.root.cz/clanky/programovaci-jazyk-clojure-synteza-proceduralnich-textur-s-vyuzitim-knihovny-clisk/</a>
</li>

<li>Programovací jazyk Clojure: syntéza procedurálních textur s využitím knihovny Clisk (2)<br />
<a href="http://www.root.cz/clanky/programovaci-jazyk-clojure-synteza-proceduralnich-textur-s-vyuzitim-knihovny-clisk-2/">http://www.root.cz/clanky/programovaci-jazyk-clojure-synteza-proceduralnich-textur-s-vyuzitim-knihovny-clisk-2/</a>
</li>

<li>Seesaw: knihovna pro snadnou tvorbu GUI v jazyce Clojure<br />
<a href="http://www.root.cz/clanky/seesaw-knihovna-pro-snadnou-tvorbu-gui-v-jazyce-clojure/">http://www.root.cz/clanky/seesaw-knihovna-pro-snadnou-tvorbu-gui-v-jazyce-clojure/</a>
</li>

<li>Seesaw: knihovna pro snadnou tvorbu GUI v jazyce Clojure (2)<br />
<a href="http://www.root.cz/clanky/seesaw-knihovna-pro-snadnou-tvorbu-gui-v-jazyce-clojure-2/">http://www.root.cz/clanky/seesaw-knihovna-pro-snadnou-tvorbu-gui-v-jazyce-clojure-2/</a>
</li>

<li>Seesaw: knihovna pro snadnou tvorbu GUI v jazyce Clojure (3)<br />
<a href="http://www.root.cz/clanky/seesaw-knihovna-pro-snadnou-tvorbu-gui-v-jazyce-clojure-3/">http://www.root.cz/clanky/seesaw-knihovna-pro-snadnou-tvorbu-gui-v-jazyce-clojure-3/</a>
</li>

<li>Programovací jazyk Clojure a práce s Gitem<br />
<a href="http://www.root.cz/clanky/programovaci-jazyk-clojure-a-prace-s-gitem/">http://www.root.cz/clanky/programovaci-jazyk-clojure-a-prace-s-gitem/</a>
</li>

<li>Programovací jazyk Clojure: syntéza procedurálních textur s využitím knihovny Clisk (dokončení)<br />
<a href="http://www.root.cz/clanky/programovaci-jazyk-clojure-synteza-proceduralnich-textur-s-vyuzitim-knihovny-clisk-dokonceni/">http://www.root.cz/clanky/programovaci-jazyk-clojure-synteza-proceduralnich-textur-s-vyuzitim-knihovny-clisk-dokonceni/</a>
</li>

<li>Programovací jazyk Clojure a práce s Gitem (2)<br />
<a href="http://www.root.cz/clanky/programovaci-jazyk-clojure-a-prace-s-gitem-2/">http://www.root.cz/clanky/programovaci-jazyk-clojure-a-prace-s-gitem-2/</a>
</li>

<li>Programovací jazyk Clojure – triky při práci s řetězci<br />
<a href="http://www.root.cz/clanky/programovaci-jazyk-clojure-triky-pri-praci-s-retezci/">http://www.root.cz/clanky/programovaci-jazyk-clojure-triky-pri-praci-s-retezci/</a>
</li>

<li>Programovací jazyk Clojure – triky při práci s kolekcemi<br />
<a href="http://www.root.cz/clanky/programovaci-jazyk-clojure-triky-pri-praci-s-kolekcemi/">http://www.root.cz/clanky/programovaci-jazyk-clojure-triky-pri-praci-s-kolekcemi/</a>
</li>

<li>Programovací jazyk Clojure – práce s mapami a množinami<br />
<a href="http://www.root.cz/clanky/programovaci-jazyk-clojure-prace-s-mapami-a-mnozinami/">http://www.root.cz/clanky/programovaci-jazyk-clojure-prace-s-mapami-a-mnozinami/</a>
</li>

<li>Programovací jazyk Clojure – základy zpracování XML<br />
<a href="http://www.root.cz/clanky/programovaci-jazyk-clojure-zaklady-zpracovani-xml/">http://www.root.cz/clanky/programovaci-jazyk-clojure-zaklady-zpracovani-xml/</a>
</li>

<li>Programovací jazyk Clojure – testování s využitím knihovny Expectations<br />
<a href="http://www.root.cz/clanky/programovaci-jazyk-clojure-testovani-s-vyuzitim-knihovny-expectations/">http://www.root.cz/clanky/programovaci-jazyk-clojure-testovani-s-vyuzitim-knihovny-expectations/</a>
</li>

<li>Programovací jazyk Clojure – některé užitečné triky použitelné (nejenom) v&nbsp;testech<br />
<a href="http://www.root.cz/clanky/programovaci-jazyk-clojure-nektere-uzitecne-triky-pouzitelne-nejenom-v-testech/">http://www.root.cz/clanky/programovaci-jazyk-clojure-nektere-uzitecne-triky-pouzitelne-nejenom-v-testech/</a>
</li>

<li>Enlive – výkonný šablonovací systém pro jazyk Clojure<br/>
<a href="http://www.root.cz/clanky/enlive-vykonny-sablonovaci-system-pro-jazyk-clojure/">http://www.root.cz/clanky/enlive-vykonny-sablonovaci-system-pro-jazyk-clojure/</a>
</li>

<li>Nástroj Leiningen a programovací jazyk Clojure: tvorba vlastních knihoven pro veřejný repositář Clojars<br />
<a href="http://www.root.cz/clanky/nastroj-leiningen-a-programovaci-jazyk-clojure-tvorba-vlastnich-knihoven-pro-verejny-repositar-clojars/">http://www.root.cz/clanky/nastroj-leiningen-a-programovaci-jazyk-clojure-tvorba-vlastnich-knihoven-pro-verejny-repositar-clojars/</a>
</li>

<li>Novinky v Clojure verze 1.8.0<br />
<a href="http://www.root.cz/clanky/novinky-v-clojure-verze-1-8-0/">http://www.root.cz/clanky/novinky-v-clojure-verze-1-8-0/</a>
</li>

<li>Asynchronní programování v&nbsp;Clojure s&nbsp;využitím knihovny core.async<br />
<a href="http://www.root.cz/clanky/asynchronni-programovani-v-clojure-s-vyuzitim-knihovny-core-async/">http://www.root.cz/clanky/asynchronni-programovani-v-clojure-s-vyuzitim-knihovny-core-async/</a>
</li>

<li>Asynchronní programování v&nbsp;Clojure s&nbsp;využitím knihovny core.async (pokračování)<br />
<a href="http://www.root.cz/clanky/asynchronni-programovani-v-clojure-s-vyuzitim-knihovny-core-async-pokracovani/">http://www.root.cz/clanky/asynchronni-programovani-v-clojure-s-vyuzitim-knihovny-core-async-pokracovani/</a>
</li>

<li>Asynchronní programování v Clojure s využitím knihovny core.async (dokončení)<br />
<a href="http://www.root.cz/clanky/asynchronni-programovani-v-clojure-s-vyuzitim-knihovny-core-async-dokonceni/">http://www.root.cz/clanky/asynchronni-programovani-v-clojure-s-vyuzitim-knihovny-core-async-dokonceni/</a>
</li>

<li>Vytváříme IRC bota v programovacím jazyce Clojure<br />
<a href="http://www.root.cz/clanky/vytvarime-irc-bota-v-programovacim-jazyce-clojure/">http://www.root.cz/clanky/vytvarime-irc-bota-v-programovacim-jazyce-clojure/</a>
</li>

<li>Gorilla REPL: interaktivní prostředí pro programovací jazyk Clojure<br />
<a href="https://www.root.cz/clanky/gorilla-repl-interaktivni-prostredi-pro-programovaci-jazyk-clojure/">https://www.root.cz/clanky/gorilla-repl-interaktivni-prostredi-pro-programovaci-jazyk-clojure/</a>
</li>

</ol>



<p><a name="k14"></a></p>
<h2 id="k14">14. Odkazy na Internetu</h2>

<ol>

<li>Clojure home page<br />
<a href="http://clojure.org/">http://clojure.org/</a>
</li>

<li>Clojure (downloads)<br />
<a href="http://clojure.org/downloads">http://clojure.org/downloads</a>
</li>

<li>Clojure - Functional Programming for the JVM<br />
<a href="http://java.ociweb.com/mark/clojure/article.html">http://java.ociweb.com/mark/clojure/article.html</a>
</li>

<li>Clojure quick reference<br />
<a href="http://faustus.webatu.com/clj-quick-ref.html">http://faustus.webatu.com/clj-quick-ref.html</a>
</li>

<li>4Clojure<br />
<a href="http://www.4clojure.com/">http://www.4clojure.com/</a>
</li>

<li>ClojureDoc (rozcestník s&nbsp;dokumentací jazyka Clojure)<br />
<a href="http://clojuredocs.org/">http://clojuredocs.org/</a>
</li>

<li>Clojure (na Wikipedia EN)<br />
<a href="http://en.wikipedia.org/wiki/Clojure">http://en.wikipedia.org/wiki/Clojure</a>
</li>

<li>Clojure (na Wikipedia CS)<br />
<a href="http://cs.wikipedia.org/wiki/Clojure">http://cs.wikipedia.org/wiki/Clojure</a>
</li>

<li>Clojars:<br />
<a href="https://clojars.org/">https://clojars.org/</a>
</li>

<li>Seznam knihoven na Clojars:<br />
<a href="https://clojars.org/projects">https://clojars.org/projects</a>
</li>

<li>Zip archiv s&nbsp;Clojure 1.8.0<br />
<a href="http://repo1.maven.org/maven2/org/clojure/clojure/1.8.0/clojure-1.8.0.zip">http://repo1.maven.org/maven2/org/clojure/clojure/1.8.0/clojure-1.8.0.zip</a>
</li>

<li>Clojure 1.8 is now available<br />
<a href="http://clojure.org/news/2016/01/19/clojure18">http://clojure.org/news/2016/01/19/clojure18</a>
</li>

<li>Changes to Clojure in Version 1.8<br />
<a href="https://github.com/clojure/clojure/blob/master/changes.md">https://github.com/clojure/clojure/blob/master/changes.md</a>
</li>

<li>Clojure core.async<br />
<a href="http://www.infoq.com/presentations/clojure-core-async">http://www.infoq.com/presentations/clojure-core-async</a>
</li>

<li>core.async API Reference<br />
<a href="https://clojure.github.io/core.async/">https://clojure.github.io/core.async/</a>
</li>

<li>Clojure core.async Channels<br />
<a href="http://clojure.com/blog/2013/06/28/clojure-core-async-channels.html">http://clojure.com/blog/2013/06/28/clojure-core-async-channels.html</a>
</li>

<li>core.async examples<br />
<a href="https://github.com/clojure/core.async/blob/master/examples/walkthrough.clj">https://github.com/clojure/core.async/blob/master/examples/walkthrough.clj</a>
</li>

<li>Timothy Baldridge - Core.Async<br />
<a href="https://www.youtube.com/watch?v=enwIIGzhahw">https://www.youtube.com/watch?v=enwIIGzhahw</a>
</li>

</ol>



<p></p><p></p>
<p><small>Autor: <a href="http://www.fit.vutbr.cz/~tisnovpa">Pavel Tišnovský</a> &nbsp; 2016</small></p>
</body>
</html>

