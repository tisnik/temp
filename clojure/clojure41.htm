<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
        "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html>
<head>
<title>Validace dat s využitím knihovny spec v Clojure 1.9.0 (dokončení)</title>
<meta name="Author" content="Pavel Tisnovsky" />
<meta name="Generator" content="vim" />
<meta http-equiv="content-type" content="text/html; charset=utf-8" />
<style type="text/css">
         body {color:#000000; background:#ffffff;}
         h1  {font-family: arial, helvetica, sans-serif; color:#ffffff; background-color:#c00000; text-align:center; padding-left:1em}
         h2  {font-family: arial, helvetica, sans-serif; color:#ffffff; background-color:#0000c0; padding-left:1em; text-align:left}
         h3  {font-family: arial, helvetica, sans-serif; color:#000000; background-color:#c0c0c0; padding-left:1em; text-align:left}
         h4  {font-family: arial, helvetica, sans-serif; color:#000000; background-color:#e0e0e0; padding-left:1em; text-align:left}
         a   {font-family: arial, helvetica, sans-serif;}
         li  {font-family: arial, helvetica, sans-serif; color:#000000; text-align:justify; width:450px;}
         ol  {font-family: arial, helvetica, sans-serif; color:#000000; text-align:justify; width:450px;}
         ul  {font-family: arial, helvetica, sans-serif; color:#000000; text-align:justify; width:450px;}
         p   {font-family: arial, helvetica, sans-serif; color:#000000; text-align:justify;}
         pre {background:#e0e0e0}
</style>
</head>

<body>

<h1>Validace dat s využitím knihovny spec v Clojure 1.9.0 (dokončení)</h1>

<h3>Pavel Tišnovský</h3>

<p></p>

<h1>Úvodník</h1>

<p>Popis možností nabízených knihovnou spec, kterou jsme se zabývali v předchozích dvou článcích, dnes dokončíme. Ukážeme si především velmi užitečnou vlastnost: možnost deklarovat validační kritéria způsobem, který do jisté míry připomíná zápis regulárních výrazů.</p>



<h2>Obsah</h2>

<p><a href="#k01">1. Validace dat s&nbsp;využitím knihovny spec v&nbsp;Clojure 1.9.0 (dokončení)</a></p>
<p><a href="#k02">2. Spuštění interaktivní smyčky REPL s&nbsp;interpretrem Clojure 1.9.0</a></p>
<p><a href="#k03">*** 3. Použití klauzule <strong>spec/and</strong></a></p>
<p><a href="#k04">*** 4. Použití klauzule <strong>spec/or</strong></a></p>
<p><a href="#k05">*** 5. </a></p>
<p><a href="#k06">*** 6. </a></p>
<p><a href="#k07">*** 7. </a></p>
<p><a href="#k08">*** 8. </a></p>
<p><a href="#k09">*** 9. </a></p>
<p><a href="#k10">*** 10. </a></p>
<p><a href="#k11">*** 11. </a></p>
<p><a href="#k12">*** 12. </a></p>
<p><a href="#k13">*** 13. </a></p>
<p><a href="#k14">*** 14. </a></p>
<p><a href="#k15">*** 15. </a></p>
<p><a href="#k16">*** 16. </a></p>
<p><a href="#k17">*** 17. </a></p>
<p><a href="#k18">18. Repositář s&nbsp;demonstračními příklady</a></p>
<p><a href="#k19">19. Odkazy na předchozí části tohoto seriálu</a></p>
<p><a href="#k20">20. Odkazy na Internetu</a></p>



<p><a name="k01"></a></p>
<h2 id="k01">1. Validace dat s&nbsp;využitím knihovny spec v&nbsp;Clojure 1.9.0 (dokončení)</h2>

<p>V&nbsp;dnešním článku o nejnovější <a
href="https://github.com/clojure/clojure/blob/master/changes.md">stabilní verzi
1.9.0</a> programovacího jazyka <a href="https://clojure.org/">Clojure</a>
dokončíme popis možností nabízených velmi užitečnou knihovnou nazvanou
<i>spec</i>. Již <a
href="https://www.root.cz/clanky/validace-dat-s-vyuzitim-knihovny-spec-v-clojure-1-9-0/">z&nbsp;předchozího
článku</a> víme, že tato knihovna slouží k&nbsp;deklaraci očekávané struktury
dat a následně k&nbsp;jejich validaci. Složitější datové struktury jsou
v&nbsp;jazyku Clojure většinou reprezentovány formou slovníku, který
(rekurzivně) obsahuje další struktury, tj.&nbsp;další slovníky, seznamy,
vektory či množiny. Právě z&nbsp;tohoto důvodu používá knihovna <i>spec</i>
operátory (či možná lépe řečeno klauzule), které do jisté míry dokážou
zkontrolovat i sekvence, jejichž délka nemusí být dopředu známá. Pěkným
příkladem může být seznam či vektor osob, mapa představující konfigurační volby
apod.</p>



<p><a name="k02"></a></p>
<h2 id="k02">2. Spuštění interaktivní smyčky REPL s&nbsp;interpretrem Clojure 1.9.0</h2>

<p>Všechny dále uváděné deklarace, volání funkcí i maker atd., budeme zkoušet
přímo v&nbsp;interaktivní smyčce (REPL). Ta musí být spuštěna pro interpret
Clojure 1.9.0, což lze zajistit například tak, že v&nbsp;adresáři projektu <a
href="https://github.com/tisnik/clojure-examples/tree/master/clojure9-test">clojure9-test</a>
spustíte skript <strong>repl</strong>:</p>

<pre>
$ <strong>./repl</strong>
nREPL server started on port 35985 on host 127.0.0.1 - nrepl://127.0.0.1:35985
REPL-y 0.3.7, nREPL 0.2.12
Clojure <strong>1.9.0</strong>
OpenJDK 64-Bit Server VM 1.8.0_151-b12
    Docs: (doc function-name-here)
          (find-doc "part-of-name-here")
  Source: (source function-name-here)
 Javadoc: (javadoc java-object-or-class-here)
    Exit: Control+D or (exit) or (quit)
 Results: Stored in vars *1, *2, *3, an exception in *e
&nbsp;
clojure9-test.core=&gt;
</pre>

<p>Ihned poté si nastavte jmenný prostor a naimportujte knihovnu
<i>spec</i>:</p>

<pre>
clojure9-test.core=&gt; <strong>(ns user)</strong>
nil
&nbsp;
user=&gt; <strong>(require '[clojure.spec.alpha :as spec])</strong>
nil
</pre>

<p>Po změně jmenného prostoru přestane být dostupné makro
<strong>doc</strong>:</p>

<pre>
user=&gt; <strong>(doc doc)</strong>
&nbsp;
CompilerException java.lang.RuntimeException: Unable to resolve symbol: doc in this context, compiling:(/tmp/form-init3972254276603866443.clj:1:1) 
</pre>

<p>Makro <strong>doc</strong> je ovšem velmi užitečné, takže si ho
naimportujeme:</p>

<pre>
user=&gt; <strong>(use '[clojure.repl :only (doc)])</strong>
nil
&nbsp;
user=&gt; <strong>(doc doc)</strong>
-------------------------
clojure.repl/doc
([name])
Macro
  Prints documentation for a var or special form given its name,
   or for a spec if given a keyword
nil
</pre>

<p>Nyní je již REPL připraven pro další testy.</p>



<p><a name="k03"></a></p>
<h2 id="k03">3. Použití klauzule <strong>spec/and</strong></h2>

<pre>
user=&gt; <strong>(doc spec/and)</strong>
-------------------------
clojure.spec.alpha/and
([&amp; pred-forms])
Macro
  Takes predicate/spec-forms, e.g.

  (s/and even? #(< % 42))

  Returns a spec that returns the conformed value. Successive
  conformed values propagate through rest of predicates.
</pre>

user=&gt; <strong>(spec/def ::user-id (spec/and pos-int? #(&gt;= % 1000) #(&lt; % Integer/MAX_VALUE)))</strong>
:user/user-id

user=&gt; <strong>(doc ::user-id)</strong>
-------------------------
:user/user-id
Spec
  (and pos-int? (>= % 1000) (< % MAX_VALUE))

user=&gt; <strong>(spec/valid? ::user-id 1)</strong>
false

user=&gt; <strong>(spec/valid? ::user-id 1000)</strong>
true

user=&gt; <strong>(spec/valid? ::user-id 10000000)</strong>
true

user=&gt; <strong>(spec/valid? ::user-id 100000000)</strong>
true

user=&gt; <strong>(spec/valid? ::user-id 1000000000)</strong>
true

user=&gt; <strong>(spec/valid? ::user-id 10000000000)</strong>
false



<p><a name="k04"></a></p>
<h2 id="k04">4. Použití klauzule <strong>spec/or</strong></h2>

<pre>
user=&gt; <strong>(doc spec/or)</strong>
-------------------------
clojure.spec.alpha/or
([&amp; key-pred-forms])
Macro
  Takes key+pred pairs, e.g.

  (s/or :even even? :small #(< % 42))

  Returns a destructuring spec that returns a map entry containing the
  key of the first matching pred and the corresponding value. Thus the
  'key' and 'val' functions can be used to refer generically to the
  components of the tagged return.
</pre>

user=&gt; <strong>(spec/def ::unique-id (spec/or :name string? :id pos-int?))</strong>
:user/unique-id

user=&gt; <strong>(doc ::unique-id)</strong>
-------------------------
:user/unique-id
Spec
  (or :name string? :id pos-int?)

user=&gt; <strong>(spec/valid? ::unique-id 42)</strong>
true

user=&gt; <strong>(spec/valid? ::unique-id "foo")</strong>
true

user=&gt; <strong>(spec/valid? ::unique-id nil)</strong>
false

user=&gt; <strong>(spec/valid? ::unique-id [])</strong>
false

user=&gt; <strong>(spec/conform ::unique-id 42)</strong>
[:id 42]

user=&gt; <strong>(spec/conform ::unique-id "foo")</strong>
[:name "foo"]

user=&gt; <strong>(spec/conform ::unique-id nil)</strong>
:clojure.spec.alpha/invalid

user=&gt; <strong>(spec/conform ::unique-id [])</strong>
:clojure.spec.alpha/invalid

user=&gt; <strong>(spec/explain ::unique-id 42)</strong>
Success!
nil

user=&gt; <strong>(spec/explain ::unique-id [])</strong>
val: [] fails spec: :user/unique-id at: [:name] predicate: string?
val: [] fails spec: :user/unique-id at: [:id] predicate: pos-int?
nil

user=&gt; <strong>(spec/explain ::unique-id nil)</strong>
val: nil fails spec: :user/unique-id at: [:name] predicate: string?
val: nil fails spec: :user/unique-id at: [:id] predicate: pos-int?
nil



<p><a name="k04"></a></p>
<h2 id="k04">4. </h2>

user=&gt; <strong>(spec/def ::comment (spec/or :filled string? :empty nil?))</strong>
:user/comment

user=&gt; <strong>(doc ::comment)</strong>
-------------------------
:user/comment
Spec
  (or :filled string? :empty nil?)

user=&gt; <strong>(spec/valid? ::comment "komentar")</strong>
true
user=&gt; <strong>(spec/valid? ::comment nil)</strong>
true
user=&gt; <strong>(spec/valid? ::comment [])</strong>
false
user=&gt; <strong>(spec/valid? ::comment false)</strong>
false
user=&gt; <strong>(spec/valid? ::comment (range 10))</strong>
false

user=&gt; <strong>(spec/explain ::comment (range 10))</strong>
val: (0 1 2 3 4 5 6 7 8 9) fails spec: :user/comment at: [:filled] predicate: string?
val: (0 1 2 3 4 5 6 7 8 9) fails spec: :user/comment at: [:empty] predicate: nil?
nil
user=&gt; <strong>(spec/explain ::comment '())</strong>
val: () fails spec: :user/comment at: [:filled] predicate: string?
val: () fails spec: :user/comment at: [:empty] predicate: nil?
nil




<p><a name="k05"></a></p>
<h2 id="k05">5. </h2>

<pre>
user=&gt; <strong>(doc spec/nilable)</strong>
-------------------------
clojure.spec.alpha/nilable
([pred])
Macro
  returns a spec that accepts nil and values satisfying pred
nil
</pre>

user=&gt; <strong>(doc ::comment)</strong>
-------------------------
:user/comment
Spec
  (nilable string?)

user=&gt; <strong>(spec/def ::comment (spec/nilable string?))</strong>
:user/comment
user=&gt; <strong>(spec/valid? ::comment "komentar")</strong>
true
user=&gt; <strong>(spec/valid? ::comment nil)</strong>
true
user=&gt; <strong>(spec/valid? ::comment [])</strong>
false
user=&gt; <strong>(spec/valid? ::comment false)</strong>
false
user=&gt; <strong>(spec/explain ::comment (range 10))</strong>
val: (0 1 2 3 4 5 6 7 8 9) fails spec: :user/comment at: [:clojure.spec.alpha/pred] predicate: string?
val: (0 1 2 3 4 5 6 7 8 9) fails spec: :user/comment at: [:clojure.spec.alpha/nil] predicate: nil?
nil
user=&gt; <strong>(spec/explain ::comment '())</strong>
val: () fails spec: :user/comment at: [:clojure.spec.alpha/pred] predicate: string?
val: () fails spec: :user/comment at: [:clojure.spec.alpha/nil] predicate: nil?
nil



<p><a name="k06"></a></p>
<h2 id="k06">6. </h2>


user=&gt; <strong>(spec/explain-data ::comment '())</strong>
#:clojure.spec.alpha{:problems [{:path [:clojure.spec.alpha/pred], :pred clojure.core/string?, :val (), :via [:user/comment], :in []} {:path [:clojure.spec.alpha/nil], :pred nil?, :val (), :via [:user/comment], :in []}], :spec :user/comment, :value ()}

user=&gt; <strong>(-> (spec/explain-data ::comment '()) clojure.pprint/pprint)</strong>
#:clojure.spec.alpha{:problems
                     [{:path [:clojure.spec.alpha/pred],
                       :pred clojure.core/string?,
                       :val (),
                       :via [:user/comment],
                       :in []}
                      {:path [:clojure.spec.alpha/nil],
                       :pred nil?,
                       :val (),
                       :via [:user/comment],
                       :in []}],
                     :spec :user/comment,
                     :value ()}

user=&gt; <strong>(-> (spec/explain-data ::unique-id nil) clojure.pprint/pprint)</strong>
#:clojure.spec.alpha{:problems
                     ({:path [:name],
                       :pred clojure.core/string?,
                       :val nil,
                       :via [:user/unique-id],
                       :in []}
                      {:path [:id],
                       :pred clojure.core/pos-int?,
                       :val nil,
                       :via [:user/unique-id],
                       :in []}),
                     :spec :user/unique-id,
                     :value nil}



<p><a name="k07"></a></p>
<h2 id="k07">7. </h2>

user=&gt; <strong>(spec/def ::positive-integers (spec/coll-of pos-int?))</strong>
:user/pos-integers
user=&gt; <strong>(spec/valid? ::positive-integers [1 2 3])</strong>
true
user=&gt; <strong>(spec/valid? ::positive-integers (range 10))</strong>
false
user=&gt; <strong>(spec/valid? ::positive-integers (range 1 10))</strong>
true
user=&gt; <strong>(spec/explain ::positive-integers (range 1 10))</strong>
Success!

user=&gt; <strong>(spec/valid? ::dictionary {"one" "jedna" "two" "dve"})</strong>
true
user=&gt; <strong>(spec/valid? ::dictionary {"one" 1 "two" 2})</strong>
false

user=&gt; <strong>(spec/def ::byte (spec/and nat-int? #(<= % 255)))</strong>
:user/byte
user=&gt; <strong>(spec/valid? ::byte -1)</strong>
false
user=&gt; <strong>(spec/valid? ::byte 0)</strong>
true
user=&gt; <strong>(spec/valid? ::byte 255)</strong>
true
user=&gt; <strong>(spec/valid? ::byte 256)</strong>
false



<p><a name="k08"></a></p>
<h2 id="k08">8. </h2>

user=&gt; <strong>(spec/def ::ip-address (spec/tuple ::byte ::byte ::byte ::byte))</strong>
:user/ip-address

user=&gt; <strong>(doc ::ip-address)</strong>
-------------------------
:user/ip-address
Spec
  (tuple :user/byte :user/byte :user/byte :user/byte)

user=&gt; <strong>(spec/valid? ::ip-address [127 0 0 1])</strong>
true
user=&gt; <strong>(spec/valid? ::ip-address [256 0 0 1])</strong>
false
user=&gt; <strong>(spec/valid? ::ip-address [127 0 0 0 1])</strong>
false

user=&gt; <strong>(-> (spec/explain-data ::ip-address [127 0 0 0 1]) clojure.pprint/pprint)</strong>
#:clojure.spec.alpha{:problems
                     [{:path [],
                       :pred (clojure.core/= (clojure.core/count %) 4),
                       :val [127 0 0 0 1],
                       :via [:user/ip-address],
                       :in []}],
                     :spec :user/ip-address,
                     :value [127 0 0 0 1]}



<p><a name="k09"></a></p>
<h2 id="k09">9. </h2>


    cat - concatenation of predicates/patterns

    alt - choice among alternative predicates/patterns

    * - 0 or more of a predicate/pattern

    + - 1 or more of a predicate/pattern

    ? - 0 or 1 of a predicate/pattern




<p><a name="k10"></a></p>
<h2 id="k10">10. </h2>

user=&gt; <strong>(spec/def ::ip-address-2 (spec/cat :1st ::byte :2nd ::byte :3rd ::byte :4th ::byte))</strong>
:user/ip-address-2
user=&gt; <strong>(doc ::ip-address-2)</strong>
-------------------------
:user/ip-address-2
Spec
  (cat :1st :user/byte :2nd :user/byte :3rd :user/byte :4th :user/byte)
nil
user=&gt; <strong>(spec/valid? ::ip-address-2 [127 0 0 0 1])</strong>
false
user=&gt; <strong>(spec/valid? ::ip-address-2 [127 0 0 1])</strong>
true
user=&gt; <strong>(-> (spec/explain-data ::ip-address-2 [127 0 0 0 1]) clojure.pprint/pprint)</strong>
#:clojure.spec.alpha{:problems
                     [{:path [],
                       :reason "Extra input",
                       :pred
                       (clojure.spec.alpha/cat
                        :1st
                        :user/byte
                        :2nd
                        :user/byte
                        :3rd
                        :user/byte
                        :4th
                        :user/byte),
                       :val (1),
                       :via [:user/ip-address-2],
                       :in [4]}],
                     :spec :user/ip-address-2,
                     :value [127 0 0 0 1]}



<p><a name="k11"></a></p>
<h2 id="k11">11. </h2>

user=&gt; <strong>(spec/def ::even-numbers (spec/+ even?))</strong>
:user/even-numbers
user=&gt; <strong>(spec/valid? ::even-numbers [1 2 3])</strong>
false
user=&gt; <strong>(spec/valid? ::even-numbers [2 4 6])</strong>
true
user=&gt; <strong>(spec/explain ::even-numbers [1 2 3])</strong>
In: [0] val: 1 fails spec: :user/even-numbers predicate: even?
nil
user=&gt; <strong>(spec/valid? ::even-numbers (map #(* % 2) (range 10)))</strong>
true



<p><a name="k12"></a></p>
<h2 id="k12">12. </h2>

user=&gt; <strong>(spec/def ::uid string?)</strong>
:user/uid
user=&gt; <strong>(spec/def ::sequence-with-uid (spec/cat :uid ::uid :seq (spec/+ pos-int?)))</strong>
:user/sequence-with-uid
user=&gt; <strong>(spec/valid? ::sequence-with-uid ["x" 1 2 3])</strong>
true
user=&gt; <strong>(spec/valid? ::sequence-with-uid [0 1 2 3])</strong>
false
user=&gt; <strong>(spec/valid? ::sequence-with-uid [0 1 2 3 "x"])</strong>
false
user=&gt; <strong>(spec/explain-data ::sequence-with-uid [0 1 2 3 "x"])</strong>
#:clojure.spec.alpha{:problems [{:path [:uid], :pred clojure.core/string?, :val 0, :via [:user/sequence-with-uid :user/sequence-with-uid :user/uid :user/uid], :in [0]}], :spec :user/sequence-with-uid, :value [0 1 2 3 "x"]}
user=&gt; <strong>(spec/conform ::sequence-with-uid ["x" 1 2 3])</strong>
{:uid "x", :seq [1 2 3]}

user=&gt; <strong>(-> (spec/explain-data ::sequence-with-uid [0 1 2 3 "x"]) clojure.pprint/pprint)</strong>
#:clojure.spec.alpha{:problems
                     [{:path [:uid],
                       :pred clojure.core/string?,
                       :val 0,
                       :via
                       [:user/sequence-with-uid
                        :user/sequence-with-uid
                        :user/uid
                        :user/uid],
                       :in [0]}],
                     :spec :user/sequence-with-uid,
                     :value [0 1 2 3 "x"]}
nil



<p><a name="k13"></a></p>
<h2 id="k13">13. </h2>

user=&gt; <strong>(s/def ::odds-then-maybe-even (s/cat :odds (s/+ odd?)</strong>
  #_=&gt; <strong>                                     :even (s/? even?))</strong>

user=&gt; <strong>(spec/def ::odds-then-maybe-even (spec/cat :odds (spec/+ odd?) :even (spec/? even?)))</strong>
:user/odds-then-maybe-even
user=&gt; <strong>(spec/conform ::odds-then-maybe-even [1 3 5 100])</strong>
{:odds [1 3 5], :even 100}


user=&gt; <strong>(spec/def ::configuration (spec/+ (spec/cat :name string? :value some?)))</strong>
:user/configuration
user=&gt; <strong>(spec/valid? ::configuration ["debug" true "url" "localhost" "port" 8080])</strong>
true
user=&gt; <strong>(spec/valid? ::configuration ["debug" true "url" "localhost" "port"])</strong>
false
user=&gt; <strong>(spec/explain ::configuration ["debug" true "url" "localhost" "port"])</strong>
val: () fails spec: :user/configuration at: [:value] predicate: some?,  Insufficient input
nil

user=&gt; <strong>(spec/valid? ::configuration [])</strong>
false
user=&gt; <strong>(spec/explain ::configuration [])</strong>
val: () fails spec: :user/configuration at: [:name] predicate: string?,  Insufficient input
nil

user=&gt; <strong>(spec/def ::configuration (spec/* (spec/cat :name string? :value some?)))</strong>
:user/configuration
user=&gt; <strong>(spec/valid? ::configuration [])</strong>
true
user=&gt; <strong>(spec/valid? ::configuration ["debug" true "url" "localhost" "port"])</strong>
false
user=&gt; <strong>(spec/valid? ::configuration ["debug" true "url" "localhost" "port" 8080])</strong>
true



<p><a name="k14"></a></p>
<h2 id="k14">14. </h2>

user=&gt; <strong>(spec/def ::configuration (spec/* (spec/cat :name string? :value (spec/alt :str string? :bool boolean? :integer int?))))</strong>
:user/configuration
user=&gt; <strong>(spec/valid? ::configuration ["debug" true "url" "localhost" "port" 8080])</strong>
true
user=&gt; <strong>(spec/valid? ::configuration ["debug" true "url" "localhost" "port" 8080.1])</strong>
false
user=&gt; <strong>(spec/explain ::configuration ["debug" true "url" "localhost" "port" 8080.1])</strong>
In: [5] val: 8080.1 fails spec: :user/configuration at: [:value :str] predicate: string?
In: [5] val: 8080.1 fails spec: :user/configuration at: [:value :bool] predicate: boolean?
In: [5] val: 8080.1 fails spec: :user/configuration at: [:value :integer] predicate: int?
nil



<p><a name="k15"></a></p>
<h2 id="k15">15. </h2>

user=&gt; <strong>(spec/conform ::configuration ["debug" true "url" "localhost" "port" 8080])</strong>
[{:name "debug", :value [:bool true]} {:name "url", :value [:str "localhost"]} {:name "port", :value [:integer 8080]}]

user=&gt; <strong>(-> (spec/conform ::configuration ["debug" true "url" "localhost" "port" 8080]) clojure.pprint/pprint)</strong>
[{:name "debug", :value [:bool true]}
 {:name "url", :value [:str "localhost"]}
 {:name "port", :value [:integer 8080]}]
nil



<p><a name="k16"></a></p>
<h2 id="k16">16. </h2>

spec-demo6.core=&gt; <strong>(require '[clojure.spec.gen.alpha :as gen])</strong>
nil
spec-demo6.core=&gt; <strong>(gen/generate (spec/gen int?))</strong>
506842
spec-demo6.core=&gt; <strong>(gen/generate (spec/gen int?))</strong>
75
spec-demo6.core=&gt; <strong>(gen/generate (spec/gen int?))</strong>
-1
spec-demo6.core=&gt; <strong>(gen/generate (spec/gen int?))</strong>
-347611

spec-demo6.core=&gt; <strong>(gen/generate (spec/gen ::comment))</strong>
"2MT4fYI7qDn4p"
spec-demo6.core=&gt; <strong>(gen/generate (spec/gen ::comment))</strong>
nil
spec-demo6.core=&gt; <strong>(gen/generate (spec/gen ::comment))</strong>
"Pb"

spec-demo6.core=&gt; <strong>(gen/generate (spec/gen ::ip-address-2))</strong>
(118 4 30 127)
spec-demo6.core=&gt; <strong>(gen/generate (spec/gen ::ip-address-2))</strong>
(5 123 1 0)
spec-demo6.core=&gt; <strong>(gen/generate (spec/gen ::ip-address-2))</strong>
(193 1 1 13)
spec-demo6.core=&gt; <strong>(gen/generate (spec/gen ::ip-address-2))</strong>
(96 1 5 34)
spec-demo6.core=&gt; <strong>(gen/generate (spec/gen ::ip-address-2))</strong>
(71 102 48 0)



<p><a name="k17"></a></p>
<h2 id="k17">17. </h2>



<p><a name="k18"></a></p>
<h2 id="k18">18. Repositář s&nbsp;demonstračními příklady</h2>

<p>Všechny demonstrační příklady a projekty určené pro Clojure verze 1.9.0 byly
uloženy do repositáře <a
href="https://github.com/tisnik/clojure-examples">https://github.com/tisnik/clojure-examples</a>:</p>

<table>
<tr><th>Projekt</th><th>Popis</th><th>Odkaz</th></tr>
<tr><td>spec-demo6</td><td>ukázka použití klauzule <strong>and</strong></td><td><a href="https://github.com/tisnik/clojure-examples/tree/master/spec-demo6">https://github.com/tisnik/clojure-examples/tree/master/spec-demo6</a></td></tr>
<tr><td>spec-demo7</td><td>ukázka použití klauzule <strong>or</strong></td><td><a href="https://github.com/tisnik/clojure-examples/tree/master/spec-demo7">https://github.com/tisnik/clojure-examples/tree/master/spec-demo7</a></td></tr>
<tr><td>spec-demo8</td><td>nilable řetězec, první varianta</td><td><a href="https://github.com/tisnik/clojure-examples/tree/master/spec-demo8">https://github.com/tisnik/clojure-examples/tree/master/spec-demo8</a></td></tr>
<tr><td>spec-demo9</td><td>nilable řetězec, druhá varianta</td><td><a href="https://github.com/tisnik/clojure-examples/tree/master/spec-demo9">https://github.com/tisnik/clojure-examples/tree/master/spec-demo9</a></td></tr>
<tr><td>spec-demo10</td><td>funkce <strong>explain-data</strong></td><td><a href="https://github.com/tisnik/clojure-examples/tree/master/spec-demo10">https://github.com/tisnik/clojure-examples/tree/master/spec-demo10</a></td></tr>
<tr><td>spec-demo11</td><td>validace IP adres, dvě varianty</td><td><a href="https://github.com/tisnik/clojure-examples/tree/master/spec-demo11">https://github.com/tisnik/clojure-examples/tree/master/spec-demo11</a></td></tr>
<tr><td>spec-demo12</td><td>generování testovacích dat</td><td><a href="https://github.com/tisnik/clojure-examples/tree/master/spec-demo12">https://github.com/tisnik/clojure-examples/tree/master/spec-demo12</a></td></tr>
</table>

<p>Pro spuštění projektů je vyžadován nainstalovaný správce projektů
<i>Leiningen</i>.</p>



<p><a name="k19"></a></p>
<h2 id="k19">19. Odkazy na předchozí části tohoto seriálu</h2>

<ol>

<li>Clojure  1: Úvod<br />
<a href="http://www.root.cz/clanky/clojure-aneb-jazyk-umoznujici-tvorbu-bezpecnych-vicevlaknovych-aplikaci-pro-jvm/">http://www.root.cz/clanky/clojure-aneb-jazyk-umoznujici-tvorbu-bezpecnych-vicevlaknovych-aplikaci-pro-jvm/</a>
</li>

<li>Clojure  2: Symboly, kolekce atd.<br />
<a href="http://www.root.cz/clanky/clojure-aneb-jazyk-umoznujici-tvorbu-bezpecnych-vicevlaknovych-aplikaci-pro-jvm-2-cast/">http://www.root.cz/clanky/clojure-aneb-jazyk-umoznujici-tvorbu-bezpecnych-vicevlaknovych-aplikaci-pro-jvm-2-cast/</a>
</li>

<li>Clojure  3: Funkcionální programování<br />
<a href="http://www.root.cz/clanky/clojure-aneb-jazyk-umoznujici-tvorbu-bezpecnych-vicevlaknovych-aplikaci-pro-jvm-3-cast-funkcionalni-programovani/">http://www.root.cz/clanky/clojure-aneb-jazyk-umoznujici-tvorbu-bezpecnych-vicevlaknovych-aplikaci-pro-jvm-3-cast-funkcionalni-programovani/</a>
</li>

<li>Clojure  4: Kolekce, sekvence a lazy sekvence<br />
<a href="http://www.root.cz/clanky/clojure-aneb-jazyk-umoznujici-tvorbu-bezpecnych-vicevlaknovych-aplikaci-pro-jvm-4-cast-kolekce-sekvence-a-lazy-sekvence/">http://www.root.cz/clanky/clojure-aneb-jazyk-umoznujici-tvorbu-bezpecnych-vicevlaknovych-aplikaci-pro-jvm-4-cast-kolekce-sekvence-a-lazy-sekvence/</a>
</li>

<li>Clojure  5: Sekvence, lazy sekvence a paralelní programy<br />
<a href="http://www.root.cz/clanky/clojure-a-bezpecne-aplikace-pro-jvm-sekvence-lazy-sekvence-a-paralelni-programy/">http://www.root.cz/clanky/clojure-a-bezpecne-aplikace-pro-jvm-sekvence-lazy-sekvence-a-paralelni-programy/</a>
</li>

<li>Clojure  6: Podpora pro paralelní programování<br />
<a href="http://www.root.cz/clanky/programovaci-jazyk-clojure-6-futures-nejsou-jen-financni-derivaty/">http://www.root.cz/clanky/programovaci-jazyk-clojure-6-futures-nejsou-jen-financni-derivaty/</a>
</li>

<li>Clojure  7: Další funkce pro paralelní programování<br />
<a href="http://www.root.cz/clanky/programovaci-jazyk-clojure-7-dalsi-podpurne-prostredky-pro-paralelni-programovani/">http://www.root.cz/clanky/programovaci-jazyk-clojure-7-dalsi-podpurne-prostredky-pro-paralelni-programovani/</a>
</li>

<li>Clojure  8: Identity, stavy, neměnné hodnoty a reference<br />
<a href="http://www.root.cz/clanky/programovaci-jazyk-clojure-8-identity-stavy-nemenne-hodnoty-a-referencni-typy/">http://www.root.cz/clanky/programovaci-jazyk-clojure-8-identity-stavy-nemenne-hodnoty-a-referencni-typy/</a>
</li>

<li>Clojure  9: Validátory, pozorovatelé a kooperace s Javou<br />
<a href="http://www.root.cz/clanky/programovaci-jazyk-clojure-9-validatory-pozorovatele-a-kooperace-mezi-clojure-a-javou/">http://www.root.cz/clanky/programovaci-jazyk-clojure-9-validatory-pozorovatele-a-kooperace-mezi-clojure-a-javou/</a>
</li>

<li>Clojure 10: Kooperace mezi Clojure a Javou<br />
<a href="http://www.root.cz/clanky/programovaci-jazyk-clojure-10-kooperace-mezi-clojure-a-javou-pokracovani/">http://www.root.cz/clanky/programovaci-jazyk-clojure-10-kooperace-mezi-clojure-a-javou-pokracovani/</a>
</li>

<li>Clojure 11: Generátorová notace seznamu/list comprehension<br />
<a href="http://www.root.cz/clanky/programovaci-jazyk-clojure-11-generatorova-notace-seznamu-list-comprehension/">http://www.root.cz/clanky/programovaci-jazyk-clojure-11-generatorova-notace-seznamu-list-comprehension/</a>
</li>

<li>Clojure 12: Překlad programů z Clojure do bajtkódu JVM I:<br />
<a href="http://www.root.cz/clanky/programovaci-jazyk-clojure-12-preklad-programu-z-clojure-do-bajtkodu-jvm/">http://www.root.cz/clanky/programovaci-jazyk-clojure-12-preklad-programu-z-clojure-do-bajtkodu-jvm/</a>
</li>

<li>Clojure 13: Překlad programů z Clojure do bajtkódu JVM II:<br />
<a href="http://www.root.cz/clanky/programovaci-jazyk-clojure-13-preklad-programu-z-clojure-do-bajtkodu-jvm-pokracovani/">http://www.root.cz/clanky/programovaci-jazyk-clojure-13-preklad-programu-z-clojure-do-bajtkodu-jvm-pokracovani/</a>
</li>

<li>Clojure 14: Základy práce se systémem maker<br />
<a href="http://www.root.cz/clanky/programovaci-jazyk-clojure-14-zaklady-prace-se-systemem-maker/">http://www.root.cz/clanky/programovaci-jazyk-clojure-14-zaklady-prace-se-systemem-maker/</a>
</li>

<li>Clojure 15: Tvorba uživatelských maker<br />
<a href="http://www.root.cz/clanky/programovaci-jazyk-clojure-15-tvorba-uzivatelskych-maker/">http://www.root.cz/clanky/programovaci-jazyk-clojure-15-tvorba-uzivatelskych-maker/</a>
</li>

<li>Clojure 16: Složitější uživatelská makra<br />
<a href="http://www.root.cz/clanky/programovaci-jazyk-clojure-16-slozitejsi-uzivatelska-makra/">http://www.root.cz/clanky/programovaci-jazyk-clojure-16-slozitejsi-uzivatelska-makra/</a>
</li>

<li>Clojure 17: Využití standardních maker v praxi<br />
<a href="http://www.root.cz/clanky/programovaci-jazyk-clojure-17-vyuziti-standardnich-maker-v-praxi/">http://www.root.cz/clanky/programovaci-jazyk-clojure-17-vyuziti-standardnich-maker-v-praxi/</a>
</li>

<li>Clojure 18: Základní techniky optimalizace aplikací<br />
<a href="http://www.root.cz/clanky/programovaci-jazyk-clojure-18-zakladni-techniky-optimalizace-aplikaci/">http://www.root.cz/clanky/programovaci-jazyk-clojure-18-zakladni-techniky-optimalizace-aplikaci/</a>
</li>

<li>Clojure 19: Vývojová prostředí pro Clojure<br />
<a href="http://www.root.cz/clanky/programovaci-jazyk-clojure-19-vyvojova-prostredi-pro-clojure/">http://www.root.cz/clanky/programovaci-jazyk-clojure-19-vyvojova-prostredi-pro-clojure/</a>
</li>

<li>Clojure 20: Vývojová prostředí pro Clojure (Vimu s REPL)<br />
<a href="http://www.root.cz/clanky/programovaci-jazyk-clojure-20-vyvojova-prostredi-pro-clojure-integrace-vimu-s-repl/">http://www.root.cz/clanky/programovaci-jazyk-clojure-20-vyvojova-prostredi-pro-clojure-integrace-vimu-s-repl/</a>
</li>

<li>Clojure 21: ClojureScript aneb překlad Clojure do JS<br />
<a href="http://www.root.cz/clanky/programovaci-jazyk-clojure-21-clojurescript-aneb-preklad-clojure-do-javascriptu/">http://www.root.cz/clanky/programovaci-jazyk-clojure-21-clojurescript-aneb-preklad-clojure-do-javascriptu/</a>
</li>

<li>Leiningen: nástroj pro správu projektů napsaných v Clojure<br />
<a href="http://www.root.cz/clanky/leiningen-nastroj-pro-spravu-projektu-napsanych-v-clojure/">http://www.root.cz/clanky/leiningen-nastroj-pro-spravu-projektu-napsanych-v-clojure/</a>
</li>

<li>Leiningen: nástroj pro správu projektů napsaných v Clojure (2)<br />
<a href="http://www.root.cz/clanky/leiningen-nastroj-pro-spravu-projektu-napsanych-v-clojure-2/">http://www.root.cz/clanky/leiningen-nastroj-pro-spravu-projektu-napsanych-v-clojure-2/</a>
</li>

<li>Leiningen: nástroj pro správu projektů napsaných v Clojure (3)<br />
<a href="http://www.root.cz/clanky/leiningen-nastroj-pro-spravu-projektu-napsanych-v-clojure-3/">http://www.root.cz/clanky/leiningen-nastroj-pro-spravu-projektu-napsanych-v-clojure-3/</a>
</li>

<li>Leiningen: nástroj pro správu projektů napsaných v Clojure (4)<br />
<a href="http://www.root.cz/clanky/leiningen-nastroj-pro-spravu-projektu-napsanych-v-clojure-4/">http://www.root.cz/clanky/leiningen-nastroj-pro-spravu-projektu-napsanych-v-clojure-4/</a>
</li>

<li>Leiningen: nástroj pro správu projektů napsaných v Clojure (5)<br />
<a href="http://www.root.cz/clanky/leiningen-nastroj-pro-spravu-projektu-napsanych-v-clojure-5/">http://www.root.cz/clanky/leiningen-nastroj-pro-spravu-projektu-napsanych-v-clojure-5/</a>
</li>

<li>Leiningen: nástroj pro správu projektů napsaných v Clojure (6)<br />
<a href="http://www.root.cz/clanky/leiningen-nastroj-pro-spravu-projektu-napsanych-v-clojure-6/">http://www.root.cz/clanky/leiningen-nastroj-pro-spravu-projektu-napsanych-v-clojure-6/</a>
</li>

<li>Programovací jazyk Clojure a databáze (1.část)<br />
<a href="http://www.root.cz/clanky/programovaci-jazyk-clojure-a-databaze-1-cast/">http://www.root.cz/clanky/programovaci-jazyk-clojure-a-databaze-1-cast/</a>
</li>

<li>Pluginy pro Leiningen<br />
<a href="http://www.root.cz/clanky/leiningen-nastroj-pro-spravu-projektu-napsanych-v-clojure-pluginy-pro-leiningen/">http://www.root.cz/clanky/leiningen-nastroj-pro-spravu-projektu-napsanych-v-clojure-pluginy-pro-leiningen/</a>
</li>

<li>Programovací jazyk Clojure a knihovny pro práci s vektory a maticemi<br />
<a href="http://www.root.cz/clanky/programovaci-jazyk-clojure-a-knihovny-pro-praci-s-vektory-a-maticemi/">http://www.root.cz/clanky/programovaci-jazyk-clojure-a-knihovny-pro-praci-s-vektory-a-maticemi/</a>
</li>

<li>Programovací jazyk Clojure a knihovny pro práci s vektory a maticemi (2)<br />
<a href="http://www.root.cz/clanky/programovaci-jazyk-clojure-a-knihovny-pro-praci-s-vektory-a-maticemi-2/">http://www.root.cz/clanky/programovaci-jazyk-clojure-a-knihovny-pro-praci-s-vektory-a-maticemi-2/</a>
</li>

<li>Programovací jazyk Clojure: syntéza procedurálních textur s využitím knihovny Clisk<br />
<a href="http://www.root.cz/clanky/programovaci-jazyk-clojure-synteza-proceduralnich-textur-s-vyuzitim-knihovny-clisk/">http://www.root.cz/clanky/programovaci-jazyk-clojure-synteza-proceduralnich-textur-s-vyuzitim-knihovny-clisk/</a>
</li>

<li>Programovací jazyk Clojure: syntéza procedurálních textur s využitím knihovny Clisk (2)<br />
<a href="http://www.root.cz/clanky/programovaci-jazyk-clojure-synteza-proceduralnich-textur-s-vyuzitim-knihovny-clisk-2/">http://www.root.cz/clanky/programovaci-jazyk-clojure-synteza-proceduralnich-textur-s-vyuzitim-knihovny-clisk-2/</a>
</li>

<li>Seesaw: knihovna pro snadnou tvorbu GUI v jazyce Clojure<br />
<a href="http://www.root.cz/clanky/seesaw-knihovna-pro-snadnou-tvorbu-gui-v-jazyce-clojure/">http://www.root.cz/clanky/seesaw-knihovna-pro-snadnou-tvorbu-gui-v-jazyce-clojure/</a>
</li>

<li>Seesaw: knihovna pro snadnou tvorbu GUI v jazyce Clojure (2)<br />
<a href="http://www.root.cz/clanky/seesaw-knihovna-pro-snadnou-tvorbu-gui-v-jazyce-clojure-2/">http://www.root.cz/clanky/seesaw-knihovna-pro-snadnou-tvorbu-gui-v-jazyce-clojure-2/</a>
</li>

<li>Seesaw: knihovna pro snadnou tvorbu GUI v jazyce Clojure (3)<br />
<a href="http://www.root.cz/clanky/seesaw-knihovna-pro-snadnou-tvorbu-gui-v-jazyce-clojure-3/">http://www.root.cz/clanky/seesaw-knihovna-pro-snadnou-tvorbu-gui-v-jazyce-clojure-3/</a>
</li>

<li>Programovací jazyk Clojure a práce s Gitem<br />
<a href="http://www.root.cz/clanky/programovaci-jazyk-clojure-a-prace-s-gitem/">http://www.root.cz/clanky/programovaci-jazyk-clojure-a-prace-s-gitem/</a>
</li>

<li>Programovací jazyk Clojure: syntéza procedurálních textur s využitím knihovny Clisk (dokončení)<br />
<a href="http://www.root.cz/clanky/programovaci-jazyk-clojure-synteza-proceduralnich-textur-s-vyuzitim-knihovny-clisk-dokonceni/">http://www.root.cz/clanky/programovaci-jazyk-clojure-synteza-proceduralnich-textur-s-vyuzitim-knihovny-clisk-dokonceni/</a>
</li>

<li>Programovací jazyk Clojure a práce s Gitem (2)<br />
<a href="http://www.root.cz/clanky/programovaci-jazyk-clojure-a-prace-s-gitem-2/">http://www.root.cz/clanky/programovaci-jazyk-clojure-a-prace-s-gitem-2/</a>
</li>

<li>Programovací jazyk Clojure – triky při práci s řetězci<br />
<a href="http://www.root.cz/clanky/programovaci-jazyk-clojure-triky-pri-praci-s-retezci/">http://www.root.cz/clanky/programovaci-jazyk-clojure-triky-pri-praci-s-retezci/</a>
</li>

<li>Programovací jazyk Clojure – triky při práci s kolekcemi<br />
<a href="http://www.root.cz/clanky/programovaci-jazyk-clojure-triky-pri-praci-s-kolekcemi/">http://www.root.cz/clanky/programovaci-jazyk-clojure-triky-pri-praci-s-kolekcemi/</a>
</li>

<li>Programovací jazyk Clojure – práce s mapami a množinami<br />
<a href="http://www.root.cz/clanky/programovaci-jazyk-clojure-prace-s-mapami-a-mnozinami/">http://www.root.cz/clanky/programovaci-jazyk-clojure-prace-s-mapami-a-mnozinami/</a>
</li>

<li>Programovací jazyk Clojure – základy zpracování XML<br />
<a href="http://www.root.cz/clanky/programovaci-jazyk-clojure-zaklady-zpracovani-xml/">http://www.root.cz/clanky/programovaci-jazyk-clojure-zaklady-zpracovani-xml/</a>
</li>

<li>Programovací jazyk Clojure – testování s využitím knihovny Expectations<br />
<a href="http://www.root.cz/clanky/programovaci-jazyk-clojure-testovani-s-vyuzitim-knihovny-expectations/">http://www.root.cz/clanky/programovaci-jazyk-clojure-testovani-s-vyuzitim-knihovny-expectations/</a>
</li>

<li>Programovací jazyk Clojure – některé užitečné triky použitelné (nejenom) v&nbsp;testech<br />
<a href="http://www.root.cz/clanky/programovaci-jazyk-clojure-nektere-uzitecne-triky-pouzitelne-nejenom-v-testech/">http://www.root.cz/clanky/programovaci-jazyk-clojure-nektere-uzitecne-triky-pouzitelne-nejenom-v-testech/</a>
</li>

<li>Enlive – výkonný šablonovací systém pro jazyk Clojure<br/>
<a href="http://www.root.cz/clanky/enlive-vykonny-sablonovaci-system-pro-jazyk-clojure/">http://www.root.cz/clanky/enlive-vykonny-sablonovaci-system-pro-jazyk-clojure/</a>
</li>

<li>Nástroj Leiningen a programovací jazyk Clojure: tvorba vlastních knihoven pro veřejný repositář Clojars<br />
<a href="http://www.root.cz/clanky/nastroj-leiningen-a-programovaci-jazyk-clojure-tvorba-vlastnich-knihoven-pro-verejny-repositar-clojars/">http://www.root.cz/clanky/nastroj-leiningen-a-programovaci-jazyk-clojure-tvorba-vlastnich-knihoven-pro-verejny-repositar-clojars/</a>
</li>

<li>Novinky v Clojure verze 1.8.0<br />
<a href="http://www.root.cz/clanky/novinky-v-clojure-verze-1-8-0/">http://www.root.cz/clanky/novinky-v-clojure-verze-1-8-0/</a>
</li>

<li>Asynchronní programování v&nbsp;Clojure s&nbsp;využitím knihovny core.async<br />
<a href="http://www.root.cz/clanky/asynchronni-programovani-v-clojure-s-vyuzitim-knihovny-core-async/">http://www.root.cz/clanky/asynchronni-programovani-v-clojure-s-vyuzitim-knihovny-core-async/</a>
</li>

<li>Asynchronní programování v&nbsp;Clojure s&nbsp;využitím knihovny core.async (pokračování)<br />
<a href="http://www.root.cz/clanky/asynchronni-programovani-v-clojure-s-vyuzitim-knihovny-core-async-pokracovani/">http://www.root.cz/clanky/asynchronni-programovani-v-clojure-s-vyuzitim-knihovny-core-async-pokracovani/</a>
</li>

<li>Asynchronní programování v Clojure s využitím knihovny core.async (dokončení)<br />
<a href="http://www.root.cz/clanky/asynchronni-programovani-v-clojure-s-vyuzitim-knihovny-core-async-dokonceni/">http://www.root.cz/clanky/asynchronni-programovani-v-clojure-s-vyuzitim-knihovny-core-async-dokonceni/</a>
</li>

<li>Vytváříme IRC bota v programovacím jazyce Clojure<br />
<a href="http://www.root.cz/clanky/vytvarime-irc-bota-v-programovacim-jazyce-clojure/">http://www.root.cz/clanky/vytvarime-irc-bota-v-programovacim-jazyce-clojure/</a>
</li>

<li>Gorilla REPL: interaktivní prostředí pro programovací jazyk Clojure<br />
<a href="https://www.root.cz/clanky/gorilla-repl-interaktivni-prostredi-pro-programovaci-jazyk-clojure/">https://www.root.cz/clanky/gorilla-repl-interaktivni-prostredi-pro-programovaci-jazyk-clojure/</a>
</li>

<li>Multimetody v Clojure aneb polymorfismus bez použití OOP<br />
<a href="https://www.root.cz/clanky/multimetody-v-clojure-aneb-polymorfismus-bez-pouziti-oop/">https://www.root.cz/clanky/multimetody-v-clojure-aneb-polymorfismus-bez-pouziti-oop/</a>
</li>

<li>Práce s externími Java archivy v programovacím jazyku Clojure<br />
<a href="https://www.root.cz/clanky/prace-s-externimi-java-archivy-v-programovacim-jazyku-clojure/">https://www.root.cz/clanky/prace-s-externimi-java-archivy-v-programovacim-jazyku-clojure/</a>
</li>

<li>Pixie: lehký skriptovací jazyk s „kouzelnými“ schopnostmi<br />
<a href="https://www.root.cz/clanky/pixie-lehky-skriptovaci-jazyk-s-kouzelnymi-schopnostmi/">https://www.root.cz/clanky/pixie-lehky-skriptovaci-jazyk-s-kouzelnymi-schopnostmi/</a>
</li>

<li>Programovací jazyk Pixie: funkce ze základní knihovny a použití FFI<br />
<a href="https://www.root.cz/clanky/programovaci-jazyk-pixie-funkce-ze-zakladni-knihovny-a-pouziti-ffi/">https://www.root.cz/clanky/programovaci-jazyk-pixie-funkce-ze-zakladni-knihovny-a-pouziti-ffi/</a>
</li>

<li>Novinky v Clojure verze 1.9.0<br />
<a href="https://www.root.cz/clanky/novinky-v-clojure-verze-1-9-0/">https://www.root.cz/clanky/novinky-v-clojure-verze-1-9-0/</a>
</li>

<li>Validace dat s&nbsp;využitím knihovny spec v&nbsp;Clojure 1.9.0<br />
<a href="https://www.root.cz/clanky/validace-dat-s-vyuzitim-knihovny-spec-v-clojure-1-9-0/">https://www.root.cz/clanky/validace-dat-s-vyuzitim-knihovny-spec-v-clojure-1-9-0/</a>
</li>

</ol>



<p><a name="k20"></a></p>
<h2 id="k20">20. Odkazy na Internetu</h2>

<ol>

<li>5 Differences between clojure.spec and Schema<br />
<a href="https://lispcast.com/clojure.spec-vs-schema/">https://lispcast.com/clojure.spec-vs-schema/</a>
</li>

<li>Schema: Clojure(Script) library for declarative data description and validation<br />
<a href="https://github.com/plumatic/schema">https://github.com/plumatic/schema</a>
</li>

<li>Zip archiv s&nbsp;Clojure 1.9.0<br />
<a href="http://repo1.maven.org/maven2/org/clojure/clojure/1.9.0/clojure-1.9.0.zip">http://repo1.maven.org/maven2/org/clojure/clojure/1.9.0/clojure-1.9.0.zip</a>
</li>

<li>Clojure 1.9 is now available<br />
<a href="https://clojure.org/news/2017/12/08/clojure19">https://clojure.org/news/2017/12/08/clojure19</a>
</li>

<li>Deps and CLI Guide<br />
<a href="https://clojure.org/guides/deps_and_cli">https://clojure.org/guides/deps_and_cli</a>
</li>

<li>Changes to Clojure in Version 1.9<br />
<a href="https://github.com/clojure/clojure/blob/master/changes.md">https://github.com/clojure/clojure/blob/master/changes.md</a>
</li>

<li>clojure.spec - Rationale and Overview<br />
<a href="https://clojure.org/about/spec">https://clojure.org/about/spec</a>
</li>

<li>Zip archiv s&nbsp;Clojure 1.8.0<br />
<a href="http://repo1.maven.org/maven2/org/clojure/clojure/1.8.0/clojure-1.8.0.zip">http://repo1.maven.org/maven2/org/clojure/clojure/1.8.0/clojure-1.8.0.zip</a>
</li>

<li>Clojure 1.8 is now available<br />
<a href="http://clojure.org/news/2016/01/19/clojure18">http://clojure.org/news/2016/01/19/clojure18</a>
</li>

<li>Socket Server REPL<br />
<a href="http://dev.clojure.org/display/design/Socket+Server+REPL">http://dev.clojure.org/display/design/Socket+Server+REPL</a>
</li>

<li>CLJ-1671: Clojure socket server<br />
<a href="http://dev.clojure.org/jira/browse/CLJ-1671">http://dev.clojure.org/jira/browse/CLJ-1671</a>
</li>

<li>CLJ-1449: Add clojure.string functions for portability to ClojureScript<br />
<a href="http://dev.clojure.org/jira/browse/CLJ-1449">http://dev.clojure.org/jira/browse/CLJ-1449</a>
</li>

<li>Launching a Socket Server<br />
<a href="http://clojure.org/reference/repl_and_main#_launching_a_socket_server">http://clojure.org/reference/repl_and_main#_launching_a_socket_server</a>
</li>

<li>API for clojure.string<br />
<a href="http://clojure.github.io/clojure/branch-master/clojure.string-api.html">http://clojure.github.io/clojure/branch-master/clojure.string-api.html</a>
</li>

<li>Clojars:<br />
<a href="https://clojars.org/">https://clojars.org/</a>
</li>

<li>Seznam knihoven na Clojars:<br />
<a href="https://clojars.org/projects">https://clojars.org/projects</a>
</li>

<li>Clojure Cookbook: Templating HTML with Enlive<br />
<a href="https://github.com/clojure-cookbook/clojure-cookbook/blob/master/07_webapps/7-11_enlive.asciidoc">https://github.com/clojure-cookbook/clojure-cookbook/blob/master/07_webapps/7-11_enlive.asciidoc</a>
</li>

<li>An Introduction to Enlive<br />
<a href="https://github.com/swannodette/enlive-tutorial/">https://github.com/swannodette/enlive-tutorial/</a>
</li>

<li>Enlive na GitHubu<br />
<a href="https://github.com/cgrand/enlive">https://github.com/cgrand/enlive</a>
</li>

<li>Expectations: příklady atd.<br />
<a href="http://jayfields.com/expectations/">http://jayfields.com/expectations/</a>
</li>

<li>Expectations na GitHubu<br />
<a href="https://github.com/jaycfields/expectations">https://github.com/jaycfields/expectations</a>
</li>

<li>Lein-expectations na GitHubu<br />
<a href="https://github.com/gar3thjon3s/lein-expectations">https://github.com/gar3thjon3s/lein-expectations</a>
</li>

<li>Testing Clojure With Expectations<br />
<a href="https://semaphoreci.com/blog/2014/09/23/testing-clojure-with-expectations.html">https://semaphoreci.com/blog/2014/09/23/testing-clojure-with-expectations.html</a>
</li>

<li>Clojure testing TDD/BDD libraries: clojure.test vs Midje vs Expectations vs Speclj<br />
<a href="https://www.reddit.com/r/Clojure/comments/1viilt/clojure_testing_tddbdd_libraries_clojuretest_vs/">https://www.reddit.com/r/Clojure/comments/1viilt/clojure_testing_tddbdd_libraries_clojuretest_vs/</a>
</li>

<li>Testing: One assertion per test<br />
<a href="http://blog.jayfields.com/2007/06/testing-one-assertion-per-test.html">http://blog.jayfields.com/2007/06/testing-one-assertion-per-test.html</a>
</li>

<li>Rewriting Your Test Suite in Clojure in 24 hours<br />
<a href="http://blog.circleci.com/rewriting-your-test-suite-in-clojure-in-24-hours/">http://blog.circleci.com/rewriting-your-test-suite-in-clojure-in-24-hours/</a>
</li>

<li>Clojure doc: zipper<br />
<a href="http://clojuredocs.org/clojure.zip/zipper">http://clojuredocs.org/clojure.zip/zipper</a>
</li>

<li>Clojure doc: parse<br />
<a href="http://clojuredocs.org/clojure.xml/parse">http://clojuredocs.org/clojure.xml/parse</a>
</li>

<li>Clojure doc: xml-zip<br />
<a href="http://clojuredocs.org/clojure.zip/xml-zip">http://clojuredocs.org/clojure.zip/xml-zip</a>
</li>

<li>Clojure doc: xml-seq<br />
<a href="http://clojuredocs.org/clojure.core/xml-seq">http://clojuredocs.org/clojure.core/xml-seq</a>
</li>

<li>Parsing XML in Clojure<br />
<a href="https://github.com/clojuredocs/guides">https://github.com/clojuredocs/guides</a>
</li>

<li>Clojure Zipper Over Nested Vector<br />
<a href="https://vitalyper.wordpress.com/2010/11/23/clojure-zipper-over-nested-vector/">https://vitalyper.wordpress.com/2010/11/23/clojure-zipper-over-nested-vector/</a>
</li>

<li>Understanding Clojure's PersistentVector implementation<br />
<a href="http://blog.higher-order.net/2009/02/01/understanding-clojures-persistentvector-implementation">http://blog.higher-order.net/2009/02/01/understanding-clojures-persistentvector-implementation</a>
</li>

<li>Understanding Clojure's PersistentHashMap (deftwice...)<br />
<a href="http://blog.higher-order.net/2009/09/08/understanding-clojures-persistenthashmap-deftwice.html">http://blog.higher-order.net/2009/09/08/understanding-clojures-persistenthashmap-deftwice.html</a>
</li>

<li>Assoc and Clojure's PersistentHashMap: part ii<br />
<a href="http://blog.higher-order.net/2010/08/16/assoc-and-clojures-persistenthashmap-part-ii.html">http://blog.higher-order.net/2010/08/16/assoc-and-clojures-persistenthashmap-part-ii.html</a>
</li>

<li>Ideal Hashtrees (paper)<br />
<a href="http://lampwww.epfl.ch/papers/idealhashtrees.pdf">http://lampwww.epfl.ch/papers/idealhashtrees.pdf</a>
</li>

<li>Clojure home page<br />
<a href="http://clojure.org/">http://clojure.org/</a>
</li>

<li>Clojure (downloads)<br />
<a href="http://clojure.org/downloads">http://clojure.org/downloads</a>
</li>

<li>Clojure Sequences<br />
<a href="http://clojure.org/sequences">http://clojure.org/sequences</a>
</li>

<li>Clojure Data Structures<br />
<a href="http://clojure.org/data_structures">http://clojure.org/data_structures</a>
</li>

<li>The Structure and Interpretation of Computer Programs: 2.2.1  Representing Sequences<br />
<a href="http://mitpress.mit.edu/sicp/full-text/book/book-Z-H-15.html#%_sec_2.2.1">http://mitpress.mit.edu/sicp/full-text/book/book-Z-H-15.html#%_sec_2.2.1</a>
</li>

<li>The Structure and Interpretation of Computer Programs: 3.3.1  Mutable List Structure<br />
<a href="http://mitpress.mit.edu/sicp/full-text/book/book-Z-H-22.html#%_sec_3.3.1">http://mitpress.mit.edu/sicp/full-text/book/book-Z-H-22.html#%_sec_3.3.1</a>
</li>

<li>Clojure - Functional Programming for the JVM<br />
<a href="http://java.ociweb.com/mark/clojure/article.html">http://java.ociweb.com/mark/clojure/article.html</a>
</li>

<li>Clojure quick reference<br />
<a href="http://faustus.webatu.com/clj-quick-ref.html">http://faustus.webatu.com/clj-quick-ref.html</a>
</li>

<li>4Clojure<br />
<a href="http://www.4clojure.com/">http://www.4clojure.com/</a>
</li>

<li>ClojureDoc (rozcestník s&nbsp;dokumentací jazyka Clojure)<br />
<a href="http://clojuredocs.org/">http://clojuredocs.org/</a>
</li>

<li>Clojure (na Wikipedia EN)<br />
<a href="http://en.wikipedia.org/wiki/Clojure">http://en.wikipedia.org/wiki/Clojure</a>
</li>

<li>Clojure (na Wikipedia CS)<br />
<a href="http://cs.wikipedia.org/wiki/Clojure">http://cs.wikipedia.org/wiki/Clojure</a>
</li>

<li>SICP (The Structure and Interpretation of Computer Programs)<br />
<a href="http://mitpress.mit.edu/sicp/">http://mitpress.mit.edu/sicp/</a>
</li>

<li>Pure function<br />
<a href="http://en.wikipedia.org/wiki/Pure_function">http://en.wikipedia.org/wiki/Pure_function</a>
</li>

<li>Funkcionální programování<br />
<a href="http://cs.wikipedia.org/wiki/Funkcionální_programování">http://cs.wikipedia.org/wiki/Funkcionální_programování</a>
</li>

<li>Čistě funkcionální (datové struktury, jazyky, programování)<br />
<a href="http://cs.wikipedia.org/wiki/Čistě_funkcionální">http://cs.wikipedia.org/wiki/Čistě_funkcionální</a>
</li>

<li>Clojure Macro Tutorial (Part I, Getting the Compiler to Write Your Code For You)<br />
<a href="http://www.learningclojure.com/2010/09/clojure-macro-tutorial-part-i-getting.html">http://www.learningclojure.com/2010/09/clojure-macro-tutorial-part-i-getting.html</a>
</li>

<li>Clojure Macro Tutorial (Part II: The Compiler Strikes Back)<br />
<a href="http://www.learningclojure.com/2010/09/clojure-macro-tutorial-part-ii-compiler.html">http://www.learningclojure.com/2010/09/clojure-macro-tutorial-part-ii-compiler.html</a>
</li>

<li>Clojure Macro Tutorial (Part III: Syntax Quote)<br />
<a href="http://www.learningclojure.com/2010/09/clojure-macro-tutorial-part-ii-syntax.html">http://www.learningclojure.com/2010/09/clojure-macro-tutorial-part-ii-syntax.html</a>
</li>

<li>Tech behind Tech: Clojure Macros Simplified<br />
<a href="http://techbehindtech.com/2010/09/28/clojure-macros-simplified/">http://techbehindtech.com/2010/09/28/clojure-macros-simplified/</a>
</li>

<li>Fatvat - Exploring functional programming: Clojure Macros<br />
<a href="http://www.fatvat.co.uk/2009/02/clojure-macros.html">http://www.fatvat.co.uk/2009/02/clojure-macros.html</a>
</li>

<li>Eulerovo číslo<br />
<a href="http://cs.wikipedia.org/wiki/Eulerovo_číslo">http://cs.wikipedia.org/wiki/Eulerovo_číslo</a>
</li>

<li>List comprehension<br />
<a href="http://en.wikipedia.org/wiki/List_comprehension">http://en.wikipedia.org/wiki/List_comprehension</a>
</li>

<li>List Comprehensions in Clojure<br />
<a href="http://asymmetrical-view.com/2008/11/18/list-comprehensions-in-clojure.html">http://asymmetrical-view.com/2008/11/18/list-comprehensions-in-clojure.html</a>
</li>

<li>Clojure Programming Concepts: List Comprehension<br />
<a href="http://en.wikibooks.org/wiki/Clojure_Programming/Concepts#List_Comprehension">http://en.wikibooks.org/wiki/Clojure_Programming/Concepts#List_Comprehension</a>
</li>

<li>Clojure core API: for macro<br />
<a href="http://clojure.github.com/clojure/clojure.core-api.html#clojure.core/for">http://clojure.github.com/clojure/clojure.core-api.html#clojure.core/for</a>
</li>

<li>cirrus machina - The Clojure for macro<br />
<a href="http://www.cirrusmachina.com/blog/comment/the-clojure-for-macro/">http://www.cirrusmachina.com/blog/comment/the-clojure-for-macro/</a>
</li>

<li>Riastradh's Lisp Style Rules<br />
<a href="http://mumble.net/~campbell/scheme/style.txt">http://mumble.net/~campbell/scheme/style.txt</a>
</li>

<li>Dynamic Languages Strike Back<br />
<a href="http://steve-yegge.blogspot.cz/2008/05/dynamic-languages-strike-back.html">http://steve-yegge.blogspot.cz/2008/05/dynamic-languages-strike-back.html</a>
</li>

<li>Scripting: Higher Level Programming for the 21st Century<br />
<a href="http://www.tcl.tk/doc/scripting.html">http://www.tcl.tk/doc/scripting.html</a>
</li>

<li>Java Virtual Machine Support for Non-Java Languages<br />
<a href="http://docs.oracle.com/javase/7/docs/technotes/guides/vm/multiple-language-support.html">http://docs.oracle.com/javase/7/docs/technotes/guides/vm/multiple-language-support.html</a>
</li>

<li>Třída java.lang.String<br />
<a href="http://docs.oracle.com/javase/7/docs/api/java/lang/String.html">http://docs.oracle.com/javase/7/docs/api/java/lang/String.html</a>
</li>

<li>Třída java.lang.StringBuffer<br />
<a href="http://docs.oracle.com/javase/7/docs/api/java/lang/StringBuffer.html">http://docs.oracle.com/javase/7/docs/api/java/lang/StringBuffer.html</a>
</li>

<li>Třída java.lang.StringBuilder<br />
<a href="http://docs.oracle.com/javase/7/docs/api/java/lang/StringBuilder.html">http://docs.oracle.com/javase/7/docs/api/java/lang/StringBuilder.html</a>
</li>

<li>StringBuffer versus String<br />
<a href="http://www.javaworld.com/article/2076072/build-ci-sdlc/stringbuffer-versus-string.html">http://www.javaworld.com/article/2076072/build-ci-sdlc/stringbuffer-versus-string.html</a>
</li>

<li>Threading macro (dokumentace k&nbsp;jazyku Clojure)<br />
<a href="https://clojure.github.io/clojure/clojure.core-api.html#clojure.core/-&gt;">https://clojure.github.io/clojure/clojure.core-api.html#clojure.core/-&gt;</a>
</li>

<li>Understanding the Clojure -&gt; macro<br />
<a href="http://blog.fogus.me/2009/09/04/understanding-the-clojure-macro/">http://blog.fogus.me/2009/09/04/understanding-the-clojure-macro/</a>
</li>

<li>clojure.inspector<br />
<a href="http://clojure.github.io/clojure/clojure.inspector-api.html">http://clojure.github.io/clojure/clojure.inspector-api.html</a>
</li>

<li>The Clojure Toolbox<br />
<a href="http://www.clojure-toolbox.com/">http://www.clojure-toolbox.com/</a>
</li>

<li>Unit Testing in Clojure<br />
<a href="http://nakkaya.com/2009/11/18/unit-testing-in-clojure/">http://nakkaya.com/2009/11/18/unit-testing-in-clojure/</a>
</li>

<li>Testing in Clojure (Part-1: Unit testing)<br />
<a href="http://blog.knoldus.com/2014/03/22/testing-in-clojure-part-1-unit-testing/">http://blog.knoldus.com/2014/03/22/testing-in-clojure-part-1-unit-testing/</a>
</li>

<li>API for clojure.test - Clojure v1.6 (stable)<br />
<a href="https://clojure.github.io/clojure/clojure.test-api.html">https://clojure.github.io/clojure/clojure.test-api.html</a>
</li>

<li>Leiningen: úvodní stránka<br />
<a href="http://leiningen.org/">http://leiningen.org/</a>
</li>

<li>Leiningen: Git repository<br />
<a href="https://github.com/technomancy/leiningen">https://github.com/technomancy/leiningen</a>
</li>

<li>leiningen-win-installer<br />
<a href="http://leiningen-win-installer.djpowell.net/">http://leiningen-win-installer.djpowell.net/</a>
</li>

<li>Clojure.org: Vars and the Global Environment<br />
<a href="http://clojure.org/Vars">http://clojure.org/Vars</a>
</li>

<li>Clojure.org: Refs and Transactions<br />
<a href="http://clojure.org/Refs">http://clojure.org/Refs</a>
</li>

<li>Clojure.org: Atoms<br />
<a href="http://clojure.org/Atoms">http://clojure.org/Atoms</a>
</li>

<li>Clojure.org: Agents as Asynchronous Actions<br />
<a href="http://clojure.org/agents">http://clojure.org/agents</a>
</li>

<li>Transient Data Structures
<a href="http://clojure.org/transients">http://clojure.org/transients</a>
</li>

</ol>



<p></p><p></p>
<p><small>Autor: <a href="http://www.fit.vutbr.cz/~tisnovpa">Pavel Tišnovský</a> &nbsp; 2018</small></p>
</body>
</html>

