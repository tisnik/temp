<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
        "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html>
<head>
<title>Validace dat s využitím knihovny spec v Clojure 1.9.0 (dokončení)</title>
<meta name="Author" content="Pavel Tisnovsky" />
<meta name="Generator" content="vim" />
<meta http-equiv="content-type" content="text/html; charset=utf-8" />
<style type="text/css">
         body {color:#000000; background:#ffffff;}
         h1  {font-family: arial, helvetica, sans-serif; color:#ffffff; background-color:#c00000; text-align:center; padding-left:1em}
         h2  {font-family: arial, helvetica, sans-serif; color:#ffffff; background-color:#0000c0; padding-left:1em; text-align:left}
         h3  {font-family: arial, helvetica, sans-serif; color:#000000; background-color:#c0c0c0; padding-left:1em; text-align:left}
         h4  {font-family: arial, helvetica, sans-serif; color:#000000; background-color:#e0e0e0; padding-left:1em; text-align:left}
         a   {font-family: arial, helvetica, sans-serif;}
         li  {font-family: arial, helvetica, sans-serif; color:#000000; text-align:justify; width:450px;}
         ol  {font-family: arial, helvetica, sans-serif; color:#000000; text-align:justify; width:450px;}
         ul  {font-family: arial, helvetica, sans-serif; color:#000000; text-align:justify; width:450px;}
         p   {font-family: arial, helvetica, sans-serif; color:#000000; text-align:justify;}
         pre {background:#e0e0e0}
</style>
</head>

<body>

<h1>Validace dat s využitím knihovny spec v Clojure 1.9.0 (dokončení)</h1>

<h3>Pavel Tišnovský</h3>

<p></p>

<h1>Úvodník</h1>

<p>Popis možností nabízených knihovnou spec, kterou jsme se zabývali v předchozích dvou článcích, dnes dokončíme. Ukážeme si především velmi užitečnou vlastnost: možnost deklarovat validační kritéria způsobem, který do jisté míry připomíná zápis regulárních výrazů.</p>



<h2>Obsah</h2>

<p><a href="#k01">1. Validace dat s&nbsp;využitím knihovny spec v&nbsp;Clojure 1.9.0 (dokončení)</a></p>
<p><a href="#k02">2. Spuštění interaktivní smyčky REPL s&nbsp;interpretrem Clojure 1.9.0</a></p>
<p><a href="#k03">3. Použití klauzule <strong>spec/and</strong></a></p>
<p><a href="#k04">4. Použití klauzule <strong>spec/or</strong></a></p>
<p><a href="#k05">5. Validace v&nbsp;případě, že hodnota může být <strong>nil</strong></a></p>
<p><a href="#k06">6. Vylepšení validace s&nbsp;využitím makra <strong>nilable</strong></a></p>
<p><a href="#k07">7. Varianty funkce <strong>explain</strong> &ndash; <strong>explain-str</strong> a <strong>explain-data</strong></a></p>
<p><a href="#k08">8. Malé zopakování z&nbsp;minula: základní validace obsahu kolekcí</a></p>
<p><a href="#k09">9. První varianta validátoru IPv4 adres</a></p>
<p><a href="#k10">10. Validace sekvencí s&nbsp;využitím operátorů převzatých z&nbsp;regulárních výrazů</a></p>
<p><a href="#k11">11. Druhá varianta validátoru IPv4 adres</a></p>
<p><a href="#k12">12. Příklad validace sekvence s&nbsp;využitím operátoru <strong>+</strong></a></p>
<p><a href="#k13">13. Validace složitější datové struktury</a></p>
<p><a href="#k14">14. Kombinace operátorů <strong>+</strong> a <strong>?</strong></a></p>
<p><a href="#k15">15. Validace vektoru s&nbsp;konfiguračními volbami</a></p>
<p><a href="#k16">16. Automatický destructuring po validaci datové struktury</a></p>
<p><a href="#k17">17. Generování testovacích dat na základě validačních kritérií</a></p>
<p><a href="#k18">18. Repositář s&nbsp;demonstračními příklady</a></p>
<p><a href="#k19">19. Odkazy na předchozí části tohoto seriálu</a></p>
<p><a href="#k20">20. Odkazy na Internetu</a></p>



<p><a name="k01"></a></p>
<h2 id="k01">1. Validace dat s&nbsp;využitím knihovny spec v&nbsp;Clojure 1.9.0 (dokončení)</h2>

<p>V&nbsp;dnešním článku o nejnovější <a
href="https://github.com/clojure/clojure/blob/master/changes.md">stabilní verzi
1.9.0</a> programovacího jazyka <a href="https://clojure.org/">Clojure</a>
dokončíme popis možností nabízených velmi užitečnou knihovnou nazvanou
<i>spec</i>. Již <a
href="https://www.root.cz/clanky/validace-dat-s-vyuzitim-knihovny-spec-v-clojure-1-9-0/">z&nbsp;předchozího
článku</a> víme, že tato knihovna slouží k&nbsp;deklaraci očekávané struktury
dat (popř.&nbsp;i jediné hodnoty) a následně k&nbsp;jejich validaci. Složitější
datové struktury jsou v&nbsp;jazyku Clojure většinou reprezentovány formou
slovníku, který (rekurzivně) obsahuje další struktury, tj.&nbsp;další slovníky,
seznamy, vektory či množiny. Právě z&nbsp;tohoto důvodu používá knihovna
<i>spec</i> operátory (či možná lépe řečeno klauzule), které do jisté míry
dokážou zkontrolovat i sekvence, jejichž délka nemusí být dopředu známá. Tyto
operátory byly převzaty z&nbsp;regulárních výrazů a mají i stejnou vyjadřovací
schopnost (včetně všech omezení). Pěkným příkladem může být seznam či vektor
osob, mapa představující konfigurační volby apod.</p>

<p>Ve druhé části článku se zmíníme i o kombinaci schopností knihoven
<i>spec</i> a <i>test.check</i> pro generování testovacích dat. Samotná
knihovna <i>test.check</i> je přitom reimplementací známé knihovny <a
href="https://en.wikipedia.org/wiki/QuickCheck">QuickCheck</a>, která původně
vznikla v&nbsp;Haskellu, ale později byla znovu implementována pro potřeby
dalších programovacích jazyků.</p>



<p><a name="k02"></a></p>
<h2 id="k02">2. Spuštění interaktivní smyčky REPL s&nbsp;interpretrem Clojure 1.9.0</h2>

<p>Všechny dále uváděné deklarace, volání funkcí i maker atd., budeme zkoušet
přímo v&nbsp;interaktivní smyčce (<a
href="https://en.wikipedia.org/wiki/Read%E2%80%93eval%E2%80%93print_loop">REPL</a>)
programovacího jazyka Clojure. Ta ovšem musí být spuštěna pro interpret Clojure
1.9.0 (nebo i Clojure 1.10.0 Alpha), což lze zajistit například tak, že
v&nbsp;adresáři projektu <a
href="https://github.com/tisnik/clojure-examples/tree/master/clojure9-test">clojure9-test</a>
spustíte skript nazvaný <strong>repl</strong>:</p>

<pre>
$ <strong>./repl</strong>
&nbsp;
nREPL server started on port 35985 on host 127.0.0.1 - nrepl://127.0.0.1:35985
REPL-y 0.3.7, nREPL 0.2.12
Clojure <strong>1.9.0</strong>
OpenJDK 64-Bit Server VM 1.8.0_151-b12
    Docs: (doc function-name-here)
          (find-doc "part-of-name-here")
  Source: (source function-name-here)
 Javadoc: (javadoc java-object-or-class-here)
    Exit: Control+D or (exit) or (quit)
 Results: Stored in vars *1, *2, *3, an exception in *e
&nbsp;
clojure9-test.core=&gt;
</pre>

<p>Ihned poté si přenastavte jmenný prostor
z&nbsp;<strong>clojure-9-test.core</strong> na <strong>user</strong> a následně
naimportujte knihovnu <i>spec</i>:</p>

<pre>
clojure9-test.core=&gt; <strong>(ns user)</strong>
nil
&nbsp;
user=&gt; <strong>(require '[clojure.spec.alpha :as spec])</strong>
nil
</pre>

<p>Ještě nám zbývá dořešit maličkost &ndash; po změně jmenného prostoru totiž
přestane být dostupné makro <strong>doc</strong>, což si ostatně můžeme
vyzkoušet:</p>

<pre>
user=&gt; <strong>(doc doc)</strong>
&nbsp;
CompilerException java.lang.RuntimeException: Unable to resolve symbol: doc in this context, compiling:(/tmp/form-init3972254276603866443.clj:1:1) 
</pre>

<p>Makro <strong>doc</strong> je ovšem velmi užitečné a několikrát ho
použijeme, takže si ho naimportujeme:</p>

<pre>
user=&gt; <strong>(use '[clojure.repl :only (doc)])</strong>
nil
</pre>

<p>Opět zkusíme toto makro zavolat, tentokrát již úspěšně:</p>

<pre>
user=&gt; <strong>(doc doc)</strong>
-------------------------
clojure.repl/doc
([name])
Macro
  Prints documentation for a var or special form given its name,
   or for a spec if given a keyword
nil
</pre>

<p>Nyní je již interaktivní smyčka REPL připravena pro další testy.</p>



<p><a name="k03"></a></p>
<h2 id="k03">3. Použití klauzule <strong>spec/and</strong></h2>

<p>Začneme krátkým připomenutím existence klauzule <strong>and</strong>, která
nám umožňuje spojit větší množství validačních kritérií. Data budou zvalidována
jen ve chvíli, kdy budou splněna všechna kritéria (ta jsou reprezentována
&bdquo;obyčejnými&ldquo; predikáty). Samotná klauzule <strong>and</strong> (asi
nepřekvapivě reprezentovaná makrem) akceptuje libovolné množství kritérií:</p>

<pre>
user=&gt; <strong>(doc spec/and)</strong>
-------------------------
clojure.spec.alpha/and
([&amp; pred-forms])
Macro
  Takes predicate/spec-forms, e.g.
&nbsp;
  (s/and even? #(&lt; % 42))
&nbsp;
  Returns a spec that returns the conformed value. Successive
  conformed values propagate through rest of predicates.
</pre>

<p>Ukažme si nyní jednoduchý příklad použití této klauzule. Budeme testovat,
zda nějaká hodnota odpovídá UID běžného uživatele, tj.&nbsp;zda se jedná o
kladné celé číslo větší nebo rovno 1000 a současně menší než 2<sup>31</sup>-1
(u starších Unixů jen 65535 nebo dokonce jen 32767). S&nbsp;využitím klauzule
<strong>and</strong> se validace zapíše jednoduše. Povšimněte si, že využíváme
anonymní funkce; samozřejmě je však můžeme nahradit explicitně zapsanými
predikáty:</p>

<pre>
user=&gt; <strong>(spec/def ::user-id (spec/and pos-int? #(&gt;= % 1000) #(&lt; % Integer/MAX_VALUE)))</strong>
:user/user-id
</pre>

<p>K&nbsp;validačnímu kritériu se automaticky vygenerovala nápověda:</p>

<pre>
user=&gt; <strong>(doc ::user-id)</strong>
-------------------------
:user/user-id
Spec
  (and pos-int? (&gt;= % 1000) (&lt; % MAX_VALUE))
</pre>

<p>Funkcionalitu si samozřejmě ihned můžeme vyzkoušet:</p>

<pre>
user=&gt; <strong>(spec/valid? ::user-id nil)</strong>
false
&nbsp;
user=&gt; <strong>(spec/valid? ::user-id "hello")</strong>
false
&nbsp;
user=&gt; <strong>(spec/valid? ::user-id 1)</strong>
false
&nbsp;
user=&gt; <strong>(spec/valid? ::user-id 1000)</strong>
true
&nbsp;
user=&gt; <strong>(spec/valid? ::user-id 10000000)</strong>
true
&nbsp;
user=&gt; <strong>(spec/valid? ::user-id 100000000)</strong>
true
&nbsp;
user=&gt; <strong>(spec/valid? ::user-id 1000000000)</strong>
true
&nbsp;
user=&gt; <strong>(spec/valid? ::user-id 10000000000)</strong>
false
</pre>

<p>Tato klauzule je použita i v&nbsp;dnešním prvním demonstračním příkladu,
který naleznete na adrese <a
href="https://github.com/tisnik/clojure-examples/tree/master/spec-demo6">https://github.com/tisnik/clojure-examples/tree/master/spec-demo6</a>.</p>



<p><a name="k04"></a></p>
<h2 id="k04">4. Použití klauzule <strong>spec/or</strong></h2>

<p>Kromě klauzule <strong>and</strong> samozřejmě existuje i klauzule
<strong>or</strong>, která je opět reprezentovaná makrem. Tato klauzule
umožňuje, aby bylo možné zapsat větší množství predikátů, přičemž data budou
validována i v&nbsp;případě, kdy bude platný jeden jediný predikát (nezávisle
na tom který). Před každým predikátem (validačním kritériem) se zapisuje jeho
identifikátor, aby bylo možné později určit, která podmínka (podmínky) byly
splněny a které nikoli:</p>

<pre>
user=&gt; <strong>(doc spec/or)</strong>
-------------------------
clojure.spec.alpha/or
([&amp; key-pred-forms])
Macro
  Takes key+pred pairs, e.g.
&nbsp;
  (s/or :even even? :small #(&lt; % 42))
&nbsp;
  Returns a destructuring spec that returns a map entry containing the
  key of the first matching pred and the corresponding value. Thus the
  'key' and 'val' functions can be used to refer generically to the
  components of the tagged return.
</pre>

<p>Opět si funkci tohoto predikátu ukažme na příkladu. Tentokrát budeme
testovat, zda validovaná hodnota představuje identifikátor, který může být
představován buď řetězcem nebo kladným celým číslem. Povšimněte si, že před
oběma predikáty <strong>string?</strong> a <strong>pos-int?</strong> skutečně
zapisujeme jednoznačný klíč:</p>

<pre>
user=&gt; <strong>(spec/def ::unique-id (spec/or :name string? :id pos-int?))</strong>
:user/unique-id
</pre>

<p>Vygenerovaná nápověda je podobná nápovědě, kterou jsme viděli
v&nbsp;předchozí kapitole:</p>

<pre>
user=&gt; <strong>(doc ::unique-id)</strong>
-------------------------
:user/unique-id
Spec
  (or :name string? :id pos-int?)
</pre>

<p>Správnou funkci validace si opět otestujeme, podobně jako v&nbsp;předchozím případě:</p>

<pre>
user=&gt; <strong>(spec/valid? ::unique-id 42)</strong>
true
&nbsp;
user=&gt; <strong>(spec/valid? ::unique-id "foo")</strong>
true
&nbsp;
user=&gt; <strong>(spec/valid? ::unique-id nil)</strong>
false
&nbsp;
user=&gt; <strong>(spec/valid? ::unique-id [])</strong>
false
</pre>

<p>Pomocí <strong>spec/conform</strong> lze získat jak správnou hodnotu (pokud
byla zvalidována), tak i informaci o tom, který predikát byl splněn:</p>

<pre>
user=&gt; <strong>(spec/conform ::unique-id 42)</strong>
[:id 42]
&nbsp;
user=&gt; <strong>(spec/conform ::unique-id "foo")</strong>
[:name "foo"]
&nbsp;
user=&gt; <strong>(spec/conform ::unique-id nil)</strong>
:clojure.spec.alpha/invalid
&nbsp;
user=&gt; <strong>(spec/conform ::unique-id [])</strong>
:clojure.spec.alpha/invalid
&nbsp;
user=&gt; <strong>(spec/explain ::unique-id 42)</strong>
Success!
nil
</pre>

<p>Taktéž můžeme s&nbsp;využitím <strong>spec/explain</strong> zjistit, které
predikáty byly či nebyly splněny:</p>

<pre>
user=&gt; <strong>(spec/explain ::unique-id [])</strong>
val: [] fails spec: :user/unique-id at: [:name] predicate: string?
val: [] fails spec: :user/unique-id at: [:id] predicate: pos-int?
nil
&nbsp;
user=&gt; <strong>(spec/explain ::unique-id nil)</strong>
val: nil fails spec: :user/unique-id at: [:name] predicate: string?
val: nil fails spec: :user/unique-id at: [:id] predicate: pos-int?
nil
</pre>

<p>Předchozí validační kritérium bylo zvláštní tím, že vždy platil maximálně
jeden predikát, nikdy ne oba dva (žádná hodnota není současně řetězec a
současně celé číslo). Ovšem můžeme samozřejmě použít i predikáty, které se
&bdquo;překrývají&ldquo;. Například lze napsat více kritérií pro všechna celá
čísla a zjistit, zda se skutečně vyhodnotí všechny, nebo se vyhodnocování
zastaví při nalezení prvního platného predikátu:</p>

<pre>
user=&gt; <strong>(spec/def ::integer (spec/or :negative neg-int? :zero zero? :positive pos-int?))</strong>
&nbsp;
user=&gt; <strong>(doseq [i (range -5 6)] (println (spec/conform ::integer i)))</strong>
[:negative -5]
[:negative -4]
[:negative -3]
[:negative -2]
[:negative -1]
[:zero 0]
[:positive 1]
[:positive 2]
[:positive 3]
[:positive 4]
[:positive 5]
nil
</pre>

<p><div class="rs-tip-major">Poznámka: předchozí validační kritérium je
schválně napsané špatně, protože nebude fungovat například ve chvíli, kdy
budeme validovat řetězec atd. Oprava spočívá v&nbsp;tom, že se celý test
&bdquo;obalí&ldquo; klauzulí <strong>and</strong>, v&nbsp;níž se bude testovat
predikátem <strong>int?</strong>.</div></p>

<p>Klauzule <strong>or</strong> je použita i v&nbsp;dnešním druhém
demonstračním příkladu, který naleznete na adrese <a
href="https://github.com/tisnik/clojure-examples/tree/master/spec-demo7">https://github.com/tisnik/clojure-examples/tree/master/spec-demo7</a>.</p>



<p><a name="k05"></a></p>
<h2 id="k05">5. Validace v&nbsp;případě, že hodnota může být <strong>nil</strong></h2>

<p>Poměrně často se setkáme se situací, kdy nějaká hodnota musí splňovat určité
kritérium (například být řetězcem) popř.&nbsp;může být prázdná, což je
v&nbsp;Clojure a vlastně i ve většině LISPovských jazyků představováno hodnotou
<a href="https://clojure.org/reference/data_structures#nil">nil</a>.
S&nbsp;využitím klauzule <strong>or</strong> samozřejmě takovou podmínku můžeme
napsat, a to například takto (komentář musí být řetězcem nebo nesmí být zadaný
vůbec):</p>

<pre>
user=&gt; <strong>(spec/def ::comment (spec/or :filled string? :empty nil?))</strong>
:user/comment
</pre>

<p>Pro jistotu se podívejme na vygenerovanou nápovědu:</p>

<pre>
user=&gt; <strong>(doc ::comment)</strong>
-------------------------
:user/comment
Spec
  (or :filled string? :empty nil?)
</pre>

<p>Nové validační kritérium je snadné otestovat pro hodnoty různých typů:</p>

<pre>
user=&gt; <strong>(spec/valid? ::comment "komentar")</strong>
true
&nbsp;
user=&gt; <strong>(spec/valid? ::comment nil)</strong>
true
&nbsp;
user=&gt; <strong>(spec/valid? ::comment [])</strong>
false
&nbsp;
user=&gt; <strong>(spec/valid? ::comment false)</strong>
false
&nbsp;
user=&gt; <strong>(spec/valid? ::comment (range 10))</strong>
false
&nbsp;
user=&gt; <strong>(spec/explain ::comment (range 10))</strong>
val: (0 1 2 3 4 5 6 7 8 9) fails spec: :user/comment at: [:filled] predicate: string?
val: (0 1 2 3 4 5 6 7 8 9) fails spec: :user/comment at: [:empty] predicate: nil?
nil
&nbsp;
user=&gt; <strong>(spec/explain ::comment '())</strong>
val: () fails spec: :user/comment at: [:filled] predicate: string?
val: () fails spec: :user/comment at: [:empty] predicate: nil?
nil
</pre>

<p>Úprava příkladu z&nbsp;konce předchozí kapitoly:</p>

<pre>
user=&gt; <strong>(spec/def ::possible-integer (spec/or :none nil? :negative neg-int? :zero zero? :positive pos-int?))</strong>
:user/possible-integer
&nbsp;
user=&gt; <strong>(spec/conform ::possible-integer nil)</strong>
[:none nil]
&nbsp;
user=&gt; <strong>(doseq [i (range -5 6)] (println (spec/conform ::possible-integer i)))</strong>
[:negative -5]
[:negative -4]
[:negative -3]
[:negative -2]
[:negative -1]
[:zero 0]
[:positive 1]
[:positive 2]
[:positive 3]
[:positive 4]
[:positive 5]
nil
</pre>

<p>Ve třetím demonstračním příklad, který naleznete na adrese <a
href="https://github.com/tisnik/clojure-examples/tree/master/spec-demo8">https://github.com/tisnik/clojure-examples/tree/master/spec-demo8</a>,
je ukázáno použití takto vytvořeného validačního kritéria.</p>



<p><a name="k06"></a></p>
<h2 id="k06">6. Vylepšení validace s&nbsp;využitím makra <strong>nilable</strong></h2>

<p>Validační kritéria popsaná <a href="#k05">v&nbsp;předchozí kapitole</a> jsou
sice funkční, ale existuje i idiomatičtější řešení založené na použití makra
<strong>nilable</strong>. Tomu se předá libovolný predikát, k&nbsp;němuž je
automaticky doplněno &bdquo;spec/or nil?&ldquo;:</p>

<pre>
user=&gt; <strong>(doc spec/nilable)</strong>
-------------------------
clojure.spec.alpha/nilable
([pred])
Macro
  returns a spec that accepts nil and values satisfying pred
nil
</pre>

<p>Zkusme si nyní předeklarovat validační kritérium pro komentáře
s&nbsp;využitím makra <strong>nilable</strong>. Je to velmi jednoduché:</p>

<pre>
user=&gt; <strong>(spec/def ::comment (spec/nilable string?))</strong>
:user/comment
&nbsp;
user=&gt; <strong>(doc ::comment)</strong>
-------------------------
:user/comment
Spec
  (nilable string?)
</pre>

<p>Interně se makro <strong>nilable</strong> expanduje následujícím
způsobem:</p>

<pre>
user=&gt; <strong>(macroexpand-1 '(spec/nilable string?))</strong>
(clojure.spec.alpha/nilable-impl (quote clojure.core/string?) string? nil)
</pre>

<p>Opět si novou variantu validačního kritéria pro komentáře můžeme otestovat:</p>

<pre>
user=&gt; <strong>(spec/valid? ::comment "komentar")</strong>
true
&nbsp;
user=&gt; <strong>(spec/valid? ::comment nil)</strong>
true
&nbsp;
user=&gt; <strong>(spec/valid? ::comment [])</strong>
false
&nbsp;
user=&gt; <strong>(spec/valid? ::comment false)</strong>
false
&nbsp;
user=&gt; <strong>(spec/explain ::comment (range 10))</strong>
val: (0 1 2 3 4 5 6 7 8 9) fails spec: :user/comment at: [:clojure.spec.alpha/pred] predicate: string?
val: (0 1 2 3 4 5 6 7 8 9) fails spec: :user/comment at: [:clojure.spec.alpha/nil] predicate: nil?
nil
&nbsp;
user=&gt; <strong>(spec/explain ::comment '())</strong>
val: () fails spec: :user/comment at: [:clojure.spec.alpha/pred] predicate: string?
val: () fails spec: :user/comment at: [:clojure.spec.alpha/nil] predicate: nil?
nil
</pre>

<p>Makro <strong>nilable</strong> je použito ve čtvrtém demonstračním příkladu,
který naleznete na adrese <a
href="https://github.com/tisnik/clojure-examples/tree/master/spec-demo9">https://github.com/tisnik/clojure-examples/tree/master/spec-demo9</a>.</p>



<p><a name="k07"></a></p>
<h2 id="k07">7. Varianty funkce <strong>explain</strong> &ndash; <strong>explain-str</strong> a <strong>explain-data</strong></h2>

<p>Při zjišťování, z&nbsp;jakého důvodu nebyla data zvalidována, jsme až
doposud používali pouze jedinou funkci nazvanou <strong>explain</strong>. Tato
funkce vytiskla výsledek validace na standardní výstup popř.&nbsp;do
libovolného výstupního streamu navázaného na symbol <strong>*out*</strong>:</p>

<pre>
user=&gt; <strong>(doc spec/explain)</strong>
-------------------------
clojure.spec.alpha/explain
([spec x])
  Given a spec and a value that fails to conform, prints an explanation to *out*.
nil
</pre>

<p>V&nbsp;některých případech, například při potřebě logování, je však
výhodnější použít funkci pojmenovanou <strong>explain-str</strong>. Ta provádí
stejnou činnost jako funkce <strong>explain</strong>, ovšem výsledek je vrácen
formou řetězce:</p>

<pre>
user=&gt; <strong>(doc spec/explain-str)</strong>
-------------------------
clojure.spec.alpha/explain-str
([spec x])
  Given a spec and a value that fails to conform, returns an explanation as a string.
nil
</pre>

<p>Nejzajímavější je však poslední funkce pojmenovaná
<strong>explain-data</strong>. Tato funkce totiž vrátí výsledek validace ve
formě datové struktury, kterou je možné relativně snadno zpravovat (určitě
jednodušeji, než parsováním textového výstupu):</p>

<pre>
user=&gt; <strong>(doc spec/explain-data)</strong>
-------------------------
clojure.spec.alpha/explain-data
([spec x])
  Given a spec and a value x which ought to conform, returns nil if x
  conforms, else a map with at least the key ::problems whose value is
  a collection of problem-maps, where problem-map has at least :path :pred and :val
  keys describing the predicate and the value that failed at that
  path.
nil
</pre>

<p>Můžeme si to vyzkoušet na již dříve ukázaných validačních kritériích:</p>

<pre>
user=&gt; <strong>(spec/explain-data ::comment '())</strong>
#:clojure.spec.alpha{:problems [{:path [:clojure.spec.alpha/pred], :pred clojure.core/string?, :val (), :via [:user/comment], :in []} {:path [:clojure.spec.alpha/nil], :pred nil?, :val (), :via [:user/comment], :in []}], :spec :user/comment, :value ()}
</pre>

<p>Poměrně nečitelný výstup lze vylepšit zavoláním &bdquo;pretty-print&ldquo;
funkce <strong>clojure.pprint/pprint</strong>. Pro zpřehlednění zápisu
použijeme threading makro -&gt; (:pred znamená predikát):</p>

<pre>
user=&gt; <strong>(-&gt; (spec/explain-data ::comment '()) clojure.pprint/pprint)</strong>
#:clojure.spec.alpha{:problems
                     [{:path [:clojure.spec.alpha/pred],
                       :pred clojure.core/string?,
                       :val (),
                       :via [:user/comment],
                       :in []}
                      {:path [:clojure.spec.alpha/nil],
                       :pred nil?,
                       :val (),
                       :via [:user/comment],
                       :in []}],
                     :spec :user/comment,
                     :value ()}
&nbsp;
user=&gt; <strong>(-&gt; (spec/explain-data ::unique-id nil) clojure.pprint/pprint)</strong>
#:clojure.spec.alpha{:problems
                     ({:path [:name],
                       :pred clojure.core/string?,
                       :val nil,
                       :via [:user/unique-id],
                       :in []}
                      {:path [:id],
                       :pred clojure.core/pos-int?,
                       :val nil,
                       :via [:user/unique-id],
                       :in []}),
                     :spec :user/unique-id,
                     :value nil}
</pre>

<p>Pro validní data se však vrátí pouze <strong>nil</strong> (což je vcelku
rozumné chování):</p>

<pre>
user=&gt; <strong>(-&gt; (spec/explain-data ::possible-integer 42) clojure.pprint/pprint)</strong>
nil
nil
&nbsp;
user=&gt; <strong>(-&gt; (spec/explain-data ::possible-integer nil) clojure.pprint/pprint)</strong>
nil
nil
</pre>



<p><a name="k08"></a></p>
<h2 id="k08">8. Malé zopakování z&nbsp;minula: základní validace obsahu kolekcí</h2>

<p>Připomeňme si, že v&nbsp;knihovně <i>spec</i> nalezneme i makro pojmenované
<strong>coll-of</strong>. Toto makro je možné použít ve chvíli, kdy potřebujeme
otestovat delší sekvenci, vektor či seznam. Můžeme přitom specifikovat predikát
aplikovaný na prvky sekvence, očekávaný počet prvků v&nbsp;sekvenci, minimální
a maximální očekávaný počet prvků, to, zda se prvky mohou opakovat atd. Dokonce
je možné specifikovat, zda se má sekvence po validaci převést na jiný typ
sekvence (vektor na seznam atd.). Nejjednodušší použití spočívá pouze ve
specifikaci predikátu, který musí platit pro všechny prvky sekvence či
kolekce:</p>

<pre>
user=&gt; <strong>(spec/def ::positive-integers (spec/coll-of pos-int?))</strong>
:user/pos-integers
</pre>

<p>Funkci lze otestovat snadno:</p>

<pre>
user=&gt; <strong>(spec/valid? ::positive-integers [1 2 3])</strong>
true
&nbsp;
user=&gt; <strong>(spec/valid? ::positive-integers (range 10))</strong>
false
&nbsp;
user=&gt; <strong>(spec/valid? ::positive-integers (range 1 10))</strong>
true
&nbsp;
user=&gt; <strong>(spec/valid? ::positive-integers (repeat 10 42))</strong>
true
&nbsp;
user=&gt; <strong>(spec/valid? ::positive-integers (repeat 10 "A"))</strong>
false
&nbsp;
user=&gt; <strong>(spec/explain ::positive-integers (range 1 10))</strong>
Success!
</pre>

<p>Podobně lze vytvořit i kontrolu pro všechny prvky slovníku. Zde musíme
testovat jak klíče, tak (samostatně) hodnoty uložené pod jednotlivými
klíči::</p>

<pre>
user=&gt; <strong>(spec/def ::dictionary (spec/map-of string? string?))</strong>
:user/dictionary
</pre>

<p>Opět se podívejme na výsledky použití tohoto validačního kritéria:</p>

<pre>
user=&gt; <strong>(spec/valid? ::dictionary nil)</strong>
false
&nbsp;
user=&gt; <strong>(spec/valid? ::dictionary [1 2])</strong>
false
&nbsp;
user=&gt; <strong>(spec/valid? ::dictionary {"one" "jedna" "two" "dve"})</strong>
true
&nbsp;
user=&gt; <strong>(spec/valid? ::dictionary {"one" 1 "two" 2})</strong>
false
</pre>



<p><a name="k09"></a></p>
<h2 id="k09">9. První varianta validátoru IPv4 adres</h2>

<p>Minule jsme se zmínili i o funkci <strong>spec/tuple</strong> určené pro
validaci n-tic, u nichž je známý počet a typ prvků (na rozdíl od potenciálně
nekonečných sekvencí!). Podívejme se nyní na nepatrně složitější příklad,
konkrétně na kontrolu, zda daná čtveřice obsahuje validní <a
href="https://en.wikipedia.org/wiki/IPv4#Address_representations">IPv4
adresu</a>. Pro jednoduchost prozatím předpokládejme, že jednotlivé oktety
mohou nabývat libovolné hodnoty od 0 do 255. Nejprve si tedy nadefinujeme
validační kritérium pro každý oktet:</p>

<pre>
user=&gt; <strong>(spec/def ::byte (spec/and nat-int? #(&lt;= % 255)))</strong>
:user/byte
</pre>

<p>Otestování je snadné:</p>

<pre>
user=&gt; <strong>(spec/valid? ::byte -1)</strong>
false
&nbsp;
user=&gt; <strong>(spec/valid? ::byte 0)</strong>
true
&nbsp;
user=&gt; <strong>(spec/valid? ::byte 255)</strong>
true
&nbsp;
user=&gt; <strong>(spec/valid? ::byte 256)</strong>
false
&nbsp;
user=&gt; <strong>(spec/valid? ::byte nil)</strong>
false
&nbsp;
user=&gt; <strong>(spec/valid? ::byte "adresa")</strong>
false
&nbsp;
user=&gt; <strong>(spec/valid? ::byte [:foo :bar])</strong>
false
</pre>

<p>Nyní již můžeme vytvořit validační kritérium pro celou IPv4 adresu:</p>

<pre>
user=&gt; <strong>(spec/def ::ip-address (spec/tuple ::byte ::byte ::byte ::byte))</strong>
:user/ip-address
</pre>

<p>Opět se nám vygenerovala nápověda:</p>

<pre>
user=&gt; <strong>(doc ::ip-address)</strong>
-------------------------
:user/ip-address
Spec
  (tuple :user/byte :user/byte :user/byte :user/byte)
</pre>

<p>Valiace adres:</p>

<pre>
user=&gt; <strong>(spec/valid? ::ip-address [127 0 0 1])</strong>
true
&nbsp;
user=&gt; <strong>(spec/valid? ::ip-address [256 0 0 1])</strong>
false
&nbsp;
user=&gt; <strong>(spec/valid? ::ip-address [127 0 0 0 1])</strong>
false
</pre>

<p>Zjištění, která část nebyla zvalidována (problém je vyznačen tučným
písmem):</p>

<pre>
user=&gt; <strong>(-&gt; (spec/explain-data ::ip-address [127 0 0 0 1]) clojure.pprint/pprint)</strong>
#:clojure.spec.alpha{:problems
                     [{:path [],
                       :pred <strong>(clojure.core/= (clojure.core/count %) 4)</strong>,
                       :val [127 0 0 0 1],
                       :via [:user/ip-address],
                       :in []}],
                     :spec :user/ip-address,
                     :value [127 0 0 0 1]}
nil
</pre>

<pre>
user=&gt; <strong>(-&gt; (spec/explain-data ::ip-address [127 0 256 0]) clojure.pprint/pprint)</strong>
#:clojure.spec.alpha{:problems
                     ({:path [2],
                       :pred
                       <strong>(clojure.core/fn [%] (clojure.core/&lt;= % 255))</strong>,
                       :val 256,
                       :via [:user/ip-address :user/byte],
                       :in [2]}),
                     :spec :user/ip-address,
                     :value [127 0 256 0]}
nil
</pre>



<p><a name="k10"></a></p>
<h2 id="k10">10. Validace sekvencí s&nbsp;využitím operátorů převzatých z&nbsp;regulárních výrazů</h2>

<p>Nyní se již dostáváme k&nbsp;zajímavější problematice. Ve chvíli, kdy
validujeme sekvence, se totiž může stát, že chceme aplikovat různá validační
kritéria na různé prvky sekvence, přičemž ovšem délka sekvence nemusí být
předem známá (potom by se vlastně jednalo o n-tice). Pro sekvence s&nbsp;předem
neznámým počtem prvků můžeme použít operátory, které jsou převzaté
z&nbsp;regulárních výrazů, u nichž také nemusíme specifikovat přesný počet
prvků (příkladem je [a-z]+, což je výraz, který jen říká, že očekáváme
libovolný počet písmen malé abecedy). V&nbsp;knihovně <i>spec</i> můžeme
postupovat stejně, a to díky použití těchto operátorů předávaných do
<strong>spec/def</strong>:</p>

<table>
<tr><th>Operátor</th><th>Význam</th></tr>
<tr><td>cat</td><td>spojení (zřetězení) predikátů</td></tr>
<tr><td>alt</td><td>výběr jedné alternativy z&nbsp;množiny predikátů</td></tr>
<tr><td>*</td><td>očekává se 0 nebo více výskytů hodnoty odpovídající predikátu</td></tr>
<tr><td>+</td><td>očekává se jeden nebo více výskytů hodnoty odpovídající predikátu</td></tr>
<tr><td>?</td><td>očekává se 0 nebo jeden výskyt hodnoty odpovídající predikátu</td></tr>
</table>

<p>Vidíme, že poslední tři operátory skutečně odpovídají stejně zapisovaným
operátorům v&nbsp;regulárních výrazech. Příklady si ukážeme v&nbsp;navazujících
kapitolách.</p>



<p><a name="k11"></a></p>
<h2 id="k11">11. Druhá varianta validátoru IPv4 adres</h2>

<p>Druhou variantu validátoru IPv4 adres vytvoříme s&nbsp;využitím operátoru
<strong>cat</strong>, který umožní zřetězení většího množství predikátů. Před
každým predikátem se navíc uvede jednoznačný identifikátor (typicky klíč),
jehož význam si vysvětlíme později. Víme, že IPv4 adresa se skládá ze čtyř
oktetů, takže zapíšeme &bdquo;regulární výraz&ldquo; takto:</p>

<pre>
user=&gt; <strong>(spec/def ::ip-address-2 (spec/cat :1st ::byte :2nd ::byte :3rd ::byte :4th ::byte))</strong>
:user/ip-address-2
</pre>

<p>Samozřejmě, jak již očekáváte, se vytvořila dokumentace k&nbsp;validačnímu
kritériu:</p>

<pre>
user=&gt; <strong>(doc ::ip-address-2)</strong>
-------------------------
:user/ip-address-2
Spec
  (cat :1st :user/byte :2nd :user/byte :3rd :user/byte :4th :user/byte)
nil
</pre>

<p>Mnohem zajímavější je však zjistit, jak bude probíhat validace:</p>

<pre>
user=&gt; <strong>(spec/valid? ::ip-address-2 [127 0 0 0 1])</strong>
false
&nbsp;
user=&gt; <strong>(spec/valid? ::ip-address-2 [127 0 0 1])</strong>
true
&nbsp;
user=&gt; <strong>(-> (spec/explain-data ::ip-address-2 [127 0 0 0 1]) clojure.pprint/pprint)</strong>
#:clojure.spec.alpha{:problems
                     [{:path [],
                       :reason "Extra input",
                       :pred
                       (clojure.spec.alpha/cat
                        :1st
                        :user/byte
                        :2nd
                        :user/byte
                        :3rd
                        :user/byte
                        :4th
                        :user/byte),
                       :val (1),
                       :via [:user/ip-address-2],
                       :in [4]}],
                     :spec :user/ip-address-2,
                     :value [127 0 0 0 1]}
</pre>

<p>Trošku předběhneme, ale ukažme si výsledek volání
<strong>spec/conform</strong>. Pokud jsou vstupní data korektní, provede se
automatický destructuring, a to právě s&nbsp;využitím klíčů. To je velmi
zajímavá vlastnost, kterou oceníme především u složitěji strukturovaných
dat:</p>

<pre>
user=&gt; <strong>(spec/conform ::ip-address-2 [127 0 0 1])</strong>
{:1st 127, :2nd 0, :3rd 0, :4th 1}
</pre>



<p><a name="k12"></a></p>
<h2 id="k12">12. Příklad validace sekvence s&nbsp;využitím operátoru <strong>+</strong></h2>

<p>S&nbsp;využitím operátoru <strong>+</strong> můžeme definovat, že se očekává
alespoň jeden prvek splňující další predikát. V&nbsp;nejjednodušším případě
použití tohoto operátoru vypadá následovně &ndash; budeme testovat, zda
sekvence obsahuje alespoň jedno sudé číslo nebo více sudých čísel:</p>

<pre>
user=&gt; <strong>(spec/def ::even-numbers (spec/+ even?))</strong>
:user/even-numbers
</pre>

<p>Opět si otestujeme chování:</p>

<pre>
user=&gt; <strong>(spec/valid? ::even-numbers [2])</strong>
true
&nbsp;
user=&gt; <strong>(spec/valid? ::even-numbers [])</strong>
false
&nbsp;
user=&gt; <strong>(spec/valid? ::even-numbers [1 2 3])</strong>
false
&nbsp;
user=&gt; <strong>(spec/valid? ::even-numbers [2 4 6])</strong>
true
&nbsp;
user=&gt; <strong>(spec/explain ::even-numbers [1 2 3])</strong>
In: [0] val: 1 fails spec: :user/even-numbers predicate: even?
nil
&nbsp;
user=&gt; <strong>(spec/valid? ::even-numbers (map #(* % 2) (range 10)))</strong>
true
</pre>

<p>Malý počet prvků v&nbsp;sekvenci:</p>

<pre>
user=&gt; <strong>(spec/explain ::even-numbers [])</strong>
val: () fails spec: :user/even-numbers predicate: even?,  Insufficient input
nil
</pre>



<p><a name="k13"></a></p>
<h2 id="k13">13. Validace složitější datové struktury</h2>

<p>Vhodnou kombinací operátorů <strong>cat</strong>, <strong>+</strong> atd.
lze zajistit i validaci složitěji strukturovaných sekvencí. Například
v&nbsp;následujícím příkladu očekáváme, že prvním prvkem sekvence bude UID
(řetězec) a další prvky budou striktně kladná čísla. Zápis přesně odpovídá
předchozímu slovnímu popisu podmínky:</p>

<pre>
user=&gt; <strong>(spec/def ::uid string?)</strong>
:user/uid
user=&gt; <strong>(spec/def ::sequence-with-uid (spec/cat :uid ::uid :seq (spec/+ pos-int?)))</strong>
:user/sequence-with-uid
</pre>

<p>Otestování:</p>

<pre>
user=&gt; <strong>(spec/valid? ::sequence-with-uid ["x" 1 2 3])</strong>
true
&nbsp;
user=&gt; <strong>(spec/valid? ::sequence-with-uid [0 1 2 3])</strong>
false
&nbsp;
user=&gt; <strong>(spec/valid? ::sequence-with-uid [0 1 2 3 "x"])</strong>
false
&nbsp;
</pre>

<p>I v&nbsp;tomto případě bude probíhat velmi užitečný destructuring:</p>

<pre>
user=&gt; <strong>(spec/conform ::sequence-with-uid ["x" 1 2 3])</strong>
{:uid "x", :seq [1 2 3]}
</pre>

<p>Zjištění důvodu, proč se validace nepovedla (predikát, který nebyl splněn,
je označen tučným písmem):</p>

<pre>
user=&gt; <strong>(-&gt; (spec/explain-data ::sequence-with-uid [0 1 2 3 "x"]) clojure.pprint/pprint)</strong>
#:clojure.spec.alpha{:problems
                     [{:path [:uid],
                       :pred <strong>clojure.core/string?</strong>,
                       :val 0,
                       :via
                       [:user/sequence-with-uid
                        :user/sequence-with-uid
                        :user/uid
                        :user/uid],
                       :in [0]}],
                     :spec :user/sequence-with-uid,
                     :value [0 1 2 3 "x"]}
nil
</pre>

<p>Samozřejmě nám nic nebrání převést UID na konec celé sekvence, opět ve stylu
regulárních výrazů:</p>

<pre>
user=&gt; <strong>(spec/def ::sequence-with-uid-at-end (spec/cat :seq (spec/+ pos-int?) :uid ::uid))</strong>
:user/sequence-with-uid-at-end
&nbsp;
user=&gt; <strong>(spec/valid? ::sequence-with-uid-at-end [1 2 3 "x"])</strong>
true
&nbsp;
user=&gt; <strong>(spec/conform ::sequence-with-uid-at-end [1 2 3 "x"])</strong>
{:seq [1 2 3], :uid "x"}
</pre>



<p><a name="k14"></a></p>
<h2 id="k14">14. Kombinace operátorů <strong>+</strong> a <strong>?</strong></h2>

<p>Následující příklad je převzat z&nbsp;oficiální dokumentace ke knihovně
<i>spec</i>. Deklarujeme v&nbsp;něm validační kritérium, kdy sekvence má na
začátku obsahovat libovolné množství lichých čísel, za nimiž může (ale také
nemusí) následovat jedno číslo sudé. Zápis opět připomíná regulární výraz
(liché+sudé?):</p>

<pre>
user=&gt; <strong>(spec/def ::odds-then-maybe-even (spec/cat :odds (spec/+ odd?) :even (spec/? even?)))</strong>
:user/odds-then-maybe-even
</pre>

<p>V&nbsp;tomto příkladu je nejzajímavější destructuring, který vypadá takto:</p>

<pre>
user=&gt; <strong>(spec/conform ::odds-then-maybe-even [1 3 5 100])</strong>
{:odds [1 3 5], :even 100}
&nbsp;
user=&gt; <strong>(spec/conform ::odds-then-maybe-even [1])</strong>
{:odds [1]}
&nbsp;
user=&gt; <strong>(spec/conform ::odds-then-maybe-even [1 2])</strong>
{:odds [1], :even 2}
&nbsp;
user=&gt; <strong>(spec/conform ::odds-then-maybe-even [1 2 3])</strong>
:clojure.spec.alpha/invalid
&nbsp;
user=&gt; <strong>(spec/conform ::odds-then-maybe-even [1 3 5 7 2])</strong>
{:odds [1 3 5 7], :even 2}
&nbsp;
user=&gt; <strong>(spec/conform ::odds-then-maybe-even [1 3 5 7])</strong>
{:odds [1 3 5 7]}
</pre>

<p>Povšimněte si, že pokud není na konci nalezeno sudé číslo, v&nbsp;mapě se
vůbec nevrátí klíč <strong>:even</strong>.</p>



<p><a name="k15"></a></p>
<h2 id="k15">15. Validace vektoru s&nbsp;konfiguračními volbami</h2>

<p>V&nbsp;dalším příkladu si ukážeme, jak je možné validovat datovou strukturu
obsahující konfigurační volby. Od této struktury požadujeme, aby obsahovala
vždy klíč, což je řetězec (lze doplnit požadavek na jeho unikátnost), a
povinnou hodnotu libovolného typu, ovšem odlišnou od <strong>nil</strong>.
Druhou podmínku nám zajistí predikát <strong>some?</strong>. Počet dvojic
klíč+hodnota není předem známý:</p>

<pre>
user=&gt; <strong>(spec/def ::configuration (spec/+ (spec/cat :name string? :value some?)))</strong>
:user/configuration
</pre>

<p>Ukázka otestování:</p>

<pre>
user=&gt; <strong>(spec/valid? ::configuration ["debug" true "url" "localhost" "port" 8080])</strong>
true
&nbsp;
user=&gt; <strong>(spec/valid? ::configuration ["debug" true "url" "localhost" "port"])</strong>
false
&nbsp;
user=&gt; <strong>(spec/explain ::configuration ["debug" true "url" "localhost" "port"])</strong>
val: () fails spec: :user/configuration at: [:value] predicate: some?,  Insufficient input
nil
</pre>

<p>Prázdný vektor bez konfigurace není validní:</p>

<pre>
user=&gt; <strong>(spec/valid? ::configuration [])</strong>
false
&nbsp;
user=&gt; <strong>(spec/explain ::configuration [])</strong>
val: () fails spec: :user/configuration at: [:name] predicate: string?,  Insufficient input
nil
</pre>

<p>Pokud přesto budeme chtít povolit použití prázdných vektorů, je to velmi
snadné &ndash; změnou operátoru <strong>+</strong> za operátor
<strong>*</strong>:</p>

<pre>
user=&gt; <strong>(spec/def ::configuration (spec/* (spec/cat :name string? :value some?)))</strong>
:user/configuration
</pre>

<p>Otestování:</p>

<pre>
user=&gt; <strong>(spec/valid? ::configuration nil)</strong>
true
&nbsp;
user=&gt; <strong>(spec/valid? ::configuration [])</strong>
true
&nbsp;
user=&gt; <strong>(spec/valid? ::configuration ["debug" true "url" "localhost" "port"])</strong>
false
&nbsp;
user=&gt; <strong>(spec/valid? ::configuration ["debug" true "url" "localhost" "port" 8080])</strong>
true
</pre>



<p><a name="k16"></a></p>
<h2 id="k16">16. Automatický destructuring po validaci datové struktury</h2>

<p>Již několikrát jsme si ukázali možnosti &bdquo;destructuringu&ldquo; dat,
takže si tuto vlastnost vyzkoušejme na nepatrně složitějším příkladu. Opět se
bude jednat o konfigurační volby, resp.&nbsp;přesněji řečeno o vektor
obsahující dvojice klíč+hodnota. Tentokrát ovšem budeme požadovat jak rozdělení
na zmíněné dvojice klíč+hodnota, tak i vrácení hodnot v&nbsp;mapě podle toho, o
jaký datový typ se jedná. Zde využijeme poslední prozatím nepopsaný operátor
<strong>alt</strong> pro výběr jedné z&nbsp;možností:</p>

<pre>
user=&gt; <strong>(spec/def ::configuration (spec/* (spec/cat :name string? :value (spec/alt :str string? :bool boolean? :integer int?))))</strong>
:user/configuration
</pre>

<p>Nejprve se podívejme, zda se data skutečně validují:</p>

<pre>
user=&gt; <strong>(spec/valid? ::configuration ["debug" true "url" "localhost" "port" 8080])</strong>
true
&nbsp;
user=&gt; <strong>(spec/valid? ::configuration ["debug" true "url" "localhost" "port" 8080.1])</strong>
false
</pre>

<p>Zobrazení důvodu, proč data nebyla zvalidována (zde konkrétně kvůli použití
reálného čísla):</p>

<pre>
user=&gt; <strong>(spec/explain ::configuration ["debug" true "url" "localhost" "port" 8080.1])</strong>
In: [5] val: 8080.1 fails spec: :user/configuration at: [:value :str] predicate: string?
In: [5] val: 8080.1 fails spec: :user/configuration at: [:value :bool] predicate: boolean?
In: [5] val: 8080.1 fails spec: :user/configuration at: [:value :integer] predicate: int?
nil
</pre>

<p>Ovšem nejzajímavější je vlastní destructuring:</p>

<pre>
user=&gt; <strong>(spec/conform ::configuration ["debug" true "url" "localhost" "port" 8080])</strong>
[{:name "debug", :value [:bool true]} {:name "url", :value [:str "localhost"]} {:name "port", :value [:integer 8080]}]
</pre>

<p>Čitelnější bude použití pretty-printingu, takže opět využijeme threading
makro:</p>

<pre>
user=&gt; <strong>(-> (spec/conform ::configuration ["debug" true "url" "localhost" "port" 8080]) clojure.pprint/pprint)</strong>
[{:name "debug", :value [:bool true]}
 {:name "url", :value [:str "localhost"]}
 {:name "port", :value [:integer 8080]}]
nil
</pre>

<p>Vidíme, že se destructuring skutečně provedl, a to rekurzivně:</p>

<ol>
<li>Původní vektor se rozdělil na dvojice klíč+hodnota</li>
<li>Hodnota se vrací ve formě vektoru, v&nbsp;němž se nachází opět klíč (typ) a hodnota daného typu</li>
</ol>

<p>Podobně je možné provést automatický destructuring jakkoli složité datové
struktury, samozřejmě za předpokladu, že došlo k&nbsp;její validaci.</p>



<p><a name="k17"></a></p>
<h2 id="k17">17. Generování testovacích dat na základě validačních kritérií</h2>

<p>Jednou z&nbsp;nejzajímavějších a potenciálně i nejužitečnějších vlastností
knihovny <i>spec</i> je její schopnost kooperace s&nbsp;knihovnou <a
href="https://clojure.github.io/test.check/intro.html">test.check</a> při
generování testovacích dat. Nejprve si však musíme upravit projektový soubor
<strong>project.clj</strong> tak, aby obsahoval zvýrazněný řádek (pozor &ndash;
z&nbsp;předchozího řádku odstraňte poslední dvě uzavírací závorky):</p>

<pre>
(defproject spec-demo12 "0.1.0-SNAPSHOT"
    :description "FIXME: write description"
    :url "http://example.com/FIXME"
    :license {:name "Eclipse Public License"
              :url "http://www.eclipse.org/legal/epl-v10.html"}
    :dependencies [[org.clojure/clojure "1.9.0"]]
    :main ^:skip-aot spec-demo12.core
    :target-path "target/%s"
    :profiles {:uberjar {:aot :all}
               <strong>:dev {:dependencies [[org.clojure/test.check "0.9.0"]]}</strong>})
</pre>

<p>Dále je nutné načíst knihovnu <strong>clojure.spec.gen.alpha</strong>.
Přistupovat k&nbsp;ní budeme přes zkrácený jmenný prostor
<strong>gen</strong>:</p>

<pre>
user=&gt; <strong>(require '[clojure.spec.gen.alpha :as gen])</strong>
nil
</pre>

<p>Nejzajímavější je funkce <strong>gen/generate</strong>, které se předá
validační kritérium a výsledkem je <i>náhodná hodnota</i>, jenž ovšem tomuto
kritériu odpovídá. Otestujme si to například na vygenerování náhodných celých
čísel:</p>

<pre>
user=&gt; <strong>(gen/generate (spec/gen int?))</strong>
506842
user=&gt; <strong>(gen/generate (spec/gen int?))</strong>
75
user=&gt; <strong>(gen/generate (spec/gen int?))</strong>
-1
user=&gt; <strong>(gen/generate (spec/gen int?))</strong>
-347611
</pre>

<p>Podobně můžeme vygenerovat náhodné komentáře, a to včetně
<strong>nil</strong> (protože jsou nilable):</p>

<pre>
user=&gt; <strong>(spec/def ::comment (spec/nilable string?))</strong>
:user/comment
&nbsp;
user=&gt; <strong>(gen/generate (spec/gen ::comment))</strong>
"2MT4fYI7qDn4p"
&nbsp;
user=&gt; <strong>(gen/generate (spec/gen ::comment))</strong>
nil
&nbsp;
user=&gt; <strong>(gen/generate (spec/gen ::comment))</strong>
"Pb"
</pre>

<p>Podobně lze postupovat i u složitějších struktur, například u našich IPv4 adres:</p>

<pre>
user=&gt; <strong>(spec/def ::ip-address-2 (spec/cat :1st ::byte :2nd ::byte :3rd ::byte :4th ::byte))</strong>
:user/ip-address-2
&nbsp;
user=&gt; <strong>(gen/generate (spec/gen ::ip-address-2))</strong>
(118 4 30 127)
&nbsp;
user=&gt; <strong>(gen/generate (spec/gen ::ip-address-2))</strong>
(5 123 1 0)
&nbsp;
user=&gt; <strong>(gen/generate (spec/gen ::ip-address-2))</strong>
(193 1 1 13)
&nbsp;
user=&gt; <strong>(gen/generate (spec/gen ::ip-address-2))</strong>
(96 1 5 34)
&nbsp;
user=&gt; <strong>(gen/generate (spec/gen ::ip-address-2))</strong>
(71 102 48 0)
</pre>

<p>Vše nejlépe osvětlí poslední demonstrační příklad:</p>

<pre>
(ns spec-demo12.core)
&nbsp;
(require '[clojure.pprint :as pprint])
(require '[clojure.spec.alpha :as spec])
(require '[clojure.spec.gen.alpha :as gen])
&nbsp;
(spec/def ::user-id      (spec/and pos-int? #(&gt;= % 1000) #(&lt; % Integer/MAX_VALUE)))
(spec/def ::unique-id    (spec/or :name string? :id pos-int?))
&nbsp;
(spec/def ::comment-ver1 (spec/or :filled string? :empty nil?))
(spec/def ::comment-ver2 (spec/nilable string?))
&nbsp;
(spec/def ::byte         (spec/and nat-int? #(&lt;= % 255)))
(spec/def ::ip-address   (spec/tuple ::byte ::byte ::byte ::byte))
&nbsp;
&nbsp;
(defn generate-test-data
    [validation-key]
    (println "validation-key" validation-key)
    (doseq [i (range 10)]
        (println (str "#" i ": ") (gen/generate (spec/gen validation-key))))
    (println "\n\n\n"))
&nbsp;
&nbsp;
(defn -main
    [&amp; args]
    (let [validation-keys [::user-id ::unique-id ::comment-ver1 ::comment-ver2 ::ip-address]]
        (doseq [validation-key validation-keys]
            (generate-test-data validation-key))))
</pre>

<p>Tento příklad v&nbsp;mém případě vygeneroval následující testovací data:</p>

<pre>
validation-key :spec-demo12.core/user-id
#0:  59033803
#1:  13394
#2:  104186169
#3:  16706747
#4:  440193707
#5:  116487
#6:  905027
#7:  464669
#8:  40352
#9:  1460
&nbsp;
&nbsp;
&nbsp;
&nbsp;
validation-key :spec-demo12.core/unique-id
#0:  kSo4dm0Fjn1kvl0n0lVL2
#1:  B2q3ThZ442L3sj4U4c
#2:  oB11ShtmWj
#3:  qiUkMcyg027V7BQ5KR9455h
#4:  
#5:  411640
#6:  98602
#7:  k
#8:  8OJpvma
#9:  oqG09AJKJGyxEHwgyhA9kjeGAql
&nbsp;
&nbsp;
&nbsp;
&nbsp;
validation-key :spec-demo12.core/comment-ver1
#0:  oLeX40PKWrG
#1:  52ts09TxOik8fO2Y7vAYUT
#2:  Rfoac85p
#3:  nil
#4:  nil
#5:  nil
#6:  1bVu1XG
#7:  W1y8g7MuV1w
#8:  nil
#9:  ZNCz3hu1G70H3BE5owGae97cpk
&nbsp;
&nbsp;
&nbsp;
&nbsp;
validation-key :spec-demo12.core/comment-ver2
#0:  8sMXcl39lWDg642dtF7dV37sIb800
#1:  T951gGeS3pD5KT1
#2:  jp0K54INQ5Pb7kf948xE6XixsqNwH8
#3:  VhcT24P090mxF06Rq
#4:  tX14hRwPZw2T6RjjlOb19F01
#5:  nil
#6:  9RoXd2H25o09u
#7:  KvqXN4NY9Mp9KF6
#8:  8AAmSjz9SjvcQI3r6HfDneoFbVNg
#9:  dMpIW9By4c2vjR8mfK0
&nbsp;
&nbsp;
&nbsp;
&nbsp;
validation-key :spec-demo12.core/ip-address
#0:  [73 210 0 2]
#1:  [46 1 1 1]
#2:  [37 1 127 20]
#3:  [3 20 6 21]
#4:  [181 0 1 1]
#5:  [1 1 91 10]
#6:  [12 83 28 179]
#7:  [184 126 2 28]
#8:  [12 171 26 14]
#9:  [101 26 3 28]
</pre>



<p><a name="k18"></a></p>
<h2 id="k18">18. Repositář s&nbsp;demonstračními příklady</h2>

<p>Všechny demonstrační příklady a projekty určené pro Clojure verze 1.9.0 byly
uloženy do repositáře <a
href="https://github.com/tisnik/clojure-examples">https://github.com/tisnik/clojure-examples</a>:</p>

<table>
<tr><th>Projekt</th><th>Popis</th><th>Odkaz</th></tr>
<tr><td>spec-demo6</td><td>ukázka použití klauzule <strong>and</strong></td><td><a href="https://github.com/tisnik/clojure-examples/tree/master/spec-demo6">https://github.com/tisnik/clojure-examples/tree/master/spec-demo6</a></td></tr>
<tr><td>spec-demo7</td><td>ukázka použití klauzule <strong>or</strong></td><td><a href="https://github.com/tisnik/clojure-examples/tree/master/spec-demo7">https://github.com/tisnik/clojure-examples/tree/master/spec-demo7</a></td></tr>
<tr><td>spec-demo8</td><td>nilable řetězec, první varianta</td><td><a href="https://github.com/tisnik/clojure-examples/tree/master/spec-demo8">https://github.com/tisnik/clojure-examples/tree/master/spec-demo8</a></td></tr>
<tr><td>spec-demo9</td><td>nilable řetězec, druhá varianta</td><td><a href="https://github.com/tisnik/clojure-examples/tree/master/spec-demo9">https://github.com/tisnik/clojure-examples/tree/master/spec-demo9</a></td></tr>
<tr><td>spec-demo10</td><td>funkce <strong>explain-data</strong></td><td><a href="https://github.com/tisnik/clojure-examples/tree/master/spec-demo10">https://github.com/tisnik/clojure-examples/tree/master/spec-demo10</a></td></tr>
<tr><td>spec-demo11</td><td>validace IP adres, dvě varianty</td><td><a href="https://github.com/tisnik/clojure-examples/tree/master/spec-demo11">https://github.com/tisnik/clojure-examples/tree/master/spec-demo11</a></td></tr>
<tr><td>spec-demo12</td><td>generování testovacích dat</td><td><a href="https://github.com/tisnik/clojure-examples/tree/master/spec-demo12">https://github.com/tisnik/clojure-examples/tree/master/spec-demo12</a></td></tr>
</table>

<p>Pro spuštění projektů je vyžadován nainstalovaný správce projektů
<i>Leiningen</i> a samozřejmě i Clojure verze 1.9.0. Pokud tato verze Clojure
není nainstalována, provede se instalace po prvním příkazu <strong>lein
deps</strong> nebo <strong>lein run</strong>.</p>



<p><a name="k19"></a></p>
<h2 id="k19">19. Odkazy na předchozí části tohoto seriálu</h2>

<ol>

<li>Clojure  1: Úvod<br />
<a href="http://www.root.cz/clanky/clojure-aneb-jazyk-umoznujici-tvorbu-bezpecnych-vicevlaknovych-aplikaci-pro-jvm/">http://www.root.cz/clanky/clojure-aneb-jazyk-umoznujici-tvorbu-bezpecnych-vicevlaknovych-aplikaci-pro-jvm/</a>
</li>

<li>Clojure  2: Symboly, kolekce atd.<br />
<a href="http://www.root.cz/clanky/clojure-aneb-jazyk-umoznujici-tvorbu-bezpecnych-vicevlaknovych-aplikaci-pro-jvm-2-cast/">http://www.root.cz/clanky/clojure-aneb-jazyk-umoznujici-tvorbu-bezpecnych-vicevlaknovych-aplikaci-pro-jvm-2-cast/</a>
</li>

<li>Clojure  3: Funkcionální programování<br />
<a href="http://www.root.cz/clanky/clojure-aneb-jazyk-umoznujici-tvorbu-bezpecnych-vicevlaknovych-aplikaci-pro-jvm-3-cast-funkcionalni-programovani/">http://www.root.cz/clanky/clojure-aneb-jazyk-umoznujici-tvorbu-bezpecnych-vicevlaknovych-aplikaci-pro-jvm-3-cast-funkcionalni-programovani/</a>
</li>

<li>Clojure  4: Kolekce, sekvence a lazy sekvence<br />
<a href="http://www.root.cz/clanky/clojure-aneb-jazyk-umoznujici-tvorbu-bezpecnych-vicevlaknovych-aplikaci-pro-jvm-4-cast-kolekce-sekvence-a-lazy-sekvence/">http://www.root.cz/clanky/clojure-aneb-jazyk-umoznujici-tvorbu-bezpecnych-vicevlaknovych-aplikaci-pro-jvm-4-cast-kolekce-sekvence-a-lazy-sekvence/</a>
</li>

<li>Clojure  5: Sekvence, lazy sekvence a paralelní programy<br />
<a href="http://www.root.cz/clanky/clojure-a-bezpecne-aplikace-pro-jvm-sekvence-lazy-sekvence-a-paralelni-programy/">http://www.root.cz/clanky/clojure-a-bezpecne-aplikace-pro-jvm-sekvence-lazy-sekvence-a-paralelni-programy/</a>
</li>

<li>Clojure  6: Podpora pro paralelní programování<br />
<a href="http://www.root.cz/clanky/programovaci-jazyk-clojure-6-futures-nejsou-jen-financni-derivaty/">http://www.root.cz/clanky/programovaci-jazyk-clojure-6-futures-nejsou-jen-financni-derivaty/</a>
</li>

<li>Clojure  7: Další funkce pro paralelní programování<br />
<a href="http://www.root.cz/clanky/programovaci-jazyk-clojure-7-dalsi-podpurne-prostredky-pro-paralelni-programovani/">http://www.root.cz/clanky/programovaci-jazyk-clojure-7-dalsi-podpurne-prostredky-pro-paralelni-programovani/</a>
</li>

<li>Clojure  8: Identity, stavy, neměnné hodnoty a reference<br />
<a href="http://www.root.cz/clanky/programovaci-jazyk-clojure-8-identity-stavy-nemenne-hodnoty-a-referencni-typy/">http://www.root.cz/clanky/programovaci-jazyk-clojure-8-identity-stavy-nemenne-hodnoty-a-referencni-typy/</a>
</li>

<li>Clojure  9: Validátory, pozorovatelé a kooperace s Javou<br />
<a href="http://www.root.cz/clanky/programovaci-jazyk-clojure-9-validatory-pozorovatele-a-kooperace-mezi-clojure-a-javou/">http://www.root.cz/clanky/programovaci-jazyk-clojure-9-validatory-pozorovatele-a-kooperace-mezi-clojure-a-javou/</a>
</li>

<li>Clojure 10: Kooperace mezi Clojure a Javou<br />
<a href="http://www.root.cz/clanky/programovaci-jazyk-clojure-10-kooperace-mezi-clojure-a-javou-pokracovani/">http://www.root.cz/clanky/programovaci-jazyk-clojure-10-kooperace-mezi-clojure-a-javou-pokracovani/</a>
</li>

<li>Clojure 11: Generátorová notace seznamu/list comprehension<br />
<a href="http://www.root.cz/clanky/programovaci-jazyk-clojure-11-generatorova-notace-seznamu-list-comprehension/">http://www.root.cz/clanky/programovaci-jazyk-clojure-11-generatorova-notace-seznamu-list-comprehension/</a>
</li>

<li>Clojure 12: Překlad programů z Clojure do bajtkódu JVM I:<br />
<a href="http://www.root.cz/clanky/programovaci-jazyk-clojure-12-preklad-programu-z-clojure-do-bajtkodu-jvm/">http://www.root.cz/clanky/programovaci-jazyk-clojure-12-preklad-programu-z-clojure-do-bajtkodu-jvm/</a>
</li>

<li>Clojure 13: Překlad programů z Clojure do bajtkódu JVM II:<br />
<a href="http://www.root.cz/clanky/programovaci-jazyk-clojure-13-preklad-programu-z-clojure-do-bajtkodu-jvm-pokracovani/">http://www.root.cz/clanky/programovaci-jazyk-clojure-13-preklad-programu-z-clojure-do-bajtkodu-jvm-pokracovani/</a>
</li>

<li>Clojure 14: Základy práce se systémem maker<br />
<a href="http://www.root.cz/clanky/programovaci-jazyk-clojure-14-zaklady-prace-se-systemem-maker/">http://www.root.cz/clanky/programovaci-jazyk-clojure-14-zaklady-prace-se-systemem-maker/</a>
</li>

<li>Clojure 15: Tvorba uživatelských maker<br />
<a href="http://www.root.cz/clanky/programovaci-jazyk-clojure-15-tvorba-uzivatelskych-maker/">http://www.root.cz/clanky/programovaci-jazyk-clojure-15-tvorba-uzivatelskych-maker/</a>
</li>

<li>Clojure 16: Složitější uživatelská makra<br />
<a href="http://www.root.cz/clanky/programovaci-jazyk-clojure-16-slozitejsi-uzivatelska-makra/">http://www.root.cz/clanky/programovaci-jazyk-clojure-16-slozitejsi-uzivatelska-makra/</a>
</li>

<li>Clojure 17: Využití standardních maker v praxi<br />
<a href="http://www.root.cz/clanky/programovaci-jazyk-clojure-17-vyuziti-standardnich-maker-v-praxi/">http://www.root.cz/clanky/programovaci-jazyk-clojure-17-vyuziti-standardnich-maker-v-praxi/</a>
</li>

<li>Clojure 18: Základní techniky optimalizace aplikací<br />
<a href="http://www.root.cz/clanky/programovaci-jazyk-clojure-18-zakladni-techniky-optimalizace-aplikaci/">http://www.root.cz/clanky/programovaci-jazyk-clojure-18-zakladni-techniky-optimalizace-aplikaci/</a>
</li>

<li>Clojure 19: Vývojová prostředí pro Clojure<br />
<a href="http://www.root.cz/clanky/programovaci-jazyk-clojure-19-vyvojova-prostredi-pro-clojure/">http://www.root.cz/clanky/programovaci-jazyk-clojure-19-vyvojova-prostredi-pro-clojure/</a>
</li>

<li>Clojure 20: Vývojová prostředí pro Clojure (Vimu s REPL)<br />
<a href="http://www.root.cz/clanky/programovaci-jazyk-clojure-20-vyvojova-prostredi-pro-clojure-integrace-vimu-s-repl/">http://www.root.cz/clanky/programovaci-jazyk-clojure-20-vyvojova-prostredi-pro-clojure-integrace-vimu-s-repl/</a>
</li>

<li>Clojure 21: ClojureScript aneb překlad Clojure do JS<br />
<a href="http://www.root.cz/clanky/programovaci-jazyk-clojure-21-clojurescript-aneb-preklad-clojure-do-javascriptu/">http://www.root.cz/clanky/programovaci-jazyk-clojure-21-clojurescript-aneb-preklad-clojure-do-javascriptu/</a>
</li>

<li>Leiningen: nástroj pro správu projektů napsaných v Clojure<br />
<a href="http://www.root.cz/clanky/leiningen-nastroj-pro-spravu-projektu-napsanych-v-clojure/">http://www.root.cz/clanky/leiningen-nastroj-pro-spravu-projektu-napsanych-v-clojure/</a>
</li>

<li>Leiningen: nástroj pro správu projektů napsaných v Clojure (2)<br />
<a href="http://www.root.cz/clanky/leiningen-nastroj-pro-spravu-projektu-napsanych-v-clojure-2/">http://www.root.cz/clanky/leiningen-nastroj-pro-spravu-projektu-napsanych-v-clojure-2/</a>
</li>

<li>Leiningen: nástroj pro správu projektů napsaných v Clojure (3)<br />
<a href="http://www.root.cz/clanky/leiningen-nastroj-pro-spravu-projektu-napsanych-v-clojure-3/">http://www.root.cz/clanky/leiningen-nastroj-pro-spravu-projektu-napsanych-v-clojure-3/</a>
</li>

<li>Leiningen: nástroj pro správu projektů napsaných v Clojure (4)<br />
<a href="http://www.root.cz/clanky/leiningen-nastroj-pro-spravu-projektu-napsanych-v-clojure-4/">http://www.root.cz/clanky/leiningen-nastroj-pro-spravu-projektu-napsanych-v-clojure-4/</a>
</li>

<li>Leiningen: nástroj pro správu projektů napsaných v Clojure (5)<br />
<a href="http://www.root.cz/clanky/leiningen-nastroj-pro-spravu-projektu-napsanych-v-clojure-5/">http://www.root.cz/clanky/leiningen-nastroj-pro-spravu-projektu-napsanych-v-clojure-5/</a>
</li>

<li>Leiningen: nástroj pro správu projektů napsaných v Clojure (6)<br />
<a href="http://www.root.cz/clanky/leiningen-nastroj-pro-spravu-projektu-napsanych-v-clojure-6/">http://www.root.cz/clanky/leiningen-nastroj-pro-spravu-projektu-napsanych-v-clojure-6/</a>
</li>

<li>Programovací jazyk Clojure a databáze (1.část)<br />
<a href="http://www.root.cz/clanky/programovaci-jazyk-clojure-a-databaze-1-cast/">http://www.root.cz/clanky/programovaci-jazyk-clojure-a-databaze-1-cast/</a>
</li>

<li>Pluginy pro Leiningen<br />
<a href="http://www.root.cz/clanky/leiningen-nastroj-pro-spravu-projektu-napsanych-v-clojure-pluginy-pro-leiningen/">http://www.root.cz/clanky/leiningen-nastroj-pro-spravu-projektu-napsanych-v-clojure-pluginy-pro-leiningen/</a>
</li>

<li>Programovací jazyk Clojure a knihovny pro práci s vektory a maticemi<br />
<a href="http://www.root.cz/clanky/programovaci-jazyk-clojure-a-knihovny-pro-praci-s-vektory-a-maticemi/">http://www.root.cz/clanky/programovaci-jazyk-clojure-a-knihovny-pro-praci-s-vektory-a-maticemi/</a>
</li>

<li>Programovací jazyk Clojure a knihovny pro práci s vektory a maticemi (2)<br />
<a href="http://www.root.cz/clanky/programovaci-jazyk-clojure-a-knihovny-pro-praci-s-vektory-a-maticemi-2/">http://www.root.cz/clanky/programovaci-jazyk-clojure-a-knihovny-pro-praci-s-vektory-a-maticemi-2/</a>
</li>

<li>Programovací jazyk Clojure: syntéza procedurálních textur s využitím knihovny Clisk<br />
<a href="http://www.root.cz/clanky/programovaci-jazyk-clojure-synteza-proceduralnich-textur-s-vyuzitim-knihovny-clisk/">http://www.root.cz/clanky/programovaci-jazyk-clojure-synteza-proceduralnich-textur-s-vyuzitim-knihovny-clisk/</a>
</li>

<li>Programovací jazyk Clojure: syntéza procedurálních textur s využitím knihovny Clisk (2)<br />
<a href="http://www.root.cz/clanky/programovaci-jazyk-clojure-synteza-proceduralnich-textur-s-vyuzitim-knihovny-clisk-2/">http://www.root.cz/clanky/programovaci-jazyk-clojure-synteza-proceduralnich-textur-s-vyuzitim-knihovny-clisk-2/</a>
</li>

<li>Seesaw: knihovna pro snadnou tvorbu GUI v jazyce Clojure<br />
<a href="http://www.root.cz/clanky/seesaw-knihovna-pro-snadnou-tvorbu-gui-v-jazyce-clojure/">http://www.root.cz/clanky/seesaw-knihovna-pro-snadnou-tvorbu-gui-v-jazyce-clojure/</a>
</li>

<li>Seesaw: knihovna pro snadnou tvorbu GUI v jazyce Clojure (2)<br />
<a href="http://www.root.cz/clanky/seesaw-knihovna-pro-snadnou-tvorbu-gui-v-jazyce-clojure-2/">http://www.root.cz/clanky/seesaw-knihovna-pro-snadnou-tvorbu-gui-v-jazyce-clojure-2/</a>
</li>

<li>Seesaw: knihovna pro snadnou tvorbu GUI v jazyce Clojure (3)<br />
<a href="http://www.root.cz/clanky/seesaw-knihovna-pro-snadnou-tvorbu-gui-v-jazyce-clojure-3/">http://www.root.cz/clanky/seesaw-knihovna-pro-snadnou-tvorbu-gui-v-jazyce-clojure-3/</a>
</li>

<li>Programovací jazyk Clojure a práce s Gitem<br />
<a href="http://www.root.cz/clanky/programovaci-jazyk-clojure-a-prace-s-gitem/">http://www.root.cz/clanky/programovaci-jazyk-clojure-a-prace-s-gitem/</a>
</li>

<li>Programovací jazyk Clojure: syntéza procedurálních textur s využitím knihovny Clisk (dokončení)<br />
<a href="http://www.root.cz/clanky/programovaci-jazyk-clojure-synteza-proceduralnich-textur-s-vyuzitim-knihovny-clisk-dokonceni/">http://www.root.cz/clanky/programovaci-jazyk-clojure-synteza-proceduralnich-textur-s-vyuzitim-knihovny-clisk-dokonceni/</a>
</li>

<li>Programovací jazyk Clojure a práce s Gitem (2)<br />
<a href="http://www.root.cz/clanky/programovaci-jazyk-clojure-a-prace-s-gitem-2/">http://www.root.cz/clanky/programovaci-jazyk-clojure-a-prace-s-gitem-2/</a>
</li>

<li>Programovací jazyk Clojure – triky při práci s řetězci<br />
<a href="http://www.root.cz/clanky/programovaci-jazyk-clojure-triky-pri-praci-s-retezci/">http://www.root.cz/clanky/programovaci-jazyk-clojure-triky-pri-praci-s-retezci/</a>
</li>

<li>Programovací jazyk Clojure – triky při práci s kolekcemi<br />
<a href="http://www.root.cz/clanky/programovaci-jazyk-clojure-triky-pri-praci-s-kolekcemi/">http://www.root.cz/clanky/programovaci-jazyk-clojure-triky-pri-praci-s-kolekcemi/</a>
</li>

<li>Programovací jazyk Clojure – práce s mapami a množinami<br />
<a href="http://www.root.cz/clanky/programovaci-jazyk-clojure-prace-s-mapami-a-mnozinami/">http://www.root.cz/clanky/programovaci-jazyk-clojure-prace-s-mapami-a-mnozinami/</a>
</li>

<li>Programovací jazyk Clojure – základy zpracování XML<br />
<a href="http://www.root.cz/clanky/programovaci-jazyk-clojure-zaklady-zpracovani-xml/">http://www.root.cz/clanky/programovaci-jazyk-clojure-zaklady-zpracovani-xml/</a>
</li>

<li>Programovací jazyk Clojure – testování s využitím knihovny Expectations<br />
<a href="http://www.root.cz/clanky/programovaci-jazyk-clojure-testovani-s-vyuzitim-knihovny-expectations/">http://www.root.cz/clanky/programovaci-jazyk-clojure-testovani-s-vyuzitim-knihovny-expectations/</a>
</li>

<li>Programovací jazyk Clojure – některé užitečné triky použitelné (nejenom) v&nbsp;testech<br />
<a href="http://www.root.cz/clanky/programovaci-jazyk-clojure-nektere-uzitecne-triky-pouzitelne-nejenom-v-testech/">http://www.root.cz/clanky/programovaci-jazyk-clojure-nektere-uzitecne-triky-pouzitelne-nejenom-v-testech/</a>
</li>

<li>Enlive – výkonný šablonovací systém pro jazyk Clojure<br/>
<a href="http://www.root.cz/clanky/enlive-vykonny-sablonovaci-system-pro-jazyk-clojure/">http://www.root.cz/clanky/enlive-vykonny-sablonovaci-system-pro-jazyk-clojure/</a>
</li>

<li>Nástroj Leiningen a programovací jazyk Clojure: tvorba vlastních knihoven pro veřejný repositář Clojars<br />
<a href="http://www.root.cz/clanky/nastroj-leiningen-a-programovaci-jazyk-clojure-tvorba-vlastnich-knihoven-pro-verejny-repositar-clojars/">http://www.root.cz/clanky/nastroj-leiningen-a-programovaci-jazyk-clojure-tvorba-vlastnich-knihoven-pro-verejny-repositar-clojars/</a>
</li>

<li>Novinky v Clojure verze 1.8.0<br />
<a href="http://www.root.cz/clanky/novinky-v-clojure-verze-1-8-0/">http://www.root.cz/clanky/novinky-v-clojure-verze-1-8-0/</a>
</li>

<li>Asynchronní programování v&nbsp;Clojure s&nbsp;využitím knihovny core.async<br />
<a href="http://www.root.cz/clanky/asynchronni-programovani-v-clojure-s-vyuzitim-knihovny-core-async/">http://www.root.cz/clanky/asynchronni-programovani-v-clojure-s-vyuzitim-knihovny-core-async/</a>
</li>

<li>Asynchronní programování v&nbsp;Clojure s&nbsp;využitím knihovny core.async (pokračování)<br />
<a href="http://www.root.cz/clanky/asynchronni-programovani-v-clojure-s-vyuzitim-knihovny-core-async-pokracovani/">http://www.root.cz/clanky/asynchronni-programovani-v-clojure-s-vyuzitim-knihovny-core-async-pokracovani/</a>
</li>

<li>Asynchronní programování v Clojure s využitím knihovny core.async (dokončení)<br />
<a href="http://www.root.cz/clanky/asynchronni-programovani-v-clojure-s-vyuzitim-knihovny-core-async-dokonceni/">http://www.root.cz/clanky/asynchronni-programovani-v-clojure-s-vyuzitim-knihovny-core-async-dokonceni/</a>
</li>

<li>Vytváříme IRC bota v programovacím jazyce Clojure<br />
<a href="http://www.root.cz/clanky/vytvarime-irc-bota-v-programovacim-jazyce-clojure/">http://www.root.cz/clanky/vytvarime-irc-bota-v-programovacim-jazyce-clojure/</a>
</li>

<li>Gorilla REPL: interaktivní prostředí pro programovací jazyk Clojure<br />
<a href="https://www.root.cz/clanky/gorilla-repl-interaktivni-prostredi-pro-programovaci-jazyk-clojure/">https://www.root.cz/clanky/gorilla-repl-interaktivni-prostredi-pro-programovaci-jazyk-clojure/</a>
</li>

<li>Multimetody v Clojure aneb polymorfismus bez použití OOP<br />
<a href="https://www.root.cz/clanky/multimetody-v-clojure-aneb-polymorfismus-bez-pouziti-oop/">https://www.root.cz/clanky/multimetody-v-clojure-aneb-polymorfismus-bez-pouziti-oop/</a>
</li>

<li>Práce s externími Java archivy v programovacím jazyku Clojure<br />
<a href="https://www.root.cz/clanky/prace-s-externimi-java-archivy-v-programovacim-jazyku-clojure/">https://www.root.cz/clanky/prace-s-externimi-java-archivy-v-programovacim-jazyku-clojure/</a>
</li>

<li>Pixie: lehký skriptovací jazyk s „kouzelnými“ schopnostmi<br />
<a href="https://www.root.cz/clanky/pixie-lehky-skriptovaci-jazyk-s-kouzelnymi-schopnostmi/">https://www.root.cz/clanky/pixie-lehky-skriptovaci-jazyk-s-kouzelnymi-schopnostmi/</a>
</li>

<li>Programovací jazyk Pixie: funkce ze základní knihovny a použití FFI<br />
<a href="https://www.root.cz/clanky/programovaci-jazyk-pixie-funkce-ze-zakladni-knihovny-a-pouziti-ffi/">https://www.root.cz/clanky/programovaci-jazyk-pixie-funkce-ze-zakladni-knihovny-a-pouziti-ffi/</a>
</li>

<li>Novinky v Clojure verze 1.9.0<br />
<a href="https://www.root.cz/clanky/novinky-v-clojure-verze-1-9-0/">https://www.root.cz/clanky/novinky-v-clojure-verze-1-9-0/</a>
</li>

<li>Validace dat s&nbsp;využitím knihovny spec v&nbsp;Clojure 1.9.0<br />
<a href="https://www.root.cz/clanky/validace-dat-s-vyuzitim-knihovny-spec-v-clojure-1-9-0/">https://www.root.cz/clanky/validace-dat-s-vyuzitim-knihovny-spec-v-clojure-1-9-0/</a>
</li>

</ol>



<p><a name="k20"></a></p>
<h2 id="k20">20. Odkazy na Internetu</h2>

<ol>

<li>Test.check 0.9.0<br />
<a href="https://clojure.github.io/test.check/index.html">https://clojure.github.io/test.check/index.html</a>
</li>

<li>Knihovna test.check na GitHubu<br />
<a href="https://github.com/clojure/test.check">https://github.com/clojure/test.check</a>
</li>

<li>Introduction to test.check<br />
<a href="https://clojure.github.io/test.check/intro.html">https://clojure.github.io/test.check/intro.html</a>
</li>

<li>QuickCheck<br />
<a href="https://en.wikipedia.org/wiki/QuickCheck">https://en.wikipedia.org/wiki/QuickCheck</a>
</li>

<li>Originální QuickCheck<br />
<a href="http://www.cse.chalmers.se/~rjmh/QuickCheck/">http://www.cse.chalmers.se/~rjmh/QuickCheck/</a>
</li>

<li>Hypothesis (QuickCheck pro Python)<br />
<a href="https://hypothesis.works/">https://hypothesis.works/</a>
</li>

<li>Generator Examples<br />
<a href="https://clojure.github.io/test.check/generator-examples.html">https://clojure.github.io/test.check/generator-examples.html</a>
</li>

<li>5 Differences between clojure.spec and Schema<br />
<a href="https://lispcast.com/clojure.spec-vs-schema/">https://lispcast.com/clojure.spec-vs-schema/</a>
</li>

<li>Schema: Clojure(Script) library for declarative data description and validation<br />
<a href="https://github.com/plumatic/schema">https://github.com/plumatic/schema</a>
</li>

<li>Zip archiv s&nbsp;Clojure 1.9.0<br />
<a href="http://repo1.maven.org/maven2/org/clojure/clojure/1.9.0/clojure-1.9.0.zip">http://repo1.maven.org/maven2/org/clojure/clojure/1.9.0/clojure-1.9.0.zip</a>
</li>

<li>Clojure 1.9 is now available<br />
<a href="https://clojure.org/news/2017/12/08/clojure19">https://clojure.org/news/2017/12/08/clojure19</a>
</li>

<li>Deps and CLI Guide<br />
<a href="https://clojure.org/guides/deps_and_cli">https://clojure.org/guides/deps_and_cli</a>
</li>

<li>Changes to Clojure in Version 1.9<br />
<a href="https://github.com/clojure/clojure/blob/master/changes.md">https://github.com/clojure/clojure/blob/master/changes.md</a>
</li>

<li>clojure.spec - Rationale and Overview<br />
<a href="https://clojure.org/about/spec">https://clojure.org/about/spec</a>
</li>

<li>Zip archiv s&nbsp;Clojure 1.8.0<br />
<a href="http://repo1.maven.org/maven2/org/clojure/clojure/1.8.0/clojure-1.8.0.zip">http://repo1.maven.org/maven2/org/clojure/clojure/1.8.0/clojure-1.8.0.zip</a>
</li>

<li>Clojure 1.8 is now available<br />
<a href="http://clojure.org/news/2016/01/19/clojure18">http://clojure.org/news/2016/01/19/clojure18</a>
</li>

<li>Socket Server REPL<br />
<a href="http://dev.clojure.org/display/design/Socket+Server+REPL">http://dev.clojure.org/display/design/Socket+Server+REPL</a>
</li>

<li>CLJ-1671: Clojure socket server<br />
<a href="http://dev.clojure.org/jira/browse/CLJ-1671">http://dev.clojure.org/jira/browse/CLJ-1671</a>
</li>

<li>CLJ-1449: Add clojure.string functions for portability to ClojureScript<br />
<a href="http://dev.clojure.org/jira/browse/CLJ-1449">http://dev.clojure.org/jira/browse/CLJ-1449</a>
</li>

<li>Launching a Socket Server<br />
<a href="http://clojure.org/reference/repl_and_main#_launching_a_socket_server">http://clojure.org/reference/repl_and_main#_launching_a_socket_server</a>
</li>

<li>API for clojure.string<br />
<a href="http://clojure.github.io/clojure/branch-master/clojure.string-api.html">http://clojure.github.io/clojure/branch-master/clojure.string-api.html</a>
</li>

<li>Clojars:<br />
<a href="https://clojars.org/">https://clojars.org/</a>
</li>

<li>Seznam knihoven na Clojars:<br />
<a href="https://clojars.org/projects">https://clojars.org/projects</a>
</li>

<li>Clojure Cookbook: Templating HTML with Enlive<br />
<a href="https://github.com/clojure-cookbook/clojure-cookbook/blob/master/07_webapps/7-11_enlive.asciidoc">https://github.com/clojure-cookbook/clojure-cookbook/blob/master/07_webapps/7-11_enlive.asciidoc</a>
</li>

<li>An Introduction to Enlive<br />
<a href="https://github.com/swannodette/enlive-tutorial/">https://github.com/swannodette/enlive-tutorial/</a>
</li>

<li>Enlive na GitHubu<br />
<a href="https://github.com/cgrand/enlive">https://github.com/cgrand/enlive</a>
</li>

<li>Expectations: příklady atd.<br />
<a href="http://jayfields.com/expectations/">http://jayfields.com/expectations/</a>
</li>

<li>Expectations na GitHubu<br />
<a href="https://github.com/jaycfields/expectations">https://github.com/jaycfields/expectations</a>
</li>

<li>Lein-expectations na GitHubu<br />
<a href="https://github.com/gar3thjon3s/lein-expectations">https://github.com/gar3thjon3s/lein-expectations</a>
</li>

<li>Testing Clojure With Expectations<br />
<a href="https://semaphoreci.com/blog/2014/09/23/testing-clojure-with-expectations.html">https://semaphoreci.com/blog/2014/09/23/testing-clojure-with-expectations.html</a>
</li>

<li>Clojure testing TDD/BDD libraries: clojure.test vs Midje vs Expectations vs Speclj<br />
<a href="https://www.reddit.com/r/Clojure/comments/1viilt/clojure_testing_tddbdd_libraries_clojuretest_vs/">https://www.reddit.com/r/Clojure/comments/1viilt/clojure_testing_tddbdd_libraries_clojuretest_vs/</a>
</li>

<li>Testing: One assertion per test<br />
<a href="http://blog.jayfields.com/2007/06/testing-one-assertion-per-test.html">http://blog.jayfields.com/2007/06/testing-one-assertion-per-test.html</a>
</li>

<li>Rewriting Your Test Suite in Clojure in 24 hours<br />
<a href="http://blog.circleci.com/rewriting-your-test-suite-in-clojure-in-24-hours/">http://blog.circleci.com/rewriting-your-test-suite-in-clojure-in-24-hours/</a>
</li>

<li>Clojure doc: zipper<br />
<a href="http://clojuredocs.org/clojure.zip/zipper">http://clojuredocs.org/clojure.zip/zipper</a>
</li>

<li>Clojure doc: parse<br />
<a href="http://clojuredocs.org/clojure.xml/parse">http://clojuredocs.org/clojure.xml/parse</a>
</li>

<li>Clojure doc: xml-zip<br />
<a href="http://clojuredocs.org/clojure.zip/xml-zip">http://clojuredocs.org/clojure.zip/xml-zip</a>
</li>

<li>Clojure doc: xml-seq<br />
<a href="http://clojuredocs.org/clojure.core/xml-seq">http://clojuredocs.org/clojure.core/xml-seq</a>
</li>

<li>Parsing XML in Clojure<br />
<a href="https://github.com/clojuredocs/guides">https://github.com/clojuredocs/guides</a>
</li>

<li>Clojure Zipper Over Nested Vector<br />
<a href="https://vitalyper.wordpress.com/2010/11/23/clojure-zipper-over-nested-vector/">https://vitalyper.wordpress.com/2010/11/23/clojure-zipper-over-nested-vector/</a>
</li>

<li>Understanding Clojure's PersistentVector implementation<br />
<a href="http://blog.higher-order.net/2009/02/01/understanding-clojures-persistentvector-implementation">http://blog.higher-order.net/2009/02/01/understanding-clojures-persistentvector-implementation</a>
</li>

<li>Understanding Clojure's PersistentHashMap (deftwice...)<br />
<a href="http://blog.higher-order.net/2009/09/08/understanding-clojures-persistenthashmap-deftwice.html">http://blog.higher-order.net/2009/09/08/understanding-clojures-persistenthashmap-deftwice.html</a>
</li>

<li>Assoc and Clojure's PersistentHashMap: part ii<br />
<a href="http://blog.higher-order.net/2010/08/16/assoc-and-clojures-persistenthashmap-part-ii.html">http://blog.higher-order.net/2010/08/16/assoc-and-clojures-persistenthashmap-part-ii.html</a>
</li>

<li>Ideal Hashtrees (paper)<br />
<a href="http://lampwww.epfl.ch/papers/idealhashtrees.pdf">http://lampwww.epfl.ch/papers/idealhashtrees.pdf</a>
</li>

<li>Clojure home page<br />
<a href="http://clojure.org/">http://clojure.org/</a>
</li>

<li>Clojure (downloads)<br />
<a href="http://clojure.org/downloads">http://clojure.org/downloads</a>
</li>

<li>Clojure Sequences<br />
<a href="http://clojure.org/sequences">http://clojure.org/sequences</a>
</li>

<li>Clojure Data Structures<br />
<a href="http://clojure.org/data_structures">http://clojure.org/data_structures</a>
</li>

<li>The Structure and Interpretation of Computer Programs: 2.2.1  Representing Sequences<br />
<a href="http://mitpress.mit.edu/sicp/full-text/book/book-Z-H-15.html#%_sec_2.2.1">http://mitpress.mit.edu/sicp/full-text/book/book-Z-H-15.html#%_sec_2.2.1</a>
</li>

<li>The Structure and Interpretation of Computer Programs: 3.3.1  Mutable List Structure<br />
<a href="http://mitpress.mit.edu/sicp/full-text/book/book-Z-H-22.html#%_sec_3.3.1">http://mitpress.mit.edu/sicp/full-text/book/book-Z-H-22.html#%_sec_3.3.1</a>
</li>

<li>Clojure - Functional Programming for the JVM<br />
<a href="http://java.ociweb.com/mark/clojure/article.html">http://java.ociweb.com/mark/clojure/article.html</a>
</li>

<li>Clojure quick reference<br />
<a href="http://faustus.webatu.com/clj-quick-ref.html">http://faustus.webatu.com/clj-quick-ref.html</a>
</li>

<li>4Clojure<br />
<a href="http://www.4clojure.com/">http://www.4clojure.com/</a>
</li>

<li>ClojureDoc (rozcestník s&nbsp;dokumentací jazyka Clojure)<br />
<a href="http://clojuredocs.org/">http://clojuredocs.org/</a>
</li>

<li>Clojure (na Wikipedia EN)<br />
<a href="http://en.wikipedia.org/wiki/Clojure">http://en.wikipedia.org/wiki/Clojure</a>
</li>

<li>Clojure (na Wikipedia CS)<br />
<a href="http://cs.wikipedia.org/wiki/Clojure">http://cs.wikipedia.org/wiki/Clojure</a>
</li>

<li>SICP (The Structure and Interpretation of Computer Programs)<br />
<a href="http://mitpress.mit.edu/sicp/">http://mitpress.mit.edu/sicp/</a>
</li>

<li>Pure function<br />
<a href="http://en.wikipedia.org/wiki/Pure_function">http://en.wikipedia.org/wiki/Pure_function</a>
</li>

<li>Funkcionální programování<br />
<a href="http://cs.wikipedia.org/wiki/Funkcionální_programování">http://cs.wikipedia.org/wiki/Funkcionální_programování</a>
</li>

<li>Čistě funkcionální (datové struktury, jazyky, programování)<br />
<a href="http://cs.wikipedia.org/wiki/Čistě_funkcionální">http://cs.wikipedia.org/wiki/Čistě_funkcionální</a>
</li>

<li>Clojure Macro Tutorial (Part I, Getting the Compiler to Write Your Code For You)<br />
<a href="http://www.learningclojure.com/2010/09/clojure-macro-tutorial-part-i-getting.html">http://www.learningclojure.com/2010/09/clojure-macro-tutorial-part-i-getting.html</a>
</li>

<li>Clojure Macro Tutorial (Part II: The Compiler Strikes Back)<br />
<a href="http://www.learningclojure.com/2010/09/clojure-macro-tutorial-part-ii-compiler.html">http://www.learningclojure.com/2010/09/clojure-macro-tutorial-part-ii-compiler.html</a>
</li>

<li>Clojure Macro Tutorial (Part III: Syntax Quote)<br />
<a href="http://www.learningclojure.com/2010/09/clojure-macro-tutorial-part-ii-syntax.html">http://www.learningclojure.com/2010/09/clojure-macro-tutorial-part-ii-syntax.html</a>
</li>

<li>Tech behind Tech: Clojure Macros Simplified<br />
<a href="http://techbehindtech.com/2010/09/28/clojure-macros-simplified/">http://techbehindtech.com/2010/09/28/clojure-macros-simplified/</a>
</li>

<li>Fatvat - Exploring functional programming: Clojure Macros<br />
<a href="http://www.fatvat.co.uk/2009/02/clojure-macros.html">http://www.fatvat.co.uk/2009/02/clojure-macros.html</a>
</li>

<li>Eulerovo číslo<br />
<a href="http://cs.wikipedia.org/wiki/Eulerovo_číslo">http://cs.wikipedia.org/wiki/Eulerovo_číslo</a>
</li>

<li>List comprehension<br />
<a href="http://en.wikipedia.org/wiki/List_comprehension">http://en.wikipedia.org/wiki/List_comprehension</a>
</li>

<li>List Comprehensions in Clojure<br />
<a href="http://asymmetrical-view.com/2008/11/18/list-comprehensions-in-clojure.html">http://asymmetrical-view.com/2008/11/18/list-comprehensions-in-clojure.html</a>
</li>

<li>Clojure Programming Concepts: List Comprehension<br />
<a href="http://en.wikibooks.org/wiki/Clojure_Programming/Concepts#List_Comprehension">http://en.wikibooks.org/wiki/Clojure_Programming/Concepts#List_Comprehension</a>
</li>

<li>Clojure core API: for macro<br />
<a href="http://clojure.github.com/clojure/clojure.core-api.html#clojure.core/for">http://clojure.github.com/clojure/clojure.core-api.html#clojure.core/for</a>
</li>

<li>cirrus machina - The Clojure for macro<br />
<a href="http://www.cirrusmachina.com/blog/comment/the-clojure-for-macro/">http://www.cirrusmachina.com/blog/comment/the-clojure-for-macro/</a>
</li>

<li>Riastradh's Lisp Style Rules<br />
<a href="http://mumble.net/~campbell/scheme/style.txt">http://mumble.net/~campbell/scheme/style.txt</a>
</li>

<li>Dynamic Languages Strike Back<br />
<a href="http://steve-yegge.blogspot.cz/2008/05/dynamic-languages-strike-back.html">http://steve-yegge.blogspot.cz/2008/05/dynamic-languages-strike-back.html</a>
</li>

<li>Scripting: Higher Level Programming for the 21st Century<br />
<a href="http://www.tcl.tk/doc/scripting.html">http://www.tcl.tk/doc/scripting.html</a>
</li>

<li>Java Virtual Machine Support for Non-Java Languages<br />
<a href="http://docs.oracle.com/javase/7/docs/technotes/guides/vm/multiple-language-support.html">http://docs.oracle.com/javase/7/docs/technotes/guides/vm/multiple-language-support.html</a>
</li>

<li>Třída java.lang.String<br />
<a href="http://docs.oracle.com/javase/7/docs/api/java/lang/String.html">http://docs.oracle.com/javase/7/docs/api/java/lang/String.html</a>
</li>

<li>Třída java.lang.StringBuffer<br />
<a href="http://docs.oracle.com/javase/7/docs/api/java/lang/StringBuffer.html">http://docs.oracle.com/javase/7/docs/api/java/lang/StringBuffer.html</a>
</li>

<li>Třída java.lang.StringBuilder<br />
<a href="http://docs.oracle.com/javase/7/docs/api/java/lang/StringBuilder.html">http://docs.oracle.com/javase/7/docs/api/java/lang/StringBuilder.html</a>
</li>

<li>StringBuffer versus String<br />
<a href="http://www.javaworld.com/article/2076072/build-ci-sdlc/stringbuffer-versus-string.html">http://www.javaworld.com/article/2076072/build-ci-sdlc/stringbuffer-versus-string.html</a>
</li>

<li>Threading macro (dokumentace k&nbsp;jazyku Clojure)<br />
<a href="https://clojure.github.io/clojure/clojure.core-api.html#clojure.core/-&gt;">https://clojure.github.io/clojure/clojure.core-api.html#clojure.core/-&gt;</a>
</li>

<li>Understanding the Clojure -&gt; macro<br />
<a href="http://blog.fogus.me/2009/09/04/understanding-the-clojure-macro/">http://blog.fogus.me/2009/09/04/understanding-the-clojure-macro/</a>
</li>

<li>clojure.inspector<br />
<a href="http://clojure.github.io/clojure/clojure.inspector-api.html">http://clojure.github.io/clojure/clojure.inspector-api.html</a>
</li>

<li>The Clojure Toolbox<br />
<a href="http://www.clojure-toolbox.com/">http://www.clojure-toolbox.com/</a>
</li>

<li>Unit Testing in Clojure<br />
<a href="http://nakkaya.com/2009/11/18/unit-testing-in-clojure/">http://nakkaya.com/2009/11/18/unit-testing-in-clojure/</a>
</li>

<li>Testing in Clojure (Part-1: Unit testing)<br />
<a href="http://blog.knoldus.com/2014/03/22/testing-in-clojure-part-1-unit-testing/">http://blog.knoldus.com/2014/03/22/testing-in-clojure-part-1-unit-testing/</a>
</li>

<li>API for clojure.test - Clojure v1.6 (stable)<br />
<a href="https://clojure.github.io/clojure/clojure.test-api.html">https://clojure.github.io/clojure/clojure.test-api.html</a>
</li>

<li>Leiningen: úvodní stránka<br />
<a href="http://leiningen.org/">http://leiningen.org/</a>
</li>

<li>Leiningen: Git repository<br />
<a href="https://github.com/technomancy/leiningen">https://github.com/technomancy/leiningen</a>
</li>

<li>leiningen-win-installer<br />
<a href="http://leiningen-win-installer.djpowell.net/">http://leiningen-win-installer.djpowell.net/</a>
</li>

<li>Clojure.org: Vars and the Global Environment<br />
<a href="http://clojure.org/Vars">http://clojure.org/Vars</a>
</li>

<li>Clojure.org: Refs and Transactions<br />
<a href="http://clojure.org/Refs">http://clojure.org/Refs</a>
</li>

<li>Clojure.org: Atoms<br />
<a href="http://clojure.org/Atoms">http://clojure.org/Atoms</a>
</li>

<li>Clojure.org: Agents as Asynchronous Actions<br />
<a href="http://clojure.org/agents">http://clojure.org/agents</a>
</li>

<li>Transient Data Structures
<a href="http://clojure.org/transients">http://clojure.org/transients</a>
</li>

</ol>



<p></p><p></p>
<p><small>Autor: <a href="http://www.fit.vutbr.cz/~tisnovpa">Pavel Tišnovský</a> &nbsp; 2018</small></p>
</body>
</html>

