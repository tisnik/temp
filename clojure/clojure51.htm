<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
        "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html>
<head>
<title>Řídicí struktury využitelné v programovacím jazyku Clojure (dokončení)</title>
<meta name="Author" content="Pavel Tisnovsky" />
<meta name="Generator" content="vim" />
<meta http-equiv="content-type" content="text/html; charset=utf-8" />
<style type="text/css">
         body {color:#000000; background:#ffffff;}
         h1  {font-family: arial, helvetica, sans-serif; color:#ffffff; background-color:#c00000; text-align:center; padding-left:1em}
         h2  {font-family: arial, helvetica, sans-serif; color:#ffffff; background-color:#0000c0; padding-left:1em; text-align:left}
         h3  {font-family: arial, helvetica, sans-serif; color:#000000; background-color:#c0c0c0; padding-left:1em; text-align:left}
         h4  {font-family: arial, helvetica, sans-serif; color:#000000; background-color:#e0e0e0; padding-left:1em; text-align:left}
         a   {font-family: arial, helvetica, sans-serif;}
         li  {font-family: arial, helvetica, sans-serif; color:#000000; text-align:justify; width:450px;}
         ol  {font-family: arial, helvetica, sans-serif; color:#000000; text-align:justify; width:450px;}
         ul  {font-family: arial, helvetica, sans-serif; color:#000000; text-align:justify; width:450px;}
         p   {font-family: arial, helvetica, sans-serif; color:#000000; text-align:justify;}
         pre {background:#e0e0e0}
</style>
</head>

<body>

<h1>Řídicí struktury využitelné v programovacím jazyku Clojure (dokončení)</h1>

<h3>Pavel Tišnovský</h3>

<p></p>

<h1>Úvodník</h1>

<p></p>



<h2>Obsah</h2>

<p><a href="#k01">1. Řídicí struktury využitelné v&nbsp;programovacím jazyku Clojure (dokončení)</a></p>
<p><a href="#k02">2. Makro <strong>cond-&gt;</strong></a></p>
<p><a href="#k03">3. Vyhodnocování všech větví makrem <strong>cond-&gt;</strong></a></p>
<p><a href="#k04">4. Expanze makra <strong>cond-&gt;</strong></a></p>
<p><a href="#k05">5. Makro <strong>cond-&gt;&gt;</strong></a></p>
<p><a href="#k06">6. Expanze makra <strong>cond-&gt;&gt;</strong></a></p>
<p><a href="#k07">7. Jedno z&nbsp;nejsložitějších maker ze standardní knihovny: <strong>case</strong></a></p>
<p><a href="#k08">8. Větší množství konstant u jednotlivých větví v&nbsp;makru <strong>case</strong></a></p>
<p><a href="#k09">9. Kdy použít <strong>cond</strong>, <strong>condp</strong> a <strong>case</strong>?</a></p>
<p><a href="#k10">10. Expanze makra <strong>case</strong> a forma vygenerovaného bajtkódu</a></p>
<p><a href="#k11">11. Makra ze jmenného prostoru clojure.core.logic</a></p>
<p><a href="#k12">12. Od &bdquo;jednorozměrných&ldquo; rozhodovacích konstrukcí ke konstrukcím dvourozměrným</a></p>
<p><a href="#k13">13. Makro <strong>cond-table</strong></a></p>
<p><a href="#k14">*** 14. Příklady použití makra <strong>cond-table</strong></a></p>
<p><a href="#k15">*** 15. </a></p>
<p><a href="#k16">*** 16. </a></p>
<p><a href="#k17">17. Příloha: zdrojové kódy výše popsaných maker</a></p>
<p><a href="#k18">18. Repositář s&nbsp;demonstračními příklady</a></p>
<p><a href="#k19">19. Odkazy na předchozí části seriálu o programovacím jazyku Clojure</a></p>
<p><a href="#k20">20. Odkazy na Internetu</a></p>



<p><a name="k01"></a></p>
<h2 id="k01">1. Řídicí struktury využitelné v&nbsp;programovacím jazyku Clojure (dokončení)</h2>

<p>V&nbsp;dnešním článku dokončíme téma, kterému jsme se věnovali <a
href="https://www.root.cz/clanky/ridici-struktury-vyuzitelne-v-programovacim-jazyku-clojure/">minule</a>.
Nejprve si popíšeme některá další (a nutno říci, že velmi často používaná)
makra nabízená standardní knihovnou programovacího jazyka Clojure. Jedná se
především o makra <strong>cond-&gt;</strong>, <strong>cond-&gt;&gt;</strong>
(což jsou varianty makra <strong>cond</strong>, které již dobře známe), dále
pak o makro <strong>if-not</strong> a v&nbsp;neposlední řadě o interně dosti
složité makro nazvané příhodně <strong>case</strong>. To však není zdaleka vše,
protože existují i další makra určená pro řízení toku programu. Především se
jedná o makra nabízená ve jmenném prostoru <strong>clojure.core.logic</strong>,
zejména o makra nazvaná <strong>conde</strong>, <strong>condu</strong> a
<strong>conda</strong>. Asi nebude velkým překvapením, že se opět jedná o
varianty standardního makra <strong>cond</strong>.</p>

<p>Ještě zajímavější jsou však makra z&nbsp;vybraných nestandardních knihoven,
zejména pak velmi povedené makro <strong>cond-table</strong>, jehož autorem je
Daniel Gregoire. S&nbsp;využitím <strong>cond-table</strong> je možné vytvářet
i složité rozhodovací tabulky (což jsou de facto dvourozměrné rozhodovací
struktury, které možnosti jednorozměrných struktur dosti podstatným způsobem
zobecňují). Zmíníme se i o složitějších rozhodovacích strukturách nabízených
například knihovnou <strong>special</strong>, <strong>better-cond</strong>,
<strong>cond-let</strong> atd.</p>

<table>
<tr><th> #</th><th>Konstrukce</th><th>Článek/kapitola</th><th>Typ</th><th>Stručný popis</th></tr>
<tr><td> 1</td><td>if</td><td><a href="https://www.root.cz/clanky/ridici-struktury-vyuzitelne-v-programovacim-jazyku-clojure#k02">1/2</a></td><td>speciální forma</td><td>základní rozhodovací konstrukce, základ pro další makra</td></tr>
<tr><td> 2</td><td>if-not</td><td>&nbsp;</td><td>makro</td><td>stejné jako speciální forma <strong>if</strong>, ovšem s&nbsp;negovanou podmínkou</td></tr>
<tr><td> 3</td><td>if+do</td><td><a href="https://www.root.cz/clanky/ridici-struktury-vyuzitelne-v-programovacim-jazyku-clojure#k03">1/3</a></td><td>dvě speciální formy</td><td>použito ve chvíli, kdy je nutné do jedné větve či obou větví zapsat více výrazů</td></tr>
<tr><td> 4</td><td>if-let</td><td><a href="https://www.root.cz/clanky/ridici-struktury-vyuzitelne-v-programovacim-jazyku-clojure#k05">1/5</a></td><td>makro</td><td>kombinace speciálních forem <strong>if</strong> a <strong>let</strong></td></tr>
<tr><td> 5</td><td>if-some</td><td><a href="https://www.root.cz/clanky/ridici-struktury-vyuzitelne-v-programovacim-jazyku-clojure#k06">1/6</a></td><td>makro</td><td>kombinace speciálních forem <strong>if</strong> (test na <strong>nil</strong>) a <strong>let</strong></td></tr>
<tr><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td></tr>
<tr><td> 6</td><td>and</td><td><a href="https://www.root.cz/clanky/ridici-struktury-vyuzitelne-v-programovacim-jazyku-clojure#k07">1/7</a></td><td>makro</td><td>postupné vyhodnocování předaných výrazů až do chvíle, kdy se vrátí <strong>nil</strong> či <strong>false</strong></td></tr>
<tr><td> 7</td><td>or</td><td><a href="https://www.root.cz/clanky/ridici-struktury-vyuzitelne-v-programovacim-jazyku-clojure#k07">1/7</a></td><td>makro</td><td>postupné vyhodnocování předaných výrazů až do chvíle, kdy se vrátí <strong>true</strong></td></tr>
<tr><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td></tr>
<tr><td> 8</td><td>when</td><td><a href="https://www.root.cz/clanky/ridici-struktury-vyuzitelne-v-programovacim-jazyku-clojure#k04">1/4</a></td><td>makro</td><td>vhodná náhrada za <strong>if</strong> s&nbsp;jedinou větví s&nbsp;více výrazy</td></tr>
<tr><td> 9</td><td>when-not</td><td><a href="https://www.root.cz/clanky/ridici-struktury-vyuzitelne-v-programovacim-jazyku-clojure#k04">1/4</a></td><td>makro</td><td>vhodná náhrada za <strong>if-not</strong> s&nbsp;jedinou větví s&nbsp;více výrazy</td></tr>
<tr><td>10</td><td>when-let</td><td><a href="https://www.root.cz/clanky/ridici-struktury-vyuzitelne-v-programovacim-jazyku-clojure#k05">1/5</a></td><td>makro</td><td>kombinace speciálních forem <strong>when</strong> a <strong>let</strong></td></tr>
<tr><td>11</td><td>when-some</td><td><a href="https://www.root.cz/clanky/ridici-struktury-vyuzitelne-v-programovacim-jazyku-clojure#k06">1/6</a></td><td>makro</td><td>kombinace speciálních forem <strong>when</strong> (test na <strong>nil</strong>) a <strong>let</strong></td></tr>
<tr><td>12</td><td>when-first</td><td>&nbsp;</td><td>makro</td><td>použito při testu prvního prvku sekvence s&nbsp;následným zpracováním sekvence</td></tr>
<tr><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td></tr>
<tr><td>13</td><td>cond</td><td><a href="https://www.root.cz/clanky/ridici-struktury-vyuzitelne-v-programovacim-jazyku-clojure#k08">1/8</a></td><td>makro</td><td>postupné testování podmínek, pokud je podmínka splněna, vrátí se hodnota příslušného výrazu</td></tr>
<tr><td>14</td><td>cond + :else </td><td><a href="https://www.root.cz/clanky/ridici-struktury-vyuzitelne-v-programovacim-jazyku-clojure#k08">1/8</a></td><td>makro</td><td>typické použití makra <strong>cond</strong> s&nbsp;větví <strong>:else</strong> nebo <strong>:default</strong></td></tr>
<tr><td>15</td><td>condp</td><td><a href="https://www.root.cz/clanky/ridici-struktury-vyuzitelne-v-programovacim-jazyku-clojure#k10">1/10</a></td><td>makro</td><td>postupné dosazování testované hodnoty do zadaného výrazu, obdoba <strong>switch-case</strong></td></tr>
<tr><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td></tr>
<tr><td>16</td><td>conde</td><td><a href="#k11">2/11</a></td><td>makro</td><td>makro z&nbsp;knihovny <strong>clojure.core.logic</strong> (logické programování)</td></tr>
<tr><td>17</td><td>condu</td><td><a href="#k11">2/11</a></td><td>makro</td><td>makro z&nbsp;knihovny <strong>clojure.core.logic</strong> (logické programování)</td></tr>
<tr><td>18</td><td>conda</td><td><a href="#k11">2/11</a></td><td>makro</td><td>makro z&nbsp;knihovny <strong>clojure.core.logic</strong> (logické programování)</td></tr>
<tr><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td></tr>
<tr><td>19</td><td>cond-&gt;</td><td><a href="#k02">2/2</a></td><td>makro</td><td>odvozeno od <strong>cond</strong> a threading makra -&gt;</td></tr>
<tr><td>20</td><td>cond-&gt;&gt;</td><td><a href="#k05">2/5</a></td><td>makro</td><td>odvozeno od <strong>cond</strong> a threading makra -&gt;</td></tr>
<tr><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td></tr>
<tr><td>21</td><td>case</td><td><a href="#k07">2/7</a></td><td>makro</td><td>rozeskok na základě porovnání hodnoty výrazu s&nbsp;konstantami</td></tr>
<tr><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td></tr>
<tr><td>22</td><td>cond-table</td><td><a href="#k13">2/13</a></td><td>makro</td><td>nová nestandardní konstrukce</td></tr>
</table>

<p><div class="rs-tip-major">Poznámka: v&nbsp;ukázkách zdrojových kódů jsou
použity tyto typografické konvence:</div></p>

<pre>
<strong>součást zdrojového kódu (zapisovaná do smyčky REPL)</strong>
<strong>zvýraznění právě <u>popisovaného makra</u></strong>
výsledná hodnota popř. text vytištěný funkcemi print, println atd.
</pre>



<p><a name="k02"></a></p>
<h2 id="k02">2. Makro <strong>cond-&gt;</strong></h2>

<p>První makro s&nbsp;nímž se v&nbsp;dnešním článku setkáme a které nám
umožňuje zapsat rozvětvení na základě vyhodnocovaných podmínek, se jmenuje
<strong>cond-&gt;</strong>. Jedná se o makro ze standardní knihovny (ta je
automaticky dostupná), takže si můžeme ihned vypsat nápovědu k&nbsp;tomuto
makru:</p>

<pre>
<strong>(doc <u>cond-&gt;</u>)</strong>
-------------------------
clojure.core/cond-&gt;
([expr &amp; clauses])
Macro
  Takes an expression and a set of test/form pairs. Threads expr (via -&amp;)
  through each form for which the corresponding test
  expression is true. Note that, unlike cond branching, cond-&gt; threading does
  not short circuit after the first true test expression.
</pre>

<p>Toto na první pohled poněkud neobvyklé pojmenování nám naznačuje, že se bude
jednat o konstrukci, která je založena na takzvaném <i>threading makru</i>.
Samotné threading makro je přitom jednou z&nbsp;nejelegantnějších konstrukcí
programovacího jazyka Clojure vůbec:</p>

<pre>
<strong>(doc -&gt;)</strong>
&nbsp;
-------------------------
clojure.core/-&gt;
([x &amp; forms])
Macro
  Threads the expr through the forms. Inserts x as the
  second item in the first form, making a list of it if it is not a
  list already. If there are more forms, inserts the first form as the
  second item in second form, etc.
</pre>

<p>Toto makro nám umožňuje zapisovat sérii funkcí, mezi nimiž se předávají
parametry podobně, jako je tomu v&nbsp;klasické <i>koloně (pipe)</i>. Samotný
zápis je přitom velmi stručný a obejde se bez řady závorek, které by jinak bylo
nutné použít v&nbsp;případě NEpoužití threading makra:</p>

<pre>
<strong>(-&gt; 1</strong>
    <strong>inc</strong>
    <strong>println)</strong>
&nbsp;
2
</pre>

<p>Další jednoduchý příklad:</p>

<pre>
<strong>(-&gt; (range 1 10)</strong>
    <strong>count</strong>
    <strong>println)</strong>
&nbsp;
9
</pre>

<p>Volat je ovšem možné i funkce s&nbsp;větším množstvím parametrů, včetně
metod:</p>

<pre>
<strong>(-&gt; "Hello world."</strong>
    <strong>.toUpperCase</strong>
    <strong>(.replace "." "!")</strong>
    <strong>println)</strong>
&nbsp;
HELLO WORLD!
</pre>

<p>Popř.:</p>

<pre>
<strong>(-&gt; "Hello world."</strong>
    <strong>.toUpperCase</strong>
    <strong>(.replace "." "!")</strong>
    <strong>(.split " ")</strong>
    <strong>first</strong>
    <strong>println)</strong>
&nbsp;
HELLO
</pre>

<p>Expanze tohoto makra vede k&nbsp;zápisu s&nbsp;velkým množstvím závorek tak
typickým pro klasické LISPovské jazyky bez tohoto makra:</p>

<pre>
<strong>(macroexpand</strong>
  <strong>'(-&gt; "Hello world."</strong>
      <strong>.toUpperCase</strong>
      <strong>(.replace "." "!")</strong>
      <strong>(.split " ")</strong>
      <strong>first</strong>
      <strong>println))</strong>
</pre>

<p>S&nbsp;výsledkem:</p>

<pre>
(println (first (.split (.replace (.toUpperCase "Hello world.") "." "!") " ")))
</pre>

<p>Vraťme se však k&nbsp;makru <strong>cond-&gt;</strong>, které je odvozené od
makra <strong>cond</strong>. Jeho činnost je následující: postupně jsou
testovány jednotlivé podmínky (sudé parametry) a pokud je podmínka splněna, je
do výrazu za ní (liché parametry) dosazen první parametr makra, podobně jako je
tomu u výše zmíněného <i>threading makra</i> (tedy na první pozici ve volané
funkci či metodě).</p>

<p>V&nbsp;následujícím úryvku kódu se pokoušíme převést obsah řetězce na
číselnou hodnotu, ovšem s&nbsp;testem, zda je vstupní hodnota skutečně
řetězcem. S&nbsp;využitím makra <strong>cond-&gt;</strong> se samotné
<strong>x</strong> (tedy reference na převáděnou hodnotu) nemusí opakovat
v&nbsp;podmínce a současně i v&nbsp;převodní funkci:</p>

<pre>
<strong>(let [x "42"] </strong>
  <strong>(<u>cond-&gt;</u> x </strong>
    <strong>(string? x) (Integer.)))</strong>
&nbsp;
42
</pre>

<p>Poněkud umělý příklad, který je na makru <strong>cond-&gt;</strong>
postaven, může testovat hodnotu parametru <strong>x</strong> a následně na
základě hodnoty tohoto parametru provádí operace <strong>(inc x)</strong>,
<strong>(/ x 2)</strong> a <strong>(dec x)</strong>:</p>

<pre>
<strong>(defn machina</strong>
  <strong>[x]</strong>
  <strong>(<u>cond-&gt;</u> x </strong>
    <strong>(odd? x)  inc</strong>
    <strong>(even? x) (/ 2)</strong>
    <strong>(zero? x) dec))</strong>
</pre>

<p>Výše uvedenou funkci si otestujeme na vstupních hodnotách od nuly do
deseti:</p>

<pre>
<strong>(doseq [x (range 0 11)]</strong>
  <strong>(println x (machina x)))</strong>
</pre>

<p>S&nbsp;těmito výsledky:</p>

<pre>
0 -1
1 2
2 1
3 4
4 2
5 6
6 3
7 8
8 4
9 10
10 5
</pre>

<p><div class="rs-tip-major">Poznámka: ve skutečnosti je ve funkci logická
chyba, která se však navenek neprojeví, protože se týká vstupní hodnoty 0.
Problém spočívá v&nbsp;tom, že pro nulu platí dvě podmínky
<strong>even?</strong> i <strong>zero?</strong> &ndash; viz další
kapitolu.</div></p>



<p><a name="k03"></a></p>
<h2 id="k03">3. Vyhodnocování všech větví makrem <strong>cond-&gt;</strong></h2>

<p>Na rozdíl od makra <strong>cond</strong>, které při splnění nějaké podmínky
z&nbsp;celé sady již další podmínky netestuje, je tomu u makra
<strong>cond-&gt;</strong> odlišně, protože se postupně prochází všechny
podmínky. To může vést k&nbsp;chybám, zejména tehdy, pokud se použije větev
<strong>:else</strong> (symbol <strong>:else</strong> se totiž vždy vyhodnotí
na pravdu). Pokud tedy předchozí příklad nepatrně upravíme:</p>

<pre>
<strong>(defn machina-2</strong>
  <strong>[x]</strong>
  <strong>(<u>cond-&gt;</u> x </strong>
    <strong>(odd? x)  inc</strong>
    <strong>(even? x) (/ 2)</strong>
    <strong>:else     dec))</strong>
</pre>

<p>Získáme odlišné výsledky, což si ostatně můžeme velmi snadno ukázat:</p>

<pre>
<strong>(doseq [x (range 0 11)]</strong>
  <strong>(println x (machina x) (machina-2 x)))</strong>
</pre>

<p>Tabulka vypsaná předchozí smyčkou zobrazuje postupně vstupní hodnotu,
výpočet provedený první funkcí <strong>machina</strong> a výpočet provedený
funkcí upravenou <strong>machina-2</strong>:</p>

<pre>
0 -1 -1
1 2 1
2 1 0
3 4 3
4 2 1
5 6 5
6 3 2
7 8 7
8 4 3
9 10 9
10 5 4
</pre>

<p><div class="rs-tip-major">Poznámka: vidíme, že se výsledky odlišují o jedničku, která byla ve větvi <strong>:else</strong> odečtena od všech výsledků.</div></p>

<p>Ještě lépe je toto chování patrné v&nbsp;případě, že se v&nbsp;jednotlivých
větvích nachází funkce s&nbsp;vedlejším efektem, zde konkrétně funkce
<strong>println</strong>:</p>

<pre>
<strong>(defn machina-3</strong>
  <strong>[x]</strong>
  <strong>(<u>cond-&gt;</u> x </strong>
    <strong>(odd? x)  (println "odd")</strong>
    <strong>(even? x) (println "even")</strong>
    <strong>:else     (println "zero")))</strong>
</pre>

<p>Zkusme si tuto funkci vyvolat postupně s&nbsp;hodnotami od 0 do 10:</p>

<pre>
<strong>(doseq [x (range 0 11)]</strong>
  <strong>(println x)</strong>
  <strong>(machina-3 x)</strong>
  <strong>(println))</strong>
</pre>

<p>Z&nbsp;vypsaných výsledků je patrné, že se vždy vyhodnotí i poslední
větev:</p>

<pre>
0
0 even
nil zero
&nbsp;
1
1 odd
nil zero
&nbsp;
2
2 even
nil zero
&nbsp;
3
3 odd
nil zero
&nbsp;
4
4 even
nil zero
&nbsp;
5
5 odd
nil zero
&nbsp;
6
6 even
nil zero
&nbsp;
7
7 odd
nil zero
&nbsp;
8
8 even
nil zero
&nbsp;
9
9 odd
nil zero
&nbsp;
10
10 even
nil zero
</pre>

<p><div class="rs-tip-major">Poznámka: funkce <strong>println</strong>
v&nbsp;tomto případě ve skutečnosti vypíše i hodnotu parametru
<strong>x</strong>, který je do <strong>println</strong> dosazen jako první
parametr makrem <strong>cond-&gt;</strong>, popř.&nbsp;návratová hodnota
z&nbsp;jednotlivých větví. Proč se vždy vypisuje <strong>nil</strong> uvidíme
<a href="#k04">v&nbsp;navazující kapitole</a> po expanzi makra.</div></p>

<p>Makro <strong>cond-&gt;</strong> je tedy většinou vhodné použít pouze tehdy,
pokud se množiny hodnot, pro které podmínky platí, nepřekrývají.</p>



<p><a name="k04"></a></p>
<h2 id="k04">4. Expanze makra <strong>cond-&gt;</strong></h2>

<p>Otestovat si můžeme i expanzi makra <strong>cond-&gt;</strong>. Pro výpis
expandovaného makra opět použijeme známou funkci <strong>macroexpand</strong>
ze standardní knihovny programovacího jazyka Clojure:</p>

<pre>
<strong>(macroexpand</strong>
  <strong>'(<u>cond-&gt;</u> x </strong>
     <strong>(odd? x)  inc</strong>
     <strong>(even? x) (/ 2)</strong>
     <strong>(zero? x) inc))</strong>
</pre>

<p>Výsledkem by měl být následující kód (pomocná automaticky vygenerovaná
proměnná může mít ovšem odlišné jméno):</p>

<pre>
(let* [G__10086 x
       G__10086 (if (odd? x)  (clojure.core/-&gt; G__10086 inc) G__10086)
       G__10086 (if (even? x) (clojure.core/-&gt; G__10086 (/ 2)) G__10086)]
  (if (zero? x) (clojure.core/-&gt; G__10086 inc) G__10086))
</pre>

<p><div class="rs-tip-major">Poznámka: povšimněte si, že se skutečně postupně
vyhodnocují všechny větve a současně se interně používá threading makro
<strong>-&gt;</strong>. Navíc se postupně přepisují hodnoty předávané do větví
(lokální symbol <strong>G__10086</strong>), což <a href="#k03">v&nbsp;předchozí
kapitole</a> vedlo k&nbsp;výpisu hodnot <strong>nil</strong> &ndash;
návratových hodnot funkce <strong>println</strong>!</div></p>

<p>Příklad expanze ne plně funkčního kódu s&nbsp;větví
<strong>else</strong>:</p>

<pre>
<strong>(macroexpand</strong>
  <strong>'(<u>cond-&gt;</u> x </strong>
     <strong>(odd? x)  inc</strong>
     <strong>(even? x) (/ 2)</strong>
     <strong>:else     inc))</strong>
</pre>

<p>Nyní bude expanze vypadat následovně:</p>

<pre>
(let* [G__10117 x
       G__10117 (if (odd? x) (clojure.core/-&gt; G__10117 inc) G__10117)
       G__10117 (if (even? x) (clojure.core/-&gt; G__10117 (/ 2)) G__10117)]
  (if :else (clojure.core/-&gt; G__10117 inc) G__10117))
</pre>

<p>Extrémní příklad, v&nbsp;němž se provedou všechny větve a současně se
mezivýsledek pětkrát zvětší o jedničku:</p>

<pre>
<strong>(<u>cond-&gt;</u> 1</strong>
  <strong>:foo     inc</strong>
  <strong>:bar     inc</strong>
  <strong>:baz     inc</strong>
  <strong>:else    inc</strong>
  <strong>:default inc)</strong>
&nbsp;
6
</pre>

<p>Bude expandován takto:</p>

<pre>
<strong>(macroexpand</strong>
  <strong>'(<u>cond-&gt;</u> 1</strong>
    <strong>:foo     inc</strong>
    <strong>:bar     inc</strong>
    <strong>:baz     inc</strong>
    <strong>:else    inc</strong>
    <strong>:default inc))</strong>
&nbsp;
(let*
  [G__11216 1
   G__11216 (if :foo (clojure.core/-&gt; G__11216 inc) G__11216)
   G__11216 (if :bar (clojure.core/-&gt; G__11216 inc) G__11216)
   G__11216 (if :baz (clojure.core/-&gt; G__11216 inc) G__11216)
   G__11216 (if :else (clojure.core/-&gt; G__11216 inc) G__11216)]
  (if :default (clojure.core/-&gt; G__11216 inc) G__11216))
</pre>

<p><div class="rs-tip-major">Poznámka: opět je patrné postupné přepisování,
resp.&nbsp;přesněji řečeno redefinice lokálního symbolu
<strong>G__11216</strong>.</div></p>



<p><a name="k05"></a></p>
<h2 id="k05">5. Makro <strong>cond-&gt;&gt;</strong></h2>

<p>Druhé dnes popisované makro určené pro implementaci rozvětvení na základě
zadaných podmínek se jmenuje <strong>cond-&gt;&gt;</strong>:</p>

<pre>
<strong>(doc <u>cond-&gt;&gt;</u>)</strong>
&nbsp;
-------------------------
clojure.core/cond-&gt;&gt;
([expr &amp; clauses])
Macro
  Takes an expression and a set of test/form pairs. Threads expr (via -&gt;&gt;)
  through each form for which the corresponding test expression
  is true.  Note that, unlike cond branching, cond-&gt;&gt; threading does not short circuit
  after the first true test expression.
</pre>

<p>Opět se jedná o variantu makra <strong>cond</strong>, tentokrát ovšem
zkombinovanou s&nbsp;alternativní formou threading makra
<strong>-&gt;&gt;</strong>:</p>

<pre>
<strong>(doc -&gt;&gt;)</strong>
&nbsp;
-------------------------
clojure.core/-&gt;&gt;
([x &amp; forms])
Macro
  Threads the expr through the forms. Inserts x as the
  last item in the first form, making a list of it if it is not a
  list already. If there are more forms, inserts the first form as the
  last item in second form, etc.
</pre>

<p><div class="rs-tip-major">Poznámka: makro -&gt;&gt; dosazuje výsledek
předchozí formy do posledního parametru následující formy:</div></p>

<pre>
<strong>(-&gt;&gt; (range 1 11)</strong>
   <strong>(filter even?))</strong>
&nbsp;
(2 4 6 8 10)
</pre>

<p>Součet všech sudých čísel vybraných z&nbsp;řady 0..10:</p>

<pre>
<strong>(-&gt;&gt; (range 1 11)</strong>
  <strong>(filter even?)</strong>
  <strong>(reduce +))</strong>
&nbsp;
30
</pre>

<p>Vraťme se k&nbsp;makru <strong>cond-&gt;&gt;</strong>. Na rozdíl od výše
popsaného makra <strong>cond-&gt;</strong> se liší dosazování parametru do
jednotlivých větví &ndash; parametr je dosazen na <i>poslední</i> místo výrazu
ve větvi (ta je typicky představována voláním nějaké funkce) a nikoli na místo
první. Pokud tedy například použijeme tuto funkci:</p>

<pre>
<strong>(defn machina-3</strong>
  <strong>[x]</strong>
  <strong>(<u>cond-&gt;&gt;</u> x </strong>
    <strong>(odd? x)  inc</strong>
    <strong>(even? x) (/ 2)))</strong>
</pre>

<p>bude se ve druhé větvi vyhodnocovat funkce <strong>(/ 2 x)</strong> a nikoli
<strong>(/ x 2)</strong>.</p>

<p>Výše definovanou funkci <strong>machina-3</strong> si otestujeme na
vstupních hodnotách od nuly do deseti:</p>

<pre>
<strong>(doseq [x (range 1 11)]</strong>
  <strong>(println x (machina-3 x)))</strong>
</pre>

<p>S&nbsp;výsledkem:</p>

<pre>
1 2
2 1
3 4
4 1/2
5 6
6 1/3
7 8
8 1/4
9 10
10 1/5
</pre>

<p><div class="rs-tip-major">Poznámka: jen na okraj &ndash; povšimněte si, že
programovací jazyk Clojure plně podporuje zlomky, tj.&nbsp;datový typ
<i>rational</i>.</div></p>

<p>Nepatrně složitější příklad, který se snaží převést parametr na celé
číslo:</p>

<pre>
<strong>(defn -&gt;int</strong>
  <strong>[x]</strong>
  <strong>(<u>cond-&gt;&gt;</u> x </strong>
    <strong>(string? x)   Integer.</strong>
    <strong>(float?  x)   int</strong>
    <strong>(rational? x) int</strong>
    <strong>(integer? x)  identity))</strong>
</pre>

<p>Chování této funkce si můžeme snadno otestovat:</p>

<pre>
<strong>(println (-&gt;int 3.14))</strong>
3
&nbsp;
<strong>(println (-&gt;int 10/3))</strong>
3
&nbsp;
<strong>(println (-&gt;int 42))</strong>
42
&nbsp;
<strong>(println (-&gt;int "1000"))</strong>
1000
</pre>



<p><a name="k06"></a></p>
<h2 id="k06">6. Expanze makra <strong>cond-&gt;&gt;</strong></h2>

<p>Způsob expanze makra <strong>cond-&gt;&gt;</strong> si ukážeme na příkladu
převodníku hodnoty typu řetězec, čísla s&nbsp;plovoucí řádovou čárkou, zlomku
či celého čísla na hodnotu typu <i>integer</i> (tedy celé číslo). Expanzi si
opět zobrazíme standardní funkcí <strong>macroexpand</strong>
popř.&nbsp;<strong>macroexpand-1</strong>:</p>

<pre>
<strong>(macroexpand</strong>
  <strong>'(<u>cond-&gt;&gt;</u> x </strong>
    <strong>(string? x)   Integer.</strong>
    <strong>(float?  x)   int</strong>
    <strong>(rational? x) int</strong>
    <strong>(integer? x)  identity))</strong>
</pre>

<p>Výsledek expanze by měl v&nbsp;tomto případě vypadat následovně:</p>

<pre>
(let*
  [G__10237 x
   G__10237 (if (string? x) (clojure.core/-&gt;&gt; G__10237 Integer.) G__10237)
   G__10237 (if (float? x) (clojure.core/-&gt;&gt; G__10237 int) G__10237)
   G__10237 (if (rational? x) (clojure.core/-&gt;&gt; G__10237 int) G__10237)]
  (if (integer? x) (clojure.core/-&gt;&gt; G__10237 identity) G__10237))
</pre>

<p><div class="rs-tip-major">Poznámka: povšimněte si, že se skutečně jednotlivá
přiřazení provádí bez ohledu na to, zda byl předchozí test úspěšný nebo
neúspěšný. To je největší rozdíl maker <strong>cond-&gt;</strong> a
<strong>cond-&gt;&gt;</strong> oproti makru <strong>cond</strong>.</div></p>



<p><a name="k07"></a></p>
<h2 id="k07">7. Jedno z&nbsp;nejsložitějších maker ze standardní knihovny: <strong>case</strong></h2>

<p>Interně nejsložitější makro ze standardní knihovny, které si dnes popíšeme,
se jmenuje <strong>case</strong>:</p>

<pre>
<strong>(doc <u>case</u>)</strong>
&nbsp;
-------------------------
clojure.core/case
([e &amp; clauses])
Macro
  Takes an expression, and a set of clauses.
&nbsp;
  Each clause can take the form of either:
&nbsp;
  test-constant result-expr
&nbsp;
  (test-constant1 ... test-constantN)  result-expr
&nbsp;
  The test-constants are not evaluated. They must be compile-time
  literals, and need not be quoted.  If the expression is equal to a
  test-constant, the corresponding result-expr is returned. A single
  default expression can follow the clauses, and its value will be
  returned if no clause matches. If no default expression is provided
  and no clause matches, an IllegalArgumentException is thrown.
&nbsp;
  Unlike cond and condp, case does a constant-time dispatch, the
  clauses are not considered sequentially.  All manner of constant
  expressions are acceptable in case, including numbers, strings,
  symbols, keywords, and (Clojure) composites thereof. Note that since
  lists are used to group multiple constants that map to the same
  expression, a vector can be used to match a list if needed. The
  test-constants need not be all of the same type.
</pre>

<p>Toto makro se do značné míry podobá céčkové či javovské konstrukci
<strong>switch</strong>, protože výsledek zadaného výrazu je porovnáván
s&nbsp;konstantami zapsanými před jednotlivými větvemi. To sice není tak obecné
řešení, jako je tomu v&nbsp;případě maker <strong>cond</strong> a
<strong>condp</strong>, ovšem výsledkem by měl být rychlejší běh, protože se
interně zkonstruuje mapa s&nbsp;jednotlivými větvemi a výběr větve je tak
proveden v&nbsp;téměř konstantním čase a nikoli postupným porovnáváním. Navíc
existuje speciální režim expanze pro celočíselné hodnoty.</p>

<p><div class="rs-tip-major">Poznámka: v&nbsp;předchozím odstavci bylo napsáno
&bdquo;téměř konstantní čas&ldquo;. Ve skutečnosti záleží na tom, jak je
v&nbsp;daném virtuálním stroji Javy (JVM) realizována instrukce bajtkódu
<strong>tableswitch</strong>.</div></p>

<p>Podívejme se nyní na jednotlivé způsoby použití makra <strong>case</strong>
pro vytvoření rozhodovací konstrukce. Nejprve převod celočíselných hodnot na
řetězce (což by ovšem bylo rozumnější implementovat přes mapy!):</p>

<pre>
<strong>(defn say-number</strong>
  <strong>[x]</strong>
  <strong>(<u>case x</u></strong>
    <strong>0 "nula"</strong>
    <strong>1 "jedna"</strong>
    <strong>2 "dva"))</strong>
</pre>

<p>Otestování funkce <strong>say-number</strong>:</p>

<pre>
<strong>(println (say-number 0))</strong>
nula
&nbsp;
<strong>(println (say-number 1))</strong>
jedna
&nbsp;
<strong>(println (say-number 2))</strong>
dva
</pre>

<p>Prozatím ovšem nemáme nijak zajištěnu funkčnost ve chvíli, kdy se předá
hodnota neodpovídající žádné větvi:</p>

<pre>
<strong>(println (say-number 3))</strong>
&nbsp;
Execution error (IllegalArgumentException) at user/say-number (REPL:3).
No matching clause: 3
</pre>

<p>To lze ovšem velmi snadno napravit uvedením takzvané <i>default</i> větve,
resp.&nbsp;<i>default výrazu</i> (bez konstanty):</p>

<pre>
<strong>(defn say-number</strong>
  <strong>[x]</strong>
  <strong>(<u>case</u> x</strong>
    <strong>0 "nula"</strong>
    <strong>1 "jedna"</strong>
    <strong>2 "dva"</strong>
      <strong>"nezname cislo"))</strong>
</pre>

<p>Otestování nové podoby funkce <strong>say-number</strong>:</p>

<pre>
<strong>(println (say-number 0))</strong>
nula
&nbsp;
<strong>(println (say-number 1))</strong>
jedna
&nbsp;
<strong>(println (say-number 2))</strong>
dva
&nbsp;
<strong>(println (say-number 3))</strong>
nezname cislo
</pre>

<p>Nejsme ovšem v&nbsp;žádném případě omezeni pouze na celočíselné
konstanty</p>

<pre>
<strong>(defn string-&gt;number</strong>
  <strong>[x]</strong>
  <strong>(<u>case</u> x</strong>
    <strong>"nula"  0</strong>
    <strong>"jedna" 1</strong>
    <strong>"dva"   2</strong>
            <strong>-1))</strong>
</pre>

<p>Následuje otestování funkce <strong>string-&gt;number</strong>:</p>

<pre>
<strong>(println (string-&gt;number "nula"))</strong>
0
&nbsp;
<strong>(println (string-&gt;number "jedna"))</strong>
1
&nbsp;
<strong>(println (string-&gt;number "milion"))</strong>
-1
</pre>



<p><a name="k08"></a></p>
<h2 id="k08">8. Větší množství konstant u jednotlivých větví v&nbsp;makru <strong>case</strong></h2>

<p>Jednu větev je možné provést (resp.&nbsp;přesněji řečeno vyhodnotit) pro
více konstant, které ovšem musí být v&nbsp;tomto případě umístěny do
závorek:</p>

<pre>
<strong>(defn string-&gt;number</strong>
  <strong>[x]</strong>
  <strong>(<u>case</u> x</strong>
    <strong>("nic" "nula")  0</strong>
    <strong>"jedna"         1</strong>
    <strong>("dva" "dve")   2</strong>
                   <strong>-1))</strong>
</pre>

<p><div class="rs-tip-major">Poznámka: v&nbsp;Clojure obecně platí, že kulaté
závorky znamenají vyhodnocení formy (zavolání funkce atd.), což ovšem nemusí
platit u maker &ndash; a je tomu tak i v&nbsp;případě makra
<strong>case</strong>.</div></p>

<p>Otestování předchozí funkce:</p>

<pre>
<strong>(println (string-&gt;number "nula"))</strong>
0
&nbsp;
<strong>(println (string-&gt;number "dva"))</strong>
2
&nbsp;
<strong>(println (string-&gt;number "dve"))</strong>
2
</pre>

<p>Konstantami mohou být v&nbsp;případě potřeby i vektory, mapy atd.</p>

<pre>
<strong>(defn say-vector</strong>
  <strong>[x]</strong>
  <strong>(<u>case x</u></strong>
    <strong>[]    "Empty vector"</strong>
    <strong>[1]   "Vector with just one item"</strong>
    <strong>[1 2] "Sequence of two numbers 1 and 2"</strong>
          <strong>"I don't know"))</strong>
</pre>

<p>Vyzkoušení funkce <strong>say-vector</strong>:</p>

<pre>
<strong>(say-vector [])</strong>
"Empty vector"
&nbsp;
<strong>(say-vector [1 2])</strong>
"Sequence of two numbers 1 and 2"
</pre>



<p><a name="k09"></a></p>
<h2 id="k09">9. Kdy použít <strong>cond</strong>, <strong>condp</strong> a <strong>case</strong>?</h2>

<p>Nyní již známe celou trojici standardních maker pro rozeskoky &ndash;
<strong>cond</strong>, <strong>condp</strong> a <strong>case</strong>. Makro
<strong>cond</strong> je nejobecnější, protože každá podmínka může být zadána
samostatným výrazem. Ovšem za tuto univerzálnost platíme menší čitelností.
Pokud je nutné testy implementovat podobnými výrazy, je výhodnější použít
<strong>condp</strong> a v&nbsp;případě, že se porovnává výsledek nějakého
výrazu s&nbsp;konstantami, doporučuje se použít <strong>case</strong>, viz též
<a href="https://github.com/bbatsov/clojure-style-guide#case">Clojure Style
Guide</a>.</p>

<p>Makro <strong>cond</strong> je sice nejuniverzálnější, ale taktéž delší na
zápis a i výpočetně složité:</p>

<pre>
<strong>(<u>cond</u></strong>
  <strong>(= x 0) "Nula"</strong>
  <strong>(= x 1) "Jedna"</strong>
  <strong>(= x 2) "Dva"</strong>
  <strong>:else   "Nevim")</strong>
</pre>

<p>Makro <strong>condp</strong> umožňuje kratší zápis podmínky na jediném místě
(první parametry makra):</p>

<pre>
<strong>(<u>condp</u> = x</strong>
  <strong>0 "Nula"</strong>
  <strong>1 "Jedna"</strong>
  <strong>2 "Dva"</strong>
    <strong>"Nevim")</strong>
</pre>

<p>Nejméně univerzální je makro <strong>case</strong>, ovšem na druhou stranu
je nejrychlejší:</p>

<pre>
<strong>(<u>case</u> x</strong>
  <strong>0 "Nula"</strong>
  <strong>1 "Jedna"</strong>
  <strong>2 "Dva"</strong>
    <strong>"Nevim")</strong>
</pre>

<p>Rychlejší rozeskoky v&nbsp;případě použití makra <strong>case</strong> by
mělo být možné i naměřit, pochopitelně ovšem za předpokladu, že důvěřujete
mikrobenchmarkům (což je zrovna v&nbsp;případě JVM dosti problematické):</p>

<pre>
<strong>(defn f1</strong>
  <strong>[x]</strong>
  <strong>(cond</strong>
    <strong>(= x 0) "Nula"</strong>
    <strong>(= x 1) "Jedna"</strong>
    <strong>(= x 2) "Dva"</strong>
    <strong>:else   "Nevim"))</strong>
&nbsp;
<strong>(defn f2</strong>
  <strong>[x]</strong>
  <strong>(condp = x</strong>
    <strong>0 "Nula"</strong>
    <strong>1 "Jedna"</strong>
    <strong>2 "Dva"</strong>
      <strong>"Nevim"))</strong>
&nbsp;
<strong>(defn f3</strong>
  <strong>[x]</strong>
  <strong>(case x</strong>
    <strong>0 "Nula"</strong>
    <strong>1 "Jedna"</strong>
    <strong>2 "Dva"</strong>
      <strong>"Nevim"))</strong>
&nbsp;
<strong>(time (doseq [_ (range 100000000)]</strong>
        <strong>(doseq [x (range 0 4)]</strong>
          <strong>(f1 x))))</strong>
"Elapsed time: 4252.930607 msecs"
&nbsp;
<strong>(time (doseq [_ (range 100000000)]</strong>
        <strong>(doseq [x (range 0 4)]</strong>
          <strong>(f2 x))))</strong>
"Elapsed time: 4417.662463 msecs"
&nbsp;
<strong>(time (doseq [_ (range 100000000)]</strong>
        <strong>(doseq [x (range 0 4)]</strong>
          <strong>(f3 x))))</strong>
"Elapsed time: 3924.937731 msecs"
</pre>

<p><div class="rs-tip-major">Poznámka: na druhou stranu je vhodné poznamenat,
že u programovacího jazyka typu Clojure (dynamicky typovaný vysokoúrovňový
jazyk běžící nad JVM) je většinou mnohem důležitější sémantika zapisovaných
operací (tj. i zde má makro <strong>case</strong> význam) nad ušetřeným
strojovým časem.</div></p>



<p><a name="k10"></a></p>
<h2 id="k10">10. Expanze makra <strong>case</strong> a forma vygenerovaného bajtkódu</h2>

<p>V&nbsp;krátkosti se ještě zmiňme o způsobu expanze makra
<strong>case</strong>. Ta se v&nbsp;jednom ohledu odlišuje od expanze ostatních
maker, a to konkrétně v&nbsp;tom směru, že výsledkem expanze není kód založený
na speciální formě <strong>if</strong>. Namísto toho se v&nbsp;expanzi setkáme
s&nbsp;<strong>case*</strong>, což je metoda implementovaná v&nbsp;Javě, která
slouží ke konstrukci rozeskoku na úrovni bajtkódu (viz též <a
href="https://github.com/clojure/clojure/blob/master/src/jvm/clojure/lang/Compiler.java#L63">zdrojové
kódy samotného Clojure</a>). Ostatně se o tom můžeme velmi snadno
přesvědčit:</p>

<pre>
<strong>(macroexpand</strong>
  <strong>'(<u>case</u> x</strong>
    <strong>0 "Nula"</strong>
    <strong>1 "Jedna"</strong>
    <strong>2 "Dva"</strong>
      <strong>"Nevim"))</strong>
&nbsp;
(let*
 [G__11190 x]
 (case*
  G__11190
  0
  0
  "Nevim"
  {0 [0 "Nula"] 1 [1 "Jedna"] 2 [2 "Dva"]}
  :compact
  :int))
</pre>

<p>Abychom pochopili, jak celá technologie pracuje, musíme si připomenout, že
Clojure pracuje tak, že každou zapsanou formu přeloží (po expanzi maker) do
bajtkódu JVM a teprve poté je tato forma spuštěna. A právě pro překlad do
bajtkódu se interně používá třída <strong>Compiler</strong>, která konkrétně
interní symbol <strong>case*</strong> přeloží s&nbsp;využitím instrukce
<strong>tableswitch</strong> určené pro implementaci konstrukce
<strong>switch</strong> známé z&nbsp;Javy (resp.&nbsp;přesněji
<strong>switch</strong> v&nbsp;případě, že jsou použita celá čísla nebo výčtový
typ, nikoli řetězce). Touto problematikou jsme se již zabývali v&nbsp;článcích
<a
href="https://www.root.cz/clanky/pohled-pod-kapotu-jvm-9-cast-tajemstvi-instrukci-lookupswitch-a-tableswitch/#k04">https://www.root.cz/clanky/pohled-pod-kapotu-jvm-9-cast-tajemstvi-instrukci-lookupswitch-a-tableswitch/#k04</a>
a <a
href="https://www.root.cz/clanky/pohled-pod-kapotu-jvm-9-cast-tajemstvi-instrukci-lookupswitch-a-tableswitch/#k07">https://www.root.cz/clanky/pohled-pod-kapotu-jvm-9-cast-tajemstvi-instrukci-lookupswitch-a-tableswitch/#k07</a>.</p>

<p>V&nbsp;praxi vypadá překlad funkce <strong>f3</strong>:</p>

<pre>
<strong>(defn f3</strong>
  <strong>[x]</strong>
  <strong>(<u>case</u> x</strong>
    <strong>0 "Nula"</strong>
    <strong>1 "Jedna"</strong>
    <strong>2 "Dva"</strong>
      <strong>"Nevim"))</strong>
</pre>

<p>následovně (zvýrazněna je instrukce <strong>tableswitch</strong>:</p>

<pre>
public static java.lang.Object invokeStatic(java.lang.Object x);
   0  aload_0 [x]
   1  aconst_null
   2  astore_0 [x]
   3  astore_1 [G__5991]
   4  aload_1 [G__5991]
   5  instanceof java.lang.Number [13]
   8  ifeq 89
  11  aload_1 [G__5991]
  12  checkcast java.lang.Number [13]
  15  invokevirtual java.lang.Number.intValue() : int [17]
  18  <strong>tableswitch default: 89</strong>
        <strong>case 0: 44</strong>
        <strong>case 1: 59</strong>
        <strong>case 2: 74</strong>
  44  aload_1 [G__5991]
  45  getstatic user$f3.const__0 : java.lang.Object [21]
  48  invokestatic clojure.lang.Util.equiv(java.lang.Object, java.lang.Object) : boolean [27]
  51  ifeq 89
  54  ldc &lt;String "Nula"&gt; [29]
  56  goto 91
  59  aload_1 [G__5991]
  60  getstatic user$f3.const__1 : java.lang.Object [32]
  63  invokestatic clojure.lang.Util.equiv(java.lang.Object, java.lang.Object) : boolean [27]
  66  ifeq 89
  69  ldc &lt;String "Jedna"&gt; [34]
  71  goto 91
  74  aload_1 [G__5991]
  75  getstatic user$f3.const__2 : java.lang.Object [37]
  78  invokestatic clojure.lang.Util.equiv(java.lang.Object, java.lang.Object) : boolean [27]
  81  ifeq 89
  84  ldc &lt;String "Dva"&gt; [39]
  86  goto 91
  89  ldc &lt;String "Nevim"&gt; [41]
  91  areturn
</pre>

<p><div class="rs-tip-major">Poznámka: pro získání bajtkódu lze použít buď
nástroj <strong>javap</strong> dodávaný společně s&nbsp;JVM, nebo &ndash; což
je jednodušší &ndash; knihovnu nazvanou <strong>no.disassemble</strong>, která
je dostupná na adrese <a
href="https://github.com/gtrak/no.disassemble">https://github.com/gtrak/no.disassemble</a>.
Popis této knihovny přesahuje rozsah dnešního článku, ovšem zmíníme se o ní
později v&nbsp;samostatném textu.</div></p>



<p><a name="k11"></a></p>
<h2 id="k11">11. Makra ze jmenného prostoru clojure.core.logic</h2>

<p>V&nbsp;této kapitole se ve stručnosti zmíníme o makrech, která jsou
definována ve jmenném prostoru <strong>clojure.core.logic</strong>.
V&nbsp;tomto jmenném prostoru nalezneme knihovnu, která do programovacího
jazyka Clojure přináší konstrukce známé z&nbsp;Prologu, které byly popsány
například v&nbsp;The Reasoned Schemer (viz též: <i>The Reasoned Schemer, Second
Edition</i>: <a
href="https://mitpress.mit.edu/books/reasoned-schemer-second-edition">https://mitpress.mit.edu/books/reasoned-schemer-second-edition</a>).
Načtení funkcí, maker a dalších symbolů z&nbsp;tohoto jmenného prostoru si
musíme explicitně vyžádat, například použitím <strong>require</strong> či
<strong>use</strong>:</p>

<pre>
<strong>(use 'clojure.core.logic)</strong>
</pre>

<p>Mezi makra, která se zde používají pro vyhodnocení podmínek, patří
<strong>condu</strong>, <strong>conda</strong> a <strong>conde</strong>. Jejich
podrobnějším popisem se budeme zabývat v&nbsp;samostatném článku o logickém
programování v&nbsp;Clojure.</p>



<p><a name="k12"></a></p>
<h2 id="k12">12. Od &bdquo;jednorozměrných&ldquo; rozhodovacích konstrukcí ke konstrukcím dvourozměrným</h2>

<p>Existuje poměrně mnoho algoritmů postavených na takzvaných <i>rozhodovacích
tabulkách</i>. Tyto tabulky mají podobu skutečných tabulek, v&nbsp;nichž se
v&nbsp;hlavičkách sloupců i řádků zapisují podmínky a do buněk tabulky pak
vypočtená hodnota popř.&nbsp;akce, která se má provést (tedy volání nějaké
funkce). V&nbsp;běžných programovacích jazycích většinou nelze tyto rozhodovací
tabulky zapisovat přímo, takže se setkáme buď s&nbsp;využitím map
(popř.&nbsp;map obsahujících další mapy), vnořených konstrukcí
<strong>switch</strong> apod. To ovšem není ani přehledné ani to neodpovídá
implementovanému algoritmu (rozhodovací tabulka totiž může být součástí
zadání). V&nbsp;programovacím jazyku Clojure však díky jeho makrosystému a
homoikonicitě existuje minimálně jedno elegantní řešení, a to konkrétně ve
formě makra nazvaného příznačně <strong>cond-table</strong>, jehož autorem je
<a href="https://github.com/semperos">Daniel Gregoire</a>.</p>

<p>Pokud je například nutné implementovat tabulku, která na základě dvou dvojic
predikátů určí, která další funkce se má zavolat:</p>

<pre>
+------------++--------------+------------+
|            || in-progress? | final-run? |
+------------++--------------+------------+
| succeeded? || succeed      | succeed    |
|    failed? || retry        | terminate  |
+------------++--------------+------------+
</pre>

<p>Je možné tuto rozhodovací tabulku zapsat do zdrojového kódu zcela přímočarým
způsobem:</p>

<pre>
<strong>(<u>cond-table</u></strong>
  <strong>:|             in-progress?   final-run?</strong>
  <strong>:| succeeded?  (succeed)      (succeed)</strong>
  <strong>:|    failed?  (retry)        (terminate))</strong>
</pre>

<p>Taktéž někdy můžeme chtít pouze vrátit určitou hodnotu na základě podmínek a
nevolat žádné funkce:</p>

<pre>
+------------++-----------------+----------------+--------------------+
|            || operace=login   | operace=logout | operace=index-page |
+------------++-----------------+----------------+--------------------+
| status=200 || :index-page     | :logout-page   | :index-page        |
| status=401 || :not-authorized | :invalid-state | :invalid-state     |
| status=404 || :not-found      | :not-found     | :not-found)        |
+------------++-----------------+----------------+--------------------+
</pre>

<p>I tuto tabulku lze do zdrojového kódu zapsat přímočaře:</p>

<pre>
<strong>(<u>cond-table</u></strong>
    <strong>:|                   (= oper :login)   (= oper :logout)  (= oper :index-page)</strong>
    <strong>:|   (= status 200)  :index-page       :logout-page      :index-page</strong>
    <strong>:|   (= status 401)  :not-authorized   :invalid-state    :invalid-state</strong>
    <strong>:|   (= status 404)  :not-found        :not-found        :not-found)</strong>
</pre>

<p><div class="rs-tip-major">Poznámka: v&nbsp;mnoha případech vede zařazení
tohoto makra k&nbsp;výraznému zjednodušení i zpřehlednění výsledného
kódu.</div></p>



<p><a name="k13"></a></p>
<h2 id="k13">13. Makro <strong>cond-table</strong></h2>

<p>Makro <strong>cond-table</strong> sice není příliš rozsáhlé, ovšem je
strukturováno velmi zajímavě. Nejdříve je (v&nbsp;expandovaném kódu)
zkontrolována tabulka zapsaná programátorem a následně se z&nbsp;této tabulky
sestaví sekvence forem <strong>cond</strong> (a ty jsou v&nbsp;další expanzi
převedeny na speciální formu <strong>if</strong>). Úplný zdrojový kód tohoto
makra vypadá následovně:</p>

<pre>
(defmacro <strong>cond-table</strong>
  <i>"Produce a `cond` expression from a tabular representation of its clauses".</i>
&nbsp;
  [&amp; items]
  (let [rows (validate-cond-table items)
        rights (first rows)  ;; get right-hand conditions
        rights (if (and (symbol? (first rights))
                        (every? (partial = \_) (name (first rights))))
                 (next rights)
                 rights)
        op-omitted? (= (count (second rows))
                       (inc (count rights)))
        [op rights] (if op-omitted?
                      ['and rights]
                      [(first rights) (next rights)])]
    (cons 'cond
          (mapcat
           (fn [[left-condition &amp; exprs :as row]]
             (mapcat
              (fn [right-condition expr]
                <i>;; `cond` test/expr pair:</i>
                (list (list op left-condition right-condition) expr))
              rights exprs))
           (next rows)))))
</pre>

<p>Při expanzi makra se ve výsledném kódu nejdříve provede kontrola (nebo
řekněme validace) zapsané tabulky. To zajišťuje pomocná funkce nazvaná
příznačně <strong>validate-cond-table</strong>:</p>

<pre>
(defn <strong>validate-cond-table</strong>
  <i>"Validate the arguments passed to the `cond-table` macro and return</i>
  <i>the data of the table rows."</i>
  [items]
  (let [rs (into []
                 (comp (partition-by (partial = :|))
                       (partition-all 2))
                 items)
        _ (when-not (every? #(= '(:|) (first %)) rs)
            (throw (IllegalArgumentException. "Each row in cond-table must begin with the keyword :|")))
        rows (map second rs) ;; remove :| syntax
        header-count (count (first rows))
        next-row-counts (into #{} (map count) (next rows))
        next-rows-same-count? (= 1 (count next-row-counts))
        <i>;; First row with blank first cell, for default `and` behavior</i>
        default-header-validates? (= (inc header-count) (first next-row-counts))
        <i>;; First row with custom op in first cell</i>
        op-header-validates? (= header-count (first next-row-counts))
        <i>;; All rows after the first must be same length and first row is either</i>
        <i>;; the same length (because a custom op was supplied) or has one item</i>
        <i>;; fewer (default of `and` is being leveraged).</i>
        _ (when-not (and next-rows-same-count?
                         (or default-header-validates?
                             op-header-validates?))
            (throw (IllegalArgumentException. "Every row after the first in cond-table must start with a predicate and include an expression for each cell in the table.")))]
    rows))
</pre>



<p><a name="k14"></a></p>
<h2 id="k14">14. Příklady použití makra <strong>cond-table</strong></h2>

<p></p>



<p><a name="k15"></a></p>
<h2 id="k15">15. </h2>



<p><a name="k16"></a></p>
<h2 id="k16">16. </h2>



<p><a name="k17"></a></p>
<h2 id="k17">17. Příloha: zdrojové kódy výše popsaných maker</h2>

<p>V&nbsp;této příloze jsou vypsány podoby všech výše popsaných maker ze
standardní knihovny programovacího jazyka Clojure. Tyto kódy jsou velmi dobrým
studijním materiálem pro tvorbu vlastních maker:</p>

<pre>
<strong>(source <u>if-not</u>)</strong>
&nbsp;
(defmacro if-not
  "Evaluates test. If logical false, evaluates and returns then expr, 
  otherwise else expr, if supplied, else nil."
  {:added "1.0"}
  ([test then] `(if-not ~test ~then nil))
  ([test then else]
   `(if (not ~test) ~then ~else)))
</pre>

<pre>
<strong>(source <u>if-let</u>)</strong>
&nbsp;
(defmacro if-let
  "bindings =&gt; binding-form test
&nbsp;
  If test is true, evaluates then with binding-form bound to the value of 
  test, if not, yields else"
  {:added "1.0"}
  ([bindings then]
   `(if-let ~bindings ~then nil))
  ([bindings then else &amp; oldform]
   (assert-args
     (vector? bindings) "a vector for its binding"
     (nil? oldform) "1 or 2 forms after binding vector"
     (= 2 (count bindings)) "exactly 2 forms in binding vector")
   (let [form (bindings 0) tst (bindings 1)]
     `(let [temp# ~tst]
        (if temp#
          (let [~form temp#]
            ~then)
          ~else)))))
</pre>

<pre>
<strong>(source <u>if-some</u>)</strong>
&nbsp;
(defmacro if-some
  "bindings =&gt; binding-form test
&nbsp;
   If test is not nil, evaluates then with binding-form bound to the
   value of test, if not, yields else"
  {:added "1.6"}
  ([bindings then]
   `(if-some ~bindings ~then nil))
  ([bindings then else &amp; oldform]
   (assert-args
     (vector? bindings) "a vector for its binding"
     (nil? oldform) "1 or 2 forms after binding vector"
     (= 2 (count bindings)) "exactly 2 forms in binding vector")
   (let [form (bindings 0) tst (bindings 1)]
     `(let [temp# ~tst]
        (if (nil? temp#)
          ~else
          (let [~form temp#]
            ~then))))))
</pre>

<pre>
<strong>(source <u>and</u>)</strong>
&nbsp;
(defmacro and
  "Evaluates exprs one at a time, from left to right. If a form
  returns logical false (nil or false), and returns that value and
  doesn't evaluate any of the other expressions, otherwise it returns
  the value of the last expr. (and) returns true."
  {:added "1.0"}
  ([] true)
  ([x] x)
  ([x &amp; next]
   `(let [and# ~x]
      (if and# (and ~@next) and#))))
</pre>

<pre>
<strong>(source <u>or</u>)</strong>
&nbsp;
(defmacro or
  "Evaluates exprs one at a time, from left to right. If a form
  returns a logical true value, or returns that value and doesn't
  evaluate any of the other expressions, otherwise it returns the
  value of the last expression. (or) returns nil."
  {:added "1.0"}
  ([] nil)
  ([x] x)
  ([x &amp; next]
      `(let [or# ~x]
         (if or# or# (or ~@next)))))
</pre>

<pre>
<strong>(source <u>when</u>)</strong>
&nbsp;
(defmacro when
  "Evaluates test. If logical true, evaluates body in an implicit do."
  {:added "1.0"}
  [test &amp; body]
  (list 'if test (cons 'do body)))
</pre>

<pre>
<strong>(source <u>when-not</u>)</strong>
&nbsp;
(defmacro when-not
  "Evaluates test. If logical false, evaluates body in an implicit do."
  {:added "1.0"}
  [test &amp; body]
    (list 'if test nil (cons 'do body)))
</pre>

<pre>
<strong>(source <u>when-let</u>)</strong>
&nbsp;
(defmacro when-let
  "bindings =&gt; binding-form test
&nbsp;
  When test is true, evaluates body with binding-form bound to the value of test"
  {:added "1.0"}
  [bindings &amp; body]
  (assert-args
     (vector? bindings) "a vector for its binding"
     (= 2 (count bindings)) "exactly 2 forms in binding vector")
   (let [form (bindings 0) tst (bindings 1)]
    `(let [temp# ~tst]
       (when temp#
         (let [~form temp#]
           ~@body)))))
</pre>

<pre>
<strong>(source <u>when-some</u>)</strong>
&nbsp;
(defmacro when-some
  "bindings =&gt; binding-form test
&nbsp;
   When test is not nil, evaluates body with binding-form bound to the
   value of test"
  {:added "1.6"}
  [bindings &amp; body]
  (assert-args
     (vector? bindings) "a vector for its binding"
     (= 2 (count bindings)) "exactly 2 forms in binding vector")
   (let [form (bindings 0) tst (bindings 1)]
    `(let [temp# ~tst]
       (if (nil? temp#)
         nil
         (let [~form temp#]
           ~@body)))))
</pre>

<pre>
<strong>(source <u>when-first</u>)</strong>
&nbsp;
(defmacro when-first
  "bindings =&gt; x xs
&nbsp;
  Roughly the same as (when (seq xs) (let [x (first xs)] body)) but xs is evaluated only once"
  {:added "1.0"}
  [bindings &amp; body]
  (assert-args
     (vector? bindings) "a vector for its binding"
     (= 2 (count bindings)) "exactly 2 forms in binding vector")
  (let [[x xs] bindings]
    `(when-let [xs# (seq ~xs)]
       (let [~x (first xs#)]
           ~@body))))
</pre>

<pre>
<strong>(source <u>cond</u>)</strong>
&nbsp;
(defmacro cond
  "Takes a set of test/expr pairs. It evaluates each test one at a
  time.  If a test returns logical true, cond evaluates and returns
  the value of the corresponding expr and doesn't evaluate any of the
  other tests or exprs. (cond) returns nil."
  {:added "1.0"}
  [&amp; clauses]
    (when clauses
      (list 'if (first clauses)
            (if (next clauses)
                (second clauses)
                (throw (IllegalArgumentException.
                         "cond requires an even number of forms")))
            (cons 'clojure.core/cond (next (next clauses))))))
</pre>

<pre>
<strong>(source <u>condp</u>)</strong>
&nbsp;
(defmacro condp
  "Takes a binary predicate, an expression, and a set of clauses.
  Each clause can take the form of either:
&nbsp;
  Each clause can take the form of either:
&nbsp;
  test-expr result-expr
&nbsp;
  test-expr :&gt;&gt; result-fn
&nbsp;
  Note :&gt;&gt; is an ordinary keyword.
&nbsp;
  For each clause, (pred test-expr expr) is evaluated. If it returns
  logical true, the clause is a match. If a binary clause matches, the
  result-expr is returned, if a ternary clause matches, its result-fn,
  which must be a unary function, is called with the result of the
  predicate as its argument, the result of that call being the return
  value of condp. A single default expression can follow the clauses,
  and its value will be returned if no clause matches. If no default
  expression is provided and no clause matches, an
  IllegalArgumentException is thrown."
&nbsp;
  {:added "1.0"}
&nbsp;
  [pred expr &amp; clauses]
  (let [gpred (gensym "pred__")
        gexpr (gensym "expr__")
        emit (fn emit [pred expr args]
               (let [[[a b c :as clause] more]
                       (split-at (if (= :&gt;&gt; (second args)) 3 2) args)
                       n (count clause)]
                 (cond
                  (= 0 n) `(throw (IllegalArgumentException. (str "No matching clause: " ~expr)))
                  (= 1 n) a
                  (= 2 n) `(if (~pred ~a ~expr)
                             ~b
                             ~(emit pred expr more))
                  :else `(if-let [p# (~pred ~a ~expr)]
                           (~c p#)
                           ~(emit pred expr more)))))]
    `(let [~gpred ~pred
           ~gexpr ~expr]
       ~(emit gpred gexpr clauses))))
</pre>

<pre>
<strong>(source <u>conde</u>)</strong>
&nbsp;
(defmacro conde
  "Logical disjunction of the clauses. The first goal in
  a clause is considered the head of that clause. Interleaves the
  execution of the clauses."
  [&amp; clauses]
  (let [a (gensym "a")]
    `(fn [~a]
       (-inc
        (mplus* ~@(bind-conde-clauses a clauses))))))
</pre>

<pre>
<strong>(source <u>condu</u>)</strong>
(defmacro condu
&nbsp;
  "Committed choice. Once the head (first goal) of a clause
  has succeeded, remaining goals of the clause will only
  be run once. Non-relational."
  [&amp; clauses]
  (let [a (gensym "a")]
    `(fn [~a]
       (ifu* ~@(map (cond-clauses a) clauses)))))
</pre>

<pre>
<strong>(source <u>conda</u>)</strong>
(defmacro conda
&nbsp;
  "Soft cut. Once the head of a clause has succeeded
  all other clauses will be ignored. Non-relational."
  [&amp; clauses]
  (let [a (gensym "a")]
    `(fn [~a]
       (ifa* ~@(map (cond-clauses a) clauses)))))
</pre>

<pre>
<strong>(source <u>cond-&gt;</u>)</strong>
(defmacro cond-&gt;
&nbsp;
  "Takes an expression and a set of test/form pairs. Threads expr (via -&gt;)
  through each form for which the corresponding test
  expression is true. Note that, unlike cond branching, cond-&gt; threading does
  not short circuit after the first true test expression."
  {:added "1.5"}
  [expr &amp; clauses]
  (assert (even? (count clauses)))
  (let [g (gensym)
        steps (map (fn [[test step]] `(if ~test (-&gt; ~g ~step) ~g))
                   (partition 2 clauses))]
    `(let [~g ~expr
           ~@(interleave (repeat g) (butlast steps))]
       ~(if (empty? steps)
          g
          (last steps)))))
</pre>

<pre>
<strong>(source <u>cond-&gt;&gt;</u>)</strong>
(defmacro cond-&gt;&gt;
&nbsp;
  "Takes an expression and a set of test/form pairs. Threads expr (via -&gt;&gt;)
  through each form for which the corresponding test expression
  is true.  Note that, unlike cond branching, cond-&gt;&gt; threading does not short circuit
  after the first true test expression."
  {:added "1.5"}
  [expr &amp; clauses]
  (assert (even? (count clauses)))
  (let [g (gensym)
        steps (map (fn [[test step]] `(if ~test (-&gt;&gt; ~g ~step) ~g))
                   (partition 2 clauses))]
    `(let [~g ~expr
           ~@(interleave (repeat g) (butlast steps))]
       ~(if (empty? steps)
          g
          (last steps)))))
</pre>

<pre>
<strong>(source <u>case</u>)</strong>
&nbsp;
(defmacro case
  "Takes an expression, and a set of clauses.
&nbsp;
  Each clause can take the form of either:
&nbsp;
  test-constant result-expr
&nbsp;
  (test-constant1 ... test-constantN)  result-expr
&nbsp;
  The test-constants are not evaluated. They must be compile-time
  literals, and need not be quoted.  If the expression is equal to a
  test-constant, the corresponding result-expr is returned. A single
  default expression can follow the clauses, and its value will be
  returned if no clause matches. If no default expression is provided
  and no clause matches, an IllegalArgumentException is thrown.
&nbsp;
  Unlike cond and condp, case does a constant-time dispatch, the
  clauses are not considered sequentially.  All manner of constant
  expressions are acceptable in case, including numbers, strings,
  symbols, keywords, and (Clojure) composites thereof. Note that since
  lists are used to group multiple constants that map to the same
  expression, a vector can be used to match a list if needed. The
  test-constants need not be all of the same type."
  {:added "1.2"}
&nbsp;
  [e &amp; clauses]
  (let [ge (with-meta (gensym) {:tag Object})
        default (if (odd? (count clauses))
                  (last clauses)
                  `(throw (IllegalArgumentException. (str "No matching clause: " ~ge))))]
    (if (&gt; 2 (count clauses))
      `(let [~ge ~e] ~default)
      (let [pairs (partition 2 clauses)
            assoc-test (fn assoc-test [m test expr]
                         (if (contains? m test)
                           (throw (IllegalArgumentException. (str "Duplicate case test constant: " test)))
                           (assoc m test expr)))
            pairs (reduce1
                       (fn [m [test expr]]
                         (if (seq? test)
                           (reduce1 #(assoc-test %1 %2 expr) m test)
                           (assoc-test m test expr)))
                       {} pairs)
            tests (keys pairs)
            thens (vals pairs)
            mode (cond
                   (every? #(and (integer? %) (&lt;= Integer/MIN_VALUE % Integer/MAX_VALUE)) tests)
                   :ints
                   (every? keyword? tests)
                   :identity
                   :else :hashes)]
        (condp = mode
          :ints
          (let [[shift mask imap switch-type] (prep-ints tests thens)]
            `(let [~ge ~e] (case* ~ge ~shift ~mask ~default ~imap ~switch-type :int)))
          :hashes
          (let [[shift mask imap switch-type skip-check] (prep-hashes ge default tests thens)]
            `(let [~ge ~e] (case* ~ge ~shift ~mask ~default ~imap ~switch-type :hash-equiv ~skip-check)))
          :identity
          (let [[shift mask imap switch-type skip-check] (prep-hashes ge default tests thens)]
            `(let [~ge ~e] (case* ~ge ~shift ~mask ~default ~imap ~switch-type :hash-identity ~skip-check))))))))
</pre>



<p><a name="k18"></a></p>
<h2 id="k18">18. Repositář s&nbsp;demonstračními příklady</h2>

<p>Ukázkové části kódu s&nbsp;rozhodovacími konstrukcemi, které byly popsány
v&nbsp;rámci předchozích kapitol, byly uloženy do Git repositáře, který je
dostupný na adrese <a
href="https://github.com/tisnik/clojure-examples/">https://github.com/tisnik/clojure-examples/</a>.
Konkrétně se jedná o projekt <strong>conditions</strong> (<a
href="https://github.com/tisnik/clojure-examples/tree/master/conditions">https://github.com/tisnik/clojure-examples/tree/master/conditions</a>),
jehož zdrojový kód (<a
href="https://github.com/tisnik/clojure-examples/tree/master/conditions/src/conditions/core.clj">jediný
soubor</a>) je možné postupně kopírovat do interaktivního prostředí
představovaného smyčkou REPL. Příklad je pochopitelně možné spustit i
v&nbsp;jeho plné podobě příkazem:</p>

<pre>
<strong>lein run</strong>
</pre>

<p>To ovšem do určité míry postrádá výukový charakter.</p>



<p><a name="k19"></a></p>
<h2 id="k19">19. Odkazy na předchozí části seriálu o programovacím jazyku Clojure</h2>

<ol>

<li>Clojure  1: Úvod<br />
<a href="http://www.root.cz/clanky/clojure-aneb-jazyk-umoznujici-tvorbu-bezpecnych-vicevlaknovych-aplikaci-pro-jvm/">http://www.root.cz/clanky/clojure-aneb-jazyk-umoznujici-tvorbu-bezpecnych-vicevlaknovych-aplikaci-pro-jvm/</a>
</li>

<li>Clojure  2: Symboly, kolekce atd.<br />
<a href="http://www.root.cz/clanky/clojure-aneb-jazyk-umoznujici-tvorbu-bezpecnych-vicevlaknovych-aplikaci-pro-jvm-2-cast/">http://www.root.cz/clanky/clojure-aneb-jazyk-umoznujici-tvorbu-bezpecnych-vicevlaknovych-aplikaci-pro-jvm-2-cast/</a>
</li>

<li>Clojure  3: Funkcionální programování<br />
<a href="http://www.root.cz/clanky/clojure-aneb-jazyk-umoznujici-tvorbu-bezpecnych-vicevlaknovych-aplikaci-pro-jvm-3-cast-funkcionalni-programovani/">http://www.root.cz/clanky/clojure-aneb-jazyk-umoznujici-tvorbu-bezpecnych-vicevlaknovych-aplikaci-pro-jvm-3-cast-funkcionalni-programovani/</a>
</li>

<li>Clojure  4: Kolekce, sekvence a lazy sekvence<br />
<a href="http://www.root.cz/clanky/clojure-aneb-jazyk-umoznujici-tvorbu-bezpecnych-vicevlaknovych-aplikaci-pro-jvm-4-cast-kolekce-sekvence-a-lazy-sekvence/">http://www.root.cz/clanky/clojure-aneb-jazyk-umoznujici-tvorbu-bezpecnych-vicevlaknovych-aplikaci-pro-jvm-4-cast-kolekce-sekvence-a-lazy-sekvence/</a>
</li>

<li>Clojure  5: Sekvence, lazy sekvence a paralelní programy<br />
<a href="http://www.root.cz/clanky/clojure-a-bezpecne-aplikace-pro-jvm-sekvence-lazy-sekvence-a-paralelni-programy/">http://www.root.cz/clanky/clojure-a-bezpecne-aplikace-pro-jvm-sekvence-lazy-sekvence-a-paralelni-programy/</a>
</li>

<li>Clojure  6: Podpora pro paralelní programování<br />
<a href="http://www.root.cz/clanky/programovaci-jazyk-clojure-6-futures-nejsou-jen-financni-derivaty/">http://www.root.cz/clanky/programovaci-jazyk-clojure-6-futures-nejsou-jen-financni-derivaty/</a>
</li>

<li>Clojure  7: Další funkce pro paralelní programování<br />
<a href="http://www.root.cz/clanky/programovaci-jazyk-clojure-7-dalsi-podpurne-prostredky-pro-paralelni-programovani/">http://www.root.cz/clanky/programovaci-jazyk-clojure-7-dalsi-podpurne-prostredky-pro-paralelni-programovani/</a>
</li>

<li>Clojure  8: Identity, stavy, neměnné hodnoty a reference<br />
<a href="http://www.root.cz/clanky/programovaci-jazyk-clojure-8-identity-stavy-nemenne-hodnoty-a-referencni-typy/">http://www.root.cz/clanky/programovaci-jazyk-clojure-8-identity-stavy-nemenne-hodnoty-a-referencni-typy/</a>
</li>

<li>Clojure  9: Validátory, pozorovatelé a kooperace s Javou<br />
<a href="http://www.root.cz/clanky/programovaci-jazyk-clojure-9-validatory-pozorovatele-a-kooperace-mezi-clojure-a-javou/">http://www.root.cz/clanky/programovaci-jazyk-clojure-9-validatory-pozorovatele-a-kooperace-mezi-clojure-a-javou/</a>
</li>

<li>Clojure 10: Kooperace mezi Clojure a Javou<br />
<a href="http://www.root.cz/clanky/programovaci-jazyk-clojure-10-kooperace-mezi-clojure-a-javou-pokracovani/">http://www.root.cz/clanky/programovaci-jazyk-clojure-10-kooperace-mezi-clojure-a-javou-pokracovani/</a>
</li>

<li>Clojure 11: Generátorová notace seznamu/list comprehension<br />
<a href="http://www.root.cz/clanky/programovaci-jazyk-clojure-11-generatorova-notace-seznamu-list-comprehension/">http://www.root.cz/clanky/programovaci-jazyk-clojure-11-generatorova-notace-seznamu-list-comprehension/</a>
</li>

<li>Clojure 12: Překlad programů z Clojure do bajtkódu JVM I:<br />
<a href="http://www.root.cz/clanky/programovaci-jazyk-clojure-12-preklad-programu-z-clojure-do-bajtkodu-jvm/">http://www.root.cz/clanky/programovaci-jazyk-clojure-12-preklad-programu-z-clojure-do-bajtkodu-jvm/</a>
</li>

<li>Clojure 13: Překlad programů z Clojure do bajtkódu JVM II:<br />
<a href="http://www.root.cz/clanky/programovaci-jazyk-clojure-13-preklad-programu-z-clojure-do-bajtkodu-jvm-pokracovani/">http://www.root.cz/clanky/programovaci-jazyk-clojure-13-preklad-programu-z-clojure-do-bajtkodu-jvm-pokracovani/</a>
</li>

<li>Clojure 14: Základy práce se systémem maker<br />
<a href="http://www.root.cz/clanky/programovaci-jazyk-clojure-14-zaklady-prace-se-systemem-maker/">http://www.root.cz/clanky/programovaci-jazyk-clojure-14-zaklady-prace-se-systemem-maker/</a>
</li>

<li>Clojure 15: Tvorba uživatelských maker<br />
<a href="http://www.root.cz/clanky/programovaci-jazyk-clojure-15-tvorba-uzivatelskych-maker/">http://www.root.cz/clanky/programovaci-jazyk-clojure-15-tvorba-uzivatelskych-maker/</a>
</li>

<li>Programovací jazyk Clojure &ndash; triky při práci s řetězci<br />
<a href="http://www.root.cz/clanky/programovaci-jazyk-clojure-triky-pri-praci-s-retezci/">http://www.root.cz/clanky/programovaci-jazyk-clojure-triky-pri-praci-s-retezci/</a>
</li>

<li>Programovací jazyk Clojure &ndash; triky při práci s kolekcemi<br />
<a href="http://www.root.cz/clanky/programovaci-jazyk-clojure-triky-pri-praci-s-kolekcemi/">http://www.root.cz/clanky/programovaci-jazyk-clojure-triky-pri-praci-s-kolekcemi/</a>
</li>

<li>Programovací jazyk Clojure &ndash; práce s mapami a množinami<br />
<a href="http://www.root.cz/clanky/programovaci-jazyk-clojure-prace-s-mapami-a-mnozinami/">http://www.root.cz/clanky/programovaci-jazyk-clojure-prace-s-mapami-a-mnozinami/</a>
</li>

<li>Programovací jazyk Clojure &ndash; základy zpracování XML<br />
<a href="http://www.root.cz/clanky/programovaci-jazyk-clojure-zaklady-zpracovani-xml/">http://www.root.cz/clanky/programovaci-jazyk-clojure-zaklady-zpracovani-xml/</a>
</li>

<li>Programovací jazyk Clojure &ndash; testování s využitím knihovny Expectations<br />
<a href="http://www.root.cz/clanky/programovaci-jazyk-clojure-testovani-s-vyuzitim-knihovny-expectations/">http://www.root.cz/clanky/programovaci-jazyk-clojure-testovani-s-vyuzitim-knihovny-expectations/</a>
</li>

<li>Programovací jazyk Clojure &ndash; některé užitečné triky použitelné (nejenom) v&nbsp;testech<br />
<a href="http://www.root.cz/clanky/programovaci-jazyk-clojure-nektere-uzitecne-triky-pouzitelne-nejenom-v-testech/">http://www.root.cz/clanky/programovaci-jazyk-clojure-nektere-uzitecne-triky-pouzitelne-nejenom-v-testech/</a>
</li>

<li>Enlive &ndash; výkonný šablonovací systém pro jazyk Clojure<br/>
<a href="http://www.root.cz/clanky/enlive-vykonny-sablonovaci-system-pro-jazyk-clojure/">http://www.root.cz/clanky/enlive-vykonny-sablonovaci-system-pro-jazyk-clojure/</a>
</li>

<li>Nástroj Leiningen a programovací jazyk Clojure: tvorba vlastních knihoven pro veřejný repositář Clojars<br />
<a href="http://www.root.cz/clanky/nastroj-leiningen-a-programovaci-jazyk-clojure-tvorba-vlastnich-knihoven-pro-verejny-repositar-clojars/">http://www.root.cz/clanky/nastroj-leiningen-a-programovaci-jazyk-clojure-tvorba-vlastnich-knihoven-pro-verejny-repositar-clojars/</a>
</li>

<li>Novinky v Clojure verze 1.8.0<br />
<a href="http://www.root.cz/clanky/novinky-v-clojure-verze-1-8-0/">http://www.root.cz/clanky/novinky-v-clojure-verze-1-8-0/</a>
</li>

<li>Asynchronní programování v&nbsp;Clojure s&nbsp;využitím knihovny core.async<br />
<a href="http://www.root.cz/clanky/asynchronni-programovani-v-clojure-s-vyuzitim-knihovny-core-async/">http://www.root.cz/clanky/asynchronni-programovani-v-clojure-s-vyuzitim-knihovny-core-async/</a>
</li>

<li>Asynchronní programování v&nbsp;Clojure s&nbsp;využitím knihovny core.async (pokračování)<br />
<a href="http://www.root.cz/clanky/asynchronni-programovani-v-clojure-s-vyuzitim-knihovny-core-async-pokracovani/">http://www.root.cz/clanky/asynchronni-programovani-v-clojure-s-vyuzitim-knihovny-core-async-pokracovani/</a>
</li>

<li>Asynchronní programování v Clojure s využitím knihovny core.async (dokončení)<br />
<a href="http://www.root.cz/clanky/asynchronni-programovani-v-clojure-s-vyuzitim-knihovny-core-async-dokonceni/">http://www.root.cz/clanky/asynchronni-programovani-v-clojure-s-vyuzitim-knihovny-core-async-dokonceni/</a>
</li>

<li>Vytváříme IRC bota v programovacím jazyce Clojure<br />
<a href="http://www.root.cz/clanky/vytvarime-irc-bota-v-programovacim-jazyce-clojure/">http://www.root.cz/clanky/vytvarime-irc-bota-v-programovacim-jazyce-clojure/</a>
</li>

<li>Gorilla REPL: interaktivní prostředí pro programovací jazyk Clojure<br />
<a href="https://www.root.cz/clanky/gorilla-repl-interaktivni-prostredi-pro-programovaci-jazyk-clojure/">https://www.root.cz/clanky/gorilla-repl-interaktivni-prostredi-pro-programovaci-jazyk-clojure/</a>
</li>

<li>Multimetody v Clojure aneb polymorfismus bez použití OOP<br />
<a href="https://www.root.cz/clanky/multimetody-v-clojure-aneb-polymorfismus-bez-pouziti-oop/">https://www.root.cz/clanky/multimetody-v-clojure-aneb-polymorfismus-bez-pouziti-oop/</a>
</li>

<li>Práce s externími Java archivy v programovacím jazyku Clojure<br />
<a href="https://www.root.cz/clanky/prace-s-externimi-java-archivy-v-programovacim-jazyku-clojure/">https://www.root.cz/clanky/prace-s-externimi-java-archivy-v-programovacim-jazyku-clojure/</a>
</li>

<li>Clojure 16: Složitější uživatelská makra<br />
<a href="http://www.root.cz/clanky/programovaci-jazyk-clojure-16-slozitejsi-uzivatelska-makra/">http://www.root.cz/clanky/programovaci-jazyk-clojure-16-slozitejsi-uzivatelska-makra/</a>
</li>

<li>Clojure 17: Využití standardních maker v praxi<br />
<a href="http://www.root.cz/clanky/programovaci-jazyk-clojure-17-vyuziti-standardnich-maker-v-praxi/">http://www.root.cz/clanky/programovaci-jazyk-clojure-17-vyuziti-standardnich-maker-v-praxi/</a>
</li>

<li>Clojure 18: Základní techniky optimalizace aplikací<br />
<a href="http://www.root.cz/clanky/programovaci-jazyk-clojure-18-zakladni-techniky-optimalizace-aplikaci/">http://www.root.cz/clanky/programovaci-jazyk-clojure-18-zakladni-techniky-optimalizace-aplikaci/</a>
</li>

<li>Clojure 19: Vývojová prostředí pro Clojure<br />
<a href="http://www.root.cz/clanky/programovaci-jazyk-clojure-19-vyvojova-prostredi-pro-clojure/">http://www.root.cz/clanky/programovaci-jazyk-clojure-19-vyvojova-prostredi-pro-clojure/</a>
</li>

<li>Clojure 20: Vývojová prostředí pro Clojure (Vimu s REPL)<br />
<a href="http://www.root.cz/clanky/programovaci-jazyk-clojure-20-vyvojova-prostredi-pro-clojure-integrace-vimu-s-repl/">http://www.root.cz/clanky/programovaci-jazyk-clojure-20-vyvojova-prostredi-pro-clojure-integrace-vimu-s-repl/</a>
</li>

<li>Clojure 21: ClojureScript aneb překlad Clojure do JS<br />
<a href="http://www.root.cz/clanky/programovaci-jazyk-clojure-21-clojurescript-aneb-preklad-clojure-do-javascriptu/">http://www.root.cz/clanky/programovaci-jazyk-clojure-21-clojurescript-aneb-preklad-clojure-do-javascriptu/</a>
</li>

<li>Leiningen: nástroj pro správu projektů napsaných v&nbsp;Clojure<br />
<a href="http://www.root.cz/clanky/leiningen-nastroj-pro-spravu-projektu-napsanych-v-clojure/">http://www.root.cz/clanky/leiningen-nastroj-pro-spravu-projektu-napsanych-v-clojure/</a>
</li>

<li>Leiningen: nástroj pro správu projektů napsaných v&nbsp;Clojure (2)<br />
<a href="http://www.root.cz/clanky/leiningen-nastroj-pro-spravu-projektu-napsanych-v-clojure-2/">http://www.root.cz/clanky/leiningen-nastroj-pro-spravu-projektu-napsanych-v-clojure-2/</a>
</li>

<li>Leiningen: nástroj pro správu projektů napsaných v&nbsp;Clojure (3)<br />
<a href="http://www.root.cz/clanky/leiningen-nastroj-pro-spravu-projektu-napsanych-v-clojure-3/">http://www.root.cz/clanky/leiningen-nastroj-pro-spravu-projektu-napsanych-v-clojure-3/</a>
</li>

<li>Leiningen: nástroj pro správu projektů napsaných v&nbsp;Clojure (4)<br />
<a href="http://www.root.cz/clanky/leiningen-nastroj-pro-spravu-projektu-napsanych-v-clojure-4/">http://www.root.cz/clanky/leiningen-nastroj-pro-spravu-projektu-napsanych-v-clojure-4/</a>
</li>

<li>Leiningen: nástroj pro správu projektů napsaných v&nbsp;Clojure (5)<br />
<a href="http://www.root.cz/clanky/leiningen-nastroj-pro-spravu-projektu-napsanych-v-clojure-5/">http://www.root.cz/clanky/leiningen-nastroj-pro-spravu-projektu-napsanych-v-clojure-5/</a>
</li>

<li>Leiningen: nástroj pro správu projektů napsaných v&nbsp;Clojure (6)<br />
<a href="http://www.root.cz/clanky/leiningen-nastroj-pro-spravu-projektu-napsanych-v-clojure-6/">http://www.root.cz/clanky/leiningen-nastroj-pro-spravu-projektu-napsanych-v-clojure-6/</a>
</li>

<li>Programovací jazyk Clojure a databáze (1.část)<br />
<a href="http://www.root.cz/clanky/programovaci-jazyk-clojure-a-databaze-1-cast/">http://www.root.cz/clanky/programovaci-jazyk-clojure-a-databaze-1-cast/</a>
</li>

<li>Pluginy pro Leiningen<br />
<a href="http://www.root.cz/clanky/leiningen-nastroj-pro-spravu-projektu-napsanych-v-clojure-pluginy-pro-leiningen/">http://www.root.cz/clanky/leiningen-nastroj-pro-spravu-projektu-napsanych-v-clojure-pluginy-pro-leiningen/</a>
</li>

<li>Programovací jazyk Clojure a knihovny pro práci s&nbsp;vektory a maticemi<br />
<a href="http://www.root.cz/clanky/programovaci-jazyk-clojure-a-knihovny-pro-praci-s-vektory-a-maticemi/">http://www.root.cz/clanky/programovaci-jazyk-clojure-a-knihovny-pro-praci-s-vektory-a-maticemi/</a>
</li>

<li>Programovací jazyk Clojure a knihovny pro práci s&nbsp;vektory a maticemi (2)<br />
<a href="http://www.root.cz/clanky/programovaci-jazyk-clojure-a-knihovny-pro-praci-s-vektory-a-maticemi-2/">http://www.root.cz/clanky/programovaci-jazyk-clojure-a-knihovny-pro-praci-s-vektory-a-maticemi-2/</a>
</li>

<li>Programovací jazyk Clojure: syntéza procedurálních textur s&nbsp;využitím knihovny Clisk<br />
<a href="http://www.root.cz/clanky/programovaci-jazyk-clojure-synteza-proceduralnich-textur-s-vyuzitim-knihovny-clisk/">http://www.root.cz/clanky/programovaci-jazyk-clojure-synteza-proceduralnich-textur-s-vyuzitim-knihovny-clisk/</a>
</li>

<li>Programovací jazyk Clojure: syntéza procedurálních textur s&nbsp;využitím knihovny Clisk (2)<br />
<a href="http://www.root.cz/clanky/programovaci-jazyk-clojure-synteza-proceduralnich-textur-s-vyuzitim-knihovny-clisk-2/">http://www.root.cz/clanky/programovaci-jazyk-clojure-synteza-proceduralnich-textur-s-vyuzitim-knihovny-clisk-2/</a>
</li>

<li>Seesaw: knihovna pro snadnou tvorbu GUI v&nbsp;jazyce Clojure<br />
<a href="http://www.root.cz/clanky/seesaw-knihovna-pro-snadnou-tvorbu-gui-v-jazyce-clojure/">http://www.root.cz/clanky/seesaw-knihovna-pro-snadnou-tvorbu-gui-v-jazyce-clojure/</a>
</li>

<li>Seesaw: knihovna pro snadnou tvorbu GUI v &nbsp;azyce Clojure (2)<br />
<a href="http://www.root.cz/clanky/seesaw-knihovna-pro-snadnou-tvorbu-gui-v-jazyce-clojure-2/">http://www.root.cz/clanky/seesaw-knihovna-pro-snadnou-tvorbu-gui-v-jazyce-clojure-2/</a>
</li>

<li>Seesaw: knihovna pro snadnou tvorbu GUI v&nbsp;jazyce Clojure (3)<br />
<a href="http://www.root.cz/clanky/seesaw-knihovna-pro-snadnou-tvorbu-gui-v-jazyce-clojure-3/">http://www.root.cz/clanky/seesaw-knihovna-pro-snadnou-tvorbu-gui-v-jazyce-clojure-3/</a>
</li>

<li>Programovací jazyk Clojure a práce s&nbsp;Gitem<br />
<a href="http://www.root.cz/clanky/programovaci-jazyk-clojure-a-prace-s-gitem/">http://www.root.cz/clanky/programovaci-jazyk-clojure-a-prace-s-gitem/</a>
</li>

<li>Programovací jazyk Clojure a práce s&nbsp;Gitem (2)<br />
<a href="http://www.root.cz/clanky/programovaci-jazyk-clojure-a-prace-s-gitem-2/">http://www.root.cz/clanky/programovaci-jazyk-clojure-a-prace-s-gitem-2/</a>
</li>

<li>Programovací jazyk Clojure: syntéza procedurálních textur s&nbsp;využitím knihovny Clisk (dokončení)<br />
<a href="http://www.root.cz/clanky/programovaci-jazyk-clojure-synteza-proceduralnich-textur-s-vyuzitim-knihovny-clisk-dokonceni/">http://www.root.cz/clanky/programovaci-jazyk-clojure-synteza-proceduralnich-textur-s-vyuzitim-knihovny-clisk-dokonceni/</a>
</li>

<li>Pixie: lehký skriptovací jazyk s&nbsp;„kouzelnými“ schopnostmi<br />
<a href="https://www.root.cz/clanky/pixie-lehky-skriptovaci-jazyk-s-kouzelnymi-schopnostmi/">https://www.root.cz/clanky/pixie-lehky-skriptovaci-jazyk-s-kouzelnymi-schopnostmi/</a>
</li>

<li>Programovací jazyk Pixie: funkce ze základní knihovny a použití FFI<br />
<a href="https://www.root.cz/clanky/programovaci-jazyk-pixie-funkce-ze-zakladni-knihovny-a-pouziti-ffi/">https://www.root.cz/clanky/programovaci-jazyk-pixie-funkce-ze-zakladni-knihovny-a-pouziti-ffi/</a>
</li>

<li>Novinky v&nbsp;Clojure verze 1.9.0<br />
<a href="https://www.root.cz/clanky/novinky-v-clojure-verze-1-9-0/">https://www.root.cz/clanky/novinky-v-clojure-verze-1-9-0/</a>
</li>

<li>Validace dat s&nbsp;využitím knihovny spec v&nbsp;Clojure 1.9.0<br />
<a href="https://www.root.cz/clanky/validace-dat-s-vyuzitim-knihovny-spec-v-clojure-1-9-0/">https://www.root.cz/clanky/validace-dat-s-vyuzitim-knihovny-spec-v-clojure-1-9-0/</a>
</li>

<li>Použití jazyka Gherkin při tvorbě testovacích scénářů pro aplikace psané v&nbsp;Clojure<br />
<a href="https://www.root.cz/clanky/pouziti-jazyka-gherkin-pri-tvorbe-testovacich-scenaru-pro-aplikace-psane-v-nbsp-clojure/">https://www.root.cz/clanky/pouziti-jazyka-gherkin-pri-tvorbe-testovacich-scenaru-pro-aplikace-psane-v-nbsp-clojure/</a>
</li>

<li>Použití jazyka Gherkin při tvorbě testovacích scénářů pro aplikace psané v&nbsp;Clojure (2)<br />
<a href="https://www.root.cz/clanky/pouziti-jazyka-gherkin-pri-tvorbe-testovacich-scenaru-pro-aplikace-psane-v-nbsp-clojure-2/">https://www.root.cz/clanky/pouziti-jazyka-gherkin-pri-tvorbe-testovacich-scenaru-pro-aplikace-psane-v-nbsp-clojure-2/</a>
</li>

<li>Incanter: prostředí pro statistické výpočty s grafickým výstupem založené na Clojure<br />
<a href="https://www.root.cz/clanky/incanter-prostredi-pro-statisticke-vypocty-s-grafickym-vystupem-zalozene-na-clojure/">https://www.root.cz/clanky/incanter-prostredi-pro-statisticke-vypocty-s-grafickym-vystupem-zalozene-na-clojure/</a>
</li>

<li>Incanter: operace s&nbsp;maticemi<br />
<a href="https://www.root.cz/clanky/incanter-operace-s-maticemi/">https://www.root.cz/clanky/incanter-operace-s-maticemi/</a>
</li>

<li>Interpret programovacího jazyka Clojure integrovaný do Jupyter Notebooku<br />
<a href="https://www.root.cz/clanky/interpret-programovaciho-jazyka-clojure-integrovany-do-jupyter-notebooku/">https://www.root.cz/clanky/interpret-programovaciho-jazyka-clojure-integrovany-do-jupyter-notebooku/</a>
</li>

<li>Babashka: interpret Clojure určený pro rychlé spouštění utilit z&nbsp;příkazového řádku<br />
<a href="https://www.root.cz/clanky/babashka-interpret-clojure-urceny-pro-rychle-spousteni-utilit-z-prikazoveho-radku/">https://www.root.cz/clanky/babashka-interpret-clojure-urceny-pro-rychle-spousteni-utilit-z-prikazoveho-radku/</a>
</li>

<li>Pokročilý streaming založený na Apache Kafce, jazyku Clojure a knihovně Jackdaw<br />
<a href="https://www.root.cz/clanky/pokrocily-streaming-zalozeny-na-apache-kafce-jazyku-clojure-a-knihovne-jackdaw/">https://www.root.cz/clanky/pokrocily-streaming-zalozeny-na-apache-kafce-jazyku-clojure-a-knihovne-jackdaw/</a>
</li>

<li>Pokročilý streaming založený na Apache Kafce, jazyku Clojure a knihovně Jackdaw (2. část)<br />
<a href="https://www.root.cz/clanky/pokrocily-streaming-zalozeny-na-apache-kafce-jazyku-clojure-a-knihovne-jackdaw-2-cast/">https://www.root.cz/clanky/pokrocily-streaming-zalozeny-na-apache-kafce-jazyku-clojure-a-knihovne-jackdaw-2-cast/</a>
</li>

<li>Pokročilý streaming založený na projektu Apache Kafka, jazyku Clojure a knihovně Jackdaw (streamy a kolony)<br />
<a href="https://www.root.cz/clanky/pokrocily-streaming-zalozeny-na-projektu-apache-kafka-jazyku-clojure-a-knihovne-jackdaw-streamy-a-kolony/">https://www.root.cz/clanky/pokrocily-streaming-zalozeny-na-projektu-apache-kafka-jazyku-clojure-a-knihovne-jackdaw-streamy-a-kolony/</a>
</li>

<li>Řídicí struktury využitelné v&nbsp;programovacím jazyku Clojure<br />
<a href="https://www.root.cz/clanky/ridici-struktury-vyuzitelne-v-programovacim-jazyku-clojure/">https://www.root.cz/clanky/ridici-struktury-vyuzitelne-v-programovacim-jazyku-clojure/</a>
</li>

</ol>



<p><a name="k20"></a></p>
<h2 id="k20">20. Odkazy na Internetu</h2>

<ol>

<li>The Clojure Style Guide<br />
<a href="https://github.com/bbatsov/clojure-style-guide">https://github.com/bbatsov/clojure-style-guide</a>
</li>

<li>Rozhodovací tabulky a stromy<br />
<a href="https://wikisofia.cz/wiki/Rozhodovac%C3%AD_tabulky_a_stromy">https://wikisofia.cz/wiki/Rozhodovac%C3%AD_tabulky_a_stromy</a>
</li>

<li>Special (Conditions)<br />
<a href="https://github.com/clojureman/special">https://github.com/clojureman/special</a>
</li>

<li>better-cond<br />
<a href="https://cljdoc.org/d/better-cond/better-cond/2.1.0/doc/readme">https://cljdoc.org/d/better-cond/better-cond/2.1.0/doc/readme</a>
</li>

<li>A micro-library around the useful cond-let macro<br />
<a href="https://cljdoc.org/d/com.walmartlabs/cond-let/1.0.0/doc/readme">https://cljdoc.org/d/com.walmartlabs/cond-let/1.0.0/doc/readme</a>
</li>

<li>An adaption of the Racket cond macro for Clojure<br />
<a href="https://cljdoc.org/d/cond-plus/cond-plus/1.0.1/doc/readme">https://cljdoc.org/d/cond-plus/cond-plus/1.0.1/doc/readme</a>
</li>

<li>Makro cond-table<br />
<a href="https://github.com/semperos/rankle/blob/master/src/com/semperos/rankle/util.clj">https://github.com/semperos/rankle/blob/master/src/com/semperos/rankle/util.clj</a>
</li>

<li>cond v&nbsp;jazyku Racket<br />
<a href="https://docs.racket-lang.org/reference/if.html?q=cond#%28form._%28%28lib._racket%2Fprivate%2Fletstx-scheme..rkt%29._cond%29%29">https://docs.racket-lang.org/reference/if.html?q=cond#%28form._%28%28lib._racket%2Fprivate%2Fletstx-scheme..rkt%29._cond%29%29</a>
</li>

<li>Learn Clojure - Flow Control<br />
<a href="https://clojure.org/guides/learn/flow">https://clojure.org/guides/learn/flow</a>
</li>

<li>clojure.core.logic<br />
<a href="https://clojuredocs.org/clojure.core.logic">https://clojuredocs.org/clojure.core.logic</a>
</li>

<li>ETL Batch Processing With Kafka?<br />
<a href="https://medium.com/swlh/etl-batch-processing-with-kafka-7f66f843e20d">https://medium.com/swlh/etl-batch-processing-with-kafka-7f66f843e20d</a>
</li>

<li>ETL with Kafka<br />
<a href="https://blog.codecentric.de/en/2018/03/etl-kafka/">https://blog.codecentric.de/en/2018/03/etl-kafka/</a>
</li>

<li>Building ETL Pipelines with Clojure and Transducers<br />
<a href="https://www.grammarly.com/blog/engineering/building-etl-pipelines-with-clojure-and-transducers/">https://www.grammarly.com/blog/engineering/building-etl-pipelines-with-clojure-and-transducers/</a>
</li>

<li>pipeline (možné použít pro ETL)<br />
<a href="https://clojuredocs.org/clojure.core.async/pipeline">https://clojuredocs.org/clojure.core.async/pipeline</a>
</li>

<li>On Track with Apache Kafka – Building a Streaming ETL Solution with Rail Data<br />
<a href="https://www.confluent.io/blog/build-streaming-etl-solutions-with-kafka-and-rail-data/">https://www.confluent.io/blog/build-streaming-etl-solutions-with-kafka-and-rail-data/</a>
</li>

<li>Kafka - Understanding Offset Commits<br />
<a href="https://www.logicbig.com/tutorials/misc/kafka/committing-offsets.html">https://www.logicbig.com/tutorials/misc/kafka/committing-offsets.html</a>
</li>

<li>fundingcircle/jackdaw (na Clojars)<br />
<a href="https://clojars.org/fundingcircle/jackdaw/versions/0.7.6">https://clojars.org/fundingcircle/jackdaw/versions/0.7.6</a>
</li>

<li>Dokumentace ke knihovně jackdaw<br />
<a href="https://cljdoc.org/d/fundingcircle/jackdaw/0.7.6/doc/readme">https://cljdoc.org/d/fundingcircle/jackdaw/0.7.6/doc/readme</a>
</li>

<li>Jackdaw AdminClient API<br />
<a href="https://cljdoc.org/d/fundingcircle/jackdaw/0.7.6/doc/jackdaw-adminclient-api">https://cljdoc.org/d/fundingcircle/jackdaw/0.7.6/doc/jackdaw-adminclient-api</a>
</li>

<li>Jackdaw Client API<br />
<a href="https://cljdoc.org/d/fundingcircle/jackdaw/0.7.6/doc/jackdaw-client-api">https://cljdoc.org/d/fundingcircle/jackdaw/0.7.6/doc/jackdaw-client-api</a>
</li>

<li>Kafka.clj<br />
<a href="https://github.com/helins-io/kafka.clj">https://github.com/helins-io/kafka.clj</a>
</li>

<li>Použití nástroje Apache Kafka v aplikacích založených na mikroslužbách<br />
<a href="https://www.root.cz/clanky/pouziti-nastroje-apache-kafka-v-aplikacich-zalozenych-na-mikrosluzbach/">https://www.root.cz/clanky/pouziti-nastroje-apache-kafka-v-aplikacich-zalozenych-na-mikrosluzbach/</a>
</li>

<li>Apache Kafka: distribuovaná streamovací platforma<br />
<a href="https://www.root.cz/clanky/apache-kafka-distribuovana-streamovaci-platforma/">https://www.root.cz/clanky/apache-kafka-distribuovana-streamovaci-platforma/</a>
</li>

<li>Real-Time Payments with Clojure and Apache Kafka (podcast)<br />
<a href="https://www.evidentsystems.com/news/confluent-podcast-about-apache-kafka/">https://www.evidentsystems.com/news/confluent-podcast-about-apache-kafka/</a>
</li>

<li>Kafka and Clojure - Immutable event streams<br />
<a href="https://practicalli.github.io/kafka-and-clojure/">https://practicalli.github.io/kafka-and-clojure/</a>
</li>

<li>Kafka Streams, the Clojure way<br />
<a href="https://blog.davemartin.me/posts/kafka-streams-the-clojure-way/">https://blog.davemartin.me/posts/kafka-streams-the-clojure-way/</a>
</li>

<li>dvlopt.kafka na GitHubu<br />
<a href="https://github.com/helins-io/kafka.clj">https://github.com/helins-io/kafka.clj</a>
</li>

<li>kafka-streams-the-clojure-way na GitHubu<br />
<a href="https://github.com/DaveWM/kafka-streams-the-clojure-way">https://github.com/DaveWM/kafka-streams-the-clojure-way</a>
</li>

<li>babashka: A Clojure babushka for the grey areas of Bash<br />
<a href="https://github.com/borkdude/babashka">https://github.com/borkdude/babashka</a>
</li>

<li>Babashka and the Small Clojure Interpreter @ ClojureD 2020 (slajdy)<br />
<a href="https://speakerdeck.com/borkdude/babashka-and-the-small-clojure-interpreter-at-clojured-2020">https://speakerdeck.com/borkdude/babashka-and-the-small-clojure-interpreter-at-clojured-2020</a>
</li>

<li>Babashka: ukázky použití<br />
<a href="https://github.com/borkdude/babashka/blob/master/doc/examples.md">https://github.com/borkdude/babashka/blob/master/doc/examples.md</a>
</li>

<li>clojureD 2020: "Babashka and Small Clojure Interpreter: Clojure in new contexts" by Michiel Borkent<br />
<a href="https://www.youtube.com/watch?v=Nw8aN-nrdEk&amp;t=5s">https://www.youtube.com/watch?v=Nw8aN-nrdEk&amp;t=5s</a>
</li>

<li>Meetup #124 Babashka, implementing an nREPL server &amp; game engines with Clojure<br />
<a href="https://www.youtube.com/watch?v=0YmZYnwyHHc">https://www.youtube.com/watch?v=0YmZYnwyHHc</a>
</li>

<li>The Last Programming Language (shrnutí vývoje programovacích jazyků)<br />
<a href="https://www.youtube.com/watch?v=P2yr-3F6PQo">https://www.youtube.com/watch?v=P2yr-3F6PQo</a>
</li>

<li>Shebang (Unix): Wikipedia EN<br />
<a href="https://en.wikipedia.org/wiki/Shebang_(Unix)">https://en.wikipedia.org/wiki/Shebang_(Unix)</a>
</li>

<li>Shebang (Unix): Wikipedia CZ<br />
<a href="https://cs.wikipedia.org/wiki/Shebang_(Unix)">https://cs.wikipedia.org/wiki/Shebang_(Unix)</a>
</li>

<li>How to create Clojure notebooks in Jupyter<br />
<a href="https://s01blog.wordpress.com/2017/12/10/how-to-create-clojure-notebooks-in-jupyter/">https://s01blog.wordpress.com/2017/12/10/how-to-create-clojure-notebooks-in-jupyter/</a>
</li>

<li>Dokumentace k&nbsp;nástroji Conda<br />
<a href="https://docs.conda.io/en/latest/">https://docs.conda.io/en/latest/</a>
</li>

<li>Notebook interface<br />
<a href="https://en.wikipedia.org/wiki/Notebook_interface">https://en.wikipedia.org/wiki/Notebook_interface</a>
</li>

<li>Jypyter: open source, interactive data science and scientific computing across over 40 programming languages<br />
<a href="https://jupyter.org/">https://jupyter.org/</a>
</li>

<li>Calysto Scheme<br />
<a href="https://github.com/Calysto/calysto_scheme">https://github.com/Calysto/calysto_scheme</a>
</li>

<li>scheme.py (základ projektu Calysto Scheme)<br />
<a href="https://github.com/Calysto/calysto_scheme/blob/master/calysto_scheme/scheme.py">https://github.com/Calysto/calysto_scheme/blob/master/calysto_scheme/scheme.py</a>
</li>

<li>Humane test output for clojure.test<br />
<a href="https://github.com/pjstadig/humane-test-output">https://github.com/pjstadig/humane-test-output</a>
</li>

<li>iota<br />
<a href="https://github.com/juxt/iota">https://github.com/juxt/iota</a>
</li>

<li>5 Differences between clojure.spec and Schema<br />
<a href="https://lispcast.com/clojure.spec-vs-schema/">https://lispcast.com/clojure.spec-vs-schema/</a>
</li>

<li>Schema: Clojure(Script) library for declarative data description and validation<br />
<a href="https://github.com/plumatic/schema">https://github.com/plumatic/schema</a>
</li>

<li>Zip archiv s&nbsp;Clojure 1.9.0<br />
<a href="http://repo1.maven.org/maven2/org/clojure/clojure/1.9.0/clojure-1.9.0.zip">http://repo1.maven.org/maven2/org/clojure/clojure/1.9.0/clojure-1.9.0.zip</a>
</li>

<li>Clojure 1.9 is now available<br />
<a href="https://clojure.org/news/2017/12/08/clojure19">https://clojure.org/news/2017/12/08/clojure19</a>
</li>

<li>Deps and CLI Guide<br />
<a href="https://clojure.org/guides/deps_and_cli">https://clojure.org/guides/deps_and_cli</a>
</li>

<li>Changes to Clojure in Version 1.9<br />
<a href="https://github.com/clojure/clojure/blob/master/changes.md">https://github.com/clojure/clojure/blob/master/changes.md</a>
</li>

<li>clojure.spec - Rationale and Overview<br />
<a href="https://clojure.org/about/spec">https://clojure.org/about/spec</a>
</li>

<li>Zip archiv s&nbsp;Clojure 1.8.0<br />
<a href="http://repo1.maven.org/maven2/org/clojure/clojure/1.8.0/clojure-1.8.0.zip">http://repo1.maven.org/maven2/org/clojure/clojure/1.8.0/clojure-1.8.0.zip</a>
</li>

<li>Clojure 1.8 is now available<br />
<a href="http://clojure.org/news/2016/01/19/clojure18">http://clojure.org/news/2016/01/19/clojure18</a>
</li>

<li>Socket Server REPL<br />
<a href="http://dev.clojure.org/display/design/Socket+Server+REPL">http://dev.clojure.org/display/design/Socket+Server+REPL</a>
</li>

<li>CLJ-1671: Clojure socket server<br />
<a href="http://dev.clojure.org/jira/browse/CLJ-1671">http://dev.clojure.org/jira/browse/CLJ-1671</a>
</li>

<li>CLJ-1449: Add clojure.string functions for portability to ClojureScript<br />
<a href="http://dev.clojure.org/jira/browse/CLJ-1449">http://dev.clojure.org/jira/browse/CLJ-1449</a>
</li>

<li>Launching a Socket Server<br />
<a href="http://clojure.org/reference/repl_and_main#_launching_a_socket_server">http://clojure.org/reference/repl_and_main#_launching_a_socket_server</a>
</li>

<li>API for clojure.string<br />
<a href="http://clojure.github.io/clojure/branch-master/clojure.string-api.html">http://clojure.github.io/clojure/branch-master/clojure.string-api.html</a>
</li>

<li>Clojars:<br />
<a href="https://clojars.org/">https://clojars.org/</a>
</li>

<li>Seznam knihoven na Clojars:<br />
<a href="https://clojars.org/projects">https://clojars.org/projects</a>
</li>

<li>Clojure Cookbook: Templating HTML with Enlive<br />
<a href="https://github.com/clojure-cookbook/clojure-cookbook/blob/master/07_webapps/7-11_enlive.asciidoc">https://github.com/clojure-cookbook/clojure-cookbook/blob/master/07_webapps/7-11_enlive.asciidoc</a>
</li>

<li>An Introduction to Enlive<br />
<a href="https://github.com/swannodette/enlive-tutorial/">https://github.com/swannodette/enlive-tutorial/</a>
</li>

<li>Enlive na GitHubu<br />
<a href="https://github.com/cgrand/enlive">https://github.com/cgrand/enlive</a>
</li>

<li>Expectations: příklady atd.<br />
<a href="http://jayfields.com/expectations/">http://jayfields.com/expectations/</a>
</li>

<li>Expectations na GitHubu<br />
<a href="https://github.com/jaycfields/expectations">https://github.com/jaycfields/expectations</a>
</li>

<li>Lein-expectations na GitHubu<br />
<a href="https://github.com/gar3thjon3s/lein-expectations">https://github.com/gar3thjon3s/lein-expectations</a>
</li>

<li>Testing Clojure With Expectations<br />
<a href="https://semaphoreci.com/blog/2014/09/23/testing-clojure-with-expectations.html">https://semaphoreci.com/blog/2014/09/23/testing-clojure-with-expectations.html</a>
</li>

<li>Clojure testing TDD/BDD libraries: clojure.test vs Midje vs Expectations vs Speclj<br />
<a href="https://www.reddit.com/r/Clojure/comments/1viilt/clojure_testing_tddbdd_libraries_clojuretest_vs/">https://www.reddit.com/r/Clojure/comments/1viilt/clojure_testing_tddbdd_libraries_clojuretest_vs/</a>
</li>

<li>Testing: One assertion per test<br />
<a href="http://blog.jayfields.com/2007/06/testing-one-assertion-per-test.html">http://blog.jayfields.com/2007/06/testing-one-assertion-per-test.html</a>
</li>

<li>Rewriting Your Test Suite in Clojure in 24 hours<br />
<a href="http://blog.circleci.com/rewriting-your-test-suite-in-clojure-in-24-hours/">http://blog.circleci.com/rewriting-your-test-suite-in-clojure-in-24-hours/</a>
</li>

<li>Clojure doc: zipper<br />
<a href="http://clojuredocs.org/clojure.zip/zipper">http://clojuredocs.org/clojure.zip/zipper</a>
</li>

<li>Clojure doc: parse<br />
<a href="http://clojuredocs.org/clojure.xml/parse">http://clojuredocs.org/clojure.xml/parse</a>
</li>

<li>Clojure doc: xml-zip<br />
<a href="http://clojuredocs.org/clojure.zip/xml-zip">http://clojuredocs.org/clojure.zip/xml-zip</a>
</li>

<li>Clojure doc: xml-seq<br />
<a href="http://clojuredocs.org/clojure.core/xml-seq">http://clojuredocs.org/clojure.core/xml-seq</a>
</li>

<li>Parsing XML in Clojure<br />
<a href="https://github.com/clojuredocs/guides">https://github.com/clojuredocs/guides</a>
</li>

<li>Clojure Zipper Over Nested Vector<br />
<a href="https://vitalyper.wordpress.com/2010/11/23/clojure-zipper-over-nested-vector/">https://vitalyper.wordpress.com/2010/11/23/clojure-zipper-over-nested-vector/</a>
</li>

<li>Understanding Clojure's PersistentVector implementation<br />
<a href="http://blog.higher-order.net/2009/02/01/understanding-clojures-persistentvector-implementation">http://blog.higher-order.net/2009/02/01/understanding-clojures-persistentvector-implementation</a>
</li>

<li>Understanding Clojure's PersistentHashMap (deftwice...)<br />
<a href="http://blog.higher-order.net/2009/09/08/understanding-clojures-persistenthashmap-deftwice.html">http://blog.higher-order.net/2009/09/08/understanding-clojures-persistenthashmap-deftwice.html</a>
</li>

<li>Assoc and Clojure's PersistentHashMap: part ii<br />
<a href="http://blog.higher-order.net/2010/08/16/assoc-and-clojures-persistenthashmap-part-ii.html">http://blog.higher-order.net/2010/08/16/assoc-and-clojures-persistenthashmap-part-ii.html</a>
</li>

<li>Ideal Hashtrees (paper)<br />
<a href="http://lampwww.epfl.ch/papers/idealhashtrees.pdf">http://lampwww.epfl.ch/papers/idealhashtrees.pdf</a>
</li>

<li>4Clojure<br />
<a href="http://www.4clojure.com/">http://www.4clojure.com/</a>
</li>

<li>ClojureDoc (rozcestník s&nbsp;dokumentací jazyka Clojure)<br />
<a href="http://clojuredocs.org/">http://clojuredocs.org/</a>
</li>

<li>Clojure (na Wikipedia EN)<br />
<a href="http://en.wikipedia.org/wiki/Clojure">http://en.wikipedia.org/wiki/Clojure</a>
</li>

<li>Clojure (na Wikipedia CS)<br />
<a href="http://cs.wikipedia.org/wiki/Clojure">http://cs.wikipedia.org/wiki/Clojure</a>
</li>

<li>SICP (The Structure and Interpretation of Computer Programs)<br />
<a href="http://mitpress.mit.edu/sicp/">http://mitpress.mit.edu/sicp/</a>
</li>

<li>Pure function<br />
<a href="http://en.wikipedia.org/wiki/Pure_function">http://en.wikipedia.org/wiki/Pure_function</a>
</li>

<li>Funkcionální programování<br />
<a href="http://cs.wikipedia.org/wiki/Funkcionální_programování">http://cs.wikipedia.org/wiki/Funkcionální_programování</a>
</li>

<li>Čistě funkcionální (datové struktury, jazyky, programování)<br />
<a href="http://cs.wikipedia.org/wiki/Čistě_funkcionální">http://cs.wikipedia.org/wiki/Čistě_funkcionální</a>
</li>

<li>Clojure Macro Tutorial (Part I, Getting the Compiler to Write Your Code For You)<br />
<a href="http://www.learningclojure.com/2010/09/clojure-macro-tutorial-part-i-getting.html">http://www.learningclojure.com/2010/09/clojure-macro-tutorial-part-i-getting.html</a>
</li>

<li>Clojure Macro Tutorial (Part II: The Compiler Strikes Back)<br />
<a href="http://www.learningclojure.com/2010/09/clojure-macro-tutorial-part-ii-compiler.html">http://www.learningclojure.com/2010/09/clojure-macro-tutorial-part-ii-compiler.html</a>
</li>

<li>Clojure Macro Tutorial (Part III: Syntax Quote)<br />
<a href="http://www.learningclojure.com/2010/09/clojure-macro-tutorial-part-ii-syntax.html">http://www.learningclojure.com/2010/09/clojure-macro-tutorial-part-ii-syntax.html</a>
</li>

<li>Tech behind Tech: Clojure Macros Simplified<br />
<a href="http://techbehindtech.com/2010/09/28/clojure-macros-simplified/">http://techbehindtech.com/2010/09/28/clojure-macros-simplified/</a>
</li>

<li>Fatvat - Exploring functional programming: Clojure Macros<br />
<a href="http://www.fatvat.co.uk/2009/02/clojure-macros.html">http://www.fatvat.co.uk/2009/02/clojure-macros.html</a>
</li>

</ol>



<p></p><p></p>
<p><small>Autor: <a href="http://www.fit.vutbr.cz/~tisnovpa">Pavel Tišnovský</a> &nbsp; 2021</small></p>
</body>
</html>
