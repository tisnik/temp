<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
        "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html>
<head>
<title>Řídicí struktury využitelné v programovacím jazyku Clojure (dokončení)</title>
<meta name="Author" content="Pavel Tisnovsky" />
<meta name="Generator" content="vim" />
<meta http-equiv="content-type" content="text/html; charset=utf-8" />
<style type="text/css">
         body {color:#000000; background:#ffffff;}
         h1  {font-family: arial, helvetica, sans-serif; color:#ffffff; background-color:#c00000; text-align:center; padding-left:1em}
         h2  {font-family: arial, helvetica, sans-serif; color:#ffffff; background-color:#0000c0; padding-left:1em; text-align:left}
         h3  {font-family: arial, helvetica, sans-serif; color:#000000; background-color:#c0c0c0; padding-left:1em; text-align:left}
         h4  {font-family: arial, helvetica, sans-serif; color:#000000; background-color:#e0e0e0; padding-left:1em; text-align:left}
         a   {font-family: arial, helvetica, sans-serif;}
         li  {font-family: arial, helvetica, sans-serif; color:#000000; text-align:justify; width:450px;}
         ol  {font-family: arial, helvetica, sans-serif; color:#000000; text-align:justify; width:450px;}
         ul  {font-family: arial, helvetica, sans-serif; color:#000000; text-align:justify; width:450px;}
         p   {font-family: arial, helvetica, sans-serif; color:#000000; text-align:justify;}
         pre {background:#e0e0e0}
</style>
</head>

<body>

<h1>Řídicí struktury využitelné v programovacím jazyku Clojure (dokončení)</h1>

<h3>Pavel Tišnovský</h3>

<p></p>

<h1>Úvodník</h1>

<p></p>



<h2>Obsah</h2>

<p><a href="#k01">*** 1. Řídicí struktury využitelné v&nbsp;programovacím jazyku Clojure (dokončení)</a></p>
<p><a href="#k02">*** 2. Makro <strong>cond-&gt;</strong></a></p>
<p><a href="#k03">*** 3. Vyhodnocování všech větví makrem <strong>cond-&gt;</strong></a></p>
<p><a href="#k04">*** 4. Expanze makra <strong>cond-&gt;</strong></a></p>
<p><a href="#k05">*** 5. Makro <strong>cond-&gt;&gt;</strong></a></p>
<p><a href="#k06">*** 6. Expanze makra <strong>cond-&gt;&gt;</strong></a></p>
<p><a href="#k07">*** 7. Jedno z&nbsp;nejsložitějších maker ze standardní knihovny: <strong>case</strong></a></p>
<p><a href="#k08">*** 8. Expanze makra case a forma vygenerovaného bajtkódu</a></p>
<p><a href="#k09">*** 9. Makra ze jmenného prostoru clojure.core.logic</a></p>
<p><a href="#k10">*** 10. Od &bdquo;jednorozměrných&ldquo; rozhodovacích konstrukcí ke konstrukcím dvourozměrným</a></p>
<p><a href="#k11">*** 11. Makro <strong>cond-table</strong></a></p>
<p><a href="#k12">*** 12. Příklady použití makra <strong>cond-table</strong></a></p>
<p><a href="#k13">*** 13. </a></p>
<p><a href="#k14">*** 14. </a></p>
<p><a href="#k15">*** 15. </a></p>
<p><a href="#k16">*** 16. Krátký přehled dalších maker: <strong>if-not</strong></a></p>
<p><a href="#k17">*** 17. Příloha: zdrojové kódy výše popsaných maker</a></p>
<p><a href="#k18">*** 18. Repositář s&nbsp;demonstračními příklady</a></p>
<p><a href="#k19">*** 19. Odkazy na předchozí části seriálu o programovacím jazyku Clojure</a></p>
<p><a href="#k20">*** 20. Odkazy na Internetu</a></p>



<p><a name="k01"></a></p>
<h2 id="k01">1. Řídicí struktury využitelné v&nbsp;programovacím jazyku Clojure (dokončení)</h2>

<p>V&nbsp;dnešním článku dokončíme téma, kterému jsme se věnovali <a
href="https://www.root.cz/clanky/ridici-struktury-vyuzitelne-v-programovacim-jazyku-clojure/">minule</a>.
Nejprve si popíšeme některá další (a nutno říci, že velmi často používaná)
makra nabízená standardní knihovnou programovacího jazyka Clojure. Jedná se
především o makra <strong>cond-&gt;</strong>, <strong>cond-&gt;&gt;</strong>
(což jsou varianty makra <strong>cond</strong>, které již dobře známe), dále
pak o makro <strong>if-not</strong> a v&nbsp;neposlední řadě o interně dosti
složité makro nazvané příhodně <strong>case</strong>. To však není zdaleka vše,
protože existují i další makra určená pro řízení toku programu. Především se
jedná o makra nabízená ve jmenném prostoru <strong>clojure.core.logic</strong>,
zejména o makra nazvaná <strong>conde</strong>, <strong>condu</strong> a
<strong>conda</strong>. Asi nebude velkým překvapením, že se opět jedná o
varianty standardního makra <strong>cond</strong>.</p>

<p>Ještě zajímavější jsou však makra z&nbsp;vybraných nestandardních knihoven,
zejména pak velmi povedené makro <strong>cond-table</strong>, jehož autorem je
Daniel Gregoire. S&nbsp;využitím <strong>cond-table</strong> je možné vytvářet
i složité rozhodovací tabulky (což jsou de facto dvourozměrné rozhodovací
struktury, které možnosti jednorozměrných struktur dosti podstatným způsobem
zobecňují). Zmíníme se i o složitějších rozhodovacích strukturách nabízených
například knihovnou <strong>special</strong>, <strong>better-cond</strong>,
<strong>cond-let</strong> atd.</p>

<table>
<tr><th> #</th><th>Konstrukce</th><th>Článek/kapitola</th><th>Typ</th><th>Stručný popis</th></tr>
<tr><td> 1</td><td>if</td><td><a href="https://www.root.cz/clanky/ridici-struktury-vyuzitelne-v-programovacim-jazyku-clojure#k02">1/2</a></td><td>speciální forma</td><td>základní rozhodovací konstrukce, základ pro další makra</td></tr>
<tr><td> 2</td><td>if-not</td><td><a href="#k16">2/16</a></td><td>makro</td><td>stejné jako speciální forma <strong>if</strong>, ovšem s&nbsp;negovanou podmínkou</td></tr>
<tr><td> 3</td><td>if+do</td><td><a href="https://www.root.cz/clanky/ridici-struktury-vyuzitelne-v-programovacim-jazyku-clojure#k03">1/3</a></td><td>dvě speciální formy</td><td>použito ve chvíli, kdy je nutné do jedné větve či obou větví zapsat více výrazů</td></tr>
<tr><td> 4</td><td>if-let</td><td><a href="https://www.root.cz/clanky/ridici-struktury-vyuzitelne-v-programovacim-jazyku-clojure#k05">1/5</a></td><td>makro</td><td>kombinace speciálních forem <strong>if</strong> a <strong>let</strong></td></tr>
<tr><td> 5</td><td>if-some</td><td><a href="https://www.root.cz/clanky/ridici-struktury-vyuzitelne-v-programovacim-jazyku-clojure#k06">1/6</a></td><td>makro</td><td>kombinace speciálních forem <strong>if</strong> (test na <strong>nil</strong>) a <strong>let</strong></td></tr>
<tr><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td></tr>
<tr><td> 6</td><td>and</td><td><a href="https://www.root.cz/clanky/ridici-struktury-vyuzitelne-v-programovacim-jazyku-clojure#k07">1/7</a></td><td>makro</td><td>postupné vyhodnocování předaných výrazů až do chvíle, kdy se vrátí <strong>nil</strong> či <strong>false</strong></td></tr>
<tr><td> 7</td><td>or</td><td><a href="https://www.root.cz/clanky/ridici-struktury-vyuzitelne-v-programovacim-jazyku-clojure#k07">1/7</a></td><td>makro</td><td>postupné vyhodnocování předaných výrazů až do chvíle, kdy se vrátí <strong>true</strong></td></tr>
<tr><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td></tr>
<tr><td> 8</td><td>when</td><td><a href="https://www.root.cz/clanky/ridici-struktury-vyuzitelne-v-programovacim-jazyku-clojure#k04">1/4</a></td><td>makro</td><td>vhodná náhrada za <strong>if</strong> s&nbsp;jedinou větví s&nbsp;více výrazy</td></tr>
<tr><td> 9</td><td>when-not</td><td><a href="https://www.root.cz/clanky/ridici-struktury-vyuzitelne-v-programovacim-jazyku-clojure#k04">1/4</a></td><td>makro</td><td>vhodná náhrada za <strong>if-not</strong> s&nbsp;jedinou větví s&nbsp;více výrazy</td></tr>
<tr><td>10</td><td>when-let</td><td><a href="https://www.root.cz/clanky/ridici-struktury-vyuzitelne-v-programovacim-jazyku-clojure#k05">1/5</a></td><td>makro</td><td>kombinace speciálních forem <strong>when</strong> a <strong>let</strong></td></tr>
<tr><td>11</td><td>when-some</td><td><a href="https://www.root.cz/clanky/ridici-struktury-vyuzitelne-v-programovacim-jazyku-clojure#k06">1/6</a></td><td>makro</td><td>kombinace speciálních forem <strong>when</strong> (test na <strong>nil</strong>) a <strong>let</strong></td></tr>
<tr><td>12</td><td>when-first</td><td>&nbsp;</td><td>makro</td><td>použito při testu prvního prvku sekvence s&nbsp;následným zpracováním sekvence</td></tr>
<tr><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td></tr>
<tr><td>13</td><td>cond</td><td><a href="https://www.root.cz/clanky/ridici-struktury-vyuzitelne-v-programovacim-jazyku-clojure#k08">1/8</a></td><td>makro</td><td>postupné testování podmínek, pokud je podmínka splněna, vrátí se hodnota příslušného výrazu</td></tr>
<tr><td>14</td><td>cond + :else </td><td><a href="https://www.root.cz/clanky/ridici-struktury-vyuzitelne-v-programovacim-jazyku-clojure#k08">1/8</a></td><td>makro</td><td>typické použití makra <strong>cond</strong> s&nbsp;větví <strong>:else</strong> nebo <strong>:default</strong></td></tr>
<tr><td>15</td><td>condp</td><td><a href="https://www.root.cz/clanky/ridici-struktury-vyuzitelne-v-programovacim-jazyku-clojure#k10">1/10</a></td><td>makro</td><td>postupné dosazování testované hodnoty do zadaného výrazu, obdoba <strong>switch-case</strong></td></tr>
<tr><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td></tr>
<tr><td>16</td><td>conde</td><td><a href="#k09">2/9</a></td><td>makro</td><td>makro z&nbsp;knihovny <strong>clojure.core.logic</strong></td></tr>
<tr><td>17</td><td>condu</td><td><a href="#k09">2/9</a></td><td>makro</td><td>makro z&nbsp;knihovny <strong>clojure.core.logic</strong></td></tr>
<tr><td>18</td><td>conda</td><td><a href="#k09">2/9</a></td><td>makro</td><td>makro z&nbsp;knihovny <strong>clojure.core.logic</strong></td></tr>
<tr><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td></tr>
<tr><td>19</td><td>cond-&gt;</td><td><a href="#k02">2/2</a></td><td>makro</td><td>odvozeno od <strong>cond</strong> a threading makra -&gt;</td></tr>
<tr><td>20</td><td>cond-&gt;&gt;</td><td><a href="#k05">2/5</a></td><td>makro</td><td>odvozeno od <strong>cond</strong> a threading makra -&gt;</td></tr>
<tr><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td></tr>
<tr><td>21</td><td>case</td><td><a href="#k07">2/7</a></td><td>makro</td><td>makro</td></tr>
<tr><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td></tr>
<tr><td>22</td><td>cond-table</td><td><a href="#k11">2/11</a></td><td>makro</td><td>nová nestandardní konstrukce</td></tr>
</table>



<p><a name="k02"></a></p>
<h2 id="k02">2. Makro <strong>cond-&gt;</strong></h2>

; První makro s nímž se dnes setkáme a které nám umožňuje zapsat rozvětvení na základě vyhodnocovaných podmínek, se jmenuje cond->:

(doc cond->)
-------------------------
clojure.core/cond->
;; ([expr & clauses])
;; Macro
;;   Takes an expression and a set of test/form pairs. Threads expr (via ->)
;;   through each form for which the corresponding test
;;   expression is true. Note that, unlike cond branching, cond-> threading does
;;   not short circuit after the first true test expression.

Toto na první pohled poněkud neobvyklé pojmenování nám naznačuje, že se bude jednat o konstrukci, která je založena na takzvaném threading makru. Samotné threading makro je přitom jednou z nejelegantnějších konstrukcí programovacího jazyka Clojure vůbec:

(doc ->)
;; -------------------------
;; clojure.core/->
;; ([x & forms])
;; Macro
;;   Threads the expr through the forms. Inserts x as the
;;   second item in the first form, making a list of it if it is not a
;;   list already. If there are more forms, inserts the first form as the
;;   second item in second form, etc.

; Toto makro nám umožňuje zapisovat sérii funkcí, mezi nimiž se předávají parametry podobně, jako je tomu v klasické koloně. Samotný zápis je přitom velmi stručný a obejde se bez řady závorek:

(-> 1
    inc
    println)
; 2

(-> (range 1 10)
    count
    println)
; 9

; Volat je ovšem možné i funkce s větším množstvím parametrů, včetně metod:
(-> "Hello world."
    .toUpperCase
    (.replace "." "!")
    println)
; HELLO WORLD!

(-> "Hello world."
    .toUpperCase
    (.replace "." "!")
    (.split " ")
    first
    println)
; HELLO

; Expanze tohoto makra vede k zápisu s velkým množstvím závorek tak typickým pro klasické LISPovské jazyky bez tohoto makra:
(macroexpand
  '(-> "Hello world."
      .toUpperCase
      (.replace "." "!")
      (.split " ")
      first
      println))

; S výsledkem:
; (println (first (.split (.replace (.toUpperCase "Hello world.") "." "!") " ")))

; Vraťme se však k makru cond->, které je odvozené od makra cond. Jeho činnost je následující: postupně jsou testovány jednotlivé podmínky (sudé parametry) a pokud je podmínka splněna, je do výrazu za ní (liché parametry) dosazen první parametr makra, podobně jako je tomu u výše zmíněného threading makra.

; V následujícím úryvku kódu se pokoušíme převést obsah řetězce na číselnou hodnotu, ovšem s testem, zda je vstupní hodnota skutečně řetězcem. S využitím makra cond-> se samotné x (tedy reference na převáděnou hodnotu) nemusí opakovat v podmínce i v převodní funkci:
(let [x "42"] 
  (cond-> x 
    (string? x) (Integer.)))
; 42

; Poněkud umělý příklad, který je na makru cond-> postaven, může testovat hodnotu parametru x a následně na základě hodnoty tohoto parametru provádí operace (inc x), (/ x 2) a (dec x):
(defn machina
  [x]
  (cond-> x 
    (odd? x)  inc
    (even? x) (/ 2)
    (zero? x) dec))

; Výše uvedenou funkci si otestujeme na vstupních hodnotách od nuly do deseti:
(doseq [x (range 0 11)]
  (println x (machina x)))

; S těmito výsledky:
; 0 -1
; 1 2
; 2 1
; 3 4
; 4 2
; 5 6
; 6 3
; 7 8
; 8 4
; 9 10
; 10 5




<p><a name="k03"></a></p>
<h2 id="k03">3. Vyhodnocování všech větví makrem <strong>cond-&gt;</strong></h2>

; Na rozdíl od makra cond, které při splnění podmínky již další podmínky netestuje, je tomu u makra cond-> jinak, protože se postupně prochází všechny podmínky. To může vést k chybám, zejména tehdy, pokud se použije větev :else (symbol :else se vždy vyhodnotí na pravdu). Pokud tedy předchozí příklad nepatrně upravíme:
(defn machina-2
  [x]
  (cond-> x 
    (odd? x)  inc
    (even? x) (/ 2)
    :else     dec))

; Získáme odlišné výsledky, což si ostatně můžeme velmi snadno ukázat:
(doseq [x (range 0 11)]
  (println x (machina x) (machina-2 x)))

; Tabulka vypsaná předchozí smyčkou:
; 0 -1 -1
; 1 2 1
; 2 1 0
; 3 4 3
; 4 2 1
; 5 6 5
; 6 3 2
; 7 8 7
; 8 4 3
; 9 10 9
; 10 5 4

; Ještě lépe je toto chování patrné v případě, že se v jednotlivých větvích nachází funkce s vedlejším efektem, zde konkrétně funkce println:
(defn machina-3
  [x]
  (cond-> x 
    (odd? x)  (println "odd")
    (even? x) (println "even")
    :else     (println "zero")))

; Zkusme si tuto funkci vyvolat postupně s hodnotami od 0 do 10:
(doseq [x (range 0 11)]
  (println x)
  (machina-3 x)
  (println))

; Z výsledků je patrné, že se vždy vyhodnotí i poslední větev:
;; 0
;; 0 even
;; nil zero
;; 
;; 1
;; 1 odd
;; nil zero
;; 
;; 2
;; 2 even
;; nil zero
;; 
;; 3
;; 3 odd
;; nil zero
;; 
;; 4
;; 4 even
;; nil zero
;; 
;; 5
;; 5 odd
;; nil zero
;; 
;; 6
;; 6 even
;; nil zero
;; 
;; 7
;; 7 odd
;; nil zero
;; 
;; 8
;; 8 even
;; nil zero
;; 
;; 9
;; 9 odd
;; nil zero
;; 
;; 10
;; 10 even
;; nil zero

; Poznámka: funkce println v tomto případě ve skutečnosti vypíše i hodnotu parametru x, který je do println dosazen makrem cond->.



<p><a name="k04"></a></p>
<h2 id="k04">4. Expanze makra <strong>cond-&gt;</strong></h2>

<p>Otestovat si můžeme i expanzi makra <strong>cond-&gt;</strong>. Pro výpis
expandovaného makra opět použijeme známou funkci
<strong>macroexpand</strong>:</p>

<pre>
<strong>(macroexpand</strong>
  <strong>'(<u>cond-&gt;</u> x </strong>
     <strong>(odd? x)  inc</strong>
     <strong>(even? x) (/ 2)</strong>
     <strong>(zero? x) inc))</strong>
</pre>

<p>Výsledkem by měl být tento kód (pomocná automaticky vygenerovaná proměnná
může mít ovšem odlišné jméno):</p>

<pre>
(let* [G__10086 x
       G__10086 (if (odd? x)  (clojure.core/-&gt; G__10086 inc) G__10086)
       G__10086 (if (even? x) (clojure.core/-&gt; G__10086 (/ 2)) G__10086)]
  (if (zero? x) (clojure.core/-&gt; G__10086 inc) G__10086))
</pre>

<p><div class="rs-tip-major">Poznámka: povšimněte si, že se skutečně postupně
vyhodnocují všechny větve a současně se interně používá threading makro
<strong>-&gt;</strong>.</div></p>

<p>Příklad expanze ne plně funkčního kódu s&nbsp;větví
<strong>else</strong>:</p>

<pre>
<strong>(macroexpand</strong>
  <strong>'(<u>cond-&gt;</u> x </strong>
     <strong>(odd? x)  inc</strong>
     <strong>(even? x) (/ 2)</strong>
     <strong>:else     inc))</strong>
</pre>

<p>Nyní bude expanze vypadat následovně:</p>

<pre>
(let* [G__10117 x
       G__10117 (if (odd? x) (clojure.core/-&gt; G__10117 inc) G__10117)
       G__10117 (if (even? x) (clojure.core/-&gt; G__10117 (/ 2)) G__10117)]
  (if :else (clojure.core/-&gt; G__10117 inc) G__10117))
</pre>



<p><a name="k05"></a></p>
<h2 id="k05">5. Makro <strong>cond-&gt;&gt;</strong></h2>

<p>Druhé makro určené pro implementaci rozvětvení na základě zadaných podmínek
se jmenuje <strong>cond-&gt;&gt;</strong>:</p>

<pre>
<strong>(doc <u>cond-&gt;&gt;</u>)</strong>
&nbsp;
-------------------------
clojure.core/cond-&gt;&gt;
([expr &amp; clauses])
Macro
  Takes an expression and a set of test/form pairs. Threads expr (via -&gt;&gt;)
  through each form for which the corresponding test expression
  is true.  Note that, unlike cond branching, cond-&gt;&gt; threading does not short circuit
  after the first true test expression.
</pre>

<p>Opět se jedná o variantu makra <strong>cond</strong>, tentokrát ovšem
zkombinovanou s alternativní formou threading makra
<strong>-&gt;&gt;</strong>:</p>

<pre>
<strong>(doc -&gt;&gt;)</strong>
&nbsp;
-------------------------
clojure.core/-&gt;&gt;
([x &amp; forms])
Macro
  Threads the expr through the forms. Inserts x as the
  last item in the first form, making a list of it if it is not a
  list already. If there are more forms, inserts the first form as the
  last item in second form, etc.
</pre>

<p>Na rozdíl od výše popsaného makra <strong>cond-&gt;</strong> se liší
dosazování parametru do jednotlivých větví &ndash; parametr je dosazen na
poslední místo výrazu (což je typicky volání nějaké funkce) a nikoli na místo
první. Pokud tedy například použijeme tuto funkci:</p>

<pre>
<strong>(defn machina-3</strong>
  <strong>[x]</strong>
  <strong>(<u>cond-&gt;&gt;</u> x </strong>
    <strong>(odd? x)  inc</strong>
    <strong>(even? x) (/ 2)))</strong>
</pre>

<p>bude se ve druhé větvi vyhodnocovat funkce <strong>(/ 2 x)</strong> a nikoli
<strong>(/ x 2)</strong>.</p>

<p>Výše definovanou funkci <strong>machina-3</strong> si otestujeme na
vstupních hodnotách od nuly do deseti:</p>

<pre>
<strong>(doseq [x (range 1 11)]</strong>
  <strong>(println x (machina-3 x)))</strong>
</pre>

<p>S&nbsp;výsledkem:</p>

<pre>
1 2
2 1
3 4
4 1/2
5 6
6 1/3
7 8
8 1/4
9 10
10 1/5
</pre>

<p>Nepatrně složitější příklad, který se snaží převést parametr na celé
číslo:</p>

<pre>
<strong>(defn -&gt;int</strong>
  <strong>[x]</strong>
  <strong>(<u>cond-&gt;&gt;</u> x </strong>
    <strong>(string? x)   Integer.</strong>
    <strong>(float?  x)   int</strong>
    <strong>(rational? x) int</strong>
    <strong>(integer? x)  identity))</strong>
</pre>

<p>Chování této funkce si můžeme snadno otestovat:</p>

<pre>
<strong>(println (-&gt;int 3.14))</strong>
3
&nbsp;
<strong>(println (-&gt;int 10/3))</strong>
3
&nbsp;
<strong>(println (-&gt;int 42))</strong>
42
&nbsp;
<strong>(println (-&gt;int "1000"))</strong>
1000
</pre>



<p><a name="k06"></a></p>
<h2 id="k06">6. Expanze makra <strong>cond-&gt;&gt;</strong></h2>

; Způsob expanze makra cond->> si ukážeme na příklad převodníku hodnoty typu řetězec, číslo s plovoucí řádovou čárkou, zlomek či celé číslo na hodnotu typu integer (tedy celé číslo):

(macroexpand
  '(cond->> x 
    (string? x)   Integer.
    (float?  x)   int
    (rational? x) int
    (integer? x)  identity))

; Výsledek expanze by měl vypadat následovně:
;; (let*
;;   [G__10237 x
;;    G__10237 (if (string? x) (clojure.core/->> G__10237 Integer.) G__10237)
;;    G__10237 (if (float? x) (clojure.core/->> G__10237 int) G__10237)
;;    G__10237 (if (rational? x) (clojure.core/->> G__10237 int) G__10237)]
;;   (if (integer? x) (clojure.core/->> G__10237 identity) G__10237))

; Poznámka: povšimněte si, že se skutečně jednotlivá přiřazení provádí bez ohledu na to, zda byl předchozí test úspěšný nebo neúspěšný. To je největší rozdíl maker cond-> a cond->> oproti makru cond.



<p><a name="k07"></a></p>
<h2 id="k07">7. Jedno z&nbsp;nejsložitějších maker ze standardní knihovny: <strong>case</strong></h2>

; Nejsložitější makro ze standardní knihovny, které si dnes popíšeme, se jmenuje case:

(doc case)
;; -------------------------
;; clojure.core/case
;; ([e & clauses])
;; Macro
;;   Takes an expression, and a set of clauses.
;; 
;;   Each clause can take the form of either:
;; 
;;   test-constant result-expr
;; 
;;   (test-constant1 ... test-constantN)  result-expr
;; 
;;   The test-constants are not evaluated. They must be compile-time
;;   literals, and need not be quoted.  If the expression is equal to a
;;   test-constant, the corresponding result-expr is returned. A single
;;   default expression can follow the clauses, and its value will be
;;   returned if no clause matches. If no default expression is provided
;;   and no clause matches, an IllegalArgumentException is thrown.
;; 
;;   Unlike cond and condp, case does a constant-time dispatch, the
;;   clauses are not considered sequentially.  All manner of constant
;;   expressions are acceptable in case, including numbers, strings,
;;   symbols, keywords, and (Clojure) composites thereof. Note that since
;;   lists are used to group multiple constants that map to the same
;;   expression, a vector can be used to match a list if needed. The
;;   test-constants need not be all of the same type.

; Toto makro se do značné míry podobá céčkové či javovské konstrukci switch, protože výsledek zadaného výrazu je porovnáván s konstantami zapsanými před jednotlivými větvemi. To sice není tak obecné řešení, jako je tomu v případě maker cond a condp, ovšem výsledkem by měl být rychlejší běh, protože se interně zkonstruuje mapa s jednotlivými větvemi a výběr větve je tak proveden v téměř konstantním čase a nikoli postupným porovnáváním.

; Poznámka: v předchozím odstavci bylo napsáno "téměř konstantní čas". Zcela přesně se jedná o časovou složitost O(log32N), což je ovšem pro malé N (což se dá u konstrukce case předpokládat) skutečně prakticky konstantní čas.

; Podívejme se nyní na jednotlivé způsoby použití makra case pro vytvoření rozhodovací konstrukce.

(defn say-number
  [x]
  (case x
    0 "nula"
    1 "jedna"
    2 "dva"))

(println (say-number 0))
; nula
(println (say-number 1))
; jedna
(println (say-number 2))
; dva

(println (say-number 3))
Execution error (IllegalArgumentException) at user/say-number (REPL:3).
No matching clause: 3

(defn say-number
  [x]
  (case x
    0 "nula"
    1 "jedna"
    2 "dva"
      "nezname cislo"))

; Otestování funkce say-number:
(println (say-number 0))
; nula
(println (say-number 1))
; jedna
(println (say-number 2))
; dva
(println (say-number 3))
; nezname cislo

; Nejsme ovšem omezeni pouze na celočíselné konstanty
(defn string->number
  [x]
  (case x
    "nula"  0
    "jedna" 1
    "dva"   2
            -1))

; Otestování funkce string->number:
(println (string->number "nula"))
; 0
(println (string->number "jedna"))
; 1
(println (string->number "milion"))
-1

; Jednu větev je možné provést pro více konstant, které musí být umístěny do závorek:

(defn string->number
  [x]
  (case x
    ("nic" "nula")  0
    "jedna"         1
    ("dva" "dve")   2
                   -1))

(println (string->number "nula"))
; 0
(println (string->number "dva"))
; 2
(println (string->number "dve"))
; 2

; Konstantami mohou být v případě potřeby i vektory atd.
(defn say-vector
  [x]
  (case x
    []    "Empty vector"
    [1]   "Vector with just one item"
    [1 2] "Sequence of two numbers 1 and 2"
          "I don't know"))

(say-vector [])
; "Empty vector"


(say-vector [1 2])
; "Sequence of two numbers 1 and 2"

; Poznámka: pokud je možné namísto testů použít konstanty, je vždy výhodnější v kódu makro case a nikoli condp či dokonce cond.

; Makro cond je sice nejuniverzálnější, ale taktéž delší na zápis a i výpočetně složité:
(cond
  (= x 0) "Nula"
  (= x 1) "Jedna"
  (= x 2) "Dva"
  :else   "Nevim")

; Makro condp umožňuje kratší zápis podmínky na jediném místě:
(condp = x
  0 "Nula"
  1 "Jedna"
  2 "Dva"
    "Nevim")

; Nejméně univerzální je case, ovšem na druhou stranu je nejrychlejší:
(case x
  0 "Nula"
  1 "Jedna"
  2 "Dva"
    "Nevim")

; Rychlejší rozeskoky v případě použití makra case by mělo být možné i naměřit, pochopitelně ovšem za předpokladu, že důvěřujete mikrobenchmarkům:

(defn f1
  [x]
  (cond
    (= x 0) "Nula"
    (= x 1) "Jedna"
    (= x 2) "Dva"
    :else   "Nevim"))

(defn f2
  [x]
  (condp = x
    0 "Nula"
    1 "Jedna"
    2 "Dva"
    "Nevim"))

(defn f3
  [x]
  (case x
    0 "Nula"
    1 "Jedna"
    2 "Dva"
    "Nevim"))

(time (doseq [_ (range 100000000)]
        (doseq [x (range 0 4)]
          (f1 x))))
; "Elapsed time: 4252.930607 msecs"

(time (doseq [_ (range 100000000)]
        (doseq [x (range 0 4)]
          (f2 x))))
; "Elapsed time: 4417.662463 msecs"

(time (doseq [_ (range 100000000)]
        (doseq [x (range 0 4)]
          (f3 x))))
; "Elapsed time: 3924.937731 msecs"

; Poznámka: na druhou stranu je nutné poznamenat, že u jazyka typu Clojure (dynamicky typovaný vysokoúrovňový jazyk běžící nad JVM) je většinou mnohem důležitější sémantika zapisovaných operací (tj. i zde má makro case význam) nad ušetřeným strojovým časem.



<p><a name="k08"></a></p>
<h2 id="k08">8. Expanze makra case a forma vygenerovaného bajtkódu</h2>

; V krátkosti se ještě zmiňme o expanzi makra case. Ta se v jednom ohledu odlišuje od expanze ostatních maker, a to konkrétně v tom ohledu, že výsledkem expanze není kód založený na speciální formě if. Namísto toho se v expanzi setkáme s case*, což je metoda implementovaná v Javě, která slouží ke konstrukci rozeskoku na úrovni bajtkódu. Ostatně se o tom můžeme velmi snadno přesvědčit:
(macroexpand
  '(case x
    0 "Nula"
    1 "Jedna"
    2 "Dva"
      "Nevim"))
;; (let*
;;  [G__11190 x]
;;  (case*
;;   G__11190
;;   0
;;   0
;;   "Nevim"
;;   {0 [0 "Nula"] 1 [1 "Jedna"] 2 [2 "Dva"]}
;;   :compact
;;   :int))

; Abychom pochopili, jak celá technologie pracuje, musíme si připomenout, že Clojure pracuje tak, že každou zapsanou formu přeloží (po expanzi maker) do bajtkódu JVM a teprve poté je tato forma spuštěna. A právě pro překlad do bajtkódu se interně používá třída Compiler, která konkrétně interní symbol case* přeloží s využitím instrukce tableswitch určené pro implementaci konstrukce switch z Javy (resp. přesněji switch v případě, že jsou použita celá čísla nebo výčtový typ, nikoli řetězce). V praxi vypadá překlad funkce f3:

(defn f3
  [x]
  (case x
    0 "Nula"
    1 "Jedna"
    2 "Dva"
    "Nevim"))

; následovně:

;; public static java.lang.Object invokeStatic(java.lang.Object x);
;;    0  aload_0 [x]
;;    1  aconst_null
;;    2  astore_0 [x]
;;    3  astore_1 [G__5991]
;;    4  aload_1 [G__5991]
;;    5  instanceof java.lang.Number [13]
;;    8  ifeq 89
;;   11  aload_1 [G__5991]
;;   12  checkcast java.lang.Number [13]
;;   15  invokevirtual java.lang.Number.intValue() : int [17]
;;   18  tableswitch default: 89
;;         case 0: 44
;;         case 1: 59
;;         case 2: 74
;;   44  aload_1 [G__5991]
;;   45  getstatic user$f3.const__0 : java.lang.Object [21]
;;   48  invokestatic clojure.lang.Util.equiv(java.lang.Object, java.lang.Object) : boolean [27]
;;   51  ifeq 89
;;   54  ldc <String "Nula"> [29]
;;   56  goto 91
;;   59  aload_1 [G__5991]
;;   60  getstatic user$f3.const__1 : java.lang.Object [32]
;;   63  invokestatic clojure.lang.Util.equiv(java.lang.Object, java.lang.Object) : boolean [27]
;;   66  ifeq 89
;;   69  ldc <String "Jedna"> [34]
;;   71  goto 91
;;   74  aload_1 [G__5991]
;;   75  getstatic user$f3.const__2 : java.lang.Object [37]
;;   78  invokestatic clojure.lang.Util.equiv(java.lang.Object, java.lang.Object) : boolean [27]
;;   81  ifeq 89
;;   84  ldc <String "Dva"> [39]
;;   86  goto 91
;;   89  ldc <String "Nevim"> [41]
;;   91  areturn

; Poznámka: https://github.com/gtrak/no.disassemble



<p><a name="k09"></a></p>
<h2 id="k09">9. Makra ze jmenného prostoru clojure.core.logic</h2>



<p><a name="k10"></a></p>
<h2 id="k10">10. Od &bdquo;jednorozměrných&ldquo; rozhodovacích konstrukcí ke konstrukcím dvourozměrným</h2>



<p><a name="k11"></a></p>
<h2 id="k11">11. Makro <strong>cond-table</strong></h2>



<p><a name="k12"></a></p>
<h2 id="k12">12. Příklady použití makra <strong>cond-table</strong></h2>



<p><a name="k13"></a></p>
<h2 id="k13">13. </h2>



<p><a name="k14"></a></p>
<h2 id="k14">14. </h2>



<p><a name="k15"></a></p>
<h2 id="k15">15. </h2>



<p><a name="k16"></a></p>
<h2 id="k16">16. </h2>



<p><a name="k17"></a></p>
<h2 id="k17">17. Příloha: zdrojové kódy výše popsaných maker</h2>

<pre>
<strong>(source if-let)</strong>
&nbsp;
(defmacro if-let
  "bindings =&gt; binding-form test

  If test is true, evaluates then with binding-form bound to the value of 
  test, if not, yields else"
  {:added "1.0"}
  ([bindings then]
   `(if-let ~bindings ~then nil))
  ([bindings then else &amp; oldform]
   (assert-args
     (vector? bindings) "a vector for its binding"
     (nil? oldform) "1 or 2 forms after binding vector"
     (= 2 (count bindings)) "exactly 2 forms in binding vector")
   (let [form (bindings 0) tst (bindings 1)]
     `(let [temp# ~tst]
        (if temp#
          (let [~form temp#]
            ~then)
          ~else)))))
</pre>


<strong>(source if-some)</strong>
&nbsp;
(defmacro if-some
  "bindings =&gt; binding-form test
&nbsp;
   If test is not nil, evaluates then with binding-form bound to the
   value of test, if not, yields else"
  {:added "1.6"}
  ([bindings then]
   `(if-some ~bindings ~then nil))
  ([bindings then else &amp; oldform]
   (assert-args
     (vector? bindings) "a vector for its binding"
     (nil? oldform) "1 or 2 forms after binding vector"
     (= 2 (count bindings)) "exactly 2 forms in binding vector")
   (let [form (bindings 0) tst (bindings 1)]
     `(let [temp# ~tst]
        (if (nil? temp#)
          ~else
          (let [~form temp#]
            ~then))))))
</pre>

<pre>
<strong>(source and)</strong>
&nbsp;
(defmacro and
  "Evaluates exprs one at a time, from left to right. If a form
  returns logical false (nil or false), and returns that value and
  doesn't evaluate any of the other expressions, otherwise it returns
  the value of the last expr. (and) returns true."
  {:added "1.0"}
  ([] true)
  ([x] x)
  ([x &amp; next]
   `(let [and# ~x]
      (if and# (and ~@next) and#))))
</pre>

<pre>
<strong>(source or)</strong>
&nbsp;
(defmacro or
  "Evaluates exprs one at a time, from left to right. If a form
  returns a logical true value, or returns that value and doesn't
  evaluate any of the other expressions, otherwise it returns the
  value of the last expression. (or) returns nil."
  {:added "1.0"}
  ([] nil)
  ([x] x)
  ([x &amp; next]
      `(let [or# ~x]
         (if or# or# (or ~@next)))))
</pre>

<pre>
<strong>(source when)</strong>
&nbsp;
(defmacro when
  "Evaluates test. If logical true, evaluates body in an implicit do."
  {:added "1.0"}
  [test &amp; body]
  (list 'if test (cons 'do body)))
</pre>


<pre>
<strong>(source when-not)</strong>
&nbsp;
(defmacro when-not
  "Evaluates test. If logical false, evaluates body in an implicit do."
  {:added "1.0"}
  [test &amp; body]
    (list 'if test nil (cons 'do body)))
</pre>


<pre>
<strong>(source when-let)</strong>
&nbsp;
(defmacro when-let
  "bindings =&gt; binding-form test
&nbsp;
  When test is true, evaluates body with binding-form bound to the value of test"
  {:added "1.0"}
  [bindings &amp; body]
  (assert-args
     (vector? bindings) "a vector for its binding"
     (= 2 (count bindings)) "exactly 2 forms in binding vector")
   (let [form (bindings 0) tst (bindings 1)]
    `(let [temp# ~tst]
       (when temp#
         (let [~form temp#]
           ~@body)))))
</pre>


<pre>
<strong>(source when-some)</strong>
&nbsp;
(defmacro when-some
  "bindings =&gt; binding-form test
&nbsp;
   When test is not nil, evaluates body with binding-form bound to the
   value of test"
  {:added "1.6"}
  [bindings &amp; body]
  (assert-args
     (vector? bindings) "a vector for its binding"
     (= 2 (count bindings)) "exactly 2 forms in binding vector")
   (let [form (bindings 0) tst (bindings 1)]
    `(let [temp# ~tst]
       (if (nil? temp#)
         nil
         (let [~form temp#]
           ~@body)))))
</pre>


<pre>
<strong>(source when-first)</strong>
&nbsp;
(defmacro when-first
  "bindings =&gt; x xs
&nbsp;
  Roughly the same as (when (seq xs) (let [x (first xs)] body)) but xs is evaluated only once"
  {:added "1.0"}
  [bindings &amp; body]
  (assert-args
     (vector? bindings) "a vector for its binding"
     (= 2 (count bindings)) "exactly 2 forms in binding vector")
  (let [[x xs] bindings]
    `(when-let [xs# (seq ~xs)]
       (let [~x (first xs#)]
           ~@body))))
</pre>


<pre>
<strong>(source cond)</strong>
&nbsp;
(defmacro cond
  "Takes a set of test/expr pairs. It evaluates each test one at a
  time.  If a test returns logical true, cond evaluates and returns
  the value of the corresponding expr and doesn't evaluate any of the
  other tests or exprs. (cond) returns nil."
  {:added "1.0"}
  [&amp; clauses]
    (when clauses
      (list 'if (first clauses)
            (if (next clauses)
                (second clauses)
                (throw (IllegalArgumentException.
                         "cond requires an even number of forms")))
            (cons 'clojure.core/cond (next (next clauses))))))
</pre>


<pre>
<strong>(source condp)</strong>
&nbsp;
(defmacro condp
  "Takes a binary predicate, an expression, and a set of clauses.
  Each clause can take the form of either:
&nbsp;
  Each clause can take the form of either:
&nbsp;
  test-expr result-expr
&nbsp;
  test-expr :&gt;&gt; result-fn
&nbsp;
  Note :&gt;&gt; is an ordinary keyword.
&nbsp;
  For each clause, (pred test-expr expr) is evaluated. If it returns
  logical true, the clause is a match. If a binary clause matches, the
  result-expr is returned, if a ternary clause matches, its result-fn,
  which must be a unary function, is called with the result of the
  predicate as its argument, the result of that call being the return
  value of condp. A single default expression can follow the clauses,
  and its value will be returned if no clause matches. If no default
  expression is provided and no clause matches, an
  IllegalArgumentException is thrown."
&nbsp;
  {:added "1.0"}
&nbsp;
  [pred expr &amp; clauses]
  (let [gpred (gensym "pred__")
        gexpr (gensym "expr__")
        emit (fn emit [pred expr args]
               (let [[[a b c :as clause] more]
                       (split-at (if (= :&gt;&gt; (second args)) 3 2) args)
                       n (count clause)]
                 (cond
                  (= 0 n) `(throw (IllegalArgumentException. (str "No matching clause: " ~expr)))
                  (= 1 n) a
                  (= 2 n) `(if (~pred ~a ~expr)
                             ~b
                             ~(emit pred expr more))
                  :else `(if-let [p# (~pred ~a ~expr)]
                           (~c p#)
                           ~(emit pred expr more)))))]
    `(let [~gpred ~pred
           ~gexpr ~expr]
       ~(emit gpred gexpr clauses))))
</pre>


<pre>
<strong>(source conde)</strong>
&nbsp;
(defmacro conde
  "Logical disjunction of the clauses. The first goal in
  a clause is considered the head of that clause. Interleaves the
  execution of the clauses."
  [&amp; clauses]
  (let [a (gensym "a")]
    `(fn [~a]
       (-inc
        (mplus* ~@(bind-conde-clauses a clauses))))))
</pre>


<pre>
<strong>(source condu)</strong>
(defmacro condu
&nbsp;
  "Committed choice. Once the head (first goal) of a clause
  has succeeded, remaining goals of the clause will only
  be run once. Non-relational."
  [&amp; clauses]
  (let [a (gensym "a")]
    `(fn [~a]
       (ifu* ~@(map (cond-clauses a) clauses)))))
</pre>


<pre>
<strong>(source conda)</strong>
(defmacro conda
&nbsp;
  "Soft cut. Once the head of a clause has succeeded
  all other clauses will be ignored. Non-relational."
  [&amp; clauses]
  (let [a (gensym "a")]
    `(fn [~a]
       (ifa* ~@(map (cond-clauses a) clauses)))))
</pre>


<pre>
<strong>(source cond-&gt;)</strong>
(defmacro cond-&gt;
&nbsp;
  "Takes an expression and a set of test/form pairs. Threads expr (via -&gt;)
  through each form for which the corresponding test
  expression is true. Note that, unlike cond branching, cond-&gt; threading does
  not short circuit after the first true test expression."
  {:added "1.5"}
  [expr &amp; clauses]
  (assert (even? (count clauses)))
  (let [g (gensym)
        steps (map (fn [[test step]] `(if ~test (-&gt; ~g ~step) ~g))
                   (partition 2 clauses))]
    `(let [~g ~expr
           ~@(interleave (repeat g) (butlast steps))]
       ~(if (empty? steps)
          g
          (last steps)))))
</pre>


<pre>
<strong>(source cond-&gt;&gt;)</strong>
(defmacro cond-&gt;&gt;
&nbsp;
  "Takes an expression and a set of test/form pairs. Threads expr (via -&gt;&gt;)
  through each form for which the corresponding test expression
  is true.  Note that, unlike cond branching, cond-&gt;&gt; threading does not short circuit
  after the first true test expression."
  {:added "1.5"}
  [expr &amp; clauses]
  (assert (even? (count clauses)))
  (let [g (gensym)
        steps (map (fn [[test step]] `(if ~test (-&gt;&gt; ~g ~step) ~g))
                   (partition 2 clauses))]
    `(let [~g ~expr
           ~@(interleave (repeat g) (butlast steps))]
       ~(if (empty? steps)
          g
          (last steps)))))
</pre>


<pre>
<strong>(source case)</strong>
&nbsp;
(defmacro case
  "Takes an expression, and a set of clauses.
&nbsp;
  Each clause can take the form of either:
&nbsp;
  test-constant result-expr
&nbsp;
  (test-constant1 ... test-constantN)  result-expr
&nbsp;
  The test-constants are not evaluated. They must be compile-time
  literals, and need not be quoted.  If the expression is equal to a
  test-constant, the corresponding result-expr is returned. A single
  default expression can follow the clauses, and its value will be
  returned if no clause matches. If no default expression is provided
  and no clause matches, an IllegalArgumentException is thrown.
&nbsp;
  Unlike cond and condp, case does a constant-time dispatch, the
  clauses are not considered sequentially.  All manner of constant
  expressions are acceptable in case, including numbers, strings,
  symbols, keywords, and (Clojure) composites thereof. Note that since
  lists are used to group multiple constants that map to the same
  expression, a vector can be used to match a list if needed. The
  test-constants need not be all of the same type."
  {:added "1.2"}
&nbsp;
  [e &amp; clauses]
  (let [ge (with-meta (gensym) {:tag Object})
        default (if (odd? (count clauses))
                  (last clauses)
                  `(throw (IllegalArgumentException. (str "No matching clause: " ~ge))))]
    (if (&gt; 2 (count clauses))
      `(let [~ge ~e] ~default)
      (let [pairs (partition 2 clauses)
            assoc-test (fn assoc-test [m test expr]
                         (if (contains? m test)
                           (throw (IllegalArgumentException. (str "Duplicate case test constant: " test)))
                           (assoc m test expr)))
            pairs (reduce1
                       (fn [m [test expr]]
                         (if (seq? test)
                           (reduce1 #(assoc-test %1 %2 expr) m test)
                           (assoc-test m test expr)))
                       {} pairs)
            tests (keys pairs)
            thens (vals pairs)
            mode (cond
                   (every? #(and (integer? %) (&lt;= Integer/MIN_VALUE % Integer/MAX_VALUE)) tests)
                   :ints
                   (every? keyword? tests)
                   :identity
                   :else :hashes)]
        (condp = mode
          :ints
          (let [[shift mask imap switch-type] (prep-ints tests thens)]
            `(let [~ge ~e] (case* ~ge ~shift ~mask ~default ~imap ~switch-type :int)))
          :hashes
          (let [[shift mask imap switch-type skip-check] (prep-hashes ge default tests thens)]
            `(let [~ge ~e] (case* ~ge ~shift ~mask ~default ~imap ~switch-type :hash-equiv ~skip-check)))
          :identity
          (let [[shift mask imap switch-type skip-check] (prep-hashes ge default tests thens)]
            `(let [~ge ~e] (case* ~ge ~shift ~mask ~default ~imap ~switch-type :hash-identity ~skip-check))))))))
</pre>



<p><a name="k18"></a></p>
<h2 id="k18">18. Repositář s&nbsp;demonstračními příklady</h2>

<p>Ukázkové části kódu s&nbsp;rozhodovacími konstrukcemi, které byly popsány
v&nbsp;rámci předchozích kapitol, byly uloženy do Git repositáře, který je
dostupný na adrese <a
href="https://github.com/tisnik/clojure-examples/">https://github.com/tisnik/clojure-examples/</a>.
Konkrétně se jedná o projekt <strong>conditions</strong> (<a
href="https://github.com/tisnik/clojure-examples/tree/master/conditions">https://github.com/tisnik/clojure-examples/tree/master/conditions</a>),
jehož zdrojový kód (<a
href="https://github.com/tisnik/clojure-examples/tree/master/conditions/src/conditions/core.clj">jediný
soubor</a>) je možné postupně kopírovat do interaktivního prostředí
představovaného smyčkou REPL. Příklad je pochopitelně možné spustit i
v&nbsp;jeho plné podobě příkazem <strong>lein run</strong> (to ovšem do určité
míry postrádá výukový charakter).</p>



<p><a name="k19"></a></p>
<h2 id="k19">19. Odkazy na předchozí části seriálu o programovacím jazyku Clojure</h2>

<ol>

<li>Clojure  1: Úvod<br />
<a href="http://www.root.cz/clanky/clojure-aneb-jazyk-umoznujici-tvorbu-bezpecnych-vicevlaknovych-aplikaci-pro-jvm/">http://www.root.cz/clanky/clojure-aneb-jazyk-umoznujici-tvorbu-bezpecnych-vicevlaknovych-aplikaci-pro-jvm/</a>
</li>

<li>Clojure  2: Symboly, kolekce atd.<br />
<a href="http://www.root.cz/clanky/clojure-aneb-jazyk-umoznujici-tvorbu-bezpecnych-vicevlaknovych-aplikaci-pro-jvm-2-cast/">http://www.root.cz/clanky/clojure-aneb-jazyk-umoznujici-tvorbu-bezpecnych-vicevlaknovych-aplikaci-pro-jvm-2-cast/</a>
</li>

<li>Clojure  3: Funkcionální programování<br />
<a href="http://www.root.cz/clanky/clojure-aneb-jazyk-umoznujici-tvorbu-bezpecnych-vicevlaknovych-aplikaci-pro-jvm-3-cast-funkcionalni-programovani/">http://www.root.cz/clanky/clojure-aneb-jazyk-umoznujici-tvorbu-bezpecnych-vicevlaknovych-aplikaci-pro-jvm-3-cast-funkcionalni-programovani/</a>
</li>

<li>Clojure  4: Kolekce, sekvence a lazy sekvence<br />
<a href="http://www.root.cz/clanky/clojure-aneb-jazyk-umoznujici-tvorbu-bezpecnych-vicevlaknovych-aplikaci-pro-jvm-4-cast-kolekce-sekvence-a-lazy-sekvence/">http://www.root.cz/clanky/clojure-aneb-jazyk-umoznujici-tvorbu-bezpecnych-vicevlaknovych-aplikaci-pro-jvm-4-cast-kolekce-sekvence-a-lazy-sekvence/</a>
</li>

<li>Clojure  5: Sekvence, lazy sekvence a paralelní programy<br />
<a href="http://www.root.cz/clanky/clojure-a-bezpecne-aplikace-pro-jvm-sekvence-lazy-sekvence-a-paralelni-programy/">http://www.root.cz/clanky/clojure-a-bezpecne-aplikace-pro-jvm-sekvence-lazy-sekvence-a-paralelni-programy/</a>
</li>

<li>Clojure  6: Podpora pro paralelní programování<br />
<a href="http://www.root.cz/clanky/programovaci-jazyk-clojure-6-futures-nejsou-jen-financni-derivaty/">http://www.root.cz/clanky/programovaci-jazyk-clojure-6-futures-nejsou-jen-financni-derivaty/</a>
</li>

<li>Clojure  7: Další funkce pro paralelní programování<br />
<a href="http://www.root.cz/clanky/programovaci-jazyk-clojure-7-dalsi-podpurne-prostredky-pro-paralelni-programovani/">http://www.root.cz/clanky/programovaci-jazyk-clojure-7-dalsi-podpurne-prostredky-pro-paralelni-programovani/</a>
</li>

<li>Clojure  8: Identity, stavy, neměnné hodnoty a reference<br />
<a href="http://www.root.cz/clanky/programovaci-jazyk-clojure-8-identity-stavy-nemenne-hodnoty-a-referencni-typy/">http://www.root.cz/clanky/programovaci-jazyk-clojure-8-identity-stavy-nemenne-hodnoty-a-referencni-typy/</a>
</li>

<li>Clojure  9: Validátory, pozorovatelé a kooperace s Javou<br />
<a href="http://www.root.cz/clanky/programovaci-jazyk-clojure-9-validatory-pozorovatele-a-kooperace-mezi-clojure-a-javou/">http://www.root.cz/clanky/programovaci-jazyk-clojure-9-validatory-pozorovatele-a-kooperace-mezi-clojure-a-javou/</a>
</li>

<li>Clojure 10: Kooperace mezi Clojure a Javou<br />
<a href="http://www.root.cz/clanky/programovaci-jazyk-clojure-10-kooperace-mezi-clojure-a-javou-pokracovani/">http://www.root.cz/clanky/programovaci-jazyk-clojure-10-kooperace-mezi-clojure-a-javou-pokracovani/</a>
</li>

<li>Clojure 11: Generátorová notace seznamu/list comprehension<br />
<a href="http://www.root.cz/clanky/programovaci-jazyk-clojure-11-generatorova-notace-seznamu-list-comprehension/">http://www.root.cz/clanky/programovaci-jazyk-clojure-11-generatorova-notace-seznamu-list-comprehension/</a>
</li>

<li>Clojure 12: Překlad programů z Clojure do bajtkódu JVM I:<br />
<a href="http://www.root.cz/clanky/programovaci-jazyk-clojure-12-preklad-programu-z-clojure-do-bajtkodu-jvm/">http://www.root.cz/clanky/programovaci-jazyk-clojure-12-preklad-programu-z-clojure-do-bajtkodu-jvm/</a>
</li>

<li>Clojure 13: Překlad programů z Clojure do bajtkódu JVM II:<br />
<a href="http://www.root.cz/clanky/programovaci-jazyk-clojure-13-preklad-programu-z-clojure-do-bajtkodu-jvm-pokracovani/">http://www.root.cz/clanky/programovaci-jazyk-clojure-13-preklad-programu-z-clojure-do-bajtkodu-jvm-pokracovani/</a>
</li>

<li>Clojure 14: Základy práce se systémem maker<br />
<a href="http://www.root.cz/clanky/programovaci-jazyk-clojure-14-zaklady-prace-se-systemem-maker/">http://www.root.cz/clanky/programovaci-jazyk-clojure-14-zaklady-prace-se-systemem-maker/</a>
</li>

<li>Clojure 15: Tvorba uživatelských maker<br />
<a href="http://www.root.cz/clanky/programovaci-jazyk-clojure-15-tvorba-uzivatelskych-maker/">http://www.root.cz/clanky/programovaci-jazyk-clojure-15-tvorba-uzivatelskych-maker/</a>
</li>

<li>Programovací jazyk Clojure &ndash; triky při práci s řetězci<br />
<a href="http://www.root.cz/clanky/programovaci-jazyk-clojure-triky-pri-praci-s-retezci/">http://www.root.cz/clanky/programovaci-jazyk-clojure-triky-pri-praci-s-retezci/</a>
</li>

<li>Programovací jazyk Clojure &ndash; triky při práci s kolekcemi<br />
<a href="http://www.root.cz/clanky/programovaci-jazyk-clojure-triky-pri-praci-s-kolekcemi/">http://www.root.cz/clanky/programovaci-jazyk-clojure-triky-pri-praci-s-kolekcemi/</a>
</li>

<li>Programovací jazyk Clojure &ndash; práce s mapami a množinami<br />
<a href="http://www.root.cz/clanky/programovaci-jazyk-clojure-prace-s-mapami-a-mnozinami/">http://www.root.cz/clanky/programovaci-jazyk-clojure-prace-s-mapami-a-mnozinami/</a>
</li>

<li>Programovací jazyk Clojure &ndash; základy zpracování XML<br />
<a href="http://www.root.cz/clanky/programovaci-jazyk-clojure-zaklady-zpracovani-xml/">http://www.root.cz/clanky/programovaci-jazyk-clojure-zaklady-zpracovani-xml/</a>
</li>

<li>Programovací jazyk Clojure &ndash; testování s využitím knihovny Expectations<br />
<a href="http://www.root.cz/clanky/programovaci-jazyk-clojure-testovani-s-vyuzitim-knihovny-expectations/">http://www.root.cz/clanky/programovaci-jazyk-clojure-testovani-s-vyuzitim-knihovny-expectations/</a>
</li>

<li>Programovací jazyk Clojure &ndash; některé užitečné triky použitelné (nejenom) v&nbsp;testech<br />
<a href="http://www.root.cz/clanky/programovaci-jazyk-clojure-nektere-uzitecne-triky-pouzitelne-nejenom-v-testech/">http://www.root.cz/clanky/programovaci-jazyk-clojure-nektere-uzitecne-triky-pouzitelne-nejenom-v-testech/</a>
</li>

<li>Enlive &ndash; výkonný šablonovací systém pro jazyk Clojure<br/>
<a href="http://www.root.cz/clanky/enlive-vykonny-sablonovaci-system-pro-jazyk-clojure/">http://www.root.cz/clanky/enlive-vykonny-sablonovaci-system-pro-jazyk-clojure/</a>
</li>

<li>Nástroj Leiningen a programovací jazyk Clojure: tvorba vlastních knihoven pro veřejný repositář Clojars<br />
<a href="http://www.root.cz/clanky/nastroj-leiningen-a-programovaci-jazyk-clojure-tvorba-vlastnich-knihoven-pro-verejny-repositar-clojars/">http://www.root.cz/clanky/nastroj-leiningen-a-programovaci-jazyk-clojure-tvorba-vlastnich-knihoven-pro-verejny-repositar-clojars/</a>
</li>

<li>Novinky v Clojure verze 1.8.0<br />
<a href="http://www.root.cz/clanky/novinky-v-clojure-verze-1-8-0/">http://www.root.cz/clanky/novinky-v-clojure-verze-1-8-0/</a>
</li>

<li>Asynchronní programování v&nbsp;Clojure s&nbsp;využitím knihovny core.async<br />
<a href="http://www.root.cz/clanky/asynchronni-programovani-v-clojure-s-vyuzitim-knihovny-core-async/">http://www.root.cz/clanky/asynchronni-programovani-v-clojure-s-vyuzitim-knihovny-core-async/</a>
</li>

<li>Asynchronní programování v&nbsp;Clojure s&nbsp;využitím knihovny core.async (pokračování)<br />
<a href="http://www.root.cz/clanky/asynchronni-programovani-v-clojure-s-vyuzitim-knihovny-core-async-pokracovani/">http://www.root.cz/clanky/asynchronni-programovani-v-clojure-s-vyuzitim-knihovny-core-async-pokracovani/</a>
</li>

<li>Asynchronní programování v Clojure s využitím knihovny core.async (dokončení)<br />
<a href="http://www.root.cz/clanky/asynchronni-programovani-v-clojure-s-vyuzitim-knihovny-core-async-dokonceni/">http://www.root.cz/clanky/asynchronni-programovani-v-clojure-s-vyuzitim-knihovny-core-async-dokonceni/</a>
</li>

<li>Vytváříme IRC bota v programovacím jazyce Clojure<br />
<a href="http://www.root.cz/clanky/vytvarime-irc-bota-v-programovacim-jazyce-clojure/">http://www.root.cz/clanky/vytvarime-irc-bota-v-programovacim-jazyce-clojure/</a>
</li>

<li>Gorilla REPL: interaktivní prostředí pro programovací jazyk Clojure<br />
<a href="https://www.root.cz/clanky/gorilla-repl-interaktivni-prostredi-pro-programovaci-jazyk-clojure/">https://www.root.cz/clanky/gorilla-repl-interaktivni-prostredi-pro-programovaci-jazyk-clojure/</a>
</li>

<li>Multimetody v Clojure aneb polymorfismus bez použití OOP<br />
<a href="https://www.root.cz/clanky/multimetody-v-clojure-aneb-polymorfismus-bez-pouziti-oop/">https://www.root.cz/clanky/multimetody-v-clojure-aneb-polymorfismus-bez-pouziti-oop/</a>
</li>

<li>Práce s externími Java archivy v programovacím jazyku Clojure<br />
<a href="https://www.root.cz/clanky/prace-s-externimi-java-archivy-v-programovacim-jazyku-clojure/">https://www.root.cz/clanky/prace-s-externimi-java-archivy-v-programovacim-jazyku-clojure/</a>
</li>

<li>Clojure 16: Složitější uživatelská makra<br />
<a href="http://www.root.cz/clanky/programovaci-jazyk-clojure-16-slozitejsi-uzivatelska-makra/">http://www.root.cz/clanky/programovaci-jazyk-clojure-16-slozitejsi-uzivatelska-makra/</a>
</li>

<li>Clojure 17: Využití standardních maker v praxi<br />
<a href="http://www.root.cz/clanky/programovaci-jazyk-clojure-17-vyuziti-standardnich-maker-v-praxi/">http://www.root.cz/clanky/programovaci-jazyk-clojure-17-vyuziti-standardnich-maker-v-praxi/</a>
</li>

<li>Clojure 18: Základní techniky optimalizace aplikací<br />
<a href="http://www.root.cz/clanky/programovaci-jazyk-clojure-18-zakladni-techniky-optimalizace-aplikaci/">http://www.root.cz/clanky/programovaci-jazyk-clojure-18-zakladni-techniky-optimalizace-aplikaci/</a>
</li>

<li>Clojure 19: Vývojová prostředí pro Clojure<br />
<a href="http://www.root.cz/clanky/programovaci-jazyk-clojure-19-vyvojova-prostredi-pro-clojure/">http://www.root.cz/clanky/programovaci-jazyk-clojure-19-vyvojova-prostredi-pro-clojure/</a>
</li>

<li>Clojure 20: Vývojová prostředí pro Clojure (Vimu s REPL)<br />
<a href="http://www.root.cz/clanky/programovaci-jazyk-clojure-20-vyvojova-prostredi-pro-clojure-integrace-vimu-s-repl/">http://www.root.cz/clanky/programovaci-jazyk-clojure-20-vyvojova-prostredi-pro-clojure-integrace-vimu-s-repl/</a>
</li>

<li>Clojure 21: ClojureScript aneb překlad Clojure do JS<br />
<a href="http://www.root.cz/clanky/programovaci-jazyk-clojure-21-clojurescript-aneb-preklad-clojure-do-javascriptu/">http://www.root.cz/clanky/programovaci-jazyk-clojure-21-clojurescript-aneb-preklad-clojure-do-javascriptu/</a>
</li>

<li>Leiningen: nástroj pro správu projektů napsaných v&nbsp;Clojure<br />
<a href="http://www.root.cz/clanky/leiningen-nastroj-pro-spravu-projektu-napsanych-v-clojure/">http://www.root.cz/clanky/leiningen-nastroj-pro-spravu-projektu-napsanych-v-clojure/</a>
</li>

<li>Leiningen: nástroj pro správu projektů napsaných v&nbsp;Clojure (2)<br />
<a href="http://www.root.cz/clanky/leiningen-nastroj-pro-spravu-projektu-napsanych-v-clojure-2/">http://www.root.cz/clanky/leiningen-nastroj-pro-spravu-projektu-napsanych-v-clojure-2/</a>
</li>

<li>Leiningen: nástroj pro správu projektů napsaných v&nbsp;Clojure (3)<br />
<a href="http://www.root.cz/clanky/leiningen-nastroj-pro-spravu-projektu-napsanych-v-clojure-3/">http://www.root.cz/clanky/leiningen-nastroj-pro-spravu-projektu-napsanych-v-clojure-3/</a>
</li>

<li>Leiningen: nástroj pro správu projektů napsaných v&nbsp;Clojure (4)<br />
<a href="http://www.root.cz/clanky/leiningen-nastroj-pro-spravu-projektu-napsanych-v-clojure-4/">http://www.root.cz/clanky/leiningen-nastroj-pro-spravu-projektu-napsanych-v-clojure-4/</a>
</li>

<li>Leiningen: nástroj pro správu projektů napsaných v&nbsp;Clojure (5)<br />
<a href="http://www.root.cz/clanky/leiningen-nastroj-pro-spravu-projektu-napsanych-v-clojure-5/">http://www.root.cz/clanky/leiningen-nastroj-pro-spravu-projektu-napsanych-v-clojure-5/</a>
</li>

<li>Leiningen: nástroj pro správu projektů napsaných v&nbsp;Clojure (6)<br />
<a href="http://www.root.cz/clanky/leiningen-nastroj-pro-spravu-projektu-napsanych-v-clojure-6/">http://www.root.cz/clanky/leiningen-nastroj-pro-spravu-projektu-napsanych-v-clojure-6/</a>
</li>

<li>Programovací jazyk Clojure a databáze (1.část)<br />
<a href="http://www.root.cz/clanky/programovaci-jazyk-clojure-a-databaze-1-cast/">http://www.root.cz/clanky/programovaci-jazyk-clojure-a-databaze-1-cast/</a>
</li>

<li>Pluginy pro Leiningen<br />
<a href="http://www.root.cz/clanky/leiningen-nastroj-pro-spravu-projektu-napsanych-v-clojure-pluginy-pro-leiningen/">http://www.root.cz/clanky/leiningen-nastroj-pro-spravu-projektu-napsanych-v-clojure-pluginy-pro-leiningen/</a>
</li>

<li>Programovací jazyk Clojure a knihovny pro práci s&nbsp;vektory a maticemi<br />
<a href="http://www.root.cz/clanky/programovaci-jazyk-clojure-a-knihovny-pro-praci-s-vektory-a-maticemi/">http://www.root.cz/clanky/programovaci-jazyk-clojure-a-knihovny-pro-praci-s-vektory-a-maticemi/</a>
</li>

<li>Programovací jazyk Clojure a knihovny pro práci s&nbsp;vektory a maticemi (2)<br />
<a href="http://www.root.cz/clanky/programovaci-jazyk-clojure-a-knihovny-pro-praci-s-vektory-a-maticemi-2/">http://www.root.cz/clanky/programovaci-jazyk-clojure-a-knihovny-pro-praci-s-vektory-a-maticemi-2/</a>
</li>

<li>Programovací jazyk Clojure: syntéza procedurálních textur s&nbsp;využitím knihovny Clisk<br />
<a href="http://www.root.cz/clanky/programovaci-jazyk-clojure-synteza-proceduralnich-textur-s-vyuzitim-knihovny-clisk/">http://www.root.cz/clanky/programovaci-jazyk-clojure-synteza-proceduralnich-textur-s-vyuzitim-knihovny-clisk/</a>
</li>

<li>Programovací jazyk Clojure: syntéza procedurálních textur s&nbsp;využitím knihovny Clisk (2)<br />
<a href="http://www.root.cz/clanky/programovaci-jazyk-clojure-synteza-proceduralnich-textur-s-vyuzitim-knihovny-clisk-2/">http://www.root.cz/clanky/programovaci-jazyk-clojure-synteza-proceduralnich-textur-s-vyuzitim-knihovny-clisk-2/</a>
</li>

<li>Seesaw: knihovna pro snadnou tvorbu GUI v&nbsp;jazyce Clojure<br />
<a href="http://www.root.cz/clanky/seesaw-knihovna-pro-snadnou-tvorbu-gui-v-jazyce-clojure/">http://www.root.cz/clanky/seesaw-knihovna-pro-snadnou-tvorbu-gui-v-jazyce-clojure/</a>
</li>

<li>Seesaw: knihovna pro snadnou tvorbu GUI v &nbsp;azyce Clojure (2)<br />
<a href="http://www.root.cz/clanky/seesaw-knihovna-pro-snadnou-tvorbu-gui-v-jazyce-clojure-2/">http://www.root.cz/clanky/seesaw-knihovna-pro-snadnou-tvorbu-gui-v-jazyce-clojure-2/</a>
</li>

<li>Seesaw: knihovna pro snadnou tvorbu GUI v&nbsp;jazyce Clojure (3)<br />
<a href="http://www.root.cz/clanky/seesaw-knihovna-pro-snadnou-tvorbu-gui-v-jazyce-clojure-3/">http://www.root.cz/clanky/seesaw-knihovna-pro-snadnou-tvorbu-gui-v-jazyce-clojure-3/</a>
</li>

<li>Programovací jazyk Clojure a práce s&nbsp;Gitem<br />
<a href="http://www.root.cz/clanky/programovaci-jazyk-clojure-a-prace-s-gitem/">http://www.root.cz/clanky/programovaci-jazyk-clojure-a-prace-s-gitem/</a>
</li>

<li>Programovací jazyk Clojure a práce s&nbsp;Gitem (2)<br />
<a href="http://www.root.cz/clanky/programovaci-jazyk-clojure-a-prace-s-gitem-2/">http://www.root.cz/clanky/programovaci-jazyk-clojure-a-prace-s-gitem-2/</a>
</li>

<li>Programovací jazyk Clojure: syntéza procedurálních textur s&nbsp;využitím knihovny Clisk (dokončení)<br />
<a href="http://www.root.cz/clanky/programovaci-jazyk-clojure-synteza-proceduralnich-textur-s-vyuzitim-knihovny-clisk-dokonceni/">http://www.root.cz/clanky/programovaci-jazyk-clojure-synteza-proceduralnich-textur-s-vyuzitim-knihovny-clisk-dokonceni/</a>
</li>

<li>Pixie: lehký skriptovací jazyk s&nbsp;„kouzelnými“ schopnostmi<br />
<a href="https://www.root.cz/clanky/pixie-lehky-skriptovaci-jazyk-s-kouzelnymi-schopnostmi/">https://www.root.cz/clanky/pixie-lehky-skriptovaci-jazyk-s-kouzelnymi-schopnostmi/</a>
</li>

<li>Programovací jazyk Pixie: funkce ze základní knihovny a použití FFI<br />
<a href="https://www.root.cz/clanky/programovaci-jazyk-pixie-funkce-ze-zakladni-knihovny-a-pouziti-ffi/">https://www.root.cz/clanky/programovaci-jazyk-pixie-funkce-ze-zakladni-knihovny-a-pouziti-ffi/</a>
</li>

<li>Novinky v&nbsp;Clojure verze 1.9.0<br />
<a href="https://www.root.cz/clanky/novinky-v-clojure-verze-1-9-0/">https://www.root.cz/clanky/novinky-v-clojure-verze-1-9-0/</a>
</li>

<li>Validace dat s&nbsp;využitím knihovny spec v&nbsp;Clojure 1.9.0<br />
<a href="https://www.root.cz/clanky/validace-dat-s-vyuzitim-knihovny-spec-v-clojure-1-9-0/">https://www.root.cz/clanky/validace-dat-s-vyuzitim-knihovny-spec-v-clojure-1-9-0/</a>
</li>

<li>Použití jazyka Gherkin při tvorbě testovacích scénářů pro aplikace psané v&nbsp;Clojure<br />
<a href="https://www.root.cz/clanky/pouziti-jazyka-gherkin-pri-tvorbe-testovacich-scenaru-pro-aplikace-psane-v-nbsp-clojure/">https://www.root.cz/clanky/pouziti-jazyka-gherkin-pri-tvorbe-testovacich-scenaru-pro-aplikace-psane-v-nbsp-clojure/</a>
</li>

<li>Použití jazyka Gherkin při tvorbě testovacích scénářů pro aplikace psané v&nbsp;Clojure (2)<br />
<a href="https://www.root.cz/clanky/pouziti-jazyka-gherkin-pri-tvorbe-testovacich-scenaru-pro-aplikace-psane-v-nbsp-clojure-2/">https://www.root.cz/clanky/pouziti-jazyka-gherkin-pri-tvorbe-testovacich-scenaru-pro-aplikace-psane-v-nbsp-clojure-2/</a>
</li>

<li>Incanter: prostředí pro statistické výpočty s grafickým výstupem založené na Clojure<br />
<a href="https://www.root.cz/clanky/incanter-prostredi-pro-statisticke-vypocty-s-grafickym-vystupem-zalozene-na-clojure/">https://www.root.cz/clanky/incanter-prostredi-pro-statisticke-vypocty-s-grafickym-vystupem-zalozene-na-clojure/</a>
</li>

<li>Incanter: operace s&nbsp;maticemi<br />
<a href="https://www.root.cz/clanky/incanter-operace-s-maticemi/">https://www.root.cz/clanky/incanter-operace-s-maticemi/</a>
</li>

<li>Interpret programovacího jazyka Clojure integrovaný do Jupyter Notebooku<br />
<a href="https://www.root.cz/clanky/interpret-programovaciho-jazyka-clojure-integrovany-do-jupyter-notebooku/">https://www.root.cz/clanky/interpret-programovaciho-jazyka-clojure-integrovany-do-jupyter-notebooku/</a>
</li>

<li>Babashka: interpret Clojure určený pro rychlé spouštění utilit z&nbsp;příkazového řádku<br />
<a href="https://www.root.cz/clanky/babashka-interpret-clojure-urceny-pro-rychle-spousteni-utilit-z-prikazoveho-radku/">https://www.root.cz/clanky/babashka-interpret-clojure-urceny-pro-rychle-spousteni-utilit-z-prikazoveho-radku/</a>
</li>

<li>Pokročilý streaming založený na Apache Kafce, jazyku Clojure a knihovně Jackdaw<br />
<a href="https://www.root.cz/clanky/pokrocily-streaming-zalozeny-na-apache-kafce-jazyku-clojure-a-knihovne-jackdaw/">https://www.root.cz/clanky/pokrocily-streaming-zalozeny-na-apache-kafce-jazyku-clojure-a-knihovne-jackdaw/</a>
</li>

<li>Pokročilý streaming založený na Apache Kafce, jazyku Clojure a knihovně Jackdaw (2. část)<br />
<a href="https://www.root.cz/clanky/pokrocily-streaming-zalozeny-na-apache-kafce-jazyku-clojure-a-knihovne-jackdaw-2-cast/">https://www.root.cz/clanky/pokrocily-streaming-zalozeny-na-apache-kafce-jazyku-clojure-a-knihovne-jackdaw-2-cast/</a>
</li>

<li>Pokročilý streaming založený na projektu Apache Kafka, jazyku Clojure a knihovně Jackdaw (streamy a kolony)<br />
<a href="https://www.root.cz/clanky/pokrocily-streaming-zalozeny-na-projektu-apache-kafka-jazyku-clojure-a-knihovne-jackdaw-streamy-a-kolony/">https://www.root.cz/clanky/pokrocily-streaming-zalozeny-na-projektu-apache-kafka-jazyku-clojure-a-knihovne-jackdaw-streamy-a-kolony/</a>
</li>

<li>Řídicí struktury využitelné v&nbsp;programovacím jazyku Clojure<br />
<a href="https://www.root.cz/clanky/ridici-struktury-vyuzitelne-v-programovacim-jazyku-clojure/">https://www.root.cz/clanky/ridici-struktury-vyuzitelne-v-programovacim-jazyku-clojure/</a>
</li>

</ol>



<p><a name="k20"></a></p>
<h2 id="k20">20. Odkazy na Internetu</h2>

<ol>

<li>Special (Conditions)<br />
<a href="https://github.com/clojureman/special">https://github.com/clojureman/special</a>
</li>

<li>better-cond<br />
<a href="https://cljdoc.org/d/better-cond/better-cond/2.1.0/doc/readme">https://cljdoc.org/d/better-cond/better-cond/2.1.0/doc/readme</a>
</li>

<li>A micro-library around the useful cond-let macro<br />
<a href="https://cljdoc.org/d/com.walmartlabs/cond-let/1.0.0/doc/readme">https://cljdoc.org/d/com.walmartlabs/cond-let/1.0.0/doc/readme</a>
</li>

<li>An adaption of the Racket cond macro for Clojure<br />
<a href="https://cljdoc.org/d/cond-plus/cond-plus/1.0.1/doc/readme">https://cljdoc.org/d/cond-plus/cond-plus/1.0.1/doc/readme</a>
</li>

<li>Makro cond-table<br />
<a href="https://github.com/semperos/rankle/blob/master/src/com/semperos/rankle/util.clj">https://github.com/semperos/rankle/blob/master/src/com/semperos/rankle/util.clj</a>
</li>

<li>cond v&nbsp;jazyku Racket<br />
<a href="https://docs.racket-lang.org/reference/if.html?q=cond#%28form._%28%28lib._racket%2Fprivate%2Fletstx-scheme..rkt%29._cond%29%29">https://docs.racket-lang.org/reference/if.html?q=cond#%28form._%28%28lib._racket%2Fprivate%2Fletstx-scheme..rkt%29._cond%29%29</a>
</li>

<li>Learn Clojure - Flow Control<br />
<a href="https://clojure.org/guides/learn/flow">https://clojure.org/guides/learn/flow</a>
</li>

<li>clojure.core.logic<br />
<a href="https://clojuredocs.org/clojure.core.logic">https://clojuredocs.org/clojure.core.logic</a>
</li>

<li>ETL Batch Processing With Kafka?<br />
<a href="https://medium.com/swlh/etl-batch-processing-with-kafka-7f66f843e20d">https://medium.com/swlh/etl-batch-processing-with-kafka-7f66f843e20d</a>
</li>

<li>ETL with Kafka<br />
<a href="https://blog.codecentric.de/en/2018/03/etl-kafka/">https://blog.codecentric.de/en/2018/03/etl-kafka/</a>
</li>

<li>Building ETL Pipelines with Clojure and Transducers<br />
<a href="https://www.grammarly.com/blog/engineering/building-etl-pipelines-with-clojure-and-transducers/">https://www.grammarly.com/blog/engineering/building-etl-pipelines-with-clojure-and-transducers/</a>
</li>

<li>pipeline (možné použít pro ETL)<br />
<a href="https://clojuredocs.org/clojure.core.async/pipeline">https://clojuredocs.org/clojure.core.async/pipeline</a>
</li>

<li>On Track with Apache Kafka – Building a Streaming ETL Solution with Rail Data<br />
<a href="https://www.confluent.io/blog/build-streaming-etl-solutions-with-kafka-and-rail-data/">https://www.confluent.io/blog/build-streaming-etl-solutions-with-kafka-and-rail-data/</a>
</li>

<li>Kafka - Understanding Offset Commits<br />
<a href="https://www.logicbig.com/tutorials/misc/kafka/committing-offsets.html">https://www.logicbig.com/tutorials/misc/kafka/committing-offsets.html</a>
</li>

<li>fundingcircle/jackdaw (na Clojars)<br />
<a href="https://clojars.org/fundingcircle/jackdaw/versions/0.7.6">https://clojars.org/fundingcircle/jackdaw/versions/0.7.6</a>
</li>

<li>Dokumentace ke knihovně jackdaw<br />
<a href="https://cljdoc.org/d/fundingcircle/jackdaw/0.7.6/doc/readme">https://cljdoc.org/d/fundingcircle/jackdaw/0.7.6/doc/readme</a>
</li>

<li>Jackdaw AdminClient API<br />
<a href="https://cljdoc.org/d/fundingcircle/jackdaw/0.7.6/doc/jackdaw-adminclient-api">https://cljdoc.org/d/fundingcircle/jackdaw/0.7.6/doc/jackdaw-adminclient-api</a>
</li>

<li>Jackdaw Client API<br />
<a href="https://cljdoc.org/d/fundingcircle/jackdaw/0.7.6/doc/jackdaw-client-api">https://cljdoc.org/d/fundingcircle/jackdaw/0.7.6/doc/jackdaw-client-api</a>
</li>

<li>Kafka.clj<br />
<a href="https://github.com/helins-io/kafka.clj">https://github.com/helins-io/kafka.clj</a>
</li>

<li>Použití nástroje Apache Kafka v aplikacích založených na mikroslužbách<br />
<a href="https://www.root.cz/clanky/pouziti-nastroje-apache-kafka-v-aplikacich-zalozenych-na-mikrosluzbach/">https://www.root.cz/clanky/pouziti-nastroje-apache-kafka-v-aplikacich-zalozenych-na-mikrosluzbach/</a>
</li>

<li>Apache Kafka: distribuovaná streamovací platforma<br />
<a href="https://www.root.cz/clanky/apache-kafka-distribuovana-streamovaci-platforma/">https://www.root.cz/clanky/apache-kafka-distribuovana-streamovaci-platforma/</a>
</li>

<li>Real-Time Payments with Clojure and Apache Kafka (podcast)<br />
<a href="https://www.evidentsystems.com/news/confluent-podcast-about-apache-kafka/">https://www.evidentsystems.com/news/confluent-podcast-about-apache-kafka/</a>
</li>

<li>Kafka and Clojure - Immutable event streams<br />
<a href="https://practicalli.github.io/kafka-and-clojure/">https://practicalli.github.io/kafka-and-clojure/</a>
</li>

<li>Kafka Streams, the Clojure way<br />
<a href="https://blog.davemartin.me/posts/kafka-streams-the-clojure-way/">https://blog.davemartin.me/posts/kafka-streams-the-clojure-way/</a>
</li>

<li>dvlopt.kafka na GitHubu<br />
<a href="https://github.com/helins-io/kafka.clj">https://github.com/helins-io/kafka.clj</a>
</li>

<li>kafka-streams-the-clojure-way na GitHubu<br />
<a href="https://github.com/DaveWM/kafka-streams-the-clojure-way">https://github.com/DaveWM/kafka-streams-the-clojure-way</a>
</li>

<li>babashka: A Clojure babushka for the grey areas of Bash<br />
<a href="https://github.com/borkdude/babashka">https://github.com/borkdude/babashka</a>
</li>

<li>Babashka and the Small Clojure Interpreter @ ClojureD 2020 (slajdy)<br />
<a href="https://speakerdeck.com/borkdude/babashka-and-the-small-clojure-interpreter-at-clojured-2020">https://speakerdeck.com/borkdude/babashka-and-the-small-clojure-interpreter-at-clojured-2020</a>
</li>

<li>Babashka: ukázky použití<br />
<a href="https://github.com/borkdude/babashka/blob/master/doc/examples.md">https://github.com/borkdude/babashka/blob/master/doc/examples.md</a>
</li>

<li>clojureD 2020: "Babashka and Small Clojure Interpreter: Clojure in new contexts" by Michiel Borkent<br />
<a href="https://www.youtube.com/watch?v=Nw8aN-nrdEk&amp;t=5s">https://www.youtube.com/watch?v=Nw8aN-nrdEk&amp;t=5s</a>
</li>

<li>Meetup #124 Babashka, implementing an nREPL server &amp; game engines with Clojure<br />
<a href="https://www.youtube.com/watch?v=0YmZYnwyHHc">https://www.youtube.com/watch?v=0YmZYnwyHHc</a>
</li>

<li>The Last Programming Language (shrnutí vývoje programovacích jazyků)<br />
<a href="https://www.youtube.com/watch?v=P2yr-3F6PQo">https://www.youtube.com/watch?v=P2yr-3F6PQo</a>
</li>

<li>Shebang (Unix): Wikipedia EN<br />
<a href="https://en.wikipedia.org/wiki/Shebang_(Unix)">https://en.wikipedia.org/wiki/Shebang_(Unix)</a>
</li>

<li>Shebang (Unix): Wikipedia CZ<br />
<a href="https://cs.wikipedia.org/wiki/Shebang_(Unix)">https://cs.wikipedia.org/wiki/Shebang_(Unix)</a>
</li>

<li>How to create Clojure notebooks in Jupyter<br />
<a href="https://s01blog.wordpress.com/2017/12/10/how-to-create-clojure-notebooks-in-jupyter/">https://s01blog.wordpress.com/2017/12/10/how-to-create-clojure-notebooks-in-jupyter/</a>
</li>

<li>Dokumentace k&nbsp;nástroji Conda<br />
<a href="https://docs.conda.io/en/latest/">https://docs.conda.io/en/latest/</a>
</li>

<li>Notebook interface<br />
<a href="https://en.wikipedia.org/wiki/Notebook_interface">https://en.wikipedia.org/wiki/Notebook_interface</a>
</li>

<li>Jypyter: open source, interactive data science and scientific computing across over 40 programming languages<br />
<a href="https://jupyter.org/">https://jupyter.org/</a>
</li>

<li>Calysto Scheme<br />
<a href="https://github.com/Calysto/calysto_scheme">https://github.com/Calysto/calysto_scheme</a>
</li>

<li>scheme.py (základ projektu Calysto Scheme)<br />
<a href="https://github.com/Calysto/calysto_scheme/blob/master/calysto_scheme/scheme.py">https://github.com/Calysto/calysto_scheme/blob/master/calysto_scheme/scheme.py</a>
</li>

<li>Humane test output for clojure.test<br />
<a href="https://github.com/pjstadig/humane-test-output">https://github.com/pjstadig/humane-test-output</a>
</li>

<li>iota<br />
<a href="https://github.com/juxt/iota">https://github.com/juxt/iota</a>
</li>

<li>5 Differences between clojure.spec and Schema<br />
<a href="https://lispcast.com/clojure.spec-vs-schema/">https://lispcast.com/clojure.spec-vs-schema/</a>
</li>

<li>Schema: Clojure(Script) library for declarative data description and validation<br />
<a href="https://github.com/plumatic/schema">https://github.com/plumatic/schema</a>
</li>

<li>Zip archiv s&nbsp;Clojure 1.9.0<br />
<a href="http://repo1.maven.org/maven2/org/clojure/clojure/1.9.0/clojure-1.9.0.zip">http://repo1.maven.org/maven2/org/clojure/clojure/1.9.0/clojure-1.9.0.zip</a>
</li>

<li>Clojure 1.9 is now available<br />
<a href="https://clojure.org/news/2017/12/08/clojure19">https://clojure.org/news/2017/12/08/clojure19</a>
</li>

<li>Deps and CLI Guide<br />
<a href="https://clojure.org/guides/deps_and_cli">https://clojure.org/guides/deps_and_cli</a>
</li>

<li>Changes to Clojure in Version 1.9<br />
<a href="https://github.com/clojure/clojure/blob/master/changes.md">https://github.com/clojure/clojure/blob/master/changes.md</a>
</li>

<li>clojure.spec - Rationale and Overview<br />
<a href="https://clojure.org/about/spec">https://clojure.org/about/spec</a>
</li>

<li>Zip archiv s&nbsp;Clojure 1.8.0<br />
<a href="http://repo1.maven.org/maven2/org/clojure/clojure/1.8.0/clojure-1.8.0.zip">http://repo1.maven.org/maven2/org/clojure/clojure/1.8.0/clojure-1.8.0.zip</a>
</li>

<li>Clojure 1.8 is now available<br />
<a href="http://clojure.org/news/2016/01/19/clojure18">http://clojure.org/news/2016/01/19/clojure18</a>
</li>

<li>Socket Server REPL<br />
<a href="http://dev.clojure.org/display/design/Socket+Server+REPL">http://dev.clojure.org/display/design/Socket+Server+REPL</a>
</li>

<li>CLJ-1671: Clojure socket server<br />
<a href="http://dev.clojure.org/jira/browse/CLJ-1671">http://dev.clojure.org/jira/browse/CLJ-1671</a>
</li>

<li>CLJ-1449: Add clojure.string functions for portability to ClojureScript<br />
<a href="http://dev.clojure.org/jira/browse/CLJ-1449">http://dev.clojure.org/jira/browse/CLJ-1449</a>
</li>

<li>Launching a Socket Server<br />
<a href="http://clojure.org/reference/repl_and_main#_launching_a_socket_server">http://clojure.org/reference/repl_and_main#_launching_a_socket_server</a>
</li>

<li>API for clojure.string<br />
<a href="http://clojure.github.io/clojure/branch-master/clojure.string-api.html">http://clojure.github.io/clojure/branch-master/clojure.string-api.html</a>
</li>

<li>Clojars:<br />
<a href="https://clojars.org/">https://clojars.org/</a>
</li>

<li>Seznam knihoven na Clojars:<br />
<a href="https://clojars.org/projects">https://clojars.org/projects</a>
</li>

<li>Clojure Cookbook: Templating HTML with Enlive<br />
<a href="https://github.com/clojure-cookbook/clojure-cookbook/blob/master/07_webapps/7-11_enlive.asciidoc">https://github.com/clojure-cookbook/clojure-cookbook/blob/master/07_webapps/7-11_enlive.asciidoc</a>
</li>

<li>An Introduction to Enlive<br />
<a href="https://github.com/swannodette/enlive-tutorial/">https://github.com/swannodette/enlive-tutorial/</a>
</li>

<li>Enlive na GitHubu<br />
<a href="https://github.com/cgrand/enlive">https://github.com/cgrand/enlive</a>
</li>

<li>Expectations: příklady atd.<br />
<a href="http://jayfields.com/expectations/">http://jayfields.com/expectations/</a>
</li>

<li>Expectations na GitHubu<br />
<a href="https://github.com/jaycfields/expectations">https://github.com/jaycfields/expectations</a>
</li>

<li>Lein-expectations na GitHubu<br />
<a href="https://github.com/gar3thjon3s/lein-expectations">https://github.com/gar3thjon3s/lein-expectations</a>
</li>

<li>Testing Clojure With Expectations<br />
<a href="https://semaphoreci.com/blog/2014/09/23/testing-clojure-with-expectations.html">https://semaphoreci.com/blog/2014/09/23/testing-clojure-with-expectations.html</a>
</li>

<li>Clojure testing TDD/BDD libraries: clojure.test vs Midje vs Expectations vs Speclj<br />
<a href="https://www.reddit.com/r/Clojure/comments/1viilt/clojure_testing_tddbdd_libraries_clojuretest_vs/">https://www.reddit.com/r/Clojure/comments/1viilt/clojure_testing_tddbdd_libraries_clojuretest_vs/</a>
</li>

<li>Testing: One assertion per test<br />
<a href="http://blog.jayfields.com/2007/06/testing-one-assertion-per-test.html">http://blog.jayfields.com/2007/06/testing-one-assertion-per-test.html</a>
</li>

<li>Rewriting Your Test Suite in Clojure in 24 hours<br />
<a href="http://blog.circleci.com/rewriting-your-test-suite-in-clojure-in-24-hours/">http://blog.circleci.com/rewriting-your-test-suite-in-clojure-in-24-hours/</a>
</li>

<li>Clojure doc: zipper<br />
<a href="http://clojuredocs.org/clojure.zip/zipper">http://clojuredocs.org/clojure.zip/zipper</a>
</li>

<li>Clojure doc: parse<br />
<a href="http://clojuredocs.org/clojure.xml/parse">http://clojuredocs.org/clojure.xml/parse</a>
</li>

<li>Clojure doc: xml-zip<br />
<a href="http://clojuredocs.org/clojure.zip/xml-zip">http://clojuredocs.org/clojure.zip/xml-zip</a>
</li>

<li>Clojure doc: xml-seq<br />
<a href="http://clojuredocs.org/clojure.core/xml-seq">http://clojuredocs.org/clojure.core/xml-seq</a>
</li>

<li>Parsing XML in Clojure<br />
<a href="https://github.com/clojuredocs/guides">https://github.com/clojuredocs/guides</a>
</li>

<li>Clojure Zipper Over Nested Vector<br />
<a href="https://vitalyper.wordpress.com/2010/11/23/clojure-zipper-over-nested-vector/">https://vitalyper.wordpress.com/2010/11/23/clojure-zipper-over-nested-vector/</a>
</li>

<li>Understanding Clojure's PersistentVector implementation<br />
<a href="http://blog.higher-order.net/2009/02/01/understanding-clojures-persistentvector-implementation">http://blog.higher-order.net/2009/02/01/understanding-clojures-persistentvector-implementation</a>
</li>

<li>Understanding Clojure's PersistentHashMap (deftwice...)<br />
<a href="http://blog.higher-order.net/2009/09/08/understanding-clojures-persistenthashmap-deftwice.html">http://blog.higher-order.net/2009/09/08/understanding-clojures-persistenthashmap-deftwice.html</a>
</li>

<li>Assoc and Clojure's PersistentHashMap: part ii<br />
<a href="http://blog.higher-order.net/2010/08/16/assoc-and-clojures-persistenthashmap-part-ii.html">http://blog.higher-order.net/2010/08/16/assoc-and-clojures-persistenthashmap-part-ii.html</a>
</li>

<li>Ideal Hashtrees (paper)<br />
<a href="http://lampwww.epfl.ch/papers/idealhashtrees.pdf">http://lampwww.epfl.ch/papers/idealhashtrees.pdf</a>
</li>

<li>4Clojure<br />
<a href="http://www.4clojure.com/">http://www.4clojure.com/</a>
</li>

<li>ClojureDoc (rozcestník s&nbsp;dokumentací jazyka Clojure)<br />
<a href="http://clojuredocs.org/">http://clojuredocs.org/</a>
</li>

<li>Clojure (na Wikipedia EN)<br />
<a href="http://en.wikipedia.org/wiki/Clojure">http://en.wikipedia.org/wiki/Clojure</a>
</li>

<li>Clojure (na Wikipedia CS)<br />
<a href="http://cs.wikipedia.org/wiki/Clojure">http://cs.wikipedia.org/wiki/Clojure</a>
</li>

<li>SICP (The Structure and Interpretation of Computer Programs)<br />
<a href="http://mitpress.mit.edu/sicp/">http://mitpress.mit.edu/sicp/</a>
</li>

<li>Pure function<br />
<a href="http://en.wikipedia.org/wiki/Pure_function">http://en.wikipedia.org/wiki/Pure_function</a>
</li>

<li>Funkcionální programování<br />
<a href="http://cs.wikipedia.org/wiki/Funkcionální_programování">http://cs.wikipedia.org/wiki/Funkcionální_programování</a>
</li>

<li>Čistě funkcionální (datové struktury, jazyky, programování)<br />
<a href="http://cs.wikipedia.org/wiki/Čistě_funkcionální">http://cs.wikipedia.org/wiki/Čistě_funkcionální</a>
</li>

<li>Clojure Macro Tutorial (Part I, Getting the Compiler to Write Your Code For You)<br />
<a href="http://www.learningclojure.com/2010/09/clojure-macro-tutorial-part-i-getting.html">http://www.learningclojure.com/2010/09/clojure-macro-tutorial-part-i-getting.html</a>
</li>

<li>Clojure Macro Tutorial (Part II: The Compiler Strikes Back)<br />
<a href="http://www.learningclojure.com/2010/09/clojure-macro-tutorial-part-ii-compiler.html">http://www.learningclojure.com/2010/09/clojure-macro-tutorial-part-ii-compiler.html</a>
</li>

<li>Clojure Macro Tutorial (Part III: Syntax Quote)<br />
<a href="http://www.learningclojure.com/2010/09/clojure-macro-tutorial-part-ii-syntax.html">http://www.learningclojure.com/2010/09/clojure-macro-tutorial-part-ii-syntax.html</a>
</li>

<li>Tech behind Tech: Clojure Macros Simplified<br />
<a href="http://techbehindtech.com/2010/09/28/clojure-macros-simplified/">http://techbehindtech.com/2010/09/28/clojure-macros-simplified/</a>
</li>

<li>Fatvat - Exploring functional programming: Clojure Macros<br />
<a href="http://www.fatvat.co.uk/2009/02/clojure-macros.html">http://www.fatvat.co.uk/2009/02/clojure-macros.html</a>
</li>

</ol>



<p></p><p></p>
<p><small>Autor: <a href="http://www.fit.vutbr.cz/~tisnovpa">Pavel Tišnovský</a> &nbsp; 2021</small></p>
</body>
</html>
