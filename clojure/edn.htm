<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
        "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html>
<head>
<title>Formát EDN: extensible data notation</title>
<meta name="Author" content="Pavel Tisnovsky" />
<meta name="Generator" content="vim" />
<meta http-equiv="content-type" content="text/html; charset=utf-8" />
<style type="text/css">
         body {color:#000000; background:#ffffff;}
         h1  {font-family: arial, helvetica, sans-serif; color:#ffffff; background-color:#c00000; text-align:center; padding-left:1em}
         h2  {font-family: arial, helvetica, sans-serif; color:#ffffff; background-color:#0000c0; padding-left:1em; text-align:left}
         h3  {font-family: arial, helvetica, sans-serif; color:#000000; background-color:#c0c0c0; padding-left:1em; text-align:left}
         h4  {font-family: arial, helvetica, sans-serif; color:#000000; background-color:#e0e0e0; padding-left:1em; text-align:left}
         a   {font-family: arial, helvetica, sans-serif;}
         li  {font-family: arial, helvetica, sans-serif; color:#000000; text-align:justify; width:450px;}
         ol  {font-family: arial, helvetica, sans-serif; color:#000000; text-align:justify; width:450px;}
         ul  {font-family: arial, helvetica, sans-serif; color:#000000; text-align:justify; width:450px;}
         p   {font-family: arial, helvetica, sans-serif; color:#000000; text-align:justify;}
         pre {background:#e0e0e0}
</style>
</head>

<body>

<h1>Formát EDN: extensible data notation</h1>

<h3>Pavel Tišnovský</h3>

<p></p>

<h1>Úvodník</h1>

<p></p>



<h2>Obsah</h2>

<p><a href="#k01">1. Formát EDN: extensible data notation</a></p>
<p><a href="#k02">*** 2. Sémantické rozdíly mezi formáty EDN, JSON a XML</a></p>
<p><a href="#k03">*** 3. Základní datové typy podporované formátem EDN</a></p>
<p><a href="#k04">*** 4. Řetězce versus keywords</a></p>
<p><a href="#k05">*** 5. Kolekce, které lze v&nbsp;EDN použít</a></p>
<p><a href="#k06">*** 6. Pravidla pro porovnávání</a></p>
<p><a href="#k07">*** 7. Štítky jako prostředek pro rozšíření formátu EDN</a></p>
<p><a href="#k08">8. Podpora formátu EDN v&nbsp;různých programovacích jazycích</a></p>
<p><a href="#k09">9. Clojure</a></p>
<p><a href="#k10">10. Python</a></p>
<p><a href="#k11">*** 11. Go</a></p>
<p><a href="#k12">12. Praktická část</a></p>
<p><a href="#k13">*** 13. Převod mezi formátem JSON a EDN v&nbsp;Pythonu a Clojure</a></p>
<p><a href="#k14">*** 14. Převod mezi formátem EDN a JSON v&nbsp;Pythonu a Clojure</a></p>
<p><a href="#k15">*** 15. Převod mezi souborem .properties a formátem EDN v&nbsp;Clojure</a></p>
<p><a href="#k16">*** 16. Převod mezi XML a EDN (plná varianta zachovávající vlastnosti XML)</a></p>
<p><a href="#k17">*** 17. Převod XML do různých forem formátu EDN s&nbsp;využitím knihovny Tupelo.forest</a></p>
<p><a href="#k18">*** 18. Práce s&nbsp;formátem EDN v&nbsp;jazyce Go</a></p>
<p><a href="#k19">19. Repositář s&nbsp;demonstračními příklady</a></p>
<p><a href="#k20">20. Odkazy na Internetu</a></p>



<p><a name="k01"></a></p>
<h2 id="k01">1. Formát EDN: extensible data notation</h2>

<p>V&nbsp;dnešním článku se seznámíme se základními vlastnostmi datového
formátu pojmenovaného <i>EDN</i>, což je zkratka celého názvu <i>Extensible
Data Notation</i>. Tento formát vychází ze syntaxe a sémantiky <a
href="https://www.root.cz/n/clojure/">programovacího jazyka Clojure</a>, je
tedy založen na původních <a
href="https://en.wikipedia.org/wiki/S-expression">S-výrazech</a> rozšířených o
možnost zápisu map (slovníků), množin a vektorů. Popis tohoto formátu (a tím
pádem i popis syntaxe Clojure, resp.&nbsp;jeho podmnožiny) naleznete na stránce
<a
href="https://github.com/edn-format/edn">https://github.com/edn-format/edn</a>,
nás však v&nbsp;dnešním článku bude zajímat i porovnání EDN s&nbsp;dalšími
často používanými datovými formáty JSON a XML a taktéž to, jak lze EDN využít i
v&nbsp;dalších programovacích jazycích; nejenom v&nbsp;samotném Clojure.
Popíšeme si tudíž podporu EDN <a
href="https://pypi.org/project/edn-format/">v&nbsp;Pythonu</a> a <a
href="https://github.com/go-edn/edn">v&nbsp;jazyce Go</a>; ve skutečnosti je
však EDN podporován <a href="https://lib.rs/crates/edn-rs">i v&nbsp;Rustu</a>
či <a href="https://github.com/bpsm/edn-java">v&nbsp;Javě</a>.</p>

<img src="https://i.iinfo.cz/images/214/kawa1-3.png" class="image-366709" alt="&#160;" width="256" height="256" />
<p><i>Obrázek 1: Logo programovacího jazyka Clojure.</i></p>



<p><a name="k02"></a></p>
<h2 id="k02">2. Sémantické rozdíly mezi formáty EDN, JSON a XML</h2>

<p>V&nbsp;současnosti se pro přenos strukturovaných informací (ale popř.&nbsp;i
tabulek) používá relativně velké množství různých datových formátů.
Pravděpodobně nejznámějšími formáty jsou XML a JSON, ovšem vznikají a postupně
jsou adaptovány i další formáty, ať již textové (<a
href="https://yaml.org/">YAML</a>, <a
href="https://github.com/edn-format/edn">edn</a>) či binární (<a
href="http://bsonspec.org/">BSON</a>, <a href="http://bjson.org/">B-JSON</a>,
<a href="https://github.com/FasterXML/smile-format-specification">Smile</a>, <a
href="https://developers.google.com/protocol-buffers/">Protocol-Buffers</a>).
Je velmi pravděpodobné, že se JSON i XML bude i nadále poměrně masivně
využívat, na druhou stranu je dobré znát i některá omezení těchto formátů,
popř.&nbsp;vztah JSONu a XML k&nbsp;formátu EDN. Nejedná se nám přitom o
syntaktické rozdíly &ndash; ty jsou viditelné na první pohled a každý dovede
tyto rozdíly rozeznat. Důležitější jsou rozdíly sémantické a pravě zde můžeme
nalézt celou řadu různých omezení.</p>

<p></p>



<p><a name="k03"></a></p>
<h2 id="k03">3. Základní datové typy podporované formátem EDN</h2>

<p></p>



<p><a name="k04"></a></p>
<h2 id="k04">4. Řetězce versus keywords</h2>

<p></p>



<p><a name="k05"></a></p>
<h2 id="k05">5. Kolekce, které lze v&nbsp;EDN použít</h2>

<p></p>



<p><a name="k06"></a></p>
<h2 id="k06">6. Pravidla pro porovnávání</h2>

<p></p>



<p><a name="k07"></a></p>
<h2 id="k07">7. Štítky jako prostředek pro rozšíření formátu EDN</h2>

<p></p>



<p><a name="k08"></a></p>
<h2 id="k08">8. Podpora formátu EDN v&nbsp;různých programovacích jazycích</h2>

<p>Formát EDN sice není rozšířený do takové míry, jako formáty XML a JSON,
ovšem i přesto ho lze použít v&nbsp;relativně velkém množství programovacích
jazyků. Jedná se v&nbsp;první řadě o jazyk Clojure, což ovšem není nijak
překvapivé, neboť EDN je prakticky celý odvozen od Clojure (až na štítky).
Kromě Clojure je možné EDN použít v&nbsp;Pythonu, Javě, JavaScriptu, Rustu,
jazyku Go a s&nbsp;velkou pravděpodobností i v&nbsp;dalších jazycích (ovšem již
zmíněné jazyky pokrývají velké množství aplikačních použití). Podporu pro
formát EDN nalezneme i v&nbsp;projektu <a
href="https://github.com/babashka/babashka">Babashka</a>, s&nbsp;nímž jsme se
již na stránkách Roota <a
href="https://www.root.cz/clanky/babashka-interpret-clojure-urceny-pro-rychle-spousteni-utilit-z-prikazoveho-radku/">ve
stručnosti seznámili</a>.</p>

<p>Knihovny pro práci s&nbsp;EDN pro jednotlivé jazyky:</p>

<table>
<tr><th>#</th><th>Programovací jazyk</th><th>Knihovna</th></tr>
<tr><td>1</td><td>Clojure</td><td><a href="https://clojuredocs.org/clojure.edn">clojure.edn (standardní)</a></td></tr>
<tr><td>2</td><td>Python</td><td><a href="https://github.com/swaroopch/edn_format">edn_format</a></td></tr>
<tr><td>3</td><td>Java</td><td><a href="https://github.com/bpsm/edn-java">edn-java</a></td></tr>
<tr><td>4</td><td>JavaScript</td><td><a href="https://github.com/shaunxcode/jsedn">jsedn</a></td></tr>
<tr><td>5</td><td>Rust</td><td><a href="https://lib.rs/crates/edn-rs">edn-rs</a></td></tr>
<tr><td>6</td><td>Go</td><td><a href="https://github.com/go-edn/edn">go-edn/edn</a></td></tr>
<tr><td>7</td><td>Babashka</td><td><a href="https://book.babashka.org/#libraries">clojure.edn (standardní)</a></td></tr>
</table>



<p><a name="k09"></a></p>
<h2 id="k09">9. Clojure</h2>

<p>Podpora formátu EDN v&nbsp;programovacím jazyku Clojure je
&bdquo;nativní&ldquo;, což znamená, že všechny potřebné funkce jsou přímo
součástí standardní knihovny tohoto jazyka. Konkrétně se jedná o balíček (nebo
možná přesněji řečeno jmenný prostor) <a
href="https://clojuredocs.org/clojure.edn">clojure.edn</a>, ve kterém nalezneme
pouhé dvě funkce:</p>

<table>
<tr><th>#</th><th>Funkce</th><th>Stručný popis funkce</th></tr>
<tr><td>1</td><td>read</td><td>načtení dat ve formátu EDN z&nbsp;libovolného vstupního proudu</td></tr>
<tr><td>2</td><td>read-string</td><td>načtení dat ve formátu EDN z&nbsp;řetězce (získaného libovolným postupem)</td></tr>
</table>

<p>Jak je v&nbsp;ekosystému programovacího jazyka Clojure zvykem, lze nápovědu
k&nbsp;těmto funkcím získat přímo z&nbsp;interaktivního prostředí vybaveném
smyčkou REPL. Nejdříve je ovšem nutné příslušnou knihovnu načíst:</p>

<pre>
user=&gt; <strong>(require '[clojure.edn :as edn])</strong>
</pre>

<p>Nápověda k&nbsp;funkci <strong>read</strong>:</p>

<pre>
user=&gt; <strong>(doc edn/read)</strong>
-------------------------
clojure.edn/read
([] [stream] [opts stream])
  Reads the next object from stream, which must be an instance of
  java.io.PushbackReader or some derivee.  stream defaults to the
  current value of *in*.
&nbsp;
  Reads data in the edn format (subset of Clojure data):
  http://edn-format.org
&nbsp;
  opts is a map that can include the following keys:
  :eof - value to return on end-of-file. When not supplied, eof throws an exception.
  :readers  - a map of tag symbols to data-reader functions to be considered before default-data-readers.
              When not supplied, only the default-data-readers will be used.
  :default - A function of two args, that will, if present and no reader is found for a tag,
             be called with the tag and the value.
</pre>

<p>Nápověda k&nbsp;funkci <strong>read-string</strong>:</p>

<pre>
user=&gt; <strong>(doc edn/read-string)</strong>
-------------------------
clojure.edn/read-string
([s] [opts s])
  Reads one object from the string s. Returns <strong>nil</strong> when s is <strong>nil</strong> or empty.
&nbsp;
  Reads data in the edn format (subset of Clojure data):
  http://edn-format.org
&nbsp;
  opts is a map as per clojure.edn/read
</pre>

<p>Možná se nyní ptáte, jakým způsobem se vlastně <i>zapisují</i> data ve
formátu EDN. Odpověď je jednoduchá &ndash; výpis jakékoli datové struktury
jazyka Clojure či jakékoli hodnoty do čitelného formátu již odpovídá formátu
EDN. To znamená, že pro tyto účely lze použít například standardní funkci
<strong>prn-str</strong>, jejíž výsledek se uloží do souboru funkcí
<strong>spit</strong> atd.:</p>

<pre>
user=&gt; <strong>(doc prn-str)</strong>
-------------------------
clojure.core/prn-str
([&amp; xs])
  prn to a string, returning it
</pre>

<p><div class="rs-tip-major">Poznámka: s&nbsp;formátem EDN se v&nbsp;ekosystému
jazyka Clojure setkáme doslova na každém kroku. Ostatně samotné projektové
soubory <strong>project.clj</strong> i přes odlišnou zkratku <i>jsou</i>
reprezentovány jako EDN:</div></p>

<pre>
(defproject edn2json "0.1.0-SNAPSHOT"
  :description "FIXME: write description"
  :url "http://example.com/FIXME"
  :license {:name "EPL-2.0 OR GPL-2.0-or-later WITH Classpath-exception-2.0"
            :url "https://www.eclipse.org/legal/epl-2.0/"}
  :dependencies [[org.clojure/clojure "1.10.1"]
                 [org.clojure/data.json "2.2.0"]]
  :plugins [[lein-project-edn "0.3.0"]]
  :project-edn {:output-file "details.edn"}
  :main ^:skip-aot edn2json.core
  :target-path "target/%s"
  :profiles {:uberjar {:aot :all
                       :jvm-opts ["-Dclojure.compiler.direct-linking=true"]}})
</pre>

<p>Podobně soubory <strong>deps.edn</strong> podporované <a
href="https://www.root.cz/clanky/novinky-v-clojure-verze-1-9-0/">od Clojure
1.9</a> mají tento formát:</p>

<pre>
{:deps
    {net.mikera/core.matrix {:mvn/version "0.62.0"}}}
</pre>

<p>Do souborů ve formátu EDN lze vyexportovat i detailní informace o projektu,
což zajišťuje plugin <strong>lein-project-edn</strong>:</p>

<pre>
{:aliases {"downgrade" "upgrade"},
 :checkout-deps-shares
 [:source-paths
  :test-paths
  :resource-paths
  :compile-path
  "#'leiningen.core.classpath/checkout-deps-paths"],
 :clean-targets [:target-path],
 :compile-path
 "/home/ptisnovs/src/presentations/edn/edn2json/target/default/classes",
 :dependencies
 ([org.clojure/clojure "1.10.1"]
  [org.clojure/data.json "2.2.0"]
  [nrepl/nrepl "0.7.0" :exclusions ([org.clojure/clojure])]
  [clojure-complete/clojure-complete
   "0.2.5"
   :exclusions
   ([org.clojure/clojure])]
  [venantius/ultra "0.6.0"]),
 :deploy-repositories
 [["clojars"
   {:url "https://repo.clojars.org/",
    :password :gpg,
    :username :gpg}]],
 :description "FIXME: write description",
 :eval-in :subprocess,
 :global-vars {},
 :group "edn2json",
 :jar-exclusions ["#\"^\\.\"" "#\"\\Q/.\\E\""],
 :jvm-opts
 ["-XX:-OmitStackTraceInFastThrow"
  "-XX:+TieredCompilation"
  "-XX:TieredStopAtLevel=1"],
 :license
 {:name "EPL-2.0 OR GPL-2.0-or-later WITH Classpath-exception-2.0",
  :url "https://www.eclipse.org/legal/epl-2.0/"},
 :main edn2json.core,
 :monkeypatch-clojure-test false,
 :name "edn2json",
 :native-path
 "/home/ptisnovs/src/presentations/edn/edn2json/target/default/native",
 :offline? false,
 :pedantic? ranges,
 :plugin-repositories
 [["central"
   {:url "https://repo1.maven.org/maven2/", :snapshots false}]
  ["clojars" {:url "https://repo.clojars.org/"}]],
 :plugins
 ([lein-project-edn/lein-project-edn "0.3.0"]
  [venantius/ultra "0.6.0"]
  [lein-kibit/lein-kibit "0.1.8"]),
 :prep-tasks ["javac" "compile"],
 :profiles
 {:uberjar
  {:aot [:all], :jvm-opts ["-Dclojure.compiler.direct-linking=true"]},
  :whidbey/repl
  {:dependencies [[mvxcvi/whidbey "RELEASE"]],
   :repl-options
   {:init
    (do
     nil
     (clojure.core/require 'whidbey.repl)
     (whidbey.repl/init! nil)),
    :custom-init (do nil (whidbey.repl/update-print-fn!)),
    :nrepl-context
    {:interactive-eval {:printer whidbey.repl/render-str}}}}},
 :project-edn {:output-file "details.clj"},
 :release-tasks
 [["vcs" "assert-committed"]
  ["change" "version" "leiningen.release/bump-version" "release"]
  ["vcs" "commit"]
  ["vcs" "tag"]
  ["deploy"]
  ["change" "version" "leiningen.release/bump-version"]
  ["vcs" "commit"]
  ["vcs" "push"]],
 :repl-options
 {:init
  (do
   (do
    (clojure.core/require 'ultra.hardcore)
    (clojure.core/require 'whidbey.repl)
    (whidbey.repl/init! nil)
    (ultra.hardcore/configure!
     {:repl
      {:print-meta false,
       :map-delimiter "",
       :print-fallback :print,
       :sort-keys true}})))},
 :repositories
 [["central"
   {:url "https://repo1.maven.org/maven2/", :snapshots false}]
  ["clojars" {:url "https://repo.clojars.org/"}]],
 :resource-paths
 ("/home/ptisnovs/src/presentations/edn/edn2json/dev-resources"
  "/home/ptisnovs/src/presentations/edn/edn2json/resources"),
 :root
 "/home/ptisnovs/src/presentations/edn/edn2json",
 :source-paths
 ("/home/ptisnovs/src/presentations/edn/edn2json/src"),
 :target-path
 "/home/ptisnovs/src/presentations/edn/edn2json/target/default",
 :test-paths
 ("/home/ptisnovs/src/presentations/edn/edn2json/test"),
 :test-selectors {:default (constantly true)},
 :uberjar-exclusions ["#\"(?i)^META-INF/[^/]*\\.(SF|RSA|DSA)$\""],
 :url "http://example.com/FIXME",
 :version "0.1.0-SNAPSHOT"}
</pre>



<p><a name="k10"></a></p>
<h2 id="k10">10. Python</h2>

<p>V&nbsp;programovacím jazyku Python je formát EDN dostupný přes balíček
nazvaný přímočaře <a
href="https://github.com/swaroopch/edn_format">edn_format</a>. Tento balíček
nainstalujete jednoduše přes <strong>pip</strong>:</p>

<pre>
$ <strong>pip install --user edn_format</strong>
</pre>

<p>Dostupné jsou tyto funkce:</p>

<table>
<tr><th>#</th><th>Funkce</th><th>Stručný popis funkce</th></tr>
<tr><td>1</td><td>loads</td><td>načtení objektu z&nbsp;formátu EDN</td></tr>
<tr><td>2</td><td>loads_all</td><td>načtení všech objektů z&nbsp;formátu EDN (výsledkem může být prázdný seznam)</td></tr>
<tr><td>3</td><td>dumps</td><td>opak předchozích funkcí &ndash; export dat do formátu EDN</td></tr>
</table>

<p>Nápovědu k&nbsp;jednotlivým funkcím opět &ndash; podobně jako v&nbsp;případě
jazyka Clojure &ndash; získáme přímo přes interaktivní smyčku REPL.</p>

<p>Import příslušného balíčku:</p>

<pre>
&gt;&gt;&gt; <strong>import edn_format</strong>
</pre>

<p>Zobrazení nápovědy k&nbsp;celému balíčku:</p>

<pre>
&gt;&gt;&gt; <strong>help(edn_format)</strong>
&nbsp;
Help on package edn_format:
&nbsp;
NAME
    edn_format - # -*- coding: utf-8 -*-
&nbsp;
PACKAGE CONTENTS
    edn_dump
    edn_lex
    edn_parse
    exceptions
    immutable_dict
    immutable_list
    parsetab
</pre>

<p>Nápověda k&nbsp;vybrané funkci, například k&nbsp;funkci
<strong>loads_all</strong>:</p>

<pre>
&gt;&gt;&gt; <strong>help(edn_format.loads_all)</strong>
&nbsp;
...
...
...
</pre>



<p><a name="k11"></a></p>
<h2 id="k11">11. Go</h2>

<p></p>

<pre>
go get olympos.io/encoding/edn
</pre>



<p><a name="k12"></a></p>
<h2 id="k12">12. Praktická část</h2>

<p>Druhá část dnešního článku bude zaměřena spíše prakticky. Ukážeme si totiž
některé možnosti práce s&nbsp;formátem EDN v&nbsp;programovacích jazycích
Clojure, Python i Go. Uvidíme &ndash; což je ovšem očekávatelné &ndash; že se
jednotlivé jazyky od sebe velmi odlišují při operacích typu serializace a
deserializace datových struktur (též se setkáme s&nbsp;termíny marshalling a
unmarshalling, které sice striktně řečeno nemají úplně shodný význam, ale
mnohdy se mezi sebou zaměňují).</p>



<p><a name="k13"></a></p>
<h2 id="k13">13. Převod mezi formátem JSON a EDN v&nbsp;Pythonu a Clojure</h2>

<pre>
<i>#!/usr/bin/env python3</i>
&nbsp;
<i># Converts structured data from JSON format into EDN format.</i>
&nbsp;
import sys
import json
import edn_format
&nbsp;
<i># Check if command line argument is specified (it is mandatory).</i>
if len(sys.argv) &lt; 2:
    print("Usage:")
    print("  json2edn.py input_file.csv")
    print("Example:")
    print("  json2edn.py report.csv")
    sys.exit(1)
&nbsp;
<i># First command line argument should contain name of input JSON file.</i>
input_json = sys.argv[1]
&nbsp;
<i># Try to open the JSON file specified.</i>
with open(input_json) as json_input:
    <i># open the JSON file and parse it</i>
    payload = json.load(json_input)
    <i># dump the parsed data structure into EDN format</i>
    print(edn_format.dumps(payload))
</pre>

<pre>
(ns json2edn.core)

(require '[clojure.data.json :as json])
(require '[clojure.edn :as edn])


(defn json->edn
  "Convert JSON format into EDN format."
  [json-file-name edn-file-name]
  (let [payload (-> json-file-name slurp (json/read-str :key-fn keyword))
        fout    (clojure.java.io/writer edn-file-name)]
    (clojure.pprint/pprint payload)
    (clojure.pprint/pprint payload fout)))


(defn -main
  [& args]
  (json->edn "details.json" "details.edn"))
</pre>



<p><a name="k14"></a></p>
<h2 id="k14">14. Převod mezi formátem EDN a JSON v&nbsp;Pythonu a Clojure</h2>

<pre>
#!/usr/bin/env python3

# Converts structured data from EDN format into JSON format.

import sys
import json
import edn_format

# Check if command line argument is specified (it is mandatory).
if len(sys.argv) < 2:
    print("Usage:")
    print("  edn2json.py input_file.edn")
    print("Example:")
    print("  edn2json.py report.edn")
    sys.exit(1)

# First command line argument should contain name of input EDN file.
filename = sys.argv[1]


# Taken from https://github.com/swaroopch/edn_format/issues/76#issuecomment-749618312
def edn_to_map(x):
    if isinstance(x, edn_format.ImmutableDict):
        return {edn_to_map(k): edn_to_map(v) for k, v in x.items()}
    elif isinstance(x, edn_format.ImmutableList):
        return [edn_to_map(v) for v in x]
    elif isinstance(x, edn_format.Keyword):
        return x.name
    else:
        return x


# Try to open the EDN file specified.
with open(filename, "r") as edn_input:
    # open the EDN file and parse it
    payload = edn_format.loads(edn_input.read())
    print(json.dumps(edn_to_map(payload), indent=2))
</pre>

<pre>
(ns edn2json.core)

(require '[clojure.data.json :as json])
(require '[clojure.edn :as edn])


(defn edn->json
  "Convert EDN format into JSON format."
  [edn-file-name json-file-name]
  (let [payload (-> edn-file-name slurp edn/read-string)
        output (with-out-str (json/pprint payload))]
    (spit json-file-name output)))


(defn -main
  [& args]
  (edn->json "details.edn" "details.json"))
</pre>



<p><a name="k15"></a></p>
<h2 id="k15">15. Převod mezi souborem .properties a formátem EDN v&nbsp;Clojure</h2>

<pre>
(ns properties2edn.core)


(defn properties->map
  "Convert properties entries into a map. Keys are converted into proper keywords."
  [properties]
  (into {}
        (for [[k v] properties]
              [(keyword k) v])))


(defn load-properties-file
  "Load configuration from the provided properties file."
  [file-name]
  (with-open [reader (clojure.java.io/reader file-name)]
    (let [properties (java.util.Properties.)]
      (.load properties reader)
      (properties->map properties))))


(defn properties->edn
  "Convert properties file into EDN format."
  [properties-file-name edn-file-name]
  (let [payload (load-properties-file properties-file-name)
        fout    (clojure.java.io/writer edn-file-name)]
    (clojure.pprint/pprint payload fout)))


(defn -main
  [& args]
  (properties->edn "test.properties" "test.edn"))
</pre>

<pre>
# This file is shared currently between this Gradle build and the
# Ant builds for fd303 and JavaScript. Keep the dotted notation for
# the properties to minimize the changes in the dependencies.
thrift.version=0.14.0
thrift.groupid=org.apache.thrift
release=false

# Local Install paths
install.path=/usr/local/lib
install.javadoc.path=/usr/local/lib

# Test execution properties
testPort=9090

# Test with Clover Code coverage (disabled by default)
cloverEnabled=false

# Maven dependency download locations
mvn.repo=https://repo1.maven.org/maven2
apache.repo=https://repository.apache.org/content/repositories/releases

# Apache Maven publish
license=https://www.apache.org/licenses/LICENSE-2.0.txt
maven-repository-url=https://repository.apache.org/service/local/staging/deploy/maven2
maven-repository-id=apache.releases.https

# Dependency versions
httpclient.version=4.5.10
httpcore.version=4.4.12
slf4j.version=1.7.28
#servlet.version=2.5
#It contains servlet3
tomcat.embed.version=8.5.46
junit.version=4.12
mockito.version=1.10.19
javax.annotation.version=1.3.2
</pre>

<pre>
{:tomcat.embed.version "8.5.46",
 :thrift.version "0.14.0",
 :httpclient.version "4.5.10",
 :mockito.version "1.10.19",
 :javax.annotation.version "1.3.2",
 :thrift.groupid "org.apache.thrift",
 :license "https://www.apache.org/licenses/LICENSE-2.0.txt",
 :install.javadoc.path "/usr/local/lib",
 :slf4j.version "1.7.28",
 :httpcore.version "4.4.12",
 :release "false",
 :mvn.repo "https://repo1.maven.org/maven2",
 :maven-repository-url
 "https://repository.apache.org/service/local/staging/deploy/maven2",
 :maven-repository-id "apache.releases.https",
 :testPort "9090",
 :apache.repo
 "https://repository.apache.org/content/repositories/releases",
 :junit.version "4.12",
 :cloverEnabled "false",
 :install.path "/usr/local/lib"}
</pre>



<p><a name="k16"></a></p>
<h2 id="k16">16. Převod mezi XML a EDN (plná varianta zachovávající vlastnosti XML)</h2>

<pre>
(ns xml2edn.core)

(use '[clojure.xml])


(defn xml->edn
  "Convert XML file into EDN format."
  [xml-file-name edn-file-name]
  (let [payload (clojure.xml/parse "nested.xml")
        fout    (clojure.java.io/writer edn-file-name)]
    (clojure.pprint/pprint payload fout)))


(defn -main
  [& args]
  (xml->edn "nested.xml" "nested.edn"))
</pre>

<pre>
<?xml version="1.0"?>
<first>
  <second value="A">
    <third>
      <fourth>Hello A</fourth>
    </third>
  </second>
  <second value="B">
    <third>
      <fourth>Hello B</fourth>
    </third>
  </second>
</first>
</pre>

<pre>
{:tag :first,
 :attrs nil,
 :content
 [{:tag :second,
   :attrs {:value "A"},
   :content
   [{:tag :third,
     :attrs nil,
     :content [{:tag :fourth, :attrs nil, :content ["Hello A"]}]}]}
  {:tag :second,
   :attrs {:value "B"},
   :content
   [{:tag :third,
     :attrs nil,
     :content [{:tag :fourth, :attrs nil, :content ["Hello B"]}]}]}]}
</pre>



<p><a name="k17"></a></p>
<h2 id="k17">17. Převod XML do různých forem formátu EDN s&nbsp;využitím knihovny Tupelo.forest</h2>


<pre>
(defproject forest-demo "0.1.0-SNAPSHOT"
  :description "FIXME: write description"
  :url "http://example.com/FIXME"
  :license {:name "EPL-2.0 OR GPL-2.0-or-later WITH Classpath-exception-2.0"
            :url "https://www.eclipse.org/legal/epl-2.0/"}
  :dependencies [[org.clojure/clojure "1.10.1"]
                 [tupelo "21.04.13"]]
  :main ^:skip-aot forest-demo.core
  :target-path "target/%s"
  :profiles {:uberjar {:aot :all
                       :jvm-opts ["-Dclojure.compiler.direct-linking=true"]}})
</pre>

<pre>
(ns forest-demo.core)

(require '[clojure.xml :as xml])
(require '[tupelo.forest :as tf])


(defn pprint-to-file
  [filename payload]
  (clojure.pprint/pprint payload (clojure.java.io/writer filename)))


(defn -main
  [& args]
  (let [payload        (xml/parse "nested.xml")
        hiccup-format  (tf/enlive->hiccup payload)
        bush-format    (tf/enlive->bush payload)
        tree-format    (tf/enlive->tree payload)]
    (pprint-to-file "nested-enlive.edn" payload)
    (pprint-to-file "nested-hiccup.edn" hiccup-format)
    (pprint-to-file "nested-bush.edn" bush-format)
    (pprint-to-file "nested-tree.edn" tree-format)))
</pre>

<pre>
<?xml version="1.0"?>
<first>
  <second value="A">
    <third>
      <fourth>Hello A</fourth>
    </third>
  </second>
  <second value="B">
    <third>
      <fourth>Hello B</fourth>
    </third>
  </second>
</first>
</pre>

<pre>
{:tag :first,
 :attrs nil,
 :content
 [{:tag :second,
   :attrs {:value "A"},
   :content
   [{:tag :third,
     :attrs nil,
     :content [{:tag :fourth, :attrs nil, :content ["Hello A"]}]}]}
  {:tag :second,
   :attrs {:value "B"},
   :content
   [{:tag :third,
     :attrs nil,
     :content [{:tag :fourth, :attrs nil, :content ["Hello B"]}]}]}]}
</pre>

<pre>
[:first
 [:second {:value "A"} [:third [:fourth "Hello A"]]]
 [:second {:value "B"} [:third [:fourth "Hello B"]]]]
</pre>

<pre>
[{:tag :first}
 [{:value "A", :tag :second}
  [{:tag :third} [{:tag :fourth, :value "Hello A"}]]]
 [{:value "B", :tag :second}
  [{:tag :third} [{:tag :fourth, :value "Hello B"}]]]]
</pre>

<pre>
{:tag :first,
 :tupelo.forest/kids
 [{:value "A",
   :tag :second,
   :tupelo.forest/kids
   [{:tag :third,
     :tupelo.forest/kids
     [{:tag :fourth, :value "Hello A", :tupelo.forest/kids []}]}]}
  {:value "B",
   :tag :second,
   :tupelo.forest/kids
   [{:tag :third,
     :tupelo.forest/kids
     [{:tag :fourth, :value "Hello B", :tupelo.forest/kids []}]}]}]}
</pre>


<p><a name="k18"></a></p>
<h2 id="k18">18. Práce s&nbsp;formátem EDN v&nbsp;jazyce Go</h2>

<p></p>

<pre>
package main

import (
        "fmt"
        "olympos.io/encoding/edn"
)

// User1 je uživatelsky definovaná datová struktura s privátními atributy
type User1 struct {
        id      uint32
        name    string
        surname string
}

// User2 je uživatelsky definovaná datová struktura s viditelnými atributy
type User2 struct {
        ID      uint32
        Name    string
        Surname string
}

func main() {
        user1 := User1{
                1,
                "Pepek",
                "Vyskoč"}

        user2 := User2{
                1,
                "Pepek",
                "Vyskoč"}

        fmt.Println("user1")
        user1EDN, _ := edn.Marshal(user1)
        fmt.Println(string(user1EDN))

        fmt.Println()
        user1PrettyEDN, _ := edn.MarshalPPrint(user1, nil)
        fmt.Println(string(user1PrettyEDN))
        fmt.Println()

        fmt.Println("user2")
        user2EDN, _ := edn.Marshal(user2)
        fmt.Println(string(user2EDN))

        fmt.Println()
        user2PrettyEDN, _ := edn.MarshalPPrint(user2, nil)
        fmt.Println(string(user2PrettyEDN))
        fmt.Println()
}
</pre>

<pre>
package main

import (
        "fmt"
        "olympos.io/encoding/edn"
)

// User3 je uživatelsky definovaná datová struktura s viditelnými atributy
type User3 struct {
        ID      uint32 `edn:"id"`
        Name    string `edn:"user-name"`
        Surname string `edn:"surname"`
}

func main() {
        user3 := User3{
                1,
                "Pepek",
                "Vyskoč"}

        fmt.Println("user3")
        user3EDN, _ := edn.Marshal(user3)
        fmt.Println(string(user3EDN))
        fmt.Println()

        user3PrettyEDN, _ := edn.MarshalPPrint(user3, nil)
        fmt.Println(string(user3PrettyEDN))
        fmt.Println()
}
</pre>

<pre>
package main

import (
        "fmt"
        "olympos.io/encoding/edn"
)

// User3 je uživatelsky definovaná datová struktura s viditelnými atributy
type User3 struct {
        ID      uint32 `edn:"id"`
        Name    string `edn:"user-name"`
        Surname string `edn:"surname"`
}

func main() {
        var users = [3]User3{
                User3{
                        ID:      1,
                        Name:    "Pepek",
                        Surname: "Vyskoč"},
                User3{
                        ID:      2,
                        Name:    "Pepek",
                        Surname: "Vyskoč"},
                User3{
                        ID:      3,
                        Name:    "Josef",
                        Surname: "Vyskočil"},
        }

        fmt.Println("users")
        usersEDN, _ := edn.Marshal(users)
        fmt.Println(string(usersEDN))
        fmt.Println()

        usersPrettyEDN, _ := edn.MarshalPPrint(users, nil)
        fmt.Println(string(usersPrettyEDN))
        fmt.Println()
}
</pre>

<pre>
package main

import (
        "fmt"
        "olympos.io/encoding/edn"
)

// User3 je uživatelsky definovaná datová struktura s viditelnými atributy
type User3 struct {
        ID      uint32 `edn:"id"`
        Name    string `edn:"user-name"`
        Surname string `edn:"surname"`
}

func main() {
        m1 := make(map[string]User3)

        m1["user-id-1"] = User3{
                ID:      1,
                Name:    "Pepek",
                Surname: "Vyskoč"}

        m1["user-id-3"] = User3{
                ID:      2,
                Name:    "Josef",
                Surname: "Vyskočil"}

        fmt.Println("users map")
        usersMapEDN, _ := edn.Marshal(m1)
        fmt.Println(string(usersMapEDN))
        fmt.Println()
        usersPrettyEDN, _ := edn.MarshalPPrint(m1, nil)
        fmt.Println(string(usersPrettyEDN))
        fmt.Println()
}
</pre>



<p><a name="k19"></a></p>
<h2 id="k19">19. Repositář s&nbsp;demonstračními příklady</h2>

<p>Zdrojové kódy všech dnes popsaných demonstračních příkladů vyvinutých
v&nbsp;programovacích jazycích Clojure, Python i Go, byly uloženy do Git
repositáře, který je dostupný na adrese <a
href="https://github.com/tisnik/presentations">https://github.com/tisnik/presentations</a>:</p>

<table>
<tr><th> #</th><th>Zdrojový kód</th><th>Stručný popis souboru</th><th>Cesta</th></tr>
<tr><td> 1</td><td>json2edn.py</td><td>konverze mezi formátem JSON a EDN naprogramovaná v&nbsp;Pythonu</td><td><a href="https://github.com/tisnik/presentations/blob/master/edn/json2edn.py">https://github.com/tisnik/presentations/blob/master/edn/json2edn.py</a></td></tr>
<tr><td> 2</td><td>edn2json.py</td><td>konverze mezi formátem EDN a JSON naprogramovaná v&nbsp;Pythonu</td><td><a href="https://github.com/tisnik/presentations/blob/master/edn/edn2json.py">https://github.com/tisnik/presentations/blob/master/edn/edn2json.py</a></td></tr>
<tr><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td></tr>
<tr><td> 3</td><td>json2edn (adresář)</td><td>konverze mezi formátem JSON a EDN naprogramovaná v&nbsp;Clojure</td><td><a href="https://github.com/tisnik/presentations/blob/master/edn/json2edn">https://github.com/tisnik/presentations/blob/master/edn/json2edn</a></td></tr>
<tr><td> 4</td><td>edn2json (adresář)</td><td>konverze mezi formátem EDN a JSON naprogramovaná v&nbsp;Clojure</td><td><a href="https://github.com/tisnik/presentations/blob/master/edn/edn2json">https://github.com/tisnik/presentations/blob/master/edn/edn2json</a></td></tr>
<tr><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td></tr>
<tr><td> 3</td><td>properties2edn (adresář)</td><td>konverze mezi .properties souborem a formátem EDN (Clojure)</td><td><a href="https://github.com/tisnik/presentations/blob/master/edn/properties2edn">https://github.com/tisnik/presentations/blob/master/edn/properties2edn</a></td></tr>
<tr><td> 4</td><td>xml2edn (adresář)</td><td>konverze mezi XML a formátem EDN (Clojure, plná konverze)</td><td><a href="https://github.com/tisnik/presentations/blob/master/edn/xml2edn">https://github.com/tisnik/presentations/blob/master/edn/xml2edn</a></td></tr>
<tr><td> 5</td><td>forest-demo (adresář)</td><td>různé možnosti konverze mezi XML a formátem EDN</td><td><a href="https://github.com/tisnik/presentations/blob/master/edn/forest-demo">https://github.com/tisnik/presentations/blob/master/edn/forest-demo</a></td></tr>
<tr><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td></tr>
<tr><td> 6</td><td>go-edn-1 (adresář)</td><td>serializace (marshalling) datové struktury do formátu EDN</td><td><a href="https://github.com/tisnik/presentations/blob/master/edn/go-edn-1">https://github.com/tisnik/presentations/blob/master/edn/go-edn-1</a></td></tr>
<tr><td> 7</td><td>go-edn-2 (adresář)</td><td>specifikace názvů klíčů v&nbsp;EDN formátu</td><td><a href="https://github.com/tisnik/presentations/blob/master/edn/go-edn-2">https://github.com/tisnik/presentations/blob/master/edn/go-edn-2</a></td></tr>
<tr><td> 8</td><td>go-edn-3 (adresář)</td><td>uložení pole datových struktur do formátu EDN</td><td><a href="https://github.com/tisnik/presentations/blob/master/edn/go-edn-3">https://github.com/tisnik/presentations/blob/master/edn/go-edn-3</a></td></tr>
<tr><td> 9</td><td>go-edn-4 (adresář)</td><td>uložení mapy datových struktur do formátu EDN</td><td><a href="https://github.com/tisnik/presentations/blob/master/edn/go-edn-4">https://github.com/tisnik/presentations/blob/master/edn/go-edn-4</a></td></tr>
<tr><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td></tr>
<tr><td>10</td><td>go-edn-5 (adresář)</td><td>deserializace (unmarshalling) datové struktury z&nbsp;formátu EDN</td><td><a href="https://github.com/tisnik/presentations/blob/master/edn/go-edn-5">https://github.com/tisnik/presentations/blob/master/edn/go-edn-5</a></td></tr>
</table>



<p><a name="k20"></a></p>
<h2 id="k20">20. Odkazy na Internetu</h2>

<ol>

<li>edn &ndash; extensible data notation<br />
<a href="https://github.com/edn-format/edn">https://github.com/edn-format/edn</a>
</li>

<li>Programming with Data and EDN<br />
<a href="https://docs.datomic.com/cloud/whatis/edn.html">https://docs.datomic.com/cloud/whatis/edn.html</a>
</li>

<li>Video about EDN<br />
<a href="https://docs.datomic.com/cloud/livetutorial/edntutorial.html">https://docs.datomic.com/cloud/livetutorial/edntutorial.html</a>
</li>

<li>(Same) video about EDN on Youtube<br />
<a href="https://www.youtube.com/watch?v=5eKgRcvEJxU">https://www.youtube.com/watch?v=5eKgRcvEJxU</a>
</li>

<li>clojure.edn<br />
<a href="https://clojuredocs.org/clojure.edn">https://clojuredocs.org/clojure.edn</a>
</li>

<li>API for clojure.edn - Clojure v1.10.2 (stable)<br />
<a href="https://clojure.github.io/clojure/clojure.edn-api.html">https://clojure.github.io/clojure/clojure.edn-api.html</a>
</li>

<li>Clojure EDN Walkthrough<br />
<a href="https://www.compoundtheory.com/clojure-edn-walkthrough/">https://www.compoundtheory.com/clojure-edn-walkthrough/</a>
</li>

<li>Články týkající se Pythonu na Rootu<br />
<a href="https://www.root.cz/n/python/">https://www.root.cz/n/python/</a>
</li>

<li>Články týkající se programovacího jazyka Clojure na Rootu<br />
<a href="https://www.root.cz/n/clojure/">https://www.root.cz/n/clojure/</a>
</li>

<li>Seriál Programovací jazyk Go<br />
<a href="https://www.root.cz/serialy/programovaci-jazyk-go/">https://www.root.cz/serialy/programovaci-jazyk-go/</a>
</li>

<li>Crux<br />
<a href="https://opencrux.com/main/index.html">https://opencrux.com/main/index.html</a>
</li>

<li>Crux Installation<br />
<a href="https://opencrux.com/reference/21.04-1.16.0/installation.html">https://opencrux.com/reference/21.04-1.16.0/installation.html</a>
</li>

<li>read<br />
<a href="https://clojuredocs.org/clojure.edn/read">https://clojuredocs.org/clojure.edn/read</a>
</li>

<li>read-string<br />
<a href="https://clojuredocs.org/clojure.edn/read-string">https://clojuredocs.org/clojure.edn/read-string</a>
</li>

<li>Tupelo 21.04.12 (dokumentace)<br />
<a href="https://cloojure.github.io/doc/tupelo/">https://cloojure.github.io/doc/tupelo/</a>
</li>

<li>tupelo - Clojure With A Spoonful of Honey<br />
<a href="https://clojars.org/tupelo">https://clojars.org/tupelo</a>
</li>

<li>Clojure Cookbook: Templating HTML with Enlive<br />
<a href="https://github.com/clojure-cookbook/clojure-cookbook/blob/master/07_webapps/7-11_enlive.asciidoc">https://github.com/clojure-cookbook/clojure-cookbook/blob/master/07_webapps/7-11_enlive.asciidoc</a>
</li>

<li>An Introduction to Enlive<br />
<a href="https://github.com/swannodette/enlive-tutorial/">https://github.com/swannodette/enlive-tutorial/</a>
</li>

<li>Enlive na GitHubu<br />
<a href="https://github.com/cgrand/enlive">https://github.com/cgrand/enlive</a>
</li>

<li>data.json<br />
<a href="https://github.com/clojure/data.json">https://github.com/clojure/data.json</a>
</li>

<li>data.json API reference<br />
<a href="https://clojure.github.io/data.json/">https://clojure.github.io/data.json/</a>
</li>

<li>Clojure: Writing JSON to a File/Reading JSON From a File<br />
<a href="https://dzone.com/articles/clojure-writing-json">https://dzone.com/articles/clojure-writing-json</a>
</li>

<li>How to pretty print JSON to a file in Clojure?<br />
<a href="https://stackoverflow.com/questions/23307552/how-to-pretty-print-json-to-a-file-in-clojure">https://stackoverflow.com/questions/23307552/how-to-pretty-print-json-to-a-file-in-clojure</a>
</li>

<li>go-edn / edn<br />
<a href="https://github.com/go-edn/edn">https://github.com/go-edn/edn</a>
</li>

<li>Queries (Crux)<br />
<a href="https://opencrux.com/reference/21.04-1.16.0/queries.html">https://opencrux.com/reference/21.04-1.16.0/queries.html</a>
</li>

<li>Essential EDN<br />
<a href="https://opencrux.com/tutorials/essential-edn.html">https://opencrux.com/tutorials/essential-edn.html</a>
</li>

<li>Babashka: interpret Clojure určený pro rychlé spouštění utilit z příkazového řádku<br />
<a href="https://www.root.cz/clanky/babashka-interpret-clojure-urceny-pro-rychle-spousteni-utilit-z-prikazoveho-radku/">https://www.root.cz/clanky/babashka-interpret-clojure-urceny-pro-rychle-spousteni-utilit-z-prikazoveho-radku/</a>
</li>

</ol>



<p></p><p></p>
<p><small>Autor: <a href="http://www.fit.vutbr.cz/~tisnovpa">Pavel Tišnovský</a> &nbsp; 2021</small></p>
</body>
</html>

