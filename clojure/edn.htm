<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
        "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html>
<head>
<title>Formát EDN: extensible data notation</title>
<meta name="Author" content="Pavel Tisnovsky" />
<meta name="Generator" content="vim" />
<meta http-equiv="content-type" content="text/html; charset=utf-8" />
<style type="text/css">
         body {color:#000000; background:#ffffff;}
         h1  {font-family: arial, helvetica, sans-serif; color:#ffffff; background-color:#c00000; text-align:center; padding-left:1em}
         h2  {font-family: arial, helvetica, sans-serif; color:#ffffff; background-color:#0000c0; padding-left:1em; text-align:left}
         h3  {font-family: arial, helvetica, sans-serif; color:#000000; background-color:#c0c0c0; padding-left:1em; text-align:left}
         h4  {font-family: arial, helvetica, sans-serif; color:#000000; background-color:#e0e0e0; padding-left:1em; text-align:left}
         a   {font-family: arial, helvetica, sans-serif;}
         li  {font-family: arial, helvetica, sans-serif; color:#000000; text-align:justify; width:450px;}
         ol  {font-family: arial, helvetica, sans-serif; color:#000000; text-align:justify; width:450px;}
         ul  {font-family: arial, helvetica, sans-serif; color:#000000; text-align:justify; width:450px;}
         p   {font-family: arial, helvetica, sans-serif; color:#000000; text-align:justify;}
         pre {background:#e0e0e0}
</style>
</head>

<body>

<h1>Formát EDN: extensible data notation</h1>

<h3>Pavel Tišnovský</h3>

<p></p>

<h1>Úvodník</h1>

<p>V dnešním článku se seznámíme se základními vlastnostmi datového formátu pojmenovaného EDN, což je zkratka celého názvu Extensible Data Notation. Jedná se o formát určený pro reprezentaci a přenosy strukturovaných dat, který je navíc rozšiřitelný o další typy hodnot.</p>



<h2>Obsah</h2>

<p><a href="#k01">1. Formát EDN: extensible data notation</a></p>
<p><a href="#k02">2. Sémantické rozdíly mezi formáty EDN, JSON a XML</a></p>
<p><a href="#k03">3. Základní datové typy podporované formátem EDN</a></p>
<p><a href="#k04">4. Řetězce versus keywords</a></p>
<p><a href="#k05">5. Kolekce, které lze v&nbsp;EDN použít</a></p>
<p><a href="#k06">6. Klíče</a></p>
<p><a href="#k07">7. Štítky jako prostředek pro rozšíření formátu EDN</a></p>
<p><a href="#k08">8. Podpora formátu EDN v&nbsp;různých programovacích jazycích</a></p>
<p><a href="#k09">9. Clojure</a></p>
<p><a href="#k10">10. Python</a></p>
<p><a href="#k11">11. Go</a></p>
<p><a href="#k12">12. Praktická část</a></p>
<p><a href="#k13">13. Převod mezi formátem JSON a EDN v&nbsp;Pythonu a Clojure</a></p>
<p><a href="#k14">14. Převod mezi formátem EDN a JSON v&nbsp;Pythonu a Clojure</a></p>
<p><a href="#k15">15. Převod mezi souborem .properties a formátem EDN v&nbsp;Clojure</a></p>
<p><a href="#k16">16. Převod mezi XML a EDN (plná varianta zachovávající vlastnosti XML)</a></p>
<p><a href="#k17">17. Převod XML do různých forem formátu EDN s&nbsp;využitím knihovny Tupelo.forest</a></p>
<p><a href="#k18">18. Práce s&nbsp;formátem EDN v&nbsp;jazyce Go, vlastní štítky rozšiřující možnosti EDN</a></p>
<p><a href="#k19">19. Repositář s&nbsp;demonstračními příklady</a></p>
<p><a href="#k20">20. Odkazy na Internetu</a></p>



<p><a name="k01"></a></p>
<h2 id="k01">1. Formát EDN: extensible data notation</h2>

<p>V&nbsp;dnešním článku se seznámíme se základními vlastnostmi datového
formátu pojmenovaného <i>EDN</i>, což je zkratka celého názvu <i>Extensible
Data Notation</i>. Tento formát, který je primárně určený pro přenos
strukturovaných dat mezi různými systémy a službami, vychází ze syntaxe a
sémantiky <a href="https://www.root.cz/n/clojure/">programovacího jazyka
Clojure</a>, je tedy založen na původních <a
href="https://en.wikipedia.org/wiki/S-expression">S-výrazech</a> rozšířených o
možnost zápisu map (slovníků), množin a vektorů. Popis tohoto formátu (a tím
pádem i popis syntaxe Clojure, resp.&nbsp;jeho podmnožiny) naleznete na stránce
<a
href="https://github.com/edn-format/edn">https://github.com/edn-format/edn</a>,
nás však v&nbsp;dnešním článku bude zajímat i porovnání EDN s&nbsp;dalšími
často používanými datovými formáty JSON a XML a taktéž to, jak lze EDN využít i
v&nbsp;dalších programovacích jazycích; nejenom v&nbsp;samotném Clojure.
Popíšeme si tudíž podporu EDN <a
href="https://pypi.org/project/edn-format/">v&nbsp;Pythonu</a> a <a
href="https://github.com/go-edn/edn">v&nbsp;jazyce Go</a>; ve skutečnosti je
však EDN podporován <a href="https://lib.rs/crates/edn-rs">i v&nbsp;Rustu</a>
či <a href="https://github.com/bpsm/edn-java">v&nbsp;Javě</a>.</p>

<img src="https://i.iinfo.cz/images/214/kawa1-3.png" class="image-366709" alt="&#160;" width="256" height="256" />
<p><i>Obrázek 1: Logo programovacího jazyka Clojure.</i></p>

<p><div class="rs-tip-major">Poznámka: &nbsp;formátem EDN se setkáme například
v&nbsp;databázovém systému <a
href="https://opencrux.com/main/index.html">Crux</a>, kde EDN slouží mj.&nbsp;i
pro tvorbu dotazů (Crux je velmi zajímavou technologií, ke které se taktéž na
stránkách Roota vrátíme):</div></p>

<pre>
(crux/q
         (crux/db node) 
         '{:find [p1] 
           :where [[p1 :name n]
                   [p1 :last-name n]
                   [p1 :name name]]
           :in [name]}
         "Pavel")
</pre>

<pre>
(crux/q
         (crux/db node)
         '{:find [(sum ?heads)
                  (min ?heads)
                  (max ?heads)
                  (count ?heads)
                  (count-distinct ?heads)]
           :where [[(identity [["Cerberus" 3]
                               ["Medusa" 1]
                               ["Cyclops" 1]
                               ["Chimera" 1]])
                    [[?monster ?heads]]]]})
</pre>



<p><a name="k02"></a></p>
<h2 id="k02">2. Sémantické rozdíly mezi formáty EDN, JSON a XML</h2>

<p>V&nbsp;současnosti se pro přenos strukturovaných informací (ale popř.&nbsp;i
tabulek) používá relativně velké množství různých datových formátů.
Pravděpodobně nejznámějšími formáty jsou XML a JSON, ovšem vznikají a postupně
jsou adaptovány i další formáty, ať již textové (<a
href="https://yaml.org/">YAML</a>, <a
href="https://github.com/edn-format/edn">edn</a>) či binární (<a
href="http://bsonspec.org/">BSON</a>, <a href="http://bjson.org/">B-JSON</a>,
<a href="https://github.com/FasterXML/smile-format-specification">Smile</a>, <a
href="https://developers.google.com/protocol-buffers/">Protocol-Buffers</a>).
Je velmi pravděpodobné, že se JSON i XML bude i nadále poměrně masivně
využívat, na druhou stranu je dobré znát i některá omezení těchto formátů,
popř.&nbsp;vztah JSONu a XML k&nbsp;formátu EDN. Nejedná se nám přitom o
syntaktické rozdíly &ndash; ty jsou viditelné na první pohled a každý dovede
tyto rozdíly rozeznat (i když například absence čárek v&nbsp;EDN je krokem
kupředu). Důležitější jsou rozdíly sémantické a pravě zde můžeme nalézt celou
řadu různých omezení.</p>

<p>Nejvíce podobností nalezneme mezi formáty EDN a JSONem. JSON má ovšem
několik omezení, a to jak v&nbsp;podporovaných základních datových typech
(chybí například celá čísla), tak i v&nbsp;podpoře kolekcí (jen pole a mapa) a
v&nbsp;rozšiřitelnosti (výhodné by například bylo rozšíření o typ pro
jednoznačnou reprezentaci časových razítek). Pravděpodobně nejdůležitějším
rozdílem je chybějící sémantika pro uložení množin a taktéž omezení klíčů
v&nbsp;mapách &ndash; musí se totiž jednat o řetězce, zatímco ve formátu EDN
může být klíč jakoukoli hodnotou &ndash; tedy například mapou, vektorem
(relativně často používáno) nebo dokonce lze použít <strong>nil</strong>.</p>

<p>V&nbsp;předchozím textu jsem několikrát použil sousloví &bdquo;formát
XML&ldquo;, i když se mnohdy setkáme spíše s&nbsp;označením &bdquo;jazyk
XML&ldquo; (které je ovšem nepřesné). XML, i když se jedná o <i>značkovací
jazyk</i> (<i>markup language</i>) se totiž začal používat i pro přenosy
strukturovaných netextových dat, což se může při zpětném pohledu znát poněkud
zvláštní, neboť pro tento účel není příliš uzpůsoben (ale už fakt, že se XML
podařilo &bdquo;ohnout&ldquo; něco říká o jeho flexibilitě). Sémantika XML se
v&nbsp;mnoha ohledech odlišuje jak od JSONu, tak i od EDN, protože je
v&nbsp;něm nutné datové struktury reprezentovat neexplicitně &ndash; celý XML
dokument tvoří stromovou strukturu a pouze z&nbsp;popisu jednotlivých značek
popř.&nbsp;jejich atributů vyplyne, jaká konkrétní struktura je vlastně
v&nbsp;XML dokumentu uložena, tj.&nbsp;zda se jedná o seznam, asociativní pole
či o množinu (navíc i typ jednotlivých prvků je nutné popsat externě). Ovšem
například v&nbsp;případě množiny a asociativního pole se musí (externě)
kontrolovat integrita datové struktury.</p>

<p><div class="rs-tip-major">Poznámka: nutnost použít další XML s&nbsp;popisem
schématu je dvousečná zbraň; skvělá pro enterprise řešení, výhodná pro některé
nasazení v&nbsp;oblasti SOA, ovšem na druhou stranu je dosti neflexibilní. I
z&nbsp;tohoto důvodu se stále častěji v&nbsp;oblasti (nejenom) webových služeb
setkáme s&nbsp;formátem JSON.</div></p>



<p><a name="k03"></a></p>
<h2 id="k03">3. Základní datové typy podporované formátem EDN</h2>

<p>V&nbsp;datech reprezentovaných ve formátu EDN lze využít hned několik
datových typů, z&nbsp;nichž mnohé jsou známé i z&nbsp;dalších podobně
koncipovaných formátů (textové JSON, popř.&nbsp;binární formáty). Jedná se o
následující osmici základních datových typů:</p>

<table>
<tr><th>#</th><th>Typ</th><th>Popis</th><th>Příklad</th></tr>
<tr><td>1</td><td>nil</td><td>symbolizuje neexistující hodnotu</td><td><strong>nil</strong></td></tr>
<tr><td>2</td><td>boolean</td><td>pravdivostní</td><td><strong>true</strong>, <strong>false</strong></td></tr>
<tr><td>3</td><td>keyword</td><td>jednoznačný symbol (ovšem ne řetězec)</td><td><strong>:test</strong></td></tr>
<tr><td>4</td><td>string</td><td>běžný řetězec v&nbsp;Unicode</td><td><strong>"hello\n"</strong></td></tr>
<tr><td>5</td><td>character</td><td>jediný znak</td><td><strong>\newline</strong>, <strong>\c</strong></td></tr>
<tr><td>6</td><td>symbol</td><td>použití pro identifikátory, včetně specifikace jmenného prostoru</td><td><strong>foo/bar</strong></td></tr>
<tr><td>7</td><td>integer</td><td>celá čísla (64 bitů se znaménkem)</td><td><strong>42</strong></td></tr>
<tr><td>8</td><td>floating point numbers</td><td>hodnoty s&nbsp;plovoucí řádovou čárkou (double)</td><td><strong>1.3e-10</strong></td></tr>
</table>

<p><div class="rs-tip-major">Poznámka: povšimněte si, že jsou jednoznačně
definovány celočíselné hodnoty i s&nbsp;jejich rozsahem, což je v&nbsp;praxi
velmi důležité, neboť ne všechny hodnoty typu <strong>int64</strong> lze beze
ztráty přesnosti reprezentovat typem <strong>double</strong></div></p>



<p><a name="k04"></a></p>
<h2 id="k04">4. Řetězce versus keywords</h2>

<p>Na chvíli se zastavme u datového typu <i>keyword</i>. Překlad tohoto slova
je poněkud problematický kvůli jeho dvojímu významu (alespoň
v&nbsp;programování), takže se pokusím používat sousloví &bdquo;klíčová
hesla&ldquo;, protože termín &bdquo;keywords&ldquo; v&nbsp;jazyce Clojure i ve
formátu EDN neznamená, že by se jednalo o rezervovaná klíčová slova jazyka.
Klíčová hesla, která reprezentují samy sebe (svoje označení) jsou na použití
jednodušší než symboly či řetězce, protože jim nemůže být přiřazena žádná
hodnota. Na co se tedy vlastně v&nbsp;praxi tento typ formy hodí? Jedním
z&nbsp;důvodů zavedení tohoto typu formy do programovacího jazyka Clojure i do
formátu EDN byla podpora pro datového typu (kolekce) mapa (asociativní pole),
v&nbsp;němž je možné uchovávat dvojice klíč:hodnota. A jako klíče jsou
s&nbsp;výhodou používána právě klíčová hesla, protože jejich hodnotu nelze
měnit a navíc se jejich hešovací hodnota (zkráceně heš) může vypočítat pouze
jedenkrát.</p>

<p>Příklad použití tohoto typu:</p>

<pre>
{
  :description "FIXME: write description"
  :url "http://example.com/FIXME"
  :license {...}
  :dependencies [...]
  :plugins [...]
  :project-edn {...}
  :target-path "target/%s"
  :profiles {...}
}
</pre>

<p><div class="rs-tip-major">Poznámka: vidíme tedy, že by bylo možné klíčová
hesla nahradit řetězci. To je pochopitelně dovoleno, i když se nejedná o příliš
idiomatický EDN:</div></p>

<pre>
{
  "description" "FIXME: write description"
  "url" "http://example.com/FIXME"
  "license" {...}
  "dependencies" [...]
  "plugins" [...]
  "project-edn" {...}
  "target-path" "target/%s"
  "profiles" {...}
}
</pre>



<p><a name="k05"></a></p>
<h2 id="k05">5. Kolekce, které lze v&nbsp;EDN použít</h2>

<p>Největší sémantický rozdíl mezi EDN a dalšími formáty spočívá v&nbsp;tom,
jaké kolekce jsou podporovány. Přitom zde pod pojmem kolekce myslíme datovou
strukturu, která je používána jako kontejner pro další hodnoty &ndash;
pochopitelně je dovoleno rekurzivní využití kolekcí v&nbsp;jiné kolekci
(naprosto stejně, jako je tomu v&nbsp;JSONu, ovšem s&nbsp;tím rozdílem, že JSON
podporuje jen mapy a pole/vektory). Ve formátu EDN se používají čtyři typy
kolekcí: seznamy (<strong>list</strong>), vektory (<strong>vector</strong>),
množiny (<strong>set</strong>) a mapy <strong>map</strong> neboli asociativní
pole. Všechny čtyři typy složených forem, ať již se jedná o seznam, vektor,
množinu či mapu, jsou z&nbsp;obou stran uvozeny závorkami, přičemž musí být
zachována párovost závorek (ke každé otevírací závorce přísluší jedna závorka
uzavírací), která je kontrolována při načítání dat uložených v&nbsp;EDN.</p>

<p>Prvky seznamů se již tradičně (více než padesát let!) zapisují do kulatých
závorek. Pro zápis vektorů se používají hranaté závorky, mapy využívají závorky
složené a množiny taktéž závorky složené, ovšem před otevírací závorkou se musí
napsat křížek (<i>hash</i>, #). Jednotlivé prvky jsou od sebe odděleny bílým
znakem. V&nbsp;následující tabulce jsou vypsány všechny čtyři typy složených
forem:</p>

<table>
<tr><th>Typ kolekce</th><th>Zápis</th></tr>
<tr><td>Seznam</td><td>(prvky)</td></tr>
<tr><td>Vektor</td><td>[prvky]</td></tr>
<tr><td>Mapa</td><td>{dvojice klíč-hodnota}</td></tr>
<tr><td>Množina</td><td>#{unikátní prvky}</td></tr>
</table>

<p>Nyní by tedy měl být následující datový soubor dobře čitelný. Jedná se o
mapu s&nbsp;několika prvky, jejichž hodnoty jsou buď reprezentovány řetězci,
vektory nebo dalšími mapami:</p>

<pre>
{
  :description "FIXME: write description"
  :url "http://example.com/FIXME"
  :license {:name "EPL-2.0 OR GPL-2.0-or-later WITH Classpath-exception-2.0"
            :url "https://www.eclipse.org/legal/epl-2.0/"}
  :dependencies [[org.clojure/clojure "1.10.1"]
                 [tupelo "21.04.13"]]
  :target-path "target/%s"
  :profiles {:uberjar {:aot :all
                       :jvm-opts ["-Dclojure.compiler.direct-linking=true"]}})
}
</pre>



<p><a name="k06"></a></p>
<h2 id="k06">6. Klíče</h2>

<p>Již <a href="#k02">ve druhé kapitole</a> jsme si řekli, že ve formátu EDN
lze v&nbsp;mapách použít jako klíče naprosto libovolné hodnoty, což si můžeme
velmi snadno demonstrovat v&nbsp;interaktivní smyčce REPL jazyka Clojure.
Dokonce si ani nemusíte jazyk Clojure instalovat, protože postačuje příklady
otestovat na stránce <a
href="https://clojurescript.io/">https://clojurescript.io/</a>:</p>

<pre>
user=&gt; <strong>{:foo "bar"}</strong>
{:foo "bar"}
&nbsp;
user=&gt; <strong>{42 "answer"}</strong>
{42 "answer"}
&nbsp;
user=&gt; <strong>{[1 2 3] "a vector"}</strong>
{[1 2 3] "a vector"}
&nbsp;
user=&gt; <strong>{{:type :map} "map is a key"}</strong>
{{:type :map} "map is a key"}
&nbsp;
user=&gt; <strong>{{:another-key [1 2 3]} "strange key"}</strong>
{{:another-key [1 2 3]} "strange key"}
&nbsp;
user=&gt; <strong>{nil "nil as a key"}</strong>
{nil "nil as a key"}
</pre>

<p><div class="rs-tip-major">Poznámka: liché prvky jsou klíče, sudé hodnotami.
Použít lze i čárky pro oddělení jednotlivých dvojic klíč-hodnota:</div></p>

<pre>
user=&gt; <strong>{{:another-key [1 2 3]}, "strange key"}</strong>
{{:another-key [1 2 3]} "strange key"}
</pre>



<p><a name="k07"></a></p>
<h2 id="k07">7. Štítky jako prostředek pro rozšíření formátu EDN</h2>

<p>Důvodem, proč se v&nbsp;názvu formátu (a to hned na jeho začátku) objevuje
slovo &bdquo;Extensible&ldquo; je fakt, že se skutečně jedná o rozšiřitelný
formát. Není sice možné rozšiřovat množství podporovaných kolekcí (ovšem na
druhou stranu &ndash; pravděpodobně žádná známá kolekce nechybí, až na obecný
graf), ale zato lze rozšiřovat počet datových typů. Pro tento účel se používají
takzvané štítky (<i>tags</i>), které začínají znakem # (hash). Již
v&nbsp;základní variantě EDN existují dva takové rozšiřující datové typy.</p>

<p>Prvním z&nbsp;těchto typů je časové razítko podle <a
href="https://www.ietf.org/rfc/rfc3339.txt">RFC-3339</a>:</p>

<pre>
#inst "1985-04-12T23:20:50.52Z"
</pre>

<p>To je velmi užitečné, ostatně právě v&nbsp;oblasti dat a časových razítek <a
href="https://xkcd.com/1179/">existují zmatky</a>.</p>

<p>Druhým z&nbsp;těchto typů je <a
href="https://en.wikipedia.org/wiki/Universally_unique_identifier">UUID</a>,
který se dnes skutečně využívá univerzálně:</p>

<pre>
#uuid "01234567-89ab-cdef-0123-456789abcdef"
</pre>

<p><div class="rs-tip-major">Poznámka: pochopitelně by bylo možné použít běžné
řetězce, ovšem poté by bylo nutné typ předepsat ve schématu, což není
jednoduché a mnohdy ani možné.</div></p>

<p>Použitím štítků se budeme podrobněji zabývat ve druhém pokračování dnešního
článku &ndash; jedná se totiž o relativně rozsáhlé a přitom užitečné téma.</p>



<p><a name="k08"></a></p>
<h2 id="k08">8. Podpora formátu EDN v&nbsp;různých programovacích jazycích</h2>

<p>Formát EDN sice není rozšířený do takové míry, jako formáty XML a JSON,
ovšem i přesto ho lze použít v&nbsp;relativně velkém množství programovacích
jazyků. Jedná se v&nbsp;první řadě o jazyk Clojure, což ovšem není nijak
překvapivé, neboť EDN je prakticky celý odvozen od Clojure (až na štítky).
Kromě Clojure je možné EDN použít v&nbsp;Pythonu, Javě, JavaScriptu, Rustu,
jazyku Go a s&nbsp;velkou pravděpodobností i v&nbsp;dalších jazycích (ovšem již
zmíněné jazyky pokrývají velké množství aplikačních použití). Podporu pro
formát EDN nalezneme i v&nbsp;projektu <a
href="https://github.com/babashka/babashka">Babashka</a>, s&nbsp;nímž jsme se
již na stránkách Roota <a
href="https://www.root.cz/clanky/babashka-interpret-clojure-urceny-pro-rychle-spousteni-utilit-z-prikazoveho-radku/">ve
stručnosti seznámili</a>.</p>

<p>Knihovny pro práci s&nbsp;EDN pro jednotlivé jazyky:</p>

<table>
<tr><th>#</th><th>Programovací jazyk</th><th>Knihovna</th></tr>
<tr><td>1</td><td>Clojure</td><td><a href="https://clojuredocs.org/clojure.edn">clojure.edn (standardní)</a></td></tr>
<tr><td>2</td><td>Python</td><td><a href="https://github.com/swaroopch/edn_format">edn_format</a></td></tr>
<tr><td>3</td><td>Java</td><td><a href="https://github.com/bpsm/edn-java">edn-java</a></td></tr>
<tr><td>4</td><td>JavaScript</td><td><a href="https://github.com/shaunxcode/jsedn">jsedn</a></td></tr>
<tr><td>5</td><td>Rust</td><td><a href="https://lib.rs/crates/edn-rs">edn-rs</a></td></tr>
<tr><td>6</td><td>Go</td><td><a href="https://github.com/go-edn/edn">go-edn/edn</a></td></tr>
<tr><td>7</td><td>Babashka</td><td><a href="https://book.babashka.org/#libraries">clojure.edn (standardní)</a></td></tr>
</table>



<p><a name="k09"></a></p>
<h2 id="k09">9. Clojure</h2>

<p>Podpora formátu EDN v&nbsp;programovacím jazyku Clojure je
&bdquo;nativní&ldquo;, což znamená, že všechny potřebné funkce jsou přímo
součástí standardní knihovny tohoto jazyka. Konkrétně se jedná o balíček (nebo
možná přesněji řečeno jmenný prostor) <a
href="https://clojuredocs.org/clojure.edn">clojure.edn</a>, ve kterém nalezneme
pouhé dvě funkce:</p>

<table>
<tr><th>#</th><th>Funkce</th><th>Stručný popis funkce</th></tr>
<tr><td>1</td><td>read</td><td>načtení dat ve formátu EDN z&nbsp;libovolného vstupního proudu</td></tr>
<tr><td>2</td><td>read-string</td><td>načtení dat ve formátu EDN z&nbsp;řetězce (získaného libovolným postupem)</td></tr>
</table>

<p>Jak je v&nbsp;ekosystému programovacího jazyka Clojure zvykem, lze nápovědu
k&nbsp;těmto funkcím získat přímo z&nbsp;interaktivního prostředí vybaveném
smyčkou REPL. Nejdříve je ovšem nutné příslušnou knihovnu načíst:</p>

<pre>
user=&gt; <strong>(require '[clojure.edn :as edn])</strong>
</pre>

<p>Nápověda k&nbsp;funkci <strong>read</strong>:</p>

<pre>
user=&gt; <strong>(doc edn/read)</strong>
-------------------------
clojure.edn/read
([] [stream] [opts stream])
  Reads the next object from stream, which must be an instance of
  java.io.PushbackReader or some derivee.  stream defaults to the
  current value of *in*.
&nbsp;
  Reads data in the edn format (subset of Clojure data):
  http://edn-format.org
&nbsp;
  opts is a map that can include the following keys:
  :eof - value to return on end-of-file. When not supplied, eof throws an exception.
  :readers  - a map of tag symbols to data-reader functions to be considered before default-data-readers.
              When not supplied, only the default-data-readers will be used.
  :default - A function of two args, that will, if present and no reader is found for a tag,
             be called with the tag and the value.
</pre>

<p>Nápověda k&nbsp;funkci <strong>read-string</strong>:</p>

<pre>
user=&gt; <strong>(doc edn/read-string)</strong>
-------------------------
clojure.edn/read-string
([s] [opts s])
  Reads one object from the string s. Returns <strong>nil</strong> when s is <strong>nil</strong> or empty.
&nbsp;
  Reads data in the edn format (subset of Clojure data):
  http://edn-format.org
&nbsp;
  opts is a map as per clojure.edn/read
</pre>

<p>Možná se nyní ptáte, jakým způsobem se vlastně <i>zapisují</i> data ve
formátu EDN. Odpověď je jednoduchá &ndash; výpis jakékoli datové struktury
jazyka Clojure či jakékoli hodnoty do čitelného formátu již odpovídá formátu
EDN. To znamená, že pro tyto účely lze použít například standardní funkci
<strong>prn-str</strong>, jejíž výsledek se uloží do souboru funkcí
<strong>spit</strong> atd.:</p>

<pre>
user=&gt; <strong>(doc prn-str)</strong>
-------------------------
clojure.core/prn-str
([&amp; xs])
  prn to a string, returning it
</pre>

<p><div class="rs-tip-major">Poznámka: s&nbsp;formátem EDN se v&nbsp;ekosystému
jazyka Clojure setkáme doslova na každém kroku. Ostatně samotné projektové
soubory <strong>project.clj</strong> i přes odlišnou zkratku <i>jsou</i>
reprezentovány jako EDN:</div></p>

<pre>
(defproject edn2json "0.1.0-SNAPSHOT"
  :description "FIXME: write description"
  :url "http://example.com/FIXME"
  :license {:name "EPL-2.0 OR GPL-2.0-or-later WITH Classpath-exception-2.0"
            :url "https://www.eclipse.org/legal/epl-2.0/"}
  :dependencies [[org.clojure/clojure "1.10.1"]
                 [org.clojure/data.json "2.2.0"]]
  :plugins [[lein-project-edn "0.3.0"]]
  :project-edn {:output-file "details.edn"}
  :main ^:skip-aot edn2json.core
  :target-path "target/%s"
  :profiles {:uberjar {:aot :all
                       :jvm-opts ["-Dclojure.compiler.direct-linking=true"]}})
</pre>

<p>Podobně soubory <strong>deps.edn</strong> podporované <a
href="https://www.root.cz/clanky/novinky-v-clojure-verze-1-9-0/">od Clojure
1.9</a> mají tento formát:</p>

<pre>
{:deps
    {net.mikera/core.matrix {:mvn/version "0.62.0"}}}
</pre>

<p>Do souborů ve formátu EDN lze vyexportovat i detailní informace o projektu,
což zajišťuje plugin <strong>lein-project-edn</strong>:</p>

<pre>
{:aliases {"downgrade" "upgrade"},
 :checkout-deps-shares
 [:source-paths
  :test-paths
  :resource-paths
  :compile-path
  "#'leiningen.core.classpath/checkout-deps-paths"],
 :clean-targets [:target-path],
 :compile-path
 "/home/ptisnovs/src/presentations/edn/edn2json/target/default/classes",
 :dependencies
 ([org.clojure/clojure "1.10.1"]
  [org.clojure/data.json "2.2.0"]
  [nrepl/nrepl "0.7.0" :exclusions ([org.clojure/clojure])]
  [clojure-complete/clojure-complete
   "0.2.5"
   :exclusions
   ([org.clojure/clojure])]
  [venantius/ultra "0.6.0"]),
 :deploy-repositories
 [["clojars"
   {:url "https://repo.clojars.org/",
    :password :gpg,
    :username :gpg}]],
 :description "FIXME: write description",
 :eval-in :subprocess,
 :global-vars {},
 :group "edn2json",
 :jar-exclusions ["#\"^\\.\"" "#\"\\Q/.\\E\""],
 :jvm-opts
 ["-XX:-OmitStackTraceInFastThrow"
  "-XX:+TieredCompilation"
  "-XX:TieredStopAtLevel=1"],
 :license
 {:name "EPL-2.0 OR GPL-2.0-or-later WITH Classpath-exception-2.0",
  :url "https://www.eclipse.org/legal/epl-2.0/"},
 :main edn2json.core,
 :monkeypatch-clojure-test false,
 :name "edn2json",
 :native-path
 "/home/ptisnovs/src/presentations/edn/edn2json/target/default/native",
 :offline? false,
 :pedantic? ranges,
 :plugin-repositories
 [["central"
   {:url "https://repo1.maven.org/maven2/", :snapshots false}]
  ["clojars" {:url "https://repo.clojars.org/"}]],
 :plugins
 ([lein-project-edn/lein-project-edn "0.3.0"]
  [venantius/ultra "0.6.0"]
  [lein-kibit/lein-kibit "0.1.8"]),
 :prep-tasks ["javac" "compile"],
 :profiles
 {:uberjar
  {:aot [:all], :jvm-opts ["-Dclojure.compiler.direct-linking=true"]},
  :whidbey/repl
  {:dependencies [[mvxcvi/whidbey "RELEASE"]],
   :repl-options
   {:init
    (do
     nil
     (clojure.core/require 'whidbey.repl)
     (whidbey.repl/init! nil)),
    :custom-init (do nil (whidbey.repl/update-print-fn!)),
    :nrepl-context
    {:interactive-eval {:printer whidbey.repl/render-str}}}}},
 :project-edn {:output-file "details.clj"},
 :release-tasks
 [["vcs" "assert-committed"]
  ["change" "version" "leiningen.release/bump-version" "release"]
  ["vcs" "commit"]
  ["vcs" "tag"]
  ["deploy"]
  ["change" "version" "leiningen.release/bump-version"]
  ["vcs" "commit"]
  ["vcs" "push"]],
 :repl-options
 {:init
  (do
   (do
    (clojure.core/require 'ultra.hardcore)
    (clojure.core/require 'whidbey.repl)
    (whidbey.repl/init! nil)
    (ultra.hardcore/configure!
     {:repl
      {:print-meta false,
       :map-delimiter "",
       :print-fallback :print,
       :sort-keys true}})))},
 :repositories
 [["central"
   {:url "https://repo1.maven.org/maven2/", :snapshots false}]
  ["clojars" {:url "https://repo.clojars.org/"}]],
 :resource-paths
 ("/home/ptisnovs/src/presentations/edn/edn2json/dev-resources"
  "/home/ptisnovs/src/presentations/edn/edn2json/resources"),
 :root
 "/home/ptisnovs/src/presentations/edn/edn2json",
 :source-paths
 ("/home/ptisnovs/src/presentations/edn/edn2json/src"),
 :target-path
 "/home/ptisnovs/src/presentations/edn/edn2json/target/default",
 :test-paths
 ("/home/ptisnovs/src/presentations/edn/edn2json/test"),
 :test-selectors {:default (constantly true)},
 :uberjar-exclusions ["#\"(?i)^META-INF/[^/]*\\.(SF|RSA|DSA)$\""],
 :url "http://example.com/FIXME",
 :version "0.1.0-SNAPSHOT"}
</pre>



<p><a name="k10"></a></p>
<h2 id="k10">10. Python</h2>

<p>V&nbsp;programovacím jazyku Python je formát EDN dostupný přes balíček
nazvaný přímočaře <a
href="https://github.com/swaroopch/edn_format">edn_format</a>. Tento balíček
nainstalujete jednoduše přes <strong>pip</strong>:</p>

<pre>
$ <strong>pip install --user edn_format</strong>
</pre>

<p>Dostupné jsou tyto funkce:</p>

<table>
<tr><th>#</th><th>Funkce</th><th>Stručný popis funkce</th></tr>
<tr><td>1</td><td>loads</td><td>načtení objektu z&nbsp;formátu EDN</td></tr>
<tr><td>2</td><td>loads_all</td><td>načtení všech objektů z&nbsp;formátu EDN (výsledkem může být prázdný seznam)</td></tr>
<tr><td>3</td><td>dumps</td><td>opak předchozích funkcí &ndash; export dat do formátu EDN</td></tr>
</table>

<p>Nápovědu k&nbsp;jednotlivým funkcím opět &ndash; podobně jako v&nbsp;případě
jazyka Clojure &ndash; získáme přímo přes interaktivní smyčku REPL.</p>

<p>Import příslušného balíčku:</p>

<pre>
&gt;&gt;&gt; <strong>import edn_format</strong>
</pre>

<p>Zobrazení nápovědy k&nbsp;celému balíčku:</p>

<pre>
&gt;&gt;&gt; <strong>help(edn_format)</strong>
&nbsp;
Help on package edn_format:
&nbsp;
NAME
    edn_format - # -*- coding: utf-8 -*-
&nbsp;
PACKAGE CONTENTS
    edn_dump
    edn_lex
    edn_parse
    exceptions
    immutable_dict
    immutable_list
    parsetab
</pre>

<p>Nápověda k&nbsp;vybrané funkci, například k&nbsp;funkci
<strong>loads_all</strong>:</p>

<pre>
&gt;&gt;&gt; <strong>help(edn_format.loads_all)</strong>
&nbsp;
...
...
...
</pre>



<p><a name="k11"></a></p>
<h2 id="k11">11. Go</h2>

<p>Podporu formátu EDN nalezneme i v&nbsp;programovacím jazyce Go, pro nějž
vznikla knihovna nazvaná <strong>encoding/edn</strong>, což je
v&nbsp;ekosystému tohoto jazyka zcela konzistentní jméno, protože na
&bdquo;encoding/&ldquo; začínají i jména mnohých dalších knihoven zajištujících
kódování či dekódování dat popř.&nbsp;jejich <i>marshaling</i> a
<i>unmarshaling</i>. Připomeňme si především knihovnu
<strong>encoding/json</strong>.</p>

<p>Balíček pro práci s&nbsp;EDN není součástí standardní knihovny jazyka Go a
proto je nutné balíček explicitně doinstalovat. To se provede následujícím
příkazem:</p>

<pre>
$ <strong>go get olympos.io/encoding/edn</strong>
</pre>

<p>Po instalaci si lze prohlédnou dokumentaci s&nbsp;využitím <strong>go
doc</strong> popř.&nbsp;použít stránku s&nbsp;již vygenerovanou dokumentací: <a
href="https://pkg.go.dev/olympos.io/encoding/edn?utm_source=godoc">https://pkg.go.dev/olympos.io/encoding/edn?utm_source=godoc</a>.</p>

<p>Pro převod libovolného typu (přesněji řečeno hodnoty libovolného typu) do
formátu EDN se používá funkce nazvaná <strong>Marshal</strong>, kterou
nalezneme v&nbsp;balíčku <strong>encoding/edn</strong> nainstalovaném výše
zmíněným příkazem:</p>

<pre>
func <strong>Marshal</strong>(v interface{}) ([]byte, error)
</pre>

<p>Povšimněte si, že tato funkce skutečně akceptuje hodnotu libovolného typu,
protože prázdné rozhraní implementuje (zcela automaticky!) každý datový typ
(s&nbsp;tímto zajímavým konceptem &bdquo;univerzálního datového typu&ldquo; se
ještě několikrát setkáme, zejména v&nbsp;rozhraních mezi Go a dalšími systémy).
Návratovou hodnotou je sekvence bajtů (nikoli řetězec!) a popř.&nbsp;i
struktura reprezentující chybový stav, pokud k&nbsp;chybě skutečně došlo.
V&nbsp;opačném případě se ve druhé návratové hodnotě funkce
<strong>Marshal</strong> vrací <strong>nil</strong>, jak jsme ostatně zvyklí ze
všech podobně koncipovaných funkcí, které mohou za určitých okolností skončit
s&nbsp;chybou.</p>

<p>V&nbsp;typických zdrojových kódech se tedy setkáme s&nbsp;tímto idiomatickým
zápisem:</p>

<pre>
edn_bytes, err := <strong>json.Marshal(a)</strong>
&nbsp;
if err != nil {
        log.Fatal(err)
}
...
...
...
</pre>

<p><div class="rs-tip-major">Poznámka: to, že funkci <strong>Marshal</strong>
můžeme zavolat a předat jí libovolnou hodnotu ovšem v&nbsp;žádném případě
neznamená, že převod bude skutečně proveden. Některé typy hodnot totiž nemají
v&nbsp;EDN svoji obdobu (je to například funkce nebo ukazatel). Podrobnosti o
podporovaných a nepodporovaných typech budou vysvětleny v&nbsp;navazujících
kapitolách při popisu demonstračních příkladů.</div></p>

<p>Jméno funkce odpovídá prováděné operaci, takzvanému <i>marshalingu</i>.
Opačná operace, tj.&nbsp;převod dat z&nbsp;EDN do datových struktur Go, se
nazývá <i>unmarshalling</i>. Jedná se o funkci s&nbsp;touto hlavičkou:</p>

<pre>
func <strong>Unmarshal</strong>(data []byte, v interface{}) error
</pre>

<p>Vstupem je v&nbsp;tomto případě pole (řez) bajtů, výstup je vrácen přes
ukazatel předaný ve druhém parametru (což znamená, že se musíme sami postarat o
případnou alokaci paměti pro strukturu či pro mapu). Samozřejmě, že při
unmarshalingu může dojít k&nbsp;nějaké chybě, která je vrácena volající funkci.
Pokud k&nbsp;chybě nedošlo, je návratová hodnota rovna <strong>nil</strong>,
opět přesně podle zvyklostí programovacího jazyka Go.</p>



<p><a name="k12"></a></p>
<h2 id="k12">12. Praktická část</h2>

<p>Druhá část dnešního článku bude zaměřena spíše prakticky. Ukážeme si totiž
některé možnosti práce s&nbsp;formátem EDN v&nbsp;programovacích jazycích
Clojure, Python i Go. Uvidíme &ndash; což je ovšem očekávatelné &ndash; že se
jednotlivé jazyky od sebe velmi odlišují při operacích typu serializace a
deserializace datových struktur (též se setkáme s&nbsp;termíny
<i>marshaling</i> a <i>unmarshaling</i>, které sice striktně řečeno nemají
úplně shodný význam, ale mnohdy se mezi sebou zaměňují).</p>



<p><a name="k13"></a></p>
<h2 id="k13">13. Převod mezi formátem JSON a EDN v&nbsp;Pythonu a Clojure</h2>

<p>Nejprve se podívejme na způsob realizace převodů mezi formáty JSON a EDN,
což může být dosti častý případ využitelný v&nbsp;praxi. Ukážeme si, jak se
tyto převody provedou v&nbsp;jazyce Python a taktéž v&nbsp;programovacím jazyku
Clojure. Začneme příkladem vypracovaným v&nbsp;Pythonu, který provede převod
mezi souborem s&nbsp;daty uloženými ve formátu JSON a formátem EDN. Realizace
tohoto příkladu je poměrně přímočará &ndash; nejprve se s&nbsp;využitím funkce
<strong>load</strong> z&nbsp;balíčku <strong>json</strong> načte vstupní soubor
a posléze se funkcí <strong>dumps</strong> z&nbsp;balíčku
<strong>end_format</strong> data převedou do formátu EDN. Typicky se budou
převádět seznamy popř.&nbsp;mapy (asociativní pole):</p>

<pre>
<i>#!/usr/bin/env python3</i>
&nbsp;
<i># Converts structured data from JSON format into EDN format.</i>
&nbsp;
import sys
import json
import edn_format
&nbsp;
<i># Check if command line argument is specified (it is mandatory).</i>
if len(sys.argv) &lt; 2:
    print("Usage:")
    print("  json2edn.py input_file.csv")
    print("Example:")
    print("  json2edn.py report.csv")
    sys.exit(1)
&nbsp;
<i># First command line argument should contain name of input JSON file.</i>
input_json = sys.argv[1]
&nbsp;
<i># Try to open the JSON file specified.</i>
with open(input_json) as json_input:
    <i># open the JSON file and parse it</i>
    payload = json.load(json_input)
    <i># dump the parsed data structure into EDN format</i>
    print(edn_format.dumps(payload))
</pre>

<p>Pro porovnání se podívejme na realizaci stejného převodníku, nyní ovšem
vypracovaného v&nbsp;jazyku Clojure. Zde se použije funkce
<strong>read-str</strong> z&nbsp;balíčku <strong>clojure.data.json</strong> pro
vstup a de facto standardní funkce <strong>pprint</strong> z&nbsp;balíčku
<strong>clojure.pprint</strong> pro výstup dat, protože ten bude kompatibilní
s&nbsp;formátem EDN:</p>

<pre>
(ns json2edn.core)
&nbsp;
(require '[clojure.data.json :as json])
(require '[clojure.edn :as edn])
&nbsp;
&nbsp;
(defn <strong>json-&gt;edn</strong>
  <i>"Convert JSON format into EDN format."</i>
  [json-file-name edn-file-name]
  (let [payload (-&gt; json-file-name slurp (json/read-str :key-fn keyword))
        fout    (clojure.java.io/writer edn-file-name)]
    (clojure.pprint/pprint payload)
    (clojure.pprint/pprint payload fout)))
&nbsp;
&nbsp;
(defn <strong>-main</strong>
  [&amp; args]
  (json-&gt;edn "details.json" "details.edn"))
</pre>

<p>Následuje příklad použití:</p>

<p>Vstup (reálná data):</p>

<pre>
{
    "Messages": [
        {
            "MessageId": "aaaaaaaa-bbbb-cccc-dddd-eeeeeeeeeeee",
            "ReceiptHandle": "123",
            "MD5OfBody": "cafe0000cafe0000cafe0000cafe0000",
            "Body": "{\"Records\": [{\"s3\": {\"object\": {\"key\": \"7307752/aaaaaaaa-bbbb-cccc-dddd-eeeeeeeeeeee/20200609125740-0123456789abcdef0123456789abcdef\",\"size\": 11805,\"eTag\": \"beef0000beef0000beef0000beef0000\",\"sequencer\": \"005EDF87444DDF7525\"}}}]}",
            "Attributes": {
                "SenderId": "321123",
                "ApproximateFirstReceiveTimestamp": "1591707477622",
                "ApproximateReceiveCount": "1",
                "SentTimestamp": "1591707468964"
            }
        }
    ],
    "ResponseMetadata": {
        "RequestId": "aaaaaaaa-bbbb-cccc-dddd-eeeeeeeeeeee",
        "HTTPStatusCode": 200,
        "HTTPHeaders": {
            "x-amzn-requestid": "aaaaaaaa-bbbb-cccc-dddd-eeeeeeeeeeee",
            "date": "Tue, 09 Jun 2020 12:57:57 GMT",
            "content-type": "text/xml",
            "content-length": "22437"
        },
        "RetryAttempts": 0
    }
}
</pre>

<p>Převod:</p>

<pre>
$ <strong>lein run</strong>
</pre>

<p>Výstup:</p>

<pre>
{:Messages
 [{:MessageId "aaaaaaaa-bbbb-cccc-dddd-eeeeeeeeeeee",
   :ReceiptHandle "123",
   :MD5OfBody "cafe0000cafe0000cafe0000cafe0000",
   :Body
   "{\"Records\": [{\"s3\": {\"object\": {\"key\": \"7307752/aaaaaaaa-bbbb-cccc-dddd-eeeeeeeeeeee/20200609125740-0123456789abcdef0123456789abcdef\",\"size\": 11805,\"eTag\": \"beef0000beef0000beef0000beef0000\",\"sequencer\": \"005EDF87444DDF7525\"}}}]}",
   :Attributes
   {:SenderId "321123",
    :ApproximateFirstReceiveTimestamp "1591707477622",
    :ApproximateReceiveCount "1",
    :SentTimestamp "1591707468964"}}],
 :ResponseMetadata
 {:RequestId "aaaaaaaa-bbbb-cccc-dddd-eeeeeeeeeeee",
  :HTTPStatusCode 200,
  :HTTPHeaders
  {:x-amzn-requestid "aaaaaaaa-bbbb-cccc-dddd-eeeeeeeeeeee",
   :date "Tue, 09 Jun 2020 12:57:57 GMT",
   :content-type "text/xml",
   :content-length "22437"},
  :RetryAttempts 0}}
</pre>



<p><a name="k14"></a></p>
<h2 id="k14">14. Převod mezi formátem EDN a JSON v&nbsp;Pythonu a Clojure</h2>

<p>Opačný převod mezi formátem EDN a JSON v&nbsp;Pythonu není tak přímočarý,
jak by se mohlo na první pohled zdát. Je tomu tak z&nbsp;toho důvodu, že
seznamy a mapy (asociativní pole) v&nbsp;EDN jsou realizovány formou
neměnitelné (<i>immutable</i>) datové struktury typu
<strong>ImmutableList</strong> a <strong>ImmutableDict</strong>, kterou nelze
přímo do JSONu serializovat. Je tedy nutné tyto struktury převést na běžný
(měnitelný) seznam popř.&nbsp;slovník, což v&nbsp;dalším kódu zajišťuje
rekurzivně volaná funkce <strong>edn_to_map</strong>, která byla převzata
z&nbsp;<a
href="https://github.com/swaroopch/edn_format/issues/76#issuecomment-749618312">https://github.com/swaroopch/edn_format/issues/76#issuecomment-749618312</a>:</p>

<pre>
<i># Taken from https://github.com/swaroopch/edn_format/issues/76#issuecomment-749618312</i>
def <strong>edn_to_map</strong>(x):
    if isinstance(x, edn_format.ImmutableDict):
        return {edn_to_map(k): edn_to_map(v) for k, v in x.items()}
    elif isinstance(x, edn_format.ImmutableList):
        return [edn_to_map(v) for v in x]
    elif isinstance(x, edn_format.Keyword):
        return x.name
    else:
        return x
</pre>

<p>Úplný kód převodníku může vypadat takto:</p>

<pre>
<i>#!/usr/bin/env python3</i>
&nbsp;
<i># Converts structured data from EDN format into JSON format.</i>
&nbsp;
import sys
import json
import edn_format
&nbsp;
<i># Check if command line argument is specified (it is mandatory).</i>
if len(sys.argv) &lt; 2:
    print("Usage:")
    print("  edn2json.py input_file.edn")
    print("Example:")
    print("  edn2json.py report.edn")
    sys.exit(1)

<i># First command line argument should contain name of input EDN file.</i>
filename = sys.argv[1]
&nbsp;
&nbsp;
<i># Taken from https://github.com/swaroopch/edn_format/issues/76#issuecomment-749618312</i>
def edn_to_map(x):
    if isinstance(x, edn_format.ImmutableDict):
        return {edn_to_map(k): edn_to_map(v) for k, v in x.items()}
    elif isinstance(x, edn_format.ImmutableList):
        return [edn_to_map(v) for v in x]
    elif isinstance(x, edn_format.Keyword):
        return x.name
    else:
        return x
&nbsp;
&nbsp;
<i># Try to open the EDN file specified.</i>
with open(filename, "r") as edn_input:
    <i># open the EDN file and parse it</i>
    payload = edn_format.loads(edn_input.read())
    print(json.dumps(edn_to_map(payload), indent=2))
</pre>

<p>Přepis do jazyka Clojure je ovšem přímočarý a struktura tohoto příkladu
odpovídá příkladu pro převod opačný (viz předchozí kapitolu):</p>

<pre>
(ns edn2json.core)
&nbsp;
(require '[clojure.data.json :as json])
(require '[clojure.edn :as edn])
&nbsp;
&nbsp;
(defn <strong>edn-&gt;json</strong>
  <i>"Convert EDN format into JSON format."</i>
  [edn-file-name json-file-name]
  (let [payload (-&gt; edn-file-name slurp edn/read-string)
        output (with-out-str (json/pprint payload))]
    (spit json-file-name output)))
&nbsp;
&nbsp;
(defn <strong>-main</strong>
  [&amp; args]
  (edn-&gt;json "details.edn" "details.json"))
</pre>

<p>Opět následuje příklad použití:</p>

<p>Vstup (detailní informace o projektu reprezentované v&nbsp;EDN):</p>

<pre>
{:aliases {"downgrade" "upgrade"},
 :checkout-deps-shares
 [:source-paths
  :test-paths
  :resource-paths
  :compile-path
  "#'leiningen.core.classpath/checkout-deps-paths"],
 :clean-targets [:target-path],
 :compile-path
 "/home/ptisnovs/src/presentations/edn/edn2json/target/default/classes",
 :dependencies
 ([org.clojure/clojure "1.10.1"]
  [org.clojure/data.json "2.2.0"]
  [nrepl/nrepl "0.7.0" :exclusions ([org.clojure/clojure])]
  [clojure-complete/clojure-complete
   "0.2.5"
   :exclusions
   ([org.clojure/clojure])]
  [venantius/ultra "0.6.0"]),
 :deploy-repositories
 [["clojars"
   {:url "https://repo.clojars.org/",
    :password :gpg,
    :username :gpg}]],
 :description "FIXME: write description",
 :eval-in :subprocess,
 :global-vars {},
 :group "edn2json",
 :jar-exclusions ["#\"^\\.\"" "#\"\\Q/.\\E\""],
 :jvm-opts
 ["-XX:-OmitStackTraceInFastThrow"
  "-XX:+TieredCompilation"
  "-XX:TieredStopAtLevel=1"],
 :license
 {:name "EPL-2.0 OR GPL-2.0-or-later WITH Classpath-exception-2.0",
  :url "https://www.eclipse.org/legal/epl-2.0/"},
 :main edn2json.core,
 :monkeypatch-clojure-test false,
 :name "edn2json",
 :native-path
 "/home/ptisnovs/src/presentations/edn/edn2json/target/default/native",
 :offline? false,
 :pedantic? ranges,
 :plugin-repositories
 [["central"
   {:url "https://repo1.maven.org/maven2/", :snapshots false}]
  ["clojars" {:url "https://repo.clojars.org/"}]],
 :plugins
 ([lein-project-edn/lein-project-edn "0.3.0"]
  [venantius/ultra "0.6.0"]
  [lein-kibit/lein-kibit "0.1.8"]),
 :prep-tasks ["javac" "compile"],
 :profiles
 {:uberjar
  {:aot [:all], :jvm-opts ["-Dclojure.compiler.direct-linking=true"]},
  :whidbey/repl
  {:dependencies [[mvxcvi/whidbey "RELEASE"]],
   :repl-options
   {:init
    (do
     nil
     (clojure.core/require 'whidbey.repl)
     (whidbey.repl/init! nil)),
    :custom-init (do nil (whidbey.repl/update-print-fn!)),
    :nrepl-context
    {:interactive-eval {:printer whidbey.repl/render-str}}}}},
 :project-edn {:output-file "details.clj"},
 :release-tasks
 [["vcs" "assert-committed"]
  ["change" "version" "leiningen.release/bump-version" "release"]
  ["vcs" "commit"]
  ["vcs" "tag"]
  ["deploy"]
  ["change" "version" "leiningen.release/bump-version"]
  ["vcs" "commit"]
  ["vcs" "push"]],
 :repl-options
 {:init
  (do
   (do
    (clojure.core/require 'ultra.hardcore)
    (clojure.core/require 'whidbey.repl)
    (whidbey.repl/init! nil)
    (ultra.hardcore/configure!
     {:repl
      {:print-meta false,
       :map-delimiter "",
       :print-fallback :print,
       :sort-keys true}})))},
 :repositories
 [["central"
   {:url "https://repo1.maven.org/maven2/", :snapshots false}]
  ["clojars" {:url "https://repo.clojars.org/"}]],
 :resource-paths
 ("/home/ptisnovs/src/presentations/edn/edn2json/dev-resources"
  "/home/ptisnovs/src/presentations/edn/edn2json/resources"),
 :root
 "/home/ptisnovs/src/presentations/edn/edn2json",
 :source-paths
 ("/home/ptisnovs/src/presentations/edn/edn2json/src"),
 :target-path
 "/home/ptisnovs/src/presentations/edn/edn2json/target/default",
 :test-paths
 ("/home/ptisnovs/src/presentations/edn/edn2json/test"),
 :test-selectors {:default (constantly true)},
 :uberjar-exclusions ["#\"(?i)^META-INF/[^/]*\\.(SF|RSA|DSA)$\""],
 :url "http://example.com/FIXME",
 :version "0.1.0-SNAPSHOT"
}
</pre>

<p>Převod:</p>

<pre>
$ <strong>lein run</strong>
</pre>

<p>Výstup:</p>

<pre>
{"description":"FIXME: write description",
 "compile-path":
 "\/home\/ptisnovs\/src\/presentations\/edn\/edn2json\/target\/default\/classes",
 "deploy-repositories":
 [["clojars",
   {"url":"https:\/\/repo.clojars.org\/",
    "password":"gpg",
    "username":"gpg"}]],
 "group":"edn2json",
 "license":
 {"name":"EPL-2.0 OR GPL-2.0-or-later WITH Classpath-exception-2.0",
  "url":"https:\/\/www.eclipse.org\/legal\/epl-2.0\/"},
 "project-edn":{"output-file":"details.clj"},
 "resource-paths":
 ["\/home\/ptisnovs\/src\/presentations\/edn\/edn2json\/dev-resources",
  "\/home\/ptisnovs\/src\/presentations\/edn\/edn2json\/resources"],
 "name":"edn2json",
 "checkout-deps-shares":
 ["source-paths", "test-paths", "resource-paths", "compile-path",
  "#'leiningen.core.classpath\/checkout-deps-paths"],
 "source-paths":
 ["\/home\/ptisnovs\/src\/presentations\/edn\/edn2json\/src"],
 "eval-in":"subprocess",
 "repositories":
 [["central",
   {"url":"https:\/\/repo1.maven.org\/maven2\/", "snapshots":false}],
  ["clojars", {"url":"https:\/\/repo.clojars.org\/"}]],
 "test-paths":
 ["\/home\/ptisnovs\/src\/presentations\/edn\/edn2json\/test"],
 "target-path":
 "\/home\/ptisnovs\/src\/presentations\/edn\/edn2json\/target\/default",
 "prep-tasks":["javac", "compile"],
 "native-path":
 "\/home\/ptisnovs\/src\/presentations\/edn\/edn2json\/target\/default\/native",
 "offline?":false,
 "root":"\/home\/ptisnovs\/src\/presentations\/edn\/edn2json",
 "pedantic?":"ranges",
 "clean-targets":["target-path"],
 "plugins":
 [["lein-project-edn", "0.3.0"], ["ultra", "0.6.0"],
  ["lein-kibit", "0.1.8"]],
 "url":"http:\/\/example.com\/FIXME",
 "profiles":
 {"uberjar":
  {"aot":["all"],
   "jvm-opts":["-Dclojure.compiler.direct-linking=true"]},
  "repl":
  {"dependencies":[["whidbey", "RELEASE"]],
   "repl-options":
   {"init":
    ["do", null, ["require", "'whidbey.repl"], ["init!", null]],
    "custom-init":["do", null, ["update-print-fn!"]],
    "nrepl-context":{"interactive-eval":{"printer":"render-str"}}}}},
 "plugin-repositories":
 [["central",
   {"url":"https:\/\/repo1.maven.org\/maven2\/", "snapshots":false}],
  ["clojars", {"url":"https:\/\/repo.clojars.org\/"}]],
 "aliases":{"downgrade":"upgrade"},
 "version":"0.1.0-SNAPSHOT",
 "jar-exclusions":["#\"^\\.\"", "#\"\\Q\/.\\E\""],
 "main":"edn2json.core",
 "global-vars":{},
 "uberjar-exclusions":["#\"(?i)^META-INF\/[^\/]*\\.(SF|RSA|DSA)$\""],
 "jvm-opts":
 ["-XX:-OmitStackTraceInFastThrow", "-XX:+TieredCompilation",
  "-XX:TieredStopAtLevel=1"],
 "dependencies":
 [["clojure", "1.10.1"], ["data.json", "2.2.0"],
  ["nrepl", "0.7.0", "exclusions", [["clojure"]]],
  ["clojure-complete", "0.2.5", "exclusions", [["clojure"]]],
  ["ultra", "0.6.0"]],
 "release-tasks":
 [["vcs", "assert-committed"],
  ["change", "version", "leiningen.release\/bump-version", "release"],
  ["vcs", "commit"], ["vcs", "tag"], ["deploy"],
  ["change", "version", "leiningen.release\/bump-version"],
  ["vcs", "commit"], ["vcs", "push"]],
 "repl-options":
 {"init":
  ["do",
   ["do", ["require", "'ultra.hardcore"], ["require", "'whidbey.repl"],
    ["init!", null],
    ["configure!",
     {"repl":
      {"print-meta":false,
       "map-delimiter":"",
       "print-fallback":"print",
       "sort-keys":true}}]]]},
 "test-selectors":{"default":["constantly", true]},
 "monkeypatch-clojure-test":false}
</pre>



<p><a name="k15"></a></p>
<h2 id="k15">15. Převod mezi souborem .properties a formátem EDN v&nbsp;Clojure</h2>

<p>Relativně často se v&nbsp;aplikacích vytvářených v&nbsp;jazyku Clojure
setkáme se soubory s&nbsp;koncovkou <strong>.properties</strong>, které jsou
ostatně v&nbsp;ekosystému programovacího jazyka Java běžné. Převod takových
souborů do EDN je snadný, protože můžeme využít možnosti nabízené třídou
<strong>java.util.Properties</strong> pro načtení hodnot s&nbsp;jejich
následnou konverzí funkcí <strong>properties-&gt;map</strong>:</p>

<pre>
(ns properties2edn.core)
&nbsp;
&nbsp;
(defn <strong>properties-&gt;map</strong>
  <i>"Convert properties entries into a map. Keys are converted into proper keywords."</i>
  [properties]
  (into {}
        (for [[k v] properties]
              [(keyword k) v])))
&nbsp;
&nbsp;
(defn <strong>load-properties-file</strong>
  <i>"Load configuration from the provided properties file."</i>
  [file-name]
  (with-open [reader (clojure.java.io/reader file-name)]
    (let [properties (java.util.Properties.)]
      (.load properties reader)
      (properties-&gt;map properties))))
&nbsp;
&nbsp;
(defn <strong>properties-&gt;edn</strong>
  <i>"Convert properties file into EDN format."</i>
  [properties-file-name edn-file-name]
  (let [payload (load-properties-file properties-file-name)
        fout    (clojure.java.io/writer edn-file-name)]
    (clojure.pprint/pprint payload fout)))
&nbsp;
&nbsp;
(defn <strong>-main</strong>
  [&amp; args]
  (properties-&gt;edn "test.properties" "test.edn"))
</pre>

<p>Příklad převodu:</p>

<p>Vstup (soubor s&nbsp;reálnými daty):</p>

<pre>
# This file is shared currently between this Gradle build and the
# Ant builds for fd303 and JavaScript. Keep the dotted notation for
# the properties to minimize the changes in the dependencies.
thrift.version=0.14.0
thrift.groupid=org.apache.thrift
release=false
&nbsp;
# Local Install paths
install.path=/usr/local/lib
install.javadoc.path=/usr/local/lib
&nbsp;
# Test execution properties
testPort=9090
&nbsp;
# Test with Clover Code coverage (disabled by default)
cloverEnabled=false
&nbsp;
# Maven dependency download locations
mvn.repo=https://repo1.maven.org/maven2
apache.repo=https://repository.apache.org/content/repositories/releases
&nbsp;
# Apache Maven publish
license=https://www.apache.org/licenses/LICENSE-2.0.txt
maven-repository-url=https://repository.apache.org/service/local/staging/deploy/maven2
maven-repository-id=apache.releases.https
&nbsp;
# Dependency versions
httpclient.version=4.5.10
httpcore.version=4.4.12
slf4j.version=1.7.28
#servlet.version=2.5
#It contains servlet3
tomcat.embed.version=8.5.46
junit.version=4.12
mockito.version=1.10.19
javax.annotation.version=1.3.2
</pre>

<p>Převod:</p>

<pre>
$ <strong>lein run</strong>
</pre>

<p>Výstup:</p>

<pre>
{:tomcat.embed.version "8.5.46",
 :thrift.version "0.14.0",
 :httpclient.version "4.5.10",
 :mockito.version "1.10.19",
 :javax.annotation.version "1.3.2",
 :thrift.groupid "org.apache.thrift",
 :license "https://www.apache.org/licenses/LICENSE-2.0.txt",
 :install.javadoc.path "/usr/local/lib",
 :slf4j.version "1.7.28",
 :httpcore.version "4.4.12",
 :release "false",
 :mvn.repo "https://repo1.maven.org/maven2",
 :maven-repository-url "https://repository.apache.org/service/local/staging/deploy/maven2",
 :maven-repository-id "apache.releases.https",
 :testPort "9090",
 :apache.repo "https://repository.apache.org/content/repositories/releases",
 :junit.version "4.12",
 :cloverEnabled "false",
 :install.path "/usr/local/lib"}
</pre>



<p><a name="k16"></a></p>
<h2 id="k16">16. Převod mezi XML a EDN (plná varianta zachovávající vlastnosti XML)</h2>

<p>V&nbsp;základní knihovně programovacího jazyka Clojure nalezneme i balíček
<strong>clojure.xml</strong> s&nbsp;funkcemi určenými pro načítání souborů XML.
Výsledkem načtení (parsingu) je mapa, jejíž prvky mají jednotný formát. Samotný
převodník z&nbsp;formátu XML přes mapu do formátu EDN je přímočarý (další
možnosti jsou ukázány v&nbsp;navazující kapitole):</p>

<pre>
(ns xml2edn.core)
&nbsp;
(use '[clojure.xml])
&nbsp;
&nbsp;
(defn <strong>xml-&gt;edn</strong>
  <i>"Convert XML file into EDN format."</i>
  [xml-file-name edn-file-name]
  (let [payload (clojure.xml/parse "nested.xml")
        fout    (clojure.java.io/writer edn-file-name)]
    (clojure.pprint/pprint payload fout)))
&nbsp;
&nbsp;
(defn <strong>-main</strong>
  [&amp; args]
  (xml-&gt;edn "nested.xml" "nested.edn"))
</pre>

<p>Podívejme se nyní, jakým způsobem je zkonvertován následující (na první
pohled velmi jednoduchý) soubor:</p>

<pre>
&lt;?xml version="1.0"?&gt;
&lt;first&gt;
  &lt;second value="A"&gt;
    &lt;third&gt;
      &lt;fourth&gt;Hello A&lt;/fourth&gt;
    &lt;/third&gt;
  &lt;/second&gt;
  &lt;second value="B"&gt;
    &lt;third&gt;
      &lt;fourth&gt;Hello B&lt;/fourth&gt;
    &lt;/third&gt;
  &lt;/second&gt;
&lt;/first&gt;
</pre>

<p>Výsledkem převodu bude relativně složitá rekurzivní mapa, která ovšem přesně
odpovídá vstupnímu XML, ovšem s&nbsp;tím rozdílem, že jsou explicitně vypsány i
hodnoty atributů:</p>

<pre>
{:tag :first,
 :attrs nil,
 :content
 [{:tag :second,
   :attrs {:value "A"},
   :content
   [{:tag :third,
     :attrs nil,
     :content [{:tag :fourth, :attrs nil, :content ["Hello A"]}]}]}
  {:tag :second,
   :attrs {:value "B"},
   :content
   [{:tag :third,
     :attrs nil,
     :content [{:tag :fourth, :attrs nil, :content ["Hello B"]}]}]}]}
</pre>



<p><a name="k17"></a></p>
<h2 id="k17">17. Převod XML do různých forem formátu EDN s&nbsp;využitím knihovny Tupelo.forest</h2>

<p>Do XML je možné provést převod hodnot (tedy vektorů, map atd.) několika
různými způsoby. Většina z&nbsp;nich není podporována v&nbsp;základních
knihovnách jazyka Clojure, takže si budeme muset vypomoci externí knihovnou,
konkrétně knihovnou nazvanou <strong>Tupelo.forest</strong>. Do projektového
souboru se tato závislost přidá snadno:</p>

<pre>
(defproject forest-demo "0.1.0-SNAPSHOT"
  :description "FIXME: write description"
  :url "http://example.com/FIXME"
  :license {:name "EPL-2.0 OR GPL-2.0-or-later WITH Classpath-exception-2.0"
            :url "https://www.eclipse.org/legal/epl-2.0/"}
  :dependencies [[org.clojure/clojure "1.10.1"]
                 <strong>[tupelo "21.04.13"]</strong>]
  :main ^:skip-aot forest-demo.core
  :target-path "target/%s"
  :profiles {:uberjar {:aot :all
                       :jvm-opts ["-Dclojure.compiler.direct-linking=true"]}})
</pre>

<p>V&nbsp;dalším demonstračním příkladu použijeme několik způsobů převodu a
serializace hodnot z&nbsp;XML do EDN. Jednotlivé varianty EDN jsou nazvány
&bdquo;enlive&ldquo; &bdquo;hiccup&ldquo;, &bdquo;bush&ldquo; a
&bdquo;tree&ldquo; (jsou pro to různé důvody, například první název vychází ze
jména šablonovacího systému <i>Enlive</i>):</p>

<pre>
(ns forest-demo.core)
&nbsp;
(require '[clojure.xml :as xml])
(require '[tupelo.forest :as tf])
&nbsp;
&nbsp;
(defn <strong>pprint-to-file</strong>
  [filename payload]
  (clojure.pprint/pprint payload (clojure.java.io/writer filename)))
&nbsp;
&nbsp;
(defn -main
  [&amp; args]
  (let [payload        (xml/parse "nested.xml")
        hiccup-format  (tf/enlive-&gt;hiccup payload)
        bush-format    (tf/enlive-&gt;bush payload)
        tree-format    (tf/enlive-&gt;tree payload)]
    (pprint-to-file "nested-enlive.edn" payload)
    (pprint-to-file "nested-hiccup.edn" hiccup-format)
    (pprint-to-file "nested-bush.edn" bush-format)
    (pprint-to-file "nested-tree.edn" tree-format)))
</pre>

<p>Vstupem do příkladu je následující XML soubor:</p>

<pre>
&lt;?xml version="1.0"?&gt;
&lt;first&gt;
  &lt;second value="A"&gt;
    &lt;third&gt;
      &lt;fourth&gt;Hello A&lt;/fourth&gt;
    &lt;/third&gt;
  &lt;/second&gt;
  &lt;second value="B"&gt;
    &lt;third&gt;
      &lt;fourth&gt;Hello B&lt;/fourth&gt;
    &lt;/third&gt;
  &lt;/second&gt;
&lt;/first&gt;
</pre>

<p>Export do formátu &bdquo;enlive&ldquo;:</p>

<pre>
{:tag :first,
 :attrs nil,
 :content
 [{:tag :second,
   :attrs {:value "A"},
   :content
   [{:tag :third,
     :attrs nil,
     :content [{:tag :fourth, :attrs nil, :content ["Hello A"]}]}]}
  {:tag :second,
   :attrs {:value "B"},
   :content
   [{:tag :third,
     :attrs nil,
     :content [{:tag :fourth, :attrs nil, :content ["Hello B"]}]}]}]}
</pre>

<p>Export do formátu &bdquo;hiccup&ldquo; je nejstručnější:</p>

<pre>
[:first
 [:second {:value "A"} [:third [:fourth "Hello A"]]]
 [:second {:value "B"} [:third [:fourth "Hello B"]]]]
</pre>

<p>Formát nazvaný &bdquo;bush&ldquo;:</p>

<pre>
[{:tag :first}
 [{:value "A", :tag :second}
  [{:tag :third} [{:tag :fourth, :value "Hello A"}]]]
 [{:value "B", :tag :second}
  [{:tag :third} [{:tag :fourth, :value "Hello B"}]]]]
</pre>

<p>A konečně formát nazvaný &bdquo;tree&ldquo;, v&nbsp;němž jsou synovské uzly
reprezentovány formou vloženého vektoru:</p>

<pre>
{:tag :first,
 :tupelo.forest/kids
 [{:value "A",
   :tag :second,
   :tupelo.forest/kids
   [{:tag :third,
     :tupelo.forest/kids
     [{:tag :fourth, :value "Hello A", :tupelo.forest/kids []}]}]}
  {:value "B",
   :tag :second,
   :tupelo.forest/kids
   [{:tag :third,
     :tupelo.forest/kids
     [{:tag :fourth, :value "Hello B", :tupelo.forest/kids []}]}]}]}
</pre>

<p><div class="rs-tip-major">Poznámka: je zřejmé, že se každý formát hodí
k&nbsp;jiným účelům.</div></p>

<p>Ve skutečnosti jsou možnosti knihovny <strong>Tupelo.forest</strong> ještě
mnohem větší a pravděpodobně se s&nbsp;nimi setkáme v&nbsp;některém dalším
článku o <a href="https://www.root.cz/n/clojure/">programovacím jazyku
Clojure</a>.</p>



<p><a name="k18"></a></p>
<h2 id="k18">18. Práce s&nbsp;formátem EDN v&nbsp;jazyce Go, vlastní štítky rozšiřující možnosti EDN</h2>

<p>V&nbsp;navazujícím článku téma formátu EDN dokončíme. Ukážeme si především
použití formátu EDN v&nbsp;programovacím jazyce Go (ostatně některé
demonstrační příklady jsou již uloženy do repositáře) a taktéž se budeme
zabývat problematikou tvorby vlastních štítků. Jedná se o užitečný koncept,
protože právě štítky umožňují rozšiřování EDN o další datové typy, což je
vlastnost, kterou v&nbsp;dalších podobně koncipovaných formátech většinou
nenalezneme.</p>



<p><a name="k19"></a></p>
<h2 id="k19">19. Repositář s&nbsp;demonstračními příklady</h2>

<p>Zdrojové kódy všech dnes popsaných demonstračních příkladů vyvinutých
v&nbsp;programovacích jazycích Clojure, Python i Go, byly uloženy do Git
repositáře, který je dostupný na adrese <a
href="https://github.com/tisnik/presentations">https://github.com/tisnik/presentations</a>:</p>

<table>
<tr><th> #</th><th>Zdrojový kód</th><th>Stručný popis souboru</th><th>Cesta</th></tr>
<tr><td> 1</td><td>json2edn.py</td><td>konverze mezi formátem JSON a EDN naprogramovaná v&nbsp;Pythonu</td><td><a href="https://github.com/tisnik/presentations/blob/master/edn/json2edn.py">https://github.com/tisnik/presentations/blob/master/edn/json2edn.py</a></td></tr>
<tr><td> 2</td><td>edn2json.py</td><td>konverze mezi formátem EDN a JSON naprogramovaná v&nbsp;Pythonu</td><td><a href="https://github.com/tisnik/presentations/blob/master/edn/edn2json.py">https://github.com/tisnik/presentations/blob/master/edn/edn2json.py</a></td></tr>
<tr><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td></tr>
<tr><td> 3</td><td>json2edn (adresář)</td><td>konverze mezi formátem JSON a EDN naprogramovaná v&nbsp;Clojure</td><td><a href="https://github.com/tisnik/presentations/blob/master/edn/json2edn">https://github.com/tisnik/presentations/blob/master/edn/json2edn</a></td></tr>
<tr><td> 4</td><td>edn2json (adresář)</td><td>konverze mezi formátem EDN a JSON naprogramovaná v&nbsp;Clojure</td><td><a href="https://github.com/tisnik/presentations/blob/master/edn/edn2json">https://github.com/tisnik/presentations/blob/master/edn/edn2json</a></td></tr>
<tr><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td></tr>
<tr><td> 3</td><td>properties2edn (adresář)</td><td>konverze mezi .properties souborem a formátem EDN (Clojure)</td><td><a href="https://github.com/tisnik/presentations/blob/master/edn/properties2edn">https://github.com/tisnik/presentations/blob/master/edn/properties2edn</a></td></tr>
<tr><td> 4</td><td>xml2edn (adresář)</td><td>konverze mezi XML a formátem EDN (Clojure, plná konverze)</td><td><a href="https://github.com/tisnik/presentations/blob/master/edn/xml2edn">https://github.com/tisnik/presentations/blob/master/edn/xml2edn</a></td></tr>
<tr><td> 5</td><td>forest-demo (adresář)</td><td>různé možnosti konverze mezi XML a formátem EDN</td><td><a href="https://github.com/tisnik/presentations/blob/master/edn/forest-demo">https://github.com/tisnik/presentations/blob/master/edn/forest-demo</a></td></tr>
<tr><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td></tr>
<tr><td> 6</td><td>go-edn-1 (adresář)</td><td>serializace (marshalling) datové struktury do formátu EDN</td><td><a href="https://github.com/tisnik/presentations/blob/master/edn/go-edn-1">https://github.com/tisnik/presentations/blob/master/edn/go-edn-1</a></td></tr>
<tr><td> 7</td><td>go-edn-2 (adresář)</td><td>specifikace názvů klíčů v&nbsp;EDN formátu</td><td><a href="https://github.com/tisnik/presentations/blob/master/edn/go-edn-2">https://github.com/tisnik/presentations/blob/master/edn/go-edn-2</a></td></tr>
<tr><td> 8</td><td>go-edn-3 (adresář)</td><td>uložení pole datových struktur do formátu EDN</td><td><a href="https://github.com/tisnik/presentations/blob/master/edn/go-edn-3">https://github.com/tisnik/presentations/blob/master/edn/go-edn-3</a></td></tr>
<tr><td> 9</td><td>go-edn-4 (adresář)</td><td>uložení mapy datových struktur do formátu EDN</td><td><a href="https://github.com/tisnik/presentations/blob/master/edn/go-edn-4">https://github.com/tisnik/presentations/blob/master/edn/go-edn-4</a></td></tr>
<tr><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td></tr>
<tr><td>10</td><td>go-edn-5 (adresář)</td><td>deserializace (unmarshalling) datové struktury z&nbsp;formátu EDN</td><td><a href="https://github.com/tisnik/presentations/blob/master/edn/go-edn-5">https://github.com/tisnik/presentations/blob/master/edn/go-edn-5</a></td></tr>
</table>



<p><a name="k20"></a></p>
<h2 id="k20">20. Odkazy na Internetu</h2>

<ol>

<li>edn &ndash; extensible data notation<br />
<a href="https://github.com/edn-format/edn">https://github.com/edn-format/edn</a>
</li>

<li>Programming with Data and EDN<br />
<a href="https://docs.datomic.com/cloud/whatis/edn.html">https://docs.datomic.com/cloud/whatis/edn.html</a>
</li>

<li>Video about EDN<br />
<a href="https://docs.datomic.com/cloud/livetutorial/edntutorial.html">https://docs.datomic.com/cloud/livetutorial/edntutorial.html</a>
</li>

<li>(Same) video about EDN on Youtube<br />
<a href="https://www.youtube.com/watch?v=5eKgRcvEJxU">https://www.youtube.com/watch?v=5eKgRcvEJxU</a>
</li>

<li>clojure.edn<br />
<a href="https://clojuredocs.org/clojure.edn">https://clojuredocs.org/clojure.edn</a>
</li>

<li>API for clojure.edn - Clojure v1.10.2 (stable)<br />
<a href="https://clojure.github.io/clojure/clojure.edn-api.html">https://clojure.github.io/clojure/clojure.edn-api.html</a>
</li>

<li>Clojure EDN Walkthrough<br />
<a href="https://www.compoundtheory.com/clojure-edn-walkthrough/">https://www.compoundtheory.com/clojure-edn-walkthrough/</a>
</li>

<li>Články týkající se Pythonu na Rootu<br />
<a href="https://www.root.cz/n/python/">https://www.root.cz/n/python/</a>
</li>

<li>Články týkající se programovacího jazyka Clojure na Rootu<br />
<a href="https://www.root.cz/n/clojure/">https://www.root.cz/n/clojure/</a>
</li>

<li>Seriál Programovací jazyk Go<br />
<a href="https://www.root.cz/serialy/programovaci-jazyk-go/">https://www.root.cz/serialy/programovaci-jazyk-go/</a>
</li>

<li>Crux<br />
<a href="https://opencrux.com/main/index.html">https://opencrux.com/main/index.html</a>
</li>

<li>Crux Installation<br />
<a href="https://opencrux.com/reference/21.04-1.16.0/installation.html">https://opencrux.com/reference/21.04-1.16.0/installation.html</a>
</li>

<li>read<br />
<a href="https://clojuredocs.org/clojure.edn/read">https://clojuredocs.org/clojure.edn/read</a>
</li>

<li>read-string<br />
<a href="https://clojuredocs.org/clojure.edn/read-string">https://clojuredocs.org/clojure.edn/read-string</a>
</li>

<li>Tupelo 21.04.12 (dokumentace)<br />
<a href="https://cloojure.github.io/doc/tupelo/">https://cloojure.github.io/doc/tupelo/</a>
</li>

<li>tupelo - Clojure With A Spoonful of Honey<br />
<a href="https://clojars.org/tupelo">https://clojars.org/tupelo</a>
</li>

<li>Clojure Cookbook: Templating HTML with Enlive<br />
<a href="https://github.com/clojure-cookbook/clojure-cookbook/blob/master/07_webapps/7-11_enlive.asciidoc">https://github.com/clojure-cookbook/clojure-cookbook/blob/master/07_webapps/7-11_enlive.asciidoc</a>
</li>

<li>An Introduction to Enlive<br />
<a href="https://github.com/swannodette/enlive-tutorial/">https://github.com/swannodette/enlive-tutorial/</a>
</li>

<li>Enlive na GitHubu<br />
<a href="https://github.com/cgrand/enlive">https://github.com/cgrand/enlive</a>
</li>

<li>data.json<br />
<a href="https://github.com/clojure/data.json">https://github.com/clojure/data.json</a>
</li>

<li>data.json API reference<br />
<a href="https://clojure.github.io/data.json/">https://clojure.github.io/data.json/</a>
</li>

<li>Clojure: Writing JSON to a File/Reading JSON From a File<br />
<a href="https://dzone.com/articles/clojure-writing-json">https://dzone.com/articles/clojure-writing-json</a>
</li>

<li>How to pretty print JSON to a file in Clojure?<br />
<a href="https://stackoverflow.com/questions/23307552/how-to-pretty-print-json-to-a-file-in-clojure">https://stackoverflow.com/questions/23307552/how-to-pretty-print-json-to-a-file-in-clojure</a>
</li>

<li>go-edn / edn<br />
<a href="https://github.com/go-edn/edn">https://github.com/go-edn/edn</a>
</li>

<li>Queries (Crux)<br />
<a href="https://opencrux.com/reference/21.04-1.16.0/queries.html">https://opencrux.com/reference/21.04-1.16.0/queries.html</a>
</li>

<li>Essential EDN<br />
<a href="https://opencrux.com/tutorials/essential-edn.html">https://opencrux.com/tutorials/essential-edn.html</a>
</li>

<li>Babashka: interpret Clojure určený pro rychlé spouštění utilit z příkazového řádku<br />
<a href="https://www.root.cz/clanky/babashka-interpret-clojure-urceny-pro-rychle-spousteni-utilit-z-prikazoveho-radku/">https://www.root.cz/clanky/babashka-interpret-clojure-urceny-pro-rychle-spousteni-utilit-z-prikazoveho-radku/</a>
</li>

<li>Introducing JSON<br />
<a href="https://www.json.org/json-en.html">https://www.json.org/json-en.html</a>
</li>

<li>ISO 8601<br />
<a href="https://xkcd.com/1179/">https://xkcd.com/1179/</a>
</li>

<li>What is the right JSON date format<br />
<a href="https://stackoverflow.com/questions/10286204/what-is-the-right-json-date-format">https://stackoverflow.com/questions/10286204/what-is-the-right-json-date-format</a>
</li>

<li>ClojureScript REPL<br />
<a href="https://clojurescript.io/">https://clojurescript.io/</a>
</li>

</ol>



<p></p><p></p>
<p><small>Autor: <a href="http://www.fit.vutbr.cz/~tisnovpa">Pavel Tišnovský</a> &nbsp; 2021</small></p>
</body>
</html>

