<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
        "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html>
<head>
<title>Formát EDN: extensible data notation</title>
<meta name="Author" content="Pavel Tisnovsky" />
<meta name="Generator" content="vim" />
<meta http-equiv="content-type" content="text/html; charset=utf-8" />
<style type="text/css">
         body {color:#000000; background:#ffffff;}
         h1  {font-family: arial, helvetica, sans-serif; color:#ffffff; background-color:#c00000; text-align:center; padding-left:1em}
         h2  {font-family: arial, helvetica, sans-serif; color:#ffffff; background-color:#0000c0; padding-left:1em; text-align:left}
         h3  {font-family: arial, helvetica, sans-serif; color:#000000; background-color:#c0c0c0; padding-left:1em; text-align:left}
         h4  {font-family: arial, helvetica, sans-serif; color:#000000; background-color:#e0e0e0; padding-left:1em; text-align:left}
         a   {font-family: arial, helvetica, sans-serif;}
         li  {font-family: arial, helvetica, sans-serif; color:#000000; text-align:justify; width:450px;}
         ol  {font-family: arial, helvetica, sans-serif; color:#000000; text-align:justify; width:450px;}
         ul  {font-family: arial, helvetica, sans-serif; color:#000000; text-align:justify; width:450px;}
         p   {font-family: arial, helvetica, sans-serif; color:#000000; text-align:justify;}
         pre {background:#e0e0e0}
</style>
</head>

<body>

<h1>Formát EDN: extensible data notation</h1>

<h3>Pavel Tišnovský</h3>

<p></p>

<h1>Úvodník</h1>

<p></p>



<h2>Obsah</h2>

<p><a href="#k01">1. Formát EDN: extensible data notation</a></p>
<p><a href="#k02">*** 2. Sémantické rozdíly mezi formáty EDN, JSON a XML</a></p>
<p><a href="#k03">*** 3. Základní datové typy podporované formátem EDN</a></p>
<p><a href="#k04">*** 4. Řetězce versus keywords</a></p>
<p><a href="#k05">*** 5. Kolekce, které lze v&nbsp;EDN použít</a></p>
<p><a href="#k06">*** 6. Klíče, pravidla pro porovnávání</a></p>
<p><a href="#k07">*** 7. Štítky jako prostředek pro rozšíření formátu EDN</a></p>
<p><a href="#k08">8. Podpora formátu EDN v&nbsp;různých programovacích jazycích</a></p>
<p><a href="#k09">9. Clojure</a></p>
<p><a href="#k10">10. Python</a></p>
<p><a href="#k11">11. Go</a></p>
<p><a href="#k12">12. Praktická část</a></p>
<p><a href="#k13">13. Převod mezi formátem JSON a EDN v&nbsp;Pythonu a Clojure</a></p>
<p><a href="#k14">14. Převod mezi formátem EDN a JSON v&nbsp;Pythonu a Clojure</a></p>
<p><a href="#k15">15. Převod mezi souborem .properties a formátem EDN v&nbsp;Clojure</a></p>
<p><a href="#k16">16. Převod mezi XML a EDN (plná varianta zachovávající vlastnosti XML)</a></p>
<p><a href="#k17">*** 17. Převod XML do různých forem formátu EDN s&nbsp;využitím knihovny Tupelo.forest</a></p>
<p><a href="#k18">*** 18. Práce s&nbsp;formátem EDN v&nbsp;jazyce Go</a></p>
<p><a href="#k19">19. Repositář s&nbsp;demonstračními příklady</a></p>
<p><a href="#k20">20. Odkazy na Internetu</a></p>



<p><a name="k01"></a></p>
<h2 id="k01">1. Formát EDN: extensible data notation</h2>

<p>V&nbsp;dnešním článku se seznámíme se základními vlastnostmi datového
formátu pojmenovaného <i>EDN</i>, což je zkratka celého názvu <i>Extensible
Data Notation</i>. Tento formát, který je primárně určený pro přenos
strukturovaných dat mezi různými systémy a službami, vychází ze syntaxe a
sémantiky <a href="https://www.root.cz/n/clojure/">programovacího jazyka
Clojure</a>, je tedy založen na původních <a
href="https://en.wikipedia.org/wiki/S-expression">S-výrazech</a> rozšířených o
možnost zápisu map (slovníků), množin a vektorů. Popis tohoto formátu (a tím
pádem i popis syntaxe Clojure, resp.&nbsp;jeho podmnožiny) naleznete na stránce
<a
href="https://github.com/edn-format/edn">https://github.com/edn-format/edn</a>,
nás však v&nbsp;dnešním článku bude zajímat i porovnání EDN s&nbsp;dalšími
často používanými datovými formáty JSON a XML a taktéž to, jak lze EDN využít i
v&nbsp;dalších programovacích jazycích; nejenom v&nbsp;samotném Clojure.
Popíšeme si tudíž podporu EDN <a
href="https://pypi.org/project/edn-format/">v&nbsp;Pythonu</a> a <a
href="https://github.com/go-edn/edn">v&nbsp;jazyce Go</a>; ve skutečnosti je
však EDN podporován <a href="https://lib.rs/crates/edn-rs">i v&nbsp;Rustu</a>
či <a href="https://github.com/bpsm/edn-java">v&nbsp;Javě</a>.</p>

<img src="https://i.iinfo.cz/images/214/kawa1-3.png" class="image-366709" alt="&#160;" width="256" height="256" />
<p><i>Obrázek 1: Logo programovacího jazyka Clojure.</i></p>



<p><a name="k02"></a></p>
<h2 id="k02">2. Sémantické rozdíly mezi formáty EDN, JSON a XML</h2>

<p>V&nbsp;současnosti se pro přenos strukturovaných informací (ale popř.&nbsp;i
tabulek) používá relativně velké množství různých datových formátů.
Pravděpodobně nejznámějšími formáty jsou XML a JSON, ovšem vznikají a postupně
jsou adaptovány i další formáty, ať již textové (<a
href="https://yaml.org/">YAML</a>, <a
href="https://github.com/edn-format/edn">edn</a>) či binární (<a
href="http://bsonspec.org/">BSON</a>, <a href="http://bjson.org/">B-JSON</a>,
<a href="https://github.com/FasterXML/smile-format-specification">Smile</a>, <a
href="https://developers.google.com/protocol-buffers/">Protocol-Buffers</a>).
Je velmi pravděpodobné, že se JSON i XML bude i nadále poměrně masivně
využívat, na druhou stranu je dobré znát i některá omezení těchto formátů,
popř.&nbsp;vztah JSONu a XML k&nbsp;formátu EDN. Nejedná se nám přitom o
syntaktické rozdíly &ndash; ty jsou viditelné na první pohled a každý dovede
tyto rozdíly rozeznat. Důležitější jsou rozdíly sémantické a pravě zde můžeme
nalézt celou řadu různých omezení.</p>

<p></p>

<p>V&nbsp;předchozím textu jsem několikrát použil sousloví &bdquo;formát
XML&ldquo;, i když se mnohdy setkáme spíše s&nbsp;označením &bdquo;jazyk
XML&ldquo; (které je ovšem nepřesné). XML, i když se jedná o <i>značkovací
jazyk</i> (<i>markup language</i>) se totiž začal používat i pro přenosy
strukturovaných netextových dat, což se může při zpětném pohledu znát poněkud
zvláštní, neboť pro tento účel není příliš uzpůsoben (ale už fakt, že se XML
podařilo &bdquo;ohnout&ldquo; něco říká o jeho flexibilitě). Sémantika XML se
v&nbsp;mnoha ohledech odlišuje jak od JSONu, tak i od EDN, protože je
v&nbsp;něm nutné datové struktury reprezentovat neexplicitně &ndash; celý XML
dokument tvoří stromovou strukturu a pouze z&nbsp;popisu jednotlivých značek
popř.&nbsp;jejich atributů vyplyne, jaká konkrétní struktura je vlastně
v&nbsp;XML dokumentu uložena, tj.&nbsp;zda se jedná o seznam, asociativní pole
či o množinu (navíc i typ jednotlivých prvků je nutné popsat externě). Ovšem
například v&nbsp;případě množiny a asociativního pole se musí (externě)
kontrolovat integrita datové struktury.</p>

<p><div class="rs-tip-major">Poznámka: nutnost použít další XML s&nbsp;popisem
schématu je dvousečná zbraň; výhodná pro některé nasazení v&nbsp;oblasti SOA,
ovšem na druhou stranu je dosti neflexibilní. I z&nbsp;tohoto důvodu se stále
častěji v&nbsp;oblasti (nejenom) webových služeb setkáme s&nbsp;formátem
JSON.</div></p>

<a href="https://www.json.org/json-en.html">Introducing JSON</a>


<p><a name="k03"></a></p>
<h2 id="k03">3. Základní datové typy podporované formátem EDN</h2>

<p></p>



<p><a name="k04"></a></p>
<h2 id="k04">4. Řetězce versus keywords</h2>

<p></p>



<p><a name="k05"></a></p>
<h2 id="k05">5. Kolekce, které lze v&nbsp;EDN použít</h2>

<p></p>



<p><a name="k06"></a></p>
<h2 id="k06">6. Klíče, pravidla pro porovnávání</h2>

<p></p>

<pre>
user=&gt; <strong>{:foo "bar"}</strong>
{:foo "bar"}
&nbsp;
user=&gt; <strong>{42 "answer"}</strong>
{42 "answer"}
&nbsp;
user=&gt; <strong>{[1 2 3] "a vector"}</strong>
{[1 2 3] "a vector"}
&nbsp;
user=&gt; <strong>{{:type :map} "map is a key"}</strong>
{{:type :map} "map is a key"}
&nbsp;
user=&gt; <strong>{{:another-key [1 2 3]} "strange key"}</strong>
{{:another-key [1 2 3]} "strange key"}
&nbsp;
user=&gt; <strong>{nil "nil as a key"}</strong>
{nil "nil as a key"}
</pre>



<p><a name="k07"></a></p>
<h2 id="k07">7. Štítky jako prostředek pro rozšíření formátu EDN</h2>

<p></p>

https://xkcd.com/1179/



<p><a name="k08"></a></p>
<h2 id="k08">8. Podpora formátu EDN v&nbsp;různých programovacích jazycích</h2>

<p>Formát EDN sice není rozšířený do takové míry, jako formáty XML a JSON,
ovšem i přesto ho lze použít v&nbsp;relativně velkém množství programovacích
jazyků. Jedná se v&nbsp;první řadě o jazyk Clojure, což ovšem není nijak
překvapivé, neboť EDN je prakticky celý odvozen od Clojure (až na štítky).
Kromě Clojure je možné EDN použít v&nbsp;Pythonu, Javě, JavaScriptu, Rustu,
jazyku Go a s&nbsp;velkou pravděpodobností i v&nbsp;dalších jazycích (ovšem již
zmíněné jazyky pokrývají velké množství aplikačních použití). Podporu pro
formát EDN nalezneme i v&nbsp;projektu <a
href="https://github.com/babashka/babashka">Babashka</a>, s&nbsp;nímž jsme se
již na stránkách Roota <a
href="https://www.root.cz/clanky/babashka-interpret-clojure-urceny-pro-rychle-spousteni-utilit-z-prikazoveho-radku/">ve
stručnosti seznámili</a>.</p>

<p>Knihovny pro práci s&nbsp;EDN pro jednotlivé jazyky:</p>

<table>
<tr><th>#</th><th>Programovací jazyk</th><th>Knihovna</th></tr>
<tr><td>1</td><td>Clojure</td><td><a href="https://clojuredocs.org/clojure.edn">clojure.edn (standardní)</a></td></tr>
<tr><td>2</td><td>Python</td><td><a href="https://github.com/swaroopch/edn_format">edn_format</a></td></tr>
<tr><td>3</td><td>Java</td><td><a href="https://github.com/bpsm/edn-java">edn-java</a></td></tr>
<tr><td>4</td><td>JavaScript</td><td><a href="https://github.com/shaunxcode/jsedn">jsedn</a></td></tr>
<tr><td>5</td><td>Rust</td><td><a href="https://lib.rs/crates/edn-rs">edn-rs</a></td></tr>
<tr><td>6</td><td>Go</td><td><a href="https://github.com/go-edn/edn">go-edn/edn</a></td></tr>
<tr><td>7</td><td>Babashka</td><td><a href="https://book.babashka.org/#libraries">clojure.edn (standardní)</a></td></tr>
</table>



<p><a name="k09"></a></p>
<h2 id="k09">9. Clojure</h2>

<p>Podpora formátu EDN v&nbsp;programovacím jazyku Clojure je
&bdquo;nativní&ldquo;, což znamená, že všechny potřebné funkce jsou přímo
součástí standardní knihovny tohoto jazyka. Konkrétně se jedná o balíček (nebo
možná přesněji řečeno jmenný prostor) <a
href="https://clojuredocs.org/clojure.edn">clojure.edn</a>, ve kterém nalezneme
pouhé dvě funkce:</p>

<table>
<tr><th>#</th><th>Funkce</th><th>Stručný popis funkce</th></tr>
<tr><td>1</td><td>read</td><td>načtení dat ve formátu EDN z&nbsp;libovolného vstupního proudu</td></tr>
<tr><td>2</td><td>read-string</td><td>načtení dat ve formátu EDN z&nbsp;řetězce (získaného libovolným postupem)</td></tr>
</table>

<p>Jak je v&nbsp;ekosystému programovacího jazyka Clojure zvykem, lze nápovědu
k&nbsp;těmto funkcím získat přímo z&nbsp;interaktivního prostředí vybaveném
smyčkou REPL. Nejdříve je ovšem nutné příslušnou knihovnu načíst:</p>

<pre>
user=&gt; <strong>(require '[clojure.edn :as edn])</strong>
</pre>

<p>Nápověda k&nbsp;funkci <strong>read</strong>:</p>

<pre>
user=&gt; <strong>(doc edn/read)</strong>
-------------------------
clojure.edn/read
([] [stream] [opts stream])
  Reads the next object from stream, which must be an instance of
  java.io.PushbackReader or some derivee.  stream defaults to the
  current value of *in*.
&nbsp;
  Reads data in the edn format (subset of Clojure data):
  http://edn-format.org
&nbsp;
  opts is a map that can include the following keys:
  :eof - value to return on end-of-file. When not supplied, eof throws an exception.
  :readers  - a map of tag symbols to data-reader functions to be considered before default-data-readers.
              When not supplied, only the default-data-readers will be used.
  :default - A function of two args, that will, if present and no reader is found for a tag,
             be called with the tag and the value.
</pre>

<p>Nápověda k&nbsp;funkci <strong>read-string</strong>:</p>

<pre>
user=&gt; <strong>(doc edn/read-string)</strong>
-------------------------
clojure.edn/read-string
([s] [opts s])
  Reads one object from the string s. Returns <strong>nil</strong> when s is <strong>nil</strong> or empty.
&nbsp;
  Reads data in the edn format (subset of Clojure data):
  http://edn-format.org
&nbsp;
  opts is a map as per clojure.edn/read
</pre>

<p>Možná se nyní ptáte, jakým způsobem se vlastně <i>zapisují</i> data ve
formátu EDN. Odpověď je jednoduchá &ndash; výpis jakékoli datové struktury
jazyka Clojure či jakékoli hodnoty do čitelného formátu již odpovídá formátu
EDN. To znamená, že pro tyto účely lze použít například standardní funkci
<strong>prn-str</strong>, jejíž výsledek se uloží do souboru funkcí
<strong>spit</strong> atd.:</p>

<pre>
user=&gt; <strong>(doc prn-str)</strong>
-------------------------
clojure.core/prn-str
([&amp; xs])
  prn to a string, returning it
</pre>

<p><div class="rs-tip-major">Poznámka: s&nbsp;formátem EDN se v&nbsp;ekosystému
jazyka Clojure setkáme doslova na každém kroku. Ostatně samotné projektové
soubory <strong>project.clj</strong> i přes odlišnou zkratku <i>jsou</i>
reprezentovány jako EDN:</div></p>

<pre>
(defproject edn2json "0.1.0-SNAPSHOT"
  :description "FIXME: write description"
  :url "http://example.com/FIXME"
  :license {:name "EPL-2.0 OR GPL-2.0-or-later WITH Classpath-exception-2.0"
            :url "https://www.eclipse.org/legal/epl-2.0/"}
  :dependencies [[org.clojure/clojure "1.10.1"]
                 [org.clojure/data.json "2.2.0"]]
  :plugins [[lein-project-edn "0.3.0"]]
  :project-edn {:output-file "details.edn"}
  :main ^:skip-aot edn2json.core
  :target-path "target/%s"
  :profiles {:uberjar {:aot :all
                       :jvm-opts ["-Dclojure.compiler.direct-linking=true"]}})
</pre>

<p>Podobně soubory <strong>deps.edn</strong> podporované <a
href="https://www.root.cz/clanky/novinky-v-clojure-verze-1-9-0/">od Clojure
1.9</a> mají tento formát:</p>

<pre>
{:deps
    {net.mikera/core.matrix {:mvn/version "0.62.0"}}}
</pre>

<p>Do souborů ve formátu EDN lze vyexportovat i detailní informace o projektu,
což zajišťuje plugin <strong>lein-project-edn</strong>:</p>

<pre>
{:aliases {"downgrade" "upgrade"},
 :checkout-deps-shares
 [:source-paths
  :test-paths
  :resource-paths
  :compile-path
  "#'leiningen.core.classpath/checkout-deps-paths"],
 :clean-targets [:target-path],
 :compile-path
 "/home/ptisnovs/src/presentations/edn/edn2json/target/default/classes",
 :dependencies
 ([org.clojure/clojure "1.10.1"]
  [org.clojure/data.json "2.2.0"]
  [nrepl/nrepl "0.7.0" :exclusions ([org.clojure/clojure])]
  [clojure-complete/clojure-complete
   "0.2.5"
   :exclusions
   ([org.clojure/clojure])]
  [venantius/ultra "0.6.0"]),
 :deploy-repositories
 [["clojars"
   {:url "https://repo.clojars.org/",
    :password :gpg,
    :username :gpg}]],
 :description "FIXME: write description",
 :eval-in :subprocess,
 :global-vars {},
 :group "edn2json",
 :jar-exclusions ["#\"^\\.\"" "#\"\\Q/.\\E\""],
 :jvm-opts
 ["-XX:-OmitStackTraceInFastThrow"
  "-XX:+TieredCompilation"
  "-XX:TieredStopAtLevel=1"],
 :license
 {:name "EPL-2.0 OR GPL-2.0-or-later WITH Classpath-exception-2.0",
  :url "https://www.eclipse.org/legal/epl-2.0/"},
 :main edn2json.core,
 :monkeypatch-clojure-test false,
 :name "edn2json",
 :native-path
 "/home/ptisnovs/src/presentations/edn/edn2json/target/default/native",
 :offline? false,
 :pedantic? ranges,
 :plugin-repositories
 [["central"
   {:url "https://repo1.maven.org/maven2/", :snapshots false}]
  ["clojars" {:url "https://repo.clojars.org/"}]],
 :plugins
 ([lein-project-edn/lein-project-edn "0.3.0"]
  [venantius/ultra "0.6.0"]
  [lein-kibit/lein-kibit "0.1.8"]),
 :prep-tasks ["javac" "compile"],
 :profiles
 {:uberjar
  {:aot [:all], :jvm-opts ["-Dclojure.compiler.direct-linking=true"]},
  :whidbey/repl
  {:dependencies [[mvxcvi/whidbey "RELEASE"]],
   :repl-options
   {:init
    (do
     nil
     (clojure.core/require 'whidbey.repl)
     (whidbey.repl/init! nil)),
    :custom-init (do nil (whidbey.repl/update-print-fn!)),
    :nrepl-context
    {:interactive-eval {:printer whidbey.repl/render-str}}}}},
 :project-edn {:output-file "details.clj"},
 :release-tasks
 [["vcs" "assert-committed"]
  ["change" "version" "leiningen.release/bump-version" "release"]
  ["vcs" "commit"]
  ["vcs" "tag"]
  ["deploy"]
  ["change" "version" "leiningen.release/bump-version"]
  ["vcs" "commit"]
  ["vcs" "push"]],
 :repl-options
 {:init
  (do
   (do
    (clojure.core/require 'ultra.hardcore)
    (clojure.core/require 'whidbey.repl)
    (whidbey.repl/init! nil)
    (ultra.hardcore/configure!
     {:repl
      {:print-meta false,
       :map-delimiter "",
       :print-fallback :print,
       :sort-keys true}})))},
 :repositories
 [["central"
   {:url "https://repo1.maven.org/maven2/", :snapshots false}]
  ["clojars" {:url "https://repo.clojars.org/"}]],
 :resource-paths
 ("/home/ptisnovs/src/presentations/edn/edn2json/dev-resources"
  "/home/ptisnovs/src/presentations/edn/edn2json/resources"),
 :root
 "/home/ptisnovs/src/presentations/edn/edn2json",
 :source-paths
 ("/home/ptisnovs/src/presentations/edn/edn2json/src"),
 :target-path
 "/home/ptisnovs/src/presentations/edn/edn2json/target/default",
 :test-paths
 ("/home/ptisnovs/src/presentations/edn/edn2json/test"),
 :test-selectors {:default (constantly true)},
 :uberjar-exclusions ["#\"(?i)^META-INF/[^/]*\\.(SF|RSA|DSA)$\""],
 :url "http://example.com/FIXME",
 :version "0.1.0-SNAPSHOT"}
</pre>



<p><a name="k10"></a></p>
<h2 id="k10">10. Python</h2>

<p>V&nbsp;programovacím jazyku Python je formát EDN dostupný přes balíček
nazvaný přímočaře <a
href="https://github.com/swaroopch/edn_format">edn_format</a>. Tento balíček
nainstalujete jednoduše přes <strong>pip</strong>:</p>

<pre>
$ <strong>pip install --user edn_format</strong>
</pre>

<p>Dostupné jsou tyto funkce:</p>

<table>
<tr><th>#</th><th>Funkce</th><th>Stručný popis funkce</th></tr>
<tr><td>1</td><td>loads</td><td>načtení objektu z&nbsp;formátu EDN</td></tr>
<tr><td>2</td><td>loads_all</td><td>načtení všech objektů z&nbsp;formátu EDN (výsledkem může být prázdný seznam)</td></tr>
<tr><td>3</td><td>dumps</td><td>opak předchozích funkcí &ndash; export dat do formátu EDN</td></tr>
</table>

<p>Nápovědu k&nbsp;jednotlivým funkcím opět &ndash; podobně jako v&nbsp;případě
jazyka Clojure &ndash; získáme přímo přes interaktivní smyčku REPL.</p>

<p>Import příslušného balíčku:</p>

<pre>
&gt;&gt;&gt; <strong>import edn_format</strong>
</pre>

<p>Zobrazení nápovědy k&nbsp;celému balíčku:</p>

<pre>
&gt;&gt;&gt; <strong>help(edn_format)</strong>
&nbsp;
Help on package edn_format:
&nbsp;
NAME
    edn_format - # -*- coding: utf-8 -*-
&nbsp;
PACKAGE CONTENTS
    edn_dump
    edn_lex
    edn_parse
    exceptions
    immutable_dict
    immutable_list
    parsetab
</pre>

<p>Nápověda k&nbsp;vybrané funkci, například k&nbsp;funkci
<strong>loads_all</strong>:</p>

<pre>
&gt;&gt;&gt; <strong>help(edn_format.loads_all)</strong>
&nbsp;
...
...
...
</pre>



<p><a name="k11"></a></p>
<h2 id="k11">11. Go</h2>

<p>Podporu formátu EDN nalezneme i v&nbsp;programovacím jazyce Go, pro nějž
vznikla knihovna nazvaná <strong>encoding/edn</strong>, což je
v&nbsp;ekosystému tohoto jazyka zcela konzistentní jméno, protože na
&bdquo;encoding/&ldquo; začínají i jména mnohých dalších knihoven zajištujících
kódování či dekódování dat popř.&nbsp;jejich <i>marshaling</i> a
<i>unmarshaling</i>. Připomeňme si především knihovnu
<strong>encoding/json</strong>.</p>

<p>Balíček pro práci s&nbsp;EDN není součástí standardní knihovny jazyka Go a
proto je nutné balíček explicitně doinstalovat. To se provede následujícím
příkazem:</p>

<pre>
$ <strong>go get olympos.io/encoding/edn</strong>
</pre>

<p>Po instalaci si lze prohlédnou dokumentaci s&nbsp;využitím <strong>go
doc</strong> popř.&nbsp;použít stránku s&nbsp;již vygenerovanou dokumentací: <a
href="https://pkg.go.dev/olympos.io/encoding/edn?utm_source=godoc">https://pkg.go.dev/olympos.io/encoding/edn?utm_source=godoc</a>.</p>

<p>Pro převod libovolného typu (přesněji řečeno hodnoty libovolného typu) do
formátu EDN se používá funkce nazvaná <strong>Marshal</strong>, kterou
nalezneme v&nbsp;balíčku <strong>encoding/edn</strong> nainstalovaném výše
zmíněným příkazem:</p>

<pre>
func <strong>Marshal</strong>(v interface{}) ([]byte, error)
</pre>

<p>Povšimněte si, že tato funkce skutečně akceptuje hodnotu libovolného typu,
protože prázdné rozhraní implementuje (zcela automaticky!) každý datový typ
(s&nbsp;tímto zajímavým konceptem &bdquo;univerzálního datového typu&ldquo; se
ještě několikrát setkáme, zejména v&nbsp;rozhraních mezi Go a dalšími systémy).
Návratovou hodnotou je sekvence bajtů (nikoli řetězec!) a popř.&nbsp;i
struktura reprezentující chybový stav, pokud k&nbsp;chybě skutečně došlo.
V&nbsp;opačném případě se ve druhé návratové hodnotě funkce
<strong>Marshal</strong> vrací <strong>nil</strong>, jak jsme ostatně zvyklí ze
všech podobně koncipovaných funkcí, které mohou za určitých okolností skončit
s&nbsp;chybou.</p>

<p>V&nbsp;typických zdrojových kódech se tedy setkáme s&nbsp;tímto idiomatickým
zápisem:</p>

<pre>
edn_bytes, err := <strong>json.Marshal(a)</strong>
&nbsp;
if err != nil {
        log.Fatal(err)
}
...
...
...
</pre>

<p><div class="rs-tip-major">Poznámka: to, že funkci <strong>Marshal</strong>
můžeme zavolat a předat jí libovolnou hodnotu ovšem v&nbsp;žádném případě
neznamená, že převod bude skutečně proveden. Některé typy hodnot totiž nemají
v&nbsp;EDN svoji obdobu (je to například funkce nebo ukazatel). Podrobnosti o
podporovaných a nepodporovaných typech budou vysvětleny v&nbsp;navazujících
kapitolách při popisu demonstračních příkladů.</div></p>

<p>Jméno funkce odpovídá prováděné operaci, takzvanému <i>marshalingu</i>.
Opačná operace, tj.&nbsp;převod dat z&nbsp;EDN do datových struktur Go, se
nazývá <i>unmarshalling</i>. Jedná se o funkci s&nbsp;touto hlavičkou:</p>

<pre>
func <strong>Unmarshal</strong>(data []byte, v interface{}) error
</pre>

<p>Vstupem je v&nbsp;tomto případě pole (řez) bajtů, výstup je vrácen přes
ukazatel předaný ve druhém parametru (což znamená, že se musíme sami postarat o
případnou alokaci paměti pro strukturu či pro mapu). Samozřejmě, že při
unmarshalingu může dojít k&nbsp;nějaké chybě, která je vrácena volající funkci.
Pokud k&nbsp;chybě nedošlo, je návratová hodnota rovna <strong>nil</strong>,
opět přesně podle zvyklostí programovacího jazyka Go.</p>



<p><a name="k12"></a></p>
<h2 id="k12">12. Praktická část</h2>

<p>Druhá část dnešního článku bude zaměřena spíše prakticky. Ukážeme si totiž
některé možnosti práce s&nbsp;formátem EDN v&nbsp;programovacích jazycích
Clojure, Python i Go. Uvidíme &ndash; což je ovšem očekávatelné &ndash; že se
jednotlivé jazyky od sebe velmi odlišují při operacích typu serializace a
deserializace datových struktur (též se setkáme s&nbsp;termíny
<i>marshaling</i> a <i>unmarshaling</i>, které sice striktně řečeno nemají
úplně shodný význam, ale mnohdy se mezi sebou zaměňují).</p>



<p><a name="k13"></a></p>
<h2 id="k13">13. Převod mezi formátem JSON a EDN v&nbsp;Pythonu a Clojure</h2>

<p>Nejprve se podívejme na způsob realizace převodů mezi formáty JSON a EDN,
což může být dosti častý případ využitelný v&nbsp;praxi. Ukážeme si, jak se
tyto převody provedou v&nbsp;jazyce Python a taktéž v&nbsp;programovacím jazyku
Clojure. Začneme příkladem vypracovaným v&nbsp;Pythonu, který provede převod
mezi souborem s&nbsp;daty uloženými ve formátu JSON a formátem EDN. Realizace
tohoto příkladu je poměrně přímočará &ndash; nejprve se s&nbsp;využitím funkce
<strong>load</strong> z&nbsp;balíčku <strong>json</strong> načte vstupní soubor
a posléze se funkcí <strong>dumps</strong> z&nbsp;balíčku
<strong>end_format</strong> data převedou do formátu EDN. Typicky se budou
převádět seznamy popř.&nbsp;mapy (asociativní pole):</p>

<pre>
<i>#!/usr/bin/env python3</i>
&nbsp;
<i># Converts structured data from JSON format into EDN format.</i>
&nbsp;
import sys
import json
import edn_format
&nbsp;
<i># Check if command line argument is specified (it is mandatory).</i>
if len(sys.argv) &lt; 2:
    print("Usage:")
    print("  json2edn.py input_file.csv")
    print("Example:")
    print("  json2edn.py report.csv")
    sys.exit(1)
&nbsp;
<i># First command line argument should contain name of input JSON file.</i>
input_json = sys.argv[1]
&nbsp;
<i># Try to open the JSON file specified.</i>
with open(input_json) as json_input:
    <i># open the JSON file and parse it</i>
    payload = json.load(json_input)
    <i># dump the parsed data structure into EDN format</i>
    print(edn_format.dumps(payload))
</pre>

<p>Pro porovnání se podívejme na realizaci stejného převodníku, nyní ovšem
vypracovaného v&nbsp;jazyku Clojure. Zde se použije funkce
<strong>read-str</strong> z&nbsp;balíčku <strong>clojure.data.json</strong> pro
vstup a de facto standardní funkce <strong>pprint</strong> z&nbsp;balíčku
<strong>clojure.pprint</strong> pro výstup dat, protože ten bude kompatibilní
s&nbsp;formátem EDN:</p>

<pre>
(ns json2edn.core)
&nbsp;
(require '[clojure.data.json :as json])
(require '[clojure.edn :as edn])
&nbsp;
&nbsp;
(defn <strong>json-&gt;edn</strong>
  <i>"Convert JSON format into EDN format."</i>
  [json-file-name edn-file-name]
  (let [payload (-&gt; json-file-name slurp (json/read-str :key-fn keyword))
        fout    (clojure.java.io/writer edn-file-name)]
    (clojure.pprint/pprint payload)
    (clojure.pprint/pprint payload fout)))
&nbsp;
&nbsp;
(defn <strong>-main</strong>
  [&amp; args]
  (json-&gt;edn "details.json" "details.edn"))
</pre>

<p>Následuje příklad použití:</p>

<p>Vstup (reálná data):</p>

<pre>
{
    "Messages": [
        {
            "MessageId": "aaaaaaaa-bbbb-cccc-dddd-eeeeeeeeeeee",
            "ReceiptHandle": "123",
            "MD5OfBody": "cafe0000cafe0000cafe0000cafe0000",
            "Body": "{\"Records\": [{\"s3\": {\"object\": {\"key\": \"7307752/aaaaaaaa-bbbb-cccc-dddd-eeeeeeeeeeee/20200609125740-0123456789abcdef0123456789abcdef\",\"size\": 11805,\"eTag\": \"beef0000beef0000beef0000beef0000\",\"sequencer\": \"005EDF87444DDF7525\"}}}]}",
            "Attributes": {
                "SenderId": "321123",
                "ApproximateFirstReceiveTimestamp": "1591707477622",
                "ApproximateReceiveCount": "1",
                "SentTimestamp": "1591707468964"
            }
        }
    ],
    "ResponseMetadata": {
        "RequestId": "aaaaaaaa-bbbb-cccc-dddd-eeeeeeeeeeee",
        "HTTPStatusCode": 200,
        "HTTPHeaders": {
            "x-amzn-requestid": "aaaaaaaa-bbbb-cccc-dddd-eeeeeeeeeeee",
            "date": "Tue, 09 Jun 2020 12:57:57 GMT",
            "content-type": "text/xml",
            "content-length": "22437"
        },
        "RetryAttempts": 0
    }
}
</pre>

<p>Převod:</p>

<pre>
$ <strong>lein run</strong>
</pre>

<p>Výstup:</p>

<pre>
{:Messages
 [{:MessageId "aaaaaaaa-bbbb-cccc-dddd-eeeeeeeeeeee",
   :ReceiptHandle "123",
   :MD5OfBody "cafe0000cafe0000cafe0000cafe0000",
   :Body
   "{\"Records\": [{\"s3\": {\"object\": {\"key\": \"7307752/aaaaaaaa-bbbb-cccc-dddd-eeeeeeeeeeee/20200609125740-0123456789abcdef0123456789abcdef\",\"size\": 11805,\"eTag\": \"beef0000beef0000beef0000beef0000\",\"sequencer\": \"005EDF87444DDF7525\"}}}]}",
   :Attributes
   {:SenderId "321123",
    :ApproximateFirstReceiveTimestamp "1591707477622",
    :ApproximateReceiveCount "1",
    :SentTimestamp "1591707468964"}}],
 :ResponseMetadata
 {:RequestId "aaaaaaaa-bbbb-cccc-dddd-eeeeeeeeeeee",
  :HTTPStatusCode 200,
  :HTTPHeaders
  {:x-amzn-requestid "aaaaaaaa-bbbb-cccc-dddd-eeeeeeeeeeee",
   :date "Tue, 09 Jun 2020 12:57:57 GMT",
   :content-type "text/xml",
   :content-length "22437"},
  :RetryAttempts 0}}
</pre>



<p><a name="k14"></a></p>
<h2 id="k14">14. Převod mezi formátem EDN a JSON v&nbsp;Pythonu a Clojure</h2>

<p>Opačný převod mezi formátem EDN a JSON v&nbsp;Pythonu není tak přímočarý,
jak by se mohlo na první pohled zdát. Je tomu tak z&nbsp;toho důvodu, že
seznamy a mapy (asociativní pole) v&nbsp;EDN jsou realizovány formou
neměnitelné (<i>immutable</i>) datové struktury typu
<strong>ImmutableList</strong> a <strong>ImmutableDict</strong>, kterou nelze
přímo do JSONu serializovat. Je tedy nutné tyto struktury převést na běžný
(měnitelný) seznam popř.&nbsp;slovník, což v&nbsp;dalším kódu zajišťuje
rekurzivně volaná funkce <strong>edn_to_map</strong>, která byla převzata
z&nbsp;<a
href="https://github.com/swaroopch/edn_format/issues/76#issuecomment-749618312">https://github.com/swaroopch/edn_format/issues/76#issuecomment-749618312</a>:</p>

<pre>
<i># Taken from https://github.com/swaroopch/edn_format/issues/76#issuecomment-749618312</i>
def <strong>edn_to_map</strong>(x):
    if isinstance(x, edn_format.ImmutableDict):
        return {edn_to_map(k): edn_to_map(v) for k, v in x.items()}
    elif isinstance(x, edn_format.ImmutableList):
        return [edn_to_map(v) for v in x]
    elif isinstance(x, edn_format.Keyword):
        return x.name
    else:
        return x
</pre>

<p>Úplný kód převodníku může vypadat takto:</p>

<pre>
<i>#!/usr/bin/env python3</i>
&nbsp;
<i># Converts structured data from EDN format into JSON format.</i>
&nbsp;
import sys
import json
import edn_format
&nbsp;
<i># Check if command line argument is specified (it is mandatory).</i>
if len(sys.argv) &lt; 2:
    print("Usage:")
    print("  edn2json.py input_file.edn")
    print("Example:")
    print("  edn2json.py report.edn")
    sys.exit(1)

<i># First command line argument should contain name of input EDN file.</i>
filename = sys.argv[1]
&nbsp;
&nbsp;
<i># Taken from https://github.com/swaroopch/edn_format/issues/76#issuecomment-749618312</i>
def edn_to_map(x):
    if isinstance(x, edn_format.ImmutableDict):
        return {edn_to_map(k): edn_to_map(v) for k, v in x.items()}
    elif isinstance(x, edn_format.ImmutableList):
        return [edn_to_map(v) for v in x]
    elif isinstance(x, edn_format.Keyword):
        return x.name
    else:
        return x
&nbsp;
&nbsp;
<i># Try to open the EDN file specified.</i>
with open(filename, "r") as edn_input:
    <i># open the EDN file and parse it</i>
    payload = edn_format.loads(edn_input.read())
    print(json.dumps(edn_to_map(payload), indent=2))
</pre>

<p>Přepis do jazyka Clojure je ovšem přímočarý a struktura tohoto příkladu
odpovídá příkladu pro převod opačný (viz předchozí kapitolu):</p>

<pre>
(ns edn2json.core)
&nbsp;
(require '[clojure.data.json :as json])
(require '[clojure.edn :as edn])
&nbsp;
&nbsp;
(defn <strong>edn-&gt;json</strong>
  <i>"Convert EDN format into JSON format."</i>
  [edn-file-name json-file-name]
  (let [payload (-&gt; edn-file-name slurp edn/read-string)
        output (with-out-str (json/pprint payload))]
    (spit json-file-name output)))
&nbsp;
&nbsp;
(defn <strong>-main</strong>
  [&amp; args]
  (edn-&gt;json "details.edn" "details.json"))
</pre>

<p>Opět následuje příklad použití:</p>

<p>Vstup (detailní informace o projektu reprezentované v&nbsp;EDN):</p>

<pre>
{:aliases {"downgrade" "upgrade"},
 :checkout-deps-shares
 [:source-paths
  :test-paths
  :resource-paths
  :compile-path
  "#'leiningen.core.classpath/checkout-deps-paths"],
 :clean-targets [:target-path],
 :compile-path
 "/home/ptisnovs/src/presentations/edn/edn2json/target/default/classes",
 :dependencies
 ([org.clojure/clojure "1.10.1"]
  [org.clojure/data.json "2.2.0"]
  [nrepl/nrepl "0.7.0" :exclusions ([org.clojure/clojure])]
  [clojure-complete/clojure-complete
   "0.2.5"
   :exclusions
   ([org.clojure/clojure])]
  [venantius/ultra "0.6.0"]),
 :deploy-repositories
 [["clojars"
   {:url "https://repo.clojars.org/",
    :password :gpg,
    :username :gpg}]],
 :description "FIXME: write description",
 :eval-in :subprocess,
 :global-vars {},
 :group "edn2json",
 :jar-exclusions ["#\"^\\.\"" "#\"\\Q/.\\E\""],
 :jvm-opts
 ["-XX:-OmitStackTraceInFastThrow"
  "-XX:+TieredCompilation"
  "-XX:TieredStopAtLevel=1"],
 :license
 {:name "EPL-2.0 OR GPL-2.0-or-later WITH Classpath-exception-2.0",
  :url "https://www.eclipse.org/legal/epl-2.0/"},
 :main edn2json.core,
 :monkeypatch-clojure-test false,
 :name "edn2json",
 :native-path
 "/home/ptisnovs/src/presentations/edn/edn2json/target/default/native",
 :offline? false,
 :pedantic? ranges,
 :plugin-repositories
 [["central"
   {:url "https://repo1.maven.org/maven2/", :snapshots false}]
  ["clojars" {:url "https://repo.clojars.org/"}]],
 :plugins
 ([lein-project-edn/lein-project-edn "0.3.0"]
  [venantius/ultra "0.6.0"]
  [lein-kibit/lein-kibit "0.1.8"]),
 :prep-tasks ["javac" "compile"],
 :profiles
 {:uberjar
  {:aot [:all], :jvm-opts ["-Dclojure.compiler.direct-linking=true"]},
  :whidbey/repl
  {:dependencies [[mvxcvi/whidbey "RELEASE"]],
   :repl-options
   {:init
    (do
     nil
     (clojure.core/require 'whidbey.repl)
     (whidbey.repl/init! nil)),
    :custom-init (do nil (whidbey.repl/update-print-fn!)),
    :nrepl-context
    {:interactive-eval {:printer whidbey.repl/render-str}}}}},
 :project-edn {:output-file "details.clj"},
 :release-tasks
 [["vcs" "assert-committed"]
  ["change" "version" "leiningen.release/bump-version" "release"]
  ["vcs" "commit"]
  ["vcs" "tag"]
  ["deploy"]
  ["change" "version" "leiningen.release/bump-version"]
  ["vcs" "commit"]
  ["vcs" "push"]],
 :repl-options
 {:init
  (do
   (do
    (clojure.core/require 'ultra.hardcore)
    (clojure.core/require 'whidbey.repl)
    (whidbey.repl/init! nil)
    (ultra.hardcore/configure!
     {:repl
      {:print-meta false,
       :map-delimiter "",
       :print-fallback :print,
       :sort-keys true}})))},
 :repositories
 [["central"
   {:url "https://repo1.maven.org/maven2/", :snapshots false}]
  ["clojars" {:url "https://repo.clojars.org/"}]],
 :resource-paths
 ("/home/ptisnovs/src/presentations/edn/edn2json/dev-resources"
  "/home/ptisnovs/src/presentations/edn/edn2json/resources"),
 :root
 "/home/ptisnovs/src/presentations/edn/edn2json",
 :source-paths
 ("/home/ptisnovs/src/presentations/edn/edn2json/src"),
 :target-path
 "/home/ptisnovs/src/presentations/edn/edn2json/target/default",
 :test-paths
 ("/home/ptisnovs/src/presentations/edn/edn2json/test"),
 :test-selectors {:default (constantly true)},
 :uberjar-exclusions ["#\"(?i)^META-INF/[^/]*\\.(SF|RSA|DSA)$\""],
 :url "http://example.com/FIXME",
 :version "0.1.0-SNAPSHOT"
}
</pre>

<p>Převod:</p>

<pre>
$ <strong>lein run</strong>
</pre>

<p>Výstup:</p>

<pre>
{"description":"FIXME: write description",
 "compile-path":
 "\/home\/ptisnovs\/src\/presentations\/edn\/edn2json\/target\/default\/classes",
 "deploy-repositories":
 [["clojars",
   {"url":"https:\/\/repo.clojars.org\/",
    "password":"gpg",
    "username":"gpg"}]],
 "group":"edn2json",
 "license":
 {"name":"EPL-2.0 OR GPL-2.0-or-later WITH Classpath-exception-2.0",
  "url":"https:\/\/www.eclipse.org\/legal\/epl-2.0\/"},
 "project-edn":{"output-file":"details.clj"},
 "resource-paths":
 ["\/home\/ptisnovs\/src\/presentations\/edn\/edn2json\/dev-resources",
  "\/home\/ptisnovs\/src\/presentations\/edn\/edn2json\/resources"],
 "name":"edn2json",
 "checkout-deps-shares":
 ["source-paths", "test-paths", "resource-paths", "compile-path",
  "#'leiningen.core.classpath\/checkout-deps-paths"],
 "source-paths":
 ["\/home\/ptisnovs\/src\/presentations\/edn\/edn2json\/src"],
 "eval-in":"subprocess",
 "repositories":
 [["central",
   {"url":"https:\/\/repo1.maven.org\/maven2\/", "snapshots":false}],
  ["clojars", {"url":"https:\/\/repo.clojars.org\/"}]],
 "test-paths":
 ["\/home\/ptisnovs\/src\/presentations\/edn\/edn2json\/test"],
 "target-path":
 "\/home\/ptisnovs\/src\/presentations\/edn\/edn2json\/target\/default",
 "prep-tasks":["javac", "compile"],
 "native-path":
 "\/home\/ptisnovs\/src\/presentations\/edn\/edn2json\/target\/default\/native",
 "offline?":false,
 "root":"\/home\/ptisnovs\/src\/presentations\/edn\/edn2json",
 "pedantic?":"ranges",
 "clean-targets":["target-path"],
 "plugins":
 [["lein-project-edn", "0.3.0"], ["ultra", "0.6.0"],
  ["lein-kibit", "0.1.8"]],
 "url":"http:\/\/example.com\/FIXME",
 "profiles":
 {"uberjar":
  {"aot":["all"],
   "jvm-opts":["-Dclojure.compiler.direct-linking=true"]},
  "repl":
  {"dependencies":[["whidbey", "RELEASE"]],
   "repl-options":
   {"init":
    ["do", null, ["require", "'whidbey.repl"], ["init!", null]],
    "custom-init":["do", null, ["update-print-fn!"]],
    "nrepl-context":{"interactive-eval":{"printer":"render-str"}}}}},
 "plugin-repositories":
 [["central",
   {"url":"https:\/\/repo1.maven.org\/maven2\/", "snapshots":false}],
  ["clojars", {"url":"https:\/\/repo.clojars.org\/"}]],
 "aliases":{"downgrade":"upgrade"},
 "version":"0.1.0-SNAPSHOT",
 "jar-exclusions":["#\"^\\.\"", "#\"\\Q\/.\\E\""],
 "main":"edn2json.core",
 "global-vars":{},
 "uberjar-exclusions":["#\"(?i)^META-INF\/[^\/]*\\.(SF|RSA|DSA)$\""],
 "jvm-opts":
 ["-XX:-OmitStackTraceInFastThrow", "-XX:+TieredCompilation",
  "-XX:TieredStopAtLevel=1"],
 "dependencies":
 [["clojure", "1.10.1"], ["data.json", "2.2.0"],
  ["nrepl", "0.7.0", "exclusions", [["clojure"]]],
  ["clojure-complete", "0.2.5", "exclusions", [["clojure"]]],
  ["ultra", "0.6.0"]],
 "release-tasks":
 [["vcs", "assert-committed"],
  ["change", "version", "leiningen.release\/bump-version", "release"],
  ["vcs", "commit"], ["vcs", "tag"], ["deploy"],
  ["change", "version", "leiningen.release\/bump-version"],
  ["vcs", "commit"], ["vcs", "push"]],
 "repl-options":
 {"init":
  ["do",
   ["do", ["require", "'ultra.hardcore"], ["require", "'whidbey.repl"],
    ["init!", null],
    ["configure!",
     {"repl":
      {"print-meta":false,
       "map-delimiter":"",
       "print-fallback":"print",
       "sort-keys":true}}]]]},
 "test-selectors":{"default":["constantly", true]},
 "monkeypatch-clojure-test":false}
</pre>



<p><a name="k15"></a></p>
<h2 id="k15">15. Převod mezi souborem .properties a formátem EDN v&nbsp;Clojure</h2>

<p>Relativně často se v&nbsp;aplikacích vytvářených v&nbsp;jazyku Clojure
setkáme se soubory s&nbsp;koncovkou <strong>.properties</strong>, které jsou
ostatně v&nbsp;ekosystému programovacího jazyka Java běžné. Převod takových
souborů do EDN je snadný, protože můžeme využít možnosti nabízené třídou
<strong>java.util.Properties</strong> pro načtení hodnot s&nbsp;jejich
následnou konverzí funkcí <strong>properties-&gt;map</strong>:</p>

<pre>
(ns properties2edn.core)
&nbsp;
&nbsp;
(defn <strong>properties-&gt;map</strong>
  <i>"Convert properties entries into a map. Keys are converted into proper keywords."</i>
  [properties]
  (into {}
        (for [[k v] properties]
              [(keyword k) v])))
&nbsp;
&nbsp;
(defn <strong>load-properties-file</strong>
  <i>"Load configuration from the provided properties file."</i>
  [file-name]
  (with-open [reader (clojure.java.io/reader file-name)]
    (let [properties (java.util.Properties.)]
      (.load properties reader)
      (properties-&gt;map properties))))
&nbsp;
&nbsp;
(defn <strong>properties-&gt;edn</strong>
  <i>"Convert properties file into EDN format."</i>
  [properties-file-name edn-file-name]
  (let [payload (load-properties-file properties-file-name)
        fout    (clojure.java.io/writer edn-file-name)]
    (clojure.pprint/pprint payload fout)))
&nbsp;
&nbsp;
(defn <strong>-main</strong>
  [&amp; args]
  (properties-&gt;edn "test.properties" "test.edn"))
</pre>

<p>Příklad převodu:</p>

<p>Vstup (soubor s&nbsp;reálnými daty):</p>

<pre>
# This file is shared currently between this Gradle build and the
# Ant builds for fd303 and JavaScript. Keep the dotted notation for
# the properties to minimize the changes in the dependencies.
thrift.version=0.14.0
thrift.groupid=org.apache.thrift
release=false
&nbsp;
# Local Install paths
install.path=/usr/local/lib
install.javadoc.path=/usr/local/lib
&nbsp;
# Test execution properties
testPort=9090
&nbsp;
# Test with Clover Code coverage (disabled by default)
cloverEnabled=false
&nbsp;
# Maven dependency download locations
mvn.repo=https://repo1.maven.org/maven2
apache.repo=https://repository.apache.org/content/repositories/releases
&nbsp;
# Apache Maven publish
license=https://www.apache.org/licenses/LICENSE-2.0.txt
maven-repository-url=https://repository.apache.org/service/local/staging/deploy/maven2
maven-repository-id=apache.releases.https
&nbsp;
# Dependency versions
httpclient.version=4.5.10
httpcore.version=4.4.12
slf4j.version=1.7.28
#servlet.version=2.5
#It contains servlet3
tomcat.embed.version=8.5.46
junit.version=4.12
mockito.version=1.10.19
javax.annotation.version=1.3.2
</pre>

<p>Převod:</p>

<pre>
$ <strong>lein run</strong>
</pre>

<p>Výstup:</p>

<pre>
{:tomcat.embed.version "8.5.46",
 :thrift.version "0.14.0",
 :httpclient.version "4.5.10",
 :mockito.version "1.10.19",
 :javax.annotation.version "1.3.2",
 :thrift.groupid "org.apache.thrift",
 :license "https://www.apache.org/licenses/LICENSE-2.0.txt",
 :install.javadoc.path "/usr/local/lib",
 :slf4j.version "1.7.28",
 :httpcore.version "4.4.12",
 :release "false",
 :mvn.repo "https://repo1.maven.org/maven2",
 :maven-repository-url "https://repository.apache.org/service/local/staging/deploy/maven2",
 :maven-repository-id "apache.releases.https",
 :testPort "9090",
 :apache.repo "https://repository.apache.org/content/repositories/releases",
 :junit.version "4.12",
 :cloverEnabled "false",
 :install.path "/usr/local/lib"}
</pre>



<p><a name="k16"></a></p>
<h2 id="k16">16. Převod mezi XML a EDN (plná varianta zachovávající vlastnosti XML)</h2>

<p>V&nbsp;základní knihovně programovacího jazyka Clojure nalezneme i balíček
<strong>clojure.xml</strong> s&nbsp;funkcemi určenými pro načítání souborů XML.
Výsledkem načtení (parsingu) je mapa, jejíž prvky mají jednotný formát. Samotný
převodník z&nbsp;formátu XML přes mapu do formátu EDN je přímočarý (další
možnosti jsou ukázány v&nbsp;navazující kapitole):</p>

<pre>
(ns xml2edn.core)
&nbsp;
(use '[clojure.xml])
&nbsp;
&nbsp;
(defn <strong>xml-&gt;edn</strong>
  <i>"Convert XML file into EDN format."</i>
  [xml-file-name edn-file-name]
  (let [payload (clojure.xml/parse "nested.xml")
        fout    (clojure.java.io/writer edn-file-name)]
    (clojure.pprint/pprint payload fout)))
&nbsp;
&nbsp;
(defn <strong>-main</strong>
  [&amp; args]
  (xml-&gt;edn "nested.xml" "nested.edn"))
</pre>

<p>Podívejme se nyní, jakým způsobem je zkonvertován následující (na první
pohled velmi jednoduchý) soubor:</p>

<pre>
&lt;?xml version="1.0"?&gt;
&lt;first&gt;
  &lt;second value="A"&gt;
    &lt;third&gt;
      &lt;fourth&gt;Hello A&lt;/fourth&gt;
    &lt;/third&gt;
  &lt;/second&gt;
  &lt;second value="B"&gt;
    &lt;third&gt;
      &lt;fourth&gt;Hello B&lt;/fourth&gt;
    &lt;/third&gt;
  &lt;/second&gt;
&lt;/first&gt;
</pre>

<p>Výsledkem převodu bude relativně složitá rekurzivní mapa, která ovšem přesně
odpovídá vstupnímu XML, ovšem s&nbsp;tím rozdílem, že jsou explicitně vypsány i
hodnoty atributů:</p>

<pre>
{:tag :first,
 :attrs nil,
 :content
 [{:tag :second,
   :attrs {:value "A"},
   :content
   [{:tag :third,
     :attrs nil,
     :content [{:tag :fourth, :attrs nil, :content ["Hello A"]}]}]}
  {:tag :second,
   :attrs {:value "B"},
   :content
   [{:tag :third,
     :attrs nil,
     :content [{:tag :fourth, :attrs nil, :content ["Hello B"]}]}]}]}
</pre>



<p><a name="k17"></a></p>
<h2 id="k17">17. Převod XML do různých forem formátu EDN s&nbsp;využitím knihovny Tupelo.forest</h2>


<pre>
(defproject forest-demo "0.1.0-SNAPSHOT"
  :description "FIXME: write description"
  :url "http://example.com/FIXME"
  :license {:name "EPL-2.0 OR GPL-2.0-or-later WITH Classpath-exception-2.0"
            :url "https://www.eclipse.org/legal/epl-2.0/"}
  :dependencies [[org.clojure/clojure "1.10.1"]
                 [tupelo "21.04.13"]]
  :main ^:skip-aot forest-demo.core
  :target-path "target/%s"
  :profiles {:uberjar {:aot :all
                       :jvm-opts ["-Dclojure.compiler.direct-linking=true"]}})
</pre>

<pre>
(ns forest-demo.core)

(require '[clojure.xml :as xml])
(require '[tupelo.forest :as tf])


(defn pprint-to-file
  [filename payload]
  (clojure.pprint/pprint payload (clojure.java.io/writer filename)))


(defn -main
  [& args]
  (let [payload        (xml/parse "nested.xml")
        hiccup-format  (tf/enlive-&gt;hiccup payload)
        bush-format    (tf/enlive-&gt;bush payload)
        tree-format    (tf/enlive-&gt;tree payload)]
    (pprint-to-file "nested-enlive.edn" payload)
    (pprint-to-file "nested-hiccup.edn" hiccup-format)
    (pprint-to-file "nested-bush.edn" bush-format)
    (pprint-to-file "nested-tree.edn" tree-format)))
</pre>

<pre>
<?xml version="1.0"?>
<first>
  <second value="A">
    <third>
      <fourth>Hello A</fourth>
    </third>
  </second>
  <second value="B">
    <third>
      <fourth>Hello B</fourth>
    </third>
  </second>
</first>
</pre>

<pre>
{:tag :first,
 :attrs nil,
 :content
 [{:tag :second,
   :attrs {:value "A"},
   :content
   [{:tag :third,
     :attrs nil,
     :content [{:tag :fourth, :attrs nil, :content ["Hello A"]}]}]}
  {:tag :second,
   :attrs {:value "B"},
   :content
   [{:tag :third,
     :attrs nil,
     :content [{:tag :fourth, :attrs nil, :content ["Hello B"]}]}]}]}
</pre>

<pre>
[:first
 [:second {:value "A"} [:third [:fourth "Hello A"]]]
 [:second {:value "B"} [:third [:fourth "Hello B"]]]]
</pre>

<pre>
[{:tag :first}
 [{:value "A", :tag :second}
  [{:tag :third} [{:tag :fourth, :value "Hello A"}]]]
 [{:value "B", :tag :second}
  [{:tag :third} [{:tag :fourth, :value "Hello B"}]]]]
</pre>

<pre>
{:tag :first,
 :tupelo.forest/kids
 [{:value "A",
   :tag :second,
   :tupelo.forest/kids
   [{:tag :third,
     :tupelo.forest/kids
     [{:tag :fourth, :value "Hello A", :tupelo.forest/kids []}]}]}
  {:value "B",
   :tag :second,
   :tupelo.forest/kids
   [{:tag :third,
     :tupelo.forest/kids
     [{:tag :fourth, :value "Hello B", :tupelo.forest/kids []}]}]}]}
</pre>


<p><a name="k18"></a></p>
<h2 id="k18">18. Práce s&nbsp;formátem EDN v&nbsp;jazyce Go</h2>

<p></p>

<pre>
package main

import (
        "fmt"
        "olympos.io/encoding/edn"
)

// User1 je uživatelsky definovaná datová struktura s privátními atributy
type User1 struct {
        id      uint32
        name    string
        surname string
}

// User2 je uživatelsky definovaná datová struktura s viditelnými atributy
type User2 struct {
        ID      uint32
        Name    string
        Surname string
}

func main() {
        user1 := User1{
                1,
                "Pepek",
                "Vyskoč"}

        user2 := User2{
                1,
                "Pepek",
                "Vyskoč"}

        fmt.Println("user1")
        user1EDN, _ := edn.Marshal(user1)
        fmt.Println(string(user1EDN))

        fmt.Println()
        user1PrettyEDN, _ := edn.MarshalPPrint(user1, nil)
        fmt.Println(string(user1PrettyEDN))
        fmt.Println()

        fmt.Println("user2")
        user2EDN, _ := edn.Marshal(user2)
        fmt.Println(string(user2EDN))

        fmt.Println()
        user2PrettyEDN, _ := edn.MarshalPPrint(user2, nil)
        fmt.Println(string(user2PrettyEDN))
        fmt.Println()
}
</pre>

<pre>
package main

import (
        "fmt"
        "olympos.io/encoding/edn"
)

// User3 je uživatelsky definovaná datová struktura s viditelnými atributy
type User3 struct {
        ID      uint32 `edn:"id"`
        Name    string `edn:"user-name"`
        Surname string `edn:"surname"`
}

func main() {
        user3 := User3{
                1,
                "Pepek",
                "Vyskoč"}

        fmt.Println("user3")
        user3EDN, _ := edn.Marshal(user3)
        fmt.Println(string(user3EDN))
        fmt.Println()

        user3PrettyEDN, _ := edn.MarshalPPrint(user3, nil)
        fmt.Println(string(user3PrettyEDN))
        fmt.Println()
}
</pre>

<pre>
package main

import (
        "fmt"
        "olympos.io/encoding/edn"
)

// User3 je uživatelsky definovaná datová struktura s viditelnými atributy
type User3 struct {
        ID      uint32 `edn:"id"`
        Name    string `edn:"user-name"`
        Surname string `edn:"surname"`
}

func main() {
        var users = [3]User3{
                User3{
                        ID:      1,
                        Name:    "Pepek",
                        Surname: "Vyskoč"},
                User3{
                        ID:      2,
                        Name:    "Pepek",
                        Surname: "Vyskoč"},
                User3{
                        ID:      3,
                        Name:    "Josef",
                        Surname: "Vyskočil"},
        }

        fmt.Println("users")
        usersEDN, _ := edn.Marshal(users)
        fmt.Println(string(usersEDN))
        fmt.Println()

        usersPrettyEDN, _ := edn.MarshalPPrint(users, nil)
        fmt.Println(string(usersPrettyEDN))
        fmt.Println()
}
</pre>

<pre>
package main

import (
        "fmt"
        "olympos.io/encoding/edn"
)

// User3 je uživatelsky definovaná datová struktura s viditelnými atributy
type User3 struct {
        ID      uint32 `edn:"id"`
        Name    string `edn:"user-name"`
        Surname string `edn:"surname"`
}

func main() {
        m1 := make(map[string]User3)

        m1["user-id-1"] = User3{
                ID:      1,
                Name:    "Pepek",
                Surname: "Vyskoč"}

        m1["user-id-3"] = User3{
                ID:      2,
                Name:    "Josef",
                Surname: "Vyskočil"}

        fmt.Println("users map")
        usersMapEDN, _ := edn.Marshal(m1)
        fmt.Println(string(usersMapEDN))
        fmt.Println()
        usersPrettyEDN, _ := edn.MarshalPPrint(m1, nil)
        fmt.Println(string(usersPrettyEDN))
        fmt.Println()
}
</pre>



<p><a name="k19"></a></p>
<h2 id="k19">19. Repositář s&nbsp;demonstračními příklady</h2>

<p>Zdrojové kódy všech dnes popsaných demonstračních příkladů vyvinutých
v&nbsp;programovacích jazycích Clojure, Python i Go, byly uloženy do Git
repositáře, který je dostupný na adrese <a
href="https://github.com/tisnik/presentations">https://github.com/tisnik/presentations</a>:</p>

<table>
<tr><th> #</th><th>Zdrojový kód</th><th>Stručný popis souboru</th><th>Cesta</th></tr>
<tr><td> 1</td><td>json2edn.py</td><td>konverze mezi formátem JSON a EDN naprogramovaná v&nbsp;Pythonu</td><td><a href="https://github.com/tisnik/presentations/blob/master/edn/json2edn.py">https://github.com/tisnik/presentations/blob/master/edn/json2edn.py</a></td></tr>
<tr><td> 2</td><td>edn2json.py</td><td>konverze mezi formátem EDN a JSON naprogramovaná v&nbsp;Pythonu</td><td><a href="https://github.com/tisnik/presentations/blob/master/edn/edn2json.py">https://github.com/tisnik/presentations/blob/master/edn/edn2json.py</a></td></tr>
<tr><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td></tr>
<tr><td> 3</td><td>json2edn (adresář)</td><td>konverze mezi formátem JSON a EDN naprogramovaná v&nbsp;Clojure</td><td><a href="https://github.com/tisnik/presentations/blob/master/edn/json2edn">https://github.com/tisnik/presentations/blob/master/edn/json2edn</a></td></tr>
<tr><td> 4</td><td>edn2json (adresář)</td><td>konverze mezi formátem EDN a JSON naprogramovaná v&nbsp;Clojure</td><td><a href="https://github.com/tisnik/presentations/blob/master/edn/edn2json">https://github.com/tisnik/presentations/blob/master/edn/edn2json</a></td></tr>
<tr><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td></tr>
<tr><td> 3</td><td>properties2edn (adresář)</td><td>konverze mezi .properties souborem a formátem EDN (Clojure)</td><td><a href="https://github.com/tisnik/presentations/blob/master/edn/properties2edn">https://github.com/tisnik/presentations/blob/master/edn/properties2edn</a></td></tr>
<tr><td> 4</td><td>xml2edn (adresář)</td><td>konverze mezi XML a formátem EDN (Clojure, plná konverze)</td><td><a href="https://github.com/tisnik/presentations/blob/master/edn/xml2edn">https://github.com/tisnik/presentations/blob/master/edn/xml2edn</a></td></tr>
<tr><td> 5</td><td>forest-demo (adresář)</td><td>různé možnosti konverze mezi XML a formátem EDN</td><td><a href="https://github.com/tisnik/presentations/blob/master/edn/forest-demo">https://github.com/tisnik/presentations/blob/master/edn/forest-demo</a></td></tr>
<tr><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td></tr>
<tr><td> 6</td><td>go-edn-1 (adresář)</td><td>serializace (marshalling) datové struktury do formátu EDN</td><td><a href="https://github.com/tisnik/presentations/blob/master/edn/go-edn-1">https://github.com/tisnik/presentations/blob/master/edn/go-edn-1</a></td></tr>
<tr><td> 7</td><td>go-edn-2 (adresář)</td><td>specifikace názvů klíčů v&nbsp;EDN formátu</td><td><a href="https://github.com/tisnik/presentations/blob/master/edn/go-edn-2">https://github.com/tisnik/presentations/blob/master/edn/go-edn-2</a></td></tr>
<tr><td> 8</td><td>go-edn-3 (adresář)</td><td>uložení pole datových struktur do formátu EDN</td><td><a href="https://github.com/tisnik/presentations/blob/master/edn/go-edn-3">https://github.com/tisnik/presentations/blob/master/edn/go-edn-3</a></td></tr>
<tr><td> 9</td><td>go-edn-4 (adresář)</td><td>uložení mapy datových struktur do formátu EDN</td><td><a href="https://github.com/tisnik/presentations/blob/master/edn/go-edn-4">https://github.com/tisnik/presentations/blob/master/edn/go-edn-4</a></td></tr>
<tr><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td></tr>
<tr><td>10</td><td>go-edn-5 (adresář)</td><td>deserializace (unmarshalling) datové struktury z&nbsp;formátu EDN</td><td><a href="https://github.com/tisnik/presentations/blob/master/edn/go-edn-5">https://github.com/tisnik/presentations/blob/master/edn/go-edn-5</a></td></tr>
</table>



<p><a name="k20"></a></p>
<h2 id="k20">20. Odkazy na Internetu</h2>

<ol>

<li>edn &ndash; extensible data notation<br />
<a href="https://github.com/edn-format/edn">https://github.com/edn-format/edn</a>
</li>

<li>Programming with Data and EDN<br />
<a href="https://docs.datomic.com/cloud/whatis/edn.html">https://docs.datomic.com/cloud/whatis/edn.html</a>
</li>

<li>Video about EDN<br />
<a href="https://docs.datomic.com/cloud/livetutorial/edntutorial.html">https://docs.datomic.com/cloud/livetutorial/edntutorial.html</a>
</li>

<li>(Same) video about EDN on Youtube<br />
<a href="https://www.youtube.com/watch?v=5eKgRcvEJxU">https://www.youtube.com/watch?v=5eKgRcvEJxU</a>
</li>

<li>clojure.edn<br />
<a href="https://clojuredocs.org/clojure.edn">https://clojuredocs.org/clojure.edn</a>
</li>

<li>API for clojure.edn - Clojure v1.10.2 (stable)<br />
<a href="https://clojure.github.io/clojure/clojure.edn-api.html">https://clojure.github.io/clojure/clojure.edn-api.html</a>
</li>

<li>Clojure EDN Walkthrough<br />
<a href="https://www.compoundtheory.com/clojure-edn-walkthrough/">https://www.compoundtheory.com/clojure-edn-walkthrough/</a>
</li>

<li>Články týkající se Pythonu na Rootu<br />
<a href="https://www.root.cz/n/python/">https://www.root.cz/n/python/</a>
</li>

<li>Články týkající se programovacího jazyka Clojure na Rootu<br />
<a href="https://www.root.cz/n/clojure/">https://www.root.cz/n/clojure/</a>
</li>

<li>Seriál Programovací jazyk Go<br />
<a href="https://www.root.cz/serialy/programovaci-jazyk-go/">https://www.root.cz/serialy/programovaci-jazyk-go/</a>
</li>

<li>Crux<br />
<a href="https://opencrux.com/main/index.html">https://opencrux.com/main/index.html</a>
</li>

<li>Crux Installation<br />
<a href="https://opencrux.com/reference/21.04-1.16.0/installation.html">https://opencrux.com/reference/21.04-1.16.0/installation.html</a>
</li>

<li>read<br />
<a href="https://clojuredocs.org/clojure.edn/read">https://clojuredocs.org/clojure.edn/read</a>
</li>

<li>read-string<br />
<a href="https://clojuredocs.org/clojure.edn/read-string">https://clojuredocs.org/clojure.edn/read-string</a>
</li>

<li>Tupelo 21.04.12 (dokumentace)<br />
<a href="https://cloojure.github.io/doc/tupelo/">https://cloojure.github.io/doc/tupelo/</a>
</li>

<li>tupelo - Clojure With A Spoonful of Honey<br />
<a href="https://clojars.org/tupelo">https://clojars.org/tupelo</a>
</li>

<li>Clojure Cookbook: Templating HTML with Enlive<br />
<a href="https://github.com/clojure-cookbook/clojure-cookbook/blob/master/07_webapps/7-11_enlive.asciidoc">https://github.com/clojure-cookbook/clojure-cookbook/blob/master/07_webapps/7-11_enlive.asciidoc</a>
</li>

<li>An Introduction to Enlive<br />
<a href="https://github.com/swannodette/enlive-tutorial/">https://github.com/swannodette/enlive-tutorial/</a>
</li>

<li>Enlive na GitHubu<br />
<a href="https://github.com/cgrand/enlive">https://github.com/cgrand/enlive</a>
</li>

<li>data.json<br />
<a href="https://github.com/clojure/data.json">https://github.com/clojure/data.json</a>
</li>

<li>data.json API reference<br />
<a href="https://clojure.github.io/data.json/">https://clojure.github.io/data.json/</a>
</li>

<li>Clojure: Writing JSON to a File/Reading JSON From a File<br />
<a href="https://dzone.com/articles/clojure-writing-json">https://dzone.com/articles/clojure-writing-json</a>
</li>

<li>How to pretty print JSON to a file in Clojure?<br />
<a href="https://stackoverflow.com/questions/23307552/how-to-pretty-print-json-to-a-file-in-clojure">https://stackoverflow.com/questions/23307552/how-to-pretty-print-json-to-a-file-in-clojure</a>
</li>

<li>go-edn / edn<br />
<a href="https://github.com/go-edn/edn">https://github.com/go-edn/edn</a>
</li>

<li>Queries (Crux)<br />
<a href="https://opencrux.com/reference/21.04-1.16.0/queries.html">https://opencrux.com/reference/21.04-1.16.0/queries.html</a>
</li>

<li>Essential EDN<br />
<a href="https://opencrux.com/tutorials/essential-edn.html">https://opencrux.com/tutorials/essential-edn.html</a>
</li>

<li>Babashka: interpret Clojure určený pro rychlé spouštění utilit z příkazového řádku<br />
<a href="https://www.root.cz/clanky/babashka-interpret-clojure-urceny-pro-rychle-spousteni-utilit-z-prikazoveho-radku/">https://www.root.cz/clanky/babashka-interpret-clojure-urceny-pro-rychle-spousteni-utilit-z-prikazoveho-radku/</a>
</li>

<li>Introducing JSON<br />
<a href="https://www.json.org/json-en.html">https://www.json.org/json-en.html</a>
</li>

<li>ISO 8601<br />
<a href="https://xkcd.com/1179/">https://xkcd.com/1179/</a>
</li>

<li>What is the right JSON date format<br />
<a href="https://stackoverflow.com/questions/10286204/what-is-the-right-json-date-format">https://stackoverflow.com/questions/10286204/what-is-the-right-json-date-format</a>
</li>

</ol>



<p></p><p></p>
<p><small>Autor: <a href="http://www.fit.vutbr.cz/~tisnovpa">Pavel Tišnovský</a> &nbsp; 2021</small></p>
</body>
</html>

