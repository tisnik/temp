<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
        "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html>
<head>
<title>Leiningen: nástroj pro správu projektů napsaných v Clojure (5)</title>
<meta name="Author" content="Pavel Tisnovsky" />
<meta name="Generator" content="vim" />
<meta http-equiv="content-type" content="text/html; charset=utf-8" />
<style type="text/css">
         body {color:#000000; background:#ffffff;}
         h1  {font-family: arial, helvetica, sans-serif; color:#ffffff; background-color:#c00000; text-align:center; padding-left:1em}
         h2  {font-family: arial, helvetica, sans-serif; color:#ffffff; background-color:#0000c0; padding-left:1em; text-align:left}
         h3  {font-family: arial, helvetica, sans-serif; color:#000000; background-color:#c0c0c0; padding-left:1em; text-align:left}
         h4  {font-family: arial, helvetica, sans-serif; color:#000000; background-color:#e0e0e0; padding-left:1em; text-align:left}
         a   {font-family: arial, helvetica, sans-serif;}
         li  {font-family: arial, helvetica, sans-serif; color:#000000; text-align:justify; width:450px;}
         ol  {font-family: arial, helvetica, sans-serif; color:#000000; text-align:justify; width:450px;}
         ul  {font-family: arial, helvetica, sans-serif; color:#000000; text-align:justify; width:450px;}
         p   {font-family: arial, helvetica, sans-serif; color:#000000; text-align:justify;}
         pre {background:#e0e0e0}
</style>
</head>

<body>

<h1>Leiningen: nástroj pro správu projektů napsaných v Clojure (5)</h1>

<h3>Pavel Tišnovský</h3>

<p></p>

<h1>Úvodník</h1>

<p>I v páté části článku o nástroji Leiningen určeného pro správu projektů vytvořených v programovacím jazyku Clojure se budeme zabývat tvorbou jednoduchých webových aplikací s využitím knihovny Ring. Ukážeme se použití tří typů middleware nazvaných wrap-params, wrap-session a wrap-cookies.</p>



<h2>Obsah</h2>

<p><a href="#k01">1. Leiningen: nástroj pro správu projektů napsaných v Clojure (5)</a></p>
<p><a href="#k02">2. První demonstrační příklad &ndash; webová aplikace s&nbsp;jednoduchým handlerem</a></p>
<p><a href="#k03">3. Zpracování parametrů požadavku</a></p>
<p><a href="#k04">4. Druhý demonstrační příklad &ndash; použití <strong>ring.middleware.params/wrap-params</strong></a></p>
<p><a href="#k05">5. Práce se session</a></p>
<p><a href="#k06">6. Třetí demonstrační příklad &ndash; použití <strong>ring.middleware.session/wrap-session</strong></a></p>
<p><a href="#k07">7. Implementace čítače uloženého v&nbsp;session</a></p>
<p><a href="#k08">8. Čtvrtý demonstrační příklad &ndash; uložení hodnoty čítače do session</a></p>
<p><a href="#k09">9. Pátý demonstrační příklad &ndash; uložení hodnoty čítače do session (zjednodušená varianta)</a></p>
<p><a href="#k10">10. Šestý demonstrační příklad &ndash; zobrazení hodnoty čítače na WWW stránce</a></p>
<p><a href="#k11">11. Základy práce s&nbsp;cookies</a></p>
<p><a href="#k12">12. Sedmý demonstrační příklad &ndash; použití <strong>ring.middleware.cookies/wrap-cookies</strong></a></p>
<p><a href="#k13">13. Přečtení hodnoty z&nbsp;cookie a nastavení nové hodnoty</a></p>
<p><a href="#k14">14. Odkazy na Internetu</a></p>



<p><a name="k01"></a></p>
<h2 id="k01">1. Leiningen: nástroj pro správu projektů napsaných v Clojure (5)</h2>

<p><a
href="http://www.root.cz/clanky/leiningen-nastroj-pro-spravu-projektu-napsanych-v-clojure-4/">Ve
čtvrté části článku o nástroji Leiningen</a> jsme si popsali některé základní
koncepty, na níž je postavena knihovna <i>Clojure Ring</i>, kterou je možné
využít pro tvorbu jednodušších i složitějších webových aplikací
v&nbsp;programovacím jazyku <i>Clojure</i>. Připomeňme si, že tato knihovna je
abstrakcí mezi webovým kontejnerem (kterým je typicky <i>Jetty</i> či
<i>Tomcat</i>) a aplikační logikou. Základem knihovny <i>Clojure Ring</i> je
takzvaný handler, což je funkce zavolaná ve chvíli příchodu HTTP požadavku od
klienta. Handler musí zajistit vytvoření HTTP odpovědi, přičemž je Ring
postaven do značné míry na základních principech funkcionálního programování:
handler dostane jako parametr neměnnou (<i>immutable</i>) mapu představující
požadavek klienta (<i>request</i>) a výsledkem jeho práce je jiná neměnná mapa
reprezentující odpověď serveru (<i>response</i>). Handler lze tedy snadno
testovat, rozšiřovat apod.</p>

<p>Webová aplikace využívající knihovnu <i>Ring</i> může být
v&nbsp;nejjednodušším případě složena pouze ze tří vrstev:</p>

<ol>
<li>Aplikační logika</li>
<li>Ring Adapter</li>
<li>Webový server/servlet kontejner/vestavěný kontejner</li>
</ol>

<p>Navíc se ještě v&nbsp;knihovně <i>Clojure Ring</i> objevuje další zajímavý
koncept. Jedná se o takzvané <i>middleware</i>, což jsou v&nbsp;pojetí
<i>Ringu</i> makra a funkce vkládané mezi Ring a vlastní implementaci webové
aplikace. Tyto funkce a makra tedy například mohou z&nbsp;původní mapy
s&nbsp;požadavkem vytvořit novou mapu, v&nbsp;níž již budou předpřipraveny
parametry požadavku, cookies, objekty uložené na session atd. My si
v&nbsp;dnešním článku popíšeme trojici již připravených middleware:</p>

<table>
<tr><td>ring.middleware.params/wrap-params</td></tr>
<tr><td>ring.middleware.session/wrap-session</td></tr>
<tr><td>ring.middleware.cookies/wrap-cookies</td></tr>
</table>



<p><a name="k02"></a></p>
<h2 id="k02">2. První demonstrační příklad &ndash; webová aplikace s&nbsp;jednoduchým handlerem</h2>

<p>Dnešní první demonstrační příklad vznikl nepatrnou úpravou příkladů, které
jsme si již popsali v&nbsp;předchozí části tohoto článku. Tento příklad uvádím
zejména z&nbsp;toho důvodu, že na jeho zdrojovém kódu bude postaveno i šest
ostatních demonstračních příkladů, takže si v&nbsp;dalších kapitolách již
nebudeme popisovat tvorbu základní kostry webové aplikace, její spuštění apod.
Vytvoření nového projektu nám zajistí notoricky známý příkaz:</p>

<pre>
lein new app webapp5
</pre>

<p>Následně upravíme soubor <strong>project.clj</strong> takovým způsobem, aby
se projekt odkazoval na všechny potřebné moduly knihovny <i>Clojure Ring</i>
(zvýrazněné řádky):</p>

<pre>
(defproject webapp3 "0.1.0-SNAPSHOT"
  :description "FIXME: write description"
  :url "http://example.com/FIXME"
  :license {:name "Eclipse Public License"
            :url "http://www.eclipse.org/legal/epl-v10.html"}
  :dependencies [[org.clojure/clojure "1.6.0"]
                 <strong>[ring/ring-core "1.3.2"]</strong>
                 <strong>[ring/ring-jetty-adapter "1.3.2"]</strong>]
  :main ^:skip-aot webapp3.core
  :target-path "target/%s"
  :profiles {:uberjar {:aot :all}})
</pre>

<p>Změní se samozřejmě i soubor <strong>src/webapp5/core.clj</strong>, a to
následujícím způsobem:</p>

<pre>
(ns <strong>webapp6.core</strong>
    (:gen-class))
&nbsp;
(require '[ring.adapter.jetty     :as jetty])
(require '[ring.util.response     :as response])
&nbsp;
(def <strong>html-page</strong>
"    &lt;html&gt;
         &lt;head&gt;
             &lt;title&gt;Powered by Ring!&lt;/title&gt;
         &lt;/head&gt;
         &lt;body&gt;
             &lt;h1&gt;Powered by Ring!&lt;/h1&gt;
         &lt;/body&gt;
     &lt;/html&gt;
")
&nbsp;
(defn <strong>handler</strong>
    <i>"Zpracovani pozadavku."</i>
    [request]
    (-&gt; (response/response html-page)
        (response/content-type "text/html; charset=utf-8")))
&nbsp;
(def <strong>app</strong>
    <i>"Datova struktura predstavujici kostru webove aplikace."</i>
    (-&gt; handler))
&nbsp;
(defn <strong>-main</strong>
    <i>"Spusteni webove aplikace na portu 8080."</i>
    [&amp; args]
    (jetty/run-jetty app {:port 8080}))
</pre>

<p>Ve zdrojovém textu vidíme definice čtyř symbolů:</p>

<table>
<tr><th>#</th><th>Symbol</th><th>Význam</th></tr>
<tr><td>1</td><td>html-page</td><td>navázaný na řetězec představující HTML stránku poslanou klientovi</td></tr>
<tr><td>2</td><td>handler</td><td>navázaný na funkci reprezentující handler pro zpracování požadavku</td></tr>
<tr><td>3</td><td>app</td><td>datová struktura představující kostru webové aplikace</td></tr>
<tr><td>4</td><td>-main</td><td>navázaný na funkci spuštěnou nástrojem Leiningen</td></tr>
</table>

<p>Aplikaci si můžeme jednoduše otestovat:</p>

<pre>
lein run
</pre>

<p>Následně se k&nbsp;aplikaci připojíme z&nbsp;CLI klienta:</p>

<pre>
curl -v localhost:8080
</pre>

<pre>
* Rebuilt URL to: localhost:8080/
* Hostname was NOT found in DNS cache
*   Trying 127.0.0.1...
* Connected to localhost (127.0.0.1) port 8080 (#0)
&gt; GET / HTTP/1.1
&gt; User-Agent: curl/7.35.0
&gt; Host: localhost:8080
&gt; Accept: */*
&gt; 
&lt; HTTP/1.1 200 OK
&lt; Date: Tue, 10 Mar 2015 17:34:31 GMT
&lt; Content-Type: text/html;charset=UTF-8
&lt; Content-Length: 174
* Server Jetty(7.6.13.v20130916) is not blacklisted
&lt; Server: Jetty(7.6.13.v20130916)
&lt; 
    &lt;html&gt;
         &lt;head&gt;
             &lt;title&gt;Powered by Ring!&lt;/title&gt;
         &lt;/head&gt;
         &lt;body&gt;
             &lt;h1&gt;Powered by Ring!&lt;/h1&gt;
         &lt;/body&gt;
     &lt;/html&gt;
* Connection #0 to host localhost left intact
</pre>



<p><a name="k03"></a></p>
<h2 id="k03">3. Zpracování parametrů požadavku</h2>

<p>Jednou ze základních funkcí prakticky každého webového serveru je rozpoznání
a zpracování parametrů požadavků, které server přijme od klienta. Připomeňme
si, že protokol HTTP rozlišuje několik možností, jak pametry serveru přidat:
buď je možné parametry zakódovat přímo do <a
href="https://en.wikipedia.org/wiki/Uniform_Resource_Locator">URL</a> (metoda
<strong>GET</strong>) nebo je alternativně možné parametry předat v&nbsp;těle
požadavku (metoda <strong>POST</strong>). Aby bylo možné parametry získat a
zpracovat nezávisle na použité metodě, lze v&nbsp;případě knihovny <i>Clojure
Ring</i> použít middleware <strong>ring.middleware.params/wrap-params</strong>.
Tento middleware zajistí vytvoření mapy obsahující původní požadavek
(<i>request</i>) i již zpracované parametry. Datová struktura, kterou je
definována kostra webové aplikace, bude vypadat následovně:</p>

<pre>
(def <strong>app</strong>
    <i>"Datova struktura predstavujici kostru webove aplikace."</i>
    (-&gt; handler
        ring.middleware.params/wrap-params))
</pre>

<p>Makro <strong>-&gt;</strong> zajišťuje především lepší čitelnost
s&nbsp;menším množstvím závorek. Namísto tohoto makra by bylo možné provést i
tento zápis:</p>

<pre>
(def <strong>app</strong>
    <i>"Datova struktura predstavujici kostru webove aplikace."</i>
    (ring.middleware.params/wrap-params handler))
</pre>

<p>To se však se zvyšujícím se počtem middleware stává méně srozumitelné.</p>



<p><a name="k04"></a></p>
<h2 id="k04">4. Druhý demonstrační příklad &ndash; použití <strong>ring.middleware.params/wrap-params</strong></h2>

<p>Podívejme se nyní na postup úpravy dnešního prvního demontračního příkladu
takovým způsobem, aby se mohly jednoduše zpracovávat parametry požadavku
(requestu). První úprava spočívá v&nbsp;odlišné deklaraci <strong>app</strong>,
což již bylo naznačeno v&nbsp;předchozí kapitole (pouze se použije zkrácené
jméno díky importu a vytvoření aliasu):</p>

<pre>
(def <strong>app</strong>
    <i>"Datova struktura predstavujici kostru webove aplikace."</i>
    (-&gt; handler
        http-params/wrap-params))
</pre>

<p>Dále se v&nbsp;handleru přečtou parametry uložené pod klíčem
<strong>:params</strong>. Následně se celá struktura nesoucí informace o všech
parametrech jednoduše vytiskne na standardní výstup:</p>

<pre>
(defn <strong>handler</strong>
    <i>"Zpracovani pozadavku."</i>
    [request]
    (let [params (:params request)]
        (println "Params: " params))
    (-&gt; (response/response html-page)
        (response/content-type "text/html; charset=utf-8")))
</pre>

<p>Následuje výpis zdrojového kódu celého dnešního druhého demonstračního
příkladu:</p>

<pre>
(ns <strong>webapp7.core</strong>
    (:gen-class))
&nbsp;
(require '[ring.adapter.jetty     :as jetty])
(require '[ring.middleware.params :as http-params])
(require '[ring.util.response     :as response])
&nbsp;
(def <strong>html-page</strong>
"    &lt;html&gt;
         &lt;head&gt;
             &lt;title&gt;Powered by Ring!&lt;/title&gt;
         &lt;/head&gt;
         &lt;body&gt;
             &lt;h1&gt;Powered by Ring!&lt;/h1&gt;
         &lt;/body&gt;
     &lt;/html&gt;
")
&nbsp;
(defn <strong>handler</strong>
    <i>"Zpracovani pozadavku."</i>
    [request]
    (let [params (:params request)]
        (println "Params: " params))
    (-&gt; (response/response html-page)
        (response/content-type "text/html; charset=utf-8")))
&nbsp;
(def <strong>app</strong>
    <i>"Datova struktura predstavujici kostru webove aplikace."</i>
    (-&gt; handler
        http-params/wrap-params))
&nbsp;
(defn <strong>-main</strong>
    <i>"Spusteni webove aplikace na portu 8080."</i>
    [&amp; args]
    (jetty/run-jetty app {:port 8080}))
</pre>

<p>Opět můžeme provést několik testů. V&nbsp;následujících výpisech je nejdříve
zobrazen požadavek od CLI klienta a na dalších řádcích pak text vypsaný
serverem/webovou aplikací (klient se samozřejmě spouští z&nbsp;jiného
terminálu):</p>

<pre>
curl "localhost:8080"
&nbsp;
Params:  {}
</pre>

<pre>
curl "localhost:8080?param1=Hello&amp;param2=World"
&nbsp;
Params:  {param1 Hello, param2 World}
</pre>

<pre>
curl localhost:8080?message="Message%20with%20spaces"
&nbsp;
Params:  {message Message with spaces}
</pre>



<p><a name="k05"></a></p>
<h2 id="k05">5. Práce se session</h2>

<p>Zpracování parametrů požadavku je poměrně triviální, ovšem zajímavější je
již práce se <i>session</i>. Knihovna <i>Clojure Ring</i> samozřejmě obsahuje
možnost ukládat stav (libovolné objekty) na session a při dalším požadavku tyto
objekty opět získat, ovšem musíme mít na paměti, že mapa představující session
je neměnná (<i>immutable</i>), což může být především zpočátku poněkud matoucí.
Pokud potřebujeme pracovat se session, lze použít middleware
<strong>ring.middleware.session/wrap-session</strong>, který upraví původní
mapu s&nbsp;daty požadavku takovým způsobem, že nová mapa bude obsahovat i klíč
<strong>:session</strong>, na nějž je navázána mapa s&nbsp;objekty uloženými
v&nbsp;sezení. Nově upravený handler může vypadat následovně:</p>

<pre>
(def <strong>app</strong>
    <i>"Datova struktura predstavujici kostru webove aplikace."</i>
    (-&gt; handler
        ring.middleware.session/wrap-session
        ring.middleware.params/wrap-params))
</pre>

<p>(zde se již ukazuje přednost použití makra -&gt;)</p>



<p><a name="k06"></a></p>
<h2 id="k06">6. Třetí demonstrační příklad &ndash; použití <strong>ring.middleware.session/wrap-session</strong></h2>

<p>V&nbsp;dnešním třetím demonstračním příkladu je ukázán základní způsob práce
se session. Datová struktura <strong>app</strong> je upravena způsobem popsaným
v&nbsp;předchozí kapitole, takže si ji již nemusíme znovu uvádět. Pokud je
skutečně aplikován middleware
<strong>ring.middleware.session/wrap-session</strong>, obsahuje nově vytvořená
mapa <i>request</i> i klíč <strong>:session</strong> navázaný na další mapu, ve
které mohou (ale nemusí) být uloženy libovolné objekty. Následuje výpis úplného
zdrojového kódu dnešního třetího demonstračního příkladu:</p>

<pre>
(ns <strong>webapp8.core</strong>
    (:gen-class))
&nbsp;
(require '[ring.adapter.jetty      :as jetty])
(require '[ring.middleware.params  :as http-params])
(require '[ring.middleware.session :as http-session])
(require '[ring.util.response      :as response])
&nbsp;
(def <strong>html-page</strong>
"    &lt;html&gt;
         &lt;head&gt;
             &lt;title&gt;Powered by Ring!&lt;/title&gt;
         &lt;/head&gt;
         &lt;body&gt;
             &lt;h1&gt;Powered by Ring!&lt;/h1&gt;
         &lt;/body&gt;
     &lt;/html&gt;
")
&nbsp;
(defn <strong>handler</strong>
    <i>"Zpracovani pozadavku."</i>
    [request]
    (let [params  (:params request)
          session (:session request)]
        (println "Params:  " params)
        (println "Session: " session))
    (-&gt; (response/response html-page)
        (response/content-type "text/html; charset=utf-8")))
&nbsp;
(def <strong>app</strong>
    <i>"Datova struktura predstavujici kostru webove aplikace."</i>
    (-&gt; handler
        http-session/wrap-session
        http-params/wrap-params))
&nbsp;
(defn <strong>-main</strong>
    <i>"Spusteni webove aplikace na portu 8080."</i>
    [&amp; args]
    (jetty/run-jetty app {:port 8080}))
</pre>

<p>Aplikaci si můžeme otestovat:</p>

<pre>
lein run
&nbsp;
2015-03-10 19:07:15.369:INFO:oejs.Server:jetty-7.6.13.v20130916
2015-03-10 19:07:15.405:INFO:oejs.AbstractConnector:Started SelectChannelConnector@0.0.0.0:8080
</pre>

<pre>
wget localhost:8080
&nbsp;
Params:   {}
Session:  {}
</pre>



<p><a name="k07"></a></p>
<h2 id="k07">7. Implementace čítače uloženého v&nbsp;session</h2>

<p>Nyní se již konečně dostáváme k&nbsp;praktickému příkladu. Bude se jednat o
jednoduchou webovou aplikaci, která bude mít na session uložený čítač. Pokud
klient bude aplikaci posílat více požadavků, bude se čítač zvyšovat o jedničku.
Jak lze však tohoto chování dosáhnout? Základem je, že v&nbsp;odpovědi
(<i>response</i>), což je běžná mapa, musí být obsažen i klíč
<strong>:session</strong> navázaný na další pod-mapu, v&nbsp;níž jsou uloženy
jednotlivé objekty, které se mají na session zachovat pro další požadavek.
Stačí tedy upravit odpověď (vracenou handlerem) následujícím způsobem:</p>

<pre>
    (-&gt; (response/response html-page)
           (response/content-type "text/html; charset=utf-8")
           (assoc :session new-session)))))
</pre>

<p>Připomeňme si, že funkce <strong>assoc</strong> vezme svůj první parametr
(což musí být mapa) a vrátí novou mapu, která obsahuje jak mapu původní, tak i
novou dvojici klíč-hodnota (druhý a třetí parametr). Z&nbsp;výše uvedeného
zápisu by se mohlo zdát, že <strong>assoc</strong> voláme jen se dvěma
parametry, ve skutečnosti to však není pravda, protože je celé volání uzavřeno
v&nbsp;makru -&gt; (je skutečně dobré si chování tohoto makra nastudovat a
důsledně ho používat :-). Výše uvedený zápis tedy vede k&nbsp;pouhému přidání
nové dvojice <strong>:session+new_session</strong> do mapy reprezentující
odpověď serveru (<i>response</i>).</p>

<p>Poznámka: dokumentace k&nbsp;funkci <strong>assoc</strong>:</p>

<pre>
user=&gt; (doc assoc)
-------------------------
clojure.core/assoc
([map key val] [map key val &amp; kvs])
  assoc[iate]. When applied to a map, returns a new map of the
    same (hashed/sorted) type, that contains the mapping of key(s) to
    val(s). When applied to a vector, returns a new vector that
    contains val at index. Note - index must be &lt;= (count vector).
</pre>



<p><a name="k08"></a></p>
<h2 id="k08">8. Čtvrtý demonstrační příklad &ndash; uložení hodnoty čítače do session</h2>

<p>Se znalostí toho, jak se čte původní session i jak se nová session přidává
do odpovědi serveru (<i>response</i>), již můžeme v&nbsp;handleru realizovat
jednoduchý čítač:</p>

<pre>
(defn <strong>handler</strong>
    <i>"Zpracovani pozadavku."</i>
    [request]
    (let [params      (:params  request)
          old-session (:session request)
          counter     (:counter old-session 0)]
        (println "Params:      " params)
        (println "Old session: " old-session)
        (println "Counter:     " counter)
        (let [new-session (assoc old-session :counter (inc counter))]
            (println "New session: " new-session)
            (-&gt; (response/response html-page)
                (response/content-type "text/html; charset=utf-8")
                (assoc :session new-session)))))
</pre>

<p>Stručný popis funkce handleru:</p>

<ol>
<li>Získají se parametry požadavku a uloží se do lokální proměnné <strong>params</strong>.</li>
<li>Získá se session požadavku a uloží se do lokální proměnné <strong>old-session</strong>.</li>
<li>Získá se hodnota čítače (pokud neexistuje tak 0) ze session a uloží se do proměnné <strong>counter</strong>.</li>
<li>Všechny tři údaje se vytisknou na standardní výstup.</li>
<li>Vytvoří se proměnná <strong>new-session</strong> obsahující v&nbsp;prvku :counter novou hodnotu čítače.</li>
<li>Nová session se vytiskne na standardní výstup.</li>
<li>Vygeneruje se mapa obsahující odpověď serveru (<i>response</i>).</li>
</ol>

<p>Následuje výpis celého zdrojového kódu demontračního příkladu:</p>

<pre>
(ns <strong>webapp9.core</strong>
    (:gen-class))
&nbsp;
(require '[ring.adapter.jetty      :as jetty])
(require '[ring.middleware.params  :as http-params])
(require '[ring.middleware.session :as http-session])
(require '[ring.util.response      :as response])
&nbsp;
(def <strong>html-page</strong>
"    &lt;html&gt;
         &lt;head&gt;
             &lt;title&gt;Powered by Ring!&lt;/title&gt;
         &lt;/head&gt;
         &lt;body&gt;
             &lt;h1&gt;Powered by Ring!&lt;/h1&gt;
         &lt;/body&gt;
     &lt;/html&gt;
")
&nbsp;
(defn <strong>handler</strong>
    <i>"Zpracovani pozadavku."</i>
    [request]
    (let [params      (:params  request)
          old-session (:session request)
          counter     (:counter old-session 0)]
        (println "Params:      " params)
        (println "Old session: " old-session)
        (println "Counter:     " counter)
        (let [new-session (assoc old-session :counter (inc counter))]
            (println "New session: " new-session)
            (-&gt; (response/response html-page)
                (response/content-type "text/html; charset=utf-8")
                (assoc :session new-session)))))
&nbsp;
(def <strong>app</strong>
    <i>"Datova struktura predstavujici kostru webove aplikace."</i>
    (-&gt; handler
        http-session/wrap-session
        http-params/wrap-params))
&nbsp;
(defn <strong>-main</strong>
    <i>"Spusteni webove aplikace na portu 8080."</i>
    [&amp; args]
    (jetty/run-jetty app {:port 8080}))
</pre>

<p>Opět si můžeme aplikaci otestovat a to otevřením stránky z&nbsp;adresy
<i>localhost:8080</i> v&nbsp;prohlížeči a několikerým stlačením F5/Reload.
Webová aplikace by měla na standardní výstup vypsat následující zprávy:</p>

<pre>
lein run
&nbsp;
2015-03-10 19:33:34.809:INFO:oejs.Server:jetty-7.6.13.v20130916
2015-03-10 19:33:34.845:INFO:oejs.AbstractConnector:Started SelectChannelConnector@0.0.0.0:8080
</pre>

<pre>
Params:       {}
Old session:  {}
Counter:      0
New session:  {:counter 1}
&nbsp;
Params:       {}
Old session:  {:counter 1}
Counter:      1
New session:  {:counter 2}
&nbsp;
Params:       {}
Old session:  {:counter 2}
Counter:      2
New session:  {:counter 3}
&nbsp;
Params:       {}
Old session:  {:counter 3}
Counter:      3
New session:  {:counter 4}
&nbsp;
Params:       {}
Old session:  {:counter 4}
Counter:      4
New session:  {:counter 5}
&nbsp;
Params:       {}
Old session:  {:counter 5}
Counter:      5
New session:  {:counter 6}
</pre>

<p>Vidíme, že skutečně vše pracuje korektně.</p>



<p><a name="k09"></a></p>
<h2 id="k09">9. Pátý demonstrační příklad &ndash; uložení hodnoty čítače do session (zjednodušená varianta)</h2>

<p>V&nbsp;předchozím demonstračním příkladu jsme vytvářeli novou mapu se
session, která se ukládala do nové lokální proměnné (přesněji řečeno se
navázala na lokální symbol). To však ve skutečnosti není nutné, protože novou
session lze jednoduše vytvořit ze session staré na jediném řádku, což je patrné
z&nbsp;následujícího úryvku kódu:</p>

<pre>
...
...
...
(-&gt; (response/response html-page)
    (response/content-type "text/html; charset=utf-8")
    (assoc :session {:counter (inc counter)}))))
</pre>

<p>Přičemž hodnotu navázanou na lokální symbol <strong>counter</strong>
přečteme z&nbsp;původní session (a když hodnota neexistuje, inicializuje se
čítač na nulu):</p>

<pre>
(let [session     (:session request)
      counter     (:counter session 0)]
...
...
...
</pre>

<p>Úplný zdrojový kód dnešního pátého demonstračního příkladu je nepatrně
kratší než kód předchozí:</p>

<pre>
(ns <strong>webapp10.core</strong>
    (:gen-class))
&nbsp;
(require '[ring.adapter.jetty      :as jetty])
(require '[ring.middleware.params  :as http-params])
(require '[ring.middleware.session :as http-session])
(require '[ring.util.response      :as response])
&nbsp;
(def <strong>html-page</strong>
"    &lt;html&gt;
         &lt;head&gt;
             &lt;title&gt;Powered by Ring!&lt;/title&gt;
         &lt;/head&gt;
         &lt;body&gt;
             &lt;h1&gt;Powered by Ring!&lt;/h1&gt;
         &lt;/body&gt;
     &lt;/html&gt;
")
&nbsp;
(defn <strong>handler</strong>
    <i>"Zpracovani pozadavku."</i>
    [request]
    (let [params      (:params  request)
          session     (:session request)
          counter     (:counter session 0)]
        (println "Params:  " params)
        (println "Session: " session)
        (println "Counter: " counter)
        (-&gt; (response/response html-page)
            (response/content-type "text/html; charset=utf-8")
            (assoc :session {:counter (inc counter)}))))
&nbsp;
(def <strong>app</strong>
    <i>"Datova struktra predstavujici kostru webove aplikace."</i>
    (-&gt; handler
        http-session/wrap-session
        http-params/wrap-params))
&nbsp;
(defn <strong>-main</strong>
    <i>"Spusteni webove aplikace na portu 8080."</i>
    [&amp; args]
    (jetty/run-jetty app {:port 8080}))
</pre>

<p>Kontrola korektnosti aplikace otevřením stránky <i>localhost:8080</i> a
několikerým stlačením F5/Reload:</p>

<pre>
lein run
&nbsp;
2015-03-10 19:58:00.456:INFO:oejs.Server:jetty-7.6.13.v20130916
2015-03-10 19:58:00.488:INFO:oejs.AbstractConnector:Started SelectChannelConnector@0.0.0.0:8080
</pre>

<pre>
Params:   {}
Session:  {}
Counter:  0
&nbsp;
Params:   {}
Session:  {:counter 1}
Counter:  1
&nbsp;
Params:   {}
Session:  {:counter 2}
Counter:  2
&nbsp;
Params:   {}
Session:  {:counter 3}
Counter:  3
&nbsp;
Params:   {}
Session:  {:counter 4}
Counter:  4
</pre>

<p>(výstup je nepatrně odlišný, protože již nemáme k&nbsp;dispozici původní i
novou mapu session).</p>



<p><a name="k10"></a></p>
<h2 id="k10">10. Šestý demonstrační příklad &ndash; zobrazení hodnoty čítače na WWW stránce</h2>

<p>V&nbsp;šestém (již předposledním) demonstračním příkladu je ukázáno, jak lze
hodnotu čítače jednoduše zobrazit přímo na HTML stránce. Úprava předchozího
demonstračního příkladu je vlastně pouze minimální &ndash; namísto řetězce
navázaného na symbol <strong>html-page</strong> se použije funkce
<strong>create-html-page</strong>, které se předá hodnota čítače. Povšimněte si
použití univerzální funkce <strong>str</strong>, která relativně čitelným
způsobem dokáže spojit řetězcové literály s&nbsp;hodnotou čítače:</p>

<pre>
(defn <strong>create-html-page</strong>
    <i>"Vygenerovani HTML stranky."</i>
    [counter]
    (str
"    &lt;html&gt;
         &lt;head&gt;
             &lt;title&gt;Powered by Ring!&lt;/title&gt;
         &lt;/head&gt;
         &lt;body&gt;
             &lt;h1&gt;Powered by Ring!&lt;/h1&gt;
             &lt;p&gt;Counter: " counter "&lt;/p&gt;
         &lt;/body&gt;
     &lt;/html&gt;
"))
</pre>

<p>Samotný handler je upraven pouze na jediném (zvýrazněném) řádku:</p>

<pre>
(defn <strong>handler</strong>
    <i>"Zpracovani pozadavku."</i>
    [request]
    (let [params      (:params  request)
          session     (:session request)
          counter     (:counter session 0)]
        (println "Params:  " params)
        (println "Session: " session)
        (println "Counter: " counter)
        (-&gt; <strong>(response/response (create-html-page counter)</strong>)
            (response/content-type "text/html; charset=utf-8")
            (assoc :session {:counter (inc counter)}))))
</pre>

<p>Opět si uveďme úplný zdrojový kód šestého demonstračního příkladu:</p>

<pre>
(ns <strong>webapp11.core</strong>
    (:gen-class))
&nbsp;
(require '[ring.adapter.jetty      :as jetty])
(require '[ring.middleware.params  :as http-params])
(require '[ring.middleware.session :as http-session])
(require '[ring.util.response      :as response])
&nbsp;
(defn <strong>create-html-page</strong>
    <i>"Vygenerovani HTML stranky."</i>
    [counter]
    (str
"    &lt;html&gt;
         &lt;head&gt;
             &lt;title&gt;Powered by Ring!&lt;/title&gt;
         &lt;/head&gt;
         &lt;body&gt;
             &lt;h1&gt;Powered by Ring!&lt;/h1&gt;
             &lt;p&gt;Counter: " counter "&lt;/p&gt;
         &lt;/body&gt;
     &lt;/html&gt;
"))
&nbsp;
(defn <strong>handler</strong>
    <i>"Zpracovani pozadavku."</i>
    [request]
    (let [params      (:params  request)
          session     (:session request)
          counter     (:counter session 0)]
        (println "Params:  " params)
        (println "Session: " session)
        (println "Counter: " counter)
        (-&gt; (response/response (create-html-page counter))
            (response/content-type "text/html; charset=utf-8")
            (assoc :session {:counter (inc counter)}))))
&nbsp;
(def <strong>app</strong>
    <i>"Datova struktra predstavujici kostru webove aplikace."</i>
    (-&gt; handler
        http-session/wrap-session
        http-params/wrap-params))
&nbsp;
(defn <strong>-main</strong>
    <i>"Spusteni webove aplikace na portu 8080."</i>
    [&amp; args]
    (jetty/run-jetty app {:port 8080}))
</pre>

<img src="http://i.iinfo.cz/images/70/s0.png" class="image-200395" alt="&#160;" height="372" width="538" />
<p><i>Obrázek 1: Webová aplikace s&nbsp;čítačem.</i></p>



<p><a name="k11"></a></p>
<h2 id="k11">11. Základy práce s&nbsp;cookies</h2>

<p>Kromě sezení (session) lze v&nbsp;knihovně <i>Clojure Ring</i> přímo
pracovat i s&nbsp;cookies, ostatně session bývá obvykle realizováno právě přes
cookies. K&nbsp;tomu, aby se k&nbsp;mapě představující původní požadavek
přidaly i informace o cookies, lze použít middleware se jménem
<strong>ring.middleware.cookies/wrap-cookies</strong>, které k&nbsp;mapě
požadavku přidá další dvojici klíč-hodnota, kde klíč má (podle očekávání) jméno
<strong>:cookies</strong>. Kostra webové aplikace může vypadat následovně:</p>

<pre>
(def <strong>app</strong>
    <i>"Datova struktra predstavujici kostru webove aplikace."</i>
    (-&gt; handler
        ring.middleware.cookies/wrap-cookies
        ring.middleware.params/wrap-params))
</pre>

<p>Pokud se mají zpracovat parametry požadavku, session i cookies, dostaneme
následující strukturu:</p>

<pre>
(def <strong>app</strong>
    <i>"Datova struktra predstavujici kostru webove aplikace."</i>
    (-&gt; handler
        ring.middleware.cookies/wrap-cookies
        ring.middleware.session/wrap-session
        ring.middleware.params/wrap-params))
</pre>

<p>U třech middleware aplikovaných za sebou a postupně obalujících původní mapu
s&nbsp;informacemi o požadavku se již v&nbsp;plné kráse ukazují možnosti makra
-&gt;.</p>

<p>To však není vše &ndash; kromě přečtení cookies je nutné umět i vytvořit
nové cookie. Nejjednodušším způsobem je předat další parametry funkci
<strong>ring.util.response</strong>, například:</p>

<pre>
(ring.util.response/set-cookie :user-name "Pavel")
</pre>

<p>Popř.&nbsp;při požadavku na nastavení dalších vlastností cookie (zde
konkrétně životnosti):</p>

<pre>
(ring.util.response/set-cookie :user-name "Pavel" {:max-age 36000000})
</pre>



<p><a name="k12"></a></p>
<h2 id="k12">12. Sedmý demonstrační příklad &ndash; použití <strong>ring.middleware.cookies/wrap-cookies</strong></h2>

<p>Dnešní sedmý a současně i poslední demonstrační příklad je (alespoň
prozatím) nejsložitější, ovšem můžeme si na něm ukázat jak přečtení parametrů
požadavku, tak i základy práce se session. Tato webová aplikace zobrazí na
straně klienta formulář, v&nbsp;němž se nachází textové políčko pro zadání
jména a tlačítko nadepsané &bdquo;Remember me&ldquo; pro odeslání formuláře na
server. O tuto část se stará funkce nazvaná <strong>create-html-page</strong>.
Za povšimnutí stojí fakt, že se formulář správně zobrazí i za předpokladu, že
parametr <strong>user-name</strong> bude mít hodnotu <strong>nil</strong>:</p>

<pre>
(defn <strong>create-html-page</strong>
    <i>"Vygenerovani HTML stranky."</i>
    [user-name]
    (str
"    &lt;html&gt;
         &lt;head&gt;
             &lt;title&gt;Powered by Ring!&lt;/title&gt;
         &lt;/head&gt;
         &lt;body&gt;
             &lt;h1&gt;Powered by Ring!&lt;/h1&gt;
             &lt;form method='post' action='/'&gt;
                 User name: &lt;input type='text' name='user-name' value='" user-name "'/&gt;&lt;br /&gt;
                            &lt;input type='submit' value='Remember me' /&gt;
             &lt;/form&gt;
         &lt;/body&gt;
     &lt;/html&gt;
"))
</pre>

<p>Vzhledem k&nbsp;tomu, že potřebujeme číst parametry požadavku a současně i
pracovat s&nbsp;cookies, musí kostra aplikace vypadat takto:</p>

<pre>
(def <strong>app</strong>
    <i>"Datova struktra predstavujici kostru webove aplikace."</i>
    (-&gt; handler
        cookies/wrap-cookies
        http-params/wrap-params))
</pre>

<p>Handler musí přečíst parametr se jménem <strong>user-name</strong> i stejně
pojmenovaný objekt z&nbsp;cookies. Ani jeden z&nbsp;těchto objektů nemusí být
nalezen, typicky při prvním přístupu na stránku webové aplikace, což však
nevadí, protože <strong>or</strong> dokáže bez problémů zpracovat i hodnoty
<strong>nil</strong> (žádné NullPointerException nenastane :-). Pokud je na
formuláři zadáno nové jméno, tak <strong>or</strong> vrátí právě toto jméno,
pokud však formulář žádné jméno neobsahuje (nově spuštěný prohlížeč), přečte a
vrátí se jméno z&nbsp;cookie:</p>

<pre>
(defn <strong>handler</strong>
    <i>"Zpracovani pozadavku."</i>
    [request]
    (let [params        (:params  request)
          cookies       (:cookies request)
          new-user-name (get params "user-name")
          old-user-name (get (get cookies "user-name") :value)
          user-name     (or new-user-name old-user-name)]
        (println "New user name " new-user-name)
        (println "Old user name " old-user-name)
        (println "Incoming cookies: " cookies)
        (let [response (generate-response user-name)]
              (println "Outgoing cookies: " (get response :cookies))
              response)))
</pre>

<p>Odpověď serveru je vytvořena v&nbsp;nové funkci, a to především z&nbsp;toho
důvodu, že potřebujeme na standardní výstup vypsat jak starou, tak i novou
hodnotu cookie(s):</p>

<pre>
(defn <strong>generate-response</strong>
    <i>"Vytvoreni odpovedi."</i>
    [user-name]
     (let [html-output (create-html-page user-name)]
        (if user-name
            (-&gt; (http-response/response html-output)
                (http-response/set-cookie :user-name user-name {:max-age 36000000})
                (http-response/content-type "text/html"))
            (-&gt; (http-response/response html-output)
                (http-response/content-type "text/html")))))
</pre>

<p>Opět se podívejme na úplný zdrojový kód aplikace:</p>

<pre>
(ns <strong>webapp12.core</strong>
    (:gen-class))
&nbsp;
(require '[ring.adapter.jetty      :as jetty])
(require '[ring.middleware.params  :as http-params])
(require '[ring.util.response      :as http-response])
(require '[ring.middleware.cookies :as cookies])
&nbsp;
(defn <strong>create-html-page</strong>
    <i>"Vygenerovani HTML stranky."</i>
    [user-name]
    (str
"    &lt;html&gt;
         &lt;head&gt;
             &lt;title&gt;Powered by Ring!&lt;/title&gt;
         &lt;/head&gt;
         &lt;body&gt;
             &lt;h1&gt;Powered by Ring!&lt;/h1&gt;
             &lt;form method='post' action='/'&gt;
                 User name: &lt;input type='text' name='user-name' value='" user-name "'/&gt;&lt;br /&gt;
                            &lt;input type='submit' value='Remember me' /&gt;
             &lt;/form&gt;
         &lt;/body&gt;
     &lt;/html&gt;
"))
&nbsp;
(defn <strong>generate-response</strong>
    <i>"Vytvoreni odpovedi."</i>
    [user-name]
     (let [html-output (create-html-page user-name)]
        (if user-name
            (-&gt; (http-response/response html-output)
                (http-response/set-cookie :user-name user-name {:max-age 36000000})
                (http-response/content-type "text/html"))
            (-&gt; (http-response/response html-output)
                (http-response/content-type "text/html")))))
&nbsp;
(defn <strong>handler</strong>
    <i>"Zpracovani pozadavku."</i>
    [request]
    (let [params        (:params  request)
          cookies       (:cookies request)
          new-user-name (get params "user-name")
          old-user-name (get (get cookies "user-name") :value)
          user-name     (or new-user-name old-user-name)]
        (println "New user name " new-user-name)
        (println "Old user name " old-user-name)
        (println "Incoming cookies: " cookies)
        (let [response (generate-response user-name)]
              (println "Outgoing cookies: " (get response :cookies))
              response)))
&nbsp;
(def <strong>app</strong>
    <i>"Datova struktra predstavujici kostru webove aplikace."</i>
    (-&gt; handler
        cookies/wrap-cookies
        http-params/wrap-params))
&nbsp;
(defn <strong>-main</strong>
    <i>"Spusteni webove aplikace na portu 8080."</i>
    [&amp; args]
    (jetty/run-jetty app {:port 8080}))
</pre>



<p><a name="k13"></a></p>
<h2 id="k13">13. Přečtení hodnoty z&nbsp;cookie a nastavení nové hodnoty</h2>

<p>Podívejme se, jak se bude aplikace chovat při testování. Předpokládejme, že
v&nbsp;prohlížeči se nejdříve zobrazí prázdný formulář, posléze se zadá jméno
&bdquo;Pavel&ldquo;, prohlížeč se vypne, zapne a jméno se změní na
&bdquo;tisnik&ldquo;:</p>

<pre>
lein run
&nbsp;
2015-03-10 20:29:49.330:INFO:oejs.Server:jetty-7.6.13.v20130916
2015-03-10 20:29:49.382:INFO:oejs.AbstractConnector:Started SelectChannelConnector@0.0.0.0:8080
</pre>

<pre>
<strong>První zobrazení formuláře:</strong>
New user name  nil
Old user name  nil
Incoming cookies:  {}
Outgoing cookies:  nil
&nbsp;
<strong>Zadání jména a odeslání formuláře:</strong>
New user name  Pavel
Old user name  nil
Incoming cookies:  {}
Outgoing cookies:  {:user-name {:max-age 36000000, :value Pavel}}
&nbsp;
<strong>Reload:</strong>
New user name  Pavel
Old user name  Pavel
Incoming cookies:  {user-name {:value Pavel}}
Outgoing cookies:  {:user-name {:max-age 36000000, :value Pavel}}
&nbsp;
<strong>Zadání nového jména:</strong>
New user name  tisnik
Old user name  Pavel
Incoming cookies:  {user-name {:value Pavel}}
Outgoing cookies:  {:user-name {:max-age 36000000, :value tisnik}}
</pre>

<img src="http://i.iinfo.cz/images/252/s1.png" class="image-200396" alt="&#160;" height="194" width="423" />
<p><i>Obrázek 2: Formulář zobrazený ve webovém prohlížeči.</i></p>

<img src="http://i.iinfo.cz/images/278/s2.png" class="image-200397" alt="&#160;" height="459" width="727" />
<p><i>Obrázek 3: Aplikace skutečně vytvořila cookie.</i></p>

<img src="http://i.iinfo.cz/images/531/s3.png" class="image-200398" alt="&#160;" height="408" width="482" />
<p><i>Obrázek 4: Informace o cookie: jméno, hodnota, doba platnosti.</i></p>



<p><a name="k14"></a></p>
<h2 id="k14">14. Odkazy na Internetu</h2>

<ol>

<li>Clojure Ring na GitHubu<br />
<a href="https://github.com/ring-clojure/ring">https://github.com/ring-clojure/ring</a>
</li>

<li>A brief overview of the Clojure web stack<br />
<a href="https://brehaut.net/blog/2011/ring_introduction">https://brehaut.net/blog/2011/ring_introduction</a>
</li>

<li>Getting Started with Ring<br />
<a href="http://www.learningclojure.com/2013/01/getting-started-with-ring.html">http://www.learningclojure.com/2013/01/getting-started-with-ring.html</a>
</li>

<li>Getting Started with Ring and Compojure - Clojure Web Programming<br />
<a href="http://www.myclojureadventure.com/2011/03/getting-started-with-ring-and-compojure.html">http://www.myclojureadventure.com/2011/03/getting-started-with-ring-and-compojure.html</a>
</li>

<li>Leiningen: nástroj pro správu projektů napsaných v Clojure<br />
<a href="http://www.root.cz/clanky/leiningen-nastroj-pro-spravu-projektu-napsanych-v-clojure/">http://www.root.cz/clanky/leiningen-nastroj-pro-spravu-projektu-napsanych-v-clojure/</a>
</li>

<li>Leiningen: nástroj pro správu projektů napsaných v Clojure (2)<br />
<a href="http://www.root.cz/clanky/leiningen-nastroj-pro-spravu-projektu-napsanych-v-clojure-2/">http://www.root.cz/clanky/leiningen-nastroj-pro-spravu-projektu-napsanych-v-clojure-2/</a>
</li>

<li>Leiningen: nástroj pro správu projektů napsaných v Clojure (3)<br />
<a href="http://www.root.cz/clanky/leiningen-nastroj-pro-spravu-projektu-napsanych-v-clojure-3/">http://www.root.cz/clanky/leiningen-nastroj-pro-spravu-projektu-napsanych-v-clojure-3/</a>
</li>

<li>Leiningen: nástroj pro správu projektů napsaných v Clojure (4)<br />
<a href="http://www.root.cz/clanky/leiningen-nastroj-pro-spravu-projektu-napsanych-v-clojure-4/">http://www.root.cz/clanky/leiningen-nastroj-pro-spravu-projektu-napsanych-v-clojure-4/</a>
</li>

<li>Unit Testing in Clojure<br />
<a href="http://nakkaya.com/2009/11/18/unit-testing-in-clojure/">http://nakkaya.com/2009/11/18/unit-testing-in-clojure/</a>
</li>

<li>Testing in Clojure (Part-1: Unit testing)<br />
<a href="http://blog.knoldus.com/2014/03/22/testing-in-clojure-part-1-unit-testing/">http://blog.knoldus.com/2014/03/22/testing-in-clojure-part-1-unit-testing/</a>
</li>

<li>API for clojure.test - Clojure v1.6 (stable)<br />
<a href="https://clojure.github.io/clojure/clojure.test-api.html">https://clojure.github.io/clojure/clojure.test-api.html</a>
</li>

<li>Leiningen: úvodní stránka<br />
<a href="http://leiningen.org/">http://leiningen.org/</a>
</li>

<li>Leiningen: Git repository<br />
<a href="https://github.com/technomancy/leiningen">https://github.com/technomancy/leiningen</a>
</li>

<li>leiningen-win-installer<br />
<a href="http://leiningen-win-installer.djpowell.net/">http://leiningen-win-installer.djpowell.net/</a>
</li>

<li>Clojure  1: Úvod<br />
<a href="http://www.root.cz/clanky/clojure-aneb-jazyk-umoznujici-tvorbu-bezpecnych-vicevlaknovych-aplikaci-pro-jvm/">http://www.root.cz/clanky/clojure-aneb-jazyk-umoznujici-tvorbu-bezpecnych-vicevlaknovych-aplikaci-pro-jvm/</a>
</li>

<li>Clojure  2: Symboly, kolekce atd.<br />
<a href="http://www.root.cz/clanky/clojure-aneb-jazyk-umoznujici-tvorbu-bezpecnych-vicevlaknovych-aplikaci-pro-jvm-2-cast/">http://www.root.cz/clanky/clojure-aneb-jazyk-umoznujici-tvorbu-bezpecnych-vicevlaknovych-aplikaci-pro-jvm-2-cast/</a>
</li>

<li>Clojure  3: Funkcionální programování<br />
<a href="http://www.root.cz/clanky/clojure-aneb-jazyk-umoznujici-tvorbu-bezpecnych-vicevlaknovych-aplikaci-pro-jvm-3-cast-funkcionalni-programovani/">http://www.root.cz/clanky/clojure-aneb-jazyk-umoznujici-tvorbu-bezpecnych-vicevlaknovych-aplikaci-pro-jvm-3-cast-funkcionalni-programovani/</a>
</li>

<li>Clojure  4: Kolekce, sekvence a lazy sekvence<br />
<a href="http://www.root.cz/clanky/clojure-aneb-jazyk-umoznujici-tvorbu-bezpecnych-vicevlaknovych-aplikaci-pro-jvm-4-cast-kolekce-sekvence-a-lazy-sekvence/">http://www.root.cz/clanky/clojure-aneb-jazyk-umoznujici-tvorbu-bezpecnych-vicevlaknovych-aplikaci-pro-jvm-4-cast-kolekce-sekvence-a-lazy-sekvence/</a>
</li>

<li>Clojure  5: Sekvence, lazy sekvence a paralelní programy<br />
<a href="http://www.root.cz/clanky/clojure-a-bezpecne-aplikace-pro-jvm-sekvence-lazy-sekvence-a-paralelni-programy/">http://www.root.cz/clanky/clojure-a-bezpecne-aplikace-pro-jvm-sekvence-lazy-sekvence-a-paralelni-programy/</a>
</li>

<li>Clojure  6: Podpora pro paralelní programování<br />
<a href="http://www.root.cz/clanky/programovaci-jazyk-clojure-6-futures-nejsou-jen-financni-derivaty/">http://www.root.cz/clanky/programovaci-jazyk-clojure-6-futures-nejsou-jen-financni-derivaty/</a>
</li>

<li>Clojure  7: Další funkce pro paralelní programování<br />
<a href="http://www.root.cz/clanky/programovaci-jazyk-clojure-7-dalsi-podpurne-prostredky-pro-paralelni-programovani/">http://www.root.cz/clanky/programovaci-jazyk-clojure-7-dalsi-podpurne-prostredky-pro-paralelni-programovani/</a>
</li>

<li>Clojure  8: Identity, stavy, neměnné hodnoty a reference<br />
<a href="http://www.root.cz/clanky/programovaci-jazyk-clojure-8-identity-stavy-nemenne-hodnoty-a-referencni-typy/">http://www.root.cz/clanky/programovaci-jazyk-clojure-8-identity-stavy-nemenne-hodnoty-a-referencni-typy/</a>
</li>

<li>Clojure  9: Validátory, pozorovatelé a kooperace s Javou<br />
<a href="http://www.root.cz/clanky/programovaci-jazyk-clojure-9-validatory-pozorovatele-a-kooperace-mezi-clojure-a-javou/">http://www.root.cz/clanky/programovaci-jazyk-clojure-9-validatory-pozorovatele-a-kooperace-mezi-clojure-a-javou/</a>
</li>

<li>Clojure 10: Kooperace mezi Clojure a Javou<br />
<a href="http://www.root.cz/clanky/programovaci-jazyk-clojure-10-kooperace-mezi-clojure-a-javou-pokracovani/">http://www.root.cz/clanky/programovaci-jazyk-clojure-10-kooperace-mezi-clojure-a-javou-pokracovani/</a>
</li>

<li>Clojure 11: Generátorová notace seznamu/list comprehension<br />
<a href="http://www.root.cz/clanky/programovaci-jazyk-clojure-11-generatorova-notace-seznamu-list-comprehension/">http://www.root.cz/clanky/programovaci-jazyk-clojure-11-generatorova-notace-seznamu-list-comprehension/</a>
</li>

<li>Clojure 12: Překlad programů z Clojure do bajtkódu JVM I<br />
<a href="http://www.root.cz/clanky/programovaci-jazyk-clojure-12-preklad-programu-z-clojure-do-bajtkodu-jvm/">http://www.root.cz/clanky/programovaci-jazyk-clojure-12-preklad-programu-z-clojure-do-bajtkodu-jvm/</a>
</li>

<li>Clojure 13: Překlad programů z Clojure do bajtkódu JVM II<br />
<a href="2) http://www.root.cz/clanky/programovaci-jazyk-clojure-13-preklad-programu-z-clojure-do-bajtkodu-jvm-pokracovani/">2) http://www.root.cz/clanky/programovaci-jazyk-clojure-13-preklad-programu-z-clojure-do-bajtkodu-jvm-pokracovani/</a>
</li>

<li>Clojure 14: Základy práce se systémem maker<br />
<a href="http://www.root.cz/clanky/programovaci-jazyk-clojure-14-zaklady-prace-se-systemem-maker/">http://www.root.cz/clanky/programovaci-jazyk-clojure-14-zaklady-prace-se-systemem-maker/</a>
</li>

<li>Clojure 15: Tvorba uživatelských maker<br />
<a href="http://www.root.cz/clanky/programovaci-jazyk-clojure-15-tvorba-uzivatelskych-maker/">http://www.root.cz/clanky/programovaci-jazyk-clojure-15-tvorba-uzivatelskych-maker/</a>
</li>

<li>Clojure 16: Složitější uživatelská makra<br />
<a href="http://www.root.cz/clanky/programovaci-jazyk-clojure-16-slozitejsi-uzivatelska-makra/">http://www.root.cz/clanky/programovaci-jazyk-clojure-16-slozitejsi-uzivatelska-makra/</a>
</li>

<li>Clojure 17: Využití standardních maker v praxi<br />
<a href="http://www.root.cz/clanky/programovaci-jazyk-clojure-17-vyuziti-standardnich-maker-v-praxi/">http://www.root.cz/clanky/programovaci-jazyk-clojure-17-vyuziti-standardnich-maker-v-praxi/</a>
</li>

<li>Clojure 18: Základní techniky optimalizace aplikací<br />
<a href="http://www.root.cz/clanky/programovaci-jazyk-clojure-18-zakladni-techniky-optimalizace-aplikaci/">http://www.root.cz/clanky/programovaci-jazyk-clojure-18-zakladni-techniky-optimalizace-aplikaci/</a>
</li>

<li>Clojure 19: Vývojová prostředí pro Clojure<br />
<a href="http://www.root.cz/clanky/programovaci-jazyk-clojure-19-vyvojova-prostredi-pro-clojure/">http://www.root.cz/clanky/programovaci-jazyk-clojure-19-vyvojova-prostredi-pro-clojure/</a>
</li>

<li>Clojure 20: Vývojová prostředí pro Clojure (Vimu s REPL)<br />
<a href="http://www.root.cz/clanky/programovaci-jazyk-clojure-20-vyvojova-prostredi-pro-clojure-integrace-vimu-s-repl/">http://www.root.cz/clanky/programovaci-jazyk-clojure-20-vyvojova-prostredi-pro-clojure-integrace-vimu-s-repl/</a>
</li>

<li>Clojure 21: ClojureScript aneb překlad Clojure do JS<br />
<a href="http://www.root.cz/clanky/programovaci-jazyk-clojure-21-clojurescript-aneb-preklad-clojure-do-javascriptu/">http://www.root.cz/clanky/programovaci-jazyk-clojure-21-clojurescript-aneb-preklad-clojure-do-javascriptu/</a>
</li>

</ol>



<p></p><p></p>
<p><small>Autor: <a href="http://www.fit.vutbr.cz/~tisnovpa">Pavel Tišnovský</a> &nbsp; 2015</small></p>
</body>
</html>

