<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
        "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html>
<head>
<title>Čtyři různé podoby datové struktury map v programovacím jazyku Clojure</title>
<meta name="Author" content="Pavel Tisnovsky" />
<meta name="Generator" content="vim" />
<meta http-equiv="content-type" content="text/html; charset=utf-8" />
<style type="text/css">
         body {color:#000000; background:#ffffff;}
         h1  {font-family: arial, helvetica, sans-serif; color:#ffffff; background-color:#c00000; text-align:center; padding-left:1em}
         h2  {font-family: arial, helvetica, sans-serif; color:#ffffff; background-color:#0000c0; padding-left:1em; text-align:left}
         h3  {font-family: arial, helvetica, sans-serif; color:#000000; background-color:#c0c0c0; padding-left:1em; text-align:left}
         h4  {font-family: arial, helvetica, sans-serif; color:#000000; background-color:#e0e0e0; padding-left:1em; text-align:left}
         a   {font-family: arial, helvetica, sans-serif;}
         li  {font-family: arial, helvetica, sans-serif; color:#000000; text-align:justify; width:450px;}
         ol  {font-family: arial, helvetica, sans-serif; color:#000000; text-align:justify; width:450px;}
         ul  {font-family: arial, helvetica, sans-serif; color:#000000; text-align:justify; width:450px;}
         p   {font-family: arial, helvetica, sans-serif; color:#000000; text-align:justify;}
         pre {background:#e0e0e0}
</style>
</head>

<body>

<h1>Čtyři různé podoby datové struktury map v programovacím jazyku Clojure</h1>

<h3>Pavel Tišnovský</h3>

<p></p>

<h1>Úvodník</h1>

<p>V prakticky jakémkoli programu psaném v jazyce Clojure nalezneme mnoho míst, ve kterých se používají mapy. Tato nejužitečnější datová struktura existuje ve třech základních podobách (hash map, sorted map, array map), ovšem v balíčku clojure.data.priority-map nalezneme specifickou formu prioritní mapy.</p>



<h2>Obsah</h2>

<p><a href="#k01">1. Mapy &ndash; nejdůležitější datový typ programovacího jazyka Clojure</a></p>
<p><a href="#k02">2. Typy map v&nbsp;Clojure</a></p>
<p><a href="#k03">3. Implementace třídy <strong>clojure.lang.PersistentHashMap</strong></a></p>
<p><a href="#k04">4. Rozhraní <strong>INode</strong></a></p>
<p><a href="#k05">5. Třídy <strong>ArrayNode</strong> a <strong>BitmapIndexedNode</strong></a></p>
<p><a href="#k06">6. Nový užitečný typ mapy: <strong>priority-map</strong></a></p>
<p><a href="#k07">7. Příprava projektu pro otestování vlastností jednotlivých implementací map</a></p>
<p><a href="#k08">8. Přidání nové závislosti a stažení potřebných knihoven</a></p>
<p><a href="#k09">9. Spuštění interaktivní smyčky REPL a import potřebného modulu</a></p>
<p><a href="#k10">10. Otestování vlastností mapy typu <strong>hash-map</strong></a></p>
<p><a href="#k11">11. Otestování vlastností mapy typu <strong>sorted-map</strong></a></p>
<p><a href="#k12">12. Otestování vlastností mapy typu <strong>array-map</strong></a></p>
<p><a href="#k13">13. Otestování vlastností mapy typu <strong>priority-map</strong></a></p>
<p><a href="#k14">14. Základní operace s&nbsp;mapami: <strong>assoc</strong> a <strong>dissoc</strong></a></p>
<p><a href="#k15">15. Vyhledávání prvků, získání klíčů a hodnot</a></p>
<p><a href="#k16">16. Operace <strong>merge</strong> a <strong>zipmap</strong></a></p>
<p><a href="#k17">17. Specifické operace pro <strong>priority-map</strong></a></p>
<p><a href="#k18">18. Repositář s&nbsp;demonstračním příkladem</a></p>
<p><a href="#k19">19. Odkazy na předchozí části seriálu o programovacím jazyku Clojure</a></p>
<p><a href="#k20">20. Odkazy na Internetu</a></p>



<p><a name="k01"></a></p>
<h2 id="k01">1. Mapy &ndash; nejdůležitější datový typ programovacího jazyka Clojure</h2>

<p>Při popisu programovacího jazyka Clojure jsme se seznámili se všemi datovými
typy, které tento jazyk vývojářům nabízí. Připomeňme si, že kromě jednoduchých
datových typů (celá čísla, reálná čísla, znaky, pravdivostní hodnoty,
<strong>nil</strong>) Clojure podporuje i tři složené datové typy, nad nimiž je
navíc postaven abstraktní typ <i>sekvence</i>. Především se jedná o seznamy
(<i>list</i>), vektory (<i>vector</i>), množiny (<i>set</i>) a mapy
(<i>map</i>). Seznamy a vektory jsou velmi důležité, protože se
mj.&nbsp;používají i pro reprezentaci samotného programu, a to díky tomu, že
Clojure je, podobně jako další dialekty programovacího jazyka LISP, takzvaně
<i>homoikonickým</i> jazykem &ndash; program je reprezentován stejným způsobem
jako data (což mj.&nbsp;umožňuje vytvářet pokročilé systémy maker).
V&nbsp;některých aplikacích se používají i množiny, a to například ve chvíli,
kdy potřebujeme reprezentovat přítomnost či nepřítomnost určitého prvku, a to
nezávisle na jeho umístění v&nbsp;nějaké datové kolekci (nezajímá nás tedy
například to, že se jedná o třetí prvek, ale o to, zda takový prvek vůbec
existuje).</p>

<p>Seznamy, vektory a mnohdy i množiny tedy nalezneme v&nbsp;prakticky
jakémkoli programu psaném v&nbsp;jazyce Clojure, ovšem zdaleka nejužitečnějším
datovým typem jsou <i>mapy</i>. A právě velmi časté používání map
v&nbsp;programech psaných v&nbsp;Clojure odlišuje tento jazyk jak od většiny
ostatních dialektů LISPu, tak i od mainstreamových programovacích jazyků. Mapy
jsou skutečně velmi flexibilním a téměř univerzálním datovým typem (či možná
lépe řečeno datovou strukturou), který může nahradit například hodnotové
objekty (viz například <a
href="https://www.youtube.com/watch?v=aSEQfqNYNAc">toto známé video</a>),
používají se namísto pojmenovaných parametrů funkcí (v&nbsp;Pythonu je nazýváme
&bdquo;keyword parametry&ldquo;) a samozřejmě jsou (alespoň většinou) výsledkem
deserializace souborů typu JSON, YAML apod. Na tomto místě je nutné upozornit
na to, že mapy jsou, ostatně stejně jako seznamy, vektory i množiny,
v&nbsp;jazyku Clojure <i>neměnitelné (immutable)</i> a <i>perzistentní
(persistent)</i>, takže velmi dobře zapadají do konceptu funkcionálního
jazyka.</p>

<p><div class="rs-tip-major">Poznámka: velmi pěkně je téma použití map
v&nbsp;Clojure shrnuto v&nbsp;přednášce <a
href="https://www.youtube.com/watch?v=rI8tNMsozo0">Rails Conf 2012 Keynote:
Simplicity Matters by Rich Hickey</a> (tato přednáška existuje v&nbsp;několika
variantách).</div></p>



<p><a name="k02"></a></p>
<h2 id="k02">2. Typy map v&nbsp;Clojure</h2>

<p>V&nbsp;základní knihovně programovacího jazyka Clojure existují tři
implementace map, které se od sebe odlišují některými svými vlastnostmi,
především tím, jak jsou mapy převáděny na sekvence (tedy zda a jak zachovávají
pořadí dvojic klíč-hodnota), a jaké jsou časové složitosti základních operací.
Ovšem existuje i mnoho dalších implementací map a taktéž multimap. Tento článek
vznikl primárně z&nbsp;toho důvodu, aby čtenáře seznámil s&nbsp;takzvanou
<i>prioritní mapou</i>, v&nbsp;níž jsou <i>hodnoty</i> uložené do mapy použity
pro reprezentaci priority prvků reprezentovaných svým <i>klíčem</i> (což je
vlastně inverzní způsob chápání funkce mapy &ndash; blíže viz navazující
kapitoly). Nicméně pro úplnost si nejdříve připomeneme zmíněné tři základní
implementace mapy a poté si vlastnosti těchto implementací porovnáme
s&nbsp;prioritními mapami. Mimochodem &ndash; prioritní mapy lze využít i pro
implementaci prioritní fronty, ovšem s&nbsp;určitými omezeními (prvky musí být
unikátní).</p>

<table>
<tr><th> #</th><th>Vlastnost</th><th>Hash map</th><th>Sorted map</th><th>Array map</th></tr>
<tr><td> 1</td><td>konstruktor</td><td>(hash-map ...)</td><td>(sorted-map ...)</td><td>(array-map)</td></tr>
<tr><td> 2</td><td>&bdquo;literál&ldquo;</td><td>{klíč hodnota klíč hodnota...}</td><td>&times;</td><td>&times;</td></tr>
<tr><td> 3</td><td>složitost přístupu k&nbsp;prvkům</td><td>O(log<sub>32</sub>N)</td><td>O(log N)</td><td>O(N)</td></tr>
<tr><td> 4</td><td>složitost <strong>(count)</strong></td><td>O(1)</td><td>O(1)</td><td>O(1)</td></tr>
<tr><td> 5</td><td>zachování pořadí</td><td>ne</td><td>ne</td><td>ano</td></tr>
<tr><td> 6</td><td>setříděné prvky</td><td>ne</td><td>ano</td><td>ne</td></tr>
<tr><td> 7</td><td>podpora operace <strong>(seq)</strong></td><td>ano</td><td>ano</td><td>ano</td></tr>
<tr><td> 8</td><td>podpora operace <strong>(rseq)</strong></td><td>ne</td><td>ano</td><td>ano</td></tr>
<tr><td> 9</td><td>klíče <strong>nil</strong> povoleny</td><td>ano</td><td>ano</td><td>ano</td></tr>
<tr><td>10</td><td>hodnoty <strong>nil</strong> povoleny</td><td>ano</td><td>ano</td><td>ano</td></tr>
</table>

<p><div class="rs-tip-major">Poznámka: povšimněte si rozdílu v&nbsp;časové
složitosti přístupu k&nbsp;prvkům mapy v&nbsp;případě hash mapy a sorted mapy.
Složitosti <i>O(log<sub>32</sub>N)</i> a <i>O(log N)</i> sice patří do stejné
kategorie, ovšem v&nbsp;praxi je první složitost prakticky <i>konstantní</i>
pro rozumně velké mapy (přístup do mapy s&nbsp;tisíci prvky znamená dva kroky,
pro mapu s&nbsp;milionem prvků pouhé kroky tři atd).</div></p>



<p><a name="k03"></a></p>
<h2 id="k03">3. Implementace třídy <strong>clojure.lang.PersistentHashMap</strong></h2>

<p>Hash mapy se v&nbsp;praxi používají (minimálně v&nbsp;případě programovacího
jazyka Clojure) mnohem častěji než mapy, v&nbsp;nichž jsou prvky setříděny na
základě hodnoty svého klíče popř.&nbsp;podle pořadí vložení prvku do mapy.
Proto si podrobněji popíšeme interní strukturu hash mapy. Jedná se o
neměnitelnou (<i>immutable</i>) a současně i perzistentní (<i>persistent</i>)
datovou strukturu, což znamená, že do jednou vytvořené mapy již nelze přidávat
další prvky (dvojice klíč-hodnota) ani žádné prvky ubírat. Na druhou stranu
však mapy mohou sdílet svoji interní strukturu (<i>structural sharing</i>),
takže přidání nového prvku lze efektivně zařídit vytvořením nové mapy
s&nbsp;přidaným prvkem (což zajišťuje funkce nazvaná <strong>assoc</strong>,
kterou si popíšeme níže, opakem je funkce <strong>dissoc</strong>). Hash mapy
jsou interně uloženy podobným způsobem, jako vektory, tj.&nbsp;s&nbsp;využitím
&bdquo;tlustého&ldquo; stromu, jehož každý uzel může obsahovat až 32 odkazů na
další poduzly. Takové stromy jsou typicky velmi nízké a tím pádem je i jejich
prohledání rychlé &ndash; složitost mnoha operací je buď konstntní nebo rovna
<i>O(log<sub>32</sub>N)</i>, tj.&nbsp;&bdquo;prakticky konstantní&ldquo;.</p>



<p><a name="k04"></a></p>
<h2 id="k04">4. Rozhraní <strong>INode</strong></h2>

<p>Interně je hash mapa tvořena stromem obsahujícím jako své uzly objekty
objekty s&nbsp;rozhraním <i>INode</i> (tj.&nbsp;jedná se o instance tříd
implementujících toto rozhraní). Samotná struktura <i>INode</i> se postupně
vyvíjí a mění. V&nbsp;současné verzi jazyka Clojure (1.10) vypadá
následovně:</p>

<pre>
static interface <strong>INode</strong> extends <strong>Serializable</strong> {
	INode assoc(int shift, int hash, Object key, Object val, Box addedLeaf);
	INode without(int shift, int hash, Object key);
	IMapEntry find(int shift, int hash, Object key);
	Object find(int shift, int hash, Object key, Object notFound);
	ISeq nodeSeq();
	INode assoc(AtomicReference<Thread> edit, int shift, int hash, Object key, Object val, Box addedLeaf);
	INode without(AtomicReference<Thread> edit, int shift, int hash, Object key, Box removedLeaf);
    public Object kvreduce(IFn f, Object init);
	Object fold(IFn combinef, IFn reducef, IFn fjtask, IFn fjfork, IFn fjjoin);
    <i>// returns the result of (f [k v]) for each iterated element</i>
    Iterator iterator(IFn f);
}
</pre>

<p>V&nbsp;minulosti existovalo pět tříd implementujících rozhraní <i>INode</i>,
v&nbsp;moderním Clojure jsou to již jen tři třídy: <i>ArrayNode</i>,
<i>BitmapIndexedNode</i> a <i>HashCollisionNode</i>.</p>



<p><a name="k05"></a></p>
<h2 id="k05">5. Třídy <strong>ArrayNode</strong> a <strong>BitmapIndexedNode</strong></h2>

<p>Třída <i>ArrayNode</i> interně obsahuje pole s&nbsp;prvky typu <i>INode</i>
a hodnotu obsahující počet aktivních prvků v&nbsp;poli (což znamená, že funkce
<strong>count</strong> má konstantní časovou složitost). Důležité je, že zde
není uložen přímo klíč a hodnota prvku, jen reference na INode
popř.&nbsp;hodnota <strong>null</strong>. Operace <strong>assoc</strong>
(přidání prvku se strukturálním sdílením) znamená buď pouhé přidání nového
prvku nebo klonování pole s&nbsp;následným přidáním (klonují se ovšem pouze
reference, nikoli vlastní hodnoty prvků).</p>

<p>Mnohem zajímavější je třída <i>BitmapIndexedMode</i>. Zde je interně použito
pole <i>Object[]</i> o kapacitě 32 prvků, o obsazenosti rozhoduje celočíselný
atribut <strong>bitmap</strong>. Význam jednotlivých položek se může měnit.
Sudé prvky obsahují buď hodnotu <strong>null</strong> nebo klíč, liché prvky
buď hodnotu (navázanou na klíč) nebo referenci na další <i>INode</i> (což je
rekurzivně opět <i>ArrayNode</i> či <i>BitmapIndexedMode</i>):</p>

<ol>
<li>Když pole[2*i]==null pak pole[2*i+1] je <i>INode</i></li>
<li>Když pole[2*i]!=null pak pole[2*i] je klíč a pole[2*i+1] je hodnota</li>
</ol>

<p>To znamená, že zmíněné 32prvkové pole může maximálně obsahovat šestnáct
prvků klíč+hodnota, 32 odkazů na poduzly typu <i>INode</i> nebo mix obou typů
záznamů.</p>

<p>Ve skutečnosti se pracuje s&nbsp;klíčem nepřímo přes jeho hash kód zjištěný
funkcí <strong>hash</strong> (jde o 32bitovou hodnotu).</p>

<p><div class="rs-tip-major">Poznámka: to, jaká struktura bude interně použita,
záleží na počtu prvků při konstrukci mapy popř.&nbsp;na způsobu práce
s&nbsp;funkcemi <strong>assoc</strong> a <strong>dissoc</strong>. Je možné, že
bude docházet i k&nbsp;převodům mezi interní strukturou.</div></p>



<p><a name="k06"></a></p>
<h2 id="k06">6. Nový užitečný typ mapy: <strong>priority-map</strong></h2>

<p>Konečně se dostáváme k&nbsp;novému typu mapy, kvůli kterému vlastně dnešní
článek vznikl. Jedná se o datový typ nazvaný <i>priority-map</i>, jenž je
dostupný v&nbsp;balíčku <strong>clojure.data.priority-map</strong> (viz též <a
href="https://github.com/clojure/data.priority-map">https://github.com/clojure/data.priority-map</a>).
Prvky ukládané do této mapy jsou seřazeny, podobně jako v&nbsp;datové struktuře
<i>sorted map</i>. Ovšem je zde jeden velký rozdíl &ndash; řazení není
prováděno na základě klíče, ale na základě hodnoty &ndash; jedná se tedy o
&bdquo;inverzní&ldquo; přístup k&nbsp;mapě, který umožňuje, aby priorita prvků
byla libovolná (což u sorted mapy nelze, protože klíče musí být unikátní).
Prioritní mapy lze využít ve funkci prioritní fronty, k&nbsp;čemuž můžeme
použít funkce <strong>conj</strong>, <strong>peek</strong> a
<strong>pop</strong>, které budou odzkoušeny v&nbsp;rámci navazujících kapitol.
Samozřejmě jsou podporovány i běžné funkce typu <strong>assoc</strong>,
<strong>dissoc</strong>, <strong>count</strong>, <strong>into</strong> atd.</p>



<p><a name="k07"></a></p>
<h2 id="k07">7. Příprava projektu pro otestování vlastností jednotlivých implementací map</h2>

<p>V&nbsp;dalších kapitolách si ukážeme práci s&nbsp;mapami (všech typů)
prakticky. Aby bylo možné otestovat si možnosti prioritních map, vytvoříme nový
Clojure projekt založený na projektu Leiningen, s&nbsp;nímž jsme se již
v&nbsp;tomto seriálu setkali (odkazy jsou uvedeny <a
href="#k19">v&nbsp;devatenácté kapitole</a>). Kostra nového projektu se vytvoří
příkazem:</p>

<pre>
$ <strong>lein new app priority-map-1</strong>
&nbsp;
Generating a project called priority-map-1 based on the 'app' template.
</pre>

<p>Výsledkem předchozího příkazu by měla být následující adresářová
struktura:</p>

<pre>
.
├── CHANGELOG.md
├── doc
│   └── intro.md
├── LICENSE
├── project.clj
├── README.md
├── resources
├── src
│   └── priority_map_1
│       └── core.clj
└── test
    └── priority_map_1
        └── core_test.clj
&nbsp;
6 directories, 7 files
</pre>

<p>Pro nás je v&nbsp;tuto chvíli nejdůležitější soubor nazvaný
<strong>project.clj</strong>, který obsahuje specifikaci celého projektu, a to
včetně knihoven, na kterých projekt přímo závisí. Tranzitivní závislosti se
řeší automaticky nástrojem Leiningen, který interně pro tento účel používá
Maven. Vygenerovaný projektový soubor vypadá takto:</p>

<pre>
(defproject priority-map-1 "0.1.0-SNAPSHOT"
  :description "FIXME: write description"
  :url "http://example.com/FIXME"
  :license {:name "EPL-2.0 OR GPL-2.0-or-later WITH Classpath-exception-2.0"
            :url "https://www.eclipse.org/legal/epl-2.0/"}
  :dependencies [[org.clojure/clojure "1.10.1"]]
  :main ^:skip-aot priority-map-1.core
  :target-path "target/%s"
  :profiles {:uberjar {:aot :all
                       :jvm-opts ["-Dclojure.compiler.direct-linking=true"]}})
</pre>



<p><a name="k08"></a></p>
<h2 id="k08">8. Přidání nové závislosti a stažení potřebných knihoven</h2>

<p>Do projektového souboru <strong>project.clj</strong> je nyní nutné přidat
informaci o balíčku s&nbsp;implementací prioritní mapy. Soubor upravíme
následujícím způsobem:</p>

<pre>
(defproject priority-map-1 "0.1.0-SNAPSHOT"
  :description "FIXME: write description"
  :url "http://example.com/FIXME"
  :license {:name "EPL-2.0 OR GPL-2.0-or-later WITH Classpath-exception-2.0"
            :url "https://www.eclipse.org/legal/epl-2.0/"}
  :dependencies [[org.clojure/clojure "1.10.1"]
                 <strong>[org.clojure/data.priority-map "1.0.0"]</strong>]
  :main ^:skip-aot priority-map-1.core
  :target-path "target/%s"
  :profiles {:uberjar {:aot :all
                       :jvm-opts ["-Dclojure.compiler.direct-linking=true"]}})
</pre>

<p>Pro stažení všech závislých knihoven se použije příkaz:</p>

<pre>
$ <strong>lein deps</strong>
&nbsp;
Retrieving org/clojure/data.priority-map/1.0.0/data.priority-map-1.0.0.pom from central
Retrieving org/clojure/data.priority-map/1.0.0/data.priority-map-1.0.0.jar from central
</pre>

<p>Nyní by měl být projekt připraven a měly by být k&nbsp;dispozici i všechny
potřebné nestandardní knihovny.</p>



<p><a name="k09"></a></p>
<h2 id="k09">9. Spuštění interaktivní smyčky REPL a import potřebného modulu</h2>

<p>Pro otestování práce s&nbsp;mapami (všech typů) použijeme interaktivní
smyčku REPL jazyka Clojure. Tu je nutné spustit v&nbsp;adresáři
s&nbsp;projektovým souborem:</p>

<pre>
$ <strong>lein repl</strong>
&nbsp;
nREPL server started on port 33211 on host 127.0.0.1 - nrepl://127.0.0.1:33211
REPL-y 0.4.4, nREPL 0.7.0
Clojure 1.10.1
OpenJDK 64-Bit Server VM 1.8.0_191-b12
    Docs: (doc function-name-here)
          (find-doc "part-of-name-here")
  Source: (source function-name-here)
 Javadoc: (javadoc java-object-or-class-here)
    Exit: Control+D or (exit) or (quit)
 Results: Stored in vars *1, *2, *3, an exception in *e
&nbsp;
priority-map-1.core=&gt;
</pre>

<p>V&nbsp;posledním přípravném kroku načteme modul s&nbsp;implementací
prioritní mapy. To lze provést více způsoby, buď s&nbsp;využitím formy
<strong>use</strong>:</p>

<pre>
priority-map-1.core=&gt; <strong>(use 'clojure.data.priority-map)</strong>
WARNING: subseq already refers to: #'clojure.core/subseq in namespace: priority-map-1.core, being replaced by: #'clojure.data.priority-map/subseq
WARNING: rsubseq already refers to: #'clojure.core/rsubseq in namespace: priority-map-1.core, being replaced by: #'clojure.data.priority-map/rsubseq
</pre>

<p>Alternativně &ndash; a jedná se o čistší řešení &ndash; použijeme příkaz
<strong>require</strong>, u kterého můžeme specifikovat, které symboly se mají
načíst do stávajícího jmenného prostoru:</p>

<pre>
priority-map-1.core=&gt; <strong>(require '[clojure.data.priority-map :refer [priority-map]])</strong>
</pre>

<p><div class="rs-tip-major">Poznámka: další informace o formě
<strong>use</strong> a <strong>require</strong> nalezneme v&nbsp;nápovědě
dostupné přímo z&nbsp;prostředí smyčky REPL:</div></p>

<pre>
priority-map-1.core=&gt; <strong>(doc use)</strong>
-------------------------
clojure.core/use
([&amp; args])
  Like 'require, but also refers to each lib's namespace using
  clojure.core/refer. Use :use in the ns macro in preference to calling
  this directly.
&nbsp;
  'use accepts additional options in libspecs: :exclude, :only, :rename.
  The arguments and semantics for :exclude, :only, and :rename are the same
  as those documented for clojure.core/refer.
</pre>

<pre>
priority-map-1.core=&gt; <strong>(doc require)</strong>
-------------------------
clojure.core/require
([&amp; args])
  Loads libs, skipping any that are already loaded. Each argument is
  either a libspec that identifies a lib, a prefix list that identifies
  multiple libs whose names share a common prefix, or a flag that modifies
  how all the identified libs are loaded. Use :require in the ns macro
  in preference to calling this directly.
</pre>



<p><a name="k10"></a></p>
<h2 id="k10">10. Otestování vlastností mapy typu <strong>hash-map</strong></h2>

<p>Ve druhé polovině článku se budeme věnovat otestování základních vlastností
jednotlivých typů map. Začneme s&nbsp;hash mapou, pro níž (kromě jiného)
existuje konstruktor (či spíše literál) zapisovaný takto:</p>

<pre>
{klíč hodnota klíč hodnota klíč hodnota ...}
</pre>

<p>Pro větší čitelnost je možné použít čárky pro oddělení jednotlivých
prvků:</p>

<pre>
{klíč hodnota, klíč hodnota, klíč hodnota ...}
</pre>

<p><div class="rs-tip-major">Poznámka: ve skutečnosti vůbec na umístění čárek
nezáleží &ndash; jsou zde ignorovány.</div></p>

<p>Konstruktorem hash mapy je funkce pojmenovaná <strong>hash-map</strong>:</p>

<pre>
priority-map-1.core=&gt; <strong>(doc hash-map)</strong>
-------------------------
clojure.core/hash-map
([] [&amp; keyvals])
  keyval =&gt; key val
  Returns a new hash map with supplied mappings.  If any keys are
  equal, they are handled as if by repeated uses of assoc.
</pre>

<p>Vytvoříme tedy hodnotu typu hash map a navážeme ji na symbol
<strong>p1</strong> (což by v&nbsp;jiných jazycích byla proměnná, ovšem nikoli
v&nbsp;Clojure):</p>

<pre>
priority-map-1.core=&gt; <strong>(def p1 (hash-map :a 2 :b 1 :c 3 :d 5 :e 4 :f 3 :g 0 :h 10 :i 6 :j 7))</strong>
#'priority-map-1.core/p1
</pre>

<p><div class="rs-tip-major">Poznámka: velmi často se setkáme s&nbsp;tím, že
klíče jsou reprezentovány formou <strong>:a</strong>, <strong>:foo</strong>
atd. (<i>keywords</i>), což je z&nbsp;mnoha pohledů lepší řešení, než využití
běžných řetězců. Viz též <a
href="https://blog.jeaye.com/2017/10/31/clojure-keywords/">The five common
forms of Clojure keywords</a>.</div></p>

<p>Zobrazení obsahu hash mapy zdánlivě napovídá, že prvky jsou seřazeny takovým
způsobem, jakým byly do mapy zadány (což ovšem není ve skutečnosti pravda):</p>

<pre>
priority-map-1.core=&gt; <strong>p1</strong>
{:a 2 :b 1 :c 3 :d 5 :e 4 :f 3 :g 0 :h 10 :i 6 :j 7}
</pre>

<p>Způsob skutečného seřazení (resp.&nbsp;posloupnost přístupů) nám napoví
spíše funkce pro získání všech klíčů:</p>

<pre>
priority-map-1.core=&gt; <strong>(keys p1)</strong>
(:e :g :c :j :h :b :d :f :i :a)
</pre>

<p>Vrácení hodnot v&nbsp;nespecifikovaném pořadí:</p>

<pre>
priority-map-1.core=&gt; <strong>(vals p1)</strong>
(4 0 3 7 10 1 5 3 6 2)
</pre>

<p>Takto se k&nbsp;mapě přistupuje jako k&nbsp;sekvenci hodnot (dvojic).
Povšimněte si, že pořadí prvků je &bdquo;náhodné&ldquo; (resp.&nbsp;závislé na
haši klíčů):</p>

<pre>
priority-map-1.core=&gt; <strong>(doseq [[key val] p1] (println key val))</strong>
:e 4
:g 0
:c 3
:j 7
:h 10
:b 1
:d 5
:f 3
:i 6
:a 2
</pre>

<p>Ještě jednodušší je převést mapu na sekvenci:</p>

<pre>
priority-map-1.core=&gt; <strong>(seq p1)</strong>
([:e 4] [:g 0] [:c 3] [:j 7] [:h 10] [:b 1] [:d 5] [:f 3] [:i 6] [:a 2])
</pre>

<p>Pokud prvky do hash mapy vložíme v&nbsp;opačném pořadí:</p>

<pre>
priority-map-1.core=&gt; <strong>(def p1r (hash-map :j 2 :i 1 :h 3 :g 5 :f 4 :e 3 :d 0 :c 10 :b 6 :a 7))</strong>
#'priority-map-1.core/p1r
</pre>

<p>Bude její obsah zdánlivě opět seřazen podle klíčů, ovšem jen při výpisu mapy:</p>

<pre>
priority-map-1.core=&gt; <strong>p1r</strong>
{:a 7 :b 6 :c 10 :d 0 :e 3 :f 4 :g 5 :h 3 :i 1 :j 2}
</pre>

<p>Skutečné pořadí při přístupu k&nbsp;mapě jako k&nbsp;sekvenci:</p>

<pre>
priority-map-1.core=&gt; <strong>(keys p1r)</strong>
(:e :g :c :j :h :b :d :f :i :a)
&nbsp;
priority-map-1.core=&gt; <strong>(vals p1r)</strong>
(3 5 10 2 3 6 0 4 1 7)
</pre>

<p>Přístup k&nbsp;mapě jako k&nbsp;sekvenci:</p>

<pre>
priority-map-1.core=&gt; <strong>(doseq [[key val] p1r] (println key val))</strong>
:e 3
:g 5
:c 10
:j 2
:h 3
:b 6
:d 0
:f 4
:i 1
:a 7
</pre>

<p>A nakonec si ukažme prázdnou mapu:</p>

<pre>
priority-map-1.core=&gt; <strong>(def p1e (hash-map))</strong>
#'priority-map-1.core/p1e
&nbsp;
priority-map-1.core=&gt; <strong>p1e</strong>
{}
</pre>

<p>Mapa podporuje i univerzální &bdquo;spojovací&ldquo; operaci
<strong>conj</strong>. Výsledkem je nová mapa:</p>

<pre>
priority-map-1.core=&gt; <strong>(conj p1 {:foo 99})</strong>
{:a 2 :b 1 :c 3 :d 5 :e 4 :f 3 :foo 99 :g 0 :h 10 :i 6 :j 7}
</pre>

<p>Prvek je možné přepsat:</p>

<pre>
priority-map-1.core=&gt; <strong>(conj p1 {:a 99})</strong>
{:a 99 :b 1 :c 3 :d 5 :e 4 :f 3 :g 0 :h 10 :i 6 :j 7}
</pre>

<p>Naproti tomu hash mapa NEpodporuje operace <strong>peek</strong> a
<strong>pop</strong>, a to kvůli &bdquo;náhodnému&ldquo; pořadí prvků:</p>

<pre>
priority-map-1.core=&gt; <strong>(peek p1)</strong>
Execution error (ClassCastException) at priority-map-1.core/eval5764 (form-init1137606523006859476.clj:1).
clojure.lang.PersistentHashMap cannot be cast to clojure.lang.IPersistentStack
&nbsp;
priority-map-1.core=&gt; <strong>(pop p1)</strong>
Execution error (ClassCastException) at priority-map-1.core/eval5766 (form-init1137606523006859476.clj:1).
clojure.lang.PersistentHashMap cannot be cast to clojure.lang.IPersistentStack
</pre>



<p><a name="k11"></a></p>
<h2 id="k11">11. Otestování vlastností mapy typu <strong>sorted-map</strong></h2>

<p>Mapa typu <i>sorted map</i> je interně založena na RB stromech, v&nbsp;nichž
jsou prvky rozmístěny do jednotlivých uzlů na základě porovnání klíčů
s&nbsp;klíči jiných prvků. Při sekvenčním přístupu k&nbsp;mapě jsou prvky
seřazeny podle klíčů, přičemž záleží na použitém <i>komparátoru</i>. Například
pro čísla se porovnávají jejich hodnoty, řetězce a keywords jsou seřazeny
lexikograficky atd. Samozřejmě lze použít i vlastní komparátor.</p>

<p>Konstruktorem tohoto typu mapy je funkce <strong>sorted-map</strong>:</p>

<pre>
priority-map-1.core=&gt; <strong>(doc sorted-map)</strong>
-------------------------
clojure.core/sorted-map
([&amp; keyvals])
  keyval =&gt; key val
  Returns a new sorted map with supplied mappings.  If any keys are
  equal, they are handled as if by repeated uses of assoc.
nil
</pre>

<p>Vytvoříme si tedy tento typ mapy s&nbsp;několika prvky:</p>

<pre>
priority-map-1.core=&gt; <strong>(def p2 (sorted-map :a 2 :b 1 :c 3 :d 5 :e 4 :f 3 :g 0 :h 10 :i 6 :j 7))</strong>
#'priority-map-1.core/p2
</pre>

<p>Nyní jsou prvky skutečně zařazeny podle hodnoty klíče, a to nejenom zdánlivě
při tisku obsahu mapy, ale i při přístupu ke klíčům či přímo
k&nbsp;hodnotám:</p>

<pre>
priority-map-1.core=&gt; <strong>(keys p2)</strong>
(:a :b :c :d :e :f :g :h :i :j)
&nbsp;
priority-map-1.core=&gt; <strong>(vals p2)</strong>
(2 1 3 5 4 3 0 10 6 7)
&nbsp;
priority-map-1.core=&gt; <strong>p2</strong>
{:a 2 :b 1 :c 3 :d 5 :e 4 :f 3 :g 0 :h 10 :i 6 :j 7}
</pre>

<p>Zde se ukazuje zásadní rozdíl oproti hash mapám:</p>

<pre>
priority-map-1.core=&gt; <strong>(doseq [[key val] p2] (println key val))</strong>
:a 2
:b 1
:c 3
:d 5
:e 4
:f 3
:g 0
:h 10
:i 6
:j 7
</pre>

<p>Převedení mapy na sekvenci ukazuje seřazení prvků podle hodnoty klíče:</p>

<pre>
priority-map-1.core=&gt; <strong>(seq p2)</strong>
([:a 2] [:b 1] [:c 3] [:d 5] [:e 4] [:f 3] [:g 0] [:h 10] [:i 6] [:j 7])
</pre>

<p>Do mapy lze prvky vložit (při její konstrukci) v&nbsp;libovolném pořadí:</p>

<pre>
priority-map-1.core=&gt; <strong>(def p2r (sorted-map :j 2 :i 1 :h 3 :g 5 :f 4 :e 3 :d 0 :c 10 :b 6 :a 7))</strong>
#'priority-map-1.core/p2r
</pre>

<p>Ovšem interně bude struktura stejná, jako v&nbsp;předchozím případě (prvky
seřazeny podle hodnoty klíče):</p>

<pre>
priority-map-1.core=&gt; <strong>p2r</strong>
{:a 7 :b 6 :c 10 :d 0 :e 3 :f 4 :g 5 :h 3 :i 1 :j 2}
&nbsp;
priority-map-1.core=&gt; <strong>(keys p2r)</strong>
(:a :b :c :d :e :f :g :h :i :j)
&nbsp;
priority-map-1.core=&gt; <strong>(vals p2r)</strong>
(7 6 10 0 3 4 5 3 1 2)
&nbsp;
priority-map-1.core=&gt; <strong>(doseq [[key val] p2r] (println key val))</strong>
:a 7
:b 6
:c 10
:d 0
:e 3
:f 4
:g 5
:h 3
:i 1
:j 2
</pre>

<p>Pochopitelně je podporována i práce s&nbsp;prázdnou mapou:</p>

<pre>
priority-map-1.core=&gt; <strong>(def p2e (sorted-map))</strong>
#'priority-map-1.core/p2e
&nbsp;
priority-map-1.core=&gt; <strong>p2e</strong>
{}
</pre>

<p>Specifikace vlastního komparátoru (velmi užitečná vlastnost):</p>

<pre>
priority-map-1.core=&gt; <strong>(sorted-map-by (comparator &lt;) 0 :a 1 :b 2 :c)</strong>
{0 :a 1 :b 2 :c}
&nbsp;
priority-map-1.core=&gt; <strong>(sorted-map-by (comparator &gt;) 0 :a 1 :b 2 :c)</strong>
{2 :c 1 :b 0 :a}
</pre>

<p>Konverze na jiný typ mapy zajišťuje funkce <strong>into</strong>:</p>

<pre>
priority-map-1.core=&gt; <strong>(into (hash-map) p2)</strong>
{:a 2 :b 1 :c 3 :d 5 :e 4 :f 3 :g 0 :h 10 :i 6 :j 7}
</pre>

<p>Výsledek vypadá stejně, takže si raději prohlédněme typy:</p>

<pre>
priority-map-1.core=&gt; <strong>(type p2)</strong>
#&lt;Class@4fcabd1a <u>clojure.lang.PersistentTreeMap</u>&gt;
&nbsp;
priority-map-1.core=&gt; <strong>(type (into (hash-map) p2))</strong>
#&lt;Class@78047b92 <u>clojure.lang.PersistentHashMap</u>&gt;
</pre>



<p><a name="k12"></a></p>
<h2 id="k12">12. Otestování vlastností mapy typu <strong>array-map</strong></h2>

<p>Třetím základním typem mapy je <i>array-map</i>. V&nbsp;této mapě si prvky
zachovávají pořadí, v&nbsp;jakém byly do mapy vloženy, což však má za následek
méně efektivní přístup k&nbsp;jednotlivým prvkům přes jejich klíč.
Konstruktorem této mapy je funkce <strong>array-map</strong>:</p>

<pre>
priority-map-1.core=&gt; <strong>(doc array-map)</strong>
-------------------------
clojure.core/array-map
([] [&amp; keyvals])
  Constructs an array-map. If any keys are equal, they are handled as
  if by repeated uses of assoc.
</pre>

<p>Vytvořme si nyní hodnotu typu <i>array-map</i>, navážeme na symbol a
zobrazíme ji:</p>

<pre>
priority-map-1.core=&gt; <strong>(def p3 (array-map :a 2 :b 1 :c 3 :d 5 :e 4 :f 3 :g 0 :h 10 :i 6 :j 7))</strong>
#'priority-map-1.core/p3
&nbsp;
priority-map-1.core=&gt; <strong>p3</strong>
{:a 2 :b 1 :c 3 :d 5 :e 4 :f 3 :g 0 :h 10 :i 6 :j 7}
</pre>

<p>Funkce <strong>keys</strong> a <strong>vals</strong> naznačují, jak jsou
prvky v&nbsp;této mapě seřazeny:</p>

<pre>
priority-map-1.core=&gt; <strong>(keys p3)</strong>
(:a :b :c :d :e :f :g :h :i :j)
&nbsp;
priority-map-1.core=&gt; <strong>(vals p3)</strong>
(2 1 3 5 4 3 0 10 6 7)
</pre>

<p>Ovšem přesnější údaje nám dá explicitně zapsaná iterace nad všemi prvky
mapy:</p>

<pre>
priority-map-1.core=&gt; <strong>(doseq [[key val] p3] (println key val))</strong>
:a 2
:b 1
:c 3
:d 5
:e 4
:f 3
:g 0
:h 10
:i 6
:j 7
</pre>

<p>Převod na sekvenci:</p>

<pre>
priority-map-1.core=&gt; <strong>(seq p3)</strong>
([:a 2] [:b 1] [:c 3] [:d 5] [:e 4] [:f 3] [:g 0] [:h 10] [:i 6] [:j 7])
</pre>

<p>Mapa, v&nbsp;níž jsou prvky na začátku uspořádány v&nbsp;opačném pořadí,
zachová toto nové pořadí:</p>

<pre>
priority-map-1.core=&gt; <strong>(def p3r (array-map :j 2 :i 1 :h 3 :g 5 :f 4 :e 3 :d 0 :c 10 :b 6 :a 7))</strong>
#'priority-map-1.core/p3r
&nbsp;
priority-map-1.core=&gt; <strong>p3r</strong>
{:a 7 :b 6 :c 10 :d 0 :e 3 :f 4 :g 5 :h 3 :i 1 :j 2}
&nbsp;
priority-map-1.core=&gt; <strong>(keys p3r)</strong>
(:j :i :h :g :f :e :d :c :b :a)
&nbsp;
priority-map-1.core=&gt; <strong>(vals p3r)</strong>
(2 1 3 5 4 3 0 10 6 7)
&nbsp;
priority-map-1.core=&gt; <strong>(doseq [[key val] p3r] (println key val))</strong>
:j 2
:i 1
:h 3
:g 5
:f 4
:e 3
:d 0
:c 10
:b 6
:a 7
</pre>

<p>Při převodech mezi různými typy map se pořadí prvků podle očekávání ztratí:</p>

<pre>
priority-map-1.core=&gt; <strong>(def p3-hash (into (hash-map) p3))</strong>
#'priority-map-1.core/p3-hash
&nbsp;
priority-map-1.core=&gt; <strong>(keys p3-hash)</strong>
(:e :g :c :j :h :b :d :f :i :a)
&nbsp;
priority-map-1.core=&gt; <strong>(def p3-back (into (array-map) p3-hash))</strong>
#'priority-map-1.core/p3-back
&nbsp;
priority-map-1.core=&gt; <strong>(keys p3-back)</strong>
(:e :g :c :j :h :b :d :f :i :a)
</pre>



<p><a name="k13"></a></p>
<h2 id="k13">13. Otestování vlastností mapy typu <strong>priority-map</strong></h2>

<p>Posledním typem mapy, jejíž základní vlastnosti testujeme, je <i>priority
map</i>. Její konstruktor se jmenuje jednoznačně &ndash;
<strong>priority-map</strong>:</p>

<pre>
priority-map-1.core=&gt; <strong>(doc priority-map)</strong>
-------------------------
clojure.data.priority-map/priority-map
([&amp; keyvals])
  Usage: (priority-map key val key val ...)
  Returns a new priority map with optional supplied mappings.
  (priority-map) returns an empty priority map.
</pre>

<p>Zkusme si nyní vytvořit a zobrazit novou prioritní mapu:</p>

<pre>
priority-map-1.core=&gt; <strong>(def p4 (priority-map :a 2 :b 1 :c 3 :d 5 :e 4 :f 3 :g 0 :h 10 :i 6 :j 7))</strong>
#'priority-map-1.core/p4
&nbsp;
priority-map-1.core=&gt; <strong>p4</strong>
{:g 0 :b 1 :a 2 :c 3 :f 3 :e 4 :d 5 :i 6 :j 7 :h 10}
</pre>

<p>Nyní se dostáváme k&nbsp;základní a unikátní vlastnosti prioritní mapy
&ndash; prvky jsou v&nbsp;ní uspořádány podle své hodnoty, nikoli podle svého
klíče:</p>

<pre>
priority-map-1.core=&gt; <strong>(keys p4)</strong>
(:g :b :a :c :f :e :d :i :j :h)
&nbsp;
priority-map-1.core=&gt; <strong>(vals p4)</strong>
(0 1 2 3 3 4 5 6 7 10)
</pre>

<p>Převod na sekvenci ukazuje stejné uspořádání:</p>

<pre>
priority-map-1.core=&gt; <strong>(seq p4)</strong>
([:g 0] [:b 1] [:a 2] [:c 3] [:f 3] [:e 4] [:d 5] [:i 6] [:j 7] [:h 10])
</pre>

<p>Otestujme tuto vlastnost ještě na mapě s&nbsp;jinak zadanými prvky:</p>

<pre>
priority-map-1.core=&gt; <strong>(def p4r (priority-map :j 2 :i 1 :h 3 :g 5 :f 4 :e 3 :d 0 :c 10 :b 6 :a 7))</strong>
#'priority-map-1.core/p4r
&nbsp;
priority-map-1.core=&gt; <strong>(keys p4r)</strong>
(:d :i :j :e :h :f :g :b :a :c)
&nbsp;
priority-map-1.core=&gt; <strong>(vals p4r)</strong>
(0 1 2 3 3 4 5 6 7 10)
</pre>

<p>Prázdnou mapu je možné taktéž použít:</p>

<pre>
priority-map-1.core=&gt; <strong>(def p4e (priority-map))</strong>
#'priority-map-1.core/p4e
&nbsp;
priority-map-1.core=&gt; <strong>p4e</strong>
{}
</pre>

<p>Převody prvků z&nbsp;jiných map do prioritní mapy:</p>

<pre>
priority-map-1.core=&gt; <strong>(into (priority-map) p1)</strong>
{:g 0 :b 1 :a 2 :c 3 :f 3 :e 4 :d 5 :i 6 :j 7 :h 10}
&nbsp;
priority-map-1.core=&gt; <strong>(into (priority-map) p2)</strong>
{:g 0 :b 1 :a 2 :c 3 :f 3 :e 4 :d 5 :i 6 :j 7 :h 10}
&nbsp;
priority-map-1.core=&gt; <strong>(into (priority-map) p3)</strong>
{:g 0 :b 1 :a 2 :c 3 :f 3 :e 4 :d 5 :i 6 :j 7 :h 10}
</pre>

<p>S&nbsp;využitím <i>threading makra</i> zobrazíme uspořádání hodnot
v&nbsp;prioritní mapě vzniklé konverzí z&nbsp;jiného typu mapy:</p>

<pre>
priority-map-1.core=&gt; <strong>(->> p1 (into (priority-map)) vals)</strong>
(0 1 2 3 3 4 5 6 7 10)
&nbsp;
priority-map-1.core=&gt; <strong>(->> p2 (into (priority-map)) vals)</strong>
(0 1 2 3 3 4 5 6 7 10)
&nbsp;
priority-map-1.core=&gt; <strong>(->> p3 (into (priority-map)) vals)</strong>
(0 1 2 3 3 4 5 6 7 10)
</pre>

<p><div class="rs-tip-major">Poznámka: pochopitelně nejsme omezeni pouze na
celočíselné prvky; použít lze jakýkoli hodnoty, které jsou navzájem
porovnatelné:</div></p>

<pre>
priority-map-1.core=&gt; <strong>(priority-map :a "foo" :b "bar" :c "zzz" :d "aaa")</strong>
{:d "aaa" :b "bar" :a "foo" :c "zzz"}
</pre>

<p>Pokus o použití prvků, které nelze navzájem porovnat:</p>

<pre>
priority-map-1.core=&gt; <strong>(priority-map :a "foo" :b "bar" :c "zzz" :d 0)</strong>
Execution error (ClassCastException) at clojure.data.priority_map.PersistentPriorityMap/assoc (priority_map.clj:302).
java.lang.String cannot be cast to java.lang.Number
</pre>



<p><a name="k14"></a></p>
<h2 id="k14">14. Základní operace s&nbsp;mapami: <strong>assoc</strong> a <strong>dissoc</strong></h2>

<p>Mezi dvě základní operace, které je možné provádět s&nbsp;mapami, patří
operace reprezentované funkcemi nazvanými <strong>assoc</strong> a
<strong>dissoc</strong>. První z&nbsp;těchto funkcí přidá k&nbsp;již existující
mapě novou dvojici klíč-hodnota (či několik dvojic klíč-hodnota) a vrátí novou
mapu rozšířenou o tyto prvky (mapy jsou totiž neměnné datové typy, podobně jako
seznamy a vektory). Druhá funkce &ndash; <strong>dissoc</strong> &ndash; plní
opačnou roli, protože z&nbsp;nějaké mapy odstraní dvojici/e klíč-hodnota pro
zadaný klíč či několik klíčů (jediným voláním <strong>dissoc</strong> je tedy
možné odstranit více prvků). I tato funkce nemění původní mapu, ale vrací
namísto toho novou datovou strukturu, která ovšem s&nbsp;původní mapou většinu
prvků sdílí:</p>

<pre>
priority-map-1.core=&gt; <strong>(doc assoc)</strong>
-------------------------
clojure.core/assoc
([map key val] [map key val &amp; kvs])
  assoc[iate]. When applied to a map, returns a new map of the
    same (hashed/sorted) type, that contains the mapping of key(s) to
    val(s). When applied to a vector, returns a new vector that
    contains val at index. Note - index must be &lt;= (count vector).
&nbsp;
&nbsp;
priority-map-1.core=&gt; <strong>(doc dissoc)</strong>
-------------------------
clojure.core/dissoc
([map] [map key] [map key &amp; ks])
  dissoc[iate]. Returns a new map of the same (hashed/sorted) type,
  that does not contain a mapping for key(s).
</pre>

<p>Ukažme si chování obou zmíněných funkcí <strong>assoc</strong> a
<strong>dissoc</strong> na jednoduchém příkladu:</p>

<p>Nejprve vytvoříme mapu, jejímiž klíči jsou symboly a hodnotami řetězce
(zejména použití symbolů pro klíče je v&nbsp;Clojure idiomatické, což jsme si
již ukázali výše):</p>

<pre>
priority-map-1.core=&gt; <strong>(def client {:id 42</strong>
  #_=&gt;              <strong>:name "Sheldon"</strong>
  #_=&gt;              <strong>:surname "Cooper"</strong>
  #_=&gt;              <strong>:real-name "Jim Parsons"})</strong>
#'user/client
</pre>

<p>Zobrazíme obsah této mapy (povšimněte si, že prvky jsou zobrazeny náhodně,
protože se jedná o hashmapu):</p>

<pre>
priority-map-1.core=&gt; <strong>client</strong>
{:name "Sheldon", :surname "Cooper", :id 42, :real-name "Jim Parsons"}
</pre>

<p>Funkcí <strong>assoc</strong> vytvoříme novou mapu, do níž bude přidán další
prvek:</p>

<pre>
priority-map-1.core=&gt; <strong>(assoc client :iq 187)</strong>
{:name "Sheldon", :surname "Cooper", :iq 187, :id 42, :real-name "Jim Parsons"}
</pre>

<p>Původní mapa zůstala nezměněna:</p>

<pre>
priority-map-1.core=&gt; <strong>client</strong>
{:name "Sheldon", :surname "Cooper", :id 42, :real-name "Jim Parsons"}
</pre>

<p>Funkcí <strong>dissoc</strong> vytvoříme mapu s&nbsp;odstraněným jedním
prvkem či dvěma prvky:</p>

<pre>
priority-map-1.core=&gt; <strong>(dissoc client :surname)</strong>
{:name "Sheldon", :id 42, :real-name "Jim Parsons"}
&nbsp;
priority-map-1.core=&gt; <strong>(dissoc client :name :surname)</strong>
{:id 42, :real-name "Jim Parsons"}
</pre>

<p>Opět se můžeme přesvědčit o tom, že původní mapa zůstala nezměněna:</p>

<pre>
priority-map-1.core=&gt; <strong>client</strong>
{:name "Sheldon", :surname "Cooper", :id 42, :real-name "Jim Parsons"}
</pre>

<p><div class="rs-tip-major">Poznámka: pro mapy existuje tranzientní
ekvivalent, pro nějž jsou definovány funkce <strong>assoc!</strong> a
<strong>dissoc!</strong> (s&nbsp;vykřičníkem na konci). Výsledné hodnoty těchto
funkcí jsou opět tranzientními mapami, které je možné v&nbsp;případě potřeby
navázat na symbol původní tranzientní mapy.</div></p>



<p><a name="k15"></a></p>
<h2 id="k15">15. Vyhledávání prvků, získání klíčů a hodnot</h2>

<p>Mezi další důležité operace, které se s&nbsp;mapami většinou provádí, patří
zjištění, zda mapa obsahuje prvek (tj.&nbsp;klíč-hodnota). Pro tento účel nám
Clojure nabízí hned několik funkcí. Opět si tyto funkce nejlépe odzkoušíme na
jednoduchých příkladech.</p>

<p>Funkce budou otestovány na mapě, jejímiž klíči jsou římské číslice a
hodnotami odpovídající číslice arabské:</p>

<pre>
priority-map-1.core=&gt; <strong>(def numbers {"I" 1 "II" 2 "III" 3 "IV" 4 "V" 5})</strong>
#'user/numbers
</pre>

<p>Zobrazíme obsah této mapy (povšimněte si, že prvky jsou zobrazeny náhodně,
protože se jedná o hashmapu:</p>

<pre>
priority-map-1.core=&gt; <strong>(println numbers)</strong>
{III 3, II 2, V 5, I 1, IV 4}
nil
</pre>

<p>První funkcí je predikát <strong>contains?</strong>, kde otazník naznačuje,
že se vždy vrací pravdivostní hodnota <strong>true</strong> či
<strong>false</strong> v&nbsp;závislosti na tom, zda v&nbsp;mapě existuje prvek
s&nbsp;daným klíčem:</p>

<pre>
priority-map-1.core=&gt; <strong>(contains? numbers "I")</strong>
true
&nbsp;
priority-map-1.core=&gt; <strong>(contains? numbers 1)</strong>
false
&nbsp;
priority-map-1.core=&gt; <strong>(contains? numbers "xyzzy")</strong>
false
</pre>

<p>Druhá důležitá funkce je <strong>get</strong>, která vrací hodnotu navázanou
na zadaný klíč popř.&nbsp;<strong>nil</strong>, pokud klíč nebyl nalezen. Pokud
se do mapy ukládají i hodnoty <strong>nil</strong>, nezbývá většinou nic
jiného, než kombinace <strong>get+contains?</strong>:</p>

<pre>
priority-map-1.core=&gt; <strong>(get numbers "V")</strong>
5
&nbsp;
priority-map-1.core=&gt; <strong>(get numbers "xyzzy")</strong>
nil
</pre>

<p>Funkce <strong>find</strong> je podobná funkci <strong>get</strong>, ale
namísto hodnoty navázané na klíč vrací dvojici klíč+hodnota:</p>

<pre>
priority-map-1.core=&gt; <strong>(find numbers "V")</strong>
["V" 5]
&nbsp;
priority-map-1.core=&gt; <strong>(find numbers "xyzzy")</strong>
nil
&nbsp;
priority-map-1.core=&gt; <strong>(type (find numbers "V"))</strong>
clojure.lang.MapEntry
</pre>

<p>Získat je možné všechny klíče, všechny hodnoty či provést selekci na základě
sekvence klíčů (to jsme si již odzkoušeli u všech typů map výše):</p>

<pre>
priority-map-1.core=&gt; <strong>(keys numbers)</strong>
("III" "II" "V" "I" "IV")
&nbsp;
priority-map-1.core=&gt; <strong>(vals numbers)</strong>
(3 2 5 1 4)
&nbsp;
priority-map-1.core=&gt; <strong>(select-keys numbers ["I" "IV" "V"])</strong>
{"V" 5, "IV" 4, "I" 1}
&nbsp;
priority-map-1.core=&gt; <strong>(select-keys numbers ["I" "IV" "neznamy"])</strong>
{"IV" 4, "I" 1}
</pre>

<p>Výběr jednoho prvku je možné provést i tím, že se zapíše volání
<strong>(klíč mapa)</strong>, což je v&nbsp;Clojure idiomatické:</p>

<pre>
priority-map-1.core=&gt; <strong>(def numbers1 {:I 1 :II 2 :III 3 :IV 4 :V 5 :VI 6})</strong>
#'user/numbers1
&nbsp;
priority-map-1.core=&gt; <strong>(:III numbers1)</strong>
3
</pre>

<p>Podívejme se na praktičtější příklad používající mapu namísto
struktury/záznamu a dvojí způsob získání jedné hodnoty na základě klíče:</p>

<pre>
priority-map-1.core=&gt; <strong>(def client {:id 42</strong>
  #_=&gt;              <strong>:name "Sheldon"</strong>
  #_=&gt;              <strong>:surname "Cooper"</strong>
  #_=&gt;              <strong>:real-name "Jim Parsons"})</strong>
#'user/client
&nbsp;
priority-map-1.core=&gt; <strong>client</strong>
{:name "Sheldon", :surname "Cooper", :id 42, :real-name "Jim Parsons"}
&nbsp;
priority-map-1.core=&gt; <strong>(get client :name)</strong>
"Sheldon"
&nbsp;
priority-map-1.core=&gt; <strong>(:name client)</strong>
"Sheldon"
</pre>

<p><div class="rs-tip-major">Poznámka: toto je velmi flexibilní a funkcionálně
pojatá náhrada za hodnotové objekty.</div></p>



<p><a name="k16"></a></p>
<h2 id="k16">16. Operace <strong>merge</strong> a <strong>zipmap</strong></h2>

<p>Posledními dvěma důležitými operacemi nad mapami, s&nbsp;nimiž se lze
v&nbsp;reálných aplikacích velmi často setkat, jsou operace reprezentované
funkcemi <strong>merge</strong> a <strong>zipmap</strong>. Funkce nazvaná
<strong>merge</strong> slouží ke spojení dvou či většího množství map. Nejprve
opět použijeme známou strukturu obsahující základní informace o Sheldonovi:</p>

<pre>
priority-map-1.core=&gt; <strong>(def client {:id 42</strong>
  #_=&gt;              <strong>:name "Sheldon"</strong>
  #_=&gt;              <strong>:surname "Cooper"</strong>
  #_=&gt;              <strong>:real-name "Jim Parsons"})</strong>
#'user/client
&nbsp;
priority-map-1.core=&gt; <strong>client</strong>
{:name "Sheldon", :surname "Cooper", :id 42, :real-name "Jim Parsons"}
</pre>

<p>Nyní zavoláme funkci <strong>merge</strong>, jejímž výsledkem bude nová
mapa:</p>

<pre>
priority-map-1.core=&gt; <strong>(merge client {:iq 187 :degrees ["Ph.D." "Sc.D."]})</strong>
{:name "Sheldon", :surname "Cooper", :iq 187, :id 42, :degrees ["Ph.D." "Sc.D."], :real-name "Jim Parsons"}
</pre>

<p>Původní mapa zůstala nezměněna:</p>

<pre>
priority-map-1.core=&gt; <strong>client</strong>
{:name "Sheldon", :surname "Cooper", :id 42, :real-name "Jim Parsons"}
</pre>

<p>Lépe bude patrný význam funkce <strong>merge</strong> u map se shodnými
klíči. Při spojování v&nbsp;takovém případě &bdquo;vyhraje&ldquo; hodnota
uložená v&nbsp;poslední mapě vstupující do <strong>merge</strong>:</p>

<pre>
priority-map-1.core=&gt; <strong>(def numbers1 {"I" 1 "II" 2 "III" 3 "IV" 4 "V" 5 "VI" 6})</strong>
#'user/numbers1
&nbsp;
priority-map-1.core=&gt; <strong>(def numbers2 {"VI" "sest" "VII" 7 "VIII" 8 "IX" 9 "X" 9})</strong>
#'user/numbers2
&nbsp;
priority-map-1.core=&gt; <strong>(merge numbers1 numbers2)</strong>
{"III" 3, "VIII" 8, "II" 2, "V" 5, "VII" 7, "X" 9, "VI" "sest", "IX" 9, "I" 1, "IV" 4}
</pre>

<p>Ovšem:</p>

<pre>
priority-map-1.core=&gt; <strong>(merge numbers2 numbers1)</strong>
{"III" 3, "VIII" 8, "II" 2, "V" 5, "VII" 7, "X" 9, "VI" 6, "IX" 9, "I" 1, "IV" 4}
</pre>

<p>Velmi užitečná je v&nbsp;praxi funkce nazvaná <strong>zipmap</strong>, která
umožňuje zkombinovat dvě sekvence do jediné mapy. První sekvence obsahuje
klíče, druhá sekvence hodnoty. Můžeme tedy psát například:</p>

<pre>
priority-map-1.core=&gt; <strong>(zipmap ["I" "II" "III" "IV" "V" "VI"]</strong>
  #_=&gt;         <strong>[1 2 3 4 5 6])</strong>
{"VI" 6, "V" 5, "IV" 4, "III" 3, "II" 2, "I" 1}
</pre>

<p>Pravověrný Clojure programátor by ovšem napsal (se stejným výsledkem):</p>

<pre>
priority-map-1.core=&gt; <strong>(zipmap ["I" "II" "III" "IV" "V" "VI"]</strong>
  #_=&gt;         <strong>(range 1 7))</strong>
{"VI" 6, "V" 5, "IV" 4, "III" 3, "II" 2, "I" 1}
</pre>

<p>Pozor ovšem na to, že <strong>zipmap</strong> nejde jednoduše použít
s&nbsp;nekonečnými lazy sekvencemi. Toto není dobrý nápad:</p>

<pre>
(zipmap (range) (repeat 42))
</pre>

<p>(Stačí ovšem, aby první sekvence byla konečná).</p>



<p><a name="k17"></a></p>
<h2 id="k17">17. Specifické operace pro <strong>priority-map</strong></h2>

<p>Funkce <strong>assoc</strong> vrací v&nbsp;případě prioritní mapy novou mapu
s&nbsp;přeuspořádanými prvky:</p>

<pre>
priority-map-1.core=&gt; <strong>(assoc p4 :e 100)</strong>
{:g 0 :b 1 :a 2 :c 3 :f 3 :d 5 :i 6 :j 7 :h 10 :e 100}
&nbsp;
priority-map-1.core=&gt; <strong>(assoc p4 :i -100)</strong>
{:i -100 :g 0 :b 1 :a 2 :c 3 :f 3 :e 4 :d 5 :j 7 :h 10}
</pre>

<p>Operace <strong>conj</strong> dovoluje vytvořit novou mapu
s&nbsp;připojenými novými prvky:</p>

<pre>
priority-map-1.core=&gt; <strong>(doc conj)</strong>
-------------------------
clojure.core/conj
([coll x] [coll x &amp; xs])
  conj[oin]. Returns a new collection with the xs
    'added'. (conj nil item) returns (item).  The 'addition' may
    happen at different 'places' depending on the concrete type.
</pre>

<p>Takto to vypadá v&nbsp;praxi:</p>

<pre>
priority-map-1.core=&gt; <strong>(conj p4 {:foo 99})</strong>
{:g 0 :b 1 :a 2 :c 3 :f 3 :e 4 :d 5 :i 6 :j 7 :h 10 :foo 99}
&nbsp;
priority-map-1.core=&gt; <strong>(conj p4 {:bar 0})</strong>
{:bar 0 :g 0 :b 1 :a 2 :c 3 :f 3 :e 4 :d 5 :i 6 :j 7 :h 10}
</pre>

<p>Ovšem &ndash; na rozdíl od běžných map &ndash; je kontrolován typ nově
vkládané hodnoty:</p>

<pre>
priority-map-1.core=&gt; <strong>(conj p4 {:foo :bar})</strong>
Execution error (ClassCastException) at clojure.data.priority_map.PersistentPriorityMap/assoc (priority_map.clj:302).
java.lang.Long cannot be cast to clojure.lang.Keyword
</pre>

<p>Další funkce umožňuje měnit hodnotu prvku se zadaným klíčem aplikací nějaké
funkce:</p>

<pre>
priority-map-1.core=&gt; <strong>(doc update)</strong>
-------------------------
clojure.core/update
([m k f] [m k f x] [m k f x y] [m k f x y z] [m k f x y z &amp; more])
  'Updates' a value in an associative structure, where k is a
  key and f is a function that will take the old value
  and any supplied args and return the new value, and returns a new
  structure.  If the key does not exist, nil is passed as the old value.
</pre>

<p>Pro ostatní typy map tato operace nemění pořadí prvků, ovšem pro prioritní
mapy tomu tak být může:</p>

<pre>
priority-map-1.core=&gt; <strong>(update p4 :g inc)</strong>
{:g 1 :b 1 :a 2 :c 3 :f 3 :e 4 :d 5 :i 6 :j 7 :h 10}
&nbsp;
priority-map-1.core=&gt; <strong>(update p4 :e #(*2 %))</strong>
{:e nil :g 0 :b 1 :a 2 :c 3 :f 3 :d 5 :i 6 :j 7 :h 10}
</pre>

<p>Velmi specifické jsou operace <strong>peek</strong> a
<strong>pop</strong>:</p>

<pre>
priority-map-1.core=&gt; <strong>(doc peek)</strong>
-------------------------
clojure.core/peek
([coll])
  For a list or queue, same as first, for a vector, same as, but much
  more efficient than, last. If the collection is empty, returns nil.
&nbsp;
priority-map-1.core=&gt; <strong>(doc pop)</strong>
-------------------------
clojure.core/pop
([coll])
  For a list or queue, returns a new list/queue without the first
  item, for a vector, returns a new vector without the last item. If
  the collection is empty, throws an exception.  Note - not the same
  as next/butlast.
</pre>

<p>Tyto operace nelze u běžných map jiných typů použít:</p>

<pre>
priority-map-1.core=&gt; <strong>(peek p1)</strong>
Execution error (ClassCastException) at priority-map-1.core/eval6095 (form-init1137606523006859476.clj:1).
clojure.lang.PersistentHashMap cannot be cast to clojure.lang.IPersistentStack
&nbsp;
priority-map-1.core=&gt; <strong>(pop p1)</strong>
Execution error (ClassCastException) at priority-map-1.core/eval6097 (form-init1137606523006859476.clj:1).
clojure.lang.PersistentHashMap cannot be cast to clojure.lang.IPersistentStack
&nbsp;
priority-map-1.core=&gt; <strong>(peek p2)</strong>
Execution error (ClassCastException) at priority-map-1.core/eval6099 (form-init1137606523006859476.clj:1).
clojure.lang.PersistentTreeMap cannot be cast to clojure.lang.IPersistentStack
&nbsp;
priority-map-1.core=&gt; <strong>(pop p2)</strong>
Execution error (ClassCastException) at priority-map-1.core/eval6101 (form-init1137606523006859476.clj:1).
clojure.lang.PersistentTreeMap cannot be cast to clojure.lang.IPersistentStack
&nbsp;
priority-map-1.core=&gt; <strong>(peek p3)</strong>
Execution error (ClassCastException) at priority-map-1.core/eval6103 (form-init1137606523006859476.clj:1).
clojure.lang.PersistentArrayMap cannot be cast to clojure.lang.IPersistentStack
&nbsp;
priority-map-1.core=&gt; <strong>(pop p3)</strong>
Execution error (ClassCastException) at priority-map-1.core/eval6109 (form-init1137606523006859476.clj:1).
clojure.lang.PersistentArrayMap cannot be cast to clojure.lang.IPersistentStack
</pre>

<p>Tyto operace jsou určeny pro práci se sekvencemi (získanými například
z&nbsp;vektorů, front nebo seznamů, popř.&nbsp;z&nbsp;nekonečných sekvencí),
ovšem pro účely prioritní mapy byly redefinovány:</p>

<pre>
priority-map-1.core=&gt; <strong>p4</strong>
{:g 0 :b 1 :a 2 :c 3 :f 3 :e 4 :d 5 :i 6 :j 7 :h 10}
&nbsp;
priority-map-1.core=&gt; <strong>(pop p4)</strong>
{:b 1 :a 2 :c 3 :f 3 :e 4 :d 5 :i 6 :j 7 :h 10}
&nbsp;
priority-map-1.core=&gt; <strong>(peek p4)</strong>
[:g 0]
</pre>

<p>Z&nbsp;předchozích příkladů je patrné, že <strong>pop</strong> vrací mapu
bez prvku s&nbsp;nejnižší prioritou, zatímco <strong>peek</strong> vrací právě
onen prvek s&nbsp;nejnižší prioritou. Toto jsou dvě ze tří operací prioritní
fronty; třetí operací je přidání prvku, což zajišťuje nám již známá funkce
<strong>conj</strong>.</p>

<p>Nakonec si ukažme filtraci prvků podle jejich priority:</p>

<pre>
priority-map-1.core=&gt; <strong>(subseq p4 &lt; 4)</strong>
([:g 0] [:b 1] [:a 2] [:c 3] [:f 3])
&nbsp;
priority-map-1.core=&gt; <strong>(subseq p4 &gt; 4)</strong>
([:d 5] [:i 6] [:j 7] [:h 10])
</pre>

<p><div class="rs-tip-major">Poznámka: vidíme, že prioritní mapy jsou sice
poměrně úzce zaměřeným, ovšem na druhou stranu flexibilním a užitečným datovým
typem, který by se mohl stát součástí základní knihovny jazyka Clojure (podobně
jako prioritní fronty).</div></p>



<p><a name="k18"></a></p>
<h2 id="k18">18. Repositář s&nbsp;demonstračním příkladem</h2>

<p>Projekt, v&nbsp;němž je definována závislost na knihovně s&nbsp;prioritní
mapou, byl uložen do Git repositáře, který je dostupný na adrese <a
href="https://github.com/tisnik/clojure-examples/">https://github.com/tisnik/clojure-examples/</a>.
Konkrétně se jedná o projekt nazvaný <strong>priority-map</strong> (<a
href="https://github.com/tisnik/clojure-examples/tree/master/priority-map-1">https://github.com/tisnik/clojure-examples/tree/master/priority-map-1</a>).</p>



<p><a name="k19"></a></p>
<h2 id="k19">19. Odkazy na předchozí části seriálu o programovacím jazyku Clojure</h2>

<ol>

<li>Clojure  1: Úvod<br />
<a href="http://www.root.cz/clanky/clojure-aneb-jazyk-umoznujici-tvorbu-bezpecnych-vicevlaknovych-aplikaci-pro-jvm/">http://www.root.cz/clanky/clojure-aneb-jazyk-umoznujici-tvorbu-bezpecnych-vicevlaknovych-aplikaci-pro-jvm/</a>
</li>

<li>Clojure  2: Symboly, kolekce atd.<br />
<a href="http://www.root.cz/clanky/clojure-aneb-jazyk-umoznujici-tvorbu-bezpecnych-vicevlaknovych-aplikaci-pro-jvm-2-cast/">http://www.root.cz/clanky/clojure-aneb-jazyk-umoznujici-tvorbu-bezpecnych-vicevlaknovych-aplikaci-pro-jvm-2-cast/</a>
</li>

<li>Clojure  3: Funkcionální programování<br />
<a href="http://www.root.cz/clanky/clojure-aneb-jazyk-umoznujici-tvorbu-bezpecnych-vicevlaknovych-aplikaci-pro-jvm-3-cast-funkcionalni-programovani/">http://www.root.cz/clanky/clojure-aneb-jazyk-umoznujici-tvorbu-bezpecnych-vicevlaknovych-aplikaci-pro-jvm-3-cast-funkcionalni-programovani/</a>
</li>

<li>Clojure  4: Kolekce, sekvence a lazy sekvence<br />
<a href="http://www.root.cz/clanky/clojure-aneb-jazyk-umoznujici-tvorbu-bezpecnych-vicevlaknovych-aplikaci-pro-jvm-4-cast-kolekce-sekvence-a-lazy-sekvence/">http://www.root.cz/clanky/clojure-aneb-jazyk-umoznujici-tvorbu-bezpecnych-vicevlaknovych-aplikaci-pro-jvm-4-cast-kolekce-sekvence-a-lazy-sekvence/</a>
</li>

<li>Clojure  5: Sekvence, lazy sekvence a paralelní programy<br />
<a href="http://www.root.cz/clanky/clojure-a-bezpecne-aplikace-pro-jvm-sekvence-lazy-sekvence-a-paralelni-programy/">http://www.root.cz/clanky/clojure-a-bezpecne-aplikace-pro-jvm-sekvence-lazy-sekvence-a-paralelni-programy/</a>
</li>

<li>Clojure  6: Podpora pro paralelní programování<br />
<a href="http://www.root.cz/clanky/programovaci-jazyk-clojure-6-futures-nejsou-jen-financni-derivaty/">http://www.root.cz/clanky/programovaci-jazyk-clojure-6-futures-nejsou-jen-financni-derivaty/</a>
</li>

<li>Clojure  7: Další funkce pro paralelní programování<br />
<a href="http://www.root.cz/clanky/programovaci-jazyk-clojure-7-dalsi-podpurne-prostredky-pro-paralelni-programovani/">http://www.root.cz/clanky/programovaci-jazyk-clojure-7-dalsi-podpurne-prostredky-pro-paralelni-programovani/</a>
</li>

<li>Clojure  8: Identity, stavy, neměnné hodnoty a reference<br />
<a href="http://www.root.cz/clanky/programovaci-jazyk-clojure-8-identity-stavy-nemenne-hodnoty-a-referencni-typy/">http://www.root.cz/clanky/programovaci-jazyk-clojure-8-identity-stavy-nemenne-hodnoty-a-referencni-typy/</a>
</li>

<li>Clojure  9: Validátory, pozorovatelé a kooperace s Javou<br />
<a href="http://www.root.cz/clanky/programovaci-jazyk-clojure-9-validatory-pozorovatele-a-kooperace-mezi-clojure-a-javou/">http://www.root.cz/clanky/programovaci-jazyk-clojure-9-validatory-pozorovatele-a-kooperace-mezi-clojure-a-javou/</a>
</li>

<li>Clojure 10: Kooperace mezi Clojure a Javou<br />
<a href="http://www.root.cz/clanky/programovaci-jazyk-clojure-10-kooperace-mezi-clojure-a-javou-pokracovani/">http://www.root.cz/clanky/programovaci-jazyk-clojure-10-kooperace-mezi-clojure-a-javou-pokracovani/</a>
</li>

<li>Clojure 11: Generátorová notace seznamu/list comprehension<br />
<a href="http://www.root.cz/clanky/programovaci-jazyk-clojure-11-generatorova-notace-seznamu-list-comprehension/">http://www.root.cz/clanky/programovaci-jazyk-clojure-11-generatorova-notace-seznamu-list-comprehension/</a>
</li>

<li>Clojure 12: Překlad programů z Clojure do bajtkódu JVM I:<br />
<a href="http://www.root.cz/clanky/programovaci-jazyk-clojure-12-preklad-programu-z-clojure-do-bajtkodu-jvm/">http://www.root.cz/clanky/programovaci-jazyk-clojure-12-preklad-programu-z-clojure-do-bajtkodu-jvm/</a>
</li>

<li>Clojure 13: Překlad programů z Clojure do bajtkódu JVM II:<br />
<a href="http://www.root.cz/clanky/programovaci-jazyk-clojure-13-preklad-programu-z-clojure-do-bajtkodu-jvm-pokracovani/">http://www.root.cz/clanky/programovaci-jazyk-clojure-13-preklad-programu-z-clojure-do-bajtkodu-jvm-pokracovani/</a>
</li>

<li>Clojure 14: Základy práce se systémem maker<br />
<a href="http://www.root.cz/clanky/programovaci-jazyk-clojure-14-zaklady-prace-se-systemem-maker/">http://www.root.cz/clanky/programovaci-jazyk-clojure-14-zaklady-prace-se-systemem-maker/</a>
</li>

<li>Clojure 15: Tvorba uživatelských maker<br />
<a href="http://www.root.cz/clanky/programovaci-jazyk-clojure-15-tvorba-uzivatelskych-maker/">http://www.root.cz/clanky/programovaci-jazyk-clojure-15-tvorba-uzivatelskych-maker/</a>
</li>

<li>Programovací jazyk Clojure &ndash; triky při práci s řetězci<br />
<a href="http://www.root.cz/clanky/programovaci-jazyk-clojure-triky-pri-praci-s-retezci/">http://www.root.cz/clanky/programovaci-jazyk-clojure-triky-pri-praci-s-retezci/</a>
</li>

<li>Programovací jazyk Clojure &ndash; triky při práci s kolekcemi<br />
<a href="http://www.root.cz/clanky/programovaci-jazyk-clojure-triky-pri-praci-s-kolekcemi/">http://www.root.cz/clanky/programovaci-jazyk-clojure-triky-pri-praci-s-kolekcemi/</a>
</li>

<li>Programovací jazyk Clojure &ndash; práce s mapami a množinami<br />
<a href="http://www.root.cz/clanky/programovaci-jazyk-clojure-prace-s-mapami-a-mnozinami/">http://www.root.cz/clanky/programovaci-jazyk-clojure-prace-s-mapami-a-mnozinami/</a>
</li>

<li>Programovací jazyk Clojure &ndash; základy zpracování XML<br />
<a href="http://www.root.cz/clanky/programovaci-jazyk-clojure-zaklady-zpracovani-xml/">http://www.root.cz/clanky/programovaci-jazyk-clojure-zaklady-zpracovani-xml/</a>
</li>

<li>Programovací jazyk Clojure &ndash; testování s využitím knihovny Expectations<br />
<a href="http://www.root.cz/clanky/programovaci-jazyk-clojure-testovani-s-vyuzitim-knihovny-expectations/">http://www.root.cz/clanky/programovaci-jazyk-clojure-testovani-s-vyuzitim-knihovny-expectations/</a>
</li>

<li>Programovací jazyk Clojure &ndash; některé užitečné triky použitelné (nejenom) v&nbsp;testech<br />
<a href="http://www.root.cz/clanky/programovaci-jazyk-clojure-nektere-uzitecne-triky-pouzitelne-nejenom-v-testech/">http://www.root.cz/clanky/programovaci-jazyk-clojure-nektere-uzitecne-triky-pouzitelne-nejenom-v-testech/</a>
</li>

<li>Enlive &ndash; výkonný šablonovací systém pro jazyk Clojure<br/>
<a href="http://www.root.cz/clanky/enlive-vykonny-sablonovaci-system-pro-jazyk-clojure/">http://www.root.cz/clanky/enlive-vykonny-sablonovaci-system-pro-jazyk-clojure/</a>
</li>

<li>Nástroj Leiningen a programovací jazyk Clojure: tvorba vlastních knihoven pro veřejný repositář Clojars<br />
<a href="http://www.root.cz/clanky/nastroj-leiningen-a-programovaci-jazyk-clojure-tvorba-vlastnich-knihoven-pro-verejny-repositar-clojars/">http://www.root.cz/clanky/nastroj-leiningen-a-programovaci-jazyk-clojure-tvorba-vlastnich-knihoven-pro-verejny-repositar-clojars/</a>
</li>

<li>Novinky v Clojure verze 1.8.0<br />
<a href="http://www.root.cz/clanky/novinky-v-clojure-verze-1-8-0/">http://www.root.cz/clanky/novinky-v-clojure-verze-1-8-0/</a>
</li>

<li>Asynchronní programování v&nbsp;Clojure s&nbsp;využitím knihovny core.async<br />
<a href="http://www.root.cz/clanky/asynchronni-programovani-v-clojure-s-vyuzitim-knihovny-core-async/">http://www.root.cz/clanky/asynchronni-programovani-v-clojure-s-vyuzitim-knihovny-core-async/</a>
</li>

<li>Asynchronní programování v&nbsp;Clojure s&nbsp;využitím knihovny core.async (pokračování)<br />
<a href="http://www.root.cz/clanky/asynchronni-programovani-v-clojure-s-vyuzitim-knihovny-core-async-pokracovani/">http://www.root.cz/clanky/asynchronni-programovani-v-clojure-s-vyuzitim-knihovny-core-async-pokracovani/</a>
</li>

<li>Asynchronní programování v Clojure s využitím knihovny core.async (dokončení)<br />
<a href="http://www.root.cz/clanky/asynchronni-programovani-v-clojure-s-vyuzitim-knihovny-core-async-dokonceni/">http://www.root.cz/clanky/asynchronni-programovani-v-clojure-s-vyuzitim-knihovny-core-async-dokonceni/</a>
</li>

<li>Vytváříme IRC bota v programovacím jazyce Clojure<br />
<a href="http://www.root.cz/clanky/vytvarime-irc-bota-v-programovacim-jazyce-clojure/">http://www.root.cz/clanky/vytvarime-irc-bota-v-programovacim-jazyce-clojure/</a>
</li>

<li>Gorilla REPL: interaktivní prostředí pro programovací jazyk Clojure<br />
<a href="https://www.root.cz/clanky/gorilla-repl-interaktivni-prostredi-pro-programovaci-jazyk-clojure/">https://www.root.cz/clanky/gorilla-repl-interaktivni-prostredi-pro-programovaci-jazyk-clojure/</a>
</li>

<li>Multimetody v Clojure aneb polymorfismus bez použití OOP<br />
<a href="https://www.root.cz/clanky/multimetody-v-clojure-aneb-polymorfismus-bez-pouziti-oop/">https://www.root.cz/clanky/multimetody-v-clojure-aneb-polymorfismus-bez-pouziti-oop/</a>
</li>

<li>Práce s externími Java archivy v programovacím jazyku Clojure<br />
<a href="https://www.root.cz/clanky/prace-s-externimi-java-archivy-v-programovacim-jazyku-clojure/">https://www.root.cz/clanky/prace-s-externimi-java-archivy-v-programovacim-jazyku-clojure/</a>
</li>

<li>Clojure 16: Složitější uživatelská makra<br />
<a href="http://www.root.cz/clanky/programovaci-jazyk-clojure-16-slozitejsi-uzivatelska-makra/">http://www.root.cz/clanky/programovaci-jazyk-clojure-16-slozitejsi-uzivatelska-makra/</a>
</li>

<li>Clojure 17: Využití standardních maker v praxi<br />
<a href="http://www.root.cz/clanky/programovaci-jazyk-clojure-17-vyuziti-standardnich-maker-v-praxi/">http://www.root.cz/clanky/programovaci-jazyk-clojure-17-vyuziti-standardnich-maker-v-praxi/</a>
</li>

<li>Clojure 18: Základní techniky optimalizace aplikací<br />
<a href="http://www.root.cz/clanky/programovaci-jazyk-clojure-18-zakladni-techniky-optimalizace-aplikaci/">http://www.root.cz/clanky/programovaci-jazyk-clojure-18-zakladni-techniky-optimalizace-aplikaci/</a>
</li>

<li>Clojure 19: Vývojová prostředí pro Clojure<br />
<a href="http://www.root.cz/clanky/programovaci-jazyk-clojure-19-vyvojova-prostredi-pro-clojure/">http://www.root.cz/clanky/programovaci-jazyk-clojure-19-vyvojova-prostredi-pro-clojure/</a>
</li>

<li>Clojure 20: Vývojová prostředí pro Clojure (Vimu s REPL)<br />
<a href="http://www.root.cz/clanky/programovaci-jazyk-clojure-20-vyvojova-prostredi-pro-clojure-integrace-vimu-s-repl/">http://www.root.cz/clanky/programovaci-jazyk-clojure-20-vyvojova-prostredi-pro-clojure-integrace-vimu-s-repl/</a>
</li>

<li>Clojure 21: ClojureScript aneb překlad Clojure do JS<br />
<a href="http://www.root.cz/clanky/programovaci-jazyk-clojure-21-clojurescript-aneb-preklad-clojure-do-javascriptu/">http://www.root.cz/clanky/programovaci-jazyk-clojure-21-clojurescript-aneb-preklad-clojure-do-javascriptu/</a>
</li>

<li>Leiningen: nástroj pro správu projektů napsaných v&nbsp;Clojure<br />
<a href="http://www.root.cz/clanky/leiningen-nastroj-pro-spravu-projektu-napsanych-v-clojure/">http://www.root.cz/clanky/leiningen-nastroj-pro-spravu-projektu-napsanych-v-clojure/</a>
</li>

<li>Leiningen: nástroj pro správu projektů napsaných v&nbsp;Clojure (2)<br />
<a href="http://www.root.cz/clanky/leiningen-nastroj-pro-spravu-projektu-napsanych-v-clojure-2/">http://www.root.cz/clanky/leiningen-nastroj-pro-spravu-projektu-napsanych-v-clojure-2/</a>
</li>

<li>Leiningen: nástroj pro správu projektů napsaných v&nbsp;Clojure (3)<br />
<a href="http://www.root.cz/clanky/leiningen-nastroj-pro-spravu-projektu-napsanych-v-clojure-3/">http://www.root.cz/clanky/leiningen-nastroj-pro-spravu-projektu-napsanych-v-clojure-3/</a>
</li>

<li>Leiningen: nástroj pro správu projektů napsaných v&nbsp;Clojure (4)<br />
<a href="http://www.root.cz/clanky/leiningen-nastroj-pro-spravu-projektu-napsanych-v-clojure-4/">http://www.root.cz/clanky/leiningen-nastroj-pro-spravu-projektu-napsanych-v-clojure-4/</a>
</li>

<li>Leiningen: nástroj pro správu projektů napsaných v&nbsp;Clojure (5)<br />
<a href="http://www.root.cz/clanky/leiningen-nastroj-pro-spravu-projektu-napsanych-v-clojure-5/">http://www.root.cz/clanky/leiningen-nastroj-pro-spravu-projektu-napsanych-v-clojure-5/</a>
</li>

<li>Leiningen: nástroj pro správu projektů napsaných v&nbsp;Clojure (6)<br />
<a href="http://www.root.cz/clanky/leiningen-nastroj-pro-spravu-projektu-napsanych-v-clojure-6/">http://www.root.cz/clanky/leiningen-nastroj-pro-spravu-projektu-napsanych-v-clojure-6/</a>
</li>

<li>Programovací jazyk Clojure a databáze (1.část)<br />
<a href="http://www.root.cz/clanky/programovaci-jazyk-clojure-a-databaze-1-cast/">http://www.root.cz/clanky/programovaci-jazyk-clojure-a-databaze-1-cast/</a>
</li>

<li>Pluginy pro Leiningen<br />
<a href="http://www.root.cz/clanky/leiningen-nastroj-pro-spravu-projektu-napsanych-v-clojure-pluginy-pro-leiningen/">http://www.root.cz/clanky/leiningen-nastroj-pro-spravu-projektu-napsanych-v-clojure-pluginy-pro-leiningen/</a>
</li>

<li>Programovací jazyk Clojure a knihovny pro práci s&nbsp;vektory a maticemi<br />
<a href="http://www.root.cz/clanky/programovaci-jazyk-clojure-a-knihovny-pro-praci-s-vektory-a-maticemi/">http://www.root.cz/clanky/programovaci-jazyk-clojure-a-knihovny-pro-praci-s-vektory-a-maticemi/</a>
</li>

<li>Programovací jazyk Clojure a knihovny pro práci s&nbsp;vektory a maticemi (2)<br />
<a href="http://www.root.cz/clanky/programovaci-jazyk-clojure-a-knihovny-pro-praci-s-vektory-a-maticemi-2/">http://www.root.cz/clanky/programovaci-jazyk-clojure-a-knihovny-pro-praci-s-vektory-a-maticemi-2/</a>
</li>

<li>Programovací jazyk Clojure: syntéza procedurálních textur s&nbsp;využitím knihovny Clisk<br />
<a href="http://www.root.cz/clanky/programovaci-jazyk-clojure-synteza-proceduralnich-textur-s-vyuzitim-knihovny-clisk/">http://www.root.cz/clanky/programovaci-jazyk-clojure-synteza-proceduralnich-textur-s-vyuzitim-knihovny-clisk/</a>
</li>

<li>Programovací jazyk Clojure: syntéza procedurálních textur s&nbsp;využitím knihovny Clisk (2)<br />
<a href="http://www.root.cz/clanky/programovaci-jazyk-clojure-synteza-proceduralnich-textur-s-vyuzitim-knihovny-clisk-2/">http://www.root.cz/clanky/programovaci-jazyk-clojure-synteza-proceduralnich-textur-s-vyuzitim-knihovny-clisk-2/</a>
</li>

<li>Seesaw: knihovna pro snadnou tvorbu GUI v&nbsp;jazyce Clojure<br />
<a href="http://www.root.cz/clanky/seesaw-knihovna-pro-snadnou-tvorbu-gui-v-jazyce-clojure/">http://www.root.cz/clanky/seesaw-knihovna-pro-snadnou-tvorbu-gui-v-jazyce-clojure/</a>
</li>

<li>Seesaw: knihovna pro snadnou tvorbu GUI v &nbsp;azyce Clojure (2)<br />
<a href="http://www.root.cz/clanky/seesaw-knihovna-pro-snadnou-tvorbu-gui-v-jazyce-clojure-2/">http://www.root.cz/clanky/seesaw-knihovna-pro-snadnou-tvorbu-gui-v-jazyce-clojure-2/</a>
</li>

<li>Seesaw: knihovna pro snadnou tvorbu GUI v&nbsp;jazyce Clojure (3)<br />
<a href="http://www.root.cz/clanky/seesaw-knihovna-pro-snadnou-tvorbu-gui-v-jazyce-clojure-3/">http://www.root.cz/clanky/seesaw-knihovna-pro-snadnou-tvorbu-gui-v-jazyce-clojure-3/</a>
</li>

<li>Programovací jazyk Clojure a práce s&nbsp;Gitem<br />
<a href="http://www.root.cz/clanky/programovaci-jazyk-clojure-a-prace-s-gitem/">http://www.root.cz/clanky/programovaci-jazyk-clojure-a-prace-s-gitem/</a>
</li>

<li>Programovací jazyk Clojure a práce s&nbsp;Gitem (2)<br />
<a href="http://www.root.cz/clanky/programovaci-jazyk-clojure-a-prace-s-gitem-2/">http://www.root.cz/clanky/programovaci-jazyk-clojure-a-prace-s-gitem-2/</a>
</li>

<li>Programovací jazyk Clojure: syntéza procedurálních textur s&nbsp;využitím knihovny Clisk (dokončení)<br />
<a href="http://www.root.cz/clanky/programovaci-jazyk-clojure-synteza-proceduralnich-textur-s-vyuzitim-knihovny-clisk-dokonceni/">http://www.root.cz/clanky/programovaci-jazyk-clojure-synteza-proceduralnich-textur-s-vyuzitim-knihovny-clisk-dokonceni/</a>
</li>

<li>Pixie: lehký skriptovací jazyk s&nbsp;„kouzelnými“ schopnostmi<br />
<a href="https://www.root.cz/clanky/pixie-lehky-skriptovaci-jazyk-s-kouzelnymi-schopnostmi/">https://www.root.cz/clanky/pixie-lehky-skriptovaci-jazyk-s-kouzelnymi-schopnostmi/</a>
</li>

<li>Programovací jazyk Pixie: funkce ze základní knihovny a použití FFI<br />
<a href="https://www.root.cz/clanky/programovaci-jazyk-pixie-funkce-ze-zakladni-knihovny-a-pouziti-ffi/">https://www.root.cz/clanky/programovaci-jazyk-pixie-funkce-ze-zakladni-knihovny-a-pouziti-ffi/</a>
</li>

<li>Novinky v&nbsp;Clojure verze 1.9.0<br />
<a href="https://www.root.cz/clanky/novinky-v-clojure-verze-1-9-0/">https://www.root.cz/clanky/novinky-v-clojure-verze-1-9-0/</a>
</li>

<li>Validace dat s&nbsp;využitím knihovny spec v&nbsp;Clojure 1.9.0<br />
<a href="https://www.root.cz/clanky/validace-dat-s-vyuzitim-knihovny-spec-v-clojure-1-9-0/">https://www.root.cz/clanky/validace-dat-s-vyuzitim-knihovny-spec-v-clojure-1-9-0/</a>
</li>

<li>Použití jazyka Gherkin při tvorbě testovacích scénářů pro aplikace psané v&nbsp;Clojure<br />
<a href="https://www.root.cz/clanky/pouziti-jazyka-gherkin-pri-tvorbe-testovacich-scenaru-pro-aplikace-psane-v-nbsp-clojure/">https://www.root.cz/clanky/pouziti-jazyka-gherkin-pri-tvorbe-testovacich-scenaru-pro-aplikace-psane-v-nbsp-clojure/</a>
</li>

<li>Použití jazyka Gherkin při tvorbě testovacích scénářů pro aplikace psané v&nbsp;Clojure (2)<br />
<a href="https://www.root.cz/clanky/pouziti-jazyka-gherkin-pri-tvorbe-testovacich-scenaru-pro-aplikace-psane-v-nbsp-clojure-2/">https://www.root.cz/clanky/pouziti-jazyka-gherkin-pri-tvorbe-testovacich-scenaru-pro-aplikace-psane-v-nbsp-clojure-2/</a>
</li>

<li>Incanter: prostředí pro statistické výpočty s grafickým výstupem založené na Clojure<br />
<a href="https://www.root.cz/clanky/incanter-prostredi-pro-statisticke-vypocty-s-grafickym-vystupem-zalozene-na-clojure/">https://www.root.cz/clanky/incanter-prostredi-pro-statisticke-vypocty-s-grafickym-vystupem-zalozene-na-clojure/</a>
</li>

<li>Incanter: operace s&nbsp;maticemi<br />
<a href="https://www.root.cz/clanky/incanter-operace-s-maticemi/">https://www.root.cz/clanky/incanter-operace-s-maticemi/</a>
</li>

<li>Interpret programovacího jazyka Clojure integrovaný do Jupyter Notebooku<br />
<a href="https://www.root.cz/clanky/interpret-programovaciho-jazyka-clojure-integrovany-do-jupyter-notebooku/">https://www.root.cz/clanky/interpret-programovaciho-jazyka-clojure-integrovany-do-jupyter-notebooku/</a>
</li>

<li>Babashka: interpret Clojure určený pro rychlé spouštění utilit z&nbsp;příkazového řádku<br />
<a href="https://www.root.cz/clanky/babashka-interpret-clojure-urceny-pro-rychle-spousteni-utilit-z-prikazoveho-radku/">https://www.root.cz/clanky/babashka-interpret-clojure-urceny-pro-rychle-spousteni-utilit-z-prikazoveho-radku/</a>
</li>

<li>Pokročilý streaming založený na Apache Kafce, jazyku Clojure a knihovně Jackdaw<br />
<a href="https://www.root.cz/clanky/pokrocily-streaming-zalozeny-na-apache-kafce-jazyku-clojure-a-knihovne-jackdaw/">https://www.root.cz/clanky/pokrocily-streaming-zalozeny-na-apache-kafce-jazyku-clojure-a-knihovne-jackdaw/</a>
</li>

<li>Pokročilý streaming založený na Apache Kafce, jazyku Clojure a knihovně Jackdaw (2. část)<br />
<a href="https://www.root.cz/clanky/pokrocily-streaming-zalozeny-na-apache-kafce-jazyku-clojure-a-knihovne-jackdaw-2-cast/">https://www.root.cz/clanky/pokrocily-streaming-zalozeny-na-apache-kafce-jazyku-clojure-a-knihovne-jackdaw-2-cast/</a>
</li>

<li>Pokročilý streaming založený na projektu Apache Kafka, jazyku Clojure a knihovně Jackdaw (streamy a kolony)<br />
<a href="https://www.root.cz/clanky/pokrocily-streaming-zalozeny-na-projektu-apache-kafka-jazyku-clojure-a-knihovne-jackdaw-streamy-a-kolony/">https://www.root.cz/clanky/pokrocily-streaming-zalozeny-na-projektu-apache-kafka-jazyku-clojure-a-knihovne-jackdaw-streamy-a-kolony/</a>
</li>

<li>Řídicí struktury využitelné v&nbsp;programovacím jazyku Clojure<br />
<a href="https://www.root.cz/clanky/ridici-struktury-vyuzitelne-v-programovacim-jazyku-clojure/">https://www.root.cz/clanky/ridici-struktury-vyuzitelne-v-programovacim-jazyku-clojure/</a>
</li>

<li>Řídicí struktury využitelné v programovacím jazyku Clojure (dokončení)<br />
<a href="https://www.root.cz/clanky/ridici-struktury-vyuzitelne-v-programovacim-jazyku-clojure-dokonceni/">https://www.root.cz/clanky/ridici-struktury-vyuzitelne-v-programovacim-jazyku-clojure-dokonceni/</a>
</li>

</ol>



<p><a name="k20"></a></p>
<h2 id="k20">20. Odkazy na Internetu</h2>

<ol>

<li>Understanding Clojure's PersistentVector implementation<br />
<a href="http://blog.higher-order.net/2009/02/01/understanding-clojures-persistentvector-implementation">http://blog.higher-order.net/2009/02/01/understanding-clojures-persistentvector-implementation</a>
</li>

<li>Understanding Clojure's PersistentHashMap (deftwice...)<br />
<a href="http://blog.higher-order.net/2009/09/08/understanding-clojures-persistenthashmap-deftwice.html">http://blog.higher-order.net/2009/09/08/understanding-clojures-persistenthashmap-deftwice.html</a>
</li>

<li>Assoc and Clojure's PersistentHashMap: part ii<br />
<a href="http://blog.higher-order.net/2010/08/16/assoc-and-clojures-persistenthashmap-part-ii.html">http://blog.higher-order.net/2010/08/16/assoc-and-clojures-persistenthashmap-part-ii.html</a>
</li>

<li>Ideal Hashtrees (paper)<br />
<a href="http://lampwww.epfl.ch/papers/idealhashtrees.pdf">http://lampwww.epfl.ch/papers/idealhashtrees.pdf</a>
</li>

<li>data.priority-map API Reference<br />
<a href="https://clojure.github.io/data.priority-map/">https://clojure.github.io/data.priority-map/</a>
</li>

<li>Clojure Sequences<br />
<a href="http://clojure.org/sequences">http://clojure.org/sequences</a>
</li>

<li>Clojure Data Structures<br />
<a href="https://clojure.org/reference/data_structures">https://clojure.org/reference/data_structures</a>
</li>

<li>hash-map<br />
<a href="https://clojure.github.io/clojure/clojure.core-api.html#clojure.core/hash-map">https://clojure.github.io/clojure/clojure.core-api.html#clojure.core/hash-map</a>
</li>

<li>sorted-map<br />
<a href="https://clojure.github.io/clojure/clojure.core-api.html#clojure.core/sorted-map">https://clojure.github.io/clojure/clojure.core-api.html#clojure.core/sorted-map</a>
</li>

<li>array-map<br />
<a href="https://clojuredocs.org/clojure.core/array-map">https://clojuredocs.org/clojure.core/array-map</a>
</li>

<li>Clojure Hashmaps Explained: How to Retrieve Values From and Update Hashmaps<br />
<a href="https://www.freecodecamp.org/news/clojure-hashmaps-explained-how-to-retrieve-values-from-and-update-hashmaps/">https://www.freecodecamp.org/news/clojure-hashmaps-explained-how-to-retrieve-values-from-and-update-hashmaps/</a>
</li>

<li>Clojure Data Structures Tutorial<br />
<a href="https://purelyfunctional.tv/guide/clojure-collections/">https://purelyfunctional.tv/guide/clojure-collections/</a>
</li>

<li>Are maps in Clojure ordered?<br />
<a href="https://stackoverflow.com/questions/34401121/are-maps-in-clojure-ordered">https://stackoverflow.com/questions/34401121/are-maps-in-clojure-ordered</a>
</li>

<li>Clojure: how to conj to front of hash map in swap! function<br />
<a href="https://stackoverflow.com/questions/33042116/clojure-how-to-conj-to-front-of-hash-map-in-swap-function">https://stackoverflow.com/questions/33042116/clojure-how-to-conj-to-front-of-hash-map-in-swap-function</a>
</li>

<li>The Clojure Toolbox<br />
<a href="http://www.clojure-toolbox.com/">http://www.clojure-toolbox.com/</a>
</li>

<li>Transient Data Structures
<a href="http://clojure.org/transients">http://clojure.org/transients</a>
</li>

<li>Rails Conf 2012 Keynote: Simplicity Matters by Rich Hickey<br />
<a href="https://www.youtube.com/watch?v=rI8tNMsozo0">https://www.youtube.com/watch?v=rI8tNMsozo0</a>
</li>

<li>Clojure Performance Guarantees<br />
<a href="https://www.innoq.com/blog/st/2010/04/clojure-performance-guarantees/">https://www.innoq.com/blog/st/2010/04/clojure-performance-guarantees/</a>
</li>

<li>Time complexity of operations on collections<br />
<a href="https://groups.google.com/g/clojure/c/xpqap7HShWw?pli=1">https://groups.google.com/g/clojure/c/xpqap7HShWw?pli=1</a>
</li>

The <li>five common forms of Clojure keywords<br />
<a href="https://blog.jeaye.com/2017/10/31/clojure-keywords/">https://blog.jeaye.com/2017/10/31/clojure-keywords/</a>
</li>

</ol>



<p></p><p></p>
<p><small>Autor: <a href="http://www.fit.vutbr.cz/~tisnovpa">Pavel Tišnovský</a> &nbsp; 2021</small></p>
</body>
</html>

