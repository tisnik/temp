<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
        "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html>
<head>
<title>Knihovny a moduly usnadňující testování aplikací naprogramovaných v jazyce Clojure</title>
<meta name="Author" content="Pavel Tisnovsky" />
<meta name="Generator" content="vim" />
<meta http-equiv="content-type" content="text/html; charset=utf-8" />
<style type="text/css">
         body {color:#000000; background:#ffffff;}
         h1  {font-family: arial, helvetica, sans-serif; color:#ffffff; background-color:#c00000; text-align:center; padding-left:1em}
         h2  {font-family: arial, helvetica, sans-serif; color:#ffffff; background-color:#0000c0; padding-left:1em; text-align:left}
         h3  {font-family: arial, helvetica, sans-serif; color:#000000; background-color:#c0c0c0; padding-left:1em; text-align:left}
         h4  {font-family: arial, helvetica, sans-serif; color:#000000; background-color:#e0e0e0; padding-left:1em; text-align:left}
         a   {font-family: arial, helvetica, sans-serif;}
         li  {font-family: arial, helvetica, sans-serif; color:#000000; text-align:justify; width:450px;}
         ol  {font-family: arial, helvetica, sans-serif; color:#000000; text-align:justify; width:450px;}
         ul  {font-family: arial, helvetica, sans-serif; color:#000000; text-align:justify; width:450px;}
         p   {font-family: arial, helvetica, sans-serif; color:#000000; text-align:justify;}
         pre {background:#e0e0e0}
</style>
</head>

<body>

<h1>Knihovny a moduly usnadňující testování aplikací naprogramovaných v jazyce Clojure</h1>

<h3>Pavel Tišnovský</h3>

<p></p>

<h1>Úvodník</h1>

<p>V dnešním článku se seznámíme s knihovnami a moduly pro Leiningen určenými pro testování aplikací naprogramovaných v jazyce Clojure. V této oblasti vzniklo velké množství zajímavých projektů, například modul humane-test-output, knihovna iota či adaptace jazyka Gherkin pro BDD.</p>



<h2>Obsah</h2>

<p><a href="#k01">*** 1. Knihovny a moduly usnadňující testování aplikací naprogramovaných v&nbsp;jazyce Clojure</a></p>
<p><a href="#k02">2. Tvorba jednotkových testů s&nbsp;využitím základní knihovny <strong>clojure.test</strong></a></p>
<p><a href="#k03">3. Makra <strong>is</strong> a <strong>are</strong></a></p>
<p><a href="#k04">4. Test, zda byla vyhozena výjimka specifikovaného typu nebo výjimka s&nbsp;určitou zprávou</a></p>
<p><a href="#k05">5. Rozšiřující modul <strong>humane-test-output</strong> pro vylepšení hlášení výstupu jednotkových testů</a></p>
<p><a href="#k06">6. Rozdíly mezi běžným výstupem testů a výstupem upraveným <strong>humane-test-output</strong></a></p>
<p><a href="#k07">7. Jednotkové testy s&nbsp;výstupem kompatibilním s&nbsp;JUnit</a></p>
<p><a href="#k08">8. Spuštění jednotkového testu a konverze výsledku do formátu kompatibilního s&nbsp;JUnit</a></p>
<p><a href="#k09">*** 9. Plugin <strong>cloverage</strong> &ndash; zjištění pokrytí kódu testy</a></p>
<p><a href="#k10">*** 10. Příklad výstupu generovaného pluginem <strong>cloverage</strong></a></p>
<p><a href="#k11">*** 11. Knihovna <strong>iota</strong> a její použití při tvorbě testů</a></p>
<p><a href="#k12">*** 12. Ukázka testu napsaného s&nbsp;využitím knihovny <strong>iota</strong></a></p>
<p><a href="#k13">*** 13. Testování s&nbsp;využitím knihovny Expectations</a></p>
<p><a href="#k14">*** 14. </a></p>
<p><a href="#k15">*** 15. </a></p>
<p><a href="#k16">*** 16. Podpora pro BDD (behaviour-driven development) knihovnou <strong>cucumber-jvm-clojure</strong></a></p>
<p><a href="#k17">*** 17. Jednoduchý projekt testovaný s&nbsp;využitím BDD</a></p>
<p><a href="#k18">*** 18. Repositář s&nbsp;demonstračními příklady</a></p>
<p><a href="#k19">19. Odkazy na předchozí části tohoto seriálu</a></p>
<p><a href="#k20">20. Odkazy na Internetu</a></p>



<p><a name="k01"></a></p>
<h2 id="k01">1. Knihovny a moduly usnadňující testování aplikací naprogramovaných v&nbsp;jazyce Clojure</h2>

<p></p>

<p><div class="rs-tip-major">Poznámka: v&nbsp;dalším textu se předpokládá, že
máte nainstalován správce projektu <i>Leiningen</i>. Pokud tomu tak není, bude
nutné si <a
href="https://www.root.cz/clanky/leiningen-nastroj-pro-spravu-projektu-napsanych-v-clojure/">Leiningen
nainstalovat</a>, což není nic těžkého. Navíc se jedná o velmi užitečný projekt
s&nbsp;mnoha přídavnými moduly, které využijete nejenom při
testování.</div></p>



<p><a name="k02"></a></p>
<h2 id="k02">2. Tvorba jednotkových testů s&nbsp;využitím základní knihovny <strong>clojure.test</strong></h2>

<p>Tvorbou jednotkových testů s&nbsp;využitím základní knihovny nazvané
<strong>clojure.test</strong> jsme se již v&nbsp;tomto seriálu věnovali, takže
se o možnostech této knihovny zmíníme jen krátce. Připomeňme si, že
<strong>clojure.test</strong>, která patří mezi <a
href="https://clojure.github.io/clojure/clojure.test-api.html">standardní
knihovny</a> dodávané společně s&nbsp;interpretrem Clojure, obsahuje několik
funkcí a maker určených pro psaní jednotkových testů popř.&nbsp;pro jednoduché
<i>aserce</i> zapisované přímo do programového kódu (například při ladění
v&nbsp;interaktivní smyčce REPL). Tuto knihovnu navíc automaticky používá
systém pro správu projektů <i>Leiningen</i>, takže když vytvoříte strukturu
nového projektu příkazem:</p>

<pre>
lein new app nova_aplikace
</pre>

<p>Objeví se ve struktuře projektu i podadresář <strong>test</strong>,
v&nbsp;němž se vytváří jednotkové testy:</p>

<pre>
├── doc
│   └── intro.md
├── LICENSE
├── project.clj
├── README.md
├── resources
├── src
│   └── nova_aplikace
│       └── core.clj
└── test
    └── nova_aplikace
        └── core_test.clj
</pre>

<p>Moduly v&nbsp;adresáři <strong>test</strong> knihovnu
<strong>clojure.test</strong> automaticky načítají:</p>

<pre>
(ns nova-aplikace.core-test
    (:require [<strong>clojure.test :refer :all</strong>]
              [nova-aplikace.core :refer :all]))
...
...
...
</pre>

<p>Samotný test se zapisuje následujícím způsobem:</p>

<pre>
(deftest factorial-test
    (testing "Factorial"
        (is ( = (factorial 0)   1) "beginning")
        (is ( = (factorial 1)   1) "beginning")
        (is ( = (factorial 2)   (* 1 2)) "still easy")
        (is ( = (factorial 5)   (* 1 2 3 4 5)) "5!")
        (is ( = (factorial 6)   720) "6!")))
</pre>

<p>Můžeme zde vidět použití tří maker &ndash; <strong>deftest</strong>,
<strong>testing</strong> a <strong>is</strong>.</p>

<p>Makro <strong>deftest</strong> sémanticky odpovídá definici funkce, ovšem
nikde se neuvádí parametry:</p>

<pre>
user=&gt; <strong>(doc deftest)</strong>
-------------------------
clojure.test/deftest
([name &amp; body])
Macro
  Defines a test function with no arguments.  Test functions may call
  other tests, so tests may be composed.  If you compose tests, you
  should also define a function named test-ns-hook; run-tests will
  call test-ns-hook instead of testing all vars.
&nbsp;
  Note: Actually, the test body goes in the :test metadata on the var,
  and the real function (the value of the var) calls test-var on
  itself.
&nbsp;
  When *load-tests* is false, deftest is ignored.
</pre>

<p>Použití druhého makra <strong>testing</strong> je nepovinné, ale může se
hodit například v&nbsp;případě, že potřebujeme vypisovat informace o tom, jaká
část aplikace je právě testována:</p>

<pre>
user=&gt; <strong>(doc testing)</strong>
-------------------------
clojure.test/testing
([string &amp; body])
Macro
  Adds a new string to the list of testing contexts.  May be nested,
  but must occur inside a test function (deftest).
</pre>

<p>Příklad výstupu testu:</p>

<pre>
<strong>lein test</strong>
&nbsp;
Ran 2 tests containing 8 assertions.
0 failures, 0 errors.
</pre>

<p>Popř.&nbsp;při zjištění chyby nebo chyb:</p>

<pre>
<strong>lein test</strong>
&nbsp;
lein test factorial.core-test
&nbsp;
lein test :only factorial.core-test/factorial-test
&nbsp;
FAIL in (factorial-test) (core_test.clj:9)
Factorial
still easy
expected: (= (factorial 2) (* 1 2))
  actual: (not (= 1 2))
&nbsp;
lein test :only factorial.core-test/factorial-test
&nbsp;
FAIL in (factorial-test) (core_test.clj:10)
Factorial
5!
expected: (= (factorial 5) (* 1 2 3 4 5))
  actual: (not (= 24 120))
&nbsp;
lein test :only factorial.core-test/factorial-test
&nbsp;
FAIL in (factorial-test) (core_test.clj:11)
Factorial
6!
expected: (= (factorial 6) 720)
  actual: (not (= 120 720))
&nbsp;
Ran 2 tests containing 8 assertions.
3 failures, 0 errors.
Tests failed.
</pre>



<p><a name="k03"></a></p>
<h2 id="k03">3. Makra <strong>is</strong> a <strong>are</strong></h2>

<p>Základem pro psaní jednotkových testů s&nbsp;využitím knihovny
<strong>clojure.test</strong> je makro nazvané jednoduše <strong>is</strong>,
takže se nejprve podívejme na to, co o tomto makru říká dokumentace. Prohlížení
dokumentace slouží makro <strong>doc</strong>, kterému se jako parametr předá
jméno funkce, makra či symbolu, jehož význam potřebujeme zjistit:</p>

<pre>
user=&gt; <strong>(doc is)</strong>
-------------------------
clojure.test/is
([form] [form msg])
Macro
  Generic assertion macro.  'form' is any predicate test.
  'msg' is an optional message to attach to the assertion.
&nbsp;
  Example: (is (= 4 (+ 2 2)) "Two plus two should be 4")
&nbsp;
  Special forms:
&nbsp;
  (is (thrown? c body)) checks that an instance of c is thrown from
  body, fails if not; then returns the thing thrown.
&nbsp;
  (is (thrown-with-msg? c re body)) checks that an instance of c is
  thrown AND that the message on the exception matches (with
  re-find) the regular expression re.
nil
</pre>

<p>Vidíme, že tomuto makru lze předat takzvaný predikát a popř.&nbsp;i textovou
zprávu. Predikát je použit ve dvou významech &ndash; po svém vyhodnocení se
zjišťuje výsledná hodnota a pokud není predikát splněn, vypíše se chybové
hlášení obsahující jak původní znění predikátu, tak i aktuální (odlišná)
hodnota vzniklá vyhodnocením. Mimochodem: právě proto, že se vypisuje text
predikátu, nemůže být <strong>is</strong> implementováno pomocí funkce, ale
bylo nutné použít makro. Chování makra <strong>is</strong> si můžeme snadno
odzkoušet:</p>

<pre>
user=&gt; <strong>(is true)</strong>
true
</pre>

<pre>
user=&gt; <strong>(is (= (+ 1 1) 2))</strong>
true
</pre>

<pre>
user=&gt; <strong>(is (= (inc 1) 2))</strong>
true
</pre>

<pre>
user=&gt; <strong>(is (nil? nil))</strong>
true
</pre>

<pre>
user=&gt; <strong>(is (seq? '(1 2 3)))</strong>
true
</pre>

<pre>
user=&gt; <strong>(is (fn? println))</strong>
true
</pre>

<p>Co se stane ve chvíli, kdy není predikát splněn, lze opět snadno
odzkoušet:</p>

<pre>
user=&gt; <strong>(is (= 1 2))</strong>
&nbsp;
FAIL in clojure.lang.PersistentList$EmptyList@1 (NO_SOURCE_FILE:1)
expected: (= 1 2)
  actual: (not (= 1 2))
false
</pre>

<pre>
user=&gt; <strong>(is (nil? "ja nejsem nil"))</strong>
&nbsp;
FAIL in clojure.lang.PersistentList$EmptyList@1 (NO_SOURCE_FILE:1)
expected: (nil? "ja nejsem nil")
  actual: (not (nil? "ja nejsem nil"))
false
</pre>

<pre>
user=&gt; <strong>(is (= (inc 1) 3))</strong>
&nbsp;
FAIL in clojure.lang.PersistentList$EmptyList@1 (NO_SOURCE_FILE:1)
expected: (= (inc 1) 3)
  actual: (not (= 2 3))
false
</pre>

<pre>
user=&gt; <strong>(is (fn? true))</strong>
&nbsp;
FAIL in clojure.lang.PersistentList$EmptyList@1 (NO_SOURCE_FILE:1)
expected: (fn? true)
  actual: (not (fn? true))
false
</pre>

<p>Řádek začínající slovem FAIL jen naznačuje, že makro <strong>is</strong>
spouštíme z&nbsp;interaktivní konzole a nikoli ze zdrojového kódu (kde by bylo
známé jak jméno zdrojového souboru, tak i číslo řádku, na němž je makro
<strong>is</strong> použito). Tento nedostatek se nijak neprojeví při testování
reálných aplikací.</p>

<p><div class="rs-tip-major">Poznámka: mohlo by se zdát, že namísto
<strong>is</strong> je možné použít standardní makro <strong>assrty</strong>.
Ve skutečnosti by však správně nefungovalo vyhodnocení testů, i když je činnost
makra <strong>assert</strong> zdánlivě velmi podobná:</div></p>

<pre>
user=&gt; <strong>(assert (= 1 1))</strong>
nil
user=&gt; <strong>(assert (= 1 2))</strong>
&nbsp;
AssertionError Assert failed: (= 1 2)  user/eval771 (NO_SOURCE_FILE:1)
</pre>

<p>Jedinou vážnější nevýhodou je opakované použití makra <strong>is</strong> a
z&nbsp;toho vyplývající záplavy závorek. Aby se psaní testů zpřehlednilo, lze
namísto <strong>is</strong> využít makro <strong>are</strong>, kterému se předá
funkce provádějící porovnání (jen se nezapisuje jméno funkce) a za tímto
zápisem pak již většinou seznam obsahující očekávané hodnoty a volání testované
funkce:</p>

<pre>
user=&gt; <strong>(doc are)</strong>
-------------------------
clojure.test/are
([argv expr &amp; args])
Macro
  Checks multiple assertions with a template expression.
  See clojure.template/do-template for an explanation of
  templates.
&nbsp;
  Example: (are [x y] (= x y)  
                2 (+ 1 1)
                4 (* 2 2))
  Expands to: 
           (do (is (= 2 (+ 1 1)))
               (is (= 4 (* 2 2))))
&nbsp;
  Note: This breaks some reporting features, such as line numbers.
nil
</pre>

<p>Rozdíl mezi makry <strong>is</strong> a <strong>are</strong> je patrný
z&nbsp;následujících dvou testů:</p>

<pre>
(ns <strong>testing1.core-test</strong>
    (:require [clojure.test :refer :all]
              [testing1.core :refer :all]))
&nbsp;
(deftest <strong>test-add-1</strong>
    (testing "function add"
        (is (= 0 (add 0 0)))
        (is (= 3 (add 1 2)))
        (is (= 5/6 (add 1/2 1/3)))))
&nbsp;
(deftest <strong>test-add-2</strong>
    (testing "function add"
        (are [x y] (= x y)
            0   (add 0 0)
            3   (add 1 2)
            5/6 (add 1/2 1/3))))
</pre>



<p><a name="k04"></a></p>
<h2 id="k04">4. Test, zda byla vyhozena výjimka specifikovaného typu nebo výjimka s&nbsp;určitou zprávou</h2>

<p>V&nbsp;nápovědě zobrazené k&nbsp;makru <strong>is</strong> je
mj.&nbsp;popsána jedno z&nbsp;častou využívaných volání tohoto makra:</p>

<pre>
(is (thrown? c body))
</pre>

<p>Tuto formu je v&nbsp;případě potřeby možné použít pro otestování, zda
zavolání nějaké funkce vyvolá výjimky určitého typu (typ je určen třídou
<strong>c</strong>). Podívejme se na velmi jednoduchý příklad. Tím je dělení
nulou, které podle očekávání vede k&nbsp;vyhození výjimky typu
<strong>ArithmeticException</strong>. Ostatně můžeme se sami přesvědčit, zda je
to pravda:</p>

<pre>
user=&gt; <strong>(/ 42 0)</strong>
&nbsp;
ArithmeticException Divide by zero  clojure.lang.Numbers.divide (Numbers.java:156)
</pre>

<p>Výjimka skutečně byla podle všech očekávání vyhozena, takže můžeme zkusit,
co se stane ve chvíli, kdy se využije výše uvedená speciální forma volání makra
<strong>is</strong>:</p>

<pre>
user=&gt; <strong>(is (thrown? ArithmeticException (/ 42 0)))</strong>
#&lt;ArithmeticException java.lang.ArithmeticException: Divide by zero&lt;
</pre>

<p>Výsledkem volání je instance třídy ArithmeticException. Opět se můžeme
snadno přesvědčit, že je to pravda:</p>

<pre>
user=&gt; <strong>(def result (is (thrown? ArithmeticException (/ 42 0))))</strong>
#'user/result
user=&gt; <strong>result</strong>
#&lt;ArithmeticException java.lang.ArithmeticException: Divide by zero&lt;
user=&gt; <strong>(type result)</strong>
java.lang.ArithmeticException
</pre>

<p>Ve chvíli, kdy se použije format <strong>(is (thrown? ...))</strong> a
k&nbsp;vyhození výjimky nedojde, vypíše makro <strong>is</strong> následující
zprávu:</p>

<pre>
user=&gt; <strong>(is (thrown? ArithmeticException (/ 42 1)))</strong>
&nbsp;
FAIL in clojure.lang.PersistentList$EmptyList@1 (NO_SOURCE_FILE:1)
expected: (thrown? ArithmeticException (/ 42 1))
  actual: nil
nil
</pre>

<p>V&nbsp;některých případech může být důležité otestovat nejenom typ výjimky,
ale i to, jestli zpráva nesená výjimkou odpovídá zadanému regulárnímu výrazu.
Připomeňme si, že v&nbsp;Clojure se regulární výrazy zapisují ve formátu <a
href="https://clojure.org/guides/weird_characters#__code_code_regular_expression">#"regulární_výraz"</a>,
díky čemuž je možné se vyhnout nutnosti escapování mnoha znaků, které mají
v&nbsp;regulárních výrazech speciální význam. Podívejme se na následující test,
který zjistí, jestli výjimka obsahuje zprávu &bdquo;No such file or
directory&ldquo; (což platí pro Linux, ne nutně pro další systémy):</p>

<pre>
user=&gt; <strong>(is (thrown-with-msg? java.io.FileNotFoundException #"No such file or directory" (slurp "nejaky_soubor")))</strong>
#&lt;FileNotFoundException java.io.FileNotFoundException: nejaky_soubor (No such file or directory)&gt;
</pre>

<p>Naopak test, jehož podmínka není splněna:</p>

<pre>
user=&gt; <strong>(is (thrown-with-msg? java.io.FileNotFoundException #"Soubor nelze najit" (slurp "nejaky_soubor")))</strong>
&nbsp;
FAIL in clojure.lang.PersistentList$EmptyList@1 (NO_SOURCE_FILE:1)
expected: (thrown-with-msg? java.io.FileNotFoundException #"Soubor nelze najit" (slurp "nejaky_soubor"))
  actual: #&lt;FileNotFoundException java.io.FileNotFoundException: nejaky_soubor (No such file or directory)&gt;
#&lt;FileNotFoundException java.io.FileNotFoundException: nejaky_soubor (No such file or directory)&gt;
</pre>

<p>Pro testování zprávy se používá funkce <strong>re-find</strong>, takže pokud
potřebujete zjistit, zda <i>celá</i> zpráva odpovídá zadanému regulárnímu
výrazu, je nutné na začátku a konci výrazu použít znaky ^ a $:</p>

<pre>
user=&gt; <strong>(is (thrown-with-msg? java.lang.ArrayIndexOutOfBoundsException #"^[0-9]+$" (aget (int-array 10) 100)))</strong>
#&lt;ArrayIndexOutOfBoundsException java.lang.ArrayIndexOutOfBoundsException: 100&gt;
&nbsp;
user=&gt; <strong>(is (thrown-with-msg? java.lang.ArrayIndexOutOfBoundsException #"^[0-9]+$" (aget (int-array 10) -1)))</strong>
&nbsp;
FAIL in clojure.lang.PersistentList$EmptyList@1 (NO_SOURCE_FILE:1)
expected: (thrown-with-msg? java.lang.ArrayIndexOutOfBoundsException #"^[0-9]+$" (aget (int-array 10) -1))
  actual: #&lt;ArrayIndexOutOfBoundsException java.lang.ArrayIndexOutOfBoundsException: -1&gt;
#&lt;ArrayIndexOutOfBoundsException java.lang.ArrayIndexOutOfBoundsException: -1&gt;
</pre>



<p><a name="k05"></a></p>
<h2 id="k05">5. Rozšiřující modul <strong>humane-test-output</strong> pro vylepšení hlášení výstupu jednotkových testů</h2>

<p>Z&nbsp;předchozích příkladů je patrné, že výstup produkovaný výše popsanými
makry <strong>is</strong> a <strong>are</strong> (popř.&nbsp;i dalšími makry a
funkcemi poskytovanými knihovnou <strong>clojure.test</strong>) nemusí být
příliš čitelný. Tento problém se stane ještě více patrný ve chvíli, kdy
například testujeme, zda se vrátil určitý řetězec a chyba (přesněji řečeno
rozdíl) nastane v&nbsp;jediném znaku. Podobně se může stát, že porovnáváme dvě
rozsáhlejší či složitější datové struktury, které se opět mohou odlišovat pouze
v&nbsp;několika detailech. Klasický výstup produkovaný makry
<strong>is</strong> a <strong>are</strong> v&nbsp;těchto případech bude vypadat
následovně:</p>

<pre>
user=&gt; <strong>(use '[clojure.test])</strong>
nil
user=&gt; <strong>(is (= "Linux was originally developed for personal computers based on the Intel x86 architecture" "Linux was originally developed for personal computers based on the Intel i386 architecture"))</strong>
&nbsp;
FAIL in () (form-init2657361174634375861.clj:1)
expected: (= "Linux was originally developed for personal computers based on the Intel x86 architecture" "Linux was originally developed for personal computers based on the Intel i386 architecture")
  actual: (not (= "Linux was originally developed for personal computers based on the Intel x86 architecture" "Linux was originally developed for personal computers based on the Intel i386 architecture"))
false
</pre>

<p>Stručně a přitom nečitelně se napíše, že dva porovnávané řetězce jsou
rozdílné.</p>

<p>Pro dosažení čitelnějších výsledků testů je možné použít několik různých
modulů. Pravděpodobně nejužitečnější je modul nazvaný přímočaře
<strong>humane-test-output</strong>. Tento modul je nejdříve nutné
nainstalovat, a to ideálně pro celé vývojové prostředí programátora. Provede se
to poměrně snadnou úpravou souboru <strong>profiles.clj</strong>, který se
nachází v&nbsp;adresáři <strong>~/.lein</strong> (~ nahrazuje domovský adresář
uživatele):</p>

<pre>
{:user {:dependencies [[pjstadig/humane-test-output "0.8.3"]]
        :injections [(require 'pjstadig.humane-test-output)
                     (pjstadig.humane-test-output/activate!)]}}
</pre>

<p>Pokud nyní znovu spustíme REPL a porovnáme dva řetězce pomocí makra
<strong>is</strong>, tak se chybové hlášení změní do čitelnější podoby. Navíc
se kromě dvou porovnávaných hodnot vypíše i jejich rozdíl (což ovšem
v&nbsp;případě řetězců nedává moc velký význam; smysl uvidíme později):</p>

<pre>
user=&gt; <strong>(use '[clojure.test])</strong>
nil
user=&gt; <strong>(is (= "Linux was originally developed for personal computers based on the Intel x86 architecture" "Linux was originally developed for personal computers based on the Intel i386 architecture"))</strong>
&nbsp;
FAIL in () (form-init7785123977273257765.clj:1)
expected: "Linux was originally developed for personal computers based on the Intel x86 architecture"
  actual: "Linux was originally developed for personal computers based on the Intel i386 architecture"
    diff: - "Linux was originally developed for personal computers based on the Intel x86 architecture"
          + "Linux was originally developed for personal computers based on the Intel i386 architecture"
false
</pre>

<p><div class="rs-tip-major">Poznámka: modul
<strong>humane-test-output</strong> je kompatibilní s&nbsp;Clojure 1.8.0 a
samozřejmě i s&nbsp;vyššími verzemi. Pozor si dejte především na to, že pouhé
spuštění příkazu <strong>lein repl</strong> mimo vlastní projekt může u
starších verzí Leiningenu ve skutečnosti spustit interpret starší varianty
Clojure, například i dnes již notně zastaralé varianty 1.6.0. Při spuštění
<strong>lein repl</strong> v&nbsp;adresáři projektu se ovšem korektně použije
interpret nastavený v&nbsp;souboru <strong>project.clj</strong>.</div></p>

<p>Další příklad použití &ndash; porovnání dvou delších sekvencí bez přídavného
modulu:</p>

<pre>
user=&gt; <strong>(is (= (range 10) (range 11)))</strong>
&nbsp;
FAIL in () (form-init7847812831457116868.clj:1)
expected: (= (range 10) (range 11))
  actual: (not (= (0 1 2 3 4 5 6 7 8 9) (0 1 2 3 4 5 6 7 8 9 10)))
false
</pre>

<p>Totéž porovnání, nyní ovšem se zapnutým modulem
<strong>humane-test-output</strong>:</p>

<pre>
user=&gt; <strong>(is (= (range 10) (range 11)))</strong>
&nbsp;
FAIL in () (form-init2139708971885779974.clj:1)
expected: (0 1 2 3 4 5 6 7 8 9)
  actual: (0 1 2 3 4 5 6 7 8 9 10)
    diff: + [nil nil nil nil nil nil nil nil nil nil 10]
false
</pre>

<p>Porovnání dvou map, které se od sebe liší jedinou hodnotou:</p>

<pre>
user=&gt; <strong>(is (= {:a 1 :b 2 :c 3} {:a 1 :b 3 :c 3}))</strong>
&nbsp;
FAIL in () (form-init7847812831457116868.clj:1)
expected: (= {:a 1, :b 2, :c 3} {:a 1, :b 3, :c 3})
  actual: (not (= {:a 1, :b 2, :c 3} {:a 1, :b 3, :c 3}))
false
</pre>

<p>Totéž porovnání, nyní ovšem se zapnutým modulem
<strong>humane-test-output</strong>:</p>

<pre>
user=&gt; <strong>(is (= {:a 1 :b 2 :c 3} {:a 1 :b 3 :c 3}))</strong>
&nbsp;
FAIL in () (form-init2139708971885779974.clj:1)
expected: {:a 1, :b 2, :c 3}
  actual: {:a 1, :b 3, :c 3}
    diff: - {:b 2}
          + {:b 3}
false
</pre>

<p>Zejména v&nbsp;posledním případě jistě oceníte mnohem vyšší čitelnost
výstupu.</p>



<p><a name="k06"></a></p>
<h2 id="k06">6. Rozdíly mezi běžným výstupem testů a výstupem upraveným <strong>humane-test-output</strong></h2>

<p>Podívejme se nyní na to, jak se výstup produkovaný jednotkovými testy změní
ve chvíli, kdy je nakonfigurován modul <strong>humane-test-output</strong> a
provádíme testování nějaké aplikace příkazem <strong>lein test</strong>.
Nejdříve vyzkoušíme naši funkci pro výpočet faktoriálu, přesněji řečeno takovou
variantu funkce <strong>factorial</strong>, která vyhazuje výjimku pro záporná
čísla:</p>

<pre>
(ns factorial4.core
    (:gen-class))
&nbsp;
<i>; funkce faktorial obsahuje i test na zaporne hodnoty</i>
(defn factorial
    [n]
    (if (neg? n)
        (throw (IllegalArgumentException. "negative numbers are not supported!"))
        (apply * (range 1 (inc n)))))
&nbsp;
<i>; otestujeme funkci faktorial</i>
(defn -main
    [&amp; args]
    (doseq [i (range 0 10)]
        (println i "! = " (factorial i))))
</pre>

<p>Samotné testy jsou naprogramovány pro odzkoušení známých výsledků i pro
otestování, kdy dojde k&nbsp;chybě nebo dokonce k&nbsp;vyhození výjimky.
Zvýrazněný test je schválně napsán nekorektně, aby při jeho spuštění byly
hlášeny špatné výsledky:</p>

<pre>
(ns factorial4.core-test
  (:require [clojure.test :refer :all]
            [factorial4.core :refer :all]))
&nbsp;
(deftest factorial-test
    (testing "Factorial"
        (is ( = (factorial 0)   1) "beginning")
        (is ( = (factorial 1)   1) "beginning")
        (is ( = (factorial 2)   (* 1 2)) "still easy")
        (is ( = (factorial 5)   (* 1 2 3 4 5)) "5!")
        (is ( = (factorial 6)   720) "6!")))
&nbsp;
<strong>(deftest negative-factorial-test</strong>
    <strong>(testing "Negative tests"</strong>
        <strong>(is ( = (factorial 0)   0) "negative test case #1")</strong>
        <strong>(is ( = (factorial 1)   0) "negative test case #2")</strong>
        <strong>(is ( = (factorial 2)   0) "negative test case #3")))</strong>
&nbsp;
(deftest exception-test
    (testing "If factorial throws exception"
        (is (thrown? IllegalArgumentException (factorial -1)))
        (is (thrown? IllegalArgumentException (factorial -2)))
        (is (thrown? IllegalArgumentException (factorial -100)))))
&nbsp;
(deftest negative-exception-test
    (testing "(negative test) If factorial throws exception"
        (is (thrown? IllegalArgumentException (factorial 1)))
        (is (thrown? IllegalArgumentException (factorial 2)))
        (is (thrown? IllegalArgumentException (factorial 3)))))

</pre>

<p>V&nbsp;případě, že se nepoužije modul <strong>humane-test-output</strong>,
bude vygenerovaný výstup obsahovat mj.&nbsp;i zvýrazněné řádky, které pouze
opakují krok testu a také fakt, že se výsledky neshodují s&nbsp;očekávanými
hodnotami (not (= 1 0)):</p>

<pre>
lein test factorial4.core-test
&nbsp;
lein test :only factorial4.core-test/negative-factorial-test
&nbsp;
FAIL in (negative-factorial-test) (core_test.clj:15)
Negative tests
negative test case #1
<strong>expected: (= (factorial 0) 0)</strong>
  <strong>actual: (not (= 1 0))</strong>
&nbsp;
lein test :only factorial4.core-test/negative-factorial-test
&nbsp;
FAIL in (negative-factorial-test) (core_test.clj:16)
Negative tests
negative test case #2
<strong>expected: (= (factorial 1) 0)</strong>
  <strong>actual: (not (= 1 0))</strong>
&nbsp;
lein test :only factorial4.core-test/negative-factorial-test
&nbsp;
FAIL in (negative-factorial-test) (core_test.clj:17)
Negative tests
negative test case #3
<strong>expected: (= (factorial 2) 0)</strong>
  <strong>actual: (not (= 2 0))</strong>
&nbsp;
lein test :only factorial4.core-test/negative-exception-test
&nbsp;
FAIL in (negative-exception-test) (core_test.clj:27)
(negative test) If factorial throws exception
expected: (thrown? IllegalArgumentException (factorial 1))
  actual: nil
&nbsp;
lein test :only factorial4.core-test/negative-exception-test
&nbsp;
FAIL in (negative-exception-test) (core_test.clj:28)
(negative test) If factorial throws exception
expected: (thrown? IllegalArgumentException (factorial 2))
  actual: nil
&nbsp;
lein test :only factorial4.core-test/negative-exception-test
&nbsp;
FAIL in (negative-exception-test) (core_test.clj:29)
(negative test) If factorial throws exception
expected: (thrown? IllegalArgumentException (factorial 3))
  actual: nil
&nbsp;
Ran 4 tests containing 14 assertions.
6 failures, 0 errors.
</pre>

<p>V&nbsp;případě, kdy naopak modul <strong>humane-test-output</strong>
korektně nakonfigurujeme a použijeme, budou výsledky mnohem čitelnější, což je
ostatně patrné z&nbsp;následujícího výpisu:</p>

<pre>
lein test factorial4.core-test
&nbsp;
lein test :only factorial4.core-test/negative-factorial-test
&nbsp;
FAIL in (negative-factorial-test) (core_test.clj:15)
Negative tests
negative test case #1
expected: 1
  actual: 0
    diff: - 1
          + 0
&nbsp;
lein test :only factorial4.core-test/negative-factorial-test
&nbsp;
FAIL in (negative-factorial-test) (core_test.clj:16)
Negative tests
negative test case #2
expected: 1
  actual: 0
    diff: - 1
          + 0
&nbsp;
lein test :only factorial4.core-test/negative-factorial-test
&nbsp;
FAIL in (negative-factorial-test) (core_test.clj:17)
Negative tests
negative test case #3
expected: 2
  actual: 0
    diff: - 2
          + 0
&nbsp;
lein test :only factorial4.core-test/negative-exception-test
&nbsp;
FAIL in (negative-exception-test) (core_test.clj:27)
(negative test) If factorial throws exception
expected: (thrown? IllegalArgumentException (factorial 1))
  actual: nil
&nbsp;
lein test :only factorial4.core-test/negative-exception-test
&nbsp;
FAIL in (negative-exception-test) (core_test.clj:28)
(negative test) If factorial throws exception
expected: (thrown? IllegalArgumentException (factorial 2))
  actual: nil
&nbsp;
lein test :only factorial4.core-test/negative-exception-test
&nbsp;
FAIL in (negative-exception-test) (core_test.clj:29)
(negative test) If factorial throws exception
expected: (thrown? IllegalArgumentException (factorial 3))
  actual: nil
&nbsp;
Ran 4 tests containing 14 assertions.
6 failures, 0 errors.
</pre>

<p>Zkusme si vytvořit a otestovat ještě jeden příklad, tentokrát napsaný
takovým způsobem, aby se porovnávala relativně složitá datová struktura.
V&nbsp;následujícím úryvku kódu se vytváří struktura odpovědi
(<i>response</i>), kterou server odesílá klientovi. Struktura je před odesláním
zpracována knihovnou <a
href="https://www.root.cz/clanky/leiningen-nastroj-pro-spravu-projektu-napsanych-v-clojure-4/">Ring</a>,
tuto část kódu ovšem netestujeme &ndash; zajímá nás jen, zda bude datová
struktura vytvořená funkcí nazvanou <strong>generate-response</strong>
korektní. Nejprve se podívejme na zdrojový kód testované aplikace
(resp.&nbsp;přesněji řečeno její relevantní části):</p>

<pre>
(ns humane-output.core
    (:gen-class))
&nbsp;
(require '[ring.util.response :as response])
&nbsp;
(defn cache-control-headers
    "Update the response to contains all cache-control headers."
    [response]
    (-&gt; response
        (assoc-in [:headers "Cache-Control"] ["must-revalidate" "no-cache" "no-store"])
        (assoc-in [:headers "Expires"] "0")
        (assoc-in [:headers "Pragma"] "no-cache")))
&nbsp;
(defn generate-response
    [content]
    (-&gt; (response/response content)
        (response/content-type "text/plain; charset=utf-8")
        cache-control-headers))
&nbsp;
(defn -main
    [&amp; args]
    (println (generate-response "Hello world!")))
</pre>

<p>Test je napsán velmi jednoduše. Nejprve se v&nbsp;něm definuje očekávaná
hodnota (viz symbol <strong>expected-response</strong>) a následně jen
zjistíme, zda je hodnota (tj.&nbsp;celá datová struktura) vrácená funkcí
<strong>generate-response</strong> shodná s&nbsp;očekávanou hodnotou.
Připomeňme si, že porovnání funkcí <strong>=</strong> lze v&nbsp;Clojure
provést i pro libovolně složité struktury (o samotný rekurzivní sestup se
nemusíme starat):</p>

<pre>
user=&gt; <strong>(doc =)</strong>
-------------------------
clojure.core/=
([x] [x y] [x y &amp; more])
  Equality. Returns true if x equals y, false if not. Same as
  Java x.equals(y) except it also works for nil, and compares
  numbers and collections in a type-independent manner.  Clojure's immutable data
  structures define equals() (and thus =) as a value, not an identity,
  comparison.
nil
</pre>

<p>Povšimněte si, že v&nbsp;testu očekáváme, že pod klíčem
<strong>Expires</strong> je uložena hodnota "-1" a nikoli "0". Z&nbsp;tohoto
důvodu se po spuštění testů příkazem <strong>lein test</strong> nahlásí
chyba:</p>

<pre>
(ns humane-output.core-test
  (:require [clojure.test :refer :all]
            [humane-output.core :refer :all]))
&nbsp;
&nbsp;
(def expected-response
    {:status 200,
     :headers
           {"Content-Type" "text/plain; charset=utf-8",
            "Cache-Control" ["must-revalidate" "no-cache" "no-store"],
            "Expires" "-1",
            "Pragma" "no-cache"},
     :body "hello world!"})
&nbsp;
&nbsp;
(deftest test-generate-response
    (testing "Function generate-response"
        (is (= expected-response
               (generate-response "hello world!")))))

</pre>

<p>V&nbsp;případě, že se nepoužije modul <strong>humane-test-output</strong>,
bude výstup dosti nečitelný. Ostatně posuďte sami, kolik času je nutné pro
zjištění skutečného problému na řádku <strong>actual:</strong>:</p>

<pre>
lein test humane-output.core-test
&nbsp;
lein test :only humane-output.core-test/test-generate-response
&nbsp;
FAIL in (test-generate-response) (core_test.clj:18)
Function generate-response
expected: (= expected-response (generate-response "hello world!"))
  actual: (not (= {:status 200, :headers {"Content-Type" "text/plain; charset=utf-8","Cache-Control" ["must-revalidate" "no-cache" "no-store"], "Expires" "-1", "Pragma" "no-cache"}, :body "hello world!"} {:status 200, :headers {"Content-Type" "text/plain; charset=utf-8", "Cache-Control" ["must-revalidate" "no-cache" "no-store"], "Expires" "0", "Pragma" "no-cache"}, :body "hello world!"}))
&nbsp;
Ran 1 tests containing 1 assertions.
1 failures, 0 errors.
</pre>

<p>Naproti tomu je při použití modulu <strong>humane-test-output</strong> ihned
patrné, kde spočívá příčina pádu testu. Obě struktury jsou totiž nejdříve
vypsány pod sebou s&nbsp;využitím funkce <strong>pprint</strong> a navíc se
ještě zobrazí pouze rozdíly mezi oběma strukturami formou inteligentního diffu
(viz zvýrazněné řádky):</p>

<pre>
lein test humane-output.core-test
&nbsp;
lein test :only humane-output.core-test/test-generate-response
&nbsp;
FAIL in (test-generate-response) (core_test.clj:18)
Function generate-response
expected: {:status 200,
           :headers
           {"Content-Type" "text/plain; charset=utf-8",
            "Cache-Control" ["must-revalidate" "no-cache" "no-store"],
            "Expires" "-1",
            "Pragma" "no-cache"},
           :body "hello world!"}
  actual: {:status 200,
           :headers
           {"Content-Type" "text/plain; charset=utf-8",
            "Cache-Control" ["must-revalidate" "no-cache" "no-store"],
            "Expires" "0",
            "Pragma" "no-cache"},
           :body "hello world!"}
    diff: <strong>- {:headers {"Expires" "-1"}}</strong>
          <strong>+ {:headers {"Expires" "0"}}</strong>
&nbsp;
Ran 1 tests containing 1 assertions.
1 failures, 0 errors.
</pre>

<p>Funkci tohoto modulu je možné kdykoli zakázat nastavením proměnné prostředí
<strong>INHUMANE_TEST_OUTPUT</strong> (to lze provést i z&nbsp;IDE atd.).</p>



<p><a name="k07"></a></p>
<h2 id="k07">7. Jednotkové testy s&nbsp;výstupem kompatibilním s&nbsp;JUnit</h2>

<p>Příkazem <strong>lein test</strong> je sice možné spustit jednotkové testy a
získat čitelný výstup, tj.&nbsp;informaci o tom, kolik testů bylo spuštěno,
kolik testů proběhlo v&nbsp;pořádku a které testy naopak našly v&nbsp;aplikaci
chybu, ovšem výstupní formát je poněkud neobvyklý. Ve světě Javy (a vlastně i
mimo tento svět) se ustálilo použití XML formátu kompatibilního
s&nbsp;nástrojem <i>JUnit</i>. Tento formát dokážou zpracovat jak mnohá
integrovaná vývojová prostředí, tak i například několik přídavných modulů pro
systém Jenkins popř.&nbsp;Hudson. Tyto moduly dokážou například vytvářet grafy
s&nbsp;regresemi atd., takže by bylo vhodné nějakým způsobem upravit
<i>Leiningen</i> takovým způsobem, aby formát <i>JUnitu</i> podporoval. To je
samozřejmě možné, a to především díky velké rozšiřitelnosti <i>Leiningenu</i> o
další moduly. Modul, který budeme potřebovat, se jmenuje jednoduše
<strong>test2junit</strong> a v&nbsp;následujících odstavcích si ukážeme jeho
základní použití.</p>

<p>Aby bylo možné tento modul použít, je nutné upravit projektový soubor
<strong>project.clj</strong>, přesněji řečeno do něj doplnit informaci o
používaném pluginu (nikoli knihovně!, ty se zapisují do sekce
<strong>:dependencies</strong>):</p>

<pre>
(defproject factorial2 "0.1.0-SNAPSHOT"
    :description "FIXME: write description"
    :url "http://example.com/FIXME"
    :license {:name "Eclipse Public License"
              :url "http://www.eclipse.org/legal/epl-v10.html"}
    :dependencies [[org.clojure/clojure "1.6.0"]]
    :main ^:skip-aot factorial2.core
    :target-path "target/%s"
    <strong>:plugins [[test2junit "1.1.0"]]</strong>
    :profiles {:uberjar {:aot :all}})
</pre>

*** image ***
<p><i>Obrázek 1: Aplikace psané v&nbsp;Clojure testované v&nbsp;CI (Jenkinsu).
Díky použití <strong>test2junit</strong> lze využívat všech pluginů Jenkinsu
pro zpracování výsledků testů &ndash; viz grafy úspěšnosti.</i></p>

<p>Následně je vhodné spustit následující příkaz, který zajistí stažení nového
modulu a popř.&nbsp;i všech knihoven, na nichž tento modul závisí (pokud tento
příkaz nespustíte, spustí se automaticky při prvním volání testů):</p>

<pre>
<strong>lein deps</strong>
&nbsp;
Retrieving test2junit/test2junit/1.1.0/test2junit-1.1.0.pom from clojars
Retrieving test2junit/test2junit/1.1.0/test2junit-1.1.0.jar from clojars
</pre>

*** image ***
<p><i>Obrázek 2: Tabulka s&nbsp;výsledky jednotkových testů pro aplikace psané
v&nbsp;jazyku Clojure.</i></p>



<p><a name="k08"></a></p>
<h2 id="k08">8. Spuštění jednotkového testu a konverze výsledku do formátu kompatibilního s&nbsp;JUnit</h2>

<p>Nyní nastává zajímavý okamžik &ndash; spustíme totiž nástroj
<i>Leiningen</i> s&nbsp;novým jménem úkolu (task). To je možné, protože
<i>Leiningen</i> byl díky úpravě souboru <strong>project.clj</strong> rozšířen
o novou funkcionalitu (onen zmíněný plugin):</p>

<pre>
<strong>lein test2junit</strong>
</pre>

<p>Na standardní výstup se vypíšou následující informace (v&nbsp;některých
případech se však ještě stáhnou zbývající knihovny, na nichž dokončení
zvoleného úkolu závisí):</p>

<pre>
Using test2junit version: 1.1.0
Running Tests...
Writing output to: test2junit
Creating default build.xml file.
&nbsp;
Testing: factorial2.core-test
&nbsp;
Ran 2 tests containing 8 assertions.
0 failures, 0 errors.
</pre>

<p>Výsledkem běhu tohoto nového tasku je soubor <strong>build.xml</strong> a
především pak adresářová struktura <strong>test2unit</strong> obsahující soubor
s&nbsp;cestou <strong>test2unit/xml/factorial2.core-test.xml</strong>.
Podívejme se na obsah tohoto souboru:</p>

<pre>
&lt;?xml version="1.0" encoding="UTF-8"?&gt;
&lt;testsuite name="factorial2.core-test" errors="0" failures="0" tests="2" time="0.0142" timestamp="2015-02-21_20:56:31+0100"&gt;
    &lt;testcase name="factorial-test" classname="factorial2.core-test" time="0.0044"&gt;
    &lt;/testcase&gt;
    &lt;testcase name="exception-test" classname="factorial2.core-test" time="0.0013"&gt;
    &lt;/testcase&gt;
&lt;/testsuite&gt;
</pre>

<p>Vidíme, že jsou zde uloženy informace jak o jménu spuštěných testů, tak i o
době běhu a čase spuštění.</p>

*** image ***
<p><i>Obrázek 3: Výsledky běhu jednotkových testů pro vybraný projekt
naprogramovaný v&nbsp;Clojure.</i></p>

<p>Pokud uděláme ve zdrojovém kódu aplikace záměrnou chybu &ndash; vynechání
volání funkce <strong>inc</strong> &ndash; bude výsledek běhu testů
odlišný:</p>

<pre>
<strong>lein test2junit</strong>
&nbsp;
Using test2junit version: 1.1.0
Running Tests...
Writing output to: test2junit
&nbsp;
Testing: factorial2.core-test
&nbsp;
Ran 2 tests containing 8 assertions.
3 failures, 0 errors.
Tests failed.
Tests failed.
</pre>

<p>A odlišovat se samozřejmě bude i výstupní XML soubor:o</p>

<pre>
&lt;?xml version="1.0" encoding="UTF-8"?&gt;
&lt;testsuite name="factorial2.core-test" errors="0" failures="3" tests="2" time="0.0232" timestamp="2015-02-21_20:59:03+0100"&gt;
    &lt;testcase name="factorial-test" classname="factorial2.core-test" time="0.0168"&gt;
    &lt;failure message="still easy"&gt;still easy
expected: (= (factorial 2) (* 1 2))
  actual: (not (= 1 2))
      at: AFn.java:18&lt;/failure&gt;
    &lt;failure message="5!"&gt;5!
expected: (= (factorial 5) (* 1 2 3 4 5))
  actual: (not (= 24 120))
      at: AFn.java:18&lt;/failure&gt;
    &lt;failure message="6!"&gt;6!
expected: (= (factorial 6) 720)
  actual: (not (= 120 720))
      at: AFn.java:18&lt;/failure&gt;
    &lt;/testcase&gt;
    &lt;testcase name="exception-test" classname="factorial2.core-test" time="0.0011"&gt;
    &lt;/testcase&gt;
&lt;/testsuite&gt;
</pre>

*** image ***
<p><i>Obrázek 4: Podrobnější informace o výsledcích jednotkových testů, opět
získané díky pluginu <strong>test2unit</strong>.</i></p>



<p><a name="k09"></a></p>
<h2 id="k09">9. Plugin <strong>cloverage</strong> &ndash; zjištění pokrytí kódu testy</h2>

<p>Dalším užitečným pluginem určeným pro nástroj <i>Leiningen</i>, který je
určený pro usnadnění práce testerů či devops, je modul nazvaný
<i>cloverage</i>. Úkolem tohoto modulu je zjištění, které části programového
kódu jsou pokryté testy, tj.&nbsp;opět se jedná o analogii k&nbsp;podobným
nástrojům existujícím i pro další programovací jazyky, ovšem s&nbsp;tím
rozdílem, že kvůli použití maker je zjištění pokrytí testy v&nbsp;programovacím
jazyku <i>Clojure</i> složitější.</p>



<p><a name="k10"></a></p>
<h2 id="k10">10. Příklad výstupu generovaného pluginem <strong>cloverage</strong></h2>



<p><a name="k11"></a></p>
<h2 id="k11">11. Knihovna <strong>iota</strong> a její použití při tvorbě testů</h2>



<p><a name="k12"></a></p>
<h2 id="k12">12. Ukázka testu napsaného s&nbsp;využitím knihovny <strong>iota</strong></h2>



<p><a name="k13"></a></p>
<h2 id="k13">13. Testování s&nbsp;využitím knihovny Expectations</h2>



<p><a name="k14"></a></p>
<h2 id="k14">14. </h2>



<p><a name="k15"></a></p>
<h2 id="k15">15. </h2>



<p><a name="k16"></a></p>
<h2 id="k16">16. Podpora pro BDD (behaviour-driven development) knihovnou <strong>cucumber-jvm-clojure</strong></h2>



<p><a name="k17"></a></p>
<h2 id="k17">17. Jednoduchý projekt testovaný s&nbsp;využitím BDD</h2>

<p></p>

<pre>
(defproject cucumber-demo "0.1.0-SNAPSHOT"
    :description "FIXME: write description"
    :url "http://example.com/FIXME"
    :license {:name "Eclipse Public License"
              :url "http://www.eclipse.org/legal/epl-v10.html"}
    :dependencies [[org.clojure/clojure "1.9.0"]]
    :plugins [<strong>[com.siili/lein-cucumber "1.0.7"]</strong>]
    :<strong>cucumber-feature-paths ["test/features/"]</strong>
    :main ^:skip-aot cucumber-demo.core
    :target-path "target/%s"
    :profiles {:uberjar {:aot :all}
               <strong>:dev {:dependencies [[com.siili/lein-cucumber "1.0.7"]]</strong>}})
</pre>

<p></p>

<pre>
$ <strong>lein deps</strong>
&nbsp;
Retrieving com/siili/lein-cucumber/1.0.7/lein-cucumber-1.0.7.pom from clojars
Retrieving info/cukes/cucumber-clojure/1.2.4/cucumber-clojure-1.2.4.pom from central
Retrieving info/cukes/cucumber-jvm/1.2.4/cucumber-jvm-1.2.4.pom from central
Retrieving info/cukes/cucumber-core/1.2.4/cucumber-core-1.2.4.pom from central
Retrieving info/cukes/cucumber-html/0.2.3/cucumber-html-0.2.3.pom from central
Retrieving org/sonatype/oss/oss-parent/6/oss-parent-6.pom from central
Retrieving info/cukes/cucumber-jvm-deps/1.0.5/cucumber-jvm-deps-1.0.5.pom from central
Retrieving info/cukes/gherkin/2.12.2/gherkin-2.12.2.pom from central
...
...
...
Retrieving robert/hooke/1.3.0/hooke-1.3.0.jar from clojars
Retrieving useful/useful/0.8.6/useful-0.8.6.jar from clojars
Retrieving leiningen-core/leiningen-core/2.0.0/leiningen-core-2.0.0.jar from clojars
</pre>



<p><a name="k18"></a></p>
<h2 id="k18">18. Repositář s&nbsp;demonstračními příklady</h2>

<p>Všechny demonstrační příklady a projekty určené pro Clojure verze 1.9.0 byly
uloženy do repositáře <a
href="https://github.com/tisnik/clojure-examples">https://github.com/tisnik/clojure-examples</a>:</p>

<table>
<tr><th>Projekt</th><th>Popis</th><th>Odkaz</th></tr>
<tr><td>1</td><td>factorial</td><td><a href="https://github.com/tisnik/clojure-examples/tree/master/factorial">https://github.com/tisnik/clojure-examples/tree/master/factorial</a></td></tr>
<tr><td>2</td><td>factorial2</td><td><a href="https://github.com/tisnik/clojure-examples/tree/master/factorial2">https://github.com/tisnik/clojure-examples/tree/master/factorial2</a></td></tr>
<tr><td>3</td><td>factorial3</td><td><a href="https://github.com/tisnik/clojure-examples/tree/master/factorial3">https://github.com/tisnik/clojure-examples/tree/master/factorial3</a></td></tr>
<tr><td>4</td><td>factorial4</td><td><a href="https://github.com/tisnik/clojure-examples/tree/master/factorial4">https://github.com/tisnik/clojure-examples/tree/master/factorial4</a></td></tr>
<tr><td>5</td><td>expectations-demo</td><td><a href="https://github.com/tisnik/clojure-examples/tree/master/expectations-demo">https://github.com/tisnik/clojure-examples/tree/master/expectations-demo</a></td></tr>
<tr><td>6</td><td>cloverage</td><td><a href="https://github.com/tisnik/clojure-examples/tree/master/cloverage">https://github.com/tisnik/clojure-examples/tree/master/cloverage</a></td></tr>
<tr><td>7</td><td>humane-output</td><td><a href="https://github.com/tisnik/clojure-examples/tree/master/humane-output">https://github.com/tisnik/clojure-examples/tree/master/humane-output</a></td></tr>
<tr><td>8</td><td>iota-test</td><td><a href="https://github.com/tisnik/clojure-examples/tree/master/iota-test">https://github.com/tisnik/clojure-examples/tree/master/iota-test</a></td></tr>
<tr><td>9</td><td>cucumber-demo</td><td><a href="https://github.com/tisnik/clojure-examples/tree/master/cucumber-demo">https://github.com/tisnik/clojure-examples/tree/master/cucumber-demo</a></td></tr>
<tr><td>10</td><td></td><td><a href="https://github.com/tisnik/clojure-examples/tree/master/">https://github.com/tisnik/clojure-examples/tree/master/</a></td></tr>
</table>

<p><div class="rs-tip-major">Poznámka: pro spuštění projektů je vyžadován
nainstalovaný správce projektů <i>Leiningen</i>.</div></p>



<p><a name="k19"></a></p>
<h2 id="k19">19. Odkazy na předchozí části tohoto seriálu</h2>

<ol>

<li>Clojure  1: Úvod<br />
<a href="http://www.root.cz/clanky/clojure-aneb-jazyk-umoznujici-tvorbu-bezpecnych-vicevlaknovych-aplikaci-pro-jvm/">http://www.root.cz/clanky/clojure-aneb-jazyk-umoznujici-tvorbu-bezpecnych-vicevlaknovych-aplikaci-pro-jvm/</a>
</li>

<li>Clojure  2: Symboly, kolekce atd.<br />
<a href="http://www.root.cz/clanky/clojure-aneb-jazyk-umoznujici-tvorbu-bezpecnych-vicevlaknovych-aplikaci-pro-jvm-2-cast/">http://www.root.cz/clanky/clojure-aneb-jazyk-umoznujici-tvorbu-bezpecnych-vicevlaknovych-aplikaci-pro-jvm-2-cast/</a>
</li>

<li>Clojure  3: Funkcionální programování<br />
<a href="http://www.root.cz/clanky/clojure-aneb-jazyk-umoznujici-tvorbu-bezpecnych-vicevlaknovych-aplikaci-pro-jvm-3-cast-funkcionalni-programovani/">http://www.root.cz/clanky/clojure-aneb-jazyk-umoznujici-tvorbu-bezpecnych-vicevlaknovych-aplikaci-pro-jvm-3-cast-funkcionalni-programovani/</a>
</li>

<li>Clojure  4: Kolekce, sekvence a lazy sekvence<br />
<a href="http://www.root.cz/clanky/clojure-aneb-jazyk-umoznujici-tvorbu-bezpecnych-vicevlaknovych-aplikaci-pro-jvm-4-cast-kolekce-sekvence-a-lazy-sekvence/">http://www.root.cz/clanky/clojure-aneb-jazyk-umoznujici-tvorbu-bezpecnych-vicevlaknovych-aplikaci-pro-jvm-4-cast-kolekce-sekvence-a-lazy-sekvence/</a>
</li>

<li>Clojure  5: Sekvence, lazy sekvence a paralelní programy<br />
<a href="http://www.root.cz/clanky/clojure-a-bezpecne-aplikace-pro-jvm-sekvence-lazy-sekvence-a-paralelni-programy/">http://www.root.cz/clanky/clojure-a-bezpecne-aplikace-pro-jvm-sekvence-lazy-sekvence-a-paralelni-programy/</a>
</li>

<li>Clojure  6: Podpora pro paralelní programování<br />
<a href="http://www.root.cz/clanky/programovaci-jazyk-clojure-6-futures-nejsou-jen-financni-derivaty/">http://www.root.cz/clanky/programovaci-jazyk-clojure-6-futures-nejsou-jen-financni-derivaty/</a>
</li>

<li>Clojure  7: Další funkce pro paralelní programování<br />
<a href="http://www.root.cz/clanky/programovaci-jazyk-clojure-7-dalsi-podpurne-prostredky-pro-paralelni-programovani/">http://www.root.cz/clanky/programovaci-jazyk-clojure-7-dalsi-podpurne-prostredky-pro-paralelni-programovani/</a>
</li>

<li>Clojure  8: Identity, stavy, neměnné hodnoty a reference<br />
<a href="http://www.root.cz/clanky/programovaci-jazyk-clojure-8-identity-stavy-nemenne-hodnoty-a-referencni-typy/">http://www.root.cz/clanky/programovaci-jazyk-clojure-8-identity-stavy-nemenne-hodnoty-a-referencni-typy/</a>
</li>

<li>Clojure  9: Validátory, pozorovatelé a kooperace s Javou<br />
<a href="http://www.root.cz/clanky/programovaci-jazyk-clojure-9-validatory-pozorovatele-a-kooperace-mezi-clojure-a-javou/">http://www.root.cz/clanky/programovaci-jazyk-clojure-9-validatory-pozorovatele-a-kooperace-mezi-clojure-a-javou/</a>
</li>

<li>Clojure 10: Kooperace mezi Clojure a Javou<br />
<a href="http://www.root.cz/clanky/programovaci-jazyk-clojure-10-kooperace-mezi-clojure-a-javou-pokracovani/">http://www.root.cz/clanky/programovaci-jazyk-clojure-10-kooperace-mezi-clojure-a-javou-pokracovani/</a>
</li>

<li>Clojure 11: Generátorová notace seznamu/list comprehension<br />
<a href="http://www.root.cz/clanky/programovaci-jazyk-clojure-11-generatorova-notace-seznamu-list-comprehension/">http://www.root.cz/clanky/programovaci-jazyk-clojure-11-generatorova-notace-seznamu-list-comprehension/</a>
</li>

<li>Clojure 12: Překlad programů z Clojure do bajtkódu JVM I:<br />
<a href="http://www.root.cz/clanky/programovaci-jazyk-clojure-12-preklad-programu-z-clojure-do-bajtkodu-jvm/">http://www.root.cz/clanky/programovaci-jazyk-clojure-12-preklad-programu-z-clojure-do-bajtkodu-jvm/</a>
</li>

<li>Clojure 13: Překlad programů z Clojure do bajtkódu JVM II:<br />
<a href="http://www.root.cz/clanky/programovaci-jazyk-clojure-13-preklad-programu-z-clojure-do-bajtkodu-jvm-pokracovani/">http://www.root.cz/clanky/programovaci-jazyk-clojure-13-preklad-programu-z-clojure-do-bajtkodu-jvm-pokracovani/</a>
</li>

<li>Clojure 14: Základy práce se systémem maker<br />
<a href="http://www.root.cz/clanky/programovaci-jazyk-clojure-14-zaklady-prace-se-systemem-maker/">http://www.root.cz/clanky/programovaci-jazyk-clojure-14-zaklady-prace-se-systemem-maker/</a>
</li>

<li>Clojure 15: Tvorba uživatelských maker<br />
<a href="http://www.root.cz/clanky/programovaci-jazyk-clojure-15-tvorba-uzivatelskych-maker/">http://www.root.cz/clanky/programovaci-jazyk-clojure-15-tvorba-uzivatelskych-maker/</a>
</li>

<li>Clojure 16: Složitější uživatelská makra<br />
<a href="http://www.root.cz/clanky/programovaci-jazyk-clojure-16-slozitejsi-uzivatelska-makra/">http://www.root.cz/clanky/programovaci-jazyk-clojure-16-slozitejsi-uzivatelska-makra/</a>
</li>

<li>Clojure 17: Využití standardních maker v praxi<br />
<a href="http://www.root.cz/clanky/programovaci-jazyk-clojure-17-vyuziti-standardnich-maker-v-praxi/">http://www.root.cz/clanky/programovaci-jazyk-clojure-17-vyuziti-standardnich-maker-v-praxi/</a>
</li>

<li>Clojure 18: Základní techniky optimalizace aplikací<br />
<a href="http://www.root.cz/clanky/programovaci-jazyk-clojure-18-zakladni-techniky-optimalizace-aplikaci/">http://www.root.cz/clanky/programovaci-jazyk-clojure-18-zakladni-techniky-optimalizace-aplikaci/</a>
</li>

<li>Clojure 19: Vývojová prostředí pro Clojure<br />
<a href="http://www.root.cz/clanky/programovaci-jazyk-clojure-19-vyvojova-prostredi-pro-clojure/">http://www.root.cz/clanky/programovaci-jazyk-clojure-19-vyvojova-prostredi-pro-clojure/</a>
</li>

<li>Clojure 20: Vývojová prostředí pro Clojure (Vimu s REPL)<br />
<a href="http://www.root.cz/clanky/programovaci-jazyk-clojure-20-vyvojova-prostredi-pro-clojure-integrace-vimu-s-repl/">http://www.root.cz/clanky/programovaci-jazyk-clojure-20-vyvojova-prostredi-pro-clojure-integrace-vimu-s-repl/</a>
</li>

<li>Clojure 21: ClojureScript aneb překlad Clojure do JS<br />
<a href="http://www.root.cz/clanky/programovaci-jazyk-clojure-21-clojurescript-aneb-preklad-clojure-do-javascriptu/">http://www.root.cz/clanky/programovaci-jazyk-clojure-21-clojurescript-aneb-preklad-clojure-do-javascriptu/</a>
</li>

<li>Leiningen: nástroj pro správu projektů napsaných v Clojure<br />
<a href="http://www.root.cz/clanky/leiningen-nastroj-pro-spravu-projektu-napsanych-v-clojure/">http://www.root.cz/clanky/leiningen-nastroj-pro-spravu-projektu-napsanych-v-clojure/</a>
</li>

<li>Leiningen: nástroj pro správu projektů napsaných v Clojure (2)<br />
<a href="http://www.root.cz/clanky/leiningen-nastroj-pro-spravu-projektu-napsanych-v-clojure-2/">http://www.root.cz/clanky/leiningen-nastroj-pro-spravu-projektu-napsanych-v-clojure-2/</a>
</li>

<li>Leiningen: nástroj pro správu projektů napsaných v Clojure (3)<br />
<a href="http://www.root.cz/clanky/leiningen-nastroj-pro-spravu-projektu-napsanych-v-clojure-3/">http://www.root.cz/clanky/leiningen-nastroj-pro-spravu-projektu-napsanych-v-clojure-3/</a>
</li>

<li>Leiningen: nástroj pro správu projektů napsaných v Clojure (4)<br />
<a href="http://www.root.cz/clanky/leiningen-nastroj-pro-spravu-projektu-napsanych-v-clojure-4/">http://www.root.cz/clanky/leiningen-nastroj-pro-spravu-projektu-napsanych-v-clojure-4/</a>
</li>

<li>Leiningen: nástroj pro správu projektů napsaných v Clojure (5)<br />
<a href="http://www.root.cz/clanky/leiningen-nastroj-pro-spravu-projektu-napsanych-v-clojure-5/">http://www.root.cz/clanky/leiningen-nastroj-pro-spravu-projektu-napsanych-v-clojure-5/</a>
</li>

<li>Leiningen: nástroj pro správu projektů napsaných v Clojure (6)<br />
<a href="http://www.root.cz/clanky/leiningen-nastroj-pro-spravu-projektu-napsanych-v-clojure-6/">http://www.root.cz/clanky/leiningen-nastroj-pro-spravu-projektu-napsanych-v-clojure-6/</a>
</li>

<li>Programovací jazyk Clojure a databáze (1.část)<br />
<a href="http://www.root.cz/clanky/programovaci-jazyk-clojure-a-databaze-1-cast/">http://www.root.cz/clanky/programovaci-jazyk-clojure-a-databaze-1-cast/</a>
</li>

<li>Pluginy pro Leiningen<br />
<a href="http://www.root.cz/clanky/leiningen-nastroj-pro-spravu-projektu-napsanych-v-clojure-pluginy-pro-leiningen/">http://www.root.cz/clanky/leiningen-nastroj-pro-spravu-projektu-napsanych-v-clojure-pluginy-pro-leiningen/</a>
</li>

<li>Programovací jazyk Clojure a knihovny pro práci s vektory a maticemi<br />
<a href="http://www.root.cz/clanky/programovaci-jazyk-clojure-a-knihovny-pro-praci-s-vektory-a-maticemi/">http://www.root.cz/clanky/programovaci-jazyk-clojure-a-knihovny-pro-praci-s-vektory-a-maticemi/</a>
</li>

<li>Programovací jazyk Clojure a knihovny pro práci s vektory a maticemi (2)<br />
<a href="http://www.root.cz/clanky/programovaci-jazyk-clojure-a-knihovny-pro-praci-s-vektory-a-maticemi-2/">http://www.root.cz/clanky/programovaci-jazyk-clojure-a-knihovny-pro-praci-s-vektory-a-maticemi-2/</a>
</li>

<li>Programovací jazyk Clojure: syntéza procedurálních textur s využitím knihovny Clisk<br />
<a href="http://www.root.cz/clanky/programovaci-jazyk-clojure-synteza-proceduralnich-textur-s-vyuzitim-knihovny-clisk/">http://www.root.cz/clanky/programovaci-jazyk-clojure-synteza-proceduralnich-textur-s-vyuzitim-knihovny-clisk/</a>
</li>

<li>Programovací jazyk Clojure: syntéza procedurálních textur s využitím knihovny Clisk (2)<br />
<a href="http://www.root.cz/clanky/programovaci-jazyk-clojure-synteza-proceduralnich-textur-s-vyuzitim-knihovny-clisk-2/">http://www.root.cz/clanky/programovaci-jazyk-clojure-synteza-proceduralnich-textur-s-vyuzitim-knihovny-clisk-2/</a>
</li>

<li>Seesaw: knihovna pro snadnou tvorbu GUI v jazyce Clojure<br />
<a href="http://www.root.cz/clanky/seesaw-knihovna-pro-snadnou-tvorbu-gui-v-jazyce-clojure/">http://www.root.cz/clanky/seesaw-knihovna-pro-snadnou-tvorbu-gui-v-jazyce-clojure/</a>
</li>

<li>Seesaw: knihovna pro snadnou tvorbu GUI v jazyce Clojure (2)<br />
<a href="http://www.root.cz/clanky/seesaw-knihovna-pro-snadnou-tvorbu-gui-v-jazyce-clojure-2/">http://www.root.cz/clanky/seesaw-knihovna-pro-snadnou-tvorbu-gui-v-jazyce-clojure-2/</a>
</li>

<li>Seesaw: knihovna pro snadnou tvorbu GUI v jazyce Clojure (3)<br />
<a href="http://www.root.cz/clanky/seesaw-knihovna-pro-snadnou-tvorbu-gui-v-jazyce-clojure-3/">http://www.root.cz/clanky/seesaw-knihovna-pro-snadnou-tvorbu-gui-v-jazyce-clojure-3/</a>
</li>

<li>Programovací jazyk Clojure a práce s Gitem<br />
<a href="http://www.root.cz/clanky/programovaci-jazyk-clojure-a-prace-s-gitem/">http://www.root.cz/clanky/programovaci-jazyk-clojure-a-prace-s-gitem/</a>
</li>

<li>Programovací jazyk Clojure: syntéza procedurálních textur s využitím knihovny Clisk (dokončení)<br />
<a href="http://www.root.cz/clanky/programovaci-jazyk-clojure-synteza-proceduralnich-textur-s-vyuzitim-knihovny-clisk-dokonceni/">http://www.root.cz/clanky/programovaci-jazyk-clojure-synteza-proceduralnich-textur-s-vyuzitim-knihovny-clisk-dokonceni/</a>
</li>

<li>Programovací jazyk Clojure a práce s Gitem (2)<br />
<a href="http://www.root.cz/clanky/programovaci-jazyk-clojure-a-prace-s-gitem-2/">http://www.root.cz/clanky/programovaci-jazyk-clojure-a-prace-s-gitem-2/</a>
</li>

<li>Programovací jazyk Clojure – triky při práci s řetězci<br />
<a href="http://www.root.cz/clanky/programovaci-jazyk-clojure-triky-pri-praci-s-retezci/">http://www.root.cz/clanky/programovaci-jazyk-clojure-triky-pri-praci-s-retezci/</a>
</li>

<li>Programovací jazyk Clojure – triky při práci s kolekcemi<br />
<a href="http://www.root.cz/clanky/programovaci-jazyk-clojure-triky-pri-praci-s-kolekcemi/">http://www.root.cz/clanky/programovaci-jazyk-clojure-triky-pri-praci-s-kolekcemi/</a>
</li>

<li>Programovací jazyk Clojure – práce s mapami a množinami<br />
<a href="http://www.root.cz/clanky/programovaci-jazyk-clojure-prace-s-mapami-a-mnozinami/">http://www.root.cz/clanky/programovaci-jazyk-clojure-prace-s-mapami-a-mnozinami/</a>
</li>

<li>Programovací jazyk Clojure – základy zpracování XML<br />
<a href="http://www.root.cz/clanky/programovaci-jazyk-clojure-zaklady-zpracovani-xml/">http://www.root.cz/clanky/programovaci-jazyk-clojure-zaklady-zpracovani-xml/</a>
</li>

<li>Programovací jazyk Clojure – testování s využitím knihovny Expectations<br />
<a href="http://www.root.cz/clanky/programovaci-jazyk-clojure-testovani-s-vyuzitim-knihovny-expectations/">http://www.root.cz/clanky/programovaci-jazyk-clojure-testovani-s-vyuzitim-knihovny-expectations/</a>
</li>

<li>Programovací jazyk Clojure – některé užitečné triky použitelné (nejenom) v&nbsp;testech<br />
<a href="http://www.root.cz/clanky/programovaci-jazyk-clojure-nektere-uzitecne-triky-pouzitelne-nejenom-v-testech/">http://www.root.cz/clanky/programovaci-jazyk-clojure-nektere-uzitecne-triky-pouzitelne-nejenom-v-testech/</a>
</li>

<li>Enlive – výkonný šablonovací systém pro jazyk Clojure<br/>
<a href="http://www.root.cz/clanky/enlive-vykonny-sablonovaci-system-pro-jazyk-clojure/">http://www.root.cz/clanky/enlive-vykonny-sablonovaci-system-pro-jazyk-clojure/</a>
</li>

<li>Nástroj Leiningen a programovací jazyk Clojure: tvorba vlastních knihoven pro veřejný repositář Clojars<br />
<a href="http://www.root.cz/clanky/nastroj-leiningen-a-programovaci-jazyk-clojure-tvorba-vlastnich-knihoven-pro-verejny-repositar-clojars/">http://www.root.cz/clanky/nastroj-leiningen-a-programovaci-jazyk-clojure-tvorba-vlastnich-knihoven-pro-verejny-repositar-clojars/</a>
</li>

<li>Novinky v Clojure verze 1.8.0<br />
<a href="http://www.root.cz/clanky/novinky-v-clojure-verze-1-8-0/">http://www.root.cz/clanky/novinky-v-clojure-verze-1-8-0/</a>
</li>

<li>Asynchronní programování v&nbsp;Clojure s&nbsp;využitím knihovny core.async<br />
<a href="http://www.root.cz/clanky/asynchronni-programovani-v-clojure-s-vyuzitim-knihovny-core-async/">http://www.root.cz/clanky/asynchronni-programovani-v-clojure-s-vyuzitim-knihovny-core-async/</a>
</li>

<li>Asynchronní programování v&nbsp;Clojure s&nbsp;využitím knihovny core.async (pokračování)<br />
<a href="http://www.root.cz/clanky/asynchronni-programovani-v-clojure-s-vyuzitim-knihovny-core-async-pokracovani/">http://www.root.cz/clanky/asynchronni-programovani-v-clojure-s-vyuzitim-knihovny-core-async-pokracovani/</a>
</li>

<li>Asynchronní programování v Clojure s využitím knihovny core.async (dokončení)<br />
<a href="http://www.root.cz/clanky/asynchronni-programovani-v-clojure-s-vyuzitim-knihovny-core-async-dokonceni/">http://www.root.cz/clanky/asynchronni-programovani-v-clojure-s-vyuzitim-knihovny-core-async-dokonceni/</a>
</li>

<li>Vytváříme IRC bota v programovacím jazyce Clojure<br />
<a href="http://www.root.cz/clanky/vytvarime-irc-bota-v-programovacim-jazyce-clojure/">http://www.root.cz/clanky/vytvarime-irc-bota-v-programovacim-jazyce-clojure/</a>
</li>

<li>Gorilla REPL: interaktivní prostředí pro programovací jazyk Clojure<br />
<a href="https://www.root.cz/clanky/gorilla-repl-interaktivni-prostredi-pro-programovaci-jazyk-clojure/">https://www.root.cz/clanky/gorilla-repl-interaktivni-prostredi-pro-programovaci-jazyk-clojure/</a>
</li>

<li>Multimetody v Clojure aneb polymorfismus bez použití OOP<br />
<a href="https://www.root.cz/clanky/multimetody-v-clojure-aneb-polymorfismus-bez-pouziti-oop/">https://www.root.cz/clanky/multimetody-v-clojure-aneb-polymorfismus-bez-pouziti-oop/</a>
</li>

<li>Práce s externími Java archivy v programovacím jazyku Clojure<br />
<a href="https://www.root.cz/clanky/prace-s-externimi-java-archivy-v-programovacim-jazyku-clojure/">https://www.root.cz/clanky/prace-s-externimi-java-archivy-v-programovacim-jazyku-clojure/</a>
</li>

<li>Pixie: lehký skriptovací jazyk s „kouzelnými“ schopnostmi<br />
<a href="https://www.root.cz/clanky/pixie-lehky-skriptovaci-jazyk-s-kouzelnymi-schopnostmi/">https://www.root.cz/clanky/pixie-lehky-skriptovaci-jazyk-s-kouzelnymi-schopnostmi/</a>
</li>

<li>Programovací jazyk Pixie: funkce ze základní knihovny a použití FFI<br />
<a href="https://www.root.cz/clanky/programovaci-jazyk-pixie-funkce-ze-zakladni-knihovny-a-pouziti-ffi/">https://www.root.cz/clanky/programovaci-jazyk-pixie-funkce-ze-zakladni-knihovny-a-pouziti-ffi/</a>
</li>

<li>Novinky v Clojure verze 1.9.0<br />
<a href="https://www.root.cz/clanky/novinky-v-clojure-verze-1-9-0/">https://www.root.cz/clanky/novinky-v-clojure-verze-1-9-0/</a>
</li>

<li>Validace dat s&nbsp;využitím knihovny spec v&nbsp;Clojure 1.9.0<br />
<a href="https://www.root.cz/clanky/validace-dat-s-vyuzitim-knihovny-spec-v-clojure-1-9-0/">https://www.root.cz/clanky/validace-dat-s-vyuzitim-knihovny-spec-v-clojure-1-9-0/</a>
</li>

</ol>



<p><a name="k20"></a></p>
<h2 id="k20">20. Odkazy na Internetu</h2>

<ol>

<li>Humane test output for clojure.test<br />
<a href="https://github.com/pjstadig/humane-test-output">https://github.com/pjstadig/humane-test-output</a>
</li>

<li>5 Differences between clojure.spec and Schema<br />
<a href="https://lispcast.com/clojure.spec-vs-schema/">https://lispcast.com/clojure.spec-vs-schema/</a>
</li>

<li>Schema: Clojure(Script) library for declarative data description and validation<br />
<a href="https://github.com/plumatic/schema">https://github.com/plumatic/schema</a>
</li>

<li>Zip archiv s&nbsp;Clojure 1.9.0<br />
<a href="http://repo1.maven.org/maven2/org/clojure/clojure/1.9.0/clojure-1.9.0.zip">http://repo1.maven.org/maven2/org/clojure/clojure/1.9.0/clojure-1.9.0.zip</a>
</li>

<li>Clojure 1.9 is now available<br />
<a href="https://clojure.org/news/2017/12/08/clojure19">https://clojure.org/news/2017/12/08/clojure19</a>
</li>

<li>Deps and CLI Guide<br />
<a href="https://clojure.org/guides/deps_and_cli">https://clojure.org/guides/deps_and_cli</a>
</li>

<li>Changes to Clojure in Version 1.9<br />
<a href="https://github.com/clojure/clojure/blob/master/changes.md">https://github.com/clojure/clojure/blob/master/changes.md</a>
</li>

<li>clojure.spec - Rationale and Overview<br />
<a href="https://clojure.org/about/spec">https://clojure.org/about/spec</a>
</li>

<li>Zip archiv s&nbsp;Clojure 1.8.0<br />
<a href="http://repo1.maven.org/maven2/org/clojure/clojure/1.8.0/clojure-1.8.0.zip">http://repo1.maven.org/maven2/org/clojure/clojure/1.8.0/clojure-1.8.0.zip</a>
</li>

<li>Clojure 1.8 is now available<br />
<a href="http://clojure.org/news/2016/01/19/clojure18">http://clojure.org/news/2016/01/19/clojure18</a>
</li>

<li>Socket Server REPL<br />
<a href="http://dev.clojure.org/display/design/Socket+Server+REPL">http://dev.clojure.org/display/design/Socket+Server+REPL</a>
</li>

<li>CLJ-1671: Clojure socket server<br />
<a href="http://dev.clojure.org/jira/browse/CLJ-1671">http://dev.clojure.org/jira/browse/CLJ-1671</a>
</li>

<li>CLJ-1449: Add clojure.string functions for portability to ClojureScript<br />
<a href="http://dev.clojure.org/jira/browse/CLJ-1449">http://dev.clojure.org/jira/browse/CLJ-1449</a>
</li>

<li>Launching a Socket Server<br />
<a href="http://clojure.org/reference/repl_and_main#_launching_a_socket_server">http://clojure.org/reference/repl_and_main#_launching_a_socket_server</a>
</li>

<li>API for clojure.string<br />
<a href="http://clojure.github.io/clojure/branch-master/clojure.string-api.html">http://clojure.github.io/clojure/branch-master/clojure.string-api.html</a>
</li>

<li>Clojars:<br />
<a href="https://clojars.org/">https://clojars.org/</a>
</li>

<li>Seznam knihoven na Clojars:<br />
<a href="https://clojars.org/projects">https://clojars.org/projects</a>
</li>

<li>Clojure Cookbook: Templating HTML with Enlive<br />
<a href="https://github.com/clojure-cookbook/clojure-cookbook/blob/master/07_webapps/7-11_enlive.asciidoc">https://github.com/clojure-cookbook/clojure-cookbook/blob/master/07_webapps/7-11_enlive.asciidoc</a>
</li>

<li>An Introduction to Enlive<br />
<a href="https://github.com/swannodette/enlive-tutorial/">https://github.com/swannodette/enlive-tutorial/</a>
</li>

<li>Enlive na GitHubu<br />
<a href="https://github.com/cgrand/enlive">https://github.com/cgrand/enlive</a>
</li>

<li>Expectations: příklady atd.<br />
<a href="http://jayfields.com/expectations/">http://jayfields.com/expectations/</a>
</li>

<li>Expectations na GitHubu<br />
<a href="https://github.com/jaycfields/expectations">https://github.com/jaycfields/expectations</a>
</li>

<li>Lein-expectations na GitHubu<br />
<a href="https://github.com/gar3thjon3s/lein-expectations">https://github.com/gar3thjon3s/lein-expectations</a>
</li>

<li>Testing Clojure With Expectations<br />
<a href="https://semaphoreci.com/blog/2014/09/23/testing-clojure-with-expectations.html">https://semaphoreci.com/blog/2014/09/23/testing-clojure-with-expectations.html</a>
</li>

<li>Clojure testing TDD/BDD libraries: clojure.test vs Midje vs Expectations vs Speclj<br />
<a href="https://www.reddit.com/r/Clojure/comments/1viilt/clojure_testing_tddbdd_libraries_clojuretest_vs/">https://www.reddit.com/r/Clojure/comments/1viilt/clojure_testing_tddbdd_libraries_clojuretest_vs/</a>
</li>

<li>Testing: One assertion per test<br />
<a href="http://blog.jayfields.com/2007/06/testing-one-assertion-per-test.html">http://blog.jayfields.com/2007/06/testing-one-assertion-per-test.html</a>
</li>

<li>Rewriting Your Test Suite in Clojure in 24 hours<br />
<a href="http://blog.circleci.com/rewriting-your-test-suite-in-clojure-in-24-hours/">http://blog.circleci.com/rewriting-your-test-suite-in-clojure-in-24-hours/</a>
</li>

<li>Clojure doc: zipper<br />
<a href="http://clojuredocs.org/clojure.zip/zipper">http://clojuredocs.org/clojure.zip/zipper</a>
</li>

<li>Clojure doc: parse<br />
<a href="http://clojuredocs.org/clojure.xml/parse">http://clojuredocs.org/clojure.xml/parse</a>
</li>

<li>Clojure doc: xml-zip<br />
<a href="http://clojuredocs.org/clojure.zip/xml-zip">http://clojuredocs.org/clojure.zip/xml-zip</a>
</li>

<li>Clojure doc: xml-seq<br />
<a href="http://clojuredocs.org/clojure.core/xml-seq">http://clojuredocs.org/clojure.core/xml-seq</a>
</li>

<li>Parsing XML in Clojure<br />
<a href="https://github.com/clojuredocs/guides">https://github.com/clojuredocs/guides</a>
</li>

<li>Clojure Zipper Over Nested Vector<br />
<a href="https://vitalyper.wordpress.com/2010/11/23/clojure-zipper-over-nested-vector/">https://vitalyper.wordpress.com/2010/11/23/clojure-zipper-over-nested-vector/</a>
</li>

<li>Understanding Clojure's PersistentVector implementation<br />
<a href="http://blog.higher-order.net/2009/02/01/understanding-clojures-persistentvector-implementation">http://blog.higher-order.net/2009/02/01/understanding-clojures-persistentvector-implementation</a>
</li>

<li>Understanding Clojure's PersistentHashMap (deftwice...)<br />
<a href="http://blog.higher-order.net/2009/09/08/understanding-clojures-persistenthashmap-deftwice.html">http://blog.higher-order.net/2009/09/08/understanding-clojures-persistenthashmap-deftwice.html</a>
</li>

<li>Assoc and Clojure's PersistentHashMap: part ii<br />
<a href="http://blog.higher-order.net/2010/08/16/assoc-and-clojures-persistenthashmap-part-ii.html">http://blog.higher-order.net/2010/08/16/assoc-and-clojures-persistenthashmap-part-ii.html</a>
</li>

<li>Ideal Hashtrees (paper)<br />
<a href="http://lampwww.epfl.ch/papers/idealhashtrees.pdf">http://lampwww.epfl.ch/papers/idealhashtrees.pdf</a>
</li>

<li>Clojure home page<br />
<a href="http://clojure.org/">http://clojure.org/</a>
</li>

<li>Clojure (downloads)<br />
<a href="http://clojure.org/downloads">http://clojure.org/downloads</a>
</li>

<li>Clojure Sequences<br />
<a href="http://clojure.org/sequences">http://clojure.org/sequences</a>
</li>

<li>Clojure Data Structures<br />
<a href="http://clojure.org/data_structures">http://clojure.org/data_structures</a>
</li>

<li>The Structure and Interpretation of Computer Programs: 2.2.1  Representing Sequences<br />
<a href="http://mitpress.mit.edu/sicp/full-text/book/book-Z-H-15.html#%_sec_2.2.1">http://mitpress.mit.edu/sicp/full-text/book/book-Z-H-15.html#%_sec_2.2.1</a>
</li>

<li>The Structure and Interpretation of Computer Programs: 3.3.1  Mutable List Structure<br />
<a href="http://mitpress.mit.edu/sicp/full-text/book/book-Z-H-22.html#%_sec_3.3.1">http://mitpress.mit.edu/sicp/full-text/book/book-Z-H-22.html#%_sec_3.3.1</a>
</li>

<li>Clojure - Functional Programming for the JVM<br />
<a href="http://java.ociweb.com/mark/clojure/article.html">http://java.ociweb.com/mark/clojure/article.html</a>
</li>

<li>Clojure quick reference<br />
<a href="http://faustus.webatu.com/clj-quick-ref.html">http://faustus.webatu.com/clj-quick-ref.html</a>
</li>

<li>4Clojure<br />
<a href="http://www.4clojure.com/">http://www.4clojure.com/</a>
</li>

<li>ClojureDoc (rozcestník s&nbsp;dokumentací jazyka Clojure)<br />
<a href="http://clojuredocs.org/">http://clojuredocs.org/</a>
</li>

<li>Clojure (na Wikipedia EN)<br />
<a href="http://en.wikipedia.org/wiki/Clojure">http://en.wikipedia.org/wiki/Clojure</a>
</li>

<li>Clojure (na Wikipedia CS)<br />
<a href="http://cs.wikipedia.org/wiki/Clojure">http://cs.wikipedia.org/wiki/Clojure</a>
</li>

<li>SICP (The Structure and Interpretation of Computer Programs)<br />
<a href="http://mitpress.mit.edu/sicp/">http://mitpress.mit.edu/sicp/</a>
</li>

<li>Pure function<br />
<a href="http://en.wikipedia.org/wiki/Pure_function">http://en.wikipedia.org/wiki/Pure_function</a>
</li>

<li>Funkcionální programování<br />
<a href="http://cs.wikipedia.org/wiki/Funkcionální_programování">http://cs.wikipedia.org/wiki/Funkcionální_programování</a>
</li>

<li>Čistě funkcionální (datové struktury, jazyky, programování)<br />
<a href="http://cs.wikipedia.org/wiki/Čistě_funkcionální">http://cs.wikipedia.org/wiki/Čistě_funkcionální</a>
</li>

<li>Clojure Macro Tutorial (Part I, Getting the Compiler to Write Your Code For You)<br />
<a href="http://www.learningclojure.com/2010/09/clojure-macro-tutorial-part-i-getting.html">http://www.learningclojure.com/2010/09/clojure-macro-tutorial-part-i-getting.html</a>
</li>

<li>Clojure Macro Tutorial (Part II: The Compiler Strikes Back)<br />
<a href="http://www.learningclojure.com/2010/09/clojure-macro-tutorial-part-ii-compiler.html">http://www.learningclojure.com/2010/09/clojure-macro-tutorial-part-ii-compiler.html</a>
</li>

<li>Clojure Macro Tutorial (Part III: Syntax Quote)<br />
<a href="http://www.learningclojure.com/2010/09/clojure-macro-tutorial-part-ii-syntax.html">http://www.learningclojure.com/2010/09/clojure-macro-tutorial-part-ii-syntax.html</a>
</li>

<li>Tech behind Tech: Clojure Macros Simplified<br />
<a href="http://techbehindtech.com/2010/09/28/clojure-macros-simplified/">http://techbehindtech.com/2010/09/28/clojure-macros-simplified/</a>
</li>

<li>Fatvat - Exploring functional programming: Clojure Macros<br />
<a href="http://www.fatvat.co.uk/2009/02/clojure-macros.html">http://www.fatvat.co.uk/2009/02/clojure-macros.html</a>
</li>

<li>Eulerovo číslo<br />
<a href="http://cs.wikipedia.org/wiki/Eulerovo_číslo">http://cs.wikipedia.org/wiki/Eulerovo_číslo</a>
</li>

<li>List comprehension<br />
<a href="http://en.wikipedia.org/wiki/List_comprehension">http://en.wikipedia.org/wiki/List_comprehension</a>
</li>

<li>List Comprehensions in Clojure<br />
<a href="http://asymmetrical-view.com/2008/11/18/list-comprehensions-in-clojure.html">http://asymmetrical-view.com/2008/11/18/list-comprehensions-in-clojure.html</a>
</li>

<li>Clojure Programming Concepts: List Comprehension<br />
<a href="http://en.wikibooks.org/wiki/Clojure_Programming/Concepts#List_Comprehension">http://en.wikibooks.org/wiki/Clojure_Programming/Concepts#List_Comprehension</a>
</li>

<li>Clojure core API: for macro<br />
<a href="http://clojure.github.com/clojure/clojure.core-api.html#clojure.core/for">http://clojure.github.com/clojure/clojure.core-api.html#clojure.core/for</a>
</li>

<li>cirrus machina - The Clojure for macro<br />
<a href="http://www.cirrusmachina.com/blog/comment/the-clojure-for-macro/">http://www.cirrusmachina.com/blog/comment/the-clojure-for-macro/</a>
</li>

<li>Riastradh's Lisp Style Rules<br />
<a href="http://mumble.net/~campbell/scheme/style.txt">http://mumble.net/~campbell/scheme/style.txt</a>
</li>

<li>Dynamic Languages Strike Back<br />
<a href="http://steve-yegge.blogspot.cz/2008/05/dynamic-languages-strike-back.html">http://steve-yegge.blogspot.cz/2008/05/dynamic-languages-strike-back.html</a>
</li>

<li>Scripting: Higher Level Programming for the 21st Century<br />
<a href="http://www.tcl.tk/doc/scripting.html">http://www.tcl.tk/doc/scripting.html</a>
</li>

<li>Java Virtual Machine Support for Non-Java Languages<br />
<a href="http://docs.oracle.com/javase/7/docs/technotes/guides/vm/multiple-language-support.html">http://docs.oracle.com/javase/7/docs/technotes/guides/vm/multiple-language-support.html</a>
</li>

<li>Třída java.lang.String<br />
<a href="http://docs.oracle.com/javase/7/docs/api/java/lang/String.html">http://docs.oracle.com/javase/7/docs/api/java/lang/String.html</a>
</li>

<li>Třída java.lang.StringBuffer<br />
<a href="http://docs.oracle.com/javase/7/docs/api/java/lang/StringBuffer.html">http://docs.oracle.com/javase/7/docs/api/java/lang/StringBuffer.html</a>
</li>

<li>Třída java.lang.StringBuilder<br />
<a href="http://docs.oracle.com/javase/7/docs/api/java/lang/StringBuilder.html">http://docs.oracle.com/javase/7/docs/api/java/lang/StringBuilder.html</a>
</li>

<li>StringBuffer versus String<br />
<a href="http://www.javaworld.com/article/2076072/build-ci-sdlc/stringbuffer-versus-string.html">http://www.javaworld.com/article/2076072/build-ci-sdlc/stringbuffer-versus-string.html</a>
</li>

<li>Threading macro (dokumentace k&nbsp;jazyku Clojure)<br />
<a href="https://clojure.github.io/clojure/clojure.core-api.html#clojure.core/-&gt;">https://clojure.github.io/clojure/clojure.core-api.html#clojure.core/-&gt;</a>
</li>

<li>Understanding the Clojure -&gt; macro<br />
<a href="http://blog.fogus.me/2009/09/04/understanding-the-clojure-macro/">http://blog.fogus.me/2009/09/04/understanding-the-clojure-macro/</a>
</li>

<li>clojure.inspector<br />
<a href="http://clojure.github.io/clojure/clojure.inspector-api.html">http://clojure.github.io/clojure/clojure.inspector-api.html</a>
</li>

<li>The Clojure Toolbox<br />
<a href="http://www.clojure-toolbox.com/">http://www.clojure-toolbox.com/</a>
</li>

<li>Unit Testing in Clojure<br />
<a href="http://nakkaya.com/2009/11/18/unit-testing-in-clojure/">http://nakkaya.com/2009/11/18/unit-testing-in-clojure/</a>
</li>

<li>Testing in Clojure (Part-1: Unit testing)<br />
<a href="http://blog.knoldus.com/2014/03/22/testing-in-clojure-part-1-unit-testing/">http://blog.knoldus.com/2014/03/22/testing-in-clojure-part-1-unit-testing/</a>
</li>

<li>API for clojure.test - Clojure v1.6 (stable)<br />
<a href="https://clojure.github.io/clojure/clojure.test-api.html">https://clojure.github.io/clojure/clojure.test-api.html</a>
</li>

<li>Leiningen: úvodní stránka<br />
<a href="http://leiningen.org/">http://leiningen.org/</a>
</li>

<li>Leiningen: Git repository<br />
<a href="https://github.com/technomancy/leiningen">https://github.com/technomancy/leiningen</a>
</li>

<li>leiningen-win-installer<br />
<a href="http://leiningen-win-installer.djpowell.net/">http://leiningen-win-installer.djpowell.net/</a>
</li>

<li>Clojure.org: Vars and the Global Environment<br />
<a href="http://clojure.org/Vars">http://clojure.org/Vars</a>
</li>

<li>Clojure.org: Refs and Transactions<br />
<a href="http://clojure.org/Refs">http://clojure.org/Refs</a>
</li>

<li>Clojure.org: Atoms<br />
<a href="http://clojure.org/Atoms">http://clojure.org/Atoms</a>
</li>

<li>Clojure.org: Agents as Asynchronous Actions<br />
<a href="http://clojure.org/agents">http://clojure.org/agents</a>
</li>

<li>Transient Data Structures
<a href="http://clojure.org/transients">http://clojure.org/transients</a>
</li>

</ol>



<p></p><p></p>
<p><small>Autor: <a href="http://www.fit.vutbr.cz/~tisnovpa">Pavel Tišnovský</a> &nbsp; 2018</small></p>
</body>
</html>

