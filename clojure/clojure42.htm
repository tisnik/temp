<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
        "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html>
<head>
<title>Knihovny a moduly usnadňující testování aplikací naprogramovaných v jazyce Clojure</title>
<meta name="Author" content="Pavel Tisnovsky" />
<meta name="Generator" content="vim" />
<meta http-equiv="content-type" content="text/html; charset=utf-8" />
<style type="text/css">
         body {color:#000000; background:#ffffff;}
         h1  {font-family: arial, helvetica, sans-serif; color:#ffffff; background-color:#c00000; text-align:center; padding-left:1em}
         h2  {font-family: arial, helvetica, sans-serif; color:#ffffff; background-color:#0000c0; padding-left:1em; text-align:left}
         h3  {font-family: arial, helvetica, sans-serif; color:#000000; background-color:#c0c0c0; padding-left:1em; text-align:left}
         h4  {font-family: arial, helvetica, sans-serif; color:#000000; background-color:#e0e0e0; padding-left:1em; text-align:left}
         a   {font-family: arial, helvetica, sans-serif;}
         li  {font-family: arial, helvetica, sans-serif; color:#000000; text-align:justify; width:450px;}
         ol  {font-family: arial, helvetica, sans-serif; color:#000000; text-align:justify; width:450px;}
         ul  {font-family: arial, helvetica, sans-serif; color:#000000; text-align:justify; width:450px;}
         p   {font-family: arial, helvetica, sans-serif; color:#000000; text-align:justify;}
         pre {background:#e0e0e0}
</style>
</head>

<body>

<h1>Knihovny a moduly usnadňující testování aplikací naprogramovaných v jazyce Clojure</h1>

<h3>Pavel Tišnovský</h3>

<p></p>

<h1>Úvodník</h1>

<p>V dnešním článku se seznámíme s knihovnami a moduly pro Leiningen určenými pro testování aplikací naprogramovaných v jazyce Clojure. V této oblasti vzniklo velké množství zajímavých projektů, například modul humane-test-output, knihovna iota či adaptace jazyka Gherkin pro BDD.</p>



<h2>Obsah</h2>

<p><a href="#k01">1. Knihovny a moduly usnadňující testování aplikací naprogramovaných v&nbsp;jazyce Clojure</a></p>
<p><a href="#k02">2. Tvorba jednotkových testů s&nbsp;využitím základní knihovny <strong>clojure.test</strong></a></p>
<p><a href="#k03">3. Makra <strong>is</strong> a <strong>are</strong></a></p>
<p><a href="#k04">4. Test, zda byla vyhozena výjimka specifikovaného typu nebo výjimka s&nbsp;určitou zprávou</a></p>
<p><a href="#k05">5. Rozšiřující modul <strong>humane-test-output</strong> pro vylepšení hlášení výstupu jednotkových testů</a></p>
<p><a href="#k06">6. Rozdíly mezi běžným výstupem testů a výstupem upraveným <strong>humane-test-output</strong></a></p>
<p><a href="#k07">7. Jednotkové testy s&nbsp;výstupem kompatibilním s&nbsp;JUnit</a></p>
<p><a href="#k08">8. Spuštění jednotkového testu a konverze výsledku do formátu kompatibilního s&nbsp;JUnit</a></p>
<p><a href="#k09">9. Plugin <strong>cloverage</strong> &ndash; zjištění pokrytí kódu testy</a></p>
<p><a href="#k10">10. Příklad výstupu generovaného pluginem <strong>cloverage</strong></a></p>
<p><a href="#k11">11. Knihovna <strong>iota</strong> a její použití při tvorbě testů</a></p>
<p><a href="#k12">12. Nové infixové operátory operátory použité v&nbsp;makru <strong>given</strong></a></p>
<p><a href="#k13">13. Ukázka testu napsaného s&nbsp;využitím knihovny <strong>iota</strong></a></p>
<p><a href="#k14">14. Testování s&nbsp;využitím knihovny Expectations</a></p>
<p><a href="#k15">15. Testy napsané s&nbsp;využitím knihovny <strong>Expectations</strong></a></p>
<p><a href="#k16">16. Podpora pro BDD (behaviour-driven development) knihovnou <strong>cucumber-jvm-clojure</strong></a></p>
<p><a href="#k17">17. Jednoduchý projekt testovaný s&nbsp;využitím BDD</a></p>
<p><a href="#k18">18. Repositář s&nbsp;demonstračními příklady</a></p>
<p><a href="#k19">19. Odkazy na předchozí části tohoto seriálu</a></p>
<p><a href="#k20">20. Odkazy na Internetu</a></p>



<p><a name="k01"></a></p>
<h2 id="k01">1. Knihovny a moduly usnadňující testování aplikací naprogramovaných v&nbsp;jazyce Clojure</h2>

<p>Programovací jazyk Clojure se dnes může pochlubit poměrně rozsáhlým
ekosystémem, ať již se to týká <a
href="https://www.clojure-toolbox.com/">knihoven či různých podpůrných
nástrojů</a>. Nezapomnělo se ani na knihovny popř.&nbsp;moduly pro Leiningen
určené pro tvorbu testů. V&nbsp;dnešním superdlouhém článku se s&nbsp;některými
užitečnými nástroji a knihovnami pro testování seznámíme.</p>

<p><a href="#k02">Nejprve</a> si připomeneme možnosti nabízené standardní
knihovnou <strong>clojure.test</strong>, <a href="#k05">poté</a> si ukážeme,
jak je možné vylepšit způsob zobrazení výsledků testů s&nbsp;využitím nástroje
<strong>humane-test-output</strong>. Výsledky testů je možné upravit do podoby
kompatibilní s&nbsp;JUnit, což je téma, kterému se budeme věnovat <a
href="#k07">v&nbsp;sedmé kapitole</a>. Následovat bude <a href="#k09">popis
pluginu</a> <strong>cloverage</strong>, jenž dokáže zobrazit ty řádky kódu,
které jsou pokryté testy. Jednodušší psaní jednotkových testů podporuje <a
href="#k11">knihovna iota</a> a na závěr si popíšeme možnosti knihovny <a
href="#k14">Expectations</a> a v&nbsp;neposlední řadě i <a
href="#k16">cucumber-jvm-clojure</a> určené pro psaní BDD testů v&nbsp;jazyku
<a href="https://github.com/cucumber/cucumber/wiki/Gherkin">Gherkin</a>.</p>

<p><div class="rs-tip-major">Poznámka: v&nbsp;dalším textu se předpokládá, že
máte nainstalován správce projektu <i>Leiningen</i>. Pokud tomu tak není, bude
nutné si <a
href="https://www.root.cz/clanky/leiningen-nastroj-pro-spravu-projektu-napsanych-v-clojure/">Leiningen
nainstalovat</a>, což není nic těžkého. Navíc se jedná o velmi užitečný projekt
s&nbsp;mnoha přídavnými moduly, které využijete nejenom při
testování.</div></p>



<p><a name="k02"></a></p>
<h2 id="k02">2. Tvorba jednotkových testů s&nbsp;využitím základní knihovny <strong>clojure.test</strong></h2>

<p>Tvorbou jednotkových testů s&nbsp;využitím základní knihovny nazvané
<strong>clojure.test</strong> jsme se již v&nbsp;tomto seriálu věnovali, takže
se o možnostech této knihovny zmíníme jen krátce. Připomeňme si pouze, že
<strong>clojure.test</strong>, která patří mezi <a
href="https://clojure.github.io/clojure/clojure.test-api.html">standardní
knihovny</a> dodávané společně s&nbsp;interpretrem Clojure, obsahuje několik
funkcí a maker určených pro psaní jednotkových testů popř.&nbsp;pro jednoduché
<i>aserce</i> zapisované přímo do programového kódu (například při ladění
v&nbsp;interaktivní smyčce REPL). Tuto knihovnu navíc automaticky používá
systém pro správu projektů <i>Leiningen</i>, takže když vytvoříte strukturu
nového projektu příkazem:</p>

<pre>
lein new app nova_aplikace
</pre>

<p>objeví se ve struktuře projektu i podadresář <strong>test</strong>,
v&nbsp;němž se vytváří jednotkové testy:</p>

<pre>
├── doc
│   └── intro.md
├── LICENSE
├── project.clj
├── README.md
├── resources
├── src
│   └── nova_aplikace
│       └── core.clj
└── test
    └── nova_aplikace
        └── core_test.clj
</pre>

<p>Moduly uložené v&nbsp;adresáři <strong>test</strong> knihovnu
<strong>clojure.test</strong> automaticky načítají:</p>

<pre>
(ns nova-aplikace.core-test
    (:require [<strong>clojure.test :refer :all</strong>]
              [nova-aplikace.core :refer :all]))
...
...
...
</pre>

<p>Samotný test se zapisuje následujícím způsobem:</p>

<pre>
(deftest factorial-test
    (testing "Factorial"
        (is ( = (factorial 0)   1) "beginning")
        (is ( = (factorial 1)   1) "beginning")
        (is ( = (factorial 2)   (* 1 2)) "still easy")
        (is ( = (factorial 5)   (* 1 2 3 4 5)) "5!")
        (is ( = (factorial 6)   720) "6!")))
</pre>

<p>Můžeme zde vidět použití tří maker nazvaných <strong>deftest</strong>,
<strong>testing</strong> a <strong>is</strong>.</p>

<p>Makro <strong>deftest</strong> sémanticky odpovídá definici funkce, ovšem
nikde se neuvádí parametry:</p>

<pre>
user=&gt; <strong>(doc deftest)</strong>
-------------------------
clojure.test/deftest
([name &amp; body])
Macro
  Defines a test function with no arguments.  Test functions may call
  other tests, so tests may be composed.  If you compose tests, you
  should also define a function named test-ns-hook; run-tests will
  call test-ns-hook instead of testing all vars.
&nbsp;
  Note: Actually, the test body goes in the :test metadata on the var,
  and the real function (the value of the var) calls test-var on
  itself.
&nbsp;
  When *load-tests* is false, deftest is ignored.
</pre>

<p>Použití druhého makra <strong>testing</strong> je nepovinné, ale může se
hodit například v&nbsp;případě, že potřebujeme vypisovat informace o tom, jaká
část aplikace je právě testována:</p>

<pre>
user=&gt; <strong>(doc testing)</strong>
-------------------------
clojure.test/testing
([string &amp; body])
Macro
  Adds a new string to the list of testing contexts.  May be nested,
  but must occur inside a test function (deftest).
</pre>

<p>Příklad výstupu testu:</p>

<pre>
<strong>lein test</strong>
&nbsp;
Ran 2 tests containing 8 assertions.
0 failures, 0 errors.
</pre>

<p>Popř.&nbsp;při zjištění chyby nebo chyb:</p>

<pre>
<strong>lein test</strong>
&nbsp;
lein test factorial.core-test
&nbsp;
lein test :only factorial.core-test/factorial-test
&nbsp;
FAIL in (factorial-test) (core_test.clj:9)
Factorial
still easy
expected: (= (factorial 2) (* 1 2))
  actual: (not (= 1 2))
&nbsp;
lein test :only factorial.core-test/factorial-test
&nbsp;
FAIL in (factorial-test) (core_test.clj:10)
Factorial
5!
expected: (= (factorial 5) (* 1 2 3 4 5))
  actual: (not (= 24 120))
&nbsp;
lein test :only factorial.core-test/factorial-test
&nbsp;
FAIL in (factorial-test) (core_test.clj:11)
Factorial
6!
expected: (= (factorial 6) 720)
  actual: (not (= 120 720))
&nbsp;
Ran 2 tests containing 8 assertions.
3 failures, 0 errors.
Tests failed.
</pre>



<p><a name="k03"></a></p>
<h2 id="k03">3. Makra <strong>is</strong> a <strong>are</strong></h2>

<p>Základem pro psaní jednotkových testů s&nbsp;využitím knihovny
<strong>clojure.test</strong> je makro nazvané jednoduše <strong>is</strong>,
takže se nejprve podívejme na to, co o tomto makru říká dokumentace.
K&nbsp;prohlížení dokumentace přímo z&nbsp;interaktivní smyčky REPL slouží
makro <strong>doc</strong>, kterému se jako parametr předá jméno funkce, makra
či symbolu, jehož význam potřebujeme zjistit:</p>

<pre>
user=&gt; <strong>(doc is)</strong>
-------------------------
clojure.test/is
([form] [form msg])
Macro
  Generic assertion macro.  'form' is any predicate test.
  'msg' is an optional message to attach to the assertion.
&nbsp;
  Example: (is (= 4 (+ 2 2)) "Two plus two should be 4")
&nbsp;
  Special forms:
&nbsp;
  (is (thrown? c body)) checks that an instance of c is thrown from
  body, fails if not; then returns the thing thrown.
&nbsp;
  (is (thrown-with-msg? c re body)) checks that an instance of c is
  thrown AND that the message on the exception matches (with
  re-find) the regular expression re.
nil
</pre>

<p>Vidíme, že tomuto makru lze předat takzvaný predikát a popř.&nbsp;i textovou
zprávu. Predikát je použit ve dvou významech &ndash; po svém vyhodnocení se
zjišťuje výsledná hodnota a pokud není predikát splněn, vypíše se chybové
hlášení obsahující jak původní znění predikátu, tak i aktuální (odlišnou)
hodnotu vzniklou vyhodnocením. Mimochodem: právě proto, že se vypisuje text
predikátu, nemůže být <strong>is</strong> implementováno pomocí funkce, ale
bylo nutné použít makro. Chování makra <strong>is</strong> si můžeme snadno
odzkoušet:</p>

<pre>
user=&gt; <strong>(is true)</strong>
true
</pre>

<pre>
user=&gt; <strong>(is (= (+ 1 1) 2))</strong>
true
</pre>

<pre>
user=&gt; <strong>(is (= (inc 1) 2))</strong>
true
</pre>

<pre>
user=&gt; <strong>(is (nil? nil))</strong>
true
</pre>

<pre>
user=&gt; <strong>(is (seq? '(1 2 3)))</strong>
true
</pre>

<pre>
user=&gt; <strong>(is (fn? println))</strong>
true
</pre>

<p>Co se stane ve chvíli, kdy není predikát splněn, lze opět snadno
odzkoušet:</p>

<pre>
user=&gt; <strong>(is (= 1 2))</strong>
&nbsp;
FAIL in clojure.lang.PersistentList$EmptyList@1 (NO_SOURCE_FILE:1)
expected: (= 1 2)
  actual: (not (= 1 2))
false
</pre>

<pre>
user=&gt; <strong>(is (nil? "ja nejsem nil"))</strong>
&nbsp;
FAIL in clojure.lang.PersistentList$EmptyList@1 (NO_SOURCE_FILE:1)
expected: (nil? "ja nejsem nil")
  actual: (not (nil? "ja nejsem nil"))
false
</pre>

<pre>
user=&gt; <strong>(is (= (inc 1) 3))</strong>
&nbsp;
FAIL in clojure.lang.PersistentList$EmptyList@1 (NO_SOURCE_FILE:1)
expected: (= (inc 1) 3)
  actual: (not (= 2 3))
false
</pre>

<pre>
user=&gt; <strong>(is (fn? true))</strong>
&nbsp;
FAIL in clojure.lang.PersistentList$EmptyList@1 (NO_SOURCE_FILE:1)
expected: (fn? true)
  actual: (not (fn? true))
false
</pre>

<p>Řádek začínající slovem &bdquo;FAIL&ldquo; jen naznačuje, že makro
<strong>is</strong> spouštíme z&nbsp;interaktivní konzole a nikoli ze
zdrojového kódu (kde by bylo známé jak jméno zdrojového souboru, tak i číslo
řádku, na němž je makro <strong>is</strong> použito). Tento nedostatek se nijak
neprojeví při testování reálných aplikací.</p>

<p><div class="rs-tip-major">Poznámka: mohlo by se zdát, že namísto
<strong>is</strong> je možné použít standardní makro <strong>assert</strong>.
Ve skutečnosti by však správně nefungovalo vyhodnocení testů, i když je činnost
makra <strong>assert</strong> zdánlivě velmi podobná:</div></p>

<pre>
user=&gt; <strong>(assert (= 1 1))</strong>
nil
user=&gt; <strong>(assert (= 1 2))</strong>
&nbsp;
AssertionError Assert failed: (= 1 2)  user/eval771 (NO_SOURCE_FILE:1)
</pre>

<p>Jedinou vážnější nevýhodou předchozích testů je opakované použití makra
<strong>is</strong> a z&nbsp;toho vyplývající záplavy závorek. Aby se psaní
testů zpřehlednilo, lze namísto <strong>is</strong> využít makro pojmenované
<strong>are</strong>, kterému se předá funkce provádějící porovnání (jen se
nezapisuje jméno funkce) a za tímto zápisem pak již většinou seznam obsahující
očekávané hodnoty a volání testované funkce:</p>

<pre>
user=&gt; <strong>(doc are)</strong>
-------------------------
clojure.test/are
([argv expr &amp; args])
Macro
  Checks multiple assertions with a template expression.
  See clojure.template/do-template for an explanation of
  templates.
&nbsp;
  Example: (are [x y] (= x y)  
                2 (+ 1 1)
                4 (* 2 2))
  Expands to: 
           (do (is (= 2 (+ 1 1)))
               (is (= 4 (* 2 2))))
&nbsp;
  Note: This breaks some reporting features, such as line numbers.
nil
</pre>

<p>Rozdíl mezi makry <strong>is</strong> a <strong>are</strong> je patrný
z&nbsp;následujících dvou testů:</p>

<pre>
(ns <strong>testing1.core-test</strong>
    (:require [clojure.test :refer :all]
              [testing1.core :refer :all]))
&nbsp;
(deftest <strong>test-add-1</strong>
    (testing "function add"
        (is (= 0 (add 0 0)))
        (is (= 3 (add 1 2)))
        (is (= 5/6 (add 1/2 1/3)))))
&nbsp;
(deftest <strong>test-add-2</strong>
    (testing "function add"
        (are [x y] (= x y)
            0   (add 0 0)
            3   (add 1 2)
            5/6 (add 1/2 1/3))))
</pre>



<p><a name="k04"></a></p>
<h2 id="k04">4. Test, zda byla vyhozena výjimka specifikovaného typu nebo výjimka s&nbsp;určitou zprávou</h2>

<p>V&nbsp;nápovědě zobrazené k&nbsp;makru <strong>is</strong> je
mj.&nbsp;popsáno i jedno velmi často využívané volání tohoto makra:</p>

<pre>
(is (thrown? c body))
</pre>

<p>Tuto formu je v&nbsp;případě potřeby možné použít pro otestování, zda
zavolání nějaké funkce vyvolá výjimky určitého typu (typ je určen třídou
<strong>c</strong>). Podívejme se na velmi jednoduchý příklad. Tím je dělení
nulou, které podle očekávání vede k&nbsp;vyhození výjimky typu
<strong>ArithmeticException</strong>. Ostatně můžeme se sami přesvědčit, zda je
to pravda:</p>

<pre>
user=&gt; <strong>(/ 42 0)</strong>
&nbsp;
ArithmeticException Divide by zero  clojure.lang.Numbers.divide (Numbers.java:156)
</pre>

<p>Výjimka skutečně byla podle všech očekávání vyhozena, takže můžeme zkusit,
co se stane ve chvíli, kdy se využije výše uvedená speciální forma volání makra
<strong>is</strong>:</p>

<pre>
user=&gt; <strong>(is (thrown? ArithmeticException (/ 42 0)))</strong>
#&lt;ArithmeticException java.lang.ArithmeticException: Divide by zero&lt;
</pre>

<p>Výsledkem volání je instance třídy ArithmeticException. Opět se můžeme
snadno přesvědčit, že je to pravda:</p>

<pre>
user=&gt; <strong>(def result (is (thrown? ArithmeticException (/ 42 0))))</strong>
#'user/result
user=&gt; <strong>result</strong>
#&lt;ArithmeticException java.lang.ArithmeticException: Divide by zero&lt;
user=&gt; <strong>(type result)</strong>
java.lang.ArithmeticException
</pre>

<p>Ve chvíli, kdy se použije format <strong>(is (thrown? ...))</strong> a
k&nbsp;vyhození výjimky nedojde, vypíše makro <strong>is</strong> následující
zprávu:</p>

<pre>
user=&gt; <strong>(is (thrown? ArithmeticException (/ 42 1)))</strong>
&nbsp;
FAIL in clojure.lang.PersistentList$EmptyList@1 (NO_SOURCE_FILE:1)
expected: (thrown? ArithmeticException (/ 42 1))
  actual: nil
nil
</pre>

<p>V&nbsp;některých případech může být důležité otestovat nejenom typ výjimky,
ale i to, jestli zpráva nesená výjimkou odpovídá zadanému regulárnímu výrazu.
Připomeňme si, že v&nbsp;Clojure se regulární výrazy zapisují ve formátu <a
href="https://clojure.org/guides/weird_characters#__code_code_regular_expression">#"regulární_výraz"</a>,
díky čemuž je možné se vyhnout nutnosti escapování mnoha znaků, které mají
v&nbsp;regulárních výrazech speciální význam. Podívejme se na následující test,
který zjistí, jestli výjimka obsahuje zprávu &bdquo;No such file or
directory&ldquo; (což platí pro Linux, ne nutně pro další systémy):</p>

<pre>
user=&gt; <strong>(is (thrown-with-msg? java.io.FileNotFoundException #"No such file or directory" (slurp "nejaky_soubor")))</strong>
#&lt;FileNotFoundException java.io.FileNotFoundException: nejaky_soubor (No such file or directory)&gt;
</pre>

<p>Naopak test, jehož podmínka není splněna:</p>

<pre>
user=&gt; <strong>(is (thrown-with-msg? java.io.FileNotFoundException #"Soubor nelze najit" (slurp "nejaky_soubor")))</strong>
&nbsp;
FAIL in clojure.lang.PersistentList$EmptyList@1 (NO_SOURCE_FILE:1)
expected: (thrown-with-msg? java.io.FileNotFoundException #"Soubor nelze najit" (slurp "nejaky_soubor"))
  actual: #&lt;FileNotFoundException java.io.FileNotFoundException: nejaky_soubor (No such file or directory)&gt;
#&lt;FileNotFoundException java.io.FileNotFoundException: nejaky_soubor (No such file or directory)&gt;
</pre>

<p>Pro testování zprávy se interně volá funkce <strong>re-find</strong>, takže
pokud potřebujete zjistit, zda <i>celá</i> zpráva odpovídá zadanému regulárnímu
výrazu, je nutné na začátku a konci výrazu použít znaky ^ a $:</p>

<pre>
user=&gt; <strong>(is (thrown-with-msg? java.lang.ArrayIndexOutOfBoundsException #"^[0-9]+$" (aget (int-array 10) 100)))</strong>
#&lt;ArrayIndexOutOfBoundsException java.lang.ArrayIndexOutOfBoundsException: 100&gt;
&nbsp;
user=&gt; <strong>(is (thrown-with-msg? java.lang.ArrayIndexOutOfBoundsException #"^[0-9]+$" (aget (int-array 10) -1)))</strong>
&nbsp;
FAIL in clojure.lang.PersistentList$EmptyList@1 (NO_SOURCE_FILE:1)
expected: (thrown-with-msg? java.lang.ArrayIndexOutOfBoundsException #"^[0-9]+$" (aget (int-array 10) -1))
  actual: #&lt;ArrayIndexOutOfBoundsException java.lang.ArrayIndexOutOfBoundsException: -1&gt;
#&lt;ArrayIndexOutOfBoundsException java.lang.ArrayIndexOutOfBoundsException: -1&gt;
</pre>



<p><a name="k05"></a></p>
<h2 id="k05">5. Rozšiřující modul <strong>humane-test-output</strong> pro vylepšení hlášení výstupu jednotkových testů</h2>

<p>Z&nbsp;předchozích příkladů je patrné, že výstup produkovaný výše popsanými
makry <strong>is</strong> a <strong>are</strong> (popř.&nbsp;i dalšími makry a
funkcemi poskytovanými knihovnou <strong>clojure.test</strong>) nemusí být
příliš čitelný. Tento problém se stane ještě více patrný ve chvíli, kdy
například testujeme, zda se vrátil určitý řetězec a chyba (přesněji řečeno
rozdíl) nastane v&nbsp;jediném znaku. Podobně se může stát, že porovnáváme dvě
rozsáhlejší či složitější datové struktury, které se opět mohou odlišovat pouze
v&nbsp;několika detailech. Klasický výstup produkovaný makry
<strong>is</strong> a <strong>are</strong> v&nbsp;těchto případech bude vypadat
následovně:</p>

<pre>
user=&gt; <strong>(use '[clojure.test])</strong>
nil
user=&gt; <strong>(is (= "Linux was originally developed for personal computers based on the Intel x86 architecture" "Linux was originally developed for personal computers based on the Intel i386 architecture"))</strong>
&nbsp;
FAIL in () (form-init2657361174634375861.clj:1)
expected: (= "Linux was originally developed for personal computers based on the Intel x86 architecture" "Linux was originally developed for personal computers based on the Intel i386 architecture")
  actual: (not (= "Linux was originally developed for personal computers based on the Intel x86 architecture" "Linux was originally developed for personal computers based on the Intel i386 architecture"))
false
</pre>

<p>Stručně a přitom nečitelně se napíše, že dva porovnávané řetězce jsou
rozdílné.</p>

<p>Pro dosažení čitelnějších výsledků testů je možné použít několik různých
modulů. Pravděpodobně nejužitečnější je modul nazvaný přímočaře
<strong>humane-test-output</strong>. Tento modul je nejdříve nutné
nainstalovat, a to ideálně pro celé vývojové prostředí programátora. Provede se
to poměrně snadnou úpravou souboru <strong>profiles.clj</strong>, který se
nachází v&nbsp;adresáři <strong>~/.lein</strong> (~ nahrazuje domovský adresář
uživatele):</p>

<pre>
{:user {:dependencies [[pjstadig/humane-test-output "0.8.3"]]
        :injections [(require 'pjstadig.humane-test-output)
                     (pjstadig.humane-test-output/activate!)]}}
</pre>

<p>Pokud nyní znovu spustíme REPL a porovnáme dva řetězce pomocí makra
<strong>is</strong>, tak se chybové hlášení změní do čitelnější podoby. Navíc
se kromě dvou porovnávaných hodnot vypíše i jejich rozdíl (což ovšem
v&nbsp;případě řetězců nedává moc velký význam; pravý smysl uvidíme
později):</p>

<pre>
user=&gt; <strong>(use '[clojure.test])</strong>
nil
user=&gt; <strong>(is (= "Linux was originally developed for personal computers based on the Intel x86 architecture" "Linux was originally developed for personal computers based on the Intel i386 architecture"))</strong>
&nbsp;
FAIL in () (form-init7785123977273257765.clj:1)
expected: "Linux was originally developed for personal computers based on the Intel x86 architecture"
  actual: "Linux was originally developed for personal computers based on the Intel i386 architecture"
    diff: - "Linux was originally developed for personal computers based on the Intel x86 architecture"
          + "Linux was originally developed for personal computers based on the Intel i386 architecture"
false
</pre>

<p><div class="rs-tip-major">Poznámka: modul
<strong>humane-test-output</strong> je kompatibilní s&nbsp;Clojure 1.8.0 a
samozřejmě i s&nbsp;vyššími verzemi. Pozor si dejte především na to, že pouhé
spuštění příkazu <strong>lein repl</strong> mimo vlastní projekt může u
starších verzí Leiningenu ve skutečnosti spustit interpret starší varianty
Clojure, například i dnes již notně zastaralé varianty 1.6.0. Při spuštění
<strong>lein repl</strong> v&nbsp;adresáři projektu se ovšem korektně použije
interpret nastavený v&nbsp;souboru <strong>project.clj</strong>.</div></p>

<p>Další příklad použití &ndash; porovnání dvou delších sekvencí bez přídavného
modulu:</p>

<pre>
user=&gt; <strong>(is (= (range 10) (range 11)))</strong>
&nbsp;
FAIL in () (form-init7847812831457116868.clj:1)
expected: (= (range 10) (range 11))
  actual: (not (= (0 1 2 3 4 5 6 7 8 9) (0 1 2 3 4 5 6 7 8 9 10)))
false
</pre>

<p>Totéž porovnání, nyní ovšem se zapnutým modulem
<strong>humane-test-output</strong>:</p>

<pre>
user=&gt; <strong>(is (= (range 10) (range 11)))</strong>
&nbsp;
FAIL in () (form-init2139708971885779974.clj:1)
expected: (0 1 2 3 4 5 6 7 8 9)
  actual: (0 1 2 3 4 5 6 7 8 9 10)
    diff: + [nil nil nil nil nil nil nil nil nil nil 10]
false
</pre>

<p>Porovnání dvou map, které se od sebe liší jedinou hodnotou:</p>

<pre>
user=&gt; <strong>(is (= {:a 1 :b 2 :c 3} {:a 1 :b 3 :c 3}))</strong>
&nbsp;
FAIL in () (form-init7847812831457116868.clj:1)
expected: (= {:a 1, :b 2, :c 3} {:a 1, :b 3, :c 3})
  actual: (not (= {:a 1, :b 2, :c 3} {:a 1, :b 3, :c 3}))
false
</pre>

<p>Totéž porovnání, nyní ovšem se zapnutým modulem
<strong>humane-test-output</strong>:</p>

<pre>
user=&gt; <strong>(is (= {:a 1 :b 2 :c 3} {:a 1 :b 3 :c 3}))</strong>
&nbsp;
FAIL in () (form-init2139708971885779974.clj:1)
expected: {:a 1, :b 2, :c 3}
  actual: {:a 1, :b 3, :c 3}
    diff: - {:b 2}
          + {:b 3}
false
</pre>

<p>Zejména v&nbsp;posledním případě jistě oceníte mnohem vyšší čitelnost
výstupu.</p>



<p><a name="k06"></a></p>
<h2 id="k06">6. Rozdíly mezi běžným výstupem testů a výstupem upraveným <strong>humane-test-output</strong></h2>

<p>Podívejme se nyní na to, jak se výstup produkovaný jednotkovými testy změní
ve chvíli, kdy je nakonfigurován modul <strong>humane-test-output</strong> a
provádíme testování nějaké aplikace příkazem <strong>lein test</strong>.
Nejdříve vyzkoušíme naši funkci pro výpočet faktoriálu, přesněji řečeno takovou
variantu funkce <strong>factorial</strong>, která vyhazuje výjimku pro záporná
čísla:</p>

<pre>
(ns factorial4.core
    (:gen-class))
&nbsp;
<i>; funkce faktorial obsahuje i test na zaporne hodnoty</i>
(defn factorial
    [n]
    (if (neg? n)
        (throw (IllegalArgumentException. "negative numbers are not supported!"))
        (apply * (range 1 (inc n)))))
&nbsp;
<i>; otestujeme funkci faktorial</i>
(defn -main
    [&amp; args]
    (doseq [i (range 0 10)]
        (println i "! = " (factorial i))))
</pre>

<p>Samotné testy jsou naprogramovány pro odzkoušení známých výsledků i pro
otestování, kdy dojde k&nbsp;chybě nebo dokonce k&nbsp;vyhození výjimky.
Zvýrazněný test je schválně napsán nekorektně, aby při jeho spuštění byly
hlášeny špatné výsledky:</p>

<pre>
(ns factorial4.core-test
  (:require [clojure.test :refer :all]
            [factorial4.core :refer :all]))
&nbsp;
(deftest factorial-test
    (testing "Factorial"
        (is ( = (factorial 0)   1) "beginning")
        (is ( = (factorial 1)   1) "beginning")
        (is ( = (factorial 2)   (* 1 2)) "still easy")
        (is ( = (factorial 5)   (* 1 2 3 4 5)) "5!")
        (is ( = (factorial 6)   720) "6!")))
&nbsp;
<strong>(deftest negative-factorial-test</strong>
    <strong>(testing "Negative tests"</strong>
        <strong>(is ( = (factorial 0)   0) "negative test case #1")</strong>
        <strong>(is ( = (factorial 1)   0) "negative test case #2")</strong>
        <strong>(is ( = (factorial 2)   0) "negative test case #3")))</strong>
&nbsp;
(deftest exception-test
    (testing "If factorial throws exception"
        (is (thrown? IllegalArgumentException (factorial -1)))
        (is (thrown? IllegalArgumentException (factorial -2)))
        (is (thrown? IllegalArgumentException (factorial -100)))))
&nbsp;
(deftest negative-exception-test
    (testing "(negative test) If factorial throws exception"
        (is (thrown? IllegalArgumentException (factorial 1)))
        (is (thrown? IllegalArgumentException (factorial 2)))
        (is (thrown? IllegalArgumentException (factorial 3)))))

</pre>

<p>V&nbsp;případě, že se nepoužije modul <strong>humane-test-output</strong>,
bude vygenerovaný výstup obsahovat mj.&nbsp;i zvýrazněné řádky, které pouze
opakují krok testu a také fakt, že se výsledky neshodují s&nbsp;očekávanými
hodnotami (not (= 1 0)):</p>

<pre>
lein test factorial4.core-test
&nbsp;
lein test :only factorial4.core-test/negative-factorial-test
&nbsp;
FAIL in (negative-factorial-test) (core_test.clj:15)
Negative tests
negative test case #1
<strong>expected: (= (factorial 0) 0)</strong>
  <strong>actual: (not (= 1 0))</strong>
&nbsp;
lein test :only factorial4.core-test/negative-factorial-test
&nbsp;
FAIL in (negative-factorial-test) (core_test.clj:16)
Negative tests
negative test case #2
<strong>expected: (= (factorial 1) 0)</strong>
  <strong>actual: (not (= 1 0))</strong>
&nbsp;
lein test :only factorial4.core-test/negative-factorial-test
&nbsp;
FAIL in (negative-factorial-test) (core_test.clj:17)
Negative tests
negative test case #3
<strong>expected: (= (factorial 2) 0)</strong>
  <strong>actual: (not (= 2 0))</strong>
&nbsp;
lein test :only factorial4.core-test/negative-exception-test
&nbsp;
FAIL in (negative-exception-test) (core_test.clj:27)
(negative test) If factorial throws exception
expected: (thrown? IllegalArgumentException (factorial 1))
  actual: nil
&nbsp;
lein test :only factorial4.core-test/negative-exception-test
&nbsp;
FAIL in (negative-exception-test) (core_test.clj:28)
(negative test) If factorial throws exception
expected: (thrown? IllegalArgumentException (factorial 2))
  actual: nil
&nbsp;
lein test :only factorial4.core-test/negative-exception-test
&nbsp;
FAIL in (negative-exception-test) (core_test.clj:29)
(negative test) If factorial throws exception
expected: (thrown? IllegalArgumentException (factorial 3))
  actual: nil
&nbsp;
Ran 4 tests containing 14 assertions.
6 failures, 0 errors.
</pre>

<p>V&nbsp;případě, kdy naopak modul <strong>humane-test-output</strong>
korektně nakonfigurujeme a použijeme, budou výsledky mnohem čitelnější, což je
ostatně patrné z&nbsp;následujícího výpisu:</p>

<pre>
lein test factorial4.core-test
&nbsp;
lein test :only factorial4.core-test/negative-factorial-test
&nbsp;
FAIL in (negative-factorial-test) (core_test.clj:15)
Negative tests
negative test case #1
expected: 1
  actual: 0
    diff: - 1
          + 0
&nbsp;
lein test :only factorial4.core-test/negative-factorial-test
&nbsp;
FAIL in (negative-factorial-test) (core_test.clj:16)
Negative tests
negative test case #2
expected: 1
  actual: 0
    diff: - 1
          + 0
&nbsp;
lein test :only factorial4.core-test/negative-factorial-test
&nbsp;
FAIL in (negative-factorial-test) (core_test.clj:17)
Negative tests
negative test case #3
expected: 2
  actual: 0
    diff: - 2
          + 0
&nbsp;
lein test :only factorial4.core-test/negative-exception-test
&nbsp;
FAIL in (negative-exception-test) (core_test.clj:27)
(negative test) If factorial throws exception
expected: (thrown? IllegalArgumentException (factorial 1))
  actual: nil
&nbsp;
lein test :only factorial4.core-test/negative-exception-test
&nbsp;
FAIL in (negative-exception-test) (core_test.clj:28)
(negative test) If factorial throws exception
expected: (thrown? IllegalArgumentException (factorial 2))
  actual: nil
&nbsp;
lein test :only factorial4.core-test/negative-exception-test
&nbsp;
FAIL in (negative-exception-test) (core_test.clj:29)
(negative test) If factorial throws exception
expected: (thrown? IllegalArgumentException (factorial 3))
  actual: nil
&nbsp;
Ran 4 tests containing 14 assertions.
6 failures, 0 errors.
</pre>

<p>Zkusme si vytvořit a otestovat ještě jeden příklad, tentokrát napsaný
takovým způsobem, aby se porovnávala relativně složitá datová struktura.
V&nbsp;následujícím úryvku kódu se vytváří struktura odpovědi
(<i>response</i>), kterou server odesílá klientovi. Struktura je před odesláním
zpracována knihovnou <a
href="https://www.root.cz/clanky/leiningen-nastroj-pro-spravu-projektu-napsanych-v-clojure-4/">Ring</a>,
tuto část kódu ovšem netestujeme &ndash; zajímá nás jen, zda bude datová
struktura vytvořená funkcí nazvanou <strong>generate-response</strong>
korektní. Nejprve se podívejme na zdrojový kód testované aplikace
(resp.&nbsp;přesněji řečeno její relevantní části):</p>

<pre>
(ns humane-output.core
    (:gen-class))
&nbsp;
(require '[ring.util.response :as response])
&nbsp;
(defn cache-control-headers
    "Update the response to contains all cache-control headers."
    [response]
    (-&gt; response
        (assoc-in [:headers "Cache-Control"] ["must-revalidate" "no-cache" "no-store"])
        (assoc-in [:headers "Expires"] "0")
        (assoc-in [:headers "Pragma"] "no-cache")))
&nbsp;
(defn generate-response
    [content]
    (-&gt; (response/response content)
        (response/content-type "text/plain; charset=utf-8")
        cache-control-headers))
&nbsp;
(defn -main
    [&amp; args]
    (println (generate-response "Hello world!")))
</pre>

<p>Test je napsán velmi jednoduše. Nejprve se v&nbsp;něm definuje očekávaná
hodnota (viz symbol <strong>expected-response</strong>) a následně jen
zjistíme, zda je hodnota (tj.&nbsp;celá datová struktura) vrácená funkcí
<strong>generate-response</strong> shodná s&nbsp;očekávanou hodnotou.
Připomeňme si, že porovnání funkcí <strong>=</strong> lze v&nbsp;Clojure
provést i pro libovolně složité struktury (o samotný rekurzivní sestup se
nemusíme starat):</p>

<pre>
user=&gt; <strong>(doc =)</strong>
-------------------------
clojure.core/=
([x] [x y] [x y &amp; more])
  Equality. Returns true if x equals y, false if not. Same as
  Java x.equals(y) except it also works for nil, and compares
  numbers and collections in a type-independent manner.  Clojure's immutable data
  structures define equals() (and thus =) as a value, not an identity,
  comparison.
nil
</pre>

<p>Povšimněte si, že v&nbsp;testu očekáváme, že pod klíčem
<strong>Expires</strong> je uložena hodnota "-1" a nikoli "0". Z&nbsp;tohoto
důvodu se po spuštění testů příkazem <strong>lein test</strong> nahlásí
chyba:</p>

<pre>
(ns humane-output.core-test
  (:require [clojure.test :refer :all]
            [humane-output.core :refer :all]))
&nbsp;
&nbsp;
(def expected-response
    {:status 200,
     :headers
           {"Content-Type" "text/plain; charset=utf-8",
            "Cache-Control" ["must-revalidate" "no-cache" "no-store"],
            "Expires" "-1",
            "Pragma" "no-cache"},
     :body "hello world!"})
&nbsp;
&nbsp;
(deftest test-generate-response
    (testing "Function generate-response"
        (is (= expected-response
               (generate-response "hello world!")))))

</pre>

<p>V&nbsp;případě, že se nepoužije modul <strong>humane-test-output</strong>,
bude výstup dosti nečitelný. Ostatně posuďte sami, kolik času je nutné pro
zjištění skutečného problému na řádku <strong>actual:</strong>:</p>

<pre>
lein test humane-output.core-test
&nbsp;
lein test :only humane-output.core-test/test-generate-response
&nbsp;
FAIL in (test-generate-response) (core_test.clj:18)
Function generate-response
expected: (= expected-response (generate-response "hello world!"))
  actual: (not (= {:status 200, :headers {"Content-Type" "text/plain; charset=utf-8","Cache-Control" ["must-revalidate" "no-cache" "no-store"], "Expires" "-1", "Pragma" "no-cache"}, :body "hello world!"} {:status 200, :headers {"Content-Type" "text/plain; charset=utf-8", "Cache-Control" ["must-revalidate" "no-cache" "no-store"], "Expires" "0", "Pragma" "no-cache"}, :body "hello world!"}))
&nbsp;
Ran 1 tests containing 1 assertions.
1 failures, 0 errors.
</pre>

<p>Naproti tomu je při použití modulu <strong>humane-test-output</strong> ihned
patrné, kde spočívá příčina pádu testu. Obě struktury jsou totiž nejdříve
vypsány pod sebou s&nbsp;využitím funkce <strong>pprint</strong> a navíc se
ještě zobrazí pouze rozdíly mezi oběma strukturami formou inteligentního diffu
(viz zvýrazněné řádky):</p>

<pre>
lein test humane-output.core-test
&nbsp;
lein test :only humane-output.core-test/test-generate-response
&nbsp;
FAIL in (test-generate-response) (core_test.clj:18)
Function generate-response
expected: {:status 200,
           :headers
           {"Content-Type" "text/plain; charset=utf-8",
            "Cache-Control" ["must-revalidate" "no-cache" "no-store"],
            "Expires" "-1",
            "Pragma" "no-cache"},
           :body "hello world!"}
  actual: {:status 200,
           :headers
           {"Content-Type" "text/plain; charset=utf-8",
            "Cache-Control" ["must-revalidate" "no-cache" "no-store"],
            "Expires" "0",
            "Pragma" "no-cache"},
           :body "hello world!"}
    diff: <strong>- {:headers {"Expires" "-1"}}</strong>
          <strong>+ {:headers {"Expires" "0"}}</strong>
&nbsp;
Ran 1 tests containing 1 assertions.
1 failures, 0 errors.
</pre>

<p>Funkci tohoto modulu je možné kdykoli zakázat nastavením proměnné prostředí
<strong>INHUMANE_TEST_OUTPUT</strong> (to lze provést i z&nbsp;IDE atd.).</p>



<p><a name="k07"></a></p>
<h2 id="k07">7. Jednotkové testy s&nbsp;výstupem kompatibilním s&nbsp;JUnit</h2>

<p>Příkazem <strong>lein test</strong> je sice možné spustit jednotkové testy a
získat čitelný výstup, tj.&nbsp;informaci o tom, kolik testů bylo spuštěno,
kolik testů proběhlo v&nbsp;pořádku a které testy naopak našly v&nbsp;aplikaci
chybu, ovšem výstupní formát je poněkud neobvyklý. Ve světě Javy (a vlastně i
mimo tento svět) se ustálilo použití XML formátu kompatibilního
s&nbsp;nástrojem <i>JUnit</i>. Tento formát dokážou zpracovat jak mnohá
integrovaná vývojová prostředí, tak i například několik přídavných modulů pro
systém Jenkins popř.&nbsp;starší Hudson.</p>

<p>Tyto moduly dokážou například vytvářet grafy s&nbsp;regresemi atd., takže by
bylo vhodné nějakým způsobem upravit <i>Leiningen</i> takovým způsobem, aby
formát <i>JUnitu</i> podporoval. To je samozřejmě možné, a to především díky
velké rozšiřitelnosti <i>Leiningenu</i> o další moduly. Modul, který budeme
potřebovat, se jmenuje jednoduše <strong>test2junit</strong> a
v&nbsp;následujících odstavcích si ukážeme jeho základní použití.</p>

<p>Aby bylo možné tento modul použít, je nutné upravit projektový soubor
<strong>project.clj</strong>, přesněji řečeno do něj doplnit informaci o
používaném pluginu (nikoli knihovně!, ty se totiž zapisují do sekce
<strong>:dependencies</strong> a nikoli <strong>:plugins</strong>):</p>

<pre>
(defproject factorial2 "0.1.0-SNAPSHOT"
    :description "FIXME: write description"
    :url "http://example.com/FIXME"
    :license {:name "Eclipse Public License"
              :url "http://www.eclipse.org/legal/epl-v10.html"}
    :dependencies [[org.clojure/clojure "1.6.0"]]
    :main ^:skip-aot factorial2.core
    :target-path "target/%s"
    <strong>:plugins [[test2junit "1.1.0"]]</strong>
    :profiles {:uberjar {:aot :all}})
</pre>

<img src="https://i.iinfo.cz/images/563/clojure-testing-1.png" class="image-323632" alt="&#160;" height="538" width="320" />
<p><i>Obrázek 1: Aplikace psané v&nbsp;Clojure testované v&nbsp;CI (Jenkinsu).
Díky použití <strong>test2junit</strong> lze využívat všech pluginů Jenkinsu
pro zpracování výsledků testů &ndash; viz grafy úspěšnosti.</i></p>

<p>Následně je vhodné spustit následující příkaz, který zajistí stažení nového
modulu a popř.&nbsp;i všech knihoven, na nichž tento modul závisí (pokud tento
příkaz nespustíte, spustí se automaticky při prvním volání testů):</p>

<pre>
<strong>lein deps</strong>
&nbsp;
Retrieving test2junit/test2junit/1.1.0/test2junit-1.1.0.pom from clojars
Retrieving test2junit/test2junit/1.1.0/test2junit-1.1.0.jar from clojars
</pre>

<a href="https://www.root.cz/obrazek/323633/"><img src="https://i.iinfo.cz/images/563/clojure-testing-2-prev.png" class="image-323633" alt="&#160;" height="270" width="305" /></a>
<p><i>Obrázek 2: Tabulka s&nbsp;výsledky jednotkových testů pro aplikace psané
v&nbsp;jazyku Clojure.</i></p>



<p><a name="k08"></a></p>
<h2 id="k08">8. Spuštění jednotkového testu a konverze výsledku do formátu kompatibilního s&nbsp;JUnit</h2>

<p>Nyní nastává zajímavý okamžik &ndash; spustíme totiž nástroj
<i>Leiningen</i> s&nbsp;novým jménem úkolu (task). To je možné, protože
<i>Leiningen</i> byl díky úpravě souboru <strong>project.clj</strong> rozšířen
o novou funkcionalitu (onen zmíněný plugin):</p>

<pre>
<strong>lein test2junit</strong>
</pre>

<p>Na standardní výstup se vypíšou následující informace (v&nbsp;některých
případech se však ještě stáhnou zbývající knihovny, na nichž dokončení
zvoleného úkolu závisí):</p>

<pre>
Using test2junit version: 1.1.0
Running Tests...
Writing output to: test2junit
Creating default build.xml file.
&nbsp;
Testing: factorial2.core-test
&nbsp;
Ran 2 tests containing 8 assertions.
0 failures, 0 errors.
</pre>

<p>Výsledkem běhu tohoto nové úlohy (<i>tasku</i>) je soubor
<strong>build.xml</strong> a především pak adresářová struktura
<strong>test2unit</strong> obsahující soubor s&nbsp;cestou
<strong>test2unit/xml/factorial2.core-test.xml</strong>. Podívejme se na obsah
tohoto souboru:</p>

<pre>
&lt;?xml version="1.0" encoding="UTF-8"?&gt;
&lt;testsuite name="factorial2.core-test" errors="0" failures="0" tests="2" time="0.0142" timestamp="2015-02-21_20:56:31+0100"&gt;
    &lt;testcase name="factorial-test" classname="factorial2.core-test" time="0.0044"&gt;
    &lt;/testcase&gt;
    &lt;testcase name="exception-test" classname="factorial2.core-test" time="0.0013"&gt;
    &lt;/testcase&gt;
&lt;/testsuite&gt;
</pre>

<p>Vidíme, že jsou zde uloženy informace jak o jménu spuštěných testů, tak i o
době běhu a čase spuštění.</p>

<a href="https://www.root.cz/obrazek/323634/"><img src="https://i.iinfo.cz/images/563/clojure-testing-3-prev.png" class="image-323634" alt="&#160;" height="196" width="370" /></a>
<p><i>Obrázek 3: Výsledky běhu jednotkových testů pro vybraný projekt
naprogramovaný v&nbsp;Clojure.</i></p>

<p>Pokud uděláme ve zdrojovém kódu aplikace záměrnou chybu &ndash; vynechání
volání funkce <strong>inc</strong> &ndash; bude výsledek běhu testů
odlišný:</p>

<pre>
<strong>lein test2junit</strong>
&nbsp;
Using test2junit version: 1.1.0
Running Tests...
Writing output to: test2junit
&nbsp;
Testing: factorial2.core-test
&nbsp;
Ran 2 tests containing 8 assertions.
3 failures, 0 errors.
Tests failed.
Tests failed.
</pre>

<p>A odlišovat se samozřejmě bude i výstupní XML soubor:o</p>

<pre>
&lt;?xml version="1.0" encoding="UTF-8"?&gt;
&lt;testsuite name="factorial2.core-test" errors="0" failures="3" tests="2" time="0.0232" timestamp="2015-02-21_20:59:03+0100"&gt;
    &lt;testcase name="factorial-test" classname="factorial2.core-test" time="0.0168"&gt;
    &lt;failure message="still easy"&gt;still easy
expected: (= (factorial 2) (* 1 2))
  actual: (not (= 1 2))
      at: AFn.java:18&lt;/failure&gt;
    &lt;failure message="5!"&gt;5!
expected: (= (factorial 5) (* 1 2 3 4 5))
  actual: (not (= 24 120))
      at: AFn.java:18&lt;/failure&gt;
    &lt;failure message="6!"&gt;6!
expected: (= (factorial 6) 720)
  actual: (not (= 120 720))
      at: AFn.java:18&lt;/failure&gt;
    &lt;/testcase&gt;
    &lt;testcase name="exception-test" classname="factorial2.core-test" time="0.0011"&gt;
    &lt;/testcase&gt;
&lt;/testsuite&gt;
</pre>

<a href="https://www.root.cz/obrazek/323635/"><img src="https://i.iinfo.cz/images/563/clojure-testing-4-prev.png" class="image-323635" alt="&#160;" height="193" width="370" /></a></p>
<p><i>Obrázek 4: Podrobnější informace o výsledcích jednotkových testů, opět
získané díky pluginu <strong>test2unit</strong>.</i></p>



<p><a name="k09"></a></p>
<h2 id="k09">9. Plugin <strong>cloverage</strong> &ndash; zjištění pokrytí kódu testy</h2>

<p>Dalším užitečným pluginem pro nástroj <i>Leiningen</i>, který je určený pro
usnadnění práce testerů či devops, je modul nazvaný <i>cloverage</i>. Úkolem
tohoto modulu je zjištění, které části programového kódu jsou pokryté testy,
tj.&nbsp;opět se jedná o analogii k&nbsp;podobným nástrojům existujícím i pro
další programovací jazyky, ovšem s&nbsp;tím rozdílem, že kvůli použití maker je
zjištění pokrytí testy v&nbsp;programovacím jazyku <i>Clojure</i>
složitější.</p>

<p>Funkci tohoto pluginu otestujeme jednoduše &ndash; použijeme upravený
projekt pro výpočet faktoriálu, do nějž jsou přidány další dvě totožné funkce,
které se od sebe odlišují pouze jménem:</p>

<pre>
(ns <strong>cloverage.core</strong>
  (:gen-class))
&nbsp;
(defn <strong>factorial</strong>
    [n]
    (if (neg? n)
        (throw (IllegalArgumentException. "negative numbers are not supported!"))
        (apply * (range 1 (inc n)))))
&nbsp;
(defn <strong>factorial2</strong>
    [n]
    (if (neg? n)
        (throw (IllegalArgumentException. "negative numbers are not supported!"))
        (apply * (range 1 (inc n)))))
&nbsp;
(defn <strong>factorial3</strong>
    [n]
    (if (neg? n)
        (throw (IllegalArgumentException. "negative numbers are not supported!"))
        (apply * (range 1 (inc n)))))
&nbsp;
(defn <strong>-main</strong>
    "I don't do a whole lot ... yet."
    [&amp; args]
    (doseq [i (range 0 10)]
        (println i "! = " (factorial i))))
</pre>

<p>Projektový soubor <strong>project.clj</strong> musí vypadat následovně (opět
si povšimněte nového pluginu na zvýrazněném řádku):</p>

<pre>
(defproject cloverage "0.1.0-SNAPSHOT"
    :description "FIXME: write description"
    :url "http://example.com/FIXME"
    :license {:name "Eclipse Public License"
              :url "http://www.eclipse.org/legal/epl-v10.html"}
    :dependencies [[org.clojure/clojure "1.6.0"]]
    :main ^:skip-aot cloverage.core
    :target-path "target/%s"
    <strong>:plugins [[lein-cloverage "1.0.2"]]</strong>
    :profiles {:uberjar {:aot :all}})
</pre>

<p>Po přidání tohoto pluginu se při spuštění projektového manažeru
<strong>lein</strong> zobrazí nová úloha:</p>

<pre>
Leiningen is a tool for working with Clojure projects.
&nbsp;
Several tasks are available:
change              Rewrite project.clj by applying a function.
check               Check syntax and warn on reflection.
classpath           Print the classpath of the current project.
clean               Remove all files from project's target-path.
<strong>cloverage           Run code coverage on the project.</strong>
compile             Compile Clojure source into .class files.
deploy              Build and deploy jar to remote repository.
deps                Download all dependencies.
do                  Higher-order task to perform other tasks in succession.
help                Display a list of tasks or help for a given task.
install             Install the current project to the local repository.
jar                 Package up all the project's files into a jar file.
javac               Compile Java source files.
new                 Generate project scaffolding based on a template.
plugin              DEPRECATED. Please use the :user profile instead.
pom                 Write a pom.xml file to disk for Maven interoperability.
release             Perform :release-tasks.
repl                Start a repl session either with the current project or standalone.
retest              Run only the test namespaces which failed last time around.
run                 Run a -main function with optional command-line arguments.
search              Search remote maven repositories for matching jars.
show-profiles       List all available profiles or display one if given an argument.
test                Run the project's tests.
trampoline          Run a task without nesting the project's JVM inside Leiningen's.
uberjar             Package up the project files and dependencies into a jar file.
update-in           Perform arbitrary transformations on your project map.
upgrade             Upgrade Leiningen to specified version or latest stable.
vcs                 Interact with the version control system.
version             Print version for Leiningen and the current JVM.
with-profile        Apply the given task with the profile(s) specified.
</pre>

<p>Nejzajímavější jsou jednotkové testy. Povšimněte si, že funkce
<i>factorial1</i> je otestována celá, tj.&nbsp;včetně obou větví, funkce
<i>factorial2</i> je otestována jen částečně (pouze jedna větev) a nakonec
funkce <i>factorial3</i> není otestována vůbec. Tyto rozdíly by se nějakým
způsobem měly projevit ve výsledcích:</p>

<pre>
(ns <strong>cloverage.core-test</strong>
  (:require [clojure.test :refer :all]
            [cloverage.core :refer :all]))
&nbsp;
(deftest <strong>factorial-test</strong>
    (testing "Factorial"
        (is ( = (factorial 0)   1) "beginning")
        (is ( = (factorial 1)   1) "beginning")
        (is ( = (factorial 2)   (* 1 2)) "still easy")
        (is ( = (factorial 5)   (* 1 2 3 4 5)) "5!")
        (is ( = (factorial 6)   720) "6!")))
&nbsp;
(deftest <strong>factorial2-test</strong>
    (testing "Factorial"
        (is ( = (factorial2 0)   1) "beginning")
        (is ( = (factorial2 1)   1) "beginning")
        (is ( = (factorial2 2)   (* 1 2)) "still easy")
        (is ( = (factorial2 5)   (* 1 2 3 4 5)) "5!")
        (is ( = (factorial2 6)   720) "6!")))
&nbsp;
(deftest <strong>exception-test</strong>
    (testing "If factorial throws exception"
        (is (thrown? IllegalArgumentException (factorial -1)))
        (is (thrown? IllegalArgumentException (factorial -2)))
        (is (thrown? IllegalArgumentException (factorial -100)))))
</pre>



<p><a name="k10"></a></p>
<h2 id="k10">10. Příklad výstupu generovaného pluginem <strong>cloverage</strong></h2>

<p>Po přípravě projektového souboru i testů je nutné spustit novou úlohu.
Nejedná se o <strong>lein test</strong>, ale o <strong>lein
cloverage</strong>:</p>

<pre>
<strong>lein cloverage</strong>
Loading namespaces:  (cloverage.core)
Test namespaces:  (cloverage.core-test)
Loaded  cloverage.core  .
Instrumented namespaces.
&nbsp;
Testing cloverage.core-test
&nbsp;
Ran 3 tests containing 13 assertions.
0 failures, 0 errors.
Ran tests.
Produced output in /home/tester/repos/clojure-examples/cloverage/target/coverage .
HTML: file:///home/tester/repos/clojure-examples/cloverage/target/coverage/index.html
</pre>

<p>Kromě HTML výstupu se mj.&nbsp;vygeneruje i následující tabulka:</p>

<pre>
|----------------+---------+---------|
|      Namespace | % Forms | % Lines |
|----------------+---------+---------|
| cloverage.core |   33.33 |   62.50 |
|----------------+---------+---------|
|      ALL FILES |   33.33 |   62.50 |
|----------------+---------+---------|
</pre>

<p>Podívejme se nyní na výsledky &ndash; zdá se, že skutečně odpovídají
testům:</p>

<img src="http://i.iinfo.cz/images/4/clojure8-3.png" class="image-202483" alt="&#160;" height="180" width="693" />
<p><i>Obrázek 5: Pokrytí zdrojového kódu testy &ndash; celková
statistika.</i></p>

<a href="http://www.root.cz/obrazek/202484/"><img src="http://i.iinfo.cz/images/4/clojure8-4-prev.png" class="image-202484" alt="&#160;" height="222" width="370" /></a>
<p><i>Obrázek 6: Pokrytí zdrojového kódu testy &ndash; zelené řádky byly
vyhodnoceny, červené nikoli (bílé řádky nepředstavují zdrojový kód).</i></p>



<p><a name="k11"></a></p>
<h2 id="k11">11. Knihovna <strong>iota</strong> a její použití při tvorbě testů</h2>

<p>Další užitečnou knihovnou usnadňující psaní jednotkových testů je knihovna
nazvaná <i>iota</i>. Tato knihovna programátorům nabízí makra usnadňující psaní
testů s&nbsp;využitím nových &bdquo;operátorů&ldquo; a navíc bez nutnosti
použití velkého množství závorek &ndash; ve skutečnosti je možné dosáhnout, že
celý jeden test bude zapsán bez jediné závorky. Nejdříve si připravíme nový
projekt s&nbsp;touto knihovnou a následně si vyzkoušíme její možnosti
v&nbsp;interaktivní smyčce REPL. Do projektového souboru je nutné přidat
zvýrazněný řádek:</p>

<pre>
(defproject iota-test "0.1.0-SNAPSHOT"
    :description "FIXME: write description"
    :url "http://example.com/FIXME"
    :license {:name "Eclipse Public License"
              :url "http://www.eclipse.org/legal/epl-v10.html"}
    :dependencies [[org.clojure/clojure "1.9.0"]
                   <strong>[juxt/iota "0.2.3"]</strong>]
    :main ^:skip-aot iota-test.core
    :target-path "target/%s"
    :profiles {:uberjar {:aot :all}})
</pre>

<p>V&nbsp;adresáři s&nbsp;projektem spustíme smyčku REPL:</p>

<pre>
<strong>lein repl</strong>
</pre>

<p>Následně musíme načíst jak knihovnu <strong>clojure.test</strong>, tak i
makro <strong>given</strong> z&nbsp;knihovny <strong>iota</strong>:</p>

<pre>
user=&gt; <strong>(use '[clojure.test])</strong>
nil
&nbsp;
user=&gt; <strong>(require '[juxt.iota :refer [given]])</strong>
</pre>

<p>Popis nově načteného makra <strong>given</strong> je dosti stručný, ale to
nevadí, protože si jeho schopnosti ukážeme o několik odstavců níže:</p>

<pre>
user=&gt; <strong>(doc given)</strong>
-------------------------
juxt.iota/given
([v &amp; body])
Macro
  Given v, assert the following…
nil
</pre>



<p><a name="k12"></a></p>
<h2 id="k12">12. Nové infixové operátory operátory použité v&nbsp;makru <strong>given</strong></h2>

<p>Makro <strong>given</strong> ve svém prvním parametru očekává libovolnou
hodnotu či funkci vracející hodnotu. Následuje libovolně dlouhá sekvence
podmínek, přičemž každá podmínka je zapisovaná v&nbsp;&bdquo;lidském&ldquo;
tvaru <i>selektor operátor očekávaná_hodnota</i>. Podívejme se na příklad,
v&nbsp;němž kontrolujeme, jaké hodnoty jsou uloženy v&nbsp;mapě. Pro striktní
porovnání hodnot slouží nový infixový operátor <strong>:=</strong>. Zapsány
jsou celkem dvě podmínky, a to pro selektor <strong>:a</strong> a
<strong>:b</strong>:</p>

<pre>
user=&gt; <strong>(given {:a 1 :b 2} :a := 1 :b := 2)</strong>
true
&nbsp;
user=&gt; <strong>(given {:a 1 :b 2} :a := 1 :b := 1)</strong>
&nbsp;
FAIL in () (form-init1562388683681536377.clj:1)
expected: (clojure.core/= ((juxt.iota/as-test-function :b) G__2883) 1)
  actual: (not (clojure.core/= 2 1))
false
</pre>

<p>Pomocí operátoru <strong>:?</strong> lze zjistit, zda hodnota vybraná
selektorem odpovídá zvolenému predikátu; druhý operátor <strong>:!?</strong>
testuje opačnou podmínku. Predikáty již dobře známe, takže se podívejme na
příklady:</p>

<pre>
user=&gt; <strong>(given {:a 1 :b 0 :c [1,2,3]} :a :? pos-int? :b :? zero? :c :? vector?)</strong>
true
&nbsp;
user=&gt; <strong>(given {:a 1 :b 0 :c [1,2,3]} :a :!? neg-int? :b :!? pos-int? :c :!? seq?)</strong>
true
&nbsp;
user=&gt; <strong>(given {:a 1 :b 0 :c [1,2,3]} :a :!? neg-int? :b :!? zero? :c :!? seq?)</strong>
&nbsp;
FAIL in () (form-init1562388683681536377.clj:1)
expected: (clojure.core/not (zero? ((juxt.iota/as-test-function :b) G__2949)))
  actual: (not (clojure.core/not true))
false
</pre>

<p>Operátorem <strong>:&lt;</strong> se zjišťuje, zda je vybraná hodnota
podmnožinou druhého operandu. Ovšem ve skutečnosti se i sekvence a vektory
převádí na množiny, takže lze psát:</p>

<pre>
user=&gt; <strong>(given {:c [1 2 3]} :c :&lt; [1 2 3 4 5])</strong>
true
&nbsp;
user=&gt; <strong>(given {:c [1 2 3 10]} :c :&lt; (range 10))</strong>
&nbsp;
FAIL in () (form-init1562388683681536377.clj:1)
expected: (clojure.set/subset? (clojure.core/set ((juxt.iota/as-test-function :c) G__2977)) (clojure.core/set (range 10)))
  actual: (not (clojure.set/subset? #{1 3 2 10} #{0 7 1 4 6 3 2 9 5 8}))
false
</pre>

<p>Tento operátor je možné zapisovat i příslušným Unicode znakem:</p>

<pre>
user=&gt; <strong>(given {:c [1 2 3]} :c :&lt; (range 10))</strong>
true
&nbsp;
user=&gt; <strong>(given {:c [1 2 3 10]} :c :⊂ (range 10))</strong>
&nbsp;
FAIL in () (form-init1562388683681536377.clj:1)
expected: (clojure.set/subset? (clojure.core/set ((juxt.iota/as-test-function :c) G__2992)) (clojure.core/set (range 10)))
  actual: (not (clojure.set/subset? #{1 3 2 10} #{0 7 1 4 6 3 2 9 5 8}))
false
</pre>

<p>Opačnou podmínku, tj.&nbsp;zda je druhý operand podmnožinou operandu
prvního, můžeme taktéž zapsat dvěma způsoby:</p>

<pre>
user=&gt; <strong>(given {:c [1 2 3 10]} :c :&gt; [])</strong>
true
&nbsp;
user=&gt; <strong>(given {:c [1 2 3 10]} :c :⊃ [])</strong>
true
</pre>

<p>Posledním operátorem, o kterém se dnes ve stručnosti zmíníme, je operátor
<strong>:#</strong>, který testuje hodnotu vůči regulárnímu výrazu:</p>

<pre>
user=&gt; <strong>(given {:body "Hello world"} :body :# #"[a-z]+")</strong>
&nbsp;
FAIL in () (form-init1562388683681536377.clj:1)
expected: (clojure.core/re-matches (clojure.core/re-pattern #"[a-z]+") ((juxt.iota/as-test-function :body) G__2997))
  actual: (not (clojure.core/re-matches #"[a-z]+" "Hello world"))
nil
user=&gt; <strong>(given {:body "hello world"} :body :# #"[a-z]+")</strong>
&nbsp;
FAIL in () (form-init1562388683681536377.clj:1)
expected: (clojure.core/re-matches (clojure.core/re-pattern #"[a-z]+") ((juxt.iota/as-test-function :body) G__3002))
  actual: (not (clojure.core/re-matches #"[a-z]+" "hello world"))
nil
user=&gt; <strong>(given {:body "hello world"} :body :# #"[a-z ]+")</strong>
"hello world"
</pre>



<p><a name="k13"></a></p>
<h2 id="k13">13. Ukázka testu napsaného s&nbsp;využitím knihovny <strong>iota</strong></h2>

<p>Zkusme si nyní vytvořit <a
href="https://github.com/tisnik/clojure-examples/tree/master/iota-test">jednoduchý
projekt</a>, v&nbsp;němž knihovnu <strong>iota</strong> použijeme. Projektový
soubor <strong>project.clj</strong> bude vypadat následovně:</p>

<pre>
(defproject iota-test "0.1.0-SNAPSHOT"
  :description "FIXME: write description"
  :url "http://example.com/FIXME"
  :license {:name "Eclipse Public License"
            :url "http://www.eclipse.org/legal/epl-v10.html"}
  :dependencies [[org.clojure/clojure "1.9.0"]
                 <strong>[juxt/iota "0.2.3"]</strong>
                 [ring/ring-core "1.3.2"]]
  :main ^:skip-aot iota-test.core
  :target-path "target/%s"
  :profiles {:uberjar {:aot :all}})
</pre>

<p>Samotný zdrojový kód bude opět obsahovat funkci
<strong>generate-response</strong>, která vytvoří mapu představující odpověď
serveru posílanou klientovi:</p>

<pre>
(ns iota-test.core
    (:gen-class))
&nbsp;
(require '[ring.util.response :as response])
&nbsp;
(defn cache-control-headers
    "Update the response to contains all cache-control headers."
    [response]
    (-&gt; response
        (assoc-in [:headers "Cache-Control"] ["must-revalidate" "no-cache" "no-store"])
        (assoc-in [:headers "Expires"] "0")
        (assoc-in [:headers "Pragma"] "no-cache")))
&nbsp;
(defn generate-response
    [content]
    (-&gt; (response/response content)
        (response/content-type "text/plain; charset=utf-8")
        cache-control-headers))
&nbsp;
(defn -main
    [&amp; args]
    (println (generate-response "Hello world!")))
</pre>

<p>Nejzajímavější jsou samozřejmě testy, protože zde můžeme využít nové
operátory. Povšimněte si, že hodnotu uloženou pod klíčem :status testujeme na
rovnost, dále pro testy používáme predikát <strong>string?</strong>, test
s&nbsp;využitím regulárního výrazu a v&nbsp;neposlední řadě i test na relaci
&bdquo;je nadmnožinou&ldquo;. Dále si povšimněte, že složitější selektor lze
zapsat formou vektoru:</p>

<pre>
(ns iota-test.core-test
  (:require [clojure.test   :refer :all]
            [iota-test.core :refer :all]
            [juxt.iota      :refer [given]]))
&nbsp;
&nbsp;
(deftest test-generate-response
    (testing "Function generate-response"
        (given (generate-response "hello world!")
               :status <strong>:=</strong> 200
               :body   <strong>:#</strong> #"[a-zA-Z !]+"
               [:headers "Pragma"] <strong>:?</strong> string?
               [:headers "Content-Type"] <strong>:?</strong> string?
               [:headers "Content-Type"] <strong>:?</strong> #(.startsWith % "text/plain; ")
               [:headers "Cache-Control"] <strong>:&gt;</strong> ["no-cache" "no-store"])))
</pre>

<p>Samotné spuštění testů se provede standardním způsobem:</p>

<pre>
<strong>lein test iota-test.core-test</strong>
&nbsp;
Ran 1 tests containing 6 assertions.
0 failures, 0 errors.
</pre>



<p><a name="k14"></a></p>
<h2 id="k14">14. Testování s&nbsp;využitím knihovny Expectations</h2>

<p>Nízkoúrovňový přístup knihovny <strong>clojure.test</strong> sice do určité
míry vylepšuje výše zmíněná knihovna <strong>iota</strong>, ovšem
k&nbsp;dispozici jsou i další možnosti. Poněkud odlišným směrem se vydal
vývojář Jay Fields, který naprogramoval nástroj nazvaný <i>Expectations</i>
(resp.&nbsp;expectations, tedy s&nbsp;malým &bdquo;e&ldquo; na začátku názvu).
Tento nástroj sice interně využívá výše zmíněnou knihovnu <i>clojure.test</i>,
ovšem staví nad ní mezivrstvu zajišťující rozhraní pro psaní přehlednějších
jednotkových testů. V&nbsp;této mezivrstvě nalezneme &bdquo;inteligentní&ldquo;
makro <strong>expect</strong>, které samo o sobě postačuje pro napsání většiny
testů. Pro další zjednodušení jsou v&nbsp;nástroji Expectations dostupná i
další makra, především pak makro <strong>more-&gt;</strong>,
<strong>more-of</strong> a v&nbsp;neposlední řadě taktéž
<strong>from-each</strong>.</p>

<p>To však není vše, protože podobně inteligentně zpracovaná jsou i hlášení o
chybách, která jsou generovaná při spouštění jednotkových testů. Namísto
obvyklé strohé informace o tom, že se například vypočtená kolekce odlišuje od
kolekce očekávané, dokáže knihovna Expectations vypsat i další informace,
například tehdy, když vrácená kolekce obsahuje jen další prvky (a zbytek
kolekce se shoduje s&nbsp;kolekcí očekávanou), některé prvky chybí či se liší
pořadí prvků. I v&nbsp;případě vzniku výjimky se namísto celého obsahu
zásobníkových rámců vypíšou pouze relevantní informace.</p>

<p>Pro použití této knihovny je nutné upravit projektový soubor
<strong>project.clj</strong>:</p>

<pre>
(defproject factorial3 "0.1.0-SNAPSHOT"
    :description "FIXME: write description"
    :url "http://example.com/FIXME"
    :license {:name "Eclipse Public License"
              :url "http://www.eclipse.org/legal/epl-v10.html"}
    :dependencies [[org.clojure/clojure "1.6.0"]
                   <strong>[expectations "2.0.9"]</strong>]
    :main ^:skip-aot factorial2.core
    :target-path "target/%s"
    :plugins [<strong>[lein-expectations "0.0.8"]</strong>
              [lein-cloverage "1.0.2"]]
    :profiles {:uberjar {:aot :all}})
</pre>

<p>Leiningen nyní umožňuje spouštět novou sadu testů příkazem:</p>

<pre>
<strong>lein expectations</strong>
&nbsp;
Ran 0 tests containing 0 assertions in 8 msecs
0 failures, 0 errors.
</pre>

<p>Ve skutečnosti využívá knihovna Expectations řídicí kódy terminálu pro
obarvení výstupu, takže výsledek může vypadat takto:</p>

<a href="http://www.root.cz/obrazek/218465/"><img src="http://i.iinfo.cz/images/199/exp1-prev.png" class="image-218465" alt="&#160;" height="55" width="370" /></a>



<p><a name="k15"></a></p>
<h2 id="k15">15. Testy napsané s&nbsp;využitím knihovny <strong>Expectations</strong></h2>

<p>Při použití knihovny <i>Expectations</i> se testy zapisují nepatrně odlišným
způsobem, než je tomu v&nbsp;případě <strong>clojure.test</strong>. Především
se zde nepoužívá sdružování s&nbsp;využitím <strong>deftest</strong> a
<strong>testing</strong>, protože autor knihovny <i>Expectations</i> (Jay
Fields) se drží zásady &bdquo;One assertion per test&ldquo;. Dále se namísto
maker <strong>is</strong> a <strong>are</strong>, které většinou vyžadují
explicitní zápis porovnání, používá inteligentní makro nazvané
<strong>expect</strong>. Toto makro očekává dva parametry. Prvním parametrem je
očekávaná hodnota, druhým parametrem je pak většinou volání nějaké funkce či
jiného makra.</p>

<p>Makro <strong>expect</strong> na základě typu prvního parametru automaticky
rozpozná, jakým způsobem se má provádět porovnávání; porovnávat lze totiž jak
návratové hodnoty (jakéhokoli typu), tak i například zjistit, zda byla vyhozena
očekávaná výjimka, zda má návratová hodnota očekávaný typ atd. atd. My nejdříve
použijeme test s&nbsp;porovnáváním návratových hodnot a zjišťováním, zda byla
vyhozena očekávaná výjimka. V&nbsp;obou případech je použit stejný formát
volání makra <strong>expect</strong>:</p>

<pre>
(ns <strong>factorial2.core-expect-test</strong>
  (:require [factorial2.core :refer :all])
  (:use <strong>expectations</strong>))
&nbsp;
(<strong>expect</strong> 1       (factorial 0))
(<strong>expect</strong> 1       (factorial 1))
(<strong>expect</strong> (* 1 2) (factorial 2))
(<strong>expect</strong> (* 1 2 3 4 5) (factorial 5))
(<strong>expect</strong> 720     (factorial 6))
&nbsp;
(<strong>expect</strong> 0 (factorial 0))
(<strong>expect</strong> 0 (factorial 1))
(<strong>expect</strong> 0 (factorial 2))
&nbsp;
(<strong>expect</strong> IllegalArgumentException (factorial -1))
(<strong>expect</strong> IllegalArgumentException (factorial -2))
(<strong>expect</strong> IllegalArgumentException (factorial -100))
&nbsp;
(<strong>expect</strong> IllegalArgumentException (factorial 1))
(<strong>expect</strong> IllegalArgumentException (factorial 2))
(<strong>expect</strong> IllegalArgumentException (factorial 3))
</pre>

<p>Následuje výstup poskytovaný knihovnou <i>Expectations</i>:</p>

<pre>
failure in (core_expect_test.clj:14) : factorial2.core-expect-test
(expect 0 (factorial 0))
&nbsp;
           expected: 0
                was: 1
&nbsp;
failure in (core_expect_test.clj:15) : factorial2.core-expect-test
(expect 0 (factorial 1))
&nbsp;
           expected: 0
                was: 1
&nbsp;
failure in (core_expect_test.clj:16) : factorial2.core-expect-test
(expect 0 (factorial 2))
&nbsp;
           expected: 0
                was: 2
&nbsp;
failure in (core_expect_test.clj:22) : factorial2.core-expect-test
(expect IllegalArgumentException (factorial 1))
&nbsp;
           (factorial 1) did not throw IllegalArgumentException
&nbsp;
failure in (core_expect_test.clj:23) : factorial2.core-expect-test
(expect IllegalArgumentException (factorial 2))
&nbsp;
           (factorial 2) did not throw IllegalArgumentException
&nbsp;
failure in (core_expect_test.clj:24) : factorial2.core-expect-test
(expect IllegalArgumentException (factorial 3))
&nbsp;
           (factorial 3) did not throw IllegalArgumentException
&nbsp;
Ran 14 tests containing 14 assertions in 71 msecs
6 failures, 0 errors.
</pre>

<p>Opět platí, že výstup je ve skutečnosti obarven a vypadá zhruba takto:</p>

<a href="http://www.root.cz/obrazek/218466/"><img src="http://i.iinfo.cz/images/209/exp2-prev.png" class="image-218466" alt="&#160;" height="270" width="285" /></a>

<p>Takto generovaný výsledek testů je podle mého názoru čitelnější, neboť jsou
zobrazeny jen ty skutečně relevantní informace (nicméně výstup
z&nbsp;<strong>humate-test-output</strong> je ještě lepší).</p>

<p>Pokud je prvním parametrem regulární výraz (<i>regexp</i>), bude se
&bdquo;matchovat&ldquo; s&nbsp;řetězcem, který je očekáván jako druhý parametr
(či výsledek volané funkce/makra). Připomeňme si, že regulární výraz lze
v&nbsp;jazyku Clojure považovat za samostatný datový typ a nikoli za běžný
řetězec (což zjednodušuje zápis regulárních výrazů):</p>

<pre>
(<strong>expect</strong> #"Expect" "Expectations")
&nbsp;
(<strong>expect</strong> #"^[a-zA-Z]+$" "Hello")
&nbsp;
(<strong>expect</strong> #"^[a-zA-Z]+$" "123qwe") ; nebude splněno
&nbsp;
(<strong>expect</strong> #"^[a-zA-Z0-9]+$" "123qwe") ; bude splněno
&nbsp;
(<strong>expect</strong> #"[\s]*" "123qwe")
&nbsp;
(<strong>expect</strong> #"^([A-Z][a-z]+)+$" "CamelCaseString")  ; bude splněno
&nbsp;
(<strong>expect</strong> #"^([A-Z][a-z]+)+$" "CamelCaseStringS") ; nebude splněno
&nbsp;
(<strong>expect</strong> #"^([A-Z][a-z]+)+$" "camel_case_string") ; nebude splněno
</pre>

<p>Velmi elegantní je práce s&nbsp;kolekcemi, neboť se automaticky rozpoznávají
některé typické odlišnosti dvou kolekcí (očekávané hodnoty a hodnoty vypočtené)
&ndash; přidání prvku, ubrání prvku, prohození prvků atd. Podívejme se na
příklady:</p>

<pre>
<i>; zjištění existence prvku v kolekci</i>
(<strong>expect</strong> 3 (in [1 2 3]))
&nbsp;
<i>; porovnání dvou různých kolekcí</i>
(<strong>expect</strong> [1 2] [3 4])
&nbsp;
(<strong>expect</strong> [1 2] [3 4 5 6])
&nbsp;
<i>; různé typy, stejný obsah - test projde</i>
(<strong>expect</strong> [1 2] '(1 2))
&nbsp;
<i>; expect rozpozná zpřeházené prvky</i>
(<strong>expect</strong> [1 2] [2 1])
(<strong>expect</strong> [1 2 3] [3 2 1])
&nbsp;
<i>; expect rozpozná přidání prvku</i>
(<strong>expect</strong> [1 2] [1 2 3])
(<strong>expect</strong> [1 2] [1 2 3 4 5])
&nbsp;
<i>; expect rozpozná i ubrání prvku</i>
(<strong>expect</strong> [1 2 3] [1 2])
(<strong>expect</strong> [1 2 3 4 5] [1 2])
&nbsp;
<i>; dtto pro mapy - opět se eliminuje výpis zbytečných informací</i>
(<strong>expect</strong> #{:name "Bender" :id 42} #{:name "Bender" :id 42})
&nbsp;
(<strong>expect</strong> #{:name "Bender" :id 42} #{:name "Joe" :id 42})
&nbsp;
(<strong>expect</strong> #{:name "Bender" :id 42} #{:name "Joe" :id 1000})
&nbsp;
(<strong>expect</strong> #{:name "Bender" :id 42} #{:name "Bender" :id 42 :foo :bar})
&nbsp;
(<strong>expect</strong> #{:name "Bender" :id 42} #{:name "Bender"})
&nbsp;
(<strong>expect</strong> #{:name "Bender" :id 42} #{:name "Bender" :not-id 42})
</pre>

<p>Výsledek běhu testů:</p>

<pre>
failure in (core_test.clj:67) : expectations-demo.core-test
(expect [1 2] [3 4])
&nbsp;
           expected: [1 2] 
                was: [3 4]
&nbsp;
           in expected, not actual: [1 2]
           in actual, not expected: [3 4]
&nbsp;
failure in (core_test.clj:69) : expectations-demo.core-test
(expect [1 2] [3 4 5 6])
&nbsp;
           expected: [1 2] 
                was: [3 4 5 6]
&nbsp;
           in expected, not actual: [1 2]
           in actual, not expected: [3 4 5 6]
           actual is larger than expected
&nbsp;
failure in (core_test.clj:75) : expectations-demo.core-test
(expect [1 2] [2 1])
&nbsp;
           expected: [1 2] 
                was: [2 1]
&nbsp;
           in expected, not actual: [1 2]
           in actual, not expected: [2 1]
           lists appear to contain the same items with different ordering
&nbsp;
failure in (core_test.clj:76) : expectations-demo.core-test
(expect [1 2 3] [3 2 1])
&nbsp;
           expected: [1 2 3] 
                was: [3 2 1]
&nbsp;
           in expected, not actual: [1 nil 3]
           in actual, not expected: [3 nil 1]
           lists appear to contain the same items with different ordering
&nbsp;
failure in (core_test.clj:79) : expectations-demo.core-test
(expect [1 2] [1 2 3])
&nbsp;
           expected: [1 2] 
                was: [1 2 3]
&nbsp;
           in expected, not actual: null
           in actual, not expected: [nil nil 3]
           actual is larger than expected
&nbsp;
failure in (core_test.clj:80) : expectations-demo.core-test
(expect [1 2] [1 2 3 4 5])
&nbsp;
           expected: [1 2] 
                was: [1 2 3 4 5]
&nbsp;
           in expected, not actual: null
           in actual, not expected: [nil nil 3 4 5]
           actual is larger than expected
&nbsp;
failure in (core_test.clj:83) : expectations-demo.core-test
(expect [1 2 3] [1 2])
&nbsp;
           expected: [1 2 3] 
                was: [1 2]
&nbsp;
           in expected, not actual: [nil nil 3]
           in actual, not expected: null
           expected is larger than actual
&nbsp;
failure in (core_test.clj:84) : expectations-demo.core-test
(expect [1 2 3 4 5] [1 2])
&nbsp;
           expected: [1 2 3 4 5] 
                was: [1 2]
&nbsp;
           in expected, not actual: [nil nil 3 4 5]
           in actual, not expected: null
           expected is larger than actual
&nbsp;
failure in (core_test.clj:89) : expectations-demo.core-test
(expect #{:name "Bender" :id 42} #{:name "Joe" :id 42})
&nbsp;
           expected: #{:name "Bender" :id 42} 
                was: #{:name "Joe" :id 42}
&nbsp;
           in expected, not actual: #{"Bender"}
           in actual, not expected: #{"Joe"}
&nbsp;
failure in (core_test.clj:91) : expectations-demo.core-test
(expect #{:name "Bender" :id 42} #{:name 1000 "Joe" :id})
&nbsp;
           expected: #{:name "Bender" :id 42} 
                was: #{:name 1000 "Joe" :id}
&nbsp;
           in expected, not actual: #{"Bender" 42}
           in actual, not expected: #{1000 "Joe"}
&nbsp;
failure in (core_test.clj:93) : expectations-demo.core-test
(expect #{:name "Bender" :id 42} #{:bar :name "Bender" :foo :id 42})
&nbsp;
           expected: #{:name "Bender" :id 42} 
                was: #{:bar :name "Bender" :foo :id 42}
&nbsp;
           in expected, not actual: null
           in actual, not expected: #{:bar :foo}
&nbsp;
failure in (core_test.clj:95) : expectations-demo.core-test
(expect #{:name "Bender" :id 42} #{:name "Bender"})
&nbsp;
           expected: #{:name "Bender" :id 42} 
                was: #{:name "Bender"}
&nbsp;
           in expected, not actual: #{:id 42}
           in actual, not expected: null
&nbsp;
failure in (core_test.clj:97) : expectations-demo.core-test
(expect #{:name "Bender" :id 42} #{:name "Bender" :not-id 42})
&nbsp;
           expected: #{:name "Bender" :id 42} 
                was: #{:name "Bender" :not-id 42}
&nbsp;
           in expected, not actual: #{:id}
           in actual, not expected: #{:not-id}
</pre>



<p><a name="k16"></a></p>
<h2 id="k16">16. Podpora pro BDD (behaviour-driven development) knihovnou <strong>cucumber-jvm-clojure</strong></h2>

<p>Jen ve stručnosti se dnes zmíním o posledním nástroji nazvaném
<strong>cucumber-jvm-clojure</strong>. Tento nástroj slouží k&nbsp;podpoře
<i>BDD</i> neboli <strong>behaviour-driven development</strong>. Z&nbsp;pohledu
vývojáře se jedná o možnost zápisu testovacích scénářů formalizovaným jazykem
blízkým angličtině. Této problematice se budu věnovat v&nbsp;samostatném článku
(věnovaném ale spíše Pythonu a modulu <strong>behave</strong>), takže si jen ve
stručnosti ukažme, jak by bylo možné zapsat BDD test pro funkci počítající
faktoriál (ve skutečnosti se tyto testy píšou na vyšší úrovni, nejedná se totiž
o jednotkové testy):</p>

<pre>
(ns cucumber-demo.core
    (:gen-class))
&nbsp;
<i>; funkce faktorial obsahuje i test na zaporne hodnoty</i>
(defn factorial
    [n]
    (if (neg? n)
        (throw (IllegalArgumentException. "negative numbers are not supported!"))
        (apply * (range 1M (inc n)))))
&nbsp;
<i>; otestujeme funkci faktorial</i>
(defn -main
    [&amp; args]
    (doseq [i (range 0 10)]
        (println i "! = " (factorial i))))
</pre>

<p>Testovací scénáře skutečně připomínají angličtinu, ovšem slova
<strong>Feature</strong>, <strong>Scenario</strong>, <strong>Given</strong>,
<strong>When</strong>, <strong>Then</strong> a <strong>Examples</strong> mají
speciální význam. Jednodušší forma testu může vypadat takto:</p>

<pre>
Feature: Factorial computation
&nbsp;
  Scenario: Compute factorial for natural numbers
    Given The function factorial is callable
    When I try to compute 2!
    Then I should get result 2
    When I try to compute 3!
    Then I should get result 6
    When I try to compute 10!
    Then I should get result 3628800
</pre>

<p>V&nbsp;případě potřeby je možné ten samý test spustit vícekrát
s&nbsp;různými parametry (<strong>n</strong>) a s&nbsp;očekáváním různých
výsledků (<strong>result</strong>):</p>

<pre>
Feature: Factorial computation #2
&nbsp;
  Scenario Outline: Compute more factorials for natural numbers
    Given The function factorial is callable
    When I try to compute &lt;n&gt;!
    Then I should get result &lt;result&gt;
&nbsp;
    Examples:
        | n | result |
        | 1 | 1 |
        | 2 | 2 |
        | 3 | 6 |
</pre>

<p>V&nbsp;další kapitole si ukážeme, jak připravit projekt akceptující výše
uvedené testy.</p>



<p><a name="k17"></a></p>
<h2 id="k17">17. Jednoduchý projekt testovaný s&nbsp;využitím BDD</h2>

<p>Projektový soubor je nutné upravit následujícím způsobem. Povšimněte si
cesty k&nbsp;testovacím scénářům a současně i ke zdrojovým kódům testů:</p>

<pre>
(defproject cucumber-demo "0.1.0-SNAPSHOT"
    :description "FIXME: write description"
    :url "http://example.com/FIXME"
    :license {:name "Eclipse Public License"
              :url "http://www.eclipse.org/legal/epl-v10.html"}
    :dependencies [[org.clojure/clojure "1.8.0"]]
    :plugins [<strong>[com.siili/lein-cucumber "1.0.7"]</strong>]
    :<strong>cucumber-feature-paths ["test/features/"]</strong>
    :main ^:skip-aot cucumber-demo.core
    :target-path "target/%s"
    :profiles {:uberjar {:aot :all}
               <strong>:dev {:dependencies [[com.siili/lein-cucumber "1.0.7"]]</strong>}})
</pre>

<p>Po spuštění příkazu:</p>

<pre>
<strong>lein deps</strong>
</pre>

<p>se nainstaluje nový modul pro Leiningen:</p>

<pre>
Leiningen is a tool for working with Clojure projects.
&nbsp;
Several tasks are available:
change              Rewrite project.clj by applying a function.
check               Check syntax and warn on reflection.
classpath           Print the classpath of the current project.
clean               Remove all files from project's target-path.
compile             Compile Clojure source into .class files.
<strong>cucumber            Runs Cucumber features in test/features with glue in test/features/step_definitions</strong>
deploy              Build and deploy jar to remote repository.
deps                Download all dependencies.
do                  Higher-order task to perform other tasks in succession.
help                Display a list of tasks or help for a given task.
install             Install the current project to the local repository.
jar                 Package up all the project's files into a jar file.
javac               Compile Java source files.
new                 Generate project scaffolding based on a template.
plugin              DEPRECATED. Please use the :user profile instead.
pom                 Write a pom.xml file to disk for Maven interoperability.
release             Perform :release-tasks.
repl                Start a repl session either with the current project or standalone.
retest              Run only the test namespaces which failed last time around.
run                 Run a -main function with optional command-line arguments.
search              Search remote maven repositories for matching jars.
show-profiles       List all available profiles or display one if given an argument.
test                Run the project's tests.
trampoline          Run a task without nesting the project's JVM inside Leiningen's.
uberjar             Package up the project files and dependencies into a jar file.
update-in           Perform arbitrary transformations on your project map.
upgrade             Upgrade Leiningen to specified version or latest stable.
vcs                 Interact with the version control system.
version             Print version for Leiningen and the current JVM.
with-profile        Apply the given task with the profile(s) specified.
</pre>

<p>Testovací scénáře se uloží do adresáře <strong>test/features</strong>, což
je ostatně patrné i při pohledu <a
href="https://github.com/tisnik/clojure-examples/tree/master/cucumber-demo">na
demonstrační příklad</a>:</p>

<pre>
.
├── doc
│   └── intro.md
├── LICENSE
├── project.clj
├── README.md
├── resources
├── src
│   └── cucumber_demo
│       └── core.clj
└── test
    ├── cucumber_demo
    │   └── core_test.clj
    └── features
        ├── factorial.feature
        └── step_definitions
            └── factorial_steps.clj
</pre>

<p>Nyní musíme napsat implementaci testů, tj.&nbsp;funkce, které se mají
provést pro všechny řádky začínající v&nbsp;testovacím scénáři na
<strong>Given</strong>, <strong>When</strong> a <strong>Then</strong>. Tyto
funkce jsou definovány přes makra <strong>(Given)</strong>,
<strong>(When)</strong> a <strong>(Then)</strong>, za nimiž následuje regulární
výraz zpracovávající text scénáře. Taktéž je nutné vyřešit způsob držení
informace o <i>kontextu</i>, protože se mezi jednotlivými kroky musí udržovat
informace o stavu testu (což jde proti filozofii jazyka Clojure, v&nbsp;němž se
snažíme stavovým hodnotám vyhnout):</p>

<pre>
(use '[clojure.test])
(use '[cucumber-demo.core])
&nbsp;
&nbsp;
(def context (atom
    {:input nil
     :result nil}))
&nbsp;
&nbsp;
(Given #"^The function factorial is callable$"
    []
    (assert (clojure.test/function? 'cucumber-demo.core/factorial)))
&nbsp;
&nbsp;
(When #"^I try to compute (\d+)!$"
    [input]
    (let [n (bigdec input)]
        (swap! context assoc :input n)
        (swap! context assoc :result (factorial n))))
&nbsp;
&nbsp;
(Then #"^I should get result (\d+)$"
    [result_str]
    (let [expected (bigdec result_str)
          actual   (:result @context)]
          (assert (= expected actual))))
</pre>

<p>Podrobnější informace o BDD, jazyku Gherkin i o jeho implementaci
v&nbsp;Pythonu a Clojure si řekneme příště.</p>



<p><a name="k18"></a></p>
<h2 id="k18">18. Repositář s&nbsp;demonstračními příklady</h2>

<p>Všechny demonstrační příklady a projekty určené pro Clojure verze 1.9.0 byly
uloženy do repositáře <a
href="https://github.com/tisnik/clojure-examples">https://github.com/tisnik/clojure-examples</a>:</p>

<table>
<tr><th>Projekt</th><th>Popis</th><th>Odkaz</th></tr>
<tr><td>1</td><td>factorial</td><td><a href="https://github.com/tisnik/clojure-examples/tree/master/factorial">https://github.com/tisnik/clojure-examples/tree/master/factorial</a></td></tr>
<tr><td>2</td><td>factorial2</td><td><a href="https://github.com/tisnik/clojure-examples/tree/master/factorial2">https://github.com/tisnik/clojure-examples/tree/master/factorial2</a></td></tr>
<tr><td>3</td><td>factorial3</td><td><a href="https://github.com/tisnik/clojure-examples/tree/master/factorial3">https://github.com/tisnik/clojure-examples/tree/master/factorial3</a></td></tr>
<tr><td>4</td><td>factorial4</td><td><a href="https://github.com/tisnik/clojure-examples/tree/master/factorial4">https://github.com/tisnik/clojure-examples/tree/master/factorial4</a></td></tr>
<tr><td>5</td><td>expectations-demo</td><td><a href="https://github.com/tisnik/clojure-examples/tree/master/expectations-demo">https://github.com/tisnik/clojure-examples/tree/master/expectations-demo</a></td></tr>
<tr><td>6</td><td>cloverage</td><td><a href="https://github.com/tisnik/clojure-examples/tree/master/cloverage">https://github.com/tisnik/clojure-examples/tree/master/cloverage</a></td></tr>
<tr><td>7</td><td>humane-output</td><td><a href="https://github.com/tisnik/clojure-examples/tree/master/humane-output">https://github.com/tisnik/clojure-examples/tree/master/humane-output</a></td></tr>
<tr><td>8</td><td>iota-test</td><td><a href="https://github.com/tisnik/clojure-examples/tree/master/iota-test">https://github.com/tisnik/clojure-examples/tree/master/iota-test</a></td></tr>
<tr><td>9</td><td>cucumber-demo</td><td><a href="https://github.com/tisnik/clojure-examples/tree/master/cucumber-demo">https://github.com/tisnik/clojure-examples/tree/master/cucumber-demo</a></td></tr>
</table>

<p><div class="rs-tip-major">Poznámka: pro spuštění projektů je vyžadován
nainstalovaný správce projektů <i>Leiningen</i>.</div></p>



<p><a name="k19"></a></p>
<h2 id="k19">19. Odkazy na předchozí části tohoto seriálu</h2>

<ol>

<li>Clojure  1: Úvod<br />
<a href="http://www.root.cz/clanky/clojure-aneb-jazyk-umoznujici-tvorbu-bezpecnych-vicevlaknovych-aplikaci-pro-jvm/">http://www.root.cz/clanky/clojure-aneb-jazyk-umoznujici-tvorbu-bezpecnych-vicevlaknovych-aplikaci-pro-jvm/</a>
</li>

<li>Clojure  2: Symboly, kolekce atd.<br />
<a href="http://www.root.cz/clanky/clojure-aneb-jazyk-umoznujici-tvorbu-bezpecnych-vicevlaknovych-aplikaci-pro-jvm-2-cast/">http://www.root.cz/clanky/clojure-aneb-jazyk-umoznujici-tvorbu-bezpecnych-vicevlaknovych-aplikaci-pro-jvm-2-cast/</a>
</li>

<li>Clojure  3: Funkcionální programování<br />
<a href="http://www.root.cz/clanky/clojure-aneb-jazyk-umoznujici-tvorbu-bezpecnych-vicevlaknovych-aplikaci-pro-jvm-3-cast-funkcionalni-programovani/">http://www.root.cz/clanky/clojure-aneb-jazyk-umoznujici-tvorbu-bezpecnych-vicevlaknovych-aplikaci-pro-jvm-3-cast-funkcionalni-programovani/</a>
</li>

<li>Clojure  4: Kolekce, sekvence a lazy sekvence<br />
<a href="http://www.root.cz/clanky/clojure-aneb-jazyk-umoznujici-tvorbu-bezpecnych-vicevlaknovych-aplikaci-pro-jvm-4-cast-kolekce-sekvence-a-lazy-sekvence/">http://www.root.cz/clanky/clojure-aneb-jazyk-umoznujici-tvorbu-bezpecnych-vicevlaknovych-aplikaci-pro-jvm-4-cast-kolekce-sekvence-a-lazy-sekvence/</a>
</li>

<li>Clojure  5: Sekvence, lazy sekvence a paralelní programy<br />
<a href="http://www.root.cz/clanky/clojure-a-bezpecne-aplikace-pro-jvm-sekvence-lazy-sekvence-a-paralelni-programy/">http://www.root.cz/clanky/clojure-a-bezpecne-aplikace-pro-jvm-sekvence-lazy-sekvence-a-paralelni-programy/</a>
</li>

<li>Clojure  6: Podpora pro paralelní programování<br />
<a href="http://www.root.cz/clanky/programovaci-jazyk-clojure-6-futures-nejsou-jen-financni-derivaty/">http://www.root.cz/clanky/programovaci-jazyk-clojure-6-futures-nejsou-jen-financni-derivaty/</a>
</li>

<li>Clojure  7: Další funkce pro paralelní programování<br />
<a href="http://www.root.cz/clanky/programovaci-jazyk-clojure-7-dalsi-podpurne-prostredky-pro-paralelni-programovani/">http://www.root.cz/clanky/programovaci-jazyk-clojure-7-dalsi-podpurne-prostredky-pro-paralelni-programovani/</a>
</li>

<li>Clojure  8: Identity, stavy, neměnné hodnoty a reference<br />
<a href="http://www.root.cz/clanky/programovaci-jazyk-clojure-8-identity-stavy-nemenne-hodnoty-a-referencni-typy/">http://www.root.cz/clanky/programovaci-jazyk-clojure-8-identity-stavy-nemenne-hodnoty-a-referencni-typy/</a>
</li>

<li>Clojure  9: Validátory, pozorovatelé a kooperace s Javou<br />
<a href="http://www.root.cz/clanky/programovaci-jazyk-clojure-9-validatory-pozorovatele-a-kooperace-mezi-clojure-a-javou/">http://www.root.cz/clanky/programovaci-jazyk-clojure-9-validatory-pozorovatele-a-kooperace-mezi-clojure-a-javou/</a>
</li>

<li>Clojure 10: Kooperace mezi Clojure a Javou<br />
<a href="http://www.root.cz/clanky/programovaci-jazyk-clojure-10-kooperace-mezi-clojure-a-javou-pokracovani/">http://www.root.cz/clanky/programovaci-jazyk-clojure-10-kooperace-mezi-clojure-a-javou-pokracovani/</a>
</li>

<li>Clojure 11: Generátorová notace seznamu/list comprehension<br />
<a href="http://www.root.cz/clanky/programovaci-jazyk-clojure-11-generatorova-notace-seznamu-list-comprehension/">http://www.root.cz/clanky/programovaci-jazyk-clojure-11-generatorova-notace-seznamu-list-comprehension/</a>
</li>

<li>Clojure 12: Překlad programů z Clojure do bajtkódu JVM I:<br />
<a href="http://www.root.cz/clanky/programovaci-jazyk-clojure-12-preklad-programu-z-clojure-do-bajtkodu-jvm/">http://www.root.cz/clanky/programovaci-jazyk-clojure-12-preklad-programu-z-clojure-do-bajtkodu-jvm/</a>
</li>

<li>Clojure 13: Překlad programů z Clojure do bajtkódu JVM II:<br />
<a href="http://www.root.cz/clanky/programovaci-jazyk-clojure-13-preklad-programu-z-clojure-do-bajtkodu-jvm-pokracovani/">http://www.root.cz/clanky/programovaci-jazyk-clojure-13-preklad-programu-z-clojure-do-bajtkodu-jvm-pokracovani/</a>
</li>

<li>Clojure 14: Základy práce se systémem maker<br />
<a href="http://www.root.cz/clanky/programovaci-jazyk-clojure-14-zaklady-prace-se-systemem-maker/">http://www.root.cz/clanky/programovaci-jazyk-clojure-14-zaklady-prace-se-systemem-maker/</a>
</li>

<li>Clojure 15: Tvorba uživatelských maker<br />
<a href="http://www.root.cz/clanky/programovaci-jazyk-clojure-15-tvorba-uzivatelskych-maker/">http://www.root.cz/clanky/programovaci-jazyk-clojure-15-tvorba-uzivatelskych-maker/</a>
</li>

<li>Clojure 16: Složitější uživatelská makra<br />
<a href="http://www.root.cz/clanky/programovaci-jazyk-clojure-16-slozitejsi-uzivatelska-makra/">http://www.root.cz/clanky/programovaci-jazyk-clojure-16-slozitejsi-uzivatelska-makra/</a>
</li>

<li>Clojure 17: Využití standardních maker v praxi<br />
<a href="http://www.root.cz/clanky/programovaci-jazyk-clojure-17-vyuziti-standardnich-maker-v-praxi/">http://www.root.cz/clanky/programovaci-jazyk-clojure-17-vyuziti-standardnich-maker-v-praxi/</a>
</li>

<li>Clojure 18: Základní techniky optimalizace aplikací<br />
<a href="http://www.root.cz/clanky/programovaci-jazyk-clojure-18-zakladni-techniky-optimalizace-aplikaci/">http://www.root.cz/clanky/programovaci-jazyk-clojure-18-zakladni-techniky-optimalizace-aplikaci/</a>
</li>

<li>Clojure 19: Vývojová prostředí pro Clojure<br />
<a href="http://www.root.cz/clanky/programovaci-jazyk-clojure-19-vyvojova-prostredi-pro-clojure/">http://www.root.cz/clanky/programovaci-jazyk-clojure-19-vyvojova-prostredi-pro-clojure/</a>
</li>

<li>Clojure 20: Vývojová prostředí pro Clojure (Vimu s REPL)<br />
<a href="http://www.root.cz/clanky/programovaci-jazyk-clojure-20-vyvojova-prostredi-pro-clojure-integrace-vimu-s-repl/">http://www.root.cz/clanky/programovaci-jazyk-clojure-20-vyvojova-prostredi-pro-clojure-integrace-vimu-s-repl/</a>
</li>

<li>Clojure 21: ClojureScript aneb překlad Clojure do JS<br />
<a href="http://www.root.cz/clanky/programovaci-jazyk-clojure-21-clojurescript-aneb-preklad-clojure-do-javascriptu/">http://www.root.cz/clanky/programovaci-jazyk-clojure-21-clojurescript-aneb-preklad-clojure-do-javascriptu/</a>
</li>

<li>Leiningen: nástroj pro správu projektů napsaných v Clojure<br />
<a href="http://www.root.cz/clanky/leiningen-nastroj-pro-spravu-projektu-napsanych-v-clojure/">http://www.root.cz/clanky/leiningen-nastroj-pro-spravu-projektu-napsanych-v-clojure/</a>
</li>

<li>Leiningen: nástroj pro správu projektů napsaných v Clojure (2)<br />
<a href="http://www.root.cz/clanky/leiningen-nastroj-pro-spravu-projektu-napsanych-v-clojure-2/">http://www.root.cz/clanky/leiningen-nastroj-pro-spravu-projektu-napsanych-v-clojure-2/</a>
</li>

<li>Leiningen: nástroj pro správu projektů napsaných v Clojure (3)<br />
<a href="http://www.root.cz/clanky/leiningen-nastroj-pro-spravu-projektu-napsanych-v-clojure-3/">http://www.root.cz/clanky/leiningen-nastroj-pro-spravu-projektu-napsanych-v-clojure-3/</a>
</li>

<li>Leiningen: nástroj pro správu projektů napsaných v Clojure (4)<br />
<a href="http://www.root.cz/clanky/leiningen-nastroj-pro-spravu-projektu-napsanych-v-clojure-4/">http://www.root.cz/clanky/leiningen-nastroj-pro-spravu-projektu-napsanych-v-clojure-4/</a>
</li>

<li>Leiningen: nástroj pro správu projektů napsaných v Clojure (5)<br />
<a href="http://www.root.cz/clanky/leiningen-nastroj-pro-spravu-projektu-napsanych-v-clojure-5/">http://www.root.cz/clanky/leiningen-nastroj-pro-spravu-projektu-napsanych-v-clojure-5/</a>
</li>

<li>Leiningen: nástroj pro správu projektů napsaných v Clojure (6)<br />
<a href="http://www.root.cz/clanky/leiningen-nastroj-pro-spravu-projektu-napsanych-v-clojure-6/">http://www.root.cz/clanky/leiningen-nastroj-pro-spravu-projektu-napsanych-v-clojure-6/</a>
</li>

<li>Programovací jazyk Clojure a databáze (1.část)<br />
<a href="http://www.root.cz/clanky/programovaci-jazyk-clojure-a-databaze-1-cast/">http://www.root.cz/clanky/programovaci-jazyk-clojure-a-databaze-1-cast/</a>
</li>

<li>Pluginy pro Leiningen<br />
<a href="http://www.root.cz/clanky/leiningen-nastroj-pro-spravu-projektu-napsanych-v-clojure-pluginy-pro-leiningen/">http://www.root.cz/clanky/leiningen-nastroj-pro-spravu-projektu-napsanych-v-clojure-pluginy-pro-leiningen/</a>
</li>

<li>Programovací jazyk Clojure a knihovny pro práci s vektory a maticemi<br />
<a href="http://www.root.cz/clanky/programovaci-jazyk-clojure-a-knihovny-pro-praci-s-vektory-a-maticemi/">http://www.root.cz/clanky/programovaci-jazyk-clojure-a-knihovny-pro-praci-s-vektory-a-maticemi/</a>
</li>

<li>Programovací jazyk Clojure a knihovny pro práci s vektory a maticemi (2)<br />
<a href="http://www.root.cz/clanky/programovaci-jazyk-clojure-a-knihovny-pro-praci-s-vektory-a-maticemi-2/">http://www.root.cz/clanky/programovaci-jazyk-clojure-a-knihovny-pro-praci-s-vektory-a-maticemi-2/</a>
</li>

<li>Programovací jazyk Clojure: syntéza procedurálních textur s využitím knihovny Clisk<br />
<a href="http://www.root.cz/clanky/programovaci-jazyk-clojure-synteza-proceduralnich-textur-s-vyuzitim-knihovny-clisk/">http://www.root.cz/clanky/programovaci-jazyk-clojure-synteza-proceduralnich-textur-s-vyuzitim-knihovny-clisk/</a>
</li>

<li>Programovací jazyk Clojure: syntéza procedurálních textur s využitím knihovny Clisk (2)<br />
<a href="http://www.root.cz/clanky/programovaci-jazyk-clojure-synteza-proceduralnich-textur-s-vyuzitim-knihovny-clisk-2/">http://www.root.cz/clanky/programovaci-jazyk-clojure-synteza-proceduralnich-textur-s-vyuzitim-knihovny-clisk-2/</a>
</li>

<li>Seesaw: knihovna pro snadnou tvorbu GUI v jazyce Clojure<br />
<a href="http://www.root.cz/clanky/seesaw-knihovna-pro-snadnou-tvorbu-gui-v-jazyce-clojure/">http://www.root.cz/clanky/seesaw-knihovna-pro-snadnou-tvorbu-gui-v-jazyce-clojure/</a>
</li>

<li>Seesaw: knihovna pro snadnou tvorbu GUI v jazyce Clojure (2)<br />
<a href="http://www.root.cz/clanky/seesaw-knihovna-pro-snadnou-tvorbu-gui-v-jazyce-clojure-2/">http://www.root.cz/clanky/seesaw-knihovna-pro-snadnou-tvorbu-gui-v-jazyce-clojure-2/</a>
</li>

<li>Seesaw: knihovna pro snadnou tvorbu GUI v jazyce Clojure (3)<br />
<a href="http://www.root.cz/clanky/seesaw-knihovna-pro-snadnou-tvorbu-gui-v-jazyce-clojure-3/">http://www.root.cz/clanky/seesaw-knihovna-pro-snadnou-tvorbu-gui-v-jazyce-clojure-3/</a>
</li>

<li>Programovací jazyk Clojure a práce s Gitem<br />
<a href="http://www.root.cz/clanky/programovaci-jazyk-clojure-a-prace-s-gitem/">http://www.root.cz/clanky/programovaci-jazyk-clojure-a-prace-s-gitem/</a>
</li>

<li>Programovací jazyk Clojure: syntéza procedurálních textur s využitím knihovny Clisk (dokončení)<br />
<a href="http://www.root.cz/clanky/programovaci-jazyk-clojure-synteza-proceduralnich-textur-s-vyuzitim-knihovny-clisk-dokonceni/">http://www.root.cz/clanky/programovaci-jazyk-clojure-synteza-proceduralnich-textur-s-vyuzitim-knihovny-clisk-dokonceni/</a>
</li>

<li>Programovací jazyk Clojure a práce s Gitem (2)<br />
<a href="http://www.root.cz/clanky/programovaci-jazyk-clojure-a-prace-s-gitem-2/">http://www.root.cz/clanky/programovaci-jazyk-clojure-a-prace-s-gitem-2/</a>
</li>

<li>Programovací jazyk Clojure – triky při práci s řetězci<br />
<a href="http://www.root.cz/clanky/programovaci-jazyk-clojure-triky-pri-praci-s-retezci/">http://www.root.cz/clanky/programovaci-jazyk-clojure-triky-pri-praci-s-retezci/</a>
</li>

<li>Programovací jazyk Clojure – triky při práci s kolekcemi<br />
<a href="http://www.root.cz/clanky/programovaci-jazyk-clojure-triky-pri-praci-s-kolekcemi/">http://www.root.cz/clanky/programovaci-jazyk-clojure-triky-pri-praci-s-kolekcemi/</a>
</li>

<li>Programovací jazyk Clojure – práce s mapami a množinami<br />
<a href="http://www.root.cz/clanky/programovaci-jazyk-clojure-prace-s-mapami-a-mnozinami/">http://www.root.cz/clanky/programovaci-jazyk-clojure-prace-s-mapami-a-mnozinami/</a>
</li>

<li>Programovací jazyk Clojure – základy zpracování XML<br />
<a href="http://www.root.cz/clanky/programovaci-jazyk-clojure-zaklady-zpracovani-xml/">http://www.root.cz/clanky/programovaci-jazyk-clojure-zaklady-zpracovani-xml/</a>
</li>

<li>Programovací jazyk Clojure – testování s využitím knihovny Expectations<br />
<a href="http://www.root.cz/clanky/programovaci-jazyk-clojure-testovani-s-vyuzitim-knihovny-expectations/">http://www.root.cz/clanky/programovaci-jazyk-clojure-testovani-s-vyuzitim-knihovny-expectations/</a>
</li>

<li>Programovací jazyk Clojure – některé užitečné triky použitelné (nejenom) v&nbsp;testech<br />
<a href="http://www.root.cz/clanky/programovaci-jazyk-clojure-nektere-uzitecne-triky-pouzitelne-nejenom-v-testech/">http://www.root.cz/clanky/programovaci-jazyk-clojure-nektere-uzitecne-triky-pouzitelne-nejenom-v-testech/</a>
</li>

<li>Enlive – výkonný šablonovací systém pro jazyk Clojure<br/>
<a href="http://www.root.cz/clanky/enlive-vykonny-sablonovaci-system-pro-jazyk-clojure/">http://www.root.cz/clanky/enlive-vykonny-sablonovaci-system-pro-jazyk-clojure/</a>
</li>

<li>Nástroj Leiningen a programovací jazyk Clojure: tvorba vlastních knihoven pro veřejný repositář Clojars<br />
<a href="http://www.root.cz/clanky/nastroj-leiningen-a-programovaci-jazyk-clojure-tvorba-vlastnich-knihoven-pro-verejny-repositar-clojars/">http://www.root.cz/clanky/nastroj-leiningen-a-programovaci-jazyk-clojure-tvorba-vlastnich-knihoven-pro-verejny-repositar-clojars/</a>
</li>

<li>Novinky v Clojure verze 1.8.0<br />
<a href="http://www.root.cz/clanky/novinky-v-clojure-verze-1-8-0/">http://www.root.cz/clanky/novinky-v-clojure-verze-1-8-0/</a>
</li>

<li>Asynchronní programování v&nbsp;Clojure s&nbsp;využitím knihovny core.async<br />
<a href="http://www.root.cz/clanky/asynchronni-programovani-v-clojure-s-vyuzitim-knihovny-core-async/">http://www.root.cz/clanky/asynchronni-programovani-v-clojure-s-vyuzitim-knihovny-core-async/</a>
</li>

<li>Asynchronní programování v&nbsp;Clojure s&nbsp;využitím knihovny core.async (pokračování)<br />
<a href="http://www.root.cz/clanky/asynchronni-programovani-v-clojure-s-vyuzitim-knihovny-core-async-pokracovani/">http://www.root.cz/clanky/asynchronni-programovani-v-clojure-s-vyuzitim-knihovny-core-async-pokracovani/</a>
</li>

<li>Asynchronní programování v Clojure s využitím knihovny core.async (dokončení)<br />
<a href="http://www.root.cz/clanky/asynchronni-programovani-v-clojure-s-vyuzitim-knihovny-core-async-dokonceni/">http://www.root.cz/clanky/asynchronni-programovani-v-clojure-s-vyuzitim-knihovny-core-async-dokonceni/</a>
</li>

<li>Vytváříme IRC bota v programovacím jazyce Clojure<br />
<a href="http://www.root.cz/clanky/vytvarime-irc-bota-v-programovacim-jazyce-clojure/">http://www.root.cz/clanky/vytvarime-irc-bota-v-programovacim-jazyce-clojure/</a>
</li>

<li>Gorilla REPL: interaktivní prostředí pro programovací jazyk Clojure<br />
<a href="https://www.root.cz/clanky/gorilla-repl-interaktivni-prostredi-pro-programovaci-jazyk-clojure/">https://www.root.cz/clanky/gorilla-repl-interaktivni-prostredi-pro-programovaci-jazyk-clojure/</a>
</li>

<li>Multimetody v Clojure aneb polymorfismus bez použití OOP<br />
<a href="https://www.root.cz/clanky/multimetody-v-clojure-aneb-polymorfismus-bez-pouziti-oop/">https://www.root.cz/clanky/multimetody-v-clojure-aneb-polymorfismus-bez-pouziti-oop/</a>
</li>

<li>Práce s externími Java archivy v programovacím jazyku Clojure<br />
<a href="https://www.root.cz/clanky/prace-s-externimi-java-archivy-v-programovacim-jazyku-clojure/">https://www.root.cz/clanky/prace-s-externimi-java-archivy-v-programovacim-jazyku-clojure/</a>
</li>

<li>Pixie: lehký skriptovací jazyk s „kouzelnými“ schopnostmi<br />
<a href="https://www.root.cz/clanky/pixie-lehky-skriptovaci-jazyk-s-kouzelnymi-schopnostmi/">https://www.root.cz/clanky/pixie-lehky-skriptovaci-jazyk-s-kouzelnymi-schopnostmi/</a>
</li>

<li>Programovací jazyk Pixie: funkce ze základní knihovny a použití FFI<br />
<a href="https://www.root.cz/clanky/programovaci-jazyk-pixie-funkce-ze-zakladni-knihovny-a-pouziti-ffi/">https://www.root.cz/clanky/programovaci-jazyk-pixie-funkce-ze-zakladni-knihovny-a-pouziti-ffi/</a>
</li>

<li>Novinky v Clojure verze 1.9.0<br />
<a href="https://www.root.cz/clanky/novinky-v-clojure-verze-1-9-0/">https://www.root.cz/clanky/novinky-v-clojure-verze-1-9-0/</a>
</li>

<li>Validace dat s&nbsp;využitím knihovny spec v&nbsp;Clojure 1.9.0<br />
<a href="https://www.root.cz/clanky/validace-dat-s-vyuzitim-knihovny-spec-v-clojure-1-9-0/">https://www.root.cz/clanky/validace-dat-s-vyuzitim-knihovny-spec-v-clojure-1-9-0/</a>
</li>

</ol>



<p><a name="k20"></a></p>
<h2 id="k20">20. Odkazy na Internetu</h2>

<ol>

<li>Humane test output for clojure.test<br />
<a href="https://github.com/pjstadig/humane-test-output">https://github.com/pjstadig/humane-test-output</a>
</li>

<li>iota<br />
<a href="https://github.com/juxt/iota">https://github.com/juxt/iota</a>
</li>

<li>5 Differences between clojure.spec and Schema<br />
<a href="https://lispcast.com/clojure.spec-vs-schema/">https://lispcast.com/clojure.spec-vs-schema/</a>
</li>

<li>Schema: Clojure(Script) library for declarative data description and validation<br />
<a href="https://github.com/plumatic/schema">https://github.com/plumatic/schema</a>
</li>

<li>Zip archiv s&nbsp;Clojure 1.9.0<br />
<a href="http://repo1.maven.org/maven2/org/clojure/clojure/1.9.0/clojure-1.9.0.zip">http://repo1.maven.org/maven2/org/clojure/clojure/1.9.0/clojure-1.9.0.zip</a>
</li>

<li>Clojure 1.9 is now available<br />
<a href="https://clojure.org/news/2017/12/08/clojure19">https://clojure.org/news/2017/12/08/clojure19</a>
</li>

<li>Deps and CLI Guide<br />
<a href="https://clojure.org/guides/deps_and_cli">https://clojure.org/guides/deps_and_cli</a>
</li>

<li>Changes to Clojure in Version 1.9<br />
<a href="https://github.com/clojure/clojure/blob/master/changes.md">https://github.com/clojure/clojure/blob/master/changes.md</a>
</li>

<li>clojure.spec - Rationale and Overview<br />
<a href="https://clojure.org/about/spec">https://clojure.org/about/spec</a>
</li>

<li>Zip archiv s&nbsp;Clojure 1.8.0<br />
<a href="http://repo1.maven.org/maven2/org/clojure/clojure/1.8.0/clojure-1.8.0.zip">http://repo1.maven.org/maven2/org/clojure/clojure/1.8.0/clojure-1.8.0.zip</a>
</li>

<li>Clojure 1.8 is now available<br />
<a href="http://clojure.org/news/2016/01/19/clojure18">http://clojure.org/news/2016/01/19/clojure18</a>
</li>

<li>Socket Server REPL<br />
<a href="http://dev.clojure.org/display/design/Socket+Server+REPL">http://dev.clojure.org/display/design/Socket+Server+REPL</a>
</li>

<li>CLJ-1671: Clojure socket server<br />
<a href="http://dev.clojure.org/jira/browse/CLJ-1671">http://dev.clojure.org/jira/browse/CLJ-1671</a>
</li>

<li>CLJ-1449: Add clojure.string functions for portability to ClojureScript<br />
<a href="http://dev.clojure.org/jira/browse/CLJ-1449">http://dev.clojure.org/jira/browse/CLJ-1449</a>
</li>

<li>Launching a Socket Server<br />
<a href="http://clojure.org/reference/repl_and_main#_launching_a_socket_server">http://clojure.org/reference/repl_and_main#_launching_a_socket_server</a>
</li>

<li>API for clojure.string<br />
<a href="http://clojure.github.io/clojure/branch-master/clojure.string-api.html">http://clojure.github.io/clojure/branch-master/clojure.string-api.html</a>
</li>

<li>Clojars:<br />
<a href="https://clojars.org/">https://clojars.org/</a>
</li>

<li>Seznam knihoven na Clojars:<br />
<a href="https://clojars.org/projects">https://clojars.org/projects</a>
</li>

<li>Clojure Cookbook: Templating HTML with Enlive<br />
<a href="https://github.com/clojure-cookbook/clojure-cookbook/blob/master/07_webapps/7-11_enlive.asciidoc">https://github.com/clojure-cookbook/clojure-cookbook/blob/master/07_webapps/7-11_enlive.asciidoc</a>
</li>

<li>An Introduction to Enlive<br />
<a href="https://github.com/swannodette/enlive-tutorial/">https://github.com/swannodette/enlive-tutorial/</a>
</li>

<li>Enlive na GitHubu<br />
<a href="https://github.com/cgrand/enlive">https://github.com/cgrand/enlive</a>
</li>

<li>Expectations: příklady atd.<br />
<a href="http://jayfields.com/expectations/">http://jayfields.com/expectations/</a>
</li>

<li>Expectations na GitHubu<br />
<a href="https://github.com/jaycfields/expectations">https://github.com/jaycfields/expectations</a>
</li>

<li>Lein-expectations na GitHubu<br />
<a href="https://github.com/gar3thjon3s/lein-expectations">https://github.com/gar3thjon3s/lein-expectations</a>
</li>

<li>Testing Clojure With Expectations<br />
<a href="https://semaphoreci.com/blog/2014/09/23/testing-clojure-with-expectations.html">https://semaphoreci.com/blog/2014/09/23/testing-clojure-with-expectations.html</a>
</li>

<li>Clojure testing TDD/BDD libraries: clojure.test vs Midje vs Expectations vs Speclj<br />
<a href="https://www.reddit.com/r/Clojure/comments/1viilt/clojure_testing_tddbdd_libraries_clojuretest_vs/">https://www.reddit.com/r/Clojure/comments/1viilt/clojure_testing_tddbdd_libraries_clojuretest_vs/</a>
</li>

<li>Testing: One assertion per test<br />
<a href="http://blog.jayfields.com/2007/06/testing-one-assertion-per-test.html">http://blog.jayfields.com/2007/06/testing-one-assertion-per-test.html</a>
</li>

<li>Rewriting Your Test Suite in Clojure in 24 hours<br />
<a href="http://blog.circleci.com/rewriting-your-test-suite-in-clojure-in-24-hours/">http://blog.circleci.com/rewriting-your-test-suite-in-clojure-in-24-hours/</a>
</li>

<li>Clojure doc: zipper<br />
<a href="http://clojuredocs.org/clojure.zip/zipper">http://clojuredocs.org/clojure.zip/zipper</a>
</li>

<li>Clojure doc: parse<br />
<a href="http://clojuredocs.org/clojure.xml/parse">http://clojuredocs.org/clojure.xml/parse</a>
</li>

<li>Clojure doc: xml-zip<br />
<a href="http://clojuredocs.org/clojure.zip/xml-zip">http://clojuredocs.org/clojure.zip/xml-zip</a>
</li>

<li>Clojure doc: xml-seq<br />
<a href="http://clojuredocs.org/clojure.core/xml-seq">http://clojuredocs.org/clojure.core/xml-seq</a>
</li>

<li>Parsing XML in Clojure<br />
<a href="https://github.com/clojuredocs/guides">https://github.com/clojuredocs/guides</a>
</li>

<li>Clojure Zipper Over Nested Vector<br />
<a href="https://vitalyper.wordpress.com/2010/11/23/clojure-zipper-over-nested-vector/">https://vitalyper.wordpress.com/2010/11/23/clojure-zipper-over-nested-vector/</a>
</li>

<li>Understanding Clojure's PersistentVector implementation<br />
<a href="http://blog.higher-order.net/2009/02/01/understanding-clojures-persistentvector-implementation">http://blog.higher-order.net/2009/02/01/understanding-clojures-persistentvector-implementation</a>
</li>

<li>Understanding Clojure's PersistentHashMap (deftwice...)<br />
<a href="http://blog.higher-order.net/2009/09/08/understanding-clojures-persistenthashmap-deftwice.html">http://blog.higher-order.net/2009/09/08/understanding-clojures-persistenthashmap-deftwice.html</a>
</li>

<li>Assoc and Clojure's PersistentHashMap: part ii<br />
<a href="http://blog.higher-order.net/2010/08/16/assoc-and-clojures-persistenthashmap-part-ii.html">http://blog.higher-order.net/2010/08/16/assoc-and-clojures-persistenthashmap-part-ii.html</a>
</li>

<li>Ideal Hashtrees (paper)<br />
<a href="http://lampwww.epfl.ch/papers/idealhashtrees.pdf">http://lampwww.epfl.ch/papers/idealhashtrees.pdf</a>
</li>

<li>Clojure home page<br />
<a href="http://clojure.org/">http://clojure.org/</a>
</li>

<li>Clojure (downloads)<br />
<a href="http://clojure.org/downloads">http://clojure.org/downloads</a>
</li>

<li>Clojure Sequences<br />
<a href="http://clojure.org/sequences">http://clojure.org/sequences</a>
</li>

<li>Clojure Data Structures<br />
<a href="http://clojure.org/data_structures">http://clojure.org/data_structures</a>
</li>

<li>The Structure and Interpretation of Computer Programs: 2.2.1  Representing Sequences<br />
<a href="http://mitpress.mit.edu/sicp/full-text/book/book-Z-H-15.html#%_sec_2.2.1">http://mitpress.mit.edu/sicp/full-text/book/book-Z-H-15.html#%_sec_2.2.1</a>
</li>

<li>The Structure and Interpretation of Computer Programs: 3.3.1  Mutable List Structure<br />
<a href="http://mitpress.mit.edu/sicp/full-text/book/book-Z-H-22.html#%_sec_3.3.1">http://mitpress.mit.edu/sicp/full-text/book/book-Z-H-22.html#%_sec_3.3.1</a>
</li>

<li>Clojure - Functional Programming for the JVM<br />
<a href="http://java.ociweb.com/mark/clojure/article.html">http://java.ociweb.com/mark/clojure/article.html</a>
</li>

<li>Clojure quick reference<br />
<a href="http://faustus.webatu.com/clj-quick-ref.html">http://faustus.webatu.com/clj-quick-ref.html</a>
</li>

<li>4Clojure<br />
<a href="http://www.4clojure.com/">http://www.4clojure.com/</a>
</li>

<li>ClojureDoc (rozcestník s&nbsp;dokumentací jazyka Clojure)<br />
<a href="http://clojuredocs.org/">http://clojuredocs.org/</a>
</li>

<li>Clojure (na Wikipedia EN)<br />
<a href="http://en.wikipedia.org/wiki/Clojure">http://en.wikipedia.org/wiki/Clojure</a>
</li>

<li>Clojure (na Wikipedia CS)<br />
<a href="http://cs.wikipedia.org/wiki/Clojure">http://cs.wikipedia.org/wiki/Clojure</a>
</li>

<li>SICP (The Structure and Interpretation of Computer Programs)<br />
<a href="http://mitpress.mit.edu/sicp/">http://mitpress.mit.edu/sicp/</a>
</li>

<li>Pure function<br />
<a href="http://en.wikipedia.org/wiki/Pure_function">http://en.wikipedia.org/wiki/Pure_function</a>
</li>

<li>Funkcionální programování<br />
<a href="http://cs.wikipedia.org/wiki/Funkcionální_programování">http://cs.wikipedia.org/wiki/Funkcionální_programování</a>
</li>

<li>Čistě funkcionální (datové struktury, jazyky, programování)<br />
<a href="http://cs.wikipedia.org/wiki/Čistě_funkcionální">http://cs.wikipedia.org/wiki/Čistě_funkcionální</a>
</li>

<li>Clojure Macro Tutorial (Part I, Getting the Compiler to Write Your Code For You)<br />
<a href="http://www.learningclojure.com/2010/09/clojure-macro-tutorial-part-i-getting.html">http://www.learningclojure.com/2010/09/clojure-macro-tutorial-part-i-getting.html</a>
</li>

<li>Clojure Macro Tutorial (Part II: The Compiler Strikes Back)<br />
<a href="http://www.learningclojure.com/2010/09/clojure-macro-tutorial-part-ii-compiler.html">http://www.learningclojure.com/2010/09/clojure-macro-tutorial-part-ii-compiler.html</a>
</li>

<li>Clojure Macro Tutorial (Part III: Syntax Quote)<br />
<a href="http://www.learningclojure.com/2010/09/clojure-macro-tutorial-part-ii-syntax.html">http://www.learningclojure.com/2010/09/clojure-macro-tutorial-part-ii-syntax.html</a>
</li>

<li>Tech behind Tech: Clojure Macros Simplified<br />
<a href="http://techbehindtech.com/2010/09/28/clojure-macros-simplified/">http://techbehindtech.com/2010/09/28/clojure-macros-simplified/</a>
</li>

<li>Fatvat - Exploring functional programming: Clojure Macros<br />
<a href="http://www.fatvat.co.uk/2009/02/clojure-macros.html">http://www.fatvat.co.uk/2009/02/clojure-macros.html</a>
</li>

<li>Eulerovo číslo<br />
<a href="http://cs.wikipedia.org/wiki/Eulerovo_číslo">http://cs.wikipedia.org/wiki/Eulerovo_číslo</a>
</li>

<li>List comprehension<br />
<a href="http://en.wikipedia.org/wiki/List_comprehension">http://en.wikipedia.org/wiki/List_comprehension</a>
</li>

<li>List Comprehensions in Clojure<br />
<a href="http://asymmetrical-view.com/2008/11/18/list-comprehensions-in-clojure.html">http://asymmetrical-view.com/2008/11/18/list-comprehensions-in-clojure.html</a>
</li>

<li>Clojure Programming Concepts: List Comprehension<br />
<a href="http://en.wikibooks.org/wiki/Clojure_Programming/Concepts#List_Comprehension">http://en.wikibooks.org/wiki/Clojure_Programming/Concepts#List_Comprehension</a>
</li>

<li>Clojure core API: for macro<br />
<a href="http://clojure.github.com/clojure/clojure.core-api.html#clojure.core/for">http://clojure.github.com/clojure/clojure.core-api.html#clojure.core/for</a>
</li>

<li>cirrus machina - The Clojure for macro<br />
<a href="http://www.cirrusmachina.com/blog/comment/the-clojure-for-macro/">http://www.cirrusmachina.com/blog/comment/the-clojure-for-macro/</a>
</li>

<li>Riastradh's Lisp Style Rules<br />
<a href="http://mumble.net/~campbell/scheme/style.txt">http://mumble.net/~campbell/scheme/style.txt</a>
</li>

<li>Dynamic Languages Strike Back<br />
<a href="http://steve-yegge.blogspot.cz/2008/05/dynamic-languages-strike-back.html">http://steve-yegge.blogspot.cz/2008/05/dynamic-languages-strike-back.html</a>
</li>

<li>Scripting: Higher Level Programming for the 21st Century<br />
<a href="http://www.tcl.tk/doc/scripting.html">http://www.tcl.tk/doc/scripting.html</a>
</li>

<li>Java Virtual Machine Support for Non-Java Languages<br />
<a href="http://docs.oracle.com/javase/7/docs/technotes/guides/vm/multiple-language-support.html">http://docs.oracle.com/javase/7/docs/technotes/guides/vm/multiple-language-support.html</a>
</li>

<li>Třída java.lang.String<br />
<a href="http://docs.oracle.com/javase/7/docs/api/java/lang/String.html">http://docs.oracle.com/javase/7/docs/api/java/lang/String.html</a>
</li>

<li>Třída java.lang.StringBuffer<br />
<a href="http://docs.oracle.com/javase/7/docs/api/java/lang/StringBuffer.html">http://docs.oracle.com/javase/7/docs/api/java/lang/StringBuffer.html</a>
</li>

<li>Třída java.lang.StringBuilder<br />
<a href="http://docs.oracle.com/javase/7/docs/api/java/lang/StringBuilder.html">http://docs.oracle.com/javase/7/docs/api/java/lang/StringBuilder.html</a>
</li>

<li>StringBuffer versus String<br />
<a href="http://www.javaworld.com/article/2076072/build-ci-sdlc/stringbuffer-versus-string.html">http://www.javaworld.com/article/2076072/build-ci-sdlc/stringbuffer-versus-string.html</a>
</li>

<li>Threading macro (dokumentace k&nbsp;jazyku Clojure)<br />
<a href="https://clojure.github.io/clojure/clojure.core-api.html#clojure.core/-&gt;">https://clojure.github.io/clojure/clojure.core-api.html#clojure.core/-&gt;</a>
</li>

<li>Understanding the Clojure -&gt; macro<br />
<a href="http://blog.fogus.me/2009/09/04/understanding-the-clojure-macro/">http://blog.fogus.me/2009/09/04/understanding-the-clojure-macro/</a>
</li>

<li>clojure.inspector<br />
<a href="http://clojure.github.io/clojure/clojure.inspector-api.html">http://clojure.github.io/clojure/clojure.inspector-api.html</a>
</li>

<li>The Clojure Toolbox<br />
<a href="http://www.clojure-toolbox.com/">http://www.clojure-toolbox.com/</a>
</li>

<li>Unit Testing in Clojure<br />
<a href="http://nakkaya.com/2009/11/18/unit-testing-in-clojure/">http://nakkaya.com/2009/11/18/unit-testing-in-clojure/</a>
</li>

<li>Testing in Clojure (Part-1: Unit testing)<br />
<a href="http://blog.knoldus.com/2014/03/22/testing-in-clojure-part-1-unit-testing/">http://blog.knoldus.com/2014/03/22/testing-in-clojure-part-1-unit-testing/</a>
</li>

<li>API for clojure.test - Clojure v1.6 (stable)<br />
<a href="https://clojure.github.io/clojure/clojure.test-api.html">https://clojure.github.io/clojure/clojure.test-api.html</a>
</li>

<li>Leiningen: úvodní stránka<br />
<a href="http://leiningen.org/">http://leiningen.org/</a>
</li>

<li>Leiningen: Git repository<br />
<a href="https://github.com/technomancy/leiningen">https://github.com/technomancy/leiningen</a>
</li>

<li>leiningen-win-installer<br />
<a href="http://leiningen-win-installer.djpowell.net/">http://leiningen-win-installer.djpowell.net/</a>
</li>

<li>Clojure.org: Vars and the Global Environment<br />
<a href="http://clojure.org/Vars">http://clojure.org/Vars</a>
</li>

<li>Clojure.org: Refs and Transactions<br />
<a href="http://clojure.org/Refs">http://clojure.org/Refs</a>
</li>

<li>Clojure.org: Atoms<br />
<a href="http://clojure.org/Atoms">http://clojure.org/Atoms</a>
</li>

<li>Clojure.org: Agents as Asynchronous Actions<br />
<a href="http://clojure.org/agents">http://clojure.org/agents</a>
</li>

<li>Transient Data Structures
<a href="http://clojure.org/transients">http://clojure.org/transients</a>
</li>

</ol>



<p></p><p></p>
<p><small>Autor: <a href="http://www.fit.vutbr.cz/~tisnovpa">Pavel Tišnovský</a> &nbsp; 2018</small></p>
</body>
</html>

