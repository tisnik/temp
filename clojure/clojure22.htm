<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
        "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html>
<head>
<title>Programovací jazyk Clojure - práce s mapami a množinami</title>
<meta name="Author" content="Pavel Tisnovsky" />
<meta name="Generator" content="vim" />
<meta http-equiv="content-type" content="text/html; charset=utf-8" />
<style type="text/css">
         body {color:#000000; background:#ffffff;}
         h1  {font-family: arial, helvetica, sans-serif; color:#ffffff; background-color:#c00000; text-align:center; padding-left:1em}
         h2  {font-family: arial, helvetica, sans-serif; color:#ffffff; background-color:#0000c0; padding-left:1em; text-align:left}
         h3  {font-family: arial, helvetica, sans-serif; color:#000000; background-color:#c0c0c0; padding-left:1em; text-align:left}
         h4  {font-family: arial, helvetica, sans-serif; color:#000000; background-color:#e0e0e0; padding-left:1em; text-align:left}
         a   {font-family: arial, helvetica, sans-serif;}
         li  {font-family: arial, helvetica, sans-serif; color:#000000; text-align:justify; width:450px;}
         ol  {font-family: arial, helvetica, sans-serif; color:#000000; text-align:justify; width:450px;}
         ul  {font-family: arial, helvetica, sans-serif; color:#000000; text-align:justify; width:450px;}
         p   {font-family: arial, helvetica, sans-serif; color:#000000; text-align:justify;}
         pre {background:#e0e0e0}
</style>
</head>

<body>

<h1>Programovací jazyk Clojure - práce s mapami a množinami</h1>

<h3>Pavel Tišnovský</h3>

<p></p>

<h1>Úvodník</h1>

<p>Po vysvětlení principu práce se sekvencemi, seznamy a vektory v&nbsp;programovacím jazyku Clojure nám zbývá popis zbylých dvou strukturovaných datových typů. Jedná se o velmi důležité mapy (maps), které mají v&nbsp;Clojure hned několik využití (i implementací), a dále pak o množiny (sets).</p>



<h2>Obsah</h2>

<p><a href="#k01">1. Programovací jazyk Clojure - práce s mapami a množinami</a></p>
<p><a href="#k02">2. Typy map v&nbsp;Clojure</a></p>
<p><a href="#k03">3. Implementace <strong>clojure.lang.PersistentHashMap</strong></a></p>
<p><a href="#k04">4. INode</a></p>
<p><a href="#k05">5. ArrayNode a BitmapIndexedNode</a></p>
<p><a href="#k06">6. Operace s&nbsp;mapami: <strong>assoc</strong> a <strong>dissoc</strong></a></p>
<p><a href="#k07">7. Vyhledávání prvků, získání klíčů a hodnot</a></p>
<p><a href="#k08">8. Operace <strong>merge</strong> a <strong>zipmap</strong></a></p>
<p><a href="#k09">9. Práce s&nbsp;množinami v&nbsp;jazyce Clojure</a></p>
<p><a href="#k10">10. Množinové operace</a></p>
<p><a href="#k11">11. Odkazy na předchozí části tohoto seriálu</a></p>
<p><a href="#k12">12. Odkazy na Internetu</a></p>



<p><a name="k01"></a></p>
<h2 id="k01">1. Programovací jazyk Clojure - práce s mapami a množinami</h2>

<p><a
href="http://www.root.cz/clanky/programovaci-jazyk-clojure-triky-pri-praci-s-kolekcemi/">Ve
dvacáté první</a> části <a href="#k11">seriálu</a> o programovacím jazyku
Clojure i o knihovnách, které jsou pro tento jazyk dostupné jsme se zaměřili na
popis práce se seznamy a vektory. Jedná se o základní strukturované datové
typy, které jsou v&nbsp;Clojure používané ve všech programech. Díky <a
href="https://cs.wikipedia.org/wiki/Homoikonicita">homoikonicitě</a> se navíc
seznamy a vektory používají i přímo pro zápis algoritmů &ndash; každá definice,
funkce či makro je reprezentováno stromem sestrojeným z&nbsp;vnořených seznamů
a vektorů (vektory jsou použity například pro deklaraci parametrů, najdeme je
ve speciální formě <strong>let</strong>, v&nbsp;makru <strong>for</strong>
atd.). Ostatně právě tato vlastnost jazyka Clojure se &ndash; stejně jako u
LISPu &ndash; velmi často využívá při tvorbě maker, protože se stromovou
reprezentací funkce je možné poměrně snadným způsobem manipulovat.</p>

<p>Nesmíme však zapomenout ani na zbylé dva strukturované datové typy. Jedná se
o mapy (<i>maps</i>) a množiny (<i>sets</i>). Především mapy jsou velmi
důležité v&nbsp;mnoha aplikacích naprogramovaných v&nbsp;Clojure, neboť se
s&nbsp;jejich využitím mohou vytvářet struktury/záznamy
(<i>structs/records</i>), hodnotové objekty atd. Mapy se velmi často používají
pro předávání pojmenovaných parametrů do volaných funkcí či maker atd. Navíc
jsou mapy zajímavé i z&nbsp;toho hlediska jejich implementace.</p>



<p><a name="k02"></a></p>
<h2 id="k02">2. Typy map v&nbsp;Clojure</h2>

<p>Nejprve se budeme zabývat mapami. Ty existují ve dvou variantách, jejichž
základní vlastnosti shrnuje tabulka zobrazená pod tímto odstavcem:</p>

<table>
<tr><th>#</th><th>Vlastnost</th><th>Hash map</th><th>Sorted map</th></tr>
<tr><td>1</td><td>konstruktor</td><td>(hash-map ...)</td><td>(sorted-map ...)</td></tr>
<tr><td>2</td><td>&bdquo;literál&ldquo;</td><td>{klíč hodnota klíč hodnota...}</td><td>&times;</td></tr>
<tr><td>2</td><td>složitost přístupu k&nbsp;prvkům</td><td>O(log<sub>32</sub>N)</td><td>O(N)</td></tr>
<tr><td>3</td><td>složitost <strong>(count)</strong></td><td>O(1)</td><td>O(1)</td></tr>
<tr><td>4</td><td>setříděné prvky</td><td>ne</td><td>ano</td></tr>
<tr><td>5</td><td>podpora <strong>(seq)</strong></td><td>ano</td><td>ano</td></tr>
<tr><td>6</td><td>podpora <strong>(rseq)</strong></td><td>ne</td><td>ano</td></tr>
<tr><td>6</td><td>klíče <strong>nil</strong></td><td>ano</td><td>ano</td></tr>
<tr><td>7</td><td>hodnoty <strong>nil</strong></td><td>ano</td><td>ano</td></tr>
</table>



<p><a name="k03"></a></p>
<h2 id="k03">3. Implementace <strong>clojure.lang.PersistentHashMap</strong></h2>

<p>Hash mapy se v&nbsp;praxi používají (minimálně v&nbsp;případě programovacího
jazyka Clojure) mnohem častěji než mapy, v&nbsp;nichž jsou prvky setříděny na
základě hodnoty svého klíče. Proto si podrobněji popíšeme interní strukturu
hash mapy. Jedná se o neměnitelnou (<i>immutable</i>) a perzistentní
(<i>persistent</i>) datovou strukturu, což znamená, že do jednou vytvořené mapy
již nelze přidávat další prvky (dvojice klíč-hodnota) ani žádné prvky ubírat.
Na druhou stranu však mapy mohou sdílet svoji interní strukturu, takže přidání
nového prvku lze efektivně zařídit vytvořením nové mapy s&nbsp;přidaným prvkem
(což zajišťuje funkce nazvaná <strong>assoc</strong>, kterou si popíšeme níže).
Hash mapy jsou interně uloženy podobným způsobem, jako minule popsané vektory,
tj.&nbsp;s&nbsp;využitím stromu, jehož každý uzel může obsahovat až 32 odkazů
na další poduzly. Takové stromy jsou typicky velmi nízké a tím pádem je i
jejich prohledání rychlé &ndash; složitost je O(log<sub>32</sub>N),
tj.&nbsp;&bdquo;prakticky konstantní&ldquo;.</p>



<p><a name="k04"></a></p>
<h2 id="k04">4. INode</h2>

<p>Interně je hash mapa tvořena stromem obsahujícím jako své uzly objekty
objekty s&nbsp;rozhraním <i>INode</i> (tj.&nbsp;jedná se o instance tříd
implementujících toto rozhraní). Samotná struktura <i>INode</i> se postupně
vyvíjí a mění. V&nbsp;současné verzi jazyka Clojure (1.6.0) vypadá
následovně:</p>

<pre>
static interface INode extends Serializable {
        INode assoc(int shift, int hash, Object key, Object val, Box addedLeaf);
        INode without(int shift, int hash, Object key);
        IMapEntry find(int shift, int hash, Object key);
        Object find(int shift, int hash, Object key, Object notFound);
        ISeq nodeSeq();
        INode assoc(AtomicReference&lt;Thread&gt; edit, int shift, int hash, Object key, Object val, Box addedLeaf);
        INode without(AtomicReference&lt;Thread&gt; edit, int shift, int hash, Object key, Box removedLeaf);
        public Object kvreduce(IFn f, Object init);
        Object fold(IFn combinef, IFn reducef, IFn fjtask, IFn fjfork, IFn fjjoin);
        Iterator iterator(IFn f);
}
</pre>

<p>V&nbsp;minulosti existovalo pět tříd implementujících rozhraní <i>INode</i>,
v&nbsp;moderním Clojure jsou to již jen tři třídy: <i>ArrayNode</i>,
<i>BitmapIndexedNode</i> a <i>HashCollisionNode</i>.</p>



<p><a name="k05"></a></p>
<h2 id="k05">5. ArrayNode a BitmapIndexedNode</h2>

<p>Třída <i>ArrayNode</i> interně obsahuje pole <i>INodu</i> a hodnotu
obsahující počet aktivních prvků v&nbsp;poli. Důležité je, že zde není uložen
přímo klíč a hodnota prvku, jen reference na INode popř.&nbsp;hodnota
<strong>null</strong>. Operace <strong>assoc</strong> (přidání prvku se
strukturálním sdílením) znamená buď pouhé přidání nového prvku nebo klonování
pole s&nbsp;následným přidáním (klonují se ovšem pouze reference).</p>

<p>Mnohem zajímavější je třída <i>BitmapIndexedMode</i>. Zde je interně použito
pole <i>Object[]</i> o kapacitě 32 prvků. Význam jednotlivých položek se může
měnit. Sudé prvky obsahují buď hodnotu <strong>null</strong> nebo klíč, liché
prvky buď hodnotu (navázanou na klíč) nebo referenci na další <i>INode</i> (což
je rekurzivně opět <i>ArrayNode</i> či <i>BitmapIndexedMode</i>):</p>

<ol>
<li>Když pole[2*i]==null pak pole[2*i+1] je <i>INode</i></li>
<li>Když pole[2*i]!=null pak pole[2*i] je klíč a pole[2*i+1] je hodnota</li>
</ol>

<p>To znamená, že zmíněné 32prvkové pole může maximálně obsahovat 16 prvků
klíč+hodnota, 32 odkazů na poduzly typu <i>INode</i> nebo mix obou typů
záznamů.</p>

<p>Ve skutečnosti se pracuje s&nbsp;klíčem nepřímo přes jeho hash kód zjištěný
funkcí <strong>hash</strong> (jde o 32bitovou hodnotu).</p>



<p><a name="k06"></a></p>
<h2 id="k06">6. Operace s&nbsp;mapami: <strong>assoc</strong> a <strong>dissoc</strong></h2>

<p>Mezi dvě základní operace, které je možné provádět s&nbsp;mapami, patří
operace reprezentované funkcemi nazvanými <strong>assoc</strong> a
<strong>dissoc</strong>. První z&nbsp;těchto funkcí přidá k&nbsp;již existující
mapě novou dvojici klíč-hodnota (či několik dvojic klíč-hodnota) a vrátí novou
mapu rozšířenou o tyto prvky (mapy jsou totiž neměnné datové typy, podobně jako
seznamy a vektory). Druhá funkce &ndash; <strong>dissoc</strong> &ndash; plní
opačnou roli, protože z&nbsp;nějaké mapy odstraní dvojici/e klíč-hodnota pro
zadaný klíč či několik klíčů (jediným voláním <strong>dissoc</strong> je tedy
možné odstranit více prvků). I tato funkce nemění původní mapu, ale vrací
namísto toho novou datovou strukturu, která ovšem s&nbsp;původní mapou většinu
prvků sdílí. Ukažme si chování obou zmíněných funkcí <strong>assoc</strong> a
<strong>dissoc</strong> na jednoduchém příkladu:</p>

<p>Nejprve vytvoříme mapu, jejímiž klíči jsou symboly a hodnotami řetězce
(zejména použití symbolů pro klíče je v&nbsp;Clojure idiomatické):</p>

<pre>
user=&gt; <strong>(def client {:id 42</strong>
  #_=&gt;              <strong>:name "Sheldon"</strong>
  #_=&gt;              <strong>:surname "Cooper"</strong>
  #_=&gt;              <strong>:real-name "Jim Parsons"})</strong>
#'user/client
</pre>

<p>Zobrazíme obsah této mapy (povšimněte si, že prvky jsou zobrazeny náhodně,
protože se jedná o hashmapu:</p>

<pre>
user=&gt; <strong>client</strong>
{:name "Sheldon", :surname "Cooper", :id 42, :real-name "Jim Parsons"}
</pre>

<p>Funkcí <strong>assoc</strong> vytvoříme novou mapu, do níž bude přidán další
prvek:</p>

<pre>
user=&gt; <strong>(assoc client :iq 187)</strong>
{:name "Sheldon", :surname "Cooper", :iq 187, :id 42, :real-name "Jim Parsons"}
</pre>

<p>Původní mapa zůstala nezměněna:</p>

<pre>
user=&gt; <strong>client</strong>
{:name "Sheldon", :surname "Cooper", :id 42, :real-name "Jim Parsons"}
</pre>

<p>Funkcí <strong>dissoc</strong> vytvoříme mapu s&nbsp;odstraněným jedním
prvkem či dvěma prvky:</p>

<pre>
user=&gt; <strong>(dissoc client :surname)</strong>
{:name "Sheldon", :id 42, :real-name "Jim Parsons"}
&nbsp;
user=&gt; <strong>(dissoc client :name :surname)</strong>
{:id 42, :real-name "Jim Parsons"}
</pre>

<p>Opět se můžeme přesvědčit o tom, že původní mapa zůstala nezměněna:</p>

<pre>
user=&gt; <strong>client</strong>
{:name "Sheldon", :surname "Cooper", :id 42, :real-name "Jim Parsons"}
</pre>

<p>Poznámka: minule jsme se seznámili s&nbsp;takzvanými dočasnými
(tranzientními) datovými typy. I pro mapy existuje tranzientní ekvivalent, pro
nějž jsou definovány funkce <strong>assoc!</strong> a <strong>dissoc!</strong>
(s&nbsp;vykřičníkem na konci). Výsledné hodnoty těchto funkcí jsou opět
tranzientními mapami, které je možné v&nbsp;případě potřeby navázat na symbol
původní tranzientní mapy.</p>



<p><a name="k07"></a></p>
<h2 id="k07">7. Vyhledávání prvků, získání klíčů a hodnot</h2>

<p>Mezi další důležité operace, které se s&nbsp;mapami většinou provádí, patří
zjištění, zda mapa obsahuje prvek (tj.&nbsp;klíč-hodnota). Pro tento účel nám
Clojure nabízí hned několik funkcí. Opět si tyto funkce nejlépe odzkoušíme na
jednoduchých příkladech.</p>

<p>Funkce budou otestovány na mapě, jejímiž klíči jsou římské číslice a
hodnotami odpovídající číslice arabské:</p>

<pre>
user=&gt; <strong>(def numbers {"I" 1 "II" 2 "III" 3 "IV" 4 "V" 5})</strong>
#'user/numbers
</pre>

<p>Zobrazíme obsah této mapy (povšimněte si, že prvky jsou zobrazeny náhodně,
protože se jedná o hashmapu:</p>

<pre>
user=&gt; <strong>(println numbers)</strong>
{III 3, II 2, V 5, I 1, IV 4}
nil
</pre>

<p>První funkcí je predikát <strong>contains?</strong>, kde otazník naznačuje,
že se vždy vrací pravdivostní hodnota <strong>true</strong> či
<strong>false</strong> v&nbsp;závislosti na tom, zda v&nbsp;mapě existuje prvek
s&nbsp;daným klíčem:</p>

<pre>
user=&gt; <strong>(contains? numbers "I")</strong>
true
&nbsp;
user=&gt; <strong>(contains? numbers 1)</strong>
false
&nbsp;
user=&gt; <strong>(contains? numbers "xyzzy")</strong>
false
</pre>

<p>Druhá důležitá funkce je <strong>get</strong>, která vrací hodnotu navázanou
na zadaný klíč popř.&nbsp;<strong>nil</strong>, pokud klíč nebyl nalezen. Pokud
se do mapy ukládají i hodnoty <strong>nil</strong>, nezbývá většinou nic
jiného, než kombinace <strong>get+contains?</strong>:</p>

<pre>
user=&gt; <strong>(get numbers "V")</strong>
5
&nbsp;
user=&gt; <strong>(get numbers "xyzzy")</strong>
nil
</pre>

<p>Funkce <strong>find</strong> je podobná funkci <strong>get</strong>, ale
namísto hodnoty navázané na klíč vrací dvojici klíč+hodnota:</p>

<pre>
user=&gt; <strong>(find numbers "V")</strong>
["V" 5]
&nbsp;
user=&gt; <strong>(find numbers "xyzzy")</strong>
nil
&nbsp;
user=&gt; <strong>(type (find numbers "V"))</strong>
clojure.lang.MapEntry
</pre>

<p>Získat je možné všechny klíče, všechny hodnoty či provést selekci na základě
sekvence klíčů:</p>

<pre>
user=&gt; <strong>(keys numbers)</strong>
("III" "II" "V" "I" "IV")
&nbsp;
user=&gt; <strong>(vals numbers)</strong>
(3 2 5 1 4)
&nbsp;
user=&gt; <strong>(select-keys numbers ["I" "IV" "V"])</strong>
{"V" 5, "IV" 4, "I" 1}
&nbsp;
user=&gt; <strong>(select-keys numbers ["I" "IV" "neznamy"])</strong>
{"IV" 4, "I" 1}
</pre>

<p>Výběr jednoho prvku je možné provést i tím, že se zapíše volání
<strong>(klíč mapa)</strong>, což je v&nbsp;Clojure idiomatické:</p>

<pre>
user=&gt; <strong>(def numbers1 {:I 1 :II 2 :III 3 :IV 4 :V 5 :VI 6})</strong>
#'user/numbers1
&nbsp;
user=&gt; <strong>(:III numbers1)</strong>
3
</pre>

<p>Podívejme se na praktičtější příklad používající mapu namísto
struktury/záznamu a dvojí způsob získání jedné hodnoty na základě klíče:</p>

<pre>
user=&gt; <strong>(def client {:id 42</strong>
  #_=&gt;              <strong>:name "Sheldon"</strong>
  #_=&gt;              <strong>:surname "Cooper"</strong>
  #_=&gt;              <strong>:real-name "Jim Parsons"})</strong>
#'user/client
&nbsp;
user=&gt; <strong>client</strong>
{:name "Sheldon", :surname "Cooper", :id 42, :real-name "Jim Parsons"}
&nbsp;
user=&gt; <strong>(get client :name)</strong>
"Sheldon"
&nbsp;
user=&gt; <strong>(:name client)</strong>
"Sheldon"
</pre>



<p><a name="k08"></a></p>
<h2 id="k08">8. Operace <strong>merge</strong> a <strong>zipmap</strong></h2>

<p>Posledními dvěma důležitými operacemi, s&nbsp;nimiž se lze v&nbsp;reálných
aplikacích velmi často setkat, jsou operace reprezentované funkcemi
<strong>merge</strong> a <strong>zipmap</strong>. Funkce nazvaná
<strong>merge</strong> slouží ke spojení dvou či většího množství map. Nejprve
opět použijeme známou strukturu obsahující základní informace o Sheldonovi:</p>

<pre>
user=&gt; <strong>(def client {:id 42</strong>
  #_=&gt;              <strong>:name "Sheldon"</strong>
  #_=&gt;              <strong>:surname "Cooper"</strong>
  #_=&gt;              <strong>:real-name "Jim Parsons"})</strong>
#'user/client
&nbsp;
user=&gt; <strong>client</strong>
{:name "Sheldon", :surname "Cooper", :id 42, :real-name "Jim Parsons"}
</pre>

<p>Nyní zavoláme funkci <strong>merge</strong>, jejímž výsledkem bude nová
mapa:</p>

<pre>
user=&gt; <strong>(merge client {:iq 187 :degrees ["Ph.D." "Sc.D."]})</strong>
{:name "Sheldon", :surname "Cooper", :iq 187, :id 42, :degrees ["Ph.D." "Sc.D."], :real-name "Jim Parsons"}
</pre>

<p>Původní mapa zůstala nezměněna:</p>

<pre>
user=&gt; <strong>client</strong>
{:name "Sheldon", :surname "Cooper", :id 42, :real-name "Jim Parsons"}
</pre>

<p>Lépe bude vidět význam funkce <strong>merge</strong> u map se shodnými
klíči. Při spojování v&nbsp;takovém případě &bdquo;vyhraje&ldquo; hodnota
uložená v&nbsp;poslední mapě vstupující do <strong>merge</strong>:</p>

<pre>
user=&gt; <strong>(def numbers1 {"I" 1 "II" 2 "III" 3 "IV" 4 "V" 5 "VI" 6})</strong>
#'user/numbers1
&nbsp;
user=&gt; <strong>(def numbers2 {"VI" "sest" "VII" 7 "VIII" 8 "IX" 9 "X" 9})</strong>
#'user/numbers2
&nbsp;
user=&gt; <strong>(merge numbers1 numbers2)</strong>
{"III" 3, "VIII" 8, "II" 2, "V" 5, "VII" 7, "X" 9, "VI" "sest", "IX" 9, "I" 1, "IV" 4}
</pre>

<p>Ovšem:</p>

<pre>
user=&gt; <strong>(merge numbers2 numbers1)</strong>
{"III" 3, "VIII" 8, "II" 2, "V" 5, "VII" 7, "X" 9, "VI" 6, "IX" 9, "I" 1, "IV" 4}
</pre>

<p>Velmi užitečná je v&nbsp;praxi funkce nazvaná <strong>zipmap</strong>, která
umožňuje zkombinovat dvě sekvence do jediné mapy. První sekvence obsahuje
klíče, druhá sekvence hodnoty. Můžeme tedy psát například:</p>

<pre>
user=&gt; <strong>(zipmap ["I" "II" "III" "IV" "V" "VI"]</strong>
  #_=&gt;         <strong>[1 2 3 4 5 6])</strong>
{"VI" 6, "V" 5, "IV" 4, "III" 3, "II" 2, "I" 1}
</pre>

<p>Pravověrný Clojure programátor by ovšem napsal (se stejným výsledkem):</p>

<pre>
user=&gt; <strong>(zipmap ["I" "II" "III" "IV" "V" "VI"]</strong>
  #_=&gt;         <strong>(range 1 7))</strong>
{"VI" 6, "V" 5, "IV" 4, "III" 3, "II" 2, "I" 1}
</pre>

<p>Pozor ovšem na to, že <strong>zipmap</strong> nejde jednoduše použít
s&nbsp;nekonečnými lazy sekvencemi. Toto není dobrý nápad:</p>

<pre>
(zipmap (range) (repeat 42))
</pre>

<p>(Stačí ovšem, aby první sekvence byla konečná).</p>



<p><a name="k09"></a></p>
<h2 id="k09">9. Práce s&nbsp;množinami v&nbsp;jazyce Clojure</h2>

<p>Poslední důležitou datovou strukturou, se kterou se dříve či později musí
seznámit jakýkoli programátor používající jazyk Clojure, jsou množiny
(<i>sets</i>), které jsou charakteristické tím, že každý prvek obsahují
maximálně jednou (na rozdíl od seznamů a vektorů). Podobně jako mapy, i množiny
existují ve dvou podobách: s&nbsp;nesetříděnými prvky (hash set) a setříděnými
prvky (sorted set). Pro vytvoření prvního typu množiny je možné použít buď
&bdquo;literál&ldquo; s&nbsp;formou zápisu #{prvek1 prvek2 prvek3} nebo
funkci-konstruktor nazvanou <strong>hash-set</strong>. Pro vytvoření druhého
prvku množiny se používá výhradně konstruktoru představovaného funkcí
<strong>sorted-set</strong>. Nejdůležitějšími množinovými operacemi je
sjednocení, průnik, rozdíl (viz též další kapitolu) a test, zda je jedna
množina podmnožinou či nadmnožinou jiné množiny. V&nbsp;Clojure je ovšem
množiny možné využít podobně jako další typy sekvencí:</p>

<pre>
user=&gt; <strong>(def colors #{:red :green :blue :yellow :magenta :cyan})</strong>
#'user/colors
&nbsp;
user=&gt; <strong>(count colors)</strong>
6
&nbsp;
user=&gt; <strong>(:red colors)</strong>
:red
&nbsp;
user=&gt; <strong>(:xxx colors)</strong>
nil
&nbsp;
user=&gt; <strong>(get colors :red)</strong>
:red
&nbsp;
user=&gt; <strong>(get colors :xxx)</strong>
nil
&nbsp;
user=&gt; <strong>(contains? colors :red)</strong>
true
&nbsp;
user=&gt; <strong>(contains? colors :xxx)</strong>
false
</pre>

<p>Fungovat bude i přiřazení kódu (indexu) každé barvě:</p>

<pre>
user=&gt; <strong>(zipmap (range) colors)</strong>
{5 :magenta, 4 :blue, 3 :red, 2 :cyan, 1 :green, 0 :yellow}
</pre>



<p><a name="k10"></a></p>
<h2 id="k10">10. Množinové operace</h2>

<p>Podívejme se nyní na vybrané operace (funkce), které je možné aplikovat na
množiny. Nejprve vytvoříme trojici množin, z&nbsp;nichž první reprezentuje
množinu s&nbsp;prvky černá a bílá, druhá množina obsahuje prvky červená,
zelená, modrá a třetí množina obsahuje prvky azurová, fialová, modrá:</p>

<pre>
user=&gt; <strong>(def bw #{:white :black})</strong>
#'user/bw
&nbsp;
user=&gt; <strong>(def rgb #{:red :green :blue})</strong>
#'user/rgb
&nbsp;
user=&gt; <strong>(def cmy #{:cyan :magenta :yellow})</strong>
#'user/cmy
</pre>

<p>Obsah všech tří množin si vypíšeme:</p>

<pre>
user=&gt; <strong>bw</strong>
#{:white :black}
&nbsp;
user=&gt; <strong>rgb</strong>
#{:green :red :blue}
&nbsp;
user=&gt; <strong>cmy</strong>
#{:yellow :cyan :magenta}
</pre>

<p>S&nbsp;využitím operace <strong>union</strong> vytvoříme dvě nové množiny
nazvané &bdquo;cmyk&ldquo; a &bdquo;palette&ldquo;. První z&nbsp;těchto množin
bude obsahovat prvky azurová, fialová, modrá, druhá množina pak všech osm prvků
představujících základní barvy ZX Spectra či textových režimů PC:</p>

<pre>
user=&gt; <strong>(def cmyk (clojure.set/union cmy #{:black}))</strong>
#'user/cmyk
&nbsp;
user=&gt; <strong>cmyk</strong>
#{:yellow :cyan :magenta :black}
&nbsp;
user=&gt; <strong>(def palette (clojure.set/union bw cmy rgb))</strong>
#'user/palette
&nbsp;
user=&gt; <strong>palette</strong>
#{:white :yellow :green :cyan :red :blue :magenta :black}
</pre>

<p>Komu se nechce počet barev palety počítat, může použít:</p>

<pre>
user=&gt; <strong>(count palette)</strong>
8
</pre>

<p>Nyní otestujeme operaci <strong>intersection</strong> (průnik):</p>

<pre>
user=&gt; <strong>(clojure.set/intersection cmyk rgb)</strong>
#{}
&nbsp;
user=&gt; <strong>(clojure.set/intersection cmyk bw)</strong>
#{:black}
</pre>

<p>Na závěr zjistíme, zda je některá množina podmnožinou či nadmnožinou jiné množiny:</p>

<pre>
user=&gt; <strong>(clojure.set/subset? rgb palette)</strong>
true
&nbsp;
user=&gt; <strong>(clojure.set/subset? rgb cmyk)</strong>
false
&nbsp;
user=&gt; <strong>(clojure.set/subset? cmy cmyk)</strong>
true
&nbsp;
user=&gt; <strong>(clojure.set/superset? cmy cmyk)</strong>
false
&nbsp;
user=&gt; <strong>(clojure.set/superset? cmyk cmy)</strong>
true
</pre>



<p><a name="k11"></a></p>
<h2 id="k11">11. Odkazy na předchozí části tohoto seriálu</h2>

<ol>

<li>Leiningen: nástroj pro správu projektů napsaných v Clojure<br />
<a href="http://www.root.cz/clanky/leiningen-nastroj-pro-spravu-projektu-napsanych-v-clojure/">http://www.root.cz/clanky/leiningen-nastroj-pro-spravu-projektu-napsanych-v-clojure/</a>
</li>

<li>Leiningen: nástroj pro správu projektů napsaných v Clojure (2)<br />
<a href="http://www.root.cz/clanky/leiningen-nastroj-pro-spravu-projektu-napsanych-v-clojure-2/">http://www.root.cz/clanky/leiningen-nastroj-pro-spravu-projektu-napsanych-v-clojure-2/</a>
</li>

<li>Leiningen: nástroj pro správu projektů napsaných v Clojure (3)<br />
<a href="http://www.root.cz/clanky/leiningen-nastroj-pro-spravu-projektu-napsanych-v-clojure-3/">http://www.root.cz/clanky/leiningen-nastroj-pro-spravu-projektu-napsanych-v-clojure-3/</a>
</li>

<li>Leiningen: nástroj pro správu projektů napsaných v Clojure (4)<br />
<a href="http://www.root.cz/clanky/leiningen-nastroj-pro-spravu-projektu-napsanych-v-clojure-4/">http://www.root.cz/clanky/leiningen-nastroj-pro-spravu-projektu-napsanych-v-clojure-4/</a>
</li>

<li>Leiningen: nástroj pro správu projektů napsaných v Clojure (5)<br />
<a href="http://www.root.cz/clanky/leiningen-nastroj-pro-spravu-projektu-napsanych-v-clojure-5/">http://www.root.cz/clanky/leiningen-nastroj-pro-spravu-projektu-napsanych-v-clojure-5/</a>
</li>

<li>Leiningen: nástroj pro správu projektů napsaných v Clojure (6)<br />
<a href="http://www.root.cz/clanky/leiningen-nastroj-pro-spravu-projektu-napsanych-v-clojure-6/">http://www.root.cz/clanky/leiningen-nastroj-pro-spravu-projektu-napsanych-v-clojure-6/</a>
</li>

<li>Programovací jazyk Clojure a databáze (1.část)<br />
<a href="http://www.root.cz/clanky/programovaci-jazyk-clojure-a-databaze-1-cast/">http://www.root.cz/clanky/programovaci-jazyk-clojure-a-databaze-1-cast/</a>
</li>

<li>Pluginy pro Leiningen<br />
<a href="http://www.root.cz/clanky/leiningen-nastroj-pro-spravu-projektu-napsanych-v-clojure-pluginy-pro-leiningen/">http://www.root.cz/clanky/leiningen-nastroj-pro-spravu-projektu-napsanych-v-clojure-pluginy-pro-leiningen/</a>
</li>

<li>Programovací jazyk Clojure a knihovny pro práci s vektory a maticemi<br />
<a href="http://www.root.cz/clanky/programovaci-jazyk-clojure-a-knihovny-pro-praci-s-vektory-a-maticemi/">http://www.root.cz/clanky/programovaci-jazyk-clojure-a-knihovny-pro-praci-s-vektory-a-maticemi/</a>
</li>

<li>Programovací jazyk Clojure a knihovny pro práci s vektory a maticemi (2)<br />
<a href="http://www.root.cz/clanky/programovaci-jazyk-clojure-a-knihovny-pro-praci-s-vektory-a-maticemi-2/">http://www.root.cz/clanky/programovaci-jazyk-clojure-a-knihovny-pro-praci-s-vektory-a-maticemi-2/</a>
</li>

<li>Programovací jazyk Clojure: syntéza procedurálních textur s využitím knihovny Clisk<br />
<a href="http://www.root.cz/clanky/programovaci-jazyk-clojure-synteza-proceduralnich-textur-s-vyuzitim-knihovny-clisk/">http://www.root.cz/clanky/programovaci-jazyk-clojure-synteza-proceduralnich-textur-s-vyuzitim-knihovny-clisk/</a>
</li>

<li>Programovací jazyk Clojure: syntéza procedurálních textur s využitím knihovny Clisk (2)<br />
<a href="http://www.root.cz/clanky/programovaci-jazyk-clojure-synteza-proceduralnich-textur-s-vyuzitim-knihovny-clisk-2/">http://www.root.cz/clanky/programovaci-jazyk-clojure-synteza-proceduralnich-textur-s-vyuzitim-knihovny-clisk-2/</a>
</li>

<li>Programovací jazyk Clojure: syntéza procedurálních textur s využitím knihovny Clisk (dokončení)<br />
<a href="http://www.root.cz/clanky/programovaci-jazyk-clojure-synteza-proceduralnich-textur-s-vyuzitim-knihovny-clisk-dokonceni/">http://www.root.cz/clanky/programovaci-jazyk-clojure-synteza-proceduralnich-textur-s-vyuzitim-knihovny-clisk-dokonceni/</a>
</li>

<li>Seesaw: knihovna pro snadnou tvorbu GUI v jazyce Clojure<br />
<a href="http://www.root.cz/clanky/seesaw-knihovna-pro-snadnou-tvorbu-gui-v-jazyce-clojure/">http://www.root.cz/clanky/seesaw-knihovna-pro-snadnou-tvorbu-gui-v-jazyce-clojure/</a>
</li>

<li>Seesaw: knihovna pro snadnou tvorbu GUI v jazyce Clojure (2)<br />
<a href="http://www.root.cz/clanky/seesaw-knihovna-pro-snadnou-tvorbu-gui-v-jazyce-clojure-2/">http://www.root.cz/clanky/seesaw-knihovna-pro-snadnou-tvorbu-gui-v-jazyce-clojure-2/</a>
</li>

<li>Seesaw: knihovna pro snadnou tvorbu GUI v jazyce Clojure (3)<br />
<a href="http://www.root.cz/clanky/seesaw-knihovna-pro-snadnou-tvorbu-gui-v-jazyce-clojure-3/">http://www.root.cz/clanky/seesaw-knihovna-pro-snadnou-tvorbu-gui-v-jazyce-clojure-3/</a>
</li>

<li>Programovací jazyk Clojure a práce s Gitem<br />
<a href="http://www.root.cz/clanky/programovaci-jazyk-clojure-a-prace-s-gitem/">http://www.root.cz/clanky/programovaci-jazyk-clojure-a-prace-s-gitem/</a>
</li>

<li>Programovací jazyk Clojure a práce s Gitem (2)<br />
<a href="http://www.root.cz/clanky/programovaci-jazyk-clojure-a-prace-s-gitem-2/">http://www.root.cz/clanky/programovaci-jazyk-clojure-a-prace-s-gitem-2/</a>
</li>

<li>Programovací jazyk Clojure – triky při práci s řetězci<br />
<a href="http://www.root.cz/clanky/programovaci-jazyk-clojure-triky-pri-praci-s-retezci/">http://www.root.cz/clanky/programovaci-jazyk-clojure-triky-pri-praci-s-retezci/</a>
</li>

<li>Programovací jazyk Clojure – triky při práci s kolekcemi<br />
<a href="http://www.root.cz/clanky/programovaci-jazyk-clojure-triky-pri-praci-s-kolekcemi/">http://www.root.cz/clanky/programovaci-jazyk-clojure-triky-pri-praci-s-kolekcemi/</a>
</li>

</ol>



<p><a name="k12"></a></p>
<h2 id="k12">12. Odkazy na Internetu</h2>

<ol>

<li>Understanding Clojure's PersistentVector implementation<br />
<a href="http://blog.higher-order.net/2009/02/01/understanding-clojures-persistentvector-implementation">http://blog.higher-order.net/2009/02/01/understanding-clojures-persistentvector-implementation</a>
</li>

<li>Understanding Clojure's PersistentHashMap (deftwice...)<br />
<a href="http://blog.higher-order.net/2009/09/08/understanding-clojures-persistenthashmap-deftwice.html">http://blog.higher-order.net/2009/09/08/understanding-clojures-persistenthashmap-deftwice.html</a>
</li>

<li>Assoc and Clojure's PersistentHashMap: part ii<br />
<a href="http://blog.higher-order.net/2010/08/16/assoc-and-clojures-persistenthashmap-part-ii.html">http://blog.higher-order.net/2010/08/16/assoc-and-clojures-persistenthashmap-part-ii.html</a>
</li>

<li>Ideal Hashtrees (paper)<br />
<a href="http://lampwww.epfl.ch/papers/idealhashtrees.pdf">http://lampwww.epfl.ch/papers/idealhashtrees.pdf</a>
</li>

<li>Clojure home page<br />
<a href="http://clojure.org/">http://clojure.org/</a>
</li>

<li>Clojure (downloads)<br />
<a href="http://clojure.org/downloads">http://clojure.org/downloads</a>
</li>

<li>Clojure Sequences<br />
<a href="http://clojure.org/sequences">http://clojure.org/sequences</a>
</li>

<li>Clojure Data Structures<br />
<a href="http://clojure.org/data_structures">http://clojure.org/data_structures</a>
</li>

<li>The Structure and Interpretation of Computer Programs: 2.2.1  Representing Sequences<br />
<a href="http://mitpress.mit.edu/sicp/full-text/book/book-Z-H-15.html#%_sec_2.2.1">http://mitpress.mit.edu/sicp/full-text/book/book-Z-H-15.html#%_sec_2.2.1</a>
</li>

<li>The Structure and Interpretation of Computer Programs: 3.3.1  Mutable List Structure<br />
<a href="http://mitpress.mit.edu/sicp/full-text/book/book-Z-H-22.html#%_sec_3.3.1">http://mitpress.mit.edu/sicp/full-text/book/book-Z-H-22.html#%_sec_3.3.1</a>
</li>

<li>Clojure - Functional Programming for the JVM<br />
<a href="http://java.ociweb.com/mark/clojure/article.html">http://java.ociweb.com/mark/clojure/article.html</a>
</li>

<li>Clojure quick reference<br />
<a href="http://faustus.webatu.com/clj-quick-ref.html">http://faustus.webatu.com/clj-quick-ref.html</a>
</li>

<li>4Clojure<br />
<a href="http://www.4clojure.com/">http://www.4clojure.com/</a>
</li>

<li>ClojureDoc (rozcestník s&nbsp;dokumentací jazyka Clojure)<br />
<a href="http://clojuredocs.org/">http://clojuredocs.org/</a>
</li>

<li>Clojure (na Wikipedia EN)<br />
<a href="http://en.wikipedia.org/wiki/Clojure">http://en.wikipedia.org/wiki/Clojure</a>
</li>

<li>Clojure (na Wikipedia CS)<br />
<a href="http://cs.wikipedia.org/wiki/Clojure">http://cs.wikipedia.org/wiki/Clojure</a>
</li>

<li>SICP (The Structure and Interpretation of Computer Programs)<br />
<a href="http://mitpress.mit.edu/sicp/">http://mitpress.mit.edu/sicp/</a>
</li>

<li>Pure function<br />
<a href="http://en.wikipedia.org/wiki/Pure_function">http://en.wikipedia.org/wiki/Pure_function</a>
</li>

<li>Funkcionální programování<br />
<a href="http://cs.wikipedia.org/wiki/Funkcionální_programování">http://cs.wikipedia.org/wiki/Funkcionální_programování</a>
</li>

<li>Čistě funkcionální (datové struktury, jazyky, programování)<br />
<a href="http://cs.wikipedia.org/wiki/Čistě_funkcionální">http://cs.wikipedia.org/wiki/Čistě_funkcionální</a>
</li>

<li>Clojure Macro Tutorial (Part I, Getting the Compiler to Write Your Code For You)<br />
<a href="http://www.learningclojure.com/2010/09/clojure-macro-tutorial-part-i-getting.html">http://www.learningclojure.com/2010/09/clojure-macro-tutorial-part-i-getting.html</a>
</li>

<li>Clojure Macro Tutorial (Part II: The Compiler Strikes Back)<br />
<a href="http://www.learningclojure.com/2010/09/clojure-macro-tutorial-part-ii-compiler.html">http://www.learningclojure.com/2010/09/clojure-macro-tutorial-part-ii-compiler.html</a>
</li>

<li>Clojure Macro Tutorial (Part III: Syntax Quote)<br />
<a href="http://www.learningclojure.com/2010/09/clojure-macro-tutorial-part-ii-syntax.html">http://www.learningclojure.com/2010/09/clojure-macro-tutorial-part-ii-syntax.html</a>
</li>

<li>Tech behind Tech: Clojure Macros Simplified<br />
<a href="http://techbehindtech.com/2010/09/28/clojure-macros-simplified/">http://techbehindtech.com/2010/09/28/clojure-macros-simplified/</a>
</li>

<li>Fatvat - Exploring functional programming: Clojure Macros<br />
<a href="http://www.fatvat.co.uk/2009/02/clojure-macros.html">http://www.fatvat.co.uk/2009/02/clojure-macros.html</a>
</li>

<li>Eulerovo číslo<br />
<a href="http://cs.wikipedia.org/wiki/Eulerovo_číslo">http://cs.wikipedia.org/wiki/Eulerovo_číslo</a>
</li>

<li>List comprehension<br />
<a href="http://en.wikipedia.org/wiki/List_comprehension">http://en.wikipedia.org/wiki/List_comprehension</a>
</li>

<li>List Comprehensions in Clojure<br />
<a href="http://asymmetrical-view.com/2008/11/18/list-comprehensions-in-clojure.html">http://asymmetrical-view.com/2008/11/18/list-comprehensions-in-clojure.html</a>
</li>

<li>Clojure Programming Concepts: List Comprehension<br />
<a href="http://en.wikibooks.org/wiki/Clojure_Programming/Concepts#List_Comprehension">http://en.wikibooks.org/wiki/Clojure_Programming/Concepts#List_Comprehension</a>
</li>

<li>Clojure core API: for macro<br />
<a href="http://clojure.github.com/clojure/clojure.core-api.html#clojure.core/for">http://clojure.github.com/clojure/clojure.core-api.html#clojure.core/for</a>
</li>

<li>cirrus machina - The Clojure for macro<br />
<a href="http://www.cirrusmachina.com/blog/comment/the-clojure-for-macro/">http://www.cirrusmachina.com/blog/comment/the-clojure-for-macro/</a>
</li>

<li>Riastradh's Lisp Style Rules<br />
<a href="http://mumble.net/~campbell/scheme/style.txt">http://mumble.net/~campbell/scheme/style.txt</a>
</li>

<li>Dynamic Languages Strike Back<br />
<a href="http://steve-yegge.blogspot.cz/2008/05/dynamic-languages-strike-back.html">http://steve-yegge.blogspot.cz/2008/05/dynamic-languages-strike-back.html</a>
</li>

<li>Scripting: Higher Level Programming for the 21st Century<br />
<a href="http://www.tcl.tk/doc/scripting.html">http://www.tcl.tk/doc/scripting.html</a>
</li>

<li>Java Virtual Machine Support for Non-Java Languages<br />
<a href="http://docs.oracle.com/javase/7/docs/technotes/guides/vm/multiple-language-support.html">http://docs.oracle.com/javase/7/docs/technotes/guides/vm/multiple-language-support.html</a>
</li>

<li>Třída java.lang.String<br />
<a href="http://docs.oracle.com/javase/7/docs/api/java/lang/String.html">http://docs.oracle.com/javase/7/docs/api/java/lang/String.html</a>
</li>

<li>Třída java.lang.StringBuffer<br />
<a href="http://docs.oracle.com/javase/7/docs/api/java/lang/StringBuffer.html">http://docs.oracle.com/javase/7/docs/api/java/lang/StringBuffer.html</a>
</li>

<li>Třída java.lang.StringBuilder<br />
<a href="http://docs.oracle.com/javase/7/docs/api/java/lang/StringBuilder.html">http://docs.oracle.com/javase/7/docs/api/java/lang/StringBuilder.html</a>
</li>

<li>StringBuffer versus String<br />
<a href="http://www.javaworld.com/article/2076072/build-ci-sdlc/stringbuffer-versus-string.html">http://www.javaworld.com/article/2076072/build-ci-sdlc/stringbuffer-versus-string.html</a>
</li>

<li>Threading macro (dokumentace k&nbsp;jazyku Clojure)<br />
<a href="https://clojure.github.io/clojure/clojure.core-api.html#clojure.core/-&gt;">https://clojure.github.io/clojure/clojure.core-api.html#clojure.core/-&gt;</a>
</li>

<li>Understanding the Clojure -&gt; macro<br />
<a href="http://blog.fogus.me/2009/09/04/understanding-the-clojure-macro/">http://blog.fogus.me/2009/09/04/understanding-the-clojure-macro/</a>
</li>

<li>clojure.inspector<br />
<a href="http://clojure.github.io/clojure/clojure.inspector-api.html">http://clojure.github.io/clojure/clojure.inspector-api.html</a>
</li>

<li>The Clojure Toolbox<br />
<a href="http://www.clojure-toolbox.com/">http://www.clojure-toolbox.com/</a>
</li>

<li>Unit Testing in Clojure<br />
<a href="http://nakkaya.com/2009/11/18/unit-testing-in-clojure/">http://nakkaya.com/2009/11/18/unit-testing-in-clojure/</a>
</li>

<li>Testing in Clojure (Part-1: Unit testing)<br />
<a href="http://blog.knoldus.com/2014/03/22/testing-in-clojure-part-1-unit-testing/">http://blog.knoldus.com/2014/03/22/testing-in-clojure-part-1-unit-testing/</a>
</li>

<li>API for clojure.test - Clojure v1.6 (stable)<br />
<a href="https://clojure.github.io/clojure/clojure.test-api.html">https://clojure.github.io/clojure/clojure.test-api.html</a>
</li>

<li>Leiningen: úvodní stránka<br />
<a href="http://leiningen.org/">http://leiningen.org/</a>
</li>

<li>Leiningen: Git repository<br />
<a href="https://github.com/technomancy/leiningen">https://github.com/technomancy/leiningen</a>
</li>

<li>leiningen-win-installer<br />
<a href="http://leiningen-win-installer.djpowell.net/">http://leiningen-win-installer.djpowell.net/</a>
</li>

<li>Clojure  1: Úvod<br />
<a href="http://www.root.cz/clanky/clojure-aneb-jazyk-umoznujici-tvorbu-bezpecnych-vicevlaknovych-aplikaci-pro-jvm/">http://www.root.cz/clanky/clojure-aneb-jazyk-umoznujici-tvorbu-bezpecnych-vicevlaknovych-aplikaci-pro-jvm/</a>
</li>

<li>Clojure  2: Symboly, kolekce atd.<br />
<a href="http://www.root.cz/clanky/clojure-aneb-jazyk-umoznujici-tvorbu-bezpecnych-vicevlaknovych-aplikaci-pro-jvm-2-cast/">http://www.root.cz/clanky/clojure-aneb-jazyk-umoznujici-tvorbu-bezpecnych-vicevlaknovych-aplikaci-pro-jvm-2-cast/</a>
</li>

<li>Clojure  3: Funkcionální programování<br />
<a href="http://www.root.cz/clanky/clojure-aneb-jazyk-umoznujici-tvorbu-bezpecnych-vicevlaknovych-aplikaci-pro-jvm-3-cast-funkcionalni-programovani/">http://www.root.cz/clanky/clojure-aneb-jazyk-umoznujici-tvorbu-bezpecnych-vicevlaknovych-aplikaci-pro-jvm-3-cast-funkcionalni-programovani/</a>
</li>

<li>Clojure  4: Kolekce, sekvence a lazy sekvence<br />
<a href="http://www.root.cz/clanky/clojure-aneb-jazyk-umoznujici-tvorbu-bezpecnych-vicevlaknovych-aplikaci-pro-jvm-4-cast-kolekce-sekvence-a-lazy-sekvence/">http://www.root.cz/clanky/clojure-aneb-jazyk-umoznujici-tvorbu-bezpecnych-vicevlaknovych-aplikaci-pro-jvm-4-cast-kolekce-sekvence-a-lazy-sekvence/</a>
</li>

<li>Clojure  5: Sekvence, lazy sekvence a paralelní programy<br />
<a href="http://www.root.cz/clanky/clojure-a-bezpecne-aplikace-pro-jvm-sekvence-lazy-sekvence-a-paralelni-programy/">http://www.root.cz/clanky/clojure-a-bezpecne-aplikace-pro-jvm-sekvence-lazy-sekvence-a-paralelni-programy/</a>
</li>

<li>Clojure  6: Podpora pro paralelní programování<br />
<a href="http://www.root.cz/clanky/programovaci-jazyk-clojure-6-futures-nejsou-jen-financni-derivaty/">http://www.root.cz/clanky/programovaci-jazyk-clojure-6-futures-nejsou-jen-financni-derivaty/</a>
</li>

<li>Clojure  7: Další funkce pro paralelní programování<br />
<a href="http://www.root.cz/clanky/programovaci-jazyk-clojure-7-dalsi-podpurne-prostredky-pro-paralelni-programovani/">http://www.root.cz/clanky/programovaci-jazyk-clojure-7-dalsi-podpurne-prostredky-pro-paralelni-programovani/</a>
</li>

<li>Clojure  8: Identity, stavy, neměnné hodnoty a reference<br />
<a href="http://www.root.cz/clanky/programovaci-jazyk-clojure-8-identity-stavy-nemenne-hodnoty-a-referencni-typy/">http://www.root.cz/clanky/programovaci-jazyk-clojure-8-identity-stavy-nemenne-hodnoty-a-referencni-typy/</a>
</li>

<li>Clojure  9: Validátory, pozorovatelé a kooperace s Javou<br />
<a href="http://www.root.cz/clanky/programovaci-jazyk-clojure-9-validatory-pozorovatele-a-kooperace-mezi-clojure-a-javou/">http://www.root.cz/clanky/programovaci-jazyk-clojure-9-validatory-pozorovatele-a-kooperace-mezi-clojure-a-javou/</a>
</li>

<li>Clojure 10: Kooperace mezi Clojure a Javou<br />
<a href="http://www.root.cz/clanky/programovaci-jazyk-clojure-10-kooperace-mezi-clojure-a-javou-pokracovani/">http://www.root.cz/clanky/programovaci-jazyk-clojure-10-kooperace-mezi-clojure-a-javou-pokracovani/</a>
</li>

<li>Clojure 11: Generátorová notace seznamu/list comprehension<br />
<a href="http://www.root.cz/clanky/programovaci-jazyk-clojure-11-generatorova-notace-seznamu-list-comprehension/">http://www.root.cz/clanky/programovaci-jazyk-clojure-11-generatorova-notace-seznamu-list-comprehension/</a>
</li>

<li>Clojure 12: Překlad programů z Clojure do bajtkódu JVM I:<br />
<a href="http://www.root.cz/clanky/programovaci-jazyk-clojure-12-preklad-programu-z-clojure-do-bajtkodu-jvm/">http://www.root.cz/clanky/programovaci-jazyk-clojure-12-preklad-programu-z-clojure-do-bajtkodu-jvm/</a>
</li>

<li>Clojure 13: Překlad programů z Clojure do bajtkódu JVM II:<br />
<a href="http://www.root.cz/clanky/programovaci-jazyk-clojure-13-preklad-programu-z-clojure-do-bajtkodu-jvm-pokracovani/">http://www.root.cz/clanky/programovaci-jazyk-clojure-13-preklad-programu-z-clojure-do-bajtkodu-jvm-pokracovani/</a>
</li>

<li>Clojure 14: Základy práce se systémem maker<br />
<a href="http://www.root.cz/clanky/programovaci-jazyk-clojure-14-zaklady-prace-se-systemem-maker/">http://www.root.cz/clanky/programovaci-jazyk-clojure-14-zaklady-prace-se-systemem-maker/</a>
</li>

<li>Clojure 15: Tvorba uživatelských maker<br />
<a href="http://www.root.cz/clanky/programovaci-jazyk-clojure-15-tvorba-uzivatelskych-maker/">http://www.root.cz/clanky/programovaci-jazyk-clojure-15-tvorba-uzivatelskych-maker/</a>
</li>

<li>Clojure 16: Složitější uživatelská makra<br />
<a href="http://www.root.cz/clanky/programovaci-jazyk-clojure-16-slozitejsi-uzivatelska-makra/">http://www.root.cz/clanky/programovaci-jazyk-clojure-16-slozitejsi-uzivatelska-makra/</a>
</li>

<li>Clojure 17: Využití standardních maker v praxi<br />
<a href="http://www.root.cz/clanky/programovaci-jazyk-clojure-17-vyuziti-standardnich-maker-v-praxi/">http://www.root.cz/clanky/programovaci-jazyk-clojure-17-vyuziti-standardnich-maker-v-praxi/</a>
</li>

<li>Clojure 18: Základní techniky optimalizace aplikací<br />
<a href="http://www.root.cz/clanky/programovaci-jazyk-clojure-18-zakladni-techniky-optimalizace-aplikaci/">http://www.root.cz/clanky/programovaci-jazyk-clojure-18-zakladni-techniky-optimalizace-aplikaci/</a>
</li>

<li>Clojure 19: Vývojová prostředí pro Clojure<br />
<a href="http://www.root.cz/clanky/programovaci-jazyk-clojure-19-vyvojova-prostredi-pro-clojure/">http://www.root.cz/clanky/programovaci-jazyk-clojure-19-vyvojova-prostredi-pro-clojure/</a>
</li>

<li>Clojure 20: Vývojová prostředí pro Clojure (Vimu s REPL)<br />
<a href="http://www.root.cz/clanky/programovaci-jazyk-clojure-20-vyvojova-prostredi-pro-clojure-integrace-vimu-s-repl/">http://www.root.cz/clanky/programovaci-jazyk-clojure-20-vyvojova-prostredi-pro-clojure-integrace-vimu-s-repl/</a>
</li>

<li>Clojure 21: ClojureScript aneb překlad Clojure do JS<br />
<a href="http://www.root.cz/clanky/programovaci-jazyk-clojure-21-clojurescript-aneb-preklad-clojure-do-javascriptu/">http://www.root.cz/clanky/programovaci-jazyk-clojure-21-clojurescript-aneb-preklad-clojure-do-javascriptu/</a>
</li>

<li>Clojure.org: Vars and the Global Environment<br />
<a href="http://clojure.org/Vars">http://clojure.org/Vars</a>
</li>

<li>Clojure.org: Refs and Transactions<br />
<a href="http://clojure.org/Refs">http://clojure.org/Refs</a>
</li>

<li>Clojure.org: Atoms<br />
<a href="http://clojure.org/Atoms">http://clojure.org/Atoms</a>
</li>

<li>Clojure.org: Agents as Asynchronous Actions<br />
<a href="http://clojure.org/agents">http://clojure.org/agents</a>
</li>

<li>Transient Data Structures
<a href="http://clojure.org/transients">http://clojure.org/transients</a>
</li>

</ol>



<p></p><p></p>
<p><small>Autor: <a href="http://www.fit.vutbr.cz/~tisnovpa">Pavel Tišnovský</a> &nbsp; 2015</small></p>
</body>
</html>

