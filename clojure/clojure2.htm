<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
        "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html>
<head>
<title>Leiningen: nástroj pro správu projektů napsaných v Clojure (2)</title>
<meta name="Author" content="Pavel Tisnovsky" />
<meta name="Generator" content="vim" />
<meta http-equiv="content-type" content="text/html; charset=utf-8" />
<style type="text/css">
         body {color:#000000; background:#ffffff;}
         h1  {font-family: arial, helvetica, sans-serif; color:#ffffff; background-color:#c00000; text-align:center; padding-left:1em}
         h2  {font-family: arial, helvetica, sans-serif; color:#ffffff; background-color:#0000c0; padding-left:1em; text-align:left}
         h3  {font-family: arial, helvetica, sans-serif; color:#000000; background-color:#c0c0c0; padding-left:1em; text-align:left}
         h4  {font-family: arial, helvetica, sans-serif; color:#000000; background-color:#e0e0e0; padding-left:1em; text-align:left}
         a   {font-family: arial, helvetica, sans-serif;}
         li  {font-family: arial, helvetica, sans-serif; color:#000000; text-align:justify; width:450px;}
         ol  {font-family: arial, helvetica, sans-serif; color:#000000; text-align:justify; width:450px;}
         ul  {font-family: arial, helvetica, sans-serif; color:#000000; text-align:justify; width:450px;}
         p   {font-family: arial, helvetica, sans-serif; color:#000000; text-align:justify;}
         pre {background:#e0e0e0}
</style>
</head>

<body>

<h1>Leiningen: nástroj pro správu projektů napsaných v Clojure (2)</h1>

<h3>Pavel Tišnovský</h3>

<p></p>

<h1>Úvodník</h1>

<p>Ve druhé části článku o nástroji Leiningen určeného pro správu projektů vytvořených v Clojure se seznámíme s možnostmi použití zkompilovaných tříd vytvořených v Javě, s interaktivní smyčkou REPL zabudovanou do Leiningenu a vytvářením javovských archivů (.jar) obsahujících vyvíjenou aplikaci a připravených pro nasazení na další počítače.</p>



<h2>Obsah</h2>

<p><a href="#k01">1. Leiningen: nástroj pro správu projektů napsaných v&nbsp;Clojure (2)</a></p>
<p><a href="#k02">2. Vytvoření nového demonstračního projektu</a></p>
<p><a href="#k03">3. Výpis adresářů, v&nbsp;nichž se hledají přeložené třídy a zdrojové kódy</a></p>
<p><a href="#k04">4. Přidání přeložené javovské třídy do projektu</a></p>
<p><a href="#k05">5. Spuštění projektu s&nbsp;přidanou javovskou třídou</a></p>
<p><a href="#k06">6. Interaktivní smyčka REPL integrovaná do Leiningenu</a></p>
<p><a href="#k07">7. Vytvoření Java archivu s&nbsp;demonstračním projektem</a></p>
<p><a href="#k08">8. Spuštění projektu s&nbsp;využitím Java archivu</a></p>
<p><a href="#k09">9. Vytvoření &bdquo;megaarchivu&ldquo; s&nbsp;projektem i se samotným Clojure</a></p>
<p><a href="#k10">10. Spuštění aplikace z&nbsp;&bdquo;megaarchivu&ldquo;</a></p>
<p><a href="#k11">11. Obsah třetí části článku</a></p>
<p><a href="#k12">12. Odkazy na Internetu</a></p>



<p><a name="k01"></a></p>
<h2 id="k01">1. Leiningen: nástroj pro správu projektů napsaných v Clojure (2)</h2>

<p><a
href="http://www.root.cz/clanky/leiningen-nastroj-pro-spravu-projektu-napsanych-v-clojure/">V&nbsp;první
části článku o nástroji Leiningen</a> jsme si ukázali, jakým způsobem je možné
tento nástroj jednoduše nainstalovat na prakticky jakýkoli stroj s&nbsp;JDK a
JRE skriptem <strong>lein</strong> a jak lze s&nbsp;využitím tohoto nástroje
vytvořit nový projekt, který bude napsán v&nbsp;programovacím jazyce
<i>Clojure</i>. Taktéž jsme se seznámili se způsobem automatického stažení
knihoven, na nichž projekt závisí i s&nbsp;tím, jak se projekt nakonec spustí.
Ve skutečnosti je ovšem možné <i>Leiningen</i> používat i k&nbsp;dalším
činnostem. Při vývoji lze s&nbsp;výhodou využít vestavěnou interaktivní smyčku
<i>REPL</i> (<a href="https://en.wikipedia.org/wiki/REPL">Read-Eval-Print
Loop</a>), která se od běžné smyčky REPL implementované v&nbsp;samotném
<i>Clojure</i> v&nbsp;mnoha ohledech odlišuje &ndash; existencí historie
zadávaných příkazů, automatickým nahráním všech knihoven vyžadovaných pro běh
projektu, vylepšeným systémem nápovědy apod.</p>

<p><i>Leiningen</i> se ovšem v&nbsp;praxi velmi často používá i při vytváření
javovských archivů (souborů s&nbsp;koncovkou .jar) obsahujících celý projekt,
který tak lze jednoduše distribuovat či nasazovat na další počítače. Vytvořený
archiv lze ale například využít i v&nbsp;<a
href="https://registry.hub.docker.com/u/pointslope/clojure/">tomto obrazu</a>
pro Docker. Dokonce lze vytvářet i takzvané &bdquo;megaarchivy&ldquo;
(<i>uberjar</i>) určené pro spuštění na počítači s&nbsp;JRE (<i>Java Runtime
Environment</i>) &ndash; megaarchivy totiž obsahují i samotné jádro
<i>Clojure</i>, samozřejmě ve verzi používané programátorem při vývoji
aplikace. <i>Leiningen</i> podporuje i tvorbu a spouštění jednotkových testů,
které sice nejsou ve výchozím nastavení kompatibilní s&nbsp;formátem používaným
nástrojem JUnit (lze ovšem využít plugin <a
href="https://github.com/ruedigergad/test2junit">test2junit</a>), ovšem i tak
lze s&nbsp;jejich pomocí relativně snadno vyvíjenou aplikaci, resp.&nbsp;její
jednotlivé funkce, průběžně testovat. Způsobem tvorby jednotkových testů se
budeme podrobněji zabývat příště.</p>



<p><a name="k02"></a></p>
<h2 id="k02">2. Vytvoření nového demonstračního projektu</h2>

<p>Před ukázkami dalších možností nabízených nástrojem <i>Leiningen</i> si ve
vhodném adresáři vytvoříme zcela nový projekt, který budeme postupně měnit a
v&nbsp;závěru článku také testovat. Již z&nbsp;předchozí části víme, jak se
nový projekt vytvoří. Vše zařídí následující příkaz, který musí být spuštěn
v&nbsp;adresáři, do něhož má právě aktivní uživatel právo zápisu:</p>

<pre>
lein new app clojure_test_2
</pre>

<p>Na standardní výstup by se měla vypsat následující zpráva:</p>

<pre>
Generating a project called clojure_test_2 based on the 'app' template.
</pre>

<p>Z&nbsp;hlášení vidíme, že se projekt skutečně podařilo vytvořit. Adresář
s&nbsp;projektem by měl mít následující strukturu (stejnou, jako projekt
vytvořený minule, samozřejmě až na odlišný název):</p>

<pre>
.
├── doc
│   └── intro.md
├── LICENSE
├── project.clj
├── README.md
├── resources
├── src
│   └── clojure_test_2
│       └── core.clj
└── test
    └── clojure_test_2
        └── core_test.clj
&nbsp;
6 directories, 6 files
</pre>

<p>Do projektu ještě přidáme deklaraci závislosti na externí knihovně, pro
jednoduchost stejné, jako tomu bylo i minule, tedy
<strong>org.clojure.data/json</strong>. Změna je provedena v&nbsp;hlavním
souboru celého projektu &ndash; <strong>project.clj</strong>:</p>

<pre>
(defproject clojure_test_2 "0.1.0-SNAPSHOT"
  :description "FIXME: write description"
  :url "http://example.com/FIXME"
  :license {:name "Eclipse Public License"
            :url "http://www.eclipse.org/legal/epl-v10.html"}
  :dependencies [[org.clojure/clojure "1.6.0"]
                 <strong>[org.clojure/data.json "0.2.5"]</strong>]
  :main ^:skip-aot clojure-test-2.core
  :target-path "target/%s"
  :profiles {:uberjar {:aot :all}})
</pre>

<p>Upravíme i zdrojový kód projektu takovým způsobem, aby tuto knihovnu
využíval a volal z&nbsp;ní metodu <strong>pprint</strong> (povšimněte si, že
jsme pro jmenný prostor knihovny vytvořili kratší a snadno zapamatovatelný
alias <strong>json</strong>):</p>

<pre>
(ns clojure-test-2.core
    (:gen-class)
    (:require [clojure.data.json :as json]))
&nbsp;
(defn -main
    "I don't do a whole lot ... yet."
    [&amp; args]
    (let [article {:title "What's Good About Clojure?"
                   :url   "http://www.catalysoft.com/articles/goodAboutClojure.html"
                   :last-checked (.toString (new java.util.Date))}]
         (json/pprint article)))
</pre>



<p><a name="k03"></a></p>
<h2 id="k03">3. Výpis adresářů, v&nbsp;nichž se hledají přeložené třídy a zdrojové kódy</h2>

<p>Jedním z&nbsp;velmi častých problémů, s&nbsp;nimiž se setkávají jak
programátoři vyvíjející aplikace v&nbsp;Javě, tak i administrátoři, je zjištění
popř.&nbsp;nastavení <i>classpath</i>, tj.&nbsp;adresářů a Java archivů,
v&nbsp;nichž virtuální stroj Javy po svém spuštění hledá přeložené třídy
popř.&nbsp;další potřebné soubory (<i>resources</i>). Podobný problém řeší i
vývojáři používající programovací jazyk <i>Clojure</i>, kde je situace ještě
poněkud komplikovanější kvůli pravidlům pojmenovávání zdrojových souborů,
adresářů a jmenných prostorů (zjednodušeně řečeno se pomlčky ve jmenných
prostorech převádí na podtržítka). Pokud je však projekt založen nástrojem
<i>Leiningen</i>, je možné zjistit aktuální nastavení <i>classpath</i> velmi
jednoduše; konkrétně pomocí příkazu <strong>lein classpath</strong>. Můžeme si
to snadno vyzkoušet:</p>

<pre>
lein classpath
</pre>

<p>Výstupem tohoto příkazu je jediný řádek, který jsem kvůli vyšší čitelnosti
rozdělil na větší množství řádků v&nbsp;místě oddělovače jednotlivých cest:</p>

<pre>
/home/tester/src/Clojure/clojure_test_2/test:
/home/tester/src/Clojure/clojure_test_2/src:
/home/tester/src/Clojure/clojure_test_2/dev-resources:
/home/tester/src/Clojure/clojure_test_2/resources:
/home/tester/src/Clojure/clojure_test_2/target/base+system+user+dev/classes:
/home/tester/.m2/repository/clojure-complete/clojure-complete/0.2.3/clojure-complete-0.2.3.jar:
/home/tester/.m2/repository/org/clojure/tools.nrepl/0.2.6/tools.nrepl-0.2.6.jar:
/home/tester/.m2/repository/org/clojure/data.json/0.2.5/data.json-0.2.5.jar:
/home/tester/.m2/repository/org/clojure/clojure/1.6.0/clojure-1.6.0.jar
</pre>



<p><a name="k04"></a></p>
<h2 id="k04">4. Přidání přeložené javovské třídy do projektu</h2>

<p>Z&nbsp;výstupu příkazu <strong>lein classpath</strong> je patrné, že se
přeložené třídy, tj.&nbsp;soubory s&nbsp;koncovkou <strong>.class</strong>
budou vyhledávat mj.&nbsp;i v&nbsp;podadresáři <strong>resources</strong>,
který byl automaticky vytvořen v&nbsp;průběhu generování adresářové struktury
nového projektu. Ihned si tuto vlastnost otestujeme; přidáme totiž do projektu
jeden zdrojový soubor napsaný v&nbsp;programovacím jazyce Java, jehož překladem
vznikne kýžený soubor <strong>.class</strong> obsahující bajtkód přeložené
třídy. Zdrojový soubor se bude jmenovat <strong>Adder.java</strong> a třída
v&nbsp;něm deklarovaná bude mít (pochopitelně) název <strong>Adder</strong>,
protože se jedná o veřejnou třídu:</p>

<pre>
public class Adder {
    public static int add(int x, int y) {
        return x+y;
    }
}
</pre>

<p>Překlad této třídy do bajtkódu se (prozatím) provede ručním zavoláním
standardního překladače <strong>javac</strong>:</p>

<pre>
javac Adder.java
</pre>

<p>Výsledný soubor se jménem <strong>Adder.class</strong> musí být přesunut do
adresáře <strong>resources</strong>:</p>

<pre>
mv Adder.class resources/
</pre>

<p>Struktura projektu nyní vypadá následovně:</p>

<pre>
.
├── Adder.java
├── doc
│   └── intro.md
├── LICENSE
├── project.clj
├── README.md
├── resources
│   └── Adder.class
├── src
│   └── clojure_test_2
│       └── core.clj
└── test
    └── clojure_test_2
        └── core_test.clj
&nbsp;
6 directories, 8 files
</pre>



<p><a name="k05"></a></p>
<h2 id="k05">5. Spuštění projektu s&nbsp;přidanou javovskou třídou</h2>

<p>Nyní musíme otestovat, zda vyvíjená aplikace po svém spuštění skutečně třídu
<strong>Adder</strong> &bdquo;vidí&ldquo; a může volat její metody. Upravíme
tedy zdrojový kód naší aplikace následujícím způsobem:</p>

<pre>
(ns clojure-test-2.core
    (:gen-class)
    (:require [clojure.data.json :as json]))
&nbsp;
(defn -main
    "I don't do a whole lot ... yet."
    [&amp; args]
    <strong>(println (Adder/add 1 2))</strong>)
</pre>

<p>Zkusme si nyní takto upravenou aplikaci spustit a otestovat tak, zda se
přeložená třída <strong>Adder</strong> skutečně po spuštění nalezne a zda bude
korektně zavolána i metoda <strong>Adder.add()</strong>:</p>

<pre>
lein run
</pre>

<p>Výstupem by měla být hodnota 3:</p>

<pre>
3
</pre>

<p>Projekt vrátíme do původního stavu vymazáním souborů
<strong>Adder.java</strong> a <strong>Adder.class</strong>. Následně se upraví
i zdrojový kód <strong>core.clj</strong> tak, jak je <a href="#k02">vypsán ve
druhé kapitole</a>.</p>



<p><a name="k06"></a></p>
<h2 id="k06">6. Interaktivní smyčka REPL integrovaná do Leiningenu</h2>

<p>Důležitou součástí nástroje <i>Leiningen</i> je i interaktivní smyčka
<i>REPL (Read-Eval-Print Loop)</i>, která je oproti standardnímu REPLu
integrovanému přímo do <i>Clojure</i> vylepšena. Zejména je implementována
historie příkazů, dále je možné se k&nbsp;REPLu připojit přes zvolený port (což
dělají některá integrovaná vývojová prostředí), k&nbsp;dispozici je vylepšený
systém nápovědy apod. Ovšem nejdůležitější je fakt, že se při inicializaci
REPLu správně nastaví i cesty ke všem třídám a knihovnám, takže je možné bez
dalších složitostí spouštět a testovat jednotlivé části projektu. Ostatně si to
můžeme jednoduše vyzkoušet zadáním následujícího příkazu (příkaz se samozřejmě
musí spustit z&nbsp;adresáře projektu):</p>

<pre>
lein repl
</pre>

<p>Po inicializaci by se měla na konzoli vypsat následující zpráva (verze JVM
atd. samozřejmě může být odlišná):</p>

<pre>
nREPL server started on port 56416 on host 127.0.0.1 - nrepl://127.0.0.1:56416
REPL-y 0.3.5, nREPL 0.2.6
Clojure 1.6.0
OpenJDK 64-Bit Server VM 1.7.0_75-b13
    Docs: (doc function-name-here)
          (find-doc "part-of-name-here")
  Source: (source function-name-here)
 Javadoc: (javadoc java-object-or-class-here)
    Exit: Control+D or (exit) or (quit)
 Results: Stored in vars *1, *2, *3, an exception in *e
&nbsp;
clojure-test-2.core=&gt;
</pre>

<p>Nyní si můžeme vyzkoušet, jestli se opravdu načetla i knihovna pro práci
s&nbsp;formátem JSON:</p>

<pre>
clojure-test-2.core=&gt; json/pprint
#&lt;json$pprint clojure.data.json$pprint@69f528dc&gt;
</pre>

<p>Symbol <strong>json/pprint</strong> je skutečně navázán na funkci, takže si
vypišme nápovědu:</p>

<pre>
clojure-test-2.core=&gt; (doc json/pprint)
-------------------------
clojure.data.json/pprint
([x &amp; options])
  Pretty-prints JSON representation of x to *out*. Options are the
  same as for write except :value-fn, which is not supported.
nil
</pre>

<p>Funkci je samozřejmě možné ihned zavolat:</p>

<pre>
clojure-test-2.core=&gt; (json/pprint [:Clojure :is :awesome])
["Clojure", "is", "awesome"]
nil
</pre>



<p><a name="k07"></a></p>
<h2 id="k07">7. Vytvoření Java archivu s&nbsp;demonstračním projektem</h2>

<p>Další důležitou funkcí nabízenou nástrojem <i>Leiningen</i> je možnost
vytvořit Java archiv (soubor s&nbsp;koncovkou .jar), který bude obsahovat jak
vlastní projekt, tak i všechny knihovny, na kterých tento projekt závisí. Java
archiv je posléze možné spustit na jiném počítači, na něm ovšem musí být
nainstalovaný <i>Clojure</i>. Opět si tuto funkcionalitu vyzkoušíme. Nejdříve
je nutné nepatrně upravit obsah souboru <strong>project.clj</strong> takovým
způsobem, aby se provedl překlad zdrojového kódu
<strong>clojure-test-2.core</strong> do bajtkódu, tedy do souborů .class.
Úprava je jednoduchá: na řádku <strong>:main</strong> stačí vymazat metadata
<strong>^:skip-aot</strong> (já jsem změnu provedl poněkud odlišně &ndash;
původní řádek je zakomentovaný a za ním je přidána nová deklarace):</p>

<pre>
(defproject clojure_test_2 "0.1.0-SNAPSHOT"
  :description "FIXME: write description"
  :url "http://example.com/FIXME"
  :license {:name "Eclipse Public License"
            :url "http://www.eclipse.org/legal/epl-v10.html"}
  :dependencies [[org.clojure/clojure "1.6.0"]
                 [org.clojure/data.json "0.2.5"]]
  <strong>;:main ^:skip-aot clojure-test-2.core</strong>
  <strong>:main clojure-test-2.core</strong>
  :target-path "target/%s"
  :profiles {:uberjar {:aot :all}})
</pre>

<p>Vytvoření Java archivu zajistí příkaz <strong>lein jar</strong>, ještě
předtím je však vhodné celý projekt vyčistit příkazem <strong>lein
clean</strong>:</p>

<pre>
lein clean
lein jar
</pre>

<p>Struktura projektu se rozšíří, protože vznikne adresář pojmenovaný
<strong>target</strong>, v&nbsp;němž je mj.&nbsp;i náš projekt přeložený do
souborů .class:</p>

<pre>
.
├── doc
│   └── intro.md
├── LICENSE
├── project.clj
├── README.md
├── resources
├── src
│   └── clojure_test_2
│       └── core.clj
├── target
│   ├── classes
│   │   ├── clojure
│   │   │   └── data
│   │   │       ├── json
│   │   │       │   └── JSONWriter.class
│   │   │       ├── json$codepoint_case.class
│   │   │       ├── json$codepoint.class
│   │   │       ├── json$codepoint_clause.class
│   │   │       ├── json_compat_0_1__init.class
│   │   │       ├── json$default_value_fn.class
│   │   │       ├── json$default_write_key_fn.class
│   │   │       ├── json$fn__23.class
│   │   │       ├── json$fn__67.class
│   │   │       ├── json$fn__70.class
│   │   │       ├── json$fn__70$G__65__77.class
│   │   │       ├── json$fn__70$G__66__73.class
│   │   │       ├── json$fn__97.class
│   │   │       ├── json$fn__97$fn__98.class
│   │   │       ├── json__init.class
│   │   │       ├── json$json_str.class
│   │   │       ├── json$loading__4958__auto__.class
│   │   │       ├── json$pprint_array.class
│   │   │       ├── json$pprint_array$fn__105.class
│   │   │       ├── json$pprint.class
│   │   │       ├── json$pprint_dispatch.class
│   │   │       ├── json$pprint_generic.class
│   │   │       ├── json$pprint_generic$fn__133.class
│   │   │       ├── json$pprint_json.class
│   │   │       ├── json$pprint_object.class
│   │   │       ├── json$pprint_object$fn__111.class
│   │   │       ├── json$pprint_object$iter__114__118.class
│   │   │       ├── json$pprint_object$iter__114__118$fn__119.class
│   │   │       ├── json$pprint_object$iter__114__118$fn__119$fn__120.class
│   │   │       ├── json$print_json.class
│   │   │       ├── json$read_array.class
│   │   │       ├── json$_read.class
│   │   │       ├── json$read.class
│   │   │       ├── json$read_decimal.class
│   │   │       ├── json$read_escaped_char.class
│   │   │       ├── json$read_hex_char.class
│   │   │       ├── json$read_integer.class
│   │   │       ├── json$read_integer$fn__44.class
│   │   │       ├── json$read_json.class
│   │   │       ├── json$read_number.class
│   │   │       ├── json$read_number$fn__49.class
│   │   │       ├── json$read_object.class
│   │   │       ├── json$read_quoted_string.class
│   │   │       ├── json$read_str.class
│   │   │       ├── json$write_array.class
│   │   │       ├── json$write_bignum.class
│   │   │       ├── json$write.class
│   │   │       ├── json$write_double.class
│   │   │       ├── json$write_float.class
│   │   │       ├── json$write_generic.class
│   │   │       ├── json$write_json.class
│   │   │       ├── json$write_named.class
│   │   │       ├── json$write_null.class
│   │   │       ├── json$write_object.class
│   │   │       ├── json$write_plain.class
│   │   │       ├── json$write_ratio.class
│   │   │       ├── json$write_str.class
│   │   │       └── json$write_string.class
│   │   ├── clojure_test_2
│   │   │   ├── core.class
│   │   │   ├── core$fn__148.class
│   │   │   ├── core__init.class
│   │   │   ├── core$loading__4958__auto__.class
│   │   │   └── core$_main.class
│   │   └── META-INF
│   │       └── maven
│   │           └── clojure_test_2
│   │               └── clojure_test_2
│   │                   └── pom.properties
│   ├── clojure_test_2-0.1.0-SNAPSHOT.jar
│   └── stale
│       └── extract-native.dependencies
└── test
    └── clojure_test_2
        └── core_test.clj
</pre>

<p>Podívejme se nyní podrobněji na obsah adresáře <strong>target</strong>:</p>

<pre>
ls -la target/
</pre>

<p>Na standardní výstup by se měla vypsat přibližně následující struktura:</p>

<pre>
total 108
drwxr-xr-x 4 tester tester  4096 Uno 14 22:25 .
drwxr-xr-x 7 tester tester  4096 Uno 14 22:25 ..
drwxr-xr-x 4 tester tester  4096 úno 15 21:35 base+system+user+dev
drwxr-xr-x 5 tester tester  4096 Uno 14 22:25 classes
-rw-r--r-- 1 tester tester 90184 Uno 14 22:25 clojure_test_2-0.1.0-SNAPSHOT.jar
drwxr-xr-x 2 tester tester  4096 Uno 14 22:25 stale
</pre>

<p>Nejzajímavější je v&nbsp;tomto případě samozřejmě soubor
<strong>clojure_test_2-0.1.0-SNAPSHOT.jar</strong>. Jeho pojmenování vzniklo
jednoduše &ndash; jedná se o název projektu, za nějž je připojeno číslo verze.
Oba tyto údaje lze opět nalézt v&nbsp;souboru <strong>project.clj</strong>.</p>

<p>Můžeme samozřejmě prozkoumat obsah tohoto souboru, a to konkrétně
s&nbsp;využitím nástroje <strong>jar</strong>:</p>

<pre>
jar tvf target/clojure_test_2-0.1.0-SNAPSHOT.jar
</pre>

<p>Nalezneme zde například celou strukturu se zdrojovými kódy projektu:</p>

<pre>
   453 Sat Feb 14 22:25:56 CET 2015 project.clj
   373 Sat Feb 14 22:18:06 CET 2015 clojure_test_2/core.clj
</pre>

<p>Dále různé metainformace obsahující mj.&nbsp;i jméno třídy, v&nbsp;níž se má
při spuštění hledat statická metoda <strong>main</strong>:</p>

<pre>
     0 Sat Feb 14 22:25:52 CET 2015 META-INF/
   126 Sat Feb 14 22:25:56 CET 2015 META-INF/MANIFEST.MF
   453 Sat Feb 14 22:25:56 CET 2015 META-INF/leiningen/clojure_test_2/clojure_test_2/project.clj
   479 Sat Feb 14 22:25:56 CET 2015 META-INF/leiningen/clojure_test_2/clojure_test_2/README.md
 11218 Sat Feb 14 22:25:56 CET 2015 META-INF/leiningen/clojure_test_2/clojure_test_2/LICENSE
</pre>

<p>Dokonce se zde nachází metainformace použitelné známým nástrojem
<strong>Maven</strong> (v&nbsp;souboru <strong>pom.properties</strong> jsou
správně vypsány i závislosti atd. atd.):</p>

<pre>
     0 Sat Feb 14 22:25:52 CET 2015 META-INF/maven/
     0 Sat Feb 14 22:25:52 CET 2015 META-INF/maven/clojure_test_2/
     0 Sat Feb 14 22:25:52 CET 2015 META-INF/maven/clojure_test_2/clojure_test_2/
  2003 Sat Feb 14 22:25:56 CET 2015 META-INF/maven/clojure_test_2/clojure_test_2/pom.xml
   113 Sat Feb 14 22:25:52 CET 2015 META-INF/maven/clojure_test_2/clojure_test_2/pom.properties
</pre>

<p><i>Leiningen</i> samozřejmě celý projekt přeložil ze zdrojových kódů přímo
do javovského bajtkódu (překlad je komplikovanější, protože se provádí po
funcích):</p>

<pre>
     0 Sat Feb 14 22:25:56 CET 2015 clojure_test_2/
  1559 Sat Feb 14 22:25:56 CET 2015 clojure_test_2/core$_main.class
  2996 Sat Feb 14 22:25:56 CET 2015 clojure_test_2/core__init.class
  1859 Sat Feb 14 22:25:54 CET 2015 clojure_test_2/core$loading__4958__auto__.class
  1338 Sat Feb 14 22:25:56 CET 2015 clojure_test_2/core$fn__148.class
  1799 Sat Feb 14 22:25:54 CET 2015 clojure_test_2/core.class
</pre>

<p>A konečně můžeme v&nbsp;archivu nalézt i třídy knihovny
<strong>clojure.data.json</strong>, která je naším testovacím projektem
využívána:</p>

<pre>
     0 Sat Feb 14 22:25:54 CET 2015 clojure/
     0 Sat Feb 14 22:25:56 CET 2015 clojure/data/
  2021 Sat Feb 14 22:25:56 CET 2015 clojure/data/json$pprint_dispatch.class
  3219 Sat Feb 14 22:25:54 CET 2015 clojure/data/json$write_object.class
  2562 Sat Feb 14 22:25:54 CET 2015 clojure/data/json$read_array.class
  3035 Sat Feb 14 22:25:54 CET 2015 clojure/data/json$loading__4958__auto__.class
   722 Sat Feb 14 22:25:54 CET 2015 clojure/data/json$fn__70$G__66__73.class
   957 Sat Feb 14 22:25:54 CET 2015 clojure/data/json$fn__97$fn__98.class
  1168 Sat Feb 14 22:25:54 CET 2015 clojure/data/json$pprint_object$fn__111.class
   787 Sat Feb 14 22:25:56 CET 2015 clojure/data/json$pprint_object$iter__114__118.class
  1294 Sat Feb 14 22:25:54 CET 2015 clojure/data/json$write_float.class
  1662 Sat Feb 14 22:25:56 CET 2015 clojure/data/json$pprint_generic.class
  1378 Sat Feb 14 22:25:56 CET 2015 clojure/data/json$pprint_object.class
   668 Sat Feb 14 22:25:54 CET 2015 clojure/data/json$write_plain.class
  1714 Sat Feb 14 22:25:54 CET 2015 clojure/data/json$fn__70$G__65__77.class
  3591 Sat Feb 14 22:25:54 CET 2015 clojure/data/json$write.class
  1545 Sat Feb 14 22:25:54 CET 2015 clojure/data/json$fn__97.class
  1365 Sat Feb 14 22:25:54 CET 2015 clojure/data/json$write_ratio.class
  1806 Sat Feb 14 22:25:54 CET 2015 clojure/data/json$fn__23.class
  1047 Sat Feb 14 22:25:54 CET 2015 clojure/data/json$write_named.class
   767 Sat Feb 14 22:25:54 CET 2015 clojure/data/json$read_integer$fn__44.class
     0 Sat Feb 14 22:25:54 CET 2015 clojure/data/json/
   138 Sat Feb 14 22:25:54 CET 2015 clojure/data/json/JSONWriter.class
  1164 Sat Feb 14 22:25:56 CET 2015 clojure/data/json$pprint_json.class
  2047 Sat Feb 14 22:25:54 CET 2015 clojure/data/json$read_hex_char.class
  1255 Sat Feb 14 22:25:56 CET 2015 clojure/data/json$print_json.class
  1167 Sat Feb 14 22:25:54 CET 2015 clojure/data/json$pprint_array$fn__105.class
   701 Sat Feb 14 22:25:54 CET 2015 clojure/data/json$write_null.class
   588 Sat Feb 14 22:25:54 CET 2015 clojure/data/json$default_value_fn.class
  3661 Sat Feb 14 22:25:54 CET 2015 clojure/data/json$codepoint_clause.class
  3061 Sat Feb 14 22:25:54 CET 2015 clojure/data/json$read.class
  3574 Sat Feb 14 22:25:54 CET 2015 clojure/data/json$read_object.class
   970 Sat Feb 14 22:25:54 CET 2015 clojure/data/json$codepoint.class
  2866 Sat Feb 14 22:25:56 CET 2015 clojure/data/json$read_json.class
  2588 Sat Feb 14 22:25:54 CET 2015 clojure/data/json$read_number$fn__49.class
  1039 Sat Feb 14 22:25:54 CET 2015 clojure/data/json$write_bignum.class
  1769 Sat Feb 14 22:25:54 CET 2015 clojure/data/json$default_write_key_fn.class
  1298 Sat Feb 14 22:25:54 CET 2015 clojure/data/json$write_double.class
  1213 Sat Feb 14 22:25:54 CET 2015 clojure/data/json$read_str.class
  2093 Sat Feb 14 22:25:54 CET 2015 clojure/data/json$pprint_object$iter__114__118$fn__119$fn__120.class
  1898 Sat Feb 14 22:25:54 CET 2015 clojure/data/json$write_array.class
  1884 Sat Feb 14 22:25:54 CET 2015 clojure/data/json$fn__67.class
  3002 Sat Feb 14 22:25:56 CET 2015 clojure/data/json$pprint.class
   868 Sat Feb 14 22:25:54 CET 2015 clojure/data/json$fn__70.class
  1447 Sat Feb 14 22:25:54 CET 2015 clojure/data/json$read_integer.class
  1249 Sat Feb 14 22:25:54 CET 2015 clojure/data/json$write_str.class
  2646 Sat Feb 14 22:25:54 CET 2015 clojure/data/json$read_escaped_char.class
  1253 Sat Feb 14 22:25:54 CET 2015 clojure/data/json$pprint_array.class
  1166 Sat Feb 14 22:25:54 CET 2015 clojure/data/json$read_decimal.class
  2008 Sat Feb 14 22:25:54 CET 2015 clojure/data/json$read_quoted_string.class
  3083 Sat Feb 14 22:25:56 CET 2015 clojure/data/json$pprint_object$iter__114__118$fn__119.class
  1290 Sat Feb 14 22:25:56 CET 2015 clojure/data/json$write_json.class
 29064 Sat Feb 14 22:25:56 CET 2015 clojure/data/json__init.class
  4993 Sat Feb 14 22:25:54 CET 2015 clojure/data/json$_read.class
  5390 Sat Feb 14 22:25:56 CET 2015 clojure/data/json_compat_0_1__init.class
  2378 Sat Feb 14 22:25:54 CET 2015 clojure/data/json$codepoint_case.class
  1164 Sat Feb 14 22:25:56 CET 2015 clojure/data/json$json_str.class
  1363 Sat Feb 14 22:25:54 CET 2015 clojure/data/json$read_number.class
  1659 Sat Feb 14 22:25:54 CET 2015 clojure/data/json$write_generic.class
  1667 Sat Feb 14 22:25:56 CET 2015 clojure/data/json$pprint_generic$fn__133.class
 10739 Sat Feb 14 22:25:54 CET 2015 clojure/data/json$write_string.class
</pre>



<p><a name="k08"></a></p>
<h2 id="k08">8. Spuštění projektu s&nbsp;využitím Java archivu</h2>

<p>Java archiv vytvořený postupem popsaným <a href="#k07">v&nbsp;předchozí
kapitole</a> je možné použít pro spuštění aplikace. Musí se však zajistit, aby
virtuální stroj jazyka Java našel i Java archiv se samotným runtime systémem
<i>Clojure</i>. Pro jednoduchost předpokládejme, že soubor
<strong>clojure-1.6.0.jar</strong> (popř.&nbsp;symbolický link na tento soubor)
je umístěn v&nbsp;adresáři <strong>target</strong>. Spuštění je relativně
snadné &ndash; musí se jen nastavit <i>classpath</i> a specifikovat jméno třídy
s&nbsp;metodou <strong>main</strong> (což je v&nbsp;tomto případě shodné se
jmenným prostorem našeho projektu):</p>

<pre>
cd target
java -classpath clojure-1.6.0.jar:clojure_test_2-0.1.0-SNAPSHOT.jar clojure_test_2.core
</pre>

<p>Aplikace se skutečně korektně spustí:</p>

<pre>
{"title":"What's Good About Clojure?",
 "url":"http:\/\/www.catalysoft.com\/articles\/goodAboutClojure.html",
 "last-checked":"Sat Feb 14 22:21:57 CET 2015"}
</pre>

<p>Lze použít i následující zkratku (viz též <strong>man java</strong>):</p>

<pre>
java -cp "*" clojure_test_2.core
</pre>

<p>Archiv <strong>clojure-1.6.0.jar</strong> se samozřejmě může nacházet i
v&nbsp;jiném adresáři:</p>

<pre>
java -cp /home/tester/src/Clojure/clojure-1.6.0.jar:clojure_test_2-0.1.0-SNAPSHOT.jar clojure_test_2.core
</pre>

<p>Kupodivu je možné použít i starší verze <i>Clojure</i> (to ovšem neplatí za
všech okolností):</p>

<pre>
java -cp /home/tester/src/Clojure/clojure-1.5.1.jar:clojure_test_2-0.1.0-SNAPSHOT.jar clojure_test_2.core
</pre>



<p><a name="k09"></a></p>
<h2 id="k09">9. Vytvoření &bdquo;megaarchivu&ldquo; s&nbsp;projektem i se samotným Clojure</h2>

<p><a href="#k08">V&nbsp;předchozí kapitole</a> ukázaný způsob spouštění
aplikace z&nbsp;javovského archivu je sice použitelný, ovšem v&nbsp;mnoha
případech může být výhodnější, aby archiv obsahoval i samotný <i>Clojure</i>.
Tím se zajistí téměř stoprocentní přenositelnost takto zabalené aplikace i na
další počítače, které musí obsahovat pouze běhové prostředí Javy (ve verzi
minimálně stejné, jaká byla použita pro vytvoření archivu, i když toto omezení
je možné obejít). Poměrně zajímavé může být použití tímto způsobem zabalené
aplikace v&nbsp;obrazu systému pro Docker. Nástroj <i>Leiningen</i> tvorbu
podobných &bdquo;megaarchivů&ldquo; podporuje: nazývá je
<strong>uberjar-y</strong>. Pro jejich vytvoření se používá příkaz <strong>lein
uberjar</strong>, ovšem před jeho provedením je rozumné vyčistit adresář
s&nbsp;projektem příkazem <strong>lein clean</strong>:</p>

<pre>
lein clean
lein uberjar
</pre>

<p><i>Leiningen</i> by po zadání těchto příkazů měl do adresáře
s&nbsp;projektem vygenerovat další soubory, zejména adresář
<strong>target/uberjar</strong>. Jednotlivé verze <i>Leiningenu</i> se ve svém
chování nepatrně odlišují, nicméně získat byste měli přibližně následující
strukturu. Soubor s&nbsp;megaarchivem, který nás nyní zajímá, je vyznačený
tučným písmem:</p>

<pre>
.
├── doc
│   └── intro.md
├── LICENSE
├── project.clj
├── README.md
├── resources
├── src
│   └── clojure_test_2
│       └── core.clj
├── target
│   ├── uberjar
│   │   ├── <strong>clojure_test_2-0.1.0-SNAPSHOT-standalone.jar</strong>
│   │   └── stale
│   │       └── extract-native.dependencies
│   └── uberjar+uberjar
│       ├── classes
│       │   ├── clojure
│       │   │   └── data
│       │   │       ├── json
│       │   │       │   └── JSONWriter.class
│       │   │       ├── json$codepoint_case.class
│       │   │       ├── json$codepoint.class
│       │   │       ├── json$codepoint_clause.class
│       │   │       ├── json_compat_0_1__init.class
│       │   │       ├── json$default_value_fn.class
│       │   │       ├── json$default_write_key_fn.class
│       │   │       ├── json$fn__23.class
│       │   │       ├── json$fn__67.class
│       │   │       ├── json$fn__70.class
│       │   │       ├── json$fn__70$G__65__77.class
│       │   │       ├── json$fn__70$G__66__73.class
│       │   │       ├── json$fn__97.class
│       │   │       ├── json$fn__97$fn__98.class
│       │   │       ├── json__init.class
│       │   │       ├── json$json_str.class
│       │   │       ├── json$loading__4958__auto__.class
│       │   │       ├── json$pprint_array.class
│       │   │       ├── json$pprint_array$fn__105.class
│       │   │       ├── json$pprint.class
│       │   │       ├── json$pprint_dispatch.class
│       │   │       ├── json$pprint_generic.class
│       │   │       ├── json$pprint_generic$fn__133.class
│       │   │       ├── json$pprint_json.class
│       │   │       ├── json$pprint_object.class
│       │   │       ├── json$pprint_object$fn__111.class
│       │   │       ├── json$pprint_object$iter__114__118.class
│       │   │       ├── json$pprint_object$iter__114__118$fn__119.class
│       │   │       ├── json$pprint_object$iter__114__118$fn__119$fn__120.class
│       │   │       ├── json$print_json.class
│       │   │       ├── json$read_array.class
│       │   │       ├── json$_read.class
│       │   │       ├── json$read.class
│       │   │       ├── json$read_decimal.class
│       │   │       ├── json$read_escaped_char.class
│       │   │       ├── json$read_hex_char.class
│       │   │       ├── json$read_integer.class
│       │   │       ├── json$read_integer$fn__44.class
│       │   │       ├── json$read_json.class
│       │   │       ├── json$read_number.class
│       │   │       ├── json$read_number$fn__49.class
│       │   │       ├── json$read_object.class
│       │   │       ├── json$read_quoted_string.class
│       │   │       ├── json$read_str.class
│       │   │       ├── json$write_array.class
│       │   │       ├── json$write_bignum.class
│       │   │       ├── json$write.class
│       │   │       ├── json$write_double.class
│       │   │       ├── json$write_float.class
│       │   │       ├── json$write_generic.class
│       │   │       ├── json$write_json.class
│       │   │       ├── json$write_named.class
│       │   │       ├── json$write_null.class
│       │   │       ├── json$write_object.class
│       │   │       ├── json$write_plain.class
│       │   │       ├── json$write_ratio.class
│       │   │       ├── json$write_str.class
│       │   │       └── json$write_string.class
│       │   ├── clojure_test_2
│       │   │   ├── core.class
│       │   │   ├── core$fn__148.class
│       │   │   ├── core__init.class
│       │   │   ├── core$loading__4958__auto__.class
│       │   │   └── core$_main.class
│       │   └── META-INF
│       │       └── maven
│       │           └── clojure_test_2
│       │               └── clojure_test_2
│       │                   └── pom.properties
│       ├── clojure_test_2-0.1.0-SNAPSHOT.jar
│       └── stale
│           └── extract-native.dependencies
└── test
    └── clojure_test_2
        └── core_test.clj
</pre>

<p>Podívejme se na velikost tohoto souboru, například příkazem ls:</p>

<pre>
ls -l target/uberjar
</pre>

<pre>
total 3728
-rw-r--r-- 1 tester tester 3811198 Uno 14 22:23 clojure_test_2-0.1.0-SNAPSHOT-standalone.jar
drwxr-xr-x 2 tester tester    4096 Uno 14 22:23 stale
</pre>

<p>Vidíme, že se jedná o relativně velký archiv, ovšem není divu, protože
obsahuje jak naši demonstrační aplikaci, tak i všechny potřebné knihovny (zde
konkrétně <strong>clojure.data.json</strong>) i samotný <i>Clojure</i>. Pokud
se chcete podívat na obsah tohoto archivu, lze opět použít nástroj
<strong>jar</strong>:</p>

<pre>
jar tvf target/uberjar/clojure_test_2-0.1.0-SNAPSHOT-standalone.jar
</pre>



<p><a name="k10"></a></p>
<h2 id="k10">10. Spuštění aplikace z&nbsp;&bdquo;megaarchivu&ldquo;</h2>

<p>Ve chvíli, kdy je &bdquo;megaarchiv&ldquo; vytvořen, je možné naši
demonstrační aplikaci spustit velice snadno, a to následujícím způsobem:</p>

<pre>
cd target/uberjar
java -jar clojure_test_2-0.1.0-SNAPSHOT-standalone.jar 
</pre>

<p>Povšimněte si, že není zapotřebí zadávat jméno třídy, v&nbsp;níž se má
vyhledat statická metoda <strong>main</strong>. Dříve, přesněji řečeno při
snaze o spuštění aplikace z&nbsp;Java archivu bez přidaného Clojure, bylo nutné
uvádět jméno této třídy, zde konkrétně <strong>clojure_test_2.core</strong>, ve
skutečnosti se ovšem při použití <strong>java -jar</strong> najde jméno třídy
v&nbsp;metadatech přidaných do javovského archivu nástrojem
<i>Leiningen</i>.</p>

<p>Po spuštění by se na standardní výstup měly vypsat tyto tři řádky:</p>

<pre>
{"title":"What's Good About Clojure?",
 "url":"http:\/\/www.catalysoft.com\/articles\/goodAboutClojure.html",
 "last-checked":"Sat Feb 14 22:24:41 CET 2015"}
</pre>



<p><a name="k11"></a></p>
<h2 id="k11">11. Obsah třetí části článku</h2>

<p>Ve třetí části článku o nástroji <i>Leiningen</i> se budeme podrobněji
zabývat dvěma oblastmi. Tou první je práce s&nbsp;jednotkovými testy,
tj.&nbsp;vytváření a následné spouštění testů. Druhou &ndash; podle mého názoru
dosti zajímavou &ndash; oblastí je využití <i>Leiningenu</i> při tvorbě a
ladění webových aplikací. Seznámíme se s&nbsp;knihovnami <strong>Ring</strong>
(<a
href="https://github.com/ring-clojure/ring">https://github.com/ring-clojure/ring</a>)
a <strong>Hiccup</strong> (<a
href="https://github.com/weavejester/hiccup">https://github.com/weavejester/hiccup</a>),
které je možné použít pro velmi rychlou tvorbu kostry webových aplikací.</p>



<p><a name="k12"></a></p>
<h2 id="k12">12. Odkazy na Internetu</h2>

<ol>

<li>První část článku:<br />
<a href="http://www.root.cz/clanky/leiningen-nastroj-pro-spravu-projektu-napsanych-v-clojure/">http://www.root.cz/clanky/leiningen-nastroj-pro-spravu-projektu-napsanych-v-clojure/</a>
</li>

<li>Leiningen: úvodní stránka<br />
<a href="http://leiningen.org/">http://leiningen.org/</a>
</li>

<li>Leiningen: Git repository<br />
<a href="https://github.com/technomancy/leiningen">https://github.com/technomancy/leiningen</a>
</li>

<li>leiningen-win-installer<br />
<a href="http://leiningen-win-installer.djpowell.net/">http://leiningen-win-installer.djpowell.net/</a>
</li>

<li>Clojure  1: Úvod<br />
<a href="http://www.root.cz/clanky/clojure-aneb-jazyk-umoznujici-tvorbu-bezpecnych-vicevlaknovych-aplikaci-pro-jvm/">http://www.root.cz/clanky/clojure-aneb-jazyk-umoznujici-tvorbu-bezpecnych-vicevlaknovych-aplikaci-pro-jvm/</a>
</li>

<li>Clojure  2: Symboly, kolekce atd.<br />
<a href="http://www.root.cz/clanky/clojure-aneb-jazyk-umoznujici-tvorbu-bezpecnych-vicevlaknovych-aplikaci-pro-jvm-2-cast/">http://www.root.cz/clanky/clojure-aneb-jazyk-umoznujici-tvorbu-bezpecnych-vicevlaknovych-aplikaci-pro-jvm-2-cast/</a>
</li>

<li>Clojure  3: Funkcionální programování<br />
<a href="http://www.root.cz/clanky/clojure-aneb-jazyk-umoznujici-tvorbu-bezpecnych-vicevlaknovych-aplikaci-pro-jvm-3-cast-funkcionalni-programovani/">http://www.root.cz/clanky/clojure-aneb-jazyk-umoznujici-tvorbu-bezpecnych-vicevlaknovych-aplikaci-pro-jvm-3-cast-funkcionalni-programovani/</a>
</li>

<li>Clojure  4: Kolekce, sekvence a lazy sekvence<br />
<a href="http://www.root.cz/clanky/clojure-aneb-jazyk-umoznujici-tvorbu-bezpecnych-vicevlaknovych-aplikaci-pro-jvm-4-cast-kolekce-sekvence-a-lazy-sekvence/">http://www.root.cz/clanky/clojure-aneb-jazyk-umoznujici-tvorbu-bezpecnych-vicevlaknovych-aplikaci-pro-jvm-4-cast-kolekce-sekvence-a-lazy-sekvence/</a>
</li>

<li>Clojure  5: Sekvence, lazy sekvence a paralelní programy<br />
<a href="http://www.root.cz/clanky/clojure-a-bezpecne-aplikace-pro-jvm-sekvence-lazy-sekvence-a-paralelni-programy/">http://www.root.cz/clanky/clojure-a-bezpecne-aplikace-pro-jvm-sekvence-lazy-sekvence-a-paralelni-programy/</a>
</li>

<li>Clojure  6: Podpora pro paralelní programování<br />
<a href="http://www.root.cz/clanky/programovaci-jazyk-clojure-6-futures-nejsou-jen-financni-derivaty/">http://www.root.cz/clanky/programovaci-jazyk-clojure-6-futures-nejsou-jen-financni-derivaty/</a>
</li>

<li>Clojure  7: Další funkce pro paralelní programování<br />
<a href="http://www.root.cz/clanky/programovaci-jazyk-clojure-7-dalsi-podpurne-prostredky-pro-paralelni-programovani/">http://www.root.cz/clanky/programovaci-jazyk-clojure-7-dalsi-podpurne-prostredky-pro-paralelni-programovani/</a>
</li>

<li>Clojure  8: Identity, stavy, neměnné hodnoty a reference<br />
<a href="http://www.root.cz/clanky/programovaci-jazyk-clojure-8-identity-stavy-nemenne-hodnoty-a-referencni-typy/">http://www.root.cz/clanky/programovaci-jazyk-clojure-8-identity-stavy-nemenne-hodnoty-a-referencni-typy/</a>
</li>

<li>Clojure  9: Validátory, pozorovatelé a kooperace s Javou<br />
<a href="http://www.root.cz/clanky/programovaci-jazyk-clojure-9-validatory-pozorovatele-a-kooperace-mezi-clojure-a-javou/">http://www.root.cz/clanky/programovaci-jazyk-clojure-9-validatory-pozorovatele-a-kooperace-mezi-clojure-a-javou/</a>
</li>

<li>Clojure 10: Kooperace mezi Clojure a Javou<br />
<a href="http://www.root.cz/clanky/programovaci-jazyk-clojure-10-kooperace-mezi-clojure-a-javou-pokracovani/">http://www.root.cz/clanky/programovaci-jazyk-clojure-10-kooperace-mezi-clojure-a-javou-pokracovani/</a>
</li>

<li>Clojure 11: Generátorová notace seznamu/list comprehension<br />
<a href="http://www.root.cz/clanky/programovaci-jazyk-clojure-11-generatorova-notace-seznamu-list-comprehension/">http://www.root.cz/clanky/programovaci-jazyk-clojure-11-generatorova-notace-seznamu-list-comprehension/</a>
</li>

<li>Clojure 12: Překlad programů z Clojure do bajtkódu JVM I<br />
<a href="http://www.root.cz/clanky/programovaci-jazyk-clojure-12-preklad-programu-z-clojure-do-bajtkodu-jvm/">http://www.root.cz/clanky/programovaci-jazyk-clojure-12-preklad-programu-z-clojure-do-bajtkodu-jvm/</a>
</li>

<li>Clojure 13: Překlad programů z Clojure do bajtkódu JVM II<br />
<a href="2) http://www.root.cz/clanky/programovaci-jazyk-clojure-13-preklad-programu-z-clojure-do-bajtkodu-jvm-pokracovani/">2) http://www.root.cz/clanky/programovaci-jazyk-clojure-13-preklad-programu-z-clojure-do-bajtkodu-jvm-pokracovani/</a>
</li>

<li>Clojure 14: Základy práce se systémem maker<br />
<a href="http://www.root.cz/clanky/programovaci-jazyk-clojure-14-zaklady-prace-se-systemem-maker/">http://www.root.cz/clanky/programovaci-jazyk-clojure-14-zaklady-prace-se-systemem-maker/</a>
</li>

<li>Clojure 15: Tvorba uživatelských maker<br />
<a href="http://www.root.cz/clanky/programovaci-jazyk-clojure-15-tvorba-uzivatelskych-maker/">http://www.root.cz/clanky/programovaci-jazyk-clojure-15-tvorba-uzivatelskych-maker/</a>
</li>

<li>Clojure 16: Složitější uživatelská makra<br />
<a href="http://www.root.cz/clanky/programovaci-jazyk-clojure-16-slozitejsi-uzivatelska-makra/">http://www.root.cz/clanky/programovaci-jazyk-clojure-16-slozitejsi-uzivatelska-makra/</a>
</li>

<li>Clojure 17: Využití standardních maker v praxi<br />
<a href="http://www.root.cz/clanky/programovaci-jazyk-clojure-17-vyuziti-standardnich-maker-v-praxi/">http://www.root.cz/clanky/programovaci-jazyk-clojure-17-vyuziti-standardnich-maker-v-praxi/</a>
</li>

<li>Clojure 18: Základní techniky optimalizace aplikací<br />
<a href="http://www.root.cz/clanky/programovaci-jazyk-clojure-18-zakladni-techniky-optimalizace-aplikaci/">http://www.root.cz/clanky/programovaci-jazyk-clojure-18-zakladni-techniky-optimalizace-aplikaci/</a>
</li>

<li>Clojure 19: Vývojová prostředí pro Clojure<br />
<a href="http://www.root.cz/clanky/programovaci-jazyk-clojure-19-vyvojova-prostredi-pro-clojure/">http://www.root.cz/clanky/programovaci-jazyk-clojure-19-vyvojova-prostredi-pro-clojure/</a>
</li>

<li>Clojure 20: Vývojová prostředí pro Clojure (Vimu s REPL)<br />
<a href="http://www.root.cz/clanky/programovaci-jazyk-clojure-20-vyvojova-prostredi-pro-clojure-integrace-vimu-s-repl/">http://www.root.cz/clanky/programovaci-jazyk-clojure-20-vyvojova-prostredi-pro-clojure-integrace-vimu-s-repl/</a>
</li>

<li>Clojure 21: ClojureScript aneb překlad Clojure do JS<br />
<a href="http://www.root.cz/clanky/programovaci-jazyk-clojure-21-clojurescript-aneb-preklad-clojure-do-javascriptu/">http://www.root.cz/clanky/programovaci-jazyk-clojure-21-clojurescript-aneb-preklad-clojure-do-javascriptu/</a>
</li>

</ol>



<p></p><p></p>
<p><small>Autor: <a href="http://www.fit.vutbr.cz/~tisnovpa">Pavel Tišnovský</a> &nbsp; 2015</small></p>
</body>
</html>

