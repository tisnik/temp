<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
        "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html>
<head>
<title>Programovací jazyk Clojure - triky při práci s kolekcemi</title>
<meta name="Author" content="Pavel Tisnovsky" />
<meta name="Generator" content="vim" />
<meta http-equiv="content-type" content="text/html; charset=utf-8" />
<style type="text/css">
         body {color:#000000; background:#ffffff;}
         h1  {font-family: arial, helvetica, sans-serif; color:#ffffff; background-color:#c00000; text-align:center; padding-left:1em}
         h2  {font-family: arial, helvetica, sans-serif; color:#ffffff; background-color:#0000c0; padding-left:1em; text-align:left}
         h3  {font-family: arial, helvetica, sans-serif; color:#000000; background-color:#c0c0c0; padding-left:1em; text-align:left}
         h4  {font-family: arial, helvetica, sans-serif; color:#000000; background-color:#e0e0e0; padding-left:1em; text-align:left}
         a   {font-family: arial, helvetica, sans-serif;}
         li  {font-family: arial, helvetica, sans-serif; color:#000000; text-align:justify; width:450px;}
         ol  {font-family: arial, helvetica, sans-serif; color:#000000; text-align:justify; width:450px;}
         ul  {font-family: arial, helvetica, sans-serif; color:#000000; text-align:justify; width:450px;}
         p   {font-family: arial, helvetica, sans-serif; color:#000000; text-align:justify;}
         pre {background:#e0e0e0}
</style>
</head>

<body>

<h1>Programovací jazyk Clojure - triky při práci s kolekcemi</h1>

<h3>Pavel Tišnovský</h3>

<p></p>

<h1>Úvodník</h1>

<p>Ve dvacátém prvním dílu seriálu o programovacím jazyku Clojure i o knihovnách, které jsou pro tento jazyk dostupné, se budeme zabývat popisem některých tipů a triků použitelných při práci se sekvencemi a kolekcemi. Navážeme tak na předchozí část věnovanou především práci s řetězci.</p>



<h2>Obsah</h2>

<p><a href="#k01">1. Programovací jazyk Clojure - triky při práci s kolekcemi</a></p>
<p><a href="#k02">2. Kolekce v&nbsp;programovacím jazyku Clojure</a></p>
<p><a href="#k03">3. Sekvence a rozhraní Seq</a></p>
<p><a href="#k04">4. Funkce pracující se sekvencemi</a></p>
<p><a href="#k05">5. Seznamy</a></p>
<p><a href="#k06">6. Vektory</a></p>
<p><a href="#k07">7. Rozdíly v&nbsp;chování seznamů a vektorů</a></p>
<p><a href="#k08">8. Měnitelné seznamy a vektory (transient collection)</a></p>
<p><a href="#k09">9. Tajemná funkce <strong>contains?</strong></a></p>
<p><a href="#k10">10. Jak tedy zjistit existenci prvku v&nbsp;seznamu či vektoru?</a></p>
<p><a href="#k11">11. Odkazy na předchozí části tohoto seriálu</a></p>
<p><a href="#k12">12. Odkazy na Internetu</a></p>



<p><a name="k01"></a></p>
<h2 id="k01">1. Programovací jazyk Clojure - triky při práci s kolekcemi</h2>

<p><a
href="http://www.root.cz/clanky/programovaci-jazyk-clojure-triky-pri-praci-s-retezci/">V&nbsp;předchozí
části</a> tohoto seriálu jsme se seznámili s&nbsp;některými tipy a triky, které
je v&nbsp;programovacím jazyce <i>Clojure</i> možné použít při práci
s&nbsp;řetězci. Mnohem důležitější pro praktické použití jazyka <i>Clojure</i>
je však seznámení se s&nbsp;nabízenými kolekcemi, protože právě kolekce tvoří
ve většině aplikací naprostý základ při tvorbě strukturovaných uživatelských
datových typů. Jak je ve funkcionálních jazycích zvykem, omezuje se zde
využívání tříd a objektů, namísto toho se intenzivně pracuje
s&nbsp;neměnitelnými (<i>immutable</i>) a persistentními kolekcemi.
Z&nbsp;hlediska dobrého návrhu aplikací i z&nbsp;hlediska případných
optimalizací je výhodné se alespoň přibližně seznámit s&nbsp;vnitřní strukturou
kolekcí a se složitostí operací prováděných s&nbsp;kolekcemi. V&nbsp;případě
potřeby je však možné přímo v&nbsp;Clojure využít i původní měnitelné
(<i>mutable</i>) kolekce nabízené knihovnami programovacího jazyka Java, použít
tzv.&nbsp;dočasné kolekce (<i>transient collections</i>) popř.&nbsp;existuje i
poměrně pěkně zpracované rozhraní umožňující práci s&nbsp;klasickými javovskými
poli (<i>arrays</i>).</p>

<p>Programovací jazyk <i>Clojure</i> podporuje jak práci s&nbsp;takzvanými
základními typy (což mohou být například pravdivostní hodnoty, celá čísla,
numerické hodnoty s&nbsp;plovoucí řádovou čárkou, zlomky, znaky, symboly a
keywords), tak i s&nbsp;kolekcemi, s&nbsp;jejichž využitím je možné vytvářet
složitější datové struktury. Mezi čtyři základní typy kolekcí, které nalezneme
v&nbsp;prakticky každé rozsáhlejší aplikaci, patří seznam (<i>list</i>), vektor
(<i>vector</i>), mapa (<i>map</i>) a množina (<i>set</i>). Seznamy přitom mají
poněkud výjimečné postavení, neboť se s&nbsp;jejich využitím zapisuje i samotný
zdrojový kód, což je mimochodem dnes již velmi tradiční zápis používaný před
více než padesáti lety v&nbsp;LISPu a posléze převzatý jak jazykem Scheme, tak
i Clojure.</p>



<p><a name="k02"></a></p>
<h2 id="k02">2. Kolekce v&nbsp;programovacím jazyku Clojure</h2>

<p>Pro zápis vektorů se používají hranaté závorky, mapy využívají závorky
složené a množiny taktéž závorky složené, ovšem před otevírací závorkou se musí
napsat křížek (hash, #). V&nbsp;následující tabulce jsou vypsány všechny čtyři
typy kolekcí. Kromě seznamů lze ostatní tři složené formy (vektory, mapy,
množiny) vytvořit i s&nbsp;využitím vhodného konstruktoru (třetí sloupec),
ovšem přesný význam této formy zápisu si uvedeme až v&nbsp;následujících
kapitolách:</p>

<table>
<tr><th>#</th><th>Typ kolekce</th><th>Zápis (syntaktický cukr)</th><th>Konstruktor</th></tr>
<tr><td>1</td><td>Seznam </td><td>(prvky)</td><td>'(prvky)<br />(list prvky)</td></tr>
<tr><td>2</td><td>Vektor </td><td>[prvky]</td><td>(vector prvky)<br />(vec kolekce)</td></tr>
<tr><td>3</td><td>Mapa   </td><td>{dvojice klíč-hodnota}</td><td>(hash-map dvojice klíč-hodnota)<br />(sorted-map dvojice klíč-hodnota)</td></tr>
<tr><td>4</td><td>Množina</td><td>#{unikátní prvky}</td><td>(hash-set unikátní prvky)<br />(sorted-set unikátní prvky)</td></tr>
</table>

<p>Podívejme se ještě na to, v&nbsp;jakých třídách jsou jednotlivé kolekce
deklarovány a jaká rozhraní tyto třídy implementují:</p>

<table>
<tr><th>#</th><th>Kolekce</th><th>Implementované rozhraní</th><th>Implementováno v...</th><th>Predikát</th></tr>
<tr><td>1</td><td>Seznam </td><td>IPersistentList  </td><td>PersistentList.java</td><td>list?</td></tr>
<tr><td>2</td><td>Vektor </td><td>IPersistentVector</td><td>PersistentVector.java</td><td>vector?</td></tr>
<tr><td>3</td><td>Mapa   </td><td>IPersistentMap   </td><td>PersistentArrayMap.java<br />PersistentHashMap.java<br />PersistentTreeMap.java</td><td>map?</td></tr>
<tr><td>4</td><td>Množina</td><td>IPersistentSet   </td><td>PersistentHashSet.java<br />PersistentTreeSet.java</td><td>set?</td></tr>
</table>

<p>Vidíme, že některé typy kolekcí mají větší počet implementací, což je ale
pochopitelné, protože mapy a množiny mohou být buď seřazené (a interně tedy
založené na datové struktuře stromu) či neseřazené (a založené na hashovací
mapě).</p>

<p>Při volbě vhodné kolekce, která má tvořit základ uživatelem definované
datové struktury ve vyvíjené aplikaci, se vývojář může orientovat i podle toho,
jaké rozhraní (ve smyslu programovacího jazyka Java) jednotlivé kolekce
implementují. Tím jsou určeny základní vlastnosti každé kolekce:</p>

<table>
<tr><th>Rozhraní</th><th>seznam</th><th>vektor</th><th>mapa</th><th>množina</th></tr>
<tr><td>java.util.Collection  </td><td>ano</td><td>ano</td><td>ne </td><td>ano</td></tr>
<tr><td>java.util.List        </td><td>ano</td><td>ano</td><td>ne </td><td>ne </td></tr>
<tr><td>java.util.Map         </td><td>ne </td><td>ne </td><td>ano</td><td>ne </td></tr>
<tr><td>java.util.Set         </td><td>ne </td><td>ne </td><td>ne </td><td>ano</td></tr>
<tr><td>java.util.RandomAccess</td><td>ne </td><td>ano</td><td>ne </td><td>ne </td></tr>
<tr><td>java.lang.Iterable    </td><td>ano</td><td>ano</td><td>ano</td><td>ano</td></tr>
<tr><td>java.lang.Comparable  </td><td>ne </td><td>ano</td><td>ne </td><td>ne </td></tr>
</table>

<p>Další vlastnosti jsou společné všem kolekcím:</p>

<ul>
<li>Kolekce jsou neměnitelné (immutable), kolekci je tak možné sdílet mezi více
vlákny i bez použití zámků či dalších synchronizačních mechanizmů.</li>
<li>Kolekce jsou perzistentní.</li>
<li>Mezi libovolným počtem kolekcí jazyk zajišťuje sdílení struktury (viz další
text), pokud je to možné.</li>
<li>U všech kolekcí lze zjistit počet prvků funkcí <strong>count</strong>.</li>
<li>Každá kolekce je mapovatelná na <a href="#k03">sekvenci</a> a je tedy možné
procházet všemi prvky kolekce.</li>
<li>Ke každé kolekci je možné &bdquo;přidat&ldquo; nový prvek funkcí
<strong>conj</strong>, výsledkem je nová kolekce.</li>
</ul>

<p>Funkce společné všem kolekcím:</p>

<table>
<tr><th> #</th><th>Funkce</th><th>Význam funkce</th></tr>
<tr><td> 1</td><td>count </td><td>vrátí počet prvků v kolekci</td></tr>
<tr><td> 2</td><td>empty?</td><td>(<i>s otazníkem na konci</i>) vrátí <strong>true</strong> v&nbsp;případě, že je kolekce prázdná</td></tr>
<tr><td> 3</td><td>empty</td><td>(<i>bez otazníku</i>) vrátí prázdnou kolekci stejného typu</td></tr>
<tr><td> 4</td><td>not-empty</td><td>pokud není parametrem prázdná kolekce, vrátí se tato kolekce, jinak se vrátí <strong>nil</strong></td></tr>
<tr><td> 5</td><td>distinct?</td><td>vrací <strong>true</strong>, pokud se všechny prvky kolekce od sebe liší</td></tr>
<tr><td> 6</td><td>sequential?</td><td>vrací <strong>true</strong> pro vektory, seznamy a sekvence</td></tr>
<tr><td> 7</td><td>associative?</td><td>vrací <strong>true</strong> pro asociativní typy: vektory (klíčem jsou celá čísla), mapy a struktury</td></tr>
<tr><td> 8</td><td>cons</td><td>vrátí novou kolekci s&nbsp;přidaným prvkem (odkaz jazyka <i>LISP</i>)</td></tr>
<tr><td> 9</td><td>pop</td><td>vrátí kolekci bez prvního prvku (seznamy) nebo bez prvku posledního (vektory)</td></tr>
<tr><td>10</td><td>peek</td><td>vrátí první prvek (seznam), popř.&nbsp;poslední prvek (vektor)</td></tr>
<tr><td>11</td><td>nth</td><td>získání n-tého prvku kolekce</td></tr>
<tr><td>12</td><td>first</td><td>první prvek kolekce</td></tr>
<tr><td>13</td><td>rest</td><td>kolekce bez prvního prvku</td></tr>
</table>



<p><a name="k03"></a></p>
<h2 id="k03">3. Sekvence a rozhraní Seq</h2>

<p>S&nbsp;kolekcemi velmi úzce souvisí i takzvané <i>sekvence</i>. Tímto
termínem se v&nbsp;programovacím jazyce Clojure označuje programové rozhraní,
které svými základními možnostmi zhruba odpovídá <i>iterátorům</i> známým
z&nbsp;programovacího jazyka Java (iterátory jsou však &bdquo;kurzory&ldquo;
v&nbsp;měnitelných kolekcích, kdežto v&nbsp;Clojure jsou kolekce, jak již víme,
neměnitelné). V&nbsp;základní knihovně programovacího jazyka Clojure existuje
velké množství funkcí, které dokážou pracovat se sekvencemi, ať již se jedná o
běžné sekvence (jejichž prvky jsou přímo uloženy v&nbsp;paměti), nebo takzvané
líné sekvence (<i>lazy sekvence</i>), které nové prvky vytváří či zjišťují až
při konkrétním přístupu na tyto prvky. Mezi tyto funkce patří například
<strong>sort</strong>, <strong>sort-by</strong>, <strong>reverse</strong> či
<strong>flatten</strong>. Díky tomu, že všechny kolekce (viz <a
href="#k02">předchozí kapitolu</a>) jsou současně i sekvencemi, lze tyto funkce
aplikovat i na kolekce, ovšem ve skutečnosti jsou sekvencemi i další typy
objektů &ndash; I/O proudy (je možná škoda, že se tímto směrem nevyvinulo API
Javy, které je zrovna v&nbsp;případě I/O operací dosti složité), řetězce (což
jsou sekvence znaků, viz též předchozí část tohoto seriálu) atd.</p>

<p>Naprostý základ pro práci se sekvencemi tvoří trojice funkcí nazvaných
<strong>first</strong>, <strong>rest</strong> a <strong>next</strong>. Funkce
<strong>first</strong> vrací první prvek v&nbsp;sekvenci, popř.&nbsp; speciální
hodnotu <strong>nil</strong> v&nbsp;případě, že je sekvence prázdná. Funkce
<strong>rest</strong> i <strong>next</strong> vrací zbylé prvky
v&nbsp;sekvenci, ovšem liší se tím, jaká hodnota se vrátí ve chvíli, kdy již
v&nbsp;sekvenci nezbyly žádné prvky (kromě prvního). V&nbsp;tomto případě vrátí
<strong>rest</strong> prázdnou sekvenci (například prázdný seznam), zatímco
funkce <strong>next</strong> vrátí hodnotu <strong>nil</strong>. U běžných
sekvencí, například seznamů, jsou tyto funkce implementovány přímočaře, ovšem
v&nbsp;případě <i>lazy sekvencí</i> se prvky vrácené pomocí funkce
<strong>first</strong> vyhodnocují až za běhu aplikace, například pomocí nějaké
generátorové funkce. Tímto způsobem je možné pracovat i s&nbsp;nekonečnými
sekvencemi, u nichž už z&nbsp;principu nelze dopředu znát celkový počet prvků
atd.</p>

<table>
<tr><th>#</th><th>Funkce z&nbsp;rozhraní Seq</th><th>Stručný popis</th></tr>
<tr><td>1</td><td>(first coll)</td><td>vrací první prvek sekvence</td></tr>
<tr><td>2</td><td>(rest coll)</td><td>vrací zbytek sekvence (bez prvního prvku), může vrátit i prázdnou sekvenci</td></tr>
<tr><td>3</td><td>(next coll)</td><td>vrací novou sekvenci odvozenou od původní sekvence bez prvního prvku, může vrátit hodnotu <strong>nil</strong></td></tr>
<tr><td>3</td><td>(cons coll)</td><td>vrací novou sekvenci, na jejíž první místo byl přidán nový prvek</td></tr>
</table>



<p><a name="k04"></a></p>
<h2 id="k04">4. Funkce pracující se sekvencemi</h2>

<p>V&nbsp;základní knihovně programovacího jazyka Clojure existuje několik
desítek funkcí, které nějakým způsobem pracují se sekvencemi. Poměrně velké
množství dostupných funkcí sice může být zpočátku matoucí, ovšem na tomto místě
je vhodné si uvědomit, že se autor jazyka Clojure držel poučky, že je lepší mít
k&nbsp;dispozici sto odladěných, dokumentovaných a optimalizovaných funkcí
pracujících nad jediným datovým typem, než deset různých tříd, kde každá třída
implementuje deset různých metod. V&nbsp;této kapitole se s&nbsp;některými
funkcemi pracujícími s&nbsp;kolekcemi seznámíme, a to formou jednoduchých
příkladů.</p>

<p>Nejprve se podívejme na způsob vytvoření sekvence, a to buď zcela nové
sekvence (popř.&nbsp;lazy sekvence) nebo sekvence vzniklé z&nbsp;kolekce:</p>

<p>Sekvence od 0 do devíti (asi nejjednodušší příklad reálného použití funkce
<strong>range</strong>):</p>

<pre>
user=&gt; <strong>(range 10)</strong>
(0 1 2 3 4 5 6 7 8 9)
</pre>

<p>Nulová hodnota je tolerována:</p>

<pre>
user=&gt; <strong>(range 0)</strong>
()
</pre>

<p>Záporná hodnota je taktéž tolerována:</p>

<pre>
user=&gt; <strong>(range -10)</strong>
()
</pre>

<p>Vrací lazy sekvenci od 10 do 19:</p>

<pre>
user=&gt; <strong>(range 10 20)</strong>
(10 11 12 13 14 15 16 17 18 19)
</pre>

<p>Podobný příklad, ale s&nbsp;krokem 2:</p>

<pre>
user=&gt; <strong>(range 10 20 2)</strong>
(10 12 14 16 18)
</pre>

<p>Lze použít i záporný krok:</p>

<pre>
user=&gt; <strong>(range 20 10 -1)</strong>
(20 19 18 17 16 15 14 13 12 11)
</pre>

<p>...různý od 1:</p>

<pre>
user=&gt; <strong>(range 20 10 -2)</strong>
(20 18 16 14 12)
</pre>

<p>(Lazy) sekvenci je možné vytvořit i s&nbsp;využitím funkce
<strong>repeat</strong>:</p>

<pre>
user=&gt; <strong>(repeat 10 1)</strong>
(1 1 1 1 1 1 1 1 1 1)
</pre>

<pre>
user=&gt; <strong>(repeat 10 "a")</strong>
("a" "a" "a" "a" "a" "a" "a" "a" "a" "a")
</pre>

<p>Pro pohled na libovolnou kolekci jako na sekvenci slouží funkce
<strong>seq</strong>:</p>

<pre>
user=&gt; <strong>(seq [1 2 3])</strong>
(1 2 3)
</pre>

<p>Konečně se dostáváme k&nbsp;zajímavému tématu &ndash; k&nbsp;funkci
<strong>map</strong>. V&nbsp;nejjednodušším případě funkce <strong>map</strong>
aplikuje nějakou jinou funkci na všechny prvky nějaké sekvence a výsledkem této
operace je nová (lazy) sekvence. Sice to může znít složitě, ale použití funkce
<strong>map</strong> je ve skutečnosti dosti jednoduché, protože již víme, že
funkce jsou v&nbsp;Clojure plnohodnotným datovým typem a tudíž je lze předat
jako parametr jiné funkci.</p>

<p>Aplikace funkce <strong>inc</strong> na každý prvek sekvence (zde
vektoru):</p>

<pre>
user=&gt; <strong>(map inc [1 2 3 4 5 6 7 8])</strong>
(2 3 4 5 6 7 8 9)
</pre>

<p>U seznamů si musíme dát pozor na jejich quotování:</p>

<pre>
user=&gt; <strong>(map inc '(1 2 3 4 5 6 7 8))</strong>
(2 3 4 5 6 7 8 9)
</pre>

<p>Sekvenci lze samozřejmě vytvořit i pomocí funkcí <strong>range</strong> a
<strong>repeat</strong> (což jsme si již ukázali výše):</p>

<pre>
user=&gt; <strong>(map inc (range 1 9))</strong>
(2 3 4 5 6 7 8 9)
</pre>

<p>Ještě zajímavější je aplikace nějaké funkce s&nbsp;větší aritou než 1 na
dvojici, trojici atd. sekvencí:</p>

<pre>
user=&gt; <strong>(map * [1 2 3 4] [5 6 7 8])</strong>
(5 12 21 32)
</pre>

<p>Dtto se seznamy:</p>

<pre>
user=&gt; <strong>(map * '(1 2 3 4) '(5 6 7 8))</strong>
(5 12 21 32)
</pre>

<pre>
user=&gt; <strong>(map * (range 1 5) (range 5 9))</strong>
(5 12 21 32)
</pre>

<p>Hmm, tato číselná řada se tuším nějak jmenovala...</p>

<pre>
user=&gt; <strong>(map / (range 10) (range 1 10))</strong>
(0 1/2 2/3 3/4 4/5 5/6 6/7 7/8 8/9)
</pre>

<p>Samozřejmě lze použít například i funkci &bdquo;větší než&ldquo;:</p>

<pre>
user=&gt; <strong>(map &gt; (range 1 10) (range 10 1 -1))</strong>
(false false false false false true true true true)
</pre>

<p>Popř.&nbsp;<strong>compare</strong> vracející -1, 0, či 1:</p>

<pre>
user=&gt; <strong>(map compare (range 1 10) (range 10 1 -1))</strong>
(-1 -1 -1 -1 -1 1 1 1 1)
</pre>



<p><a name="k05"></a></p>
<h2 id="k05">5. Seznamy</h2>

<p>Programovací jazyk <i>LISP</i>, který je ideovým předchůdcem jazyka
<i>Clojure</i>, byl původně založen prakticky pouze na použití seznamů, které
byly považovány za zcela univerzální datovou strukturu. V&nbsp;tradičních
<i>LISPech</i> jsou seznamy implementované pomocí takzvaných tečka-dvojic
(<i>dot-pair</i>), což jsou dvojice prvků, přičemž každý prvek buď může
obsahovat nějakou hodnotu nebo obsahuje odkaz na další tečka-dvojici. Běžný
seznam pak byl vytvořen jako jednosměrně vázaný lineární seznam složený
z&nbsp;tečka-dvojic, kde první prvek ve dvojici obsahoval nějakou hodnotu a
druhý prvek pak odkaz na prvek následující. U některých variant programovacího
jazyka <i>LISP</i> se navíc obsah každého prvku v&nbsp;tečka dvojici rozděloval
na takzvaný <i>tag</i> (řekněme zjednodušeně popis datového typu) a vlastní
hodnotu, což bylo z&nbsp;hlediska obsazení operační paměti poměrně efektivní
řešení. Pro přístup k&nbsp;prvkům seznamů se používaly dvě funkce pojmenované
z&nbsp;historických důvodů <strong>car</strong> a <strong>cdr</strong>. Funkce
<strong>car</strong> vracela první prvek seznamu a funkce <strong>cdr</strong>
zbytek seznamu, tj.&nbsp;všechny prvky následující. V&nbsp;Clojure jsou tyto
funkce nahrazeny funkcemi pro práci se sekvencemi: <strong>first</strong>,
<strong>next</strong> a <strong>rest</strong>, s&nbsp;nimiž jsme se již
seznámili.</p>

<p>Podívejme se na použití seznamů v&nbsp;příkladech:</p>

<p>Vytvoření seznamu:</p>

<pre>
user=&gt; <strong>(list 1 2 3)</strong>
(1 2 3)
&nbsp;
user=&gt; <strong>'(1 2 3)</strong>
(1 2 3)
</pre>

<p>Mezi funkcí <strong>list</strong> a quotováním je rozdíl:</p>

<pre>
user=&gt; <strong>(list (* 6 7) 10 10)</strong>
(42 10 10)
&nbsp;
user=&gt; <strong>'((*6 7) 10 10)</strong>
((*6 7) 10 10)
</pre>

<p>Další možnosti vytvoření seznamu:</p>

<pre>
user=&gt; <strong>(apply list [1 2 3])</strong>
(1 2 3)
&nbsp;
user=&gt; <strong>(into '() [1 2 3])</strong>
(3 2 1)
</pre>

<p>Ukázka sdílení struktury seznamu:</p>

<pre>
user=&gt; <strong>(def seznam '(1 2 3))</strong>
#'user/seznam
&nbsp;
user=&gt; <strong>seznam</strong>
(1 2 3)
&nbsp;
user=&gt; <strong>(def seznam1 (conj seznam 4))</strong>
#'user/seznam1
&nbsp;
user=&gt; <strong>(def seznam2 (conj seznam "hello"))</strong>
#'user/seznam2
&nbsp;
user=&gt; <strong>seznam</strong>
(1 2 3)
&nbsp;
user=&gt; <strong>seznam1</strong>
(4 1 2 3)
&nbsp;
user=&gt; <strong>seznam2</strong>
("hello" 1 2 3)
</pre>

<p>Operace <strong>rest</strong> a <strong>pop</strong> se někdy chovají
odlišně (konkrétně při aplikaci na prázdný seznam):</p>

<pre>
user=&gt; <strong>(rest seznam)</strong>
(2 3)
&nbsp;
user=&gt; <strong>(pop seznam)</strong>
(2 3)
&nbsp;
user=&gt; <strong>(type (rest seznam))</strong>
clojure.lang.PersistentList
&nbsp;
user=&gt; <strong>(type (pop seznam))</strong>
clojure.lang.PersistentList
&nbsp;
user=&gt; <strong>(rest '())</strong>
()
&nbsp;
user=&gt; <strong>(pop '())</strong>
IllegalStateException Can't pop empty list  clojure.lang.PersistentList$EmptyList.pop (PersistentList.java:178)
</pre>

<p>Výsledky predikátů a funkce pro zjištění typu:</p>

<pre>
user=&gt; <strong>(list? seznam)</strong>
true
&nbsp;
user=&gt; <strong>(seq? seznam)</strong>
true
&nbsp;
user=&gt; <strong>(type seznam)</strong>
clojure.lang.PersistentList
&nbsp;
user=&gt; <strong>(def x (range 1 10))</strong>
#'user/x
&nbsp;
user=&gt; <strong>(list? x)</strong>
false
&nbsp;
user=&gt; <strong>(seq? x)</strong>
true
&nbsp;
user=&gt; <strong>(type x)</strong>
clojure.lang.LazySeq
</pre>



<p><a name="k06"></a></p>
<h2 id="k06">6. Vektory</h2>

<p>V&nbsp;programovacím jazyku <i>Clojure</i> se na mnoha místech seznamy
nahrazují za vektory, protože práce s&nbsp;vektory může být více efektivní.
Vektor můžeme považovat za jednorozměrné pole hodnot libovolných typů, takže by
se mohlo zdát, že složitost přístupu k&nbsp;jeho prvkům bude konstantní
<i>O(N)</i>. Ve skutečnosti jsou však vektory interně implementovány poněkud
složitějším (a velmi zajímavým) způsobem a to především z&nbsp;toho důvodu, aby
bylo snadné k&nbsp;vektorům připojovat další prvky &ndash; tak vznikne nový
vektor, ovšem původní vektor musí samozřejmě zůstat zachovaný. Proto se
v&nbsp;<i>Clojure</i> (a v&nbsp;některých dalších moderních programovacích
jazycích) používají pro implementaci vektorů takzvané <i>RRB-Stromy (RRB-Trees,
Relaxed Radix Balanced Trees)</i>. V&nbsp;<i>Clojure</i> jsou použity
(vyvážené) RRB-stromy, které mají v&nbsp;každém listu uloženo jednorozměrné
pole o délce 32 prvků. Pokud se pracuje s&nbsp;kratším vektorem, je pro jeho
uložení použit strom pouze s&nbsp;jedním listem a tudíž je vektor skutečně
reprezentován jednorozměrným polem (ve skutečnosti se vedle vlastního stromu
používá ještě pomocné pole <strong>tail</strong>, pro jednoduchost však jeho
roli v&nbsp;tomto textu poněkud zanedbáme).</p>

<p>U delších vektorů se v&nbsp;32prvkovém poli uloženém v&nbsp;kořenu stromu
<strong>ne</strong>nachází přímo prvky vektoru, ale reference na další listy,
z&nbsp;nichž každý opět obsahuje 32prvkové pole. To znamená, že vektor
s&nbsp;až 1024 prvky může být uložen ve stromu o výšce 1, ve stromu o výšce 2
je celkový (možný) počet prvků vektoru roven 32768 (1024 listů á 32 prvků) atd.
Operace vrácení <i>n</i>-tého prvku má tedy složitost
<i>O(log<sub>32</sub>N)</i>, což sice není konstantní složitost <i>O(1)</i>,
ale pro vektory běžných délek můžeme tuto složitost taktéž považovat za
konstantní. Předností vektorů je tedy rychlejší přístup k&nbsp;jeho prvkům, ale
nesmíme zapomenout ani na paměťové nároky &ndash; vektory interně potřebují
mnohem méně referencí, než je tomu u seznamů, tudíž i paměťové nároky budou
nižší, a to zejména na 64bitových systémech; samozřejmě pokud zde uživatelé
nepovolí použití komprimovaných ukazatelů (<i>compressed oops</i>).</p>

<p>Opět se podívejme na základní příklady:</p>

<p>Několik způsobů vytvoření vektoru:</p>

<pre>
user=&gt; <strong>[1 2 3]</strong>
[1 2 3]
&nbsp;
user=&gt; <strong>(vector 1 2 3)</strong>
[1 2 3]
&nbsp;
user=&gt; <strong>(vec '(1 2 3))</strong>
[1 2 3]
&nbsp;
user=&gt; <strong>(vec (range 1 10))</strong>
[1 2 3 4 5 6 7 8 9]
&nbsp;
user=&gt; <strong>(into [] (range 1 10))</strong>
[1 2 3 4 5 6 7 8 9]
</pre>

<p>Funkce <strong>conj</strong>, <strong>pop</strong> a
<strong>rest</strong>:</p>

<pre>
user=&gt; <strong>(def vektor [1 2 3])</strong>
#'user/vektor
&nbsp;
user=&gt; <strong>(conj vektor 4)</strong>
[1 2 3 4]
&nbsp;
user=&gt; <strong>(pop vektor)</strong>
[1 2]
&nbsp;
user=&gt; <strong>(rest vektor)</strong>
(2 3)
&nbsp;
user=&gt; <strong>(type (rest vektor))</strong>
clojure.lang.PersistentVector$ChunkedSeq
&nbsp;
user=&gt; <strong>(type (pop vektor))</strong>
clojure.lang.PersistentVector
</pre>


<p>Výsledky predikátů a funkce pro zjištění typu:</p>

<pre>
user=&gt; <strong>(vector? vektor)</strong>
true
&nbsp;
user=&gt; <strong>(list? vektor)</strong>
false
&nbsp;
user=&gt; <strong>(seq? vektor)</strong>
false
&nbsp;
user=&gt; <strong>(sequential? vektor)</strong>
true
&nbsp;
user=&gt; <strong>(type vektor)</strong>
clojure.lang.PersistentVector
</pre>



<p><a name="k07"></a></p>
<h2 id="k07">7. Rozdíly v&nbsp;chování seznamů a vektorů</h2>

<p>Programovací jazyk <i>LISP</i>, z&nbsp;něhož je jazyk <i>Clojure</i> do
značné míry odvozen (či možná lépe řečeno inspirován), byl původně založen
prakticky pouze na použití seznamů, které se využívaly jak pro ukládání dat,
tak i pro reprezentaci vlastního programu, protože program (jeho funkce) lze
reprezentovat jako seznam seznamů (tato vlastnost se označuje termínem
<i>homoikonicita/homoiconicity</i>). Stejným způsobem se seznamy používají i
v&nbsp;jazyku <i>Scheme</i> a nejinak je tomu i v&nbsp;programovacím jazyku
<i>Clojure</i>, jenž však, jak již víme z&nbsp;předchozích kapitol, kromě
seznamů poměrně intenzivně používá i vektory (například parametry funkce se
zapisují do vektorů, speciální forma <strong>let</strong> používá vektory,
stejně jako makro <strong>for</strong> atd.), což musí mít svoje opodstatnění.
Seznamy a vektory sice na první pohled vypadají jako vzájemně zaměnitelné
datové typy, ve skutečnosti se však od sebe dosti podstatným způsobem odlišují,
a to především svojí vnitřní strukturou, z&nbsp;níž přímo vyplývají i operace,
které lze s&nbsp;těmito kolekcemi provádět a v&nbsp;neposlední řadě i složitost
jednotlivých operací, která nás dnes taktéž zajímá.</p>

<p>Jeden z&nbsp;rozdílů mezi seznamy a kolekcemi spočívá v&nbsp;tom, že prvky
vektorů je možné číst jako přímou sekvenci i jako sekvenci otočenou (od
posledního prvku k&nbsp;prvku prvnímu). Nad vektorem lze tedy zavolat funkci
<strong>seq</strong> i <strong>rseq</strong>, zatímco u seznamů pouze funkci
<strong>seq</strong> &ndash; prvky lze číst pouze od začátku seznamu do konce.
Další rozdíl mezi seznamy a vektory spočívá v&nbsp;odlišném chování funkce
<strong>conj</strong>, kterou lze použít k&nbsp;vytvoření kopie původní kolekce
doplněné o nové prvky. U seznamů se prvky přidávají na jeho začátek, zatímco u
vektorů je tomu přesně naopak &ndash; vrácen je nový vektor s&nbsp;prvky
přidanými na jeho konci. Podobně se liší chování funkcí <strong>pop</strong> a
<strong>peek</strong>. Shrňme si nyní jednotlivé funkční rozdíly mezi seznamy a
vektory přehledně do tabulky:</p>

<table>
<tr><th>#</th><th>Funkce</th><th>Seznam</th><th>Vektor</th></tr>
<tr><td>1</td><td>seq  </td><td>podporováno</td><td>podporováno</td></tr>
<tr><td>2</td><td>rseq </td><td>není podporováno</td><td>podporováno</td></tr>
<tr><td>3</td><td>conj </td><td>nové prvky + původní seznam</td><td>vektor + nové prvky</td></tr>
<tr><td>4</td><td>pop  </td><td>seznam bez prvního prvku</td><td>vektor bez posledního prvku</td></tr>
<tr><td>5</td><td>peek </td><td>první prvek seznamu</td><td>poslední prvek vektoru</td></tr>
<tr><td>5</td><td>first</td><td>první prvek seznamu</td><td>první prvek vektoru</td></tr>
<tr><td>6</td><td>last </td><td>poslední prvek seznamu</td><td>poslední prvek vektoru</td></tr>
<tr><td>7</td><td>nth  </td><td>n-tý prvek seznamu</td><td>n-tý prvek vektoru</td></tr>
<tr><td>8</td><td>count</td><td>počet prvků seznamu</td><td>počet prvků vektoru</td></tr>
</table>

<p>Důležité je při optimalizaci aplikací i porovnání výpočetní složitosti
některých funkcí z&nbsp;předchozí tabulky, protože právě odlišná složitost může
výrazným způsobem ovlivnit výkonnost celé aplikace, zejména tehdy, pokud se
budou používat kolekce s&nbsp;velkým množstvím prvků. Zajímavé je, že funkce
<strong>count</strong> má v&nbsp;obou případech konstantní složitost:
<i>O(1)</i>. To znamená, že v&nbsp;<i>Clojure</i> nemá smysl počítat počet
prvků seznamu s&nbsp;využitím rekurzivní funkce, což je jeden z&nbsp;oblíbených
školních příkladů používaných při výuce LISPu :-) Naproti tomu funkce
<strong>nth</strong> se sice u obou typů kolekcí chová stejně, má však výrazně
odlišnou složitost: <i>O(n)</i> v&nbsp;případě seznamů (lineární složitost) a
<i>O(log<sub>32</sub>N)</i> v&nbsp;případě vektorů (logaritmická složitost). U
krátkých vektorů (do 32 prvků) je složitost konstantní a i u delších vektorů je
počet kroků nutných pro získání n-tého prvku velmi malý (například dva kroky
pro vektory o délce přibližně 1000 prvků atd.). Složitost funkce
<strong>peek</strong> je v&nbsp;případě vektoru taktéž rovna
<i>O(log<sub>32</sub>N)</i>, na rozdíl od funkce <strong>last</strong> se
složitostí <i>O(N)</i> &ndash; v&nbsp;případě vektorů tedy vždy používejte
<strong>peek</strong>!</p>

<table>
<tr><th>#</th><th>Funkce</th><th>Seznam</th><th>Vektor</th></tr>
<tr><td>1</td><td>count</td><td>O(1)</td><td>O(1)</td></tr>
<tr><td>2</td><td>nth  </td><td>O(N)</td><td>O(log<sub>32</sub>N)</td></tr>
<tr><td>3</td><td>pop  </td><td>O(1)</td><td>O(log<sub>32</sub>N)</td></tr>
<tr><td>4</td><td>peek </td><td>O(1)</td><td>O(log<sub>32</sub>N)</td></tr>
<tr><td>5</td><td>first</td><td>O(1)</td><td>O(1)</td></tr>
<tr><td>6</td><td>last </td><td>O(N)</td><td>O(N)</td></tr>
</table>

<p>Povšimněte si, že vektory ve skutečnosti neodpovídají složitostí některých
funkcí běžně chápaným vektorům-jednorozměrným polím. Je tomu tak z&nbsp;toho
důvodu, že v&nbsp;<i>Clojure</i> jsou vektory implementovány odlišným způsobem
a to zejména proto, aby bylo možné jednoduše implementovat funkci
<strong>conj</strong>, tj.&nbsp;aby se již vytvořená datová struktura mohla
sdílet mezi větším množstvím vektorů (to je možné i díky jejich
neměnnosti).</p>



<p><a name="k08"></a></p>
<h2 id="k08">8. Měnitelné seznamy a vektory (transient collection)</h2>

<p>Jak jsme se již několikrát zmínili v&nbsp;předchozích kapitolách, jsou
všechny základní kolekce nabízené programovacím jazykem <i>Clojure</i> neměnné
a perzistentní. V&nbsp;některých algoritmech z&nbsp;praxe je však nutné kolekci
vytvářet postupně (prvek po prvku) popř.&nbsp;modifikovat hodnoty jednotlivých
prvků. V&nbsp;tomto případě je možné použít takzvané krátkodobé kolekce
(<i>transient collection</i>). Slovo &bdquo;transient&ldquo; naznačuje, že
s&nbsp;takovou kolekcí by se mělo v&nbsp;ideálním případě pracovat pouze
v&nbsp;rámci jediné funkce, přičemž výsledkem této funkce by měla být již
očekávaná neměnná a perzistentní kolekce. Myšlenka je to vlastně logická
&ndash; to, co se děje v&nbsp;rámci jedné funkce, je lokální změna stavu, která
se neprojeví ani v&nbsp;dalších funkcích ani v&nbsp;dalších vláknech, takže zde
je povolena změna kolekce. Jak se ovšem jednou z&nbsp;funkce vrátí nově
vytvořená kolekce, již se nesmí jednat o měnitelnou datovou strukturu.
Předností jsou pak značně rychlejší operace při práci s&nbsp;krátkodobými
kolekcemi.</p>

<p>Při práci s&nbsp;tranzientními :-) kolekcemi se používají tyto nové
funkce:</p>

<ul>
<li><strong>transient</strong> pro vrácení perzistentní kolekce z&nbsp;kolekce
tranzientní (původní kolekce se nemění)</li>
<li><strong>persistent!</strong> pro převod tranzientní kolekce na kolekci
perzistentní (neprovádí se kopie)</li>
<li><strong>assoc!</strong> pro změnu prvku tranzientní kolekce</li>
<li><strong>conj!</strong> pro přidání prvku do tranzientní kolekce</li>
</ul>

<p>Podívejme se na poněkud umělý příklad funkce pro vytvoření vektoru zadané délky:</p>

<pre>
(defn <strong>x1</strong>
    [length]
    (let [vektor (atom [])]
        (doseq [x (range 0 length)]
            (reset! vektor (conj @vektor x)))
            @vektor))
</pre>

<p>Tuto funkci je možné vylepšit použitím <strong>swap!</strong>, nicméně se
stále bude aplikovat <strong>conj</strong> na již existující vektor:</p>

<pre>
(defn <strong>x2</strong>
    [length]
    (let [vektor (atom [])]
        (doseq [x (range 0 length)]
            (swap! vektor conj x))
            @vektor))
</pre>

<p>Řešením je třetí verze nepoužívající atomy ale tranzientní kolekci:</p>

<pre>
(defn <strong>x3</strong>
    [length]
    (let [vektor (transient [])]
        (doseq [x (range 0 length)]
            (conj! vektor x))
            (persistent! vektor)))
</pre>

<p>Povšimněte si, že výslednou hodnotou je běžná perzistentní kolekce!</p>

<p>Příklad z&nbsp;praxe &ndash; získání setříděné množiny obsahující jména
produktů přečtených z&nbsp;knížek:</p>

<pre>
(defn <strong>get-products</strong>
    "Returns sorted set of all products"
    []
    (let [products (transient #{})]
        (doseq [book books/books]
            (let [book-val (val book) 
                  book-product-name (nth book-val 3)
                  book-product-ver  (nth book-val 4)
                  book-product (str book-product-name " " book-product-ver)]
                (conj! products book-product)))
        (into (sorted-set) (persistent! products))))
</pre>



<p><a name="k09"></a></p>
<h2 id="k09">9. Tajemná funkce <strong>contains?</strong></h2>

<p><i>"Indeed, contains? has to be the most misleadingly named function in
Clojure :)"</i></p>

<p>Při práci s&nbsp;kolekcemi je mnohdy nutné zjistit, zda daná kolekce
obsahuje nějaký prvek. První funkcí, kterou většina vývojářů (včetně autora
tohoto článku :-) intuitivně ale chybně použije, je funkce-predikát nazvaná
<strong>contains?</strong>. Podle názvu této funkce by se mohlo zdát, že
v&nbsp;případě, že kolekce obsahuje zadaný <i>prvek</i>, vrátí se pravdivostní
hodnota <strong>true</strong>, v&nbsp;opačném případě pak hodnota
<strong>false</strong> či <strong>nil</strong>. Ve skutečnosti tomu však tak
není, protože predikát <strong>contains?</strong> slouží ke zjištění, zda daná
kolekce obsahuje zadaný <i>klíč</i>, nikoli <i>prvek</i>! Co to znamená
v&nbsp;praxi? Tuto funkci vůbec nejde použít pro seznamy, protože se vyhodí
výjimka typu <strong>IllegalArgumentException</strong>. Dále, pokud je tato
funkce použita pro vektory, bude sice fungovat (nevyhodí se výjimka), ale
vracet se bude <strong>true</strong> pouze tehdy, když funkci
<strong>contains?</strong> předáme správný <i>klíč</i>, přičemž ve vektorech
jsou klíče celočíselné hodnoty (jedná se o indexy prvků).</p>

<pre>
user=&gt; <strong>(doc contains?)</strong>
-------------------------
clojure.core/contains?
([coll key])
  Returns true if key is present in the given collection, otherwise
  returns false.  Note that for numerically indexed collections like
  vectors and Java arrays, this tests if the numeric key is within the
  range of indexes. 'contains?' operates constant or logarithmic time;
  it will not perform a linear search for a value.  See also 'some'.
</pre>

<p>Podívejme se pro jistotu na několik příkladů, na nichž bude chování
popisované funkce patrné:</p>

<pre>
user=&gt; <strong>(def seznam '("a" "b" "c"))</strong>
#'user/seznam
&nbsp;
user=&gt; <strong>(def vektor ["a" "b" "c"])</strong>
#'user/vektor
&nbsp;
&nbsp;
user=&gt; <strong>(contains? seznam "b")</strong>
IllegalArgumentException contains? not supported on type: clojure.lang.PersistentList  clojure.lang.RT.contains (RT.java:724)
&nbsp;
&nbsp;
user=&gt; <strong>(contains? vektor "b")</strong>
false
&nbsp;
user=&gt; <strong>(contains? vektor 1)</strong>
true
&nbsp;
user=&gt; <strong>(contains? vektor 10)</strong>
false
</pre>

<p>Chování funkce <strong>contains?</strong> začne být intuitivní ve chvíli,
kdy je použita pro vyhledání prvků (podle klíčů) v&nbsp;mapě či
v&nbsp;množině:</p>

<pre>
user=&gt; <strong>(def mapa {"a" "acko"  "b" "becko"   "c" "cecko"})</strong>
#'user/mapa
&nbsp;
user=&gt; <strong>(def mnozina #{"a" "b" "c"})</strong>
#'user/mnozina
&nbsp;
&nbsp;
user=&gt; <strong>(contains? mapa "a")</strong>
true
&nbsp;
user=&gt; <strong>(contains? mapa "acko")</strong>
false
&nbsp;
user=&gt; <strong>(contains? mnozina "a")</strong>
true
&nbsp;
user=&gt; <strong>(contains? mnozina "z")</strong>
false
</pre>

<p>Výsledkem je tedy zjištění, že funkce <strong>contains?</strong> má
praktický význam jen při práci s&nbsp;mapami a množinami, nikoli při práci se
seznamy a vektory.</p>



<p><a name="k10"></a></p>
<h2 id="k10">10. Jak tedy zjistit existenci prvku v&nbsp;seznamu či vektoru?</h2>

<p>Jakou funkci tedy mají vývojáři použít namísto <strong>contains?</strong> ve
chvíli, kdy potřebují zjistit, zda seznam či vektor obsahuje nějaký prvek?
Samozřejmě je možné si napsat nějakou funkci vlastní, ovšem již ve standardní
knihovně se nachází použitelná funkce nazvaná <strong>some</strong>. Této
funkci stačí předat množinu hledaných prvků (klidně se může jednat o
jednoprvkovou množinu) a seznam/vektor. Pokud se žádný prvek z&nbsp;předané
množiny v&nbsp;kolekci nenachází, vrátí se hodnota <strong>nil</strong>
(zpracovávaná většinou stejně jako <strong>false</strong>), pokud se prvek či
prvku najdou, je jeden z&nbsp;prvků vrácen (u seznamů a vektorů jde o první
prvek). Připomeňme si, že v&nbsp;<i>Clojure</i> je jakákoli hodnota odlišná od
<strong>nil</strong> či <strong>false</strong> chápána jako pravda, takže náš
problém s&nbsp;vyhledáním prvku nebo prvků je vyřešen.</p>

<pre>
user=&gt; <strong>(doc some)</strong>
-------------------------
clojure.core/some
([pred coll])
  Returns the first logical true value of (pred x) for any x in coll,
  else nil.  One common idiom is to use a set as pred, for example
  this will return :fred if :fred is in the sequence, otherwise nil:
  (some #{:fred} coll)
</pre>

<p>Opět se podívejme na několik příkladů, v&nbsp;nichž se funkce
<strong>some</strong> používá:</p>

<pre>
user=&gt; <strong>(def seznam '("a" "b" "c"))</strong>
#'user/seznam
&nbsp;
user=&gt; <strong>(def vektor ["a" "b" "c"])</strong>
#'user/vektor
&nbsp;
&nbsp;
user=&gt; <strong>(some #{"a"} seznam)</strong>
"a"
&nbsp;
user=&gt; <strong>(some #{"x"} seznam)</strong>
nil
&nbsp;
user=&gt; <strong>(some #{"a"} vektor)</strong>
"a"
&nbsp;
user=&gt; <strong>(some #{"x"} vektor)</strong>
nil
&nbsp;
&nbsp;
user=&gt; <strong>(some #{"a" "c"} seznam)</strong>
"a"
&nbsp;
user=&gt; <strong>(some #{"a" "c"} vektor)</strong>
"a"
&nbsp;
user=&gt; <strong>(some #{"c" "a"} seznam)</strong>
"a"
&nbsp;
user=&gt; <strong>(some #{"c" "a"} vektor)</strong>
"a"
&nbsp;
&nbsp;
user=&gt; <strong>(some #{42 "a"} seznam)</strong>
"a"
&nbsp;
user=&gt; <strong>(some #{42 "a"} vektor)</strong>
"a"
</pre>



<p><a name="k11"></a></p>
<h2 id="k11">11. Odkazy na předchozí části tohoto seriálu</h2>

<ol>

<li>Leiningen: nástroj pro správu projektů napsaných v Clojure<br />
<a href="http://www.root.cz/clanky/leiningen-nastroj-pro-spravu-projektu-napsanych-v-clojure/">http://www.root.cz/clanky/leiningen-nastroj-pro-spravu-projektu-napsanych-v-clojure/</a>
</li>

<li>Leiningen: nástroj pro správu projektů napsaných v Clojure (2)<br />
<a href="http://www.root.cz/clanky/leiningen-nastroj-pro-spravu-projektu-napsanych-v-clojure-2/">http://www.root.cz/clanky/leiningen-nastroj-pro-spravu-projektu-napsanych-v-clojure-2/</a>
</li>

<li>Leiningen: nástroj pro správu projektů napsaných v Clojure (3)<br />
<a href="http://www.root.cz/clanky/leiningen-nastroj-pro-spravu-projektu-napsanych-v-clojure-3/">http://www.root.cz/clanky/leiningen-nastroj-pro-spravu-projektu-napsanych-v-clojure-3/</a>
</li>

<li>Leiningen: nástroj pro správu projektů napsaných v Clojure (4)<br />
<a href="http://www.root.cz/clanky/leiningen-nastroj-pro-spravu-projektu-napsanych-v-clojure-4/">http://www.root.cz/clanky/leiningen-nastroj-pro-spravu-projektu-napsanych-v-clojure-4/</a>
</li>

<li>Leiningen: nástroj pro správu projektů napsaných v Clojure (5)<br />
<a href="http://www.root.cz/clanky/leiningen-nastroj-pro-spravu-projektu-napsanych-v-clojure-5/">http://www.root.cz/clanky/leiningen-nastroj-pro-spravu-projektu-napsanych-v-clojure-5/</a>
</li>

<li>Leiningen: nástroj pro správu projektů napsaných v Clojure (6)<br />
<a href="http://www.root.cz/clanky/leiningen-nastroj-pro-spravu-projektu-napsanych-v-clojure-6/">http://www.root.cz/clanky/leiningen-nastroj-pro-spravu-projektu-napsanych-v-clojure-6/</a>
</li>

<li>Programovací jazyk Clojure a databáze (1.část)<br />
<a href="http://www.root.cz/clanky/programovaci-jazyk-clojure-a-databaze-1-cast/">http://www.root.cz/clanky/programovaci-jazyk-clojure-a-databaze-1-cast/</a>
</li>

<li>Pluginy pro Leiningen<br />
<a href="http://www.root.cz/clanky/leiningen-nastroj-pro-spravu-projektu-napsanych-v-clojure-pluginy-pro-leiningen/">http://www.root.cz/clanky/leiningen-nastroj-pro-spravu-projektu-napsanych-v-clojure-pluginy-pro-leiningen/</a>
</li>

<li>Programovací jazyk Clojure a knihovny pro práci s vektory a maticemi<br />
<a href="http://www.root.cz/clanky/programovaci-jazyk-clojure-a-knihovny-pro-praci-s-vektory-a-maticemi/">http://www.root.cz/clanky/programovaci-jazyk-clojure-a-knihovny-pro-praci-s-vektory-a-maticemi/</a>
</li>

<li>Programovací jazyk Clojure a knihovny pro práci s vektory a maticemi (2)<br />
<a href="http://www.root.cz/clanky/programovaci-jazyk-clojure-a-knihovny-pro-praci-s-vektory-a-maticemi-2/">http://www.root.cz/clanky/programovaci-jazyk-clojure-a-knihovny-pro-praci-s-vektory-a-maticemi-2/</a>
</li>

<li>Programovací jazyk Clojure: syntéza procedurálních textur s využitím knihovny Clisk<br />
<a href="http://www.root.cz/clanky/programovaci-jazyk-clojure-synteza-proceduralnich-textur-s-vyuzitim-knihovny-clisk/">http://www.root.cz/clanky/programovaci-jazyk-clojure-synteza-proceduralnich-textur-s-vyuzitim-knihovny-clisk/</a>
</li>

<li>Programovací jazyk Clojure: syntéza procedurálních textur s využitím knihovny Clisk (2)<br />
<a href="http://www.root.cz/clanky/programovaci-jazyk-clojure-synteza-proceduralnich-textur-s-vyuzitim-knihovny-clisk-2/">http://www.root.cz/clanky/programovaci-jazyk-clojure-synteza-proceduralnich-textur-s-vyuzitim-knihovny-clisk-2/</a>
</li>

<li>Programovací jazyk Clojure: syntéza procedurálních textur s využitím knihovny Clisk (dokončení)<br />
<a href="http://www.root.cz/clanky/programovaci-jazyk-clojure-synteza-proceduralnich-textur-s-vyuzitim-knihovny-clisk-dokonceni/">http://www.root.cz/clanky/programovaci-jazyk-clojure-synteza-proceduralnich-textur-s-vyuzitim-knihovny-clisk-dokonceni/</a>
</li>

<li>Seesaw: knihovna pro snadnou tvorbu GUI v jazyce Clojure<br />
<a href="http://www.root.cz/clanky/seesaw-knihovna-pro-snadnou-tvorbu-gui-v-jazyce-clojure/">http://www.root.cz/clanky/seesaw-knihovna-pro-snadnou-tvorbu-gui-v-jazyce-clojure/</a>
</li>

<li>Seesaw: knihovna pro snadnou tvorbu GUI v jazyce Clojure (2)<br />
<a href="http://www.root.cz/clanky/seesaw-knihovna-pro-snadnou-tvorbu-gui-v-jazyce-clojure-2/">http://www.root.cz/clanky/seesaw-knihovna-pro-snadnou-tvorbu-gui-v-jazyce-clojure-2/</a>
</li>

<li>Seesaw: knihovna pro snadnou tvorbu GUI v jazyce Clojure (3)<br />
<a href="http://www.root.cz/clanky/seesaw-knihovna-pro-snadnou-tvorbu-gui-v-jazyce-clojure-3/">http://www.root.cz/clanky/seesaw-knihovna-pro-snadnou-tvorbu-gui-v-jazyce-clojure-3/</a>
</li>

<li>Programovací jazyk Clojure a práce s Gitem<br />
<a href="http://www.root.cz/clanky/programovaci-jazyk-clojure-a-prace-s-gitem/">http://www.root.cz/clanky/programovaci-jazyk-clojure-a-prace-s-gitem/</a>
</li>

<li>Programovací jazyk Clojure a práce s Gitem (2)<br />
<a href="http://www.root.cz/clanky/programovaci-jazyk-clojure-a-prace-s-gitem-2/">http://www.root.cz/clanky/programovaci-jazyk-clojure-a-prace-s-gitem-2/</a>
</li>

<li>Programovací jazyk Clojure – triky při práci s řetězci<br />
<a href="http://www.root.cz/clanky/programovaci-jazyk-clojure-triky-pri-praci-s-retezci/">http://www.root.cz/clanky/programovaci-jazyk-clojure-triky-pri-praci-s-retezci/</a>
</li>

</ol>



<p><a name="k12"></a></p>
<h2 id="k12">12. Odkazy na Internetu</h2>

<ol>

<li>Clojure home page<br />
<a href="http://clojure.org/">http://clojure.org/</a>
</li>

<li>Clojure (downloads)<br />
<a href="http://clojure.org/downloads">http://clojure.org/downloads</a>
</li>

<li>Clojure Sequences<br />
<a href="http://clojure.org/sequences">http://clojure.org/sequences</a>
</li>

<li>Clojure Data Structures<br />
<a href="http://clojure.org/data_structures">http://clojure.org/data_structures</a>
</li>

<li>The Structure and Interpretation of Computer Programs: 2.2.1  Representing Sequences<br />
<a href="http://mitpress.mit.edu/sicp/full-text/book/book-Z-H-15.html#%_sec_2.2.1">http://mitpress.mit.edu/sicp/full-text/book/book-Z-H-15.html#%_sec_2.2.1</a>
</li>

<li>The Structure and Interpretation of Computer Programs: 3.3.1  Mutable List Structure<br />
<a href="http://mitpress.mit.edu/sicp/full-text/book/book-Z-H-22.html#%_sec_3.3.1">http://mitpress.mit.edu/sicp/full-text/book/book-Z-H-22.html#%_sec_3.3.1</a>
</li>

<li>Clojure - Functional Programming for the JVM<br />
<a href="http://java.ociweb.com/mark/clojure/article.html">http://java.ociweb.com/mark/clojure/article.html</a>
</li>

<li>Clojure quick reference<br />
<a href="http://faustus.webatu.com/clj-quick-ref.html">http://faustus.webatu.com/clj-quick-ref.html</a>
</li>

<li>4Clojure<br />
<a href="http://www.4clojure.com/">http://www.4clojure.com/</a>
</li>

<li>ClojureDoc (rozcestník s&nbsp;dokumentací jazyka Clojure)<br />
<a href="http://clojuredocs.org/">http://clojuredocs.org/</a>
</li>

<li>Clojure (na Wikipedia EN)<br />
<a href="http://en.wikipedia.org/wiki/Clojure">http://en.wikipedia.org/wiki/Clojure</a>
</li>

<li>Clojure (na Wikipedia CS)<br />
<a href="http://cs.wikipedia.org/wiki/Clojure">http://cs.wikipedia.org/wiki/Clojure</a>
</li>

<li>SICP (The Structure and Interpretation of Computer Programs)<br />
<a href="http://mitpress.mit.edu/sicp/">http://mitpress.mit.edu/sicp/</a>
</li>

<li>Pure function<br />
<a href="http://en.wikipedia.org/wiki/Pure_function">http://en.wikipedia.org/wiki/Pure_function</a>
</li>

<li>Funkcionální programování<br />
<a href="http://cs.wikipedia.org/wiki/Funkcionální_programování">http://cs.wikipedia.org/wiki/Funkcionální_programování</a>
</li>

<li>Čistě funkcionální (datové struktury, jazyky, programování)<br />
<a href="http://cs.wikipedia.org/wiki/Čistě_funkcionální">http://cs.wikipedia.org/wiki/Čistě_funkcionální</a>
</li>

<li>Clojure Macro Tutorial (Part I, Getting the Compiler to Write Your Code For You)<br />
<a href="http://www.learningclojure.com/2010/09/clojure-macro-tutorial-part-i-getting.html">http://www.learningclojure.com/2010/09/clojure-macro-tutorial-part-i-getting.html</a>
</li>

<li>Clojure Macro Tutorial (Part II: The Compiler Strikes Back)<br />
<a href="http://www.learningclojure.com/2010/09/clojure-macro-tutorial-part-ii-compiler.html">http://www.learningclojure.com/2010/09/clojure-macro-tutorial-part-ii-compiler.html</a>
</li>

<li>Clojure Macro Tutorial (Part III: Syntax Quote)<br />
<a href="http://www.learningclojure.com/2010/09/clojure-macro-tutorial-part-ii-syntax.html">http://www.learningclojure.com/2010/09/clojure-macro-tutorial-part-ii-syntax.html</a>
</li>

<li>Tech behind Tech: Clojure Macros Simplified<br />
<a href="http://techbehindtech.com/2010/09/28/clojure-macros-simplified/">http://techbehindtech.com/2010/09/28/clojure-macros-simplified/</a>
</li>

<li>Fatvat - Exploring functional programming: Clojure Macros<br />
<a href="http://www.fatvat.co.uk/2009/02/clojure-macros.html">http://www.fatvat.co.uk/2009/02/clojure-macros.html</a>
</li>

<li>Eulerovo číslo<br />
<a href="http://cs.wikipedia.org/wiki/Eulerovo_číslo">http://cs.wikipedia.org/wiki/Eulerovo_číslo</a>
</li>

<li>List comprehension<br />
<a href="http://en.wikipedia.org/wiki/List_comprehension">http://en.wikipedia.org/wiki/List_comprehension</a>
</li>

<li>List Comprehensions in Clojure<br />
<a href="http://asymmetrical-view.com/2008/11/18/list-comprehensions-in-clojure.html">http://asymmetrical-view.com/2008/11/18/list-comprehensions-in-clojure.html</a>
</li>

<li>Clojure Programming Concepts: List Comprehension<br />
<a href="http://en.wikibooks.org/wiki/Clojure_Programming/Concepts#List_Comprehension">http://en.wikibooks.org/wiki/Clojure_Programming/Concepts#List_Comprehension</a>
</li>

<li>Clojure core API: for macro<br />
<a href="http://clojure.github.com/clojure/clojure.core-api.html#clojure.core/for">http://clojure.github.com/clojure/clojure.core-api.html#clojure.core/for</a>
</li>

<li>cirrus machina - The Clojure for macro<br />
<a href="http://www.cirrusmachina.com/blog/comment/the-clojure-for-macro/">http://www.cirrusmachina.com/blog/comment/the-clojure-for-macro/</a>
</li>

<li>Riastradh's Lisp Style Rules<br />
<a href="http://mumble.net/~campbell/scheme/style.txt">http://mumble.net/~campbell/scheme/style.txt</a>
</li>

<li>Dynamic Languages Strike Back<br />
<a href="http://steve-yegge.blogspot.cz/2008/05/dynamic-languages-strike-back.html">http://steve-yegge.blogspot.cz/2008/05/dynamic-languages-strike-back.html</a>
</li>

<li>Scripting: Higher Level Programming for the 21st Century<br />
<a href="http://www.tcl.tk/doc/scripting.html">http://www.tcl.tk/doc/scripting.html</a>
</li>

<li>Java Virtual Machine Support for Non-Java Languages<br />
<a href="http://docs.oracle.com/javase/7/docs/technotes/guides/vm/multiple-language-support.html">http://docs.oracle.com/javase/7/docs/technotes/guides/vm/multiple-language-support.html</a>
</li>

<li>Třída java.lang.String<br />
<a href="http://docs.oracle.com/javase/7/docs/api/java/lang/String.html">http://docs.oracle.com/javase/7/docs/api/java/lang/String.html</a>
</li>

<li>Třída java.lang.StringBuffer<br />
<a href="http://docs.oracle.com/javase/7/docs/api/java/lang/StringBuffer.html">http://docs.oracle.com/javase/7/docs/api/java/lang/StringBuffer.html</a>
</li>

<li>Třída java.lang.StringBuilder<br />
<a href="http://docs.oracle.com/javase/7/docs/api/java/lang/StringBuilder.html">http://docs.oracle.com/javase/7/docs/api/java/lang/StringBuilder.html</a>
</li>

<li>StringBuffer versus String<br />
<a href="http://www.javaworld.com/article/2076072/build-ci-sdlc/stringbuffer-versus-string.html">http://www.javaworld.com/article/2076072/build-ci-sdlc/stringbuffer-versus-string.html</a>
</li>

<li>Threading macro (dokumentace k&nbsp;jazyku Clojure)<br />
<a href="https://clojure.github.io/clojure/clojure.core-api.html#clojure.core/-&gt;">https://clojure.github.io/clojure/clojure.core-api.html#clojure.core/-&gt;</a>
</li>

<li>Understanding the Clojure -&gt; macro<br />
<a href="http://blog.fogus.me/2009/09/04/understanding-the-clojure-macro/">http://blog.fogus.me/2009/09/04/understanding-the-clojure-macro/</a>
</li>

<li>clojure.inspector<br />
<a href="http://clojure.github.io/clojure/clojure.inspector-api.html">http://clojure.github.io/clojure/clojure.inspector-api.html</a>
</li>

<li>The Clojure Toolbox<br />
<a href="http://www.clojure-toolbox.com/">http://www.clojure-toolbox.com/</a>
</li>

<li>Unit Testing in Clojure<br />
<a href="http://nakkaya.com/2009/11/18/unit-testing-in-clojure/">http://nakkaya.com/2009/11/18/unit-testing-in-clojure/</a>
</li>

<li>Testing in Clojure (Part-1: Unit testing)<br />
<a href="http://blog.knoldus.com/2014/03/22/testing-in-clojure-part-1-unit-testing/">http://blog.knoldus.com/2014/03/22/testing-in-clojure-part-1-unit-testing/</a>
</li>

<li>API for clojure.test - Clojure v1.6 (stable)<br />
<a href="https://clojure.github.io/clojure/clojure.test-api.html">https://clojure.github.io/clojure/clojure.test-api.html</a>
</li>

<li>Leiningen: úvodní stránka<br />
<a href="http://leiningen.org/">http://leiningen.org/</a>
</li>

<li>Leiningen: Git repository<br />
<a href="https://github.com/technomancy/leiningen">https://github.com/technomancy/leiningen</a>
</li>

<li>leiningen-win-installer<br />
<a href="http://leiningen-win-installer.djpowell.net/">http://leiningen-win-installer.djpowell.net/</a>
</li>

<li>Clojure  1: Úvod<br />
<a href="http://www.root.cz/clanky/clojure-aneb-jazyk-umoznujici-tvorbu-bezpecnych-vicevlaknovych-aplikaci-pro-jvm/">http://www.root.cz/clanky/clojure-aneb-jazyk-umoznujici-tvorbu-bezpecnych-vicevlaknovych-aplikaci-pro-jvm/</a>
</li>

<li>Clojure  2: Symboly, kolekce atd.<br />
<a href="http://www.root.cz/clanky/clojure-aneb-jazyk-umoznujici-tvorbu-bezpecnych-vicevlaknovych-aplikaci-pro-jvm-2-cast/">http://www.root.cz/clanky/clojure-aneb-jazyk-umoznujici-tvorbu-bezpecnych-vicevlaknovych-aplikaci-pro-jvm-2-cast/</a>
</li>

<li>Clojure  3: Funkcionální programování<br />
<a href="http://www.root.cz/clanky/clojure-aneb-jazyk-umoznujici-tvorbu-bezpecnych-vicevlaknovych-aplikaci-pro-jvm-3-cast-funkcionalni-programovani/">http://www.root.cz/clanky/clojure-aneb-jazyk-umoznujici-tvorbu-bezpecnych-vicevlaknovych-aplikaci-pro-jvm-3-cast-funkcionalni-programovani/</a>
</li>

<li>Clojure  4: Kolekce, sekvence a lazy sekvence<br />
<a href="http://www.root.cz/clanky/clojure-aneb-jazyk-umoznujici-tvorbu-bezpecnych-vicevlaknovych-aplikaci-pro-jvm-4-cast-kolekce-sekvence-a-lazy-sekvence/">http://www.root.cz/clanky/clojure-aneb-jazyk-umoznujici-tvorbu-bezpecnych-vicevlaknovych-aplikaci-pro-jvm-4-cast-kolekce-sekvence-a-lazy-sekvence/</a>
</li>

<li>Clojure  5: Sekvence, lazy sekvence a paralelní programy<br />
<a href="http://www.root.cz/clanky/clojure-a-bezpecne-aplikace-pro-jvm-sekvence-lazy-sekvence-a-paralelni-programy/">http://www.root.cz/clanky/clojure-a-bezpecne-aplikace-pro-jvm-sekvence-lazy-sekvence-a-paralelni-programy/</a>
</li>

<li>Clojure  6: Podpora pro paralelní programování<br />
<a href="http://www.root.cz/clanky/programovaci-jazyk-clojure-6-futures-nejsou-jen-financni-derivaty/">http://www.root.cz/clanky/programovaci-jazyk-clojure-6-futures-nejsou-jen-financni-derivaty/</a>
</li>

<li>Clojure  7: Další funkce pro paralelní programování<br />
<a href="http://www.root.cz/clanky/programovaci-jazyk-clojure-7-dalsi-podpurne-prostredky-pro-paralelni-programovani/">http://www.root.cz/clanky/programovaci-jazyk-clojure-7-dalsi-podpurne-prostredky-pro-paralelni-programovani/</a>
</li>

<li>Clojure  8: Identity, stavy, neměnné hodnoty a reference<br />
<a href="http://www.root.cz/clanky/programovaci-jazyk-clojure-8-identity-stavy-nemenne-hodnoty-a-referencni-typy/">http://www.root.cz/clanky/programovaci-jazyk-clojure-8-identity-stavy-nemenne-hodnoty-a-referencni-typy/</a>
</li>

<li>Clojure  9: Validátory, pozorovatelé a kooperace s Javou<br />
<a href="http://www.root.cz/clanky/programovaci-jazyk-clojure-9-validatory-pozorovatele-a-kooperace-mezi-clojure-a-javou/">http://www.root.cz/clanky/programovaci-jazyk-clojure-9-validatory-pozorovatele-a-kooperace-mezi-clojure-a-javou/</a>
</li>

<li>Clojure 10: Kooperace mezi Clojure a Javou<br />
<a href="http://www.root.cz/clanky/programovaci-jazyk-clojure-10-kooperace-mezi-clojure-a-javou-pokracovani/">http://www.root.cz/clanky/programovaci-jazyk-clojure-10-kooperace-mezi-clojure-a-javou-pokracovani/</a>
</li>

<li>Clojure 11: Generátorová notace seznamu/list comprehension<br />
<a href="http://www.root.cz/clanky/programovaci-jazyk-clojure-11-generatorova-notace-seznamu-list-comprehension/">http://www.root.cz/clanky/programovaci-jazyk-clojure-11-generatorova-notace-seznamu-list-comprehension/</a>
</li>

<li>Clojure 12: Překlad programů z Clojure do bajtkódu JVM I:<br />
<a href="http://www.root.cz/clanky/programovaci-jazyk-clojure-12-preklad-programu-z-clojure-do-bajtkodu-jvm/">http://www.root.cz/clanky/programovaci-jazyk-clojure-12-preklad-programu-z-clojure-do-bajtkodu-jvm/</a>
</li>

<li>Clojure 13: Překlad programů z Clojure do bajtkódu JVM II:<br />
<a href="http://www.root.cz/clanky/programovaci-jazyk-clojure-13-preklad-programu-z-clojure-do-bajtkodu-jvm-pokracovani/">http://www.root.cz/clanky/programovaci-jazyk-clojure-13-preklad-programu-z-clojure-do-bajtkodu-jvm-pokracovani/</a>
</li>

<li>Clojure 14: Základy práce se systémem maker<br />
<a href="http://www.root.cz/clanky/programovaci-jazyk-clojure-14-zaklady-prace-se-systemem-maker/">http://www.root.cz/clanky/programovaci-jazyk-clojure-14-zaklady-prace-se-systemem-maker/</a>
</li>

<li>Clojure 15: Tvorba uživatelských maker<br />
<a href="http://www.root.cz/clanky/programovaci-jazyk-clojure-15-tvorba-uzivatelskych-maker/">http://www.root.cz/clanky/programovaci-jazyk-clojure-15-tvorba-uzivatelskych-maker/</a>
</li>

<li>Clojure 16: Složitější uživatelská makra<br />
<a href="http://www.root.cz/clanky/programovaci-jazyk-clojure-16-slozitejsi-uzivatelska-makra/">http://www.root.cz/clanky/programovaci-jazyk-clojure-16-slozitejsi-uzivatelska-makra/</a>
</li>

<li>Clojure 17: Využití standardních maker v praxi<br />
<a href="http://www.root.cz/clanky/programovaci-jazyk-clojure-17-vyuziti-standardnich-maker-v-praxi/">http://www.root.cz/clanky/programovaci-jazyk-clojure-17-vyuziti-standardnich-maker-v-praxi/</a>
</li>

<li>Clojure 18: Základní techniky optimalizace aplikací<br />
<a href="http://www.root.cz/clanky/programovaci-jazyk-clojure-18-zakladni-techniky-optimalizace-aplikaci/">http://www.root.cz/clanky/programovaci-jazyk-clojure-18-zakladni-techniky-optimalizace-aplikaci/</a>
</li>

<li>Clojure 19: Vývojová prostředí pro Clojure<br />
<a href="http://www.root.cz/clanky/programovaci-jazyk-clojure-19-vyvojova-prostredi-pro-clojure/">http://www.root.cz/clanky/programovaci-jazyk-clojure-19-vyvojova-prostredi-pro-clojure/</a>
</li>

<li>Clojure 20: Vývojová prostředí pro Clojure (Vimu s REPL)<br />
<a href="http://www.root.cz/clanky/programovaci-jazyk-clojure-20-vyvojova-prostredi-pro-clojure-integrace-vimu-s-repl/">http://www.root.cz/clanky/programovaci-jazyk-clojure-20-vyvojova-prostredi-pro-clojure-integrace-vimu-s-repl/</a>
</li>

<li>Clojure 21: ClojureScript aneb překlad Clojure do JS<br />
<a href="http://www.root.cz/clanky/programovaci-jazyk-clojure-21-clojurescript-aneb-preklad-clojure-do-javascriptu/">http://www.root.cz/clanky/programovaci-jazyk-clojure-21-clojurescript-aneb-preklad-clojure-do-javascriptu/</a>
</li>

<li>Clojure.org: Vars and the Global Environment<br />
<a href="http://clojure.org/Vars">http://clojure.org/Vars</a>
</li>

<li>Clojure.org: Refs and Transactions<br />
<a href="http://clojure.org/Refs">http://clojure.org/Refs</a>
</li>

<li>Clojure.org: Atoms<br />
<a href="http://clojure.org/Atoms">http://clojure.org/Atoms</a>
</li>

<li>Clojure.org: Agents as Asynchronous Actions<br />
<a href="http://clojure.org/agents">http://clojure.org/agents</a>
</li>

<li>Transient Data Structures
<a href="http://clojure.org/transients">http://clojure.org/transients</a>
</li>

</ol>



<p></p><p></p>
<p><small>Autor: <a href="http://www.fit.vutbr.cz/~tisnovpa">Pavel Tišnovský</a> &nbsp; 2015</small></p>
</body>
</html>

