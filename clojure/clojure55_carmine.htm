<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
        "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html>
<head>
<title>Využití Redisu z jazyka Clojure pomocí knihovny Carmine (dokončení)</title>
<meta name="Author" content="Pavel Tisnovsky" />
<meta name="Generator" content="vim" />
<meta http-equiv="content-type" content="text/html; charset=utf-8" />
<style type="text/css">
         body {color:#000000; background:#ffffff;}
         h1  {font-family: arial, helvetica, sans-serif; color:#ffffff; background-color:#c00000; text-align:center; padding-left:1em}
         h2  {font-family: arial, helvetica, sans-serif; color:#ffffff; background-color:#0000c0; padding-left:1em; text-align:left}
         h3  {font-family: arial, helvetica, sans-serif; color:#000000; background-color:#c0c0c0; padding-left:1em; text-align:left}
         h4  {font-family: arial, helvetica, sans-serif; color:#000000; background-color:#e0e0e0; padding-left:1em; text-align:left}
         a   {font-family: arial, helvetica, sans-serif;}
         li  {font-family: arial, helvetica, sans-serif; color:#000000; text-align:justify; width:450px;}
         ol  {font-family: arial, helvetica, sans-serif; color:#000000; text-align:justify; width:450px;}
         ul  {font-family: arial, helvetica, sans-serif; color:#000000; text-align:justify; width:450px;}
         p   {font-family: arial, helvetica, sans-serif; color:#000000; text-align:justify;}
         pre {background:#e0e0e0}
</style>
</head>

<body>

<h1>Využití Redisu z jazyka Clojure pomocí knihovny Carmine (dokončení)</h1>

<h3>Pavel Tišnovský</h3>

<p></p>

<h1>Úvodník</h1>

<p>Na úvodní článek o knihovně Carmine, která umožňuje používat Redis v aplikacích naprogramovaných v Clojure, dnes navážeme. Ukážeme si mj. i komunikaci založenou na strategii publish-subscribe a taktéž použití front zpráv (queues).</p>



<h2>Obsah</h2>

<p><a href="#k01">1. Využití Redisu z&nbsp;jazyka Clojure pomocí knihovny Carmine (dokončení)</a></p>
<p><a href="#k02">2. Množiny</a></p>
<p><a href="#k03">3. Základní operace s&nbsp;množinami prováděné z&nbsp;knihovny Carmine</a></p>
<p><a href="#k04">4. Množinové operace: sjednocení, průnik, rozdíl</a></p>
<p><a href="#k05">5. Množinové operace prováděné z&nbsp;jazyka Clojure</a></p>
<p><a href="#k06">6. Mapy (asociativní pole)</a></p>
<p><a href="#k07">7. Práce s&nbsp;mapami v&nbsp;jazyku Clojure</a></p>
<p><a href="#k08">8. Množiny s&nbsp;ohodnocenými prvky (uspořádané množiny)</a></p>
<p><a href="#k09">9. Uspořádané množiny a jazyk Clojure</a></p>
<p><a href="#k10">10. Komunikační strategie publish-subscribe</a></p>
<p><a href="#k11">11. Program konzumující zprávy (subscriber)</a></p>
<p><a href="#k12">12. Program produkující zprávy (publisher)</a></p>
<p><a href="#k13">13. Použití front pro komunikaci</a></p>
<p><a href="#k14">14. Implementace workera přijímacího úkoly přes frontu</a></p>
<p><a href="#k15">15. Klient vytvářející zprávy pro workery</a></p>
<p><a href="#k16">16. Seznam popsaných maker a funkcí knihovny Carmine</a></p>
<p><a href="#k17">17. Repositář s&nbsp;demonstračními příklady</a></p>
<p><a href="#k18">18. Předchozí články o systému Redis</a></p>
<p><a href="#k19">19. Odkazy na předchozí části seriálu o programovacím jazyku Clojure</a></p>
<p><a href="#k20">20. Odkazy na Internetu</a></p>



<p><a name="k01"></a></p>
<h2 id="k01">1. Využití Redisu z&nbsp;jazyka Clojure pomocí knihovny Carmine (dokončení)</h2>

<p><a
href="https://www.root.cz/clanky/vyuziti-redisu-z-jazyka-clojure-pomoci-knihovny-carmine/">V&nbsp;úvodním
článku</a> jsme se seznámili s&nbsp;tím, jakým způsobem je možné vyvinout
aplikace v&nbsp;programovacím jazyku Clojure, které komunikují s&nbsp;databází
Redis. Pro tento účel jsme použili knihovnu <a
href="https://github.com/ptaoussanis/carmine">Carmine</a>. Prozatím víme, jakým
způsobem se do Redisu ukládají jednotlivé hodnoty pod určitým klíčem (přičemž
hodnotou může být řetězec, ale i celý serializovaný objekt). Taktéž jsme si
ukázali základní operace se seznamy, které mohou být ve skutečnosti použity i
ve funkci zásobníků popř.&nbsp;front. Dnes si popíšeme další datové typy
podporované Redisem, zejména mapy (asociativní pole), množiny a takzvané
uspořádané množiny. Ve druhé části článku si na několika demonstračních
příkladech ukážeme způsob použití komunikačních strategií
<i>publish-subscribe</i> i využití front zpráv (<i>queue</i>).</p>



<p><a name="k02"></a></p>
<h2 id="k02">2. Množiny</h2>

<p>Kromě datových typů popsaných minule (tedy řetězců a seznamů, přičemž
řetězce mohou ve skutečnosti obsahovat čísla či serializované objekty) lze
v&nbsp;Redisu pracovat i s&nbsp;dalšími datovými typy (a každý z&nbsp;nich se
pochopitelně hodí pro jiné účely). Třetím datovým typem, s&nbsp;nímž je možné
v&nbsp;Redisu pracovat a s&nbsp;nímž se ve stručnosti seznámíme, jsou množiny
(<i>sets</i>). Každá množina může obsahovat až 2<sup>32</sup>-1 prvků, což je
stejná maximální kapacita prvků, jako u seznamů. Prvky se do množiny přidávají
příkazem <strong>sadd</strong> (neboli <i>set add</i>), přičemž je nutné uvést
jak jméno (identifikátor) množiny, tak i hodnotu vkládaného prvku.
V&nbsp;případě, že množina daného jména neexistuje, je prvním příkazem
<strong>sadd</strong> vytvořena:</p>

<pre>
127.0.0.1:6379&gt; <strong>sadd s "foo"</strong>
(integer) 1
&nbsp;
127.0.0.1:6379&gt; <strong>sadd s "bar"</strong>
(integer) 1
&nbsp;
127.0.0.1:6379&gt; <strong>sadd s "baz"</strong>
(integer) 1
</pre>

<p><div class="rs-tip-major">Poznámka: vrácená hodnota 1 oznamuje počet prvků
vložených do množiny. V&nbsp;případě potřeby lze jednou operací
<strong>sadd</strong> vložit větší množství prvků, ovšem pokud prvek/prvky již
v&nbsp;množině existují, nebudou do výsledku započteny. V&nbsp;limitním případě
se tak může vrátit i nula.</div></p>

<p>Celkový počet prvků uložených v&nbsp;množině získáme příkazem
<strong>scard</strong>, seznam všech prvků pak příkazem
<strong>smembers</strong>:</p>

<pre>
127.0.0.1:6379&gt; <strong>scard s</strong>
(integer) 3
&nbsp;
127.0.0.1:6379&gt; <strong>smembers s</strong>
1) "bar"
2) "baz"
3) "foo"
</pre>

<p>Test, jestli množina obsahuje nějaký prvek, zajistí příkaz
<strong>sismember</strong>, který vrací numerickou hodnotu 0 nebo 1:</p>

<pre>
127.0.0.1:6379&gt; <strong>sismember s "foo"</strong>
(integer) 1
&nbsp;
127.0.0.1:6379&gt; <strong>sismember s "xyzzy"</strong>
(integer) 0
</pre>

<p>Odstranění prvku z&nbsp;množiny zajistí příkaz <strong>srem</strong>, který
navíc vrátí příznak, zda byl prvek odstraněn (tj.&nbsp;zda vůbec v&nbsp;množině
figuroval):</p>

<pre>
127.0.0.1:6379&gt; <strong>srem s "foo"</strong>
(integer) 1
&nbsp;
127.0.0.1:6379&gt; <strong>sismember s "foo"</strong>
(integer) 0
&nbsp;
127.0.0.1:6379&gt; <strong>smembers s</strong>
1) "bar"
2) "baz"
</pre>

<p>Vzhledem k&nbsp;tomu, že se jedná o skutečné množiny, je ošetřen i případ,
kdy se do množiny vkládá více stejných prvků:</p>

<pre>
127.0.0.1:6379&gt; <strong>sadd mnozina 1</strong>
(integer) 1
&nbsp;
127.0.0.1:6379&gt; <strong>sadd mnozina 2</strong>
(integer) 1
&nbsp;
127.0.0.1:6379&gt; <strong>sadd mnozina 1</strong>
(integer) 0
</pre>

<p><div class="rs-tip-major">Poznámka: poslední nula vrácená Redisem značí, že
prvek 1 již nebyl do množiny vložen, neboť v&nbsp;ní již existuje.</div></p>



<p><a name="k03"></a></p>
<h2 id="k03">3. Základní operace s&nbsp;množinami prováděné z&nbsp;knihovny Carmine</h2>

<p>Všechny operace s&nbsp;množinami, které jsme si popsali <a href="#k02">ve
druhé kapitole</a> jsou pochopitelně podporovány i knihovnou Carmine. Ukázány
jsou v&nbsp;následujícím demonstračním příkladu. Povšimněte si, že se (do
značné míry) jedná o idiomatický kód programovacího jazyka Clojure, protože
namísto textových literálů používáme &bdquo;keywords&ldquo;, tedy symboly,
které jsou ve všech jmenných prostorech unikátní a jsou interně reprezentovány
referencí a nikoli hodnotou (tedy nezáleží na délce symbolu):</p>

<pre>
(ns <strong>carmine8.core</strong>
  (:require [taoensso.carmine :as carmine :refer (wcar)]))
&nbsp;
&nbsp;
(def <strong>redis-connection</strong> {
  :pool {}
  :spec {
    :uri "redis://localhost@127.0.0.1:6379"}})
&nbsp;
&nbsp;
(defmacro <strong>wcar*</strong>
  [&amp; body]
  `(carmine/wcar redis-connection ~@body))
&nbsp;
&nbsp;
(defn <strong>-main</strong>
  [&amp; args]
  (println "Working with two sets")
&nbsp;
  (println "Set s1")
  (println
    (wcar*
      (carmine/sadd :s1 :a)
      (carmine/sadd :s1 :b)
      (carmine/sadd :s1 :c)
      (carmine/sadd :s1 :d)
      (carmine/smembers :s1)
      (carmine/scard :s1)))
&nbsp;
  (println "Set s2")
  (println
    (wcar*
      (carmine/sadd :s2 :c :d :e :f)
      (carmine/smembers :s2)
      (carmine/scard :s1)))
&nbsp;
  (println "Done"))
</pre>

<p>Po spuštění tohoto příkladu se mj.&nbsp;vypíšou i dva vektory:</p>

<pre>
Working with two sets
Set s1
[1 1 1 1 [c d b a] 4]
Set s2
[4 [f e c d] 4]
Done
</pre>

<p>První vektor obsahuje postupně výsledek čtyř operací <strong>sadd</strong>,
následně prvky množiny :s1 a konečně počet prvků množiny. Druhý vektor obsahuje
výsledek operace <strong>sadd</strong>, která vložila čtyři prvky, následně
prvky množiny :s2 a nakonec taktéž počet prvků této množiny.</p>



<p><a name="k04"></a></p>
<h2 id="k04">4. Množinové operace: sjednocení, průnik, rozdíl</h2>

<p>Systém Redis podporuje provádění základních množinových operací &ndash; tedy
konkrétně sjednocení, průniku a rozdílu. Tyto operace jsou vyvolány příkazy
nazvanými <strong>sunion</strong>, <strong>sunionstore</strong>,
<strong>sinter</strong>, <strong>sinterstore</strong>, <strong>sdiff</strong> a
<strong>sdiffstore</strong>.</p>

<p>Před ukázkou základního způsobu použití těchto operací si vytvoříme dvě
množiny s&nbsp;identifikátory <strong>s1</strong> a <strong>s2</strong>.</p>

<p>Naplnění množiny <strong>s1</strong> čtyřmi prvky:</p>

<pre>
127.0.0.1:6379&gt; <strong>sadd s1 1</strong>
(integer) 1
&nbsp;
127.0.0.1:6379&gt; <strong>sadd s1 2</strong>
(integer) 1
&nbsp;
127.0.0.1:6379&gt; <strong>sadd s1 3</strong>
(integer) 1
&nbsp;
127.0.0.1:6379&gt; <strong>sadd s1 4</strong>
(integer) 1
</pre>

<p>Naplnění množiny <strong>s2</strong> taktéž čtyřmi prvky (ovšem částečně
odlišnými od množiny <strong>s1</strong>):</p>

<pre>
127.0.0.1:6379&gt; <strong>sadd s2 3</strong>
(integer) 1
&nbsp;
127.0.0.1:6379&gt; <strong>sadd s2 4</strong>
(integer) 1
&nbsp;
127.0.0.1:6379&gt; <strong>sadd s2 5</strong>
(integer) 1
&nbsp;
127.0.0.1:6379&gt; <strong>sadd s2 6</strong>
(integer) 1
</pre>

<p>Pro jistotu si vypíšeme aktuální obsah obou množin:</p>

<pre>
127.0.0.1:6379&gt; <strong>smembers s1</strong>
1) "1"
2) "2"
3) "3"
4) "4"
&nbsp;
127.0.0.1:6379&gt; <strong>smembers s2</strong>
1) "3"
2) "4"
3) "5"
4) "6"
</pre>

<p>Příkazem <strong>sunionstore</strong> vytvoříme novou množinu, která bude
sjednocením obou množin zdrojových (<i>union</i>). Následně zkontrolujeme
výsledek:</p>

<pre>
127.0.0.1:6379&gt; <strong>sunionstore s3 s1 s2</strong>
(integer) 6
&nbsp;
127.0.0.1:6379&gt; <strong>smembers s3</strong>
1) "1"
2) "2"
3) "3"
4) "4"
5) "5"
6) "6"
</pre>

<p>Podobně je možné příkazem <strong>sinterstore</strong> vytvořit novou
množinu s&nbsp;využitím operace průniku (<i>intersection</i>):</p>

<pre>
127.0.0.1:6379&gt; <strong>sinterstore s4 s1 s2</strong>
(integer) 2
&nbsp;
127.0.0.1:6379&gt; <strong>smembers s4</strong>
1) "3"
2) "4"
</pre>

<p>Poslední podporovanou operací je rozdíl množin (<i>difference</i>). Tato
operace není komutativní, takže je pochopitelně výsledek jiný při provedení
rozdílu s1\s2 a s2\s1:</p>

<pre>
127.0.0.1:6379&gt; <strong>sdiffstore s5 s1 s2</strong>
(integer) 2
&nbsp;
127.0.0.1:6379&gt; <strong>smembers s5</strong>
1) "1"
2) "2"
&nbsp;
127.0.0.1:6379&gt; <strong>sdiffstore s6 s2 s1</strong>
(integer) 2
&nbsp;
127.0.0.1:6379&gt; <strong>smembers s6</strong>
1) "5"
2) "6"
</pre>

<p><div class="rs-tip-major">Poznámka: použít lze i příkazy
<strong>sunion</strong>, <strong>sinter</strong> a <strong>sdiff</strong>,
které taktéž provedou sjednocení, průnik či rozdíl množin, ale výsledek je
v&nbsp;tomto případě pouze poslán uživateli a není uložen zpět do
Redisu.</div></p>



<p><a name="k05"></a></p>
<h2 id="k05">5. Množinové operace prováděné z&nbsp;jazyka Clojure</h2>

<p>Opět platí, že všechny výše popsané a otestované množinové operace můžeme
provádět z&nbsp;programovacího jazyka Clojure s&nbsp;využitím knihovny Carmine.
Ukažme si nejdříve operace, u nichž se výsledek ukládá zpět do Redisu do nové
množiny, tedy operace, jejichž jméno končí na &bdquo;store&ldquo;:</p>

<pre>
(ns <strong>carmine9.core</strong>
  (:require [taoensso.carmine :as carmine :refer (wcar)]))
&nbsp;
&nbsp;
(def <strong>redis-connection</strong> {
  :pool {}
  :spec {
    :uri "redis://localhost@127.0.0.1:6379"}})
&nbsp;
&nbsp;
(defmacro <strong>wcar*</strong>
  [&amp; body]
  `(carmine/wcar redis-connection ~@body))
&nbsp;
&nbsp;
(defn <strong>-main</strong>
  [&amp; args]
  (println "Working with two sets")
  (println "Fill in sets s1 and s2")
&nbsp;
  (println
    (wcar*
      (carmine/srem :s1 :a :b :c :d :e :f)
      (carmine/srem :s2 :a :b :c :d :e :f)
      (carmine/sadd :s1 :a :b :c :d)
      (carmine/sadd :s2 :c :d :e :f)
      (carmine/smembers :s1)
      (carmine/smembers :s2)))
&nbsp;
  (println "Set operations")
&nbsp;
  (println "union")
  (println
    (wcar*
      (carmine/sunionstore :s3 :s1 :s2)
      (carmine/smembers :s3)))
&nbsp;
  (println "intersection")
  (println
    (wcar*
      (carmine/sinterstore :s4 :s1 :s2)
      (carmine/smembers :s4)))
&nbsp;
  (println "diff")
  (println
    (wcar*
      (carmine/sdiffstore :s5 :s1 :s2)
      (carmine/smembers :s5)
      (carmine/sdiffstore :s6 :s2 :s1)
      (carmine/smembers :s6)))
&nbsp;
  (println "Done"))
</pre>

<p>Po spuštění tohoto demonstračního příkladu získáme sérii vektorů, přičemž u
zvýrazněných vektorů je zobrazen počet prvků ve výsledné množině, za nímž
následuje seznam těchto prvků:</p>

<pre>
Working with two sets
Fill in sets s1 and s2
[0 0 4 4 [d b a c] [f d e c]]
Set operations
&nbsp;
union
<strong>[6 [c d b f a e]]</strong>
&nbsp;
intersection
<strong>[2 [d c]]</strong>
&nbsp;
diff
<strong>[2 [b a] 2 [f e]]</strong>
&nbsp;
Done
</pre>

<p>Podobným způsobem je možné použít i množinové operace, jejichž výsledkem je
množina vrácená uživateli (ale neukládaná zpět do Redisu):</p>

<pre>
(ns <strong>carmineA.core</strong>
  (:require [taoensso.carmine :as carmine :refer (wcar)]))
&nbsp;
&nbsp;
(def <strong>redis-connection</strong> {
  :pool {}
  :spec {
    :uri "redis://localhost@127.0.0.1:6379"}})
&nbsp;
&nbsp;
(defmacro <strong>wcar*</strong>
  [&amp; body]
  `(carmine/wcar redis-connection ~@body))
&nbsp;
&nbsp;
(defn <strong>-main</strong>
  [&amp; args]
  (println "Working with two sets")
  (println "Fill in sets s1 and s2")
&nbsp;
  (println
    (wcar*
      (carmine/srem :s1 :a :b :c :d :e :f)
      (carmine/srem :s2 :a :b :c :d :e :f)
      (carmine/sadd :s1 :a :b :c :d)
      (carmine/sadd :s2 :c :d :e :f)
      (carmine/smembers :s1)
      (carmine/smembers :s2)))
&nbsp;
  (println "Set operations")
&nbsp;
  (println "union")
  (println
    (wcar*
      (carmine/sunion :s1 :s2)))
&nbsp;
  (println "intersection")
  (println
    (wcar*
      (carmine/sinter :s1 :s2)))
&nbsp;
  (println "diff")
  (println
    (wcar*
      (carmine/sdiff :s1 :s2)
      (carmine/sdiff :s2 :s1)))
&nbsp;
  (println "Done"))
</pre>

<p>Výsledek získaný po spuštění tohoto demonstračního příkladu. Výsledky
množinových operací jsou opět zvýrazněny:</p>

<pre>
Working with two sets
Fill in sets s1 and s2
[0 0 4 4 [c a d b] [f c e d]]
Set operations
&nbsp;
union
<strong>[c a e d b f]</strong>
&nbsp;
intersection
<strong>[c d]</strong>
&nbsp;
diff
<strong>[[a b] [f e]]</strong>
&nbsp;
Done
</pre>

<p><div class="rs-tip-major">Poznámka: poslední vektor obsahuje dva výsledky;
konkrétně výsledky rozdílu s1\s2 a s2\s1:</div></p>



<p><a name="k06"></a></p>
<h2 id="k06">6. Mapy (asociativní pole)</h2>

<p>Jedním z&nbsp;nejpoužívanějších datových typů v&nbsp;systému Redis jsou mapy
neboli asociativní pole. Každá mapa může obsahovat 2<sup>32</sup>-1 dvojic
klíč-hodnota, přičemž klíčem jsou řetězce. Příkazy pro práci
s&nbsp;asociativními poli začínají prefixem &bdquo;H&ldquo;. Základním příkazem
je <strong>hset</strong> určený pro uložení dvojice klíč-hodnota do množiny,
ovšem častěji se setkáme s&nbsp;příkazem <strong>hmset</strong>, který umožňuje
uložit větší množství dvojic jedinou operací. Opakem dvojice
<strong>hset/hmset</strong> jsou operace <strong>hget</strong> pro přečtení
jednoho prvku nebo <strong>hgetall</strong> pro přečtení všech dvojic (formou
tabulky, tj.&nbsp;tabulka má dvakrát více prvků, než asociativní pole). Tyto
operace si snadno odzkoušíme přímo z&nbsp;konzole Redisu:</p>

<pre>
127.0.0.1:6379&gt; <strong>hset apole x 1</strong>
(integer) 1
&nbsp;
127.0.0.1:6379&gt; <strong>hset apole y 2</strong>
(integer) 1
&nbsp;
127.0.0.1:6379&gt; <strong>hget apole x</strong>
"1"
&nbsp;
127.0.0.1:6379&gt; <strong>hget apole z</strong>
(nil)
</pre>

<p>Přepis existující hodnoty operací <strong>hset</strong>:</p>

<pre>
127.0.0.1:6379&gt; <strong>hset apole x "nova hodnota"</strong>
(integer) 0
&nbsp;
127.0.0.1:6379&gt; <strong>hget apole x </strong>
"nova hodnota"
</pre>

<p>Použití příkazů <strong>hmset</strong> a <strong>hgetall</strong>:</p>

<pre>
127.0.0.1:6379&gt; <strong>hmset user:1000 username antirez password P1pp0 age 34</strong>
OK
&nbsp;
127.0.0.1:6379&gt; <strong>hgetall user:1000</strong>
1) "username"
2) "antirez"
3) "password"
4) "P1pp0"
5) "age"
6) "34"
&nbsp;
127.0.0.1:6379&gt; <strong>hset user:1000 password 12345</strong>
(integer) 0
&nbsp;
127.0.0.1:6379&gt; <strong>hgetall user:1000</strong>
1) "username"
2) "antirez"
3) "password"
4) "12345"
5) "age"
6) "34"
</pre>



<p><a name="k07"></a></p>
<h2 id="k07">7. Práce s&nbsp;mapami v&nbsp;jazyku Clojure</h2>

<p>Příkazy, které byly otestovány v&nbsp;konzoli Redisu, si můžeme vyzkoušet i
přímo v&nbsp;programovacím jazyce Clojure. Vzhledem k&nbsp;tomu, že hodnoty
prvků jsou serializovány knihovnou <i>Nippy</i> (viz úvodní článek) je
v&nbsp;dalším demonstračním příkladu ukázáno použití prvků různých typů,
konkrétně seznamů, vektorů, ale i množin či map (přesněji řečeno množin a map
v&nbsp;kontextu jazyka Clojure, který tyto datové typy plně podporuje):</p>

<pre>
(ns <strong>carmineB.core</strong>
  (:require [taoensso.carmine :as carmine :refer (wcar)]
            [clojure.pprint :as pprint]))
&nbsp;
&nbsp;
(def <strong>redis-connection</strong> {
  :pool {}
  :spec {
    :uri "redis://localhost@127.0.0.1:6379"}})
&nbsp;
&nbsp;
(defmacro <strong>wcar*</strong>
  [&amp; body]
  `(carmine/wcar redis-connection ~@body))
&nbsp;
&nbsp;
(defn <strong>-main</strong>
  [&amp; args]
  (println "Working with maps")
&nbsp;
  (println "hset operation")
  (println
    (wcar*
      (carmine/hset :m1 :foo :bar)
      (carmine/hset :m1 :bar :baz)
      (carmine/hset :m1 "result" 1/3)
      (carmine/hset :m1 "more-complicated" [1 2 3])
      (carmine/hset :m1 :boolean   true)
      (carmine/hset :m1 :nil-value nil)
      (carmine/hset :m1 :text      "Hello world!")
      (carmine/hset :m1 :list      '(1 2 3))
      (carmine/hset :m1 :vector    [1 2 3])
      (carmine/hset :m1 :a-set     #{1 2 3 4})
      (carmine/hset :m1 :map {:name    "foo"
                              :surname "bar"
                         })))
&nbsp;
  (println "hget operation")
  (println
    (wcar*
      (carmine/hget :m1 :foo)
      (carmine/hget :m1 :bar)
      (carmine/hget :m1 :baz)
      (carmine/hget :m1 "result")
      (carmine/hget :m1 "more-complicated")
      (carmine/hget :m1 :unknown)))
&nbsp;
&nbsp;
  (println "hgetall operation")
  (pprint/pprint
    (wcar*
      (carmine/hgetall :m1)))
&nbsp;
  (println "Done"))
</pre>

<p>Po spuštění tohoto příkladu se nejprve prvky do mapy uloží a následně zase
přečtou a vypíšou na terminál:</p>

<pre>
Working with maps
&nbsp;
hset operation
[1 1 1 1 1 1 1 1 1 1 1]
&nbsp;
hget operation
[bar baz nil 1/3 [1 2 3] nil]
&nbsp;
hgetall operation
["foo"
 "bar"
 "bar"
 "baz"
 "result"
 1/3
 "more-complicated"
 [1 2 3]
 "boolean"
 true
 "nil-value"
 nil
 "text"
 "Hello world!"
 "list"
 (1 2 3)
 "vector"
 [1 2 3]
 "a-set"
 #{1 4 3 2}
 "map"
 {:name "foo", :surname "bar"}]
&nbsp;
Done
</pre>

<p><div class="rs-tip-major">Poznámka: povšimněte si, že příkaz
<strong>hset</strong> vrací počet prvků vložených do mapy. Pokud se provedlo
více těchto operací současně v&nbsp;rámci makra <strong>wcar*</strong>, vrátí
se vektor těchto hodnot:</div></p>

<pre>
hset operation
[1 1 1 1 1 1 1 1 1 1 1]
</pre>



<p><a name="k08"></a></p>
<h2 id="k08">8. Množiny s&nbsp;ohodnocenými prvky (uspořádané množiny)</h2>

<p>Posledním datovým typem Redisu, o kterém se v&nbsp;dnešním článku zmíníme,
jsou množiny s&nbsp;ohodnocenými prvky. V&nbsp;tomto datovém typu (kontejneru)
je každému prvku přiřazeno číslo, které je následně použito při porovnávání
jednotlivých prvků (množina je tedy částečně uspořádaná), při zpětném čtení
prvků apod. To se hodí například při implementaci prioritních front apod.
Příkazy, které s&nbsp;tímto datovým typem pracují, začínají prefixem
&bdquo;z&ldquo;. Nejprve vytvoříme novou množinu a přidáme do ní několik prvků.
Zadané číslo odpovídá ohodnocení prvků:</p>

<pre>
127.0.0.1:6379&gt; <strong>zadd set 100 x</strong>
(integer) 1
&nbsp;
127.0.0.1:6379&gt; <strong>zadd set 150 y</strong>
(integer) 1
&nbsp;
127.0.0.1:6379&gt; <strong>zadd set 50 z</strong>
(integer) 1
&nbsp;
127.0.0.1:6379&gt; <strong>zadd set -5 w</strong>
(integer) 1
</pre>

<p>Hodnota ve skutečnosti může být reálné číslo, nikoli pouze číslo celé:</p>

<pre>
127.0.0.1:6379&gt; <strong>zadd set 0.5 a</strong>
(integer) 1
</pre>

<p>Aktuální pořadí prvku (na základě jeho ohodnocení) přečteme příkazem
<strong>zrank</strong>:</p>

<pre>
127.0.0.1:6379&gt; <strong>zrank set x</strong>
(integer) 3
&nbsp;
127.0.0.1:6379&gt; <strong>zrank set w</strong>
(integer) 0
&nbsp;
127.0.0.1:6379&gt; <strong>zrank set foo</strong>
(nil)
</pre>

<p>Dále můžeme získat počet prvků množiny příkazem <strong>zcard</strong>,
popř.&nbsp;příkazem <strong>zcount</strong> zjistit počet takových prvků,
jejichž skóre (ohodnocení) leží v&nbsp;nějakém zadaném intervalu:</p>

<pre>
127.0.0.1:6379&gt; <strong>zcard set</strong>
(integer) 4
&nbsp;
127.0.0.1:6379&gt; <strong>zcount set -1000 1000</strong>
(integer) 4
&nbsp;
127.0.0.1:6379&gt; <strong>zcount set 0 1000</strong>
(integer) 3
</pre>

<p>Ohodnocení je možné změnit příkazem <strong>zincrby</strong>, kterému se
zadá relativní přírůstek (samozřejmě může být i záporný a opět se nemusí jednat
o celé číslo):</p>

<pre>
127.0.0.1:6379&gt; <strong>zrank set x</strong>
(integer) 3
&nbsp;
127.0.0.1:6379&gt; <strong>zincrby set 1000 x</strong>
"1100"
&nbsp;
127.0.0.1:6379&gt; <strong>zrank set x</strong>
(integer) 4
&nbsp;
127.0.0.1:6379&gt; <strong>zincrby set -2000 x</strong>
"-900"
&nbsp;
127.0.0.1:6379&gt; <strong>zrank set x</strong>
(integer) 0
</pre>

<p>Nad uspořádanými množinami je možné provádět i některé další operace,
například získat ty prvky, jejichž ohodnocení se nachází mezi specifikovanými
mezními hodnotami:</p>

<pre>
127.0.0.1:6379&gt; <strong>zrangebyscore set 1 200</strong>
1) "z"
2) "y"
&nbsp;
127.0.0.1:6379&gt; <strong>zrangebyscore set 1 300</strong>
1) "z"
2) "y"
3) "x"
</pre>

<p>Příkazem <strong>zremrangebyscore</strong> lze odstranit prvky, jejichž
ohodnocení (skóre) se nachází mezi mezními hodnotami (opět užitečné při
implementaci některých variant prioritních front):</p>

<pre>
127.0.0.1:6379&gt; <strong>zremrangebyscore set 1 200</strong>
(integer) 2
&nbsp;
127.0.0.1:6379&gt; <strong>zrangebyscore set -1000 1000</strong>
1) "w"
2) "x"
</pre>

<p>Pokus o vymazání prvků se skóre, které v&nbsp;množině neleží:</p>

<pre>
127.0.0.1:6379&gt; <strong>zremrangebyscore set 1 200</strong>
(empty list or set)
</pre>



<p><a name="k09"></a></p>
<h2 id="k09">9. Uspořádané množiny a jazyk Clojure</h2>

<p>I manipulace s&nbsp;uspořádanými množinami je podle očekávání podporovaná
knihovnou Carmine a tím pádem dostupná pro aplikace naprogramované
v&nbsp;Clojure. Základní operace jsou ukázány v&nbsp;dalším demonstračním
příkladu. Funkce a makra definovaná v&nbsp;knihovně Carmine odpovídají přímo
protokolu Redisu (ostatně jedná se o generovaná jména, takže je plná
kompatibilita Carmine-Redis zaručena automaticky):</p>

<pre>
(ns <strong>carmineC.core</strong>
  (:require [taoensso.carmine :as carmine :refer (wcar)]
            [clojure.pprint :as pprint]))
&nbsp;
&nbsp;
(def <strong>redis-connection</strong> {
  :pool {}
  :spec {
    :uri "redis://localhost@127.0.0.1:6379"}})
&nbsp;
&nbsp;
(defmacro <strong>wcar*</strong>
  [&amp; body]
  `(carmine/wcar redis-connection ~@body))
&nbsp;
&nbsp;
(defn <strong>-main</strong>
  [&amp; args]
  (println "Working with sorted sets")
&nbsp;
  (println "Fill in sorted set s1")
  (println
    (wcar*
      (carmine/zadd :s1 0.9 :a)
      (carmine/zadd :s1 0.8 :b)
      (carmine/zadd :s1 0.7 :c)
      (carmine/zadd :s1 0.6 :d)))
&nbsp;
  (println "Retrieving items from sorted set s1")
  (println
    (wcar*
      (carmine/zcard :s1)
      (carmine/zrangebyscore :s1 0 100)
      (carmine/zrangebyscore :s1 0.65 0.85)))
&nbsp;
  (println "Done"))
</pre>

<p>Po spuštění tohoto demonstračního příkladu získáme následující
informace:</p>

<pre>
Working with sorted sets
Fill in sorted set s1
[1 1 1 1]
Retrieving items from sorted set s1
[4 [d c b a] [c b]]
Done
</pre>

<p>Důležiý je především výpis prvků s&nbsp;ohonocením 0..100 a poté 0.65 až
0.85:</p>

<pre>
[d c b a]
[c b]
</pre>



<p><a name="k10"></a></p>
<h2 id="k10">10. Komunikační strategie publish-subscribe</h2>

<p>Jedna z&nbsp;velmi užitečných technologií, kterou najdeme v&nbsp;Redisu, je
technologie implementující paradigma <i>publish-subscribe</i> (nebo též
<i>publisher-subscriber</i>). Jedná se o jednu z&nbsp;forem posílání zpráv mezi
několika subsystémy, které tak mohou pracovat relativně samostatně, mohou být
nakonfigurovány a administrovány nezávisle na sobě a případná změna
architektury může být snadnější, než kdyby byly tyto subsystémy propojeny přímo
(například přes nějaké binární API). V&nbsp;praxi se setkáme jak
s&nbsp;paradigmatem pojmenovaným <i>publish-subscribe</i>, tak i
s&nbsp;frontami zpráv (<i>message queues</i>), ovšem mezi oběma technologiemi
existuje několik rozdílů a každá se proto používá k&nbsp;odlišným účelům.</p>

<p>Nejprve se budeme zabývat komunikační strategií <i>publish-subscribe</i>.
Mezi vlastnosti této komunikační strategie patří:</p>

<ol>
<li>Existuje jeden či několik zdrojů zpráv.</li>
<li>Příjemců může být taktéž více, zpráva je doručena všem příjemcům, kteří se k&nbsp;odběru přihlásili.</li>
<li>Pořadí zpráv je zaručeno.</li>
<li>Většinou není zaručeno zpracování a ani přijetí zprávy (pokud se například příjemce odpojí, zbytku &bdquo;pipeline&ldquo; to nevadí).</li>
</ol>

<p>Toto paradigma se může použít například při implementaci různých
komunikačních systémů atd. Příkladem může být chat, kde záleží na pořadí
doručení zpráv a příjemců je většinou větší množství. Popř.&nbsp;se tato
strategie používá v&nbsp;IoT, kde je důležité poslat (a přijmout) aktuální data
a nikoli sledovat minulé hodnoty.</p>

<p>V&nbsp;Redisu nalezneme následujících šest příkazů, kterými je
implementována komunikační strategie <i>publish-subscribe</i>:</p>

<table>
<tr><th>Příkaz</th><th>Stručný popis příkazu</th></tr>
<tr><td>SUBSCRIBE</td><td>přihlášení se k&nbsp;odebírání jednoho kanálu nebo většího množství kanálů</td></tr>
<tr><td>UNSUBSCRIBE</td><td>opak předchozího, odhlášení se z&nbsp;odebírání specifikovaných kanálů (popř. ze všech kanálů)</td></tr>
<tr><td>&nbsp;</td><td>&nbsp;</td></tr>
<tr><td>PSUBSCRIBE</td><td>odpovídá SUBSCRIBE, ovšem pro jméno kanálu lze použít žolíkové znaky</td></tr>
<tr><td>PUNSUBSCRIBE</td><td>odpovídá UNSUBSCRIBE, ovšem pro jméno kanálu lze použít žolíkové znaky</td></tr>
<tr><td>&nbsp;</td><td>&nbsp;</td></tr>
<tr><td>PUBLISH</td><td>publikování zprávy do zvoleného kanálu</td></tr>
<tr><td>&nbsp;</td><td>&nbsp;</td></tr>
<tr><td>PUBSUB</td><td>získání podrobnějších informací o stavu kanálů, přihlášených odebíratelů zpráv atd.</td></tr>
</table>

<p>U příkazů <strong>psubscribe</strong> a <strong>punsubscribe</strong> je
možné ve jménu kanálu používat takzvané <i>žolíkové znaky</i>, které
s&nbsp;velkou pravděpodobností znáte například z&nbsp;BASHe při specifikaci
souborů. Mezi tyto znaky patří především hvězdička (nahrazuje libovolně dlouhou
sekvenci znaků), otazník (nahrazuje jeden libovolný znak) a zápis množiny
znaků: [znaky]. Žolíkové znaky se odlišují od zápisu regulárních výrazů
především v&nbsp;tom, že &bdquo;*&ldquo; a &bdquo;?&ldquo; před sebou
neobsahují specifikaci, jakých znaků se náhrada týká (tj.&nbsp;nepíše se
například &bdquo;.*&ldquo; ale jen &bdquo;*&ldquo;). Více informací je uvedeno
například na stránce <a
href="https://en.wikipedia.org/wiki/Glob_(programming)">https://en.wikipedia.org/wiki/Glob_(programming)</a>.</p>

<p><div class="rs-tip-major">Poznámka: protokol používaný Redisem je většinou
založen na té nejjednodušší možné komunikaci typu dotaz-odpověď. To znamená, že
každý příkaz poslaný klientem na server je následován odpovědí serveru zpět
klientovi. Typicky jsou buď klientovi poslána data nebo alespoň celočíselná
hodnota 0 nebo 1 reprezentující úspěch popř.&nbsp;neúspěch příkazu. Existují
však tři výjimky, kdy se dotaz-odpověď nepoužívá. První výjimkou jsou takzvané
<i>pipeline</i>, kdy klient zasílá více příkazů v&nbsp;jednom balíčku. Druhou
výjimkou je právě použití <i>Pub/Sub</i> kanálů, protože v&nbsp;této chvíli se
začne používat <i>push</i> protokol &ndash; server sám začíná posílat zprávy ve
chvíli, kdy jsou publikovány nějakým jiným klientem. Třetí výjimka se objevila
v&nbsp;páté verzi Redisu a souvisí se <i>streamy</i> a příkazem
<strong>XREAD</strong>. Popisem streamů se však dnes zabývat
nebudeme.</div></p>



<p><a name="k11"></a></p>
<h2 id="k11">11. Program konzumující zprávy (subscriber)</h2>

<p>Vytvoření samotného konzumenta zpráv v&nbsp;jazyce Clojure je ve skutečnosti
poměrně triviální. Postačuje totiž použít makro
<strong>with-new-pubsub-listener</strong>, v&nbsp;němž se uvede seznam kanálů
(resp.&nbsp;jejich jmen) a funkce, která se má zavolat ve chvíli, kdy je do
daného kanálu poslána zpráva. Například pro kanál pojmenovaný
&bdquo;events&ldquo; můžeme takovou (anonymní) funkci definovat následovně:</p>

<pre>
{"events" (fn f [event] (println "Received event" event))}
</pre>

<p>Konzument ovšem může přijímat zprávy z&nbsp;většího množství kanálů:</p>

<pre>
{"kanál1" (fn f [event] (println "Received event" event))}
{"kanál2" (fn f [event] (println "Received event" event))}
{"kanál3" (fn f [event] (println "Received event" event))}
</pre>

<p>Popř.:</p>

<pre>
{"kanál*" (fn f [event] (println "Received event" event))}
</pre>

<p>Podívejme se nyní na úplný zdrojový kód konzumenta zpráv:</p>

<pre>
(ns <strong>carmineD.core</strong>
  (:require [taoensso.carmine :as carmine :refer (wcar)]
            [clojure.pprint :as pprint]))
&nbsp;
&nbsp;
(def <strong>redis-connection</strong> {
  :pool {}
  :spec {
    :uri "redis://localhost@127.0.0.1:6379"}})
&nbsp;
&nbsp;
(defmacro <strong>wcar*</strong>
  [&amp; body]
  `(carmine/wcar redis-connection ~@body))
&nbsp;
(defn <strong>-main</strong>
  [&amp; args]
  (println "Listener to given channel")
&nbsp;
  (carmine/with-new-pubsub-listener
    (:spec redis-connection)
    {"events" (fn f [event] (println "Received event" event))}
    (carmine/subscribe "events")))
</pre>



<p><a name="k12"></a></p>
<h2 id="k12">12. Program produkující zprávy (publisher)</h2>

<p>Následující program po svém spuštění vytvoří sto zpráv, které budou poslány
do kanálu &bdquo;events&ldquo;. V&nbsp;případě, že bude současně spuštěný i
předchozí příklad, budou zprávy přijaty, v&nbsp;opačném případě zahozeny:</p>

<pre>
(ns <strong>carmineE.core</strong>
  (:require [taoensso.carmine :as carmine :refer (wcar)]))
&nbsp;
&nbsp;
(def <strong>redis-connection</strong> {
  :pool {}
  :spec {
    :uri "redis://localhost@127.0.0.1:6379"}})
&nbsp;
&nbsp;
(defmacro <strong>wcar*</strong>
  [&amp; body]
  `(carmine/wcar redis-connection ~@body))
&nbsp;
(defn <strong>-main</strong>
  [&amp; args]
  (println "Publisher")
&nbsp;
  (doseq [i (range 100)]
    (println i)
    (println (wcar* (carmine/publish "events" (* i 100))))))
</pre>

<p><div class="rs-tip-major">Poznámka: sami si vyzkoušejte, jak bude situace
vypadat ve chvíli, kdy se spustí větší množství producentů zpráv
popř.&nbsp;větší množství konzumentů &ndash; vše za předpokladu, že se použije
shodné jméno komunikačního kanálu.</div></p>



<p><a name="k13"></a></p>
<h2 id="k13">13. Použití front pro komunikaci</h2>

<p>Knihovna Carmine obsahuje podporu pro tvorbu aplikací, které spolu
komunikují přes fronty zpráv. V&nbsp;dalších dvou kapitolách si ukážeme jak
producenta, tak i konzumenta takto posílaných zpráv, ovšem nejprve si
připomeňme typické vlastnosti front zpráv (které se v&nbsp;některých ohledech
liší od komuniační strategie <i>publish-subscribe</i>):</p>

<ol>
<li>Existuje jeden či několik zdrojů zpráv.</li>
<li>Příjemců může být taktéž více, ovšem zpráva je typicky získána jen jedním z&nbsp;nich (příjemci se tedy o zprávy dělí).</li>
<li>Obecně není zaručeno pořadí doručení zpráv.</li>
<li>Zpráva je zpracována jen jedenkrát, ovšem pokud ji příjemce nezpracuje, může být doručena dalšímu příjemci.</li>
<li>Volitelná vlastnost související s&nbsp;předchozím bodem: po nezpracování se zpráva vrací zpět do fronty.</li>
</ol>

<p>Fronty zpráv se používají velmi často například ve chvíli, kdy se
zpracovávají různé transakce, u nichž není nutné, aby jejich výsledek uživatel
viděl v&nbsp;reálném čase. Do fronty se pouze uloží všechny informace o tom,
jaká transakce se má provést a později si tuto operaci z&nbsp;fronty vyzvedne
nějaký &bdquo;worker&ldquo;.</p>

<p>Alternativně lze fronty zpráv obecně využít pro dělbu práce mezi větším
množstvím &bdquo;workerů&ldquo;, kteří mohou být vhodným způsobem naškálovány,
mohou se zapnout v&nbsp;době, kdy je volný strojový čas atd.</p>



<p><a name="k14"></a></p>
<h2 id="k14">14. Implementace workera přijímacího úkoly přes frontu</h2>

<p>Ukažme si nyní, jak snadné je vytvoření workera, který přijímá úkoly přes
frontu, konkrétně přes frontu nazvanou &bdquo;task-queue&ldquo;. Povšimněte si,
že při přijetí zprávy se zavolá takzvaný <i>handler</i>, což je v&nbsp;našem
případě anonymní funkce. Důležité je, aby tato funkce potvrdila přijetí zprávy
tím, že vrátí hodnotu <strong>{:status :success}</strong>:</p>

<pre>
(fn [{:keys [message attempt]}]
    (println "Received" message)
    {:status :success})
</pre>

<p>Samotná obsluha fronty je v&nbsp;balíčku
<strong>taoensso.carmine.message-queue</strong>, což znamená odlišnou hlavičku
programu:</p>

<pre>
(ns <strong>carmineF.core</strong>
  (:require [taoensso.carmine.message-queue :as car-mq]))
</pre>

<p>Podívejme se nyní na úplný zdrojový kód workera:</p>

<pre>
(ns <strong>carmineF.core</strong>
  (:require [taoensso.carmine.message-queue :as car-mq]))
&nbsp;
&nbsp;
(def <strong>redis-connection</strong> {
  :pool {}
  :spec {
    :uri "redis://localhost@127.0.0.1:6379"}})
&nbsp;
&nbsp;
(defmacro <strong>wcar*</strong>
  [&amp; body]
  `(carmine/wcar redis-connection ~@body))
&nbsp;
(defn <strong>-main</strong>
  [&amp; args]
  (println "Worker")
&nbsp;
  (car-mq/worker {:spec redis-connection} "task-queue"
   {:handler (fn [{:keys [message attempt]}]
               (println "Received" message)
               {:status :success})})
&nbsp;
  ;(car-mq/stop my-worker)
)
</pre>

<p><div class="rs-tip-major">Poznámka: forma <strong>car-mq/stop</strong> by se
měla zavolat ve chvíli, kdy již klient nepotřebuje s&nbsp;frontou pracovat.
V&nbsp;našem konkrétním případě však k&nbsp;zavolání této formy stejně nedojde,
takže je zakomentována.</div></p>



<p><a name="k15"></a></p>
<h2 id="k15">15. Klient vytvářející zprávy pro workery</h2>

<p>Zprávy posílané do fronty &bdquo;task-queue&ldquo; můžeme pochopitelně
vytvářet přímo v&nbsp;řádkovém klientu Redisu (<strong>redis-cli</strong>),
ovšem pochopitelně je možné pro tento účel opět použít aplikaci naprogramovanou
v&nbsp;jazyku Clojure. Po spuštění následujícího skriptu se do fronty
&bdquo;task-queue&ldquo; vloží sto zpráv, které mohou být kdykoli později
přečteny:</p>

<pre>
(ns <strong>carmineG.core</strong>
  (:require [taoensso.carmine :as carmine :refer (wcar)]
            [taoensso.carmine.message-queue :as car-mq]))
&nbsp;
&nbsp;
(def <strong>redis-connection</strong> {
  :pool {}
  :spec {
    :uri "redis://localhost@127.0.0.1:6379"}})
&nbsp;
&nbsp;
(defmacro <strong>wcar*</strong>
  [&amp; body]
  `(carmine/wcar redis-connection ~@body))
&nbsp;
(defn <strong>-main</strong>
  [&amp; args]
  (println "")
&nbsp;
  (doseq [i (range 100)]
    (println i)
    (println (wcar* (car-mq/enqueue "task-queue" (* i 100))))))
</pre>

<p><div class="rs-tip-major">Poznámka: opět si vyzkoušejte paralelní spuštění
většího množství workerů popř.&nbsp;i producentů zpráv, aby bylo zřejmé, jakým
způsobem komunikace přes fronty reálně probíhá.</div></p>



<p><a name="k16"></a></p>
<h2 id="k16">16. Seznam popsaných maker a funkcí knihovny Carmine</h2>

<table>
<tr><th>Makro/funkce</th><th>Oblast/typ</th><th>Stručný popis</th></tr>
<tr><td><a href="http://ptaoussanis.github.io/carmine/taoensso.carmine.html#var-ping">ping</a></td><td>komunikační protokol</td><td>dotaz, zda je Redis připraven</td></tr>
<tr><td><a href="http://ptaoussanis.github.io/carmine/taoensso.carmine.html#var-pong">pong</a></td><td>komunikační protokol</td><td>odpověď Redisu na příkaz <strong>ping</strong></td></tr>
<tr><td><a href="http://ptaoussanis.github.io/carmine/taoensso.carmine.html#var-info">info</a></td><td>komunikační protokol</td><td>dotaz na vlastnosti Redisu</td></tr>
<tr><td><a href="http://ptaoussanis.github.io/carmine/taoensso.carmine.html#var-type">type</a></td><td>komunikační protokol</td><td>získání typu prvky</td></tr>
<tr><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td></tr>
<tr><td><a href="http://ptaoussanis.github.io/carmine/taoensso.carmine.html#var-set">set</a></td><td>řetězce</td><td>uložení řetězce nebo serializovaného objektu</td></tr>
<tr><td><a href="http://ptaoussanis.github.io/carmine/taoensso.carmine.html#var-get">get</a></td><td>řetězce</td><td>načtení řetězce nebo serializovaného objektu</td></tr>
<tr><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td></tr>
<tr><td><a href="http://ptaoussanis.github.io/carmine/taoensso.carmine.html#var-incr">incr</a></td><td>numerické hodnoty</td><td>změna uložené hodnoty o jedničku</td></tr>
<tr><td><a href="http://ptaoussanis.github.io/carmine/taoensso.carmine.html#var-incrby">incrby</a></td><td>numerické hodnoty</td><td>změna uložené hodnoty</td></tr>
<tr><td><a href="http://ptaoussanis.github.io/carmine/taoensso.carmine.html#var-decr">decr</a></td><td>numerické hodnoty</td><td>změna uložené hodnoty o jedničku</td></tr>
<tr><td><a href="http://ptaoussanis.github.io/carmine/taoensso.carmine.html#var-decrby">decrby</a></td><td>numerické hodnoty</td><td>změna uložené hodnoty</td></tr>
<tr><td><a href="http://ptaoussanis.github.io/carmine/taoensso.carmine.html#var-incrbyfloat">incrbyfloat</a></td><td>numerické hodnoty</td><td>změna uložené hodnoty</td></tr>
<tr><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td></tr>
<tr><td><a href="http://ptaoussanis.github.io/carmine/taoensso.carmine.html#var-lpush">lpush</a></td><td>seznamy</td><td>přidání prvku na začátek seznamu</td></tr>
<tr><td><a href="http://ptaoussanis.github.io/carmine/taoensso.carmine.html#var-rpush">rpush</a></td><td>seznamy</td><td>přidání prvku na konec seznamu</td></tr>
<tr><td><a href="http://ptaoussanis.github.io/carmine/taoensso.carmine.html#var-lpop">lpop</a></td><td>seznamy</td><td>přečtení prvního prvku ze seznamu s&nbsp;jeho odstraněním</td></tr>
<tr><td><a href="http://ptaoussanis.github.io/carmine/taoensso.carmine.html#var-rpop">rpop</a></td><td>seznamy</td><td>přečtení posledního prvku ze seznamu s&nbsp;jeho odstraněním</td></tr>
<tr><td><a href="http://ptaoussanis.github.io/carmine/taoensso.carmine.html#var-lset">lset</a></td><td>seznamy</td><td>změna hodnoty prvku na určeném indexu v&nbsp;seznamu</td></tr>
<tr><td><a href="http://ptaoussanis.github.io/carmine/taoensso.carmine.html#var-lindex">lindex</a></td><td>seznamy</td><td>přečtení prvku se zadaným indexem</td></tr>
<tr><td><a href="http://ptaoussanis.github.io/carmine/taoensso.carmine.html#var-linsert">linsert</a></td><td>seznamy</td><td>přidání prvku na určený index seznamu (s&nbsp;posunem dalších prvků)</td></tr>
<tr><td><a href="http://ptaoussanis.github.io/carmine/taoensso.carmine.html#var-llen">llen</a></td><td>seznamy</td><td>přečtení délky seznamu</td></tr>
<tr><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td></tr>
<tr><td><a href="http://ptaoussanis.github.io/carmine/taoensso.carmine.html#var-sadd">sadd</a></td><td>množiny</td><td>přidání prvku či prvků do množiny</td></tr>
<tr><td><a href="http://ptaoussanis.github.io/carmine/taoensso.carmine.html#var-scard">scard</a></td><td>množiny</td><td>získání počtu prvků množiny</td></tr>
<tr><td><a href="http://ptaoussanis.github.io/carmine/taoensso.carmine.html#var-smembers">smembers</a></td><td>množiny</td><td>přečtení prvků z&nbsp;množiny</td></tr>
<tr><td><a href="http://ptaoussanis.github.io/carmine/taoensso.carmine.html#var-sismember">sismember</a></td><td>množiny</td><td>test existence prvku</td></tr>
<tr><td><a href="http://ptaoussanis.github.io/carmine/taoensso.carmine.html#var-srem">srem</a></td><td>množiny</td><td>odstranění prvku z&nbsp;množiny</td></tr>
<tr><td><a href="http://ptaoussanis.github.io/carmine/taoensso.carmine.html#var-sunion">sunion</a></td><td>množiny</td><td>množinové sjednocení bez uložení výsledků</td></tr>
<tr><td><a href="http://ptaoussanis.github.io/carmine/taoensso.carmine.html#var-sinter">sinter</a></td><td>množiny</td><td>množinový průnik bez uložení výsledků</td></tr>
<tr><td><a href="http://ptaoussanis.github.io/carmine/taoensso.carmine.html#var-sdiff">sdiff</a></td><td>množiny</td><td>množinový rozdíl bez uložení výsledků</td></tr>
<tr><td><a href="http://ptaoussanis.github.io/carmine/taoensso.carmine.html#var-sunionstore">sunionstore</a></td><td>množiny</td><td>množinové sjednocení s&nbsp;uložením výsledků</td></tr>
<tr><td><a href="http://ptaoussanis.github.io/carmine/taoensso.carmine.html#var-sinterstore">sinterstore</a></td><td>množiny</td><td>množinový průnik s&nbsp;uložením výsledků</td></tr>
<tr><td><a href="http://ptaoussanis.github.io/carmine/taoensso.carmine.html#var-sdiffstore">sdiffstore</a></td><td>množiny</td><td>množinový rozdíl s&nbsp;uložením výsledků</td></tr>
<tr><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td></tr>
<tr><td><a href="http://ptaoussanis.github.io/carmine/taoensso.carmine.html#var-hset">hset</a></td><td>mapy</td><td>vložení prvku do mapy</td></tr>
<tr><td><a href="http://ptaoussanis.github.io/carmine/taoensso.carmine.html#var-hget">hget</a></td><td>mapy</td><td>přečtení prvku z&nbsp;mapy</td></tr>
<tr><td><a href="http://ptaoussanis.github.io/carmine/taoensso.carmine.html#var-hmset">hmset</a></td><td>mapy</td><td>vložení více prvků do mapy</td></tr>
<tr><td><a href="http://ptaoussanis.github.io/carmine/taoensso.carmine.html#var-hgetall">hgetall</a></td><td>mapy</td><td>přečtení všech prvků z&nbsp;mapy</td></tr>
<tr><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td></tr>
<tr><td><a href="http://ptaoussanis.github.io/carmine/taoensso.carmine.html#var-zadd">zadd</a></td><td>množiny s&nbsp;ohodnocenými prvky</td><td>přidání prvku</td></tr>
<tr><td><a href="http://ptaoussanis.github.io/carmine/taoensso.carmine.html#var-zrank">zrank</a></td><td>množiny s&nbsp;ohodnocenými prvky</td><td>pořadí prvku</td></tr>
<tr><td><a href="http://ptaoussanis.github.io/carmine/taoensso.carmine.html#var-zcard">zcard</a></td><td>množiny s&nbsp;ohodnocenými prvky</td><td>počet prvků v&nbsp;množině</td></tr>
<tr><td><a href="http://ptaoussanis.github.io/carmine/taoensso.carmine.html#var-zcount">zcount</a></td><td>množiny s&nbsp;ohodnocenými prvky</td><td>počet prvků s&nbsp;ohodnocením x až y</td></tr>
<tr><td><a href="http://ptaoussanis.github.io/carmine/taoensso.carmine.html#var-zincrby">zincrby</a></td><td>množiny s&nbsp;ohodnocenými prvky</td><td>změna ohodnocení prvku</td></tr>
<tr><td><a href="http://ptaoussanis.github.io/carmine/taoensso.carmine.html#var-zrangebyscore">zrangebyscore</a></td><td>množiny s&nbsp;ohodnocenými prvky</td><td>prvky s&nbsp;ohodnocením x až y</td></tr>
<tr><td><a href="http://ptaoussanis.github.io/carmine/taoensso.carmine.html#var-zremrangebyscore">zremrangebyscore</a></td><td>množiny s&nbsp;ohodnocenými prvky</td><td>odstranění prvků s&nbsp;ohodnocením x až y</td></tr>
</table>



<p><a name="k17"></a></p>
<h2 id="k17">17. Repositář s&nbsp;demonstračními příklady</h2>

<p>Všechny <a
href="https://www.root.cz/clanky/vyuziti-redisu-z-jazyka-clojure-pomoci-knihovny-carmine/">minule</a>
i dnes popsané demonstrační příklady byly uloženy do repositáře dostupného na
adrese <a
href="https://github.com/tisnik/clojure-examples/">https://github.com/tisnik/clojure-examples/</a>.
V&nbsp;tabulce umístěné pod tímto odstavcem jsou uvedeny odkazy na tyto
příklady (vždy se přitom jedná o plnohodnotný projekt vyžadující jak samotný
jazyk Clojure, tak i Leiningen a pochopitelně i virtuální stroj Javy):</p>

<table>
<tr><th> #</th><th>Projekt</th><th>Popis projektu</th><th>Cesta</th></tr>
<tr><td> 1</td><td>carmine1</td><td>připojení k&nbsp;Redisu, poslání zprávy PING a obdržení zprávy PONG</td><td><a href="https://github.com/tisnik/clojure-examples/tree/master/carmine1">https://github.com/tisnik/clojure-examples/tree/master/carmine1</a></td></tr>
<tr><td> 2</td><td>carmine2</td><td>pomocné makro <strong>wcar*</strong> vytvořené pro každé připojení k&nbsp;Redisu</td><td><a href="https://github.com/tisnik/clojure-examples/tree/master/carmine2">https://github.com/tisnik/clojure-examples/tree/master/carmine2</a></td></tr>
<tr><td> 3</td><td>carmine3</td><td>alternativní způsob definice připojení k&nbsp;Redisu</td><td><a href="https://github.com/tisnik/clojure-examples/tree/master/carmine3">https://github.com/tisnik/clojure-examples/tree/master/carmine3</a></td></tr>
<tr><td> 4</td><td>carmine4</td><td>uložení řetězce a zpětné přečtení řetězce realizované v&nbsp;Clojure</td><td><a href="https://github.com/tisnik/clojure-examples/tree/master/carmine4">https://github.com/tisnik/clojure-examples/tree/master/carmine4</a></td></tr>
<tr><td> 5</td><td>carmine5</td><td>využití příkazu <strong>incr</strong></td><td><a href="https://github.com/tisnik/clojure-examples/tree/master/carmine5">https://github.com/tisnik/clojure-examples/tree/master/carmine5</a></td></tr>
<tr><td> 6</td><td>carmine6</td><td>uložení strukturovaných dat do Redisu</td><td><a href="https://github.com/tisnik/clojure-examples/tree/master/carmine6">https://github.com/tisnik/clojure-examples/tree/master/carmine6</a></td></tr>
<tr><td> 7</td><td>carmine7</td><td>manipulace se seznamy uloženými v&nbsp;Redisu</td><td><a href="https://github.com/tisnik/clojure-examples/tree/master/carmine7">https://github.com/tisnik/clojure-examples/tree/master/carmine7</a></td></tr>
<tr><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td></tr>
<tr><td> 8</td><td>carmine8</td><td>základní operace s&nbsp;množinami</td><td><a href="https://github.com/tisnik/clojure-examples/tree/master/carmine8">https://github.com/tisnik/clojure-examples/tree/master/carmine8</a></td></tr>
<tr><td> 9</td><td>carmine9</td><td>množinové operace s&nbsp;uložením výsledku do nové množiny</td><td><a href="https://github.com/tisnik/clojure-examples/tree/master/carmine9">https://github.com/tisnik/clojure-examples/tree/master/carmine9</a></td></tr>
<tr><td>10</td><td>carmineA</td><td>množinové operace s&nbsp;posláním výsledku bez ukládání</td><td><a href="https://github.com/tisnik/clojure-examples/tree/master/carmineA">https://github.com/tisnik/clojure-examples/tree/master/carmineA</a></td></tr>
<tr><td>11</td><td>carmineB</td><td>práce s&nbsp;mapami</td><td><a href="https://github.com/tisnik/clojure-examples/tree/master/carmineB">https://github.com/tisnik/clojure-examples/tree/master/carmineB</a></td></tr>
<tr><td>12</td><td>carmineC</td><td>práce s&nbsp;uspořádanými množinami</td><td><a href="https://github.com/tisnik/clojure-examples/tree/master/carmineC">https://github.com/tisnik/clojure-examples/tree/master/carmineC</a></td></tr>
<tr><td>13</td><td>carmineD</td><td>komunikace typu <i>pub-sub</i>: příjemce zpráv</td><td><a href="https://github.com/tisnik/clojure-examples/tree/master/carmineD">https://github.com/tisnik/clojure-examples/tree/master/carmineD</a></td></tr>
<tr><td>14</td><td>carmineE</td><td>komunikace typu <i>pub-sub</i>: odesílatel zpráv</td><td><a href="https://github.com/tisnik/clojure-examples/tree/master/carmineE">https://github.com/tisnik/clojure-examples/tree/master/carmineE</a></td></tr>
<tr><td>15</td><td>carmineF</td><td>komunikace přes frontu (<i>queue</i>): implementace workera</td><td><a href="https://github.com/tisnik/clojure-examples/tree/master/carmineF">https://github.com/tisnik/clojure-examples/tree/master/carmineF</a></td></tr>
<tr><td>16</td><td>carmineG</td><td>komunikace přes frontu (<i>queue</i>): tvorba úloh pro workery</td><td><a href="https://github.com/tisnik/clojure-examples/tree/master/carmineG">https://github.com/tisnik/clojure-examples/tree/master/carmineG</a></td></tr>
</table>



<p><a name="k18"></a></p>
<h2 id="k18">18. Předchozí články o systému Redis</h2>

<p>Se systémem Redis jsme se již na stránkách Rootu setkali, a to dokonce
několikrát. Buď jsme si popisovali přímo přístup k&nbsp;Redisu z&nbsp;různých
programovacích jazyků (což je konkrétně případ všech dále zmíněných článků
zaměřených na jazyky <a href="https://www.root.cz/n/python/">Python</a> a <a
href="https://www.root.cz/serialy/programovaci-jazyk-go/">Go</a>) nebo byl
Redis použit ve funkci databáze resp.&nbsp;perzistentního úložiště různými <a
href="https://www.root.cz/serialy/message-brokery/">message brokery</a> (<a
href="https://www.root.cz/clanky/celery-system-implementujici-asynchronni-fronty-uloh-pro-python/">Celery</a>,
<a
href="https://www.root.cz/clanky/pouziti-nastroje-rq-redis-queue-pro-spravu-uloh-zpracovavanych-na-pozadi/">RQ</a>,
apod.). Poslední dva články pak popisují problematiku proudů v&nbsp;systému
Redis:</p>

<ol>

<li>Databáze Redis (nejenom) pro vývojáře používající Python<br />
<a href="https://www.root.cz/clanky/databaze-redis-nejenom-pro-vyvojare-pouzivajici-python/">https://www.root.cz/clanky/databaze-redis-nejenom-pro-vyvojare-pouzivajici-python/</a>
</li>

<li>Databáze Redis (nejenom) pro vývojáře používající Python (dokončení)<br />
<a href="https://www.root.cz/clanky/databaze-redis-nejenom-pro-vyvojare-pouzivajici-python-dokonceni/">https://www.root.cz/clanky/databaze-redis-nejenom-pro-vyvojare-pouzivajici-python-dokonceni/</a>
</li>

<li>Použití databáze Redis v&nbsp;aplikacích naprogramovaných v Go<br />
<a href="https://www.root.cz/clanky/pouziti-databaze-redis-v-aplikacich-naprogramovanych-v-go/">https://www.root.cz/clanky/pouziti-databaze-redis-v-aplikacich-naprogramovanych-v-go/</a>
</li>

<li>Použití databáze Redis v&nbsp;aplikacích naprogramovaných v Go (2)<br />
<a href="https://www.root.cz/clanky/pouziti-databaze-redis-v-aplikacich-naprogramovanych-v-go-2/">https://www.root.cz/clanky/pouziti-databaze-redis-v-aplikacich-naprogramovanych-v-go-2/</a>
</li>

<li>Použití nástroje RQ (Redis Queue) pro správu úloh zpracovávaných na pozadí<br />
<a href="https://www.root.cz/clanky/pouziti-nastroje-rq-redis-queue-pro-spravu-uloh-zpracovavanych-na-pozadi/">https://www.root.cz/clanky/pouziti-nastroje-rq-redis-queue-pro-spravu-uloh-zpracovavanych-na-pozadi/</a>
</li>

<li>Proudy (streams) podporované systémem Redis<br />
<a href="https://www.root.cz/clanky/proudy-streams-podporovane-systemem-redis/">https://www.root.cz/clanky/proudy-streams-podporovane-systemem-redis/</a>
</li>

<li>Proudy (streams) podporované systémem Redis (dokončení)<br />
<a href="https://www.root.cz/clanky/proudy-streams-podporovane-systemem-redis-dokonceni/">https://www.root.cz/clanky/proudy-streams-podporovane-systemem-redis-dokonceni/</a>
</li>

</ol>



<p><a name="k19"></a></p>
<h2 id="k19">19. Odkazy na předchozí části seriálu o programovacím jazyku Clojure</h2>

<ol>

<li>Clojure  1: Úvod<br />
<a href="http://www.root.cz/clanky/clojure-aneb-jazyk-umoznujici-tvorbu-bezpecnych-vicevlaknovych-aplikaci-pro-jvm/">http://www.root.cz/clanky/clojure-aneb-jazyk-umoznujici-tvorbu-bezpecnych-vicevlaknovych-aplikaci-pro-jvm/</a>
</li>

<li>Clojure  2: Symboly, kolekce atd.<br />
<a href="http://www.root.cz/clanky/clojure-aneb-jazyk-umoznujici-tvorbu-bezpecnych-vicevlaknovych-aplikaci-pro-jvm-2-cast/">http://www.root.cz/clanky/clojure-aneb-jazyk-umoznujici-tvorbu-bezpecnych-vicevlaknovych-aplikaci-pro-jvm-2-cast/</a>
</li>

<li>Clojure  3: Funkcionální programování<br />
<a href="http://www.root.cz/clanky/clojure-aneb-jazyk-umoznujici-tvorbu-bezpecnych-vicevlaknovych-aplikaci-pro-jvm-3-cast-funkcionalni-programovani/">http://www.root.cz/clanky/clojure-aneb-jazyk-umoznujici-tvorbu-bezpecnych-vicevlaknovych-aplikaci-pro-jvm-3-cast-funkcionalni-programovani/</a>
</li>

<li>Clojure  4: Kolekce, sekvence a lazy sekvence<br />
<a href="http://www.root.cz/clanky/clojure-aneb-jazyk-umoznujici-tvorbu-bezpecnych-vicevlaknovych-aplikaci-pro-jvm-4-cast-kolekce-sekvence-a-lazy-sekvence/">http://www.root.cz/clanky/clojure-aneb-jazyk-umoznujici-tvorbu-bezpecnych-vicevlaknovych-aplikaci-pro-jvm-4-cast-kolekce-sekvence-a-lazy-sekvence/</a>
</li>

<li>Clojure  5: Sekvence, lazy sekvence a paralelní programy<br />
<a href="http://www.root.cz/clanky/clojure-a-bezpecne-aplikace-pro-jvm-sekvence-lazy-sekvence-a-paralelni-programy/">http://www.root.cz/clanky/clojure-a-bezpecne-aplikace-pro-jvm-sekvence-lazy-sekvence-a-paralelni-programy/</a>
</li>

<li>Clojure  6: Podpora pro paralelní programování<br />
<a href="http://www.root.cz/clanky/programovaci-jazyk-clojure-6-futures-nejsou-jen-financni-derivaty/">http://www.root.cz/clanky/programovaci-jazyk-clojure-6-futures-nejsou-jen-financni-derivaty/</a>
</li>

<li>Clojure  7: Další funkce pro paralelní programování<br />
<a href="http://www.root.cz/clanky/programovaci-jazyk-clojure-7-dalsi-podpurne-prostredky-pro-paralelni-programovani/">http://www.root.cz/clanky/programovaci-jazyk-clojure-7-dalsi-podpurne-prostredky-pro-paralelni-programovani/</a>
</li>

<li>Clojure  8: Identity, stavy, neměnné hodnoty a reference<br />
<a href="http://www.root.cz/clanky/programovaci-jazyk-clojure-8-identity-stavy-nemenne-hodnoty-a-referencni-typy/">http://www.root.cz/clanky/programovaci-jazyk-clojure-8-identity-stavy-nemenne-hodnoty-a-referencni-typy/</a>
</li>

<li>Clojure  9: Validátory, pozorovatelé a kooperace s Javou<br />
<a href="http://www.root.cz/clanky/programovaci-jazyk-clojure-9-validatory-pozorovatele-a-kooperace-mezi-clojure-a-javou/">http://www.root.cz/clanky/programovaci-jazyk-clojure-9-validatory-pozorovatele-a-kooperace-mezi-clojure-a-javou/</a>
</li>

<li>Clojure 10: Kooperace mezi Clojure a Javou<br />
<a href="http://www.root.cz/clanky/programovaci-jazyk-clojure-10-kooperace-mezi-clojure-a-javou-pokracovani/">http://www.root.cz/clanky/programovaci-jazyk-clojure-10-kooperace-mezi-clojure-a-javou-pokracovani/</a>
</li>

<li>Clojure 11: Generátorová notace seznamu/list comprehension<br />
<a href="http://www.root.cz/clanky/programovaci-jazyk-clojure-11-generatorova-notace-seznamu-list-comprehension/">http://www.root.cz/clanky/programovaci-jazyk-clojure-11-generatorova-notace-seznamu-list-comprehension/</a>
</li>

<li>Clojure 12: Překlad programů z Clojure do bajtkódu JVM I:<br />
<a href="http://www.root.cz/clanky/programovaci-jazyk-clojure-12-preklad-programu-z-clojure-do-bajtkodu-jvm/">http://www.root.cz/clanky/programovaci-jazyk-clojure-12-preklad-programu-z-clojure-do-bajtkodu-jvm/</a>
</li>

<li>Clojure 13: Překlad programů z Clojure do bajtkódu JVM II:<br />
<a href="http://www.root.cz/clanky/programovaci-jazyk-clojure-13-preklad-programu-z-clojure-do-bajtkodu-jvm-pokracovani/">http://www.root.cz/clanky/programovaci-jazyk-clojure-13-preklad-programu-z-clojure-do-bajtkodu-jvm-pokracovani/</a>
</li>

<li>Clojure 14: Základy práce se systémem maker<br />
<a href="http://www.root.cz/clanky/programovaci-jazyk-clojure-14-zaklady-prace-se-systemem-maker/">http://www.root.cz/clanky/programovaci-jazyk-clojure-14-zaklady-prace-se-systemem-maker/</a>
</li>

<li>Clojure 15: Tvorba uživatelských maker<br />
<a href="http://www.root.cz/clanky/programovaci-jazyk-clojure-15-tvorba-uzivatelskych-maker/">http://www.root.cz/clanky/programovaci-jazyk-clojure-15-tvorba-uzivatelskych-maker/</a>
</li>

<li>Programovací jazyk Clojure &ndash; triky při práci s&nbsp;řetězci<br />
<a href="http://www.root.cz/clanky/programovaci-jazyk-clojure-triky-pri-praci-s-retezci/">http://www.root.cz/clanky/programovaci-jazyk-clojure-triky-pri-praci-s-retezci/</a>
</li>

<li>Programovací jazyk Clojure &ndash; triky při práci s&nbsp;kolekcemi<br />
<a href="http://www.root.cz/clanky/programovaci-jazyk-clojure-triky-pri-praci-s-kolekcemi/">http://www.root.cz/clanky/programovaci-jazyk-clojure-triky-pri-praci-s-kolekcemi/</a>
</li>

<li>Programovací jazyk Clojure &ndash; práce s&nbsp;mapami a množinami<br />
<a href="http://www.root.cz/clanky/programovaci-jazyk-clojure-prace-s-mapami-a-mnozinami/">http://www.root.cz/clanky/programovaci-jazyk-clojure-prace-s-mapami-a-mnozinami/</a>
</li>

<li>Programovací jazyk Clojure &ndash; základy zpracování XML<br />
<a href="http://www.root.cz/clanky/programovaci-jazyk-clojure-zaklady-zpracovani-xml/">http://www.root.cz/clanky/programovaci-jazyk-clojure-zaklady-zpracovani-xml/</a>
</li>

<li>Programovací jazyk Clojure &ndash; testování s využitím knihovny Expectations<br />
<a href="http://www.root.cz/clanky/programovaci-jazyk-clojure-testovani-s-vyuzitim-knihovny-expectations/">http://www.root.cz/clanky/programovaci-jazyk-clojure-testovani-s-vyuzitim-knihovny-expectations/</a>
</li>

<li>Programovací jazyk Clojure &ndash; některé užitečné triky použitelné (nejenom) v&nbsp;testech<br />
<a href="http://www.root.cz/clanky/programovaci-jazyk-clojure-nektere-uzitecne-triky-pouzitelne-nejenom-v-testech/">http://www.root.cz/clanky/programovaci-jazyk-clojure-nektere-uzitecne-triky-pouzitelne-nejenom-v-testech/</a>
</li>

<li>Enlive &ndash; výkonný šablonovací systém pro jazyk Clojure<br/>
<a href="http://www.root.cz/clanky/enlive-vykonny-sablonovaci-system-pro-jazyk-clojure/">http://www.root.cz/clanky/enlive-vykonny-sablonovaci-system-pro-jazyk-clojure/</a>
</li>

<li>Nástroj Leiningen a programovací jazyk Clojure: tvorba vlastních knihoven pro veřejný repositář Clojars<br />
<a href="http://www.root.cz/clanky/nastroj-leiningen-a-programovaci-jazyk-clojure-tvorba-vlastnich-knihoven-pro-verejny-repositar-clojars/">http://www.root.cz/clanky/nastroj-leiningen-a-programovaci-jazyk-clojure-tvorba-vlastnich-knihoven-pro-verejny-repositar-clojars/</a>
</li>

<li>Novinky v&nbsp;Clojure verze 1.8.0<br />
<a href="http://www.root.cz/clanky/novinky-v-clojure-verze-1-8-0/">http://www.root.cz/clanky/novinky-v-clojure-verze-1-8-0/</a>
</li>

<li>Asynchronní programování v&nbsp;Clojure s&nbsp;využitím knihovny core.async<br />
<a href="http://www.root.cz/clanky/asynchronni-programovani-v-clojure-s-vyuzitim-knihovny-core-async/">http://www.root.cz/clanky/asynchronni-programovani-v-clojure-s-vyuzitim-knihovny-core-async/</a>
</li>

<li>Asynchronní programování v&nbsp;Clojure s&nbsp;využitím knihovny core.async (pokračování)<br />
<a href="http://www.root.cz/clanky/asynchronni-programovani-v-clojure-s-vyuzitim-knihovny-core-async-pokracovani/">http://www.root.cz/clanky/asynchronni-programovani-v-clojure-s-vyuzitim-knihovny-core-async-pokracovani/</a>
</li>

<li>Asynchronní programování v&nbsp;Clojure s&nbsp;využitím knihovny core.async (dokončení)<br />
<a href="http://www.root.cz/clanky/asynchronni-programovani-v-clojure-s-vyuzitim-knihovny-core-async-dokonceni/">http://www.root.cz/clanky/asynchronni-programovani-v-clojure-s-vyuzitim-knihovny-core-async-dokonceni/</a>
</li>

<li>Vytváříme IRC bota v&nbsp;programovacím jazyce Clojure<br />
<a href="http://www.root.cz/clanky/vytvarime-irc-bota-v-programovacim-jazyce-clojure/">http://www.root.cz/clanky/vytvarime-irc-bota-v-programovacim-jazyce-clojure/</a>
</li>

<li>Gorilla REPL: interaktivní prostředí pro programovací jazyk Clojure<br />
<a href="https://www.root.cz/clanky/gorilla-repl-interaktivni-prostredi-pro-programovaci-jazyk-clojure/">https://www.root.cz/clanky/gorilla-repl-interaktivni-prostredi-pro-programovaci-jazyk-clojure/</a>
</li>

<li>Multimetody v&nbsp;Clojure aneb polymorfismus bez použití OOP<br />
<a href="https://www.root.cz/clanky/multimetody-v-clojure-aneb-polymorfismus-bez-pouziti-oop/">https://www.root.cz/clanky/multimetody-v-clojure-aneb-polymorfismus-bez-pouziti-oop/</a>
</li>

<li>Práce s&nbsp;externími Java archivy v&nbsp;programovacím jazyku Clojure<br />
<a href="https://www.root.cz/clanky/prace-s-externimi-java-archivy-v-programovacim-jazyku-clojure/">https://www.root.cz/clanky/prace-s-externimi-java-archivy-v-programovacim-jazyku-clojure/</a>
</li>

<li>Clojure 16: Složitější uživatelská makra<br />
<a href="http://www.root.cz/clanky/programovaci-jazyk-clojure-16-slozitejsi-uzivatelska-makra/">http://www.root.cz/clanky/programovaci-jazyk-clojure-16-slozitejsi-uzivatelska-makra/</a>
</li>

<li>Clojure 17: Využití standardních maker v&nbsp;praxi<br />
<a href="http://www.root.cz/clanky/programovaci-jazyk-clojure-17-vyuziti-standardnich-maker-v-praxi/">http://www.root.cz/clanky/programovaci-jazyk-clojure-17-vyuziti-standardnich-maker-v-praxi/</a>
</li>

<li>Clojure 18: Základní techniky optimalizace aplikací<br />
<a href="http://www.root.cz/clanky/programovaci-jazyk-clojure-18-zakladni-techniky-optimalizace-aplikaci/">http://www.root.cz/clanky/programovaci-jazyk-clojure-18-zakladni-techniky-optimalizace-aplikaci/</a>
</li>

<li>Clojure 19: Vývojová prostředí pro Clojure<br />
<a href="http://www.root.cz/clanky/programovaci-jazyk-clojure-19-vyvojova-prostredi-pro-clojure/">http://www.root.cz/clanky/programovaci-jazyk-clojure-19-vyvojova-prostredi-pro-clojure/</a>
</li>

<li>Clojure 20: Vývojová prostředí pro Clojure (Vim s&nbsp;REPL)<br />
<a href="http://www.root.cz/clanky/programovaci-jazyk-clojure-20-vyvojova-prostredi-pro-clojure-integrace-vimu-s-repl/">http://www.root.cz/clanky/programovaci-jazyk-clojure-20-vyvojova-prostredi-pro-clojure-integrace-vimu-s-repl/</a>
</li>

<li>Clojure 21: ClojureScript aneb překlad Clojure do JS<br />
<a href="http://www.root.cz/clanky/programovaci-jazyk-clojure-21-clojurescript-aneb-preklad-clojure-do-javascriptu/">http://www.root.cz/clanky/programovaci-jazyk-clojure-21-clojurescript-aneb-preklad-clojure-do-javascriptu/</a>
</li>

<li>Leiningen: nástroj pro správu projektů napsaných v&nbsp;Clojure<br />
<a href="http://www.root.cz/clanky/leiningen-nastroj-pro-spravu-projektu-napsanych-v-clojure/">http://www.root.cz/clanky/leiningen-nastroj-pro-spravu-projektu-napsanych-v-clojure/</a>
</li>

<li>Leiningen: nástroj pro správu projektů napsaných v&nbsp;Clojure (2)<br />
<a href="http://www.root.cz/clanky/leiningen-nastroj-pro-spravu-projektu-napsanych-v-clojure-2/">http://www.root.cz/clanky/leiningen-nastroj-pro-spravu-projektu-napsanych-v-clojure-2/</a>
</li>

<li>Leiningen: nástroj pro správu projektů napsaných v&nbsp;Clojure (3)<br />
<a href="http://www.root.cz/clanky/leiningen-nastroj-pro-spravu-projektu-napsanych-v-clojure-3/">http://www.root.cz/clanky/leiningen-nastroj-pro-spravu-projektu-napsanych-v-clojure-3/</a>
</li>

<li>Leiningen: nástroj pro správu projektů napsaných v&nbsp;Clojure (4)<br />
<a href="http://www.root.cz/clanky/leiningen-nastroj-pro-spravu-projektu-napsanych-v-clojure-4/">http://www.root.cz/clanky/leiningen-nastroj-pro-spravu-projektu-napsanych-v-clojure-4/</a>
</li>

<li>Leiningen: nástroj pro správu projektů napsaných v&nbsp;Clojure (5)<br />
<a href="http://www.root.cz/clanky/leiningen-nastroj-pro-spravu-projektu-napsanych-v-clojure-5/">http://www.root.cz/clanky/leiningen-nastroj-pro-spravu-projektu-napsanych-v-clojure-5/</a>
</li>

<li>Leiningen: nástroj pro správu projektů napsaných v&nbsp;Clojure (6)<br />
<a href="http://www.root.cz/clanky/leiningen-nastroj-pro-spravu-projektu-napsanych-v-clojure-6/">http://www.root.cz/clanky/leiningen-nastroj-pro-spravu-projektu-napsanych-v-clojure-6/</a>
</li>

<li>Programovací jazyk Clojure a databáze (1.část)<br />
<a href="http://www.root.cz/clanky/programovaci-jazyk-clojure-a-databaze-1-cast/">http://www.root.cz/clanky/programovaci-jazyk-clojure-a-databaze-1-cast/</a>
</li>

<li>Pluginy pro Leiningen<br />
<a href="http://www.root.cz/clanky/leiningen-nastroj-pro-spravu-projektu-napsanych-v-clojure-pluginy-pro-leiningen/">http://www.root.cz/clanky/leiningen-nastroj-pro-spravu-projektu-napsanych-v-clojure-pluginy-pro-leiningen/</a>
</li>

<li>Programovací jazyk Clojure a knihovny pro práci s&nbsp;vektory a maticemi<br />
<a href="http://www.root.cz/clanky/programovaci-jazyk-clojure-a-knihovny-pro-praci-s-vektory-a-maticemi/">http://www.root.cz/clanky/programovaci-jazyk-clojure-a-knihovny-pro-praci-s-vektory-a-maticemi/</a>
</li>

<li>Programovací jazyk Clojure a knihovny pro práci s&nbsp;vektory a maticemi (2)<br />
<a href="http://www.root.cz/clanky/programovaci-jazyk-clojure-a-knihovny-pro-praci-s-vektory-a-maticemi-2/">http://www.root.cz/clanky/programovaci-jazyk-clojure-a-knihovny-pro-praci-s-vektory-a-maticemi-2/</a>
</li>

<li>Programovací jazyk Clojure: syntéza procedurálních textur s&nbsp;využitím knihovny Clisk<br />
<a href="http://www.root.cz/clanky/programovaci-jazyk-clojure-synteza-proceduralnich-textur-s-vyuzitim-knihovny-clisk/">http://www.root.cz/clanky/programovaci-jazyk-clojure-synteza-proceduralnich-textur-s-vyuzitim-knihovny-clisk/</a>
</li>

<li>Programovací jazyk Clojure: syntéza procedurálních textur s&nbsp;využitím knihovny Clisk (2)<br />
<a href="http://www.root.cz/clanky/programovaci-jazyk-clojure-synteza-proceduralnich-textur-s-vyuzitim-knihovny-clisk-2/">http://www.root.cz/clanky/programovaci-jazyk-clojure-synteza-proceduralnich-textur-s-vyuzitim-knihovny-clisk-2/</a>
</li>

<li>Seesaw: knihovna pro snadnou tvorbu GUI v&nbsp;jazyce Clojure<br />
<a href="http://www.root.cz/clanky/seesaw-knihovna-pro-snadnou-tvorbu-gui-v-jazyce-clojure/">http://www.root.cz/clanky/seesaw-knihovna-pro-snadnou-tvorbu-gui-v-jazyce-clojure/</a>
</li>

<li>Seesaw: knihovna pro snadnou tvorbu GUI v &nbsp;azyce Clojure (2)<br />
<a href="http://www.root.cz/clanky/seesaw-knihovna-pro-snadnou-tvorbu-gui-v-jazyce-clojure-2/">http://www.root.cz/clanky/seesaw-knihovna-pro-snadnou-tvorbu-gui-v-jazyce-clojure-2/</a>
</li>

<li>Seesaw: knihovna pro snadnou tvorbu GUI v&nbsp;jazyce Clojure (3)<br />
<a href="http://www.root.cz/clanky/seesaw-knihovna-pro-snadnou-tvorbu-gui-v-jazyce-clojure-3/">http://www.root.cz/clanky/seesaw-knihovna-pro-snadnou-tvorbu-gui-v-jazyce-clojure-3/</a>
</li>

<li>Programovací jazyk Clojure a práce s&nbsp;Gitem<br />
<a href="http://www.root.cz/clanky/programovaci-jazyk-clojure-a-prace-s-gitem/">http://www.root.cz/clanky/programovaci-jazyk-clojure-a-prace-s-gitem/</a>
</li>

<li>Programovací jazyk Clojure a práce s&nbsp;Gitem (2)<br />
<a href="http://www.root.cz/clanky/programovaci-jazyk-clojure-a-prace-s-gitem-2/">http://www.root.cz/clanky/programovaci-jazyk-clojure-a-prace-s-gitem-2/</a>
</li>

<li>Programovací jazyk Clojure: syntéza procedurálních textur s&nbsp;využitím knihovny Clisk (dokončení)<br />
<a href="http://www.root.cz/clanky/programovaci-jazyk-clojure-synteza-proceduralnich-textur-s-vyuzitim-knihovny-clisk-dokonceni/">http://www.root.cz/clanky/programovaci-jazyk-clojure-synteza-proceduralnich-textur-s-vyuzitim-knihovny-clisk-dokonceni/</a>
</li>

<li>Pixie: lehký skriptovací jazyk s&nbsp;„kouzelnými“ schopnostmi<br />
<a href="https://www.root.cz/clanky/pixie-lehky-skriptovaci-jazyk-s-kouzelnymi-schopnostmi/">https://www.root.cz/clanky/pixie-lehky-skriptovaci-jazyk-s-kouzelnymi-schopnostmi/</a>
</li>

<li>Programovací jazyk Pixie: funkce ze základní knihovny a použití FFI<br />
<a href="https://www.root.cz/clanky/programovaci-jazyk-pixie-funkce-ze-zakladni-knihovny-a-pouziti-ffi/">https://www.root.cz/clanky/programovaci-jazyk-pixie-funkce-ze-zakladni-knihovny-a-pouziti-ffi/</a>
</li>

<li>Novinky v&nbsp;Clojure verze 1.9.0<br />
<a href="https://www.root.cz/clanky/novinky-v-clojure-verze-1-9-0/">https://www.root.cz/clanky/novinky-v-clojure-verze-1-9-0/</a>
</li>

<li>Validace dat s&nbsp;využitím knihovny spec v&nbsp;Clojure 1.9.0<br />
<a href="https://www.root.cz/clanky/validace-dat-s-vyuzitim-knihovny-spec-v-clojure-1-9-0/">https://www.root.cz/clanky/validace-dat-s-vyuzitim-knihovny-spec-v-clojure-1-9-0/</a>
</li>

<li>Použití jazyka Gherkin při tvorbě testovacích scénářů pro aplikace psané v&nbsp;Clojure<br />
<a href="https://www.root.cz/clanky/pouziti-jazyka-gherkin-pri-tvorbe-testovacich-scenaru-pro-aplikace-psane-v-nbsp-clojure/">https://www.root.cz/clanky/pouziti-jazyka-gherkin-pri-tvorbe-testovacich-scenaru-pro-aplikace-psane-v-nbsp-clojure/</a>
</li>

<li>Použití jazyka Gherkin při tvorbě testovacích scénářů pro aplikace psané v&nbsp;Clojure (2)<br />
<a href="https://www.root.cz/clanky/pouziti-jazyka-gherkin-pri-tvorbe-testovacich-scenaru-pro-aplikace-psane-v-nbsp-clojure-2/">https://www.root.cz/clanky/pouziti-jazyka-gherkin-pri-tvorbe-testovacich-scenaru-pro-aplikace-psane-v-nbsp-clojure-2/</a>
</li>

<li>Incanter: prostředí pro statistické výpočty s grafickým výstupem založené na Clojure<br />
<a href="https://www.root.cz/clanky/incanter-prostredi-pro-statisticke-vypocty-s-grafickym-vystupem-zalozene-na-clojure/">https://www.root.cz/clanky/incanter-prostredi-pro-statisticke-vypocty-s-grafickym-vystupem-zalozene-na-clojure/</a>
</li>

<li>Incanter: operace s&nbsp;maticemi<br />
<a href="https://www.root.cz/clanky/incanter-operace-s-maticemi/">https://www.root.cz/clanky/incanter-operace-s-maticemi/</a>
</li>

<li>Interpret programovacího jazyka Clojure integrovaný do Jupyter Notebooku<br />
<a href="https://www.root.cz/clanky/interpret-programovaciho-jazyka-clojure-integrovany-do-jupyter-notebooku/">https://www.root.cz/clanky/interpret-programovaciho-jazyka-clojure-integrovany-do-jupyter-notebooku/</a>
</li>

<li>Babashka: interpret Clojure určený pro rychlé spouštění utilit z&nbsp;příkazového řádku<br />
<a href="https://www.root.cz/clanky/babashka-interpret-clojure-urceny-pro-rychle-spousteni-utilit-z-prikazoveho-radku/">https://www.root.cz/clanky/babashka-interpret-clojure-urceny-pro-rychle-spousteni-utilit-z-prikazoveho-radku/</a>
</li>

<li>Pokročilý streaming založený na Apache Kafce, jazyku Clojure a knihovně Jackdaw<br />
<a href="https://www.root.cz/clanky/pokrocily-streaming-zalozeny-na-apache-kafce-jazyku-clojure-a-knihovne-jackdaw/">https://www.root.cz/clanky/pokrocily-streaming-zalozeny-na-apache-kafce-jazyku-clojure-a-knihovne-jackdaw/</a>
</li>

<li>Pokročilý streaming založený na Apache Kafce, jazyku Clojure a knihovně Jackdaw (2. část)<br />
<a href="https://www.root.cz/clanky/pokrocily-streaming-zalozeny-na-apache-kafce-jazyku-clojure-a-knihovne-jackdaw-2-cast/">https://www.root.cz/clanky/pokrocily-streaming-zalozeny-na-apache-kafce-jazyku-clojure-a-knihovne-jackdaw-2-cast/</a>
</li>

<li>Pokročilý streaming založený na projektu Apache Kafka, jazyku Clojure a knihovně Jackdaw (streamy a kolony)<br />
<a href="https://www.root.cz/clanky/pokrocily-streaming-zalozeny-na-projektu-apache-kafka-jazyku-clojure-a-knihovne-jackdaw-streamy-a-kolony/">https://www.root.cz/clanky/pokrocily-streaming-zalozeny-na-projektu-apache-kafka-jazyku-clojure-a-knihovne-jackdaw-streamy-a-kolony/</a>
</li>

<li>Řídicí struktury využitelné v&nbsp;programovacím jazyku Clojure<br />
<a href="https://www.root.cz/clanky/ridici-struktury-vyuzitelne-v-programovacim-jazyku-clojure/">https://www.root.cz/clanky/ridici-struktury-vyuzitelne-v-programovacim-jazyku-clojure/</a>
</li>

<li>Řídicí struktury využitelné v programovacím jazyku Clojure (dokončení)<br />
<a href="https://www.root.cz/clanky/ridici-struktury-vyuzitelne-v-programovacim-jazyku-clojure-dokonceni/">https://www.root.cz/clanky/ridici-struktury-vyuzitelne-v-programovacim-jazyku-clojure-dokonceni/</a>
</li>

<li>Formát EDN: extensible data notation<br />
<a href="https://www.root.cz/clanky/format-edn-extensible-data-notation/">https://www.root.cz/clanky/format-edn-extensible-data-notation/</a>
</li>

<li>Formát EDN: extensible data notation (dokončení)<br />
<a href="https://www.root.cz/clanky/format-edn-extensible-data-notation-dokonceni/">https://www.root.cz/clanky/format-edn-extensible-data-notation-dokonceni/</a>
</li>

<li>Čtyři různé podoby datové struktury map v&nbsp;programovacím jazyku Clojure<br />
<a href="https://www.root.cz/clanky/ctyri-ruzne-podoby-datove-struktury-map-v-programovacim-jazyku-clojure/">https://www.root.cz/clanky/ctyri-ruzne-podoby-datove-struktury-map-v-programovacim-jazyku-clojure/</a>
</li>

<li>Programová tvorba diagramů v&nbsp;jazyku Clojure s&nbsp;využitím knihovny Rhizome<br />
<a href="https://www.root.cz/clanky/programova-tvorba-diagramu-v-jazyku-clojure-s-vyuzitim-knihovny-rhizome/">https://www.root.cz/clanky/programova-tvorba-diagramu-v-jazyku-clojure-s-vyuzitim-knihovny-rhizome/</a>
</li>

<li>Využití Redisu z&nbsp;jazyka Clojure pomocí knihovny Carmine<br />
<a href="https://www.root.cz/clanky/vyuziti-redisu-z-jazyka-clojure-pomoci-knihovny-carmine/">https://www.root.cz/clanky/vyuziti-redisu-z-jazyka-clojure-pomoci-knihovny-carmine/</a>
</li>

</ol>



<p><a name="k20"></a></p>
<h2 id="k20">20. Odkazy na Internetu</h2>

<ol>

<li>Carmine: a pure-Clojure Redis client &amp; message queue<br />
<a href="https://github.com/ptaoussanis/carmine">https://github.com/ptaoussanis/carmine</a>
</li>

<li>Redis streams and Clojure<br />
<a href="https://tirkarthi.github.io/programming/2018/08/17/redis-streams-clojure.html">https://tirkarthi.github.io/programming/2018/08/17/redis-streams-clojure.html</a>
</li>

<li>Clojure Redis using Carmine<br />
<a href="https://clojure.tgenedavis.com/clojure-redis-using-carmine/">https://clojure.tgenedavis.com/clojure-redis-using-carmine/</a>
</li>

<li>Clojure with a Touch of Redis<br />
<a href="https://clojure.tgenedavis.com/2020-07-04/clojure-with-a-touch-of-redis/">https://clojure.tgenedavis.com/2020-07-04/clojure-with-a-touch-of-redis/</a>
</li>

<li>Clojure Redis: Get and Set<br />
<a href="https://clojure.tgenedavis.com/2020-07-07/clojure-redis-get-and-set/">https://clojure.tgenedavis.com/2020-07-07/clojure-redis-get-and-set/</a>
</li>

<li>Clojure Redis Pub/Sub with Carmine<br />
<a href="https://clojure.tgenedavis.com/2020-10-17/clojure-redis-pub-sub-with-carmine/">https://clojure.tgenedavis.com/2020-10-17/clojure-redis-pub-sub-with-carmine/</a>
</li>

<li>Redis and Clojure (založeno na odlišné knihovně)<br />
<a href="https://devender.me/2010/06/13/redis-and-clojure/">https://devender.me/2010/06/13/redis-and-clojure/</a>
</li>

<li>Disque, an in-memory, distributed job queue<br />
<a href="https://github.com/antirez/disque">https://github.com/antirez/disque</a>
</li>

<li>Scripting Redis with Lua<br />
<a href="https://redislabs.com/ebook/part-3-next-steps/chapter-11-scripting-redis-with-lua/">https://redislabs.com/ebook/part-3-next-steps/chapter-11-scripting-redis-with-lua/</a>
</li>

<li>Redis Lua script for atomic operations and cache stampede<br />
<a href="https://engineering.linecorp.com/en/blog/redis-lua-scripting-atomic-processing-cache/">https://engineering.linecorp.com/en/blog/redis-lua-scripting-atomic-processing-cache/</a>
</li>

<li>Příkaz pro spuštění skriptu v&nbsp;jazyce Lua: EVAL script numkeys key [key ...] arg [arg ...]<br />
<a href="https://redis.io/commands/eval">https://redis.io/commands/eval</a>
</li>

<li>Redis Lua scripts debugger<br />
<a href="https://redis.io/topics/ldb">https://redis.io/topics/ldb</a>
</li>

<li>Repositář projektu s&nbsp;Redis klientem pro jazyk Go<br />
<a href="https://github.com/go-redis/redis">https://github.com/go-redis/redis</a>
</li>

<li>Stránky programovacího jazyka Lua<br />
<a href="https://www.lua.org/">https://www.lua.org/</a>
</li>

<li>Programovací jazyk Lua<br />
<a href="https://www.palmknihy.cz/ucebnice-odborna-literatura/programovaci-jazyk-lua-12651">https://www.palmknihy.cz/ucebnice-odborna-literatura/programovaci-jazyk-lua-12651</a>
</li>

<li>Programming in Lua<br />
<a href="https://www.lua.org/pil/">https://www.lua.org/pil/</a>
</li>

<li>Redis Lua Scripts - Itamar Haber<br />
<a href="https://www.youtube.com/watch?v=eReTl8NhHCs">https://www.youtube.com/watch?v=eReTl8NhHCs</a>
</li>

<li>Building Databases with Redis Tutorial: Lua Script | packtpub.com<br />
<a href="https://www.youtube.com/watch?v=mMfGNsAr7Bg">https://www.youtube.com/watch?v=mMfGNsAr7Bg</a>
</li>

<li>Repositář projektu redis-luajit (fork)<br />
<a href="https://github.com/coleifer/redis-luajit">https://github.com/coleifer/redis-luajit</a>
</li>

<li>Type-safe Redis client for Go<br />
<a href="https://redis.uptrace.dev/">https://redis.uptrace.dev/</a>
</li>

<li>Dokumentace k&nbsp;balíčku redis<br />
<a href="https://pkg.go.dev/github.com/go-redis/redis/v8?tab=doc">https://pkg.go.dev/github.com/go-redis/redis/v8?tab=doc</a>
</li>

<li>godis &ndash; redis client implement by golang, inspired by jedis. <br />
<a href="https://github.com/piaohao/godis">https://github.com/piaohao/godis</a>
</li>

<li>How to Use Redis Go Client go-redis/redis with GoLang<br />
<a href="https://kb.objectrocket.com/redis/how-to-use-redis-go-client-go-redis-redis-with-golang-592">https://kb.objectrocket.com/redis/how-to-use-redis-go-client-go-redis-redis-with-golang-592</a>
</li>

<li>Adventures in message queues<br />
<a href="http://antirez.com/news/88">http://antirez.com/news/88</a>
</li>

<li>redeo<br />
<a href="https://github.com/bsm/redeo">https://github.com/bsm/redeo</a>
</li>

<li>First-in, first-out queues<br />
<a href="https://redislabs.com/ebook/part-2-core-concepts/chapter-6-application-components-in-redis/6-4-task-queues/6-4-1-first-in-first-out-queues/">https://redislabs.com/ebook/part-2-core-concepts/chapter-6-application-components-in-redis/6-4-task-queues/6-4-1-first-in-first-out-queues/</a>
</li>

<li>Stránky projektu Redis<br />
<a href="https://redis.io/">https://redis.io/</a>
</li>

<li>Introduction to Redis<br />
<a href="https://redis.io/topics/introduction">https://redis.io/topics/introduction</a>
</li>

<li>Try Redis<br />
<a href="http://try.redis.io/">http://try.redis.io/</a>
</li>

<li>Redis tutorial, April 2010 (starší, ale pěkně udělaný)<br />
<a href="https://static.simonwillison.net/static/2010/redis-tutorial/">https://static.simonwillison.net/static/2010/redis-tutorial/</a>
</li>

<li>Redis: key-value databáze v paměti i na disku<br />
<a href="https://www.zdrojak.cz/clanky/redis-key-value-databaze-v-pameti-i-na-disku/">https://www.zdrojak.cz/clanky/redis-key-value-databaze-v-pameti-i-na-disku/</a>
</li>

<li>Praktický úvod do Redis (1): vaše distribuovaná NoSQL cache<br />
<a href="http://www.cloudsvet.cz/?p=253">http://www.cloudsvet.cz/?p=253</a>
</li>

<li>Praktický úvod do Redis (2): transakce<br />
<a href="http://www.cloudsvet.cz/?p=256">http://www.cloudsvet.cz/?p=256</a>
</li>

<li>Praktický úvod do Redis (3): cluster<br />
<a href="http://www.cloudsvet.cz/?p=258">http://www.cloudsvet.cz/?p=258</a>
</li>

</ol>



<p></p><p></p>
<p><small>Autor: <a href="http://www.fit.vutbr.cz/~tisnovpa">Pavel Tišnovský</a> &nbsp; 2022</small></p>
</body>
</html>
