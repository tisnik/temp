<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
        "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html>
<head>
<title>Programovací jazyk Clojure - základy zpracování XML</title>
<meta name="Author" content="Pavel Tisnovsky" />
<meta name="Generator" content="vim" />
<meta http-equiv="content-type" content="text/html; charset=utf-8" />
<style type="text/css">
         body {color:#000000; background:#ffffff;}
         h1  {font-family: arial, helvetica, sans-serif; color:#ffffff; background-color:#c00000; text-align:center; padding-left:1em}
         h2  {font-family: arial, helvetica, sans-serif; color:#ffffff; background-color:#0000c0; padding-left:1em; text-align:left}
         h3  {font-family: arial, helvetica, sans-serif; color:#000000; background-color:#c0c0c0; padding-left:1em; text-align:left}
         h4  {font-family: arial, helvetica, sans-serif; color:#000000; background-color:#e0e0e0; padding-left:1em; text-align:left}
         a   {font-family: arial, helvetica, sans-serif;}
         li  {font-family: arial, helvetica, sans-serif; color:#000000; text-align:justify; width:450px;}
         ol  {font-family: arial, helvetica, sans-serif; color:#000000; text-align:justify; width:450px;}
         ul  {font-family: arial, helvetica, sans-serif; color:#000000; text-align:justify; width:450px;}
         p   {font-family: arial, helvetica, sans-serif; color:#000000; text-align:justify;}
         pre {background:#e0e0e0}
</style>
</head>

<body>

<h1>Programovací jazyk Clojure - základy zpracování XML</h1>

<h3>Pavel Tišnovský</h3>

<p></p>

<h1>Úvodník</h1>

<p>Další důležitou součástí standardních knihoven programovacího jazyka Clojure jsou funkce umožňující zpracování dat uložených v XML. Dnes se zaměříme na funkce clojure.xml/parse, clojure.core/xml-seq a clojure.zip/xml-zip, které postačují pro přístup k jednotlivým uzlům, atributům i hodnotám v XML.</p>



<h2>Obsah</h2>

<p><a href="#k01">1. Programovací jazyk Clojure - základy zpracování XML</a></p>
<p><a href="#k02">2. Parsing XML a reprezentace obsahu XML souboru ve formě stromu</a></p>
<p><a href="#k03">3. První demonstrační příklad: parsing XML souborů</a></p>
<p><a href="#k04">4. Druhý demonstrační příklad: přístup ke XML reprezentovaného ve formě stromové struktury</a></p>
<p><a href="#k05">5. Třetí demonstrační příklad: funkce <strong>xml-seq</strong></a></p>
<p><a href="#k06">6. Čtvrtý demonstrační příklad: jednoduché filtry postavené na funkci <strong>xml-seq</strong></a></p>
<p><a href="#k07">7. Použití zipperů pro přístup k&nbsp;prvkům XML</a></p>
<p><a href="#k08">8. Pátý demonstrační příklad: základy použití zipperů</a></p>
<p><a href="#k09">9. Šestý demonstrační příklad: složitější zipper</a></p>
<p><a href="#k10">10. Repositář s&nbsp;dnešními demonstračními příklady</a></p>
<p><a href="#k11">11. Odkazy na předchozí části tohoto seriálu</a></p>
<p><a href="#k12">12. Odkazy na Internetu</a></p>



<p><a name="k01"></a></p>
<h2 id="k01">1. Programovací jazyk Clojure - základy zpracování XML</h2>

<p>Programovací jazyk <i>Clojure</i> se některými svými vlastnostmi, zejména
pak již několikrát zmíněnou <a
href="https://cs.wikipedia.org/wiki/Homoikonicita">homoikonicitou</a> a taktéž
podporou líných sekvencí (<i>lazy sequences</i>), hodí pro zpracování
strukturovaných dat, neboť tato data lze reprezentovat s&nbsp;využitím
(většinou vnořených) seznamů, vektorů, map a popř.&nbsp;i množin. Předností
této reprezentace dat je jejich relativně snadné zpracování pomocí funkcí
dostupných již ve standardní knihovně jazyka <i>Clojure</i> (filtry, mapování
funkcí na sekvence atd.). To samozřejmě platí i pro XML, což si ostatně ukážeme
na několika demonstračních příkladech uvedených v&nbsp;navazujících kapitolách.
Pro zpracování XML souborů nám budou postačovat jen tři speciální funkce. Jedna
z&nbsp;těchto funkcí slouží pro parsování XML, druhá pak pro vytvoření sekvence
z&nbsp;předaných dat a třetí funkce pro vytvoření takzvaného <i>zipperu</i>,
s&nbsp;jehož využitím je možné procházet stromovou strukturou. Pro pokročilejší
práci (například i pro proudové zpracování XML), je nutné použít mírně odlišné
funkce popsané příště.</p>



<p><a name="k02"></a></p>
<h2 id="k02">2. Parsing XML a reprezentace obsahu XML souboru ve formě stromu</h2>

<p>Před vlastním zpracováním strukturovaných dat uložených v&nbsp;souborech
typu XML je nutné provést načtení a syntaktickou analýzu XML. Pro tento účel
slouží funkce pojmenovaná příhodně <strong>parse</strong>. Tato funkce je
umístěna v&nbsp;knihovně nazvané <strong>clojure.xml</strong>, což
mj.&nbsp;znamená, že před prvním voláním <strong>parse</strong> je nutné tuto
knihovnu načíst s&nbsp;využitím <strong>require</strong> či
<strong>use</strong>. V&nbsp;demonstračních příkladech budu pro jednoduchost
používat funkci <strong>use</strong>, i když v&nbsp;praxi se pravděpodobně
mnohem častěji setkáte s&nbsp;použitím <strong>require</strong>. Vraťme se však
k&nbsp;funkci <strong>clojure.xml/parse</strong>. Tato funkce se většinou volá
s&nbsp;jediným parametrem představujícím soubor nebo vstupní proud,
z&nbsp;něhož se mají načíst data reprezentovaná v&nbsp;XML. Je možné použít i
adresu (URI) reprezentovanou řetězcem. Pozor je nutné dát jen na to, že tento
řetězec skutečně obsahuje jen URI a nikoli vlastní XML (načtené například
funkcí <strong>slurp</strong>)!:</p>

<pre>
user=&gt; <strong>(use '[clojure.xml])</strong>
&nbsp;
user=&gt; <strong>(doc parse)</strong>
-------------------------
clojure.xml/parse
([s] [s startparse])
  Parses and loads the source s, which can be a File, InputStream or
  String naming a URI. Returns a tree of the xml/element struct-map,
  which has the keys :tag, :attrs, and :content. and accessor fns tag,
  attrs, and content. Other parsers can be supplied by passing
  startparse, a fn taking a source and a ContentHandler and returning
  a parser
</pre>

<p>Výsledkem volání této funkce je stromová struktura, v&nbsp;níž je každý uzel
z&nbsp;původního XML reprezentován mapou obsahující tři prvky s&nbsp;klíči
<strong>:tag</strong>, <strong>:attrs</strong> a <strong>:content</strong>. Pod
klíčem <strong>:tag</strong> je uložen název původního uzlu (jako symbol, ne
jako řetězec, což je poměrně výhodné), pod klíčem <strong>:attrs</strong> mapa
atributů uzlu a konečně pod klíčem <strong>:content</strong> se skrývá obsah
uzlu, včetně rekurzivně uložených poduzlů.</p>



<p><a name="k03"></a></p>
<h2 id="k03">3. První demonstrační příklad: parsing XML souborů</h2>

<p>V&nbsp;prvním demonstračním příkladu, jehož úplnou podobu je možné nalézt na
adrese <a
href="https://github.com/tisnik/clojure-examples/tree/master/xmltest01">https://github.com/tisnik/clojure-examples/tree/master/xmltest01</a>,
je ukázáno použití výše uvedené funkce <strong>clojure.xml/parse</strong> při
syntaktické analýze jednoduchého XML souboru. Nejprve je obsah tohoto souboru
načten (interně se sice používá SAX, ale i přesto se načte celé XML!), následně
je provedena jeho syntaktická analýza a výsledkem je datová struktura zmíněná
v&nbsp;předchozí kapitole. Tuto strukturu vypíšeme v&nbsp;čitelné podobě
s&nbsp;využitím další užitečné funkce nazvané
<strong>clojure.pprint/pprint</strong>:</p>

<pre>
(ns <strong>xmltest01.core</strong>)
&nbsp;
(use '[clojure.xml])
(use '[clojure.pprint])
&nbsp;
&nbsp;
&nbsp;
(defn <strong>xmltest01</strong>
    []
    (let [parsed-xml (clojure.xml/parse "test.xml")]
        (clojure.pprint/pprint parsed-xml)))
&nbsp;
(defn <strong>-main</strong>
    [&amp; args]
    (xmltest01))
</pre>

<p>Vstupní XML soubor, který se bude načítat a zpracovávat:</p>

<pre>
&lt;?xml version="1.0"?&gt;
&lt;first value="42"&gt;
  &lt;second&gt;
    &lt;third firstTag="10" secondTag="20"&gt;
      &lt;fourth&gt;Hello!
      &lt;/fourth&gt;
    &lt;/third&gt;
  &lt;/second&gt;
&lt;/first&gt;
</pre>

<p>Výsledkem načtení a syntaktické analýzy je tato struktura:</p>

<pre>
{:tag :first,
 :attrs {:value "42"},
 :content
 [{:tag :second,
   :attrs nil,
   :content
   [{:tag :third,
     :attrs {:firstTag "10", :secondTag "20"},
     :content
     [{:tag :fourth, :attrs nil, :content ["Hello!\n      "]}]}]}]}
</pre>

<p>Povšimněte si několika zajímavostí:</p>

<ol>
<li>Pod klíčem <strong>:tag</strong> je uložen název tagu, a to vždy jako
symbol, ne jako řetězec. To je příjemné, protože pokud se bude zpracovávat XML
s&nbsp;milionem tagů &lg;strašně_dlouhé_jméno_tagu&gt;, bude řetězec se jménem
tagu použit v&nbsp;paměti jen jedenkrát a ne milionkrát.</li>
<li>Atributy jsou reprezentovány mapou klíč&ndash;hodnota, kde klíč je opět
symbolem a nikoli řetězcem.</li>
<li>Obsahem uzlu je vektor s&nbsp;poduzlem/poduzly nebo přímo
s&nbsp;hodnotou.</li>
<li>Obsahem uzlu <strong>fourth</strong> je vektor obsahující řetězec (což
očekáváme), který obsahuje jak konec řádku, tak i mezery na začátku druhého
řádku (před uzavíracím tagem).</li>
</ol>



<p><a name="k04"></a></p>
<h2 id="k04">4. Druhý demonstrační příklad: přístup ke XML reprezentovaného ve formě stromové struktury</h2>

<p>Ve druhém demonstračním příkladu jsou ukázány dva způsoby, jak poměrně
nemotorně přistupovat ke stromové struktuře reprezentující zparsovaný XML
soubor. Vzhledem k&nbsp;tomu, že celá struktura je skutečně stromem (uzly
s&nbsp;vektory poduzlů), a jména původních uzlů jsou reprezentována symboly, je
přístup k&nbsp;prvkům stromu relativně jednoduchý. Připomeňme si, že
v&nbsp;mapě je možné k&nbsp;prvku přistupovat buď přes funkci <strong>(get mapa
:klíč)</strong> nebo alternativně <strong>(:klíč mapa)</strong>, což je kratší
a po chvilce tréninku i čitelnější varianta. Navíc je možné využít oblíbené
threading makro -&gt;. Ostatně podívejme se na zdrojový kód demonstračního
příkladu a dvě podobné funkce nazvané <strong>get-attributes-v1</strong> a
<strong>get-attributes-v2</strong>. Druhá zmíněná funkce je čitelnější a navíc
se mnohem lépe čte zleva doprava (či shora dolů) a chybí zde nechvalně známá
změť LISPovských závorek:</p>

<pre>
(ns <strong>xmltest02.core</strong>)
&nbsp;
(use '[clojure.xml])
(use '[clojure.pprint])
&nbsp;
&nbsp;
&nbsp;
(defn <strong>get-attributes-v1</strong>
    [parsed-xml]
    (:attrs (first (:content (first (:content parsed-xml))))))
&nbsp;
(defn <strong>get-attributes-v2</strong>
    [parsed-xml]
    (-&gt; parsed-xml
        :content
        first
        :content
        first
        :attrs))
&nbsp;
(defn <strong>xmltest02</strong>
    []
    (let [parsed-xml (clojure.xml/parse "test.xml")]
        (clojure.pprint/pprint parsed-xml)
        (println "----------------------------------")
        (println (get-attributes-v1 parsed-xml))
        (println (get-attributes-v2 parsed-xml))))
&nbsp;
(defn <strong>-main</strong>
    [&amp; args]
    (xmltest02))
</pre>

<p>Výstupem tohoto příkladu by měly být následující řádky:</p>

<pre>
{:tag :first,
 :attrs {:value "42"},
 :content
 [{:tag :second,
   :attrs nil,
   :content
   [{:tag :third,
     :attrs {:firstTag "10", :secondTag "20"},
     :content
     [{:tag :fourth, :attrs nil, :content ["Hello!\n      "]}]}]}]}
----------------------------------
{:firstTag 10, :secondTag 20}
{:firstTag 10, :secondTag 20}
</pre>



<p><a name="k05"></a></p>
<h2 id="k05">5. Třetí demonstrační příklad: funkce <strong>xml-seq</strong></h2>

<p>Druhou důležitou funkcí, která se poměrně často používá při zpracování XML
souborů, je funkce nazvaná <strong>xml-seq</strong>. Tuto funkci nalezneme
přímo ve standardní knihovně, takže se nemusí provádět její explicitní načtení.
<strong>xml-seq</strong> na svém vstupu očekává výstup z&nbsp;výše popsané
funkce <strong>clojure.xml/parse</strong> a jejím výsledkem je sekvence, jejíž
prvky jsou získány průchodem původního stromu:</p>

<pre>
user=&gt; <strong>(doc xml-seq)</strong>
-------------------------
clojure.core/xml-seq
([root])
  A tree seq on the xml elements as per xml/parse
</pre>

<p>Z&nbsp;jakého důvodu je tato funkce užitečná, si ukážeme <a
href="#k06">v&nbsp;navazující kapitole</a>, nyní nás však bude zajímat výsledná
podoba sekvence. Proto se v&nbsp;dnešním třetím příkladu bude procházet
vytvořenou sekvencí s&nbsp;využitím &bdquo;smyčky&ldquo; realizované přes makro
<strong>doseq</strong>, v&nbsp;němž se postupně jednotlivé prvky sekvence
tisknou na standardní výstup:</p>

<pre>
(ns <strong>xmltest03.core</strong>)
&nbsp;
(use '[clojure.xml])
(use '[clojure.pprint])
&nbsp;
(defn <strong>print-xml-seq</strong>
    [parsed-xml]
    (doseq [item (xml-seq parsed-xml)]
        (println item)))
&nbsp;
(defn <strong>xmltest03</strong>
    []
    (let [parsed-xml (clojure.xml/parse "nested.xml")]
        (clojure.pprint/pprint parsed-xml)
        (println "----------------------------------")
        (print-xml-seq parsed-xml)))
&nbsp;
(defn <strong>-main</strong>
    [&amp; args]
    (xmltest03))
</pre>

<p>Podoba vstupního souboru byla oproti předchozím příkladům upravena &ndash;
povšimněte si dvojice poduzlů uložených v&nbsp;kořenovém uzlu:</p>

<pre>
&lt;?xml version="1.0"?&gt;
&lt;first&gt;
  &lt;second value="A"&gt;
    &lt;third&gt;
      &lt;fourth&gt;Hello A&lt;/fourth&gt;
    &lt;/third&gt;
  &lt;/second&gt;
  &lt;second value="B"&gt;
    &lt;third&gt;
      &lt;fourth&gt;Hello B&lt;/fourth&gt;
    &lt;/third&gt;
  &lt;/second&gt;
&lt;/first&gt;
</pre>

<p>Následuje výstup vytvořený tímto demonstračním příkladem:</p>

<pre>
{:tag :first,
 :attrs nil,
 :content
 [{:tag :second,
   :attrs {:value "A"},
   :content
   [{:tag :third,
     :attrs nil,
     :content [{:tag :fourth, :attrs nil, :content ["Hello A"]}]}]}
  {:tag :second,
   :attrs {:value "B"},
   :content
   [{:tag :third,
     :attrs nil,
     :content [{:tag :fourth, :attrs nil, :content ["Hello B"]}]}]}]}
----------------------------------
{:tag :first, :attrs nil, :content [{:tag :second, :attrs {:value A}, :content [{:tag :third, :attrs nil, :content [{:tag :fourth, :attrs nil, :content [Hello A]}]}]} {:tag :second, :attrs {:value B}, :content [{:tag :third, :attrs nil, :content [{:tag :fourth, :attrs nil, :content [Hello B]}]}]}]}
{:tag :second, :attrs {:value A}, :content [{:tag :third, :attrs nil, :content [{:tag :fourth, :attrs nil, :content [Hello A]}]}]}
{:tag :third, :attrs nil, :content [{:tag :fourth, :attrs nil, :content [Hello A]}]}
{:tag :fourth, :attrs nil, :content [Hello A]}
Hello A
{:tag :second, :attrs {:value B}, :content [{:tag :third, :attrs nil, :content [{:tag :fourth, :attrs nil, :content [Hello B]}]}]}
{:tag :third, :attrs nil, :content [{:tag :fourth, :attrs nil, :content [Hello B]}]}
{:tag :fourth, :attrs nil, :content [Hello B]}
Hello B
</pre>

<p>Po ilustraci si výstupní sekvenci uložme do tabulky:</p>

<table>
<tr><th>#</th><th>Prvek</th></tr>
<tr><td>1</td><td>{:tag :first, :attrs nil, :content [{:tag :second, :attrs {:value A}, :content [{:tag :third, :attrs nil, :content [{:tag :fourth, :attrs nil, :content [Hello A]}]}]} {:tag :second, :attrs {:value B}, :content [{:tag :third, :attrs nil, :content [{:tag :fourth, :attrs nil, :content [Hello B]}]}]}]}</td></tr>
<tr><td>2</td><td>{:tag :second, :attrs {:value A}, :content [{:tag :third, :attrs nil, :content [{:tag :fourth, :attrs nil, :content [Hello A]}]}]}</td></tr>
<tr><td>3</td><td>{:tag :third, :attrs nil, :content [{:tag :fourth, :attrs nil, :content [Hello A]}]}</td></tr>
<tr><td>4</td><td>{:tag :fourth, :attrs nil, :content [Hello A]}</td></tr>
<tr><td>5</td><td>Hello A</td></tr>
<tr><td>6</td><td>{:tag :second, :attrs {:value B}, :content [{:tag :third, :attrs nil, :content [{:tag :fourth, :attrs nil, :content [Hello B]}]}]}</td></tr>
<tr><td>7</td><td>{:tag :third, :attrs nil, :content [{:tag :fourth, :attrs nil, :content [Hello B]}]}</td></tr>
<tr><td>8</td><td>{:tag :fourth, :attrs nil, :content [Hello B]}</td></tr>
<tr><td>9</td><td>Hello B</td></tr>
</table>

<p>Samotná podoba sekvence může být poněkud překvapivá, ovšem skutečně se jedná
o výsledek průchodu původním stromem (otázka pro čtenáře: jedná se o průchod
typu pre-order, in-order či post-order?). Zajímavé je, že i textová hodnota
uložená v&nbsp;uzlech <strong>fourth</strong> je vrácena jako samostatný prvek
sekvence, čehož se ostatně v&nbsp;praxi často využívá.</p>

<p>Poznámka: vzhledem ke sdílení struktury v&nbsp;Clojure není výsledná
sekvence nijak paměťově náročná, i když by se možná mohlo zdát, že se informace
v&nbsp;jednotlivých prvcích musí duplikovat.</p>



<p><a name="k06"></a></p>
<h2 id="k06">6. Čtvrtý demonstrační příklad: jednoduché filtry postavené na funkci <strong>xml-seq</strong></h2>

<p>Sekvenci prvků stromu získaného po syntaktické analýze XML souborů a po
aplikaci funkce <strong>xml-seq</strong>, je možné použít různým způsobem.
Poměrně elegantní je filtrace s&nbsp;využitím makra pojmenovaného
<strong>for</strong>, které se v&nbsp;Clojure používá pro realizaci
generátorové notace seznamu/sekvence (<i>list comprehension</i>). Připomeňme
si, že toto makro podporuje i modifikátory <strong>:let</strong>,
<strong>:while</strong> a <strong>:when</strong>. V&nbsp;našem případě se pro
filtraci nejvíce hodí využití modifikátoru <strong>:when</strong>, což je
ostatně patrné i při pohledu na uživatelské funkce
<strong>filter-seq-1</strong> a <strong>filter-seq-2</strong>:</p>

<pre>
(ns <strong>xmltest04.core</strong>)
&nbsp;
(use '[clojure.xml])
(use '[clojure.pprint])
&nbsp;
&nbsp;
&nbsp;
(defn <strong>filter-seq-1</strong>
    [parsed-xml]
    (for [item (xml-seq parsed-xml)
                :when (= :second (:tag item))]
             (:attrs item)))
&nbsp;
(defn <strong>filter-seq-2</strong>
    [parsed-xml]
    (for [item (xml-seq parsed-xml)
                :when (= :fourth (:tag item))]
             (:content item)))
&nbsp;
(defn <strong>xmltest04</strong>
    []
    (let [parsed-xml (clojure.xml/parse "nested.xml")]
        (clojure.pprint/pprint parsed-xml)
        (println "----------------------------------")
        (clojure.pprint/pprint (filter-seq-1 parsed-xml))
        (println "----------------------------------")
        (clojure.pprint/pprint (filter-seq-2 parsed-xml))))
&nbsp;
(defn <strong>-main</strong>
    [&amp; args]
    (xmltest04))
</pre>

<p>Výsledek běhu dnešního čtvrtého demonstračního příkladu:</p>

<pre>
{:tag :first,
 :attrs nil,
 :content
 [{:tag :second,
   :attrs {:value "A"},
   :content
   [{:tag :third,
     :attrs nil,
     :content [{:tag :fourth, :attrs nil, :content ["Hello A"]}]}]}
  {:tag :second,
   :attrs {:value "B"},
   :content
   [{:tag :third,
     :attrs nil,
     :content [{:tag :fourth, :attrs nil, :content ["Hello B"]}]}]}]}
----------------------------------
({:value "A"} {:value "B"})
----------------------------------
(["Hello A"] ["Hello B"])
</pre>

<p>Poznámka: samozřejmě by bylo možné použít i funkci <strong>filter</strong>,
to je však v&nbsp;tomto případě zbytečně komplikované (tvorba anonymní funkce
atd.).</p>



<p><a name="k07"></a></p>
<h2 id="k07">7. Použití zipperů pro přístup k&nbsp;prvkům XML</h2>

<p>Existuje ještě jeden poměrně elegantní a v&nbsp;mnoha případech i vhodný
způsob přístupu k&nbsp;datům uloženým v&nbsp;XML souborech. Vzhledem
k&nbsp;tomu, že obsah XML je reprezentován stromovou datovou strukturou, nabízí
se použití takzvaných <i>zipperů</i>, které programátorům umožňují mj.&nbsp;i
průchod stromem stylem &bdquo;jdi na první poduzel&ldquo;, &bdquo;přesuň se na
další uzel ve stejné úrovni&ldquo; atd. Běžný <i>zipper</i> je možné použít na
jakoukoli základní datovou strukturu <i>Clojure</i>:</p>

<pre>
user=&gt; <strong>(use '[clojure.zip])</strong>
&nbsp;
user=&gt; <strong>(doc zipper)</strong>
-------------------------
clojure.zip/zipper
([branch? children make-node root])
  Creates a new zipper structure. 
&nbsp;
  branch? is a fn that, given a node, returns true if can have
  children, even if it currently doesn't.
&nbsp;
  children is a fn that, given a branch node, returns a seq of its
  children.
&nbsp;
  make-node is a fn that, given an existing node and a seq of
  children, returns a new branch node with the supplied children.
  root is the root node.
</pre>

<p>Nás však bude namísto funkce <strong>zipper</strong> zajímat jeho speciální
podoba určená přímo pro soubory typu XML. Tento zipper je vytvořen (a vrácen)
funkcí <strong>clojure.zip/xml-zip</strong>:</p>

<pre>
user=&gt; <strong>(use '[clojure.zip])</strong>
&nbsp;
user=&gt; <strong>(doc xml-zip)</strong>
-------------------------
clojure.zip/xml-zip
([root])
  Returns a zipper for xml elements (as from xml/parse),
  given a root element
</pre>



<p><a name="k08"></a></p>
<h2 id="k08">8. Pátý demonstrační příklad: základy použití zipperů</h2>

<p>Podívejme se na jeden ze způsobů použití zipperu. Ve zdrojovém kódu pátého
demonstračního příkladu jsou funkce zipperu volány v&nbsp;rámci threading
makra, což je výhodné, protože výstup z&nbsp;jedné funkce skutečně ihned
použijeme ve funkci následující (navíc je kód značně čitelnější). Funkce
<strong>clojure.zip/down</strong> a <strong>clojure.zip/right</strong> slouží
pro průchod stromem, ovšem musíme si strom představit skutečně tak, jak se
obvykle v&nbsp;informatice kreslí (kořen nahoře, poduzly kořenu jsou pod ním
v&nbsp;jedné řadě atd.). XML struktura je v&nbsp;tomto případě poněkud matoucí,
protože v&nbsp;ní je strom jakoby pootočen o 90&deg;, takže směry
&bdquo;dolů&ldquo; a &bdquo;doprava&ldquo; zde mají odlišný význam:</p>

<pre>
(ns <strong>xmltest05.core</strong>)
&nbsp;
(use '[clojure.xml])
(use '[clojure.pprint])
(use '[clojure.zip])
&nbsp;
(defn <strong>xmltest05</strong>
    []
    (let [parsed-xml (clojure.xml/parse "nested.xml")
          zipper     (clojure.zip/xml-zip parsed-xml)]
        (clojure.pprint/pprint parsed-xml)
        (println "----------------------------------")
        (println (:tag (clojure.zip/node zipper)))
        (println (:tag (-&gt; zipper
                           clojure.zip/node)))
        (println (:tag (-&gt; zipper
                           clojure.zip/down    <i>; prvni synovsky uzel</i>
                           clojure.zip/node)))
        (println (:tag (-&gt; zipper
                           clojure.zip/down    <i>; prvni synovsky uzel</i>
                           clojure.zip/down    <i>; synovsky uzel prvniho synovskeho uzlu</i>
                           clojure.zip/node)))
        (println (:attrs (-&gt; zipper
                           clojure.zip/down    <i>; prvni synovsky uzel</i>
                           clojure.zip/right   <i>; druhy uzel v rade</i>
                           clojure.zip/node)))))
&nbsp;
(defn <strong>-main</strong>
    [&amp; args]
    (xmltest05))
</pre>

<p>Výsledek běhu pátého příkladu:</p>

<pre>
{:tag :first,
 :attrs nil,
 :content
 [{:tag :second,
   :attrs {:value "A"},
   :content
   [{:tag :third,
     :attrs nil,
     :content [{:tag :fourth, :attrs nil, :content ["Hello A"]}]}]}
  {:tag :second,
   :attrs {:value "B"},
   :content
   [{:tag :third,
     :attrs nil,
     :content [{:tag :fourth, :attrs nil, :content ["Hello B"]}]}]}]}
----------------------------------
:first
:first
:second
:third
{:value B}
</pre>



<p><a name="k09"></a></p>
<h2 id="k09">9. Šestý demonstrační příklad: složitější zipper</h2>

<p>Dnešní poslední demonstrační příklad je vlastně obdobou příkladu
předchozího, ovšem threading makro je zde použito skutečně důsledně. Nejprve se
provede načtení a syntaktická analýza souboru s&nbsp;XML, následně se na strom
vzniklý syntaktickou analýzou aplikuje funkce
<strong>clojure.zip/xml-zip</strong> a posléze již přichází čas pro průchod
stromem s&nbsp;využitím zipperu a následně pro získání obsahu uzlu
<strong>(:content node)</strong> a přečtení prvního (a jediného) prvku
z&nbsp;obsahu <strong>(first content)</strong>:</p>

<pre>
(ns <strong>xmltest06.core</strong>)
&nbsp;
(use '[clojure.xml])
(use '[clojure.pprint])
(use '[clojure.zip])
&nbsp;
(defn <strong>xmltest06</strong>
    []
    (let [parsed-xml (clojure.xml/parse "nested.xml")
          zipper     (clojure.zip/xml-zip parsed-xml)]
        (clojure.pprint/pprint parsed-xml)
        (println "----------------------------------")
        (println (-&gt; zipper
                     clojure.zip/down   <i>; prvni synovsky uzel: &lt;second&gt;</i>
                     clojure.zip/right  <i>; druhy synovsky uzel: (taktez &lt;second&gt;)</i>
                     clojure.zip/down   <i>; poduzel: &lt;third&gt;</i>
                     clojure.zip/down   <i>; poduzel: &lt;fourth&gt;</i>
                     clojure.zip/node   <i>; hodnota uzlu &lt;fourth&gt;</i>
                     :content           <i>; nahrada za get</i>
                     first))            <i>; prvni (a jediny prvek vektoru)</i>
                     ))
&nbsp;
(defn <strong>-main</strong>
    [&amp; args]
    (xmltest06))
</pre>

<p>Výsledek běhu šestého demonstračního příkladu:</p>

<pre>
{:tag :first,
 :attrs nil,
 :content
 [{:tag :second,
   :attrs {:value "A"},
   :content
   [{:tag :third,
     :attrs nil,
     :content [{:tag :fourth, :attrs nil, :content ["Hello A"]}]}]}
  {:tag :second,
   :attrs {:value "B"},
   :content
   [{:tag :third,
     :attrs nil,
     :content [{:tag :fourth, :attrs nil, :content ["Hello B"]}]}]}]}
----------------------------------
Hello B
</pre>



<p><a name="k10"></a></p>
<h2 id="k10">10. Repositář s&nbsp;dnešními demonstračními příklady</h2>

<p>Všech šest dnes popsaných demonstračních příkladů bylo, podobně jako
v&nbsp;předchozích částech tohoto seriálu, uloženo do Git repositáře dostupného
na adrese <a
href="https://github.com/tisnik/clojure-examples">https://github.com/tisnik/clojure-examples</a>.
V&nbsp;tabulce zobrazené pod tímto odstavcem naleznete na zdrojové kódy
jednotlivých demonstračních příkladů přímé odkazy:</p>

<table>
<tr><th>#</th><th>Příklad </th><th>Github</th></tr>
<tr><td>1</td><td></td><td><a href="https://github.com/tisnik/clojure-examples/tree/master/xmltest01">https://github.com/tisnik/clojure-examples/tree/master/xmltest01</a></td></tr>
<tr><td>2</td><td></td><td><a href="https://github.com/tisnik/clojure-examples/tree/master/xmltest02">https://github.com/tisnik/clojure-examples/tree/master/xmltest02</a></td></tr>
<tr><td>3</td><td></td><td><a href="https://github.com/tisnik/clojure-examples/tree/master/xmltest03">https://github.com/tisnik/clojure-examples/tree/master/xmltest03</a></td></tr>
<tr><td>4</td><td></td><td><a href="https://github.com/tisnik/clojure-examples/tree/master/xmltest04">https://github.com/tisnik/clojure-examples/tree/master/xmltest04</a></td></tr>
<tr><td>5</td><td></td><td><a href="https://github.com/tisnik/clojure-examples/tree/master/xmltest05">https://github.com/tisnik/clojure-examples/tree/master/xmltest05</a></td></tr>
<tr><td>6</td><td></td><td><a href="https://github.com/tisnik/clojure-examples/tree/master/xmltest06">https://github.com/tisnik/clojure-examples/tree/master/xmltest06</a></td></tr>
</table>



<p><a name="k11"></a></p>
<h2 id="k11">11. Odkazy na předchozí části tohoto seriálu</h2>

<ol>

<li>Leiningen: nástroj pro správu projektů napsaných v Clojure<br />
<a href="http://www.root.cz/clanky/leiningen-nastroj-pro-spravu-projektu-napsanych-v-clojure/">http://www.root.cz/clanky/leiningen-nastroj-pro-spravu-projektu-napsanych-v-clojure/</a>
</li>

<li>Leiningen: nástroj pro správu projektů napsaných v Clojure (2)<br />
<a href="http://www.root.cz/clanky/leiningen-nastroj-pro-spravu-projektu-napsanych-v-clojure-2/">http://www.root.cz/clanky/leiningen-nastroj-pro-spravu-projektu-napsanych-v-clojure-2/</a>
</li>

<li>Leiningen: nástroj pro správu projektů napsaných v Clojure (3)<br />
<a href="http://www.root.cz/clanky/leiningen-nastroj-pro-spravu-projektu-napsanych-v-clojure-3/">http://www.root.cz/clanky/leiningen-nastroj-pro-spravu-projektu-napsanych-v-clojure-3/</a>
</li>

<li>Leiningen: nástroj pro správu projektů napsaných v Clojure (4)<br />
<a href="http://www.root.cz/clanky/leiningen-nastroj-pro-spravu-projektu-napsanych-v-clojure-4/">http://www.root.cz/clanky/leiningen-nastroj-pro-spravu-projektu-napsanych-v-clojure-4/</a>
</li>

<li>Leiningen: nástroj pro správu projektů napsaných v Clojure (5)<br />
<a href="http://www.root.cz/clanky/leiningen-nastroj-pro-spravu-projektu-napsanych-v-clojure-5/">http://www.root.cz/clanky/leiningen-nastroj-pro-spravu-projektu-napsanych-v-clojure-5/</a>
</li>

<li>Leiningen: nástroj pro správu projektů napsaných v Clojure (6)<br />
<a href="http://www.root.cz/clanky/leiningen-nastroj-pro-spravu-projektu-napsanych-v-clojure-6/">http://www.root.cz/clanky/leiningen-nastroj-pro-spravu-projektu-napsanych-v-clojure-6/</a>
</li>

<li>Programovací jazyk Clojure a databáze (1.část)<br />
<a href="http://www.root.cz/clanky/programovaci-jazyk-clojure-a-databaze-1-cast/">http://www.root.cz/clanky/programovaci-jazyk-clojure-a-databaze-1-cast/</a>
</li>

<li>Pluginy pro Leiningen<br />
<a href="http://www.root.cz/clanky/leiningen-nastroj-pro-spravu-projektu-napsanych-v-clojure-pluginy-pro-leiningen/">http://www.root.cz/clanky/leiningen-nastroj-pro-spravu-projektu-napsanych-v-clojure-pluginy-pro-leiningen/</a>
</li>

<li>Programovací jazyk Clojure a knihovny pro práci s vektory a maticemi<br />
<a href="http://www.root.cz/clanky/programovaci-jazyk-clojure-a-knihovny-pro-praci-s-vektory-a-maticemi/">http://www.root.cz/clanky/programovaci-jazyk-clojure-a-knihovny-pro-praci-s-vektory-a-maticemi/</a>
</li>

<li>Programovací jazyk Clojure a knihovny pro práci s vektory a maticemi (2)<br />
<a href="http://www.root.cz/clanky/programovaci-jazyk-clojure-a-knihovny-pro-praci-s-vektory-a-maticemi-2/">http://www.root.cz/clanky/programovaci-jazyk-clojure-a-knihovny-pro-praci-s-vektory-a-maticemi-2/</a>
</li>

<li>Programovací jazyk Clojure: syntéza procedurálních textur s využitím knihovny Clisk<br />
<a href="http://www.root.cz/clanky/programovaci-jazyk-clojure-synteza-proceduralnich-textur-s-vyuzitim-knihovny-clisk/">http://www.root.cz/clanky/programovaci-jazyk-clojure-synteza-proceduralnich-textur-s-vyuzitim-knihovny-clisk/</a>
</li>

<li>Programovací jazyk Clojure: syntéza procedurálních textur s využitím knihovny Clisk (2)<br />
<a href="http://www.root.cz/clanky/programovaci-jazyk-clojure-synteza-proceduralnich-textur-s-vyuzitim-knihovny-clisk-2/">http://www.root.cz/clanky/programovaci-jazyk-clojure-synteza-proceduralnich-textur-s-vyuzitim-knihovny-clisk-2/</a>
</li>

<li>Programovací jazyk Clojure: syntéza procedurálních textur s využitím knihovny Clisk (dokončení)<br />
<a href="http://www.root.cz/clanky/programovaci-jazyk-clojure-synteza-proceduralnich-textur-s-vyuzitim-knihovny-clisk-dokonceni/">http://www.root.cz/clanky/programovaci-jazyk-clojure-synteza-proceduralnich-textur-s-vyuzitim-knihovny-clisk-dokonceni/</a>
</li>

<li>Seesaw: knihovna pro snadnou tvorbu GUI v jazyce Clojure<br />
<a href="http://www.root.cz/clanky/seesaw-knihovna-pro-snadnou-tvorbu-gui-v-jazyce-clojure/">http://www.root.cz/clanky/seesaw-knihovna-pro-snadnou-tvorbu-gui-v-jazyce-clojure/</a>
</li>

<li>Seesaw: knihovna pro snadnou tvorbu GUI v jazyce Clojure (2)<br />
<a href="http://www.root.cz/clanky/seesaw-knihovna-pro-snadnou-tvorbu-gui-v-jazyce-clojure-2/">http://www.root.cz/clanky/seesaw-knihovna-pro-snadnou-tvorbu-gui-v-jazyce-clojure-2/</a>
</li>

<li>Seesaw: knihovna pro snadnou tvorbu GUI v jazyce Clojure (3)<br />
<a href="http://www.root.cz/clanky/seesaw-knihovna-pro-snadnou-tvorbu-gui-v-jazyce-clojure-3/">http://www.root.cz/clanky/seesaw-knihovna-pro-snadnou-tvorbu-gui-v-jazyce-clojure-3/</a>
</li>

<li>Programovací jazyk Clojure a práce s Gitem<br />
<a href="http://www.root.cz/clanky/programovaci-jazyk-clojure-a-prace-s-gitem/">http://www.root.cz/clanky/programovaci-jazyk-clojure-a-prace-s-gitem/</a>
</li>

<li>Programovací jazyk Clojure a práce s Gitem (2)<br />
<a href="http://www.root.cz/clanky/programovaci-jazyk-clojure-a-prace-s-gitem-2/">http://www.root.cz/clanky/programovaci-jazyk-clojure-a-prace-s-gitem-2/</a>
</li>

<li>Programovací jazyk Clojure – triky při práci s řetězci<br />
<a href="http://www.root.cz/clanky/programovaci-jazyk-clojure-triky-pri-praci-s-retezci/">http://www.root.cz/clanky/programovaci-jazyk-clojure-triky-pri-praci-s-retezci/</a>
</li>

<li>Programovací jazyk Clojure – triky při práci s kolekcemi<br />
<a href="http://www.root.cz/clanky/programovaci-jazyk-clojure-triky-pri-praci-s-kolekcemi/">http://www.root.cz/clanky/programovaci-jazyk-clojure-triky-pri-praci-s-kolekcemi/</a>
</li>

<li>Programovací jazyk Clojure – práce s mapami a množinami<br />
<a href="http://www.root.cz/clanky/programovaci-jazyk-clojure-prace-s-mapami-a-mnozinami/">http://www.root.cz/clanky/programovaci-jazyk-clojure-prace-s-mapami-a-mnozinami/</a>
</li>

</ol>



<p><a name="k12"></a></p>
<h2 id="k12">12. Odkazy na Internetu</h2>

<ol>

<li>Clojure doc: zipper<br />
<a href="http://clojuredocs.org/clojure.zip/zipper">http://clojuredocs.org/clojure.zip/zipper</a>
</li>

<li>Clojure doc: parse<br />
<a href="http://clojuredocs.org/clojure.xml/parse">http://clojuredocs.org/clojure.xml/parse</a>
</li>

<li>Clojure doc: xml-zip<br />
<a href="http://clojuredocs.org/clojure.zip/xml-zip">http://clojuredocs.org/clojure.zip/xml-zip</a>
</li>

<li>Clojure doc: xml-seq<br />
<a href="http://clojuredocs.org/clojure.core/xml-seq">http://clojuredocs.org/clojure.core/xml-seq</a>
</li>

<li>Parsing XML in Clojure<br />
<a href="https://github.com/clojuredocs/guides">https://github.com/clojuredocs/guides</a>
</li>

<li>Clojure Zipper Over Nested Vector<br />
<a href="https://vitalyper.wordpress.com/2010/11/23/clojure-zipper-over-nested-vector/">https://vitalyper.wordpress.com/2010/11/23/clojure-zipper-over-nested-vector/</a>
</li>

<li>Understanding Clojure's PersistentVector implementation<br />
<a href="http://blog.higher-order.net/2009/02/01/understanding-clojures-persistentvector-implementation">http://blog.higher-order.net/2009/02/01/understanding-clojures-persistentvector-implementation</a>
</li>

<li>Understanding Clojure's PersistentHashMap (deftwice...)<br />
<a href="http://blog.higher-order.net/2009/09/08/understanding-clojures-persistenthashmap-deftwice.html">http://blog.higher-order.net/2009/09/08/understanding-clojures-persistenthashmap-deftwice.html</a>
</li>

<li>Assoc and Clojure's PersistentHashMap: part ii<br />
<a href="http://blog.higher-order.net/2010/08/16/assoc-and-clojures-persistenthashmap-part-ii.html">http://blog.higher-order.net/2010/08/16/assoc-and-clojures-persistenthashmap-part-ii.html</a>
</li>

<li>Ideal Hashtrees (paper)<br />
<a href="http://lampwww.epfl.ch/papers/idealhashtrees.pdf">http://lampwww.epfl.ch/papers/idealhashtrees.pdf</a>
</li>

<li>Clojure home page<br />
<a href="http://clojure.org/">http://clojure.org/</a>
</li>

<li>Clojure (downloads)<br />
<a href="http://clojure.org/downloads">http://clojure.org/downloads</a>
</li>

<li>Clojure Sequences<br />
<a href="http://clojure.org/sequences">http://clojure.org/sequences</a>
</li>

<li>Clojure Data Structures<br />
<a href="http://clojure.org/data_structures">http://clojure.org/data_structures</a>
</li>

<li>The Structure and Interpretation of Computer Programs: 2.2.1  Representing Sequences<br />
<a href="http://mitpress.mit.edu/sicp/full-text/book/book-Z-H-15.html#%_sec_2.2.1">http://mitpress.mit.edu/sicp/full-text/book/book-Z-H-15.html#%_sec_2.2.1</a>
</li>

<li>The Structure and Interpretation of Computer Programs: 3.3.1  Mutable List Structure<br />
<a href="http://mitpress.mit.edu/sicp/full-text/book/book-Z-H-22.html#%_sec_3.3.1">http://mitpress.mit.edu/sicp/full-text/book/book-Z-H-22.html#%_sec_3.3.1</a>
</li>

<li>Clojure - Functional Programming for the JVM<br />
<a href="http://java.ociweb.com/mark/clojure/article.html">http://java.ociweb.com/mark/clojure/article.html</a>
</li>

<li>Clojure quick reference<br />
<a href="http://faustus.webatu.com/clj-quick-ref.html">http://faustus.webatu.com/clj-quick-ref.html</a>
</li>

<li>4Clojure<br />
<a href="http://www.4clojure.com/">http://www.4clojure.com/</a>
</li>

<li>ClojureDoc (rozcestník s&nbsp;dokumentací jazyka Clojure)<br />
<a href="http://clojuredocs.org/">http://clojuredocs.org/</a>
</li>

<li>Clojure (na Wikipedia EN)<br />
<a href="http://en.wikipedia.org/wiki/Clojure">http://en.wikipedia.org/wiki/Clojure</a>
</li>

<li>Clojure (na Wikipedia CS)<br />
<a href="http://cs.wikipedia.org/wiki/Clojure">http://cs.wikipedia.org/wiki/Clojure</a>
</li>

<li>SICP (The Structure and Interpretation of Computer Programs)<br />
<a href="http://mitpress.mit.edu/sicp/">http://mitpress.mit.edu/sicp/</a>
</li>

<li>Pure function<br />
<a href="http://en.wikipedia.org/wiki/Pure_function">http://en.wikipedia.org/wiki/Pure_function</a>
</li>

<li>Funkcionální programování<br />
<a href="http://cs.wikipedia.org/wiki/Funkcionální_programování">http://cs.wikipedia.org/wiki/Funkcionální_programování</a>
</li>

<li>Čistě funkcionální (datové struktury, jazyky, programování)<br />
<a href="http://cs.wikipedia.org/wiki/Čistě_funkcionální">http://cs.wikipedia.org/wiki/Čistě_funkcionální</a>
</li>

<li>Clojure Macro Tutorial (Part I, Getting the Compiler to Write Your Code For You)<br />
<a href="http://www.learningclojure.com/2010/09/clojure-macro-tutorial-part-i-getting.html">http://www.learningclojure.com/2010/09/clojure-macro-tutorial-part-i-getting.html</a>
</li>

<li>Clojure Macro Tutorial (Part II: The Compiler Strikes Back)<br />
<a href="http://www.learningclojure.com/2010/09/clojure-macro-tutorial-part-ii-compiler.html">http://www.learningclojure.com/2010/09/clojure-macro-tutorial-part-ii-compiler.html</a>
</li>

<li>Clojure Macro Tutorial (Part III: Syntax Quote)<br />
<a href="http://www.learningclojure.com/2010/09/clojure-macro-tutorial-part-ii-syntax.html">http://www.learningclojure.com/2010/09/clojure-macro-tutorial-part-ii-syntax.html</a>
</li>

<li>Tech behind Tech: Clojure Macros Simplified<br />
<a href="http://techbehindtech.com/2010/09/28/clojure-macros-simplified/">http://techbehindtech.com/2010/09/28/clojure-macros-simplified/</a>
</li>

<li>Fatvat - Exploring functional programming: Clojure Macros<br />
<a href="http://www.fatvat.co.uk/2009/02/clojure-macros.html">http://www.fatvat.co.uk/2009/02/clojure-macros.html</a>
</li>

<li>Eulerovo číslo<br />
<a href="http://cs.wikipedia.org/wiki/Eulerovo_číslo">http://cs.wikipedia.org/wiki/Eulerovo_číslo</a>
</li>

<li>List comprehension<br />
<a href="http://en.wikipedia.org/wiki/List_comprehension">http://en.wikipedia.org/wiki/List_comprehension</a>
</li>

<li>List Comprehensions in Clojure<br />
<a href="http://asymmetrical-view.com/2008/11/18/list-comprehensions-in-clojure.html">http://asymmetrical-view.com/2008/11/18/list-comprehensions-in-clojure.html</a>
</li>

<li>Clojure Programming Concepts: List Comprehension<br />
<a href="http://en.wikibooks.org/wiki/Clojure_Programming/Concepts#List_Comprehension">http://en.wikibooks.org/wiki/Clojure_Programming/Concepts#List_Comprehension</a>
</li>

<li>Clojure core API: for macro<br />
<a href="http://clojure.github.com/clojure/clojure.core-api.html#clojure.core/for">http://clojure.github.com/clojure/clojure.core-api.html#clojure.core/for</a>
</li>

<li>cirrus machina - The Clojure for macro<br />
<a href="http://www.cirrusmachina.com/blog/comment/the-clojure-for-macro/">http://www.cirrusmachina.com/blog/comment/the-clojure-for-macro/</a>
</li>

<li>Riastradh's Lisp Style Rules<br />
<a href="http://mumble.net/~campbell/scheme/style.txt">http://mumble.net/~campbell/scheme/style.txt</a>
</li>

<li>Dynamic Languages Strike Back<br />
<a href="http://steve-yegge.blogspot.cz/2008/05/dynamic-languages-strike-back.html">http://steve-yegge.blogspot.cz/2008/05/dynamic-languages-strike-back.html</a>
</li>

<li>Scripting: Higher Level Programming for the 21st Century<br />
<a href="http://www.tcl.tk/doc/scripting.html">http://www.tcl.tk/doc/scripting.html</a>
</li>

<li>Java Virtual Machine Support for Non-Java Languages<br />
<a href="http://docs.oracle.com/javase/7/docs/technotes/guides/vm/multiple-language-support.html">http://docs.oracle.com/javase/7/docs/technotes/guides/vm/multiple-language-support.html</a>
</li>

<li>Třída java.lang.String<br />
<a href="http://docs.oracle.com/javase/7/docs/api/java/lang/String.html">http://docs.oracle.com/javase/7/docs/api/java/lang/String.html</a>
</li>

<li>Třída java.lang.StringBuffer<br />
<a href="http://docs.oracle.com/javase/7/docs/api/java/lang/StringBuffer.html">http://docs.oracle.com/javase/7/docs/api/java/lang/StringBuffer.html</a>
</li>

<li>Třída java.lang.StringBuilder<br />
<a href="http://docs.oracle.com/javase/7/docs/api/java/lang/StringBuilder.html">http://docs.oracle.com/javase/7/docs/api/java/lang/StringBuilder.html</a>
</li>

<li>StringBuffer versus String<br />
<a href="http://www.javaworld.com/article/2076072/build-ci-sdlc/stringbuffer-versus-string.html">http://www.javaworld.com/article/2076072/build-ci-sdlc/stringbuffer-versus-string.html</a>
</li>

<li>Threading macro (dokumentace k&nbsp;jazyku Clojure)<br />
<a href="https://clojure.github.io/clojure/clojure.core-api.html#clojure.core/-&gt;">https://clojure.github.io/clojure/clojure.core-api.html#clojure.core/-&gt;</a>
</li>

<li>Understanding the Clojure -&gt; macro<br />
<a href="http://blog.fogus.me/2009/09/04/understanding-the-clojure-macro/">http://blog.fogus.me/2009/09/04/understanding-the-clojure-macro/</a>
</li>

<li>clojure.inspector<br />
<a href="http://clojure.github.io/clojure/clojure.inspector-api.html">http://clojure.github.io/clojure/clojure.inspector-api.html</a>
</li>

<li>The Clojure Toolbox<br />
<a href="http://www.clojure-toolbox.com/">http://www.clojure-toolbox.com/</a>
</li>

<li>Unit Testing in Clojure<br />
<a href="http://nakkaya.com/2009/11/18/unit-testing-in-clojure/">http://nakkaya.com/2009/11/18/unit-testing-in-clojure/</a>
</li>

<li>Testing in Clojure (Part-1: Unit testing)<br />
<a href="http://blog.knoldus.com/2014/03/22/testing-in-clojure-part-1-unit-testing/">http://blog.knoldus.com/2014/03/22/testing-in-clojure-part-1-unit-testing/</a>
</li>

<li>API for clojure.test - Clojure v1.6 (stable)<br />
<a href="https://clojure.github.io/clojure/clojure.test-api.html">https://clojure.github.io/clojure/clojure.test-api.html</a>
</li>

<li>Leiningen: úvodní stránka<br />
<a href="http://leiningen.org/">http://leiningen.org/</a>
</li>

<li>Leiningen: Git repository<br />
<a href="https://github.com/technomancy/leiningen">https://github.com/technomancy/leiningen</a>
</li>

<li>leiningen-win-installer<br />
<a href="http://leiningen-win-installer.djpowell.net/">http://leiningen-win-installer.djpowell.net/</a>
</li>

<li>Clojure  1: Úvod<br />
<a href="http://www.root.cz/clanky/clojure-aneb-jazyk-umoznujici-tvorbu-bezpecnych-vicevlaknovych-aplikaci-pro-jvm/">http://www.root.cz/clanky/clojure-aneb-jazyk-umoznujici-tvorbu-bezpecnych-vicevlaknovych-aplikaci-pro-jvm/</a>
</li>

<li>Clojure  2: Symboly, kolekce atd.<br />
<a href="http://www.root.cz/clanky/clojure-aneb-jazyk-umoznujici-tvorbu-bezpecnych-vicevlaknovych-aplikaci-pro-jvm-2-cast/">http://www.root.cz/clanky/clojure-aneb-jazyk-umoznujici-tvorbu-bezpecnych-vicevlaknovych-aplikaci-pro-jvm-2-cast/</a>
</li>

<li>Clojure  3: Funkcionální programování<br />
<a href="http://www.root.cz/clanky/clojure-aneb-jazyk-umoznujici-tvorbu-bezpecnych-vicevlaknovych-aplikaci-pro-jvm-3-cast-funkcionalni-programovani/">http://www.root.cz/clanky/clojure-aneb-jazyk-umoznujici-tvorbu-bezpecnych-vicevlaknovych-aplikaci-pro-jvm-3-cast-funkcionalni-programovani/</a>
</li>

<li>Clojure  4: Kolekce, sekvence a lazy sekvence<br />
<a href="http://www.root.cz/clanky/clojure-aneb-jazyk-umoznujici-tvorbu-bezpecnych-vicevlaknovych-aplikaci-pro-jvm-4-cast-kolekce-sekvence-a-lazy-sekvence/">http://www.root.cz/clanky/clojure-aneb-jazyk-umoznujici-tvorbu-bezpecnych-vicevlaknovych-aplikaci-pro-jvm-4-cast-kolekce-sekvence-a-lazy-sekvence/</a>
</li>

<li>Clojure  5: Sekvence, lazy sekvence a paralelní programy<br />
<a href="http://www.root.cz/clanky/clojure-a-bezpecne-aplikace-pro-jvm-sekvence-lazy-sekvence-a-paralelni-programy/">http://www.root.cz/clanky/clojure-a-bezpecne-aplikace-pro-jvm-sekvence-lazy-sekvence-a-paralelni-programy/</a>
</li>

<li>Clojure  6: Podpora pro paralelní programování<br />
<a href="http://www.root.cz/clanky/programovaci-jazyk-clojure-6-futures-nejsou-jen-financni-derivaty/">http://www.root.cz/clanky/programovaci-jazyk-clojure-6-futures-nejsou-jen-financni-derivaty/</a>
</li>

<li>Clojure  7: Další funkce pro paralelní programování<br />
<a href="http://www.root.cz/clanky/programovaci-jazyk-clojure-7-dalsi-podpurne-prostredky-pro-paralelni-programovani/">http://www.root.cz/clanky/programovaci-jazyk-clojure-7-dalsi-podpurne-prostredky-pro-paralelni-programovani/</a>
</li>

<li>Clojure  8: Identity, stavy, neměnné hodnoty a reference<br />
<a href="http://www.root.cz/clanky/programovaci-jazyk-clojure-8-identity-stavy-nemenne-hodnoty-a-referencni-typy/">http://www.root.cz/clanky/programovaci-jazyk-clojure-8-identity-stavy-nemenne-hodnoty-a-referencni-typy/</a>
</li>

<li>Clojure  9: Validátory, pozorovatelé a kooperace s Javou<br />
<a href="http://www.root.cz/clanky/programovaci-jazyk-clojure-9-validatory-pozorovatele-a-kooperace-mezi-clojure-a-javou/">http://www.root.cz/clanky/programovaci-jazyk-clojure-9-validatory-pozorovatele-a-kooperace-mezi-clojure-a-javou/</a>
</li>

<li>Clojure 10: Kooperace mezi Clojure a Javou<br />
<a href="http://www.root.cz/clanky/programovaci-jazyk-clojure-10-kooperace-mezi-clojure-a-javou-pokracovani/">http://www.root.cz/clanky/programovaci-jazyk-clojure-10-kooperace-mezi-clojure-a-javou-pokracovani/</a>
</li>

<li>Clojure 11: Generátorová notace seznamu/list comprehension<br />
<a href="http://www.root.cz/clanky/programovaci-jazyk-clojure-11-generatorova-notace-seznamu-list-comprehension/">http://www.root.cz/clanky/programovaci-jazyk-clojure-11-generatorova-notace-seznamu-list-comprehension/</a>
</li>

<li>Clojure 12: Překlad programů z Clojure do bajtkódu JVM I:<br />
<a href="http://www.root.cz/clanky/programovaci-jazyk-clojure-12-preklad-programu-z-clojure-do-bajtkodu-jvm/">http://www.root.cz/clanky/programovaci-jazyk-clojure-12-preklad-programu-z-clojure-do-bajtkodu-jvm/</a>
</li>

<li>Clojure 13: Překlad programů z Clojure do bajtkódu JVM II:<br />
<a href="http://www.root.cz/clanky/programovaci-jazyk-clojure-13-preklad-programu-z-clojure-do-bajtkodu-jvm-pokracovani/">http://www.root.cz/clanky/programovaci-jazyk-clojure-13-preklad-programu-z-clojure-do-bajtkodu-jvm-pokracovani/</a>
</li>

<li>Clojure 14: Základy práce se systémem maker<br />
<a href="http://www.root.cz/clanky/programovaci-jazyk-clojure-14-zaklady-prace-se-systemem-maker/">http://www.root.cz/clanky/programovaci-jazyk-clojure-14-zaklady-prace-se-systemem-maker/</a>
</li>

<li>Clojure 15: Tvorba uživatelských maker<br />
<a href="http://www.root.cz/clanky/programovaci-jazyk-clojure-15-tvorba-uzivatelskych-maker/">http://www.root.cz/clanky/programovaci-jazyk-clojure-15-tvorba-uzivatelskych-maker/</a>
</li>

<li>Clojure 16: Složitější uživatelská makra<br />
<a href="http://www.root.cz/clanky/programovaci-jazyk-clojure-16-slozitejsi-uzivatelska-makra/">http://www.root.cz/clanky/programovaci-jazyk-clojure-16-slozitejsi-uzivatelska-makra/</a>
</li>

<li>Clojure 17: Využití standardních maker v praxi<br />
<a href="http://www.root.cz/clanky/programovaci-jazyk-clojure-17-vyuziti-standardnich-maker-v-praxi/">http://www.root.cz/clanky/programovaci-jazyk-clojure-17-vyuziti-standardnich-maker-v-praxi/</a>
</li>

<li>Clojure 18: Základní techniky optimalizace aplikací<br />
<a href="http://www.root.cz/clanky/programovaci-jazyk-clojure-18-zakladni-techniky-optimalizace-aplikaci/">http://www.root.cz/clanky/programovaci-jazyk-clojure-18-zakladni-techniky-optimalizace-aplikaci/</a>
</li>

<li>Clojure 19: Vývojová prostředí pro Clojure<br />
<a href="http://www.root.cz/clanky/programovaci-jazyk-clojure-19-vyvojova-prostredi-pro-clojure/">http://www.root.cz/clanky/programovaci-jazyk-clojure-19-vyvojova-prostredi-pro-clojure/</a>
</li>

<li>Clojure 20: Vývojová prostředí pro Clojure (Vimu s REPL)<br />
<a href="http://www.root.cz/clanky/programovaci-jazyk-clojure-20-vyvojova-prostredi-pro-clojure-integrace-vimu-s-repl/">http://www.root.cz/clanky/programovaci-jazyk-clojure-20-vyvojova-prostredi-pro-clojure-integrace-vimu-s-repl/</a>
</li>

<li>Clojure 21: ClojureScript aneb překlad Clojure do JS<br />
<a href="http://www.root.cz/clanky/programovaci-jazyk-clojure-21-clojurescript-aneb-preklad-clojure-do-javascriptu/">http://www.root.cz/clanky/programovaci-jazyk-clojure-21-clojurescript-aneb-preklad-clojure-do-javascriptu/</a>
</li>

<li>Clojure.org: Vars and the Global Environment<br />
<a href="http://clojure.org/Vars">http://clojure.org/Vars</a>
</li>

<li>Clojure.org: Refs and Transactions<br />
<a href="http://clojure.org/Refs">http://clojure.org/Refs</a>
</li>

<li>Clojure.org: Atoms<br />
<a href="http://clojure.org/Atoms">http://clojure.org/Atoms</a>
</li>

<li>Clojure.org: Agents as Asynchronous Actions<br />
<a href="http://clojure.org/agents">http://clojure.org/agents</a>
</li>

<li>Transient Data Structures
<a href="http://clojure.org/transients">http://clojure.org/transients</a>
</li>

</ol>



<p></p><p></p>
<p><small>Autor: <a href="http://www.fit.vutbr.cz/~tisnovpa">Pavel Tišnovský</a> &nbsp; 2015</small></p>
</body>
</html>

