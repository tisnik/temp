<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
        "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html>
<head>
<title>Programovací jazyk Pixie aneb &bdquo;Clojure bez JVM&ldquo;</title>
<meta name="Author" content="Pavel Tisnovsky" />
<meta name="Generator" content="vim" />
<meta http-equiv="content-type" content="text/html; charset=utf-8" />
<style type="text/css">
         body {color:#000000; background:#ffffff;}
         h1  {font-family: arial, helvetica, sans-serif; color:#ffffff; background-color:#c00000; text-align:center; padding-left:1em}
         h2  {font-family: arial, helvetica, sans-serif; color:#ffffff; background-color:#0000c0; padding-left:1em; text-align:left}
         h3  {font-family: arial, helvetica, sans-serif; color:#000000; background-color:#c0c0c0; padding-left:1em; text-align:left}
         h4  {font-family: arial, helvetica, sans-serif; color:#000000; background-color:#e0e0e0; padding-left:1em; text-align:left}
         a   {font-family: arial, helvetica, sans-serif;}
         li  {font-family: arial, helvetica, sans-serif; color:#000000; text-align:justify; width:450px;}
         ol  {font-family: arial, helvetica, sans-serif; color:#000000; text-align:justify; width:450px;}
         ul  {font-family: arial, helvetica, sans-serif; color:#000000; text-align:justify; width:450px;}
         p   {font-family: arial, helvetica, sans-serif; color:#000000; text-align:justify;}
         pre {background:#e0e0e0}
</style>
</head>

<body>

<h1>Programovací jazyk Pixie aneb &bdquo;Clojure bez JVM&ldquo;</h1>

<h3>Pavel Tišnovský</h3>

<p></p>

<h1>Úvodník</h1>

<p>Programovací jazyk Clojure pro svůj běh vyžaduje nějaký virtuální stroj, ať již se jedná o JVM, CLR či o VM pro JavaScript. Žádná z těchto variant sice není vhodná pro psaní kratších skriptů spouštěných z příkazové řádky, ovšem existuje zde jedno řešení &ndash; jazyk Pixie s vlastní &bdquo;odlehčenou&ldquo; VM.</p>



<h2>Obsah</h2>

<p><a href="#k01">1. Clojure pro JVM, CLR i virtuální stroje JavaScriptu</a></p>
<p><a href="#k02">2. Programovací jazyk Pixie aneb &bdquo;Clojure bez JVM&ldquo;</a></p>
<p><a href="#k03">3. Překlad interpretru a JITu jazyka Pixie</a></p>
<p><a href="#k04">4. Kontrola, zda jsou nainstalovány všechny potřebné knihovny</a></p>
<p><a href="#k05">5. Spuštění interpretru (smyčky REPL)</a></p>
<p><a href="#k06">6. Strukturované datové typy (kolekce)</a></p>
<p><a href="#k07">7. Základní operace nad strukturovanými datovými typy (kolekcemi)</a></p>
<p><a href="#k08">8. Funkce vyššího řádu</a></p>
<p><a href="#k09">9. Threading makra</a></p>
<p><a href="#k10">10. Podpora pro práci se zlomky a čísly s&nbsp;neomezeným rozsahem</a></p>
<p><a href="#k11">11. Práce s&nbsp;atomy</a></p>
<p><a href="#k12">12. Atomy a strukturované datové typy</a></p>
<p><a href="#k13">13. Odkazy na předchozí části tohoto seriálu</a></p>
<p><a href="#k14">14. Odkazy na Internetu</a></p>



<p><a name="k01"></a></p>
<h2 id="k01">1. Clojure pro JVM, CLR i virtuální stroje JavaScriptu</h2>

<p><i>&bdquo;That is to say, if you're doing lightweight scripting, or want
something that boots fast and runs well on low-end systems, Pixie might be a
good fit. Basically I want it for all those times I'd reach for Python instead
of Clojure.&ldquo;<br />
Autor programovacího jazyka Pixie.</i></p>

<p>Programovací jazyk Clojure v&nbsp;současnosti oficiálně existuje ve třech
variantách. Pravděpodobně nejpoužívanější varianta je určena pro běh nad JVM
(virtuálním strojem jazyka Java, Java Virtual Machine), dále existuje varianta
pro CLR (Common Language Runtime z&nbsp;.NET) a třetí variantou je
ClojureScript transformovaný do JavaScriptu a tedy využitelný například ve
webových prohlížečích či v&nbsp;běhovém prostředí Node.js. Všechny tři zmíněné
varianty mají jednu společnou vlastnost &ndash; spuštění a inicializace
vlastního virtuálního stroje je poměrně zdlouhavé, což je kritické zejména na
méně výkonných zařízeních (IoT). To mj.&nbsp;znamená, že se Clojure (ale
například ani Java, Jython či Ruby) příliš často nepoužívá k&nbsp;psaní
nástrojů, které mají běžet relativně krátkou dobu a mají být spouštěny
z&nbsp;příkazové řádky. Existují sice řešení, které se snaží neustálé spouštění
virtuálního stroje obejít (dobrým příkladem je projekt <i>Nailgun</i>), ovšem
to neřeší vlastní problém; ten se pouze více či méně úspěšně obchází.</p>



<p><a name="k02"></a></p>
<h2 id="k02">2. Programovací jazyk Pixie aneb &bdquo;Clojure bez JVM&ldquo;</h2>

<p><i>&bdquo;...the first language I ever wrote was when I was in high-school.
It was a small interpreted language named PhaLinks and was terrible, but I
learned a lot from the effort. I also acquired a distaste for parsers in the
process. Which, incidentally, is why I stick with Lisp these days: Lisp parsers
are super easy to write.&ldquo;<br />
Autor programovacího jazyka Pixie.</i></p>

<p>Pokud programátoři, kteří propadli kouzlu programovacího jazyka Clojure,
potřebují kromě aplikací běžících delší dobu (webový server atd.) vytvářet i
kratší skripty spouštěné typicky z&nbsp;příkazové řádky, nezbývá jim nic
jiného, než se poohlédnout po alternativních řešeních a jazycích, které se
(alespoň prozatím) Clojure pouze podobají a nejsou s&nbsp;ním vždy na 100%
kompatibilní. Prozatím pravděpodobně nejpropracovanější variantou je jazyk
nazvaný <i>Pixie</i>. Jazyk <i>Pixie</i> využívá <i>just in time</i> překladač
(JIT) i správce paměti implementovaný <a
href="http://pypy.org/">v&nbsp;PyPy</a>, další části Pixie jsou pak psány
v&nbsp;jazycích C a C++.</p>

<p>Na rozdíl od Clojure, které se spoléhá na to, že programátoři budou využívat
knihovny kompatibilní s&nbsp;vybraným virtuálním strojem (tj.&nbsp;například
javovskou standardní knihovnu apod.) se jazyk Pixie spoléhá na rozhraní <i>FFI
(Foreign Function Interface</i>) a tím pádem na použití nativních knihoven
dostupných v&nbsp;operačním systému, v&nbsp;němž aplikace poběží. Kombinace
JITu a GC z&nbsp;PyPy společně s&nbsp;nativními knihovnami se ukazuje být
úspěšná, protože skripty psané v&nbsp;Pixie bez výkonnostních problémů fungují
i na prvních modelech Raspberry Pi (to se týká i prakticky okamžitého
spouštění).</p>

<p>Poznámka: Pixie není v&nbsp;žádném případě prvním programovacím jazykem,
který se do jisté míry snaží napodobit programovací jazyk Clojure. V&nbsp;tomto
seriálu jsme se již setkali s&nbsp;programovacím jazykem Wisp, který je
automaticky s&nbsp;využitím takzvaného <i>transpileru</i> transformován do
JavaScriptu, dále existuje sémanticky podobný jazyk naprogramovaný v&nbsp;Perlu
atd. Ovšem Pixie je z&nbsp;těchto jazyků nejpropracovanější a především pak
prakticky využitelný.</p>



<p><a name="k03"></a></p>
<h2 id="k03">3. Překlad interpretru a JITu jazyka Pixie</h2>

<p>Všechny dále uvedené příklady byly spouštěny a odzkoušeny na poslední verzi
jazyka Pixie přeloženého ze zdrojových kódů získaných na GitHubu
z&nbsp;repositáře <a
href="https://github.com/pixie-lang/pixie">https://github.com/pixie-lang/pixie</a>
(větev master). Vzhledem k&nbsp;tomu, že se tento jazyk poměrně rychle vyvíjí,
je lepší provést překlad Pixie právě z&nbsp;oficiálního repositáře a nepoužívat
velmi pravděpodobně zastaralou verzi z&nbsp;vaší linuxové distribuce. Ve
skutečnosti není překlad příliš složitý, pouze poměrně zdlouhavý. Navíc vám
k&nbsp;urychlení překladu příliš nepomůže procesor s&nbsp;větším množstvím
jader, protože podstatná část překladu probíhá v&nbsp;jediném vláknu.</p>

<p>Prvním krokem je instalace všech potřebných knihoven:</p>

<ol>
<li>libffi-dev</li>
<li>libedit-dev</li>
<li>libuv-dev</li>
<li>libboost-dev</li>
</ol>

<p>Dále je nutné, aby byl na systému nainstalován interpret Pythonu (2), což je
však s&nbsp;velkou pravděpodobností na prakticky všech distribucích
splněno.</p>

<p>Další závislosti:</p>

<ol>
<li>Překladač jazyka C (gcc)</li>
<li>Překladač jazyka C++ (g++)</li>
<li>Nástroj Make</li>
</ol>

<p>Dejte si prosím pozor na to, že pokud není nainstalován překladač jazyka
C++, může překlad vypadat zdánlivě v&nbsp;pořádku, protože chybová hlášení
relativně rychle &bdquo;odscrollují&ldquo;, ovšem překlad pokračuje dále.</p>

<p>O vlastní překlad se postará nástroj Make, překlad se spustí takto:</p>

<pre>
make build_with_jit
</pre>

<p>V&nbsp;první fázi překladu dochází ke stažení dalších balíčků potřebných pro
sestrojení virtuálního stroje jazyka Pixie. Nelekněte se tedy, že se stahuje
například poměrně objemný tarball obsahující PyPy z&nbsp;adresy <a
href="https://bitbucket.org/pypy/pypy/get/91db1a9.tar.bz2">https://bitbucket.org/pypy/pypy/get/91db1a9.tar.bz2</a>.</p>

<p>V&nbsp;průběhu překladu dochází mj.&nbsp;i k&nbsp;ladění parametrů JITu,
takže se nelekněte, když se při překladu začnou na terminál vykreslovat různé
fraktály atd. (viz též přiložené screenshoty).</p>

<p><a href="https://www.root.cz/obrazek/266796/"><img src="https://i.iinfo.cz/images/372/pixie-1-prev.png" class="image-266796" alt="&#160;" width="370" height="237" /></a></p>

<p>Výsledkem překladu by měl být spustitelný soubor nazvaný
<strong>pixie-vm</strong> o velikosti přibližně 11 MB (což je stále o mnoho
méně, než je velikost JVM z&nbsp;JRE). Pro úspěšné spuštění interpretru dále
potřebujete adresář <strong>pixie</strong>; ostatní adresáře jsou potřebné jen
pro otestování či pro překlad.</p>

<p><a href="https://www.root.cz/obrazek/266797/"><img src="https://i.iinfo.cz/images/372/pixie-2-prev.png" class="image-266797" alt="&#160;" width="370" height="237" /></a></p>



<p><a name="k04"></a></p>
<h2 id="k04">4. Kontrola, zda jsou nainstalovány všechny potřebné knihovny</h2>

<p>Typický problém, na který můžete narazit až <i>po překladu</i> interpretru,
je chybějící knihovna <strong>libedit-dev</strong>. Pokud tato knihovna není
nainstalována (skutečně se jedná o -dev variantu), vypíše se při pokusu o start
interpretru následující chybové hlášení:</p>

<pre>
<strong>./pixie-vm</strong>
&nbsp;
in internal function run_load_stdlib
&nbsp;
in internal function load-ns
&nbsp;
in internal function load-file
&nbsp;
in pixie function _toplevel_
&nbsp;
in pixie/stdlib.pxi at 14:14
(def libedit (ffi-library (str "libedit." pixie.platform/so-ext)))
 &nbsp;            ^
in internal function ffi-library
&nbsp;
RuntimeException: &lt;inst pixie.stdlib.Keyword&gt; Couldn't Load Library: libedit.so
</pre>

<p>Podobné chybové hlášení se objeví ve chvíli, kdy není k&nbsp;dispozici
knihovna <strong>libffi-dev</strong>. Ostatní závislosti jsou kontrolovány již
v&nbsp;době překladu.</p>



<p><a name="k05"></a></p>
<h2 id="k05">5. Spuštění interpretru (smyčky REPL)</h2>

<p>Předpokládejme, že se virtuální stroj s&nbsp;interpretrem jazyka Pixie
podařilo přeložit bez problémů. Zbývá nám si otestovat jeho základní
funkcionalitu, takže si nejprve interpret spusťme:</p>

<pre>
<strong>./pixie-vm</strong>
user =&gt;
</pre>

<p>Spuštěním virtuálního stroje jsme se dostali do základního režimu
interpretru &ndash; do interaktivní smyčky REPL (Read Eval Print Loop),
v&nbsp;níž lze zadávat libovolné <i>formy</i>, které jsou ihned interpretovány.
Syntaxe zápisu forem odpovídá syntaxi programovacího jazyka Clojure, což si
ostatně můžeme velmi jednoduše vyzkoušet:</p>

<pre>
<i>; vyhodnocení konstant</i>
user =&gt;<strong> 42</strong>
42
&nbsp;
user =&gt;<strong> :foo</strong>
:foo
&nbsp;
user =&gt;<strong> "Hello"</strong>
"Hello"
&nbsp;
user =&gt;<strong> 1/2</strong>
1/2
&nbsp;
user =&gt;<strong> nil</strong>
nil
&nbsp;
<i>; volání funkcí vyhodnocujících základní aritmetické výrazy</i>
user =&gt;<strong> (* 6 7)</strong>
42
&nbsp;
user =&gt;<strong> (* (+ 1 2 3) (- 4 5 6))</strong>
-42
&nbsp;
<i>; většina funkcí ze standardní knihovny obsahuje dokumentační řetězce</i>
user =&gt;<strong> (doc +)</strong>
pixie.stdlib/+
([&amp; args])
&nbsp;
Adds the arguments, returning 0 if no arguments.
&nbsp;
nil
&nbsp;
user =&gt;<strong> (doc println)</strong>
pixie.stdlib/println
([&amp; args])
&nbsp;
Prints the arguments, separated by spaces, with a newline at the end.
&nbsp;
nil
&nbsp;
user =&gt;<strong> (doc conj)</strong>
pixie.stdlib/conj
([] [coll] [coll item] [coll item &amp; args])
&nbsp;
Adds elements to the collection. Elements are added to the end except in the case of Cons lists.
&nbsp;
nil
</pre>



<p><a name="k06"></a></p>
<h2 id="k06">6. Strukturované datové typy (kolekce)</h2>

<p>Programovací jazyk Pixie podporuje všechny základní strukturované datové
typy, které známe z&nbsp;jazyka Clojure. Jedná se o seznamy, vektory, mapy i
množiny:</p>

<table>
<tr><th>#</th><th>Typ kolekce</th><th>Zápis (syntaktický cukr)</th><th>Konstruktor</th></tr>
<tr><td>1</td><td>Seznam </td><td>(prvky)</td><td>'(prvky)<br />(list prvky)</td></tr>
<tr><td>2</td><td>Vektor </td><td>[prvky]</td><td>(vector prvky)<br />(vec kolekce)</td></tr>
<tr><td>3</td><td>Mapa   </td><td>{dvojice klíč-hodnota}</td><td>(hash-map dvojice klíč-hodnota)<br />(sorted-map dvojice klíč-hodnota)</td></tr>
<tr><td>4</td><td>Množina</td><td>#{unikátní prvky}</td><td>(hash-set unikátní prvky)<br />(sorted-set unikátní prvky)</td></tr>
</table>

<p>Konstruktory těchto typů zapisované s&nbsp;využitím &bdquo;syntaktického
cukru&ldquo; jsou taktéž shodné, ostatně se podívejme na příklady:</p>

<pre>
user =&gt;<strong> (def seznam '(1 2 3 'a 'b "hello"))</strong>
&lt;inst pixie.stdlib.Var&gt;
&nbsp;
user =&gt;<strong> (type seznam)</strong>
pixie.stdlib.Cons
&nbsp;
user =&gt;<strong> (def vektor [1 2 3 'a 'b "hello"])</strong>
&lt;inst pixie.stdlib.Var&gt;
&nbsp;
user =&gt;<strong> (type vektor)</strong>
pixie.stdlib.PersistentVector
&nbsp;
user =&gt;<strong> (def mapa {:first "jedna" :second "dva"})</strong>
&lt;inst pixie.stdlib.Var&gt;
&nbsp;
user =&gt;<strong> (type mapa)</strong>
pixie.stdlib.PersistentHashMap
&nbsp;
user =&gt;<strong> (def mnozina #{1 2 3})</strong>
&lt;inst pixie.stdlib.Var&gt;
&nbsp;
user =&gt;<strong> (type mnozina)</strong>
pixie.stdlib.PersistentHashSet
</pre>

<p>Všechny tyto strukturované typy jsou neměnitelné (<i>immutable</i>), stejně
jako je tomu v&nbsp;programovacím jazyku Clojure. Ostatně se jedná o jednu ze
základních vlastností Clojure, která je &ndash; alespoň podle názoru autora
tohoto článku &ndash; jedním z&nbsp;důležitých faktorů oblíbenosti tohoto
jazyka.</p>

<p>Mezi další vlastnosti, které jsou společné všem kolekcím, patří:</p>

<ul>
<li>Kolekce jsou perzistentní.</li>
<li>Mezi libovolným počtem kolekcí jazyk zajišťuje sdílení struktury, pokud je
to možné.</li>
<li>U všech kolekcí lze zjistit počet prvků funkcí <strong>count</strong>.</li>
<li>Každá kolekce je mapovatelná na sekvenci a je tedy možné procházet všemi
prvky kolekce.</li>
<li>Ke každé kolekci je možné &bdquo;přidat&ldquo; nový prvek funkcí
<strong>conj</strong>, výsledkem je nová kolekce.</li>
</ul>



<p><a name="k07"></a></p>
<h2 id="k07">7. Základní operace nad strukturovanými datovými typy (kolekcemi)</h2>

<p>Některé funkce nabízené jazykem Pixie jsou společné všem kolekcím. Ty
nejužitečnější funkce jsou vypsány v&nbsp;následující tabulce. Povšimněte si,
že některé funkce známé z&nbsp;jazyka Clojure, například funkce
<strong>peek</strong>, zde nenajdeme (ovšem není problém si je v&nbsp;případě
potřeby dodefinovat):</p>

<table>
<tr><th>#</th><th>Funkce</th><th>Význam funkce</th></tr>
<tr><td>1</td><td>count </td><td>vrátí počet prvků v kolekci</td></tr>
<tr><td>2</td><td>empty?</td><td>(<i>s otazníkem na konci</i>) vrátí <strong>true</strong> v&nbsp;případě, že je kolekce prázdná</td></tr>
<tr><td>3</td><td>empty</td><td>(<i>bez otazníku</i>) vrátí prázdnou kolekci stejného typu</td></tr>
<tr><td>4</td><td>not-empty?</td><td>pokud není parametrem prázdná kolekce, vrátí se tato kolekce, jinak se vrátí <strong>nil</strong></td></tr>
<tr><td>5</td><td>cons</td><td>vrátí novou kolekci s&nbsp;přidaným prvkem (odkaz jazyka <i>LISP</i>)</td></tr>
<tr><td>6</td><td>pop</td><td>vrátí kolekci bez prvního prvku (seznamy) nebo bez prvku posledního (vektory)</td></tr>
<tr><td>7</td><td>nth</td><td>získání n-tého prvku kolekce</td></tr>
<tr><td>8</td><td>first</td><td>první prvek kolekce</td></tr>
<tr><td>9</td><td>rest</td><td>kolekce bez prvního prvku</td></tr>
</table>

<p>Tyto funkce si můžeme snadno vyzkoušet v&nbsp;interaktivní smyčce REPL:</p>

<pre>
user =&gt;<strong> (empty? [1 2 3])</strong>
false
&nbsp;
user =&gt;<strong> (empty? [])</strong>
true
&nbsp;
user =&gt;<strong> (empty? {})</strong>
true
&nbsp;
user =&gt;<strong> (empty? {:prvni 1 :druhy 2})</strong>
false
&nbsp;
<i>; speciální případ, kdy nil nahrazuje prázdnou kolekci</i>
user =&gt;<strong> (empty? nil)</strong>
true
&nbsp;
user =&gt;<strong> (count [1 2 3])</strong>
3
&nbsp;
user =&gt;<strong> (def seznam '(1 2 3))</strong>
&lt;inst pixie.stdlib.Var&gt;
&nbsp;
user =&gt;<strong> (def vektor [1 2 3])</strong>
&lt;inst pixie.stdlib.Var&gt;
&nbsp;
user =&gt;<strong> (conj seznam 100)</strong>
(100 1 2 3)
&nbsp;
user =&gt;<strong> (conj vektor 100)</strong>
[1 2 3 100]
&nbsp;
user =&gt;<strong> (pop [1 2 3])</strong>
[1 2]
&nbsp;
user =&gt;<strong> (nth [1 2 3] 1)</strong>
2
&nbsp;
user =&gt;<strong> (first mnozina)</strong>
2
&nbsp;
user =&gt;<strong> (first vektor)</strong>
1
&nbsp;
user =&gt;<strong> (rest vektor)</strong>
(2 3)
&nbsp;
user =&gt;<strong> (rest mnozina)</strong>
(3 1)
</pre>

<p>U map lze použít i zkrácený zápis pro přečtení prvku uloženého pod nějakým
klíčem:</p>

<pre>
user =&gt;<strong> (def mapa {:first "jedna" :second "dva"})</strong>
&lt;inst pixie.stdlib.Var&gt;
&nbsp;
user =&gt;<strong> (count mapa)</strong>
2
&nbsp;
user =&gt;<strong> (get mapa :first)</strong>
"jedna"
&nbsp;
user =&gt;<strong> (get mapa :blabla)</strong>
nil
&nbsp;
user =&gt;<strong> (:first mapa)</strong>
"jedna"
&nbsp;
user =&gt;<strong> (:foobar mapa)</strong>
nil
</pre>

<p>Další užitečnou funkcí je funkce <strong>into</strong>, která dokáže
převádět prvky mezi různými typy kolekcí. Například následující příklad převede
sekvenci dvojic čísel na mapu, v&nbsp;níž jsou klíčem celá čísla 1 až 9 a
hodnotami druhé mocniny těchto klíčů:</p>

<pre>
user =&gt;<strong> (into {} (for [x (range 1 10)] [x (* x x)]))</strong>
{9 81, 8 64, 1 1, 3 9, 5 25, 2 4, 6 36, 7 49, 4 16}
</pre>



<p><a name="k08"></a></p>
<h2 id="k08">8. Funkce vyššího řádu</h2>

<p>V&nbsp;programovacím jazyku Pixie jsou samozřejmě podporovány i funkce
vyššího řádu, ostatně jedná se o LISPovský jazyk, takže by se nemělo jednat o
velké překvapení. Mezi základní funkce vyššího řádu patří zejména čtveřice
<strong>map</strong>, <strong>apply</strong>, <strong>filter</strong> a
<strong>reduce</strong>. Pojďme si nyní použití těchto funkcí otestovat.</p>

<p>Nejdříve vytvoříme sekvenci, přesněji řečeno speciální typ sekvence, pomocí
funkce <strong>range</strong>:</p>

<pre>
user =&gt;<strong> (def a (range 1 10))</strong>
&lt;inst pixie.stdlib.Var&gt;
user =&gt;<strong> a</strong>
(1 2 3 4 5 6 7 8 9)
user =&gt;<strong> (type a)</strong>
Range
</pre>

<p>Funkce vyššího řádu <strong>reduce</strong> postupně aplikuje předanou
funkci (zde konkrétně funkci +) na akumulovaný mezivýsledek a jednotlivé prvky
sekvence (funkce musí akceptovat dva parametry). Sekvence je tedy postupně
redukována v&nbsp;každé iteraci o jeden prvek:</p>

<pre>
user =&gt;<strong> (reduce + a)</strong>
45
</pre>

<p>Funkce <strong>apply</strong> naproti tomu převezme sekvenci (druhý
parametr) a vytvoří z&nbsp;nich parametry funkce (první parametr). Výsledek
sice bude v&nbsp;tomto případě stejný, ovšem pro jiné funkce to samozřejmě
nemusí být pravda:</p>

<pre>
user =&gt;<strong> (apply + a)</strong>
45
</pre>

<p>Funkce vyššího řádu <strong>map</strong> dokáže pro každý prvek sekvence
zavolat předanou funkci a vytvořit tak novou sekvenci. Zde konkrétně použijeme
anonymní funkci (lambdu), která vynásobí svůj parametr dvěma:</p>

<pre>
user =&gt;<strong> (map #(* % 2) a)</strong>
(2 4 6 8 10 12 14 16 18)
</pre>

<p>Užitečná je i funkce nazvaná <strong>filter</strong>, která z&nbsp;předané
sekvence vybere pouze ty prvky, které odpovídají zadanému <i>predikátu</i>.
Predikátem je libovolná funkce vracející pravdivostní hodnotu
<strong>true</strong> či <strong>false</strong>
(popř.&nbsp;<strong>nil</strong>, který se taktéž chápe jako
<strong>false</strong>). My si vytvoříme nový predikát, kterým bude funkce
testující, zda je parametr liché číslo:</p>

<pre>
user =&gt;<strong> (defn odd [x] (= 1 (rem x 2)))</strong>
&lt;inst pixie.stdlib.Var&gt;
user =&gt;<strong> (odd 1)</strong>
true
user =&gt;<strong> (odd 2)</strong>
false
</pre>

<p>S&nbsp;využitím tohoto predikátu již můžeme z&nbsp;předané sekvence
vyfiltrovat pouze liché prvky:</p>

<pre>
user =&gt;<strong> (filter odd a)</strong>
(1 3 5 7 9)
</pre>

<p>Poslední zajímavou a užitečnou funkcí vyššího řádu je funkce
<strong>take-while</strong>. Tato funkce se podobá funkci
<strong>take</strong>, která z&nbsp;předané sekvence získá prvních <i>n</i>
prvků:</p>

<pre>
<i>; nekonečná sekvence (ve skutečnosti je tato sekvence v jazyku Pixie omezena)</i>
user =&gt;<strong> (def b (range))</strong>
&nbsp;
user =&gt;<strong> (take 10 b)</strong>
(0 1 2 3 4 5 6 7 8 9)
</pre>

<p>Funkce <strong>take-while</strong> namísto hodnoty <i>n</i> očekává
predikát. Dokud predikát vrací hodnotu <strong>true</strong>, budou se prvky ze
vstupní sekvence předávat do sekvence výstupní, při první hodnotě
<strong>false</strong> je funkce ukončena. Tímto způsobem lze například získat
ta celá čísla, jejichž druhá mocnina je menší než 100 popř.&nbsp;1000:</p>

<pre>
user =&gt;<strong> (take-while #(&lt; (* % %) 100) b)</strong>
(0 1 2 3 4 5 6 7 8 9)
user =&gt;<strong> (take-while #(&lt; (* % %) 1000) b)</strong>
(0 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31)
</pre>

<p>Následují typické &bdquo;školní&ldquo; příklady použití funkcí
<strong>apply</strong> a <strong>reduce</strong> pro získání tabulky
faktoriálů:</p>

<pre>
user =&gt;<strong> (doseq [n (range 1 11)] (println n (apply * (range 1 (inc n)))))</strong>
1 1
2 2
3 6
4 24
5 120
6 720
7 5040
8 40320
9 362880
10 3628800
nil
</pre>

<pre>
user =&gt;<strong> (doseq [n (range 1 11)] (println n (reduce * (range 1 (inc n)))))</strong>
1 1
2 2
3 6
4 24
5 120
6 720
7 5040
8 40320
9 362880
10 3628800
nil
</pre>



<p><a name="k09"></a></p>
<h2 id="k09">9. Threading makra</h2>

<p>V&nbsp;programovacím jazyku Clojure existuje dvojice velmi užitečných maker,
která je možné použít pro zjednodušení zápisu &bdquo;kolony&ldquo; funkcí,
kterým se postupně předávají výsledky předchozích funkcí. Jedná se vlastně o
obdobu klasické Unixové kolony používané při spojování filtrů v&nbsp;shellu
(<strong>ls -1 | sort</strong>). V&nbsp;Clojure je možné namísto poměrně
nečitelného zápisu <strong>(f (g (h x)))</strong> použít zápis <strong>(-&gt;x
h g f)</strong>, kterým se specifikuje, že se hodnota <strong>x</strong> předá
funkci <strong>h</strong>, výsledek této funkce se předá funkci
<strong>g</strong> a výsledek funkce <strong>g</strong> se předá funkci
<strong>f</strong>.</p>

<p>Threading makro -&gt; přidá předchozí výsledek další funkci ve svém prvním
parametru:</p>

<pre>
user =&gt;<strong> (def a (range 1 11))</strong>
&lt;inst pixie.stdlib.Var&gt;
&nbsp;
user =&gt;<strong> a</strong>
(1 2 3 4 5 6 7 8 9 10)
&nbsp;
user =&gt;<strong> (-> a count)</strong>
10
&nbsp;
user =&gt;<strong> (-> a count inc)</strong>
11
</pre>

<p>V&nbsp;mnoha případech nám však nemusí vyhovovat, že se předchozí výsledek
předá další funkci v&nbsp;koloně v&nbsp;prvním parametru. Dobrým příkladem
mohou být již výše zmíněné funkce vyššího řádu. Pokud se tyto funkce používají
v&nbsp;koloně, musí se namísto makra -&gt; použít druhé threading makro nazvané
-&gt;&gt;, které předchozí výsledek předá další funkci v&nbsp;posledním
parametru, nikoli v&nbsp;parametru prvním:</p>

<pre>
user =&gt;<strong> (->> a (map #(* % 2)))</strong>
(2 4 6 8 10 12 14 16 18 20)
&nbsp;
user =&gt;<strong> (->> a (map #(* % 2)) (reduce +))</strong>
110
&nbsp;
user =&gt;<strong> (->> a (filter #(&lt; % 5)) (map #(* % 2)))</strong>
(2 4 6 8)
</pre>

<p>Druhý příklad na threading makro -&gt;&gt;, které provede tyto operace:</p>

<ol>
<li>Vytvoří sekvenci deseti hodnot 0..9</li>
<li>Vyfiltruje ze sekvence lichá čísla</li>
<li>Prvky výsledné sekvence 1, 3, .. 9 vynásobí dvěma</li>
</ol>

<pre>
user =&gt;<strong> (defn odd[x] (= 1 (rem x 2)))</strong>
&lt;inst pixie.stdlib.Var&gt;
&nbsp;
user =&gt;<strong> (->> 10 range (filter odd) (map #(* 2 %)))</strong>
(2 6 10 14 18)
</pre>



<p><a name="k10"></a></p>
<h2 id="k10">10. Podpora pro práci se zlomky a čísly s&nbsp;neomezeným rozsahem</h2>

<p>Podobně jako v&nbsp;naprosté většině ostatních LISPovských jazyků nalezneme
i v&nbsp;programovacím jazyku Pixie podporu pro práci se zlomky (které tvoří
samostatný datový typ, interně se jedná o dvojici celých čísel) i podporu pro
práci s&nbsp;celočíselnými hodnotami s&nbsp;prakticky neomezeným rozsahem
(rozsah je samozřejmě omezen kapacitou operační paměti, ovšem
z&nbsp;praktického hlediska lze rozsah považovat za neomezený). Nejprve si
ukažme práci se zlomky, které se zapisují tak, jak jsme zvyklí ze školy (znak
&bdquo;/&ldquo; zde samozřejmě neznamená operátor dělení):</p>

<pre>
user =&gt;<strong> 1/3</strong>
1/3
&nbsp;
user =&gt;<strong> 1/2</strong>
1/2
</pre>

<p>Operace se zlomky se zapisují jednoduše. Povšimněte si, že po každé operaci
se automaticky provede zjednodušení zlomku:</p>

<pre>
user =&gt;<strong> (+ 1/3 1/2)</strong>
5/6
&nbsp;
user =&gt;<strong> (+ 1/2 1/4)</strong>
3/4
&nbsp;
user =&gt;<strong> (* 2 (+ 1/2 1/4))</strong>
3/2
&nbsp;
user =&gt;<strong> (+ 1/2 (* 3/4 (/ 5/6 7/8)))</strong>
17/14
</pre>

<p>Další příklad: kombinace threading makra, konstruktoru sekvence, funkce
vyššího řádu <strong>reduce</strong> a zlomků:</p>

<pre>
user =&gt;<strong> (-&gt;&gt; (repeat 10 3/7) (reduce *))</strong>
59049/282475249
</pre>

<p>Většinu problémů s&nbsp;datovým typem float/double lze tedy velmi snadno
obejít právě použitím zlomků; samozřejmě však nesmíme zapomenout na to, že
výpočty mohou být i řádově pomalejší.</p>

<p>Práce s&nbsp;celými čísly s&nbsp;neomezeným rozsahem je z&nbsp;pohledu
programátora velmi jednoduchá. Jazyk Pixie se ve většině případů dokáže sám
rozhodnout, kdy tento rozsah použít a kdy postačují prostá celá čísla (typu
long integer). Povšimněte si odlišného typu následujících dvou hodnot:</p>

<pre>
user =&gt;<strong> (type 1)</strong>
pixie.stdlib.Integer
&nbsp;
user =&gt;<strong> (type (* 10000000000 1000000000))</strong>
pixie.stdlib.BigInteger
</pre>

<p>Následuje poněkud extrémní příklad použití při výpočtu faktoriálu (namísto
funkce <strong>apply</strong> lze použít i funkci <strong>reduce</strong>):</p>

<pre>
user =&gt;<strong> (type (apply * (range 1 1000)))</strong>
pixie.stdlib.BigInteger
&nbsp;
user =&gt;<strong> (apply * (range 1 1000))</strong>
402387260077093773543702433923003985719374864210714632543799
910429938512398629020592044208486969404800479988610197196058
631666872994808558901323829669944590997424504087073759918823
627727188732519779505950995276120874975462497043601418278094
646496291056393887437886487337119181045825783647849977012476
632889835955735432513185323958463075557409114262417474349347
553428646576611667797396668820291207379143853719588249808126
867838374559731746136085379534524221586593201928090878297308
431392844403281231558611036976801357304216168747609675871348
312025478589320767169132448426236131412508780208000261683151
027341827977704784635868170164365024153691398281264810213092
761244896359928705114964975419909342221566832572080821333186
116811553615836546984046708975602900950537616475847728421889
679646244945160765353408198901385442487984959953319101723355
556602139450399736280750137837615307127761926849034352625200
015888535147331611702103968175921510907788019393178114194545
257223865541461062892187960223838971476088506276862967146674
697562911234082439208160153780889893964518263243671616762179
168909779911903754031274622289988005195444414282012187361745
992642956581746628302955570299024324153181617210465832036786
906117260158783520751516284225540265170483304226143974286933
061690897968482590125458327168226458066526769958652682272807
075781391858178889652208164348344825993266043367660176999612
831860788386150279465955131156552036093988180612138558600301
435694527224206344631797460594682573103790084024432438465657
245014402821885252470935190620929023136493273497565513958720
559654228749774011413346962715422845862377387538230483865688
976461927383814900140767310446640259899490222221765904339901
886018566526485061799702356193897017860040811889729918311021
171229845901641921068884387121855646124960798722908519296819
372388642614839657382291123125024186649353143970137428531926
649875337218940694281434118520158014123344828015051399694290
153483077644569099073152433278288269864602789864321139083506
217095002597389863554277196742822248757586765752344220207573
630569498825087968928162753848863396909959826280956121450994
871701244516461260379029309120889086942028510640182154399457
156805941872748998094254742173582401063677404595741785160829
230135358081840096996372524230560855903700624271243416909004
153690105933983835777939410970027753472000000000000000000000
000000000000000000000000000000000000000000000000000000000000
000000000000000000000000000000000000000000000000000000000000
000000000000000000000000000000000000000000000000000000000000
000000000000000000000000000000000000000000000N
</pre>



<p><a name="k11"></a></p>
<h2 id="k11">11. Práce s&nbsp;atomy</h2>

<p>Programovací jazyk Pixie podporuje práci se dvěma typy symbolů, na nichž
může být navázána hodnota. Pokud se použije deklarace ve stylu:</p>

<pre>
(def Pi 3.1415)
</pre>

<p>je vytvořen symbol, na nějž je navázána konstantní hodnota, kterou nelze
změnit (samozřejmě je možné symbol předefinovat, to však vede
k&nbsp;neidiomatickému kódu). Pokud je zapotřebí pracovat s&nbsp;měnitelnými
proměnnými, lze v&nbsp;jazyku Pixie použít takzvané <i>atomy</i>, které mají
k&nbsp;proměnným pravděpodobně nejblíže. Zatímco však běžné proměnné může měnit
jakékoli vlákno bez další koordinace s&nbsp;ostatními vlákny, jsou hodnoty
atomů modifikovány &bdquo;atomicky&ldquo; &ndash; ostatní vlákna uvidí buď
starou hodnotu nebo hodnotu novou, nikdy ne výsledek nějakého mezivýpočtu.</p>

<p>Práce s&nbsp;atomy je v&nbsp;praxi velmi jednoduchá, protože si programátor
vystačí se čtveřicí funkcí, k&nbsp;nimž můžeme připočíst ještě jedno makro
preprocesoru. Všechny čtyři zmíněné funkce můžeme nalézt v&nbsp;následující
tabulce:</p>

<table>
<tr><th>#</th><th>Funkce</th><th>Význam</th></tr>
<tr><td>1</td><td>atom</td><td>vytvoření reference typu atom</td></tr>
<tr><td>2</td><td>deref</td><td>dereference, vrátí se stav identity</td></tr>
<tr><td>3</td><td>reset!</td><td>atomická změna stavu identity na zvolenou hodnotu</td></tr>
<tr><td>4</td><td>swap!</td><td>atomická změna stavu identity zavoláním zvolené funkce</td></tr>
</table>

<p>Atomy se vytváří pomocí funkce <strong>atom</strong>, které lze předat
počáteční (inicializační) hodnotu:</p>

<pre>
<i>; vytvoření nového atomu</i>
user =&gt;<strong> (def i (atom 1))</strong>
&lt;inst pixie.stdlib.Var&gt;
&nbsp;
<i>; globální symbol i je navázán</i>
<i>; na atom a nikoli na stav identity</i>
<i>; (=hodnotu)</i>
user =&gt;<strong> i</strong>
&lt;inst pixie.stdlib.Atom&gt;
&nbsp;
<i>; pro jistotu zkontrolujeme typ objektu</i>
user =&gt;<strong> (type i)</strong>
pixie.stdlib.Atom
</pre>

<p>Způsob přečtení hodnoty:</p>

<pre>
<i>; pro získání aktuálního stavu</i>
<i>; je nutné použít dereferenci</i>
user =&gt;<strong> (deref i)</strong>
1
&nbsp;
<i>; namísto (deref x) se používá</i>
<i>; makro preprocesoru @</i>
user =&gt;<strong> @i</strong>
1
</pre>

<p></p>

<pre>
<i>; atomická změna stavu identity</i>
user =&gt;<strong> (reset! i 42)</strong>
42
&nbsp;
<i>; další možnost atomické změny</i>
<i>; stavu identity - nyní přes funkci</i>
<i>; aplikovanou na atom a popř. i další</i>
<i>; parametry</i>
user =&gt;<strong> (swap! i inc)</strong>
43
&nbsp;
<i>; samozřejmě lze použít i anonymní funkci</i>
user =&gt;<strong> (swap! i #(* % %))</strong>
1849
</pre>



<p><a name="k12"></a></p>
<h2 id="k12">12. Atomy a strukturované datové typy</h2>

<p>Do atomů se samozřejmě nemusí ukládat jen číselné hodnoty, ale je možné
použít i všechny podporované strukturované datové typy neboli kolekce.
V&nbsp;dalším příkladu si ukážeme, jak je možné implementovat měnitelnou
(<i>mutable</i>) mapu:</p>

<pre>
<i>; vytvoření prázdné mapy (ta je sama o sobě immutable) a její uložení do atomu</i>
user =&gt;<strong> (def m (atom {}))</strong>
&lt;inst pixie.stdlib.Var&gt;
&nbsp;
<i>; použití funkce swap! a assoc, funkce assoc vrátí novou mapu s přidaným prvkem</i>
user =&gt;<strong> (swap! m assoc :first "prvni")</strong>
{:first "prvni"}
&nbsp;
<i>; dereference hodnoty uložené do atomu s využitím makra @</i>
user =&gt;<strong> @m</strong>
{:first "prvni"}
&nbsp;
<i>; přidání dalšího prvku do mapy</i>
user =&gt;<strong> (swap! m assoc :second "druhy")</strong>
{:first "prvni", :second "druhy"}
&nbsp;
<i>; přidání třetího prvku do mapy</i>
user =&gt;<strong> (swap! m assoc :third "treti")</strong>
{:first "prvni", :third "treti", :second "druhy"}
&nbsp;
<i>; odstranění dvou prvků specifikovaných svým klíčem z mapy</i>
user =&gt;<strong> (swap! m dissoc :first :second)</strong>
{:third "treti"}
</pre>



<p><a name="k13"></a></p>
<h2 id="k13">13. Odkazy na předchozí části tohoto seriálu</h2>

<ol>

<li>Clojure  1: Úvod<br />
<a href="http://www.root.cz/clanky/clojure-aneb-jazyk-umoznujici-tvorbu-bezpecnych-vicevlaknovych-aplikaci-pro-jvm/">http://www.root.cz/clanky/clojure-aneb-jazyk-umoznujici-tvorbu-bezpecnych-vicevlaknovych-aplikaci-pro-jvm/</a>
</li>

<li>Clojure  2: Symboly, kolekce atd.<br />
<a href="http://www.root.cz/clanky/clojure-aneb-jazyk-umoznujici-tvorbu-bezpecnych-vicevlaknovych-aplikaci-pro-jvm-2-cast/">http://www.root.cz/clanky/clojure-aneb-jazyk-umoznujici-tvorbu-bezpecnych-vicevlaknovych-aplikaci-pro-jvm-2-cast/</a>
</li>

<li>Clojure  3: Funkcionální programování<br />
<a href="http://www.root.cz/clanky/clojure-aneb-jazyk-umoznujici-tvorbu-bezpecnych-vicevlaknovych-aplikaci-pro-jvm-3-cast-funkcionalni-programovani/">http://www.root.cz/clanky/clojure-aneb-jazyk-umoznujici-tvorbu-bezpecnych-vicevlaknovych-aplikaci-pro-jvm-3-cast-funkcionalni-programovani/</a>
</li>

<li>Clojure  4: Kolekce, sekvence a lazy sekvence<br />
<a href="http://www.root.cz/clanky/clojure-aneb-jazyk-umoznujici-tvorbu-bezpecnych-vicevlaknovych-aplikaci-pro-jvm-4-cast-kolekce-sekvence-a-lazy-sekvence/">http://www.root.cz/clanky/clojure-aneb-jazyk-umoznujici-tvorbu-bezpecnych-vicevlaknovych-aplikaci-pro-jvm-4-cast-kolekce-sekvence-a-lazy-sekvence/</a>
</li>

<li>Clojure  5: Sekvence, lazy sekvence a paralelní programy<br />
<a href="http://www.root.cz/clanky/clojure-a-bezpecne-aplikace-pro-jvm-sekvence-lazy-sekvence-a-paralelni-programy/">http://www.root.cz/clanky/clojure-a-bezpecne-aplikace-pro-jvm-sekvence-lazy-sekvence-a-paralelni-programy/</a>
</li>

<li>Clojure  6: Podpora pro paralelní programování<br />
<a href="http://www.root.cz/clanky/programovaci-jazyk-clojure-6-futures-nejsou-jen-financni-derivaty/">http://www.root.cz/clanky/programovaci-jazyk-clojure-6-futures-nejsou-jen-financni-derivaty/</a>
</li>

<li>Clojure  7: Další funkce pro paralelní programování<br />
<a href="http://www.root.cz/clanky/programovaci-jazyk-clojure-7-dalsi-podpurne-prostredky-pro-paralelni-programovani/">http://www.root.cz/clanky/programovaci-jazyk-clojure-7-dalsi-podpurne-prostredky-pro-paralelni-programovani/</a>
</li>

<li>Clojure  8: Identity, stavy, neměnné hodnoty a reference<br />
<a href="http://www.root.cz/clanky/programovaci-jazyk-clojure-8-identity-stavy-nemenne-hodnoty-a-referencni-typy/">http://www.root.cz/clanky/programovaci-jazyk-clojure-8-identity-stavy-nemenne-hodnoty-a-referencni-typy/</a>
</li>

<li>Clojure  9: Validátory, pozorovatelé a kooperace s Javou<br />
<a href="http://www.root.cz/clanky/programovaci-jazyk-clojure-9-validatory-pozorovatele-a-kooperace-mezi-clojure-a-javou/">http://www.root.cz/clanky/programovaci-jazyk-clojure-9-validatory-pozorovatele-a-kooperace-mezi-clojure-a-javou/</a>
</li>

<li>Clojure 10: Kooperace mezi Clojure a Javou<br />
<a href="http://www.root.cz/clanky/programovaci-jazyk-clojure-10-kooperace-mezi-clojure-a-javou-pokracovani/">http://www.root.cz/clanky/programovaci-jazyk-clojure-10-kooperace-mezi-clojure-a-javou-pokracovani/</a>
</li>

<li>Clojure 11: Generátorová notace seznamu/list comprehension<br />
<a href="http://www.root.cz/clanky/programovaci-jazyk-clojure-11-generatorova-notace-seznamu-list-comprehension/">http://www.root.cz/clanky/programovaci-jazyk-clojure-11-generatorova-notace-seznamu-list-comprehension/</a>
</li>

<li>Clojure 12: Překlad programů z Clojure do bajtkódu JVM I:<br />
<a href="http://www.root.cz/clanky/programovaci-jazyk-clojure-12-preklad-programu-z-clojure-do-bajtkodu-jvm/">http://www.root.cz/clanky/programovaci-jazyk-clojure-12-preklad-programu-z-clojure-do-bajtkodu-jvm/</a>
</li>

<li>Clojure 13: Překlad programů z Clojure do bajtkódu JVM II:<br />
<a href="http://www.root.cz/clanky/programovaci-jazyk-clojure-13-preklad-programu-z-clojure-do-bajtkodu-jvm-pokracovani/">http://www.root.cz/clanky/programovaci-jazyk-clojure-13-preklad-programu-z-clojure-do-bajtkodu-jvm-pokracovani/</a>
</li>

<li>Clojure 14: Základy práce se systémem maker<br />
<a href="http://www.root.cz/clanky/programovaci-jazyk-clojure-14-zaklady-prace-se-systemem-maker/">http://www.root.cz/clanky/programovaci-jazyk-clojure-14-zaklady-prace-se-systemem-maker/</a>
</li>

<li>Clojure 15: Tvorba uživatelských maker<br />
<a href="http://www.root.cz/clanky/programovaci-jazyk-clojure-15-tvorba-uzivatelskych-maker/">http://www.root.cz/clanky/programovaci-jazyk-clojure-15-tvorba-uzivatelskych-maker/</a>
</li>

<li>Clojure 16: Složitější uživatelská makra<br />
<a href="http://www.root.cz/clanky/programovaci-jazyk-clojure-16-slozitejsi-uzivatelska-makra/">http://www.root.cz/clanky/programovaci-jazyk-clojure-16-slozitejsi-uzivatelska-makra/</a>
</li>

<li>Clojure 17: Využití standardních maker v praxi<br />
<a href="http://www.root.cz/clanky/programovaci-jazyk-clojure-17-vyuziti-standardnich-maker-v-praxi/">http://www.root.cz/clanky/programovaci-jazyk-clojure-17-vyuziti-standardnich-maker-v-praxi/</a>
</li>

<li>Clojure 18: Základní techniky optimalizace aplikací<br />
<a href="http://www.root.cz/clanky/programovaci-jazyk-clojure-18-zakladni-techniky-optimalizace-aplikaci/">http://www.root.cz/clanky/programovaci-jazyk-clojure-18-zakladni-techniky-optimalizace-aplikaci/</a>
</li>

<li>Clojure 19: Vývojová prostředí pro Clojure<br />
<a href="http://www.root.cz/clanky/programovaci-jazyk-clojure-19-vyvojova-prostredi-pro-clojure/">http://www.root.cz/clanky/programovaci-jazyk-clojure-19-vyvojova-prostredi-pro-clojure/</a>
</li>

<li>Clojure 20: Vývojová prostředí pro Clojure (Vimu s REPL)<br />
<a href="http://www.root.cz/clanky/programovaci-jazyk-clojure-20-vyvojova-prostredi-pro-clojure-integrace-vimu-s-repl/">http://www.root.cz/clanky/programovaci-jazyk-clojure-20-vyvojova-prostredi-pro-clojure-integrace-vimu-s-repl/</a>
</li>

<li>Clojure 21: ClojureScript aneb překlad Clojure do JS<br />
<a href="http://www.root.cz/clanky/programovaci-jazyk-clojure-21-clojurescript-aneb-preklad-clojure-do-javascriptu/">http://www.root.cz/clanky/programovaci-jazyk-clojure-21-clojurescript-aneb-preklad-clojure-do-javascriptu/</a>
</li>

<li>Leiningen: nástroj pro správu projektů napsaných v Clojure<br />
<a href="http://www.root.cz/clanky/leiningen-nastroj-pro-spravu-projektu-napsanych-v-clojure/">http://www.root.cz/clanky/leiningen-nastroj-pro-spravu-projektu-napsanych-v-clojure/</a>
</li>

<li>Leiningen: nástroj pro správu projektů napsaných v Clojure (2)<br />
<a href="http://www.root.cz/clanky/leiningen-nastroj-pro-spravu-projektu-napsanych-v-clojure-2/">http://www.root.cz/clanky/leiningen-nastroj-pro-spravu-projektu-napsanych-v-clojure-2/</a>
</li>

<li>Leiningen: nástroj pro správu projektů napsaných v Clojure (3)<br />
<a href="http://www.root.cz/clanky/leiningen-nastroj-pro-spravu-projektu-napsanych-v-clojure-3/">http://www.root.cz/clanky/leiningen-nastroj-pro-spravu-projektu-napsanych-v-clojure-3/</a>
</li>

<li>Leiningen: nástroj pro správu projektů napsaných v Clojure (4)<br />
<a href="http://www.root.cz/clanky/leiningen-nastroj-pro-spravu-projektu-napsanych-v-clojure-4/">http://www.root.cz/clanky/leiningen-nastroj-pro-spravu-projektu-napsanych-v-clojure-4/</a>
</li>

<li>Leiningen: nástroj pro správu projektů napsaných v Clojure (5)<br />
<a href="http://www.root.cz/clanky/leiningen-nastroj-pro-spravu-projektu-napsanych-v-clojure-5/">http://www.root.cz/clanky/leiningen-nastroj-pro-spravu-projektu-napsanych-v-clojure-5/</a>
</li>

<li>Leiningen: nástroj pro správu projektů napsaných v Clojure (6)<br />
<a href="http://www.root.cz/clanky/leiningen-nastroj-pro-spravu-projektu-napsanych-v-clojure-6/">http://www.root.cz/clanky/leiningen-nastroj-pro-spravu-projektu-napsanych-v-clojure-6/</a>
</li>

<li>Programovací jazyk Clojure a databáze (1.část)<br />
<a href="http://www.root.cz/clanky/programovaci-jazyk-clojure-a-databaze-1-cast/">http://www.root.cz/clanky/programovaci-jazyk-clojure-a-databaze-1-cast/</a>
</li>

<li>Pluginy pro Leiningen<br />
<a href="http://www.root.cz/clanky/leiningen-nastroj-pro-spravu-projektu-napsanych-v-clojure-pluginy-pro-leiningen/">http://www.root.cz/clanky/leiningen-nastroj-pro-spravu-projektu-napsanych-v-clojure-pluginy-pro-leiningen/</a>
</li>

<li>Programovací jazyk Clojure a knihovny pro práci s vektory a maticemi<br />
<a href="http://www.root.cz/clanky/programovaci-jazyk-clojure-a-knihovny-pro-praci-s-vektory-a-maticemi/">http://www.root.cz/clanky/programovaci-jazyk-clojure-a-knihovny-pro-praci-s-vektory-a-maticemi/</a>
</li>

<li>Programovací jazyk Clojure a knihovny pro práci s vektory a maticemi (2)<br />
<a href="http://www.root.cz/clanky/programovaci-jazyk-clojure-a-knihovny-pro-praci-s-vektory-a-maticemi-2/">http://www.root.cz/clanky/programovaci-jazyk-clojure-a-knihovny-pro-praci-s-vektory-a-maticemi-2/</a>
</li>

<li>Programovací jazyk Clojure: syntéza procedurálních textur s využitím knihovny Clisk<br />
<a href="http://www.root.cz/clanky/programovaci-jazyk-clojure-synteza-proceduralnich-textur-s-vyuzitim-knihovny-clisk/">http://www.root.cz/clanky/programovaci-jazyk-clojure-synteza-proceduralnich-textur-s-vyuzitim-knihovny-clisk/</a>
</li>

<li>Programovací jazyk Clojure: syntéza procedurálních textur s využitím knihovny Clisk (2)<br />
<a href="http://www.root.cz/clanky/programovaci-jazyk-clojure-synteza-proceduralnich-textur-s-vyuzitim-knihovny-clisk-2/">http://www.root.cz/clanky/programovaci-jazyk-clojure-synteza-proceduralnich-textur-s-vyuzitim-knihovny-clisk-2/</a>
</li>

<li>Seesaw: knihovna pro snadnou tvorbu GUI v jazyce Clojure<br />
<a href="http://www.root.cz/clanky/seesaw-knihovna-pro-snadnou-tvorbu-gui-v-jazyce-clojure/">http://www.root.cz/clanky/seesaw-knihovna-pro-snadnou-tvorbu-gui-v-jazyce-clojure/</a>
</li>

<li>Seesaw: knihovna pro snadnou tvorbu GUI v jazyce Clojure (2)<br />
<a href="http://www.root.cz/clanky/seesaw-knihovna-pro-snadnou-tvorbu-gui-v-jazyce-clojure-2/">http://www.root.cz/clanky/seesaw-knihovna-pro-snadnou-tvorbu-gui-v-jazyce-clojure-2/</a>
</li>

<li>Seesaw: knihovna pro snadnou tvorbu GUI v jazyce Clojure (3)<br />
<a href="http://www.root.cz/clanky/seesaw-knihovna-pro-snadnou-tvorbu-gui-v-jazyce-clojure-3/">http://www.root.cz/clanky/seesaw-knihovna-pro-snadnou-tvorbu-gui-v-jazyce-clojure-3/</a>
</li>

<li>Programovací jazyk Clojure a práce s Gitem<br />
<a href="http://www.root.cz/clanky/programovaci-jazyk-clojure-a-prace-s-gitem/">http://www.root.cz/clanky/programovaci-jazyk-clojure-a-prace-s-gitem/</a>
</li>

<li>Programovací jazyk Clojure: syntéza procedurálních textur s využitím knihovny Clisk (dokončení)<br />
<a href="http://www.root.cz/clanky/programovaci-jazyk-clojure-synteza-proceduralnich-textur-s-vyuzitim-knihovny-clisk-dokonceni/">http://www.root.cz/clanky/programovaci-jazyk-clojure-synteza-proceduralnich-textur-s-vyuzitim-knihovny-clisk-dokonceni/</a>
</li>

<li>Programovací jazyk Clojure a práce s Gitem (2)<br />
<a href="http://www.root.cz/clanky/programovaci-jazyk-clojure-a-prace-s-gitem-2/">http://www.root.cz/clanky/programovaci-jazyk-clojure-a-prace-s-gitem-2/</a>
</li>

<li>Programovací jazyk Clojure – triky při práci s řetězci<br />
<a href="http://www.root.cz/clanky/programovaci-jazyk-clojure-triky-pri-praci-s-retezci/">http://www.root.cz/clanky/programovaci-jazyk-clojure-triky-pri-praci-s-retezci/</a>
</li>

<li>Programovací jazyk Clojure – triky při práci s kolekcemi<br />
<a href="http://www.root.cz/clanky/programovaci-jazyk-clojure-triky-pri-praci-s-kolekcemi/">http://www.root.cz/clanky/programovaci-jazyk-clojure-triky-pri-praci-s-kolekcemi/</a>
</li>

<li>Programovací jazyk Clojure – práce s mapami a množinami<br />
<a href="http://www.root.cz/clanky/programovaci-jazyk-clojure-prace-s-mapami-a-mnozinami/">http://www.root.cz/clanky/programovaci-jazyk-clojure-prace-s-mapami-a-mnozinami/</a>
</li>

<li>Programovací jazyk Clojure – základy zpracování XML<br />
<a href="http://www.root.cz/clanky/programovaci-jazyk-clojure-zaklady-zpracovani-xml/">http://www.root.cz/clanky/programovaci-jazyk-clojure-zaklady-zpracovani-xml/</a>
</li>

<li>Programovací jazyk Clojure – testování s využitím knihovny Expectations<br />
<a href="http://www.root.cz/clanky/programovaci-jazyk-clojure-testovani-s-vyuzitim-knihovny-expectations/">http://www.root.cz/clanky/programovaci-jazyk-clojure-testovani-s-vyuzitim-knihovny-expectations/</a>
</li>

<li>Programovací jazyk Clojure – některé užitečné triky použitelné (nejenom) v&nbsp;testech<br />
<a href="http://www.root.cz/clanky/programovaci-jazyk-clojure-nektere-uzitecne-triky-pouzitelne-nejenom-v-testech/">http://www.root.cz/clanky/programovaci-jazyk-clojure-nektere-uzitecne-triky-pouzitelne-nejenom-v-testech/</a>
</li>

<li>Enlive – výkonný šablonovací systém pro jazyk Clojure<br/>
<a href="http://www.root.cz/clanky/enlive-vykonny-sablonovaci-system-pro-jazyk-clojure/">http://www.root.cz/clanky/enlive-vykonny-sablonovaci-system-pro-jazyk-clojure/</a>
</li>

<li>Nástroj Leiningen a programovací jazyk Clojure: tvorba vlastních knihoven pro veřejný repositář Clojars<br />
<a href="http://www.root.cz/clanky/nastroj-leiningen-a-programovaci-jazyk-clojure-tvorba-vlastnich-knihoven-pro-verejny-repositar-clojars/">http://www.root.cz/clanky/nastroj-leiningen-a-programovaci-jazyk-clojure-tvorba-vlastnich-knihoven-pro-verejny-repositar-clojars/</a>
</li>

<li>Novinky v Clojure verze 1.8.0<br />
<a href="http://www.root.cz/clanky/novinky-v-clojure-verze-1-8-0/">http://www.root.cz/clanky/novinky-v-clojure-verze-1-8-0/</a>
</li>

<li>Asynchronní programování v&nbsp;Clojure s&nbsp;využitím knihovny core.async<br />
<a href="http://www.root.cz/clanky/asynchronni-programovani-v-clojure-s-vyuzitim-knihovny-core-async/">http://www.root.cz/clanky/asynchronni-programovani-v-clojure-s-vyuzitim-knihovny-core-async/</a>
</li>

<li>Asynchronní programování v&nbsp;Clojure s&nbsp;využitím knihovny core.async (pokračování)<br />
<a href="http://www.root.cz/clanky/asynchronni-programovani-v-clojure-s-vyuzitim-knihovny-core-async-pokracovani/">http://www.root.cz/clanky/asynchronni-programovani-v-clojure-s-vyuzitim-knihovny-core-async-pokracovani/</a>
</li>

<li>Asynchronní programování v Clojure s využitím knihovny core.async (dokončení)<br />
<a href="http://www.root.cz/clanky/asynchronni-programovani-v-clojure-s-vyuzitim-knihovny-core-async-dokonceni/">http://www.root.cz/clanky/asynchronni-programovani-v-clojure-s-vyuzitim-knihovny-core-async-dokonceni/</a>
</li>

<li>Vytváříme IRC bota v programovacím jazyce Clojure<br />
<a href="http://www.root.cz/clanky/vytvarime-irc-bota-v-programovacim-jazyce-clojure/">http://www.root.cz/clanky/vytvarime-irc-bota-v-programovacim-jazyce-clojure/</a>
</li>

<li>Gorilla REPL: interaktivní prostředí pro programovací jazyk Clojure<br />
<a href="https://www.root.cz/clanky/gorilla-repl-interaktivni-prostredi-pro-programovaci-jazyk-clojure/">https://www.root.cz/clanky/gorilla-repl-interaktivni-prostredi-pro-programovaci-jazyk-clojure/</a>
</li>

<li>Multimetody v Clojure aneb polymorfismus bez použití OOP<br />
<a href="https://www.root.cz/clanky/multimetody-v-clojure-aneb-polymorfismus-bez-pouziti-oop/">https://www.root.cz/clanky/multimetody-v-clojure-aneb-polymorfismus-bez-pouziti-oop/</a>
</li>

<li>Práce s externími Java archivy v programovacím jazyku Clojure<br />
<a href="https://www.root.cz/clanky/prace-s-externimi-java-archivy-v-programovacim-jazyku-clojure/">https://www.root.cz/clanky/prace-s-externimi-java-archivy-v-programovacim-jazyku-clojure/</a>
</li>

</ol>



<p><a name="k14"></a></p>
<h2 id="k14">14. Odkazy na Internetu</h2>

<ol>

<li>Pixie (repositář na GitHubu)<br />
<a href="https://github.com/pixie-lang/pixie">https://github.com/pixie-lang/pixie</a>
</li>

<li>Pixie Installation<br />
<a href="https://github.com/pixie-lang/pixie/wiki/Installation">https://github.com/pixie-lang/pixie/wiki/Installation</a>
</li>

<li>Pixie Libraries<br />
<a href="https://github.com/pixie-lang/pixie/wiki/Libraries">https://github.com/pixie-lang/pixie/wiki/Libraries</a>
</li>

<li>Interview with Timothy Baldridge, Pixie's language creator<br />
<a href="https://notamonadtutorial.com/indie-languages-interview-pixie-and-timothy-baldridge-cadbc36418dc#.vhbl5rp1c">https://notamonadtutorial.com/indie-languages-interview-pixie-and-timothy-baldridge-cadbc36418dc#.vhbl5rp1c</a>
</li>

<li>Pixie (programming language) [Wikipedia]<br />
<a href="https://en.wikipedia.org/wiki/Pixie_%28programming_language%29">https://en.wikipedia.org/wiki/Pixie_%28programming_language%29</a>
</li>

<li>Clojure home page<br />
<a href="http://clojure.org/">http://clojure.org/</a>
</li>

<li>Clojure (downloads)<br />
<a href="http://clojure.org/downloads">http://clojure.org/downloads</a>
</li>

<li>Clojure - Functional Programming for the JVM<br />
<a href="http://java.ociweb.com/mark/clojure/article.html">http://java.ociweb.com/mark/clojure/article.html</a>
</li>

<li>Clojure quick reference<br />
<a href="http://faustus.webatu.com/clj-quick-ref.html">http://faustus.webatu.com/clj-quick-ref.html</a>
</li>

<li>4Clojure<br />
<a href="http://www.4clojure.com/">http://www.4clojure.com/</a>
</li>

<li>ClojureDoc (rozcestník s&nbsp;dokumentací jazyka Clojure)<br />
<a href="http://clojuredocs.org/">http://clojuredocs.org/</a>
</li>

<li>Clojure (na Wikipedia EN)<br />
<a href="http://en.wikipedia.org/wiki/Clojure">http://en.wikipedia.org/wiki/Clojure</a>
</li>

<li>Clojure (na Wikipedia CS)<br />
<a href="http://cs.wikipedia.org/wiki/Clojure">http://cs.wikipedia.org/wiki/Clojure</a>
</li>

<li>Clojars:<br />
<a href="https://clojars.org/">https://clojars.org/</a>
</li>

<li>Seznam knihoven na Clojars:<br />
<a href="https://clojars.org/projects">https://clojars.org/projects</a>
</li>

<li>Zip archiv s&nbsp;Clojure 1.8.0<br />
<a href="http://repo1.maven.org/maven2/org/clojure/clojure/1.8.0/clojure-1.8.0.zip">http://repo1.maven.org/maven2/org/clojure/clojure/1.8.0/clojure-1.8.0.zip</a>
</li>

<li>Clojure 1.8 is now available<br />
<a href="http://clojure.org/news/2016/01/19/clojure18">http://clojure.org/news/2016/01/19/clojure18</a>
</li>

<li>Changes to Clojure in Version 1.8<br />
<a href="https://github.com/clojure/clojure/blob/master/changes.md">https://github.com/clojure/clojure/blob/master/changes.md</a>
</li>

<li>Clojure core.async<br />
<a href="http://www.infoq.com/presentations/clojure-core-async">http://www.infoq.com/presentations/clojure-core-async</a>
</li>

<li>core.async API Reference<br />
<a href="https://clojure.github.io/core.async/">https://clojure.github.io/core.async/</a>
</li>

<li>Clojure core.async Channels<br />
<a href="http://clojure.com/blog/2013/06/28/clojure-core-async-channels.html">http://clojure.com/blog/2013/06/28/clojure-core-async-channels.html</a>
</li>

<li>core.async examples<br />
<a href="https://github.com/clojure/core.async/blob/master/examples/walkthrough.clj">https://github.com/clojure/core.async/blob/master/examples/walkthrough.clj</a>
</li>

<li>Timothy Baldridge - Core.Async<br />
<a href="https://www.youtube.com/watch?v=enwIIGzhahw">https://www.youtube.com/watch?v=enwIIGzhahw</a>
</li>

</ol>



<p></p><p></p>
<p><small>Autor: <a href="http://www.fit.vutbr.cz/~tisnovpa">Pavel Tišnovský</a> &nbsp; 2016</small></p>
</body>
</html>

