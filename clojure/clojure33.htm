<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
        "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html>
<head>
<title>Vytváříme IRC bota v programovacím jazyce Clojure</title>
<meta name="Author" content="Pavel Tisnovsky" />
<meta name="Generator" content="vim" />
<meta http-equiv="content-type" content="text/html; charset=utf-8" />
<style type="text/css">
         body {color:#000000; background:#ffffff;}
         h1  {font-family: arial, helvetica, sans-serif; color:#ffffff; background-color:#c00000; text-align:center; padding-left:1em}
         h2  {font-family: arial, helvetica, sans-serif; color:#ffffff; background-color:#0000c0; padding-left:1em; text-align:left}
         h3  {font-family: arial, helvetica, sans-serif; color:#000000; background-color:#c0c0c0; padding-left:1em; text-align:left}
         h4  {font-family: arial, helvetica, sans-serif; color:#000000; background-color:#e0e0e0; padding-left:1em; text-align:left}
         a   {font-family: arial, helvetica, sans-serif;}
         li  {font-family: arial, helvetica, sans-serif; color:#000000; text-align:justify; width:450px;}
         ol  {font-family: arial, helvetica, sans-serif; color:#000000; text-align:justify; width:450px;}
         ul  {font-family: arial, helvetica, sans-serif; color:#000000; text-align:justify; width:450px;}
         p   {font-family: arial, helvetica, sans-serif; color:#000000; text-align:justify;}
         pre {background:#e0e0e0}
</style>
</head>

<body>

<h1>Vytváříme IRC bota v programovacím jazyce Clojure</h1>

<h3>Pavel Tišnovský</h3>

<p></p>

<h1>Úvodník</h1>

<p>Dnešní část seriálu o programovacím jazyce Clojure bude zaměřena více prakticky, než předchozí tři části, protože si ukážeme, jakým způsobem je možné vytvořit jednoduchého IRC bota, a to s využitím knihovny nazvané irclj.</p>



<h2>Obsah</h2>

<p><a href="#k01">1. Vytváříme IRC bota v&nbsp;programovacím jazyce Clojure</a></p>
<p><a href="#k02">2. Knihovna <strong>irclj</strong></a></p>
<p><a href="#k03">3. Připojení IRC bota k&nbsp;serveru</a></p>
<p><a href="#k04">4. Příjem zprávy a generování odpovědi</a></p>
<p><a href="#k05">5. Demonstrační příklad <strong>ircbot1</strong>: první jednoduchá varianta IRC bota</a></p>
<p><a href="#k06">6. Rozhodnutí, zda zpráva přišla z&nbsp;kanálu nebo v&nbsp;soukromém chatu a zda jde o zprávu pro bota</a></p>
<p><a href="#k07">7. Druhý demonstrační příklad <strong>ircbot2</strong>: odpovídání na zprávy určené pouze botovi</a></p>
<p><a href="#k08">8. Rozpoznání dotazu, parsing čísla, výpočet faktoriálu</a></p>
<p><a href="#k09">9. Třetí demonstrační příklad <strong>ircbot3</strong>: výpočet faktoriálu (smysluplná odpověď)</a></p>
<p><a href="#k10">10. Odpověď tazateli na kanálu a přímá odpověď v&nbsp;soukromém chatu</a></p>
<p><a href="#k11">11. Čtvrtý demonstrační příklad <strong>ircbot4</strong>: rozpoznání jména bota, odpověď přímo tazateli atd.</a></p>
<p><a href="#k12">12. Repositář s&nbsp;demonstračními příklady</a></p>
<p><a href="#k13">13. Odkazy na předchozí části tohoto seriálu</a></p>
<p><a href="#k14">14. Odkazy na Internetu</a></p>



<p><a name="k01"></a></p>
<h2 id="k01">1. Vytváříme IRC bota v&nbsp;programovacím jazyce Clojure</h2>

<p>V&nbsp;seriálu o programovacím jazyce <i>Clojure</i> jsme se již seznámili
s&nbsp;mnoha knihovnami, které je možné použít jak pro tvorbu serverových
aplikací, tak i pro aplikace provozované na desktopech či na vývojářských
strojích. Připomeňme si jen ve stručnosti, že jsme se zabývali popisem knihoven
<i>Clisk</i> (generování procedurální grafiky), <i>Enlive</i> (šablonovací
systém pro HTML a XML), <i>Codox</i> (generování dokumentace ke zdrojovým kódům
projektů), <i>Cloverage</i> (zjištění pokrytí programového kódu jednotkovými
testy), <i>Clj-Git</i> (rozhraní ke GITu), <i>core.matrix</i> (efektivní práce
s&nbsp;vektory a maticemi), <i>Seesaw</i> (funkcionálně pojaté rozhraní ke
Swingu), <i>Clojure Ring</i> (webový server, opět s&nbsp;funkcionálními rysy),
<i>Hiccup</i> (překladač z&nbsp;Clojure do HTML) a taktéž s&nbsp;knihovnou
<i>core.async</i> (podpora pro asynchronní programování). Dnes si řekneme
základní informace o užitečné knihovně <i>irclj</i>, kterou lze použít pro
tvorbu takzvaných IRC botů.</p>

<p><i>IRC</i> neboli <i>Internet Relay Chat</i> je jednou z&nbsp;prvních
Internetových služeb sloužících pro komunikaci v&nbsp;reálném čase (jinými
slovy pro chatování). <i>IRC</i> vznikl již v&nbsp;roce 1988, a to konkrétně ve
Finském akademickém prostředí. I přes vznik různých dalších podobně zaměřených
služeb (asi nejznámější je XMPP/Jabber, dříve ICQ apod.) se <i>IRC</i> stále
používá a populární je zejména mezi vývojáři. Jedním z&nbsp;fenoménů, které
službu <i>IRC</i> provázejí už prakticky od začátku, jsou takzvaní
&bdquo;boti&ldquo;, což jsou programy, které mohou komunikovat s&nbsp;uživateli
(nebo i s&nbsp;jinými boty) pomocí textových zpráv. Implementace botů není
příliš složitá, protože i samotný protokol používaný službou IRC je poměrně
jednoduchý (posílat zprávy lze i přes pouhý netcat). Boti se používají jak pro
zábavu, tak i pro vážnější služby; ostatně na kanálu <strong>#clojure</strong>
na serveru <strong>irc.freenode.net</strong> nalezneme bota, který dokáže
interpretovat výrazy zapsané v&nbsp;Clojure, odkazovat na dokumentaci či
trousit poznámky o některých ne zcela podařených programátorských obratech
(tento kanál mimochodem navštěvuje hodně známých programátorů z&nbsp;komunity
nejenom okolo jazyka Clojure).</p>



<p><a name="k02"></a></p>
<h2 id="k02">2. Knihovna <strong>irclj</strong></h2>

<p>IRC boty je možné naprogramovat prakticky v&nbsp;jakémkoli programovacím
jazyce. Přitom je zajímavé, že mnoho botů bylo vytvořeno v&nbsp;Perlu, a to
pravděpodobně z&nbsp;toho důvodu, že Perl byl na konci minulého tisíciletí ve
vývojářské komunitě populární a navíc poskytoval a samozřejmě dodnes poskytuje
prostředky pro snadnou manipulaci s&nbsp;textem, tj.&nbsp;i s&nbsp;textovými
zprávami, které jsou přes IRC přenášeny. My se však v&nbsp;tomto článku
samozřejmě zaměříme na programovací jazyk Clojure, pro nějž již vzniklo hned
několik knihoven pro práci s&nbsp;IRC. Knihovna nazvaná <i>irclj</i>, kterou
dnes použijeme, je z&nbsp;praktického pohledu zajímavá tím, že je velmi snadno
použitelná (podobně jako již popsaná knihovna <i>Clojure Ring</i>) a navíc je
možné případného IRC bota rozšiřovat o další funkce. Celý bot může být
naprogramován funkcionálním stylem, což zde konkrétně znamená, že v&nbsp;jedné
asynchronně volané callback funkci dochází k&nbsp;transformaci vstupní zprávy
na zprávu výstupní.</p>

<p>Přidání knihovny <strong>irclj</strong> do vlastního projektu je velmi
snadné, což ostatně ukazuje i následující projektový soubor:</p>

<pre>
(defproject ircbot1 "0.1.0-SNAPSHOT"
  :description "FIXME: write description"
  :url "http://example.com/FIXME"
  :license {:name "Eclipse Public License"
            :url "http://www.eclipse.org/legal/epl-v10.html"}
  :dependencies [[org.clojure/clojure "1.7.0"]
                 <strong>[irclj "0.5.0-alpha4"]</strong>]
  :main ^:skip-aot ircbot1.core
  :target-path "target/%s"
  :profiles {:uberjar {:aot :all}})
</pre>

<p>Poznámka: podobný soubor, pouze s&nbsp;odlišným jménem projektu a hlavního
modulu, je použit ve všech čtyřech demonstračních příkladech, takže si kopii
tohoto souboru již nebudeme ukazovat.</p>

<p>Poznámka<sup>2</sup>: označení &bdquo;0.5.0-alpha4&ldquo; se není třeba bát,
protože knihovna <i>irclj</i> v&nbsp;alfa verzi je ve skutečnosti v&nbsp;mnohem
lepším stavu, než mnohé knihovny a frameworky ve své stabilní verzi :-)</p>



<p><a name="k03"></a></p>
<h2 id="k03">3. Připojení IRC bota k&nbsp;serveru, příjem zprávy a generování odpovědi</h2>

<p>Použití knihovny <i>irclj</i> je poměrně jednoduché. Podívejme se nejprve na
kroky, které je zapotřebí provést při implementaci vlastního IRC bota:</p>

<ul>
<li>Navázání spojení s&nbsp;vybraným IRC serverem a registrace nicku
(přezdívky) bota.</li>
<li>Připojení k&nbsp;vybranému kanálu či kanálům, na nichž má být bot dostupný
(nepovinné, protože s&nbsp;botem je možné komunikovat i s&nbsp;využitím pouze
soukromých zpráv).</li>
<li>Realizace callback funkce zavolané ve chvíli, kdy je botovi poslána
zpráva.</li>
</ul>

<p>První krok, tj.&nbsp;připojení k&nbsp;IRC serveru, se realizuje
s&nbsp;využitím funkce <strong>irclj.core/connect</strong>, které se předá
jméno serveru, port, na který se má bot připojit, nick (přezdívka) bota, a
případné další parametry:</p>

<pre>
(<strong>irclj.core/connect</strong> jméno_serveru port nick další_parametry)
</pre>

<p>Konkrétně může být připojení navázáno tímto způsobem. Posledním parametrem
je specifikována uživatelská callback funkce volaná při přijetí zprávy:</p>

<pre>
(<strong>irclj.core/connect</strong> "irc.freenode.net" 6667 "unique" :callbacks {:privmsg callback-function})
</pre>

<p>Druhým krokem je připojení bota k&nbsp;vybranému kanálu či kanálům, což
zajišťuje funkce nazvaná <strong>irclj.core/join</strong>. První parametrem
této funkce je hodnota reprezentující navázané spojení, tj.&nbsp;hodnota
vrácená již popsanou funkcí <strong>irclj.core/connect</strong>:</p>

<pre>
(<strong>irclj.core/join</strong> connection jmeno-kanalu)
</pre>

<p>Konkrétní způsob použití této funkce:</p>

<pre>
(<strong>irclj.core/join</strong> connection "#botwar")
</pre>

<p>Pro zjednodušení konfigurace budeme v&nbsp;demonstračních příkladech
používat datovou strukturu (konkrétně mapu) nazvanou
<strong>configuration</strong>, v&nbsp;níž budou uloženy všechny potřebné
parametry připojení:</p>

<pre>
(<strong>def</strong> configuration
    <i>"Datova struktura obsahujici informace o pripojeni na IRC server."</i>
    {:server  "irc.freenode.net" <i>; vsem dostupny IRC server</i>
     :port    6667               <i>; vychozi port</i>
     :channel "#botwar"          <i>; kanal, ktery je urceny pro testovani botu</i>
                                 <i>; (dostanete zde mj. prava channel operatora)</i>
     :nick    "cljbot42"})       <i>; tuto cast bude potreba zmenit, nehadejte se</i>
                                 <i>; prosim o stejny nick :)</i>
</pre>

<p>Navázání připojení potom zajišťuje uživatelská funkce pojmenovaná
<strong>start-irc-bot</strong>. Nejprve se zavolá
<strong>irclj.core/connect</strong>, výsledek a její návratová hodnota se
použije pro <strong>irclj.core/join</strong>:</p>

<pre>
(<strong>defn</strong> start-irc-bot
    <i>"Funkce, ktera zajisti spusteni IRC bota a jeho pripojeni na zvoleny server a kanal(y)."</i>
    [configuration callback-function]
    (println "Connecting to" (:server configuration) "port" (:port configuration))
    <i>; vlastni pripojeni na server</i>
    (<strong>let</strong> [connection (irclj.core/connect (:server configuration)
                                  (:port   configuration)
                                  (:nick   configuration)
                                  :callbacks {:privmsg callback-function})]
        (println "Connected, joining to channel" (:channel configuration))
        <i>; pripojeni ke zvolenemu kanalu ci kanalum</i>
        (irclj.core/join connection (:channel configuration))
        <i>; snad je vse ok :)</i>
        (println "Connected...")))
</pre>

<a href="http://www.root.cz/obrazek/238225/"><img src="https://i.iinfo.cz/images/561/ircbot1-prev.png" class="image-238225" alt="&#160;" width="370" height="229" /></a>
<p><i>Obrázek 1: Připojení bota do kanálu a začátek konverzace.</i></p>



<p><a name="k04"></a></p>
<h2 id="k04">4. Příjem zprávy a generování odpovědi</h2>

<p>Do navázání spojení a připojení bota ke zvolenému kanálu je nutné nějakým
způsobem odpovídat na přijímané zprávy. K&nbsp;tomu slouží uživatelská callback
funkce, kterou jsme pojmenovali <strong>on-incoming-message</strong> a
zaregistrovali při volání <strong>irclj.core/connect</strong>. Nejprve se
podívejme, jak tato funkce vypadá:</p>

<pre>
(<strong>defn</strong> on-incoming-message
    <i>"Callback funkce volana pri prichodu zpravy na kanal ci na soukromy chat."</i>
    [connection incoming-message]
    <i>; rozdeleni zpravy na jednotlive prvky</i>
    (<strong>let</strong> [{text    :text
           target  :target
           nick    :nick
           host    :host
           command :command} incoming-message]
           <i>; zalogujeme, co se prave stalo</i>
           (println "Received message from" nick "to" target ":" text "(" host command ")")
           <i>; a vytvorime vhodnou odpoved</i>
           (irclj.core/reply connection (create-reply incoming-message) (str "hello " nick))))
</pre>

<p>Tato funkce je při příchodu zprávy zavolána a jsou jí předány dva parametry.
V&nbsp;prvním parametru je uložena hodnota s&nbsp;informacemi o připojení,
tj.&nbsp;hodnota, kterou vrací funkce <strong>irclj.core/connect</strong>. Tuto
hodnotu použijeme při vytváření odpovědi. Druhým automaticky naplňovaným
parametrem je datová struktura obsahující samotnou zprávu. Jak je
v&nbsp;programovacím jazyku Clojure dobrým zvykem, je tato datová struktura
reprezentována mapou, kde klíči jsou takzvané <i>keywords</i>,
tj.&nbsp;unikátní hodnoty. My nejprve ze zprávy získáme pětici prvků a uložíme
je do lokálních proměnných pojmenovaných <strong>text</strong>,
<strong>target</strong>, <strong>nick</strong>, <strong>host</strong> a
<strong>command</strong> (používá se zde postup nazývaný
&bdquo;destructuring&ldquo; a navíc fakt, že i samotný <i>keyword</i> se chová
jako funkce <strong>get</strong>). Následně jsou na standardní výstup vypsány
informace o přijetí zprávy:</p>

<a href="http://www.root.cz/obrazek/238226/"><img src="https://i.iinfo.cz/images/171/ircbot2-prev.png" class="image-238226" alt="&#160;" width="370" height="94" /></a>
<p><i>Obrázek 2: Zprávy vypisované botem na standardní výstup.</i></p>

<p>O odpověď se postará <strong>irclj.core/reply</strong>, které se předá mapa
se stejnou strukturou, jako má příchozí zpráva, ale samozřejmě s&nbsp;jiným
obsahem. To je řešeno v&nbsp;uživatelské funkci nazvané příhodně
<strong>create-reply</strong>. Tato funkce se rozhodne, zda jí přichází
soukromá zpráva či zpráva na kanálu a potom buď přímo odpoví nebo pošle zprávu
zpět přímo uživateli (<strong>target</strong> bude nastaven na přezdívku
uživatele a nikoli na jméno kanálu; náhradu zařizuje funkce
<strong>assoc</strong> vracející upravenou mapu):</p>

<pre>
(<strong>defn</strong> create-reply
    <i>"Vytvoreni datove struktury popisujici odpoved."</i>
    [incoming-message]
    <i>; rozhodnuti, zda se ma odpoved poslat zpet do kanalu nebo na soukromy chat</i>
    (<strong>if</strong> (.startsWith (:target incoming-message) "#") <i>; cilem je jmeno kanalu</i>
        incoming-message                             <i>; -> posleme odpoved zpet na kanal</i>
        <i>; v opacnem pripade posleme zpravu primo uzivateli</i>
        <i>; cilem bude prezdivka uzivatele</i>
        (assoc incoming-message :target (:nick incoming-message))))
</pre>

<a href="http://www.root.cz/obrazek/238227/"><img src="https://i.iinfo.cz/images/445/ircbot3-prev.png" class="image-238227" alt="&#160;" width="370" height="229" /></a>
<p><i>Obrázek 3: Zpráva zaslaná botovi soukromě. Bot správně odpoví na soukromý
chat a nikoli do kanálu.</i></p>



<p><a name="k05"></a></p>
<h2 id="k05">5. Demonstrační příklad <strong>ircbot1</strong>: první jednoduchá varianta IRC bota</h2>

<p>Postupy a uživatelské funkce vysvětlené v&nbsp;předchozích dvou kapitolách
jsou použity v&nbsp;dnešním prvním demonstračním příkladu pojmenovaném
jednoduše <strong>ircbot1</strong>. Celý projekt s&nbsp;tímto demonstračním
příkladem naleznete na adrese <a
href="https://github.com/tisnik/clojure-examples/tree/master/ircbot1">https://github.com/tisnik/clojure-examples/tree/master/ircbot1</a>.
Po spuštění tohoto příkladu se provede připojení ke známému IRC serveru
&bdquo;irc.freenode.net&ldquo; přes port 6667. Bot se bude snažit získat
přezdívku &bdquo;cljbot42&ldquo;, což se pravděpodobně nepovede v&nbsp;případě,
že si tento příklad spustí více čtenářů současně, takže si prosím přezdívku ve
zdrojovém kódu změňte (třeba si do ni přidejte hostname atd.). Následně se bot
připojí na kanál #botwar a bude zde očekávat zprávy, přičemž o zpracování zpráv
se podělí dvě uživatelské funkce pojmenované
<strong>on-incomming-message</strong> a <strong>create-reply</strong>:</p>

<pre>
<i>;</i>
<i>; Prvni varianta velmi jednoducheho IRC bota</i>
<i>;</i>
<i>; Autor: Pavel Tisnovsky</i>
<i>;</i>
&nbsp;
(<strong>ns</strong> ircbot1.core
  (:gen-class))
&nbsp;
(<strong>require</strong> '[irclj.core :as irc])
&nbsp;
(<strong>def</strong> configuration
    <i>"Datova struktura obsahujici informace o pripojeni na IRC server."</i>
    {:server  "irc.freenode.net" <i>; vsem dostupny IRC server</i>
     :port    6667               <i>; vychozi port</i>
     :channel "#botwar"          <i>; kanal, ktery je urceny pro testovani botu</i>
                                 <i>; (dostanete zde mj. prava channel operatora)</i>
     :nick    "cljbot42"})       <i>; tuto cast bude potreba zmenit, nehadejte se</i>
                                 <i>; prosim o stejny nick :)</i>
&nbsp;
(<strong>defn</strong> create-reply
    <i>"Vytvoreni datove struktury popisujici odpoved."</i>
    [incoming-message]
    <i>; rozhodnuti, zda se ma odpoved poslat zpet do kanalu nebo na soukromy chat</i>
    (<strong>if</strong> (.startsWith (:target incoming-message) "#") <i>; cilem je jmeno kanalu</i>
        incoming-message                             <i>; -> posleme odpoved zpet na kanal</i>
        <i>; v opacnem pripade posleme zpravu primo uzivateli</i>
        <i>; cilem bude prezdivka uzivatele</i>
        (assoc incoming-message :target (:nick incoming-message))))
&nbsp;
(<strong>defn</strong> on-incoming-message
    <i>"Callback funkce volana pri prichodu zpravy na kanal ci na soukromy chat."</i>
    [connection incoming-message]
    <i>; rozdeleni zpravy na jednotlive prvky</i>
    (<strong>let</strong> [{text    :text
           target  :target
           nick    :nick
           host    :host
           command :command} incoming-message]
           <i>; zalogujeme, co se prave stalo</i>
           (println "Received message from" nick "to" target ":" text "(" host command ")")
           <i>; a vytvorime vhodnou odpoved</i>
           (irc/reply connection (create-reply incoming-message) (str "hello " nick))))
&nbsp;
(<strong>defn</strong> start-irc-bot
    <i>"Funkce, ktera zajisti spusteni IRC bota a jeho pripojeni na zvoleny server a kanal(y)."</i>
    [configuration callback-function]
    (println "Connecting to" (:server configuration) "port" (:port configuration))
    <i>; vlastni pripojeni na server</i>
    (<strong>let</strong> [connection (irc/connect (:server configuration)
                                  (:port   configuration)
                                  (:nick   configuration)
                                  :callbacks {:privmsg callback-function})]
        (println "Connected, joining to channel" (:channel configuration))
        <i>; pripojeni ke zvolenemu kanalu ci kanalum</i>
        (irc/join connection (:channel configuration))
        <i>; snad je vse ok :)</i>
        (println "Connected...")))
&nbsp;
(<strong>defn</strong> -main
    <i>"Vstupni bod do teto aplikace."</i>
    [&amp; args]
    (start-irc-bot configuration on-incoming-message))
</pre>

<a href="http://www.root.cz/obrazek/238228/"><img src="https://i.iinfo.cz/images/176/ircbot4-prev.png" class="image-238228" alt="&#160;" width="370" height="229" /></a>
<p><i>Obrázek 4: Na kanálu #botwar dostanou všichni práva operátora, což je pro
ladění botů výhodné &ndash; je možné je ihned vyhodit :-)</i></p>



<p><a name="k06"></a></p>
<h2 id="k06">6. Rozhodnutí, zda zpráva přišla z&nbsp;kanálu nebo v&nbsp;soukromém chatu a zda jde o zprávu pro bota</h2>

<p>Už v&nbsp;první verzi IRC bota bylo nutné rozhodnout, zda zpráva, na kterou
bot reaguje (nebo také nereaguje) přišla na kanál nebo přes soukromý chat.
Tento test je vlastně velmi jednoduchý, protože stačí ověřit, jestli cíl
(<i>target</i>) zprávy začíná znakem #. Nově tedy test implementujeme ve
vlastní funkci &ndash; predikátu (proto název této funkce končí na
otazník):</p>

<pre>
(<strong>defn</strong> message-to-channel?
    <i>"Test, zda se jedna o zpravu poslanou na kanal."</i>
    [message]
    (.startsWith (:target message) "#"))
</pre>

<p>Funkce pro vytvoření odpovědi se poněkud změní:</p>

<pre>
(<strong>defn</strong> create-reply
    <i>"Vytvoreni datove struktury popisujici odpoved."</i>
    [incoming-message]
    <i>; rozhodnuti, zda se ma odpoved poslat zpet do kanalu nebo na soukromy chat</i>
    (<strong>if</strong> (message-to-channel? incoming-message) <i>; pokud je cilem primo jmeno kanalu</i>
        incoming-message                       <i>; -> posleme odpoved zpet na kanal</i>
        <i>; v opacnem pripade posleme zpravu primo uzivateli</i>
        <i>; cilem bude prezdivka uzivatele</i>
        (assoc incoming-message :target (:nick incoming-message))))
</pre>

<a href="http://www.root.cz/obrazek/238229/"><img src="https://i.iinfo.cz/images/466/ircbot5-prev.png" class="image-238229" alt="&#160;" width="370" height="229" /></a>
<p><i>Obrázek 5: Původní verze bota reagovala na všechny zprávy.</i></p>

<p>Další test, který je nutné implementovat, ověří, zda je zpráva poslána přímo
botovi. Zde jsou dvě možnosti: u privátní zprávy stačí otestovat jejího
příjemce (<i>target</i>), zatímco u zprávy poslané na kanál se zjistí, zda
zpráva začíná správným nickem. Poněkud naivní implementace tohoto druhého testu
může vypadat následovně:</p>

<pre>
(<strong>defn</strong> message-for-me?
    <i>"Vrati logickou 'pravdu' v pripade, ze se byla prijata</i>
    <i> prima zprava ci privatni zprava."</i>
    [my-name message]
    (or (.startsWith (:target message) my-name)        <i>; privatni zprava</i>
        (.startsWith (:text message) (str my-name ":"))<i>; prima zprava</i>
    ))
</pre>

<p>Nyní může bot reagovat pouze na zprávu určenou přímo jemu, což zajišťuje
přidaná podmínka:</p>

<pre>
(<strong>defn</strong> on-incoming-message
    <i>"Callback funkce volana pri prichodu zpravy na kanal ci na soukromy chat."</i>
    [connection incoming-message]
    <i>; rozdeleni zpravy na jednotlive prvky</i>
    (<strong>let</strong> [{text    :text
           target  :target
           nick    :nick
           host    :host
           command :command} incoming-message]
           <i>; zalogujeme, co se prave stalo</i>
           (println "Received message from" nick "to" target ":" text "(" host command ")")
           <i>; test, zda je zprava skutecne urcena pro bota</i>
           (<strong>if</strong> (message-for-me? (:nick configuration) incoming-message)
               <i>; vytvorime vhodnou odpoved</i>
               (irc/reply connection (create-reply incoming-message) (str "hello " nick)))))
</pre>

<a href="http://www.root.cz/obrazek/238230/"><img src="https://i.iinfo.cz/images/343/ircbot6-prev.png" class="image-238230" alt="&#160;" width="370" height="229" /></a>
<p><i>Obrázek 6: Nová verze bota reaguje jen na zprávy poslané přímo jemu.</i></p>



<p><a name="k07"></a></p>
<h2 id="k07">7. Druhý demonstrační příklad <strong>ircbot2</strong>: odpovídání na zprávy určené pouze botovi</h2>

<p>Podobně, jako tomu bylo už <a href="#k05">v&nbsp;prvním demonstračním
příkladu</a>, i druhý příklad využívá funkce popsané <a
href="#k06">v&nbsp;předchozí kapitole</a>. Tento příklad se jmenuje
<strong>ircbot2</strong> a jeho zdrojový kód naleznete na adrese <a
href="https://github.com/tisnik/clojure-examples/tree/master/ircbot2">https://github.com/tisnik/clojure-examples/tree/master/ircbot2</a>.
Při testování bota prosím nezapomeňte změnit jeho nick popř.&nbsp;ho otestovat
na jiném serveru, než je &bdquo;irc.freenode.net&ldquo;:</p>

<pre>
<i>;</i>
<i>; Druha varianta velmi jednoducheho IRC bota:</i>
<i>; bot nyni odpovida pouze na zpravy, ktere jsou mu urceny</i>
<i>;</i>
<i>; Autor: Pavel Tisnovsky</i>
<i>;</i>
&nbsp;
(<strong>ns</strong> ircbot2.core
  (:gen-class))
&nbsp;
(<strong>require</strong> '[irclj.core :as irc])
&nbsp;
(<strong>def</strong> configuration
    <i>"Datova struktura obsahujici informace o pripojeni na IRC server."</i>
    {:server  "irc.freenode.net" <i>; vsem dostupny IRC server</i>
     :port    6667               <i>; vychozi port</i>
     :channel "#botwar"          <i>; kanal, ktery je urceny pro testovani botu</i>
                                 <i>; (dostanete zde mj. prava channel operatora)</i>
     :nick    "cljbot42"})       <i>; tuto cast bude potreba zmenit, nehadejte se</i>
                                 <i>; prosim o stejny nick :)</i>
&nbsp;
(<strong>defn</strong> message-to-channel?
    <i>"Test, zda se jedna o zpravu poslanou na kanal."</i>
    [message]
    (.startsWith (:target message) "#"))
&nbsp;
(<strong>defn</strong> message-for-me?
    <i>"Vrati logickou 'pravdu' v pripade, ze se byla prijata</i>
    <i> prima zprava ci privatni zprava."</i>
    [my-name message]
    (or (.startsWith (:target message) my-name)        <i>; privatni zprava</i>
        (.startsWith (:text message) (str my-name ":"))<i>; prima zprava</i>
    ))
&nbsp;
(<strong>defn</strong> create-reply
    <i>"Vytvoreni datove struktury popisujici odpoved."</i>
    [incoming-message]
    <i>; rozhodnuti, zda se ma odpoved poslat zpet do kanalu nebo na soukromy chat</i>
    (<strong>if</strong> (message-to-channel? incoming-message) <i>; pokud je cilem primo jmeno kanalu</i>
        incoming-message                       <i>; -> posleme odpoved zpet na kanal</i>
        <i>; v opacnem pripade posleme zpravu primo uzivateli</i>
        <i>; cilem bude prezdivka uzivatele</i>
        (assoc incoming-message :target (:nick incoming-message))))
&nbsp;
(<strong>defn</strong> on-incoming-message
    <i>"Callback funkce volana pri prichodu zpravy na kanal ci na soukromy chat."</i>
    [connection incoming-message]
    <i>; rozdeleni zpravy na jednotlive prvky</i>
    (<strong>let</strong> [{text    :text
           target  :target
           nick    :nick
           host    :host
           command :command} incoming-message]
           <i>; zalogujeme, co se prave stalo</i>
           (println "Received message from" nick "to" target ":" text "(" host command ")")
           <i>; test, zda je zprava skutecne urcena pro bota</i>
           (<strong>if</strong> (message-for-me? (:nick configuration) incoming-message)
               <i>; vytvorime vhodnou odpoved</i>
               (irc/reply connection (create-reply incoming-message) (str "hello " nick)))))
&nbsp;
(<strong>defn</strong> start-irc-bot
    <i>"Funkce, ktera zajisti spusteni IRC bota a jeho pripojeni na zvoleny server a kanal(y)."</i>
    [configuration callback-function]
    (println "Connecting to" (:server configuration) "port" (:port configuration))
    <i>; vlastni pripojeni na server</i>
    (<strong>let</strong> [connection (irc/connect (:server configuration)
                                  (:port   configuration)
                                  (:nick   configuration)
                                  :callbacks {:privmsg callback-function})]
        (println "Connected, joining to channel" (:channel configuration))
        <i>; pripojeni ke zvolenemu kanalu ci kanalum</i>
        (irc/join connection (:channel configuration))
        <i>; snad je vse ok :)</i>
        (println "Connected...")))
&nbsp;
(<strong>defn</strong> -main
    <i>"Vstupni bod do teto aplikace."</i>
    [&amp; args]
    (start-irc-bot configuration on-incoming-message))
</pre>



<p><a name="k08"></a></p>
<h2 id="k08">8. Rozpoznání dotazu, parsing čísla, výpočet faktoriálu</h2>

<p>Aby byl IRC bot nějakým způsobem užitečný nebo zábavný, musí reagovat na
zprávy, které mu byly zaslány. My si ukážeme velmi jednoduchou variantu bota,
která prozatím pouze vypočítá faktoriál z&nbsp;přirozeného čísla (což sice není
příliš užitečné ani zábavné, ale nějak se začít musí). Funkce pro výpočet
faktoriálu může v&nbsp;podání jazyka Clojure používat <strong>apply</strong>
(rekurzí se zde nechte otravovat pouze ve škole, zde pro výpočet faktoriálu se
nehodí :-) a operaci (což je taktéž funkce) *'. Apostrof zde mění význam
násobení, protože automaticky rozpozná přetečení čísel typu int či long a
přejde na výpočty s&nbsp;čísly reprezentovanými objekty typu BigDecimal:</p>

<pre>
(<strong>defn</strong> factorial
    <i>"Vypocet faktorialu, varianta pracujici korektne s typem BigDecimal."</i>
    [n]
    (<strong>if</strong> (neg? n)
        "negative numbers are not supported!"
        (apply *' (range 1 (inc n)))))
</pre>

<a href="http://www.root.cz/obrazek/238231/"><img src="https://i.iinfo.cz/images/549/ircbot7-prev.png" class="image-238231" alt="&#160;" width="370" height="229" /></a>
<p><i>Obrázek 7: IRC bot dokáže spočítat faktoriál prakticky jakéhokoli
přirozeného čísla.</i></p>

<p>Dále si připravíme funkci pro převod textu na číslo typu BigDecimal (šlo by
ovšem použít i int). Pokud zpráva neobsahuje číslo nebo došlo k&nbsp;nějaké
jiné chybě, vrací se <strong>nil</strong>:</p>

<pre>
(<strong>defn</strong> text-&gt;number
    <i>"Prevod parametru specifikovaneho v param-name na cislo typu BigDecimal."</i>
    [input-text]
    (<strong>try</strong>
        (<strong>let</strong> [number (re-find #"\d+" input-text)]
            (<strong>if</strong> number (bigdec number)))       <i>; pokus o prevod na BigDecimal</i>
        (<strong>catch</strong> Exception e nil))) <i>; pokud se prevod nepovede, vraci se nil</i>
</pre>

<p>Samotná reakce na zprávu poslanou uživatelem přímo botovi by mohla vypadat
následovně (povšimněte si, že pokud se číslo ve zprávě nenalezne, odpoví bot
otazníkem; sami si namísto něj můžete přidat jinou vtipnou odpověď):</p>

<pre>
(<strong>defn</strong> prepare-reply-text
    <i>"Priprava odpovedi."</i>
    [input-text]
    (<strong>let</strong> [number (text-&gt;number input-text)]
        <i>; pokud se podarilo precist cislo</i>
        (<strong>if</strong> number
            <i>; vypocte a vrati se jeho faktorial</i>
            (factorial number)
            "?")))
</pre>

<a href="http://www.root.cz/obrazek/238232/"><img src="https://i.iinfo.cz/images/443/ircbot8-prev.png" class="image-238232" alt="&#160;" width="370" height="229" /></a>
<p><i>Obrázek 8: Pokud se číslo nerozpozná, vypíše se pouze otazník.</i></p>



<p><a name="k09"></a></p>
<h2 id="k09">9. Třetí demonstrační příklad <strong>ircbot3</strong>: výpočet faktoriálu (smysluplná odpověď)</h2>

<p>Podívejme se nyní, jak budou výše popsané funkce <strong>factorial</strong>,
<strong>text-&gt;number</strong> a <strong>prepare-reply-text</strong> použity
ve třetí variantě jednoduchého IRC bota. Základní struktura bota se nijak
neliší od předchozích dvou variant (připojení k&nbsp;serveru, registrace nicku,
připojení ke kanálu), odlišné je pouze naprogramování jeho reakce na příchozí
zprávy:</p>

<pre>
<i>;</i>
<i>; Treti varianta velmi jednoducheho IRC bota:</i>
<i>; bot nyni odpovida pouze na zpravy, ktere jsou mu urceny</i>
<i>; pokud rozpozna cislo, vypocte z neho faktorial</i>
<i>;</i>
<i>; Autor: Pavel Tisnovsky</i>
<i>;</i>
&nbsp;
(<strong>ns</strong> ircbot3.core
  (:gen-class))
&nbsp;
(<strong>require</strong> '[irclj.core :as irc])
&nbsp;
(<strong>def</strong> configuration
    <i>"Datova struktura obsahujici informace o pripojeni na IRC server."</i>
    {:server  "irc.freenode.net" <i>; vsem dostupny IRC server</i>
     :port    6667               <i>; vychozi port</i>
     :channel "#botwar"          <i>; kanal, ktery je urceny pro testovani botu</i>
                                 <i>; (dostanete zde mj. prava channel operatora)</i>
     :nick    "cljbot42"})       <i>; tuto cast bude potreba zmenit, nehadejte se</i>
                                 <i>; prosim o stejny nick :)</i>
&nbsp;
(<strong>defn</strong> message-to-channel?
    <i>"Test, zda se jedna o zpravu poslanou na kanal."</i>
    [message]
    (.startsWith (:target message) "#"))
&nbsp;
(<strong>defn</strong> message-for-me?
    <i>"Vrati logickou 'pravdu' v pripade, ze se byla prijata</i>
    <i> prima zprava ci privatni zprava."</i>
    [my-name message]
    (or (.startsWith (:target message) my-name)        <i>; privatni zprava</i>
        (.startsWith (:text message) (str my-name ":"))<i>; prima zprava</i>
    ))
&nbsp;
(<strong>defn</strong> create-reply
    <i>"Vytvoreni datove struktury popisujici odpoved."</i>
    [incoming-message]
    <i>; rozhodnuti, zda se ma odpoved poslat zpet do kanalu nebo na soukromy chat</i>
    (<strong>if</strong> (message-to-channel? incoming-message) <i>; pokud je cilem primo jmeno kanalu</i>
        incoming-message                       <i>; -&gt; posleme odpoved zpet na kanal</i>
        <i>; v opacnem pripade posleme zpravu primo uzivateli</i>
        <i>; cilem bude prezdivka uzivatele</i>
        (assoc incoming-message :target (:nick incoming-message))))
&nbsp;
(<strong>defn</strong> text-&gt;number
    <i>"Prevod parametru specifikovaneho v param-name na cislo typu BigDecimal."</i>
    [input-text]
    (<strong>try</strong>
        (<strong>let</strong> [number (re-find #"\d+" input-text)]
            (<strong>if</strong> number (bigdec number)))       <i>; pokus o prevod na BigDecimal</i>
        (<strong>catch</strong> Exception e nil))) <i>; pokud se prevod nepovede, vraci se nil</i>
&nbsp;
(<strong>defn</strong> factorial
    <i>"Vypocet faktorialu, varianta pracujici korektne s typem BigDecimal."</i>
    [n]
    (<strong>if</strong> (neg? n)
        "negative numbers are not supported!"
        (apply *' (range 1 (inc n)))))
&nbsp;
(<strong>defn</strong> prepare-reply-text
    <i>"Priprava odpovedi."</i>
    [input-text]
    (<strong>let</strong> [number (text-&gt;number input-text)]
        <i>; pokud se podarilo precist cislo</i>
        (<strong>if</strong> number
            <i>; vypocte a vrati se jeho faktorial</i>
            (factorial number)
            "?")))
&nbsp;
(<strong>defn</strong> on-incoming-message
    <i>"Callback funkce volana pri prichodu zpravy na kanal ci na soukromy chat."</i>
    [connection incoming-message]
    <i>; rozdeleni zpravy na jednotlive prvky</i>
    (<strong>let</strong> [{text    :text
           target  :target
           nick    :nick
           host    :host
           command :command} incoming-message]
           <i>; zalogujeme, co se prave stalo</i>
           (println "Received message from" nick "to" target ":" text "(" host command ")")
           <i>; test, zda je zprava skutecne urcena pro bota</i>
           (<strong>if</strong> (message-for-me? (:nick configuration) incoming-message)
               <i>; vytvorime vhodnou odpoved</i>
               (irc/reply connection (create-reply incoming-message) (prepare-reply-text text)))))
&nbsp;
(<strong>defn</strong> start-irc-bot
    <i>"Funkce, ktera zajisti spusteni IRC bota a jeho pripojeni na zvoleny server a kanal(y)."</i>
    [configuration callback-function]
    (println "Connecting to" (:server configuration) "port" (:port configuration))
    <i>; vlastni pripojeni na server</i>
    (<strong>let</strong> [connection (irc/connect (:server configuration)
                                  (:port   configuration)
                                  (:nick   configuration)
                                  :callbacks {:privmsg callback-function})]
        (println "Connected, joining to channel" (:channel configuration))
        <i>; pripojeni ke zvolenemu kanalu ci kanalum</i>
        (irc/join connection (:channel configuration))
        <i>; snad je vse ok :)</i>
        (println "Connected...")))
&nbsp;
(<strong>defn</strong> -main
    <i>"Vstupni bod do teto aplikace."</i>
    [&amp; args]
    (start-irc-bot configuration on-incoming-message))
</pre>



<p><a name="k10"></a></p>
<h2 id="k10">10. Odpověď tazateli na kanálu a přímá odpověď v&nbsp;soukromém chatu</h2>

<p>Všimli jste si, jakým způsobem náš IRC bot odpoví ve chvíli, kdy se ho
zeptáme na kanále (nikoli v&nbsp;privátní zprávě)? Podívejte se na následující
screenshot:</p>

<a href="http://www.root.cz/obrazek/238233/"><img src="https://i.iinfo.cz/images/113/ircbot9-prev.png" class="image-238233" alt="&#160;" width="370" height="229" /></a>
<p><i>Obrázek 9: Všimli jste si, co nyní IRC bot počítá?</i></p>

<p>Problém je jednoduchý &ndash; samotný nick bota už obsahuje číslo (42),
které je &bdquo;správně&ldquo; rozpoznáno a je vypočítán jeho faktoriál. Pro
opravu tohoto problému je nutné nepatrně změnit uživatelskou funkci
<strong>prepare-reply-text</strong> tak, aby se u zpráv posílaných do kanálu
odstranilo jméno bota:</p>

<pre>
<i>; test, zda zpráva přišla do kanálu</i>
in-channel? (message-to-channel? incomming-message)
&nbsp;
<i>; získání vstupního čísla n</i>
number (text-&gt;number (<strong>if</strong> in-channel?
                         (subs input-text (count (:nick configuration)))
                         input-text))
</pre>

<p>Nový tvar funkce <strong>prepare-reply-text</strong> může vypadat
následovně:</p>

<pre>
(<strong>defn</strong> prepare-reply-text
    <i>"Priprava odpovedi."</i>
    [incomming-message nick input-text]
    (<strong>let</strong> [in-channel? (message-to-channel? incomming-message)
          number      (text-&gt;number (<strong>if</strong> in-channel?
                                        (subs input-text (count (:nick configuration)))
                                        input-text))
          prefix      (<strong>if</strong> in-channel? (str nick ": "))]
        <i>; pokud se podarilo precist cislo</i>
        (<strong>if</strong> number
            <i>; vypocte a vrati se jeho faktorial + odpoved uzivateli</i>
            (str prefix (factorial number))
            (str prefix "?"))))
</pre>

<a href="http://www.root.cz/obrazek/238234/"><img src="https://i.iinfo.cz/images/594/ircbot10-prev.png" class="image-238234" alt="&#160;" width="370" height="229" /></a></p>
<p><i>Obrázek 10: První úspěch u uživatelů :-) + nová verze IRC bota (druhá
část zpráv).</i></p>



<p><a name="k11"></a></p>
<h2 id="k11">11. Čtvrtý demonstrační příklad <strong>ircbot4</strong>: rozpoznání jména bota, odpověď přímo tazateli atd.</h2>

<p>Na závěr si ukažme úplný zdrojový kód čtvrté verze IRC bota, který by již
měl správně počítat faktoriály i ve chvíli, kdy samotný nick obsahuje
číslo:</p>

<pre>
<i>;</i>
<i>; Ctvrta varianta velmi jednoducheho IRC bota:</i>
<i>; bot nyni odpovida pouze na zpravy, ktere jsou mu urceny</i>
<i>; pokud rozpozna cislo, vypocte z neho faktorial, spravne</i>
<i>; ignoruje sve jmeno, odpovida primo tazateli atd.</i>
<i>;</i>
<i>; Autor: Pavel Tisnovsky</i>
<i>;</i>
&nbsp;
(<strong>ns</strong> ircbot4.core
  (:gen-class))
&nbsp;
(<strong>require</strong> '[irclj.core :as irc])
&nbsp;
(<strong>def</strong> configuration
    <i>"Datova struktura obsahujici informace o pripojeni na IRC server."</i>
    {:server  "irc.freenode.net" <i>; vsem dostupny IRC server</i>
     :port    6667               <i>; vychozi port</i>
     :channel "#botwar"          <i>; kanal, ktery je urceny pro testovani botu</i>
                                 <i>; (dostanete zde mj. prava channel operatora)</i>
     :nick    "cljbot42"})       <i>; tuto cast bude potreba zmenit, nehadejte se</i>
                                 <i>; prosim o stejny nick :)</i>
&nbsp;
(<strong>defn</strong> message-to-channel?
    <i>"Test, zda se jedna o zpravu poslanou na kanal."</i>
    [message]
    (.startsWith (:target message) "#"))
&nbsp;
(<strong>defn</strong> message-for-me?
    <i>"Vrati logickou 'pravdu' v pripade, ze se byla prijata</i>
    <i> prima zprava ci privatni zprava."</i>
    [my-name message]
    (or (.startsWith (:target message) my-name)        <i>; privatni zprava</i>
        (.startsWith (:text message) (str my-name ":"))<i>; prima zprava</i>
    ))
&nbsp;
(<strong>defn</strong> create-reply
    <i>"Vytvoreni datove struktury popisujici odpoved."</i>
    [incoming-message]
    <i>; rozhodnuti, zda se ma odpoved poslat zpet do kanalu nebo na soukromy chat</i>
    (<strong>if</strong> (message-to-channel? incoming-message) <i>; pokud je cilem primo jmeno kanalu</i>
        incoming-message                       <i>; -&gt; posleme odpoved zpet na kanal</i>
        <i>; v opacnem pripade posleme zpravu primo uzivateli</i>
        <i>; cilem bude prezdivka uzivatele</i>
        (assoc incoming-message :target (:nick incoming-message))))
&nbsp;
(<strong>defn</strong> text-&gt;number
    <i>"Prevod parametru specifikovaneho v param-name na cislo typu BigDecimal."</i>
    [input-text]
    (<strong>try</strong>
        (<strong>let</strong> [number (re-find #"\d+" input-text)]
            (<strong>if</strong> number (bigdec number)))       <i>; pokus o prevod na BigDecimal</i>
        (<strong>catch</strong> Exception e nil)))              <i>; pokud se prevod nepovede, vraci se nil</i>
&nbsp;
(<strong>defn</strong> factorial
    <i>"Vypocet faktorialu, varianta pracujici korektne s typem BigDecimal."</i>
    [n]
    (<strong>if</strong> (neg? n)
        "negative numbers are not supported!"
        (apply *' (range 1 (inc n)))))
&nbsp;
(<strong>defn</strong> prepare-reply-text
    <i>"Priprava odpovedi."</i>
    [incomming-message nick input-text]
    (<strong>let</strong> [in-channel? (message-to-channel? incomming-message)
          number      (text-&gt;number (<strong>if</strong> in-channel?
                                        (subs input-text (count (:nick configuration)))
                                        input-text))
          prefix      (<strong>if</strong> in-channel? (str nick ": "))]
        <i>; pokud se podarilo precist cislo</i>
        (<strong>if</strong> number
            <i>; vypocte a vrati se jeho faktorial + odpoved uzivateli</i>
            (str prefix (factorial number))
            (str prefix "?"))))
&nbsp;
(<strong>defn</strong> on-incoming-message
    <i>"Callback funkce volana pri prichodu zpravy na kanal ci na soukromy chat."</i>
    [connection incoming-message]
    <i>; rozdeleni zpravy na jednotlive prvky</i>
    (<strong>let</strong> [{text    :text
           target  :target
           nick    :nick
           host    :host
           command :command} incoming-message]
           <i>; zalogujeme, co se prave stalo</i>
           (println "Received message from" nick "to" target ":" text "(" host command ")")
           <i>; test, zda je zprava skutecne urcena pro bota</i>
           (<strong>if</strong> (message-for-me? (:nick configuration) incoming-message)
               <i>; vytvorime vhodnou odpoved</i>
               (irc/reply connection (create-reply incoming-message)
                                     (prepare-reply-text incoming-message nick text)))))
&nbsp;
(<strong>defn</strong> start-irc-bot
    <i>"Funkce, ktera zajisti spusteni IRC bota a jeho pripojeni na zvoleny server a kanal(y)."</i>
    [configuration callback-function]
    (println "Connecting to" (:server configuration) "port" (:port configuration))
    <i>; vlastni pripojeni na server</i>
    (<strong>let</strong> [connection (irc/connect (:server configuration)
                                  (:port   configuration)
                                  (:nick   configuration)
                                  :callbacks {:privmsg callback-function})]
        (println "Connected, joining to channel" (:channel configuration))
        <i>; pripojeni ke zvolenemu kanalu ci kanalum</i>
        (irc/join connection (:channel configuration))
        <i>; snad je vse ok :)</i>
        (println "Connected...")))
&nbsp;
(<strong>defn</strong> -main
    <i>"Vstupni bod do teto aplikace."</i>
    [&amp; args]
    (start-irc-bot configuration on-incoming-message))
</pre>



<p><a name="k12"></a></p>
<h2 id="k12">12. Repositář s&nbsp;demonstračními příklady</h2>

<p>Všechny čtyři demonstrační příklady, které jsme si v&nbsp;dnešním článku
popsali, byly uloženy do Git repositáře dostupného na adrese <a
href="https://github.com/tisnik/clojure-examples">https://github.com/tisnik/clojure-examples</a>.
V&nbsp;tabulce zobrazené pod tímto odstavcem naleznete na zdrojové kódy všech
čtyř demonstračních příkladů přímé odkazy:</p>

<table>
<tr><th>#</th><th>Příklad/knihovna</th><th>Github</th></tr>
<tr><td>1</td><td>ircbot1</td><td><a href="https://github.com/tisnik/clojure-examples/tree/master/ircbot1">https://github.com/tisnik/clojure-examples/tree/master/ircbot1</a></td></tr>
<tr><td>2</td><td>ircbot2</td><td><a href="https://github.com/tisnik/clojure-examples/tree/master/ircbot2">https://github.com/tisnik/clojure-examples/tree/master/ircbot2</a></td></tr>
<tr><td>3</td><td>ircbot3</td><td><a href="https://github.com/tisnik/clojure-examples/tree/master/ircbot3">https://github.com/tisnik/clojure-examples/tree/master/ircbot3</a></td></tr>
<tr><td>4</td><td>ircbot4</td><td><a href="https://github.com/tisnik/clojure-examples/tree/master/ircbot4">https://github.com/tisnik/clojure-examples/tree/master/ircbot4</a></td></tr>
</table>



<p><a name="k13"></a></p>
<h2 id="k13">13. Odkazy na předchozí části tohoto seriálu</h2>

<ol>

<li>Clojure  1: Úvod<br />
<a href="http://www.root.cz/clanky/clojure-aneb-jazyk-umoznujici-tvorbu-bezpecnych-vicevlaknovych-aplikaci-pro-jvm/">http://www.root.cz/clanky/clojure-aneb-jazyk-umoznujici-tvorbu-bezpecnych-vicevlaknovych-aplikaci-pro-jvm/</a>
</li>

<li>Clojure  2: Symboly, kolekce atd.<br />
<a href="http://www.root.cz/clanky/clojure-aneb-jazyk-umoznujici-tvorbu-bezpecnych-vicevlaknovych-aplikaci-pro-jvm-2-cast/">http://www.root.cz/clanky/clojure-aneb-jazyk-umoznujici-tvorbu-bezpecnych-vicevlaknovych-aplikaci-pro-jvm-2-cast/</a>
</li>

<li>Clojure  3: Funkcionální programování<br />
<a href="http://www.root.cz/clanky/clojure-aneb-jazyk-umoznujici-tvorbu-bezpecnych-vicevlaknovych-aplikaci-pro-jvm-3-cast-funkcionalni-programovani/">http://www.root.cz/clanky/clojure-aneb-jazyk-umoznujici-tvorbu-bezpecnych-vicevlaknovych-aplikaci-pro-jvm-3-cast-funkcionalni-programovani/</a>
</li>

<li>Clojure  4: Kolekce, sekvence a lazy sekvence<br />
<a href="http://www.root.cz/clanky/clojure-aneb-jazyk-umoznujici-tvorbu-bezpecnych-vicevlaknovych-aplikaci-pro-jvm-4-cast-kolekce-sekvence-a-lazy-sekvence/">http://www.root.cz/clanky/clojure-aneb-jazyk-umoznujici-tvorbu-bezpecnych-vicevlaknovych-aplikaci-pro-jvm-4-cast-kolekce-sekvence-a-lazy-sekvence/</a>
</li>

<li>Clojure  5: Sekvence, lazy sekvence a paralelní programy<br />
<a href="http://www.root.cz/clanky/clojure-a-bezpecne-aplikace-pro-jvm-sekvence-lazy-sekvence-a-paralelni-programy/">http://www.root.cz/clanky/clojure-a-bezpecne-aplikace-pro-jvm-sekvence-lazy-sekvence-a-paralelni-programy/</a>
</li>

<li>Clojure  6: Podpora pro paralelní programování<br />
<a href="http://www.root.cz/clanky/programovaci-jazyk-clojure-6-futures-nejsou-jen-financni-derivaty/">http://www.root.cz/clanky/programovaci-jazyk-clojure-6-futures-nejsou-jen-financni-derivaty/</a>
</li>

<li>Clojure  7: Další funkce pro paralelní programování<br />
<a href="http://www.root.cz/clanky/programovaci-jazyk-clojure-7-dalsi-podpurne-prostredky-pro-paralelni-programovani/">http://www.root.cz/clanky/programovaci-jazyk-clojure-7-dalsi-podpurne-prostredky-pro-paralelni-programovani/</a>
</li>

<li>Clojure  8: Identity, stavy, neměnné hodnoty a reference<br />
<a href="http://www.root.cz/clanky/programovaci-jazyk-clojure-8-identity-stavy-nemenne-hodnoty-a-referencni-typy/">http://www.root.cz/clanky/programovaci-jazyk-clojure-8-identity-stavy-nemenne-hodnoty-a-referencni-typy/</a>
</li>

<li>Clojure  9: Validátory, pozorovatelé a kooperace s Javou<br />
<a href="http://www.root.cz/clanky/programovaci-jazyk-clojure-9-validatory-pozorovatele-a-kooperace-mezi-clojure-a-javou/">http://www.root.cz/clanky/programovaci-jazyk-clojure-9-validatory-pozorovatele-a-kooperace-mezi-clojure-a-javou/</a>
</li>

<li>Clojure 10: Kooperace mezi Clojure a Javou<br />
<a href="http://www.root.cz/clanky/programovaci-jazyk-clojure-10-kooperace-mezi-clojure-a-javou-pokracovani/">http://www.root.cz/clanky/programovaci-jazyk-clojure-10-kooperace-mezi-clojure-a-javou-pokracovani/</a>
</li>

<li>Clojure 11: Generátorová notace seznamu/list comprehension<br />
<a href="http://www.root.cz/clanky/programovaci-jazyk-clojure-11-generatorova-notace-seznamu-list-comprehension/">http://www.root.cz/clanky/programovaci-jazyk-clojure-11-generatorova-notace-seznamu-list-comprehension/</a>
</li>

<li>Clojure 12: Překlad programů z Clojure do bajtkódu JVM I:<br />
<a href="http://www.root.cz/clanky/programovaci-jazyk-clojure-12-preklad-programu-z-clojure-do-bajtkodu-jvm/">http://www.root.cz/clanky/programovaci-jazyk-clojure-12-preklad-programu-z-clojure-do-bajtkodu-jvm/</a>
</li>

<li>Clojure 13: Překlad programů z Clojure do bajtkódu JVM II:<br />
<a href="http://www.root.cz/clanky/programovaci-jazyk-clojure-13-preklad-programu-z-clojure-do-bajtkodu-jvm-pokracovani/">http://www.root.cz/clanky/programovaci-jazyk-clojure-13-preklad-programu-z-clojure-do-bajtkodu-jvm-pokracovani/</a>
</li>

<li>Clojure 14: Základy práce se systémem maker<br />
<a href="http://www.root.cz/clanky/programovaci-jazyk-clojure-14-zaklady-prace-se-systemem-maker/">http://www.root.cz/clanky/programovaci-jazyk-clojure-14-zaklady-prace-se-systemem-maker/</a>
</li>

<li>Clojure 15: Tvorba uživatelských maker<br />
<a href="http://www.root.cz/clanky/programovaci-jazyk-clojure-15-tvorba-uzivatelskych-maker/">http://www.root.cz/clanky/programovaci-jazyk-clojure-15-tvorba-uzivatelskych-maker/</a>
</li>

<li>Clojure 16: Složitější uživatelská makra<br />
<a href="http://www.root.cz/clanky/programovaci-jazyk-clojure-16-slozitejsi-uzivatelska-makra/">http://www.root.cz/clanky/programovaci-jazyk-clojure-16-slozitejsi-uzivatelska-makra/</a>
</li>

<li>Clojure 17: Využití standardních maker v praxi<br />
<a href="http://www.root.cz/clanky/programovaci-jazyk-clojure-17-vyuziti-standardnich-maker-v-praxi/">http://www.root.cz/clanky/programovaci-jazyk-clojure-17-vyuziti-standardnich-maker-v-praxi/</a>
</li>

<li>Clojure 18: Základní techniky optimalizace aplikací<br />
<a href="http://www.root.cz/clanky/programovaci-jazyk-clojure-18-zakladni-techniky-optimalizace-aplikaci/">http://www.root.cz/clanky/programovaci-jazyk-clojure-18-zakladni-techniky-optimalizace-aplikaci/</a>
</li>

<li>Clojure 19: Vývojová prostředí pro Clojure<br />
<a href="http://www.root.cz/clanky/programovaci-jazyk-clojure-19-vyvojova-prostredi-pro-clojure/">http://www.root.cz/clanky/programovaci-jazyk-clojure-19-vyvojova-prostredi-pro-clojure/</a>
</li>

<li>Clojure 20: Vývojová prostředí pro Clojure (Vimu s REPL)<br />
<a href="http://www.root.cz/clanky/programovaci-jazyk-clojure-20-vyvojova-prostredi-pro-clojure-integrace-vimu-s-repl/">http://www.root.cz/clanky/programovaci-jazyk-clojure-20-vyvojova-prostredi-pro-clojure-integrace-vimu-s-repl/</a>
</li>

<li>Clojure 21: ClojureScript aneb překlad Clojure do JS<br />
<a href="http://www.root.cz/clanky/programovaci-jazyk-clojure-21-clojurescript-aneb-preklad-clojure-do-javascriptu/">http://www.root.cz/clanky/programovaci-jazyk-clojure-21-clojurescript-aneb-preklad-clojure-do-javascriptu/</a>
</li>

<li>Leiningen: nástroj pro správu projektů napsaných v Clojure<br />
<a href="http://www.root.cz/clanky/leiningen-nastroj-pro-spravu-projektu-napsanych-v-clojure/">http://www.root.cz/clanky/leiningen-nastroj-pro-spravu-projektu-napsanych-v-clojure/</a>
</li>

<li>Leiningen: nástroj pro správu projektů napsaných v Clojure (2)<br />
<a href="http://www.root.cz/clanky/leiningen-nastroj-pro-spravu-projektu-napsanych-v-clojure-2/">http://www.root.cz/clanky/leiningen-nastroj-pro-spravu-projektu-napsanych-v-clojure-2/</a>
</li>

<li>Leiningen: nástroj pro správu projektů napsaných v Clojure (3)<br />
<a href="http://www.root.cz/clanky/leiningen-nastroj-pro-spravu-projektu-napsanych-v-clojure-3/">http://www.root.cz/clanky/leiningen-nastroj-pro-spravu-projektu-napsanych-v-clojure-3/</a>
</li>

<li>Leiningen: nástroj pro správu projektů napsaných v Clojure (4)<br />
<a href="http://www.root.cz/clanky/leiningen-nastroj-pro-spravu-projektu-napsanych-v-clojure-4/">http://www.root.cz/clanky/leiningen-nastroj-pro-spravu-projektu-napsanych-v-clojure-4/</a>
</li>

<li>Leiningen: nástroj pro správu projektů napsaných v Clojure (5)<br />
<a href="http://www.root.cz/clanky/leiningen-nastroj-pro-spravu-projektu-napsanych-v-clojure-5/">http://www.root.cz/clanky/leiningen-nastroj-pro-spravu-projektu-napsanych-v-clojure-5/</a>
</li>

<li>Leiningen: nástroj pro správu projektů napsaných v Clojure (6)<br />
<a href="http://www.root.cz/clanky/leiningen-nastroj-pro-spravu-projektu-napsanych-v-clojure-6/">http://www.root.cz/clanky/leiningen-nastroj-pro-spravu-projektu-napsanych-v-clojure-6/</a>
</li>

<li>Programovací jazyk Clojure a databáze (1.část)<br />
<a href="http://www.root.cz/clanky/programovaci-jazyk-clojure-a-databaze-1-cast/">http://www.root.cz/clanky/programovaci-jazyk-clojure-a-databaze-1-cast/</a>
</li>

<li>Pluginy pro Leiningen<br />
<a href="http://www.root.cz/clanky/leiningen-nastroj-pro-spravu-projektu-napsanych-v-clojure-pluginy-pro-leiningen/">http://www.root.cz/clanky/leiningen-nastroj-pro-spravu-projektu-napsanych-v-clojure-pluginy-pro-leiningen/</a>
</li>

<li>Programovací jazyk Clojure a knihovny pro práci s vektory a maticemi<br />
<a href="http://www.root.cz/clanky/programovaci-jazyk-clojure-a-knihovny-pro-praci-s-vektory-a-maticemi/">http://www.root.cz/clanky/programovaci-jazyk-clojure-a-knihovny-pro-praci-s-vektory-a-maticemi/</a>
</li>

<li>Programovací jazyk Clojure a knihovny pro práci s vektory a maticemi (2)<br />
<a href="http://www.root.cz/clanky/programovaci-jazyk-clojure-a-knihovny-pro-praci-s-vektory-a-maticemi-2/">http://www.root.cz/clanky/programovaci-jazyk-clojure-a-knihovny-pro-praci-s-vektory-a-maticemi-2/</a>
</li>

<li>Programovací jazyk Clojure: syntéza procedurálních textur s využitím knihovny Clisk<br />
<a href="http://www.root.cz/clanky/programovaci-jazyk-clojure-synteza-proceduralnich-textur-s-vyuzitim-knihovny-clisk/">http://www.root.cz/clanky/programovaci-jazyk-clojure-synteza-proceduralnich-textur-s-vyuzitim-knihovny-clisk/</a>
</li>

<li>Programovací jazyk Clojure: syntéza procedurálních textur s využitím knihovny Clisk (2)<br />
<a href="http://www.root.cz/clanky/programovaci-jazyk-clojure-synteza-proceduralnich-textur-s-vyuzitim-knihovny-clisk-2/">http://www.root.cz/clanky/programovaci-jazyk-clojure-synteza-proceduralnich-textur-s-vyuzitim-knihovny-clisk-2/</a>
</li>

<li>Programovací jazyk Clojure: syntéza procedurálních textur s využitím knihovny Clisk (dokončení)<br />
<a href="http://www.root.cz/clanky/programovaci-jazyk-clojure-synteza-proceduralnich-textur-s-vyuzitim-knihovny-clisk-dokonceni/">http://www.root.cz/clanky/programovaci-jazyk-clojure-synteza-proceduralnich-textur-s-vyuzitim-knihovny-clisk-dokonceni/</a>
</li>

<li>Seesaw: knihovna pro snadnou tvorbu GUI v jazyce Clojure<br />
<a href="http://www.root.cz/clanky/seesaw-knihovna-pro-snadnou-tvorbu-gui-v-jazyce-clojure/">http://www.root.cz/clanky/seesaw-knihovna-pro-snadnou-tvorbu-gui-v-jazyce-clojure/</a>
</li>

<li>Seesaw: knihovna pro snadnou tvorbu GUI v jazyce Clojure (2)<br />
<a href="http://www.root.cz/clanky/seesaw-knihovna-pro-snadnou-tvorbu-gui-v-jazyce-clojure-2/">http://www.root.cz/clanky/seesaw-knihovna-pro-snadnou-tvorbu-gui-v-jazyce-clojure-2/</a>
</li>

<li>Seesaw: knihovna pro snadnou tvorbu GUI v jazyce Clojure (3)<br />
<a href="http://www.root.cz/clanky/seesaw-knihovna-pro-snadnou-tvorbu-gui-v-jazyce-clojure-3/">http://www.root.cz/clanky/seesaw-knihovna-pro-snadnou-tvorbu-gui-v-jazyce-clojure-3/</a>
</li>

<li>Programovací jazyk Clojure a práce s Gitem<br />
<a href="http://www.root.cz/clanky/programovaci-jazyk-clojure-a-prace-s-gitem/">http://www.root.cz/clanky/programovaci-jazyk-clojure-a-prace-s-gitem/</a>
</li>

<li>Programovací jazyk Clojure a práce s Gitem (2)<br />
<a href="http://www.root.cz/clanky/programovaci-jazyk-clojure-a-prace-s-gitem-2/">http://www.root.cz/clanky/programovaci-jazyk-clojure-a-prace-s-gitem-2/</a>
</li>

<li>Programovací jazyk Clojure – triky při práci s řetězci<br />
<a href="http://www.root.cz/clanky/programovaci-jazyk-clojure-triky-pri-praci-s-retezci/">http://www.root.cz/clanky/programovaci-jazyk-clojure-triky-pri-praci-s-retezci/</a>
</li>

<li>Programovací jazyk Clojure – triky při práci s kolekcemi<br />
<a href="http://www.root.cz/clanky/programovaci-jazyk-clojure-triky-pri-praci-s-kolekcemi/">http://www.root.cz/clanky/programovaci-jazyk-clojure-triky-pri-praci-s-kolekcemi/</a>
</li>

<li>Programovací jazyk Clojure – práce s mapami a množinami<br />
<a href="http://www.root.cz/clanky/programovaci-jazyk-clojure-prace-s-mapami-a-mnozinami/">http://www.root.cz/clanky/programovaci-jazyk-clojure-prace-s-mapami-a-mnozinami/</a>
</li>

<li>Programovací jazyk Clojure – základy zpracování XML<br />
<a href="http://www.root.cz/clanky/programovaci-jazyk-clojure-zaklady-zpracovani-xml/">http://www.root.cz/clanky/programovaci-jazyk-clojure-zaklady-zpracovani-xml/</a>
</li>

<li>Programovací jazyk Clojure – testování s využitím knihovny Expectations<br />
<a href="http://www.root.cz/clanky/programovaci-jazyk-clojure-testovani-s-vyuzitim-knihovny-expectations/">http://www.root.cz/clanky/programovaci-jazyk-clojure-testovani-s-vyuzitim-knihovny-expectations/</a>
</li>

<li>Programovací jazyk Clojure – některé užitečné triky použitelné (nejenom) v&nbsp;testech<br />
<a href="http://www.root.cz/clanky/programovaci-jazyk-clojure-nektere-uzitecne-triky-pouzitelne-nejenom-v-testech/">http://www.root.cz/clanky/programovaci-jazyk-clojure-nektere-uzitecne-triky-pouzitelne-nejenom-v-testech/</a>
</li>

<li>Enlive – výkonný šablonovací systém pro jazyk Clojure<br/>
<a href="http://www.root.cz/clanky/enlive-vykonny-sablonovaci-system-pro-jazyk-clojure/">http://www.root.cz/clanky/enlive-vykonny-sablonovaci-system-pro-jazyk-clojure/</a>
</li>

<li>Nástroj Leiningen a programovací jazyk Clojure: tvorba vlastních knihoven pro veřejný repositář Clojars<br />
<a href="http://www.root.cz/clanky/nastroj-leiningen-a-programovaci-jazyk-clojure-tvorba-vlastnich-knihoven-pro-verejny-repositar-clojars/">http://www.root.cz/clanky/nastroj-leiningen-a-programovaci-jazyk-clojure-tvorba-vlastnich-knihoven-pro-verejny-repositar-clojars/</a>
</li>

<li>Novinky v Clojure verze 1.8.0<br />
<a href="http://www.root.cz/clanky/novinky-v-clojure-verze-1-8-0/">http://www.root.cz/clanky/novinky-v-clojure-verze-1-8-0/</a>
</li>

<li>Asynchronní programování v&nbsp;Clojure s&nbsp;využitím knihovny core.async<br />
<a href="http://www.root.cz/clanky/asynchronni-programovani-v-clojure-s-vyuzitim-knihovny-core-async/">http://www.root.cz/clanky/asynchronni-programovani-v-clojure-s-vyuzitim-knihovny-core-async/</a>
</li>

<li>Asynchronní programování v&nbsp;Clojure s&nbsp;využitím knihovny core.async (pokračování)<br />
<a href="http://www.root.cz/clanky/asynchronni-programovani-v-clojure-s-vyuzitim-knihovny-core-async-pokracovani/">http://www.root.cz/clanky/asynchronni-programovani-v-clojure-s-vyuzitim-knihovny-core-async-pokracovani/</a>
</li>

<li>Asynchronní programování v Clojure s využitím knihovny core.async (dokončení)<br />
<a href="http://www.root.cz/clanky/asynchronni-programovani-v-clojure-s-vyuzitim-knihovny-core-async-dokonceni/">http://www.root.cz/clanky/asynchronni-programovani-v-clojure-s-vyuzitim-knihovny-core-async-dokonceni/</a>
</li>

</ol>



<p><a name="k14"></a></p>
<h2 id="k14">14. Odkazy na Internetu</h2>

<ol>

<li>Communicating sequential processes<br />
<a href="https://en.wikipedia.org/wiki/Communicating_sequential_processes">https://en.wikipedia.org/wiki/Communicating_sequential_processes</a>
</li>

<li>Clojure core.async<br />
<a href="http://www.infoq.com/presentations/clojure-core-async">http://www.infoq.com/presentations/clojure-core-async</a>
</li>

<li>core.async API Reference<br />
<a href="https://clojure.github.io/core.async/">https://clojure.github.io/core.async/</a>
</li>

<li>Clojure core.async Channels<br />
<a href="http://clojure.com/blog/2013/06/28/clojure-core-async-channels.html">http://clojure.com/blog/2013/06/28/clojure-core-async-channels.html</a>
</li>

<li>core.async examples<br />
<a href="https://github.com/clojure/core.async/blob/master/examples/walkthrough.clj">https://github.com/clojure/core.async/blob/master/examples/walkthrough.clj</a>
</li>

<li>Timothy Baldridge - Core.Async<br />
<a href="https://www.youtube.com/watch?v=enwIIGzhahw">https://www.youtube.com/watch?v=enwIIGzhahw</a>
</li>

<li>Designing Front End Applications with core.async<br />
<a href="http://go.cognitect.com/core_async_webinar_recording">http://go.cognitect.com/core_async_webinar_recording</a>
</li>

<li>Mastering Concurrent Processes with core.async<br />
<a href="http://www.braveclojure.com/core-async/">http://www.braveclojure.com/core-async/</a>
</li>

<li>LispCast: Clojure core.async<br />
<a href="https://www.youtube.com/watch?v=msv8Fvtd6YQ">https://www.youtube.com/watch?v=msv8Fvtd6YQ</a>
</li>

<li>Julian Gamble - Applying the paradigms of core.async in ClojureScript<br />
<a href="https://www.youtube.com/watch?v=JUrOebC5HmA">https://www.youtube.com/watch?v=JUrOebC5HmA</a>
</li>

<li>Zip archiv s&nbsp;Clojure 1.8.0<br />
<a href="http://repo1.maven.org/maven2/org/clojure/clojure/1.8.0/clojure-1.8.0.zip">http://repo1.maven.org/maven2/org/clojure/clojure/1.8.0/clojure-1.8.0.zip</a>
</li>

<li>Clojure 1.8 is now available<br />
<a href="http://clojure.org/news/2016/01/19/clojure18">http://clojure.org/news/2016/01/19/clojure18</a>
</li>

<li>Changes to Clojure in Version 1.8<br />
<a href="https://github.com/clojure/clojure/blob/master/changes.md">https://github.com/clojure/clojure/blob/master/changes.md</a>
</li>

<li>Socket Server REPL<br />
<a href="http://dev.clojure.org/display/design/Socket+Server+REPL">http://dev.clojure.org/display/design/Socket+Server+REPL</a>
</li>

<li>CLJ-1671: Clojure socket server<br />
<a href="http://dev.clojure.org/jira/browse/CLJ-1671">http://dev.clojure.org/jira/browse/CLJ-1671</a>
</li>

<li>CLJ-1449: Add clojure.string functions for portability to ClojureScript<br />
<a href="http://dev.clojure.org/jira/browse/CLJ-1449">http://dev.clojure.org/jira/browse/CLJ-1449</a>
</li>

<li>Launching a Socket Server<br />
<a href="http://clojure.org/reference/repl_and_main#_launching_a_socket_server">http://clojure.org/reference/repl_and_main#_launching_a_socket_server</a>
</li>

<li>API for clojure.string<br />
<a href="http://clojure.github.io/clojure/branch-master/clojure.string-api.html">http://clojure.github.io/clojure/branch-master/clojure.string-api.html</a>
</li>

<li>Clojars:<br />
<a href="https://clojars.org/">https://clojars.org/</a>
</li>

<li>Seznam knihoven na Clojars:<br />
<a href="https://clojars.org/projects">https://clojars.org/projects</a>
</li>

<li>Clojure Cookbook: Templating HTML with Enlive<br />
<a href="https://github.com/clojure-cookbook/clojure-cookbook/blob/master/07_webapps/7-11_enlive.asciidoc">https://github.com/clojure-cookbook/clojure-cookbook/blob/master/07_webapps/7-11_enlive.asciidoc</a>
</li>

<li>An Introduction to Enlive<br />
<a href="https://github.com/swannodette/enlive-tutorial/">https://github.com/swannodette/enlive-tutorial/</a>
</li>

<li>Enlive na GitHubu<br />
<a href="https://github.com/cgrand/enlive">https://github.com/cgrand/enlive</a>
</li>

<li>Expectations: příklady atd.<br />
<a href="http://jayfields.com/expectations/">http://jayfields.com/expectations/</a>
</li>

<li>Expectations na GitHubu<br />
<a href="https://github.com/jaycfields/expectations">https://github.com/jaycfields/expectations</a>
</li>

<li>Lein-expectations na GitHubu<br />
<a href="https://github.com/gar3thjon3s/lein-expectations">https://github.com/gar3thjon3s/lein-expectations</a>
</li>

<li>Testing Clojure With Expectations<br />
<a href="https://semaphoreci.com/blog/2014/09/23/testing-clojure-with-expectations.html">https://semaphoreci.com/blog/2014/09/23/testing-clojure-with-expectations.html</a>
</li>

<li>Clojure testing TDD/BDD libraries: clojure.test vs Midje vs Expectations vs Speclj<br />
<a href="https://www.reddit.com/r/Clojure/comments/1viilt/clojure_testing_tddbdd_libraries_clojuretest_vs/">https://www.reddit.com/r/Clojure/comments/1viilt/clojure_testing_tddbdd_libraries_clojuretest_vs/</a>
</li>

<li>Testing: One assertion per test<br />
<a href="http://blog.jayfields.com/2007/06/testing-one-assertion-per-test.html">http://blog.jayfields.com/2007/06/testing-one-assertion-per-test.html</a>
</li>

<li>Rewriting Your Test Suite in Clojure in 24 hours<br />
<a href="http://blog.circleci.com/rewriting-your-test-suite-in-clojure-in-24-hours/">http://blog.circleci.com/rewriting-your-test-suite-in-clojure-in-24-hours/</a>
</li>

<li>Clojure doc: zipper<br />
<a href="http://clojuredocs.org/clojure.zip/zipper">http://clojuredocs.org/clojure.zip/zipper</a>
</li>

<li>Clojure doc: parse<br />
<a href="http://clojuredocs.org/clojure.xml/parse">http://clojuredocs.org/clojure.xml/parse</a>
</li>

<li>Clojure doc: xml-zip<br />
<a href="http://clojuredocs.org/clojure.zip/xml-zip">http://clojuredocs.org/clojure.zip/xml-zip</a>
</li>

<li>Clojure doc: xml-seq<br />
<a href="http://clojuredocs.org/clojure.core/xml-seq">http://clojuredocs.org/clojure.core/xml-seq</a>
</li>

<li>Parsing XML in Clojure<br />
<a href="https://github.com/clojuredocs/guides">https://github.com/clojuredocs/guides</a>
</li>

<li>Clojure Zipper Over Nested Vector<br />
<a href="https://vitalyper.wordpress.com/2010/11/23/clojure-zipper-over-nested-vector/">https://vitalyper.wordpress.com/2010/11/23/clojure-zipper-over-nested-vector/</a>
</li>

<li>Understanding Clojure's PersistentVector implementation<br />
<a href="http://blog.higher-order.net/2009/02/01/understanding-clojures-persistentvector-implementation">http://blog.higher-order.net/2009/02/01/understanding-clojures-persistentvector-implementation</a>
</li>

<li>Understanding Clojure's PersistentHashMap (deftwice...)<br />
<a href="http://blog.higher-order.net/2009/09/08/understanding-clojures-persistenthashmap-deftwice.html">http://blog.higher-order.net/2009/09/08/understanding-clojures-persistenthashmap-deftwice.html</a>
</li>

<li>Assoc and Clojure's PersistentHashMap: part ii<br />
<a href="http://blog.higher-order.net/2010/08/16/assoc-and-clojures-persistenthashmap-part-ii.html">http://blog.higher-order.net/2010/08/16/assoc-and-clojures-persistenthashmap-part-ii.html</a>
</li>

<li>Ideal Hashtrees (paper)<br />
<a href="http://lampwww.epfl.ch/papers/idealhashtrees.pdf">http://lampwww.epfl.ch/papers/idealhashtrees.pdf</a>
</li>

<li>Clojure home page<br />
<a href="http://clojure.org/">http://clojure.org/</a>
</li>

<li>Clojure (downloads)<br />
<a href="http://clojure.org/downloads">http://clojure.org/downloads</a>
</li>

<li>Clojure Sequences<br />
<a href="http://clojure.org/sequences">http://clojure.org/sequences</a>
</li>

<li>Clojure Data Structures<br />
<a href="http://clojure.org/data_structures">http://clojure.org/data_structures</a>
</li>

<li>The Structure and Interpretation of Computer Programs: 2.2.1  Representing Sequences<br />
<a href="http://mitpress.mit.edu/sicp/full-text/book/book-Z-H-15.html#%_sec_2.2.1">http://mitpress.mit.edu/sicp/full-text/book/book-Z-H-15.html#%_sec_2.2.1</a>
</li>

<li>The Structure and Interpretation of Computer Programs: 3.3.1  Mutable List Structure<br />
<a href="http://mitpress.mit.edu/sicp/full-text/book/book-Z-H-22.html#%_sec_3.3.1">http://mitpress.mit.edu/sicp/full-text/book/book-Z-H-22.html#%_sec_3.3.1</a>
</li>

<li>Clojure - Functional Programming for the JVM<br />
<a href="http://java.ociweb.com/mark/clojure/article.html">http://java.ociweb.com/mark/clojure/article.html</a>
</li>

<li>Clojure quick reference<br />
<a href="http://faustus.webatu.com/clj-quick-ref.html">http://faustus.webatu.com/clj-quick-ref.html</a>
</li>

<li>4Clojure<br />
<a href="http://www.4clojure.com/">http://www.4clojure.com/</a>
</li>

<li>ClojureDoc (rozcestník s&nbsp;dokumentací jazyka Clojure)<br />
<a href="http://clojuredocs.org/">http://clojuredocs.org/</a>
</li>

<li>Clojure (na Wikipedia EN)<br />
<a href="http://en.wikipedia.org/wiki/Clojure">http://en.wikipedia.org/wiki/Clojure</a>
</li>

<li>Clojure (na Wikipedia CS)<br />
<a href="http://cs.wikipedia.org/wiki/Clojure">http://cs.wikipedia.org/wiki/Clojure</a>
</li>

<li>SICP (The Structure and Interpretation of Computer Programs)<br />
<a href="http://mitpress.mit.edu/sicp/">http://mitpress.mit.edu/sicp/</a>
</li>

<li>Pure function<br />
<a href="http://en.wikipedia.org/wiki/Pure_function">http://en.wikipedia.org/wiki/Pure_function</a>
</li>

<li>Funkcionální programování<br />
<a href="http://cs.wikipedia.org/wiki/Funkcionální_programování">http://cs.wikipedia.org/wiki/Funkcionální_programování</a>
</li>

<li>Čistě funkcionální (datové struktury, jazyky, programování)<br />
<a href="http://cs.wikipedia.org/wiki/Čistě_funkcionální">http://cs.wikipedia.org/wiki/Čistě_funkcionální</a>
</li>

<li>Clojure Macro Tutorial (Part I, Getting the Compiler to Write Your Code For You)<br />
<a href="http://www.learningclojure.com/2010/09/clojure-macro-tutorial-part-i-getting.html">http://www.learningclojure.com/2010/09/clojure-macro-tutorial-part-i-getting.html</a>
</li>

<li>Clojure Macro Tutorial (Part II: The Compiler Strikes Back)<br />
<a href="http://www.learningclojure.com/2010/09/clojure-macro-tutorial-part-ii-compiler.html">http://www.learningclojure.com/2010/09/clojure-macro-tutorial-part-ii-compiler.html</a>
</li>

<li>Clojure Macro Tutorial (Part III: Syntax Quote)<br />
<a href="http://www.learningclojure.com/2010/09/clojure-macro-tutorial-part-ii-syntax.html">http://www.learningclojure.com/2010/09/clojure-macro-tutorial-part-ii-syntax.html</a>
</li>

<li>Tech behind Tech: Clojure Macros Simplified<br />
<a href="http://techbehindtech.com/2010/09/28/clojure-macros-simplified/">http://techbehindtech.com/2010/09/28/clojure-macros-simplified/</a>
</li>

<li>Fatvat - Exploring functional programming: Clojure Macros<br />
<a href="http://www.fatvat.co.uk/2009/02/clojure-macros.html">http://www.fatvat.co.uk/2009/02/clojure-macros.html</a>
</li>

<li>Eulerovo číslo<br />
<a href="http://cs.wikipedia.org/wiki/Eulerovo_číslo">http://cs.wikipedia.org/wiki/Eulerovo_číslo</a>
</li>

<li>List comprehension<br />
<a href="http://en.wikipedia.org/wiki/List_comprehension">http://en.wikipedia.org/wiki/List_comprehension</a>
</li>

<li>List Comprehensions in Clojure<br />
<a href="http://asymmetrical-view.com/2008/11/18/list-comprehensions-in-clojure.html">http://asymmetrical-view.com/2008/11/18/list-comprehensions-in-clojure.html</a>
</li>

<li>Clojure Programming Concepts: List Comprehension<br />
<a href="http://en.wikibooks.org/wiki/Clojure_Programming/Concepts#List_Comprehension">http://en.wikibooks.org/wiki/Clojure_Programming/Concepts#List_Comprehension</a>
</li>

<li>Clojure core API: for macro<br />
<a href="http://clojure.github.com/clojure/clojure.core-api.html#clojure.core/for">http://clojure.github.com/clojure/clojure.core-api.html#clojure.core/for</a>
</li>

<li>cirrus machina - The Clojure for macro<br />
<a href="http://www.cirrusmachina.com/blog/comment/the-clojure-for-macro/">http://www.cirrusmachina.com/blog/comment/the-clojure-for-macro/</a>
</li>

<li>Riastradh's Lisp Style Rules<br />
<a href="http://mumble.net/~campbell/scheme/style.txt">http://mumble.net/~campbell/scheme/style.txt</a>
</li>

<li>Dynamic Languages Strike Back<br />
<a href="http://steve-yegge.blogspot.cz/2008/05/dynamic-languages-strike-back.html">http://steve-yegge.blogspot.cz/2008/05/dynamic-languages-strike-back.html</a>
</li>

<li>Scripting: Higher Level Programming for the 21st Century<br />
<a href="http://www.tcl.tk/doc/scripting.html">http://www.tcl.tk/doc/scripting.html</a>
</li>

<li>Java Virtual Machine Support for Non-Java Languages<br />
<a href="http://docs.oracle.com/javase/7/docs/technotes/guides/vm/multiple-language-support.html">http://docs.oracle.com/javase/7/docs/technotes/guides/vm/multiple-language-support.html</a>
</li>

<li>Třída java.lang.String<br />
<a href="http://docs.oracle.com/javase/7/docs/api/java/lang/String.html">http://docs.oracle.com/javase/7/docs/api/java/lang/String.html</a>
</li>

<li>Třída java.lang.StringBuffer<br />
<a href="http://docs.oracle.com/javase/7/docs/api/java/lang/StringBuffer.html">http://docs.oracle.com/javase/7/docs/api/java/lang/StringBuffer.html</a>
</li>

<li>Třída java.lang.StringBuilder<br />
<a href="http://docs.oracle.com/javase/7/docs/api/java/lang/StringBuilder.html">http://docs.oracle.com/javase/7/docs/api/java/lang/StringBuilder.html</a>
</li>

<li>StringBuffer versus String<br />
<a href="http://www.javaworld.com/article/2076072/build-ci-sdlc/stringbuffer-versus-string.html">http://www.javaworld.com/article/2076072/build-ci-sdlc/stringbuffer-versus-string.html</a>
</li>

<li>Threading macro (dokumentace k&nbsp;jazyku Clojure)<br />
<a href="https://clojure.github.io/clojure/clojure.core-api.html#clojure.core/-&gt;">https://clojure.github.io/clojure/clojure.core-api.html#clojure.core/-&gt;</a>
</li>

<li>Understanding the Clojure -&gt; macro<br />
<a href="http://blog.fogus.me/2009/09/04/understanding-the-clojure-macro/">http://blog.fogus.me/2009/09/04/understanding-the-clojure-macro/</a>
</li>

<li>clojure.inspector<br />
<a href="http://clojure.github.io/clojure/clojure.inspector-api.html">http://clojure.github.io/clojure/clojure.inspector-api.html</a>
</li>

<li>The Clojure Toolbox<br />
<a href="http://www.clojure-toolbox.com/">http://www.clojure-toolbox.com/</a>
</li>

<li>Unit Testing in Clojure<br />
<a href="http://nakkaya.com/2009/11/18/unit-testing-in-clojure/">http://nakkaya.com/2009/11/18/unit-testing-in-clojure/</a>
</li>

<li>Testing in Clojure (Part-1: Unit testing)<br />
<a href="http://blog.knoldus.com/2014/03/22/testing-in-clojure-part-1-unit-testing/">http://blog.knoldus.com/2014/03/22/testing-in-clojure-part-1-unit-testing/</a>
</li>

<li>API for clojure.test - Clojure v1.6 (stable)<br />
<a href="https://clojure.github.io/clojure/clojure.test-api.html">https://clojure.github.io/clojure/clojure.test-api.html</a>
</li>

<li>Leiningen: úvodní stránka<br />
<a href="http://leiningen.org/">http://leiningen.org/</a>
</li>

<li>Leiningen: Git repository<br />
<a href="https://github.com/technomancy/leiningen">https://github.com/technomancy/leiningen</a>
</li>

<li>leiningen-win-installer<br />
<a href="http://leiningen-win-installer.djpowell.net/">http://leiningen-win-installer.djpowell.net/</a>
</li>

<li>Clojure.org: Vars and the Global Environment<br />
<a href="http://clojure.org/Vars">http://clojure.org/Vars</a>
</li>

<li>Clojure.org: Refs and Transactions<br />
<a href="http://clojure.org/Refs">http://clojure.org/Refs</a>
</li>

<li>Clojure.org: Atoms<br />
<a href="http://clojure.org/Atoms">http://clojure.org/Atoms</a>
</li>

<li>Clojure.org: Agents as Asynchronous Actions<br />
<a href="http://clojure.org/agents">http://clojure.org/agents</a>
</li>

<li>Transient Data Structures
<a href="http://clojure.org/transients">http://clojure.org/transients</a>
</li>

</ol>



<p></p><p></p>
<p><small>Autor: <a href="http://www.fit.vutbr.cz/~tisnovpa">Pavel Tišnovský</a> &nbsp; 2016</small></p>
</body>
</html>

