<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
        "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html>
<head>
<title>Babashka - interpret Clojure určený pro rychlé spouštění utilit z příkazového řádku</title>
<meta name="Author" content="Pavel Tisnovsky" />
<meta name="Generator" content="vim" />
<meta http-equiv="content-type" content="text/html; charset=utf-8" />
<style type="text/css">
         body {color:#000000; background:#ffffff;}
         h1  {font-family: arial, helvetica, sans-serif; color:#ffffff; background-color:#c00000; text-align:center; padding-left:1em}
         h2  {font-family: arial, helvetica, sans-serif; color:#ffffff; background-color:#0000c0; padding-left:1em; text-align:left}
         h3  {font-family: arial, helvetica, sans-serif; color:#000000; background-color:#c0c0c0; padding-left:1em; text-align:left}
         h4  {font-family: arial, helvetica, sans-serif; color:#000000; background-color:#e0e0e0; padding-left:1em; text-align:left}
         a   {font-family: arial, helvetica, sans-serif;}
         li  {font-family: arial, helvetica, sans-serif; color:#000000; text-align:justify; width:450px;}
         ol  {font-family: arial, helvetica, sans-serif; color:#000000; text-align:justify; width:450px;}
         ul  {font-family: arial, helvetica, sans-serif; color:#000000; text-align:justify; width:450px;}
         p   {font-family: arial, helvetica, sans-serif; color:#000000; text-align:justify;}
         pre {background:#e0e0e0}
</style>
</head>

<body>

<h1>Babashka - interpret Clojure určený pro rychlé spouštění utilit z příkazového řádku</h1>

<h3>Pavel Tišnovský</h3>

<p></p>

<h1>Úvodník</h1>

<p>Jazyk Clojure existuje ve třech oficiálně podporovaných variantách. Především se jedná o variantu pro JVM, dále pak o variantu pro CLR a nakonec existuje ClojureScript. Ovšem žádná z těchto variant se nehodí pro psaní utilit pro příkazový řádek. Řešení představuje projekt Babashka.</p>



<h2>Obsah</h2>

<p><a href="#k01">1. Babashka &ndash; interpret Clojure určený pro rychlé spouštění utilit z příkazového řádku</a></p>
<p><a href="#k02">2. Instalace Babashky a první otestování základní funkcionality</a></p>
<p><a href="#k03">3. Jak rychlé je spouštění skriptů, informace o spotřebě dalších prostředků</a></p>
<p><a href="#k04">4. Použití <i>shebangu</i> pro spuštění skriptů</a></p>
<p><a href="#k05">5. Implicitní výstup ze skriptu</a></p>
<p><a href="#k06">6. Hodnota navázaná na symbol <strong>*input*</strong></a></p>
<p><a href="#k07">7. Dostupné balíčky</a></p>
<p><a href="#k08">8. Výstup do JSONu</a></p>
<p><a href="#k09">9. Zpracování argumentů předaných na příkazové řádce</a></p>
<p><a href="#k10">10. Základní práce s&nbsp;HTTP/HTTPS popř.&nbsp;s&nbsp;REST API</a></p>
<p><a href="#k11">11. Zpracování dat vracených ve formátu JSON</a></p>
<p><a href="#k12">12. Ukázka síly jazyka Clojure &ndash; threading makro</a></p>
<p><a href="#k13">*** 13. Využití dalších vlastností Clojure &ndash; výpočty s&nbsp;neomezeným rozsahem hodnot</a></p>
<p><a href="#k14">*** 14. Datový typ <i>double</i> a počítání se zlomky</a></p>
<p><a href="#k15">15. Výpočty ve více vláknech &ndash; <strong>map</strong> versus <strong>pmap</strong></a></p>
<p><a href="#k16">16. Porovnání rychlosti výpočtů Babashky s&nbsp;implementací Clojure pro JVM</a></p>
<p><a href="#k17">17. Zobrazení nápovědy přímo v&nbsp;interaktivní smyčce REPL</a></p>
<p><a href="#k18">18. Repositář s&nbsp;demonstračními příklady</a></p>
<p><a href="#k19">19. Odkazy na předchozí části seriálu o programovacím jazyku Clojure</a></p>
<p><a href="#k20">20. Odkazy na Internetu</a></p>



<p><a name="k01"></a></p>
<h2 id="k01">1. Babashka &ndash; interpret Clojure určený pro rychlé spouštění utilit z příkazového řádku</h2>

<p>S&nbsp;programovacím jazykem <a
href="https://www.root.cz/vyhledavani/?qs=clojure">Clojure</a> jsme se již na
stránkách Roota mnohokrát setkali. Popisovali jsme si jak interpret a překladač
běžící nad JVM, tak i (i když ve stručnosti) <i>ClojureScript</i>, tedy
transpřekladač z&nbsp;Clojure do JavaScriptu. Tyto dvě implementace Clojure
mají jednu společnou (a dosti nepěknou) vlastnost &ndash; spuštění skriptů
popř.&nbsp;spuštění interaktivní smyčky REPL je dosti zdlouhavé a i na nových
výkonných počítačích může trvat několik sekund. To sice nevadí při delší práci
(představme si programátora, který má REPL otevřený celý pracovní den), ovšem i
z&nbsp;tohoto důvodu se Clojure nepoužívá pro psaní skriptů, které mají být
rychle spouštěny z&nbsp;příkazové řádky. Taktéž delší inicializace REPLu není
příliš dobrým &bdquo;reklamním materiálem&ldquo; tohoto jazyka, i když výsledné
aplikace přeložené do bajtkódu a JITované v&nbsp;JVM mají většinou velmi dobrou
výkonnost.</p>

<p>Řešení tohoto problému spočívá v&nbsp;použití nástroje nazvaného
<i>Babashka</i>. Jedná se o interpret Clojure naprogramovaný taktéž
v&nbsp;Clojure (což není ve světě LISPu nic neobvyklého). Ovšem tento interpret
je přeložen do nativního kódu s&nbsp;využitím <i>GraalVM</i>, takže výsledkem
je spustitelný (binární) soubor. Důležité je, že je spustitelný prakticky
okamžitě, takže REPL či interpretace skriptů spouštěných z&nbsp;příkazové řádky
či z&nbsp;BASHe je již velmi dobře možná. Navíc je <i>Babashka</i> dodávána
&bdquo;včetně baterií&ldquo;, což znamená, že holý interpret je doplněn mnoha
užitečnými balíčky &ndash; viz též <a href="#k07">sedmou kapitolu</a>.</p>



<p><a name="k02"></a></p>
<h2 id="k02">2. Instalace Babashky a první otestování základní funkcionality</h2>

<p>Instalace Babashky je popsána na stránce <a
href="https://github.com/borkdude/babashka#quickstart">https://github.com/borkdude/babashka#quickstart</a>.
Nejprve je nutné stáhnout krátký instalační skript:</p>

<pre>
$ <strong>curl -s https://raw.githubusercontent.com/borkdude/babashka/master/install -o install-babashka</strong>
</pre>

<p>Nyní je vhodné si prohlédnout, co skript dělá, protože ho budeme spouštět
s&nbsp;právy roota:</p>

<pre>
$ <strong>chmod +x install-babashka &amp;&amp; sudo ./install-babashka</strong>
</pre>

<p>Výsledný spustitelný soubor by měl být dostupný v&nbsp;podadresáři
<strong>/usr/local/bin</strong>, o čemž se můžeme snadno přesvědčit:</p>

<pre>
$ <strong>ls -l /usr/local/bin</strong>
</pre>

<p>Stažený a nainstalovaný nástroj Babashka je zobrazen na prvním místě:</p>

<pre>
total 184948
-rwxr-xr-x. 1 root root  67231896 Jun 27 13:39 bb
-rwxr-xr-x. 1 root root       218 Oct  9  2019 flake8
-rwxr-xr-x. 1 root root       384 Oct  9  2019 futurize
-rwxr-xr-x. 1 root root 120350344 Sep 27  2019 oc
-rwxr-xr-x. 1 root root       388 Oct  9  2019 pasteurize
-rwxr-xr-x. 1 root root       216 Oct  9  2019 pycodestyle
-rwxr-xr-x. 1 root root       215 Oct  8  2019 pyflakes
-rwxr-xr-x. 1 root root       208 Oct  9  2019 radon
-rwxr-xr-x. 1 root root       213 Oct  3  2019 virtualenv
-rwxr-xr-x. 1 root root       215 Oct  8  2019 vulture
-rwxr-xr-x. 1 root root   1750603 Mar 23 21:15 youtube-dl
</pre>

<p><div class="rs-tip-major">Poznámka: alternativně je možné stažení provést
ručně a spustitelný soubor umístit například do <strong>~/bin</strong> nebo
<strong>/opt/bin</strong>, a to bez nutnosti použití rootovských
práv.</div></p>

<p>Kontrola, zda je interpret skutečně spustitelný:</p>

<pre>
$ <strong>bb --help</strong>
&nbsp;
Babashka v0.1.3
&nbsp;
Options must appear in the order of groups mentioned below.
&nbsp;
Help:
&nbsp;
  --help, -h or -?    Print this help text.
  --version           Print the current version of babashka.
  --describe          Print an EDN map with information about this version of babashka.
&nbsp;
In- and output flags:
&nbsp;
  -i                  Bind *input* to a lazy seq of lines from stdin.
  -I                  Bind *input* to a lazy seq of EDN values from stdin.
  -o                  Write lines to stdout.
  -O                  Write EDN values to stdout.
  --stream            Stream over lines or EDN values from stdin. Combined with -i or -I *input* becomes a single value per iteration.
&nbsp;
Uberscript:
&nbsp;
  --uberscript &lt;file&gt; Collect preloads, -e, -f and -m and all required namespaces from the classpath into a single executable file.
&nbsp;
Evaluation:
&nbsp;
  -e, --eval &lt;expr&gt;   Evaluate an expression.
  -f, --file &lt;path&gt;   Evaluate a file.
  -cp, --classpath    Classpath to use.
  -m, --main &lt;ns&gt;     Call the -main function from namespace with args.
  --verbose           Print entire stacktrace in case of exception.
&nbsp;
REPL:
&nbsp;
  --repl              Start REPL. Use rlwrap for history.
  --socket-repl       Start socket REPL. Specify port (e.g. 1666) or host and port separated by colon (e.g. 127.0.0.1:1666).
  --nrepl-server      Start nREPL server. Specify port (e.g. 1667) or host and port separated by colon (e.g. 127.0.0.1:1667).
&nbsp;
If neither -e, -f, or --socket-repl are specified, then the first argument that
is not parsed as a option is treated as a file if it exists, or as an
expression otherwise. Everything after that is bound to *command-line-args*.
Use -- to separate script command lin args from bb command line args.
</pre>

<p>Můžeme si vyzkoušet i interaktivní smyčku REPL:</p>

<pre>
$ <strong>bb</strong>
&nbsp;
Babashka v0.1.3 REPL.
Use :repl/quit or :repl/exit to quit the REPL.
Clojure rocks, Bash reaches.
&nbsp;
user=&gt;
</pre>

<p><div class="rs-tip-major">Poznámka: na rozdíl od REPL dostupného přes
Leiningen by se měl REPL Babashky spustit prakticky okamžitě.</div></p>

<p>Poslední jednoduchý test &ndash; pokusíme se interpretovat následující
skript:</p>

<pre>
(println "Hello" "world")
</pre>

<p>Spuštění interpretru:</p>

<pre>
$ <strong>bb 01_hello.clj</strong>
&nbsp;
Hello world
</pre>



<p><a name="k03"></a></p>
<h2 id="k03">3. Jak rychlé je spouštění skriptů, informace o spotřebě dalších prostředků</h2>

<p>Vyzkoušejme si nyní, jak rychle je spuštěn a dokončen skript &bdquo;Hello
world&ldquo;:</p>

<pre>
$ <strong>time bb 01_hello.clj</strong>
&nbsp;
Hello world
&nbsp;
real    0m0.030s
user    0m0.010s
sys     0m0.017s
</pre>

<p>To není špatné; navíc se <strong>bb</strong> uložil do bufferu, takže druhé
spuštění bude ještě rychlejší:</p>

<pre>
$ <strong>time bb 01_hello.clj</strong>
&nbsp;
Hello world
&nbsp;
real    0m0.014s
user    0m0.003s
sys     0m0.011s
</pre>

<p>Výsledek: spuštění interpretru je prakticky okamžité; žádné prodlevy, které
známe z&nbsp;použití Leiningenu, zde nejsou patrné!</p>

<p>Ještě se podívejme, jaké vlastnosti má spuštěný proces z&nbsp;interpretrem.
Vytvoříme nový skript, který po svém spuštění čeká na stisk klávesy Enter:</p>

<pre>
(println "Press Enter to continue...")
(read-line)
</pre>

<p>Skript spustíme v&nbsp;interpretru:</p>

<pre>
$ <strong>bb 02_wait_for_user.clj</strong>
Press Enter to continue...
</pre>

<p>Nalezneme PID procesu s&nbsp;interpretrem (je to první PID):</p>

<pre>
$ <strong>ps ax |grep 02_wait_for_user</strong>
&nbsp;
14649 pts/1    Sl+    0:00 bb 02_wait_for_user.clj
14758 pts/2    S+     0:00 grep 02_wait_for_user
</pre>

<p>A podíváme se na podrobnější informace o tomto procesu, které jsou
poskytované jádrem operačního systému:</p>

<pre>
$ <strong>cat /proc/14649/status</strong>
</pre>

<pre>
Name:   bb
Umask:  0002
State:  S (sleeping)
Tgid:   14649
Ngid:   0
Pid:    14649
PPid:   29490
TracerPid:      0
Uid:    1000    1000    1000    1000
Gid:    1000    1000    1000    1000
FDSize: 256
Groups: 39 982 1000 1001
NStgid: 14649
NSpid:  14649
NSpgid: 14649
NSsid:  29490
VmPeak:   227912 kB
VmSize:   163400 kB
VmLck:         0 kB
VmPin:         0 kB
VmHWM:     38576 kB
VmRSS:     38576 kB
RssAnon:            7012 kB
RssFile:           31564 kB
RssShmem:              0 kB
VmData:    23776 kB
VmStk:       132 kB
VmExe:     57612 kB
VmLib:         0 kB
VmPTE:       200 kB
VmSwap:        0 kB
HugetlbPages:          0 kB
CoreDumping:    0
Threads:        2
SigQ:   0/61760
SigPnd: 0000000000000000
ShdPnd: 0000000000000000
SigBlk: 0000000000000000
SigIgn: 0000000000000000
SigCgt: 2000000180001402
CapInh: 0000000000000000
CapPrm: 0000000000000000
CapEff: 0000000000000000
CapBnd: 0000003fffffffff
CapAmb: 0000000000000000
NoNewPrivs:     0
Seccomp:        0
Speculation_Store_Bypass:       thread vulnerable
Cpus_allowed:   ff
Cpus_allowed_list:      0-7
Mems_allowed:   00000000,00000000,00000000,00000000,00000000,00000000,00000000,00000000,00000000,00000000,00000000,00000000,00000000,00000000,00000000,00000000,00000000,00000000,00000000,00000000,00000000,00000000,00000000,00000000,00000000,00000000,00000000,00000000,00000000,00000000,00000000,00000001
Mems_allowed_list:      0
voluntary_ctxt_switches:        9
nonvoluntary_ctxt_switches:     1
</pre>

<p><div class="rs-tip-major">Poznámka: důležité jsou především informace
začínající na &bdquo;Vm&ldquo;, které nám ukazují spotřebu operační paměti
(RSS). Ta je &ndash; alespoň na dnešní poměry :-) &ndash; relativně malá a opět
se jedná o mnohem menší hodnoty, než dvě či tři spuštěné JVM v&nbsp;případě
použití Leiningenu.</div></p>



<p><a name="k04"></a></p>
<h2 id="k04">4. Použití <i>shebangu</i> pro spuštění skriptů</h2>

<p>Babashka je primárně určena pro tvorbu pomocných skriptů, které jsou příliš
složité na to, aby je programátor či administrátor psal v&nbsp;BASHi. Takové
skripty (nebo řekněme nástroje či filtry) se většinou nespouští zadáním názvu
interpretru, ale přímo. I to je možné, protože můžeme na začátku skriptů použít
známý <i>shebang</i>, který může obsahovat přímo cestu k&nbsp;interpretru:</p>

<pre>
<i>#!/usr/local/bin/bb</i>
&nbsp;
(println "Hello" "world")
</pre>

<p>Nastavíme atribut <strong>x</strong> u skriptu:</p>

<pre>
$ <strong>chmod u+x 03_shebang.clj</strong>
</pre>

<p>A můžeme ho přímo spustit:</p>

<pre>
$ <strong>./03_shebang.clj</strong>
&nbsp;
Hello world
</pre>

<p><div class="rs-tip-major">Poznámka: samozřejmě vůbec není nutné používat
koncovku &bdquo;.clj&ldquo;</div></p>

<p>Čistější je spustit skript v&nbsp;modifikovaném prostředí, tudíž
<i>shebang</i> příslušným způsobem změníme:</p>

<pre>
<i>#!/usr/bin/env bb</i>
&nbsp;
(println "Hello" "world")
</pre>

<p>Použití je naprosto stejné, jako v&nbsp;předchozím příkladu:</p>

<pre>
$ <strong>chmod u+x 04_shebang.clj</strong>
&nbsp;
$ <strong>./04_shebang.clj</strong>
Hello world
</pre>



<p><a name="k05"></a></p>
<h2 id="k05">5. Implicitní výstup ze skriptu</h2>

<p>Ve skutečnosti lze &bdquo;Hello world&ldquo; vypsat ještě kratším skriptem,
než jaký byl uveden v&nbsp;předchozích kapitolách:</p>

<pre>
<i>#!/usr/bin/env bb</i>
&nbsp;
"Hello world"
</pre>

<p>Tento skript pracuje tak, že poslední hodnotou (tedy řetězec) pošle na svůj
standardní výstup.</p>

<p>Můžeme ovšem generovat i víceřádkový výstup, zde konkrétně v&nbsp;kombinaci
se standardní funkcí <strong>println</strong>:</p>

<pre>
<i>#!/usr/bin/env bb</i>
&nbsp;
(doseq [i (range 1 10)]
  (println i))
&nbsp;
"Hello world"
</pre>

<p>S&nbsp;výsledkem:</p>

<pre>
1
2
3
4
5
6
7
8
9
"Hello world"
</pre>



<p><a name="k06"></a></p>
<h2 id="k06">6. Hodnota navázaná na symbol <strong>*input*</strong></h2>

<p>Pokud se skript interpretovaný Babashkou spustí s&nbsp;přepínačem
<strong>-i</strong>, bude standardní vstup (resp.&nbsp;přesněji řečeno jeho
obsah) převeden na sekvenci a navázán na symbol <strong>*input*</strong>
(symbol můžeme v&nbsp;tomto případě považovat za pojmenovanou konstantu, i když
to není přesné). Obsah sekvence si tedy můžeme snadno vypsat:</p>

<pre>
(println *input*)
</pre>

<p>Příklad použití &ndash; na standardním vstupu bude seznam souborů, který
bude převeden na sekvenci:</p>

<pre>
$ <strong>ls -1 | bb -i 07_print_input.clj</strong>
&nbsp;
(01_hello.clj 02_wait_for_user.clj 03_shebang.clj 04_shebang.clj 05_implicit_output.clj 06_multiline_output.clj 07_print_input.clj 08_input_type.clj 09_sort_input.clj 10_for_each_input.clj 11_to_json.clj 12_cli_arguments.clj 13_cli_arguments.clj 14_http_get_to_text.clj 15_http_get_processing.clj 16_http_get_processing.clj 17_http_get_processing_args.clj 18_factorial_overflow.clj 19_factorial_bigint.clj 20_pi_computation_double.clj 21_pi_computation_rational.clj 22_sequential_map.clj 23_parallel_map.clj 24_parallel_map_clojure.clj license.clj README.md)
</pre>
 
<p>Snadno se můžeme přesvědčit, jakého typu vlastně vstup je:</p>

<pre>
(println (type *input*))
</pre>

<p>S&nbsp;výsledky:</p>

<pre>
$ <strong>ls -1 | bb -i 08_input_type.clj</strong>
&nbsp;
clojure.lang.Cons
</pre>

<p>Se vstupem lze provádět různé operace, například ho setřídit a posléze
vypsat (zde je použito <i>threading makro</i>):</p>

<pre>
(-&gt; *input* sort println)
</pre>

<p>Otestování:</p>

<pre>
$ <strong>ls -1 | bb -i 09_sort_input.clj </strong>
&nbsp;
(01_hello.clj 02_wait_for_user.clj 03_shebang.clj 04_shebang.clj
05_implicit_output.clj 06_multiline_output.clj 07_print_input.clj
08_input_type.clj 09_sort_input.clj 10_for_each_input.clj 11_to_json.clj
12_cli_arguments.clj 13_cli_arguments.clj 14_http_get_to_text.clj
15_http_get_processing.clj 16_http_get_processing.clj 17_http_get_processing_args.clj
18_factorial_overflow.clj 19_factorial_bigint.clj 20_pi_computation_double.clj
21_pi_computation_rational.clj 22_sequential_map.clj 23_parallel_map.clj
24_parallel_map_clojure.clj README.md license.clj)
</pre>

<p>Taktéž můžeme sekvenci zpracovat prvek po prvku:</p>

<pre>
(doseq [i *input*]
  (println i))
</pre>

<p>Nyní bude výsledek odlišný:</p>

<pre>
$ <strong>ls -1 | bb -i 10_for_each_input.clj </strong>
&nbsp;
01_hello.clj
02_wait_for_user.clj
03_shebang.clj
04_shebang.clj
05_implicit_output.clj
06_multiline_output.clj
07_print_input.clj
08_input_type.clj
09_sort_input.clj
10_for_each_input.clj
11_to_json.clj
12_cli_arguments.clj
13_cli_arguments.clj
14_http_get_to_text.clj
15_http_get_processing.clj
16_http_get_processing.clj
17_http_get_processing_args.clj
18_factorial_overflow.clj
19_factorial_bigint.clj
20_pi_computation_double.clj
21_pi_computation_rational.clj
22_sequential_map.clj
23_parallel_map.clj
24_parallel_map_clojure.clj
license.clj
README.md
</pre>



<p><a name="k07"></a></p>
<h2 id="k07">7. Dostupné balíčky</h2>

<p>Babashka ovšem není &bdquo;pouze&ldquo; interpretrem programovacího jazyka
Clojure bez dalších podpůrných funkcí. Ve skutečnosti obsahuje Babashka
relativně velké množství balíčků, které lze přímo použít (což do jisté míry
vysvětluje i to, proč je spustitelný soubor <strong>bb</strong> tak velký).
Tyto balíčky nebo jejich části by měly uspokojit velkou část programátorů při
vytváření nástrojů spouštěných z&nbsp;příkazové řádky. Chybí prakticky jen
plnohodnotný HTTP klient. Ostatně se můžete sami přesvědčit, které balíčky jsou
dostupné, popř.&nbsp;které funkce a makra z&nbsp;nich je možné přímo použít, a
to bez nutnosti importu externích balíčků nebo Javovských knihoven:</p>

<table>
<tr><th> #</th><th>Plné jméno</th><th>Alias</th><th>Podporované funkce</th></tr>
<tr><td> 1</td><td>clojure.string</td><td>str</td><td>všechny</td></tr>
<tr><td> 2</td><td>clojure.set</td><td>set</td><td>všechny</td></tr>
<tr><td> 3</td><td>clojure.edn</td><td>edn</td><td>read-string</td></tr>
<tr><td> 4</td><td>clojure.java.shell</td><td>shell</td><td>všechny</td></tr>
<tr><td> 5</td><td>clojure.java.io</td><td>io</td><td>as-relative-path, as-url, copy, delete-file, file, input-stream, make-parents, output-stream, reader, resource, writer</td></tr>
<tr><td> 6</td><td>clojure.main</td><td>clojure.main</td><td>repl</td></tr>
<tr><td> 7</td><td>clojure.core.async</td><td>async</td><td>všechny</td></tr>
<tr><td> 8</td><td>clojure.stacktrace</td><td>&times;</td><td>všechny</td></tr>
<tr><td> 9</td><td>clojure.test</td><td>&times;</td><td>všechny</td></tr>
<tr><td>10</td><td>clojure.pprint</td><td>&times;</td><td>pprint</td></tr>
<tr><td>11</td><td>clojure.zip</td><td>&times;</td><td>všechny</td></tr>
<tr><td>12</td><td>clojure.tools.cli</td><td>tools.cli</td><td>všechny</td></tr>
<tr><td>13</td><td>clojure.data.csv</td><td>csv</td><td>všechny</td></tr>
<tr><td>14</td><td>clojure.data.xml</td><td>xml</td><td>všechny</td></tr>
<tr><td>15</td><td>cheshire.core</td><td>json</td><td>všechny</td></tr>
<tr><td>16</td><td>cognitect.transit</td><td>transit</td><td>všechny</td></tr>
<tr><td>17</td><td>clj-yaml.core</td><td>yaml</td><td>všechny</td></tr>
<tr><td>18</td><td>bencode.core</td><td>bencode</td><td>read-bencode, write-bencode</td></tr>
</table>

<p><div class="rs-tip-major">Poznámka: dostupný je i balíček s&nbsp;rozhraním
JDBC, ten ovšem (pochopitelně) pro korektní práci vyžaduje i ovladače ke
konkrétní databázi.</div></p>



<p><a name="k08"></a></p>
<h2 id="k08">8. Výstup do JSONu</h2>

<p>Některé balíčky a funkce či makra v&nbsp;nich definované si můžeme odzkoušet
velmi snadno. V&nbsp;následujícím jednořádkovém demonstračním příkladu se
hodnota na vstupu navázaná na symbol <strong>*input*</strong> převede do
formátu JSON a vytiskne na standardní výstup (takže je JSON dostupný pro
zpracování dalšími nástroji):</p>

<pre>
(println (json/encode *input*))
</pre>

<p>Vzhledem k&nbsp;tomu, že na vstupu je sekvence textových řádků, bude
výstupní JSON obsahovat pole s&nbsp;řetězci, přičemž každý řetězec odpovídá
jednomu vstupnímu řádku:</p>

<pre>
$ <strong>ls -1 | bb -i 11_to_json.clj</strong>
&nbsp;
["01_hello.clj","02_wait_for_user.clj","03_shebang.clj","04_shebang.clj",
"05_implicit_output.clj","06_multiline_output.clj","07_print_input.clj",
"08_input_type.clj","09_sort_input.clj","10_for_each_input.clj","11_to_json.clj",
"12_cli_arguments.clj","13_cli_arguments.clj","14_http_get_to_text.clj",
"15_http_get_processing.clj","16_http_get_processing.clj","17_http_get_processing_args.clj",
"18_factorial_overflow.clj","19_factorial_bigint.clj","20_pi_computation_double.clj",
"21_pi_computation_rational.clj","22_sequential_map.clj","23_parallel_map.clj",
"24_parallel_map_clojure.clj","license.clj","README.md"]
</pre>

<p><div class="rs-tip-major">Poznámka: pole v&nbsp;JSONu je totiž nejbližším
ekvivalentem sekvencí, seznamů a vektorů, tedy datových struktur používaných
v&nbsp;programovacím jazyku Clojure.</div></p>



<p><a name="k09"></a></p>
<h2 id="k09">9. Zpracování argumentů předaných na příkazové řádce</h2>

<p>Mnoho skriptů spouštěných z&nbsp;příkazové řádky (ať již jsou naprogramovány
v&nbsp;jakémkoli jazyce) musí nějakým způsobem zpracovávat argumenty zadané
uživatelem či jiným skriptem při volání. Pro tento účel se v&nbsp;programovacím
jazyku Clojure používá balíček nazvaný <strong>clojure.tools.cli</strong>,
který je dostupný i v&nbsp;nástroji Babashka. Bližší popis možností tohoto
balíčku naleznete na stránce <a
href="https://github.com/clojure/tools.cli">https://github.com/clojure/tools.cli</a>.
My si nyní v&nbsp;krátkosti ukážeme způsob použití pro skript, který má
akceptovat argumenty <strong>-v</strong>, <strong>-h</strong> a argument
s&nbsp;parametrem <strong>-p</strong>. Argumenty příkazové řádky se definují
strukturou typu &bdquo;vektor vektorů&ldquo; a zpracovávají funkcí
<strong>parse-opts</strong> vracející informace o předaných parametrech:</p>

<pre>
(require '[clojure.pprint :as pprint])
(require '[clojure.tools.cli :refer [parse-opts]])
&nbsp;
(def <strong>command-line-options</strong>
  [["-v" "--verbose" "Verbosity level"
    :id :verbosity
    :default 0
    :update-fn inc]
   ["-p" "--port PORT" "Port number"
    :default 80
    :parse-fn #(Integer/parseInt %)
    :validate [#(&lt; 0 % 0x10000) "Must be a number between 0 and 65536"]]
   ["-h" "--help"]])
&nbsp;
(pprint/pprint (parse-opts *command-line-args* command-line-options))
</pre>

<p><div class="rs-tip-major">Poznámka: povšimněte si, že argumenty je možné i
kontrolovat funkcí specifikovanou přes <strong>:validate</strong> (my jsme
použili funkci anonymní, která zjišťuje, zda je číslo portu v&nbsp;rozsahu 1 až
65535).</div></p>

<p>Datová struktura vracená funkcí <strong>parse-opts</strong> je
v&nbsp;čitelné podobě vypsána na standardní výstup, takže si můžeme otestovat,
jak bude skript reagovat na různé argumenty, popř.&nbsp;na jejich absenci.</p>

<p>Spuštění bez argumentů:</p>

<pre>
$ <strong>bb 12_cli_arguments.clj</strong>
&nbsp;
{:options {:verbosity 0, :port 80},
 :arguments [],
 :summary "  -v, --verbose        Verbosity level\n  -p, --port PORT  80  Port number\n  -h, --help",
 :errors nil}
</pre>

<p>Specifikace jediného argumentu:</p>

<pre>
$ <strong>bb 12_cli_arguments.clj -h</strong>
&nbsp;
{:options {:verbosity 0, :port 80, :help true},
 :arguments [],
 :summary "  -v, --verbose        Verbosity level\n  -p, --port PORT  80  Port number\n  -h, --help",
 :errors nil}
</pre>

<p>Specifikace dvou argumentů, jeden má i hodnotu:</p>

<pre>
$ <strong>bb 12_cli_arguments.clj -h -p 42</strong>
&nbsp;
{:options {:verbosity 0, :port 42, :help true},
 :arguments [],
 :summary "  -v, --verbose        Verbosity level\n  -p, --port PORT  80  Port number\n  -h, --help",
 :errors nil}
</pre>

<p>Použití delšího jména argumentu:</p>

<pre>
$ <strong>bb 12_cli_arguments.clj -h -p 42 --verbose</strong>
&nbsp;
{:options {:verbosity 1, :port 42, :help true},
 :arguments [],
 :summary "  -v, --verbose        Verbosity level\n  -p, --port PORT  80  Port number\n  -h, --help",
 :errors nil}
</pre>

<p>Předání neznámých argumentů:</p>

<pre>
$ <strong>bb 12_cli_arguments.clj --foobar -x</strong>
&nbsp;
{:options {:verbosity 0, :port 80},
 :arguments [],
 :summary "  -v, --verbose        Verbosity level\n  -p, --port PORT  80  Port number\n  -h, --help",
 :errors ["Unknown option: \"--foobar\"" "Unknown option: \"-x\""]}
</pre>

<p>Podobně lze tentýž přístup použít i ve chvíli, kdy je skript spustitelný a
začíná shebangem:</p>

<pre>
<i>#!/usr/bin/env bb</i>
&nbsp;
(require '[clojure.pprint :as pprint])
(require '[clojure.tools.cli :refer [parse-opts]])
&nbsp;
(def <strong>command-line-options</strong>
  [["-v" "--verbose" "Verbosity level"
    :id :verbosity
    :default 0
    :update-fn inc]
   ["-p" "--port PORT" "Port number"
    :default 80
    :parse-fn #(Integer/parseInt %)
    :validate [#(&lt; 0 % 0x10000) "Must be a number between 0 and 65536"]]
   ["-h" "--help"]])
&nbsp;
(pprint/pprint (parse-opts *command-line-args* command-line-options))
</pre>

<p>Opět si skript několikrát spustíme.</p>

<p>Použití jediného argumentu v&nbsp;dlouhé podobě:</p>

<pre>
$ <strong>./13_cli_arguments.clj --help</strong>
&nbsp;
{:options {:verbosity 0, :port 80, :help true},
 :arguments [],
 :summary "  -v, --verbose        Verbosity level\n  -p, --port PORT  80  Port number\n  -h, --help",
 :errors nil}
</pre>

<p>Předání více argumentů v&nbsp;dlouhé podobě:</p>

<pre>
$ <strong>./13_cli_arguments.clj --help --port 42 --verbose</strong>
&nbsp;
{:options {:verbosity 1, :port 42, :help true},
 :arguments [],
 :summary "  -v, --verbose        Verbosity level\n  -p, --port PORT  80  Port number\n  -h, --help",
 :errors nil}
</pre>

<p>Předání více argumentů v&nbsp;krátké podobě:</p>

<pre>
$ <strong>./13_cli_arguments.clj -h -p 42 -v</strong>
&nbsp;
{:options {:verbosity 1, :port 42, :help true},
 :arguments [],
 :summary "  -v, --verbose        Verbosity level\n  -p, --port PORT  80  Port number\n  -h, --help",
 :errors nil}
</pre>

<p>Předání neznámých argumentů:</p>

<pre>
$ <strong>./13_cli_arguments.clj -h -p 42 --foobar</strong>
&nbsp;
{:options {:verbosity 0, :port 42, :help true},
 :arguments [],
 :summary "  -v, --verbose        Verbosity level\n  -p, --port PORT  80  Port number\n  -h, --help",
 :errors ["Unknown option: \"--foobar\""]}
</pre>



<p><a name="k10"></a></p>
<h2 id="k10">10. Základní práce s&nbsp;HTTP/HTTPS popř.&nbsp;s&nbsp;REST API</h2>

<p>Velmi užitečná může být práce s&nbsp;HTTP či HTTPS, protože kombinace
<strong>curl</strong> + <strong>sed</strong> nebo <strong>curl</strong> +
<strong>jq</strong> nemusí být vždy to nejlepší možné řešení. Podívejme se na
skript, který přistoupí na REST API a vypíše tělo odpovědi. Použijeme
standardní funkci <strong>slurp</strong>:</p>

<pre>
(println (slurp "https://httpbin.org/get"))
</pre>

<p>Po spuštění tohoto skriptu by se na standardní výstup měl vypsat následující
JSON:</p>

<pre>
{
  "args": {}, 
  "headers": {
    "Accept": "text/html, image/gif, image/jpeg, *; q=.2, */*; q=.2", 
    "Host": "httpbin.org", 
    "User-Agent": "Java/11.0.7", 
    "X-Amzn-Trace-Id": "Root=1-5f32df22-ecb57d4c0414da444b2dc6e8"
  }, 
  "origin": "37.48.9.246", 
  "url": "https://httpbin.org/get"
}
</pre>



<p><a name="k11"></a></p>
<h2 id="k11">11. Zpracování dat vracených ve formátu JSON</h2>

<p>Předchozí skript lze samozřejmě nahradit voláním utility
<strong>curl</strong>, ovšem předností Babashky (a vůbec Clojure) je excelentní
práce se strukturovanými daty. Další skript opět přistoupí k&nbsp;REST API,
ovšem z&nbsp;odpovědi nyní získá pouze některá data, konkrétně obsah hlavičky
&bdquo;User-Agent&ldquo;. &bdquo;Ukecaná&ldquo; verze skriptu by mohla vypadat
následovně:</p>

<pre>
(let [response (slurp "https://httpbin.org/get")
      parsed   (json/decode response true)
      headers  (:headers parsed)
      user-agent (:User-Agent headers)]
  (println user-agent))
</pre>

<p>Po spuštění by se měl vypsat jediný řádek:</p>

<pre>
Java/11.0.7
</pre>

<p><div class="rs-tip-major">Poznámka: zde Babashka prozrazuje, čím byla
přeložena.</div></p>



<p><a name="k12"></a></p>
<h2 id="k12">12. Ukázka síly jazyka Clojure &ndash; threading makro</h2>

<p>Předchozí skript si můžeme přepsat do lepší podoby používající takzvané
&bdquo;threading makro&ldquo;, které předává návratovou hodnotu nějaké formy
jako první parametr další formy. Začíná se řetězcem, který se vyhodnotí sám na
sebe. Tento řetězec je předán funkci <strong>slurp</strong>, která získá tělo
odpovědi. To zpracujeme jako vstup v&nbsp;JSONu a následně můžeme přistupovat
k&nbsp;jednotlivým atributům zkráceným voláním &bdquo;get&ldquo;:</p>

<pre>
(-&gt; "https://httpbin.org/get"
    slurp
    (json/decode true)
    :headers
    :User-Agent
    println)
</pre>

<p>Výsledek bude shodný s&nbsp;předchozím skriptem:</p>

<pre>
Java/11.0.7
</pre>

<p><div class="rs-tip-major">Poznámka: samozřejmě je možné celý skript napsat
na jediný řádek, ovšem se zhoršenou čitelností.</div></p>

<p>Další skript je kombinací znalostí, které již máme. Skript akceptuje povinný
argument s&nbsp;názvem serveru a z&nbsp;tohoto serveru se pak snaží získat
odpověď přes jednoduché REST API. Pro větší zábavu je opět použito threading
makro:</p>

<pre>
<i>#!/usr/bin/env bb</i>
&nbsp;
(require '[clojure.pprint :as pprint])
(require '[clojure.tools.cli :refer [parse-opts]])
&nbsp;
(import (java.net InetAddress))
&nbsp;
(def <strong>command-line-options</strong>
  [["-H" "--hostname HOST" "Remote host"
    :default "localhost"
    :required true
    ]])
&nbsp;
(let [opts (parse-opts *command-line-args* command-line-options)
      url  (-&gt; opts :options :hostname)]
  (-&gt; (str "https://" url "/get")
      slurp
      (json/decode true)
      pprint/pprint))
</pre>

<p>Příklad použití bez uvedení argumentu:</p>

<pre>
$ <strong>./17_http_get_processing_args.clj</strong>
&nbsp;
java.net.ConnectException: Connection refused (Connection refused) [at /home/ptisnovs/src/clojure/clojure-examples/babashka/17_http_get_processing_args.clj, line 18, column 7]
</pre>

<p>Příklad použití s&nbsp;uvedením argumentu:</p>

<pre>
$ <strong>./17_http_get_processing_args.clj -H httpbin.org</strong>
&nbsp;
{:args {},
 :headers {:Accept "text/html, image/gif, image/jpeg, *; q=.2, */*; q=.2",
           :Host "httpbin.org",
           :User-Agent "Java/11.0.7",
           :X-Amzn-Trace-Id "Root=1-5f32e7ed-23b74824f4391614a1e2853a"},
 :origin "37.48.9.246",
 :url "https://httpbin.org/get"}
</pre>



<p><a name="k13"></a></p>
<h2 id="k13">13. Využití dalších vlastností Clojure &ndash; výpočty s&nbsp;neomezeným rozsahem hodnot</h2>

<p>Podporovány jsou i další vlastnosti programovacího jazyka Clojure, například
výpočty s&nbsp;neomezeným rozsahem hodnot (což je základní požadavek, který na
vysokoúrovňové jazyky mám). Podívejme se na výpočet faktoriálu, který je
založen na typu <strong>long</strong> resp.&nbsp;přesněji řečeno
<strong>java.lang.Long</strong>:</p>

<pre>
(defn <strong>factorial</strong>
    [n]
    (if (neg? n)
        (throw (IllegalArgumentException. "negative numbers are not supported!"))
        (apply * (range 1 (inc n)))))
&nbsp;
(defn <strong>main</strong>
    [max]
    (doseq [i (range 0 (inc max))]
        (println i "! = " (factorial i))))
&nbsp;
(main 50)
</pre>

<pre>
$ <strong>bb 18_factorial_overflow.clj</strong>
&nbsp;
0 ! =  1
1 ! =  1
2 ! =  2
3 ! =  6
4 ! =  24
5 ! =  120
6 ! =  720
7 ! =  5040
8 ! =  40320
9 ! =  362880
10 ! =  3628800
11 ! =  39916800
12 ! =  479001600
13 ! =  6227020800
14 ! =  87178291200
15 ! =  1307674368000
16 ! =  20922789888000
17 ! =  355687428096000
18 ! =  6402373705728000
19 ! =  121645100408832000
20 ! =  2432902008176640000
java.lang.ArithmeticException: integer overflow [at /home/ptisnovs/src/clojure/clojure-examples/babashka/18_factorial_overflow.clj, line 5, column 9]
</pre>

<pre>
(defn <strong>factorial</strong>
    [n]
    (if (neg? n)
        (throw (IllegalArgumentException. "negative numbers are not supported!"))
        (apply * (range 1N (inc n)))))
&nbsp;
(defn <strong>main</strong>
    [max]
    (doseq [i (range 0 (inc max))]
        (println i "! = " (factorial i))))
&nbsp;
(main 50)
</pre>

<pre>
$ <strong>bb 19_factorial_bigint.clj</strong>
&nbsp;
0 ! =  1
1 ! =  1N
2 ! =  2N
3 ! =  6N
4 ! =  24N
5 ! =  120N
6 ! =  720N
7 ! =  5040N
8 ! =  40320N
9 ! =  362880N
10 ! =  3628800N
11 ! =  39916800N
12 ! =  479001600N
13 ! =  6227020800N
14 ! =  87178291200N
15 ! =  1307674368000N
16 ! =  20922789888000N
17 ! =  355687428096000N
18 ! =  6402373705728000N
19 ! =  121645100408832000N
20 ! =  2432902008176640000N

</pre>



<p><a name="k14"></a></p>
<h2 id="k14">14. Datový typ <i>double</i> a počítání se zlomky</h2>

<pre>
(defn <strong>compute-pi</strong>
  ([n pi]
  (loop [i 3
         pi pi]
    (if (&lt;= i (+ n 2))
      (recur (+ i 2) (* pi (/ (- i 1) i) (/ (+ i 1) i)))
      pi)))
  ([n]
   (compute-pi n 4.0)))
&nbsp;
&nbsp;
(doseq [i (range 0 20)]
  (let [n (bit-shift-left 1 i)]
    (println n "\t" (compute-pi n))))
</pre>

<pre>
</pre>

<pre>
(defn <strong>compute-pi</strong>
  ([n pi]
  (loop [i 3
         pi pi]
    (if (&lt;= i (+ n 2))
      (recur (+ i 2) (* pi (/ (- i 1) i) (/ (+ i 1) i)))
      pi)))
  ([n]
   (compute-pi n 4)))
&nbsp;
&nbsp;
(doseq [i (range 0 6)]
  (let [n (bit-shift-left 1 i)]
    (println n "\t" (compute-pi n))))
</pre>

<pre>
</pre>



<p><a name="k15"></a></p>
<h2 id="k15">15. Výpočty ve více vláknech &ndash; <strong>map</strong> versus <strong>pmap</strong></h2>

<p>Velkou předností Babashky oproti jiným jednodušším technologiím je možnost
spuštění částí algoritmu ve více vláknech. V&nbsp;jazyce Clojure k&nbsp;tomuto
účelu existuje několik funkcí a maker. Pravděpodobně nejjednodušeji je
použitelná funkce nazvaná <strong>pmap</strong>, která je obdobou funkce
vyššího řádu <strong>map</strong>, ovšem s&nbsp;tím, že zpracování vstupu
(aplikace funkce) je prováděno ve větším množství vláken přidělených
z&nbsp;<i>thread poolu</i> (nemusí se tedy vždy vytvářet znovu). Nejprve si
ukažme, jakým způsobem by bylo možné vypočítat konstantu Pi algoritmem <a
href="https://en.wikipedia.org/wiki/Wallis_product">popsaným zde</a> pro počet
iterací mezi hodnotou 1000000 a 1000020. Jedná se o vysoké počty iterací, takže
sekvenční výpočet pro vstup 1000000, 1000001 atd. nebude příliš rychlý:</p>

<pre>
(defn <strong>compute-pi</strong>
  ([n pi]
  (loop [i 3
         pi pi]
    (if (&lt;= i (+ n 2))
      (recur (+ i 2) (* pi (/ (- i 1) i) (/ (+ i 1) i)))
      pi)))
  ([n]
   (compute-pi n 4.0)))
&nbsp;
(let [n (range 1000000 1000020)
      results (doall (<u>map</u> #(compute-pi %) n))]
  (doseq [pi results]
    (println pi)))
</pre>

<p>Celý výpočet lze ovšem provést i paralelně a to velmi jednoduše &ndash;
náhradou funkce <strong>map</strong> za funkci <strong>pmap</strong> neboli
&bdquo;parallel map&ldquo;:</p>

<pre>
(defn <strong>compute-pi</strong>
  ([n pi]
  (loop [i 3
         pi pi]
    (if (&lt;= i (+ n 2))
      (recur (+ i 2) (* pi (/ (- i 1) i) (/ (+ i 1) i)))
      pi)))
  ([n]
   (compute-pi n 4.0)))
&nbsp;
(let [n (range 1000000 1000020)
      results (doall (<u>pmap</u> #(compute-pi %) n))]
  (doseq [pi results]
    (println pi)))
</pre>

<p>Nyní si oba časy výpočtu můžeme porovnat. Nejprve sekvenční výpočet založený
na funkci <strong>map</strong> (které se předala funkce anonymní &ndash; znak #
lze číst jako &lambda;):</p>

<pre>
$ <strong>time bb 22_sequential_map.clj</strong>
&nbsp;
3.141594224383251
3.14159422438011
3.14159422438011
3.141594224376968
3.141594224376968
3.1415942243738266
3.1415942243738266
3.1415942243706847
3.1415942243706847
3.141594224367543
3.141594224367543
3.1415942243644017
3.1415942243644017
3.1415942243612593
3.1415942243612593
3.141594224358117
3.141594224358117
3.141594224354974
3.141594224354974
3.1415942243518313
&nbsp;
real    1m15.040s
user    1m14.825s
sys     0m0.088s
</pre>

<p>Ve druhém případě je použit výpočet paralelní:</p>

<pre>
$ <strong>time bb 23_parallel_map.clj</strong>
&nbsp;
3.141594224383251
3.14159422438011
3.14159422438011
3.141594224376968
3.141594224376968
3.1415942243738266
3.1415942243738266
3.1415942243706847
3.1415942243706847
3.141594224367543
3.141594224367543
3.1415942243644017
3.1415942243644017
3.1415942243612593
3.1415942243612593
3.141594224358117
3.141594224358117
3.141594224354974
3.141594224354974
3.1415942243518313
&nbsp;
real    0m41.497s
user    1m40.592s
sys     0m3.002s
</pre>

<p><div class="rs-tip-major">Poznámka: výsledky byly vypočteny přibližně
dvakrát rychleji, což znamená, že celý výpočet z&nbsp;nějakého důvodu neškáluje
tak dobře, jak by se mohlo na stroji se čtyřmi jádry očekávat. Nicméně
například pro souběžné stahování souborů, přístup k&nbsp;REST API apod. se může
jednat o vhodný přístup.</div></p>



<p><a name="k16"></a></p>
<h2 id="k16">16. Porovnání rychlosti výpočtů Babashky s&nbsp;implementací Clojure pro JVM</h2>

<p>V&nbsp;úvodní kapitole jsme si řekli, že se Babashka hodí především pro
spouštění takových skriptů, v&nbsp;nichž se neprovádí složité výpočty. Je tomu
tak z&nbsp;toho důvodu, že interpret (SCI) nemůže u dlouhodobějších výpočtů
konkurovat původnímu Clojure, které provádí překlad do bajtkódu s&nbsp;jeho
následným JITováním. Ostatně si to můžeme snadno otestovat &ndash; spustíme
výpočet čísla Pi s&nbsp;běžným Clojure (starší verze 1.8.0 byla zvolena proto,
že je spustitelná z&nbsp;příkazové řádky velmi snadno, bez nutnosti složitější
manipulace s&nbsp;CLASSPATH):</p>

<pre>
$ <strong>time java -cp clojure-1.8.0.jar clojure.main 22_sequential_map.clj</strong>
&nbsp;
3.141594224383251
3.14159422438011
3.14159422438011
3.141594224376968
3.141594224376968
3.1415942243738266
3.1415942243738266
3.1415942243706847
3.1415942243706847
3.141594224367543
3.141594224367543
3.1415942243644017
3.1415942243644017
3.1415942243612593
3.1415942243612593
3.141594224358117
3.141594224358117
3.141594224354974
3.141594224354974
3.1415942243518313
&nbsp;
real    0m7.150s
user    0m8.078s
sys     0m0.280s
</pre>

<p>Výpočet (sekvenční) je znatelně rychlejší (osm sekund oproti minutě a
patnácti sekundám), takže se ještě podívejme na možnosti paralelizace výpočtu
s&nbsp;využitím funkce <strong>pmap</strong>:</p>

<pre>
$ <strong>time java -cp clojure-1.8.0.jar clojure.main 24_parallel_map_clojure.clj</strong>
&nbsp;
3.141594224383251
3.14159422438011
3.14159422438011
3.141594224376968
3.141594224376968
3.1415942243738266
3.1415942243738266
3.1415942243706847
3.1415942243706847
3.141594224367543
3.141594224367543
3.1415942243644017
3.1415942243644017
3.1415942243612593
3.1415942243612593
3.141594224358117
3.141594224358117
3.141594224354974
3.141594224354974
3.1415942243518313
&nbsp;
real    0m2.590s
user    0m14.539s
sys     0m0.585s
</pre>

<p>Nyní byl výpočet dokončen za necelé tři sekundy!</p>

<p><div class="rs-tip-major">Poznámka: demonstrační příklad bylo nutné nepatrně
upravit, aby se po ukončení výpočtů ihned ukončila i celá JVM a nečekalo se na
vlákna vracená do thread poolu:</div></p>

<pre>
(defn <strong>compute-pi</strong>
  ([n pi]
  (loop [i 3
         pi pi]
    (if (&lt;= i (+ n 2))
      (recur (+ i 2) (* pi (/ (- i 1) i) (/ (+ i 1) i)))
      pi)))
  ([n]
   (compute-pi n 4.0)))
&nbsp;
(let [n (range 1000000 1000020)
      results (doall (pmap #(compute-pi %) n))]
  (doseq [pi results]
    (println pi)))
&nbsp;
(System/exit 0)
</pre>



<p><a name="k17"></a></p>
<h2 id="k17">17. Zobrazení nápovědy přímo v&nbsp;interaktivní smyčce REPL</h2>

<p>Poslední užitečnou vlastností nástroje <i>Babashka</i>, s&nbsp;níž se dnes
seznámíme, je možnost zobrazení nápovědy k&nbsp;implementovaným funkcím přímo
z&nbsp;interaktivní smyčky REPL. To mj.&nbsp;znamená, že není zapotřebí dodávat
další soubory s&nbsp;dokumentací, info stránky atd. Postačuje pouze spustit
REPL:</p>

<pre>
$ <strong>bb</strong>
</pre>

<p>a následně použít makro <strong>doc</strong> pro zobrazení příslušné
nápovědy:</p>

<pre>
user=&gt; <strong>(doc first)</strong>
-------------------------
clojure.core/first
([coll])
  Returns the first item in the collection. Calls seq on its
    argument. If coll is nil, returns nil.
nil
&nbsp;
user=&gt; <strong>(doc rest)</strong>
-------------------------
clojure.core/rest
([coll])
  Returns a possibly empty seq of the items after the first. Calls seq on its
  argument.
nil
&nbsp;
user=&gt; <strong>(doc str)</strong>
-------------------------
clojure.core/str
([] [x] [x &amp; ys])
  With no args, returns the empty string. With one arg x, returns
  x.toString().  (str nil) returns the empty string. With more than
  one arg, returns the concatenation of the str values of the args.
nil
&nbsp;
</pre>

<p>Nápovědu lze získat i k&nbsp;funkcím, které se nachází ve standardně
dostupných balíčcích zmíněných <a href="#k07">v&nbsp;sedmé kapitole</a>:</p>

<pre>
user=&gt; <strong>(doc json/decode)</strong>
-------------------------
cheshire.core/decode
([string] [string key-fn] [string key-fn array-coerce-fn])
  Alias to parse-string for clojure-json users
</pre>

<p><div class="rs-tip-major">Poznámka: současná verze Babashky nedokáže
zobrazit nápovědu k&nbsp;makrům, což pravděpodobně souvisí s&nbsp;neexistencí
podpory pro funkci <strong>eval</strong>.</div></p>



<p><a name="k18"></a></p>
<h2 id="k18">18. Repositář s&nbsp;demonstračními příklady</h2>

<p>Všechny dnes ukázané demonstrační příklady určené pro poslední verzi
projektu Babashka byly uloženy do repositáře, který naleznete na adrese <a
href="https://github.com/tisnik/clojure-examples">https://github.com/tisnik/clojure-examples</a>,
konkrétně do adresáře <a
href="https://github.com/tisnik/clojure-examples/tree/master/babashka">https://github.com/tisnik/clojure-examples/tree/master/babashka</a>:</p>

<table>
<tr><th> #</th><th>Projekt</th><th>Popis</th><th>Odkaz</th></tr>
<tr><td> 1</td><td>01_hello.clj</td><td>klasický příklad typu &bdquo;Hello world!&ldquo;</td><td><a href="https://github.com/tisnik/clojure-examples/tree/master/babashka/01_hello.clj">https://github.com/tisnik/clojure-examples/tree/master/babashka/01_hello.clj</a></td></tr>
<tr><td> 2</td><td>02_wait_for_user.clj</td><td>čekání na vstup od uživatele (pro získání charakteristik procesu)</td><td><a href="https://github.com/tisnik/clojure-examples/tree/master/babashka/02_wait_for_user.clj">https://github.com/tisnik/clojure-examples/tree/master/babashka/02_wait_for_user.clj</a></td></tr>
<tr><td> 3</td><td>03_shebang.clj</td><td>použití <i>shebangu</i> pro spuštění skriptů</td><td><a href="https://github.com/tisnik/clojure-examples/tree/master/babashka/03_shebang.clj">https://github.com/tisnik/clojure-examples/tree/master/babashka/03_shebang.clj</a></td></tr>
<tr><td> 4</td><td>04_shebang.clj</td><td>použití <i>shebangu</i> pro spuštění skriptů</td><td><a href="https://github.com/tisnik/clojure-examples/tree/master/babashka/04_shebang.clj">https://github.com/tisnik/clojure-examples/tree/master/babashka/04_shebang.clj</a></td></tr>
<tr><td> 5</td><td>05_implicit_output.clj</td><td>implicitní výstup ze skriptu</td><td><a href="https://github.com/tisnik/clojure-examples/tree/master/babashka/05_implicit_output.clj">https://github.com/tisnik/clojure-examples/tree/master/babashka/05_implicit_output.clj</a></td></tr>
<tr><td> 6</td><td>06_multiline_output.clj</td><td>implicitní a víceřádkový výstup ze skriptu</td><td><a href="https://github.com/tisnik/clojure-examples/tree/master/babashka/06_multiline_output.clj">https://github.com/tisnik/clojure-examples/tree/master/babashka/06_multiline_output.clj</a></td></tr>
<tr><td> 7</td><td>07_print_input.clj</td><td>tisk hodnoty navázané na symbol <strong>*input*</strong></td><td><a href="https://github.com/tisnik/clojure-examples/tree/master/babashka/07_print_input.clj">https://github.com/tisnik/clojure-examples/tree/master/babashka/07_print_input.clj</a></td></tr>
<tr><td> 8</td><td>08_input_type.clj</td><td>získání typu hodnoty navázané na symbol <strong>*input*</strong></td><td><a href="https://github.com/tisnik/clojure-examples/tree/master/babashka/08_input_type.clj">https://github.com/tisnik/clojure-examples/tree/master/babashka/08_input_type.clj</a></td></tr>
<tr><td> 9</td><td>09_sort_input.clj</td><td>setřídění hodnot na vstupu</td><td><a href="https://github.com/tisnik/clojure-examples/tree/master/babashka/09_sort_input.clj">https://github.com/tisnik/clojure-examples/tree/master/babashka/09_sort_input.clj</a></td></tr>
<tr><td>10</td><td>10_for_each_input.clj</td><td>programová smyčka</td><td><a href="https://github.com/tisnik/clojure-examples/tree/master/babashka/10_for_each_input.clj">https://github.com/tisnik/clojure-examples/tree/master/babashka/10_for_each_input.clj</a></td></tr>
<tr><td>11</td><td>11_to_json.clj</td><td>výstup do formátu JSON</td><td><a href="https://github.com/tisnik/clojure-examples/tree/master/babashka/11_to_json.clj">https://github.com/tisnik/clojure-examples/tree/master/babashka/11_to_json.clj</a></td></tr>
<tr><td>12</td><td>12_cli_arguments.clj</td><td>zpracování argumentů na příkazové řádce</td><td><a href="https://github.com/tisnik/clojure-examples/tree/master/babashka/12_cli_arguments.clj">https://github.com/tisnik/clojure-examples/tree/master/babashka/12_cli_arguments.clj</a></td></tr>
<tr><td>13</td><td>13_cli_arguments.clj</td><td>zpracování argumentů na příkazové řádce</td><td><a href="https://github.com/tisnik/clojure-examples/tree/master/babashka/13_cli_arguments.clj">https://github.com/tisnik/clojure-examples/tree/master/babashka/13_cli_arguments.clj</a></td></tr>
<tr><td>14</td><td>14_http_get_to_text.clj</td><td>jednoduchý HTTP dotaz typu GET</td><td><a href="https://github.com/tisnik/clojure-examples/tree/master/babashka/14_http_get_to_text.clj">https://github.com/tisnik/clojure-examples/tree/master/babashka/14_http_get_to_text.clj</a></td></tr>
<tr><td>15</td><td>15_http_get_processing.clj</td><td>vylepšení předchozího příkladu</td><td><a href="https://github.com/tisnik/clojure-examples/tree/master/babashka/15_http_get_processing.clj">https://github.com/tisnik/clojure-examples/tree/master/babashka/15_http_get_processing.clj</a></td></tr>
<tr><td>16</td><td>16_http_get_processing.clj</td><td>zpracování výsledků získaných přes REST API</td><td><a href="https://github.com/tisnik/clojure-examples/tree/master/babashka/16_http_get_processing.clj">https://github.com/tisnik/clojure-examples/tree/master/babashka/16_http_get_processing.clj</a></td></tr>
<tr><td>17</td><td>17_http_get_processing_args.clj</td><td>zadání URL z&nbsp;příkazového řádku</td><td><a href="https://github.com/tisnik/clojure-examples/tree/master/babashka/17_http_get_processing_args.clj">https://github.com/tisnik/clojure-examples/tree/master/babashka/17_http_get_processing_args.clj</a></td></tr>
<tr><td>18</td><td>18_factorial_overflow.clj</td><td>výpočet faktoriálu s&nbsp;přetečením výsledků</td><td><a href="https://github.com/tisnik/clojure-examples/tree/master/babashka/18_factorial_overflow.clj">https://github.com/tisnik/clojure-examples/tree/master/babashka/18_factorial_overflow.clj</a></td></tr>
<tr><td>19</td><td>19_factorial_bigint.clj</td><td>výpočet faktoriálu s&nbsp;prakticky neomezeným rozsahem</td><td><a href="https://github.com/tisnik/clojure-examples/tree/master/babashka/19_factorial_bigint.clj">https://github.com/tisnik/clojure-examples/tree/master/babashka/19_factorial_bigint.clj</a></td></tr>
<tr><td>20</td><td>20_pi_computation_double.clj</td><td>výpočet konstanty Pi s&nbsp;datovým typem <i>double</i></td><td><a href="https://github.com/tisnik/clojure-examples/tree/master/babashka/20_pi_computation_double.clj">https://github.com/tisnik/clojure-examples/tree/master/babashka/20_pi_computation_double.clj</a></td></tr>
<tr><td>21</td><td>21_pi_computation_rational.clj</td><td>výpočet konstanty Pi s&nbsp;datovým typem <i>zlomek</i></td><td><a href="https://github.com/tisnik/clojure-examples/tree/master/babashka/21_pi_computation_rational.clj">https://github.com/tisnik/clojure-examples/tree/master/babashka/21_pi_computation_rational.clj</a></td></tr>
<tr><td>22</td><td>22_sequential_map.clj</td><td>sekvenční výpočet Pi s&nbsp;využitím funkce <strong>map</strong></td><td><a href="https://github.com/tisnik/clojure-examples/tree/master/babashka/22_sequential_map.clj">https://github.com/tisnik/clojure-examples/tree/master/babashka/22_sequential_map.clj</a></td></tr>
<tr><td>23</td><td>23_parallel_map.clj</td><td>paralelní výpočet Pi s&nbsp;využitím funkce <strong>pmap</strong></td><td><a href="https://github.com/tisnik/clojure-examples/tree/master/babashka/23_parallel_map.clj">https://github.com/tisnik/clojure-examples/tree/master/babashka/23_parallel_map.clj</a></td></tr>
<tr><td>24</td><td>24_parallel_map_clojure.clj</td><td>úprava předchozího příkladu pro klasické Clojure</td><td><a href="https://github.com/tisnik/clojure-examples/tree/master/babashka/24_parallel_map_clojure.clj">https://github.com/tisnik/clojure-examples/tree/master/babashka/24_parallel_map_clojure.clj</a></td></tr>
</table>



<p><a name="k19"></a></p>
<h2 id="k19">19. Odkazy na předchozí části seriálu o programovacím jazyku Clojure</h2>

<ol>

<li>Clojure  1: Úvod<br />
<a href="http://www.root.cz/clanky/clojure-aneb-jazyk-umoznujici-tvorbu-bezpecnych-vicevlaknovych-aplikaci-pro-jvm/">http://www.root.cz/clanky/clojure-aneb-jazyk-umoznujici-tvorbu-bezpecnych-vicevlaknovych-aplikaci-pro-jvm/</a>
</li>

<li>Clojure  2: Symboly, kolekce atd.<br />
<a href="http://www.root.cz/clanky/clojure-aneb-jazyk-umoznujici-tvorbu-bezpecnych-vicevlaknovych-aplikaci-pro-jvm-2-cast/">http://www.root.cz/clanky/clojure-aneb-jazyk-umoznujici-tvorbu-bezpecnych-vicevlaknovych-aplikaci-pro-jvm-2-cast/</a>
</li>

<li>Clojure  3: Funkcionální programování<br />
<a href="http://www.root.cz/clanky/clojure-aneb-jazyk-umoznujici-tvorbu-bezpecnych-vicevlaknovych-aplikaci-pro-jvm-3-cast-funkcionalni-programovani/">http://www.root.cz/clanky/clojure-aneb-jazyk-umoznujici-tvorbu-bezpecnych-vicevlaknovych-aplikaci-pro-jvm-3-cast-funkcionalni-programovani/</a>
</li>

<li>Clojure  4: Kolekce, sekvence a lazy sekvence<br />
<a href="http://www.root.cz/clanky/clojure-aneb-jazyk-umoznujici-tvorbu-bezpecnych-vicevlaknovych-aplikaci-pro-jvm-4-cast-kolekce-sekvence-a-lazy-sekvence/">http://www.root.cz/clanky/clojure-aneb-jazyk-umoznujici-tvorbu-bezpecnych-vicevlaknovych-aplikaci-pro-jvm-4-cast-kolekce-sekvence-a-lazy-sekvence/</a>
</li>

<li>Clojure  5: Sekvence, lazy sekvence a paralelní programy<br />
<a href="http://www.root.cz/clanky/clojure-a-bezpecne-aplikace-pro-jvm-sekvence-lazy-sekvence-a-paralelni-programy/">http://www.root.cz/clanky/clojure-a-bezpecne-aplikace-pro-jvm-sekvence-lazy-sekvence-a-paralelni-programy/</a>
</li>

<li>Clojure  6: Podpora pro paralelní programování<br />
<a href="http://www.root.cz/clanky/programovaci-jazyk-clojure-6-futures-nejsou-jen-financni-derivaty/">http://www.root.cz/clanky/programovaci-jazyk-clojure-6-futures-nejsou-jen-financni-derivaty/</a>
</li>

<li>Clojure  7: Další funkce pro paralelní programování<br />
<a href="http://www.root.cz/clanky/programovaci-jazyk-clojure-7-dalsi-podpurne-prostredky-pro-paralelni-programovani/">http://www.root.cz/clanky/programovaci-jazyk-clojure-7-dalsi-podpurne-prostredky-pro-paralelni-programovani/</a>
</li>

<li>Clojure  8: Identity, stavy, neměnné hodnoty a reference<br />
<a href="http://www.root.cz/clanky/programovaci-jazyk-clojure-8-identity-stavy-nemenne-hodnoty-a-referencni-typy/">http://www.root.cz/clanky/programovaci-jazyk-clojure-8-identity-stavy-nemenne-hodnoty-a-referencni-typy/</a>
</li>

<li>Clojure  9: Validátory, pozorovatelé a kooperace s Javou<br />
<a href="http://www.root.cz/clanky/programovaci-jazyk-clojure-9-validatory-pozorovatele-a-kooperace-mezi-clojure-a-javou/">http://www.root.cz/clanky/programovaci-jazyk-clojure-9-validatory-pozorovatele-a-kooperace-mezi-clojure-a-javou/</a>
</li>

<li>Clojure 10: Kooperace mezi Clojure a Javou<br />
<a href="http://www.root.cz/clanky/programovaci-jazyk-clojure-10-kooperace-mezi-clojure-a-javou-pokracovani/">http://www.root.cz/clanky/programovaci-jazyk-clojure-10-kooperace-mezi-clojure-a-javou-pokracovani/</a>
</li>

<li>Clojure 11: Generátorová notace seznamu/list comprehension<br />
<a href="http://www.root.cz/clanky/programovaci-jazyk-clojure-11-generatorova-notace-seznamu-list-comprehension/">http://www.root.cz/clanky/programovaci-jazyk-clojure-11-generatorova-notace-seznamu-list-comprehension/</a>
</li>

<li>Clojure 12: Překlad programů z Clojure do bajtkódu JVM I:<br />
<a href="http://www.root.cz/clanky/programovaci-jazyk-clojure-12-preklad-programu-z-clojure-do-bajtkodu-jvm/">http://www.root.cz/clanky/programovaci-jazyk-clojure-12-preklad-programu-z-clojure-do-bajtkodu-jvm/</a>
</li>

<li>Clojure 13: Překlad programů z Clojure do bajtkódu JVM II:<br />
<a href="http://www.root.cz/clanky/programovaci-jazyk-clojure-13-preklad-programu-z-clojure-do-bajtkodu-jvm-pokracovani/">http://www.root.cz/clanky/programovaci-jazyk-clojure-13-preklad-programu-z-clojure-do-bajtkodu-jvm-pokracovani/</a>
</li>

<li>Clojure 14: Základy práce se systémem maker<br />
<a href="http://www.root.cz/clanky/programovaci-jazyk-clojure-14-zaklady-prace-se-systemem-maker/">http://www.root.cz/clanky/programovaci-jazyk-clojure-14-zaklady-prace-se-systemem-maker/</a>
</li>

<li>Clojure 15: Tvorba uživatelských maker<br />
<a href="http://www.root.cz/clanky/programovaci-jazyk-clojure-15-tvorba-uzivatelskych-maker/">http://www.root.cz/clanky/programovaci-jazyk-clojure-15-tvorba-uzivatelskych-maker/</a>
</li>

<li>Programovací jazyk Clojure – triky při práci s řetězci<br />
<a href="http://www.root.cz/clanky/programovaci-jazyk-clojure-triky-pri-praci-s-retezci/">http://www.root.cz/clanky/programovaci-jazyk-clojure-triky-pri-praci-s-retezci/</a>
</li>

<li>Programovací jazyk Clojure – triky při práci s kolekcemi<br />
<a href="http://www.root.cz/clanky/programovaci-jazyk-clojure-triky-pri-praci-s-kolekcemi/">http://www.root.cz/clanky/programovaci-jazyk-clojure-triky-pri-praci-s-kolekcemi/</a>
</li>

<li>Programovací jazyk Clojure – práce s mapami a množinami<br />
<a href="http://www.root.cz/clanky/programovaci-jazyk-clojure-prace-s-mapami-a-mnozinami/">http://www.root.cz/clanky/programovaci-jazyk-clojure-prace-s-mapami-a-mnozinami/</a>
</li>

<li>Programovací jazyk Clojure – základy zpracování XML<br />
<a href="http://www.root.cz/clanky/programovaci-jazyk-clojure-zaklady-zpracovani-xml/">http://www.root.cz/clanky/programovaci-jazyk-clojure-zaklady-zpracovani-xml/</a>
</li>

<li>Programovací jazyk Clojure – testování s využitím knihovny Expectations<br />
<a href="http://www.root.cz/clanky/programovaci-jazyk-clojure-testovani-s-vyuzitim-knihovny-expectations/">http://www.root.cz/clanky/programovaci-jazyk-clojure-testovani-s-vyuzitim-knihovny-expectations/</a>
</li>

<li>Programovací jazyk Clojure – některé užitečné triky použitelné (nejenom) v&nbsp;testech<br />
<a href="http://www.root.cz/clanky/programovaci-jazyk-clojure-nektere-uzitecne-triky-pouzitelne-nejenom-v-testech/">http://www.root.cz/clanky/programovaci-jazyk-clojure-nektere-uzitecne-triky-pouzitelne-nejenom-v-testech/</a>
</li>

<li>Enlive – výkonný šablonovací systém pro jazyk Clojure<br/>
<a href="http://www.root.cz/clanky/enlive-vykonny-sablonovaci-system-pro-jazyk-clojure/">http://www.root.cz/clanky/enlive-vykonny-sablonovaci-system-pro-jazyk-clojure/</a>
</li>

<li>Nástroj Leiningen a programovací jazyk Clojure: tvorba vlastních knihoven pro veřejný repositář Clojars<br />
<a href="http://www.root.cz/clanky/nastroj-leiningen-a-programovaci-jazyk-clojure-tvorba-vlastnich-knihoven-pro-verejny-repositar-clojars/">http://www.root.cz/clanky/nastroj-leiningen-a-programovaci-jazyk-clojure-tvorba-vlastnich-knihoven-pro-verejny-repositar-clojars/</a>
</li>

<li>Novinky v Clojure verze 1.8.0<br />
<a href="http://www.root.cz/clanky/novinky-v-clojure-verze-1-8-0/">http://www.root.cz/clanky/novinky-v-clojure-verze-1-8-0/</a>
</li>

<li>Asynchronní programování v&nbsp;Clojure s&nbsp;využitím knihovny core.async<br />
<a href="http://www.root.cz/clanky/asynchronni-programovani-v-clojure-s-vyuzitim-knihovny-core-async/">http://www.root.cz/clanky/asynchronni-programovani-v-clojure-s-vyuzitim-knihovny-core-async/</a>
</li>

<li>Asynchronní programování v&nbsp;Clojure s&nbsp;využitím knihovny core.async (pokračování)<br />
<a href="http://www.root.cz/clanky/asynchronni-programovani-v-clojure-s-vyuzitim-knihovny-core-async-pokracovani/">http://www.root.cz/clanky/asynchronni-programovani-v-clojure-s-vyuzitim-knihovny-core-async-pokracovani/</a>
</li>

<li>Asynchronní programování v Clojure s využitím knihovny core.async (dokončení)<br />
<a href="http://www.root.cz/clanky/asynchronni-programovani-v-clojure-s-vyuzitim-knihovny-core-async-dokonceni/">http://www.root.cz/clanky/asynchronni-programovani-v-clojure-s-vyuzitim-knihovny-core-async-dokonceni/</a>
</li>

<li>Vytváříme IRC bota v programovacím jazyce Clojure<br />
<a href="http://www.root.cz/clanky/vytvarime-irc-bota-v-programovacim-jazyce-clojure/">http://www.root.cz/clanky/vytvarime-irc-bota-v-programovacim-jazyce-clojure/</a>
</li>

<li>Gorilla REPL: interaktivní prostředí pro programovací jazyk Clojure<br />
<a href="https://www.root.cz/clanky/gorilla-repl-interaktivni-prostredi-pro-programovaci-jazyk-clojure/">https://www.root.cz/clanky/gorilla-repl-interaktivni-prostredi-pro-programovaci-jazyk-clojure/</a>
</li>

<li>Multimetody v Clojure aneb polymorfismus bez použití OOP<br />
<a href="https://www.root.cz/clanky/multimetody-v-clojure-aneb-polymorfismus-bez-pouziti-oop/">https://www.root.cz/clanky/multimetody-v-clojure-aneb-polymorfismus-bez-pouziti-oop/</a>
</li>

<li>Práce s externími Java archivy v programovacím jazyku Clojure<br />
<a href="https://www.root.cz/clanky/prace-s-externimi-java-archivy-v-programovacim-jazyku-clojure/">https://www.root.cz/clanky/prace-s-externimi-java-archivy-v-programovacim-jazyku-clojure/</a>
</li>

<li>Clojure 16: Složitější uživatelská makra<br />
<a href="http://www.root.cz/clanky/programovaci-jazyk-clojure-16-slozitejsi-uzivatelska-makra/">http://www.root.cz/clanky/programovaci-jazyk-clojure-16-slozitejsi-uzivatelska-makra/</a>
</li>

<li>Clojure 17: Využití standardních maker v praxi<br />
<a href="http://www.root.cz/clanky/programovaci-jazyk-clojure-17-vyuziti-standardnich-maker-v-praxi/">http://www.root.cz/clanky/programovaci-jazyk-clojure-17-vyuziti-standardnich-maker-v-praxi/</a>
</li>

<li>Clojure 18: Základní techniky optimalizace aplikací<br />
<a href="http://www.root.cz/clanky/programovaci-jazyk-clojure-18-zakladni-techniky-optimalizace-aplikaci/">http://www.root.cz/clanky/programovaci-jazyk-clojure-18-zakladni-techniky-optimalizace-aplikaci/</a>
</li>

<li>Clojure 19: Vývojová prostředí pro Clojure<br />
<a href="http://www.root.cz/clanky/programovaci-jazyk-clojure-19-vyvojova-prostredi-pro-clojure/">http://www.root.cz/clanky/programovaci-jazyk-clojure-19-vyvojova-prostredi-pro-clojure/</a>
</li>

<li>Clojure 20: Vývojová prostředí pro Clojure (Vimu s REPL)<br />
<a href="http://www.root.cz/clanky/programovaci-jazyk-clojure-20-vyvojova-prostredi-pro-clojure-integrace-vimu-s-repl/">http://www.root.cz/clanky/programovaci-jazyk-clojure-20-vyvojova-prostredi-pro-clojure-integrace-vimu-s-repl/</a>
</li>

<li>Clojure 21: ClojureScript aneb překlad Clojure do JS<br />
<a href="http://www.root.cz/clanky/programovaci-jazyk-clojure-21-clojurescript-aneb-preklad-clojure-do-javascriptu/">http://www.root.cz/clanky/programovaci-jazyk-clojure-21-clojurescript-aneb-preklad-clojure-do-javascriptu/</a>
</li>

<li>Leiningen: nástroj pro správu projektů napsaných v Clojure<br />
<a href="http://www.root.cz/clanky/leiningen-nastroj-pro-spravu-projektu-napsanych-v-clojure/">http://www.root.cz/clanky/leiningen-nastroj-pro-spravu-projektu-napsanych-v-clojure/</a>
</li>

<li>Leiningen: nástroj pro správu projektů napsaných v Clojure (2)<br />
<a href="http://www.root.cz/clanky/leiningen-nastroj-pro-spravu-projektu-napsanych-v-clojure-2/">http://www.root.cz/clanky/leiningen-nastroj-pro-spravu-projektu-napsanych-v-clojure-2/</a>
</li>

<li>Leiningen: nástroj pro správu projektů napsaných v Clojure (3)<br />
<a href="http://www.root.cz/clanky/leiningen-nastroj-pro-spravu-projektu-napsanych-v-clojure-3/">http://www.root.cz/clanky/leiningen-nastroj-pro-spravu-projektu-napsanych-v-clojure-3/</a>
</li>

<li>Leiningen: nástroj pro správu projektů napsaných v Clojure (4)<br />
<a href="http://www.root.cz/clanky/leiningen-nastroj-pro-spravu-projektu-napsanych-v-clojure-4/">http://www.root.cz/clanky/leiningen-nastroj-pro-spravu-projektu-napsanych-v-clojure-4/</a>
</li>

<li>Leiningen: nástroj pro správu projektů napsaných v Clojure (5)<br />
<a href="http://www.root.cz/clanky/leiningen-nastroj-pro-spravu-projektu-napsanych-v-clojure-5/">http://www.root.cz/clanky/leiningen-nastroj-pro-spravu-projektu-napsanych-v-clojure-5/</a>
</li>

<li>Leiningen: nástroj pro správu projektů napsaných v Clojure (6)<br />
<a href="http://www.root.cz/clanky/leiningen-nastroj-pro-spravu-projektu-napsanych-v-clojure-6/">http://www.root.cz/clanky/leiningen-nastroj-pro-spravu-projektu-napsanych-v-clojure-6/</a>
</li>

<li>Programovací jazyk Clojure a databáze (1.část)<br />
<a href="http://www.root.cz/clanky/programovaci-jazyk-clojure-a-databaze-1-cast/">http://www.root.cz/clanky/programovaci-jazyk-clojure-a-databaze-1-cast/</a>
</li>

<li>Pluginy pro Leiningen<br />
<a href="http://www.root.cz/clanky/leiningen-nastroj-pro-spravu-projektu-napsanych-v-clojure-pluginy-pro-leiningen/">http://www.root.cz/clanky/leiningen-nastroj-pro-spravu-projektu-napsanych-v-clojure-pluginy-pro-leiningen/</a>
</li>

<li>Programovací jazyk Clojure a knihovny pro práci s vektory a maticemi<br />
<a href="http://www.root.cz/clanky/programovaci-jazyk-clojure-a-knihovny-pro-praci-s-vektory-a-maticemi/">http://www.root.cz/clanky/programovaci-jazyk-clojure-a-knihovny-pro-praci-s-vektory-a-maticemi/</a>
</li>

<li>Programovací jazyk Clojure a knihovny pro práci s vektory a maticemi (2)<br />
<a href="http://www.root.cz/clanky/programovaci-jazyk-clojure-a-knihovny-pro-praci-s-vektory-a-maticemi-2/">http://www.root.cz/clanky/programovaci-jazyk-clojure-a-knihovny-pro-praci-s-vektory-a-maticemi-2/</a>
</li>

<li>Programovací jazyk Clojure: syntéza procedurálních textur s využitím knihovny Clisk<br />
<a href="http://www.root.cz/clanky/programovaci-jazyk-clojure-synteza-proceduralnich-textur-s-vyuzitim-knihovny-clisk/">http://www.root.cz/clanky/programovaci-jazyk-clojure-synteza-proceduralnich-textur-s-vyuzitim-knihovny-clisk/</a>
</li>

<li>Programovací jazyk Clojure: syntéza procedurálních textur s využitím knihovny Clisk (2)<br />
<a href="http://www.root.cz/clanky/programovaci-jazyk-clojure-synteza-proceduralnich-textur-s-vyuzitim-knihovny-clisk-2/">http://www.root.cz/clanky/programovaci-jazyk-clojure-synteza-proceduralnich-textur-s-vyuzitim-knihovny-clisk-2/</a>
</li>

<li>Seesaw: knihovna pro snadnou tvorbu GUI v jazyce Clojure<br />
<a href="http://www.root.cz/clanky/seesaw-knihovna-pro-snadnou-tvorbu-gui-v-jazyce-clojure/">http://www.root.cz/clanky/seesaw-knihovna-pro-snadnou-tvorbu-gui-v-jazyce-clojure/</a>
</li>

<li>Seesaw: knihovna pro snadnou tvorbu GUI v jazyce Clojure (2)<br />
<a href="http://www.root.cz/clanky/seesaw-knihovna-pro-snadnou-tvorbu-gui-v-jazyce-clojure-2/">http://www.root.cz/clanky/seesaw-knihovna-pro-snadnou-tvorbu-gui-v-jazyce-clojure-2/</a>
</li>

<li>Seesaw: knihovna pro snadnou tvorbu GUI v jazyce Clojure (3)<br />
<a href="http://www.root.cz/clanky/seesaw-knihovna-pro-snadnou-tvorbu-gui-v-jazyce-clojure-3/">http://www.root.cz/clanky/seesaw-knihovna-pro-snadnou-tvorbu-gui-v-jazyce-clojure-3/</a>
</li>

<li>Programovací jazyk Clojure a práce s Gitem<br />
<a href="http://www.root.cz/clanky/programovaci-jazyk-clojure-a-prace-s-gitem/">http://www.root.cz/clanky/programovaci-jazyk-clojure-a-prace-s-gitem/</a>
</li>

<li>Programovací jazyk Clojure a práce s Gitem (2)<br />
<a href="http://www.root.cz/clanky/programovaci-jazyk-clojure-a-prace-s-gitem-2/">http://www.root.cz/clanky/programovaci-jazyk-clojure-a-prace-s-gitem-2/</a>
</li>

<li>Programovací jazyk Clojure: syntéza procedurálních textur s využitím knihovny Clisk (dokončení)<br />
<a href="http://www.root.cz/clanky/programovaci-jazyk-clojure-synteza-proceduralnich-textur-s-vyuzitim-knihovny-clisk-dokonceni/">http://www.root.cz/clanky/programovaci-jazyk-clojure-synteza-proceduralnich-textur-s-vyuzitim-knihovny-clisk-dokonceni/</a>
</li>

<li>Pixie: lehký skriptovací jazyk s „kouzelnými“ schopnostmi<br />
<a href="https://www.root.cz/clanky/pixie-lehky-skriptovaci-jazyk-s-kouzelnymi-schopnostmi/">https://www.root.cz/clanky/pixie-lehky-skriptovaci-jazyk-s-kouzelnymi-schopnostmi/</a>
</li>

<li>Programovací jazyk Pixie: funkce ze základní knihovny a použití FFI<br />
<a href="https://www.root.cz/clanky/programovaci-jazyk-pixie-funkce-ze-zakladni-knihovny-a-pouziti-ffi/">https://www.root.cz/clanky/programovaci-jazyk-pixie-funkce-ze-zakladni-knihovny-a-pouziti-ffi/</a>
</li>

<li>Novinky v Clojure verze 1.9.0<br />
<a href="https://www.root.cz/clanky/novinky-v-clojure-verze-1-9-0/">https://www.root.cz/clanky/novinky-v-clojure-verze-1-9-0/</a>
</li>

<li>Validace dat s&nbsp;využitím knihovny spec v&nbsp;Clojure 1.9.0<br />
<a href="https://www.root.cz/clanky/validace-dat-s-vyuzitim-knihovny-spec-v-clojure-1-9-0/">https://www.root.cz/clanky/validace-dat-s-vyuzitim-knihovny-spec-v-clojure-1-9-0/</a>
</li>

<li>Použití jazyka Gherkin při tvorbě testovacích scénářů pro aplikace psané v Clojure<br />
<a href="https://www.root.cz/clanky/pouziti-jazyka-gherkin-pri-tvorbe-testovacich-scenaru-pro-aplikace-psane-v-nbsp-clojure/">https://www.root.cz/clanky/pouziti-jazyka-gherkin-pri-tvorbe-testovacich-scenaru-pro-aplikace-psane-v-nbsp-clojure/</a>
</li>

<li>Použití jazyka Gherkin při tvorbě testovacích scénářů pro aplikace psané v Clojure (2)<br />
<a href="https://www.root.cz/clanky/pouziti-jazyka-gherkin-pri-tvorbe-testovacich-scenaru-pro-aplikace-psane-v-nbsp-clojure-2/">https://www.root.cz/clanky/pouziti-jazyka-gherkin-pri-tvorbe-testovacich-scenaru-pro-aplikace-psane-v-nbsp-clojure-2/</a>
</li>

<li>Incanter: prostředí pro statistické výpočty s grafickým výstupem založené na Clojure<br />
<a href="https://www.root.cz/clanky/incanter-prostredi-pro-statisticke-vypocty-s-grafickym-vystupem-zalozene-na-clojure/">https://www.root.cz/clanky/incanter-prostredi-pro-statisticke-vypocty-s-grafickym-vystupem-zalozene-na-clojure/</a>
</li>

<li>Incanter: operace s maticemi<br />
<a href="https://www.root.cz/clanky/incanter-operace-s-maticemi/">https://www.root.cz/clanky/incanter-operace-s-maticemi/</a>
</li>

<li>Pixie: lehký skriptovací jazyk s „kouzelnými“ schopnostmi<br />
<a href="https://www.root.cz/clanky/pixie-lehky-skriptovaci-jazyk-s-kouzelnymi-schopnostmi/">https://www.root.cz/clanky/pixie-lehky-skriptovaci-jazyk-s-kouzelnymi-schopnostmi/</a>
</li>

<li>Programovací jazyk Pixie: funkce ze základní knihovny a použití FFI<br />
<a href="https://www.root.cz/clanky/programovaci-jazyk-pixie-funkce-ze-zakladni-knihovny-a-pouziti-ffi/">https://www.root.cz/clanky/programovaci-jazyk-pixie-funkce-ze-zakladni-knihovny-a-pouziti-ffi/</a>
</li>

<li>Novinky v Clojure verze 1.9.0<br />
<a href="https://www.root.cz/clanky/novinky-v-clojure-verze-1-9-0/">https://www.root.cz/clanky/novinky-v-clojure-verze-1-9-0/</a>
</li>

<li>Validace dat s&nbsp;využitím knihovny spec v&nbsp;Clojure 1.9.0<br />
<a href="https://www.root.cz/clanky/validace-dat-s-vyuzitim-knihovny-spec-v-clojure-1-9-0/">https://www.root.cz/clanky/validace-dat-s-vyuzitim-knihovny-spec-v-clojure-1-9-0/</a>
</li>

<li>Použití jazyka Gherkin při tvorbě testovacích scénářů pro aplikace psané v&nbsp;Clojure<br />
<a href="https://www.root.cz/clanky/pouziti-jazyka-gherkin-pri-tvorbe-testovacich-scenaru-pro-aplikace-psane-v-nbsp-clojure/">https://www.root.cz/clanky/pouziti-jazyka-gherkin-pri-tvorbe-testovacich-scenaru-pro-aplikace-psane-v-nbsp-clojure/</a>
</li>

<li>Použití jazyka Gherkin při tvorbě testovacích scénářů pro aplikace psané v&nbsp;Clojure (2)<br />
<a href="https://www.root.cz/clanky/pouziti-jazyka-gherkin-pri-tvorbe-testovacich-scenaru-pro-aplikace-psane-v-nbsp-clojure-2/">https://www.root.cz/clanky/pouziti-jazyka-gherkin-pri-tvorbe-testovacich-scenaru-pro-aplikace-psane-v-nbsp-clojure-2/</a>
</li>

<li>Interpret programovacího jazyka Clojure integrovaný do Jupyter Notebooku<br />
<a href="https://www.root.cz/clanky/interpret-programovaciho-jazyka-clojure-integrovany-do-jupyter-notebooku/">https://www.root.cz/clanky/interpret-programovaciho-jazyka-clojure-integrovany-do-jupyter-notebooku/</a>
</li>

</ol>



<p><a name="k20"></a></p>
<h2 id="k20">20. Odkazy na Internetu</h2>

<ol>

<li>babashka: A Clojure babushka for the grey areas of Bash<br />
<a href="https://github.com/borkdude/babashka">https://github.com/borkdude/babashka</a>
</li>

<li>Babashka and the Small Clojure Interpreter @ ClojureD 2020 (slajdy)<br />
<a href="https://speakerdeck.com/borkdude/babashka-and-the-small-clojure-interpreter-at-clojured-2020">https://speakerdeck.com/borkdude/babashka-and-the-small-clojure-interpreter-at-clojured-2020</a>
</li>

<li>Babashka: ukázky použití<br />
<a href="https://github.com/borkdude/babashka/blob/master/doc/examples.md">https://github.com/borkdude/babashka/blob/master/doc/examples.md</a>
</li>

<li>clojureD 2020: "Babashka and Small Clojure Interpreter: Clojure in new contexts" by Michiel Borkent<br />
<a href="https://www.youtube.com/watch?v=Nw8aN-nrdEk&amp;t=5s">https://www.youtube.com/watch?v=Nw8aN-nrdEk&amp;t=5s</a>
</li>

<li>Meetup #124 Babashka, implementing an nREPL server &amp; game engines with Clojure<br />
<a href="https://www.youtube.com/watch?v=0YmZYnwyHHc">https://www.youtube.com/watch?v=0YmZYnwyHHc</a>
</li>

<li>The Last Programming Language (shrnutí vývoje programovacích jazyků)<br />
<a href="https://www.youtube.com/watch?v=P2yr-3F6PQo">https://www.youtube.com/watch?v=P2yr-3F6PQo</a>
</li>

<li>Shebang (Unix): Wikipedia EN<br />
<a href="https://en.wikipedia.org/wiki/Shebang_(Unix)">https://en.wikipedia.org/wiki/Shebang_(Unix)</a>
</li>

<li>Shebang (Unix): Wikipedia CZ<br />
<a href="https://cs.wikipedia.org/wiki/Shebang_(Unix)">https://cs.wikipedia.org/wiki/Shebang_(Unix)</a>
</li>

<li>How to create Clojure notebooks in Jupyter<br />
<a href="https://s01blog.wordpress.com/2017/12/10/how-to-create-clojure-notebooks-in-jupyter/">https://s01blog.wordpress.com/2017/12/10/how-to-create-clojure-notebooks-in-jupyter/</a>
</li>

<li>Dokumentace k&nbsp;nástroji Conda<br />
<a href="https://docs.conda.io/en/latest/">https://docs.conda.io/en/latest/</a>
</li>

<li>Notebook interface<br />
<a href="https://en.wikipedia.org/wiki/Notebook_interface">https://en.wikipedia.org/wiki/Notebook_interface</a>
</li>

<li>Jypyter: open source, interactive data science and scientific computing across over 40 programming languages<br />
<a href="https://jupyter.org/">https://jupyter.org/</a>
</li>

<li>Calysto Scheme<br />
<a href="https://github.com/Calysto/calysto_scheme">https://github.com/Calysto/calysto_scheme</a>
</li>

<li>scheme.py (základ projektu Calysto Scheme)<br />
<a href="https://github.com/Calysto/calysto_scheme/blob/master/calysto_scheme/scheme.py">https://github.com/Calysto/calysto_scheme/blob/master/calysto_scheme/scheme.py</a>
</li>


<li>Humane test output for clojure.test<br />
<a href="https://github.com/pjstadig/humane-test-output">https://github.com/pjstadig/humane-test-output</a>
</li>

<li>iota<br />
<a href="https://github.com/juxt/iota">https://github.com/juxt/iota</a>
</li>

<li>5 Differences between clojure.spec and Schema<br />
<a href="https://lispcast.com/clojure.spec-vs-schema/">https://lispcast.com/clojure.spec-vs-schema/</a>
</li>

<li>Schema: Clojure(Script) library for declarative data description and validation<br />
<a href="https://github.com/plumatic/schema">https://github.com/plumatic/schema</a>
</li>

<li>Zip archiv s&nbsp;Clojure 1.9.0<br />
<a href="http://repo1.maven.org/maven2/org/clojure/clojure/1.9.0/clojure-1.9.0.zip">http://repo1.maven.org/maven2/org/clojure/clojure/1.9.0/clojure-1.9.0.zip</a>
</li>

<li>Clojure 1.9 is now available<br />
<a href="https://clojure.org/news/2017/12/08/clojure19">https://clojure.org/news/2017/12/08/clojure19</a>
</li>

<li>Deps and CLI Guide<br />
<a href="https://clojure.org/guides/deps_and_cli">https://clojure.org/guides/deps_and_cli</a>
</li>

<li>Changes to Clojure in Version 1.9<br />
<a href="https://github.com/clojure/clojure/blob/master/changes.md">https://github.com/clojure/clojure/blob/master/changes.md</a>
</li>

<li>clojure.spec - Rationale and Overview<br />
<a href="https://clojure.org/about/spec">https://clojure.org/about/spec</a>
</li>

<li>Zip archiv s&nbsp;Clojure 1.8.0<br />
<a href="http://repo1.maven.org/maven2/org/clojure/clojure/1.8.0/clojure-1.8.0.zip">http://repo1.maven.org/maven2/org/clojure/clojure/1.8.0/clojure-1.8.0.zip</a>
</li>

<li>Clojure 1.8 is now available<br />
<a href="http://clojure.org/news/2016/01/19/clojure18">http://clojure.org/news/2016/01/19/clojure18</a>
</li>

<li>Socket Server REPL<br />
<a href="http://dev.clojure.org/display/design/Socket+Server+REPL">http://dev.clojure.org/display/design/Socket+Server+REPL</a>
</li>

<li>CLJ-1671: Clojure socket server<br />
<a href="http://dev.clojure.org/jira/browse/CLJ-1671">http://dev.clojure.org/jira/browse/CLJ-1671</a>
</li>

<li>CLJ-1449: Add clojure.string functions for portability to ClojureScript<br />
<a href="http://dev.clojure.org/jira/browse/CLJ-1449">http://dev.clojure.org/jira/browse/CLJ-1449</a>
</li>

<li>Launching a Socket Server<br />
<a href="http://clojure.org/reference/repl_and_main#_launching_a_socket_server">http://clojure.org/reference/repl_and_main#_launching_a_socket_server</a>
</li>

<li>API for clojure.string<br />
<a href="http://clojure.github.io/clojure/branch-master/clojure.string-api.html">http://clojure.github.io/clojure/branch-master/clojure.string-api.html</a>
</li>

<li>Clojars:<br />
<a href="https://clojars.org/">https://clojars.org/</a>
</li>

<li>Seznam knihoven na Clojars:<br />
<a href="https://clojars.org/projects">https://clojars.org/projects</a>
</li>

<li>Clojure Cookbook: Templating HTML with Enlive<br />
<a href="https://github.com/clojure-cookbook/clojure-cookbook/blob/master/07_webapps/7-11_enlive.asciidoc">https://github.com/clojure-cookbook/clojure-cookbook/blob/master/07_webapps/7-11_enlive.asciidoc</a>
</li>

<li>An Introduction to Enlive<br />
<a href="https://github.com/swannodette/enlive-tutorial/">https://github.com/swannodette/enlive-tutorial/</a>
</li>

<li>Enlive na GitHubu<br />
<a href="https://github.com/cgrand/enlive">https://github.com/cgrand/enlive</a>
</li>

<li>Expectations: příklady atd.<br />
<a href="http://jayfields.com/expectations/">http://jayfields.com/expectations/</a>
</li>

<li>Expectations na GitHubu<br />
<a href="https://github.com/jaycfields/expectations">https://github.com/jaycfields/expectations</a>
</li>

<li>Lein-expectations na GitHubu<br />
<a href="https://github.com/gar3thjon3s/lein-expectations">https://github.com/gar3thjon3s/lein-expectations</a>
</li>

<li>Testing Clojure With Expectations<br />
<a href="https://semaphoreci.com/blog/2014/09/23/testing-clojure-with-expectations.html">https://semaphoreci.com/blog/2014/09/23/testing-clojure-with-expectations.html</a>
</li>

<li>Clojure testing TDD/BDD libraries: clojure.test vs Midje vs Expectations vs Speclj<br />
<a href="https://www.reddit.com/r/Clojure/comments/1viilt/clojure_testing_tddbdd_libraries_clojuretest_vs/">https://www.reddit.com/r/Clojure/comments/1viilt/clojure_testing_tddbdd_libraries_clojuretest_vs/</a>
</li>

<li>Testing: One assertion per test<br />
<a href="http://blog.jayfields.com/2007/06/testing-one-assertion-per-test.html">http://blog.jayfields.com/2007/06/testing-one-assertion-per-test.html</a>
</li>

<li>Rewriting Your Test Suite in Clojure in 24 hours<br />
<a href="http://blog.circleci.com/rewriting-your-test-suite-in-clojure-in-24-hours/">http://blog.circleci.com/rewriting-your-test-suite-in-clojure-in-24-hours/</a>
</li>

<li>Clojure doc: zipper<br />
<a href="http://clojuredocs.org/clojure.zip/zipper">http://clojuredocs.org/clojure.zip/zipper</a>
</li>

<li>Clojure doc: parse<br />
<a href="http://clojuredocs.org/clojure.xml/parse">http://clojuredocs.org/clojure.xml/parse</a>
</li>

<li>Clojure doc: xml-zip<br />
<a href="http://clojuredocs.org/clojure.zip/xml-zip">http://clojuredocs.org/clojure.zip/xml-zip</a>
</li>

<li>Clojure doc: xml-seq<br />
<a href="http://clojuredocs.org/clojure.core/xml-seq">http://clojuredocs.org/clojure.core/xml-seq</a>
</li>

<li>Parsing XML in Clojure<br />
<a href="https://github.com/clojuredocs/guides">https://github.com/clojuredocs/guides</a>
</li>

<li>Clojure Zipper Over Nested Vector<br />
<a href="https://vitalyper.wordpress.com/2010/11/23/clojure-zipper-over-nested-vector/">https://vitalyper.wordpress.com/2010/11/23/clojure-zipper-over-nested-vector/</a>
</li>

<li>Understanding Clojure's PersistentVector implementation<br />
<a href="http://blog.higher-order.net/2009/02/01/understanding-clojures-persistentvector-implementation">http://blog.higher-order.net/2009/02/01/understanding-clojures-persistentvector-implementation</a>
</li>

<li>Understanding Clojure's PersistentHashMap (deftwice...)<br />
<a href="http://blog.higher-order.net/2009/09/08/understanding-clojures-persistenthashmap-deftwice.html">http://blog.higher-order.net/2009/09/08/understanding-clojures-persistenthashmap-deftwice.html</a>
</li>

<li>Assoc and Clojure's PersistentHashMap: part ii<br />
<a href="http://blog.higher-order.net/2010/08/16/assoc-and-clojures-persistenthashmap-part-ii.html">http://blog.higher-order.net/2010/08/16/assoc-and-clojures-persistenthashmap-part-ii.html</a>
</li>

<li>Ideal Hashtrees (paper)<br />
<a href="http://lampwww.epfl.ch/papers/idealhashtrees.pdf">http://lampwww.epfl.ch/papers/idealhashtrees.pdf</a>
</li>

<li>Clojure home page<br />
<a href="http://clojure.org/">http://clojure.org/</a>
</li>

<li>Clojure (downloads)<br />
<a href="http://clojure.org/downloads">http://clojure.org/downloads</a>
</li>

<li>Clojure Sequences<br />
<a href="http://clojure.org/sequences">http://clojure.org/sequences</a>
</li>

<li>Clojure Data Structures<br />
<a href="http://clojure.org/data_structures">http://clojure.org/data_structures</a>
</li>

<li>The Structure and Interpretation of Computer Programs: 2.2.1  Representing Sequences<br />
<a href="http://mitpress.mit.edu/sicp/full-text/book/book-Z-H-15.html#%_sec_2.2.1">http://mitpress.mit.edu/sicp/full-text/book/book-Z-H-15.html#%_sec_2.2.1</a>
</li>

<li>The Structure and Interpretation of Computer Programs: 3.3.1  Mutable List Structure<br />
<a href="http://mitpress.mit.edu/sicp/full-text/book/book-Z-H-22.html#%_sec_3.3.1">http://mitpress.mit.edu/sicp/full-text/book/book-Z-H-22.html#%_sec_3.3.1</a>
</li>

<li>Clojure - Functional Programming for the JVM<br />
<a href="http://java.ociweb.com/mark/clojure/article.html">http://java.ociweb.com/mark/clojure/article.html</a>
</li>

<li>Clojure quick reference<br />
<a href="http://faustus.webatu.com/clj-quick-ref.html">http://faustus.webatu.com/clj-quick-ref.html</a>
</li>

<li>4Clojure<br />
<a href="http://www.4clojure.com/">http://www.4clojure.com/</a>
</li>

<li>ClojureDoc (rozcestník s&nbsp;dokumentací jazyka Clojure)<br />
<a href="http://clojuredocs.org/">http://clojuredocs.org/</a>
</li>

<li>Clojure (na Wikipedia EN)<br />
<a href="http://en.wikipedia.org/wiki/Clojure">http://en.wikipedia.org/wiki/Clojure</a>
</li>

<li>Clojure (na Wikipedia CS)<br />
<a href="http://cs.wikipedia.org/wiki/Clojure">http://cs.wikipedia.org/wiki/Clojure</a>
</li>

<li>SICP (The Structure and Interpretation of Computer Programs)<br />
<a href="http://mitpress.mit.edu/sicp/">http://mitpress.mit.edu/sicp/</a>
</li>

<li>Pure function<br />
<a href="http://en.wikipedia.org/wiki/Pure_function">http://en.wikipedia.org/wiki/Pure_function</a>
</li>

<li>Funkcionální programování<br />
<a href="http://cs.wikipedia.org/wiki/Funkcionální_programování">http://cs.wikipedia.org/wiki/Funkcionální_programování</a>
</li>

<li>Čistě funkcionální (datové struktury, jazyky, programování)<br />
<a href="http://cs.wikipedia.org/wiki/Čistě_funkcionální">http://cs.wikipedia.org/wiki/Čistě_funkcionální</a>
</li>

<li>Clojure Macro Tutorial (Part I, Getting the Compiler to Write Your Code For You)<br />
<a href="http://www.learningclojure.com/2010/09/clojure-macro-tutorial-part-i-getting.html">http://www.learningclojure.com/2010/09/clojure-macro-tutorial-part-i-getting.html</a>
</li>

<li>Clojure Macro Tutorial (Part II: The Compiler Strikes Back)<br />
<a href="http://www.learningclojure.com/2010/09/clojure-macro-tutorial-part-ii-compiler.html">http://www.learningclojure.com/2010/09/clojure-macro-tutorial-part-ii-compiler.html</a>
</li>

<li>Clojure Macro Tutorial (Part III: Syntax Quote)<br />
<a href="http://www.learningclojure.com/2010/09/clojure-macro-tutorial-part-ii-syntax.html">http://www.learningclojure.com/2010/09/clojure-macro-tutorial-part-ii-syntax.html</a>
</li>

<li>Tech behind Tech: Clojure Macros Simplified<br />
<a href="http://techbehindtech.com/2010/09/28/clojure-macros-simplified/">http://techbehindtech.com/2010/09/28/clojure-macros-simplified/</a>
</li>

<li>Fatvat - Exploring functional programming: Clojure Macros<br />
<a href="http://www.fatvat.co.uk/2009/02/clojure-macros.html">http://www.fatvat.co.uk/2009/02/clojure-macros.html</a>
</li>

<li>Eulerovo číslo<br />
<a href="http://cs.wikipedia.org/wiki/Eulerovo_číslo">http://cs.wikipedia.org/wiki/Eulerovo_číslo</a>
</li>

<li>List comprehension<br />
<a href="http://en.wikipedia.org/wiki/List_comprehension">http://en.wikipedia.org/wiki/List_comprehension</a>
</li>

<li>List Comprehensions in Clojure<br />
<a href="http://asymmetrical-view.com/2008/11/18/list-comprehensions-in-clojure.html">http://asymmetrical-view.com/2008/11/18/list-comprehensions-in-clojure.html</a>
</li>

<li>Clojure Programming Concepts: List Comprehension<br />
<a href="http://en.wikibooks.org/wiki/Clojure_Programming/Concepts#List_Comprehension">http://en.wikibooks.org/wiki/Clojure_Programming/Concepts#List_Comprehension</a>
</li>

<li>Clojure core API: for macro<br />
<a href="http://clojure.github.com/clojure/clojure.core-api.html#clojure.core/for">http://clojure.github.com/clojure/clojure.core-api.html#clojure.core/for</a>
</li>

<li>cirrus machina - The Clojure for macro<br />
<a href="http://www.cirrusmachina.com/blog/comment/the-clojure-for-macro/">http://www.cirrusmachina.com/blog/comment/the-clojure-for-macro/</a>
</li>

<li>Riastradh's Lisp Style Rules<br />
<a href="http://mumble.net/~campbell/scheme/style.txt">http://mumble.net/~campbell/scheme/style.txt</a>
</li>

<li>Dynamic Languages Strike Back<br />
<a href="http://steve-yegge.blogspot.cz/2008/05/dynamic-languages-strike-back.html">http://steve-yegge.blogspot.cz/2008/05/dynamic-languages-strike-back.html</a>
</li>

<li>Scripting: Higher Level Programming for the 21st Century<br />
<a href="http://www.tcl.tk/doc/scripting.html">http://www.tcl.tk/doc/scripting.html</a>
</li>

<li>Java Virtual Machine Support for Non-Java Languages<br />
<a href="http://docs.oracle.com/javase/7/docs/technotes/guides/vm/multiple-language-support.html">http://docs.oracle.com/javase/7/docs/technotes/guides/vm/multiple-language-support.html</a>
</li>

<li>Třída java.lang.String<br />
<a href="http://docs.oracle.com/javase/7/docs/api/java/lang/String.html">http://docs.oracle.com/javase/7/docs/api/java/lang/String.html</a>
</li>

<li>Třída java.lang.StringBuffer<br />
<a href="http://docs.oracle.com/javase/7/docs/api/java/lang/StringBuffer.html">http://docs.oracle.com/javase/7/docs/api/java/lang/StringBuffer.html</a>
</li>

<li>Třída java.lang.StringBuilder<br />
<a href="http://docs.oracle.com/javase/7/docs/api/java/lang/StringBuilder.html">http://docs.oracle.com/javase/7/docs/api/java/lang/StringBuilder.html</a>
</li>

<li>StringBuffer versus String<br />
<a href="http://www.javaworld.com/article/2076072/build-ci-sdlc/stringbuffer-versus-string.html">http://www.javaworld.com/article/2076072/build-ci-sdlc/stringbuffer-versus-string.html</a>
</li>

<li>Threading macro (dokumentace k&nbsp;jazyku Clojure)<br />
<a href="https://clojure.github.io/clojure/clojure.core-api.html#clojure.core/-&gt;">https://clojure.github.io/clojure/clojure.core-api.html#clojure.core/-&gt;</a>
</li>

<li>Understanding the Clojure -&gt; macro<br />
<a href="http://blog.fogus.me/2009/09/04/understanding-the-clojure-macro/">http://blog.fogus.me/2009/09/04/understanding-the-clojure-macro/</a>
</li>

<li>clojure.inspector<br />
<a href="http://clojure.github.io/clojure/clojure.inspector-api.html">http://clojure.github.io/clojure/clojure.inspector-api.html</a>
</li>

<li>The Clojure Toolbox<br />
<a href="http://www.clojure-toolbox.com/">http://www.clojure-toolbox.com/</a>
</li>

<li>Unit Testing in Clojure<br />
<a href="http://nakkaya.com/2009/11/18/unit-testing-in-clojure/">http://nakkaya.com/2009/11/18/unit-testing-in-clojure/</a>
</li>

<li>Testing in Clojure (Part-1: Unit testing)<br />
<a href="http://blog.knoldus.com/2014/03/22/testing-in-clojure-part-1-unit-testing/">http://blog.knoldus.com/2014/03/22/testing-in-clojure-part-1-unit-testing/</a>
</li>

<li>API for clojure.test - Clojure v1.6 (stable)<br />
<a href="https://clojure.github.io/clojure/clojure.test-api.html">https://clojure.github.io/clojure/clojure.test-api.html</a>
</li>

<li>Leiningen: úvodní stránka<br />
<a href="http://leiningen.org/">http://leiningen.org/</a>
</li>

<li>Leiningen: Git repository<br />
<a href="https://github.com/technomancy/leiningen">https://github.com/technomancy/leiningen</a>
</li>

<li>leiningen-win-installer<br />
<a href="http://leiningen-win-installer.djpowell.net/">http://leiningen-win-installer.djpowell.net/</a>
</li>

<li>Clojure.org: Vars and the Global Environment<br />
<a href="http://clojure.org/Vars">http://clojure.org/Vars</a>
</li>

<li>Clojure.org: Refs and Transactions<br />
<a href="http://clojure.org/Refs">http://clojure.org/Refs</a>
</li>

<li>Clojure.org: Atoms<br />
<a href="http://clojure.org/Atoms">http://clojure.org/Atoms</a>
</li>

<li>Clojure.org: Agents as Asynchronous Actions<br />
<a href="http://clojure.org/agents">http://clojure.org/agents</a>
</li>

<li>Transient Data Structures<br />
<a href="http://clojure.org/transients">http://clojure.org/transients</a>
</li>

</ol>



<p></p><p></p>
<p><small>Autor: <a href="http://www.fit.vutbr.cz/~tisnovpa">Pavel Tišnovský</a> &nbsp; 2018</small></p>
</body>
</html>

