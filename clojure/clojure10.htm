<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
        "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html>
<head>
<title>Programovací jazyk Clojure a knihovny pro práci s vektory a maticemi (2)</title>
<meta name="Author" content="Pavel Tisnovsky" />
<meta name="Generator" content="vim" />
<meta http-equiv="content-type" content="text/html; charset=utf-8" />
<style type="text/css">
         body {color:#000000; background:#ffffff;}
         h1  {font-family: arial, helvetica, sans-serif; color:#ffffff; background-color:#c00000; text-align:center; padding-left:1em}
         h2  {font-family: arial, helvetica, sans-serif; color:#ffffff; background-color:#0000c0; padding-left:1em; text-align:left}
         h3  {font-family: arial, helvetica, sans-serif; color:#000000; background-color:#c0c0c0; padding-left:1em; text-align:left}
         h4  {font-family: arial, helvetica, sans-serif; color:#000000; background-color:#e0e0e0; padding-left:1em; text-align:left}
         a   {font-family: arial, helvetica, sans-serif;}
         li  {font-family: arial, helvetica, sans-serif; color:#000000; text-align:justify; width:450px;}
         ol  {font-family: arial, helvetica, sans-serif; color:#000000; text-align:justify; width:450px;}
         ul  {font-family: arial, helvetica, sans-serif; color:#000000; text-align:justify; width:450px;}
         p   {font-family: arial, helvetica, sans-serif; color:#000000; text-align:justify;}
         pre {background:#e0e0e0}
</style>
</head>

<body>

<h1>Programovací jazyk Clojure a knihovny pro práci s vektory a maticemi (2)</h1>

<h3>Pavel Tišnovský</h3>

<p></p>

<h1>Úvodník</h1>

<p>Ve druhé části článku o knihovnách určených pro práci s vektory a maticemi v programovacím jazyku Clojure dokončíme popis knihovny nazvané core.matrix. Řekneme si mj. i o několika způsobech ukládání vektorů a matic v operační paměti i o použití takzvaných pohledů (views).</p>



<h2>Obsah</h2>

<p><a href="#k01">1. Práce s&nbsp;vektory v&nbsp;knihovně <strong>core.matrix</strong></a></p>
<p><a href="#k02">2. Pomocná makra pro výpis prováděné operace i jejího výsledku</a></p>
<p><a href="#k03">3. Operátory</a></p>
<p><a href="#k04">4. Funkce pracující s&nbsp;vektory</a></p>
<p><a href="#k05">5. Skalární a vektorový součin</a></p>
<p><a href="#k06">6. Immutable vs. mutable vektory</a></p>
<p><a href="#k07">7. Úplný zdrojový kód prvního demonstračního příkladu</a></p>
<p><a href="#k08">8. Práce s&nbsp;maticemi v&nbsp;knihovně <strong>core.matrix</strong></a></p>
<p><a href="#k09">9. Neměnitelné matice</a></p>
<p><a href="#k10">10. Měnitelné matice</a></p>
<p><a href="#k11">11. Řídké matice, interní reprezentace matic</a></p>
<p><a href="#k12">12. Pohledy (views)</a></p>
<p><a href="#k13">13. Úplný zdrojový kód druhého demonstračního příkladu</a></p>
<p><a href="#k14">14. Repositář s&nbsp;demonstračními příklady</a></p>
<p><a href="#k15">15. Odkazy na předchozí části seriálu</a></p>
<p><a href="#k16">16. Odkazy na Internetu</a></p>



<p><a name="k01"></a></p>
<h2 id="k01">1. Práce s&nbsp;vektory v&nbsp;knihovně <strong>core.matrix</strong></h2>

<p><a
href="http://www.root.cz/clanky/programovaci-jazyk-clojure-a-knihovny-pro-praci-s-vektory-a-maticemi/">V&nbsp;první
části</a> článku o knihovnách určených pro práci s&nbsp;vektory a maticemi
v&nbsp;programovacím jazyku Clojure jsme si nejprve řekli základní informace o
významu termínu <i>array programming</i>, což je (poněkud zjednodušeně řečeno)
jedno z&nbsp;paradigmat programování reprezentované především programovacími
jazyky APL, J a částečně i MATLAB. Dále jsme se zabývali popisem některých
funkcí a maker nabízených knihovnou nazvanou <strong>core.matrix</strong>. Dnes
toto téma dokončíme, protože si na trojici demonstračních příkladů ukážeme
další makra a funkce, které jsou touto knihovnou nabízeny. Kromě toho si taktéž
řekneme, jakým způsobem mohou být vektory a především pak matice reprezentovány
v&nbsp;operační paměti počítače a jak se v&nbsp;knihovně
<strong>core.matrix</strong> pracuje s&nbsp;takzvanými pohledy (<i>views</i>),
díky nimž je možné relativně snadno sdílet data několika matic v&nbsp;jediné
struktuře.</p>

<p>Začneme popisem práce s&nbsp;vektory. Ty je možné v&nbsp;knihovně
<strong>core.matrix</strong> vytvářet několika způsoby. Pokud se jedná o vektor
obsahující samé nuly, lze takovou strukturu vytvořit funkcí
<strong>zero-vector</strong>, které se jako jediný parametr předá délka
vektoru. Pro vektory, jejichž prvky mají odlišnou hodnotu, se používá funkce
<strong>array</strong>, které lze předat buď již existující vektor, sekvenci
(mj.&nbsp;tedy i vektor v&nbsp;chápání jazyka Clojure a taktéž seznam) či řez
2D polem. Existuje ještě třetí možnost vytvoření vektoru, a to s&nbsp;využitím
funkce <strong>to-vector</strong>, která slouží k&nbsp;transformaci libovolné
matice na vektor obsahující všechny prvky původní matice (podobně nazvaná
funkce <strong>as-vector</strong> bude popsána dále v&nbsp;sekci o
pohledech):</p>

<table>
<tr><th>#</th><th>Funkce</th><th>Výsledek</th><th>Popis</th></tr>
<tr><td>1</td><td>array</td><td>vektor</td><td>vytvoření nového vektoru (nebo matice)</td></tr>
<tr><td>2</td><td>to-vector</td><td>vektor</td><td>vytvoření nového vektoru z již existující matice</td></tr>
</table>



<p><a name="k02"></a></p>
<h2 id="k02">2. Pomocné makro pro výpis prováděné operace i jejího výsledku</h2>

<p>V&nbsp;trojici demonstračních příkladů se budou pro výpis prováděných
operací i výsledků těchto operací používat dvě makra nazvaná
<strong>print-vector</strong> a <strong>print-matrix</strong>. Funkce těchto
maker je relativně jednoduchá &ndash; nejprve se vypíše úplný (nevyhodnocený)
tvar výrazu, s&nbsp;nímž je makro zavoláno a posléze se s&nbsp;využitím funkce
<strong>pm</strong> (<i>pretty print matrix</i>) vypíše vyhodnocený výraz, což
může být skalár, vektor či matice. V&nbsp;případě matice je vhodnější použít
makro <strong>print-matrix</strong>, které vypíše již první řádek matice na
nový textový řádek, což zvyšuje čitelnost výstupu:</p>

<pre>
(defmacro <strong>print-vector</strong>
    <i>"Makro, které na standardní výstup vypíše výraz a následně i</i>
    <i> hodnotu tohoto výrazu s použitím funkce pm (pretty print matrix).</i>
    <i> Předpokládá se, že se výraz vyhodnotí na vektor."</i>
    [expression]
    `(do (printf "    %-32s =  " '~expression)
         (pm ~expression)))
</pre>

<pre>
(defmacro <strong>print-matrix</strong>
    <i>"Makro, které na standardní výstup vypíše výraz a následně i</i>
    <i> hodnotu tohoto výrazu s použitím funkce pm (pretty print matrix).</i>
    <i> Předpokládá se, že se výraz vyhodnotí na matici"</i>
    [expression]
    `(do (println "   " '~expression "=")
         (pm ~expression)
         (println)))
</pre>

<p>Význam znaků se speciálním významem, které lze používat v&nbsp;makrech,
naleznete v&nbsp;následující tabulce:</p>

<table>
<tr><th>#</th><th>Symbol v makru</th><th>Název</th><th>Význam</th></tr>
<tr><td>1</td><td>` </td><td>syntax-quote</td><td>provádí plnou kvalifikaci symbolů + zde lze použít makra ~ a ~@</td></tr>
<tr><td>2</td><td>~ </td><td>unquote</td><td>zajistí, že se vyhodnotí pouze označená část formy (= provede substituci této části výsledkem)</td></tr>
<tr><td>3</td><td>~@</td><td>unquote-splicing</td><td>podobné předchozími makru, ovšem výsledná sekvence se vloží ve formě samostatných prvků do &bdquo;obalující&ldquo; sekvence</td></tr>
</table>

<p>Bližší informace o tvorbě a použití maker lze najít v&nbsp;těchto
článcích:</p>

<ol>

<li>Programovací jazyk Clojure 14: základy práce se systémem maker<br />
<a href="http://www.root.cz/clanky/programovaci-jazyk-clojure-14-zaklady-prace-se-systemem-maker/">http://www.root.cz/clanky/programovaci-jazyk-clojure-14-zaklady-prace-se-systemem-maker/</a>
</li>

<li>Programovací jazyk Clojure 15: tvorba uživatelských maker<br />
<a href="http://www.root.cz/clanky/programovaci-jazyk-clojure-15-tvorba-uzivatelskych-maker/">http://www.root.cz/clanky/programovaci-jazyk-clojure-15-tvorba-uzivatelskych-maker/</a>
</li>

<li>Programovací jazyk Clojure 16: složitější uživatelská makra<br />
<a href="http://www.root.cz/clanky/programovaci-jazyk-clojure-16-slozitejsi-uzivatelska-makra/">http://www.root.cz/clanky/programovaci-jazyk-clojure-16-slozitejsi-uzivatelska-makra/</a>
</li>

<li>Programovací jazyk Clojure 17: využití standardních maker v praxi<br />
<a href="http://www.root.cz/clanky/programovaci-jazyk-clojure-17-vyuziti-standardnich-maker-v-praxi/">http://www.root.cz/clanky/programovaci-jazyk-clojure-17-vyuziti-standardnich-maker-v-praxi/</a>
</li>

</ol>



<p><a name="k03"></a></p>
<h2 id="k03">3. Operátory</h2>

<p>Ve jmenném prostoru <strong>clojure.core.matrix.operators</strong> jsou
deklarovány funkce pojmenované +, -, *, /, ** a ==, které lze
v&nbsp;programovacím jazyku Clojure považovat za obdobu klasických operátorů.
Tyto funkce/operátory jsou běžně deklarovány pro celá čísla, reálná čísla i
čísla racionální (zlomky), ovšem právě díky redeklaraci těchto funkcí
v&nbsp;<strong>clojure.core.matrix.operators</strong> je lze použít i pro
operace prováděné nad vektory a maticemi. V&nbsp;případě vektorů jsou tyto
operace deklarovány takovým způsobem, že jsou prováděny vždy na prvky vektorů
se shodným indexem a pokud je jedním z&nbsp;operandů skalární hodnota a nikoli
vektor, je skalár převeden na vektor stejné délky jakou má druhý operand. Toto
&bdquo;rozšíření&ldquo; skalární hodnoty na vektor se nazývá <i>broadcast</i> a
podobně funguje i &bdquo;rozšíření&ldquo; vektoru na matici (viz též další
kapitoly). Podívejme se nyní na způsob použití výše jmenovaných funkcí:</p>

<pre>
(defn <strong>immutable-vector-operators</strong>
    <i>"Test chování operátorů předefinovaných ve jmenném prostoru</i>
    <i> clojure.core.matrix.operators."</i>
    [vector1 vector2]
    (println "*** Test základních operátorů aplikovaných na vektory ***")
    (println "Vstupní data (vektory):")
    (print-vector vector1)
    (print-vector vector2)
    (println "Vyhodnocení:")
    <i>; operace provedené mezi vektorem a skalární hodnotou</i>
    (print-vector (+ vector1 10))
    (print-vector (- vector1 10))
    (print-vector (* vector1 10))
    (print-vector (/ vector1 10))
    <i>; operace provedené mezi skalární hodnotou a vektorem</i>
    (print-vector (+ 10 vector1))
    (print-vector (- 10 vector1))
    (print-vector (* 10 vector1))
    (print-vector (/ 10 vector1))
    <i>; operace provedené mezi dvěma vektory (zde stejné délky)</i>
    (print-vector (+ vector1 vector2))
    (print-vector (- vector1 vector2))
    (print-vector (* vector1 vector2))
    (print-vector (/ vector1 vector2))
    (println))
&nbsp;
(defn <strong>immutable-vector-tests</strong>
    <i>"Spustí všechny testovací funkce s neměnitelnými vektory."</i>
    []
    (let [v1 (array [1 2 3])
          v2 (array [2 3 4])]
          (immutable-vector-operators v1 v2)
          (immutable-vector-special-operators v1 v2)
</pre>

<p>Na standardním výstupu by se měly objevit tyto řádky:</p>

<pre>
*** Test základních operátorů aplikovaných na vektory ***
Vstupní data (vektory):
    vector1                          =  [1.000 2.000 3.000]
    vector2                          =  [2.000 3.000 4.000]
Vyhodnocení:
    (+ vector1 10)                   =  [11.000 12.000 13.000]
    (- vector1 10)                   =  [-9.000 -8.000 -7.000]
    (* vector1 10)                   =  [10.000 20.000 30.000]
    (/ vector1 10)                   =  [0.100 0.200 0.300]
    (+ 10 vector1)                   =  [11.000 12.000 13.000]
    (- 10 vector1)                   =  [9.000 8.000 7.000]
    (* 10 vector1)                   =  [10.000 20.000 30.000]
    (/ 10 vector1)                   =  [10.000 5.000 3.333]
    (+ vector1 vector2)              =  [3.000 5.000 7.000]
    (- vector1 vector2)              =  [-1.000 -1.000 -1.000]
    (* vector1 vector2)              =  [2.000 6.000 12.000]
    (/ vector1 vector2)              =  [0.500 0.667 0.750]
</pre>

<p>Podobným způsobem jsou předeklarovány i funkce/operátory ** (umocnění) a ==
(porovnání prvek po prvku):</p>

<pre>
(defn <strong>immutable-vector-special-operators</strong>
    <i>"Test chování speciálních operátorů předefinovaných</i>
    <i> ve jmenném prostoru clojure.core.matrix.operators."</i>
    [vector1 vector2]
    (println "*** Test speciálních operátorů aplikovaných na vektory ***")
    (println "Vstupní data (vektory):")
    (print-vector vector1)
    (print-vector vector2)
    (println "Vyhodnocení:")
    <i>; operace provedené mezi vektorem a skalární hodnotou</i>
    (print-vector (** vector1 10))
    <i>; operace provedené mezi skalární hodnotou a vektorem</i>
    (print-vector (** 10 vector1))
    <i>; operace provedené mezi dvěma vektory (zde stejné délky)</i>
    (print-vector (** vector1 vector2))
    <i>; operátor ekvivalence</i>
    (print-vector (== vector1 vector2))
    (print-vector (== vector1 vector1))
    (print-vector (== vector1 (array [1 2 3])))
    (print-vector (== vector1 [1 2 3]))
    (print-vector (== vector1 '(1 2 3)))
    (println))
</pre>

<p>Na standardním výstupu by se měly objevit tyto řádky:</p>

<pre>
*** Test speciálních operátorů aplikovaných na vektory ***
Vstupní data (vektory):
    vector1                          =  [1.000 2.000 3.000]
    vector2                          =  [2.000 3.000 4.000]
Vyhodnocení:
    (** vector1 10)                  =  [1.000 1024.000 59049.000]
    (** 10 vector1)                  =  [10.000 100.000 1000.000]
    (** vector1 vector2)             =  [1.000 8.000 81.000]
    (== vector1 vector2)             =  false
    (== vector1 vector1)             =  true
    (== vector1 (array [1 2 3]))     =  true
    (== vector1 [1 2 3])             =  true
    (== vector1 (quote (1 2 3)))     =  true
</pre>



<p><a name="k04"></a></p>
<h2 id="k04">4. Funkce pracující s&nbsp;vektory</h2>

<p>V&nbsp;knihovně <i>core.matrix</i> je deklarováno velké množství funkcí,
které dokážou pracovat s&nbsp;celými vektory popř.&nbsp;s&nbsp;jednotlivými
prvky, z&nbsp;nichž se vektory skládají. Některé z&nbsp;těchto funkcí jsme si
již popsali minule, ovšem ve skutečnosti těchto funkcí existuje mnohem větší
množství, jak bude ostatně patrné i z&nbsp;úryvku demonstračního příkladu:</p>

<pre>
(defn <strong>immutable-vector-functions</strong>
    <i>"Test chování vybraných funkcí, které lze nalézt ve jmenných prostorech</i>
    <i> clojure.core.matrix a clojure.core.matrix.operators."</i>
    [vector1 vector2 vector3]
    (println "*** Test funkcí aplikovaných na vektory ***")
    (println "Vstupní data (vektory):")
    (print-vector vector1)
    (print-vector vector2)
    (print-vector vector3)
    (println "Vyhodnocení:")
    (print-vector (emin vector1))
    (print-vector (emin vector2))
    (print-vector (emin vector3))
    (print-vector (emax vector1))
    (print-vector (emax vector2))
    (print-vector (emax vector3))
    (print-vector (normalise vector1))
    (print-vector (normalise vector2))
    (print-vector (normalise vector3))
    (print-vector (length vector1))
    (print-vector (length vector2))
    (print-vector (length vector3))
    (print-vector (length-squared vector1))
    (print-vector (length-squared vector2))
    (print-vector (length-squared vector3))
    (print-vector (distance vector1 vector2))
    (print-vector (distance vector1 vector3))
    (print-vector (distance vector2 vector3))
    (print-vector (join vector1 vector2))
    (print-vector (join vector1 vector2 vector3))
    (println))
</pre>

<p>Nejprve se podívejme na výsledky vypsané po spuštění této funkce:</p>

<pre>
*** Test funkcí aplikovaných na vektory ***
Vstupní data (vektory):
    vector1                          =  [1.000 2.000 3.000]
    vector2                          =  [2.000 3.000 4.000]
    vector3                          =  [1.000 1.000]
Vyhodnocení:
    (emin vector1)                   =  1.000
    (emin vector2)                   =  2.000
    (emin vector3)                   =  1.000
    (emax vector1)                   =  3.000
    (emax vector2)                   =  4.000
    (emax vector3)                   =  1.000
    (normalise vector1)              =  [0.267 0.535 0.802]
    (normalise vector2)              =  [0.371 0.557 0.743]
    (normalise vector3)              =  [0.707 0.707]
    (length vector1)                 =  3.742
    (length vector2)                 =  5.385
    (length vector3)                 =  1.414
    (length-squared vector1)         =  14.000
    (length-squared vector2)         =  29.000
    (length-squared vector3)         =  2.000
    (distance vector1 vector2)       =  1.732
    (distance vector1 vector3)       =  1.000
    (distance vector2 vector3)       =  2.236
    (join vector1 vector2)           =  [1.000 2.000 3.000 2.000 3.000 4.000]
    (join vector1 vector2 vector3)   =  [1.000 2.000 3.000 2.000 3.000 4.000 1.000 1.000]
</pre>

<p>Význam jednotlivých funkcí použitých v&nbsp;předchozím příkladu je vysvětlen
v&nbsp;tabulce:</p>

<table>
<tr><th>#</th><th>Funkce</th><th>Výsledek</th><th>Popis</th></tr>
<tr><td>1</td><td>emin</td><td>skalár</td><td>nalezne nejmenší prvek vektoru</td></tr>
<tr><td>2</td><td>emax</td><td>skalár</td><td>nalezne největší prvek vektoru</td></tr>
<tr><td>3</td><td>normalize</td><td>vektor</td><td>normalizace vektoru (na délku rovnou jedné)</td></tr>
<tr><td>4</td><td>length</td><td>skalár</td><td>výpočet délky vektoru</td></tr>
<tr><td>5</td><td>length-squared</td><td>skalár</td><td>výpočet druhé mocniny délky vektoru</td></tr>
<tr><td>6</td><td>distance</td><td>skalár</td><td>dva vektory jsou chápány jako 2D/3D body, vypočítá se jejich vzdálenost</td></tr>
<tr><td>7</td><td>join</td><td>vektor</td><td>spojení dvou čí většího množství vektorů</td></tr>
</table>

<p>Poznámka: žádná z&nbsp;těchto funkcí nemodifikuje původní vektor, vždy je
vytvořena nová datová struktura.</p>



<p><a name="k05"></a></p>
<h2 id="k05">5. Skalární a vektorový součin</h2>

<p><a href="#k03">Ve třetí kapitole</a> jsme se mj.&nbsp;zmínili i o
funkci/operátoru *, který slouží k&nbsp;vynásobení těch prvků vektorů, které
mají shodný index, tj.&nbsp;první prvek vektoru číslo 1 je vynásoben
s&nbsp;prvním prvkem vektoru číslo 2 atd. Kromě toho se však v&nbsp;mnoha
disciplínách (mj.&nbsp;i v&nbsp;počítačové grafice) pracuje se skalárním a
vektorovým součinem. I tyto operace jsou samozřejmě v&nbsp;knihovně
<strong>core.matrix</strong> podporovány:</p>

<table>
<tr><th>#</th><th>Funkce</th><th>Výsledek</th><th>Popis</th></tr>
<tr><td>1</td><td>dot</td><td>skalár</td><td>skalární součin dvou vektorů</td></tr>
<tr><td>2</td><td>inner-product</td><td>skalár</td><td>zobecnění skalárního součinu (pro matice má význam násobení matic)</td></tr>
<tr><td>3</td><td>cross</td><td>vektor</td><td>vektorový součin dvou vektorů</td></tr>
</table>

<p>Opět se podívejme na způsob použití těchto funkcí:</p>

<pre>
(defn <strong>immutable-vector-products</strong>
    <i>"Skalární a vektorový součin dvou trojsložkových vektorů."</i>
    [vector1 vector2]
    (println "*** Skalární a vektorový součin dvou trojsložkových vektorů ***")
    (println "Vstupní data (vektory):")
    (print-vector vector1)
    (print-vector vector2)
    (println "Vyhodnocení:")
    (print-vector (dot vector1 vector1))
    (print-vector (dot vector1 vector2))
    (print-vector (dot vector2 vector1))
    (print-vector (dot vector2 vector2))
    (print-vector (inner-product vector1 vector1))
    (print-vector (inner-product vector1 vector2))
    (print-vector (inner-product vector2 vector1))
    (print-vector (inner-product vector2 vector2))
    (print-vector (cross vector1 vector1))
    (print-vector (cross vector1 vector2))
    (print-vector (cross vector2 vector1))
    (print-vector (cross vector2 vector2))
    (println))
&nbsp;
(defn <strong>immutable-vector-tests</strong>
    <i>"Spustí všechny testovací funkce s neměnitelnými vektory."</i>
    []
    (let [v0 (zero-vector 3)
          v1 (array [1 2 3])
          v2 (array [2 3 4])
          v3 (array [1 1])]
          (immutable-vector-products v1 v2)
          (immutable-vector-products v0 v1)))
</pre>

<p>Výsledek zavolání testovací funkce:</p>

<pre>
*** Skalární a vektorový součin dvou trojsložkových vektorů ***
Vstupní data (vektory):
    vector1                          =  [1.000 2.000 3.000]
    vector2                          =  [2.000 3.000 4.000]
Vyhodnocení:
    (dot vector1 vector1)            =  14.000
    (dot vector1 vector2)            =  20.000
    (dot vector2 vector1)            =  20.000
    (dot vector2 vector2)            =  29.000
    (inner-product vector1 vector1)  =  14.000
    (inner-product vector1 vector2)  =  20.000
    (inner-product vector2 vector1)  =  20.000
    (inner-product vector2 vector2)  =  29.000
    (cross vector1 vector1)          =  [0.000 0.000 0.000]
    (cross vector1 vector2)          =  [-1.000 2.000 -1.000]
    (cross vector2 vector1)          =  [1.000 -2.000 1.000]
    (cross vector2 vector2)          =  [0.000 0.000 0.000]
&nbsp;
*** Skalární a vektorový součin dvou trojsložkových vektorů ***
Vstupní data (vektory):
    vector1                          =  [0.000 0.000 0.000]
    vector2                          =  [1.000 2.000 3.000]
Vyhodnocení:
    (dot vector1 vector1)            =  0.000
    (dot vector1 vector2)            =  0.000
    (dot vector2 vector1)            =  0.000
    (dot vector2 vector2)            =  14.000
    (inner-product vector1 vector1)  =  0.000
    (inner-product vector1 vector2)  =  0.000
    (inner-product vector2 vector1)  =  0.000
    (inner-product vector2 vector2)  =  14.000
    (cross vector1 vector1)          =  [0.000 0.000 0.000]
    (cross vector1 vector2)          =  [0.000 0.000 0.000]
    (cross vector2 vector1)          =  [0.000 0.000 0.000]
    (cross vector2 vector2)          =  [0.000 0.000 0.000]
</pre>



<p><a name="k06"></a></p>
<h2 id="k06">6. Immutable vs. mutable vektory</h2>

<p>Všechny funkce pro práci s&nbsp;vektory, které jsme si doposud popsali, byly
založeny na myšlence, že všechny datové struktury by měly být v&nbsp;ideálním
případě neměnitelné neboli <i>immutable</i>. V&nbsp;případě funkcionálních
jazyků a samozřejmě též i programovacího jazyka Clojure se názvem
<i>neměnitelnost</i> myslí jak neměnitelnost samotné struktury tak i
neměnitelnost dat ve struktuře uložených, ovšem u jiných jazyků může mít tento
význam odlišný význam (v&nbsp;Javě označuje pouze neměnitelnost samotné
struktury, ale nikoli již uložených dat &ndash; příkladem je běžné pole).</p>

<p>Vraťme se však k&nbsp;vektorům a knihovně <strong>core.matrix</strong>.
Kromě čistě funkcionálně navržených funkcí popsaných výše zde jsou deklarovány
i funkce měnící původní vektor, který však musí být vytvořen pomocí funkce
<strong>mutable</strong>. Všechny funkce měnící původní vektor mají na konci
svého jména znak !, což odpovídá konvencím Clojure. Výjimkou je čtveřice
&bdquo;operátorů&ldquo; +=, -=, *= a div=, kde sice znak ! není použit, ale
význam operace je zřejmý &ndash; výsledek se uloží do prvního operandu:</p>

<table>
<tr><th>#</th><th>Funkce</th><th>Výsledek</th><th>Popis</th></tr>
<tr><td>1</td><td>+=</td><td>vektor</td><td>stejný význam jako + ovšem výsledek se uloží do prvního vektoru</td></tr>
<tr><td>2</td><td>-=</td><td>vektor</td><td>stejný význam jako - ovšem výsledek se uloží do prvního vektoru</td></tr>
<tr><td>3</td><td>*=</td><td>vektor</td><td>stejný význam jako * ovšem výsledek se uloží do prvního vektoru</td></tr>
<tr><td>4</td><td>div=</td><td>vektor</td><td>stejný význam jako / ovšem výsledek se uloží do prvního vektoru</td></tr>
<tr><td>5</td><td>fill!</td><td>vektor</td><td>naplnění vektoru specifikovanou hodnotou</td></tr>
<tr><td>6</td><td>sin!</td><td>vektor</td><td>aplikace funkce sin na všechny prvky vektoru</td></tr>
<tr><td>7</td><td>abs!</td><td>vektor</td><td>výpočet absolutní hodnoty všech prvků vektoru</td></tr>
<tr><td>8</td><td>cross!</td><td>vektor</td><td>výpočet vektorového součinu</td></tr>
<tr><td>9</td><td>mset!</td><td>vektor</td><td>změna hodnoty vybraného prvku vektoru</td></tr>
</table>

<p>Podívejme se nyní na trojici funkcí, v&nbsp;nichž se pracuje
s&nbsp;měnitelnými vektory (povšimněte si volání <strong>mutable</strong>
v&nbsp;poslední funkci při konstrukci vektorů):</p>

<pre>
(defn <strong>mutable-vector-operators</strong>
    <i>"Test chování operátorů předefinovaných ve jmenném prostoru</i>
    <i> clojure.core.matrix.operators na měnitelné vektory."</i>
    [vector1 vector2]
    (println "*** Test základních operátorů aplikovaných na měnitelné vektory ***")
    (println "Vstupní data (vektory):")
    (print-vector vector1)
    (print-vector vector2)
    (println "Vyhodnocení:")
    <i>; operace provedené mezi dvěma vektory (zde stejné délky)</i>
    (print-vector (+= vector1 vector2))
    (print-vector (-= vector1 vector2))
    (print-vector (*= vector1 vector2))
    (print-vector (div= vector1 vector2))
    (println))
&nbsp;
(defn <strong>mutable-vector-functions</strong>
    <i>"Test chování vybraných funkcí, které lze nalézt ve jmenných prostorech</i>
    <i> clojure.core.matrix a clojure.core.matrix.operators na měnitelné vektory."</i>
    [vector1 vector2 vector3]
    (println "*** Test funkcí aplikovaných na měnitelné vektory ***")
    (println "Vstupní data (vektory):")
    (print-vector vector1)
    (print-vector vector2)
    (print-vector vector3)
    (println "Vyhodnocení:")
    (print-vector (sin! vector1))
    (print-vector (sin! vector2))
    (print-vector (sin! vector3))
    (print-vector (fill! vector1 1))
    (print-vector (fill! vector2 2))
    (print-vector (fill! vector3 3))
    (println))
&nbsp;
(defn <strong>mutable-vector-tests</strong>
    []
    (let [v0 (mutable (zero-vector 3))
          v1 (mutable (array [1 2 3]))
          v2 (mutable (array [2 3 4]))]
          (mutable-vector-operators v1 v2)
          (mutable-vector-functions v0 v1 v2)))
</pre>

<p>Při zavolání funkce <strong>mutable-vector-tests</strong> by se na
standardní výstup měly vypsat následující řádky:</p>

<pre>
*** Test základních operátorů aplikovaných na měnitelné vektory ***
Vstupní data (vektory):
    vector1                          =  [1.000 2.000 3.000]
    vector2                          =  [2.000 3.000 4.000]
Vyhodnocení:
    (+= vector1 vector2)             =  [3.000 5.000 7.000]
    (-= vector1 vector2)             =  [1.000 2.000 3.000]
    (*= vector1 vector2)             =  [2.000 6.000 12.000]
    (div= vector1 vector2)           =  [1.000 2.000 3.000]
&nbsp;
*** Test funkcí aplikovaných na měnitelné vektory ***
Vstupní data (vektory):
    vector1                          =  [0.000 0.000 0.000]
    vector2                          =  [1.000 2.000 3.000]
    vector3                          =  [2.000 3.000 4.000]
Vyhodnocení:
    (sin! vector1)                   =  [0.000 0.000 0.000]
    (sin! vector2)                   =  [0.841 0.909 0.141]
    (sin! vector3)                   =  [0.909 0.141 -0.757]
    (fill! vector1 1)                =  [1.000 1.000 1.000]
    (fill! vector2 2)                =  [2.000 2.000 2.000]
    (fill! vector3 3)                =  [3.000 3.000 3.000]
</pre>

<p>Povšimněte si, že návratová hodnota všech použitých funkcí je shodná
s&nbsp;hodnotou ukládanou do prvního (měnitelného) vektoru.</p>



<p><a name="k07"></a></p>
<h2 id="k07">7. Úplný zdrojový kód prvního demonstračního příkladu</h2>

<p>V&nbsp;této kapitole bude uveden výpis úplného zdrojového kódu prvního
demonstračního příkladu, z&nbsp;něhož jsme používali úryvky v&nbsp;předchozích
kapitolách:</p>

<p><strong>project.clj</strong>:</p>

<pre>
(defproject <strong>vector1</strong> "0.1.0-SNAPSHOT"
  :description "FIXME: write description"
  :url "http://example.com/FIXME"
  :license {:name "Eclipse Public License"
            :url "http://www.eclipse.org/legal/epl-v10.html"}
  :dependencies [[org.clojure/clojure "1.6.0"]
                 [net.mikera/core.matrix "0.34.0"]]
  :main ^:skip-aot vector1.core
  :target-path "target/%s"
  :profiles {:uberjar {:aot :all}})
</pre>

<p><strong>core.clj</strong>:</p>

<pre>
(ns <strong>vector1.core</strong>
  (:gen-class))
&nbsp;
(use 'clojure.core.matrix)
(use 'clojure.core.matrix.operators)
&nbsp;
(defmacro <strong>print-vector</strong>
    <i>"Makro, které na standardní výstup vypíše výraz a následně i</i>
    <i> hodnotu tohoto výrazu s použitím funkce pm (pretty print matrix).</i>
    <i> Předpokládá se, že se výraz vyhodnotí na vektor."</i>
    [expression]
    `(do (printf "    %-32s =  " '~expression)
         (pm ~expression)))
&nbsp;
(defn <strong>immutable-vector-operators</strong>
    <i>"Test chování operátorů předefinovaných ve jmenném prostoru</i>
    <i> clojure.core.matrix.operators."</i>
    [vector1 vector2]
    (println "*** Test základních operátorů aplikovaných na vektory ***")
    (println "Vstupní data (vektory):")
    (print-vector vector1)
    (print-vector vector2)
    (println "Vyhodnocení:")
    <i>; operace provedené mezi vektorem a skalární hodnotou</i>
    (print-vector (+ vector1 10))
    (print-vector (- vector1 10))
    (print-vector (* vector1 10))
    (print-vector (/ vector1 10))
    <i>; operace provedené mezi skalární hodnotou a vektorem</i>
    (print-vector (+ 10 vector1))
    (print-vector (- 10 vector1))
    (print-vector (* 10 vector1))
    (print-vector (/ 10 vector1))
    <i>; operace provedené mezi dvěma vektory (zde stejné délky)</i>
    (print-vector (+ vector1 vector2))
    (print-vector (- vector1 vector2))
    (print-vector (* vector1 vector2))
    (print-vector (/ vector1 vector2))
    (println))
&nbsp;
(defn <strong>immutable-vector-special-operators</strong>
    <i>"Test chování speciálních operátorů předefinovaných</i>
    <i> ve jmenném prostoru clojure.core.matrix.operators."</i>
    [vector1 vector2]
    (println "*** Test speciálních operátorů aplikovaných na vektory ***")
    (println "Vstupní data (vektory):")
    (print-vector vector1)
    (print-vector vector2)
    (println "Vyhodnocení:")
    <i>; operace provedené mezi vektorem a skalární hodnotou</i>
    (print-vector (** vector1 10))
    <i>; operace provedené mezi skalární hodnotou a vektorem</i>
    (print-vector (** 10 vector1))
    <i>; operace provedené mezi dvěma vektory (zde stejné délky)</i>
    (print-vector (** vector1 vector2))
    <i>; operátor ekvivalence</i>
    (print-vector (== vector1 vector2))
    (print-vector (== vector1 vector1))
    (print-vector (== vector1 (array [1 2 3])))
    (print-vector (== vector1 [1 2 3]))
    (print-vector (== vector1 '(1 2 3)))
    (println))
&nbsp;
(defn <strong>immutable-vector-functions</strong>
    <i>"Test chování vybraných funkcí, které lze nalézt ve jmenných prostorech</i>
    <i> clojure.core.matrix a clojure.core.matrix.operators."</i>
    [vector1 vector2 vector3]
    (println "*** Test funkcí aplikovaných na vektory ***")
    (println "Vstupní data (vektory):")
    (print-vector vector1)
    (print-vector vector2)
    (print-vector vector3)
    (println "Vyhodnocení:")
    (print-vector (emin vector1))
    (print-vector (emin vector2))
    (print-vector (emin vector3))
    (print-vector (emax vector1))
    (print-vector (emax vector2))
    (print-vector (emax vector3))
    (print-vector (normalise vector1))
    (print-vector (normalise vector2))
    (print-vector (normalise vector3))
    (print-vector (length vector1))
    (print-vector (length vector2))
    (print-vector (length vector3))
    (print-vector (length-squared vector1))
    (print-vector (length-squared vector2))
    (print-vector (length-squared vector3))
    (print-vector (distance vector1 vector2))
    (print-vector (distance vector1 vector3))
    (print-vector (distance vector2 vector3))
    (print-vector (join vector1 vector2))
    (print-vector (join vector1 vector2 vector3))
    (println))
&nbsp;
(defn <strong>immutable-vector-products</strong>
    <i>"Skalární a vektorový součin dvou trojsložkových vektorů."</i>
    [vector1 vector2]
    (println "*** Skalární a vektorový součin dvou trojsložkových vektorů ***")
    (println "Vstupní data (vektory):")
    (print-vector vector1)
    (print-vector vector2)
    (println "Vyhodnocení:")
    (print-vector (dot vector1 vector1))
    (print-vector (dot vector1 vector2))
    (print-vector (dot vector2 vector1))
    (print-vector (dot vector2 vector2))
    (print-vector (inner-product vector1 vector1))
    (print-vector (inner-product vector1 vector2))
    (print-vector (inner-product vector2 vector1))
    (print-vector (inner-product vector2 vector2))
    (print-vector (cross vector1 vector1))
    (print-vector (cross vector1 vector2))
    (print-vector (cross vector2 vector1))
    (print-vector (cross vector2 vector2))
    (println))
&nbsp;
(defn <strong>immutable-vector-tests</strong>
    <i>"Spustí všechny testovací funkce s neměnitelnými vektory."</i>
    []
    (let [v0 (zero-vector 3)
          v1 (array [1 2 3])
          v2 (array [2 3 4])
          v3 (array [1 1])]
          (immutable-vector-operators v1 v2)
          (immutable-vector-special-operators v1 v2)
          (immutable-vector-functions v1 v2 v3)
          (immutable-vector-products v1 v2)
          (immutable-vector-products v0 v1)))
&nbsp;
(defn <strong>mutable-vector-operators</strong>
    <i>"Test chování operátorů předefinovaných ve jmenném prostoru</i>
    <i> clojure.core.matrix.operators na měnitelné vektory."</i>
    [vector1 vector2]
    (println "*** Test základních operátorů aplikovaných na měnitelné vektory ***")
    (println "Vstupní data (vektory):")
    (print-vector vector1)
    (print-vector vector2)
    (println "Vyhodnocení:")
    <i>; operace provedené mezi dvěma vektory (zde stejné délky)</i>
    (print-vector (+= vector1 vector2))
    (print-vector (-= vector1 vector2))
    (print-vector (*= vector1 vector2))
    (print-vector (div= vector1 vector2))
    (println))
&nbsp;
(defn <strong>mutable-vector-functions</strong>
    <i>"Test chování vybraných funkcí, které lze nalézt ve jmenných prostorech</i>
    <i> clojure.core.matrix a clojure.core.matrix.operators na měnitelné vektory."</i>
    [vector1 vector2 vector3]
    (println "*** Test funkcí aplikovaných na měnitelné vektory ***")
    (println "Vstupní data (vektory):")
    (print-vector vector1)
    (print-vector vector2)
    (print-vector vector3)
    (println "Vyhodnocení:")
    (print-vector (sin! vector1))
    (print-vector (sin! vector2))
    (print-vector (sin! vector3))
    (print-vector (fill! vector1 1))
    (print-vector (fill! vector2 2))
    (print-vector (fill! vector3 3))
    (println))
&nbsp;
(defn <strong>mutable-vector-tests</strong>
    []
    (let [v0 (mutable (zero-vector 3))
          v1 (mutable (array [1 2 3]))
          v2 (mutable (array [2 3 4]))]
          (mutable-vector-operators v1 v2)
          (mutable-vector-functions v0 v1 v2)))
&nbsp;
(defn <strong>-main</strong>
    <i>"Vítejte v Matrixu podruhé..."</i>
    [&amp; args]
    (immutable-vector-tests)
    (mutable-vector-tests))
</pre>



<p><a name="k08"></a></p>
<h2 id="k08">8. Práce s&nbsp;maticemi v&nbsp;knihovně <strong>core.matrix</strong></h2>

<p>Nejdůležitější datovou strukturou, s&nbsp;níž se v&nbsp;knihovně
<strong>core.matrix</strong> pracuje, jsou samozřejmě matice, především pak
dvourozměrné matice. Tyto matice mohou mít libovolné rozměry a při jejich
vytváření je možné si zvolit jak způsob jejich uložení v&nbsp;operační paměti
počítače, tak i to, zda se bude jednat o matice měnitelné <i>(mutable)</i> či
neměnitelné <i>(immutable)</i>. Již v&nbsp;předchozí části tohoto seriálu jsme
se seznámili s&nbsp;některými funkcemi používanými při práci s&nbsp;maticemi.
V&nbsp;první řadě se jedná o funkce sloužící pro vytvoření matic různých typů,
viz též následující tabulku:</p>

<table>
<tr><th>#</th><th>Funkce</th><th>Výsledek</th><th>Popis</th></tr>
<tr><td>1</td><td>matrix</td><td>matice</td><td>vytvoření matice a inicializace jejích prvků</td></tr>
<tr><td>1</td><td>zero-matrix</td><td>matice</td><td>vytvoření matice s&nbsp;nulovými prvky</td></tr>
<tr><td>1</td><td>identity-matrix</td><td>matice</td><td>vytvoření jednotkové matice</td></tr>
<tr><td>1</td><td>permutation-matrix</td><td>matice</td><td>vytvoření matice, v&nbsp;níž jsou jedničky umístěny podle specifikovaného vektoru</td></tr>
</table>

<p>Další velmi důležitou funkcí je funkce <strong>reshape</strong>, která
dokáže změnit velikost matice a vhodným způsobem přeorganizovat prvky
v&nbsp;původní matici.</p>



<p><a name="k09"></a></p>
<h2 id="k09">9. Neměnitelné matice</h2>

<p>Podívejme se nyní na některé další funkce, které lze použít pro práci
s&nbsp;maticemi. Nejprve se budeme zabývat již zmíněnými funkcemi/operátory,
které mají u matic v&nbsp;některých případech odlišný význam, než tomu bylo u
vektorů:</p>

<table>
<tr><th>#</th><th>Funkce</th><th>Výsledek</th><th>Popis</th></tr>
<tr><td>1</td><td>+</td><td>matice</td><td>součet matic (může se provést <i>broadcast</i>)</td></tr>
<tr><td>2</td><td>-</td><td>matice</td><td>rozdíl matic (může se provést <i>broadcast</i>)</td></tr>
<tr><td>3</td><td>*</td><td>matice</td><td>maticový součin (nikoli prvek po prvku!)</td></tr>
<tr><td>4</td><td>/</td><td>matice</td><td>maticový součin s&nbsp;inverzní maticí</td></tr>
</table>

<p>Chování těchto funkcí/operátorů si samozřejmě vyzkoušíme v&nbsp;praxi:</p>

<pre>
(defn <strong>immutable-matrix-tests</strong>
    <i>"Spustí všechny testovací funkce s neměnitelnými maticemi"</i>
    []
    (let [m0 (zero-matrix 3 3)
          m1 (identity-matrix 3 3)
          m2 (array [[1 2 3] [4 5 6] [7 8 9]])
          m3 (array [[0 1] [2 3]])]
          (immutable-matrix-operators m0 m1)
          (immutable-matrix-operators m1 m2)
          ;(immutable-matrix-special-operators m1 m2)  ; bude použito níže
          ;(immutable-matrix-functions m1 m2 m3)))     ; bude použito níže
</pre>

<pre>
(defn <strong>immutable-matrix-operators</strong>
    <i>"Test chování operátorů předefinovaných ve jmenném prostoru</i>
    <i> clojure.core.matrix.operators."</i>
    [matrix1 matrix2]
    (println "*** Test základních operátorů aplikovaných na matice ***")
    (println "Vstupní data (matice):")
    (print-matrix matrix1)
    (print-matrix matrix2)
    (println "Vyhodnocení:")
    <i>; operace provedené mezi maticí a skalární hodnotou</i>
    (print-matrix (+ matrix1 10))
    (print-matrix (- matrix1 10))
    (print-matrix (* matrix1 10))
    (print-matrix (/ matrix1 10))
    <i>; operace provedené mezi skalární hodnotou a maticí</i>
    (print-matrix (+ 10 matrix1))
    (print-matrix (- 10 matrix1))
    (print-matrix (* 10 matrix1))
    (try
        (print-matrix (/ 10 matrix1))
        (catch java.lang.ArithmeticException e
            (println "Exception: " (.toString e))))
    <i>; operace provedené mezi dvěma maticemi</i>
    (print-matrix (+ matrix1 matrix2))
    (print-matrix (- matrix1 matrix2))
    (print-matrix (* matrix1 matrix2))
    (try
        (print-matrix (/ matrix1 matrix2))
        (catch java.lang.ArithmeticException e
            (println "Exception: " (.toString e))))
    (println))
</pre>

<p>Výsledky vypadají následovně (povšimněte si, že může dojít k&nbsp;vyhození
výjimky při dělení nulou):</p>

<pre>
*** Test základních operátorů aplikovaných na matice ***
Vstupní data (matice):
    matrix1 =
[[0.000 0.000 0.000]
 [0.000 0.000 0.000]
 [0.000 0.000 0.000]]
&nbsp;
    matrix2 =
[[1.000 0.000 0.000]
 [0.000 1.000 0.000]
 [0.000 0.000 1.000]]
&nbsp;
Vyhodnocení:
    (+ matrix1 10) =
[[10.000 10.000 10.000]
 [10.000 10.000 10.000]
 [10.000 10.000 10.000]]
&nbsp;
    (- matrix1 10) =
[[-10.000 -10.000 -10.000]
 [-10.000 -10.000 -10.000]
 [-10.000 -10.000 -10.000]]
&nbsp;
    (* matrix1 10) =
[[0.000 0.000 0.000]
 [0.000 0.000 0.000]
 [0.000 0.000 0.000]]
&nbsp;
    (/ matrix1 10) =
[[0.000 0.000 0.000]
 [0.000 0.000 0.000]
 [0.000 0.000 0.000]]
&nbsp;
    (+ 10 matrix1) =
[[10.000 10.000 10.000]
 [10.000 10.000 10.000]
 [10.000 10.000 10.000]]
&nbsp;
    (- 10 matrix1) =
[[10.000 10.000 10.000]
 [10.000 10.000 10.000]
 [10.000 10.000 10.000]]
&nbsp;
    (* 10 matrix1) =
[[0.000 0.000 0.000]
 [0.000 0.000 0.000]
 [0.000 0.000 0.000]]
&nbsp;
    (/ 10 matrix1) =
Exception:  java.lang.ArithmeticException: Divide by zero
&nbsp;
    (+ matrix1 matrix2) =
[[1.000 0.000 0.000]
 [0.000 1.000 0.000]
 [0.000 0.000 1.000]]
&nbsp;
    (- matrix1 matrix2) =
[[-1.000  0.000  0.000]
 [ 0.000 -1.000  0.000]
 [ 0.000  0.000 -1.000]]
&nbsp;
    (* matrix1 matrix2) =
[[0.000 0.000 0.000]
 [0.000 0.000 0.000]
 [0.000 0.000 0.000]]
&nbsp;
    (/ matrix1 matrix2) =
Exception:  java.lang.ArithmeticException: Divide by zero
&nbsp;
*** Test základních operátorů aplikovaných na matice ***
Vstupní data (matice):
    matrix1 =
[[1.000 0.000 0.000]
 [0.000 1.000 0.000]
 [0.000 0.000 1.000]]
&nbsp;
    matrix2 =
[[1.000 2.000 3.000]
 [4.000 5.000 6.000]
 [7.000 8.000 9.000]]
&nbsp;
Vyhodnocení:
    (+ matrix1 10) =
[[11.000 10.000 10.000]
 [10.000 11.000 10.000]
 [10.000 10.000 11.000]]
&nbsp;
    (- matrix1 10) =
[[ -9.000 -10.000 -10.000]
 [-10.000  -9.000 -10.000]
 [-10.000 -10.000  -9.000]]
&nbsp;
    (* matrix1 10) =
[[10.000  0.000  0.000]
 [ 0.000 10.000  0.000]
 [ 0.000  0.000 10.000]]
&nbsp;
    (/ matrix1 10) =
[[0.100 0.000 0.000]
 [0.000 0.100 0.000]
 [0.000 0.000 0.100]]
&nbsp;
    (+ 10 matrix1) =
[[11.000 10.000 10.000]
 [10.000 11.000 10.000]
 [10.000 10.000 11.000]]
&nbsp;
    (- 10 matrix1) =
[[ 9.000 10.000 10.000]
 [10.000  9.000 10.000]
 [10.000 10.000  9.000]]
&nbsp;
    (* 10 matrix1) =
[[10.000  0.000  0.000]
 [ 0.000 10.000  0.000]
 [ 0.000  0.000 10.000]]
&nbsp;
    (/ 10 matrix1) =
Exception:  java.lang.ArithmeticException: Divide by zero
&nbsp;
    (+ matrix1 matrix2) =
[[2.000 2.000  3.000]
 [4.000 6.000  6.000]
 [7.000 8.000 10.000]]
&nbsp;
    (- matrix1 matrix2) =
[[ 0.000 -2.000 -3.000]
 [-4.000 -4.000 -6.000]
 [-7.000 -8.000 -8.000]]
&nbsp;
    (* matrix1 matrix2) =
[[1.000 0.000 0.000]
 [0.000 5.000 0.000]
 [0.000 0.000 9.000]]
&nbsp;
    (/ matrix1 matrix2) =
[[1.000 0.000 0.000]
 [0.000 0.200 0.000]
 [0.000 0.000 0.111]]
</pre>

<p>Zajímavé je i chování operátorů ** (aplikován prvek po prvku
s&nbsp;případným broadcastem) a == (taktéž aplikován prvek po prvku):</p>

<pre>
(defn <strong>immutable-matrix-special-operators</strong>
    <i>"Test chování speciálních operátorů předefinovaných</i>
    <i> ve jmenném prostoru clojure.core.matrix.operators."</i>
    [matrix1 matrix2]
    (println "*** Test speciálních operátorů aplikovaných na matice ***")
    (println "Vstupní data (matice):")
    (print-matrix matrix1)
    (print-matrix matrix2)
    (println "Vyhodnocení:")
    <i>; operace provedené mezi maticí a skalární hodnotou</i>
    (print-matrix (** matrix1 10))
    <i>; operace provedené mezi skalární hodnotou a maticí</i>
    (print-matrix (** 10 matrix1))
    <i>; operace provedené mezi dvěma maticemi</i>
    (print-matrix (** matrix1 matrix2))
    <i>; operátor ekvivalence aplikovaný na dvojici matic</i>
    (print-vector (== matrix1 matrix2))
    (print-vector (== matrix1 matrix1))
    (print-vector (== matrix1 (identity-matrix 3 3)))
    (print-vector (== matrix2 (array [[1 2 3] [4 5 6] [7 8 9]])))
    (println))
</pre>

<p>Opět se podívejme na výsledky:</p>

<pre>
*** Test speciálních operátorů aplikovaných na matice ***
Vstupní data (matice):
    matrix1 =
[[1.000 0.000 0.000]
 [0.000 1.000 0.000]
 [0.000 0.000 1.000]]
&nbsp;
    matrix2 =
[[1.000 2.000 3.000]
 [4.000 5.000 6.000]
 [7.000 8.000 9.000]]
&nbsp;
Vyhodnocení:
    (** matrix1 10) =
[[1.000 0.000 0.000]
 [0.000 1.000 0.000]
 [0.000 0.000 1.000]]
&nbsp;
    (** 10 matrix1) =
[[10.000  1.000  1.000]
 [ 1.000 10.000  1.000]
 [ 1.000  1.000 10.000]]
&nbsp;
    (** matrix1 matrix2) =
[[1.000 0.000 0.000]
 [0.000 1.000 0.000]
 [0.000 0.000 1.000]]
&nbsp;
    (== matrix1 matrix2)             =  false
    (== matrix1 matrix1)             =  true
    (== matrix1 (identity-matrix 3 3)) =  true
    (== matrix2 (array [[1 2 3] [4 5 6] [7 8 9]])) =  true
</pre>

<p>Podívejme se ještě na některé významné funkce, které je možné aplikovat na
matice. Některé z&nbsp;těchto funkcí vrací skalární hodnotu, jiné naopak vektor
či (jinou) matici. Některé z&nbsp;těchto funkcí již známe z&nbsp;kapitol o
vektorech, další funkce jsou zcela nové:</p>

<table>
<tr><th>#</th><th>Funkce</th><th>Výsledek</th><th>Popis</th></tr>
<tr><td>1</td><td>emin</td><td>skalár</td><td>nalezne nejmenší prvek matice</td></tr>
<tr><td>2</td><td>emax</td><td>skalár</td><td>nalezne největší prvek matice</td></tr>
<tr><td>3</td><td>esum</td><td>skalár</td><td>sečte prvky v matici</td></tr>
<tr><td>4</td><td>ecount</td><td>skalár</td><td>vrátí celkový počet prvků matice</td></tr>
<tr><td>5</td><td>zero-count</td><td>skalár</td><td>vrátí počet nulových prvků matice</td></tr>
<tr><td>6</td><td>inverse</td><td>matice</td><td>výpočet inverzní matice</td></tr>
<tr><td>7</td><td>non-zero-indices</td><td>matice</td><td>vrací indexy nenulových prvků pro všechny řezy maticí</tr>
<tr><td>8</td><td>outer-product</td><td>matice (vyšší počet dimenzí)</td><td>vnější součin matice/matic či vektorů</td></tr>
<tr><td>9</td><td>join</td><td>matice</td><td>spojení dvou či více matic (zvětší se počet řádků)</td></tr>
</table>

<p>Nezbývá než si chování výše popsaných funkcí vyzkoušet:</p>

<pre>
(defn <strong>immutable-matrix-functions</strong>
    <i>"Test chování vybraných funkcí, které lze nalézt ve jmenných prostorech</i>
    <i> clojure.core.matrix a clojure.core.matrix.operators."</i>
    [matrix1 matrix2 matrix3]
    (println "*** Test funkcí aplikovaných na matice ***")
    (println "Vstupní data (matice):")
    (print-matrix matrix1)
    (print-matrix matrix2)
    (print-matrix matrix3)
    (println "Vyhodnocení:")
    (print-vector (emin matrix1))
    (print-vector (emin matrix2))
    (print-vector (emin matrix3))
    (print-vector (emax matrix1))
    (print-vector (emax matrix2))
    (print-vector (emax matrix3))
    (print-vector (esum matrix1))
    (print-vector (esum matrix2))
    (print-vector (esum matrix3))
    (print-vector (ecount matrix1))
    (print-vector (ecount matrix2))
    (print-vector (ecount matrix3))
    (print-vector (zero-count matrix1))
    (print-vector (zero-count matrix2))
    (print-vector (zero-count matrix3))
    (print-matrix (inverse matrix1))
    (print-matrix (inverse matrix2))
    (print-matrix (inverse matrix3))
    (print-matrix (non-zero-indices matrix1))
    (print-matrix (non-zero-indices matrix2))
    (print-matrix (non-zero-indices matrix3))
    (print-matrix (outer-product matrix1))
    (print-matrix (outer-product matrix2))
    (print-matrix (outer-product matrix3))
    (print-matrix (join matrix1 matrix2))
    (println))
</pre>

<p>Po zavolání této funkce by se na standardní výstup měly vypsat následující
řádky:</p>

<pre>
*** Test funkcí aplikovaných na matice ***
Vstupní data (matice):
    matrix1 =
[[1.000 0.000 0.000]
 [0.000 1.000 0.000]
 [0.000 0.000 1.000]]
&nbsp;
    matrix2 =
[[1.000 2.000 3.000]
 [4.000 5.000 6.000]
 [7.000 8.000 9.000]]
&nbsp;
    matrix3 =
[[0.000 1.000]
 [2.000 3.000]]
&nbsp;
Vyhodnocení:
    (emin matrix1)                   =  0.000
    (emin matrix2)                   =  1.000
    (emin matrix3)                   =  0.000
    (emax matrix1)                   =  1.000
    (emax matrix2)                   =  9.000
    (emax matrix3)                   =  3.000
    (esum matrix1)                   =  3.000
    (esum matrix2)                   =  45.000
    (esum matrix3)                   =  6.000
    (ecount matrix1)                 =  9.000
    (ecount matrix2)                 =  9.000
    (ecount matrix3)                 =  4.000
    (zero-count matrix1)             =  6.000
    (zero-count matrix2)             =  0.000
    (zero-count matrix3)             =  1.000
&nbsp;
    (inverse matrix1) =
[[1.000 0.000 0.000]
 [0.000 1.000 0.000]
 [0.000 0.000 1.000]]
&nbsp;
    (inverse matrix2) =
[[-4503599627370498.000   9007199254740992.000 -4503599627370496.000]
 [ 9007199254740996.000 -18014398509481984.000  9007199254740991.000]
 [-4503599627370498.000   9007199254740992.000 -4503599627370495.500]]
&nbsp;
    (inverse matrix3) =
[[-1.500 0.500]
 [ 1.000 0.000]]
&nbsp;
    (non-zero-indices matrix1) =
[[0.000]
 [1.000]
 [2.000]]
&nbsp;
    (non-zero-indices matrix2) =
[[0.000 1.000 2.000]
 [0.000 1.000 2.000]
 [0.000 1.000 2.000]]
&nbsp;
    (non-zero-indices matrix3) =
[[1.000]
 [0.000]]
&nbsp;
    (outer-product matrix1) =
[[1.000 0.000 0.000]
 [0.000 1.000 0.000]
 [0.000 0.000 1.000]]
&nbsp;
    (outer-product matrix2) =
[[1.000 2.000 3.000]
 [4.000 5.000 6.000]
 [7.000 8.000 9.000]]
&nbsp;
    (outer-product matrix3) =
[[0.000 1.000]
 [2.000 3.000]]
&nbsp;
    (join matrix1 matrix2) =
[[1.000 0.000 0.000]
 [0.000 1.000 0.000]
 [0.000 0.000 1.000]
 [1.000 2.000 3.000]
 [4.000 5.000 6.000]
 [7.000 8.000 9.000]]
</pre>

<p>Vnější součin dvou matic již dá složitější výsledek (jedná se vlastně o
výsledek součinu každého prvku s&nbsp;každým prvkem a uspořádání do matice se
čtyřmi rozměry):</p>

<pre>
(pm (outer-product m2 m2))
[[[[ 1.000  2.000  3.000]
   [ 4.000  5.000  6.000]
   [ 7.000  8.000  9.000]]
  [[ 2.000  4.000  6.000]
   [ 8.000 10.000 12.000]
   [14.000 16.000 18.000]]
  [[ 3.000  6.000  9.000]
   [12.000 15.000 18.000]
   [21.000 24.000 27.000]]]
 [[[ 4.000  8.000 12.000]
   [16.000 20.000 24.000]
   [28.000 32.000 36.000]]
  [[ 5.000 10.000 15.000]
   [20.000 25.000 30.000]
   [35.000 40.000 45.000]]
  [[ 6.000 12.000 18.000]
   [24.000 30.000 36.000]
   [42.000 48.000 54.000]]]
 [[[ 7.000 14.000 21.000]
   [28.000 35.000 42.000]
   [49.000 56.000 63.000]]
  [[ 8.000 16.000 24.000]
   [32.000 40.000 48.000]
   [56.000 64.000 72.000]]
  [[ 9.000 18.000 27.000]
   [36.000 45.000 54.000]
   [63.000 72.000 81.000]]]]
</pre>

<p>Jednodušší je vysvětlení chování této funkce na dvojici vektorů &ndash;
jednorozměrných matic:</p>

<pre>
(def v1 (array [1 2 3]))
&nbsp;
(pm (outer-product v1 v1))
[[1.000 2.000 3.000]
 [2.000 4.000 6.000]
 [3.000 6.000 9.000]]
</pre>

<p>Příklad z&nbsp;praxe &ndash; tabulka malé násobilky:</p>

<pre>
(def v1 (array (range 1 11)))
&nbsp;
(pm (outer-product v1 v1))
[[ 1.000  2.000  3.000  4.000  5.000  6.000  7.000  8.000  9.000  10.000]
 [ 2.000  4.000  6.000  8.000 10.000 12.000 14.000 16.000 18.000  20.000]
 [ 3.000  6.000  9.000 12.000 15.000 18.000 21.000 24.000 27.000  30.000]
 [ 4.000  8.000 12.000 16.000 20.000 24.000 28.000 32.000 36.000  40.000]
 [ 5.000 10.000 15.000 20.000 25.000 30.000 35.000 40.000 45.000  50.000]
 [ 6.000 12.000 18.000 24.000 30.000 36.000 42.000 48.000 54.000  60.000]
 [ 7.000 14.000 21.000 28.000 35.000 42.000 49.000 56.000 63.000  70.000]
 [ 8.000 16.000 24.000 32.000 40.000 48.000 56.000 64.000 72.000  80.000]
 [ 9.000 18.000 27.000 36.000 45.000 54.000 63.000 72.000 81.000  90.000]
 [10.000 20.000 30.000 40.000 50.000 60.000 70.000 80.000 90.000 100.000]]
</pre>



<p><a name="k10"></a></p>
<h2 id="k10">10. Měnitelné matice</h2>

<p>Podobně jako bylo možné se při vytváření vektorů rozhodnout, zda se má
jednat o neměnitelné či naopak o modifikovatelné datové struktury, lze totéž
rozhodnutí provést i v&nbsp;případě matix zavoláním funkce <i>mutable</i>.
Použití modifikovatelných matic může v&nbsp;mnoha případech znamenat znatelné
urychlení mnoha operací a taktéž menší nároky na kapacitu operační paměti.
Záleží tedy jen na vývojáři, ve kterých případech se přikloní k&nbsp;použití
neměnitelných matic a tím pádem i k&nbsp;funkcionálnímu stylu programování a
kdy naopak kvůli paměťovým a časovým nárokům upřednostní matice, jejichž prvky
je možné kdykoli změnit (a to i z&nbsp;jiných vláken). Podívejme se nyní na
několik příkladů použití měnitelných matic:</p>

<pre>
(defn <strong>mutable-matrix-tests</strong>
    []
    (let [m0 (mutable (zero-matrix 3 3))
          m1 (mutable (identity-matrix 3 3))
          m2 (mutable (array [[1 2 3] [4 5 6] [7 8 9]]))]
          (mutable-matrix-operators m1 m2)
          (mutable-matrix-functions m0 m1 m2)))
</pre>

<p>V&nbsp;případě použití měnitelných matic lze použít funkce/operátory +=, -=,
*= a div=, což je ukázáno ve funkci nazvané
<strong>mutable-matrix-operators</strong>:</p>

<pre>
(defn <strong>mutable-matrix-operators</strong>
    <i>"Test chování operátorů předefinovaných ve jmenném prostoru</i>
    <i> clojure.core.matrix.operators na měnitelné matice"</i>
    [matrix1 matrix2]
    (println "*** Test základních operátorů aplikovaných na měnitelné matice ***")
    (println "Vstupní data (matice):")
    (print-matrix matrix1)
    (print-matrix matrix2)
    (println "Vyhodnocení:")
    <i>; operace provedené mezi dvěma maticemi</i>
    (print-matrix (+= matrix1 matrix2))
    (print-matrix (-= matrix1 matrix2))
    (print-matrix (*= matrix1 matrix2))
    (print-matrix (div= matrix1 matrix2))
    (println))
</pre>

<p>Po zavolání této funkce se na standardní výstup vypíšou tyto řádky:</p>

<pre>
*** Test základních operátorů aplikovaných na měnitelné matice ***
Vstupní data (matice):
    matrix1 =
[[1.000 0.000 0.000]
 [0.000 1.000 0.000]
 [0.000 0.000 1.000]]
&nbsp;
    matrix2 =
[[1.000 2.000 3.000]
 [4.000 5.000 6.000]
 [7.000 8.000 9.000]]
&nbsp;
Vyhodnocení:
    (+= matrix1 matrix2) =
[[2.000 2.000  3.000]
 [4.000 6.000  6.000]
 [7.000 8.000 10.000]]
&nbsp;
    (-= matrix1 matrix2) =
[[1.000 0.000 0.000]
 [0.000 1.000 0.000]
 [0.000 0.000 1.000]]
&nbsp;
    (*= matrix1 matrix2) =
[[1.000 0.000 0.000]
 [0.000 5.000 0.000]
 [0.000 0.000 9.000]]
&nbsp;
    (div= matrix1 matrix2) =
[[1.000 0.000 0.000]
 [0.000 1.000 0.000]
 [0.000 0.000 1.000]]
</pre>

<p>Všechny funkce, které mění prvky matice, mají na konci svého jména znak
!:</p>

<pre>
(defn <strong>mutable-matrix-functions</strong>
    <i>"test chování vybraných funkcí, které lze nalézt ve jmenných prostorech</i>
    <i> clojure.core.matrix a clojure.core.matrix.operators na měnitelné matice."</i>
    [matrix1 matrix2 matrix3]
    (println "*** test funkcí aplikovaných na měnitelné matice ***")
    (println "vstupní data (matice):")
    (print-matrix matrix1)
    (print-matrix matrix2)
    (print-matrix matrix3)
    (println "vyhodnocení:")
    (print-matrix (sin! matrix1))
    (print-matrix (sin! matrix2))
    (print-matrix (sin! matrix3))
    (print-matrix (fill! matrix1 0))
    (print-matrix (fill! matrix2 1))
    (print-matrix (fill! matrix3 2))
    (println))
</pre>

<p>Po zavolání výše vypsané funkce <strong>mutable-matrix-functions</strong> se
na standardní výstup vypíšou následující řádky:</p>

<pre>
*** Test funkcí aplikovaných na měnitelné matice ***
Vstupní data (matice):
    matrix1 =
[[0.000 0.000 0.000]
 [0.000 0.000 0.000]
 [0.000 0.000 0.000]]
&nbsp;
    matrix2 =
[[1.000 0.000 0.000]
 [0.000 1.000 0.000]
 [0.000 0.000 1.000]]
&nbsp;
    matrix3 =
[[1.000 2.000 3.000]
 [4.000 5.000 6.000]
 [7.000 8.000 9.000]]
&nbsp;
Vyhodnocení:
    (sin! matrix1) =
[[0.000 0.000 0.000]
 [0.000 0.000 0.000]
 [0.000 0.000 0.000]]
&nbsp;
    (sin! matrix2) =
[[0.841 0.000 0.000]
 [0.000 0.841 0.000]
 [0.000 0.000 0.841]]
&nbsp;
    (sin! matrix3) =
[[ 0.841  0.909  0.141]
 [-0.757 -0.959 -0.279]
 [ 0.657  0.989  0.412]]
&nbsp;
    (fill! matrix1 0) =
[[0.000 0.000 0.000]
 [0.000 0.000 0.000]
 [0.000 0.000 0.000]]
&nbsp;
    (fill! matrix2 1) =
[[1.000 1.000 1.000]
 [1.000 1.000 1.000]
 [1.000 1.000 1.000]]
&nbsp;
    (fill! matrix3 2) =
[[2.000 2.000 2.000]
 [2.000 2.000 2.000]
 [2.000 2.000 2.000]]
</pre>



<p><a name="k11"></a></p>
<h2 id="k11">11. Řídké matice, interní reprezentace matic</h2>

<p>V&nbsp;knihovně <strong>core.matrix</strong> je deklarováno i několik funkcí
sloužících pro vytvoření takzvaných řídkých matic neboli <i>sparse
matrices</i>. Tyto matice jsou charakteristické tím, že mnoho jejich prvků je
nulových, takže většinou nemá význam matici reprezentovat běžným dvourozměrným
polem, ale je možné využít vylepšené způsoby uložení a taktéž optimalizované
algoritmy výpočtu některých operací, například pro násobení matic (musíme si
uvědomit, že mnoho řídkých matic má opravdu velké rozměry, příkladem může být
tzv.&nbsp;Google matice). Samotná knihovna <strong>core.matrix</strong> přesně
nespecifikuje, jakým způsobem mají být normální matice i řídké matice uloženy
v&nbsp;operační paměti, protože je možné použít různé implementace rozhraní
deklarovaného v&nbsp;této knihovně. V&nbsp;základním nastavení lze použít
následující implementace:</p>

<table>
<tr><th>Implementace</th><th>Typ</th><th>Popis</th></tr>
<tr><td>persistent-vector</td><td>immutable</td><td>implementace pomocí vektorů jazyka Clojure</td></tr>
<tr><td>double-array</td><td>mutable</td><td>implementace pomocí javovských polí</td></tr>
<tr><td>sequene</td><td>immutable</td><td>používáno především při načítání dat z&nbsp;jiných částí aplikace</td></tr>
<tr><td>ndarray</td><td>m/i</td><td>používá strukturu NDArray navrženou Dmitrijem Groševem</td></tr>
<tr><td>ndarray-double</td><td>m/i</td><td>přesná specifikace typů prvků</td></tr>
<tr><td>ndarray-long</td><td>m/i</td><td>přesná specifikace typů prvků (lze i další typy)</td></tr>
</table>

<p>Datová struktura NDArray interně využívá jednorozměrná javovská pole a navíc
si pamatuje i počet prvků v&nbsp;jednotlivých dimenzích, tj.&nbsp;vlastně
ofsety mezi řádky matice (popř.&nbsp;mezi jednotlivými 2D maticemi u matic
s&nbsp;větším počtem dimenzí).</p>



<p><a name="k12"></a></p>
<h2 id="k12">12. Pohledy (views)</h2>

<p>Poslední vlastností matic, s&nbsp;níž se v&nbsp;dnešním článku seznámíme, je
podpora takzvaných pohledů neboli <i>views</i>. Při implementaci některých
algoritmů je totiž nutné použít z&nbsp;větší matice pouze její část, ovšem
mnohdy je kvůli časovým i paměťovým nárokům neefektivní tuto část kopírovat
(klonovat). Jednodušší a rychlejší je použít právě pohledy, s&nbsp;jejichž
využitím je možné (z&nbsp;pohledu programátora) vytvořit kopii části matice, ve
skutečnosti se však bude skutečně jednat o jakýsi &bdquo;pohled&ldquo; do
obecně větší matice původní. Pohledy v&nbsp;<strong>core.matrix</strong> se
tedy skutečně podobají pohledům známým například z&nbsp;relačních databází. Pro
vysvětlení způsobu vytváření pohledů se opět podívejme na demonstrační
příklad:</p>

<pre>
(defn <strong>views-tests</strong>
    <i>"Pohledy na matice."</i>
    []
    (println "*** Test pohledů na matice ***")
    (let [m1 big-matrix]
        (println "Vstupní matice:")
        (print-matrix m1)
        (as-vector-test m1)
        (submatrix-test m1)
        (select-test m1)))
</pre>

<p>První funkcí, která dokáže vytvořit pohled, je funkce nazvaná
<strong>as-vector</strong>, kterou lze použít pro (zdánlivý) převod matice na
vektor. Pokud je zapotřebí provést skutečný převod, lze použít výše popsanou
funkci <strong>to-vector</strong>, o níž jsme se zmínili <a
href="#k01">v&nbsp;první kapitole</a>:</p>

<pre>
(defn <strong>as-vector-test</strong>
    <i>"Test funkce as-vector."</i>
    [matrix]
    (print-vector (as-vector matrix)))
</pre>

<p>Pravděpodobně užitečnější funkcí pro tvorbu pohledu je funkce nazvaná
<strong>submatrix</strong>, jejíž význam je zřejmý již z&nbsp;jejího
pojmenování. Zajímavé je, že tuto funkci lze volat s&nbsp;různým typem a počtem
parametrů: buď se zadávájí první a poslední indexy prvků v&nbsp;každé dimenzi,
nebo se použije vektor obsahující rozměry a začátek výsledné podmatice:</p>

<pre>
(defn <strong>submatrix-test</strong>
    <i>"Test funkce submatrix."</i>
    [matrix]
    (print-matrix (submatrix matrix 0 3 0 3))
    (print-matrix (submatrix matrix 1 5 2 4))
    (print-matrix (submatrix matrix 0 5 0 1))
    (print-matrix (submatrix matrix 0 1 0 5))
    (print-matrix (submatrix matrix [[0 10][2 2]])))
</pre>

<p>Nejsložitější je funkce nazvaná <strong>select</strong>, která taktéž vrací
pohled. Tuto funkci lze využít pro výběr celých řádků či sloupců, a to
s&nbsp;využitím speciální hodnoty :all, která se do <strong>select</strong>u
předá namísto indexu. Kromě toho lze zadat i přesný index prvku či prvků
vybíraných z&nbsp;matice (počet indexů odpovídá počtu dimenzí matice):</p>

<pre>
(defn <strong>select-test</strong>
    <i>"Test funkce select."</i>
    [matrix]
    (print-matrix (select matrix 0 0))
    (print-matrix (select matrix 5 5))
    (print-matrix (select matrix 1 :all))
    (print-matrix (select matrix :all 1))
    (print-matrix (select matrix 9 :all))
    (print-matrix (select matrix :all 9)))
</pre>

<p>Výsledky běhu všech tří testovacích funkcí jsou zobrazeny pod tímto
odstavcem:</p>

<pre>
*** Test pohledů na matice ***
Vstupní matice:
    m1 =
[[ 0.000  1.000  2.000  3.000  4.000  5.000  6.000  7.000  8.000  9.000]
 [10.000 11.000 12.000 13.000 14.000 15.000 16.000 17.000 18.000 19.000]
 [20.000 21.000 22.000 23.000 24.000 25.000 26.000 27.000 28.000 29.000]
 [30.000 31.000 32.000 33.000 34.000 35.000 36.000 37.000 38.000 39.000]
 [40.000 41.000 42.000 43.000 44.000 45.000 46.000 47.000 48.000 49.000]
 [50.000 51.000 52.000 53.000 54.000 55.000 56.000 57.000 58.000 59.000]
 [60.000 61.000 62.000 63.000 64.000 65.000 66.000 67.000 68.000 69.000]
 [70.000 71.000 72.000 73.000 74.000 75.000 76.000 77.000 78.000 79.000]
 [80.000 81.000 82.000 83.000 84.000 85.000 86.000 87.000 88.000 89.000]
 [90.000 91.000 92.000 93.000 94.000 95.000 96.000 97.000 98.000 99.000]]
&nbsp;
    (as-vector matrix)               =  [0.000 1.000 2.000 3.000 4.000 5.000 6.000 7.000 8.000 9.000 10.000 11.000 12.000 13.000 14.000 15.000 16.000 17.000 18.000 19.000 20.000 21.000 22.000 23.000 24.000 25.000 26.000 27.000 28.000 29.000 30.000 31.000 32.000 33.000 34.000 35.000 36.000 37.000 38.000 39.000 40.000 41.000 42.000 43.000 44.000 45.000 46.000 47.000 48.000 49.000 50.000 51.000 52.000 53.000 54.000 55.000 56.000 57.000 58.000 59.000 60.000 61.000 62.000 63.000 64.000 65.000 66.000 67.000 68.000 69.000 70.000 71.000 72.000 73.000 74.000 75.000 76.000 77.000 78.000 79.000 80.000 81.000 82.000 83.000 84.000 85.000 86.000 87.000 88.000 89.000 90.000 91.000 92.000 93.000 94.000 95.000 96.000 97.000 98.000 99.000]
&nbsp;
    (submatrix matrix 0 3 0 3) =
[[ 0.000  1.000  2.000]
 [10.000 11.000 12.000]
 [20.000 21.000 22.000]]
&nbsp;
    (submatrix matrix 1 5 2 4) =
[[12.000 13.000 14.000 15.000]
 [22.000 23.000 24.000 25.000]
 [32.000 33.000 34.000 35.000]
 [42.000 43.000 44.000 45.000]
 [52.000 53.000 54.000 55.000]]
&nbsp;
    (submatrix matrix 0 5 0 1) =
[[ 0.000]
 [10.000]
 [20.000]
 [30.000]
 [40.000]]
&nbsp;
    (submatrix matrix 0 1 0 5) =
[[0.000 1.000 2.000 3.000 4.000]]
&nbsp;
    (submatrix matrix [[0 10] [2 2]]) =
[[ 2.000  3.000]
 [12.000 13.000]
 [22.000 23.000]
 [32.000 33.000]
 [42.000 43.000]
 [52.000 53.000]
 [62.000 63.000]
 [72.000 73.000]
 [82.000 83.000]
 [92.000 93.000]]
&nbsp;
    (select matrix 0 0) =
0.000
&nbsp;
    (select matrix 5 5) =
55.000
&nbsp;
    (select matrix 1 :all) =
[10.000 11.000 12.000 13.000 14.000 15.000 16.000 17.000 18.000 19.000]
&nbsp;
    (select matrix :all 1) =
[1.000 11.000 21.000 31.000 41.000 51.000 61.000 71.000 81.000 91.000]
&nbsp;
    (select matrix 9 :all) =
[90.000 91.000 92.000 93.000 94.000 95.000 96.000 97.000 98.000 99.000]
&nbsp;
    (select matrix :all 9) =
[9.000 19.000 29.000 39.000 49.000 59.000 69.000 79.000 89.000 99.000]
</pre>



<p><a name="k13"></a></p>
<h2 id="k13">13. Úplný zdrojový kód druhého demonstračního příkladu</h2>

<p>V&nbsp;této kapitole bude uveden výpis úplného zdrojového kódu dnešního
druhého demonstračního příkladu, z&nbsp;něhož jsme používali úryvky
v&nbsp;předchozích čtyřech kapitolách:</p>

<p><strong>project.clj</strong>:</p>

<pre>
(defproject <strong>matrix2</strong> "0.1.0-SNAPSHOT"
  :description "FIXME: write description"
  :url "http://example.com/FIXME"
  :license {:name "Eclipse Public License"
            :url "http://www.eclipse.org/legal/epl-v10.html"}
  :dependencies [[org.clojure/clojure "1.6.0"]
                 [net.mikera/core.matrix "0.34.0"]]
  :main ^:skip-aot matrix2.core
  :target-path "target/%s"
  :profiles {:uberjar {:aot :all}})
</pre>

<p><strong>core.clj</strong>:</p>

<pre>
(ns <strong>matrix2.core</strong>
  (:gen-class))
&nbsp;
(use 'clojure.core.matrix)
(use 'clojure.core.matrix.operators)
&nbsp;
(defmacro <strong>print-vector</strong>
    <i>"Makro, které na standardní výstup vypíše výraz a následně i</i>
    <i> hodnotu tohoto výrazu s použitím funkce pm (pretty print matrix).</i>
    <i> Předpokládá se, že se výraz vyhodnotí na vektor."</i>
    [expression]
    `(do (printf "    %-32s =  " '~expression)
         (pm ~expression)))
&nbsp;
(defmacro <strong>print-matrix</strong>
    <i>"Makro, které na standardní výstup vypíše výraz a následně i</i>
    <i> hodnotu tohoto výrazu s použitím funkce pm (pretty print matrix).</i>
    <i> Předpokládá se, že se výraz vyhodnotí na matici"</i>
    [expression]
    `(do (println "   " '~expression "=")
         (pm ~expression)
         (println)))
&nbsp;
(defn <strong>immutable-matrix-operators</strong>
    <i>"Test chování operátorů předefinovaných ve jmenném prostoru</i>
    <i> clojure.core.matrix.operators."</i>
    [matrix1 matrix2]
    (println "*** Test základních operátorů aplikovaných na matice ***")
    (println "Vstupní data (matice):")
    (print-matrix matrix1)
    (print-matrix matrix2)
    (println "Vyhodnocení:")
    <i>; operace provedené mezi maticí a skalární hodnotou</i>
    (print-matrix (+ matrix1 10))
    (print-matrix (- matrix1 10))
    (print-matrix (* matrix1 10))
    (print-matrix (/ matrix1 10))
    <i>; operace provedené mezi skalární hodnotou a maticí</i>
    (print-matrix (+ 10 matrix1))
    (print-matrix (- 10 matrix1))
    (print-matrix (* 10 matrix1))
    (try
        (print-matrix (/ 10 matrix1))
        (catch java.lang.ArithmeticException e
            (println "Exception: " (.toString e))))
    <i>; operace provedené mezi dvěma maticemi</i>
    (print-matrix (+ matrix1 matrix2))
    (print-matrix (- matrix1 matrix2))
    (print-matrix (* matrix1 matrix2))
    (try
        (print-matrix (/ matrix1 matrix2))
        (catch java.lang.ArithmeticException e
            (println "Exception: " (.toString e))))
    (println))
&nbsp;
(defn <strong>immutable-matrix-special-operators</strong>
    <i>"Test chování speciálních operátorů předefinovaných</i>
    <i> ve jmenném prostoru clojure.core.matrix.operators."</i>
    [matrix1 matrix2]
    (println "*** Test speciálních operátorů aplikovaných na matice ***")
    (println "Vstupní data (matice):")
    (print-matrix matrix1)
    (print-matrix matrix2)
    (println "Vyhodnocení:")
    <i>; operace provedené mezi maticí a skalární hodnotou</i>
    (print-matrix (** matrix1 10))
    <i>; operace provedené mezi skalární hodnotou a maticí</i>
    (print-matrix (** 10 matrix1))
    <i>; operace provedené mezi dvěma maticemi</i>
    (print-matrix (** matrix1 matrix2))
    <i>; operátor ekvivalence aplikovaný na dvojici matic</i>
    (print-vector (== matrix1 matrix2))
    (print-vector (== matrix1 matrix1))
    (print-vector (== matrix1 (identity-matrix 3 3)))
    (print-vector (== matrix2 (array [[1 2 3] [4 5 6] [7 8 9]])))
    (println))
&nbsp;
(defn <strong>immutable-matrix-functions</strong>
    <i>"Test chování vybraných funkcí, které lze nalézt ve jmenných prostorech</i>
    <i> clojure.core.matrix a clojure.core.matrix.operators."</i>
    [matrix1 matrix2 matrix3]
    (println "*** Test funkcí aplikovaných na matice ***")
    (println "Vstupní data (matice):")
    (print-matrix matrix1)
    (print-matrix matrix2)
    (print-matrix matrix3)
    (println "Vyhodnocení:")
    (print-vector (emin matrix1))
    (print-vector (emin matrix2))
    (print-vector (emin matrix3))
    (print-vector (emax matrix1))
    (print-vector (emax matrix2))
    (print-vector (emax matrix3))
    (print-vector (esum matrix1))
    (print-vector (esum matrix2))
    (print-vector (esum matrix3))
    (print-vector (ecount matrix1))
    (print-vector (ecount matrix2))
    (print-vector (ecount matrix3))
    (print-vector (zero-count matrix1))
    (print-vector (zero-count matrix2))
    (print-vector (zero-count matrix3))
    (print-matrix (inverse matrix1))
    (print-matrix (inverse matrix2))
    (print-matrix (inverse matrix3))
    (print-matrix (non-zero-indices matrix1))
    (print-matrix (non-zero-indices matrix2))
    (print-matrix (non-zero-indices matrix3))
    (print-matrix (outer-product matrix1))
    (print-matrix (outer-product matrix2))
    (print-matrix (outer-product matrix3))
    (print-matrix (join matrix1 matrix2))
    (println))
&nbsp;
(defn <strong>immutable-matrix-tests</strong>
    <i>"Spustí všechny testovací funkce s neměnitelnými maticemi"</i>
    []
    (let [m0 (zero-matrix 3 3)
          m1 (identity-matrix 3 3)
          m2 (array [[1 2 3] [4 5 6] [7 8 9]])
          m3 (array [[0 1] [2 3]])]
          (immutable-matrix-operators m0 m1)
          (immutable-matrix-operators m1 m2)
          (immutable-matrix-special-operators m1 m2)
          (immutable-matrix-functions m1 m2 m3)))
&nbsp;
(defn <strong>mutable-matrix-operators</strong>
    <i>"Test chování operátorů předefinovaných ve jmenném prostoru</i>
    <i> clojure.core.matrix.operators na měnitelné matice"</i>
    [matrix1 matrix2]
    (println "*** Test základních operátorů aplikovaných na měnitelné matice ***")
    (println "Vstupní data (matice):")
    (print-matrix matrix1)
    (print-matrix matrix2)
    (println "Vyhodnocení:")
    <i>; operace provedené mezi dvěma maticemi</i>
    (print-matrix (+= matrix1 matrix2))
    (print-matrix (-= matrix1 matrix2))
    (print-matrix (*= matrix1 matrix2))
    (print-matrix (div= matrix1 matrix2))
    (println))
&nbsp;
(defn <strong>mutable-matrix-functions</strong>
    <i>"test chování vybraných funkcí, které lze nalézt ve jmenných prostorech</i>
    <i> clojure.core.matrix a clojure.core.matrix.operators na měnitelné matice."</i>
    [matrix1 matrix2 matrix3]
    (println "*** test funkcí aplikovaných na měnitelné matice ***")
    (println "vstupní data (matice):")
    (print-matrix matrix1)
    (print-matrix matrix2)
    (print-matrix matrix3)
    (println "vyhodnocení:")
    (print-matrix (sin! matrix1))
    (print-matrix (sin! matrix2))
    (print-matrix (sin! matrix3))
    (print-matrix (fill! matrix1 0))
    (print-matrix (fill! matrix2 1))
    (print-matrix (fill! matrix3 2))
    (println))
&nbsp;
(defn <strong>mutable-matrix-tests</strong>
    []
    (let [m0 (mutable (zero-matrix 3 3))
          m1 (mutable (identity-matrix 3 3))
          m2 (mutable (array [[1 2 3] [4 5 6] [7 8 9]]))]
          (mutable-matrix-operators m1 m2)
          (mutable-matrix-functions m0 m1 m2)))
&nbsp;
<i>; vytvoření matice o rozměrech 10x10 prvků</i>
(def big-matrix
    (-&gt; (range 0 100) (reshape [10 10])))
&nbsp;
(defn <strong>as-vector-test</strong>
    <i>"Test funkce as-vector."</i>
    [matrix]
    (print-vector (as-vector matrix)))
&nbsp;
(defn <strong>submatrix-test</strong>
    <i>"Test funkce submatrix."</i>
    [matrix]
    (print-matrix (submatrix matrix 0 3 0 3))
    (print-matrix (submatrix matrix 1 5 2 4))
    (print-matrix (submatrix matrix 0 5 0 1))
    (print-matrix (submatrix matrix 0 1 0 5))
    (print-matrix (submatrix matrix [[0 10][2 2]])))
&nbsp;
(defn <strong>select-test</strong>
    <i>"Test funkce select."</i>
    [matrix]
    (print-matrix (select matrix 0 0))
    (print-matrix (select matrix 5 5))
    (print-matrix (select matrix 1 :all))
    (print-matrix (select matrix :all 1))
    (print-matrix (select matrix 9 :all))
    (print-matrix (select matrix :all 9)))
&nbsp;
(defn <strong>views-tests</strong>
    <i>"Pohledy na matice."</i>
    []
    (println "*** Test pohledů na matice ***")
    (let [m1 big-matrix]
        (println "Vstupní matice:")
        (print-matrix m1)
        (as-vector-test m1)
        (submatrix-test m1)
        (select-test m1)))
&nbsp;
(defn <strong>-main</strong>
    <i>"Vítejte v Matrixu potřetí..."</i>
    [&amp; args]
    (immutable-matrix-tests)
    (mutable-matrix-tests)
    (views-tests))
&nbsp;
</pre>



<p><a name="k14"></a></p>
<h2 id="k14">14. Repositář s&nbsp;demonstračními příklady</h2>

<p>Oba dva dnes popsané demonstrační příklady byly, podobně jako
v&nbsp;předchozích částech tohoto seriálu, uloženy do GIT repositáře dostupného
na adrese <a
href="https://github.com/tisnik/clojure-examples">https://github.com/tisnik/clojure-examples</a>.
V&nbsp;tabulce zobrazené pod tímto odstavcem naleznete na jednotlivé příklady
přímé odkazy:</p>

<table>
<tr><th>#</th><th>Příklad</th><th>Github</th></tr>
<tr><td>1</td><td>vector1</td><td><a href="https://github.com/tisnik/clojure-examples/tree/master/vector1">https://github.com/tisnik/clojure-examples/tree/master/vector1</a></td></tr>
<tr><td>2</td><td>matrix2</td><td><a href="https://github.com/tisnik/clojure-examples/tree/master/matrix2">https://github.com/tisnik/clojure-examples/tree/master/matrix2</a></td></tr>
</table>



<p><a name="k15"></a></p>
<h2 id="k15">15. Odkazy na předchozí části seriálu</h2>

<ol>

<li>Leiningen: nástroj pro správu projektů napsaných v Clojure<br />
<a href="http://www.root.cz/clanky/leiningen-nastroj-pro-spravu-projektu-napsanych-v-clojure/">http://www.root.cz/clanky/leiningen-nastroj-pro-spravu-projektu-napsanych-v-clojure/</a>
</li>

<li>Leiningen: nástroj pro správu projektů napsaných v Clojure (2)<br />
<a href="http://www.root.cz/clanky/leiningen-nastroj-pro-spravu-projektu-napsanych-v-clojure-2/">http://www.root.cz/clanky/leiningen-nastroj-pro-spravu-projektu-napsanych-v-clojure-2/</a>
</li>

<li>Leiningen: nástroj pro správu projektů napsaných v Clojure (3)<br />
<a href="http://www.root.cz/clanky/leiningen-nastroj-pro-spravu-projektu-napsanych-v-clojure-3/">http://www.root.cz/clanky/leiningen-nastroj-pro-spravu-projektu-napsanych-v-clojure-3/</a>
</li>

<li>Leiningen: nástroj pro správu projektů napsaných v Clojure (4)<br />
<a href="http://www.root.cz/clanky/leiningen-nastroj-pro-spravu-projektu-napsanych-v-clojure-4/">http://www.root.cz/clanky/leiningen-nastroj-pro-spravu-projektu-napsanych-v-clojure-4/</a>
</li>

<li>Leiningen: nástroj pro správu projektů napsaných v Clojure (5)<br />
<a href="http://www.root.cz/clanky/leiningen-nastroj-pro-spravu-projektu-napsanych-v-clojure-5/">http://www.root.cz/clanky/leiningen-nastroj-pro-spravu-projektu-napsanych-v-clojure-5/</a>
</li>

<li>Leiningen: nástroj pro správu projektů napsaných v Clojure (6)<br />
<a href="http://www.root.cz/clanky/leiningen-nastroj-pro-spravu-projektu-napsanych-v-clojure-6/">http://www.root.cz/clanky/leiningen-nastroj-pro-spravu-projektu-napsanych-v-clojure-6/</a>
</li>

<li>Programovací jazyk Clojure a databáze (1.část)<br />
<a href="http://www.root.cz/clanky/programovaci-jazyk-clojure-a-databaze-1-cast/">http://www.root.cz/clanky/programovaci-jazyk-clojure-a-databaze-1-cast/</a>
</li>

<li>Pluginy pro Leiningen<br />
<a href="http://www.root.cz/clanky/leiningen-nastroj-pro-spravu-projektu-napsanych-v-clojure-pluginy-pro-leiningen/">http://www.root.cz/clanky/leiningen-nastroj-pro-spravu-projektu-napsanych-v-clojure-pluginy-pro-leiningen/</a>
</li>

<li>Programovací jazyk Clojure a knihovny pro práci s vektory a maticemi<br />
<a href="http://www.root.cz/clanky/programovaci-jazyk-clojure-a-knihovny-pro-praci-s-vektory-a-maticemi/">http://www.root.cz/clanky/programovaci-jazyk-clojure-a-knihovny-pro-praci-s-vektory-a-maticemi/</a>
</li>

</ol>



<p><a name="k16"></a></p>
<h2 id="k16">16. Odkazy na Internetu</h2>

<ol>

<li>Dokumentace vygenerovaná pro knihovnu core.matrix<br />
<a href="https://cloojure.github.io/doc/core.matrix/index.html">https://cloojure.github.io/doc/core.matrix/index.html</a>
</li>

<li>Size and Dimensionality<br />
<a href="https://groups.google.com/forum/#!topic/numerical-clojure/zebBCa68eTw/discussion">https://groups.google.com/forum/#!topic/numerical-clojure/zebBCa68eTw/discussion</a>
</li>

<li>Towards core.matrix for Clojure?<br />
<a href="https://clojurefun.wordpress.com/2013/01/05/towards-core-matrix-for-clojure/">https://clojurefun.wordpress.com/2013/01/05/towards-core-matrix-for-clojure/</a>
</li>

<li>The Clojure Toolbox<br />
<a href="http://www.clojure-toolbox.com/">http://www.clojure-toolbox.com/</a>
</li>

<li>Neanderthal<br />
<a href="http://neanderthal.uncomplicate.org/">http://neanderthal.uncomplicate.org/</a>
</li>

<li>Hello world project<br />
<a href="https://github.com/uncomplicate/neanderthal/blob/master/examples/hello-world/project.clj">https://github.com/uncomplicate/neanderthal/blob/master/examples/hello-world/project.clj</a>
</li>

<li>vectorz-clj<br />
<a href="https://github.com/mikera/vectorz-clj">https://github.com/mikera/vectorz-clj</a>
</li>

<li>vectorz - Examples<br />
<a href="https://github.com/mikera/vectorz-clj/wiki/Examples">https://github.com/mikera/vectorz-clj/wiki/Examples</a>
</li>

<li>gloss<br />
<a href="https://github.com/ztellman/gloss">https://github.com/ztellman/gloss</a>
</li>

<li>HTTP client/server for Clojure<br />
<a href="http://www.http-kit.org/">http://www.http-kit.org/</a>
</li>

<li>Array Programming<br />
<a href="https://en.wikipedia.org/wiki/Array_programming">https://en.wikipedia.org/wiki/Array_programming</a>
</li>

<li>Discovering Array Languages<br />
<a href="http://archive.vector.org.uk/art10008110">http://archive.vector.org.uk/art10008110</a>
</li>

<li>no stinking loops -- Kalothi<br />
<a href="http://www.nsl.com/">http://www.nsl.com/</a>
</li>

<li>Vector (obsahuje odkazy na články, knihy a blogy o programovacích jazycích APL, J a K)<br />
<a href="http://www.vector.org.uk/">http://www.vector.org.uk/</a>
</li>

<li>APL Interpreters<br />
<a href="http://www.vector.org.uk/?area=interpreters">http://www.vector.org.uk/?area=interpreters</a>
</li>

<li>APL_(programming_language<br />
<a href="http://en.wikipedia.org/wiki/APL_(programming_language">http://en.wikipedia.org/wiki/APL_(programming_language</a>
</li>

<li>APL FAQ<br />
<a href="http://www.faqs.org/faqs/apl-faq/">http://www.faqs.org/faqs/apl-faq/</a>
</li>

<li>APL FAQ (nejnovější verze)<br />
<a href="http://home.earthlink.net/~swsirlin/apl.faq.html">http://home.earthlink.net/~swsirlin/apl.faq.html</a>
</li>

<li>A+<br />
<a href="http://www.aplusdev.org/">http://www.aplusdev.org/</a>
</li>

<li>APLX<br />
<a href="http://www.microapl.co.uk/">http://www.microapl.co.uk/</a>
</li>

<li>FreeAPL<br />
<a href="http://www.pyr.fi/apl/index.htm">http://www.pyr.fi/apl/index.htm</a>
</li>

<li>J: a modern, high-level, general-purpose, high-performance programming language<br />
<a href="http://www.jsoftware.com/">http://www.jsoftware.com/</a>
</li>

<li>K, Kdb: an APL derivative for Solaris, Linux, Windows<br />
<a href="http://www.kx.com">http://www.kx.com</a>
</li>

<li>openAPL (GPL)<br />
<a href="http://sourceforge.net/projects/openapl">http://sourceforge.net/projects/openapl</a>
</li>

<li>Parrot APL (GPL)<br />
<a href="http://www.parrotcode.org/">http://www.parrotcode.org/</a>
</li>

<li>Learning J (Roger Stokes)<br />
<a href="http://www.jsoftware.com/help/learning/contents.htm">http://www.jsoftware.com/help/learning/contents.htm</a>
</li>

<li>Rosetta Code<br />
<a href="http://rosettacode.org/wiki/Main_Page">http://rosettacode.org/wiki/Main_Page</a>
</li>

<li>Why APL<br />
<a href="http://www.acm.org/sigapl/whyapl.htm">http://www.acm.org/sigapl/whyapl.htm</a>
</li>

<li>java.jdbc API Reference<br />
<a href="https://clojure.github.io/java.jdbc/">https://clojure.github.io/java.jdbc/</a>
</li>

<li>Hiccup<br />
<a href="https://github.com/weavejester/hiccup">https://github.com/weavejester/hiccup</a>
</li>

<li>Clojure Ring na GitHubu<br />
<a href="https://github.com/ring-clojure/ring">https://github.com/ring-clojure/ring</a>
</li>

<li>A brief overview of the Clojure web stack<br />
<a href="https://brehaut.net/blog/2011/ring_introduction">https://brehaut.net/blog/2011/ring_introduction</a>
</li>

<li>Getting Started with Ring<br />
<a href="http://www.learningclojure.com/2013/01/getting-started-with-ring.html">http://www.learningclojure.com/2013/01/getting-started-with-ring.html</a>
</li>

<li>Getting Started with Ring and Compojure - Clojure Web Programming<br />
<a href="http://www.myclojureadventure.com/2011/03/getting-started-with-ring-and-compojure.html">http://www.myclojureadventure.com/2011/03/getting-started-with-ring-and-compojure.html</a>
</li>

<li>Unit Testing in Clojure<br />
<a href="http://nakkaya.com/2009/11/18/unit-testing-in-clojure/">http://nakkaya.com/2009/11/18/unit-testing-in-clojure/</a>
</li>

<li>Testing in Clojure (Part-1: Unit testing)<br />
<a href="http://blog.knoldus.com/2014/03/22/testing-in-clojure-part-1-unit-testing/">http://blog.knoldus.com/2014/03/22/testing-in-clojure-part-1-unit-testing/</a>
</li>

<li>API for clojure.test - Clojure v1.6 (stable)<br />
<a href="https://clojure.github.io/clojure/clojure.test-api.html">https://clojure.github.io/clojure/clojure.test-api.html</a>
</li>

<li>Leiningen: úvodní stránka<br />
<a href="http://leiningen.org/">http://leiningen.org/</a>
</li>

<li>Leiningen: Git repository<br />
<a href="https://github.com/technomancy/leiningen">https://github.com/technomancy/leiningen</a>
</li>

<li>leiningen-win-installer<br />
<a href="http://leiningen-win-installer.djpowell.net/">http://leiningen-win-installer.djpowell.net/</a>
</li>

<li>Clojure  1: Úvod<br />
<a href="http://www.root.cz/clanky/clojure-aneb-jazyk-umoznujici-tvorbu-bezpecnych-vicevlaknovych-aplikaci-pro-jvm/">http://www.root.cz/clanky/clojure-aneb-jazyk-umoznujici-tvorbu-bezpecnych-vicevlaknovych-aplikaci-pro-jvm/</a>
</li>

<li>Clojure  2: Symboly, kolekce atd.<br />
<a href="http://www.root.cz/clanky/clojure-aneb-jazyk-umoznujici-tvorbu-bezpecnych-vicevlaknovych-aplikaci-pro-jvm-2-cast/">http://www.root.cz/clanky/clojure-aneb-jazyk-umoznujici-tvorbu-bezpecnych-vicevlaknovych-aplikaci-pro-jvm-2-cast/</a>
</li>

<li>Clojure  3: Funkcionální programování<br />
<a href="http://www.root.cz/clanky/clojure-aneb-jazyk-umoznujici-tvorbu-bezpecnych-vicevlaknovych-aplikaci-pro-jvm-3-cast-funkcionalni-programovani/">http://www.root.cz/clanky/clojure-aneb-jazyk-umoznujici-tvorbu-bezpecnych-vicevlaknovych-aplikaci-pro-jvm-3-cast-funkcionalni-programovani/</a>
</li>

<li>Clojure  4: Kolekce, sekvence a lazy sekvence<br />
<a href="http://www.root.cz/clanky/clojure-aneb-jazyk-umoznujici-tvorbu-bezpecnych-vicevlaknovych-aplikaci-pro-jvm-4-cast-kolekce-sekvence-a-lazy-sekvence/">http://www.root.cz/clanky/clojure-aneb-jazyk-umoznujici-tvorbu-bezpecnych-vicevlaknovych-aplikaci-pro-jvm-4-cast-kolekce-sekvence-a-lazy-sekvence/</a>
</li>

<li>Clojure  5: Sekvence, lazy sekvence a paralelní programy<br />
<a href="http://www.root.cz/clanky/clojure-a-bezpecne-aplikace-pro-jvm-sekvence-lazy-sekvence-a-paralelni-programy/">http://www.root.cz/clanky/clojure-a-bezpecne-aplikace-pro-jvm-sekvence-lazy-sekvence-a-paralelni-programy/</a>
</li>

<li>Clojure  6: Podpora pro paralelní programování<br />
<a href="http://www.root.cz/clanky/programovaci-jazyk-clojure-6-futures-nejsou-jen-financni-derivaty/">http://www.root.cz/clanky/programovaci-jazyk-clojure-6-futures-nejsou-jen-financni-derivaty/</a>
</li>

<li>Clojure  7: Další funkce pro paralelní programování<br />
<a href="http://www.root.cz/clanky/programovaci-jazyk-clojure-7-dalsi-podpurne-prostredky-pro-paralelni-programovani/">http://www.root.cz/clanky/programovaci-jazyk-clojure-7-dalsi-podpurne-prostredky-pro-paralelni-programovani/</a>
</li>

<li>Clojure  8: Identity, stavy, neměnné hodnoty a reference<br />
<a href="http://www.root.cz/clanky/programovaci-jazyk-clojure-8-identity-stavy-nemenne-hodnoty-a-referencni-typy/">http://www.root.cz/clanky/programovaci-jazyk-clojure-8-identity-stavy-nemenne-hodnoty-a-referencni-typy/</a>
</li>

<li>Clojure  9: Validátory, pozorovatelé a kooperace s Javou<br />
<a href="http://www.root.cz/clanky/programovaci-jazyk-clojure-9-validatory-pozorovatele-a-kooperace-mezi-clojure-a-javou/">http://www.root.cz/clanky/programovaci-jazyk-clojure-9-validatory-pozorovatele-a-kooperace-mezi-clojure-a-javou/</a>
</li>

<li>Clojure 10: Kooperace mezi Clojure a Javou<br />
<a href="http://www.root.cz/clanky/programovaci-jazyk-clojure-10-kooperace-mezi-clojure-a-javou-pokracovani/">http://www.root.cz/clanky/programovaci-jazyk-clojure-10-kooperace-mezi-clojure-a-javou-pokracovani/</a>
</li>

<li>Clojure 11: Generátorová notace seznamu/list comprehension<br />
<a href="http://www.root.cz/clanky/programovaci-jazyk-clojure-11-generatorova-notace-seznamu-list-comprehension/">http://www.root.cz/clanky/programovaci-jazyk-clojure-11-generatorova-notace-seznamu-list-comprehension/</a>
</li>

<li>Clojure 12: Překlad programů z Clojure do bajtkódu JVM I<br />
<a href="http://www.root.cz/clanky/programovaci-jazyk-clojure-12-preklad-programu-z-clojure-do-bajtkodu-jvm/">http://www.root.cz/clanky/programovaci-jazyk-clojure-12-preklad-programu-z-clojure-do-bajtkodu-jvm/</a>
</li>

<li>Clojure 13: Překlad programů z Clojure do bajtkódu JVM II<br />
<a href="2) http://www.root.cz/clanky/programovaci-jazyk-clojure-13-preklad-programu-z-clojure-do-bajtkodu-jvm-pokracovani/">2) http://www.root.cz/clanky/programovaci-jazyk-clojure-13-preklad-programu-z-clojure-do-bajtkodu-jvm-pokracovani/</a>
</li>

<li>Clojure 14: Základy práce se systémem maker<br />
<a href="http://www.root.cz/clanky/programovaci-jazyk-clojure-14-zaklady-prace-se-systemem-maker/">http://www.root.cz/clanky/programovaci-jazyk-clojure-14-zaklady-prace-se-systemem-maker/</a>
</li>

<li>Clojure 15: Tvorba uživatelských maker<br />
<a href="http://www.root.cz/clanky/programovaci-jazyk-clojure-15-tvorba-uzivatelskych-maker/">http://www.root.cz/clanky/programovaci-jazyk-clojure-15-tvorba-uzivatelskych-maker/</a>
</li>

<li>Clojure 16: Složitější uživatelská makra<br />
<a href="http://www.root.cz/clanky/programovaci-jazyk-clojure-16-slozitejsi-uzivatelska-makra/">http://www.root.cz/clanky/programovaci-jazyk-clojure-16-slozitejsi-uzivatelska-makra/</a>
</li>

<li>Clojure 17: Využití standardních maker v praxi<br />
<a href="http://www.root.cz/clanky/programovaci-jazyk-clojure-17-vyuziti-standardnich-maker-v-praxi/">http://www.root.cz/clanky/programovaci-jazyk-clojure-17-vyuziti-standardnich-maker-v-praxi/</a>
</li>

<li>Clojure 18: Základní techniky optimalizace aplikací<br />
<a href="http://www.root.cz/clanky/programovaci-jazyk-clojure-18-zakladni-techniky-optimalizace-aplikaci/">http://www.root.cz/clanky/programovaci-jazyk-clojure-18-zakladni-techniky-optimalizace-aplikaci/</a>
</li>

<li>Clojure 19: Vývojová prostředí pro Clojure<br />
<a href="http://www.root.cz/clanky/programovaci-jazyk-clojure-19-vyvojova-prostredi-pro-clojure/">http://www.root.cz/clanky/programovaci-jazyk-clojure-19-vyvojova-prostredi-pro-clojure/</a>
</li>

<li>Clojure 20: Vývojová prostředí pro Clojure (Vimu s REPL)<br />
<a href="http://www.root.cz/clanky/programovaci-jazyk-clojure-20-vyvojova-prostredi-pro-clojure-integrace-vimu-s-repl/">http://www.root.cz/clanky/programovaci-jazyk-clojure-20-vyvojova-prostredi-pro-clojure-integrace-vimu-s-repl/</a>
</li>

<li>Clojure 21: ClojureScript aneb překlad Clojure do JS<br />
<a href="http://www.root.cz/clanky/programovaci-jazyk-clojure-21-clojurescript-aneb-preklad-clojure-do-javascriptu/">http://www.root.cz/clanky/programovaci-jazyk-clojure-21-clojurescript-aneb-preklad-clojure-do-javascriptu/</a>
</li>

</ol>



<p></p><p></p>
<p><small>Autor: <a href="http://www.fit.vutbr.cz/~tisnovpa">Pavel Tišnovský</a> &nbsp; 2015</small></p>
</body>
</html>

