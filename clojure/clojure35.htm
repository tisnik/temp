<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
        "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html>
<head>
<title>Multimetody v Clojure aneb polymorfismus bez použití OOP</title>
<meta name="Author" content="Pavel Tisnovsky" />
<meta name="Generator" content="vim" />
<meta http-equiv="content-type" content="text/html; charset=utf-8" />
<style type="text/css">
         body {color:#000000; background:#ffffff;}
         h1  {font-family: arial, helvetica, sans-serif; color:#ffffff; background-color:#c00000; text-align:center; padding-left:1em}
         h2  {font-family: arial, helvetica, sans-serif; color:#ffffff; background-color:#0000c0; padding-left:1em; text-align:left}
         h3  {font-family: arial, helvetica, sans-serif; color:#000000; background-color:#c0c0c0; padding-left:1em; text-align:left}
         h4  {font-family: arial, helvetica, sans-serif; color:#000000; background-color:#e0e0e0; padding-left:1em; text-align:left}
         a   {font-family: arial, helvetica, sans-serif;}
         li  {font-family: arial, helvetica, sans-serif; color:#000000; text-align:justify; width:450px;}
         ol  {font-family: arial, helvetica, sans-serif; color:#000000; text-align:justify; width:450px;}
         ul  {font-family: arial, helvetica, sans-serif; color:#000000; text-align:justify; width:450px;}
         p   {font-family: arial, helvetica, sans-serif; color:#000000; text-align:justify;}
         pre {background:#e0e0e0}
</style>
</head>

<body>

<h1>Multimetody v Clojure aneb polymorfismus bez použití OOP</h1>

<h3>Pavel Tišnovský</h3>

<p></p>

<h1>Úvodník</h1>

<p>Programovací jazyk Clojure obsahuje, podobně jako například Common Lisp, Scala či Elixir, podporu pro tvorbu a volání takzvaných multimetod. Multimetody se od běžných metod známých z mainstreamových programovacích jazyků (C++, Java či C#) odlišují především principem dynamického výběru konkrétní metody v čase běhu aplikace: ten totiž není založen jen na hierarchii tříd či typů.</p>



<h2>Obsah</h2>

<p><a href="#k01">1. Multimetody v&nbsp;Clojure aneb polymorfismus bez použití OOP</a></p>
<p><a href="#k02">2. Problém typický pro třídní OOP: je kružnice speciálním případem elipsy?</a></p>
<p><a href="#k03">3. Multimetody</a></p>
<p><a href="#k04">4. První varianta funkce <strong>heading</strong></a></p>
<p><a href="#k05">5. Nedostatky první verze</a></p>
<p><a href="#k06">6. První vylepšení &ndash; rozlišení typu parametru předaného funkci <strong>heading</strong></a></p>
<p><a href="#k07">7. Definice multimetody a k&nbsp;ní příslušné výběrové (dispatch) funkce</a></p>
<p><a href="#k08">8. Volání multimetody na základě zjištěného typu parametru</a></p>
<p><a href="#k09">9. Implicitní metoda</a></p>
<p><a href="#k10">10. Hierarchie typů a způsob řešení &bdquo;kolizí&ldquo;</a></p>
<p><a href="#k11">11. Programátorem zvolená preference metod</a></p>
<p><a href="#k12">12. Finální varianta multimetody <strong>heading</strong></a></p>
<p><a href="#k13">13. Odkazy na předchozí části tohoto seriálu</a></p>
<p><a href="#k14">14. Odkazy na Internetu</a></p>



<p><a name="k01"></a></p>
<h2 id="k01">1. Multimetody v&nbsp;Clojure aneb polymorfismus bez použití OOP</h2>

<p>V&nbsp;diskusi, která se vedla (resp.&nbsp;přesněji řečeno stále ještě
s&nbsp;poněkud menší frekvencí vede) pod článkem <a
href="http://www.root.cz/clanky/recenze-knihy-functional-thinking-paradigm-over-syntax/">Recenze
knihy Functional Thinking (Paradigm over syntax)</a>, zaznělo mj.&nbsp;i
několik zajímavých názorů, které se poměrně úzce dotýkají problematiky
polymorfismu, tj.&nbsp;poněkud zjednodušeně řečeno technologie způsobu výběru
konkrétní funkce či metody, která se má v&nbsp;daném kontextu zavolat. Pojem
&bdquo;polymorfismus&ldquo; se v&nbsp;oblasti programovacích jazyků používá pro
popis hned několika navzájem odlišných vlastností nějakého jazyka či jeho
běhového prostředí, což někdy může vést ke zbytečným nedorozuměním, zvláště
když se přesně nespecifikuje, který druh polymorfismu má pisatel vlastně na
mysli. V&nbsp;mnoha programovacích jazycích podporujících objektově orientované
programování (navíc založené na použití tříd) se pod pojmem
&bdquo;polymorfismus&ldquo; většinou automaticky myslí takzvaný <i>podtypový
polymorfismus</i> neboli <i>subtype polymorphism</i>.</p>

<p>Podtypový polymorfismus se dále může dělit na polymorfismus statický a
dynamický. U statického polymorfismu o výběru volané metody rozhoduje již
překladač, který většinou do vytvářeného strojového kódu přímo umístí instrukce
pro volání konkrétní funkce či metody (její adresu). Někdy se pod tento pojem
poněkud nepřesně zahrnuje i přetížení funkcí. Naopak dynamický podtypový
polymorfismus (v&nbsp;řeči OOP tedy jen &bdquo;polymorfismus&ldquo;) je typicky
založený na pozdní vazbě &ndash; <i>late binding</i> &ndash; a tabulce
virtuálních metod). Pokud však termín &bdquo;polymorfismus&ldquo; použije
vývojář používající nějaký jazyk podporující funkcionální programování, bude
mít pravděpodobně na mysli <i>polymorfismus parametrický</i>, tedy technologii,
kterou si alespoň stručně vysvětlíme v&nbsp;navazujících kapitolách. Aby nebylo
zmatků v&nbsp;pojmenování málo, můžeme se setkat i s&nbsp;označením <i>runtime
polymorphism</i>, což může být buď podtypový dynamický polymorfismus nebo
parametrický dynamický polymorfismus :-)</p>



<p><a name="k02"></a></p>
<h2 id="k02">2. Problém typický pro třídní OOP: je kružnice speciálním případem elipsy?</h2>

<p>Podtypový polymorfismus pravděpodobně není nutné vývojářům, kteří tento
článek čtou, podrobně představovat, protože v&nbsp;mainstreamových
programovacích jazycích založených na objektově orientovaném programování
s&nbsp;třídami je použit právě tento druh polymorfismu. V&nbsp;praxi to může
znamenat, že vývojář definuje hierarchii tříd s&nbsp;tím, že se výběr konkrétní
metody, která se má zavolat, může provést až v&nbsp;čase běhu aplikace, a to na
základě typu objektu, jehož metoda se volá. Obecně totiž platí, že překladač
nemusí mít k&nbsp;dispozici informaci o přesném typu objektu, a to právě na
základě hierarchie tříd, kdy potomek může nahradit předka. I přes značné
rozšíření podtypového polymorfismu v&nbsp;OOP jazycích se však v&nbsp;některých
případech nevyhneme některým problémům, typicky problému nazývanému <a
href="https://en.wikipedia.org/wiki/Circle-ellipse_problem">problém
kružnice-elipsa</a> (<i>Circle-ellipse problem</i>). Zkuste se nad tímto
problémem sami chvíli zamyslet a zjistit, proč použití klasické třídní
hierarchie a objektů s&nbsp;měnitelným stavem (&bdquo;se settery&ldquo;) nutně
vede k&nbsp;problémům:</p>

<pre>
class Ellipse implements Shape {
}
&nbsp;
class Circle extends Ellipse {
}
</pre>

<p>versus:</p>

<pre>
class Circle implements Shape {
}
&nbsp;
class Ellipse extends Circle {
}
</pre>

<p>versus:</p>

<pre>
class Circle implements Shape {
}
&nbsp;
class Ellipse implements Shape {
}
</pre>

<p>Ostatně velmi podobný typ problému byl popsán v&nbsp;již zmíněné <a
href="http://www.root.cz/clanky/recenze-knihy-functional-thinking-paradigm-over-syntax/nazory/">diskusi</a>
(poněkud sofistikovanější to bude například při snaze o vytvoření hierarchie
tříd číselných typů &ndash; reálná vs komplexní čísla apod.). Právě tyto
kategorie problémů je možné poměrně elegantně vyřešit použitím
<i>multimetod</i>, které nejsou svázány s&nbsp;hierarchií tříd.</p>

<ins>Poznámka: tvrzení z&nbsp;předchozích odstavců nutně neznamená, že OOP je
ve všech případech špatný koncept; pouze by mělo být patrné, že při modelování
objektů z&nbsp;reálného světa musíme být velmi obezřetní k&nbsp;tomu, zda se ve
vytvářeném modelu neporušuje nějaký základní předpoklad, nebo zda naopak nějaký
předpoklad zbytečně nepřidáváme (u zmíněného problému kružnice-elipsa se
například základní nedostatky relativně snadno obejdou zákazem změny stavu, což
je ostatně typický přístup používaný ve funkcionálním programování).</ins>



<p><a name="k03"></a></p>
<h2 id="k03">3. Multimetody</h2>

<p>Programovací jazyk Clojure vývojářům taktéž nabízí možnost tvorby
polymorfních metod, ovšem samotný princip výběru volané metody v&nbsp;čase běhu
aplikace nezávisí na použité třídní hierarchii: namísto běžných metod
(deklarovaných typicky v&nbsp;rámci tříd) je totiž v&nbsp;Clojure možné
deklarovat takzvané <i>multimetody</i>. Ty se skládají ze dvou částí &ndash;
definice <a
href="http://clojure.github.io/clojure/clojure.core-api.html#clojure.core/defmulti">defmulti</a>,
v&nbsp;níž je multimetoda pojmenovaná a navíc je zde zmíněna takzvaná výběrová
(dispatch) funkce, a následně z&nbsp;libovolného počtu definic <a
href="http://clojure.github.io/clojure/clojure.core-api.html#clojure.core/defmethod">defmethod</a>,
na něž se můžeme dívat jako na definice běžných funkcí, ovšem doplněných o
kontext určující, za jakých okolností se tato konkrétní funkce tvořící část
multimetody zavolá. Před popisem konkrétního způsobu zápisu multimetod si však
uveďme reálný příklad, který nám ukáže, kdy je vhodné multimetody použít
(v&nbsp;praxi však zjistíte, že se v&nbsp;naprosté většině případů bez
multimetod a tím pádem i polymorfismu můžete obejít, minimálně v&nbsp;dynamicky
typovaném jazyce Clojure).</p>



<p><a name="k04"></a></p>
<h2 id="k04">4. První varianta funkce <strong>heading</strong></h2>

<p>Předpokládejme, že ve vyvíjené aplikaci potřebujeme vytvořit funkci
(prozatím skutečně běžnou funkci) nazvanou <strong>heading</strong>. Tato
funkce vypíše na standardní výstup hodnotu svého parametru, ovšem navíc tuto
hodnotu od ostatních zpráv z&nbsp;obou stran vizuálně oddělí. První &ndash; a
jak uvidíme dále, i poměrně naivní &ndash; implementace této funkce může
vypadat velmi jednoduše a přímočaře. Připomeňme si jen, že
<strong>*out*</strong> je objekt typu <strong>java.io.Writer</strong>, který je
běžně navázaný na <strong>System.out</strong>. Můžeme tedy směle volat metodu
<strong>java.io.Writer.write()</strong>, ovšem s&nbsp;využitím Java
interop:</p>

<pre>
(<strong>defn</strong> heading
    [anything]
    (.write *out* "-----------------\n")
    (.write *out* anything)
    (.write *out* "\n-----------------\n"))
</pre>

<p>První test této funkce dopadne vcelku uspokojivě:</p>

<pre>
<i>user=&gt;</i> (heading "xyzzy")
-----------------
xyzzy
-----------------
</pre>



<p><a name="k05"></a></p>
<h2 id="k05">5. Nedostatky první verze</h2>

<p>Zdá se, že funkce <strong>heading</strong> pracuje uspokojivě za
předpokladu, že jí předáme parametr typu řetězec. Co se však stane u parametrů
jiných typů? Můžeme si to jednoduše vyzkoušet:</p>

<pre>
<i>user=&gt;</i> (heading 42)
-----------------
*
-----------------
</pre>

<p>Zde se číselná hodnota převedla na ASCII znak s&nbsp;kódem 42.</p>

<pre>
<i>user=&gt;</i> (heading nil)
&nbsp;
-----------------
NullPointerException   java.io.PrintWriter.write (PrintWriter.java:443)
</pre>

<p>Zde nejenže funkce nepracuje spolehlivě, ale navíc v&nbsp;programu
vygenerovala výjimku.</p>

<pre>
<i>user=&gt;</i> (heading [1 2 3])
&nbsp;
-----------------
IllegalArgumentException No matching method found: write for class java.io.PrintWriter  clojure.lang.Reflector.invokeMatchingMethod (Reflector.java:80)
&nbsp;
<i>user=&gt;</i> (heading {:first 1 :second 2})
&nbsp;
-----------------
IllegalArgumentException No matching method found: write for class java.io.PrintWriter  clojure.lang.Reflector.invokeMatchingMethod (Reflector.java:80)
</pre>

<p>Pro odlišné parametry, než je řetězec či celé číslo, taktéž namísto výpisu
dojde k&nbsp;vyhození výjimky; což pravděpodobně programátory, kteří budou naši
funkci chtít použít ve svých aplikacích, moc nepotěší.</p>



<p><a name="k06"></a></p>
<h2 id="k06">6. První vylepšení &ndash; rozlišení typu parametru předaného funkci <strong>heading</strong></h2>

<p>Pokusme se nyní funkci <strong>heading</strong> vylepšit, a to stále bez
použití multimetod. Jedním z&nbsp;možných řešení (ke kterému se prosím
v&nbsp;praxi moc často neuchylujte :-) je založeno na explicitním rozvětvení
provedeného na základě zjištěného typu parametru. Využijeme zde čtveřici
prediktorů nazvaných <strong>nil?</strong>, <strong>string?</strong>,
<strong>number?</strong> a <strong>vector?</strong>, samozřejmě je však možné
provést rozšíření i na další typy, s&nbsp;nimiž se v&nbsp;programovacím jazyce
Clojure můžete setkat. Bylo by například pěkné automaticky dereferovat atomy
apod.:</p>

<pre>
(<strong>defn</strong> heading
    [anything]
    (.write *out* "-----------------\n")
    (cond (nil?    anything) (.write *out* "nothing")
          (string? anything) (.write *out* anything)
          (number? anything) (.write *out* (str anything))
          (vector? anything) (.write *out* (clojure.string/join " " anything)))
    (.write *out* "\n-----------------\n"))
</pre>

<p>Funkce se nám prodloužila, takže se podívejme na to, jak si obstojí při
testování:</p>

<pre>
<i>user=&gt;</i> (heading "xyzzy")
-----------------
xyzzy
-----------------
&nbsp;
<i>user=&gt;</i> (heading 42)
-----------------
42
-----------------
&nbsp;
<i>user=&gt;</i> (heading nil)
-----------------
nothing
-----------------
&nbsp;
<i>user=&gt;</i> (heading [1 2 3])
-----------------
1 2 3
-----------------
&nbsp;
<i>user=&gt;</i> (heading {:first 1 :second 2})
-----------------
-----------------
&nbsp;
</pre>

<p>Vidíme, že v&nbsp;posledním případě, tj.&nbsp;při předání mapy, se mezi
označené řádky nic nevypíše, což je však v&nbsp;pořádku, protože jsme
v&nbsp;makru nedeklarovali žádnou větev <i>else</i>. Úprava je snadná:</p>

<pre>
(<strong>defn</strong> heading
    [anything]
    (.write *out* "-----------------\n")
    (cond (nil?    anything) (.write *out* "nothing")
          (string? anything) (.write *out* anything)
          (number? anything) (.write *out* (str anything))
          (vector? anything) (.write *out* (clojure.string/join " " anything))
          :else              (.write *out* "I'm confused"))
    (.write *out* "\n-----------------\n"))
</pre>



<p><a name="k07"></a></p>
<h2 id="k07">7. Definice multimetody a k&nbsp;ní příslušné výběrové (dispatch) funkce</h2>

<p>Výše uvedené řešení není zcela ideální, protože se v&nbsp;něm vlastně
snažíme o ruční (ad-hoc) implementaci polymorfismu. Podívejme se tedy, jak by
bylo možné využít multimetody. Víme již, že jejich definice je rozdělena
minimálně do dvou částí &ndash; <strong>defmulti</strong> a
<strong>defmethod</strong>. V&nbsp;definici <strong>defmulti</strong> je
multimetoda pojmenována a navíc je zde specifikována takzvaná výběrová
(dispatch) funkce:</p>

<pre>
(<strong>defmulti</strong> heading dispatch-fn)
</pre>

<p>Při volání multimetody je nejprve zavolána dispatch funkce s&nbsp;tím, že
její návratová hodnota je následně použita pro výběr konkrétní funkce/metody,
která se má zavolat (v&nbsp;třídním OOP, jaké je například implementováno
v&nbsp;Javě, vlastně dispatch funkce odpovídá výrazu <strong>this</strong>).
V&nbsp;našem konkrétním případě potřebujeme, aby dispatch funkce zjistila typ
parametru a nějakým způsobem tento typ vrátila. Naivní implementace může
vypadat například takto:</p>

<pre>
(<strong>defn</strong> dispatch-fn
    [anything]
    (cond (nil?    anything) :nil
          (string? anything) :string
          (number? anything) :number
          (vector? anything) :vector))
</pre>

<p>Následuje definice jednotlivých variant multimetody. Povšimněte si, že
<strong>defmethod</strong> se vlastně podobá běžné definici funkce
s&nbsp;využitím <strong>defn</strong>, ovšem s&nbsp;tím rozdílem, že za jménem
multimetody ještě následuje hodnota, která je při volání multimetody párována
s&nbsp;výsledkem dispatch funkce. Toto &bdquo;párování&ldquo; (<i>dynamic
dispatching</i>) za nás provede interpret a překladač automaticky, ostatně
podobně automaticky je tomu v&nbsp;OOP jazycích (poznámka &ndash; hodnota může
být libovolná, klidně zde můžeme použít mapu, vektor, záznam atd.):</p>

<pre>
(<strong>defmethod</strong> heading :nil
    [val]
    (.write *out* "-----------------\n")
    (.write *out* "nothing")
    (.write *out* "\n-----------------\n"))
&nbsp;
(<strong>defmethod</strong> heading :string
    [val]
    (.write *out* "-----------------\n")
    (.write *out* val)
    (.write *out* "\n-----------------\n"))
&nbsp;
(<strong>defmethod</strong> heading :number
    [val]
    (.write *out* "-----------------\n")
    (.write *out* (str val))
    (.write *out* "\n-----------------\n"))
&nbsp;
(<strong>defmethod</strong> heading :vector
    [val]
    (.write *out* "-----------------\n")
    (.write *out* (clojure.string/join " " val))
    (.write *out* "\n-----------------\n"))
</pre>

<p>Volání multimetody se nijak neliší od volání běžné funkce (to je právě na
multimetodách pěkné), takže si pusťme do testování:</p>

<pre>
<i>user=&gt;</i> (heading nil)
-----------------
nothing
-----------------
&nbsp;
<i>user=&gt;</i> (heading "xyzzy")
-----------------
xyzzy
-----------------
&nbsp;
<i>user=&gt;</i> (heading 42)
-----------------
42
-----------------
&nbsp;
<i>user=&gt;</i> (heading nil)
-----------------
nothing
-----------------
&nbsp;
<i>user=&gt;</i> (heading [1 2 3])
-----------------
1 2 3
-----------------
</pre>

<p>Zajímavá situace nastane ve chvíli, kdy použijeme parametr neznámého
typu:</p>

<pre>
<i>user=&gt;</i> (heading {:first 1 :second 2})
&nbsp;
IllegalArgumentException No method in multimethod 'heading' for dispatch value: null  clojure.lang.MultiFn.getFn (MultiFn.java:160)
</pre>

<p>I tento problém však lze snadno vyřešit, jak ostatně uvidíme v&nbsp;dalších
kapitolách.</p>



<p><a name="k08"></a></p>
<h2 id="k08">8. Volání multimetody na základě zjištěného typu parametru</h2>

<p>Naši multimetodu <strong>heading</strong> je možné vylepšit, a to hned
několika způsoby. Například namísto uživatelsky definované dispatch funkce
můžeme v&nbsp;tomto případě použít vestavěnou funkci nazvanou jednoduše
<strong>class</strong>, která dokáže v&nbsp;runtime (za běhu aplikace)
detekovat typ svého argumentu. Ostatně se sami podívejme, jak tato funkce
pracuje (povšimněte si, že pro <strong>nil</strong> se vrátí taktéž typ
<strong>nil</strong>):</p>

<pre>
<i>user=&gt;</i> (class nil)
nil
&nbsp;
<i>user=&gt;</i> (class "xyzzy")
java.lang.String
&nbsp;
<i>user=&gt;</i> (class 42)
java.lang.Long
&nbsp;
<i>user=&gt;</i> (class 42.0)
java.lang.Double
&nbsp;
<i>user=&gt;</i> (class [1 2 3])
clojure.lang.PersistentVector
&nbsp;
<i>user=&gt;</i> (class (range 10))
clojure.lang.LazySeq
</pre>

<p>První část definice multimetody se nám tedy zjednoduší na jeden jediný
řádek, protože nebudeme definovat žádnou dispatch funkci:</p>

<pre>
(<strong>defmulti</strong> heading class)
</pre>

<p>Druhá část definice multimetody (jednotlivé konkrétní metody) se od první
verze příkladu odlišují hodnotou použitou pro spárování (<i>dynamic
dispatching</i>):</p>

<pre>
(<strong>defmethod</strong> heading nil
    [val]
    (.write *out* "-----------------\n")
    (.write *out* "nothing")
    (.write *out* "\n-----------------\n"))
&nbsp;
(<strong>defmethod</strong> heading String
    [val]
    (.write *out* "-----------------\n")
    (.write *out* val)
    (.write *out* "\n-----------------\n"))
&nbsp;
(<strong>defmethod</strong> heading Number
    [val]
    (.write *out* "-----------------\n")
    (.write *out* (str val))
    (.write *out* "\n-----------------\n"))
&nbsp;
(<strong>defmethod</strong> heading clojure.lang.IPersistentVector
    [val]
    (.write *out* "-----------------\n")
    (.write *out* (clojure.string/join " " val))
    (.write *out* "\n-----------------\n"))
</pre>

<p>Opět si novou variantu multimetody otestujme:</p>

<pre>
<i>user=&gt;</i> (heading nil)
-----------------
nothing
-----------------
&nbsp;
<i>user=&gt;</i> (heading "xyzzy")
-----------------
xyzzy
-----------------
&nbsp;
<i>user=&gt;</i> (heading 42)
-----------------
42
-----------------
&nbsp;
<i>user=&gt;</i> (heading nil)
-----------------
nothing
-----------------
&nbsp;
<i>user=&gt;</i> (heading [1 2 3])
-----------------
1 2 3
-----------------
</pre>

<p>Vše vypadá (zdánlivě) v&nbsp;pořádku!</p>



<p><a name="k09"></a></p>
<h2 id="k09">9. Implicitní metoda</h2>

<p>Když jsme se snažili o implementaci ad-hoc polymorfismu s&nbsp;využitím
makra <strong>cond</strong>, bylo možné použít větev <i>else</i> pro ty
případy, pro které neexistovala speciální větev. Podobnou vlastnost podporují i
multimetody, a to při použití hodnoty <strong>:default</strong>. Pokud naši
multimetodu <a href="#k08">z&nbsp;předchozí kapitoly</a> rozšíříme o další
metodu ve tvaru:</p>

<pre>
(<strong>defmethod</strong> heading :default
    [anything]
    (.write *out* "-----------------\n")
    (.write *out* "I'm confused!")
    (.write *out* "\n-----------------\n"))
</pre>

<p>...budeme moci bez problémů metodu zavolat a předat jí množinu, mapu
apod.:</p>

<pre>
<i>user=&gt;</i> (heading {:first 1 :second 2})
-----------------
I'm confused!
-----------------
</pre>

<ins>Pokuste se o něco podobného například v&nbsp;Javě...</ins>



<p><a name="k10"></a></p>
<h2 id="k10">10. Hierarchie typů a způsob řešení &bdquo;kolizí&ldquo;</h2>

<p>Ve skutečnosti nám však ještě zbývá vyřešit minimálně jeden problém.
Řekněme, že požadavek na multimetodu <strong>heading</strong> byl rozšířen
&ndash; pokud se jí předá vektor, má být vypsán v&nbsp;hranatých závorkách,
pokud sekvence nebo jiná kolekce, pak se mají použít závorky kulaté. Zdánlivě
se nejedná o nic složitého, takže by řešení mohlo vypadat třeba takto:</p>

<pre>
(<strong>defmulti</strong> heading class)
&nbsp;
(<strong>defmethod</strong> heading nil
    [val]
    (.write *out* "-----------------\n")
    (.write *out* "nothing")
    (.write *out* "\n-----------------\n"))
&nbsp;
(<strong>defmethod</strong> heading String
    [val]
    (.write *out* "-----------------\n")
    (.write *out* val)
    (.write *out* "\n-----------------\n"))
&nbsp;
(<strong>defmethod</strong> heading Number
    [val]
    (.write *out* "-----------------\n")
    (.write *out* (str val))
    (.write *out* "\n-----------------\n"))
&nbsp;
(<strong>defmethod</strong> heading clojure.lang.IPersistentVector
    [val]
    (.write *out* "-----------------\n")
    (.write *out* "[")
    (.write *out* (clojure.string/join " " val))
    (.write *out* "]")
    (.write *out* "\n-----------------\n"))
&nbsp;
(<strong>defmethod</strong> heading java.util.Collection
    [val]
    (.write *out* "-----------------\n")
    (.write *out* "(")
    (.write *out* (clojure.string/join " " val))
    (.write *out* ")")
    (.write *out* "\n-----------------\n"))
&nbsp;
(<strong>defmethod</strong> heading :default
    [anything]
    (.write *out* "-----------------\n")
    (.write *out* "I'm confused!")
    (.write *out* "\n-----------------\n"))
</pre>

<p>První testování však nedopadne příliš dobře:</p>

<pre>
(heading [1 2 3])
<i>user=&gt;</i> (heading [1 2 3])
&nbsp;
IllegalArgumentException Multiple methods in multimethod 'heading' match dispatch value:
class clojure.lang.PersistentVector -&gt; interface java.util.Collection and interface
clojure.lang.IPersistentVector, and neither is preferred
clojure.lang.MultiFn.findAndCacheBestMethod (MultiFn.java:182)
</pre>

<p>Runtime programovacího jazyka Clojure nám celkem jasně sděluje, že pro daný
typ (vektor) našel hned dvě metody, které může použít. A vzhledem k&nbsp;tomu,
že se v&nbsp;multimetodách nepoužívá (a ani nemůže používat) hierarchie tříd,
je runtime zmatený a namísto hádání, která metoda je danému typu
&bdquo;nejblíže&ldquo;, raději vyhodí výjimku.</p>



<p><a name="k11"></a></p>
<h2 id="k11">11. Programátorem zvolená preference metod</h2>

<p>Vzhledem k&nbsp;tomu, jakou volnost mají programátoři při konstrukci
multimetod, nás pravděpodobně příliš nepřekvapí, že i preference jednotlivých
metod tvořících multimetodu je volitelná. Používá se zde deklarace
<strong>prefer-method</strong>, které se musí předat jak identifikátor
multimetody (<strong>heading</strong>), tak i specifikace, která metoda
(resp.&nbsp;přesněji řečeno která hodnota vrácená dispatch funkcí) bude mít
přednost. V&nbsp;tomto máme jasno &ndash; pokud je multimetodě předán vektor,
nechť je vypsán jako vektor ve hranatých závorkách, zatímco ostatní kolekce
nechť jsou vypsány v&nbsp;kulatých závorkách:</p>

<pre>
(<strong>prefer-method</strong> heading clojure.lang.IPersistentVector java.util.Collection)
</pre>

<p>Vše si samozřejmě otestujeme:</p>

<pre>
<i>user=&gt;</i> (heading [1 2 3])
-----------------
[1 2 3]
-----------------
&nbsp;
<i>user=&gt;</i> (heading '(1 2 3))
-----------------
(1 2 3)
-----------------
&nbsp;
<i>user=&gt;</i> (heading (range 10))
-----------------
(0 1 2 3 4 5 6 7 8 9)
-----------------
</pre>

<ins>Poznámka: v&nbsp;deklaraci <strong>prefer-method</strong> se vždy
specifikují jen dvě hodnoty, přičemž první hodnota je preferována, ovšem nic
nám nebrání použít více těchto deklarací a vytvořit si tak vlastní
&bdquo;hierarchii&ldquo;</ins>



<p><a name="k12"></a></p>
<h2 id="k12">12. Finální varianta multimetody <strong>heading</strong></h2>

<p>Na závěr tohoto článku si ještě uveďme úplnou definici multimetody
<strong>heading</strong>. Namísto uživatelsky definované dispatch funkce je
použita funkce <strong>class</strong> implementovaná v&nbsp;základní knihovně,
multimetoda správně (bez vyhození výjimky) reaguje na neznámý typ parametru a u
vektorů je jasně rozlišeno, která část multimetody se má zavolat:</p>

<pre>
(<strong>defmulti</strong> heading class)
&nbsp;
(<strong>defmethod</strong> heading nil
    [value]
    (.write *out* "-----------------\n")
    (.write *out* "nothing")
    (.write *out* "\n-----------------\n"))
&nbsp;
(<strong>defmethod</strong> heading String
    [value]
    (.write *out* "-----------------\n")
    (.write *out* value)
    (.write *out* "\n-----------------\n"))
&nbsp;
(<strong>defmethod</strong> heading Number
    [value]
    (.write *out* "-----------------\n")
    (.write *out* (str value))
    (.write *out* "\n-----------------\n"))
&nbsp;
(<strong>defmethod</strong> heading clojure.lang.IPersistentVector
    [value]
    (.write *out* "-----------------\n")
    (.write *out* "[")
    (.write *out* (clojure.string/join " " value))
    (.write *out* "]")
    (.write *out* "\n-----------------\n"))
&nbsp;
(<strong>defmethod</strong> heading java.util.Collection
    [value]
    (.write *out* "-----------------\n")
    (.write *out* "(")
    (.write *out* (clojure.string/join " " value))
    (.write *out* ")")
    (.write *out* "\n-----------------\n"))
&nbsp;
(<strong>defmethod</strong> heading :default
    [anything]
    (.write *out* "-----------------\n")
    (.write *out* "I'm confused!")
    (.write *out* "\n-----------------\n"))
&nbsp;
(prefer-method heading clojure.lang.IPersistentVector java.util.Collection)
</pre>



<p><a name="k13"></a></p>
<h2 id="k13">13. Odkazy na předchozí části tohoto seriálu</h2>

<ol>

<li>Clojure  1: Úvod<br />
<a href="http://www.root.cz/clanky/clojure-aneb-jazyk-umoznujici-tvorbu-bezpecnych-vicevlaknovych-aplikaci-pro-jvm/">http://www.root.cz/clanky/clojure-aneb-jazyk-umoznujici-tvorbu-bezpecnych-vicevlaknovych-aplikaci-pro-jvm/</a>
</li>

<li>Clojure  2: Symboly, kolekce atd.<br />
<a href="http://www.root.cz/clanky/clojure-aneb-jazyk-umoznujici-tvorbu-bezpecnych-vicevlaknovych-aplikaci-pro-jvm-2-cast/">http://www.root.cz/clanky/clojure-aneb-jazyk-umoznujici-tvorbu-bezpecnych-vicevlaknovych-aplikaci-pro-jvm-2-cast/</a>
</li>

<li>Clojure  3: Funkcionální programování<br />
<a href="http://www.root.cz/clanky/clojure-aneb-jazyk-umoznujici-tvorbu-bezpecnych-vicevlaknovych-aplikaci-pro-jvm-3-cast-funkcionalni-programovani/">http://www.root.cz/clanky/clojure-aneb-jazyk-umoznujici-tvorbu-bezpecnych-vicevlaknovych-aplikaci-pro-jvm-3-cast-funkcionalni-programovani/</a>
</li>

<li>Clojure  4: Kolekce, sekvence a lazy sekvence<br />
<a href="http://www.root.cz/clanky/clojure-aneb-jazyk-umoznujici-tvorbu-bezpecnych-vicevlaknovych-aplikaci-pro-jvm-4-cast-kolekce-sekvence-a-lazy-sekvence/">http://www.root.cz/clanky/clojure-aneb-jazyk-umoznujici-tvorbu-bezpecnych-vicevlaknovych-aplikaci-pro-jvm-4-cast-kolekce-sekvence-a-lazy-sekvence/</a>
</li>

<li>Clojure  5: Sekvence, lazy sekvence a paralelní programy<br />
<a href="http://www.root.cz/clanky/clojure-a-bezpecne-aplikace-pro-jvm-sekvence-lazy-sekvence-a-paralelni-programy/">http://www.root.cz/clanky/clojure-a-bezpecne-aplikace-pro-jvm-sekvence-lazy-sekvence-a-paralelni-programy/</a>
</li>

<li>Clojure  6: Podpora pro paralelní programování<br />
<a href="http://www.root.cz/clanky/programovaci-jazyk-clojure-6-futures-nejsou-jen-financni-derivaty/">http://www.root.cz/clanky/programovaci-jazyk-clojure-6-futures-nejsou-jen-financni-derivaty/</a>
</li>

<li>Clojure  7: Další funkce pro paralelní programování<br />
<a href="http://www.root.cz/clanky/programovaci-jazyk-clojure-7-dalsi-podpurne-prostredky-pro-paralelni-programovani/">http://www.root.cz/clanky/programovaci-jazyk-clojure-7-dalsi-podpurne-prostredky-pro-paralelni-programovani/</a>
</li>

<li>Clojure  8: Identity, stavy, neměnné hodnoty a reference<br />
<a href="http://www.root.cz/clanky/programovaci-jazyk-clojure-8-identity-stavy-nemenne-hodnoty-a-referencni-typy/">http://www.root.cz/clanky/programovaci-jazyk-clojure-8-identity-stavy-nemenne-hodnoty-a-referencni-typy/</a>
</li>

<li>Clojure  9: Validátory, pozorovatelé a kooperace s Javou<br />
<a href="http://www.root.cz/clanky/programovaci-jazyk-clojure-9-validatory-pozorovatele-a-kooperace-mezi-clojure-a-javou/">http://www.root.cz/clanky/programovaci-jazyk-clojure-9-validatory-pozorovatele-a-kooperace-mezi-clojure-a-javou/</a>
</li>

<li>Clojure 10: Kooperace mezi Clojure a Javou<br />
<a href="http://www.root.cz/clanky/programovaci-jazyk-clojure-10-kooperace-mezi-clojure-a-javou-pokracovani/">http://www.root.cz/clanky/programovaci-jazyk-clojure-10-kooperace-mezi-clojure-a-javou-pokracovani/</a>
</li>

<li>Clojure 11: Generátorová notace seznamu/list comprehension<br />
<a href="http://www.root.cz/clanky/programovaci-jazyk-clojure-11-generatorova-notace-seznamu-list-comprehension/">http://www.root.cz/clanky/programovaci-jazyk-clojure-11-generatorova-notace-seznamu-list-comprehension/</a>
</li>

<li>Clojure 12: Překlad programů z Clojure do bajtkódu JVM I:<br />
<a href="http://www.root.cz/clanky/programovaci-jazyk-clojure-12-preklad-programu-z-clojure-do-bajtkodu-jvm/">http://www.root.cz/clanky/programovaci-jazyk-clojure-12-preklad-programu-z-clojure-do-bajtkodu-jvm/</a>
</li>

<li>Clojure 13: Překlad programů z Clojure do bajtkódu JVM II:<br />
<a href="http://www.root.cz/clanky/programovaci-jazyk-clojure-13-preklad-programu-z-clojure-do-bajtkodu-jvm-pokracovani/">http://www.root.cz/clanky/programovaci-jazyk-clojure-13-preklad-programu-z-clojure-do-bajtkodu-jvm-pokracovani/</a>
</li>

<li>Clojure 14: Základy práce se systémem maker<br />
<a href="http://www.root.cz/clanky/programovaci-jazyk-clojure-14-zaklady-prace-se-systemem-maker/">http://www.root.cz/clanky/programovaci-jazyk-clojure-14-zaklady-prace-se-systemem-maker/</a>
</li>

<li>Clojure 15: Tvorba uživatelských maker<br />
<a href="http://www.root.cz/clanky/programovaci-jazyk-clojure-15-tvorba-uzivatelskych-maker/">http://www.root.cz/clanky/programovaci-jazyk-clojure-15-tvorba-uzivatelskych-maker/</a>
</li>

<li>Clojure 16: Složitější uživatelská makra<br />
<a href="http://www.root.cz/clanky/programovaci-jazyk-clojure-16-slozitejsi-uzivatelska-makra/">http://www.root.cz/clanky/programovaci-jazyk-clojure-16-slozitejsi-uzivatelska-makra/</a>
</li>

<li>Clojure 17: Využití standardních maker v praxi<br />
<a href="http://www.root.cz/clanky/programovaci-jazyk-clojure-17-vyuziti-standardnich-maker-v-praxi/">http://www.root.cz/clanky/programovaci-jazyk-clojure-17-vyuziti-standardnich-maker-v-praxi/</a>
</li>

<li>Clojure 18: Základní techniky optimalizace aplikací<br />
<a href="http://www.root.cz/clanky/programovaci-jazyk-clojure-18-zakladni-techniky-optimalizace-aplikaci/">http://www.root.cz/clanky/programovaci-jazyk-clojure-18-zakladni-techniky-optimalizace-aplikaci/</a>
</li>

<li>Clojure 19: Vývojová prostředí pro Clojure<br />
<a href="http://www.root.cz/clanky/programovaci-jazyk-clojure-19-vyvojova-prostredi-pro-clojure/">http://www.root.cz/clanky/programovaci-jazyk-clojure-19-vyvojova-prostredi-pro-clojure/</a>
</li>

<li>Clojure 20: Vývojová prostředí pro Clojure (Vimu s REPL)<br />
<a href="http://www.root.cz/clanky/programovaci-jazyk-clojure-20-vyvojova-prostredi-pro-clojure-integrace-vimu-s-repl/">http://www.root.cz/clanky/programovaci-jazyk-clojure-20-vyvojova-prostredi-pro-clojure-integrace-vimu-s-repl/</a>
</li>

<li>Clojure 21: ClojureScript aneb překlad Clojure do JS<br />
<a href="http://www.root.cz/clanky/programovaci-jazyk-clojure-21-clojurescript-aneb-preklad-clojure-do-javascriptu/">http://www.root.cz/clanky/programovaci-jazyk-clojure-21-clojurescript-aneb-preklad-clojure-do-javascriptu/</a>
</li>

<li>Leiningen: nástroj pro správu projektů napsaných v Clojure<br />
<a href="http://www.root.cz/clanky/leiningen-nastroj-pro-spravu-projektu-napsanych-v-clojure/">http://www.root.cz/clanky/leiningen-nastroj-pro-spravu-projektu-napsanych-v-clojure/</a>
</li>

<li>Leiningen: nástroj pro správu projektů napsaných v Clojure (2)<br />
<a href="http://www.root.cz/clanky/leiningen-nastroj-pro-spravu-projektu-napsanych-v-clojure-2/">http://www.root.cz/clanky/leiningen-nastroj-pro-spravu-projektu-napsanych-v-clojure-2/</a>
</li>

<li>Leiningen: nástroj pro správu projektů napsaných v Clojure (3)<br />
<a href="http://www.root.cz/clanky/leiningen-nastroj-pro-spravu-projektu-napsanych-v-clojure-3/">http://www.root.cz/clanky/leiningen-nastroj-pro-spravu-projektu-napsanych-v-clojure-3/</a>
</li>

<li>Leiningen: nástroj pro správu projektů napsaných v Clojure (4)<br />
<a href="http://www.root.cz/clanky/leiningen-nastroj-pro-spravu-projektu-napsanych-v-clojure-4/">http://www.root.cz/clanky/leiningen-nastroj-pro-spravu-projektu-napsanych-v-clojure-4/</a>
</li>

<li>Leiningen: nástroj pro správu projektů napsaných v Clojure (5)<br />
<a href="http://www.root.cz/clanky/leiningen-nastroj-pro-spravu-projektu-napsanych-v-clojure-5/">http://www.root.cz/clanky/leiningen-nastroj-pro-spravu-projektu-napsanych-v-clojure-5/</a>
</li>

<li>Leiningen: nástroj pro správu projektů napsaných v Clojure (6)<br />
<a href="http://www.root.cz/clanky/leiningen-nastroj-pro-spravu-projektu-napsanych-v-clojure-6/">http://www.root.cz/clanky/leiningen-nastroj-pro-spravu-projektu-napsanych-v-clojure-6/</a>
</li>

<li>Programovací jazyk Clojure a databáze (1.část)<br />
<a href="http://www.root.cz/clanky/programovaci-jazyk-clojure-a-databaze-1-cast/">http://www.root.cz/clanky/programovaci-jazyk-clojure-a-databaze-1-cast/</a>
</li>

<li>Pluginy pro Leiningen<br />
<a href="http://www.root.cz/clanky/leiningen-nastroj-pro-spravu-projektu-napsanych-v-clojure-pluginy-pro-leiningen/">http://www.root.cz/clanky/leiningen-nastroj-pro-spravu-projektu-napsanych-v-clojure-pluginy-pro-leiningen/</a>
</li>

<li>Programovací jazyk Clojure a knihovny pro práci s vektory a maticemi<br />
<a href="http://www.root.cz/clanky/programovaci-jazyk-clojure-a-knihovny-pro-praci-s-vektory-a-maticemi/">http://www.root.cz/clanky/programovaci-jazyk-clojure-a-knihovny-pro-praci-s-vektory-a-maticemi/</a>
</li>

<li>Programovací jazyk Clojure a knihovny pro práci s vektory a maticemi (2)<br />
<a href="http://www.root.cz/clanky/programovaci-jazyk-clojure-a-knihovny-pro-praci-s-vektory-a-maticemi-2/">http://www.root.cz/clanky/programovaci-jazyk-clojure-a-knihovny-pro-praci-s-vektory-a-maticemi-2/</a>
</li>

<li>Programovací jazyk Clojure: syntéza procedurálních textur s využitím knihovny Clisk<br />
<a href="http://www.root.cz/clanky/programovaci-jazyk-clojure-synteza-proceduralnich-textur-s-vyuzitim-knihovny-clisk/">http://www.root.cz/clanky/programovaci-jazyk-clojure-synteza-proceduralnich-textur-s-vyuzitim-knihovny-clisk/</a>
</li>

<li>Programovací jazyk Clojure: syntéza procedurálních textur s využitím knihovny Clisk (2)<br />
<a href="http://www.root.cz/clanky/programovaci-jazyk-clojure-synteza-proceduralnich-textur-s-vyuzitim-knihovny-clisk-2/">http://www.root.cz/clanky/programovaci-jazyk-clojure-synteza-proceduralnich-textur-s-vyuzitim-knihovny-clisk-2/</a>
</li>

<li>Programovací jazyk Clojure: syntéza procedurálních textur s využitím knihovny Clisk (dokončení)<br />
<a href="http://www.root.cz/clanky/programovaci-jazyk-clojure-synteza-proceduralnich-textur-s-vyuzitim-knihovny-clisk-dokonceni/">http://www.root.cz/clanky/programovaci-jazyk-clojure-synteza-proceduralnich-textur-s-vyuzitim-knihovny-clisk-dokonceni/</a>
</li>

<li>Seesaw: knihovna pro snadnou tvorbu GUI v jazyce Clojure<br />
<a href="http://www.root.cz/clanky/seesaw-knihovna-pro-snadnou-tvorbu-gui-v-jazyce-clojure/">http://www.root.cz/clanky/seesaw-knihovna-pro-snadnou-tvorbu-gui-v-jazyce-clojure/</a>
</li>

<li>Seesaw: knihovna pro snadnou tvorbu GUI v jazyce Clojure (2)<br />
<a href="http://www.root.cz/clanky/seesaw-knihovna-pro-snadnou-tvorbu-gui-v-jazyce-clojure-2/">http://www.root.cz/clanky/seesaw-knihovna-pro-snadnou-tvorbu-gui-v-jazyce-clojure-2/</a>
</li>

<li>Seesaw: knihovna pro snadnou tvorbu GUI v jazyce Clojure (3)<br />
<a href="http://www.root.cz/clanky/seesaw-knihovna-pro-snadnou-tvorbu-gui-v-jazyce-clojure-3/">http://www.root.cz/clanky/seesaw-knihovna-pro-snadnou-tvorbu-gui-v-jazyce-clojure-3/</a>
</li>

<li>Programovací jazyk Clojure a práce s Gitem<br />
<a href="http://www.root.cz/clanky/programovaci-jazyk-clojure-a-prace-s-gitem/">http://www.root.cz/clanky/programovaci-jazyk-clojure-a-prace-s-gitem/</a>
</li>

<li>Programovací jazyk Clojure a práce s Gitem (2)<br />
<a href="http://www.root.cz/clanky/programovaci-jazyk-clojure-a-prace-s-gitem-2/">http://www.root.cz/clanky/programovaci-jazyk-clojure-a-prace-s-gitem-2/</a>
</li>

<li>Programovací jazyk Clojure – triky při práci s řetězci<br />
<a href="http://www.root.cz/clanky/programovaci-jazyk-clojure-triky-pri-praci-s-retezci/">http://www.root.cz/clanky/programovaci-jazyk-clojure-triky-pri-praci-s-retezci/</a>
</li>

<li>Programovací jazyk Clojure – triky při práci s kolekcemi<br />
<a href="http://www.root.cz/clanky/programovaci-jazyk-clojure-triky-pri-praci-s-kolekcemi/">http://www.root.cz/clanky/programovaci-jazyk-clojure-triky-pri-praci-s-kolekcemi/</a>
</li>

<li>Programovací jazyk Clojure – práce s mapami a množinami<br />
<a href="http://www.root.cz/clanky/programovaci-jazyk-clojure-prace-s-mapami-a-mnozinami/">http://www.root.cz/clanky/programovaci-jazyk-clojure-prace-s-mapami-a-mnozinami/</a>
</li>

<li>Programovací jazyk Clojure – základy zpracování XML<br />
<a href="http://www.root.cz/clanky/programovaci-jazyk-clojure-zaklady-zpracovani-xml/">http://www.root.cz/clanky/programovaci-jazyk-clojure-zaklady-zpracovani-xml/</a>
</li>

<li>Programovací jazyk Clojure – testování s využitím knihovny Expectations<br />
<a href="http://www.root.cz/clanky/programovaci-jazyk-clojure-testovani-s-vyuzitim-knihovny-expectations/">http://www.root.cz/clanky/programovaci-jazyk-clojure-testovani-s-vyuzitim-knihovny-expectations/</a>
</li>

<li>Programovací jazyk Clojure – některé užitečné triky použitelné (nejenom) v&nbsp;testech<br />
<a href="http://www.root.cz/clanky/programovaci-jazyk-clojure-nektere-uzitecne-triky-pouzitelne-nejenom-v-testech/">http://www.root.cz/clanky/programovaci-jazyk-clojure-nektere-uzitecne-triky-pouzitelne-nejenom-v-testech/</a>
</li>

<li>Enlive – výkonný šablonovací systém pro jazyk Clojure<br/>
<a href="http://www.root.cz/clanky/enlive-vykonny-sablonovaci-system-pro-jazyk-clojure/">http://www.root.cz/clanky/enlive-vykonny-sablonovaci-system-pro-jazyk-clojure/</a>
</li>

<li>Nástroj Leiningen a programovací jazyk Clojure: tvorba vlastních knihoven pro veřejný repositář Clojars<br />
<a href="http://www.root.cz/clanky/nastroj-leiningen-a-programovaci-jazyk-clojure-tvorba-vlastnich-knihoven-pro-verejny-repositar-clojars/">http://www.root.cz/clanky/nastroj-leiningen-a-programovaci-jazyk-clojure-tvorba-vlastnich-knihoven-pro-verejny-repositar-clojars/</a>
</li>

<li>Novinky v Clojure verze 1.8.0<br />
<a href="http://www.root.cz/clanky/novinky-v-clojure-verze-1-8-0/">http://www.root.cz/clanky/novinky-v-clojure-verze-1-8-0/</a>
</li>

<li>Asynchronní programování v&nbsp;Clojure s&nbsp;využitím knihovny core.async<br />
<a href="http://www.root.cz/clanky/asynchronni-programovani-v-clojure-s-vyuzitim-knihovny-core-async/">http://www.root.cz/clanky/asynchronni-programovani-v-clojure-s-vyuzitim-knihovny-core-async/</a>
</li>

<li>Asynchronní programování v&nbsp;Clojure s&nbsp;využitím knihovny core.async (pokračování)<br />
<a href="http://www.root.cz/clanky/asynchronni-programovani-v-clojure-s-vyuzitim-knihovny-core-async-pokracovani/">http://www.root.cz/clanky/asynchronni-programovani-v-clojure-s-vyuzitim-knihovny-core-async-pokracovani/</a>
</li>

<li>Asynchronní programování v Clojure s využitím knihovny core.async (dokončení)<br />
<a href="http://www.root.cz/clanky/asynchronni-programovani-v-clojure-s-vyuzitim-knihovny-core-async-dokonceni/">http://www.root.cz/clanky/asynchronni-programovani-v-clojure-s-vyuzitim-knihovny-core-async-dokonceni/</a>
</li>

<li>Vytváříme IRC bota v programovacím jazyce Clojure<br />
<a href="http://www.root.cz/clanky/vytvarime-irc-bota-v-programovacim-jazyce-clojure/">http://www.root.cz/clanky/vytvarime-irc-bota-v-programovacim-jazyce-clojure/</a>
</li>

<li>Gorilla REPL: interaktivní prostředí pro programovací jazyk Clojure<br />
<a href="https://www.root.cz/clanky/gorilla-repl-interaktivni-prostredi-pro-programovaci-jazyk-clojure/">https://www.root.cz/clanky/gorilla-repl-interaktivni-prostredi-pro-programovaci-jazyk-clojure/</a>
</li>

</ol>



<p><a name="k14"></a></p>
<h2 id="k14">14. Odkazy na Internetu</h2>

<ol>

<li>Runtime Polymorphism<br />
<a href="http://www.clojure.org/about/runtime_polymorphism">http://www.clojure.org/about/runtime_polymorphism</a>
</li>

<li>Multiple dispatch<br />
<a href="https://en.wikipedia.org/wiki/Multiple_dispatch">https://en.wikipedia.org/wiki/Multiple_dispatch</a>
</li>

<li>Dynamic dispatch<br />
<a href="https://en.wikipedia.org/wiki/Dynamic_dispatch#Single_and_multiple_dispatch">https://en.wikipedia.org/wiki/Dynamic_dispatch#Single_and_multiple_dispatch</a>
</li>

<li>Dynamický výběr<br />
<a href="https://cs.wikipedia.org/wiki/Dynamick%C3%BD_v%C3%BDb%C4%9Br">https://cs.wikipedia.org/wiki/Dynamick%C3%BD_v%C3%BDb%C4%9Br</a>
</li>

<li>Back to the Future: Lisp as a Base for a Statistical Computing System<br />
<a href="https://www.stat.auckland.ac.nz/~ihaka/downloads/Compstat-2008.pdf">https://www.stat.auckland.ac.nz/~ihaka/downloads/Compstat-2008.pdf</a>
</li>

<li>gg4clj: a simple wrapper for using R's ggplot2 in Clojure and Gorilla REPL<br />
<a href="https://github.com/JonyEpsilon/gg4clj">https://github.com/JonyEpsilon/gg4clj</a>
</li>

<li>Analemma: a Clojure-based SVG DSL and charting library<br />
<a href="http://liebke.github.io/analemma/">http://liebke.github.io/analemma/</a>
</li>

<li>Clojupyter: a Jupyter kernel for Clojure<br />
<a href="https://github.com/roryk/clojupyter">https://github.com/roryk/clojupyter</a>
</li>

<li>Communicating sequential processes<br />
<a href="https://en.wikipedia.org/wiki/Communicating_sequential_processes">https://en.wikipedia.org/wiki/Communicating_sequential_processes</a>
</li>

<li>The IPython Notebook<br />
<a href="http://ipython.org/notebook.html">http://ipython.org/notebook.html</a>
</li>

<li>Jypyter: open source, interactive data science and scientific computing across over 40 programming languages<br />
<a href="https://jupyter.org/">https://jupyter.org/</a>
</li>

<li>nbviewer: a simple way to share Jupyter Notebooks<br />
<a href="https://nbviewer.jupyter.org/">https://nbviewer.jupyter.org/</a>
</li>

<li>Clojure core.async<br />
<a href="http://www.infoq.com/presentations/clojure-core-async">http://www.infoq.com/presentations/clojure-core-async</a>
</li>

<li>core.async API Reference<br />
<a href="https://clojure.github.io/core.async/">https://clojure.github.io/core.async/</a>
</li>

<li>Clojure core.async Channels<br />
<a href="http://clojure.com/blog/2013/06/28/clojure-core-async-channels.html">http://clojure.com/blog/2013/06/28/clojure-core-async-channels.html</a>
</li>

<li>core.async examples<br />
<a href="https://github.com/clojure/core.async/blob/master/examples/walkthrough.clj">https://github.com/clojure/core.async/blob/master/examples/walkthrough.clj</a>
</li>

<li>Timothy Baldridge - Core.Async<br />
<a href="https://www.youtube.com/watch?v=enwIIGzhahw">https://www.youtube.com/watch?v=enwIIGzhahw</a>
</li>

<li>Designing Front End Applications with core.async<br />
<a href="http://go.cognitect.com/core_async_webinar_recording">http://go.cognitect.com/core_async_webinar_recording</a>
</li>

<li>Mastering Concurrent Processes with core.async<br />
<a href="http://www.braveclojure.com/core-async/">http://www.braveclojure.com/core-async/</a>
</li>

<li>LispCast: Clojure core.async<br />
<a href="https://www.youtube.com/watch?v=msv8Fvtd6YQ">https://www.youtube.com/watch?v=msv8Fvtd6YQ</a>
</li>

<li>Julian Gamble - Applying the paradigms of core.async in ClojureScript<br />
<a href="https://www.youtube.com/watch?v=JUrOebC5HmA">https://www.youtube.com/watch?v=JUrOebC5HmA</a>
</li>

<li>Zip archiv s&nbsp;Clojure 1.8.0<br />
<a href="http://repo1.maven.org/maven2/org/clojure/clojure/1.8.0/clojure-1.8.0.zip">http://repo1.maven.org/maven2/org/clojure/clojure/1.8.0/clojure-1.8.0.zip</a>
</li>

<li>Clojure 1.8 is now available<br />
<a href="http://clojure.org/news/2016/01/19/clojure18">http://clojure.org/news/2016/01/19/clojure18</a>
</li>

<li>Changes to Clojure in Version 1.8<br />
<a href="https://github.com/clojure/clojure/blob/master/changes.md">https://github.com/clojure/clojure/blob/master/changes.md</a>
</li>

<li>Socket Server REPL<br />
<a href="http://dev.clojure.org/display/design/Socket+Server+REPL">http://dev.clojure.org/display/design/Socket+Server+REPL</a>
</li>

<li>CLJ-1671: Clojure socket server<br />
<a href="http://dev.clojure.org/jira/browse/CLJ-1671">http://dev.clojure.org/jira/browse/CLJ-1671</a>
</li>

<li>CLJ-1449: Add clojure.string functions for portability to ClojureScript<br />
<a href="http://dev.clojure.org/jira/browse/CLJ-1449">http://dev.clojure.org/jira/browse/CLJ-1449</a>
</li>

<li>Launching a Socket Server<br />
<a href="http://clojure.org/reference/repl_and_main#_launching_a_socket_server">http://clojure.org/reference/repl_and_main#_launching_a_socket_server</a>
</li>

<li>API for clojure.string<br />
<a href="http://clojure.github.io/clojure/branch-master/clojure.string-api.html">http://clojure.github.io/clojure/branch-master/clojure.string-api.html</a>
</li>

<li>Clojars:<br />
<a href="https://clojars.org/">https://clojars.org/</a>
</li>

<li>Seznam knihoven na Clojars:<br />
<a href="https://clojars.org/projects">https://clojars.org/projects</a>
</li>

<li>Clojure Cookbook: Templating HTML with Enlive<br />
<a href="https://github.com/clojure-cookbook/clojure-cookbook/blob/master/07_webapps/7-11_enlive.asciidoc">https://github.com/clojure-cookbook/clojure-cookbook/blob/master/07_webapps/7-11_enlive.asciidoc</a>
</li>

<li>An Introduction to Enlive<br />
<a href="https://github.com/swannodette/enlive-tutorial/">https://github.com/swannodette/enlive-tutorial/</a>
</li>

<li>Enlive na GitHubu<br />
<a href="https://github.com/cgrand/enlive">https://github.com/cgrand/enlive</a>
</li>

<li>Expectations: příklady atd.<br />
<a href="http://jayfields.com/expectations/">http://jayfields.com/expectations/</a>
</li>

<li>Expectations na GitHubu<br />
<a href="https://github.com/jaycfields/expectations">https://github.com/jaycfields/expectations</a>
</li>

<li>Lein-expectations na GitHubu<br />
<a href="https://github.com/gar3thjon3s/lein-expectations">https://github.com/gar3thjon3s/lein-expectations</a>
</li>

<li>Testing Clojure With Expectations<br />
<a href="https://semaphoreci.com/blog/2014/09/23/testing-clojure-with-expectations.html">https://semaphoreci.com/blog/2014/09/23/testing-clojure-with-expectations.html</a>
</li>

<li>Clojure testing TDD/BDD libraries: clojure.test vs Midje vs Expectations vs Speclj<br />
<a href="https://www.reddit.com/r/Clojure/comments/1viilt/clojure_testing_tddbdd_libraries_clojuretest_vs/">https://www.reddit.com/r/Clojure/comments/1viilt/clojure_testing_tddbdd_libraries_clojuretest_vs/</a>
</li>

<li>Testing: One assertion per test<br />
<a href="http://blog.jayfields.com/2007/06/testing-one-assertion-per-test.html">http://blog.jayfields.com/2007/06/testing-one-assertion-per-test.html</a>
</li>

<li>Rewriting Your Test Suite in Clojure in 24 hours<br />
<a href="http://blog.circleci.com/rewriting-your-test-suite-in-clojure-in-24-hours/">http://blog.circleci.com/rewriting-your-test-suite-in-clojure-in-24-hours/</a>
</li>

<li>Clojure doc: zipper<br />
<a href="http://clojuredocs.org/clojure.zip/zipper">http://clojuredocs.org/clojure.zip/zipper</a>
</li>

<li>Clojure doc: parse<br />
<a href="http://clojuredocs.org/clojure.xml/parse">http://clojuredocs.org/clojure.xml/parse</a>
</li>

<li>Clojure doc: xml-zip<br />
<a href="http://clojuredocs.org/clojure.zip/xml-zip">http://clojuredocs.org/clojure.zip/xml-zip</a>
</li>

<li>Clojure doc: xml-seq<br />
<a href="http://clojuredocs.org/clojure.core/xml-seq">http://clojuredocs.org/clojure.core/xml-seq</a>
</li>

<li>Parsing XML in Clojure<br />
<a href="https://github.com/clojuredocs/guides">https://github.com/clojuredocs/guides</a>
</li>

<li>Clojure Zipper Over Nested Vector<br />
<a href="https://vitalyper.wordpress.com/2010/11/23/clojure-zipper-over-nested-vector/">https://vitalyper.wordpress.com/2010/11/23/clojure-zipper-over-nested-vector/</a>
</li>

<li>Understanding Clojure's PersistentVector implementation<br />
<a href="http://blog.higher-order.net/2009/02/01/understanding-clojures-persistentvector-implementation">http://blog.higher-order.net/2009/02/01/understanding-clojures-persistentvector-implementation</a>
</li>

<li>Understanding Clojure's PersistentHashMap (deftwice...)<br />
<a href="http://blog.higher-order.net/2009/09/08/understanding-clojures-persistenthashmap-deftwice.html">http://blog.higher-order.net/2009/09/08/understanding-clojures-persistenthashmap-deftwice.html</a>
</li>

<li>Assoc and Clojure's PersistentHashMap: part ii<br />
<a href="http://blog.higher-order.net/2010/08/16/assoc-and-clojures-persistenthashmap-part-ii.html">http://blog.higher-order.net/2010/08/16/assoc-and-clojures-persistenthashmap-part-ii.html</a>
</li>

<li>Ideal Hashtrees (paper)<br />
<a href="http://lampwww.epfl.ch/papers/idealhashtrees.pdf">http://lampwww.epfl.ch/papers/idealhashtrees.pdf</a>
</li>

<li>Clojure home page<br />
<a href="http://clojure.org/">http://clojure.org/</a>
</li>

<li>Clojure (downloads)<br />
<a href="http://clojure.org/downloads">http://clojure.org/downloads</a>
</li>

<li>Clojure Sequences<br />
<a href="http://clojure.org/sequences">http://clojure.org/sequences</a>
</li>

<li>Clojure Data Structures<br />
<a href="http://clojure.org/data_structures">http://clojure.org/data_structures</a>
</li>

<li>The Structure and Interpretation of Computer Programs: 2.2.1  Representing Sequences<br />
<a href="http://mitpress.mit.edu/sicp/full-text/book/book-Z-H-15.html#%_sec_2.2.1">http://mitpress.mit.edu/sicp/full-text/book/book-Z-H-15.html#%_sec_2.2.1</a>
</li>

<li>The Structure and Interpretation of Computer Programs: 3.3.1  Mutable List Structure<br />
<a href="http://mitpress.mit.edu/sicp/full-text/book/book-Z-H-22.html#%_sec_3.3.1">http://mitpress.mit.edu/sicp/full-text/book/book-Z-H-22.html#%_sec_3.3.1</a>
</li>

<li>Clojure - Functional Programming for the JVM<br />
<a href="http://java.ociweb.com/mark/clojure/article.html">http://java.ociweb.com/mark/clojure/article.html</a>
</li>

<li>Clojure quick reference<br />
<a href="http://faustus.webatu.com/clj-quick-ref.html">http://faustus.webatu.com/clj-quick-ref.html</a>
</li>

<li>4Clojure<br />
<a href="http://www.4clojure.com/">http://www.4clojure.com/</a>
</li>

<li>ClojureDoc (rozcestník s&nbsp;dokumentací jazyka Clojure)<br />
<a href="http://clojuredocs.org/">http://clojuredocs.org/</a>
</li>

<li>Clojure (na Wikipedia EN)<br />
<a href="http://en.wikipedia.org/wiki/Clojure">http://en.wikipedia.org/wiki/Clojure</a>
</li>

<li>Clojure (na Wikipedia CS)<br />
<a href="http://cs.wikipedia.org/wiki/Clojure">http://cs.wikipedia.org/wiki/Clojure</a>
</li>

<li>SICP (The Structure and Interpretation of Computer Programs)<br />
<a href="http://mitpress.mit.edu/sicp/">http://mitpress.mit.edu/sicp/</a>
</li>

<li>Pure function<br />
<a href="http://en.wikipedia.org/wiki/Pure_function">http://en.wikipedia.org/wiki/Pure_function</a>
</li>

<li>Funkcionální programování<br />
<a href="http://cs.wikipedia.org/wiki/Funkcionální_programování">http://cs.wikipedia.org/wiki/Funkcionální_programování</a>
</li>

<li>Čistě funkcionální (datové struktury, jazyky, programování)<br />
<a href="http://cs.wikipedia.org/wiki/Čistě_funkcionální">http://cs.wikipedia.org/wiki/Čistě_funkcionální</a>
</li>

<li>Clojure Macro Tutorial (Part I, Getting the Compiler to Write Your Code For You)<br />
<a href="http://www.learningclojure.com/2010/09/clojure-macro-tutorial-part-i-getting.html">http://www.learningclojure.com/2010/09/clojure-macro-tutorial-part-i-getting.html</a>
</li>

<li>Clojure Macro Tutorial (Part II: The Compiler Strikes Back)<br />
<a href="http://www.learningclojure.com/2010/09/clojure-macro-tutorial-part-ii-compiler.html">http://www.learningclojure.com/2010/09/clojure-macro-tutorial-part-ii-compiler.html</a>
</li>

<li>Clojure Macro Tutorial (Part III: Syntax Quote)<br />
<a href="http://www.learningclojure.com/2010/09/clojure-macro-tutorial-part-ii-syntax.html">http://www.learningclojure.com/2010/09/clojure-macro-tutorial-part-ii-syntax.html</a>
</li>

<li>Tech behind Tech: Clojure Macros Simplified<br />
<a href="http://techbehindtech.com/2010/09/28/clojure-macros-simplified/">http://techbehindtech.com/2010/09/28/clojure-macros-simplified/</a>
</li>

<li>Fatvat - Exploring functional programming: Clojure Macros<br />
<a href="http://www.fatvat.co.uk/2009/02/clojure-macros.html">http://www.fatvat.co.uk/2009/02/clojure-macros.html</a>
</li>

<li>List comprehension<br />
<a href="http://en.wikipedia.org/wiki/List_comprehension">http://en.wikipedia.org/wiki/List_comprehension</a>
</li>

<li>List Comprehensions in Clojure<br />
<a href="http://asymmetrical-view.com/2008/11/18/list-comprehensions-in-clojure.html">http://asymmetrical-view.com/2008/11/18/list-comprehensions-in-clojure.html</a>
</li>

<li>Clojure Programming Concepts: List Comprehension<br />
<a href="http://en.wikibooks.org/wiki/Clojure_Programming/Concepts#List_Comprehension">http://en.wikibooks.org/wiki/Clojure_Programming/Concepts#List_Comprehension</a>
</li>

<li>Clojure core API: for macro<br />
<a href="http://clojure.github.com/clojure/clojure.core-api.html#clojure.core/for">http://clojure.github.com/clojure/clojure.core-api.html#clojure.core/for</a>
</li>

<li>cirrus machina - The Clojure for macro<br />
<a href="http://www.cirrusmachina.com/blog/comment/the-clojure-for-macro/">http://www.cirrusmachina.com/blog/comment/the-clojure-for-macro/</a>
</li>

<li>Riastradh's Lisp Style Rules<br />
<a href="http://mumble.net/~campbell/scheme/style.txt">http://mumble.net/~campbell/scheme/style.txt</a>
</li>

<li>Dynamic Languages Strike Back<br />
<a href="http://steve-yegge.blogspot.cz/2008/05/dynamic-languages-strike-back.html">http://steve-yegge.blogspot.cz/2008/05/dynamic-languages-strike-back.html</a>
</li>

<li>Scripting: Higher Level Programming for the 21st Century<br />
<a href="http://www.tcl.tk/doc/scripting.html">http://www.tcl.tk/doc/scripting.html</a>
</li>

<li>Java Virtual Machine Support for Non-Java Languages<br />
<a href="http://docs.oracle.com/javase/7/docs/technotes/guides/vm/multiple-language-support.html">http://docs.oracle.com/javase/7/docs/technotes/guides/vm/multiple-language-support.html</a>
</li>

<li>Threading macro (dokumentace k&nbsp;jazyku Clojure)<br />
<a href="https://clojure.github.io/clojure/clojure.core-api.html#clojure.core/-&gt;">https://clojure.github.io/clojure/clojure.core-api.html#clojure.core/-&gt;</a>
</li>

<li>Understanding the Clojure -&gt; macro<br />
<a href="http://blog.fogus.me/2009/09/04/understanding-the-clojure-macro/">http://blog.fogus.me/2009/09/04/understanding-the-clojure-macro/</a>
</li>

<li>clojure.inspector<br />
<a href="http://clojure.github.io/clojure/clojure.inspector-api.html">http://clojure.github.io/clojure/clojure.inspector-api.html</a>
</li>

<li>The Clojure Toolbox<br />
<a href="http://www.clojure-toolbox.com/">http://www.clojure-toolbox.com/</a>
</li>

<li>Unit Testing in Clojure<br />
<a href="http://nakkaya.com/2009/11/18/unit-testing-in-clojure/">http://nakkaya.com/2009/11/18/unit-testing-in-clojure/</a>
</li>

<li>Testing in Clojure (Part-1: Unit testing)<br />
<a href="http://blog.knoldus.com/2014/03/22/testing-in-clojure-part-1-unit-testing/">http://blog.knoldus.com/2014/03/22/testing-in-clojure-part-1-unit-testing/</a>
</li>

<li>API for clojure.test - Clojure v1.6 (stable)<br />
<a href="https://clojure.github.io/clojure/clojure.test-api.html">https://clojure.github.io/clojure/clojure.test-api.html</a>
</li>

<li>Leiningen: úvodní stránka<br />
<a href="http://leiningen.org/">http://leiningen.org/</a>
</li>

<li>Leiningen: Git repository<br />
<a href="https://github.com/technomancy/leiningen">https://github.com/technomancy/leiningen</a>
</li>

<li>leiningen-win-installer<br />
<a href="http://leiningen-win-installer.djpowell.net/">http://leiningen-win-installer.djpowell.net/</a>
</li>

<li>Clojure.org: Vars and the Global Environment<br />
<a href="http://clojure.org/Vars">http://clojure.org/Vars</a>
</li>

<li>Clojure.org: Refs and Transactions<br />
<a href="http://clojure.org/Refs">http://clojure.org/Refs</a>
</li>

<li>Clojure.org: Atoms<br />
<a href="http://clojure.org/Atoms">http://clojure.org/Atoms</a>
</li>

<li>Clojure.org: Agents as Asynchronous Actions<br />
<a href="http://clojure.org/agents">http://clojure.org/agents</a>
</li>

<li>Transient Data Structures
<a href="http://clojure.org/transients">http://clojure.org/transients</a>
</li>

</ol>



<p></p><p></p>
<p><small>Autor: <a href="http://www.fit.vutbr.cz/~tisnovpa">Pavel Tišnovský</a> &nbsp; 2016</small></p>
</body>
</html>

