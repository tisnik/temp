<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
        "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html>
<head>
<title>Projekt Mori aneb perzistentní datové struktury pro JavaScript</title>
<meta name="Author" content="Pavel Tisnovsky" />
<meta name="Generator" content="vim" />
<meta http-equiv="content-type" content="text/html; charset=utf-8" />
<style type="text/css">
         body {color:#000000; background:#ffffff;}
         h1  {font-family: arial, helvetica, sans-serif; color:#ffffff; background-color:#c00000; text-align:center; padding-left:1em}
         h2  {font-family: arial, helvetica, sans-serif; color:#ffffff; background-color:#0000c0; padding-left:1em; text-align:left}
         h3  {font-family: arial, helvetica, sans-serif; color:#000000; background-color:#c0c0c0; padding-left:1em; text-align:left}
         h4  {font-family: arial, helvetica, sans-serif; color:#000000; background-color:#e0e0e0; padding-left:1em; text-align:left}
         a   {font-family: arial, helvetica, sans-serif;}
         li  {font-family: arial, helvetica, sans-serif; color:#000000; text-align:justify; width:450px;}
         ol  {font-family: arial, helvetica, sans-serif; color:#000000; text-align:justify; width:450px;}
         ul  {font-family: arial, helvetica, sans-serif; color:#000000; text-align:justify; width:450px;}
         p   {font-family: arial, helvetica, sans-serif; color:#000000; text-align:justify;}
         pre {background:#e0e0e0}
</style>
</head>

<body>

<h1>Projekt Mori aneb perzistentní datové struktury pro JavaScript</h1>

<h3>Pavel Tišnovský</h3>

<p></p>

<h1>Úvodník</h1>

<p>JavaScript se v posledních letech stal platformou, nad níž se staví další programovací jazyky, například jazyky se striktním typováním či jazyky funkcionální. Pro JavaScript dokonce vzniklo i několik knihoven, které do něj přidávají perzistentní (neměnné) datové struktury. Jednou z těchto knihoven je i knihovna Mori, kterou si dnes popíšeme.</p>



<h2>Obsah</h2>

<p><a href="#k01">1. Projekt Mori aneb perzistentní datové struktury pro JavaScript</a></p>
<p><a href="#k02">2. Základní vlastnosti datových struktur v&nbsp;knihovně Mori</a></p>
<p><a href="#k03">3. Neměnnost (immutability) datových struktur</a></p>
<p><a href="#k04">4. Perzistence datových struktur</a></p>
<p><a href="#k05">5. První demonstrační příklad: použití knihovny Mory na webové stránce</a></p>
<p><a href="#k06">6. Seznamy a vektory</a></p>
<p><a href="#k07">7. Druhý demonstrační příklad: použití seznamů a vektorů</a></p>
<p><a href="#k08">8. Sekvence a lazy sekvence</a></p>
<p><a href="#k09">9. Základní funkce pro práci se sekvencemi</a></p>
<p><a href="#k10">10. Třetí demonstrační příklad: použití funkcí <strong>first</strong> a <strong>rest</strong></a></p>
<p><a href="#k11">11. Funkce <strong>range</strong>, <strong>take</strong> a <strong>map</strong></a></p>
<p><a href="#k12">12. Čtvrtý demonstrační příklad: použití funkcí <strong>range</strong>, <strong>take</strong> a <strong>map</strong></a></p>
<p><a href="#k13">13. Repositář se zdrojovými kódy všech dnešních demonstračních příkladů</a></p>
<p><a href="#k14">14. Odkazy na Internetu</a></p>



<p><a name="k01"></a></p>
<h2 id="k01">1. Projekt Mori aneb perzistentní datové struktury pro JavaScript</h2>

<p>V&nbsp;několika posledních letech se vývojáři používající programovací jazyk
<i>JavaScript</i> mohli setkat se dvěma zajímavými fenomény. Prvním fenoménem
je postupné rozšiřování použití tohoto (nutno říci, že mnohdy neprávem
podceňovaného) jazyka z&nbsp;webových browserů i do dalších aplikačních
oblastí, zejména na servery a taktéž, i když v&nbsp;poněkud menší míře, na
desktopy. Využití JavaScriptu na serverech sice ve skutečnosti není žádný nový
či přelomový objev, protože podobnou funkci již kdysi dávno (konkrétně od roku
1994) nabízel komerční webový server nazvaný <i>Netscape Enterprise Server</i>
(jednalo se o technologii pojmenovanou Server-Side JavaScript aneb SSJS), ovšem
teprve s&nbsp;rozvojem známého a populárního projektu <i>Node.js</i> je možné
mluvit o masivní adaptaci JavaScriptu i na serverech.</p>

<p>Na desktopu se JavaScript používá například v&nbsp;desktopovém prostředí
GNOME (<a href="https://wiki.gnome.org/action/show/Projects/Gjs">Gjs</a>) či ve
<a
href="https://www.zdrojak.cz/serialy/aplikace-pro-windows-store-v-html5/">Windows
Store</a>, zajímavé je ovšem i jeho využití například <a
href="http://www.root.cz/clanky/atom-moderni-textovy-editor/">v&nbsp;textovém
editoru Atom</a> (který je vnitřně rozdělen na klientskou a serverovou část,
zjednodušeně lze říci, že klientská část je kombinací JavaScriptu a browseru).
Navíc se objevují i &bdquo;šílenosti&ldquo; typu <a
href="http://os.js.org/">OS.js</a>, které ukazují možnosti tohoto jazyka i
vyspělost jeho interpretrů.</p>

<p>Druhým fenoménem, s&nbsp;nímž se již mohlo setkat poměrně velké množství
vývojářů, je vznik mnoha rozmanitých <i>transpřekladačů (transcompilers,
source-to-source compilers)</i>, jejichž cílovým jazykem je právě JavaScript.
Připomeňme si, že transpřekladače jsou nástroje sloužící pro překlad algoritmů
zapsaných v&nbsp;nějakém zdrojovém programovacím jazyce do zvoleného cílového
jazyka (ovšem nikoli do nativního kódu či do bajtkódu, protože to už je role
běžných překladačů). V&nbsp;současnosti existuje již poměrně velké množství
transpřekladačů do JavaScriptu, nejpopulárnější jsou pak transpřekladače pro
jazyky <i>CoffeeScript</i>, <i>ClojureScript</i>, <i>TypeScript</i>,
<i>Dart</i> a <i>Haxe</i>. Nesmíme ovšem zapomenout ani na jazyk <i>Wisp</i>,
s&nbsp;nímž jsme se již na stránkách Roota potkali [<a
href="http://www.root.cz/clanky/propojeni-sveta-lispu-se-svetem-javascriptu-s-vyuzitim-transprekladace-wisp/">1</a>]
[<a
href="http://www.root.cz/clanky/propojeni-sveta-lispu-se-svetem-javascriptu-s-vyuzitim-transprekladace-wisp-2-cast/">2</a>].</p>

<p>A právě v&nbsp;souvislosti s&nbsp;<i>CoffeeScriptem</i>,
<i>ClojureScriptem</i> a v&nbsp;neposlední řadě i <i>Wispem</i> se setkáme
s&nbsp;potřebou použití perzistentních (neměnných) datových struktur. Jednou
z&nbsp;knihoven, která perzistentní datové struktury programátorům používajícím
(nejenom) JavaScript nabízí, je knihovna <i>Mori</i>.</p>



<p><a name="k02"></a></p>
<h2 id="k02">2. Základní vlastnosti datových struktur v&nbsp;knihovně Mori</h2>

<p>Interně je knihovna <i>Mori</i> naprogramována poměrně neobvyklým způsobem,
protože všechny perzistentní datové struktury, které jsou v&nbsp;ní
implementovány, ve skutečnosti pochází z&nbsp;<i>ClojureScriptu</i>, jehož
starší verzi jsme si již <a
href="http://www.root.cz/clanky/programovaci-jazyk-clojure-21-clojurescript-aneb-preklad-clojure-do-javascriptu/">na
stránkách Rootu popsali</a> (nastal již ovšem ten pravý čas si někdy představit
i novou verzi tohoto jazyka). Knihovna <i>Mori</i> tedy umožňuje, aby i
programátoři používající &bdquo;pouhý&ldquo; JavaScript (či TypeScript
popř.&nbsp;CoffeeScript) měli přístup k&nbsp;optimalizovaným algoritmům
vyvinutých v&nbsp;rámci projektu <i>ClojureScript</i>, aniž by se přitom bylo
nutné učit odlišný přístup k&nbsp;tvorbě programů, který je
v&nbsp;<i>Clojure</i> a <i>ClojureScriptu</i> vyžadován. Nicméně se vraťme
k&nbsp;již zmíněným perzistentním datovým strukturám, které jsou
v&nbsp;knihovně <i>Mori</i> uživatelům dostupné. Jedná se o neměnné seznamy
(list), vektory (vector), množiny (set), mapy (map) a taktéž fronty
(queue):</p>

<table>
<tr><th>#</th><th>Datová struktura</th><th>Konstruktor</th><th>Alt. implementace</th></tr>
<tr><td>1</td><td>seznam </td><td>mori.list(prvky)</td><td>&times;</td></tr>
<tr><td>2</td><td>vektor </td><td>mori.vector(prvky)</td><td>&times;</td></tr>
<tr><td>3</td><td>množina</td><td>mori.set(prvky)</td><td>mori.sortedSet(prvky)</td></tr>
<tr><td>4</td><td>mapa   </td><td>mori.hashMap(klíče+hodnoty)</td><td>mori.sorted_map(klíče+hodnoty)</td></tr>
<tr><td>5</td><td>fronta </td><td>mori.queue(prvky)</td><td>&times;</td></tr>
</table>

<p>Povšimněte si, že mapy a množiny mohou být implementovány dvěma odlišnými
způsoby, v&nbsp;závislosti na tom, zda mají být jejich prvky setříděny či
nikoli.</p>



<p><a name="k03"></a></p>
<h2 id="k03">3. Neměnnost (immutability) datových struktur</h2>

<p>Všech pět typů datových struktur (seznamů, vektorů, množin, map a front) má
několik důležitých společných vlastností. Základní vlastností společnou všem
pěti typům datových struktur je jejich <i>neměnnost (immutability)</i>. To
znamená, že již ve chvíli, kdy je některá datová struktura vytvořena, je po
celou další dobu její existence v&nbsp;běžícím programu určen její obsah,
tj.&nbsp;hodnoty všech prvků struktury. Na první pohled to sice možná může
vypadat zvláštně, ale i s&nbsp;takto se chovajícími strukturami je možné
v&nbsp;reálným programech pracovat a to dokonce velmi efektivním způsobem
(navíc se i zjednodušuje testování aplikace). Ostatně i v&nbsp;samotném
JavaScriptu jsou některé hodnoty a objekty neměnné. Pravděpodobně
nejviditelnějším příkladem jsou řetězce a samozřejmě taktéž všechny hodnoty
primitivního datového typu (číslo, pravdivostní hodnota, ...).</p>



<p><a name="k04"></a></p>
<h2 id="k04">4. Perzistence datových struktur</h2>

<p>Kromě neměnnosti (<i>immutability</i>) je další společnou vlastností všech
čtyř typů kolekcí jejich <i>persistence</i>. Většina standardních funkcí
poskytovaných knihovnou <i>Mori</i> se totiž snaží o to, aby jednou vytvořené
sekvence (dejme tomu pro jednoduchost seznam) mohly být znovupoužity i
v&nbsp;případě, že je vytvořen nový seznam, který v&nbsp;sobě obsahuje i seznam
starší. Ten stále existuje a mohou na něj existovat reference používané
například i v&nbsp;jiných paralelně běžících workerech či ve vláknech (pokud
interpret JavaScriptu podporuje tvorbu většího množství vláken).</p>

<p>Vzhledem k&nbsp;tomu, že se obsah starého seznamu nemůže změnit (seznam je
neměnitelný), může například funkce <strong>conj</strong> (což je obdoba funkce
<strong>cons</strong> známé již z&nbsp;<i>LISPu</i>) jednoduše k&nbsp;seznamu
přidat nový první prvek (<i>head</i>) s&nbsp;tím, že tento prvek ukazuje na
původní seznam &ndash; jinými slovy není nutné, alespoň v&nbsp;tomto případě,
vytvářet kopii (ať již plytkou či hlubokou) původního seznamu, což přispívá
k&nbsp;tomu, že mnohé operace nad kolekcemi jsou ve skutečnosti velmi rychlé, i
když by se podle jejich popisu mohlo zdát, že jejich implementace vyžaduje
provedení časově složitých operací. Je pouze důležité si zvolit správnou
datovou strukturu, což se v&nbsp;praxi týká rozhodování mezi použitím seznamů,
vektorů či front.</p>



<p><a name="k05"></a></p>
<h2 id="k05">5. První demonstrační příklad: použití knihovny Mory na webové stránce</h2>

<p>Všechny datové struktury poskytované knihovnou <i>Mori</i> jsou
implementovány formou objektů, tj.&nbsp;nelze s&nbsp;nimi zacházet jako
s&nbsp;polem atd. &ndash; veškeré manipulace se provádí přes k&nbsp;tomu určené
funkce. Ovšem <i>Mori</i> umožňuje převádět &bdquo;své&ldquo; datové struktury
na struktury zpracovávané JavaScriptem, což může být velmi užitečné ve chvíli,
kdy se tato knihovna začíná používat v&nbsp;již rozpracovaném projektu.
V&nbsp;dnešním <a
href="https://github.com/tisnik/presentations/blob/master/mori/mori_01.js">prvním
demonstračním příkladu</a> je ukázáno, jak se vytvoří perzistentní seznam
s&nbsp;využitím konstruktoru <strong>mori.list()</strong>, jak se následně
zjistí počet prvků tohoto seznamu a taktéž způsob převodu perzistentního
seznamu pomocí funkce <strong>mori.toJs()</strong> na běžné JavaScriptové
pole:</p>

<pre>
<i>// ------------------------------------------------------------</i>
<i>// Knihovna Mori: demonstrační příklad číslo 1</i>
<i>// ------------------------------------------------------------</i>
&nbsp;
<i>// vytvoření perzistentního seznamu</i>
var moriList = mori.list(1,2,3);
&nbsp;
<i>// výpočet délky perzistentního seznamu</i>
var listSize = mori.count(moriList);
&nbsp;
<i>// převod perzistentního seznamu na "normální" JavaScriptové pole</i>
var jsList = mori.toJs(moriList);
&nbsp;
<i>// výpis základních informaci o perzistentním seznamu i o jeho</i>
<i>// JavaScriptové variantě</i>
console.log("List size: " + listSize);
console.log("List to JavaScript: " + jsList);
&nbsp;
&nbsp;
&nbsp;
<i>// ------------------------------------------------------------</i>
<i>// Výpis typu objektu moriList a jsList - první varianta</i>
<i>// ------------------------------------------------------------</i>
console.log("Using typeof:");
<i>// operátor typeof nám moc nepomůže v případě objektových typu</i>
console.log("jsList type:   " + typeof jsList);
console.log("moriList type: " + typeof moriList);
&nbsp;
&nbsp;
&nbsp;
<i>// ------------------------------------------------------------</i>
<i>// Výpis typu objektu moriList a jsList - druha varianta</i>
<i>// ------------------------------------------------------------</i>
console.log("Using Object.toString():");
<i>// získáme referenci na toString a uložíme do proměnné toClass</i>
var toClass = {}.toString
&nbsp;
<i>// Výpis informace o typech objektu</i>
console.log("jsList type:   " + toClass.call(jsList));
console.log("moriList type: " + toClass.call(moriList));
&nbsp;
&nbsp;
&nbsp;
<i>// ------------------------------------------------------------</i>
<i>// Finito</i>
<i>// ------------------------------------------------------------</i>
</pre>

<a href="http://www.root.cz/obrazek/233557/"><img src="http://i.iinfo.cz/images/230/mori01-prev.png" class="image-233557" alt="&#160;" height="219" width="370" /></a>
<p><i>Obrázek 1: Výpis na konzoli zachycený ve Firebugu.</i></p>

<p>Příklad je napsán takovým způsobem, aby ho bylo možné použít na webové
stránce; konzolový výstup bude čitelný například přes <i>Firebug</i> ve
<i>Firefoxu</i> popř.&nbsp;s&nbsp;využitím nástroje <i>Inspect Page</i>
v&nbsp;prohlížeči <i>Midori</i> (ovšem i další webové prohlížeče používají
podobné ladicí nástroje). Samotná <a
href="https://github.com/tisnik/presentations/blob/master/mori/mori_01.html">webová
stránka</a> je pojata skutečně minimalisticky, protože vyžaduje pouze načtení
dvou skriptů &ndash; samotné knihovny <i>Mori</i> a zdrojového kódu prvního
demonstračního příkladu.  Zdrojový kód <strong>mori.js</strong> získáte
instalací knihovny příkazem <strong>npm install mori</strong> (soubor bude
umístěn v&nbsp;adresáři ~/node_modules/mori), zdrojový kód uložený
v&nbsp;souboru <strong>mori_01.js</strong> byl vypsán před tímto odstavcem:</p>

<pre>
&lt;!doctype html&gt;
&lt;html&gt;
    &lt;head&gt;
        &lt;title&gt;Mori tests #01&lt;/title&gt;
        &lt;meta charset="utf-8"&gt;
        &lt;script src="mori.js"&gt;&lt;/script&gt;
        &lt;script src="mori_01.js"&gt;&lt;/script&gt;
    &lt;/head&gt;
    &lt;body&gt;
        &lt;h1&gt;Mori tests #01&lt;/h1&gt;
    &lt;/body&gt;
&lt;/html&gt;
</pre>

<p>V&nbsp;ladicí konzoli webového prohlížeče by se po otevření výše uvedené
testovací stránky měly objevit tyto řádky:</p>

<pre>
List size: 3
List to JavaScript: 1,2,3
Using typeof:
jsList type:   object
moriList type: object
Using Object.toString():
jsList type:   [object Array]
moriList type: [object Object]
</pre>

<p>Povšimněte si, že <strong>moriList</strong> je z&nbsp;pohledu JavaScriptu
&bdquo;nějakým&ldquo; obecným objektem, zatímco <strong>jsList</strong> je
plnohodnotné JavaScriptové pole (jeho prvky ovšem již s&nbsp;původním seznamem
nemusí sdílet stejný paměťový prostor!).</p>

<a href="http://www.root.cz/obrazek/233558/"><img src="http://i.iinfo.cz/images/487/mori02-prev.png" class="image-233558" alt="&#160;" height="242" width="370" /></a>
<p><i>Obrázek 2: Výpis na konzoli zachycený v&nbsp;nástroji Inspect Page
(Midori).</i></p>



<p><a name="k06"></a></p>
<h2 id="k06">6. Seznamy a vektory</h2>

<p>Způsob vytváření seznamů a vektorů s&nbsp;využitím konstruktorů
<strong>mori.list</strong> již známe. Podobně se tvoří vektory konstruktorem
<strong>mori.vector</strong>. Kromě toho knihovna <i>Mori</i> obsahuje i
množství funkcí, které buď vrací stav dané datové struktury, vrací jeden
vybraný prvek z&nbsp;této struktury, nebo vrací novou strukturu s&nbsp;přidaným
či ubraným prvkem. Jedná se o následující funkce (povšimněte si, že zde není
použit klasický OOP přístup, což je ale v&nbsp;tomto případě spíše výhoda;
podrobnosti si řekneme později):</p>

<table>
<tr><th> #</th><th>Funkce</th><th>Význam funkce</th></tr>
<tr><td> 1</td><td>mori.count</td><td>vrátí počet prvků v&nbsp;seznamu či vektoru</td></tr>
<tr><td> 2</td><td>mori.isEmpty</td><td>vrátí <strong>true</strong> v&nbsp;případě, že je datová struktura prázdná</td></tr>
<tr><td> 3</td><td>mori.empty</td><td>vrátí prázdnou datovou strukturu stejného typu</td></tr>
<tr><td> 4</td><td>mori.distinct</td><td>vrací novou datovou strukturu bez duplicitních prvků (velmi užitečné)</td></tr>
<tr><td> 5</td><td>mori.conj</td><td>vrátí novou datovou strukturu s&nbsp;přidaným prvkem</td></tr>
<tr><td> 6</td><td>mori.pop</td><td>vrátí kolekci bez prvního prvku (seznamy) nebo bez prvku posledního (vektory)</td></tr>
<tr><td> 7</td><td>mori.peek</td><td>vrátí první prvek (seznamy), popř.&nbsp;poslední prvek (vektory)</td></tr>
<tr><td> 8</td><td>mori.first</td><td>vrátí první prvek kolekce *</td></tr>
<tr><td> 9</td><td>mori.last</td><td>vrátí poslední prvek kolekce</td></tr>
<tr><td>10</td><td>mori.nth</td><td>získání n-tého prvku kolekce (u seznamů má lineární složitost!)</td></tr>
<tr><td>11</td><td>mori.get</td><td>vrátí n-tý prvek seznamu či vektoru (má obecnější význam než <strong>nth</strong>)</td></tr>
</table>

<p>Poznámka: funkce <strong>mori.first()</strong> ve skutečnosti není omezena
pouze na seznamy a vektory, protože ji je možné použít i na obecné sekvence a
dokonce i na lazy sekvence popsané v&nbsp;dalších kapitolách.</p>

<p>Některé funkce z&nbsp;výše uvedené tabulky se chovají stejně pro seznamy i
pro vektory, další funkce jsou však odlišné v&nbsp;chápání, který
&bdquo;konec&ldquo; datové struktury je modifikován, či z&nbsp;kterého
&bdquo;konce&ldquo; se mají vracet prvky:</p>

<table>
<tr><th>#</th><th>Funkce</th><th>Seznam</th><th>Vektor</th></tr>
<tr><td>1</td><td>mori.conj </td><td>nové prvky + původní seznam</td><td>vektor + nové prvky</td></tr>
<tr><td>2</td><td>mori.pop  </td><td>seznam bez prvního prvku</td><td>vektor bez posledního prvku</td></tr>
<tr><td>3</td><td>mori.peek </td><td>první prvek seznamu</td><td>poslední prvek vektoru</td></tr>
<tr><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td></tr>
<tr><td>4</td><td>mori.first</td><td>první prvek seznamu</td><td>první prvek vektoru</td></tr>
<tr><td>5</td><td>mori.last </td><td>poslední prvek seznamu</td><td>poslední prvek vektoru</td></tr>
</table>

<p>Důležité je při optimalizaci aplikací i porovnání výpočetní složitosti
některých funkcí z&nbsp;předchozí tabulky, protože právě odlišná složitost může
výrazným způsobem ovlivnit výkonnost celé aplikace, zejména tehdy, pokud se
budou používat kolekce s&nbsp;velkým množstvím prvků. Zajímavé je, že funkce
<strong>count</strong> má v&nbsp;obou případech konstantní složitost:
<i>O(1)</i>. To znamená, že v&nbsp;knihovně <i>Mori</i> nemá smysl si dopředu
počítat a pamatovat počet prvků seznamu. Naproti tomu funkce
<strong>nth</strong> se sice u obou typů kolekcí chová stejně, má však výrazně
odlišnou složitost: <i>O(n)</i> v&nbsp;případě seznamů (lineární složitost) a
<i>O(log<sub>32</sub>N)</i> v&nbsp;případě vektorů (logaritmická složitost). U
krátkých vektorů (do 32 prvků) je složitost konstantní a i u delších vektorů je
počet kroků nutných pro získání n-tého prvku velmi malý (například dva kroky
pro vektory o délce přibližně 1000 prvků atd., maximálně se jedná o sedm
kroků). Složitost funkce <strong>peek</strong> je v&nbsp;případě vektoru taktéž
rovna <i>O(log<sub>32</sub>N)</i>, na rozdíl od funkce <strong>last</strong> se
složitostí <i>O(N)</i> &ndash; v&nbsp;případě vektorů tedy vždy používejte
<strong>peek</strong>!</p>

<table>
<tr><th>#</th><th>Funkce</th><th>Seznam</th><th>Vektor</th></tr>
<tr><td>1</td><td>mori.count</td><td>O(1)</td><td>O(1)</td></tr>
<tr><td>2</td><td>mori.nth  </td><td>O(N)</td><td>O(log<sub>32</sub>N)</td></tr>
<tr><td>3</td><td>mori.pop  </td><td>O(1)</td><td>O(log<sub>32</sub>N)</td></tr>
<tr><td>4</td><td>mori.peek </td><td>O(1)</td><td>O(log<sub>32</sub>N)</td></tr>
<tr><td>5</td><td>mori.first</td><td>O(1)</td><td>O(1)</td></tr>
<tr><td>6</td><td>mori.last </td><td>O(N)</td><td>O(N)</td></tr>
</table>

<p>Povšimněte si, že vektory ve skutečnosti neodpovídají složitostí některých
funkcí běžně chápaným vektorům-jednorozměrným polím. Je tomu tak z&nbsp;toho
důvodu, že v&nbsp;knihovně <i>Mori</i> jsou vektory implementovány odlišným
způsobem a to zejména proto, aby bylo možné jednoduše implementovat funkci
<strong>conj</strong>, tj.&nbsp;aby se již vytvořená datová struktura mohla
sdílet mezi větším množstvím vektorů (to je možné i díky jejich
neměnnosti).</p>



<p><a name="k07"></a></p>
<h2 id="k07">7. Druhý demonstrační příklad: použití seznamů a vektorů</h2>

<p>Ve <a
href="https://github.com/tisnik/presentations/blob/master/mori/mori_02.js">druhém
demonstračním příkladu</a> jsou ukázány základní vlastnosti některých výše
popsaných funkcí, zejména chování ve chvíli, kdy je datová struktura (seznam či
vektor) prázdná. Nejprve se podívejme na zdrojový kód příkladu, který je hodně
&bdquo;ukecaný&ldquo;, a to kvůli přehlednosti:</p>

<pre>
<i>// ------------------------------------------------------------</i>
<i>// Knihovna Mori: demonstrační příklad číslo 2</i>
<i>// ------------------------------------------------------------</i>
&nbsp;
<i>// vytvoření čtyř seznamu různé délky</i>
var list1 = mori.list(1,2,3);
var list2 = mori.list(1,2);
var list3 = mori.list(1);
var list4 = mori.list();
&nbsp;
<i>// vytvoření čtyř vektoru různé délky</i>
var vector1 = mori.vector(1,2,3);
var vector2 = mori.vector(1,2);
var vector3 = mori.vector(1);
var vector4 = mori.vector();
&nbsp;
&nbsp;
&nbsp;
<i>// ------------------------------------------------------------</i>
<i>// Výpis informaci o délkách seznamu a vektoru</i>
<i>// ------------------------------------------------------------</i>
console.log("List1 size: " + mori.count(list1));
console.log("List2 size: " + mori.count(list2));
console.log("List3 size: " + mori.count(list3));
console.log("List4 size: " + mori.count(list4));
&nbsp;
console.log("Vector1 size: " + mori.count(vector1));
console.log("Vector2 size: " + mori.count(vector2));
console.log("Vector3 size: " + mori.count(vector3));
console.log("Vector4 size: " + mori.count(vector4));
&nbsp;
&nbsp;
&nbsp;
<i>// ------------------------------------------------------------</i>
<i>// Vyzkoušení funkce conj</i>
<i>// ------------------------------------------------------------</i>
console.log("Using conj:");
&nbsp;
console.log("conj list1: " + mori.conj(list1, 42));
console.log("conj list2: " + mori.conj(list2, 42));
console.log("conj list3: " + mori.conj(list3, 42));
console.log("conj list4: " + mori.conj(list4, 42));
&nbsp;
console.log("conj vector1: " + mori.conj(vector1, 42));
console.log("conj vector2: " + mori.conj(vector2, 42));
console.log("conj vector3: " + mori.conj(vector3, 42));
console.log("conj vector4: " + mori.conj(vector4, 42));
&nbsp;
&nbsp;
&nbsp;
<i>// ------------------------------------------------------------</i>
<i>// Vyzkoušení funkce pop</i>
<i>// ------------------------------------------------------------</i>
console.log("Using pop:");
&nbsp;
console.log("pop list1: " + mori.pop(list1));
console.log("pop list2: " + mori.pop(list2));
console.log("pop list3: " + mori.pop(list3));
<i>// následující volání skončí chybou!</i>
<i>//console.log("pop list4: " + mori.pop(list4));</i>
&nbsp;
console.log("pop vector1: " + mori.pop(vector1));
console.log("pop vector2: " + mori.pop(vector2));
console.log("pop vector3: " + mori.pop(vector3));
<i>// následující volání skončí chybou!</i>
<i>//console.log("pop vector4: " + mori.pop(vector4));</i>
&nbsp;
&nbsp;
&nbsp;
<i>// ------------------------------------------------------------</i>
<i>// Vyzkoušení funkce peek</i>
<i>// ------------------------------------------------------------</i>
console.log("Using peek:");
&nbsp;
console.log("peek list1: " + mori.peek(list1));
console.log("peek list2: " + mori.peek(list2));
console.log("peek list3: " + mori.peek(list3));
console.log("peek list4: " + mori.peek(list4));
&nbsp;
console.log("peek vector1: " + mori.peek(vector1));
console.log("peek vector2: " + mori.peek(vector2));
console.log("peek vector3: " + mori.peek(vector3));
console.log("peek vector4: " + mori.peek(vector4));
&nbsp;
&nbsp;
&nbsp;
<i>// ------------------------------------------------------------</i>
<i>// Vyzkoušení funkce first</i>
<i>// ------------------------------------------------------------</i>
console.log("Using first:");
&nbsp;
console.log("first list1: " + mori.first(list1));
console.log("first list2: " + mori.first(list2));
console.log("first list3: " + mori.first(list3));
console.log("first list4: " + mori.first(list4));
&nbsp;
console.log("first vector1: " + mori.first(vector1));
console.log("first vector2: " + mori.first(vector2));
console.log("first vector3: " + mori.first(vector3));
console.log("first vector4: " + mori.first(vector4));
&nbsp;
&nbsp;
&nbsp;
<i>// ------------------------------------------------------------</i>
<i>// Vyzkoušení funkce last</i>
<i>// ------------------------------------------------------------</i>
console.log("Using last:");
&nbsp;
console.log("last list1: " + mori.last(list1));
console.log("last list2: " + mori.last(list2));
console.log("last list3: " + mori.last(list3));
console.log("last list4: " + mori.last(list4));
&nbsp;
console.log("last vector1: " + mori.last(vector1));
console.log("last vector2: " + mori.last(vector2));
console.log("last vector3: " + mori.last(vector3));
console.log("last vector4: " + mori.last(vector4));
&nbsp;
&nbsp;
&nbsp;
<i>// ------------------------------------------------------------</i>
<i>// Vyzkoušení funkce distinct</i>
<i>// ------------------------------------------------------------</i>
console.log("Using distinct:");
&nbsp;
console.log("distinct []: " + mori.distinct(mori.list()));
console.log("distinct [1]: " + mori.distinct(mori.list(1)));
console.log("distinct [1 2]: " + mori.distinct(mori.list(1,2)));
console.log("distinct [1 2 1]: " + mori.distinct(mori.list(1,2,1)));
console.log("distinct [1 2 1 2]: " + mori.distinct(mori.list(1,2,1,2)));
&nbsp;
&nbsp;
&nbsp;
<i>// ------------------------------------------------------------</i>
<i>// Finito</i>
<i>// ------------------------------------------------------------</i>
</pre>

<p>Zdrojový kód HTML stránky použité pro spuštění druhého demonstračního
příkladu v&nbsp;prohlížeči:</p>

<pre>
&lt;!doctype html&gt;
&lt;html&gt;
    &lt;head&gt;
        &lt;title&gt;Mori tests #02&lt;/title&gt;
        &lt;meta charset="utf-8"&gt;
        &lt;script src="mori.js"&gt;&lt;/script&gt;
        &lt;script src="mori_02.js"&gt;&lt;/script&gt;
    &lt;/head&gt;
    &lt;body&gt;
        &lt;h1&gt;Mori tests #02&lt;/h1&gt;
    &lt;/body&gt;
&lt;/html&gt;
</pre>

<p>Příklad by měl po svém spuštění na konzoli (webového prohlížeče) vypsat tyto
zprávy:</p>

<pre>
List1 size: 3
List2 size: 2
List3 size: 1
List4 size: 0
Vector1 size: 3
Vector2 size: 2
Vector3 size: 1
Vector4 size: 0
Using conj:
conj list1: (42 1 2 3)
conj list2: (42 1 2)
conj list3: (42 1)
conj list4: (42)
conj vector1: [1 2 3 42]
conj vector2: [1 2 42]
conj vector3: [1 42]
conj vector4: [42]
Using pop:
pop list1: (2 3)
pop list2: (2)
pop list3: ()
pop vector1: [1 2]
pop vector2: [1]
pop vector3: []
Using peek:
peek list1: 1
peek list2: 1
peek list3: 1
peek list4: null
peek vector1: 3
peek vector2: 2
peek vector3: 1
peek vector4: null
Using first:
first list1: 1
first list2: 1
first list3: 1
first list4: null
first vector1: 1
first vector2: 1
first vector3: 1
first vector4: null
Using last:
last list1: 3
last list2: 2
last list3: 1
last list4: null 
last vector1: 3 
last vector2: 2 
last vector3: 1 
last vector4: null 
Using distinct: 
distinct []: () 
distinct [1]: (1) 
distinct [1 2]: (1 2) 
distinct [1 2 1]: (1 2) 
distinct [1 2 1 2]: (1 2) 
</pre>

<a href="http://www.root.cz/obrazek/233559/"><img src="http://i.iinfo.cz/images/493/mori03-prev.png" class="image-233559" alt="&#160;" height="270" width="265" /></a>
<p><i>Obrázek 3: Výpis na konzoli zachycený v&nbsp;nástroji Inspect Page
(Midori).</i></p>

<p>Povšimněte si chování funkce <strong>mori.pop</strong>, která skončí
s&nbsp;chybou ve chvíli, kdy se jí předá prázdná datová struktura, ať již se
jedná o seznam či o vektor:</p>

<a href="http://www.root.cz/obrazek/233560/"><img src="http://i.iinfo.cz/images/578/mori04-prev.png" class="image-233560" alt="&#160;" height="242" width="370" /></a>
<p><i>Obrázek 4: Funkce <strong>mori.pop</strong> volaná pro prázdný seznam.</i></p>

<a href="http://www.root.cz/obrazek/233561/"><img src="http://i.iinfo.cz/images/20/mori05-prev.png" class="image-233561" alt="&#160;" height="242" width="370" /></a>
<p><i>Obrázek 5: Funkce <strong>mori.pop</strong> volaná pro prázdný vektor.</i></p>



<p><a name="k08"></a></p>
<h2 id="k08">8. Sekvence a lazy sekvence</h2>

<p>Na všechny datové typy, které jsou v&nbsp;knihovně <i>Mori</i> programátorům
nabízeny, se můžeme dívat jako na různým způsobem implementované datové
<i>kolekce (collections)</i>, které je možné velmi snadno převést na takzvané
<i>sekvence</i>, a to konkrétně s&nbsp;využitím funkce <a
href="http://swannodette.github.io/mori/#seq">seq</a>. Mnohdy se dokonce
konverze datové kolekce na sekvenci provede automaticky uvnitř jiné funkce
(s&nbsp;vlastními daty se přitom většinou žádným způsobem nemanipuluje,
konverze znamená, že se pouze použije obecnější pohled na data). To ale
současně znamená, že všechny datové typy (tj.&nbsp;sekvence) mají společné
rozhraní, které svými základními možnostmi zhruba odpovídá <i>iterátorům</i>
známým například z&nbsp;programovacího jazyka Java (ve skutečnosti sice jazyk
JavaScript pojem &bdquo;rozhraní&ldquo; (interface) nepoužívá ve stejném smyslu
jako jazyk Java, ovšem funkce pro práci se sekvencemi lze skutečně použít
například jak pro seznamy, tak i pro vektory, mapy atd., bez ohledu na to, jaká
datová struktura je pro implementaci sekvence použita).</p>

<p>V&nbsp;knihovně <i>Mori</i> existuje pro práci se sekvencemi poměrně velké
množství funkcí, jejichž skládáním je možné vytvořit i dosti komplikované
algoritmy. Navíc, což je pro implementaci mnoha algoritmů taktéž velmi
důležité, podporuje knihovna <i>Mori</i> i vytváření a manipulaci
s&nbsp;takzvanými línými sekvencemi (<i>lazy sequence</i>), v&nbsp;nichž se
nové datové prvky vytváří či zjišťují až ve chvíli, kdy je to skutečně
zapotřebí. A vzhledem k&nbsp;tomu, že mnohdy není zapotřebí přečíst
<strong>všechny</strong> prvky nějaké líné sekvence, znamená to, že lze bez
větších problémů pracovat i s&nbsp;nekonečnými sekvencemi (samozřejmě se však
nesmíme snažit vyhodnotit/přečíst všechny prvky nekonečné sekvence, na druhou
stranu je možné aplikovat funkci, která z&nbsp;jedné nekonečné líné sekvence
vytvoří odlišnou línou sekvenci, a to bez toho, aby došlo k&nbsp;přeplnění
operační paměti). Použití běžných sekvencí i líných sekvencí si ukážeme na
několika demonstračních příkladech.</p>



<p><a name="k09"></a></p>
<h2 id="k09">9. Základní funkce pro práci se sekvencemi</h2>

<p>Naprostý základ pro práci se sekvencemi tvoří dvojice funkcí nazvaných <a
href="http://swannodette.github.io/mori/#first">first</a> a <a
href="http://swannodette.github.io/mori/#rest">rest</a>. Funkce
<strong>first</strong> vrací první prvek v&nbsp;sekvenci, popř.&nbsp;speciální
hodnotu <strong>null</strong> v&nbsp;případě, že je sekvence prázdná. Funkce
<strong>rest</strong> vrací zbylé prvky v&nbsp;sekvenci, popř.&nbsp;prázdnou
sekvenci ve chvíli, kdy je sekvence prázdná či obsahuje pouze jeden prvek. U
běžných sekvencí, například seznamů, jsou tyto funkce implementovány přímočaře,
ovšem v&nbsp;případě <i>lazy sekvencí</i> se prvky vrácené pomocí funkce
<strong>first</strong> vyhodnocují až za běhu aplikace, například pomocí nějaké
generátorové funkce. Tímto způsobem je možné pracovat i s&nbsp;nekonečnými
sekvencemi, u nichž už z&nbsp;principu nelze dopředu znát celkový počet prvků
atd. (viz též závěr <a href="#k08">předchozí kapitoly</a>).</p>



<p><a name="k10"></a></p>
<h2 id="k10">10. Třetí demonstrační příklad: použití funkcí <strong>first</strong> a <strong>rest</strong></h2>

<p><a
href="https://github.com/tisnik/presentations/blob/master/mori/mori_03.js">Třetí
demonstrační příklad</a> je velmi jednoduchý. Nejprve jsou vytvořeny čtyři
seznamy, přičemž třetí seznam obsahuje pouze jeden prvek a seznam čtvrtý je
prázdný. Následně je vytvořena čtveřice vektorů se stejným počtem prvků. Délky
(počty prvků) všech čtyř seznamů i všech čtyř vektorů jsou vypsány do konzole a
posléze je ukázáno chování funkcí <strong>first</strong> a
<strong>rest</strong>, popř.&nbsp;i kombinace těchto funkcí:</p>

<pre>
<i>// ------------------------------------------------------------</i>
<i>// Knihovna Mori: demonstrační příklad číslo 3</i>
<i>// ------------------------------------------------------------</i>
&nbsp;
<i>// vytvoření čtyř seznamu různé délky</i>
var list1 = mori.list(1,2,3);
var list2 = mori.list(1,2);
var list3 = mori.list(1);
var list4 = mori.list();
&nbsp;
<i>// vytvoření čtyř vektoru různé délky</i>
var vector1 = mori.vector(1,2,3);
var vector2 = mori.vector(1,2);
var vector3 = mori.vector(1);
var vector4 = mori.vector();
&nbsp;
&nbsp;
&nbsp;
<i>// ------------------------------------------------------------</i>
<i>// Výpis informaci o délkách seznamu a vektoru</i>
<i>// ------------------------------------------------------------</i>
console.log("List1 size: " + mori.count(list1));
console.log("List2 size: " + mori.count(list2));
console.log("List3 size: " + mori.count(list3));
console.log("List4 size: " + mori.count(list4));
&nbsp;
console.log("Vector1 size: " + mori.count(vector1));
console.log("Vector2 size: " + mori.count(vector2));
console.log("Vector3 size: " + mori.count(vector3));
console.log("Vector4 size: " + mori.count(vector4));
&nbsp;
&nbsp;
&nbsp;
<i>// ------------------------------------------------------------</i>
<i>// Vyzkoušení funkce first</i>
<i>// ------------------------------------------------------------</i>
console.log("Using first:");
&nbsp;
console.log("first list1: " + mori.first(list1));
console.log("first list2: " + mori.first(list2));
console.log("first list3: " + mori.first(list3));
console.log("first list4: " + mori.first(list4));
&nbsp;
console.log("first vector1: " + mori.first(vector1));
console.log("first vector2: " + mori.first(vector2));
console.log("first vector3: " + mori.first(vector3));
console.log("first vector4: " + mori.first(vector4));
&nbsp;
&nbsp;
&nbsp;
<i>// ------------------------------------------------------------</i>
<i>// Vyzkoušení funkce rest</i>
<i>// ------------------------------------------------------------</i>
console.log("Using rest:");
&nbsp;
console.log("rest list1: " + mori.rest(list1));
console.log("rest list2: " + mori.rest(list2));
console.log("rest list3: " + mori.rest(list3));
console.log("rest list4: " + mori.rest(list4));
&nbsp;
console.log("rest vector1: " + mori.rest(vector1));
console.log("rest vector2: " + mori.rest(vector2));
console.log("rest vector3: " + mori.rest(vector3));
console.log("rest vector4: " + mori.rest(vector4));
&nbsp;
&nbsp;
&nbsp;
<i>// ------------------------------------------------------------</i>
<i>// Kombinace rest+first</i>
<i>// ------------------------------------------------------------</i>
console.log("Using rest+first:");
&nbsp;
console.log("rest+first list1: " + mori.first(mori.rest(list1)));
console.log("rest+first list2: " + mori.first(mori.rest(list2)));
console.log("rest+first list3: " + mori.first(mori.rest(list3)));
console.log("rest+first list4: " + mori.first(mori.rest(list4)));
&nbsp;
console.log("rest+first vector1: " + mori.first(mori.rest(vector1)));
console.log("rest+first vector2: " + mori.first(mori.rest(vector2)));
console.log("rest+first vector3: " + mori.first(mori.rest(vector3)));
console.log("rest+first vector4: " + mori.first(mori.rest(vector4)));
&nbsp;
&nbsp;
&nbsp;
<i>// ------------------------------------------------------------</i>
<i>// Kombinace rest+rest</i>
<i>// ------------------------------------------------------------</i>
console.log("Using rest+rest:");
&nbsp;
console.log("rest+rest list1: " + mori.rest(mori.rest(list1)));
console.log("rest+rest list2: " + mori.rest(mori.rest(list2)));
console.log("rest+rest list3: " + mori.rest(mori.rest(list3)));
console.log("rest+rest list4: " + mori.rest(mori.rest(list4)));
&nbsp;
console.log("rest+rest vector1: " + mori.rest(mori.rest(vector1)));
console.log("rest+rest vector2: " + mori.rest(mori.rest(vector2)));
console.log("rest+rest vector3: " + mori.rest(mori.rest(vector3)));
console.log("rest+rest vector4: " + mori.rest(mori.rest(vector4)));
&nbsp;
&nbsp;
&nbsp;
<i>// ------------------------------------------------------------</i>
<i>// Finito</i>
<i>// ------------------------------------------------------------</i>
</pre>

<p>Zdrojový kód HTML stránky použité pro spuštění třetího demonstračního
příkladu v&nbsp;prohlížeči:</p>

<pre>
&lt;!doctype html&gt;
&lt;html&gt;
    &lt;head&gt;
        &lt;title&gt;Mori tests #03&lt;/title&gt;
        &lt;meta charset="utf-8"&gt;
        &lt;script src="mori.js"&gt;&lt;/script&gt;
        &lt;script src="mori_03.js"&gt;&lt;/script&gt;
    &lt;/head&gt;
    &lt;body&gt;
        &lt;h1&gt;Mori tests #03&lt;/h1&gt;
    &lt;/body&gt;
&lt;/html&gt;
</pre>

<p>Na výstupu vygenerovaném demonstračním příkladem je nejzajímavější chování
funkce <strong>first</strong> v&nbsp;případě, že se jí předá prázdná sekvence:
vrátí se <strong>null</strong>. Naproti tomu funkce <strong>rest</strong> vrátí
v&nbsp;případě sekvence s&nbsp;jedním prvkem prázdnou sekvenci; stejná hodnota
se vrátí i ve chvíli, kdy se funkci <strong>rest</strong> na vstup předá
prázdná sekvence (což je vlastně logické a očekávatelné chování, protože se do
programového kódu nemusí zbytečně vkládat další podmínky):</p>

<pre>
List1 size: 3
List2 size: 2
List3 size: 1
List4 size: 0
Vector1 size: 3
Vector2 size: 2
Vector3 size: 1
Vector4 size: 0
&nbsp;
Using first:
first list1: 1
first list2: 1
first list3: 1
first list4: null
first vector1: 1
first vector2: 1
first vector3: 1
first vector4: null
&nbsp;
Using rest:
rest list1: (2 3)
rest list2: (2)
rest list3: ()
rest list4: ()
rest vector1: (2 3)
rest vector2: (2)
rest vector3: ()
rest vector4: ()
</pre>

<a href="http://www.root.cz/obrazek/233562/"><img src="http://i.iinfo.cz/images/186/mori06-prev.png" class="image-233562" alt="&#160;" height="270" width="345" /></a>
<p><i>Obrázek 6: První část výstupu demonstračního příkladu.</i></p>

<a href="http://www.root.cz/obrazek/233563/"><img src="http://i.iinfo.cz/images/588/mori07-prev.png" class="image-233563" alt="&#160;" height="242" width="370" /></a>
<p><i>Obrázek 7: Druhá část výstupu demonstračního příkladu.</i></p>



<p><a name="k11"></a></p>
<h2 id="k11">11. Funkce <strong>range</strong>, <strong>take</strong> a <strong>map</strong></h2>

<p>Vlastnosti lazy sekvencí a taktéž nekonečných lazy sekvencí plně vyniknou až
ve chvíli, kdy začneme používat funkce, které s&nbsp;těmito sekvencemi umí
manipulovat, a to bez nutnosti výpočtu jednotlivých prvků sekvence. Nejprve se
seznámíme s&nbsp;funkcí <strong>mori.range</strong> sloužící k&nbsp;vytvoření
lazy sekvence čísel. Této funkci lze předat tři parametry
<strong>mori.range(start, end, step)</strong> určující první číselnou hodnotu
v&nbsp;sekvenci, limitní hodnotu a krok (ten udává počet prvků sekvence).
Ovšem parametry je možné vynechat; když se například vynechá první parametr,
bude mít první prvek v&nbsp;sekvenci hodnotu 0, když se vynechá parametr
poslední, bude krok roven jedné. To znamená, že volání:</p>

<pre>
mori.range(10)
</pre>

<p>vytvoří lazy sekvenci:</p>

<pre>
(0 1 2 3 4 5 6 7 8 9)
</pre>

<p>jejíž prvky jsou však vyhodnoceny až ve chvíli, kdy je to zapotřebí (nebo
taky nikdy!). Zajímavější je volání:</p>

<pre>
mori.range()
</pre>

<p>které vytvoří nekonečnou lazy sekvenci.</p>

<p>Funkce <strong>mori.take</strong> na svém vstupu očekává celé číslo
<strong>n</strong> a libovolnou (lazy) sekvenci. Vrátí se taktéž lazy sekvence,
mající ovšem maximálně <strong>n</strong> prvků původní sekvence. Prvky se
nevyhodnocují, proto tato funkce bez problémů pracuje i s&nbsp;nekonečnými
sekvencemi.</p>

<p>Třetí funkcí je funkce <strong>mori.map</strong>, která dokáže pro každý
prvek vstupní (lazy) sekvence zavolat jinou zvolenou funkci. Výsledkem
<strong>mori.map</strong> je druhá lazy sekvence. Ovšem pozor: zvolená funkce
se pro prvky nevolá ihned, ale &bdquo;líně&ldquo; až ve chvíli, kdy je to
skutečně zapotřebí (v&nbsp;mnoha případech tedy nikdy). Proto i funkce
<strong>map</strong> může pracovat s&nbsp;nekonečnými sekvencemi.</p>



<p><a name="k12"></a></p>
<h2 id="k12">12. Čtvrtý demonstrační příklad: použití funkcí <strong>range</strong>, <strong>take</strong> a <strong>map</strong></h2>

<p>Podívejme se nyní na okomentovaný <a
href="https://github.com/tisnik/presentations/blob/master/mori/mori_04.js">čtvrtý
demonstrační příklad</a>, v&nbsp;němž se kombinují možnosti výše popsaných
funkcí <strong>range</strong>, <strong>map</strong> a <strong>take</strong>. Za
povšimnutí stojí zejména možnost využít ve funkci <strong>map</strong> anonymní
funkci či libovolnou (pojmenovanou) funkci. Tyto funkce nejsou v&nbsp;příkladu
zcela čisté, protože provádějí výpis na konzoli. Právě díky tomu je patrné, kdy
se tyto funkce ve skutečnosti volají, tj.&nbsp;kdy se z&nbsp;lazy sekvence
stane běžná (vyhodnocená, realizovaná) sekvence:</p>

<pre>
<i>// ------------------------------------------------------------</i>
<i>// Knihovna Mori: demonstrační příklad číslo 4</i>
<i>// ------------------------------------------------------------</i>
&nbsp;
<i>// konstrukce nekonečné lazy sekvence</i>
var sequence1 = mori.range();
&nbsp;
<i>// z nekonečné lazy sekvence získáme konečnou línou sekvenci s 10 prvky</i>
var sequence2 = mori.take(10, sequence1);
&nbsp;
<i>// realizace druhé sekvence + její výpis</i>
console.log("sequence2=" + sequence2);
&nbsp;
<i>// funkce použitá ve funkcích map</i>
function twice(element) {
    console.log('processing:', element);
    return 2 * element;
}
&nbsp;
<i>// mapujeme uživatelskou funkci na *konečnou* sekvenci</i>
var sequence3 = mori.map(twice, sequence2);
&nbsp;
<i>// mapujeme uživatelskou anonymní funkci na *konečnou* sekvenci</i>
var sequence4 = mori.map(function(element) {
    console.log('processing:', element);
    return -2 * element
}, sequence2);
&nbsp;
<i>// obě nové vytvořené sekvence vypíšeme</i>
<i>// (tím se 'realizuji')</i>
console.log("sequence3=" + sequence3);
console.log("sequence4=" + sequence3);
&nbsp;
<i>// nyní mapujeme uživatelskou funkci na *nekonečnou* sekvenci</i>
var sequence5 = mori.map(twice, sequence1);
&nbsp;
<i>// nyní mapujeme uživatelskou anonymní funkci na *nekonečnou* sekvenci</i>
var sequence6 = mori.map(function(element) {
    console.log('processing:', element);
    return -1 * element
}, sequence1);
&nbsp;
<i>// obě nově vytvořené sekvence vypíšeme</i>
<i>// (tím se 'realizuji')</i>
console.log("sequence5 begins with: " + mori.take(10, sequence5));
console.log("sequence6 begins with: " + mori.take(10, sequence6));
&nbsp;
<i>// mapování může mít několik "vrstev", stále se však jedna o lazy</i>
<i>// sekvence, které se prozatím nerealizuji (mezikrok je taktéž nekonečná sekvence!)</i>
var sequence7 = mori.map(twice, mori.map(twice, sequence1));
&nbsp;
<i>// sekvence vypíšeme</i>
<i>// (tím se 'realizuje')</i>
console.log("sequence7 begins with: " + mori.take(10, sequence7));
&nbsp;
&nbsp;
&nbsp;
<i>// ------------------------------------------------------------</i>
<i>// Finito</i>
<i>// ------------------------------------------------------------</i>
</pre>

<p>Zdrojový kód HTML stránky použité pro spuštění čtvrtého demonstračního
příkladu v&nbsp;prohlížeči:</p>

<pre>
&lt;!doctype html&gt;
&lt;html&gt;
    &lt;head&gt;
        &lt;title&gt;Mori tests #04&lt;/title&gt;
        &lt;meta charset="utf-8"&gt;
        &lt;script src="mori.js"&gt;&lt;/script&gt;
        &lt;script src="mori_03.js"&gt;&lt;/script&gt;
    &lt;/head&gt;
    &lt;body&gt;
        &lt;h1&gt;Mori tests #04&lt;/h1&gt;
    &lt;/body&gt;
&lt;/html&gt;
</pre>

<a href="http://www.root.cz/obrazek/233564/"><img src="http://i.iinfo.cz/images/511/mori08-prev.png" class="image-233564" alt="&#160;" height="270" width="247" /></a>
<p><i>Obrázek 8: Výsledek běhu demonstračního příkladu..</i></p>



<p><a name="k13"></a></p>
<h2 id="k13">13. Repositář se zdrojovými kódy všech dnešních demonstračních příkladů</h2>

<p>Demonstrační příklady, na nichž jsme si ukazovali vlastnosti knihovny
<i>Mori</i>, byly uloženy do Git repositáře dostupného na adrese <a
href="https://github.com/tisnik/presentations">https://github.com/tisnik/presentations</a>.
V&nbsp;tabulce zobrazené pod tímto odstavcem naleznete na zdrojové kódy těchto
příkladů přímé odkazy:</p>

<table>
<tr><th>#</th><th>Zdrojový soubor</th><th>Odkaz</th></tr>
<tr><td>1</td><td>mori_01.js  </td><td><a href="https://github.com/tisnik/presentations/blob/master/mori/mori_01.js">https://github.com/tisnik/presentations/blob/master/mori/mori_01.js</a></td></tr>
<tr><td>2</td><td>mori_01.html</td><td><a href="https://github.com/tisnik/presentations/blob/master/mori/mori_01.html">https://github.com/tisnik/presentations/blob/master/mori/mori_01.html</a></td></tr>
<tr><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td></tr>
<tr><td>3</td><td>mori_02.js  </td><td><a href="https://github.com/tisnik/presentations/blob/master/mori/mori_02.js">https://github.com/tisnik/presentations/blob/master/mori/mori_02.js</a></td></tr>
<tr><td>4</td><td>mori_02.html</td><td><a href="https://github.com/tisnik/presentations/blob/master/mori/mori_02.html">https://github.com/tisnik/presentations/blob/master/mori/mori_02.html</a></td></tr>
<tr><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td></tr>
<tr><td>5</td><td>mori_03.js  </td><td><a href="https://github.com/tisnik/presentations/blob/master/mori/mori_03.js">https://github.com/tisnik/presentations/blob/master/mori/mori_03.js</a></td></tr>
<tr><td>6</td><td>mori_03.html</td><td><a href="https://github.com/tisnik/presentations/blob/master/mori/mori_03.html">https://github.com/tisnik/presentations/blob/master/mori/mori_03.html</a></td></tr>
<tr><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td></tr>
<tr><td>7</td><td>mori_04.js  </td><td><a href="https://github.com/tisnik/presentations/blob/master/mori/mori_04.js">https://github.com/tisnik/presentations/blob/master/mori/mori_04.js</a></td></tr>
<tr><td>8</td><td>mori_04.html</td><td><a href="https://github.com/tisnik/presentations/blob/master/mori/mori_04.html">https://github.com/tisnik/presentations/blob/master/mori/mori_04.html</a></td></tr>
</table>



<p><a name="k14"></a></p>
<h2 id="k14">14. Odkazy na Internetu</h2>

<ol>

<li>Mori na GitHubu<br />
<a href="https://github.com/swannodette/mori">https://github.com/swannodette/mori</a>
</li>

<li>Mori: popis API (dokumentace)<br />
<a href="http://swannodette.github.io/mori/">http://swannodette.github.io/mori/</a>
</li>

<li>Mori: Benchmarking<br />
<a href="https://github.com/swannodette/mori/wiki/Benchmarking">https://github.com/swannodette/mori/wiki/Benchmarking</a>
</li>

<li>Functional data structures in JavaScript with Mori<br />
<a href="http://sitr.us/2013/11/04/functional-data-structures.html">http://sitr.us/2013/11/04/functional-data-structures.html</a>
</li>

<li>Immutable.js<br />
<a href="https://facebook.github.io/immutable-js/">https://facebook.github.io/immutable-js/</a>
</li>

<li>Persistent data structure<br />
<a href="https://en.wikipedia.org/wiki/Persistent_data_structure">https://en.wikipedia.org/wiki/Persistent_data_structure</a>
</li>

<li>Understanding Clojure's Persistent Vectors, pt. 1<br />
<a href="http://hypirion.com/musings/understanding-persistent-vector-pt-1">http://hypirion.com/musings/understanding-persistent-vector-pt-1</a>
</li>

<li>Hash array mapped trie (Wikipedia)<br />
<a href="https://en.wikipedia.org/wiki/Hash_array_mapped_trie">https://en.wikipedia.org/wiki/Hash_array_mapped_trie</a>
</li>

<li>Java theory and practice: To mutate or not to mutate?<br />
<a href="http://www.ibm.com/developerworks/java/library/j-jtp02183/index.html">http://www.ibm.com/developerworks/java/library/j-jtp02183/index.html</a>
</li>

<li>Efficient persistent (immutable) data structures<br />
<a href="https://persistent.codeplex.com/">https://persistent.codeplex.com/</a>
</li>

<li>Netscape Enterprise Server (Wikipedia)<br />
<a href="https://en.wikipedia.org/wiki/Netscape_Enterprise_Server">https://en.wikipedia.org/wiki/Netscape_Enterprise_Server</a>
</li>

<li>SSJS Reference Guide (Server-Side JavaScript)<br />
<a href="http://docs.oracle.com/cd/E19957-01/816-6410-10/816-6410-10.pdf">http://docs.oracle.com/cd/E19957-01/816-6410-10/816-6410-10.pdf</a>
</li>

<li>Atom: moderní textový editor<br />
<a href="http://www.root.cz/clanky/atom-moderni-textovy-editor/">http://www.root.cz/clanky/atom-moderni-textovy-editor/</a>
</li>

<li>Atom: moderní textový editor (dokončení)<br />
<a href="http://www.root.cz/clanky/atom-moderni-textovy-editor-dokonceni/">http://www.root.cz/clanky/atom-moderni-textovy-editor-dokonceni/</a>
</li>

<li>Propojení světa LISPu se světem JavaScriptu s využitím transpřekladače Wisp<br />
<a href="http://www.root.cz/clanky/propojeni-sveta-lispu-se-svetem-javascriptu-s-vyuzitim-transprekladace-wisp/">http://www.root.cz/clanky/propojeni-sveta-lispu-se-svetem-javascriptu-s-vyuzitim-transprekladace-wisp/</a>
</li>

<li>Propojení světa LISPu se světem JavaScriptu s využitím transpřekladače Wisp (2.část)<br />
<a href="http://www.root.cz/clanky/propojeni-sveta-lispu-se-svetem-javascriptu-s-vyuzitim-transprekladace-wisp-2-cast/">http://www.root.cz/clanky/propojeni-sveta-lispu-se-svetem-javascriptu-s-vyuzitim-transprekladace-wisp-2-cast/</a>
</li>

<li>Wisp na GitHubu<br />
<a href="https://github.com/Gozala/wisp">https://github.com/Gozala/wisp</a>
</li>

<li>Wisp playground<br />
<a href="http://www.jeditoolkit.com/try-wisp/">http://www.jeditoolkit.com/try-wisp/</a>
</li>

<li>REPL v prohlížeči<br />
<a href="http://www.jeditoolkit.com/interactivate-wisp/">http://www.jeditoolkit.com/interactivate-wisp/</a>
</li>

<li>Minification (programming)<br />
<a href="https://en.wikipedia.org/wiki/Minification_(programming)">https://en.wikipedia.org/wiki/Minification_(programming)</a>
</li>

<li>Clojure Macro Tutorial (Part I, Getting the Compiler to Write Your Code For You)<br />
<a href="http://www.learningclojure.com/2010/09/clojure-macro-tutorial-part-i-getting.html">http://www.learningclojure.com/2010/09/clojure-macro-tutorial-part-i-getting.html</a>
</li>

<li>Clojure Macro Tutorial (Part II: The Compiler Strikes Back)<br />
<a href="http://www.learningclojure.com/2010/09/clojure-macro-tutorial-part-ii-compiler.html">http://www.learningclojure.com/2010/09/clojure-macro-tutorial-part-ii-compiler.html</a>
</li>

<li>Clojure Macro Tutorial (Part III: Syntax Quote)<br />
<a href="http://www.learningclojure.com/2010/09/clojure-macro-tutorial-part-ii-syntax.html">http://www.learningclojure.com/2010/09/clojure-macro-tutorial-part-ii-syntax.html</a>
</li>

<li>Tech behind Tech: Clojure Macros Simplified<br />
<a href="http://techbehindtech.com/2010/09/28/clojure-macros-simplified/">http://techbehindtech.com/2010/09/28/clojure-macros-simplified/</a>
</li>

<li>Fatvat - Exploring functional programming: Clojure Macros<br />
<a href="http://www.fatvat.co.uk/2009/02/clojure-macros.html">http://www.fatvat.co.uk/2009/02/clojure-macros.html</a>
</li>

<li>Eulerovo číslo<br />
<a href="http://cs.wikipedia.org/wiki/Eulerovo_??slo">http://cs.wikipedia.org/wiki/Eulerovo_??slo</a>
</li>

<li>List comprehension<br />
<a href="http://en.wikipedia.org/wiki/List_comprehension">http://en.wikipedia.org/wiki/List_comprehension</a>
</li>

<li>List Comprehensions in Clojure<br />
<a href="http://asymmetrical-view.com/2008/11/18/list-comprehensions-in-clojure.html">http://asymmetrical-view.com/2008/11/18/list-comprehensions-in-clojure.html</a>
</li>

<li>Clojure Programming Concepts: List Comprehension<br />
<a href="http://en.wikibooks.org/wiki/Clojure_Programming/Concepts#List_Comprehension">http://en.wikibooks.org/wiki/Clojure_Programming/Concepts#List_Comprehension</a>
</li>

<li>Clojure core API: for macro<br />
<a href="http://clojure.github.com/clojure/clojure.core-api.html#clojure.core/for">http://clojure.github.com/clojure/clojure.core-api.html#clojure.core/for</a>
</li>

<li>cirrus machina - The Clojure for macro<br />
<a href="http://www.cirrusmachina.com/blog/comment/the-clojure-for-macro/">http://www.cirrusmachina.com/blog/comment/the-clojure-for-macro/</a>
</li>

<li>Clojure.org: Clojure home page<br />
<a href="http://clojure.org/downloads">http://clojure.org/downloads</a>
</li>

<li>Clojure.org: Vars and the Global Environment<br />
<a href="http://clojure.org/Vars">http://clojure.org/Vars</a>
</li>

<li>Clojure.org: Refs and Transactions<br />
<a href="http://clojure.org/Refs">http://clojure.org/Refs</a>
</li>

<li>Clojure.org: Atoms<br />
<a href="http://clojure.org/Atoms">http://clojure.org/Atoms</a>
</li>

<li>Clojure.org: Agents as Asynchronous Actions<br />
<a href="http://clojure.org/agents">http://clojure.org/agents</a>
</li>

<li>A Couple of Clojure Agent Examples<br />
<a href="http://lethain.com/a-couple-of-clojure-agent-examples/">http://lethain.com/a-couple-of-clojure-agent-examples/</a>
</li>

<li>Clojure - Functional Programming for the JVM<br />
<a href="http://java.ociweb.com/mark/clojure/article.html">http://java.ociweb.com/mark/clojure/article.html</a>
</li>

<li>Clojure quick reference<br />
<a href="http://faustus.webatu.com/clj-quick-ref.html">http://faustus.webatu.com/clj-quick-ref.html</a>
</li>

<li>4Clojure<br />
<a href="http://www.4clojure.com/">http://www.4clojure.com/</a>
</li>

<li>ClojureDoc<br />
<a href="http://clojuredocs.org/">http://clojuredocs.org/</a>
</li>

<li>Clojure (Wikipedia EN)<br />
<a href="http://en.wikipedia.org/wiki/Clojure">http://en.wikipedia.org/wiki/Clojure</a>
</li>

<li>Clojure (Wikipedia CS)<br />
<a href="http://cs.wikipedia.org/wiki/Clojure">http://cs.wikipedia.org/wiki/Clojure</a>
</li>

<li>Riastradh's Lisp Style Rules<br />
<a href="http://mumble.net/~campbell/scheme/style.txt">http://mumble.net/~campbell/scheme/style.txt</a>
</li>

<li>Dynamic Languages Strike Back<br />
<a href="http://steve-yegge.blogspot.cz/2008/05/dynamic-languages-strike-back.html">http://steve-yegge.blogspot.cz/2008/05/dynamic-languages-strike-back.html</a>
</li>

<li>Scripting: Higher Level Programming for the 21st Century<br />
<a href="http://www.tcl.tk/doc/scripting.html">http://www.tcl.tk/doc/scripting.html</a>
</li>

<li>Java Virtual Machine Support for Non-Java Languages<br />
<a href="http://docs.oracle.com/javase/7/docs/technotes/guides/vm/multiple-language-support.html">http://docs.oracle.com/javase/7/docs/technotes/guides/vm/multiple-language-support.html</a>
</li>

<li>The Lua VM, on the Web<br />
<a href="https://kripken.github.io/lua.vm.js/lua.vm.js.html">https://kripken.github.io/lua.vm.js/lua.vm.js.html</a>
</li>

<li>Lua.vm.js REPL<br />
<a href="https://kripken.github.io/lua.vm.js/repl.html">https://kripken.github.io/lua.vm.js/repl.html</a>
</li>

<li>lua2js<br />
<a href="https://www.npmjs.com/package/lua2js">https://www.npmjs.com/package/lua2js</a>
</li>

<li>lua2js na GitHubu<br />
<a href="https://github.com/basicer/lua2js-dist">https://github.com/basicer/lua2js-dist</a>
</li>

<li>Seriál o programovacím jazyku Lua<br />
<a href="http://www.root.cz/serialy/programovaci-jazyk-lua/">http://www.root.cz/serialy/programovaci-jazyk-lua/</a>
</li>

<li>Source-to-source compiler<br />
<a href="https://en.wikipedia.org/wiki/Source-to-source_compiler">https://en.wikipedia.org/wiki/Source-to-source_compiler</a>
</li>

<li>JavaScript is Assembly Language for the Web: Sematic Markup is Dead! Clean vs. Machine-coded HTML<br />
<a href="http://www.hanselman.com/blog/JavaScriptIsAssemblyLanguageForTheWebSematicMarkupIsDeadCleanVsMachinecodedHTML.aspx">http://www.hanselman.com/blog/JavaScriptIsAssemblyLanguageForTheWebSematicMarkupIsDeadCleanVsMachinecodedHTML.aspx</a>
</li>

<li>JavaScript is Web Assembly Language and that's OK.<br />
<a href="http://www.hanselman.com/blog/JavaScriptIsWebAssemblyLanguageAndThatsOK.aspx">http://www.hanselman.com/blog/JavaScriptIsWebAssemblyLanguageAndThatsOK.aspx</a>
</li>

<li>Dart<br />
<a href="https://www.dartlang.org/">https://www.dartlang.org/</a>
</li>

<li>CoffeeScript<br />
<a href="http://coffeescript.org/">http://coffeescript.org/</a>
</li>

<li>TypeScript<br />
<a href="http://www.typescriptlang.org/">http://www.typescriptlang.org/</a>
</li>

<li>Lua (programming language)<br />
<a href="http://en.wikipedia.org/wiki/Lua_(programming_language)">http://en.wikipedia.org/wiki/Lua_(programming_language)</a>
</li>

<li>Static single assignment form (SSA)<br />
<a href="http://en.wikipedia.org/wiki/Static_single_assignment_form">http://en.wikipedia.org/wiki/Static_single_assignment_form</a>
</li>

<li>LuaJIT 2.0 SSA IR
<a href="http://wiki.luajit.org/SSA-IR-2.0">http://wiki.luajit.org/SSA-IR-2.0</a>
</li>

<li>The LuaJIT Project<br />
<a href="http://luajit.org/index.html">http://luajit.org/index.html</a>
</li>

<li>LuaJIT FAQ<br />
<a href="http://luajit.org/faq.html">http://luajit.org/faq.html</a>
</li>

<li>LuaJIT Performance Comparison<br />
<a href="http://luajit.org/performance.html">http://luajit.org/performance.html</a>
</li>

<li>LuaJIT 2.0 intellectual property disclosure and research opportunities<br />
<a href="http://article.gmane.org/gmane.comp.lang.lua.general/58908">http://article.gmane.org/gmane.comp.lang.lua.general/58908</a>
</li>

<li>LuaJIT Wiki<br />
<a href="http://wiki.luajit.org/Home">http://wiki.luajit.org/Home</a>
</li>

<li>LuaJIT 2.0 Bytecode Instructions<br />
<a href="http://wiki.luajit.org/Bytecode-2.0">http://wiki.luajit.org/Bytecode-2.0</a>
</li>

<li>Programming in Lua (first edition)<br />
<a href="http://www.lua.org/pil/contents.html">http://www.lua.org/pil/contents.html</a>
</li>

<li>Lua 5.2 sources<br />
<a href="http://www.lua.org/source/5.2/">http://www.lua.org/source/5.2/</a>
</li>

<li>Tcl Plugin Version 3<br />
<a href="http://www.tcl.tk/software/plugin/">http://www.tcl.tk/software/plugin/</a>
</li>

<li>JavaScript: The Web Assembly Language?<br />
<a href="http://www.informit.com/articles/article.aspx?p=1856657">http://www.informit.com/articles/article.aspx?p=1856657</a>
</li>

<li>asm.js<br />
<a href="http://asmjs.org/">http://asmjs.org/</a>
</li>

<li>List of languages that compile to JS<br />
<a href="https://github.com/jashkenas/coffeescript/wiki/List-of-languages-that-compile-to-JS">https://github.com/jashkenas/coffeescript/wiki/List-of-languages-that-compile-to-JS</a>
</li>

<li>REPL<br />
<a href="https://en.wikipedia.org/wiki/Read%E2%80%93eval%E2%80%93print_loop">https://en.wikipedia.org/wiki/Read%E2%80%93eval%E2%80%93print_loop</a>
</li>

<li>The LLVM Compiler Infrastructure<br />
<a href="http://llvm.org/ProjectsWithLLVM/">http://llvm.org/ProjectsWithLLVM/</a>
</li>

<li>clang: a C language family frontend for LLVM<br />
<a href="http://clang.llvm.org/">http://clang.llvm.org/</a>
</li>

<li>emscripten<br />
<a href="http://kripken.github.io/emscripten-site/">http://kripken.github.io/emscripten-site/</a>
</li>

<li>LLVM Backend ("Fastcomp")<br />
<a href="http://kripken.github.io/emscripten-site/docs/building_from_source/LLVM-Backend.html#llvm-backend">http://kripken.github.io/emscripten-site/docs/building_from_source/LLVM-Backend.html#llvm-backend</a>
</li>

<li>Emscripten - Fastcomp na GitHubu<br />
<a href="https://github.com/kripken/emscripten-fastcomp">https://github.com/kripken/emscripten-fastcomp</a>
</li>

<li>Clang (pro Emscripten) na GitHubu<br />
<a href="https://github.com/kripken/emscripten-fastcomp-clang">https://github.com/kripken/emscripten-fastcomp-clang</a>
</li>

<li>Why not use JavaScript?<br />
<a href="https://ckknight.github.io/gorillascript/">https://ckknight.github.io/gorillascript/</a>
</li>

</ol>



<p></p><p></p>
<p><small>Autor: <a href="http://www.fit.vutbr.cz/~tisnovpa">Pavel Tišnovský</a> &nbsp; 2015</small></p>
</body>
</html>

