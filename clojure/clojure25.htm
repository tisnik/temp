<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
        "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html>
<head>
<title>Programovací jazyk Clojure - některé užitečné triky použitelné (nejenom) v testech</title>
<meta name="Author" content="Pavel Tisnovsky" />
<meta name="Generator" content="vim" />
<meta http-equiv="content-type" content="text/html; charset=utf-8" />
<style type="text/css">
         body {color:#000000; background:#ffffff;}
         h1  {font-family: arial, helvetica, sans-serif; color:#ffffff; background-color:#c00000; text-align:center; padding-left:1em}
         h2  {font-family: arial, helvetica, sans-serif; color:#ffffff; background-color:#0000c0; padding-left:1em; text-align:left}
         h3  {font-family: arial, helvetica, sans-serif; color:#000000; background-color:#c0c0c0; padding-left:1em; text-align:left}
         h4  {font-family: arial, helvetica, sans-serif; color:#000000; background-color:#e0e0e0; padding-left:1em; text-align:left}
         a   {font-family: arial, helvetica, sans-serif;}
         li  {font-family: arial, helvetica, sans-serif; color:#000000; text-align:justify; width:450px;}
         ol  {font-family: arial, helvetica, sans-serif; color:#000000; text-align:justify; width:450px;}
         ul  {font-family: arial, helvetica, sans-serif; color:#000000; text-align:justify; width:450px;}
         p   {font-family: arial, helvetica, sans-serif; color:#000000; text-align:justify;}
         pre {background:#e0e0e0}
</style>
</head>

<body>

<h1>Programovací jazyk Clojure - některé užitečné triky použitelné (nejenom) v testech</h1>

<h3>Pavel Tišnovský</h3>

<p></p>

<h1>Úvodník</h1>

<p>Programovací jazyk Clojure je navržen takovým způsobem, aby vývojáře vedl k tvorbě referenčně transparentních funkcí, tj. funkcí bez vedlejších efektů, které se velmi snadno testují. Ovšem programátoři musí při psaní testů pracovat i s funkcemi s vedlejšími efekty. V těchto případech lze využít některé triky, o nichž se dnes zmíníme.</p>



<h2>Obsah</h2>

<p><a href="#k01">1. Makro <strong>are</strong> určené pro zpřehlednění testů</a></p>
<p><a href="#k02">2. Referenčně transparentní funkce a funkce s&nbsp;vedlejšími efekty</a></p>
<p><a href="#k03">3. Jak testovat funkce, které tisknou na standardní či chybový výstup?</a></p>
<p><a href="#k04">4. Makro <strong>with-out-str</strong></a></p>
<p><a href="#k05">5. Mockování funkcí volaných v&nbsp;průběhu testování</a></p>
<p><a href="#k06">6. Makro <strong>with-redefs</strong></a></p>
<p><a href="#k07">7. Zjištění existence funkcí či proměnných v&nbsp;testovaném jmenném prostoru</a></p>
<p><a href="#k08">8. Predikát <strong>clojure.test/function?</strong></a></p>
<p><a href="#k09">9. Repositář s&nbsp;dnešními demonstračními příklady</a></p>
<p><a href="#k10">10. Odkazy na předchozí části tohoto seriálu</a></p>
<p><a href="#k11">11. Odkazy na Internetu</a></p>



<p><a name="k01"></a></p>
<h2 id="k01">1. Makro <strong>are</strong> určené pro zpřehlednění testů</h2>

<p>V&nbsp;dnešním článku o programovacím jazyku <i>Clojure</i> se seznámíme
s&nbsp;některými jednoduchými i složitějšími triky, které lze využít při tvorbě
testů. První trik spočívá ve využití makra <strong>are</strong>, které může
v&nbsp;mnoha případech zpřehlednit testy, v&nbsp;nichž se neustále volá nám již
známé makro <strong>is</strong>. Jedná se o velmi jednoduchý trik, nicméně si
jeho použití ukažme na demonstračním příkladu. Nejprve vytvoříme kostru tohoto
příkladu:</p>

<pre>
lein new app testing1
</pre>

<p>Dále upravíme module <strong>testing1.core</strong> následujícím
způsobem:</p>

<pre>
(ns <strong>testing1.core</strong>
    (:gen-class))
&nbsp;
(defn <strong>add</strong>
    [x y]
    (println "Adding" x "to" y)
    (+ x y))
&nbsp;
(defn <strong>-main</strong>
    [&amp; args]
    (println (add 1 2)))
</pre>

<p>Pokusme se nyní napsat jednoduchý test pro funkci <strong>add</strong>. Test
bude uložen v&nbsp;souboru
<strong>testing1/test/testing1/core_test.clj</strong>, jehož kostra byla
automaticky vygenerována nástrojem <i>Leiningen</i>, takže nám zbývá jen
dopsání vlastní testovací funkce:</p>

<pre>
(ns <strong>testing1.core-test</strong>
    (:require [clojure.test :refer :all]
              [testing1.core :refer :all]))
&nbsp;
(deftest <strong>test-add-1</strong>
    (testing "function add"
        (is (= 0 (add 0 0)))
        (is (= 3 (add 1 2)))
        (is (= 5/6 (add 1/2 1/3)))))
</pre>

<p>Takto zapsaný test je plně funkční, o čemž se lze snadno přesvědčit:</p>

<pre>
<strong>lein test</strong>
&nbsp;
lein test testing1.core-test
Adding 0 to 0
Adding 1 to 2
Adding 1/2 to 1/3
&nbsp;
Ran 1 tests containing 3 assertions.
0 failures, 0 errors.
</pre>

<p>Jedinou vážnější nevýhodou je opakované použití makra <strong>is</strong> a
z&nbsp;toho vyplývající záplavy závorek. Aby se psaní testů zpřehlednilo, lze
využít makro <strong>are</strong>, kterému se předá funkce provádějící
porovnání (jen se nezapisuje jméno funkce) a za tímto zápisem pak již většinou
seznam obsahující očekávané hodnoty a volání testované funkce:</p>

<pre>
(ns <strong>testing1.core-test</strong>
    (:require [clojure.test :refer :all]
              [testing1.core :refer :all]))
&nbsp;
(deftest <strong>test-add-1</strong>
    (testing "function add"
        (is (= 0 (add 0 0)))
        (is (= 3 (add 1 2)))
        (is (= 5/6 (add 1/2 1/3)))))
&nbsp;
(deftest <strong>test-add-2</strong>
    (testing "function add"
        (are [x y] (= x y)
            0   (add 0 0)
            3   (add 1 2)
            5/6 (add 1/2 1/3))))
</pre>

<p>Oba dva testy <strong>test-add-1</strong> a <strong>test-add-2</strong> jsou
prakticky ekvivalentní, o čemž se opět můžeme snadno přesvědčit:</p>

<pre>
<strong>lein test</strong>
Adding 0 to 0
Adding 1 to 2
Adding 1/2 to 1/3
Adding 0 to 0
Adding 1 to 2
Adding 1/2 to 1/3
&nbsp;
Ran 2 tests containing 6 assertions.
0 failures, 0 errors.
</pre>



<p><a name="k02"></a></p>
<h2 id="k02">2. Referenčně transparentní funkce a funkce s&nbsp;vedlejšími efekty</h2>

<p>Již v&nbsp;úvodních článcích o programovacím jazyce <i>Clojure</i> jsme si
řekli, že tento jazyk patří, společně s&nbsp;klasickým <i>LISPem</i>,
<i>Scheme</i>, <i>Haskellem</i> či <i>Erlangem</i> do skupiny (ne vždy nutně
čistě) funkcionálních jazyků, tj.&nbsp;programovacích jazyků vycházejících
z&nbsp;teorie takzvaného &lambda;-kalkulu, jehož autorem je <i>Alonzo
Church</i> (na první návrhy LISPu se dokonce můžeme dívat jako na jeden
z&nbsp;formalizovaných způsobů zápisu &lambda;-kalkulu, pro nějž jen tak
mimochodem existuje mechanismus vyhodnocování jednotlivých &lambda; výrazů;
taktéž se tím vysvětluje přítomnost znaku lambda v&nbsp;logu jazyka
<i>Clojure</i>). Ve skutečnosti sice <i>Clojure</i> není čistě funkcionálním
jazykem, ovšem v&nbsp;případě, že vývojář bude při tvorbě svých aplikací
dodržovat zásady funkcionálního programování, bude pro něj mnohem snadnější
vytvářet skutečně výkonné aplikace; ať se to již týká snadnější tvorby
bezpečných vícevláknových aplikací či možnosti použití mnohdy velmi užitečné
funkce <strong>memoize</strong>.</p>

<p>Připomeňme si, že v&nbsp;programovacím jazyce <i>Clojure</i> jsou funkce
považovány za plnohodnotné datové typy, což znamená, že funkce lze navázat na
libovolný symbol (a tím vlastně původně anonymní funkci pojmenovat), funkce lze
předávat jako parametry do jiných funkcí a funkce mohou být taktéž návratovou
hodnotou jiných funkcí &ndash; funkce tedy může vytvořit a vrátit jinou funkci.
<i>Clojure</i> taktéž podporuje práci s&nbsp;uzávěry (<i>closure(s)</i>),
tj.&nbsp;funkcí svázaných s&nbsp;nějakým symbolem vytvořeným vně funkce.
Podpora uzávěrů umožňuje například tvorbu funkcí sdílejících společný kontext
(GUI) atd. Ovšem vzhledem k&nbsp;tomu, že &ndash; jak již víme &ndash;
<i>Clojure</i> není čistě funkcionálním jazykem, je možné při vytváření
uživatelských funkcí přímo z&nbsp;dané funkce přistupovat k&nbsp;nějakému
globálnímu symbolu, přesněji řečeno k&nbsp;symbolu &bdquo;globálnímu&ldquo;
v&nbsp;rámci nějakého jmenného prostoru. Taktéž lze vytvářet funkce
s&nbsp;vedlejším efektem, které například zapisují data do souborů, mění
hodnotu navázanou na globální symboly atd.</p>

<p>Vývojáři by však neměli tyto možnosti nabízené programovacím jazykem
<i>Clojure</i> zneužívat, protože tím znemožňují využití některých
optimalizačních technik a v&nbsp;neposlední řadě si taktéž komplikují možnost
testování takto vytvořených funkcí. Namísto toho se ukazuje být velmi výhodné
vytvářet již v&nbsp;perexu zmíněné takzvané <i>referenčně transparentní
funkce</i>, což jsou funkce, které nepřistupují k&nbsp;žádným globálním
symbolům, nemají žádný vedlejší efekt ani si nepamatují žádný vnitřní stav
(příkladem &bdquo;funkce&ldquo; s&nbsp;vnitřním stavem je například
<strong>Math/random</strong>). Referenčně transparentní funkci jsou při jejím
volání předány parametry a funkce <strong>pouze</strong> na základě hodnot
předaných parametrů vrátí nějaký výsledek. Tato (pochopitelná) vlastnost má
jeden důležitý důsledek &ndash; chování referenčně transparentní funkce je
nezávislé na stavu aplikace a je taktéž zcela nezávislé na tom, kdy je funkce
zavolána.</p>

<p>Pravděpodobně nejjednodušší ukázka funkce, která není referenčně
transparentní:</p>

<pre>
(defn <strong>random</strong>
    []
    (java.lang.Math/random))
</pre>

<p>Referenčně transparentní funkce jsou typicky používány ve frameworku
<i>Clojure Ring</i>:</p>

<pre>
(defn <strong>handler</strong>
    [request]
    (let [params (:params request)
          x      (param-&gt;number params "x")
          y      (param-&gt;number params "y")
          result (compute-result x y)]
    (-&gt; (response/response (render-html-page x y result))
        (response/content-type "text/html; charset=utf-8"))))
</pre>



<p><a name="k03"></a></p>
<h2 id="k03">3. Jak testovat funkce, které tisknou na standardní či chybový výstup?</h2>

<p>Při tvorbě reálných aplikací v&nbsp;programovacím jazyku <i>Clojure</i> se
poměrně často setkáme s&nbsp;následujícím problémem: máme za úkol otevřít
nějaký zdroj dat (databázi, soubor...), přečíst z&nbsp;tohoto zdroje data a
posléze zdroj dat opět zavřít. Dalším praktickým problémem je nastavení
přesnosti a zaokrouhlovacího režimu pro objekty typu
<strong>BigDecimal</strong>, provedení nějaké matematické operace a následně
obnovení původní přesnosti a zaokrouhlovacího režimu. Všechny tyto problémy
tedy vyžadují, aby se provedla nějaká nastavovací operace, která většinou mění
prostředí programu, posléze se provede vlastní výpočet/sekvence příkazů a
nakonec se obnoví původní prostředí programu. Takto chápané operace se
v&nbsp;programovacím jazyce <i>Clojure</i> poměrně často implementují
s&nbsp;využitím maker, jejichž název začíná na <strong>with-</strong>.
Příkladem může být makro <strong>with-precision</strong> pro dočasnou změnu
přesnosti a zaokrouhlovacího režimu pro objekty typu
<strong>BigDecimal</strong>:</p>

<pre>
user=&gt; <strong>(with-precision 1 (/ 1M 3))</strong>
0.3M
&nbsp;
&nbsp;
user=&gt; <strong>(with-precision 2 (/ 1M 3))</strong>
0.33M
&nbsp;
&nbsp;
user=&gt; <strong>(with-precision 10 (/ 1M 3))</strong>
0.3333333333M
&nbsp;
&nbsp;
user=&gt;
</pre>

<p>Proč se vlastně o makrech <strong>with-*</strong> zmiňujeme zrovna
v&nbsp;dnešním článku věnovaném tvorbě testů? Určité problémy s&nbsp;testováním
totiž nastanou již ve chvíli, kdy testovaná funkce provádí tisk na standardní
či na chybový výstup. Již tato &bdquo;maličkost&ldquo; totiž ve skutečnosti
porušuje referenční transparentnost (funkce mění stav objektu
<strong>*out*</strong> či <strong>*err*</strong>), což se vlastně ihned projeví
ve chvíli, kdy je v&nbsp;testu nutné ověřit, zda funkce skutečně na
standardní/chybový výstup tiskne korektní zprávy. Jedna z&nbsp;možností, jak
takové funkce testovat, spočívá v&nbsp;použití makra nazvaného
<strong>with-out-str</strong>, které dokáže &bdquo;zachytit&ldquo; všechna
volání funkcí <strong>print</strong> a <strong>println</strong>. Řetězce,
které by se pomocí těchto funkcí normálně vypsaly na standardní výstup, jsou
namísto využity jako návratová hodnota makra:</p>

<pre>
user=&gt; <strong>(with-out-str (print "Hello ") (print "world") (print '!))</strong>
"Hello world!"
&nbsp;
&nbsp;
user=&gt; <strong>(def vystup (with-out-str (print "Hello ") (print "world") (print '!)))</strong>
#'user/vystup
&nbsp;
&nbsp;
user=&gt; <strong>vystup</strong>
"Hello world!"
&nbsp;
&nbsp;
user=&gt;
</pre>

<p>Jak již bylo řečeno v&nbsp;úvodním odstavci, pracují makra
<strong>with-</strong> takovým způsobem, že dočasně změní prostředí programu.
Nejinak je tomu i v&nbsp;případě makra <strong>with-out-str</strong>, kde se
dočasně změní objekt navázaný na symbol <strong>*out*</strong>, jenž
představuje standardní výstup, neboli v&nbsp;řeči Javy
<strong>System.out</strong>. Symbol <strong>*out*</strong> je při provádění
příkazů předaných makru přesměrován na novou instanci objektu
<strong>java.io.StringWriter</strong>, který je po provedení těla převeden na
řetězec s&nbsp;využitím funkce <strong>str</strong>:</p>

<pre>
(defmacro <strong>with-out-str</strong>
  <i>"Evaluates exprs in a context in which *out* is bound to a fresh</i>
  <i>StringWriter.  Returns the string created by any nested printing</i>
  <i>calls."</i>
  {:added "1.0"}
  [&amp; body]
  `(let [s# (new java.io.StringWriter)]
      (binding [*out* s#]
          ~@body
          (str s#))))
</pre>



<p><a name="k04"></a></p>
<h2 id="k04">4. Makro <strong>with-out-str</strong></h2>

<p>Doplňme si nyní test pro první demonstrační příklad o zjištění, zda funkce
<strong>add</strong> tiskne na standardní výstup očekávané zprávy. Rozšíření
testu není složité, protože pouze namísto návratové hodnoty testujeme text
zachycený makrem <strong>with-out-str</strong>:</p>

<pre>
(ns <strong>testing1.core-test</strong>
    (:require [clojure.test :refer :all]
              [testing1.core :refer :all]))
&nbsp;
(deftest <strong>test-add-1</strong>
    (testing "function add"
        (is (= 0 (add 0 0)))
        (is (= 3 (add 1 2)))
        (is (= 5/6 (add 1/2 1/3)))))
&nbsp;
(deftest <strong>test-add-2</strong>
    (testing "function add"
        (are [x y] (= x y)
            0   (add 0 0)
            3   (add 1 2)
            5/6 (add 1/2 1/3))))
&nbsp;
(deftest <strong>test-add-3</strong>
    (testing "function add"
        (is (= "Adding 0 to 0\n"     (with-out-str (add 0 0))))
        (is (= "Adding 1 to 2\n"     (with-out-str (add 1 2))))
        (is (= "Adding 1/2 to 1/3\n" (with-out-str (add 1/2 1/3))))))
&nbsp;
(deftest <strong>test-add-4</strong>
    (testing "function add"
        (are [x y] (= x y)
            "Adding 0 to 0\n"     (with-out-str (add 0 0))
            "Adding 1 to 2\n"     (with-out-str (add 1 2))
            "Adding 1/2 to 1/3\n" (with-out-str (add 1/2 1/3)))))
</pre>

<p>Rozšířený test odzkoušíme:</p>

<pre>
<strong>lein test</strong>
&nbsp;
lein test testing1.core-test
Adding 0 to 0
Adding 1 to 2
Adding 1/2 to 1/3
Adding 0 to 0
Adding 1 to 2
Adding 1/2 to 1/3
&nbsp;
Ran 4 tests containing 12 assertions.
0 failures, 0 errors.
</pre>

<p>Poznámka: řádky začínající na &bdquo;Adding&ldquo; byly vypsány
v&nbsp;prvních dvou testech <strong>test-add-1</strong> a
<strong>test-add-2</strong>, zatímco ve zbývajících testech
<strong>test-add-3</strong> a <strong>test-add-4</strong> byl výstup zachycen a
nijak viditelně se při spuštění testů neprojeví.</p>



<p><a name="k05"></a></p>
<h2 id="k05">5. Mockování funkcí volaných v&nbsp;průběhu testování</h2>

<p>Podívejme se nyní na nepatrně složitější demonstrační příklad nazvaný
<strong>testing2</strong>, v&nbsp;němž jsou použity funkce pracující s&nbsp;SQL
databází SQLite. Projektový soubor tohoto demonstračního příkladu vypadá
následovně (povšimněte si především dvou nových prvků uložených ve vektoru
:dependencies:</p>

<pre>
(defproject <strong>testing2</strong> "0.1.0-SNAPSHOT"
  :description "FIXME: write description"
  :url "http://example.com/FIXME"
  :license {:name "Eclipse Public License"
            :url "http://www.eclipse.org/legal/epl-v10.html"}
  :dependencies [[org.clojure/clojure "1.6.0"]
                 <strong>[org.clojure/java.jdbc "0.3.5"]</strong>
                 <strong>[org.xerial/sqlite-jdbc "3.7.2"]</strong>]
  :main ^:skip-aot testing2.core
  :target-path "target/%s"
  :profiles {:uberjar {:aot :all}})
</pre>

<p>V&nbsp;hlavním modulu jsou mj.&nbsp;deklarovány funkce pro čtení
z&nbsp;databáze i pro zápis do databáze:</p>

<pre>
(ns <strong>testing2.core</strong>
    (:gen-class))
&nbsp;
(require '[clojure.java.jdbc :as jdbc])
&nbsp;
(def <strong>changes-db</strong>
    {:classname   "org.sqlite.JDBC"
     :subprotocol "sqlite"
     :subname     "changes.db"
    })
&nbsp;
(defn <strong>read-changes-for-user</strong>
    [user-name]
    (jdbc/query changes-db
        [(str "select * from changes where user_name=? order by id;") user-name]))
&nbsp;
(defn <strong>store-changes</strong>
    [user-name package description date]
    (jdbc/insert! changes-db :changes
        {:date_time date :user_name user-name :package package :description description}))
&nbsp;
(defn <strong>count-changes-for-user</strong>
    [user-name]
    (count (read-changes-for-user user-name)))
&nbsp;
(defn <strong>-main</strong>
    [&amp; args]
    (println "Hello, World!"))
</pre>

<p>Problém může nastat ve chvíli, kdy je zapotřebí otestovat například funkci
<strong>read-changes-for-user</strong> nebo <strong>store-changes</strong>.
Existuje několik způsobů, jak je možné tento problém vyřešit; například se
namísto skutečné databáze použije jen její omezená varianta (typicky in-memory
databáze naplněná jen nejnutnějšími a předem známými daty).
V&nbsp;programovacím jazyce <i>Clojure</i> však existuje ještě jedna možnost
&ndash; mocking (to je ale slovo!) funkcí <strong>jdbc/query</strong> a
<strong>jdbc/insert</strong> a jejich náhrada za uživatelsky definované funkce,
které se vůči okolnímu kódu chovají jako původní funkce, ale ve skutečnosti
provádí jinou činnost, například namísto čtení z&nbsp;databáze vrací konstantu
atd. V&nbsp;následující kapitole si ukážeme, jak se tato problematika řeší
s&nbsp;využitím makra <strong>with-redefs</strong>.</p>



<p><a name="k06"></a></p>
<h2 id="k06">6. Makro <strong>with-redefs</strong></h2>

<p>Testovací modul, který bude (například) testovat korektnost funkcí
<strong>read-changes-for-user</strong> a
<strong>count-changes-for-user</strong> může používat makro nazvané
<strong>with-redefs</strong>. V&nbsp;těle tohoto makra je původní symbol
navázán na jinou hodnotu. V&nbsp;našem konkrétním příkladu potřebujeme na
symbol <strong>jdbc/query</strong> (povšimněte si použití jmenného prostoru!)
navázat jinou funkci. Původní funkce <strong>clojure.java.jdbc/query</strong>
je volána se dvěma parametry, což bude platit i pro novou uživatelskou
funkci:</p>

<pre>
(<strong>with-redefs</strong> [jdbc/query (fn [db-spec query] (tělo_nové_anonymní_funkce))]
<i>;</i>
<i>; v těle makra je jdbc/query navázáno na novou anonymní funkci</i>
<i>;</i>
)
</pre>

<p>Důležité je, že mimo tělo makra <strong>with-redefs</strong> je na symbol
<strong>jdbc/query</strong> navázána původní funkce pracující s&nbsp;SQL
databázemi!</p>

<p>Testovací modul lze napsat například následujícím způsobem. Povšimněte si,
že v&nbsp;testu <strong>test-read-changes-for-user</strong> vrací lokálně
deklarovaná anonymní funkce navázaná na symbol <strong>jdbc/query</strong>
druhý prvek druhého parametru (což je předané jméno), zatímco v&nbsp;testu
<strong>test-count-changes-for-user</strong> se vrací konstantní desetiprvkový
vektor:</p>

<pre>
(ns <strong>testing2.core-test</strong>
  (:require [clojure.test :refer :all]
            [testing2.core :refer :all]))
&nbsp;
(require '[clojure.java.jdbc :as jdbc])
&nbsp;
(deftest <strong>test-read-changes-for-user</strong>
    (testing "read-changes-for-user"
        <i>; use mock instead of jdbc/query</i>
        (with-redefs [jdbc/query (fn [db-spec query] (second query))]
            (is (= "Pavel" (read-changes-for-user "Pavel"))))))
&nbsp;
(deftest <strong>test-count-changes-for-user</strong>
    (testing "read-changes-for-user"
        <i>; use mock instead of jdbc/query</i>
        (with-redefs [jdbc/query (fn [db-spec query] [1 2 3 4 5 6 7 8 9 10])]
            (is (= 10 (count-changes-for-user "Pavel"))))))
</pre>

<p>Test si opět odzkoušíme:</p>

<pre>
<strong>lein test</strong>
&nbsp;
lein test testing2.core-test
&nbsp;
Ran 2 tests containing 2 assertions.
0 failures, 0 errors.
</pre>

<p>Poznámka: lokálně nahradit je možné prakticky libovolnou funkci
z&nbsp;libovolného jmenného prostoru.</p>

<p>Poznámka 2: namísto makra <strong>with-redefs</strong> je možné použít i
přímo funkci <strong>with-redefs-fn</strong>, která je mimochodem v&nbsp;makru
<strong>with-redefs</strong> volána.</p>



<p><a name="k07"></a></p>
<h2 id="k07">7. Zjištění existence funkcí či proměnných v&nbsp;testovaném jmenném prostoru</h2>

<p>V&nbsp;některých případech je nutné v&nbsp;testu zjistit, zda nějaká funkce
či proměnná existuje. Pro tento účel se mi vyplatilo deklarovat si pomocnou
funkci (přesněji řečeno predikát) nazvanou <strong>callable?</strong>. Tomuto
predikátu se předá libovolný symbol a pokud je tento symbol navázán na
skutečnou funkci, vrátí se hodnota <strong>true</strong>, jinak
<strong>false</strong>:</p>

<pre>
(defn <strong>callable?</strong>
    <i>"Test if given function-name is bound to the real function."</i>
    [function-name]
    (clojure.test/function? function-name))
</pre>

<p>Test na existenci proměnné (či proměnných) lze zajistit predikátem
<strong>bound?</strong>, který se použije následujícím způsobem:</p>

<pre>
(bound? (find-var 'jméno.modulu/symbol)
</pre>



<p><a name="k08"></a></p>
<h2 id="k08">8. Predikát <strong>clojure.test/function?</strong></h2>

<p>Jen stručně se podívejme na použití výše zmíněného predikátu
<strong>function?</strong> při psaní testů. Mějme modul, který se má
otestovat:</p>

<pre>
(ns <strong>testing3.core</strong>
    (:gen-class))
&nbsp;
(defn <strong>add</strong>
    [x y]
    (println "Adding" x "to" y)
    (+ x y))
&nbsp;
(defn <strong>-main</strong>
    [&amp; args]
    (println (add 1 2)))
</pre>

<p>Dva nové testy nazvané <strong>test-main-existence</strong> a
<strong>test-add-existence</strong> pouze zjišťují existenci funkce
<strong>-main</strong> a <strong>add</strong> z&nbsp;hlavního modulu, tedy
konkrétně ze jmenného prostoru <strong>testing3.core</strong>:</p>

<pre>
(ns <strong>testing3.core-test</strong>
    (:require [clojure.test :refer :all]
              [testing3.core :refer :all]))
&nbsp;
(defn <strong>callable?</strong>
    <i>"Test if given function-name is bound to the real function."</i>
    [function-name]
    (clojure.test/function? function-name))
&nbsp;
(deftest <strong>test-main-existence</strong>
    <i>"Check that the testing3.core/-main definition exists."</i>
    (testing "if the testing3.core/-main definition exists."
        (is (callable? 'testing3.core/-main))))
&nbsp;
(deftest <strong>test-add-existence</strong>
    <i>"Check that the testing3.core/add definition exists."</i>
    (testing "if the testing3.core/add definition exists."
        (is (callable? 'testing3.core/add))))
&nbsp;
(deftest <strong>test-add-1</strong>
    (testing "function add"
        (is (= 0 (add 0 0)))
        (is (= 3 (add 1 2)))
        (is (= 5/6 (add 1/2 1/3)))))
</pre>

<p>Obligátní zjištění, zda všechny testy proběhnou bez chyb:</p>

<pre>
<strong>lein test</strong>
&nbsp;
Adding 0 to 0
Adding 1 to 2
Adding 1/2 to 1/3
&nbsp;
Ran 3 tests containing 5 assertions.
0 failures, 0 errors.
</pre>



<p><a name="k09"></a></p>
<h2 id="k09">9. Repositář s&nbsp;dnešními demonstračními příklady</h2>

<p>Všechny tři dnes zmíněné demonstrační příklady byly, podobně jako
v&nbsp;předchozích částech tohoto seriálu, uloženy do Git repositáře dostupného
na adrese <a
href="https://github.com/tisnik/clojure-examples">https://github.com/tisnik/clojure-examples</a>.
V&nbsp;tabulce zobrazené pod tímto odstavcem naleznete na zdrojové kódy
jednotlivých demonstračních příkladů přímé odkazy:</p>

<table>
<tr><th>#</th><th>Příklad </th><th>Github</th></tr>
<tr><td>1</td><td>testing1</td><td><a href="https://github.com/tisnik/clojure-examples/tree/master/testing1">https://github.com/tisnik/clojure-examples/tree/master/testing1</a></td></tr>
<tr><td>2</td><td>testing2</td><td><a href="https://github.com/tisnik/clojure-examples/tree/master/testing2">https://github.com/tisnik/clojure-examples/tree/master/testing2</a></td></tr>
<tr><td>3</td><td>testing3</td><td><a href="https://github.com/tisnik/clojure-examples/tree/master/testing3">https://github.com/tisnik/clojure-examples/tree/master/testing3</a></td></tr>
</table>



<p><a name="k10"></a></p>
<h2 id="k10">10. Odkazy na předchozí části tohoto seriálu</h2>

<ol>

<li>Leiningen: nástroj pro správu projektů napsaných v Clojure<br />
<a href="http://www.root.cz/clanky/leiningen-nastroj-pro-spravu-projektu-napsanych-v-clojure/">http://www.root.cz/clanky/leiningen-nastroj-pro-spravu-projektu-napsanych-v-clojure/</a>
</li>

<li>Leiningen: nástroj pro správu projektů napsaných v Clojure (2)<br />
<a href="http://www.root.cz/clanky/leiningen-nastroj-pro-spravu-projektu-napsanych-v-clojure-2/">http://www.root.cz/clanky/leiningen-nastroj-pro-spravu-projektu-napsanych-v-clojure-2/</a>
</li>

<li>Leiningen: nástroj pro správu projektů napsaných v Clojure (3)<br />
<a href="http://www.root.cz/clanky/leiningen-nastroj-pro-spravu-projektu-napsanych-v-clojure-3/">http://www.root.cz/clanky/leiningen-nastroj-pro-spravu-projektu-napsanych-v-clojure-3/</a>
</li>

<li>Leiningen: nástroj pro správu projektů napsaných v Clojure (4)<br />
<a href="http://www.root.cz/clanky/leiningen-nastroj-pro-spravu-projektu-napsanych-v-clojure-4/">http://www.root.cz/clanky/leiningen-nastroj-pro-spravu-projektu-napsanych-v-clojure-4/</a>
</li>

<li>Leiningen: nástroj pro správu projektů napsaných v Clojure (5)<br />
<a href="http://www.root.cz/clanky/leiningen-nastroj-pro-spravu-projektu-napsanych-v-clojure-5/">http://www.root.cz/clanky/leiningen-nastroj-pro-spravu-projektu-napsanych-v-clojure-5/</a>
</li>

<li>Leiningen: nástroj pro správu projektů napsaných v Clojure (6)<br />
<a href="http://www.root.cz/clanky/leiningen-nastroj-pro-spravu-projektu-napsanych-v-clojure-6/">http://www.root.cz/clanky/leiningen-nastroj-pro-spravu-projektu-napsanych-v-clojure-6/</a>
</li>

<li>Programovací jazyk Clojure a databáze (1.část)<br />
<a href="http://www.root.cz/clanky/programovaci-jazyk-clojure-a-databaze-1-cast/">http://www.root.cz/clanky/programovaci-jazyk-clojure-a-databaze-1-cast/</a>
</li>

<li>Pluginy pro Leiningen<br />
<a href="http://www.root.cz/clanky/leiningen-nastroj-pro-spravu-projektu-napsanych-v-clojure-pluginy-pro-leiningen/">http://www.root.cz/clanky/leiningen-nastroj-pro-spravu-projektu-napsanych-v-clojure-pluginy-pro-leiningen/</a>
</li>

<li>Programovací jazyk Clojure a knihovny pro práci s vektory a maticemi<br />
<a href="http://www.root.cz/clanky/programovaci-jazyk-clojure-a-knihovny-pro-praci-s-vektory-a-maticemi/">http://www.root.cz/clanky/programovaci-jazyk-clojure-a-knihovny-pro-praci-s-vektory-a-maticemi/</a>
</li>

<li>Programovací jazyk Clojure a knihovny pro práci s vektory a maticemi (2)<br />
<a href="http://www.root.cz/clanky/programovaci-jazyk-clojure-a-knihovny-pro-praci-s-vektory-a-maticemi-2/">http://www.root.cz/clanky/programovaci-jazyk-clojure-a-knihovny-pro-praci-s-vektory-a-maticemi-2/</a>
</li>

<li>Programovací jazyk Clojure: syntéza procedurálních textur s využitím knihovny Clisk<br />
<a href="http://www.root.cz/clanky/programovaci-jazyk-clojure-synteza-proceduralnich-textur-s-vyuzitim-knihovny-clisk/">http://www.root.cz/clanky/programovaci-jazyk-clojure-synteza-proceduralnich-textur-s-vyuzitim-knihovny-clisk/</a>
</li>

<li>Programovací jazyk Clojure: syntéza procedurálních textur s využitím knihovny Clisk (2)<br />
<a href="http://www.root.cz/clanky/programovaci-jazyk-clojure-synteza-proceduralnich-textur-s-vyuzitim-knihovny-clisk-2/">http://www.root.cz/clanky/programovaci-jazyk-clojure-synteza-proceduralnich-textur-s-vyuzitim-knihovny-clisk-2/</a>
</li>

<li>Programovací jazyk Clojure: syntéza procedurálních textur s využitím knihovny Clisk (dokončení)<br />
<a href="http://www.root.cz/clanky/programovaci-jazyk-clojure-synteza-proceduralnich-textur-s-vyuzitim-knihovny-clisk-dokonceni/">http://www.root.cz/clanky/programovaci-jazyk-clojure-synteza-proceduralnich-textur-s-vyuzitim-knihovny-clisk-dokonceni/</a>
</li>

<li>Seesaw: knihovna pro snadnou tvorbu GUI v jazyce Clojure<br />
<a href="http://www.root.cz/clanky/seesaw-knihovna-pro-snadnou-tvorbu-gui-v-jazyce-clojure/">http://www.root.cz/clanky/seesaw-knihovna-pro-snadnou-tvorbu-gui-v-jazyce-clojure/</a>
</li>

<li>Seesaw: knihovna pro snadnou tvorbu GUI v jazyce Clojure (2)<br />
<a href="http://www.root.cz/clanky/seesaw-knihovna-pro-snadnou-tvorbu-gui-v-jazyce-clojure-2/">http://www.root.cz/clanky/seesaw-knihovna-pro-snadnou-tvorbu-gui-v-jazyce-clojure-2/</a>
</li>

<li>Seesaw: knihovna pro snadnou tvorbu GUI v jazyce Clojure (3)<br />
<a href="http://www.root.cz/clanky/seesaw-knihovna-pro-snadnou-tvorbu-gui-v-jazyce-clojure-3/">http://www.root.cz/clanky/seesaw-knihovna-pro-snadnou-tvorbu-gui-v-jazyce-clojure-3/</a>
</li>

<li>Programovací jazyk Clojure a práce s Gitem<br />
<a href="http://www.root.cz/clanky/programovaci-jazyk-clojure-a-prace-s-gitem/">http://www.root.cz/clanky/programovaci-jazyk-clojure-a-prace-s-gitem/</a>
</li>

<li>Programovací jazyk Clojure a práce s Gitem (2)<br />
<a href="http://www.root.cz/clanky/programovaci-jazyk-clojure-a-prace-s-gitem-2/">http://www.root.cz/clanky/programovaci-jazyk-clojure-a-prace-s-gitem-2/</a>
</li>

<li>Programovací jazyk Clojure – triky při práci s řetězci<br />
<a href="http://www.root.cz/clanky/programovaci-jazyk-clojure-triky-pri-praci-s-retezci/">http://www.root.cz/clanky/programovaci-jazyk-clojure-triky-pri-praci-s-retezci/</a>
</li>

<li>Programovací jazyk Clojure – triky při práci s kolekcemi<br />
<a href="http://www.root.cz/clanky/programovaci-jazyk-clojure-triky-pri-praci-s-kolekcemi/">http://www.root.cz/clanky/programovaci-jazyk-clojure-triky-pri-praci-s-kolekcemi/</a>
</li>

<li>Programovací jazyk Clojure – práce s mapami a množinami<br />
<a href="http://www.root.cz/clanky/programovaci-jazyk-clojure-prace-s-mapami-a-mnozinami/">http://www.root.cz/clanky/programovaci-jazyk-clojure-prace-s-mapami-a-mnozinami/</a>
</li>

<li>Programovací jazyk Clojure – základy zpracování XML<br />
<a href="http://www.root.cz/clanky/programovaci-jazyk-clojure-zaklady-zpracovani-xml/">http://www.root.cz/clanky/programovaci-jazyk-clojure-zaklady-zpracovani-xml/</a>
</li>

<li>Programovací jazyk Clojure – testování s využitím knihovny Expectations<br />
<a href="http://www.root.cz/clanky/programovaci-jazyk-clojure-testovani-s-vyuzitim-knihovny-expectations/">http://www.root.cz/clanky/programovaci-jazyk-clojure-testovani-s-vyuzitim-knihovny-expectations/</a>
</li>

</ol>



<p><a name="k11"></a></p>
<h2 id="k11">11. Odkazy na Internetu</h2>

<ol>

<li>Expectations: příklady atd.<br />
<a href="http://jayfields.com/expectations/">http://jayfields.com/expectations/</a>
</li>

<li>Expectations na GitHubu<br />
<a href="https://github.com/jaycfields/expectations">https://github.com/jaycfields/expectations</a>
</li>

<li>Lein-expectations na GitHubu<br />
<a href="https://github.com/gar3thjon3s/lein-expectations">https://github.com/gar3thjon3s/lein-expectations</a>
</li>

<li>Testing Clojure With Expectations<br />
<a href="https://semaphoreci.com/blog/2014/09/23/testing-clojure-with-expectations.html">https://semaphoreci.com/blog/2014/09/23/testing-clojure-with-expectations.html</a>
</li>

<li>Clojure testing TDD/BDD libraries: clojure.test vs Midje vs Expectations vs Speclj<br />
<a href="https://www.reddit.com/r/Clojure/comments/1viilt/clojure_testing_tddbdd_libraries_clojuretest_vs/">https://www.reddit.com/r/Clojure/comments/1viilt/clojure_testing_tddbdd_libraries_clojuretest_vs/</a>
</li>

<li>Testing: One assertion per test<br />
<a href="http://blog.jayfields.com/2007/06/testing-one-assertion-per-test.html">http://blog.jayfields.com/2007/06/testing-one-assertion-per-test.html</a>
</li>

<li>Rewriting Your Test Suite in Clojure in 24 hours<br />
<a href="http://blog.circleci.com/rewriting-your-test-suite-in-clojure-in-24-hours/">http://blog.circleci.com/rewriting-your-test-suite-in-clojure-in-24-hours/</a>
</li>

<li>Clojure doc: zipper<br />
<a href="http://clojuredocs.org/clojure.zip/zipper">http://clojuredocs.org/clojure.zip/zipper</a>
</li>

<li>Clojure doc: parse<br />
<a href="http://clojuredocs.org/clojure.xml/parse">http://clojuredocs.org/clojure.xml/parse</a>
</li>

<li>Clojure doc: xml-zip<br />
<a href="http://clojuredocs.org/clojure.zip/xml-zip">http://clojuredocs.org/clojure.zip/xml-zip</a>
</li>

<li>Clojure doc: xml-seq<br />
<a href="http://clojuredocs.org/clojure.core/xml-seq">http://clojuredocs.org/clojure.core/xml-seq</a>
</li>

<li>Parsing XML in Clojure<br />
<a href="https://github.com/clojuredocs/guides">https://github.com/clojuredocs/guides</a>
</li>

<li>Clojure Zipper Over Nested Vector<br />
<a href="https://vitalyper.wordpress.com/2010/11/23/clojure-zipper-over-nested-vector/">https://vitalyper.wordpress.com/2010/11/23/clojure-zipper-over-nested-vector/</a>
</li>

<li>Understanding Clojure's PersistentVector implementation<br />
<a href="http://blog.higher-order.net/2009/02/01/understanding-clojures-persistentvector-implementation">http://blog.higher-order.net/2009/02/01/understanding-clojures-persistentvector-implementation</a>
</li>

<li>Understanding Clojure's PersistentHashMap (deftwice...)<br />
<a href="http://blog.higher-order.net/2009/09/08/understanding-clojures-persistenthashmap-deftwice.html">http://blog.higher-order.net/2009/09/08/understanding-clojures-persistenthashmap-deftwice.html</a>
</li>

<li>Assoc and Clojure's PersistentHashMap: part ii<br />
<a href="http://blog.higher-order.net/2010/08/16/assoc-and-clojures-persistenthashmap-part-ii.html">http://blog.higher-order.net/2010/08/16/assoc-and-clojures-persistenthashmap-part-ii.html</a>
</li>

<li>Ideal Hashtrees (paper)<br />
<a href="http://lampwww.epfl.ch/papers/idealhashtrees.pdf">http://lampwww.epfl.ch/papers/idealhashtrees.pdf</a>
</li>

<li>Clojure home page<br />
<a href="http://clojure.org/">http://clojure.org/</a>
</li>

<li>Clojure (downloads)<br />
<a href="http://clojure.org/downloads">http://clojure.org/downloads</a>
</li>

<li>Clojure Sequences<br />
<a href="http://clojure.org/sequences">http://clojure.org/sequences</a>
</li>

<li>Clojure Data Structures<br />
<a href="http://clojure.org/data_structures">http://clojure.org/data_structures</a>
</li>

<li>The Structure and Interpretation of Computer Programs: 2.2.1  Representing Sequences<br />
<a href="http://mitpress.mit.edu/sicp/full-text/book/book-Z-H-15.html#%_sec_2.2.1">http://mitpress.mit.edu/sicp/full-text/book/book-Z-H-15.html#%_sec_2.2.1</a>
</li>

<li>The Structure and Interpretation of Computer Programs: 3.3.1  Mutable List Structure<br />
<a href="http://mitpress.mit.edu/sicp/full-text/book/book-Z-H-22.html#%_sec_3.3.1">http://mitpress.mit.edu/sicp/full-text/book/book-Z-H-22.html#%_sec_3.3.1</a>
</li>

<li>Clojure - Functional Programming for the JVM<br />
<a href="http://java.ociweb.com/mark/clojure/article.html">http://java.ociweb.com/mark/clojure/article.html</a>
</li>

<li>Clojure quick reference<br />
<a href="http://faustus.webatu.com/clj-quick-ref.html">http://faustus.webatu.com/clj-quick-ref.html</a>
</li>

<li>4Clojure<br />
<a href="http://www.4clojure.com/">http://www.4clojure.com/</a>
</li>

<li>ClojureDoc (rozcestník s&nbsp;dokumentací jazyka Clojure)<br />
<a href="http://clojuredocs.org/">http://clojuredocs.org/</a>
</li>

<li>Clojure (na Wikipedia EN)<br />
<a href="http://en.wikipedia.org/wiki/Clojure">http://en.wikipedia.org/wiki/Clojure</a>
</li>

<li>Clojure (na Wikipedia CS)<br />
<a href="http://cs.wikipedia.org/wiki/Clojure">http://cs.wikipedia.org/wiki/Clojure</a>
</li>

<li>SICP (The Structure and Interpretation of Computer Programs)<br />
<a href="http://mitpress.mit.edu/sicp/">http://mitpress.mit.edu/sicp/</a>
</li>

<li>Pure function<br />
<a href="http://en.wikipedia.org/wiki/Pure_function">http://en.wikipedia.org/wiki/Pure_function</a>
</li>

<li>Funkcionální programování<br />
<a href="http://cs.wikipedia.org/wiki/Funkcionální_programování">http://cs.wikipedia.org/wiki/Funkcionální_programování</a>
</li>

<li>Čistě funkcionální (datové struktury, jazyky, programování)<br />
<a href="http://cs.wikipedia.org/wiki/Čistě_funkcionální">http://cs.wikipedia.org/wiki/Čistě_funkcionální</a>
</li>

<li>Clojure Macro Tutorial (Part I, Getting the Compiler to Write Your Code For You)<br />
<a href="http://www.learningclojure.com/2010/09/clojure-macro-tutorial-part-i-getting.html">http://www.learningclojure.com/2010/09/clojure-macro-tutorial-part-i-getting.html</a>
</li>

<li>Clojure Macro Tutorial (Part II: The Compiler Strikes Back)<br />
<a href="http://www.learningclojure.com/2010/09/clojure-macro-tutorial-part-ii-compiler.html">http://www.learningclojure.com/2010/09/clojure-macro-tutorial-part-ii-compiler.html</a>
</li>

<li>Clojure Macro Tutorial (Part III: Syntax Quote)<br />
<a href="http://www.learningclojure.com/2010/09/clojure-macro-tutorial-part-ii-syntax.html">http://www.learningclojure.com/2010/09/clojure-macro-tutorial-part-ii-syntax.html</a>
</li>

<li>Tech behind Tech: Clojure Macros Simplified<br />
<a href="http://techbehindtech.com/2010/09/28/clojure-macros-simplified/">http://techbehindtech.com/2010/09/28/clojure-macros-simplified/</a>
</li>

<li>Fatvat - Exploring functional programming: Clojure Macros<br />
<a href="http://www.fatvat.co.uk/2009/02/clojure-macros.html">http://www.fatvat.co.uk/2009/02/clojure-macros.html</a>
</li>

<li>Eulerovo číslo<br />
<a href="http://cs.wikipedia.org/wiki/Eulerovo_číslo">http://cs.wikipedia.org/wiki/Eulerovo_číslo</a>
</li>

<li>List comprehension<br />
<a href="http://en.wikipedia.org/wiki/List_comprehension">http://en.wikipedia.org/wiki/List_comprehension</a>
</li>

<li>List Comprehensions in Clojure<br />
<a href="http://asymmetrical-view.com/2008/11/18/list-comprehensions-in-clojure.html">http://asymmetrical-view.com/2008/11/18/list-comprehensions-in-clojure.html</a>
</li>

<li>Clojure Programming Concepts: List Comprehension<br />
<a href="http://en.wikibooks.org/wiki/Clojure_Programming/Concepts#List_Comprehension">http://en.wikibooks.org/wiki/Clojure_Programming/Concepts#List_Comprehension</a>
</li>

<li>Clojure core API: for macro<br />
<a href="http://clojure.github.com/clojure/clojure.core-api.html#clojure.core/for">http://clojure.github.com/clojure/clojure.core-api.html#clojure.core/for</a>
</li>

<li>cirrus machina - The Clojure for macro<br />
<a href="http://www.cirrusmachina.com/blog/comment/the-clojure-for-macro/">http://www.cirrusmachina.com/blog/comment/the-clojure-for-macro/</a>
</li>

<li>Riastradh's Lisp Style Rules<br />
<a href="http://mumble.net/~campbell/scheme/style.txt">http://mumble.net/~campbell/scheme/style.txt</a>
</li>

<li>Dynamic Languages Strike Back<br />
<a href="http://steve-yegge.blogspot.cz/2008/05/dynamic-languages-strike-back.html">http://steve-yegge.blogspot.cz/2008/05/dynamic-languages-strike-back.html</a>
</li>

<li>Scripting: Higher Level Programming for the 21st Century<br />
<a href="http://www.tcl.tk/doc/scripting.html">http://www.tcl.tk/doc/scripting.html</a>
</li>

<li>Java Virtual Machine Support for Non-Java Languages<br />
<a href="http://docs.oracle.com/javase/7/docs/technotes/guides/vm/multiple-language-support.html">http://docs.oracle.com/javase/7/docs/technotes/guides/vm/multiple-language-support.html</a>
</li>

<li>Třída java.lang.String<br />
<a href="http://docs.oracle.com/javase/7/docs/api/java/lang/String.html">http://docs.oracle.com/javase/7/docs/api/java/lang/String.html</a>
</li>

<li>Třída java.lang.StringBuffer<br />
<a href="http://docs.oracle.com/javase/7/docs/api/java/lang/StringBuffer.html">http://docs.oracle.com/javase/7/docs/api/java/lang/StringBuffer.html</a>
</li>

<li>Třída java.lang.StringBuilder<br />
<a href="http://docs.oracle.com/javase/7/docs/api/java/lang/StringBuilder.html">http://docs.oracle.com/javase/7/docs/api/java/lang/StringBuilder.html</a>
</li>

<li>StringBuffer versus String<br />
<a href="http://www.javaworld.com/article/2076072/build-ci-sdlc/stringbuffer-versus-string.html">http://www.javaworld.com/article/2076072/build-ci-sdlc/stringbuffer-versus-string.html</a>
</li>

<li>Threading macro (dokumentace k&nbsp;jazyku Clojure)<br />
<a href="https://clojure.github.io/clojure/clojure.core-api.html#clojure.core/-&gt;">https://clojure.github.io/clojure/clojure.core-api.html#clojure.core/-&gt;</a>
</li>

<li>Understanding the Clojure -&gt; macro<br />
<a href="http://blog.fogus.me/2009/09/04/understanding-the-clojure-macro/">http://blog.fogus.me/2009/09/04/understanding-the-clojure-macro/</a>
</li>

<li>clojure.inspector<br />
<a href="http://clojure.github.io/clojure/clojure.inspector-api.html">http://clojure.github.io/clojure/clojure.inspector-api.html</a>
</li>

<li>The Clojure Toolbox<br />
<a href="http://www.clojure-toolbox.com/">http://www.clojure-toolbox.com/</a>
</li>

<li>Unit Testing in Clojure<br />
<a href="http://nakkaya.com/2009/11/18/unit-testing-in-clojure/">http://nakkaya.com/2009/11/18/unit-testing-in-clojure/</a>
</li>

<li>Testing in Clojure (Part-1: Unit testing)<br />
<a href="http://blog.knoldus.com/2014/03/22/testing-in-clojure-part-1-unit-testing/">http://blog.knoldus.com/2014/03/22/testing-in-clojure-part-1-unit-testing/</a>
</li>

<li>API for clojure.test - Clojure v1.6 (stable)<br />
<a href="https://clojure.github.io/clojure/clojure.test-api.html">https://clojure.github.io/clojure/clojure.test-api.html</a>
</li>

<li>Leiningen: úvodní stránka<br />
<a href="http://leiningen.org/">http://leiningen.org/</a>
</li>

<li>Leiningen: Git repository<br />
<a href="https://github.com/technomancy/leiningen">https://github.com/technomancy/leiningen</a>
</li>

<li>leiningen-win-installer<br />
<a href="http://leiningen-win-installer.djpowell.net/">http://leiningen-win-installer.djpowell.net/</a>
</li>

<li>Clojure  1: Úvod<br />
<a href="http://www.root.cz/clanky/clojure-aneb-jazyk-umoznujici-tvorbu-bezpecnych-vicevlaknovych-aplikaci-pro-jvm/">http://www.root.cz/clanky/clojure-aneb-jazyk-umoznujici-tvorbu-bezpecnych-vicevlaknovych-aplikaci-pro-jvm/</a>
</li>

<li>Clojure  2: Symboly, kolekce atd.<br />
<a href="http://www.root.cz/clanky/clojure-aneb-jazyk-umoznujici-tvorbu-bezpecnych-vicevlaknovych-aplikaci-pro-jvm-2-cast/">http://www.root.cz/clanky/clojure-aneb-jazyk-umoznujici-tvorbu-bezpecnych-vicevlaknovych-aplikaci-pro-jvm-2-cast/</a>
</li>

<li>Clojure  3: Funkcionální programování<br />
<a href="http://www.root.cz/clanky/clojure-aneb-jazyk-umoznujici-tvorbu-bezpecnych-vicevlaknovych-aplikaci-pro-jvm-3-cast-funkcionalni-programovani/">http://www.root.cz/clanky/clojure-aneb-jazyk-umoznujici-tvorbu-bezpecnych-vicevlaknovych-aplikaci-pro-jvm-3-cast-funkcionalni-programovani/</a>
</li>

<li>Clojure  4: Kolekce, sekvence a lazy sekvence<br />
<a href="http://www.root.cz/clanky/clojure-aneb-jazyk-umoznujici-tvorbu-bezpecnych-vicevlaknovych-aplikaci-pro-jvm-4-cast-kolekce-sekvence-a-lazy-sekvence/">http://www.root.cz/clanky/clojure-aneb-jazyk-umoznujici-tvorbu-bezpecnych-vicevlaknovych-aplikaci-pro-jvm-4-cast-kolekce-sekvence-a-lazy-sekvence/</a>
</li>

<li>Clojure  5: Sekvence, lazy sekvence a paralelní programy<br />
<a href="http://www.root.cz/clanky/clojure-a-bezpecne-aplikace-pro-jvm-sekvence-lazy-sekvence-a-paralelni-programy/">http://www.root.cz/clanky/clojure-a-bezpecne-aplikace-pro-jvm-sekvence-lazy-sekvence-a-paralelni-programy/</a>
</li>

<li>Clojure  6: Podpora pro paralelní programování<br />
<a href="http://www.root.cz/clanky/programovaci-jazyk-clojure-6-futures-nejsou-jen-financni-derivaty/">http://www.root.cz/clanky/programovaci-jazyk-clojure-6-futures-nejsou-jen-financni-derivaty/</a>
</li>

<li>Clojure  7: Další funkce pro paralelní programování<br />
<a href="http://www.root.cz/clanky/programovaci-jazyk-clojure-7-dalsi-podpurne-prostredky-pro-paralelni-programovani/">http://www.root.cz/clanky/programovaci-jazyk-clojure-7-dalsi-podpurne-prostredky-pro-paralelni-programovani/</a>
</li>

<li>Clojure  8: Identity, stavy, neměnné hodnoty a reference<br />
<a href="http://www.root.cz/clanky/programovaci-jazyk-clojure-8-identity-stavy-nemenne-hodnoty-a-referencni-typy/">http://www.root.cz/clanky/programovaci-jazyk-clojure-8-identity-stavy-nemenne-hodnoty-a-referencni-typy/</a>
</li>

<li>Clojure  9: Validátory, pozorovatelé a kooperace s Javou<br />
<a href="http://www.root.cz/clanky/programovaci-jazyk-clojure-9-validatory-pozorovatele-a-kooperace-mezi-clojure-a-javou/">http://www.root.cz/clanky/programovaci-jazyk-clojure-9-validatory-pozorovatele-a-kooperace-mezi-clojure-a-javou/</a>
</li>

<li>Clojure 10: Kooperace mezi Clojure a Javou<br />
<a href="http://www.root.cz/clanky/programovaci-jazyk-clojure-10-kooperace-mezi-clojure-a-javou-pokracovani/">http://www.root.cz/clanky/programovaci-jazyk-clojure-10-kooperace-mezi-clojure-a-javou-pokracovani/</a>
</li>

<li>Clojure 11: Generátorová notace seznamu/list comprehension<br />
<a href="http://www.root.cz/clanky/programovaci-jazyk-clojure-11-generatorova-notace-seznamu-list-comprehension/">http://www.root.cz/clanky/programovaci-jazyk-clojure-11-generatorova-notace-seznamu-list-comprehension/</a>
</li>

<li>Clojure 12: Překlad programů z Clojure do bajtkódu JVM I:<br />
<a href="http://www.root.cz/clanky/programovaci-jazyk-clojure-12-preklad-programu-z-clojure-do-bajtkodu-jvm/">http://www.root.cz/clanky/programovaci-jazyk-clojure-12-preklad-programu-z-clojure-do-bajtkodu-jvm/</a>
</li>

<li>Clojure 13: Překlad programů z Clojure do bajtkódu JVM II:<br />
<a href="http://www.root.cz/clanky/programovaci-jazyk-clojure-13-preklad-programu-z-clojure-do-bajtkodu-jvm-pokracovani/">http://www.root.cz/clanky/programovaci-jazyk-clojure-13-preklad-programu-z-clojure-do-bajtkodu-jvm-pokracovani/</a>
</li>

<li>Clojure 14: Základy práce se systémem maker<br />
<a href="http://www.root.cz/clanky/programovaci-jazyk-clojure-14-zaklady-prace-se-systemem-maker/">http://www.root.cz/clanky/programovaci-jazyk-clojure-14-zaklady-prace-se-systemem-maker/</a>
</li>

<li>Clojure 15: Tvorba uživatelských maker<br />
<a href="http://www.root.cz/clanky/programovaci-jazyk-clojure-15-tvorba-uzivatelskych-maker/">http://www.root.cz/clanky/programovaci-jazyk-clojure-15-tvorba-uzivatelskych-maker/</a>
</li>

<li>Clojure 16: Složitější uživatelská makra<br />
<a href="http://www.root.cz/clanky/programovaci-jazyk-clojure-16-slozitejsi-uzivatelska-makra/">http://www.root.cz/clanky/programovaci-jazyk-clojure-16-slozitejsi-uzivatelska-makra/</a>
</li>

<li>Clojure 17: Využití standardních maker v praxi<br />
<a href="http://www.root.cz/clanky/programovaci-jazyk-clojure-17-vyuziti-standardnich-maker-v-praxi/">http://www.root.cz/clanky/programovaci-jazyk-clojure-17-vyuziti-standardnich-maker-v-praxi/</a>
</li>

<li>Clojure 18: Základní techniky optimalizace aplikací<br />
<a href="http://www.root.cz/clanky/programovaci-jazyk-clojure-18-zakladni-techniky-optimalizace-aplikaci/">http://www.root.cz/clanky/programovaci-jazyk-clojure-18-zakladni-techniky-optimalizace-aplikaci/</a>
</li>

<li>Clojure 19: Vývojová prostředí pro Clojure<br />
<a href="http://www.root.cz/clanky/programovaci-jazyk-clojure-19-vyvojova-prostredi-pro-clojure/">http://www.root.cz/clanky/programovaci-jazyk-clojure-19-vyvojova-prostredi-pro-clojure/</a>
</li>

<li>Clojure 20: Vývojová prostředí pro Clojure (Vimu s REPL)<br />
<a href="http://www.root.cz/clanky/programovaci-jazyk-clojure-20-vyvojova-prostredi-pro-clojure-integrace-vimu-s-repl/">http://www.root.cz/clanky/programovaci-jazyk-clojure-20-vyvojova-prostredi-pro-clojure-integrace-vimu-s-repl/</a>
</li>

<li>Clojure 21: ClojureScript aneb překlad Clojure do JS<br />
<a href="http://www.root.cz/clanky/programovaci-jazyk-clojure-21-clojurescript-aneb-preklad-clojure-do-javascriptu/">http://www.root.cz/clanky/programovaci-jazyk-clojure-21-clojurescript-aneb-preklad-clojure-do-javascriptu/</a>
</li>

<li>Clojure.org: Vars and the Global Environment<br />
<a href="http://clojure.org/Vars">http://clojure.org/Vars</a>
</li>

<li>Clojure.org: Refs and Transactions<br />
<a href="http://clojure.org/Refs">http://clojure.org/Refs</a>
</li>

<li>Clojure.org: Atoms<br />
<a href="http://clojure.org/Atoms">http://clojure.org/Atoms</a>
</li>

<li>Clojure.org: Agents as Asynchronous Actions<br />
<a href="http://clojure.org/agents">http://clojure.org/agents</a>
</li>

<li>Transient Data Structures
<a href="http://clojure.org/transients">http://clojure.org/transients</a>
</li>

</ol>



<p></p><p></p>
<p><small>Autor: <a href="http://www.fit.vutbr.cz/~tisnovpa">Pavel Tišnovský</a> &nbsp; 2015</small></p>
</body>
</html>

