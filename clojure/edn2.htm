<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
        "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html>
<head>
<title>Formát EDN: extensible data notation (dokončení)</title>
<meta name="Author" content="Pavel Tisnovsky" />
<meta name="Generator" content="vim" />
<meta http-equiv="content-type" content="text/html; charset=utf-8" />
<style type="text/css">
         body {color:#000000; background:#ffffff;}
         h1  {font-family: arial, helvetica, sans-serif; color:#ffffff; background-color:#c00000; text-align:center; padding-left:1em}
         h2  {font-family: arial, helvetica, sans-serif; color:#ffffff; background-color:#0000c0; padding-left:1em; text-align:left}
         h3  {font-family: arial, helvetica, sans-serif; color:#000000; background-color:#c0c0c0; padding-left:1em; text-align:left}
         h4  {font-family: arial, helvetica, sans-serif; color:#000000; background-color:#e0e0e0; padding-left:1em; text-align:left}
         a   {font-family: arial, helvetica, sans-serif;}
         li  {font-family: arial, helvetica, sans-serif; color:#000000; text-align:justify; width:450px;}
         ol  {font-family: arial, helvetica, sans-serif; color:#000000; text-align:justify; width:450px;}
         ul  {font-family: arial, helvetica, sans-serif; color:#000000; text-align:justify; width:450px;}
         p   {font-family: arial, helvetica, sans-serif; color:#000000; text-align:justify;}
         pre {background:#e0e0e0}
</style>
</head>

<body>

<h1>Formát EDN: extensible data notation (dokončení)</h1>

<h3>Pavel Tišnovský</h3>

<p></p>

<h1>Úvodník</h1>

<p></p>



<h2>Obsah</h2>

<p><a href="#k01">1. Formát EDN: extensible data notation (dokončení)</a></p>
<p><a href="#k02">2. Serializace hodnot základních datových typů Go do formátu EDN</a></p>
<p><a href="#k03">3. Převod celočíselných hodnot do formátu EDN</a></p>
<p><a href="#k04">4. Chování systému při pokusu o převod hodnot, které nemají ve formátu EDN podporu</a></p>
<p><a href="#k05">5. Hodnoty <strong>nil</strong> a řetězce převáděné do formátu EDN</a></p>
<p><a href="#k06">6. Převod polí a řezů do formátu EDN</a></p>
<p><a href="#k07">7. Struktury (záznamy) a jejich přímý převod do formátu EDN</a></p>
<p><a href="#k08">8. Změna názvů klíčů ve výsledném souboru EDN</a></p>
<p><a href="#k09">9. Pole záznamů a jejich převod do formátu EDN</a></p>
<p><a href="#k10">10. Jedno z&nbsp;nejčastějších použití: mapy struktur (záznamů)</a></p>
<p><a href="#k11">11. Import dat ve formátu EDN do aplikace psané v&nbsp;Go</a></p>
<p><a href="#k12">12. Import jednoduché struktury (záznamu) se známým obsahem, import polí</a></p>
<p><a href="#k13">13. Načtení předem neznámé struktury ze souboru ve formátu EDN</a></p>
<p><a href="#k14">14. Problematika načítání EDN v&nbsp;jazycích se sémantikou odlišnou od Clojure</a></p>
<p><a href="#k15">15. Konverze hodnot prováděné v&nbsp;Pythonu</a></p>
<p><a href="#k16">16. Načtení složitějších datových struktur</a></p>
<p><a href="#k17">*** 17. Uživatelem definované tagy</a></p>
<p><a href="#k18">*** 18. </a></p>
<p><a href="#k19">19. Repositář s&nbsp;demonstračními příklady</a></p>
<p><a href="#k20">20. Odkazy na Internetu</a></p>



<p><a name="k01"></a></p>
<h2 id="k01">1. Formát EDN: extensible data notation (dokončení)</h2>

<p>V&nbsp;dnešním článku, který navazuje na <a
href="https://www.root.cz/clanky/format-edn-extensible-data-notation/">úterní
článek</a>, dokončíme popis použití formátu <i>EDN</i> neboli <i>Extensible
Data Notation</i>. Ukážeme si především vybrané příklady použití formátu EDN
v&nbsp;programovacím jazyce Go, některé specifické vlastnosti práce s&nbsp;EDN
v&nbsp;Pythonu (což souvisí s&nbsp;typovým systémem tohoto jazyka) a taktéž se
budeme zabývat problematikou tvorby vlastních štítků (<i>tags</i>). Jedná se o
užitečný koncept, protože právě štítky umožňují rozšiřování EDN o další datové
typy, což je vlastnost, kterou v&nbsp;dalších podobně koncipovaných formátech
většinou nenalezneme. Zmíníme se ovšem i o dalších specifických vlastnostech,
například práci se jmennými prostory atd.</p>

<p>Pro začátek si připomeňme, že tento formát, který je primárně určený pro
přenos strukturovaných dat mezi různými systémy a službami, vychází ze syntaxe
a sémantiky <a href="https://www.root.cz/n/clojure/">programovacího jazyka
Clojure</a>, je tedy založen na původních <a
href="https://en.wikipedia.org/wiki/S-expression">S-výrazech</a> rozšířených o
možnost zápisu map (slovníků), množin a vektorů. A právě možnost specifikovat
množiny, společně s&nbsp;prakticky neomezenými možnosti při použití klíčů
v&nbsp;mapách, dělají z&nbsp;EDN dosti flexibilní formát s&nbsp;užitečnou
<i>sémentikou</i> (to, že se přenáší množina a nikoli seznam či pole, je zřejmé
již do prvního znaku atd.).</p>



<p><a name="k02"></a></p>
<h2 id="k02">2. Serializace hodnot základních datových typů Go do formátu EDN</h2>

<p>Pro převod libovolného typu (přesněji řečeno hodnoty libovolného typu) do
formátu EDN se v&nbsp;programovacím jazyku Go používá funkce nazvaná
<strong>Marshal</strong>, kterou nalezneme v&nbsp;balíčku
<strong>encoding/edn</strong> (ten ovšem musí být explicitně nainstalován,
neboť není součástí standardní knihovny Go):</p>

<pre>
func <strong>Marshal</strong>(v interface{}) ([]byte, error)
</pre>

<p>Povšimněte si, že tato funkce skutečně akceptuje hodnotu libovolného typu,
protože prázdné rozhraní implementuje (zcela automaticky!) každý datový typ
(s&nbsp;tímto zajímavým konceptem &bdquo;univerzálního datového typu&ldquo; se
ještě několikrát setkáme, zejména v&nbsp;rozhraních mezi Go a dalšími systémy).
Návratovou hodnotou je sekvence bajtů (nikoli řetězec!) a popř.&nbsp;i
struktura reprezentující chybový stav, pokud k&nbsp;chybě skutečně došlo.
V&nbsp;opačném případě se ve druhé návratové hodnotě funkce
<strong>Marshal</strong> vrací <strong>nil</strong>, jak jsme ostatně zvyklí ze
všech podobně koncipovaných funkcí, které mohou za určitých okolností skončit
s&nbsp;chybou.</p>

<p><div class="rs-tip-major">Poznámka: to, že se při marshalingu vytváří
sekvence bajtů a nikoli řetězec, není vážný problém, neboť převod na řetězec je
triviální:</div></p>

<pre>
byteStream, err := edn.Marshal(valueOfAnyType)
&nbsp;
if err != nil {
        fmt.Println(string(byteStream))
}
</pre>



<p><a name="k03"></a></p>
<h2 id="k03">3. Převod celočíselných hodnot do formátu EDN</h2>

<p>V&nbsp;dnešním prvním demonstračním příkladu, jehož zdrojový kód naleznete
na adrese <a
href="https://github.com/tisnik/presentations/tree/master/edn/go-edn-basic-types-1">https://github.com/tisnik/presentations/tree/master/edn/go-edn-basic-types-1</a>
je ukázán způsob konverze celých čísel se znaménkem do formátu EDN. Připomeňme
si, že v&nbsp;Go existuje několik celočíselných typů se znaménkem, přičemž
některé typy jsou pouze jmennými aliasy:</p>

<table>
<tr><th>#</th><th>Označení</th><th>Rozsah hodnot</th><th>Stručný popis</th></tr>
<tr><td>1</td><td>int8 </td><td>-128 až 127</td><td>osmibitové celé číslo se znaménkem</td></tr>
<tr><td>2</td><td>int16</td><td>-32768 až 32767</td><td>16bitové celé číslo se znaménkem</td></tr>
<tr><td>3</td><td>int32</td><td>-2147483648 až 2147483647</td><td>32bitové celé číslo se znaménkem</td></tr>
<tr><td>4</td><td>int64</td><td>-9223372036854775808 až 9223372036854775807</td><td>64bitové celé číslo se znaménkem</td></tr>
<tr><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td></tr>
<tr><td>5</td><td>int</td><td>různý</td><td>odpovídá buď typu int32 nebo int64</td></tr>
<tr><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td></tr>
<tr><td>6</td><td>rune</td><td>-2147483648 až 2147483647</td><td>alias pro typ int32, používá se pro znaky</td></tr>
</table>

<p>Převod hodnot všech skupin celočíselných hodnot se znaménkem může být
proveden následovně (vynechali jsme pouze typ <strong>int</strong>, který je
aliasem pro <strong>int32</strong> nebo <strong>int64</strong>, a to podle
konkrétní použité architektury):</p>

<pre>
package <strong>main</strong>
&nbsp;
import (
        "fmt"
        "olympos.io/encoding/edn"
)
&nbsp;
func <strong>main</strong>() {
        var a int8 = -10
        var b int16 = -1000
        var c int32 = -10000
        var d int32 = -1000000
&nbsp;
        var r1 rune = 'a'
        var r2 rune = '\x40'
        var r3 rune = '\n'
        var r4 rune = '\u03BB'
&nbsp;
        aEDN, err := <u>edn.Marshal(a)</u>
        fmt.Println(string(aEDN))
        fmt.Println(err)
&nbsp;
        bEDN, err := <u>edn.Marshal(b)</u>
        fmt.Println(string(bEDN))
        fmt.Println(err)
&nbsp;
        cEDN, err := <i>edn.Marshal(c)</i>
        fmt.Println(string(cEDN))
        fmt.Println(err)
&nbsp;
        dEDN, err := <i>edn.Marshal(d)</i>
        fmt.Println(string(dEDN))
        fmt.Println(err)
&nbsp;
        fmt.Println()
&nbsp;
        r1EDN, err := <i>edn.Marshal(r1)</i>
        fmt.Println(string(r1EDN))
        fmt.Println(err)
&nbsp;
        r2EDN, err := <i>edn.Marshal(r2)</i>
        fmt.Println(string(r2EDN))
        fmt.Println(err)
&nbsp;
        r3EDN, err := <i>edn.Marshal(r3)</i>
        fmt.Println(string(r3EDN))
        fmt.Println(err)
&nbsp;
        r4EDN, err := <i>edn.Marshal(r4)</i>
        fmt.Println(string(r4EDN))
        fmt.Println(err)
}
</pre>

<p>Po spuštění demonstračního příkladu by se mělo zobrazit několik textových
řádků, z&nbsp;nichž každý reprezentuje validní EDN (a pod ním hodnotu
<strong>nil</strong> značící, že nedošlo k&nbsp;žádné chybě):</p>

<pre>
-10
&lt;nil&gt;
-1000
&lt;nil&gt;
-10000
&lt;nil&gt;
-1000000
&lt;nil&gt;
&nbsp;
97
&lt;nil&gt;
64
&lt;nil&gt;
10
&lt;nil&gt;
955
&lt;nil&gt;
</pre>

<p>Druhý demonstrační příklad, který najdete na adrese <a
href="https://github.com/tisnik/presentations/tree/master/edn/go-edn-basic-types-2">https://github.com/tisnik/presentations/tree/master/edn/go-edn-basic-types-2</a>,
provádí tytéž operace, ovšem nad celočíselnými hodnotami bez znaménka:</p>

<table>
<tr><th>#</th><th>Označení</th><th>Rozsah hodnot</th><th>Stručný popis</th></tr>
<tr><td>1<td>uint8 </td><td>0 až 255</td><td>osmibitové celé číslo bez znaménka</td></tr>
<tr><td>2<td>uint16</td><td>0 až 65535</td><td>16bitové celé číslo bez znaménka</td></tr>
<tr><td>3<td>uint32</td><td>0 až 4294967295</td><td>32bitové celé číslo bez znaménka</td></tr>
<tr><td>4<td>uint64</td><td>0 až 18446744073709551615</td><td>64bitové celé číslo bez znaménka</td></tr>
<tr><td>&nbsp;<td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td></tr>
<tr><td>5<td>uint</td><td>různý</td><td>odpovídá buď typu uint32 nebo uint64</td></tr>
<tr><td>&nbsp;<td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td></tr>
<tr><td>6<td>byte</td><td>0 až 255</td><td>alias pro typ uint8</td></tr>
</table>

<p>Zdrojový kód tohoto demonstračního příkladu vypadá takto:</p>

<pre>
package <strong>main</strong>
&nbsp;
import (
        "fmt"
        "olympos.io/encoding/edn"
)
&nbsp;
func <strong>main</strong>() {
        var b8 byte = 0x42
        var a uint8 = 10
        var b uint16 = 1000
        var c uint32 = 10000
        var d uint32 = 1000000
&nbsp;
        b8EDN, err := <u>edn.Marshal(b8)</u>
        fmt.Println(string(b8EDN))
        fmt.Println(err)
&nbsp;
        aEDN, err := <u>edn.Marshal(a)</u>
        fmt.Println(string(aEDN))
        fmt.Println(err)
&nbsp;
        bEDN, err := <u>edn.Marshal(b)</u>
        fmt.Println(string(bEDN))
        fmt.Println(err)
&nbsp;
        cEDN, err := <u>edn.Marshal(c)</u>
        fmt.Println(string(cEDN))
        fmt.Println(err)
&nbsp;
        dEDN, err := <u>edn.Marshal(d)</u>
        fmt.Println(string(dEDN))
        fmt.Println(err)
}
</pre>

<p>Po spuštění tohoto demonstračního příkladu získáme deset řádků &ndash; pět
korektních EDN + informaci o tom, že nedošlo k&nbsp;žádné chybě:</p>

<pre>
66
&lt;nil&gt;
10
&lt;nil&gt;
1000
&lt;nil&gt;
10000
&lt;nil&gt;
1000000
&lt;nil&gt;
</pre>

<p><div class="rs-tip-major">Poznámka: ve skutečnosti mohou (ale nemusí) nastat
problémy s&nbsp;datovými typy <strong>int64</strong>, <strong>uint64</strong>
popř.&nbsp;některými hodnotami typu <strong>uint32</strong> (těmi, které se
nevejdou do rozsahu <strong>int32</strong>). Tyto problémy nenastanou na straně
Go, ale knihoven jiných programovacích jazyků.</div></p>



<p><a name="k04"></a></p>
<h2 id="k04">4. Chování systému při pokusu o převod hodnot, které nemají ve formátu EDN podporu</h2>

<p>Hodnoty některých datových typů programovacího jazyka Go ovšem nemají ve
formátu EDN přímý ekvivalent a proto nejsou převoditelné (alespoň ne
automaticky). Týká se to například i datových typů <strong>complex64</strong> a
<strong>complex128</strong>, kterými jsou v&nbsp;jazyku Go reprezentována
komplexní čísla (dvojice hodnot typu <strong>float32</strong>
popř.&nbsp;<strong>float64</strong>):</p>

<pre>
var a complex64 = -1.5 + 0i
var b complex64 = 1.5 + 1000i
var c complex64 = 1e30 + 1e30i
var d complex64 = 1i
</pre>

<p><div class="rs-tip-major">Poznámka: zajímavé je, že Clojure neobsahuje
podporu pro komplexní čísla, zatímco <a
href="https://www.root.cz/clanky/kawa-prekvapive-silny-a-vykonny-dialekt-scheme-pro-jvm/#k06">jazyk
Kawa</a> ano.</div></p>

<p>Převod (s&nbsp;kontrolou průběhu převodu) je implementován v&nbsp;dnešním
třetím demonstračním příkladu s&nbsp;tímto zdrojovým kódem:</p>

<pre>
package <strong>main</strong>
&nbsp;
import (
        "fmt"
        "olympos.io/encoding/edn"
)
&nbsp;
func <strong>main</strong>() {
        var a complex64 = -1.5 + 0i
        var b complex64 = 1.5 + 1000i
        var c complex64 = 1e30 + 1e30i
        var d complex64 = 1i
&nbsp;
        aEDN, err := <u>edn.Marshal(a)</u>
        fmt.Println(string(aEDN))
        fmt.Println(err)
&nbsp;
        bEDN, err := <u>edn.Marshal(b)</u>
        fmt.Println(string(bEDN))
        fmt.Println(err)
&nbsp;
        cEDN, err := <u>edn.Marshal(c)</u>
        fmt.Println(string(cEDN))
        fmt.Println(err)
&nbsp;
        dEDN, err := <u>edn.Marshal(d)</u>
        fmt.Println(string(dEDN))
        fmt.Println(err)
}
</pre>

<p>Po spuštění takto připraveného demonstračního příkladu je již jasné, že se
konverze nezadařila &ndash; po každém prázdném řádku (výsledek nepovedené
konverze) je totiž vypsána i chyba, ke které došlo:</p>

<pre>
&nbsp;
edn: unsupported type: complex64
&nbsp;
edn: unsupported type: complex64
&nbsp;
edn: unsupported type: complex64
&nbsp;
edn: unsupported type: complex64
</pre>

<p><div class="rs-tip-major">Poznámka: v&nbsp;případě, že kontrolu chyby
neprovedete, vrátí se pouze prázdný řetězec (resp.&nbsp;prázdný řez bajtů), což
je pochopitelně nekorektní chování &ndash; tuto chybu je zapotřebí
ošetřit.</div></p>



<p><a name="k05"></a></p>
<h2 id="k05">5. Hodnoty <strong>nil</strong> a řetězce převáděné do formátu EDN</h2>

<p>Podívejme se nyní na způsob uložení hodnot <strong>nil</strong> do formátu
EDN. Připomeňme si, že s&nbsp;hodnotou <strong>nil</strong> je v&nbsp;jazyce Go
spojen i typ této hodnoty. Podrobnosti jsme si řekli v&nbsp;článku <a
href="https://www.root.cz/clanky/problematika-nulovych-hodnot-v-go-aneb-proc-nil-nil/">Problematika
nulových hodnot v&nbsp;Go, aneb proč nil != nil</a>, v&nbsp;němž jsme si
uvedli, že <strong>nil</strong> může reprezentovat &bdquo;nulovou
hodnotu&ldquo; pro některé datové typy:</p>

<table>
<tr><th>#</th><th>Datový typ</th><th>Nulová hodnota</th></tr>
<tr><td>1</td><td>bool</td><td>false</td></tr>
<tr><td>2</td><td>int (a varianty)</td><td>0</td></tr>
<tr><td>3</td><td>float (obě varianty)</td><td>0.0</td></tr>
<tr><td>4</td><td>complex (obě varianty)</td><td>0.0+0.0i</td></tr>
<tr><td>5</td><td>string</td><td>""</td></tr>
<tr><td>6</td><td>pointer</td><td>nil</td></tr>
<tr><td>7</td><td>slice</td><td>nil</td></tr>
<tr><td>8</td><td>map</td><td>nil</td></tr>
<tr><td>9</td><td>channel</td><td>nil</td></tr>
<tr><td>10</td><td>function</td><td>nil</td></tr>
<tr><td>11</td><td>interface</td><td>nil</td></tr>
<tr><td>12</td><td>struct</td><td>prvky s&nbsp;nulovými hodnotami</td></tr>
</table>

<p>Na druhou stranu ve formátu EDN je <strong>typ</strong> spojen přímo
s&nbsp;<strong>hodnotou</strong>, přesněji řečeno literál představující hodnotu
současně určuje i typ, takže <strong>nil</strong> zůstane beztypové. Po úplnost
je do příkladu přidána i serializace běžného řetězce:</p>

<pre>
package <strong>main</strong>
&nbsp;
import (
        "fmt"
        "olympos.io/encoding/edn"
)
&nbsp;
func <strong>main</strong>() {
        var a interface{} = nil
        var b map[string]string = nil
        c := "foo bar baz"
&nbsp;
        aEDN, err := <u>edn.Marshal(a)</u>
        fmt.Println(string(aEDN))
        fmt.Println(err)
&nbsp;
        fmt.Println()
&nbsp;
        bEDN, err := <u>edn.Marshal(b)</u>
        fmt.Println(string(bEDN))
        fmt.Println(err)
&nbsp;
        fmt.Println()
&nbsp;
        cEDN, err := <u>edn.Marshal(c)</u>
        fmt.Println(string(cEDN))
        fmt.Println(err)
}
</pre>

<p>Výsledek běhu tohoto demonstračního příkladu opět ukazuje jak serializované
hodnoty, tak i fakt, že při serializaci nedošlo k&nbsp;chybě:</p>

<pre>
nil
&lt;nil&gt;
&nbsp;
nil
&lt;nil&gt;
&nbsp;
"foo bar baz"
&lt;nil&gt;
</pre>



<p><a name="k06"></a></p>
<h2 id="k06">6. Převod polí a řezů do formátu EDN</h2>

<p>S&nbsp;EDN obsahujícími pouze jedinou skalární hodnotu se nesetkáme příliš
často, proto se nyní podívejme na způsob práce se strukturovanými daty.
Začneme s&nbsp;poli (<i>arrays</i>), popř.&nbsp;s&nbsp;řezy, které se do
formátu EDN provádí naprosto stejným způsobem jako pole. Vyzkoušíme si převod
polí, v&nbsp;nichž jsou typy prvků shodné:</p>

<pre>
var a1 [10]byte
var a2 [10]int32
a3 := [10]int32{1, 10, 2, 9, 3, 8, 4, 7, 5, 6}
a4 := []string{"www", "root", "cz"}
</pre>

<p>Převádět samozřejmě můžeme i dvourozměrné (popř.&nbsp;i vícerozměrné)
pole:</p>

<pre>
matice := [4][3]float32{
        {1, 2, 3},
        {4, 5, 6},
        {7, 8, 9},
        {0, -1, 0},
}
</pre>

<p>V&nbsp;případě, že je nutné pracovat s&nbsp;poli, v&nbsp;nichž mohou mít
prvky rozdílné typy hodnot (což je v&nbsp;EDN relativně častý požadavek),
můžeme si v&nbsp;programovacím jazyce Go pomoci poli s&nbsp;prvky typu
&bdquo;prázdné rozhraní&ldquo; (přesněji se všemi typy, které prázdné rozhraní
implementují &ndash; to jsou všechny typy):</p>

<pre>
a5 := []interface{}{1, "root", 3.1415, true, []int{1, 2, 3, 4}}
</pre>

<p>Následuje úplný zdrojový kód dnešního pátého demonstračního příkladu,
v&nbsp;němž k&nbsp;marshalingu polí (s&nbsp;prvky různých typů) dochází:</p>

<pre>
package <strong>main</strong>
&nbsp;
import (
        "fmt"
        "olympos.io/encoding/edn"
)
&nbsp;
func <strong>main</strong>() {
        var a1 [10]byte
        var a2 [10]int32
        a3 := [10]int32{1, 10, 2, 9, 3, 8, 4, 7, 5, 6}
        a4 := []string{"www", "root", "cz"}
        a5 := []interface{}{1, "root", 3.1415, true, []int{1, 2, 3, 4}}
&nbsp;
        matice := [4][3]float32{
                {1, 2, 3},
                {4, 5, 6},
                {7, 8, 9},
                {0, -1, 0},
        }
&nbsp;
        a1EDN, err := <u>edn.MarshalPPrint(a1, nil)</u>
        fmt.Println(string(a1EDN))
        fmt.Println(err)
        fmt.Println()
&nbsp;
        a2EDN, err := <u>edn.MarshalPPrint(a2, nil)</u>
        fmt.Println(string(a2EDN))
        fmt.Println(err)
        fmt.Println()
&nbsp;
        a3EDN, err := <u>edn.MarshalPPrint(a3, nil)</u>
        fmt.Println(string(a3EDN))
        fmt.Println(err)
        fmt.Println()
&nbsp;
        a4EDN, err := <u>edn.MarshalPPrint(a4, nil)</u>
        fmt.Println(string(a4EDN))
        fmt.Println(err)
        fmt.Println()
&nbsp;
        a5EDN, err := <u>edn.MarshalPPrint(a5, nil)</u>
        fmt.Println(string(a5EDN))
        fmt.Println(err)
        fmt.Println()
&nbsp;
        maticeEDN, err := <u>edn.MarshalPPrint(matice, nil)</u>
        fmt.Println(string(maticeEDN))
        fmt.Println(err)
}
</pre>

<p><div class="rs-tip-major">Poznámka: povšimněte si, že nyní pro tisk
používáme funkci pojmenovanou <strong>MarshalPPrint</strong>, která používá
bílé znaky pro vygenerování naformátovaného EDN.</div></p>

<p>První tři pole se převedou do formátu JSON takto:</p>

<pre>
[0 0 0 0 0 0 0 0 0 0]
[0 0 0 0 0 0 0 0 0 0]
[1 10 2 9 3 8 4 7 5 6]
</pre>

<p>Další pole obsahuje řetězce, které mohou vypadat následovně:</p>

<pre>
["www" "root" "cz"]
</pre>

<p>Následuje pole prvků různých typů (resp.&nbsp;hodnot implementujících
prázdné rozhraní):</p>

<pre>
[1 "root" 3.1415 true [1 2 3 4]]
</pre>

<p>A konečně posledním případem je dvourozměrné pole hodnot typu
<i>float32</i>, které sice nejsou v&nbsp;EDN přímo podporovány, ale je proveden
jejich převod na <i>float64/double</i> (což je převod, v&nbsp;němž nedochází ke
ztrátě přesnosti ani rozsahu). Výsledek bude následující (jedná se o vektor
vektorů):</p>

<pre>
[[1.0 2.0 3.0]
 [4.0 5.0 6.0]
 [7.0 8.0 9.0]
 [0.0 -1.0 0.0]]
</pre>



<p><a name="k07"></a></p>
<h2 id="k07">7. Struktury (záznamy) a jejich přímý převod do formátu EDN</h2>

<p>Do formátu EDN pochopitelně můžeme převádět i jednotlivé struktury.
Struktura se zkonvertuje do EDN ve formě <i>mapy</i> (neboli asociativního
pole). Ovšem musíme si dát pozor na to, že převedeny budou jen ty položky
záznamu, jejichž jméno začíná velkým písmenem. Ostatně se o tom můžeme snadno
přesvědčit při překladu a spuštění dalšího demonstračního příkladu:</p>

<pre>
package <strong>main</strong>
&nbsp;
import (
        "fmt"
        "olympos.io/encoding/edn"
)
&nbsp;
<i>// User1 je uživatelsky definovaná datová struktura s privátními atributy</i>
type <strong>User1</strong> struct {
        id      uint32
        name    string
        surname string
}
&nbsp;
<i>// User2 je uživatelsky definovaná datová struktura s viditelnými atributy</i>
type <strong>User2</strong> struct {
        ID      uint32
        Name    string
        Surname string
}
&nbsp;
func <strong>main</strong>() {
        user1 := User1{
                1,
                "Pepek",
                "Vyskoč"}
&nbsp;
        user2 := User2{
                1,
                "Pepek",
                "Vyskoč"}
&nbsp;
        fmt.Println("user1")
        user1EDN, err := edn.Marshal(user1)
        fmt.Println(string(user1EDN))
        fmt.Println(err)
        fmt.Println()
&nbsp;
        user1PrettyEDN, err := edn.MarshalPPrint(user1, nil)
        fmt.Println(string(user1PrettyEDN))
        fmt.Println(err)
        fmt.Println()
&nbsp;
        fmt.Println("user2")
        user2EDN, err := edn.Marshal(user2)
        fmt.Println(string(user2EDN))
        fmt.Println(err)
        fmt.Println()
&nbsp;
        user2PrettyEDN, err := edn.MarshalPPrint(user2, nil)
        fmt.Println(string(user2PrettyEDN))
        fmt.Println(err)
        fmt.Println()
}
</pre>

<p>První struktura se převede na prázdný objekt (má položky pojmenované malými
písmeny), druhá se již převede korektně:</p>

<pre>
{}
{:iD 1 :name"Pepek":surname"Vyskoč"}
</pre>

<p>V&nbsp;příkladu je taktéž ukázán přehlednější
&bdquo;pretty-printovaný&ldquo; výstup:</p>

<pre>
{:iD 1,
 :name "Pepek",
 :surname "Vyskoč"}
</pre>

<p><div class="rs-tip-major">Poznámka: v&nbsp;dalším textu si ukážeme, jak lze
toto omezení částečně obejít s&nbsp;využitím tzv.&nbsp;struktur se
značkami.</div></p>



<p><a name="k08"></a></p>
<h2 id="k08">8. Změna názvů klíčů ve výsledném souboru EDN</h2>

<p>Velmi často se ovšem setkáme s&nbsp;požadavkem na to, aby měly položky
v&nbsp;souboru EDN odlišné označení &ndash; ostatně pojmenování položek stylem
<i>CamelCase</i> není ve světě EDN příliš běžné. Řešení tohoto problému
existuje, i když není příliš elegantní &ndash; v&nbsp;Go jsou totiž podporovány
takzvané &bdquo;tagged structs&ldquo;, což jsou běžné struktury/záznamy, za
jejichž položkami jsou v&nbsp;řetězci zapsaném ve zpětných apostrofech uvedeny
příslušné názvy, které se mají v&nbsp;EDN objevit:</p>

<pre>
type <strong>User3</strong> struct {
        ID      uint32 <u>`edn:"id"`</u>
        Name    string <u>`edn:"user-name"`</u>
        Surname string <u>`edn:"surname"`</u>
}
</pre>

<p>Nevýhodou tohoto způsobu deklarace je fakt, že obsah řetězců není
překladačem nijak kontrolován, takže se o případných problémech (chybějící
uvozovky atd.) dozvíme až v&nbsp;čase běhu aplikace (ideální z&nbsp;testů).</p>

<p>Chování si můžeme ověřit na tomto příkladu:</p>

<pre>
package <strong>main</strong>
&nbsp;
import (
        "fmt"
        "olympos.io/encoding/edn"
)
&nbsp;
<i>// User3 je uživatelsky definovaná datová struktura s viditelnými atributy</i>
type <strong>User3</strong> struct {
        ID      uint32 `edn:"id"`
        Name    string `edn:"user-name"`
        Surname string `edn:"surname"`
}
&nbsp;
func <strong>main</strong>() {
        user3 := User3{
                1,
                "Pepek",
                "Vyskoč"}
&nbsp;
        fmt.Println("user3")
        user3EDN, err := edn.Marshal(user3)
        fmt.Println(string(user3EDN))
        fmt.Println(err)
        fmt.Println()
&nbsp;
        user3PrettyEDN, err := edn.MarshalPPrint(user3, nil)
        fmt.Println(string(user3PrettyEDN))
        fmt.Println(err)
        fmt.Println()
}
</pre>

<p>S&nbsp;následujícím výsledkem (jsou v&nbsp;něm zobrazeny i případné chyby,
které by mohly při převodu nastat):</p>

<pre>
user3
{:id 1 :user-name"Pepek":surname"Vyskoč"}
&lt;nil&gt;
&nbsp;
{:id 1,
 :user-name "Pepek",
 :surname "Vyskoč"}
&lt;nil&gt;
</pre>



<p><a name="k09"></a></p>
<h2 id="k09">9. Pole záznamů a jejich převod do formátu EDN</h2>

<p>Často se taktéž setkáme s&nbsp;poli nebo řezy, jejichž prvky jsou struktury.
Převod takové hierarchické datové struktury do formátu je stejně přímočarý,
jako v&nbsp;předchozím příkladu:</p>

<pre>
package <strong>main</strong>
&nbsp;
import (
        "fmt"
        "olympos.io/encoding/edn"
)
&nbsp;
<i>// User3 je uživatelsky definovaná datová struktura s viditelnými atributy</i>
type <strong>User3</strong> struct {
        ID      uint32 `edn:"id"`
        Name    string `edn:"user-name"`
        Surname string `edn:"surname"`
}
&nbsp;
func <strong>main</strong>() {
        var users = [3]User3{
                User3{
                        ID:      1,
                        Name:    "Pepek",
                        Surname: "Vyskoč"},
                User3{
                        ID:      2,
                        Name:    "Pepek",
                        Surname: "Vyskoč"},
                User3{
                        ID:      3,
                        Name:    "Josef",
                        Surname: "Vyskočil"},
        }
&nbsp;
        fmt.Println("users")
        usersEDN, err := edn.Marshal(users)
        fmt.Println(string(usersEDN))
        fmt.Println(err)
        fmt.Println()
&nbsp;
        usersPrettyEDN, err := edn.MarshalPPrint(users, nil)
        fmt.Println(string(usersPrettyEDN))
        fmt.Println(err)
        fmt.Println()
}
</pre>

<p>Nenaformátovaný výsledek:</p>

<pre>
[{:id 1 :user-name"Pepek":surname"Vyskoč"}{:id 2 :user-name"Pepek":surname"Vyskoč"}{:id 3 :user-name"Josef":surname"Vyskočil"}]
</pre>

<p>Naformátovaný výsledek:</p>

<pre>
[{:id 1,
  :user-name "Pepek",
  :surname "Vyskoč"}
 {:id 2,
  :user-name "Pepek",
  :surname "Vyskoč"}
 {:id 3,
  :user-name "Josef",
  :surname "Vyskočil"}]
</pre>



<p><a name="k10"></a></p>
<h2 id="k10">10. Jedno z&nbsp;nejčastějších použití: mapy struktur (záznamů)</h2>

<p>Pravděpodobně nejčastěji se při práci s&nbsp;formátem EDN setkáme
s&nbsp;mapami (resp.&nbsp;asociativními poli), jejichž hodnotami jsou záznamy.
Mapy mají v&nbsp;JSON jedno omezené &ndash; klíči mohou být řetězce. Toto
omezení v&nbsp;programovacím jazyce Go neplatí a neplatí ani pro formát
EDN.</p>

<p>V&nbsp;dalším demonstračním příkladu je ukázán převod mapy se dvěma
dvojicemi klíč-hodnota. Klíče jsou typu <strong>string</strong>, hodnotami jsou
struktury/záznamy s&nbsp;předem známými prvky:</p>

<pre>
package <strong>main</strong>
&nbsp;
import (
        "fmt"
        "olympos.io/encoding/edn"
)
&nbsp;
<i>// User3 je uživatelsky definovaná datová struktura s viditelnými atributy</i>
type <strong>User3</strong> struct {
        ID      uint32 `edn:"id"`
        Name    string `edn:"user-name"`
        Surname string `edn:"surname"`
}
&nbsp;
func <strong>main</strong>() {
        m1 := make(map[string]User3)
&nbsp;
        m1["user-id-1"] = User3{
                ID:      1,
                Name:    "Pepek",
                Surname: "Vyskoč"}
&nbsp;
        m1["user-id-3"] = User3{
                ID:      2,
                Name:    "Josef",
                Surname: "Vyskočil"}
&nbsp;
        fmt.Println("users map")
        usersMapEDN, _ := <u>edn.Marshal(m1)</u>
        fmt.Println(string(usersMapEDN))
        fmt.Println()
        usersPrettyEDN, _ := <u>edn.MarshalPPrint(m1, nil)</u>
        fmt.Println(string(usersPrettyEDN))
        fmt.Println()
}
</pre>

<p>Výsledkem je mapa ve formátu EDN, která je v&nbsp;prvním případě
nenaformátovaná a ve druhém naopak naformátovaná a tedy uživatelsky
čitelná:</p>

<pre>
{"user-id-1"{:id 1 :user-name"Pepek":surname"Vyskoč"}"user-id-3"{:id 2 :user-name"Josef":surname"Vyskočil"}}
&nbsp;
{"user-id-1" {:id 1,
              :user-name "Pepek",
              :surname "Vyskoč"},
 "user-id-3" {:id 2,
              :user-name "Josef",
              :surname "Vyskočil"}}

</pre>



<p><a name="k11"></a></p>
<h2 id="k11">11. Import dat ve formátu EDN do aplikace psané v&nbsp;Go</h2>

<p>V&nbsp;této části článku se zaměříme na popis importu dat z&nbsp;formátu EDN
do interních datových struktur programovacího jazyka Go. Pro tuto operaci,
která se nazývá <i>unmarshaling</i> s&nbsp;následující hlavičkou:</p>

<pre>
func <strong>Unmarshal</strong>(data []byte, v interface{}) error
</pre>

<p>Vstupem je v&nbsp;tomto případě pole (řez) bajtů, výstup je vrácen přes
ukazatel předaný ve druhém parametru (což znamená, že se musíme sami postarat o
případnou alokaci paměti pro strukturu či pro mapu). Samozřejmě, že při
unmarshalingu může dojít k&nbsp;nějaké chybě, která je vrácena volající funkci.
Pokud k&nbsp;chybě nedošlo, je návratová hodnota rovna
<strong>nil</strong>.</p>



<p><a name="k12"></a></p>
<h2 id="k12">12. Import jednoduché struktury (záznamu) se známým obsahem, import polí</h2>

<p>Nejjednodušší je situace ve chvíli, kdy přesně (tedy dopředu &ndash; již
v&nbsp;čase vývoje aplikace) známe strukturu dat. Pokud se v&nbsp;EDN přenáší
informace o struktuře (záznamu, objektu), lze tuto strukturu deklarovat jako
datový typ, vytvořit proměnnou tohoto typu a následně zavolat výše zmíněnou
funkci <strong>Unmarshal</strong>:</p>

<pre>
type <strong>User</strong> struct {
   ...
   ...
   ...
}
&nbsp;
var user User
edn.Unmarshal(bytes, &amp;user)
</pre>

<p>Podívejme se nyní, jak by mohl vypadat celý demonstrační příklad,
v&nbsp;němž je EDN načten ze souboru a zpracován:</p>

<pre>
package <strong>main</strong>
&nbsp;
import (
        "fmt"
        "io/ioutil"
        "log"
&nbsp;
        "olympos.io/encoding/edn"
)
&nbsp;
<i>// User je uživatelsky definovaná datová struktura s viditelnými atributy</i>
type <strong>User</strong> struct {
        ID      uint32 `edn:"id"`
        Name    string `edn:"user-name"`
        Surname string `edn:"surname"`
}
&nbsp;
func <strong>main</strong>() {
        inputEdnAsBytes, err := ioutil.ReadFile("user.edn")
        if err != nil {
                log.Fatal(err)
        }
&nbsp;
        fmt.Println("Input (bytes):")
        fmt.Println(inputEdnAsBytes)
&nbsp;
        fmt.Println("\nInput (string):")
        fmt.Println(string(inputEdnAsBytes))
&nbsp;
        var user User
        <u>edn.Unmarshal(inputEdnAsBytes, &amp;user)</u>
&nbsp;
        fmt.Println("\nOutput:")
        fmt.Println(user)
&nbsp;
        fmt.Println("\nFields:")
        fmt.Printf("ID:      %d\n", user.ID)
        fmt.Printf("Name:    %s\n", user.Name)
        fmt.Printf("Surname: %s\n", user.Surname)
}
</pre>

<p>Pro vstup:</p>

<pre>
{:id 1,
 :user-name "Pepek",
 :surname "Vyskoč"}
</pre>

<p>Dostaneme tyto výsledky:</p>

<pre>
Input (bytes):
[123 58 105 100 32 49 44 10 32 58 117 115 101 114 45 110 97 109 101 32 34 80 101 112 101 107 34 44 10 32 58 115 117 114 110 97 109 101 32 34 86 121 115 107 111 196 141 34 125 10 10]
&nbsp;
Input (string):
{:id 1,
 :user-name "Pepek",
 :surname "Vyskoč"}
&nbsp;
&nbsp;
&nbsp;
Output:
{1 Pepek Vyskoč}
&nbsp;
Fields:
ID:      1
Name:    Pepek
Surname: Vyskoč
</pre>

<p><div class="rs-tip-major">Poznámka: povšimněte si, že je možné snadno
přistupovat k&nbsp;prvkům struktury, protože překladač zná její předpokládaný
obsah. V&nbsp;dalším příkladu to již takto jednoduše možné nebude.  </div> </p>

<p>Při importu polí využijeme skutečnosti, že v&nbsp;případě použití řezů je
možné pole, které je řezem používáno, automaticky zvětšovat při přidávání
nových prvků. Tuto operaci za nás provede přímo knihovna pro unmarshalling,
takže se nemusíme zabývat (před)alokací pole:</p>

<pre>
var numbers []int
edn.Unmarshal(input_json_as_bytes, &amp;numbers)
</pre>



<p><a name="k13"></a></p>
<h2 id="k13">13. Načtení předem neznámé struktury ze souboru ve formátu EDN</h2>

<p>Nakonec se podívejme, jak se načítá obsah souboru uloženého ve formátu EDN
s&nbsp;předem neznámou strukturou. V&nbsp;tomto případě použijeme mapu,
jejímiž klíči musí být řetězce a hodnotami libovolný typ implementující prázdné
rozhraní <strong>interface{}</strong>:</p>

<pre>
m1 := map[string]interface{}{}
</pre>

<p><div class="rs-tip-major">Poznámka: dvojice složených závorek je napsána
naschvál &ndash; první závorky jsou součástí typu, druhé znamenají inicializaci
mapy.</div></p>

<p>Problém spočívá v&nbsp;další interpretaci hodnot, kdy je nutné použít obdobu
reflexe. Nicméně alespoň základní práci s&nbsp;takto načtenou mapou lze
zajistit:</p>

<pre>
package <strong>main</strong>
&nbsp;
import (
        "fmt"
        "io/ioutil"
        "log"
&nbsp;
        "olympos.io/encoding/edn"
)
&nbsp;
func <strong>main</strong>() {
        inputEdnAsBytes, err := ioutil.ReadFile("user.edn")
        if err != nil {
                log.Fatal(err)
        }
&nbsp;
        fmt.Println("Input (bytes):")
        fmt.Println(inputEdnAsBytes)
&nbsp;
        fmt.Println("\nInput (string):")
        fmt.Println(string(inputEdnAsBytes))
&nbsp;
        user := map[interface{}]interface{}{}
        <u>edn.Unmarshal(inputEdnAsBytes, &amp;user)</u>
&nbsp;
        fmt.Println("\nOutput:")
        fmt.Println(user)
&nbsp;
        fmt.Println("\nFields:")
        for key, value := range user {
                fmt.Printf("%v\t%v\n", key, value)
        }
}
</pre>

<p>Opět si vyzkoušejme použít tento vstupní soubor:</p>

<pre>
{:id 1,
 :user-name "Pepek",
 :surname "Vyskoč"}
</pre>

<p>Tato mapa by měla být korektně načtena a zpracována:</p>

<pre>
Input (bytes):
[123 58 105 100 32 49 44 10 32 58 117 115 101 114 45 110 97 109 101 32 34 80 101 112 101 107 34 44 10 32 58 115 117 114 110 97 109 101 32 34 86 121 115 107 111 196 141 34 125 10 10]
&nbsp;
Input (string):
{:id 1,
 :user-name "Pepek",
 :surname "Vyskoč"}
&nbsp;
&nbsp;
&nbsp;
Output:
map[:id:1 :surname:Vyskoč :user-name:Pepek]
&nbsp;
Fields:
:user-name      Pepek
:surname        Vyskoč
:id     1
</pre>

<p><div class="rs-tip-major">Poznámka: teoreticky lze načíst data
s&nbsp;libovolnou strukturou do proměnné typu <strong>interface{}</strong>,
jenže zpracování takových dat není vůbec přímočaré &ndash; pro tyto účely se
(alespoň podle mého názoru) Go, jako většinou staticky a silně typovaný jazyk,
příliš nehodí.</div></p>



<p><a name="k14"></a></p>
<h2 id="k14">14. Problematika načítání EDN v&nbsp;jazycích se sémantikou odlišnou od Clojure</h2>

<p>V&nbsp;úvodním článku o formátu EDN jsme si řekli, že je tento formát do
značné míry odvozený od vlastností programovacího jazyka Clojure. Tento jazyk
přináší vývojářům několik zajímavých vlastností, které ovšem do značné míry
určují i vlastnosti EDN &ndash; a hlavní problém spočívá v&nbsp;tom, že některé
z&nbsp;těchto vlastností nejsou v&nbsp;jiných jazycích podporovány, takže
čtečky (či konvertory) EDN musí tato omezení nějakým způsobem obcházet. Abychom
byli konkrétnější, jsou v&nbsp;následujících bodech vypsány některé vlastnosti
EDN, které mohou být v&nbsp;jiných programovacích jazycích při práci s&nbsp;EDN
problematické:</p>

<ol>

<li>Ve formátu EDN je možné používat jak &bdquo;keywords&ldquo;, tak i řetězce,
ovšem mnohé další jazyky &bdquo;keywords&ldquo; nepodporují a v&nbsp;některých
případech dokonce automaticky převádí jejich hodnotu na řetězce. To je
pochopitelně nekorektní, protože nám to neumožní rozlišit například mezi
hodnotou <strong>:foo</strong> a <strong>"foo"</strong>; tudíž nelze tyto dvě
hodnoty uložit do jedné množiny, použít je jako klíče v&nbsp;jedné mapě
atd.</li>

<li>Ve formátu EDN se taktéž striktně rozlišuje mezi celočíselnými hodnotami a
numerickými hodnotami s&nbsp;plovoucí řádovou čárkou. To například znamená, že
hodnota <strong>42</strong> je odlišná od hodnoty <strong>42.0</strong> a tudíž
je možné obě tyto hodnoty použít jako (rozdílné) klíče v&nbsp;jediné mapě či
jako dva prvky v&nbsp;množině. Pro ty programovací jazyky, které mají pouze
jeden numerický datový typ, je toto rozlišení minimálně problematické.</li>

<li>EDN podporuje čtyři typy kontejnerů, a to konkrétně seznamy, vektory, mapy
a množiny. Většina ostatních jazyků, které EDN podporují, dokáže pracovat se
seznamy a vektory jako s&nbsp;poli (což je v&nbsp;pořádku, liší se jen způsob
uložení hodnot) a s&nbsp;mapami (nazývanými většinou asociativní pole). Práce
s&nbsp;množinami tedy musí být řešena tak, že se tato <i>hodnota</i> převede na
vhodný objekt.</li>

<li>Již několikrát jsme se v&nbsp;předchozích odstavcích zmínili o mapách.
V&nbsp;EDN je možné použít <i>jakékoli hodnoty</i> ve funkci klíče nějakého
prvku. To znamená, že klíčem může být například hodnota <strong>nil</strong>,
pochopitelně řetězec, ale i vektor, mapa, mapa obsahující jako své prvky další
mapu atd. atd. A tato vlastnost není v&nbsp;mnoha dalších programovacích
jazycích, které s&nbsp;EDN pracují, korektně implementována, což znamená, že
není možné mapy z&nbsp;EDN přímo převádět na asociativní pole v&nbsp;těchto
programovacích jazycích.</li>

</ol>

<p>V&nbsp;navazujících kapitolách si ukážeme příklady některých EDN, které
nejsou či nemusí být ve všech případech správně zpracovány (což do značné míry
souvisí se sémantikou daných programovacích jazyků).</p>



<p><a name="k15"></a></p>
<h2 id="k15">15. Konverze hodnot prováděné v&nbsp;Pythonu</h2>

<p>Pro otestování vlastností knihovny <strong>edn_format</strong> určené pro
programovací jazyk Python, kterou jsme si popsali minule, použijeme následující
jednoduchý skript, který načte soubor ve formátu EDN a zobrazí formu načtených
dat:</p>

<pre>
<i>#!/usr/bin/env python3</i>
&nbsp;
<i># Converts structured data from EDN format into JSON format.</i>
&nbsp;
import sys
import edn_format
&nbsp;
<i># Check if command line argument is specified (it is mandatory).</i>
if len(sys.argv) &gt; 2:
    print("Usage:")
    print("  print_edn.py input_file.edn")
    print("Example:")
    print("  print_edn.py report.edn")
    sys.exit(1)
&nbsp;
<i># First command line argument should contain name of input EDN file.</i>
filename = sys.argv[1]
&nbsp;
&nbsp;
<i># Try to open the EDN file specified.</i>
with open(filename, "r") as edn_input:
    <i># open the EDN file and parse it</i>
    payload = edn_format.loads(edn_input.read())
    print(payload)
</pre>

<p>Začneme mapou obsahující celočíselné hodnoty i hodnoty s&nbsp;plovoucí
řádovou čárkou:</p>

<p>Vstup:</p>

<pre>
{"foo" 42
 "bar" 42.0}
</pre>

<p>Výstup:</p>

<pre>
{'foo': 42, 'bar': 42.0}
</pre>

<p>V&nbsp;předchozím příkladu by vše v&nbsp;pořádku, takže zkusme použití
numerických hodnot ve funkci klíčů:</p>

<p>Vstup:</p>

<pre>
{42 "a"
 42.0 "b"}
</pre>

<p>Výstup:</p>

<pre>
{42: 'b'}
</pre>

<p>V&nbsp;tomto případě došlo ke konverzi a ztrátě jedné z&nbsp;hodnot
v&nbsp;mapě.</p>

<p>Použití <i>keywords</i> ve funkci klíčů:</p>

<p>Vstup:</p>

<pre>
{:foo "a"
 :bar "b"}
</pre>

<p>Výstup:</p>

<pre>
{Keyword(foo): 'a', Keyword(bar): 'b'}
</pre>

<p>Vše je v&nbsp;pořádku &ndash; <i>keywords</i> jsou reprezentovány
objektem.</p>

<p>Kombinace <i>keyword</i> a řetězce ve funkci klíče:</p>

<p>Vstup:</p>

<pre>
{:foo "a"
 "foo" "b"}
</pre>

<p>Výstup:</p>

<pre>
{Keyword(foo): 'a', 'foo': 'b'}
</pre>

<p>Použití hodnoty <strong>nil</strong>:</p>

<p>Vstup:</p>

<pre>
{nil "a"
 "foo" "b"
 "nic" nil}
</pre>

<p>Výstup:</p>

<pre>
{None: 'a', 'foo': 'b', 'nic': None}
</pre>

<p>Opět můžeme vidět, že je vše v&nbsp;pořádku.</p>



<p><a name="k16"></a></p>
<h2 id="k16">16. Načtení složitějších datových struktur</h2>

<p>Mapa se složenými klíči obsahujícími různé typy hodnot:</p>

<p>Vstup:</p>

<pre>
{nil       "a"
 "foo"     "b"
 ["a" "b"] "c"
 [1 2 3]   4
 #{1 2 3}  4
 "nic"     nil}
</pre>

<p>Výstup:</p>

<pre>
{None: 'a', 'foo': 'b', ['a', 'b']: 'c', [1, 2, 3]: 4, frozenset({1, 2, 3}): 4, 'nic': None}
</pre>

<p>Vstupem nemusí být pouze mapa, ale například přímo množina:</p>

<pre>
#{nil "a" "foo" "b" ["a" "b"] "c" [1 2 3] 4 #{1 2 3} 5 "nic" :nil}
</pre>

<p>Výstup:</p>

<pre>
frozenset({'foo', 4, 5, 'a', frozenset({1, 2, 3}), 'nic', [1, 2, 3], None, ['a', 'b'], Keyword(nil), 'b', 'c'})
</pre>

<p><div class="rs-tip-major">Poznámka: v&nbsp;tomto případě je použit objekt
typu <a
href="https://docs.python.org/3/library/stdtypes.html#frozenset">frozenset</a>
ze standardní knihovny programovacího jazyka Python.</div></p>

<p>Často se taktéž setkáme s&nbsp;maticemi:</p>

<pre>
[[ 1  2  3  4]
 [ 5  6  7  8]
 [ 9 10 11 12]
 [13 14 15 16]]
</pre>

<p>Výstup:</p>

<pre>
[[1, 2, 3, 4], [5, 6, 7, 8], [9, 10, 11, 12], [13, 14, 15, 16]]
</pre>

<p>Nebo se seznamy seznamů:</p>

<pre>
[[ 1  2  3  4]
 [ 5  6  7  8]
 [ 9 10 11 12]
 [13 14 15 16]]
</pre>

<p>Výstup:</p>

<pre>
((1, 2, 3, 4), (5, 6, 7, 8), (9, 10, 11, 12), (13, 14, 15, 16))
</pre>

<p>A nakonec reálná data používaná v&nbsp;ekosystému programovacího jazyka Clojure:</p>

<pre>
{:aliases {"downgrade" "upgrade"},
 :checkout-deps-shares
 [:source-paths
  :test-paths
  :resource-paths
  :compile-path
  "#'leiningen.core.classpath/checkout-deps-paths"],
 :clean-targets [:target-path],
 :compile-path
 "/home/ptisnovs/src/presentations/edn/edn2json/target/default/classes",
 :dependencies
 ([org.clojure/clojure "1.10.1"]
  [org.clojure/data.json "2.2.0"]
  [nrepl/nrepl "0.7.0" :exclusions ([org.clojure/clojure])]
  [clojure-complete/clojure-complete
   "0.2.5"
   :exclusions
   ([org.clojure/clojure])]
  [venantius/ultra "0.6.0"]),
 :deploy-repositories
 [["clojars"
   {:url "https://repo.clojars.org/",
    :password :gpg,
    :username :gpg}]],
 :description "FIXME: write description",
 :eval-in :subprocess,
 :global-vars {},
 :group "edn2json",
 :jar-exclusions ["#\"^\\.\"" "#\"\\Q/.\\E\""],
 :jvm-opts
 ["-XX:-OmitStackTraceInFastThrow"
  "-XX:+TieredCompilation"
  "-XX:TieredStopAtLevel=1"],
 :license
 {:name "EPL-2.0 OR GPL-2.0-or-later WITH Classpath-exception-2.0",
  :url "https://www.eclipse.org/legal/epl-2.0/"},
 :main edn2json.core,
 :monkeypatch-clojure-test false,
 :name "edn2json",
 :native-path
 "/home/ptisnovs/src/presentations/edn/edn2json/target/default/native",
 :offline? false,
 :pedantic? ranges,
 :plugin-repositories
 [["central"
   {:url "https://repo1.maven.org/maven2/", :snapshots false}]
  ["clojars" {:url "https://repo.clojars.org/"}]],
 :plugins
 ([lein-project-edn/lein-project-edn "0.3.0"]
  [venantius/ultra "0.6.0"]
  [lein-kibit/lein-kibit "0.1.8"]),
 :prep-tasks ["javac" "compile"],
 :profiles
 :project-edn {:output-file "details.clj"},
 :release-tasks
 [["vcs" "assert-committed"]
  ["change" "version" "leiningen.release/bump-version" "release"]
  ["vcs" "commit"]
  ["vcs" "tag"]
  ["deploy"]
  ["change" "version" "leiningen.release/bump-version"]
  ["vcs" "commit"]
  ["vcs" "push"]],
 :repl-options
 :repositories
 [["central"
   {:url "https://repo1.maven.org/maven2/", :snapshots false}]
  ["clojars" {:url "https://repo.clojars.org/"}]],
 :resource-paths
 ("/home/ptisnovs/src/presentations/edn/edn2json/dev-resources"
  "/home/ptisnovs/src/presentations/edn/edn2json/resources"),
 :root
 "/home/ptisnovs/src/presentations/edn/edn2json",
 :source-paths
 ("/home/ptisnovs/src/presentations/edn/edn2json/src"),
 :target-path
 "/home/ptisnovs/src/presentations/edn/edn2json/target/default",
 :test-paths
 ("/home/ptisnovs/src/presentations/edn/edn2json/test"),
 :test-selectors {:default (constantly true)},
 :uberjar-exclusions ["#\"(?i)^META-INF/[^/]*\\.(SF|RSA|DSA)$\""],
 :url "http://example.com/FIXME",
 :version "0.1.0-SNAPSHOT"
}
</pre>

<p>Výstup:</p>

<pre>
{Keyword(aliases): {'downgrade': 'upgrade'},
 Keyword(checkout-deps-shares): [Keyword(source-paths),
                                 Keyword(test-paths),
                                 Keyword(resource-paths),
                                 Keyword(compile-path),
                                 "#'leiningen.core.classpath/checkout-deps-paths"],
 Keyword(clean-targets): [Keyword(target-path)],
 Keyword(compile-path): '/home/ptisnovs/src/presentations/edn/edn2json/target/default/classes',
 Keyword(dependencies): ([Symbol(org.clojure/clojure), '1.10.1'],
                         [Symbol(org.clojure/data.json), '2.2.0'],
                         [Symbol(nrepl/nrepl), '0.7.0', Keyword(exclusions), ([Symbol(org.clojure/clojure)],)],
                         [Symbol(clojure-complete/clojure-complete), '0.2.5', Keyword(exclusions),
                         ([Symbol(org.clojure/clojure)],)], [Symbol(venantius/ultra), '0.6.0']),
 ...
 ...
 ...
</pre>

<p><div class="rs-tip-major">Poznámka: povšimněte si, že i symboly jsou
zpracovány a reprezentovány formou objektu.</div></p>



<p><a name="k17"></a></p>
<h2 id="k17">17. Uživatelem definované tagy</h2>



<p><a name="k18"></a></p>
<h2 id="k18">18. </h2>

<pre>
[#complex {:real 10.0 :imag 20.0}
 #user "root"]
</pre>

<pre>
$ <strong>./print_edn.py t1.edn </strong>
&nbsp;
Traceback (most recent call last):
  File "./print_edn.py", line 23, in <module>
    payload = edn_format.loads(edn_input.read())
  File "/home/ptisnovs/.local/lib/python3.6/site-packages/edn_format/edn_parse.py", line 244, in parse
    expressions = parse_all(text, **kwargs)
  File "/home/ptisnovs/.local/lib/python3.6/site-packages/edn_format/edn_parse.py", line 234, in parse_all
    expressions = p.parse(text, lexer=lex())
  File "/home/ptisnovs/.local/lib/python3.6/site-packages/ply/yacc.py", line 333, in parse
    return self.parseopt_notrack(input, lexer, debug, tracking, tokenfunc)
  File "/home/ptisnovs/.local/lib/python3.6/site-packages/ply/yacc.py", line 1120, in parseopt_notrack
    p.callable(pslice)
  File "/home/ptisnovs/.local/lib/python3.6/site-packages/edn_format/edn_parse.py", line 199, in p_expression_tagged_element
    u"Don't know how to handle tag ImmutableDict({})".format(tag))
NotImplementedError: Don't know how to handle tag ImmutableDict(complex)
</pre>

<pre>


# Check if command line argument is specified (it is mandatory).
if len(sys.argv) &lt; 2:
    print("Usage:")
    print("  print_edn.py input_file.edn")
    print("Example:")
    print("  print_edn.py report.edn")
    sys.exit(1)

# First command line argument should contain name of input EDN file.
filename = sys.argv[1]


# Try to open the EDN file specified.
with open(filename, "r") as edn_input:
    # open the EDN file and parse it
    payload = edn_format.loads(edn_input.read())
    print(payload)
</pre>



<p><a name="k19"></a></p>
<h2 id="k19">19. Repositář s&nbsp;demonstračními příklady</h2>

<p>Zdrojové kódy všech <a
href="https://www.root.cz/clanky/format-edn-extensible-data-notation/">minule</a>
i dnes popsaných demonstračních příkladů vyvinutých v&nbsp;programovacích
jazycích Clojure, Python i Go, byly uloženy do Git repositáře, který je
dostupný na adrese <a
href="https://github.com/tisnik/presentations">https://github.com/tisnik/presentations</a>:</p>

<table>
<tr><th> #</th><th>Zdrojový kód</th><th>Stručný popis souboru</th><th>Cesta</th></tr>
<tr><td> 1</td><td>json2edn.py</td><td>konverze mezi formátem JSON a EDN naprogramovaná v&nbsp;Pythonu</td><td><a href="https://github.com/tisnik/presentations/blob/master/edn/json2edn.py">https://github.com/tisnik/presentations/blob/master/edn/json2edn.py</a></td></tr>
<tr><td> 2</td><td>edn2json.py</td><td>konverze mezi formátem EDN a JSON naprogramovaná v&nbsp;Pythonu</td><td><a href="https://github.com/tisnik/presentations/blob/master/edn/edn2json.py">https://github.com/tisnik/presentations/blob/master/edn/edn2json.py</a></td></tr>
<tr><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td></tr>
<tr><td> 3</td><td>json2edn (adresář)</td><td>konverze mezi formátem JSON a EDN naprogramovaná v&nbsp;Clojure</td><td><a href="https://github.com/tisnik/presentations/blob/master/edn/json2edn">https://github.com/tisnik/presentations/blob/master/edn/json2edn</a></td></tr>
<tr><td> 4</td><td>edn2json (adresář)</td><td>konverze mezi formátem EDN a JSON naprogramovaná v&nbsp;Clojure</td><td><a href="https://github.com/tisnik/presentations/blob/master/edn/edn2json">https://github.com/tisnik/presentations/blob/master/edn/edn2json</a></td></tr>
<tr><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td></tr>
<tr><td> 5</td><td>properties2edn (adresář)</td><td>konverze mezi .properties souborem a formátem EDN (Clojure)</td><td><a href="https://github.com/tisnik/presentations/blob/master/edn/properties2edn">https://github.com/tisnik/presentations/blob/master/edn/properties2edn</a></td></tr>
<tr><td> 6</td><td>xml2edn (adresář)</td><td>konverze mezi XML a formátem EDN (Clojure, plná konverze)</td><td><a href="https://github.com/tisnik/presentations/blob/master/edn/xml2edn">https://github.com/tisnik/presentations/blob/master/edn/xml2edn</a></td></tr>
<tr><td> 7</td><td>forest-demo (adresář)</td><td>různé možnosti konverze mezi XML a formátem EDN</td><td><a href="https://github.com/tisnik/presentations/blob/master/edn/forest-demo">https://github.com/tisnik/presentations/blob/master/edn/forest-demo</a></td></tr>
<tr><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td></tr>
<tr><td> 8</td><td>go-edn-basic-types-1 (adresář)</td><td>serializace (marshalling) celočíselných datových typů do formátu EDN</td><td><a href="https://github.com/tisnik/presentations/blob/master/edn/go-edn-basic-types-1">https://github.com/tisnik/presentations/blob/master/edn/go-edn-basic-types-1</a></td></tr>
<tr><td> 9</td><td>go-edn-basic-types-2 (adresář)</td><td>serializace (marshalling) celočíselných datových typů do formátu EDN</td><td><a href="https://github.com/tisnik/presentations/blob/master/edn/go-edn-basic-types-2">https://github.com/tisnik/presentations/blob/master/edn/go-edn-basic-types-2</a></td></tr>
<tr><td>10</td><td>go-edn-basic-types-3 (adresář)</td><td>serializace (marshalling) komplexních čísel do formátu EDN</td><td><a href="https://github.com/tisnik/presentations/blob/master/edn/go-edn-basic-types-3">https://github.com/tisnik/presentations/blob/master/edn/go-edn-basic-types-3</a></td></tr>
<tr><td>11</td><td>go-edn-basic-types-4 (adresář)</td><td>serializace (marshalling) hodnot <strong>nil</strong> a řetězců do formátu EDN</td><td><a href="https://github.com/tisnik/presentations/blob/master/edn/go-edn-basic-types-4">https://github.com/tisnik/presentations/blob/master/edn/go-edn-basic-types-4</a></td></tr>
<tr><td>12</td><td>go-edn-arrays (adresář)</td><td>serializace (marshalling) polí do formátu EDN</td><td><a href="https://github.com/tisnik/presentations/blob/master/edn/go-edn-arrays">https://github.com/tisnik/presentations/blob/master/edn/go-edn-arrays</a></td></tr>
<tr><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td></tr>
<tr><td>13</td><td>go-edn-1 (adresář)</td><td>serializace (marshalling) datové struktury do formátu EDN</td><td><a href="https://github.com/tisnik/presentations/blob/master/edn/go-edn-1">https://github.com/tisnik/presentations/blob/master/edn/go-edn-1</a></td></tr>
<tr><td>14</td><td>go-edn-2 (adresář)</td><td>specifikace názvů klíčů v&nbsp;EDN formátu</td><td><a href="https://github.com/tisnik/presentations/blob/master/edn/go-edn-2">https://github.com/tisnik/presentations/blob/master/edn/go-edn-2</a></td></tr>
<tr><td>15</td><td>go-edn-3 (adresář)</td><td>uložení pole datových struktur do formátu EDN</td><td><a href="https://github.com/tisnik/presentations/blob/master/edn/go-edn-3">https://github.com/tisnik/presentations/blob/master/edn/go-edn-3</a></td></tr>
<tr><td>16</td><td>go-edn-4 (adresář)</td><td>uložení mapy datových struktur do formátu EDN</td><td><a href="https://github.com/tisnik/presentations/blob/master/edn/go-edn-4">https://github.com/tisnik/presentations/blob/master/edn/go-edn-4</a></td></tr>
<tr><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td></tr>
<tr><td>17</td><td>go-edn-5 (adresář)</td><td>deserializace (unmarshalling) známé datové struktury z&nbsp;formátu EDN</td><td><a href="https://github.com/tisnik/presentations/blob/master/edn/go-edn-5">https://github.com/tisnik/presentations/blob/master/edn/go-edn-5</a></td></tr>
<tr><td>18</td><td>go-edn-6 (adresář)</td><td>deserializace (unmarshalling) neznámé datové struktury z&nbsp;formátu EDN</td><td><a href="https://github.com/tisnik/presentations/blob/master/edn/go-edn-6">https://github.com/tisnik/presentations/blob/master/edn/go-edn-6</a></td></tr>
<tr><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td></tr>
<tr><td>19</td><td>print_edn.py</td><td>skript, který vytiskne obsah vybraného souboru uloženého ve formátu EDN</td><td><a href="https://github.com/tisnik/presentations/blob/master/edn/print_edn.py">https://github.com/tisnik/presentations/blob/master/edn/print_edn.py</a></td></tr>
</table>



<p><a name="k20"></a></p>
<h2 id="k20">20. Odkazy na Internetu</h2>

<ol>

<li>edn &ndash; extensible data notation<br />
<a href="https://github.com/edn-format/edn">https://github.com/edn-format/edn</a>
</li>

<li>Programming with Data and EDN<br />
<a href="https://docs.datomic.com/cloud/whatis/edn.html">https://docs.datomic.com/cloud/whatis/edn.html</a>
</li>

<li>Video about EDN<br />
<a href="https://docs.datomic.com/cloud/livetutorial/edntutorial.html">https://docs.datomic.com/cloud/livetutorial/edntutorial.html</a>
</li>

<li>(Same) video about EDN on Youtube<br />
<a href="https://www.youtube.com/watch?v=5eKgRcvEJxU">https://www.youtube.com/watch?v=5eKgRcvEJxU</a>
</li>

<li>clojure.edn<br />
<a href="https://clojuredocs.org/clojure.edn">https://clojuredocs.org/clojure.edn</a>
</li>

<li>API for clojure.edn - Clojure v1.10.2 (stable)<br />
<a href="https://clojure.github.io/clojure/clojure.edn-api.html">https://clojure.github.io/clojure/clojure.edn-api.html</a>
</li>

<li>Clojure EDN Walkthrough<br />
<a href="https://www.compoundtheory.com/clojure-edn-walkthrough/">https://www.compoundtheory.com/clojure-edn-walkthrough/</a>
</li>

<li>Články týkající se Pythonu na Rootu<br />
<a href="https://www.root.cz/n/python/">https://www.root.cz/n/python/</a>
</li>

<li>Články týkající se programovacího jazyka Clojure na Rootu<br />
<a href="https://www.root.cz/n/clojure/">https://www.root.cz/n/clojure/</a>
</li>

<li>Seriál Programovací jazyk Go<br />
<a href="https://www.root.cz/serialy/programovaci-jazyk-go/">https://www.root.cz/serialy/programovaci-jazyk-go/</a>
</li>

<li>Crux<br />
<a href="https://opencrux.com/main/index.html">https://opencrux.com/main/index.html</a>
</li>

<li>Crux Installation<br />
<a href="https://opencrux.com/reference/21.04-1.16.0/installation.html">https://opencrux.com/reference/21.04-1.16.0/installation.html</a>
</li>

<li>read<br />
<a href="https://clojuredocs.org/clojure.edn/read">https://clojuredocs.org/clojure.edn/read</a>
</li>

<li>read-string<br />
<a href="https://clojuredocs.org/clojure.edn/read-string">https://clojuredocs.org/clojure.edn/read-string</a>
</li>

<li>Tupelo 21.04.12 (dokumentace)<br />
<a href="https://cloojure.github.io/doc/tupelo/">https://cloojure.github.io/doc/tupelo/</a>
</li>

<li>tupelo - Clojure With A Spoonful of Honey<br />
<a href="https://clojars.org/tupelo">https://clojars.org/tupelo</a>
</li>

<li>Clojure Cookbook: Templating HTML with Enlive<br />
<a href="https://github.com/clojure-cookbook/clojure-cookbook/blob/master/07_webapps/7-11_enlive.asciidoc">https://github.com/clojure-cookbook/clojure-cookbook/blob/master/07_webapps/7-11_enlive.asciidoc</a>
</li>

<li>An Introduction to Enlive<br />
<a href="https://github.com/swannodette/enlive-tutorial/">https://github.com/swannodette/enlive-tutorial/</a>
</li>

<li>Enlive na GitHubu<br />
<a href="https://github.com/cgrand/enlive">https://github.com/cgrand/enlive</a>
</li>

<li>data.json<br />
<a href="https://github.com/clojure/data.json">https://github.com/clojure/data.json</a>
</li>

<li>data.json API reference<br />
<a href="https://clojure.github.io/data.json/">https://clojure.github.io/data.json/</a>
</li>

<li>Clojure: Writing JSON to a File/Reading JSON From a File<br />
<a href="https://dzone.com/articles/clojure-writing-json">https://dzone.com/articles/clojure-writing-json</a>
</li>

<li>How to pretty print JSON to a file in Clojure?<br />
<a href="https://stackoverflow.com/questions/23307552/how-to-pretty-print-json-to-a-file-in-clojure">https://stackoverflow.com/questions/23307552/how-to-pretty-print-json-to-a-file-in-clojure</a>
</li>

<li>go-edn / edn<br />
<a href="https://github.com/go-edn/edn">https://github.com/go-edn/edn</a>
</li>

<li>Queries (Crux)<br />
<a href="https://opencrux.com/reference/21.04-1.16.0/queries.html">https://opencrux.com/reference/21.04-1.16.0/queries.html</a>
</li>

<li>Essential EDN<br />
<a href="https://opencrux.com/tutorials/essential-edn.html">https://opencrux.com/tutorials/essential-edn.html</a>
</li>

<li>Babashka: interpret Clojure určený pro rychlé spouštění utilit z příkazového řádku<br />
<a href="https://www.root.cz/clanky/babashka-interpret-clojure-urceny-pro-rychle-spousteni-utilit-z-prikazoveho-radku/">https://www.root.cz/clanky/babashka-interpret-clojure-urceny-pro-rychle-spousteni-utilit-z-prikazoveho-radku/</a>
</li>

<li>Introducing JSON<br />
<a href="https://www.json.org/json-en.html">https://www.json.org/json-en.html</a>
</li>

<li>ISO 8601<br />
<a href="https://xkcd.com/1179/">https://xkcd.com/1179/</a>
</li>

<li>What is the right JSON date format<br />
<a href="https://stackoverflow.com/questions/10286204/what-is-the-right-json-date-format">https://stackoverflow.com/questions/10286204/what-is-the-right-json-date-format</a>
</li>

<li>ClojureScript REPL<br />
<a href="https://clojurescript.io/">https://clojurescript.io/</a>
</li>

</ol>



<p></p><p></p>
<p><small>Autor: <a href="http://www.fit.vutbr.cz/~tisnovpa">Pavel Tišnovský</a> &nbsp; 2021</small></p>
</body>
</html>

