<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
        "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html>
<head>
<title>Programovací jazyk Pixie: funkce ze základní knihovny a použití FFI</title>
<meta name="Author" content="Pavel Tisnovsky" />
<meta name="Generator" content="vim" />
<meta http-equiv="content-type" content="text/html; charset=utf-8" />
<style type="text/css">
         body {color:#000000; background:#ffffff;}
         h1  {font-family: arial, helvetica, sans-serif; color:#ffffff; background-color:#c00000; text-align:center; padding-left:1em}
         h2  {font-family: arial, helvetica, sans-serif; color:#ffffff; background-color:#0000c0; padding-left:1em; text-align:left}
         h3  {font-family: arial, helvetica, sans-serif; color:#000000; background-color:#c0c0c0; padding-left:1em; text-align:left}
         h4  {font-family: arial, helvetica, sans-serif; color:#000000; background-color:#e0e0e0; padding-left:1em; text-align:left}
         a   {font-family: arial, helvetica, sans-serif;}
         li  {font-family: arial, helvetica, sans-serif; color:#000000; text-align:justify; width:450px;}
         ol  {font-family: arial, helvetica, sans-serif; color:#000000; text-align:justify; width:450px;}
         ul  {font-family: arial, helvetica, sans-serif; color:#000000; text-align:justify; width:450px;}
         p   {font-family: arial, helvetica, sans-serif; color:#000000; text-align:justify;}
         pre {background:#e0e0e0}
</style>
</head>

<body>

<h1>Programovací jazyk Pixie: funkce ze základní knihovny a použití FFI</h1>

<h3>Pavel Tišnovský</h3>

<p></p>

<h1>Úvodník</h1>

<p>Ve druhé a současně i závěrečné části článku o programovacím jazyce Pixie si nejprve ukážeme nejdůležitější funkce ze základní knihovny používané v prakticky všech aplikacích a posléze se budeme zabývat problematikou FFI.</p>



<h2>Obsah</h2>

<p><a href="#k01">1. Programovací jazyk Pixie: funkce ze základní knihovny a použití FFI</a></p>
<p><a href="#k02">2. Použití klasické rekurze</a></p>
<p><a href="#k03">3. Použití tail rekurze</a></p>
<p><a href="#k04">4. Opakování části kódu s&nbsp;použitím konstrukce <strong>dotimes</strong></a></p>
<p><a href="#k05">5. Průchod prvky sekvence s&nbsp;využitím <strong>doseq</strong></a></p>
<p><a href="#k06">6. Generátorová notace seznamu &ndash; list comprehension</a></p>
<p><a href="#k07">7. Praktický příklad &ndash; výpočet Eulerova čísla s&nbsp;využitím <strong>doseq</strong>, <strong>for</strong> a <strong>reduce</strong></a></p>
<p><a href="#k08">8. Použití programové konstrukce <strong>loop</strong>/<strong>recur</strong></a></p>
<p><a href="#k09">9. Použití FFI aneb volání nativních funkcí</a></p>
<p><a href="#k10">10. Nativní funkce dostupné ze standardních modulů jazyka Pixie</a></p>
<p><a href="#k11">11. Příklad &ndash; vygenerování perexového obrázku k&nbsp;tomuto článku</a></p>
<p><a href="#k12">12. Problém s&nbsp;nativními funkcemi typu <strong>printf</strong></a></p>
<p><a href="#k13">13. Odkazy na předchozí části tohoto seriálu</a></p>
<p><a href="#k14">14. Odkazy na Internetu</a></p>



<p><a name="k01"></a></p>
<h2 id="k01">1. Programovací jazyk Pixie: funkce ze základní knihovny a použití FFI</h2>

<p><a
href="https://www.root.cz/clanky/pixie-lehky-skriptovaci-jazyk-s-kouzelnymi-schopnostmi/">V&nbsp;úvodním
článku</a> o programovacím jazyku <i>Pixie</i> jsme se seznámili se základními
vlastnostmi tohoto programovacího jazyka. Připomeňme si, že Pixie se po stránce
syntaxe a z&nbsp;velké části i sémantiky podobá jazyku Clojure, ovšem
s&nbsp;tím rozdílem, že zatímco Clojure je určen pro běh nad nějakým větším a
univerzálnějším virtuálním strojem (JVM, CLR, VM JavaScriptu), má programovací
jazyk Pixie vlastní (výrazně menší) virtuální stroj využívající PyPy. Dnes se
<a href="#k02">nejprve</a> seznámíme s&nbsp;dalšími funkcemi a makry ze
základní knihovny, které jsou určeny pro implementaci programových smyček, tail
rekurze či generátorové notace seznamu (<i>list comprehension</i>). <a
href="#k09">Ve druhé části</a> se budeme zabývat problematikou FFI,
tj.&nbsp;volání nativních funkcí přímo ze skriptů napsaných v&nbsp;jazyce
<i>Pixie</i>.</p>



<p><a name="k02"></a></p>
<h2 id="k02">2. Použití klasické rekurze</h2>

<p>V&nbsp;programovacím jazyku <i>Pixie</i> se, podobně jako v&nbsp;mnoha
dalších programovacích jazycích, většinou nepoužívají klasické programové
smyčky. Namísto nich se využívají funkce vyššího řádu (<strong>map</strong>,
<strong>reduce</strong>, <strong>filter</strong> atd.), generátorová notace
seznamu představovaná makrem <strong>for</strong>, klasická přímá rekurze nebo
tzv.&nbsp;tail rekurze. Nejprve si ukažme použití přímé rekurze,
tj.&nbsp;takového zápisu, kdy se v&nbsp;těle vytvářené funkce může objevit
volání této funkce. Zcela typickým &bdquo;školním&ldquo; příkladem rekurzivní
funkce je funkce pro výpočet faktoriálu, jejíž jednoduchá varianta (neochráněná
před všemi typy vstupů) může vypadat takto:</p>

<pre>
user=&gt; <strong>(defn fact [n] (if (&lt;= n 1) 1 (* n (fact (- n 1)))))</strong>
#'user/fact
</pre>

<p>Funkci lze samozřejmě přepsat do čitelnějšího tvaru:</p>

<pre>
(defn fact
    [n]
    (if (&lt;= n 1)
        1
        (* n (fact (- n 1)))))
</pre>

<p>Podobným způsobem je možné rekurzivně implementovat funkci pro výpočet
největšího společného dělitele dvou přirozených čísel. V&nbsp;následující
implementaci schválně nepoužívám výpočet zbytku po dělení, ale pouze postupný
výpočet rozdílu mezivýsledků:</p>

<pre>
(defn gcd
    [x y]
    (if (= x y) x
                (if (&gt; x y)
                    (gcd (- x y) y)
                    (gcd x (- y x)))))
</pre>

<p>Opět si zkusme tuto funkci otestovat. Pro malé vstupní hodnoty (přirozená
čísla!) pracuje bez problémů:</p>

<pre>
user =&gt; <strong>(gcd 1 1)</strong>
1
&nbsp;
user =&gt; <strong>(gcd 1 2)</strong>
1
&nbsp;
user =&gt; <strong>(gcd 4 2)</strong>
2
&nbsp;
user =&gt; <strong>(gcd 6 9)</strong>
3
&nbsp;
user =&gt; <strong>(gcd 12 8)</strong>
4
&nbsp;
user =&gt; <strong>(gcd 1024 768)</strong>
256
</pre>

<p>Co se však stane pro větší vstupy?:</p>

<pre>
user =&gt; (gcd 123456 98765)
ERROR: 
 RuntimeException: :pixie.stdlib/InternalError Internal error: &lt;StackOverflow object at 0xccc6f8&gt;
</pre>

<p>Vidíme, že zápis algoritmu přímou rekurzí sice může být elegantní a může
vycházet přímo z&nbsp;definice řešení problému (viz faktoriál, ovšem i spousta
dalších funkcí je v&nbsp;matematice definována rekurzivně), ale
z&nbsp;praktického hlediska zde evidentně existují technická omezení.</p>



<p><a name="k03"></a></p>
<h2 id="k03">3. Použití tail rekurze</h2>

<p>Důvod, proč předchozí volání funkce <strong>gcd</strong> skončilo
s&nbsp;chybou, spočívá v&nbsp;tom, že došlo k&nbsp;přeplnění zásobníku při
rekurzivním volání. Na zásobník se totiž musí v&nbsp;takzvané <i>winding
fázi</i> ukládat parametry předávané volané funkci a taktéž body návratu
(zjednodušeně řečeno návratové adresy). Aby k&nbsp;přetečení zásobníku
nedocházelo, můžeme naši funkci <strong>gcd</strong> upravit tak, aby se
využívalo takzvané <i>tail rekurze</i>. Velmi zjednodušeně řečeno je <i>tail
rekurze</i> použita tehdy, pokud je posledním příkazem nějaké funkce příkaz pro
rekurzivní volání té samé funkce. V&nbsp;tomto případě se nemusí na zásobník
nic ukládat a namísto toho se prostě provede skok. V&nbsp;jazyku <i>Pixie</i>
se však musí <i>tail rekurze</i> zapsat explicitně, což má své přednosti i
zápory (podle mě převažují přednosti, protože již ze zápisu programu je zcela
zřejmé, kdy k&nbsp;<i>tail rekurzi</i> skutečně dojde).</p>

<p>Explicitní zápis rekurze spočívá ve využití speciální formy
<strong>recur</strong>, která se zapíše přesně do místa, kde má k&nbsp;tail
rekurzi (=skoku) dojít. U funkce <strong>gcd</strong> je použití přímočaré,
prostě se na posledních dvou řádcích nahradí <strong>(gcd parametry)</strong>
za <strong>(recur parametry)</strong>:</p>

<pre>
(defn gcd
    [x y]
    (if (= x y) x
                (if (&gt; x y)
                    (recur (- x y) y)
                    (recur x (- y x)))))
</pre>

<p>Chování si můžeme ihned otestovat na příkladu, který v&nbsp;případě zápisu
algoritmu přímou rekurzí zhavaroval:</p>

<pre>
user =&gt; (gcd 123456 98765)
1
</pre>

<p>Ještě větší hodnoty také nezpůsobí žádné problémy:</p>

<pre>
user =&gt; (gcd 120000000000 800224)
32
</pre>

<p>Mohlo by se zdát, že by překladač programovacího jazyka Pixie snad bylo
možné zmást a použít <strong>recur</strong> jako náhradu skoku kdekoli. Ve
skutečnosti si však překladač hlídá, zda je <strong>recur</strong> použito
správně:</p>

<pre>
(defn fact
    [n]
    (if (&lt;= n 1)
        1
        (* n (recur (- n 1)))))
</pre>

<p>Překladač vypíše následující (zcela korektní) chybové hlášení:</p>

<pre>
ERROR: 
 in pixie function repl_fn
&nbsp;
in pixie/repl.pxi at 27:24
               (let [x (eval form)]
                       ^
in internal function eval
&nbsp;
RuntimeException: :pixie.stdlib/AssertionException Can't recur in non-tail position
</pre>

<p>Funkci <strong>fact</strong> je totiž nutné nejdříve upravit tak, aby
rekurzivní volání skutečně nepotřebovalo zásobník. Například lze použít
akumulátor a funkci s&nbsp;více aritami (zjednodušeně řečeno &ndash;
<strong>fact</strong> lze volat s&nbsp;jedním parametrem či se dvěma parametry,
přičemž druhým parametrem bude mezihodnota uložená do akumulátoru):</p>

<pre>
(defn fact
    ([n]
     (fact n 1))
    ([n acc]
     (if (&lt;= n 1)
         acc
         (recur (dec n) (* acc n)))))
</pre>

<p>Nyní již vše bude fungovat bez přetečení zásobníku:</p>

<pre>
user =&lt; <strong>(fact 1000)</strong>
&nbsp;
4023872600770937735437024339230039857193748642107146325437999104
2993851239862902059204420848696940480047998861019719605863166687
2994808558901323829669944590997424504087073759918823627727188732
5197795059509952761208749754624970436014182780946464962910563938
8743788648733711918104582578364784997701247663288983595573543251
3185323958463075557409114262417474349347553428646576611667797396
6688202912073791438537195882498081268678383745597317461360853795
3452422158659320192809087829730843139284440328123155861103697680
1357304216168747609675871348312025478589320767169132448426236131
4125087802080002616831510273418279777047846358681701643650241536
9139828126481021309276124489635992870511496497541990934222156683
2572080821333186116811553615836546984046708975602900950537616475
8477284218896796462449451607653534081989013854424879849599533191
0172335555660213945039973628075013783761530712776192684903435262
5200015888535147331611702103968175921510907788019393178114194545
2572238655414610628921879602238389714760885062768629671466746975
6291123408243920816015378088989396451826324367161676217916890977
9911903754031274622289988005195444414282012187361745992642956581
7466283029555702990243241531816172104658320367869061172601587835
2075151628422554026517048330422614397428693306169089796848259012
5458327168226458066526769958652682272807075781391858178889652208
1643483448259932660433676601769996128318607883861502794659551311
5655203609398818061213855860030143569452722420634463179746059468
2573103790084024432438465657245014402821885252470935190620929023
1364932734975655139587205596542287497740114133469627154228458623
7738753823048386568897646192738381490014076731044664025989949022
2221765904339901886018566526485061799702356193897017860040811889
7299183110211712298459016419210688843871218556461249607987229085
1929681937238864261483965738229112312502418664935314397013742853
1926649875337218940694281434118520158014123344828015051399694290
1534830776445690990731524332782882698646027898643211390835062170
9500259738986355427719674282224875758676575234422020757363056949
8825087968928162753848863396909959826280956121450994871701244516
4612603790293091208890869420285106401821543994571568059418727489
9809425474217358240106367740459574178516082923013535808184009699
6372524230560855903700624271243416909004153690105933983835777939
4109700277534720000000000000000000000000000000000000000000000000
0000000000000000000000000000000000000000000000000000000000000000
0000000000000000000000000000000000000000000000000000000000000000
0000000000000000000000000000000000000000000000000000000000000000
00000000N
</pre>



<p><a name="k04"></a></p>
<h2 id="k04">4. Opakování části kódu s&nbsp;použitím konstrukce <strong>dotimes</strong></h2>

<p>V&nbsp;některých částech programu (ve skutečnosti jich však není mnoho) může
být poměrně užitečné makro nazvané jednoduše a přitom příhodně
<strong>dotimes</strong>, které dokáže nějaký výraz (formu) opakovat <i>n</i>
krát. Přitom toto makro může v&nbsp;každé iteraci (opakování) nastavit zvolenou
lokální proměnnou na aktuální hodnotu počitadla, přičemž se hodnota počitadla
v&nbsp;první iteraci vždy nastavuje na nulu a v&nbsp;poslední iteraci dosahuje
zadaného počtu opakování-1:</p>

<pre>
user =&gt; <strong>(doc dotimes)</strong>
pixie.stdlib/dotimes
([[i n] &amp; body])
&nbsp;
Executes the expressions in the body n times.
&nbsp;
  user =&gt; (dotimes [i 3] (println i))
&nbsp;
  1
  2
  3
</pre>

<p>Vzdáleně tedy můžeme toto makro považovat za ekvivalent programové smyčky
<strong>for i in range(n):</strong> v&nbsp;programovacím jazyku <i>Python</i>
či ekvivalent k&nbsp;počítané smyčce <strong>for (int i = 0; i&lt;n;
i++)</strong> známé z&nbsp;céčka (zde bez možnosti mít lokální proměnnou jako
počitadlo), C++, Javy atd. Vzhledem k&nbsp;tomu, že se předpokládá, že forma
&ndash; tělo smyčky &ndash; předaná makru <strong>dotimes</strong> bude mít
nějaký vedlejší efekt, nejedná se sice o čistě funkcionální přístup, nicméně se
někdy s&nbsp;použitím makra <strong>dotimes</strong> můžeme setkat (například
v&nbsp;testech).</p>

<p>V&nbsp;jednoduchém demonstračním příkladu, který si ukážeme, se na
standardní výstup vypisuje převrácená hodnota celých čísel od 0 do 9. Vedlejším
efektem je v&nbsp;tomto případě samotný výpis na standardní výstup funkcí
<strong>println</strong>:</p>

<pre>
user =&gt; <strong>(dotimes [i 10] (println (/ 1.0 i)))</strong>
inf
1.0
0.5
0.3333333333333333
0.25
0.2
0.16666666666666666
0.14285714285714285
0.125
0.1111111111111111
nil
</pre>

<div>Poznámka: poslední vypsané <strong>nil</strong> je
návratovou hodnotou samotného makra <strong>dotimes</strong>, nikoli výsledek
poslední iterace).</div>

<div>Poznámka<sup>2</sup>: Dělení nulou je pro hodnoty
s&nbsp;plovoucí řádovou čárkou povolené, výsledkem je buď <strong>inf</strong>,
<strong>-inf</strong> či <strong>nan</strong>:</div>

<pre>
user =&gt; <strong>(/ 1. 0)</strong>
inf
&nbsp;
user =&gt; <strong>(/ -1. 0)</strong>
-inf
&nbsp;
user =&gt; <strong>(/ 0. 0)</strong>
nan
</pre>

<p>Podívejme se nyní na nepatrně složitější příklad, který by se
v&nbsp;imperativních programovacích jazycích většinou řešil s&nbsp;využitím
dvojice do sebe vnořených počítaných programových smyček. Mějme za úkol vypsat
tabulku malé násobilky, tj.&nbsp;všechny výsledky vzniklé vynásobením dvojic
celých čísel od 1 do 10. Tento algoritmus je možné velmi snadno realizovat
právě s&nbsp;využitím makra <strong>dotimes</strong>, například následujícím
one-linerem:</p>

<pre>
user =&gt; <strong>(dotimes [i 10] (dotimes [j 10] (print (* (+ i 1) (+ j 1)) "\t")) (println))</strong>
</pre>

<p>Malou &bdquo;optimalizací&ldquo; v&nbsp;tomto zápisu by byla náhrada výrazů
<strong>(+ i 1)</strong> za volání funkce <strong>(inc i)</strong>
s&nbsp;prakticky shodným významem (alespoň pro čísla typu integer). Mimochodem:
jméno funkce <strong>inc</strong> může evokovat to, že zvyšuje hodnotu svého
parametru, což však ve skutečnosti ani není možné, neboť se jedná o běžnou
funkci a nikoli o makro či o speciální formu (důležitá je tedy návratová
hodnota této funkce):</p>

<pre>
user =&gt; <strong>(dotimes [i 10] (dotimes [j 10] (print (* (inc i) (inc j)) "\t")) (println))</strong>
</pre>

<p>Pro větší přehlednost si můžeme výše uvedený one-liner přepsat na správně
odsazený program, z&nbsp;něhož je patrné, že se skutečně jedná o ekvivalent
dvou do sebe zanořených programových smyček:</p>

<pre>
(dotimes [i 10]
    (dotimes [j 10]
        (print (* (inc i) (inc j)) "\t"))
    (println))
</pre>

<p>A zde je již výsledek práce tohoto prográmku (poslední <strong>nil</strong>
je opět návratovou hodnotou makra <strong>dotimes</strong>):</p>

<pre>
1     2     3     4     5     6     7     8     9     10
2     4     6     8     10    12    14    16    18    20
3     6     9     12    15    18    21    24    27    30
4     8     12    16    20    24    28    32    36    40
5     10    15    20    25    30    35    40    45    50
6     12    18    24    30    36    42    48    54    60
7     14    21    28    35    42    49    56    63    70
8     16    24    32    40    48    56    64    72    80
9     18    27    36    45    54    63    72    81    90
10    20    30    40    50    60    70    80    90    100
nil
</pre>

<p>Poznámka: na rozdíl od dále uvedené formy
<strong>for</strong> není možné v&nbsp;makru <strong>dotimes</strong> použít
kombinaci dvou či většího množství počitadel. Následující zápis je tedy bude
ignorovat pokus o vytvoření počitadla <strong>j</strong>:</p>

<pre>
user =&gt; <strong>(dotimes [i 10 j 20] (println i))</strong>
0
1
2
3
4
5
6
7
8
9
nil
&nbsp;
user =&gt; <strong>(dotimes [i 10 j 20] (println j))</strong>
ERROR: 
 in pixie function repl_fn
&nbsp;
in pixie/repl.pxi at 27:24
               (let [x (eval form)]
 &nbsp;                      ^
in internal function eval
&nbsp;
in &lt;unknown&gt; at 13:31
(dotimes [i 10 j 20] (println j))
                              ^
RuntimeException: :pixie.stdlib/AssertionException Var j is undefined
</pre>



<p><a name="k05"></a></p>
<h2 id="k05">5. Průchod prvky sekvence s&nbsp;využitím <strong>doseq</strong></h2>

<p>Mnohem častěji než s&nbsp;výše uvedeným makrem <strong>dotimes</strong> se
setkáme s&nbsp;makrem <strong>doseq</strong>, které lze použít pro postupné
procházení všemi prvky zvolené sekvence (a tím pádem i kolekce):</p>

<pre>
user =&gt; <strong>(doc doseq)</strong>
pixie.stdlib/doseq
([binding &amp; body])
&nbsp;
Evaluates all elements of the seq, presumably for side effects. Returns nil.
</pre>

<p>Použití tohoto makra je velmi jednoduché, což je ostatně patrné i
z&nbsp;následujících příkladů.</p>

<p>Průchod prvky vektoru:</p>

<pre>
user =&gt; <strong>(doseq [i ["a" "b" "c" "d"]] (println i))</strong>
a
b
c
d
</pre>

<p>Podobný příklad, ovšem pro seznam:</p>

<pre>
user =&gt; <strong>(doseq [i '("a" "b" "c" "d")] (println i))</strong>
a
b
c
d
</pre>

<p>Průchod všemi prvky množiny (prvky se do množiny obecně ukládají
neuspořádaně):</p>

<pre>
user =&gt; <strong>(doseq [i #{1 2 3 4 5 6}] (print i " "))</strong>
4  6  2  5  3  1  nil
</pre>

<p>Použití pro generované sekvence (ve skutečnosti by bylo mnohem vhodnější
tyto příklady přepsat tak, aby se používala funkce vyššího řádu
<strong>map</strong> či makro <strong>for</strong>):</p>

<pre>
user =&gt; <strong>(doseq [dot (repeat 100 ".")] (print dot))</strong>
....................................................................................................
&nbsp;
user =&gt; <strong>(doseq [i (range 10)] (println (/ i (inc i))))</strong>
0
1/2
2/3
3/4
4/5
5/6
6/7
7/8
8/9
9/10
nil
</pre>

<p>Poznámka: pokud stojíte před takovým problémem, který
vyžaduje průchod nějakou sekvencí (či kolekcí) s&nbsp;tím, že výsledkem má být
jiná sekvence, není použití makra <strong>doseq</strong> vhodné, protože to se
používá jen tehdy, pokud <i>vyžadujete</i> nějaký vedlejší efekt (zde například
volání <strong>print</strong> či <strong>println</strong>). Při zpracování
jedné sekvence na sekvenci jinou je vhodnější použít <strong>for</strong>,
někdy též <strong>map</strong>, <strong>filter</strong> či
<strong>reduce</strong>. Jinými slovy &ndash; nenechte se prosím zmást tím, že
v&nbsp;některých jiných programovacích jazycích se veškeré průchody sekvencemi
provádí jediným typem smyčky <i>for-each</i>, když v&nbsp;Clojure/Pixie
existují pro každý typ zpracování specializované funkce (= low-level návrhové
vzory).</p>



<p><a name="k06"></a></p>
<h2 id="k06">6. Generátorová notace seznamu &ndash; list comprehension</h2>

<p>Programovací jazyk Pixie převzal z&nbsp;Clojure i makro
<strong>for</strong>, s&nbsp;jehož využitím je možné používat takzvanou
&bdquo;generátorovou notaci seznamu&ldquo;, což je poněkud nepřesně přeložený
anglický termín &bdquo;list comprehension&ldquo;. O způsobu překladu tohoto
termínu se vedly a pravděpodobně dodnes vedou poměrně vášnivé diskuse; já se
zde budu držet překladu použitého v&nbsp;knize <i>Ponořme se do Python(u) 3</i>
(původně <i>Dive Into Python 3)</i>), kterou si můžete stáhnout na stránkách <a
href="http://knihy.nic.cz/">http://knihy.nic.cz/</a>, popř.&nbsp;si zde
objednat i papírovou verzi knihy.</p>

<p>S&nbsp;využitím generátorové notace seznamu je možné v&nbsp;programovacích
jazycích, které tento zápis podporují, zapsat deklaraci vytvoření nového
seznamu s&nbsp;využitím seznamu jiného, a to pomocí aplikace nějaké zvolené
funkce na všechny prvky zdrojového seznamu. V&nbsp;mnoha programovacích
jazycích je nutné pro generátorovou notaci seznamů používat zvláštní příkaz či
deklaraci, tj.&nbsp;vlastně novou syntaktickou kategorii. Z&nbsp;těch
známějších jazyků podporujících list comprehension se jedná například o
<i>Python</i>, <i>Haskell</i>, <i>Scala</i> či <i>Erlang</i>.</p>

<p>Programovací jazyk <i>Clojure</i> a tím pádem i <i>Pixie</i> se však od
těchto jazyků v&nbsp;podpoře pro generátorovou notaci seznamů liší, a to
dokonce hned v&nbsp;několika ohledech. V&nbsp;<i>Clojure</i> i <i>Pixie</i> se
totiž nemusela zavádět žádná nová syntaxe, ale postačovalo vhodně naprogramovat
makro (jeho kód je však poměrně dlouhý). Navíc je možné aplikovat zvolenou
funkci nejenom na (konečný) seznam, ale na libovolnou (a to i nekonečnou)
<i>sekvenci</i>, čímž ve výsledku můžeme taktéž získat nekonečnou sekvenci
vyhodnocovanou líně (<i>lazy sequence</i>). Třetím rozdílem <i>Clojure</i> a
<i>Pixie</i> oproti jiným jazykům s&nbsp;podporou generátorových notací seznamů
je to, že je možné pracovat s&nbsp;libovolným množstvím zdrojových seznamů
(přesněji řečeno sekvencí).</p>

<p>Generátorová notace seznamů je implementována již výše zmíněným makrem
<strong>for</strong>:</p>

<pre>
user =&gt; <strong>(doc for)</strong>
pixie.stdlib/for
([bindings &amp; body])
&nbsp;
A list comprehension for the bindings.
&nbsp;
  user =&gt; (for [x [1 2 3]] x)
  [1 2 3]
  user =&gt; (for [x [1 2 3] y [:a :b :c]] [x y])
  [[1 :a] [1 :b] [1 :c] [2 :a] [2 :b] [2 :c] [3 :a] [3 :b] [3 :c]]
</pre>

<p>Zajímavý je především způsob zápisu makra <strong>for</strong>, kde je
v&nbsp;hranatých závorkách (tedy ve vektoru) nejprve uveden název lokální
proměnné používané při výpočtu a za jménem proměnné je pak uveden zdrojový
seznam. Apostrof před zdrojovým seznamem zabrání jeho vyhodnocení; pokud by zde
nebyl uveden, došlo by k&nbsp;pokusu o zavolání funkce s&nbsp;názvem
<strong>1</strong> s&nbsp;trojicí parametrů 2, 3 4. Posledním parametrem makra
<strong>for</strong> je výraz (forma), jehož výsledek je použit pro konstrukci
výsledného seznamu:</p>

<pre>
user=&gt; <strong>(for [x '(1 2 3 4)] (inc x))</strong>
(2 3 4 5)
</pre>

<p>Lokální proměnnou <strong>x</strong>, která je postupně navazována na
jednotlivé prvky zdrojového seznamu, je samozřejmě možné použít i ve
složitějších výrazech; důležitý je pro nás pouze výsledek daného výrazu (jen
minimálně se zde používají funkce s&nbsp;vedlejším efektem, i když i to je
možné).</p>

<p>Kromě seznamu lze použít i libovolnou jinou sekvenci či kolekci (vektor,
mapu, množinu):</p>

<pre>
user =&gt; <strong>(for [x [1 2 3 4]] (inc x))</strong>
(2 3 4 5)
&nbsp;
user =&gt; <strong>(for [x #{1 2 3 4}] (inc x))</strong>
(5 3 4 2)
&nbsp;
user =&gt; <strong>(for [x {:a 1 :b 2 :c 3 :d 4}] (key x))</strong>
(:b :c :a :d)
&nbsp;
user =&gt; <strong>(for [x (range 1 10)] (/ 3 x))</strong>
(3 3/2 1 3/4 3/5 1/2 3/7 3/8 1/3)
</pre>

<p><strong>for</strong> je samozřejmě možné libovolným způsobem zanořovat, i
když čitelnost je v&nbsp;tomto případě již velmi malá (lepší je rozdělení
zápisu na více řádků):</p>

<pre>
user=&gt; <strong>(for [x (for [x (range 1 10)] (inc x))] (* x 2))</strong>
(4 6 8 10 12 14 16 18 20)
</pre>

<p><strong>for</strong> dokáže pracovat s&nbsp;více generátory
(tj.&nbsp;s&nbsp;více zdrojovými sekvencemi) současně. Princip jeho práce se
podobá funkci vnořených programových smyček typu &bdquo;for&ldquo;. Podívejme
se nyní, jak se vlastně makro <strong>for</strong> s&nbsp;více generátory
zapisuje. Nejjednodušší způsob zápisu vypadá následovně:</p>

<pre>
<strong>user=&gt; (for [x (range 1 10) y (range 1 10)] (* x y))</strong>
(1 2 3 4 5 6 7 8 9
2 4 6 8 10 12 14 16 18
3 6 9 12 15 18 21 24 27
4 8 12 16 20 24 28 32 36
5 10 15 20 25 30 35 40 45
6 12 18 24 30 36 42 48 54
7 14 21 28 35 42 49 56 63
8 16 24 32 40 48 56 64 72
9 18 27 36 45 54 63 72 81)
</pre>

<div>Poznámka: výpis je samozřejmě upraven ručně, aby bylo patrné, jakým způsobem
je výsledná sekvence vytvořena.</div>

<p>My ovšem můžeme taktéž vytvořit sekvenci obsahující dvojice, trojice atd.
prvků. Postačuje jen vhodně upravit funkci volanou makrem <strong>for</strong>,
například takovým způsobem, aby se vytvořit vektor obsahující dvojici
čísel:</p>

<pre>
user=&gt; <strong>(for [x (range 1 10) y (range 1 10)] [x y])</strong>
(
[1 1] [1 2] [1 3] [1 4] [1 5] [1 6] [1 7] [1 8] [1 9]
[2 1] [2 2] [2 3] [2 4] [2 5] [2 6] [2 7] [2 8] [2 9]
[3 1] [3 2] [3 3] [3 4] [3 5] [3 6] [3 7] [3 8] [3 9]
[4 1] [4 2] [4 3] [4 4] [4 5] [4 6] [4 7] [4 8] [4 9]
[5 1] [5 2] [5 3] [5 4] [5 5] [5 6] [5 7] [5 8] [5 9]
[6 1] [6 2] [6 3] [6 4] [6 5] [6 6] [6 7] [6 8] [6 9]
[7 1] [7 2] [7 3] [7 4] [7 5] [7 6] [7 7] [7 8] [7 9]
[8 1] [8 2] [8 3] [8 4] [8 5] [8 6] [8 7] [8 8] [8 9]
[9 1] [9 2] [9 3] [9 4] [9 5] [9 6] [9 7] [9 8] [9 9])
</pre>

<div>Důležitá poznámka: na rozdíl od jazyka Clojure prozatím
nelze v&nbsp;Pixie použít modifikátory <strong>:when</strong> a
<strong>:while</strong>, což je nepochybně škoda.</div>



<p><a name="k07"></a></p>
<h2 id="k07">7. Praktický příklad &ndash; výpočet Eulerova čísla s&nbsp;využitím <strong>doseq</strong>, <strong>for</strong> a <strong>reduce</strong></h2>

<p>Pojďme si nyní ukázat použití funkcí a maker <strong>doseq</strong>,
<strong>for</strong> a <strong>reduce</strong> v&nbsp;jednoduchém programu pro
výpočet přibližné hodnoty <i>Eulerova čísla</i>, které tvoří základ přirozených
logaritmů a má v&nbsp;matematice jako jedna ze základních konstant i mnoho
dalších použití. Pro výpočet <i>Eulerova čísla</i> použijeme součet nekonečné
číselné řady prvků s&nbsp;hodnotou 1/x!. Celý vzorec lze nalézt na stránce <a
href="http://cs.wikipedia.org/wiki/Eulerovo_číslo">http://cs.wikipedia.org/wiki/Eulerovo_číslo</a>
ve formě druhé definice této konstanty.</p>

<p>Aby bylo možné provést součet prvků výše zmíněné nekonečné řady, musíme
nejprve deklarovat funkci pro výpočet faktoriálu. Některé způsoby zápisu této
funkce jsme si již ukazovali &ndash; jednalo se jak o čistě rekurzivní zápis,
tak i o zápis používající tail rekurzi, popř.&nbsp;programovou smyčku. Nyní se
pro jednoduchost spolehneme na použití funkce <strong>reduce</strong>, která
bude redukovat vypočtenou sekvenci celočíselných hodnot (aritmetickou řadu
celých čísel od <i>1</i> do <i>n</i>) s&nbsp;využitím operace násobení
(jedná se o pravděpodobně nejkratší zápis faktoriálu):</p>

<pre>
(defn fact
    [n]
    (reduce *
        (range 1 (inc n))))
</pre>

<p>Námi vytvořenou funkci pro výpočet faktoriálu můžeme jednoduše otestovat,
například její aplikací na vstupní hodnoty 0..9:</p>

<pre>
user=&gt; <strong>(map fact (range 0 10))</strong>
&nbsp;
(1 1 2 6 24 120 720 5040 40320 362880)
</pre>

<p>Funkci <strong>fact</strong> můžeme použít společně s&nbsp;makrem
<strong>for</strong> pro vytvoření číselné řady obsahující hodnoty 1/x!,
přičemž x leží ve zvoleném rozsahu (0..max):</p>

<pre>
user=&gt; <strong>(for [x (range 0 10)] (/ 1 (fact x)))</strong>
&nbsp;
(1 1 1/2 1/6 1/24 1/120 1/720 1/5040 1/40320 1/362880)
</pre>

<p>Pro výpočet přibližné hodnoty Eulerova čísla nám již pouze postačí výsledné
hodnoty sečíst, například takto:</p>

<pre>
<strong>user=&gt; (reduce + (for [x (range 0 10)] (/ 1 (fact x))))</strong>
98641/36288
</pre>

<div>Poznámka: povšimněte si, že se výsledek vyjádřil formou
zjednodušeného zlomku, protože jsme dělili dvě celá čísla.</div>

<p>Samozřejmě je možné si vypsat tabulku pro zvětšující se limit, aby bylo
patrné, že se výpočet postupně přibližuje k&nbsp;Eulerovu číslu (pokud ovšem
nedojde k&nbsp;přetečení při zjednodušování zlomků!):</p>

<pre>
(doseq [i (range 1 15)]
    (println i
        (reduce + (for [x (range 0 i)]
            (/ 1 (fact x))))))
&nbsp;
1 1
2 2
3 5/2
4 8/3
5 65/24
6 163/60
7 1957/720
8 685/252
9 109601/40320
10 98641/36288
11 9864101/3628800
12 13563139/4989600
13 260412269/95800320
14 8463398743/3113510400
</pre>

<p>Zápis výsledků pomocí zlomků nám v&nbsp;tomto případě příliš nepomůže, takže
zlomek převedeme na běžnou numerickou hodnotu reprezentovanou v&nbsp;systému
plovoucí řádové čárky. Jednou z&nbsp;možností je pouhé přičtení hodnoty 0.0
popř.&nbsp;vynásobení hodnotou 1.0:</p>

<pre>
(doseq [i (range 1 15)]
    (println i (+ 0.0
        (reduce + (for [x (range 0 i)]
            (/ 1 (fact x)))))))
&nbsp;
1 1.000000
2 2.000000
3 2.500000
4 2.666667
5 2.708333
6 2.716667
7 2.718056
8 2.718254
9 2.718279
10 2.718282
11 2.718282
12 2.718282
13 2.718282
14 2.718282
</pre>



<p><a name="k08"></a></p>
<h2 id="k08">8. Použití programové konstrukce <strong>loop</strong>/<strong>recur</strong></h2>

<p>Poměrně jednoduše je možné rekurzi s&nbsp;využitím TCO (<i>tail call
optimization</i>) deklarovat pomocí <strong>loop</strong> společně
s&nbsp;<strong>recur</strong>. Za formou <strong>loop</strong> se nachází
vektor s&nbsp;deklarací a inicializací lokálních proměnných použitých ve
smyčce, na kterou je rekurzivní volání automaticky převedeno. Forma
<strong>recur</strong> umístěná uvnitř <strong>loop</strong> přesune řízení
programu ihned za slovo <strong>loop</strong>, přičemž parametry předané do
<strong>recur</strong> slouží ke změně hodnot(y) lokálních proměnných. Co to
znamená v&nbsp;praxi? Podívejme se na způsob zápisu smyčky, jejíž počitadlo
(lokální proměnná <strong>i</strong>) se zvyšuje od 0 do 10:</p>

<pre>
<i>; počitadlo od 0 do 10</i>
(loop [i 0]
    (if (= i 10)           <i>; podmínka pro ukončení smyčky</i>
        i                  <i>; návratová hodnota při splnění podmínky</i>
        (recur (+ i 1))))  <i>; rekurze (s TCO)</i>
                           <i>; v nové iteraci obsahuje i hodnotu staré_i+1</i>
</pre>

<p>Poznámka: díky tomuto způsobu zápisu si může překladač pohlídat, zda se
skutečně může použít TCO.</p>

<p>Smyčka, ve které se používá počitadlo <strong>i</strong> a současně se
počítá i suma <strong>sum</strong>, bude implementována takto:</p>

<pre>
<i>; výpočet desáté mocniny dvojky</i>
(loop [i 0 sum 1]
    (if (= i 10)                     <i>; podmínka pro ukončení smyčky</i>
        sum                          <i>; návratová hodnota při splnění podmínky</i>
        (recur (+ i 1) (* sum 2))))  <i>; rekurze (s TCO)</i>
                                     <i>; v nové iteraci obsahuje i hodnotu staré_i+1</i>
                                     <i>; a sum hodnotu staré_sum * 2</i>
</pre>

<p>Podívejme se nyní na implementaci funkce pro výpočet n-té mocniny
dvojky:</p>

<pre>
<i>; funkce pro výpočet n-té mocniny dvojky</i>
(defn pow2
    [n]
    (loop [i 0 sum 1]
        (if (= i n)        <i>; podmínka pro ukončení smyčky</i>
            sum            <i>; návratová hodnota při splnění podmínky</i>
            (recur (+ i 1) (* sum 2)))))  <i>; rekurze (s TCO)</i>
                           <i>; v nové iteraci obsahuje i hodnotu staré_i+1</i>
                           <i>; a sum hodnotu staré_sum * 2</i>
</pre>

<p>Mimochodem: s&nbsp;využitím <strong>loop</strong> a <strong>recur</strong>
bylo vytvořeno i makro <strong>while</strong>, jehož kód vypadá následovně (ve
skutečnosti toto makro není v&nbsp;Pixie příliš užitečné, na rozdíl od
mainstreamových jazyků a jejich programové konstrukce
<strong>while</strong>):</p>

<pre>
<i>; definice makra while</i>
(defmacro <strong>while</strong>
  <i>"Repeatedly executes body while test expression is true. Presumes</i>
  <i>some side-effect will cause test to become false/nil. Returns nil"</i>
  {:added "1.0"}
  [test &amp; body]
  `(loop []
      (when ~test
          ~@body
          (recur))))
</pre>



<p><a name="k09"></a></p>
<h2 id="k09">9. Použití FFI aneb volání nativních funkcí</h2>

<p>Knihovny jazyka Pixie nejsou v&nbsp;porovnání s&nbsp;některými jinými
programovacími jazyky nijak rozsáhlé, což však nemusí vždy vadit, neboť Pixie
dokáže volat i nativní funkce přes FFI. Vlastně se zde setkáváme
s&nbsp;podobným principem, jaký známe i z&nbsp;Clojure &ndash; Clojure dokáže
využívat knihovny nabízené VM (JVM, CLR...), Pixie dokáže využívat nativní
knihovny nabízené operačním systémem. V&nbsp;obou případech není zapotřebí
znovuvynalézat kolo :-)</p>

<p>Vlastní rozhraní pro FFI je implementováno ve jmenném prostoru
<strong>ffi-infer</strong>, který však většinou není nutné importovat
explicitně &ndash; to za nás udělá příslušný modul s&nbsp;obalovými funkcemi
(<strong>pixie.math</strong>, <strong>pixie.io</strong>,
<strong>pixie.stdlib</strong>, <strong>pixie.uv</strong>,
<strong>pixie.streams.zip</strong> atd.).</p>

<p>Již v&nbsp;základní instalaci Pixie (viz též úvodní část tohoto článku) jsou
k&nbsp;dispozici některé základní nativní knihovní funkce z&nbsp;knihovny
<strong>libc</strong>. Pokud některé z&nbsp;těchto funkcí potřebujeme volat, je
nejdříve nutné načíst i příslušný jmenný prostor (<i>namespace</i>). Příkladem
mohou být matematické funkce, jejichž nativní verze jsou přístupné přes jmenný
prostor <strong>pixie.math</strong>. Jestliže tyto funkce potřebujeme volat,
stačí použít direktivu <strong>:require</strong> uvedenou při specifikaci
nového jmenného prostoru (se jmennými prostory se pracuje stejně, jako je tomu
v&nbsp;programovacím jazyku Clojure):</p>

<pre>
test =&gt; <strong>(ns test (:require [pixie.math :as math]))</strong>
nil
&nbsp;
test =&gt; <strong>(math/abs -10)</strong>
10
&nbsp;
test =&gt; <strong>(math/sin 3.1415)</strong>
0.000093
&nbsp;
test =&gt; <strong>(math/sin (/ 3.1415 2))</strong>
1.000000
&nbsp;
test =&gt; <strong>math/M_PI</strong>
3.141590
&nbsp;
test =&gt; <strong>math/M_SQRT2</strong>
1.414210
&nbsp;
test =&gt; <strong>(* math/M_SQRT2 math/M_SQRT2)</strong>
1.999990
</pre>

<p>Alternativně je možné určit, že všechny symboly z&nbsp;načítaného jmenného
prostoru budou dostupné i bez nutnosti udání jmenného prefixu:</p>

<pre>
test =&gt; <strong>(ns test (:require [pixie.math :refer :all])</strong>
nil
&nbsp;
test =&gt; <strong>(abs -42)</strong>
42
&nbsp;
test =&gt; <strong>M_PI</strong>
3.141590
&nbsp;
test =&gt; <strong>M_SQRT2</strong>
1.414210
&nbsp;
test =&gt; <strong>(sin M_PI)</strong>
0.000003
&nbsp;
test =&gt; <strong>(sin (/ M_PI 2))</strong>
1.000000
</pre>


<p><a name="k10"></a></p>
<h2 id="k10">10. Nativní funkce dostupné ze standardních modulů jazyka Pixie</h2>

<p>Mezi další užitečné funkce, které používají FFI pro volání nativního kódu,
patří funkce ze jmenného prostoru <strong>io</strong>. Kromě klasických funkcí
typu <strong>spit</strong> a <strong>slurp</strong> zde nalezneme například
užitečnou funkci <strong>run-command</strong>, která nejenže spustí externí
příkaz, ale vrátí i jeho výstup (tím se dosti podstatným způsobem liší od
funkce <strong>exec</strong>, která dokáže vrátit jen návratový kód, nikoli
výstup):</p>

<pre>
test =&gt; <strong>(ns test (:require [pixie.io :refer :all]))</strong>
nil
&nbsp;
test =&gt; <strong>(count (slurp "README.md"))</strong>
5961
&nbsp;
test =&gt; <strong>(run-command "date")</strong>
"Po rij 24 19:34:17 CEST 2016\n"
&nbsp;
test =&gt; <strong>(run-command "ls -la")</strong>
... dlouhý výstup...
</pre>

<p>Pokud potřebujete zpracovávat soubory po jednotlivých řádcích (nikoli tedy
jako sekvence), mohou se hodit funkce <strong>open-read</strong> (otevření
souboru pro čtení), <strong>open-write</strong> (otevření souboru pro zápis),
<strong>read-line</strong> (načtení jednoho řádku z&nbsp;otevřeného souboru)
atd.:</p>

<pre>
test =&gt; <strong>(def fin (open-read "README.md"))</strong>
&lt;inst pixie.stdlib.Var&gt;
&nbsp;
test =&gt; <strong>(read-line fin)</strong>
"# Pixie"
test =&gt; <strong>(fs_close fin)</strong>
&nbsp;
</pre>

<p>Alternativně lze získat sekvenci řádků:</p>

<pre>
test =&gt; <strong>(line-seq fin)</strong>
&nbsp;
</pre>
<p>Samozřejmě je možné naimportovat větší množství modulů současně:</p>

<pre>
test =&gt; (ns test (:require [pixie.io :refer :all] [pixie.string :as str]))
nil
</pre>

<p>Načtení textového souboru s&nbsp;jeho rozdělením na jednotlivé řádky lze
poměrně čitelně vyřešit threading makrem:</p>

<pre>
<strong>(-&gt; "README.md" slurp str/split-lines)</strong>
</pre>

<p>Délky jednotlivých řádků v&nbsp;souboru README.md vypočteme opět
s&nbsp;použitím threading makra, tentokrát však musíme dbát na to, že do funkce
vyššího řádu <strong>map</strong> se sekvence předává ve druhém parametru,
nikoli v&nbsp;parametru prvním:</p>

<pre>
test =&gt; <strong>(-&gt;&gt; "README.md" slurp str/split-lines (map #(count %)))</strong>
(238 7 0 208 0 8 0 166 266 0 11 0 38 0 26 32 69 86 10 25 0 15 0
26 47 46 68 75 0 11 0 23 14 0 191 0 0 20 0 28 0 0 11 0 46 27 0
30 0 0 13 127 0 6 0 33 0 483 0 0 43 0 144 0 112 0 270 0 250 0 10
0 103 84 0 21 23 0 11 18 5 26 0 3 0 0 0 338 0 28 0 374 0 108 0
115 0 29 60 0 15 0 286 0 23 0 363 0 13 181 0 10 0 251 0)
</pre>



<p><a name="k11"></a></p>
<h2 id="k11">11. Příklad &ndash; vygenerování perexového obrázku k&nbsp;tomuto článku</h2>

<p>Jako příklad použití některých funkcí z&nbsp;modulů
<strong>pixie.math</strong> a <strong>pixie.io</strong> (tyto funkce volají
svůj nativní protějšek) si ukažme krátký prográmek, který vygeneruje perexový
obrázek k&nbsp;tomuto článku. Při výpočtu vektorového obrázku ukládaného do
formátu <a
href="https://www.root.cz/clanky/vektorovy-graficky-format-svg/">SVG</a> se
používají funkce sinus a kosinus, při ukládání obrázku pak funkce
<strong>spit</strong> (opak funkce <strong>slurp</strong>, těžko říct, proč
Rich Hickey zvolil taková libozvučná jména):</p>

<pre>
(ns logo (:require [pixie.math :refer :all]
                   [pixie.io :refer :all]))
&nbsp;
(def s 480)
&nbsp;
(-&gt;&gt;
    (str "&lt;svg xmlns='http://www.w3.org/2000/svg' version='1.1' width='" s "' height='" s "'&gt;"
    (loop [i 0 R 255 G 255 B 0 o ""]
        (let [r (- 128 i)
              a (/ i 12.)
              b (+ i 80)
              x (+ (/ s 2) (* b (cos a)))
              y (+ (/ s 2) (* b (sin a)))
              c (str R "," G "," B)
              p (str "&lt;circle cx='" x "' cy='" y "' r='" r "' ")
              q (str "fill='rgb(" R "," G "," B ")' style='fill-opacity:.06'/&gt;\n")]
              (if (&lt; i 128)
                  (recur (inc i) (- R 2) G (+ B 2) (str o p q p "fill='none' stroke='black'/&gt;\n"))
                  o)))
         "&lt;/svg&gt;")
    (spit "logo.svg"))
</pre>

<img src="https://i.iinfo.cz/images/336/pixie-full-1.png" class="image-268621" alt="&#160;" width="438" height="438" />
<p><i>Obrázek 1: Vektorový obrazec vytvořený předchozím demonstračním
příkladem.</i></p>



<p><a name="k12"></a></p>
<h2 id="k12">12. Problém s&nbsp;nativními funkcemi typu <strong>printf</strong></h2>

<p>Volání některých nativních funkcí je &ndash; alespoň prozatím &ndash;
v&nbsp;Pixie nepoužitelné. Jedná se především o funkci <strong>printf</strong>,
což je škoda, protože právě tato funkce je v&nbsp;praxi velmi užitečná. Pro
ilustraci se podívejme na to, co se stane při volání této funkce.
V&nbsp;případě, že formátovací řetězec neobsahuje žádné formátovací příkazy,
bude volání úspěšné a funkce <strong>printf</strong> dokonce korektně vrátí
počet vypsaných znaků:</p>

<pre>
user =&gt; <strong>(printf "Hello World\n")</strong>
Hello World
12
</pre>

<p>Při pokusu o použití formátovacích znaků a předání parametrů však ke kýženým
výsledkům nedojdeme:</p>

<pre>
user =&gt; <strong>(printf "%d %d\n" 1 2)</strong>
5175984 -959918736
19
&nbsp;
user =&gt; <strong>(printf "result: %f\n" 3.14)</strong>
result: 0.000000
17
&nbsp;
user =&gt; <strong>(printf "result: %+10d %10.7f\n" 1 1.2)</strong>
result:   +5175984  0.0000000
30
&nbsp;
user =&gt; <strong>(printf "*%s*" "hello")</strong>
*garbage*8
</pre>

<p>Tato chyba je vývojářům známá a je popsána ve dvou issues:</p>

<ol>
<li><a href="https://github.com/pixie-lang/pixie/issues/420">printf doesn't work as expected #420</a></li>
<li><a href="https://github.com/pixie-lang/pixie/issues/449">ffi `:variadic? true` generated function do not use all arguments supplied #449</a></li>
</ol>



<p><a name="k13"></a></p>
<h2 id="k13">13. Odkazy na předchozí části tohoto seriálu</h2>

<ol>

<li>Clojure  1: Úvod<br />
<a href="http://www.root.cz/clanky/clojure-aneb-jazyk-umoznujici-tvorbu-bezpecnych-vicevlaknovych-aplikaci-pro-jvm/">http://www.root.cz/clanky/clojure-aneb-jazyk-umoznujici-tvorbu-bezpecnych-vicevlaknovych-aplikaci-pro-jvm/</a>
</li>

<li>Clojure  2: Symboly, kolekce atd.<br />
<a href="http://www.root.cz/clanky/clojure-aneb-jazyk-umoznujici-tvorbu-bezpecnych-vicevlaknovych-aplikaci-pro-jvm-2-cast/">http://www.root.cz/clanky/clojure-aneb-jazyk-umoznujici-tvorbu-bezpecnych-vicevlaknovych-aplikaci-pro-jvm-2-cast/</a>
</li>

<li>Clojure  3: Funkcionální programování<br />
<a href="http://www.root.cz/clanky/clojure-aneb-jazyk-umoznujici-tvorbu-bezpecnych-vicevlaknovych-aplikaci-pro-jvm-3-cast-funkcionalni-programovani/">http://www.root.cz/clanky/clojure-aneb-jazyk-umoznujici-tvorbu-bezpecnych-vicevlaknovych-aplikaci-pro-jvm-3-cast-funkcionalni-programovani/</a>
</li>

<li>Clojure  4: Kolekce, sekvence a lazy sekvence<br />
<a href="http://www.root.cz/clanky/clojure-aneb-jazyk-umoznujici-tvorbu-bezpecnych-vicevlaknovych-aplikaci-pro-jvm-4-cast-kolekce-sekvence-a-lazy-sekvence/">http://www.root.cz/clanky/clojure-aneb-jazyk-umoznujici-tvorbu-bezpecnych-vicevlaknovych-aplikaci-pro-jvm-4-cast-kolekce-sekvence-a-lazy-sekvence/</a>
</li>

<li>Clojure  5: Sekvence, lazy sekvence a paralelní programy<br />
<a href="http://www.root.cz/clanky/clojure-a-bezpecne-aplikace-pro-jvm-sekvence-lazy-sekvence-a-paralelni-programy/">http://www.root.cz/clanky/clojure-a-bezpecne-aplikace-pro-jvm-sekvence-lazy-sekvence-a-paralelni-programy/</a>
</li>

<li>Clojure  6: Podpora pro paralelní programování<br />
<a href="http://www.root.cz/clanky/programovaci-jazyk-clojure-6-futures-nejsou-jen-financni-derivaty/">http://www.root.cz/clanky/programovaci-jazyk-clojure-6-futures-nejsou-jen-financni-derivaty/</a>
</li>

<li>Clojure  7: Další funkce pro paralelní programování<br />
<a href="http://www.root.cz/clanky/programovaci-jazyk-clojure-7-dalsi-podpurne-prostredky-pro-paralelni-programovani/">http://www.root.cz/clanky/programovaci-jazyk-clojure-7-dalsi-podpurne-prostredky-pro-paralelni-programovani/</a>
</li>

<li>Clojure  8: Identity, stavy, neměnné hodnoty a reference<br />
<a href="http://www.root.cz/clanky/programovaci-jazyk-clojure-8-identity-stavy-nemenne-hodnoty-a-referencni-typy/">http://www.root.cz/clanky/programovaci-jazyk-clojure-8-identity-stavy-nemenne-hodnoty-a-referencni-typy/</a>
</li>

<li>Clojure  9: Validátory, pozorovatelé a kooperace s Javou<br />
<a href="http://www.root.cz/clanky/programovaci-jazyk-clojure-9-validatory-pozorovatele-a-kooperace-mezi-clojure-a-javou/">http://www.root.cz/clanky/programovaci-jazyk-clojure-9-validatory-pozorovatele-a-kooperace-mezi-clojure-a-javou/</a>
</li>

<li>Clojure 10: Kooperace mezi Clojure a Javou<br />
<a href="http://www.root.cz/clanky/programovaci-jazyk-clojure-10-kooperace-mezi-clojure-a-javou-pokracovani/">http://www.root.cz/clanky/programovaci-jazyk-clojure-10-kooperace-mezi-clojure-a-javou-pokracovani/</a>
</li>

<li>Clojure 11: Generátorová notace seznamu/list comprehension<br />
<a href="http://www.root.cz/clanky/programovaci-jazyk-clojure-11-generatorova-notace-seznamu-list-comprehension/">http://www.root.cz/clanky/programovaci-jazyk-clojure-11-generatorova-notace-seznamu-list-comprehension/</a>
</li>

<li>Clojure 12: Překlad programů z Clojure do bajtkódu JVM I:<br />
<a href="http://www.root.cz/clanky/programovaci-jazyk-clojure-12-preklad-programu-z-clojure-do-bajtkodu-jvm/">http://www.root.cz/clanky/programovaci-jazyk-clojure-12-preklad-programu-z-clojure-do-bajtkodu-jvm/</a>
</li>

<li>Clojure 13: Překlad programů z Clojure do bajtkódu JVM II:<br />
<a href="http://www.root.cz/clanky/programovaci-jazyk-clojure-13-preklad-programu-z-clojure-do-bajtkodu-jvm-pokracovani/">http://www.root.cz/clanky/programovaci-jazyk-clojure-13-preklad-programu-z-clojure-do-bajtkodu-jvm-pokracovani/</a>
</li>

<li>Clojure 14: Základy práce se systémem maker<br />
<a href="http://www.root.cz/clanky/programovaci-jazyk-clojure-14-zaklady-prace-se-systemem-maker/">http://www.root.cz/clanky/programovaci-jazyk-clojure-14-zaklady-prace-se-systemem-maker/</a>
</li>

<li>Clojure 15: Tvorba uživatelských maker<br />
<a href="http://www.root.cz/clanky/programovaci-jazyk-clojure-15-tvorba-uzivatelskych-maker/">http://www.root.cz/clanky/programovaci-jazyk-clojure-15-tvorba-uzivatelskych-maker/</a>
</li>

<li>Clojure 16: Složitější uživatelská makra<br />
<a href="http://www.root.cz/clanky/programovaci-jazyk-clojure-16-slozitejsi-uzivatelska-makra/">http://www.root.cz/clanky/programovaci-jazyk-clojure-16-slozitejsi-uzivatelska-makra/</a>
</li>

<li>Clojure 17: Využití standardních maker v praxi<br />
<a href="http://www.root.cz/clanky/programovaci-jazyk-clojure-17-vyuziti-standardnich-maker-v-praxi/">http://www.root.cz/clanky/programovaci-jazyk-clojure-17-vyuziti-standardnich-maker-v-praxi/</a>
</li>

<li>Clojure 18: Základní techniky optimalizace aplikací<br />
<a href="http://www.root.cz/clanky/programovaci-jazyk-clojure-18-zakladni-techniky-optimalizace-aplikaci/">http://www.root.cz/clanky/programovaci-jazyk-clojure-18-zakladni-techniky-optimalizace-aplikaci/</a>
</li>

<li>Clojure 19: Vývojová prostředí pro Clojure<br />
<a href="http://www.root.cz/clanky/programovaci-jazyk-clojure-19-vyvojova-prostredi-pro-clojure/">http://www.root.cz/clanky/programovaci-jazyk-clojure-19-vyvojova-prostredi-pro-clojure/</a>
</li>

<li>Clojure 20: Vývojová prostředí pro Clojure (Vimu s REPL)<br />
<a href="http://www.root.cz/clanky/programovaci-jazyk-clojure-20-vyvojova-prostredi-pro-clojure-integrace-vimu-s-repl/">http://www.root.cz/clanky/programovaci-jazyk-clojure-20-vyvojova-prostredi-pro-clojure-integrace-vimu-s-repl/</a>
</li>

<li>Clojure 21: ClojureScript aneb překlad Clojure do JS<br />
<a href="http://www.root.cz/clanky/programovaci-jazyk-clojure-21-clojurescript-aneb-preklad-clojure-do-javascriptu/">http://www.root.cz/clanky/programovaci-jazyk-clojure-21-clojurescript-aneb-preklad-clojure-do-javascriptu/</a>
</li>

<li>Leiningen: nástroj pro správu projektů napsaných v Clojure<br />
<a href="http://www.root.cz/clanky/leiningen-nastroj-pro-spravu-projektu-napsanych-v-clojure/">http://www.root.cz/clanky/leiningen-nastroj-pro-spravu-projektu-napsanych-v-clojure/</a>
</li>

<li>Leiningen: nástroj pro správu projektů napsaných v Clojure (2)<br />
<a href="http://www.root.cz/clanky/leiningen-nastroj-pro-spravu-projektu-napsanych-v-clojure-2/">http://www.root.cz/clanky/leiningen-nastroj-pro-spravu-projektu-napsanych-v-clojure-2/</a>
</li>

<li>Leiningen: nástroj pro správu projektů napsaných v Clojure (3)<br />
<a href="http://www.root.cz/clanky/leiningen-nastroj-pro-spravu-projektu-napsanych-v-clojure-3/">http://www.root.cz/clanky/leiningen-nastroj-pro-spravu-projektu-napsanych-v-clojure-3/</a>
</li>

<li>Leiningen: nástroj pro správu projektů napsaných v Clojure (4)<br />
<a href="http://www.root.cz/clanky/leiningen-nastroj-pro-spravu-projektu-napsanych-v-clojure-4/">http://www.root.cz/clanky/leiningen-nastroj-pro-spravu-projektu-napsanych-v-clojure-4/</a>
</li>

<li>Leiningen: nástroj pro správu projektů napsaných v Clojure (5)<br />
<a href="http://www.root.cz/clanky/leiningen-nastroj-pro-spravu-projektu-napsanych-v-clojure-5/">http://www.root.cz/clanky/leiningen-nastroj-pro-spravu-projektu-napsanych-v-clojure-5/</a>
</li>

<li>Leiningen: nástroj pro správu projektů napsaných v Clojure (6)<br />
<a href="http://www.root.cz/clanky/leiningen-nastroj-pro-spravu-projektu-napsanych-v-clojure-6/">http://www.root.cz/clanky/leiningen-nastroj-pro-spravu-projektu-napsanych-v-clojure-6/</a>
</li>

<li>Programovací jazyk Clojure a databáze (1.část)<br />
<a href="http://www.root.cz/clanky/programovaci-jazyk-clojure-a-databaze-1-cast/">http://www.root.cz/clanky/programovaci-jazyk-clojure-a-databaze-1-cast/</a>
</li>

<li>Pluginy pro Leiningen<br />
<a href="http://www.root.cz/clanky/leiningen-nastroj-pro-spravu-projektu-napsanych-v-clojure-pluginy-pro-leiningen/">http://www.root.cz/clanky/leiningen-nastroj-pro-spravu-projektu-napsanych-v-clojure-pluginy-pro-leiningen/</a>
</li>

<li>Programovací jazyk Clojure a knihovny pro práci s vektory a maticemi<br />
<a href="http://www.root.cz/clanky/programovaci-jazyk-clojure-a-knihovny-pro-praci-s-vektory-a-maticemi/">http://www.root.cz/clanky/programovaci-jazyk-clojure-a-knihovny-pro-praci-s-vektory-a-maticemi/</a>
</li>

<li>Programovací jazyk Clojure a knihovny pro práci s vektory a maticemi (2)<br />
<a href="http://www.root.cz/clanky/programovaci-jazyk-clojure-a-knihovny-pro-praci-s-vektory-a-maticemi-2/">http://www.root.cz/clanky/programovaci-jazyk-clojure-a-knihovny-pro-praci-s-vektory-a-maticemi-2/</a>
</li>

<li>Programovací jazyk Clojure: syntéza procedurálních textur s využitím knihovny Clisk<br />
<a href="http://www.root.cz/clanky/programovaci-jazyk-clojure-synteza-proceduralnich-textur-s-vyuzitim-knihovny-clisk/">http://www.root.cz/clanky/programovaci-jazyk-clojure-synteza-proceduralnich-textur-s-vyuzitim-knihovny-clisk/</a>
</li>

<li>Programovací jazyk Clojure: syntéza procedurálních textur s využitím knihovny Clisk (2)<br />
<a href="http://www.root.cz/clanky/programovaci-jazyk-clojure-synteza-proceduralnich-textur-s-vyuzitim-knihovny-clisk-2/">http://www.root.cz/clanky/programovaci-jazyk-clojure-synteza-proceduralnich-textur-s-vyuzitim-knihovny-clisk-2/</a>
</li>

<li>Seesaw: knihovna pro snadnou tvorbu GUI v jazyce Clojure<br />
<a href="http://www.root.cz/clanky/seesaw-knihovna-pro-snadnou-tvorbu-gui-v-jazyce-clojure/">http://www.root.cz/clanky/seesaw-knihovna-pro-snadnou-tvorbu-gui-v-jazyce-clojure/</a>
</li>

<li>Seesaw: knihovna pro snadnou tvorbu GUI v jazyce Clojure (2)<br />
<a href="http://www.root.cz/clanky/seesaw-knihovna-pro-snadnou-tvorbu-gui-v-jazyce-clojure-2/">http://www.root.cz/clanky/seesaw-knihovna-pro-snadnou-tvorbu-gui-v-jazyce-clojure-2/</a>
</li>

<li>Seesaw: knihovna pro snadnou tvorbu GUI v jazyce Clojure (3)<br />
<a href="http://www.root.cz/clanky/seesaw-knihovna-pro-snadnou-tvorbu-gui-v-jazyce-clojure-3/">http://www.root.cz/clanky/seesaw-knihovna-pro-snadnou-tvorbu-gui-v-jazyce-clojure-3/</a>
</li>

<li>Programovací jazyk Clojure a práce s Gitem<br />
<a href="http://www.root.cz/clanky/programovaci-jazyk-clojure-a-prace-s-gitem/">http://www.root.cz/clanky/programovaci-jazyk-clojure-a-prace-s-gitem/</a>
</li>

<li>Programovací jazyk Clojure: syntéza procedurálních textur s využitím knihovny Clisk (dokončení)<br />
<a href="http://www.root.cz/clanky/programovaci-jazyk-clojure-synteza-proceduralnich-textur-s-vyuzitim-knihovny-clisk-dokonceni/">http://www.root.cz/clanky/programovaci-jazyk-clojure-synteza-proceduralnich-textur-s-vyuzitim-knihovny-clisk-dokonceni/</a>
</li>

<li>Programovací jazyk Clojure a práce s Gitem (2)<br />
<a href="http://www.root.cz/clanky/programovaci-jazyk-clojure-a-prace-s-gitem-2/">http://www.root.cz/clanky/programovaci-jazyk-clojure-a-prace-s-gitem-2/</a>
</li>

<li>Programovací jazyk Clojure – triky při práci s řetězci<br />
<a href="http://www.root.cz/clanky/programovaci-jazyk-clojure-triky-pri-praci-s-retezci/">http://www.root.cz/clanky/programovaci-jazyk-clojure-triky-pri-praci-s-retezci/</a>
</li>

<li>Programovací jazyk Clojure – triky při práci s kolekcemi<br />
<a href="http://www.root.cz/clanky/programovaci-jazyk-clojure-triky-pri-praci-s-kolekcemi/">http://www.root.cz/clanky/programovaci-jazyk-clojure-triky-pri-praci-s-kolekcemi/</a>
</li>

<li>Programovací jazyk Clojure – práce s mapami a množinami<br />
<a href="http://www.root.cz/clanky/programovaci-jazyk-clojure-prace-s-mapami-a-mnozinami/">http://www.root.cz/clanky/programovaci-jazyk-clojure-prace-s-mapami-a-mnozinami/</a>
</li>

<li>Programovací jazyk Clojure – základy zpracování XML<br />
<a href="http://www.root.cz/clanky/programovaci-jazyk-clojure-zaklady-zpracovani-xml/">http://www.root.cz/clanky/programovaci-jazyk-clojure-zaklady-zpracovani-xml/</a>
</li>

<li>Programovací jazyk Clojure – testování s využitím knihovny Expectations<br />
<a href="http://www.root.cz/clanky/programovaci-jazyk-clojure-testovani-s-vyuzitim-knihovny-expectations/">http://www.root.cz/clanky/programovaci-jazyk-clojure-testovani-s-vyuzitim-knihovny-expectations/</a>
</li>

<li>Programovací jazyk Clojure – některé užitečné triky použitelné (nejenom) v&nbsp;testech<br />
<a href="http://www.root.cz/clanky/programovaci-jazyk-clojure-nektere-uzitecne-triky-pouzitelne-nejenom-v-testech/">http://www.root.cz/clanky/programovaci-jazyk-clojure-nektere-uzitecne-triky-pouzitelne-nejenom-v-testech/</a>
</li>

<li>Enlive – výkonný šablonovací systém pro jazyk Clojure<br/>
<a href="http://www.root.cz/clanky/enlive-vykonny-sablonovaci-system-pro-jazyk-clojure/">http://www.root.cz/clanky/enlive-vykonny-sablonovaci-system-pro-jazyk-clojure/</a>
</li>

<li>Nástroj Leiningen a programovací jazyk Clojure: tvorba vlastních knihoven pro veřejný repositář Clojars<br />
<a href="http://www.root.cz/clanky/nastroj-leiningen-a-programovaci-jazyk-clojure-tvorba-vlastnich-knihoven-pro-verejny-repositar-clojars/">http://www.root.cz/clanky/nastroj-leiningen-a-programovaci-jazyk-clojure-tvorba-vlastnich-knihoven-pro-verejny-repositar-clojars/</a>
</li>

<li>Novinky v Clojure verze 1.8.0<br />
<a href="http://www.root.cz/clanky/novinky-v-clojure-verze-1-8-0/">http://www.root.cz/clanky/novinky-v-clojure-verze-1-8-0/</a>
</li>

<li>Asynchronní programování v&nbsp;Clojure s&nbsp;využitím knihovny core.async<br />
<a href="http://www.root.cz/clanky/asynchronni-programovani-v-clojure-s-vyuzitim-knihovny-core-async/">http://www.root.cz/clanky/asynchronni-programovani-v-clojure-s-vyuzitim-knihovny-core-async/</a>
</li>

<li>Asynchronní programování v&nbsp;Clojure s&nbsp;využitím knihovny core.async (pokračování)<br />
<a href="http://www.root.cz/clanky/asynchronni-programovani-v-clojure-s-vyuzitim-knihovny-core-async-pokracovani/">http://www.root.cz/clanky/asynchronni-programovani-v-clojure-s-vyuzitim-knihovny-core-async-pokracovani/</a>
</li>

<li>Asynchronní programování v Clojure s využitím knihovny core.async (dokončení)<br />
<a href="http://www.root.cz/clanky/asynchronni-programovani-v-clojure-s-vyuzitim-knihovny-core-async-dokonceni/">http://www.root.cz/clanky/asynchronni-programovani-v-clojure-s-vyuzitim-knihovny-core-async-dokonceni/</a>
</li>

<li>Vytváříme IRC bota v programovacím jazyce Clojure<br />
<a href="http://www.root.cz/clanky/vytvarime-irc-bota-v-programovacim-jazyce-clojure/">http://www.root.cz/clanky/vytvarime-irc-bota-v-programovacim-jazyce-clojure/</a>
</li>

<li>Gorilla REPL: interaktivní prostředí pro programovací jazyk Clojure<br />
<a href="https://www.root.cz/clanky/gorilla-repl-interaktivni-prostredi-pro-programovaci-jazyk-clojure/">https://www.root.cz/clanky/gorilla-repl-interaktivni-prostredi-pro-programovaci-jazyk-clojure/</a>
</li>

<li>Multimetody v Clojure aneb polymorfismus bez použití OOP<br />
<a href="https://www.root.cz/clanky/multimetody-v-clojure-aneb-polymorfismus-bez-pouziti-oop/">https://www.root.cz/clanky/multimetody-v-clojure-aneb-polymorfismus-bez-pouziti-oop/</a>
</li>

<li>Práce s externími Java archivy v programovacím jazyku Clojure<br />
<a href="https://www.root.cz/clanky/prace-s-externimi-java-archivy-v-programovacim-jazyku-clojure/">https://www.root.cz/clanky/prace-s-externimi-java-archivy-v-programovacim-jazyku-clojure/</a>
</li>

<li>Pixie: lehký skriptovací jazyk s „kouzelnými“ schopnostmi<br />
<a href="https://www.root.cz/clanky/pixie-lehky-skriptovaci-jazyk-s-kouzelnymi-schopnostmi/">https://www.root.cz/clanky/pixie-lehky-skriptovaci-jazyk-s-kouzelnymi-schopnostmi/</a>
</li>

</ol>



<p><a name="k14"></a></p>
<h2 id="k14">14. Odkazy na Internetu</h2>

<ol>

<li>Pixie (repositář na GitHubu)<br />
<a href="https://github.com/pixie-lang/pixie">https://github.com/pixie-lang/pixie</a>
</li>

<li>Pixie Installation<br />
<a href="https://github.com/pixie-lang/pixie/wiki/Installation">https://github.com/pixie-lang/pixie/wiki/Installation</a>
</li>

<li>Pixie Libraries<br />
<a href="https://github.com/pixie-lang/pixie/wiki/Libraries">https://github.com/pixie-lang/pixie/wiki/Libraries</a>
</li>

<li>Interview with Timothy Baldridge, Pixie's language creator<br />
<a href="https://notamonadtutorial.com/indie-languages-interview-pixie-and-timothy-baldridge-cadbc36418dc#.vhbl5rp1c">https://notamonadtutorial.com/indie-languages-interview-pixie-and-timothy-baldridge-cadbc36418dc#.vhbl5rp1c</a>
</li>

<li>Pixie (programming language) [Wikipedia]<br />
<a href="https://en.wikipedia.org/wiki/Pixie_%28programming_language%29">https://en.wikipedia.org/wiki/Pixie_%28programming_language%29</a>
</li>

<li>FFI or interop with C libraries<br />
<a href="https://github.com/pixie-lang/pixie/wiki/FFI-%28interop-with-C%29">https://github.com/pixie-lang/pixie/wiki/FFI-%28interop-with-C%29</a>
</li>

<li>printf doesn't work as expected #420<br />
<a href="https://github.com/pixie-lang/pixie/issues/420">https://github.com/pixie-lang/pixie/issues/420</a>
</li>

<li>ffi `:variadic? true` generated function do not use all arguments supplied #449<br />
<a href="https://github.com/pixie-lang/pixie/issues/449">https://github.com/pixie-lang/pixie/issues/449</a>
</li>

<li>Clojure home page<br />
<a href="http://clojure.org/">http://clojure.org/</a>
</li>

<li>Clojure (downloads)<br />
<a href="http://clojure.org/downloads">http://clojure.org/downloads</a>
</li>

<li>Clojure - Functional Programming for the JVM<br />
<a href="http://java.ociweb.com/mark/clojure/article.html">http://java.ociweb.com/mark/clojure/article.html</a>
</li>

<li>Clojure quick reference<br />
<a href="http://faustus.webatu.com/clj-quick-ref.html">http://faustus.webatu.com/clj-quick-ref.html</a>
</li>

<li>4Clojure<br />
<a href="http://www.4clojure.com/">http://www.4clojure.com/</a>
</li>

<li>ClojureDoc (rozcestník s&nbsp;dokumentací jazyka Clojure)<br />
<a href="http://clojuredocs.org/">http://clojuredocs.org/</a>
</li>

<li>Clojure (na Wikipedia EN)<br />
<a href="http://en.wikipedia.org/wiki/Clojure">http://en.wikipedia.org/wiki/Clojure</a>
</li>

<li>Clojure (na Wikipedia CS)<br />
<a href="http://cs.wikipedia.org/wiki/Clojure">http://cs.wikipedia.org/wiki/Clojure</a>
</li>

<li>Clojars:<br />
<a href="https://clojars.org/">https://clojars.org/</a>
</li>

<li>Seznam knihoven na Clojars:<br />
<a href="https://clojars.org/projects">https://clojars.org/projects</a>
</li>

<li>Zip archiv s&nbsp;Clojure 1.8.0<br />
<a href="http://repo1.maven.org/maven2/org/clojure/clojure/1.8.0/clojure-1.8.0.zip">http://repo1.maven.org/maven2/org/clojure/clojure/1.8.0/clojure-1.8.0.zip</a>
</li>

<li>Clojure 1.8 is now available<br />
<a href="http://clojure.org/news/2016/01/19/clojure18">http://clojure.org/news/2016/01/19/clojure18</a>
</li>

<li>Changes to Clojure in Version 1.8<br />
<a href="https://github.com/clojure/clojure/blob/master/changes.md">https://github.com/clojure/clojure/blob/master/changes.md</a>
</li>

<li>Clojure core.async<br />
<a href="http://www.infoq.com/presentations/clojure-core-async">http://www.infoq.com/presentations/clojure-core-async</a>
</li>

<li>core.async API Reference<br />
<a href="https://clojure.github.io/core.async/">https://clojure.github.io/core.async/</a>
</li>

<li>Clojure core.async Channels<br />
<a href="http://clojure.com/blog/2013/06/28/clojure-core-async-channels.html">http://clojure.com/blog/2013/06/28/clojure-core-async-channels.html</a>
</li>

<li>core.async examples<br />
<a href="https://github.com/clojure/core.async/blob/master/examples/walkthrough.clj">https://github.com/clojure/core.async/blob/master/examples/walkthrough.clj</a>
</li>

<li>Timothy Baldridge - Core.Async<br />
<a href="https://www.youtube.com/watch?v=enwIIGzhahw">https://www.youtube.com/watch?v=enwIIGzhahw</a>
</li>

<li>List comprehension<br />
<a href="http://en.wikipedia.org/wiki/List_comprehension">http://en.wikipedia.org/wiki/List_comprehension</a>
</li>

<li>List Comprehensions in Clojure<br />
<a href="http://asymmetrical-view.com/2008/11/18/list-comprehensions-in-clojure.html">http://asymmetrical-view.com/2008/11/18/list-comprehensions-in-clojure.html</a>
</li>

<li>Clojure Programming Concepts: List Comprehension<br />
<a href="http://en.wikibooks.org/wiki/Clojure_Programming/Concepts#List_Comprehension">http://en.wikibooks.org/wiki/Clojure_Programming/Concepts#List_Comprehension</a>
</li>

</ol>



<p></p><p></p>
<p><small>Autor: <a href="http://www.fit.vutbr.cz/~tisnovpa">Pavel Tišnovský</a> &nbsp; 2016</small></p>
</body>
</html>

