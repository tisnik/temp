<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
        "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html>
<head>
<title>Programovací jazyk Clojure - testování s využitím knihovny Expectations</title>
<meta name="Author" content="Pavel Tisnovsky" />
<meta name="Generator" content="vim" />
<meta http-equiv="content-type" content="text/html; charset=utf-8" />
<style type="text/css">
         body {color:#000000; background:#ffffff;}
         h1  {font-family: arial, helvetica, sans-serif; color:#ffffff; background-color:#c00000; text-align:center; padding-left:1em}
         h2  {font-family: arial, helvetica, sans-serif; color:#ffffff; background-color:#0000c0; padding-left:1em; text-align:left}
         h3  {font-family: arial, helvetica, sans-serif; color:#000000; background-color:#c0c0c0; padding-left:1em; text-align:left}
         h4  {font-family: arial, helvetica, sans-serif; color:#000000; background-color:#e0e0e0; padding-left:1em; text-align:left}
         a   {font-family: arial, helvetica, sans-serif;}
         li  {font-family: arial, helvetica, sans-serif; color:#000000; text-align:justify; width:450px;}
         ol  {font-family: arial, helvetica, sans-serif; color:#000000; text-align:justify; width:450px;}
         ul  {font-family: arial, helvetica, sans-serif; color:#000000; text-align:justify; width:450px;}
         p   {font-family: arial, helvetica, sans-serif; color:#000000; text-align:justify;}
         pre {background:#e0e0e0}
</style>
</head>

<body>

<h1>Programovací jazyk Clojure - testování s využitím knihovny Expectations</h1>

<h3>Pavel Tišnovský</h3>

<p></p>

<h1>Úvodník</h1>

<p>V dnešní části seriálu o programovacím jazyce Clojure i o knihovnách, které jsou pro tento jazyk dostupné, se budeme zabývat dalším nástrojem určeným pro psaní jednotkových testů. Alternativou k již popsané knihovně clojure.test je nástroj nazvaný Expectations, který dokáže zpřehlednit jak psaní testů, tak i prezentaci jejich výsledků.</p>



<h2>Obsah</h2>

<p><a href="#k01">1. Programovací jazyk Clojure &ndash; testování s využitím knihovny Expectations</a></p>
<p><a href="#k02">2. Vytvoření nového projektu a úprava projektového souboru</a></p>
<p><a href="#k03">3. Testy napsané s&nbsp;využitím knihovny <strong>clojure.test</strong></a></p>
<p><a href="#k04">4. Testy napsané s&nbsp;využitím knihovny <strong>Expectations</strong></a></p>
<p><a href="#k05">5. Porovnání výsledků běhu obou testů</a></p>
<p><a href="#k06">6. Další možnosti makra <strong>expect</strong></a></p>
<p><a href="#k07">7. Regulární výrazy v&nbsp;makru <strong>expect</strong></a></p>
<p><a href="#k08">8. Kolekce v&nbsp;makru <strong>expect</strong></a></p>
<p><a href="#k09">9. Kontrola typu a test, zda byla vyvolána výjimka</a></p>
<p><a href="#k10">10. Repositář s&nbsp;dnešními demonstračními příklady</a></p>
<p><a href="#k11">11. Odkazy na předchozí části tohoto seriálu</a></p>
<p><a href="#k12">12. Odkazy na Internetu</a></p>



<p><a name="k01"></a></p>
<h2 id="k01">1. Programovací jazyk Clojure &ndash; testování s využitím knihovny Expectations</h2>

<p>V&nbsp;článku <a
href="http://www.root.cz/clanky/leiningen-nastroj-pro-spravu-projektu-napsanych-v-clojure-3/">Leiningen:
nástroj pro správu projektů napsaných v&nbsp;Clojure (3)</a> jsme se
mj.&nbsp;zabývali i způsobem tvorby jednotkových testů (<i>unit tests</i>) a
jejich následném spouštění s&nbsp;využitím nástroje <i>Leiningen</i>. Popsány
byly základní možnosti knihovny <i>clojure.test</i>, a to zejména z&nbsp;toho
důvodu, že se jedná o knihovnu, která je standardní součástí každé instalace
jazyka Clojure (ostatně jejím autorem je sám Rich Hickey) a navíc se jedná o
knihovnu, která je poměrně nízkoúrovňová a autorům testů tak přináší relativně
málo různých nechtěných &bdquo;překvapení&ldquo; (jinými slovy: nesnaží se být
chytřejší než programátor). Ovšem právě ona zmiňovaná nízkoúrovňovost na druhou
stranu znamená, že testy mohou být poměrně nečitelné, objevuje se v&nbsp;nich
relativně velké množství opakujícího se kódu a ani způsob hlášení chyb
v&nbsp;testovaném kódu není dokonalý, protože chybová hlášení obsahují jen
informaci o tom, že skutečně vrácená hodnota se odlišuje od hodnoty očekávané a
pokud celý test vyhodí výjimku, vypíše se pouze špatně čitelný výpis obsahu
zásobníkových rámců (<i>stack trace</i>).</p>

<p>Poněkud odlišným směrem se vydal vývojář Jay Fields, který naprogramoval
nástroj nazvaný <i>Expectations</i> (resp.&nbsp;expectations, tedy s&nbsp;malým
&bdquo;e&ldquo; na začátku názvu). Tento nástroj sice interně využívá výše
zmíněnou knihovnu <i>clojure.test</i>, ovšem staví nad ní mezivrstvu
zajišťující rozhraní pro psaní přehlednějších jednotkových testů. V&nbsp;této
mezivrstvě nalezneme &bdquo;inteligentní&ldquo; makro <strong>expect</strong>,
které samo o sobě postačuje pro napsání většiny testů. Pro další zjednodušení
jsou v&nbsp;nástroji Expectations dostupná i další makra, především pak makro
<strong>more-&gt;</strong>, <strong>more-of</strong> a v&nbsp;neposlední řadě
taktéž <strong>from-each</strong>. To však není vše, protože podobně
inteligentně zpracovaná jsou i hlášení o chybách, která jsou generovaná při
spouštění jednotkových testů. Namísto obvyklé strohé informace o tom, že se
například vypočtená kolekce odlišuje od kolekce očekávané, dokáže knihovna
Expectations vypsat i další informace, například tehdy, když vrácená kolekce
obsahuje jen další prvky (a zbytek kolekce se shoduje s&nbsp;kolekcí
očekávanou), některé prvky chybí či se liší pořadí prvků. I v&nbsp;případě
vzniku výjimky se namísto celého obsahu zásobníkových rámců vypíšou pouze
relevantní informace.</p>



<p><a name="k02"></a></p>
<h2 id="k02">2. Vytvoření nového projektu a úprava projektového souboru</h2>

<p>Před podrobnějším popisem možností knihovny Expectations se podívejme na
praktický příklad, v&nbsp;němž opět využijeme nástroj Leiningen. Jedná se o <a
href="https://github.com/tisnik/clojure-examples/tree/master/factorial">nám již
známý</a> a taktéž <a
href="http://www.root.cz/clanky/leiningen-nastroj-pro-spravu-projektu-napsanych-v-clojure-3/#k06">popsaný</a>
projekt obsahující funkci pro výpočet faktoriálu. Samotná funkce pro výpočet
faktoriálu je otestovaná několika jednotkovými testy používajícími knihovnu
<i>clojure.test</i>. Zkusme si nyní tento projekt rozšířit takovým způsobem,
aby bylo možné použít vlastnosti nabízené knihovnou Expectations. Nový projekt
vytvoříme známým příkazem:</p>

<pre>
<strong>lein new app factorial3</strong>
Generating a project called factorial2 based on the 'app' template.
</pre>

<p>Následně je nutné upravit soubor <strong>project.clj</strong> obsahující
mj.&nbsp;i všechny knihovny a pluginy, které jsou projektem používané.
V&nbsp;našem případě přidáme jednu knihovnu a jeden plugin. V&nbsp;následujícím
výpisu jsou změněné části projektového souboru označeny tučným písmem:</p>

<pre>
(defproject factorial3 "0.1.0-SNAPSHOT"
  :description "FIXME: write description"
  :url "http://example.com/FIXME"
  :license {:name "Eclipse Public License"
            :url "http://www.eclipse.org/legal/epl-v10.html"}
  :dependencies [[org.clojure/clojure "1.6.0"]
                 <strong>[expectations "2.0.9"]</strong>]
  :main ^:skip-aot factorial2.core
  :target-path "target/%s"
  :plugins [<strong>[lein-expectations "0.0.8"]</strong>
            [lein-cloverage "1.0.2"]]
  :profiles {:uberjar {:aot :all}})
</pre>

<p>Struktura projektu po jeho vytvoření:</p>

<pre>
├── doc
│   └── intro.md
├── LICENSE
├── project.clj
├── README.md
├── resources
├── src
│   └── factorial3
│       └── core.clj
└── test
    └── factorial3
        └── core_test.clj
&nbsp;
6 directories, 6 files
</pre>

<p>Zdrojový kód <strong>src/factorial3/core.clj</strong>:</p>

<pre>
(ns <strong>factorial3</strong>.core
  (:gen-class))
&nbsp;
(defn <strong>factorial</strong>
    [n]
    (if (neg? n)
        (throw (IllegalArgumentException. "negative numbers are not supported!"))
        (apply * (range 1 (inc n)))))
&nbsp;
(defn <strong>factorial2</strong>
    [n]
    (if (neg? n)
        (throw (IllegalArgumentException. "negative numbers are not supported!"))
        (apply * (range 1 (inc n)))))
&nbsp;
(defn <strong>factorial3</strong>
    [n]
    (if (neg? n)
        (throw (IllegalArgumentException. "negative numbers are not supported!"))
        (apply * (range 1 (inc n)))))
&nbsp;
(defn <strong>-main</strong>
    "I don't do a whole lot ... yet."
    [&amp; args]
    (doseq [i (range 0 10)]
        (println i "! = " (factorial i))))
</pre>

<p>Instalaci všech závislých knihoven zajistí příkaz:</p>

<pre>
<strong>lein deps</strong>
&nbsp;
Retrieving lein-expectations/lein-expectations/0.0.8/lein-expectations-0.0.8.pom from clojars
Retrieving expectations/expectations/1.4.5/expectations-1.4.5.pom from clojars
Retrieving org/clojure/clojure/1.3.0/clojure-1.3.0.jar from central
Retrieving lein-expectations/lein-expectations/0.0.8/lein-expectations-0.0.8.jar from clojars
Retrieving expectations/expectations/1.4.5/expectations-1.4.5.jar from clojars
Retrieving expectations/expectations/2.0.9/expectations-2.0.9.pom from clojars
Retrieving junit/junit/4.8.1/junit-4.8.1.pom from central
Retrieving junit/junit/4.8.1/junit-4.8.1.jar from central
Retrieving expectations/expectations/2.0.9/expectations-2.0.9.jar from clojars
</pre>

<p>Leiningen nyní umožňuje spouštět novou sadu testů příkazem:</p>

<pre>
<strong>lein expectations</strong>
&nbsp;
Ran 0 tests containing 0 assertions in 8 msecs
0 failures, 0 errors.
</pre>

<p>Ve skutečnosti využívá knihovna Expectations řídicí kódy terminálu pro
obarvení výstupu, takže výsledek může vypadat takto:</p>

<a href="http://www.root.cz/obrazek/218465/"><img src="http://i.iinfo.cz/images/199/exp1-prev.png" class="image-218465" alt="&#160;" height="55" width="370" /></a>



<p><a name="k03"></a></p>
<h2 id="k03">3. Testy napsané s&nbsp;využitím knihovny <strong>clojure.test</strong></h2>

<p>Zopakujme si nejdříve, jakým způsobem se vytváří jednotkové testy při
použití knihovny <i>clojure.test</i>. V&nbsp;tomto případě je skupina testů
sdružena deklarací <strong>deftest</strong>, uvnitř které lze použít makro
<strong>testing</strong> zajišťující další úroveň sdružování, není to však
nutné (já zde toto makro používám pro zvýšení čitelnosti). V&nbsp;těle makra
<strong>testing</strong> jsou umístěny funkce a makra <strong>is</strong> a
<strong>are</strong> pro zápis volání funkcí (či metod) a očekávaného výsledku.
Navíc je možné přes <strong>thrown?</strong> otestovat, zda volaná funkce či
metoda vyhodila výjimku správného typu. Testy pro zjištění korektní
funkcionality funkce <strong>factorial</strong> mohou vypadat následovně. Za
povšimnutí stojí i způsob použití makra <strong>ns</strong> na začátku testu,
především pak třetí řádek, který zajistí nahrání všech testovaných funkcí (to
se neprovádí automaticky):</p>

<pre>
(ns <strong>factorial3.core-test</strong>
  (:require [<strong>clojure.test</strong>    :refer :all]
            [factorial3.core :refer :all]))
&nbsp;
(deftest <strong>factorial-test</strong>
    (testing "Factorial"
        (is ( = (factorial 0)   1) "beginning")
        (is ( = (factorial 1)   1) "beginning")
        (is ( = (factorial 2)   (* 1 2)) "still easy")
        (is ( = (factorial 5)   (* 1 2 3 4 5)) "5!")
        (is ( = (factorial 6)   720) "6!")))
&nbsp;
(deftest <strong>negative-factorial-test</strong>
    (testing "Negative tests"
        (is ( = (factorial 0)   0) "negative test case #1")
        (is ( = (factorial 1)   0) "negative test case #2")
        (is ( = (factorial 2)   0) "negative test case #3")))
&nbsp;
(deftest <strong>exception-test</strong>
    (testing "If factorial throws exception"
        (is (thrown? IllegalArgumentException (factorial -1)))
        (is (thrown? IllegalArgumentException (factorial -2)))
        (is (thrown? IllegalArgumentException (factorial -100)))))
&nbsp;
(deftest <strong>negative-exception-test</strong>
    (testing "(negative test) If factorial throws exception"
        (is (thrown? IllegalArgumentException (factorial 1)))
        (is (thrown? IllegalArgumentException (factorial 2)))
        (is (thrown? IllegalArgumentException (factorial 3)))))
</pre>

<p>Očekávané výsledky:</p>

<ol>
<li>Test <strong>factorial-test</strong> by měl být spuštěn bez chyby (vypočtené výsledky odpovídají očekávaným hodnotám).</li>
<li>Test <strong>negative-factorial-test</strong> by měl nahlásit tři chyby (testovaná funkce je sice korektní, my však očekáváme odlišné výsledky).</li>
<li>Test <strong>exception-test</strong> by měl být spuštěn bez chyby (všechny výjimky jsou skutečně vyhozeny).</li>
<li>Test <strong>negative-exception-test</strong> by měl nahlásit tři chyby (výjimky nejsou vyhozeny, protože vstupní parametry 1, 2 a 3 jsou zcela korektní).</li>
</ol>



<p><a name="k04"></a></p>
<h2 id="k04">4. Testy napsané s&nbsp;využitím knihovny <strong>Expectations</strong></h2>

<p>Při použití knihovny <i>Expectations</i> se testy zapisují nepatrně odlišným
způsobem. Především se zde nepoužívá sdružování s&nbsp;využitím
<strong>deftest</strong> a <strong>testing</strong>, protože autor knihovny
<i>Expectations</i> (Jay Fields) se drží zásady &bdquo;One assertion per
test&ldquo;. Dále se namísto maker <strong>is</strong> a <strong>are</strong>,
které většinou vyžadují explicitní zápis porovnání, používá inteligentní makro
nazvané <strong>expect</strong>. Toto makro očekává dva parametry. Prvním
parametrem je očekávaná hodnota, druhým parametrem je pak většinou volání
nějaké funkce či jiného makra. <strong>expect</strong> na základě typu prvního
parametru automaticky rozpozná, jakým způsobem se má provádět porovnávání;
porovnávat lze totiž jak návratové hodnoty (jakéhokoli typu), tak i například
zjistit, zda byla vyhozena očekávaná výjimka, zda má návratová hodnota
očekávaný typ atd. atd. My nejdříve použijeme test s&nbsp;porovnáváním
návratových hodnot a zjišťováním, zda byla vyhozena očekávaná výjimka.
V&nbsp;obou případech je použit stejný formát volání makra
<strong>expect</strong>:</p>

<pre>
(ns <strong>factorial2.core-expect-test</strong>
  (:require [factorial2.core :refer :all])
  (:use <strong>expectations</strong>))
&nbsp;
(<strong>expect</strong> 1       (factorial 0))
(<strong>expect</strong> 1       (factorial 1))
(<strong>expect</strong> (* 1 2) (factorial 2))
(<strong>expect</strong> (* 1 2 3 4 5) (factorial 5))
(<strong>expect</strong> 720     (factorial 6))
&nbsp;
(<strong>expect</strong> 0 (factorial 0))
(<strong>expect</strong> 0 (factorial 1))
(<strong>expect</strong> 0 (factorial 2))
&nbsp;
(<strong>expect</strong> IllegalArgumentException (factorial -1))
(<strong>expect</strong> IllegalArgumentException (factorial -2))
(<strong>expect</strong> IllegalArgumentException (factorial -100))
&nbsp;
(<strong>expect</strong> IllegalArgumentException (factorial 1))
(<strong>expect</strong> IllegalArgumentException (factorial 2))
(<strong>expect</strong> IllegalArgumentException (factorial 3))
</pre>



<p><a name="k05"></a></p>
<h2 id="k05">5. Porovnání výsledků běhu obou testů</h2>

<p>Podívejme se nyní na způsob prezentace výsledků běhu obou testů. Nejprve se
zaměříme na výsledky vypsané knihovnou <i>clojure.test</i>:</p>

<pre>
lein test factorial2.core-test
&nbsp;
lein test :only factorial2.core-test/negative-exception-test
&nbsp;
FAIL in (negative-exception-test) (core_test.clj:27)
(negative test) If factorial throws exception
expected: (thrown? IllegalArgumentException (factorial 1))
  actual: nil
&nbsp;
lein test :only factorial2.core-test/negative-exception-test
&nbsp;
FAIL in (negative-exception-test) (core_test.clj:28)
(negative test) If factorial throws exception
expected: (thrown? IllegalArgumentException (factorial 2))
  actual: nil
&nbsp;
lein test :only factorial2.core-test/negative-exception-test
&nbsp;
FAIL in (negative-exception-test) (core_test.clj:29)
(negative test) If factorial throws exception
expected: (thrown? IllegalArgumentException (factorial 3))
  actual: nil
&nbsp;
lein test :only factorial2.core-test/negative-factorial-test
&nbsp;
FAIL in (negative-factorial-test) (core_test.clj:15)
Negative tests
negative test case #1
expected: (= (factorial 0) 0)
  actual: (not (= 1 0))
&nbsp;
lein test :only factorial2.core-test/negative-factorial-test
&nbsp;
FAIL in (negative-factorial-test) (core_test.clj:16)
Negative tests
negative test case #2
expected: (= (factorial 1) 0)
  actual: (not (= 1 0))
&nbsp;
lein test :only factorial2.core-test/negative-factorial-test
&nbsp;
FAIL in (negative-factorial-test) (core_test.clj:17)
Negative tests
negative test case #3
expected: (= (factorial 2) 0)
  actual: (not (= 2 0))
&nbsp;
Ran 4 tests containing 14 assertions.
6 failures, 0 errors.
</pre>

<p>Vidíme, že testy nejsou volány v&nbsp;tom pořadí, jak jsou zapsány ve
zdrojovém kódu, což v&nbsp;některých případech může způsobovat problémy. Dále
je pak patrné, že hlášení o chybách není příliš čitelné, protože se očekávané a
skutečně získané výsledky zbytečně ztrácí mezi množstvím závorek a opisech
původního zdrojového kódu.</p>

<p>Následuje výstup poskytovaný knihovnou <i>Expectations</i>:</p>

<pre>
failure in (core_expect_test.clj:14) : factorial2.core-expect-test
(expect 0 (factorial 0))
&nbsp;
           expected: 0
                was: 1
&nbsp;
failure in (core_expect_test.clj:15) : factorial2.core-expect-test
(expect 0 (factorial 1))
&nbsp;
           expected: 0
                was: 1
&nbsp;
failure in (core_expect_test.clj:16) : factorial2.core-expect-test
(expect 0 (factorial 2))
&nbsp;
           expected: 0
                was: 2
&nbsp;
failure in (core_expect_test.clj:22) : factorial2.core-expect-test
(expect IllegalArgumentException (factorial 1))
&nbsp;
           (factorial 1) did not throw IllegalArgumentException
&nbsp;
failure in (core_expect_test.clj:23) : factorial2.core-expect-test
(expect IllegalArgumentException (factorial 2))
&nbsp;
           (factorial 2) did not throw IllegalArgumentException
&nbsp;
failure in (core_expect_test.clj:24) : factorial2.core-expect-test
(expect IllegalArgumentException (factorial 3))
&nbsp;
           (factorial 3) did not throw IllegalArgumentException
&nbsp;
Ran 14 tests containing 14 assertions in 71 msecs
6 failures, 0 errors.
</pre>

<p>Opět platí, že výstup je ve skutečnosti obarven a vypadá zhruba takto:</p>

<a href="http://www.root.cz/obrazek/218466/"><img src="http://i.iinfo.cz/images/209/exp2-prev.png" class="image-218466" alt="&#160;" height="270" width="285" /></a>

<p>Takto generovaný výsledek testů je podle mého názoru čitelnější, neboť jsou
zobrazeny jen ty skutečně relevantní informace.</p>



<p><a name="k06"></a></p>
<h2 id="k06">6. Další možnosti makra <strong>expect</strong></h2>

<p>Pro otestování dalších vlastností makra <strong>expect</strong> si vytvoříme
nový projekt:</p>

<pre>
<strong>lein new app expectations-demo</strong>
Generating a project called expectations-demo based on the 'app' template.
</pre>

<p>Upravíme projektový soubor <strong>project.clj</strong>:</p>

<pre>
(defproject expectations-demo "0.1.0-SNAPSHOT"
  :description "FIXME: write description"
  :url "http://example.com/FIXME"
  :license {:name "Eclipse Public License"
            :url "http://www.eclipse.org/legal/epl-v10.html"}
  :dependencies [[org.clojure/clojure "1.6.0"]
                 <strong>[expectations "2.0.9"]</strong>]
  :main ^:skip-aot expectations-demo.core
  :target-path "target/%s"
  :plugins [<strong>[lein-expectations "0.0.8"]</strong>]
  :profiles {:uberjar {:aot :all}})
</pre>

<p>Struktura projektu po jeho vytvoření:</p>

<pre>
.
├── doc
│   └── intro.md
├── LICENSE
├── project.clj
├── README.md
├── resources
├── src
│   └── expectations_demo
│       └── core.clj
└── test
    └── expectations_demo
        └── core_test.clj
&nbsp;
6 directories, 6 files
</pre>

<p>Všechny další úpravy se budou týkat pouze souboru
<strong>test/expectations_demo/core_test.clj</strong>. Další vlastnosti makra
<strong>expect</strong> jsou popsány přímo v&nbsp;tomto souboru formou
poznámek:</p>

<pre>
(ns expectations-demo.core-test
  (:require [expectations :refer :all]
            [expectations-demo.core :refer :all]))
&nbsp;
&nbsp;
&nbsp;
<i>; ------------------------------------------------------------</i>
<i>; Porovnání návratové hodnoty</i>
<i>; ------------------------------------------------------------</i>
&nbsp;
(<strong>expect</strong> 42 (* 6 7))
&nbsp;
(<strong>expect</strong> "Hello world" (str "Hello" " " "world"))
&nbsp;
(<strong>expect</strong> 2/3 (/ 2 3))
&nbsp;
&nbsp;
&nbsp;
<i>; ------------------------------------------------------------</i>
<i>; Prvním parametrem makra expect může být například i predikát</i>
<i>; ------------------------------------------------------------</i>
&nbsp;
(<strong>expect</strong> even? 2)
&nbsp;
(<strong>expect</strong> odd? 3)
&nbsp;
(<strong>expect</strong> nil? nil)
&nbsp;
(<strong>expect</strong> seq? '(1 2 3))
&nbsp;
(<strong>expect</strong> seq? (seq [1 2 3]))
</pre>



<p><a name="k07"></a></p>
<h2 id="k07">7. Regulární výrazy v&nbsp;makru <strong>expect</strong></h2>

<p>Pokud je prvním parametrem regulární výraz (<i>regexp</i>), bude se
&bdquo;matchovat&ldquo; s&nbsp;řetězcem, který je očekáván jako druhý parametr
(či výsledek volané funkce/makra). Připomeňme si, že regulární výraz lze
v&nbsp;jazyku Clojure považovat za samostatný datový typ a nikoli za běžný
řetězec (což zjednodušuje zápis regulárních výrazů):</p>

<pre>
(<strong>expect</strong> #"Expect" "Expectations")
&nbsp;
(<strong>expect</strong> #"^[a-zA-Z]+$" "Hello")
&nbsp;
(<strong>expect</strong> #"^[a-zA-Z]+$" "123qwe") ; nebude splněno
&nbsp;
(<strong>expect</strong> #"^[a-zA-Z0-9]+$" "123qwe") ; bude splněno
&nbsp;
(<strong>expect</strong> #"[\s]*" "123qwe")
&nbsp;
(<strong>expect</strong> #"^([A-Z][a-z]+)+$" "CamelCaseString")  ; bude splněno
&nbsp;
(<strong>expect</strong> #"^([A-Z][a-z]+)+$" "CamelCaseStringS") ; nebude splněno
&nbsp;
(<strong>expect</strong> #"^([A-Z][a-z]+)+$" "camel_case_string") ; nebude splněno
</pre>

<p>Výsledek běhu testů:</p>

<pre>
failure in (core_test.clj:45) : expectations-demo.core-test
(expect #"^[a-zA-Z]+$" "123qwe")
&nbsp;
           regex #"^[a-zA-Z]+$" not found in "123qwe"
&nbsp;
failure in (core_test.clj:53) : expectations-demo.core-test
(expect #"^([A-Z][a-z]+)+$" "CamelCaseStringS")
&nbsp;
           regex #"^([A-Z][a-z]+)+$" not found in "CamelCaseStringS"
&nbsp;
failure in (core_test.clj:55) : expectations-demo.core-test
(expect #"^([A-Z][a-z]+)+$" "camel_case_string")
&nbsp;
           regex #"^([A-Z][a-z]+)+$" not found in "camel_case_string"
</pre>



<p><a name="k08"></a></p>
<h2 id="k08">8. Kolekce v&nbsp;makru <strong>expect</strong></h2>

<p>Velmi elegantní je práce s&nbsp;kolekcemi, neboť se automaticky rozpoznávají
některé typické odlišnosti dvou kolekcí (očekávané hodnoty a hodnoty vypočtené)
&ndash; přidání prvku, ubrání prvku, prohození prvků atd. Podívejme se na
příklady:</p>

<pre>
<i>; zjištění existence prvku v kolekci</i>
(<strong>expect</strong> 3 (in [1 2 3]))
&nbsp;
<i>; porovnání dvou různých kolekcí</i>
(<strong>expect</strong> [1 2] [3 4])
&nbsp;
(<strong>expect</strong> [1 2] [3 4 5 6])
&nbsp;
<i>; různé typy, stejný obsah - test projde</i>
(<strong>expect</strong> [1 2] '(1 2))
&nbsp;
<i>; expect rozpozná zpřeházené prvky</i>
(<strong>expect</strong> [1 2] [2 1])
(<strong>expect</strong> [1 2 3] [3 2 1])
&nbsp;
<i>; expect rozpozná přidání prvku</i>
(<strong>expect</strong> [1 2] [1 2 3])
(<strong>expect</strong> [1 2] [1 2 3 4 5])
&nbsp;
<i>; expect rozpozná i ubrání prvku</i>
(<strong>expect</strong> [1 2 3] [1 2])
(<strong>expect</strong> [1 2 3 4 5] [1 2])
&nbsp;
<i>; dtto pro mapy - opět se eliminuje výpis zbytečných informací</i>
(<strong>expect</strong> #{:name "Bender" :id 42} #{:name "Bender" :id 42})
&nbsp;
(<strong>expect</strong> #{:name "Bender" :id 42} #{:name "Joe" :id 42})
&nbsp;
(<strong>expect</strong> #{:name "Bender" :id 42} #{:name "Joe" :id 1000})
&nbsp;
(<strong>expect</strong> #{:name "Bender" :id 42} #{:name "Bender" :id 42 :foo :bar})
&nbsp;
(<strong>expect</strong> #{:name "Bender" :id 42} #{:name "Bender"})
&nbsp;
(<strong>expect</strong> #{:name "Bender" :id 42} #{:name "Bender" :not-id 42})
</pre>

<p>Výsledek běhu testů:</p>

<pre>
failure in (core_test.clj:67) : expectations-demo.core-test
(expect [1 2] [3 4])
&nbsp;
           expected: [1 2] 
                was: [3 4]
&nbsp;
           in expected, not actual: [1 2]
           in actual, not expected: [3 4]
&nbsp;
failure in (core_test.clj:69) : expectations-demo.core-test
(expect [1 2] [3 4 5 6])
&nbsp;
           expected: [1 2] 
                was: [3 4 5 6]
&nbsp;
           in expected, not actual: [1 2]
           in actual, not expected: [3 4 5 6]
           actual is larger than expected
&nbsp;
failure in (core_test.clj:75) : expectations-demo.core-test
(expect [1 2] [2 1])
&nbsp;
           expected: [1 2] 
                was: [2 1]
&nbsp;
           in expected, not actual: [1 2]
           in actual, not expected: [2 1]
           lists appear to contain the same items with different ordering
&nbsp;
failure in (core_test.clj:76) : expectations-demo.core-test
(expect [1 2 3] [3 2 1])
&nbsp;
           expected: [1 2 3] 
                was: [3 2 1]
&nbsp;
           in expected, not actual: [1 nil 3]
           in actual, not expected: [3 nil 1]
           lists appear to contain the same items with different ordering
&nbsp;
failure in (core_test.clj:79) : expectations-demo.core-test
(expect [1 2] [1 2 3])
&nbsp;
           expected: [1 2] 
                was: [1 2 3]
&nbsp;
           in expected, not actual: null
           in actual, not expected: [nil nil 3]
           actual is larger than expected
&nbsp;
failure in (core_test.clj:80) : expectations-demo.core-test
(expect [1 2] [1 2 3 4 5])
&nbsp;
           expected: [1 2] 
                was: [1 2 3 4 5]
&nbsp;
           in expected, not actual: null
           in actual, not expected: [nil nil 3 4 5]
           actual is larger than expected
&nbsp;
failure in (core_test.clj:83) : expectations-demo.core-test
(expect [1 2 3] [1 2])
&nbsp;
           expected: [1 2 3] 
                was: [1 2]
&nbsp;
           in expected, not actual: [nil nil 3]
           in actual, not expected: null
           expected is larger than actual
&nbsp;
failure in (core_test.clj:84) : expectations-demo.core-test
(expect [1 2 3 4 5] [1 2])
&nbsp;
           expected: [1 2 3 4 5] 
                was: [1 2]
&nbsp;
           in expected, not actual: [nil nil 3 4 5]
           in actual, not expected: null
           expected is larger than actual
&nbsp;
failure in (core_test.clj:89) : expectations-demo.core-test
(expect #{:name "Bender" :id 42} #{:name "Joe" :id 42})
&nbsp;
           expected: #{:name "Bender" :id 42} 
                was: #{:name "Joe" :id 42}
&nbsp;
           in expected, not actual: #{"Bender"}
           in actual, not expected: #{"Joe"}
&nbsp;
failure in (core_test.clj:91) : expectations-demo.core-test
(expect #{:name "Bender" :id 42} #{:name 1000 "Joe" :id})
&nbsp;
           expected: #{:name "Bender" :id 42} 
                was: #{:name 1000 "Joe" :id}
&nbsp;
           in expected, not actual: #{"Bender" 42}
           in actual, not expected: #{1000 "Joe"}
&nbsp;
failure in (core_test.clj:93) : expectations-demo.core-test
(expect #{:name "Bender" :id 42} #{:bar :name "Bender" :foo :id 42})
&nbsp;
           expected: #{:name "Bender" :id 42} 
                was: #{:bar :name "Bender" :foo :id 42}
&nbsp;
           in expected, not actual: null
           in actual, not expected: #{:bar :foo}
&nbsp;
failure in (core_test.clj:95) : expectations-demo.core-test
(expect #{:name "Bender" :id 42} #{:name "Bender"})
&nbsp;
           expected: #{:name "Bender" :id 42} 
                was: #{:name "Bender"}
&nbsp;
           in expected, not actual: #{:id 42}
           in actual, not expected: null
&nbsp;
failure in (core_test.clj:97) : expectations-demo.core-test
(expect #{:name "Bender" :id 42} #{:name "Bender" :not-id 42})
&nbsp;
           expected: #{:name "Bender" :id 42} 
                was: #{:name "Bender" :not-id 42}
&nbsp;
           in expected, not actual: #{:id}
           in actual, not expected: #{:not-id}
</pre>



<p><a name="k09"></a></p>
<h2 id="k09">9. Kontrola typu a test, zda byla vyvolána výjimka</h2>

<pre>
<i>; ------------------------------------------------------------</i>
<i>; Kontrola typu návratové hodnoty</i>
<i>; ------------------------------------------------------------</i>
&nbsp;
(<strong>expect</strong> String (str "Hello world"))
&nbsp;
(<strong>expect</strong> Long (* 6 7))
&nbsp;
(<strong>expect</strong> Long (apply * (range 10)))
&nbsp;
(<strong>expect</strong> Double (/ 1.0 3))
&nbsp;
<i>; pozor na použití zlomků</i>
(<strong>expect</strong> clojure.lang.Ratio (/ 1 3))
</pre>

<pre>
<i>; ------------------------------------------------------------</i>
<i>; Kontrola vyhození výjimky</i>
<i>; ------------------------------------------------------------</i>
&nbsp;
<i>; výjimka je vyhozena</i>
(<strong>expect</strong> ArithmeticException (/ 1 0))
&nbsp;
<i>; výjimka není vyhozena</i>
(<strong>expect</strong> IndexOutOfBoundsException (nth [1 2 3] 1))
&nbsp;
<i>; výjimka je vyhozena</i>
(<strong>expect</strong> IndexOutOfBoundsException (nth [1 2 3] -1))
&nbsp;
<i>; je vyhozena odlišná výjimka</i>
(<strong>expect</strong> NullPointerException (nth [1 2 3] -1))
</pre>

<p>Výsledek běhu všech testů:</p>

<a href="http://www.root.cz/obrazek/218467/"><img src="http://i.iinfo.cz/images/199/exp3-prev.png" class="image-218467" alt="&#160;" height="270" width="208" /></a>



<p><a name="k10"></a></p>
<h2 id="k10">10. Repositář s&nbsp;dnešními demonstračními příklady</h2>

<p>Všechny dnes zmíněné demonstrační příklady byly, podobně jako
v&nbsp;předchozích částech tohoto seriálu, uloženy do Git repositáře dostupného
na adrese <a
href="https://github.com/tisnik/clojure-examples">https://github.com/tisnik/clojure-examples</a>.
V&nbsp;tabulce zobrazené pod tímto odstavcem naleznete na zdrojové kódy
jednotlivých demonstračních příkladů přímé odkazy:</p>

<table>
<tr><th>#</th><th>Příklad </th><th>Github</th></tr>
<tr><td>1</td><td>factorial</td><td><a href="https://github.com/tisnik/clojure-examples/tree/master/factorial">https://github.com/tisnik/clojure-examples/tree/master/factorial</a></td></tr>
<tr><td>2</td><td>factorial2</td><td><a href="https://github.com/tisnik/clojure-examples/tree/master/factorial2">https://github.com/tisnik/clojure-examples/tree/master/factorial2</a></td></tr>
<tr><td>3</td><td>factorial3</td><td><a href="https://github.com/tisnik/clojure-examples/tree/master/factorial3">https://github.com/tisnik/clojure-examples/tree/master/factorial3</a></td></tr>
<tr><td>4</td><td>expectations-demo</td><td><a href="https://github.com/tisnik/clojure-examples/tree/master/expectations-demo">https://github.com/tisnik/clojure-examples/tree/master/expectations-demo</a></td></tr>
</table>



<p><a name="k11"></a></p>
<h2 id="k11">11. Odkazy na předchozí části tohoto seriálu</h2>

<ol>

<li>Leiningen: nástroj pro správu projektů napsaných v Clojure<br />
<a href="http://www.root.cz/clanky/leiningen-nastroj-pro-spravu-projektu-napsanych-v-clojure/">http://www.root.cz/clanky/leiningen-nastroj-pro-spravu-projektu-napsanych-v-clojure/</a>
</li>

<li>Leiningen: nástroj pro správu projektů napsaných v Clojure (2)<br />
<a href="http://www.root.cz/clanky/leiningen-nastroj-pro-spravu-projektu-napsanych-v-clojure-2/">http://www.root.cz/clanky/leiningen-nastroj-pro-spravu-projektu-napsanych-v-clojure-2/</a>
</li>

<li>Leiningen: nástroj pro správu projektů napsaných v Clojure (3)<br />
<a href="http://www.root.cz/clanky/leiningen-nastroj-pro-spravu-projektu-napsanych-v-clojure-3/">http://www.root.cz/clanky/leiningen-nastroj-pro-spravu-projektu-napsanych-v-clojure-3/</a>
</li>

<li>Leiningen: nástroj pro správu projektů napsaných v Clojure (4)<br />
<a href="http://www.root.cz/clanky/leiningen-nastroj-pro-spravu-projektu-napsanych-v-clojure-4/">http://www.root.cz/clanky/leiningen-nastroj-pro-spravu-projektu-napsanych-v-clojure-4/</a>
</li>

<li>Leiningen: nástroj pro správu projektů napsaných v Clojure (5)<br />
<a href="http://www.root.cz/clanky/leiningen-nastroj-pro-spravu-projektu-napsanych-v-clojure-5/">http://www.root.cz/clanky/leiningen-nastroj-pro-spravu-projektu-napsanych-v-clojure-5/</a>
</li>

<li>Leiningen: nástroj pro správu projektů napsaných v Clojure (6)<br />
<a href="http://www.root.cz/clanky/leiningen-nastroj-pro-spravu-projektu-napsanych-v-clojure-6/">http://www.root.cz/clanky/leiningen-nastroj-pro-spravu-projektu-napsanych-v-clojure-6/</a>
</li>

<li>Programovací jazyk Clojure a databáze (1.část)<br />
<a href="http://www.root.cz/clanky/programovaci-jazyk-clojure-a-databaze-1-cast/">http://www.root.cz/clanky/programovaci-jazyk-clojure-a-databaze-1-cast/</a>
</li>

<li>Pluginy pro Leiningen<br />
<a href="http://www.root.cz/clanky/leiningen-nastroj-pro-spravu-projektu-napsanych-v-clojure-pluginy-pro-leiningen/">http://www.root.cz/clanky/leiningen-nastroj-pro-spravu-projektu-napsanych-v-clojure-pluginy-pro-leiningen/</a>
</li>

<li>Programovací jazyk Clojure a knihovny pro práci s vektory a maticemi<br />
<a href="http://www.root.cz/clanky/programovaci-jazyk-clojure-a-knihovny-pro-praci-s-vektory-a-maticemi/">http://www.root.cz/clanky/programovaci-jazyk-clojure-a-knihovny-pro-praci-s-vektory-a-maticemi/</a>
</li>

<li>Programovací jazyk Clojure a knihovny pro práci s vektory a maticemi (2)<br />
<a href="http://www.root.cz/clanky/programovaci-jazyk-clojure-a-knihovny-pro-praci-s-vektory-a-maticemi-2/">http://www.root.cz/clanky/programovaci-jazyk-clojure-a-knihovny-pro-praci-s-vektory-a-maticemi-2/</a>
</li>

<li>Programovací jazyk Clojure: syntéza procedurálních textur s využitím knihovny Clisk<br />
<a href="http://www.root.cz/clanky/programovaci-jazyk-clojure-synteza-proceduralnich-textur-s-vyuzitim-knihovny-clisk/">http://www.root.cz/clanky/programovaci-jazyk-clojure-synteza-proceduralnich-textur-s-vyuzitim-knihovny-clisk/</a>
</li>

<li>Programovací jazyk Clojure: syntéza procedurálních textur s využitím knihovny Clisk (2)<br />
<a href="http://www.root.cz/clanky/programovaci-jazyk-clojure-synteza-proceduralnich-textur-s-vyuzitim-knihovny-clisk-2/">http://www.root.cz/clanky/programovaci-jazyk-clojure-synteza-proceduralnich-textur-s-vyuzitim-knihovny-clisk-2/</a>
</li>

<li>Programovací jazyk Clojure: syntéza procedurálních textur s využitím knihovny Clisk (dokončení)<br />
<a href="http://www.root.cz/clanky/programovaci-jazyk-clojure-synteza-proceduralnich-textur-s-vyuzitim-knihovny-clisk-dokonceni/">http://www.root.cz/clanky/programovaci-jazyk-clojure-synteza-proceduralnich-textur-s-vyuzitim-knihovny-clisk-dokonceni/</a>
</li>

<li>Seesaw: knihovna pro snadnou tvorbu GUI v jazyce Clojure<br />
<a href="http://www.root.cz/clanky/seesaw-knihovna-pro-snadnou-tvorbu-gui-v-jazyce-clojure/">http://www.root.cz/clanky/seesaw-knihovna-pro-snadnou-tvorbu-gui-v-jazyce-clojure/</a>
</li>

<li>Seesaw: knihovna pro snadnou tvorbu GUI v jazyce Clojure (2)<br />
<a href="http://www.root.cz/clanky/seesaw-knihovna-pro-snadnou-tvorbu-gui-v-jazyce-clojure-2/">http://www.root.cz/clanky/seesaw-knihovna-pro-snadnou-tvorbu-gui-v-jazyce-clojure-2/</a>
</li>

<li>Seesaw: knihovna pro snadnou tvorbu GUI v jazyce Clojure (3)<br />
<a href="http://www.root.cz/clanky/seesaw-knihovna-pro-snadnou-tvorbu-gui-v-jazyce-clojure-3/">http://www.root.cz/clanky/seesaw-knihovna-pro-snadnou-tvorbu-gui-v-jazyce-clojure-3/</a>
</li>

<li>Programovací jazyk Clojure a práce s Gitem<br />
<a href="http://www.root.cz/clanky/programovaci-jazyk-clojure-a-prace-s-gitem/">http://www.root.cz/clanky/programovaci-jazyk-clojure-a-prace-s-gitem/</a>
</li>

<li>Programovací jazyk Clojure a práce s Gitem (2)<br />
<a href="http://www.root.cz/clanky/programovaci-jazyk-clojure-a-prace-s-gitem-2/">http://www.root.cz/clanky/programovaci-jazyk-clojure-a-prace-s-gitem-2/</a>
</li>

<li>Programovací jazyk Clojure – triky při práci s řetězci<br />
<a href="http://www.root.cz/clanky/programovaci-jazyk-clojure-triky-pri-praci-s-retezci/">http://www.root.cz/clanky/programovaci-jazyk-clojure-triky-pri-praci-s-retezci/</a>
</li>

<li>Programovací jazyk Clojure – triky při práci s kolekcemi<br />
<a href="http://www.root.cz/clanky/programovaci-jazyk-clojure-triky-pri-praci-s-kolekcemi/">http://www.root.cz/clanky/programovaci-jazyk-clojure-triky-pri-praci-s-kolekcemi/</a>
</li>

<li>Programovací jazyk Clojure – práce s mapami a množinami<br />
<a href="http://www.root.cz/clanky/programovaci-jazyk-clojure-prace-s-mapami-a-mnozinami/">http://www.root.cz/clanky/programovaci-jazyk-clojure-prace-s-mapami-a-mnozinami/</a>
</li>

<li>Programovací jazyk Clojure – základy zpracování XML<br />
<a href="http://www.root.cz/clanky/programovaci-jazyk-clojure-zaklady-zpracovani-xml/">http://www.root.cz/clanky/programovaci-jazyk-clojure-zaklady-zpracovani-xml/</a>
</li>

</ol>



<p><a name="k12"></a></p>
<h2 id="k12">12. Odkazy na Internetu</h2>

<ol>

<li>Expectations: příklady atd.<br />
<a href="http://jayfields.com/expectations/">http://jayfields.com/expectations/</a>
</li>

<li>Expectations na GitHubu<br />
<a href="https://github.com/jaycfields/expectations">https://github.com/jaycfields/expectations</a>
</li>

<li>Lein-expectations na GitHubu<br />
<a href="https://github.com/gar3thjon3s/lein-expectations">https://github.com/gar3thjon3s/lein-expectations</a>
</li>

<li>Testing Clojure With Expectations<br />
<a href="https://semaphoreci.com/blog/2014/09/23/testing-clojure-with-expectations.html">https://semaphoreci.com/blog/2014/09/23/testing-clojure-with-expectations.html</a>
</li>

<li>Clojure testing TDD/BDD libraries: clojure.test vs Midje vs Expectations vs Speclj<br />
<a href="https://www.reddit.com/r/Clojure/comments/1viilt/clojure_testing_tddbdd_libraries_clojuretest_vs/">https://www.reddit.com/r/Clojure/comments/1viilt/clojure_testing_tddbdd_libraries_clojuretest_vs/</a>
</li>

<li>Testing: One assertion per test<br />
<a href="http://blog.jayfields.com/2007/06/testing-one-assertion-per-test.html">http://blog.jayfields.com/2007/06/testing-one-assertion-per-test.html</a>
</li>

<li>Rewriting Your Test Suite in Clojure in 24 hours<br />
<a href="http://blog.circleci.com/rewriting-your-test-suite-in-clojure-in-24-hours/">http://blog.circleci.com/rewriting-your-test-suite-in-clojure-in-24-hours/</a>
</li>

<li>Clojure doc: zipper<br />
<a href="http://clojuredocs.org/clojure.zip/zipper">http://clojuredocs.org/clojure.zip/zipper</a>
</li>

<li>Clojure doc: parse<br />
<a href="http://clojuredocs.org/clojure.xml/parse">http://clojuredocs.org/clojure.xml/parse</a>
</li>

<li>Clojure doc: xml-zip<br />
<a href="http://clojuredocs.org/clojure.zip/xml-zip">http://clojuredocs.org/clojure.zip/xml-zip</a>
</li>

<li>Clojure doc: xml-seq<br />
<a href="http://clojuredocs.org/clojure.core/xml-seq">http://clojuredocs.org/clojure.core/xml-seq</a>
</li>

<li>Parsing XML in Clojure<br />
<a href="https://github.com/clojuredocs/guides">https://github.com/clojuredocs/guides</a>
</li>

<li>Clojure Zipper Over Nested Vector<br />
<a href="https://vitalyper.wordpress.com/2010/11/23/clojure-zipper-over-nested-vector/">https://vitalyper.wordpress.com/2010/11/23/clojure-zipper-over-nested-vector/</a>
</li>

<li>Understanding Clojure's PersistentVector implementation<br />
<a href="http://blog.higher-order.net/2009/02/01/understanding-clojures-persistentvector-implementation">http://blog.higher-order.net/2009/02/01/understanding-clojures-persistentvector-implementation</a>
</li>

<li>Understanding Clojure's PersistentHashMap (deftwice...)<br />
<a href="http://blog.higher-order.net/2009/09/08/understanding-clojures-persistenthashmap-deftwice.html">http://blog.higher-order.net/2009/09/08/understanding-clojures-persistenthashmap-deftwice.html</a>
</li>

<li>Assoc and Clojure's PersistentHashMap: part ii<br />
<a href="http://blog.higher-order.net/2010/08/16/assoc-and-clojures-persistenthashmap-part-ii.html">http://blog.higher-order.net/2010/08/16/assoc-and-clojures-persistenthashmap-part-ii.html</a>
</li>

<li>Ideal Hashtrees (paper)<br />
<a href="http://lampwww.epfl.ch/papers/idealhashtrees.pdf">http://lampwww.epfl.ch/papers/idealhashtrees.pdf</a>
</li>

<li>Clojure home page<br />
<a href="http://clojure.org/">http://clojure.org/</a>
</li>

<li>Clojure (downloads)<br />
<a href="http://clojure.org/downloads">http://clojure.org/downloads</a>
</li>

<li>Clojure Sequences<br />
<a href="http://clojure.org/sequences">http://clojure.org/sequences</a>
</li>

<li>Clojure Data Structures<br />
<a href="http://clojure.org/data_structures">http://clojure.org/data_structures</a>
</li>

<li>The Structure and Interpretation of Computer Programs: 2.2.1  Representing Sequences<br />
<a href="http://mitpress.mit.edu/sicp/full-text/book/book-Z-H-15.html#%_sec_2.2.1">http://mitpress.mit.edu/sicp/full-text/book/book-Z-H-15.html#%_sec_2.2.1</a>
</li>

<li>The Structure and Interpretation of Computer Programs: 3.3.1  Mutable List Structure<br />
<a href="http://mitpress.mit.edu/sicp/full-text/book/book-Z-H-22.html#%_sec_3.3.1">http://mitpress.mit.edu/sicp/full-text/book/book-Z-H-22.html#%_sec_3.3.1</a>
</li>

<li>Clojure - Functional Programming for the JVM<br />
<a href="http://java.ociweb.com/mark/clojure/article.html">http://java.ociweb.com/mark/clojure/article.html</a>
</li>

<li>Clojure quick reference<br />
<a href="http://faustus.webatu.com/clj-quick-ref.html">http://faustus.webatu.com/clj-quick-ref.html</a>
</li>

<li>4Clojure<br />
<a href="http://www.4clojure.com/">http://www.4clojure.com/</a>
</li>

<li>ClojureDoc (rozcestník s&nbsp;dokumentací jazyka Clojure)<br />
<a href="http://clojuredocs.org/">http://clojuredocs.org/</a>
</li>

<li>Clojure (na Wikipedia EN)<br />
<a href="http://en.wikipedia.org/wiki/Clojure">http://en.wikipedia.org/wiki/Clojure</a>
</li>

<li>Clojure (na Wikipedia CS)<br />
<a href="http://cs.wikipedia.org/wiki/Clojure">http://cs.wikipedia.org/wiki/Clojure</a>
</li>

<li>SICP (The Structure and Interpretation of Computer Programs)<br />
<a href="http://mitpress.mit.edu/sicp/">http://mitpress.mit.edu/sicp/</a>
</li>

<li>Pure function<br />
<a href="http://en.wikipedia.org/wiki/Pure_function">http://en.wikipedia.org/wiki/Pure_function</a>
</li>

<li>Funkcionální programování<br />
<a href="http://cs.wikipedia.org/wiki/Funkcionální_programování">http://cs.wikipedia.org/wiki/Funkcionální_programování</a>
</li>

<li>Čistě funkcionální (datové struktury, jazyky, programování)<br />
<a href="http://cs.wikipedia.org/wiki/Čistě_funkcionální">http://cs.wikipedia.org/wiki/Čistě_funkcionální</a>
</li>

<li>Clojure Macro Tutorial (Part I, Getting the Compiler to Write Your Code For You)<br />
<a href="http://www.learningclojure.com/2010/09/clojure-macro-tutorial-part-i-getting.html">http://www.learningclojure.com/2010/09/clojure-macro-tutorial-part-i-getting.html</a>
</li>

<li>Clojure Macro Tutorial (Part II: The Compiler Strikes Back)<br />
<a href="http://www.learningclojure.com/2010/09/clojure-macro-tutorial-part-ii-compiler.html">http://www.learningclojure.com/2010/09/clojure-macro-tutorial-part-ii-compiler.html</a>
</li>

<li>Clojure Macro Tutorial (Part III: Syntax Quote)<br />
<a href="http://www.learningclojure.com/2010/09/clojure-macro-tutorial-part-ii-syntax.html">http://www.learningclojure.com/2010/09/clojure-macro-tutorial-part-ii-syntax.html</a>
</li>

<li>Tech behind Tech: Clojure Macros Simplified<br />
<a href="http://techbehindtech.com/2010/09/28/clojure-macros-simplified/">http://techbehindtech.com/2010/09/28/clojure-macros-simplified/</a>
</li>

<li>Fatvat - Exploring functional programming: Clojure Macros<br />
<a href="http://www.fatvat.co.uk/2009/02/clojure-macros.html">http://www.fatvat.co.uk/2009/02/clojure-macros.html</a>
</li>

<li>Eulerovo číslo<br />
<a href="http://cs.wikipedia.org/wiki/Eulerovo_číslo">http://cs.wikipedia.org/wiki/Eulerovo_číslo</a>
</li>

<li>List comprehension<br />
<a href="http://en.wikipedia.org/wiki/List_comprehension">http://en.wikipedia.org/wiki/List_comprehension</a>
</li>

<li>List Comprehensions in Clojure<br />
<a href="http://asymmetrical-view.com/2008/11/18/list-comprehensions-in-clojure.html">http://asymmetrical-view.com/2008/11/18/list-comprehensions-in-clojure.html</a>
</li>

<li>Clojure Programming Concepts: List Comprehension<br />
<a href="http://en.wikibooks.org/wiki/Clojure_Programming/Concepts#List_Comprehension">http://en.wikibooks.org/wiki/Clojure_Programming/Concepts#List_Comprehension</a>
</li>

<li>Clojure core API: for macro<br />
<a href="http://clojure.github.com/clojure/clojure.core-api.html#clojure.core/for">http://clojure.github.com/clojure/clojure.core-api.html#clojure.core/for</a>
</li>

<li>cirrus machina - The Clojure for macro<br />
<a href="http://www.cirrusmachina.com/blog/comment/the-clojure-for-macro/">http://www.cirrusmachina.com/blog/comment/the-clojure-for-macro/</a>
</li>

<li>Riastradh's Lisp Style Rules<br />
<a href="http://mumble.net/~campbell/scheme/style.txt">http://mumble.net/~campbell/scheme/style.txt</a>
</li>

<li>Dynamic Languages Strike Back<br />
<a href="http://steve-yegge.blogspot.cz/2008/05/dynamic-languages-strike-back.html">http://steve-yegge.blogspot.cz/2008/05/dynamic-languages-strike-back.html</a>
</li>

<li>Scripting: Higher Level Programming for the 21st Century<br />
<a href="http://www.tcl.tk/doc/scripting.html">http://www.tcl.tk/doc/scripting.html</a>
</li>

<li>Java Virtual Machine Support for Non-Java Languages<br />
<a href="http://docs.oracle.com/javase/7/docs/technotes/guides/vm/multiple-language-support.html">http://docs.oracle.com/javase/7/docs/technotes/guides/vm/multiple-language-support.html</a>
</li>

<li>Třída java.lang.String<br />
<a href="http://docs.oracle.com/javase/7/docs/api/java/lang/String.html">http://docs.oracle.com/javase/7/docs/api/java/lang/String.html</a>
</li>

<li>Třída java.lang.StringBuffer<br />
<a href="http://docs.oracle.com/javase/7/docs/api/java/lang/StringBuffer.html">http://docs.oracle.com/javase/7/docs/api/java/lang/StringBuffer.html</a>
</li>

<li>Třída java.lang.StringBuilder<br />
<a href="http://docs.oracle.com/javase/7/docs/api/java/lang/StringBuilder.html">http://docs.oracle.com/javase/7/docs/api/java/lang/StringBuilder.html</a>
</li>

<li>StringBuffer versus String<br />
<a href="http://www.javaworld.com/article/2076072/build-ci-sdlc/stringbuffer-versus-string.html">http://www.javaworld.com/article/2076072/build-ci-sdlc/stringbuffer-versus-string.html</a>
</li>

<li>Threading macro (dokumentace k&nbsp;jazyku Clojure)<br />
<a href="https://clojure.github.io/clojure/clojure.core-api.html#clojure.core/-&gt;">https://clojure.github.io/clojure/clojure.core-api.html#clojure.core/-&gt;</a>
</li>

<li>Understanding the Clojure -&gt; macro<br />
<a href="http://blog.fogus.me/2009/09/04/understanding-the-clojure-macro/">http://blog.fogus.me/2009/09/04/understanding-the-clojure-macro/</a>
</li>

<li>clojure.inspector<br />
<a href="http://clojure.github.io/clojure/clojure.inspector-api.html">http://clojure.github.io/clojure/clojure.inspector-api.html</a>
</li>

<li>The Clojure Toolbox<br />
<a href="http://www.clojure-toolbox.com/">http://www.clojure-toolbox.com/</a>
</li>

<li>Unit Testing in Clojure<br />
<a href="http://nakkaya.com/2009/11/18/unit-testing-in-clojure/">http://nakkaya.com/2009/11/18/unit-testing-in-clojure/</a>
</li>

<li>Testing in Clojure (Part-1: Unit testing)<br />
<a href="http://blog.knoldus.com/2014/03/22/testing-in-clojure-part-1-unit-testing/">http://blog.knoldus.com/2014/03/22/testing-in-clojure-part-1-unit-testing/</a>
</li>

<li>API for clojure.test - Clojure v1.6 (stable)<br />
<a href="https://clojure.github.io/clojure/clojure.test-api.html">https://clojure.github.io/clojure/clojure.test-api.html</a>
</li>

<li>Leiningen: úvodní stránka<br />
<a href="http://leiningen.org/">http://leiningen.org/</a>
</li>

<li>Leiningen: Git repository<br />
<a href="https://github.com/technomancy/leiningen">https://github.com/technomancy/leiningen</a>
</li>

<li>leiningen-win-installer<br />
<a href="http://leiningen-win-installer.djpowell.net/">http://leiningen-win-installer.djpowell.net/</a>
</li>

<li>Clojure  1: Úvod<br />
<a href="http://www.root.cz/clanky/clojure-aneb-jazyk-umoznujici-tvorbu-bezpecnych-vicevlaknovych-aplikaci-pro-jvm/">http://www.root.cz/clanky/clojure-aneb-jazyk-umoznujici-tvorbu-bezpecnych-vicevlaknovych-aplikaci-pro-jvm/</a>
</li>

<li>Clojure  2: Symboly, kolekce atd.<br />
<a href="http://www.root.cz/clanky/clojure-aneb-jazyk-umoznujici-tvorbu-bezpecnych-vicevlaknovych-aplikaci-pro-jvm-2-cast/">http://www.root.cz/clanky/clojure-aneb-jazyk-umoznujici-tvorbu-bezpecnych-vicevlaknovych-aplikaci-pro-jvm-2-cast/</a>
</li>

<li>Clojure  3: Funkcionální programování<br />
<a href="http://www.root.cz/clanky/clojure-aneb-jazyk-umoznujici-tvorbu-bezpecnych-vicevlaknovych-aplikaci-pro-jvm-3-cast-funkcionalni-programovani/">http://www.root.cz/clanky/clojure-aneb-jazyk-umoznujici-tvorbu-bezpecnych-vicevlaknovych-aplikaci-pro-jvm-3-cast-funkcionalni-programovani/</a>
</li>

<li>Clojure  4: Kolekce, sekvence a lazy sekvence<br />
<a href="http://www.root.cz/clanky/clojure-aneb-jazyk-umoznujici-tvorbu-bezpecnych-vicevlaknovych-aplikaci-pro-jvm-4-cast-kolekce-sekvence-a-lazy-sekvence/">http://www.root.cz/clanky/clojure-aneb-jazyk-umoznujici-tvorbu-bezpecnych-vicevlaknovych-aplikaci-pro-jvm-4-cast-kolekce-sekvence-a-lazy-sekvence/</a>
</li>

<li>Clojure  5: Sekvence, lazy sekvence a paralelní programy<br />
<a href="http://www.root.cz/clanky/clojure-a-bezpecne-aplikace-pro-jvm-sekvence-lazy-sekvence-a-paralelni-programy/">http://www.root.cz/clanky/clojure-a-bezpecne-aplikace-pro-jvm-sekvence-lazy-sekvence-a-paralelni-programy/</a>
</li>

<li>Clojure  6: Podpora pro paralelní programování<br />
<a href="http://www.root.cz/clanky/programovaci-jazyk-clojure-6-futures-nejsou-jen-financni-derivaty/">http://www.root.cz/clanky/programovaci-jazyk-clojure-6-futures-nejsou-jen-financni-derivaty/</a>
</li>

<li>Clojure  7: Další funkce pro paralelní programování<br />
<a href="http://www.root.cz/clanky/programovaci-jazyk-clojure-7-dalsi-podpurne-prostredky-pro-paralelni-programovani/">http://www.root.cz/clanky/programovaci-jazyk-clojure-7-dalsi-podpurne-prostredky-pro-paralelni-programovani/</a>
</li>

<li>Clojure  8: Identity, stavy, neměnné hodnoty a reference<br />
<a href="http://www.root.cz/clanky/programovaci-jazyk-clojure-8-identity-stavy-nemenne-hodnoty-a-referencni-typy/">http://www.root.cz/clanky/programovaci-jazyk-clojure-8-identity-stavy-nemenne-hodnoty-a-referencni-typy/</a>
</li>

<li>Clojure  9: Validátory, pozorovatelé a kooperace s Javou<br />
<a href="http://www.root.cz/clanky/programovaci-jazyk-clojure-9-validatory-pozorovatele-a-kooperace-mezi-clojure-a-javou/">http://www.root.cz/clanky/programovaci-jazyk-clojure-9-validatory-pozorovatele-a-kooperace-mezi-clojure-a-javou/</a>
</li>

<li>Clojure 10: Kooperace mezi Clojure a Javou<br />
<a href="http://www.root.cz/clanky/programovaci-jazyk-clojure-10-kooperace-mezi-clojure-a-javou-pokracovani/">http://www.root.cz/clanky/programovaci-jazyk-clojure-10-kooperace-mezi-clojure-a-javou-pokracovani/</a>
</li>

<li>Clojure 11: Generátorová notace seznamu/list comprehension<br />
<a href="http://www.root.cz/clanky/programovaci-jazyk-clojure-11-generatorova-notace-seznamu-list-comprehension/">http://www.root.cz/clanky/programovaci-jazyk-clojure-11-generatorova-notace-seznamu-list-comprehension/</a>
</li>

<li>Clojure 12: Překlad programů z Clojure do bajtkódu JVM I:<br />
<a href="http://www.root.cz/clanky/programovaci-jazyk-clojure-12-preklad-programu-z-clojure-do-bajtkodu-jvm/">http://www.root.cz/clanky/programovaci-jazyk-clojure-12-preklad-programu-z-clojure-do-bajtkodu-jvm/</a>
</li>

<li>Clojure 13: Překlad programů z Clojure do bajtkódu JVM II:<br />
<a href="http://www.root.cz/clanky/programovaci-jazyk-clojure-13-preklad-programu-z-clojure-do-bajtkodu-jvm-pokracovani/">http://www.root.cz/clanky/programovaci-jazyk-clojure-13-preklad-programu-z-clojure-do-bajtkodu-jvm-pokracovani/</a>
</li>

<li>Clojure 14: Základy práce se systémem maker<br />
<a href="http://www.root.cz/clanky/programovaci-jazyk-clojure-14-zaklady-prace-se-systemem-maker/">http://www.root.cz/clanky/programovaci-jazyk-clojure-14-zaklady-prace-se-systemem-maker/</a>
</li>

<li>Clojure 15: Tvorba uživatelských maker<br />
<a href="http://www.root.cz/clanky/programovaci-jazyk-clojure-15-tvorba-uzivatelskych-maker/">http://www.root.cz/clanky/programovaci-jazyk-clojure-15-tvorba-uzivatelskych-maker/</a>
</li>

<li>Clojure 16: Složitější uživatelská makra<br />
<a href="http://www.root.cz/clanky/programovaci-jazyk-clojure-16-slozitejsi-uzivatelska-makra/">http://www.root.cz/clanky/programovaci-jazyk-clojure-16-slozitejsi-uzivatelska-makra/</a>
</li>

<li>Clojure 17: Využití standardních maker v praxi<br />
<a href="http://www.root.cz/clanky/programovaci-jazyk-clojure-17-vyuziti-standardnich-maker-v-praxi/">http://www.root.cz/clanky/programovaci-jazyk-clojure-17-vyuziti-standardnich-maker-v-praxi/</a>
</li>

<li>Clojure 18: Základní techniky optimalizace aplikací<br />
<a href="http://www.root.cz/clanky/programovaci-jazyk-clojure-18-zakladni-techniky-optimalizace-aplikaci/">http://www.root.cz/clanky/programovaci-jazyk-clojure-18-zakladni-techniky-optimalizace-aplikaci/</a>
</li>

<li>Clojure 19: Vývojová prostředí pro Clojure<br />
<a href="http://www.root.cz/clanky/programovaci-jazyk-clojure-19-vyvojova-prostredi-pro-clojure/">http://www.root.cz/clanky/programovaci-jazyk-clojure-19-vyvojova-prostredi-pro-clojure/</a>
</li>

<li>Clojure 20: Vývojová prostředí pro Clojure (Vimu s REPL)<br />
<a href="http://www.root.cz/clanky/programovaci-jazyk-clojure-20-vyvojova-prostredi-pro-clojure-integrace-vimu-s-repl/">http://www.root.cz/clanky/programovaci-jazyk-clojure-20-vyvojova-prostredi-pro-clojure-integrace-vimu-s-repl/</a>
</li>

<li>Clojure 21: ClojureScript aneb překlad Clojure do JS<br />
<a href="http://www.root.cz/clanky/programovaci-jazyk-clojure-21-clojurescript-aneb-preklad-clojure-do-javascriptu/">http://www.root.cz/clanky/programovaci-jazyk-clojure-21-clojurescript-aneb-preklad-clojure-do-javascriptu/</a>
</li>

<li>Clojure.org: Vars and the Global Environment<br />
<a href="http://clojure.org/Vars">http://clojure.org/Vars</a>
</li>

<li>Clojure.org: Refs and Transactions<br />
<a href="http://clojure.org/Refs">http://clojure.org/Refs</a>
</li>

<li>Clojure.org: Atoms<br />
<a href="http://clojure.org/Atoms">http://clojure.org/Atoms</a>
</li>

<li>Clojure.org: Agents as Asynchronous Actions<br />
<a href="http://clojure.org/agents">http://clojure.org/agents</a>
</li>

<li>Transient Data Structures
<a href="http://clojure.org/transients">http://clojure.org/transients</a>
</li>

</ol>



<p></p><p></p>
<p><small>Autor: <a href="http://www.fit.vutbr.cz/~tisnovpa">Pavel Tišnovský</a> &nbsp; 2015</small></p>
</body>
</html>

