<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
        "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html>
<head>
<title>Funkce vyššího řádu v knihovně Underscore</title>
<meta name="Author" content="Pavel Tisnovsky" />
<meta name="Generator" content="vim" />
<meta http-equiv="content-type" content="text/html; charset=utf-8" />
<style type="text/css">
         body {color:#000000; background:#ffffff;}
         h1  {font-family: arial, helvetica, sans-serif; color:#ffffff; background-color:#c00000; text-align:center; padding-left:1em}
         h2  {font-family: arial, helvetica, sans-serif; color:#ffffff; background-color:#0000c0; padding-left:1em; text-align:left}
         h3  {font-family: arial, helvetica, sans-serif; color:#000000; background-color:#c0c0c0; padding-left:1em; text-align:left}
         h4  {font-family: arial, helvetica, sans-serif; color:#000000; background-color:#e0e0e0; padding-left:1em; text-align:left}
         a   {font-family: arial, helvetica, sans-serif;}
         li  {font-family: arial, helvetica, sans-serif; color:#000000; text-align:justify; width:450px;}
         ol  {font-family: arial, helvetica, sans-serif; color:#000000; text-align:justify; width:450px;}
         ul  {font-family: arial, helvetica, sans-serif; color:#000000; text-align:justify; width:450px;}
         p   {font-family: arial, helvetica, sans-serif; color:#000000; text-align:justify;}
         pre {background:#e0e0e0}
</style>
</head>

<body>

<h1>Funkce vyššího řádu v knihovně Underscore</h1>

<h3>Pavel Tišnovský</h3>

<p></p>

<h1>Úvodník</h1>

<p>Ve druhém článku o JavaScriptové knihovně Underscore se seznámíme s použitím funkcí vyššího řádu, která tato knihovna vývojářům nabízí. Jedná se především o funkce map, filter, reject, some, every, partition, reduce a reduceRight, díky nimž lze mnoho algoritmů zjednodušit a zkrátit.</p>



<h2>Obsah</h2>

<p><a href="#k01">1. Funkce vyššího řádu v&nbsp;knihovně Underscore</a></p>
<p><a href="#k02">2. Funkce <strong>map</strong> a její význam při práci s&nbsp;kolekcemi</a></p>
<p><a href="#k03">3. První demonstrační příklad &ndash; použití funkce <strong>map</strong> při práci s&nbsp;poli či kolekcemi</a></p>
<p><a href="#k04">4. Výběr prvků z&nbsp;kolekcí pomocí funkcí <strong>filter</strong> a <strong>reject</strong></a></p>
<p><a href="#k05">5. Druhý demonstrační příklad &ndash; použití funkcí <strong>filter</strong> a <strong>reject</strong></a></p>
<p><a href="#k06">6. Rozhodování na základě stavu kolekcí zjištěných funkcemi <strong>some</strong> a <strong>every</strong></a></p>
<p><a href="#k07">7. Třetí demonstrační příklad &ndash; použití funkcí <strong>some</strong> a <strong>every</strong></a></p>
<p><a href="#k08">8. Kombinace chování <strong>filter</strong> a <strong>reject</strong>: funkce <strong>partition</strong></a></p>
<p><a href="#k09">9. Čtvrtý demonstrační příklad &ndash; použití funkce <strong>partition</strong></a></p>
<p><a href="#k10">10. Funkce <strong>reduce</strong> a <strong>reduceRight</strong></a></p>
<p><a href="#k11">11. Pátý demonstrační příklad &ndash; použití funkcí <strong>reduce</strong> a <strong>reduceRight</strong></a></p>
<p><a href="#k12">12. Výpočet faktoriálu s&nbsp;použitím funkce <strong>reduce</strong></a></p>
<p><a href="#k13">13. Šestý demonstrační příklad &ndash; funkce <strong>each</strong> a <strong>reduce</strong> při výpočtu faktoriálu</a></p>
<p><a href="#k14">14. Repositář s&nbsp;demonstračními příklady</a></p>
<p><a href="#k15">15. Odkazy na Internetu</a></p>



<p><a name="k01"></a></p>
<h2 id="k01">1. Funkce vyššího řádu v&nbsp;knihovně Underscore</h2>

<p>Ve druhé části článku o knihovně <i>Underscore</i>, která přináší do
JavaScriptu některé prvky funkcionálního programování, si na šestici
demonstračních příkladů ukážeme použití takzvaných funkcí vyššího řádu, což
jsou v&nbsp;tomto případě funkce, která jako jeden ze svých parametrů akceptují
jiné funkce (ať již pojmenované či anonymní). Jedná se konkrétně o funkce
určené pro práci s&nbsp;poli a obecnými kolekcemi. V&nbsp;knihovně
<i>Underscore</i> nalezneme základní trojici funkcí známých z&nbsp;prakticky
všech funkcionálních jazyků: <strong>map</strong>, <strong>filter</strong>,
<strong>reduce</strong> (i když někdy mívají tyto funkce odlišné názvy). Ovšem
najdeme zde taktéž různé další varianty, například funkce
<strong>reject</strong> (varianta na <strong>filter</strong>),
<strong>reduceRight</strong> (varianta pro <strong>reduce</strong>) a taktéž
<strong>some</strong>, <strong>every</strong> a <strong>partition</strong>.</p>

<p>Díky existenci těchto funkcí je možné ve vytvářených aplikacích do značné
míry při zpracování polí a obecných kolekcí eliminovat programové smyčky, které
mohou do programů zanášet zbytečné chyby (a to zejména v&nbsp;JavaScriptu
s&nbsp;jeho poněkud zvláštní implementací smyčky typu for-each).</p>



<p><a name="k02"></a></p>
<h2 id="k02">2. Funkce <strong>map</strong> a její význam při práci s&nbsp;kolekcemi</h2>

<p>Pravděpodobně nejdůležitější a současně i velmi snadno pochopitelnou funkcí
určenou pro zpracování kolekcí &bdquo;funkcionálním&ldquo; způsobem je funkce
nazvaná <strong>map</strong>. Tato funkce zpracovává všechny prvky vstupní
kolekce (což budou většinou prvky běžného pole) a vytváří výslednou kolekci
(většinou opět pole). Důležité je, že původní kolekce zůstane nezměněna. Funkce
<strong>map</strong> při konstrukci výsledné kolekce zavolá pro každý prvek
vstupní kolekce uživatelem specifikovanou funkci, jejíž návratový kód následně
použije. Funkce <strong>map</strong> tedy potřebuje dva údaje: vstupní kolekci
(pole) a funkci, kterou má na jednotlivé prvky této kolekce aplikovat. Tato
funkce může být anonymní či neanonymní (pojmenovaná).</p>

<p>Ostatně se podívejme na jednoduchý příklad. Vytvoříme naprosto běžnou
pojmenovanou (neanonymní) funkci akceptující nějaké číslo a vracející jeho
dvojnásobnou hodnotu:</p>

<pre>
<i>// bezna neanonymni (pojmenovana) funkce pouzita v map()</i>
<strong>function</strong> doubleValue(value)
{
    return value*2;
}
</pre>

<p>Dále si necháme vygenerovat pole obsahující prvky 1 až 10. Použijeme přitom
funkci <strong>range</strong>, s&nbsp;níž jsme se již seznámili <a
href="http://www.root.cz/clanky/underscore-aneb-dalsi-knihovna-pro-funkcionalni-programovani-v-javascriptu/#k06">minule</a>:</p>

<pre>
<i>// pole s prvky 1..10</i>
<strong>var</strong> array1 = _.range(1, 11);
1,2,3,4,5,6,7,8,9,10
</pre>

<p>S&nbsp;použitím funkce <strong>map</strong> nyní vytvoříme <i>nové pole</i>,
které bude mít deset prvků, jako pole původní, ale hodnoty těchto prvků budou
mít oproti původním prvkům dvojnásobnou hodnotu:</p>

<pre>
<i>// vytvorime nove pole se sudymi cisly</i>
<strong>var</strong> array2 = _.map(array1, doubleValue);
2,4,6,8,10,12,14,16,18,20
</pre>

<p>V&nbsp;dalším příkladu použijeme anonymní funkci, která se přímo zapíše do
volání funkce <strong>map</strong>. Na první pohled to sice může vypadat
poněkud nečitelně, ovšem tento způsob je vhodné si osvojit, protože je mnohdy
užitečný a elegantní:</p>

<pre>
<i>// alternativni zpusob vytvorime nove pole s prevracenymi hodnotami</i>
<i>// a to s pouzitim anonymni funkce</i>
<strong>var</strong> array3 = _.map(array1, <strong>function</strong>(value) {return 1.0/value;});
1,0.5,0.3333333333333333,0.25,0.2,0.16666666666666666,0.14285714285714285,0.125,0.1111111111111111,0.1
</pre>

<p>Podívejme se nyní na použití již existujících metod základních objektů,
které jsou v&nbsp;implementacích jazyka JavaScript dostupné. Nejprve vytvoříme
pole s&nbsp;řetězci:</p>

<pre>
<i>// priklad pouziti metod objektu String</i>
<i>// puvodni pole</i>
<strong>var</strong> names = ["Perl", "Python", "Java", "JavaScript", "C", "C++", "Lua", "Clojure", "Forth", "APL", "BASIC"];
</pre>

<p>Všechna jména převedeme na verzálky s&nbsp;využitím kombinace
<strong>map</strong> a <strong>String.toUpperCase</strong></p>

<pre>
<i>// pole obsahujici retezce psane verzalkami</i>
<strong>var</strong> upperCaseNames = _.map(names, String.toUpperCase);
</pre>

<p>Zcela stejným způsobem si tato jména převedeme na mínusky s&nbsp;využitím
kombinace <strong>map</strong> a <strong>String.toLowerCase</strong></p>

<pre>
<i>// pole obsahujici retezce psane minuskami</i>
<strong>var</strong> lowerCaseNames = _.map(names, String.toLowerCase);
</pre>



<p><a name="k03"></a></p>
<h2 id="k03">3. První demonstrační příklad &ndash; použití funkce <strong>map</strong> při práci s&nbsp;poli či kolekcemi</h2>

<p>Funkce <strong>map</strong> popsaná <a href="#k02">v&nbsp;předchozí
kapitole</a> je použita v&nbsp;dnešním prvním demonstračním příkladu, jehož
úplný zdrojový kód lze nalézt na adrese <a
href="https://github.com/tisnik/presentations/blob/master/underscore/underscore_06.js">https://github.com/tisnik/presentations/blob/master/underscore/underscore_06.js</a>.
Povšimněte si, že se funkci <strong>map</strong> skutečně dají předat běžné
(pojmenované) funkce, anonymní funkce i &bdquo;metody&ldquo; již existujících
objektů:</p>

<pre>
<i>// ------------------------------------------------------------</i>
<i>// Knihovna Underscore.js: demonstracni priklad cislo 6</i>
<i>//                         Pouziti funkce map() pri praci s poli</i>
<i>//                         ci s kolekcemi.</i>
<i>// ------------------------------------------------------------</i>
&nbsp;
&nbsp;
&nbsp;
<i>// funkce pro vypis informaci o vybranem poli (ci o jinem objektu)</i>
<strong>function</strong> printArrayInfo(expression) {
    <strong>var</strong> anArray = eval(expression);
    console.log("---------------------------------");
    console.log(expression);
&nbsp;
    <i>// zjisteni typu objektu (a pripadne delky pole)</i>
    <strong>if</strong> (anArray instanceof Array) {
        console.log("type:    array");
        console.log("length:  " + anArray.length);
    }
    <i>// jiny typ objektu, nemame zde jistotu, ze existuje atribut length</i>
    <strong>else</strong> {
        console.log("type:    " + typeof anArray);
    }
    console.log("content: " + anArray);
}
&nbsp;
&nbsp;
&nbsp;
<i>// bezna neanonymni (pojmenovana) funkce pouzita v map()</i>
<strong>function</strong> doubleValue(value)
{
    return value*2;
}
&nbsp;
&nbsp;
&nbsp;
<i>// pole s prvky 1..10</i>
<strong>var</strong> array1 = _.range(1, 11);
&nbsp;
<i>// vytvorime nove pole se sudymi cisly</i>
<strong>var</strong> array2 = _.map(array1, doubleValue);
&nbsp;
<i>// alternativni zpusob vytvorime nove pole s prevracenymi hodnotami</i>
<i>// a to s pouzitim anonymni funkce</i>
<strong>var</strong> array3 = _.map(array1, <strong>function</strong>(value) {return 1.0/value;});
&nbsp;
<i>// vypis informaci o vsech trech polich</i>
printArrayInfo("array1");
printArrayInfo("array2");
printArrayInfo("array3");
&nbsp;
&nbsp;
&nbsp;
<i>// pouziti metody objektu Math</i>
<strong>var</strong> array4 = _.map(array1, Math.sqrt);
printArrayInfo("array4");
&nbsp;
&nbsp;
&nbsp;
<i>// priklad pouziti metod objektu String</i>
<i>// puvodni pole</i>
<strong>var</strong> names = ["Perl", "Python", "Java", "JavaScript", "C", "C++", "Lua", "Clojure", "Forth", "APL", "BASIC"];
&nbsp;
<i>// pole obsahujici retezce psane verzalkami</i>
<strong>var</strong> upperCaseNames = _.map(names, String.toUpperCase);
&nbsp;
<i>// pole obsahujici retezce psane minuskami</i>
<strong>var</strong> lowerCaseNames = _.map(names, String.toLowerCase);
&nbsp;
<i>// vypis informaci o vsech trech polich s retezci</i>
printArrayInfo("names");
printArrayInfo("upperCaseNames");
printArrayInfo("lowerCaseNames");
&nbsp;
&nbsp;
&nbsp;
<i>// ------------------------------------------------------------</i>
<i>// Finito</i>
<i>// ------------------------------------------------------------</i>
</pre>

<p>Výstup generovaný příkladem na konzoli:</p>

<pre>
---------------------------------
array1
type:    array
length:  10
content: 1,2,3,4,5,6,7,8,9,10
---------------------------------
array2
type:    array
length:  10
content: 2,4,6,8,10,12,14,16,18,20
---------------------------------
array3
type:    array
length:  10
content: 1,0.5,0.3333333333333333,0.25,0.2,0.16666666666666666,0.14285714285714285,0.125,0.1111111111111111,0.1
---------------------------------
array4
type:    array
length:  10
content: 1,1.4142135623730951,1.7320508075688772,2,2.23606797749979,2.449489742783178,2.6457513110645907,2.8284271247461903,3,3.1622776601683795
---------------------------------
names
type:    array
length:  11
content: Perl,Python,Java,JavaScript,C,C++,Lua,Clojure,Forth,APL,BASIC
---------------------------------
upperCaseNames
type:    array
length:  11
content: PERL,PYTHON,JAVA,JAVASCRIPT,C,C++,LUA,CLOJURE,FORTH,APL,BASIC
---------------------------------
lowerCaseNames
type:    array
length:  11
content: perl,python,java,javascript,c,c++,lua,clojure,forth,apl,basic
</pre>



<p><a name="k04"></a></p>
<h2 id="k04">4. Výběr prvků z&nbsp;kolekcí pomocí funkcí <strong>filter</strong> a <strong>reject</strong></h2>

<p>V&nbsp;mnoha algoritmech je nutné vybrat prvky z&nbsp;nějaké kolekce na
základě zadaných kritérií. Pro tento účel lze v&nbsp;knihovně <i>Underscore</i>
použít funkce <strong>filter</strong> a <strong>reject</strong>. Tyto funkce
akceptují stejné parametry jako funkce <strong>map</strong>: kolekci (pole) a
uživatelem specifikovanou funkci. Ta má ovšem jiný význam, protože se na
základě její návratové hodnoty (true či false) rozhoduje, zda se má daný prvek
ze vstupní kolekce zkopírovat do kolekce výsledné či nikoli (obecně je tedy
výsledná kolekce menší než kolekce vstupní).</p>

<p>Opět se podívejme na příklad. Vytvořme funkci-predikát, která vrací hodnotu
true či false na základě testu na sudé číslo:</p>

<pre>
<i>// bezna neanonymni (pojmenovana) funkce pouzita ve filter() a reject()</i>
<strong>function</strong> isEven(value)
{
    return value % 2 == 0;
}
</pre>

<p>Nyní získáme všechny sudé prvky, a to pomocí <strong>filter</strong>:</p>

<pre>
<i>// vytvorime nove pole jen se sudymi cisly</i>
<strong>var</strong> array2 = _.filter(array1, isEven);
2,4,6,8,10
</pre>

<p>Všechny liché prvky se získají funkcí <strong>reject</strong>, která tak
tvoří opak k&nbsp;funkci <strong>filter</strong> (v&nbsp;praxi nám to ušetří
tvorbu predikátů s&nbsp;logickou negací):</p>

<pre>
<i>// vytvorime nove pole jen s lichymi cisly</i>
<strong>var</strong> array3 = _.reject(array1, isEven);
1,3,5,7,9
</pre>

<p>Podobně můžeme použít anonymní funkce pro získání prvků menších
popř.&nbsp;větších než zadaný limit:</p>

<pre>
<i>// alternativni zpusob s vyuzitim anonymnich funkci pro ziskani</i>
<i>// pole cisel mensich nez 6 resp. vetsich nez 5</i>
<strong>var</strong> array4 = _.filter(array1, <strong>function</strong>(value) {return value &lt;= 5;});
1,2,3,4,5
<strong>var</strong> array5 = _.reject(array1, <strong>function</strong>(value) {return value &lt;= 5;});
6,7,8,9,10
</pre>



<p><a name="k05"></a></p>
<h2 id="k05">5. Druhý demonstrační příklad &ndash; použití funkcí <strong>filter</strong> a <strong>reject</strong></h2>

<p>Použití <a href="#k04">výše popsaných</a> funkcí nazvaných
<strong>filter</strong> a <strong>reject</strong> si ukážeme v&nbsp;dnešním
druhém demonstračním příkladu, jehož <a
href="https://github.com/tisnik/presentations/blob/master/underscore/underscore_07.js">úplný
zdrojový kód</a> je vypsán pod tímto odstavcem. Těmto dvěma funkcím vyššího
řádu předáváme jak anonymní funkce, tak i funkce neanonymní (pojmenované).
Kterou variantu programátor v&nbsp;tomto případě zvolí, záleží čistě na řešené
problematice (ve skutečnosti by pravděpodobně bylo jednodušší funkci
<strong>isEven</strong> nepojmenovávat):</p>

<pre>
<i>// ------------------------------------------------------------</i>
<i>// Knihovna Underscore.js: demonstracni priklad cislo 7</i>
<i>//                         Pouziti funkci filter() a reject()</i>
<i>//                         pri praci s poli ci s kolekcemi.</i>
<i>// ------------------------------------------------------------</i>
&nbsp;
&nbsp;
&nbsp;
<i>// funkce pro vypis informaci o vybranem poli (ci o jinem objektu)</i>
<strong>function</strong> printArrayInfo(expression) {
    <strong>var</strong> anArray = eval(expression);
    console.log("---------------------------------");
    console.log(expression);
&nbsp;
    <i>// zjisteni typu objektu (a pripadne delky pole)</i>
    <strong>if</strong> (anArray instanceof Array) {
        console.log("type:    array");
        console.log("length:  " + anArray.length);
    }
    <i>// jiny typ objektu, nemame zde jistotu, ze existuje atribut length</i>
    <strong>else</strong> {
        console.log("type:    " + typeof anArray);
    }
    console.log("content: " + anArray);
}
&nbsp;
&nbsp;
&nbsp;
<i>// bezna neanonymni (pojmenovana) funkce pouzita ve filter() a reject()</i>
<strong>function</strong> isEven(value)
{
    return value % 2 == 0;
}
&nbsp;
&nbsp;
&nbsp;
<i>// pole s prvky 1..10</i>
<strong>var</strong> array1 = _.range(1, 11);
&nbsp;
<i>// vytvorime nove pole jen se sudymi cisly</i>
<strong>var</strong> array2 = _.filter(array1, isEven);
<i>// vytvorime nove pole jen s lichymi cisly</i>
<strong>var</strong> array3 = _.reject(array1, isEven);
&nbsp;
<i>// vypis informaci o vsech trech polich</i>
printArrayInfo("array1");
printArrayInfo("array2");
printArrayInfo("array3");
&nbsp;
<i>// alternativni zpusob s vyuzitim anonymnich funkci pro ziskani</i>
<i>// pole cisel mensich nez 6 resp. vetsich nez 5</i>
<strong>var</strong> array4 = _.filter(array1, <strong>function</strong>(value) {return value &lt;= 5;});
<strong>var</strong> array5 = _.reject(array1, <strong>function</strong>(value) {return value &lt;= 5;});
&nbsp;
printArrayInfo("array4");
printArrayInfo("array5");
&nbsp;
&nbsp;
&nbsp;
<i>// priklad s polem retezcu</i>
<i>// puvodni pole</i>
<strong>var</strong> names = ["Perl", "Python", "Java", "JavaScript", "C", "C++", "Lua", "Clojure", "Forth", "APL", "BASIC"];
&nbsp;
<i>// pole obsahujici retezce psane verzalkami</i>
<strong>var</strong> shortNames = _.filter(names, <strong>function</strong>(str) {return str.length &lt;= 4;});
&nbsp;
<i>// pole obsahujici retezce psane minuskami</i>
<strong>var</strong> longNames  = _.reject(names, <strong>function</strong>(str) {return str.length &lt;= 4;});
&nbsp;
<i>// vypis informaci o vsech trech polich s retezci</i>
printArrayInfo("names");
printArrayInfo("shortNames");
printArrayInfo("longNames");
&nbsp;
&nbsp;
&nbsp;
<i>// ------------------------------------------------------------</i>
<i>// Finito</i>
<i>// ------------------------------------------------------------</i>
</pre>

<p>Výstup generovaný příkladem na konzoli:</p>

<pre>
---------------------------------
array1
type:    array
length:  10
content: 1,2,3,4,5,6,7,8,9,10
---------------------------------
array2
type:    array
length:  5
content: 2,4,6,8,10
---------------------------------
array3
type:    array
length:  5
content: 1,3,5,7,9
---------------------------------
array4
type:    array
length:  5
content: 1,2,3,4,5
---------------------------------
array5
type:    array
length:  5
content: 6,7,8,9,10
---------------------------------
names
type:    array
length:  11
content: Perl,Python,Java,JavaScript,C,C++,Lua,Clojure,Forth,APL,BASIC
---------------------------------
shortNames
type:    array
length:  6
content: Perl,Java,C,C++,Lua,APL
---------------------------------
longNames
type:    array
length:  5
content: Python,JavaScript,Clojure,Forth,BASIC
</pre>



<p><a name="k06"></a></p>
<h2 id="k06">6. Rozhodování na základě stavu kolekcí zjištěných funkcemi <strong>some</strong> a <strong>every</strong></h2>

<p>V&nbsp;případě, že potřebujeme zjistit, zda všechny prvky kolekcí splňují
nějakou podmínku (zapsanou samozřejmě opět s&nbsp;využitím libovolné
uživatelské či systémové funkce vracející pravdivostní hodnotu), můžeme použít
funkci vyššího řádu nazvanou <strong>every</strong>. Tato funkce postupně
prochází jednotlivé prvky kolekce či pole a pro každý prvek zavolá zadanou
funkci, stejně jako tomu bylo u již popsaných funkcí <strong>filter</strong> a
<strong>reject</strong>. Jakmile se nalezne prvek, pro něhož funkce vrací
<strong>False</strong>, vrátí <strong>every</strong> taktéž
<strong>False</strong> (a to ihned po prvním takovém prvku, neprochází se
zbytek kolekce, neboť už je to zbytečné). Pokud se projdou všechny prvky, vrátí
se hodnota <strong>True</strong>. Jestliže tedy chcete zjistit, zda jsou
všechny prvky pole sudé, stačí použít:</p>

<pre>
<i>// test zda pole obsahuje jen suda cisla</i>
_.every(anArray, isEven);
</pre>

<p>Někdy potřebujeme zjistit, zda alespoň jeden prvek splňuje nějakou podmínku
(tedy nikoli všechny prvky). Knihovna <i>Underscore</i> samozřejmě myslí i na
tento případ a nabízí programátorům funkci nazvanou <strong>some</strong>.
Způsob volání je shodný s&nbsp;funkcí <strong>every</strong>, ovšem chování se
odlišuje &ndash; pokud uživatelem specifikovaná funkce (predikát) vrátí pro
nějaký prvek pravdivostní hodnotu <strong>True</strong>, je hledání ihned
ukončeno a taktéž se vrátí <strong>True</strong>. Jestliže se žádný vhodný
prvek nenalezne, nezbude této funkci nic jiného, než vrátit
<strong>False</strong>. Test na existenci alespoň jednoho sudého čísla
v&nbsp;poli vypadá takto:</p>

<pre>
<i>// test zda pole obsahuje alespon jedno sude cislo</i>
_.some(anArray, isEven);
</pre>



<p><a name="k07"></a></p>
<h2 id="k07">7. Třetí demonstrační příklad &ndash; použití funkcí <strong>some</strong> a <strong>every</strong></h2>

<p>Chování funkcí <strong>every</strong> a <strong>some</strong> je poměrně
snadno pochopitelné, proto se již bez dalšího podrobnějšího vysvětlování
podívejme na <a
href="https://github.com/tisnik/presentations/blob/master/underscore/underscore_08.js">zdrojový
kód</a> dnešního třetího demonstračního příkladu, kde jsou tyto dvě funkce
vyššího řádu použity pro zjištění informací o třech polích. Samotná pole jsou
taktéž vytvořena funkcemi vyššího řádu knihovny <i>Underscore</i>, alespoň je
patrné, jak se jednotlivé části této knihovny mohou vzájemně doplňovat:</p>

<pre>
<i>// ------------------------------------------------------------</i>
<i>// Knihovna Underscore.js: demonstracni priklad cislo 8</i>
<i>//                         Pouziti funkci some() a every()</i>
<i>//                         pri praci s poli ci s kolekcemi.</i>
<i>// ------------------------------------------------------------</i>
&nbsp;
&nbsp;
&nbsp;
<i>// funkce pro vypis informaci o vybranem poli (ci o jinem objektu)</i>
<strong>function</strong> printArrayInfo(expression) {
    <strong>var</strong> anArray = eval(expression);
    console.log("---------------------------------");
    console.log(expression);
&nbsp;
    <i>// zjisteni typu objektu (a pripadne delky pole)</i>
    <strong>if</strong> (anArray instanceof Array) {
        console.log("type:    array");
        console.log("length:  " + anArray.length);
    }
    <i>// jiny typ objektu, nemame zde jistotu, ze existuje atribut length</i>
    <strong>else</strong> {
        console.log("type:    " + typeof anArray);
    }
    console.log("content: " + anArray);
}
&nbsp;
&nbsp;
&nbsp;
<i>// bezna neanonymni (pojmenovana) funkce pouzita ve filter() a reject()</i>
<strong>function</strong> isEven(value)
{
    return value % 2 == 0;
}
&nbsp;
&nbsp;
&nbsp;
<i>// pole s prvky 1..10</i>
<strong>var</strong> array1 = _.range(1, 11);
&nbsp;
<i>// vytvorime nove pole jen se sudymi cisly</i>
<strong>var</strong> array2 = _.filter(array1, isEven);
&nbsp;
<i>// vytvorime nove pole jen s lichymi cisly</i>
<strong>var</strong> array3 = _.reject(array1, isEven);
&nbsp;
<i>// vypis informaci o vsech trech polich</i>
printArrayInfo("array1");
printArrayInfo("array2");
printArrayInfo("array3");
&nbsp;
&nbsp;
&nbsp;
<i>// test zda pole obsahuje jen suda cisla</i>
<strong>function</strong> containsOnlyEvenValues(anArray)
{
    return _.every(anArray, isEven);
}
&nbsp;
<i>// test zda pole obsahuje alespon jedno sude cislo</i>
<strong>function</strong> containsEvenValue(anArray)
{
    return _.some(anArray, isEven);
}
&nbsp;
console.log("---------------------------------");
&nbsp;
console.log("array1 contains only even values: " + containsOnlyEvenValues(array1));
console.log("array2 contains only even values: " + containsOnlyEvenValues(array2));
console.log("array3 contains only even values: " + containsOnlyEvenValues(array3));
&nbsp;
console.log("---------------------------------");
&nbsp;
console.log("array1 contains at least one even value: " + containsEvenValue(array1));
console.log("array2 contains at least one even value: " + containsEvenValue(array2));
console.log("array3 contains at least one even value: " + containsEvenValue(array3));
&nbsp;
&nbsp;
&nbsp;
<i>// ------------------------------------------------------------</i>
<i>// Finito</i>
<i>// ------------------------------------------------------------</i>
</pre>

<p>Výstup generovaný příkladem na konzoli:</p>

<pre>
---------------------------------
array1
type:    array
length:  10
content: 1,2,3,4,5,6,7,8,9,10
---------------------------------
array2
type:    array
length:  5
content: 2,4,6,8,10
---------------------------------
array3
type:    array
length:  5
content: 1,3,5,7,9
---------------------------------
array1 contains only even values: false
array2 contains only even values: true
array3 contains only even values: false
---------------------------------
array1 contains at least one even value: true
array2 contains at least one even value: true
array3 contains at least one even value: false
</pre>



<p><a name="k08"></a></p>
<h2 id="k08">8. Kombinace chování <strong>filter</strong> a <strong>reject</strong>: funkce <strong>partition</strong></h2>

<p>V&nbsp;předchozím demonstračním příkladu jste si možná všimli této dvojice
řádků:</p>

<pre>
<i>// vytvorime nove pole jen se sudymi cisly</i>
<strong>var</strong> array2 = _.filter(array1, isEven);
&nbsp;
<i>// vytvorime nove pole jen s lichymi cisly</i>
<strong>var</strong> array3 = _.reject(array1, isEven);
</pre>

<p>V&nbsp;těchto programových řádcích se původní pole (či kolekce) rozděluje na
dvě obecně nestejně velké části na základě predikátu <strong>isEven</strong>
volaného pro každý prvek původního pole. Tento způsob rozdělování je pro
některé algoritmy typický (rozdělení žáků na propadlíky a ty ostatní apod.), a
proto se v&nbsp;knihovně <i>Underscore</i> můžeme setkat s&nbsp;další užitečnou
funkcí nazvanou příznačně <strong>partition</strong>, která původní
pole/kolekci rozdělí podle predikátu. Návratovou hodnotou je pole obsahující
pouze dva prvky: první část původní kolekce a druhou část (typicky se jedná o
2D pole). Podívejme se na jednoduchý příklad, z&nbsp;něhož bude chování této
funkce zřejmé:</p>

<pre>
<i>// pole s prvky 1..10</i>
<strong>var</strong> array1 = _.range(1, 11);
</pre>

<pre>
<i>// rozdelime pole na zaklade podminky</i>
<strong>var</strong> partitioned = _.partition(array1, isEven);
</pre>

<pre>
<i>// vytvorime nove pole jen se sudymi cisly</i>
<strong>var</strong> array2 = partitioned[0];
</pre>

<pre>
<i>// vytvorime nove pole jen s lichymi cisly</i>
<strong>var</strong> array3 = partitioned[1];
</pre>



<p><a name="k09"></a></p>
<h2 id="k09">9. Čtvrtý demonstrační příklad &ndash; použití funkce <strong>partition</strong></h2>

<p>V&nbsp;dnešním čtvrtém demonstračním příkladu se <a href="#k08">výše
popsaná</a> funkce <strong>partition</strong> použije nejprve k&nbsp;rozdělení
pole s&nbsp;prvky 1..10 na ty prvky, které jsou sudé, a dále na prvky, které
jsou naopak liché (původní pole se ovšem nijak nezmění; navíc jsem pro jistotu
nepřidal problematickou nulu :-). Zajímavější je druhá část příkladu,
v&nbsp;níž se rozdělí pole obsahující názvy některých programovacích jazyků na
jazyky s&nbsp;krátkými názvy (méně než pět znaků) a samozřejmě na zbytek,
tj.&nbsp;na jazyky, jejichž názvy jsou dlouhé pět či více znaků. Podívejme se
na <a
href="https://github.com/tisnik/presentations/blob/master/underscore/underscore_09.js">úplný
zdrojový</a> kód tohoto příkladu, který ve skutečnosti není příliš
komplikovaný:</p>

<pre>
<i>// ------------------------------------------------------------</i>
<i>// Knihovna Underscore.js: demonstracni priklad cislo 9</i>
<i>//                         Pouziti funkce partition()</i>
<i>//                         pri praci s poli ci s kolekcemi.</i>
<i>// ------------------------------------------------------------</i>
&nbsp;
&nbsp;
&nbsp;
<i>// funkce pro vypis informaci o vybranem poli (ci o jinem objektu)</i>
<strong>function</strong> printArrayInfo(expression) {
    <strong>var</strong> anArray = eval(expression);
    console.log("---------------------------------");
    console.log(expression);
&nbsp;
    <i>// zjisteni typu objektu (a pripadne delky pole)</i>
    <strong>if</strong> (anArray instanceof Array) {
        console.log("type:    array");
        console.log("length:  " + anArray.length);
    }
    <i>// jiny typ objektu, nemame zde jistotu, ze existuje atribut length</i>
    <strong>else</strong> {
        console.log("type:    " + typeof anArray);
    }
    console.log("content: " + anArray);
}
&nbsp;
&nbsp;
&nbsp;
<i>// bezna neanonymni (pojmenovana) funkce pouzita ve filter() a reject()</i>
<strong>function</strong> isEven(value)
{
    return value % 2 == 0;
}
&nbsp;
&nbsp;
&nbsp;
<i>// pole s prvky 1..10</i>
<strong>var</strong> array1 = _.range(1, 11);
&nbsp;
<i>// rozdelime pole na zaklade podminky</i>
<strong>var</strong> partitioned = _.partition(array1, isEven);
&nbsp;
<i>// vytvorime nove pole jen se sudymi cisly</i>
<strong>var</strong> array2 = partitioned[0];
&nbsp;
<i>// vytvorime nove pole jen s lichymi cisly</i>
<strong>var</strong> array3 = partitioned[1];
&nbsp;
<i>// vypis informaci o vsech trech polich</i>
printArrayInfo("array1");
printArrayInfo("array2");
printArrayInfo("array3");
&nbsp;
&nbsp;
&nbsp;
<i>// priklad s rozdelenim pole retezcu</i>
<strong>var</strong> names = ["Perl", "Python", "Java", "JavaScript", "C", "C++", "Lua", "Clojure", "Forth", "APL", "BASIC"];
&nbsp;
<i>// rozdeleni pole retezcu podle toho, jak jsou jednotlive retezce dlouhe</i>
<strong>var</strong> longAndShortNames = _.partition(names, <strong>function</strong>(str) {return str.length &lt;= 4;});
&nbsp;
<i>// pro lepsi citelnost vytvorime samostatne pole kratkych</i>
<i>// a samostatne pole dlouhych retezcu</i>
<strong>var</strong> shortNames = longAndShortNames[0];
<strong>var</strong> longNames = longAndShortNames[1];
&nbsp;
<i>// vypis informaci o vsech trech polich s retezci</i>
printArrayInfo("names");
printArrayInfo("shortNames");
printArrayInfo("longNames");
&nbsp;
&nbsp;
&nbsp;
<i>// ------------------------------------------------------------</i>
<i>// Finito</i>
<i>// ------------------------------------------------------------</i>
</pre>

<p>Výstup generovaný příkladem na konzoli:</p>

<pre>
---------------------------------
array1
type:    array
length:  10
content: 1,2,3,4,5,6,7,8,9,10
---------------------------------
array2
type:    array
length:  5
content: 2,4,6,8,10
---------------------------------
array3
type:    array
length:  5
content: 1,3,5,7,9
---------------------------------
names
type:    array
length:  11
content: Perl,Python,Java,JavaScript,C,C++,Lua,Clojure,Forth,APL,BASIC
---------------------------------
shortNames
type:    array
length:  6
content: Perl,Java,C,C++,Lua,APL
---------------------------------
longNames
type:    array
length:  5
content: Python,JavaScript,Clojure,Forth,BASIC
</pre>



<p><a name="k10"></a></p>
<h2 id="k10">10. Funkce <strong>reduce</strong> a <strong>reduceRight</strong></h2>

<p>Posledními dvěma funkcemi vyššího řádu, které nesmějí chybět
v&nbsp;repertoáru žádné funkcionálně zaměřené knihovny, je dvojice funkcí
pojmenovaná <strong>reduce</strong> a <strong>reduceRight</strong> (někdy se
setkáme s&nbsp;názvy <strong>foldl</strong> a <strong>foldr</strong> atd.).
Názvy těchto funkcí naznačují jejich účel &ndash; dochází k&nbsp;postupné
redukci prvků uložených v&nbsp;kolekci či v&nbsp;poli, a to (postupnou)
aplikací zvolené uživatelské funkce na jednotlivé prvky a po krocích počítaný
mezivýsledek. Mezi <strong>reduce</strong> a <strong>reduceRight</strong> je
rozdíl v&nbsp;tom, ze které strany původní kolekce dochází ke kýžené redukci.
Podívejme se na typický &bdquo;školní&ldquo; příklad, v&nbsp;němž se sečtou
všechny prvky v&nbsp;aritmetické řadě 1..10. Nejprve vytvořme tuto řadu:</p>

<pre>
<i>// pole s prvky 1..10</i>
<strong>var</strong> array1 = _.range(1, 11);
</pre>

<p>Následně vytvořme uživatelskou funkci, která se bude volat pro každý prvek
původní kolekce a pro mezivýsledek. Jedná se o značně jednoduchou funkci, které
pouze obě předané hodnoty sečte:</p>

<pre>
<i>// bezna neanonymni (pojmenovana) funkce pouzita v reduce</i>
<i>// i v reduceRight</i>
<strong>function</strong> add(x,y)
{
    return x+y;
}
</pre>

<p>Nyní zajistíme postupné volání funkce <strong>add</strong> na prvky pole
s&nbsp;automatickým předáním mezivýsledku. Podle předpokladů bude výsledek
funkce <strong>reduce</strong> v&nbsp;tomto případě totožný s&nbsp;výsledkem
vráceným funkcí <strong>reduceRight</strong>, protože je zcela jedno,
v&nbsp;jakém pořadí se prvky sečtou:</p>

<pre>
<i>// vypocet sumy prvku</i>
<strong>var</strong> sum1 = _.reduce(array1, add);
55
<strong>var</strong> sum2 = _.reduceRight(array1, add);
55
</pre>

<p>Ne všechny operace jsou ovšem asociativní a komutativní, jako je tomu u
součtu čísel. Zkusme si vyzkoušet, co se stane ve chvíli, kdy namísto sčítání
čísel budeme spojovat řetězce:</p>

<pre>
<i>// rozdil mezi reduce a reduceRight</i>
<strong>var</strong> names = ["Perl", "Python", "Java", "JavaScript", "C", "C++", "Lua", "Clojure", "Forth", "APL", "BASIC"];
&nbsp;
<i>// bezna neanonymni (pojmenovana) funkce pouzita v reduce</i>
<i>// i v reduceRight</i>
<strong>function</strong> concat(string1,string2)
{
    return string1 + ", " + string2
}
</pre>

<p>Výsledky mezi <strong>reduce</strong> a <strong>reduceRight</strong> budou
rozdílné, protože se výsledný řetězec bude skládat opačným způsobem
(z&nbsp;výsledků je zřejmé, jak):</p>

<pre>
&nbsp;
console.log("reduce: " + _.reduce(names, concat));
reduce: Perl, Python, Java, JavaScript, C, C++, Lua, Clojure, Forth, APL, BASIC
&nbsp;
console.log("reduceRight: " + _.reduceRight(names, concat));
reduceRight: BASIC, APL, Forth, Clojure, Lua, C++, C, JavaScript, Java, Python, Perl
</pre>



<p><a name="k11"></a></p>
<h2 id="k11">11. Pátý demonstrační příklad &ndash; použití funkcí <strong>reduce</strong> a <strong>reduceRight</strong></h2>

<p>Funkce <strong>reduce</strong> a <strong>reduceRight</strong> jsou
pravděpodobně pochopitelné poněkud hůře, než předchozí funkce vyššího řádu,
ovšem i jejich užitečnost může být vysoká. Podívejme se nyní, jak se úryvky
kódu, s&nbsp;nimiž jsme se seznámili <a href="#k10">v&nbsp;předchozí
kapitole</a>, použijí v&nbsp;demonstračním příkladu:</p>

<pre>
<i>// ------------------------------------------------------------</i>
<i>// Knihovna Underscore.js: demonstracni priklad cislo 10</i>
<i>//                         Pouziti funkci reduce a reduceRight</i>
<i>// ------------------------------------------------------------</i>
&nbsp;
&nbsp;
&nbsp;
<i>// pole s prvky 1..10</i>
<strong>var</strong> array1 = _.range(1, 11);
&nbsp;
&nbsp;
<i>// bezna neanonymni (pojmenovana) funkce pouzita v reduce</i>
<i>// i v reduceRight</i>
<strong>function</strong> add(x,y)
{
    return x+y;
}
&nbsp;
<i>// vypocet sumy prvku</i>
<strong>var</strong> sum1 = _.reduce(array1, add);
<strong>var</strong> sum2 = _.reduceRight(array1, add);
&nbsp;
console.log("sum1 = " + sum1);
console.log("sum2 = " + sum2);
&nbsp;
<i>// alternativni zpusob s pouzitim anonymnich funkci</i>
console.log("sum1 = " + _.reduce(array1, <strong>function</strong>(x,y) {return x+y;}));
console.log("sum2 = " + _.reduceRight(array1, <strong>function</strong>(x,y) {return x+y;}));
&nbsp;
&nbsp;
<i>// rozdil mezi reduce a reduceRight</i>
<strong>var</strong> names = ["Perl", "Python", "Java", "JavaScript", "C", "C++", "Lua", "Clojure", "Forth", "APL", "BASIC"];
&nbsp;
&nbsp;
<i>// bezna neanonymni (pojmenovana) funkce pouzita v reduce</i>
<i>// i v reduceRight</i>
<strong>function</strong> concat(string1,string2)
{
    return string1 + ", " + string2
}
&nbsp;
console.log("reduce: " + _.reduce(names, concat));
console.log("reduceRight: " + _.reduceRight(names, concat));
&nbsp;
<i>// alternativni zpusob s pouzitim anonymnich funkci</i>
console.log("reduce: " + _.reduce(names, <strong>function</strong>(x,y) {return x+", "+y;}));
console.log("reduceRight: " + _.reduceRight(names, <strong>function</strong>(x,y) {return x+", "+y;}));
&nbsp;
&nbsp;
&nbsp;
<i>// ------------------------------------------------------------</i>
<i>// Finito</i>
<i>// ------------------------------------------------------------</i>
</pre>

<p>Výstup generovaný příkladem na konzoli je zobrazen níže:</p>

<pre>
sum1 = 55
sum2 = 55
sum1 = 55
sum2 = 55
reduce: Perl, Python, Java, JavaScript, C, C++, Lua, Clojure, Forth, APL, BASIC
reduceRight: BASIC, APL, Forth, Clojure, Lua, C++, C, JavaScript, Java, Python, Perl
reduce: Perl, Python, Java, JavaScript, C, C++, Lua, Clojure, Forth, APL, BASIC
reduceRight: BASIC, APL, Forth, Clojure, Lua, C++, C, JavaScript, Java, Python, Perl
</pre>

<p>Povšimněte si především toho, že funkce <strong>reduce</strong> a
<strong>reduceRight</strong> mají odlišný výsledek ve chvíli, kdy jsou operace
prováděné volanými funkcemi nekomutativní a neasociativní:</p>



<p><a name="k12"></a></p>
<h2 id="k12">12. Výpočet faktoriálu s&nbsp;použitím funkce <strong>reduce</strong></h2>

<p>Funkci <strong>reduce</strong> či <strong>reduceRight</strong> (zde je to
opět jedno) můžeme použít pro výpočet faktoriálu, protože si stačí uvědomit, že
výpočet faktoriálu je prakticky totožný s&nbsp;algoritmem pro součet
aritmetické řady (ten již velmi dobře známe). Liší se jen použitá operace
&ndash; namísto součtu se provede součin. &bdquo;Funkcionálně&ldquo; zapsaný
výpočet faktoriálu může vypadat i tak, že se na sekvenci hodnot vygenerovanou
s&nbsp;využitím <strong>range</strong> aplikuje <strong>reduce</strong>:</p>

<pre>
_.reduce(_.range(1,n+1), function(x,y) {return x*y;});
</pre>

<p>Poznámka: nejedná se o optimální způsob z&nbsp;hlediska spotřeby paměti ani
rychlosti, a to kvůli nutnosti generovat prvky zdrojového pole, které se ihned
po výpočtu opět zahodí.</p>

<p>Pokud budeme chtít vytvořit tabulku faktoriálu pro zvolená <i>n</i>, můžeme
samozřejmě použít programovou smyčku typu for. Ovšem zápis této smyčky je už od
dob jazyka C mnohdy zbytečně komplikovaný. Namísto toho je možné použít funkci
<strong>each</strong>, která pro každý prvek vstupní sekvence volá zapsanou
funkci. Povšimněte si zde malého ale významného rozdílu oproti
<strong>map</strong>, kde se vracela nová sekvence. To funkce
<strong>each</strong> nedělá a předpokládá, že volaná funkce bude mít nějaký
vedlejší efekt:</p>

<pre>
_.each(_.range(1,11), ...);
</pre>

<p>Výpočet tabulky faktoriálu pro n=1..10 tedy zapíšeme například takto:</p>

<pre>
_.each(_.range(1,11), function(n) {console.log(n + "! = " + factorial(n));});
</pre>



<p><a name="k13"></a></p>
<h2 id="k13">13. Šestý demonstrační příklad &ndash; funkce <strong>each</strong> a <strong>reduce</strong> při výpočtu faktoriálu</h2>

<p>Podívejme se nyní na použití funkce pro výpočet faktoriálu s&nbsp;využitím
<strong>reduce</strong> a <strong>range</strong> v&nbsp;praxi. V&nbsp;dnešním
posledním demonstračním příkladu, jehož zdrojový kód lze nalézt na <a
href="https://github.com/tisnik/presentations/blob/master/underscore/underscore_11.js">https://github.com/tisnik/presentations/blob/master/underscore/underscore_11.js</a>
je tato funkce definována a následně použita pro výpočet faktoriálů pro n=1 až
n=10. Povšimněte si, že se v&nbsp;tomto příkladu opět nikde neobjevují
explicitně zapsané programové smyčky:</p>

<pre>
<i>// ------------------------------------------------------------</i>
<i>// Knihovna Underscore.js: demonstracni priklad cislo 11</i>
<i>//                         Pouziti funkce each spolecne s funkci</i>
<i>//                         reduce.</i>
<i>// ------------------------------------------------------------</i>
&nbsp;
&nbsp;
&nbsp;
<i>// alternativni zpusob vypoctu faktorialu</i>
function factorial(n)
{
    <i>// vytvori se posloupnost 1..n</i>
    <i>// postupne se jednotlive prvky poslouposti nasobi</i>
    <i>// a vrati se vysledek</i>
    return _.reduce(_.range(1,n+1), function(x,y) {return x*y;});
}
&nbsp;
<i>// tisk nekolika faktorialu pro vstupni hodnoty 1..10</i>
<i>// (vime jiz, ze funkce range nezahrnuje mezni hodnotu)</i>
&nbsp;
<i>// funkce each pracuje jako smycka foreach</i>
<i>// (neni to tedy cista funkce, protoze ma a musi mit vedlejsi efekt)</i>
_.each(_.range(1,11), function(n) {console.log(n + "! = " + factorial(n));});
&nbsp;
&nbsp;
&nbsp;
<i>// ------------------------------------------------------------</i>
<i>// Finito</i>
<i>// ------------------------------------------------------------</i>
</pre>

<p>Výstup generovaný tímto posledním příkladem na konzoli webového prohlížeče
ukazuje, že se faktoriály skutečně počítají korektně (minimálně pro celá kladná
čísla až do limitu zmíněného níže):</p>

<pre>
1! = 1
2! = 2
3! = 6
4! = 24
5! = 120
6! = 720
7! = 5040
8! = 40320
9! = 362880
10! = 3628800
</pre>

<p>Poznámka: podle specifikace by měly všechny implementace JavaScriptu pro
numerické hodnoty používat typ <i>double</i> (čísla s&nbsp;plovoucí řádovou
čárkou mající dvojitou přesnost) definovaný v&nbsp;IEEE 754. Z&nbsp;tohoto
limitu lze odvodit i maximální hodnotu <i>n</i>, pro kterou se faktoriál
vypočítá korektně. Hranice leží mezi n=170 a n=171:</p>

<pre>
170! = 7.257415615307994e+306
171! = Infinity
</pre>



<p><a name="k14"></a></p>
<h2 id="k14">14. Repositář s&nbsp;demonstračními příklady</h2>

<p>Všech šest demonstračních příkladů, které jsme si v&nbsp;dnešním článku
popsali, bylo uloženo do Git repositáře dostupného na adrese <a
href="https://github.com/tisnik/presentations">https://github.com/tisnik/presentations</a>.
V&nbsp;tabulce zobrazené pod tímto odstavcem naleznete na zdrojové kódy všech
šesti demonstračních příkladů přímé odkazy (navíc je doplněn i odkaz na
aktuálně použitou variantu knihovny <i>Underscore</i>):</p>

<table>
<tr><th>#</th><th>Příklad/knihovna</th><th>Github</th></tr>
<tr><td>1</td><td>underscore_06.js</td><td><a href="https://github.com/tisnik/presentations/blob/master/underscore/underscore_06.js">https://github.com/tisnik/presentations/blob/master/underscore/underscore_06.js</a></td></tr>
<tr><td>2</td><td>underscore_07.js</td><td><a href="https://github.com/tisnik/presentations/blob/master/underscore/underscore_07.js">https://github.com/tisnik/presentations/blob/master/underscore/underscore_07.js</a></td></tr>
<tr><td>3</td><td>underscore_08.js</td><td><a href="https://github.com/tisnik/presentations/blob/master/underscore/underscore_08.js">https://github.com/tisnik/presentations/blob/master/underscore/underscore_08.js</a></td></tr>
<tr><td>4</td><td>underscore_09.js</td><td><a href="https://github.com/tisnik/presentations/blob/master/underscore/underscore_09.js">https://github.com/tisnik/presentations/blob/master/underscore/underscore_09.js</a></td></tr>
<tr><td>5</td><td>underscore_10.js</td><td><a href="https://github.com/tisnik/presentations/blob/master/underscore/underscore_10.js">https://github.com/tisnik/presentations/blob/master/underscore/underscore_10.js</a></td></tr>
<tr><td>6</td><td>underscore_11.js</td><td><a href="https://github.com/tisnik/presentations/blob/master/underscore/underscore_11.js">https://github.com/tisnik/presentations/blob/master/underscore/underscore_11.js</a></td></tr>
<tr><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td></tr>
<tr><td>7</td><td>underscore-min.js</td><td><a href="https://github.com/tisnik/presentations/blob/master/underscore/underscore-min.js">https://github.com/tisnik/presentations/blob/master/underscore/underscore-min.js</a></td></tr>
</table>



<p><a name="k15"></a></p>
<h2 id="k15">15. Odkazy na Internetu</h2>

<ol>

<li>Stránky knihovny Underscore s popisem všech funkcí<br />
<a href="http://underscorejs.org/">http://underscorejs.org/</a>
</li>

<li>Minifikovaná verze knihovny Underscore<br />
<a href="http://underscorejs.org/underscore-min.js">http://underscorejs.org/underscore-min.js</a>
</li>

<li>Functional Programming (Wikipedia)<br />
<a href="https://en.wikipedia.org/wiki/Functional_programming">https://en.wikipedia.org/wiki/Functional_programming</a>
</li>

<li>An Introduction to Functional Programming in JavaScript<br />
<a href="http://www.srirangan.net/2011-12-functional-programming-in-javascript">http://www.srirangan.net/2011-12-functional-programming-in-javascript</a>
</li>

<li>Getting Cozy With Underscore.js<br />
<a href="http://code.tutsplus.com/tutorials/getting-cozy-with-underscorejs--net-24581">http://code.tutsplus.com/tutorials/getting-cozy-with-underscorejs--net-24581</a>
</li>

<li>Mori na GitHubu<br />
<a href="https://github.com/swannodette/mori">https://github.com/swannodette/mori</a>
</li>

<li>Mori: popis API (dokumentace)<br />
<a href="http://swannodette.github.io/mori/">http://swannodette.github.io/mori/</a>
</li>

<li>Mori: Benchmarking<br />
<a href="https://github.com/swannodette/mori/wiki/Benchmarking">https://github.com/swannodette/mori/wiki/Benchmarking</a>
</li>

<li>Functional data structures in JavaScript with Mori<br />
<a href="http://sitr.us/2013/11/04/functional-data-structures.html">http://sitr.us/2013/11/04/functional-data-structures.html</a>
</li>

<li>Immutable.js<br />
<a href="https://facebook.github.io/immutable-js/">https://facebook.github.io/immutable-js/</a>
</li>

<li>Persistent data structure<br />
<a href="https://en.wikipedia.org/wiki/Persistent_data_structure">https://en.wikipedia.org/wiki/Persistent_data_structure</a>
</li>

<li>Understanding Clojure's Persistent Vectors, pt. 1<br />
<a href="http://hypirion.com/musings/understanding-persistent-vector-pt-1">http://hypirion.com/musings/understanding-persistent-vector-pt-1</a>
</li>

<li>Hash array mapped trie (Wikipedia)<br />
<a href="https://en.wikipedia.org/wiki/Hash_array_mapped_trie">https://en.wikipedia.org/wiki/Hash_array_mapped_trie</a>
</li>

<li>Java theory and practice: To mutate or not to mutate?<br />
<a href="http://www.ibm.com/developerworks/java/library/j-jtp02183/index.html">http://www.ibm.com/developerworks/java/library/j-jtp02183/index.html</a>
</li>

<li>Efficient persistent (immutable) data structures<br />
<a href="https://persistent.codeplex.com/">https://persistent.codeplex.com/</a>
</li>

<li>Netscape Enterprise Server (Wikipedia)<br />
<a href="https://en.wikipedia.org/wiki/Netscape_Enterprise_Server">https://en.wikipedia.org/wiki/Netscape_Enterprise_Server</a>
</li>

<li>SSJS Reference Guide (Server-Side JavaScript)<br />
<a href="http://docs.oracle.com/cd/E19957-01/816-6410-10/816-6410-10.pdf">http://docs.oracle.com/cd/E19957-01/816-6410-10/816-6410-10.pdf</a>
</li>

<li>Atom: moderní textový editor<br />
<a href="http://www.root.cz/clanky/atom-moderni-textovy-editor/">http://www.root.cz/clanky/atom-moderni-textovy-editor/</a>
</li>

<li>Atom: moderní textový editor (dokončení)<br />
<a href="http://www.root.cz/clanky/atom-moderni-textovy-editor-dokonceni/">http://www.root.cz/clanky/atom-moderni-textovy-editor-dokonceni/</a>
</li>

<li>Propojení světa LISPu se světem JavaScriptu s využitím transpřekladače Wisp<br />
<a href="http://www.root.cz/clanky/propojeni-sveta-lispu-se-svetem-javascriptu-s-vyuzitim-transprekladace-wisp/">http://www.root.cz/clanky/propojeni-sveta-lispu-se-svetem-javascriptu-s-vyuzitim-transprekladace-wisp/</a>
</li>

<li>Propojení světa LISPu se světem JavaScriptu s využitím transpřekladače Wisp (2.část)<br />
<a href="http://www.root.cz/clanky/propojeni-sveta-lispu-se-svetem-javascriptu-s-vyuzitim-transprekladace-wisp-2-cast/">http://www.root.cz/clanky/propojeni-sveta-lispu-se-svetem-javascriptu-s-vyuzitim-transprekladace-wisp-2-cast/</a>
</li>

<li>Wisp na GitHubu<br />
<a href="https://github.com/Gozala/wisp">https://github.com/Gozala/wisp</a>
</li>

<li>Wisp playground<br />
<a href="http://www.jeditoolkit.com/try-wisp/">http://www.jeditoolkit.com/try-wisp/</a>
</li>

<li>REPL v prohlížeči<br />
<a href="http://www.jeditoolkit.com/interactivate-wisp/">http://www.jeditoolkit.com/interactivate-wisp/</a>
</li>

<li>Minification (programming)<br />
<a href="https://en.wikipedia.org/wiki/Minification_(programming)">https://en.wikipedia.org/wiki/Minification_(programming)</a>
</li>

<li>Clojure Macro Tutorial (Part I, Getting the Compiler to Write Your Code For You)<br />
<a href="http://www.learningclojure.com/2010/09/clojure-macro-tutorial-part-i-getting.html">http://www.learningclojure.com/2010/09/clojure-macro-tutorial-part-i-getting.html</a>
</li>

<li>Clojure Macro Tutorial (Part II: The Compiler Strikes Back)<br />
<a href="http://www.learningclojure.com/2010/09/clojure-macro-tutorial-part-ii-compiler.html">http://www.learningclojure.com/2010/09/clojure-macro-tutorial-part-ii-compiler.html</a>
</li>

<li>Clojure Macro Tutorial (Part III: Syntax Quote)<br />
<a href="http://www.learningclojure.com/2010/09/clojure-macro-tutorial-part-ii-syntax.html">http://www.learningclojure.com/2010/09/clojure-macro-tutorial-part-ii-syntax.html</a>
</li>

<li>Tech behind Tech: Clojure Macros Simplified<br />
<a href="http://techbehindtech.com/2010/09/28/clojure-macros-simplified/">http://techbehindtech.com/2010/09/28/clojure-macros-simplified/</a>
</li>

<li>Fatvat - Exploring functional programming: Clojure Macros<br />
<a href="http://www.fatvat.co.uk/2009/02/clojure-macros.html">http://www.fatvat.co.uk/2009/02/clojure-macros.html</a>
</li>

<li>Eulerovo číslo<br />
<a href="http://cs.wikipedia.org/wiki/Eulerovo_??slo">http://cs.wikipedia.org/wiki/Eulerovo_??slo</a>
</li>

<li>List comprehension<br />
<a href="http://en.wikipedia.org/wiki/List_comprehension">http://en.wikipedia.org/wiki/List_comprehension</a>
</li>

<li>List Comprehensions in Clojure<br />
<a href="http://asymmetrical-view.com/2008/11/18/list-comprehensions-in-clojure.html">http://asymmetrical-view.com/2008/11/18/list-comprehensions-in-clojure.html</a>
</li>

<li>Clojure Programming Concepts: List Comprehension<br />
<a href="http://en.wikibooks.org/wiki/Clojure_Programming/Concepts#List_Comprehension">http://en.wikibooks.org/wiki/Clojure_Programming/Concepts#List_Comprehension</a>
</li>

<li>Clojure core API: for macro<br />
<a href="http://clojure.github.com/clojure/clojure.core-api.html#clojure.core/for">http://clojure.github.com/clojure/clojure.core-api.html#clojure.core/for</a>
</li>

<li>cirrus machina - The Clojure for macro<br />
<a href="http://www.cirrusmachina.com/blog/comment/the-clojure-for-macro/">http://www.cirrusmachina.com/blog/comment/the-clojure-for-macro/</a>
</li>

<li>Clojure.org: Clojure home page<br />
<a href="http://clojure.org/downloads">http://clojure.org/downloads</a>
</li>

<li>Clojure.org: Vars and the Global Environment<br />
<a href="http://clojure.org/Vars">http://clojure.org/Vars</a>
</li>

<li>Clojure.org: Refs and Transactions<br />
<a href="http://clojure.org/Refs">http://clojure.org/Refs</a>
</li>

<li>Clojure.org: Atoms<br />
<a href="http://clojure.org/Atoms">http://clojure.org/Atoms</a>
</li>

<li>Clojure.org: Agents as Asynchronous Actions<br />
<a href="http://clojure.org/agents">http://clojure.org/agents</a>
</li>

<li>A Couple of Clojure Agent Examples<br />
<a href="http://lethain.com/a-couple-of-clojure-agent-examples/">http://lethain.com/a-couple-of-clojure-agent-examples/</a>
</li>

<li>Clojure - Functional Programming for the JVM<br />
<a href="http://java.ociweb.com/mark/clojure/article.html">http://java.ociweb.com/mark/clojure/article.html</a>
</li>

<li>Clojure quick reference<br />
<a href="http://faustus.webatu.com/clj-quick-ref.html">http://faustus.webatu.com/clj-quick-ref.html</a>
</li>

<li>4Clojure<br />
<a href="http://www.4clojure.com/">http://www.4clojure.com/</a>
</li>

<li>ClojureDoc<br />
<a href="http://clojuredocs.org/">http://clojuredocs.org/</a>
</li>

<li>Clojure (Wikipedia EN)<br />
<a href="http://en.wikipedia.org/wiki/Clojure">http://en.wikipedia.org/wiki/Clojure</a>
</li>

<li>Clojure (Wikipedia CS)<br />
<a href="http://cs.wikipedia.org/wiki/Clojure">http://cs.wikipedia.org/wiki/Clojure</a>
</li>

<li>Riastradh's Lisp Style Rules<br />
<a href="http://mumble.net/~campbell/scheme/style.txt">http://mumble.net/~campbell/scheme/style.txt</a>
</li>

<li>Dynamic Languages Strike Back<br />
<a href="http://steve-yegge.blogspot.cz/2008/05/dynamic-languages-strike-back.html">http://steve-yegge.blogspot.cz/2008/05/dynamic-languages-strike-back.html</a>
</li>

<li>Scripting: Higher Level Programming for the 21st Century<br />
<a href="http://www.tcl.tk/doc/scripting.html">http://www.tcl.tk/doc/scripting.html</a>
</li>

<li>Java Virtual Machine Support for Non-Java Languages<br />
<a href="http://docs.oracle.com/javase/7/docs/technotes/guides/vm/multiple-language-support.html">http://docs.oracle.com/javase/7/docs/technotes/guides/vm/multiple-language-support.html</a>
</li>

<li>The Lua VM, on the Web<br />
<a href="https://kripken.github.io/lua.vm.js/lua.vm.js.html">https://kripken.github.io/lua.vm.js/lua.vm.js.html</a>
</li>

<li>Lua.vm.js REPL<br />
<a href="https://kripken.github.io/lua.vm.js/repl.html">https://kripken.github.io/lua.vm.js/repl.html</a>
</li>

<li>lua2js<br />
<a href="https://www.npmjs.com/package/lua2js">https://www.npmjs.com/package/lua2js</a>
</li>

<li>lua2js na GitHubu<br />
<a href="https://github.com/basicer/lua2js-dist">https://github.com/basicer/lua2js-dist</a>
</li>

<li>Seriál o programovacím jazyku Lua<br />
<a href="http://www.root.cz/serialy/programovaci-jazyk-lua/">http://www.root.cz/serialy/programovaci-jazyk-lua/</a>
</li>

<li>Source-to-source compiler<br />
<a href="https://en.wikipedia.org/wiki/Source-to-source_compiler">https://en.wikipedia.org/wiki/Source-to-source_compiler</a>
</li>

<li>JavaScript is Assembly Language for the Web: Sematic Markup is Dead! Clean vs. Machine-coded HTML<br />
<a href="http://www.hanselman.com/blog/JavaScriptIsAssemblyLanguageForTheWebSematicMarkupIsDeadCleanVsMachinecodedHTML.aspx">http://www.hanselman.com/blog/JavaScriptIsAssemblyLanguageForTheWebSematicMarkupIsDeadCleanVsMachinecodedHTML.aspx</a>
</li>

<li>JavaScript is Web Assembly Language and that's OK.<br />
<a href="http://www.hanselman.com/blog/JavaScriptIsWebAssemblyLanguageAndThatsOK.aspx">http://www.hanselman.com/blog/JavaScriptIsWebAssemblyLanguageAndThatsOK.aspx</a>
</li>

<li>Dart<br />
<a href="https://www.dartlang.org/">https://www.dartlang.org/</a>
</li>

<li>CoffeeScript<br />
<a href="http://coffeescript.org/">http://coffeescript.org/</a>
</li>

<li>TypeScript<br />
<a href="http://www.typescriptlang.org/">http://www.typescriptlang.org/</a>
</li>

<li>Lua (programming language)<br />
<a href="http://en.wikipedia.org/wiki/Lua_(programming_language)">http://en.wikipedia.org/wiki/Lua_(programming_language)</a>
</li>

<li>Static single assignment form (SSA)<br />
<a href="http://en.wikipedia.org/wiki/Static_single_assignment_form">http://en.wikipedia.org/wiki/Static_single_assignment_form</a>
</li>

<li>LuaJIT 2.0 SSA IR
<a href="http://wiki.luajit.org/SSA-IR-2.0">http://wiki.luajit.org/SSA-IR-2.0</a>
</li>

<li>The LuaJIT Project<br />
<a href="http://luajit.org/index.html">http://luajit.org/index.html</a>
</li>

<li>LuaJIT FAQ<br />
<a href="http://luajit.org/faq.html">http://luajit.org/faq.html</a>
</li>

<li>LuaJIT Performance Comparison<br />
<a href="http://luajit.org/performance.html">http://luajit.org/performance.html</a>
</li>

<li>LuaJIT 2.0 intellectual property disclosure and research opportunities<br />
<a href="http://article.gmane.org/gmane.comp.lang.lua.general/58908">http://article.gmane.org/gmane.comp.lang.lua.general/58908</a>
</li>

<li>LuaJIT Wiki<br />
<a href="http://wiki.luajit.org/Home">http://wiki.luajit.org/Home</a>
</li>

<li>LuaJIT 2.0 Bytecode Instructions<br />
<a href="http://wiki.luajit.org/Bytecode-2.0">http://wiki.luajit.org/Bytecode-2.0</a>
</li>

<li>Programming in Lua (first edition)<br />
<a href="http://www.lua.org/pil/contents.html">http://www.lua.org/pil/contents.html</a>
</li>

<li>Lua 5.2 sources<br />
<a href="http://www.lua.org/source/5.2/">http://www.lua.org/source/5.2/</a>
</li>

<li>Tcl Plugin Version 3<br />
<a href="http://www.tcl.tk/software/plugin/">http://www.tcl.tk/software/plugin/</a>
</li>

<li>JavaScript: The Web Assembly Language?<br />
<a href="http://www.informit.com/articles/article.aspx?p=1856657">http://www.informit.com/articles/article.aspx?p=1856657</a>
</li>

<li>asm.js<br />
<a href="http://asmjs.org/">http://asmjs.org/</a>
</li>

<li>List of languages that compile to JS<br />
<a href="https://github.com/jashkenas/coffeescript/wiki/List-of-languages-that-compile-to-JS">https://github.com/jashkenas/coffeescript/wiki/List-of-languages-that-compile-to-JS</a>
</li>

<li>REPL<br />
<a href="https://en.wikipedia.org/wiki/Read%E2%80%93eval%E2%80%93print_loop">https://en.wikipedia.org/wiki/Read%E2%80%93eval%E2%80%93print_loop</a>
</li>

<li>The LLVM Compiler Infrastructure<br />
<a href="http://llvm.org/ProjectsWithLLVM/">http://llvm.org/ProjectsWithLLVM/</a>
</li>

<li>clang: a C language family frontend for LLVM<br />
<a href="http://clang.llvm.org/">http://clang.llvm.org/</a>
</li>

<li>emscripten<br />
<a href="http://kripken.github.io/emscripten-site/">http://kripken.github.io/emscripten-site/</a>
</li>

<li>LLVM Backend ("Fastcomp")<br />
<a href="http://kripken.github.io/emscripten-site/docs/building_from_source/LLVM-Backend.html#llvm-backend">http://kripken.github.io/emscripten-site/docs/building_from_source/LLVM-Backend.html#llvm-backend</a>
</li>

<li>Emscripten - Fastcomp na GitHubu<br />
<a href="https://github.com/kripken/emscripten-fastcomp">https://github.com/kripken/emscripten-fastcomp</a>
</li>

<li>Clang (pro Emscripten) na GitHubu<br />
<a href="https://github.com/kripken/emscripten-fastcomp-clang">https://github.com/kripken/emscripten-fastcomp-clang</a>
</li>

<li>Why not use JavaScript?<br />
<a href="https://ckknight.github.io/gorillascript/">https://ckknight.github.io/gorillascript/</a>
</li>

</ol>



<p></p><p></p>
<p><small>Autor: <a href="http://www.fit.vutbr.cz/~tisnovpa">Pavel Tišnovský</a> &nbsp; 2016</small></p>
</body>
</html>

