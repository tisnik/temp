<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
        "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html>
<head>
<title>Použití jazyka Gherkin při tvorbě testovacích scénářů pro aplikace psané v&nbsp;Clojure</title>
<meta name="Author" content="Pavel Tisnovsky" />
<meta name="Generator" content="vim" />
<meta http-equiv="content-type" content="text/html; charset=utf-8" />
<style type="text/css">
         body {color:#000000; background:#ffffff;}
         h1  {font-family: arial, helvetica, sans-serif; color:#ffffff; background-color:#c00000; text-align:center; padding-left:1em}
         h2  {font-family: arial, helvetica, sans-serif; color:#ffffff; background-color:#0000c0; padding-left:1em; text-align:left}
         h3  {font-family: arial, helvetica, sans-serif; color:#000000; background-color:#c0c0c0; padding-left:1em; text-align:left}
         h4  {font-family: arial, helvetica, sans-serif; color:#000000; background-color:#e0e0e0; padding-left:1em; text-align:left}
         a   {font-family: arial, helvetica, sans-serif;}
         li  {font-family: arial, helvetica, sans-serif; color:#000000; text-align:justify; width:450px;}
         ol  {font-family: arial, helvetica, sans-serif; color:#000000; text-align:justify; width:450px;}
         ul  {font-family: arial, helvetica, sans-serif; color:#000000; text-align:justify; width:450px;}
         p   {font-family: arial, helvetica, sans-serif; color:#000000; text-align:justify;}
         pre {background:#e0e0e0}
</style>
</head>

<body>

<h1></h1>

<h3>Pavel Tišnovský</h3>

<p></p>

<h1>Úvodník</h1>

<p>Dnes si ukážeme způsob použití doménově specifického jazyka Gherkin při tvorbě testovacích scénářů pro aplikace napsané v&nbsp;programovacím jazyku Clojure. Při implementaci testů bude použita knihovna Expectations.</p>



<h2>Obsah</h2>

<p><a href="#k01">1. Použití jazyka Gherkin při tvorbě testovacích scénářů pro aplikace psané v&nbsp;Clojure</a></p>
<p><a href="#k02">2. Příprava projektu, jehož chování se bude testovat předpisem napsaným v&nbsp;Gherkinu</a></p>
<p><a href="#k03">3. Testovaná funkce</a></p>
<p><a href="#k04">4. Úprava projektového souboru <strong>project.clj</strong></a></p>
<p><a href="#k05">5. První pokus o spuštění testovacích scénářů</a></p>
<p><a href="#k06">6. Přidání první verze testovacích scénářů a kostry souboru pro implementaci kroků testu</a></p>
<p><a href="#k07">7. První verze modulu s&nbsp;implementací kroků testu</a></p>
<p><a href="#k08">8. Druhý pokus o spuštění testovacích scénářů</a></p>
<p><a href="#k09">9. Implementace dvou kroků testu</a></p>
<p><a href="#k10">10. Třetí pokus o spuštění testovacích scénářů</a></p>
<p><a href="#k11">11. Implementace zbývajících kroků</a></p>
<p><a href="#k12">12. Čtvrtý pokus o spuštění testovacích scénářů</a></p>
<p><a href="#k13">13. Rozšíření testovacích scénářů</a></p>
<p><a href="#k14">14. Opakování kroků s&nbsp;využitím tabulky v&nbsp;osnově scénáře</a></p>
<p><a href="#k15">15. Pátý pokus o spuštění testovacích scénářů</a></p>
<p><a href="#k16">16. Změna adresáře v&nbsp;němž jsou uloženy testovací scénáře</a></p>
<p><a href="#k17">17. Výsledná struktura projektu</a></p>
<p><a href="#k18">18. Repositář s&nbsp;demonstračními příklady</a></p>
<p><a href="#k19">19. Odkazy na předchozí části tohoto seriálu</a></p>
<p><a href="#k20">20. Odkazy na Internetu</a></p>



<p><a name="k01"></a></p>
<h2 id="k01">1. Použití jazyka Gherkin při tvorbě testovacích scénářů pro aplikace psané v&nbsp;Clojure</h2>

<p>V&nbsp;dnešní části seriálu o programovacím jazyku Clojure částečně navážeme
<a
href="https://www.root.cz/clanky/knihovny-a-moduly-usnadnujici-testovani-aplikaci-naprogramovanych-v-jazyce-clojure/">na
předchozí článek</a>, v němž jsme se seznámili s&nbsp;knihovnami a moduly pro
<i>Leiningen</i> určenými především pro testování aplikací, zejména pro psaní
jednotkových testů popř.&nbsp;pro zjištění pokrytí kódu testy. Víme již, že
v&nbsp;této oblasti vzniklo poměrně velké množství zajímavých projektů,
například modul <a
href="https://www.root.cz/clanky/knihovny-a-moduly-usnadnujici-testovani-aplikaci-naprogramovanych-v-jazyce-clojure/#k05">humane-test-output</a>,
knihovna <a
href="https://www.root.cz/clanky/knihovny-a-moduly-usnadnujici-testovani-aplikaci-naprogramovanych-v-jazyce-clojure/#k11">iota</a>,
dále knihovna <a
href="https://www.root.cz/clanky/knihovny-a-moduly-usnadnujici-testovani-aplikaci-naprogramovanych-v-jazyce-clojure/#k14">Expectations</a>
a v&nbsp;neposlední řadě i adaptace jazyka <a
href="https://github.com/cucumber/cucumber/wiki/Gherkin">Gherkin</a>
používaného v&nbsp;<i>BDD</i> neboli <i>Behaviour-driven development</i>.</p>

<p>Dnes si ukážeme, jakým způsobem je možné testy psané v&nbsp;jazyku Gherkin
zaintegrovat do projektu psaném v&nbsp;Clojure. Samotné kroky prováděné testy
budou napsány s&nbsp;využitím knihovny <i>Expectations</i>, což je &ndash;
samozřejmě jen pouze podle mého názoru &ndash; téměř ideální kombinace (jak již
víme, je přímé použití <strong>clojure.test</strong> příliš nízkoúrovňové).</p>

<p><div class="rs-tip-major">Poznámka: v dalším textu se, podobně jako
v&nbsp;předchozím článku, předpokládá, že máte nainstalován správce projektu
Leiningen. Pokud tomu tak není, bude nutné si <a
href="https://www.root.cz/clanky/leiningen-nastroj-pro-spravu-projektu-napsanych-v-clojure/">Leiningen
nainstalovat</a>, což ve skutečnosti není nic těžkého. Navíc se jedná o velmi
užitečný projekt s mnoha přídavnými moduly, které využijete nejenom při
testování, ale například i při přípravě dokumentace nebo ve chvíli, kdy se
aplikace připravuje na deployment. To, zda je Leiningen nainstalován a lze ho
spustit zjistíte například příkazem <strong>which lein</strong>.</div></p>



<p><a name="k02"></a></p>
<h2 id="k02">2. Příprava projektu, jehož chování se bude testovat předpisem napsaným v&nbsp;Gherkinu</h2>

<p>V&nbsp;dnešním článku se zaměříme na popis konfigurace projektů (aplikací)
psaných v&nbsp;programovacím jazyku Clojure. Ukážeme si, jak je možné zařídit,
aby se chování aplikace mohlo testovat předpisem (scénářem, skriptem) napsaným
v&nbsp;jazyce <a
href="https://github.com/cucumber/cucumber/wiki/Gherkin">Gherkin</a>.
V&nbsp;případě Gherkinu se jedná o doménově specifický jazyk (<i>DSL &ndash;
domain specific language</i>) navržený takovým způsobem, aby bylo možné
předpokládané (očekávané) chování aplikace popsat tak jednoduše, že se přípravy
popisu bude moci zúčastnit i zákazník-neprogramátor, popř.&nbsp;po krátkém
zaučení prakticky jakýkoli člen vývojového týmu. Jazyk Gherkin existuje
v&nbsp;různých jazykových mutacích, my se však budeme držet jeho originální
anglické varianty.</p>

<a href="https://www.root.cz/obrazek/324266/"><img src="https://i.iinfo.cz/images/634/clojure-cucumber-1-prev.png" class="image-324266" alt="&#160;" width="370" height="198" /></a>
<p><i>Obrázek 1: Ukázka scénářů napsaných v&nbsp;jazyce Gherkin.</i></p>

<p>Jednotlivé kroky testu napsané v&nbsp;jazyce Gherkin je samozřejmě nutné
nějakým způsobem implementovat. Pro tento účel použijeme již minule zmíněnou
knihovnu <strong>Expectations</strong>, i když si teoreticky můžeme vystačit
pouze s&nbsp;knihovnou <strong>clojure.test</strong> či dokonce jen
s&nbsp;makrem <strong>assert</strong> (to je ovšem řešení pro masochisty
popř.&nbsp;pro vývojáře placené podle počtu řádků napsaného zdrojového kódu
.-).</p>

<p>Na úplném začátku si připravíme kostru projektu, který budeme testovat. Pro
vytvoření této kostry použijeme <i>Leiningen</i>. Kostra projektu se vytvoří
příkazem:</p>

<pre>
$ <strong>lein new app cucumber+expect1</strong>
</pre>

<p>Výsledkem tohoto příkazu by měla být následující adresářová struktura:</p>

<pre>
.
├── doc
│   └── intro.md
├── LICENSE
├── project.clj
├── README.md
├── resources
├── src
│   └── cucumber+expect1
│       └── core.clj
└── test
    └── cucumber+expect1
        └── core_test.clj
&nbsp;
6 directories, 6 files
</pre>

<p><div class="rs-tip-major">Poznámka: povšimněte si, že v&nbsp;názvu projektu
lze použít i znak +. Ten se objeví i v&nbsp;názvu jmenného prostoru. Tento znak
nemá v&nbsp;Clojure žádný speciální význam.</div></p>



<p><a name="k03"></a></p>
<h2 id="k03">3. Testovaná funkce</h2>

<p>Dále upravíme soubor <a
href="https://github.com/tisnik/clojure-examples/blob/master/cucumber%2Bexpect1/src/cucumber%2Bexpect1/core.clj">src/core.clj</a>
takovým způsobem, aby obsahoval testovanou funkci. Pro jednoduchost budeme
testovat nám již známý výpočet faktoriálu, který pro záporná čísla na vstupu
vyhazuje výjimku <strong>IllegalArgumentException</strong> (šlo by použít i
<strong>ArithmeticException</strong>). Celý kód může vypadat následovně:</p>

<pre>
(ns <strong>cucumber+expect1.core</strong>
    (:gen-class))
&nbsp;
<i>; funkce faktorial obsahuje i test na zaporne hodnoty</i>
(defn <strong>factorial</strong>
    [n]
    (if (neg? n)
        (throw (IllegalArgumentException. "negative numbers are not supported!"))
        (apply * (range 1M (inc n)))))
&nbsp;
<i>; otestujeme funkci faktorial</i>
(defn <strong>-main</strong>
    [&amp; args]
    (doseq [i (range 0 10)]
        (println i "! = " (factorial i))))
</pre>

<p>Funkci otestujeme snadno spuštěním <strong>-main</strong>, a to opět přes
<i>Leiningen</i>:</p>

<pre>
$ <strong>lein run</strong>
&nbsp;
0 ! =  1
1 ! =  1M
2 ! =  2M
3 ! =  6M
4 ! =  24M
5 ! =  120M
6 ! =  720M
7 ! =  5040M
8 ! =  40320M
9 ! =  362880M
</pre>



<p><a name="k04"></a></p>
<h2 id="k04">4. Úprava projektového souboru <strong>project.clj</strong></h2>

<p>V&nbsp;dalším kroku přistoupíme k&nbsp;úpravám projektového souboru
<strong>project.clj</strong>. Po vytvoření nového projektu by projektový soubor
měl vypadat přibližně takto (pouze si zkontrolujte verzi interpretru jazyka
Clojure):</p>

<pre>
(defproject cucumber+expect1 "0.1.0-SNAPSHOT"
    :description "FIXME: write description"
    :url "http://example.com/FIXME"
    :license {:name "Eclipse Public License"
              :url "http://www.eclipse.org/legal/epl-v10.html"}
    :dependencies [[org.clojure/clojure <strong>"1.8.0"</strong>]]
    :main ^:skip-aot cucumber+expect1.core
    :target-path "target/%s"
    :profiles {:uberjar {:aot :all}})
</pre>

<p>Do projektového souboru je nutné přidat hned několik údajů:</p>

<ol>

<li>Především budeme používat již výše zmíněnou knihovnu
<strong>Expectations</strong>, kterou přidáme jak do atributu
<strong>:dependencies</strong>, tak i (ve funkci přídavného modulu pro
Leiningen) do atributu <strong>:plugins</strong>. Většinou u nového projektu
tento atribut neexistuje, takže ho je nutné do projektového souboru
přidat.</li>

<li>Dále musíme nakonfigurovat přídavný modul pro jazyk Gherkin. Interpret
tohoto jazyka je součástí knihovny <strong>com.siili/lein-cucumber</strong>,
kterou přidáme jak do atributu <strong>:plugins</strong>, tak i do
<strong>:profiles/:dev</strong> (tím zajistíme automatický překlad testů
popsaných dále).</li>

<li>Nakonec musíme nakonfigurovat adresář, v&nbsp;němž budou uloženy skripty
psané v&nbsp;Gherkinu a taktéž jednotlivé testovací kroky. Prozatím použijeme
adresář &bdquo;test/features&ldquo;. Tato konfigurační volba je uložena
v&nbsp;atributu <strong>:cucumber-feature-paths</strong>.</li>

</ol>

<p>Výsledný projektový soubor <a
href="https://github.com/tisnik/clojure-examples/blob/master/cucumber%2Bexpect1/project.clj">project.clj</a>
by měl vypadat následovně:</p>

<pre>
(defproject cucumber+expect1 "0.1.0-SNAPSHOT"
    :description "FIXME: write description"
    :url "http://example.com/FIXME"
    :license {:name "Eclipse Public License"
              :url "http://www.eclipse.org/legal/epl-v10.html"}
    :dependencies [[org.clojure/clojure "1.8.0"]
                   <strong>[expectations "2.0.9"]</strong>]
    <strong>:plugins [[com.siili/lein-cucumber "1.0.7"]</strong>
              <strong>[lein-expectations "0.0.8"]]</strong>
    <strong>:cucumber-feature-paths ["test/features/"]</strong>
    :main ^:skip-aot cucumber+expect1.core
    :target-path "target/%s"
    :profiles {:uberjar {:aot :all}
               <strong>:dev {:dependencies [[com.siili/lein-cucumber "1.0.7"]</strong>]}})
</pre>

<a href="https://www.root.cz/obrazek/324267/"><img src="https://i.iinfo.cz/images/634/clojure-cucumber-2-prev.png" class="image-324267" alt="&#160;" width="370" height="74" /></a>
<p><i>Obrázek 2: Rozdíl mezi původním projektovým souborem a souborem
upraveným.</i></p>



<p><a name="k05"></a></p>
<h2 id="k05">5. První pokus o spuštění testovacích scénářů</h2>

<p>Po nakonfigurování projektu se v&nbsp;nabídce příkazu <strong>lein</strong>
objeví nové úlohy, o čemž se můžeme snadno přesvědčit. Následující příkaz je
nutné spustit (kdekoli) v&nbsp;adresáři projektu:</p>

<pre>
$ <strong>lein</strong>
</pre>

<p>Ve výsledném seznamu dostupných úloh se objeví i
<strong>cucumber</strong>:</p>

<pre>
Leiningen is a tool for working with Clojure projects.
&nbsp;
Several tasks are available:
change              Rewrite project.clj by applying a function.
check               Check syntax and warn on reflection.
classpath           Print the classpath of the current project.
clean               Remove all files from project's target-path.
compile             Compile Clojure source into .class files.
<strong>cucumber            Runs Cucumber features in test/features with glue in test/features/step_definitions</strong>
deploy              Build and deploy jar to remote repository.
deps                Download all dependencies.
do                  Higher-order task to perform other tasks in succession.
expectations        Executes expectation tests in your project.
help                Display a list of tasks or help for a given task.
install             Install the current project to the local repository.
jar                 Package up all the project's files into a jar file.
javac               Compile Java source files.
new                 Generate project scaffolding based on a template.
plugin              DEPRECATED. Please use the :user profile instead.
pom                 Write a pom.xml file to disk for Maven interoperability.
release             Perform :release-tasks.
repl                Start a repl session either with the current project or standalone.
retest              Run only the test namespaces which failed last time around.
run                 Run a -main function with optional command-line arguments.
search              Search remote maven repositories for matching jars.
show-profiles       List all available profiles or display one if given an argument.
test                Run the project's tests.
trampoline          Run a task without nesting the project's JVM inside Leiningen's.
uberjar             Package up the project files and dependencies into a jar file.
update-in           Perform arbitrary transformations on your project map.
upgrade             Upgrade Leiningen to specified version or latest stable.
vcs                 Interact with the version control system.
version             Print version for Leiningen and the current JVM.
with-profile        Apply the given task with the profile(s) specified.
</pre>

<p>Pokud se nyní pokusíme úlohu <strong>cucumber</strong> spustit:</p>

<pre>
$ <strong>lein cucumber</strong>
</pre>

<p>vypíše se (dosti dlouhé) chybové hlášení společně s&nbsp;výpisem
posloupnosti zásobníkových rámců. Je tomu tak z&nbsp;toho důvodu, že žádné
testovací scénáře prozatím nebyly vytvořeny a tudíž je úloha nedokáže
najít:</p>

<pre>
WARNING: update already refers to: #'clojure.core/update in namespace: useful.map, being replaced by: #'useful.map/update
WARNING: update already refers to: #'clojure.core/update in namespace: leiningen.core.project, being replaced by: #'useful.map/update
Exception in thread "main" java.lang.IllegalArgumentException: Not a file or directory: /home/tester/temp/clojure/clojure-examples/cucumber+expect1/test/features/step_definitions, compiling:(/tmp/form-init4089471517859683101.clj:1:73)
        at clojure.lang.Compiler.load(Compiler.java:7391)
        at clojure.lang.Compiler.loadFile(Compiler.java:7317)
        at clojure.main$load_script.invokeStatic(main.clj:275)
        at clojure.main$init_opt.invokeStatic(main.clj:277)
        at clojure.main$init_opt.invoke(main.clj:277)
        at clojure.main$initialize.invokeStatic(main.clj:308)
        at clojure.main$null_opt.invokeStatic(main.clj:342)
        at clojure.main$null_opt.invoke(main.clj:339)
        at clojure.main$main.invokeStatic(main.clj:421)
        at clojure.main$main.doInvoke(main.clj:384)
        at clojure.lang.RestFn.invoke(RestFn.java:421)
        at clojure.lang.Var.invoke(Var.java:383)
        at clojure.lang.AFn.applyToHelper(AFn.java:156)
        at clojure.lang.Var.applyTo(Var.java:700)
        at clojure.main.main(main.java:37)
Caused by: java.lang.IllegalArgumentException: Not a file or directory: /home/tester/temp/clojure/clojure-examples/cucumber+expect1/test/features/step_definitions
        at cucumber.runtime.io.FileResourceIterator$FileIterator.&lt;init&gt;(FileResourceIterator.java:54)
        at cucumber.runtime.io.FileResourceIterator.&lt;init&gt;(FileResourceIterator.java:20)
        at cucumber.runtime.io.FileResourceIterable.iterator(FileResourceIterable.java:19)
        at clojure.lang.RT.seqFrom(RT.java:532)
        at clojure.lang.RT.seq(RT.java:523)
        at clojure.core$seq__4357.invokeStatic(core.clj:137)
        at clojure.core$seq__4357.invoke(core.clj:137)
        at cucumber.runtime.clj$_loadGlue.invokeStatic(clj.clj:50)
        at cucumber.runtime.clj$_loadGlue.invoke(clj.clj:48)
        at cucumber.runtime.clj.Backend.loadGlue(Unknown Source)
        at cucumber.runtime.Runtime.&lt;init&gt;(Runtime.java:91)
        at cucumber.runtime.Runtime.&lt;init&gt;(Runtime.java:69)
        at sun.reflect.NativeConstructorAccessorImpl.newInstance0(Native Method)
        at sun.reflect.NativeConstructorAccessorImpl.newInstance(NativeConstructorAccessorImpl.java:57)
        at sun.reflect.DelegatingConstructorAccessorImpl.newInstance(DelegatingConstructorAccessorImpl.java:45)
        at java.lang.reflect.Constructor.newInstance(Constructor.java:526)
        at clojure.lang.Reflector.invokeConstructor(Reflector.java:180)
        at leiningen.cucumber.util$create_runtime.invokeStatic(util.clj:18)
        at leiningen.cucumber.util$create_runtime.invoke(util.clj:17)
        at leiningen.cucumber.util$run_cucumber_BANG_.invokeStatic(util.clj:26)
        at leiningen.cucumber.util$run_cucumber_BANG_.invoke(util.clj:23)
        at user$eval1846.invokeStatic(form-init4089471517859683101.clj:1)
        at user$eval1846.invoke(form-init4089471517859683101.clj:1)
        at clojure.lang.Compiler.eval(Compiler.java:6927)
        at clojure.lang.Compiler.eval(Compiler.java:6917)
        at clojure.lang.Compiler.eval(Compiler.java:6917)
        at clojure.lang.Compiler.load(Compiler.java:7379)
        ... 14 more
Subprocess failed
</pre>



<p><a name="k06"></a></p>
<h2 id="k06">6. Přidání první verze testovacích scénářů a kostry souboru pro implementaci kroků testu</h2>

<p>Nyní si do projektu (jedná se o jeho <a
href="https://github.com/tisnik/clojure-examples/tree/master/cucumber%2Bexpect2">novou
verzi</a>, proto má ve svém názvu dvojku) přidáme první verzi testovacích
scénářů a taktéž (prozatím) kostru modulu psaného v&nbsp;Clojure, do něhož
zapíšeme implementace jednotlivých kroků testu. Nově vytvářené soubory budou
umístěny do podadresářů <strong>test/features</strong> a
<strong>test/features/step_definitions</strong>. Výsledek by měl vypadat takto:</p>

<pre>
.
├── doc
│   └── intro.md
├── LICENSE
├── project.clj
├── README.md
├── resources
├── src
│   └── cucumber+expect2
│       └── core.clj
└── test
    ├── cucumber+expect2
    │   └── core_test.clj
    └── features
        ├── <strong>factorial.feature</strong>
        └── <strong>step_definitions</strong>
            └── <strong>factorial_steps.clj</strong>
&nbsp;
8 directories, 6 files
</pre>

<p>Soubor <a
href="https://github.com/tisnik/clojure-examples/blob/master/cucumber%2Bexpect2/test/features/factorial.feature">factorial.feature</a>,
který je umístěný v&nbsp;adresáři <strong>test/features</strong>, bude
obsahovat testovací scénáře napsané v&nbsp;jazyce Gherkin. Ve scénářích jsou
použita klíčová slova <strong>Feature</strong>, <strong>Scenario</strong>,
<strong>Given</strong>, <strong>When</strong> a <strong>Then</strong>, na která
postupně navážeme testovací kroky:</p>

<pre>
<strong>Feature</strong>: Factorial computation
&nbsp;
  <strong>Scenario</strong>: Compute factorial for natural numbers
    <strong>Given</strong> The function factorial is callable
    <strong>When</strong> I try to compute 2!
    <strong>Then</strong> I should get result 2
    <strong>When</strong> I try to compute 3!
    <strong>Then</strong> I should get result 6
    <strong>When</strong> I try to compute 10!
    <strong>Then</strong> I should get result 3628800
&nbsp;
&nbsp;
  <strong>Scenario</strong>: Compute factorial for negative numbers
    <strong>Given</strong> The function factorial is callable
    <strong>When</strong> I try to compute -1!
    <strong>Then</strong> the IllegalArgumentException should be thrown
</pre>

<p>Povšimněte si, že Gherkin je z&nbsp;hlediska sémantiky velmi jednoduchý
jazyk. Obsahuje deklarace jednotlivých testovacích scénářů, počáteční podmínku
a potom sérii kroků ve stylu &bdquo;když udělám X, stane se (očekávám)
Y&ldquo;. Syntax je také jednoduchá (alespoň prozatím), protože první slovo je
klíčové a jednotlivé bloky (zde scénáře) jsou odsazeny, podobně jako
v&nbsp;Pythonu či ve formátu YAML.</p>



<p><a name="k07"></a></p>
<h2 id="k07">7. První verze modulu s&nbsp;implementací kroků testu</h2>

<p>Soubor <a
href="https://github.com/tisnik/clojure-examples/blob/master/cucumber%2Bexpect2/test/features/step_definitions/factorial_steps.clj">factorial_steps.clj</a>
je umístěný v&nbsp;adresáři <strong>test/features/step_definitions</strong>.
Právě do tohoto souboru budeme později zapisovat testovací kroky:</p>

<pre>
(use '[cucumber+expect2.core])
(require '[clojure.test :refer [function?]])
(require '[expectations :refer [expect]])
</pre>

<p>Vidíme, že prozatím je tento soubor prakticky prázdný; obsahuje pouze
nezbytné příkazy pro import potřebných modulů.</p>



<p><a name="k08"></a></p>
<h2 id="k08">8. Druhý pokus o spuštění testovacích scénářů</h2>

<p>Zkusme si testovací scénáře spustit, i když prozatím nemáme definované
jednotlivé kroky:</p>

<pre>
$ <strong>lein cucumber</strong>
</pre>

<p>Nyní již nedojde k&nbsp;pádu, ale scénář se spustí. Ovšem vzhledem
k&nbsp;tomu, že nedojde ke spárování kroků ve scénáři s&nbsp;definovanými kroky
testu, vypíše se informace o tom, že je zapotřebí definovat oba scénáře a všech
deset kroků:</p>

<pre>
Running cucumber...
Looking for features in:  [/home/tester/temp/clojure/clojure-examples/cucumber+expect2/test/features]
Looking for glue in:  [/home/tester/temp/clojure/clojure-examples/cucumber+expect2/test/features/step_definitions]
UUUUUUUUUU
&nbsp;
2 Scenarios (2 undefined)
10 Steps (10 undefined)
0m0.000s
</pre>

<p>Navíc dostaneme i radu, jak by měla implementace jednotlivých kroků
vypadat:</p>

<pre>
You can implement missing steps with the snippets below:
&nbsp;
(Given #"^The function factorial is callable$" []
  (comment  Write code here that turns the phrase above into concrete actions  )
  (throw (cucumber.api.PendingException.)))
&nbsp;
(When #"^I try to compute (\d+)!$" [arg1]
  (comment  Write code here that turns the phrase above into concrete actions  )
  (throw (cucumber.api.PendingException.)))
&nbsp;
(Then #"^I should get result (\d+)$" [arg1]
  (comment  Write code here that turns the phrase above into concrete actions  )
  (throw (cucumber.api.PendingException.)))
&nbsp;
(When #"^I try to compute -(\d+)!$" [arg1]
  (comment  Write code here that turns the phrase above into concrete actions  )
  (throw (cucumber.api.PendingException.)))
&nbsp;
(Then #"^the IllegalArgumentException should be thrown$" []
  (comment  Write code here that turns the phrase above into concrete actions  )
  (throw (cucumber.api.PendingException.)))
&nbsp;
&nbsp;
Ran 0 tests containing 0 assertions in 9 msecs
0 failures, 0 errors.
</pre>

<a href="https://www.root.cz/obrazek/324268/"><img src="https://i.iinfo.cz/images/634/clojure-cucumber-3-prev.png" class="image-324268" alt="&#160;" width="284" height="270" /></a>
<p><i>Obrázek 3: První částečně úspěšné spuštění testovacích scénářů.</i></p>



<p><a name="k09"></a></p>
<h2 id="k09">9. Implementace dvou kroků testu</h2>

<p>Nyní je zapotřebí zjistit, jak vlastně interpret jazyka Gherkin funguje. Ve
své nejjednodušší podobě přečte řádek ve scénáři, rozezná první klíčové slovo
(<strong>Given</strong>, <strong>When</strong>, <strong>Then</strong>) a
posléze se snaží najít takový definovaný krok, na který by bylo možné
&bdquo;spárovat&ldquo; zbytek textu na řádku. Jednotlivé kroky testu přitom
obsahují regulární výraz, což znamená, že například krok:</p>

<pre>
    <strong>When</strong> I try to compute 2!
</pre>

<p>je možné spárovat s&nbsp;krokem definovaným jako:</p>

<pre>
(<strong>When</strong> #"^I try to compute (-?\d+)!$"
    [input]
    (print "Computing" input "!"))
</pre>

<p>Povšimněte si, že krok začíná voláním makra <strong>When</strong>, za nímž
skutečně následuje regulární výraz. V&nbsp;tomto výrazu je deklarována jediná
skupina (group) &ndash; <strong>(-?\d+)</strong>, tj.&nbsp;sekvence číslic,
před nimiž může být umístěno znaménko. Dále kód vypadá stejně, jako definice
běžné funkce, tj.&nbsp;následuje seznam parametrů, který zde bude odpovídat
počtu skupin v&nbsp;regulárním výrazu a samotné tělo funkce. Spárování musí být
jednoznačné, protože v&nbsp;opačném případě by Gherkin zahlásil chybu
(nejednoznačnost). Pokud se spárování povede, jsou z&nbsp;řetězce
(odpovídajícího regulárnímu výrazu) vybrány obsahy jednotlivých skupin a ty
jsou předány tělu funkce (resp.&nbsp;makra, ale to zde nehraje žádnou roli.).
Zcela stejným způsobem jsou implementovány kroky začínající na
<strong>Given</strong> a <strong>Then</strong>, popř.&nbsp;na
<strong>And</strong> a <strong>But</strong> (ale to již předbíháme).</p>

<p>Vzhledem k&nbsp;tomu, že scénáře v&nbsp;Gherkinu vyžadují uložení mezistavu
(minimálně mezi <strong>When-Then</strong>), potřebujeme tento stav nějakým
způsobem reprezentovat. Stavu se většinou říká kontext (<i>context</i>) a
v&nbsp;Clojure ho můžeme reprezentovat hodnotou typu atom (většinou však bude
kontext složitější):</p>

<pre>
(<strong>def</strong> context (atom
    {:input nil
     :result nil}))
</pre>

<p>Nyní již můžeme definovat jednotlivé kroky testu. Nejjednodušší je
<strong>Given</strong>, který jen otestuje existenci funkce, ovšem nijak nemění
stav:</p>

<pre>
(<strong>Given</strong> #"^The function factorial is callable$"
    []
    (assert (clojure.test/function? 'cucumber+expect3.core/factorial)))
</pre>

<p>Složitější je implementace kroků <strong>When</strong> a
<strong>Then</strong>, protože zde již pracujeme se stavem. V&nbsp;kroku
<strong>When</strong> přečteme ze scénáře uživatelem zapsanou hodnotu,
převedeme ji na číslo pomocí <strong>bigdec</strong>, uložíme hodnotu do
kontextu (<strong>swap! context assoc ...</strong>), vypočteme faktoriál a
výsledek taktéž uložíme do kontextu:</p>

<pre>
(<strong>When</strong> #"^I try to compute (-?\d+)!$"
    [input]
    (let [n (bigdec input)]
        (swap! context assoc :input n)
        (swap! context assoc  :result (factorial n))))
</pre>

<p>V&nbsp;kroku <strong>Then</strong> opět získáme hodnotu zapsanou do scénáře,
převedeme ji na číslo a porovnáme s&nbsp;hodnotou vypočtenou. Již zde je vidět
použití makra <strong>expect</strong> z&nbsp;knihovny <i>expectations</i>:</p>

<pre>
(<strong>Then</strong> #"^I should get result (\d+)$"
    [result_str]
    (let [expected_result (bigdec result_str)
          actual_result   (:result @context)]
          (expect expected_result actual_result)))
</pre>



<p><a name="k10"></a></p>
<h2 id="k10">10. Třetí pokus o spuštění testovacích scénářů</h2>

<p>Zkusme si testovací scénáře opět spustit:</p>

<pre>
$ <strong>lein cucumber</strong>
</pre>

<p>Nyní již celkem osm kroků proběhlo v&nbsp;pořádku, jeden krok zhavaroval a
jeden není definován (to je celkem pokrok):</p>

<pre>
Running cucumber...
Looking for features in:  [/home/tester/temp/clojure/clojure-examples/cucumber+expect3/test/features]
Looking for glue in:  [/home/tester/temp/clojure/clojure-examples/cucumber+expect3/test/features/step_definitions]
........FU
&nbsp;
Failed scenarios:
factorial.feature:13 # Scenario: Compute factorial for negative numbers
&nbsp;
2 Scenarios (1 failed, 1 passed)
10 Steps (1 failed, 1 undefined, 8 passed)
0m0.136s
&nbsp;
java.lang.IllegalArgumentException: negative numbers are not supported!
        at cucumber_PLUS_expect3.core$factorial.invokeStatic(core.clj:7)
        at clojure.main.main(main.java:37)
        at ✽.When I try to compute -1!(factorial.feature:15)
&nbsp;
&nbsp;
You can implement missing steps with the snippets below:
&nbsp;
(Then #"^the IllegalArgumentException should be thrown$" []
  (comment  Write code here that turns the phrase above into concrete actions  )
  (throw (cucumber.api.PendingException.)))
&nbsp;
&nbsp;
Ran 1 tests containing 1 assertions in 11 msecs
0 failures, 0 errors.
</pre>

<a href="https://www.root.cz/obrazek/324269/"><img src="https://i.iinfo.cz/images/634/clojure-cucumber-4-prev.png" class="image-324269" alt="&#160;" width="370" height="181" /></a>
<p><i>Obrázek 4: Druhé částečně úspěšné spuštění testovacích scénářů.</i></p>



<p><a name="k11"></a></p>
<h2 id="k11">11. Implementace zbývajících kroků</h2>

<p>Implementace zbývajících kroků bude relativně snadná. Nejdříve rozšíříme
kontext o informaci, zda došlo k&nbsp;výjimce a o jakou výjimku se jedná:</p>

<pre>
(<strong>def</strong> context (atom
    {:input     nil
     :result    nil
     :exception nil}))
</pre>

<p>Další krok je shodný s&nbsp;předchozí verzí testu:</p>

<pre>
(<strong>Given</strong> #"^The function factorial is callable$"
    []
    (assert (clojure.test/function? 'cucumber+expect4.core/factorial)))
</pre>

<p>Změní se ovšem krok s&nbsp;výpočtem faktoriálu. Pokud nedojde
k&nbsp;výjimce, uloží se do kontextu výsledek, pokud k&nbsp;výjimce dojde,
uloží se do kontextu objekt s&nbsp;výjimkou (tento kód by bylo možné napsat
kratším způsobem, ale méně čitelně):</p>

<pre>
(<strong>When</strong> #"^I try to compute (-?\d+)!$"
    [input]
    (let [n (bigdec input)]
        (swap! context assoc :input n)
        (try
            (swap! context assoc  :result (factorial n))
            (swap! context dissoc :exception)
            (catch Exception e
                (swap! context dissoc :result)
                (swap! context assoc  :exception e)))))
</pre>

<p>Krok s&nbsp;testem výsledku obsahuje podmínku, zda nenastala výjimka:</p>

<pre>
(<strong>Then</strong> #"^I should get result (\d+)$"
    [result_str]
    (let [expected_result (bigdec result_str)
          actual_result   (:result @context)
          exception       (:exception @context)]
          (expect nil? exception)
          (expect expected_result actual_result)))
</pre>

<p>Dále následuje definice kroků, které očekávají výjimku. Povšimněte si, že
oba kroky mohou začínat stejným řetězcem a přitom je rozlišení, který krok se
má zavolat, stále zcela jednoznačné:</p>

<pre>
(<strong>defn</strong> exception-name
     [exception]
     (-&gt; exception .getClass .getSimpleName))
&nbsp;
&nbsp;
(<strong>Then</strong> #"^the ([A-Za-z]+) should be thrown$"
    [exception_name]
    (let [exception (:exception @context)
          result    (:result @context)]
         (expect nil? result)
         (expect exception)
         (expect exception_name (exception-name exception))))
&nbsp;
&nbsp;
(<strong>Then</strong> #"^the ([A-Za-z]+) should be thrown with message (.+)$"
    [exception_name message]
    (let [exception (:exception @context)
          result    (:result @context)]
         (expect nil? result)
         (expect exception)
         (expect exception_name (exception-name exception))))
</pre>



<p><a name="k12"></a></p>
<h2 id="k12">12. Čtvrtý pokus o spuštění testovacích scénářů</h2>

<p>Zkusme si testovací scénáře opět spustit tak, jak jsme zvyklí:</p>

<pre>
$ <strong>lein cucumber</strong>
</pre>

<p>Tentokrát se (konečně!) vypíše informace o úspěšném dokončení testovacího
scénáře:</p>

<pre>
Running cucumber...
Looking for features in:  [/home/tester/temp/clojure/clojure-examples/cucumber+expect4/test/features]
Looking for glue in:  [/home/tester/temp/clojure/clojure-examples/cucumber+expect4/test/features/step_definitions]
..........
&nbsp;
2 Scenarios (2 passed)
10 Steps (10 passed)
0m0.130s
&nbsp;
&nbsp;
Ran 5 tests containing 5 assertions in 13 msecs
0 failures, 0 errors.
</pre>

<a href="https://www.root.cz/obrazek/324270/"><img src="https://i.iinfo.cz/images/634/clojure-cucumber-5-prev.png" class="image-324270" alt="&#160;" width="370" height="129" /></a>
<p><i>Obrázek 5: Úspěšné dokončení testovacích scénářů.</i></p>



<p><a name="k13"></a></p>
<h2 id="k13">13. Rozšíření testovacích scénářů</h2>

<p>Testovací scénáře je nyní možné relativně snadno upravovat a to &ndash; což
je důležité &ndash; bez jakýchkoli zásahů do definicí testů. To znamená, že
scénář může převzít kolega, který například Clojure nedokáže přečíst, ovšem má
dobrou znalost aplikační domény. Jednou z&nbsp;velmi zajímavých možností, jak
scénáře rozšířit, spočívá v&nbsp;tom, že se specifikuje tabulka či tabulky se
vstupními hodnotami a očekávanými výsledky.</p>

<p>Do testovacího scénáře přidáme tzv.&nbsp;osnovu (<i>Scenario
Outline</i>):</p>

<pre>
  Scenario Outline: Compute more factorials for natural numbers
    Given The function factorial is callable
    When I try to compute <strong>&lt;n&gt;</strong>!
    Then I should get result <strong>&lt;result&gt;</strong>
&nbsp;
    Examples:
        |  <strong>n</strong> |  <strong>result</strong> |
        |  1 |       1 |
        |  2 |       2 |
        |  3 |       6 |
        |  4 |      24 |
        | 10 | 3628800 |
</pre>

<p>Tento scénář se bude pro každý řádek tabulky opakovat, přičemž v&nbsp;každé
iteraci se namísto textů <strong>&lt;n&gt;</strong> a
<strong>&lt;result&gt;</strong> dosadí hodnoty z&nbsp;příslušného sloupce
tabulky. Jedná se přitom o pouhou textovou substituci, takže ve skutečnosti je
možné s&nbsp;tabulkami provádět i dosti složité operace (viz též navazující
článek).</p>

<p>Podobně můžeme vytvořit osnovu pro ty vstupní hodnoty, u nichž očekáváme
vznik výjimky:</p>

<pre>
  Scenario Outline: Compute more factorials for negative numbers
    Given The function factorial is callable
    When I try to compute <strong>&lt;n&gt;</strong>!
    Then the IllegalArgumentException should be thrown
&nbsp;
    Examples:
        | <strong>n</strong> |
        |-1 |
        |-2 |
        |-3 |
        |-1000 |
</pre>



<p><a name="k14"></a></p>
<h2 id="k14">14. Opakování kroků s&nbsp;využitím tabulky v&nbsp;osnově scénáře</h2>

<p><a
href="https://github.com/tisnik/clojure-examples/blob/master/cucumber%2Bexpect5/test/features/factorial.feature">Celý
scénář</a> bude vypadat následovně:</p>

<pre>
Feature: Factorial computation
&nbsp;
  Scenario: Compute factorial for natural numbers
    Given The function factorial is callable
    When I try to compute 2!
    Then I should get result 2
    When I try to compute 3!
    Then I should get result 6
    When I try to compute 10!
    Then I should get result 3628800
&nbsp;
&nbsp;
  Scenario Outline: Compute more factorials for natural numbers
    Given The function factorial is callable
    When I try to compute &lt;n&gt;!
    Then I should get result &lt;result&gt;
&nbsp;
    Examples:
        |  n |  result |
        |  1 |       1 |
        |  2 |       2 |
        |  3 |       6 |
        |  4 |      24 |
        | 10 | 3628800 |
&nbsp;
&nbsp;
  Scenario: Compute factorial for negative numbers
    Given The function factorial is callable
    When I try to compute -1!
    Then the IllegalArgumentException should be thrown
&nbsp;
&nbsp;
  Scenario Outline: Compute more factorials for negative numbers
    Given The function factorial is callable
    When I try to compute &lt;n&gt;!
    Then the IllegalArgumentException should be thrown
&nbsp;
    Examples:
        | n |
        |-1 |
        |-2 |
        |-3 |
        |-1000 |
</pre>



<p><a name="k15"></a></p>
<h2 id="k15">15. Pátý pokus o spuštění testovacích scénářů</h2>

<p>Popáté si zkusme testy spustit:</p>

<pre>
$ <strong>lein cucumber</strong>
</pre>

<p>Povšimněte si neobvykle vysokého počtu kroků. Je to samozřejmě způsobeno
tím, že každé opakování osnovy vede k&nbsp;provedení dvou kroků testu:</p>

<pre>
Running cucumber...
Looking for features in:  [/home/tester/temp/clojure/clojure-examples/cucumber+expect5/test/features]
Looking for glue in:  [/home/tester/temp/clojure/clojure-examples/cucumber+expect5/test/features/step_definitions]
.....................................
&nbsp;
11 Scenarios (11 passed)
37 Steps (37 passed)
0m0.126s
&nbsp;
&nbsp;
Ran 5 tests containing 5 assertions in 13 msecs
0 failures, 0 errors.
</pre>

<a href="https://www.root.cz/obrazek/324271/"><img src="https://i.iinfo.cz/images/634/clojure-cucumber-6-prev.png" class="image-324271" alt="&#160;" width="370" height="146" /></a>
<p><i>Obrázek 6: Další úspěšné dokončení všech testovacích scénářů.</i></p>



<p><a name="k16"></a></p>
<h2 id="k16">16. Změna adresáře v&nbsp;němž jsou uloženy testovací scénáře</h2>

<p>Pokud budete chtít změnit adresář, v&nbsp;němž jsou uloženy testovací
scénáře, je to velmi snadné. Stačí malý zásah do <a
href="https://github.com/tisnik/clojure-examples/blob/master/cucumber%2Bexpect6/project.clj">projektového
souboru</a> (viz zvýrazněnou část):</p>

<pre>
(defproject cucumber+expect6 "0.1.0-SNAPSHOT"
    :description "FIXME: write description"
    :url "http://example.com/FIXME"
    :license {:name "Eclipse Public License"
              :url "http://www.eclipse.org/legal/epl-v10.html"}
    :dependencies [[org.clojure/clojure "1.8.0"]
                   [expectations "2.0.9"]]
    :plugins [[com.siili/lein-cucumber "1.0.7"]
              [lein-expectations "0.0.8"]]
    <strong>:cucumber-feature-paths ["features/"]</strong>
    :main ^:skip-aot cucumber+expect6.core
    :target-path "target/%s"
    :profiles {:uberjar {:aot :all}
               :dev {:dependencies [[com.siili/lein-cucumber "1.0.7"]]}})
</pre>



<p><a name="k17"></a></p>
<h2 id="k17">17. Výsledná struktura projektu</h2>

<p>Takto <a
href="https://github.com/tisnik/clojure-examples/tree/master/cucumber%2Bexpect6">nakonfigurovaný
projekt</a> by měl mít následující strukturu:</p>

<pre>
.
├── doc
│   └── intro.md
├── <strong>features</strong>
│   ├── <strong>factorial.feature</strong>
│   └── <strong>step_definitions</strong>
│       └── <strong>factorial_steps.clj</strong>
├── LICENSE
├── project.clj
├── README.md
├── resources
├── src
│   └── cucumber+expect6
│       └── core.clj
└── test
    └── cucumber+expect6
        └── core_test.clj
&nbsp;
8 directories, 8 files
</pre>

<p>Příště si popíšeme některé další zajímavé vlastnosti jazyka Gherkin a jeho
spojení s&nbsp;Clojure.</p>



<p><a name="k18"></a></p>
<h2 id="k18">18. Repositář s&nbsp;demonstračními příklady</h2>

<p>Všech šest demonstračních příkladů a projektů určených pro Clojure verze
1.9.0 popř.&nbsp;Clojure 1.8.0 bylo uloženo do repositáře, který naleznete na
adrese <a
href="https://github.com/tisnik/clojure-examples">https://github.com/tisnik/clojure-examples</a>:</p>

<table>
<tr><th>Projekt</th><th>Popis</th><th>Odkaz</th></tr>
<tr><td>1</td><td>cucumber-demo</td><td><a href="https://github.com/tisnik/clojure-examples/tree/master/cucumber-demo">https://github.com/tisnik/clojure-examples/tree/master/cucumber-demo</a></td></tr>
<tr><td>&nbsp;</td><td>&nbsp;</td></tr>
<tr><td>2</td><td>cucumber+expect1</td><td><a href="https://github.com/tisnik/clojure-examples/tree/master/cucumber+expect1">https://github.com/tisnik/clojure-examples/tree/master/cucumber+expect1</a></td></tr>
<tr><td>3</td><td>cucumber+expect2</td><td><a href="https://github.com/tisnik/clojure-examples/tree/master/cucumber+expect2">https://github.com/tisnik/clojure-examples/tree/master/cucumber+expect2</a></td></tr>
<tr><td>4</td><td>cucumber+expect3</td><td><a href="https://github.com/tisnik/clojure-examples/tree/master/cucumber+expect3">https://github.com/tisnik/clojure-examples/tree/master/cucumber+expect3</a></td></tr>
<tr><td>5</td><td>cucumber+expect4</td><td><a href="https://github.com/tisnik/clojure-examples/tree/master/cucumber+expect4">https://github.com/tisnik/clojure-examples/tree/master/cucumber+expect4</a></td></tr>
<tr><td>6</td><td>cucumber+expect5</td><td><a href="https://github.com/tisnik/clojure-examples/tree/master/cucumber+expect5">https://github.com/tisnik/clojure-examples/tree/master/cucumber+expect5</a></td></tr>
<tr><td>7</td><td>cucumber+expect6</td><td><a href="https://github.com/tisnik/clojure-examples/tree/master/cucumber+expect6">https://github.com/tisnik/clojure-examples/tree/master/cucumber+expect6</a></td></tr>
</table>



<p><a name="k19"></a></p>
<h2 id="k19">19. Odkazy na předchozí části tohoto seriálu</h2>

<ol>

<li>Clojure  1: Úvod<br />
<a href="http://www.root.cz/clanky/clojure-aneb-jazyk-umoznujici-tvorbu-bezpecnych-vicevlaknovych-aplikaci-pro-jvm/">http://www.root.cz/clanky/clojure-aneb-jazyk-umoznujici-tvorbu-bezpecnych-vicevlaknovych-aplikaci-pro-jvm/</a>
</li>

<li>Clojure  2: Symboly, kolekce atd.<br />
<a href="http://www.root.cz/clanky/clojure-aneb-jazyk-umoznujici-tvorbu-bezpecnych-vicevlaknovych-aplikaci-pro-jvm-2-cast/">http://www.root.cz/clanky/clojure-aneb-jazyk-umoznujici-tvorbu-bezpecnych-vicevlaknovych-aplikaci-pro-jvm-2-cast/</a>
</li>

<li>Clojure  3: Funkcionální programování<br />
<a href="http://www.root.cz/clanky/clojure-aneb-jazyk-umoznujici-tvorbu-bezpecnych-vicevlaknovych-aplikaci-pro-jvm-3-cast-funkcionalni-programovani/">http://www.root.cz/clanky/clojure-aneb-jazyk-umoznujici-tvorbu-bezpecnych-vicevlaknovych-aplikaci-pro-jvm-3-cast-funkcionalni-programovani/</a>
</li>

<li>Clojure  4: Kolekce, sekvence a lazy sekvence<br />
<a href="http://www.root.cz/clanky/clojure-aneb-jazyk-umoznujici-tvorbu-bezpecnych-vicevlaknovych-aplikaci-pro-jvm-4-cast-kolekce-sekvence-a-lazy-sekvence/">http://www.root.cz/clanky/clojure-aneb-jazyk-umoznujici-tvorbu-bezpecnych-vicevlaknovych-aplikaci-pro-jvm-4-cast-kolekce-sekvence-a-lazy-sekvence/</a>
</li>

<li>Clojure  5: Sekvence, lazy sekvence a paralelní programy<br />
<a href="http://www.root.cz/clanky/clojure-a-bezpecne-aplikace-pro-jvm-sekvence-lazy-sekvence-a-paralelni-programy/">http://www.root.cz/clanky/clojure-a-bezpecne-aplikace-pro-jvm-sekvence-lazy-sekvence-a-paralelni-programy/</a>
</li>

<li>Clojure  6: Podpora pro paralelní programování<br />
<a href="http://www.root.cz/clanky/programovaci-jazyk-clojure-6-futures-nejsou-jen-financni-derivaty/">http://www.root.cz/clanky/programovaci-jazyk-clojure-6-futures-nejsou-jen-financni-derivaty/</a>
</li>

<li>Clojure  7: Další funkce pro paralelní programování<br />
<a href="http://www.root.cz/clanky/programovaci-jazyk-clojure-7-dalsi-podpurne-prostredky-pro-paralelni-programovani/">http://www.root.cz/clanky/programovaci-jazyk-clojure-7-dalsi-podpurne-prostredky-pro-paralelni-programovani/</a>
</li>

<li>Clojure  8: Identity, stavy, neměnné hodnoty a reference<br />
<a href="http://www.root.cz/clanky/programovaci-jazyk-clojure-8-identity-stavy-nemenne-hodnoty-a-referencni-typy/">http://www.root.cz/clanky/programovaci-jazyk-clojure-8-identity-stavy-nemenne-hodnoty-a-referencni-typy/</a>
</li>

<li>Clojure  9: Validátory, pozorovatelé a kooperace s Javou<br />
<a href="http://www.root.cz/clanky/programovaci-jazyk-clojure-9-validatory-pozorovatele-a-kooperace-mezi-clojure-a-javou/">http://www.root.cz/clanky/programovaci-jazyk-clojure-9-validatory-pozorovatele-a-kooperace-mezi-clojure-a-javou/</a>
</li>

<li>Clojure 10: Kooperace mezi Clojure a Javou<br />
<a href="http://www.root.cz/clanky/programovaci-jazyk-clojure-10-kooperace-mezi-clojure-a-javou-pokracovani/">http://www.root.cz/clanky/programovaci-jazyk-clojure-10-kooperace-mezi-clojure-a-javou-pokracovani/</a>
</li>

<li>Clojure 11: Generátorová notace seznamu/list comprehension<br />
<a href="http://www.root.cz/clanky/programovaci-jazyk-clojure-11-generatorova-notace-seznamu-list-comprehension/">http://www.root.cz/clanky/programovaci-jazyk-clojure-11-generatorova-notace-seznamu-list-comprehension/</a>
</li>

<li>Clojure 12: Překlad programů z Clojure do bajtkódu JVM I:<br />
<a href="http://www.root.cz/clanky/programovaci-jazyk-clojure-12-preklad-programu-z-clojure-do-bajtkodu-jvm/">http://www.root.cz/clanky/programovaci-jazyk-clojure-12-preklad-programu-z-clojure-do-bajtkodu-jvm/</a>
</li>

<li>Clojure 13: Překlad programů z Clojure do bajtkódu JVM II:<br />
<a href="http://www.root.cz/clanky/programovaci-jazyk-clojure-13-preklad-programu-z-clojure-do-bajtkodu-jvm-pokracovani/">http://www.root.cz/clanky/programovaci-jazyk-clojure-13-preklad-programu-z-clojure-do-bajtkodu-jvm-pokracovani/</a>
</li>

<li>Clojure 14: Základy práce se systémem maker<br />
<a href="http://www.root.cz/clanky/programovaci-jazyk-clojure-14-zaklady-prace-se-systemem-maker/">http://www.root.cz/clanky/programovaci-jazyk-clojure-14-zaklady-prace-se-systemem-maker/</a>
</li>

<li>Clojure 15: Tvorba uživatelských maker<br />
<a href="http://www.root.cz/clanky/programovaci-jazyk-clojure-15-tvorba-uzivatelskych-maker/">http://www.root.cz/clanky/programovaci-jazyk-clojure-15-tvorba-uzivatelskych-maker/</a>
</li>

<li>Clojure 16: Složitější uživatelská makra<br />
<a href="http://www.root.cz/clanky/programovaci-jazyk-clojure-16-slozitejsi-uzivatelska-makra/">http://www.root.cz/clanky/programovaci-jazyk-clojure-16-slozitejsi-uzivatelska-makra/</a>
</li>

<li>Clojure 17: Využití standardních maker v praxi<br />
<a href="http://www.root.cz/clanky/programovaci-jazyk-clojure-17-vyuziti-standardnich-maker-v-praxi/">http://www.root.cz/clanky/programovaci-jazyk-clojure-17-vyuziti-standardnich-maker-v-praxi/</a>
</li>

<li>Clojure 18: Základní techniky optimalizace aplikací<br />
<a href="http://www.root.cz/clanky/programovaci-jazyk-clojure-18-zakladni-techniky-optimalizace-aplikaci/">http://www.root.cz/clanky/programovaci-jazyk-clojure-18-zakladni-techniky-optimalizace-aplikaci/</a>
</li>

<li>Clojure 19: Vývojová prostředí pro Clojure<br />
<a href="http://www.root.cz/clanky/programovaci-jazyk-clojure-19-vyvojova-prostredi-pro-clojure/">http://www.root.cz/clanky/programovaci-jazyk-clojure-19-vyvojova-prostredi-pro-clojure/</a>
</li>

<li>Clojure 20: Vývojová prostředí pro Clojure (Vimu s REPL)<br />
<a href="http://www.root.cz/clanky/programovaci-jazyk-clojure-20-vyvojova-prostredi-pro-clojure-integrace-vimu-s-repl/">http://www.root.cz/clanky/programovaci-jazyk-clojure-20-vyvojova-prostredi-pro-clojure-integrace-vimu-s-repl/</a>
</li>

<li>Clojure 21: ClojureScript aneb překlad Clojure do JS<br />
<a href="http://www.root.cz/clanky/programovaci-jazyk-clojure-21-clojurescript-aneb-preklad-clojure-do-javascriptu/">http://www.root.cz/clanky/programovaci-jazyk-clojure-21-clojurescript-aneb-preklad-clojure-do-javascriptu/</a>
</li>

<li>Leiningen: nástroj pro správu projektů napsaných v Clojure<br />
<a href="http://www.root.cz/clanky/leiningen-nastroj-pro-spravu-projektu-napsanych-v-clojure/">http://www.root.cz/clanky/leiningen-nastroj-pro-spravu-projektu-napsanych-v-clojure/</a>
</li>

<li>Leiningen: nástroj pro správu projektů napsaných v Clojure (2)<br />
<a href="http://www.root.cz/clanky/leiningen-nastroj-pro-spravu-projektu-napsanych-v-clojure-2/">http://www.root.cz/clanky/leiningen-nastroj-pro-spravu-projektu-napsanych-v-clojure-2/</a>
</li>

<li>Leiningen: nástroj pro správu projektů napsaných v Clojure (3)<br />
<a href="http://www.root.cz/clanky/leiningen-nastroj-pro-spravu-projektu-napsanych-v-clojure-3/">http://www.root.cz/clanky/leiningen-nastroj-pro-spravu-projektu-napsanych-v-clojure-3/</a>
</li>

<li>Leiningen: nástroj pro správu projektů napsaných v Clojure (4)<br />
<a href="http://www.root.cz/clanky/leiningen-nastroj-pro-spravu-projektu-napsanych-v-clojure-4/">http://www.root.cz/clanky/leiningen-nastroj-pro-spravu-projektu-napsanych-v-clojure-4/</a>
</li>

<li>Leiningen: nástroj pro správu projektů napsaných v Clojure (5)<br />
<a href="http://www.root.cz/clanky/leiningen-nastroj-pro-spravu-projektu-napsanych-v-clojure-5/">http://www.root.cz/clanky/leiningen-nastroj-pro-spravu-projektu-napsanych-v-clojure-5/</a>
</li>

<li>Leiningen: nástroj pro správu projektů napsaných v Clojure (6)<br />
<a href="http://www.root.cz/clanky/leiningen-nastroj-pro-spravu-projektu-napsanych-v-clojure-6/">http://www.root.cz/clanky/leiningen-nastroj-pro-spravu-projektu-napsanych-v-clojure-6/</a>
</li>

<li>Programovací jazyk Clojure a databáze (1.část)<br />
<a href="http://www.root.cz/clanky/programovaci-jazyk-clojure-a-databaze-1-cast/">http://www.root.cz/clanky/programovaci-jazyk-clojure-a-databaze-1-cast/</a>
</li>

<li>Pluginy pro Leiningen<br />
<a href="http://www.root.cz/clanky/leiningen-nastroj-pro-spravu-projektu-napsanych-v-clojure-pluginy-pro-leiningen/">http://www.root.cz/clanky/leiningen-nastroj-pro-spravu-projektu-napsanych-v-clojure-pluginy-pro-leiningen/</a>
</li>

<li>Programovací jazyk Clojure a knihovny pro práci s vektory a maticemi<br />
<a href="http://www.root.cz/clanky/programovaci-jazyk-clojure-a-knihovny-pro-praci-s-vektory-a-maticemi/">http://www.root.cz/clanky/programovaci-jazyk-clojure-a-knihovny-pro-praci-s-vektory-a-maticemi/</a>
</li>

<li>Programovací jazyk Clojure a knihovny pro práci s vektory a maticemi (2)<br />
<a href="http://www.root.cz/clanky/programovaci-jazyk-clojure-a-knihovny-pro-praci-s-vektory-a-maticemi-2/">http://www.root.cz/clanky/programovaci-jazyk-clojure-a-knihovny-pro-praci-s-vektory-a-maticemi-2/</a>
</li>

<li>Programovací jazyk Clojure: syntéza procedurálních textur s využitím knihovny Clisk<br />
<a href="http://www.root.cz/clanky/programovaci-jazyk-clojure-synteza-proceduralnich-textur-s-vyuzitim-knihovny-clisk/">http://www.root.cz/clanky/programovaci-jazyk-clojure-synteza-proceduralnich-textur-s-vyuzitim-knihovny-clisk/</a>
</li>

<li>Programovací jazyk Clojure: syntéza procedurálních textur s využitím knihovny Clisk (2)<br />
<a href="http://www.root.cz/clanky/programovaci-jazyk-clojure-synteza-proceduralnich-textur-s-vyuzitim-knihovny-clisk-2/">http://www.root.cz/clanky/programovaci-jazyk-clojure-synteza-proceduralnich-textur-s-vyuzitim-knihovny-clisk-2/</a>
</li>

<li>Seesaw: knihovna pro snadnou tvorbu GUI v jazyce Clojure<br />
<a href="http://www.root.cz/clanky/seesaw-knihovna-pro-snadnou-tvorbu-gui-v-jazyce-clojure/">http://www.root.cz/clanky/seesaw-knihovna-pro-snadnou-tvorbu-gui-v-jazyce-clojure/</a>
</li>

<li>Seesaw: knihovna pro snadnou tvorbu GUI v jazyce Clojure (2)<br />
<a href="http://www.root.cz/clanky/seesaw-knihovna-pro-snadnou-tvorbu-gui-v-jazyce-clojure-2/">http://www.root.cz/clanky/seesaw-knihovna-pro-snadnou-tvorbu-gui-v-jazyce-clojure-2/</a>
</li>

<li>Seesaw: knihovna pro snadnou tvorbu GUI v jazyce Clojure (3)<br />
<a href="http://www.root.cz/clanky/seesaw-knihovna-pro-snadnou-tvorbu-gui-v-jazyce-clojure-3/">http://www.root.cz/clanky/seesaw-knihovna-pro-snadnou-tvorbu-gui-v-jazyce-clojure-3/</a>
</li>

<li>Programovací jazyk Clojure a práce s Gitem<br />
<a href="http://www.root.cz/clanky/programovaci-jazyk-clojure-a-prace-s-gitem/">http://www.root.cz/clanky/programovaci-jazyk-clojure-a-prace-s-gitem/</a>
</li>

<li>Programovací jazyk Clojure: syntéza procedurálních textur s využitím knihovny Clisk (dokončení)<br />
<a href="http://www.root.cz/clanky/programovaci-jazyk-clojure-synteza-proceduralnich-textur-s-vyuzitim-knihovny-clisk-dokonceni/">http://www.root.cz/clanky/programovaci-jazyk-clojure-synteza-proceduralnich-textur-s-vyuzitim-knihovny-clisk-dokonceni/</a>
</li>

<li>Programovací jazyk Clojure a práce s Gitem (2)<br />
<a href="http://www.root.cz/clanky/programovaci-jazyk-clojure-a-prace-s-gitem-2/">http://www.root.cz/clanky/programovaci-jazyk-clojure-a-prace-s-gitem-2/</a>
</li>

<li>Programovací jazyk Clojure – triky při práci s řetězci<br />
<a href="http://www.root.cz/clanky/programovaci-jazyk-clojure-triky-pri-praci-s-retezci/">http://www.root.cz/clanky/programovaci-jazyk-clojure-triky-pri-praci-s-retezci/</a>
</li>

<li>Programovací jazyk Clojure – triky při práci s kolekcemi<br />
<a href="http://www.root.cz/clanky/programovaci-jazyk-clojure-triky-pri-praci-s-kolekcemi/">http://www.root.cz/clanky/programovaci-jazyk-clojure-triky-pri-praci-s-kolekcemi/</a>
</li>

<li>Programovací jazyk Clojure – práce s mapami a množinami<br />
<a href="http://www.root.cz/clanky/programovaci-jazyk-clojure-prace-s-mapami-a-mnozinami/">http://www.root.cz/clanky/programovaci-jazyk-clojure-prace-s-mapami-a-mnozinami/</a>
</li>

<li>Programovací jazyk Clojure – základy zpracování XML<br />
<a href="http://www.root.cz/clanky/programovaci-jazyk-clojure-zaklady-zpracovani-xml/">http://www.root.cz/clanky/programovaci-jazyk-clojure-zaklady-zpracovani-xml/</a>
</li>

<li>Programovací jazyk Clojure – testování s využitím knihovny Expectations<br />
<a href="http://www.root.cz/clanky/programovaci-jazyk-clojure-testovani-s-vyuzitim-knihovny-expectations/">http://www.root.cz/clanky/programovaci-jazyk-clojure-testovani-s-vyuzitim-knihovny-expectations/</a>
</li>

<li>Programovací jazyk Clojure – některé užitečné triky použitelné (nejenom) v&nbsp;testech<br />
<a href="http://www.root.cz/clanky/programovaci-jazyk-clojure-nektere-uzitecne-triky-pouzitelne-nejenom-v-testech/">http://www.root.cz/clanky/programovaci-jazyk-clojure-nektere-uzitecne-triky-pouzitelne-nejenom-v-testech/</a>
</li>

<li>Enlive – výkonný šablonovací systém pro jazyk Clojure<br/>
<a href="http://www.root.cz/clanky/enlive-vykonny-sablonovaci-system-pro-jazyk-clojure/">http://www.root.cz/clanky/enlive-vykonny-sablonovaci-system-pro-jazyk-clojure/</a>
</li>

<li>Nástroj Leiningen a programovací jazyk Clojure: tvorba vlastních knihoven pro veřejný repositář Clojars<br />
<a href="http://www.root.cz/clanky/nastroj-leiningen-a-programovaci-jazyk-clojure-tvorba-vlastnich-knihoven-pro-verejny-repositar-clojars/">http://www.root.cz/clanky/nastroj-leiningen-a-programovaci-jazyk-clojure-tvorba-vlastnich-knihoven-pro-verejny-repositar-clojars/</a>
</li>

<li>Novinky v Clojure verze 1.8.0<br />
<a href="http://www.root.cz/clanky/novinky-v-clojure-verze-1-8-0/">http://www.root.cz/clanky/novinky-v-clojure-verze-1-8-0/</a>
</li>

<li>Asynchronní programování v&nbsp;Clojure s&nbsp;využitím knihovny core.async<br />
<a href="http://www.root.cz/clanky/asynchronni-programovani-v-clojure-s-vyuzitim-knihovny-core-async/">http://www.root.cz/clanky/asynchronni-programovani-v-clojure-s-vyuzitim-knihovny-core-async/</a>
</li>

<li>Asynchronní programování v&nbsp;Clojure s&nbsp;využitím knihovny core.async (pokračování)<br />
<a href="http://www.root.cz/clanky/asynchronni-programovani-v-clojure-s-vyuzitim-knihovny-core-async-pokracovani/">http://www.root.cz/clanky/asynchronni-programovani-v-clojure-s-vyuzitim-knihovny-core-async-pokracovani/</a>
</li>

<li>Asynchronní programování v Clojure s využitím knihovny core.async (dokončení)<br />
<a href="http://www.root.cz/clanky/asynchronni-programovani-v-clojure-s-vyuzitim-knihovny-core-async-dokonceni/">http://www.root.cz/clanky/asynchronni-programovani-v-clojure-s-vyuzitim-knihovny-core-async-dokonceni/</a>
</li>

<li>Vytváříme IRC bota v programovacím jazyce Clojure<br />
<a href="http://www.root.cz/clanky/vytvarime-irc-bota-v-programovacim-jazyce-clojure/">http://www.root.cz/clanky/vytvarime-irc-bota-v-programovacim-jazyce-clojure/</a>
</li>

<li>Gorilla REPL: interaktivní prostředí pro programovací jazyk Clojure<br />
<a href="https://www.root.cz/clanky/gorilla-repl-interaktivni-prostredi-pro-programovaci-jazyk-clojure/">https://www.root.cz/clanky/gorilla-repl-interaktivni-prostredi-pro-programovaci-jazyk-clojure/</a>
</li>

<li>Multimetody v Clojure aneb polymorfismus bez použití OOP<br />
<a href="https://www.root.cz/clanky/multimetody-v-clojure-aneb-polymorfismus-bez-pouziti-oop/">https://www.root.cz/clanky/multimetody-v-clojure-aneb-polymorfismus-bez-pouziti-oop/</a>
</li>

<li>Práce s externími Java archivy v programovacím jazyku Clojure<br />
<a href="https://www.root.cz/clanky/prace-s-externimi-java-archivy-v-programovacim-jazyku-clojure/">https://www.root.cz/clanky/prace-s-externimi-java-archivy-v-programovacim-jazyku-clojure/</a>
</li>

<li>Pixie: lehký skriptovací jazyk s „kouzelnými“ schopnostmi<br />
<a href="https://www.root.cz/clanky/pixie-lehky-skriptovaci-jazyk-s-kouzelnymi-schopnostmi/">https://www.root.cz/clanky/pixie-lehky-skriptovaci-jazyk-s-kouzelnymi-schopnostmi/</a>
</li>

<li>Programovací jazyk Pixie: funkce ze základní knihovny a použití FFI<br />
<a href="https://www.root.cz/clanky/programovaci-jazyk-pixie-funkce-ze-zakladni-knihovny-a-pouziti-ffi/">https://www.root.cz/clanky/programovaci-jazyk-pixie-funkce-ze-zakladni-knihovny-a-pouziti-ffi/</a>
</li>

<li>Novinky v Clojure verze 1.9.0<br />
<a href="https://www.root.cz/clanky/novinky-v-clojure-verze-1-9-0/">https://www.root.cz/clanky/novinky-v-clojure-verze-1-9-0/</a>
</li>

<li>Validace dat s&nbsp;využitím knihovny spec v&nbsp;Clojure 1.9.0<br />
<a href="https://www.root.cz/clanky/validace-dat-s-vyuzitim-knihovny-spec-v-clojure-1-9-0/">https://www.root.cz/clanky/validace-dat-s-vyuzitim-knihovny-spec-v-clojure-1-9-0/</a>
</li>

<li>Knihovny a moduly usnadňující testování aplikací naprogramovaných v jazyce Clojure<br />
<a href="https://www.root.cz/clanky/knihovny-a-moduly-usnadnujici-testovani-aplikaci-naprogramovanych-v-jazyce-clojure/">https://www.root.cz/clanky/knihovny-a-moduly-usnadnujici-testovani-aplikaci-naprogramovanych-v-jazyce-clojure/</a>
</li>

</ol>



<p><a name="k20"></a></p>
<h2 id="k20">20. Odkazy na Internetu</h2>

<ol>

<li>BusinessReadableDSL<br />
<a href="https://martinfowler.com/bliki/BusinessReadableDSL.html">https://martinfowler.com/bliki/BusinessReadableDSL.html</a>
</li>

<li>Gherkin: Feature &ndash; introduction<br />
<a href="https://github.com/cucumber/cucumber/wiki/Feature-Introduction">https://github.com/cucumber/cucumber/wiki/Feature-Introduction</a>
</li>

<li>BDD 101: The Gherkin Language<br />
<a href="https://automationpanda.com/2017/01/26/bdd-101-the-gherkin-language/">https://automationpanda.com/2017/01/26/bdd-101-the-gherkin-language/</a>
</li>

<li>Gherkin: Given/When/Then<br />
<a href="https://github.com/cucumber/cucumber/wiki/Given-When-Then">https://github.com/cucumber/cucumber/wiki/Given-When-Then</a>
</li>

<li>Humane test output for clojure.test<br />
<a href="https://github.com/pjstadig/humane-test-output">https://github.com/pjstadig/humane-test-output</a>
</li>

<li>iota<br />
<a href="https://github.com/juxt/iota">https://github.com/juxt/iota</a>
</li>

<li>5 Differences between clojure.spec and Schema<br />
<a href="https://lispcast.com/clojure.spec-vs-schema/">https://lispcast.com/clojure.spec-vs-schema/</a>
</li>

<li>Schema: Clojure(Script) library for declarative data description and validation<br />
<a href="https://github.com/plumatic/schema">https://github.com/plumatic/schema</a>
</li>

<li>Zip archiv s&nbsp;Clojure 1.9.0<br />
<a href="http://repo1.maven.org/maven2/org/clojure/clojure/1.9.0/clojure-1.9.0.zip">http://repo1.maven.org/maven2/org/clojure/clojure/1.9.0/clojure-1.9.0.zip</a>
</li>

<li>Clojure 1.9 is now available<br />
<a href="https://clojure.org/news/2017/12/08/clojure19">https://clojure.org/news/2017/12/08/clojure19</a>
</li>

<li>Deps and CLI Guide<br />
<a href="https://clojure.org/guides/deps_and_cli">https://clojure.org/guides/deps_and_cli</a>
</li>

<li>Changes to Clojure in Version 1.9<br />
<a href="https://github.com/clojure/clojure/blob/master/changes.md">https://github.com/clojure/clojure/blob/master/changes.md</a>
</li>

<li>clojure.spec - Rationale and Overview<br />
<a href="https://clojure.org/about/spec">https://clojure.org/about/spec</a>
</li>

<li>Zip archiv s&nbsp;Clojure 1.8.0<br />
<a href="http://repo1.maven.org/maven2/org/clojure/clojure/1.8.0/clojure-1.8.0.zip">http://repo1.maven.org/maven2/org/clojure/clojure/1.8.0/clojure-1.8.0.zip</a>
</li>

<li>Clojure 1.8 is now available<br />
<a href="http://clojure.org/news/2016/01/19/clojure18">http://clojure.org/news/2016/01/19/clojure18</a>
</li>

<li>Socket Server REPL<br />
<a href="http://dev.clojure.org/display/design/Socket+Server+REPL">http://dev.clojure.org/display/design/Socket+Server+REPL</a>
</li>

<li>CLJ-1671: Clojure socket server<br />
<a href="http://dev.clojure.org/jira/browse/CLJ-1671">http://dev.clojure.org/jira/browse/CLJ-1671</a>
</li>

<li>CLJ-1449: Add clojure.string functions for portability to ClojureScript<br />
<a href="http://dev.clojure.org/jira/browse/CLJ-1449">http://dev.clojure.org/jira/browse/CLJ-1449</a>
</li>

<li>Launching a Socket Server<br />
<a href="http://clojure.org/reference/repl_and_main#_launching_a_socket_server">http://clojure.org/reference/repl_and_main#_launching_a_socket_server</a>
</li>

<li>API for clojure.string<br />
<a href="http://clojure.github.io/clojure/branch-master/clojure.string-api.html">http://clojure.github.io/clojure/branch-master/clojure.string-api.html</a>
</li>

<li>Clojars:<br />
<a href="https://clojars.org/">https://clojars.org/</a>
</li>

<li>Seznam knihoven na Clojars:<br />
<a href="https://clojars.org/projects">https://clojars.org/projects</a>
</li>

<li>Clojure Cookbook: Templating HTML with Enlive<br />
<a href="https://github.com/clojure-cookbook/clojure-cookbook/blob/master/07_webapps/7-11_enlive.asciidoc">https://github.com/clojure-cookbook/clojure-cookbook/blob/master/07_webapps/7-11_enlive.asciidoc</a>
</li>

<li>An Introduction to Enlive<br />
<a href="https://github.com/swannodette/enlive-tutorial/">https://github.com/swannodette/enlive-tutorial/</a>
</li>

<li>Enlive na GitHubu<br />
<a href="https://github.com/cgrand/enlive">https://github.com/cgrand/enlive</a>
</li>

<li>Expectations: příklady atd.<br />
<a href="http://jayfields.com/expectations/">http://jayfields.com/expectations/</a>
</li>

<li>Expectations na GitHubu<br />
<a href="https://github.com/jaycfields/expectations">https://github.com/jaycfields/expectations</a>
</li>

<li>Lein-expectations na GitHubu<br />
<a href="https://github.com/gar3thjon3s/lein-expectations">https://github.com/gar3thjon3s/lein-expectations</a>
</li>

<li>Testing Clojure With Expectations<br />
<a href="https://semaphoreci.com/blog/2014/09/23/testing-clojure-with-expectations.html">https://semaphoreci.com/blog/2014/09/23/testing-clojure-with-expectations.html</a>
</li>

<li>Clojure testing TDD/BDD libraries: clojure.test vs Midje vs Expectations vs Speclj<br />
<a href="https://www.reddit.com/r/Clojure/comments/1viilt/clojure_testing_tddbdd_libraries_clojuretest_vs/">https://www.reddit.com/r/Clojure/comments/1viilt/clojure_testing_tddbdd_libraries_clojuretest_vs/</a>
</li>

<li>Testing: One assertion per test<br />
<a href="http://blog.jayfields.com/2007/06/testing-one-assertion-per-test.html">http://blog.jayfields.com/2007/06/testing-one-assertion-per-test.html</a>
</li>

<li>Rewriting Your Test Suite in Clojure in 24 hours<br />
<a href="http://blog.circleci.com/rewriting-your-test-suite-in-clojure-in-24-hours/">http://blog.circleci.com/rewriting-your-test-suite-in-clojure-in-24-hours/</a>
</li>

<li>Clojure doc: zipper<br />
<a href="http://clojuredocs.org/clojure.zip/zipper">http://clojuredocs.org/clojure.zip/zipper</a>
</li>

<li>Clojure doc: parse<br />
<a href="http://clojuredocs.org/clojure.xml/parse">http://clojuredocs.org/clojure.xml/parse</a>
</li>

<li>Clojure doc: xml-zip<br />
<a href="http://clojuredocs.org/clojure.zip/xml-zip">http://clojuredocs.org/clojure.zip/xml-zip</a>
</li>

<li>Clojure doc: xml-seq<br />
<a href="http://clojuredocs.org/clojure.core/xml-seq">http://clojuredocs.org/clojure.core/xml-seq</a>
</li>

<li>Parsing XML in Clojure<br />
<a href="https://github.com/clojuredocs/guides">https://github.com/clojuredocs/guides</a>
</li>

<li>Clojure Zipper Over Nested Vector<br />
<a href="https://vitalyper.wordpress.com/2010/11/23/clojure-zipper-over-nested-vector/">https://vitalyper.wordpress.com/2010/11/23/clojure-zipper-over-nested-vector/</a>
</li>

<li>Understanding Clojure's PersistentVector implementation<br />
<a href="http://blog.higher-order.net/2009/02/01/understanding-clojures-persistentvector-implementation">http://blog.higher-order.net/2009/02/01/understanding-clojures-persistentvector-implementation</a>
</li>

<li>Understanding Clojure's PersistentHashMap (deftwice...)<br />
<a href="http://blog.higher-order.net/2009/09/08/understanding-clojures-persistenthashmap-deftwice.html">http://blog.higher-order.net/2009/09/08/understanding-clojures-persistenthashmap-deftwice.html</a>
</li>

<li>Assoc and Clojure's PersistentHashMap: part ii<br />
<a href="http://blog.higher-order.net/2010/08/16/assoc-and-clojures-persistenthashmap-part-ii.html">http://blog.higher-order.net/2010/08/16/assoc-and-clojures-persistenthashmap-part-ii.html</a>
</li>

<li>Ideal Hashtrees (paper)<br />
<a href="http://lampwww.epfl.ch/papers/idealhashtrees.pdf">http://lampwww.epfl.ch/papers/idealhashtrees.pdf</a>
</li>

<li>Clojure home page<br />
<a href="http://clojure.org/">http://clojure.org/</a>
</li>

<li>Clojure (downloads)<br />
<a href="http://clojure.org/downloads">http://clojure.org/downloads</a>
</li>

<li>Clojure Sequences<br />
<a href="http://clojure.org/sequences">http://clojure.org/sequences</a>
</li>

<li>Clojure Data Structures<br />
<a href="http://clojure.org/data_structures">http://clojure.org/data_structures</a>
</li>

<li>The Structure and Interpretation of Computer Programs: 2.2.1  Representing Sequences<br />
<a href="http://mitpress.mit.edu/sicp/full-text/book/book-Z-H-15.html#%_sec_2.2.1">http://mitpress.mit.edu/sicp/full-text/book/book-Z-H-15.html#%_sec_2.2.1</a>
</li>

<li>The Structure and Interpretation of Computer Programs: 3.3.1  Mutable List Structure<br />
<a href="http://mitpress.mit.edu/sicp/full-text/book/book-Z-H-22.html#%_sec_3.3.1">http://mitpress.mit.edu/sicp/full-text/book/book-Z-H-22.html#%_sec_3.3.1</a>
</li>

<li>Clojure - Functional Programming for the JVM<br />
<a href="http://java.ociweb.com/mark/clojure/article.html">http://java.ociweb.com/mark/clojure/article.html</a>
</li>

<li>Clojure quick reference<br />
<a href="http://faustus.webatu.com/clj-quick-ref.html">http://faustus.webatu.com/clj-quick-ref.html</a>
</li>

<li>4Clojure<br />
<a href="http://www.4clojure.com/">http://www.4clojure.com/</a>
</li>

<li>ClojureDoc (rozcestník s&nbsp;dokumentací jazyka Clojure)<br />
<a href="http://clojuredocs.org/">http://clojuredocs.org/</a>
</li>

<li>Clojure (na Wikipedia EN)<br />
<a href="http://en.wikipedia.org/wiki/Clojure">http://en.wikipedia.org/wiki/Clojure</a>
</li>

<li>Clojure (na Wikipedia CS)<br />
<a href="http://cs.wikipedia.org/wiki/Clojure">http://cs.wikipedia.org/wiki/Clojure</a>
</li>

<li>SICP (The Structure and Interpretation of Computer Programs)<br />
<a href="http://mitpress.mit.edu/sicp/">http://mitpress.mit.edu/sicp/</a>
</li>

<li>Pure function<br />
<a href="http://en.wikipedia.org/wiki/Pure_function">http://en.wikipedia.org/wiki/Pure_function</a>
</li>

<li>Funkcionální programování<br />
<a href="http://cs.wikipedia.org/wiki/Funkcionální_programování">http://cs.wikipedia.org/wiki/Funkcionální_programování</a>
</li>

<li>Čistě funkcionální (datové struktury, jazyky, programování)<br />
<a href="http://cs.wikipedia.org/wiki/Čistě_funkcionální">http://cs.wikipedia.org/wiki/Čistě_funkcionální</a>
</li>

<li>Clojure Macro Tutorial (Part I, Getting the Compiler to Write Your Code For You)<br />
<a href="http://www.learningclojure.com/2010/09/clojure-macro-tutorial-part-i-getting.html">http://www.learningclojure.com/2010/09/clojure-macro-tutorial-part-i-getting.html</a>
</li>

<li>Clojure Macro Tutorial (Part II: The Compiler Strikes Back)<br />
<a href="http://www.learningclojure.com/2010/09/clojure-macro-tutorial-part-ii-compiler.html">http://www.learningclojure.com/2010/09/clojure-macro-tutorial-part-ii-compiler.html</a>
</li>

<li>Clojure Macro Tutorial (Part III: Syntax Quote)<br />
<a href="http://www.learningclojure.com/2010/09/clojure-macro-tutorial-part-ii-syntax.html">http://www.learningclojure.com/2010/09/clojure-macro-tutorial-part-ii-syntax.html</a>
</li>

<li>Tech behind Tech: Clojure Macros Simplified<br />
<a href="http://techbehindtech.com/2010/09/28/clojure-macros-simplified/">http://techbehindtech.com/2010/09/28/clojure-macros-simplified/</a>
</li>

<li>Fatvat - Exploring functional programming: Clojure Macros<br />
<a href="http://www.fatvat.co.uk/2009/02/clojure-macros.html">http://www.fatvat.co.uk/2009/02/clojure-macros.html</a>
</li>

<li>Eulerovo číslo<br />
<a href="http://cs.wikipedia.org/wiki/Eulerovo_číslo">http://cs.wikipedia.org/wiki/Eulerovo_číslo</a>
</li>

<li>List comprehension<br />
<a href="http://en.wikipedia.org/wiki/List_comprehension">http://en.wikipedia.org/wiki/List_comprehension</a>
</li>

<li>List Comprehensions in Clojure<br />
<a href="http://asymmetrical-view.com/2008/11/18/list-comprehensions-in-clojure.html">http://asymmetrical-view.com/2008/11/18/list-comprehensions-in-clojure.html</a>
</li>

<li>Clojure Programming Concepts: List Comprehension<br />
<a href="http://en.wikibooks.org/wiki/Clojure_Programming/Concepts#List_Comprehension">http://en.wikibooks.org/wiki/Clojure_Programming/Concepts#List_Comprehension</a>
</li>

<li>Clojure core API: for macro<br />
<a href="http://clojure.github.com/clojure/clojure.core-api.html#clojure.core/for">http://clojure.github.com/clojure/clojure.core-api.html#clojure.core/for</a>
</li>

<li>cirrus machina - The Clojure for macro<br />
<a href="http://www.cirrusmachina.com/blog/comment/the-clojure-for-macro/">http://www.cirrusmachina.com/blog/comment/the-clojure-for-macro/</a>
</li>

<li>Riastradh's Lisp Style Rules<br />
<a href="http://mumble.net/~campbell/scheme/style.txt">http://mumble.net/~campbell/scheme/style.txt</a>
</li>

<li>Dynamic Languages Strike Back<br />
<a href="http://steve-yegge.blogspot.cz/2008/05/dynamic-languages-strike-back.html">http://steve-yegge.blogspot.cz/2008/05/dynamic-languages-strike-back.html</a>
</li>

<li>Scripting: Higher Level Programming for the 21st Century<br />
<a href="http://www.tcl.tk/doc/scripting.html">http://www.tcl.tk/doc/scripting.html</a>
</li>

<li>Java Virtual Machine Support for Non-Java Languages<br />
<a href="http://docs.oracle.com/javase/7/docs/technotes/guides/vm/multiple-language-support.html">http://docs.oracle.com/javase/7/docs/technotes/guides/vm/multiple-language-support.html</a>
</li>

<li>Třída java.lang.String<br />
<a href="http://docs.oracle.com/javase/7/docs/api/java/lang/String.html">http://docs.oracle.com/javase/7/docs/api/java/lang/String.html</a>
</li>

<li>Třída java.lang.StringBuffer<br />
<a href="http://docs.oracle.com/javase/7/docs/api/java/lang/StringBuffer.html">http://docs.oracle.com/javase/7/docs/api/java/lang/StringBuffer.html</a>
</li>

<li>Třída java.lang.StringBuilder<br />
<a href="http://docs.oracle.com/javase/7/docs/api/java/lang/StringBuilder.html">http://docs.oracle.com/javase/7/docs/api/java/lang/StringBuilder.html</a>
</li>

<li>StringBuffer versus String<br />
<a href="http://www.javaworld.com/article/2076072/build-ci-sdlc/stringbuffer-versus-string.html">http://www.javaworld.com/article/2076072/build-ci-sdlc/stringbuffer-versus-string.html</a>
</li>

<li>Threading macro (dokumentace k&nbsp;jazyku Clojure)<br />
<a href="https://clojure.github.io/clojure/clojure.core-api.html#clojure.core/-&gt;">https://clojure.github.io/clojure/clojure.core-api.html#clojure.core/-&gt;</a>
</li>

<li>Understanding the Clojure -&gt; macro<br />
<a href="http://blog.fogus.me/2009/09/04/understanding-the-clojure-macro/">http://blog.fogus.me/2009/09/04/understanding-the-clojure-macro/</a>
</li>

<li>clojure.inspector<br />
<a href="http://clojure.github.io/clojure/clojure.inspector-api.html">http://clojure.github.io/clojure/clojure.inspector-api.html</a>
</li>

<li>The Clojure Toolbox<br />
<a href="http://www.clojure-toolbox.com/">http://www.clojure-toolbox.com/</a>
</li>

<li>Unit Testing in Clojure<br />
<a href="http://nakkaya.com/2009/11/18/unit-testing-in-clojure/">http://nakkaya.com/2009/11/18/unit-testing-in-clojure/</a>
</li>

<li>Testing in Clojure (Part-1: Unit testing)<br />
<a href="http://blog.knoldus.com/2014/03/22/testing-in-clojure-part-1-unit-testing/">http://blog.knoldus.com/2014/03/22/testing-in-clojure-part-1-unit-testing/</a>
</li>

<li>API for clojure.test - Clojure v1.6 (stable)<br />
<a href="https://clojure.github.io/clojure/clojure.test-api.html">https://clojure.github.io/clojure/clojure.test-api.html</a>
</li>

<li>Leiningen: úvodní stránka<br />
<a href="http://leiningen.org/">http://leiningen.org/</a>
</li>

<li>Leiningen: Git repository<br />
<a href="https://github.com/technomancy/leiningen">https://github.com/technomancy/leiningen</a>
</li>

<li>leiningen-win-installer<br />
<a href="http://leiningen-win-installer.djpowell.net/">http://leiningen-win-installer.djpowell.net/</a>
</li>

<li>Clojure.org: Vars and the Global Environment<br />
<a href="http://clojure.org/Vars">http://clojure.org/Vars</a>
</li>

<li>Clojure.org: Refs and Transactions<br />
<a href="http://clojure.org/Refs">http://clojure.org/Refs</a>
</li>

<li>Clojure.org: Atoms<br />
<a href="http://clojure.org/Atoms">http://clojure.org/Atoms</a>
</li>

<li>Clojure.org: Agents as Asynchronous Actions<br />
<a href="http://clojure.org/agents">http://clojure.org/agents</a>
</li>

<li>Transient Data Structures
<a href="http://clojure.org/transients">http://clojure.org/transients</a>
</li>

</ol>



<p></p><p></p>
<p><small>Autor: <a href="http://www.fit.vutbr.cz/~tisnovpa">Pavel Tišnovský</a> &nbsp; 2018</small></p>
</body>
</html>

