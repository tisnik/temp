<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
        "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html>
<head>
<title></title>
<meta name="Author" content="Pavel Tisnovsky" />
<meta name="Generator" content="vim" />
<meta http-equiv="content-type" content="text/html; charset=utf-8" />
<style type="text/css">
         body {color:#000000; background:#ffffff;}
         h1  {font-family: arial, helvetica, sans-serif; color:#ffffff; background-color:#c00000; text-align:center; padding-left:1em}
         h2  {font-family: arial, helvetica, sans-serif; color:#ffffff; background-color:#0000c0; padding-left:1em; text-align:left}
         h3  {font-family: arial, helvetica, sans-serif; color:#000000; background-color:#c0c0c0; padding-left:1em; text-align:left}
         h4  {font-family: arial, helvetica, sans-serif; color:#000000; background-color:#e0e0e0; padding-left:1em; text-align:left}
         a   {font-family: arial, helvetica, sans-serif;}
         li  {font-family: arial, helvetica, sans-serif; color:#000000; text-align:justify; width:450px;}
         ol  {font-family: arial, helvetica, sans-serif; color:#000000; text-align:justify; width:450px;}
         ul  {font-family: arial, helvetica, sans-serif; color:#000000; text-align:justify; width:450px;}
         p   {font-family: arial, helvetica, sans-serif; color:#000000; text-align:justify;}
         pre {background:#e0e0e0}
</style>
</head>

<body>

<h1></h1>

<h3>Pavel Tišnovský</h3>

<p></p>

<h1>Úvodník</h1>

<p></p>



<h2>Obsah</h2>

<p><a href="#k01">*** 1. </a></p>
<p><a href="#k02">2. Speciální forma <strong>if</strong></a></p>
<p><a href="#k03">3. Použití speciální formy <strong>if</strong> s&nbsp;oběma větvemi a problematika více volaných funkcí ve větvích</a></p>
<p><a href="#k04">4. Makra <strong>when</strong> a <strong>when-not</strong></a></p>
<p><a href="#k05">5. Kombinace speciálních forem <strong>if</strong> a <strong>let</strong></a></p>
<p><a href="#k06">*** 6. </a></p>
<p><a href="#k07">*** 7. </a></p>
<p><a href="#k08">*** 8. </a></p>
<p><a href="#k09">*** 9. </a></p>
<p><a href="#k10">*** 10. </a></p>
<p><a href="#k11">*** 11. </a></p>
<p><a href="#k12">*** 12. </a></p>
<p><a href="#k13">*** 13. </a></p>
<p><a href="#k14">*** 14. </a></p>
<p><a href="#k15">*** 15. </a></p>
<p><a href="#k16">*** 16. </a></p>
<p><a href="#k17">17. Dodatek na závěr: speciální formy jazyka Clojure, porovnání se Scheme</a></p>
<p><a href="#k18">18. Repositář s&nbsp;demonstračními příklady</a></p>
<p><a href="#k19">19. Odkazy na předchozí části seriálu o programovacím jazyku Clojure</a></p>
<p><a href="#k20">20. Odkazy na Internetu</a></p>



<p><a name="k01"></a></p>
<h2 id="k01">1. </h2>

<p></p>



<p></p>

<table>
<tr><th> #</th><th>Konstrukce </th><th>Kapitola</th><th>Typ</th><th>Stručný popis</th></tr>
<tr><td> 1</td><td>if         </td><td><a href="#k02">2</a></td><td>speciální forma</td><td>základní rozhodovací konstrukce, základ pro další makra</td></tr>
<tr><td> 2</td><td>if+do      </td><td><a href="#k03">3</a></td><td>dvě speciální formy</td><td>použito ve chvíli, kdy je nutné do jedné větve či obou větví zapsat více výrazů</td></tr>
<tr><td> 3</td><td>if-let     </td><td><a href="#k05">5</a></td><td>makro</td><td>kombinace speciálních forem <strong>if</strong> a <strong>let</strong></td></tr>
<tr><td> 4</td><td>if-some    </td><td></td><td>makro</td><td></td></tr>
<tr><td>&nbsp;</td><td>&nbsp; </td><td></td><td>&nbsp;</td></tr>
<tr><td> 5</td><td>and        </td><td></td><td>makro</td><td></td></tr>
<tr><td> 6</td><td>or         </td><td></td><td>makro</td><td></td></tr>
<tr><td>&nbsp;</td><td>&nbsp; </td><td></td><td>&nbsp;</td></tr>
<tr><td> 7</td><td>when       </td><td><a href="#k04">4</a></td><td>makro</td><td>vhodná náhrada za <strong>if</strong> s&nbsp;jedinou větví s&nbsp;více výrazy</td></tr>
<tr><td> 8</td><td>when-not   </td><td><a href="#k04">4</a></td><td>makro</td><td>vhodná náhrada za <strong>if-not</strong> s&nbsp;jedinou větví s&nbsp;více výrazy</td></tr>
<tr><td> 9</td><td>when-let   </td><td></td><td></td><td></td></tr>
<tr><td>10</td><td>when-some  </td><td></td><td></td><td></td></tr>
<tr><td>11</td><td>when-first </td><td></td><td></td></tr>
<tr><td>&nbsp;</td><td>&nbsp; </td><td></td><td>&nbsp;</td></tr>
<tr><td>12</td><td>cond       </td><td></td><td></td><td></td></tr>
<tr><td>13</td><td>cond + else</td><td></td><td></td><td></td></tr>
<tr><td>14</td><td>condp      </td><td></td><td></td><td></td></tr>
<tr><td>15</td><td>conde      </td><td></td><td></td><td></td></tr>
<tr><td>16</td><td>condu      </td><td></td><td></td><td></td></tr>
<tr><td>17</td><td>conda      </td><td></td><td></td><td></td></tr>
<tr><td>&nbsp;</td><td>&nbsp; </td><td></td><td>&nbsp;</td></tr>
<tr><td>18</td><td>cond-&gt;  </td><td></td><td></td><td></td></tr>
<tr><td>19</td><td>cond-&gt;&gt;</td><td></td></tr>
<tr><td>&nbsp;</td><td>&nbsp; </td><td>&nbsp;</td></tr>
<tr><td>20</td><td>case       </td><td></td><td></td></tr>
<tr><td>21</td><td>case + else</td><td></td></tr>
<tr><td>&nbsp;</td><td>&nbsp; </td><td>&nbsp;</td></tr>
<tr><td>22</td><td>cond-table </td><td></td><td>makro</td><td>nová nestandardní konstrukce se zdrojovým kódem zmíněným na konci navazujícího článku</td></tr>
</table>



<p><a name="k02"></a></p>
<h2 id="k02">2. Speciální forma <strong>if</strong></h2>

<p>Všechna makra popsaná v&nbsp;dalším textu jsou založena na využití speciální
formy <strong>if</strong>, jejíž různé varianty si popíšeme v&nbsp;této
kapitole i v&nbsp;kapitolách navazujících.</p>

<p>Nejprve vytvoříme několik jmen navázaných na hodnoty (což je v programovacím
jazyku Clojure obdoba konstant). Tyto hodnoty budou použity v&nbsp;podmínkách
uvedených později:</p>

<pre>
<strong>(def x 10)</strong>
<strong>(def y 20)</strong>
<strong>(def z 20)</strong>
</pre>

<p><div class="rs-tip-major">Poznámka: v&nbsp;naprosté většině skutečných
aplikací by se <strong>def</strong> tímto způsobem nepoužívalo, nebo alespoň ne
frekventovaně, protože to vede k&nbsp;vytvoření obdoby hodnot dostupných
&bdquo;globálně&ldquo; v&nbsp;rámci celého jmenného prostoru.</div></p>

<p>Základní rozhodovací konstrukce je tvořena speciální formou
<strong>if</strong>, která existuje ve dvou variantách &ndash; pouze
s&nbsp;větví <strong>then</strong> a s&nbsp;oběma větvemi <strong>then</strong>
i <strong>else</strong>. Tuto speciální formu lze tedy zapsat ve zkrácené
podobě:</p>

<pre>
<strong>(<u>if</u> test větev-then)</strong>
</pre>

<p>nebo v&nbsp;plné podobě:</p>

<pre>
<strong>(<u>if</u> test větev-then větev-else)</strong>
</pre>

<p>Bližší informace o této speciální formě získáme přímo z&nbsp;vestavěné
nápovědy dostupné z&nbsp;interaktivní smyčky REPL programovacího jazyka
Clojure. Připomeňme si, že nápovědu k&nbsp;jakémukoli symbolu je možné zobrazit
makrem pojmenovaným <strong>doc</strong>. Pro speciální formu
<strong>if</strong> se tedy zobrazí nápověda takto:</p>

<pre>
<strong>(doc <u>if</u>)</strong>
&nbsp;
-------------------------
if
  (if test then else?)
Special Form
  Evaluates test. If not the singular values nil or false,
  evaluates and yields then, otherwise, evaluates and yields else. If
  else is not supplied it defaults to nil.
&nbsp;
  Please see http://clojure.org/special_forms#if
</pre>

<p>Speciální formu <strong>if</strong> je možné použít ve formě rozvětvení, což
je konstrukce známá například z&nbsp;programovacích jazyků C, <a
href="https://www.root.cz/serialy/programovaci-jazyk-go/">Go</a>, Pascalu, <a
href="https://www.root.cz/n/python/">Pythonu</a> atd. V&nbsp;tomto případě se
(nyní již v&nbsp;Clojure) typicky setkáme s&nbsp;funkcemi nebo makry
s&nbsp;vedlejším efektem, které jsou ve větvi <strong>then</strong>
použity:</p>

<pre>
<strong>(<u>if</u> (&lt; x y)</strong>
  <strong>(println "x &lt; y"))</strong>
&nbsp;
x &lt; y
nil
</pre>

<p>Funkce <strong>println</strong> je v&nbsp;tomto případě zavolána pouze
tehdy, pokud je podmínka platná. Předchozí podmínka platí, ovšem následující
nikoli, proto nebude <strong>println</strong> zavolána a pouze se vrátí hodnota
<strong>nil</strong>:</p>

<pre>
<strong>(<u>if</u> (&lt; y x)</strong>
  <strong>(println "y &lt; x"))</strong>
&nbsp;
nil
</pre>

<p>V&nbsp;programovacím jazyku Clojure a současně i ve všech LISPovských
programovacích se speciální forma <strong>if</strong> vyhodnocuje a následně se
vrátí výsledek tohoto vyhodnocení. Pokud je podmínka splněna, je vrácena
hodnota funkce/makra ve větvi <strong>then</strong>, v&nbsp;opačném případě je
vrácena hodnota funkce/makra ve větvi <strong>else</strong> nebo
<strong>nil</strong> tehdy, pokud větev <strong>else</strong> není vůbec
zapsána:</p>

<pre>
<strong>(<u>if</u> (&lt; x y)</strong>
  <strong>(+ x y))</strong>
&nbsp;
30
</pre>

<p>Nebo ještě jednodušeji:</p>

<pre>
<strong>(<u>if</u> (&lt; x y)</strong>
  <strong>:mensi)</strong>
&nbsp;
:mensi
</pre>

<p>Následující konstrukce vrátí hodnotu <strong>nil</strong>, protože podmínka
není splněna a současně není zapsána větev <strong>else</strong>:</p>

<pre>
<strong>(<u>if</u> (&lt; y x)</strong>
  <strong>(+ x y))</strong>
&nbsp;
nil
</pre>

<p>resp:</p>

<pre>
<strong>(<u>if</u> (&gt; x y)</strong>
  <strong>:vetsi)</strong>
&nbsp;
nil
</pre>

<p>Poznámka: podobným způsobem se konstrukce <strong>if</strong> používá
například v&nbsp;programovacím jazyku Rustu, kde se taktéž jedná o výraz.
V&nbsp;Rustu lze tedy psát:</p>

<pre>
fn if_expression(value:i32) {
  let value_type =
      if value &lt; 0 {
          "zaporna"
      } else {
          if value == 0 {
              "nulova"
          } else {
              "kladna"
          }
      };
  println!("Hodnota {} je {}", value, value_type);
}
</pre>

<p><div class="rs-tip-major">Poznámka: v&nbsp;předchozím příkladu je fakt, že
se jedná o zápis výrazu ještě zvýrazněn tím, že není použit příkaz
<strong>return</strong>.</div></p>



<p><a name="k03"></a></p>
<h2 id="k03">3. Použití speciální formy <strong>if</strong> s&nbsp;oběma větvemi a problematika více volaných funkcí ve větvích</h2>

<p>Vraťme se však k&nbsp;programovacímu jazyku Clojure. Již jsme si řekli, že
je podporována i speciální forma <strong>if</strong> s&nbsp;oběma větvemi
<strong>then</strong> i <strong>else</strong>. Zápis je v&nbsp;tomto případě
jednoduchý:</p>

<pre>
<strong>(<u>if</u> (&lt; x y)</strong>
  <strong>(println "x &lt; y")</strong>
  <strong>(println "x &gt; y"))</strong>
&nbsp;
x &lt; y
nil
</pre>

<p><div class="rs-tip-major">Poznámka: předchozí konstrukce vytiskla (přes
vedlejší efekt) zprávu na terminál a za všech okolností vrátila hodnotu
<strong>nil</strong>, nehledě na to, zda byla podmínka splněna či
nesplněna.</div></p>

<p>Ještě lépe je konstrukce rozvětvení patrná na demonstračním příkladu, který
vrátí hodnotu <strong>:mensi</strong> nebo <strong>:vetsi</strong> na základě
vyhodnocení podmínky:</p>

<pre>
<strong>(<u>if</u> (&lt; x y)</strong>
  <strong>:mensi</strong>
  <strong>:vetsi)</strong>
</pre>

<p>Konstrukce <strong>if</strong> je možné vnořovat:</p>

<pre>
<strong>(<u>if</u> (zero? x)</strong>
  <strong>:nulove</strong>
  <strong>(<u>if</u> (neg? x)</strong>
    <strong>:zaporne</strong>
    <strong>:kladne))</strong>
</pre>

<p>Praktičtější příklad &ndash; výpočet největšího společného dělitele:</p>

<pre>
<strong>(defn gcd</strong>
  <strong>[x y]</strong>
  <strong>(<u>if</u> (= x y)</strong>
    <strong>x</strong>
    <strong>(<u>if</u> (&gt; x y)</strong>
      <strong>(gcd (- x y) y)</strong>
      <strong>(gcd x (- y x)))))</strong>
&nbsp;
<strong>(println (gcd 64 24))</strong>
8
nil
</pre>

<p>V&nbsp;tomto případě je však lepší použít konstrukci <strong>cond</strong>
popsanou níže.</p>

<p>Mnohdy se setkáme s&nbsp;požadavkem, že se v&nbsp;jedné větvi speciální
formy <strong>if</strong> popř.&nbsp;v&nbsp;obou větvích má použít více funkcí
s&nbsp;vedlejším efektem (volání více funkcí bez vedlejšího efektu nemá význam,
i když není zakázáno). Tento požadavek, který je v&nbsp;Algolských
programovacích jazycích (C, Pascal, JavaScript, Go, ...) vyřešen
s&nbsp;využitím programových bloků (složené závorky), by bylo možné otrocky
přepsat do jazyka Clojure pomocí speciální formy <strong>do</strong>:</p>

<pre>
<strong>(<u>if</u> (&lt; x y)</strong>
  <strong>(<u>do</u></strong>
    <strong>(println "x &lt; y")</strong>
    <strong>:mensi)</strong>
  <strong>(<u>do</u></strong>
    <strong>(println "x &gt; y")</strong>
    <strong>:vetsi))</strong>
</pre>

<p>I ke speciální formě <strong>do</strong> (vedle <strong>if</strong> patří
mezi základní konstrukce Clojure) samozřejmě existuje nápověda:</p>

<pre>
<strong>(doc <u>do</u>)</strong>
&nbsp;
</pre>

<p>Nápověda:</p>

<pre>
-------------------------
do
  (do exprs*)
Special Form
  Evaluates the expressions in order and returns the value of
  the last. If no expressions are supplied, returns nil.
&nbsp;
  Please see http://clojure.org/special_forms#do
</pre>



<p><a name="k04"></a></p>
<h2 id="k04">4. Makra <strong>when</strong> a <strong>when-not</strong></h2>

<p>Ve skutečnosti je však výše zmíněná kombinace <strong>if</strong> +
<strong>do</strong> velmi špatně čitelná, nehledě na to, že se kód začíná
ztrácet ve velkém množství kulatých závorek. Existuje však i (pro mnoho účelů)
lepší řešení. Pokud konstrukce <strong>if</strong> obsahuje pouze jedinou větev
(předpokládejme nyní pro určité zjednodušení, že se jedná o větev
<strong>then</strong>), lze namísto speciální formy <strong>if</strong> použít
makro nazvané příznačně <strong>when</strong>:</p>

<pre>
<strong>(doc <u>when</u>)</strong>
&nbsp;
;; -------------------------
;; clojure.core/when
;; ([test &amp; body])
;; Macro
;;   Evaluates test. If logical true, evaluates body in an implicit do.
</pre>

<p>Následuje ukázka příkladu použití tohoto makra v&nbsp;situaci, kdy se má při
splnění podmínky vykonat více funkcí (s&nbsp;vedlejším efektem) a navíc se má
vrátit nějaká hodnota, typicky s&nbsp;využitím funkce <i>bez</i> vedlejšího
efektu:</p>

<pre>
<strong>(<u>when</u> (&lt; x y)</strong>
  <strong>(println "----------")</strong>
  <strong>(println "x &lt; y")</strong>
  <strong>(println "----------")</strong>
  <strong>:mensi)</strong>
&nbsp;
x &lt; y
:mensi
</pre>

<p>Následuje nepatrně složitější příklad vracející výsledek funkce
<strong>+</strong>:</p>

<pre>
<strong>(<u>when</u> (&lt; x y)</strong>
  <strong>(println "----------")</strong>
  <strong>(println "x &lt; y")</strong>
  <strong>(println "----------")</strong>
  <strong>(+ x y))</strong>
&nbsp;
x &lt; y
30
</pre>

<p>V&nbsp;případě, že podmínka splněna není, žádná funkce ani makro se nezavolá
a makro <strong>when</strong> vrátí hodnotu <strong>nil</strong>:</p>

<pre>
<strong>(<u>when</u> (&gt; x y)</strong>
  <strong>(println "x &gt; y")</strong>
  <strong>:vetsi)</strong>
&nbsp;
nil
</pre>

<p>Pokud je naopak nutné zavolat více funkcí při NEsplnění podmínky, použije se
namísto makra <strong>when</strong> makro nazvané
<strong>when-not</strong>:</p>

<pre>
<strong>(doc <u>when-not</u>)</strong>
&nbsp;
;; -------------------------
;; clojure.core/when-not
;; ([test &amp; body])
;; Macro
;;  Evaluates test. If logical false, evaluates body in an implicit do.
</pre>

<p>Opět si ve stručnosti ukažme příklad použití tohoto makra:</p>

<pre>
<strong>(<u>when-not</u> (&gt; x y)</strong>
  <strong>(println "----------")</strong>
  <strong>(println "x &lt; y")</strong>
  <strong>(println "----------")</strong>
  <strong>(+ x y))</strong>
</pre>

<p>Popř.&nbsp;pouze:</p>

<pre>
<strong>(<u>when-not</u> (&lt; x y)</strong>
  <strong>(println "x &gt; y")</strong>
  <strong>:vetsi)</strong>
</pre>

<p>Poznámka: pokud vám &ndash; ostatně podobně jako mnoha dalším programátorům
&ndash; nevyhovuje název makra <strong>when-not</strong>, není nic
jednoduššího, než si vytvořit vlastní makro typicky nazvané
<strong>unless</strong>:</p>

<pre>
<strong>(defmacro unless [&amp; args] `(when-not ~@args))</strong>
</pre>

<p><div class="rs-tip-major">Poznámka: <strong>unless</strong> není náhodně
zvolené jméno, protože ho najdeme v&nbsp;mnoha interpretrech a překladačích
programovacího jazyka Scheme. Příkladem může být Racket: <a
href="https://docs.racket-lang.org/reference/when_unless.html">https://docs.racket-lang.org/reference/when_unless.html</a>.</div></p>

<p>Vzhledem k tomu, že <strong>when</strong> je makro, můžeme se podívat na
expanzi tohoto makra, tedy na programový kód, který je tímto makrem
vygenerován:</p>

<pre>
<strong>(macroexpand-1</strong>
  <strong>'(<u>when</u> (&lt; x y)</strong>
    <strong>(println "----------")</strong>
    <strong>(println "x lt; y")</strong>
    <strong>(println "----------")</strong>
    <strong>(+ x y)))</strong>
</pre>

<p>Z&nbsp;výsledku je patrné, že expanze je v&nbsp;tomto případě přímočaré
rozepsání na základní speciální formy <strong>if</strong> a
<strong>do</strong>:</p>

<pre>
(if
(&lt; x y)
(do (println "----------") (println "x &lt; y") (println "----------") (+ x y)))
</pre>

<p>Totéž, tedy výpis expandovaného makra, můžeme vyzkoušet i pro makro <strong>when-not</strong>:</p>

<pre>
<strong>(macroexpand-1</strong>
  <strong>'(<u>when-not</u> (&lt; x y)</strong>
    <strong>(println "----------")</strong>
    <strong>(println "x &lt; y")</strong>
    <strong>(println "----------")</strong>
    <strong>(+ x y)))</strong>
</pre>

<p>Nyní je výsledek expanze makra zajímavější, protože větev
<strong>then</strong> je vygenerována, ovšem obsahuje pouze
<strong>nil</strong>, zatímco větev <strong>else</strong> je umístěna do
speciální formy <strong>do</strong> (což je logické, protože potřebujeme
zavolat více funkcí):</p>

<pre>
(if
 (&lt; x y)
 nil
 (do (println "----------") (println "x &lt; y") (println "----------") (+ x y)))
</pre>

<p>Zajímavější je situace, která nastane při expanzi makra
<strong>unless</strong>, které se expanduje na jiné makro, konkrétně na
<strong>when-not</strong>:</p>

<pre>
<strong>(defmacro unless [&amp; args] `(when-not ~@args))</strong>
</pre>

<p>Ostatně se sami podívejme, jak vypadá výsledek jedné expanze:</p>

<pre>
<strong>(macroexpand-1</strong>
  <strong>'(<u>unless</u> (&lt; x y)</strong>
    <strong>(println "----------")</strong>
    <strong>(println "x &lt; y")</strong>
    <strong>(println "----------")</strong>
    <strong>(+ x y)))</strong>
</pre>

<p>Výsledkem je pouhá náhrada makra <strong>unless</strong> za
<strong>when-not</strong>:</p>

<pre>
(clojure.core/when-not
 (&lt; x y)
 (println "----------")
 (println "x &lt; y")
 (println "----------")
 (+ x y))
</pre>

<p>Úplnou expanzi si můžeme zobrazit pomocí <strong>macroexpand</strong>:</p>

<pre>
(macroexpand
  '(unless (&lt; x y)
    (println "----------")
    (println "x &lt; y")
    (println "----------")
    (+ x y)))
</pre>

<p>S&nbsp;tímto výsledkem:</p>

<pre>
(if
 (&lt; x y)
 nil
 (do (println "----------") (println "x &lt; y") (println "----------") (+ x y)))
</pre>



<p><a name="k05"></a></p>
<h2 id="k05">5. Kombinace speciálních forem <strong>if</strong> a <strong>let</strong></h2>

<p>Prozatím jsme si ukázali zejména speciální formu <strong>if</strong> a
způsoby nahrazení této formy v&nbsp;případě, že je zapotřebí vykonat jednu
vícekrokovou větev. Náhrada spočívá v&nbsp;použití maker <strong>when</strong>
a <strong>when-not</strong>. Existují však i další velmi často používané
konstrukce, například kombinace speciální formy <strong>if</strong>
s&nbsp;další speciální formou <strong>let</strong> nazvaná příznačně
<strong>if-let</strong>:</p>

<pre>
<strong>(doc <u>if-let</u>)</strong>
&nbsp;
-------------------------
clojure.core/if-let
([bindings then] [bindings then else &amp; oldform])
Macro
  bindings =&gt; binding-form test

  If test is true, evaluates then with binding-form bound to the value of 
  test, if not, yields else
</pre>

<p>Podívejme se nyní na způsob použití tohoto makra. Předpokládejme, že budeme
chtít vytvořit skript, který se zeptá na jméno uživatele a pokud uživatel jméno
skutečně zadá, vypíše se řetězec &bdquo;Hello&ldquo;, za nímž následuje zapsané
jméno. Pokud ovšem uživatel pouze stiskne klávesu <strong>Enter</strong>, nic
se neprovede. Takový skript by bylo možné zapsat následujícím způsobem:</p>

<pre>
<strong>(let [name (read-line)]</strong>
  <strong>(if (not-empty name)</strong>
    <strong>(println "Hello!" name)))</strong>
</pre>

<p>Výše uvedený kód je však zbytečně komplikovaný. Můžeme ho zkrátit na použití
makra <strong>if-let</strong> a těla <strong>then</strong> s&nbsp;funkcí
<strong>println</strong> (s&nbsp;vedlejším efektem):</p>

<pre>
<strong>(<u>if-let</u> [name (not-empty (read-line))]</strong>
  <strong>(println "Hello!" name))</strong>
</pre>

<p>Pro zajímavost se nyní podívejme na plnou expanzi předchozího skriptu, který
je založen na makru <strong>if-let</strong>:</p>

<pre>
<strong>(macroexpand</strong>
  <strong>'(<u>if-let</u> [name (not-empty (read-line))]</strong>
    <strong>(println "Hello!" name)))</strong>
</pre>

<p>Z&nbsp;výsledku je patrné, že byla použita automaticky vytvořená lokální
proměnná:</p>

<pre>
(let*
 [temp__5733__auto__ (not-empty (read-line))]
 (if
  temp__5733__auto__
  (clojure.core/let [name temp__5733__auto__] (println "Hello!" name))
  nil))
</pre>

<p><div class="rs-tip-major">Poznámka: zdrojový kód makra zaručuje, že
automaticky vytvořené lokální proměnné mají unikátní název.</div></p>

<p>Otestujme si, zda <strong>if-let</strong> vrací nějakou hodnotu:</p>

<pre>
<strong>(<u>if-let</u> [name (not-empty (read-line))]</strong>
  <strong>(str "Hello! " name))</strong>
</pre>

<p>Tento výraz vrátí buď řetězec "Hello! (zadaný řetězec)" nebo hodnotu
<strong>nil</strong>.</p>

<p>Úplná forma makra <strong>if-let</strong> s&nbsp;větví <strong>else</strong>
vypadá následovně:</p>

<pre>
<strong>(<u>if-let</u> [name (not-empty (read-line))]</strong>
  <strong>(str "Hello! " name)</strong>
  <strong>:nothing)</strong>
</pre>

<p><div class="rs-tip-major">Pozor: tento výraz obsahuje jednu past: pokud
přistoupíte k&nbsp;lokálnímu jménu z&nbsp;větve <strong>else</strong>, vrátí se
nikoli hodnota (ta není navázána), ale identifikátor ve stylu &bdquo;Name=
clojure.core$name@14df1ec3&ldquo;:</div></p>

<pre>
<strong>(if-let [name (not-empty (read-line))]</strong>
  <strong>(str "Hello! " name)</strong>
  <strong>(str "Name= " name))</strong>
</pre>

<p>Úprava je v&nbsp;tomto případě snadná, i když ne na první pohled zřejmá:
musíme použít unikátní jméno namísto existující funkce
<strong>name</strong>:</p>

<pre>
<strong>(if-let [x (not-empty (read-line))]</strong>
  <strong>(str "Hello! " x)</strong>
  <strong>(str "Name= " x))</strong>
</pre>



<p><a name="k06"></a></p>
<h2 id="k06">6. </h2>


<pre>
<strong>(doc if-some)</strong>
&nbsp;
-------------------------
clojure.core/if-some
([bindings then] [bindings then else &amp; oldform])
Macro
  bindings => binding-form test

   If test is not nil, evaluates then with binding-form bound to the
   value of test, if not, yields else
</pre>

<pre>
<strong>(doc if-not)</strong>
&nbsp;
-------------------------
clojure.core/if-not
([test then] [test then else])
Macro
  Evaluates test. If logical false, evaluates and returns then expr, 
  otherwise else expr, if supplied, else nil.
</pre>


<pre>
<strong>(doc when-let)</strong>
&nbsp;
-------------------------
clojure.core/when-let
([bindings &amp; body])
Macro
  bindings => binding-form test

  When test is true, evaluates body with binding-form bound to the value of test
</pre>



<p><a name="k07"></a></p>
<h2 id="k07">7. </h2>

<pre>
<strong>(doc and)</strong>
&nbsp;
-------------------------
clojure.core/and
([] [x] [x &amp; next])
Macro
  Evaluates exprs one at a time, from left to right. If a form
  returns logical false (nil or false), and returns that value and
  doesn't evaluate any of the other expressions, otherwise it returns
  the value of the last expr. (and) returns true.
</pre>

<pre>
<strong>(doc or)</strong>
&nbsp;
-------------------------
clojure.core/or
([] [x] [x &amp; next])
Macro
  Evaluates exprs one at a time, from left to right. If a form
  returns a logical true value, or returns that value and doesn't
  evaluate any of the other expressions, otherwise it returns the
  value of the last expression. (or) returns nil.
</pre>



<p><a name="k08"></a></p>
<h2 id="k08">8. </h2>

<pre>
(doc cond)
&nbsp;
-------------------------
clojure.core/cond
([&amp; clauses])
Macro
  Takes a set of test/expr pairs. It evaluates each test one at a
  time.  If a test returns logical true, cond evaluates and returns
  the value of the corresponding expr and doesn't evaluate any of the
  other tests or exprs. (cond) returns nil.
</pre>

<pre>
<strong>(doc condp)</strong>
&nbsp;
-------------------------
clojure.core/condp
([pred expr & clauses])
Macro
  Takes a binary predicate, an expression, and a set of clauses.
  Each clause can take the form of either:

  test-expr result-expr

  test-expr :>> result-fn

  Note :>> is an ordinary keyword.

  For each clause, (pred test-expr expr) is evaluated. If it returns
  logical true, the clause is a match. If a binary clause matches, the
  result-expr is returned, if a ternary clause matches, its result-fn,
  which must be a unary function, is called with the result of the
  predicate as its argument, the result of that call being the return
  value of condp. A single default expression can follow the clauses,
  and its value will be returned if no clause matches. If no default
  expression is provided and no clause matches, an
  IllegalArgumentException is thrown.
</pre>

<pre>
<strong>(doc cond->)</strong>
&nbsp;
-------------------------
clojure.core/cond->
([expr & clauses])
Macro
  Takes an expression and a set of test/form pairs. Threads expr (via ->)
  through each form for which the corresponding test
  expression is true. Note that, unlike cond branching, cond-> threading does
  not short circuit after the first true test expression.
</pre>

<pre>
<strong>(doc cond->>)</strong>
&nbsp;
-------------------------
clojure.core/cond->>
([expr & clauses])
Macro
  Takes an expression and a set of test/form pairs. Threads expr (via ->>)
  through each form for which the corresponding test expression
  is true.  Note that, unlike cond branching, cond->> threading does not short circuit
  after the first true test expression.
</pre>



<p><a name="k09"></a></p>
<h2 id="k09">9. </h2>

(use 'clojure.core.logic)

<strong>(doc condu)</strong>
-------------------------
clojure.core.logic/condu
([&amp; clauses])
Macro
  Committed choice. Once the head (first goal) of a clause
  has succeeded, remaining goals of the clause will only
  be run once. Non-relational.

<strong>(doc conde)</strong>
-------------------------
clojure.core.logic/conde
([&amp; clauses])
Macro
  Logical disjunction of the clauses. The first goal in
  a clause is considered the head of that clause. Interleaves the
  execution of the clauses.


<strong>(doc conda)</strong>
-------------------------
clojure.core.logic/conda
([&amp; clauses])
Macro
  Soft cut. Once the head of a clause has succeeded
  all other clauses will be ignored. Non-relational.



<p><a name="k10"></a></p>
<h2 id="k10">10. </h2>



<p><a name="k11"></a></p>
<h2 id="k11">11. </h2>

<pre>
(defmacro cond-table
  "Produce a `cond` expression from a tabular representation of its clauses.

  [& items]
  (let [rows (validate-cond-table items)
        rights (first rows)  ;; get right-hand conditions
        rights (if (and (symbol? (first rights))
                        (every? (partial = \_) (name (first rights))))
                 (next rights)
                 rights)
        op-omitted? (= (count (second rows))
                       (inc (count rights)))
        [op rights] (if op-omitted?
                      ['and rights]
                      [(first rights) (next rights)])]
    (cons 'cond
          (mapcat
           (fn [[left-condition & exprs :as row]]
             (mapcat
              (fn [right-condition expr]
                ;; `cond` test/expr pair:
                (list (list op left-condition right-condition) expr))
              rights exprs))
           (next rows)))))
</pre>



<p><a name="k12"></a></p>
<h2 id="k12">12. </h2>



<p><a name="k13"></a></p>
<h2 id="k13">13. </h2>



<p><a name="k14"></a></p>
<h2 id="k14">14. </h2>



<p><a name="k15"></a></p>
<h2 id="k15">15. </h2>



<p><a name="k16"></a></p>
<h2 id="k16">16. </h2>

(map #(unless (= %2 %3) [%1 %2 %3])
  (iterate inc 0)    ; a lazy list for indecies
  [:a :b :c]
  [:a :a :a])

https://cljdoc.org/d/better-cond/better-cond/2.1.0/doc/readme

https://cljdoc.org/d/com.walmartlabs/cond-let/1.0.0/doc/readme

https://cljdoc.org/d/cond-plus/cond-plus/1.0.1/doc/readme

https://docs.racket-lang.org/reference/if.html?q=cond#%28form._%28%28lib._racket%2Fprivate%2Fletstx-scheme..rkt%29._cond%29%29



<p><a name="k17"></a></p>
<h2 id="k17">17. Dodatek na závěr: speciální formy jazyka Clojure, porovnání se Scheme</h2>

<p>Na závěr se ještě zmiňme o speciálních formách programovacího jazyka
Clojure. V&nbsp;tomto článku jsme se setkali se čtyřmi speciálními formami
(jsou uvedeny na začátku tabulky), ovšem pro úplnost si je vypišme všechny:</p>

<table>
<tr><th> #</th><th>Jméno</th><th>Stručný popis speciální formy</th></tr>
<tr><td> 1</td><td>def</td><td>definice nového jména navázaného na hodnotu</td></tr>
<tr><td> 2</td><td>if</td><td>podmíněné vyhodnocení prvního či druhého podvýrazu na základě vyhodnocené podmínky</td></tr>
<tr><td> 3</td><td>do</td><td>vyhodnocení více výrazů, vrátí se návratová hodnota posledního z&nbsp;nich</td></tr>
<tr><td> 4</td><td>let</td><td>blok, na který je navázána nová lokální proměnná či proměnné</td></tr>
<tr><td> 5</td><td>quote</td><td>zakazuje vyhodnocení podvýrazu (tedy seznamu)</td></tr>
<tr><td> 6</td><td>var</td><td>vrací objekt typu Var (nikoli jeho hodnotu), varianta <strong>quote</strong></td></tr>
<tr><td> 7</td><td>fn</td><td>definice (anonymní) funkce</td></tr>
<tr><td> 8</td><td>loop</td><td>použito pro konstrukci smyčky &ndash; cíl pro <strong>recur</strong></td></tr>
<tr><td> 9</td><td>recur</td><td>skok na začátek smyčky s&nbsp;novými hodnotami navázanými na jména v&nbsp;<strong>recur</strong></td></tr>
<tr><td>10</td><td>throw</td><td>vyhození výjimky</td></tr>
<tr><td>11</td><td>try</td><td>vyhodnocení výrazů se zachycením výjimky</td></tr>
<tr><td>12</td><td>monitor-enter</td><td>nízkoúrovňové synchronizační primitivum</td></tr>
<tr><td>13</td><td>monitor-exit</td><td>nízkoúrovňové synchronizační primitivum</td></tr>
<tr><td>14</td><td>.</td><td>přístup k&nbsp;metodám a atributům objektu</td></tr>
<tr><td>15</td><td>new</td><td>konstrukce instance třídy</td></tr>
<tr><td>15</td><td>set!</td><td>nastavení hodnoty lokální proměnné v&nbsp;aktuálním vláknu</td></tr>
</table>

<p>Poněkud odlišná je sada speciálních forem v jazyku Scheme (což je taktéž
LISPovský programovací jazyk):</p>

<table>
<tr><th> #</th><th>Jméno</th><th>Stručný popis speciální formy</th></tr>
<tr><td> 1</td><td>lambda</td><td>vytvoření anonymní funkce nebo uzávěru</td></tr>
<tr><td> 2</td><td>define</td><td>definice nové proměnné (může jít i o funkci)</td></tr>
<tr><td> 3</td><td>quote</td><td>zakazuje vyhodnocení podvýrazu (tedy seznamu)</td></tr>
<tr><td> 4</td><td>set!</td><td>změna hodnoty proměnné</td></tr>
<tr><td> 5</td><td>let</td><td>blok, na který je navázána nová lokální proměnná či proměnné</td></tr>
<tr><td> 6</td><td>let*</td><td>podobné <strong>let</strong>, ovšem umožňuje při inicializaci proměnných použít proměnné nalevo (nahoře) od právě deklarované proměnné</td></tr>
<tr><td> 7</td><td>letrec</td><td>podobné <strong>let</strong>, ovšem navíc je možné se při inicializaci proměnných rekurzivně odkazovat na další proměnné</td></tr>
<tr><td> 8</td><td>letrec*</td><td>kombinace <strong>let*</strong> a <strong>letrec</strong></td></tr>
<tr><td> 9</td><td>begin</td><td>umožňuje definovat blok s&nbsp;více výrazy, které se postupně vyhodnotí</td></tr>
<tr><td>10</td><td>if</td><td>podmíněné vyhodnocení prvního či druhého podvýrazu na základě vyhodnocené podmínky</td></tr>
<tr><td>11</td><td>cond</td><td>vícenásobné rozvětvení (vyhodnocení podvýrazů)</td></tr>
<tr><td>12</td><td>case</td><td>rozeskok na základě hodnoty vyhodnoceného podvýrazu</td></tr>
<tr><td>13</td><td>when</td><td>pokud je podmínka splněna, vyhodnotí všechny podvýrazy</td></tr>
<tr><td>14</td><td>unless</td><td>pokud podmínka není splněna, vyhodnotí všechny podvýrazy</td></tr>
<tr><td>15</td><td>and</td><td>zkrácené vyhodnocení logického součinu</td></tr>
<tr><td>16</td><td>or</td><td>zkrácené vyhodnocení logického součtu</td></tr>
<tr><td>17</td><td>do</td><td>zápis iterace s&nbsp;inicializací logických proměnných i s&nbsp;jejich změnou v&nbsp;každé iteraci</td></tr>
</table>



<p><a name="k18"></a></p>
<h2 id="k18">18. Repositář s&nbsp;demonstračními příklady</h2>

<p>Ukázkové části kódu s&nbsp;rozhodovacími konstrukcemi, které byly popsány
v&nbsp;rámci předchozích kapitol, byly uloženy do Git repositáře, který je
dostupný na adrese <a
href="https://github.com/tisnik/clojure-examples/">https://github.com/tisnik/clojure-examples/</a>.
Konkrétně se jedná o projekt <strong>conditions</strong> (<a
href="https://github.com/tisnik/clojure-examples/tree/master/conditions">https://github.com/tisnik/clojure-examples/tree/master/conditions</a>),
jehož zdrojový kód (<a
href="https://github.com/tisnik/clojure-examples/tree/master/conditions/src/conditions/core.clj">jediný
soubor</a>) je možné postupně kopírovat do interaktivního prostředí
představovaného smyčkou REPL. Příklad je pochopitelně možné spustit i
v&nbsp;jeho plné podobě příkazem <strong>lein run</strong> (to ovšem do určité
míry postrádá výukový charakter).</p>



<p><a name="k19"></a></p>
<h2 id="k19">19. Odkazy na předchozí části seriálu o programovacím jazyku Clojure</h2>

<ol>

<li>Clojure  1: Úvod<br />
<a href="http://www.root.cz/clanky/clojure-aneb-jazyk-umoznujici-tvorbu-bezpecnych-vicevlaknovych-aplikaci-pro-jvm/">http://www.root.cz/clanky/clojure-aneb-jazyk-umoznujici-tvorbu-bezpecnych-vicevlaknovych-aplikaci-pro-jvm/</a>
</li>

<li>Clojure  2: Symboly, kolekce atd.<br />
<a href="http://www.root.cz/clanky/clojure-aneb-jazyk-umoznujici-tvorbu-bezpecnych-vicevlaknovych-aplikaci-pro-jvm-2-cast/">http://www.root.cz/clanky/clojure-aneb-jazyk-umoznujici-tvorbu-bezpecnych-vicevlaknovych-aplikaci-pro-jvm-2-cast/</a>
</li>

<li>Clojure  3: Funkcionální programování<br />
<a href="http://www.root.cz/clanky/clojure-aneb-jazyk-umoznujici-tvorbu-bezpecnych-vicevlaknovych-aplikaci-pro-jvm-3-cast-funkcionalni-programovani/">http://www.root.cz/clanky/clojure-aneb-jazyk-umoznujici-tvorbu-bezpecnych-vicevlaknovych-aplikaci-pro-jvm-3-cast-funkcionalni-programovani/</a>
</li>

<li>Clojure  4: Kolekce, sekvence a lazy sekvence<br />
<a href="http://www.root.cz/clanky/clojure-aneb-jazyk-umoznujici-tvorbu-bezpecnych-vicevlaknovych-aplikaci-pro-jvm-4-cast-kolekce-sekvence-a-lazy-sekvence/">http://www.root.cz/clanky/clojure-aneb-jazyk-umoznujici-tvorbu-bezpecnych-vicevlaknovych-aplikaci-pro-jvm-4-cast-kolekce-sekvence-a-lazy-sekvence/</a>
</li>

<li>Clojure  5: Sekvence, lazy sekvence a paralelní programy<br />
<a href="http://www.root.cz/clanky/clojure-a-bezpecne-aplikace-pro-jvm-sekvence-lazy-sekvence-a-paralelni-programy/">http://www.root.cz/clanky/clojure-a-bezpecne-aplikace-pro-jvm-sekvence-lazy-sekvence-a-paralelni-programy/</a>
</li>

<li>Clojure  6: Podpora pro paralelní programování<br />
<a href="http://www.root.cz/clanky/programovaci-jazyk-clojure-6-futures-nejsou-jen-financni-derivaty/">http://www.root.cz/clanky/programovaci-jazyk-clojure-6-futures-nejsou-jen-financni-derivaty/</a>
</li>

<li>Clojure  7: Další funkce pro paralelní programování<br />
<a href="http://www.root.cz/clanky/programovaci-jazyk-clojure-7-dalsi-podpurne-prostredky-pro-paralelni-programovani/">http://www.root.cz/clanky/programovaci-jazyk-clojure-7-dalsi-podpurne-prostredky-pro-paralelni-programovani/</a>
</li>

<li>Clojure  8: Identity, stavy, neměnné hodnoty a reference<br />
<a href="http://www.root.cz/clanky/programovaci-jazyk-clojure-8-identity-stavy-nemenne-hodnoty-a-referencni-typy/">http://www.root.cz/clanky/programovaci-jazyk-clojure-8-identity-stavy-nemenne-hodnoty-a-referencni-typy/</a>
</li>

<li>Clojure  9: Validátory, pozorovatelé a kooperace s Javou<br />
<a href="http://www.root.cz/clanky/programovaci-jazyk-clojure-9-validatory-pozorovatele-a-kooperace-mezi-clojure-a-javou/">http://www.root.cz/clanky/programovaci-jazyk-clojure-9-validatory-pozorovatele-a-kooperace-mezi-clojure-a-javou/</a>
</li>

<li>Clojure 10: Kooperace mezi Clojure a Javou<br />
<a href="http://www.root.cz/clanky/programovaci-jazyk-clojure-10-kooperace-mezi-clojure-a-javou-pokracovani/">http://www.root.cz/clanky/programovaci-jazyk-clojure-10-kooperace-mezi-clojure-a-javou-pokracovani/</a>
</li>

<li>Clojure 11: Generátorová notace seznamu/list comprehension<br />
<a href="http://www.root.cz/clanky/programovaci-jazyk-clojure-11-generatorova-notace-seznamu-list-comprehension/">http://www.root.cz/clanky/programovaci-jazyk-clojure-11-generatorova-notace-seznamu-list-comprehension/</a>
</li>

<li>Clojure 12: Překlad programů z Clojure do bajtkódu JVM I:<br />
<a href="http://www.root.cz/clanky/programovaci-jazyk-clojure-12-preklad-programu-z-clojure-do-bajtkodu-jvm/">http://www.root.cz/clanky/programovaci-jazyk-clojure-12-preklad-programu-z-clojure-do-bajtkodu-jvm/</a>
</li>

<li>Clojure 13: Překlad programů z Clojure do bajtkódu JVM II:<br />
<a href="http://www.root.cz/clanky/programovaci-jazyk-clojure-13-preklad-programu-z-clojure-do-bajtkodu-jvm-pokracovani/">http://www.root.cz/clanky/programovaci-jazyk-clojure-13-preklad-programu-z-clojure-do-bajtkodu-jvm-pokracovani/</a>
</li>

<li>Clojure 14: Základy práce se systémem maker<br />
<a href="http://www.root.cz/clanky/programovaci-jazyk-clojure-14-zaklady-prace-se-systemem-maker/">http://www.root.cz/clanky/programovaci-jazyk-clojure-14-zaklady-prace-se-systemem-maker/</a>
</li>

<li>Clojure 15: Tvorba uživatelských maker<br />
<a href="http://www.root.cz/clanky/programovaci-jazyk-clojure-15-tvorba-uzivatelskych-maker/">http://www.root.cz/clanky/programovaci-jazyk-clojure-15-tvorba-uzivatelskych-maker/</a>
</li>

<li>Programovací jazyk Clojure &ndash; triky při práci s řetězci<br />
<a href="http://www.root.cz/clanky/programovaci-jazyk-clojure-triky-pri-praci-s-retezci/">http://www.root.cz/clanky/programovaci-jazyk-clojure-triky-pri-praci-s-retezci/</a>
</li>

<li>Programovací jazyk Clojure &ndash; triky při práci s kolekcemi<br />
<a href="http://www.root.cz/clanky/programovaci-jazyk-clojure-triky-pri-praci-s-kolekcemi/">http://www.root.cz/clanky/programovaci-jazyk-clojure-triky-pri-praci-s-kolekcemi/</a>
</li>

<li>Programovací jazyk Clojure &ndash; práce s mapami a množinami<br />
<a href="http://www.root.cz/clanky/programovaci-jazyk-clojure-prace-s-mapami-a-mnozinami/">http://www.root.cz/clanky/programovaci-jazyk-clojure-prace-s-mapami-a-mnozinami/</a>
</li>

<li>Programovací jazyk Clojure &ndash; základy zpracování XML<br />
<a href="http://www.root.cz/clanky/programovaci-jazyk-clojure-zaklady-zpracovani-xml/">http://www.root.cz/clanky/programovaci-jazyk-clojure-zaklady-zpracovani-xml/</a>
</li>

<li>Programovací jazyk Clojure &ndash; testování s využitím knihovny Expectations<br />
<a href="http://www.root.cz/clanky/programovaci-jazyk-clojure-testovani-s-vyuzitim-knihovny-expectations/">http://www.root.cz/clanky/programovaci-jazyk-clojure-testovani-s-vyuzitim-knihovny-expectations/</a>
</li>

<li>Programovací jazyk Clojure &ndash; některé užitečné triky použitelné (nejenom) v&nbsp;testech<br />
<a href="http://www.root.cz/clanky/programovaci-jazyk-clojure-nektere-uzitecne-triky-pouzitelne-nejenom-v-testech/">http://www.root.cz/clanky/programovaci-jazyk-clojure-nektere-uzitecne-triky-pouzitelne-nejenom-v-testech/</a>
</li>

<li>Enlive &ndash; výkonný šablonovací systém pro jazyk Clojure<br/>
<a href="http://www.root.cz/clanky/enlive-vykonny-sablonovaci-system-pro-jazyk-clojure/">http://www.root.cz/clanky/enlive-vykonny-sablonovaci-system-pro-jazyk-clojure/</a>
</li>

<li>Nástroj Leiningen a programovací jazyk Clojure: tvorba vlastních knihoven pro veřejný repositář Clojars<br />
<a href="http://www.root.cz/clanky/nastroj-leiningen-a-programovaci-jazyk-clojure-tvorba-vlastnich-knihoven-pro-verejny-repositar-clojars/">http://www.root.cz/clanky/nastroj-leiningen-a-programovaci-jazyk-clojure-tvorba-vlastnich-knihoven-pro-verejny-repositar-clojars/</a>
</li>

<li>Novinky v Clojure verze 1.8.0<br />
<a href="http://www.root.cz/clanky/novinky-v-clojure-verze-1-8-0/">http://www.root.cz/clanky/novinky-v-clojure-verze-1-8-0/</a>
</li>

<li>Asynchronní programování v&nbsp;Clojure s&nbsp;využitím knihovny core.async<br />
<a href="http://www.root.cz/clanky/asynchronni-programovani-v-clojure-s-vyuzitim-knihovny-core-async/">http://www.root.cz/clanky/asynchronni-programovani-v-clojure-s-vyuzitim-knihovny-core-async/</a>
</li>

<li>Asynchronní programování v&nbsp;Clojure s&nbsp;využitím knihovny core.async (pokračování)<br />
<a href="http://www.root.cz/clanky/asynchronni-programovani-v-clojure-s-vyuzitim-knihovny-core-async-pokracovani/">http://www.root.cz/clanky/asynchronni-programovani-v-clojure-s-vyuzitim-knihovny-core-async-pokracovani/</a>
</li>

<li>Asynchronní programování v Clojure s využitím knihovny core.async (dokončení)<br />
<a href="http://www.root.cz/clanky/asynchronni-programovani-v-clojure-s-vyuzitim-knihovny-core-async-dokonceni/">http://www.root.cz/clanky/asynchronni-programovani-v-clojure-s-vyuzitim-knihovny-core-async-dokonceni/</a>
</li>

<li>Vytváříme IRC bota v programovacím jazyce Clojure<br />
<a href="http://www.root.cz/clanky/vytvarime-irc-bota-v-programovacim-jazyce-clojure/">http://www.root.cz/clanky/vytvarime-irc-bota-v-programovacim-jazyce-clojure/</a>
</li>

<li>Gorilla REPL: interaktivní prostředí pro programovací jazyk Clojure<br />
<a href="https://www.root.cz/clanky/gorilla-repl-interaktivni-prostredi-pro-programovaci-jazyk-clojure/">https://www.root.cz/clanky/gorilla-repl-interaktivni-prostredi-pro-programovaci-jazyk-clojure/</a>
</li>

<li>Multimetody v Clojure aneb polymorfismus bez použití OOP<br />
<a href="https://www.root.cz/clanky/multimetody-v-clojure-aneb-polymorfismus-bez-pouziti-oop/">https://www.root.cz/clanky/multimetody-v-clojure-aneb-polymorfismus-bez-pouziti-oop/</a>
</li>

<li>Práce s externími Java archivy v programovacím jazyku Clojure<br />
<a href="https://www.root.cz/clanky/prace-s-externimi-java-archivy-v-programovacim-jazyku-clojure/">https://www.root.cz/clanky/prace-s-externimi-java-archivy-v-programovacim-jazyku-clojure/</a>
</li>

<li>Clojure 16: Složitější uživatelská makra<br />
<a href="http://www.root.cz/clanky/programovaci-jazyk-clojure-16-slozitejsi-uzivatelska-makra/">http://www.root.cz/clanky/programovaci-jazyk-clojure-16-slozitejsi-uzivatelska-makra/</a>
</li>

<li>Clojure 17: Využití standardních maker v praxi<br />
<a href="http://www.root.cz/clanky/programovaci-jazyk-clojure-17-vyuziti-standardnich-maker-v-praxi/">http://www.root.cz/clanky/programovaci-jazyk-clojure-17-vyuziti-standardnich-maker-v-praxi/</a>
</li>

<li>Clojure 18: Základní techniky optimalizace aplikací<br />
<a href="http://www.root.cz/clanky/programovaci-jazyk-clojure-18-zakladni-techniky-optimalizace-aplikaci/">http://www.root.cz/clanky/programovaci-jazyk-clojure-18-zakladni-techniky-optimalizace-aplikaci/</a>
</li>

<li>Clojure 19: Vývojová prostředí pro Clojure<br />
<a href="http://www.root.cz/clanky/programovaci-jazyk-clojure-19-vyvojova-prostredi-pro-clojure/">http://www.root.cz/clanky/programovaci-jazyk-clojure-19-vyvojova-prostredi-pro-clojure/</a>
</li>

<li>Clojure 20: Vývojová prostředí pro Clojure (Vimu s REPL)<br />
<a href="http://www.root.cz/clanky/programovaci-jazyk-clojure-20-vyvojova-prostredi-pro-clojure-integrace-vimu-s-repl/">http://www.root.cz/clanky/programovaci-jazyk-clojure-20-vyvojova-prostredi-pro-clojure-integrace-vimu-s-repl/</a>
</li>

<li>Clojure 21: ClojureScript aneb překlad Clojure do JS<br />
<a href="http://www.root.cz/clanky/programovaci-jazyk-clojure-21-clojurescript-aneb-preklad-clojure-do-javascriptu/">http://www.root.cz/clanky/programovaci-jazyk-clojure-21-clojurescript-aneb-preklad-clojure-do-javascriptu/</a>
</li>

<li>Leiningen: nástroj pro správu projektů napsaných v&nbsp;Clojure<br />
<a href="http://www.root.cz/clanky/leiningen-nastroj-pro-spravu-projektu-napsanych-v-clojure/">http://www.root.cz/clanky/leiningen-nastroj-pro-spravu-projektu-napsanych-v-clojure/</a>
</li>

<li>Leiningen: nástroj pro správu projektů napsaných v&nbsp;Clojure (2)<br />
<a href="http://www.root.cz/clanky/leiningen-nastroj-pro-spravu-projektu-napsanych-v-clojure-2/">http://www.root.cz/clanky/leiningen-nastroj-pro-spravu-projektu-napsanych-v-clojure-2/</a>
</li>

<li>Leiningen: nástroj pro správu projektů napsaných v&nbsp;Clojure (3)<br />
<a href="http://www.root.cz/clanky/leiningen-nastroj-pro-spravu-projektu-napsanych-v-clojure-3/">http://www.root.cz/clanky/leiningen-nastroj-pro-spravu-projektu-napsanych-v-clojure-3/</a>
</li>

<li>Leiningen: nástroj pro správu projektů napsaných v&nbsp;Clojure (4)<br />
<a href="http://www.root.cz/clanky/leiningen-nastroj-pro-spravu-projektu-napsanych-v-clojure-4/">http://www.root.cz/clanky/leiningen-nastroj-pro-spravu-projektu-napsanych-v-clojure-4/</a>
</li>

<li>Leiningen: nástroj pro správu projektů napsaných v&nbsp;Clojure (5)<br />
<a href="http://www.root.cz/clanky/leiningen-nastroj-pro-spravu-projektu-napsanych-v-clojure-5/">http://www.root.cz/clanky/leiningen-nastroj-pro-spravu-projektu-napsanych-v-clojure-5/</a>
</li>

<li>Leiningen: nástroj pro správu projektů napsaných v&nbsp;Clojure (6)<br />
<a href="http://www.root.cz/clanky/leiningen-nastroj-pro-spravu-projektu-napsanych-v-clojure-6/">http://www.root.cz/clanky/leiningen-nastroj-pro-spravu-projektu-napsanych-v-clojure-6/</a>
</li>

<li>Programovací jazyk Clojure a databáze (1.část)<br />
<a href="http://www.root.cz/clanky/programovaci-jazyk-clojure-a-databaze-1-cast/">http://www.root.cz/clanky/programovaci-jazyk-clojure-a-databaze-1-cast/</a>
</li>

<li>Pluginy pro Leiningen<br />
<a href="http://www.root.cz/clanky/leiningen-nastroj-pro-spravu-projektu-napsanych-v-clojure-pluginy-pro-leiningen/">http://www.root.cz/clanky/leiningen-nastroj-pro-spravu-projektu-napsanych-v-clojure-pluginy-pro-leiningen/</a>
</li>

<li>Programovací jazyk Clojure a knihovny pro práci s&nbsp;vektory a maticemi<br />
<a href="http://www.root.cz/clanky/programovaci-jazyk-clojure-a-knihovny-pro-praci-s-vektory-a-maticemi/">http://www.root.cz/clanky/programovaci-jazyk-clojure-a-knihovny-pro-praci-s-vektory-a-maticemi/</a>
</li>

<li>Programovací jazyk Clojure a knihovny pro práci s&nbsp;vektory a maticemi (2)<br />
<a href="http://www.root.cz/clanky/programovaci-jazyk-clojure-a-knihovny-pro-praci-s-vektory-a-maticemi-2/">http://www.root.cz/clanky/programovaci-jazyk-clojure-a-knihovny-pro-praci-s-vektory-a-maticemi-2/</a>
</li>

<li>Programovací jazyk Clojure: syntéza procedurálních textur s&nbsp;využitím knihovny Clisk<br />
<a href="http://www.root.cz/clanky/programovaci-jazyk-clojure-synteza-proceduralnich-textur-s-vyuzitim-knihovny-clisk/">http://www.root.cz/clanky/programovaci-jazyk-clojure-synteza-proceduralnich-textur-s-vyuzitim-knihovny-clisk/</a>
</li>

<li>Programovací jazyk Clojure: syntéza procedurálních textur s&nbsp;využitím knihovny Clisk (2)<br />
<a href="http://www.root.cz/clanky/programovaci-jazyk-clojure-synteza-proceduralnich-textur-s-vyuzitim-knihovny-clisk-2/">http://www.root.cz/clanky/programovaci-jazyk-clojure-synteza-proceduralnich-textur-s-vyuzitim-knihovny-clisk-2/</a>
</li>

<li>Seesaw: knihovna pro snadnou tvorbu GUI v&nbsp;jazyce Clojure<br />
<a href="http://www.root.cz/clanky/seesaw-knihovna-pro-snadnou-tvorbu-gui-v-jazyce-clojure/">http://www.root.cz/clanky/seesaw-knihovna-pro-snadnou-tvorbu-gui-v-jazyce-clojure/</a>
</li>

<li>Seesaw: knihovna pro snadnou tvorbu GUI v &nbsp;azyce Clojure (2)<br />
<a href="http://www.root.cz/clanky/seesaw-knihovna-pro-snadnou-tvorbu-gui-v-jazyce-clojure-2/">http://www.root.cz/clanky/seesaw-knihovna-pro-snadnou-tvorbu-gui-v-jazyce-clojure-2/</a>
</li>

<li>Seesaw: knihovna pro snadnou tvorbu GUI v&nbsp;jazyce Clojure (3)<br />
<a href="http://www.root.cz/clanky/seesaw-knihovna-pro-snadnou-tvorbu-gui-v-jazyce-clojure-3/">http://www.root.cz/clanky/seesaw-knihovna-pro-snadnou-tvorbu-gui-v-jazyce-clojure-3/</a>
</li>

<li>Programovací jazyk Clojure a práce s&nbsp;Gitem<br />
<a href="http://www.root.cz/clanky/programovaci-jazyk-clojure-a-prace-s-gitem/">http://www.root.cz/clanky/programovaci-jazyk-clojure-a-prace-s-gitem/</a>
</li>

<li>Programovací jazyk Clojure a práce s&nbsp;Gitem (2)<br />
<a href="http://www.root.cz/clanky/programovaci-jazyk-clojure-a-prace-s-gitem-2/">http://www.root.cz/clanky/programovaci-jazyk-clojure-a-prace-s-gitem-2/</a>
</li>

<li>Programovací jazyk Clojure: syntéza procedurálních textur s&nbsp;využitím knihovny Clisk (dokončení)<br />
<a href="http://www.root.cz/clanky/programovaci-jazyk-clojure-synteza-proceduralnich-textur-s-vyuzitim-knihovny-clisk-dokonceni/">http://www.root.cz/clanky/programovaci-jazyk-clojure-synteza-proceduralnich-textur-s-vyuzitim-knihovny-clisk-dokonceni/</a>
</li>

<li>Pixie: lehký skriptovací jazyk s&nbsp;„kouzelnými“ schopnostmi<br />
<a href="https://www.root.cz/clanky/pixie-lehky-skriptovaci-jazyk-s-kouzelnymi-schopnostmi/">https://www.root.cz/clanky/pixie-lehky-skriptovaci-jazyk-s-kouzelnymi-schopnostmi/</a>
</li>

<li>Programovací jazyk Pixie: funkce ze základní knihovny a použití FFI<br />
<a href="https://www.root.cz/clanky/programovaci-jazyk-pixie-funkce-ze-zakladni-knihovny-a-pouziti-ffi/">https://www.root.cz/clanky/programovaci-jazyk-pixie-funkce-ze-zakladni-knihovny-a-pouziti-ffi/</a>
</li>

<li>Novinky v&nbsp;Clojure verze 1.9.0<br />
<a href="https://www.root.cz/clanky/novinky-v-clojure-verze-1-9-0/">https://www.root.cz/clanky/novinky-v-clojure-verze-1-9-0/</a>
</li>

<li>Validace dat s&nbsp;využitím knihovny spec v&nbsp;Clojure 1.9.0<br />
<a href="https://www.root.cz/clanky/validace-dat-s-vyuzitim-knihovny-spec-v-clojure-1-9-0/">https://www.root.cz/clanky/validace-dat-s-vyuzitim-knihovny-spec-v-clojure-1-9-0/</a>
</li>

<li>Použití jazyka Gherkin při tvorbě testovacích scénářů pro aplikace psané v&nbsp;Clojure<br />
<a href="https://www.root.cz/clanky/pouziti-jazyka-gherkin-pri-tvorbe-testovacich-scenaru-pro-aplikace-psane-v-nbsp-clojure/">https://www.root.cz/clanky/pouziti-jazyka-gherkin-pri-tvorbe-testovacich-scenaru-pro-aplikace-psane-v-nbsp-clojure/</a>
</li>

<li>Použití jazyka Gherkin při tvorbě testovacích scénářů pro aplikace psané v&nbsp;Clojure (2)<br />
<a href="https://www.root.cz/clanky/pouziti-jazyka-gherkin-pri-tvorbe-testovacich-scenaru-pro-aplikace-psane-v-nbsp-clojure-2/">https://www.root.cz/clanky/pouziti-jazyka-gherkin-pri-tvorbe-testovacich-scenaru-pro-aplikace-psane-v-nbsp-clojure-2/</a>
</li>

<li>Incanter: prostředí pro statistické výpočty s grafickým výstupem založené na Clojure<br />
<a href="https://www.root.cz/clanky/incanter-prostredi-pro-statisticke-vypocty-s-grafickym-vystupem-zalozene-na-clojure/">https://www.root.cz/clanky/incanter-prostredi-pro-statisticke-vypocty-s-grafickym-vystupem-zalozene-na-clojure/</a>
</li>

<li>Incanter: operace s&nbsp;maticemi<br />
<a href="https://www.root.cz/clanky/incanter-operace-s-maticemi/">https://www.root.cz/clanky/incanter-operace-s-maticemi/</a>
</li>

<li>Interpret programovacího jazyka Clojure integrovaný do Jupyter Notebooku<br />
<a href="https://www.root.cz/clanky/interpret-programovaciho-jazyka-clojure-integrovany-do-jupyter-notebooku/">https://www.root.cz/clanky/interpret-programovaciho-jazyka-clojure-integrovany-do-jupyter-notebooku/</a>
</li>

<li>Babashka: interpret Clojure určený pro rychlé spouštění utilit z&nbsp;příkazového řádku<br />
<a href="https://www.root.cz/clanky/babashka-interpret-clojure-urceny-pro-rychle-spousteni-utilit-z-prikazoveho-radku/">https://www.root.cz/clanky/babashka-interpret-clojure-urceny-pro-rychle-spousteni-utilit-z-prikazoveho-radku/</a>
</li>

<li>Pokročilý streaming založený na Apache Kafce, jazyku Clojure a knihovně Jackdaw<br />
<a href="https://www.root.cz/clanky/pokrocily-streaming-zalozeny-na-apache-kafce-jazyku-clojure-a-knihovne-jackdaw/">https://www.root.cz/clanky/pokrocily-streaming-zalozeny-na-apache-kafce-jazyku-clojure-a-knihovne-jackdaw/</a>
</li>

<li>Pokročilý streaming založený na Apache Kafce, jazyku Clojure a knihovně Jackdaw (2. část)<br />
<a href="https://www.root.cz/clanky/pokrocily-streaming-zalozeny-na-apache-kafce-jazyku-clojure-a-knihovne-jackdaw-2-cast/">https://www.root.cz/clanky/pokrocily-streaming-zalozeny-na-apache-kafce-jazyku-clojure-a-knihovne-jackdaw-2-cast/</a>
</li>

<li>Pokročilý streaming založený na projektu Apache Kafka, jazyku Clojure a knihovně Jackdaw (streamy a kolony)<br />
<a href="https://www.root.cz/clanky/pokrocily-streaming-zalozeny-na-projektu-apache-kafka-jazyku-clojure-a-knihovne-jackdaw-streamy-a-kolony/">https://www.root.cz/clanky/pokrocily-streaming-zalozeny-na-projektu-apache-kafka-jazyku-clojure-a-knihovne-jackdaw-streamy-a-kolony/</a>
</li>

</ol>



<p><a name="k20"></a></p>
<h2 id="k20">20. Odkazy na Internetu</h2>

<ol>

<li>Learn Clojure - Flow Control<br />
<a href="https://clojure.org/guides/learn/flow">https://clojure.org/guides/learn/flow</a>
</li>

<li>clojure.core.logic<br />
<a href="https://clojuredocs.org/clojure.core.logic">https://clojuredocs.org/clojure.core.logic</a>
</li>

<li>ETL Batch Processing With Kafka?<br />
<a href="https://medium.com/swlh/etl-batch-processing-with-kafka-7f66f843e20d">https://medium.com/swlh/etl-batch-processing-with-kafka-7f66f843e20d</a>
</li>

<li>ETL with Kafka<br />
<a href="https://blog.codecentric.de/en/2018/03/etl-kafka/">https://blog.codecentric.de/en/2018/03/etl-kafka/</a>
</li>

<li>Building ETL Pipelines with Clojure and Transducers<br />
<a href="https://www.grammarly.com/blog/engineering/building-etl-pipelines-with-clojure-and-transducers/">https://www.grammarly.com/blog/engineering/building-etl-pipelines-with-clojure-and-transducers/</a>
</li>

<li>pipeline (možné použít pro ETL)<br />
<a href="https://clojuredocs.org/clojure.core.async/pipeline">https://clojuredocs.org/clojure.core.async/pipeline</a>
</li>

<li>On Track with Apache Kafka – Building a Streaming ETL Solution with Rail Data<br />
<a href="https://www.confluent.io/blog/build-streaming-etl-solutions-with-kafka-and-rail-data/">https://www.confluent.io/blog/build-streaming-etl-solutions-with-kafka-and-rail-data/</a>
</li>

<li>Kafka - Understanding Offset Commits<br />
<a href="https://www.logicbig.com/tutorials/misc/kafka/committing-offsets.html">https://www.logicbig.com/tutorials/misc/kafka/committing-offsets.html</a>
</li>

<li>fundingcircle/jackdaw (na Clojars)<br />
<a href="https://clojars.org/fundingcircle/jackdaw/versions/0.7.6">https://clojars.org/fundingcircle/jackdaw/versions/0.7.6</a>
</li>

<li>Dokumentace ke knihovně jackdaw<br />
<a href="https://cljdoc.org/d/fundingcircle/jackdaw/0.7.6/doc/readme">https://cljdoc.org/d/fundingcircle/jackdaw/0.7.6/doc/readme</a>
</li>

<li>Jackdaw AdminClient API<br />
<a href="https://cljdoc.org/d/fundingcircle/jackdaw/0.7.6/doc/jackdaw-adminclient-api">https://cljdoc.org/d/fundingcircle/jackdaw/0.7.6/doc/jackdaw-adminclient-api</a>
</li>

<li>Jackdaw Client API<br />
<a href="https://cljdoc.org/d/fundingcircle/jackdaw/0.7.6/doc/jackdaw-client-api">https://cljdoc.org/d/fundingcircle/jackdaw/0.7.6/doc/jackdaw-client-api</a>
</li>

<li>Kafka.clj<br />
<a href="https://github.com/helins-io/kafka.clj">https://github.com/helins-io/kafka.clj</a>
</li>

<li>Použití nástroje Apache Kafka v aplikacích založených na mikroslužbách<br />
<a href="https://www.root.cz/clanky/pouziti-nastroje-apache-kafka-v-aplikacich-zalozenych-na-mikrosluzbach/">https://www.root.cz/clanky/pouziti-nastroje-apache-kafka-v-aplikacich-zalozenych-na-mikrosluzbach/</a>
</li>

<li>Apache Kafka: distribuovaná streamovací platforma<br />
<a href="https://www.root.cz/clanky/apache-kafka-distribuovana-streamovaci-platforma/">https://www.root.cz/clanky/apache-kafka-distribuovana-streamovaci-platforma/</a>
</li>

<li>Real-Time Payments with Clojure and Apache Kafka (podcast)<br />
<a href="https://www.evidentsystems.com/news/confluent-podcast-about-apache-kafka/">https://www.evidentsystems.com/news/confluent-podcast-about-apache-kafka/</a>
</li>

<li>Kafka and Clojure - Immutable event streams<br />
<a href="https://practicalli.github.io/kafka-and-clojure/">https://practicalli.github.io/kafka-and-clojure/</a>
</li>

<li>Kafka Streams, the Clojure way<br />
<a href="https://blog.davemartin.me/posts/kafka-streams-the-clojure-way/">https://blog.davemartin.me/posts/kafka-streams-the-clojure-way/</a>
</li>

<li>dvlopt.kafka na GitHubu<br />
<a href="https://github.com/helins-io/kafka.clj">https://github.com/helins-io/kafka.clj</a>
</li>

<li>kafka-streams-the-clojure-way na GitHubu<br />
<a href="https://github.com/DaveWM/kafka-streams-the-clojure-way">https://github.com/DaveWM/kafka-streams-the-clojure-way</a>
</li>

<li>babashka: A Clojure babushka for the grey areas of Bash<br />
<a href="https://github.com/borkdude/babashka">https://github.com/borkdude/babashka</a>
</li>

<li>Babashka and the Small Clojure Interpreter @ ClojureD 2020 (slajdy)<br />
<a href="https://speakerdeck.com/borkdude/babashka-and-the-small-clojure-interpreter-at-clojured-2020">https://speakerdeck.com/borkdude/babashka-and-the-small-clojure-interpreter-at-clojured-2020</a>
</li>

<li>Babashka: ukázky použití<br />
<a href="https://github.com/borkdude/babashka/blob/master/doc/examples.md">https://github.com/borkdude/babashka/blob/master/doc/examples.md</a>
</li>

<li>clojureD 2020: "Babashka and Small Clojure Interpreter: Clojure in new contexts" by Michiel Borkent<br />
<a href="https://www.youtube.com/watch?v=Nw8aN-nrdEk&amp;t=5s">https://www.youtube.com/watch?v=Nw8aN-nrdEk&amp;t=5s</a>
</li>

<li>Meetup #124 Babashka, implementing an nREPL server &amp; game engines with Clojure<br />
<a href="https://www.youtube.com/watch?v=0YmZYnwyHHc">https://www.youtube.com/watch?v=0YmZYnwyHHc</a>
</li>

<li>The Last Programming Language (shrnutí vývoje programovacích jazyků)<br />
<a href="https://www.youtube.com/watch?v=P2yr-3F6PQo">https://www.youtube.com/watch?v=P2yr-3F6PQo</a>
</li>

<li>Shebang (Unix): Wikipedia EN<br />
<a href="https://en.wikipedia.org/wiki/Shebang_(Unix)">https://en.wikipedia.org/wiki/Shebang_(Unix)</a>
</li>

<li>Shebang (Unix): Wikipedia CZ<br />
<a href="https://cs.wikipedia.org/wiki/Shebang_(Unix)">https://cs.wikipedia.org/wiki/Shebang_(Unix)</a>
</li>

<li>How to create Clojure notebooks in Jupyter<br />
<a href="https://s01blog.wordpress.com/2017/12/10/how-to-create-clojure-notebooks-in-jupyter/">https://s01blog.wordpress.com/2017/12/10/how-to-create-clojure-notebooks-in-jupyter/</a>
</li>

<li>Dokumentace k&nbsp;nástroji Conda<br />
<a href="https://docs.conda.io/en/latest/">https://docs.conda.io/en/latest/</a>
</li>

<li>Notebook interface<br />
<a href="https://en.wikipedia.org/wiki/Notebook_interface">https://en.wikipedia.org/wiki/Notebook_interface</a>
</li>

<li>Jypyter: open source, interactive data science and scientific computing across over 40 programming languages<br />
<a href="https://jupyter.org/">https://jupyter.org/</a>
</li>

<li>Calysto Scheme<br />
<a href="https://github.com/Calysto/calysto_scheme">https://github.com/Calysto/calysto_scheme</a>
</li>

<li>scheme.py (základ projektu Calysto Scheme)<br />
<a href="https://github.com/Calysto/calysto_scheme/blob/master/calysto_scheme/scheme.py">https://github.com/Calysto/calysto_scheme/blob/master/calysto_scheme/scheme.py</a>
</li>

<li>Humane test output for clojure.test<br />
<a href="https://github.com/pjstadig/humane-test-output">https://github.com/pjstadig/humane-test-output</a>
</li>

<li>iota<br />
<a href="https://github.com/juxt/iota">https://github.com/juxt/iota</a>
</li>

<li>5 Differences between clojure.spec and Schema<br />
<a href="https://lispcast.com/clojure.spec-vs-schema/">https://lispcast.com/clojure.spec-vs-schema/</a>
</li>

<li>Schema: Clojure(Script) library for declarative data description and validation<br />
<a href="https://github.com/plumatic/schema">https://github.com/plumatic/schema</a>
</li>

<li>Zip archiv s&nbsp;Clojure 1.9.0<br />
<a href="http://repo1.maven.org/maven2/org/clojure/clojure/1.9.0/clojure-1.9.0.zip">http://repo1.maven.org/maven2/org/clojure/clojure/1.9.0/clojure-1.9.0.zip</a>
</li>

<li>Clojure 1.9 is now available<br />
<a href="https://clojure.org/news/2017/12/08/clojure19">https://clojure.org/news/2017/12/08/clojure19</a>
</li>

<li>Deps and CLI Guide<br />
<a href="https://clojure.org/guides/deps_and_cli">https://clojure.org/guides/deps_and_cli</a>
</li>

<li>Changes to Clojure in Version 1.9<br />
<a href="https://github.com/clojure/clojure/blob/master/changes.md">https://github.com/clojure/clojure/blob/master/changes.md</a>
</li>

<li>clojure.spec - Rationale and Overview<br />
<a href="https://clojure.org/about/spec">https://clojure.org/about/spec</a>
</li>

<li>Zip archiv s&nbsp;Clojure 1.8.0<br />
<a href="http://repo1.maven.org/maven2/org/clojure/clojure/1.8.0/clojure-1.8.0.zip">http://repo1.maven.org/maven2/org/clojure/clojure/1.8.0/clojure-1.8.0.zip</a>
</li>

<li>Clojure 1.8 is now available<br />
<a href="http://clojure.org/news/2016/01/19/clojure18">http://clojure.org/news/2016/01/19/clojure18</a>
</li>

<li>Socket Server REPL<br />
<a href="http://dev.clojure.org/display/design/Socket+Server+REPL">http://dev.clojure.org/display/design/Socket+Server+REPL</a>
</li>

<li>CLJ-1671: Clojure socket server<br />
<a href="http://dev.clojure.org/jira/browse/CLJ-1671">http://dev.clojure.org/jira/browse/CLJ-1671</a>
</li>

<li>CLJ-1449: Add clojure.string functions for portability to ClojureScript<br />
<a href="http://dev.clojure.org/jira/browse/CLJ-1449">http://dev.clojure.org/jira/browse/CLJ-1449</a>
</li>

<li>Launching a Socket Server<br />
<a href="http://clojure.org/reference/repl_and_main#_launching_a_socket_server">http://clojure.org/reference/repl_and_main#_launching_a_socket_server</a>
</li>

<li>API for clojure.string<br />
<a href="http://clojure.github.io/clojure/branch-master/clojure.string-api.html">http://clojure.github.io/clojure/branch-master/clojure.string-api.html</a>
</li>

<li>Clojars:<br />
<a href="https://clojars.org/">https://clojars.org/</a>
</li>

<li>Seznam knihoven na Clojars:<br />
<a href="https://clojars.org/projects">https://clojars.org/projects</a>
</li>

<li>Clojure Cookbook: Templating HTML with Enlive<br />
<a href="https://github.com/clojure-cookbook/clojure-cookbook/blob/master/07_webapps/7-11_enlive.asciidoc">https://github.com/clojure-cookbook/clojure-cookbook/blob/master/07_webapps/7-11_enlive.asciidoc</a>
</li>

<li>An Introduction to Enlive<br />
<a href="https://github.com/swannodette/enlive-tutorial/">https://github.com/swannodette/enlive-tutorial/</a>
</li>

<li>Enlive na GitHubu<br />
<a href="https://github.com/cgrand/enlive">https://github.com/cgrand/enlive</a>
</li>

<li>Expectations: příklady atd.<br />
<a href="http://jayfields.com/expectations/">http://jayfields.com/expectations/</a>
</li>

<li>Expectations na GitHubu<br />
<a href="https://github.com/jaycfields/expectations">https://github.com/jaycfields/expectations</a>
</li>

<li>Lein-expectations na GitHubu<br />
<a href="https://github.com/gar3thjon3s/lein-expectations">https://github.com/gar3thjon3s/lein-expectations</a>
</li>

<li>Testing Clojure With Expectations<br />
<a href="https://semaphoreci.com/blog/2014/09/23/testing-clojure-with-expectations.html">https://semaphoreci.com/blog/2014/09/23/testing-clojure-with-expectations.html</a>
</li>

<li>Clojure testing TDD/BDD libraries: clojure.test vs Midje vs Expectations vs Speclj<br />
<a href="https://www.reddit.com/r/Clojure/comments/1viilt/clojure_testing_tddbdd_libraries_clojuretest_vs/">https://www.reddit.com/r/Clojure/comments/1viilt/clojure_testing_tddbdd_libraries_clojuretest_vs/</a>
</li>

<li>Testing: One assertion per test<br />
<a href="http://blog.jayfields.com/2007/06/testing-one-assertion-per-test.html">http://blog.jayfields.com/2007/06/testing-one-assertion-per-test.html</a>
</li>

<li>Rewriting Your Test Suite in Clojure in 24 hours<br />
<a href="http://blog.circleci.com/rewriting-your-test-suite-in-clojure-in-24-hours/">http://blog.circleci.com/rewriting-your-test-suite-in-clojure-in-24-hours/</a>
</li>

<li>Clojure doc: zipper<br />
<a href="http://clojuredocs.org/clojure.zip/zipper">http://clojuredocs.org/clojure.zip/zipper</a>
</li>

<li>Clojure doc: parse<br />
<a href="http://clojuredocs.org/clojure.xml/parse">http://clojuredocs.org/clojure.xml/parse</a>
</li>

<li>Clojure doc: xml-zip<br />
<a href="http://clojuredocs.org/clojure.zip/xml-zip">http://clojuredocs.org/clojure.zip/xml-zip</a>
</li>

<li>Clojure doc: xml-seq<br />
<a href="http://clojuredocs.org/clojure.core/xml-seq">http://clojuredocs.org/clojure.core/xml-seq</a>
</li>

<li>Parsing XML in Clojure<br />
<a href="https://github.com/clojuredocs/guides">https://github.com/clojuredocs/guides</a>
</li>

<li>Clojure Zipper Over Nested Vector<br />
<a href="https://vitalyper.wordpress.com/2010/11/23/clojure-zipper-over-nested-vector/">https://vitalyper.wordpress.com/2010/11/23/clojure-zipper-over-nested-vector/</a>
</li>

<li>Understanding Clojure's PersistentVector implementation<br />
<a href="http://blog.higher-order.net/2009/02/01/understanding-clojures-persistentvector-implementation">http://blog.higher-order.net/2009/02/01/understanding-clojures-persistentvector-implementation</a>
</li>

<li>Understanding Clojure's PersistentHashMap (deftwice...)<br />
<a href="http://blog.higher-order.net/2009/09/08/understanding-clojures-persistenthashmap-deftwice.html">http://blog.higher-order.net/2009/09/08/understanding-clojures-persistenthashmap-deftwice.html</a>
</li>

<li>Assoc and Clojure's PersistentHashMap: part ii<br />
<a href="http://blog.higher-order.net/2010/08/16/assoc-and-clojures-persistenthashmap-part-ii.html">http://blog.higher-order.net/2010/08/16/assoc-and-clojures-persistenthashmap-part-ii.html</a>
</li>

<li>Ideal Hashtrees (paper)<br />
<a href="http://lampwww.epfl.ch/papers/idealhashtrees.pdf">http://lampwww.epfl.ch/papers/idealhashtrees.pdf</a>
</li>

<li>4Clojure<br />
<a href="http://www.4clojure.com/">http://www.4clojure.com/</a>
</li>

<li>ClojureDoc (rozcestník s&nbsp;dokumentací jazyka Clojure)<br />
<a href="http://clojuredocs.org/">http://clojuredocs.org/</a>
</li>

<li>Clojure (na Wikipedia EN)<br />
<a href="http://en.wikipedia.org/wiki/Clojure">http://en.wikipedia.org/wiki/Clojure</a>
</li>

<li>Clojure (na Wikipedia CS)<br />
<a href="http://cs.wikipedia.org/wiki/Clojure">http://cs.wikipedia.org/wiki/Clojure</a>
</li>

<li>SICP (The Structure and Interpretation of Computer Programs)<br />
<a href="http://mitpress.mit.edu/sicp/">http://mitpress.mit.edu/sicp/</a>
</li>

<li>Pure function<br />
<a href="http://en.wikipedia.org/wiki/Pure_function">http://en.wikipedia.org/wiki/Pure_function</a>
</li>

<li>Funkcionální programování<br />
<a href="http://cs.wikipedia.org/wiki/Funkcionální_programování">http://cs.wikipedia.org/wiki/Funkcionální_programování</a>
</li>

<li>Čistě funkcionální (datové struktury, jazyky, programování)<br />
<a href="http://cs.wikipedia.org/wiki/Čistě_funkcionální">http://cs.wikipedia.org/wiki/Čistě_funkcionální</a>
</li>

<li>Clojure Macro Tutorial (Part I, Getting the Compiler to Write Your Code For You)<br />
<a href="http://www.learningclojure.com/2010/09/clojure-macro-tutorial-part-i-getting.html">http://www.learningclojure.com/2010/09/clojure-macro-tutorial-part-i-getting.html</a>
</li>

<li>Clojure Macro Tutorial (Part II: The Compiler Strikes Back)<br />
<a href="http://www.learningclojure.com/2010/09/clojure-macro-tutorial-part-ii-compiler.html">http://www.learningclojure.com/2010/09/clojure-macro-tutorial-part-ii-compiler.html</a>
</li>

<li>Clojure Macro Tutorial (Part III: Syntax Quote)<br />
<a href="http://www.learningclojure.com/2010/09/clojure-macro-tutorial-part-ii-syntax.html">http://www.learningclojure.com/2010/09/clojure-macro-tutorial-part-ii-syntax.html</a>
</li>

<li>Tech behind Tech: Clojure Macros Simplified<br />
<a href="http://techbehindtech.com/2010/09/28/clojure-macros-simplified/">http://techbehindtech.com/2010/09/28/clojure-macros-simplified/</a>
</li>

<li>Fatvat - Exploring functional programming: Clojure Macros<br />
<a href="http://www.fatvat.co.uk/2009/02/clojure-macros.html">http://www.fatvat.co.uk/2009/02/clojure-macros.html</a>
</li>

</ol>



<p></p><p></p>
<p><small>Autor: <a href="http://www.fit.vutbr.cz/~tisnovpa">Pavel Tišnovský</a> &nbsp; 2021</small></p>
</body>
</html>
