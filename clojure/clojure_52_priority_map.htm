<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
        "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html>
<head>
<title></title>
<meta name="Author" content="Pavel Tisnovsky" />
<meta name="Generator" content="vim" />
<meta http-equiv="content-type" content="text/html; charset=utf-8" />
<style type="text/css">
         body {color:#000000; background:#ffffff;}
         h1  {font-family: arial, helvetica, sans-serif; color:#ffffff; background-color:#c00000; text-align:center; padding-left:1em}
         h2  {font-family: arial, helvetica, sans-serif; color:#ffffff; background-color:#0000c0; padding-left:1em; text-align:left}
         h3  {font-family: arial, helvetica, sans-serif; color:#000000; background-color:#c0c0c0; padding-left:1em; text-align:left}
         h4  {font-family: arial, helvetica, sans-serif; color:#000000; background-color:#e0e0e0; padding-left:1em; text-align:left}
         a   {font-family: arial, helvetica, sans-serif;}
         li  {font-family: arial, helvetica, sans-serif; color:#000000; text-align:justify; width:450px;}
         ol  {font-family: arial, helvetica, sans-serif; color:#000000; text-align:justify; width:450px;}
         ul  {font-family: arial, helvetica, sans-serif; color:#000000; text-align:justify; width:450px;}
         p   {font-family: arial, helvetica, sans-serif; color:#000000; text-align:justify;}
         pre {background:#e0e0e0}
</style>
</head>

<body>

<h1></h1>

<h3>Pavel Tišnovský</h3>

<p></p>

<h1>Úvodník</h1>

<p></p>



<h2>Obsah</h2>

<p><a href="#k01">*** 1. Mapy &ndash; nejdůležitější datový typ programovacího jazyka Clojure</a></p>
<p><a href="#k02">*** 2. Typy map v&nbsp;Clojure</a></p>
<p><a href="#k03">*** 3. Implementace třídy <strong>clojure.lang.PersistentHashMap</strong></a></p>
<p><a href="#k04">*** 4. Rozhraní <strong>INode</strong></a></p>
<p><a href="#k05">*** 5. Třídy <strong>ArrayNode</strong> a <strong>BitmapIndexedNode</strong></a></p>
<p><a href="#k06">*** 6. Nový užitečný typ mapy: <strong>priority-map</strong></a></p>
<p><a href="#k07">*** 7. Příprava projektu pro otestování vlastností jednotlivých implementací map</a></p>
<p><a href="#k08">*** 8. Přidání nové závislosti a stažení potřebných knihoven</a></p>
<p><a href="#k09">*** 9. Spuštění interaktivní smyčky REPL a import potřebného modulu</a></p>
<p><a href="#k10">*** 10. Otestování vlastností mapy typu <strong>hash-map</strong></a></p>
<p><a href="#k11">*** 11. Otestování vlastností mapy typu <strong>sorted-map</strong></a></p>
<p><a href="#k12">*** 12. Otestování vlastností mapy typu <strong>array-map</strong></a></p>
<p><a href="#k13">*** 13. Otestování vlastností mapy typu <strong>priority-map</strong></a></p>
<p><a href="#k14">*** 14. Základní operace s&nbsp;mapami: <strong>assoc</strong> a <strong>dissoc</strong></a></p>
<p><a href="#k15">*** 15. Vyhledávání prvků, získání klíčů a hodnot</a></p>
<p><a href="#k16">*** 16. Operace <strong>merge</strong> a <strong>zipmap</strong></a></p>
<p><a href="#k17">*** 17. </a></p>
<p><a href="#k18">*** 18. Repositář s&nbsp;demonstračními příklady</a></p>
<p><a href="#k19">*** 19. Odkazy na předchozí části seriálu o programovacím jazyku Clojure</a></p>
<p><a href="#k20">*** 20. Odkazy na Internetu</a></p>



<p><a name="k01"></a></p>
<h2 id="k01">1. Mapy &ndash; nejdůležitější datový typ programovacího jazyka Clojure</h2>



<p><a name="k02"></a></p>
<h2 id="k02">2. Typy map v&nbsp;Clojure</h2>

<p>Mapy v&nbsp;programovacím jazyku Clojure existují ve třech základních
variantách, jejichž vlastnosti (důležité pro programátora) jsou shrnuty
v&nbsp;tabulce zobrazené pod tímto odstavcem:</p>

<table>
<tr><th> #</th><th>Vlastnost</th><th>Hash map</th><th>Sorted map</th><th>Array map</th></tr>
<tr><td> 1</td><td>konstruktor</td><td>(hash-map ...)</td><td>(sorted-map ...)</td><th>(array-map)</th></tr>
<tr><td> 2</td><td>&bdquo;literál&ldquo;</td><td>{klíč hodnota klíč hodnota...}</td><td>&times;</td><td>&times;</td></tr>
<tr><td> 3</td><td>složitost přístupu k&nbsp;prvkům</td><td>O(log<sub>32</sub>N)</td><td>O(N)</td><td>O(N)</td></tr>
<tr><td> 4</td><td>složitost <strong>(count)</strong></td><td>O(1)</td><td>O(1)</td><td>O(1)</td></tr>
<tr><td> 5</td><td>zachování pořadí</td><td>ne</td><td>ne</td><td>ano</td></tr>
<tr><td> 6</td><td>setříděné prvky</td><td>ne</td><td>ano</td><td>ne</td></tr>
<tr><td> 7</td><td>podpora <strong>(seq)</strong></td><td>ano</td><td>ano</td><td>ano</td></tr>
<tr><td> 8</td><td>podpora <strong>(rseq)</strong></td><td>ne</td><td>ano</td><td>ano</td></tr>
<tr><td> 9</td><td>klíče <strong>nil</strong></td><td>ano</td><td>ano</td><td>ano</td></tr>
<tr><td>10</td><td>hodnoty <strong>nil</strong></td><td>ano</td><td>ano</td><td>ano</td></tr>
</table>



<pre>
$ <strong>lein new app priority-map-1</strong>
&nbsp;
Generating a project called priority-map-1 based on the 'app' template.
</pre>

<pre>
.
├── CHANGELOG.md
├── doc
│   └── intro.md
├── LICENSE
├── project.clj
├── README.md
├── resources
├── src
│   └── priority_map_1
│       └── core.clj
└── test
    └── priority_map_1
        └── core_test.clj

6 directories, 7 files
</pre>

<pre>
(defproject priority-map-1 "0.1.0-SNAPSHOT"
  :description "FIXME: write description"
  :url "http://example.com/FIXME"
  :license {:name "EPL-2.0 OR GPL-2.0-or-later WITH Classpath-exception-2.0"
            :url "https://www.eclipse.org/legal/epl-2.0/"}
  :dependencies [[org.clojure/clojure "1.10.1"]]
  :main ^:skip-aot priority-map-1.core
  :target-path "target/%s"
  :profiles {:uberjar {:aot :all
                       :jvm-opts ["-Dclojure.compiler.direct-linking=true"]}})
</pre>



<p><a name="k03"></a></p>
<h2 id="k03">3. Implementace třídy <strong>clojure.lang.PersistentHashMap</strong></h2>

<pre>
(defproject priority-map-1 "0.1.0-SNAPSHOT"
  :description "FIXME: write description"
  :url "http://example.com/FIXME"
  :license {:name "EPL-2.0 OR GPL-2.0-or-later WITH Classpath-exception-2.0"
            :url "https://www.eclipse.org/legal/epl-2.0/"}
  :dependencies [[org.clojure/clojure "1.10.1"]
                 [org.clojure/data.priority-map "1.0.0"]]
  :main ^:skip-aot priority-map-1.core
  :target-path "target/%s"
  :profiles {:uberjar {:aot :all
                       :jvm-opts ["-Dclojure.compiler.direct-linking=true"]}})
</pre>

<pre>
$ <strong>lein deps</strong>
&nbsp;
Retrieving org/clojure/data.priority-map/1.0.0/data.priority-map-1.0.0.pom from central
Retrieving org/clojure/data.priority-map/1.0.0/data.priority-map-1.0.0.jar from central
</pre>



<p><a name="k04"></a></p>
<h2 id="k04">4. Rozhraní <strong>INode</strong></h2>

<pre>
$ <strong>lein repl</strong>
</pre>

<pre>
nREPL server started on port 33211 on host 127.0.0.1 - nrepl://127.0.0.1:33211
REPL-y 0.4.4, nREPL 0.7.0
Clojure 1.10.1
OpenJDK 64-Bit Server VM 1.8.0_191-b12
    Docs: (doc function-name-here)
          (find-doc "part-of-name-here")
  Source: (source function-name-here)
 Javadoc: (javadoc java-object-or-class-here)
    Exit: Control+D or (exit) or (quit)
 Results: Stored in vars *1, *2, *3, an exception in *e

priority-map-1.core=>
</pre>

<pre>
priority-map-1.core=&gt; <strong>(use 'clojure.data.priority-map)</strong>
WARNING: subseq already refers to: #'clojure.core/subseq in namespace: priority-map-1.core, being replaced by: #'clojure.data.priority-map/subseq
WARNING: rsubseq already refers to: #'clojure.core/rsubseq in namespace: priority-map-1.core, being replaced by: #'clojure.data.priority-map/rsubseq
</pre>

<pre>
priority-map-1.core=&gt; <strong>(require '[clojure.data.priority-map :refer [priority-map]])</strong>
</pre>



<p><a name="k05"></a></p>
<h2 id="k05">5. </h2>

<pre>
priority-map-1.core=&gt; <strong>(doc hash-map)</strong>
-------------------------
clojure.core/hash-map
([] [& keyvals])
  keyval => key val
  Returns a new hash map with supplied mappings.  If any keys are
  equal, they are handled as if by repeated uses of assoc.
</pre>

priority-map-1.core=&gt; <strong>(def p1 (hash-map :a 2 :b 1 :c 3 :d 5 :e 4 :f 3 :g 0 :h 10 :i 6 :j 7))</strong>
#'priority-map-1.core/p1

priority-map-1.core=&gt; <strong>p1</strong>
{:a 2 :b 1 :c 3 :d 5 :e 4 :f 3 :g 0 :h 10 :i 6 :j 7}

priority-map-1.core=&gt; <strong>(keys p1)</strong>
(:e :g :c :j :h :b :d :f :i :a)

priority-map-1.core=&gt; <strong>(vals p1)</strong>
(4 0 3 7 10 1 5 3 6 2)

priority-map-1.core=&gt; <strong>(doseq [[key val] p1] (println key val))</strong>
:e 4
:g 0
:c 3
:j 7
:h 10
:b 1
:d 5
:f 3
:i 6
:a 2

priority-map-1.core=&gt; <strong>(def p1r (hash-map :j 2 :i 1 :h 3 :g 5 :f 4 :e 3 :d 0 :c 10 :b 6 :a 7))</strong>
#'priority-map-1.core/p1r

priority-map-1.core=&gt; <strong>p1r</strong>
{:a 7 :b 6 :c 10 :d 0 :e 3 :f 4 :g 5 :h 3 :i 1 :j 2}

priority-map-1.core=&gt; <strong>(keys p1r)</strong>
(:e :g :c :j :h :b :d :f :i :a)

priority-map-1.core=&gt; <strong>(vals p1r)</strong>
(3 5 10 2 3 6 0 4 1 7)

priority-map-1.core=&gt; <strong>(doseq [[key val] p1r] (println key val))</strong>
:e 3
:g 5
:c 10
:j 2
:h 3
:b 6
:d 0
:f 4
:i 1
:a 7

priority-map-1.core=&gt; <strong>(def p1e (hash-map))</strong>
#'priority-map-1.core/p1e

priority-map-1.core=&gt; <strong>p1e</strong>
{}



<p><a name="k06"></a></p>
<h2 id="k06">6. </h2>

priority-map-1.core=&gt; <strong>(doc sorted-map)</strong>
-------------------------
clojure.core/sorted-map
([& keyvals])
  keyval => key val
  Returns a new sorted map with supplied mappings.  If any keys are
  equal, they are handled as if by repeated uses of assoc.
nil

priority-map-1.core=&gt; <strong>(def p2 (sorted-map :a 2 :b 1 :c 3 :d 5 :e 4 :f 3 :g 0 :h 10 :i 6 :j 7))</strong>
#'priority-map-1.core/p2

priority-map-1.core=&gt; <strong>(keys p2)</strong>
(:a :b :c :d :e :f :g :h :i :j)

priority-map-1.core=&gt; <strong>(vals p2)</strong>
(2 1 3 5 4 3 0 10 6 7)

priority-map-1.core=&gt; <strong>p2</strong>
{:a 2 :b 1 :c 3 :d 5 :e 4 :f 3 :g 0 :h 10 :i 6 :j 7}

priority-map-1.core=&gt; <strong>(doseq [[key val] p2] (println key val))</strong>
:a 2
:b 1
:c 3
:d 5
:e 4
:f 3
:g 0
:h 10
:i 6
:j 7

priority-map-1.core=&gt; <strong>(def p2r (sorted-map :j 2 :i 1 :h 3 :g 5 :f 4 :e 3 :d 0 :c 10 :b 6 :a 7))</strong>
#'priority-map-1.core/p2r

priority-map-1.core=&gt; <strong>p2r</strong>
{:a 7 :b 6 :c 10 :d 0 :e 3 :f 4 :g 5 :h 3 :i 1 :j 2}

priority-map-1.core=&gt; <strong>(keys p2r)</strong>
(:a :b :c :d :e :f :g :h :i :j)

priority-map-1.core=&gt; <strong>(vals p2r)</strong>
(7 6 10 0 3 4 5 3 1 2)

priority-map-1.core=&gt; <strong>(doseq [[key val] p2r] (println key val))</strong>
:a 7
:b 6
:c 10
:d 0
:e 3
:f 4
:g 5
:h 3
:i 1
:j 2

priority-map-1.core=&gt; <strong>(def p2e (sorted-map))</strong>
#'priority-map-1.core/p2e

priority-map-1.core=&gt; <strong>p2e</strong>
{}

priority-map-1.core=&gt; <strong>(sorted-map-by (comparator <) 0 :a 1 :b 2 :c)</strong>
{0 :a 1 :b 2 :c}

priority-map-1.core=&gt; <strong>(sorted-map-by (comparator >) 0 :a 1 :b 2 :c)</strong>
{2 :c 1 :b 0 :a}



<p><a name="k07"></a></p>
<h2 id="k07">7. </h2>

priority-map-1.core=&gt; <strong>(doc array-map)</strong>
-------------------------
clojure.core/array-map
([] [& keyvals])
  Constructs an array-map. If any keys are equal, they are handled as
  if by repeated uses of assoc.

priority-map-1.core=&gt; <strong>(def p3 (array-map :a 2 :b 1 :c 3 :d 5 :e 4 :f 3 :g 0 :h 10 :i 6 :j 7))</strong>
#'priority-map-1.core/p3

priority-map-1.core=&gt; <strong>p3</strong>
{:a 2 :b 1 :c 3 :d 5 :e 4 :f 3 :g 0 :h 10 :i 6 :j 7}

priority-map-1.core=&gt; <strong>(keys p3)</strong>
(:a :b :c :d :e :f :g :h :i :j)

priority-map-1.core=&gt; <strong>(vals p3)</strong>
(2 1 3 5 4 3 0 10 6 7)

priority-map-1.core=&gt; <strong>(doseq [[key val] p3] (println key val))</strong>
:a 2
:b 1
:c 3
:d 5
:e 4
:f 3
:g 0
:h 10
:i 6
:j 7

priority-map-1.core=&gt; <strong>(def p3r (array-map :j 2 :i 1 :h 3 :g 5 :f 4 :e 3 :d 0 :c 10 :b 6 :a 7))</strong>
#'priority-map-1.core/p3r

priority-map-1.core=&gt; <strong>p3r</strong>
{:a 7 :b 6 :c 10 :d 0 :e 3 :f 4 :g 5 :h 3 :i 1 :j 2}

priority-map-1.core=&gt; <strong>(keys p3r)</strong>
(:j :i :h :g :f :e :d :c :b :a)

priority-map-1.core=&gt; <strong>(vals p3r)</strong>
(2 1 3 5 4 3 0 10 6 7)

priority-map-1.core=&gt; <strong>(doseq [[key val] p3r] (println key val))</strong>
:j 2
:i 1
:h 3
:g 5
:f 4
:e 3
:d 0
:c 10
:b 6
:a 7



<p><a name="k08"></a></p>
<h2 id="k08">8. </h2>

priority-map-1.core=&gt; <strong>(doc priority-map)</strong>
-------------------------
clojure.data.priority-map/priority-map
([& keyvals])
  Usage: (priority-map key val key val ...)
  Returns a new priority map with optional supplied mappings.
  (priority-map) returns an empty priority map.

priority-map-1.core=&gt; <strong>(def p4 (priority-map :a 2 :b 1 :c 3 :d 5 :e 4 :f 3 :g 0 :h 10 :i 6 :j 7))</strong>
#'priority-map-1.core/p4

priority-map-1.core=&gt; <strong>p4</strong>
{:g 0 :b 1 :a 2 :c 3 :f 3 :e 4 :d 5 :i 6 :j 7 :h 10}

priority-map-1.core=&gt; <strong>(keys p4)</strong>
(:g :b :a :c :f :e :d :i :j :h)

priority-map-1.core=&gt; <strong>(vals p4)</strong>
(0 1 2 3 3 4 5 6 7 10)

priority-map-1.core=&gt; <strong>(def p4r (priority-map :j 2 :i 1 :h 3 :g 5 :f 4 :e 3 :d 0 :c 10 :b 6 :a 7))</strong>
#'priority-map-1.core/p4r

priority-map-1.core=&gt; <strong>p4r</strong>
{:d 0 :i 1 :j 2 :e 3 :h 3 :f 4 :g 5 :b 6 :a 7 :c 10}

priority-map-1.core=&gt; <strong>(keys p4r)</strong>
(:d :i :j :e :h :f :g :b :a :c)

priority-map-1.core=&gt; <strong>(vals p4r)</strong>
(0 1 2 3 3 4 5 6 7 10)

priority-map-1.core=&gt; <strong>(def p4e (priority-map))</strong>
#'priority-map-1.core/p4e

priority-map-1.core=&gt; <strong>p4e</strong>
{}



<p><a name="k09"></a></p>
<h2 id="k09">9. </h2>

priority-map-1.core=&gt; <strong>(doc assoc)</strong>
-------------------------
clojure.core/assoc
([map key val] [map key val & kvs])
  assoc[iate]. When applied to a map, returns a new map of the
    same (hashed/sorted) type, that contains the mapping of key(s) to
    val(s). When applied to a vector, returns a new vector that
    contains val at index. Note - index must be <= (count vector).

priority-map-1.core=&gt; <strong>(doc dissoc)</strong>
-------------------------
clojure.core/dissoc
([map] [map key] [map key & ks])
  dissoc[iate]. Returns a new map of the same (hashed/sorted) type,
  that does not contain a mapping for key(s).

priority-map-1.core=&gt; <strong>(doc conj)</strong>
-------------------------
clojure.core/conj
([coll x] [coll x & xs])
  conj[oin]. Returns a new collection with the xs
    'added'. (conj nil item) returns (item).  The 'addition' may
    happen at different 'places' depending on the concrete type.

priority-map-1.core=&gt; <strong>(doc update)</strong>
-------------------------
clojure.core/update
([m k f] [m k f x] [m k f x y] [m k f x y z] [m k f x y z & more])
  'Updates' a value in an associative structure, where k is a
  key and f is a function that will take the old value
  and any supplied args and return the new value, and returns a new
  structure.  If the key does not exist, nil is passed as the old value.



<p><a name="k10"></a></p>
<h2 id="k10">10. </h2>

priority-map-1.core=&gt; <strong>(conj p1 {:foo :bar})</strong>
{:a 2 :b 1 :c 3 :d 5 :e 4 :f 3 :foo :bar :g 0 :h 10 :i 6 :j 7}

priority-map-1.core=&gt; <strong>(conj p2 {:foo :bar})</strong>
{:a 2 :b 1 :c 3 :d 5 :e 4 :f 3 :foo :bar :g 0 :h 10 :i 6 :j 7}

priority-map-1.core=&gt; <strong>(conj p3 {:foo :bar})</strong>
{:a 2 :b 1 :c 3 :d 5 :e 4 :f 3 :foo :bar :g 0 :h 10 :i 6 :j 7}

priority-map-1.core=&gt; <strong>(conj p4 {:foo :bar})</strong>
Execution error (ClassCastException) at clojure.data.priority_map.PersistentPriorityMap/assoc (priority_map.clj:302).
java.lang.Long cannot be cast to clojure.lang.Keyword

priority-map-1.core=&gt; <strong>(conj p4 {:foo 99})</strong>
{:g 0 :b 1 :a 2 :c 3 :f 3 :e 4 :d 5 :i 6 :j 7 :h 10 :foo 99}

priority-map-1.core=&gt; <strong>(conj p4 {:bar 0})</strong>
{:bar 0 :g 0 :b 1 :a 2 :c 3 :f 3 :e 4 :d 5 :i 6 :j 7 :h 10}



<p><a name="k11"></a></p>
<h2 id="k11">11. </h2>



<p><a name="k12"></a></p>
<h2 id="k12">12. </h2>



<p><a name="k13"></a></p>
<h2 id="k13">13. </h2>



<p><a name="k14"></a></p>
<h2 id="k14">14. </h2>



<p><a name="k15"></a></p>
<h2 id="k15">15. </h2>



<p><a name="k16"></a></p>
<h2 id="k16">16. </h2>



<p><a name="k17"></a></p>
<h2 id="k17">17. </h2>



<p><a name="k18"></a></p>
<h2 id="k18">18. Repositář s&nbsp;demonstračními příklady</h2>



<p><a name="k19"></a></p>
<h2 id="k19">19. Odkazy na předchozí části seriálu o programovacím jazyku Clojure</h2>

<ol>

<li>Clojure  1: Úvod<br />
<a href="http://www.root.cz/clanky/clojure-aneb-jazyk-umoznujici-tvorbu-bezpecnych-vicevlaknovych-aplikaci-pro-jvm/">http://www.root.cz/clanky/clojure-aneb-jazyk-umoznujici-tvorbu-bezpecnych-vicevlaknovych-aplikaci-pro-jvm/</a>
</li>

<li>Clojure  2: Symboly, kolekce atd.<br />
<a href="http://www.root.cz/clanky/clojure-aneb-jazyk-umoznujici-tvorbu-bezpecnych-vicevlaknovych-aplikaci-pro-jvm-2-cast/">http://www.root.cz/clanky/clojure-aneb-jazyk-umoznujici-tvorbu-bezpecnych-vicevlaknovych-aplikaci-pro-jvm-2-cast/</a>
</li>

<li>Clojure  3: Funkcionální programování<br />
<a href="http://www.root.cz/clanky/clojure-aneb-jazyk-umoznujici-tvorbu-bezpecnych-vicevlaknovych-aplikaci-pro-jvm-3-cast-funkcionalni-programovani/">http://www.root.cz/clanky/clojure-aneb-jazyk-umoznujici-tvorbu-bezpecnych-vicevlaknovych-aplikaci-pro-jvm-3-cast-funkcionalni-programovani/</a>
</li>

<li>Clojure  4: Kolekce, sekvence a lazy sekvence<br />
<a href="http://www.root.cz/clanky/clojure-aneb-jazyk-umoznujici-tvorbu-bezpecnych-vicevlaknovych-aplikaci-pro-jvm-4-cast-kolekce-sekvence-a-lazy-sekvence/">http://www.root.cz/clanky/clojure-aneb-jazyk-umoznujici-tvorbu-bezpecnych-vicevlaknovych-aplikaci-pro-jvm-4-cast-kolekce-sekvence-a-lazy-sekvence/</a>
</li>

<li>Clojure  5: Sekvence, lazy sekvence a paralelní programy<br />
<a href="http://www.root.cz/clanky/clojure-a-bezpecne-aplikace-pro-jvm-sekvence-lazy-sekvence-a-paralelni-programy/">http://www.root.cz/clanky/clojure-a-bezpecne-aplikace-pro-jvm-sekvence-lazy-sekvence-a-paralelni-programy/</a>
</li>

<li>Clojure  6: Podpora pro paralelní programování<br />
<a href="http://www.root.cz/clanky/programovaci-jazyk-clojure-6-futures-nejsou-jen-financni-derivaty/">http://www.root.cz/clanky/programovaci-jazyk-clojure-6-futures-nejsou-jen-financni-derivaty/</a>
</li>

<li>Clojure  7: Další funkce pro paralelní programování<br />
<a href="http://www.root.cz/clanky/programovaci-jazyk-clojure-7-dalsi-podpurne-prostredky-pro-paralelni-programovani/">http://www.root.cz/clanky/programovaci-jazyk-clojure-7-dalsi-podpurne-prostredky-pro-paralelni-programovani/</a>
</li>

<li>Clojure  8: Identity, stavy, neměnné hodnoty a reference<br />
<a href="http://www.root.cz/clanky/programovaci-jazyk-clojure-8-identity-stavy-nemenne-hodnoty-a-referencni-typy/">http://www.root.cz/clanky/programovaci-jazyk-clojure-8-identity-stavy-nemenne-hodnoty-a-referencni-typy/</a>
</li>

<li>Clojure  9: Validátory, pozorovatelé a kooperace s Javou<br />
<a href="http://www.root.cz/clanky/programovaci-jazyk-clojure-9-validatory-pozorovatele-a-kooperace-mezi-clojure-a-javou/">http://www.root.cz/clanky/programovaci-jazyk-clojure-9-validatory-pozorovatele-a-kooperace-mezi-clojure-a-javou/</a>
</li>

<li>Clojure 10: Kooperace mezi Clojure a Javou<br />
<a href="http://www.root.cz/clanky/programovaci-jazyk-clojure-10-kooperace-mezi-clojure-a-javou-pokracovani/">http://www.root.cz/clanky/programovaci-jazyk-clojure-10-kooperace-mezi-clojure-a-javou-pokracovani/</a>
</li>

<li>Clojure 11: Generátorová notace seznamu/list comprehension<br />
<a href="http://www.root.cz/clanky/programovaci-jazyk-clojure-11-generatorova-notace-seznamu-list-comprehension/">http://www.root.cz/clanky/programovaci-jazyk-clojure-11-generatorova-notace-seznamu-list-comprehension/</a>
</li>

<li>Clojure 12: Překlad programů z Clojure do bajtkódu JVM I:<br />
<a href="http://www.root.cz/clanky/programovaci-jazyk-clojure-12-preklad-programu-z-clojure-do-bajtkodu-jvm/">http://www.root.cz/clanky/programovaci-jazyk-clojure-12-preklad-programu-z-clojure-do-bajtkodu-jvm/</a>
</li>

<li>Clojure 13: Překlad programů z Clojure do bajtkódu JVM II:<br />
<a href="http://www.root.cz/clanky/programovaci-jazyk-clojure-13-preklad-programu-z-clojure-do-bajtkodu-jvm-pokracovani/">http://www.root.cz/clanky/programovaci-jazyk-clojure-13-preklad-programu-z-clojure-do-bajtkodu-jvm-pokracovani/</a>
</li>

<li>Clojure 14: Základy práce se systémem maker<br />
<a href="http://www.root.cz/clanky/programovaci-jazyk-clojure-14-zaklady-prace-se-systemem-maker/">http://www.root.cz/clanky/programovaci-jazyk-clojure-14-zaklady-prace-se-systemem-maker/</a>
</li>

<li>Clojure 15: Tvorba uživatelských maker<br />
<a href="http://www.root.cz/clanky/programovaci-jazyk-clojure-15-tvorba-uzivatelskych-maker/">http://www.root.cz/clanky/programovaci-jazyk-clojure-15-tvorba-uzivatelskych-maker/</a>
</li>

<li>Programovací jazyk Clojure &ndash; triky při práci s řetězci<br />
<a href="http://www.root.cz/clanky/programovaci-jazyk-clojure-triky-pri-praci-s-retezci/">http://www.root.cz/clanky/programovaci-jazyk-clojure-triky-pri-praci-s-retezci/</a>
</li>

<li>Programovací jazyk Clojure &ndash; triky při práci s kolekcemi<br />
<a href="http://www.root.cz/clanky/programovaci-jazyk-clojure-triky-pri-praci-s-kolekcemi/">http://www.root.cz/clanky/programovaci-jazyk-clojure-triky-pri-praci-s-kolekcemi/</a>
</li>

<li>Programovací jazyk Clojure &ndash; práce s mapami a množinami<br />
<a href="http://www.root.cz/clanky/programovaci-jazyk-clojure-prace-s-mapami-a-mnozinami/">http://www.root.cz/clanky/programovaci-jazyk-clojure-prace-s-mapami-a-mnozinami/</a>
</li>

<li>Programovací jazyk Clojure &ndash; základy zpracování XML<br />
<a href="http://www.root.cz/clanky/programovaci-jazyk-clojure-zaklady-zpracovani-xml/">http://www.root.cz/clanky/programovaci-jazyk-clojure-zaklady-zpracovani-xml/</a>
</li>

<li>Programovací jazyk Clojure &ndash; testování s využitím knihovny Expectations<br />
<a href="http://www.root.cz/clanky/programovaci-jazyk-clojure-testovani-s-vyuzitim-knihovny-expectations/">http://www.root.cz/clanky/programovaci-jazyk-clojure-testovani-s-vyuzitim-knihovny-expectations/</a>
</li>

<li>Programovací jazyk Clojure &ndash; některé užitečné triky použitelné (nejenom) v&nbsp;testech<br />
<a href="http://www.root.cz/clanky/programovaci-jazyk-clojure-nektere-uzitecne-triky-pouzitelne-nejenom-v-testech/">http://www.root.cz/clanky/programovaci-jazyk-clojure-nektere-uzitecne-triky-pouzitelne-nejenom-v-testech/</a>
</li>

<li>Enlive &ndash; výkonný šablonovací systém pro jazyk Clojure<br/>
<a href="http://www.root.cz/clanky/enlive-vykonny-sablonovaci-system-pro-jazyk-clojure/">http://www.root.cz/clanky/enlive-vykonny-sablonovaci-system-pro-jazyk-clojure/</a>
</li>

<li>Nástroj Leiningen a programovací jazyk Clojure: tvorba vlastních knihoven pro veřejný repositář Clojars<br />
<a href="http://www.root.cz/clanky/nastroj-leiningen-a-programovaci-jazyk-clojure-tvorba-vlastnich-knihoven-pro-verejny-repositar-clojars/">http://www.root.cz/clanky/nastroj-leiningen-a-programovaci-jazyk-clojure-tvorba-vlastnich-knihoven-pro-verejny-repositar-clojars/</a>
</li>

<li>Novinky v Clojure verze 1.8.0<br />
<a href="http://www.root.cz/clanky/novinky-v-clojure-verze-1-8-0/">http://www.root.cz/clanky/novinky-v-clojure-verze-1-8-0/</a>
</li>

<li>Asynchronní programování v&nbsp;Clojure s&nbsp;využitím knihovny core.async<br />
<a href="http://www.root.cz/clanky/asynchronni-programovani-v-clojure-s-vyuzitim-knihovny-core-async/">http://www.root.cz/clanky/asynchronni-programovani-v-clojure-s-vyuzitim-knihovny-core-async/</a>
</li>

<li>Asynchronní programování v&nbsp;Clojure s&nbsp;využitím knihovny core.async (pokračování)<br />
<a href="http://www.root.cz/clanky/asynchronni-programovani-v-clojure-s-vyuzitim-knihovny-core-async-pokracovani/">http://www.root.cz/clanky/asynchronni-programovani-v-clojure-s-vyuzitim-knihovny-core-async-pokracovani/</a>
</li>

<li>Asynchronní programování v Clojure s využitím knihovny core.async (dokončení)<br />
<a href="http://www.root.cz/clanky/asynchronni-programovani-v-clojure-s-vyuzitim-knihovny-core-async-dokonceni/">http://www.root.cz/clanky/asynchronni-programovani-v-clojure-s-vyuzitim-knihovny-core-async-dokonceni/</a>
</li>

<li>Vytváříme IRC bota v programovacím jazyce Clojure<br />
<a href="http://www.root.cz/clanky/vytvarime-irc-bota-v-programovacim-jazyce-clojure/">http://www.root.cz/clanky/vytvarime-irc-bota-v-programovacim-jazyce-clojure/</a>
</li>

<li>Gorilla REPL: interaktivní prostředí pro programovací jazyk Clojure<br />
<a href="https://www.root.cz/clanky/gorilla-repl-interaktivni-prostredi-pro-programovaci-jazyk-clojure/">https://www.root.cz/clanky/gorilla-repl-interaktivni-prostredi-pro-programovaci-jazyk-clojure/</a>
</li>

<li>Multimetody v Clojure aneb polymorfismus bez použití OOP<br />
<a href="https://www.root.cz/clanky/multimetody-v-clojure-aneb-polymorfismus-bez-pouziti-oop/">https://www.root.cz/clanky/multimetody-v-clojure-aneb-polymorfismus-bez-pouziti-oop/</a>
</li>

<li>Práce s externími Java archivy v programovacím jazyku Clojure<br />
<a href="https://www.root.cz/clanky/prace-s-externimi-java-archivy-v-programovacim-jazyku-clojure/">https://www.root.cz/clanky/prace-s-externimi-java-archivy-v-programovacim-jazyku-clojure/</a>
</li>

<li>Clojure 16: Složitější uživatelská makra<br />
<a href="http://www.root.cz/clanky/programovaci-jazyk-clojure-16-slozitejsi-uzivatelska-makra/">http://www.root.cz/clanky/programovaci-jazyk-clojure-16-slozitejsi-uzivatelska-makra/</a>
</li>

<li>Clojure 17: Využití standardních maker v praxi<br />
<a href="http://www.root.cz/clanky/programovaci-jazyk-clojure-17-vyuziti-standardnich-maker-v-praxi/">http://www.root.cz/clanky/programovaci-jazyk-clojure-17-vyuziti-standardnich-maker-v-praxi/</a>
</li>

<li>Clojure 18: Základní techniky optimalizace aplikací<br />
<a href="http://www.root.cz/clanky/programovaci-jazyk-clojure-18-zakladni-techniky-optimalizace-aplikaci/">http://www.root.cz/clanky/programovaci-jazyk-clojure-18-zakladni-techniky-optimalizace-aplikaci/</a>
</li>

<li>Clojure 19: Vývojová prostředí pro Clojure<br />
<a href="http://www.root.cz/clanky/programovaci-jazyk-clojure-19-vyvojova-prostredi-pro-clojure/">http://www.root.cz/clanky/programovaci-jazyk-clojure-19-vyvojova-prostredi-pro-clojure/</a>
</li>

<li>Clojure 20: Vývojová prostředí pro Clojure (Vimu s REPL)<br />
<a href="http://www.root.cz/clanky/programovaci-jazyk-clojure-20-vyvojova-prostredi-pro-clojure-integrace-vimu-s-repl/">http://www.root.cz/clanky/programovaci-jazyk-clojure-20-vyvojova-prostredi-pro-clojure-integrace-vimu-s-repl/</a>
</li>

<li>Clojure 21: ClojureScript aneb překlad Clojure do JS<br />
<a href="http://www.root.cz/clanky/programovaci-jazyk-clojure-21-clojurescript-aneb-preklad-clojure-do-javascriptu/">http://www.root.cz/clanky/programovaci-jazyk-clojure-21-clojurescript-aneb-preklad-clojure-do-javascriptu/</a>
</li>

<li>Leiningen: nástroj pro správu projektů napsaných v&nbsp;Clojure<br />
<a href="http://www.root.cz/clanky/leiningen-nastroj-pro-spravu-projektu-napsanych-v-clojure/">http://www.root.cz/clanky/leiningen-nastroj-pro-spravu-projektu-napsanych-v-clojure/</a>
</li>

<li>Leiningen: nástroj pro správu projektů napsaných v&nbsp;Clojure (2)<br />
<a href="http://www.root.cz/clanky/leiningen-nastroj-pro-spravu-projektu-napsanych-v-clojure-2/">http://www.root.cz/clanky/leiningen-nastroj-pro-spravu-projektu-napsanych-v-clojure-2/</a>
</li>

<li>Leiningen: nástroj pro správu projektů napsaných v&nbsp;Clojure (3)<br />
<a href="http://www.root.cz/clanky/leiningen-nastroj-pro-spravu-projektu-napsanych-v-clojure-3/">http://www.root.cz/clanky/leiningen-nastroj-pro-spravu-projektu-napsanych-v-clojure-3/</a>
</li>

<li>Leiningen: nástroj pro správu projektů napsaných v&nbsp;Clojure (4)<br />
<a href="http://www.root.cz/clanky/leiningen-nastroj-pro-spravu-projektu-napsanych-v-clojure-4/">http://www.root.cz/clanky/leiningen-nastroj-pro-spravu-projektu-napsanych-v-clojure-4/</a>
</li>

<li>Leiningen: nástroj pro správu projektů napsaných v&nbsp;Clojure (5)<br />
<a href="http://www.root.cz/clanky/leiningen-nastroj-pro-spravu-projektu-napsanych-v-clojure-5/">http://www.root.cz/clanky/leiningen-nastroj-pro-spravu-projektu-napsanych-v-clojure-5/</a>
</li>

<li>Leiningen: nástroj pro správu projektů napsaných v&nbsp;Clojure (6)<br />
<a href="http://www.root.cz/clanky/leiningen-nastroj-pro-spravu-projektu-napsanych-v-clojure-6/">http://www.root.cz/clanky/leiningen-nastroj-pro-spravu-projektu-napsanych-v-clojure-6/</a>
</li>

<li>Programovací jazyk Clojure a databáze (1.část)<br />
<a href="http://www.root.cz/clanky/programovaci-jazyk-clojure-a-databaze-1-cast/">http://www.root.cz/clanky/programovaci-jazyk-clojure-a-databaze-1-cast/</a>
</li>

<li>Pluginy pro Leiningen<br />
<a href="http://www.root.cz/clanky/leiningen-nastroj-pro-spravu-projektu-napsanych-v-clojure-pluginy-pro-leiningen/">http://www.root.cz/clanky/leiningen-nastroj-pro-spravu-projektu-napsanych-v-clojure-pluginy-pro-leiningen/</a>
</li>

<li>Programovací jazyk Clojure a knihovny pro práci s&nbsp;vektory a maticemi<br />
<a href="http://www.root.cz/clanky/programovaci-jazyk-clojure-a-knihovny-pro-praci-s-vektory-a-maticemi/">http://www.root.cz/clanky/programovaci-jazyk-clojure-a-knihovny-pro-praci-s-vektory-a-maticemi/</a>
</li>

<li>Programovací jazyk Clojure a knihovny pro práci s&nbsp;vektory a maticemi (2)<br />
<a href="http://www.root.cz/clanky/programovaci-jazyk-clojure-a-knihovny-pro-praci-s-vektory-a-maticemi-2/">http://www.root.cz/clanky/programovaci-jazyk-clojure-a-knihovny-pro-praci-s-vektory-a-maticemi-2/</a>
</li>

<li>Programovací jazyk Clojure: syntéza procedurálních textur s&nbsp;využitím knihovny Clisk<br />
<a href="http://www.root.cz/clanky/programovaci-jazyk-clojure-synteza-proceduralnich-textur-s-vyuzitim-knihovny-clisk/">http://www.root.cz/clanky/programovaci-jazyk-clojure-synteza-proceduralnich-textur-s-vyuzitim-knihovny-clisk/</a>
</li>

<li>Programovací jazyk Clojure: syntéza procedurálních textur s&nbsp;využitím knihovny Clisk (2)<br />
<a href="http://www.root.cz/clanky/programovaci-jazyk-clojure-synteza-proceduralnich-textur-s-vyuzitim-knihovny-clisk-2/">http://www.root.cz/clanky/programovaci-jazyk-clojure-synteza-proceduralnich-textur-s-vyuzitim-knihovny-clisk-2/</a>
</li>

<li>Seesaw: knihovna pro snadnou tvorbu GUI v&nbsp;jazyce Clojure<br />
<a href="http://www.root.cz/clanky/seesaw-knihovna-pro-snadnou-tvorbu-gui-v-jazyce-clojure/">http://www.root.cz/clanky/seesaw-knihovna-pro-snadnou-tvorbu-gui-v-jazyce-clojure/</a>
</li>

<li>Seesaw: knihovna pro snadnou tvorbu GUI v &nbsp;azyce Clojure (2)<br />
<a href="http://www.root.cz/clanky/seesaw-knihovna-pro-snadnou-tvorbu-gui-v-jazyce-clojure-2/">http://www.root.cz/clanky/seesaw-knihovna-pro-snadnou-tvorbu-gui-v-jazyce-clojure-2/</a>
</li>

<li>Seesaw: knihovna pro snadnou tvorbu GUI v&nbsp;jazyce Clojure (3)<br />
<a href="http://www.root.cz/clanky/seesaw-knihovna-pro-snadnou-tvorbu-gui-v-jazyce-clojure-3/">http://www.root.cz/clanky/seesaw-knihovna-pro-snadnou-tvorbu-gui-v-jazyce-clojure-3/</a>
</li>

<li>Programovací jazyk Clojure a práce s&nbsp;Gitem<br />
<a href="http://www.root.cz/clanky/programovaci-jazyk-clojure-a-prace-s-gitem/">http://www.root.cz/clanky/programovaci-jazyk-clojure-a-prace-s-gitem/</a>
</li>

<li>Programovací jazyk Clojure a práce s&nbsp;Gitem (2)<br />
<a href="http://www.root.cz/clanky/programovaci-jazyk-clojure-a-prace-s-gitem-2/">http://www.root.cz/clanky/programovaci-jazyk-clojure-a-prace-s-gitem-2/</a>
</li>

<li>Programovací jazyk Clojure: syntéza procedurálních textur s&nbsp;využitím knihovny Clisk (dokončení)<br />
<a href="http://www.root.cz/clanky/programovaci-jazyk-clojure-synteza-proceduralnich-textur-s-vyuzitim-knihovny-clisk-dokonceni/">http://www.root.cz/clanky/programovaci-jazyk-clojure-synteza-proceduralnich-textur-s-vyuzitim-knihovny-clisk-dokonceni/</a>
</li>

<li>Pixie: lehký skriptovací jazyk s&nbsp;„kouzelnými“ schopnostmi<br />
<a href="https://www.root.cz/clanky/pixie-lehky-skriptovaci-jazyk-s-kouzelnymi-schopnostmi/">https://www.root.cz/clanky/pixie-lehky-skriptovaci-jazyk-s-kouzelnymi-schopnostmi/</a>
</li>

<li>Programovací jazyk Pixie: funkce ze základní knihovny a použití FFI<br />
<a href="https://www.root.cz/clanky/programovaci-jazyk-pixie-funkce-ze-zakladni-knihovny-a-pouziti-ffi/">https://www.root.cz/clanky/programovaci-jazyk-pixie-funkce-ze-zakladni-knihovny-a-pouziti-ffi/</a>
</li>

<li>Novinky v&nbsp;Clojure verze 1.9.0<br />
<a href="https://www.root.cz/clanky/novinky-v-clojure-verze-1-9-0/">https://www.root.cz/clanky/novinky-v-clojure-verze-1-9-0/</a>
</li>

<li>Validace dat s&nbsp;využitím knihovny spec v&nbsp;Clojure 1.9.0<br />
<a href="https://www.root.cz/clanky/validace-dat-s-vyuzitim-knihovny-spec-v-clojure-1-9-0/">https://www.root.cz/clanky/validace-dat-s-vyuzitim-knihovny-spec-v-clojure-1-9-0/</a>
</li>

<li>Použití jazyka Gherkin při tvorbě testovacích scénářů pro aplikace psané v&nbsp;Clojure<br />
<a href="https://www.root.cz/clanky/pouziti-jazyka-gherkin-pri-tvorbe-testovacich-scenaru-pro-aplikace-psane-v-nbsp-clojure/">https://www.root.cz/clanky/pouziti-jazyka-gherkin-pri-tvorbe-testovacich-scenaru-pro-aplikace-psane-v-nbsp-clojure/</a>
</li>

<li>Použití jazyka Gherkin při tvorbě testovacích scénářů pro aplikace psané v&nbsp;Clojure (2)<br />
<a href="https://www.root.cz/clanky/pouziti-jazyka-gherkin-pri-tvorbe-testovacich-scenaru-pro-aplikace-psane-v-nbsp-clojure-2/">https://www.root.cz/clanky/pouziti-jazyka-gherkin-pri-tvorbe-testovacich-scenaru-pro-aplikace-psane-v-nbsp-clojure-2/</a>
</li>

<li>Incanter: prostředí pro statistické výpočty s grafickým výstupem založené na Clojure<br />
<a href="https://www.root.cz/clanky/incanter-prostredi-pro-statisticke-vypocty-s-grafickym-vystupem-zalozene-na-clojure/">https://www.root.cz/clanky/incanter-prostredi-pro-statisticke-vypocty-s-grafickym-vystupem-zalozene-na-clojure/</a>
</li>

<li>Incanter: operace s&nbsp;maticemi<br />
<a href="https://www.root.cz/clanky/incanter-operace-s-maticemi/">https://www.root.cz/clanky/incanter-operace-s-maticemi/</a>
</li>

<li>Interpret programovacího jazyka Clojure integrovaný do Jupyter Notebooku<br />
<a href="https://www.root.cz/clanky/interpret-programovaciho-jazyka-clojure-integrovany-do-jupyter-notebooku/">https://www.root.cz/clanky/interpret-programovaciho-jazyka-clojure-integrovany-do-jupyter-notebooku/</a>
</li>

<li>Babashka: interpret Clojure určený pro rychlé spouštění utilit z&nbsp;příkazového řádku<br />
<a href="https://www.root.cz/clanky/babashka-interpret-clojure-urceny-pro-rychle-spousteni-utilit-z-prikazoveho-radku/">https://www.root.cz/clanky/babashka-interpret-clojure-urceny-pro-rychle-spousteni-utilit-z-prikazoveho-radku/</a>
</li>

<li>Pokročilý streaming založený na Apache Kafce, jazyku Clojure a knihovně Jackdaw<br />
<a href="https://www.root.cz/clanky/pokrocily-streaming-zalozeny-na-apache-kafce-jazyku-clojure-a-knihovne-jackdaw/">https://www.root.cz/clanky/pokrocily-streaming-zalozeny-na-apache-kafce-jazyku-clojure-a-knihovne-jackdaw/</a>
</li>

<li>Pokročilý streaming založený na Apache Kafce, jazyku Clojure a knihovně Jackdaw (2. část)<br />
<a href="https://www.root.cz/clanky/pokrocily-streaming-zalozeny-na-apache-kafce-jazyku-clojure-a-knihovne-jackdaw-2-cast/">https://www.root.cz/clanky/pokrocily-streaming-zalozeny-na-apache-kafce-jazyku-clojure-a-knihovne-jackdaw-2-cast/</a>
</li>

<li>Pokročilý streaming založený na projektu Apache Kafka, jazyku Clojure a knihovně Jackdaw (streamy a kolony)<br />
<a href="https://www.root.cz/clanky/pokrocily-streaming-zalozeny-na-projektu-apache-kafka-jazyku-clojure-a-knihovne-jackdaw-streamy-a-kolony/">https://www.root.cz/clanky/pokrocily-streaming-zalozeny-na-projektu-apache-kafka-jazyku-clojure-a-knihovne-jackdaw-streamy-a-kolony/</a>
</li>

<li>Řídicí struktury využitelné v&nbsp;programovacím jazyku Clojure<br />
<a href="https://www.root.cz/clanky/ridici-struktury-vyuzitelne-v-programovacim-jazyku-clojure/">https://www.root.cz/clanky/ridici-struktury-vyuzitelne-v-programovacim-jazyku-clojure/</a>
</li>

</ol>



<p><a name="k20"></a></p>
<h2 id="k20">20. Odkazy na Internetu</h2>

<ol>

<li>Understanding Clojure's PersistentVector implementation<br />
<a href="http://blog.higher-order.net/2009/02/01/understanding-clojures-persistentvector-implementation">http://blog.higher-order.net/2009/02/01/understanding-clojures-persistentvector-implementation</a>
</li>

<li>Understanding Clojure's PersistentHashMap (deftwice...)<br />
<a href="http://blog.higher-order.net/2009/09/08/understanding-clojures-persistenthashmap-deftwice.html">http://blog.higher-order.net/2009/09/08/understanding-clojures-persistenthashmap-deftwice.html</a>
</li>

<li>Assoc and Clojure's PersistentHashMap: part ii<br />
<a href="http://blog.higher-order.net/2010/08/16/assoc-and-clojures-persistenthashmap-part-ii.html">http://blog.higher-order.net/2010/08/16/assoc-and-clojures-persistenthashmap-part-ii.html</a>
</li>

<li>Ideal Hashtrees (paper)<br />
<a href="http://lampwww.epfl.ch/papers/idealhashtrees.pdf">http://lampwww.epfl.ch/papers/idealhashtrees.pdf</a>
</li>

<li>data.priority-map API Reference<br />
<a href="https://clojure.github.io/data.priority-map/">https://clojure.github.io/data.priority-map/</a>
</li>

<li>Clojure Sequences<br />
<a href="http://clojure.org/sequences">http://clojure.org/sequences</a>
</li>

<li>Clojure Data Structures<br />
<a href="https://clojure.org/reference/data_structures">https://clojure.org/reference/data_structures</a>
</li>

<li>hash-map<br />
<a href="https://clojure.github.io/clojure/clojure.core-api.html#clojure.core/hash-map">https://clojure.github.io/clojure/clojure.core-api.html#clojure.core/hash-map</a>
</li>

<li>sorted-map<br />
<a href="https://clojure.github.io/clojure/clojure.core-api.html#clojure.core/sorted-map">https://clojure.github.io/clojure/clojure.core-api.html#clojure.core/sorted-map</a>
</li>

<li>array-map<br />
<a href="https://clojuredocs.org/clojure.core/array-map">https://clojuredocs.org/clojure.core/array-map</a>
</li>

<li>Clojure Hashmaps Explained: How to Retrieve Values From and Update Hashmaps<br />
<a href="https://www.freecodecamp.org/news/clojure-hashmaps-explained-how-to-retrieve-values-from-and-update-hashmaps/">https://www.freecodecamp.org/news/clojure-hashmaps-explained-how-to-retrieve-values-from-and-update-hashmaps/</a>
</li>

<li>Clojure Data Structures Tutorial<br />
<a href="https://purelyfunctional.tv/guide/clojure-collections/">https://purelyfunctional.tv/guide/clojure-collections/</a>
</li>

<li>Are maps in Clojure ordered?<br />
<a href="https://stackoverflow.com/questions/34401121/are-maps-in-clojure-ordered">https://stackoverflow.com/questions/34401121/are-maps-in-clojure-ordered</a>
</li>

<li>Clojure: how to conj to front of hash map in swap! function<br />
<a href="https://stackoverflow.com/questions/33042116/clojure-how-to-conj-to-front-of-hash-map-in-swap-function">https://stackoverflow.com/questions/33042116/clojure-how-to-conj-to-front-of-hash-map-in-swap-function</a>
</li>

<li>The Clojure Toolbox<br />
<a href="http://www.clojure-toolbox.com/">http://www.clojure-toolbox.com/</a>
</li>

<li>Transient Data Structures
<a href="http://clojure.org/transients">http://clojure.org/transients</a>
</li>

</ol>



<p></p><p></p>
<p><small>Autor: <a href="http://www.fit.vutbr.cz/~tisnovpa">Pavel Tišnovský</a> &nbsp; 2021</small></p>
</body>
</html>

