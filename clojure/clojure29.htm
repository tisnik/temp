<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
        "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html>
<head>
<title>Novinky v Clojure verze 1.8.0</title>
<meta name="Author" content="Pavel Tisnovsky" />
<meta name="Generator" content="vim" />
<meta http-equiv="content-type" content="text/html; charset=utf-8" />
<style type="text/css">
         body {color:#000000; background:#ffffff;}
         h1  {font-family: arial, helvetica, sans-serif; color:#ffffff; background-color:#c00000; text-align:center; padding-left:1em}
         h2  {font-family: arial, helvetica, sans-serif; color:#ffffff; background-color:#0000c0; padding-left:1em; text-align:left}
         h3  {font-family: arial, helvetica, sans-serif; color:#000000; background-color:#c0c0c0; padding-left:1em; text-align:left}
         h4  {font-family: arial, helvetica, sans-serif; color:#000000; background-color:#e0e0e0; padding-left:1em; text-align:left}
         a   {font-family: arial, helvetica, sans-serif;}
         li  {font-family: arial, helvetica, sans-serif; color:#000000; text-align:justify; width:450px;}
         ol  {font-family: arial, helvetica, sans-serif; color:#000000; text-align:justify; width:450px;}
         ul  {font-family: arial, helvetica, sans-serif; color:#000000; text-align:justify; width:450px;}
         p   {font-family: arial, helvetica, sans-serif; color:#000000; text-align:justify;}
         pre {background:#e0e0e0}
</style>
</head>

<body>

<h1>Novinky v Clojure verze 1.8.0</h1>

<h3>Pavel Tišnovský</h3>

<p></p>

<h1>Úvodník</h1>

<p>Jak jsme vás již informovali ve zprávičce, vyšla minulý týden nová verze programovacího jazyka Clojure. Některé změny se týkají základních knihoven, další pak optimalizací pro dosažení vyššího výkonu při překladu zdrojových kódů do bajtkódu JVM. Právě těmito změnami se budeme zabývat v dnešním článku.</p>



<h2>Obsah</h2>

<p><a href="#k01">1. Novinky v&nbsp;Clojure verze 1.8.0</a></p>
<p><a href="#k02">2. Instalace Clojure 1.8.0 bez použití nástroje Leiningen</a></p>
<p><a href="#k03">3. Spuštění interaktivního REPLu</a></p>
<p><a href="#k04">4. Instalace Clojure 1.8.0 s&nbsp;použitím nástroje Leiningen</a></p>
<p><a href="#k05">5. Spuštění interaktivního REPLu</a></p>
<p><a href="#k06">6. Rozšíření repertoáru funkcí ve jmenném prostoru <strong>clojure.string</strong></a></p>
<p><a href="#k07">7. Demonstrační příklady</a></p>
<p><a href="#k08">8. Socket server</a></p>
<p><a href="#k09">9. Spuštění serveru a použití telnetu k&nbsp;přístupu k&nbsp;REPLu</a></p>
<p><a href="#k10">10. *out*, *err*, clojure.core.server/*session* a další symboly, které mají v&nbsp;serveru odlišné nastavení</a></p>
<p><a href="#k11">11. Použití REPLu přístupného přes socket</a></p>
<p><a href="#k12">12. Další vylepšení v&nbsp;Clojure 1.8.0</a></p>
<p><a href="#k13">13. Odkazy na předchozí části tohoto seriálu</a></p>
<p><a href="#k14">14. Odkazy na Internetu</a></p>



<p><a name="k01"></a></p>
<h2 id="k01">1. Novinky v&nbsp;Clojure verze 1.8.0</h2>

<p>Před týdnem, konkrétně dne 19.1.2016, byla vydána nová verze programovacího
jazyka Clojure. Jak jsme vás již <a
href="http://www.root.cz/zpravicky/clojure-1-8-pridava-socket-server/">informovali
ve zprávičce</a>, jedná se o verzi 1.8.0. Nutno říci, že tato verze vlastně
není příliš přelomová a už vůbec ne revoluční, což může znamenat to, že se
programovací jazyk Clojure dostává do stabilní fáze vývoje, kdy by radikální
změny byly vnímány spíše negativně. V&nbsp;rámci Clojure 1.8.0 došlo
k&nbsp;přidání pěti nových a užitečných funkcí do jmenného prostoru
<strong>clojure.string</strong>, dále je možné se připojit k&nbsp;interaktivní
smyčce REPL přes k&nbsp;tomu vytvořený socket (což je sice zdánlivě malá změna,
která má však poměrně dalekosáhlé praktické důsledky) a taktéž byl
optimalizován překlad zdrojových kódů napsaných v&nbsp;jazyce Clojure do
bajtkódu JVM. Na tomto místě je ještě vhodné dodat, že před vydáním Clojure
1.8.0 byl do standardních knihoven dodán jmenný prostor
<strong>clojure.async</strong>, což již JE poměrně závažné vylepšení, kterému
se kvůli jeho důležitosti budeme věnovat v&nbsp;samostatném článku.</p>



<p><a name="k02"></a></p>
<h2 id="k02">2. Instalace Clojure 1.8.0 bez použití nástroje Leiningen</h2>

<p>Nejprve si ukažme, jakým způsobem je možné na vývojový počítač nainstalovat
programovací jazyk Clojure verze 1.8.0 v&nbsp;případě, že z&nbsp;nějakého
důvodu nechcete používat nástroj <a
href="http://www.root.cz/clanky/leiningen-nastroj-pro-spravu-projektu-napsanych-v-clojure/">Leiningen</a>.
Pro naprostou většinu projektů je sice doporučováno Leiningen použít, ovšem
mohou existovat situace, kdy to není možné. V&nbsp;těchto situacích postačuje
stáhnout již připravený zip archiv obsahující jak samotný jazyk Clojure
(překladač do bajtkódu, runtime i vlastní smyčku REPL), zdrojové kódy Clojure,
tak i základní knihovny. Celý archiv je dostupný na adrese <a
href="http://repo1.maven.org/maven2/org/clojure/clojure/1.8.0/clojure-1.8.0.zip">http://repo1.maven.org/maven2/org/clojure/clojure/1.8.0/clojure-1.8.0.zip</a>,
takže nejprve použijeme <strong>wget</strong> pro jeho stažení do lokálního
adresáře:</p>

<pre>
<strong>wget http://repo1.maven.org/maven2/org/clojure/clojure/1.8.0/clojure-1.8.0.zip</strong>
&nbsp;
--2016-01-24 10:17:27--  http://repo1.maven.org/maven2/org/clojure/clojure/1.8.0/clojure-1.8.0.zip
Resolving repo1.maven.org (repo1.maven.org)... 185.31.17.209
Connecting to repo1.maven.org (repo1.maven.org)|185.31.17.209|:80... connected.
HTTP request sent, awaiting response... 200 OK
Length: 5017209 (4,8M) [application/zip]
Saving to: "clojure-1.8.0.zip"
&nbsp;
100%[=====================================================================================================&gt;] 5 017 209    908KB/s   in 5,9s   
&nbsp;
2016-01-24 10:17:33 (837 KB/s) - "clojure-1.8.0.zip" saved [5017209/5017209]
</pre>

<p>Dále je nutné archiv rozbali, což lze provést přímo v&nbsp;pracovním adresáři</p>

<pre>
<strong>unzip clojure-1.8.0.zip</strong>
&nbsp;
Archive:  clojure-1.8.0.zip
   creating: clojure-1.8.0/
   creating: clojure-1.8.0/src/
   creating: clojure-1.8.0/src/script/
   creating: clojure-1.8.0/src/jvm/
   ...
   ...
   ...
  inflating: clojure-1.8.0/clojure-1.8.0-slim.jar
  inflating: clojure-1.8.0/clojure-1.8.0.jar
  inflating: clojure-1.8.0/pom.xml
  inflating: clojure-1.8.0/build.xml
  inflating: clojure-1.8.0/readme.txt
  inflating: clojure-1.8.0/changes.md
  inflating: clojure-1.8.0/clojure.iml
  inflating: clojure-1.8.0/epl-v10.html
</pre>

<p>Nejdůležitější je pro nás nyní především soubor nazvaný
<strong>clojure-1.8.0/clojure-1.8.0.jar</strong> obsahující všechny součásti
interpretru a překladače jazyka Clojure, včetně REPLu a základních
knihoven.</p>

<p><ins>Poznámka: pro běh Clojure (libovolné verze) je samozřejmě zapotřebí mít
nainstalováno JRE (<i>Java Runtime Environment</i>), podobně jako pro spuštění
dalších javovských aplikací. Postačuje jak verze 7, tak i novější verze 8. Já
jsem v&nbsp;dnešním článku vše testoval na verzi 7 (konkrétně na OpenJDK
1.7.0_79, tj.&nbsp;build JRE má číslo 7u79), a to především z&nbsp;toho důvodu,
že na produkčních systémech je tato verze pravděpodobně používána
častěji, než JDK/JRE 8.<ins></p>



<p><a name="k03"></a></p>
<h2 id="k03">3. Spuštění interaktivního REPLu</h2>

<p>Spuštění interaktivní smyčky REPL, v&nbsp;níž mnoho programátorů tráví při
tvorbě aplikací nejvíce času, se provede velmi jednoduše:</p>

<pre>
<strong>cd clojure-1.8.0</strong>
&nbsp;
<strong>java -jar clojure-1.8.0.jar</strong>
&nbsp;
Clojure 1.8.0
user=&gt;
</pre>

<p>Ve skutečnosti má takto &bdquo;primitivně&ldquo; spuštěný REPL několik
nevýhod, a to především absenci historie příkazové řádky. Tento nedostatek
nahradíme nástrojem nazvaným příhodně <i>readline wrapper</i>, který dokáže
historii příkazů zachovat a kdykoli vyvolat klávesovými zkratkami známými
například z&nbsp;BASHe. Pokud chcete <i>readline wrapper</i> při vývoji a
testování s&nbsp;využitím REPL použít (což je v&nbsp;tomto případě pro
praktické použití takřka nezbytné), nainstalujte si nejprve balíček nazvaný
<i>rlwrap</i> a posléze spusťte REPL jazyka Clojure následujícím způsobem:</p>

<pre>
<strong>cd clojure-1.8.0</strong>
&nbsp;
<strong>rlwrap java -jar clojure-1.8.0.jar</strong>
&nbsp;
Clojure 1.8.0
user=&gt;
</pre>



<p><a name="k04"></a></p>
<h2 id="k04">4. Instalace Clojure 1.8.0 s&nbsp;použitím nástroje Leiningen</h2>

<p>Instalace Clojure verze 1.8.0 s&nbsp;využitím nástroje Leiningen je velmi
jednoduchá. Nejprve vytvoříme nový projekt, a to příkazem:</p>

<pre>
<strong>lein new app clojure8-test</strong>
Generating a project called clojure8-test based on the 'app' template.
</pre>

<p>Po zadání tohoto příkazu by se měl vytvořit adresář obsahující strukturu
nového projektu:</p>

<pre>
.
├── doc
│   └── intro.md
├── LICENSE
├── project.clj
├── README.md
├── resources
├── src
│   └── clojure8_test
│       └── core.clj
└── test
    └── clojure8_test
        └── core_test.clj
&nbsp;
6 directories, 6 files
</pre>

<p>Podívejme se nyní na obsah projektového souboru nazvaného
<strong>project.clj</strong>. Ten může vypadat takto:</p>

<pre>
(defproject clojure8-test "0.1.0-SNAPSHOT"
  :description "FIXME: write description"
  :url "http://example.com/FIXME"
  :license {:name "Eclipse Public License"
            :url "http://www.eclipse.org/legal/epl-v10.html"}
  :dependencies [[org.clojure/clojure "<strong>1.6.0</strong>"]]
  :main ^:skip-aot clojure8-test.core
  :target-path "target/%s"
  :profiles {:uberjar {:aot :all}})
</pre>

<p>Označenou část projektového souboru změníme takovým způsobem, aby se namísto
verze <strong>1.5.0</strong>, <strong>1.6.0</strong> či <strong>1.7.0</strong>
používala verze <strong>1.8.0</strong>:</p>

<pre>
(defproject clojure8-test "0.1.0-SNAPSHOT"
  :description "FIXME: write description"
  :url "http://example.com/FIXME"
  :license {:name "Eclipse Public License"
            :url "http://www.eclipse.org/legal/epl-v10.html"}
  :dependencies [[org.clojure/clojure "<strong>1.8.0</strong>"]]
  :main ^:skip-aot clojure8-test.core
  :target-path "target/%s"
  :profiles {:uberjar {:aot :all}})
</pre>

<p>Následně stačí uložit novou verzi projektového souboru a na příkazové řádce
zadat příkaz pro stažení všech knihoven a balíčků, na nichž projekt závisí:</p>

<pre>
<strong>lein deps</strong>
&nbsp;
Retrieving org/clojure/clojure/1.8.0/clojure-1.8.0.pom from central
Retrieving org/clojure/clojure/1.8.0/clojure-1.8.0.jar from central
</pre>

<p>Z&nbsp;vypsaných zpráv je zřejmé, že skutečně došlo ke stažení nové verze
jazyka Clojure. Standardně se interpretry Clojure ukládají do adresáře
<strong>~/.m2/repository/org/clojure/clojure</strong>, který může obsahovat i
několik verzí interpretu. To je ve skutečnosti celkem běžné, protože mnoho
knihoven má ve svém popisu (projektovém souboru) uvedenou právě nějakou starší
verzi. Podívejme se, jak struktura výše zmíněného adresáře vypadá na počítači,
který je aktivně používán pro vývoj v&nbsp;jazyce Clojure:</p>

<pre>
~/.m2/repository/org/clojure/clojure/
├── 1.2.1
│   ├── clojure-1.2.1.jar
│   ├── clojure-1.2.1.jar.sha1
│   ├── clojure-1.2.1.pom
│   ├── clojure-1.2.1.pom.sha1
│   └── _maven.repositories
├── 1.3.0
│   ├── clojure-1.3.0.pom
│   ├── clojure-1.3.0.pom.sha1
│   └── _maven.repositories
├── 1.4.0
│   ├── clojure-1.4.0.pom
│   ├── clojure-1.4.0.pom.sha1
│   └── _maven.repositories
├── 1.5.1
│   ├── clojure-1.5.1.jar
│   ├── clojure-1.5.1.jar.sha1
│   ├── clojure-1.5.1.pom
│   ├── clojure-1.5.1.pom.sha1
│   └── _maven.repositories
├── 1.6.0
│   ├── clojure-1.6.0.jar
│   ├── clojure-1.6.0.jar.sha1
│   ├── clojure-1.6.0.pom
│   ├── clojure-1.6.0.pom.sha1
│   └── _maven.repositories
├── 1.7.0
│   ├── clojure-1.7.0.jar
│   ├── clojure-1.7.0.jar.sha1
│   ├── clojure-1.7.0.pom
│   ├── clojure-1.7.0.pom.sha1
│   └── _maven.repositories
├── 1.7.0-RC1
│   ├── clojure-1.7.0-RC1.pom
│   ├── clojure-1.7.0-RC1.pom.sha1
│   └── _maven.repositories
└── 1.8.0
    ├── clojure-1.8.0.jar
    ├── clojure-1.8.0.jar.sha1
    ├── clojure-1.8.0.pom
    ├── clojure-1.8.0.pom.sha1
    └── _maven.repositories
&nbsp;
8 directories, 34 files
</pre>

<p>V&nbsp;případě Clojure verze 1.8.0 vznikl při instalaci adresář
s&nbsp;pěticí souborů, přičemž pro vývoj, ladění i spouštění programů se
používá pouze Java archiv uvedený na prvním místě:</p>

<pre>
ls -l ~/.m2/repository/org/clojure/clojure/1.8.0
total 3564
-rw-r--r-- 1 tester tester 3622815 led 24 10:14 clojure-1.8.0.jar
-rw-r--r-- 1 tester tester      40 led 24 10:14 clojure-1.8.0.jar.sha1
-rw-r--r-- 1 tester tester    8547 led 24 10:14 clojure-1.8.0.pom
-rw-r--r-- 1 tester tester      40 led 24 10:14 clojure-1.8.0.pom.sha1
-rw-r--r-- 1 tester tester     180 led 24 10:14 _maven.repositories
</pre>

<p><ins>Poznámka: samotný projekt je možné bez obav smazat, protože jeho
jedinou úlohou bylo nainstalovat Clojure 1.8.0 do adresáře
<strong>~/.m2</strong> a otestovat REPL (viz <a href="#k05">další
kapitolu</a>).</ins></p>



<p><a name="k05"></a></p>
<h2 id="k05">5. Spuštění interaktivního REPLu</h2>

<p>Spuštění interaktivní smyčky REPL je v&nbsp;případě použití projektu
používajícího nástroj Leiningen velmi snadné. Postačuje pouze v&nbsp;adresáři
s&nbsp;projektem zadat příkaz <strong>lein repl</strong>:</p>

<pre>
<strong>lein repl</strong>
&nbsp;
nREPL server started on port 47224 on host 127.0.0.1 - nrepl://127.0.0.1:47224
REPL-y 0.3.5, nREPL 0.2.6
Clojure <strong>1.8.0</strong>
OpenJDK 64-Bit Server VM 1.7.0_79-b14
    Docs: (doc function-name-here)
          (find-doc "part-of-name-here")
  Source: (source function-name-here)
 Javadoc: (javadoc java-object-or-class-here)
    Exit: Control+D or (exit) or (quit)
 Results: Stored in vars *1, *2, *3, an exception in *e
&nbsp;
clojure8-test.core=&gt;
</pre>

<p>Tato forma smyčky REPL programátorům nabízí mnohem více možností, než
&bdquo;klasická&ldquo; minimalisticky pojatá smyčka REPL, která je součástí
interpretru Clojure. K&nbsp;dispozici je historie příkazů, lze přistupovat ke
speciálním symbolům *1, *e atd. Právě tuto smyčku použijeme v&nbsp;dalším textu
při vysvětlování nových možností Clojure 1.8.0.</p>



<p><a name="k06"></a></p>
<h2 id="k06">6. Rozšíření repertoáru funkcí ve jmenném prostoru <strong>clojure.string</strong></h2>

<p>Do jmenného prostoru <strong>clojure.string</strong> bylo přidáno pět nových
funkcí, které se používají pro test, zda nějaký řetězec obsahuje zadaný
podřetězec a popř.&nbsp;na jaké pozici se tento podřetězec nachází. První tři
funkce vrací hodnotu <strong>true</strong> či <strong>false</strong>, proto se
jedná o takzvané &bdquo;predikáty&ldquo;, jejichž jména podle ustanovených
jmenných konvencí končí znakem otazník. Další dvě funkce vrací index nalezeného
podřetězce popř.&nbsp;hodnotu <strong>nil</strong>, pokud se nalezení
nepodařilo. Podívejme se na tabulku s&nbsp;novými funkcemi:</p>

<table>
<tr><th>#</th><th>Funkce</th><th>Stručný popis</th></tr>
<tr><td>1</td><td>starts-with? </td><td>test, zda řetězec začíná zadaným podřetězcem</td></tr>
<tr><td>2</td><td>ends-with?   </td><td>test, zda řetězec končí zadaným podřetězcem</td></tr>
<tr><td>2</td><td>includes?    </td><td>test, zda řetězec obsahuje zadaný podřetězec</td></tr>
<tr><td>3</td><td>index-of     </td><td>vrátí první výskyt znaku v řetězci popř.&nbsp;<strong>nil</strong></td></tr>
<tr><td>4</td><td>last-index-of</td><td>vrátí poslední výskyt znaku v řetězci popř.&nbsp;<strong>nil</strong></td></tr>
</table>

<p>Tyto funkce byly přidány primárně z&nbsp;toho důvodu, aby byly dostupné i
v&nbsp;<i>ClojureScriptu</i>. Programátoři používající předchozí verzi jazyka
Clojure se museli uchýlit k&nbsp;použití metod třídy
<strong>java.lang.String</strong>. Skutečně, nové funkce jsou částečně
s&nbsp;těmito metodami shodné:</p>

<table>
<tr><th>#</th><th>Funkce</th><th>Odpovídající metoda třídy java.lang.String</th></tr>
<tr><td>1</td><td>starts-with? </td><td>.startsWith</td></tr>
<tr><td>2</td><td>ends-with?   </td><td>.endsWith</td></tr>
<tr><td>2</td><td>includes?    </td><td>.contains</td></tr>
<tr><td>3</td><td>index-of     </td><td>.indexOf</td></tr>
<tr><td>4</td><td>last-index-of</td><td>.lastIndexOf</td></tr>
</table>

<p>Ve skutečnosti však existuje několik rozdílů mezi novými funkcemi a
odpovídajícími javovskými metodami. Především funkce lze zavolat i v&nbsp;tom
případě, kdy jejich prvním parametrem není řetězec ale například číslo či
objekt. Nejprve je tato reference automaticky převedena na řetězec a posléze je
funkce zavolána, což v&nbsp;případě metod pochopitelně není možné (přesněji
řečeno v&nbsp;Javě jakožto OO jazyku založeném na třídách to není možné). Druhý
rozdíl je v&nbsp;praxi důležitější: funkce <strong>index-of</strong> a
<strong>last-index-of</strong> v&nbsp;případě, že podřetězec nebyl nalezen,
vrací speciální hodnotu <strong>nil</strong>, zatímco metody
<strong>String.indexOf</strong> a <strong>String.lastIndexOf</strong> vrací ve
stejném případě hodnotu -1 (za to můžeme &bdquo;vděčit&ldquo; rigidnímu
typovému systému Javy a taktéž striktnímu rozlišování mezi primitivními typy a
referenčními typy). Ostatně, hodnota <strong>nil</strong> je praktičtější,
protože ji lze použít přímo v&nbsp;rozhodovacích konstrukcích, kde má stejný
význam jako pravdivostní hodnota <strong>false</strong>.</p>



<p><a name="k07"></a></p>
<h2 id="k07">7. Demonstrační příklady</h2>

<p>Vyzkoušejme si nyní výše uvedenou pětici funkcí na demonstračních příkladech
zadávaných přímo do interaktivní smyčky REPL. Nejdříve REPL spustíme:</p>

<pre>
<strong>lein repl</strong>
&nbsp;
nREPL server started on port 51457 on host 127.0.0.1 - nrepl://127.0.0.1:51457
REPL-y 0.3.5, nREPL 0.2.6
Clojure 1.8.0
OpenJDK 64-Bit Server VM 1.7.0_79-b14
    Docs: (doc function-name-here)
          (find-doc "part-of-name-here")
  Source: (source function-name-here)
 Javadoc: (javadoc java-object-or-class-here)
    Exit: Control+D or (exit) or (quit)
 Results: Stored in vars *1, *2, *3, an exception in *e
</pre>

<p>Nyní načteme všechny funkce, makra a symboly definované ve jmenném prostoru
<strong>clojure.string</strong>, přičemž namísto nutnosti zadávání plného jména
tohoto prostoru si zvolíme pouze kratší alias <strong>str</strong> (vůbec
přitom nevadí, že dojde ke &bdquo;kolizi&ldquo; s&nbsp;funkcí
<strong>str</strong>, protože jméno modulu a jméno funkce se vždy bude uvádět
v&nbsp;jiném kontextu):</p>

<pre>
clojure8-test.core=&gt; <strong>(require '[clojure.string :as str])</strong>
nil
</pre>

<p>Navážeme symbol <strong>s</strong> na řetězec &bdquo;Hello
world!&ldquo;:</p>

<pre>
clojure8-test.core=&gt; <strong>(def s "Hello world!")</strong>
#'clojure8-test.core/s
</pre>

<p>Konečně se můžeme pustit do testování nových řetězcových funkcí:</p>

<pre>
<i>; nalezení prvního výskytu znaku "o"</i>
clojure8-test.core=&gt; <strong>(str/index-of s "o")</strong>
4
&nbsp;
<i>; nalezení prvního výskytu podřetězce "wo"</i>
clojure8-test.core=&gt; <strong>(str/index-of s "wo")</strong>
6
&nbsp;
<i>; pokud se podřetězec nenalezne, vrací se hodnota nil, nikoli -1:</i>
clojure8-test.core=&gt; <strong>(str/index-of s "xxx")</strong>
nil
&nbsp;
<i>; hledání výskytu znaku od určité pozice</i>
clojure8-test.core=&gt; <strong>(str/index-of s "o" 4)</strong>
4
&nbsp;
<i>; hledání výskytu znaku od určité pozice</i>
clojure8-test.core=&gt; <strong>(str/index-of s "o" 5)</strong>
7
&nbsp;
<i>; pokud se podřetězec nenalezne, vrací se hodnota nil, nikoli -1:</i>
clojure8-test.core=&gt; <strong>(str/index-of s "o" 10)</strong>
nil
&nbsp;
<i>; hledání posledního výskytu znaku</i>
clojure8-test.core=&gt; <strong>(str/last-index-of s "o")</strong>
7
&nbsp;
<i>; hledání posledního výskytu podřetězce</i>
clojure8-test.core=&gt; <strong>(str/last-index-of s "wo")</strong>
6
&nbsp;
<i>; hledání posledního výskytu podřetězce, opět se může vracet nil</i>
clojure8-test.core=&gt; <strong>(str/last-index-of s "foo")</strong>
nil
&nbsp;
<i>; tato funkce vrací true či false v závislosti na tom, zda je nalezen podřetězec</i>
clojure8-test.core=&gt; <strong>(str/includes? s "wor")</strong>
true
&nbsp;
<i>; tato funkce vrací true či false v závislosti na tom, zda je nalezen podřetězec</i>
clojure8-test.core=&gt; <strong>(str/includes? s "xyzzy")</strong>
false
&nbsp;
<i>; tato funkce vrací true či false v závislosti na tom, zda je na začátku nalezen podřetězec</i>
clojure8-test.core=&gt; <strong>(str/starts-with? s "H")</strong>
true
&nbsp;
<i>; tato funkce vrací true či false v závislosti na tom, zda je na začátku nalezen podřetězec</i>
clojure8-test.core=&gt; <strong>(str/starts-with? s "x")</strong>
false
&nbsp;
<i>; tato funkce vrací true či false v závislosti na tom, zda je na začátku nalezen podřetězec</i>
clojure8-test.core=&gt; <strong>(str/starts-with? s "Hello")</strong>
true
&nbsp;
<i>; tato funkce vrací true či false v závislosti na tom, zda je na konci nalezen podřetězec</i>
clojure8-test.core=&gt; <strong>(str/ends-with? s "!")</strong>
true
&nbsp;
<i>; tato funkce vrací true či false v závislosti na tom, zda je na konci nalezen podřetězec</i>
clojure8-test.core=&gt; <strong>(str/ends-with? s "x")</strong>
false
&nbsp;
<i>; tato funkce vrací true či false v závislosti na tom, zda je na konci nalezen podřetězec</i>
clojure8-test.core=&gt; <strong>(str/ends-with? s "world!")</strong>
true
&nbsp;
</pre>

<p>Některé specialitky:</p>

<pre>
<i>; velmi častá chyba při použití funkce contains?, kterou nelze na řetězce použít</i>
<i>; nová funkce includes? doufejme nesprávné použití contains? omezí</i>
<i>; (mnoho programátorů si myslí, že contains? je nejhůře pojmenovanou funkcí v Clojure vůbec :-)</i>
clojure8-test.core=&gt; <strong>(contains? s "o")</strong>
&nbsp;
<i>; numerická hodnota je převedena na řetězec, v&nbsp;němž se pak hledá znak</i>
clojure8-test.core=&gt; <strong>(str/includes? 1234 "3")</strong>
true
&nbsp;
<i>; výsledek funkce je převeden na řetězec, v&nbsp;němž se pak hledá znak</i>
clojure8-test.core=&gt; <strong>(str/includes? (* 6 7) "4")</strong>
true
</pre>

<p>Pokud vám z&nbsp;nějakého důvodu nevyhovuje nutnost specifikace jmenného
prostoru <strong>clojure.string</strong> či jeho aliasu <strong>str</strong>,
je možné provést i následující operaci, která všechny symboly ze jmenného
prostoru <strong>clojure.string</strong> umístí do aktivního jmenného prostoru
(se všemi důsledky, ostatně se podívejte na překrytí některých jmen):</p>

<pre>
clojure8-test.core=&gt; <strong>(require '[clojure.string :refer :all])</strong>
WARNING: reverse already refers to: #'clojure.core/reverse in namespace: clojure8-test.core, being replaced by: #'clojure.string/reverse
WARNING: replace already refers to: #'clojure.core/replace in namespace: clojure8-test.core, being replaced by: #'clojure.string/replace
nil
</pre>

<p>Nyní je již možné funkce volat bez přidání aliasu na začátek:</p>

<pre>
clojure8-test.core=&gt; <strong>(includes? s "world")</strong>
true
&nbsp;
clojure8-test.core=&gt; <strong>(starts-with? s "H")</strong>
true
&nbsp;
clojure8-test.core=&gt; <strong>(starts-with? s "x")</strong>
false
&nbsp;
clojure8-test.core=&gt; <strong>(ends-with? s "!")</strong>
true
</pre>



<p><a name="k08"></a></p>
<h2 id="k08">8. Socket server</h2>

<p>Poměrně důležitou a především pak praktickou novinkou ve verzi 1.8.0 je
zahrnutí jednoduchého a na systémové prostředky nenáročného socket serveru,
který může být při startu aplikace spuštěn a na určeném portu (či portech) může
čekat na vzdálené připojení, typicky k&nbsp;interaktivní smyčce REPL. Díky této
nové vlastnosti je například možné se prakticky kdykoli připojit k&nbsp;již
běžící aplikaci, provést ladění, zjištění aktuálního vytížení aplikace,
aplikovat změnu programového kódu některé funkce či změnu hodnoty proměnné
(například atomu), a to bez nutnosti restartu aplikace a navíc bez nutnosti
nějakým způsobem přistupovat ke standardnímu vstupu, výstupu a chybovému
výstupu, který je ke smyčce REPL přiřazen. V&nbsp;následující kapitole si
ukážeme typické použití serveru.</p>



<p><a name="k09"></a></p>
<h2 id="k09">9. Spuštění serveru a použití telnetu k&nbsp;přístupu k&nbsp;REPLu</h2>

<p>To, zda se server spustí či nikoli, je ovlivněno existencí vlastnosti
nazvané <strong>clojure.server.{jméno-serveru}</strong>, kde se do poslední
části jména vlastnosti musí zadat jednoznačný identifikátor. Díky tomu, že se
do jména vlastnosti zadává i uživatelsky volitelná část, je možné spustit
dokonce i větší množství serverů, které se budou lišit jak svými porty (na
nichž čekají na požadavky), tak i svými jmény (či dalšími vlastnostmi). Jméno
vlastnosti tedy může vypadat takto:</p>

<pre>
clojure.server.repl1
</pre>

<p>Hodnotou vlastnosti je řetězec obsahující mapu (ve smyslu jazyka Clojure),
která může obsahovat tyto klíče:</p>

<table>
<tr><th>#</th><th>Klíč</th><th>Vyžadováno?</th><th>Výchozí hodnota</th><th>Význam</th></tr>
<tr><td>1</td><td>:address      </td><td>ne </td><td>&times;</td><td>IP adresa nebo hostname</td></tr>
<tr><td>2</td><td>:port         </td><td>ano</td><td>&times;</td><td>port, na němž server bude čekat na požadavky</td></tr>
<tr><td>3</td><td>:accept       </td><td>ano</td><td>&times;</td><td>která funkce se použije pro příjem požadavků, typicky clojure.core.server/repl</td></tr>
<tr><td>4</td><td>:args         </td><td>ne </td><td>()</td><td>další argumenty předávané funkci specifikované v&nbsp;:accept</td></tr>
<tr><td>5</td><td>:server-daemon</td><td>ne </td><td>true</td><td>pokud je nastaveno na true (výchozí hodnota), nebude vlákno serveru bránit ukončení aplikace</td></tr>
<tr><td>6</td><td>:client-deamon</td><td>ne </td><td>true</td><td>dtto pro klienta (pro REPL nevýznamné)</td></tr>
<tr><td>7</td><td>:bind-err     </td><td>ne </td><td>true</td><td>pokud je nastaveno na true (výchozí hodnota), bude se i chybový výstup posílat klientovi</td></tr>
</table>

<p>Příklad specifikace vlastnosti nazvané <strong>clojure.server.repl</strong>
při spouštění JVM:</p>

<pre>
-Dclojure.server.repl="{:port 5555 :accept clojure.core.server/repl}"
</pre>

<p>Spuštění JVM s&nbsp;interpretrem jazyka Clojure může vypadat takto:</p>

<pre>
java -Dclojure.server.repl="{:port 5555 :accept clojure.core.server/repl}" -jar clojure-1.8.0.jar
</pre>

<a href="http://www.root.cz/obrazek/235040/"><img src="http://i.iinfo.cz/images/323/clojure1-prev.png" class="image-235040" alt="&#160;" height="270" width="293" /></a>
<p><i>Obrázek 1: V&nbsp;horním terminálu je spuštěn interpret Clojure i se
serverem. V&nbsp;dolním terminálu se přes telnet připojujeme k&nbsp;serveru a
získáme tak vlastní smyčku REPL se samostatným nastavením, ovšem
s&nbsp;přístupem ke všem symbolům,které jsou v&nbsp;interpretru dostupné. Nové
symboly zde lze i vytvářet a ovlivňovat tak běžící aplikaci.</i></p>

<p>Dokonce je možné si spustit dva či více serverů, například:</p>

<pre>
java -Dclojure.server.repl1="{:port 5555 :accept clojure.core.server/repl}" -Dclojure.server.repl2="{:port 5556 :accept clojure.core.server/repl}" -jar clojure-1.8.0.jar
</pre>

<p>Každý server samozřejmě musí používat jiný port, na němž čeká na požadavky
od klientů.</p>

<a href="http://www.root.cz/obrazek/235041/"><img src="http://i.iinfo.cz/images/169/clojure2-prev.png" class="image-235041" alt="&#160;" height="256" width="370" /></a>
<p><i>Obrázek 2: Zde došlo ke spuštění dvou serverů, k&nbsp;nimž jsem se ihned
po jejich vytvoření připojil.</i></p>

<a href="http://www.root.cz/obrazek/235042/"><img src="http://i.iinfo.cz/images/395/clojure3-prev.png" class="image-235042" alt="&#160;" height="178" width="370" /></a>
<p><i>Obrázek 3: Po skončení aplikace jsou klienti násilně odpojeni, protože
jsme nikde nespecifikovali, že má server běžet v&nbsp;režimu démona.</i></p>



<p><a name="k10"></a></p>
<h2 id="k10">10. *out*, *err*, clojure.core.server/*session* a další symboly, které mají v&nbsp;serveru odlišné nastavení</h2>

<p>Jak jsme si již řekli <a href="#k09">v&nbsp;předchozí kapitole</a>, je
většina symbolů (ve všech jmenných prostorech) pro hlavní část aplikace i pro
vlákno, v&nbsp;němž je implementován server, shodné, lze k&nbsp;nim
přistupovat, měnit je atd. Existuje však několik objektů, které musí mít
odlišnou hodnotu. Jedná se samozřejmě o vstupní a výstupní proudy
reprezentované symboly *in*, *out* a *err*. Pokud se uživatel připojí
k&nbsp;aplikaci přes socket (na kterém poslouchá server), samozřejmě očekává,
že tyto symboly budou nastaveny takovým způsobem, že vstup i výstup bude
prováděn přes socket a ne přes standardní vstup a výstup navázaný na terminál,
v&nbsp;němž byla aplikace spuštěna. Dalším speciálním symbolem je
<strong>clojure.core.server/*session*</strong>, na nějž je navázána mapa
obsahující například tyto hodnoty:</p>

<pre>
{:server "repl", :client "1"}
</pre>

<p>Vidíme zde jméno serveru, tj.&nbsp;poslední část jména příslušné vlastnosti)
a identifikaci klienta. Pro hlavní smyčku REPL tento symbol neexistuje.</p>



<p><a name="k11"></a></p>
<h2 id="k11">11. Použití REPLu přístupného přes socket</h2>

<p>Podívejme se nyní na dosti umělý demonstrační příklad, na němž si ukážeme
použití smyčky REPL. V&nbsp;tomto příkladu se v&nbsp;nekonečné smyčce postupně
(konkrétně v&nbsp;sekundových intervalech) zvyšuje hodnota atomu o jedničku.
Celý příklad může vypadat takto:</p>

<pre>
(def counter (atom 0))

(doseq [i (range)]
    (reset! counter i)
    (Thread/sleep 1000))
</pre>

<p>Nejprve spustíme interpret jazyka Clojure:</p>

<pre>
java -Dclojure.server.repl="{:port 5555 :accept clojure.core.server/repl}" -jar clojure-1.8.0.jar
</pre>

<p>Načteme a spustíme výše uvedený příklad, který jsme si předtím uložili do
souboru nazvaného <strong>test.clj</strong>:</p>

<pre>
<strong>(load-file "test.clj")</strong>
</pre>

<p>Nyní se hlavní smyčka REPL &bdquo;odmlčí&ldquo;, protože vyhodnocuje
nekonečnou sekvenci a v&nbsp;sekundových intervalech nastavuje atom nazvaný
<strong>counter</strong> na hodnotu, kterou má aktuální prvek této
sekvence.</p>

<p>V&nbsp;novém terminálu se k&nbsp;aplikaci přihlásíme přes server očekávající
požadavky na portu číslo 5555:</p>

<pre>
<strong>telnet localhost 5555</strong>
Trying 127.0.0.1...
Connected to localhost.
Escape character is '^]'.
</pre>

<p>A ihned si můžeme vypsat aktuální hodnotu uloženou do atomu
<strong>counter</strong>:</p>

<pre>
user=&gt; <strong>@counter</strong>
16
&nbsp;
user=&gt; <strong>@counter</strong>
21
</pre>

<p>Po násilném ukončení aplikace (Ctrl+C) se ukončí i sezení spuštěné přes
Telnet:</p>

<pre>
&nbsp;
user=&gt; <strong>Connection closed by foreign host.</strong>
</pre>



<p><a name="k12"></a></p>
<h2 id="k12">12. Další vylepšení v&nbsp;Clojure 1.8.0</h2>

<p>Další zajímavé vylepšení jazyka Clojure bylo vyřešeno v&nbsp;rámci <a
href="http://dev.clojure.org/jira/browse/CLJ-1263">CLJ-1263</a>. Jedná se o
interní optimalizaci využívanou při volání funkcí, kdy se namísto relativně
složité dereference, načtení &bdquo;univerzálního&ldquo; rozhraní IFn a
zavolání instrukce <a
href="http://www.root.cz/clanky/pohled-pod-kapotu-jvm-volani-funkci-a-metod-v-jvm-lua-vm-a-python-vm/#k09">invokeinterface</a>
používá jediná instrukce <a
href="http://www.root.cz/clanky/pohled-pod-kapotu-jvm-volani-funkci-a-metod-v-jvm-lua-vm-a-python-vm/#k05">invokevirtual</a>,
což je rychlejší. Typicky se tato optimalizace využívá pro funkce označené
tagem :^static, ideálně ještě s&nbsp;určením datových typů všech parametrů
funkce i její návratové hodnoty &ndash; v&nbsp;tomto případě je funkce
přeložena prakticky stejným způsobem, jako plně typovaná Javovská metoda.</p>



<p><a name="k13"></a></p>
<h2 id="k13">13. Odkazy na předchozí části tohoto seriálu</h2>

<ol>

<li>Clojure  1: Úvod<br />
<a href="http://www.root.cz/clanky/clojure-aneb-jazyk-umoznujici-tvorbu-bezpecnych-vicevlaknovych-aplikaci-pro-jvm/">http://www.root.cz/clanky/clojure-aneb-jazyk-umoznujici-tvorbu-bezpecnych-vicevlaknovych-aplikaci-pro-jvm/</a>
</li>

<li>Clojure  2: Symboly, kolekce atd.<br />
<a href="http://www.root.cz/clanky/clojure-aneb-jazyk-umoznujici-tvorbu-bezpecnych-vicevlaknovych-aplikaci-pro-jvm-2-cast/">http://www.root.cz/clanky/clojure-aneb-jazyk-umoznujici-tvorbu-bezpecnych-vicevlaknovych-aplikaci-pro-jvm-2-cast/</a>
</li>

<li>Clojure  3: Funkcionální programování<br />
<a href="http://www.root.cz/clanky/clojure-aneb-jazyk-umoznujici-tvorbu-bezpecnych-vicevlaknovych-aplikaci-pro-jvm-3-cast-funkcionalni-programovani/">http://www.root.cz/clanky/clojure-aneb-jazyk-umoznujici-tvorbu-bezpecnych-vicevlaknovych-aplikaci-pro-jvm-3-cast-funkcionalni-programovani/</a>
</li>

<li>Clojure  4: Kolekce, sekvence a lazy sekvence<br />
<a href="http://www.root.cz/clanky/clojure-aneb-jazyk-umoznujici-tvorbu-bezpecnych-vicevlaknovych-aplikaci-pro-jvm-4-cast-kolekce-sekvence-a-lazy-sekvence/">http://www.root.cz/clanky/clojure-aneb-jazyk-umoznujici-tvorbu-bezpecnych-vicevlaknovych-aplikaci-pro-jvm-4-cast-kolekce-sekvence-a-lazy-sekvence/</a>
</li>

<li>Clojure  5: Sekvence, lazy sekvence a paralelní programy<br />
<a href="http://www.root.cz/clanky/clojure-a-bezpecne-aplikace-pro-jvm-sekvence-lazy-sekvence-a-paralelni-programy/">http://www.root.cz/clanky/clojure-a-bezpecne-aplikace-pro-jvm-sekvence-lazy-sekvence-a-paralelni-programy/</a>
</li>

<li>Clojure  6: Podpora pro paralelní programování<br />
<a href="http://www.root.cz/clanky/programovaci-jazyk-clojure-6-futures-nejsou-jen-financni-derivaty/">http://www.root.cz/clanky/programovaci-jazyk-clojure-6-futures-nejsou-jen-financni-derivaty/</a>
</li>

<li>Clojure  7: Další funkce pro paralelní programování<br />
<a href="http://www.root.cz/clanky/programovaci-jazyk-clojure-7-dalsi-podpurne-prostredky-pro-paralelni-programovani/">http://www.root.cz/clanky/programovaci-jazyk-clojure-7-dalsi-podpurne-prostredky-pro-paralelni-programovani/</a>
</li>

<li>Clojure  8: Identity, stavy, neměnné hodnoty a reference<br />
<a href="http://www.root.cz/clanky/programovaci-jazyk-clojure-8-identity-stavy-nemenne-hodnoty-a-referencni-typy/">http://www.root.cz/clanky/programovaci-jazyk-clojure-8-identity-stavy-nemenne-hodnoty-a-referencni-typy/</a>
</li>

<li>Clojure  9: Validátory, pozorovatelé a kooperace s Javou<br />
<a href="http://www.root.cz/clanky/programovaci-jazyk-clojure-9-validatory-pozorovatele-a-kooperace-mezi-clojure-a-javou/">http://www.root.cz/clanky/programovaci-jazyk-clojure-9-validatory-pozorovatele-a-kooperace-mezi-clojure-a-javou/</a>
</li>

<li>Clojure 10: Kooperace mezi Clojure a Javou<br />
<a href="http://www.root.cz/clanky/programovaci-jazyk-clojure-10-kooperace-mezi-clojure-a-javou-pokracovani/">http://www.root.cz/clanky/programovaci-jazyk-clojure-10-kooperace-mezi-clojure-a-javou-pokracovani/</a>
</li>

<li>Clojure 11: Generátorová notace seznamu/list comprehension<br />
<a href="http://www.root.cz/clanky/programovaci-jazyk-clojure-11-generatorova-notace-seznamu-list-comprehension/">http://www.root.cz/clanky/programovaci-jazyk-clojure-11-generatorova-notace-seznamu-list-comprehension/</a>
</li>

<li>Clojure 12: Překlad programů z Clojure do bajtkódu JVM I:<br />
<a href="http://www.root.cz/clanky/programovaci-jazyk-clojure-12-preklad-programu-z-clojure-do-bajtkodu-jvm/">http://www.root.cz/clanky/programovaci-jazyk-clojure-12-preklad-programu-z-clojure-do-bajtkodu-jvm/</a>
</li>

<li>Clojure 13: Překlad programů z Clojure do bajtkódu JVM II:<br />
<a href="http://www.root.cz/clanky/programovaci-jazyk-clojure-13-preklad-programu-z-clojure-do-bajtkodu-jvm-pokracovani/">http://www.root.cz/clanky/programovaci-jazyk-clojure-13-preklad-programu-z-clojure-do-bajtkodu-jvm-pokracovani/</a>
</li>

<li>Clojure 14: Základy práce se systémem maker<br />
<a href="http://www.root.cz/clanky/programovaci-jazyk-clojure-14-zaklady-prace-se-systemem-maker/">http://www.root.cz/clanky/programovaci-jazyk-clojure-14-zaklady-prace-se-systemem-maker/</a>
</li>

<li>Clojure 15: Tvorba uživatelských maker<br />
<a href="http://www.root.cz/clanky/programovaci-jazyk-clojure-15-tvorba-uzivatelskych-maker/">http://www.root.cz/clanky/programovaci-jazyk-clojure-15-tvorba-uzivatelskych-maker/</a>
</li>

<li>Clojure 16: Složitější uživatelská makra<br />
<a href="http://www.root.cz/clanky/programovaci-jazyk-clojure-16-slozitejsi-uzivatelska-makra/">http://www.root.cz/clanky/programovaci-jazyk-clojure-16-slozitejsi-uzivatelska-makra/</a>
</li>

<li>Clojure 17: Využití standardních maker v praxi<br />
<a href="http://www.root.cz/clanky/programovaci-jazyk-clojure-17-vyuziti-standardnich-maker-v-praxi/">http://www.root.cz/clanky/programovaci-jazyk-clojure-17-vyuziti-standardnich-maker-v-praxi/</a>
</li>

<li>Clojure 18: Základní techniky optimalizace aplikací<br />
<a href="http://www.root.cz/clanky/programovaci-jazyk-clojure-18-zakladni-techniky-optimalizace-aplikaci/">http://www.root.cz/clanky/programovaci-jazyk-clojure-18-zakladni-techniky-optimalizace-aplikaci/</a>
</li>

<li>Clojure 19: Vývojová prostředí pro Clojure<br />
<a href="http://www.root.cz/clanky/programovaci-jazyk-clojure-19-vyvojova-prostredi-pro-clojure/">http://www.root.cz/clanky/programovaci-jazyk-clojure-19-vyvojova-prostredi-pro-clojure/</a>
</li>

<li>Clojure 20: Vývojová prostředí pro Clojure (Vimu s REPL)<br />
<a href="http://www.root.cz/clanky/programovaci-jazyk-clojure-20-vyvojova-prostredi-pro-clojure-integrace-vimu-s-repl/">http://www.root.cz/clanky/programovaci-jazyk-clojure-20-vyvojova-prostredi-pro-clojure-integrace-vimu-s-repl/</a>
</li>

<li>Clojure 21: ClojureScript aneb překlad Clojure do JS<br />
<a href="http://www.root.cz/clanky/programovaci-jazyk-clojure-21-clojurescript-aneb-preklad-clojure-do-javascriptu/">http://www.root.cz/clanky/programovaci-jazyk-clojure-21-clojurescript-aneb-preklad-clojure-do-javascriptu/</a>
</li>

<li>Leiningen: nástroj pro správu projektů napsaných v Clojure<br />
<a href="http://www.root.cz/clanky/leiningen-nastroj-pro-spravu-projektu-napsanych-v-clojure/">http://www.root.cz/clanky/leiningen-nastroj-pro-spravu-projektu-napsanych-v-clojure/</a>
</li>

<li>Leiningen: nástroj pro správu projektů napsaných v Clojure (2)<br />
<a href="http://www.root.cz/clanky/leiningen-nastroj-pro-spravu-projektu-napsanych-v-clojure-2/">http://www.root.cz/clanky/leiningen-nastroj-pro-spravu-projektu-napsanych-v-clojure-2/</a>
</li>

<li>Leiningen: nástroj pro správu projektů napsaných v Clojure (3)<br />
<a href="http://www.root.cz/clanky/leiningen-nastroj-pro-spravu-projektu-napsanych-v-clojure-3/">http://www.root.cz/clanky/leiningen-nastroj-pro-spravu-projektu-napsanych-v-clojure-3/</a>
</li>

<li>Leiningen: nástroj pro správu projektů napsaných v Clojure (4)<br />
<a href="http://www.root.cz/clanky/leiningen-nastroj-pro-spravu-projektu-napsanych-v-clojure-4/">http://www.root.cz/clanky/leiningen-nastroj-pro-spravu-projektu-napsanych-v-clojure-4/</a>
</li>

<li>Leiningen: nástroj pro správu projektů napsaných v Clojure (5)<br />
<a href="http://www.root.cz/clanky/leiningen-nastroj-pro-spravu-projektu-napsanych-v-clojure-5/">http://www.root.cz/clanky/leiningen-nastroj-pro-spravu-projektu-napsanych-v-clojure-5/</a>
</li>

<li>Leiningen: nástroj pro správu projektů napsaných v Clojure (6)<br />
<a href="http://www.root.cz/clanky/leiningen-nastroj-pro-spravu-projektu-napsanych-v-clojure-6/">http://www.root.cz/clanky/leiningen-nastroj-pro-spravu-projektu-napsanych-v-clojure-6/</a>
</li>

<li>Programovací jazyk Clojure a databáze (1.část)<br />
<a href="http://www.root.cz/clanky/programovaci-jazyk-clojure-a-databaze-1-cast/">http://www.root.cz/clanky/programovaci-jazyk-clojure-a-databaze-1-cast/</a>
</li>

<li>Pluginy pro Leiningen<br />
<a href="http://www.root.cz/clanky/leiningen-nastroj-pro-spravu-projektu-napsanych-v-clojure-pluginy-pro-leiningen/">http://www.root.cz/clanky/leiningen-nastroj-pro-spravu-projektu-napsanych-v-clojure-pluginy-pro-leiningen/</a>
</li>

<li>Programovací jazyk Clojure a knihovny pro práci s vektory a maticemi<br />
<a href="http://www.root.cz/clanky/programovaci-jazyk-clojure-a-knihovny-pro-praci-s-vektory-a-maticemi/">http://www.root.cz/clanky/programovaci-jazyk-clojure-a-knihovny-pro-praci-s-vektory-a-maticemi/</a>
</li>

<li>Programovací jazyk Clojure a knihovny pro práci s vektory a maticemi (2)<br />
<a href="http://www.root.cz/clanky/programovaci-jazyk-clojure-a-knihovny-pro-praci-s-vektory-a-maticemi-2/">http://www.root.cz/clanky/programovaci-jazyk-clojure-a-knihovny-pro-praci-s-vektory-a-maticemi-2/</a>
</li>

<li>Programovací jazyk Clojure: syntéza procedurálních textur s využitím knihovny Clisk<br />
<a href="http://www.root.cz/clanky/programovaci-jazyk-clojure-synteza-proceduralnich-textur-s-vyuzitim-knihovny-clisk/">http://www.root.cz/clanky/programovaci-jazyk-clojure-synteza-proceduralnich-textur-s-vyuzitim-knihovny-clisk/</a>
</li>

<li>Programovací jazyk Clojure: syntéza procedurálních textur s využitím knihovny Clisk (2)<br />
<a href="http://www.root.cz/clanky/programovaci-jazyk-clojure-synteza-proceduralnich-textur-s-vyuzitim-knihovny-clisk-2/">http://www.root.cz/clanky/programovaci-jazyk-clojure-synteza-proceduralnich-textur-s-vyuzitim-knihovny-clisk-2/</a>
</li>

<li>Programovací jazyk Clojure: syntéza procedurálních textur s využitím knihovny Clisk (dokončení)<br />
<a href="http://www.root.cz/clanky/programovaci-jazyk-clojure-synteza-proceduralnich-textur-s-vyuzitim-knihovny-clisk-dokonceni/">http://www.root.cz/clanky/programovaci-jazyk-clojure-synteza-proceduralnich-textur-s-vyuzitim-knihovny-clisk-dokonceni/</a>
</li>

<li>Seesaw: knihovna pro snadnou tvorbu GUI v jazyce Clojure<br />
<a href="http://www.root.cz/clanky/seesaw-knihovna-pro-snadnou-tvorbu-gui-v-jazyce-clojure/">http://www.root.cz/clanky/seesaw-knihovna-pro-snadnou-tvorbu-gui-v-jazyce-clojure/</a>
</li>

<li>Seesaw: knihovna pro snadnou tvorbu GUI v jazyce Clojure (2)<br />
<a href="http://www.root.cz/clanky/seesaw-knihovna-pro-snadnou-tvorbu-gui-v-jazyce-clojure-2/">http://www.root.cz/clanky/seesaw-knihovna-pro-snadnou-tvorbu-gui-v-jazyce-clojure-2/</a>
</li>

<li>Seesaw: knihovna pro snadnou tvorbu GUI v jazyce Clojure (3)<br />
<a href="http://www.root.cz/clanky/seesaw-knihovna-pro-snadnou-tvorbu-gui-v-jazyce-clojure-3/">http://www.root.cz/clanky/seesaw-knihovna-pro-snadnou-tvorbu-gui-v-jazyce-clojure-3/</a>
</li>

<li>Programovací jazyk Clojure a práce s Gitem<br />
<a href="http://www.root.cz/clanky/programovaci-jazyk-clojure-a-prace-s-gitem/">http://www.root.cz/clanky/programovaci-jazyk-clojure-a-prace-s-gitem/</a>
</li>

<li>Programovací jazyk Clojure a práce s Gitem (2)<br />
<a href="http://www.root.cz/clanky/programovaci-jazyk-clojure-a-prace-s-gitem-2/">http://www.root.cz/clanky/programovaci-jazyk-clojure-a-prace-s-gitem-2/</a>
</li>

<li>Programovací jazyk Clojure – triky při práci s řetězci<br />
<a href="http://www.root.cz/clanky/programovaci-jazyk-clojure-triky-pri-praci-s-retezci/">http://www.root.cz/clanky/programovaci-jazyk-clojure-triky-pri-praci-s-retezci/</a>
</li>

<li>Programovací jazyk Clojure – triky při práci s kolekcemi<br />
<a href="http://www.root.cz/clanky/programovaci-jazyk-clojure-triky-pri-praci-s-kolekcemi/">http://www.root.cz/clanky/programovaci-jazyk-clojure-triky-pri-praci-s-kolekcemi/</a>
</li>

<li>Programovací jazyk Clojure – práce s mapami a množinami<br />
<a href="http://www.root.cz/clanky/programovaci-jazyk-clojure-prace-s-mapami-a-mnozinami/">http://www.root.cz/clanky/programovaci-jazyk-clojure-prace-s-mapami-a-mnozinami/</a>
</li>

<li>Programovací jazyk Clojure – základy zpracování XML<br />
<a href="http://www.root.cz/clanky/programovaci-jazyk-clojure-zaklady-zpracovani-xml/">http://www.root.cz/clanky/programovaci-jazyk-clojure-zaklady-zpracovani-xml/</a>
</li>

<li>Programovací jazyk Clojure – testování s využitím knihovny Expectations<br />
<a href="http://www.root.cz/clanky/programovaci-jazyk-clojure-testovani-s-vyuzitim-knihovny-expectations/">http://www.root.cz/clanky/programovaci-jazyk-clojure-testovani-s-vyuzitim-knihovny-expectations/</a>
</li>

<li>Programovací jazyk Clojure – některé užitečné triky použitelné (nejenom) v&nbsp;testech<br />
<a href="http://www.root.cz/clanky/programovaci-jazyk-clojure-nektere-uzitecne-triky-pouzitelne-nejenom-v-testech/">http://www.root.cz/clanky/programovaci-jazyk-clojure-nektere-uzitecne-triky-pouzitelne-nejenom-v-testech/</a>
</li>

<li>Enlive – výkonný šablonovací systém pro jazyk Clojure<br/>
<a href="http://www.root.cz/clanky/enlive-vykonny-sablonovaci-system-pro-jazyk-clojure/">http://www.root.cz/clanky/enlive-vykonny-sablonovaci-system-pro-jazyk-clojure/</a>
</li>

<li>Nástroj Leiningen a programovací jazyk Clojure: tvorba vlastních knihoven pro veřejný repositář Clojars<br />
<a href="http://www.root.cz/clanky/nastroj-leiningen-a-programovaci-jazyk-clojure-tvorba-vlastnich-knihoven-pro-verejny-repositar-clojars/">http://www.root.cz/clanky/nastroj-leiningen-a-programovaci-jazyk-clojure-tvorba-vlastnich-knihoven-pro-verejny-repositar-clojars/</a>
</li>

</ol>



<p><a name="k14"></a></p>
<h2 id="k14">14. Odkazy na Internetu</h2>

<ol>

<li>Zip archiv s&nbsp;Clojure 1.8.0<br />
<a href="http://repo1.maven.org/maven2/org/clojure/clojure/1.8.0/clojure-1.8.0.zip">http://repo1.maven.org/maven2/org/clojure/clojure/1.8.0/clojure-1.8.0.zip</a>
</li>

<li>Clojure 1.8 is now available<br />
<a href="http://clojure.org/news/2016/01/19/clojure18">http://clojure.org/news/2016/01/19/clojure18</a>
</li>

<li>Changes to Clojure in Version 1.8<br />
<a href="https://github.com/clojure/clojure/blob/master/changes.md">https://github.com/clojure/clojure/blob/master/changes.md</a>
</li>

<li>Socket Server REPL<br />
<a href="http://dev.clojure.org/display/design/Socket+Server+REPL">http://dev.clojure.org/display/design/Socket+Server+REPL</a>
</li>

<li>CLJ-1671: Clojure socket server<br />
<a href="http://dev.clojure.org/jira/browse/CLJ-1671">http://dev.clojure.org/jira/browse/CLJ-1671</a>
</li>

<li>CLJ-1449: Add clojure.string functions for portability to ClojureScript<br />
<a href="http://dev.clojure.org/jira/browse/CLJ-1449">http://dev.clojure.org/jira/browse/CLJ-1449</a>
</li>

<li>Launching a Socket Server<br />
<a href="http://clojure.org/reference/repl_and_main#_launching_a_socket_server">http://clojure.org/reference/repl_and_main#_launching_a_socket_server</a>
</li>

<li>API for clojure.string<br />
<a href="http://clojure.github.io/clojure/branch-master/clojure.string-api.html">http://clojure.github.io/clojure/branch-master/clojure.string-api.html</a>
</li>

<li>Clojars:<br />
<a href="https://clojars.org/">https://clojars.org/</a>
</li>

<li>
Seznam knihoven na Clojars:<br />
<a href="https://clojars.org/projects">https://clojars.org/projects</a>
</li>

<li>Clojure Cookbook: Templating HTML with Enlive<br />
<a href="https://github.com/clojure-cookbook/clojure-cookbook/blob/master/07_webapps/7-11_enlive.asciidoc">https://github.com/clojure-cookbook/clojure-cookbook/blob/master/07_webapps/7-11_enlive.asciidoc</a>
</li>

<li>An Introduction to Enlive<br />
<a href="https://github.com/swannodette/enlive-tutorial/">https://github.com/swannodette/enlive-tutorial/</a>
</li>

<li>Enlive na GitHubu<br />
<a href="https://github.com/cgrand/enlive">https://github.com/cgrand/enlive</a>
</li>

<li>Expectations: příklady atd.<br />
<a href="http://jayfields.com/expectations/">http://jayfields.com/expectations/</a>
</li>

<li>Expectations na GitHubu<br />
<a href="https://github.com/jaycfields/expectations">https://github.com/jaycfields/expectations</a>
</li>

<li>Lein-expectations na GitHubu<br />
<a href="https://github.com/gar3thjon3s/lein-expectations">https://github.com/gar3thjon3s/lein-expectations</a>
</li>

<li>Testing Clojure With Expectations<br />
<a href="https://semaphoreci.com/blog/2014/09/23/testing-clojure-with-expectations.html">https://semaphoreci.com/blog/2014/09/23/testing-clojure-with-expectations.html</a>
</li>

<li>Clojure testing TDD/BDD libraries: clojure.test vs Midje vs Expectations vs Speclj<br />
<a href="https://www.reddit.com/r/Clojure/comments/1viilt/clojure_testing_tddbdd_libraries_clojuretest_vs/">https://www.reddit.com/r/Clojure/comments/1viilt/clojure_testing_tddbdd_libraries_clojuretest_vs/</a>
</li>

<li>Testing: One assertion per test<br />
<a href="http://blog.jayfields.com/2007/06/testing-one-assertion-per-test.html">http://blog.jayfields.com/2007/06/testing-one-assertion-per-test.html</a>
</li>

<li>Rewriting Your Test Suite in Clojure in 24 hours<br />
<a href="http://blog.circleci.com/rewriting-your-test-suite-in-clojure-in-24-hours/">http://blog.circleci.com/rewriting-your-test-suite-in-clojure-in-24-hours/</a>
</li>

<li>Clojure doc: zipper<br />
<a href="http://clojuredocs.org/clojure.zip/zipper">http://clojuredocs.org/clojure.zip/zipper</a>
</li>

<li>Clojure doc: parse<br />
<a href="http://clojuredocs.org/clojure.xml/parse">http://clojuredocs.org/clojure.xml/parse</a>
</li>

<li>Clojure doc: xml-zip<br />
<a href="http://clojuredocs.org/clojure.zip/xml-zip">http://clojuredocs.org/clojure.zip/xml-zip</a>
</li>

<li>Clojure doc: xml-seq<br />
<a href="http://clojuredocs.org/clojure.core/xml-seq">http://clojuredocs.org/clojure.core/xml-seq</a>
</li>

<li>Parsing XML in Clojure<br />
<a href="https://github.com/clojuredocs/guides">https://github.com/clojuredocs/guides</a>
</li>

<li>Clojure Zipper Over Nested Vector<br />
<a href="https://vitalyper.wordpress.com/2010/11/23/clojure-zipper-over-nested-vector/">https://vitalyper.wordpress.com/2010/11/23/clojure-zipper-over-nested-vector/</a>
</li>

<li>Understanding Clojure's PersistentVector implementation<br />
<a href="http://blog.higher-order.net/2009/02/01/understanding-clojures-persistentvector-implementation">http://blog.higher-order.net/2009/02/01/understanding-clojures-persistentvector-implementation</a>
</li>

<li>Understanding Clojure's PersistentHashMap (deftwice...)<br />
<a href="http://blog.higher-order.net/2009/09/08/understanding-clojures-persistenthashmap-deftwice.html">http://blog.higher-order.net/2009/09/08/understanding-clojures-persistenthashmap-deftwice.html</a>
</li>

<li>Assoc and Clojure's PersistentHashMap: part ii<br />
<a href="http://blog.higher-order.net/2010/08/16/assoc-and-clojures-persistenthashmap-part-ii.html">http://blog.higher-order.net/2010/08/16/assoc-and-clojures-persistenthashmap-part-ii.html</a>
</li>

<li>Ideal Hashtrees (paper)<br />
<a href="http://lampwww.epfl.ch/papers/idealhashtrees.pdf">http://lampwww.epfl.ch/papers/idealhashtrees.pdf</a>
</li>

<li>Clojure home page<br />
<a href="http://clojure.org/">http://clojure.org/</a>
</li>

<li>Clojure (downloads)<br />
<a href="http://clojure.org/downloads">http://clojure.org/downloads</a>
</li>

<li>Clojure Sequences<br />
<a href="http://clojure.org/sequences">http://clojure.org/sequences</a>
</li>

<li>Clojure Data Structures<br />
<a href="http://clojure.org/data_structures">http://clojure.org/data_structures</a>
</li>

<li>The Structure and Interpretation of Computer Programs: 2.2.1  Representing Sequences<br />
<a href="http://mitpress.mit.edu/sicp/full-text/book/book-Z-H-15.html#%_sec_2.2.1">http://mitpress.mit.edu/sicp/full-text/book/book-Z-H-15.html#%_sec_2.2.1</a>
</li>

<li>The Structure and Interpretation of Computer Programs: 3.3.1  Mutable List Structure<br />
<a href="http://mitpress.mit.edu/sicp/full-text/book/book-Z-H-22.html#%_sec_3.3.1">http://mitpress.mit.edu/sicp/full-text/book/book-Z-H-22.html#%_sec_3.3.1</a>
</li>

<li>Clojure - Functional Programming for the JVM<br />
<a href="http://java.ociweb.com/mark/clojure/article.html">http://java.ociweb.com/mark/clojure/article.html</a>
</li>

<li>Clojure quick reference<br />
<a href="http://faustus.webatu.com/clj-quick-ref.html">http://faustus.webatu.com/clj-quick-ref.html</a>
</li>

<li>4Clojure<br />
<a href="http://www.4clojure.com/">http://www.4clojure.com/</a>
</li>

<li>ClojureDoc (rozcestník s&nbsp;dokumentací jazyka Clojure)<br />
<a href="http://clojuredocs.org/">http://clojuredocs.org/</a>
</li>

<li>Clojure (na Wikipedia EN)<br />
<a href="http://en.wikipedia.org/wiki/Clojure">http://en.wikipedia.org/wiki/Clojure</a>
</li>

<li>Clojure (na Wikipedia CS)<br />
<a href="http://cs.wikipedia.org/wiki/Clojure">http://cs.wikipedia.org/wiki/Clojure</a>
</li>

<li>SICP (The Structure and Interpretation of Computer Programs)<br />
<a href="http://mitpress.mit.edu/sicp/">http://mitpress.mit.edu/sicp/</a>
</li>

<li>Pure function<br />
<a href="http://en.wikipedia.org/wiki/Pure_function">http://en.wikipedia.org/wiki/Pure_function</a>
</li>

<li>Funkcionální programování<br />
<a href="http://cs.wikipedia.org/wiki/Funkcionální_programování">http://cs.wikipedia.org/wiki/Funkcionální_programování</a>
</li>

<li>Čistě funkcionální (datové struktury, jazyky, programování)<br />
<a href="http://cs.wikipedia.org/wiki/Čistě_funkcionální">http://cs.wikipedia.org/wiki/Čistě_funkcionální</a>
</li>

<li>Clojure Macro Tutorial (Part I, Getting the Compiler to Write Your Code For You)<br />
<a href="http://www.learningclojure.com/2010/09/clojure-macro-tutorial-part-i-getting.html">http://www.learningclojure.com/2010/09/clojure-macro-tutorial-part-i-getting.html</a>
</li>

<li>Clojure Macro Tutorial (Part II: The Compiler Strikes Back)<br />
<a href="http://www.learningclojure.com/2010/09/clojure-macro-tutorial-part-ii-compiler.html">http://www.learningclojure.com/2010/09/clojure-macro-tutorial-part-ii-compiler.html</a>
</li>

<li>Clojure Macro Tutorial (Part III: Syntax Quote)<br />
<a href="http://www.learningclojure.com/2010/09/clojure-macro-tutorial-part-ii-syntax.html">http://www.learningclojure.com/2010/09/clojure-macro-tutorial-part-ii-syntax.html</a>
</li>

<li>Tech behind Tech: Clojure Macros Simplified<br />
<a href="http://techbehindtech.com/2010/09/28/clojure-macros-simplified/">http://techbehindtech.com/2010/09/28/clojure-macros-simplified/</a>
</li>

<li>Fatvat - Exploring functional programming: Clojure Macros<br />
<a href="http://www.fatvat.co.uk/2009/02/clojure-macros.html">http://www.fatvat.co.uk/2009/02/clojure-macros.html</a>
</li>

<li>Eulerovo číslo<br />
<a href="http://cs.wikipedia.org/wiki/Eulerovo_číslo">http://cs.wikipedia.org/wiki/Eulerovo_číslo</a>
</li>

<li>List comprehension<br />
<a href="http://en.wikipedia.org/wiki/List_comprehension">http://en.wikipedia.org/wiki/List_comprehension</a>
</li>

<li>List Comprehensions in Clojure<br />
<a href="http://asymmetrical-view.com/2008/11/18/list-comprehensions-in-clojure.html">http://asymmetrical-view.com/2008/11/18/list-comprehensions-in-clojure.html</a>
</li>

<li>Clojure Programming Concepts: List Comprehension<br />
<a href="http://en.wikibooks.org/wiki/Clojure_Programming/Concepts#List_Comprehension">http://en.wikibooks.org/wiki/Clojure_Programming/Concepts#List_Comprehension</a>
</li>

<li>Clojure core API: for macro<br />
<a href="http://clojure.github.com/clojure/clojure.core-api.html#clojure.core/for">http://clojure.github.com/clojure/clojure.core-api.html#clojure.core/for</a>
</li>

<li>cirrus machina - The Clojure for macro<br />
<a href="http://www.cirrusmachina.com/blog/comment/the-clojure-for-macro/">http://www.cirrusmachina.com/blog/comment/the-clojure-for-macro/</a>
</li>

<li>Riastradh's Lisp Style Rules<br />
<a href="http://mumble.net/~campbell/scheme/style.txt">http://mumble.net/~campbell/scheme/style.txt</a>
</li>

<li>Dynamic Languages Strike Back<br />
<a href="http://steve-yegge.blogspot.cz/2008/05/dynamic-languages-strike-back.html">http://steve-yegge.blogspot.cz/2008/05/dynamic-languages-strike-back.html</a>
</li>

<li>Scripting: Higher Level Programming for the 21st Century<br />
<a href="http://www.tcl.tk/doc/scripting.html">http://www.tcl.tk/doc/scripting.html</a>
</li>

<li>Java Virtual Machine Support for Non-Java Languages<br />
<a href="http://docs.oracle.com/javase/7/docs/technotes/guides/vm/multiple-language-support.html">http://docs.oracle.com/javase/7/docs/technotes/guides/vm/multiple-language-support.html</a>
</li>

<li>Třída java.lang.String<br />
<a href="http://docs.oracle.com/javase/7/docs/api/java/lang/String.html">http://docs.oracle.com/javase/7/docs/api/java/lang/String.html</a>
</li>

<li>Třída java.lang.StringBuffer<br />
<a href="http://docs.oracle.com/javase/7/docs/api/java/lang/StringBuffer.html">http://docs.oracle.com/javase/7/docs/api/java/lang/StringBuffer.html</a>
</li>

<li>Třída java.lang.StringBuilder<br />
<a href="http://docs.oracle.com/javase/7/docs/api/java/lang/StringBuilder.html">http://docs.oracle.com/javase/7/docs/api/java/lang/StringBuilder.html</a>
</li>

<li>StringBuffer versus String<br />
<a href="http://www.javaworld.com/article/2076072/build-ci-sdlc/stringbuffer-versus-string.html">http://www.javaworld.com/article/2076072/build-ci-sdlc/stringbuffer-versus-string.html</a>
</li>

<li>Threading macro (dokumentace k&nbsp;jazyku Clojure)<br />
<a href="https://clojure.github.io/clojure/clojure.core-api.html#clojure.core/-&gt;">https://clojure.github.io/clojure/clojure.core-api.html#clojure.core/-&gt;</a>
</li>

<li>Understanding the Clojure -&gt; macro<br />
<a href="http://blog.fogus.me/2009/09/04/understanding-the-clojure-macro/">http://blog.fogus.me/2009/09/04/understanding-the-clojure-macro/</a>
</li>

<li>clojure.inspector<br />
<a href="http://clojure.github.io/clojure/clojure.inspector-api.html">http://clojure.github.io/clojure/clojure.inspector-api.html</a>
</li>

<li>The Clojure Toolbox<br />
<a href="http://www.clojure-toolbox.com/">http://www.clojure-toolbox.com/</a>
</li>

<li>Unit Testing in Clojure<br />
<a href="http://nakkaya.com/2009/11/18/unit-testing-in-clojure/">http://nakkaya.com/2009/11/18/unit-testing-in-clojure/</a>
</li>

<li>Testing in Clojure (Part-1: Unit testing)<br />
<a href="http://blog.knoldus.com/2014/03/22/testing-in-clojure-part-1-unit-testing/">http://blog.knoldus.com/2014/03/22/testing-in-clojure-part-1-unit-testing/</a>
</li>

<li>API for clojure.test - Clojure v1.6 (stable)<br />
<a href="https://clojure.github.io/clojure/clojure.test-api.html">https://clojure.github.io/clojure/clojure.test-api.html</a>
</li>

<li>Leiningen: úvodní stránka<br />
<a href="http://leiningen.org/">http://leiningen.org/</a>
</li>

<li>Leiningen: Git repository<br />
<a href="https://github.com/technomancy/leiningen">https://github.com/technomancy/leiningen</a>
</li>

<li>leiningen-win-installer<br />
<a href="http://leiningen-win-installer.djpowell.net/">http://leiningen-win-installer.djpowell.net/</a>
</li>

<li>Clojure.org: Vars and the Global Environment<br />
<a href="http://clojure.org/Vars">http://clojure.org/Vars</a>
</li>

<li>Clojure.org: Refs and Transactions<br />
<a href="http://clojure.org/Refs">http://clojure.org/Refs</a>
</li>

<li>Clojure.org: Atoms<br />
<a href="http://clojure.org/Atoms">http://clojure.org/Atoms</a>
</li>

<li>Clojure.org: Agents as Asynchronous Actions<br />
<a href="http://clojure.org/agents">http://clojure.org/agents</a>
</li>

<li>Transient Data Structures
<a href="http://clojure.org/transients">http://clojure.org/transients</a>
</li>

</ol>



<p></p><p></p>
<p><small>Autor: <a href="http://www.fit.vutbr.cz/~tisnovpa">Pavel Tišnovský</a> &nbsp; 2016</small></p>
</body>
</html>

