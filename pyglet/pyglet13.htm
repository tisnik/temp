<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
        "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html>
<head>
<title>Multimediální knihovna Pyglet: vertex listy</title>
<meta name="Author" content="Pavel Tisnovsky" />
<meta name="Generator" content="vim" />
<meta http-equiv="content-type" content="text/html; charset=utf-8" />
<style type="text/css">
         body {color:#000000; background:#ffffff;}
         h1  {font-family: arial, helvetica, sans-serif; color:#ffffff; background-color:#c00000; text-align:center; padding-left:1em}
         h2  {font-family: arial, helvetica, sans-serif; color:#ffffff; background-color:#0000c0; padding-left:1em; text-align:left}
         h3  {font-family: arial, helvetica, sans-serif; color:#000000; background-color:#c0c0c0; padding-left:1em; text-align:left}
         h4  {font-family: arial, helvetica, sans-serif; color:#000000; background-color:#e0e0e0; padding-left:1em; text-align:left}
         a   {font-family: arial, helvetica, sans-serif;}
         li  {font-family: arial, helvetica, sans-serif; color:#000000; text-align:justify; width:450px;}
         ol  {font-family: arial, helvetica, sans-serif; color:#000000; text-align:justify; width:450px;}
         ul  {font-family: arial, helvetica, sans-serif; color:#000000; text-align:justify; width:450px;}
         p   {font-family: arial, helvetica, sans-serif; color:#000000; text-align:justify;}
         pre {background:#e0e0e0}
</style>
</head>

<body>

<h1>Multimediální knihovna Pyglet: vertex listy</h1>

<h3>Pavel Tišnovský</h3>

<p></p>

<h1>Úvodník</h1>

<p>V&nbsp;dnešní části seriálu o multimediální knihovně Pyglet si nejprve řekneme, jaké potenciální výkonnostní problémy mohou nastat při použití režimu přímého vykreslování (<i>immediate mode</i>), který jsme až doposud v&nbsp;demonstračních příkladech využívali. Posléze si ukážeme jedno z&nbsp;velmi elegantních řešení těchto problémů. Toto řešení spočívá v&nbsp;použití takzvaných <i>vertex listů</i> nabízených knihovnou Pyglet.</p>



<h2>Obsah</h2>

<p><a href="#k01">1. Režim přímého vykreslování (immediate mode) v&nbsp;knihovně OpenGL</a></p>
<p><a href="#k02">2. Nevýhody přímého režimu při použití na moderních grafických akcelerátorech</a></p>
<p><a href="#k03">3. Techniky, které dokážou vyřešit některé nevýhody přímého režimu</a></p>
<p><a href="#k04">4. Display listy</a></p>
<p><a href="#k05">5. Knihovna Pyglet a podpora takzvaných vertex listů</a></p>
<p><a href="#k06">6. Jednoduchý vertex list se souřadnicemi vrcholů ve 2D rovině či v&nbsp;3D prostoru</a></p>
<p><a href="#k07">7. První demonstrační příklad &ndash; vykreslení 2D scény funkcí <strong>pyglet.graphics.draw</strong></a></p>
<p><a href="#k08">8. Konstruktor <strong>pyglet.graphics.vertex_list</strong> a metoda <strong>pyglet.graphics.vertexdomain.VertexList.draw</strong></a></p>
<p><a href="#k09">9. Druhý demonstrační příklad &ndash; vykreslení 2D scény metodou <strong>pyglet.graphics.vertexdomain.VertexList.draw</strong></a></p>
<p><a href="#k10">10. Specifikace formátu dat uložených do vertex listu</a></p>
<p><a href="#k11">11. Kombinace více typů informací o vrcholech (souřadnice, barvy, texturovací souřadnice...)</a></p>
<p><a href="#k12">12. Třetí demonstrační příklad &ndash; vertex list se souřadnicemi a současně i barvami vrcholů</a></p>
<p><a href="#k13">13. Interní struktura objektu typu <strong>pyglet.graphics.vertexdomain.VertexList</strong></a></p>
<p><a href="#k14">14. Čtvrtý demonstrační příklad &ndash; výpis atributů vytvořeného vertex listu</a></p>
<p><a href="#k15">15. Pátý demonstrační příklad &ndash; složitější vertex list s&nbsp;více údaji o vrcholech</a></p>
<p><a href="#k16">16. Repositář s&nbsp;demonstračními příklady</a></p>
<p><a href="#k17">17. Odkazy na Internetu</a></p>



<p><a name="k01"></a></p>
<h2 id="k01">1. Režim přímého vykreslování (immediate mode) v&nbsp;knihovně OpenGL</h2>

<p>Ve všech předchozích částech seriálu o multimediální knihovně <i>Pyglet</i>, v&nbsp;nichž jsme vykreslovali dvourozměrné či trojrozměrné scény s&nbsp;použitím funkcí grafické knihovny <i>OpenGL</i>, se využíval takzvaný <i>režim přímého</i> vykreslování neboli <i>immediate mode</i>. Tento režim je specifický tím, že se v&nbsp;něm používají &bdquo;příkazové závorky&ldquo; představované funkcemi <strong>glBegin()</strong> a <strong>glEnd()</strong>. U funkce <strong>glBegin()</strong> se při jejím volání specifikuje typ grafického primitiva (body, úsečky, polyčáry, uzavřené polyčáry, trojúhelníky, trsy trojúhelníků, pruhy trojúhelníků atd.) a mezi <strong>glBegin()</strong> a <strong>glEnd()</strong> je možné zadávat libovolné množství souřadnic vrcholů v&nbsp;2D rovině či 3D prostoru, barev vrcholů, sekundárních barev vrcholů, souřadnic v&nbsp;prostoru textur (<i>texture space</i>), příznaky zobrazení hran atd.</p>

<p>Přímý režim vykreslování přináší programátorům jednu podstatnou výhodu, kterou nelze opomíjet &ndash; jeho použití je jednoduché a snadno pochopitelné. To mj.&nbsp;znamená, že je k&nbsp;dispozici relativně velké množství návodů, jak přímý režim použít. Dále se při použití přímého režimu nemusí předem alokovat žádná paměť na grafickém akcelerátoru, což opět zjednodušuje výsledný zdrojový kód.</p>

<p>Jen pro připomenutí si ukažme, jak vypadá část programu používající přímý režim. Povšimněte si již zmíněných &bdquo;příkazových závorek&ldquo; <strong>glBegin()</strong> a <strong>glEnd()</strong>:</p>

<pre>
def draw_walls():
    glBegin(GL_QUADS)                         # vykresleni otevrene krychle - sten domecku
    glColor3f(0.0, 0.0, 1.0)                  # modra barva steny
    glTexCoord2f(0.0, 0.0)
    glVertex3f(-5.0, -5.0, -5.0)
    glTexCoord2f(0.7, 0.0)
    glVertex3f(-5.0, -5.0,  5.0)
    glTexCoord2f(0.7, 0.7)
    glVertex3f( 5.0, -5.0,  5.0)
    glTexCoord2f(0.0, 0.7)
    glVertex3f( 5.0, -5.0, -5.0)

    glColor3f(0.0, 1.0, 0.0)                  # zelena barva steny
    glTexCoord2f(0.0, 0.0)
    glVertex3f(-5.0,  5.0, -5.0)
    glTexCoord2f(0.7, 0.0)
    glVertex3f(-5.0,  5.0,  5.0)
    glTexCoord2f(0.7, 0.7)
    glVertex3f( 5.0,  5.0,  5.0)
    glTexCoord2f(0.0, 0.7)
    glVertex3f( 5.0,  5.0, -5.0)

    glColor3f(1.0, 0.0, 0.0)                  # cervena barva steny
    glTexCoord2f(0.0, 0.0)
    glVertex3f(-5.0, -5.0, -5.0)
    glTexCoord2f(0.7, 0.0)
    glVertex3f(-5.0, -5.0,  5.0)
    glTexCoord2f(0.7, 0.7)
    glVertex3f(-5.0,  5.0,  5.0)
    glTexCoord2f(0.0, 0.7)
    glVertex3f(-5.0,  5.0, -5.0)

    glColor3f(1.0, 1.0, 0.0)                  # zluta barva steny
    glTexCoord2f(0.0, 0.0)
    glVertex3f( 5.0, -5.0, -5.0)
    glTexCoord2f(0.7, 0.0)
    glVertex3f( 5.0, -5.0,  5.0)
    glTexCoord2f(0.7, 0.7)
    glVertex3f( 5.0,  5.0,  5.0)
    glTexCoord2f(0.0, 0.7)
    glVertex3f( 5.0,  5.0, -5.0)
    glEnd()
</pre>



<p><a name="k02"></a></p>
<h2 id="k02">2. Nevýhody přímého režimu při použití na moderních grafických akcelerátorech</h2>

<p>Přímý režim má však také několik poměrně závažných nevýhod, které nakonec vedly k&nbsp;tomu, že se s&nbsp;jeho použitím v&nbsp;mnoha moderních aplikacích (typicky v&nbsp;počítačových hrách) vůbec nesetkáme. Tyto nevýhody dokonce způsobily, že v&nbsp;novějších verzích OpenGL již není přímý režim oficiálně podporován, což je na jednu stranu škoda (začínající programátoři to mají mnohem těžší), na druhou stranu je však vývoj OpenGL pochopitelně diktován zájmy těch firem, které za rozvojem této knihovny stojí. Jaké jsou tedy největší nevýhody přímého režimu?</p>

<ul>

<li>Pro každý snímek vykreslované trojrozměrné scény je nutné přenášet (mnohdy ta stejná) data neustále znovu, což je z&nbsp;pohledu moderních grafických akcelerátorů velmi pomalá a navíc neefektivní operace, která navíc může zdržovat i další činnosti počítače (přenos dat na disk, komunikace po síti atd.).</li>

<li>Grafický akcelerátor může začít vykreslovat stěny těles až ve chvíli, kdy jsou do jeho paměti přenesena všechna potřebná data. Nicméně z&nbsp;hlediska architektury aplikace je vykreslování zdrženo, protože typicky se v&nbsp;OpenGL provádí operace v&nbsp;tomto pořadí: prohoď buffery &rarr; vymaž zadní buffer &rarr; teprve poté začni vykreslovat. To přináší zbytečné zdržení.</li>

<li>Navíc je nutné podotknout, že data zapisovaná &bdquo;přímo&ldquo; funkcemi typu <strong>glVertex*</strong>, <strong>glTexCoord*</strong> či <strong>glColor*</strong> musí být nejdříve zpracována mikroprocesorem, serializována a teprve poté přenesena do grafického akcelerátoru. Při přenosu se používají různé buffery, opět se jedná o mnohdy zbytečnou komplikaci.</li>

<li>Přímý režim typicky vyžaduje klasickou &bdquo;pevnou&ldquo; vykreslovací pipeline, zatímco moderní GPU jsou plně programovatelné, takže &ndash; velmi stručně a nepřesně řečeno &ndash; vyžadují na vstupu jen datový tok se souřadnicemi popř.&nbsp;barvami, nikoli složitější strukturované údaje.</li>

</ul>



<p><a name="k03"></a></p>
<h2 id="k03">3. Techniky, které dokážou vyřešit některé nevýhody přímého režimu</h2>

<p>Volání každé funkce s&nbsp;sebou nese poměrně značné množství práce pro mikroprocesor, zejména přesun dat mezi registry procesoru, pamětí a zásobníkem a také skok do funkce a návrat z&nbsp;funkce (snížení účinnosti cache paměti z&nbsp;hlediska lokálnosti odkazů a přepínání mezi ringy). Proto by bylo vhodné co nejvíce snížit množství volání funkcí nutných pro vykreslení dané scény, ideálně použít například jen jediné volání funkce pro vykreslení každého tělesa, nezávisle na jeho složitosti. Existuje více možností vedoucích ke snížení počtu volaných funkcí, které se liší svou složitostí, vyjadřovací schopností (tj.&nbsp;které grafické efekty lze, popř.&nbsp;naopak nelze vytvořit) a rychlostí vlastního vykreslení:</p>

<p>Historicky nejstarší možností je použití takzvaných <i>display listů</i>, kdy se příkazy nutné pro vytvoření tělesa zapíšou do display listu a ten se poté zavolá pomocí jediné funkce. Výhodou tohoto postupu je, že data uložená v&nbsp;display listu jsou v&nbsp;ideálním případě zapsána přímo do paměti grafického akcelerátoru (záleží však na konkrétních podmínkách) a při každém vykreslení tedy není nutné tato data přenášet po sběrnici, což je v&nbsp;dnešní době (se současnými sběrnicemi a grafickými akcelerátory) nejvíce zpomalující operace (bottle neck) při vykreslování trojrozměrných scén.</p>

<p>Další možností je použití pole vrcholů (<i>vertex arrays</i>), kdy jsou data pro jednotlivé vrcholy uložena ve vhodně organizovaném poli a následně je umožněno poslání dat vrcholů pomocí několika málo funkčních volání. Výhodou tohoto přístupu je, že se mezi jednotlivými snímky mohou měnit data jednotlivých vrcholů (barva, poloha apod.), což v&nbsp;případě display listů nebylo možné, protože by se při jakékoliv změně musel vytvořit nový display list.</p>

<p>Z&nbsp;původních polí vrcholů se postupně vyvinuly takzvané <i>Vertex Buffer Object</i> mnohdy zkracované na <i>VBO</i>. Pole vrcholů jsou alokována v&nbsp;paměti grafického akcelerátoru, takže data v&nbsp;nich uložená jsou dostupná ještě před začátkem vykreslování celé scény, což je velmi důležité, neboť se celý proces vykreslování významným způsobem urychluje. V&nbsp;současnosti představují <i>VBO</i> prakticky nejrychlejší možnost, kterou nám klasické 3D akcelerátory nabízí. Navíc je možné data zpracovávat konfigurovatelnými shadery, což nebylo u přímého režimu možné.</p>



<p><a name="k04"></a></p>
<h2 id="k04">4. Display listy</h2>

<p>Display-listy si můžeme představit jako makra, do kterých se nahraje několik příkazů OpenGL, a tato makra lze potom jedním příkazem &bdquo;spustit&ldquo;. Výhodou display-listů je na jedné straně zvýšená rychlost vykreslování, protože display-listy jsou většinou uloženy přímo v&nbsp;paměti grafického akcelerátoru, na straně druhé také zjednodušení kódu pro vykreslování komplikovaných scén. Je například možné 3D modely jednotlivých těles ukládat do samostatných display-listů a složitou scénu potom vykreslit pouze zavoláním těchto display listů s&nbsp;vhodně nastavenou transformační maticí.</p>

<p>Začátek záznamu do display-listu se v&nbsp;grafické knihovně OpenGL povolí příkazem <strong>glNewList()</strong>, ukončení záznamu příkazem <strong>glEndList()</strong>. V&nbsp;příkazu <strong>glNewList(list, mode)</strong> zadáváme dva parametry. První celočíselný parametr list představuje identifikátor vytvořeného display-listu. Pomocí tohoto identifikátoru můžeme display-list vyvolat. Druhý parametr mode určuje, zda se má display-list pouze vytvořit (hodnota <strong>GL_COMPILE</strong>), nebo vytvořit a přímo provést (hodnota <strong>GL_COMPILE_AND_EXECUTE</strong>). Většina volání příkazů OpenGL (jsou však výjimky) je do display-listu zaznamenána, ostatní příkazy se samozřejmě provedou.</p>

<p>Provedení display-listu (tj.&nbsp;vyvolání příkazů uložených v&nbsp;display-listu) zajistíme funkcí <strong>glCallList(list)</strong>, v&nbsp;jejímž parametru list je uložen identifikátor dříve vytvořeného display-listu.</p>



<p><a name="k05"></a></p>
<h2 id="k05">5. Knihovna Pyglet a podpora takzvaných vertex listů</h2>

<p>Při použití multimediální knihovny Pyglet se nemusíme zabývat tím, jak bude vykreslování provedeno na nižší úrovni (tedy na úrovni volání funkcí OpenGL), protože Pyglet programátorům nabízí velmi užitečnou datovou abstrakci nazvanou příznačně <i>vertex list</i>. Tento název poměrně dobře odpovídá tomu, jak jsou vertex listy konstruovány &ndash; programátor musí při jejich vytváření (konstrukci) přesně specifikovat formát zapisovaných údajů, tj.&nbsp;které atributy jednotlivých vertexů (vrcholů) budou explicitně specifikovány a jaký budou mít formát. Mezi podporované atributy patří zejména souřadnice ve 2D ploše či v&nbsp;3D prostoru, texturovací souřadnice, barvy vrcholů a normálové vektory vrcholů. Následně se vykreslení celého vertex listu (ten může představovat například samostatné trojrozměrné těleso ve scéně) provede jediným příkazem. Specifikace dat pro vertex list je velmi flexibilní a poměrně jednoduchá, zejména v&nbsp;porovnání s&nbsp;<i>VBO</i> vytvářenými v&nbsp;jazycích typu C či C++. Některé možnosti vertex listů si představíme v&nbsp;demonstračních příkladech popsaných v&nbsp;navazujících kapitolách.</p>



<p><a name="k06"></a></p>
<h2 id="k06">6. Jednoduchý vertex list se souřadnicemi vrcholů ve 2D rovině či v&nbsp;3D prostoru</h2>

<p>Podívejme se, jak může být reprezentován jednoduchý vertex list s&nbsp;osmicí vrcholů ležících ve 2D rovině. Každý vrchol je v&nbsp;tomto případě reprezentován dvojicí číselných hodnot. Typicky se jedná o proměnné typu <i>float</i>. V&nbsp;takovém případě bude typ dat ve vertex listu reprezentován řetězcem &bdquo;v2f&ldquo;, kde písmeno <strong>v</strong> značí <i>vertex</i>, hodnota 2 počet čísel pro vertex (x a y) a konečně písmeno <strong>f</strong> značí <i>float</i>. Celý vertex list lze reprezentovat jako n-tici (konkrétně dvojici), jejímž prvním prvkem je řetězec s&nbsp;formátem a druhým prvkem n-tice se souřadnicemi:</p>

<pre>
('v2f', (-0.5, -0.5,
         -0.5, +0.5,
         +0.5, +0.5,
         +0.5, -0.5,
         +0.2, +0.2,
         -0.2, -0.2,
         -0.2, +0.2,
         +0.2, -0.2))
</pre>

<p>Pro vertex list s&nbsp;vrcholy v&nbsp;3D prostoru postačuje nepatrná úprava:</p>

<pre>
('v3f', (-0.5, -0.5, 0.0,
         -0.5, +0.5, 0.0,
         +0.5, +0.5, 0.0,
         +0.5, -0.5, 0.0,
         +0.2, +0.2, 10.0,
         -0.2, -0.2, 10.0,
         -0.2, +0.2, 10.0,
         +0.2, -0.2, 10.0))
</pre>



<p><a name="k07"></a></p>
<h2 id="k07">7. První demonstrační příklad &ndash; vykreslení 2D scény funkcí <strong>pyglet.graphics.draw</strong></h2>

<p>V&nbsp;dnešním prvním demonstračním příkladu je nejdříve vytvořen vertex list:</p>

<pre>
def prepare_scene():
    # seznamu vertexu
    # parametry:
    #     v2f - format: vertex se dvema souradnicemi typu 'float'
    #     ()  - n-tice s osmi vertexy (8x2 = 16 hodnot typu 'float')
    return ('v2f', (-0.5, -0.5,
                    -0.5, +0.5,
                    +0.5, +0.5,
                    +0.5, -0.5,
                    +0.2, +0.2,
                    -0.2, -0.2,
                    -0.2, +0.2,
                    +0.2, -0.2))
</pre>

<a href="https://mojefedora.cz/wp-content/uploads/2017/07/01.png"><img class="alignnone size-thumbnail wp-image-9379" src="https://mojefedora.cz/wp-content/uploads/2017/07/01-243x254.png" alt="" width="243" height="254" /></a>
<p><i>Obrázek 1: První demonstrační příklad používající entity <strong>GL_LINES</strong>.</i></p>

<p>Ten je následně vykreslen, a to konkrétně funkcí <strong>pyglet.graphics.draw</strong>, které se předá jak samotný vertex list, tak i počet vrcholů a typ grafické entity, která se má vykreslit (v&nbsp;samotné vertex listu tato informace není uložena):</p>

<pre>
def draw_scene():
    global vertex_list
    # prime vykresleni ctyr usecek, kazda je reprezentovana dvojici vertexu
    pyglet.graphics.draw(8, GL_LINES, vertex_list)
</pre>

<p>Připomeňme si, že při vykreslování úseček (<strong>GL_LINES</strong>) je nutné pro každou úsečku specifikovat dva vrcholy (vertexy), což znamená, že se v&nbsp;našem konkrétním případě vykreslí jen čtyři úsečky.</p>

<a href="https://mojefedora.cz/wp-content/uploads/2017/07/02-1.png"><img class="alignnone size-thumbnail wp-image-9380" src="https://mojefedora.cz/wp-content/uploads/2017/07/02-1-243x254.png" alt="" width="243" height="254" /></a>
<p><i>Obrázek 2: První demonstrační příklad používající entity <strong>GL_LINE_STRIP</strong>.</i></p>

<p>Úplný zdrojový kód tohoto příkladu vypadá následovně:</p>

<pre>
#!/usr/bin/env python

import pyglet
from pyglet.gl import *
from pyglet.window import key

nearPlane = 0.1                            # blizsi orezavaci rovina
farPlane = 90.0                            # vzdalenejsi orezavaci rovina

window = pyglet.window.Window(width=500,
                              height=500,
                              caption="Pyglet library")

keys = key.KeyStateHandler()
window.push_handlers(keys)


def init():
    glClearColor(0.0, 0.0, 0.3, 0.0)       # barva pozadi obrazku


@window.event
def on_resize(width, height):
    init()
    glViewport(0, 0, width, height)        # viditelna oblast pres cele okno


def prepare_scene():
    # seznamu vertexu
    # parametry:
    #     v2f - format: vertex se dvema souradnicemi typu 'float'
    #     ()  - n-tice s osmi vertexy (8x2 = 16 hodnot typu 'float')
    return ('v2f', (-0.5, -0.5,
                    -0.5, +0.5,
                    +0.5, +0.5,
                    +0.5, -0.5,
                    +0.2, +0.2,
                    -0.2, -0.2,
                    -0.2, +0.2,
                    +0.2, -0.2))


def draw_scene():
    global vertex_list
    # prime vykresleni ctyr usecek, kazda je reprezentovana dvojici vertexu
    pyglet.graphics.draw(8, GL_LINES, vertex_list)


def clear_buffers():
    # vymazani vsech bitovych rovin barvoveho bufferu
    glClear(GL_COLOR_BUFFER_BIT)


def set_projection_matrix(nearPlane, farPlane):
    # zacatek modifikace projekcni matice
    glMatrixMode(GL_PROJECTION)
    # vymazani projekcni matice (=identita)
    glLoadIdentity()


def set_modelview_matrix():
    glMatrixMode(GL_MODELVIEW)
    glLoadIdentity()                       # nahrat jednotkovou matici


@window.event
def on_draw():
    clear_buffers()
    set_projection_matrix(nearPlane, farPlane)
    set_modelview_matrix()
    draw_scene()                    # vykresleni sceny


vertex_list = prepare_scene()
pyglet.app.run()
</pre>

<a href="https://mojefedora.cz/wp-content/uploads/2017/07/03-1.png"><img class="alignnone size-thumbnail wp-image-9381" src="https://mojefedora.cz/wp-content/uploads/2017/07/03-1-243x254.png" alt="" width="243" height="254" /></a>
<p><i>Obrázek 3: První demonstrační příklad používající entity <strong>GL_LINE_LOOP</strong>.</i></p>



<p><a name="k08"></a></p>
<h2 id="k08">8. Konstruktor <strong>pyglet.graphics.vertex_list</strong> a metoda <strong>pyglet.graphics.vertexdomain.VertexList.draw</strong></h2>

<p>Předchozí demonstrační příklad sice skutečně používal vertex list, ovšem nikoli optimálním způsobem. Problém spočívá v&nbsp;tom, že se při každém vykreslení musí vertex list znovu zpracovávat, zatímco by bylo výhodnější provést jeho konstrukci jen jedenkrát a poté ho již jednoduše vykreslit. I tento způsob je samozřejmě v&nbsp;knihovně Pyglet podporovaný. Vertex list se zkonstruuje, zkonvertuje a případně i optimalizuje pomocí konstruktoru <strong>pyglet.graphics.vertex_list</strong>. Tomuto konstruktoru je nutné předat n-tici, konkrétně dvojici, přičemž v&nbsp;prvním prvku dvojice je uložen počet vertexů a druhý prvek obsahuje specifikaci vertex listu ve formátu, který jsme si popsali <a href="#k06">v&nbsp;šesté kapitole</a>. Funkce pro vytvoření vertex listu tedy může vypadat následovně:</p>

<pre>
def prepare_scene():
    # priprava seznamu vertexu
    # parametry:
    #     8   - pocet vertexu
    #     v2f - format: vertex se dvema souradnicemi typu 'float'
    #     ()  - n-tice s osmi vertexy (8x2 = 16 hodnot typu 'float')
    return pyglet.graphics.vertex_list(8, ('v2f', (-0.5, -0.5,
                                                   -0.5, +0.5,
                                                   +0.5, +0.5,
                                                   +0.5, -0.5,
                                                   +0.2, +0.2,
                                                   -0.2, -0.2,
                                                   -0.2, +0.2,
                                                   +0.2, -0.2)))
</pre>

<p>Takto vytvořený vertex list se vykreslí metodou <strong>draw()</strong>, které se pouze předá typ vykreslované entity. V&nbsp;našem případě se budou vykreslovat úsečky, takže této metodě předáme konstantu <strong>GL_LINES</strong>:</p>

<pre>
def draw_scene():
    global vertex_list
    # vykresleni ctyr usecek, data o useckach jsou ulozeny ve vertex listu
    vertex_list.draw(GL_LINES)
</pre>



<p><a name="k09"></a></p>
<h2 id="k09">9. Druhý demonstrační příklad &ndash; vykreslení 2D scény metodou <strong>pyglet.graphics.vertexdomain.VertexList.draw</strong></h2>

<p>V&nbsp;dnešním druhém demonstračním příkladu jsou použity obě funkce <strong>prepare_scene()</strong> a <strong>draw_scene()</strong>, které byly popsány <a href="#k08">v&nbsp;předchozí kapitole</a>. Podívejme se nyní na úplný zdrojový kód tohoto příkladu:</p>

<pre>
#!/usr/bin/env python

import pyglet
from pyglet.gl import *
from pyglet.window import key

nearPlane = 0.1                            # blizsi orezavaci rovina
farPlane = 90.0                            # vzdalenejsi orezavaci rovina

window = pyglet.window.Window(width=500,
                              height=500,
                              caption="Pyglet library")

keys = key.KeyStateHandler()
window.push_handlers(keys)


def init():
    glClearColor(0.0, 0.0, 0.3, 0.0)       # barva pozadi obrazku


@window.event
def on_resize(width, height):
    init()
    glViewport(0, 0, width, height)        # viditelna oblast pres cele okno


def prepare_scene():
    # priprava seznamu vertexu
    # parametry:
    #     8   - pocet vertexu
    #     v2f - format: vertex se dvema souradnicemi typu 'float'
    #     ()  - n-tice s osmi vertexy (8x2 = 16 hodnot typu 'float')
    return pyglet.graphics.vertex_list(8, ('v2f', (-0.5, -0.5,
                                                   -0.5, +0.5,
                                                   +0.5, +0.5,
                                                   +0.5, -0.5,
                                                   +0.2, +0.2,
                                                   -0.2, -0.2,
                                                   -0.2, +0.2,
                                                   +0.2, -0.2)))


def draw_scene():
    global vertex_list
    # vykresleni ctyr usecek, data o useckach jsou ulozeny ve vertex listu
    vertex_list.draw(GL_LINES)


def clear_buffers():
    # vymazani vsech bitovych rovin barvoveho bufferu
    glClear(GL_COLOR_BUFFER_BIT)


def set_projection_matrix(nearPlane, farPlane):
    # zacatek modifikace projekcni matice
    glMatrixMode(GL_PROJECTION)
    # vymazani projekcni matice (=identita)
    glLoadIdentity()


def set_modelview_matrix():
    glMatrixMode(GL_MODELVIEW)
    glLoadIdentity()                       # nahrat jednotkovou matici


@window.event
def on_draw():
    clear_buffers()
    set_projection_matrix(nearPlane, farPlane)
    set_modelview_matrix()
    draw_scene()                    # vykresleni sceny


vertex_list = prepare_scene()
pyglet.app.run()
</pre>

<a href="https://mojefedora.cz/wp-content/uploads/2017/07/04-1.png"><img class="alignnone size-thumbnail wp-image-9382" src="https://mojefedora.cz/wp-content/uploads/2017/07/04-1-243x254.png" alt="" width="243" height="254" /></a>
<p><i>Obrázek 4: Druhý demonstrační příklad vykresluje stejnou scénu, jako příklad první.</i></p>



<p><a name="k10"></a></p>
<h2 id="k10">10. Specifikace formátu dat uložených do vertex listu</h2>

<p>Při konstrukci vertex listu se formát zadává řetězcem, který je typicky složen ze tří znaků:</p>

<table>
<tr><th>Pozice znaku</th><th>Význam</th></tr>
<tr><td>1</td><td>typ grafických údajů</td></tr>
<tr><td>2</td><td>počet datových složek</td></tr>
<tr><td>3</td><td>datový typ</td></tr>
</table>

<p>Typ grafických údajů:</p>

<table>
<tr><th>Znak</th><th>Význam</th></tr>
<tr><td>v</td><td>souřadnice vertexu (typicky 2, 3 či 4 souřadnice)</td></tr>
<tr><td>n</td><td>normálový vektor (typicky 3 souřadnice)</td></tr>
<tr><td>t</td><td>souřadnice v&nbsp;prostoře textury</td></tr>
<tr><td>c</td><td>barva vertexu</td></tr>
<tr><td>s</td><td>sekundární barva</td></tr>
<tr><td>e</td><td>příznak přiřazený hraně (jak se bude vykreslovat)</td></tr>
<tr><td>f</td><td>souřadnice použitá při výpočtu mlhy (pokud je mlha povolena)</td></tr>
</table>

<p>Druhý znak jen specifikuje počet složek, takže pro 3D souřadnice zde bude uložena hodnota 3 atd.</p>

<p>Ve třetím znaku je specifikován datový typ každé složky grafického údaje:</p>

<table>
<tr><th>Znak</th><th>Význam (odpovídající typ OpenGL)</th></tr>
<tr><td>b</td><td>GLbyte</td></tr>
<tr><td>B</td><td>GLubyte</td></tr>
<tr><td>s</td><td>GLshort</td></tr>
<tr><td>S</td><td>GLushort</td></tr>
<tr><td>i</td><td>GLint</td></tr>
<tr><td>I</td><td>GLuint</td></tr>
<tr><td>f</td><td>GLfloat</td></tr>
<tr><td>d</td><td>GLdouble</td></tr>
</table>



<p><a name="k11"></a></p>
<h2 id="k11">11. Kombinace více typů informací o vrcholech (souřadnice, barvy, texturovací souřadnice...)</h2>

<p>Při konstrukci vertex listu s&nbsp;využitím konstruktoru <strong>pyglet.graphics.vertex_list</strong> je možné v&nbsp;jediném vertex listu zkombinovat větší množství informací o vertexech. Pokud například budeme chtít, aby každý vrchol (koncový bod) vykreslovaných úseček mohl mít odlišnou barvu, lze vertex list vytvořit nikoli z&nbsp;dvojice, ale z&nbsp;trojice prvků. První prvek opět obsahuje počet vertexů, druhý prvek může obsahovat souřadnice vertexů (8&times;2 hodnoty typu <i>float</i>) a třetí prvek pak barvy vrcholů (8&times;3 hodnoty typu <i>bajt</i>):</p>

<pre>
(8, ('v2f', (-0.5, -0.5,
             -0.5, +0.5,
             +0.5, +0.5,
             +0.5, -0.5,
             +0.2, +0.2,
             -0.2, -0.2,
             -0.2, +0.2,
             +0.2, -0.2)),
    ('c3B', (0xff, 0x00, 0xff,
             0xff, 0xff, 0x00,
             0x00, 0x00, 0xff,
             0x00, 0xff, 0x00,
             0x00, 0xff, 0xff,
             0xff, 0x00, 0xff,
             0x00, 0xff, 0xff,
             0xff, 0xff, 0x00)),)
</pre>

<p>Korektní počet prvků je zkontrolován po spuštění a pokud například zapomeneme zadat 8x3 barvových složek R, G, B, vyvolá se (runtime) výjimka:</p>

<pre>
ValueError: Can only assign sequence of same size
</pre>



<p><a name="k12"></a></p>
<h2 id="k12">12. Třetí demonstrační příklad &ndash; vertex list se souřadnicemi a současně i barvami vrcholů</h2>

<p>Ve třetím demonstračním příkladu využijeme <a href="#k11">výše uvedený</a> vertex list s&nbsp;koncovými vrcholy úseček, přičemž každý koncový bod bude mít odlišnou barvu. Při vykreslování úseček provede grafický akcelerátor interpolaci barvy, takže vznikne jednoduchý barevný gradient:</p>

<a href="https://mojefedora.cz/wp-content/uploads/2017/07/05-1.png"><img class="alignnone size-thumbnail wp-image-9383" src="https://mojefedora.cz/wp-content/uploads/2017/07/05-1-243x254.png" alt="" width="243" height="254" /></a>
<p><i>Obrázek 5: Třetí demonstrační příklad s&nbsp;barvovým gradientem.</i></p>

<p>Následuje výpis zdrojového kódu tohoto demonstračního příkladu:</p>

<pre>
#!/usr/bin/env python

import pyglet
from pyglet.gl import *
from pyglet.window import key

nearPlane = 0.1                            # blizsi orezavaci rovina
farPlane = 90.0                            # vzdalenejsi orezavaci rovina

window = pyglet.window.Window(width=500,
                              height=500,
                              caption="Pyglet library")

keys = key.KeyStateHandler()
window.push_handlers(keys)


def init():
    glClearColor(0.0, 0.0, 0.3, 0.0)       # barva pozadi obrazku


@window.event
def on_resize(width, height):
    init()
    glViewport(0, 0, width, height)        # viditelna oblast pres cele okno


def prepare_scene():
    # priprava seznamu vertexu
    # parametry:
    #     8   - pocet vertexu
    #     v2f - format: vertex se dvema souradnicemi typu 'float'
    #     ()  - n-tice s osmi vertexy (8x2 = 16 hodnot typu 'float')
    #     c3b - format: barva se tremi slozkami typu 'byte'
    #     ()  - n-tice s osmi barvami (8x3 = 24 hodnot typu 'byte')
    return pyglet.graphics.vertex_list(8, ('v2f', (-0.5, -0.5,
                                                   -0.5, +0.5,
                                                   +0.5, +0.5,
                                                   +0.5, -0.5,
                                                   +0.2, +0.2,
                                                   -0.2, -0.2,
                                                   -0.2, +0.2,
                                                   +0.2, -0.2)),
                                          ('c3B', (0xff, 0x00, 0xff,
                                                   0xff, 0xff, 0x00,
                                                   0x00, 0x00, 0xff,
                                                   0x00, 0xff, 0x00,
                                                   0x00, 0xff, 0xff,
                                                   0xff, 0x00, 0xff,
                                                   0x00, 0xff, 0xff,
                                                   0xff, 0xff, 0x00)))


def draw_scene():
    global vertex_list
    # vykresleni ctyr usecek, data o useckach jsou ulozeny ve vertex listu
    vertex_list.draw(GL_LINES)


def clear_buffers():
    # vymazani vsech bitovych rovin barvoveho bufferu
    glClear(GL_COLOR_BUFFER_BIT)


def set_projection_matrix(nearPlane, farPlane):
    # zacatek modifikace projekcni matice
    glMatrixMode(GL_PROJECTION)
    # vymazani projekcni matice (=identita)
    glLoadIdentity()


def set_modelview_matrix():
    glMatrixMode(GL_MODELVIEW)
    glLoadIdentity()                       # nahrat jednotkovou matici


@window.event
def on_draw():
    clear_buffers()
    set_projection_matrix(nearPlane, farPlane)
    set_modelview_matrix()
    draw_scene()                    # vykresleni sceny


vertex_list = prepare_scene()
pyglet.app.run()
</pre>



<p><a name="k13"></a></p>
<h2 id="k13">13. Interní struktura objektu typu <strong>pyglet.graphics.vertexdomain.VertexList</strong></h2>

<p>Po své konstrukci může objekt <a href="http://pyglet.readthedocs.io/en/pyglet-1.2-maintenance/api/pyglet/graphics/vertexdomain/pyglet.graphics.vertexdomain.VertexList.html">VertexList</a> obsahovat tyto atributy:</p>

<table>
<tr><th>Atribut</th><th>Význam</th></tr>
<tr><td>vertices</td><td>samotné souřadnice vertexů (pole)</td></tr>
<tr><td>normals</td><td>pole normálových vektorů</td></tr>
<tr><td>tex_coords</td><td>pole souřadnic v&nbsp;prostoru textur</td></tr>
<tr><td>colors</td><td>pole barev vertexů</td></tr>
<tr><td>secondary_colors</td><td>pole sekundárních barev</td></tr>
<tr><td>edge_flags</td><td>pole příznaků vykreslování hran</td></tr>
<tr><td>fog_coords</td><td>pole souřadnic použitých při výpočtu mlhy</td></tr>
<tr><td>multi_tex_coords</td><td>pole používané ve chvíli, kdy se používá větší množství textur</td></tr>
</table>



<p><a name="k14"></a></p>
<h2 id="k14">14. Čtvrtý demonstrační příklad &ndash; výpis atributů vytvořeného vertex listu</h2>

<p>Ve čtvrtém demonstračním příkladu je vytvořen vertex list a následně je vypsána jeho interní struktura funkcemi popsanými <a href="#k13">v&nbsp;předchozí kapitole</a>:</p>

<pre>
#!/usr/bin/env python

import pyglet


def prepare_scene():
    # priprava seznamu vertexu
    # parametry:
    #     8   - pocet vertexu
    #     v2f - format: vertex se dvema souradnicemi typu 'float'
    #     ()  - n-tice s osmi vertexy (8x2 = 16 hodnot typu 'float')
    #     c3b - format: barva se tremi slozkami typu 'byte'
    #     ()  - n-tice s osmi barvami (8x3 = 24 hodnot typu 'byte')
    return pyglet.graphics.vertex_list(8, ('v2f', (-0.5, -0.5,
                                                   -0.5, +0.5,
                                                   +0.5, +0.5,
                                                   +0.5, -0.5,
                                                   +0.2, +0.2,
                                                   -0.2, -0.2,
                                                   -0.2, +0.2,
                                                   +0.2, -0.2)),
                                          ('c3B', (0xff, 0x00, 0xff,
                                                   0xff, 0xff, 0x00,
                                                   0x00, 0x00, 0xff,
                                                   0x00, 0xff, 0x00,
                                                   0x00, 0xff, 0xff,
                                                   0xff, 0x00, 0xff,
                                                   0x00, 0xff, 0xff,
                                                   0xff, 0xff, 0x00)))


def print_array(name, array):
    print(name)
    print("   type: %s" % type(array))
    print("   length: %d" % len(array))
    print("   content:")
    for element in array:
        print("        %6.1f" % element)


vertex_list = prepare_scene()

print("Vertex list size: %d" % vertex_list.get_size())
print_array("Colors:", vertex_list.colors)
print_array("Vertices:", vertex_list.vertices)
</pre>

<p>Po spuštění příkladu by se měly na standardní výstup vypsat tyto řádky:</p>

<pre>
Vertex list size: 8
Colors:
   type: &lt;class 'pyglet.graphics.vertexattribute.c_ubyte_Array_24'&gt;
   length: 24
   content:
         255.0
           0.0
         255.0
         255.0
         255.0
           0.0
           0.0
           0.0
         255.0
           0.0
         255.0
           0.0
           0.0
         255.0
         255.0
         255.0
           0.0
         255.0
           0.0
         255.0
         255.0
         255.0
         255.0
           0.0
Vertices:
   type: &lt;class 'pyglet.graphics.vertexattribute.c_float_Array_16'&gt;
   length: 16
   content:
          -0.5
          -0.5
          -0.5
           0.5
           0.5
           0.5
           0.5
          -0.5
           0.2
           0.2
          -0.2
          -0.2
          -0.2
           0.2
           0.2
          -0.2
</pre>



<p><a name="k15"></a></p>
<h2 id="k15">15. Pátý demonstrační příklad &ndash; složitější vertex list s&nbsp;více údaji o vrcholech</h2>

<p>Pátý příklad se do značné míry podobá příkladu čtvrtému, ovšem s&nbsp;tím rozdílem, že vertex list obsahuje čtyři typy údajů &ndash; souřadnice vrcholů, texturovací souřadnice, normálový vektor každého vertexu a konečně barvu každého vertexu:</p>

<pre>
#!/usr/bin/env python

import pyglet


def prepare_scene():
    # priprava seznamu vertexu
    # parametry:
    #     8   - pocet vertexu
    #     v2i - format: vertex se dvema souradnicemi typu 'int'
    #     ()  - n-tice s osmi vertexy (8x2 = 16 hodnot typu 'int')
    #     t2f - format: souradnice v texturovacim prostoru se dvema
    #           souradnicemi typu 'float'
    #     ()  - n-tice s osmi souradnicemi (8x2 = 16 hodnot typu 'float')
    #     n3f - format: normalovy vektor se slozkami typu 'float'
    #     ()  - n-tice s osmi barvami (8x3 = 24 hodnot typu 'float')
    #     c3b - format: barva se tremi slozkami typu 'byte'
    #     ()  - n-tice s osmi barvami (8x3 = 24 hodnot typu 'byte')
    return pyglet.graphics.vertex_list(8, ('v2i', (-50, -50,
                                                   -50, +50,
                                                   +50, +50,
                                                   +50, -50,
                                                   +20, +20,
                                                   -20, -20,
                                                   -20, +20,
                                                   +20, -20)),
                                          ('t2f', (0.0, 0.0,
                                                   1.0, 0.0,
                                                   0.0, 1.0,
                                                   1.0, 1.0,
                                                   0.0, 0.0,
                                                   1.0, 0.0,
                                                   0.0, 1.0,
                                                   1.0, 1.0)),
                                          ('n3f', (0.0, 0.0, 1.0,
                                                   1.0, 0.0, 0.0,
                                                   0.0, 1.0, 0.0,
                                                   1.0, 1.0, 0.0,
                                                   0.0, 0.0, 1.0,
                                                   1.0, 0.0, 0.0,
                                                   0.0, 1.0, 0.0,
                                                   1.0, 1.0, 0.0)),
                                          ('c3B', (0xff, 0x00, 0xff,
                                                   0xff, 0xff, 0x00,
                                                   0x00, 0x00, 0xff,
                                                   0x00, 0xff, 0x00,
                                                   0x00, 0xff, 0xff,
                                                   0xff, 0x00, 0xff,
                                                   0x00, 0xff, 0xff,
                                                   0xff, 0xff, 0x00)))


def print_array(name, array):
    print(name)
    print("   type: %s" % type(array))
    print("   length: %d" % len(array))
    print("   content:")
    for element in array:
        print("        %6.1f" % element)


vertex_list = prepare_scene()

print("Vertex list size: %d" % vertex_list.get_size())
print_array("Colors:", vertex_list.colors)
print_array("Vertices:", vertex_list.vertices)
print_array("Tex.cords:", vertex_list.tex_coords)
print_array("Normals:", vertex_list.normals)
</pre>

<p>Po spuštění příkladu by se měly na standardní výstup vypsat tyto řádky:</p>

<pre>
Vertex list size: 8
Colors:
   type: &lt;class 'pyglet.graphics.vertexattribute.c_ubyte_Array_24'&gt;
   length: 24
   content:
         255.0
           0.0
         255.0
         255.0
         255.0
           0.0
           0.0
           0.0
         255.0
           0.0
         255.0
           0.0
           0.0
         255.0
         255.0
         255.0
           0.0
         255.0
           0.0
         255.0
         255.0
         255.0
         255.0
           0.0
Vertices:
   type: &lt;class 'pyglet.graphics.vertexattribute.c_int_Array_16'&gt;
   length: 16
   content:
         -50.0
         -50.0
         -50.0
          50.0
          50.0
          50.0
          50.0
         -50.0
          20.0
          20.0
         -20.0
         -20.0
         -20.0
          20.0
          20.0
         -20.0
Tex.cords:
   type: &lt;class 'pyglet.graphics.vertexattribute.c_float_Array_16'&gt;
   length: 16
   content:
           0.0
           0.0
           1.0
           0.0
           0.0
           1.0
           1.0
           1.0
           0.0
           0.0
           1.0
           0.0
           0.0
           1.0
           1.0
           1.0
Normals:
   type: &lt;class 'pyglet.graphics.vertexattribute.c_float_Array_24'&gt;
   length: 24
   content:
           0.0
           0.0
           1.0
           1.0
           0.0
           0.0
           0.0
           1.0
           0.0
           1.0
           1.0
           0.0
           0.0
           0.0
           1.0
           1.0
           0.0
           0.0
           0.0
           1.0
           0.0
           1.0
           1.0
           0.0
</pre>



<p><a name="k16"></a></p>
<h2 id="k16">16. Repositář s&nbsp;demonstračními příklady</h2>

<p>Všechny dnes popsané demonstrační příklady byly uloženy do Git repositáře dostupného na adrese <a href="https://github.com/tisnik/presentations">https://github.com/tisnik/presentations</a>. Příklady si můžete v&nbsp;případě potřeby stáhnout i jednotlivě bez nutnosti klonovat celý repositář. Pro jejich spuštění je nutné mít nainstalovanou jak knihovnu Pyglet, tak i podpůrné grafické knihovny OpenGL a GLU (což se většinou provede automaticky v&nbsp;rámci instalace balíčku s&nbsp;Pygletem, viz též <a href="https://mojefedora.cz/multimedialni-knihovna-pyglet/">úvodní díl tohoto seriálu</a>):</p>

<table>
<tr><th>Příklad</th><th>Odkaz</th></tr>
<tr><td>64_draw_list_immediatelly.py</td><td><a href="https://github.com/tisnik/presentations/blob/master/pyglet/64_draw_list_immediatelly.py">https://github.com/tisnik/presentations/blob/master/pyglet/64_draw_list_immediatelly.py</a></td></tr>
<tr><td>65_vertex_list.py</td><td><a href="https://github.com/tisnik/presentations/blob/master/pyglet/65_vertex_list.py">https://github.com/tisnik/presentations/blob/master/pyglet/65_vertex_list.py</a></td></tr>
<tr><td>66_vertex_color_list.py</td><td><a href="https://github.com/tisnik/presentations/blob/master/pyglet/66_vertex_color_list.py">https://github.com/tisnik/presentations/blob/master/pyglet/66_vertex_color_list.py</a></td></tr>
<tr><td>67_vertex_list_attributes.py</td><td><a href="https://github.com/tisnik/presentations/blob/master/pyglet/67_vertex_list_attributes.py">https://github.com/tisnik/presentations/blob/master/pyglet/67_vertex_list_attributes.py</a></td></tr>
<tr><td>68_vertex_list_attributes_2.py</td><td><a href="https://github.com/tisnik/presentations/blob/master/pyglet/68_vertex_list_attributes_2.py">https://github.com/tisnik/presentations/blob/master/pyglet/68_vertex_list_attributes_2.py</a></td></tr>
</table>



<p><a name="k17"></a></p>
<h2 id="k17">17. Odkazy na Internetu</h2>

<ol>

<li>Class pyglet.graphics.vertexdomain.VertexList<br />
<a href="https://pythonhosted.org/pyglet/api/pyglet.graphics.vertexdomain.VertexList-class.html">https://pythonhosted.org/pyglet/api/pyglet.graphics.vertexdomain.VertexList-class.html</a>
</li>

<li>Class pyglet.graphics.vertexdomain.VertexDomain<br />
<a href="https://pythonhosted.org/pyglet/api/pyglet.graphics.vertexdomain.VertexDomain-class.html">https://pythonhosted.org/pyglet/api/pyglet.graphics.vertexdomain.VertexDomain-class.html</a>
</li>

<li>Pyglet: Module Hierarchy<br />
<a href="https://pythonhosted.org/pyglet/api/module-tree.html">https://pythonhosted.org/pyglet/api/module-tree.html</a>
</li>

<li>Learning Modern OpenGL<br />
<a href="https://www.codeproject.com/articles/771225/learning-modern-opengl">https://www.codeproject.com/articles/771225/learning-modern-opengl</a>
</li>

<li>OpenGL Utility Library<br />
<a href="https://en.wikipedia.org/wiki/OpenGL_Utility_Library">https://en.wikipedia.org/wiki/OpenGL_Utility_Library</a>
</li>

<li>GLU Specification<br />
<a href="https://www.opengl.org/registry/doc/glu1.3.pdf">https://www.opengl.org/registry/doc/glu1.3.pdf</a>
</li>

<li>The Perlin noise math FAQ<br />
<a href="https://mzucker.github.io/html/perlin-noise-math-faq.html">https://mzucker.github.io/html/perlin-noise-math-faq.html</a>
</li>

<li>Perlin noise<br />
<a href="https://en.wikipedia.org/wiki/Perlin_noise">https://en.wikipedia.org/wiki/Perlin_noise</a>
</li>

<li>Perlin Noise Generator (Python recipe)<br />
<a href="http://code.activestate.com/recipes/578470-perlin-noise-generator/">http://code.activestate.com/recipes/578470-perlin-noise-generator/</a>
</li>

<li>Simplex noise demystified<br />
<a href="http://www.itn.liu.se/~stegu/simplexnoise/simplexnoise.pdf">http://www.itn.liu.se/~stegu/simplexnoise/simplexnoise.pdf</a>
</li>

<li>glTexEnv - příkaz OpenGL<br />
<a href="https://www.khronos.org/registry/OpenGL-Refpages/gl2.1/xhtml/glTexEnv.xml">https://www.khronos.org/registry/OpenGL-Refpages/gl2.1/xhtml/glTexEnv.xml</a>
</li>

<li>glGetTexEnv - příkaz OpenGL<br />
<a href="https://www.khronos.org/registry/OpenGL-Refpages/gl2.1/xhtml/glGetTexEnv.xml">https://www.khronos.org/registry/OpenGL-Refpages/gl2.1/xhtml/glGetTexEnv.xml</a>
</li>

<li>Pyglet Home Page<br />
<a href="https://bitbucket.org/pyglet/pyglet/wiki/Home">https://bitbucket.org/pyglet/pyglet/wiki/Home</a>
</li>

<li>Pyglet: dokumentace k verzi 1.2<br />
<a href="https://pyglet.readthedocs.io/en/pyglet-1.2-maintenance/">https://pyglet.readthedocs.io/en/pyglet-1.2-maintenance/</a>
</li>

<li>Dokumentace k verzi 1.2 ve formátu PDF<br />
<a href="https://readthedocs.org/projects/pyglet/downloads/pdf/pyglet-1.2-maintenance/">https://readthedocs.org/projects/pyglet/downloads/pdf/pyglet-1.2-maintenance/</a>
</li>

<li>PyOpenGL<br />
<a href="http://pyopengl.sourceforge.net/">http://pyopengl.sourceforge.net/</a>
</li>

<li>The #! magic, details about the shebang/hash-bang mechanism on various Unix flavours<br />
<a href="https://www.in-ulm.de/~mascheck/various/shebang/">https://www.in-ulm.de/~mascheck/various/shebang/</a>
</li>

<li>Shebang (Unix)<br />
<a href="https://en.wikipedia.org/wiki/Shebang_%28Unix%29">https://en.wikipedia.org/wiki/Shebang_%28Unix%29</a>
</li>

<li>Domovská stránka systému LÖVE<br />
<a href="http://love2d.org/">http://love2d.org/</a>
</li>

<li>Simple DirectMedia Layer (home page)<br />
<a href="http://www.libsdl.org/">http://www.libsdl.org/</a>
</li>

<li>Simple DirectMedia Layer (Wikipedia)<br />
<a href="https://en.wikipedia.org/wiki/Simple_DirectMedia_Layer">https://en.wikipedia.org/wiki/Simple_DirectMedia_Layer</a>
</li>

<li>Seriál Grafická knihovna OpenGL<br />
<a href="https://www.root.cz/serialy/graficka-knihovna-opengl/">https://www.root.cz/serialy/graficka-knihovna-opengl/</a>
</li>

<li>Pyglet event loop<br />
<a href="http://pyglet.readthedocs.io/en/latest/programming_guide/eventloop.html">http://pyglet.readthedocs.io/en/latest/programming_guide/eventloop.html</a>
</li>

<li>Decorators I: Introduction to Python Decorators<br />
<a href="http://www.artima.com/weblogs/viewpost.jsp?thread=240808">http://www.artima.com/weblogs/viewpost.jsp?thread=240808</a>
</li>

<li>3D Programming in Python - Part 1 <br />
<a href="https://greendalecs.wordpress.com/2012/04/21/3d-programming-in-python-part-1/">https://greendalecs.wordpress.com/2012/04/21/3d-programming-in-python-part-1/</a>
</li>

<li>A very basic Pyglet tutorial<br />
<a href="http://www.natan.termitnjak.net/tutorials/pyglet_basic.html">http://www.natan.termitnjak.net/tutorials/pyglet_basic.html</a>
</li>

<li>Alpha blending<br />
<a href="https://en.wikipedia.org/wiki/Alpha_compositing#Alpha_blending">https://en.wikipedia.org/wiki/Alpha_compositing#Alpha_blending</a>
</li>

</ol>



<p></p><p></p>
<p><small>Autor: <a href="http://www.fit.vutbr.cz/~tisnovpa">Pavel TiĹĄnovskĂ˝</a> &nbsp; 2017</small></p>
</body>
</html>

