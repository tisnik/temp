<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
        "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html>
<head>
<title>Multimediální knihovna Pyglet: textury a texturování při vykreslování trojrozměrných scén</title>
<meta name="Author" content="Pavel Tisnovsky" />
<meta name="Generator" content="vim" />
<meta http-equiv="content-type" content="text/html; charset=utf-8" />
<style type="text/css">
         body {color:#000000; background:#ffffff;}
         h1  {font-family: arial, helvetica, sans-serif; color:#ffffff; background-color:#c00000; text-align:center; padding-left:1em}
         h2  {font-family: arial, helvetica, sans-serif; color:#ffffff; background-color:#0000c0; padding-left:1em; text-align:left}
         h3  {font-family: arial, helvetica, sans-serif; color:#000000; background-color:#c0c0c0; padding-left:1em; text-align:left}
         h4  {font-family: arial, helvetica, sans-serif; color:#000000; background-color:#e0e0e0; padding-left:1em; text-align:left}
         a   {font-family: arial, helvetica, sans-serif;}
         li  {font-family: arial, helvetica, sans-serif; color:#000000; text-align:justify; width:450px;}
         ol  {font-family: arial, helvetica, sans-serif; color:#000000; text-align:justify; width:450px;}
         ul  {font-family: arial, helvetica, sans-serif; color:#000000; text-align:justify; width:450px;}
         p   {font-family: arial, helvetica, sans-serif; color:#000000; text-align:justify;}
         pre {background:#e0e0e0}
</style>
</head>

<body>

<h1>Multimediální knihovna Pyglet: textury a texturování při vykreslování trojrozměrných scén</h1>

<h3>Pavel Tišnovský</h3>

<p></p>

<h1>Úvodník</h1>

<p>V&nbsp;sedmé části seriálu o multimediální knihovně Pyglet si na několika demonstračních příkladech ukážeme, jakým způsobem je možné na zobrazovaná 2D i 3D tělesa nanášet rastrové textury. K&nbsp;tomu využijeme kombinaci funkcí nabízených přímo knihovnou Pyglet a nepřímo grafickou knihovnou OpenGL.</p>



<h2>Obsah</h2>

<p><a href="#k01">1. Použití textur v&nbsp;knihovně Pyglet</a></p>
<p><a href="#k02">2. Textury reprezentované rastrovými obrázky</a></p>
<p><a href="#k03">3. Kdy a proč používat texturování?</a></p>
<p><a href="#k04">4. Podpora pro práci s&nbsp;texturami v&nbsp;knihovnách OpenGL a Pyglet</a></p>
<p><a href="#k05">5. Postup při použití textur ve skriptech používajících knihovnu Pyglet</a></p>
<p><a href="#k06">6. Načtení textury z&nbsp;externího souboru</a></p>
<p><a href="#k07">7. Nastavení parametrů textur a povolení texturování</a></p>
<p><a href="#k08">8. Specifikace souřadnic v&nbsp;prostoru textury</a></p>
<p><a href="#k09">9. První demonstrační příklad: převod rastrového obrázku na texturu</a></p>
<p><a href="#k10">10. Nastavování parametrů textur</a></p>
<p><a href="#k11">11. Druhý demonstrační příklad: nastavení způsobu opakování textur</a></p>
<p><a href="#k12">12. Třetí demonstrační příklad: zrcadlení textur při opakování vzorku</a></p>
<p><a href="#k13">13. Chování texturovacího engine při přibližování a vzdalování textur</a></p>
<p><a href="#k14">14. Čtvrtý demonstrační příklad: výběr nejbližšího texelu</a></p>
<p><a href="#k15">15. Pátý demonstrační příklad: použití bilineárního filtru</a></p>
<p><a href="#k16">16. Repositář s&nbsp;demonstračními příklady</a></p>
<p><a href="#k17">17. Odkazy na Internetu</a></p>



<p><a name="k01"></a></p>
<h2 id="k01">1. Použití textur v&nbsp;knihovně Pyglet</h2>

<p>Texturováním (resp.&nbsp;přesněji řečeno nanášením či promítáním textur) se označuje princip obarvení povrchu zobrazovaných (většinou trojrozměrných) těles různými obrazci. Důležité přitom je, že se nijak nemění geometrické vlastnosti těles, pouze se jinak zobrazuje jejich povrch. Obrazce, které se na povrch těles nanášejí, se nazývají <i>textury</i> (<i>textures</i>). Tyto textury jsou většinou představovány plošnými obrázky (dvoudimenzionální textury), některé grafické systémy však podporují i vykreslování jednorozměrných textur (barevné přechody) a dokonce trojrozměrných (objemových) textur.</p>

<p>Obrazce pro textury se mohou vytvářet několika způsoby. Buď je možné použít klasické rastrové obrázky (vzniklé například namalováním, vyfocením nebo naskenováním), nebo se textura může vytvářet pomocí různých algoritmů založených většinou na fraktálních technikách &ndash; tímto způsobem vznikají takzvané <i>procedurální textury</i>. Procedurální textury lze použít buď pro výpočet rastrových obrázků před vlastním vykreslováním (po výpočtu obrázku se tato textura chová jako každý jiný rastrový obrázek se všemi výhodami i nevýhodami), nebo se může výpočet textur provádět v&nbsp;reálném čase až při vykreslování, přičemž se parametry výpočtu textury nastaví podle aktuální velikosti a orientace plošky, na kterou se textura nanáší. Tuto druhou možnost však knihovna OpenGL a tím pádem nepřímo ani multimediální knihovna Pyglet přímo nepodporuje; výpočet procedurálních textur je tedy nutné provádět &bdquo;ručně&ldquo;. Na prvním obrázku je ukázána procedurální textura vzniklá sloučením více fraktálních obrazců s&nbsp;procedurální texturou mramoru (mramor, marble).</p>

<a href="https://mojefedora.cz/wp-content/uploads/2017/05/01-1.png"><img class="alignnone size-full wp-image-8974" src="https://mojefedora.cz/wp-content/uploads/2017/05/01-1.png" alt="" width="160" height="160" /></a>
<p><i>Obrázek 1: Ukázka procedurální textury.</i></p>



<p><a name="k02"></a></p>
<h2 id="k02">2. Textury reprezentované rastrovými obrázky</h2>

<p>V&nbsp;dalším textu se budeme téměř výhradně zabývat texturami reprezentovanými rastrovými obrázky, nezávisle na tom, jakým způsobem vznikly. I když řeč bude převážně o dvoudimenzionálních texturách (tedy bitmapách a či v&nbsp;řeči knihovny OpenGL pixmapách), většina zde popisovaných vlastností se vztahuje i na jednorozměrné a trojrozměrné textury. Případné výjimky a odlišnosti si samozřejmě postupně popíšeme. Na druhém obrázku je ukázána dvoudimenzionální, &bdquo;ručně&ldquo; nakreslená textura. Rastrové textury budeme v&nbsp;demonstračních příkladech vyrábět buď programově (různé šachovnice apod.), nebo je budeme načítat z&nbsp;externích souborů, k&nbsp;čemuž použijeme již známé funkce nabízené knihovnou Pyglet.</p>

<a href="https://mojefedora.cz/wp-content/uploads/2017/05/02-1.png"><img class="alignnone size-thumbnail wp-image-8975" src="https://mojefedora.cz/wp-content/uploads/2017/05/02-1.png" alt="" width="230" height="230" /></a>
<p><i>Obrázek 2: Ukázka nakreslené rastrové textury.</i></p>

<p>Podobně, jako je bitmapa či pixmapa složena ze základních rastrových elementů (<i>pixelů</i>), je textura složena z&nbsp;takzvaných <i>texelů</i>. Pixel a texel mají stejné vlastnosti a podobný či dokonce ekvivalentní způsob uložení v&nbsp;paměti. V&nbsp;dalším textu však budeme oba pojmy navzájem oddělovat, tj.&nbsp;pixel je element vykreslovaný na obrazovce, kdežto texel je rastrový element (většinou) dvourozměrné textury. Texturování potom spočívá v&nbsp;nanášení texelů na vykreslovaný povrch.</p>



<p><a name="k03"></a></p>
<h2 id="k03">3. Kdy a proč používat texturování?</h2>

<p>Texturu je možné použít ve všech případech, kdy je nutné vykreslovat tělesa se složitě strukturovanými povrchy, která však nevykazují velké změny v&nbsp;geometrii (tedy tvaru) povrchu. Typickým příkladem je cihlová zeď, která je v&nbsp;reálném světě složená z&nbsp;jednotlivých cihel spojených maltou. Při modelování této zdi sice můžeme každou cihlu reprezentovat například kvádrem s&nbsp;vhodně zvolenou barvou, ale v&nbsp;případě vykreslování velkých zdí by počet zpracovávaných těles rostl příliš rychle, takže by se zbytečně plýtvalo jak pamětí, tak i výpočetním výkonem grafického subsystému. Ještě horší situace by nastala například u koberce, kde by bylo nutné vytvářet všechna barevná vlákna apod.</p>

<p>V&nbsp;těchto případech je možné zeď nebo koberec reprezentovat jednou plochou (složenou například ze dvou trojúhelníků nebo jednoho čtyřúhelníku) a na tuto plochu potom nanést předem vytvořený rastrový obrázek. V&nbsp;případě zdi se tak sice připravíme o geometrické nerovnosti povrchu (ty lze částečně &ndash; při vhodném natočení tělesa &ndash; simulovat například takzvaným <i>bump-mappingem</i>), ale vykreslení bude na dnešních počítačích dostatečně rychlé a v&nbsp;případě dostatečné velikosti (rozlišení) textury i kvalitní.</p>

<p>Textury se také někdy používají poněkud jiným způsobem pro vytváření a následné vykreslení různých složitých modelů, například stromů. Buď je možné strom namodelovat jako těleso obsahující až několik tisíc polygonů, nebo je možné vytvořit dvourozměrný obrázek stromu z&nbsp;několika směrů a strom vykreslit jako několik vzájemně se protínajících ploch s&nbsp;nanesenou konturou stromu. V&nbsp;tomto případě však textura musí být v&nbsp;některých místech průhledná, což ovšem při vykreslování nepředstavuje větší problém. Tato technika se nazývá <i>billboarding</i>, protože se vychází z&nbsp;podobnosti s&nbsp;klasickými billboardy (například ty u dálnic).</p>

<a href="https://mojefedora.cz/wp-content/uploads/2017/05/03-1.png"><img class="alignnone size-thumbnail wp-image-8976" src="https://mojefedora.cz/wp-content/uploads/2017/05/03-1-268x254.png" alt="" width="268" height="254" /></a>
<p><i>Obrázek 3: Vytvoření modelu stromu (billboardu) s využitím texturování.</i></p>

<p>V&nbsp;minulosti se často také používaly otexturované objekty (většinou obdélníky), které byly k&nbsp;pozorovateli natočeny vždy stejnou stranou. Tyto objekty se nazývají <i>sprity</i> a byly použity zejména v&nbsp;mnoha úspěšných hrách, například Doom, pro vykreslování předmětů a potvůrek ve hře. Sprity samozřejmě můžeme používat i v&nbsp;OpenGL, lze například vykreslovat pixmapy nebo vhodně natočený obdélník pokrytý texturou (jak již víme, Pyglet pro ně má přímou podporu). Texturování může být v&nbsp;tomto případě výhodnější, protože se (na rozdíl od vykreslování pixmap) nemusí stále přenášet pixmapová data po sběrnici/portu, ale jsou uložena přímo v&nbsp;paměti grafického akcelerátoru.</p>

<a href="https://mojefedora.cz/wp-content/uploads/2017/05/04-1.png"><img class="alignnone size-thumbnail wp-image-8977" src="https://mojefedora.cz/wp-content/uploads/2017/05/04-1-406x254.png" alt="" width="406" height="254" /></a>
<p><i>Obrázek 4: Ukázka 3D scény s několika sprity (snad nemusím psát, odkud ten screenshot pochází).</i></p>



<p><a name="k04"></a></p>
<h2 id="k04">4. Podpora pro práci s&nbsp;texturami v&nbsp;knihovnách OpenGL a Pyglet</h2>

<p>V&nbsp;knihovně OpenGL a tím pádem i v&nbsp;knihovně Pyglet jsou podporovány pouze rastrové textury, které mohou být buď jednodimenzionální, dvoudimenzionální, nebo třídimenzionální. V&nbsp;případě jednodimenzionálních textur se prakticky jedná o pruh pixelů, pomocí něhož se dají realizovat různé barevné přechody. Dvoudimenzionální textury (rastrové bitmapy a pixmapy) jsou v&nbsp;dnešní době zdaleka nejpoužívanější a jsou podporovány na naprosté většině grafických akcelerátorů (dokonce bych napsal na všech, protože jsem zatím nezažil, že by texturování nefungovalo; veškeré chyby texturování spočívají buď v&nbsp;nedostatku paměti pro textury, nebo v&nbsp;chybě ovladače/driveru, který musí textury přenášet přes port do grafického akcelerátoru).</p>

<p>Třídimenzionální textury (tj.&nbsp;objemové či takzvané voxelové textury) se používají především ve specializovaných aplikacích (medicína apod.), kdy je potřeba zobrazovat objemová data. Větší podporu tohoto typu textur můžeme očekávat až v&nbsp;dalších generacích grafických akcelerátorů, protože pro uložení dat prostorových textur je zapotřebí velkého množství paměti, která současně musí být dostatečně rychlá pro čtení.</p>

<p>Největší podpora ze strany grafických akcelerátorů je tedy u dvoudimenzionálních textur, které také splňují značnou část nároků programátora počítačové grafiky. Především tímto typem textur se budeme zabývat v&nbsp;dalším textu.</p>

<p>V&nbsp;OpenGL lze také zvolit různé filtrace textur, režimy mapování textur na plošky, multitexturování a další grafické efekty, které si dále probereme. Musíme si však uvědomit, že pokud použijeme některý grafický efekt, který není grafickým akcelerátorem podporován, dojde k&nbsp;výpočtům pomocí hlavního procesoru počítače, což značně zpomaluje celý systém (dnes je to spíše neobvyklá situace). Proto je nejprve vhodné zjistit, které efekty jsou na grafickém akcelerátoru podporovány, a případně dát uživateli naší aplikace na výběr mezi kvalitou a rychlostí zobrazení.</p>

<p>Knihovna Pyglet taktéž podporuje práci s&nbsp;texturami, protože umožňuje načíst rastrový obrázek (to již známe) a převést ho na objekt reprezentující dvourozměrnou texturu. Právě tuto funkcionalitu využijeme v&nbsp;demonstračních příkladech.</p>



<p><a name="k05"></a></p>
<h2 id="k05">5. Postup při použití textur ve skriptech používajících knihovnu Pyglet</h2>

<p>Vykreslování objektů s&nbsp;nanesenou texturou vyžaduje provést několik vzájemně provázaných kroků:</p>

<ol>
<li>Vytvoření rastrové předlohy textury nebo její načtení ze souboru. K&nbsp;tomu lze využít funkce nabízené knihovnou Pyglet.</li>
<li>Vytvoření nového texturovacího objektu, přiřazení textury tomuto objektu a nastavení formátu textury. Poslední část není nutno provést explicitně, to za nás opět zajistí knihovna Pyglet.</li>
<li>Nastavení způsobu nanášení textury na vykreslované povrchy.</li>
<li>Zapnutí (povolení) nanášení textur.</li>
<li>Vykreslení scény se zadanými texturovacími souřadnicemi pro každý vrchol.</li>
</ol>



<p><a name="k06"></a></p>
<h2 id="k06">6. Načtení textury z&nbsp;externího souboru</h2>

<p>Načtení textury z&nbsp;externího souboru je ve skutečnosti velmi snadné, protože můžeme využít nám již známé funkce poskytované knihovnou Pyglet. Nejprve otevřeme soubor s&nbsp;rastrovým obrázkem, dále obrázek načteme a nakonec &ndash; což je nový krok &ndash; s&nbsp;využitím metody <strong>get_texture()</strong> získáme z&nbsp;rastrového obrázku kýženou texturu:</p>

<pre>
import pyglet

image_stream = open("gnome-globe.png", "rb")
image = pyglet.image.load('gnome-globe.png', file=image_stream)
texture = <strong>image.get_texture()</strong>
</pre>

<p>Poznámka: v&nbsp;posledním kroku může docházet k&nbsp;nuceným konverzím bitmapy, proto tuto operaci proveďte pouze jedenkrát při inicializaci aplikace, nikoli uvnitř <i>event loopu</i>.</p>



<p><a name="k07"></a></p>
<h2 id="k07">7. Nastavení parametrů textur a povolení texturování</h2>

<p>V&nbsp;knihovně OpenGL a nepřímo tedy i v&nbsp;Pygletu je možné parametry textur, tj.&nbsp;například způsob, jakým je textura mapována na povrch vykreslovaného tělesa, nastavit voláním funkce:</p>

<pre>
void glTexParameterf(
    GLenum  target,
    GLenum  pname,
    GLfloat value
);
</pre>

<p>popř.&nbsp;funkce:</p>

<pre>
void glTexParameteri(
    GLenum target,
    GLenum pname,
    GLint  value
);
</pre>

<p>V&nbsp;případě volání funkcí Pygletu z&nbsp;programovacího jazyka Python se samozřejmě nemusíme zabývat explicitní specifikací typu parametrů, takže obě výše zmíněné funkce vypadají zhruba následovně:</p>

<pre>
def glTexParameterf(
    target,
    pname,
    value)
</pre>

<pre>
def glTexParameteri(
    target,
    pname,
    value)
</pre>

<p>První parametr (nazvaný <strong>target</strong>) může podle zvolené dimenze textury nabývat hodnot <strong>GL_TEXTURE_1D</strong> (jednodimenzionální textura, tj.&nbsp;barevný přechod, nepoužijeme), <strong>GL_TEXTURE_2D</strong> (nejběžnější, rastrová textura) nebo <strong>GL_TEXTURE_3D</strong> (objemová textura, taktéž nepoužijeme). Hodnoty dalších dvou parametrů nazvaných <strong>pname</strong> a <strong>value</strong> jsou uvedeny v&nbsp;následující tabulce:</p>

<table>
<tr><th>Parametr</th><th>Význam</th></tr>
<tr><td>GL_TEXTURE_WRAP_S</td><td>tímto parametrem specifikujeme, zda se má při překročení rozsahu texturovací souřadnice ve směru osy <i>s</i> provést opakování motivu na textuře nebo &bdquo;protažení&ldquo; první či poslední hodnoty. Opakování motivu na textuře je vhodné použít v&nbsp;případech, kdy zobrazujeme různé na sebe navazující motivy, například cihlové zdi, podlahy apod. Protažením textury lze v&nbsp;některých případech zamezit vizuálním artefaktům, které by se mohly objevit při napojování textur. Překročení rozsahu tedy není v&nbsp;žádném případě chybou.</td></tr>
<tr><td>GL_TEXTURE_WRAP_T</td><td>tento parametr má podobný význam jako parametr předchozí s&nbsp;tím rozdílem, že se místo na souřadnici ve směru osy <i>s</i> vztahuje na souřadnici ve směru osy <i>t</i>. U 1D textur nemá hodnota tohoto parametru vliv na zobrazení textury, použitelný je pouze u 2D a 3D textur.</td></tr>
<tr><td>GL_TEXTURE_WRAP_R</td><td>tento parametr má opět podobný význam jako předchozí dva parametry, ale vztahuje se na třetí souřadnici <i>r</i>, která je použita například u objemových textur. U jednorozměrných ani u dvourozměrných textur nemá tento parametr žádný význam.</td></tr>
<tr><td>GL_TEXTURE_MIN_FILTER</td><td>tímto parametrem je možné zvolit filtr použitý při zmenšování textury, tj.&nbsp;tehdy, jestliže na plochu jednoho vykreslovaného pixelu musíme použít barvy několika sousedních texelů.</td></tr>
<tr><td>GL_TEXTURE_MAX_FILTER</td><td>tímto parametrem se volí filtr použitý při zvětšování textury, tj.&nbsp;v případě, že vykreslovaný pixel obsahuje pouze malou plochu texelu.</td></tr>
</table>

<p>V&nbsp;další tabulce jsou uvedeny vztahy mezi parametry <strong>pname</strong> a <strong>value</strong>:</p>

<table>
<tr><th>Jméno parametru</th><th>Hodnota</th><th>Význam</th></tr>
<tr><td>GL_TEXTURE_WRAP_S</td><td>GL_REPEAT</td><td>opakování textury ve směru osy <i>s</i></td></tr>
<tr><td>GL_TEXTURE_WRAP_S</td><td>GL_CLAMP</td><td>protažení textury ve směru osy <i>s</i></td></tr>
<tr><td>GL_TEXTURE_WRAP_T</td><td>GL_REPEAT</td><td>opakování textury ve směru osy <i>t</i></td></tr>
<tr><td>GL_TEXTURE_WRAP_T</td><td>GL_CLAMP</td><td>protažení textury ve směru osy <i>t</i></td></tr>
<tr><td>GL_TEXTURE_WRAP_R</td><td>GL_REPEAT</td><td>opakování textury ve směru osy <i>r</i></td></tr>
<tr><td>GL_TEXTURE_WRAP_R</td><td>GL_CLAMP</td><td>protažení textury ve směru osy <i>r</i></td></tr>
<tr><td>GL_TEXTURE_MIN_FILTER</td><td>GL_NEAREST</td><td>nejjednodušší a nejrychlejší filtr, u tohoto filtru se barva vykreslovaného pixelu vypočte z&nbsp;barvy texelu, jehož souřadnice nejpřesněji odpovídají souřednicím zadaným do textury</td></tr>
<tr><td>GL_TEXTURE_MIN_FILTER</td><td>GL_LINEAR</td><td>sofistikovanější filtr, kdy se barva vykreslovaného pixelu spočítá pomocí bilineární interpolace z&nbsp;barev sousedních texelů</td></tr>
<tr><td>GL_TEXTURE_MIN_FILTER</td><td>GL_NEAREST_MIPMAP_NEAREST</td><td>sofistikovanější filtr, použití takzvaných mipmap</td></tr>
<tr><td>GL_TEXTURE_MIN_FILTER</td><td>GL_LINEAR_MIPMAP_NEAREST</td><td>sofistikovanější filtr, použití takzvaných mipmap</td></tr>
<tr><td>GL_TEXTURE_MIN_FILTER</td><td>GL_NEAREST_MIPMAP_LINEAR</td><td>sofistikovanější filtr, použití takzvaných mipmap</td></tr>
<tr><td>GL_TEXTURE_MAX_FILTER</td><td>GL_NEAREST</td><td>nejrychlejší způsob, použití nejbližšího texelu</td></tr>
<tr><td>GL_TEXTURE_MAX_FILTER</td><td>GL_LINEAR</td><td>použití lineárního či bilineárního filtru</td></tr>
</table>

<p>V&nbsp;prvním demonstračním příkladu, který bude uveden <a href="#k09">v&nbsp;deváté kapitole</a>, použijeme následující nastavení parametrů textury. Volání první funkce určuje způsob uložení (a dekódování) texelu v&nbsp;textuře:</p>

<pre>
glPixelStorei(GL_UNPACK_ALIGNMENT, 1)
glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_WRAP_S, GL_REPEAT)
glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_WRAP_T, GL_REPEAT)
glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MAG_FILTER, GL_NEAREST)
glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MIN_FILTER, GL_NEAREST)
</pre>

<p></p>

<pre>
glBindTexture(GL_TEXTURE_2D, texture.id)
</pre>

<p>Poslední krok je jednoduchý &ndash; pouze potřebujeme povolit texturování, tj.&nbsp;přepnout grafický akcelerátor do režimu, v&nbsp;němž texturovací jednotka grafického akcelerátoru pokrývá povrch těles jednotlivými texely:</p>

<pre>
glEnable(GL_TEXTURE_2D)
</pre>



<p><a name="k08"></a></p>
<h2 id="k08">8. Specifikace souřadnic v&nbsp;prostoru textury</h2>

<p>Vykreslení tělesa s&nbsp;otexturovanými stěnami probíhá podobně jako u&nbsp;barevných stěn. Jedinou změnou je, že pro každý vrchol musíme k&nbsp;jeho 2D/3D/4D souřadnicím navíc specifikovat souřadnice v&nbsp;textuře. Každá textura má nezávisle na své velikosti souřadnice v&nbsp;rozsahu od 0.0 do 1.0, což znamená, že 2D textura je chápána jako čtverec o straně délky 1. Souřadnice do textury však můžeme zadávat libovolně, protože díky opakování (pokud je zapnuto) se obrázek textury může na zobrazované stěně šachovnicově skládat, podobně jako například obrázky na pozadí HTML stránek. Otexturovaný čtyřúhelník lze specifikovat takto:</p>

<pre>
glBegin(GL_QUADS) 

glTexCoord2f(0.0, 0.0);
glVertex2i(x, y) 

glTexCoord2f(1.0, 0.0);
glVertex2i(x+150, y) 

glTexCoord2f(1.0, 1.0);
glVertex2i(x+150, y+150) 

glTexCoord2f(0.0, 1.0);
glVertex2i(x, y+150) 

glEnd() 
</pre>



<p><a name="k09"></a></p>
<h2 id="k09">9. První demonstrační příklad: převod rastrového obrázku na texturu</h2>

<p>V&nbsp;prvním demonstračním příkladu se provádí následující činnosti:</p>

<ol>
<li>Načte se rastrový obrázek s&nbsp;texturou.</li>
<li>Z&nbsp;obrázku se získá textura.</li>
<li>Nastaví se parametry textury.</li>
<li>Povolí se texturování a vykreslí se čtyřúhelník s&nbsp;nanesenou texturou.</li>
<li>Texturování se zakáže a vykreslí se jednobarevný čtyřúhelník.</li>
<li>Opět se povolí texturování a vykreslí se čtyřúhelník s&nbsp;nanesenou texturou.</li>
</ol>

<p>Načtení rastrového obrázku a získání textury:</p>

<pre>
image_stream = open("gnome-globe.png", "rb")
image = pyglet.image.load('gnome-globe.png', file=image_stream)
texture = image.get_texture()
</pre>

<p>Nastavení parametrů textury a navázání na konkrétní obrázek:</p>

<pre>
    glPixelStorei(GL_UNPACK_ALIGNMENT, 1)
    glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_WRAP_S, GL_REPEAT)
    glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_WRAP_T, GL_REPEAT)
    glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MAG_FILTER, GL_NEAREST)
    glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MIN_FILTER, GL_NEAREST)
    glBindTexture(GL_TEXTURE_2D, texture.id)
</pre>

<p>Vykreslení otexturovaného čtyřúhelníku, čtyřúhelníku s&nbsp;jednobarevným povrchem a dalšího otexturovaného čtyřúhelníku:</p>

<pre>
glEnable(GL_TEXTURE_2D)
draw_quad(50, 50) 

glDisable(GL_TEXTURE_2D)
draw_quad(210, 50) 

glEnable(GL_TEXTURE_2D)
draw_quad(410, 50) 
</pre>

<p>Samotná funkce pro vykreslení čtyřúhelníku vypadá takto:</p>

<pre>
def draw_quad(x, y):
    glBegin(GL_QUADS) 

    glTexCoord2f(0.0, 0.0);
    glVertex2i(x, y) 

    glTexCoord2f(1.0, 0.0);
    glVertex2i(x+150, y) 

    glTexCoord2f(1.0, 1.0);
    glVertex2i(x+150, y+150) 

    glTexCoord2f(0.0, 1.0);
    glVertex2i(x, y+150) 

    glEnd() 
</pre>

<p>Úplný zdrojový kód dnešního prvního demonstračního příkladu vypadá následovně:</p>

<pre>
#!/usr/bin/env python

import pyglet
from pyglet.gl import *

window = pyglet.window.Window(width=600,
                              height=250,
                              caption="Pyglet library")

image_stream = open("gnome-globe.png", "rb")
image = pyglet.image.load('gnome-globe.png', file=image_stream)
texture = image.get_texture()



def init():
    glClearColor(0.0, 0.0, 0.3, 0.0)          # barva pozadi obrazku
    glPolygonMode(GL_FRONT, GL_FILL)          # nastaveni rezimu vykresleni modelu
    glPolygonMode(GL_BACK, GL_FILL)
    glDisable(GL_CULL_FACE)                   # zadne hrany ani steny se nebudou odstranovat

    glPixelStorei(GL_UNPACK_ALIGNMENT, 1)
    glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_WRAP_S, GL_REPEAT)
    glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_WRAP_T, GL_REPEAT)
    glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MAG_FILTER, GL_NEAREST)
    glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MIN_FILTER, GL_NEAREST)
    glBindTexture(GL_TEXTURE_2D, texture.id)



@window.event
def on_resize(width, height):
    init()
    glViewport(0, 0, width, height)           # viditelna oblast pres cele okno



def draw_quad(x, y):
    glBegin(GL_QUADS) 

    glTexCoord2f(0.0, 0.0);
    glVertex2i(x, y) 

    glTexCoord2f(1.0, 0.0);
    glVertex2i(x+150, y) 

    glTexCoord2f(1.0, 1.0);
    glVertex2i(x+150, y+150) 

    glTexCoord2f(0.0, 1.0);
    glVertex2i(x, y+150) 

    glEnd() 


@window.event
def on_draw():
    glClear(GL_COLOR_BUFFER_BIT)              # vymazani vsech bitovych rovin barvoveho bufferu
    glLoadIdentity()
    glClearColor(0.0, 0.0, 0.0, 0.0)            # nastaveni mazaci barvy na cernou
    glClear(GL_COLOR_BUFFER_BIT)                # vymazani bitovych rovin barvoveho bufferu

    glEnable(GL_TEXTURE_2D)
    draw_quad(50, 50) 

    glDisable(GL_TEXTURE_2D)
    draw_quad(210, 50) 

    glEnable(GL_TEXTURE_2D)
    draw_quad(410, 50) 

pyglet.app.run()
</pre>

<a href="https://mojefedora.cz/wp-content/uploads/2017/05/05-3.png"><img class="alignnone size-thumbnail wp-image-8978" src="https://mojefedora.cz/wp-content/uploads/2017/05/05-3-558x254.png" alt="" width="558" height="254" /></a>
<p><i>Obrázek 5: Screenshot dnešního prvního demonstračního příkladu.</i></p>



<p><a name="k10"></a></p>
<h2 id="k10">10. Nastavování parametrů textur</h2>

<p>V&nbsp;následujících čtyřech demonstračních příkladech si ukážeme vliv parametrů textur na způsob jejich vykreslování. Obrázek u textur budeme opakovat, zrcadlit a textury budeme zvětšovat s&nbsp;využitím různých typů filtrů (bilineárního).</p>

<a href="https://mojefedora.cz/wp-content/uploads/2017/05/06-3.png"><img class="alignnone size-thumbnail wp-image-8979" src="https://mojefedora.cz/wp-content/uploads/2017/05/06-3-243x254.png" alt="" width="243" height="254" /></a>
<p><i>Obrázek 6: Textury nanesené na trojrozměrné těleso. Přes samotnou texturu prosvítá barva stěn.</i></p>



<p><a name="k11"></a></p>
<h2 id="k11">11. Druhý demonstrační příklad: nastavení způsobu opakování textur</h2>

<p>Ve druhém příkladu je nastaveno opakování obrázku s&nbsp;texturou:</p>

<pre>
glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_WRAP_S, GL_REPEAT)
glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_WRAP_T, GL_REPEAT)
</pre>

<p>To se projeví ve chvíli, kdy použijeme texturovací souřadnice mimo rozsah 0..1 (což je zcela legální). Tento kód například požaduje, aby se textura na stěně čtverce opakovala v&nbsp;šachovnici 2&times;2:</p>

<pre>
def draw_quad(x, y):
    glBegin(GL_QUADS) 

    glTexCoord2f(0.0, 0.0);
    glVertex2i(x, y) 

    glTexCoord2f(2.0, 0.0);
    glVertex2i(x+400, y) 

    glTexCoord2f(2.0, 2.0);
    glVertex2i(x+400, y+400) 

    glTexCoord2f(0.0, 2.0);
    glVertex2i(x, y+400) 

    glEnd() 
</pre>

<a href="https://mojefedora.cz/wp-content/uploads/2017/05/07-2.png"><img class="alignnone size-thumbnail wp-image-8980" src="https://mojefedora.cz/wp-content/uploads/2017/05/07-2-243x254.png" alt="" width="243" height="254" /></a>
<p><i>Obrázek 7: Screenshot dnešního druhého demonstračního příkladu. Povšimněte si, že se obrázek zeměkoule skutečně opakuje.</i></p>

<p>Úplný zdrojový kód tohoto demonstračního příkladu:</p>

<pre>
#!/usr/bin/env python

import pyglet
from pyglet.gl import *

window = pyglet.window.Window(width=500,
                              height=500,
                              caption="Pyglet library")

image_stream = open("gnome-globe.png", "rb")
image = pyglet.image.load('gnome-globe.png', file=image_stream)
texture = image.get_texture()



def init():
    glClearColor(0.0, 0.0, 0.3, 0.0)          # barva pozadi obrazku
    glPolygonMode(GL_FRONT, GL_FILL)          # nastaveni rezimu vykresleni modelu
    glPolygonMode(GL_BACK, GL_FILL)
    glDisable(GL_CULL_FACE)                   # zadne hrany ani steny se nebudou odstranovat

    glPixelStorei(GL_UNPACK_ALIGNMENT, 1)
    glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_WRAP_S, GL_REPEAT)
    glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_WRAP_T, GL_REPEAT)
    glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MAG_FILTER, GL_NEAREST)
    glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MIN_FILTER, GL_NEAREST)
    glBindTexture(GL_TEXTURE_2D, texture.id)



@window.event
def on_resize(width, height):
    init()
    glViewport(0, 0, width, height)           # viditelna oblast pres cele okno



def draw_quad(x, y):
    glBegin(GL_QUADS) 

    glTexCoord2f(0.0, 0.0);
    glVertex2i(x, y) 

    glTexCoord2f(2.0, 0.0);
    glVertex2i(x+400, y) 

    glTexCoord2f(2.0, 2.0);
    glVertex2i(x+400, y+400) 

    glTexCoord2f(0.0, 2.0);
    glVertex2i(x, y+400) 

    glEnd() 


@window.event
def on_draw():
    glClear(GL_COLOR_BUFFER_BIT)              # vymazani vsech bitovych rovin barvoveho bufferu
    glLoadIdentity()
    glClearColor(0.0, 0.0, 0.0, 0.0)            # nastaveni mazaci barvy na cernou
    glClear(GL_COLOR_BUFFER_BIT)                # vymazani bitovych rovin barvoveho bufferu

    glEnable(GL_TEXTURE_2D)
    draw_quad(50, 50) 

pyglet.app.run()
</pre>



<p><a name="k12"></a></p>
<h2 id="k12">12. Třetí demonstrační příklad: zrcadlení textur při opakování vzorku</h2>

<p>Zajímavé je zrcadlení textury, což se může hodit ve chvíli, kdy potřebujeme, aby na sebe vzorky textury plynule navazovaly. To je při zrcadlení samozřejmě vždy splněno:</p>

<pre>
glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_WRAP_S, GL_MIRRORED_REPEAT)
glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_WRAP_T, GL_MIRRORED_REPEAT)
</pre>

<a href="https://mojefedora.cz/wp-content/uploads/2017/05/08-3.png"><img class="alignnone size-thumbnail wp-image-8981" src="https://mojefedora.cz/wp-content/uploads/2017/05/08-3-243x254.png" alt="" width="243" height="254" /></a>
<p><i>Obrázek 8: Screenshot dnešního třetího demonstračního příkladu. Povšimněte si, že se obrázek zeměkoule opakuje, ovšem současně je zrcadlen.</i></p>

<p>Úplný zdrojový kód tohoto demonstračního příkladu:</p>

<pre>
#!/usr/bin/env python

import pyglet
from pyglet.gl import *

window = pyglet.window.Window(width=500,
                              height=500,
                              caption="Pyglet library")

image_stream = open("gnome-globe.png", "rb")
image = pyglet.image.load('gnome-globe.png', file=image_stream)
texture = image.get_texture()



def init():
    glClearColor(0.0, 0.0, 0.3, 0.0)          # barva pozadi obrazku
    glPolygonMode(GL_FRONT, GL_FILL)          # nastaveni rezimu vykresleni modelu
    glPolygonMode(GL_BACK, GL_FILL)
    glDisable(GL_CULL_FACE)                   # zadne hrany ani steny se nebudou odstranovat

    glPixelStorei(GL_UNPACK_ALIGNMENT, 1)
    glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_WRAP_S, GL_MIRRORED_REPEAT)
    glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_WRAP_T, GL_MIRRORED_REPEAT)
    glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MAG_FILTER, GL_NEAREST)
    glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MIN_FILTER, GL_NEAREST)
    glBindTexture(GL_TEXTURE_2D, texture.id)



@window.event
def on_resize(width, height):
    init()
    glViewport(0, 0, width, height)           # viditelna oblast pres cele okno



def draw_quad(x, y):
    glBegin(GL_QUADS) 

    glTexCoord2f(0.0, 0.0);
    glVertex2i(x, y) 

    glTexCoord2f(2.0, 0.0);
    glVertex2i(x+400, y) 

    glTexCoord2f(2.0, 2.0);
    glVertex2i(x+400, y+400) 

    glTexCoord2f(0.0, 2.0);
    glVertex2i(x, y+400) 

    glEnd() 


@window.event
def on_draw():
    glClear(GL_COLOR_BUFFER_BIT)              # vymazani vsech bitovych rovin barvoveho bufferu
    glLoadIdentity()
    glClearColor(0.0, 0.0, 0.0, 0.0)            # nastaveni mazaci barvy na cernou
    glClear(GL_COLOR_BUFFER_BIT)                # vymazani bitovych rovin barvoveho bufferu

    glEnable(GL_TEXTURE_2D)
    draw_quad(50, 50) 

pyglet.app.run()
</pre>



<p><a name="k13"></a></p>
<h2 id="k13">13. Chování texturovacího engine při přibližování a vzdalování textur</h2>

<p>Ve chvíli, kdy se kamera (pozorovatel) přibližuje k&nbsp;textuře, je nutné nějakým způsobem zajistit zvětšení texelů. To lze provést buď triviálně a velmi rychle namapováním texelů na povrch tělesa na základě nejbližšího texelu nebo sofistikovaněji s&nbsp;využitím takzvaného bilineárního filtru. Jak již víme <a href="#k07">z&nbsp;předchozího textu</a>, je možné toto nastavení provést přes funkci <strong>glTexParameteri()</strong>, kde jméno parametru je <strong>GL_TEXTURE_MAX_FILTER</strong> a možné hodnoty jsou <strong>GL_NEAREST</strong> (použije se nejbližší texel) nebo <strong>GL_LINEAR</strong> (použije se lineární interpolace mezi barvami sousedních texelů). Rozdíly v&nbsp;obou typech filtrů uvidíme na dvojici demonstračních příkladů:</p>

<a href="https://mojefedora.cz/wp-content/uploads/2017/05/09-3.png"><img class="alignnone size-thumbnail wp-image-8982" src="https://mojefedora.cz/wp-content/uploads/2017/05/09-3-243x254.png" alt="" width="243" height="254" /></a>
<p><i>Obrázek 9: Screenshot dnešního čtvrtého demonstračního příkladu při přiblížení textury.</i></p>

<a href="https://mojefedora.cz/wp-content/uploads/2017/05/10-3.png"><img class="alignnone size-thumbnail wp-image-8983" src="https://mojefedora.cz/wp-content/uploads/2017/05/10-3-243x254.png" alt="" width="243" height="254" /></a>
<p><i>Obrázek 10: Screenshot dnešního pátého demonstračního příkladu při přiblížení textury a použití takzvaného bilineárního filtru.</i></p>



<p><a name="k14"></a></p>
<h2 id="k14">14. Čtvrtý demonstrační příklad: výběr nejbližšího texelu</h2>

<p>Ve čtvrtém demonstračním příkladu se při přiblížení textury mapují na stěnu tělesa vždy nejbližší texely, takže vznikají charakteristické &bdquo;kostičky&ldquo;:</p>

<pre>
glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MAG_FILTER, GL_NEAREST)
</pre>

<p>Úplný zdrojový kód tohoto demonstračního příkladu:</p>

<pre>
#!/usr/bin/env python

import pyglet
from pyglet.gl import *

window = pyglet.window.Window(width=500,
                              height=500,
                              caption="Pyglet library")

image_stream = open("gnome-globe.png", "rb")
image = pyglet.image.load('gnome-globe.png', file=image_stream)
texture = image.get_texture()



def init():
    glClearColor(0.0, 0.0, 0.3, 0.0)          # barva pozadi obrazku
    glPolygonMode(GL_FRONT, GL_FILL)          # nastaveni rezimu vykresleni modelu
    glPolygonMode(GL_BACK, GL_FILL)
    glDisable(GL_CULL_FACE)                   # zadne hrany ani steny se nebudou odstranovat

    glPixelStorei(GL_UNPACK_ALIGNMENT, 1)
    glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MAG_FILTER, GL_NEAREST)
    glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MIN_FILTER, GL_NEAREST)
    glBindTexture(GL_TEXTURE_2D, texture.id)



@window.event
def on_resize(width, height):
    init()
    glViewport(0, 0, width, height)           # viditelna oblast pres cele okno



def draw_quad(x, y):
    glBegin(GL_QUADS) 

    glTexCoord2f(0.4, 0.4);
    glVertex2i(x, y) 

    glTexCoord2f(0.6, 0.4);
    glVertex2i(x+400, y) 

    glTexCoord2f(0.6, 0.6);
    glVertex2i(x+400, y+400) 

    glTexCoord2f(0.4, 0.6);
    glVertex2i(x, y+400) 

    glEnd() 


@window.event
def on_draw():
    glClear(GL_COLOR_BUFFER_BIT)              # vymazani vsech bitovych rovin barvoveho bufferu
    glLoadIdentity()
    glClearColor(0.0, 0.0, 0.0, 0.0)            # nastaveni mazaci barvy na cernou
    glClear(GL_COLOR_BUFFER_BIT)                # vymazani bitovych rovin barvoveho bufferu

    glEnable(GL_TEXTURE_2D)
    draw_quad(50, 50) 

pyglet.app.run()
</pre>



<p><a name="k15"></a></p>
<h2 id="k15">15. Pátý demonstrační příklad: použití bilineárního filtru</h2>

<p>V&nbsp;příkladu pátém se naproti tomu používá bilineární filtr, který vede k&nbsp;vizuálně lepším výsledkům, ovšem výpočet celé scény je pomalejší:</p>

<pre>
glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MAG_FILTER, GL_LINEAR)
</pre>

<p>Úplný zdrojový kód tohoto demonstračního příkladu:</p>

<pre>
#!/usr/bin/env python

import pyglet
from pyglet.gl import *

window = pyglet.window.Window(width=500,
                              height=500,
                              caption="Pyglet library")

image_stream = open("gnome-globe.png", "rb")
image = pyglet.image.load('gnome-globe.png', file=image_stream)
texture = image.get_texture()



def init():
    glClearColor(0.0, 0.0, 0.3, 0.0)          # barva pozadi obrazku
    glPolygonMode(GL_FRONT, GL_FILL)          # nastaveni rezimu vykresleni modelu
    glPolygonMode(GL_BACK, GL_FILL)
    glDisable(GL_CULL_FACE)                   # zadne hrany ani steny se nebudou odstranovat

    glPixelStorei(GL_UNPACK_ALIGNMENT, 1)
    glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MAG_FILTER, GL_LINEAR)
    glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MIN_FILTER, GL_LINEAR)
    glBindTexture(GL_TEXTURE_2D, texture.id)



@window.event
def on_resize(width, height):
    init()
    glViewport(0, 0, width, height)           # viditelna oblast pres cele okno



def draw_quad(x, y):
    glBegin(GL_QUADS) 

    glTexCoord2f(0.4, 0.4);
    glVertex2i(x, y) 

    glTexCoord2f(0.6, 0.4);
    glVertex2i(x+400, y) 

    glTexCoord2f(0.6, 0.6);
    glVertex2i(x+400, y+400) 

    glTexCoord2f(0.4, 0.6);
    glVertex2i(x, y+400) 

    glEnd() 


@window.event
def on_draw():
    glClear(GL_COLOR_BUFFER_BIT)              # vymazani vsech bitovych rovin barvoveho bufferu
    glLoadIdentity()
    glClearColor(0.0, 0.0, 0.0, 0.0)            # nastaveni mazaci barvy na cernou
    glClear(GL_COLOR_BUFFER_BIT)                # vymazani bitovych rovin barvoveho bufferu

    glEnable(GL_TEXTURE_2D)
    draw_quad(50, 50) 

pyglet.app.run()
</pre>



<p><a name="k16"></a></p>
<h2 id="k16">16. Repositář s&nbsp;demonstračními příklady</h2>

<p>Všechny dnes popsané demonstrační příklady byly uloženy do Git repositáře dostupného na adrese <a href="https://github.com/tisnik/presentations">https://github.com/tisnik/presentations</a>. Příklady si můžete v&nbsp;případě potřeby stáhnout i jednotlivě bez nutnosti klonovat celý repositář. Pro jejich spuštění je nutné mít nainstalovanou jak knihovnu Pyglet, tak i podpůrné grafické knihovny OpenGL a GLU (což se většinou provede automaticky v&nbsp;rámci instalace balíčku s&nbsp;Pygletem, viz též <a href="https://mojefedora.cz/multimedialni-knihovna-pyglet/">úvodní díl tohoto seriálu</a>):</p>

<table>
<tr><th>Příklad</th><th>Odkaz</th></tr>
<tr><td>36_textures.py</td><td><a href="https://github.com/tisnik/presentations/blob/master/pyglet/36_textures.py">https://github.com/tisnik/presentations/blob/master/pyglet/36_textures.py</a></td></tr>
<tr><td>37_texture_wrapping.py</td><td><a href="https://github.com/tisnik/presentations/blob/master/pyglet/37_texture_wrapping.py">https://github.com/tisnik/presentations/blob/master/pyglet/37_texture_wrapping.py</a></td></tr>
<tr><td>38_texture_mirror.py</td><td><a href="https://github.com/tisnik/presentations/blob/master/pyglet/38_texture_mirror.py">https://github.com/tisnik/presentations/blob/master/pyglet/38_texture_mirror.py</a></td></tr>
<tr><td>39_texture_magnification.py</td><td><a href="https://github.com/tisnik/presentations/blob/master/pyglet/39_texture_magnification.py">https://github.com/tisnik/presentations/blob/master/pyglet/39_texture_magnification.py</a></td></tr>
<tr><td>40_texture_smooth.py</td><td><a href="https://github.com/tisnik/presentations/blob/master/pyglet/40_texture_smooth.py">https://github.com/tisnik/presentations/blob/master/pyglet/40_texture_smooth.py</a></td></tr>
</table>

<p>Poznámka: všechny demonstrační příklady navíc vyžadují v&nbsp;aktuální adresáři přítomnost <a href="https://github.com/tisnik/presentations/blob/master/pyglet/gnome-globe.png">tohoto obrázku</a>, z&nbsp;něhož se textura vytváří.</p>



<p><a name="k17"></a></p>
<h2 id="k17">17. Odkazy na Internetu</h2>

<ol>

<li>Pyglet Home Page<br />
<a href="https://bitbucket.org/pyglet/pyglet/wiki/Home">https://bitbucket.org/pyglet/pyglet/wiki/Home</a>
</li>

<li>Dokumentace k verzi 1.2<br />
<a href="https://pyglet.readthedocs.io/en/pyglet-1.2-maintenance/">https://pyglet.readthedocs.io/en/pyglet-1.2-maintenance/</a>
</li>

<li>Dokumentace k verzi 1.2 ve formátu PDF<br />
<a href="https://readthedocs.org/projects/pyglet/downloads/pdf/pyglet-1.2-maintenance/">https://readthedocs.org/projects/pyglet/downloads/pdf/pyglet-1.2-maintenance/</a>
</li>

<li>PyOpenGL<br />
<a href="http://pyopengl.sourceforge.net/">http://pyopengl.sourceforge.net/</a>
</li>

<li>The #! magic, details about the shebang/hash-bang mechanism on various Unix flavours<br />
<a href="https://www.in-ulm.de/~mascheck/various/shebang/">https://www.in-ulm.de/~mascheck/various/shebang/</a>
</li>

<li>Shebang (Unix)<br />
<a href="https://en.wikipedia.org/wiki/Shebang_%28Unix%29">https://en.wikipedia.org/wiki/Shebang_%28Unix%29</a>
</li>

<li>Domovská stránka systému LÖVE<br />
<a href="http://love2d.org/">http://love2d.org/</a>
</li>

<li>Simple DirectMedia Layer (home page)<br />
<a href="http://www.libsdl.org/">http://www.libsdl.org/</a>
</li>

<li>Simple DirectMedia Layer (Wikipedia)<br />
<a href="https://en.wikipedia.org/wiki/Simple_DirectMedia_Layer">https://en.wikipedia.org/wiki/Simple_DirectMedia_Layer</a>
</li>

<li>Seriál Grafická knihovna OpenGL<br />
<a href="https://www.root.cz/serialy/graficka-knihovna-opengl/">https://www.root.cz/serialy/graficka-knihovna-opengl/</a>
</li>

<li>Pyglet event loop<br />
<a href="http://pyglet.readthedocs.io/en/latest/programming_guide/eventloop.html">http://pyglet.readthedocs.io/en/latest/programming_guide/eventloop.html</a>
</li>

<li>Decorators I: Introduction to Python Decorators<br />
<a href="http://www.artima.com/weblogs/viewpost.jsp?thread=240808">http://www.artima.com/weblogs/viewpost.jsp?thread=240808</a>
</li>

<li>3D Programming in Python - Part 1 <br />
<a href="https://greendalecs.wordpress.com/2012/04/21/3d-programming-in-python-part-1/">https://greendalecs.wordpress.com/2012/04/21/3d-programming-in-python-part-1/</a>
</li>

<li>A very basic Pyglet tutorial<br />
<a href="http://www.natan.termitnjak.net/tutorials/pyglet_basic.html">http://www.natan.termitnjak.net/tutorials/pyglet_basic.html</a>
</li>

<li>Alpha blending<br />
<a href="https://en.wikipedia.org/wiki/Alpha_compositing#Alpha_blending">https://en.wikipedia.org/wiki/Alpha_compositing#Alpha_blending</a>
</li>

</ol>



<p></p><p></p>
<p><small>Autor: <a href="http://www.fit.vutbr.cz/~tisnovpa">Pavel Tišnovský</a> &nbsp; 2017</small></p>
</body>
</html>

