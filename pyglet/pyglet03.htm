<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
        "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html>
<head>
<title>Multimediální knihovna Pyglet: zobrazení prostorové scény</title>
<meta name="Author" content="Pavel Tisnovsky" />
<meta name="Generator" content="vim" />
<meta http-equiv="content-type" content="text/html; charset=utf-8" />
<style type="text/css">
         body {color:#000000; background:#ffffff;}
         h1  {font-family: arial, helvetica, sans-serif; color:#ffffff; background-color:#c00000; text-align:center; padding-left:1em}
         h2  {font-family: arial, helvetica, sans-serif; color:#ffffff; background-color:#0000c0; padding-left:1em; text-align:left}
         h3  {font-family: arial, helvetica, sans-serif; color:#000000; background-color:#c0c0c0; padding-left:1em; text-align:left}
         h4  {font-family: arial, helvetica, sans-serif; color:#000000; background-color:#e0e0e0; padding-left:1em; text-align:left}
         a   {font-family: arial, helvetica, sans-serif;}
         li  {font-family: arial, helvetica, sans-serif; color:#000000; text-align:justify; width:450px;}
         ol  {font-family: arial, helvetica, sans-serif; color:#000000; text-align:justify; width:450px;}
         ul  {font-family: arial, helvetica, sans-serif; color:#000000; text-align:justify; width:450px;}
         p   {font-family: arial, helvetica, sans-serif; color:#000000; text-align:justify;}
         pre {background:#e0e0e0}
</style>
</head>

<body>

<h1>Multimediální knihovna Pyglet: zobrazení prostorové scény</h1>

<h3>Pavel Tišnovský</h3>

<p></p>

<h1>Úvodník</h1>

<p>Ve třetí části seriálu o multimediální knihovně <i>Pyglet</i> si ukážeme dva způsoby zobrazení prostorových (3D) scén, přičemž samotné vykreslování bude prováděno přes grafickou knihovnu OpenGL.</p>



<h2>Obsah</h2>

<p><a href="#k01">1. Multimediální knihovna Pyglet: zobrazení prostorové scény</a></p>
<p><a href="#k02">2. Nastavení kamery sledující prostorovou scénu</a></p>
<p><a href="#k03">3. Pomocné funkce z&nbsp;GLU (OpenGL Utilities)</a></p>
<p><a href="#k04">4. Scéna snímaná ortografickou kamerou</a></p>
<p><a href="#k05">5. Funkce <strong>glOrtho()</strong> a <strong>gluLookAt()</strong></a></p>
<p><a href="#k06">6. Změna transformačních matic a nastavení aktuální transformační matice</a></p>
<p><a href="#k07">7. První demonstrační příklad: scéna snímaná ortografickou kamerou</a></p>
<p><a href="#k08">8. Skládání transformací</a></p>
<p><a href="#k09">9. Druhý demonstrační příklad: otáčení objektem ve scéně</a></p>
<p><a href="#k10">10. Scéna snímaná kamerou s&nbsp;perspektivou</a></p>
<p><a href="#k11">11. Základní funkce pro nastavení kamery v&nbsp;perspektivním režimu</a></p>
<p><a href="#k12">12. Třetí demonstrační příklad: perspektivní kamera</a></p>
<p><a href="#k13">13. Repositář s&nbsp;demonstračními příklady</a></p>
<p><a href="#k14">14. Seznam dnes popsaných funkcí knihovny OpenGL a GLU</a></p>
<p><a href="#k15">15. Odkazy na Internetu</a></p>



<p><a name="k01"></a></p>
<h2 id="k01">1. Multimediální knihovna Pyglet: zobrazení prostorové scény</h2>

<p>Ve třetí části seriálu o multimediální knihovně <i>Pyglet</i> si ukážeme dva způsoby zobrazení prostorových (3D) scén, přičemž samotné vykreslování bude prováděno přes grafickou knihovnu OpenGL. Při zobrazení prostorové scény musíme vyřešit dva základní problémy. Prvním problémem je zadání údajů o scéně (tj.&nbsp;geometrických a vizuálních údajů o prostorových tělesech, které jsou v&nbsp;ní umístěny), druhým problémem je nastavení kamery neboli pozorovatele, kterou se na scénu díváme, tak, aby byla korektně zobrazena požadovaná část scény. To vyžaduje určitou dávku prostorové představivosti, protože při prvních pokusech se kamera pravděpodobně bude &bdquo;dívat&ldquo; mimo oblast, v&nbsp;níž se nachází tělesa.</p>

<p>První problém je možné pro jednoduché scény řešit triviálně: tělesa ve scéně rozložíme na jednodušší části, které lze reprezentovat pomocí grafických primitiv popsaných <a href="https://mojefedora.cz/multimedialni-knihovna-pyglet-volani-funkci-opengl/#k03">minule</a>. U trojrozměrných scén musíme pro každý vrchol (<i>vertex</i>) grafického primitiva zadat minimálně jeho souřadnice v&nbsp;prostoru (tj.&nbsp;buď trojici <strong>[x, y, z]</strong>, nebo v&nbsp;některých případech dokonce čtveřici <strong>[x, y, z, w]</strong>). Ve skutečnosti však pro většinu těles musíme specifikovat i barvu vrcholu, jeho normálu, souřadnici do textury a/nebo materiál.</p>

<p>Druhý problém, tj.&nbsp;nastavení kamery, pomocí které pozorujeme scénu, lze řešit více způsoby. První způsob spočívá v&nbsp;nastavení transformačních matic <strong>Projection</strong> a <strong>ModelView</strong> s&nbsp;využitím <a href="#k06">dále popsaných</a> funkcí <strong>glRotate()</strong>, <strong>glScale()</strong> a <strong>glTranslate()</strong>. Tento způsob má nevýhodu v&nbsp;tom, že nastavení transformačních matic tímto způsobem není příliš intuitivní (jedním z&nbsp;častých problémů při práci s&nbsp;grafickou knihovnou OpenGL je nesprávné nastavení pohledu na zobrazovanou scénu, takže programátor v&nbsp;horším případě uvidí pouze černou obrazovku, protože se kamera dívá mimo scénu někam do nekonečna). Řešení tohoto problému je popsáno <a href="#k02">ve druhé</a> a <a href="#k03">ve třetí</a> kapitole.</p>



<p><a name="k02"></a></p>
<h2 id="k02">2. Nastavení kamery sledující prostorovou scénu</h2>

<p>Aby nebylo nutné nastavovat pozici kamery jen nepřímo funkcemi <strong>glRotate()</strong>, <strong>glScale()</strong> a <strong>glTranslate()</strong>, byly do knihovny OpenGL přidány další funkce určené pouze pro práci s&nbsp;kamerou. Ve skutečnosti se pomocí těchto funkcí nepřímo nastavují transformační matice, takže výsledný efekt je stejný jako přímé volání funkcí pro změnu transformačních matic (samozřejmě s&nbsp;korektními parametry). Mezi funkce, které umožňují manipulaci s&nbsp;kamerou, patří:</p>

<ol>

<li><strong>glOrtho()</strong>: nastavení takzvané <i>ortogonální kamery</i>, tj.&nbsp;takové projekce, u které není zkreslována velikost objektů se vzdáleností od kamery.</li>

<li><strong>glFrustum()</strong>: nastavení takzvané <i>perspektivní kamery</i>, tj.&nbsp;takové projekce, u které se zdánlivá velikost objektů na obrazovce zmenšuje s&nbsp;rostoucí vzdáleností od kamery.</li>

</ol>



<p><a name="k03"></a></p>
<h2 id="k03">3. Pomocné funkce z&nbsp;GLU (OpenGL Utilities)</h2>

<p>Kromě základních funkcí <strong>glOrtho()</strong> a <strong>glFrustum()</strong> můžeme využít i pomocné funkce, které nám nabízí nadstavbová knihovna GLU (<i>OpenGL Utilities</i>). Tyto funkce mají výhodu v&nbsp;tom, že umožňují nastavení kamery pomocí poměrně snadno pochopitelných parametrů, které známe i z&nbsp;reálného světa. Jedná se o následující funkce:</p>

<ol>

<li><strong>gluLookAt()</strong>: tato funkce nastaví pozici kamery, směr jejího pohledu a orientaci souřadného systému vůči kameře (směr &bdquo;stropu&ldquo;).</li>

<li><strong>gluOrtho2D()</strong>: nastavení jednoduché 2D ortografické projekce, tj.&nbsp;pohledu na rovinu X-Y. Blízká a vzdálená ořezávací rovina (viz dále) je v&nbsp;tomto případě nastavena na hodnotu –1 resp. +1.</li>

<li><strong>gluPerspective()</strong>: nastavení perspektivní kamery, ale s&nbsp;použitím jiných, intuitivnějších parametrů než u funkce <strong>glFrustum()</strong>.</li>

</ol>



<p><a name="k04"></a></p>
<h2 id="k04">4. Scéna snímaná ortografickou kamerou</h2>

<p>Termínem <i>ortografická kamera</i> (resp.&nbsp;přesněji řečeno ortografická projekce) označujeme takovou projekci, u které není zkreslována velikost objektů se vzdáleností od kamery. Ortografická projekce se používá například v&nbsp;různých CAD systémech pro zobrazení součástek nebo v&nbsp;architektonických aplikacích, protože zde lze jednoduše zjistit délky všech hran bez nutnosti složitých přepočtů.</p>

<p>Nastavení ortografické kamery lze provést například pomocí dvojice funkcí <strong>gluLookAt()</strong> a <strong>glOrtho()</strong>. Pomocí funkce <strong>glOrtho()</strong> se vhodně nastaví transformační matice Projection takovým způsobem, že všechna vykreslovaná grafická primitiva jsou ořezána podle šesti ořezávacích rovin. Tyto ořezávací roviny jsou paralelní s&nbsp;osami souřadného systému, vykreslovaný prostor je tedy tvořen osově orientovaným kvádrem (<i>viewing volume</i>). Všechny vrcholy ležící mimo tento kvádr jsou odstraněny.</p>



<p><a name="k05"></a></p>
<h2 id="k05">5. Funkce <strong>glOrtho()</strong> a <strong>gluLookAt()</strong></h2>

<p>Funkce <strong>glOrtho()</strong> akceptuje šest parametrů nazvaným <strong>left</strong>, <strong>right</strong>, <strong>bottom</strong>, <strong>top</strong>, <strong>near</strong> a <strong>far</strong> s&nbsp;následujícím významem:</p>

<table>
<tr><th>Index</th><th>Parametr</th><th>Význam</th></tr>
<tr><td>1</td><td>left  </td><td>souřadnice levé ořezávací roviny</td></tr>
<tr><td>2</td><td>right </td><td>souřadnice pravé ořezávací roviny</td></tr>
<tr><td>3</td><td>bottom</td><td>souřadnice dolní ořezávací roviny</td></tr>
<tr><td>4</td><td>top   </td><td>souřadnice horní ořezávací roviny</td></tr>
<tr><td>5</td><td>near  </td><td>souřadnice blízké ořezávací roviny</td></tr>
<tr><td>6</td><td>far   </td><td>souřadnice vzdálené ořezávací roviny</td></tr>
</table>

<p>Význam jednotlivých ořezávacích rovin a jejich orientace k pozorovateli je naznačena na následujícím obrázku:</p>

<a href="https://mojefedora.cz/wp-content/uploads/2017/04/01.gif"><img class="alignnone size-full wp-image-8678" src="https://mojefedora.cz/wp-content/uploads/2017/04/01.gif" alt="" width="400" height="240" /></a>
<p><i>Obrázek 1: Význam parametrů funkce <strong>glOrtho()</strong>.</i></p>

<p>Důležité je, že vzdálená a blízká ořezávací rovina jsou zadány ve směru záporné osy <strong>z</strong>. Pokud je kamera umístěna v&nbsp;počátku, tj.&nbsp;na souřadnicích[0, 0, 0], mají parametry funkce <strong>glOrtho()</strong> tento význam:</p>

<ul>

<li>Trojice parametrů <strong>[left, bottom, -near]</strong> specifikuje bod, který je mapován (transformován) do levého dolního rohu vykreslovaného ok­na.</li>

<li>Trojice parametrů <strong>[right, top, -near]</strong> specifikuje bod, který je mapován (transformován) do pravého horního rohu vykreslovaného ok­na.</li>

<li>Parametr <strong>-far</strong> specifikuje umístění vzdálenější ořezávací roviny.</li>

</ul>

<p>Druhým krokem v&nbsp;nastavení kamery je její umístění a natočení v&nbsp;prostoru. Tato operace se dá provádět přímou změnou matice ModelView, ale pro intuitivnější práci je výhodnější použít funkci <strong>gluLookAt()</strong>. Tato funkce akceptuje devět parametrů s&nbsp;následujícím významem:</p>

<table>
<tr><th>Index</th><th>Parametr</th><th>Význam</th></tr>
<tr><td>1-3</td><td>eyex, eyey, eyez</td><td>souřadnice, na kterých se kamera nachází</td></tr>
<tr><td>4-6</td><td>centerx, centery, centerz</td><td>souřadnice bodu, na který se kamera dívá</td></tr>
<tr><td>7-9</td><td>upx, upy, upz</td><td>vektor směřující &bdquo;nahoru&ldquo; (na vykreslované scéně vertikální směr)</td></tr>
</table>

<p>Pomocí těchto devíti parametrů lze vytvořit lokální souřadný systém kamery, který se skládá z&nbsp;vektorů <strong>F</strong> (forward), <strong>L</strong> (left) a <strong>U</strong> (up). Z&nbsp;prvních třech parametrů se vytvoří bod <strong>E</strong> (pozice kamery), ze druhých třech parametrů bod <strong>C</strong> (střed pohledu) a z&nbsp;rozdílu souřadnic těchto dvou bodů získáme vektor <strong>F</strong> (forward). Zbývá nám tedy dopočítat vektory <strong>L</strong> a <strong>U</strong>. Vektor <strong>L</strong> získáme vektorovým součinem vektorů <strong>F</strong> a <strong>up</strong> (poslední tři parametry):</p>

<p><strong>L = up &times; F</strong></p>

<p>Poslední vektor <strong>U</strong> se získá dalším vektorovým součinem vektorů <strong>F</strong> a <strong>L</strong>:</p>

<p><strong>U = F &times; L</strong>.</p>

<p>Celá situace je znázorněná na dalším obrázku.</p>

<a href="https://mojefedora.cz/wp-content/uploads/2017/04/02.gif"><img class="alignnone size-thumbnail wp-image-8679" src="https://mojefedora.cz/wp-content/uploads/2017/04/02.gif" alt="" width="400" height="240" /></a>
<p><i>Obrázek 2: Kamera ve scéně a výpočet vektorů F, L a U.</i></p>



<p><a name="k06"></a></p>
<h2 id="k06">6. Změna transformačních matic a nastavení aktuální transformační matice</h2>

<p>V&nbsp;knihovně OpenGL existují tři transformační matice, které se postupně aplikují na body (vrcholy, vertexy) popř.&nbsp;i na normálové vektory vrcholů. První transformační matice se jmenuje <strong>ModelView matrix</strong>. Na tuto matici se můžeme dívat jako na spojení modelové matice a pohledové matice, protože se používá jak pro nastavení pozice kamery, tak i pro manipulaci s&nbsp;objekty (modely) ve scéně. Druhá transformační matice se jmenuje <strong>Projection matrix</strong> a používá se pro nastavení perspektivní projekce kamery. Třetí transformační matice se jmenuje <strong>Viewport matrix</strong> a používá se po provedení perspektivní projekce k&nbsp;mapování objektů z&nbsp;abtraktních souřadnic do souřadnic okna. Tato poslední matice ve skutečnosti pouze provádí transformaci v&nbsp;dvojrozměrné ploše, proto se s&nbsp;ní v&nbsp;knihovně OpenGL nepracuje jako s&nbsp;&bdquo;plnohodnotnou&ldquo; maticí. Kromě těchto tří matic můžeme měnit matici, která se používá při mapování textur na povrch objektů. Tato matice se nazývá <strong>Texture matrix</strong>.</p>

<p>Při změně některé z&nbsp;transformačních matic musíme nejprve určit, kterou transformační matici budeme měnit. K&nbsp;tomuto účelu se používá funkce <strong>glMatrixMode(mode)</strong>. Tato funkce má jeden parametr <strong>mode</strong>, kterým určujeme matici, kterou budeme dalšími příkazy změnit. Parametr může nabývat tří hodnot, reprezentovaných symbolickými konstantami:</p>

<ul>

<li><strong>GL_MODELVIEW</strong> &ndash; bude se měnit ModelView matrix, tj.&nbsp;matice, ve které jsou uloženy modelové a pohledové transformace (transformace objektů a nastavení kamery).</li>

<li><strong>GL_PROJECTION</strong> &ndash; bude se měnit Projection matrix, tj.&nbsp;matice, která se používá pro nastavení perspektivní nebo ortogonální projekce kamery.</li>

<li><strong>GL_TEXTURE</strong> &ndash; bude se měnit Texture matrix, tj.&nbsp;matice, která se používá při mapování textur na povrch objektů.</li>

</ul>



<p><a name="k07"></a></p>
<h2 id="k07">7. První demonstrační příklad: scéna snímaná ortografickou kamerou</h2>

<p>Jak již bylo napsáno výše, funkcí <strong>glOrtho()</strong> se mění prvky v&nbsp;Projection matici. Před zavoláním této funkce je tedy nutné nastavit tuto matici jako aktuální a matici samotnou nastavit jako jednotkovou:</p>

<pre>
glMatrixMode(GL_PROJECTION)                  # zacatek modifikace projekcni matice
glLoadIdentity()                             # vymazani projekcni matice (=identita)
glOrtho(left, right, bottom, top, near, far) # nastaveni ortogonalni projekce
</pre>

<p>Vzhledem k&nbsp;tomu, že pomocí funkce <strong>gluLookAt()</strong> se mění prvky transformační matice ModelView, je ve většině běžných případů zapotřebí zavolat tuto sekvenci příkazů:</p>

<pre>
glMatrixMode(GL_MODELVIEW)                   # bude se menit modelova matice
glLoadIdentity()                             # nahrat jednotkovou matici

gluLookAt(eyex, eyey, eyez,                  # bod, odkud se kamera diva
          centerx, centery, centerz,         # bod, kam se kamera diva
          upx, upy, upz                      # poloha "stropu" ve scene
</pre>

<p>Základní práce s&nbsp;ortografickou kamerou, tedy nastavení pozice a orientace kamery pomocí funkce <strong>gluLookAt()</strong>, je ukázána v&nbsp;prvním demonstračním příkladu. Na scéně je zobrazeno jednoduché trojrozměrné těleso ve tvaru domečku složené z&nbsp;trojúhelníků a čtyřúhelníků. Tato grafická primitiva jsou vykreslena jen úsečkami, takže výsledkem je drátový model (<i>wireframe</i>):</p>

<pre>
#!/usr/bin/env python

import pyglet
from pyglet.gl import *
from pyglet.window import key
window = pyglet.window.Window(width=500,
                              height=500,
                              caption="Pyglet+OpenGL")



def init():
    glClearColor(0.0, 0.0, 0.3, 0.0)          # barva pozadi obrazku
    glPolygonMode(GL_FRONT, GL_LINE)          # nastaveni rezimu vykresleni dratoveho modelu
    glPolygonMode(GL_BACK, GL_LINE)           # jak pro predni tak pro zadni steny
    glDisable(GL_CULL_FACE)                   # zadne hrany ani steny se nebudou odstranovat



@window.event
def on_resize(width, height):
    init()
    glViewport(0, 0, width, height)           # viditelna oblast pres cele okno



@window.event
def on_draw():
    glClear(GL_COLOR_BUFFER_BIT)              # vymazani vsech bitovych rovin barvoveho bufferu

    glMatrixMode(GL_PROJECTION)               # zacatek modifikace projekcni matice
    glLoadIdentity()                          # vymazani projekcni matice (=identita)
    glOrtho(-10, 10, -10, 10, -30, 30)        # nastaveni ortogonalni projekce
    glMatrixMode(GL_MODELVIEW)                # bude se menit modelova matice
    glLoadIdentity()                          # nahrat jednotkovou matici

    gluLookAt(4.0, 6.0, 18.0,                 # bod, odkud se kamera diva
              0.0, 2.0,  0.0,                 # bod, kam se kamera diva
              0.0, 1.0,  0.0)                 # poloha "stropu" ve scene

    glBegin(GL_QUADS)                         # vykresleni otevrene krychle - sten domecku
    glColor3f(0.0, 0.0, 1.0)
    glVertex3f(-5.0, -5.0, -5.0)
    glColor3f(0.0, 1.0, 0.0)
    glVertex3f(-5.0, -5.0,  5.0)
    glColor3f(0.0, 1.0, 1.0)
    glVertex3f( 5.0, -5.0,  5.0)
    glColor3f(1.0, 0.0, 0.0)
    glVertex3f( 5.0, -5.0, -5.0)

    glColor3f(1.0, 0.0, 1.0)
    glVertex3f(-5.0,  5.0, -5.0)
    glColor3f(1.0, 1.0, 0.0)
    glVertex3f(-5.0,  5.0,  5.0)
    glColor3f(1.0, 1.0, 1.0)
    glVertex3f( 5.0,  5.0,  5.0)
    glColor3f(0.0, 0.0, 1.0)
    glVertex3f( 5.0,  5.0, -5.0)

    glColor3f(0.0, 1.0, 0.0)
    glVertex3f(-5.0, -5.0, -5.0)
    glColor3f(0.0, 1.0, 1.0)
    glVertex3f(-5.0, -5.0,  5.0)
    glColor3f(1.0, 0.0, 0.0)
    glVertex3f(-5.0,  5.0,  5.0)
    glColor3f(1.0, 0.0, 1.0)
    glVertex3f(-5.0,  5.0, -5.0)

    glColor3f(0.0, 1.0, 0.0)
    glVertex3f( 5.0, -5.0, -5.0)
    glColor3f(0.0, 1.0, 1.0)
    glVertex3f( 5.0, -5.0,  5.0)
    glColor3f(1.0, 0.0, 0.0)
    glVertex3f( 5.0,  5.0,  5.0)
    glColor3f(1.0, 0.0, 1.0)
    glVertex3f( 5.0,  5.0, -5.0)
    glEnd()

    glBegin(GL_TRIANGLES)                      # vykresleni strechy domecku z trojuhelniku
    glColor3f(0.0, 0.0, 1.0)
    glVertex3f(-5.0,  5.0, -5.0)
    glColor3f(0.0, 1.0, 1.0)
    glVertex3f( 5.0,  5.0, -5.0)
    glColor3f(1.0, 1.0, 1.0)
    glVertex3f( 0.0, 11.0,  0.0)

    glColor3f(1.0, 0.0, 0.0)
    glVertex3f( 5.0,  5.0, -5.0)
    glColor3f(1.0, 1.0, 0.0)
    glVertex3f( 5.0,  5.0,  5.0)
    glColor3f(1.0, 1.0, 1.0)
    glVertex3f( 0.0, 11.0,  0.0)

    glColor3f(0.0, 1.0, 0.0)
    glVertex3f( 5.0,  5.0,  5.0)
    glColor3f(0.0, 1.0, 1.0)
    glVertex3f(-5.0,  5.0,  5.0)
    glColor3f(1.0, 1.0, 1.0)
    glVertex3f( 0.0, 11.0,  0.0)

    glColor3f(0.0, 1.0, 0.0)
    glVertex3f(-5.0,  5.0,  5.0)
    glColor3f(1.0, 1.0, 0.0)
    glVertex3f(-5.0,  5.0, -5.0)
    glColor3f(1.0, 1.0, 1.0)
    glVertex3f( 0.0, 11.0,  0.0)
    glEnd()



pyglet.app.run()
</pre>

<a href="https://mojefedora.cz/wp-content/uploads/2017/04/03-1.png"><img class="alignnone size-thumbnail wp-image-8680" src="https://mojefedora.cz/wp-content/uploads/2017/04/03-1-254x254.png" alt="" width="254" height="254" /></a>
<p><i>Obrázek 3: Trojrozměrná scéna vykreslená prvním demonstračním příkladem.</i></p>



<p><a name="k08"></a></p>
<h2 id="k08">8. Skládání transformací</h2>

<p>S&nbsp;obsahem aktuálně nastavené transformační matice je možné manipulovat pomocí funkcí <strong>glLoadIdentity()</strong>, <strong>glLoadMatrix()</strong>, <strong>glMultMatrix()</strong>, <strong>glTranslate()</strong>, <strong>glScale()</strong> a <strong>glRotate()</strong>.</p>

<p>Nejjednodušší z&nbsp;těchto funkcí je funkce <strong>glLoadIdentity()</strong>. Tato funkce nahraje do aktuálně nastavené transformační matice koeficienty odpovídající jednotkové matici, tj.&nbsp;matici, ve které jsou všechny prvky vynulovány s&nbsp;výjimkou prvků hlavní diagonály, které jsou nastaveny na jedničku. Taková matice hraje úlohu neutrálního prvku při násobení matic nebo při násobení vektoru maticí. Při nastavování některé transformační matice se v&nbsp;naprosté většině případů začíná touto funkcí, neboť pomocí ní matici &bdquo;připravíme&ldquo; na aplikaci dalších transformací.</p>

<p>Funkce <strong>glLoadMatrix()</strong> se používá pro přímé nastavení prvků matice. Další funkce <strong>glMultMatrix()</strong> slouží k&nbsp;vynásobení aktuálně nastavené transformační matice maticí zadanou jako parametr této funkce.</p>

<p>Další tři funkce <strong>glTranslate()</strong>, <strong>glScale()</strong> a <strong>glRotate()</strong> jsou používány mnohem častěji než předchozí dvě funkce. U těchto funkcí se nemanipuluje přímo s&nbsp;jednotlivými prvky matice, ale zadávají se základní lineární transformace &ndash; posun, změna měřítka a rotace. Pro zadané transformace se vytvoří dočasná matice a aktuální matice (většinou je to matice ModelView) je touto dočasnou maticí vynásobena.</p>



<p><a name="k09"></a></p>
<h2 id="k09">9. Druhý demonstrační příklad: otáčení objektem ve scéně</h2>

<p>Ve druhém demonstračním příkladu je možné tělesem &ndash; domečkem &ndash; ve scéně rotovat, což je zařízeno dvojicí globálních proměnných, které se mění stiskem kurzorových kláves:</p>

<pre>
r1 = 0.0
r2 = 0.0
</pre>

<p>Změna proměnných <strong>r1</strong> a <strong>r2</strong>:</p>

<pre>
keys = key.KeyStateHandler()
window.push_handlers(keys)

global r1, r2

if keys[key.LEFT]:
    r2 = r2 - 1
if keys[key.RIGHT]:
    r2 = r2 + 1
if keys[key.UP]:
    r1 = r1 - 1
if keys[key.DOWN]:
    r1 = r1 + 1
</pre>

<p>Rotace tělesa pomocí skládání transformací:</p>

<pre>
glMatrixMode(GL_MODELVIEW)                # bude se menit modelova matice
glLoadIdentity()                          # nahrat jednotkovou matici

gluLookAt(4.0, 6.0, 18.0,                 # bod, odkud se kamera diva
          0.0, 2.0,  0.0,                 # bod, kam se kamera diva
          0.0, 1.0,  0.0)                 # poloha "stropu" ve scene

glRotatef(r1, 1.0, 0.0, 0.0)              # rotace objektu
glRotatef(r2, 0.0, 1.0, 0.0) 
</pre>

<p>Úplný zdrojový kód tohoto demonstračního příkladu vypadá následovně:</p>

<pre>
#!/usr/bin/env python

import pyglet
from pyglet.gl import *
from pyglet.window import key

r1 = 0.0
r2 = 0.0

window = pyglet.window.Window(width=500,
                              height=500,
                              caption="Pyglet+OpenGL")


keys = key.KeyStateHandler()
window.push_handlers(keys)



def init():
    glClearColor(0.0, 0.0, 0.3, 0.0)          # barva pozadi obrazku
    glPolygonMode(GL_FRONT, GL_LINE)          # nastaveni rezimu vykresleni dratoveho modelu
    glPolygonMode(GL_BACK, GL_LINE)           # jak pro predni tak pro zadni steny
    glDisable(GL_CULL_FACE)                   # zadne hrany ani steny se nebudou odstranovat



@window.event
def on_resize(width, height):
    init()
    glViewport(0, 0, width, height)           # viditelna oblast pres cele okno



@window.event
def on_draw():
    global r1, r2

    if keys[key.LEFT]:
        r2 = r2 - 1
    if keys[key.RIGHT]:
        r2 = r2 + 1
    if keys[key.UP]:
        r1 = r1 - 1
    if keys[key.DOWN]:
        r1 = r1 + 1

    glClear(GL_COLOR_BUFFER_BIT)              # vymazani vsech bitovych rovin barvoveho bufferu

    glMatrixMode(GL_PROJECTION)               # zacatek modifikace projekcni matice
    glLoadIdentity()                          # vymazani projekcni matice (=identita)
    glOrtho(-10, 10, -10, 10, -30, 30)        # nastaveni ortogonalni projekce
    glMatrixMode(GL_MODELVIEW)                # bude se menit modelova matice
    glLoadIdentity()                          # nahrat jednotkovou matici

    gluLookAt(4.0, 6.0, 18.0,                 # bod, odkud se kamera diva
              0.0, 2.0,  0.0,                 # bod, kam se kamera diva
              0.0, 1.0,  0.0)                 # poloha "stropu" ve scene

    glRotatef(r1, 1.0, 0.0, 0.0)              # rotace objektu
    glRotatef(r2, 0.0, 1.0, 0.0) 

    glBegin(GL_QUADS)                         # vykresleni otevrene krychle - sten domecku
    glColor3f(0.0, 0.0, 1.0)
    glVertex3f(-5.0, -5.0, -5.0)
    glColor3f(0.0, 1.0, 0.0)
    glVertex3f(-5.0, -5.0,  5.0)
    glColor3f(0.0, 1.0, 1.0)
    glVertex3f( 5.0, -5.0,  5.0)
    glColor3f(1.0, 0.0, 0.0)
    glVertex3f( 5.0, -5.0, -5.0)

    glColor3f(1.0, 0.0, 1.0)
    glVertex3f(-5.0,  5.0, -5.0)
    glColor3f(1.0, 1.0, 0.0)
    glVertex3f(-5.0,  5.0,  5.0)
    glColor3f(1.0, 1.0, 1.0)
    glVertex3f( 5.0,  5.0,  5.0)
    glColor3f(0.0, 0.0, 1.0)
    glVertex3f( 5.0,  5.0, -5.0)

    glColor3f(0.0, 1.0, 0.0)
    glVertex3f(-5.0, -5.0, -5.0)
    glColor3f(0.0, 1.0, 1.0)
    glVertex3f(-5.0, -5.0,  5.0)
    glColor3f(1.0, 0.0, 0.0)
    glVertex3f(-5.0,  5.0,  5.0)
    glColor3f(1.0, 0.0, 1.0)
    glVertex3f(-5.0,  5.0, -5.0)

    glColor3f(0.0, 1.0, 0.0)
    glVertex3f( 5.0, -5.0, -5.0)
    glColor3f(0.0, 1.0, 1.0)
    glVertex3f( 5.0, -5.0,  5.0)
    glColor3f(1.0, 0.0, 0.0)
    glVertex3f( 5.0,  5.0,  5.0)
    glColor3f(1.0, 0.0, 1.0)
    glVertex3f( 5.0,  5.0, -5.0)
    glEnd()

    glBegin(GL_TRIANGLES)                      # vykresleni strechy domecku z trojuhelniku
    glColor3f(0.0, 0.0, 1.0)
    glVertex3f(-5.0,  5.0, -5.0)
    glColor3f(0.0, 1.0, 1.0)
    glVertex3f( 5.0,  5.0, -5.0)
    glColor3f(1.0, 1.0, 1.0)
    glVertex3f( 0.0, 11.0,  0.0)

    glColor3f(1.0, 0.0, 0.0)
    glVertex3f( 5.0,  5.0, -5.0)
    glColor3f(1.0, 1.0, 0.0)
    glVertex3f( 5.0,  5.0,  5.0)
    glColor3f(1.0, 1.0, 1.0)
    glVertex3f( 0.0, 11.0,  0.0)

    glColor3f(0.0, 1.0, 0.0)
    glVertex3f( 5.0,  5.0,  5.0)
    glColor3f(0.0, 1.0, 1.0)
    glVertex3f(-5.0,  5.0,  5.0)
    glColor3f(1.0, 1.0, 1.0)
    glVertex3f( 0.0, 11.0,  0.0)

    glColor3f(0.0, 1.0, 0.0)
    glVertex3f(-5.0,  5.0,  5.0)
    glColor3f(1.0, 1.0, 0.0)
    glVertex3f(-5.0,  5.0, -5.0)
    glColor3f(1.0, 1.0, 1.0)
    glVertex3f( 0.0, 11.0,  0.0)
    glEnd()



pyglet.app.run()
</pre>

<a href="https://mojefedora.cz/wp-content/uploads/2017/04/04-1.png"><img class="alignnone size-thumbnail wp-image-8681" src="https://mojefedora.cz/wp-content/uploads/2017/04/04-1-254x254.png" alt="" width="254" height="254" /></a>
<p><i>Obrázek 4: Trojrozměrná scéna vykreslená druhým demonstračním příkladem.</i></p>

<a href="https://mojefedora.cz/wp-content/uploads/2017/04/05-1.png"><img class="alignnone size-thumbnail wp-image-8682" src="https://mojefedora.cz/wp-content/uploads/2017/04/05-1-254x254.png" alt="" width="254" height="254" /></a>
<p><i>Obrázek 5: Trojrozměrná scéna vykreslená druhým demonstračním příkladem.</i></p>



<p><a name="k10"></a></p>
<h2 id="k10">10. Scéna snímaná kamerou s&nbsp;perspektivou</h2>

<p>Nastavení perspektivní kamery je poněkud složitější, než nastavení kamery ortogonální, protože prostor viditelný touto kamerou nemá obecně tvar hranolu, ale komolého jehlanu. Musíme tedy vhodným způsobem specifikovat parametry tohoto jehlanu. Podobně jako u kamery nastavené do ortogonálního režimu, i zde se ty části těles, které se nachází mimo viditelný prostor, ořezávají.</p>



<p><a name="k11"></a></p>
<h2 id="k11">11. Základní funkce pro nastavení kamery v&nbsp;perspektivním režimu</h2>

<p>Základní funkcí pro nastavení perspektivní kamery je funkce <strong>glFrustum()</strong>, pomocí které se nastavují prvky transformační matice GL_PROJECTION. Při volání této funkce musíme zadat šest parametrů s&nbsp;následujícím významem:</p>

<table>
<tr><th>Index</th><th>Parametr</th><th>Význam</th></tr>
<tr><td>1</td><td>left</td><td>vzdálenost levé ořezávací roviny od počátku. Vzdálenost se udává ve směru osy x.</td></tr>
<tr><td>2</td><td>right</td><td>vzdálenost pravé ořezávací roviny od počátku. Vzdálenost se opět udává ve směru osy x, podobně jako u předchozího parametru.</td></tr>
<tr><td>3</td><td>bottom</td><td>vzdálenost spodní ořezávací roviny od počátku. Vzdálenost se udává ve směru osy y.</td></tr>
<tr><td>4</td><td>top</td><td>vzdálenost horní ořezávací roviny od počátku. Vzdálenost je opět zadána ve směru osy y, podobně jako u předchozího parametru.</td></tr>
<tr><td>5</td><td>near</td><td>vzdálenost od kamery k bližší ořezávací rovině kolmé na směr promítání. Vzdálenost je tedy zadána ve směru osy z.</td></tr>
<tr><td>6</td><td>far</td><td>vzdálenost od kamery k vzdálenější ořezávací rovině kolmé na směr promítání. Stejně jako u předchozího parametru, i tato vzdálenost je zadána ve směru osy z.</td></tr>
</table>

<p>Význam parametrů této funkce je znázorněn na šestém obrázku. Výsek viditelného prostoru ve tvaru komolého jehlanu je zadán rozměry menší podstavy (parametry <strong>left</strong>, <strong>right</strong>, <strong>bottom</strong> a <strong>top</strong>) a vzdáleností obou podstav od kamery. Úhel stěn je možné z&nbsp;těchto hodnot dopočítat.</p>

<a href="https://mojefedora.cz/wp-content/uploads/2017/04/06.gif"><img class="alignnone size-thumbnail wp-image-8683" src="https://mojefedora.cz/wp-content/uploads/2017/04/06.gif" alt="" width="440" height="200" /></a>
<p><i>Obrázek 6: Význam parametrů funkce <strong>glFrustum()</strong>.</i></p>

<p>Kromě této funkce (která nastavuje transformační matici GL_PROJECTION) lze samozřejmě použít i výše popsanou funkci <strong>gluLookAt()</strong>, pomocí které se nastaví prvky transformační matice MODELVIEW. Pro korektní práci je nutné nejdříve nastavit měněnou matici funkcí <strong>glMatrixMode()</strong> a poté tuto matici nastavit na jednotkovou pomocí funkce <strong>glLoadIdentity()</strong>.</p>

<p>S&nbsp;využitím funkce <strong>glFrustum()</strong> lze sice nastavit projekční transformační matici pro kameru v&nbsp;perspektivním režimu, ale zadávání šesti parametrů komolého jehlanu není příliš intuitivní. Proto byla do knihovny GLU (což je, jak již víme, nadstavba nad knihovnou OpenGL s&nbsp;mnoha užitečnými funkcemi) přidána funkce pro nastavení vlastností kamery v&nbsp;perspektivním režimu pomocí parametrů, jejichž význam známe z&nbsp;reálného světa (používají se například při popisu vlastností objektivů). Tato funkce se jmenuje <strong>gluPerspective()</strong> a akceptuje čtyři parametry:</p>

<table>
<tr><th>Index</th><th>Parametr</th><th>Význam</th></tr>
<tr><td>1</td><td>fovy</td><td>zorný úhel (Field Of View) kamery. Tento úhel je zadán v&nbsp;rovině x-z, která prochází počátkem. Běžně používané zorné úhly se pohybují v&nbsp;rozsahu 30–80 stupňů, je však možné zadat i úhly menší (teleobjektiv) nebo větší (rybí oko).</td></tr>
<tr><td>2</td><td>aspect</td><td>poměr mezi šířkou a výškou zadávaného jehlanu. Tento parametr lze použít pro roztažení popř. smrsknutí obrázku ve směru jedné ze souřadných os. Hodnotu tohoto parametru můžeme získat podílem šířky a výšky podstavy jehlanu. Většinou se tato hodnota zjišťuje z&nbsp;rozměrů okna pro kreslení.</td></tr>
<tr><td>3</td><td>near</td><td>vzdálenost od kamery k&nbsp;bližší ořezávací rovině kolmé na směr promítání. Vzdálenost je tedy zadána ve směru osy z. Význam tohoto parametru je tedy stejný jako u funkce <strong>glFrustum()</strong>.</td></tr>
<tr><td>4</td><td>far</td><td>vzdálenost od kamery k&nbsp;vzdálenější ořezávací rovině kolmé na směr promítání. Stejně jako u předchozího parametru, i tato vzdálenost je zadána ve směru osy z. Význam tohoto parametru je opět totožný s&nbsp;parametrem funkce <strong>glFrustum()</strong>.</td></tr>
</table>

<p>Význam jednotlivých parametrů funkce <strong>gluPerspective()</strong> je vysvětlen i na sedmém obrázku. Z&nbsp;tohoto obrázku je také patrné, jak jednotlivé parametry ovlivňují nastavení kamery. Dvojice parametrů <strong>fovy</strong> a <strong>aspect</strong> nastavuje tvar menší podstavy komolého jehlanu, zatímco parametry <strong>near</strong> a <strong>far</strong> nastavují výšku a velikost jehlanu.</p>

<a href="https://mojefedora.cz/wp-content/uploads/2017/04/07.gif"><img class="alignnone size-thumbnail wp-image-8684" src="https://mojefedora.cz/wp-content/uploads/2017/04/07.gif" alt="" width="440" height="200" /></a>
<p><i>Obrázek 7: Význam parametrů funkce <strong>gluPerspective()</strong>.</i></p>



<p><a name="k12"></a></p>
<h2 id="k12">12. Třetí demonstrační příklad: perspektivní kamera</h2>

<p>Ve třetím a dnes i posledním demonstračním příkladu si ukážeme postup při nastavení kamery s&nbsp;perspektivním promítáním. Způsob zobrazení je řízen trojicí globálních proměnných:</p>

<pre>
fov = 70.0                                    # hodnota zorneho uhlu - field of view
nearPlane = 0.1;                              # blizsi orezavaci rovina
farPlane = 90.0;                              # vzdalenejsi orezavaci rovina
</pre>

<p>Nastavení projekční matice:</p>

<pre>
glMatrixMode(GL_PROJECTION)                   # zacatek modifikace projekcni matice
glLoadIdentity()                              # vymazani projekcni matice (=identita)
gluPerspective(fov, 1.0, nearPlane, farPlane);
</pre>

<p>Nastavení modelview matice s&nbsp;rotací tělesa:</p>

<pre>
glMatrixMode(GL_MODELVIEW)
glLoadIdentity()                              # nahrat jednotkovou matici

gluLookAt(4.0, 6.0, 18.0,                     # bod, odkud se kamera diva
          0.0, 2.0,  0.0,                     # bod, kam se kamera diva
          0.0, 1.0,  0.0)                     # poloha "stropu" ve scene

glRotatef(r1, 1.0, 0.0, 0.0)                  # rotace objektu
glRotatef(r2, 0.0, 1.0, 0.0) 
</pre>

<p>Úplný zdrojový kód třetího demonstračního příkladu vypadá následovně:</p>

<pre>
#!/usr/bin/env python

import pyglet
from pyglet.gl import *
from pyglet.window import key

fov = 70.0                                    # hodnota zorneho uhlu - field of view
nearPlane = 0.1;                              # blizsi orezavaci rovina
farPlane = 90.0;                              # vzdalenejsi orezavaci rovina

r1 = 0.0
r2 = 0.0

window = pyglet.window.Window(width=500,
                              height=500,
                              caption="Pyglet+OpenGL")


keys = key.KeyStateHandler()
window.push_handlers(keys)



def init():
    glClearColor(0.0, 0.0, 0.3, 0.0)          # barva pozadi obrazku
    glPolygonMode(GL_FRONT, GL_LINE)          # nastaveni rezimu vykresleni dratoveho modelu
    glPolygonMode(GL_BACK, GL_LINE)           # jak pro predni tak pro zadni steny
    glDisable(GL_CULL_FACE)                   # zadne hrany ani steny se nebudou odstranovat



@window.event
def on_resize(width, height):
    init()
    glViewport(0, 0, width, height)           # viditelna oblast pres cele okno



@window.event
def on_draw():
    global r1, r2

    if keys[key.LEFT]:
        r2 = r2 - 1
    if keys[key.RIGHT]:
        r2 = r2 + 1
    if keys[key.UP]:
        r1 = r1 - 1
    if keys[key.DOWN]:
        r1 = r1 + 1

    glClear(GL_COLOR_BUFFER_BIT)              # vymazani vsech bitovych rovin barvoveho bufferu

    glMatrixMode(GL_PROJECTION)               # zacatek modifikace projekcni matice
    glLoadIdentity()                          # vymazani projekcni matice (=identita)
    gluPerspective(fov, 1.0, nearPlane, farPlane);

    glMatrixMode(GL_MODELVIEW)
    glLoadIdentity()                          # nahrat jednotkovou matici

    gluLookAt(4.0, 6.0, 18.0,                 # bod, odkud se kamera diva
              0.0, 2.0,  0.0,                 # bod, kam se kamera diva
              0.0, 1.0,  0.0)                 # poloha "stropu" ve scene

    glRotatef(r1, 1.0, 0.0, 0.0)              # rotace objektu
    glRotatef(r2, 0.0, 1.0, 0.0) 

    glBegin(GL_QUADS)                         # vykresleni otevrene krychle - sten domecku
    glColor3f(0.0, 0.0, 1.0)
    glVertex3f(-5.0, -5.0, -5.0)
    glColor3f(0.0, 1.0, 0.0)
    glVertex3f(-5.0, -5.0,  5.0)
    glColor3f(0.0, 1.0, 1.0)
    glVertex3f( 5.0, -5.0,  5.0)
    glColor3f(1.0, 0.0, 0.0)
    glVertex3f( 5.0, -5.0, -5.0)

    glColor3f(1.0, 0.0, 1.0)
    glVertex3f(-5.0,  5.0, -5.0)
    glColor3f(1.0, 1.0, 0.0)
    glVertex3f(-5.0,  5.0,  5.0)
    glColor3f(1.0, 1.0, 1.0)
    glVertex3f( 5.0,  5.0,  5.0)
    glColor3f(0.0, 0.0, 1.0)
    glVertex3f( 5.0,  5.0, -5.0)

    glColor3f(0.0, 1.0, 0.0)
    glVertex3f(-5.0, -5.0, -5.0)
    glColor3f(0.0, 1.0, 1.0)
    glVertex3f(-5.0, -5.0,  5.0)
    glColor3f(1.0, 0.0, 0.0)
    glVertex3f(-5.0,  5.0,  5.0)
    glColor3f(1.0, 0.0, 1.0)
    glVertex3f(-5.0,  5.0, -5.0)

    glColor3f(0.0, 1.0, 0.0)
    glVertex3f( 5.0, -5.0, -5.0)
    glColor3f(0.0, 1.0, 1.0)
    glVertex3f( 5.0, -5.0,  5.0)
    glColor3f(1.0, 0.0, 0.0)
    glVertex3f( 5.0,  5.0,  5.0)
    glColor3f(1.0, 0.0, 1.0)
    glVertex3f( 5.0,  5.0, -5.0)
    glEnd()

    glBegin(GL_TRIANGLES)                      # vykresleni strechy domecku z trojuhelniku
    glColor3f(0.0, 0.0, 1.0)
    glVertex3f(-5.0,  5.0, -5.0)
    glColor3f(0.0, 1.0, 1.0)
    glVertex3f( 5.0,  5.0, -5.0)
    glColor3f(1.0, 1.0, 1.0)
    glVertex3f( 0.0, 11.0,  0.0)

    glColor3f(1.0, 0.0, 0.0)
    glVertex3f( 5.0,  5.0, -5.0)
    glColor3f(1.0, 1.0, 0.0)
    glVertex3f( 5.0,  5.0,  5.0)
    glColor3f(1.0, 1.0, 1.0)
    glVertex3f( 0.0, 11.0,  0.0)

    glColor3f(0.0, 1.0, 0.0)
    glVertex3f( 5.0,  5.0,  5.0)
    glColor3f(0.0, 1.0, 1.0)
    glVertex3f(-5.0,  5.0,  5.0)
    glColor3f(1.0, 1.0, 1.0)
    glVertex3f( 0.0, 11.0,  0.0)

    glColor3f(0.0, 1.0, 0.0)
    glVertex3f(-5.0,  5.0,  5.0)
    glColor3f(1.0, 1.0, 0.0)
    glVertex3f(-5.0,  5.0, -5.0)
    glColor3f(1.0, 1.0, 1.0)
    glVertex3f( 0.0, 11.0,  0.0)
    glEnd()



pyglet.app.run()
</pre>

<a href="https://mojefedora.cz/wp-content/uploads/2017/04/08-1.png"><img class="alignnone size-thumbnail wp-image-8685" src="https://mojefedora.cz/wp-content/uploads/2017/04/08-1-254x254.png" alt="" width="254" height="254" /></a>
<p><i>Obrázek 8: Trojrozměrná scéna vykreslená třetím demonstračním příkladem.</i></p>

<a href="https://mojefedora.cz/wp-content/uploads/2017/04/09-1.png"><img class="alignnone size-thumbnail wp-image-8686" src="https://mojefedora.cz/wp-content/uploads/2017/04/09-1-254x254.png" alt="" width="254" height="254" /></a>
<p><i>Obrázek 9: Trojrozměrná scéna vykreslená třetím demonstračním příkladem.</i></p>



<p><a name="k13"></a></p>
<h2 id="k13">13. Repositář s&nbsp;demonstračními příklady</h2>

<p>Všechny tři dnes popsané demonstrační příklady byly uloženy do Git repositáře dostupného na adrese <a href="https://github.com/tisnik/presentations">https://github.com/tisnik/presentations</a>. Příklady si můžete v&nbsp;případě potřeby stáhnout i jednotlivě bez nutnosti klonovat celý repositář. Pro jejich spuštění je nutné mít nainstalovanou jak knihovnu Pyglet, tak i podpůrné grafické knihovny OpenGL a GLU (což se většinou provede automaticky v&nbsp;rámci instalace Pygletu, viz též <a href="https://mojefedora.cz/multimedialni-knihovna-pyglet/">úvodní díl tohoto seriálu</a>):</p>

<table>
<tr><th>Příklad</th><th>Odkaz</th></tr>
<tr><td>17_3d_projection.py</td><td><a href="https://github.com/tisnik/presentations/blob/master/pyglet/17_3d_projection.py">https://github.com/tisnik/presentations/blob/master/pyglet/17_3d_projection.py</a></td></tr>
<tr><td>18_rotation.py</td><td><a href="https://github.com/tisnik/presentations/blob/master/pyglet/18_rotation.py">https://github.com/tisnik/presentations/blob/master/pyglet/18_rotation.py</a></td></tr>
<tr><td>19_perspective.py</td><td><a href="https://github.com/tisnik/presentations/blob/master/pyglet/19_perspective.py">https://github.com/tisnik/presentations/blob/master/pyglet/19_perspective.py</a></td></tr>
</table>



<p><a name="k14"></a></p>
<h2 id="k14">14. Seznam dnes popsaných funkcí knihovny OpenGL a GLU</h2>

<ol>

<li>glLoadIdentity<br />
<a href="https://www.khronos.org/registry/OpenGL-Refpages/gl2.1/xhtml/glLoadIdentity.xml">https://www.khronos.org/registry/OpenGL-Refpages/gl2.1/xhtml/glLoadIdentity.xml</a>
</li>

<li>glTranslate<br />
<a href="https://www.khronos.org/registry/OpenGL-Refpages/gl2.1/xhtml/glTranslate.xml">https://www.khronos.org/registry/OpenGL-Refpages/gl2.1/xhtml/glTranslate.xml</a>
</li>

<li>glRotate<br />
<a href="https://www.khronos.org/registry/OpenGL-Refpages/gl2.1/xhtml/glRotate.xml">https://www.khronos.org/registry/OpenGL-Refpages/gl2.1/xhtml/glRotate.xml</a>
</li>

<li>glScale<br />
<a href="https://www.khronos.org/registry/OpenGL-Refpages/gl2.1/xhtml/glScale.xml">https://www.khronos.org/registry/OpenGL-Refpages/gl2.1/xhtml/glScale.xml</a>
</li>

<li>glMatrixMode<br />
<a href="https://www.khronos.org/registry/OpenGL-Refpages/gl2.1/xhtml/glMatrixMode.xml">https://www.khronos.org/registry/OpenGL-Refpages/gl2.1/xhtml/glMatrixMode.xml</a>
</li>

<li>glOrtho<br />
<a href="https://www.khronos.org/registry/OpenGL-Refpages/gl2.1/xhtml/glOrtho.xml">https://www.khronos.org/registry/OpenGL-Refpages/gl2.1/xhtml/glOrtho.xml</a>
</li>

<li>glFrustum<br />
<a href="https://www.khronos.org/registry/OpenGL-Refpages/gl2.1/xhtml/glFrustum.xml">https://www.khronos.org/registry/OpenGL-Refpages/gl2.1/xhtml/glFrustum.xml</a>
</li>

<li>glViewport<br />
<a href="https://www.khronos.org/registry/OpenGL-Refpages/gl2.1/xhtml/glViewport.xml">https://www.khronos.org/registry/OpenGL-Refpages/gl2.1/xhtml/glViewport.xml</a>
</li>

<li>gluLookAt<br />
<a href="https://www.khronos.org/registry/OpenGL-Refpages/gl2.1/xhtml/gluLookAt.xml">https://www.khronos.org/registry/OpenGL-Refpages/gl2.1/xhtml/gluLookAt.xml</a>
</li>

<li>gluPerspective<br />
<a href="https://www.khronos.org/registry/OpenGL-Refpages/gl2.1/xhtml/gluPerspective.xml">https://www.khronos.org/registry/OpenGL-Refpages/gl2.1/xhtml/gluPerspective.xml</a>
</li>

</ol>



<p><a name="k15"></a></p>
<h2 id="k15">15. Odkazy na Internetu</h2>

<ol>

<li>Pyglet Home Page<br />
<a href="https://bitbucket.org/pyglet/pyglet/wiki/Home">https://bitbucket.org/pyglet/pyglet/wiki/Home</a>
</li>

<li>Dokumentace k verzi 1.2<br />
<a href="https://pyglet.readthedocs.io/en/pyglet-1.2-maintenance/">https://pyglet.readthedocs.io/en/pyglet-1.2-maintenance/</a>
</li>

<li>Dokumentace k verzi 1.2 ve formátu PDF<br />
<a href="https://readthedocs.org/projects/pyglet/downloads/pdf/pyglet-1.2-maintenance/">https://readthedocs.org/projects/pyglet/downloads/pdf/pyglet-1.2-maintenance/</a>
</li>

<li>PyOpenGL<br />
<a href="http://pyopengl.sourceforge.net/">http://pyopengl.sourceforge.net/</a>
</li>

<li>The #! magic, details about the shebang/hash-bang mechanism on various Unix flavours<br />
<a href="https://www.in-ulm.de/~mascheck/various/shebang/">https://www.in-ulm.de/~mascheck/various/shebang/</a>
</li>

<li>Shebang (Unix)<br />
<a href="https://en.wikipedia.org/wiki/Shebang_%28Unix%29">https://en.wikipedia.org/wiki/Shebang_%28Unix%29</a>
</li>

<li>Domovská stránka systému LÖVE<br />
<a href="http://love2d.org/">http://love2d.org/</a>
</li>

<li>Simple DirectMedia Layer (home page)<br />
<a href="http://www.libsdl.org/">http://www.libsdl.org/</a>
</li>

<li>Simple DirectMedia Layer (Wikipedia)<br />
<a href="https://en.wikipedia.org/wiki/Simple_DirectMedia_Layer">https://en.wikipedia.org/wiki/Simple_DirectMedia_Layer</a>
</li>

<li>Seriál Grafická knihovna OpenGL<br />
<a href="https://www.root.cz/serialy/graficka-knihovna-opengl/">https://www.root.cz/serialy/graficka-knihovna-opengl/</a>
</li>

<li>Pyglet event loop<br />
<a href="http://pyglet.readthedocs.io/en/latest/programming_guide/eventloop.html">http://pyglet.readthedocs.io/en/latest/programming_guide/eventloop.html</a>
</li>

<li>Decorators I: Introduction to Python Decorators<br />
<a href="http://www.artima.com/weblogs/viewpost.jsp?thread=240808">http://www.artima.com/weblogs/viewpost.jsp?thread=240808</a>
</li>

<li>3D Programming in Python – Part 1 <br />
<a href="https://greendalecs.wordpress.com/2012/04/21/3d-programming-in-python-part-1/">https://greendalecs.wordpress.com/2012/04/21/3d-programming-in-python-part-1/</a>
</li>

<li>A very basic Pyglet tutorial<br />
<a href="http://www.natan.termitnjak.net/tutorials/pyglet_basic.html">http://www.natan.termitnjak.net/tutorials/pyglet_basic.html</a>
</li>

</ol>



<p></p><p></p>
<p><small>Autor: <a href="http://www.fit.vutbr.cz/~tisnovpa">Pavel Tišnovský</a> &nbsp; 2017</small></p>
</body>
</html>

