<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
        "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html>
<head>
<title>Multimediální knihovna Pyglet - tvorba procedurálních textur</title>
<meta name="Author" content="Pavel Tisnovsky" />
<meta name="Generator" content="vim" />
<meta http-equiv="content-type" content="text/html; charset=utf-8" />
<style type="text/css">
         body {color:#000000; background:#ffffff;}
         h1  {font-family: arial, helvetica, sans-serif; color:#ffffff; background-color:#c00000; text-align:center; padding-left:1em}
         h2  {font-family: arial, helvetica, sans-serif; color:#ffffff; background-color:#0000c0; padding-left:1em; text-align:left}
         h3  {font-family: arial, helvetica, sans-serif; color:#000000; background-color:#c0c0c0; padding-left:1em; text-align:left}
         h4  {font-family: arial, helvetica, sans-serif; color:#000000; background-color:#e0e0e0; padding-left:1em; text-align:left}
         a   {font-family: arial, helvetica, sans-serif;}
         li  {font-family: arial, helvetica, sans-serif; color:#000000; text-align:justify; width:450px;}
         ol  {font-family: arial, helvetica, sans-serif; color:#000000; text-align:justify; width:450px;}
         ul  {font-family: arial, helvetica, sans-serif; color:#000000; text-align:justify; width:450px;}
         p   {font-family: arial, helvetica, sans-serif; color:#000000; text-align:justify;}
         pre {background:#e0e0e0}
</style>
</head>

<body>

<h1>Multimediální knihovna Pyglet - tvorba procedurálních textur</h1>

<h3>Pavel Tišnovský</h3>

<p></p>

<h1>Úvodník</h1>

<p>V desáté části seriálu o multimediální knihovně Pyglet si ukážeme způsob tvorby jednoduchých procedurálních textur, které je možné použít při vykreslování dvourozměrných a samozřejmě i trojrozměrných scén. Popisované textury budou založené na takzvaném moaré, dvourozměrné spektrální syntéze a taktéž na slavné Perlinově šumové funkci.</p>



<h2>Obsah</h2>

<p><a href="#k01">1. Multimediální knihovna Pyglet &ndash; tvorba procedurálních textur</a></p>
<p><a href="#k02">2. Moaré s&nbsp;kružnicovým vzorkem</a></p>
<p><a href="#k03">3. První demonstrační příklad &ndash; základní moaré s&nbsp;kružnicovým vzorkem</a></p>
<p><a href="#k04">4. Druhý demonstrační příklad &ndash; výběr barvové palety</a></p>
<p><a href="#k05">5. Rozšíření repertoáru funkcí při tvorbě moaré</a></p>
<p><a href="#k06">6. Třetí demonstrační příklad &ndash; použití dalších typů funkcí při tvorbě moaré</a></p>
<p><a href="#k07">7. Algoritmy pro vykreslení textury &bdquo;plasmy&ldquo;</a></p>
<p><a href="#k08">8. Dvourozměrná spektrální syntéza</a></p>
<p><a href="#k09">9. Čtvrtý demonstrační příklad &ndash; použití dvourozměrné spektrální syntézy</a></p>
<p><a href="#k10">10. Kompletní zdrojový kód čtvrtého demonstračního příkladu</a></p>
<p><a href="#k11">11. Perlinova šumová funkce</a></p>
<p><a href="#k12">12. Princip šumové funkce</a></p>
<p><a href="#k13">13. Aplikace Perlinovy šumové funkce</a></p>
<p><a href="#k14">14. Pátý demonstrační příklad &ndash; 2D textura vykreslená Perlinovou funkcí</a></p>
<p><a href="#k15">15. Repositář s&nbsp;demonstračními příklady</a></p>
<p><a href="#k16">16. Odkazy na Internetu</a></p>



<p><a name="k01"></a></p>
<h2 id="k01">1. Multimediální knihovna Pyglet &ndash; tvorba procedurálních textur</h2>

<p>V&nbsp;předchozích částech tohoto seriálu jsme se zabývali problematikou texturování, konkrétně způsobem nanášení rastrových 2D textur na povrch vykreslovaných těles. Kromě textur uložených ve formě rastrových obrázků existuje i velmi dobře propracovaná technologie takzvaných <i>procedurálních textur</i>. Tyto textury jsou popsány matematickým výrazem, který každému bodu ležícímu v&nbsp;dvourozměrné ploše či v&nbsp;trojrozměrném prostoru přiřazuje jeho barvu, tj.&nbsp;jedná se (zjednodušeně řečeno) o funkci <i>color=f(x,y)</i> popř.&nbsp;<i>color=f(x,y,z)</i>. Dnes se budeme zabývat prozatím poměrně jednoduchými procedurálními texturami: <a href="#k02">moaré</a>, <a href="#k08">dvourozměrnou spektrální syntézou</a> a <a href="#k11">Perlinovou šumovou funkcí</a>.</p>

<a href="https://mojefedora.cz/wp-content/uploads/2017/06/01-1.png"><img class="alignnone size-thumbnail wp-image-9099" src="https://mojefedora.cz/wp-content/uploads/2017/06/01-1-254x254.png" alt="" width="254" height="254" /></a>
<p><i>Obrázek 1: Procedurální textura použitá pro vykreslení jednoduchého modelu planety.</i></p>



<p><a name="k02"></a></p>
<h2 id="k02">2. Moaré s&nbsp;kružnicovým vzorkem</h2>

<p>Velmi zajímavý a přitom jednoduše a současně i rychle vygenerovatelný vzorek založený na efektu takzvaného <i>moaré</i> vytvořil John Connett z&nbsp;Minnesotské univerzity. O tomto vzorku, který v&nbsp;podstatě názorně ukazuje vliv aliasu při tvorbě rastrových obrázků, později pojednal i A.&nbsp;K.&nbsp;Dewdney v&nbsp;časopise <i>Scientific American</i>. Tento vzorek je generovaný velmi jednoduchým způsobem: každému pixelu ve vytvářeném rastrovém obrázku (bitmapě) je přiřazena dvojice souřadnic <i>[x, y]</i>. Tyto souřadnice obecně neodpovídají celočíselným indexům pixelu, které můžeme například označit <i>[i, j]</i>. Posléze je pro každý pixel vypočtena hodnota <i>z</i> podle vztahu <i>z=x<sup>2</sup>+y<sup>2</sup></i>. To je vše &ndash; pouze se na základě vypočtené hodnoty <i>z</i> vybere vhodná barva z&nbsp;barvové palety a pixel se obarví.</p>

<a href="https://mojefedora.cz/wp-content/uploads/2017/06/02-1.png"><img class="alignnone size-thumbnail wp-image-9100" src="https://mojefedora.cz/wp-content/uploads/2017/06/02-1-254x254.png" alt="" width="254" height="254" /></a>
<p><i>Obrázek 2: Moaré s&nbsp;kružnicovým vzorkem.</i></p>

<p>Tímto přímočarým, rychlým a jednoduchým způsobem je možné vytvářet mnohdy fantastické vzorky, pouze stačí měnit barvovou paletu (ideální jsou plynulé přechody mezi barvami &ndash; <i>gradient</i>) a měřítko, pomocí kterého se převádí celočíselné pozice pixelů v&nbsp;rastru <i>[i, j]</i> na souřadnice <i>[x, y]</i>.</p>

<a href="https://mojefedora.cz/wp-content/uploads/2017/06/03-2.png"><img class="alignnone size-thumbnail wp-image-9101" src="https://mojefedora.cz/wp-content/uploads/2017/06/03-2-254x254.png" alt="" width="254" height="254" /></a>
<p><i>Obrázek 3: Mez zvětšení, při kterém již kružnicový vzorek začíná mizet.</i></p>

<p>To, že moaré s&nbsp;kružnicovým vzorkem netvoří fraktální strukturu (což z&nbsp;praktického hlediska znamená, že ho nelze libovolně zvětšovat, při určitém zvětšení textura zmizí), však nic nemění na tom, že se pomocí něho dají vytvářet zajímavé obrázky a textury, proto si jeho tvorbu podrobněji popíšeme v&nbsp;následujících dvou kapitolách. <i>Praktická poznámka:</i> pro 3D textury není tento vzorek vhodný, protože při různém pohledu na scénu (natáčení, přibližování apod.) dochází k&nbsp;několikanásobnému aliasu, který se projevuje nežádoucím poblikáváním a aplikace antialiasingu naopak může zcela vymazat původní detaily v&nbsp;textuře.</p>

<a href="https://mojefedora.cz/wp-content/uploads/2017/06/04-2.png"><img class="alignnone size-thumbnail wp-image-9102" src="https://mojefedora.cz/wp-content/uploads/2017/06/04-2-254x254.png" alt="" width="254" height="254" /></a>
<p><i>Obrázek 4: Při určitém měřítku narazíme na limit, pod kterým již nevidíme další detaily (viz střed obrázku, při jehož zvětšení již další detaily nebudou patrné).</i></p>



<p><a name="k03"></a></p>
<h2 id="k03">3. První demonstrační příklad &ndash; základní moaré s&nbsp;kružnicovým vzorkem</h2>

<p>Moaré s&nbsp;kružnicovým vzorkem je ukázáno v&nbsp;dnešním prvním demonstračním příkladu, který je založen na funkci nazvané <strong>recalc_circle_pattern()</strong>. Tato funkce provádí výpočet popsaný <a href="#k02">v&nbsp;předchozí kapitole</a>, na konci pak převádí vypočtenou hodnotu do celočíselného rozsahu 0..255:</p>

<pre>
# Funkce provadejici vypocet moare s kruznicovym vzorkem
def recalc_circle_pattern(image, xmin, ymin, xmax, ymax):
    width, height = image.size       # rozmery obrazku
    stepx = (xmax - xmin)/width
    stepy = (ymax - ymin)/height
    print(xmin, xmax, ymin, ymax, width, height, stepx, stepy)

    y1 = ymin
    for y in range(0, height):
        x1 = xmin
        for x in range(0, width):
            x1 += stepx
            x2 = x1 * x1
            y2 = y1 * y1
            i = (int)(x2 + y2) &amp; 255
            color = (i, i, i)
            image.putpixel((x, y), color)
        y1 += stepy
</pre>

<p>Úplný zdrojový kód prvního příkladu vypadá následovně:</p>

<pre>
#!/usr/bin/env python

# Vytvoreni textury s "kruznicovym moare"

from PIL import Image

# textura by mela byt ctvercova a jeji sirka i vyska by mela byt
# mocninou cisla 2
IMAGE_WIDTH = 256
IMAGE_HEIGHT = 256


# Funkce provadejici vypocet moare s kruznicovym vzorkem
def recalc_circle_pattern(image, xmin, ymin, xmax, ymax):
    width, height = image.size       # rozmery obrazku
    stepx = (xmax - xmin)/width
    stepy = (ymax - ymin)/height
    print(xmin, xmax, ymin, ymax, width, height, stepx, stepy)

    y1 = ymin
    for y in range(0, height):
        x1 = xmin
        for x in range(0, width):
            x1 += stepx
            x2 = x1 * x1
            y2 = y1 * y1
            i = (int)(x2 + y2) &amp; 255
            color = (i, i, i)
            image.putpixel((x, y), color)
        y1 += stepy


for i in range(0, 50, 10):
    image = Image.new("RGB", (IMAGE_WIDTH, IMAGE_HEIGHT))
    mez = (2 &lt;&lt; 5) + i * 2.5
    recalc_circle_pattern(image, -mez, -mez, mez, mez)
    fileName = "patternA{index:02d}.png".format(index=i)
    image.save(fileName)
</pre>

<a href="https://mojefedora.cz/wp-content/uploads/2017/06/05-2.png"><img class="alignnone size-thumbnail wp-image-9103" src="https://mojefedora.cz/wp-content/uploads/2017/06/05-2-254x254.png" alt="" width="254" height="254" /></a>
<p><i>Obrázek 5: Textura vygenerovaná prvním demonstračním příkladem.</i></p>

<a href="https://mojefedora.cz/wp-content/uploads/2017/06/06-2.png"><img class="alignnone size-thumbnail wp-image-9104" src="https://mojefedora.cz/wp-content/uploads/2017/06/06-2-254x254.png" alt="" width="254" height="254" /></a>
<p><i>Obrázek 6: Textura vygenerovaná prvním demonstračním příkladem.</i></p>

<a href="https://mojefedora.cz/wp-content/uploads/2017/06/07-1.png"><img class="alignnone size-thumbnail wp-image-9105" src="https://mojefedora.cz/wp-content/uploads/2017/06/07-1-254x254.png" alt="" width="254" height="254" /></a>
<p><i>Obrázek 7: Textura vygenerovaná prvním demonstračním příkladem.</i></p>

<a href="https://mojefedora.cz/wp-content/uploads/2017/06/08-1.png"><img class="alignnone size-thumbnail wp-image-9106" src="https://mojefedora.cz/wp-content/uploads/2017/06/08-1-254x254.png" alt="" width="254" height="254" /></a>
<p><i>Obrázek 8: Textura vygenerovaná prvním demonstračním příkladem.</i></p>

<a href="https://mojefedora.cz/wp-content/uploads/2017/06/09-1.png"><img class="alignnone size-thumbnail wp-image-9107" src="https://mojefedora.cz/wp-content/uploads/2017/06/09-1-254x254.png" alt="" width="254" height="254" /></a>
<p><i>Obrázek 9: Textura vygenerovaná prvním demonstračním příkladem.</i></p>



<p><a name="k04"></a></p>
<h2 id="k04">4. Druhý demonstrační příklad &ndash; výběr barvové palety</h2>

<p>Textury vykreslené ve stupních šedi sice mohou být pro některé projekty zajímavé (survival horory atd.), ovšem většinou požadujeme textury barevné. Ve skutečnosti je řešení jednoduché &ndash; postačuje ke každému vypočtenému indexu vybrat vhodnou barvu z&nbsp;barvové palety. Tradičně mají barvové palety 256 barev, ovšem samozřejmě je v&nbsp;případě potřeby možné vytvořit rozsáhlejší či naopak menší palety. Pro účely našich demonstračních příkladů použijeme textury získané z&nbsp;datových souborů programu <i>Fractint</i> a převedené na Pythonovské seznamy (viz též <a href="#k15">kapitolu číslo 15</a>. Upravená funkce pro vytvoření textury bude vypadat následovně:</p>

<pre>
# Funkce provadejici vypocet moare s kruznicovym vzorkem
def recalc_circle_pattern(image, palette, xmin, ymin, xmax, ymax):
    width, height = image.size       # rozmery obrazku
    stepx = (xmax - xmin)/width
    stepy = (ymax - ymin)/height

    y1 = ymin
    for y in range(0, height):
        x1 = xmin
        for x in range(0, width):
            x1 += stepx
            x2 = x1 * x1
            y2 = y1 * y1
            i = (int)(x2 + y2) &amp; 255
            color = (palette[i][0], palette[i][1], palette[i][2])
            image.putpixel((x, y), color)
        y1 += stepy
</pre>

<p>Úplný zdrojový kód druhého příkladu vypadá následovně:</p>

<pre>
#!/usr/bin/env python

# Vytvoreni textury s "kruznicovym moare"

from PIL import Image
import palette_blues
import palette_greens
import palette_gold
import palette_ice
import palette_mandmap

# textura by mela byt ctvercova a jeji sirka i vyska by mela byt
# mocninou cisla 2
IMAGE_WIDTH = 256
IMAGE_HEIGHT = 256


# Funkce provadejici vypocet moare s kruznicovym vzorkem
def recalc_circle_pattern(image, palette, xmin, ymin, xmax, ymax):
    width, height = image.size       # rozmery obrazku
    stepx = (xmax - xmin)/width
    stepy = (ymax - ymin)/height

    y1 = ymin
    for y in range(0, height):
        x1 = xmin
        for x in range(0, width):
            x1 += stepx
            x2 = x1 * x1
            y2 = y1 * y1
            i = (int)(x2 + y2) &amp; 255
            color = (palette[i][0], palette[i][1], palette[i][2])
            image.putpixel((x, y), color)
        y1 += stepy


mez = (2 &lt;&lt; 5) + 50 * 2.5
image = Image.new("RGB", (IMAGE_WIDTH, IMAGE_HEIGHT))

image_pals = ((palette_blues.palette,   "blues"),
              (palette_greens.palette,  "greens"),
              (palette_gold.palette,    "gold"),
              (palette_ice.palette,     "ice"),
              (palette_mandmap.palette, "mandmap"))

for image_pal in image_pals:
    print(image_pal[1])
    recalc_circle_pattern(image, image_pal[0], -mez, -mez, mez, mez)
    image.save("patternB_{name}.png".format(name=image_pal[1]))
</pre>

<a href="https://mojefedora.cz/wp-content/uploads/2017/06/10-1.png"><img class="alignnone size-thumbnail wp-image-9108" src="https://mojefedora.cz/wp-content/uploads/2017/06/10-1-254x254.png" alt="" width="254" height="254" /></a>
<p><i>Obrázek 10: Textura vygenerovaná druhým demonstračním příkladem.</i></p>

<a href="https://mojefedora.cz/wp-content/uploads/2017/06/11-1.png"><img class="alignnone size-thumbnail wp-image-9109" src="https://mojefedora.cz/wp-content/uploads/2017/06/11-1-254x254.png" alt="" width="254" height="254" /></a>
<p><i>Obrázek 11: Textura vygenerovaná druhým demonstračním příkladem.</i></p>



<p><a name="k05"></a></p>
<h2 id="k05">5. Rozšíření repertoáru funkcí při tvorbě moaré</h2>

<p>Předchozí dva demonstrační příklady je možné rozšířit o volbu dalších funkcí, které se použijí při výpočtu moaré. Výběr funkcí je takřka libovolný, pouze je žádoucí, aby při výpočtech docházelo k&nbsp;přetékání přes hodnotu 255 &ndash; tím vzniká požadovaný efekt tvořící základ vzorku. Některé níže uvedené &bdquo;vhodné&ldquo; funkce je jsou vypsány v&nbsp;tabulce:</p>

<table>
<tr><th>Označení funkce</th><th>Tvar funkce</th></tr>
<tr><td>circle</td><td>z<sub>factor</sub>&times;(x &times; x + y &times; y)</td></tr>
<tr><td>anticircle</td><td>z<sub>factor</sub>&times;(x &times; x - y &times; y)</td></tr>
<tr><td>xyfun</td><td>z<sub>factor</sub>&times;(x &times; x + xy<sub>factor</sub> &times; x &times; y + y &times; y)</td></tr>
<tr><td>x3y3</td><td>z<sub>factor</sub>&times;(x &times; x &times; x + y &times; y &times; y)</td></tr>
<tr><td>x4y4</td><td>z<sub>factor</sub>&times;(x &times; x &times; x &times; x + y &times; y &times; y &times; y)</td></tr>
<tr><td>x3y3_xy</td><td>z<sub>factor</sub>&times;(x &times; x &times; x + y &times; y &times; y) / (x &times; y)</td></tr>
<tr><td>xpy_xmy</td><td>z<sub>factor</sub>&times;(x + y) / (x - y)</td></tr>
</table>

<a href="https://mojefedora.cz/wp-content/uploads/2017/06/13-1.png"><img class="alignnone size-thumbnail wp-image-9111" src="https://mojefedora.cz/wp-content/uploads/2017/06/13-1-254x254.png" alt="" width="254" height="254" /></a>
<p><i>Obrázek 12: Moaré vypočtené s&nbsp;pomocí funkce nazvané x3y3.</i></p>

<a href="https://mojefedora.cz/wp-content/uploads/2017/06/12-1.png"><img class="alignnone size-thumbnail wp-image-9110" src="https://mojefedora.cz/wp-content/uploads/2017/06/12-1-254x254.png" alt="" width="254" height="254" /></a>
<p><i>Obrázek 13: Další možnosti tvorby moaré.</i></p>

<a href="https://mojefedora.cz/wp-content/uploads/2017/06/14-1.png"><img class="alignnone size-thumbnail wp-image-9112" src="https://mojefedora.cz/wp-content/uploads/2017/06/14-1-254x254.png" alt="" width="254" height="254" /></a>
<p><i>Obrázek 14: Další možnosti tvorby moaré.</i></p>



<p><a name="k06"></a></p>
<h2 id="k06">6. Třetí demonstrační příklad &ndash; použití dalších typů funkcí při tvorbě moaré</h2>

<p>Předchozí příklad nepatrně upravíme tak, že se namísto funkce <strong>recalc_circle_pattern()</strong> použije zobecněná funkce <strong>recalc_any_pattern()</strong>. Jedná se o funkci vyššího řádu, protože jejím posledním parametrem je jiná funkce použitá pro přepočet hodnot barev pixelů na základě jejich souřadnic. V&nbsp;Pythonu se předání jiné funkce provede snadno, a to konkrétně použitím anonymních funkcí (někdy nazývané <i>lambda abstrakce</i> nebo jen zkráceně <i>lambdy</i>):</p>

<pre>
recalc_any_pattern(image, palette_mandmap.palette, -mez, -mez, mez, mez, <strong>lambda x,y : x*x + y*y</strong>)
</pre>

<p>Upravená forma funkce pro výpočet moaré se od původního kódu liší jen nepatrně:</p>

<pre>
# Funkce provadejici vypocet moare s kruznicovym ci jinym vzorkem
def recalc_any_pattern(image, palette, xmin, ymin, xmax, ymax, function):
    width, height = image.size       # rozmery obrazku
    stepx = (xmax - xmin)/width
    stepy = (ymax - ymin)/height

    y1 = ymin
    for y in range(0, height):
        x1 = xmin
        for x in range(0, width):
            x1 += stepx
            val = function(x1, y1)
            i = int(val) &amp; 255
            color = (palette[i][0], palette[i][1], palette[i][2])
            image.putpixel((x, y), color)
        y1 += stepy
</pre>

<p>Úplný zdrojový kód třetího příkladu vypadá následovně:</p>

<pre>
#!/usr/bin/env python

# Vytvoreni textury s "kruznicovym moare" i dalsimi typy moare

from PIL import Image
import palette_blues
import palette_greens
import palette_gold
import palette_ice
import palette_mandmap

# textura by mela byt ctvercova a jeji sirka i vyska by mela byt
# mocninou cisla 2
IMAGE_WIDTH = 256
IMAGE_HEIGHT = 256


# Funkce provadejici vypocet moare s kruznicovym vzorkem
def recalc_any_pattern(image, palette, xmin, ymin, xmax, ymax, function):
    width, height = image.size       # rozmery obrazku
    stepx = (xmax - xmin)/width
    stepy = (ymax - ymin)/height

    y1 = ymin
    for y in range(0, height):
        x1 = xmin
        for x in range(0, width):
            x1 += stepx
            val = function(x1, y1)
            i = int(val) &amp; 255
            color = (palette[i][0], palette[i][1], palette[i][2])
            image.putpixel((x, y), color)
        y1 += stepy


image = Image.new("RGB", (IMAGE_WIDTH, IMAGE_HEIGHT))

mez = (2 &lt;&lt; 5) + 30 * 2.5
recalc_any_pattern(image, palette_mandmap.palette, -mez, -mez, mez, mez, lambda x,y : x*x + y*y)
image.save("patternC_circle.png")

mez = (2 &lt;&lt; 5) + 30 * 2.5
recalc_any_pattern(image, palette_mandmap.palette, -mez, -mez, mez, mez, lambda x,y : x*x - y*y)
image.save("patternC_anticircle.png")

mez = 20.0
recalc_any_pattern(image, palette_mandmap.palette, -mez, -mez, mez, mez, lambda x,y : x**3 + y**3)
image.save("patternC_x3y3.png")

mez = 20.0
recalc_any_pattern(image, palette_mandmap.palette, -mez, -mez, mez, mez, lambda x,y : x**4 + y**4)
image.save("patternC_x4y4.png")

mez = 90.0
recalc_any_pattern(image, palette_mandmap.palette, -mez, -mez, mez, mez, lambda x,y : x*x + y*y + x*y*1.5)
image.save("patternC_var1.png")

mez = 20.0
recalc_any_pattern(image, palette_mandmap.palette, -mez, -mez, mez, mez, lambda x,y : x*x*y + y*y*x)
image.save("patternC_var2.png")
</pre>

<a href="https://mojefedora.cz/wp-content/uploads/2017/06/15-1.png"><img class="alignnone size-thumbnail wp-image-9113" src="https://mojefedora.cz/wp-content/uploads/2017/06/15-1-254x254.png" alt="" width="254" height="254" /></a>
<p><i>Obrázek 15: Textura vykreslená třetím demonstračním příkladem.</i></p>

<a href="https://mojefedora.cz/wp-content/uploads/2017/06/16.png"><img class="alignnone size-thumbnail wp-image-9114" src="https://mojefedora.cz/wp-content/uploads/2017/06/16-254x254.png" alt="" width="254" height="254" /></a>
<p><i>Obrázek 16: Další textura vykreslená třetím demonstračním příkladem.</i></p>

<a href="https://mojefedora.cz/wp-content/uploads/2017/06/17.png"><img class="alignnone size-thumbnail wp-image-9115" src="https://mojefedora.cz/wp-content/uploads/2017/06/17-254x254.png" alt="" width="254" height="254" /></a>
<p><i>Obrázek 17: Další textura vykreslená třetím demonstračním příkladem.</i></p>



<p><a name="k07"></a></p>
<h2 id="k07">7. Algoritmy pro vykreslení textury &bdquo;plasmy&ldquo;</h2>

<p>V&nbsp;počítačové grafice, zejména v&nbsp;demech, byl velmi oblíbený efekt plasmy, ať už vykreslený jako statický obrázek, či animovaná sekvence postupně se měnící plasmy. Plasmu je možné vytvořit několika způsoby, typicky metodou rekurzivního dělení čtverce, Fourierovou syntézou či rekurzivním dělením plochy. Nejdříve si stručně popíšeme metodu rekurzivního dělení čtverce.</p>

<a href="https://mojefedora.cz/wp-content/uploads/2017/06/18.png"><img class="alignnone size-thumbnail wp-image-9116" src="https://mojefedora.cz/wp-content/uploads/2017/06/18-254x254.png" alt="" width="254" height="254" /></a>
<p><i>Obrázek 18: Klasická plasma, v&nbsp;níž jsou intenzity převedeny na stupně šedi.</i></p>

<p>Obrázek plasmy se v&nbsp;tomto případě generuje upraveným midpoint algoritmem (algoritmem posunu středního bodu) rozšířeného do dvourozměrného prostoru, přičemž čtverec je nahrazen rastrovým obrázkem (pro jednoduchost ve stupních šedi), kde pozice každého pixelu odpovídá souřadnicím bodu v&nbsp;rovině <i>x-y</i> a barva pixelu, tj.&nbsp;úroveň šedé, zbývající <i>z</i>-ové souřadnici bodu. Generování plasmy začíná v&nbsp;rozích rastrového obrázku a v&nbsp;jednotlivých krocích rekurze je obrázek dělen na čtvrtiny až do chvíle, kdy se dojde k&nbsp;velikosti jednoho pixelu, který se již dále samozřejmě nedělí. Kromě obrázků ve stupních šedi je možné generovat i barevné obrázky. Ty se tvoří dvojím způsobem &ndash; buď aplikací barvové palety, nebo vytvořením tří obrázků, z&nbsp;nichž každý odpovídá jednomu barvovému kanálu R, G, B &ndash; viz též následující obrázek.</p>

<a href="https://mojefedora.cz/wp-content/uploads/2017/06/19.png"><img class="alignnone size-thumbnail wp-image-9117" src="https://mojefedora.cz/wp-content/uploads/2017/06/19-254x254.png" alt="" width="254" height="254" /></a>
<p><i>Obrázek 19: Tři plasmy, každá vypočtená pro jednu barvovou složku (R, G, B).</i></p>

<p>Pomocí výše uvedené metody je možné vytvářet působivé obrázky plasmy; pro některé vstupní parametry však mohou být na obrázcích patrné vodorovné a svislé přechody mezi barvami, které tvoří hranice mezi čtverci na několika nejvyšších úrovních dělení. Na nižších úrovních, cca od čtvrté iterace, hranice splývají, neboť dochází ke snižování amplitudy odchylky &Delta;. Opticky rušivé přechody vznikají z&nbsp;toho důvodu, že se při každém rozdělení čtverce posune pouze jeho prostřední bod (střed) a nikoli prostřední body jeho hran &ndash; pro jejich posun nemáme dostatek informací, protože nevíme, jakým způsobem budou rozděleny čtyři sousední čtverce. Existuje několik způsobů, jak nežádoucí přechody odstranit. Některé způsoby spočívají v&nbsp;odlišném dělení čtverce, například střídavě po úhlopříčkách a vodorovných/svislých hranách, jiné způsoby zavádí &bdquo;paměť&ldquo; posuvu prostředních bodů okolních čtverců apod.</p>

<a href="https://mojefedora.cz/wp-content/uploads/2017/06/20.png"><img class="alignnone size-thumbnail wp-image-9118" src="https://mojefedora.cz/wp-content/uploads/2017/06/20-254x254.png" alt="" width="254" height="254" /></a>
<p><i>Obrázek 20: Textura plasmy vygenerovaná třetím demonstračním příkladem.</i></p>

<p>Zajímavější (a poněkud neznámá) alternativní metoda, která už nespočívá v&nbsp;rekurzivním dělení čtverce, je založena na iterativním generování různě orientovaných přímek, které rozdělují obraz na dvě (obecně) nestejně velké poloviny. Po vygenerování náhodné přímky (ta po protnutí hranic obrázku vytvoří úsečku) se provedou následující operace:</p>

<ol>
<li>intenzita všech pixelů ležících nalevo od přímky se <i>sníží</i> o jedničku.</li>
<li>intenzita všech pixelů ležících napravo od přímky se naopak o jedničku <i>zvýší</i>.</p></li>
</ol>

<p>Pro vygenerování věrohodného obrázku plasmy je zapotřebí vytvoření přímky a snižování/zvyšování intenzity pixelů provádět v&nbsp;iterační smyčce mnohokrát, typická hodnota bývá 1&nbsp;000 &ndash; 10&nbsp;000 iterací. Po provedení takto vysokého množství iterací již hranice mezi různě orientovanými přímkami (resp.&nbsp;polorovinami) nejsou patrné. Po provedení všech iterací je nutné obrázek <i>normalizovat</i>, tj.&nbsp;nejnižší intenzitě pixelů (ta může být díky odčítání i záporná) přiřadit černou barvu a nejvyšší intenzitě barvu čistě bílou. Výsledkem těchto operací je plasma bez znatelných horizontálních či vertikálních hran.</p>

<a href="https://mojefedora.cz/wp-content/uploads/2017/06/21.png"><img class="alignnone size-thumbnail wp-image-9119" src="https://mojefedora.cz/wp-content/uploads/2017/06/21-254x254.png" alt="" width="254" height="254" /></a>
<p><i>Obrázek 21: Textura plasmy vygenerovaná třetím demonstračním příkladem.</i></p>



<p><a name="k08"></a></p>
<h2 id="k08">8. Dvourozměrná spektrální syntéza</h2>

<p>Spektrální syntéza je mimořádně vhodná pro použití v&nbsp;počítačové grafice, a to zejména z&nbsp;toho důvodu, že je ji možné relativně snadno rozšiřovat do více dimenzí (rozměrů). Pro jednorozměrný příklad je výsledkem křivka. Rozšíření do dvou dimenzí je jednoduché &ndash; výsledkem bude obrázek/textura plasmy a/nebo trojrozměrné výškové pole, které může představovat například model krajiny. Při použití tří dimenzí dostaneme jako výsledek trojrozměrnou mřížku, ve které jednotlivé objemové elementy (<i>voxely</i>) mohou představovat například hustotu prostoru v&nbsp;místě jejich výskytu. Tuto hustotu je posléze možné použít při generování reálně vypadajících modelů trojrozměrných oblak &ndash; to je velký rozdíl oproti oblakům vytvořených jako dvourozměrné textury, jejichž &bdquo;dvojrozměrnost&ldquo; je při některých projekcích patrná.</p>

<a href="https://mojefedora.cz/wp-content/uploads/2017/06/22.png"><img class="alignnone size-thumbnail wp-image-9120" src="https://mojefedora.cz/wp-content/uploads/2017/06/22-254x254.png" alt="" width="254" height="254" /></a>
<p><i>Obrázek 22: Textura plasmy vygenerovaná třetím demonstračním příkladem.</i></p>

<p>V&nbsp;případě dvourozměrné spektrální syntézy je fraktální dimenze výsledného obrázku rovna:</p>

<pre>
D=3-H
</pre>

<p>Přičemž hodnota takzvaného Hurstova exponentu H se pohybuje v rozsahu 0,0..1,0. Z&nbsp;toho vyplývá, že fraktální dimenze výsledné plasmy se pohybuje v&nbsp;rozsahu 2,0..3,0.</p>

<p>Pomocí těchto koeficientů je následně s využitím inverzní diskrétní Fourierovy transformace vypočten požadovaný obrázek plasmy:</p>

<pre>
X(x,y)=&sum;&sum;(A<sub>kl</sub>cos(kx+ly)­+B<sub>kl</sub>sin(kx+ly))
</pre>

<a href="https://mojefedora.cz/wp-content/uploads/2017/06/23.png"><img class="alignnone size-thumbnail wp-image-9121" src="https://mojefedora.cz/wp-content/uploads/2017/06/23-254x254.png" alt="" width="254" height="254" /></a>
<p><i>Obrázek 23: Textura plasmy vygenerovaná třetím demonstračním příkladem.</i></p>



<p><a name="k09"></a></p>
<h2 id="k09">9. Čtvrtý demonstrační příklad &ndash; použití dvourozměrné spektrální syntézy</h2>

<p>V&nbsp;dnešním čtvrtém demonstračním příkladu je spektrální syntéza použita pro vygenerování textur, u nichž je možné zvolit vlastní barvovou paletu a taktéž míru náhodnosti textury. Ta se určuje dvěma parametry &ndash; hodnotou takzvaného <i>Hurstova exponentu</i> a taktéž počtem koeficientů spektrální syntézy. Čím větší zvolíte počet koeficientů, tím déle se bude plasma vykreslovat. V&nbsp;programu používáme knihovnu <i>Numpy</i>, s&nbsp;níž jsme se již na stránkách mojefedora.cz <a href="https://mojefedora.cz/integrovana-vyvojova-prostredi-ve-fedore-prakticke-pouziti-ipython-notebooku-a-knihovny-numpy/">seznámili</a>.</p>

<p>První pomocnou funkcí je funkce pro vygenerování náhodného čísla v&nbsp;rozsahu 0 až 1 s&nbsp;přibližným Gaussovým rozložením (ve skutečnosti tuto funkci najdeme i v&nbsp;knihovně, ale je dobré vědět, jak funkce pracuje):</p>

<pre>
def random_gauss():
    '''
    Vygenerovani nahodneho cisla v rozsahu 0..1 s pribliznym
    Gaussovym rozlozenim
    '''
    N = 50
    sum = 0.0
    for i in range(N):
        sum += random()
    return sum/N
</pre>

<p>Další funkce již provádí vlastní syntézu. Funkci se předá obrázek, do něhož má být provedeno vykreslení, barvová paleta (seznam 256 trojic R, G, B), hodnota Hurstova exponentu a taktéž počet koeficientů spektrální syntézy. Celá funkce je rozdělena do tří částí. Nejprve se jedná o výpočet koeficientů Ak a Bk:</p>

<pre>
# h ... Hurstuv exponent
# n ... pocet koeficientu spektralni syntezy
def spectral_synthesis(image, palette, n, h):
    width, height = image.size      # rozmery obrazku

    bitmap = np.zeros([height, width])

    A = np.empty([n/2, n/2])        # koeficienty Ak
    B = np.empty([n/2, n/2])        # koeficienty Bk
    beta = 2.0 * h + 1              # promenna svazana s Hurstovym koeficientem

    print("calculate coefficients")

    # vypocet koeficientu Ak a Bk
    for j in range(n/2):
        for i in range(n/2):
            rad_i = pow((i+1), -beta/2.0)*random_gauss()
            rad_j = pow((j+1), -beta/2.0)*random_gauss()
            phase_i = 2.0*math.pi*random()
            phase_j = 2.0*math.pi*random()
            A[j][i] = rad_i*math.cos(phase_i)*rad_j*math.cos(phase_j)
            B[j][i] = rad_i*math.sin(phase_i)*rad_j*math.sin(phase_j)
</pre>

<p>Dále se vygeneruje plasma do pomocného dvourozměrného pole <strong>bitmap</strong>:</p>

<pre>
    # vygenerovani plasmy
    for j in range(height):
        for i in range(width):
            z = 0
            # inverzni Fourierova transformace
            for k in range(n/2):
                for l in range(n/2):
                    u = (i-n/2)*2.0*math.pi/width
                    v = (j-n/2)*2.0*math.pi/height
                    z += A[k][l]*math.cos(k*u+l*v)+B[k][l]*math.sin(k*u+l*v)
            bitmap[j][i] = z
</pre>

<p>Posléze je nutné najít maximální a minimální hodnotu v&nbsp;poli <strong>bitmap</strong>, přepočítat hodnoty tak, aby byly v&nbsp;rozsahu 0..255 a provést převod pole na obrázek (s&nbsp;aplikací barvové palety):</p>

<pre>
def compute_min_max(bitmap, width, height):
    # pro prepocet intenzit pixelu
    min = float("inf")
    max = float("-inf")

    # ziskani statistiky o obrazku - minimalni a maximalni hodnoty
    for j in range(height):
        for i in range(width):
            z = bitmap[j][i]
            if max &lt; z:
                max = z
            if min &gt; z:
                min = z
    return min, max


def convert_to_image(bitmap, image, width, height, palette):
    print("contrast adjustment")

    min, max = compute_min_max(bitmap, width, height)
    k = 255.0 / (max - min)

    # zmena kontrastu a kopie bitmapy
    for y in range(height):
        for x in range(width):
            f = float(bitmap[y][x])
            f -= min
            f *= k
            i = int(f) &amp; 255
            color = (palette[i][0], palette[i][1], palette[i][2])
            image.putpixel((x, y), color)
</pre>

<a href="https://mojefedora.cz/wp-content/uploads/2017/06/24.png"><img class="alignnone size-thumbnail wp-image-9122" src="https://mojefedora.cz/wp-content/uploads/2017/06/24-254x254.png" alt="" width="254" height="254" /></a>
<p><i>Obrázek 24: Textura plasmy vygenerovaná třetím demonstračním příkladem.</i></p>



<p><a name="k10"></a></p>
<h2 id="k10">10. Kompletní zdrojový kód čtvrtého demonstračního příkladu</h2>

<p><a href="#k09">V&nbsp;předchozí kapitole</a> jsme si popsali nejdůležitější části čtvrtého příkladu. Jeho kompletní zdrojový kód vypadá následovně:</p>

<pre>
#!/usr/bin/env python

# Vytvoreni textury typu "plasma"

from PIL import Image
from random import random
import palette_blues
import palette_greens
import palette_gold
import palette_ice
import palette_mandmap
import numpy as np
import math

# textura by mela byt ctvercova a jeji sirka i vyska by mela byt
# mocninou cisla 2
IMAGE_WIDTH = 256
IMAGE_HEIGHT = 256


def random_gauss():
    '''
    Vygenerovani nahodneho cisla v rozsahu 0..1 s pribliznym
    Gaussovym rozlozenim
    '''
    N = 50
    sum = 0.0
    for i in range(N):
        sum += random()
    return sum/N


def compute_min_max(bitmap, width, height):
    # pro prepocet intenzit pixelu
    min = float("inf")
    max = float("-inf")

    # ziskani statistiky o obrazku - minimalni a maximalni hodnoty
    for j in range(height):
        for i in range(width):
            z = bitmap[j][i]
            if max &lt; z:
                max = z
            if min &gt; z:
                min = z
    return min, max


def convert_to_image(bitmap, image, width, height, palette):
    print("contrast adjustment")

    min, max = compute_min_max(bitmap, width, height)
    k = 255.0 / (max - min)

    # zmena kontrastu a kopie bitmapy
    for y in range(height):
        for x in range(width):
            f = float(bitmap[y][x])
            f -= min
            f *= k
            i = int(f) &amp; 255
            color = (palette[i][0], palette[i][1], palette[i][2])
            image.putpixel((x, y), color)


# h ... Hurstuv exponent
# n ... pocet koeficientu spektralni syntezy
def spectral_synthesis(image, palette, n, h):
    width, height = image.size      # rozmery obrazku

    bitmap = np.zeros([height, width])

    A = np.empty([n/2, n/2])        # koeficienty Ak
    B = np.empty([n/2, n/2])        # koeficienty Bk
    beta = 2.0 * h + 1              # promenna svazana s Hurstovym koeficientem

    print("calculate coefficients")

    # vypocet koeficientu Ak a Bk
    for j in range(n/2):
        for i in range(n/2):
            rad_i = pow((i+1), -beta/2.0)*random_gauss()
            rad_j = pow((j+1), -beta/2.0)*random_gauss()
            phase_i = 2.0*math.pi*random()
            phase_j = 2.0*math.pi*random()
            A[j][i] = rad_i*math.cos(phase_i)*rad_j*math.cos(phase_j)
            B[j][i] = rad_i*math.sin(phase_i)*rad_j*math.sin(phase_j)

    print("plasma synthesis")

    # vygenerovani plasmy
    for j in range(height):
        for i in range(width):
            z = 0
            # inverzni Fourierova transformace
            for k in range(n/2):
                for l in range(n/2):
                    u = (i-n/2)*2.0*math.pi/width
                    v = (j-n/2)*2.0*math.pi/height
                    z += A[k][l]*math.cos(k*u+l*v)+B[k][l]*math.sin(k*u+l*v)
            bitmap[j][i] = z

    convert_to_image(bitmap, image, width, height, palette)


image = Image.new("RGB", (IMAGE_WIDTH, IMAGE_HEIGHT))

spectral_synthesis(image, palette_greens.palette, 4, 0.5)
image.save("patternD_plasma1.png")

spectral_synthesis(image, palette_blues.palette, 10, 0.5)
image.save("patternD_plasma2.png")

spectral_synthesis(image, palette_mandmap.palette, 5, 0.1)
image.save("patternD_plasma3.png")

spectral_synthesis(image, palette_mandmap.palette, 5, 1.0)
image.save("patternD_plasma4.png")

spectral_synthesis(image, palette_gold.palette, 15, 0.5)
image.save("patternD_plasma5.png")

spectral_synthesis(image, palette_ice.palette, 15, 0.8)
image.save("patternD_plasma6.png")
</pre>

<a href="https://mojefedora.cz/wp-content/uploads/2017/06/25.png"><img class="alignnone size-thumbnail wp-image-9123" src="https://mojefedora.cz/wp-content/uploads/2017/06/25-254x254.png" alt="" width="254" height="254" /></a>
<p><i>Obrázek 25: Textura plasmy vygenerovaná třetím demonstračním příkladem.</i></p>



<p><a name="k11"></a></p>
<h2 id="k11">11. Perlinova šumová funkce</h2>

<p>Další způsob tvorby procedurálních textur je založena na takzvané Perlinově šumové funkci. Perlinova šumová funkce byla s&nbsp;velkým úspěchem použita v&nbsp;mnoha aplikacích počítačové grafiky; například prakticky každý film, ve kterém je použita renderovaná grafika, tuto funkci nějakým způsobem použil. Její úspěch spočívá v&nbsp;tom, že se pomocí ní dají do původně přesných a "počítačově chladných" modelů vnést náhodné prvky, takže se model či celá vytvářená scéna přiblíží realitě. Podobný princip vnesení náhodnosti ostatně umožňují i fraktály, zejména ty vytvářené na stochastickém základě (plasma, stochastické L-systémy apod.). Perlin šumovou funkci navrhl už v&nbsp;roce 1983, v&nbsp;roce 1985 o její aplikaci vznikl článek prezentovaný na SIGGRAPHu (jedna z&nbsp;nejvýznamnějších konferencí počítačové grafiky) a v&nbsp;letech 1986 až 1988 tuto funkci s&nbsp;některými modifikacemi používaly takové firmy, jako Pixar, Alias, SoftImage apod.</p>

<a href="https://mojefedora.cz/wp-content/uploads/2017/06/26.jpg"><img class="alignnone size-thumbnail wp-image-9124" src="https://mojefedora.cz/wp-content/uploads/2017/06/26.jpg" alt="" width="240" height="240" /></a>
<p><i>Obrázek 26: Perlinova šumová funkce použitá při generování dvourozměrných textur.</i></p></p>



<p><a name="k12"></a></p>
<h2 id="k12">12. Princip šumové funkce</h2>

<p>Při tvorbě textur, které by měly reprezentovat přírodní vzorky, jako je mramor, dřevo či mraky, není možné použít ani klasický generátor pseudonáhodných čísel RNG (tím je myšlena například například <i>rand()</i> ze standardní céčkové knihovny), ale ani základní matematické funkce. V&nbsp;minulosti byly prováděny pokusy o využití goniometrických funkcí, které posléze vyústily v&nbsp;úspěšnou metodu generování <i>plasmy</i> pomocí Fourierovy syntézy, což je téma, kterému jsme se věnovali výše. Při přímé aplikaci generátorů pseudonáhodných čísel sice získáme šum, ten je však příliš náhodný a vůbec se nehodí pro generování textur, a to ani po své filtraci.</p>

<a href="https://mojefedora.cz/wp-content/uploads/2017/06/27.jpg"><img class="alignnone size-thumbnail wp-image-9125" src="https://mojefedora.cz/wp-content/uploads/2017/06/27.jpg" alt="" width="320" height="240" /></a>
<p><i>Obrázek 27: Jednorozměrná Perlinova šumová funkce s&nbsp;parametry alpha=2, beta=2, n=10.</i></p>

<p>Perlin pro účely vytváření přírodních textur navrhl výpočet, který sice využívá generátor pseudonáhodných čísel, ale mezi jednotlivými vypočtenými náhodnými hodnotami je prováděna interpolace, která výsledný průběh funkce vyhladí, takže se již nebude jednat o zcela náhodný šum. Pro vyhlazení je možné použít velké množství matematických funkcí, od jednoduché lineární interpolace přes kvadratické a kubické funkce až po funkce goniometrické a jejich vzájemné kombinace. Perlin použil (pokud celý popis jeho postupu značně zjednodušíme) dvojici funkcí, první nazvanou <i>s_curve()</i> a druhou nazvanou <i>lerp()</i>. Při výpočtu šumu je nejdříve použita funkce <i>s_curve()</i>, posléze se získají dvě náhodné hodnoty a na výsledek je aplikována funkce <i>lerp()</i>. Funkce <i>s_curve()</i> má tvar:</p>

<p><i>s_curve(t)=(t<sup>2</sup>*(3-2t))</i></p>

<p><i>Obrázek 28: Průběh funkce <i>s_curve()</i>; na horizontální ose je použito jiné měřítko, než v&nbsp;originálních Perlinových zdrojových kódech. Ve skutečnosti je v&nbsp;praxi využit pouze rozsah vstupních hodnot 0..1 (na grafu 0..20), sestupná část již nikoli.</i></p>

<p>Funkce <i>lerp()</i> má tvar:</p>

<p><i>lerp(t, a, b)=(a+t(b-a))</i></p>

<p>Všimněte si, že se v&nbsp;tomto případě nejedná o nic jiného, než o lineární interpolaci řízenou parametrem <i>t</i>. Pro <i>t=0,0</i> je výsledkem funkce hodnota <i>a</i>, pro <i>t=1,0</i> pak hodnota <i>b</i>. Konkrétní hodnota parametru <i>t</i> je získána výpočtem výše uvedené funkce <i>s_curve()</i>.</p>



<p><a name="k13"></a></p>
<h2 id="k13">13. Aplikace Perlinovy šumové funkce</h2>

<p>Perlinovu šumovou funkci je možné v&nbsp;počítačové grafice všestranně použít k&nbsp;vytváření mnoha různých přírodních vzorků, například mramoru, textury dřeva, ohně, mraků, kamenů hor atd. atd. Všechny výše uvedené funkce je možné různými způsoby modifikovat, například do výpočtů prováděných ve funkcích <strong>PerlinNoise1D()</strong> a <strong>PerlinNoise2D</strong> přidávat další matematické funkce. Často se původní Perlinova funkce upravuje tak, že se sčítají absolutní hodnoty dílčích šumů (což budeme používat i my v&nbsp;demonstračním příkladu), přidává se goniometrická funkce sinus atd.</p>

<a href="https://mojefedora.cz/wp-content/uploads/2017/06/29.png"><img class="alignnone size-thumbnail wp-image-9127" src="https://mojefedora.cz/wp-content/uploads/2017/06/29-254x254.png" alt="" width="254" height="254" /></a>
<p><i>Obrázek 29: Textura vytvořená pomocí Perlinovy funkce pátým příkladem.</i></p>

<p>Mnohem důležitější je však rozšíření výpočtů do trojrozměrného prostoru. Programově se nejedná o žádnou komplikaci (viz snadný a přímočarý přechod z&nbsp;1D na 2D), ovšem dopad na možnosti využití je značný. Dvourozměrné textury mají několik vážných nevýhod, z&nbsp;nichž ta největší spočívá v&nbsp;obtížném mapování na nerovné povrchy. Například mapování obdélníkové textury na kouli vede k&nbsp;tomu, že se textura na pólech smrští a naopak na rovníku příliš roztáhne. Výsledek je většinou neuspokojivý, zvláště při aplikaci šumové funkce (ta by měla být směrově invariantní). Přechodem k&nbsp;výpočtům 3D (volumetrických) textur se tohoto problému zbavíme (viz obrázek číslo 1 zobrazený <a href="#k01">v&nbsp;úvodní kapitole</a>), protože pro každý bod v&nbsp;prostoru je možné zjistit hodnotu šumu bez nutnosti mapování.</p>

<a href="https://mojefedora.cz/wp-content/uploads/2017/06/30.png"><img class="alignnone size-thumbnail wp-image-9128" src="https://mojefedora.cz/wp-content/uploads/2017/06/30-254x254.png" alt="" width="254" height="254" /></a>
<p><i>Obrázek 30: Textura vytvořená pomocí Perlinovy funkce pátým příkladem.</i></p>

<p>3D textury se často používají v&nbsp;raytracerech, kde se projevuje i jejich další přednost &ndash; jejich hodnotu je možné vypočítat pro libovolný bod v&nbsp;prostoru, není tedy nutné nejprve provést výpočet textury v&nbsp;nějakém rastru. Tím ušetříme velké množství paměti (3D rastrové textury mají obrovské paměťové nároky), nebude docházet k&nbsp;aliasu a také je možné texturu animovat, například postupnou změnou některého z&nbsp;parametrů (barvové palety, parametru <i>alpha</i>, <i>beta</i>, <i>n</i> atd.)</p>

<a href="https://mojefedora.cz/wp-content/uploads/2017/06/31.png"><img class="alignnone size-thumbnail wp-image-9129" src="https://mojefedora.cz/wp-content/uploads/2017/06/31-254x254.png" alt="" width="254" height="254" /></a>
<p><i>Obrázek 31: Textura vytvořená pomocí Perlinovy funkce pátým příkladem.</i></p>



<p><a name="k14"></a></p>
<h2 id="k14">14. Pátý demonstrační příklad &ndash; 2D textura vykreslená Perlinovou funkcí</h2>

<p>V&nbsp;pátém a současně i dnešním posledním příkladu si ukážeme způsob vytvoření jednoduché textury pomocí Perlinovy šumové funkce. I tento příklad je rozdělen na několik částí a pomocných funkcí. Například funkce <strong>random_array()</strong> vrátí dvourozměrné pole náhodných hodnot o specifikované amplitudě:</p>

<pre>
def random_array(width, height, amplitude):
    return [[random() * amplitude for i in range(width)]
            for j in range(height)]
</pre>

<p>Nejdůležitější částí je funkce nazvaná <strong>perlin_noise()</strong>, která postupně (pro specifikovaný počet &bdquo;oktáv&ldquo;) vytvoří pole náhodných hodnot a posléze mezi nimi provede interpolaci. Pole náhodných hodnot se postupně zvětšuje (v&nbsp;obou směrech), takže čím více oktáv je zadaných, tím náhodnější výsledná textura bude:</p>

<pre>
def perlin_noise(image, palette, noise, octaves):
    width, height = image.size       # rozmery obrazku

    bitmap = np.zeros([height, width])

    # postupne vytvoreni 'octaves' vrstev v obrazku
    for k in range(octaves):
        size = 2 ** k + 1
        amplitude = noise ** k

        # vytvoreni pole nahodnych cisel o dane amplidude
        array = random_array(size, size, amplitude)

        n = width / float(size-1.0)

        # interpolace hodnot v poli nahodnych cisel
        for y in range(height):
            for x in range(width):
                i = int(x / n)   # prepocet mezi pozici pixelu a indexem v poli
                j = int(y / n)
                x0 = x - i * n
                x1 = n - x0
                y0 = y - j * n
                y1 = n - y0
                # interpolace
                z = array[j][i] * x1 * y1
                z += array[j][i + 1] * x0 * y1
                z += array[j + 1][i] * x1 * y0
                z += array[j + 1][i + 1] * x0 * y0
                z /= n * n
                bitmap[y][x] += z
</pre>

<p>Kompletní zdrojový kód tohoto příkladu vypadá takto (opět je použita knihovna Numpy):</p>

<pre>
#!/usr/bin/env python

# Perlinuv sum

from PIL import Image
from random import random
import palette_blues
import palette_greens
import palette_gold
import palette_ice
import palette_mandmap
import numpy as np
import math

# textura by mela byt ctvercova a jeji sirka i vyska by mela byt
# mocninou cisla 2
IMAGE_WIDTH = 256
IMAGE_HEIGHT = 256


def compute_min_max(bitmap, width, height):
    # pro prepocet intenzit pixelu
    min = float("inf")
    max = float("-inf")

    # ziskani statistiky o obrazku - minimalni a maximalni hodnoty
    for j in range(height):
        for i in range(width):
            z = bitmap[j][i]
            if max &lt; z:
                max = z
            if min &gt; z:
                min = z
    return min, max


def convert_to_image(bitmap, image, width, height, palette):
    print("contrast adjustment")

    min, max = compute_min_max(bitmap, width, height)
    k = 255.0 / (max - min)

    # zmena kontrastu a kopie bitmapy
    for y in range(height):
        for x in range(width):
            f = float(bitmap[y][x])
            f -= min
            f *= k
            i = int(f) &amp; 255
            color = (palette[i][0], palette[i][1], palette[i][2])
            image.putpixel((x, y), color)


def random_array(width, height, amplitude):
    return [[random() * amplitude for i in range(width)]
            for j in range(height)]


def perlin_noise(image, palette, noise, octaves):
    width, height = image.size       # rozmery obrazku

    bitmap = np.zeros([height, width])

    # postupne vytvoreni 'octaves' vrstev v obrazku
    for k in range(octaves):
        size = 2 ** k + 1
        amplitude = noise ** k

        # vytvoreni pole nahodnych cisel o dane amplidude
        array = random_array(size, size, amplitude)

        n = width / float(size-1.0)

        # interpolace hodnot v poli nahodnych cisel
        for y in range(height):
            for x in range(width):
                i = int(x / n)   # prepocet mezi pozici pixelu a indexem v poli
                j = int(y / n)
                x0 = x - i * n
                x1 = n - x0
                y0 = y - j * n
                y1 = n - y0
                # interpolace
                z = array[j][i] * x1 * y1
                z += array[j][i + 1] * x0 * y1
                z += array[j + 1][i] * x1 * y0
                z += array[j + 1][i + 1] * x0 * y0
                z /= n * n
                bitmap[y][x] += z

    convert_to_image(bitmap, image, width, height, palette)


image = Image.new("RGB", (IMAGE_WIDTH, IMAGE_HEIGHT))

perlin_noise(image, palette_mandmap.palette, 0.7, 6)
image.save("patternE_perlin_noise1.png")

perlin_noise(image, palette_mandmap.palette, 0.7, 7)
image.save("patternE_perlin_noise2.png")

perlin_noise(image, palette_blues.palette, 0.7, 9)
image.save("patternE_perlin_noise3.png")

perlin_noise(image, palette_gold.palette, 0.7, 11)
image.save("patternE_perlin_noise4.png")

perlin_noise(image, palette_greens.palette, 0.3, 12)
image.save("patternE_perlin_noise5.png")
</pre>

<a href="https://mojefedora.cz/wp-content/uploads/2017/06/32.png"><img class="alignnone size-thumbnail wp-image-9130" src="https://mojefedora.cz/wp-content/uploads/2017/06/32-254x254.png" alt="" width="254" height="254" /></a>
<p><i>Obrázek 32: Textura vytvořená pomocí Perlinovy funkce pátým příkladem.</i></p>



<p><a name="k15"></a></p>
<h2 id="k15">15. Repositář s&nbsp;demonstračními příklady</h2>

<p>Všechny dnes popsané demonstrační příklady byly uloženy do Git repositáře dostupného na adrese <a href="https://github.com/tisnik/presentations">https://github.com/tisnik/presentations</a>. Příklady si můžete v&nbsp;případě potřeby stáhnout i jednotlivě bez nutnosti klonovat celý repositář. Pro jejich spuštění je nutné mít nainstalovanou jak knihovnu Pyglet, tak i podpůrné grafické knihovny OpenGL a GLU (což se většinou provede automaticky v&nbsp;rámci instalace balíčku s&nbsp;Pygletem, viz též <a href="https://mojefedora.cz/multimedialni-knihovna-pyglet/">úvodní díl tohoto seriálu</a>):</p>

<table>
<tr><th>Příklad</th><th>Odkaz</th></tr>
<tr><td>49_circle_moire.py</td><td><a href="https://github.com/tisnik/presentations/blob/master/pyglet/49_circle_moire.py">https://github.com/tisnik/presentations/blob/master/pyglet/49_circle_moire.py</a></td></tr>
<tr><td>50_circle_moire_with_palette.py</td><td><a href="https://github.com/tisnik/presentations/blob/master/pyglet/50_circle_moire_with_palette.py">https://github.com/tisnik/presentations/blob/master/pyglet/50_circle_moire_with_palette.py</a></td></tr>
<tr><td>51_more_patterns.py</td><td><a href="https://github.com/tisnik/presentations/blob/master/pyglet/51_more_patterns.py">https://github.com/tisnik/presentations/blob/master/pyglet/51_more_patterns.py</a></td></tr>
<tr><td>52_plasma.py</td><td><a href="https://github.com/tisnik/presentations/blob/master/pyglet/52_plasma.py">https://github.com/tisnik/presentations/blob/master/pyglet/52_plasma.py</a></td></tr>
<tr><td>53_perlin.py</td><td><a href="https://github.com/tisnik/presentations/blob/master/pyglet/53_perlin.py">https://github.com/tisnik/presentations/blob/master/pyglet/53_perlin.py</a></td></tr>
</table>

<p>Dalších pět souborů obsahuje deklaraci barvových palet:</p>

<table>
<tr><td>palette_blues.py</td><td><a href="https://github.com/tisnik/presentations/blob/master/pyglet/palette_blues.py">https://github.com/tisnik/presentations/blob/master/pyglet/palette_blues.py</a></td></tr>
<tr><td>palette_gold.py</td><td><a href="https://github.com/tisnik/presentations/blob/master/pyglet/palette_gold.py">https://github.com/tisnik/presentations/blob/master/pyglet/palette_gold.py</a></td></tr>
<tr><td>palette_greens.py</td><td><a href="https://github.com/tisnik/presentations/blob/master/pyglet/palette_greens.py">https://github.com/tisnik/presentations/blob/master/pyglet/palette_greens.py</a></td></tr>
<tr><td>palette_ice.py</td><td><a href="https://github.com/tisnik/presentations/blob/master/pyglet/palette_ice.py">https://github.com/tisnik/presentations/blob/master/pyglet/palette_ice.py</a></td></tr>
<tr><td>palette_mandmap.py</td><td><a href="https://github.com/tisnik/presentations/blob/master/pyglet/palette_mandmap.py">https://github.com/tisnik/presentations/blob/master/pyglet/palette_mandmap.py</a></td></tr>
</table>

<a href="https://mojefedora.cz/wp-content/uploads/2017/06/33.png"><img class="alignnone size-thumbnail wp-image-9131" src="https://mojefedora.cz/wp-content/uploads/2017/06/33-254x254.png" alt="" width="254" height="254" /></a>
<p><i>Obrázek 33: Textura vytvořená pomocí Perlinovy funkce pátým příkladem.</i></p>



<p><a name="k16"></a></p>
<h2 id="k16">16. Odkazy na Internetu</h2>

<ol>

<li>The Perlin noise math FAQ<br />
<a href="https://mzucker.github.io/html/perlin-noise-math-faq.html">https://mzucker.github.io/html/perlin-noise-math-faq.html</a>
</li>

<li>Perlin noise<br />
<a href="https://en.wikipedia.org/wiki/Perlin_noise">https://en.wikipedia.org/wiki/Perlin_noise</a>
</li>

<li>Perlin Noise Generator (Python recipe)<br />
<a href="http://code.activestate.com/recipes/578470-perlin-noise-generator/">http://code.activestate.com/recipes/578470-perlin-noise-generator/</a>
</li>

<li>Simplex noise demystified<br />
<a href="http://www.itn.liu.se/~stegu/simplexnoise/simplexnoise.pdf">http://www.itn.liu.se/~stegu/simplexnoise/simplexnoise.pdf</a>
</li>

<li>glTexEnv - příkaz OpenGL<br />
<a href="https://www.khronos.org/registry/OpenGL-Refpages/gl2.1/xhtml/glTexEnv.xml">https://www.khronos.org/registry/OpenGL-Refpages/gl2.1/xhtml/glTexEnv.xml</a>
</li>

<li>glGetTexEnv - příkaz OpenGL<br />
<a href="https://www.khronos.org/registry/OpenGL-Refpages/gl2.1/xhtml/glGetTexEnv.xml">https://www.khronos.org/registry/OpenGL-Refpages/gl2.1/xhtml/glGetTexEnv.xml</a>
</li>

<li>Pyglet Home Page<br />
<a href="https://bitbucket.org/pyglet/pyglet/wiki/Home">https://bitbucket.org/pyglet/pyglet/wiki/Home</a>
</li>

<li>Dokumentace k verzi 1.2<br />
<a href="https://pyglet.readthedocs.io/en/pyglet-1.2-maintenance/">https://pyglet.readthedocs.io/en/pyglet-1.2-maintenance/</a>
</li>

<li>Dokumentace k verzi 1.2 ve formátu PDF<br />
<a href="https://readthedocs.org/projects/pyglet/downloads/pdf/pyglet-1.2-maintenance/">https://readthedocs.org/projects/pyglet/downloads/pdf/pyglet-1.2-maintenance/</a>
</li>

<li>PyOpenGL<br />
<a href="http://pyopengl.sourceforge.net/">http://pyopengl.sourceforge.net/</a>
</li>

<li>The #! magic, details about the shebang/hash-bang mechanism on various Unix flavours<br />
<a href="https://www.in-ulm.de/~mascheck/various/shebang/">https://www.in-ulm.de/~mascheck/various/shebang/</a>
</li>

<li>Shebang (Unix)<br />
<a href="https://en.wikipedia.org/wiki/Shebang_%28Unix%29">https://en.wikipedia.org/wiki/Shebang_%28Unix%29</a>
</li>

<li>Domovská stránka systému LÖVE<br />
<a href="http://love2d.org/">http://love2d.org/</a>
</li>

<li>Simple DirectMedia Layer (home page)<br />
<a href="http://www.libsdl.org/">http://www.libsdl.org/</a>
</li>

<li>Simple DirectMedia Layer (Wikipedia)<br />
<a href="https://en.wikipedia.org/wiki/Simple_DirectMedia_Layer">https://en.wikipedia.org/wiki/Simple_DirectMedia_Layer</a>
</li>

<li>Seriál Grafická knihovna OpenGL<br />
<a href="https://www.root.cz/serialy/graficka-knihovna-opengl/">https://www.root.cz/serialy/graficka-knihovna-opengl/</a>
</li>

<li>Pyglet event loop<br />
<a href="http://pyglet.readthedocs.io/en/latest/programming_guide/eventloop.html">http://pyglet.readthedocs.io/en/latest/programming_guide/eventloop.html</a>
</li>

<li>Decorators I: Introduction to Python Decorators<br />
<a href="http://www.artima.com/weblogs/viewpost.jsp?thread=240808">http://www.artima.com/weblogs/viewpost.jsp?thread=240808</a>
</li>

<li>3D Programming in Python - Part 1 <br />
<a href="https://greendalecs.wordpress.com/2012/04/21/3d-programming-in-python-part-1/">https://greendalecs.wordpress.com/2012/04/21/3d-programming-in-python-part-1/</a>
</li>

<li>A very basic Pyglet tutorial<br />
<a href="http://www.natan.termitnjak.net/tutorials/pyglet_basic.html">http://www.natan.termitnjak.net/tutorials/pyglet_basic.html</a>
</li>

<li>Alpha blending<br />
<a href="https://en.wikipedia.org/wiki/Alpha_compositing#Alpha_blending">https://en.wikipedia.org/wiki/Alpha_compositing#Alpha_blending</a>
</li>

</ol>



<p></p><p></p>
<p><small>Autor: <a href="http://www.fit.vutbr.cz/~tisnovpa">Pavel Tišnovský</a> &nbsp; 2017</small></p>
</body>
</html>

