<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
        "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html>
<head>
<title>Programovací jazyk Rust: použití FFI pro volání funkcí z nativních knihoven</title>
<meta name="Author" content="Pavel Tisnovsky" />
<meta name="Generator" content="vim" />
<meta http-equiv="content-type" content="text/html; charset=utf-8" />
<style type="text/css">
         body {color:#000000; background:#ffffff;}
         h1  {font-family: arial, helvetica, sans-serif; color:#ffffff; background-color:#c00000; text-align:center; padding-left:1em}
         h2  {font-family: arial, helvetica, sans-serif; color:#ffffff; background-color:#0000c0; padding-left:1em; text-align:left}
         h3  {font-family: arial, helvetica, sans-serif; color:#000000; background-color:#c0c0c0; padding-left:1em; text-align:left}
         h4  {font-family: arial, helvetica, sans-serif; color:#000000; background-color:#e0e0e0; padding-left:1em; text-align:left}
         a   {font-family: arial, helvetica, sans-serif;}
         li  {font-family: arial, helvetica, sans-serif; color:#000000; text-align:justify; width:450px;}
         ol  {font-family: arial, helvetica, sans-serif; color:#000000; text-align:justify; width:450px;}
         ul  {font-family: arial, helvetica, sans-serif; color:#000000; text-align:justify; width:450px;}
         p   {font-family: arial, helvetica, sans-serif; color:#000000; text-align:justify;}
         pre {background:#e0e0e0}
</style>
</head>

<body>

<h1>Programovací jazyk Rust: použití FFI pro volání funkcí z nativních knihoven</h1>

<h3>Pavel Tišnovský</h3>

<p></p>

<h1>Úvodník</h1>

<p></p>



<h2>Obsah</h2>

<p><a href="#k01">*** 1. Programovací jazyk Rust: použití FFI pro volání funkcí z&nbsp;nativních knihoven</a></p>
<p><a href="#k02">2. Céčkový zdrojový kód s&nbsp;nativní funkcí</a></p>
<p><a href="#k03">3. Překlad funkce do objektového souboru a vytvoření statické knihovny</a></p>
<p><a href="#k04">4. Použití statické knihovny v&nbsp;Rustu</a></p>
<p><a href="#k05">5. Překlad a spuštění aplikace psané v&nbsp;Rustu, která volá funkci ze statické knihovny</a></p>
<p><a href="#k06">6. Zjednodušení procesu překladu a spouštění: jednoduchý <strong>Makefile</strong></a></p>
<p><a href="#k07">7. Překlad funkce do objektového souboru a vytvoření dynamické knihovny</a></p>
<p><a href="#k08">*** 8. Použití dynamické knihovny v&nbsp;Rustu</a></p>
<p><a href="#k09">*** 9. Překlad a spuštění aplikace psané v&nbsp;Rustu, která volá funkci z&nbsp;dynamické knihovny</a></p>
<p><a href="#k11">*** 11. Problematika řetězců &ndash; C versus Rust</a></p>
<p><a href="#k12">*** 12. Předání řetězce do volané nativní funkce</a></p>
<p><a href="#k13">*** 13. Dangling pointers a jak je nevytvářet</a></p>
<p><a href="#k14">*** 14. Kódování znaků v&nbsp;řetězcích</a></p>
<p><a href="#k15">*** 15. Vypsání adresy ukazatele a předání řetězce s&nbsp;českými znaky do nativní funkce</a></p>
<p><a href="#k16">16. Repositář s&nbsp;demonstračními příklady</a></p>
<p><a href="#k17">17. Odkazy na Internetu</a></p>



<p><a name="k01"></a></p>
<h2 id="k01">1. Programovací jazyk Rust: použití FFI pro volání funkcí z&nbsp;nativních knihoven</h2>



<p><a name="k02"></a></p>
<h2 id="k02">2. Céčkový zdrojový kód s&nbsp;nativní funkcí</h2>

<p>Pro jednoduchost předpokládejme, že budeme potřebovat zavolat nativní
funkci, která sečte dvě celá čísla (se znaménkem) a vrátí vypočtený výsledek.
První verze této funkce (naprogramované v&nbsp;céčku) může vypadat
následovně:</p>

<pre>
int add(int x, int y)
{
    return x+y;
}
</pre>

<p>Takovou funkci je samozřejmě možné přeložit a použít, ovšem při volání
funkce <strong>add</strong> z&nbsp;Rustu se můžeme poměrně rychle dostat do
problémů ve chvíli, kdy šířka datového typu <strong>int</strong> nebude přesně
odpovídat datovému typu použitému na straně Rustu (připomeňme si, že Rust je
portován na 32bitové i 64bitové CPU a navíc jeho variantu nalezneme i na
šestnáctibitových mikrořadičích <a
href="https://www.root.cz/clanky/sestnactibitove-mikroradice-ti-rady-msp430/">MSP430</a>).
Navíc ani nedochází ke kontrole, zda jsou šířky datových typů použity korektně.
Proto je bezpečnější uvádět datové typy parametrů funkce i její návratové
hodnoty zcela explicitně, například takto:</p>

<pre>
#include &lt;stdint.h&gt;
&nbsp;
<strong>int32_t</strong> add(<strong>int32_t</strong> x, <strong>int32_t</strong> y)
{
    return x+y;
}
</pre>

<p>Převodní tabulka mezi celočíselnými typy v&nbsp;C a typy Rustu:</p>

<table>
<tr><th>Typ v C</th><th>Typ v Rustu</th><th>Význam</th></tr>
<tr><td>int8_t   </td><td>i8 </td><td>celé číslo se znaménkem (<i>signed</i>) o šířce 8 bitů</td></tr>
<tr><td>int16_t  </td><td>i16</td><td>celé číslo se znaménkem (<i>signed</i>) o šířce 16 bitů</td></tr>
<tr><td>int32_t  </td><td>i32</td><td>celé číslo se znaménkem (<i>signed</i>) o šířce 32 bitů</td></tr>
<tr><td>int64_t  </td><td>i64</td><td>celé číslo se znaménkem (<i>signed</i>) o šířce 64 bitů</td></tr>
<tr><td>uint8_t  </td><td>u8 </td><td>celé číslo bez znaménka (<i>unsigned</i>) o šířce 8 bitů</td></tr>
<tr><td>uint16_t </td><td>u16</td><td>celé číslo bez znaménka (<i>unsigned</i>) o šířce 16 bitů</td></tr>
<tr><td>uint32_t </td><td>u32</td><td>celé číslo bez znaménka (<i>unsigned</i>) o šířce 32 bitů</td></tr>
<tr><td>uint64_t </td><td>u64</td><td>celé číslo bez znaménka (<i>unsigned</i>) o šířce 64 bitů</td></tr>
</table>



<p><a name="k03"></a></p>
<h2 id="k03">3. Překlad funkce do objektového souboru a vytvoření statické knihovny</h2>

<p>V&nbsp;prvním kroku céčkovský zdrojový kód přeložíme překladačem <i>gcc</i>
(lze však použít i <i>clang</i>), a to následujícím způsobem:</p>

<pre>
gcc -Wall -ansi -c ffi1.c -o ffi1.o
</pre>

<p>Poznámka: na rozdíl od druhého příkladu nemusíme při kompilaci uvádět
přepínač <strong>-fPIC</strong> zajištující vygenerování <a
href="https://cs.wikipedia.org/wiki/Position-independent_code">pozičně
nezávislého strojového kódu</a> (<i>Position-Independent Code</i>).</p>

<p>V&nbsp;kroku druhém dojde k&nbsp;vytvoření statické knihovny. Pro tento účel
použijeme nástroj <strong>ar</strong> s&nbsp;přepínači &bdquo;r&ldquo; (přidání
souboru do archivu představujícího statickou knihovnu), &bdquo;c&ldquo;
(vytvoření archivu/knihovny) a &bdquo;s&ldquo; (vytvoření indexu). Přepínače se
z&nbsp;historických důvodů mohou uvádět bez znaku pomlčky:</p>

<pre>
ar rcs libffi1.a ffi1.o
</pre>

<p>Pokud chcete zjistit, jaké symboly (popř.&nbsp;i kód) se v&nbsp;knihovně
nachází, použijte nástroj <strong>nm</strong>:</p>

<pre>
<strong>nm -s libffi1.a </strong>
&nbsp;
Archive index:
add in ffi1.o
&nbsp;
ffi1.o:
0000000000000000 T add
</pre>



<p><a name="k04"></a></p>
<h2 id="k04">4. Použití statické knihovny v&nbsp;Rustu</h2>

<p>Pokud budeme chtít nativní funkci <strong>add</strong> zavolat z&nbsp;Rustu,
je nutné specifikovat, ve které knihovně je uložen strojový kód funkce a zda se
jedná o knihovnu statickou či dynamickou. Dále je nutné v&nbsp;bloku
<strong>extern {}</strong> uvést hlavičku funkce s&nbsp;použitím typů Rustu.
Pro funkci se dvěma celočíselnými 32bitovými parametry se znaménkem, která
vrací stejný typ (32bitové celé číslo se znaménkem) a která je uložena ve
statické knihovně <strong>libffi1.a</strong> je deklarace následující:</p>

<pre>
#[link(name = "ffi1", kind="static")]
extern {
    fn add(x:i32, y:i32) -&gt; i32;
}
</pre>

<p>Ze jména &bdquo;ffi1&ldquo; je odvozen název knihovny, parametr
&bdquo;kind&ldquo; specifikuje knihovnu statickou (u dynamické knihovny se
neuvádí).</p>

<p>Zavolání nativní funkce je snadné:</p>

<pre>
let x:i32 = 1;
let y:i32 = 2;
let z = add(x, y);
</pre>

<p>V&nbsp;některých případech (předání ukazatelů atd.) je nutné volání funkce
umístit do bloku <strong>unsafe {}</strong>:</p>

<pre>
let x:i32 = 1;
let y:i32 = 2;
let z = unsafe { add(x, y) };
</pre>

<p>Celý příklad (resp.&nbsp;jeho rustovská část) bude vypadat následovně:</p>

<pre>
#[link(name = "ffi1", kind="static")]
extern {
    fn add(x:i32, y:i32) -&gt; i32;
}
&nbsp;
fn main() {
    let x:i32 = 1;
    let y:i32 = 2;
    let z = unsafe { add(x, y) };
    println!("{} + {} = {}", x, y, z);
}
</pre>



<p><a name="k05"></a></p>
<h2 id="k05">5. Překlad a spuštění aplikace psané v&nbsp;Rustu, která volá funkci ze statické knihovny</h2>

<p>Při překladu zdrojového kódu psaného v&nbsp;Rustu se volá i linker, který
musí vědět, kde je umístěna statická knihovna <strong>libffi1.a</strong>. Cestu
ke knihovně/knihovnám můžeme předat přes parametr <strong>L</strong>, který
bude obsahovat aktuální adresář (tedy tečku):</p>

<pre>
rustc -L . ffi1.rs
</pre>

<p>Díky tomu, že se program linkuje se statickou knihovnou (resp.&nbsp;jejím
obsahem), není nutné soubor <strong>libffi1.a</strong> distribuovat současně
s&nbsp;aplikací (používá se jen při vývoji).</p>

<p>Spuštění příkladu je již jednoduché:</p>
<pre>
$ <strong>./ffi1</strong>
1 + 2 = 3
</pre>



<p><a name="k06"></a></p>
<h2 id="k06">6. Zjednodušení procesu překladu a spouštění: jednoduchý <strong>Makefile</strong></h2>

<p>Aby nebylo nutné výše uvedené kroky provádět neustále dokola po každé úpravě
části psané v&nbsp;jazyku C či naopak v&nbsp;Rusu, můžeme si vytvořit
jednoduchý soubor <strong>Makefile</strong>, který překlad a slinkování
automatizuje:</p>

<pre>
CC=gcc
CFLAGS=-Wall -ansi
RUSTC=rustc
&nbsp;
APP=ffi1
PROGNAME=$(APP)
LIBNAME=lib$(APP).a
&nbsp;
RUST_SRC=$(APP).rs
LIB_SRC=$(APP).c
OBJ_FILE=$(APP).o
&nbsp;
# Vychozi pravidlo pro vytvoreni vysledne spustitelne aplikace.
all:    $(LIBNAME) $(PROGNAME)
&nbsp;
# Pravidlo pro slinkovani vsech objektovych souboru a vytvoreni
# vysledne spustitelne aplikace.
$(PROGNAME):    $(RUST_SRC) $(LIBNAME)
        $(RUSTC) -L . $&lt;
&nbsp;
# Pravidlo pro preklad knihovny
$(LIBNAME):     $(OBJ_FILE)
        ar rcs $(LIBNAME) $&lt;
&nbsp;
%.o:    %.c
        $(CC) $(CFLAGS) $(INCLUDES) -c $&lt; -o $@
&nbsp;
clean:
        rm -f *.o
        rm -f *.a
        rm -f $(PROGNAME)
&nbsp;
run:
        ./$(APP)
</pre>



<p><a name="k07"></a></p>
<h2 id="k07">7. Překlad funkce do objektového souboru a vytvoření dynamické knihovny</h2>

<p>Mnohem častěji se setkáme s&nbsp;nutností volat nativní funkce uložené
v&nbsp;dynamických knihovnách. Můžeme se tedy pokusit si vytvořit dynamickou
knihovnu s&nbsp;naší funkcí <strong>add</strong>. Není to nic těžkého, ovšem je
nutné dodržet několik pravidel, například překládat do pozičně nezávislého
strojového kódu atd.</p>

<p>Postupovat je možné následujícím způsobem. Nejdříve se musí provést překlad
céčkového zdrojového kódu do nativního objektového kódu, což se zdánlivě nijak
neliší od předchozího příkladu, ovšem musíme zde nově použít přepínač
<strong>-fPIC</strong>:</p>

<pre>
gcc -Wall -ansi -c -fPIC ffi2.c -o ffi2.o
</pre>

<p>Výsledkem je objektový soubor nazvaný <strong>ffi2.o</strong>. Následně se
vytvoří dynamická knihovna příkazem:</p>

<pre>
gcc -shared -Wl,-soname,libffi2.so -o libffi2.so ffi2.o
</pre>

<p>Povšimněte si, že výsledná knihovna má prefix &bdquo;lib&ldquo;. To je
důležité, neboť kdyby tento prefix nebyl použit a knihovna se jmenovala jen
<strong>ffi2.so</strong>, nastaly by problémy s&nbsp;jejím načítáním (ty jsou
samozřejmě řešitelné, ale proč si zbytečně přidělávat práci nestandardním
pojmenováním?)</p>



<p><a name="k08"></a></p>
<h2 id="k08">8. Použití dynamické knihovny v&nbsp;Rustu</h2>

<pre>
#[link(name = "ffi2")]
extern {
    fn add(x:i32, y:i32) -&gt; i32;
}
&nbsp;
fn main() {
    let x:i32 = 1;
    let y:i32 = 2;
    let z = unsafe { add(x, y) };
    println!("{} + {} = {}", x, y, z);
}
</pre>



<p><a name="k09"></a></p>
<h2 id="k09">9. Překlad a spuštění aplikace psané v&nbsp;Rustu, která volá funkci z&nbsp;dynamické knihovny</h2>

<pre>
export LD_LIBRARY_PATH=.
./ffi2
</pre>



<p><a name="k10"></a></p>
<h2 id="k10">10. Pomocný soubor <strong>Makefile</strong> pro druhý příklad</h2>

<pre>
CC=gcc
CFLAGS=-Wall -ansi -fPIC
RUSTC=rustc
&nbsp;
APP=ffi2
PROGNAME=$(APP)
LIBNAME=lib$(APP).so
&nbsp;
RUST_SRC=$(APP).rs
LIB_SRC=$(APP).c
OBJ_FILE=$(APP).o
&nbsp;
# Vychozi pravidlo pro vytvoreni vysledne spustitelne aplikace.
all:    $(LIBNAME) $(PROGNAME)
&nbsp;
# Pravidlo pro slinkovani vsech objektovych souboru a vytvoreni
# vysledne spustitelne aplikace.
$(PROGNAME):    $(RUST_SRC) $(LIBNAME)
        $(RUSTC) -L . $&lt;
&nbsp;
# Pravidlo pro preklad knihovny
$(LIBNAME):     $(OBJ_FILE)
        $(CC) -shared -Wl,-soname,$(LIBNAME) -o $(LIBNAME) $&lt;
&nbsp;
%.o:    %.c
        $(CC) $(CFLAGS) $(INCLUDES) -c $&lt;
&nbsp;
clean:
        rm -f *.o
        rm -f *.so
        rm -f $(PROGNAME)
&nbsp;
run:
        export LD_LIBRARY_PATH=.;./$(APP)
</pre>



<p><a name="k11"></a></p>
<h2 id="k11">11. Problematika řetězců &ndash; C versus Rust</h2>

<pre>
#include &lt;stdint.h&gt;
&nbsp;
int32_t string_length(const char *str)
{
    int32_t len = 0;
    for (; *str; str++, len++)
        ;
    return len;
}
</pre>



<p><a name="k12"></a></p>
<h2 id="k12">12. Předání řetězce do volané nativní funkce</h2>

<pre>
use std::ffi::CString;
use std::os::raw::c_char;
&nbsp;
#[link(name = "ffi3")]
extern {
    fn string_length(str: *const c_char) -> i32;
}
&nbsp;
fn main() {
    match CString::new("Hello world!") {
        Ok(string) => {
            let pointer = string.as_ptr();
            unsafe {
                println!("string length = {}", string_length(pointer));
            }
        }
        Err(error) => {
            println!("CString::new() error: {:?}", error);
        }
    }
}
</pre>



<p><a name="k13"></a></p>
<h2 id="k13">13. Dangling pointers a jak je nevytvářet</h2>



<p><a name="k14"></a></p>
<h2 id="k14">14. Kódování znaků v&nbsp;řetězcích</h2>



<p><a name="k15"></a></p>
<h2 id="k15">15. Vypsání adresy ukazatele a předání řetězce s&nbsp;českými znaky do nativní funkce</h2>

<pre>
#include &lt;stdint.h&gt;
&nbsp;
#include &lt;stdio.h&gt;
&nbsp;
int32_t string_length(const char *str)
{
    printf("C side pointer:    %p\n", str);
    int32_t len = 0;
    for (; *str; str++, len++)
        ;
    return len;
}
</pre>

<pre>
use std::ffi::CString;
use std::os::raw::c_char;
&nbsp;
#[link(name = "ffi4")]
extern {
    fn string_length(str: *const c_char) -> i32;
}
&nbsp;
fn test(string :&'static str) {
    match CString::new(string) {
        Ok(string) => {
            let pointer = string.as_ptr();
            println!("Rust side pointer: {:p}", pointer);
            unsafe {
                println!("string length = {}", string_length(pointer));
            }
        }
        Err(error) => {
            println!("CString::new() error: {:?}", error);
        }
    }
}
&nbsp;
fn main() {
    test("Hello world!");
    test("");
    test("ěščřžýáíé");
}
</pre>



<p><a name="k16"></a></p>
<h2 id="k16">16. Repositář s&nbsp;demonstračními příklady</h2>

<p>Všechny dnes popisované demonstrační příklady a podpůrné skripty byly,
ostatně podobně jako ve všech předchozích částech <a
href="https://www.root.cz/serialy/programovaci-jazyk-rust/">tohoto seriálu</a>,
uloženy do Git repositáře dostupného na adrese <a
href="https://github.com/tisnik/presentations">https://github.com/tisnik/presentations</a>.
Demonstrační příklady si můžete v&nbsp;případě potřeby stáhnout i jednotlivě
bez nutnosti klonovat celý repositář:</p>

<table>
<tr><th>Příklad</th><th>Adresa</th></tr>
<tr><td>ffi1.c</td><td><a href="https://github.com/tisnik/presentations/blob/master/rust/ffi/ffi1/ffi1.c">https://github.com/tisnik/presentations/blob/master/rust/ffi/ffi1/ffi1.c</a></td></tr>
<tr><td>ffi1.rs</td><td><a href="https://github.com/tisnik/presentations/blob/master/rust/ffi/ffi1/ffi1.rs ">https://github.com/tisnik/presentations/blob/master/rust/ffi/ffi1/ffi1.rs</a></td></tr>
<tr><td>make_binary.sh</td><td><a href="https://github.com/tisnik/presentations/blob/master/rust/ffi/ffi1/make_binary.sh ">https://github.com/tisnik/presentations/blob/master/rust/ffi/ffi1/make_binary.sh</a></td></tr>
<tr><td>make_library.sh</td><td><a href="https://github.com/tisnik/presentations/blob/master/rust/ffi/ffi1/make_library.sh">https://github.com/tisnik/presentations/blob/master/rust/ffi/ffi1/make_library.sh</a></td></tr>
<tr><td>Makefile</td><td><a href="https://github.com/tisnik/presentations/blob/master/rust/ffi/ffi1/Makefile ">https://github.com/tisnik/presentations/blob/master/rust/ffi/ffi1/Makefile</a></td></tr>
<tr><td>&nbsp;</td><td>&nbsp;</td></tr>
<tr><td>ffi2.c</td><td><a href="https://github.com/tisnik/presentations/blob/master/rust/ffi/ffi2/ffi2.c ">https://github.com/tisnik/presentations/blob/master/rust/ffi/ffi2/ffi2.c</a></td></tr>
<tr><td>ffi2.rs</td><td><a href="https://github.com/tisnik/presentations/blob/master/rust/ffi/ffi2/ffi2.rs ">https://github.com/tisnik/presentations/blob/master/rust/ffi/ffi2/ffi2.rs</a></td></tr>
<tr><td>make_binary.sh</td><td><a href="https://github.com/tisnik/presentations/blob/master/rust/ffi/ffi2/make_binary.sh ">https://github.com/tisnik/presentations/blob/master/rust/ffi/ffi2/make_binary.sh</a></td></tr>
<tr><td>make_library.sh</td><td><a href="https://github.com/tisnik/presentations/blob/master/rust/ffi/ffi2/make_library.sh">https://github.com/tisnik/presentations/blob/master/rust/ffi/ffi2/make_library.sh</a></td></tr>
<tr><td>Makefile</td><td><a href="https://github.com/tisnik/presentations/blob/master/rust/ffi/ffi2/Makefile ">https://github.com/tisnik/presentations/blob/master/rust/ffi/ffi2/Makefile</a></td></tr>
<tr><td>&nbsp;</td><td>&nbsp;</td></tr>
<tr><td>ffi3.c</td><td><a href="https://github.com/tisnik/presentations/blob/master/rust/ffi/ffi3/ffi3.c ">https://github.com/tisnik/presentations/blob/master/rust/ffi/ffi3/ffi3.c</a></td></tr>
<tr><td>ffi3.rs</td><td><a href="https://github.com/tisnik/presentations/blob/master/rust/ffi/ffi3/ffi3.rs ">https://github.com/tisnik/presentations/blob/master/rust/ffi/ffi3/ffi3.rs</a></td></tr>
<tr><td>Makefile</td><td><a href="https://github.com/tisnik/presentations/blob/master/rust/ffi/ffi3/Makefile ">https://github.com/tisnik/presentations/blob/master/rust/ffi/ffi3/Makefile</a></td></tr>
<tr><td>&nbsp;</td><td>&nbsp;</td></tr>
<tr><td>ffi4.c</td><td><a href="https://github.com/tisnik/presentations/blob/master/rust/ffi/ffi4/ffi4.c ">https://github.com/tisnik/presentations/blob/master/rust/ffi/ffi4/ffi4.c</a></td></tr>
<tr><td>ffi4.rs</td><td><a href="https://github.com/tisnik/presentations/blob/master/rust/ffi/ffi4/ffi4.rs ">https://github.com/tisnik/presentations/blob/master/rust/ffi/ffi4/ffi4.rs</a></td></tr>
<tr><td>Makefile</td><td><a href="https://github.com/tisnik/presentations/blob/master/rust/ffi/ffi4/Makefile ">https://github.com/tisnik/presentations/blob/master/rust/ffi/ffi4/Makefile</a></td></tr>
</table>



<p><a name="k17"></a></p>
<h2 id="k17">17. Odkazy na Internetu</h2>

<ol>

<li>GNU C Library: Integers<br />
<a href="https://www.gnu.org/software/libc/manual/html_node/Integers.html">https://www.gnu.org/software/libc/manual/html_node/Integers.html</a>
</li>

<li>Position-independent code<br />
<a href="https://cs.wikipedia.org/wiki/Position-independent_code">https://cs.wikipedia.org/wiki/Position-independent_code</a>
</li>

<li>Creating a shared and static library with the gnu compiler [gcc]<br />
<a href="http://www.adp-gmbh.ch/cpp/gcc/create_lib.html">http://www.adp-gmbh.ch/cpp/gcc/create_lib.html</a>
</li>

<li>FFI: Foreign Function Interface<br />
<a href="https://doc.rust-lang.org/book/ffi.html">https://doc.rust-lang.org/book/ffi.html</a>
</li>

<li>Primitive Type pointer<br />
<a href="https://doc.rust-lang.org/std/primitive.pointer.html">https://doc.rust-lang.org/std/primitive.pointer.html</a>
</li>

<li>Cargo: správce projektů a balíčků pro programovací jazyk Rust<br />
<a href="https://mojefedora.cz/cargo-spravce-projektu-a-balicku-pro-programovaci-jazyk-rust/">https://mojefedora.cz/cargo-spravce-projektu-a-balicku-pro-programovaci-jazyk-rust/</a>
</li>

<li>Network Communication and Serialization in Rust<br />
<a href="https://www.safaribooksonline.com/blog/2014/01/28/network-communication-serialization-rust/">https://www.safaribooksonline.com/blog/2014/01/28/network-communication-serialization-rust/</a>
</li>

<li>Crate bincode<br />
<a href="http://tyoverby.com/bincode/bincode/index.html">http://tyoverby.com/bincode/bincode/index.html</a>
</li>

<li>Struct std::fs::File<br />
<a href="https://doc.rust-lang.org/std/fs/struct.File.html">https://doc.rust-lang.org/std/fs/struct.File.html</a>
</li>

<li>Trait std::io::Seek<br />
<a href="https://doc.rust-lang.org/std/io/trait.Seek.html">https://doc.rust-lang.org/std/io/trait.Seek.html</a>
</li>

<li>Trait std::io::Read<br />
<a href="https://doc.rust-lang.org/std/io/trait.Read.html">https://doc.rust-lang.org/std/io/trait.Read.html</a>
</li>

<li>Trait std::io::Write<br />
<a href="https://doc.rust-lang.org/std/io/trait.Write.html">https://doc.rust-lang.org/std/io/trait.Write.html</a>
</li>

<li>Trait std::io::BufRead<br />
<a href="https://doc.rust-lang.org/std/io/trait.BufRead.html">https://doc.rust-lang.org/std/io/trait.BufRead.html</a>
</li>

<li>Module std::io::prelude<br />
<a href="https://doc.rust-lang.org/std/io/prelude/index.html">https://doc.rust-lang.org/std/io/prelude/index.html</a>
</li>

<li>std::net::IpAddr<br />
<a href="https://doc.rust-lang.org/std/net/enum.IpAddr.html">https://doc.rust-lang.org/std/net/enum.IpAddr.html</a>
</li>

<li>std::net::Ipv4Addr<br />
<a href="https://doc.rust-lang.org/std/net/struct.Ipv4Addr.html">https://doc.rust-lang.org/std/net/struct.Ipv4Addr.html</a>
</li>

<li>std::net::Ipv6Addr<br />
<a href="https://doc.rust-lang.org/std/net/struct.Ipv6Addr.html">https://doc.rust-lang.org/std/net/struct.Ipv6Addr.html</a>
</li>

<li>TcpListener<br />
<a href="https://doc.rust-lang.org/std/net/struct.TcpListener.html">https://doc.rust-lang.org/std/net/struct.TcpListener.html</a>
</li>

<li>TcpStream<br />
<a href="https://doc.rust-lang.org/std/net/struct.TcpStream.html">https://doc.rust-lang.org/std/net/struct.TcpStream.html</a>
</li>

<li>Binary heap (Wikipedia)<br />
<a href="https://en.wikipedia.org/wiki/Binary_heap">https://en.wikipedia.org/wiki/Binary_heap</a>
</li>

<li>Binární halda (Wikipedia)<br />
<a href="https://cs.wikipedia.org/wiki/Bin%C3%A1rn%C3%AD_halda">https://cs.wikipedia.org/wiki/Bin%C3%A1rn%C3%AD_halda</a>
</li>

<li>Halda (datová struktura)<br />
<a href="https://cs.wikipedia.org/wiki/Halda_%28datov%C3%A1_struktura%29">https://cs.wikipedia.org/wiki/Halda_%28datov%C3%A1_struktura%29</a>
</li>

<li>Struct std::collections::HashSet<br />
<a href="https://doc.rust-lang.org/std/collections/struct.HashSet.html">https://doc.rust-lang.org/std/collections/struct.HashSet.html</a>
</li>

<li>Struct std::collections::BTreeSet<br />
<a href="https://doc.rust-lang.org/std/collections/struct.BTreeSet.html">https://doc.rust-lang.org/std/collections/struct.BTreeSet.html</a>
</li>

<li>Struct std::collections::BinaryHeap<br />
<a href="https://doc.rust-lang.org/std/collections/struct.BinaryHeap.html">https://doc.rust-lang.org/std/collections/struct.BinaryHeap.html</a>
</li>

<li>Set (abstract data type)<br />
<a href="https://en.wikipedia.org/wiki/Set_%28abstract_data_type%29#Language_support">https://en.wikipedia.org/wiki/Set_%28abstract_data_type%29#Language_support</a>
</li>

<li>Associative array<br />
<a href="https://en.wikipedia.org/wiki/Associative_array">https://en.wikipedia.org/wiki/Associative_array</a>
</li>

<li>Hash Table<br />
<a href="https://en.wikipedia.org/wiki/Hash_table">https://en.wikipedia.org/wiki/Hash_table</a>
</li>

<li>B-tree<br />
<a href="https://en.wikipedia.org/wiki/B-tree">https://en.wikipedia.org/wiki/B-tree</a>
</li>

<li>Pedro Celis: Robin Hood Hashing (naskenované PDF!)<br />
<a href="https://cs.uwaterloo.ca/research/tr/1986/CS-86-14.pdf">https://cs.uwaterloo.ca/research/tr/1986/CS-86-14.pdf</a>
</li>

<li>Robin Hood hashing<br />
<a href="http://codecapsule.com/2013/11/11/robin-hood-hashing/">http://codecapsule.com/2013/11/11/robin-hood-hashing/</a>
</li>

<li>Robin Hood hashing: backward shift deletion<br />
<a href="http://codecapsule.com/2013/11/17/robin-hood-hashing-backward-shift-deletion/">http://codecapsule.com/2013/11/17/robin-hood-hashing-backward-shift-deletion/</a>
</li>

<li>Module std::collections<br />
<a href="https://doc.rust-lang.org/std/collections/">https://doc.rust-lang.org/std/collections/</a>
</li>

<li>Module std::vec<br />
<a href="https://doc.rust-lang.org/nightly/std/vec/index.html">https://doc.rust-lang.org/nightly/std/vec/index.html</a>
</li>

<li>Struct std::collections::VecDeque<br />
<a href="https://doc.rust-lang.org/std/collections/struct.VecDeque.html">https://doc.rust-lang.org/std/collections/struct.VecDeque.html</a>
</li>

<li>Struct std::collections::LinkedList<br />
<a href="https://doc.rust-lang.org/std/collections/struct.LinkedList.html">https://doc.rust-lang.org/std/collections/struct.LinkedList.html</a>
</li>

<li>Module std::fmt<br />
<a href="https://doc.rust-lang.org/std/fmt/">https://doc.rust-lang.org/std/fmt/</a>
</li>

<li>Macro std::println<br />
<a href="https://doc.rust-lang.org/std/macro.println.html">https://doc.rust-lang.org/std/macro.println.html</a>
</li>

<li>Enum std::result::Result<br />
<a href="https://doc.rust-lang.org/std/result/enum.Result.html">https://doc.rust-lang.org/std/result/enum.Result.html</a>
</li>

<li>Module std::result<br />
<a href="https://doc.rust-lang.org/std/result/">https://doc.rust-lang.org/std/result/</a>
</li>

<li>Result<br />
<a href="http://rustbyexample.com/std/result.html">http://rustbyexample.com/std/result.html</a>
</li>

<li>Rust stdlib: Option<br />
<a href="https://doc.rust-lang.org/std/option/enum.Option.html">https://doc.rust-lang.org/std/option/enum.Option.html</a>
</li>

<li>Module std::option<br />
<a href="https://doc.rust-lang.org/std/option/index.html">https://doc.rust-lang.org/std/option/index.html</a>
</li>

<li>Rust by example: option<br />
<a href="http://rustbyexample.com/std/option.html">http://rustbyexample.com/std/option.html</a>
</li>

<li>Rust by example: if-let<br />
<a href="http://rustbyexample.com/flow_control/if_let.html">http://rustbyexample.com/flow_control/if_let.html</a>
</li>

<li>Rust by example: while let<br />
<a href="http://rustbyexample.com/flow_control/while_let.html">http://rustbyexample.com/flow_control/while_let.html</a>
</li>

<li>Rust by example: Option&lt;i32&gt;<br />
<a href="http://rustbyexample.com/std/option.html">http://rustbyexample.com/std/option.html</a>
</li>

<li>An Overview of Macros in Rust<br />
<a href="http://words.steveklabnik.com/an-overview-of-macros-in-rust">http://words.steveklabnik.com/an-overview-of-macros-in-rust</a>
</li>

<li>A Practical Intro to Macros in Rust 1.0<br />
<a href="https://danielkeep.github.io/practical-intro-to-macros.html">https://danielkeep.github.io/practical-intro-to-macros.html</a>
</li>

<li>The Rust Programming Language: macros<br />
<a href="https://doc.rust-lang.org/beta/book/macros.html">https://doc.rust-lang.org/beta/book/macros.html</a>
</li>

<li>Rust by example: 15 macro_rules!<br />
<a href="http://rustbyexample.com/macros.html">http://rustbyexample.com/macros.html</a>
</li>

<li>Primitive Type isize<br />
<a href="https://doc.rust-lang.org/nightly/std/primitive.isize.html">https://doc.rust-lang.org/nightly/std/primitive.isize.html</a>
</li>

<li>Primitive Type usize<br />
<a href="https://doc.rust-lang.org/nightly/std/primitive.usize.html">https://doc.rust-lang.org/nightly/std/primitive.usize.html</a>
</li>

<li>Primitive Type array<br />
<a href="https://doc.rust-lang.org/nightly/std/primitive.array.html">https://doc.rust-lang.org/nightly/std/primitive.array.html</a>
</li>

<li>Module std::slice<br />
<a href="https://doc.rust-lang.org/nightly/std/slice/">https://doc.rust-lang.org/nightly/std/slice/</a>
</li>

<li>Rust by Example: 2.3 Arrays and Slices<br />
<a href="http://rustbyexample.com/primitives/array.html">http://rustbyexample.com/primitives/array.html</a>
</li>

<li>What is the difference between Slice and Array (stackoverflow)<br />
<a href="http://stackoverflow.com/questions/30794235/what-is-the-difference-between-slice-and-array">http://stackoverflow.com/questions/30794235/what-is-the-difference-between-slice-and-array</a>
</li>

<li>Learning Rust With Entirely Too Many Linked Lists<br />
<a href="http://cglab.ca/~abeinges/blah/too-many-lists/book/">http://cglab.ca/~abeinges/blah/too-many-lists/book/</a>
</li>

<li>Testcase: linked list<br />
<a href="http://rustbyexample.com/custom_types/enum/testcase_linked_list.html">http://rustbyexample.com/custom_types/enum/testcase_linked_list.html</a>
</li>

<li>Operators and Overloading<br />
<a href="https://doc.rust-lang.org/book/operators-and-overloading.html">https://doc.rust-lang.org/book/operators-and-overloading.html</a>
</li>

<li>Module std::ops<br />
<a href="https://doc.rust-lang.org/std/ops/index.html">https://doc.rust-lang.org/std/ops/index.html</a>
</li>

<li>Module std::cmp<br />
<a href="https://doc.rust-lang.org/std/cmp/index.html">https://doc.rust-lang.org/std/cmp/index.html</a>
</li>

<li>Trait std::ops::Add<br />
<a href="https://doc.rust-lang.org/stable/std/ops/trait.Add.html">https://doc.rust-lang.org/stable/std/ops/trait.Add.html</a>
</li>

<li>Trait std::ops::AddAssign<br />
<a href="https://doc.rust-lang.org/std/ops/trait.AddAssign.html">https://doc.rust-lang.org/std/ops/trait.AddAssign.html</a>
</li>

<li>Trait std::ops::Drop<br />
<a href="https://doc.rust-lang.org/std/ops/trait.Drop.html">https://doc.rust-lang.org/std/ops/trait.Drop.html</a>
</li>

<li>Trait std::cmp::Eq<br />
<a href="https://doc.rust-lang.org/std/cmp/trait.Eq.html">https://doc.rust-lang.org/std/cmp/trait.Eq.html</a>
</li>

<li>Struct std::boxed::Box<br />
<a href="https://doc.rust-lang.org/std/boxed/struct.Box.html">https://doc.rust-lang.org/std/boxed/struct.Box.html</a>
</li>

<li>Explore the ownership system in Rust<br />
<a href="https://nercury.github.io/rust/guide/2015/01/19/ownership.html">https://nercury.github.io/rust/guide/2015/01/19/ownership.html</a>
</li>

<li>Rust's ownership and move semantic<br/>
<a href="http://www.slideshare.net/saneyuki/rusts-ownership-and-move-semantics">http://www.slideshare.net/saneyuki/rusts-ownership-and-move-semantics</a>
</li>

<li>Trait std::marker::Copy<br/>
<a href="https://doc.rust-lang.org/stable/std/marker/trait.Copy.html">https://doc.rust-lang.org/stable/std/marker/trait.Copy.html</a>
</li>

<li>Trait std::clone::Clone<br />
<a href="https://doc.rust-lang.org/stable/std/clone/trait.Clone.html">https://doc.rust-lang.org/stable/std/clone/trait.Clone.html</a>
</li>

<li>The Stack and the Heap<br />
<a href="https://doc.rust-lang.org/book/the-stack-and-the-heap.html">https://doc.rust-lang.org/book/the-stack-and-the-heap.html</a>
</li>

<li>Rust Compare: Pointers &amp; References<br />
<a href="http://www.rust-compare.com/site/pointers.html">http://www.rust-compare.com/site/pointers.html</a>
</li>

<li>Rust Compare: Parameters<br />
<a href="http://www.rust-compare.com/site/params.html">http://www.rust-compare.com/site/params.html</a>
</li>

<li>Why does this compile? Automatic dereferencing?<br />
<a href="https://users.rust-lang.org/t/why-does-this-compile-automatic-dereferencing/2183">https://users.rust-lang.org/t/why-does-this-compile-automatic-dereferencing/2183</a>
</li>

<li>Understanding Pointers, Ownership, and Lifetimes in Rust<br />
<a href="http://koerbitz.me/posts/Understanding-Pointers-Ownership-and-Lifetimes-in-Rust.html">http://koerbitz.me/posts/Understanding-Pointers-Ownership-and-Lifetimes-in-Rust.html</a>
</li>

<li>Rust lang series episode #25 — pointers (#rust-series)<br />
<a href="https://steemit.com/rust-series/@jimmco/rust-lang-series-episode-25-pointers-rust-series">https://steemit.com/rust-series/@jimmco/rust-lang-series-episode-25-pointers-rust-series</a>
</li>

<li>Rust - home page<br />
<a href="https://www.rust-lang.org/en-US/">https://www.rust-lang.org/en-US/</a>
</li>

<li>Rust - Frequently Asked Questions<br />
<a href="https://www.rust-lang.org/en-US/faq.html">https://www.rust-lang.org/en-US/faq.html</a>
</li>

<li>Destructuring and Pattern Matching<br />
<a href="https://pzol.github.io/getting_rusty/posts/20140417_destructuring_in_rust/">https://pzol.github.io/getting_rusty/posts/20140417_destructuring_in_rust/</a>
</li>

<li>The Rust Programming Language<br />
<a href="https://doc.rust-lang.org/book/">https://doc.rust-lang.org/book/</a>
</li>

<li>Rust (programming language)<br />
<a href="https://en.wikipedia.org/wiki/Rust_%28programming_language%29">https://en.wikipedia.org/wiki/Rust_%28programming_language%29</a>
</li>

<li>Go - home page<br />
<a href="https://golang.org/">https://golang.org/</a>
</li>

<li>Stack Overflow - Most Loved, Dreaded, and Wanted language<br />
<a href="https://stackoverflow.com/research/developer-survey-2016#technology-most-loved-dreaded-and-wanted">https://stackoverflow.com/research/developer-survey-2016#technology-most-loved-dreaded-and-wanted</a>
</li>

<li>Rust vs Go (dva roky staré hodnocení, od té doby došlo k posunům v obou jazycích)<br />
<a href="http://jaredforsyth.com/2014/03/22/rust-vs-go/">http://jaredforsyth.com/2014/03/22/rust-vs-go/</a>
</li>

<li>Rust vs Go: My experience<br />
<a href="https://www.reddit.com/r/golang/comments/21m6jq/rust_vs_go_my_experience/">https://www.reddit.com/r/golang/comments/21m6jq/rust_vs_go_my_experience/</a>
</li>

<li>Friends of Rust (Organizations running Rust in production)<br />
<a href="https://www.rust-lang.org/en-US/friends.html">https://www.rust-lang.org/en-US/friends.html</a>
</li>

<li>Rust programs versus C++ g++<br />
<a href="https://benchmarksgame.alioth.debian.org/u64q/compare.php?lang=rust&lang2=gpp">https://benchmarksgame.alioth.debian.org/u64q/compare.php?lang=rust&lang2=gpp</a>
</li>

<li>Další benchmarky (nejedná se o reálné příklady &bdquo;ze života&ldquo;)<br />
<a href="https://github.com/kostya/benchmarks">https://github.com/kostya/benchmarks</a>
</li>

<li>Go na Redditu<br />
<a href="https://www.reddit.com/r/golang/">https://www.reddit.com/r/golang/</a>
</li>

<li>Rust vs. Go<br />
<a href="http://vschart.com/compare/rust/vs/go-language">http://vschart.com/compare/rust/vs/go-language</a>
</li>

<li>Abstraction without overhead: traits in Rust<br />
<a href="https://blog.rust-lang.org/2015/05/11/traits.html">https://blog.rust-lang.org/2015/05/11/traits.html</a>
</li>

<li>Method Syntax<br />
<a href="https://doc.rust-lang.org/book/method-syntax.html">https://doc.rust-lang.org/book/method-syntax.html</a>
</li>

<li>Traits in Rust<br />
<a href="https://doc.rust-lang.org/book/traits.html">https://doc.rust-lang.org/book/traits.html</a>
</li>

<li>Functional Programming in Rust - Part 1 : Function Abstraction<br />
<a href="http://blog.madhukaraphatak.com/functional-programming-in-rust-part-1/">http://blog.madhukaraphatak.com/functional-programming-in-rust-part-1/</a>
</li>

<li>Of the emerging systems languages Rust, D, Go and Nim, which is the strongest language and why?<br />
<a href="https://www.quora.com/Of-the-emerging-systems-languages-Rust-D-Go-and-Nim-which-is-the-strongest-language-and-why">https://www.quora.com/Of-the-emerging-systems-languages-Rust-D-Go-and-Nim-which-is-the-strongest-language-and-why</a>
</li>

<li>Chytré ukazatele (moderní verze jazyka C++) [MSDN]<br />
<a href="https://msdn.microsoft.com/cs-cz/library/hh279674.aspx">https://msdn.microsoft.com/cs-cz/library/hh279674.aspx</a>
</li>

<li>UTF-8 Everywhere<br />
<a href="http://utf8everywhere.org/">http://utf8everywhere.org/</a>
</li>

<li>Rust by Example<br />
<a href="http://rustbyexample.com/">http://rustbyexample.com/</a>
</li>

<li>Rust oficiálně ve Fedoře<br />
<a href="https://mojefedora.cz/rust-oficialne-ve-fedore/">https://mojefedora.cz/rust-oficialne-ve-fedore/</a>
</li>

<li>Resource acquisition is initialization<br />
<a href="https://en.wikipedia.org/wiki/Resource_acquisition_is_initialization">https://en.wikipedia.org/wiki/Resource_acquisition_is_initialization</a>
</li>

<li>TIOBE index (October 2016)<br />
<a href="http://www.tiobe.com/tiobe-index/">http://www.tiobe.com/tiobe-index/</a>
</li>

<li>Porovnání Go, D a Rustu na OpenHubu:<br />
<a href="https://www.openhub.net/languages/compare?language_name[]=-1&language_name[]=-1&language_name[]=dmd&language_name[]=golang&language_name[]=rust&language_name[]=-1&measure=commits">https://www.openhub.net/languages/compare?language_name[]=-1&language_name[]=-1&language_name[]=dmd&language_name[]=golang&language_name[]=rust&language_name[]=-1&measure=commits</a>
</li>

<li>String Types in Rust<br />
<a href="http://www.suspectsemantics.com/blog/2016/03/27/string-types-in-rust/">http://www.suspectsemantics.com/blog/2016/03/27/string-types-in-rust/</a>
</li>

<li>Trait (computer programming)<br />
<a href="https://en.wikipedia.org/wiki/Trait_%28computer_programming%29">https://en.wikipedia.org/wiki/Trait_%28computer_programming%29</a>
</li>

<li>Type inference<br />
<a href="https://en.wikipedia.org/wiki/Type_inference">https://en.wikipedia.org/wiki/Type_inference</a>
</li>

</ol>



<p></p><p></p>
<p><small>Autor: <a href="http://www.fit.vutbr.cz/~tisnovpa">Pavel Tišnovský</a> &nbsp; 2017</small></p>
</body>
</html>

