<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
        "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html>
<head>
<title>Realizace MCP klientů i serverů v jazyku Go</title>
<meta name="Author" content="Pavel Tisnovsky" />
<meta name="Generator" content="vim" />
<meta http-equiv="content-type" content="text/html; charset=utf-8" />
<style type="text/css">
         body {color:#000000; background:#ffffff;}
         h1  {font-family: arial, helvetica, sans-serif; color:#ffffff; background-color:#c00000; text-align:center; padding-left:1em}
         h2  {font-family: arial, helvetica, sans-serif; color:#ffffff; background-color:#0000c0; padding-left:1em; text-align:left}
         h3  {font-family: arial, helvetica, sans-serif; color:#000000; background-color:#c0c0c0; padding-left:1em; text-align:left}
         h4  {font-family: arial, helvetica, sans-serif; color:#000000; background-color:#e0e0e0; padding-left:1em; text-align:left}
         a   {font-family: arial, helvetica, sans-serif;}
         li  {font-family: arial, helvetica, sans-serif; color:#000000; text-align:justify; width:450px;}
         ol  {font-family: arial, helvetica, sans-serif; color:#000000; text-align:justify; width:450px;}
         ul  {font-family: arial, helvetica, sans-serif; color:#000000; text-align:justify; width:450px;}
         p   {font-family: arial, helvetica, sans-serif; color:#000000; text-align:justify;}
         pre {background:#e0e0e0}
</style>
</head>

<body>

<h1>Realizace MCP klientů i serverů v jazyku Go</h1>

<h3>Pavel Tišnovský</h3>

<p></p>

<h1>Úvodník</h1>

<p>Na dvojici článků s popisem základních vlastností Model Context Protocolu, který je používám v oblasti AI a jazykových modelů, dnes navážeme. Předtím jsme si ukázali tvorbu MCP klientů i serverů v Pythonu s využitím oficiální MCP knihovny, zatímco dnes se zaměříme na jazyk Go, ve kterém oficiální knihovna prozatím není k dispozici.</p>



<h2>Obsah</h2>

<p><a href="#k01">1. Realizace MCP klientů i serverů v&nbsp;jazyku Go</a></p>
<p><a href="#k02">2. Instalace knihovny <strong>mcp-golang</strong></a></p>
<p><a href="#k03">3. Realizace MCP serveru v&nbsp;jazyce Go</a></p>
<p><a href="#k04">4. Úplný zdrojový kód MCP serveru naprogramovaného v&nbsp;jazyce Go</a></p>
<p><a href="#k05">5. Komunikace s&nbsp;MCP serverem z&nbsp;MCP klienta naprogramovaného v&nbsp;Pythonu</a></p>
<p><a href="#k06">6. Komunikace s&nbsp;MCP serverem z&nbsp;MCP klienta naprogramovaného v&nbsp;jazyce Go</a></p>
<p><a href="#k07">7. Úplný zdrojový kód jednoduchého MCP klienta, který server spustí a přečte z&nbsp;něj vybraný zdroj</a></p>
<p><a href="#k08">8. Vylepšení struktury MCP serveru</a></p>
<p><a href="#k09">9. Nástroje (<i>tools</i>) poskytované MCP serverem</a></p>
<p><a href="#k10">10. Realizace serveru s&nbsp;definovaným nástrojem (<i>tool</i>)</a></p>
<p><a href="#k11">11. Zavolání nástroje poskytovaného MCP serverem z&nbsp;Pythonu</a></p>
<p><a href="#k12">12. Zavolání nástroje poskytovaného MCP serverem z&nbsp;jazyka Go</a></p>
<p><a href="#k13">13. Podpora pro výzvy (<i>prompt</i>)</a></p>
<p><a href="#k14">14. Jednoduchý MCP server s&nbsp;výzvou (prompt)</a></p>
<p><a href="#k15">15. Úplný zdrojový kód serveru nabízejícího výzvu</a></p>
<p><a href="#k16">16. Komunikace s&nbsp;MCP serverem přes nabízenou výzvu</a></p>
<p><a href="#k17">17. Úplný zdrojový kód klienta, který komunikuje přes výzvu</a></p>
<p><a href="#k18">18. Omezení a chyby knihovny <strong>mcp-golang</strong></a></p>
<p><a href="#k19">19. Repositář s&nbsp;demonstračními příklady</a></p>
<p><a href="#k20">20. Odkazy na Internetu</a></p>



<p><a name="k01"></a></p>
<h2 id="k01">1. Realizace MCP klientů i serverů v&nbsp;jazyku Go</h2>

<p>V&nbsp;úvodní dvojici článků [<a
href="https://www.root.cz/clanky/model-context-protocol-vznikajici-standard-pro-aplikace-ai-a-llm/">1</a>]
[<a
href="https://www.root.cz/clanky/model-context-protocol-vznikajici-standard-pro-potreby-aplikaci-vyuzivajicich-ai-a-llm-2-cast/">2</a>]
jsme se seznámili se základními vlastnostmi MCP neboli <i>Model Context
Protocolu</i>. Připomeňme si, že se jedná o poměrně novou (a neustále
vyvíjenou) specifikaci protokolu používaného pro komunikaci mezi moduly systémů
nasazovaných v&nbsp;oblasti umělé inteligence (AI) a velkých jazykových modelů
(LLM).</p>

<p>Na tuto dvojici článků dnes navážeme. Prozatím jsme si ukázali tvorbu MCP
klientů i serverů v&nbsp;jazyce Python s&nbsp;využitím oficiální MCP knihovny.
Naproti tomu se dnes zaměříme na <a
href="https://www.root.cz/serialy/programovaci-jazyk-go/">programovací jazyk
Go</a>, pro který podobná oficiální knihovna prozatím není k&nbsp;dispozici.
Namísto toho vznikly minimálně tři knihovny s&nbsp;různou implementací MCP
protokolu, přičemž každá z&nbsp;těchto knihoven má své dobré vlastnosti, ale i
stinné stránky a dokonce i chyby. Dnes si popíšeme vlastnosti knihovny
<strong>mcp-golang</strong>, kterou lze využít zejména pro volání nástrojů
(<i>tools</i>) popř.&nbsp;výzev (<i>prompts</i>). Kupodivu jsou však velmi
špatně podporovány zdroje (<i>resources</i>), které jsou vlastně po stránce
implementace nejjednodušší.</p>



<p><a name="k02"></a></p>
<h2 id="k02">2. Instalace knihovny <strong>mcp-golang</strong></h2>

<p>Prvním krokem, který musíme udělat ještě před vývojem MCP klientů a MCP
serverů v&nbsp;jazyce Go, je instalace knihovny <strong>mcp-golang</strong>.
Nejprve si v&nbsp;novém adresáři necháme vygenerovat kostru projektu v&nbsp;Go
příkazem <strong>go mod init</strong>:</p>

<pre>
$ <strong>go mod init mcp-tests</strong>
&nbsp;
go: creating new go.mod: module mcp-tests
</pre>

<p>Výsledkem by měl být soubor <strong>go.mod</strong>.</p>

<p>Ve druhém kroku ze stejného adresáře spustíme instalaci knihovny
<strong>mcp-golang</strong> (postačuje <strong>go get</strong> a nikoli
<strong>go install</strong>):</p>

<pre>
$ <strong>go get github.com/metoro-io/mcp-golang</strong>
&nbsp;
go: downloading github.com/metoro-io/mcp-golang v0.8.0
go: downloading github.com/tidwall/sjson v1.2.5
go: downloading github.com/pkg/errors v0.9.1
go: downloading github.com/invopop/jsonschema v0.12.0
go: downloading github.com/wk8/go-ordered-map/v2 v2.1.8
go: downloading github.com/tidwall/gjson v1.18.0
go: downloading gopkg.in/yaml.v3 v3.0.1
go: downloading github.com/buger/jsonparser v1.1.1
go: downloading github.com/bahlo/generic-list-go v0.2.0
go: downloading github.com/mailru/easyjson v0.7.7
go: downloading github.com/tidwall/pretty v1.2.1
go: downloading github.com/tidwall/match v1.1.1
go: added github.com/bahlo/generic-list-go v0.2.0
go: added github.com/buger/jsonparser v1.1.1
go: added github.com/invopop/jsonschema v0.12.0
go: added github.com/mailru/easyjson v0.7.7
go: added github.com/metoro-io/mcp-golang v0.8.0
go: added github.com/pkg/errors v0.9.1
go: added github.com/tidwall/gjson v1.18.0
go: added github.com/tidwall/match v1.1.1
go: added github.com/tidwall/pretty v1.2.1
go: added github.com/tidwall/sjson v1.2.5
go: added github.com/wk8/go-ordered-map/v2 v2.1.8
go: added gopkg.in/yaml.v3 v3.0.1
</pre>

<p>Projektový soubor <strong>go.mod</strong> by nyní měl obsahovat přímé i
nepřímé závislosti a mohl by vypadat takto:</p>

<pre>
module mcp-tests
&nbsp;
go 1.22.1
&nbsp;
require (
        github.com/bahlo/generic-list-go v0.2.0 // indirect
        github.com/buger/jsonparser v1.1.1 // indirect
        github.com/invopop/jsonschema v0.12.0 // indirect
        github.com/mailru/easyjson v0.7.7 // indirect
        github.com/metoro-io/mcp-golang v0.8.0 // indirect
        github.com/pkg/errors v0.9.1 // indirect
        github.com/tidwall/gjson v1.18.0 // indirect
        github.com/tidwall/match v1.1.1 // indirect
        github.com/tidwall/pretty v1.2.1 // indirect
        github.com/tidwall/sjson v1.2.5 // indirect
        github.com/wk8/go-ordered-map/v2 v2.1.8 // indirect
        gopkg.in/yaml.v3 v3.0.1 // indirect
)
</pre>



<p><a name="k03"></a></p>
<h2 id="k03">3. Realizace MCP serveru v&nbsp;jazyce Go</h2>

<p>Pro realizaci jednoduchého MCP serveru v&nbsp;jazyce Go použijeme
v&nbsp;první řadě funkci/konstruktor nazvanou <strong>NewServer</strong>. Její
hlavičku lze zjistit z&nbsp;dokumentace k&nbsp;právě nainstalovanému balíčku
<strong>mcp-golang</strong>:</p>

<pre>
$ <strong>go doc mcp-golang.NewServer</strong>
&nbsp;
package mcp_golang // import "github.com/metoro-io/mcp-golang"
&nbsp;
func NewServer(transport transport.Transport, options ...ServerOptions) *Server
</pre>

<p>Tato funkce po svém zavolání zkonstruuje novou strukturu typu
<strong>Server</strong>. Musíme specifikovat především informace o tom, jaký
transport (STDIO nebo SSE) se bude využívat, tj.&nbsp;jak se budou
k&nbsp;serveru připojovat jednotliví klienti:</p>

<pre>
server := mcp_golang.NewServer(stdio.NewStdioServerTransport())
</pre>

<p>Samotná struktura (záznam) <strong>Server</strong> obsahuje (pro nás)
neviditelné atributy, a je pro ni definováno hned několik metod. I tyto
informace lze snadno získat z&nbsp;dokumentace:</p>

<pre>
$ <strong>go doc mcp-golang.Server</strong>
&nbsp;
package mcp_golang // import "github.com/metoro-io/mcp-golang"
&nbsp;
type Server struct {
        // Has unexported fields.
}
&nbsp;
func NewServer(transport transport.Transport, options ...ServerOptions) *Server
func (s *Server) CheckPromptRegistered(name string) bool
func (s *Server) CheckResourceRegistered(uri string) bool
func (s *Server) CheckToolRegistered(name string) bool
func (s *Server) DeregisterPrompt(name string) error
func (s *Server) DeregisterResource(uri string) error
func (s *Server) DeregisterTool(name string) error
func (s *Server) RegisterPrompt(name string, description string, handler any) error
func (s *Server) RegisterResource(uri string, name string, description string, mimeType string, handler any) error
func (s *Server) RegisterTool(name string, description string, handler any) error
func (s *Server) Serve() error
</pre>

<p>V&nbsp;našem prvním serveru bude realizován jen jediný zdroj
(<i>resource</i>), který musí být zaregistrován metodou:</p>

<pre>
func (s *Server) RegisterResource(uri string, name string, description string, mimeType string, handler any) error
</pre>

<p>Z&nbsp;hlavičky této metody je zřejmé, jaké informace se mají předávat.
Jediným nejasným parametrem je <i>handler</i>, tj.&nbsp;funkce, která je volaná
pro realizaci odpovědi serveru klientovi. Prozatím budeme realizovat velmi
jednoduchý handler. Ten vrací strukturu (resp.&nbsp;ukazatel na strukturu)
<strong>ResourceResponse</strong>, ve které je klientovi vrácena zpráva
&bdquo;Hello, dear client&ldquo;:</p>

<pre>
func <strong>resourceHandler</strong>() (*mcp_golang.ResourceResponse, error) {
        resource := mcp_golang.NewTextEmbeddedResource(
                "pozdrav://",
                "Hello, dear client",
                "text/plain")
        response := mcp_golang.NewResourceResponse(resource)
        return response, nil
}
</pre>



<p><a name="k04"></a></p>
<h2 id="k04">4. Úplný zdrojový kód MCP serveru naprogramovaného v&nbsp;jazyce Go</h2>

<p>Úplný zdrojový kód první varianty MCP serveru naprogramovaného v&nbsp;jazyce
Go, vypadá následovně:</p>

<pre>
<i>// Jednoduchý MCP server s jediným zdrojem</i>
&nbsp;
package <strong>main</strong>
&nbsp;
import (
        mcp_golang "github.com/metoro-io/mcp-golang"
        "github.com/metoro-io/mcp-golang/transport/stdio"
)
&nbsp;
func <strong>resourceHandler</strong>() (*mcp_golang.ResourceResponse, error) {
        resource := mcp_golang.NewTextEmbeddedResource(
                "pozdrav://",
                "Hello, dear client",
                "text/plain")
        response := mcp_golang.NewResourceResponse(resource)
        return response, nil
}
&nbsp;
func <strong>main</strong>() {
        done := make(chan struct{})
&nbsp;
        server := mcp_golang.NewServer(stdio.NewStdioServerTransport())
&nbsp;
        err := server.RegisterResource(
                "pozdrav://",
                "resource_test",
                "This is a test resource", "text/plain", resourceHandler)
        if err != nil {
                panic(err)
        }
&nbsp;
        err = server.Serve()
        if err != nil {
                panic(err)
        }
&nbsp;
        &lt;-done
}
</pre>

<p>Teoreticky je možné tento server přeložit spustit z&nbsp;příkazové řádky
příkazem:</p>

<pre>
$ <strong>go run mcp_server_1.go</strong>
</pre>

<p>Ovšem komunikace s&nbsp;tímto procesem by měla probíhat přes standardní
vstup a výstup. Bez podrobných znalostí MCP protokolu je to však složité (a
v&nbsp;praxi to ani není zapotřebí), a proto ke komunikaci využijeme MCP
klienty.</p>



<p><a name="k05"></a></p>
<h2 id="k05">5. Komunikace s&nbsp;MCP serverem z&nbsp;MCP klienta naprogramovaného v&nbsp;Pythonu</h2>

<p>MCP je podporován celou řadou programovacích jazyků a pochopitelně umožňuje
komunikaci mezi procesy naprogramovanými v&nbsp;různých jazycích. To si
ověříme, a to konkrétně takovým způsobem, že <a href="#k04">výše uvedený</a>
MCP server vytvořený v&nbsp;jazyku Go inicializujeme a zavoláme z&nbsp;Pythonu.
Dokonce je možné, aby MCP klient naprogramovaný v&nbsp;Pythonu nejdříve MCP
server přeložil a teprve poté spustil. Pro tento účel se používá již výše
zmíněný příkaz <strong>go run mcp_server_1.go</strong>, takže tento příkaz
zadáme do parametrů MCP serveru (je nutné rozdělit samotný příkaz od jeho
parametrů):</p>

<pre>
<i># parametry pro spuštění MCP serveru</i>
server_params = StdioServerParameters(
    command="go",  <i># spustí se tento příkaz</i>
    args=["run", "./mcp_server_1.go"],  <i># a předají se mu následující parametry</i>
    env=None,  <i># lze definovat i proměnné prostředí</i>
)
</pre>

<p>V&nbsp;implementaci MCP klienta nejdříve server spustíme, dále s&nbsp;ním
zahájíme komunikaci přes STDIO (standardní vstup a výstup) a nakonec ze serveru
přečteme obsah zdroje (<i>resource</i>) s&nbsp;identifikátorem
<strong>pozdrav://</strong>. Samotný zdrojový kód by měl být po přečtení
předchozí dvojice článků čtenářům snadno pochopitelný:</p>

<pre>
<i>"""MCP klient, který spustí server, se kterým se komunikuje přes STDIO."""</i>
&nbsp;
from mcp import ClientSession, StdioServerParameters
from mcp.client.stdio import stdio_client
&nbsp;
<i># parametry pro spuštění MCP serveru</i>
server_params = StdioServerParameters(
    command="go",  <i># spustí se tento příkaz</i>
    args=["run", "./mcp_server_1.go"],  <i># a předají se mu následující parametry</i>
    env=None,  <i># lze definovat i proměnné prostředí</i>
)
&nbsp;
&nbsp;
async def <strong>run</strong>():
    <i>"""Realizace klienta."""</i>
    async with stdio_client(server_params) as (read, write):
        async with ClientSession(read, write) as session:
            await session.initialize()
&nbsp;
            <i># přečtení zdroje</i>
            data = await session.read_resource("pozdrav://")
            print("Data returned:", data)
            print("Type:", type(data))
&nbsp;
            text = data.contents[0].text
            print("Text:", text)
&nbsp;
&nbsp;
<i># přímé spuštění klienta</i>
if __name__ == "__main__":
    import asyncio
&nbsp;
    asyncio.run(run())
</pre>

<p>Komunikaci mezi MCP klientem a MCP serverem si snadno ověříme:</p>

<pre>
$ <strong>python mcp_client_1.py </strong>
&nbsp;
Data returned: meta=None contents=[TextResourceContents(uri=AnyUrl('pozdrav://'), mimeType='text/plain', text='Hello, dear client')]
Type: &lt;class 'mcp.types.ReadResourceResult'&gt;
Text: Hello, dear client
</pre>



<p><a name="k06"></a></p>
<h2 id="k06">6. Komunikace s&nbsp;MCP serverem z&nbsp;MCP klienta naprogramovaného v&nbsp;jazyce Go</h2>

<p>Jak bude vlastně naprogramován MCP klient v&nbsp;jazyce Go? Teoreticky se
jedná o stejný postup, jako v&nbsp;případě klienta napsaného v&nbsp;Pythonu,
ovšem realizace je nepatrně odlišná, takže si ji popíšeme po jednotlivých
krocích.</p>

<p>Nejprve necháme klienta inicializovat spuštění MCP serveru, což je v&nbsp;Go
triviální:</p>

<pre>
cmd := exec.Command("go", "run", "./mcp_server_1.go")
</pre>

<p>Následně získáme proudy pro standardní vstup a výstup právě spuštěného MCP
serveru. Se serverem totiž budeme komunikovat právě přes STDIO:</p>

<pre>
stdin, err := cmd.StdinPipe()
if err != nil {
        log.Fatalf("Failed to get stdin pipe: %v", err)
}
&nbsp;
stdout, err := cmd.StdoutPipe()
if err != nil {
        log.Fatalf("Failed to get stdout pipe: %v", err)
}
</pre>

<p>Následuje spuštění MCP serveru:</p>

<pre>
if err := cmd.Start(); err != nil {
        log.Fatalf("Failed to start server: %v", err)
}
&nbsp;
defer cmd.Process.Kill()
</pre>

<p>Nyní tedy MCP server běží, takže můžeme inicializovat vlastní MCP protokol
s&nbsp;transportem nastaveným na STDIO:</p>

<pre>
transport := stdio.NewStdioServerTransportWithIO(stdout, stdin)
client := mcp.NewClient(transport)
&nbsp;
if _, err := client.Initialize(context.Background()); err != nil {
    log.Fatalf("Failed to initialize: %v", err)
}
</pre>

<p>V&nbsp;této chvíli spolu již MCP klient i server komunikují, takže se můžeme
pokusit o přečtení zdroje <i>pozdrav://</i>:</p>

<pre>
resource, err := client.ReadResource(context.Background(), "pozdrav://")
if err != nil {
        log.Printf("Failed to read resource: %v", err)
}
</pre>

<p>Pokud se čtení podaří, vypíšeme si podrobnější informace o přečteném
zdroji:</p>

<pre>
if resource != nil {
        log.Printf("Resource content: %s", resource)
}
</pre>

<p><div class="rs-tip-major">Poznámka: v&nbsp;poslední verzi knihovny
<strong>mcp-golang</strong> došlo ke změně, která neumožňuje přečtení obsahu
zdroje. Tato chyba bude doufejme v&nbsp;další verzi opravena (patch zašlu). Už
jen existence tohoto problému mnohé vypovídá o stabilitě a kvalitě knihoven pro
MCP.</div></p>



<p><a name="k07"></a></p>
<h2 id="k07">7. Úplný zdrojový kód jednoduchého MCP klienta, který server spustí a přečte z&nbsp;něj vybraný zdroj</h2>

<p>Úplný zdrojový kód MCP klienta naprogramovaného v&nbsp;jazyce Go vypadá
takto:</p>

<pre>
package <strong>main</strong>
&nbsp;
import (
        "context"
        "log"
        "os/exec"
&nbsp;
        mcp "github.com/metoro-io/mcp-golang"
        "github.com/metoro-io/mcp-golang/transport/stdio"
)
&nbsp;
func <strong>main</strong>() {
        cmd := exec.Command("go", "run", "./mcp_server_1.go")
&nbsp;
        stdin, err := cmd.StdinPipe()
        if err != nil {
                log.Fatalf("Failed to get stdin pipe: %v", err)
        }
&nbsp;
        stdout, err := cmd.StdoutPipe()
        if err != nil {
                log.Fatalf("Failed to get stdout pipe: %v", err)
        }
&nbsp;
        if err := cmd.Start(); err != nil {
                log.Fatalf("Failed to start server: %v", err)
        }
&nbsp;
        defer cmd.Process.Kill()
&nbsp;
        transport := stdio.NewStdioServerTransportWithIO(stdout, stdin)
        client := mcp.NewClient(transport)
&nbsp;
        if _, err := client.Initialize(context.Background()); err != nil {
                log.Fatalf("Failed to initialize: %v", err)
        }
&nbsp;
        resource, err := client.ReadResource(context.Background(), "pozdrav://")
        if err != nil {
                log.Printf("Failed to read resource: %v", err)
        }
&nbsp;
        if resource != nil {
                log.Printf("Resource content: %s", resource)
        }
}
</pre>



<p><a name="k08"></a></p>
<h2 id="k08">8. Vylepšení struktury MCP serveru</h2>

<p>Původní verze MCP serveru nebyla příliš čitelná, protože se ve zdrojovém
kódu mísila volání knihovny <strong>mcp-golang</strong> s&nbsp;konfigurací
zdroje. Z&nbsp;tohoto důvodu si server nepatrně vylepšíme, a to tak, že
konfiguraci zdroje přeneseme do konstant definovaných na začátku zdrojového
kódu (resp.&nbsp;přesněji řečeno za importy):</p>

<pre>
<i>// Jednoduchý MCP server s jediným zdrojem</i>
&nbsp;
package <strong>main</strong>
&nbsp;
import (
        mcp_golang "github.com/metoro-io/mcp-golang"
        "github.com/metoro-io/mcp-golang/transport/stdio"
)
&nbsp;
const <u>resourceURI</u> = "pozdrav://"
const <u>resourcename</u> = "greeting"
const <u>resourceDescription</u> = "Odpověď s pozdravem"
const <u>resourceMimeType</u> = "text/plain"
&nbsp;
func <strong>resourceHandler</strong>() (*mcp_golang.ResourceResponse, error) {
        resource := mcp_golang.NewTextEmbeddedResource(
                resourceURI,
                "Hello, dear client",
                resourceMimeType)
        response := mcp_golang.NewResourceResponse(resource)
        return response, nil
}
&nbsp;
func <strong>main</strong>() {
        done := make(chan struct{})
&nbsp;
        server := mcp_golang.NewServer(stdio.NewStdioServerTransport())
&nbsp;
        err := server.RegisterResource(
                resourceURI,
                resourceName,
                resourceDescription,
                resourceMimeType,
                resourceHandler)
        if err != nil {
                panic(err)
        }
&nbsp;
        err = server.Serve()
        if err != nil {
                panic(err)
        }
&nbsp;
        &lt;-done
}
</pre>

<p><div class="rs-tip-major">Poznámka: proces se serverem nemá ihned skončit a
z&nbsp;tohoto důvodu na konci čekáme na zápis do kanálu <strong>done</strong>,
který nebude nikdy proveden.</div></p>

<p>Tuto variantu serveru si otestujeme z&nbsp;Pythonu:</p>

<pre>
<i>"""MCP klient, který spustí server, se kterým se komunikuje přes STDIO."""</i>
&nbsp;
from mcp import ClientSession, StdioServerParameters
from mcp.client.stdio import stdio_client
&nbsp;
<i># parametry pro spuštění MCP serveru</i>
server_params = StdioServerParameters(
    command="go",  <i># spustí se tento příkaz</i>
    args=["run", "./mcp_server_2.go"],  <i># a předají se mu následující parametry</i>
    env=None,  <i># lze definovat i proměnné prostředí</i>
)
&nbsp;
&nbsp;
async def <strong>run</strong>():
    <i>"""Realizace klienta."""</i>
    async with stdio_client(server_params) as (read, write):
        async with ClientSession(read, write) as session:
            await session.initialize()
&nbsp;
            <i># přečtení zdroje</i>
            data = await session.read_resource("pozdrav://")
            print("Data returned:", data)
            print("Type:", type(data))
&nbsp;
            text = data.contents[0].text
            print("Text:", text)
&nbsp;
&nbsp;
<i># přímé spuštění klienta</i>
if __name__ == "__main__":
    import asyncio
&nbsp;
    asyncio.run(run())
</pre>



<p><a name="k09"></a></p>
<h2 id="k09">9. Nástroje (<i>tools</i>) poskytované MCP serverem</h2>

<p>V&nbsp;další variantě MCP serveru, kterou si dnes ukážeme, bude definován
jeden nástroj (<i>tool</i>). Připomeňme si, že v&nbsp;předchozích článcích
tento nástroj počítal faktoriál pro předané nezáporné číslo. Zkusme si tedy
realizaci právě tohoto nástroje přepsat do jazyka Go. Nejdříve je nutné
definovat záznam s&nbsp;popisem struktury dat předávaných MCP klientem do MCP
serveru. Tento záznam bude obsahovat hodnotu <i>n</i>, pro kterou se má
faktoriál počítat. V&nbsp;jazyce Go je zřejmé, že interně se budou předávat
data ve formátu JSON (v&nbsp;Pythonu jsme od těchto detailů byli
odstíněni):</p>

<pre>
type <strong>FactorialArguments</strong> struct {
        N int `json:"n" jsonschema:"required,description=input value for factorial computation"`
}
</pre>

<p>Naprogramování výpočtu faktoriálu může vypadat následovně. Povšimněte si,
jakým způsobem přečteme z&nbsp;parametru typu
<strong>FactorialArguments</strong> hodnotu <i>n</i> i to, jak zabalíme
výsledek do struktury typu <strong>ToolResponse</strong> (opět platí, že
v&nbsp;Pythonu to bylo sice jednodušší, ale mnoho funkcionality zůstalo
skryto):</p>

<pre>
func <strong>factorialHandler</strong>(arguments FactorialArguments) (*mcp_golang.ToolResponse, error) {
        fact := 1
        for i := range arguments.N {
                fact *= 1 + i
        }
        toolResults := mcp_golang.NewTextContent(strconv.Itoa(fact))
        response := mcp_golang.NewToolResponse(toolResults)
        return response, nil
}
</pre>

<p>Nyní nám již zbývá spustit MCP server a nástroj <i>factorial</i> v&nbsp;něm
zaregistrovat. To je snadné a především přímočaré:</p>

<pre>
server := mcp_golang.NewServer(stdio.NewStdioServerTransport())
&nbsp;
err := server.RegisterTool("factorial", "Výpočet faktoriálu", factorialHandler)
if err != nil {
        panic(err)
}
&nbsp;
err = server.Serve()
if err != nil {
        panic(err)
}
</pre>



<p><a name="k10"></a></p>
<h2 id="k10">10. Realizace serveru s&nbsp;definovaným nástrojem (<i>tool</i>)</h2>

<p>Opět se podívejme na způsob realizace celého MCP serveru, ve kterém je
definován a nabízen jediný nástroj (<i>tool</i>). Tento nástroj bude počítat
hodnotu faktoriálu pro zadaný parametr <i>n</i>, který mu pochopitelně musí
klient poslat:</p>

<pre>
<i>// Jednoduchý MCP server s jediným nástrojem</i>
&nbsp;
package <strong>main</strong>
&nbsp;
import (
        "strconv"
&nbsp;
        mcp_golang "github.com/metoro-io/mcp-golang"
        "github.com/metoro-io/mcp-golang/transport/stdio"
)
&nbsp;
type <strong>FactorialArguments</strong> struct {
        N int `json:"n" jsonschema:"required,description=input value for factorial computation"`
}
&nbsp;
func <strong>factorialHandler</strong>(arguments FactorialArguments) (*mcp_golang.ToolResponse, error) {
        fact := 1
        for i := range arguments.N {
                fact *= 1 + i
        }
        toolResults := mcp_golang.NewTextContent(strconv.Itoa(fact))
        response := mcp_golang.NewToolResponse(toolResults)
        return response, nil
}
&nbsp;
func <strong>main</strong>() {
        done := make(chan struct{})
&nbsp;
        server := mcp_golang.NewServer(stdio.NewStdioServerTransport())
&nbsp;
        err := server.RegisterTool("factorial", "Výpočet faktoriálu", factorialHandler)
        if err != nil {
                panic(err)
        }
&nbsp;
        err = server.Serve()
        if err != nil {
                panic(err)
        }
&nbsp;
        &lt;-done
}
</pre>



<p><a name="k11"></a></p>
<h2 id="k11">11. Zavolání nástroje poskytovaného MCP serverem z&nbsp;Pythonu</h2>

<p><a href="#k10">Výše popsaný</a> nástroj zavoláme z&nbsp;MCP klienta, který
je naprogramován v&nbsp;Pythonu. Opět se pro nás nejedná o žádnou novinku a
všechny části tohoto klienta by měly být zřejmé, a to včetně způsobu zavolání
nástroje a předání parametru <i>n</i>.</p>

<pre>
<i>"""MCP klient, který zavolá nástroj."""</i>
&nbsp;
from mcp import ClientSession, StdioServerParameters
from mcp.client.stdio import stdio_client
&nbsp;
<i># parametry pro spuštění MCP serveru</i>
server_params = StdioServerParameters(
    command="go",  <i># spustí se tento příkaz</i>
    args=["run", "./mcp_server_3.go"],  <i># a předají se mu následující parametry</i>
    env=None,  <i># lze definovat i proměnné prostředí</i>
)
&nbsp;
&nbsp;
async def <strong>run</strong>():
    <i>"""Realizace klienta."""</i>
    async with stdio_client(server_params) as (read, write):
        async with ClientSession(read, write) as session:
            await session.initialize()
&nbsp;
            for n in range(11):
                <i># zavolání nástroje</i>
                data = await session.call_tool("factorial", arguments={"n": n})
                factorial = data.content[0].text
                print(n, factorial)
&nbsp;
&nbsp;
<i># přímé spuštění klienta</i>
if __name__ == "__main__":
    import asyncio
&nbsp;
    asyncio.run(run())
</pre>

<p>Samozřejmě si komunikaci otestujeme:</p>

<pre>
$ <strong>python mcp_client_3.py </strong>
</pre>

<p>Výsledky vypsané na terminál by měly vypadat takto:</p>

<pre>
0 1
1 1
2 2
3 6
4 24
5 120
6 720
7 5040
8 40320
9 362880
10 3628800
</pre>



<p><a name="k12"></a></p>
<h2 id="k12">12. Zavolání nástroje poskytovaného MCP serverem z&nbsp;jazyka Go</h2>

<p>Nyní prakticky stejný postup, tj.&nbsp;připojení k&nbsp;MCP serveru,
zavolání nástroje a získání výsledku z&nbsp;tohoto nástroje, budeme realizovat
v&nbsp;jazyce Go. MCP klient se vlastně nijak zásadně neliší od prvního klienta
popsaného <a href="#k06">v&nbsp;šesté kapitole</a>, pouze namísto přečtení
zdroje (<i>resource</i>) zavoláme nástroj (<i>tool</i>), takže jen
v&nbsp;krátkosti:</p>

<pre>
package <strong>main</strong>
&nbsp;
import (
        "context"
        "log"
        "os/exec"
&nbsp;
        mcp "github.com/metoro-io/mcp-golang"
        "github.com/metoro-io/mcp-golang/transport/stdio"
)
&nbsp;
<i>// Define type-safe arguments</i>
type <strong>CalculateArgs</strong> struct {
        N int `json:"n"`
}
&nbsp;
func <strong>main</strong>() {
        cmd := exec.Command("go", "run", "./mcp_server_3.go")
&nbsp;
        stdin, err := cmd.StdinPipe()
        if err != nil {
                log.Fatalf("Failed to get stdin pipe: %v", err)
        }
&nbsp;
        stdout, err := cmd.StdoutPipe()
        if err != nil {
                log.Fatalf("Failed to get stdout pipe: %v", err)
        }
&nbsp;
        if err := cmd.Start(); err != nil {
                log.Fatalf("Failed to start server: %v", err)
        }
&nbsp;
        defer cmd.Process.Kill()
&nbsp;
        transport := stdio.NewStdioServerTransportWithIO(stdout, stdin)
        client := mcp.NewClient(transport)
&nbsp;
        if _, err := client.Initialize(context.Background()); err != nil {
                log.Fatalf("Failed to initialize: %v", err)
        }
&nbsp;
        for n := range 11 {
                args := CalculateArgs{N: n}
                response, err := client.CallTool(
                        context.Background(),
                        "factorial",
                        args)
                if err != nil {
                        log.Fatalf("Failed to call tool: %v", err)
                }
&nbsp;
                if response != nil &amp;&amp; len(response.Content) &gt; 0 {
                        factorial := response.Content[0].TextContent.Text
                        log.Printf("%d! = %s", n, factorial)
                }
        }
&nbsp;
}
</pre>

<p><div class="rs-tip-major">Poznámka: nový je způsob zpracování výsledků
nástroje, ovšem z&nbsp;programového kódu by měl být celý postup jasně
patrný.</div></p>

<p>V&nbsp;dalším kroku otestujeme funkčnost komunikace mezi MCP klientem a MCP
serverem:</p>

<pre>
$ <strong>go run mcp_client_3.go</strong>
&nbsp;
2025/04/08 13:55:27 0! = 1
2025/04/08 13:55:27 1! = 1
2025/04/08 13:55:27 2! = 2
2025/04/08 13:55:27 3! = 6
2025/04/08 13:55:27 4! = 24
2025/04/08 13:55:27 5! = 120
2025/04/08 13:55:27 6! = 720
2025/04/08 13:55:27 7! = 5040
2025/04/08 13:55:27 8! = 40320
2025/04/08 13:55:27 9! = 362880
2025/04/08 13:55:27 10! = 3628800
</pre>



<p><a name="k13"></a></p>
<h2 id="k13">13. Podpora pro výzvy (<i>prompt</i>)</h2>

<p>Mnoho v&nbsp;současnosti vyvíjených aplikací, které nějakým způsobem
využívají umělou inteligenci, je založeno na použití velkých jazykových modelů
(<i>LLM &ndash; Large Language Model</i>). Tyto modely nabízí různá komunikační
rozhraní, která do značné míry závisí na provozovateli tohoto modelu
(<i>providers</i>). Mnohé modely+provozovatelé například podporují OpenAI,
modely od IBM pak komunikují po rozhraní definovaném ve WatsonX atd. Ovšem
stejně tak je možné vlastní volání LLM modelu &bdquo;uzavřít&ldquo; do MCP
serveru s&nbsp;tím, že všichni klienti budou komunikovat právě s&nbsp;tímto MCP
serverem s&nbsp;využitím Model Context Protocolu. A právě pro tento účel slouží
výzvy (<i>prompt</i>), které je možné považovat za specifickou skupinu nástrojů
(zde již poněkud zjednodušuji &ndash; záleží totiž více na sémantice, i když
způsob práce s&nbsp;výzvou je do značné míry podobná práci s&nbsp;nástrojem). U
každé výzvy nabízené MCP serverem je definováno její jméno, popis a argumenty
(jméno+popis+informace, zda je argument povinný či nikoli).</p>



<p><a name="k14"></a></p>
<h2 id="k14">14. Jednoduchý MCP server s&nbsp;výzvou (prompt)</h2>

<p>Popišme si nyní krok za krokem způsob implementace MCP serveru, který
s&nbsp;klienty dokáže komunikovat přes výzvy (<i>prompt</i>. Základní struktura
tohoto serveru se podobá již oběma výše popsaným serverům. Nejdříve si necháme
zkonstruovat objekt (záznam), který představuje vlastní MCP server:</p>

<pre>
server := mcp_golang.NewServer(stdio.NewStdioServerTransport())
</pre>

<p>Následně zaregistrujeme handler pro výzvu pojmenovanou například
<i>prompt_test</i>. V&nbsp;této chvíli již překladač programovacího jazyka Go
musí handler znát, ale my si ho ukážeme až o několik řádků níže:</p>

<pre>
err := server.RegisterPrompt("prompt_test", "This is a test prompt", promptHandler)
</pre>

<p>Server spustíme (pochopitelně s&nbsp;kontrolou případné chyby, která může
v&nbsp;průběhu inicializace nastat):</p>

<pre>
err = server.Serve()
</pre>

<p>Samotný handler pro výzvu má podobnou strukturu jako handler pro nástroj.
Musíme tedy nejdříve definovat strukturu dat předávaných do handleru. Interně
je přenos prováděn přes formát JSON. Podívejme se na definici typu záznamu
(struktury) s&nbsp;dvojicí atributů <strong>Title</strong> a
<strong>Description</strong>. Současně je specifikováno, jakým způsobem bude
prováděna serializace do formátu JSON:</p>

<pre>
type <strong>Content</strong> struct {
        Title       string `json:"title" jsonschema:"required,description=The title to submit"`
        Description string `json:"description" jsonschema:"description=The description to submit"`
}
</pre>

<p>Samotný handler přečte z&nbsp;předaných dat atribut <strong>Title</strong> a
vytvoří na jeho základě odpověď. Ta bude například pro vstupní data
<strong>Title=Pavel</strong> vypadat takto: "Hello, Pavel!". Musíme pouze
explicitně vlastní řetězec, který obsahuje odpověď, &bdquo;zabalit&ldquo; do
struktury typu <strong>PromptMessage</strong> a tu následně do struktury
<strong>PromptResponse</strong>. To sice zní složitě, ale vlastní implementace
je snadná:</p>

<pre>
func <strong>promptHandler</strong>(arguments Content) (*mcp_golang.PromptResponse, error) {
        text := mcp_golang.NewTextContent(fmt.Sprintf("Hello, %s!", arguments.Title))
        message := mcp_golang.NewPromptMessage(text, mcp_golang.RoleUser)
        response := mcp_golang.NewPromptResponse("description", message)
        return response, nil
}
</pre>

<p><div class="rs-tip-major">Poznámka: v&nbsp;Pythonu naproti tomu toto
zabalení do značné míry realizovala samotná MCP knihovna.</div></p>



<p><a name="k15"></a></p>
<h2 id="k15">15. Úplný zdrojový kód serveru nabízejícího výzvu</h2>

<p>Úplný zdrojový kód <a href="#k14">výše popsaného</a> MCP serveru
s&nbsp;výzvou (<i>prompt</i>) naprogramovaného v&nbsp;jazyce Go vypadá
následovně:</p>

<pre>
<i>// Jednoduchý MCP server s výzvou (prompt)</i>
&nbsp;
package <strong>main</strong>
&nbsp;
import (
        "fmt"
&nbsp;
        mcp_golang "github.com/metoro-io/mcp-golang"
        "github.com/metoro-io/mcp-golang/transport/stdio"
)
&nbsp;
type <strong>Content</strong> struct {
        Title       string `json:"title" jsonschema:"required,description=The title to submit"`
        Description string `json:"description" jsonschema:"description=The description to submit"`
}
&nbsp;
func <strong>promptHandler</strong>(arguments Content) (*mcp_golang.PromptResponse, error) {
        text := mcp_golang.NewTextContent(fmt.Sprintf("Hello, %s!", arguments.Title))
        message := mcp_golang.NewPromptMessage(text, mcp_golang.RoleUser)
        response := mcp_golang.NewPromptResponse("description", message)
        return response, nil
}
&nbsp;
func <strong>main</strong>() {
        done := make(chan struct{})
&nbsp;
        server := mcp_golang.NewServer(stdio.NewStdioServerTransport())
&nbsp;
        err := server.RegisterPrompt("prompt_test", "This is a test prompt", promptHandler)
&nbsp;
        err = server.Serve()
        if err != nil {
                panic(err)
        }
&nbsp;
        &lt;-done
}
</pre>



<p><a name="k16"></a></p>
<h2 id="k16">16. Komunikace s&nbsp;MCP serverem přes nabízenou výzvu</h2>

<p>Jak bude realizována komunikace MCP klienta s&nbsp;MCP serverem přes
nabízenou výzvu? Se znalostmi, které již máme, je to vlastně snadné. Nejdříve
MCP server spustíme (nevyužívám zde SSE, ale STDIO):</p>

<pre>
cmd := exec.Command("go", "run", "./mcp_server_4.go")
</pre>

<p>Navážeme propojení mezi oběma procesy přes STDIO, což již dobře známe:</p>

<pre>
stdin, err := cmd.StdinPipe()
if err != nil {
        log.Fatalf("Failed to get stdin pipe: %v", err)
}
&nbsp;
stdout, err := cmd.StdoutPipe()
if err != nil {
        log.Fatalf("Failed to get stdout pipe: %v", err)
}
</pre>

<p>Nakonec server inicializujeme a připojíme se k&nbsp;němu:</p>

<pre>
if err := cmd.Start(); err != nil {
        log.Fatalf("Failed to start server: %v", err)
}
&nbsp;
transport := stdio.NewStdioServerTransportWithIO(stdout, stdin)
client := mcp.NewClient(transport)
</pre>

<p>Následně si opět definujeme strukturu používanou pro komunikaci mezi
klientem a serverem. Povšimněte si, že druhý atribut je definován formou
ukazatele a nemusí být inicializován (není &bdquo;required&ldquo;):</p>

<pre>
type <strong>Content</strong> struct {
        Title       string  `json:"title" jsonschema:"required,description=The title to submit"`
        Description *string `json:"description" jsonschema:"description=The description to submit"`
}
</pre>

<p>Poslání zprávy výzvě a získání odpovědí (obecně většího množství zpráv):</p>

<pre>
content := Content{Title: "Foo"}
&nbsp;
response, err := client.GetPrompt(ctx, "prompt_test", content)
if err != nil {
        log.Fatalf("Failed to get prompt: %v", err)
}
</pre>

<p>Pokud nedošlo k&nbsp;chybě, zkusíme získané zprávy přečíst (jednu po druhé)
a vypsat je do logu:</p>

<pre>
if response != nil {
        messages := response.Messages
        for i, message := range messages {
                text := *message.Content.TextContent
                log.Println(i, text.Text)
        }
}
</pre>

<p>Vše si otestujeme spuštěním klienta:</p>

<pre>
$ <strong>go run mcp_client_4.go </strong>
</pre>

<p>Do logu by se měla vypsat odpověď v&nbsp;tomto tvaru (samozřejmě, že časové
razítko bude odlišné). Jméno &bdquo;Foo&ldquo; jsme předali do výzvy, takže je
zřejmé, že komunikace probíhá podle předpokladů:</p>

<pre>
2025/04/09 17:09:16 0 Hello, Foo!
</pre>



<p><a name="k17"></a></p>
<h2 id="k17">17. Úplný zdrojový kód klienta, který komunikuje přes výzvu</h2>

<p>Posledním zdrojovým kódem, který si dnes ukážeme, je MCP klient
naprogramovaný v&nbsp;Go, který s&nbsp;MCP klientem komunikuje přes výzvu
(<i>prompt</i>):</p>

<pre>
<i>// MCP klient, který komunikuje přes prompt</i>
&nbsp;
package <strong>main</strong>
&nbsp;
import (
        "context"
        "log"
        "os/exec"
&nbsp;
        mcp "github.com/metoro-io/mcp-golang"
        "github.com/metoro-io/mcp-golang/transport/stdio"
)
&nbsp;
func <strong>main</strong>() {
        cmd := exec.Command("go", "run", "./mcp_server_4.go")
&nbsp;
        stdin, err := cmd.StdinPipe()
        if err != nil {
                log.Fatalf("Failed to get stdin pipe: %v", err)
        }
&nbsp;
        stdout, err := cmd.StdoutPipe()
        if err != nil {
                log.Fatalf("Failed to get stdout pipe: %v", err)
        }
&nbsp;
        if err := cmd.Start(); err != nil {
                log.Fatalf("Failed to start server: %v", err)
        }
&nbsp;
        defer cmd.Process.Kill()
&nbsp;
        transport := stdio.NewStdioServerTransportWithIO(stdout, stdin)
        client := mcp.NewClient(transport)
&nbsp;
        ctx := context.Background()
&nbsp;
        if _, err := client.Initialize(ctx); err != nil {
                log.Fatalf("Failed to initialize: %v", err)
        }
&nbsp;
        type <strong>Content</strong> struct {
                Title       string  `json:"title" jsonschema:"required,description=The title to submit"`
                Description *string `json:"description" jsonschema:"description=The description to submit"`
        }
        content := Content{Title: "Foo"}
&nbsp;
        response, err := client.GetPrompt(ctx, "prompt_test", content)
        if err != nil {
                log.Fatalf("Failed to get prompt: %v", err)
        }
&nbsp;
        if response != nil {
                messages := response.Messages
                for i, message := range messages {
                        text := *message.Content.TextContent
                        log.Println(i, text.Text)
                }
        }
}
</pre>



<p><a name="k18"></a></p>
<h2 id="k18">18. Omezení a chyby knihovny <strong>mcp-golang</strong></h2>

<p>Knihovna <strong>mcp-golang</strong>, jejíž základní vlastnosti jsme si
popsali v&nbsp;dnešním článku, dokáže bez problémů pracovat s&nbsp;nástroji a
s&nbsp;výzvami. Kupodivu je problematická práce se zdroji, což je zvláštní,
protože z&nbsp;implementačního hlediska se jedná o tu jednodušší část MCP.
Další nevýhodou této knihovny je fakt, že i pro realizaci jednoduchého nástroje
nebo výzvy je nutné pracovat s&nbsp;mnoha strukturami, které se do sebe
&bdquo;zabalují&ldquo;: <strong>EmbeddedResource</strong>,
<strong>ResourceResponse</strong>, <strong>TextContent</strong>,
<strong>ToolResponse</strong>, <strong>PromptMessage</strong>,
<strong>PromptResponse</strong> atd. Na jednu stranu se jedná o logické a navíc
i poměrně univerzální řešení, ovšem na stranu druhou nelze popřít, že
implementace MCP serveru v&nbsp;Pythonu je mnohem jednodušší &ndash; a zejména
&bdquo;AI systémy&ldquo; jsou v&nbsp;současnosti mnohdy vyvíjeny co nejrychleji
s&nbsp;tím, že se celé velké části těchto systémů stejně dříve či později
zahodí (což je však téma na zcela odlišný článek).</p>



<p><a name="k19"></a></p>
<h2 id="k19">19. Repositář s&nbsp;demonstračními příklady</h2>

<p>Zdrojové kódy demonstračních příkladů, které byly popsány v&nbsp;dnešním
článku, jsou uloženy do repositáře <a
href="https://github.com/tisnik/most-popular-python-libs">https://github.com/tisnik/most-popular-python-libs</a>
a naleznete je na následujících adresách:</p>

<table>
<tr><th> #</th><th>Demonstrační příklad</th><th>Stručný popis příkladu</th><th>Cesta</th></tr>
<tr><td> 1</td><td>mcp_server_1.go</td><td>MCP server s&nbsp;definicí jediného zdroje bez selektorů</td><td><a href="https://github.com/tisnik/most-popular-python-libs/blob/master/mcp/mcp-golang/mcp_server_1.go">https://github.com/tisnik/most-popular-python-libs/blob/master/mcp/mcp-golang/mcp_server_1.go</a></td></tr>
<tr><td> 2</td><td>mcp_client_1.py</td><td>MCP klient komunikující s&nbsp;první verzí MCP serveru, naprogramováno v&nbsp;Pythonu</td><td><a href="https://github.com/tisnik/most-popular-python-libs/blob/master/mcp/mcp-golang/mcp_client_1.py">https://github.com/tisnik/most-popular-python-libs/blob/master/mcp/mcp-golang/mcp_client_1.py</a></td></tr>
<tr><td> 3</td><td>mcp_client_1.go</td><td>MCP klient komunikující s&nbsp;první verzí MCP serveru, naprogramováno v&nbsp;jazyce Go</td><td><a href="https://github.com/tisnik/most-popular-python-libs/blob/master/mcp/mcp-golang/mcp_client_1.go">https://github.com/tisnik/most-popular-python-libs/blob/master/mcp/mcp-golang/mcp_client_1.go</a></td></tr>
<tr><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td></tr>
<tr><td> 4</td><td>mcp_server_2.go</td><td>vylepšení struktury MCP serveru</td><td><a href="https://github.com/tisnik/most-popular-python-libs/blob/master/mcp/mcp-golang/mcp_server_2.go">https://github.com/tisnik/most-popular-python-libs/blob/master/mcp/mcp-golang/mcp_server_2.go</a></td></tr>
<tr><td> 5</td><td>mcp_client_2.py</td><td>MCP klient komunikující se druhou verzí MCP serveru, naprogramováno v&nbsp;Pythonu</td><td><a href="https://github.com/tisnik/most-popular-python-libs/blob/master/mcp/mcp-golang/mcp_client_2.py">https://github.com/tisnik/most-popular-python-libs/blob/master/mcp/mcp-golang/mcp_client_2.py</a></td></tr>
<tr><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td></tr>
<tr><td> 6</td><td>mcp_server_3.go</td><td>realizace serveru s&nbsp;definovaným nástrojem (<i>tool</i>)</td><td><a href="https://github.com/tisnik/most-popular-python-libs/blob/master/mcp/mcp-golang/mcp_server_3.go">https://github.com/tisnik/most-popular-python-libs/blob/master/mcp/mcp-golang/mcp_server_3.go</a></td></tr>
<tr><td> 7</td><td>mcp_client_3.py</td><td>zavolání nástroje z&nbsp;Pythonu</td><td><a href="https://github.com/tisnik/most-popular-python-libs/blob/master/mcp/mcp-golang/mcp_client_3.py">https://github.com/tisnik/most-popular-python-libs/blob/master/mcp/mcp-golang/mcp_client_3.py</a></td></tr>
<tr><td> 8</td><td>mcp_client_3.go</td><td>zavolání nástroje z&nbsp;jazyka Go</td><td><a href="https://github.com/tisnik/most-popular-python-libs/blob/master/mcp/mcp-golang/mcp_client_3.go">https://github.com/tisnik/most-popular-python-libs/blob/master/mcp/mcp-golang/mcp_client_3.go</a></td></tr>
<tr><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td></tr>
<tr><td> 9</td><td>mcp_server_4.go</td><td>realizace serveru s&nbsp;definovanou výzvou (<i>prompt</i>)</td><td><a href="https://github.com/tisnik/most-popular-python-libs/blob/master/mcp/mcp-golang/mcp_server_4.go">https://github.com/tisnik/most-popular-python-libs/blob/master/mcp/mcp-golang/mcp_server_4.go</a></td></tr>
<tr><td>10</td><td>mcp_client_4.go</td><td>komunikace přes výzvu (<i>prompt</i>) realizovaná v&nbsp;jazyce Go</td><td><a href="https://github.com/tisnik/most-popular-python-libs/blob/master/mcp/mcp-golang/mcp_client_4.go">https://github.com/tisnik/most-popular-python-libs/blob/master/mcp/mcp-golang/mcp_client_4.go</a></td></tr>
</table>

<p>Zdrojové kódy všech minule a předminule popsaných demonstračních příkladů
určených pro Python a balíček <a
href="https://github.com/modelcontextprotocol/python-sdk">mcp</a> byly uloženy
do stejného repositáře dostupného na adrese <a
href="https://github.com/tisnik/most-popular-python-libs">https://github.com/tisnik/most-popular-python-libs</a>.
V&nbsp;tabulce zobrazené níže jsou odkazy na jednotlivé příklady:</p>

<table>
<tr><th> #</th><th>Demonstrační příklad</th><th>Stručný popis příkladu</th><th>Cesta</th></tr>
<tr><td> 1</td><td>mcp_server_1.py</td><td>jednoduchý MCP server s&nbsp;jediným definovaným zdrojem</td><td><a href="https://github.com/tisnik/most-popular-python-libs/blob/master/mcp/mcp_server_1.py">https://github.com/tisnik/most-popular-python-libs/blob/master/mcp/mcp_server_1.py</a></td></tr>
<tr><td> 2</td><td>mcp_server_2.py</td><td>jednoduchý MCP server s&nbsp;jediným definovaným dynamickým zdrojem</td><td><a href="https://github.com/tisnik/most-popular-python-libs/blob/master/mcp/mcp_server_2.py">https://github.com/tisnik/most-popular-python-libs/blob/master/mcp/mcp_server_2.py</a></td></tr>
<tr><td> 3</td><td>mcp_server_3.py</td><td>MCP server s&nbsp;dynamickým zdrojem a definicí nástroje (tool)</td><td><a href="https://github.com/tisnik/most-popular-python-libs/blob/master/mcp/mcp_server_3.py">https://github.com/tisnik/most-popular-python-libs/blob/master/mcp/mcp_server_3.py</a></td></tr>
<tr><td> 4</td><td>mcp_server_4.py</td><td>MCP server s jediným definovaným dynamickým zdrojem, zápis informací o spuštění</td><td><a href="https://github.com/tisnik/most-popular-python-libs/blob/master/mcp/mcp_server_4.py">https://github.com/tisnik/most-popular-python-libs/blob/master/mcp/mcp_server_4.py</a></td></tr>
<tr><td> 5</td><td>mcp_server_5.py</td><td>MCP server, který se přímo spustí v&nbsp;režimu STDIO</td><td><a href="https://github.com/tisnik/most-popular-python-libs/blob/master/mcp/mcp_server_5.py">https://github.com/tisnik/most-popular-python-libs/blob/master/mcp/mcp_server_5.py</a></td></tr>
<tr><td> 6</td><td>mcp_server_6.py</td><td>MCP server, který se přímo spustí v&nbsp;režimu SSE</td><td><a href="https://github.com/tisnik/most-popular-python-libs/blob/master/mcp/mcp_server_6.py">https://github.com/tisnik/most-popular-python-libs/blob/master/mcp/mcp_server_6.py</a></td></tr>
<tr><td> 7</td><td>mcp_server_7.py</td><td>MCP server se zdrojem vracejícím strukturovaná data</td><td><a href="https://github.com/tisnik/most-popular-python-libs/blob/master/mcp/mcp_server_7.py">https://github.com/tisnik/most-popular-python-libs/blob/master/mcp/mcp_server_7.py</a></td></tr>
<tr><td> 8</td><td>mcp_server_8.py</td><td>MCP server se zdrojem vracejícím strukturovaná data</td><td><a href="https://github.com/tisnik/most-popular-python-libs/blob/master/mcp/mcp_server_8.py">https://github.com/tisnik/most-popular-python-libs/blob/master/mcp/mcp_server_8.py</a></td></tr>
<tr><td> 9</td><td>mcp_server_9.py</td><td>MCP server, který dokáže poslat rastrový obrázek</td><td><a href="https://github.com/tisnik/most-popular-python-libs/blob/master/mcp/mcp_server_9.py">https://github.com/tisnik/most-popular-python-libs/blob/master/mcp/mcp_server_9.py</a></td></tr>
<tr><td>10</td><td>mcp_server_A.py</td><td>MCP server, který na požadavky odpovídá se zpožděním</td><td><a href="https://github.com/tisnik/most-popular-python-libs/blob/master/mcp/mcp_server_A.py">https://github.com/tisnik/most-popular-python-libs/blob/master/mcp/mcp_server_A.py</a></td></tr>
<tr><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td></tr>
<tr><td>11</td><td>mcp_client_1.py</td><td>MCP klient, který spustí server, se kterým se komunikuje přes STDIO</td><td><a href="https://github.com/tisnik/most-popular-python-libs/blob/master/mcp/mcp_client_1.py">https://github.com/tisnik/most-popular-python-libs/blob/master/mcp/mcp_client_1.py</a></td></tr>
<tr><td>12</td><td>mcp_client_2.py</td><td>MCP klient, který spustí server, se kterým se komunikuje přes SSE</td><td><a href="https://github.com/tisnik/most-popular-python-libs/blob/master/mcp/mcp_client_2.py">https://github.com/tisnik/most-popular-python-libs/blob/master/mcp/mcp_client_2.py</a></td></tr>
<tr><td>13</td><td>mcp_client_3.py</td><td>MCP klient, který přečte zvolený zdroj</td><td><a href="https://github.com/tisnik/most-popular-python-libs/blob/master/mcp/mcp_client_3.py">https://github.com/tisnik/most-popular-python-libs/blob/master/mcp/mcp_client_3.py</a></td></tr>
<tr><td>14</td><td>mcp_client_4.py</td><td>MCP klient, který přečte zvolený zdroj a získá z&nbsp;něj data</td><td><a href="https://github.com/tisnik/most-popular-python-libs/blob/master/mcp/mcp_client_4.py">https://github.com/tisnik/most-popular-python-libs/blob/master/mcp/mcp_client_4.py</a></td></tr>
<tr><td>15</td><td>mcp_client_5.py</td><td>MCP klient, který zavolá vybraný nástroj</td><td><a href="https://github.com/tisnik/most-popular-python-libs/blob/master/mcp/mcp_client_5.py">https://github.com/tisnik/most-popular-python-libs/blob/master/mcp/mcp_client_5.py</a></td></tr>
<tr><td>16</td><td>mcp_client_6.py</td><td>MCP klient, který přečte a zpracuje strukturovaná data</td><td><a href="https://github.com/tisnik/most-popular-python-libs/blob/master/mcp/mcp_client_6.py">https://github.com/tisnik/most-popular-python-libs/blob/master/mcp/mcp_client_6.py</a></td></tr>
<tr><td>17</td><td>mcp_client_7.py</td><td>MCP klient, který dokáže načíst rastrový obrázek</td><td><a href="https://github.com/tisnik/most-popular-python-libs/blob/master/mcp/mcp_client_7.py">https://github.com/tisnik/most-popular-python-libs/blob/master/mcp/mcp_client_7.py</a></td></tr>
<tr><td>18</td><td>mcp_client_8.py</td><td>MCP klient s&nbsp;měřením času odpovědí MCP serveru</td><td><a href="https://github.com/tisnik/most-popular-python-libs/blob/master/mcp/mcp_client_8.py">https://github.com/tisnik/most-popular-python-libs/blob/master/mcp/mcp_client_8.py</a></td></tr>
<tr><td>19</td><td>mcp_client_9.py</td><td>MCP klient s&nbsp;měřením času odpovědí MCP serveru a více asynchronními voláními</td><td><a href="https://github.com/tisnik/most-popular-python-libs/blob/master/mcp/mcp_client_9.py">https://github.com/tisnik/most-popular-python-libs/blob/master/mcp/mcp_client_9.py</a></td></tr>
</table>



<p><a name="k20"></a></p>
<h2 id="k20">20. Odkazy na Internetu</h2>

<ol>

<li>MCP Python SDK<br />
<a href="https://github.com/modelcontextprotocol/python-sdk?tab=readme-ov-file#running-your-server">https://github.com/modelcontextprotocol/python-sdk?tab=readme-ov-file#running-your-server</a>
</li>

<li>MCP protocol: Resources<br />
<a href="https://modelcontextprotocol.info/docs/concepts/resources/">https://modelcontextprotocol.info/docs/concepts/resources/</a>
</li>

<li>Example Servers<br />
<a href="https://modelcontextprotocol.io/examples">https://modelcontextprotocol.io/examples</a>
</li>

<li>Core architecture<br />
<a href="https://modelcontextprotocol.io/docs/concepts/architecture">https://modelcontextprotocol.io/docs/concepts/architecture</a>
</li>

<li>Unleashing the Power of Model Context Protocol (MCP): A Game-Changer in AI Integration<br />
<a href="https://techcommunity.microsoft.com/blog/educatordeveloperblog/unleashing-the-power-of-model-context-protocol-mcp-a-game-changer-in-ai-integrat/4397564">https://techcommunity.microsoft.com/blog/educatordeveloperblog/unleashing-the-power-of-model-context-protocol-mcp-a-game-changer-in-ai-integrat/4397564</a>
</li>

<li>MPC inspector<br />
<a href="https://github.com/modelcontextprotocol/inspector">https://github.com/modelcontextprotocol/inspector</a>
</li>

<li>Model Context Protocol servers<br />
<a href="https://github.com/modelcontextprotocol/servers">https://github.com/modelcontextprotocol/servers</a>
</li>

<li>python-sdk na GitHubu<br />
<a href="https://github.com/modelcontextprotocol/python-sdk">https://github.com/modelcontextprotocol/python-sdk</a>
</li>

<li>typescript-sdk na GitHubu<br />
<a href="https://github.com/modelcontextprotocol/typescript-sdk">https://github.com/modelcontextprotocol/typescript-sdk</a>
</li>

<li>mcp-golang<br />
<a href="https://github.com/metoro-io/mcp-golang">https://github.com/metoro-io/mcp-golang</a>
</li>

<li>MCP server: A step-by-step guide to building from scratch<br />
<a href="https://composio.dev/blog/mcp-server-step-by-step-guide-to-building-from-scrtch/">https://composio.dev/blog/mcp-server-step-by-step-guide-to-building-from-scrtch/</a>
</li>

<li>How to Build an MCP Server Fast: A Step-by-Step Tutorial<br />
<a href="https://medium.com/@eugenesh4work/how-to-build-an-mcp-server-fast-a-step-by-step-tutorial-e09faa5f7e3b">https://medium.com/@eugenesh4work/how-to-build-an-mcp-server-fast-a-step-by-step-tutorial-e09faa5f7e3b</a>
</li>

<li>Step-by-Step Guide: Building an MCP Server using Python-SDK, AlphaVantage &amp; Claude AI<br />
<a href="https://medium.com/@syed_hasan/step-by-step-guide-building-an-mcp-server-using-python-sdk-alphavantage-claude-ai-7a2bfb0c3096">https://medium.com/@syed_hasan/step-by-step-guide-building-an-mcp-server-using-python-sdk-alphavantage-claude-ai-7a2bfb0c3096</a>
</li>

<li>RFC 6570: URI Template<br />
<a href="https://datatracker.ietf.org/doc/html/rfc6570">https://datatracker.ietf.org/doc/html/rfc6570</a>
</li>

<li>Return resources as structured JSON instead of text?<br />
<a href="https://github.com/modelcontextprotocol/python-sdk/issues/279">https://github.com/modelcontextprotocol/python-sdk/issues/279</a>
</li>

<li>Python standard library: pprint<br />
<a href="https://docs.python.org/3/library/pprint.html">https://docs.python.org/3/library/pprint.html</a>
</li>

<li>Python standard library: json — JSON encoder and decoder¶<br />
<a href="https://docs.python.org/3/library/json.html">https://docs.python.org/3/library/json.html</a>
</li>

<li>Calling MCP Servers the Hard Way<br />
<a href="https://deadprogrammersociety.com/2025/03/calling-mcp-servers-the-hard-way.html">https://deadprogrammersociety.com/2025/03/calling-mcp-servers-the-hard-way.html</a>
</li>

<li>mcptools<br />
<a href="https://github.com/f/mcptools">https://github.com/f/mcptools</a>
</li>

<li>Server-sent events<br />
<a href="https://en.wikipedia.org/wiki/Server-sent_events">https://en.wikipedia.org/wiki/Server-sent_events</a>
</li>

<li>Model context protocol (MCP)<br />
<a href="https://openai.github.io/openai-agents-python/mcp/">https://openai.github.io/openai-agents-python/mcp/</a>
</li>

<li>A Clear Intro to MCP (Model Context Protocol) with Code Examples<br />
<a href="https://towardsdatascience.com/clear-intro-to-mcp/">https://towardsdatascience.com/clear-intro-to-mcp/</a>
</li>

<li>A Developer's Guide to the MCP<br />
<a href="https://www.getzep.com/ai-agents/developer-guide-to-mcp">https://www.getzep.com/ai-agents/developer-guide-to-mcp</a>
</li>

<li>MCP: Flash in the Pan or Future Standard?<br />
<a href="https://blog.langchain.dev/mcp-fad-or-fixture/">https://blog.langchain.dev/mcp-fad-or-fixture/</a>
</li>

<li>MCP yeah you know me: A complete guide and review of Model Context Protocol (MCP)<br />
<a href="https://ebi.ai/blog/model-context-protocol-guide/">https://ebi.ai/blog/model-context-protocol-guide/</a>
</li>

<li>Pillow documentation<br />
<a href="https://pillow.readthedocs.io/en/stable/handbook/tutorial.html">https://pillow.readthedocs.io/en/stable/handbook/tutorial.html</a>
</li>

<li>Pillow: Python Imaging Library (Fork)<br />
<a href="https://pypi.org/project/pillow/">https://pypi.org/project/pillow/</a>
</li>

<li>How to use Pillow, a fork of PIL<br />
<a href="https://www.pythonforbeginners.com/gui/how-to-use-pillow">https://www.pythonforbeginners.com/gui/how-to-use-pillow</a>
</li>

<li>PNG is Not GIF<br />
<a href="https://www.root.cz/clanky/png-is-not-gif/">https://www.root.cz/clanky/png-is-not-gif/</a>
</li>

</ol>



<p></p><p></p>
<p><small>Autor: <a href="https://github.com/tisnik/">Pavel Tišnovský</a> &nbsp; 2024</small></p>
</body>
</html>

