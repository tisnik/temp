<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
        "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html>
<head>
<title>FAISS: knihovna pro rychlÃ© a efektivnÃ­ vyhledÃ¡vÃ¡nÃ­ podobnÃ½ch vektorÅ¯</title>
<meta name="Author" content="Pavel Tisnovsky" />
<meta name="Generator" content="vim" />
<meta http-equiv="content-type" content="text/html; charset=utf-8" />
<style type="text/css">
         body {color:#000000; background:#ffffff;}
         h1  {font-family: arial, helvetica, sans-serif; color:#ffffff; background-color:#c00000; text-align:center; padding-left:1em}
         h2  {font-family: arial, helvetica, sans-serif; color:#ffffff; background-color:#0000c0; padding-left:1em; text-align:left}
         h3  {font-family: arial, helvetica, sans-serif; color:#000000; background-color:#c0c0c0; padding-left:1em; text-align:left}
         h4  {font-family: arial, helvetica, sans-serif; color:#000000; background-color:#e0e0e0; padding-left:1em; text-align:left}
         a   {font-family: arial, helvetica, sans-serif;}
         li  {font-family: arial, helvetica, sans-serif; color:#000000; text-align:justify; width:450px;}
         ol  {font-family: arial, helvetica, sans-serif; color:#000000; text-align:justify; width:450px;}
         ul  {font-family: arial, helvetica, sans-serif; color:#000000; text-align:justify; width:450px;}
         p   {font-family: arial, helvetica, sans-serif; color:#000000; text-align:justify;}
         pre {background:#e0e0e0}
</style>
</head>

<body>

<h1>FAISS: knihovna pro rychlÃ© a efektivnÃ­ vyhledÃ¡vÃ¡nÃ­ podobnÃ½ch vektorÅ¯</h1>

<h3>Pavel TiÅ¡novskÃ½</h3>

<p></p>

<h1>ÃšvodnÃ­k</h1>

<p>V dneÅ¡nÃ­m ÄlÃ¡nku se seznÃ¡mÃ­me se zÃ¡kladnÃ­mi vlastnostmi knihovny FAISS, kterÃ¡ se urÄena pro vyhledÃ¡vÃ¡nÃ­ vektorÅ¯ (s vysokÃ½mi poÄty dimenzÃ­) na zÃ¡kladÄ› jejich podobnosti. Tato knihovna se pouÅ¾Ã­vÃ¡ pÅ™i zpracovÃ¡nÃ­ pÅ™irozenÃ©ho jazyka, jako zÃ¡klad RAG databÃ¡zÃ­ atd.</p>



<h2>Obsah</h2>

<p><a href="#k01">1. FAISS: knihovna pro rychlÃ© a efektivnÃ­ vyhledÃ¡vÃ¡nÃ­ podobnÃ½ch vektorÅ¯</a></p>
<p><a href="#k02">2. SvÄ›t vektorovÃ½ch databÃ¡zÃ­</a></p>
<p><a href="#k03">3. Je FAISS vektorovou databÃ¡zÃ­?</a></p>
<p><a href="#k04">4. Å˜eÅ¡enÃ½ problÃ©m: nalezenÃ­ nejbliÅ¾Å¡Ã­ch <i>k</i> bodÅ¯ k&nbsp;zadanÃ½m souÅ™adnicÃ­m</a></p>
<p><a href="#k05">5. PÅ™Ã­prava projektu</a></p>
<p><a href="#k06">6. Instalace balÃ­ÄkÅ¯ <strong>faiss-cpu</strong> a <strong>numpy</strong> do virtuÃ¡lnÃ­ho prostÅ™edÃ­</a></p>
<p><a href="#k07">7. Definice souÅ™adnic bodÅ¯ v&nbsp;rovinÄ›</a></p>
<p><a href="#k08">8. Konstrukce matice se souÅ™adnicemi bodÅ¯</a></p>
<p><a href="#k09">9. Konstrukce indexu pro vyhledÃ¡vÃ¡nÃ­ na zÃ¡kladÄ› vzdÃ¡lenosti</a></p>
<p><a href="#k10">10. NalezenÃ­ nejbliÅ¾Å¡Ã­ch bodÅ¯ k&nbsp;zadanÃ½m souÅ™adnicÃ­m</a></p>
<p><a href="#k11">11. VÃ½pis souÅ™adnic bodÅ¯ nejbliÅ¾Å¡Ã­ch k&nbsp;zadanÃ½m souÅ™adnicÃ­m</a></p>
<p><a href="#k12">12. Vizualizace nejbliÅ¾Å¡Ã­ch nalezenÃ½ch bodÅ¯</a></p>
<p><a href="#k13">13. VÃ½bÄ›ry vektorÅ¯ na zÃ¡kladÄ› jejich podobnosti: volba metriky</a></p>
<p><a href="#k14">14. VÃ½bÄ›r podobnÃ½ch vektorÅ¯ pomocÃ­ skalÃ¡rnÃ­ho souÄinu: nekorektnÃ­ verze</a></p>
<p><a href="#k15">15. Normalizace vektorÅ¯ v&nbsp;indexu</a></p>
<p><a href="#k16">16. Rychlost vyhledÃ¡nÃ­ nejbliÅ¾Å¡Ã­ch bodÅ¯</a></p>
<p><a href="#k17">17. VÃ½sledky benchmarku</a></p>
<p><a href="#k18">18. Obsah navazujÃ­cÃ­ho ÄlÃ¡nku</a></p>
<p><a href="#k19">19. RepositÃ¡Å™ s&nbsp;demonstraÄnÃ­mi pÅ™Ã­klady</a></p>
<p><a href="#k20">20. Odkazy na Internetu</a></p>



<p><a name="k01"></a></p>
<h2 id="k01">1. FAISS: knihovna pro rychlÃ© a efektivnÃ­ vyhledÃ¡vÃ¡nÃ­ podobnÃ½ch vektorÅ¯</h2>

<p>V&nbsp;souÄasnosti mÅ¯Å¾eme sledovat pomÄ›rnÄ› vÃ½raznÃ© a stÃ¡le ÄastÄ›jÅ¡Ã­
nasazovÃ¡nÃ­ vektorovÃ½ch databÃ¡zÃ­. JednÃ¡ se (vÄ›tÅ¡inou) o specializovanÃ© databÃ¡ze,
kterÃ© umoÅ¾ÅˆujÃ­ uklÃ¡dat vektory numerickÃ½ch hodnot a pÅ™edevÅ¡Ã­m efektivnÄ›
vyhledÃ¡vat vektory podle jejich podobnosti (napÅ™Ã­klad se zadanÃ½m vzorem),
pÅ™iÄemÅ¾ <i>podobnostÃ­</i> mÅ¯Å¾e bÃ½t v&nbsp;tomto kontextu myÅ¡lena napÅ™Ã­klad
vzdÃ¡lenost koncovÃ½ch bodÅ¯ vektorÅ¯ v&nbsp;EukleidovskÃ©m prostoru, kosinus Ãºhlu
mezi vektory, vÃ½sledek skalÃ¡rnÃ­ho souÄinu (pro normalizovanÃ© vektory) atd.</p>

<p>Tyto operace se pouÅ¾Ã­vajÃ­ v&nbsp;mnoha oblastech, napÅ™Ã­klad pÅ™i rozpoznÃ¡vÃ¡nÃ­
a zpracovÃ¡nÃ­ pÅ™irozenÃ©ho jazyka (<i>NLP &ndash; Natural Language
Processing</i>), pÅ™i rozpoznÃ¡vÃ¡nÃ­ obrÃ¡zkÅ¯, rozpoznÃ¡vÃ¡nÃ­ hlasÅ¯, detekci
anomÃ¡liÃ­, ale i (a to zejmÃ©na) v&nbsp;souvislosti s&nbsp;velkÃ½mi jazykovÃ½mi
modely (k&nbsp;tomuto tÃ©matu se jeÅ¡tÄ› vrÃ¡tÃ­me v&nbsp;samostatnÃ©m ÄlÃ¡nku).</p>

<p><div class="rs-tip-major">PoznÃ¡mka: do tÃ©to kategorie spadajÃ­ i RAG
databÃ¡ze.</div></p>

<p>Na strÃ¡nkÃ¡ch Roota jsme se jiÅ¾ v&nbsp;ÄlÃ¡nku <a
href="https://www.root.cz/clanky/pgvector-vektorova-databaze-postavena-na-postgresu/">pgvector:
vektorovÃ¡ databÃ¡ze postavenÃ¡ na Postgresu</a> seznÃ¡mili s&nbsp;vektorovou
databÃ¡zÃ­ <strong>pgvector</strong>, kterÃ¡ je postavena nad Postgresem. Dnes si
popÃ­Å¡eme zÃ¡kladnÃ­ vlastnosti knihovny nazvanÃ© <strong>FAISS</strong>, coÅ¾ je
jmÃ©no, kterÃ© vzniklo ze souslovÃ­ <i>Facebook AI Similarity Search</i> (ovÅ¡em
tato knihovna se pouÅ¾Ã­vÃ¡ i v&nbsp;mnoha projektech, kterÃ© nemajÃ­
s&nbsp;Facebookem nebo Metou cokoli spoleÄnÃ©ho). FAISS je Å¡Ã­Å™ena pod MIT
licencÃ­, coÅ¾ umoÅ¾Åˆuje jejÃ­ relativnÄ› snadnÃ© zaÅ™azenÃ­ do dalÅ¡Ã­ch projektÅ¯.</p>



<p><a name="k02"></a></p>
<h2 id="k02">2. SvÄ›t vektorovÃ½ch databÃ¡zÃ­</h2>

<p>S&nbsp;rozvojem systÃ©mÅ¯ urÄenÃ½ch pro zpracovÃ¡nÃ­ pÅ™irozenÃ©ho jazyka i
generativnÃ­ch AI (zejmÃ©na velkÃ½ch jazykovÃ½ch modelÅ¯) doÅ¡lo i k&nbsp;velkÃ©mu
rozmachu vektorovÃ½ch databÃ¡zÃ­. Dnes jich existuje minimÃ¡lnÄ› nÄ›kolik desÃ­tek
(pokud poÄÃ­tÃ¡me ty nejznÃ¡mÄ›jÅ¡Ã­ a/nebo veÅ™ejnÄ› dostupnÃ©), ovÅ¡em spÃ­Å¡e jich bude
nÄ›kolik set.</p>

<p>V&nbsp;tabulce pod tÃ­mto odstavcem jsou vypsÃ¡ny ty nejznÃ¡mÄ›jÅ¡Ã­ vektorovÃ©
databÃ¡ze, kterÃ© pochopitelnÄ› majÃ­ rozdÃ­lnÃ© vlastnosti a kaÅ¾dÃ¡ z&nbsp;nich se
hodÃ­ pro jinÃ© zpÅ¯soby nasazenÃ­:</p>

<table>
<tr><td>Aerospike</td></tr>
<tr><td>AllegroGraph</td></tr>
<tr><td>Apache Cassandra</td></tr>
<tr><td>Azure Cosmos DB</td></tr>
<tr><td>Chroma</td></tr>
<tr><td>ClickHouse</td></tr>
<tr><td>Couchbase</td></tr>
<tr><td>CrateDB</td></tr>
<tr><td>DataStax</td></tr>
<tr><td>Elasticsearch</td></tr>
<tr><td>HAKES</td></tr>
<tr><td>HDF5 Query Indexing</td></tr>
<tr><td>JaguarDB</td></tr>
<tr><td>LanceDB</td></tr>
<tr><td>Lantern</td></tr>
<tr><td>LlamaIndex</td></tr>
<tr><td>MariaDB</td></tr>
<tr><td>Marqo</td></tr>
<tr><td>Meilisearch</td></tr>
<tr><td>Milvus</td></tr>
<tr><td>MongoDB Atlas</td></tr>
<tr><td>Neo4j</td></tr>
<tr><td>ObjectBox</td></tr>
<tr><td>OpenSearch</td></tr>
<tr><td>Oracle Database</td></tr>
<tr><td>Pinecone</td></tr>
<tr><td>Pixeltable (Incremental Embedding)</td></tr>
<tr><td>Postgres with pgvector</td></tr>
<tr><td>Qdrant</td></tr>
<tr><td>Redis Stack</td></tr>
<tr><td>Snowflake</td></tr>
<tr><td>SurrealDB</td></tr>
<tr><td>Typesense</td></tr>
<tr><td>Vespa</td></tr>
<tr><td>Weaviate</td></tr>
</table>



<p><a name="k03"></a></p>
<h2 id="k03">3. Je FAISS vektorovou databÃ¡zÃ­?</h2>

<p>V&nbsp;nÄ›kterÃ½ch ÄlÃ¡ncÃ­ch se mÅ¯Å¾eme doÄÃ­st, Å¾e FAISS je vektorovou databÃ¡zÃ­.
OvÅ¡em to ve skuteÄnosti nenÃ­ pravda, protoÅ¾e FAISS &bdquo;pouze&ldquo;
poskytuje algoritmy urÄenÃ© pro efektivnÃ­ vyhledÃ¡vÃ¡nÃ­ podobnÃ½ch vektorÅ¯ a pro
jejich shlukovÃ¡nÃ­ (<i>clustering</i>). NeÅ™eÅ¡Ã­ ovÅ¡em problÃ©m uloÅ¾enÃ­ vektorÅ¯
v&nbsp;nÄ›jakÃ©m strukturovanÃ©m formÃ¡tu. Naopak, nÄ›kterÃ© skuteÄnÃ© vektorovÃ©
databÃ¡ze, mezi kterÃ© patÅ™Ã­ napÅ™Ã­klad <i>Milvus</i> nebo <i>OpenSearch</i>,
vyuÅ¾Ã­vajÃ­ FAISS pro vyhledÃ¡vÃ¡nÃ­, ovÅ¡em zpÅ¯sob uloÅ¾enÃ­ a naÄÃ­tÃ¡nÃ­ vektorÅ¯ Å™eÅ¡Ã­
ve svÃ© vlastnÃ­ reÅ¾ii.</p>

<p><div class="rs-tip-major">PoznÃ¡mka: na druhou stranu je vÅ¡ak efektivnÃ­
vyhledÃ¡vÃ¡nÃ­ podobnÃ½ch vektorÅ¯ ÃºstÅ™ednÃ­m prvkem mnoha systÃ©mÅ¯ s&nbsp;AI, takÅ¾e
volba vhodnÃ© knihovny pro tyto operace bÃ½vÃ¡ mnohem dÅ¯leÅ¾itÄ›jÅ¡Ã­, neÅ¾ vlastnÃ­
zpÅ¯sob uloÅ¾enÃ­ vektorÅ¯ v&nbsp;databÃ¡zi. Je tomu tak z&nbsp;toho dÅ¯vodu, Å¾e
vektory majÃ­ velkÃ½ poÄet dimenzÃ­ (i nÄ›kolik tisÃ­c) a samotnÃ½ch vektorÅ¯ mÅ¯Å¾e bÃ½t
nÄ›kolik milionÅ¯, i vÃ­ce. Volba optimÃ¡lnÃ­ho algoritmu (a popÅ™.&nbsp;provedenÃ­
vÃ½poÄtÅ¯ na GPU) je tedy v&nbsp;takovÃ½ch pÅ™Ã­padech kritickÃ¡.</div></p>



<p><a name="k04"></a></p>
<h2 id="k04">4. Å˜eÅ¡enÃ½ problÃ©m: nalezenÃ­ nejbliÅ¾Å¡Ã­ch <i>k</i> bodÅ¯ k&nbsp;zadanÃ½m souÅ™adnicÃ­m</h2>

<p>V&nbsp;navazujÃ­cÃ­m kapitolÃ¡ch se s&nbsp;vyuÅ¾itÃ­m knihovny <i>FAISS</i>
pokusÃ­me vyÅ™eÅ¡it nÃ¡sledujÃ­cÃ­ problÃ©m: v&nbsp;2D prostoru mÃ¡me patnÃ¡ct bodÅ¯ a
budeme chtÃ­t najÃ­t <i>k</i> bodÅ¯, kterÃ© jsou neblÃ­Å¾e k&nbsp;zadanÃ½m
souÅ™adnicÃ­m. Pokud bude <i>k=1</i>, tak budeme chtÃ­t nalÃ©zt nejbliÅ¾Å¡Ã­ bod atd.
Body jsou pÅ™itom v&nbsp;rovinÄ› rozmÃ­stÄ›ny nÃ¡sledujÃ­cÃ­m zpÅ¯sobem a u vybranÃ½ch
bodÅ¯ jsou zapsÃ¡ny i jejich souÅ™adnice:</p>

<pre>
                                       â”‚ y
                                       â”‚
                                       â”‚
                                       â”‚
                                       â”‚                [5,5]
                     o       o         â”‚          o   o   o
                                       â”‚          o   o   o
                         o             â”‚          o   o   o
                      [-4,3]           â”‚        [3,3]   [5,3]
                                       â”‚
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€[0,0]â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
                                       â”‚                                       x
                                       â”‚              o
                                       â”‚
                                       â”‚          o       o
                                       â”‚                [5,-5]
                                       â”‚
                                       â”‚
                                       â”‚
                                       â”‚
</pre>



<p><a name="k05"></a></p>
<h2 id="k05">5. PÅ™Ã­prava projektu</h2>

<p>V&nbsp;prvnÃ­m kroku si pÅ™ipravÃ­me projekt v&nbsp;Pythonu a nÃ¡slednÄ› do nÄ›j
nainstalujeme vÅ¡echny potÅ™ebnÃ© knihovny. Pro vytvoÅ™enÃ­ projektu pouÅ¾ijeme
nÃ¡stroj <i>PDM</i> &ndash; viz tÃ©Å¾ <a
href="https://www.root.cz/clanky/pdm-moderni-spravce-balicku-a-virtualnich-prostredi-pythonu/">PDM:
modernÃ­ sprÃ¡vce balÃ­ÄkÅ¯ a virtuÃ¡lnÃ­ch prostÅ™edÃ­ Pythonu</a>. Projekt bude
vytvoÅ™en v&nbsp;novÃ©m (pÅ¯vodnÄ› prÃ¡zdnÃ©m) adresÃ¡Å™i:</p>

<pre>
$ <strong>mkdir faiss-demo</strong>
$ <strong>cd faiss-demo</strong>
</pre>

<p>NÃ¡slednÄ› si nechÃ¡me vytvoÅ™it projektovÃ½ soubor nazvanÃ½
<strong>pyproject.toml</strong>. Na vÅ¡echny odpovÄ›di kladenÃ© nÃ¡strojem PDM
mÅ¯Å¾eme s&nbsp;klidem odpovÄ›dÄ›t jen klÃ¡vesou Enter:</p>

<pre>
$ <strong>pdm init</strong>
&nbsp;
Creating a pyproject.toml for PDM...
Please enter the Python interpreter to use
 0. cpython@3.12 (/usr/bin/python)
 1. cpython@3.13 (/usr/bin/python3.13)
 2. cpython@3.12 (/usr/bin/python3.12)
 3. cpython@3.11 (/usr/bin/python3.11)
Please select (0):
&nbsp;
&nbsp;
Virtualenv is created successfully at /tmp/ramdisk/faiss-demo/.venv
Project name (faiss-demo): Project version (0.1.0): Do you want to build this project for distribution(such as wheel)?
If yes, it will be installed by default when running `pdm install`. [y/n] (n):
License(SPDX name) (MIT):
Author name (Pavel Tisnovsky):
Author email (tisnik@nikdo.nikde.com):
Python requires('*' to allow any) (==3.12.*):
Project is initialized successfully
</pre>

<p>VÃ½slednÃ½ projektovÃ½ soubor <strong>pyproject.toml</strong> by mÄ›l vypadat
nÃ¡sledovnÄ› (samozÅ™ejmÄ› kromÄ› jmÃ©na, mailu a zvolenÃ© verze Pythonu):</p>

<pre>
[project]
name = "faiss-demo"
version = "0.1.0"
description = "Default template for PDM package"
authors = [
    {name = "Pavel Tisnovsky", email = "tisnik@nikdo.nikde.com"},
]
dependencies = []
requires-python = "==3.12.*"
readme = "README.md"
license = {text = "MIT"}
&nbsp;
&nbsp;
[tool.pdm]
distribution = false
</pre>



<p><a name="k06"></a></p>
<h2 id="k06">6. Instalace balÃ­ÄkÅ¯ <strong>faiss-cpu</strong> a <strong>numpy</strong> do virtuÃ¡lnÃ­ho prostÅ™edÃ­</h2>

<p>Ve druhÃ©m kroku do virtuÃ¡lnÃ­ho prostÅ™edÃ­ vytvoÅ™enÃ©ho pro novÃ½ projekt
pÅ™idÃ¡me dva balÃ­Äky &ndash; <strong>faiss-cpu</strong> a
<strong>numpy</strong>.  DruhÃ½ z&nbsp;balÃ­ÄkÅ¯ byl pÅ™idÃ¡n z&nbsp;toho dÅ¯vodu,
abychom mohli tvoÅ™it vektory, s&nbsp;nimiÅ¾ bude <strong>faiss</strong>
pracovat:</p>

<pre>
$ <strong>pdm add faiss-cpu numpy</strong>
&nbsp;
Adding packages to default dependencies: faiss-cpu, numpy
  0:00:03 ğŸ”’ Lock successful.
Changes are written to pyproject.toml.
Synchronizing working set with resolved packages: 3 to add, 0 to update, 0 to remove
&nbsp;
  âœ” Install packaging 25.0 successful
  âœ” Install numpy 2.3.1 successful
  âœ” Install faiss-cpu 1.11.0 successful
&nbsp;
  0:00:05 ğŸ‰ All complete! 3/3
</pre>

<p>ProjektovÃ½ soubor nynÃ­ vypadÃ¡ nÃ¡sledovnÄ›:</p>

<pre>
[project]
name = "faiss-demo"
version = "0.1.0"
description = "Default template for PDM package"
authors = [
    {name = "Pavel Tisnovsky", email = "ptisnovs@redhat.com"},
]
dependencies = ["faiss-cpu&gt;=1.11.0", "numpy&gt;=2.3.1"]
requires-python = "==3.12.*"
readme = "README.md"
license = {text = "MIT"}
&nbsp;
&nbsp;
[tool.pdm]
distribution = false
</pre>

<p>OvÄ›Å™Ã­me si, zda je modul <strong>faiss</strong> skuteÄnÄ› dostupnÃ½:</p>

<pre>
$ <strong>pdm run </strong>
&nbsp;
WARNING: No command is given, default to the Python REPL.
Python 3.12.10 (main, Apr 22 2025, 00:00:00) [GCC 14.2.1 20240912 (Red Hat 14.2.1-3)] on linux
Type "help", "copyright", "credits" or "license" for more information.
&nbsp;
&gt;&gt;&gt; <strong>import faiss</strong>
&gt;&gt;&gt; <strong>help(faiss)</strong>
</pre>

<p>MÄ›la by se zobrazit nÃ¡povÄ›da:</p>

<pre>
Help on package faiss:
&nbsp;
NAME
    faiss
&nbsp;
DESCRIPTION
    # Copyright (c) Facebook, Inc. and its affiliates.
    #
    # This source code is licensed under the MIT license found in the
    # LICENSE file in the root directory of this source tree.
&nbsp;
PACKAGE CONTENTS
    _swigfaiss
    _swigfaiss_avx2
    _swigfaiss_avx512
    array_conversions
    class_wrappers
    contrib (package)
    extra_wrappers
    gpu_wrappers
    loader
    setup
    swigfaiss
    swigfaiss_avx2
    swigfaiss_avx512
&nbsp;
CLASSES
</pre>



<p><a name="k07"></a></p>
<h2 id="k07">7. Definice souÅ™adnic bodÅ¯ v&nbsp;rovinÄ›</h2>

<p>SouÅ™adnice bodÅ¯ umÃ­stÄ›nÃ½ch v&nbsp;rovinÄ› (viz <a href="#k04">Ätvrtou
kapitolu</a> s&nbsp;jejich vizualizacÃ­) je moÅ¾nÃ© uloÅ¾it do bÄ›Å¾nÃ½ch
PythonovskÃ½ch seznamÅ¯ nebo do n-tic. BodÅ¯ je celkem patnÃ¡ct a souÅ™adnice
v&nbsp;rovinÄ› majÃ­ jen dvÄ› dimenze, takÅ¾e reprezentace souÅ™adnice je
v&nbsp;tomto pÅ™Ã­padÄ› snadnÃ¡:</p>

<pre>
<i># x-ove souradnice bodu v rovine</i>
x = [-5, -4, -3,    3,  4,  5,    3, 3, 3, 4, 4, 4, 5, 5, 5]
&nbsp;
<i># y-ove souradnice bodu v rovine</i>
y = [ 5,  3,  5,   -5, -3, -5,    3, 4, 5, 3, 4, 5, 3, 4, 5]
</pre>

<p><div class="rs-tip-major">PoznÃ¡mka: vizuÃ¡lnÄ› (mezerami) jsou oddÄ›leny
jednotlivÃ© kvadranty, do nichÅ¾ jsou body umÃ­stÄ›ny.</div></p>

<p>Z&nbsp;tÄ›chto dvou oddÄ›lenÃ½ch seznamÅ¯ je moÅ¾nÃ© vytvoÅ™it seznam souÅ™adnic
(dvojic) velmi snadno:</p>

<pre>
<i># x-ove souradnice bodu v rovine</i>
x = [-5, -4, -3,    3,  4,  5,   3, 3, 3,  4, 4, 4,  5, 5, 5]
&nbsp;
<i># y-ove souradnice bodu v rovine</i>
y = [ 5,  3,  5,   -5, -3, -5,   3, 4, 5,  3, 4, 5,  3, 4, 5]
&nbsp;
print(x)
print(y)
&nbsp;
<i># seznam souradnic</i>
print(list(zip(x, y)))
</pre>

<p>VÃ½sledky:</p>

<pre>
[-5, -4, -3, 3, 4, 5, 3, 3, 3, 4, 4, 4, 5, 5, 5]
[5, 3, 5, -5, -3, -5, 3, 4, 5, 3, 4, 5, 3, 4, 5]
&nbsp;
[(-5, 5), (-4, 3), (-3, 5), (3, -5), (4, -3), (5, -5), (3, 3), (3, 4), (3, 5), (4, 3), (4, 4), (4, 5), (5, 3), (5, 4), (5, 5)]
</pre>



<p><a name="k08"></a></p>
<h2 id="k08">8. Konstrukce matice se souÅ™adnicemi bodÅ¯</h2>

<p>Knihovna <i>FAISS</i> ovÅ¡em na svÃ©m vstupu neoÄekÃ¡vÃ¡ standardnÃ­ PythonovskÃ©
seznamy, ale (typicky) matice ve formÃ¡tu podporovanÃ©m knihovnou <i>Numpy</i>
(internÄ› se jednÃ¡ o obecnou strukturu reprezentujÃ­cÃ­ n-rozmÄ›rnÃ¡ pole).
V&nbsp;takovÃ©m pÅ™Ã­padÄ› je matice homogennÃ­, tj.&nbsp;vÅ¡echny jejÃ­ prvky jsou
stejnÃ©ho typu. NavÃ­c musÃ­me zaruÄit, Å¾e tento typ bude buÄ <i>float32</i> nebo
<i>float16</i> popÅ™.&nbsp;<i>bfloat16</i>. UkaÅ¾me si tedy, jakÃ½m zpÅ¯sobem lze
vytvoÅ™it dvourozmÄ›rnÃ© pole souÅ™adnic, ve kterÃ©m budou vÅ¡echny prvky typu
<i>float32</i>:</p>

<pre>
import numpy as np
&nbsp;
<i># x-ove souradnice bodu v rovine</i>
x = [-5, -4, -3,    3,  4,  5,   3, 3, 3,  4, 4, 4,  5, 5, 5]
&nbsp;
<i># y-ove souradnice bodu v rovine</i>
y = [ 5,  3,  5,   -5, -3, -5,   3, 4, 5,  3, 4, 5,  3, 4, 5]
&nbsp;
<i># konstrukce 2D matice, v niz kazdy radek obsahuje souradnice jednoho bodu v</i>
<i># rovine</i>
points = np.column_stack((x,y)).astype("float32")
print(points)
</pre>

<p>VÃ½sledek nynÃ­ bude vypadat nÃ¡sledovnÄ›:</p>

<pre>
[[-5.  5.]
 [-4.  3.]
 [-3.  5.]
 [ 3. -5.]
 [ 4. -3.]
 [ 5. -5.]
 [ 3.  3.]
 [ 3.  4.]
 [ 3.  5.]
 [ 4.  3.]
 [ 4.  4.]
 [ 4.  5.]
 [ 5.  3.]
 [ 5.  4.]
 [ 5.  5.]]
</pre>

<p><div class="rs-tip-major">PoznÃ¡mka: tuto matici je jiÅ¾ moÅ¾nÃ© pouÅ¾Ã­t jako
pÅ™Ã­mÃ¡ vstupnÃ­ data pro knihovnu <i>FAISS</i>.</div></p>



<p><a name="k09"></a></p>
<h2 id="k09">9. Konstrukce indexu pro vyhledÃ¡vÃ¡nÃ­ na zÃ¡kladÄ› vzdÃ¡lenosti</h2>

<p>NynÃ­ jiÅ¾ mÃ¡me k&nbsp;dispozici vstupnÃ­ vektory (v&nbsp;naÅ¡em pÅ™Ã­padÄ› sadu
patnÃ¡cti dvouprvkovÃ½ch vektorÅ¯) pÅ™ipraveny ve formÃ¡tu, kterÃ½ je kompatibilnÃ­
s&nbsp;knihovnou <i>FAISS</i>. Tyto vektory nynÃ­ vyuÅ¾ijeme pro konstrukci
takzvanÃ©ho <i>indexu</i>. To je datovÃ¡ struktura umoÅ¾ÅˆujÃ­cÃ­ rychlÃ© vyhledÃ¡vÃ¡nÃ­
nejbliÅ¾Å¡Ã­ch vektorÅ¯ na zÃ¡kladÄ› zvolenÃ© metriky urÄujÃ­cÃ­ vzdÃ¡lenosti (pojem
vzdÃ¡lenosti je zde ovÅ¡em zobecnÄ›n a nemusÃ­ znamenat pouze Eukleidovskou
vzdÃ¡lenost).</p>

<p>V&nbsp;dalÅ¡Ã­m demonstraÄnÃ­m pÅ™Ã­kladu se zkonstruuje index typu
<strong>L2</strong>, coÅ¾ znaÄÃ­ Eukleidovskou vzdÃ¡lenost L<sup>2</sup>:</p>

<pre>
import faiss
import numpy as np
&nbsp;
<i># x-ove souradnice bodu v rovine</i>
x = [-5, -4, -3,    3,  4,  5,   3, 3, 3,  4, 4, 4,  5, 5, 5]
&nbsp;
<i># y-ove souradnice bodu v rovine</i>
y = [ 5,  3,  5,   -5, -3, -5,   3, 4, 5,  3, 4, 5,  3, 4, 5]
&nbsp;
<i># konstrukce 2D matice, v niz kazdy radek obsahuje souradnice jednoho bodu v</i>
<i># rovine</i>
points = np.column_stack((x,y)).astype("float32")
print(points)
&nbsp;
<i># konstrukce indexu pro vyhledavani na zaklade vzdalenosti</i>
index = faiss.IndexFlatL2(2)
index.add(points)
&nbsp;
print()
print("Dimension(s):         ", index.d)
print("Total values in index:", index.ntotal)
print("Is index trained:     ", index.is_trained)
</pre>

<p>Po konstrukci indexu si nechÃ¡me vypsat jeho zÃ¡kladnÃ­ charakteristiky &ndash;
poÄet dimenzÃ­, poÄet zÃ¡znamÅ¯ v&nbsp;indexu a taktÃ©Å¾ pÅ™Ã­znak, zda je index
natrÃ©novÃ¡n (viz navazujÃ­cÃ­ ÄlÃ¡nek):</p>

<pre>
[[-5.  5.]
 [-4.  3.]
 [-3.  5.]
 [ 3. -5.]
 [ 4. -3.]
 [ 5. -5.]
 [ 3.  3.]
 [ 3.  4.]
 [ 3.  5.]
 [ 4.  3.]
 [ 4.  4.]
 [ 4.  5.]
 [ 5.  3.]
 [ 5.  4.]
 [ 5.  5.]]
&nbsp;
Dimension(s):          2
Total values in index: 15
Is index trained:      True
</pre>



<p><a name="k10"></a></p>
<h2 id="k10">10. NalezenÃ­ nejbliÅ¾Å¡Ã­ch bodÅ¯ k&nbsp;zadanÃ½m souÅ™adnicÃ­m</h2>

<p>NynÃ­ se koneÄnÄ› dostÃ¡vÃ¡me k&nbsp;ÃºstÅ™ednÃ­mu tÃ©matu dneÅ¡nÃ­ho ÄlÃ¡nku, tedy
k&nbsp;realizaci skriptu, kterÃ½ mÃ¡ nalÃ©zt nejbliÅ¾Å¡Ã­ch <i>k</i> bodÅ¯ (nebo,
chcete-li, vektorÅ¯) k&nbsp;zadanÃ½m souÅ™adnicÃ­m v&nbsp;rovinÄ›. ZaÄnÄ›me tÄ›mito
souÅ™adnicemi. I ty je nutnÃ© realizovat formou matice, v&nbsp;naÅ¡em pÅ™Ã­padÄ›
matice s&nbsp;jedinÃ½m Å™Ã¡dkem se souÅ™adnicemi [3, 3]. A opÄ›t platÃ­, Å¾e typ prvkÅ¯
tÃ©to matice musÃ­ bÃ½t buÄ <i>float32</i> nebo <i>float16</i>
popÅ™.&nbsp;<i>bfloat16</i>. PouÅ¾ijeme typ <i>float32</i>, tedy stejnÃ½ typ, jakÃ½
majÃ­ prvky vstupnÃ­ matice vektorÅ¯:</p>

<pre>
query_vector = np.array([[3, 3]]).astype("float32")
print(query_vector)
</pre>

<p>NÃ¡slednÄ› si nechÃ¡me vyhledat <i>k</i> nejbliÅ¾Å¡Ã­ch bodÅ¯ (vektorÅ¯)
k&nbsp;tÄ›mto souÅ™adnicÃ­m. V&nbsp;praxi mÅ¯Å¾e <i>k</i> nabÃ½vat hodnoty od 1
(nejbliÅ¾Å¡Ã­ bod) aÅ¾ po poÄet vstupnÃ­ch vektorÅ¯:</p>

<pre>
k = len(x)
distances, indices = index.search(query_vector, k)
</pre>

<p>Body/vektory budou v&nbsp;tomto pÅ™Ã­padÄ› vrÃ¡ceny v&nbsp;poÅ™adÃ­ od nejbliÅ¾Å¡Ã­ho
k&nbsp;nejvzdÃ¡lenÄ›jÅ¡Ã­mu (viz prvnÃ­ hodnoty <strong>distances</strong>):</p>

<pre>
<i># tisk vysledku</i>
print("Nearest neighbors:")
print("neighbour  distance  index")
print("--------------------------")
for i in range(k):
    print(f"{i+1:3}      {distances[0][i]:5}       {indices[0][i]:2}")
</pre>

<p>VÃ½sledky budou vypadat nÃ¡sledovnÄ›:</p>

<pre>
Nearest neighbors:
neighbour  distance  index
--------------------------
  1        0.0        6
  2        1.0        7
  3        1.0        9
  4        2.0       10
  5        4.0        8
  6        4.0       12
  7        5.0       11
  8        5.0       13
  9        8.0       14
 10       37.0        4
 11       40.0        2
 12       49.0        1
 13       64.0        3
 14       68.0        0
 15       68.0        5
</pre>

<p>A takto vypadÃ¡ celÃ½ skript, kterÃ½ vÃ½Å¡e popsanÃ½ vÃ½poÄet provÃ¡dÃ­:</p>

<pre>
import faiss
import numpy as np
&nbsp;
<i># x-ove souradnice bodu v rovine</i>
x = [-5, -4, -3,    3,  4,  5,   3, 3, 3,  4, 4, 4,  5, 5, 5]
&nbsp;
<i># y-ove souradnice bodu v rovine</i>
y = [ 5,  3,  5,   -5, -3, -5,   3, 4, 5,  3, 4, 5,  3, 4, 5]
&nbsp;
<i># konstrukce 2D matice, v niz kazdy radek obsahuje souradnice jednoho bodu v</i>
<i># rovine</i>
points = np.column_stack((x,y)).astype("float32")
print(points)
&nbsp;
<i># konstrukce indexu pro vyhledavani na zaklade vzdalenosti</i>
index = faiss.IndexFlatL2(2)
index.add(points)
&nbsp;
print()
print("Dimension(s):         ", index.d)
print("Total values in index:", index.ntotal)
print("Is index trained:     ", index.is_trained)
&nbsp;
<i># vektor, ke kteremu budeme pocitat vzdalenost</i>
query_vector = np.array([[3, 3]]).astype("float32")
print(query_vector)
&nbsp;
<i># pocet nejblizsich bodu</i>
k = len(x)
distances, indices = index.search(query_vector, k)
&nbsp;
<i># tisk vysledku</i>
print("Nearest neighbors:")
print("neighbour  distance  index")
print("--------------------------")
for i in range(k):
    print(f"{i+1:3}      {distances[0][i]:5}       {indices[0][i]:2}")
</pre>



<p><a name="k11"></a></p>
<h2 id="k11">11. VÃ½pis souÅ™adnic bodÅ¯ nejbliÅ¾Å¡Ã­ch k&nbsp;zadanÃ½m souÅ™adnicÃ­m</h2>

<p>V&nbsp;pÅ™edchozÃ­m skriptu se vypisovaly pouze indexy nejbliÅ¾Å¡Ã­ch
bodÅ¯/vektorÅ¯. OvÅ¡em my mÃ¡me k&nbsp;dispozici i pÅ¯vodnÃ­ souÅ™adnice tÄ›chto bodÅ¯,
takÅ¾e si mÅ¯Å¾eme vypsat pÅ™Ã­mo tyto souÅ™adnice:</p>

<pre>
Nearest neighbors:
neighbour  distance  coordinates  
----------------------------------
  1        0.0       [3. 3.]
  2        1.0       [3. 4.]
  3        1.0       [4. 3.]
  4        2.0       [4. 4.]
  5        4.0       [3. 5.]
  6        4.0       [5. 3.]
  7        5.0       [4. 5.]
  8        5.0       [5. 4.]
  9        8.0       [5. 5.]
 10       37.0       [ 4. -3.]
 11       40.0       [-3.  5.]
 12       49.0       [-4.  3.]
 13       64.0       [ 3. -5.]
 14       68.0       [-5.  5.]
 15       68.0       [ 5. -5.]
</pre>

<p><div class="rs-tip-major">PoznÃ¡mka: zajistÃ© jste si vÅ¡imli, Å¾e vzdÃ¡lenosti
jsou vypoÄteny Å¡patnÄ›. NapÅ™Ã­klad vzdÃ¡lenost bodÅ¯ [3, 3] a [4, 4] nemÃ¡ bÃ½t 2 ale
&radic;2. Je tomu tak schvÃ¡lnÄ› &ndash; aby se nemusela pomalu poÄÃ­tat odmocnina
ze dvou, jsou namÃ­sto vzdÃ¡lenostÃ­ vypoÄteny jejich Ätverce (tedy bez onÃ©
odmocniny). V&nbsp;praxi to vÄ›tÅ¡inou nevadÃ­, protoÅ¾e vzdÃ¡lenosti potÅ™ebujeme
pouze porovnÃ¡vat a odmocnina je monotonnÄ› rostoucÃ­ funkce.</div></p>

<p>CelÃ½ upravenÃ½ skript nynÃ­ vypadÃ¡ nÃ¡sledovnÄ›:</p>

<pre>
import faiss
import numpy as np
&nbsp;
<i># x-ove souradnice bodu v rovine</i>
x = [-5, -4, -3,    3,  4,  5,   3, 3, 3,  4, 4, 4,  5, 5, 5]
&nbsp;
<i># y-ove souradnice bodu v rovine</i>
y = [ 5,  3,  5,   -5, -3, -5,   3, 4, 5,  3, 4, 5,  3, 4, 5]
&nbsp;
<i># konstrukce 2D matice, v niz kazdy radek obsahuje souradnice jednoho bodu v</i>
<i># rovine</i>
points = np.column_stack((x,y)).astype("float32")
print(points)
&nbsp;
<i># konstrukce indexu pro vyhledavani na zaklade vzdalenosti</i>
index = faiss.IndexFlatL2(2)
index.add(points)
&nbsp;
print()
print("Dimension(s):         ", index.d)
print("Total values in index:", index.ntotal)
print("Is index trained:     ", index.is_trained)
&nbsp;
<i># vektor, ke kteremu budeme pocitat vzdalenost</i>
query_vector = np.array([[3, 3]]).astype("float32")
print(query_vector)
&nbsp;
<i># pocet nejblizsich bodu</i>
k = len(x)
distances, indices = index.search(query_vector, k)
&nbsp;
<i># tisk vysledku</i>
print("Nearest neighbors:")
print("neighbour  distance  coordinates  ")
print("----------------------------------")
for i in range(k):
    print(f"{i+1:3}      {distances[0][i]:5}       {points[indices[0][i]]}")
</pre>



<p><a name="k12"></a></p>
<h2 id="k12">12. Vizualizace nejbliÅ¾Å¡Ã­ch nalezenÃ½ch bodÅ¯</h2>

<p>Upravme si nynÃ­ pÅ™edchozÃ­ skript do takovÃ© podoby, aby vracel jen tÅ™i body
nejbliÅ¾Å¡Ã­ k&nbsp;souÅ™adnicÃ­m [-4, 4]. Ãšprava je v&nbsp;tomto pÅ™Ã­padÄ› snadnÃ¡.
ModifikovanÃ¡ mÃ­sta jsou podtrÅ¾ena:</p>

<pre>
<i># vektor, ke kteremu budeme pocitat vzdalenost</i>
query_vector = np.array(<u>[[-4, 4]]</u>).astype("float32")
print(query_vector)
&nbsp;
<i># pocet nejblizsich bodu</i>
<u>k = 3</u>
distances, indices = index.search(query_vector, k)
</pre>

<p>VÃ½sledkem vÃ½Å¡e uvedenÃ©ho dotazu je trojice vektorÅ¯, kterÃ© jsou nejpodobnÄ›jÅ¡Ã­
vektoru [-4, 4]:</p>

<pre>
[[-4.  4.]]
&nbsp;
Nearest neighbors:
neighbour  distance  coordinates  
----------------------------------
  1        1.0       [-4.  3.]
  2        2.0       [-5.  5.]
  3        2.0       [-3.  5.]
</pre>

<p>CoÅ¾ si pochopitelnÄ› mÅ¯Å¾eme vizualizovat v&nbsp;rovinÄ›. HvÄ›zdiÄkou je
naznaÄen bod/vektor z&nbsp;podmÃ­nky (pro kterÃ½ hledÃ¡me nejbliÅ¾Å¡Ã­ sousedy),
koleÄkem vektory vrÃ¡cenÃ© jako vÃ½sledek dotazu a teÄkou ostatnÃ­ vektory, kterÃ©
neodpovÃ­dajÃ­ dotazu (nejsou vrÃ¡ceny):</p>

<pre>
                                       â”‚ y
                                       â”‚
                                       â”‚
                                       â”‚
                                       â”‚
                     o       o         â”‚          .   .   .
                         *             â”‚          .   .   .
                         o             â”‚          .   .   .
                                       â”‚
                                       â”‚
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€[0,0]â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
                                       â”‚                                       x
                                       â”‚
                                       â”‚              .
                                       â”‚
                                       â”‚          .       .
                                       â”‚
                                       â”‚
                                       â”‚
                                       â”‚
</pre>



<p><a name="k13"></a></p>
<h2 id="k13">13. VÃ½bÄ›ry vektorÅ¯ na zÃ¡kladÄ› jejich podobnosti: volba metriky</h2>

<p>ProzatÃ­m jsme pro vÃ½poÄty podobnosti (resp.&nbsp;vzdÃ¡lenosti) vektorÅ¯
pouÅ¾Ã­vali klasickou Eukleidovskou metriku, tedy skuteÄnou vzdÃ¡lenost bodÅ¯
v&nbsp;prostoru (v&nbsp;tomto pÅ™Ã­padÄ› vzdÃ¡lenost koncovÃ½ch bodÅ¯ vektorÅ¯
v&nbsp;2D rovinÄ›). Tato metrika se taktÃ©Å¾ oznaÄuje L2 nebo pÅ™esnÄ›ji
L<sup>2</sup>, ovÅ¡em knihovna <i>FAISS</i> podporuje i odliÅ¡nou metriku
zaloÅ¾enou na vÃ½poÄtu skalÃ¡rnÃ­ho souÄinu (<i>dot product</i>). VychÃ¡zÃ­ se pÅ™itom
z&nbsp;faktu, Å¾e pokud majÃ­ dva vektory jednotkovou dÃ©lku, bude jejich skalÃ¡rnÃ­
souÄin nejvÄ›tÅ¡Ã­ v&nbsp;pÅ™Ã­padÄ›, Å¾e jsou vektory totoÅ¾nÃ©, nulovÃ½ ve chvÃ­li, kdy
jsou vektory na sebe kolmÃ© a zÃ¡pornÃ½ tehdy, pokud je jeden vektor oproti
druhÃ©mu otoÄen o 180&deg;. JednÃ¡ se o velmi Äasto pouÅ¾Ã­vanou metriku pro
hledÃ¡nÃ­ podobnÃ½ch vektorÅ¯, ovÅ¡em v&nbsp;praxi nesmÃ­me zapomenout na jejÃ­
zÃ¡kladnÃ­ vlastnosti:</p>

<ol>
<li>VÅ¡echny vektory musÃ­ bÃ½t normalizovÃ¡ny na jednotkovou dÃ©lku (kromÄ› nulovÃ©ho vektoru)</li>
<li>JednÃ¡ se o metriku, nikoli o vzdÃ¡lenost. Naopak &ndash; ÄÃ­m podobnÄ›jÅ¡Ã­ jsou vektory, tÃ­m vÄ›tÅ¡Ã­ bude vÃ½sledek (opak vzdÃ¡lenosti).</li>
<li>Pozor je nutnÃ© dÃ¡t na nulovÃ© vektory, kterÃ© nenÃ­ moÅ¾nÃ© normalizovat (speciÃ¡lnÃ­ pÅ™Ã­pad)</li>
</ol>



<p><a name="k14"></a></p>
<h2 id="k14">14. VÃ½bÄ›r podobnÃ½ch vektorÅ¯ pomocÃ­ skalÃ¡rnÃ­ho souÄinu: nekorektnÃ­ verze</h2>

<p>VyzkouÅ¡ejme si nynÃ­ nahradit hledÃ¡nÃ­ podobnÃ½ch vektorÅ¯ na zÃ¡kladÄ›
vzdÃ¡lenosti za hledÃ¡nÃ­ s&nbsp;vyuÅ¾itÃ­m skalÃ¡rnÃ­ho souÄinu. Ve skriptu prozatÃ­m
provedeme jedinou zmÄ›nu, a to konkrÃ©tnÄ› zÃ¡mÄ›nu funkce pro konstrukci indexÅ¯.
NamÃ­sto:</p>

<pre>
index = faiss.IndexFlatL2(2)
</pre>

<p>zavolÃ¡me:</p>

<pre>
index = faiss.IndexFlatIP(2)
</pre>

<p>VÃ½sledky budou vypadat takto:</p>

<pre>
Nearest neighbors:
neighbour  distance  coordinates  
----------------------------------
  1       30.0       [5. 5.]
  2       27.0       [5. 4.]
  3       27.0       [4. 5.]
  4       24.0       [5. 3.]
  5       24.0       [4. 4.]
  6       24.0       [3. 5.]
  7       21.0       [4. 3.]
  8       21.0       [3. 4.]
  9       18.0       [3. 3.]
 10        6.0       [-3.  5.]
 11        3.0       [ 4. -3.]
 12        0.0       [ 5. -5.]
 13        0.0       [-5.  5.]
 14       -3.0       [-4.  3.]
 15       -6.0       [ 3. -5.]
</pre>

<p>NapÅ™Ã­klad prvnÃ­ vÃ½poÄet vypadÃ¡ nÃ¡sledovnÄ›: 3&times;5+3&times;5=15+15=30. A
poslednÃ­ vÃ½poÄet 3&times;3+3&times;(-5)=9-15=-6. Tedy ÄÃ­m podobnÄ›jÅ¡Ã­ jsou
vektory, tÃ­m <i>vÄ›tÅ¡Ã­</i> bude hodnota, zatÃ­mco u L2 metriky tomu bylo
naopak!</p>

<p>CelÃ½ skript byl upraven do tÃ©to podoby:</p>

<pre>
import faiss
import numpy as np
&nbsp;
<i># x-ove souradnice bodu v rovine</i>
x = [-5, -4, -3,    3,  4,  5,   3, 3, 3,  4, 4, 4,  5, 5, 5]
&nbsp;
<i># y-ove souradnice bodu v rovine</i>
y = [ 5,  3,  5,   -5, -3, -5,   3, 4, 5,  3, 4, 5,  3, 4, 5]
&nbsp;
<i># konstrukce 2D matice, v niz kazdy radek obsahuje souradnice jednoho bodu v</i>
<i># rovine</i>
points = np.column_stack((x,y)).astype("float32")
print(points)
&nbsp;
<i># konstrukce indexu pro vyhledavani na zaklade skalarniho soucinu</i>
index = <strong>faiss.IndexFlatIP(2)</strong>
index.add(points)
&nbsp;
print()
print("Dimension(s):         ", index.d)
print("Total values in index:", index.ntotal)
print("Is index trained:     ", index.is_trained)
&nbsp;
<i># vektor, ke kteremu budeme pocitat vzdalenost</i>
query_vector = np.array([[3, 3]]).astype("float32")
print(query_vector)
&nbsp;
<i># pocet nejblizsich bodu</i>
k = len(x)
distances, indices = index.search(query_vector, k)
&nbsp;
<i># tisk vysledku</i>
print("Nearest neighbors:")
print("neighbour  distance  coordinates  ")
print("----------------------------------")
for i in range(k):
    print(f"{i+1:3}      {distances[0][i]:5}       {points[indices[0][i]]}")
</pre>



<p><a name="k15"></a></p>
<h2 id="k15">15. Normalizace vektorÅ¯ v&nbsp;indexu</h2>

<p>VÃ½poÄet metriky zaloÅ¾enÃ© na skalÃ¡rnÃ­m souÄinu pÅ™edpoklÃ¡dÃ¡, Å¾e vektory jsou
jiÅ¾ dopÅ™edu normalizovÃ¡ny, tj.&nbsp;Å¾e jejich dÃ©lka je buÄ rovna jednÃ© nebo
nule. V&nbsp;praxi je tedy nutnÃ© jiÅ¾ pÅ™i konstrukci indexÅ¯ pouÅ¾Ã­t normalizovanÃ©
vektory. To se provede relativnÄ› snadno (a zejmÃ©na &ndash; pouze jedenkrÃ¡t pÅ™i
inicializaci):</p>

<pre>
<i># normalizace</i>
for i in range(len(points)):
   vector = points[i]
   normalized = np.linalg.norm(vector)
   vector /= normalized
   points[i] = vector
</pre>

<p>Index se zkonstruuje s&nbsp;vyuÅ¾itÃ­m normalizovanÃ½ch vektorÅ¯:</p>

<pre>
<i># konstrukce indexu pro vyhledavani na zaklade vzdalenosti</i>
index = faiss.IndexFlatIP(2)
index.add(points)
</pre>

<p>I vektor, pro kterÃ½ hledÃ¡me nejshodnÄ›jÅ¡Ã­ &bdquo;sousedy&ldquo; je nutnÃ©
normalizovat a teprve potÃ© provÃ©st vyhledÃ¡vÃ¡nÃ­:</p>

<pre>
<i># vektor, ke kteremu budeme pocitat vzdalenost</i>
query_vector = np.array([[3, 3]]).astype("float32")
normalized = np.linalg.norm(query_vector)
query_vector /= normalized
print(query_vector)
&nbsp;
<i># pocet nejblizsich bodu</i>
k = len(x)
distances, indices = index.search(query_vector, k)
</pre>

<p>VÃ½sledky vyhledÃ¡vÃ¡nÃ­ budou (podle oÄekÃ¡vÃ¡nÃ­) odliÅ¡nÃ©:</p>

<pre>
Nearest neighbors:
neighbour  distance  coordinates  
----------------------------------
  1      +1.0000     [0.7071068 0.7071068]
  2      +1.0000     [0.70710677 0.70710677]
  3      +1.0000     [0.70710677 0.70710677]
  4      +0.9939     [0.78086877 0.62469506]
  5      +0.9939     [0.62469506 0.78086877]
  6      +0.9899     [0.8 0.6]
  7      +0.9899     [0.6 0.8]
  8      +0.9701     [0.857493  0.5144958]
  9      +0.9701     [0.5144958 0.857493 ]
 10      +0.2425     [-0.5144958  0.857493 ]
 11      +0.1414     [ 0.8 -0.6]
 12      +0.0000     [-0.70710677  0.70710677]
 13      -0.0000     [ 0.70710677 -0.70710677]
 14      -0.1414     [-0.8  0.6]
 15      -0.2425     [ 0.5144958 -0.857493 ]
</pre>

<p><div class="rs-tip-major">PoznÃ¡mka: povÅ¡imnÄ›te si, Å¾e nynÃ­ dostÃ¡vÃ¡me hodnoty
v&nbsp;rozsahu -1..1.</div></p>

<p>OpÄ›t si ukaÅ¾me ÃºplnÃ½ zdrojovÃ½ kÃ³d takto upravenÃ©ho skriptu:</p>

<pre>
import faiss
import numpy as np
&nbsp;
<i># x-ove souradnice bodu v rovine</i>
x = [-5, -4, -3,    3,  4,  5,   3, 3, 3,  4, 4, 4,  5, 5, 5]
&nbsp;
<i># y-ove souradnice bodu v rovine</i>
y = [ 5,  3,  5,   -5, -3, -5,   3, 4, 5,  3, 4, 5,  3, 4, 5]
&nbsp;
<i># konstrukce 2D matice, v niz kazdy radek obsahuje souradnice jednoho bodu v</i>
<i># rovine</i>
points = np.column_stack((x,y)).astype("float32")
print(points)
&nbsp;
<i># normalizace</i>
for i in range(len(points)):
   vector = points[i]
   normalized = np.linalg.norm(vector)
   vector /= normalized
   points[i] = vector
&nbsp;
print()
print("Normalized:")
print(points)
&nbsp;
<i># konstrukce indexu pro vyhledavani na zaklade vzdalenosti</i>
index = faiss.IndexFlatIP(2)
index.add(points)
&nbsp;
print()
print("Dimension(s):         ", index.d)
print("Total values in index:", index.ntotal)
print("Is index trained:     ", index.is_trained)
&nbsp;
<i># vektor, ke kteremu budeme pocitat vzdalenost</i>
query_vector = np.array([[3, 3]]).astype("float32")
normalized = np.linalg.norm(query_vector)
query_vector /= normalized
print(query_vector)
&nbsp;
<i># pocet nejblizsich bodu</i>
k = len(x)
distances, indices = index.search(query_vector, k)
&nbsp;
<i># tisk vysledku</i>
print("Nearest neighbors:")
print("neighbour  distance  coordinates  ")
print("----------------------------------")
for i in range(k):
    print(f"{i+1:3}      {distances[0][i]:+7.4f}     {points[indices[0][i]]}")
</pre>



<p><a name="k16"></a></p>
<h2 id="k16">16. Rychlost vyhledÃ¡nÃ­ nejbliÅ¾Å¡Ã­ch bodÅ¯</h2>

<p>PÅ™i vyhledÃ¡vÃ¡nÃ­ na zÃ¡kladÄ› podobnosti vektorÅ¯ v&nbsp;rozsÃ¡hlÃ½ch databÃ¡zÃ­ch
je dÅ¯leÅ¾itÃ©, aby byl algoritmus vyhledÃ¡vÃ¡nÃ­ dostateÄnÄ› rychlÃ½. V&nbsp;knihovnÄ›
<i>FAISS</i> je z&nbsp;tohoto dÅ¯vodu implementovÃ¡no hned nÄ›kolik algoritmÅ¯
pouÅ¾Ã­vanÃ½ch v&nbsp;rÅ¯znÃ½ch situacÃ­ch. Dnes se budeme primÃ¡rnÄ› zabÃ½vat vÃ½chozÃ­m
algoritmem, u kterÃ©ho se pokusÃ­me odhadnout (a pÅ™Ã­Å¡tÄ› i popsat) jeho Äasovou
sloÅ¾itost. VytvoÅ™Ã­me proto benchmark, kterÃ½ bude pracovat s&nbsp;rÅ¯znÄ› velkÃ½mi
indexy a bude postupnÄ› mÄ›Å™it dobu vyhledÃ¡vÃ¡nÃ­ (a pro zajÃ­mavost i dalÅ¡Ã­ Äasy
trvÃ¡nÃ­). CelÃ½ benchmark je prozatÃ­m pomÄ›rnÄ› naivnÃ­, ovÅ¡em pro prvotnÃ­ odhad
sloÅ¾itost mÅ¯Å¾e postaÄovat:</p>

<pre>
from time import time
import faiss
import numpy as np
&nbsp;
import matplotlib.pyplot as plt
&nbsp;
&nbsp;
def <strong>similarity_search</strong>(n, k):
    DIMENSIONS=128
&nbsp;
    t1 = time()
&nbsp;
    <i># nahodne vektory</i>
    data = np.random.rand(n, 128).astype('float32')
&nbsp;
    t2 = time()
&nbsp;
    <i># konstrukce indexu pro vyhledavani na zaklade vzdalenosti</i>
    index = faiss.IndexFlatL2(DIMENSIONS)
    index.add(data)
&nbsp;
    t3 = time()
&nbsp;
    <i># vektor, ke kteremu budeme pocitat vzdalenost</i>
    query_vector = np.random.rand(1, DIMENSIONS).astype("float32")
&nbsp;
    <i># pocet nejblizsich bodu</i>
    distances, indices = index.search(query_vector, k)
    t4 = time()
    assert len(distances) == k
    assert len(indices) == k
&nbsp;
    return n, t2-t1, t3-t2, t4-t3
&nbsp;
&nbsp;
ns = []
ts_rand = []
ts_index = []
ts_search = []
&nbsp;
for n in np.linspace(1000000, 10000000, 10):
    print(n)
    n, t_rand, t_index, t_search = similarity_search(int(n), 1)
    ns.append(n)
    ts_rand.append(t_rand)
    ts_index.append(t_index)
    ts_search.append(t_search)
&nbsp;
&nbsp;
plt.plot(ns, ts_rand, "r-", label="numpy.random.rand")
plt.plot(ns, ts_index, "b-", label="index creation")
plt.plot(ns, ts_search, "m-", label="similarity search")
&nbsp;
<i># pÅ™idÃ¡nÃ­ legendy</i>
plt.legend(loc="upper left")
&nbsp;
<i># povolenÃ­ zobrazenÃ­ mÅ™Ã­Å¾ky</i>
plt.grid(True)
&nbsp;
plt.savefig("faiss_benchmark_2.png")
&nbsp;
<i># zobrazenÃ­ grafu</i>
plt.show()
</pre>



<p><a name="k17"></a></p>
<h2 id="k17">17. VÃ½sledky benchmarku</h2>

<p>NumerickÃ© vÃ½sledky benchmarku vypadajÃ­ nÃ¡sledovnÄ›:</p>

<pre>
   n      Konstrukce matice   Konstrukce indexu    VlastnÃ­ vyhledÃ¡vÃ¡nÃ­
---------------------------------------------------------------------
 1000000  1.313993215560913   0.3532786369323731   0.03192019462585449
 2000000  2.543938875198364   0.7037720680236816   0.06934928894042969
 3000000  3.741727113723755   1.0349786281585693   0.09357905387878418
 4000000  4.819754600524902   1.3467643260955810   0.11976456642150879
 5000000  6.031541824340820   1.6814656257629395   0.14942240715026855
 6000000  7.295117855072022   2.1264710426330566   0.17904376983642578
 7000000  8.616289138793945   2.3469836711883545   0.23292398452758790
 8000000 11.428938865661621   2.7663018703460693   0.24178504943847656
 9000000 21.055070638656616   3.2713224887847900   0.27842283248901367
10000000 27.235011577606200   3.4759612083435060   0.29420256614685060
</pre>

<p>LepÅ¡Ã­ vÅ¡ak bude si vÃ½sledky prohlÃ©dnou v&nbsp;grafickÃ© podobnÄ›. Nejprve
vÅ¡echny Äasy:</p>

*** image ***

<p>OvÅ¡em nejvÃ­ce nÃ¡s zajÃ­majÃ­ Äasy vyhledÃ¡vÃ¡nÃ­, takÅ¾e si zobrazme pouze tyto
namÄ›Å™enÃ© vÃ½sledky:</p>

*** image ***

<p><div class="rs-tip-major">PoznÃ¡mka: vÃ½sledky lze chÃ¡pat jak
v&nbsp;pozitivnÃ­m, tak i v&nbsp;negativnÃ­m smyslu. PozitivnÃ­ je, Å¾e na zÃ¡kladÄ›
vÃ½sledkÅ¯ lze prohlÃ¡sit, Å¾e vyhledÃ¡vÃ¡nÃ­ mÃ¡ lineÃ¡rnÃ­ sloÅ¾itost O(n), nikoli
napÅ™Ã­klad O(n<sup>2</sup>) nebo dokonce O(k<sup>n</sup>). OvÅ¡em to je souÄasnÄ›
i Å¡patnÃ½ vÃ½sledek, protoÅ¾e u velmi rozsÃ¡hlÃ½ch databÃ¡zÃ­ bychom potÅ™ebovali
sloÅ¾itost menÅ¡Ã­ (O(log) atd.). Toho je moÅ¾nÃ© ÄÃ¡steÄnÄ› dosÃ¡hnout prostÅ™edky
popsanÃ½mi pÅ™Ã­Å¡tÄ›.</div></p>



<p><a name="k18"></a></p>
<h2 id="k18">18. Obsah navazujÃ­cÃ­ho ÄlÃ¡nku</h2>

<p>Knihovna <i>FAISS</i> nenÃ­ vÃ½vojÃ¡Å™i oblÃ­bena ani tak kvÅ¯li tomu, <i>jakÃ©</i>
operace umÃ­ realizovat (ostatnÄ› jednoduchÃ½ <i>similarity search</i> lze
naprogramovat v&nbsp;Å™Ã¡du minut), ale <i>jak rychle</i> je dokÃ¡Å¾e provÃ¡dÄ›t.
K&nbsp;dispozici je totiÅ¾ hned nÄ›kolik algoritmÅ¯ vÃ½poÄtÅ¯, kterÃ© se vybÃ­rajÃ­ na
zÃ¡kladÄ› velikosti vstupnÃ­ mnoÅ¾iny vektorÅ¯, poÄtu dimenzÃ­ vektorÅ¯, taktÃ©Å¾ na
zÃ¡kladÄ› toho, jestli jsou vektory uloÅ¾eny v&nbsp;operaÄnÃ­ pamÄ›ti nebo pÅ™esahujÃ­
jejÃ­ rozsah atd. NavÃ­c je moÅ¾nÃ© vÃ½sledky (tedy nejbliÅ¾Å¡Ã­ vektory nalezenÃ© na
zÃ¡kladÄ› zadanÃ© metriky) v&nbsp;pÅ™Ã­padÄ› potÅ™eby pouze &bdquo;odhadovat&ldquo;,
tj.&nbsp;nemusÃ­ se nalÃ©zt skuteÄnÄ› ty nejbliÅ¾Å¡Ã­ vektory, ale vektory dostateÄnÄ›
blÃ­zkÃ©. To sice nemusÃ­ znÃ­t pÅ™Ã­liÅ¡ prakticky, ale ve skuteÄnosti se tyto
algoritmy v&nbsp;praxi pomÄ›rnÄ› Äasto pouÅ¾Ã­vajÃ­ zejmÃ©na pÅ™i realizacÃ­ch RAG
databÃ¡zÃ­. O tÄ›chto optimalizacÃ­ch si Å™ekneme podrobnÄ›jÅ¡Ã­ informace
v&nbsp;navazujÃ­cÃ­m ÄlÃ¡nku.</p>



<p><a name="k19"></a></p>
<h2 id="k19">19. RepositÃ¡Å™ s&nbsp;demonstraÄnÃ­mi pÅ™Ã­klady</h2>

<p>DemonstraÄnÃ­ pÅ™Ã­klady vytvoÅ™enÃ© v&nbsp;Pythonu a popsanÃ© v&nbsp;dneÅ¡nÃ­m
ÄlÃ¡nku najdete v&nbsp;repositÃ¡Å™i <a
href="https://github.com/tisnik/most-popular-python-libs/">https://github.com/tisnik/most-popular-python-libs/</a>.
NÃ¡sledujÃ­ odkazy na jednotlivÃ© pÅ™Ã­klady:</p>

<table>
<tr><th>#</th><th>PÅ™Ã­klad</th><th>StruÄnÃ½ popis</th><th>Adresa</th></tr>
<tr><td>1</td><td>faiss-1.py</td><td>seznamy souÅ™adnic bodÅ¯ v&nbsp;rovinÄ›</td><td><a href="https://github.com/tisnik/most-popular-python-libs/blob/master/faiss/faiss-1.py">https://github.com/tisnik/most-popular-python-libs/blob/master/faiss/faiss-1.py</a></td></tr>
<tr><td>2</td><td>faiss-2.py</td><td>konstrukce matice se souÅ™adnicemi bodÅ¯</td><td><a href="https://github.com/tisnik/most-popular-python-libs/blob/master/faiss/faiss-2.py">https://github.com/tisnik/most-popular-python-libs/blob/master/faiss/faiss-2.py</a></td></tr>
<tr><td>3</td><td>faiss-3.py</td><td>konstrukce indexu pro vyhledÃ¡vÃ¡nÃ­ na zÃ¡kladÄ› vzdÃ¡lenosti</td><td><a href="https://github.com/tisnik/most-popular-python-libs/blob/master/faiss/faiss-3.py">https://github.com/tisnik/most-popular-python-libs/blob/master/faiss/faiss-3.py</a></td></tr>
<tr><td>4</td><td>faiss-4.py</td><td>nalezenÃ­ nejbliÅ¾Å¡Ã­ch bodÅ¯ k&nbsp;zadanÃ½m souÅ™adnicÃ­m &ndash; vÃ½pis indexÅ¯ nalezenÃ½ch bodÅ¯</td><td><a href="https://github.com/tisnik/most-popular-python-libs/blob/master/faiss/faiss-4.py">https://github.com/tisnik/most-popular-python-libs/blob/master/faiss/faiss-4.py</a></td></tr>
<tr><td>5</td><td>faiss-5.py</td><td>nalezenÃ­ nejbliÅ¾Å¡Ã­ch bodÅ¯ k&nbsp;zadanÃ½m souÅ™adnicÃ­m &ndash; vÃ½pis souÅ™adnic nalezenÃ½ch bodÅ¯</td><td><a href="https://github.com/tisnik/most-popular-python-libs/blob/master/faiss/faiss-5.py">https://github.com/tisnik/most-popular-python-libs/blob/master/faiss/faiss-5.py</a></td></tr>
<tr><td>6</td><td>faiss-6.py</td><td>vyhledÃ¡vÃ¡nÃ­ bodÅ¯ na zÃ¡kladÄ› skalÃ¡rnÃ­ho souÄinu bez normalizace vektorÅ¯</td><td><a href="https://github.com/tisnik/most-popular-python-libs/blob/master/faiss/faiss-6.py">https://github.com/tisnik/most-popular-python-libs/blob/master/faiss/faiss-6.py</a></td></tr>
<tr><td>7</td><td>faiss-7.py</td><td>vyhledÃ¡vÃ¡nÃ­ bodÅ¯ na zÃ¡kladÄ› skalÃ¡rnÃ­ho souÄinu s&nbsp;normalizacÃ­ vektorÅ¯</td><td><a href="https://github.com/tisnik/most-popular-python-libs/blob/master/faiss/faiss-7.py">https://github.com/tisnik/most-popular-python-libs/blob/master/faiss/faiss-7.py</a></td></tr>
<tr><td>8</td><td>faiss-8.py</td><td>jednoduchÃ½ benchmark rychlosti vyhledÃ¡vÃ¡nÃ­ knihovnou FAISS</td><td><a href="https://github.com/tisnik/most-popular-python-libs/blob/master/faiss/faiss-8.py">https://github.com/tisnik/most-popular-python-libs/blob/master/faiss/faiss-8.py</a></td></tr>
<tr><td>9</td><td>pyproject.toml</td><td>soubor s&nbsp;projektem a definicÃ­ zÃ¡vislostÃ­</td><td><a href="https://github.com/tisnik/most-popular-python-libs/blob/master/faiss/pyproject.toml">https://github.com/tisnik/most-popular-python-libs/blob/master/faiss/pyproject.toml</a></td></tr>
</table>



<p><a name="k20"></a></p>
<h2 id="k20">20. Odkazy na Internetu</h2>

<ol>

<li>FAISS (Facebook AI Similarity Search)<br />
<a href="https://en.wikipedia.org/wiki/FAISS">https://en.wikipedia.org/wiki/FAISS</a>
</li>

<li>FAISS documentation<br />
<a href="https://faiss.ai/">https://faiss.ai/</a>
</li>

<li>Introduction to Facebook AI Similarity Search (Faiss)<br />
<a href="https://www.pinecone.io/learn/series/faiss/faiss-tutorial/">https://www.pinecone.io/learn/series/faiss/faiss-tutorial/</a>
</li>

<li>Faiss: Efficient Similarity Search and Clustering of Dense Vectors<br />
<a href="https://medium.com/@pankaj_pandey/faiss-efficient-similarity-search-and-clustering-of-dense-vectors-dace1df1e235">https://medium.com/@pankaj_pandey/faiss-efficient-similarity-search-and-clustering-of-dense-vectors-dace1df1e235</a>
</li>

<li>Top 8 Vector Databases in 2025: Features, Use Cases, and Comparisons<br />
<a href="https://synapsefabric.com/top-8-vector-databases-in-2025-features-use-cases-and-comparisons/">https://synapsefabric.com/top-8-vector-databases-in-2025-features-use-cases-and-comparisons/</a>
</li>

<li>Is FAISS a Vector Database? Complete Guide<br />
<a href="https://mljourney.com/is-faiss-a-vector-database-complete-guide/">https://mljourney.com/is-faiss-a-vector-database-complete-guide/</a>
</li>

<li>Vector database<br />
<a href="https://en.wikipedia.org/wiki/Vector_database">https://en.wikipedia.org/wiki/Vector_database</a>
</li>

<li>Similarity search<br />
<a href="https://en.wikipedia.org/wiki/Similarity_search">https://en.wikipedia.org/wiki/Similarity_search</a>
</li>

<li>Nearest neighbor search<br />
<a href="https://en.wikipedia.org/wiki/Nearest_neighbor_search#Approximation_methods">https://en.wikipedia.org/wiki/Nearest_neighbor_search#Approximation_methods</a>
</li>

<li>Decoding Similarity Search with FAISS: A Practical Approach<br />
<a href="https://www.luminis.eu/blog/decoding-similarity-search-with-faiss-a-practical-approach/">https://www.luminis.eu/blog/decoding-similarity-search-with-faiss-a-practical-approach/</a>
</li>

<li>MetricType and distances<br />
<a href="https://github.com/facebookresearch/faiss/wiki/MetricType-and-distances">https://github.com/facebookresearch/faiss/wiki/MetricType-and-distances</a>
</li>

<li>RAG - Retrieval-augmented generation<br />
<a href="https://en.wikipedia.org/wiki/Retrieval-augmented_generation">https://en.wikipedia.org/wiki/Retrieval-augmented_generation</a>
</li>

<li>pgvector na GitHubu<br />
<a href="https://github.com/pgvector/pgvector">https://github.com/pgvector/pgvector</a>
</li>

<li>Why we replaced Pinecone with PGVector<br />
<a href="https://www.confident-ai.com/blog/why-we-replaced-pinecone-with-pgvector">https://www.confident-ai.com/blog/why-we-replaced-pinecone-with-pgvector</a>
</li>

<li>PostgreSQL as VectorDB - Beginner Tutorial<br />
<a href="https://www.youtube.com/watch?v=Ff3tJ4pJEa4">https://www.youtube.com/watch?v=Ff3tJ4pJEa4</a>
</li>

<li>What is a Vector Database? (neobsahuje odpovÄ›Ä na otÃ¡zku v titulku :-)<br />
<a href="https://www.youtube.com/watch?v=t9IDoenf-lo">https://www.youtube.com/watch?v=t9IDoenf-lo</a>
</li>

<li>PGVector: Turn PostgreSQL Into A Vector Database<br />
<a href="https://www.youtube.com/watch?v=j1QcPSLj7u0">https://www.youtube.com/watch?v=j1QcPSLj7u0</a>
</li>

<li>Milvus<br />
<a href="https://milvus.io/">https://milvus.io/</a>
</li>

<li>Vector Databases simply explained! (Embeddings &amp; Indexes)<br />
<a href="https://www.youtube.com/watch?v=dN0lsF2cvm4">https://www.youtube.com/watch?v=dN0lsF2cvm4</a>
</li>

<li>Vector databases are so hot right now. WTF are they?<br />
<a href="https://www.youtube.com/watch?v=klTvEwg3oJ4">https://www.youtube.com/watch?v=klTvEwg3oJ4</a>
</li>

<li>Step-by-Step Guide to Installing â€œpgvectorâ€ and Loading Data in PostgreSQL<br />
<a href="https://medium.com/@besttechreads/step-by-step-guide-to-installing-pgvector-and-loading-data-in-postgresql-f2cffb5dec43">https://medium.com/@besttechreads/step-by-step-guide-to-installing-pgvector-and-loading-data-in-postgresql-f2cffb5dec43</a>
</li>

<li>Best 17 Vector Databases for 2025<br />
<a href="https://lakefs.io/blog/12-vector-databases-2023/">https://lakefs.io/blog/12-vector-databases-2023/</a>
</li>

<li>Top 15 Vector Databases that You Must Try in 2025<br />
<a href="https://www.geeksforgeeks.org/top-vector-databases/">https://www.geeksforgeeks.org/top-vector-databases/</a>
</li>

<li>Picking a vector database: a comparison and guide for 2023<br />
<a href="https://benchmark.vectorview.ai/vectordbs.html">https://benchmark.vectorview.ai/vectordbs.html</a>
</li>

<li>Top 9 Vector Databases as of Feburary 2025<br />
<a href="https://www.shakudo.io/blog/top-9-vector-databases">https://www.shakudo.io/blog/top-9-vector-databases</a>
</li>

<li>What is a vector database?<br />
<a href="https://www.ibm.com/think/topics/vector-database">https://www.ibm.com/think/topics/vector-database</a>
</li>

<li>SQL injection<br />
<a href="https://en.wikipedia.org/wiki/SQL_injection">https://en.wikipedia.org/wiki/SQL_injection</a>
</li>

<li>Cosine similarity<br />
<a href="https://en.wikipedia.org/wiki/Cosine_similarity">https://en.wikipedia.org/wiki/Cosine_similarity</a>
</li>

<li>Euclidean distance<br />
<a href="https://en.wikipedia.org/wiki/Euclidean_distance">https://en.wikipedia.org/wiki/Euclidean_distance</a>
</li>

<li>Dot product<br />
<a href="https://en.wikipedia.org/wiki/Dot_product">https://en.wikipedia.org/wiki/Dot_product</a>
</li>

<li>Hammingova vzdÃ¡lenost<br />
<a href="https://cs.wikipedia.org/wiki/Hammingova_vzd%C3%A1lenost">https://cs.wikipedia.org/wiki/Hammingova_vzd%C3%A1lenost</a>
</li>

<li>Jaccard index<br />
<a href="https://en.wikipedia.org/wiki/Jaccard_index">https://en.wikipedia.org/wiki/Jaccard_index</a>
</li>

<li>ManhattanskÃ¡ metrika<br />
<a href="https://cs.wikipedia.org/wiki/Manhattansk%C3%A1_metrika">https://cs.wikipedia.org/wiki/Manhattansk%C3%A1_metrika</a>
</li>

<li>pgvector: vektorovÃ¡ databÃ¡ze postavenÃ¡ na Postgresu<br />
<a href="https://www.root.cz/clanky/pgvector-vektorova-databaze-postavena-na-postgresu/">https://www.root.cz/clanky/pgvector-vektorova-databaze-postavena-na-postgresu/</a>
</li>

</ol>



<p></p><p></p>
<p><small>Autor: <a href="https://github.com/tisnik/">Pavel TiÅ¡novskÃ½</a> &nbsp; 2025</small></p>
</body>
</html>

