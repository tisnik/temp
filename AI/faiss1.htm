<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
        "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html>
<head>
<title>FAISS: knihovna pro rychlé a efektivní vyhledávání podobných vektorů</title>
<meta name="Author" content="Pavel Tisnovsky" />
<meta name="Generator" content="vim" />
<meta http-equiv="content-type" content="text/html; charset=utf-8" />
<style type="text/css">
         body {color:#000000; background:#ffffff;}
         h1  {font-family: arial, helvetica, sans-serif; color:#ffffff; background-color:#c00000; text-align:center; padding-left:1em}
         h2  {font-family: arial, helvetica, sans-serif; color:#ffffff; background-color:#0000c0; padding-left:1em; text-align:left}
         h3  {font-family: arial, helvetica, sans-serif; color:#000000; background-color:#c0c0c0; padding-left:1em; text-align:left}
         h4  {font-family: arial, helvetica, sans-serif; color:#000000; background-color:#e0e0e0; padding-left:1em; text-align:left}
         a   {font-family: arial, helvetica, sans-serif;}
         li  {font-family: arial, helvetica, sans-serif; color:#000000; text-align:justify; width:450px;}
         ol  {font-family: arial, helvetica, sans-serif; color:#000000; text-align:justify; width:450px;}
         ul  {font-family: arial, helvetica, sans-serif; color:#000000; text-align:justify; width:450px;}
         p   {font-family: arial, helvetica, sans-serif; color:#000000; text-align:justify;}
         pre {background:#e0e0e0}
</style>
</head>

<body>

<h1>FAISS: knihovna pro rychlé a efektivní vyhledávání podobných vektorů</h1>

<h3>Pavel Tišnovský</h3>

<p></p>

<h1>Úvodník</h1>

<p>V dnešním článku se seznámíme se základními vlastnostmi knihovny FAISS, která se určena pro vyhledávání vektorů (s vysokými počty dimenzí) na základě jejich podobnosti. Tato knihovna se používá při zpracování přirozeného jazyka, jako základ RAG databází atd.</p>



<h2>Obsah</h2>

<p><a href="#k01">1. FAISS: knihovna pro rychlé a efektivní vyhledávání podobných vektorů</a></p>
<p><a href="#k02">2. Svět vektorových databází</a></p>
<p><a href="#k03">3. Je FAISS vektorovou databází?</a></p>
<p><a href="#k04">4. Řešený problém: nalezení nejbližších <i>k</i> bodů k&nbsp;zadaným souřadnicím</a></p>
<p><a href="#k05">5. Příprava projektu</a></p>
<p><a href="#k06">6. Instalace balíčků <strong>faiss-cpu</strong> a <strong>numpy</strong> do virtuálního prostředí</a></p>
<p><a href="#k07">7. Definice souřadnic bodů v&nbsp;rovině</a></p>
<p><a href="#k08">8. Konstrukce matice se souřadnicemi bodů</a></p>
<p><a href="#k09">9. Konstrukce indexu pro vyhledávání na základě vzdálenosti</a></p>
<p><a href="#k10">10. Nalezení nejbližších bodů k&nbsp;zadaným souřadnicím</a></p>
<p><a href="#k11">11. Výpis souřadnic bodů nejbližších k&nbsp;zadaným souřadnicím</a></p>
<p><a href="#k12">12. Vizualizace nejbližších nalezených bodů</a></p>
<p><a href="#k13">13. Výběry vektorů na základě jejich podobnosti: volba metriky</a></p>
<p><a href="#k14">14. Výběr podobných vektorů pomocí skalárního součinu: nekorektní verze</a></p>
<p><a href="#k15">15. Normalizace vektorů v&nbsp;indexu</a></p>
<p><a href="#k16">16. Rychlost vyhledání nejbližších bodů</a></p>
<p><a href="#k17">17. Výsledky benchmarku</a></p>
<p><a href="#k18">18. Obsah navazujícího článku</a></p>
<p><a href="#k19">19. Repositář s&nbsp;demonstračními příklady</a></p>
<p><a href="#k20">20. Odkazy na Internetu</a></p>



<p><a name="k01"></a></p>
<h2 id="k01">1. FAISS: knihovna pro rychlé a efektivní vyhledávání podobných vektorů</h2>

<p>V&nbsp;současnosti můžeme sledovat poměrně výrazné a stále častější
nasazování vektorových databází. Jedná se (většinou) o specializované databáze,
které umožňují ukládat vektory numerických hodnot a především efektivně
vyhledávat vektory podle jejich podobnosti (například se zadaným vzorem),
přičemž <i>podobností</i> může být v&nbsp;tomto kontextu myšlena například
vzdálenost koncových bodů vektorů v&nbsp;Eukleidovském prostoru, kosinus úhlu
mezi vektory, výsledek skalárního součinu (pro normalizované vektory) atd.</p>

<p>Tyto operace se používají v&nbsp;mnoha oblastech, například při rozpoznávání
a zpracování přirozeného jazyka (<i>NLP &ndash; Natural Language
Processing</i>), při rozpoznávání obrázků, rozpoznávání hlasů, detekci
anomálií, ale i (a to zejména) v&nbsp;souvislosti s&nbsp;velkými jazykovými
modely (k&nbsp;tomuto tématu se ještě vrátíme v&nbsp;samostatném článku).</p>

<p><div class="rs-tip-major">Poznámka: do této kategorie spadají i RAG
databáze.</div></p>

<p>Na stránkách Roota jsme se již v&nbsp;článku <a
href="https://www.root.cz/clanky/pgvector-vektorova-databaze-postavena-na-postgresu/">pgvector:
vektorová databáze postavená na Postgresu</a> seznámili s&nbsp;vektorovou
databází <strong>pgvector</strong>, která je postavena nad Postgresem. Dnes si
popíšeme základní vlastnosti knihovny nazvané <strong>FAISS</strong>, což je
jméno, které vzniklo ze sousloví <i>Facebook AI Similarity Search</i> (ovšem
tato knihovna se používá i v&nbsp;mnoha projektech, které nemají
s&nbsp;Facebookem nebo Metou cokoli společného). FAISS je šířena pod MIT
licencí, což umožňuje její relativně snadné zařazení do dalších projektů.</p>



<p><a name="k02"></a></p>
<h2 id="k02">2. Svět vektorových databází</h2>

<p>S&nbsp;rozvojem systémů určených pro zpracování přirozeného jazyka i
generativních AI (zejména velkých jazykových modelů) došlo i k&nbsp;velkému
rozmachu vektorových databází. Dnes jich existuje minimálně několik desítek
(pokud počítáme ty nejznámější a/nebo veřejně dostupné), ovšem spíše jich bude
několik set.</p>

<p>V&nbsp;tabulce pod tímto odstavcem jsou vypsány ty nejznámější vektorové
databáze, které pochopitelně mají rozdílné vlastnosti a každá z&nbsp;nich se
hodí pro jiné způsoby nasazení:</p>

<table>
<tr><td>Aerospike</td></tr>
<tr><td>AllegroGraph</td></tr>
<tr><td>Apache Cassandra</td></tr>
<tr><td>Azure Cosmos DB</td></tr>
<tr><td>Chroma</td></tr>
<tr><td>ClickHouse</td></tr>
<tr><td>Couchbase</td></tr>
<tr><td>CrateDB</td></tr>
<tr><td>DataStax</td></tr>
<tr><td>Elasticsearch</td></tr>
<tr><td>HAKES</td></tr>
<tr><td>HDF5 Query Indexing</td></tr>
<tr><td>JaguarDB</td></tr>
<tr><td>LanceDB</td></tr>
<tr><td>Lantern</td></tr>
<tr><td>LlamaIndex</td></tr>
<tr><td>MariaDB</td></tr>
<tr><td>Marqo</td></tr>
<tr><td>Meilisearch</td></tr>
<tr><td>Milvus</td></tr>
<tr><td>MongoDB Atlas</td></tr>
<tr><td>Neo4j</td></tr>
<tr><td>ObjectBox</td></tr>
<tr><td>OpenSearch</td></tr>
<tr><td>Oracle Database</td></tr>
<tr><td>Pinecone</td></tr>
<tr><td>Pixeltable (Incremental Embedding)</td></tr>
<tr><td>Postgres with pgvector</td></tr>
<tr><td>Qdrant</td></tr>
<tr><td>Redis Stack</td></tr>
<tr><td>Snowflake</td></tr>
<tr><td>SurrealDB</td></tr>
<tr><td>Typesense</td></tr>
<tr><td>Vespa</td></tr>
<tr><td>Weaviate</td></tr>
</table>



<p><a name="k03"></a></p>
<h2 id="k03">3. Je FAISS vektorovou databází?</h2>

<p>V&nbsp;některých článcích se můžeme dočíst, že FAISS je vektorovou databází.
Ovšem to ve skutečnosti není pravda, protože FAISS &bdquo;pouze&ldquo;
poskytuje algoritmy určené pro efektivní vyhledávání podobných vektorů a pro
jejich shlukování (<i>clustering</i>). Neřeší ovšem problém uložení vektorů
v&nbsp;nějakém strukturovaném formátu. Naopak, některé skutečné vektorové
databáze, mezi které patří například <i>Milvus</i> nebo <i>OpenSearch</i>,
využívají FAISS pro vyhledávání, ovšem způsob uložení a načítání vektorů řeší
ve své vlastní režii.</p>

<p><div class="rs-tip-major">Poznámka: na druhou stranu je však efektivní
vyhledávání podobných vektorů ústředním prvkem mnoha systémů s&nbsp;AI, takže
volba vhodné knihovny pro tyto operace bývá mnohem důležitější, než vlastní
způsob uložení vektorů v&nbsp;databázi. Je tomu tak z&nbsp;toho důvodu, že
vektory mají velký počet dimenzí (i několik tisíc) a samotných vektorů může být
několik milionů, i více. Volba optimálního algoritmu (a popř.&nbsp;provedení
výpočtů na GPU) je tedy v&nbsp;takových případech kritická.</div></p>



<p><a name="k04"></a></p>
<h2 id="k04">4. Řešený problém: nalezení nejbližších <i>k</i> bodů k&nbsp;zadaným souřadnicím</h2>

<p>V&nbsp;navazujícím kapitolách se s&nbsp;využitím knihovny <i>FAISS</i>
pokusíme vyřešit následující problém: v&nbsp;2D prostoru máme patnáct bodů a
budeme chtít najít <i>k</i> bodů, které jsou neblíže k&nbsp;zadaným
souřadnicím. Pokud bude <i>k=1</i>, tak budeme chtít nalézt nejbližší bod atd.
Body jsou přitom v&nbsp;rovině rozmístěny následujícím způsobem a u vybraných
bodů jsou zapsány i jejich souřadnice:</p>

<pre>
                                       │ y
                                       │
                                       │
                                       │
                                       │                [5,5]
                     o       o         │          o   o   o
                                       │          o   o   o
                         o             │          o   o   o
                      [-4,3]           │        [3,3]   [5,3]
                                       │
─────────────────────────────────────[0,0]──────────────────────────────────────
                                       │                                       x
                                       │              o
                                       │
                                       │          o       o
                                       │                [5,-5]
                                       │
                                       │
                                       │
                                       │
</pre>



<p><a name="k05"></a></p>
<h2 id="k05">5. Příprava projektu</h2>

<p>V&nbsp;prvním kroku si připravíme projekt v&nbsp;Pythonu a následně do něj
nainstalujeme všechny potřebné knihovny. Pro vytvoření projektu použijeme
nástroj <i>PDM</i> &ndash; viz též <a
href="https://www.root.cz/clanky/pdm-moderni-spravce-balicku-a-virtualnich-prostredi-pythonu/">PDM:
moderní správce balíčků a virtuálních prostředí Pythonu</a>. Projekt bude
vytvořen v&nbsp;novém (původně prázdném) adresáři:</p>

<pre>
$ <strong>mkdir faiss-demo</strong>
$ <strong>cd faiss-demo</strong>
</pre>

<p>Následně si necháme vytvořit projektový soubor nazvaný
<strong>pyproject.toml</strong>. Na všechny odpovědi kladené nástrojem PDM
můžeme s&nbsp;klidem odpovědět jen klávesou Enter:</p>

<pre>
$ <strong>pdm init</strong>
&nbsp;
Creating a pyproject.toml for PDM...
Please enter the Python interpreter to use
 0. cpython@3.12 (/usr/bin/python)
 1. cpython@3.13 (/usr/bin/python3.13)
 2. cpython@3.12 (/usr/bin/python3.12)
 3. cpython@3.11 (/usr/bin/python3.11)
Please select (0):
&nbsp;
&nbsp;
Virtualenv is created successfully at /tmp/ramdisk/faiss-demo/.venv
Project name (faiss-demo): Project version (0.1.0): Do you want to build this project for distribution(such as wheel)?
If yes, it will be installed by default when running `pdm install`. [y/n] (n):
License(SPDX name) (MIT):
Author name (Pavel Tisnovsky):
Author email (tisnik@nikdo.nikde.com):
Python requires('*' to allow any) (==3.12.*):
Project is initialized successfully
</pre>

<p>Výsledný projektový soubor <strong>pyproject.toml</strong> by měl vypadat
následovně (samozřejmě kromě jména, mailu a zvolené verze Pythonu):</p>

<pre>
[project]
name = "faiss-demo"
version = "0.1.0"
description = "Default template for PDM package"
authors = [
    {name = "Pavel Tisnovsky", email = "tisnik@nikdo.nikde.com"},
]
dependencies = []
requires-python = "==3.12.*"
readme = "README.md"
license = {text = "MIT"}
&nbsp;
&nbsp;
[tool.pdm]
distribution = false
</pre>



<p><a name="k06"></a></p>
<h2 id="k06">6. Instalace balíčků <strong>faiss-cpu</strong> a <strong>numpy</strong> do virtuálního prostředí</h2>

<p>Ve druhém kroku do virtuálního prostředí vytvořeného pro nový projekt
přidáme dva balíčky &ndash; <strong>faiss-cpu</strong> a
<strong>numpy</strong>.  Druhý z&nbsp;balíčků byl přidán z&nbsp;toho důvodu,
abychom mohli tvořit vektory, s&nbsp;nimiž bude <strong>faiss</strong>
pracovat:</p>

<pre>
$ <strong>pdm add faiss-cpu numpy</strong>
&nbsp;
Adding packages to default dependencies: faiss-cpu, numpy
  0:00:03 🔒 Lock successful.
Changes are written to pyproject.toml.
Synchronizing working set with resolved packages: 3 to add, 0 to update, 0 to remove
&nbsp;
  ✔ Install packaging 25.0 successful
  ✔ Install numpy 2.3.1 successful
  ✔ Install faiss-cpu 1.11.0 successful
&nbsp;
  0:00:05 🎉 All complete! 3/3
</pre>

<p>Projektový soubor nyní vypadá následovně:</p>

<pre>
[project]
name = "faiss-demo"
version = "0.1.0"
description = "Default template for PDM package"
authors = [
    {name = "Pavel Tisnovsky", email = "ptisnovs@redhat.com"},
]
dependencies = ["faiss-cpu&gt;=1.11.0", "numpy&gt;=2.3.1"]
requires-python = "==3.12.*"
readme = "README.md"
license = {text = "MIT"}
&nbsp;
&nbsp;
[tool.pdm]
distribution = false
</pre>

<p>Ověříme si, zda je modul <strong>faiss</strong> skutečně dostupný:</p>

<pre>
$ <strong>pdm run </strong>
&nbsp;
WARNING: No command is given, default to the Python REPL.
Python 3.12.10 (main, Apr 22 2025, 00:00:00) [GCC 14.2.1 20240912 (Red Hat 14.2.1-3)] on linux
Type "help", "copyright", "credits" or "license" for more information.
&nbsp;
&gt;&gt;&gt; <strong>import faiss</strong>
&gt;&gt;&gt; <strong>help(faiss)</strong>
</pre>

<p>Měla by se zobrazit nápověda:</p>

<pre>
Help on package faiss:
&nbsp;
NAME
    faiss
&nbsp;
DESCRIPTION
    # Copyright (c) Facebook, Inc. and its affiliates.
    #
    # This source code is licensed under the MIT license found in the
    # LICENSE file in the root directory of this source tree.
&nbsp;
PACKAGE CONTENTS
    _swigfaiss
    _swigfaiss_avx2
    _swigfaiss_avx512
    array_conversions
    class_wrappers
    contrib (package)
    extra_wrappers
    gpu_wrappers
    loader
    setup
    swigfaiss
    swigfaiss_avx2
    swigfaiss_avx512
&nbsp;
CLASSES
</pre>



<p><a name="k07"></a></p>
<h2 id="k07">7. Definice souřadnic bodů v&nbsp;rovině</h2>

<p>Souřadnice bodů umístěných v&nbsp;rovině (viz <a href="#k04">čtvrtou
kapitolu</a> s&nbsp;jejich vizualizací) je možné uložit do běžných
Pythonovských seznamů nebo do n-tic. Bodů je celkem patnáct a souřadnice
v&nbsp;rovině mají jen dvě dimenze, takže reprezentace souřadnice je
v&nbsp;tomto případě snadná:</p>

<pre>
<i># x-ove souradnice bodu v rovine</i>
x = [-5, -4, -3,    3,  4,  5,    3, 3, 3, 4, 4, 4, 5, 5, 5]
&nbsp;
<i># y-ove souradnice bodu v rovine</i>
y = [ 5,  3,  5,   -5, -3, -5,    3, 4, 5, 3, 4, 5, 3, 4, 5]
</pre>

<p><div class="rs-tip-major">Poznámka: vizuálně (mezerami) jsou odděleny
jednotlivé kvadranty, do nichž jsou body umístěny.</div></p>

<p>Z&nbsp;těchto dvou oddělených seznamů je možné vytvořit seznam souřadnic
(dvojic) velmi snadno:</p>

<pre>
<i># x-ove souradnice bodu v rovine</i>
x = [-5, -4, -3,    3,  4,  5,   3, 3, 3,  4, 4, 4,  5, 5, 5]
&nbsp;
<i># y-ove souradnice bodu v rovine</i>
y = [ 5,  3,  5,   -5, -3, -5,   3, 4, 5,  3, 4, 5,  3, 4, 5]
&nbsp;
print(x)
print(y)
&nbsp;
<i># seznam souradnic</i>
print(list(zip(x, y)))
</pre>

<p>Výsledky:</p>

<pre>
[-5, -4, -3, 3, 4, 5, 3, 3, 3, 4, 4, 4, 5, 5, 5]
[5, 3, 5, -5, -3, -5, 3, 4, 5, 3, 4, 5, 3, 4, 5]
&nbsp;
[(-5, 5), (-4, 3), (-3, 5), (3, -5), (4, -3), (5, -5), (3, 3), (3, 4), (3, 5), (4, 3), (4, 4), (4, 5), (5, 3), (5, 4), (5, 5)]
</pre>



<p><a name="k08"></a></p>
<h2 id="k08">8. Konstrukce matice se souřadnicemi bodů</h2>

<p>Knihovna <i>FAISS</i> ovšem na svém vstupu neočekává standardní Pythonovské
seznamy, ale (typicky) matice ve formátu podporovaném knihovnou <i>Numpy</i>
(interně se jedná o obecnou strukturu reprezentující n-rozměrná pole).
V&nbsp;takovém případě je matice homogenní, tj.&nbsp;všechny její prvky jsou
stejného typu. Navíc musíme zaručit, že tento typ bude buď <i>float32</i> nebo
<i>float16</i> popř.&nbsp;<i>bfloat16</i>. Ukažme si tedy, jakým způsobem lze
vytvořit dvourozměrné pole souřadnic, ve kterém budou všechny prvky typu
<i>float32</i>:</p>

<pre>
import numpy as np
&nbsp;
<i># x-ove souradnice bodu v rovine</i>
x = [-5, -4, -3,    3,  4,  5,   3, 3, 3,  4, 4, 4,  5, 5, 5]
&nbsp;
<i># y-ove souradnice bodu v rovine</i>
y = [ 5,  3,  5,   -5, -3, -5,   3, 4, 5,  3, 4, 5,  3, 4, 5]
&nbsp;
<i># konstrukce 2D matice, v niz kazdy radek obsahuje souradnice jednoho bodu v</i>
<i># rovine</i>
points = np.column_stack((x,y)).astype("float32")
print(points)
</pre>

<p>Výsledek nyní bude vypadat následovně:</p>

<pre>
[[-5.  5.]
 [-4.  3.]
 [-3.  5.]
 [ 3. -5.]
 [ 4. -3.]
 [ 5. -5.]
 [ 3.  3.]
 [ 3.  4.]
 [ 3.  5.]
 [ 4.  3.]
 [ 4.  4.]
 [ 4.  5.]
 [ 5.  3.]
 [ 5.  4.]
 [ 5.  5.]]
</pre>

<p><div class="rs-tip-major">Poznámka: tuto matici je již možné použít jako
přímá vstupní data pro knihovnu <i>FAISS</i>.</div></p>



<p><a name="k09"></a></p>
<h2 id="k09">9. Konstrukce indexu pro vyhledávání na základě vzdálenosti</h2>

<p>Nyní již máme k&nbsp;dispozici vstupní vektory (v&nbsp;našem případě sadu
patnácti dvouprvkových vektorů) připraveny ve formátu, který je kompatibilní
s&nbsp;knihovnou <i>FAISS</i>. Tyto vektory nyní využijeme pro konstrukci
takzvaného <i>indexu</i>. To je datová struktura umožňující rychlé vyhledávání
nejbližších vektorů na základě zvolené metriky určující vzdálenosti (pojem
vzdálenosti je zde ovšem zobecněn a nemusí znamenat pouze Eukleidovskou
vzdálenost).</p>

<p>V&nbsp;dalším demonstračním příkladu se zkonstruuje index typu
<strong>L2</strong>, což značí Eukleidovskou vzdálenost L<sup>2</sup>:</p>

<pre>
import faiss
import numpy as np
&nbsp;
<i># x-ove souradnice bodu v rovine</i>
x = [-5, -4, -3,    3,  4,  5,   3, 3, 3,  4, 4, 4,  5, 5, 5]
&nbsp;
<i># y-ove souradnice bodu v rovine</i>
y = [ 5,  3,  5,   -5, -3, -5,   3, 4, 5,  3, 4, 5,  3, 4, 5]
&nbsp;
<i># konstrukce 2D matice, v niz kazdy radek obsahuje souradnice jednoho bodu v</i>
<i># rovine</i>
points = np.column_stack((x,y)).astype("float32")
print(points)
&nbsp;
<i># konstrukce indexu pro vyhledavani na zaklade vzdalenosti</i>
index = faiss.IndexFlatL2(2)
index.add(points)
&nbsp;
print()
print("Dimension(s):         ", index.d)
print("Total values in index:", index.ntotal)
print("Is index trained:     ", index.is_trained)
</pre>

<p>Po konstrukci indexu si necháme vypsat jeho základní charakteristiky &ndash;
počet dimenzí, počet záznamů v&nbsp;indexu a taktéž příznak, zda je index
natrénován (viz navazující článek):</p>

<pre>
[[-5.  5.]
 [-4.  3.]
 [-3.  5.]
 [ 3. -5.]
 [ 4. -3.]
 [ 5. -5.]
 [ 3.  3.]
 [ 3.  4.]
 [ 3.  5.]
 [ 4.  3.]
 [ 4.  4.]
 [ 4.  5.]
 [ 5.  3.]
 [ 5.  4.]
 [ 5.  5.]]
&nbsp;
Dimension(s):          2
Total values in index: 15
Is index trained:      True
</pre>



<p><a name="k10"></a></p>
<h2 id="k10">10. Nalezení nejbližších bodů k&nbsp;zadaným souřadnicím</h2>

<p>Nyní se konečně dostáváme k&nbsp;ústřednímu tématu dnešního článku, tedy
k&nbsp;realizaci skriptu, který má nalézt nejbližších <i>k</i> bodů (nebo,
chcete-li, vektorů) k&nbsp;zadaným souřadnicím v&nbsp;rovině. Začněme těmito
souřadnicemi. I ty je nutné realizovat formou matice, v&nbsp;našem případě
matice s&nbsp;jediným řádkem se souřadnicemi [3, 3]. A opět platí, že typ prvků
této matice musí být buď <i>float32</i> nebo <i>float16</i>
popř.&nbsp;<i>bfloat16</i>. Použijeme typ <i>float32</i>, tedy stejný typ, jaký
mají prvky vstupní matice vektorů:</p>

<pre>
query_vector = np.array([[3, 3]]).astype("float32")
print(query_vector)
</pre>

<p>Následně si necháme vyhledat <i>k</i> nejbližších bodů (vektorů)
k&nbsp;těmto souřadnicím. V&nbsp;praxi může <i>k</i> nabývat hodnoty od 1
(nejbližší bod) až po počet vstupních vektorů:</p>

<pre>
k = len(x)
distances, indices = index.search(query_vector, k)
</pre>

<p>Body/vektory budou v&nbsp;tomto případě vráceny v&nbsp;pořadí od nejbližšího
k&nbsp;nejvzdálenějšímu (viz první hodnoty <strong>distances</strong>):</p>

<pre>
<i># tisk vysledku</i>
print("Nearest neighbors:")
print("neighbour  distance  index")
print("--------------------------")
for i in range(k):
    print(f"{i+1:3}      {distances[0][i]:5}       {indices[0][i]:2}")
</pre>

<p>Výsledky budou vypadat následovně:</p>

<pre>
Nearest neighbors:
neighbour  distance  index
--------------------------
  1        0.0        6
  2        1.0        7
  3        1.0        9
  4        2.0       10
  5        4.0        8
  6        4.0       12
  7        5.0       11
  8        5.0       13
  9        8.0       14
 10       37.0        4
 11       40.0        2
 12       49.0        1
 13       64.0        3
 14       68.0        0
 15       68.0        5
</pre>

<p>A takto vypadá celý skript, který výše popsaný výpočet provádí:</p>

<pre>
import faiss
import numpy as np
&nbsp;
<i># x-ove souradnice bodu v rovine</i>
x = [-5, -4, -3,    3,  4,  5,   3, 3, 3,  4, 4, 4,  5, 5, 5]
&nbsp;
<i># y-ove souradnice bodu v rovine</i>
y = [ 5,  3,  5,   -5, -3, -5,   3, 4, 5,  3, 4, 5,  3, 4, 5]
&nbsp;
<i># konstrukce 2D matice, v niz kazdy radek obsahuje souradnice jednoho bodu v</i>
<i># rovine</i>
points = np.column_stack((x,y)).astype("float32")
print(points)
&nbsp;
<i># konstrukce indexu pro vyhledavani na zaklade vzdalenosti</i>
index = faiss.IndexFlatL2(2)
index.add(points)
&nbsp;
print()
print("Dimension(s):         ", index.d)
print("Total values in index:", index.ntotal)
print("Is index trained:     ", index.is_trained)
&nbsp;
<i># vektor, ke kteremu budeme pocitat vzdalenost</i>
query_vector = np.array([[3, 3]]).astype("float32")
print(query_vector)
&nbsp;
<i># pocet nejblizsich bodu</i>
k = len(x)
distances, indices = index.search(query_vector, k)
&nbsp;
<i># tisk vysledku</i>
print("Nearest neighbors:")
print("neighbour  distance  index")
print("--------------------------")
for i in range(k):
    print(f"{i+1:3}      {distances[0][i]:5}       {indices[0][i]:2}")
</pre>



<p><a name="k11"></a></p>
<h2 id="k11">11. Výpis souřadnic bodů nejbližších k&nbsp;zadaným souřadnicím</h2>

<p>V&nbsp;předchozím skriptu se vypisovaly pouze indexy nejbližších
bodů/vektorů. Ovšem my máme k&nbsp;dispozici i původní souřadnice těchto bodů,
takže si můžeme vypsat přímo tyto souřadnice:</p>

<pre>
Nearest neighbors:
neighbour  distance  coordinates  
----------------------------------
  1        0.0       [3. 3.]
  2        1.0       [3. 4.]
  3        1.0       [4. 3.]
  4        2.0       [4. 4.]
  5        4.0       [3. 5.]
  6        4.0       [5. 3.]
  7        5.0       [4. 5.]
  8        5.0       [5. 4.]
  9        8.0       [5. 5.]
 10       37.0       [ 4. -3.]
 11       40.0       [-3.  5.]
 12       49.0       [-4.  3.]
 13       64.0       [ 3. -5.]
 14       68.0       [-5.  5.]
 15       68.0       [ 5. -5.]
</pre>

<p><div class="rs-tip-major">Poznámka: zajisté jste si všimli, že vzdálenosti
jsou vypočteny špatně. Například vzdálenost bodů [3, 3] a [4, 4] nemá být 2 ale
&radic;2. Je tomu tak schválně &ndash; aby se nemusela pomalu počítat odmocnina
ze dvou, jsou namísto vzdáleností vypočteny jejich čtverce (tedy bez oné
odmocniny). V&nbsp;praxi to většinou nevadí, protože vzdálenosti potřebujeme
pouze porovnávat a odmocnina je monotonně rostoucí funkce.</div></p>

<p>Celý upravený skript nyní vypadá následovně:</p>

<pre>
import faiss
import numpy as np
&nbsp;
<i># x-ove souradnice bodu v rovine</i>
x = [-5, -4, -3,    3,  4,  5,   3, 3, 3,  4, 4, 4,  5, 5, 5]
&nbsp;
<i># y-ove souradnice bodu v rovine</i>
y = [ 5,  3,  5,   -5, -3, -5,   3, 4, 5,  3, 4, 5,  3, 4, 5]
&nbsp;
<i># konstrukce 2D matice, v niz kazdy radek obsahuje souradnice jednoho bodu v</i>
<i># rovine</i>
points = np.column_stack((x,y)).astype("float32")
print(points)
&nbsp;
<i># konstrukce indexu pro vyhledavani na zaklade vzdalenosti</i>
index = faiss.IndexFlatL2(2)
index.add(points)
&nbsp;
print()
print("Dimension(s):         ", index.d)
print("Total values in index:", index.ntotal)
print("Is index trained:     ", index.is_trained)
&nbsp;
<i># vektor, ke kteremu budeme pocitat vzdalenost</i>
query_vector = np.array([[3, 3]]).astype("float32")
print(query_vector)
&nbsp;
<i># pocet nejblizsich bodu</i>
k = len(x)
distances, indices = index.search(query_vector, k)
&nbsp;
<i># tisk vysledku</i>
print("Nearest neighbors:")
print("neighbour  distance  coordinates  ")
print("----------------------------------")
for i in range(k):
    print(f"{i+1:3}      {distances[0][i]:5}       {points[indices[0][i]]}")
</pre>



<p><a name="k12"></a></p>
<h2 id="k12">12. Vizualizace nejbližších nalezených bodů</h2>

<p>Upravme si nyní předchozí skript do takové podoby, aby vracel jen tři body
nejbližší k&nbsp;souřadnicím [-4, 4]. Úprava je v&nbsp;tomto případě snadná.
Modifikovaná místa jsou podtržena:</p>

<pre>
<i># vektor, ke kteremu budeme pocitat vzdalenost</i>
query_vector = np.array(<u>[[-4, 4]]</u>).astype("float32")
print(query_vector)
&nbsp;
<i># pocet nejblizsich bodu</i>
<u>k = 3</u>
distances, indices = index.search(query_vector, k)
</pre>

<p>Výsledkem výše uvedeného dotazu je trojice vektorů, které jsou nejpodobnější
vektoru [-4, 4]:</p>

<pre>
[[-4.  4.]]
&nbsp;
Nearest neighbors:
neighbour  distance  coordinates  
----------------------------------
  1        1.0       [-4.  3.]
  2        2.0       [-5.  5.]
  3        2.0       [-3.  5.]
</pre>

<p>Což si pochopitelně můžeme vizualizovat v&nbsp;rovině. Hvězdičkou je
naznačen bod/vektor z&nbsp;podmínky (pro který hledáme nejbližší sousedy),
kolečkem vektory vrácené jako výsledek dotazu a tečkou ostatní vektory, které
neodpovídají dotazu (nejsou vráceny):</p>

<pre>
                                       │ y
                                       │
                                       │
                                       │
                                       │
                     o       o         │          .   .   .
                         *             │          .   .   .
                         o             │          .   .   .
                                       │
                                       │
─────────────────────────────────────[0,0]──────────────────────────────────────
                                       │                                       x
                                       │
                                       │              .
                                       │
                                       │          .       .
                                       │
                                       │
                                       │
                                       │
</pre>



<p><a name="k13"></a></p>
<h2 id="k13">13. Výběry vektorů na základě jejich podobnosti: volba metriky</h2>

<p>Prozatím jsme pro výpočty podobnosti (resp.&nbsp;vzdálenosti) vektorů
používali klasickou Eukleidovskou metriku, tedy skutečnou vzdálenost bodů
v&nbsp;prostoru (v&nbsp;tomto případě vzdálenost koncových bodů vektorů
v&nbsp;2D rovině). Tato metrika se taktéž označuje L2 nebo přesněji
L<sup>2</sup>, ovšem knihovna <i>FAISS</i> podporuje i odlišnou metriku
založenou na výpočtu skalárního součinu (<i>dot product</i>). Vychází se přitom
z&nbsp;faktu, že pokud mají dva vektory jednotkovou délku, bude jejich skalární
součin největší v&nbsp;případě, že jsou vektory totožné, nulový ve chvíli, kdy
jsou vektory na sebe kolmé a záporný tehdy, pokud je jeden vektor oproti
druhému otočen o 180&deg;. Jedná se o velmi často používanou metriku pro
hledání podobných vektorů, ovšem v&nbsp;praxi nesmíme zapomenout na její
základní vlastnosti:</p>

<ol>
<li>Všechny vektory musí být normalizovány na jednotkovou délku (kromě nulového vektoru)</li>
<li>Jedná se o metriku, nikoli o vzdálenost. Naopak &ndash; čím podobnější jsou vektory, tím větší bude výsledek (opak vzdálenosti).</li>
<li>Pozor je nutné dát na nulové vektory, které není možné normalizovat (speciální případ)</li>
</ol>



<p><a name="k14"></a></p>
<h2 id="k14">14. Výběr podobných vektorů pomocí skalárního součinu: nekorektní verze</h2>

<p>Vyzkoušejme si nyní nahradit hledání podobných vektorů na základě
vzdálenosti za hledání s&nbsp;využitím skalárního součinu. Ve skriptu prozatím
provedeme jedinou změnu, a to konkrétně záměnu funkce pro konstrukci indexů.
Namísto:</p>

<pre>
index = faiss.IndexFlatL2(2)
</pre>

<p>zavoláme:</p>

<pre>
index = faiss.IndexFlatIP(2)
</pre>

<p>Výsledky budou vypadat takto:</p>

<pre>
Nearest neighbors:
neighbour  distance  coordinates  
----------------------------------
  1       30.0       [5. 5.]
  2       27.0       [5. 4.]
  3       27.0       [4. 5.]
  4       24.0       [5. 3.]
  5       24.0       [4. 4.]
  6       24.0       [3. 5.]
  7       21.0       [4. 3.]
  8       21.0       [3. 4.]
  9       18.0       [3. 3.]
 10        6.0       [-3.  5.]
 11        3.0       [ 4. -3.]
 12        0.0       [ 5. -5.]
 13        0.0       [-5.  5.]
 14       -3.0       [-4.  3.]
 15       -6.0       [ 3. -5.]
</pre>

<p>Například první výpočet vypadá následovně: 3&times;5+3&times;5=15+15=30. A
poslední výpočet 3&times;3+3&times;(-5)=9-15=-6. Tedy čím podobnější jsou
vektory, tím <i>větší</i> bude hodnota, zatímco u L2 metriky tomu bylo
naopak!</p>

<p>Celý skript byl upraven do této podoby:</p>

<pre>
import faiss
import numpy as np
&nbsp;
<i># x-ove souradnice bodu v rovine</i>
x = [-5, -4, -3,    3,  4,  5,   3, 3, 3,  4, 4, 4,  5, 5, 5]
&nbsp;
<i># y-ove souradnice bodu v rovine</i>
y = [ 5,  3,  5,   -5, -3, -5,   3, 4, 5,  3, 4, 5,  3, 4, 5]
&nbsp;
<i># konstrukce 2D matice, v niz kazdy radek obsahuje souradnice jednoho bodu v</i>
<i># rovine</i>
points = np.column_stack((x,y)).astype("float32")
print(points)
&nbsp;
<i># konstrukce indexu pro vyhledavani na zaklade skalarniho soucinu</i>
index = <strong>faiss.IndexFlatIP(2)</strong>
index.add(points)
&nbsp;
print()
print("Dimension(s):         ", index.d)
print("Total values in index:", index.ntotal)
print("Is index trained:     ", index.is_trained)
&nbsp;
<i># vektor, ke kteremu budeme pocitat vzdalenost</i>
query_vector = np.array([[3, 3]]).astype("float32")
print(query_vector)
&nbsp;
<i># pocet nejblizsich bodu</i>
k = len(x)
distances, indices = index.search(query_vector, k)
&nbsp;
<i># tisk vysledku</i>
print("Nearest neighbors:")
print("neighbour  distance  coordinates  ")
print("----------------------------------")
for i in range(k):
    print(f"{i+1:3}      {distances[0][i]:5}       {points[indices[0][i]]}")
</pre>



<p><a name="k15"></a></p>
<h2 id="k15">15. Normalizace vektorů v&nbsp;indexu</h2>

<p>Výpočet metriky založené na skalárním součinu předpokládá, že vektory jsou
již dopředu normalizovány, tj.&nbsp;že jejich délka je buď rovna jedné nebo
nule. V&nbsp;praxi je tedy nutné již při konstrukci indexů použít normalizované
vektory. To se provede relativně snadno (a zejména &ndash; pouze jedenkrát při
inicializaci):</p>

<pre>
<i># normalizace</i>
for i in range(len(points)):
   vector = points[i]
   normalized = np.linalg.norm(vector)
   vector /= normalized
   points[i] = vector
</pre>

<p>Index se zkonstruuje s&nbsp;využitím normalizovaných vektorů:</p>

<pre>
<i># konstrukce indexu pro vyhledavani na zaklade vzdalenosti</i>
index = faiss.IndexFlatIP(2)
index.add(points)
</pre>

<p>I vektor, pro který hledáme nejshodnější &bdquo;sousedy&ldquo; je nutné
normalizovat a teprve poté provést vyhledávání:</p>

<pre>
<i># vektor, ke kteremu budeme pocitat vzdalenost</i>
query_vector = np.array([[3, 3]]).astype("float32")
normalized = np.linalg.norm(query_vector)
query_vector /= normalized
print(query_vector)
&nbsp;
<i># pocet nejblizsich bodu</i>
k = len(x)
distances, indices = index.search(query_vector, k)
</pre>

<p>Výsledky vyhledávání budou (podle očekávání) odlišné:</p>

<pre>
Nearest neighbors:
neighbour  distance  coordinates  
----------------------------------
  1      +1.0000     [0.7071068 0.7071068]
  2      +1.0000     [0.70710677 0.70710677]
  3      +1.0000     [0.70710677 0.70710677]
  4      +0.9939     [0.78086877 0.62469506]
  5      +0.9939     [0.62469506 0.78086877]
  6      +0.9899     [0.8 0.6]
  7      +0.9899     [0.6 0.8]
  8      +0.9701     [0.857493  0.5144958]
  9      +0.9701     [0.5144958 0.857493 ]
 10      +0.2425     [-0.5144958  0.857493 ]
 11      +0.1414     [ 0.8 -0.6]
 12      +0.0000     [-0.70710677  0.70710677]
 13      -0.0000     [ 0.70710677 -0.70710677]
 14      -0.1414     [-0.8  0.6]
 15      -0.2425     [ 0.5144958 -0.857493 ]
</pre>

<p><div class="rs-tip-major">Poznámka: povšimněte si, že nyní dostáváme hodnoty
v&nbsp;rozsahu -1..1.</div></p>

<p>Opět si ukažme úplný zdrojový kód takto upraveného skriptu:</p>

<pre>
import faiss
import numpy as np
&nbsp;
<i># x-ove souradnice bodu v rovine</i>
x = [-5, -4, -3,    3,  4,  5,   3, 3, 3,  4, 4, 4,  5, 5, 5]
&nbsp;
<i># y-ove souradnice bodu v rovine</i>
y = [ 5,  3,  5,   -5, -3, -5,   3, 4, 5,  3, 4, 5,  3, 4, 5]
&nbsp;
<i># konstrukce 2D matice, v niz kazdy radek obsahuje souradnice jednoho bodu v</i>
<i># rovine</i>
points = np.column_stack((x,y)).astype("float32")
print(points)
&nbsp;
<i># normalizace</i>
for i in range(len(points)):
   vector = points[i]
   normalized = np.linalg.norm(vector)
   vector /= normalized
   points[i] = vector
&nbsp;
print()
print("Normalized:")
print(points)
&nbsp;
<i># konstrukce indexu pro vyhledavani na zaklade vzdalenosti</i>
index = faiss.IndexFlatIP(2)
index.add(points)
&nbsp;
print()
print("Dimension(s):         ", index.d)
print("Total values in index:", index.ntotal)
print("Is index trained:     ", index.is_trained)
&nbsp;
<i># vektor, ke kteremu budeme pocitat vzdalenost</i>
query_vector = np.array([[3, 3]]).astype("float32")
normalized = np.linalg.norm(query_vector)
query_vector /= normalized
print(query_vector)
&nbsp;
<i># pocet nejblizsich bodu</i>
k = len(x)
distances, indices = index.search(query_vector, k)
&nbsp;
<i># tisk vysledku</i>
print("Nearest neighbors:")
print("neighbour  distance  coordinates  ")
print("----------------------------------")
for i in range(k):
    print(f"{i+1:3}      {distances[0][i]:+7.4f}     {points[indices[0][i]]}")
</pre>



<p><a name="k16"></a></p>
<h2 id="k16">16. Rychlost vyhledání nejbližších bodů</h2>

<p>Při vyhledávání na základě podobnosti vektorů v&nbsp;rozsáhlých databázích
je důležité, aby byl algoritmus vyhledávání dostatečně rychlý. V&nbsp;knihovně
<i>FAISS</i> je z&nbsp;tohoto důvodu implementováno hned několik algoritmů
používaných v&nbsp;různých situacích. Dnes se budeme primárně zabývat výchozím
algoritmem, u kterého se pokusíme odhadnout (a příště i popsat) jeho časovou
složitost. Vytvoříme proto benchmark, který bude pracovat s&nbsp;různě velkými
indexy a bude postupně měřit dobu vyhledávání (a pro zajímavost i další časy
trvání). Celý benchmark je prozatím poměrně naivní, ovšem pro prvotní odhad
složitost může postačovat:</p>

<pre>
from time import time
import faiss
import numpy as np
&nbsp;
import matplotlib.pyplot as plt
&nbsp;
&nbsp;
def <strong>similarity_search</strong>(n, k):
    DIMENSIONS=128
&nbsp;
    t1 = time()
&nbsp;
    <i># nahodne vektory</i>
    data = np.random.rand(n, 128).astype('float32')
&nbsp;
    t2 = time()
&nbsp;
    <i># konstrukce indexu pro vyhledavani na zaklade vzdalenosti</i>
    index = faiss.IndexFlatL2(DIMENSIONS)
    index.add(data)
&nbsp;
    t3 = time()
&nbsp;
    <i># vektor, ke kteremu budeme pocitat vzdalenost</i>
    query_vector = np.random.rand(1, DIMENSIONS).astype("float32")
&nbsp;
    <i># pocet nejblizsich bodu</i>
    distances, indices = index.search(query_vector, k)
    t4 = time()
    assert len(distances) == k
    assert len(indices) == k
&nbsp;
    return n, t2-t1, t3-t2, t4-t3
&nbsp;
&nbsp;
ns = []
ts_rand = []
ts_index = []
ts_search = []
&nbsp;
for n in np.linspace(1000000, 10000000, 10):
    print(n)
    n, t_rand, t_index, t_search = similarity_search(int(n), 1)
    ns.append(n)
    ts_rand.append(t_rand)
    ts_index.append(t_index)
    ts_search.append(t_search)
&nbsp;
&nbsp;
plt.plot(ns, ts_rand, "r-", label="numpy.random.rand")
plt.plot(ns, ts_index, "b-", label="index creation")
plt.plot(ns, ts_search, "m-", label="similarity search")
&nbsp;
<i># přidání legendy</i>
plt.legend(loc="upper left")
&nbsp;
<i># povolení zobrazení mřížky</i>
plt.grid(True)
&nbsp;
plt.savefig("faiss_benchmark_2.png")
&nbsp;
<i># zobrazení grafu</i>
plt.show()
</pre>



<p><a name="k17"></a></p>
<h2 id="k17">17. Výsledky benchmarku</h2>

<p>Numerické výsledky benchmarku vypadají následovně:</p>

<pre>
   n      Konstrukce matice   Konstrukce indexu    Vlastní vyhledávání
---------------------------------------------------------------------
 1000000  1.313993215560913   0.3532786369323731   0.03192019462585449
 2000000  2.543938875198364   0.7037720680236816   0.06934928894042969
 3000000  3.741727113723755   1.0349786281585693   0.09357905387878418
 4000000  4.819754600524902   1.3467643260955810   0.11976456642150879
 5000000  6.031541824340820   1.6814656257629395   0.14942240715026855
 6000000  7.295117855072022   2.1264710426330566   0.17904376983642578
 7000000  8.616289138793945   2.3469836711883545   0.23292398452758790
 8000000 11.428938865661621   2.7663018703460693   0.24178504943847656
 9000000 21.055070638656616   3.2713224887847900   0.27842283248901367
10000000 27.235011577606200   3.4759612083435060   0.29420256614685060
</pre>

<p>Lepší však bude si výsledky prohlédnou v&nbsp;grafické podobně. Nejprve
všechny časy:</p>

*** image ***

<p>Ovšem nejvíce nás zajímají časy vyhledávání, takže si zobrazme pouze tyto
naměřené výsledky:</p>

*** image ***

<p><div class="rs-tip-major">Poznámka: výsledky lze chápat jak
v&nbsp;pozitivním, tak i v&nbsp;negativním smyslu. Pozitivní je, že na základě
výsledků lze prohlásit, že vyhledávání má lineární složitost O(n), nikoli
například O(n<sup>2</sup>) nebo dokonce O(k<sup>n</sup>). Ovšem to je současně
i špatný výsledek, protože u velmi rozsáhlých databází bychom potřebovali
složitost menší (O(log) atd.). Toho je možné částečně dosáhnout prostředky
popsanými příště.</div></p>



<p><a name="k18"></a></p>
<h2 id="k18">18. Obsah navazujícího článku</h2>

<p>Knihovna <i>FAISS</i> není vývojáři oblíbena ani tak kvůli tomu, <i>jaké</i>
operace umí realizovat (ostatně jednoduchý <i>similarity search</i> lze
naprogramovat v&nbsp;řádu minut), ale <i>jak rychle</i> je dokáže provádět.
K&nbsp;dispozici je totiž hned několik algoritmů výpočtů, které se vybírají na
základě velikosti vstupní množiny vektorů, počtu dimenzí vektorů, taktéž na
základě toho, jestli jsou vektory uloženy v&nbsp;operační paměti nebo přesahují
její rozsah atd. Navíc je možné výsledky (tedy nejbližší vektory nalezené na
základě zadané metriky) v&nbsp;případě potřeby pouze &bdquo;odhadovat&ldquo;,
tj.&nbsp;nemusí se nalézt skutečně ty nejbližší vektory, ale vektory dostatečně
blízké. To sice nemusí znít příliš prakticky, ale ve skutečnosti se tyto
algoritmy v&nbsp;praxi poměrně často používají zejména při realizacích RAG
databází. O těchto optimalizacích si řekneme podrobnější informace
v&nbsp;navazujícím článku.</p>



<p><a name="k19"></a></p>
<h2 id="k19">19. Repositář s&nbsp;demonstračními příklady</h2>

<p>Demonstrační příklady vytvořené v&nbsp;Pythonu a popsané v&nbsp;dnešním
článku najdete v&nbsp;repositáři <a
href="https://github.com/tisnik/most-popular-python-libs/">https://github.com/tisnik/most-popular-python-libs/</a>.
Následují odkazy na jednotlivé příklady:</p>

<table>
<tr><th>#</th><th>Příklad</th><th>Stručný popis</th><th>Adresa</th></tr>
<tr><td>1</td><td>faiss-1.py</td><td>seznamy souřadnic bodů v&nbsp;rovině</td><td><a href="https://github.com/tisnik/most-popular-python-libs/blob/master/faiss/faiss-1.py">https://github.com/tisnik/most-popular-python-libs/blob/master/faiss/faiss-1.py</a></td></tr>
<tr><td>2</td><td>faiss-2.py</td><td>konstrukce matice se souřadnicemi bodů</td><td><a href="https://github.com/tisnik/most-popular-python-libs/blob/master/faiss/faiss-2.py">https://github.com/tisnik/most-popular-python-libs/blob/master/faiss/faiss-2.py</a></td></tr>
<tr><td>3</td><td>faiss-3.py</td><td>konstrukce indexu pro vyhledávání na základě vzdálenosti</td><td><a href="https://github.com/tisnik/most-popular-python-libs/blob/master/faiss/faiss-3.py">https://github.com/tisnik/most-popular-python-libs/blob/master/faiss/faiss-3.py</a></td></tr>
<tr><td>4</td><td>faiss-4.py</td><td>nalezení nejbližších bodů k&nbsp;zadaným souřadnicím &ndash; výpis indexů nalezených bodů</td><td><a href="https://github.com/tisnik/most-popular-python-libs/blob/master/faiss/faiss-4.py">https://github.com/tisnik/most-popular-python-libs/blob/master/faiss/faiss-4.py</a></td></tr>
<tr><td>5</td><td>faiss-5.py</td><td>nalezení nejbližších bodů k&nbsp;zadaným souřadnicím &ndash; výpis souřadnic nalezených bodů</td><td><a href="https://github.com/tisnik/most-popular-python-libs/blob/master/faiss/faiss-5.py">https://github.com/tisnik/most-popular-python-libs/blob/master/faiss/faiss-5.py</a></td></tr>
<tr><td>6</td><td>faiss-6.py</td><td>vyhledávání bodů na základě skalárního součinu bez normalizace vektorů</td><td><a href="https://github.com/tisnik/most-popular-python-libs/blob/master/faiss/faiss-6.py">https://github.com/tisnik/most-popular-python-libs/blob/master/faiss/faiss-6.py</a></td></tr>
<tr><td>7</td><td>faiss-7.py</td><td>vyhledávání bodů na základě skalárního součinu s&nbsp;normalizací vektorů</td><td><a href="https://github.com/tisnik/most-popular-python-libs/blob/master/faiss/faiss-7.py">https://github.com/tisnik/most-popular-python-libs/blob/master/faiss/faiss-7.py</a></td></tr>
<tr><td>8</td><td>faiss-8.py</td><td>jednoduchý benchmark rychlosti vyhledávání knihovnou FAISS</td><td><a href="https://github.com/tisnik/most-popular-python-libs/blob/master/faiss/faiss-8.py">https://github.com/tisnik/most-popular-python-libs/blob/master/faiss/faiss-8.py</a></td></tr>
<tr><td>9</td><td>pyproject.toml</td><td>soubor s&nbsp;projektem a definicí závislostí</td><td><a href="https://github.com/tisnik/most-popular-python-libs/blob/master/faiss/pyproject.toml">https://github.com/tisnik/most-popular-python-libs/blob/master/faiss/pyproject.toml</a></td></tr>
</table>



<p><a name="k20"></a></p>
<h2 id="k20">20. Odkazy na Internetu</h2>

<ol>

<li>FAISS (Facebook AI Similarity Search)<br />
<a href="https://en.wikipedia.org/wiki/FAISS">https://en.wikipedia.org/wiki/FAISS</a>
</li>

<li>FAISS documentation<br />
<a href="https://faiss.ai/">https://faiss.ai/</a>
</li>

<li>Introduction to Facebook AI Similarity Search (Faiss)<br />
<a href="https://www.pinecone.io/learn/series/faiss/faiss-tutorial/">https://www.pinecone.io/learn/series/faiss/faiss-tutorial/</a>
</li>

<li>Faiss: Efficient Similarity Search and Clustering of Dense Vectors<br />
<a href="https://medium.com/@pankaj_pandey/faiss-efficient-similarity-search-and-clustering-of-dense-vectors-dace1df1e235">https://medium.com/@pankaj_pandey/faiss-efficient-similarity-search-and-clustering-of-dense-vectors-dace1df1e235</a>
</li>

<li>Top 8 Vector Databases in 2025: Features, Use Cases, and Comparisons<br />
<a href="https://synapsefabric.com/top-8-vector-databases-in-2025-features-use-cases-and-comparisons/">https://synapsefabric.com/top-8-vector-databases-in-2025-features-use-cases-and-comparisons/</a>
</li>

<li>Is FAISS a Vector Database? Complete Guide<br />
<a href="https://mljourney.com/is-faiss-a-vector-database-complete-guide/">https://mljourney.com/is-faiss-a-vector-database-complete-guide/</a>
</li>

<li>Vector database<br />
<a href="https://en.wikipedia.org/wiki/Vector_database">https://en.wikipedia.org/wiki/Vector_database</a>
</li>

<li>Similarity search<br />
<a href="https://en.wikipedia.org/wiki/Similarity_search">https://en.wikipedia.org/wiki/Similarity_search</a>
</li>

<li>Nearest neighbor search<br />
<a href="https://en.wikipedia.org/wiki/Nearest_neighbor_search#Approximation_methods">https://en.wikipedia.org/wiki/Nearest_neighbor_search#Approximation_methods</a>
</li>

<li>Decoding Similarity Search with FAISS: A Practical Approach<br />
<a href="https://www.luminis.eu/blog/decoding-similarity-search-with-faiss-a-practical-approach/">https://www.luminis.eu/blog/decoding-similarity-search-with-faiss-a-practical-approach/</a>
</li>

<li>MetricType and distances<br />
<a href="https://github.com/facebookresearch/faiss/wiki/MetricType-and-distances">https://github.com/facebookresearch/faiss/wiki/MetricType-and-distances</a>
</li>

<li>RAG - Retrieval-augmented generation<br />
<a href="https://en.wikipedia.org/wiki/Retrieval-augmented_generation">https://en.wikipedia.org/wiki/Retrieval-augmented_generation</a>
</li>

<li>pgvector na GitHubu<br />
<a href="https://github.com/pgvector/pgvector">https://github.com/pgvector/pgvector</a>
</li>

<li>Why we replaced Pinecone with PGVector<br />
<a href="https://www.confident-ai.com/blog/why-we-replaced-pinecone-with-pgvector">https://www.confident-ai.com/blog/why-we-replaced-pinecone-with-pgvector</a>
</li>

<li>PostgreSQL as VectorDB - Beginner Tutorial<br />
<a href="https://www.youtube.com/watch?v=Ff3tJ4pJEa4">https://www.youtube.com/watch?v=Ff3tJ4pJEa4</a>
</li>

<li>What is a Vector Database? (neobsahuje odpověď na otázku v titulku :-)<br />
<a href="https://www.youtube.com/watch?v=t9IDoenf-lo">https://www.youtube.com/watch?v=t9IDoenf-lo</a>
</li>

<li>PGVector: Turn PostgreSQL Into A Vector Database<br />
<a href="https://www.youtube.com/watch?v=j1QcPSLj7u0">https://www.youtube.com/watch?v=j1QcPSLj7u0</a>
</li>

<li>Milvus<br />
<a href="https://milvus.io/">https://milvus.io/</a>
</li>

<li>Vector Databases simply explained! (Embeddings &amp; Indexes)<br />
<a href="https://www.youtube.com/watch?v=dN0lsF2cvm4">https://www.youtube.com/watch?v=dN0lsF2cvm4</a>
</li>

<li>Vector databases are so hot right now. WTF are they?<br />
<a href="https://www.youtube.com/watch?v=klTvEwg3oJ4">https://www.youtube.com/watch?v=klTvEwg3oJ4</a>
</li>

<li>Step-by-Step Guide to Installing “pgvector” and Loading Data in PostgreSQL<br />
<a href="https://medium.com/@besttechreads/step-by-step-guide-to-installing-pgvector-and-loading-data-in-postgresql-f2cffb5dec43">https://medium.com/@besttechreads/step-by-step-guide-to-installing-pgvector-and-loading-data-in-postgresql-f2cffb5dec43</a>
</li>

<li>Best 17 Vector Databases for 2025<br />
<a href="https://lakefs.io/blog/12-vector-databases-2023/">https://lakefs.io/blog/12-vector-databases-2023/</a>
</li>

<li>Top 15 Vector Databases that You Must Try in 2025<br />
<a href="https://www.geeksforgeeks.org/top-vector-databases/">https://www.geeksforgeeks.org/top-vector-databases/</a>
</li>

<li>Picking a vector database: a comparison and guide for 2023<br />
<a href="https://benchmark.vectorview.ai/vectordbs.html">https://benchmark.vectorview.ai/vectordbs.html</a>
</li>

<li>Top 9 Vector Databases as of Feburary 2025<br />
<a href="https://www.shakudo.io/blog/top-9-vector-databases">https://www.shakudo.io/blog/top-9-vector-databases</a>
</li>

<li>What is a vector database?<br />
<a href="https://www.ibm.com/think/topics/vector-database">https://www.ibm.com/think/topics/vector-database</a>
</li>

<li>SQL injection<br />
<a href="https://en.wikipedia.org/wiki/SQL_injection">https://en.wikipedia.org/wiki/SQL_injection</a>
</li>

<li>Cosine similarity<br />
<a href="https://en.wikipedia.org/wiki/Cosine_similarity">https://en.wikipedia.org/wiki/Cosine_similarity</a>
</li>

<li>Euclidean distance<br />
<a href="https://en.wikipedia.org/wiki/Euclidean_distance">https://en.wikipedia.org/wiki/Euclidean_distance</a>
</li>

<li>Dot product<br />
<a href="https://en.wikipedia.org/wiki/Dot_product">https://en.wikipedia.org/wiki/Dot_product</a>
</li>

<li>Hammingova vzdálenost<br />
<a href="https://cs.wikipedia.org/wiki/Hammingova_vzd%C3%A1lenost">https://cs.wikipedia.org/wiki/Hammingova_vzd%C3%A1lenost</a>
</li>

<li>Jaccard index<br />
<a href="https://en.wikipedia.org/wiki/Jaccard_index">https://en.wikipedia.org/wiki/Jaccard_index</a>
</li>

<li>Manhattanská metrika<br />
<a href="https://cs.wikipedia.org/wiki/Manhattansk%C3%A1_metrika">https://cs.wikipedia.org/wiki/Manhattansk%C3%A1_metrika</a>
</li>

<li>pgvector: vektorová databáze postavená na Postgresu<br />
<a href="https://www.root.cz/clanky/pgvector-vektorova-databaze-postavena-na-postgresu/">https://www.root.cz/clanky/pgvector-vektorova-databaze-postavena-na-postgresu/</a>
</li>

</ol>



<p></p><p></p>
<p><small>Autor: <a href="https://github.com/tisnik/">Pavel Tišnovský</a> &nbsp; 2025</small></p>
</body>
</html>

