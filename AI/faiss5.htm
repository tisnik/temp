<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
        "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html>
<head>
<title>Knihovna FAISS a embedding: základ jazykových modelů (3. část - role indexů)</title>
<meta name="Author" content="Pavel Tisnovsky" />
<meta name="Generator" content="vim" />
<meta http-equiv="content-type" content="text/html; charset=utf-8" />
<style type="text/css">
         body {color:#000000; background:#ffffff;}
         h1  {font-family: arial, helvetica, sans-serif; color:#ffffff; background-color:#c00000; text-align:center; padding-left:1em}
         h2  {font-family: arial, helvetica, sans-serif; color:#ffffff; background-color:#0000c0; padding-left:1em; text-align:left}
         h3  {font-family: arial, helvetica, sans-serif; color:#000000; background-color:#c0c0c0; padding-left:1em; text-align:left}
         h4  {font-family: arial, helvetica, sans-serif; color:#000000; background-color:#e0e0e0; padding-left:1em; text-align:left}
         a   {font-family: arial, helvetica, sans-serif;}
         li  {font-family: arial, helvetica, sans-serif; color:#000000; text-align:justify; width:450px;}
         ol  {font-family: arial, helvetica, sans-serif; color:#000000; text-align:justify; width:450px;}
         ul  {font-family: arial, helvetica, sans-serif; color:#000000; text-align:justify; width:450px;}
         p   {font-family: arial, helvetica, sans-serif; color:#000000; text-align:justify;}
         pre {background:#e0e0e0}
</style>
</head>

<body>

<h1>Knihovna FAISS a embedding: základ jazykových modelů (3. část - role indexů)</h1>

<h3>Pavel Tišnovský</h3>

<p></p>

<h1>Úvodník</h1>

<p>Důležitou součástí knihovny FAISS je relativně široká nabídka různých indexů. Kromě interně značně jednoduchých až naivních &bdquo;lineárních&ldquo; indexů existují indexy založené na rozdělení prostoru Voroného dekompozicí či index HNSW: Hierarchical Navigable Small World.</p>



<h2>Obsah</h2>

<p><a href="#k01">1. Knihovna FAISS a embedding: základ jazykových modelů (3. část &ndash; role indexů)</a></p>
<p><a href="#k02">2. Časová složitost vyhledávání při použití výchozího indexu FlatL2</a></p>
<p><a href="#k03">3. Benchmark: zjištění časové složitosti vyhledávání při použití výchozího indexu FlatL2</a></p>
<p><a href="#k04">4. Výsledky prvního benchmarku</a></p>
<p><a href="#k05">5. Vliv rychlosti vyhledávání na počtu prvků (dimenzi) vektorů</a></p>
<p><a href="#k06">6. Výsledky druhého benchmarku</a></p>
<p><a href="#k07">7. Dimenze vektorů vs.&nbsp;jejich počet</a></p>
<p><a href="#k08">8. Benchmarky měřící rychlosti vyhledání nejpodobnějších vektorů v&nbsp;sadě s&nbsp;proměnným počtem vektorů i proměnným počtem dimenzí</a></p>
<p><a href="#k09">9. Výsledky třetího a čtvrtého benchmarku: lineární a logaritmická stupnice</a></p>
<p><a href="#k10">10. Indexy založené na použití sofistikovanějších datových struktur</a></p>
<p><a href="#k11">11. Rozdělení celého prostoru Voroného dekompozicí</a></p>
<p><a href="#k12">12. Konstrukce indexu <strong>IVFFlat</strong></a></p>
<p><a href="#k13">13. Benchmark: časy vyhledávání nejpodobnějších vektorů s&nbsp;využitím indexu FlatL2</a></p>
<p><a href="#k14">14. Výsledky pátého benchmarku</a></p>
<p><a href="#k15">15. Benchmark: modifikace počtu buněk při konstrukci indexu FlatL2</a></p>
<p><a href="#k16">16. Výsledky šestého benchmarku</a></p>
<p><a href="#k17">17. Index <i>HNSW</i> (Hierarchical Navigable Small World)</a></p>
<p><a href="#k18">18. Výsledky sedmého benchmarku</a></p>
<p><a href="#k19">19. Repositář s&nbsp;demonstračními příklady</a></p>
<p><a href="#k20">20. Odkazy na Internetu</a></p>



<p><a name="k01"></a></p>
<h2 id="k01">1. Knihovna FAISS a embedding: základ jazykových modelů (3. část &ndash; role indexů)</h2>

<p>V&nbsp;předchozích článcích o knihovně FAISS jsme používali dva typy indexů.
První z&nbsp;těchto indexů je založen na výpočtu Eukleidovské vzdálenosti
vektorů &ndash; jeho cílem je nalézt <i>k</i> vektorů, které se nejvíce
podobají vstupnímu vzorku. Druhý index je založen na výpočtu skalárního
součinu, protože u normalizovaných vektorů platí, že jejich skalární součin
odpovídá míře jejich podobnosti. Tyto dva typy indexů ve své základní podobě
mají jména <strong>IndexFlatL2</strong> a <strong>IndexFlatIP</strong>. Jejich
výhodou je jednoduchá implementace i absolutní přesnost výsledků &ndash;
skutečně se vždy vrátí <i>k</i> nejpodobnějších vektorů. Nevýhodou je obecně
lineární časová složitost, což začne být problematické v&nbsp;případě, že se
pracuje s&nbsp;modely, které obsahují jednotky, desítky či dokonce stovky
milionů vektorů.</p>

<p>Právě lineární časová složitost (resp.&nbsp;v&nbsp;těchto případech i její
&bdquo;strmost&ldquo;) vedla k&nbsp;tomu, že do knihovny FAISS byly přidány i
další typy indexů. Některé z&nbsp;nich nemusí být zcela přesné, tj.&nbsp;indexy
sice vrací požadovaných <i>k</i> vektorů, ovšem nemusí se jednat o
nejpodobnější vektory. Pro potřeby jazykových modelů je však určitá nepřesnost
akceptovatelná a někdy i vítaná.</p>

<p>Mezi indexy podporované knihovnou FAISS patří například:</p>

<table>
<tr><th></th><th>Factory</th></tr>
<tr><td>IndexFlatL2</td><td>"Flat"</td></tr>
<tr><td>IndexFlatIP</td><td>"Flat"</td></tr>
<tr><td>IndexHNSWFlat</td><td>"HNSW,Flat"</td></tr>
<tr><td>IndexIVFFlat</td><td>"IVFx,Flat"</td></tr>
<tr><td>IndexLSH</td><td>&times;</td></tr>
<tr><td>IndexScalarQuantizer</td><td>"SQ8"</td></tr>
<tr><td>IndexPQ</td><td>"PQx", "PQ"M"x"nbits</td></tr>
<tr><td>IndexIVFScalarQuantizer</td><td>"IVFx,SQ4" "IVFx,SQ8"</td></tr>
<tr><td>IndexIVFPQ</td><td>"IVFx,PQ"y"x"nbits</td></tr>
<tr><td>IndexIVFPQR</td><td>"IVFx,PQy+z"</td></tr>
</table>



<p><a name="k02"></a></p>
<h2 id="k02">2. Časová složitost vyhledávání při použití výchozího indexu FlatL2</h2>

<p>Nejprve si ověříme časovou složitost (konkrétně závislost času vyhledání na
počtu uložených vektorů) indexu <strong>IndexFlatL2</strong>. Prvky vektorů
budou datového typu <strong>float32</strong>, což sice znamená relativně velké
nároky na operační paměť, ovšem samotné výpočty (na CPU!) jsou poměrně rychlé,
protože lze využít instrukční sady SSEx či AVX.</p>

<p><div class="rs-tip-major">Poznámka: všechny tři první benchmarky,
s&nbsp;nimiž se v&nbsp;dnešním článku seznámíme, skutečně používají ten
nejjednodušší možný index nazvaný <strong>IndexFlatL2</strong>. Podobných
výsledků (stejná časová složitost atd.) dosáhneme při použití indexu
<strong>IndexFlatIP</strong>. I když se u těchto indexů používají odlišné
výpočty pro zjištění podobnosti vektorů, způsob samotného výběru vektorů je
stále stejný &ndash; lineárně se prochází celou datovou sadou. Až ve druhé
části článku se seznámíme s&nbsp;indexy založenými na sofistikovanějších
datových strukturách, které umožňují rychlejší, ovšem (obecně) ne tak přesné
vyhledávání.</div></p>

<p>Jednoduchý benchmark, který slouží pro změření časové složitosti
vyhledávání, jsme si již ukázali v&nbsp;předchozích článcích o knihovně FAISS.
Ovšem aby byly výsledky měření přesnější, musíme celý benchmark nepatrně
upravit. V&nbsp;benchmarku se provádí následující operace:</p>

<ol>

<li>Vytvoření matice obsahující zvolený počet vektorů s&nbsp;předem známou
dimenzí (počtem prvků).</li>

<li>Konstrukce indexu (L2) z&nbsp;této matice.</li>

<li>Opakované vyhledání <i>k</i> nejpodobnějších vektorů k&nbsp;náhodně
zvolenému vektoru. Čím větší bude počet opakování tohoto kroku, tím přesnější
budou výsledky benchmarku.</li>

<li>Vykreslení závislosti času vyhledávání (předchozí bod) na celkovém počtu
vektorů <i>n</i>.</li>

</ol>

<p><div class="rs-tip-major">Poznámka: pro spouštění všech benchmarků bude
použit nástroj <strong>uv</strong> nebo <strong>pdm</strong>. Soubor
<strong>pyproject.toml</strong> obsahující definici projektu, vypadá následovně
(důležitý je zde hlavně seznam knihoven, na nichž projekt závisí):</div></p>

<pre>
[project]
name = "faiss-1"
version = "0.1.0"
description = "Default template for PDM package"
authors = [
    {name = "Pavel Tisnovsky", email = "ptisnovs@redhat.com"},
]
dependencies = [
 "faiss-cpu&gt;=1.11.0",
 "matplotlib&gt;=3.10.3",
 "numpy&gt;=2.3.1",
]
requires-python = "==3.12.*"
readme = "README.md"
license = {text = "MIT"}
&nbsp;
&nbsp;
[tool.pdm]
distribution = false
</pre>



<p><a name="k03"></a></p>
<h2 id="k03">3. Benchmark: zjištění časové složitosti vyhledávání při použití výchozího indexu FlatL2</h2>

<p>V&nbsp;první verzi benchmarku je dimenze vektorů (počet prvků) specifikován
konstantou <strong>DIMENSIONS</strong> (která se pochopitelně nemění). Počet
opakování vyhledání náhodného vektoru je uložen v&nbsp;konstantě
<strong>REP_COUNT</strong>. Čím větší je hodnota této konstanty, tím pomalejší
bude benchmark, ovšem tím více se omezí náhodné vlivy.</p>

<p>Úplný zdrojový kód dnešního prvního benchmarku vypadá následovně:</p>

<pre>
<i># Knihovna FAISS</i>
<i>#</i>
<i># - benchmark rychlosti nalezení nejpodobnějších vektorů</i>
<i># - výpis výsledků v tabulkové formě</i>
<i># - vizualizace výsledků formou grafu</i>
&nbsp;
from time import time
import faiss
import numpy as np
&nbsp;
import matplotlib.pyplot as plt
&nbsp;
&nbsp;
def <strong>similarity_search</strong>(n, k):
    <i>"""Nalezeni k nejblizsich vektoru v mnozine n vektoru."""</i>
    <i># pocet slozek vektoru</i>
    DIMENSIONS=128
&nbsp;
    t1 = time()
&nbsp;
    <i># nahodne vektory</i>
    data = np.random.rand(n, 128).astype('float32')
&nbsp;
    t2 = time()
&nbsp;
    <i># konstrukce indexu pro vyhledavani na zaklade vzdalenosti</i>
    index = faiss.IndexFlatL2(DIMENSIONS)
    index.add(data)
&nbsp;
    t3 = time()
    REP_COUNT = 20
&nbsp;
    <i># opakovane mereni rychlosti nalezeni nejpodobnejsich vektoru</i>
    for _ in range(REP_COUNT):
        <i># vektor, ke kteremu budeme pocitat vzdalenost</i>
        query_vector = np.random.rand(1, DIMENSIONS).astype("float32")
&nbsp;
        <i># pocet nejblizsich bodu</i>
        distances, indices = index.search(query_vector, k)
&nbsp;
        <i># test, kolik vektoru se nalezlo</i>
        assert len(distances) == k
        assert len(indices) == k
&nbsp;
    t4 = time()
&nbsp;
    return n, t2-t1, t3-t2, (t4-t3)/REP_COUNT
&nbsp;
&nbsp;
ns = []
ts_search = []
&nbsp;
for n in np.linspace(0, 1000000, 11):
    print(n)
    n, t_rand, t_index, t_search = similarity_search(int(n), 1)
    ns.append(n)
    ts_search.append(t_search)
&nbsp;
&nbsp;
plt.xlabel("# vectors")
plt.ylabel("Time/sec")
plt.plot(ns, ts_search, "m-", label="similarity search")
&nbsp;
<i># přidání legendy</i>
plt.legend(loc="upper left")
&nbsp;
<i># povolení zobrazení mřížky</i>
plt.grid(True)
&nbsp;
plt.savefig("faiss_benchmark_1.png")
&nbsp;
<i># zobrazení grafu</i>
plt.show()
</pre>



<p><a name="k04"></a></p>
<h2 id="k04">4. Výsledky prvního benchmarku</h2>

<p>Výsledky benchmarku popsaného <a href="#k03">v&nbsp;předchozí kapitole</a>
vypadají následovně:</p>

<div class="rs-img-center" style="margin-left: auto; margin-right: auto; max-width: 640px"><a href="https://www.root.cz/obrazek/1218213/"><img src="https://i.iinfo.cz/images/304/faiss-benchmarks-1.png" class="image-1218213" width="640" height="480" data-prev-filename="https://i.iinfo.cz/images/304/faiss-benchmarks-1-prev.png" data-prev-filename-webp="https://i.iinfo.cz/images/304/faiss-benchmarks-1-prev.webp" data-prev-width="360" data-prev-height="270" data-large-filename="https://i.iinfo.cz/images/304/faiss-benchmarks-1.png" data-large-filename-webp="https://i.iinfo.cz/images/304/faiss-benchmarks-1.webp" data-large-width="640" data-large-height="480" alt="Výsledky benchmarku" data-description="Výsledky benchmarku" title="Autor: tisnik, podle licence: &lt;a href=&quot;http://en.wikipedia.org/wiki/Rights_Managed&quot;&gt;Rights Managed&lt;/a&gt;" style="width: 100%; height: auto; max-width: 640px" /></a><p>Obrázek 1: Výsledky benchmarku při použití standardního indexu FlatL2 pro proměnný počet vektorů<br class="_remove" /></p><p class="author">Autor: tisnik, podle licence: <a href="http://en.wikipedia.org/wiki/Rights_Managed">Rights Managed</a><br class="_remove" /></p></div>

<p><div class="rs-tip-major">Poznámka: ze změřeného a zobrazeného průběhu je
poměrně dobře patrná lineární časová složitost vyhledávacího algoritmu,
minimálně pro zvolený rozsah 0 až jeden milion vektorů v&nbsp;datové sadě.
Větší datová sada již vyžaduje velký objem operační paměti a (minimálně na mém
stroji) by se již negativně projevilo swapování.</div></p>



<p><a name="k05"></a></p>
<h2 id="k05">5. Vliv rychlosti vyhledávání na počtu prvků (dimenzi) vektorů</h2>

<p>V&nbsp;prvním benchmarku, jehož výsledky jsme si právě ukázali, jsme měnili
pouze počet vektorů uložených do indexu a měřili jsme čas vyhledání
nejpodobnějších vektorů. Ovšem jaký vliv má na rychlost vyhledávání počet prvků
vektorů, tj.&nbsp;jejich dimenze? Pro zjištění podobnosti vektorů se používá
klasická metrika L<sup>2</sup>, tj.&nbsp;výpočet Eukleidovské vzdálenosti
v&nbsp;n-dimenzionálním prostoru. Tento výpočet je založen na zobecněné
Pythagorově větě (sčítají se druhé mocniny rozdílů odpovídajících si prvků,
teoreticky se ještě výsledek odmocní, ale to již nehraje podstatnou roli). A
pochopitelně s&nbsp;rostoucím počtem dimenzí roste i počet operací.</p>

<p>Benchmark upravíme tak, že počet vektorů bude konstantní, ale bude se měnit
jejich dimenze v&nbsp;rozsahu 0 až 4000 (některé embedding modely se hodnotě
4000 skutečně přibližují):</p>

<pre>
<i># Knihovna FAISS</i>
<i>#</i>
<i># - benchmark rychlosti nalezení nejpodobnějších vektorů</i>
<i># - je použit index FlatL2</i>
<i># - postupně se zvyšuje počet dimenzí vektorů</i>
<i># - délka vektorů zůstává konstantní</i>
<i># - vizualizace výsledků formou grafu</i>
&nbsp;
from time import time
import faiss
import numpy as np
&nbsp;
import matplotlib.pyplot as plt
&nbsp;
&nbsp;
def <strong>similarity_search</strong>(dimensions, n, k):
    <i>"""Nalezeni k nejblizsich vektoru v mnozine n vektoru."""</i>
    t1 = time()
&nbsp;
    <i># nahodne vektory</i>
    data = np.random.rand(n, dimensions).astype('float32')
&nbsp;
    t2 = time()
&nbsp;
    <i># konstrukce indexu pro vyhledavani na zaklade vzdalenosti</i>
    index = faiss.IndexFlatL2(dimensions)
    index.add(data)
&nbsp;
    t3 = time()
    REP_COUNT = 20
&nbsp;
    for _ in range(REP_COUNT):
        <i># vektor, ke kteremu budeme pocitat vzdalenost</i>
        query_vector = np.random.rand(1, dimensions).astype("float32")
&nbsp;
        <i># pocet nejblizsich bodu</i>
        distances, indices = index.search(query_vector, k)
&nbsp;
        <i># test, kolik vektoru se nalezlo</i>
        assert len(distances) == k
        assert len(indices) == k
&nbsp;
    t4 = time()
&nbsp;
    return n, t2-t1, t3-t2, (t4-t3)/REP_COUNT
&nbsp;
&nbsp;
ns = []
ts_search = []
&nbsp;
for dimensions in np.linspace(0, 4000, 11):
    n = 100000
    print(dimensions, n)
    n, t_rand, t_index, t_search = similarity_search(int(dimensions), n, 1)
    ns.append(dimensions)
    ts_search.append(t_search)
&nbsp;
&nbsp;
plt.xlabel("# dimensions")
plt.ylabel("Time/sec")
plt.plot(ns, ts_search, "m-", label="similarity search")
&nbsp;
<i># přidání legendy</i>
plt.legend(loc="upper left")
&nbsp;
<i># povolení zobrazení mřížky</i>
plt.grid(True)
&nbsp;
plt.savefig("faiss_benchmark_2.png")
&nbsp;
<i># zobrazení grafu</i>
plt.show()
</pre>



<p><a name="k06"></a></p>
<h2 id="k06">6. Výsledky druhého benchmarku</h2>

<p>I ze změřených výsledků druhého benchmarku vyplývá (v&nbsp;souladu
s&nbsp;teorií), že vyhledání nejpodobnějších vektorů má lineární časovou
složitost, tentokrát ovšem s&nbsp;ohledem na počtu prvků vektorů. To by nemělo
být příliš překvapivé zjištění, ovšem naznačuje, že se (pravděpodobně) interně
neprovádí žádné sofistikované optimalizace:</p>

<div class="rs-img-center" style="margin-left: auto; margin-right: auto; max-width: 640px"><a href="https://www.root.cz/obrazek/1218216/"><img src="https://i.iinfo.cz/images/304/faiss-benchmarks-2.png" class="image-1218216" width="640" height="480" data-prev-filename="https://i.iinfo.cz/images/304/faiss-benchmarks-2-prev.png" data-prev-filename-webp="https://i.iinfo.cz/images/304/faiss-benchmarks-2-prev.webp" data-prev-width="360" data-prev-height="270" data-large-filename="https://i.iinfo.cz/images/304/faiss-benchmarks-2.png" data-large-filename-webp="https://i.iinfo.cz/images/304/faiss-benchmarks-2.webp" data-large-width="640" data-large-height="480" alt="Výsledky benchmarku" data-description="Výsledky benchmarku" title="Autor: tisnik, podle licence: &lt;a href=&quot;http://en.wikipedia.org/wiki/Rights_Managed&quot;&gt;Rights Managed&lt;/a&gt;" style="width: 100%; height: auto; max-width: 640px" /></a><p>Obrázek 2: Výsledky benchmarku při použití standardního indexu FlatL2 pro proměnný počet dimenzí<br class="_remove" /></p><p class="author">Autor: tisnik, podle licence: <a href="http://en.wikipedia.org/wiki/Rights_Managed">Rights Managed</a><br class="_remove" /></p></div>



<p><a name="k07"></a></p>
<h2 id="k07">7. Dimenze vektorů vs.&nbsp;jejich počet</h2>

<p>Při tréninku embedded modelů je nutné volit vhodný počet dimenzí, který do
jisté míry souvisí i s&nbsp;celkovým počtem vektorů (tj.&nbsp;počtem textů/vět,
které jsou daným modelem reprezentovány). Dimenze vektorů se většinou pohybuje
v&nbsp;rozsahu 256 až 4096 (což už jsou specializované případy); typická
hodnota dimenze je 384, 512 nebo 768. A celkový počet vektorů se pohybuje od
několika set tisíc (modely pro konkrétní malou oblast) až do stovek milionů
(obecné embedded modely).</p>

<p>Paměťové nároky se (pro přímé indexy) počítají jednoduše:<br />
<i>dimenze &times; počet vektorů &times; velikost prvku (bit, byte, float16, float32)</i></p>

<p>To tedy vlastně znamená, že pokud zachováme konstantní hodnotu <i>dimenze
&times; počet vektorů</i>, můžeme zjistit, která z&nbsp;těchto hodnot má větší
vliv na rychlost vyhledávání &ndash; zda je to dimenze (vyšší dimenze =
složitější početní operace, například více výpočtů čtverce rozdílů prvků
vektorů a více součtů) nebo počet vektorů (vyšší počet = vyšší počet výpočtů).
To si ověříme v&nbsp;benchmarku, který je uveden v&nbsp;navazující
kapitole.</p>



<p><a name="k08"></a></p>
<h2 id="k08">8. Benchmarky měřící rychlosti vyhledání nejpodobnějších vektorů v&nbsp;sadě s&nbsp;proměnným počtem vektorů i proměnným počtem dimenzí</h2>

<p>Dva benchmarky, které jsou popsány v&nbsp;této kapitole, měří rychlost
vyhledání nejpodobnějších vektorů v&nbsp;datové sadě s&nbsp;proměnným počtem
vektorů <i>n</i>, která navíc mají proměnný počet dimenzí <i>dimensions</i>.
Počet dimenzí roste s&nbsp;mocninou dvojky a počet vektorů je odvozen ze vztahu
<i>65536*64 // dimensions</i>. To tedy znamená, že celkový počet prvků zůstává
konstantní: <i>n&times;dimensions=65536*64=4194304</i> (to je dostatečně malý
počet, aby se nepřesáhla dostupná kapacita operační paměti).</p>

<p>Oba parametry vstupující do benchmarků se vypočítají takto:</p>

<pre>
for d in range(0, 14):
    dimensions = 2**d
    n = 65536*64 // dimensions
</pre>

<p>A proč jsou vytvořeny benchmarky dva? Samotné měření zůstává naprosto
stejné, ovšem první benchmark vykreslí grafy s&nbsp;využitím lineární
stupnice/měřítka a druhý benchmark použije logaritmické měřítko (důvod uvidíme
v&nbsp;další kapitole). Jinak se tyto dva benchmarky nijak neliší:</p>

<pre>
<i># Knihovna FAISS</i>
<i>#</i>
<i># - benchmark rychlosti nalezení nejpodobnějších vektorů</i>
<i># - je použit index FlatL2</i>
<i># - výpis výsledků v tabulkové formě</i>
<i># - postupně se zvyšuje počet dimenzí vektorů</i>
<i># - délka vektorů se zmenšuje s rostoucím počtem dimenzí vektorů</i>
<i># - vizualizace výsledků formou grafu</i>
&nbsp;
from time import time
import faiss
import numpy as np
&nbsp;
import matplotlib.pyplot as plt
&nbsp;
&nbsp;
def <strong>similarity_search</strong>(dimensions, n, k):
    <i>"""Nalezeni k nejblizsich vektoru v mnozine n vektoru."""</i>
    t1 = time()
&nbsp;
    <i># nahodne vektory</i>
    data = np.random.rand(n, dimensions).astype('float32')
&nbsp;
    t2 = time()
&nbsp;
    <i># konstrukce indexu pro vyhledavani na zaklade vzdalenosti</i>
    index = faiss.IndexFlatL2(dimensions)
    index.add(data)
&nbsp;
    t3 = time()
    REP_COUNT = 20
&nbsp;
    for _ in range(REP_COUNT):
        <i># vektor, ke kteremu budeme pocitat vzdalenost</i>
        query_vector = np.random.rand(1, dimensions).astype("float32")
&nbsp;
        <i># pocet nejblizsich bodu</i>
        distances, indices = index.search(query_vector, k)
&nbsp;
        <i># test, kolik vektoru se nalezlo</i>
        assert len(distances) == k
        assert len(indices) == k
&nbsp;
    t4 = time()
&nbsp;
    return n, t2-t1, t3-t2, (t4-t3)/REP_COUNT
&nbsp;
&nbsp;
ns = []
ts_search = []
&nbsp;
for d in range(0, 14):
    dimensions = 2**d
    n = 65536*64 // dimensions
    print(dimensions, n)
    n, t_rand, t_index, t_search = similarity_search(dimensions, n, 1)
    ns.append(dimensions)
    ts_search.append(t_search)
&nbsp;
&nbsp;
plt.xlabel("# dimensions")
plt.ylabel("Time/sec")
plt.plot(ns, ts_search, "m-", label="similarity search")
&nbsp;
<i># přidání legendy</i>
plt.legend(loc="upper left")
&nbsp;
<i># povolení zobrazení mřížky</i>
plt.grid(True)
&nbsp;
plt.savefig("faiss_benchmark_3.png")
&nbsp;
<i># zobrazení grafu</i>
plt.show()
</pre>

<pre>
<i># Knihovna FAISS</i>
<i>#</i>
<i># - benchmark rychlosti nalezení nejpodobnějších vektorů</i>
<i># - je použit index FlatL2</i>
<i># - výpis výsledků v tabulkové formě</i>
<i># - postupně se zvyšuje počet dimenzí vektorů</i>
<i># - délka vektorů se zmenšuje s rostoucím počtem dimenzí vektorů</i>
<i># - vizualizace výsledků formou grafu (logaritmické měřítko)</i>
&nbsp;
from time import time
import faiss
import numpy as np
&nbsp;
import matplotlib.pyplot as plt
&nbsp;
&nbsp;
def <strong>similarity_search</strong>(dimensions, n, k):
    <i>"""Nalezeni k nejblizsich vektoru v mnozine n vektoru."""</i>
    t1 = time()
&nbsp;
    <i># nahodne vektory</i>
    data = np.random.rand(n, dimensions).astype('float32')
&nbsp;
    t2 = time()
&nbsp;
    <i># konstrukce indexu pro vyhledavani na zaklade vzdalenosti</i>
    index = faiss.IndexFlatL2(dimensions)
    index.add(data)
&nbsp;
    t3 = time()
    REP_COUNT = 20
&nbsp;
    for _ in range(REP_COUNT):
        <i># vektor, ke kteremu budeme pocitat vzdalenost</i>
        query_vector = np.random.rand(1, dimensions).astype("float32")
&nbsp;
        <i># pocet nejblizsich bodu</i>
        distances, indices = index.search(query_vector, k)
&nbsp;
        <i># test, kolik vektoru se nalezlo</i>
        assert len(distances) == k
        assert len(indices) == k
&nbsp;
    t4 = time()
&nbsp;
    return n, t2-t1, t3-t2, (t4-t3)/REP_COUNT
&nbsp;
&nbsp;
ns = []
ts_search = []
&nbsp;
for d in range(0, 14):
    dimensions = 2**d
    n = 65536*64 // dimensions
    print(dimensions, n)
    n, t_rand, t_index, t_search = similarity_search(dimensions, n, 1)
    ns.append(dimensions)
    ts_search.append(t_search)
&nbsp;
&nbsp;
plt.xlabel("# dimensions")
plt.ylabel("Time/sec")
plt.semilogy(ns, ts_search, "m-", label="similarity search")
&nbsp;
<i># přidání legendy</i>
plt.legend(loc="upper left")
&nbsp;
<i># povolení zobrazení mřížky</i>
plt.grid(True)
&nbsp;
plt.savefig("faiss_benchmark_4.png")
&nbsp;
<i># zobrazení grafu</i>
plt.show()
</pre>



<p><a name="k09"></a></p>
<h2 id="k09">9. Výsledky třetího a čtvrtého benchmarku: lineární a logaritmická stupnice</h2>

<p>Z&nbsp;výsledků třetího benchmarku by se mohlo zdát, že pokud budeme
ignorovat situaci s&nbsp;nejmenší dimenzí vektorů (a tím pádem s&nbsp;jejich
největším počtem), bude čas pro nalezení <i>k</i> nejpodobnějších vektorů
konstantní &ndash; neboli že pokud je <i>celkový</i> počet prvků konstantní,
bude stejný i čas hledání:</p>

<div class="rs-img-center" style="margin-left: auto; margin-right: auto; max-width: 640px"><a href="https://www.root.cz/obrazek/1218219/"><img src="https://i.iinfo.cz/images/304/faiss-benchmarks-3.png" class="image-1218219" width="640" height="480" data-prev-filename="https://i.iinfo.cz/images/304/faiss-benchmarks-3-prev.png" data-prev-filename-webp="https://i.iinfo.cz/images/304/faiss-benchmarks-3-prev.webp" data-prev-width="360" data-prev-height="270" data-large-filename="https://i.iinfo.cz/images/304/faiss-benchmarks-3.png" data-large-filename-webp="https://i.iinfo.cz/images/304/faiss-benchmarks-3.webp" data-large-width="640" data-large-height="480" alt="Výsledky benchmarku" data-description="Výsledky benchmarku" title="Autor: tisnik, podle licence: &lt;a href=&quot;http://en.wikipedia.org/wiki/Rights_Managed&quot;&gt;Rights Managed&lt;/a&gt;" style="width: 100%; height: auto; max-width: 640px" /></a><p>Obrázek 3: Výsledky benchmarku &ndash; proměnný počet vektorů i počet dimenzí (lineární stupnice)<br class="_remove" /></p><p class="author">Autor: tisnik, podle licence: <a href="http://en.wikipedia.org/wiki/Rights_Managed">Rights Managed</a><br class="_remove" /></p></div>

<p>Ve skutečnosti je však situace odlišná od předchozího popisu, protože
s&nbsp;rostoucím počtem dimenzí (a proporcionálně se snižujícím počtem vektorů)
čas vyhledání nejpodobnějších vektorů roste. To odhalíme použitím
logaritmického měřítka na vertikální ose, což bylo realizováno ve čtvrtém
benchmarku. Jeho výsledky vypadají následovně:</p>

<div class="rs-img-center" style="margin-left: auto; margin-right: auto; max-width: 640px"><a href="https://www.root.cz/obrazek/1218222/"><img src="https://i.iinfo.cz/images/304/faiss-benchmarks-4.png" class="image-1218222" width="640" height="480" data-prev-filename="https://i.iinfo.cz/images/304/faiss-benchmarks-4-prev.png" data-prev-filename-webp="https://i.iinfo.cz/images/304/faiss-benchmarks-4-prev.webp" data-prev-width="360" data-prev-height="270" data-large-filename="https://i.iinfo.cz/images/304/faiss-benchmarks-4.png" data-large-filename-webp="https://i.iinfo.cz/images/304/faiss-benchmarks-4.webp" data-large-width="640" data-large-height="480" alt="Výsledky benchmarku" data-description="Výsledky benchmarku" title="Autor: tisnik, podle licence: &lt;a href=&quot;http://en.wikipedia.org/wiki/Rights_Managed&quot;&gt;Rights Managed&lt;/a&gt;" style="width: 100%; height: auto; max-width: 640px" /></a><p>Obrázek 4: Výsledky benchmarku &ndash; proměnný počet vektorů i počet dimenzí (logaritmická stupnice)<br class="_remove" /></p><p class="author">Autor: tisnik, podle licence: <a href="http://en.wikipedia.org/wiki/Rights_Managed">Rights Managed</a><br class="_remove" /></p></div>

<p><div class="rs-tip-major">Poznámka: v&nbsp;případě, že vám na grafu
nevyhovují dlouhé časy pro malý počet dimenzí (= mnoho vektorů), je vhodné
začít až od 128 dimenzí.</div></p>



<p><a name="k10"></a></p>
<h2 id="k10">10. Indexy založené na použití sofistikovanějších datových struktur</h2>

<p>Z&nbsp;předchozích benchmarků je patrné, že čas vyhledání nejpodobnějších
vektorů lineárně roste s&nbsp;jejich rostoucím počtem. Ovšem v&nbsp;jazykových
modelech se setkáme s&nbsp;datovými sadami, které obsahují desítky či dokonce
stovky milionů vektorů, takže (pochopitelně) existuje snaha o snížení času
vyhledávání &ndash; ideálně změnou časové složitosti (z&nbsp;lineární
složitosti k&nbsp;například logaritmické složitosti nebo složitosti
s&nbsp;odmocninou), nebo alespoň sice se zachováním lineární složitosti, ovšem
s&nbsp;jejím menším sklonem (což je ona někdy podceňovaná konstanta <i>k</i> ve
vztahu <i>k O(n)</i>). I v&nbsp;těchto oblastech nám knihovna FAISS nabízí
různá řešení. V&nbsp;rámci dalších kapitol se seznámíme se dvěma různými
technikami, které jsou založeny na použití sofistikovanějších datových
struktur, než jsou pouhé sekvence (tabulky) vektorů.</p>



<p><a name="k11"></a></p>
<h2 id="k11">11. Rozdělení celého prostoru Voroného dekompozicí</h2>

<p>Jeden z&nbsp;dostupných a relativně často používaných algoritmů určených pro
urychlení vyhledávání podobných vektorů spočívá v&nbsp;tom, že se
n-dimenzionální prostor, ve kterém vektory vstupní datové sady leží, rozdělí do
zadaného počtu oblastí. Pro rozdělení se přitom typicky používá Voroného
dekompozice, i když by teoreticky bylo možné použít i další metody (možná
zobecněný oktalový strom?). Algoritmus vyhledávání je v&nbsp;tom nejjednodušším
případě upraven následujícím způsobem:</p>

<ol>
<li>Vstupem je vektor (dotaz) k&nbsp;němuž v&nbsp;datové sadě hledáme nejbližší vektory</li>
<li>Pro tento vstupní vektor je zjištěna oblast (Voroného dekompozice), ve které bude prováděno vyhledávání</li>
<li>Následně jsou nejbližší vektory vyhledávány pouze v&nbsp;této oblasti</li>
</ol>

<p>Problém spočívá v&nbsp;tom, že právě popsaný algoritmus nemusí vyhledat
skutečně nejbližší vektory. To nastane v&nbsp;případě, že se vstupní vektor
nachází blízko hranice oblasti a nejbližší vektor(y) by se tedy nacházel
<i>za</i> touto hranicí. Proto může být algoritmus vyhledávání upraven do
nepatrně odlišné podoby:</p>

<ol>
<li>Vstupem je vektor (dotaz) k&nbsp;němuž v&nbsp;datové sadě hledáme nejbližší vektory</li>
<li>Pro tento vstupní vektor je zjištěna oblast (Voroného dekompozice), ve které bude prováděno vyhledávání</li>
<li>Dále jsou zjištěno <i>m</i> sousedních oblastí k&nbsp;nalezené oblasti (<i>m</i> je konfigurovatelné)</li>
<li>Následně jsou nejbližší vektory vyhledávány v&nbsp;nalezené oblasti (bod 2) i oblastech sousedních (bod 3)</li>
</ol>

<p>Čím větší je hodnota <i>m</i>, tím pomalejší, ale přesnější je vyhledání
nejbližších vektorů.</p>



<p><a name="k12"></a></p>
<h2 id="k12">12. Konstrukce indexu <strong>IVFFlat</strong></h2>

<p>Rozdělení n-dimenzionálního prostoru podle Voroného dekompozice je
pochopitelně nutné nějakým způsobem realizovat. Podporu pro toto rozdělení
programátorům sice nabízí samotná knihovna FAISS, ovšem samotná konstrukce
indexu se nepatrně zkomplikuje. Připomeňme si, že původně jsme si nechali
zkonstruovat index následujícím postupem:</p>

<pre>
<i># konstrukce indexu pro vyhledavani na zaklade vzdalenosti</i>
index = faiss.IndexFlatL2(dimensions)
</pre>

<p>Ihned poté bylo možné do indexu všechny vektory vložit:</p>

<pre>
index.add(data)
</pre>

<p>Při aplikaci Voroného dekompozice se nejprve samostatným příkazem index
představující realizaci této dekompozice vytvoří a teprve poté se zkonstruuje
index typu <strong>IVFFlat</strong>. Parametrem <strong>nlist</strong> je možné
určit způsob rozdělení celého n-dimenzionálního prostoru do nepřekrývajících se
oblastí:</p>

<pre>
<i># konstrukce indexu pro vyhledavani na zaklade vzdalenosti</i>
quantizer = faiss.IndexFlatL2(DIMENSIONS)
index = faiss.IndexIVFFlat(quantizer, DIMENSIONS, nlist)
</pre>

<p>Rozdílný je nyní způsob přidávání vektorů do indexu, protože index je nutné
nejprve &bdquo;natrénovat&ldquo; a teprve poté je do něj možné vektory přidat.
Je to ostatně pochopitelné, protože samotná Voroného dekompozice závisí na
koncových souřadnicích vektorů. Při tréninku tedy &bdquo;pouze&ldquo; dojde
k&nbsp;dekompozici a při vkládání vektorů k&nbsp;rozdělení vektorů do
jednotlivých oblastí:</p>

<pre>
index.train(data)
index.add(data)
</pre>

<p><div class="rs-tip-major">Poznámka: je tedy umožněno, aby byla dekompozice
provedena s&nbsp;využitím odlišné (typicky menší) datové sady, což sice
nepovede k&nbsp;nejpřesnějším výsledkům, ovšem celý postup se může poměrně
významně urychlit.</div></p>



<p><a name="k13"></a></p>
<h2 id="k13">13. Benchmark: časy vyhledávání nejpodobnějších vektorů s&nbsp;využitím indexu FlatL2</h2>

<p>V&nbsp;dalším demonstračním příkladu, který si dnes ukážeme, budeme měřit
čas vyhledání nejpodobnějších vektorů s&nbsp;využitím indexu nazvaného
<strong>FlatL2</strong>, při jehož konstrukci byly vektory rozděleny do předem
nastaveného počtu oblastí. Celý benchmark se tedy (z&nbsp;pohledu programátora)
liší pouze tím, jakým způsobem se index zkonstruován. Samotné vyhledávání
nejpodobnější vektorů je stále stejné (minimálně z&nbsp;pohledu toho, jaké
funkce se volají). Měření budeme opět provádět pro datovou sadu s&nbsp;počtem
vektorů, který se mění od nuly (resp.&nbsp;od hodnoty odpovídající počtu
oblastí, což je &bdquo;skoro nula&ldquo;) do jednoho milionu:</p>

<pre>
<i># Knihovna FAISS</i>
<i>#</i>
<i># - benchmark rychlosti nalezení nejpodobnějších vektorů</i>
<i># - je použit index FlatL2</i>
<i># - výpis výsledků v tabulkové formě</i>
<i># - vizualizace výsledků formou grafu</i>
&nbsp;
from time import time
import faiss
import numpy as np
&nbsp;
import matplotlib.pyplot as plt
&nbsp;
&nbsp;
def <strong>similarity_search</strong>(n, k, nlist=5):
    <i>"""Nalezeni k nejblizsich vektoru v mnozine n vektoru."""</i>
    <i># pocet slozek vektoru</i>
    DIMENSIONS=128
&nbsp;
    t1 = time()
&nbsp;
    <i># nahodne vektory</i>
    data = np.random.rand(n, 128).astype('float32')
&nbsp;
    t2 = time()
&nbsp;
    <i># konstrukce indexu pro vyhledavani na zaklade vzdalenosti</i>
    quantizer = faiss.IndexFlatL2(DIMENSIONS)
    index = faiss.IndexIVFFlat(quantizer, DIMENSIONS, nlist)
&nbsp;
    index.train(data)
    index.add(data)
&nbsp;
    t3 = time()
    REP_COUNT = 100
&nbsp;
    for _ in range(REP_COUNT):
        <i># vektor, ke kteremu budeme pocitat vzdalenost</i>
        query_vector = np.random.rand(1, DIMENSIONS).astype("float32")
&nbsp;
        <i># pocet nejblizsich bodu</i>
        distances, indices = index.search(query_vector, k)
&nbsp;
        <i># test, kolik vektoru se nalezlo</i>
        assert len(distances) == k
        assert len(indices) == k
&nbsp;
    t4 = time()
&nbsp;
    return n, t2-t1, t3-t2, (t4-t3)/REP_COUNT
&nbsp;
&nbsp;
ns = []
ts_search = []
&nbsp;
for n in np.linspace(0, 1000000, 11):
    <i># nlist nemuze byt nulovy a soucasne musi byt mensi nez</i>
    <i># pocet vektoru</i>
    if n == 0:
        n = 5
    print(n)
    n, t_rand, t_index, t_search = similarity_search(int(n), 1)
    ns.append(n)
    ts_search.append(t_search)
&nbsp;
&nbsp;
plt.xlabel("# vectors")
plt.ylabel("Time/sec")
plt.plot(ns, ts_search, "m-", label="similarity search")
&nbsp;
<i># přidání legendy</i>
plt.legend(loc="upper left")
&nbsp;
<i># povolení zobrazení mřížky</i>
plt.grid(True)
&nbsp;
plt.savefig("faiss_benchmark_5.png")
&nbsp;
<i># zobrazení grafu</i>
plt.show()
</pre>



<p><a name="k14"></a></p>
<h2 id="k14">14. Výsledky pátého benchmarku</h2>

<p>Z&nbsp;výsledků pátého benchmarku je patrné, že se rychlost vyhledávání
skutečně zvýšila. Konkrétně pro datovou sadu s&nbsp;jedním milionem vektorů se
čas vyhledání snížil z&nbsp;0,03 sekundy na 0,009 sekundy. Navíc si musíme
uvědomit, že počet oblastí, do kterých byly vektory rozděleny, byl na nastaven
na velmi malou hodnotu, konkrétně pouze na pět oblastí, takže bychom měli
očekávat maximálně pětinásobné urychlení. A dále je z&nbsp;průběhu grafu
patrné, že vyhledání má stále lineární časovou složitost (ovšem s&nbsp;mnohem
menším sklonem):</p>

<div class="rs-img-center" style="margin-left: auto; margin-right: auto; max-width: 640px"><a href="https://www.root.cz/obrazek/1218225/"><img src="https://i.iinfo.cz/images/304/faiss-benchmarks-5.png" class="image-1218225" width="640" height="480" data-prev-filename="https://i.iinfo.cz/images/304/faiss-benchmarks-5-prev.png" data-prev-filename-webp="https://i.iinfo.cz/images/304/faiss-benchmarks-5-prev.webp" data-prev-width="360" data-prev-height="270" data-large-filename="https://i.iinfo.cz/images/304/faiss-benchmarks-5.png" data-large-filename-webp="https://i.iinfo.cz/images/304/faiss-benchmarks-5.webp" data-large-width="640" data-large-height="480" alt="Výsledky benchmarku" data-description="Výsledky benchmarku" title="Autor: tisnik, podle licence: &lt;a href=&quot;http://en.wikipedia.org/wiki/Rights_Managed&quot;&gt;Rights Managed&lt;/a&gt;" style="width: 100%; height: auto; max-width: 640px" /></a><p>Obrázek 5: Výsledky benchmarku při rozdělení prostoru Voroného dekompozicí na pět oblastí<br class="_remove" /></p><p class="author">Autor: tisnik, podle licence: <a href="http://en.wikipedia.org/wiki/Rights_Managed">Rights Managed</a><br class="_remove" /></p></div>



<p><a name="k15"></a></p>
<h2 id="k15">15. Benchmark: modifikace počtu buněk při konstrukci indexu FlatL2</h2>

<p>V&nbsp;předchozím benchmarku byl počet oblastí (buněk) nastaven na velmi
nízkou hodnotu, konkrétně na hodnotu 5. Ovšem nic nám pochopitelně nebrání ve
zvýšení této hodnoty, například na padesát oblastí; musíme ale počítat
s&nbsp;tím, že se sníží přesnost vyhledání. Zvyšuje se totiž pravděpodobnost,
že se vzorový vektor bude nacházet blízko okraje nějaké oblasti a nikoli poblíž
jejího středu. Nicméně bude zajímavé zjistit, jak bude vyhledání rychlé
v&nbsp;případě, že počet oblastí zvýšíme z&nbsp;hodnoty 5 (což je v&nbsp;praxi
velmi malá hodnota) na 50:</p>

<pre>
<i># Knihovna FAISS</i>
<i>#</i>
<i># - benchmark rychlosti nalezení nejpodobnějších vektorů</i>
<i># - je použit index IVFlat</i>
<i># - výpis výsledků v tabulkové formě</i>
<i># - vizualizace výsledků formou grafu</i>
&nbsp;
from time import time
import faiss
import numpy as np
&nbsp;
import matplotlib.pyplot as plt
&nbsp;
&nbsp;
def <strong>similarity_search</strong>(n, k, nlist=50):
    <i>"""Nalezeni k nejblizsich vektoru v mnozine n vektoru."""</i>
    <i># pocet slozek vektoru</i>
    DIMENSIONS=128
&nbsp;
    t1 = time()
&nbsp;
    <i># nahodne vektory</i>
    data = np.random.rand(n, 128).astype('float32')
&nbsp;
    t2 = time()
&nbsp;
    <i># konstrukce indexu pro vyhledavani na zaklade vzdalenosti</i>
    quantizer = faiss.IndexFlatL2(DIMENSIONS)
    index = faiss.IndexIVFFlat(quantizer, DIMENSIONS, nlist)
&nbsp;
    index.train(data)
    index.add(data)
&nbsp;
    t3 = time()
    REP_COUNT = 100
&nbsp;
    for _ in range(REP_COUNT):
        <i># vektor, ke kteremu budeme pocitat vzdalenost</i>
        query_vector = np.random.rand(1, DIMENSIONS).astype("float32")
&nbsp;
        <i># pocet nejblizsich bodu</i>
        distances, indices = index.search(query_vector, k)
&nbsp;
        <i># test, kolik vektoru se nalezlo</i>
        assert len(distances) == k
        assert len(indices) == k
&nbsp;
    t4 = time()
&nbsp;
    return n, t2-t1, t3-t2, (t4-t3)/REP_COUNT
&nbsp;
&nbsp;
ns = []
ts_search = []
&nbsp;
for n in np.linspace(0, 1000000, 11):
    <i># nlist nemuze byt nulovy a soucasne musi byt mensi nez</i>
    <i># pocet vektoru</i>
    if n == 0:
        n = 50
    print(n)
    n, t_rand, t_index, t_search = similarity_search(int(n), 1)
    ns.append(n)
    ts_search.append(t_search)
&nbsp;
&nbsp;
plt.xlabel("# vectors")
plt.ylabel("Time/sec")
plt.plot(ns, ts_search, "m-", label="similarity search")
&nbsp;
<i># přidání legendy</i>
plt.legend(loc="upper left")
&nbsp;
<i># povolení zobrazení mřížky</i>
plt.grid(True)
&nbsp;
plt.savefig("faiss_benchmark_6.png")
&nbsp;
<i># zobrazení grafu</i>
plt.show()
</pre>

<p><div class="rs-tip-major">Poznámka: hodnota 50 je do benchmarku
&bdquo;zadrátována&ldquo; na dvou místech. Později benchmark upravíme do
podoby, ve které se bude jednat o jeden z&nbsp;proměnných parametrů
benchmarku.</div></p>



<p><a name="k16"></a></p>
<h2 id="k16">16. Výsledky šestého benchmarku</h2>

<p>Opět se podívejme na výsledky benchmarku, jehož zdrojový kód byl uveden <a
href="#k15">v&nbsp;předchozí kapitole</a>:</p>

<div class="rs-img-center" style="margin-left: auto; margin-right: auto; max-width: 640px"><a href="https://www.root.cz/obrazek/1218228/"><img src="https://i.iinfo.cz/images/304/faiss-benchmarks-6.png" class="image-1218228" width="640" height="480" data-prev-filename="https://i.iinfo.cz/images/304/faiss-benchmarks-6-prev.png" data-prev-filename-webp="https://i.iinfo.cz/images/304/faiss-benchmarks-6-prev.webp" data-prev-width="360" data-prev-height="270" data-large-filename="https://i.iinfo.cz/images/304/faiss-benchmarks-6.png" data-large-filename-webp="https://i.iinfo.cz/images/304/faiss-benchmarks-6.webp" data-large-width="640" data-large-height="480" alt="Výsledky benchmarku" data-description="Výsledky benchmarku" title="Autor: tisnik, podle licence: &lt;a href=&quot;http://en.wikipedia.org/wiki/Rights_Managed&quot;&gt;Rights Managed&lt;/a&gt;" style="width: 100%; height: auto; max-width: 640px" /></a><p>Obrázek 6: Výsledky benchmarku při rozdělení prostoru Voroného dekompozicí na padesát oblastí<br class="_remove" /></p><p class="author">Autor: tisnik, podle licence: <a href="http://en.wikipedia.org/wiki/Rights_Managed">Rights Managed</a><br class="_remove" /></p></div>

<p>Zajímavé bude porovnání hodnot získaných ze všech tří základních benchmarků,
tedy benchmarku se základním indexem L2 (bez dalších optimalizací), benchmarku
s&nbsp;rozdělením prostoru do pěti oblastí podle Voroného dekompozice a
benchmarku s&nbsp;rozdělením prostoru na základě téže dekompozice, ovšem nyní
do padesáti oblastí:</p>

<table>
<tr><th>#</th><th>Benchmark</th><th>Čas vyhledání pro milion vektorů</th><th>Teoretické urychlení</th><th>Skutečné urychlení</th></tr>
<tr><td>1</td><td>L2</td><td>0,03</td><td>1,00&times;</td><td>1,00&times;</td></tr>
<tr><td>2</td><td>Voroného dekompozice, 5 oblastí </td><td>0,009</td><td>5.0&times;</td><td>3.3&times;</td></tr>
<tr><td>3</td><td>Voroného dekompozice, 50 oblastí</td><td>0,00175</td><td>50.0&times;</td><td>17.1&times;</td></tr>
</table>

<p><div class="rs-tip-major">Poznámka: počet oblastí je pochopitelně možné dále
zvyšovat. Závislost urychlení vyhledání nejpodobnějších vektorů na základě
počtu oblastí a počtu sousedních oblastí si uvedeme příště v&nbsp;závěrečném
článku o knihovně FAISS.</div></p>



<p><a name="k17"></a></p>
<h2 id="k17">17. Index <i>HNSW</i> (Hierarchical Navigable Small World)</h2>

<p>Jedním z&nbsp;potenciálně velmi užitečných indexů, které jsou nabízeny
(nejenom) knihovnou FAISS, je index označovaný zkratkou <i>HNSW</i> neboli
<i>Hierarchical Navigable Small World</i>. Jak již název tohoto indexu
naznačuje, je metoda HNSW založena na rozdělení celého prostoru do hierarchicky
organizovaných menších částí (ty jsou nazývány &bdquo;malé světy&ldquo;).
Samotné rozdělování prostoru je časově velmi náročné, ovšem na druhou stranu se
urychlí vyhledávání podobných vektorů, a to o jeden až dva řády. Samozřejmě se
i s&nbsp;tímto indexem pojí určité nevýhody, ovšem prozatím nám bude postačovat
vytvoření benchmarku, z&nbsp;něhož je patrné, jakým způsobem se tento index
používá:</p>

<pre>
<i># Knihovna FAISS</i>
<i>#</i>
<i># - benchmark rychlosti nalezení nejpodobnějších vektorů</i>
<i># - je použit index HNSWFlat</i>
<i># - výpis výsledků v tabulkové formě</i>
<i># - vizualizace výsledků formou grafu</i>
&nbsp;
from time import time
import faiss
import numpy as np
&nbsp;
import matplotlib.pyplot as plt
&nbsp;
&nbsp;
def <strong>similarity_search</strong>(n, k):
    <i>"""Nalezeni k nejblizsich vektoru v mnozine n vektoru."""</i>
    M = 32
    ef_search = 16
    ef_construction = 32
    <i># pocet slozek vektoru</i>
    DIMENSIONS=128
&nbsp;
    t1 = time()
&nbsp;
    <i># nahodne vektory</i>
    data = np.random.rand(n, 128).astype('float32')
&nbsp;
    t2 = time()
&nbsp;
    <i># konstrukce indexu pro vyhledavani na zaklade vzdalenosti</i>
    index = faiss.IndexHNSWFlat(DIMENSIONS, M)
    index.hnsw.efConstruction = ef_construction
    index.hnsw.efSearch = ef_search
&nbsp;
    index.add(data)
&nbsp;
    t3 = time()
    REP_COUNT = 100
&nbsp;
    for _ in range(REP_COUNT):
        <i># vektor, ke kteremu budeme pocitat vzdalenost</i>
        query_vector = np.random.rand(1, DIMENSIONS).astype("float32")
&nbsp;
        <i># pocet nejblizsich bodu</i>
        distances, indices = index.search(query_vector, k)
&nbsp;
        <i># test, kolik vektoru se nalezlo</i>
        assert len(distances) == k
        assert len(indices) == k
&nbsp;
    t4 = time()
&nbsp;
    return n, t2-t1, t3-t2, (t4-t3)/REP_COUNT
&nbsp;
&nbsp;
ns = []
ts_search = []
&nbsp;
for n in np.linspace(0, 1000000, 11):
    print(n)
    n, t_rand, t_index, t_search = similarity_search(int(n), 1)
    ns.append(n)
    ts_search.append(t_search)
&nbsp;
&nbsp;
plt.xlabel("# vectors")
plt.ylabel("Time/sec")
plt.plot(ns, ts_search, "m-", label="similarity search")
&nbsp;
<i># přidání legendy</i>
plt.legend(loc="upper left")
&nbsp;
<i># povolení zobrazení mřížky</i>
plt.grid(True)
&nbsp;
plt.savefig("faiss_benchmark_7.png")
&nbsp;
<i># zobrazení grafu</i>
plt.show()
</pre>



<p><a name="k18"></a></p>
<h2 id="k18">18. Výsledky sedmého benchmarku</h2>

<p>Výsledky sedmého a dnes již posledního benchmarku jsou zobrazeny na obrázku
pod tímto odstavcem. Zajímavé je, že v&nbsp;tomto případě došlo k&nbsp;velmi
radikálnímu urychlení vyhledávání podobných vektorů. Konkrétně se (pro jeden
milion vektorů) čas vyhledání snížil z&nbsp;přibližně 0,03 sekundy na pouhých
0,0007 sekundy, takže rychlost vyhledávání je zhruba 43&times; vyšší. Co však
nevidíme je čas nutný pro konstrukci indexu &ndash; ten je naopak velmi dlouhý.
O problematice konstrukce indexu (což nás prozatím příliš netrápilo, ovšem u
podobných komplikovanějších indexů je to již reálný problém) se zmíníme
v&nbsp;závěrečném článku o knihovně FAISS.</p>

<div class="rs-img-center" style="margin-left: auto; margin-right: auto; max-width: 640px"><a href="https://www.root.cz/obrazek/1218231/"><img src="https://i.iinfo.cz/images/304/faiss-benchmarks-7.png" class="image-1218231" width="640" height="480" data-prev-filename="https://i.iinfo.cz/images/304/faiss-benchmarks-7-prev.png" data-prev-filename-webp="https://i.iinfo.cz/images/304/faiss-benchmarks-7-prev.webp" data-prev-width="360" data-prev-height="270" data-large-filename="https://i.iinfo.cz/images/304/faiss-benchmarks-7.png" data-large-filename-webp="https://i.iinfo.cz/images/304/faiss-benchmarks-7.webp" data-large-width="640" data-large-height="480" alt="Výsledky benchmarku" data-description="Výsledky benchmarku" title="Autor: tisnik, podle licence: &lt;a href=&quot;http://en.wikipedia.org/wiki/Rights_Managed&quot;&gt;Rights Managed&lt;/a&gt;" style="width: 100%; height: auto; max-width: 640px" /></a><p>Obrázek 7: Výsledky benchmarku založeného na využití indexu HNSW<br class="_remove" /></p><p class="author">Autor: tisnik, podle licence: <a href="http://en.wikipedia.org/wiki/Rights_Managed">Rights Managed</a><br class="_remove" /></p></div>



<p><a name="k19"></a></p>
<h2 id="k19">19. Repositář s&nbsp;demonstračními příklady</h2>

<p>Demonstrační příklady použité v&nbsp;článcích <a
href="https://www.root.cz/clanky/knihovna-faiss-a-embedding-zaklad-jazykovych-modelu/">Knihovna
FAISS a embedding: základ jazykových modelů</a> a <a
href="https://www.root.cz/clanky/knihovna-faiss-a-embedding-zaklad-jazykovych-modelu-2-cast/">Knihovna
FAISS a embedding: základ jazykových modelů (2. část)</a> lze nalézt na
následujících odkazech:</p>

<table>
<tr><th> #</th><th>Příklad</th><th>Stručný popis</th><th>Adresa</th></tr>
<tr><td> 1</td><td>transformer1.py</td><td>inicializace modelu <strong>paraphrase-MiniLM-L6-v2</strong> přes knihovnu sentence-transformers s&nbsp;výpisem základních informací o něm</td><td><a href="https://github.com/tisnik/most-popular-python-libs/blob/master/faiss_transformers/transformer1.py">https://github.com/tisnik/most-popular-python-libs/blob/master/faiss-transfomers/transformer1.py</a></td></tr>
<tr><td> 2</td><td>transformer2.py</td><td>inicializace modelu <strong>all-mpnet-base-v2</strong> přes knihovnu sentence-transformers s&nbsp;výpisem základních informací o něm</td><td><a href="https://github.com/tisnik/most-popular-python-libs/blob/master/faiss_transformers/transformer2.py">https://github.com/tisnik/most-popular-python-libs/blob/master/faiss-transfomers/transformer2.py</a></td></tr>
<tr><td> 3</td><td>transformer3.py</td><td>inicializace modelu <strong>Seznam/small-e-czech</strong> přes knihovnu sentence-transformers s&nbsp;výpisem základních informací o něm</td><td><a href="https://github.com/tisnik/most-popular-python-libs/blob/master/faiss_transformers/transformer3.py">https://github.com/tisnik/most-popular-python-libs/blob/master/faiss-transfomers/transformer3.py</a></td></tr>
<tr><td> 4</td><td>transformer4.py</td><td>vektorizace textů (vět) přes knihovnu sentence-transformers s&nbsp;využitím zvoleného modelu</td><td><a href="https://github.com/tisnik/most-popular-python-libs/blob/master/faiss_transformers/transformer4.py">https://github.com/tisnik/most-popular-python-libs/blob/master/faiss-transfomers/transformer4.py</a></td></tr>
<tr><td> 5</td><td>transformer5.py</td><td>informace o vypočtené matici s&nbsp;vektorizovaným textem (<i>embedding</i>)</td><td><a href="https://github.com/tisnik/most-popular-python-libs/blob/master/faiss_transformers/transformer5.py">https://github.com/tisnik/most-popular-python-libs/blob/master/faiss-transfomers/transformer5.py</a></td></tr>
<tr><td> 6</td><td>transformer6.py</td><td>výpočet a zobrazení vypočtené tabulky podobností</td><td><a href="https://github.com/tisnik/most-popular-python-libs/blob/master/faiss_transformers/transformer6.py">https://github.com/tisnik/most-popular-python-libs/blob/master/faiss-transfomers/transformer6.py</a></td></tr>
<tr><td> 7</td><td>transformer7.py</td><td>nalezení významově nejpodobnějších vět s&nbsp;využitím vektorizované databáze textů</td><td><a href="https://github.com/tisnik/most-popular-python-libs/blob/master/faiss_transformers/transformer7.py">https://github.com/tisnik/most-popular-python-libs/blob/master/faiss-transfomers/transformer7.py</a></td></tr>
<tr><td> 8</td><td>transformer8.py</td><td>nalezení významově nejpodobnějších vět s&nbsp;využitím vektorizované databáze textů</td><td><a href="https://github.com/tisnik/most-popular-python-libs/blob/master/faiss_transformers/transformer8.py">https://github.com/tisnik/most-popular-python-libs/blob/master/faiss-transfomers/transformer8.py</a></td></tr>
<tr><td> 9</td><td>transformer9.py</td><td>nalezení vět nejbližších k&nbsp;zadanému termínu</td><td><a href="https://github.com/tisnik/most-popular-python-libs/blob/master/faiss_transformers/transformer9.py">https://github.com/tisnik/most-popular-python-libs/blob/master/faiss-transfomers/transformer9.py</a></td></tr>
<tr><td>10</td><td>transformerA.py</td><td>podpora pro hledání na základě sémantické podobnosti</td><td><a href="https://github.com/tisnik/most-popular-python-libs/blob/master/faiss_transformers/transformerA.py">https://github.com/tisnik/most-popular-python-libs/blob/master/faiss-transfomers/transformerA.py</a></td></tr>
<tr><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td></tr>
<tr><td>11</td><td>dataset1.py</td><td>získání datové sady s&nbsp;milionem anglických vět</td><td><a href="https://github.com/tisnik/most-popular-python-libs/blob/master/faiss_transformers/dataset1.py">https://github.com/tisnik/most-popular-python-libs/blob/master/faiss-transfomers/dataset1.py</a></td></tr>
<tr><td>12</td><td>dataset2.py</td><td>získání tréninkových dat s&nbsp;milionem anglických vět</td><td><a href="https://github.com/tisnik/most-popular-python-libs/blob/master/faiss_transformers/dataset2.py">https://github.com/tisnik/most-popular-python-libs/blob/master/faiss-transfomers/dataset2.py</a></td></tr>
<tr><td>13</td><td>dataset3.py</td><td>konstrukce Pythonovského seznamu s&nbsp;větami</td><td><a href="https://github.com/tisnik/most-popular-python-libs/blob/master/faiss_transformers/dataset3.py">https://github.com/tisnik/most-popular-python-libs/blob/master/faiss-transfomers/dataset3.py</a></td></tr>
<tr><td>14</td><td>dataset4.py</td><td>konstrukce Pythonovského seznamu s&nbsp;větami, omezení počtu vět</td><td><a href="https://github.com/tisnik/most-popular-python-libs/blob/master/faiss_transformers/dataset4.py">https://github.com/tisnik/most-popular-python-libs/blob/master/faiss-transfomers/dataset4.py</a></td></tr>
<tr><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td></tr>
<tr><td>15</td><td>transformerB.py</td><td>vytvoření indexu z&nbsp;datové sady s&nbsp;milionem anglických vět</td><td><a href="https://github.com/tisnik/most-popular-python-libs/blob/master/faiss_transformers/transformerB.py">https://github.com/tisnik/most-popular-python-libs/blob/master/faiss-transfomers/transformerB.py</a></td></tr>
<tr><td>16</td><td>transformerC.py</td><td>refaktoring předchozího demonstračního příkladu</td><td><a href="https://github.com/tisnik/most-popular-python-libs/blob/master/faiss_transformers/transformerC.py">https://github.com/tisnik/most-popular-python-libs/blob/master/faiss-transfomers/transformerC.py</a></td></tr>
<tr><td>17</td><td>transformerD.py</td><td>zjištění rychlosti nalezení nejpodobnějších vět</td><td><a href="https://github.com/tisnik/most-popular-python-libs/blob/master/faiss_transformers/transformerD.py">https://github.com/tisnik/most-popular-python-libs/blob/master/faiss-transfomers/transformerD.py</a></td></tr>
<tr><td>18</td><td>transformerE.py</td><td>benchmark: rychlost embeddingu a konstrukce indexu (využití typu <strong>float32</strong>)</td><td><a href="https://github.com/tisnik/most-popular-python-libs/blob/master/faiss_transformers/transformerE.py">https://github.com/tisnik/most-popular-python-libs/blob/master/faiss-transfomers/transformerE.py</a></td></tr>
<tr><td>19</td><td>transformerF.py</td><td>benchmark: rychlost embeddingu a konstrukce indexu (využití typu <strong>float16</strong>)</td><td><a href="https://github.com/tisnik/most-popular-python-libs/blob/master/faiss_transformers/transformerF.py">https://github.com/tisnik/most-popular-python-libs/blob/master/faiss-transfomers/transformerF.py</a></td></tr>
<tr><td>20</td><td>transformerG.py</td><td>uložení modelu i indexu do souboru pro porovnání velikostí</td><td><a href="https://github.com/tisnik/most-popular-python-libs/blob/master/faiss_transformers/transformerG.py">https://github.com/tisnik/most-popular-python-libs/blob/master/faiss-transfomers/transformerG.py</a></td></tr>
<tr><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td></tr>
<tr><td>21</td><td>pyproject.toml</td><td>soubor s&nbsp;projektem a definicí všech potřebných závislostí</td><td><a href="https://github.com/tisnik/most-popular-python-libs/blob/master/faiss_transformers/pyproject.toml">https://github.com/tisnik/most-popular-python-libs/blob/master/faiss-transfomers/pyproject.toml</a></td></tr>
</table>

<p>Demonstrační příklady vytvořené v&nbsp;Pythonu a popsané v&nbsp;článcích <a
href="https://www.root.cz/clanky/faiss-knihovna-pro-rychle-a-efektivni-vyhledavani-podobnych-vektoru/"></a>,
<a
href="https://www.root.cz/clanky/faiss-knihovna-pro-rychle-a-efektivni-vyhledavani-podobnych-vektoru-2-cast/"></a>
i v&nbsp;článku dnešním jsou taktéž uloženy do repositáře <a
href="https://github.com/tisnik/most-popular-python-libs/">https://github.com/tisnik/most-popular-python-libs/</a>.
Následují odkazy na jednotlivé příklady:</p>

<table>
<tr><th> #</th><th>Příklad</th><th>Stručný popis</th><th>Adresa</th></tr>
<tr><td> 1</td><td>faiss-1.py</td><td>seznamy souřadnic bodů v&nbsp;rovině</td><td><a href="https://github.com/tisnik/most-popular-python-libs/blob/master/faiss/faiss-1.py">https://github.com/tisnik/most-popular-python-libs/blob/master/faiss/faiss-1.py</a></td></tr>
<tr><td> 2</td><td>faiss-2.py</td><td>konstrukce matice se souřadnicemi bodů</td><td><a href="https://github.com/tisnik/most-popular-python-libs/blob/master/faiss/faiss-2.py">https://github.com/tisnik/most-popular-python-libs/blob/master/faiss/faiss-2.py</a></td></tr>
<tr><td> 3</td><td>faiss-3.py</td><td>konstrukce indexu pro vyhledávání na základě vzdálenosti</td><td><a href="https://github.com/tisnik/most-popular-python-libs/blob/master/faiss/faiss-3.py">https://github.com/tisnik/most-popular-python-libs/blob/master/faiss/faiss-3.py</a></td></tr>
<tr><td> 4</td><td>faiss-4.py</td><td>nalezení nejbližších bodů k&nbsp;zadaným souřadnicím &ndash; výpis indexů nalezených bodů</td><td><a href="https://github.com/tisnik/most-popular-python-libs/blob/master/faiss/faiss-4.py">https://github.com/tisnik/most-popular-python-libs/blob/master/faiss/faiss-4.py</a></td></tr>
<tr><td> 5</td><td>faiss-5.py</td><td>nalezení nejbližších bodů k&nbsp;zadaným souřadnicím &ndash; výpis souřadnic nalezených bodů</td><td><a href="https://github.com/tisnik/most-popular-python-libs/blob/master/faiss/faiss-5.py">https://github.com/tisnik/most-popular-python-libs/blob/master/faiss/faiss-5.py</a></td></tr>
<tr><td> 6</td><td>faiss-6.py</td><td>vyhledávání bodů na základě skalárního součinu bez normalizace vektorů</td><td><a href="https://github.com/tisnik/most-popular-python-libs/blob/master/faiss/faiss-6.py">https://github.com/tisnik/most-popular-python-libs/blob/master/faiss/faiss-6.py</a></td></tr>
<tr><td> 7</td><td>faiss-7.py</td><td>vyhledávání bodů na základě skalárního součinu s&nbsp;normalizací vektorů</td><td><a href="https://github.com/tisnik/most-popular-python-libs/blob/master/faiss/faiss-7.py">https://github.com/tisnik/most-popular-python-libs/blob/master/faiss/faiss-7.py</a></td></tr>
<tr><td> 8</td><td>faiss-8.py</td><td>jednoduchý benchmark rychlosti vyhledávání knihovnou FAISS</td><td><a href="https://github.com/tisnik/most-popular-python-libs/blob/master/faiss/faiss-8.py">https://github.com/tisnik/most-popular-python-libs/blob/master/faiss/faiss-8.py</a></td></tr>
<tr><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td></tr>
<tr><td> 9</td><td>faiss-9.py</td><td>vizualizace koncových bodů vektorů v&nbsp;rovině</td><td><a href="https://github.com/tisnik/most-popular-python-libs/blob/master/faiss/faiss-9.py">https://github.com/tisnik/most-popular-python-libs/blob/master/faiss/faiss-9.py</a></td></tr>
<tr><td>10</td><td>faiss-A.py</td><td>vykreslení nejpodobnějších vektorů získaných na základě L2 metriky</td><td><a href="https://github.com/tisnik/most-popular-python-libs/blob/master/faiss/faiss-A.py">https://github.com/tisnik/most-popular-python-libs/blob/master/faiss/faiss-A.py</a></td></tr>
<tr><td>11</td><td>faiss-B.py</td><td>nalezení nejpodobnějších vektorů získaných na základě skalárního součinu: varianta s&nbsp;nenormovanými vektory</td><td><a href="https://github.com/tisnik/most-popular-python-libs/blob/master/faiss/faiss-B.py">https://github.com/tisnik/most-popular-python-libs/blob/master/faiss/faiss-B.py</a></td></tr>
<tr><td>12</td><td>faiss-C.py</td><td>nalezení nejpodobnějších vektorů získaných na základě skalárního součinu: varianta s&nbsp;normovanými vektory</td><td><a href="https://github.com/tisnik/most-popular-python-libs/blob/master/faiss/faiss-C.py">https://github.com/tisnik/most-popular-python-libs/blob/master/faiss/faiss-C.py</a></td></tr>
<tr><td>13</td><td>faiss-D.py</td><td>vykreslení nejpodobnějších vektorů před jejich normalizací</td><td><a href="https://github.com/tisnik/most-popular-python-libs/blob/master/faiss/faiss-D.py">https://github.com/tisnik/most-popular-python-libs/blob/master/faiss/faiss-D.py</a></td></tr>
<tr><td>14</td><td>faiss-E.py</td><td>vykreslení vektorů formou orientovaných šipek</td><td><a href="https://github.com/tisnik/most-popular-python-libs/blob/master/faiss/faiss-E.py">https://github.com/tisnik/most-popular-python-libs/blob/master/faiss/faiss-E.py</a></td></tr>
<tr><td>15</td><td>faiss-F.py</td><td>vykreslení vektorů po jejich normalizaci formou orientovaných šipek</td><td><a href="https://github.com/tisnik/most-popular-python-libs/blob/master/faiss/faiss-F.py">https://github.com/tisnik/most-popular-python-libs/blob/master/faiss/faiss-F.py</a></td></tr>
<tr><td>16</td><td>faiss-G.py</td><td>vyhledání a vykreslení nejvíce NEpodobných vektorů</td><td><a href="https://github.com/tisnik/most-popular-python-libs/blob/master/faiss/faiss-G.py">https://github.com/tisnik/most-popular-python-libs/blob/master/faiss/faiss-G.py</a></td></tr>
<tr><td>17</td><td>faiss-H.py</td><td>vyhledání podobných vektorů se složkami typu <i>float16</i></td><td><a href="https://github.com/tisnik/most-popular-python-libs/blob/master/faiss/faiss-H.py">https://github.com/tisnik/most-popular-python-libs/blob/master/faiss/faiss-H.py</a></td></tr>
<tr><td>18</td><td>faiss-I.py</td><td>jednoduchý benchmark rychlosti vyhledávání knihovnou FAISS: rozdíly mezi <i>float16</i> a <i>float32</i></td><td><a href="https://github.com/tisnik/most-popular-python-libs/blob/master/faiss/faiss-I.py">https://github.com/tisnik/most-popular-python-libs/blob/master/faiss/faiss-I.py</a></td></tr>
<tr><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td></tr>
<tr><td>19</td><td>faiss-index-benchmark-1.py</td><td>benchmark: zjištění časové složitosti vyhledávání při použití výchozího indexu L2</td><td><a href="https://github.com/tisnik/most-popular-python-libs/blob/master/faiss/faiss-index-benchmark-1.py">https://github.com/tisnik/most-popular-python-libs/blob/master/faiss/faiss-index-benchmark-1.py</a></td></tr>
<tr><td>20</td><td>faiss-index-benchmark-2.py</td><td>benchmark: vliv rychlosti vyhledávání na počtu dimenzí vektorů</td><td><a href="https://github.com/tisnik/most-popular-python-libs/blob/master/faiss/faiss-index-benchmark-2.py">https://github.com/tisnik/most-popular-python-libs/blob/master/faiss/faiss-index-benchmark-2.py</a></td></tr>
<tr><td>21</td><td>faiss-index-benchmark-3.py</td><td>benchmark: rychlosti vyhledání nejpodobnějších vektorů v&nbsp;sadě s&nbsp;proměnným počtem vektorů i proměnným počtem dimenzí (lineární stupnice)</td><td><a href="https://github.com/tisnik/most-popular-python-libs/blob/master/faiss/faiss-index-benchmark-3.py">https://github.com/tisnik/most-popular-python-libs/blob/master/faiss/faiss-index-benchmark-3.py</a></td></tr>
<tr><td>22</td><td>faiss-index-benchmark-4.py</td><td>benchmark: rychlosti vyhledání nejpodobnějších vektorů v&nbsp;sadě s&nbsp;proměnným počtem vektorů i proměnným počtem dimenzí (logaritmická stupnice)</td><td><a href="https://github.com/tisnik/most-popular-python-libs/blob/master/faiss/faiss-index-benchmark-4.py">https://github.com/tisnik/most-popular-python-libs/blob/master/faiss/faiss-index-benchmark-4.py</a></td></tr>
<tr><td>23</td><td>faiss-index-benchmark-5.py</td><td>benchmark: využití indexu <strong>IVFFlat</strong>, výchozí hodnota počtu centroidů</td><td><a href="https://github.com/tisnik/most-popular-python-libs/blob/master/faiss/faiss-index-benchmark-5.py">https://github.com/tisnik/most-popular-python-libs/blob/master/faiss/faiss-index-benchmark-5.py</a></td></tr>
<tr><td>24</td><td>faiss-index-benchmark-6.py</td><td>benchmark: využití indexu <strong>IVFFlat</strong>, zvýšená hodnota počtu centroidů</td><td><a href="https://github.com/tisnik/most-popular-python-libs/blob/master/faiss/faiss-index-benchmark-6.py">https://github.com/tisnik/most-popular-python-libs/blob/master/faiss/faiss-index-benchmark-6.py</a></td></tr>
<tr><td>25</td><td>faiss-index-benchmark-7.py</td><td>benchmark: využití indexu <strong>HNSWFlat</strong></td><td><a href="https://github.com/tisnik/most-popular-python-libs/blob/master/faiss/faiss-index-benchmark-7.py">https://github.com/tisnik/most-popular-python-libs/blob/master/faiss/faiss-index-benchmark-7.py</a></td></tr>
<tr><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td></tr>
<tr><td>26</td><td>pyproject.toml</td><td>soubor s&nbsp;projektem a definicí závislostí</td><td><a href="https://github.com/tisnik/most-popular-python-libs/blob/master/faiss/pyproject.toml">https://github.com/tisnik/most-popular-python-libs/blob/master/faiss/pyproject.toml</a></td></tr>
</table>



<p><a name="k20"></a></p>
<h2 id="k20">20. Odkazy na Internetu</h2>

<ol>

<li>FAISS: knihovna pro rychlé a efektivní vyhledávání podobných vektorů<br />
<a href="https://www.root.cz/clanky/faiss-knihovna-pro-rychle-a-efektivni-vyhledavani-podobnych-vektoru/">https://www.root.cz/clanky/faiss-knihovna-pro-rychle-a-efektivni-vyhledavani-podobnych-vektoru/</a>
</li>

<li>FAISS: knihovna pro rychlé a efektivní vyhledávání podobných vektorů (2. část)<br />
<a href="https://www.root.cz/clanky/faiss-knihovna-pro-rychle-a-efektivni-vyhledavani-podobnych-vektoru-2-cast/">https://www.root.cz/clanky/faiss-knihovna-pro-rychle-a-efektivni-vyhledavani-podobnych-vektoru-2-cast/</a>
</li>

<li>Knihovna FAISS a embedding: základ jazykových modelů<br />
<a href="https://www.root.cz/clanky/knihovna-faiss-a-embedding-zaklad-jazykovych-modelu/">https://www.root.cz/clanky/knihovna-faiss-a-embedding-zaklad-jazykovych-modelu/</a>
</li>

<li>Knihovna FAISS a embedding: základ jazykových modelů (2. část)<br />
<a href="https://www.root.cz/clanky/knihovna-faiss-a-embedding-zaklad-jazykovych-modelu-2-cast/">https://www.root.cz/clanky/knihovna-faiss-a-embedding-zaklad-jazykovych-modelu-2-cast/</a>
</li>

<li>FAISS (Facebook AI Similarity Search)<br />
<a href="https://en.wikipedia.org/wiki/FAISS">https://en.wikipedia.org/wiki/FAISS</a>
</li>

<li>FAISS documentation<br />
<a href="https://faiss.ai/">https://faiss.ai/</a>
</li>

<li>Introduction to Facebook AI Similarity Search (Faiss)<br />
<a href="https://www.pinecone.io/learn/series/faiss/faiss-tutorial/">https://www.pinecone.io/learn/series/faiss/faiss-tutorial/</a>
</li>

<li>Faiss: Efficient Similarity Search and Clustering of Dense Vectors<br />
<a href="https://medium.com/@pankaj_pandey/faiss-efficient-similarity-search-and-clustering-of-dense-vectors-dace1df1e235">https://medium.com/@pankaj_pandey/faiss-efficient-similarity-search-and-clustering-of-dense-vectors-dace1df1e235</a>
</li>

<li>Cosine Distance vs Dot Product vs Euclidean in vector similarity search<br />
<a href="https://medium.com/data-science-collective/cosine-distance-vs-dot-product-vs-euclidean-in-vector-similarity-search-227a6db32edb">https://medium.com/data-science-collective/cosine-distance-vs-dot-product-vs-euclidean-in-vector-similarity-search-227a6db32edb</a>
</li>

<li>F16C<br />
<a href="https://en.wikipedia.org/wiki/F16C">https://en.wikipedia.org/wiki/F16C</a>
</li>

<li>FP16 (AVX-512)<br />
<a href="https://en.wikipedia.org/wiki/AVX-512#FP16">https://en.wikipedia.org/wiki/AVX-512#FP16</a>
</li>

<li>Top 8 Vector Databases in 2025: Features, Use Cases, and Comparisons<br />
<a href="https://synapsefabric.com/top-8-vector-databases-in-2025-features-use-cases-and-comparisons/">https://synapsefabric.com/top-8-vector-databases-in-2025-features-use-cases-and-comparisons/</a>
</li>

<li>Is FAISS a Vector Database? Complete Guide<br />
<a href="https://mljourney.com/is-faiss-a-vector-database-complete-guide/">https://mljourney.com/is-faiss-a-vector-database-complete-guide/</a>
</li>

<li>Vector database<br />
<a href="https://en.wikipedia.org/wiki/Vector_database">https://en.wikipedia.org/wiki/Vector_database</a>
</li>

<li>Similarity search<br />
<a href="https://en.wikipedia.org/wiki/Similarity_search">https://en.wikipedia.org/wiki/Similarity_search</a>
</li>

<li>Nearest neighbor search<br />
<a href="https://en.wikipedia.org/wiki/Nearest_neighbor_search#Approximation_methods">https://en.wikipedia.org/wiki/Nearest_neighbor_search#Approximation_methods</a>
</li>

<li>Decoding Similarity Search with FAISS: A Practical Approach<br />
<a href="https://www.luminis.eu/blog/decoding-similarity-search-with-faiss-a-practical-approach/">https://www.luminis.eu/blog/decoding-similarity-search-with-faiss-a-practical-approach/</a>
</li>

<li>MetricType and distances<br />
<a href="https://github.com/facebookresearch/faiss/wiki/MetricType-and-distances">https://github.com/facebookresearch/faiss/wiki/MetricType-and-distances</a>
</li>

<li>RAG - Retrieval-augmented generation<br />
<a href="https://en.wikipedia.org/wiki/Retrieval-augmented_generation">https://en.wikipedia.org/wiki/Retrieval-augmented_generation</a>
</li>

<li>pgvector na GitHubu<br />
<a href="https://github.com/pgvector/pgvector">https://github.com/pgvector/pgvector</a>
</li>

<li>Why we replaced Pinecone with PGVector<br />
<a href="https://www.confident-ai.com/blog/why-we-replaced-pinecone-with-pgvector">https://www.confident-ai.com/blog/why-we-replaced-pinecone-with-pgvector</a>
</li>

<li>PostgreSQL as VectorDB - Beginner Tutorial<br />
<a href="https://www.youtube.com/watch?v=Ff3tJ4pJEa4">https://www.youtube.com/watch?v=Ff3tJ4pJEa4</a>
</li>

<li>What is a Vector Database? (neobsahuje odpověď na otázku v titulku :-)<br />
<a href="https://www.youtube.com/watch?v=t9IDoenf-lo">https://www.youtube.com/watch?v=t9IDoenf-lo</a>
</li>

<li>PGVector: Turn PostgreSQL Into A Vector Database<br />
<a href="https://www.youtube.com/watch?v=j1QcPSLj7u0">https://www.youtube.com/watch?v=j1QcPSLj7u0</a>
</li>

<li>Milvus<br />
<a href="https://milvus.io/">https://milvus.io/</a>
</li>

<li>Vector Databases simply explained! (Embeddings &amp; Indexes)<br />
<a href="https://www.youtube.com/watch?v=dN0lsF2cvm4">https://www.youtube.com/watch?v=dN0lsF2cvm4</a>
</li>

<li>Vector databases are so hot right now. WTF are they?<br />
<a href="https://www.youtube.com/watch?v=klTvEwg3oJ4">https://www.youtube.com/watch?v=klTvEwg3oJ4</a>
</li>

<li>Step-by-Step Guide to Installing “pgvector” and Loading Data in PostgreSQL<br />
<a href="https://medium.com/@besttechreads/step-by-step-guide-to-installing-pgvector-and-loading-data-in-postgresql-f2cffb5dec43">https://medium.com/@besttechreads/step-by-step-guide-to-installing-pgvector-and-loading-data-in-postgresql-f2cffb5dec43</a>
</li>

<li>Best 17 Vector Databases for 2025<br />
<a href="https://lakefs.io/blog/12-vector-databases-2023/">https://lakefs.io/blog/12-vector-databases-2023/</a>
</li>

<li>Top 15 Vector Databases that You Must Try in 2025<br />
<a href="https://www.geeksforgeeks.org/top-vector-databases/">https://www.geeksforgeeks.org/top-vector-databases/</a>
</li>

<li>Picking a vector database: a comparison and guide for 2023<br />
<a href="https://benchmark.vectorview.ai/vectordbs.html">https://benchmark.vectorview.ai/vectordbs.html</a>
</li>

<li>Top 9 Vector Databases as of Feburary 2025<br />
<a href="https://www.shakudo.io/blog/top-9-vector-databases">https://www.shakudo.io/blog/top-9-vector-databases</a>
</li>

<li>What is a vector database?<br />
<a href="https://www.ibm.com/think/topics/vector-database">https://www.ibm.com/think/topics/vector-database</a>
</li>

<li>SQL injection<br />
<a href="https://en.wikipedia.org/wiki/SQL_injection">https://en.wikipedia.org/wiki/SQL_injection</a>
</li>

<li>Cosine similarity<br />
<a href="https://en.wikipedia.org/wiki/Cosine_similarity">https://en.wikipedia.org/wiki/Cosine_similarity</a>
</li>

<li>Euclidean distance<br />
<a href="https://en.wikipedia.org/wiki/Euclidean_distance">https://en.wikipedia.org/wiki/Euclidean_distance</a>
</li>

<li>Dot product<br />
<a href="https://en.wikipedia.org/wiki/Dot_product">https://en.wikipedia.org/wiki/Dot_product</a>
</li>

<li>Hammingova vzdálenost<br />
<a href="https://cs.wikipedia.org/wiki/Hammingova_vzd%C3%A1lenost">https://cs.wikipedia.org/wiki/Hammingova_vzd%C3%A1lenost</a>
</li>

<li>Jaccard index<br />
<a href="https://en.wikipedia.org/wiki/Jaccard_index">https://en.wikipedia.org/wiki/Jaccard_index</a>
</li>

<li>Manhattanská metrika<br />
<a href="https://cs.wikipedia.org/wiki/Manhattansk%C3%A1_metrika">https://cs.wikipedia.org/wiki/Manhattansk%C3%A1_metrika</a>
</li>

<li>pgvector: vektorová databáze postavená na Postgresu<br />
<a href="https://www.root.cz/clanky/pgvector-vektorova-databaze-postavena-na-postgresu/">https://www.root.cz/clanky/pgvector-vektorova-databaze-postavena-na-postgresu/</a>
</li>

<li>Matplotlib Home Page<br />
<a href="http://matplotlib.org/">http://matplotlib.org/</a>
</li>

<li>matplotlib (Wikipedia)<br />
<a href="https://en.wikipedia.org/wiki/Matplotlib">https://en.wikipedia.org/wiki/Matplotlib</a>
</li>

<li>Dot Product<br />
<a href="https://mathworld.wolfram.com/DotProduct.html">https://mathworld.wolfram.com/DotProduct.html</a>
</li>

<li>FAISS and sentence-transformers in 5 Minutes<br />
<a href="https://www.stephendiehl.com/posts/faiss/">https://www.stephendiehl.com/posts/faiss/</a>
</li>

<li>Sentence Transformer: Quickstart<br />
<a href="https://sbert.net/docs/quickstart.html#sentence-transformer">https://sbert.net/docs/quickstart.html#sentence-transformer</a>
</li>

<li>Sentence Transformers: Embeddings, Retrieval, and Reranking<br />
<a href="https://pypi.org/project/sentence-transformers/">https://pypi.org/project/sentence-transformers/</a>
</li>

<li>uv<br />
<a href="https://docs.astral.sh/uv/">https://docs.astral.sh/uv/</a>
</li>

<li>A Gentle Introduction to Retrieval Augmented Generation (RAG)<br />
<a href="https://wandb.ai/cosmo3769/RAG/reports/A-Gentle-Introduction-to-Retrieval-Augmented-Generation-RAG---Vmlldzo1MjM4Mjk1">https://wandb.ai/cosmo3769/RAG/reports/A-Gentle-Introduction-to-Retrieval-Augmented-Generation-RAG---Vmlldzo1MjM4Mjk1</a>
</li>

<li>The Beginner’s Guide to Text Embeddings<br />
<a href="https://www.deepset.ai/blog/the-beginners-guide-to-text-embeddings">https://www.deepset.ai/blog/the-beginners-guide-to-text-embeddings</a>
</li>

<li>What are Word Embeddings?<br />
<a href="https://www.youtube.com/watch?v=wgfSDrqYMJ4">https://www.youtube.com/watch?v=wgfSDrqYMJ4</a>
</li>

<li>How to choose an embedding model<br />
<a href="https://www.youtube.com/watch?v=djp4205tHGU">https://www.youtube.com/watch?v=djp4205tHGU</a>
</li>

<li>What is a Vector Database? Powering Semantic Search &amp; AI Applications<br />
<a href="https://www.youtube.com/watch?v=gl1r1XV0SLw">https://www.youtube.com/watch?v=gl1r1XV0SLw</a>
</li>

<li>How do Sentence Transformers differ from traditional word embedding models like Word2Vec or GloVe?<br />
<a href="https://zilliz.com/ai-faq/how-do-sentence-transformers-differ-from-traditional-word-embedding-models-like-word2vec-or-glove">https://zilliz.com/ai-faq/how-do-sentence-transformers-differ-from-traditional-word-embedding-models-like-word2vec-or-glove</a>
</li>

<li>BERT (language model)<br />
<a href="https://en.wikipedia.org/wiki/BERT_(language_model)">https://en.wikipedia.org/wiki/BERT_(language_model)</a>
</li>

<li>Levenštejnova vzdálenost<br />
<a href="https://cs.wikipedia.org/wiki/Leven%C5%A1tejnova_vzd%C3%A1lenost">https://cs.wikipedia.org/wiki/Leven%C5%A1tejnova_vzd%C3%A1lenost</a>
</li>

<li>IVFFlat (Inverted File Flat) Index<br />
<a href="https://skyzh.github.io/write-you-a-vector-db/cpp-05-ivfflat.html">https://skyzh.github.io/write-you-a-vector-db/cpp-05-ivfflat.html</a>
</li>

<li>HNSW (Hierarchical Navigable Small Worlds) Index<br />
<a href="https://skyzh.github.io/write-you-a-vector-db/cpp-06-02-hnsw.html">https://skyzh.github.io/write-you-a-vector-db/cpp-06-02-hnsw.html</a>
</li>

<li>Vector Indexing: Your Guide to Understanding and Implementation<br />
<a href="https://www.teradata.com/insights/ai-and-machine-learning/what-is-vector-index">https://www.teradata.com/insights/ai-and-machine-learning/what-is-vector-index</a>
</li>

<li>Vector Indexing Explained: Everything You Need to Know<br />
<a href="https://www.datastax.com/guides/what-is-a-vector-index">https://www.datastax.com/guides/what-is-a-vector-index</a>
</li>

<li>Voroného diagram<br />
<a href="https://cs.wikipedia.org/wiki/Voron%C3%A9ho_diagram">https://cs.wikipedia.org/wiki/Voron%C3%A9ho_diagram</a>
</li>

</ol>



<p></p><p></p>
<p><small>Autor: <a href="https://github.com/tisnik/">Pavel Tišnovský</a> &nbsp; 2025</small></p>
</body>
</html>

