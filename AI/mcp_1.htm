<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
        "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html>
<head>
<title>Model Context Protocol: vznikající standard pro potřeby aplikací využívajících AI a LLM</title>
<meta name="Author" content="Pavel Tisnovsky" />
<meta name="Generator" content="vim" />
<meta http-equiv="content-type" content="text/html; charset=utf-8" />
<style type="text/css">
         body {color:#000000; background:#ffffff;}
         h1  {font-family: arial, helvetica, sans-serif; color:#ffffff; background-color:#c00000; text-align:center; padding-left:1em}
         h2  {font-family: arial, helvetica, sans-serif; color:#ffffff; background-color:#0000c0; padding-left:1em; text-align:left}
         h3  {font-family: arial, helvetica, sans-serif; color:#000000; background-color:#c0c0c0; padding-left:1em; text-align:left}
         h4  {font-family: arial, helvetica, sans-serif; color:#000000; background-color:#e0e0e0; padding-left:1em; text-align:left}
         a   {font-family: arial, helvetica, sans-serif;}
         li  {font-family: arial, helvetica, sans-serif; color:#000000; text-align:justify; width:450px;}
         ol  {font-family: arial, helvetica, sans-serif; color:#000000; text-align:justify; width:450px;}
         ul  {font-family: arial, helvetica, sans-serif; color:#000000; text-align:justify; width:450px;}
         p   {font-family: arial, helvetica, sans-serif; color:#000000; text-align:justify;}
         pre {background:#e0e0e0}
</style>
</head>

<body>

<h1>Model Context Protocol: vznikající standard pro potřeby aplikací využívajících AI a LLM</h1>

<h3>Pavel Tišnovský</h3>

<p></p>

<h1>Úvodník</h1>

<p>Současně s vývojem aplikací, které do nějaké míry využívají umělou inteligenci a/nebo velké jazykové modely se ukázala potřeba existence standardního mechanismu pro komunikaci mezi jednotlivými moduly těchto aplikací. Řešením by mohl být Model Context Protocol neboli MCP.</p>



<h2>Obsah</h2>

<p><a href="#k01">1. Model Context Protocol: vznikající standard pro potřeby aplikací využívajících AI a LLM</a></p>
<p><a href="#k02">2. Základní vlastnosti MCP</a></p>
<p><a href="#k03">3. Instalace balíčku <strong>mcp</strong></a></p>
<p><a href="#k04">4. Instalace nástrojů nutných pro spuštění MCP Inspectoru</a></p>
<p><a href="#k05">5. Implementace jednoduchého MCP serveru s&nbsp;jediným definovaným zdrojem</a></p>
<p><a href="#k06">6. Spuštění serveru s&nbsp;jeho otestováním pomocí MCP Inspectoru</a></p>
<p><a href="#k07">7. MCP server s&nbsp;definovaným dynamickým zdrojem (<i>resource template</i>)</a></p>
<p><a href="#k08">8. Otestování nové varianty MCP serveru</a></p>
<p><a href="#k09">9. Zdroj vracející strukturovaná data</a></p>
<p><a href="#k10">10. Server s&nbsp;definicí nástroje (<i>tool</i>)</a></p>
<p><a href="#k11">11. Otestování MCP serveru s&nbsp;voláním nástroje</a></p>
<p><a href="#k12">12. Složitější MCP servery s&nbsp;několika zdroji a/nebo nástroji</a></p>
<p><a href="#k13">13. Jak MCP Inspector spouští MCP server?</a></p>
<p><a href="#k14">14. Přímé spuštění MCP serveru z&nbsp;příkazové řádky s&nbsp;transportem STDIO</a></p>
<p><a href="#k15">15. Přímé spuštění MCP serveru z&nbsp;příkazové řádky s&nbsp;transportem SSE</a></p>
<p><a href="#k16">16. MCP klient spouštějící server s&nbsp;komunikací přes STDIO</a></p>
<p><a href="#k17">17. MCP klient s&nbsp;komunikací přes SSE</a></p>
<p><a href="#k18">18. Klient, který přečte zdroj z&nbsp;MCP serveru</a></p>
<p><a href="#k19">19. Repositář s&nbsp;demonstračními příklady</a></p>
<p><a href="#k20">20. Odkazy na Internetu</a></p>



<p><a name="k01"></a></p>
<h2 id="k01">1. Model Context Protocol: vznikající standard pro potřeby aplikací využívajících AI a LLM</h2>

<p>V&nbsp;posledním roce je možné sledovat velmi rychlý vývoj aplikací, které
nějakým způsobem využívají umělou inteligenci (AI) popř.&nbsp;velké jazykové
modely (LLM). Takové aplikace nebo služby se mohou skládat z&nbsp;většího
množství komponent, které spolu musí nějakým způsobem komunikovat &ndash; a to
většinou oboustranně a asynchronně. Samozřejmě již existuje několik více či
méně standardních způsobů takové komunikace &ndash; REST API, GraphQL, RPC, do
jisté míry i komunikační protokol Apache Kafky. Ovšem každému zmíněnému
komunikačnímu mechanismu něco chybí. REST API je mechanismus pro práci se
zdroji (i když ho lze různými způsoby ohýbat), GraphQL je určen především pro
provádění dotazů, RPC naopak pro volání vzdáleného kódu a protokol Apache Kafky
pro realizaci komunikačních strategií pub-sub, push-pull a streamingu.</p>

<p><div class="rs-tip-major">Poznámka: pochopitelně existují další desítky či
spíše stovky dalších mechanismů.</div></p>



<p><a name="k02"></a></p>
<h2 id="k02">2. Základní vlastnosti MCP</h2>

<p>Řešením by mohl být <i>Model Context Protocol</i> neboli <i>MCP</i>.
V&nbsp;něm dochází ke kombinaci několika způsobů komunikace. Lze pracovat se
zdroji (<i>resources</i>), což do značné míry odpovídá klasickému REST API, lze
volat takzvané nástroje (<i>tools</i>), což odpovídá RPC a navíc je umožněna
oboustranná a asynchronní komunikace mezi klienty a servery. V&nbsp;současnosti
jsou definovány dva takzvané <i>transporty</i>, což je způsob realizace
komunikace mezi klientem a serverem na nižší vrstvě. Buď se využívá STDIO, což
vlastně není nic jiného než přímá komunikace mezi klientem a serverem přes
standardní vstupy a výstupu (a tedy komunikace probíhá lokálně, navíc si klient
může server přímo spustit). A druhým transportem je SSE neboli <i>Server Sent
Events</i>; komunikace poté probíhá přes HTTP/HTTPS.</p>

<p><div class="rs-tip-major">Poznámka: samotný MCP se neustále vyvíjí a vyvíjí
se i balíčky, které ho umožňují využívat v&nbsp;různých programovacích
jazycích. Například teprve nedávno byla přidána podpora pro OAUTH atd., není
vyřešeno verzování, správa API, samotné balíčky mají (přiznejme si to) dosti
mizernou dokumentaci atd. I přesto se začíná MCP poměrně výrazným způsobem
v&nbsp;oblastech AI a LLM prosazovat, takže si ukážeme jeho základní způsoby
využití a později i možnosti jeho nasazení v&nbsp;složitějším &bdquo;osobním
asistentovi&ldquo; založeném na LLM.</div></p>



<p><a name="k03"></a></p>
<h2 id="k03">3. Instalace balíčku <strong>mcp</strong></h2>

<p>MCP je možné využívat mnoha různými způsoby. Je například podporován
některými frameworky určenými pro tvorbu aplikací založených na velkých
jazykových modelech atd. Ovšem pro začátek je dobré zjistit, jaké jsou vlastně
základní vlastnosti MCP a z&nbsp;tohoto důvodu si naprogramujeme vlastní MCP
server (resp.&nbsp;hned několik jeho variant) a taktéž jednoduché MCP klienty.
V&nbsp;současnosti je možné aplikace používající MCP naprogramovat v&nbsp;mnoha
jazycích; my se pro jednoduchost zaměříme na Python. Pro ekosystém Pythonu
vznikl balíček nazvaný příhodně <strong>mcp</strong>, který si nainstalujeme
příkazem:</p>

<pre>
$ <strong>pip install --user mcp</strong>
</pre>

<p>Resp.&nbsp;na systémech rozlišujících Python 2 a Python 3:</p>

<pre>
$ <strong>pip3 install --user mcp</strong>
</pre>

<p>Balíček <strong>mcp</strong> má sice několik závislostí (například celý
Pydantic a Uvicorn), ovšem i tak by měla být jeho instalace prakticky
okamžitá:</p>

<pre>
Collecting mcp
  Downloading mcp-1.5.0-py3-none-any.whl.metadata (20 kB)
Requirement already satisfied: anyio&gt;4.5 in /home/ptisnovs/.local/lib/python3.12/site-packages (from mcp) (4.6.2.post1)
Collecting httpx-sse&gt;0.4 (from mcp)
  Downloading httpx_sse-0.4.0-py3-none-any.whl.metadata (9.0 kB)
Requirement already satisfied: httpx&gt;0.27 in /home/ptisnovs/.local/lib/python3.12/site-packages (from mcp) (0.28.0)
Collecting pydantic-settings&gt;2.5.2 (from mcp)
  Downloading pydantic_settings-2.8.1-py3-none-any.whl.metadata (3.5 kB)
Requirement already satisfied: pydantic&lt;3.0.0,&gt;2.7.2 in /home/ptisnovs/.local/lib/python3.12/site-packages (from mcp) (2.10.5)
Collecting sse-starlette&gt;1.6.1 (from mcp)
  Downloading sse_starlette-2.2.1-py3-none-any.whl.metadata (7.8 kB)
Requirement already satisfied: starlette&gt;0.27 in /home/ptisnovs/.local/lib/python3.12/site-packages (from mcp) (0.41.3)
Requirement already satisfied: uvicorn&gt;0.23.1 in /home/ptisnovs/.local/lib/python3.12/site-packages (from mcp) (0.34.0)
Requirement already satisfied: idna&gt;2.8 in /usr/lib/python3.12/site-packages (from anyio&gt;4.5-&gt;mcp) (3.7)
Requirement already satisfied: sniffio&gt;1.1 in /home/ptisnovs/.local/lib/python3.12/site-packages (from anyio&gt;4.5-&gt;mcp) (1.3.1)
Requirement already satisfied: certifi in /home/ptisnovs/.local/lib/python3.12/site-packages (from httpx&gt;0.27-&gt;mcp) (2024.8.30)
Requirement already satisfied: httpcore==1.* in /home/ptisnovs/.local/lib/python3.12/site-packages (from httpx&gt;0.27-&gt;mcp) (1.0.7)
Requirement already satisfied: h11&lt;0.15,&gt;0.13 in /home/ptisnovs/.local/lib/python3.12/site-packages (from httpcore==1.*-&gt;httpx&gt;0.27-&gt;mcp) (0.14.0)
Requirement already satisfied: annotated-types&gt;0.6.0 in /home/ptisnovs/.local/lib/python3.12/site-packages (from pydantic&lt;3.0.0,&gt;2.7.2-&gt;mcp) (0.7.0)
Requirement already satisfied: pydantic-core==2.27.2 in /home/ptisnovs/.local/lib/python3.12/site-packages (from pydantic&lt;3.0.0,&gt;2.7.2-&gt;mcp) (2.27.2)
Requirement already satisfied: typing-extensions&gt;4.12.2 in /usr/lib/python3.12/site-packages (from pydantic&lt;3.0.0,&gt;2.7.2-&gt;mcp) (4.12.2)
Requirement already satisfied: python-dotenv&gt;0.21.0 in /home/ptisnovs/.local/lib/python3.12/site-packages (from pydantic-settings&gt;2.5.2-&gt;mcp) (1.0.1)
Collecting anyio&gt;4.5 (from mcp)
  Downloading anyio-4.9.0-py3-none-any.whl.metadata (4.7 kB)
Requirement already satisfied: click&gt;7.0 in /home/ptisnovs/.local/lib/python3.12/site-packages (from uvicorn&gt;0.23.1-&gt;mcp) (8.1.8)
Downloading mcp-1.5.0-py3-none-any.whl (73 kB)
   ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━ 73.7/73.7 kB 1.6 MB/s eta 0:00:00
Downloading httpx_sse-0.4.0-py3-none-any.whl (7.8 kB)
Downloading pydantic_settings-2.8.1-py3-none-any.whl (30 kB)
Downloading sse_starlette-2.2.1-py3-none-any.whl (10 kB)
Downloading anyio-4.9.0-py3-none-any.whl (100 kB)
   ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━ 100.9/100.9 kB 4.4 MB/s eta 0:00:00
Installing collected packages: httpx-sse, anyio, sse-starlette, pydantic-settings, mcp
  Attempting uninstall: anyio
    Found existing installation: anyio 4.6.2.post1
    Uninstalling anyio-4.6.2.post1:
      Successfully uninstalled anyio-4.6.2.post1
Successfully installed anyio-4.9.0 httpx-sse-0.4.0 mcp-1.5.0 pydantic-settings-2.8.1 sse-starlette-2.2.1
</pre>

<p>Po instalaci by měl být k&nbsp;dispozici i příkaz <strong>mcp</strong>,
jehož existenci a dostupnost si snadno ověříme:</p>

<pre>
 Usage: mcp [OPTIONS] COMMAND [ARGS]...
&nbsp;
 MCP development tools
&nbsp;
╭─ Options ────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╮
│ --help          Show this message and exit.                                                                                          │
╰──────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
╭─ Commands ───────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╮
│ version   Show the MCP version.                                                                                                      │
│ dev       Run a MCP server with the MCP Inspector.                                                                                   │
│ run       Run a MCP server.                                                                                                          │
│ install   Install a MCP server in the Claude desktop app.                                                                            │
╰──────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
</pre>

<p><div class="rs-tip-major">Poznámka: v&nbsp;případě, že není
<strong>mcp</strong> dostupný, je možné, že adresář
<strong>~/.local/bin</strong> není přidán do proměnné prostředí
<strong>PATH</strong>.</div></p>

<p>Taktéž si můžeme přímo v&nbsp;interaktivní smyčce Pythonu naimportovat
některou třídu z&nbsp;tohoto balíčku (například <strong>FastMCP</strong>) a
zobrazit si její nápovědu:</p>

<pre>
$ <strong>python</strong>
&nbsp;
Python 3.12.9 (main, Feb  4 2025, 00:00:00) [GCC 14.2.1 20240912 (Red Hat 14.2.1-3)] on linux
Type "help", "copyright", "credits" or "license" for more information.
&gt;&gt;&gt; from mcp.server.fastmcp import FastMCP
&gt;&gt;&gt; help(FastMCP)
</pre>

<p>S&nbsp;výsledkem:</p>

<pre>
Help on class FastMCP in module mcp.server.fastmcp.server:

class FastMCP(builtins.object)
 |  FastMCP(name: 'str | None' = None, instructions: 'str | None' = None, **settings: 'Any')
 |
 |  Methods defined here:
 |
 |  __init__(self, name: 'str | None' = None, instructions: 'str | None' = None, **settings: 'Any')
 |      Initialize self.  See help(type(self)) for accurate signature.
 |
 |  add_prompt(self, prompt: 'Prompt') -&gt; 'None'
 |      Add a prompt to the server.
 |
 |      Args:
 |          prompt: A Prompt instance to add
 |
 |  add_resource(self, resource: 'Resource') -&gt; 'None'
 |      Add a resource to the server.
 |
 |      Args:
 |          resource: A Resource instance to add
 |
 ...
 ...
 ...
</pre>



<p><a name="k04"></a></p>
<h2 id="k04">4. Instalace nástrojů nutných pro spuštění MCP Inspectoru</h2>

<p>Balíček <strong>mcp</strong>, který jsme právě nainstalovali, nabízí možnost
využití takzvaného <i>MCP Inspectoru</i>, což je aplikace s&nbsp;webovým
grafickým uživatelským rozhraním, kterou lze použít pro otestování MCP serverů.
Tato aplikace vyžaduje instalaci <strong>npm</strong> a
<strong>node.js</strong>. Distribuce Linuxu většinou tyto nástroje mají ve
svých repositářích balíčků (i když možná ne nejnovější verze, což nám ale
nemusí vadit), takže jejich instalace je jednoduchá. Pro distribuce založené na
RPM lze použít například:</p>

<pre>
$ <strong>dnf install npm</strong>
&nbsp;
$ <strong>dnf install nodejs</strong>
</pre>

<p>Pro jistotu si otestujeme, jestli jsou tyto nástroje skutečně
nainstalovány:</p>

<pre>
$ <strong>npm --version</strong>
10.8.2
&nbsp;
&nbsp;
$ <strong>node --version</strong>
v20.18.2
</pre>

<p>V&nbsp;případě, že se vypsaly verze (mohou být i nepatrně starší) jak
<strong>npm</strong>, tak i <strong>node.js</strong>, mělo by být možné <i>MCP
Inspector</i> použít.</p>



<p><a name="k05"></a></p>
<h2 id="k05">5. Implementace jednoduchého MCP serveru s&nbsp;jediným definovaným zdrojem</h2>

<p>Pokusme se nyní naprogramovat nějaký velmi jednoduchý MCP server,
tj.&nbsp;službu, která dokáže komunikovat s&nbsp;klienty právě přes protokol
MCP. V&nbsp;tomto serveru je definován pouze jediný zdroj (<i>resource</i>)
nazvaný <strong>pozdrav</strong>, jenž je implementován pomocí běžné
Pythonovské funkce s&nbsp;dekorátorem. Jedná se o zdroj, který vrací konstantní
řetězec. Samotný zdroj je popsán dekorátorem <strong>@mcp.resource</strong> a
typ hodnoty, kterou zdroj vrací, je odvozena na základě typové informace (jméno
typu za šipkou definuje typ návratové hodnoty funkce):</p>

<pre>
<i>"""Jednoduchý MCP server s jediným definovaným zdrojem."""</i>
&nbsp;
from mcp.server.fastmcp import FastMCP
&nbsp;
<i># konstrukce serveru</i>
mcp = FastMCP("Test")
&nbsp;
&nbsp;
<u>@mcp.resource("pozdrav://")</u>
def <strong>pozdrav</strong>() -&gt; str:
    <i>"""Odpověď s pozdravem."""</i>
    return "Hello, dear client"
</pre>

<p><div class="rs-tip-major">Poznámka: připomeňme si, že dekorátory jsou
interně implementovány jako funkce vyššího řádu, které &bdquo;obalují&ldquo;
funkci, před kterou jsou zapsány &ndash; typicky před volání a za volání funkce
přidávají nějaký další kód popř.&nbsp;zajišťují vytvoření uzávěru
(<i>closure</i>). Pro potřeby tohoto článku nám však bude stačit jen základní
znalosti o tom, jak se dekorátory zapisují.</div></p>



<p><a name="k06"></a></p>
<h2 id="k06">6. Spuštění serveru s&nbsp;jeho otestováním pomocí MCP Inspectoru</h2>

<p>MCP server, jehož zdrojový kód jsme si ukázali <a
href="#k05">v&nbsp;předchozí kapitole</a>, je možné spustit několika možnými
způsoby. Nejjednodušší je použití příkazu <strong>mcp</strong>, kterému se
předá jméno zdrojového kódu s&nbsp;implementací serveru a popř.&nbsp;i způsob
transportu (tedy konkrétního režimu komunikace mezi klientem a serverem). Ovšem
my prozatím nemáme naprogramován žádný klient, takže je nutné využít nějaký
jiný nástroj pro otestování našeho serveru. Takový nástroj ve skutečnosti
existuje a jmenuje se <i>MCP Inspector</i> (ostatně jsme instalovali jeho
závislosti). Pro otestování našeho serveru spustíme následující příkaz (ten
očekává, že jméno zdrojového kódu s&nbsp;implementací MCP serveru je
<strong>mcp_server_1.py</strong>):</p>

<pre>
$ <strong>mcp dev mcp_server_1.py</strong>
</pre>

<p>Při prvním spuštění (později již ne) bude <strong>mcp</strong> potřebovat
doinstalovat jeden npm balíček, takže se zeptá, zda může tuto operaci spustit.
Odpovíme, že ano:</p>

<pre>
Need to install the following packages:
@modelcontextprotocol/inspector@0.7.0
Ok to proceed? (y) y
</pre>

<p>Dále se vypíše informace o tom, na které adrese (včetně portu) je MCP
inspektor dostupný:</p>

<pre>
Starting MCP inspector...
Proxy server listening on port 3000
&nbsp;
🔍 MCP Inspector is up and running at http://localhost:5173 🚀
</pre>

<p>Ve webovém prohlížeči je nutné přejít na výše vypsanou adresu <a
href="http://localhost:5173">http://localhost:5173</a>. Měla by se zobrazit
stránka, která v&nbsp;levé části nabízí způsob připojení k&nbsp;serveru.
Vyplňte nyní údaje tak, jak je to zobrazeno na screenshotu:</p>

<a href="https://www.root.cz/obrazek/1182531/"><img src="https://i.iinfo.cz/images/328/mcp1-1-prev.webp" class="image-1182531" width="191" height="270" data-prev-filename="https://i.iinfo.cz/images/328/mcp1-1-prev.webp" data-prev-width="191" data-prev-height="270" data-large-filename="https://i.iinfo.cz/images/328/mcp1-1-large.webp" data-large-width="372" data-large-height="525" alt="MCP" data-description="&#160;" title="Autor: tisnik, podle licence: &lt;a href=&quot;http://en.wikipedia.org/wiki/Rights_Managed&quot;&gt;Rights Managed&lt;/a&gt;" /></a>
<p><i>Obrázek 1: Takto může vypadat vyplněný dialog pro připojení k&nbsp;MCP
serveru.</i></p>

<p>Po stisku tlačítka <strong>Connect</strong> by se měl server znovu spustit
(to je poněkud nešťastné) a MCP Inspector by měl začít se serverem komunikovat
přes standardní vstup a výstup (STDIO).</p>

<p>Dále v&nbsp;části <i>Resources</i> stiskněte tlačítko <strong>List
Resources</strong>. Měl by se zobrazit seznam zdrojů, který obsahuje pouze
jedinou položku &bdquo;pozdrav://&ldquo;, což je skutečně název našeho
zdroje:</p>

<a href="https://www.root.cz/obrazek/1182534/"><img src="https://i.iinfo.cz/images/328/mcp1-2-prev.webp" class="image-1182534" width="370" height="269" data-prev-filename="https://i.iinfo.cz/images/328/mcp1-2-prev.webp" data-prev-width="370" data-prev-height="269" data-large-filename="https://i.iinfo.cz/images/328/mcp1-2.webp" data-large-width="456" data-large-height="332" alt="MCP" data-description="&#160;" title="Autor: tisnik, podle licence: &lt;a href=&quot;http://en.wikipedia.org/wiki/Rights_Managed&quot;&gt;Rights Managed&lt;/a&gt;" /></a>
<p><i>Obrázek 2: Seznam dostupných zdrojů, které MCP server nabízí.</i></p>

<p>Pokud tento zdroj vyberete, provede se komunikace s&nbsp;MCP serverem a měla
by se vrátit odpověď v&nbsp;JSON formátu:</p>

<pre>
{
  "contents": [
    {
      "uri": "pozdrav://",
      "mimeType": "text/plain",
      "text": "Hello, dear client"
    }
  ]
}
</pre>

<p>Tím jsme ověřili nejenom to, že MCP server nabízí příslušný zdroj, ale že je
možné s&nbsp;ním komunikovat s&nbsp;využitím MCP.</p>



<p><a name="k07"></a></p>
<h2 id="k07">7. MCP server s&nbsp;definovaným dynamickým zdrojem (<i>resource template</i>)</h2>

<p>Druhá varianta MCP serveru, kterou vytvoříme, bude nepatrně složitější,
protože je v&nbsp;ní definován dynamický zdroj (původní název <i>resource
template</i> ovšem může být poněkud matoucí). Jedná se o zdroj, který má ve
svém názvu měnitelnou část (<i>selector</i>) <strong>name</strong>. Výsledkem
čtení tohoto zdroje bude řetězec ve formátu &bdquo;Hello, {name}&ldquo;, ve
kterém se za &bdquo;{name}&ldquo; doplní identifikátor ze jména zdroje.
Teoreticky tedy můžeme tímto způsobem předávat MCP serveru parametry a získávat
odpovědi na základě těchto parametrů, i když z&nbsp;hlediska sémantiky by bylo
v&nbsp;mnoha případech vhodnější využít spíše nástroje (<i>tools</i>),
s&nbsp;nimiž se seznámíme v&nbsp;dalších kapitolách. Povšimněte si, že nyní má
funkce <strong>pozdrav</strong> s&nbsp;implementací zdroje parametr
<strong>name</strong>, který je typu řetězec:</p>

<pre>
<i>"""Jednoduchý MCP server s jediným definovaným dynamickým zdrojem."""</i>
&nbsp;
from mcp.server.fastmcp import FastMCP
&nbsp;
<i># konstrukce serveru</i>
mcp = FastMCP("Test")
&nbsp;
&nbsp;
<u>@mcp.resource("pozdrav://{name}")</u>
def <strong>pozdrav</strong>(name: str) -&gt; str:
    <i>"""Odpověď s osobním pozdravem."""</i>
    return f"Hello, {name}"
</pre>

<p><div class="rs-tip-major">Poznámka: na třech řádcích zdrojového kódu jsou
tedy uvedeny všechny důležité informace o zdroji, které jsou zapotřebí pro
realizaci komunikace. Řádek s&nbsp;dekorátorem identifikuje zdroj i jeho
měnitelné části (<i>selectoru</i>), na řádku s&nbsp;hlavičkou funkce je pak
možné zjistit datové typy vstupů (měnitelných částí) i datový typ odpovědi. A
komentář (dokumentační řetězec) samotné funkce je zobrazen v&nbsp;MCP
Inspectoru.</div></p>



<p><a name="k08"></a></p>
<h2 id="k08">8. Otestování nové varianty MCP serveru</h2>

<p>Opět si otestujeme základní funkcionalitu druhé varianty našeho MCP serveru.
Podobně jako v&nbsp;prvním případě i nyní spustíme MCP Inspector se zadáním
jména zdrojového kódu s&nbsp;implementací serveru:</p>

<pre>
$ <strong>mcp dev mcp_server_2.py</strong>
&nbsp;
Starting MCP inspector...
Proxy server listening on port 3000
&nbsp;
🔍 MCP Inspector is up and running at http://localhost:5173 🚀
</pre>

<p>Ve webovém prohlížeči otevřeme stránku na adrese <a
href="http://localhost:5173">http://localhost:5173</a>. V&nbsp;prvním kroku se
k&nbsp;MCP serveru připojíme, přičemž parametry připojení mohou vypadat
následovně:</p>

<a href="https://www.root.cz/obrazek/1182537/"><img src="https://i.iinfo.cz/images/328/mcp1-3-prev.webp" class="image-1182537" width="184" height="270" data-prev-filename="https://i.iinfo.cz/images/328/mcp1-3-prev.webp" data-prev-width="184" data-prev-height="270" data-large-filename="https://i.iinfo.cz/images/328/mcp1-3-large.webp" data-large-width="358" data-large-height="525" alt="MCP" data-description="&#160;" title="Autor: tisnik, podle licence: &lt;a href=&quot;http://en.wikipedia.org/wiki/Rights_Managed&quot;&gt;Rights Managed&lt;/a&gt;" /></a>
<p><i>Obrázek 3: Parametry připojení k&nbsp;MCP serveru. Zelené kolečko u
&bdquo;Connected&ldquo; naznačuje, že MCP Inspector skutečně navázal
připojení.</i></p>

<p>Nyní ovšem zdroj definovaný v&nbsp;MCP serveru nenalezneme v&nbsp;sekci
&bdquo;Resources&ldquo;, ale v&nbsp;sekci nazvané &bdquo;Resource
Templates&ldquo;. Vypíšeme si obsah těchto zdrojů s&nbsp;měnitelnou částí:</p>

<a href="https://www.root.cz/obrazek/1182540/"><img src="https://i.iinfo.cz/images/328/mcp1-4-prev.webp" class="image-1182540" width="331" height="270" data-prev-filename="https://i.iinfo.cz/images/328/mcp1-4-prev.webp" data-prev-width="331" data-prev-height="270" data-large-filename="https://i.iinfo.cz/images/328/mcp1-4.webp" data-large-width="480" data-large-height="391" alt="MCP" data-description="&#160;" title="Autor: tisnik, podle licence: &lt;a href=&quot;http://en.wikipedia.org/wiki/Rights_Managed&quot;&gt;Rights Managed&lt;/a&gt;" /></a>
<p><i>Obrázek 4: Seznam zdrojů se selektory.</i></p>

<p>Vybereme (jediný) takový zdroj a zadáme potřebný selektor:</p>

<a href="https://www.root.cz/obrazek/1182543/"><img src="https://i.iinfo.cz/images/328/mcp1-5-prev.webp" class="image-1182543" width="331" height="270" data-prev-filename="https://i.iinfo.cz/images/328/mcp1-5-prev.webp" data-prev-width="331" data-prev-height="270" data-large-filename="https://i.iinfo.cz/images/328/mcp1-5.webp" data-large-width="480" data-large-height="391" alt="MCP" data-description="&#160;" title="Autor: tisnik, podle licence: &lt;a href=&quot;http://en.wikipedia.org/wiki/Rights_Managed&quot;&gt;Rights Managed&lt;/a&gt;" /></a>
<p><i>Obrázek 5: Zápis selektoru a získání zdroje z&nbsp;MCP serveru.
Povšimněte si, že se v&nbsp;popisu zdroje objevuje komentář z&nbsp;funkce,
kterou je zdroj implementován.</i></p>

<p>Výsledkem by měla být následující datová struktura. Povšimněte si, že do ní
bylo skutečně doplněno předané jméno (tedy onen selektor):</p>

<pre>
{
  "contents": [
    {
      "uri": "pozdrav://Pavel",
      "mimeType": "text/plain",
      "text": "Hello, Pavel"
    }
  ]
}
</pre>

<a href="https://www.root.cz/obrazek/1182546/"><img src="https://i.iinfo.cz/images/328/mcp1-6-prev.webp" class="image-1182546" width="331" height="270" data-prev-filename="https://i.iinfo.cz/images/328/mcp1-6-prev.webp" data-prev-width="331" data-prev-height="270" data-large-filename="https://i.iinfo.cz/images/328/mcp1-6.webp" data-large-width="480" data-large-height="391" alt="MCP" data-description="&#160;" title="Autor: tisnik, podle licence: &lt;a href=&quot;http://en.wikipedia.org/wiki/Rights_Managed&quot;&gt;Rights Managed&lt;/a&gt;" /></a>
<p><i>Obrázek 6: Odpověď MCP serveru zobrazená přímo v&nbsp;MCP
Inspectoru.</i></p>



<p><a name="k09"></a></p>
<h2 id="k09">9. Zdroj vracející strukturovaná data</h2>

<p>Pokusme se nyní definovat poněkud složitější zdroj. Ten bude mít dva
selektory, které jsou oddělené pomlčkou (ovšem stejně dobře je možné použít
lomítko &ndash; RFC 6570 umožňuje více způsobů). Ovšem zajímavější je, že tento
zdroj vrací pro zadané jméno a příjmení spisovatele seznam jeho knih,
tj.&nbsp;v&nbsp;pojetí jazyka Python <strong>list</strong>. Můžete být ovšem i
přesnější a definovat i seznam slovníků atd. &ndash; využívají se zde totiž
standardizované typové informace (<i>type hints</i>). Pro jednoduchost není
seznam knih získáván z&nbsp;databáze, ale pro jakéhokoli autora vrátíme stejný
seznam, takže implementace MCP serveru by mohla vypadat takto:</p>

<pre>
<i>"""Jednoduchý MCP server s jediným definovaným dynamickým zdrojem."""</i>
&nbsp;
from mcp.server.fastmcp import FastMCP
&nbsp;
<i># konstrukce serveru</i>
mcp = FastMCP("Test")
&nbsp;
&nbsp;
<u>@mcp.resource("author://{name}-{surname}")</u>
def author(name: str, surname: str) -&gt; list:
    <i>"""Knihy od vybraného autora."""</i>
    return [
        {"name": name, "surname": surname, "title": "Foo", "year": 1900},
        {"name": name, "surname": surname, "title": "Bar", "year": 2005},
        {"name": name, "surname": surname, "title": "Baz", "year": 2025},
    ]
</pre>

<p>Po připojení k&nbsp;MCP serveru se pokusíme získat seznam knih pro autora se
jménem John a příjmením Doe. Povšimněte si, že samotná odpověď MCP serveru je
sice ve formátu JSON, ovšem to se týká strukturování odpovědi tak, že dostaneme
i různá metadata. Ovšem vlastní data jsou předána v&nbsp;parametru
<strong>text</strong> ve formě slovníku serializovaného do řetězce:</p>

<pre>
{
  "contents": [
    {
      "uri": "author://John-Doe",
      "mimeType": "text/plain",
      "text": "[{\"name\": \"John\", \"surname\": \"Doe\", \"title\": \"Foo\", \"year\": 1900}, {\"name\": \"John\", \"surname\": \"Doe\", \"title\": \"Bar\", \"year\": 2005}, {\"name\": \"John\", \"surname\": \"Doe\", \"title\": \"Baz\", \"year\": 2025}]"
    }
  ]
}
</pre>

<p>Bude výsledek odlišný v&nbsp;případě, že zvolíme jiný formát odpovědi, tedy
odlišný <i>mimeType</i>? To si můžeme snadno otestovat nepatrnou změnou MCP
serveru:</p>

<pre>
<i>"""Jednoduchý MCP server s jediným definovaným dynamickým zdrojem."""</i>
&nbsp;
from mcp.server.fastmcp import FastMCP
&nbsp;
<i># konstrukce serveru</i>
mcp = FastMCP("Test")
&nbsp;
&nbsp;
<u>@mcp.resource("author://{name}-{surname}", mime_type="application/json")</u>
def <strong>author</strong>(name: str, surname: str) -&gt; list:
    <i>"""Knihy od vybraného autora."""</i>
    return [
        {"name": name, "surname": surname, "title": "Foo", "year": 1900},
        {"name": name, "surname": surname, "title": "Bar", "year": 2005},
        {"name": name, "surname": surname, "title": "Baz", "year": 2025},
    ]
</pre>

<p>Odpověď je až na odlišný <i>mimeType</i> totožná s&nbsp;předchozí
implementací:</p>

<pre>
{
  "contents": [
    {
      "uri": "author://John-Doe",
      "mimeType": "application/json",
      "text": "[{\"name\": \"John\", \"surname\": \"Doe\", \"title\": \"Foo\", \"year\": 1900}, {\"name\": \"John\", \"surname\": \"Doe\", \"title\": \"Bar\", \"year\": 2005}, {\"name\": \"John\", \"surname\": \"Doe\", \"title\": \"Baz\", \"year\": 2025}]"
    }
  ]
}
</pre>

<p><div class="rs-tip-major">Poznámka: jedná se o nedostatek knihovny
<strong>mcp</strong> &ndash; viz též <a
href="https://github.com/modelcontextprotocol/python-sdk/issues/279">Return
resources as structured JSON instead of text?</a>.</div></p>



<p><a name="k10"></a></p>
<h2 id="k10">10. Server s&nbsp;definicí nástroje (<i>tool</i>)</h2>

<p>Zdroje (<i>resources</i>) slouží resp.&nbsp;měly by sloužit jako zdroj dat a
jejich chování by mělo být idempotentní. To znamená, že několikeré volání toho
samého zdroje se stejnými selektory by mělo vracet totožné výsledky. Ovšem
v&nbsp;oblasti AI a LLM je nutné volat resp.&nbsp;spouštět složitější operace,
které provádí nějakou komplikovanější činnost a obecně nejsou idempotentní
(třeba nákup letenky nebo rezervace schůzky do kalendáře). Pro tento účel
slouží ve světě MCP takzvané nástroje (<i>tool</i>), které se začaly dosti
bouřlivým způsobem vyvíjet v&nbsp;posledních cca deseti měsících &ndash;
protože právě díky nástrojům se z&nbsp;původních &bdquo;kecálků&ldquo; typu
ChatGTP stávají reálně použitelná rozhraní mezi lidmi a IT systémy (více si
řekneme v&nbsp;samostatném článku &ndash; toto je opravdu velmi dynamická
oblast).</p>

<p>Vytvoření MCP serveru s&nbsp;nástrojem může být snadné. Abychom si to
ukázali, naprogramujeme server, který má kromě zdroje definován i nástroj
nazvaný <strong>factorial</strong>. Tento nástroj akceptuje celé číslo poslané
v&nbsp;dotazu a odpoví hodnotou faktoriálu tohoto čísla. Pro jednoduchost jsem
zvolil tu nejsnadnější implementaci výpočtu. Nejde nám totiž o vlastní výpočet,
ale o realizaci komunikace přes MCP:</p>

<pre>
<i>"""MCP server s dynamickým zdrojem a definicí nástroje (tool)."""</i>
&nbsp;
from mcp.server.fastmcp import FastMCP
&nbsp;
<i># konstrukce serveru</i>
mcp = FastMCP("Test")
&nbsp;
&nbsp;
<u>@mcp.tool()</u>
def <strong>factorial</strong>(n: int) -&gt; int:
    <i>"""Výpočet faktoriálu ve smyčce."""</i>
    f = 1
    for x in range(1, n + 1):
        f *= x
    return f
&nbsp;
&nbsp;
<u>@mcp.resource("pozdrav://{name}")</u>
def <strong>pozdrav</strong>(name: str) -&gt; str:
    <i>"""Odpověď s osobním pozdravem."""</i>
    return f"Hello, {name}"
</pre>



<p><a name="k11"></a></p>
<h2 id="k11">11. Otestování MCP serveru s&nbsp;voláním nástroje</h2>

<p>Pro otestování nové varianty MCP serveru opět spustíme MCP Inspectora:</p>

<pre>
$ <strong>mcp dev mcp_server_3.py </strong>
&nbsp;
Starting MCP inspector...
Proxy server listening on port 3000
&nbsp;
🔍 MCP Inspector is up and running at http://localhost:5173 🚀
</pre>

<p>Po otevření stránky s&nbsp;MCP Inspectorem a připojení k&nbsp;MCP serveru
známým způsobem je nutné v&nbsp;horní části stránky se seznamem záložek vybrat
záložku nazvanou <i>Tools</i> (ve výchozím stavu je vybrána záložka
<i>Resources</i>, kterou jsme používali doposud). Ukáže se menu s&nbsp;položkou
(tlačítkem) <strong>List Tools</strong> a po jeho stisku by se měl zobrazit
název nástroje i jeho popis získaný z&nbsp;dokumentačního řetězce funkce, ve
které je nástroj implementován:</p>

<a href="https://www.root.cz/obrazek/1182549/"><img src="https://i.iinfo.cz/images/328/mcp1-7-prev.webp" class="image-1182549" width="370" height="262" data-prev-filename="https://i.iinfo.cz/images/328/mcp1-7-prev.webp" data-prev-width="370" data-prev-height="262" data-large-filename="https://i.iinfo.cz/images/328/mcp1-7.webp" data-large-width="717" data-large-height="507" alt="MCP" data-description="&#160;" title="Autor: tisnik, podle licence: &lt;a href=&quot;http://en.wikipedia.org/wiki/Rights_Managed&quot;&gt;Rights Managed&lt;/a&gt;" /></a>
<i>Obrázek 7: Seznam nástrojů, které nabízí MCP server.</i>

<p>Nástroj vybereme a do zobrazeného dialogu zadáme vstupní parametr, který je
poslán do nástroje, jenž na základě tohoto parametru (celé číslo) vypočítá
faktoriál. Výsledek je vrácen formou jediné hodnoty, což znamená, že není nutné
parsovat odpověď v&nbsp;JSONu:</p>

<a href="https://www.root.cz/obrazek/1182552/"><img src="https://i.iinfo.cz/images/328/mcp1-8-prev.webp" class="image-1182552" width="370" height="262" data-prev-filename="https://i.iinfo.cz/images/328/mcp1-8-prev.webp" data-prev-width="370" data-prev-height="262" data-large-filename="https://i.iinfo.cz/images/328/mcp1-8.webp" data-large-width="717" data-large-height="507" alt="MCP" data-description="&#160;" title="Autor: tisnik, podle licence: &lt;a href=&quot;http://en.wikipedia.org/wiki/Rights_Managed&quot;&gt;Rights Managed&lt;/a&gt;" /></a>
<i>Obrázek 8: Volání nástroje s&nbsp;předáním parametru. Vypočtená hodnota je
vrácena do MCP Inspectoru, kde je taktéž zobrazena.</i>



<p><a name="k12"></a></p>
<h2 id="k12">12. Složitější MCP servery s&nbsp;několika zdroji a/nebo nástroji</h2>

<p>Typicky bývá v&nbsp;MCP serveru realizováno větší množství zdrojů a
popř.&nbsp;nástrojů. Ukažme si příklad, jak by mohla implementace takového
serveru vypadat. Ve variantě MCP serveru zobrazené pod tímto odstavcem je
definován nástroj pojmenovaný <strong>factorial</strong>, který známe. A dále
se zde nachází definice dvou zdrojů, které oba začínají URI
&bdquo;pozdrav://&ldquo;. Ovšem první z&nbsp;těchto zdrojů nemá selektor (URI
je neměnné), zatímco u druhého zdroje je selektor specifikován a musí být
použit při čtení tohoto zdroje:</p>

<pre>
<i>"""MCP server se zdrojem,  dynamickým zdrojem a definicí nástroje (tool)."""</i>
&nbsp;
from mcp.server.fastmcp import FastMCP
&nbsp;
<i># konstrukce serveru</i>
mcp = FastMCP("Test")
&nbsp;
&nbsp;
<u>@mcp.tool()</u>
def <strong>factorial</strong>(n: int) -&gt; int:
    <i>"""Výpočet faktoriálu ve smyčce."""</i>
    f = 1
    for x in range(1, n + 1):
        f *= x
    return f
&nbsp;
&nbsp;
<u>@mcp.resource("pozdrav://")</u>
def <strong>pozdrav1</strong>() -&gt; str:
    <i>"""Odpověď s pozdravem."""</i>
    return "Hello, dear client"
&nbsp;
&nbsp;
<u>@mcp.resource("pozdrav://{name}")</u>
def <strong>pozdrav2</strong>(name: str) -&gt; str:
    <i>"""Odpověď s osobním pozdravem."""</i>
    return f"Hello, {name}"
</pre>

<p><div class="rs-tip-major">Poznámka: pro otestování tohoto MCP serveru je
pochopitelně opět možné využít MCP Inspector. Postup zůstává stále stejný,
takže ho již nebudu popisovat a ani nebudou ukázány příslušné
screenshoty.</div></p>



<p><a name="k13"></a></p>
<h2 id="k13">13. Jak MCP Inspector spouští MCP server?</h2>

<p>V&nbsp;předchozích kapitolách jsme si řekli, že MCP Inspector se dokáže sám
připojit k&nbsp;MCP serveru. Ovšem současně jsme tento MCP server spustili i
přímo příkazem <strong>mcp</strong>. Bylo by tedy zajímavé zjistit, co se děje
&bdquo;pod pokličkou&ldquo;. Naši implementaci MCP serveru tedy upravíme do
takové podoby, aby se při každém jeho spuštění vytvořil soubor, jehož jméno
bude odpovídat číslu procesu. Tak zjistíme, kolikrát se vlastně MCP
inicializoval. Poněkud naivní implementace tohoto MCP serveru může vypadat
následovně:</p>

<pre>
<i>"""Jednoduchý MCP server s jediným definovaným dynamickým zdrojem."""</i>
&nbsp;
import os
from mcp.server.fastmcp import FastMCP
from datetime import datetime
&nbsp;
<i># konstrukce serveru</i>
mcp = FastMCP("Test")
&nbsp;
pid = os.getpid()
&nbsp;
<i># při každém spuštění serveru se vytvoří nový soubor</i>
with open(f"{pid}.txt", "w") as fout:
    fout.write(str(datetime.now()))
&nbsp;
&nbsp;
<u>@mcp.resource("pozdrav://")</u>
def <strong>pozdrav</strong>() -&gt; str:
    <i>"""Odpověď s pozdravem."""</i>
    return "Hello, dear client"
</pre>

<p>Opět provedeme spuštění MCP Inspectoru:</p>

<pre>
$ <strong>mcp dev mcp_server_4.py</strong>
</pre>

<p>Výsledek bude jediný soubor s&nbsp;PID, který značí, že server byl spuštěn,
i když jsme se k&nbsp;němu nepřipojili:</p>

<pre>
3288345.txt
</pre>

<p>Nyní soubor smažeme, opět spustíme MCP Inspector a připojíme se
k&nbsp;serveru (<i>connect</i>). Výsledkem bude dvojice souborů, protože byl
server spuštěný dvakrát:</p>

<pre>
3288553.txt
3288667.txt
</pre>

<p>Ovšem získání (resp.&nbsp;přesněji řečeno přečtení) jednotlivých zdrojů atd.
již nevede ke spuštění nového MCP serveru &ndash; vše je obslouženo jediným
serverem, který bude běžet až do té doby, dokud nedojde ke vzniku nezachycené
výjimky nebo pokud server explicitně neukončíme (Ctrl+C).</p>



<p><a name="k14"></a></p>
<h2 id="k14">14. Přímé spuštění MCP serveru z&nbsp;příkazové řádky s&nbsp;transportem STDIO</h2>

<p>Spouštění MCP serveru nepřímo přes nástroj MCP Inspector je vhodné provádět
jen v&nbsp;průběhu jeho vývoje a ladění. Ovšem nasazení takového serveru může
vypadat odlišně. V&nbsp;tom nejjednodušším případě můžeme server spustit přímo
z&nbsp;interpretru Pythonu, tj.&nbsp;bez použití příkazu <strong>mcp</strong>.
Do zdrojového kódu MCP serveru je v&nbsp;takovém případě pouze nutné přidat
programové řádky, které ho spustí. V&nbsp;základní podobě se MCP serveru spustí
s&nbsp;volbou transportu STDIO, tj.&nbsp;se serverem se bude komunikovat přes
vstupně-výstupní proudy (standard input stream, standard output stream):</p>

<pre>
<i># přímé spuštění serveru v režimu STDIO</i>
if __name__ == "__main__":
    mcp.run()
</pre>

<p>Celý zdrojový kód serveru se změní jen nepatrně &ndash; přidali jsme do něj
tři výše uvedené řádky zajišťující jeho spuštění:</p>

<pre>
<i>"""MCP server se zdrojem,  dynamickým zdrojem a definicí nástroje (tool)."""</i>
&nbsp;
from mcp.server.fastmcp import FastMCP
&nbsp;
<i># konstrukce serveru</i>
mcp = FastMCP("Test")
&nbsp;
&nbsp;
<u>@mcp.tool()</u>
def <strong>factorial</strong>(n: int) -&gt; int:
    <i>"""Výpočet faktoriálu ve smyčce."""</i>
    f = 1
    for x in range(1, n + 1):
        f *= x
    return f
&nbsp;
&nbsp;
<u>@mcp.resource("pozdrav://")</u>
def <strong>pozdrav1</strong>() -&gt; str:
    <i>"""Odpověď s pozdravem."""</i>
    return "Hello, dear client"
&nbsp;
&nbsp;
<u>@mcp.resource("pozdrav://{name}")</u>
def <strong>pozdrav2</strong>(name: str) -&gt; str:
    <i>"""Odpověď s osobním pozdravem."""</i>
    return f"Hello, {name}"
&nbsp;
&nbsp;
<i># přímé spuštění serveru v režimu STDIO</i>
if __name__ == "__main__":
    mcp.run()
</pre>

<p><div class="rs-tip-major">Poznámka: s&nbsp;takovým serverem se většinou
nekomunikuje přímo interaktivním zadáváním příkazů a dotazů, i když i to je
možné (používá se JSON RPC).</div></p>



<p><a name="k15"></a></p>
<h2 id="k15">15. Přímé spuštění MCP serveru z&nbsp;příkazové řádky s&nbsp;transportem SSE</h2>

<p>Druhým podporovaným transportem je SSE neboli <i>Server Sent Events</i>.
V&nbsp;tomto případě MCP server naslouchá na IP portu a odpovídá na dotazy  MCP
klientů popř.&nbsp;přímo sám posílá události těmto klientům (nejedná se tedy o
triviální komunikaci typu dotaz-odpověď, ale o komunikaci oboustrannou). Aby se
MCP server spustil v&nbsp;režimu transportu SSE, je možné ho spustit tímto
způsobem:</p>

<pre>
<i># přímé spuštění serveru v režimu SSE (Server-Sent Events)</i>
if __name__ == "__main__":
    mcp.run(transport="sse")
</pre>

<p><div class="rs-tip-major">Poznámka: popř.&nbsp;je možné specifikovat i port,
na kterém má MCP server naslouchat.</div></p>

<p>Upravený zdrojový kód MCP serveru vypadá takto:</p>

<pre>
<i>"""MCP server se zdrojem,  dynamickým zdrojem a definicí nástroje (tool)."""</i>
&nbsp;
from mcp.server.fastmcp import FastMCP
&nbsp;
<i># konstrukce serveru</i>
mcp = FastMCP("Test")
&nbsp;
&nbsp;
<u>@mcp.tool()</u>
def <strong>factorial</strong>(n: int) -&gt; int:
    <i>"""Výpočet faktoriálu ve smyčce."""</i>
    f = 1
    for x in range(1, n + 1):
        f *= x
    return f
&nbsp;
&nbsp;
<u>@mcp.resource("pozdrav://")</u>
def <strong>pozdrav1</strong>() -&gt; str:
    <i>"""Odpověď s pozdravem."""</i>
    return "Hello, dear client"
&nbsp;
&nbsp;
<u>@mcp.resource("pozdrav://{name}")</u>
def <strong>pozdrav2</strong>(name: str) -&gt; str:
    <i>"""Odpověď s osobním pozdravem."""</i>
    return f"Hello, {name}"
&nbsp;
&nbsp;
<i># přímé spuštění serveru v režimu SSE (Server-Sent Events)</i>
if __name__ == "__main__":
    mcp.run(transport="sse")
</pre>

<p>I bez podrobnějších znalostí protokolu, který se pro komunikaci mezi MCP
serverem a MCP klientem používá, si můžeme ověřit alespoň to, že server je
skutečně spuštěn a naslouchá na portu. Server tedy spustíme:</p>

<pre>
$ <strong>python mcp_server_6.py</strong>
</pre>

<p>Výchozím portem je 8000, takže v&nbsp;dalším terminálu provedeme připojení
k&nbsp;serveru s&nbsp;využitím (například) známého nástroje
<strong>curl</strong>:</p>

<pre>
$ <strong>curl localhost:8000/sse</strong>
</pre>

<p>MCP server by měl odpovědět tak, že pošle zpátky ID sezení (<i>session</i>), které lze použít pro další komunikaci:</p>

<pre>
event: endpoint
data: /messages/?session_id=e233fdbae32d43b29c1d3fd9b58d9145
</pre>

<p>Navíc není spojení ihned ukončeno (připomínám: nejedná se o klasický systém
dotaz-odpověď). Pokud nástroj <strong>curl</strong> neukončíme, bude patrné, že
server po určitých časových intervalech cca 15 sekund posílá zprávy
<strong>ping</strong>, aby si ověřil připojení klienta:</p>

<pre>
: ping - 2025-03-30 09:26:17.741441+00:00
&nbsp;
: ping - 2025-03-30 09:26:32.743079+00:00
&nbsp;
: ping - 2025-03-30 09:26:47.744446+00:00
&nbsp;
: ping - 2025-03-30 09:27:02.746181+00:00
</pre>

<p><div class="rs-tip-major">Poznámka: použití MCP na takto nízké úrovni
většinou není nutné znát, protože máme k&nbsp;dispozici knihovny zajišťující
komunikaci na vyšší úrovni abstrakce. Ovšem v&nbsp;případech, že se například
klienti nemohou připojit nebo nevidí nějaký zdroj či nástroj, může být výhodné
znát i tyto nízkoúrovňové postupy. Ostatně se k&nbsp;nim ještě vrátíme
v&nbsp;navazujícím článku.</div></p>



<p><a name="k16"></a></p>
<h2 id="k16">16. MCP klient spouštějící server s&nbsp;komunikací přes STDIO</h2>

<p>V&nbsp;této chvíli již máme základní znalosti o tom, jakým způsobem se
implementují MCP servery. Ovšem s&nbsp;těmito servery jsme komunikovali buď
přes MCP Inspectora nebo z&nbsp;příkazové řádky (viz výše uvedený příkaz
<strong>curl</strong>). V&nbsp;praxi se ovšem k&nbsp;MCP serverům takřka
výhradně připojují další naprogramované služby a nástroje &ndash; MCP klienti.
Ukažme si tedy, jak by mohl vypadat jednoduchý MCP klient, který po svém
spuštění vypíše seznam zdrojů, nástrojů atd. nabízených MCP serverem. Přímo
v&nbsp;kódu klienta nebudeme se serverem komunikovat na úrovni MCP protokolu,
ale na vyšší úrovni abstrakce (ostatně ani v&nbsp;implementaci serveru jsme
s&nbsp;protokolem přímo nepřišli do styku). MCP klient navíc server sám spustí
v&nbsp;režimu používajícím transport STDIO:</p>

<pre>
<i># parametry pro spuštění MCP serveru</i>
server_params = StdioServerParameters(
    command="python",  <i># spustí se tento příkaz</i>
    args=["mcp_server_5.py"],  <i># a předají se mu následující parametry</i>
    env=None,  <i># lze definovat i proměnné prostředí</i>
)
</pre>

<p>Jak je ze zdrojového kódu klienta patrné, je realizován takovým způsobem, že
veškeré operace jsou v&nbsp;něm prováděny asynchronně (v&nbsp;Pythonu se pro
tento účel používají klíčová slova <strong>async</strong> a
<strong>await</strong>).  Klient získá seznamy všech zdrojů atd. a vypíše je na
standardní výstup:</p>

<pre>
<i>"""MCP klient, který spustí server, se kterým se komunikuje přes STDIO."""</i>
&nbsp;
from mcp import ClientSession, StdioServerParameters
from mcp.client.stdio import stdio_client
&nbsp;
<i># parametry pro spuštění MCP serveru</i>
server_params = StdioServerParameters(
    command="python",  <i># spustí se tento příkaz</i>
    args=["mcp_server_5.py"],  <i># a předají se mu následující parametry</i>
    env=None,  <i># lze definovat i proměnné prostředí</i>
)
&nbsp;
&nbsp;
async def <strong>run</strong>():
    <i>"""Realizace klienta."""</i>
    async with <u>stdio_client(server_params)</u> as (read, write):
        async with ClientSession(read, write) as session:
            await session.initialize()
&nbsp;
            prompts = await session.list_prompts()
            print(prompts)
&nbsp;
            resources = await session.list_resources()
            print(resources)
&nbsp;
            templates = await session.list_resource_templates()
            print(templates)
&nbsp;
            tools = await session.list_tools()
            print(tools)
&nbsp;
&nbsp;
<i># přímé spuštění klienta</i>
if __name__ == "__main__":
    import asyncio
&nbsp;
    asyncio.run(run())
</pre>

<p>Tento klient spustíme:</p>

<pre>
$ <strong>python mcp_client_1.py</strong>
</pre>

<p>Klient po své inicializaci sám automaticky spustí příslušný MCP server (má
k&nbsp;tomu všechny potřebné informace), získá seznam dostupných zdrojů atd. a
ten vytiskne. Poté je ukončen.</p>

<p>Vypsané informace by měly vypadat přesně takto:</p>

<pre>
meta=None nextCursor=None prompts=[]
meta=None nextCursor=None resources=[Resource(uri=AnyUrl('pozdrav://'), name='pozdrav://', description=None, mimeType='text/plain', size=None, annotations=None)]
meta=None nextCursor=None resourceTemplates=[ResourceTemplate(uriTemplate='pozdrav://{name}', name='pozdrav2', description='Odpověď s osobním pozdravem.', mimeType=None, annotations=None)]
meta=None nextCursor=None tools=[Tool(name='factorial', description='Výpočet faktoriálu ve smyčce.', inputSchema={'properties': {'n': {'title': 'N', 'type': 'integer'}}, 'required': ['n'], 'title': 'factorialArguments', 'type': 'object'})]
</pre>



<p><a name="k17"></a></p>
<h2 id="k17">17. MCP klient s&nbsp;komunikací přes SSE</h2>

<p>Druhou možností komunikace mezi MCP serverem a MCP klientem je využití
transportu SSE (<i>Server-side events</i>). V&nbsp;tomto případě je možné MCP
server inicializovat ještě před spuštěním klienta. Jak se tato inicializace
provede jsme si ukázali <a href="#k15">v&nbsp;patnácté kapitole</a>.
Předpokládejme tedy, že MCP server je inicializován a naslouchá na portu 8000.
Klient se může k&nbsp;takovému serveru připojit způsobem, který lze
naprogramovat následovně:</p>

<pre>
<i>"""MCP klient, který spustí server, se kterým se komunikuje přes SSE."""</i>
&nbsp;
from mcp import ClientSession
from mcp.client.sse import sse_client
&nbsp;
&nbsp;
async def <strong>run</strong>():
    <i>"""Realizace klienta."""</i>
    async with <u>sse_client(url="http://localhost:8000/sse")</u> as (read, write):
        async with ClientSession(read, write) as session:
            await session.initialize()
&nbsp;
            prompts = await session.list_prompts()
            print(prompts)
&nbsp;
            resources = await session.list_resources()
            print(resources)
&nbsp;
            templates = await session.list_resource_templates()
            print(templates)
&nbsp;
            tools = await session.list_tools()
            print(tools)
&nbsp;
&nbsp;
<i># přímé spuštění klienta</i>
if __name__ == "__main__":
    import asyncio
&nbsp;
    asyncio.run(run())
</pre>

<p>Od klienta <a href="#k16">z&nbsp;předchozí kapitoly</a> se tedy tento klient
odlišuje pouze odlišným kontextem:</p>

<pre>
    async with <u>sse_client(url="http://localhost:8000/sse")</u> as (read, write):
</pre>

<p><div class="rs-tip-major">Poznámka: ovšem nepočítejte s&nbsp;tím, že MCP
server dokáže současně obsloužit větší množství požadavků. Tímto problémem se
budeme zabývat v&nbsp;navazujícím článku.</div></p>



<p><a name="k18"></a></p>
<h2 id="k18">18. Klient, který přečte zdroj z&nbsp;MCP serveru</h2>

<p>MCP klienti dokážou číst jakékoli zdroje nabízené MCP serverem, volat
v&nbsp;nich definované nástroje (<i>tools</i>) atd. V&nbsp;dnešním posledním
demonstračním příkladu si ukážeme způsob přečtení zdroje (pro jednoduchost
prozatím zdroje bez selektoru). Komunikace s&nbsp;MCP serverem bude opět
probíhat asynchronně:</p>

<pre>
<i>"""MCP klient, který přečte zvolený zdroj."""</i>
&nbsp;
from mcp import ClientSession, StdioServerParameters
from mcp.client.stdio import stdio_client
&nbsp;
<i># parametry pro spuštění MCP serveru</i>
server_params = StdioServerParameters(
    command="python",  <i># spustí se tento příkaz</i>
    args=["mcp_server_5.py"],  <i># a předají se mu následující parametry</i>
    env=None,  <i># lze definovat i proměnné prostředí</i>
)
&nbsp;
&nbsp;
async def <strong>run</strong>():
    <i>"""Realizace klienta."""</i>
    async with <u>stdio_client(server_params)</u> as (read, write):
        async with ClientSession(read, write) as session:
            await session.initialize()
&nbsp;
            <i># přečtení zdroje</i>
            data = await session.read_resource("pozdrav://")
            print("Data returned:", data)
            print("Type:", type(data))
&nbsp;
&nbsp;
<i># přímé spuštění klienta</i>
if __name__ == "__main__":
    import asyncio
&nbsp;
    asyncio.run(run())
</pre>

<p>Po spuštění tohoto klienta se inicializuje MCP server, provede se přečtení
zdroje <strong>pozdrav://</strong> a následně dojde k&nbsp;ukončení činnosti
jak serveru, tak posléze i klienta:</p>

<pre>
Data returned: meta=None contents=[TextResourceContents(uri=AnyUrl('pozdrav://'), mimeType='text/plain', text='Hello, dear client')]
Type: &lt;class 'mcp.types.ReadResourceResult'&gt;
</pre>

<p><div class="rs-tip-major">Poznámka: sofistikovanější příklady si ukážeme
příště.</div></p>



<p><a name="k19"></a></p>
<h2 id="k19">19. Repositář s&nbsp;demonstračními příklady</h2>

<p>Zdrojové kódy všech prozatím popsaných demonstračních příkladů určených pro
Python a balíček <a
href="https://github.com/modelcontextprotocol/python-sdk">mcp</a> byly uloženy
do repositáře dostupného na adrese <a
href="https://github.com/tisnik/most-popular-python-libs">https://github.com/tisnik/most-popular-python-libs</a>.
V&nbsp;tabulce zobrazené níže jsou odkazy na jednotlivé příklady:</p>

<table>
<tr><th> #</th><th>Demonstrační příklad</th><th>Stručný popis příkladu</th><th>Cesta</th></tr>
<tr><td> 1</td><td>mcp_server_1.py</td><td>jednoduchý MCP server s&nbsp;jediným definovaným zdrojem</td><td><a href="https://github.com/tisnik/most-popular-python-libs/blob/master/mcp/mcp_server_1.py">https://github.com/tisnik/most-popular-python-libs/blob/master/mcp/mcp_server_1.py</a></td></tr>
<tr><td> 2</td><td>mcp_server_2.py</td><td>jednoduchý MCP server s&nbsp;jediným definovaným dynamickým zdrojem</td><td><a href="https://github.com/tisnik/most-popular-python-libs/blob/master/mcp/mcp_server_2.py">https://github.com/tisnik/most-popular-python-libs/blob/master/mcp/mcp_server_2.py</a></td></tr>
<tr><td> 3</td><td>mcp_server_3.py</td><td>MCP server s&nbsp;dynamickým zdrojem a definicí nástroje (tool)</td><td><a href="https://github.com/tisnik/most-popular-python-libs/blob/master/mcp/mcp_server_3.py">https://github.com/tisnik/most-popular-python-libs/blob/master/mcp/mcp_server_3.py</a></td></tr>
<tr><td> 4</td><td>mcp_server_4.py</td><td>MCP server s jediným definovaným dynamickým zdrojem, zápis informací o spuštění</td><td><a href="https://github.com/tisnik/most-popular-python-libs/blob/master/mcp/mcp_server_4.py">https://github.com/tisnik/most-popular-python-libs/blob/master/mcp/mcp_server_4.py</a></td></tr>
<tr><td> 5</td><td>mcp_server_5.py</td><td>MCP server, který se přímo spustí v&nbsp;režimu STDIO</td><td><a href="https://github.com/tisnik/most-popular-python-libs/blob/master/mcp/mcp_server_5.py">https://github.com/tisnik/most-popular-python-libs/blob/master/mcp/mcp_server_5.py</a></td></tr>
<tr><td> 6</td><td>mcp_server_6.py</td><td>MCP server, který se přímo spustí v&nbsp;režimu SSE</td><td><a href="https://github.com/tisnik/most-popular-python-libs/blob/master/mcp/mcp_server_6.py">https://github.com/tisnik/most-popular-python-libs/blob/master/mcp/mcp_server_6.py</a></td></tr>
<tr><td> 7</td><td>mcp_server_7.py</td><td>MCP server se zdrojem vracejícím strukturovaná data</td><td><a href="https://github.com/tisnik/most-popular-python-libs/blob/master/mcp/mcp_server_7.py">https://github.com/tisnik/most-popular-python-libs/blob/master/mcp/mcp_server_7.py</a></td></tr>
<tr><td> 8</td><td>mcp_server_8.py</td><td>MCP server se zdrojem vracejícím strukturovaná data</td><td><a href="https://github.com/tisnik/most-popular-python-libs/blob/master/mcp/mcp_server_8.py">https://github.com/tisnik/most-popular-python-libs/blob/master/mcp/mcp_server_8.py</a></td></tr>
<tr><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td></tr>
<tr><td> 9</td><td>mcp_client_1.py</td><td>MCP klient, který spustí server, se kterým se komunikuje přes STDIO</td><td><a href="https://github.com/tisnik/most-popular-python-libs/blob/master/mcp/mcp_client_1.py">https://github.com/tisnik/most-popular-python-libs/blob/master/mcp/mcp_client_1.py</a></td></tr>
<tr><td>10</td><td>mcp_client_2.py</td><td>MCP klient, který spustí server, se kterým se komunikuje přes SSE</td><td><a href="https://github.com/tisnik/most-popular-python-libs/blob/master/mcp/mcp_client_2.py">https://github.com/tisnik/most-popular-python-libs/blob/master/mcp/mcp_client_2.py</a></td></tr>
<tr><td>11</td><td>mcp_client_3.py</td><td>MCP klient, který přečte zvolený zdroj</td><td><a href="https://github.com/tisnik/most-popular-python-libs/blob/master/mcp/mcp_client_3.py">https://github.com/tisnik/most-popular-python-libs/blob/master/mcp/mcp_client_3.py</a></td></tr>
<tr><td>12</td><td>mcp_client_4.py</td><td>MCP klient, který přečte zvolený zdroj a získá z&nbsp;něj data</td><td><a href="https://github.com/tisnik/most-popular-python-libs/blob/master/mcp/mcp_client_4.py">https://github.com/tisnik/most-popular-python-libs/blob/master/mcp/mcp_client_4.py</a></td></tr>
<tr><td>13</td><td>mcp_client_5.py</td><td>MCP klient, který zavolá vybraný nástroj</td><td><a href="https://github.com/tisnik/most-popular-python-libs/blob/master/mcp/mcp_client_5.py">https://github.com/tisnik/most-popular-python-libs/blob/master/mcp/mcp_client_5.py</a></td></tr>
<tr><td>14</td><td>mcp_client_6.py</td><td>MCP klient, který přečte a zpracuje strukturovaná data</td><td><a href="https://github.com/tisnik/most-popular-python-libs/blob/master/mcp/mcp_client_6.py">https://github.com/tisnik/most-popular-python-libs/blob/master/mcp/mcp_client_6.py</a></td></tr>
</table>



<p><a name="k20"></a></p>
<h2 id="k20">20. Odkazy na Internetu</h2>

<ol>

<li>MCP Python SDK<br />
<a href="https://github.com/modelcontextprotocol/python-sdk?tab=readme-ov-file#running-your-server">https://github.com/modelcontextprotocol/python-sdk?tab=readme-ov-file#running-your-server</a>
</li>

<li>MCP protocol: Resources<br />
<a href="https://modelcontextprotocol.info/docs/concepts/resources/">https://modelcontextprotocol.info/docs/concepts/resources/</a>
</li>

<li>Example Servers<br />
<a href="https://modelcontextprotocol.io/examples">https://modelcontextprotocol.io/examples</a>
</li>

<li>Core architecture<br />
<a href="https://modelcontextprotocol.io/docs/concepts/architecture">https://modelcontextprotocol.io/docs/concepts/architecture</a>
</li>

<li>Unleashing the Power of Model Context Protocol (MCP): A Game-Changer in AI Integration<br />
<a href="https://techcommunity.microsoft.com/blog/educatordeveloperblog/unleashing-the-power-of-model-context-protocol-mcp-a-game-changer-in-ai-integrat/4397564">https://techcommunity.microsoft.com/blog/educatordeveloperblog/unleashing-the-power-of-model-context-protocol-mcp-a-game-changer-in-ai-integrat/4397564</a>
</li>

<li>MPC inspector<br />
<a href="https://github.com/modelcontextprotocol/inspector">https://github.com/modelcontextprotocol/inspector</a>
</li>

<li>Model Context Protocol servers<br />
<a href="https://github.com/modelcontextprotocol/servers">https://github.com/modelcontextprotocol/servers</a>
</li>

<li>python-sdk na GitHubu<br />
<a href="https://github.com/modelcontextprotocol/python-sdk">https://github.com/modelcontextprotocol/python-sdk</a>
</li>

<li>typescript-sdk na GitHubu<br />
<a href="https://github.com/modelcontextprotocol/typescript-sdk">https://github.com/modelcontextprotocol/typescript-sdk</a>
</li>

<li>mcp-golang<br />
<a href="https://github.com/metoro-io/mcp-golang">https://github.com/metoro-io/mcp-golang</a>
</li>

<li>MCP server: A step-by-step guide to building from scratch<br />
<a href="https://composio.dev/blog/mcp-server-step-by-step-guide-to-building-from-scrtch/">https://composio.dev/blog/mcp-server-step-by-step-guide-to-building-from-scrtch/</a>
</li>

<li>How to Build an MCP Server Fast: A Step-by-Step Tutorial<br />
<a href="https://medium.com/@eugenesh4work/how-to-build-an-mcp-server-fast-a-step-by-step-tutorial-e09faa5f7e3b">https://medium.com/@eugenesh4work/how-to-build-an-mcp-server-fast-a-step-by-step-tutorial-e09faa5f7e3b</a>
</li>

<li>Step-by-Step Guide: Building an MCP Server using Python-SDK, AlphaVantage &amp; Claude AI<br />
<a href="https://medium.com/@syed_hasan/step-by-step-guide-building-an-mcp-server-using-python-sdk-alphavantage-claude-ai-7a2bfb0c3096">https://medium.com/@syed_hasan/step-by-step-guide-building-an-mcp-server-using-python-sdk-alphavantage-claude-ai-7a2bfb0c3096</a>
</li>

<li>RFC 6570: URI Template<br />
<a href="https://datatracker.ietf.org/doc/html/rfc6570">https://datatracker.ietf.org/doc/html/rfc6570</a>
</li>

<li>Return resources as structured JSON instead of text?<br />
<a href="https://github.com/modelcontextprotocol/python-sdk/issues/279">https://github.com/modelcontextprotocol/python-sdk/issues/279</a>
</li>

<li>Python standard library: pprint<br />
<a href="https://docs.python.org/3/library/pprint.html">https://docs.python.org/3/library/pprint.html</a>
</li>

<li>Python standard library: json — JSON encoder and decoder¶<br />
<a href="https://docs.python.org/3/library/json.html">https://docs.python.org/3/library/json.html</a>
</li>

<li>Calling MCP Servers the Hard Way<br />
<a href="https://deadprogrammersociety.com/2025/03/calling-mcp-servers-the-hard-way.html">https://deadprogrammersociety.com/2025/03/calling-mcp-servers-the-hard-way.html</a>
</li>

<li>mcptools<br />
<a href="https://github.com/f/mcptools">https://github.com/f/mcptools</a>
</li>

<li>Server-sent events<br />
<a href="https://en.wikipedia.org/wiki/Server-sent_events">https://en.wikipedia.org/wiki/Server-sent_events</a>
</li>

</ol>



<p></p><p></p>
<p><small>Autor: <a href="https://github.com/tisnik/">Pavel Tišnovský</a> &nbsp; 2024</small></p>
</body>
</html>

