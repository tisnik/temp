<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
        "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html>
<head>
<title>Trasování a ladění nativních aplikací v Linuxu: pokročilejší možnosti nabízené GNU Debuggerem</title>
<meta name="Author" content="Pavel Tisnovsky" />
<meta name="Generator" content="vim" />
<meta http-equiv="content-type" content="text/html; charset=utf-8" />
<style type="text/css">
         body {color:#000000; background:#ffffff;}
         h1  {font-family: arial, helvetica, sans-serif; color:#ffffff; background-color:#c00000; text-align:center; padding-left:1em}
         h2  {font-family: arial, helvetica, sans-serif; color:#ffffff; background-color:#0000c0; padding-left:1em; text-align:left}
         h3  {font-family: arial, helvetica, sans-serif; color:#000000; background-color:#c0c0c0; padding-left:1em; text-align:left}
         h4  {font-family: arial, helvetica, sans-serif; color:#000000; background-color:#e0e0e0; padding-left:1em; text-align:left}
         a   {font-family: arial, helvetica, sans-serif;}
         li  {font-family: arial, helvetica, sans-serif; color:#000000; text-align:justify; width:450px;}
         ol  {font-family: arial, helvetica, sans-serif; color:#000000; text-align:justify; width:450px;}
         ul  {font-family: arial, helvetica, sans-serif; color:#000000; text-align:justify; width:450px;}
         p   {font-family: arial, helvetica, sans-serif; color:#000000; text-align:justify;}
         pre {background:#e0e0e0}
</style>
</head>

<body>

<h1>Trasování a ladění nativních aplikací v Linuxu: pokročilejší možnosti nabízené GNU Debuggerem</h1>

<h3>Pavel Tišnovský</h3>

<p></p>

<h1>Úvodník</h1>

<p>Ve třetí části seriálu o trasování a ladění nativních aplikací v&nbsp;Linuxu se seznámíme s&nbsp;tím, jaké možnosti vývojářům nabízí GNU Debugger v&nbsp;případě, že je zapotřebí ladit aplikaci až na úrovni jednotlivých strojových instrukcí popř.&nbsp;pracovních registrů mikroprocesoru.</p>



<h2>Obsah</h2>

<p><a href="#k01">1. Trasování a ladění nativních aplikací v&nbsp;Linuxu: pokročilejší možnosti nabízené GNU Debuggerem</a></p>
<p><a href="#k02">2. Ladění aplikací naprogramovaných v&nbsp;assembleru</a></p>
<p><a href="#k03">3. Překlad aplikace v&nbsp;assembleru se zachováním ladicích informací</a></p>
<p><a href="#k04">4. Tabulka symbolů</a></p>
<p><a href="#k05">5. Načtení aplikace naprogramované v&nbsp;assembleru do GNU Debuggeru</a></p>
<p><a href="#k06">6. Disassembler v&nbsp;GNU Debuggeru</a></p>
<p><a href="#k07">7. Přepnutí režimu zobrazení instrukcí: syntaxe AT&amp;T versus Intel</a></p>
<p><a href="#k08">8. Nastavení breakpointů a krokování po instrukcích</a></p>
<p><a href="#k09">9. Zobrazení obsahu pracovních registrů</a></p>
<p><a href="#k10">10. Zobrazení obsahu vybrané části operační paměti</a></p>
<p><a href="#k11">11. Formátování zobrazovaných dat</a></p>
<p><a href="#k12">12. Užitečný příkaz <strong>display</strong></a></p>
<p><a href="#k13">13. Praktický příklad a použití TUI</a></p>
<p><a href="#k14">14. Odkazy na Internetu</a></p>



<p><a name="k01"></a></p>
<h2 id="k01">1. Trasování a ladění nativních aplikací v&nbsp;Linuxu: pokročilejší možnosti nabízené GNU Debuggerem</h2>

<p><a
href="http://www.root.cz/clanky/trasovani-a-ladeni-nativnich-aplikaci-v-linuxu-pouziti-gdb-a-jeho-nadstaveb/">V&nbsp;předchozí
části</a> seriálu o trasování a ladění nativních aplikací jsme se seznámili se
základními možnostmi a příkazy nabízenými <i>GNU Debuggerem</i>. Připomeňme si,
že se jednalo například o příkaz <strong>list</strong> (zkráceně
<strong>l</strong>) určený pro zobrazení zvolené části zdrojového kódu laděné
aplikace, dále pak o práci s&nbsp;breakpointy (příkaz <strong>break</strong>,
zkráceně <strong>b</strong>), krokování po jednotlivých řádcích či se vstupem
do volané funkce (příkazy <strong>next</strong> a <strong>step</strong>) a
v&nbsp;neposlední řadě taktéž o příkaz <strong>frame</strong> sloužící pro
zobrazení vybraných zásobníkových rámců. Již s&nbsp;těmito několika příkazy,
pokud se doplní o univerzální příkazy <strong>print</strong>,
<strong>run</strong> a <strong>continue</strong>, je možné celkem bez větších
problémů odladit i rozsáhlejší aplikaci naprogramovanou v&nbsp;nějakém vyšším
programovacím jazyce (typicky v&nbsp;Céčku či C++). Ovšem ve chvíli, kdy nemáme
k&nbsp;dispozici zdrojový kód (ladění některých ovladačů umístěných
v&nbsp;<i>blobech</i>), chybí ladicí informace, popř.&nbsp;je aplikace
naprogramovaná v&nbsp;assembleru, je nutné použít i některé další příkazy,
s&nbsp;nimiž se seznámíme v&nbsp;dnešním článku.</p>



<p><a name="k02"></a></p>
<h2 id="k02">2. Ladění aplikací naprogramovaných v&nbsp;assembleru</h2>

<p>Aby bylo možné si vyzkoušet všechny dále popisované funkce nabízené GNU
Debuggerem v&nbsp;praxi, vytvoříme si velmi jednoduchou aplikaci
naprogramovanou v&nbsp;assembleru procesorů řady i386 či x86-64. Používat
budeme pouze ty pracovní registry, které jsou kompatibilní s&nbsp;32bitovou
architekturou i386, což ostatně platí i pro volání funkcí Linuxového jádra.
Aplikace je velmi jednoduchá a skládá se ze tří částí (ty by bylo možné
rozepsat do subrutin či vkládaných maker, ovšem nebudeme aplikaci zbytečně
komplikovat). V&nbsp;části první se v&nbsp;počítané programové smyčce vytvoří
pole znaků od 'a' do 'z' (nejedná se přitom o klasický řetězec, protože pole
nemusí být ukončeno znakem \0, to je jen konvence, kterou zde potřebovat
nebudeme). V&nbsp;části druhé je výsledné pole vytištěno na standardní výstup
s&nbsp;využitím syscallu <strong>sys_write</strong>. Část třetí pouze aplikaci
korektně ukončí, a to opět s&nbsp;využitím syscallu, tentokrát syscallu
nazvaného <strong>sys_exit</strong>. Vzhledem k&nbsp;tomu, že většina(?)
programátorů, co pracují s&nbsp;assemblerem na procesorech řady i386 a x86-64,
zná a preferuje Intel syntaxi, je celá aplikace napsána právě s&nbsp;využitím
této syntaxe (viz zvýrazněná pseudoinstrukce, která syntaxi přepíná):</p>

<pre>
<i># asmsyntax=as</i>
&nbsp;
<i># Testovaci program naprogramovany v assembleru GNU as</i>
<i># - pouzita je "Intel" syntaxe.</i>
<i>#</i>
<i># Autor: Pavel Tisnovsky</i>
&nbsp;
<strong>.intel_syntax noprefix</strong>
&nbsp;
&nbsp;
<i># Linux kernel system call table</i>
sys_exit=1
sys_write=4
&nbsp;
&nbsp;
&nbsp;
<i>#-----------------------------------------------------------------------------</i>
.section .data
&nbsp;
&nbsp;
&nbsp;
<i>#-----------------------------------------------------------------------------</i>
.section .bss
        .lcomm buffer, 26            <i># rezervace bufferu pro vystup</i>
&nbsp;
&nbsp;
&nbsp;
<i>#-----------------------------------------------------------------------------</i>
.section .text
        .global _start               <i># tento symbol ma byt dostupny i linkeru</i>
&nbsp;
_start:
        mov   ecx, offset buffer     <i># zapis se bude provadet do tohoto bufferu</i>
        mov   al, 'a'                <i># kod prvniho zapisovaneho znaku</i>
loop:
        mov   [ecx], al              <i># zapis znaku do bufferu</i>
        inc   al                     <i># ASCII kod dalsiho znaku</i>
        inc   ecx                    <i># uprava ukazatele do bufferu</i>
        cmp   al, 'z'                <i># ma se smycka ukoncit?</i>
        jna   loop                   <i># pokud jsme neprekrocili kod 'z', opakovat smycku</i>
&nbsp;
        mov   eax, sys_write         <i># cislo syscallu pro funkci "write"</i>
        mov   ebx, 1                 <i># standardni vystup</i>
        mov   ecx, offset buffer     <i># adresa retezce, ktery se ma vytisknout</i>
        mov   edx, 26                <i># pocet znaku, ktere se maji vytisknout</i>
        int   0x80                   <i># volani Linuxoveho kernelu</i>
&nbsp;
        mov   eax, sys_exit          <i># cislo sycallu pro funkci "exit"</i>
        mov   ebx, 0                 <i># exit code = 0</i>
        int   0x80                   <i># volani Linuxoveho kernelu</i>
</pre>



<p><a name="k03"></a></p>
<h2 id="k03">3. Překlad aplikace v&nbsp;assembleru se zachováním ladicích informací</h2>

<p>Proces vytvoření spustitelného binárního souboru je rozdělen do dvou kroků.
V&nbsp;kroku prvním se použije nástroj zvaný <i>assembler</i> (konkrétně <i>GNU
Assembler</i>) pro vygenerování objektového kódu. Povšimněte si použití
přepínače <strong>--gstabs+</strong>, který zajistí, že se do objektového kódu
vloží i všechny symboly potřebné pro ladění a tudíž i pro GNU Debugger:</p>

<pre>
as --gstabs+ test.s -o test.o
</pre>

<p>Tyto symboly sice (mnohdy dosti podstatným způsobem) zvětšují velikost
výsledného spustitelného souboru, ovšem na samotný výkon aplikace nemají větší
vliv (tato část se ani nemusí načítat do operační paměti):</p>

<table>
<tr><th>Přeloženo</th><th>Velikost</th></tr>
<tr><td>bez ladicích symbolů</td><td>1071 bajtů</td></tr>
<tr><td>s&nbsp;ladicími symboly</td><td>1503 bajtů</td></tr>
<tr><td>po <strong>strip</strong><td>512 bajtů</td></td></tr>
</table>

<p>Pokud budete chtít později všechny ladicí informace odstranit, může se
použít příkaz <strong>strip</strong> nebo alternativně provést nový překlad,
tentokrát bez použití zmíněného přepínače. Po překladu následuje druhá fáze
&ndash; slinkování. Tato fáze je v&nbsp;naší demonstrační aplikaci velmi
jednoduchá, neboť není nutné ani spojit více objektových kódů, ani použít
knihovnu (voláme totiž přímo funkce jádra):</p>

<pre>
ld test.o
</pre>

<p>Nyní si samozřejmě můžete program vyzkoušet:</p>

<pre>
<strong>./a.out</strong>
&nbsp;
abcdefghijklmnopqrstuvwxyz
</pre>



<p><a name="k04"></a></p>
<h2 id="k04">4. Tabulka symbolů</h2>

<p>Pokud vás zajímá, jak vypadá interní struktura vytvořeného spustitelného
souboru a jaké (ladicí i jiné) symboly tento soubor obsahuje, můžete použít
následující příkaz, který všechny potřebné informace dokáže získat a zobrazit
v&nbsp;čitelné podobě. Nejzajímavější je v&nbsp;tomto okamžiku struktura
nazvaná <i>SYMBOL TABLE</i>:</p>

<pre>
<strong>objdump -f -d -t -h a.out</strong>
&nbsp;
a.out:     file format elf64-x86-64
architecture: i386:x86-64, flags 0x00000112:
EXEC_P, HAS_SYMS, D_PAGED
start address 0x00000000004000b0
&nbsp;
Sections:
Idx Name          Size      VMA               LMA               File off  Algn
  0 .text         00000034  00000000004000b0  00000000004000b0  000000b0  2**0
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  1 .bss          00000020  00000000006000e8  00000000006000e8  000000e8  2**3
                  ALLOC
  2 .stab         000000d8  0000000000000000  0000000000000000  000000e4  2**2
                  CONTENTS, READONLY, DEBUGGING
  3 .stabstr      0000001b  0000000000000000  0000000000000000  000001bc  2**0
                  CONTENTS, READONLY, DEBUGGING
SYMBOL TABLE:
00000000004000b0 l    d  .text  0000000000000000 .text
00000000006000e8 l    d  .bss   0000000000000000 .bss
0000000000000000 l    d  .stab  0000000000000000 .stab
0000000000000000 l    d  .stabstr       0000000000000000 .stabstr
0000000000000000 l    df *ABS*  0000000000000000 test.o
0000000000000001 l       *ABS*  0000000000000000 sys_exit
0000000000000004 l       *ABS*  0000000000000000 sys_write
00000000006000e8 l     O .bss   000000000000001a buffer
00000000004000b7 l       .text  0000000000000000 loop
0000000000000000 l    df *ABS*  0000000000000000 
00000000004000b0 g       .text  0000000000000000 _start
00000000006000e4 g       .bss   0000000000000000 __bss_start
00000000006000e4 g       .bss   0000000000000000 _edata
0000000000600108 g       .bss   0000000000000000 _end
&nbsp;
&nbsp;
&nbsp;
Disassembly of section .text:
&nbsp;
00000000004000b0 &lt;_start&gt;:
  4000b0:       b9 e8 00 60 00          mov    $0x6000e8,%ecx
  4000b5:       b0 61                   mov    $0x61,%al
&nbsp;
00000000004000b7 &lt;loop&gt;;
  4000b7:       67 88 01                mov    %al,(%ecx)
  4000ba:       fe c0                   inc    %al
  4000bc:       ff c1                   inc    %ecx
  4000be:       3c 7a                   cmp    $0x7a,%al
  4000c0:       76 f5                   jbe    4000b7 <loop>
  4000c2:       b8 04 00 00 00          mov    $0x4,%eax
  4000c7:       bb 01 00 00 00          mov    $0x1,%ebx
  4000cc:       b9 e8 00 60 00          mov    $0x6000e8,%ecx
  4000d1:       ba 1a 00 00 00          mov    $0x1a,%edx
  4000d6:       cd 80                   int    $0x80
  4000d8:       b8 01 00 00 00          mov    $0x1,%eax
  4000dd:       bb 00 00 00 00          mov    $0x0,%ebx
  4000e2:       cd 80                   int    $0x80
</pre>

<p>Při spuštění stejného příkazu, ovšem nad binárním souborem bez ladicích
symbolů (po <strong>strip</strong>), bude výpis vypadat zcela jinak:</p>

<pre>
<strong>objdump -f -d -t -h a.out</strong>
&nbsp;
a.out:     file format elf64-x86-64
architecture: i386:x86-64, flags 0x00000102:
EXEC_P, D_PAGED
start address 0x00000000004000b0
&nbsp;
Sections:
Idx Name          Size      VMA               LMA               File off  Algn
  0 .text         00000034  00000000004000b0  00000000004000b0  000000b0  2**0
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  1 .bss          00000020  00000000006000e8  00000000006000e8  000000e8  2**3
                  ALLOC
SYMBOL TABLE:
no symbols
&nbsp;
&nbsp;
&nbsp;
Disassembly of section .text:
&nbsp;
00000000004000b0 &lt;.text&gt;:
  4000b0:       b9 e8 00 60 00          mov    $0x6000e8,%ecx
  4000b5:       b0 61                   mov    $0x61,%al
  4000b7:       67 88 01                mov    %al,(%ecx)
  4000ba:       fe c0                   inc    %al
  4000bc:       ff c1                   inc    %ecx
  4000be:       3c 7a                   cmp    $0x7a,%al
  4000c0:       76 f5                   jbe    0x4000b7
  4000c2:       b8 04 00 00 00          mov    $0x4,%eax
  4000c7:       bb 01 00 00 00          mov    $0x1,%ebx
  4000cc:       b9 e8 00 60 00          mov    $0x6000e8,%ecx
  4000d1:       ba 1a 00 00 00          mov    $0x1a,%edx
  4000d6:       cd 80                   int    $0x80
  4000d8:       b8 01 00 00 00          mov    $0x1,%eax
  4000dd:       bb 00 00 00 00          mov    $0x0,%ebx
  4000e2:       cd 80                   int    $0x80
</pre>

<p>Alternativně si můžete zobrazit všechny řetězce, mezi nimiž lze nalézt jak
jména jednotlivých sekcí (<strong>.text</strong>, <strong>.bss</strong>), tak i
návěští (<strong>_start</strong>, <strong>loop</strong>) i pojmenované symboly
(<strong>sys_write</strong>, <strong>sys_exit</strong>):</p>

<pre>
<strong>strings a.out</strong>
&nbsp;
test.s
/home/tester/temp/
.symtab
.strtab
.shstrtab
.text
.bss
.stab
.stabstr
test.o
sys_exit
sys_write
buffer
loop
_start
__bss_start
_edata
_end
</pre>



<p><a name="k05"></a></p>
<h2 id="k05">5. Načtení aplikace naprogramované v&nbsp;assembleru do GNU Debuggeru</h2>

<p>Následně se můžeme pokusit o jeho analýzu, krokování a ladění naší testovací
aplikace přímo v&nbsp;prostředí GNU Debuggeru, popř.&nbsp;v&nbsp;jeho TUI
(textovém uživatelském rozhraní). GNU Debugger spustíme obvyklým způsobem,
který již známe z&nbsp;předchozí části tohoto seriálu:</p>

<pre>
<strong>gdb a.out</strong>
</pre>

<p>Důležité je, aby se na posledním řádku úvodní zprávy GNU Debuggeru vypsala
informace o tom, že se úspěšně načetly všechny ladicí informace:</p>

<pre>
GNU gdb (Ubuntu 7.7.1-0ubuntu5~14.04.2) 7.7.1
Copyright (C) 2014 Free Software Foundation, Inc.
License GPLv3+: GNU GPL version 3 or later &lt;http://gnu.org/licenses/gpl.html&gt;
This is free software: you are free to change and redistribute it.
There is NO WARRANTY, to the extent permitted by law.  Type "show copying"
and "show warranty" for details.
This GDB was configured as "x86_64-linux-gnu".
Type "show configuration" for configuration details.
For bug reporting instructions, please see:
&lt;http://www.gnu.org/software/gdb/bugs/&gt;.
Find the GDB manual and other documentation resources online at:
&lt;http://www.gnu.org/software/gdb/documentation/&gt;.
For help, type "help".
Type "apropos word" to search for commands related to "word"...
<strong>Reading symbols from a.out...done.</strong>
</pre>

<p>Pokud se pouze zobrazí následující zprávy:</p>

<pre>
GNU gdb (Ubuntu 7.7.1-0ubuntu5~14.04.2) 7.7.1
Copyright (C) 2014 Free Software Foundation, Inc.
License GPLv3+: GNU GPL version 3 or later &lt;http://gnu.org/licenses/gpl.html&gt;
This is free software: you are free to change and redistribute it.
There is NO WARRANTY, to the extent permitted by law.  Type "show copying"
and "show warranty" for details.
This GDB was configured as "x86_64-linux-gnu".
Type "show configuration" for configuration details.
For bug reporting instructions, please see:
&lt;http://www.gnu.org/software/gdb/bugs/&gt;.
Find the GDB manual and other documentation resources online at:
&lt;http://www.gnu.org/software/gdb/documentation/&gt;.
For help, type "help".
Type "apropos word" to search for commands related to "word"...
<strong>Reading symbols from a.out...(no debugging symbols found)...done.</strong>
</pre>

<p>... znamená to, že assembler do objektového kódu nepřidal ladicí symboly,
došlo k&nbsp;jejich odstranění při linkování, nebo byl použit příkaz
<strong>strip</strong>, který tyto symboly odstranil kdykoli později.
Samozřejmě je možné ladit a krokovat i program bez přidaných ladicích symbolů
(někdy je to dokonce nutné), celý postup je však nepatrně složitější, protože
se například ztratí informace o všech návěštích (<i>labels</i>), jménech
volaných subrutin apod.</p>



<p><a name="k06"></a></p>
<h2 id="k06">6. Disassembler v&nbsp;GNU Debuggeru</h2>

<p>Při práci na úrovni jednotlivých instrukcí velmi často využijeme příkaz
<strong>disassemble</strong>, který lze zkrátit například na
<strong>disas</strong> (ještě kratší zápis již nelze použít, neboť by jméno
příkazu kolidovalo s&nbsp;příkazem <strong>disable</strong>). Za příkazem
<strong>disassemble</strong> je možné uvést návěští, například:</p>

<pre>
(gdb) <strong>disassemble _start</strong>
Dump of assembler code for function _start:
   0x00000000004000b0 &lt;+0&gt;:     mov    $0x6000e8,%ecx
   0x00000000004000b5 &lt;+5&gt;:     mov    $0x61,%al
End of assembler dump.
</pre>

<p>nebo:</p>

<pre>
(gdb) <strong>disassemble loop</strong>
Dump of assembler code for function loop:
   0x00000000004000b7 &lt;+0&gt;:     mov    %al,(%ecx)
   0x00000000004000ba &lt;+3&gt;:     inc    %al
   0x00000000004000bc &lt;+5&gt;:     inc    %ecx
   0x00000000004000be &lt;+7&gt;:     cmp    $0x7a,%al
   0x00000000004000c0 &lt;+9&gt;:     jbe    0x4000b7 &lt;loop&gt;
   0x00000000004000c2 &lt;+11&gt;:    mov    $0x4,%eax
   0x00000000004000c7 &lt;+16&gt;:    mov    $0x1,%ebx
   0x00000000004000cc &lt;+21&gt;:    mov    $0x6000e8,%ecx
   0x00000000004000d1 &lt;+26&gt;:    mov    $0x1a,%edx
   0x00000000004000d6 &lt;+31&gt;:    int    $0x80
   0x00000000004000d8 &lt;+33&gt;:    mov    $0x1,%eax
   0x00000000004000dd &lt;+38&gt;:    mov    $0x0,%ebx
   0x00000000004000e2 &lt;+43&gt;:    int    $0x80
</pre>

<p>Povšimněte si výchozího režimu výpisu. Na začátku každého řádku je adresa,
následuje relativní offset od první adresy (z&nbsp;něj lze získat představu o
délce instrukce) a poté následuje symbolický kód: mnemotechnické jméno
instrukce a její případné operandy. Mimochodem &ndash; ona adresa první
instrukce <strong>0x00000000004000b0</strong> byla vypsána (a dokonce dvakrát)
ve výstupu programu <strong>objdump</strong>, takže vidíme, že GNU Debugger
skutečně &bdquo;nekecá&ldquo;:</p>

<pre>
...
...
...
start address <strong>0x00000000004000b0</strong>
...
...
...
  0 .text         00000034  <strong>00000000004000b0</strong>  00000000004000b0  000000b0  2**0
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
...
...
...
</pre>

<p>Samozřejmě je stále možné použít i příkaz <strong>list</strong>, který známe
z&nbsp;předchozí části:</p>

<pre>
(gdb) <strong>list loop</strong>
31       
32      _start:
33              mov   ecx, offset buffer     # zapis se bude provadet do tohoto bufferu
34              mov   al, 'a'                # kod prvniho zapisovaneho znaku
35      loop:
36              mov   [ecx], al              # zapis znaku do bufferu
37              inc   al                     # ASCII kod dalsiho znaku
38              inc   ecx                    # uprava ukazatele do bufferu
39              cmp   al, 'z'                # ma se smycka ukoncit?
40              jna   loop                   # pokud jsme neprekrocili kod 'z', opakovat smycku
</pre>



<p><a name="k07"></a></p>
<h2 id="k07">7. Přepnutí režimu zobrazení instrukcí: syntaxe AT&amp;T versus Intel</h2>

<p>Pokud se pečlivěji podíváte na výstup z&nbsp;disassembleru, zjistíte, že
operandy instrukcí příliš neodpovídají původnímu zdrojovému kódu:</p>

<pre>
(gdb) <strong>disassemble loop</strong>
Dump of assembler code for function loop:
   0x00000000004000b7 &lt;+0&gt;:     mov    %al,(%ecx)
   0x00000000004000ba &lt;+3&gt;:     inc    %al
   0x00000000004000bc &lt;+5&gt;:     inc    %ecx
   0x00000000004000be &lt;+7&gt;:     cmp    $0x7a,%al
   0x00000000004000c0 &lt;+9&gt;:     jbe    0x4000b7 &lt;loop&gt;
   0x00000000004000c2 &lt;+11&gt;:    mov    $0x4,%eax
   0x00000000004000c7 &lt;+16&gt;:    mov    $0x1,%ebx
   0x00000000004000cc &lt;+21&gt;:    mov    $0x6000e8,%ecx
   0x00000000004000d1 &lt;+26&gt;:    mov    $0x1a,%edx
   0x00000000004000d6 &lt;+31&gt;:    int    $0x80
End of assembler dump.
</pre>

<p>V&nbsp;původním zdrojovém kódu jsme ovšem používali Intel syntaxi:</p>

<pre>
loop:
        mov   [ecx], al              <i># zapis znaku do bufferu</i>
        inc   al                     <i># ASCII kod dalsiho znaku</i>
        inc   ecx                    <i># uprava ukazatele do bufferu</i>
        cmp   al, 'z'                <i># ma se smycka ukoncit?</i>
        jna   loop                   <i># pokud jsme neprekrocili kod 'z', opakovat smycku</i>
&nbsp;
        mov   eax, sys_write         <i># cislo syscallu pro funkci "write"</i>
        mov   ebx, 1                 <i># standardni vystup</i>
        mov   ecx, offset buffer     <i># adresa retezce, ktery se ma vytisknout</i>
        mov   edx, 26                <i># pocet znaku, ktere se maji vytisknout</i>
        int   0x80                   <i># volani Linuxoveho kernelu</i>
</pre>

<p>Bylo by tedy dobré stejnou syntaxi používat i v&nbsp;GNU Debuggeru. To je
skutečně možné, protože každá moderní varianta GNU Debuggeru nabízí následující
volbu pro přepnutí režimu disassembleru:</p>

<pre>
<strong>set disassembly syntax_flavor intel</strong>
</pre>

<p>Nyní již výstup disassembleru vypadá lidštěji:</p>

<pre>
(gdb) <strong>disassemble loop</strong>
Dump of assembler code for function loop:
   0x00000000004000b7 &lt;+0&gt;:     mov    BYTE PTR [ecx],al
   0x00000000004000ba &lt;+3&gt;:     inc    al
   0x00000000004000bc &lt;+5&gt;:     inc    ecx
   0x00000000004000be &lt;+7&gt;:     cmp    al,0x7a
   0x00000000004000c0 &lt;+9&gt;:     jbe    0x4000b7 &lt;loop&gt;
   0x00000000004000c2 &lt;+11&gt;:    mov    eax,0x4
   0x00000000004000c7 &lt;+16&gt;:    mov    ebx,0x1
   0x00000000004000cc &lt;+21&gt;:    mov    ecx,0x6000e8
   0x00000000004000d1 &lt;+26&gt;:    mov    edx,0x1a
   0x00000000004000d6 &lt;+31&gt;:    int    0x80
End of assembler dump.
</pre>

<p>Poznámka: instrukce <strong>jbe</strong> (&bdquo;jump if below or
equal&ldquo;) je totožná s&nbsp;instrukcí <strong>jna</strong> (&bdquo;jump if
not above&ldquo;) a disassembler samozřejmě neví, kterou variantu jsme použili
v&nbsp;původním zdrojovém kódu.</p>



<p><a name="k08"></a></p>
<h2 id="k08">8. Nastavení breakpointů a krokování po instrukcích</h2>

<p>Práce s&nbsp;breakpointy se při ladění aplikací na úrovni strojových
instrukcí prakticky vůbec neliší od ladění aplikací naprogramovaných
v&nbsp;nějakém vyšším programovacím jazyku. Breakpoint lze nastavit na
konkrétní instrukci, návěští (což je pravděpodobně nejpoužívanější způsob),
nebo na konkrétní adresu. Následují příklady na nastavení breakpointů:</p>

<pre>
(gdb) <strong>break 1</strong>
Breakpoint 2 at 0x4000b0: file test.s, line 1.
&nbsp;
(gdb) <strong>break 10</strong>
Note: breakpoint 2 also set at pc 0x4000b0.
Breakpoint 3 at 0x4000b0: file test.s, line 10.
&nbsp;
(gdb) <strong>break loop</strong>
Breakpoint 1 at 0x4000b7: file test.s, line 36.
</pre>

<p>Seznam všech breakpointů se získá příkazem <strong>info break</strong>:</p>

<pre>
(gdb) info break
Num     Type           Disp Enb Address            What
1       breakpoint     keep y   0x00000000004000b7 test.s:36
        breakpoint already hit 4 times
2       breakpoint     keep y   0x00000000004000b0 test.s:1
3       breakpoint     keep y   0x00000000004000b0 test.s:10
4       breakpoint     keep y   0x00000000004000b7 test.s:36
</pre>

<p>Podívejme se nyní na způsob použití breakpointů. Předpokládejme nastavení
jediného breakpointu na návěští <strong>loop</strong>:</p>

<pre>
(gdb) <strong>clear 1</strong>
Deleted breakpoint 5 
(gdb) <strong>clear 10</strong>
Deleted breakpoint 6 
(gdb) <strong>clear loop</strong>
Deleted breakpoint 7 
(gdb) <strong>break loop</strong>
Breakpoint 8 at 0x4000b7: file test.s, line 36.
</pre>

<p>Po spuštění programu se jeho běh podle očekávání zastaví na breakpointu, o
čemž je vývojář samozřejmě informován:</p>

<pre>
(gdb) <strong>run</strong>
Starting program: /home/tester/temp/a.out 
&nbsp;
Breakpoint 1, loop () at test.s:36
36              mov   [ecx], al              # zapis znaku do bufferu
</pre>

<p>Pro krokování na úrovni jednotlivých instrukcí se používá příkaz
<strong>nexti</strong>, který lze zkrátit na <strong>ni</strong>:</p>

<pre>
(gdb) <strong>nexti</strong>
37              inc   al                     # ASCII kod dalsiho znaku
(gdb) <strong>ni</strong>
38              inc   ecx                    # uprava ukazatele do bufferu
(gdb) <strong>ni</strong>
39              cmp   al, 'z'                # ma se smycka ukoncit?
</pre>

<p>Tomuto příkazu je možné zadat i počet provedených instrukcí:</p>

<pre>
(gdb) <strong>nexti 10</strong>
</pre>

<p>Po několika provedeních smyčky (například příkazem
<strong>c(ontinue)</strong>) se můžeme podívat na aktuální stav
breakpointů:</p>

<pre>
(gdb) <strong>info break</strong>
Num     Type           Disp Enb Address            What
1       breakpoint     keep y   0x00000000004000b7 test.s:36
        breakpoint already hit 4 times
</pre>



<p><a name="k09"></a></p>
<h2 id="k09">9. Zobrazení obsahu pracovních registrů</h2>

<p>Při ladění a krokování aplikací na úrovni jednotlivých strojových instrukcí
se prakticky vždy potřebujeme dozvědět i to, jaké hodnoty jsou uloženy
v&nbsp;pracovních registrech. V&nbsp;případě, že chceme znát hodnotu jednoho
registru, lze použít univerzální příkaz <strong>print</strong>, přičemž před
jménem registru musí být uveden znak $, aby GNU Debugger věděl, že se neptáme
na obsah proměnné:</p>

<pre>
(gdb) <strong>print $al</strong>
$1 = 100
&nbsp;
(gdb) <strong>print $ecx</strong>
$3 = 6291691
</pre>

<p>Pokud se má hodnota registru vypsat v&nbsp;jiné soustavě, stačí za příkaz
<strong>print</strong> přidat formátovací znak:</p>

<pre>
(gdb) <strong>print/x $ecx</strong>
$5 = 0x6000eb
&nbsp;
(gdb) <strong>print/t $ecx</strong>
$7 = 11000000000000011101011
&nbsp;
(gdb) <strong>print/c $al</strong>
$10 = 100 'd'
</pre>

<p>K&nbsp;dispozici jsou tyto formátovací znaky:</p>

<pre>
o(octal)
x(hex)
d(decimal)
u(unsigned decimal),
t(binary)
f(float)
a(address)
c(char)
</pre>

<p>Všechny pracovní, stavové a řídicí registry se vypisují příkazem
<strong>info registers</strong>. Na architektuře x86-64 vypadá výsledek
následovně:</p>

<pre>
(gdb) <strong>info registers</strong>
rax            0x64     100
rbx            0x0      0
rcx            0x6000eb 6291691
rdx            0x0      0
rsi            0x0      0
rdi            0x0      0
rbp            0x0      0x0
rsp            0x7fffffffe190   0x7fffffffe190
r8             0x0      0
r9             0x0      0
r10            0x0      0
r11            0x0      0
r12            0x0      0
r13            0x0      0
r14            0x0      0
r15            0x0      0
rip            0x4000b7 0x4000b7 &lt;loop&gt;
eflags         0x293    [ CF AF SF IF ]
cs             0x33     51
ss             0x2b     43
ds             0x0      0
es             0x0      0
fs             0x0      0
gs             0x0      0
</pre>

<p>Registry matematického koprocesoru se vypíšou příkazem <strong>info
float</strong>, přičemž formát výstupu opět závisí na použité architektuře:</p>

<pre>
(gdb) info float
  R7: Empty   0x00000000000000000000
  R6: Empty   0x00000000000000000000
  R5: Empty   0x00000000000000000000
  R4: Empty   0x00000000000000000000
  R3: Empty   0x00000000000000000000
  R2: Empty   0x00000000000000000000
  R1: Empty   0x00000000000000000000
=&gt;R0: Empty   0x00000000000000000000
&nbsp;
Status Word:         0x0000                                            
                       TOP: 0
Control Word:        0x037f   IM DM ZM OM UM PM
                       PC: Extended Precision (64-bits)
                       RC: Round to nearest
Tag Word:            0xffff
Instruction Pointer: 0x00:0x00000000
Operand Pointer:     0x00:0x00000000
Opcode:              0x0000
</pre>



<p><a name="k10"></a></p>
<h2 id="k10">10. Zobrazení obsahu vybrané části operační paměti</h2>

<p>Nyní již víme, jak lze zobrazit disassemblovaný kód (sekvenci strojových
instrukcí) i obsah pracovních a řídicích registrů, včetně registrů
matematického koprocesoru. Stav procesu je ovšem navíc charakterizován i
obsahem paměti, která je procesu přidělena. Pro výpis obsahu bloku paměti
použijte příkaz <strong>x</strong>, za nímž může následovat adresa. Pokud víme,
že buffer začíná na adrese <strong>0x6000e8</strong>, lze si jeho začátek
zobrazit příkazem:</p>

<pre>
(gdb) <strong>x 0x6000e8</strong>
0x6000e8 &lt;buffer&gt;:      97 'a'
</pre>

<p>Namísto explicitně zapsané adresy lze použít například i obsah registru. My
pro adresování používáme registr <strong>ecx</strong> a již víme, že před
jménem registru musí být zapsán znak dolaru:</p>

<pre>
(gdb) <strong>x $ecx</strong>
0x6000eb &lt;buffer+3&gt;:    0x00000000
</pre>

<p>Při požadavku na výpis delšího bloku se za lomítko zadá počet prvků:</p>

<pre>
(gdb) <strong>x/10 $ecx</strong>
0x6000eb &lt;buffer+3&gt;:    0x00000000      0x00000000      0x00000000      0x00000000
0x6000fb &lt;buffer+19&gt;:   0x00000000      0x00000000      0x00000000      0x00000000
0x60010b:       0x00000000      0x00000000
</pre>

<p>Povšimněte si, jak GNU Debugger inteligentně zjistí, které adresy ještě
náleží do bufferu a které už nikoli. Ještě zřejmější to bude při pokusu o výpis
paměti, na níž jsou uloženy instrukce tvořící vlastní program:</p>

<pre>
(gdb) <strong>x/50bx _start</strong>
0x4000b0 &lt;_start&gt;:      0xb9    0xe8    0x00    0x60    0x00    0xb0    0x61    0x67
0x4000b8 &lt;loop+1&gt;:      0x88    0x01    0xfe    0xc0    0xff    0xc1    0x3c    0x7a
0x4000c0 &lt;loop+9&gt;:      0x76    0xf5    0xb8    0x04    0x00    0x00    0x00    0xbb
0x4000c8 &lt;loop+17&gt;:     0x01    0x00    0x00    0x00    0xb9    0xe8    0x00    0x60
0x4000d0 &lt;loop+25&gt;:     0x00    0xba    0x1a    0x00    0x00    0x00    0xcd    0x80
0x4000d8 &lt;loop+33&gt;:     0xb8    0x01    0x00    0x00    0x00    0xbb    0x00    0x00
0x4000e0 &lt;loop+41&gt;:     0x00    0x00
</pre>



<p><a name="k11"></a></p>
<h2 id="k11">11. Formátování zobrazovaných dat</h2>

<p>Příkaz <strong>x</strong> kromě počtu prvků akceptuje i počet prvků a
formátovací znak.  Zobrazme si tedy padesát bajtů začínajících na adrese
odpovídající začátku bufferu. Každý bajt bude zobrazen v&nbsp;dekadické
podobě:</p>

<pre>
(gdb) <strong>x/50b 0x6000e8</strong>
0x6000e8 &lt;buffer&gt;:      97      98      99      0       0       0       0       0
0x6000f0 &lt;buffer+8&gt;:    0       0       0       0       0       0       0       0
0x6000f8 &lt;buffer+16&gt;:   0       0       0       0       0       0       0       0
0x600100 &lt;buffer+24&gt;:   0       0       0       0       0       0       0       0
0x600108:       0       0       0       0       0       0       0       0
0x600110:       0       0       0       0       0       0       0       0
0x600118:       0       0
</pre>

<p>Přepnutí do režimu hexadecimálního výpisu vypadá takto:</p>

<pre>
(gdb) x/50bx 0x6000e8
0x6000e8 &lt;buffer&gt;:      0x61    0x62    0x63    0x00    0x00    0x00    0x00    0x00
0x6000f0 &lt;buffer+8&gt;:    0x00    0x00    0x00    0x00    0x00    0x00    0x00    0x00
0x6000f8 &lt;buffer+16&gt;:   0x00    0x00    0x00    0x00    0x00    0x00    0x00    0x00
0x600100 &lt;buffer+24&gt;:   0x00    0x00    0x00    0x00    0x00    0x00    0x00    0x00
0x600108:       0x00    0x00    0x00    0x00    0x00    0x00    0x00    0x00
0x600110:       0x00    0x00    0x00    0x00    0x00    0x00    0x00    0x00
0x600118:       0x00    0x00
</pre>

<p>Kombinace předchozího:</p>

<pre>
(gdb) x/10xb $ecx-3
0x6000e8 &lt;buffer&gt;:      0x61    0x62    0x63    0x00    0x00    0x00    0x00    0x00
0x6000f0 &lt;buffer+8&gt;:    0x00    0x00
</pre>

<p>Zajímavý může být režim výpisu &bdquo;řetězců&ldquo;, kdy se GNU Debugger
pokusí část paměti považovat za céčkovský řetězec. To bude fungovat i pro náš
buffer, a to z&nbsp;toho důvodu, že se sekce <strong>.bss</strong> automaticky
nuluje při startu procesu a tudíž vlastně zadarmo získáme znaky pro konec
řetězce \0:</p>

<pre>
(gdb) x/10xs $ecx-3
0x6000e8 &lt;buffer&gt;:      "abc"
0x6000ec &lt;buffer+4&gt;:    ""
0x6000ed &lt;buffer+5&gt;:    ""
0x6000ee &lt;buffer+6&gt;:    ""
0x6000ef &lt;buffer+7&gt;:    ""
0x6000f0 &lt;buffer+8&gt;:    ""
0x6000f1 &lt;buffer+9&gt;:    ""
0x6000f2 &lt;buffer+10&gt;:   ""
0x6000f3 &lt;buffer+11&gt;:   ""
0x6000f4 &lt;buffer+12&gt;:   ""
</pre>

<p>Za příkazem <strong>x</strong> se tedy za lomítko zadává:</p>

<ol>
<li>Počet prvků.</li>
<li>Formátovací znak o(octal), x(hex), d(decimal), u(unsigned decimal), t(binary), f(float), a(address), i(instruction), c(char), s(string)</li>
<li>Jak velké jsou prvky: b(byte), h(halfword), w(word), g(8 bajtů)</li>
</ol>

<p>Velikost prvků se zadává, jen když je to nutné, protože GNU Debugger
velikost mnohdy odvodí automaticky podle metadat.</p>



<p><a name="k12"></a></p>
<h2 id="k12">12. Užitečný příkaz <strong>display</strong></h2>

<p>Při ladění mnohdy potřebujeme neustále sledovat obsah některých registrů či
bloku operační paměti. Zadávat neustále příkaz <strong>print</strong> popř.
<strong>info registers</strong> je samozřejmě těžkopádné a proto přichází na
řadu další velmi užitečný příkaz <strong>display</strong>. Tomu lze zadat
výraz, který se vyhodnotí a vypíše po každém provedeném kroku. Podívejme se na
příklad krokování smyčky <strong>loop</strong>, v&nbsp;níž pracujeme
s&nbsp;osmibitovým registrem <strong>al</strong> a 32bitovým registrem
<strong>ecx</strong>:</p>

<pre>
(gdb) <strong>display $al</strong>
(gdb) <strong>display $ecx</strong>
</pre>

<p>Nastavíme breakpoint a spustíme náš testovací program:</p>

<pre>
(gdb) <strong>break loop</strong>
Breakpoint 1 at 0x4000b7: file test.s, line 36.
&nbsp;
(gdb) <strong>run</strong>
Starting program: /home/tester/temp/a.out 
&nbsp;
Breakpoint 1, loop () at test.s:36
36              mov   [ecx], al              # zapis znaku do bufferu
2: $ecx = 6291688
1: $al = 97
</pre>

<p>Vidíme, že program se zastavil a současně se skutečně vypsaly i obsahy těch
registrů, které nás zajímají. Proveďme další iteraci:</p>

<pre>
(gdb) <strong>c</strong>
Continuing.
&nbsp;
Breakpoint 1, loop () at test.s:36
36              mov   [ecx], al              # zapis znaku do bufferu
2: $ecx = 6291689
1: $al = 98
</pre>

<p>A znovu...</p>

<pre>
(gdb) <strong>c</strong>
Continuing.
&nbsp;
Breakpoint 1, loop () at test.s:36
36              mov   [ecx], al              # zapis znaku do bufferu
2: $ecx = 6291690
1: $al = 99
</pre>

<p>Přidejme ještě sledování bloku operační paměti, konkrétně našeho
bufferu:</p>

<pre>
(gdb) <strong>display/50xb 0x6000e8</strong>
</pre>

<pre>
3: $ecx = 6291688
2: $al = 97
1: x/50xb 0x6000e8
0x6000e8 &lt;buffer&gt;:      0x00    0x00    0x00    0x00    0x00    0x00    0x00    0x00
0x6000f0 &lt;buffer+8&gt;:    0x00    0x00    0x00    0x00    0x00    0x00    0x00    0x00
0x6000f8 &lt;buffer+16&gt;:   0x00    0x00    0x00    0x00    0x00    0x00    0x00    0x00
0x600100 &lt;buffer+24&gt;:   0x00    0x00    0x00    0x00    0x00    0x00    0x00    0x00
0x600108:       0x00    0x00    0x00    0x00    0x00    0x00    0x00    0x00
0x600110:       0x00    0x00    0x00    0x00    0x00    0x00    0x00    0x00
0x600118:       0x00    0x00
</pre>

<pre>
(gdb) <strong>c</strong>
Continuing.
&nbsp;
Breakpoint 1, loop () at test.s:37
37              mov   [ecx], al              # zapis znaku do bufferu
3: $ecx = 6291689
2: $al = 98
1: x/50xb 0x6000e8
0x6000e8 &lt;buffer&gt;:      0x61    0x00    0x00    0x00    0x00    0x00    0x00    0x00
0x6000f0 &lt;buffer+8&gt;:    0x00    0x00    0x00    0x00    0x00    0x00    0x00    0x00
0x6000f8 &lt;buffer+16&gt;:   0x00    0x00    0x00    0x00    0x00    0x00    0x00    0x00
0x600100 &lt;buffer+24&gt;:   0x00    0x00    0x00    0x00    0x00    0x00    0x00    0x00
0x600108:       0x00    0x00    0x00    0x00    0x00    0x00    0x00    0x00
0x600110:       0x00    0x00    0x00    0x00    0x00    0x00    0x00    0x00
0x600118:       0x00    0x00
</pre>

<pre>
(gdb) <strong>c</strong>
Continuing.
&nbsp;
Breakpoint 1, loop () at test.s:37
37              mov   [ecx], al              # zapis znaku do bufferu
3: $ecx = 6291690
2: $al = 99
1: x/50xb 0x6000e8
0x6000e8 &lt;buffer&gt;:      0x61    0x62    0x00    0x00    0x00    0x00    0x00    0x00
0x6000f0 &lt;buffer+8&gt;:    0x00    0x00    0x00    0x00    0x00    0x00    0x00    0x00
0x6000f8 &lt;buffer+16&gt;:   0x00    0x00    0x00    0x00    0x00    0x00    0x00    0x00
0x600100 &lt;buffer+24&gt;:   0x00    0x00    0x00    0x00    0x00    0x00    0x00    0x00
0x600108:       0x00    0x00    0x00    0x00    0x00    0x00    0x00    0x00
0x600110:       0x00    0x00    0x00    0x00    0x00    0x00    0x00    0x00
0x600118:       0x00    0x00
</pre>

<p>Vidíme, že příkaz <strong>display</strong> je skutečně užitečný a může GDB
přiblížit možnostem celoobrazovkových debuggerů či debuggerů s&nbsp;GUI.</p>



<p><a name="k13"></a></p>
<h2 id="k13">13. Praktický příklad a použití TUI</h2>

<p>Pro úplnost se ještě podívejme, jak vypadá použití TUI společně
s&nbsp;programy laděnými na úrovni jednotlivých instrukcí. Pravděpodobně
nejdůležitější je zde příkaz <strong>layout</strong>, kterým lze změnit
zobrazené informace:</p>

<a href="http://www.root.cz/obrazek/250914/"><img src="https://i.iinfo.cz/images/102/gdb3-1-prev.png" class="image-250914" alt="&#160;" height="244" width="370" /></a>
<p><i>Obrázek 1: Po spuštění <strong>gdbtui</strong> se v&nbsp;okně zobrazí i
původní zdrojový kód.</i></p>

<a href="http://www.root.cz/obrazek/250915/"><img src="https://i.iinfo.cz/images/102/gdb3-2-prev.png" class="image-250915" alt="&#160;" height="270" width="290" /></a>
<p><i>Obrázek 2: Přidali jsme okno s&nbsp;výpisem pracovních registrů příkazem
<strong>layout regs</strong>. Současně se nastavil breakpoint, což je vidět i
ze značky B+ se šipkou.</i></p>

<a href="http://www.root.cz/obrazek/250916/"><img src="https://i.iinfo.cz/images/102/gdb3-3-prev.png" class="image-250916" alt="&#160;" height="270" width="290" /></a>
<p><i>Obrázek 3: Při krokování se zvýrazňuje jak právě zpracovávaná instrukce,
tak i ty pracovní registry, jejichž obsah se změnil.</i></p>

<a href="http://www.root.cz/obrazek/250917/"><img src="https://i.iinfo.cz/images/102/gdb3-4-prev.png" class="image-250917" alt="&#160;" height="270" width="290" /></a>
<p><i>Obrázek 4: Při krokování se zvýrazňuje jak právě zpracovávaná instrukce,
tak i ty pracovní registry, jejichž obsah se změnil.</i></p>



<p><a name="k14"></a></p>
<h2 id="k14">14. Odkazy na Internetu</h2>

<ol>

<li>Debuggery a jejich nadstavby v Linuxu<br />
<a href="http://mojefedora.cz/debuggery-a-jejich-nadstavby-v-linuxu/">http://mojefedora.cz/debuggery-a-jejich-nadstavby-v-linuxu/</a>
</li>

<li>Debuggery a jejich nadstavby v Linuxu (2. část)<br />
<a href="http://mojefedora.cz/debuggery-a-jejich-nadstavby-v-linuxu-2-cast/">http://mojefedora.cz/debuggery-a-jejich-nadstavby-v-linuxu-2-cast/</a>
</li>

<li>Debuggery a jejich nadstavby v Linuxu (3): Nemiver<br />
<a href="http://mojefedora.cz/debuggery-a-jejich-nadstavby-v-linuxu-3-nemiver/">http://mojefedora.cz/debuggery-a-jejich-nadstavby-v-linuxu-3-nemiver/</a>
</li>

<li>Debuggery a jejich nadstavby v Linuxu (4): KDbg<br />
<a href="http://mojefedora.cz/debuggery-a-jejich-nadstavby-v-linuxu-4-kdbg/">http://mojefedora.cz/debuggery-a-jejich-nadstavby-v-linuxu-4-kdbg/</a>
</li>

<li>Debuggery a jejich nadstavby v Linuxu (5): ladění aplikací v&nbsp;editorech Emacs a Vim<br />
<a href="http://mojefedora.cz/debuggery-a-jejich-nadstavby-v-linuxu-5-ladeni-aplikaci-v-editorech-emacs-a-vim/">http://mojefedora.cz/debuggery-a-jejich-nadstavby-v-linuxu-5-ladeni-aplikaci-v-editorech-emacs-a-vim/</a>
</li>

<li>Tracing (software)<br />
<a href="https://en.wikipedia.org/wiki/Tracing_%28software%29">https://en.wikipedia.org/wiki/Tracing_%28software%29</a>
</li>

<li>ltrace(1) - Linux man page<br />
<a href="http://linux.die.net/man/1/ltrace">http://linux.die.net/man/1/ltrace</a>
</li>

<li>ltrace (Wikipedia)<br />
<a href="https://en.wikipedia.org/wiki/Ltrace">https://en.wikipedia.org/wiki/Ltrace</a>
</li>

<li>strace(1) - Linux man page<br />
<a href="http://linux.die.net/man/1/strace">http://linux.die.net/man/1/strace</a>
</li>

<li>strace (stránka projektu na SourceForge)<br />
<a href="https://sourceforge.net/projects/strace/">https://sourceforge.net/projects/strace/</a>
</li>

<li>strace (Wikipedia)<br />
<a href="https://en.wikipedia.org/wiki/Strace">https://en.wikipedia.org/wiki/Strace</a>
</li>

<li>SystemTap (stránka projektu)<br />
<a href="https://sourceware.org/systemtap/">https://sourceware.org/systemtap/</a>
</li>

<li>SystemTap (Wiki projektu)<br />
<a href="https://sourceware.org/systemtap/wiki">https://sourceware.org/systemtap/wiki</a>
</li>

<li>SystemTap (Wikipedia)<br />
<a href="https://en.wikipedia.org/wiki/SystemTap">https://en.wikipedia.org/wiki/SystemTap</a>
</li>

<li>Dynamic Tracing with DTrace &amp; SystemTap<br />
<a href="http://myaut.github.io/dtrace-stap-book/">http://myaut.github.io/dtrace-stap-book/</a>
</li>

<li>DTrace (Wikipedia)<br />
<a href="https://en.wikipedia.org/wiki/DTrace">https://en.wikipedia.org/wiki/DTrace</a>
</li>

<li>GDB - Dokumentace<br />
<a href="http://sourceware.org/gdb/current/onlinedocs/gdb/">http://sourceware.org/gdb/current/onlinedocs/gdb/</a>
</li>

<li>GDB - Supported Languages<br />
<a href="http://sourceware.org/gdb/current/onlinedocs/gdb/Supported-Languages.html#Supported-Languages">http://sourceware.org/gdb/current/onlinedocs/gdb/Supported-Languages.html#Supported-Languages</a>
</li>

<li>GNU Debugger (Wikipedia)<br />
<a href="https://en.wikipedia.org/wiki/GNU_Debugger">https://en.wikipedia.org/wiki/GNU_Debugger</a>
</li>

<li>The LLDB Debugger<br />
<a href="http://lldb.llvm.org/">http://lldb.llvm.org/</a>
</li>

<li>Debugger (Wikipedia)<br />
<a href="https://en.wikipedia.org/wiki/Debugger">https://en.wikipedia.org/wiki/Debugger</a>
</li>

<li>13 Linux Debuggers for C++ Reviewed<br />
<a href="http://www.drdobbs.com/testing/13-linux-debuggers-for-c-reviewed/240156817">http://www.drdobbs.com/testing/13-linux-debuggers-for-c-reviewed/240156817</a>
</li>

<li>Getting started with ltrace: how does it do that?<br />
<a href="https://www.ellexus.com/getting-started-with-ltrace-how-does-it-do-that/">https://www.ellexus.com/getting-started-with-ltrace-how-does-it-do-that/</a>
</li>

<li>Reverse Engineering Tools in Linux – strings, nm, ltrace, strace, LD_PRELOAD<br />
<a href="http://www.thegeekstuff.com/2012/03/reverse-engineering-tools/">http://www.thegeekstuff.com/2012/03/reverse-engineering-tools/</a>
</li>

<li>7 Strace Examples to Debug the Execution of a Program in Linux<br />
<a href="http://www.thegeekstuff.com/2011/11/strace-examples/">http://www.thegeekstuff.com/2011/11/strace-examples/</a>
</li>

<li>Oracle® Solaris 11.3 DTrace (Dynamic Tracing) Guide<br />
<a href="http://docs.oracle.com/cd/E53394_01/html/E53395/gkwpo.html#scrolltoc">http://docs.oracle.com/cd/E53394_01/html/E53395/gkwpo.html#scrolltoc</a>
</li>

<li>An Introduction To Using GDB Under Emacs<br />
<a href="http://tedlab.mit.edu/~dr/gdbintro.html">http://tedlab.mit.edu/~dr/gdbintro.html</a>
</li>

<li>GNU Emacs<br />
<a href="https://www.gnu.org/software/emacs/emacs.html">https://www.gnu.org/software/emacs/emacs.html</a>
</li>

<li>The Emacs Editor<br />
<a href="https://www.gnu.org/software/emacs/manual/html_node/emacs/index.html">https://www.gnu.org/software/emacs/manual/html_node/emacs/index.html</a>
</li>

<li>Emacs Lisp<br />
<a href="https://www.gnu.org/software/emacs/manual/html_node/elisp/index.html">https://www.gnu.org/software/emacs/manual/html_node/elisp/index.html</a>
</li>

<li>An Introduction to Programming in Emacs Lisp<br />
<a href="https://www.gnu.org/software/emacs/manual/html_node/eintr/index.html">https://www.gnu.org/software/emacs/manual/html_node/eintr/index.html</a>
</li>

<li>27.6 Running Debuggers Under Emacs<br />
<a href="https://www.gnu.org/software/emacs/manual/html_node/emacs/Debuggers.html">https://www.gnu.org/software/emacs/manual/html_node/emacs/Debuggers.html</a>
</li>

<li>GdbMode<br />
<a href="http://www.emacswiki.org/emacs/GdbMode">http://www.emacswiki.org/emacs/GdbMode</a>
</li>

<li>Emacs (Wikipedia)<br />
<a href="https://en.wikipedia.org/wiki/Emacs">https://en.wikipedia.org/wiki/Emacs</a>
</li>

<li>Emacs Lisp (Wikipedia)<br />
<a href="https://en.wikipedia.org/wiki/Emacs_Lisp">https://en.wikipedia.org/wiki/Emacs_Lisp</a>
</li>

<li>Pyclewn installation notes<br />
<a href="http://pyclewn.sourceforge.net/install.html">http://pyclewn.sourceforge.net/install.html</a>
</li>

<li>pip Installation<br />
<a href="https://pip.pypa.io/en/latest/installing.html">https://pip.pypa.io/en/latest/installing.html</a>
</li>

<li>Clewn<br />
<a href="http://clewn.sourceforge.net/">http://clewn.sourceforge.net/</a>
</li>

<li>Clewn installation<br />
<a href="http://clewn.sourceforge.net/install.html">http://clewn.sourceforge.net/install.html</a>
</li>

<li>Clewn - soubory<br />
<a href="http://sourceforge.net/projects/clewn/files/OldFiles/">http://sourceforge.net/projects/clewn/files/OldFiles/</a>
</li>

<li>KDbg: úvodní stránka<br />
<a href="http://www.kdbg.org/">http://www.kdbg.org/</a>
</li>

<li>Nemiver (stránky projektu)<br />
<a href="https://wiki.gnome.org/Apps/Nemiver">https://wiki.gnome.org/Apps/Nemiver</a>
</li>

<li>Basic Assembler Debugging with GDB<br />
<a href="http://dbp-consulting.com/tutorials/debugging/basicAsmDebuggingGDB.html">http://dbp-consulting.com/tutorials/debugging/basicAsmDebuggingGDB.html</a>
</li>

<li>Nemiver FAQ<br />
<a href="https://wiki.gnome.org/Apps/Nemiver/FAQ">https://wiki.gnome.org/Apps/Nemiver/FAQ</a>
</li>

<li>Nemiver (Wikipedia)<br />
<a href="https://en.wikipedia.org/wiki/Nemiver">https://en.wikipedia.org/wiki/Nemiver</a>
</li>

<li>Data Display Debugger<br />
<a href="https://www.gnu.org/software/ddd/">https://www.gnu.org/software/ddd/</a>
</li>

<li>GDB - Dokumentace<br />
<a href="http://sourceware.org/gdb/current/onlinedocs/gdb/">http://sourceware.org/gdb/current/onlinedocs/gdb/</a>
</li>

<li>BASH Debugger<br />
<a href="http://bashdb.sourceforge.net/">http://bashdb.sourceforge.net/</a>
</li>

<li>The Perl Debugger(s)<br />
<a href="http://debugger.perl.org/">http://debugger.perl.org/</a>
</li>

<li>Visual Debugging with DDD<br />
<a href="http://www.drdobbs.com/tools/visual-debugging-with-ddd/184404519">http://www.drdobbs.com/tools/visual-debugging-with-ddd/184404519</a>
</li>

<li>Pydb - Extended Python Debugger<br />
<a href="http://bashdb.sourceforge.net/pydb/">http://bashdb.sourceforge.net/pydb/</a>
</li>

<li>Insight<br />
<a href="http://www.sourceware.org/insight/">http://www.sourceware.org/insight/</a>
</li>

<li>Supported Languages (GNU Debugger)<br />
<a href="http://sourceware.org/gdb/current/onlinedocs/gdb/Supported-Languages.html#Supported-Languages">http://sourceware.org/gdb/current/onlinedocs/gdb/Supported-Languages.html#Supported-Languages</a>
</li>

<li>GNU Debugger (Wikipedia)<br />
<a href="https://en.wikipedia.org/wiki/GNU_Debugger">https://en.wikipedia.org/wiki/GNU_Debugger</a>
</li>

<li>The LLDB Debugger<br />
<a href="http://lldb.llvm.org/">http://lldb.llvm.org/</a>
</li>

<li>Debugger (Wikipedia)<br />
<a href="https://en.wikipedia.org/wiki/Debugger">https://en.wikipedia.org/wiki/Debugger</a>
</li>

<li>13 Linux Debuggers for C++ Reviewed<br />
<a href="http://www.drdobbs.com/testing/13-linux-debuggers-for-c-reviewed/240156817">http://www.drdobbs.com/testing/13-linux-debuggers-for-c-reviewed/240156817</a>
</li>

<li>Clewn<br />
<a href="http://clewn.sourceforge.net/">http://clewn.sourceforge.net/</a>
</li>

<li>Clewn installation<br />
<a href="http://clewn.sourceforge.net/install.html">http://clewn.sourceforge.net/install.html</a>
</li>

<li>Clewn - soubory ke stažení<br />
<a href="http://sourceforge.net/projects/clewn/files/OldFiles/">http://sourceforge.net/projects/clewn/files/OldFiles/</a>
</li>

<li>Pyclewn installation notes<br />
<a href="http://pyclewn.sourceforge.net/install.html">http://pyclewn.sourceforge.net/install.html</a>
</li>

<li>Debugging<br />
<a href="http://janus.uclan.ac.uk/pagray/labs/debug.htm">http://janus.uclan.ac.uk/pagray/labs/debug.htm</a>
</li>

</ol>



<p></p><p></p>
<p><small>Autor: <a href="http://www.fit.vutbr.cz/~tisnovpa">Pavel Tišnovský</a> &nbsp; 2016</small></p>
</body>
</html>

