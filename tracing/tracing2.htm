<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
        "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html>
<head>
<title>Trasování a ladění nativních aplikací v Linuxu: použití GDB a jeho nadstaveb</title>
<meta name="Author" content="Pavel Tisnovsky" />
<meta name="Generator" content="vim" />
<meta http-equiv="content-type" content="text/html; charset=utf-8" />
<style type="text/css">
         body {color:#000000; background:#ffffff;}
         h1  {font-family: arial, helvetica, sans-serif; color:#ffffff; background-color:#c00000; text-align:center; padding-left:1em}
         h2  {font-family: arial, helvetica, sans-serif; color:#ffffff; background-color:#0000c0; padding-left:1em; text-align:left}
         h3  {font-family: arial, helvetica, sans-serif; color:#000000; background-color:#c0c0c0; padding-left:1em; text-align:left}
         h4  {font-family: arial, helvetica, sans-serif; color:#000000; background-color:#e0e0e0; padding-left:1em; text-align:left}
         a   {font-family: arial, helvetica, sans-serif;}
         li  {font-family: arial, helvetica, sans-serif; color:#000000; text-align:justify; width:450px;}
         ol  {font-family: arial, helvetica, sans-serif; color:#000000; text-align:justify; width:450px;}
         ul  {font-family: arial, helvetica, sans-serif; color:#000000; text-align:justify; width:450px;}
         p   {font-family: arial, helvetica, sans-serif; color:#000000; text-align:justify;}
         pre {background:#e0e0e0}
</style>
</head>

<body>

<h1>Trasování a ladění nativních aplikací v Linuxu: použití GDB a jeho nadstaveb</h1>

<h3>Pavel Tišnovský</h3>

<p></p>

<h1>Úvodník</h1>

<p>Ve druhé části článku o trasování a ladění aplikací v&nbsp;Linuxu se seznámíme s&nbsp;některými možnostmi nabízenými GNU Debuggerem (GDB). Nad tímto všestranně užitečným nástrojem vzniklo i poměrně mnoho různých nadstaveb s&nbsp;TUI a samozřejmě i s&nbsp;GUI. O některých z&nbsp;nich se stručně zmíníme ve druhé polovině článku.</p>



<h2>Obsah</h2>

<p><a href="#k01">1. Trasování a ladění nativních aplikací v&nbsp;Linuxu: použití GDB a jeho nadstaveb</a></p>
<p><a href="#k02">2. GNU Debugger</a></p>
<p><a href="#k03">3. Orientace v&nbsp;laděném kódu</a></p>
<p><a href="#k04">4. Spuštění programu, nastavení breakpointů a krokování</a></p>
<p><a href="#k05">5. Parametry breakpointů</a></p>
<p><a href="#k06">6. Výpis obsahu zásobníkových rámců</a></p>
<p><a href="#k07">7. Ladění aplikací, které zhavarovaly</a></p>
<p><a href="#k08">8. Demonstrační příklady použité v&nbsp;dnešním článku</a></p>
<p><a href="#k09">9. Nadstavby na GNU Debuggerem</a></p>
<p><a href="#k10">10. cgdb</a></p>
<p><a href="#k11">11. Data Display Debugger &ndash; DDD</a></p>
<p><a href="#k12">12. Nemiver</a></p>
<p><a href="#k13">13. KDbg</a></p>
<p><a href="#k14">14. Emacs</a></p>
<p><a href="#k15">15. Odkazy na Internetu</a></p>



<p><a name="k01"></a></p>
<h2 id="k01">1. Trasování a ladění nativních aplikací v&nbsp;Linuxu: použití GDB a jeho nadstaveb</h2>

<p><a
href="http://www.root.cz/clanky/trasovani-a-ladeni-nativnich-aplikaci-v-linuxu/">V&nbsp;první
části článku</a> o nástrojích, které je možné použít pro trasování a
popř.&nbsp;i pro plnohodnotné ladění nativních aplikací běžících v&nbsp;Linuxu,
jsme se seznámili s&nbsp;jednoduše použitelnými nástroji nazvanými
<strong>ltrace</strong> a <strong>strace</strong>. Připomeňme si, že nástroj
<strong>ltrace</strong> slouží k&nbsp;trasování volání knihovních funkcí
(s&nbsp;různými možnostmi filtrace, měření atd.) a <strong>strace</strong> se
naopak používá pro trasování volání funkcí jádra (<i>syscalls</i>). Kromě toho
jsme si řekli základní informace o pokročilém (a již složitěji ovládaném)
nástroji nazvaném <i>SystemTap</i>, s&nbsp;jehož možnostmi se blíže seznámíme
v&nbsp;následujícím článku. Připomeňme si též, jak může vypadat použití
jednotlivých nástrojů na celém &bdquo;stacku&ldquo;, tj.&nbsp;od
trasování/ladění samotné uživatelské aplikace až přes řešení problémů přímo
v&nbsp;jádře operačního systému:</p>

<pre>
+----------+
|          |..... gdb
| aplikace |
|          |..... SystemTap
+----------+
     |
     |
     |...... ltrace
     |
     v
+----------+
|          |..... gdb
|  glibc   |
|          |..... SystemTap
+----------+
     |
     |
     |...... strace
     |
     v
+----------+
|          |..... SystemTap
|  jádro   |
|          |..... KGDB
+----------+
</pre>

<p>Vidíme, že dnes popisovaný GNU Debugger je možné použít jak na úrovni ladění
aplikace, tak i knihoven. Kromě toho ho lze využít i pro &bdquo;pitvu&ldquo;
těch nativních aplikací, které byly kvůli nějakému problému zabity jádrem
systému a byl pro ně vygenerován takzvaný &bdquo;core dump&ldquo;.</p>



<p><a name="k02"></a></p>
<h2 id="k02">2. GNU Debugger</h2>

<p>Nástroj <i>GNU Debugger</i>, který je taktéž někdy podle své spustitelné
(binární) části pojmenováván <strong>gdb</strong>, primárně používá ke
komunikaci s&nbsp;uživatelem příkazový řádek, ale alternativně lze použít i
jednoduché TUI (textové uživatelské rozhraní) či protokol pro nepřímé ovládání
debuggeru a v&nbsp;případě potřeby je možné k&nbsp;laděné aplikaci přidat
relativně krátký &bdquo;stub&ldquo; sloužící pro přímé ladění takové aplikace
(touto nepochybně zajímavou problematikou se však dnes nebudeme zabývat).
Většina často používaných příkazů zapisovaných na příkazový řádek má i svoji
zkrácenou podobu (<i>bt=backtrace</i>, <i>c=continue</i>, <i>f=frame</i>) a
navíc je možné používat klávesu [Tab] pro automatické doplnění celého jména
příkazu či jeho parametru (doplňování je kontextové). Pokud je správně
nastavený terminál, bude fungovat i historie příkazového řádku, a to stejným
způsobem, jaký známe ze shellu. Alternativně je možné využít
<strong>gdbtui</strong> s&nbsp;celoobrazovkovým výstupem a alespoň částečně se
tak přiblížit možnostem debuggerů s&nbsp;plnohodnotným grafickým uživatelským
rozhraním.</p>

<p>Podívejme se nyní na způsob spuštění GNU Debuggeru a práce s&nbsp;ním.
Nejprve si připravíme testovací aplikaci, kterou pro jednoduchost
naprogramujeme v&nbsp;céčku (a nikoli v&nbsp;C++ &ndash; to kvůli jménům
funkcí):</p>

<pre>
#include &lt;stdio.h&gt;
&nbsp;
void print_hello()
{
    puts("Hello world!");
}
&nbsp;
int main(int argc, char **argv)
{
    print_hello();
    return 0;
}
</pre>

<p>Zdrojový kód uložíme do souboru nazvaného <strong>hello.c</strong> a
přeložíme s&nbsp;volbou <strong>-g</strong>, která zajistí vložení potřebných
ladicích symbolů do výsledného binárního (spustitelného) souboru:</p>

<pre>
gcc -g -ansi -pedantic -Wall -o hello hello.c
</pre>

<p>Následně již můžeme spustit GNU Debugger:</p>

<pre>
<strong>gdb hello</strong>
&nbsp;
GNU gdb (Ubuntu 7.7.1-0ubuntu5~14.04.2) 7.7.1
Copyright (C) 2014 Free Software Foundation, Inc.
License GPLv3+: GNU GPL version 3 or later &lt;http://gnu.org/licenses/gpl.html&gt;
This is free software: you are free to change and redistribute it.
There is NO WARRANTY, to the extent permitted by law.  Type "show copying"
and "show warranty" for details.
This GDB was configured as "x86_64-linux-gnu".
Type "show configuration" for configuration details.
For bug reporting instructions, please see:
&lt;http://www.gnu.org/software/gdb/bugs/&gt;.
Find the GDB manual and other documentation resources online at:
&lt;http://www.gnu.org/software/gdb/documentation/&gt;.
For help, type "help".
Type "apropos word" to search for commands related to "word"...
Reading symbols from hello...done.
</pre>

<p>Povšimněte si především posledního řádku, ve kterém debugger potvrzuje
načtení ladicích symbolů. Pokud se v&nbsp;tomto řádku zobrazí text:</p>

<pre>
(no debugging symbols found)
</pre>

<p>znamená to, že jste pravděpodobně při překladu zapomněli použít volbu
<strong>-g</strong>, popř.&nbsp;se na již přeložený soubor použila utilita
<strong>strip</strong>, která symboly odstranila.</p>

<p>GNU Debugger obsahuje i poměrně rozsáhlý systém nápovědy, který si můžeme
vyzkoušet:</p>

<pre>
(gdb) <strong>help</strong>
List of classes of commands:
&nbsp;
aliases -- Aliases of other commands
breakpoints -- Making program stop at certain points
data -- Examining data
files -- Specifying and examining files
internals -- Maintenance commands
obscure -- Obscure features
running -- Running the program
stack -- Examining the stack
status -- Status inquiries
support -- Support facilities
tracepoints -- Tracing of program execution without stopping the program
user-defined -- User-defined commands
&nbsp;
Type "help" followed by a class name for a list of commands in that class.
Type "help all" for the list of all commands.
Type "help" followed by command name for full documentation.
Type "apropos word" to search for commands related to "word".
Command name abbreviations are allowed if unambiguous.
</pre>

<p>Ukončení GNU Debuggeru zajišťuje příkaz <strong>quit</strong> zkracovaný na
pouhé <strong>q</strong>:</p>

<pre>
(gdb) <strong>q</strong>
</pre>

<p>Pro úplnost se ještě podívejme, jak vypadá TUI (textové uživatelské
rozhraní) zabudované do GNU Debuggeru:</p>

<pre>
<strong>gdbtui hello</strong>
&nbsp;
&nbsp;
&nbsp;
   +--hello.c-----------------------------------------------------------------------------+
   |1       #include &lt;stdio.h&gt;                                                            |
   |2                                                                                     |
   |3       void print_hello()                                                            |
   |4       {                                                                             |
   |5           puts("Hello world!");                                                     |
   |6       }                                                                             |
   |7                                                                                     |
   |8       int main(int argc, char **argv)                                               |
   |9       {                                                                             |
   |10          print_hello();                                                            |
   |11          return 0;                                                                 |
   |12      }                                                                             |
   |13                                                                                    |
   |14                                                                                    |
   |15                                                                                    |
   |16                                                                                    |
   +--------------------------------------------------------------------------------------+
exec No process In:                                                      Line: ??   PC: ?? 
&lt;http://www.gnu.org/software/gdb/documentation/&gt;
For help, type "help".
Type "apropos word" to search for commands related to "word"...
Reading symbols from hello...done.
</pre>

<p>V&nbsp;základním nastavení je terminál rozdělen do dvou oken &ndash; první
okno obsahuje zdrojový kód, druhé pak klasické rozhraní příkazového řádku. Ve
skutečnosti je však možné zobrazit i další okna, například speciální okno
s&nbsp;registry atd. V&nbsp;okně se zdrojovým kódem se navíc zobrazují
breakpointy a další důležité informace, takže &bdquo;režim TUI&ldquo; může být
pro mnohé vývojáře velmi užitečný (dokonce si dovolím říct, že je časově
výhodnější se naučit pracovat v&nbsp;tomto režimu, než řešit problémy
s&nbsp;různými GUI nadstavbami).</p>



<p><a name="k03"></a></p>
<h2 id="k03">3. Orientace v&nbsp;laděném kódu</h2>

<p>Pokud jsou do binárního souboru laděné aplikace přiloženy i ladicí symboly,
lze v&nbsp;GNU Debuggeru relativně snadno pracovat přímo se zdrojovým kódem a
využívat jména funkcí, jména proměnných atd. Základním příkazem, který se může
hodit například při nastavování breakpointů, je příkaz <strong>info
functions</strong>, který vypíše jak všechny funkce z&nbsp;aplikace, tak i
přímo či nepřímo volané funkce (pro zápis tohoto příkazu použijte klávesu [Tab]
pro kontextové doplňování):</p>

<pre>
(gdb) <strong>info functions</strong>
All defined functions:
&nbsp;
File hello.c:
int main(int, char **);
void print_hello();
&nbsp;
Non-debugging symbols:
0x00000000004003e0  _init
0x0000000000400410  puts@plt
0x0000000000400420  __libc_start_main@plt
0x0000000000400430  __gmon_start__@plt
0x0000000000400440  _start
0x0000000000400470  deregister_tm_clones
0x00000000004004a0  register_tm_clones
0x00000000004004e0  __do_global_dtors_aux
0x0000000000400500  frame_dummy
0x0000000000400560  __libc_csu_init
0x00000000004005d0  __libc_csu_fini
0x00000000004005d4  _fini
</pre>

<p>Dalším užitečným příkazem je příkaz <strong>list</strong>, který vypíše
deset řádků zdrojového kódu. Opakováním příkazu (či pouhým stlačením klávesy
Enter, což má stejný význam, jako explicitní opakování posledního příkazu) se
zobrazí dalších deset řádků atd.:</p>

<pre>
(gdb) <strong>list</strong>
1       #include &lt;stdio.h&gt;
2
3       void print_hello()
4       {
5           puts("Hello world!");
6       }
7
8       int main(int argc, char **argv)
9       {
10          print_hello();
</pre>

<p>K&nbsp;příkazu <strong>list</strong> je možné explicitně přidat i číslo
prvního a posledního vypisovaného řádku, což je výhodné v&nbsp;případě, že
z&nbsp;nějakého chybového hlášení víte, na kterém řádku k&nbsp;chybě došlo:</p>

<pre>
(gdb) <strong>list 1,12</strong>
1       #include &lt;stdio.h&gt;
2
3       void print_hello()
4       {
5           puts("Hello world!");
6       }
7
8       int main(int argc, char **argv)
9       {
10          print_hello();
11          return 0;
12      }
</pre>

<p>Užitečnější je však použití příkazu <strong>list</strong> společně se jménem
funkce, protože nemusíte složitě zjišťovat, na jakém řádku je hledaná funkce
zapsána (ani v&nbsp;jakém je souboru):</p>

<pre>
(gdb) <strong>list main</strong>
4       {
5           puts("Hello world!");
6       }
7
8       int main(int argc, char **argv)
9       {
10          print_hello();
11          return 0;
12      }
13
</pre>

<p>Pokud chcete jméno funkce vybrat ze seznamu, stačí napsat jen příkaz
<strong>list</strong>, mezeru a potom stlačit klávesu [Tab]:</p>

<pre>
_IO_stdin_used
__JCR_END__
__JCR_LIST__
__libc_csu_fini
__libc_csu_init
__libc_start_main
__libc_start_main@got.plt
__libc_start_main@plt
long int
long unsigned int
main
print_hello
puts
puts@got.plt
puts@plt
register_tm_clones
short int
short unsigned int
signed char
sizetype
_start
__TMC_END__
unsigned char
unsigned int
(gdb) <strong>list </strong>
</pre>

<p>Samozřejmě funguje i vyhledávání na základě částečně zapsaného jména
funkce:</p>

<pre>
__libc_csu_fini            __libc_start_main@got.plt
__libc_csu_init            __libc_start_main@plt
__libc_start_main          
(gdb) <strong>list __libc_</strong>
</pre>

<p>Užitečné mohou být i další varianty příkazu <strong>info</strong>:</p>

<pre>
(gdb) <strong>info sources</strong>
Source files for which symbols have been read in:
&nbsp;
/home/tester/temp/presentations/tracing/hello.c
&nbsp;
Source files for which symbols will be read in on demand:
</pre>

<pre>
(gdb) <strong>info sharedlibrary </strong>
From                To                  Syms Read   Shared Object Library
0x00007ffff7ddaae0  0x00007ffff7df54e0  Yes (*)     /lib64/ld-linux-x86-64.so.2
(*): Shared library is missing debugging information.
</pre>



<p><a name="k04"></a></p>
<h2 id="k04">4. Spuštění programu, nastavení breakpointů a krokování</h2>

<p>Nyní se podíváme na způsob spuštění laděné aplikace přímo v&nbsp;GNU
Debuggeru. To je ve skutečnosti velmi jednoduché a přímočaré, protože postačuje
zadat příkaz <strong>run</strong> či jen <strong>r</strong>:</p>

<pre>
(gdb) <strong>run</strong>
Starting program: /home/tester/temp/presentations/tracing/hello 
Hello world!
[Inferior 1 (process 6977) exited normally]
</pre>

<p>Na libovolnou funkci, řádek či dokonce jednotlivou strojovou instrukci je
možné zaregistrovat breakpoint. Pokud se běh programu dostane na breakpoint, je
jeho běh přerušen a řízení se vrátí zpět uživateli do debuggeru. Nejjednodušeji
se nastavuje breakpoint na vstupním bodě funkce. V&nbsp;tomto případě postačuje
zadat příkaz <strong>break</strong> se jménem funkce:</p>

<pre>
(gdb) <strong>break main</strong>
Breakpoint 1 at 0x40054c: file hello.c, line 10.
</pre>

<p>Pokud nyní program znovu spustíme, zastaví se na právě nastaveném
breakpointu:</p>

<pre>
(gdb) <strong>run</strong>
Starting program: /home/tester/temp/presentations/tracing/hello 
&nbsp;
Breakpoint 1, main (argc=1, argv=0x7fffffffe158) at hello.c:10
10          print_hello();
</pre>

<p>Nyní máme možnost pokračovat v&nbsp;běhu (<strong>c/continue</strong>), ale
zajímavější je použít příkaz <strong>n/next</strong>, který vykoná pouze jediný
programový řádek a posléze se běh programu opět zastaví:</p>

<pre>
(gdb) <strong>n</strong>
Hello world!
11          return 0;
(gdb) <strong>c</strong>
Continuing.
[Inferior 1 (process 7040) exited normally]
</pre>

<p>O tom, že GNU Debugger není žádné ořezávátko, možná svědčí i to, že se
v&nbsp;průběhu ladění může použít mj.&nbsp;i příkaz <strong>print</strong>
akceptující různé typy výrazů, lokální i globální proměnné, formátování atd.:</p>

<pre>
(gdb) <strong>print(i)</strong>
$1 = 30
&nbsp;
(gdb) <strong>print(argc&gt;0)</strong>
$2 = 1
&nbsp;
(gdb) <strong>print(atoi("42"))</strong>
$3 = 42
&nbsp;
(gdb) <strong>print(isdigit('4'))</strong>
$4 = 2048
&nbsp;
(gdb) <strong>print(isdigit('a'))</strong>
$5 = 0
</pre>

<p>Všechny doposud popsané příkazy si otestujme na jiném (nepatrně složitějším)
zdrojovém kódu, v&nbsp;němž se nachází funkce pro výpočet faktoriálu:</p>

<pre>
#include &lt;stdio.h&gt;
&nbsp;
short factorial(short n)
{
    if (n==0 || n==1) return 1;
    return n*factorial(n-1);
}
&nbsp;
int main(int argc, char **argv)
{
    printf("%d\n", factorial(8));
    return 0;
}
</pre>

<p>Výpis části zdrojového kódu:</p>

<pre>
(gdb) <strong>list</strong>
2
3       short factorial(short n)
4       {
5           if (n==0 || n==1) return 1;
6           return n*factorial(n-1);
7       }
8
9       int main(int argc, char **argv)
10      {
11          printf("%d\n", factorial(8));
</pre>

<p>Nastavení breakpointu:</p>

<pre>
(gdb) <strong>break factorial</strong>
Breakpoint 1 at 0x40053b: file factorial.c, line 5.
</pre>

<p>Spuštění programu a výpis parametru funkce po zastavení na breakpointu:</p>

<pre>
(gdb) <strong>run</strong>
Starting program: /home/tester/temp/presentations/tracing/factorial 
&nbsp;
Breakpoint 1, factorial (n=8) at factorial.c:5
5           if (n==0 || n==1) return 1;
(gdb) <strong>print(n)</strong>
$1 = 8
</pre>

<p>Pokračování v&nbsp;běhu programu a opětovný výpis parametru funkce:</p>

<pre>
(gdb) <strong>continue</strong>
Continuing.
&nbsp;
Breakpoint 1, factorial (n=7) at factorial.c:5
5           if (n==0 || n==1) return 1;
(gdb) <strong>print(n)</strong>
$2 = 7
</pre>

<p>Odstranění breakpointu:</p>

<pre>
(gdb) <strong>clear main</strong>
Deleted breakpoint 1 
(gdb) <strong>run</strong>
Starting program: /home/tester/temp/presentations/tracing/a.out 
Hello world!
[Inferior 1 (process 7876) exited normally]
</pre>



<p><a name="k05"></a></p>
<h2 id="k05">5. Parametry breakpointů</h2>

<p>U breakpointů je možné nastavovat různé parametry a především podmínky
ovlivňující, za jakých okolností se breakpoint projeví a za jakých nikoli.
Nejprve si opět nastavme breakpoint na vstupní bod funkce nazvané
<strong>factorial</strong>:</p>

<pre>
(gdb) <strong>break factorial</strong>
Breakpoint 1 at 0x40053b: file factorial.c, line 5.
</pre>

<p>Informaci o všech breakpointech získáme příkazem <strong>info
breakpoints</strong>:</p>

<pre>
(gdb) <strong>info breakpoints</strong>
Num     Type           Disp Enb Address            What
1       breakpoint     keep y   0x000000000040053b in factorial at factorial.c:5
</pre>

<p>Vidíme, že náš breakpoint je uložen na indexu 1. Nastavme nyní tento
breakpoint takovým způsobem, aby ignoroval prvních pět průchodů, tedy část
&bdquo;winding&ldquo; fáze rekurzivní funkce <strong>factorial</strong>:</p>

<pre>
(gdb) <strong>ignore 1 5</strong>
Will ignore next 5 crossings of breakpoint 1.
(gdb) info b
Num     Type           Disp Enb Address            What
1       breakpoint     keep y   0x000000000040053b in factorial at factorial.c:5
        ignore next 5 hits
</pre>

<p><strong>Pozor:</strong> pokud se breakpoint zobrazil pod jiným číslem, je
nutné příkaz <strong>ignore n 5</strong> upravit tak, aby se použilo správné
<strong>n</strong>.</p>

<p>Pokud aplikaci nyní spustíme, bude se chovat odlišně, protože se zastaví až
ve chvíli, kdy je hodnota <strong>n</strong> rovna třem a nikoli osmi:</p>

<pre>
(gdb) <strong>r</strong>
Starting program: /home/tester/temp/presentations/tracing/factorial 
&nbsp;
Breakpoint 1, factorial (n=3) at factorial.c:5
5           if (n==0 || n==1) return 1;
</pre>



<p><a name="k06"></a></p>
<h2 id="k06">6. Výpis obsahu zásobníkových rámců</h2>

<p>V&nbsp;tomto okamžiku si můžeme vypsat historii volání, a to příkazem
<strong>backtrace</strong> popř.&nbsp;jeho zkrácenou variantou
<strong>bt</strong>:</p>

<pre>
(gdb) <strong>bt</strong>
#0  factorial (n=3) at factorial.c:5
#1  0x000000000040055f in factorial (n=4) at factorial.c:6
#2  0x000000000040055f in factorial (n=5) at factorial.c:6
#3  0x000000000040055f in factorial (n=6) at factorial.c:6
#4  0x000000000040055f in factorial (n=7) at factorial.c:6
#5  0x000000000040055f in factorial (n=8) at factorial.c:6
#6  0x0000000000400583 in main (argc=1, argv=0x7fffffffe158) at factorial.c:11
</pre>

<p>Vidíme, že se skutečně ještě nacházíme ve &bdquo;winding&ldquo; fázi funkce
<strong>factorial</strong>. Historii je nutné číst odspodu, což je logické,
protože <strong>bt</strong> získává informace z&nbsp;obsahu zásobníkových rámců
vytvářených pro každou volanou funkci.</p>

<p>Pokud nepotřebujete zobrazit celou historii, ale jen posledních
<strong>n</strong> volání, stačí zadat <strong>bt</strong> s&nbsp;požadovaným
počtem řádků:</p>

<pre>
(gdb) <strong>bt 4</strong>
#0  factorial (n=3) at factorial.c:5
#1  0x000000000040055f in factorial (n=4) at factorial.c:6
#2  0x000000000040055f in factorial (n=5) at factorial.c:6
#3  0x000000000040055f in factorial (n=6) at factorial.c:6
(More stack frames follow...)
</pre>

<p>Začátek historie se naopak zobrazí po zadání záporného čísla:</p>

<pre>
(gdb) <strong>bt -4</strong>
#3  0x000000000040055f in factorial (n=6) at factorial.c:6
#4  0x000000000040055f in factorial (n=7) at factorial.c:6
#5  0x000000000040055f in factorial (n=8) at factorial.c:6
#6  0x0000000000400583 in main (argc=1, argv=0x7fffffffe1c8) at factorial.c:11
</pre>

<p>Pro zobrazení zásobníkových rámců společně s&nbsp;lokálními proměnnými
použijte <strong>bt full</strong> (to však u naší jednoduchoučké funkce
postrádá význam).</p>



<p><a name="k07"></a></p>
<h2 id="k07">7. Ladění aplikací, které zhavarovaly</h2>

<p><i>GNU Debugger</i> může být velmi užitečný i v&nbsp;těch případech, kdy je
zapotřebí zjistit příčinu havárie nějakého programu. Jádro operačního systému
totiž může ještě před úplným ukončením procesu uložit do speciálního souboru
nazvaného <i>core dump</i> jak obsah paměti přiřazené procesu, tak i další
údaje související s&nbsp;jeho aktuálním stavem &ndash; obsahy pracovních
registrů, stav otevřených souborů apod. (tyto informace jsou do značné míry
závislé na architektuře i na použitém operačním systému). Mimochodem termín
&bdquo;core dump&ldquo; vznikl v&nbsp;dobách používání <a
href="http://www.root.cz/clanky/ibm-a-sedm-trpasliku-prvni-cast/#k07">feritových
pamětí</a>, protože jadérka v&nbsp;těchto pamětech si pamatovala svůj obsah tak
dlouho, že po pádu aplikace (žádný skutečný operační systém ještě neexistoval,
většinou se jednalo o pouhý loader uživatelského kódu) bylo možné její obsah
v&nbsp;klidu prozkoumat. Nicméně se vraťme k&nbsp;současným core dumpům. Jeden
si vytvoříme, a to tímto jednoduchým (zabugovaným) prográmkem:</p>

<pre>
void set_mem(int *address, int value)
{
    *address = value;
}
&nbsp;
int main(int argc, char **argv)
{
    set_mem((int*)0, 42);
    return 0;
}
</pre>

<p>Program přeložíme běžným způsobem:</p>

<pre>
<strong>gcc -g -Wall -ansi -pedantic npe.c</strong>
</pre>

<p>A pokusíme se ho spustit běžným způsobem z&nbsp;příkazové řádky:</p>

<pre>
<strong>./npe </strong>
Segmentation fault
</pre>

<p>Pokud se vypíše pouze &bdquo;Segmentation fault&ldquo;, znamená to, že se
core dump ve skutečnosti nevytvořil. Zkusíme tedy systému pomoci povolením
vytváření core dumpů o neomezené velikosti:</p>

<pre>
<strong>ulimit -c unlimited</strong>
<strong>./npe </strong>
Segmentation fault (core dumped)
</pre>

<p>Teď už je to lepší (viz text v&nbsp;závorce) &ndash; vytvořil se core dump,
který můžeme prozkoumat.  <i>GNU Debugger</i> je nutné spustit takovým
způsobem, že se specifikuje jak jméno spustitelného souboru, tak i jméno
souboru s&nbsp;core dumpem (v&nbsp;uvedeném pořadí):</p>

<pre>
<strong>gdb npe core</strong>
</pre>

<p>Zajímavé je, že se při spouštění GNU Debuggeru vypíšou odlišné informace,
které však poměrně přesně říkají, co se stalo. Proč se to stalo, to je již
otázkou na samotného programátora:</p>

<pre>
Reading symbols from npe...done.
[New LWP 7703]
Core was generated by `./npe'.
Program terminated with signal SIGSEGV, Segmentation fault.
#0  0x00000000004004ff in set_mem (address=0x0, value=42) at npe.c:3
3           *address = value;
</pre>

<p>GNU Debugger se nyní chová, jakoby byl program již spuštěný (což není
náhoda), takže si můžeme nechat vypsat obsah zásobníkových rámců:</p>

<pre>
(gdb) <strong>bt</strong>
#0  0x00000000004004ff in set_mem (address=0x0, value=42) at npe.c:3
#1  0x0000000000400521 in main (argc=1, argv=0x7fff07ba7798) at npe.c:8
</pre>

<p>Můžeme nastavit breakpoint na začátek té funkce, v&nbsp;níž došlo
k&nbsp;pádu. Jedná se o funkci nazvanou <strong>set_mem</strong>:</p>

<pre>
(gdb) <strong>b set_mem</strong>
Breakpoint 1 at 0x4004f8: file npe.c, line 3.
</pre>

<p>A program můžeme znovu spustit:</p>

<pre>
(gdb) <strong>r</strong>
Starting program: /home/tester/temp/presentations/tracing/npe 
</pre>

<p>Běh laděné aplikace se podle očekávání zastaví na breakpointu:</p>

<pre>
Breakpoint 1, set_mem (address=0x0, value=42) at npe.c:3
3           *address = value;
</pre>

<p>Takže znovu prozkoumáme obsah zásobníkových rámců:</p>

<pre>
(gdb) <strong>bt</strong>
#0  set_mem (address=0x0, value=42) at npe.c:3
#1  0x0000000000400521 in main (argc=1, argv=0x7fffffffe168) at npe.c:8
</pre>

<p>Aha, adresa je nastavená nějak divně &ndash; zápis na adresu 0 skutečně
povede k&nbsp;pádu (to je většinou ošetřeno na hardwarové úrovni, například
nastavením práv k&nbsp;celé první stránce paměti přidělené aplikaci atd.):</p>

<pre>
(gdb) <strong>print address</strong>
$1 = (int *) 0x0
</pre>

<p>Skutečně, nyní již víme (což bylo v&nbsp;tomto případě velmi jednoduché), že
chyba je ve funkci <strong>main</strong>, resp.&nbsp;v&nbsp;předání špatné
adresy. Bez opuštění debuggeru si můžeme kód prohlédnout (osmý řádek):</p>

<pre>
(gdb) <strong>list main</strong>
2       {
3           *address = value;
4       }
5
6       int main(int argc, char **argv)
7       {
8           set_mem((int*)0, 42);
9           return 0;
10      }
11
</pre>

<p>Poznámka: ke složitějším situacím, stejně jako k&nbsp;ladění programů
napsaných v&nbsp;C++ (kde je někdy nutné se zabývat překladem jmen funkcí a
metod), se dostaneme příště.</p>



<p><a name="k08"></a></p>
<h2 id="k08">8. Demonstrační příklady použité v&nbsp;dnešním článku</h2>

<p>Všechny tři demonstrační příklady, které jsme používali při popisu GNU
Debuggeru, byly opět uloženy do GIT repositáře nazvaného <a
href="https://github.com/tisnik/presentations">https://github.com/tisnik/presentations</a>:</p>

<table>
<tr><th>#</th><th>Program</th><th>URL do GITu</th></tr>
<tr><td>1</td><td>test.c</td><td><a href="https://github.com/tisnik/presentations/blob/master/tracing/test.c">https://github.com/tisnik/presentations/blob/master/tracing/test.c</a></td></tr>
<tr><td>2</td><td>factorial.c</td><td><a href="https://github.com/tisnik/presentations/blob/master/tracing/factorial.c">https://github.com/tisnik/presentations/blob/master/tracing/factorial.c</a></td></tr>
<tr><td>3</td><td>npe.c</td><td><a href="https://github.com/tisnik/presentations/blob/master/tracing/npe.c">https://github.com/tisnik/presentations/blob/master/tracing/npe.c</a></td></tr>
</table>



<p><a name="k09"></a></p>
<h2 id="k09">9. Nadstavby na GNU Debuggerem</h2>

<p>Práce s&nbsp;příkazovým řádkem <i>GNU Debuggeru</i> sice programátorům
přináší velkou flexibilitu (a to jsme se prozatím seznámili pouze
s&nbsp;nepatrnou částí celkové funkcionality), ovšem je pochopitelné, že
některým uživatelům příkazová řádka nemusí vyhovovat. To však &ndash; alespoň
teoreticky &ndash; nemusí být nepřekonatelným problémem, protože GDB je navržen
takovým způsobem, aby se nad ním daly vytvářet různé nadstavby vybavené více či
méně konformním textovým či grafickým uživatelským rozhraním. O nadstavbách
vytvořených nad <i>GNU Debuggerem</i> jsem již napsal krátký seriál na
&bdquo;konkurenčním&ldquo; webu <a
href="http://www.mojefedora.cz">http://www.mojefedora.cz</a>, takže si dnes o
každé nadstavbě řekneme pouze základní informace (nejdůležitější informací je
v&nbsp;době Googlu samozřejmě jméno nadstavby :-), zbytek se již dá dohledat na
stránkách vývojářů toho kterého nástroje).</p>

<a href="http://www.root.cz/obrazek/249939/"><img src="https://i.iinfo.cz/images/615/debuggers-1-prev.png" class="image-249939" alt="&#160;" height="173" width="370" /></a>
<p><i>Obrázek 1: V&nbsp;minulosti velmi populární nástroj Turbo Debugger je
vybaven celoobrazovkovým textovým uživatelským rozhraním (TUI) připomínajícím
další produkty vytvořené společností Borland. Rozhraní a možnosti Turbo
Debuggeru je stále možné považovat za etalon toho, jak by mohl vypadat moderní
debugger s&nbsp;TUI či GUI.</i></p>



<p><a name="k10"></a></p>
<h2 id="k10">10. cgdb</h2>

<p>Nástroj nazvaný <i>cgdb</i>, o němž jsem se zmínil <a
href="http://mojefedora.cz/debuggery-a-jejich-nadstavby-v-linuxu/#k07">zde</a>,
je založený na knihovně <i>curses</i> resp.&nbsp;<i>ncurses</i>, tudíž ho je
možné využít v&nbsp;terminálu, na stroji připojeném přes SSH atd. Ve svém
základním nastavení nástroj <i>cgdb</i> rozděluje okno terminálu (konzole) na
dvě části. V&nbsp;horní části je zobrazen zdrojový kód laděné aplikace a
v&nbsp;části dolní pak rozhraní samotného <i>GNU Debuggeru</i>, které již
známe. Mezi oběma částmi je možné se s&nbsp;využitím několika klávesových
zkratek přepínat, přičemž je nutné poznamenat, že většinu složitějších příkazů
je možné zadávat jen v&nbsp;rozhraní <i>GNU Debuggeru</i>. Horní část slouží
zejména pro dobrou orientaci v&nbsp;laděném programu, pro zobrazení nastavených
breakpointů (v&nbsp;základním nastavení je použita červená barva) a taktéž pro
zobrazení místa, v&nbsp;němž se právě nachází laděný program (v&nbsp;základním
nastavení je tento řádek zobrazen zeleně).</p>

<a href="http://www.root.cz/obrazek/249940/"><img src="https://i.iinfo.cz/images/615/debuggers-2-prev.png" class="image-249940" alt="&#160;" height="243" width="370" /></a>
<p><i>Obrázek 2: Ladění programu v&nbsp;cgdb. Na řádku 21 je nastaven
breakpoint, proto je tento řádek zvýrazněn červeně. Řízení programu přešlo na
řádek číslo 23 (zvýrazněno zeleně) a v&nbsp;dolní části si vývojář
s&nbsp;využitím příkazu <strong>print</strong> vypsal obsah dvou lokálních
proměnných.</i></p>



<p><a name="k11"></a></p>
<h2 id="k11">11. Data Display Debugger &ndash; DDD</h2>

<p>O nástroji nazvaném <i>Data Display Debugger</i>, který je známý i pod svojí
zkratkou <i>DDD</i>, vznikl <a
href="http://mojefedora.cz/debuggery-a-jejich-nadstavby-v-linuxu-2-cast/">článek
na serveru mojefedora.cz</a>, takže si zde pouze ve stručnosti řekněme, že
<i>Data Display Debugger</i> je nadstavbou nad <i>GNU Debuggerem</i>, která
nabízí uživatelům při ladění aplikací plnohodnotné grafické uživatelské
rozhraní, jehož jednotlivé ovládací prvky a jejich chování sice mohou působit
zastarale (což je způsobeno použitou GUI knihovnou), ve skutečnosti je však
celé uživatelské rozhraní <i>Data Display Debuggeru</i> velmi flexibilní, což
vynikne především při použití dvou a více monitorů (to je dnes pro vývojáře asi
standardní konfigurace). Příkladem flexibility GUI jsou například
&bdquo;odtrhávací&ldquo; menu (<i>tear off menu</i>), které je možné velmi
snadno změnit na nemodální dialogy s&nbsp;nabídkou příkazů. <i>Data Display
Debugger</i> lze využít i pro komunikaci s&nbsp;dalšími debuggery, například
s&nbsp;debuggerem jazyka Perl, debuggerem skriptů psaných v&nbsp;BASHi a
v&nbsp;neposlední řadě taktéž pro ovládání <i>pydb</i>, což je jeden
z&nbsp;debuggerů používaných vývojáři používajícími programovací jazyk
Python</p>

<a href="http://www.root.cz/obrazek/249941/"><img src="https://i.iinfo.cz/images/615/debuggers-3-prev.png" class="image-249941" alt="&#160;" height="270" width="320" /></a>
<p><i>Obrázek 3: Ukázka grafického uživatelského rozhraní programu Data Display
Debugger. V&nbsp;horní části můžeme vidět okno se zdrojovým kódem,
v&nbsp;prostřední části pak výpis odpovídajícího strojového kódu a spodní
třetina GUI obsahuje klasický příkazový řádek GNU Debuggeru. K&nbsp;dispozici
je i dialogové okno se základními a často používanými příkazy.</i></p>



<p><a name="k12"></a></p>
<h2 id="k12">12. Nemiver</h2>

<p>I o dalším nástroji pojmenovaném <i>Nemiver</i> již <a
href="http://mojefedora.cz/debuggery-a-jejich-nadstavby-v-linuxu-3-nemiver/">vyšel
samostatný článek</a>. Tento nástroj opět komunikuje s&nbsp;GNU Debuggerem,
ovšem na rozdíl od DDD postaveného nad postarší GUI knihovnou je <i>Nemiver</i>
primárně určený pro desktopové prostředí GNOME se všemi přednostmi a zápory,
které to přináší. <i>Nemiver</i> tak uživatelům nabízí přehledné prostředí,
které ovšem není tak flexibilní jako DDD a taktéž například možnosti zobrazení
složitějších datových struktur (různých lineárně vázaných seznamů, stromů či
obecnějších grafových struktur) jsou v&nbsp;<i>Nemiveru</i> omezené. Pokud ale
někdo pouze potřebuje odkrokovat několik funkcí a neprovádět žádné složitější
operace, může být tento nástroj pro takového uživatele dobrým řešením.</p>

<a href="http://www.root.cz/obrazek/249942/"><img src="https://i.iinfo.cz/images/615/debuggers-4-prev.png" class="image-249942" alt="&#160;" height="270" width="346" /></a>
<p><i>Obrázek 4: Ukázka grafického uživatelského rozhraní nástroje Nemiver při
ladění uživatelské aplikace. V&nbsp;dolní části si povšimněte
&bdquo;oušek&ldquo; jednotlivých podoken.</i></p>



<p><a name="k13"></a></p>
<h2 id="k13">13. KDbg</h2>

<p>Pro &bdquo;konkurenční&ldquo; desktopové prostředí KDE vznikl projekt
nazvaný <i>KDbg</i>, který byl <a
href="http://mojefedora.cz/debuggery-a-jejich-nadstavby-v-linuxu-4-kdbg/">podrobněji
zmíněn v&nbsp;tomto článku</a>. <i>KDbg</i> vývojářům nabízí prakticky veškeré
základní funkce, které jsou od debuggerů očekávány: nastavování breakpointů,
nastavování watchpointů, krokování po jednotlivých příkazech, vstup do volaných
funkcí, prohlížení obsahu operační paměti, prohlížení složitějších datových
struktur apod. <i>KDbg</i> je ve skutečnosti opět nadstavbou nad klasickým GNU
Debuggerem, což mj.&nbsp;znamená, že KDbg je možné v&nbsp;současné verzi použít
pro ladění nativních aplikací naprogramovaných v&nbsp;jazycích Ada, C, C++, Go,
Objective-C, D, Fortran, Modula-2, Pascal a Java (zde ovšem pouze při překladu
do nativního strojového kódu). Nejpoužívanějšími jazyky laděných aplikací
pravděpodobně zůstanou C a C++.</p>

<a href="http://www.root.cz/obrazek/249943/"><img src="https://i.iinfo.cz/images/615/debuggers-5-prev.png" class="image-249943" alt="&#160;" height="256" width="370" /></a>
<p><i>Obrázek 5: Ukázka grafického uživatelského rozhraní nástroje KDbg, opět
při ladění uživatelské aplikace. Obsah levého spodního podokna je opět
volitelný.</i></p>



<p><a name="k14"></a></p>
<h2 id="k14">14. Emacs</h2>

<p>Rozhraní pro GNU Debugger může být zabudováno i do různých pokročilejších
programátorských editorů. Pravděpodobně nejlepší propojení s&nbsp;debuggerem <a
href="http://mojefedora.cz/debuggery-a-jejich-nadstavby-v-linuxu-5-ladeni-aplikaci-v-editorech-emacs-a-vim/">nabízí
textový editor Emacs</a>. Používá se v&nbsp;něm knihovna <i>Grand Unified
Debugger</i>, která mj.&nbsp;zajišťuje i propojení mezi textovým editorem
<i>GNU Emacs</i> a debuggerem <i>GNU Debugger</i>. V&nbsp;tomto režimu je možné
si v&nbsp;okně Emacsu zobrazit zdrojový kód a současně i několik bufferů
obsahujících jak textové uživatelské rozhraní debuggeru (konzoli, která je
aktivní, tj.&nbsp;lze do ní zapisovat příkazy), tak i speciální buffer
s&nbsp;hodnotami pracovních registrů procesoru, další buffer se seznamem
breakpointů, buffer se seznamem vláken atd. Kromě toho je možné (minimálně ve
chvíli, kdy je Emacs spuštěn v&nbsp;prostředí grafického desktopu) otevřít
další specializovaná okna, zejména okno s&nbsp;výpisem obsahu vybraných
proměnných, obsahem bloku paměti, disassemblovaným kódem apod.</p>

<a href="http://www.root.cz/obrazek/249944/"><img src="https://i.iinfo.cz/images/615/debuggers-6-prev.png" class="image-249944" alt="&#160;" height="270" width="362" /></a>
<p><i>Obrázek 6: Nám již známý program nazvaný <strong>npe</strong>
v&nbsp;průběhu jeho krokování a ladění v&nbsp;Emacsu (v&nbsp;režimu GNU
Debuggeru).</i></p>



<p><a name="k15"></a></p>
<h2 id="k15">15. Odkazy na Internetu</h2>

<ol>

<li>Debuggery a jejich nadstavby v Linuxu<br />
<a href="http://mojefedora.cz/debuggery-a-jejich-nadstavby-v-linuxu/">http://mojefedora.cz/debuggery-a-jejich-nadstavby-v-linuxu/</a>
</li>

<li>Debuggery a jejich nadstavby v Linuxu (2. část)<br />
<a href="http://mojefedora.cz/debuggery-a-jejich-nadstavby-v-linuxu-2-cast/">http://mojefedora.cz/debuggery-a-jejich-nadstavby-v-linuxu-2-cast/</a>
</li>

<li>Debuggery a jejich nadstavby v Linuxu (3): Nemiver<br />
<a href="http://mojefedora.cz/debuggery-a-jejich-nadstavby-v-linuxu-3-nemiver/">http://mojefedora.cz/debuggery-a-jejich-nadstavby-v-linuxu-3-nemiver/</a>
</li>

<li>Debuggery a jejich nadstavby v Linuxu (4): KDbg<br />
<a href="http://mojefedora.cz/debuggery-a-jejich-nadstavby-v-linuxu-4-kdbg/">http://mojefedora.cz/debuggery-a-jejich-nadstavby-v-linuxu-4-kdbg/</a>
</li>

<li>Debuggery a jejich nadstavby v Linuxu (5): ladění aplikací v&nbsp;editorech Emacs a Vim<br />
<a href="http://mojefedora.cz/debuggery-a-jejich-nadstavby-v-linuxu-5-ladeni-aplikaci-v-editorech-emacs-a-vim/">http://mojefedora.cz/debuggery-a-jejich-nadstavby-v-linuxu-5-ladeni-aplikaci-v-editorech-emacs-a-vim/</a>
</li>

<li>Tracing (software)<br />
<a href="https://en.wikipedia.org/wiki/Tracing_%28software%29">https://en.wikipedia.org/wiki/Tracing_%28software%29</a>
</li>

<li>ltrace(1) - Linux man page<br />
<a href="http://linux.die.net/man/1/ltrace">http://linux.die.net/man/1/ltrace</a>
</li>

<li>ltrace (Wikipedia)<br />
<a href="https://en.wikipedia.org/wiki/Ltrace">https://en.wikipedia.org/wiki/Ltrace</a>
</li>

<li>strace(1) - Linux man page<br />
<a href="http://linux.die.net/man/1/strace">http://linux.die.net/man/1/strace</a>
</li>

<li>strace (stránka projektu na SourceForge)<br />
<a href="https://sourceforge.net/projects/strace/">https://sourceforge.net/projects/strace/</a>
</li>

<li>strace (Wikipedia)<br />
<a href="https://en.wikipedia.org/wiki/Strace">https://en.wikipedia.org/wiki/Strace</a>
</li>

<li>SystemTap (stránka projektu)<br />
<a href="https://sourceware.org/systemtap/">https://sourceware.org/systemtap/</a>
</li>

<li>SystemTap (Wiki projektu)<br />
<a href="https://sourceware.org/systemtap/wiki">https://sourceware.org/systemtap/wiki</a>
</li>

<li>SystemTap (Wikipedia)<br />
<a href="https://en.wikipedia.org/wiki/SystemTap">https://en.wikipedia.org/wiki/SystemTap</a>
</li>

<li>Dynamic Tracing with DTrace &amp; SystemTap<br />
<a href="http://myaut.github.io/dtrace-stap-book/">http://myaut.github.io/dtrace-stap-book/</a>
</li>

<li>DTrace (Wikipedia)<br />
<a href="https://en.wikipedia.org/wiki/DTrace">https://en.wikipedia.org/wiki/DTrace</a>
</li>

<li>GDB - Dokumentace<br />
<a href="http://sourceware.org/gdb/current/onlinedocs/gdb/">http://sourceware.org/gdb/current/onlinedocs/gdb/</a>
</li>

<li>GDB - Supported Languages<br />
<a href="http://sourceware.org/gdb/current/onlinedocs/gdb/Supported-Languages.html#Supported-Languages">http://sourceware.org/gdb/current/onlinedocs/gdb/Supported-Languages.html#Supported-Languages</a>
</li>

<li>GNU Debugger (Wikipedia)<br />
<a href="https://en.wikipedia.org/wiki/GNU_Debugger">https://en.wikipedia.org/wiki/GNU_Debugger</a>
</li>

<li>The LLDB Debugger<br />
<a href="http://lldb.llvm.org/">http://lldb.llvm.org/</a>
</li>

<li>Debugger (Wikipedia)<br />
<a href="https://en.wikipedia.org/wiki/Debugger">https://en.wikipedia.org/wiki/Debugger</a>
</li>

<li>13 Linux Debuggers for C++ Reviewed<br />
<a href="http://www.drdobbs.com/testing/13-linux-debuggers-for-c-reviewed/240156817">http://www.drdobbs.com/testing/13-linux-debuggers-for-c-reviewed/240156817</a>
</li>

<li>Getting started with ltrace: how does it do that?<br />
<a href="https://www.ellexus.com/getting-started-with-ltrace-how-does-it-do-that/">https://www.ellexus.com/getting-started-with-ltrace-how-does-it-do-that/</a>
</li>

<li>Reverse Engineering Tools in Linux – strings, nm, ltrace, strace, LD_PRELOAD<br />
<a href="http://www.thegeekstuff.com/2012/03/reverse-engineering-tools/">http://www.thegeekstuff.com/2012/03/reverse-engineering-tools/</a>
</li>

<li>7 Strace Examples to Debug the Execution of a Program in Linux<br />
<a href="http://www.thegeekstuff.com/2011/11/strace-examples/">http://www.thegeekstuff.com/2011/11/strace-examples/</a>
</li>

<li>Oracle® Solaris 11.3 DTrace (Dynamic Tracing) Guide<br />
<a href="http://docs.oracle.com/cd/E53394_01/html/E53395/gkwpo.html#scrolltoc">http://docs.oracle.com/cd/E53394_01/html/E53395/gkwpo.html#scrolltoc</a>
</li>

<li>An Introduction To Using GDB Under Emacs<br />
<a href="http://tedlab.mit.edu/~dr/gdbintro.html">http://tedlab.mit.edu/~dr/gdbintro.html</a>
</li>

<li>GNU Emacs<br />
<a href="https://www.gnu.org/software/emacs/emacs.html">https://www.gnu.org/software/emacs/emacs.html</a>
</li>

<li>The Emacs Editor<br />
<a href="https://www.gnu.org/software/emacs/manual/html_node/emacs/index.html">https://www.gnu.org/software/emacs/manual/html_node/emacs/index.html</a>
</li>

<li>Emacs Lisp<br />
<a href="https://www.gnu.org/software/emacs/manual/html_node/elisp/index.html">https://www.gnu.org/software/emacs/manual/html_node/elisp/index.html</a>
</li>

<li>An Introduction to Programming in Emacs Lisp<br />
<a href="https://www.gnu.org/software/emacs/manual/html_node/eintr/index.html">https://www.gnu.org/software/emacs/manual/html_node/eintr/index.html</a>
</li>

<li>27.6 Running Debuggers Under Emacs<br />
<a href="https://www.gnu.org/software/emacs/manual/html_node/emacs/Debuggers.html">https://www.gnu.org/software/emacs/manual/html_node/emacs/Debuggers.html</a>
</li>

<li>GdbMode<br />
<a href="http://www.emacswiki.org/emacs/GdbMode">http://www.emacswiki.org/emacs/GdbMode</a>
</li>

<li>Emacs (Wikipedia)<br />
<a href="https://en.wikipedia.org/wiki/Emacs">https://en.wikipedia.org/wiki/Emacs</a>
</li>

<li>Emacs Lisp (Wikipedia)<br />
<a href="https://en.wikipedia.org/wiki/Emacs_Lisp">https://en.wikipedia.org/wiki/Emacs_Lisp</a>
</li>

<li>Pyclewn installation notes<br />
<a href="http://pyclewn.sourceforge.net/install.html">http://pyclewn.sourceforge.net/install.html</a>
</li>

<li>pip Installation<br />
<a href="https://pip.pypa.io/en/latest/installing.html">https://pip.pypa.io/en/latest/installing.html</a>
</li>

<li>Clewn<br />
<a href="http://clewn.sourceforge.net/">http://clewn.sourceforge.net/</a>
</li>

<li>Clewn installation<br />
<a href="http://clewn.sourceforge.net/install.html">http://clewn.sourceforge.net/install.html</a>
</li>

<li>Clewn - soubory<br />
<a href="http://sourceforge.net/projects/clewn/files/OldFiles/">http://sourceforge.net/projects/clewn/files/OldFiles/</a>
</li>

<li>KDbg: úvodní stránka<br />
<a href="http://www.kdbg.org/">http://www.kdbg.org/</a>
</li>

<li>Nemiver (stránky projektu)<br />
<a href="https://wiki.gnome.org/Apps/Nemiver">https://wiki.gnome.org/Apps/Nemiver</a>
</li>

<li>Nemiver FAQ<br />
<a href="https://wiki.gnome.org/Apps/Nemiver/FAQ">https://wiki.gnome.org/Apps/Nemiver/FAQ</a>
</li>

<li>Nemiver (Wikipedia)<br />
<a href="https://en.wikipedia.org/wiki/Nemiver">https://en.wikipedia.org/wiki/Nemiver</a>
</li>

<li>Data Display Debugger<br />
<a href="https://www.gnu.org/software/ddd/">https://www.gnu.org/software/ddd/</a>
</li>

<li>GDB - Dokumentace<br />
<a href="http://sourceware.org/gdb/current/onlinedocs/gdb/">http://sourceware.org/gdb/current/onlinedocs/gdb/</a>
</li>

<li>BASH Debugger<br />
<a href="http://bashdb.sourceforge.net/">http://bashdb.sourceforge.net/</a>
</li>

<li>The Perl Debugger(s)<br />
<a href="http://debugger.perl.org/">http://debugger.perl.org/</a>
</li>

<li>Visual Debugging with DDD<br />
<a href="http://www.drdobbs.com/tools/visual-debugging-with-ddd/184404519">http://www.drdobbs.com/tools/visual-debugging-with-ddd/184404519</a>
</li>

<li>Pydb - Extended Python Debugger<br />
<a href="http://bashdb.sourceforge.net/pydb/">http://bashdb.sourceforge.net/pydb/</a>
</li>

<li>Insight<br />
<a href="http://www.sourceware.org/insight/">http://www.sourceware.org/insight/</a>
</li>

<li>Supported Languages (GNU Debugger)<br />
<a href="http://sourceware.org/gdb/current/onlinedocs/gdb/Supported-Languages.html#Supported-Languages">http://sourceware.org/gdb/current/onlinedocs/gdb/Supported-Languages.html#Supported-Languages</a>
</li>

<li>GNU Debugger (Wikipedia)<br />
<a href="https://en.wikipedia.org/wiki/GNU_Debugger">https://en.wikipedia.org/wiki/GNU_Debugger</a>
</li>

<li>The LLDB Debugger<br />
<a href="http://lldb.llvm.org/">http://lldb.llvm.org/</a>
</li>

<li>Debugger (Wikipedia)<br />
<a href="https://en.wikipedia.org/wiki/Debugger">https://en.wikipedia.org/wiki/Debugger</a>
</li>

<li>13 Linux Debuggers for C++ Reviewed<br />
<a href="http://www.drdobbs.com/testing/13-linux-debuggers-for-c-reviewed/240156817">http://www.drdobbs.com/testing/13-linux-debuggers-for-c-reviewed/240156817</a>
</li>

<li>Clewn<br />
<a href="http://clewn.sourceforge.net/">http://clewn.sourceforge.net/</a>
</li>

<li>Clewn installation<br />
<a href="http://clewn.sourceforge.net/install.html">http://clewn.sourceforge.net/install.html</a>
</li>

<li>Clewn - soubory ke stažení<br />
<a href="http://sourceforge.net/projects/clewn/files/OldFiles/">http://sourceforge.net/projects/clewn/files/OldFiles/</a>
</li>

<li>Pyclewn installation notes<br />
<a href="http://pyclewn.sourceforge.net/install.html">http://pyclewn.sourceforge.net/install.html</a>
</li>

<li>Debugging<br />
<a href="http://janus.uclan.ac.uk/pagray/labs/debug.htm">http://janus.uclan.ac.uk/pagray/labs/debug.htm</a>
</li>

</ol>



<p></p><p></p>
<p><small>Autor: <a href="http://www.fit.vutbr.cz/~tisnovpa">Pavel Tišnovský</a> &nbsp; 2016</small></p>
</body>
</html>

