<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
        "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html>
<head>
<title>Trasování a ladění nativních aplikací v Linuxu</title>
<meta name="Author" content="Pavel Tisnovsky" />
<meta name="Generator" content="vim" />
<meta http-equiv="content-type" content="text/html; charset=utf-8" />
<style type="text/css">
         body {color:#000000; background:#ffffff;}
         h1  {font-family: arial, helvetica, sans-serif; color:#ffffff; background-color:#c00000; text-align:center; padding-left:1em}
         h2  {font-family: arial, helvetica, sans-serif; color:#ffffff; background-color:#0000c0; padding-left:1em; text-align:left}
         h3  {font-family: arial, helvetica, sans-serif; color:#000000; background-color:#c0c0c0; padding-left:1em; text-align:left}
         h4  {font-family: arial, helvetica, sans-serif; color:#000000; background-color:#e0e0e0; padding-left:1em; text-align:left}
         a   {font-family: arial, helvetica, sans-serif;}
         li  {font-family: arial, helvetica, sans-serif; color:#000000; text-align:justify; width:450px;}
         ol  {font-family: arial, helvetica, sans-serif; color:#000000; text-align:justify; width:450px;}
         ul  {font-family: arial, helvetica, sans-serif; color:#000000; text-align:justify; width:450px;}
         p   {font-family: arial, helvetica, sans-serif; color:#000000; text-align:justify;}
         pre {background:#e0e0e0}
</style>
</head>

<body>

<h1>Trasování a ladění nativních aplikací v Linuxu</h1>

<h3>Pavel Tišnovský</h3>

<p></p>

<h1>Úvodník</h1>

<p>V&nbsp;dnešním článku se seznámíme s&nbsp;vybranými nástroji, které je možné použít pro trasování a popř.&nbsp;i ladění nativních aplikací v&nbsp;Linuxu. Kromě snadno použitelných utilit typu ltrace a strace si řekneme základní informace i o pokročilejších nástrojích typu SystemTap, DTrace a samozřejmě i GNU Debuggeru (GDB).</p>



<h2>Obsah</h2>

<p><a href="#k01">1. Trasování a ladění nativních aplikací v&nbsp;Linuxu</a></p>
<p><a href="#k02">2. Utilita <strong>ltrace</strong> &ndash; výpis informací o volaných knihovních funkcích</a></p>
<p><a href="#k03">3. Ukázka použití utility <strong>ltrace</strong></a></p>
<p><a href="#k04">4. Zjištění doby trvání volané funkce a filtrace výstupu</a></p>
<p><a href="#k05">5. Zjištění statistiky volaných funkcí</a></p>
<p><a href="#k06">6. Utilita <strong>strace</strong> &ndash; výpis informací o volaných systémových funkcích</a></p>
<p><a href="#k07">7. Ukázka použití utility <strong>strace</strong></a></p>
<p><a href="#k08">8. GNU Debugger</a></p>
<p><a href="#k09">9. DTrace</a></p>
<p><a href="#k10">10. SystemTap</a></p>
<p><a href="#k11">11. Ukázky použití SystemTapu</a></p>
<p><a href="#k12">12. Obsah následujícího článku</a></p>
<p><a href="#k13">13. Demonstrační příklady použité v&nbsp;dnešním článku</a></p>
<p><a href="#k14">14. Odkazy na Internetu</a></p>



<p><a name="k01"></a></p>
<h2 id="k01">1. Trasování a ladění nativních aplikací v&nbsp;Linuxu</h2>

<p>V&nbsp;operačním systému Linux můžeme pro ladění a trasování nativních
aplikací použít hned několik nástrojů, které se od sebe liší jak způsobem
použití, tak i svými možnostmi. Dnes se nejprve zmíníme o dvou základních
nástrojích určených především pro sledování volání funkcí z&nbsp;knihoven
popř.&nbsp;sledování volání systémových funkcí. Tyto nástroje se jmenují
<strong>ltrace</strong> (<a href="#k02">kapitola číslo 2</a>) a
<strong>strace</strong> (<a href="#k06">kapitola číslo 6</a>). Pokud možnosti
těchto dvou nástrojů nestačí, je možné použít složitější prostředky typu <i>GNU
Debuggeru</i> (<a href="#k08">kapitola číslo 8</a>), prozatím neoficiální verze
nástroje <i>DTrace</i> (<a href="#k09">kapitole 9</a>) nebo sofistikované
utility nazvané <i>SystemTap</i> (<a href="#k11">jedenáctá kapitola</a>).</p>

<p>Typická aplikace běžící v&nbsp;uživatelském prostoru volá funkce různých
(nativních) knihoven, zejména pak knihovny <strong>glibc</strong>. Funkce
z&nbsp;<strong>glibc</strong> následně volají systémové funkce implementované
(zjednodušeně řečeno) v&nbsp;kernelu nebo v&nbsp;jeho modulech:</p>

<pre>
+----------+
|          |
| aplikace |
|          |
+----------+
     |
     |
     v
+----------+
|          |
|  glibc   |
|          |
+----------+
     |
     |
     v
+----------+
|          |
|  jádro   |
|          |
+----------+
</pre>

<p>Pro sledování volání funkcí z&nbsp;nativních knihoven se používá
<strong>ltrace</strong>, pro systémové volání <strong>strace</strong>, samotný
<i>GNU Debugger</i> je možné použít pro ladění aplikace i knihoven a
<i>SystemTap</i> je použitelný ve všech úrovních, a to včetně sledování stavů
jádra operačního systému (KGDB si prozatím popisovat nebudeme):</p>

<pre>
+----------+
|          |..... gdb
| aplikace |
|          |..... SystemTap
+----------+
     |
     |...... ltrace
     v
+----------+
|          |..... gdb
|  glibc   |
|          |..... SystemTap
+----------+
     |
     |...... strace
     v
+----------+
|          |..... SystemTap
|  jádro   |
|          |..... KGDB
+----------+
</pre>



<p><a name="k02"></a></p>
<h2 id="k02">2. Utilita <strong>ltrace</strong> &ndash; výpis informací o volaných knihovních funkcích</h2>

<p>Prvním nástrojem, s&nbsp;nímž se v&nbsp;dnešním článku ve stručnosti
seznámíme, je utilitka nazvaná jednoduše <strong>ltrace</strong>. Tento nástroj
je možné použít ve chvíli, kdy potřebujeme zjistit, které knihovní funkce se
volají popř.&nbsp;jak často se tyto funkce volají a kolik času v&nbsp;nich
některá aplikace tráví. Takto zjištěné statistické informace lze použít různým
způsobem, například pro vyhledání problémových či pomalých částí kódu,
zjištění, ve kterých místech dokází k&nbsp;chybě, zjištění způsobů alokace a
dealokace paměti (funkce <strong>malloc</strong>, <strong>free</strong> a
příbuzné), popř.&nbsp;k&nbsp;jednoduchému trasování (což je asi nejběžnější).
V&nbsp;tom nejjednodušším případě se <strong>ltrace</strong> používá
následujícím způsobem:</p>

<pre>
ltrace jméno_binární_aplikace parametry_aplikace
</pre>

<p>popř.&nbsp;pokud je zapotřebí předat parametry i samotnému nástroji
<strong>ltrace</strong>:</p>

<pre>
ltrace parametry_ltrace jméno_binární_aplikace parametry_aplikace
</pre>



<p><a name="k03"></a></p>
<h2 id="k03">3. Ukázka použití utility <strong>ltrace</strong></h2>

<p>Podívejme se nyní na základní použití nástroje <strong>ltrace</strong>.
Použijeme přitom demonstrační příklady, jejichž zdrojové kódy jsou zmíněny <a
href="#k13">ve třinácté kapitole</a>. Takže začněme:</p>

<pre>
<strong>ltrace ./hello</strong>
&nbsp;
__libc_start_main(0x40053d, 1, 0x7fffd2e1f5f8, 0x400560 &lt;unfinished ...&gt;
puts("Hello world!"Hello world!
)                                                                    = 13
+++ exited (status 0) +++
</pre>

<p>V&nbsp;tomto jednoduchém příkladu se (přímo) mnoho knihovních funkcí
nevolá.</p>

<pre>
<strong>ltrace ./random_bitmap</strong>
&nbsp;
__libc_start_main(0x400bf4, 1, 0x7fff18e8d758, 0x400c70 &lt;unfinished ...&gt;
puts("processing:")                                                                     = 12
malloc(16)                                                                              = 0xa11010
malloc(921600)                                                                          = 0x7f45fdb46010
memset(0x7f45fdb46010, '\0', 921600)                                                    = 0x7f45fdb46010
memset(0x7f45fdb46010, '\0', 921600)                                                    = 0x7f45fdb46010
open("/dev/urandom", 0, 037560470000)                                                   = 3
read(3, "\270\325\332\340r8\304\354\306A\001S", 1920)                                   = 1920
...
...
...
vynecháno přibližně 480 řádků
...
...
...
close(3)                                                                                = 0
fopen("random.bmp", "wb")                                                               = 0xa11030
fwrite("BMF", 54, 1, 0xa11030)                                                          = 1
printf("%d pixels written\n", 307200)                                                   = 22
fwrite("\270\325\332\340r8\304\354\306A\001S", 921600, 1, 0xa11030)                     = 1
fclose(0xa11030)                                                                        = 0
puts("done!\n")                                                                         = 7
+++ exited (status 0) +++
</pre>

<p>Povšimněte si, že u funkcí se vypisují i jejich parametry. Můžeme zde
vysledovat základní logiku aplikace, od alokace paměti pro hlavičku bitmapy i
pro celou bitmapu:</p>

<pre>
bitmap *p=(bitmap *)malloc(sizeof(bitmap)); <i>/* alokace struktury bitmapy */</i>
if (!p) return NULL;
p-&gt;width=width;                             <i>/* naplneni struktury */</i>
p-&gt;height=height;
p-&gt;pixels=(unsigned char *)malloc(3*width*height);
</pre>

<p>přes čtení náhodných čísel:</p>

<pre>
int randomDataDevice = open("/dev/urandom", O_RDONLY);
size_t i;
unsigned char *pixels_ptr = p-&gt;pixels;
for (i=0; i &lt; p-&gt;height; i++)
{
    <i>/* nacteni celeho radku */</i>
    ssize_t result = read(randomDataDevice, pixels_ptr, 3*p-&gt;width);
    if (result &gt;= 0)
    {
        <i>/* posun ukazatele na dalsi radek */</i>
        pixels_ptr+=result;
    }
    else
    {
        perror("urandom read failed");
        close(randomDataDevice);
        return;
    }
}
close(randomDataDevice);
</pre>

<p>Až po závěrečnou sekvenci:</p>

<pre>
fout=fopen(fileName, "wb");
if (!fout) return;
fwrite(bmp_header, sizeof(bmp_header), 1, fout);
printf("%d pixels written\n", width * height);
fwrite(p-&gt;pixels, 3 * width * height, 1, fout);
fclose(fout);
puts("done!\n");
</pre>

<p>Poslední příklad:</p>

<pre>
<strong>ltrace ./fractal_renderer</strong>
&nbsp;
__libc_start_main(0x400ec2, 1, 0x7fff0293d968, 0x400f60 &lt;unfinished ...&gt;
puts("processing:")                                                                     = 12
malloc(16)                                                                              = 0xf7f010
malloc(921600)                                                                          = 0x7fb63dc5a010
memset(0x7fb63dc5a010, '\0', 921600)                                                    = 0x7fb63dc5a010
memset(0x7fb63dc5a010, '\0', 921600)                                                    = 0x7fb63dc5a010
sin(0xf7f010, 1000, 0, 0xf7f010)                                                        = 0x3fa11111
...
...
...
vynechána další volání funkce sin - 614400x !!!
...
...
...
fopen("result.bmp", "wb")                                                               = 0xf7f030
fwrite("BMF", 54, 1, 0xf7f030)                                                          = 1
printf("%d pixels written\n", 307200)                                                   = 22
fwrite("z\036zz\036zz\036zz\036zz\036zz\036zz\036zz\036zz\036zz\036zz\036"..., 921600, 1, 0xf7f030) = 1
fclose(0xf7f030)                                                                        = 0
puts("done!\n")                                                                         = 7
+++ exited (status 0) +++
</pre>

<p>Zde můžeme vidět, že jasně dominuje volání funkce <i>sin</i> z&nbsp;knihovny
<strong>libm</strong>.</p>



<p><a name="k04"></a></p>
<h2 id="k04">4. Zjištění doby trvání volané funkce a filtrace výstupu</h2>

<p>Pokud potřebujete zjistit čas volání nějaké funkce, je možné použít přepínač
<strong>-t</strong>. Výsledek pak vypadá takto:</p>

<pre>
<strong>ltrace -t ./hello</strong>
&nbsp;
20:17:06 __libc_start_main(0x40053d, 1, 0x7fff74550708, 0x400560 &lt;unfinished ...&gt;
20:17:06 puts("Hello world!"Hello world!
)                                                           = 13
20:17:06 +++ exited (status 0) +++
</pre>

<p>Pokud se namísto přepínače <strong>-t</strong> použije přepínač
<strong>-tt</strong>, zvětší se přesnost na milesekundy:</p>

<pre>
<strong>ltrace -tt ./hello</strong>
&nbsp;
20:49:54.521242 __libc_start_main(0x40053d, 1, 0x7fff78e06dd8, 0x400560 &lt;unfinished ...&gt;
20:49:54.521862 puts("Hello world!"Hello world!
)                                                  = 13
20:49:54.522886 +++ exited (status 0) +++
</pre>

<p>Samozřejmě je možné zjistit nejenom okamžik, kdy se do funkce vstupuje, ale
i dobu trvání knihovních funkcí, a to díky přepínači <strong>-r</strong>:</p>

<pre>
<strong>ltrace -r ./hello</strong>
&nbsp;
  0.000000 __libc_start_main(0x40053d, 1, 0x7fffdd8d7208, 0x400560 &lt;unfinished ...&gt;
  0.000479 puts("Hello world!"Hello world!
)                                                         = 13
  0.000985 +++ exited (status 0) +++
</pre>

<p>Mnohdy nepotřebujeme zjistit všechny volané knihovní funkce, ale pouze
vypranou podmnožinu z&nbsp;nich. Zde přichází ke slovu přepínač
<strong>-e</strong>, kterému můžeme předat seznam funkcí, které nás zajímají.
Funkce se zapisují ve formě jednoduchého jazyka, což například znamená, že pro
filtraci těch funkcí, jejichž volání nás zajímá, se vkládají znaky +:</p>

<pre>
<strong>ltrace -e malloc+free+open+close ./random_bitmap</strong>
&nbsp;
processing:
random_bitmap-&gt;malloc(16)                                                               = 0x2137010
random_bitmap-&gt;malloc(921600)                                                           = 0x7f4fb333c010
random_bitmap-&gt;open("/dev/urandom", 0, 026320350000)                                    = 3
random_bitmap-&gt;close(3)                                                                 = 0
307200 pixels written
done!
&nbsp;
+++ exited (status 0) +++
</pre>

<p>Naopak je možné při použití znaku - (minus) odfiltrovat ty knihovní funkce,
které nás v&nbsp;daném okamžiku nezajímají. Řekněme, že nepotřebujeme sledovat
volání funkce <strong>read</strong>:</p>

<pre>
<strong>ltrace -e -read ./random_bitmap</strong>
&nbsp;
random_bitmap-&gt;__libc_start_main(0x400bf4, 1, 0x7fff7c9456e8, 0x400c70 &lt;unfinished ...&gt;
random_bitmap-&gt;puts("processing:"processing:
)                                                      = 12
random_bitmap-&gt;malloc(16 &lt;unfinished ...&gt;
libc.so.6-&gt;(0x7f7140a97bd0, 0x7fff7c945550, 0x7fff7c945540, 0)                          = 0x7f7140ffa4c0
&lt;... malloc resumed&gt; )                                                                  = 0x1ee3010
random_bitmap-&gt;malloc(921600)                                                           = 0x7f7140ef3010
random_bitmap-&gt;memset(0x7f7140ef3010, '\0', 921600)                                     = 0x7f7140ef3010
random_bitmap-&gt;memset(0x7f7140ef3010, '\0', 921600)                                     = 0x7f7140ef3010
random_bitmap-&gt;open("/dev/urandom", 0, 010077240000)                                    = 3
random_bitmap-&gt;close(3)                                                                 = 0
random_bitmap-&gt;fopen("random.bmp", "wb" &lt;unfinished ...&gt;
libc.so.6-&gt;memalign(568, 0x400cf4, 1, 0)                                                = 0x1ee3030
&lt;... fopen resumed&gt; )                                                                   = 0x1ee3030
random_bitmap-&gt;fwrite("BMF", 54, 1, 0x1ee3030)                                          = 1
random_bitmap-&gt;printf("%d pixels written\n", 307200307200 pixels written
)                                    = 22
random_bitmap-&gt;fwrite("Z\226\314H7\316\301\306\340\367iI\324O\332|\005\035![BL\325u\271\335L", 921600, 1, 0x1ee3030) = 1
random_bitmap-&gt;fclose(0x1ee3030 &lt;unfinished ...&gt;
libc.so.6-&gt;(0x1ee3030, 0, 0x1ee3110, 0xfbad000c)                                        = 1
&lt;... fclose resumed&gt; )                                                                  = 0
random_bitmap-&gt;puts("done!\n"done!
&nbsp;
)                                                          = 7
libc.so.6-&gt;_dl_find_dso_for_object(0x7f7140dd1d90, 0x7f7140dd26c8, 1, -1)               = 0x7f7140fd5690
+++ exited (status 0) +++
</pre>



<p><a name="k05"></a></p>
<h2 id="k05">5. Zjištění statistiky volaných funkcí</h2>

<p>Velmi užitečná je volba <strong>-c</strong>, po jejímž zadání nástroj
<strong>ltrace</strong> zobrazí statistiku volání jednotlivých funkcí
s&nbsp;celkovým i průměrným časem, který program v&nbsp;dané funkci strávil.
Opět si uveďme příklady:</p>

<pre>
<strong>ltrace -c ./hello</strong>
&nbsp;
Hello world!
&nbsp;
% time     seconds  usecs/call     calls      function
------ ----------- ----------- --------- --------------------
100.00    0.000455         455         1 puts
------ ----------- ----------- --------- --------------------
100.00    0.000455                     1 total
</pre>

<p>Zde asi nedošlo k&nbsp;žádnému většímu překvapení.</p>

<pre>
<strong>ltrace -c ./random_bitmap</strong>
&nbsp;
% time     seconds  usecs/call     calls      function
------ ----------- ----------- --------- --------------------
 97.81    0.228395         475       480 read
  0.73    0.001701         850         2 fwrite
  0.44    0.001032         516         2 memset
  0.29    0.000670         335         2 puts
  0.24    0.000559         279         2 malloc
  0.13    0.000299         299         1 fclose
  0.10    0.000245         245         1 fopen
  0.10    0.000231         231         1 printf
  0.09    0.000214         214         1 open
  0.07    0.000174         174         1 close
------ ----------- ----------- --------- --------------------
100.00    0.233520                   493 total
</pre>

<p>Povšimněte si, že funkce <strong>read()</strong> se volala přesně
480&times;, což odpovídá zdrojovému kódu:</p>

<pre>
<i>/* rozmery bitmapy */</i>
#define BITMAP_WIDTH    640
#define BITMAP_HEIGHT   480
...
...
...
void fillBitmap(const bitmap *p)
{
    int randomDataDevice = open("/dev/urandom", O_RDONLY);
    size_t i;
    unsigned char *pixels_ptr = p-&gt;pixels;
    for (i=0; i &lt; p-&gt;height; i++)
    {
        <i>/* nacteni celeho radku */</i>
        ssize_t result = read(randomDataDevice, pixels_ptr, 3*p-&gt;width);
        if (result &gt;= 0)
        {
            <i>/* posun ukazatele na dalsi radek */</i>
            pixels_ptr+=result;
        }
        else
        {
            perror("urandom read failed");
            close(randomDataDevice);
            return;
        }
    }
    close(randomDataDevice);
}
</pre>

<pre>
<strong>ltrace -c ./fractal_renderer</strong>
&nbsp;
processing:
307200 pixels written
done!
&nbsp;
% time     seconds  usecs/call     calls      function
------ ----------- ----------- --------- --------------------
 99.99   72.237624         117    614400 sin
  0.00    0.001307         653         2 fwrite
  0.00    0.000695         347         2 puts
  0.00    0.000672         336         2 memset
  0.00    0.000487         487         1 fclose
  0.00    0.000409         409         1 fopen
  0.00    0.000338         169         2 malloc
  0.00    0.000160         160         1 printf
------ ----------- ----------- --------- --------------------
100.00   72.241692                614411 total
</pre>

<p>Podle očekávání (viz <a href="#k04">čtvrtou kapitolu</a>) nás určitě
nepřekvapí, že nejvíce času se celkově (kumulativně) strávilo ve funkci
<strong>sin</strong>, i když tato funkce nepatří mezi nejpomalejší (ve
skutečnosti je ze všech volaných funkcí nejrychlejší).</p>



<p><a name="k06"></a></p>
<h2 id="k06">6. Utilita <strong>strace</strong> &ndash; výpis informací o volaných systémových funkcích</h2>

<p>Druhým nástrojem, s&nbsp;nímž se dnes seznámíme, je utilita nazvaná příhodně
<strong>strace</strong>. Zatímco výše popsaná <strong>ltrace</strong> sloužila
k&nbsp;výpisu volaných knihovních funkcí (pocházejících například
z&nbsp;knihovny <strong>glibc</strong>), je utilita <strong>strace</strong>
určena ke zjištění systémových volání, a to nezávisle na tom, kde toto volání
vzniklo (většinou se jedná opět o knihovnu <strong>glibc</strong>, ovšem nemusí
tomu tak být vždycky. Podobně jako v&nbsp;případě <strong>ltrace</strong> je
možné nástroj <strong>strace</strong> použít buď pro spuštění laděné/trasované
aplikace, nebo je možné se přes přepínač <strong>-p{pid})</strong> připojit
k&nbsp;již běžící aplikaci (to je velmi užitečné například při sledování běhu
&bdquo;živých&ldquo; dlouhoběžících serverových aplikací apod.). Význam
některých přepínačů je u <strong>strace</strong> i <strong>ltrace</strong>
shodný, což je samozřejmě výhodné.</p>



<p><a name="k07"></a></p>
<h2 id="k07">7. Ukázka použití utility <strong>strace</strong></h2>

<p>Podívejme se nyní na základní způsob použití <strong>strace</strong>. Pro
jednoduchost ji vyzkoušíme pouze oproti programu <i>Hello world</i>, který ve
svém kódu volá jedinou funkci <strong>puts</strong> a nic jiného. Ovšem
z&nbsp;pohledu systémových volání je tento program mnohem složitější, o čemž se
lze velmi snadno přesvědčit:</p>

<pre>
<strong>strace ./hello</strong>
&nbsp;
execve("./hello", ["./hello"], [/* 53 vars */]) = 0
brk(0)                                  = 0xa52000
access("/etc/ld.so.nohwcap", F_OK)      = -1 ENOENT (No such file or directory)
mmap(NULL, 8192, PROT_READ|PROT_WRITE, MAP_PRIVATE|MAP_ANONYMOUS, -1, 0) = 0x7fd1af21d000
access("/etc/ld.so.preload", R_OK)      = -1 ENOENT (No such file or directory)
open("/etc/ld.so.cache", O_RDONLY|O_CLOEXEC) = 3
fstat(3, {st_mode=S_IFREG|0644, st_size=132679, ...}) = 0
mmap(NULL, 132679, PROT_READ, MAP_PRIVATE, 3, 0) = 0x7fd1af1fc000
close(3)                                = 0
access("/etc/ld.so.nohwcap", F_OK)      = -1 ENOENT (No such file or directory)
open("/lib/x86_64-linux-gnu/libc.so.6", O_RDONLY|O_CLOEXEC) = 3
read(3, "\177ELF\2\1\1\0\0\0\0\0\0\0\0\0\3\0&gt;\0\1\0\0\0\320\37\2\0\0\0\0\0"..., 832) = 832
fstat(3, {st_mode=S_IFREG|0755, st_size=1840928, ...}) = 0
mmap(NULL, 3949248, PROT_READ|PROT_EXEC, MAP_PRIVATE|MAP_DENYWRITE, 3, 0) = 0x7fd1aec38000
mprotect(0x7fd1aedf3000, 2093056, PROT_NONE) = 0
mmap(0x7fd1aeff2000, 24576, PROT_READ|PROT_WRITE, MAP_PRIVATE|MAP_FIXED|MAP_DENYWRITE, 3, 0x1ba000) = 0x7fd1aeff2000
mmap(0x7fd1aeff8000, 17088, PROT_READ|PROT_WRITE, MAP_PRIVATE|MAP_FIXED|MAP_ANONYMOUS, -1, 0) = 0x7fd1aeff8000
close(3)                                = 0
mmap(NULL, 4096, PROT_READ|PROT_WRITE, MAP_PRIVATE|MAP_ANONYMOUS, -1, 0) = 0x7fd1af1fb000
mmap(NULL, 8192, PROT_READ|PROT_WRITE, MAP_PRIVATE|MAP_ANONYMOUS, -1, 0) = 0x7fd1af1f9000
arch_prctl(ARCH_SET_FS, 0x7fd1af1f9740) = 0
mprotect(0x7fd1aeff2000, 16384, PROT_READ) = 0
mprotect(0x600000, 4096, PROT_READ)     = 0
mprotect(0x7fd1af21f000, 4096, PROT_READ) = 0
munmap(0x7fd1af1fc000, 132679)          = 0
fstat(1, {st_mode=S_IFCHR|0620, st_rdev=makedev(136, 7), ...}) = 0
mmap(NULL, 4096, PROT_READ|PROT_WRITE, MAP_PRIVATE|MAP_ANONYMOUS, -1, 0) = 0x7fd1af21c000
write(1, "Hello world!\n", 13Hello world!
)          = 13
exit_group(0)                           = ?
+++ exited with 0 +++
</pre>

<p>Povšimněte si způsobu výpisu &ndash; u každého systémového volání jsou
uvedeny parametry, a to v&nbsp;některých případech inteligentně &ndash; namísto
číselné konstanty se používá symbolická konstanta <strong>PROT_READ</strong>
atd. Taktéž se vypisuje návratová hodnota volání, a to opět (pokud je to možné)
formou symbolické konstanty (<strong>ENOENT</strong>) popř.&nbsp;zprávy
(&bdquo;No such file or directory&ldquo;.). Na konci můžeme vidět, že volání
<strong>puts</strong> se provede formou <strong>write</strong> na standardní
výstup (vrátí se počet zapsaných/vytištěných bajtů).</p>



<p><a name="k08"></a></p>
<h2 id="k08">8. GNU Debugger</h2>

<p>Od relativně jednoduchých a snadno použitelných nástrojů určených pro
&bdquo;pouhé&ldquo; trasování se na chvíli přesuňme k&nbsp;debuggerům, což jsou
složitější, ovšem také mnohem mocnější nástroje. Pro operační systém Linux
existuje větší množství debuggerů, včetně několika komerčních nástrojů
(příkladem může být <i>Affinic</i> a <i>TotalView</i>), ovšem nejpoužívanějším
debuggerem je pravděpodobně stále <i>GNU Debugger</i> neboli <i>GDB</i>, jehož
první verze vznikla již v&nbsp;roce 1986, takže se po třiceti letech
kontinuálního vývoje jedná o velmi vyzrálý produkt. <i>GNU Debugger</i> byl
v&nbsp;průběhu svého vývoje portován jak na mnoho operačních systémů (většinou
na různé komerční i nekomerční varianty Unixu, ovšem nalezneme ho například i
v&nbsp;systému DOS), tak i na nepřeberné množství procesorových a
mikroprocesorových architektur, z&nbsp;nichž jmenujme především řadu x86,
x86_64, ARM (prakticky všechny 32bitové CPU i nová 64bitová jádra), Motorola
68HC11, MIPS či PowerPC.</p>

<p>Tento debugger podporuje všechny překladače z&nbsp;rodiny GNU, což
mj.&nbsp;znamená, že dokáže zobrazit a pracovat se zdrojovými kódy
v&nbsp;jazycích Ada, C, C++, Go, Objective-C, D, Fortran, Modula-2, Pascal a
Java (ovšem jen v&nbsp;případě překladu Javy do nativního kódu). Na základě
jazyka, v&nbsp;němž je laděný program napsán, se upravují i zprávy <i>GNU
Debuggeru</i>, takže se například používá správný formát hexadecimálních čísel,
struktur záznamů atd. Taktéž assemblery používané na Linuxu <i>GNU Debugger</i>
přímo podporují (jedná se jak o <strong>as</strong>, tak i o
<strong>NASM</strong>). Ladicí nástroj <i>GNU Debugger</i> primárně používá ke
komunikaci s&nbsp;uživatelem příkazový řádek, alternativně lze použít i
protokol pro nepřímé ovládání debuggeru (tuto technologii používají různé
nadstavby nad debuggerem) a v&nbsp;případě potřeby je možné k&nbsp;laděné
aplikaci přidat relativně krátký &bdquo;stub&ldquo; sloužící pro přímé ladění
takové aplikace (touto nepochybně zajímavou problematikou se však dnes nebudeme
zabývat).</p>

<p>Většina často používaných příkazů má i svoji zkrácenou podobu
(<i>bt=backtrace</i>, <i>c=continue</i>, <i>f=frame</i>) a navíc je možné
používat klávesu [Tab] pro automatické doplnění celého jména příkazu. Pokud je
správně nastavený terminál, bude fungovat i historie příkazového řádku, a to
stejným způsobem, jaký známe ze shellu. Alternativně je možné využít
<strong>gdbtui</strong> s&nbsp;celoobrazovkovým výstupem a přiblížit se tak
možnostem debuggerů s&nbsp;plnohodnotným grafickým uživatelským rozhraním.
Pokud se <i>GNU Debugger</i> používá pro trasování, lze do kódu vkládat
takzvané <i>tracepoints</i>. Ty slouží pro zjištění stavu programu
v&nbsp;nějakém specifikovaném bodu, ovšem bez (po)zastavení programu. Samotné
pozastavení programu totiž může v&nbsp;některých případech způsobit jeho
chybnou činnost či naopak zastínit některé chyby vyplývající ze špatně
implementované synchronizace vláken či při přístupu ke sdíleným prostředkům.
Podrobnosti o této užitečné technologii si řekneme v&nbsp;navazujícím
článku.</p>



<p><a name="k09"></a></p>
<h2 id="k09">9. DTrace</h2>

<p>Dalším nástrojem, s&nbsp;nímž se jako vývojáři či administrátoři můžeme na
některých systémech setkat, je <i>DTrace</i>. Tento nástroj původně vznikl pro
operační systém <i>Solaris</i> (dokonce se mělo jednat o jeden z&nbsp;klíčových
nástrojů, kvůli kterému si měli zákazníci koupit <i>Solaris</i> a nikoli
přecházet na <i>Linux</i>) a i přes určitou snahu společnosti <i>Oracle</i> o
konverzi <i>DTrace</i> pro Linux zatím tento nástroj v&nbsp;Linuxu oficiálně
není podporovaný a existuje pouze v&nbsp;beta verzi (dodává přímo Oracle) nebo
v&nbsp;neoficiální verzi dostupné <a
href="https://github.com/dtrace4linux/linux">na GitHubu</a>. <i>DTrace</i> je
založen na použití takzvaných &bdquo;sond&ldquo; (<i>probe</i>), což jsou
z&nbsp;hlediska uživatele (většinou) krátké skripty spuštěné ve chvíli, kdy
dojde k&nbsp;nějaké předem definované události, a to buď přímo v&nbsp;jádře
operačního systému nebo v&nbsp;laděné aplikaci. Samotná sonda (skript) má
přístup k&nbsp;zásobníkovému rámci a tedy i k&nbsp;lokálním proměnným a
parametrům předaným volané funkci.</p>

<p>Příklad naprogramované sondy:</p>

<pre>
#pragma D option flowindent
&nbsp;
syscall::write:entry
/pid == $target/    
{
        printf("Written %d bytes\n", arg2);
}
</pre>

<p>Pro zápis sond se sice používá programovací jazyk nazvaný <i>D</i>, ovšem
jedná se o &bdquo;jiné D&ldquo;, než <a
href="http://dlang.org/">http://dlang.org/</a>. Jazyk <i>D</i> použitý
v&nbsp;DTrace je sice syntakticky taktéž podobný jazyku C, ovšem sémanticky se
jedná o zcela odlišné jazyky s&nbsp;různými pravidly i překladači. Podrobnější
popis tohoto jazyka lze nalézt na stránce <a
href="http://docs.oracle.com/cd/E53394_01/html/E53395/gkwpo.html">http://docs.oracle.com/cd/E53394_01/html/E53395/gkwpo.html</a></p>



<p><a name="k10"></a></p>
<h2 id="k10">10. SystemTap</h2>

<p>Nástroj <i>SystemTap</i> je v&nbsp;některých ohledech podobný výše zmíněné
utilitě <i>DTrace</i>. I v&nbsp;<i>SystemTapu</i> se s&nbsp;využitím
programovacího jazyka deklarují takzvané sondy (<i>probe</i>) a určuje se, za
jakých okolností se mají tyto sondy provést. <i>SystemTap</i> lze použít jak
pro zjišťování procesů probíhajících v&nbsp;kernelu, tak i v&nbsp;uživatelském
prostoru (userspace). Sledovat lze například sycally (systémová volání),
operace nad soubory, vstupy do funkcí na všech úrovních atd. Poněkud složitější
bývala instalace <i>SystemTapu</i> (především kvůli nutnosti operovat
s&nbsp;ladicími symboly jádra), to se však zlepšilo přidáním utility
<strong>stap-prep</strong>. Předpokládejme, že balíček <i>SystemTap</i> je
nainstalovaný. Potom příkaz <strong>stap-prep</strong> zjistí, jaké další
balíčky je nutné doinstalovat a kde je získat (u Ubuntu se jedná o jiné kanály
atd.):</p>

<pre>
<strong>stap-prep</strong>
&nbsp;
Need to install the following packages:
kernel-devel-3.15.6-200.fc20.x86_64
kernel-debuginfo-3.15.6-200.fc20.x86_64
</pre>

<p>V&nbsp;některých případech <strong>stap-prep</strong> instalaci sám provede.
Vezměme si příklad z&nbsp;Fedory:</p>

<pre>
<strong>stap-prep</strong>
&nbsp;
Need to install the following packages:
kernel-devel-4.4.8-300.fc23.x86_64
kernel-debuginfo-4.4.8-300.fc23.x86_64
Yum command has been deprecated, redirecting to '/usr/bin/dnf install -y --enablerepo=* kernel-devel-4.4.8-300.fc23.x86_64 kernel-debuginfo-4.4.8-300.fc23.x86_64'.
See 'man dnf' and 'man yum2dnf' for more information.
To transfer transaction metadata from yum to DNF, run:
'dnf install python-dnf-plugins-extras-migrate &amp;&amp; dnf-2 migrate'
Fedora 23 - x86_64 - Test Updates                                                     50 MB/s | 2.4 MB     00:00
Fedora 23 - x86_64 - Debug                                                            46 MB/s |  11 MB     00:00
Fedora 23 - Test Updates Source                                                      4.1 MB/s | 330 kB     00:00
Fedora 23 - Updates Source                                                            14 MB/s | 2.5 MB     00:00
Fedora 23 - x86_64 - Updates - Debug                                                  45 MB/s | 6.2 MB     00:00
Fedora 23 - x86_64                                                                    52 MB/s |  43 MB     00:00
Fedora 23 - x86_64 - Test Updates Debug                                               34 MB/s | 885 kB     00:00
Fedora 23 - Source                                                                   8.3 MB/s | 5.9 MB     00:00
Last metadata expiration check: 0:00:03 ago on Wed May 11 16:05:54 2016.
Dependencies resolved.
===================================================================================================================
 Package                                  Arch        Version             Repository                          Size
===================================================================================================================
Installing:
 kernel-debuginfo                         x86_64      4.4.8-300.fc23      updates-debuginfo                  379 M
 kernel-debuginfo-common-x86_64           x86_64      4.4.8-300.fc23      updates-debuginfo                   53 M
 kernel-devel                             x86_64      4.4.8-300.fc23      updates                             10 M
&nbsp;
Transaction Summary
===================================================================================================================
Install  3 Packages
&nbsp;
Total download size: 443 M
Installed size: 2.0 G
Downloading Packages:
(1/3): kernel-devel-4.4.8-300.fc23.x86_64.rpm                                       26 MB/s |  10 MB     00:00
(2/3): kernel-debuginfo-common-x86_64-4.4.8-300.fc23.x86_64.rpm                     26 MB/s |  53 MB     00:02
(3/3): kernel-debuginfo-4.4.8-300.fc23.x86_64.rpm                                   26 MB/s | 379 MB     00:14
--------------------------------------------------------------------------------------------------------------
Total                                                                               27 MB/s | 443 MB     00:16
Running transaction check
Transaction check succeeded.
Running transaction test
Transaction test succeeded.
Running transaction
  Installing  : kernel-debuginfo-common-x86_64-4.4.8-300.fc23.x86_64                                     1/3
  Installing  : kernel-debuginfo-4.4.8-300.fc23.x86_64                                                   2/3
  Installing  : kernel-devel-4.4.8-300.fc23.x86_64                                                       3/3
  Verifying   : kernel-devel-4.4.8-300.fc23.x86_64                                                       1/3
  Verifying   : kernel-debuginfo-4.4.8-300.fc23.x86_64                                                   2/3
  Verifying   : kernel-debuginfo-common-x86_64-4.4.8-300.fc23.x86_64                                     3/3
&nbsp;
Installed:
  kernel-debuginfo.x86_64 4.4.8-300.fc23                            kernel-debuginfo-common-x86_64.x86_64 4.4.8-300.fc23                            kernel-devel.x86_64 4.4.8-300.fc23                           
&nbsp;
Complete!
kernel-devel-4.4.8-300.fc23.x86_64
kernel-debuginfo-4.4.8-300.fc23.x86_64
</pre>

<p>Po instalaci se může provést kontrola, která má dle oficiální dokumentace
vypadat takto:</p>

<pre>
<strong>stap -v -e 'probe vfs.read {printf("read performed\n"); exit()}'</strong>
&nbsp;
Pass 1: parsed user script and 118 library scripts using 233764virt/36948res/7372shr/29452data kb, in 200usr/30sys/471real ms.
Pass 2: analyzed script: 1 probe, 1 function, 4 embeds, 0 globals using 372776virt/170852res/8824shr/168464data kb, in 3560usr/400sys/4282real ms.
Pass 3: translated to C into "/tmp/stapWy5VWo/stap_5ec9a356f694741098a16e111db111c9_1654_src.c" using 372776virt/171052res/9024shr/168464data kb, in 10usr/10sys/19real ms.
Pass 4: compiled C into "stap_5ec9a356f694741098a16e111db111c9_1654.ko" in 16650usr/3190sys/20283real ms.
Pass 5: starting run.
read performed
Pass 5: run completed in 20usr/60sys/440real ms.
</pre>



<p><a name="k11"></a></p>
<h2 id="k11">11. Ukázky použití SystemTapu</h2>

<p>Podrobnější informace o <i>SystemTapu</i> si uvedeme příště, takže si dnes
jen pro ilustraci uveďme několik jednoduchých sond.</p>

<p>Sonda, která ihned po svém spuštění (<strong>begin</strong>) vypíše zprávu
na standardní výstup a ukončí se. Povšimněte si, že se syntaxe zápisu podobá
standardnímu céčku, což samozřejmě není náhoda:</p>

<pre>
probe begin
{
    printf ("hello world\n")
    exit ()
}
</pre>

<p>Spuštění této sondy:</p>

<pre>
<strong>stap hello.stp</strong>
&nbsp;
hello world
</pre>

<p>Poněkud složitější sonda, která pozdraví uživatele jeho ID:</p>

<pre>
probe begin
{
  printf ("hello %d\n", uid())
  exit ()
}
</pre>

<p>Spuštění této sondy (spuštěno pod rootem, takže UID by mělo být 0):</p>

<pre>
<strong>stap hello2.stp</strong>
&nbsp;
hello 0
</pre>

<p>Sonda reagující na časovač &ndash; po každé sekundě se vypíše zpráva:</p>

<pre>
probe timer.ms(1000)
{
  printf ("tiktak\n")
}
</pre>

<p>Spuštění této sondy:</p>

<pre>
<strong>stap clock.stp</strong>
&nbsp;
tiktak
tiktak
tiktak
</pre>

<p>Výpis všech typů sond, které je možné použít:</p>

<pre>
stap  --dump-probe-types
</pre>

<p>Prozatím nejsložitější příklad &ndash; reakce na spuštění programu nazvaného
<strong>hello</strong>, reakce na ukončení tohoto programu a taktéž reakce na
vstup do funkce <strong>main</strong> v&nbsp;tomto programu:</p>

<pre>
probe process("hello").begin
{
  printf ("started\n")
}
&nbsp;
&nbsp;
&nbsp;
probe process("hello").end
{
    printf ("finished\n")
}
&nbsp;
&nbsp;
&nbsp;
probe process("hello").function("main")
{
    printf ("main function\n")
}
</pre>

<p>Sondu zaregistrujeme:</p>

<pre>
<strong>stab process.stp</strong>
</pre>

<p>a následně v&nbsp;jiném terminálu spustíme náš program typu <i>Hello
world!</i>:</p>

<pre>
./hello
</pre>

<p>Ten se spustí, vypíše zprávu a ukončí se, zatímco sonda na prvním terminálu
zareaguje následovně:</p>

<pre>
started
main function
finished
</pre>



<p><a name="k12"></a></p>
<h2 id="k12">12. Obsah následujícího článku</h2>

<p>V&nbsp;následující části tohoto článku si řekneme podrobnější informace o
možnostech <i>GNU Debuggeru</i> (což je jedna z&nbsp;nejpropracovanějších GNU
utilit vůbec) a taktéž o <i>SystemTapu</i>. V&nbsp;případě <i>SystemTapu</i> si
ukážeme složitější sondy sloužící mj.&nbsp;i pro zjišťování různých
statistických informací, pro profilování aplikace atd.</p>



<p><a name="k13"></a></p>
<h2 id="k13">13. Demonstrační příklady použité v&nbsp;dnešním článku</h2>

<p>Všechny tři demonstrační příklady, které jsme používali při popisu nástrojů
<strong>ltrace</strong>, <strong>strace</strong> i <strong>SystemTap</strong>,
byly uloženy do GIT repositáře nazvaného <a
href="https://github.com/tisnik/presentations">https://github.com/tisnik/presentations</a>:</p>

<table>
<tr><th>#</th><th>Program</th><th>URL do GITu</th></tr>
<tr><td>1</td><td>hello.c</td><td><a href="https://github.com/tisnik/presentations/blob/master/tracing/hello.c">https://github.com/tisnik/presentations/blob/master/tracing/hello.c</a></td></tr>
<tr><td>2</td><td>random_bitmap.c</td><td><a href="https://github.com/tisnik/presentations/blob/master/tracing/random_bitmap.c">https://github.com/tisnik/presentations/blob/master/tracing/random_bitmap.c</a></td></tr>
<tr><td>3</td><td>fractal_renderer.c</td><td><a href="https://github.com/tisnik/presentations/blob/master/tracing/fractal_renderer.c">https://github.com/tisnik/presentations/blob/master/tracing/fractal_renderer.c</a></td></tr>
</table>

<p>Způsob překladu těchto tří příkladu je ve skutečnosti velmi jednoduchý:</p>

<pre>
gcc -ansi -pedantic -Wall -o hello hello.c
gcc -ansi -pedantic -Wall -o random_bitmap random_bitmap.c
gcc -ansi -pedantic -Wall -o fractal_renderer fractal_renderer.c -lm
</pre>

<p>Poznámka: u posledního příkladu nezapomeňte přilinkovat knihovnu
s&nbsp;matematickými funkcemi <strong>libm</strong>.</p>

<a href="http://www.root.cz/obrazek/248996/"><img src="https://i.iinfo.cz/images/201/tracing1-1-prev.png" class="image-248996" alt="&#160;" height="270" width="360" /></a>
<p><i>Obrázek 1: Výsledek aplikace <strong>random_bitmap</strong>.</i></p>

<a href="http://www.root.cz/obrazek/248997/"><img src="https://i.iinfo.cz/images/201/tracing1-2-prev.png" class="image-248997" alt="&#160;" height="270" width="360" /></a>
<p><i>Obrázek 2: Výsledek aplikace <strong>fractal_renderer</strong>.</i></p>



<p><a name="k14"></a></p>
<h2 id="k14">14. Odkazy na Internetu</h2>

<ol>

<li>Tracing (software)<br />
<a href="https://en.wikipedia.org/wiki/Tracing_%28software%29">https://en.wikipedia.org/wiki/Tracing_%28software%29</a>
</li>

<li>ltrace(1) - Linux man page<br />
<a href="http://linux.die.net/man/1/ltrace">http://linux.die.net/man/1/ltrace</a>
</li>

<li>ltrace (Wikipedia)<br />
<a href="https://en.wikipedia.org/wiki/Ltrace">https://en.wikipedia.org/wiki/Ltrace</a>
</li>

<li>strace(1) - Linux man page<br />
<a href="http://linux.die.net/man/1/strace">http://linux.die.net/man/1/strace</a>
</li>

<li>strace (stránka projektu na SourceForge)<br />
<a href="https://sourceforge.net/projects/strace/">https://sourceforge.net/projects/strace/</a>
</li>

<li>strace (Wikipedia)<br />
<a href="https://en.wikipedia.org/wiki/Strace">https://en.wikipedia.org/wiki/Strace</a>
</li>

<li>SystemTap (stránka projektu)<br />
<a href="https://sourceware.org/systemtap/">https://sourceware.org/systemtap/</a>
</li>

<li>SystemTap (Wiki projektu)<br />
<a href="https://sourceware.org/systemtap/wiki">https://sourceware.org/systemtap/wiki</a>
</li>

<li>SystemTap (Wikipedia)<br />
<a href="https://en.wikipedia.org/wiki/SystemTap">https://en.wikipedia.org/wiki/SystemTap</a>
</li>

<li>Dynamic Tracing with DTrace &amp; SystemTap<br />
<a href="http://myaut.github.io/dtrace-stap-book/">http://myaut.github.io/dtrace-stap-book/</a>
</li>

<li>DTrace (Wikipedia)<br />
<a href="https://en.wikipedia.org/wiki/DTrace">https://en.wikipedia.org/wiki/DTrace</a>
</li>

<li>GDB - Dokumentace<br />
<a href="http://sourceware.org/gdb/current/onlinedocs/gdb/">http://sourceware.org/gdb/current/onlinedocs/gdb/</a>
</li>

<li>GDB - Supported Languages<br />
<a href="http://sourceware.org/gdb/current/onlinedocs/gdb/Supported-Languages.html#Supported-Languages">http://sourceware.org/gdb/current/onlinedocs/gdb/Supported-Languages.html#Supported-Languages</a>
</li>

<li>GNU Debugger (Wikipedia)<br />
<a href="https://en.wikipedia.org/wiki/GNU_Debugger">https://en.wikipedia.org/wiki/GNU_Debugger</a>
</li>

<li>The LLDB Debugger<br />
<a href="http://lldb.llvm.org/">http://lldb.llvm.org/</a>
</li>

<li>Debugger (Wikipedia)<br />
<a href="https://en.wikipedia.org/wiki/Debugger">https://en.wikipedia.org/wiki/Debugger</a>
</li>

<li>13 Linux Debuggers for C++ Reviewed<br />
<a href="http://www.drdobbs.com/testing/13-linux-debuggers-for-c-reviewed/240156817">http://www.drdobbs.com/testing/13-linux-debuggers-for-c-reviewed/240156817</a>
</li>

<li>Getting started with ltrace: how does it do that?<br />
<a href="https://www.ellexus.com/getting-started-with-ltrace-how-does-it-do-that/">https://www.ellexus.com/getting-started-with-ltrace-how-does-it-do-that/</a>
</li>

<li>Reverse Engineering Tools in Linux – strings, nm, ltrace, strace, LD_PRELOAD<br />
<a href="http://www.thegeekstuff.com/2012/03/reverse-engineering-tools/">http://www.thegeekstuff.com/2012/03/reverse-engineering-tools/</a>
</li>

<li>7 Strace Examples to Debug the Execution of a Program in Linux<br />
<a href="http://www.thegeekstuff.com/2011/11/strace-examples/">http://www.thegeekstuff.com/2011/11/strace-examples/</a>
</li>

<li>Oracle® Solaris 11.3 DTrace (Dynamic Tracing) Guide<br />
<a href="http://docs.oracle.com/cd/E53394_01/html/E53395/gkwpo.html#scrolltoc">http://docs.oracle.com/cd/E53394_01/html/E53395/gkwpo.html#scrolltoc</a>
</li>

</ol>



<p></p><p></p>
<p><small>Autor: <a href="http://www.fit.vutbr.cz/~tisnovpa">Pavel Tišnovský</a> &nbsp; 2016</small></p>
</body>
</html>

