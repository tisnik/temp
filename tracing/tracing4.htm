<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
        "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html>
<head>
<title>Trasování a ladění nativních aplikací v Linuxu: použití nástroje SystemTap</title>
<meta name="Author" content="Pavel Tisnovsky" />
<meta name="Generator" content="vim" />
<meta http-equiv="content-type" content="text/html; charset=utf-8" />
<style type="text/css">
         body {color:#000000; background:#ffffff;}
         h1  {font-family: arial, helvetica, sans-serif; color:#ffffff; background-color:#c00000; text-align:center; padding-left:1em}
         h2  {font-family: arial, helvetica, sans-serif; color:#ffffff; background-color:#0000c0; padding-left:1em; text-align:left}
         h3  {font-family: arial, helvetica, sans-serif; color:#000000; background-color:#c0c0c0; padding-left:1em; text-align:left}
         h4  {font-family: arial, helvetica, sans-serif; color:#000000; background-color:#e0e0e0; padding-left:1em; text-align:left}
         a   {font-family: arial, helvetica, sans-serif;}
         li  {font-family: arial, helvetica, sans-serif; color:#000000; text-align:justify; width:450px;}
         ol  {font-family: arial, helvetica, sans-serif; color:#000000; text-align:justify; width:450px;}
         ul  {font-family: arial, helvetica, sans-serif; color:#000000; text-align:justify; width:450px;}
         p   {font-family: arial, helvetica, sans-serif; color:#000000; text-align:justify;}
         pre {background:#e0e0e0}
</style>
</head>

<body>

<h1>Trasování a ladění nativních aplikací v Linuxu: použití nástroje SystemTap</h1>

<h3>Pavel Tišnovský</h3>

<p></p>

<h1>Úvodník</h1>

<p>Ve čtvrté části seriálu o trasování a ladění aplikací v&nbsp;Linuxu si ukážeme některé způsoby použití nástroje SystemTap, s&nbsp;nímž jsme se ve stručnosti seznámili již v&nbsp;úvodním článku. Seznámíme se se způsobem zjišťování volání služeb jádra i přístupu k&nbsp;funkcím uloženým v&nbsp;knihovnách.</p>



<h2>Obsah</h2>

<p><a href="#k01">1. Trasování a ladění nativních aplikací v&nbsp;Linuxu: použití nástroje SystemTap</a></p>
<p><a href="#k02">2. Instalace nástroje SystemTap</a></p>
<p><a href="#k03">3. Vytvoření jednoduché sondy aneb pět možností zápisu &bdquo;Hello world!&ldquo;</a></p>
<p><a href="#k04">4. Implicitní a explicitní řízení pořadí spuštění sond</a></p>
<p><a href="#k05">5. Sondy zavolané při spuštění nebo ukončení programu</a></p>
<p><a href="#k06">6. Detekce systémových volání (syscallů)</a></p>
<p><a href="#k07">7. Vylepšení předchozího programu &ndash; detekce správného čísla procesu</a></p>
<p><a href="#k08">8. Výpis základních informací o syscallu (volané služby jádra)</a></p>
<p><a href="#k09">9. Přístup k&nbsp;bufferu použitém v&nbsp;syscallu write</a></p>
<p><a href="#k10">10. Opravení předchozího příkladu: výpočet skutečné délky řetězce před jeho výpisem</a></p>
<p><a href="#k11">11. Specifikace jména sledovaného programu z&nbsp;příkazové řádky</a></p>
<p><a href="#k12">12. Výpis volaných funkcí</a></p>
<p><a href="#k13">13. Zjištění, odkud se funkce volá (backtrace)</a></p>
<p><a href="#k14">14. Odkazy na Internetu</a></p>



<p><a name="k01"></a></p>
<h2 id="k01">1. Trasování a ladění nativních aplikací v&nbsp;Linuxu: použití nástroje SystemTap</h2>

<p>Ve čtvrté části (mini)seriálu o trasování a ladění nativních aplikací
v&nbsp;Linuxu se budeme zabývat popisem způsobu použití všestranného nástroje
nazvaného <i>SystemTap</i>. Tento nástroj lze použít v&nbsp;mnoha oblastech a
může být užitečný jak pro vývojáře (detekce problémů ve vyvíjené aplikaci či
knihovně), tak i pro administrátory (zjištění statistik o síťovém provozu,
vytížení souborového systému, případných &bdquo;divných&ldquo; volání funkcí
jádra, volání funkcí ze sledovaných knihoven atd.). <i>SystemTap</i> se dokonce
používá v&nbsp;součinnosti s&nbsp;JVM pro trasování volaných Javovských metod
apod., ovšem touto bezpochyby zajímavou funkcionalitou se budeme zabývat
v&nbsp;samostatném článku, protože v&nbsp;tomto případě se nejedná o nativní
aplikace, ale o aplikace určené pro virtuální stroj Javy. I díky těmto
vlastnostem dokáže <i>SystemTap</i> v&nbsp;mnoha případech nahradit podobně
koncipovaný nástroj nazvaný <i>DTrace</i>, který možná znají uživatelé
Solarisu.</p>

<p>V&nbsp;nástroji <i>SystemTap</i> se pracuje s&nbsp;takzvanými sondami
(&bdquo;probe&ldquo;), které mohou sledovat různé události, ke kterým
v&nbsp;systému dochází. Sondy lze nastavit jak na úrovni sledované aplikace
(vstupy do funkcí...), tak i knihoven (volání knihovních funkcí...) a jádra
(syscally, souborový systém, síťový subsystém):</p>

<pre>
+----------+
|          |..... gdb
| aplikace |
|          |..... SystemTap
+----------+
     |
     |...... ltrace
     v
+----------+
|          |..... gdb
|  glibc   |
|          |..... SystemTap
+----------+
     |
     | (syscall)
     |
     |...... strace
     v
+----------+
|          |..... SystemTap
|  jádro   |
|          |..... KGDB
+----------+
</pre>


<p><a name="k02"></a></p>
<h2 id="k02">2. Instalace nástroje SystemTap</h2>

<p>Instalace nástroje <i>SystemTap</i> se skládá z&nbsp;několika kroků.
V&nbsp;prvním kroku je nutné s&nbsp;využitím správce balíčků (<i>apt-get</i>,
<i>yum</i> atd.) nainstalovat balíček nazvaný <strong>systemtap</strong>
popř.&nbsp;u multilib instalace balíček <strong>systemtap.x86_64</strong>. Na
mém testovacím systému s&nbsp;Fedorou 22 se jedná o tento balíček:</p>

<pre>
Name        : systemtap
Arch        : x86_64
Epoch       : 0
Version     : 3.0
Release     : 2.fc22
Size        : 206 k
Repo        : @System
From repo   : fedora-updates
Summary     : Programmable system-wide instrumentation system
URL         : http://sourceware.org/systemtap/
License     : GPLv2+
Description : SystemTap is an instrumentation system for systems running Linux.
            : Developers can write instrumentation scripts to collect data on
            : the operation of the system.  The base systemtap package contains/requires
            : the components needed to locally develop and execute systemtap scripts.
</pre>

<p>Pokud je již balíček <strong>systemtap</strong> nainstalovaný, použijeme
utilitu nazvanou <strong>stap-prep</strong>, která zjistí, jaké další součásti
systému jsou ještě potřeba. Tato utilita je uzpůsobena pro konkrétní
distribuci, takže se například chová odlišně na Fedoře (kde jsou všechny
potřebné balíčky připraveny již v&nbsp;základním kanálu) a na Ubuntu (rozdílné
kanály atd.). Tato utilita se spustí bez parametrů:</p>

<pre>
<strong>stap-prep</strong>
</pre>

<p>Jak jsme si již řekli, tento skript po svém spuštění nejdříve ověří, které
další balíčky je nutné do operačního systému doinstalovat a následně zavolá
příslušného správce balíčků (varování o použití zastaralého příkazu
<strong>yum</strong> namísto novějšího <strong>dnf</strong> můžeme v&nbsp;tuto
chvíli ignorovat):</p>

<pre>
Need to install the following packages:
kernel-devel-4.4.11-200.fc22.x86_64
kernel-debuginfo-4.4.11-200.fc22.x86_64
Yum command has been deprecated, redirecting to '/usr/bin/dnf install -y --enablerepo=* kernel-devel-4.4.11-200.fc22.x86_64 kernel-debuginfo-4.4.11-200.fc22.x86_64'.
See 'man dnf' and 'man yum2dnf' for more information.
To transfer transaction metadata from yum to DNF, run:
'dnf install python-dnf-plugins-extras-migrate &amp;&amp; dnf-2 migrate'
&nbsp;
Last metadata expiration check performed 0:00:11 ago on Tue Jun  7 15:20:06 2016.
Dependencies resolved.
================================================================================
 Package                        Arch   Version          Repository         Size
================================================================================
Installing:
 kernel-debuginfo               x86_64 4.4.11-200.fc22  updates-debuginfo 379 M
 kernel-debuginfo-common-x86_64 x86_64 4.4.11-200.fc22  updates-debuginfo  54 M
 kernel-devel                   x86_64 4.4.11-200.fc22  updates            10 M
&nbsp;
Transaction Summary
================================================================================
Install  3 Packages
&nbsp;
Total download size: 442 M
Installed size: 2.0 G
</pre>

<p>Z&nbsp;předchozího výpisu můžeme vidět, že se budou stahovat a instalovat
velmi objemné balíčky s&nbsp;ladicími informacemi jádra. Celková velikost má po
rozbalení přesáhnout dva gigabajty! (jádro a jeho moduly se stává pěkně
vypaseným bumbrlíčkem :-).</p>

<p>Následuje vlastní instalace a ověřování balíčků:</p>

<pre>
Total                                           7.0 MB/s | 442 MB     01:02
Running transaction check
Transaction check succeeded.
Running transaction test
Transaction test succeeded.
Running transaction
  Installing  : kernel-debuginfo-common-x86_64-4.4.11-200.fc22.x86_64       1/3
  Installing  : kernel-debuginfo-4.4.11-200.fc22.x86_64                     2/3
  Installing  : kernel-devel-4.4.11-200.fc22.x86_64                         3/3
  Verifying   : kernel-devel-4.4.11-200.fc22.x86_64                         1/3
  Verifying   : kernel-debuginfo-4.4.11-200.fc22.x86_64                     2/3
  Verifying   : kernel-debuginfo-common-x86_64-4.4.11-200.fc22.x86_64       3/3
&nbsp;
Installed:
  kernel-debuginfo.x86_64 4.4.11-200.fc22
  kernel-debuginfo-common-x86_64.x86_64 4.4.11-200.fc22
  kernel-devel.x86_64 4.4.11-200.fc22
&nbsp;
Complete!
kernel-devel-4.4.11-200.fc22.x86_64
kernel-debuginfo-4.4.11-200.fc22.x86_64
</pre>

<p>Nyní by již vše mělo být připraveno na použití SystemTapu. Pro jednoduchost
budeme &bdquo;sondy&ldquo; spouštět po rootem resp.&nbsp;pod uživatelem
s&nbsp;efektivními právy roota. Ověřme si, zda SystemTap skutečně pracuje
korektně, a to skriptem převzatým z&nbsp;oficiální dokumentace:</p>

<pre>
<strong>stap -v -e 'probe vfs.read {printf("read performed\n"); exit()}'</strong>
&nbsp;
Pass 1: parsed user script and 118 library scripts using 220380virt/37700res/6832shr/31052data kb, in 170usr/0sys/176real ms.
Pass 2: analyzed script: 1 probe, 1 function, 4 embeds, 0 globals using 377596virt/190588res/8776shr/188268data kb, in 1670usr/130sys/1795real ms.
Pass 3: translated to C into "/tmp/stapZoFUBy/stap_15ce19c7f74e555a3f30d77e16514cf3_1661_src.c" using 377596virt/190840res/9028shr/188268data kb, in 10usr/0sys/5real ms.
Pass 4: compiled C into "stap_15ce19c7f74e555a3f30d77e16514cf3_1661.ko" in 1900usr/450sys/2228real ms.
Pass 5: starting run.
read performed
Pass 5: run completed in 10usr/30sys/336real ms.
</pre>

<p>Přepínač <strong>-v</strong> zapíná &bdquo;ukecaný&ldquo; režim (ony řádky
začínající na &bdquo;Pass&ldquo;) a pomocí přepínače <strong>-e</strong> lze
sondu zapsat přímo na příkazovém řádku.</p>



<p><a name="k03"></a></p>
<h2 id="k03">3. Vytvoření jednoduché sondy aneb pět možností zápisu &bdquo;Hello world!&ldquo;</h2>

<p>Podívejme se nyní, jakým způsobem lze vytvořit velmi jednoduchou sondu,
která vlastně nebude provádět žádné skutečné trasování ani sledování
systémových volání, ale pouze po svém spuštění vypíše na standardní výstup
řetězec &bdquo;Hello world!&ldquo; a následně se korektně ukončí. Jedna
z&nbsp;variant zápisu této sondy vypadá takto:</p>

<pre>
probe begin
{
    printf("Hello world!\n")
    exit()
}
</pre>

<p>Sonda typu <strong>begin</strong> se spustí po inicializaci SystemTapu,
takže právě zde je možné naplnit případné datové struktury, zjistit informace o
trasovaném systému atd. Opakem je podle očekávání sonda typu
<strong>end</strong>.</p>

<p>Zdrojový kód sondy uložíme do souboru nazvaného &bdquo;hello.stp&ldquo; a
následně sondu spustíme:</p>

<pre>
<strong>stap hello.stp</strong>
&nbsp;
hello world
</pre>

<p>Pravděpodobně jste si povšimli, že se zdrojový kód sondy nápadně podobá
deklaraci céčkové funkce, což není náhoda, ale záměr autorů SystemTapu. Céčku
se můžeme ještě více přiblížit použitím středníků, které sice nejsou nutné, ale
například textový editor Vim je při editaci souborů SystemTapu nastaven do
režimu editace céčka, takže bez použití středníků špatně volí odsazení
následujících řádků (středníky je taktéž nutné použít při zápisu většího
množství příkazů na jednom řádku):</p>

<pre>
probe begin
{
    printf("Hello world!\n");
    exit();
}
</pre>

<p>Další úprava může spočívat v&nbsp;náhradě funkce <strong>printf</strong>
(opět známé z&nbsp;céčka) za jednodušší funkci <strong>println</strong>, která
pouze vytiskne svůj parametr a provede odřádkování. Pro program typu
&bdquo;Hello world!&ldquo; je použití funkce <strong>println</strong>
samozřejmě jednodušší:</p>

<pre>
probe begin
{
    println("Hello world!");
    exit();
}
</pre>

<p>Spuštění této sondy stále povede ke stejnému výsledku:</p>

<pre>
<strong>stap hello.stp</strong>
&nbsp;
hello world
</pre>

<p>Již na konci <a href="#k02">předchozí kapitoly</a> jsme si ukázali způsob
zápisu celého popisu sondy přímo na příkazovém řádku. Pro jednodušší sondy může
být tento způsob výhodnější, ovšem nesmíme zde zapomenout na středníky:</p>

<pre>
<strong>stap -e 'probe begin {printf("Hello world!\n");exit();}'</strong>
&nbsp;
Hello world!
</pre>

<p>Poslední způsob zápisu používá speciální sondu typu &bdquo;oneshot&ldquo;,
která se provede pouze jedenkrát a tudíž zde nemusí být uveden příkaz
<strong>exit()</strong>:</p>

<pre>
probe oneshot
{
    println("Hello world!");
}
</pre>

<p>Mezi podobné speciální typy sond patří: <strong>never</strong>,
<strong>end</strong>, <strong>init</strong>, <strong>ioblock</strong> či
<strong>scsi</strong>.</p>

<p>Pro výpis všech typů sond použijte příkaz:</p>

<pre>
<strong>stap --dump-probe-types</strong>
</pre>

<p>(výstup tohoto příkazu neuvádím, protože se liší podle verze SystemTapu)</p>



<p><a name="k04"></a></p>
<h2 id="k04">4. Implicitní a explicitní řízení pořadí spuštění sond</h2>

<p>Náš zdrojový kód s&nbsp;jedinou sondou, která vypíše řetězec &bdquo;Hello
world!&ldquo; a následně se ukončí, můžeme rozšířit a ukázat si další vlastnost
SystemTapu. Sond typu <strong>begin</strong> je totiž možné deklarovat
libovolné množství, takže si celý výpis a ukončení uměle rozdělíme na čtyři
části (povšimněte si, že namísto příkazu <strong>println</strong> používáme
v&nbsp;prvních dvou sondách příkaz <strong>print</strong>, který neprovádí
odřádkování):</p>

<pre>
probe begin
{
    print("Hello");
}
&nbsp;
probe begin
{
    print(" world");
}
&nbsp;
probe begin
{
    println(" !");
}
&nbsp;
probe begin
{
    exit();
}
</pre>

<p>Díky tomuto rozdělení je například možné u složitějších skriptů inicializaci
provádět podle funkčních celků. Dokonce ani není nutné dodržet přesné pořadí
sond ve zdrojovém kódu, protože u každé sondy lze zapsat celé číslo (i
záporné), kterým se pořadí definuje explicitně. Pokusme se nyní sondy ve
zdrojovém textu prohodit a uvidíme, že po spuštění se stejně budou spouštět
takovým způsobem, aby jejich indexy tvořily rostoucí řadu (resp.&nbsp;přesněji
řečeno neklesající řadu, protože je možné pro více sond použít stejná čísla
&ndash; potom záleží na pořadí jejich zápisu ve zdrojovém textu):</p>

<pre>
probe begin(3)
{
    println(" !");
}
&nbsp;
probe begin(100)
{
    exit();
}
&nbsp;
probe begin(2)
{
    print(" world");
}
&nbsp;
probe begin(1)
{
    print("Hello");
}
</pre>



<p><a name="k05"></a></p>
<h2 id="k05">5. Sondy zavolané při spuštění nebo ukončení programu</h2>

<p>Sondu typu <strong>begin</strong> a nepřímo taktéž sondu typu
<strong>end</strong> jsme si již ukázali v&nbsp;předchozích dvou kapitolách.
V&nbsp;praxi se velmi často používá poněkud odlišný typ sondy nazvaný
<strong>process(jméno_procesu).begin</strong> a
<strong>process(jméno_procesu).end</strong>. Tyto sondy se spustí ve chvíli,
kdy je detekováno spuštění či naopak ukončení procesu se zadaným jménem (jméno
může být zadáno bez cesty či explicitně s&nbsp;cestou). Podívejme se na
jednoduchý příklad detekce spuštění a zastavení příkazu
<strong>ls</strong>:</p>

<pre>
probe process("ls").begin
{
    println("ls started");
}
&nbsp;
probe process("ls").end
{
    println("ls finished");
}
</pre>

<p>Pokud tento skript spustíme (opět příkazem <strong>stap</strong>) a
v&nbsp;jiném terminálu napíšeme <strong>ls</strong>, vypíše SystemTap (na
prvním terminálu) následující zprávy:</p>

<pre>
ls started
ls finished
</pre>

<p>Předchozí skript si ještě rozšíříme o možnost výpisu PID (<i>process ID</i>)
právě spuštěného procesu <strong>ls</strong> (přesněji řečeno procesu
vytvořenému z&nbsp;programu <strong>ls</strong>). Pro tento účel použijeme
funkci <a
href="https://access.redhat.com/documentation/en-US/Red_Hat_Enterprise_Linux/7/html/SystemTap_Tapset_Reference/API-pid.html">pid()</a>,
která číslo procesu vrací. Povšimněte si, že funkci <strong>printf</strong>
používáme skutečně podobným způsobem, jako v&nbsp;céčku (použití %d pro
dekadické celé číslo atd.):</p>

<pre>
probe begin
{
    println("STAP prepared");
}
&nbsp;
probe process("ls").begin
{
    printf("ls with PID=%d started\n", pid());
}
&nbsp;
probe process("ls").end
{
    printf("ls with PID=%d finished\n", pid());
}
</pre>

<p>Po spuštění sondy a příkazu <strong>ls</strong> v&nbsp;jiném terminálu
dostaneme tento výsledek (číslo procesu se bude pochopitelně lišit):</p>

<pre>
STAP prepared
ls with PID=20330 started
ls with PID=20330 finished
</pre>

<p>Poznámka: v&nbsp;případě potřeby je možné namísto sond typu
<strong>process(jméno_procesu).begin</strong> a
<strong>process(jméno_procesu).end</strong> použít sondy
<strong>process(PID_procesu).begin</strong> a
<strong>process(PID_procesu).end</strong>.</p>



<p><a name="k06"></a></p>
<h2 id="k06">6. Detekce systémových volání (syscallů)</h2>

<p>Poměrně zajímavé je použití <i>SystemTapu</i> pro sledování volání služeb
jádra (syscallů). Seznam všech syscallů lze najít na adrese <a
href="https://sourceware.org/systemtap/tapsets/syscalls.html">https://sourceware.org/systemtap/tapsets/syscalls.html</a>.
Alternativně je možné použít i příkaz, který vypíše aliasy (zkrácené názvy)
syscallů podporovaných aktuálně nainstalovanou verzí <i>SystemTapu</i>:</p>

<pre>
stap --dump-probe-aliases |grep ^syscall
</pre>

<p>Podívejme se nyní na způsob použití těchto typů sond. Vytvoříme čtyři sondy
zavolané po inicializaci SystemTapu, po spuštění procesu <strong>ls</strong>,
po ukončení tohoto procesu a taktéž při zavolání systémové funkce
<strong>open</strong> (známé spíše pod jménem <strong>sys_open</strong>). U
poslední sondy si povšimněte, že máme přístup ke speciální proměnné
<strong>$filename</strong>, která je (pouze v&nbsp;kontextu této sondy!)
naplněna jménem otevíraného souboru. U jiných typů sond budou přístupné odlišné
speciální proměnné &ndash; opět viz <a
href="https://sourceware.org/systemtap/tapsets/syscalls.html">https://sourceware.org/systemtap/tapsets/syscalls.html</a>):</p>

<pre>
probe begin
{
    println("STAP prepared");
}
&nbsp;
probe process("ls").begin
{
    printf("ls with PID=%d started\n", pid());
}
&nbsp;
probe process("ls").end
{
    printf("ls with PID=%d finished\n", pid());
}
&nbsp;
probe syscall.open
{
    filename = user_string($filename);
    printf("ls opened file %s\n", filename);
}
</pre>

<p>Po spuštění této sondy můžeme vidět zajímavý výsledek, z&nbsp;něhož je
patrné, že v&nbsp;systému běží nějaký další proces nazvaný
<strong>ls</strong>:</p>

<pre>
STAP prepared
ls opened file /proc/1286/cgroup
ls opened file /proc/loadavg
ls opened file /sys/fs/cgroup/systemd/system.slice/systemd-udevd.service/cgroup.procs
ls with PID=22086 started
ls opened file /etc/ld.so.cache
ls opened file /lib64/libselinux.so.1
ls opened file /lib64/libcap.so.2
ls opened file /lib64/libacl.so.1
ls opened file /lib64/libc.so.6
ls opened file /lib64/libpcre.so.1
ls opened file /lib64/libdl.so.2
ls opened file /lib64/libattr.so.1
ls opened file /lib64/libpthread.so.0
ls opened file /usr/lib/locale/locale-archive
ls with PID=22086 finished
ls opened file /proc/loadavg
ls opened file /proc/loadavg
ls opened file /proc/1089/cgroup
ls opened file /proc/loadavg
</pre>



<p><a name="k07"></a></p>
<h2 id="k07">7. Vylepšení předchozího programu &ndash; detekce správného čísla procesu</h2>

<p>Aby byl náš skript určený pro sledování chování příkazu <strong>ls</strong>
užitečnější, můžeme do něj přidat jednoduché (ve skutečnosti velmi primitivní)
filtrování. To bude fungovat následujícím způsobem &ndash; v&nbsp;sondě typu
<strong>process(jméno_procesu).begin</strong> si zapamatujeme PID právě
spuštěného příkazu <strong>ls</strong> a toto PID použijeme jako filtr
v&nbsp;sondě typu <strong>syscall.open</strong>. V&nbsp;tomto skriptu můžeme
vidět hned dvě nové vlastnosti skriptů psaných pro SystemTap. První vlastností
jsou globální proměnné vytvářené deklarací <strong>global
jméno_proměnné</strong> a druhou vlastností rozhodovací konstrukce
<strong>if-then-(else)</strong>, jejíž syntaxe a sémantika je prakticky
kompletně převzatá z&nbsp;programovacího jazyka C:</p>

<pre>
global pid=-1
&nbsp;
probe begin
{
    println("STAP prepared");
}
&nbsp;
probe process("ls").begin
{
    pid=pid()
    printf("ls with PID=%d started\n", pid());
}
&nbsp;
probe process("ls").end
{
    printf("ls with PID=%d finished\n", pid());
}
&nbsp;
probe syscall.open
{
    filename = user_string($filename);
    if (pid==pid()) {
        printf("ls opened file %s\n", filename);
    }
}
</pre>

<p>Zprávy vypisované touto sondou již budou obsahovat jen relevantní informace,
nikoli informace z&nbsp;již běžícího procesu <strong>ls</strong>:</p>

<pre>
ls with PID=22060 started
ls opened file /etc/ld.so.cache
ls opened file /lib64/libselinux.so.1
ls opened file /lib64/libcap.so.2
ls opened file /lib64/libacl.so.1
ls opened file /lib64/libc.so.6
ls opened file /lib64/libpcre.so.1
ls opened file /lib64/libdl.so.2
ls opened file /lib64/libattr.so.1
ls opened file /lib64/libpthread.so.0
ls opened file /usr/lib/locale/locale-archive
ls with PID=22060 finished
</pre>

<p>Chování sondy si můžeme zkontrolovat přes <a
href="http://www.root.cz/clanky/trasovani-a-ladeni-nativnich-aplikaci-v-linuxu/#k06">již
popsanou utilitu</a> <strong>strace</strong>:</p>

<pre>
<strong>strace -e trace=open ls</strong>
&nbsp;
open("/etc/ld.so.cache", O_RDONLY|O_CLOEXEC) = 3
open("/lib64/libselinux.so.1", O_RDONLY|O_CLOEXEC) = 3
open("/lib64/libcap.so.2", O_RDONLY|O_CLOEXEC) = 3
open("/lib64/libacl.so.1", O_RDONLY|O_CLOEXEC) = 3
open("/lib64/libc.so.6", O_RDONLY|O_CLOEXEC) = 3
open("/lib64/libpcre.so.1", O_RDONLY|O_CLOEXEC) = 3
open("/lib64/libdl.so.2", O_RDONLY|O_CLOEXEC) = 3
open("/lib64/libattr.so.1", O_RDONLY|O_CLOEXEC) = 3
open("/lib64/libpthread.so.0", O_RDONLY|O_CLOEXEC) = 3
open("/usr/lib/locale/locale-archive", O_RDONLY|O_CLOEXEC) = 3
</pre>

<p>Sondu tedy evidentně nemáme napsanou úplně špatně...</p>



<p><a name="k08"></a></p>
<h2 id="k08">8. Výpis základních informací o syscallu (volané služby jádra)</h2>

<p>Podívejme se na další příklad, který sleduje volání dvou služeb jádra. Kromě
nám již známé služby <strong>open</strong> (<strong>sys_open</strong>) se nyní
sleduje i služba <strong>write</strong> (<strong>sys_write</strong>). U služby
<strong>write</strong> se naplňují následující speciální proměnné: buf, count,
fd. První proměnná obsahuje adresu zapisovaného bufferu (viz též <a
href="#k09">navazující kapitolu</a>), druhá proměnná počet zapisovaných bajtů a
třetí proměnná file deskriptor. Právě počet zapisovaných bajtů a file
deskriptor budeme sledovat:</p>

<pre>
global pid=-1
&nbsp;
probe begin
{
    println("STAP prepared");
}
&nbsp;
probe process("ls").begin
{
    pid=pid()
    printf("ls with PID=%d started\n", pid());
}
&nbsp;
probe process("ls").end
{
    printf("ls with PID=%d finished\n", pid());
}
&nbsp;
probe syscall.open
{
    filename = user_string($filename);
    if (pid==pid()) {
        printf("ls opened file %s\n", filename);
    }
}
&nbsp;
probe syscall.write
{
    bytes=$count
    into=$fd
    if (pid==pid()) {
        printf("write %d bytes to file descriptor %d\n", bytes, into);
    }
}
</pre>

<p>Podívejme se, co se stane při spuštění sondy a příkazu <strong>ls</strong>
v&nbsp;jiném terminálu:</p>

<pre>
STAP prepared
ls with PID=23120 started
ls opened file /etc/ld.so.cache
ls opened file /lib64/libselinux.so.1
ls opened file /lib64/libcap.so.2
ls opened file /lib64/libacl.so.1
ls opened file /lib64/libc.so.6
ls opened file /lib64/libpcre.so.1
ls opened file /lib64/libdl.so.2
ls opened file /lib64/libattr.so.1
ls opened file /lib64/libpthread.so.0
ls opened file /usr/lib/locale/locale-archive
write 67 bytes to file descriptor 1
write 55 bytes to file descriptor 1
ls with PID=23120 finished
</pre>

<p>Výsledek je zajímavý a vlastně i predikovatelný &ndash; zapisují se data do
file deskriptoru číslo 1, což je standardní výstup. Pokud uděláme při spuštění
příkazu <strong>ls</strong> chybu (ls -5432 atd.), vypíše se hlášení namísto
toho do chybového výstupu:</p>

<pre>
ls with PID=7339 started
write 26 bytes to file descriptor 2
write 38 bytes to file descriptor 2
ls with PID=7339 finished
</pre>

<p>Poznámka: jedná se o následující dvě zprávy:</p>

<pre>
ls: invalid option -- '5'
Try 'ls --help' for more information.
</pre>

<p>(povšimněte si přesné délky 25 resp. 37 znaků + znaku pro odřádkování)</p>



<p><a name="k09"></a></p>
<h2 id="k09">9. Přístup k&nbsp;bufferu použitém v&nbsp;syscallu write</h2>

<p>Pokusme se nyní skript se sondou upravit takovým způsobem, aby sonda získala
a následně vypsala řetězec, který (paralelně) vypisuje příkaz
<strong>ls</strong>. První verze bude implementována poněkud naivně &ndash;
použijeme funkci <a
href="https://access.redhat.com/documentation/en-US/Red_Hat_Enterprise_Linux/7/html/SystemTap_Tapset_Reference/API-user-string.html">user_string</a>
pro přečtení řetězce z&nbsp;adresového prostoru sledovaného procesu a následně
tento řetězec bez dalších úprav vytiskneme funkcí <strong>println</strong>:</p>

<pre>
global pid=-1
&nbsp;
probe begin
{
    println("STAP prepared");
}
&nbsp;
probe process("ls").begin
{
    pid=pid()
    printf("ls with PID=%d started\n", pid());
}
&nbsp;
probe process("ls").end
{
    printf("ls with PID=%d finished\n", pid());
}
&nbsp;
probe syscall.open
{
    filename = user_string($filename);
    if (pid==pid()) {
        printf("ls opened file %s\n", filename);
    }
}
&nbsp;
probe syscall.write
{
    bytes = $count;
    into  = $fd;
    msg   = user_string($buf);
    if (pid==pid()) {
        printf("write %d bytes to file descriptor %d\n", bytes, into);
        println(msg);
    }
}
</pre>

<p>Zdrojový text sondy sice zdánlivě vypadá v&nbsp;pořádku, ale podívejme se,
co se stane při sledování příkazu <strong>ls -l</strong>:</p>

<pre>
write 9 bytes to file descriptor 1
total 40
&nbsp;
ls opened file /etc/localtime
write 62 bytes to file descriptor 1
-rw-------. 1 root root 14791  7. čen 15.02 anaconda-ks.cfg
&nbsp;
write 63 bytes to file descriptor 1
-rw-r--r--. 1 root root    48  7. čen 15.38 hello_world2.stp
&nbsp;
write 63 bytes to file descriptor 1
-rw-r--r--. 1 root root   140  7. čen 15.47 hello_world3.stp
&nbsp;
write 62 bytes to file descriptor 1
-rw-r--r--. 1 root root    58  7. čen 15.38 hello_world.stp
&nbsp;
<strong>&nbsp;(prázdný řádek)</strong>
write 53 bytes to file descriptor 1
-rw-r--r--. 1 root root   585  7. čen 16.54 ls.stp
<strong>orld.stp</strong>
&nbsp;
&nbsp;
write 65 bytes to file descriptor 1
-rw-r--r--. 1 root root     4  7. čen 15.00 NETBOOT_METHOD.TXT
&nbsp;
write 57 bytes to file descriptor 1
-rw-r--r--. 1 root root     8  7. čen 15.00 RECIPE.TXT
<strong>HOD.TXT</strong>
&nbsp;
ls with PID=47910 finished
</pre>

<p>Ve výpisu by se teoreticky měly střídat řádky s&nbsp;informacemi o počtu
zapisovaných bajtů a file deskriptoru s&nbsp;řádkem obsahujícím zprávu, kterou
produkuje příkaz <strong>ls -l</strong>. Ve skutečnosti však vidíme, že tomu
tak není, protože získáme i nějaké další fragmenty textu, které mohou být dosti
dlouhé (a obecně náhodné). Proč tomu tak je?</p>



<p><a name="k10"></a></p>
<h2 id="k10">10. Opravení předchozího příkladu: výpočet skutečné délky řetězce před jeho výpisem</h2>

<p>Problém spočívá v&nbsp;tom, že sice získáme ukazatel na buffer, který
následně převedeme na řetězec, ovšem nikde není řečeno, že tento buffer za
všech okolností končí za posledním znakem nulou, která v&nbsp;céčku ukončuje
běžné řetězce. Takto totiž systémová funkce <strong>write</strong> není
navržena, a to z&nbsp;toho prostého důvodu, že musí pracovat i s&nbsp;binárními
soubory, v&nbsp;nichž se znak s&nbsp;kódem nula běžně vyskytuje. Při volání
této funkce se předává adresa bufferu a jeho délka, přičemž obsah není žádným
způsobem interpretován. To vlastně znamená, že předchozí sonda mohla vypisovat
i velmi dlouhé řetězce, a to tehdy, pokud by se v&nbsp;datech ZA bufferem
dlouho nenacházela žádná nula. Jak tento problém vyřešit? Nemůžeme použít
funkci <strong>user_string</strong> a následně řetězec na správném místě
odříznout, protože teoreticky může dojít k&nbsp;chybě při přístupu na adresu
nepatřící procesu. Namísto toho je nutné použít alternativní funkci nazvanou <a
href="https://access.redhat.com/documentation/en-US/Red_Hat_Enterprise_Linux/7/html/SystemTap_Tapset_Reference/API-user-string-n.html">user_string_n</a>:</p>

<pre>
function user_string_n:string(addr:long,n:long)
</pre>

<p>Upravený zdrojový text sondy vypadá takto:</p>

<pre>
global pid=-1
&nbsp;
probe begin
{
    println("STAP prepared");
}
&nbsp;
probe process("ls").begin
{
    pid=pid()
    printf("ls with PID=%d started\n", pid());
}
&nbsp;
probe process("ls").end
{
    printf("ls with PID=%d finished\n", pid());
}
&nbsp;
probe syscall.open
{
    filename = user_string($filename);
    if (pid==pid()) {
        printf("ls opened file %s\n", filename);
    }
}
&nbsp;
probe syscall.write
{
    bytes = $count;
    into  = $fd;
    msg   = <strong>user_string_n($buf, bytes);</strong>
    if (pid==pid()) {
        printf("write %d bytes to file descriptor %d\n", bytes, into);
        println(msg);
    }
}
</pre>

<p>Nyní již vypisované zprávy pro <strong>ls -l</strong> budou korektní:</p>

<pre>
write 9 bytes to file descriptor 1
total 40
&nbsp;
ls opened file /etc/localtime
write 62 bytes to file descriptor 1
-rw-------. 1 root root 14791  7. čen 15.02 anaconda-ks.cfg
&nbsp;
write 63 bytes to file descriptor 1
-rw-r--r--. 1 root root    48  7. čen 15.38 hello_world2.stp
&nbsp;
write 63 bytes to file descriptor 1
-rw-r--r--. 1 root root   140  7. čen 15.47 hello_world3.stp
&nbsp;
write 62 bytes to file descriptor 1
-rw-r--r--. 1 root root    58  7. čen 15.38 hello_world.stp
&nbsp;
write 53 bytes to file descriptor 1
-rw-r--r--. 1 root root   594  7. čen 16.58 ls.stp
&nbsp;
write 65 bytes to file descriptor 1
-rw-r--r--. 1 root root     4  7. čen 15.00 NETBOOT_METHOD.TXT
&nbsp;
write 57 bytes to file descriptor 1
-rw-r--r--. 1 root root     8  7. čen 15.00 RECIPE.TXT
&nbsp;
ls with PID=47931 finished
</pre>



<p><a name="k11"></a></p>
<h2 id="k11">11. Specifikace jména sledovaného programu z&nbsp;příkazové řádky</h2>

<p>Náš skript se sondami má jednu vadu &ndash; je určen pouze pro sledování
procesu pojmenovaného <strong>ls</strong>, což není příliš univerzální.
<i>SystemTap</i> nám ovšem i v&nbsp;této chvíli nabízí řešení, a to formou <a
href="https://access.redhat.com/documentation/en-US/Red_Hat_Enterprise_Linux/7/html/SystemTap_Beginners_Guide/scriptconstructions.html#commandlineargssect">speciálních
proměnných @číslo</a>. Tyto proměnné jsou naplněny parametry předanými na
příkazovém řádku, přičemž první parametr bude mít jméno @1, druhý parametr
jméno @2 atd. Zavináče jsou použity pro řetězce, pokud je však nějaký parametr
celočíselný, používají se jména $číslo ($1, $2, ...). To může být trošku
matoucí, zejména pro programátory používající shell, takže si na rozdíl mezi $1
a @1 budeme muset dávat pozor. Univerzální skript se sondami, který je
použitelný pro jakýkoli proces, vypadá následovně:</p>

<pre>
global pid=-1
&nbsp;
probe begin
{
    println("STAP prepared");
}
&nbsp;
probe process(@1).begin
{
    pid=pid()
    printf("ls with PID=%d started\n", pid());
}
&nbsp;
probe process(@1).end
{
    printf("ls with PID=%d finished\n", pid());
}
&nbsp;
probe syscall.open
{
    filename = user_string($filename);
    if (pid==pid()) {
        printf("ls opened file %s\n", filename);
    }
}
&nbsp;
probe syscall.write
{
    bytes = $count;
    into  = $fd;
    msg   = user_string_n($buf, bytes);
    if (pid==pid()) {
        printf("write %d bytes to file descriptor %d\n", bytes, into);
        println(msg);
    }
}
</pre>

<p>Takto vytvořený skript použijeme pro sledování příkazu
<strong>whoami</strong>:</p>

<pre>
stap check.stp whoami
</pre>

<pre>
STAP prepared
ls with PID=49026 started
ls opened file /etc/ld.so.cache
ls opened file /lib64/libc.so.6
ls opened file /usr/lib/locale/locale-archive
ls opened file /etc/nsswitch.conf
ls opened file /etc/ld.so.cache
ls opened file /lib64/libnss_files.so.2
ls opened file /etc/passwd
write 5 bytes to file descriptor 1
root
&nbsp;
ls with PID=49026 finished
</pre>

<p>Poznámka: pozor musíte dát pouze na příkazy zabudované přímo do shellu. Ty
pochopitelně nebudou rozeznány, neboť se pro ně nespouští další proces. To
znamená, že všechny příkazy, které najdete v&nbsp;<strong>man builtins</strong>
nelze takto jednoduše sledovat (ovšem i zde řešení existuje).</p>



<p><a name="k12"></a></p>
<h2 id="k12">12. Výpis volaných funkcí</h2>

<p>Nyní se podívejme na poněkud odlišnou sondu. Bude se jednat o sondu volanou
ve chvíli, kdy sledovaný proces (zde opět <strong>ls</strong>) volá libovolnou
funkci. Znak * zde představuje &bdquo;žolíkový znak&ldquo;, podobně jako
v&nbsp;shellu. Jméno volané funkce se zjistí pomocí
<strong>ppfunc</strong>:</p>

<pre>
global pid=-1
&nbsp;
probe begin
{
    println("STAP prepared");
}
&nbsp;
probe process(@1).begin
{
    pid=pid()
    printf("ls with PID=%d started\n", pid());
}
&nbsp;
probe process(@1).end
{
    printf("ls with PID=%d finished\n", pid());
}
&nbsp;
probe process("ls").function("*").call
{
    println(ppfunc());
}
</pre>

<p>Výsledek běhu SystemTapu jsem musel zkrátit, protože i pro jednoduché
<strong>ls</strong> se volá několik set funkcí (zaujala mě především funkce
nazvaná <strong>get_funky_string</strong>, asi nastal správný okamžik projít
zdrojovými kódy základních příkazů shellu):</p>

<pre>
ls with PID=4269 started
_start
__libc_csu_init
_init
frame_dummy
register_tm_clones
main
set_program_name
atexit
__xargmatch_internal
argmatch
human_options
clone_quoting_options
xmemdup
xmalloc
get_quoting_style
clone_quoting_options
xmemdup
xmalloc
set_char_quoting
xstrdup
xmemdup
xmalloc
get_funky_string
...
...
...
close_stdout
close_stream
rpl_fclose
rpl_fflush
close_stream
rpl_fclose
rpl_fflush
__do_global_dtors_aux
deregister_tm_clones
_fini
ls with PID=4269 finished
</pre>



<p><a name="k13"></a></p>
<h2 id="k13">13. Zjištění, odkud se funkce volá (backtrace)</h2>

<p>Předchozí sondu lze rozšířit. Předpokládejme, že program <strong>ls</strong>
má problém při alokaci paměti funkcí <strong>xalloc</strong>. Budeme tedy
sledovat pouze volání této funkce a současně u každého volání vypíšeme
backtrace (ten již známe z&nbsp;popisu GNU Debuggeru). Pro tento výpis
použijeme funkci nazvanou <a
href="https://access.redhat.com/documentation/en-US/Red_Hat_Enterprise_Linux/7/html/SystemTap_Tapset_Reference/API-print-ubacktrace.html">print_ubacktrace</a>:</p>

<pre>
global pid=-1
&nbsp;
probe begin
{
    println("STAP prepared");
}
&nbsp;
probe process(@1).begin
{
    pid=pid()
    printf("ls with PID=%d started\n", pid());
}
&nbsp;
probe process(@1).end
{
    printf("ls with PID=%d finished\n", pid());
}
&nbsp;
probe process("ls").function("xmalloc").call
{
    println(ppfunc());
    print_ubacktrace();
}
</pre>

<p>Výsledek bude vypadat takto:</p>

<pre>
xmalloc
 0x4112f0 : xmalloc+0x0/0x20 [/usr/bin/ls]
 0x4051c8 : sort_files+0x148/0x190 [/usr/bin/ls]
 0x403c72 : main+0x12e2/0x2160 [/usr/bin/ls]
 0x7f51b4e71700 [/usr/lib64/libc-2.21.so+0x20700/0x3c1000]
xmalloc
 0x4112f0 : xmalloc+0x0/0x20 [/usr/bin/ls]
 0x4060fc : calculate_columns+0xcc/0x2d0 [/usr/bin/ls]
 0x407abe : print_current_files+0x33e/0x4e0 [/usr/bin/ls]
 0x403d73 : main+0x13e3/0x2160 [/usr/bin/ls]
 0x7f51b4e71700 [/usr/lib64/libc-2.21.so+0x20700/0x3c1000]
ls with PID=5278 finished
</pre>

<p>V&nbsp;případě potřeby je možné před zavoláním funkce
<strong>xalloc</strong> získat předávané parametry i návratovou hodnotu.</p>

<p>Příště si ukážeme další typy sond, zejména sondy určené pro sledování práce
se souborovým systémem a síťovým subsystémem.</p>



<p><a name="k14"></a></p>
<h2 id="k14">14. Odkazy na Internetu</h2>

<ol>

<li>SystemTap Reference: Context Functions<br />
<a href="https://access.redhat.com/documentation/en-US/Red_Hat_Enterprise_Linux/6/html/SystemTap_Tapset_Reference/context_stp.html">https://access.redhat.com/documentation/en-US/Red_Hat_Enterprise_Linux/6/html/SystemTap_Tapset_Reference/context_stp.html</a>
</li>

<li>SystemTap Beginners Guide (RHEL 6)<br />
<a href="https://access.redhat.com/documentation/en-US/Red_Hat_Enterprise_Linux/6/html/SystemTap_Beginners_Guide/index.html">https://access.redhat.com/documentation/en-US/Red_Hat_Enterprise_Linux/6/html/SystemTap_Beginners_Guide/index.html</a>
</li>

<li>SystemTap Tapset Reference (RHEL 6)<br />
<a href="https://access.redhat.com/documentation/en-US/Red_Hat_Enterprise_Linux/6/html-single/SystemTap_Tapset_Reference/index.html">https://access.redhat.com/documentation/en-US/Red_Hat_Enterprise_Linux/6/html-single/SystemTap_Tapset_Reference/index.html</a>
</li>

<li>SystemTap Beginners Guide (RHEL 7)<br />
<a href="https://access.redhat.com/documentation/en-US/Red_Hat_Enterprise_Linux/7/html/SystemTap_Beginners_Guide/index.html">https://access.redhat.com/documentation/en-US/Red_Hat_Enterprise_Linux/7/html/SystemTap_Beginners_Guide/index.html</a>
</li>

<li>SystemTap Tapset Reference (RHEL 6)<br />
<a href="https://access.redhat.com/documentation/en-US/Red_Hat_Enterprise_Linux/7/html/SystemTap_Tapset_Reference/index.html">https://access.redhat.com/documentation/en-US/Red_Hat_Enterprise_Linux/7/html/SystemTap_Tapset_Reference/index.html</a>
</li>

<li>Debuggery a jejich nadstavby v Linuxu<br />
<a href="http://mojefedora.cz/debuggery-a-jejich-nadstavby-v-linuxu/">http://mojefedora.cz/debuggery-a-jejich-nadstavby-v-linuxu/</a>
</li>

<li>Debuggery a jejich nadstavby v Linuxu (2. část)<br />
<a href="http://mojefedora.cz/debuggery-a-jejich-nadstavby-v-linuxu-2-cast/">http://mojefedora.cz/debuggery-a-jejich-nadstavby-v-linuxu-2-cast/</a>
</li>

<li>Debuggery a jejich nadstavby v Linuxu (3): Nemiver<br />
<a href="http://mojefedora.cz/debuggery-a-jejich-nadstavby-v-linuxu-3-nemiver/">http://mojefedora.cz/debuggery-a-jejich-nadstavby-v-linuxu-3-nemiver/</a>
</li>

<li>Debuggery a jejich nadstavby v Linuxu (4): KDbg<br />
<a href="http://mojefedora.cz/debuggery-a-jejich-nadstavby-v-linuxu-4-kdbg/">http://mojefedora.cz/debuggery-a-jejich-nadstavby-v-linuxu-4-kdbg/</a>
</li>

<li>Debuggery a jejich nadstavby v Linuxu (5): ladění aplikací v&nbsp;editorech Emacs a Vim<br />
<a href="http://mojefedora.cz/debuggery-a-jejich-nadstavby-v-linuxu-5-ladeni-aplikaci-v-editorech-emacs-a-vim/">http://mojefedora.cz/debuggery-a-jejich-nadstavby-v-linuxu-5-ladeni-aplikaci-v-editorech-emacs-a-vim/</a>
</li>

<li>Tracing (software)<br />
<a href="https://en.wikipedia.org/wiki/Tracing_%28software%29">https://en.wikipedia.org/wiki/Tracing_%28software%29</a>
</li>

<li>ltrace(1) - Linux man page<br />
<a href="http://linux.die.net/man/1/ltrace">http://linux.die.net/man/1/ltrace</a>
</li>

<li>ltrace (Wikipedia)<br />
<a href="https://en.wikipedia.org/wiki/Ltrace">https://en.wikipedia.org/wiki/Ltrace</a>
</li>

<li>strace(1) - Linux man page<br />
<a href="http://linux.die.net/man/1/strace">http://linux.die.net/man/1/strace</a>
</li>

<li>strace (stránka projektu na SourceForge)<br />
<a href="https://sourceforge.net/projects/strace/">https://sourceforge.net/projects/strace/</a>
</li>

<li>strace (Wikipedia)<br />
<a href="https://en.wikipedia.org/wiki/Strace">https://en.wikipedia.org/wiki/Strace</a>
</li>

<li>SystemTap (stránka projektu)<br />
<a href="https://sourceware.org/systemtap/">https://sourceware.org/systemtap/</a>
</li>

<li>SystemTap (Wiki projektu)<br />
<a href="https://sourceware.org/systemtap/wiki">https://sourceware.org/systemtap/wiki</a>
</li>

<li>SystemTap (Wikipedia)<br />
<a href="https://en.wikipedia.org/wiki/SystemTap">https://en.wikipedia.org/wiki/SystemTap</a>
</li>

<li>Dynamic Tracing with DTrace &amp; SystemTap<br />
<a href="http://myaut.github.io/dtrace-stap-book/">http://myaut.github.io/dtrace-stap-book/</a>
</li>

<li>DTrace (Wikipedia)<br />
<a href="https://en.wikipedia.org/wiki/DTrace">https://en.wikipedia.org/wiki/DTrace</a>
</li>

<li>GDB - Dokumentace<br />
<a href="http://sourceware.org/gdb/current/onlinedocs/gdb/">http://sourceware.org/gdb/current/onlinedocs/gdb/</a>
</li>

<li>GDB - Supported Languages<br />
<a href="http://sourceware.org/gdb/current/onlinedocs/gdb/Supported-Languages.html#Supported-Languages">http://sourceware.org/gdb/current/onlinedocs/gdb/Supported-Languages.html#Supported-Languages</a>
</li>

<li>GNU Debugger (Wikipedia)<br />
<a href="https://en.wikipedia.org/wiki/GNU_Debugger">https://en.wikipedia.org/wiki/GNU_Debugger</a>
</li>

<li>The LLDB Debugger<br />
<a href="http://lldb.llvm.org/">http://lldb.llvm.org/</a>
</li>

<li>Debugger (Wikipedia)<br />
<a href="https://en.wikipedia.org/wiki/Debugger">https://en.wikipedia.org/wiki/Debugger</a>
</li>

<li>13 Linux Debuggers for C++ Reviewed<br />
<a href="http://www.drdobbs.com/testing/13-linux-debuggers-for-c-reviewed/240156817">http://www.drdobbs.com/testing/13-linux-debuggers-for-c-reviewed/240156817</a>
</li>

<li>Getting started with ltrace: how does it do that?<br />
<a href="https://www.ellexus.com/getting-started-with-ltrace-how-does-it-do-that/">https://www.ellexus.com/getting-started-with-ltrace-how-does-it-do-that/</a>
</li>

<li>Reverse Engineering Tools in Linux – strings, nm, ltrace, strace, LD_PRELOAD<br />
<a href="http://www.thegeekstuff.com/2012/03/reverse-engineering-tools/">http://www.thegeekstuff.com/2012/03/reverse-engineering-tools/</a>
</li>

<li>7 Strace Examples to Debug the Execution of a Program in Linux<br />
<a href="http://www.thegeekstuff.com/2011/11/strace-examples/">http://www.thegeekstuff.com/2011/11/strace-examples/</a>
</li>

<li>Oracle® Solaris 11.3 DTrace (Dynamic Tracing) Guide<br />
<a href="http://docs.oracle.com/cd/E53394_01/html/E53395/gkwpo.html#scrolltoc">http://docs.oracle.com/cd/E53394_01/html/E53395/gkwpo.html#scrolltoc</a>
</li>

<li>An Introduction To Using GDB Under Emacs<br />
<a href="http://tedlab.mit.edu/~dr/gdbintro.html">http://tedlab.mit.edu/~dr/gdbintro.html</a>
</li>

<li>GNU Emacs<br />
<a href="https://www.gnu.org/software/emacs/emacs.html">https://www.gnu.org/software/emacs/emacs.html</a>
</li>

<li>The Emacs Editor<br />
<a href="https://www.gnu.org/software/emacs/manual/html_node/emacs/index.html">https://www.gnu.org/software/emacs/manual/html_node/emacs/index.html</a>
</li>

<li>Emacs Lisp<br />
<a href="https://www.gnu.org/software/emacs/manual/html_node/elisp/index.html">https://www.gnu.org/software/emacs/manual/html_node/elisp/index.html</a>
</li>

<li>An Introduction to Programming in Emacs Lisp<br />
<a href="https://www.gnu.org/software/emacs/manual/html_node/eintr/index.html">https://www.gnu.org/software/emacs/manual/html_node/eintr/index.html</a>
</li>

<li>27.6 Running Debuggers Under Emacs<br />
<a href="https://www.gnu.org/software/emacs/manual/html_node/emacs/Debuggers.html">https://www.gnu.org/software/emacs/manual/html_node/emacs/Debuggers.html</a>
</li>

<li>GdbMode<br />
<a href="http://www.emacswiki.org/emacs/GdbMode">http://www.emacswiki.org/emacs/GdbMode</a>
</li>

<li>Emacs (Wikipedia)<br />
<a href="https://en.wikipedia.org/wiki/Emacs">https://en.wikipedia.org/wiki/Emacs</a>
</li>

<li>Emacs Lisp (Wikipedia)<br />
<a href="https://en.wikipedia.org/wiki/Emacs_Lisp">https://en.wikipedia.org/wiki/Emacs_Lisp</a>
</li>

<li>Pyclewn installation notes<br />
<a href="http://pyclewn.sourceforge.net/install.html">http://pyclewn.sourceforge.net/install.html</a>
</li>

<li>pip Installation<br />
<a href="https://pip.pypa.io/en/latest/installing.html">https://pip.pypa.io/en/latest/installing.html</a>
</li>

<li>Clewn<br />
<a href="http://clewn.sourceforge.net/">http://clewn.sourceforge.net/</a>
</li>

<li>Clewn installation<br />
<a href="http://clewn.sourceforge.net/install.html">http://clewn.sourceforge.net/install.html</a>
</li>

<li>Clewn - soubory<br />
<a href="http://sourceforge.net/projects/clewn/files/OldFiles/">http://sourceforge.net/projects/clewn/files/OldFiles/</a>
</li>

<li>KDbg: úvodní stránka<br />
<a href="http://www.kdbg.org/">http://www.kdbg.org/</a>
</li>

<li>Nemiver (stránky projektu)<br />
<a href="https://wiki.gnome.org/Apps/Nemiver">https://wiki.gnome.org/Apps/Nemiver</a>
</li>

<li>Basic Assembler Debugging with GDB<br />
<a href="http://dbp-consulting.com/tutorials/debugging/basicAsmDebuggingGDB.html">http://dbp-consulting.com/tutorials/debugging/basicAsmDebuggingGDB.html</a>
</li>

<li>Nemiver FAQ<br />
<a href="https://wiki.gnome.org/Apps/Nemiver/FAQ">https://wiki.gnome.org/Apps/Nemiver/FAQ</a>
</li>

<li>Nemiver (Wikipedia)<br />
<a href="https://en.wikipedia.org/wiki/Nemiver">https://en.wikipedia.org/wiki/Nemiver</a>
</li>

<li>Data Display Debugger<br />
<a href="https://www.gnu.org/software/ddd/">https://www.gnu.org/software/ddd/</a>
</li>

<li>GDB - Dokumentace<br />
<a href="http://sourceware.org/gdb/current/onlinedocs/gdb/">http://sourceware.org/gdb/current/onlinedocs/gdb/</a>
</li>

<li>BASH Debugger<br />
<a href="http://bashdb.sourceforge.net/">http://bashdb.sourceforge.net/</a>
</li>

<li>The Perl Debugger(s)<br />
<a href="http://debugger.perl.org/">http://debugger.perl.org/</a>
</li>

<li>Visual Debugging with DDD<br />
<a href="http://www.drdobbs.com/tools/visual-debugging-with-ddd/184404519">http://www.drdobbs.com/tools/visual-debugging-with-ddd/184404519</a>
</li>

<li>Pydb - Extended Python Debugger<br />
<a href="http://bashdb.sourceforge.net/pydb/">http://bashdb.sourceforge.net/pydb/</a>
</li>

<li>Insight<br />
<a href="http://www.sourceware.org/insight/">http://www.sourceware.org/insight/</a>
</li>

<li>Supported Languages (GNU Debugger)<br />
<a href="http://sourceware.org/gdb/current/onlinedocs/gdb/Supported-Languages.html#Supported-Languages">http://sourceware.org/gdb/current/onlinedocs/gdb/Supported-Languages.html#Supported-Languages</a>
</li>

<li>GNU Debugger (Wikipedia)<br />
<a href="https://en.wikipedia.org/wiki/GNU_Debugger">https://en.wikipedia.org/wiki/GNU_Debugger</a>
</li>

<li>The LLDB Debugger<br />
<a href="http://lldb.llvm.org/">http://lldb.llvm.org/</a>
</li>

<li>Debugger (Wikipedia)<br />
<a href="https://en.wikipedia.org/wiki/Debugger">https://en.wikipedia.org/wiki/Debugger</a>
</li>

<li>13 Linux Debuggers for C++ Reviewed<br />
<a href="http://www.drdobbs.com/testing/13-linux-debuggers-for-c-reviewed/240156817">http://www.drdobbs.com/testing/13-linux-debuggers-for-c-reviewed/240156817</a>
</li>

<li>Clewn<br />
<a href="http://clewn.sourceforge.net/">http://clewn.sourceforge.net/</a>
</li>

<li>Clewn installation<br />
<a href="http://clewn.sourceforge.net/install.html">http://clewn.sourceforge.net/install.html</a>
</li>

<li>Clewn - soubory ke stažení<br />
<a href="http://sourceforge.net/projects/clewn/files/OldFiles/">http://sourceforge.net/projects/clewn/files/OldFiles/</a>
</li>

<li>Pyclewn installation notes<br />
<a href="http://pyclewn.sourceforge.net/install.html">http://pyclewn.sourceforge.net/install.html</a>
</li>

<li>Debugging<br />
<a href="http://janus.uclan.ac.uk/pagray/labs/debug.htm">http://janus.uclan.ac.uk/pagray/labs/debug.htm</a>
</li>

</ol>



<p></p><p></p>
<p><small>Autor: <a href="http://www.fit.vutbr.cz/~tisnovpa">Pavel Tišnovský</a> &nbsp; 2016</small></p>
</body>
</html>

