<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
        "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html>
<head>
<title>Funkce a typový systém programovacího jazyka ML</title>
<meta name="Author" content="Pavel Tisnovsky" />
<meta name="Generator" content="vim" />
<meta http-equiv="content-type" content="text/html; charset=utf-8" />
<style type="text/css">
         body {color:#000000; background:#ffffff;}
         h1  {font-family: arial, helvetica, sans-serif; color:#ffffff; background-color:#c00000; text-align:center; padding-left:1em}
         h2  {font-family: arial, helvetica, sans-serif; color:#ffffff; background-color:#0000c0; padding-left:1em; text-align:left}
         h3  {font-family: arial, helvetica, sans-serif; color:#000000; background-color:#c0c0c0; padding-left:1em; text-align:left}
         h4  {font-family: arial, helvetica, sans-serif; color:#000000; background-color:#e0e0e0; padding-left:1em; text-align:left}
         a   {font-family: arial, helvetica, sans-serif;}
         li  {font-family: arial, helvetica, sans-serif; color:#000000; text-align:justify; width:450px;}
         ol  {font-family: arial, helvetica, sans-serif; color:#000000; text-align:justify; width:450px;}
         ul  {font-family: arial, helvetica, sans-serif; color:#000000; text-align:justify; width:450px;}
         p   {font-family: arial, helvetica, sans-serif; color:#000000; text-align:justify;}
         pre {background:#e0e0e0}
</style>
</head>

<body>

<h1>Funkce a typový systém programovacího jazyka ML</h1>

<h3>Pavel Tišnovský</h3>

<p></p>

<h1>Úvodník</h1>

<p>Ve druhé části článku (resp.&nbsp;celého miniseriálu) o programovacím jazyku ML se zaměříme především na podrobnější popis typového systému tohoto jazyka a taktéž na složitější funkce, které používají pattern matching.</p>



<h2>Obsah</h2>

<p><a href="#k01">1. Referenčně transparentní funkce a jejich význam při optimalizaci aplikací</a></p>
<p><a href="#k02">2. Definice běžných funkcí, volání funkcí s&nbsp;předáváním parametrů</a></p>
<p><a href="#k03">3. Rekurzivní funkce</a></p>
<p><a href="#k04">4. Pattern matching</a></p>
<p><a href="#k05">5. Generická funkce <strong>append</strong></a></p>
<p><a href="#k06">6. Přetěžování operátorů?</a></p>
<p><a href="#k07">7. Použití operátoru @</a></p>
<p><a href="#k08">8. Pattern matching pro více variant</a></p>
<p><a href="#k09">9. Koncová rekurze</a></p>
<p><a href="#k10">10. Funkce vyššího řádu</a></p>
<p><a href="#k11">11. Otestování funkce <strong>map</strong></a></p>
<p><a href="#k12">12. Explicitní určení typů</a></p>
<p><a href="#k13">13. Spojení řetězců předaných v&nbsp;seznamu</a></p>
<p><a href="#k14">14. Vyvolání výjimky</a></p>
<p><a href="#k15">15. Odvození typu parametru z&nbsp;typu návratové hodnoty</a></p>
<p><a href="#k16">16. Typ <strong>option</strong></a></p>
<p><a href="#k17">17. Příloha: funkce pro operaci nad seznamy</a></p>
<p><a href="#k18">18. Repositář s&nbsp;demonstračními příklady</a></p>
<p><a href="#k19">19. Literatura</a></p>
<p><a href="#k20">20. Odkazy na Internetu</a></p>



<p><a name="k01"></a></p>
<h2 id="k01">1. Referenčně transparentní funkce a jejich význam při optimalizaci aplikací</h2>

<p>Již <a
href="https://www.root.cz/clanky/ml-funkcionalni-jazyk-s-revolucnim-typovym-systemem/">v&nbsp;úvodním
článku o programovacím jazyce ML</a> jsme si řekli, že tento jazyk patří,
společně s&nbsp;klasickým LISPem, Scheme, Haskellem či Erlangem do skupiny (ne
vždy nutně čistě) funkcionálních jazyků, tj.&nbsp;programovacích jazyků
vycházejících z&nbsp;teorie takzvaného <i>λ-kalkulu</i>, jehož autorem je
Alonzo Church (na první návrhy LISPu se dokonce můžeme dívat jako na jeden
z&nbsp;formalizovaných způsobů zápisu λ-kalkulu, pro nějž jen tak mimochodem
existuje mechanismus vyhodnocování jednotlivých λ výrazů; taktéž se tím
například vysvětluje přítomnost znaku lambda v&nbsp;logu jazyka Clojure nebo
Racketu). Ve skutečnosti sice ML není čistě funkcionálním jazykem, ovšem
v&nbsp;případě, že vývojář bude při tvorbě svých aplikací dodržovat zásady
funkcionálního programování, bude pro něj mnohem snadnější vytvářet skutečně
výkonné aplikace (navíc bezpečné z&nbsp;hlediska souběhu).</p>

<p>Připomeňme si taktéž, že v&nbsp;programovacím jazyce ML jsou funkce
považovány za plnohodnotné datové typy, což znamená, že funkce lze navázat na
libovolný symbol (a tím vlastně původně anonymní funkci pojmenovat), funkce lze
předávat jako parametry do jiných funkcí a funkce mohou být taktéž návratovou
hodnotou jiných funkcí &ndash; funkce tedy může vytvořit a vrátit jinou funkci.
ML taktéž podporuje práci s&nbsp;uzávěry (<i>closure(s)</i>), tj.&nbsp;funkcí
svázaných s&nbsp;nějakým symbolem (symboly) vytvořenými vně funkce. Podpora
uzávěrů umožňuje například tvorbu funkcí sdílejících společný kontext (GUI),
líné vyhodnocování atd. Taktéž lze ovšem vytvářet funkce s&nbsp;vedlejším
efektem, které například zapisují data do souborů, mění hodnotu navázanou na
globální symboly atd.</p>

<p>Vývojáři by však neměli tyto možnosti nabízené programovacím jazykem ML
zneužívat, protože tím znemožňují využití některých optimalizačních technik a
v&nbsp;neposlední řadě si taktéž komplikují možnost testování takto vytvořených
funkcí. Namísto toho se ukazuje být velmi výhodné vytvářet takzvané
<i>referenčně transparentní funkce</i>, což jsou funkce, které nepřistupují
k&nbsp;žádným globálním symbolům, nemají žádný vedlejší efekt ani si nepamatují
žádný vnitřní stav (příkladem &bdquo;funkce&ldquo; s&nbsp;vnitřním stavem je
například funkce <strong>random</strong>). Referenčně transparentní funkci jsou
při jejím volání předány parametry a funkce pouze na základě hodnot předaných
parametrů vrátí nějaký výsledek. Tato (pochopitelná) vlastnost má jeden
důležitý důsledek &ndash; chování referenčně transparentní funkce je nezávislé
na stavu aplikace a je taktéž zcela nezávislé na tom, kdy je funkce
zavolána.</p>

<p><div class="rs-tip-major">Poznámka: můžeme jít ještě dále a zaručit, že
funkce nebude měnit (mutovat) ani hodnoty svých lokálních proměnných. Jediná
změna stavu nastává při volání další funkce (nebo i té samé funkce), což
mj.&nbsp;znamená, že všechny změny jsou uloženy na zásobníku.</div></p>



<p><a name="k02"></a></p>
<h2 id="k02">2. Definice běžných funkcí, volání funkcí s&nbsp;předáváním parametrů</h2>

<p>Připomeňme si, jakým způsobem se v&nbsp;programovacím jazyku ML definují
funkce. V&nbsp;případě, že se má jednat o pojmenovanou (tedy neanonymní)
funkci, používá se pro definici takové funkce snadno zapamatovatelné slovo
<strong>fun</strong>, za nímž následuje jméno funkce, seznam formálních
parametrů, znak = a tělo funkce (už z&nbsp;tohoto zápisu je patrné, že se
počítá s&nbsp;tím, že se jedná o referenčně transparentní funkce).</p>

<p>Příklad definice funkce s&nbsp;jediným parametrem:</p>

<pre>
<i>(* Definice funkce s jedním parametrem *)</i>
&nbsp;
<strong>fun inc n = n + 1;</strong>
</pre>

<p>Takto definovanou funkci lze zavolat dvěma způsoby &ndash; bez kulatých
závorek popř.&nbsp;naopak s&nbsp;využitím závorek:</p>

<pre>
inc 1;
inc(1);
</pre>

<p>Velmi podobně lze definovat funkci se dvěma parametry:</p>

<pre>
<i>(* Definice funkce se dvěma parametry *)</i>
&nbsp;
<strong>fun add (x, y) = x + y;</strong>
</pre>

<p>V&nbsp;tomto případě však bude volání vyžadovat použití kulatých
závorek:</p>

<pre>
add(3,4);
</pre>

<p>V&nbsp;dalším textu se budeme zabývat datovými typy, takže se podívejme,
jakého typu jsou obě výše definované funkce. Typ funkce je v&nbsp;ML odvozen
nejenom od počtu parametrů, ale i od typů těchto parametrů i typu návratové
hodnoty. V&nbsp;případě, že tyto typy nejsou přímo určeny programátorem (a to
v&nbsp;našem případě nejsou), bude se provádět odvozování. V&nbsp;těchto
konkrétních případech se typ odvodí z&nbsp;výrazů <i>n + 1</i> a <i>x + y</i>
následovně:</p>

<pre>
<strong>fun inc n = n + 1;</strong>
&gt; val inc = fn: int → int;
&nbsp;
<strong>fun add (x, y) = x + y;</strong>
&gt; val add = fn: int * int → int;
</pre>

<p><div class="rs-tip-major">Poznámka: zápis <i>int * int</i> značí kombinaci
dvou hodnot typu <strong>int</strong>.</div></p>



<p><a name="k03"></a></p>
<h2 id="k03">3. Rekurzivní funkce</h2>

<p>Rekurze, neboli volání nějaké funkce v&nbsp;těle té samé funkce (přímá
rekurze) nebo prostřednictvím funkce jiné (takzvaná nepřímá rekurze),
představuje jednu ze základních programátorských technik, na kterých je ML
postaven, podobně jako další funkcionální jazyky. Můžeme zde spatřovat velkou
inspiraci Lispem, ve kterém se rekurze také velmi často používá; ostatně
samotné Lispovské příkazy, například <i>apply</i>, <i>map</i> či <i>forall</i>
jsou definovány rekurzivně, podobně jako v&nbsp;dalším Lispovsky orientovaném
jazyce &ndash; ve Scheme. Samotná myšlenka rekurze je však starší než všechny
programovací jazyky, protože je hluboce zakořeněna jak v podstatě některých
přírodních i umělých jevů či objektů, tak i v&nbsp;matematice, v&nbsp;například
v&nbsp;definicích různých algebraických a geometrických struktur.</p>

<p>Definice přímé rekurzivní funkce v&nbsp;jazyce ML je zcela bezproblémová
&ndash; nejsou zapotřebí žádné dopředné (&bdquo;forward&ldquo;) deklarace atd.
A pochopitelně jsou stále odvozovány popř.&nbsp;hlídány datové typy předávaných
parametrů i návratových hodnot:</p>

<pre>
<i>(* Naivní implementace funkce length *)</i>
&nbsp;
<strong>fun length(x) = if null(x) then 0</strong>
                <strong>else 1 + length(tl(x));</strong>
</pre>

<p>Typ této funkce je zajímavý &ndash; funkce bude akceptovat seznam
libovolného typu, tj.&nbsp;jedná se o generickou funkci (<i>'a</i> zde značí
&bdquo;any&ldquo;):</p>

<pre>
val length = fn: ∀ 'a . 'a list → int;
</pre>

<p>Otestování je snadné:</p>

<pre>
<strong>length([]);</strong>
&gt; val it = 0: int;
&nbsp;
<strong>length([1]);</strong>
&gt; val it = 1: int;
&nbsp;
<strong>length([1,2,3,4]);</strong>
&gt; val it = 4: int;
</pre>

<p><div class="rs-tip-major">Poznámka: toto řešení není nejvhodnější, protože
se parametry zbytečně ukládají na zásobník. V&nbsp;dalším textu si ukážeme sice
složitější, ale obecně rychlejší a méně paměťově náročnější řešení založené na
<i>koncové rekurzi</i>.</div></p>



<p><a name="k04"></a></p>
<h2 id="k04">4. Pattern matching</h2>

<p>Výše uvedená implementace funkce <strong>length</strong> není pro jazyk ML
idiomatická &ndash; spíše se podobá přímému přepisu z&nbsp;LISPu nebo ze
Scheme. Častěji se setkáme s&nbsp;použitím pattern matchingu, kterým se
(v&nbsp;tomto případě) určují těla funkce pro různé vstupní podmínky. Díky tomu
lze velmi snadno a především přehledně vyjmenovat například všechny mezní
podmínky. Pro funkci <strong>length</strong> je zde jediná mezní podmínka a tou
je předání prázdného seznamu (další možnost je jen jedna &ndash; předal se
neprázdný seznam; jiná možnost díky typovému systému není povolena):</p>

<pre>
<i>(* Implementace funkce length založená na pattern matchingu *)</i>
&nbsp;
<strong>fun length([]) = 0</strong>
  <strong>| length(lst) = 1 + length(tl(lst));</strong>
</pre>

<p>Vzhledem k&nbsp;tomu, že v&nbsp;hlavičce funkce je jediný parametr
(v&nbsp;obou případech), můžeme vynechat kulaté závorky:</p>

<pre>
<i>(* Implementace funkce length založená na pattern matchingu *)</i>
&nbsp;
<strong>fun length [] = 0</strong>
  <strong>| length lst = 1 + length(tl(lst));</strong>
</pre>

<p>Předchozí použití pattern matchingu ovšem ani zdaleka neukazuje všechny
možnosti programovacího jazyka ML v&nbsp;této oblasti. Díky existenci operátoru
<strong>::</strong> (zápis připojení prvku k&nbsp;seznamu, obdoba
<strong>cons</strong> z&nbsp;LISPu/Clojure) můžeme přímo ve druhé větvi
specifikovat, že pokud se na vstupu objeví seznam s&nbsp;hlavičkou a tělem
(tedy má alespoň jeden prvek), má se provést tato větev a funkce
<strong>length</strong> se má rekurzivně volat s&nbsp;tělem seznamu (které už
může být prázdné):</p>

<pre>
<i>(* Implementace funkce length založená na pattern matchingu *)</i>
&nbsp;
<strong>fun length([]) = 0</strong>
  <strong>| length(head::tail) = 1 + length(tail);</strong>
</pre>

<p>Vzhledem k&nbsp;tomu, že se hodnota hlavičky seznamu (jeho prvního prvku)
nikde nepoužívá, lze zápis ještě více zjednodušit náhradou identifikátoru za
podtržítko:</p>

<pre>
<i>(* Implementace funkce length založená na pattern matchingu *)</i>
&nbsp;
<strong>fun length([]) = 0</strong>
  <strong>| length(_::tail) = 1 + length(tail);</strong>
</pre>



<p><a name="k05"></a></p>
<h2 id="k05">5. Generická funkce <strong>append</strong></h2>

<p>Další rekurzivní funkcí, kterou je možné v&nbsp;jazyku ML velmi snadno
implementovat, je funkce, která k&nbsp;existujícímu seznamu připojí druhý
seznam (již jsme se s&nbsp;ní seznámili minule). Pro tuto operaci sice existuje
specializovaný operátor <strong>@</strong>, ale zajímavější bude se pokusit
funkci implementovat vlastními silami:</p>

<pre>
<i>(* Naivní implementace funkce append *)</i>
&nbsp;
<strong>fun append(x, y) = if null(x) then y</strong>
                   <strong>else hd(x) :: append(tl(x), y);</strong>

</pre>

<p>Povšimněte si, že ML automaticky odvodil jak typ parametrů této funkce, tak
i typ návratové hodnoty. Pro tuto operaci musel analyzovat interně volané
funkce, tedy <strong>null</strong>, <strong>hd</strong> a
<strong>tl</strong>:</p>

<pre>
val append = fn: ∀ 'a . 'a list * 'a list → 'a list;
</pre>

<p>Funkci <strong>append</strong> si můžeme otestovat, a to včetně mezních
případů &ndash; jeden ze seznamů může být prázdný:</p>

<pre>
<strong>append([], [1, 2, 3]);</strong>
&gt; val it = [1, 2, 3]: int list;
&nbsp;
<strong>append([1, 2, 3], []);</strong>
&gt; val it = [1, 2, 3]: int list;
&nbsp;
<strong>append([1, 2, 3], [4, 5]);</strong>
&gt; val it = [1, 2, 3, 4, 5]: int list;
&nbsp;
<strong>append([], []);</strong>
&gt; val it = []: '~A list, '~A free;
</pre>

<p><div class="rs-tip-major">Poznámka: poslední výsledek je opět zajímavý
&ndash; netypovaná &bdquo;volná&ldquo; proměnná typu seznam.</div></p>

<p>Vzhledem k&nbsp;tomu, že se opět jedná o generickou funkci, můžeme jí předat
seznamy jiného typu:</p>

<pre>
<strong>append(["foo", "bar"], ["baz"]);</strong>
&gt; val it = ["foo", "bar", "baz"]: string list;
</pre>

<p>Nebo taktéž:</p>

<pre>
<strong>append([[1,2], [3,4,5]], [[6,7,8], [9]]);</strong>
&nbsp;
val it = [[1, 2], [3, 4, 5], [6, 7, 8], [9]]: int list list;
</pre>

<p>Idiomatičtější je opět použití pattern matchingu, které může v&nbsp;případě
funkce <strong>append</strong> vypadat následovně:</p>

<pre>
<i>(* Implementace funkce append založená na pattern matchingu *)</i>
&nbsp;
<strong>fun append([], y) = y</strong>
  <strong>| append(head::tail, y) = head :: append(tail, y);</strong>
</pre>

<p><div class="rs-tip-major">Poznámka: povšimněte si, že řešíme jen jediný
mezní případ, a to prázdnost prvního seznamu. To, že je druhý seznam prázdný,
nás nemusí explicitně zajímat. A jiná možnost díky typovému systému nemůže
nastat.</div></p>



<p><a name="k06"></a></p>
<h2 id="k06">6. Přetěžování operátorů?</h2>

<p>Tvůrci jazyka ML se při jeho návrhu snažili o to, aby nebylo nutné příliš
často explicitně specifikovat datové typy parametrů funkcí, lokálních
proměnných či výrazů. Zastavme se na chvíli právě u výrazů. Pro relativně velké
množství zcela odlišných datových typů existuje operace typu &bdquo;spoj&ldquo;
či &bdquo;sečti&ldquo;. Týká se to například celých čísel, reálných čísel,
seznamů, ale i řetězců. V&nbsp;některých programovacích jazycích se tato
operace aplikovaná na různé datové typy reprezentuje totožným operátorem
<strong>+</strong>, který je v&nbsp;tomto kontextu přetížený.</p>

<p><div class="rs-tip-major">Poznámka: například v&nbsp;Pythonu přetížení došlo
do stavu, kdy lze napsat <strong>True+True</strong> nebo
<strong>True+1</strong> a získat celočíselný výsledek těchto výrazů.</div></p>

<p>V&nbsp;programovacím jazyku ML je sice operátor <strong>+</strong> zdánlivě
taktéž přetížen, protože ho lze použít jak pro typ <strong>int</strong>, tak i
pro typ <strong>real</strong>. Ve skutečnosti tomu tak není, protože tento
operátor je definován pro typ <strong>num</strong>, což je typ získaný
sloučením (<i>union</i>) typů <strong>int</strong> a <strong>real</strong>
(někdy též <strong>word</strong>). Ke sloučeným datovým typům se dostaneme
později a mimochodem se jedná o jednu z&nbsp;nejsilnějších vlastností jazyka
ML. Ovšem vraťme se k&nbsp;operátoru <strong>+</strong>, jehož typový popis
vypadá následovně:</p>

<pre>
val + : num * num -&gt; num
</pre>

<p>kde:</p>

<pre>
num = int union real
</pre>

<p>nebo:</p>

<pre>
num = word union int union real
</pre>

<p>Další podobné datové typy pro variantu jazyka ML podporující
<strong>word</strong> a <strong>word8</strong>:</p>

<table>
<tr><th>Sjednocení</th><th>Základní datové typy</th></tr>
<tr><td>realint</td><td>int, real</td></tr>
<tr><td>wordint</td><td>int, word, word8</td></tr>
<tr><td>num    </td><td>int, real, word, word8</td></tr>
<tr><td>numtxt </td><td>int, real, word, word8, char, string</td></tr>
</table>

<p>To ovšem znamená, že pro spojování řetězců nebo seznamů se musí použít jiné
funkce nebo jiné operátory. Skutečně tomu tak je; existuje totiž speciální
operátor určený pouze pro spojení dvou řetězců a jiný operátor určený pro
spojení dvou seznamů. Bez zdlouhavého vysvětlování jejich funkce se podívejme
na jejich typový popis, z&nbsp;něhož už by mělo být vše zřejmé:</p>

<pre>
val @ : ('a list * 'a list) -&gt; 'a list
val ^ : string * string -&gt; string
</pre>

<p><div class="rs-tip-major">Poznámka: jen na okraj &ndash; obecně platí, že
tyto operace mají časovou složitost O(n).</div></p>



<p><a name="k07"></a></p>
<h2 id="k07">7. Použití operátoru @</h2>

<p>Operátor <strong>@</strong> určený pro spojování seznamů je možné použít i
pro takové operace, pro které není striktně určen. Můžeme například vytvořit
funkci <strong>reverse</strong>, která celý seznam otočí a to tak, že postupně
bude odebírat prvky z&nbsp;jednoho konce seznamu (ve fázi navíjení) a poté je
připojovat za druhý konec seznamu (ve fází odvíjení). A operátor
<strong>@</strong> se použije z&nbsp;toho důvodu, že <strong>::</strong> lze
použít pouze pro připojení prvku na začátek seznamu, nikoli na jeho konec. Ve
výsledku získáme funkci se složitostí <i>O(n2)</i>:

<pre>
<i>(* Naivní implementace funkce reverse *)</i>
&nbsp;
<strong>fun reverse(x) = if null(x) then x</strong>
                 <strong>else reverse(tl(x)) @ [hd(x)];</strong>
</pre>

<p>Tato funkce je typu:</p>

<pre>
val reverse = fn: ∀ 'a . 'a list → 'a list;
</pre>

<p>Opět se tedy jedná o generickou funkci, která není závislá na typu prvků
seznamu (ovšem výsledný seznam bude stejného typu).</p>

<p>Otestovat funkci <strong>reverse</strong> můžeme i s&nbsp;využitím prázdného
seznamu na vstupu:</p>

<pre>
reverse([]);
reverse([1,2]);
reverse([1,2,3,4]);
</pre>

<p>Idiomatický zápis používající pattern matching:</p>

<pre>
<i>(* Implementace funkce reverse pattern matchingem *)</i>
&nbsp;
<strong>fun reverse([]) = []</strong>
  <strong>| reverse(lst) = reverse(tl(lst)) @ [hd(lst)];</strong>
</pre>

<p>Ještě lepší je zápis, v&nbsp;němž můžeme vynechat volání <strong>tl</strong>
a <strong>hd</strong> (to se stejně provede, ale skrytě):</p>

<pre>
<i>(* Implementace funkce reverse pattern matchingem *)</i>
&nbsp;
<strong>fun reverse([]) = []</strong>
  <strong>| reverse(head::tail) = reverse(tail) @ [head];</strong>
</pre>

<p><div class="rs-tip-major">Poznámka: povšimněte si, že připojovaný prvek
musíme převést na seznam, a to jednoduše tak, že ho zapíšeme do hranatých
závorek.</div></p>



<p><a name="k08"></a></p>
<h2 id="k08">8. Pattern matching pro více variant</h2>

<p>Prozatím jsme si ukazovali funkce, v&nbsp;nichž se pattern matching používal
pro rozhodnutí mezi dvěma variantami, takže by se mohlo zdát, že se jedná o
jakousi formu rozhodovací konstrukce if-then-else. Ve skutečnosti může variant
existovat větší množství, takže se spíše jedná o konstrukci typu switch (ovšem
bez přidružených problémů, které tato konstrukce do některých jazyků přinesla).
Podívejme se nejprve na to, jak by se v&nbsp;jazyku ML mohla definovat funkce
pro výpočet n-tého členu slavné Fibonacciho posloupnosti. Jedno z&nbsp;možných
řešení přímo vychází z&nbsp;jedné varianty matematické definice této
posloupnosti (existuje ještě varianta s&nbsp;F<sub>0</sub>=0):</p>

<pre>
F<sub>1</sub> = 1
F<sub>2</sub> = 1
F<sub>n</sub> = F<sub>n-1</sub> + F<sub>n-2</sub>
</pre>

<p>Přepis tohoto předpisu bez použití pattern matchingu bude vypadat takto:</p>

<pre>
<i>(* Naivní implementace výpočtu Fibonacciho posloupnosti *)</i>
&nbsp;
<strong>fun fib n =</strong>
    <strong>if n = 0 then 0 else</strong>
    <strong>if n = 1 then 1 else</strong>
    <strong>fib (n - 1) + fib (n - 2);</strong>
</pre>

<p>Otestování:</p>

<pre>
fib 0;
fib 1;
fib 10;
</pre>

<p>Ve skutečnosti ovšem můžeme vzít matematický předpis a prakticky doslova ho
přepsat do ML:</p>

<pre>
<i>(* Implementace výpočtu Fibonacciho posloupnosti s využitím pattern matchingu *)</i>
&nbsp;
<strong>fun fib 0 = 0</strong>
  <strong>| fib 1 = 1</strong>
  <strong>| fib n = fib (n - 1) + fib (n - 2);</strong>
</pre>

<p><div class="rs-tip-major">Poznámka: podle mého názoru se jedná o jednu
z&nbsp;nejelegantnějších forem zápisu vůbec.</div></p>



<p><a name="k09"></a></p>
<h2 id="k09">9. Koncová rekurze</h2>

<p>Vraťme se ještě k&nbsp;funkci <strong>length</strong>, kterou jsme zapsali
takto:</p>

<pre>
<i>(* Implementace funkce length založená na pattern matchingu *)</i>
&nbsp;
<strong>fun length([]) = 0</strong>
  <strong>| length(_::tail) = 1 + length(tail);</strong>
</pre>

<p>Z&nbsp;paměťového i časového hlediska se ovšem nejedná o nejlepší zápis
algoritmu, protože se zde používá skutečná rekurze. Lepší bude funkci přepsat
tak, aby bylo možné použít <i>koncovou rekurzi</i>. Ta je založena na tom, že
pokud se na konci funkce rekurzivně volá ta samá funkce a s&nbsp;výsledkem se
již žádným způsobem nemanipuluje (třeba se k&nbsp;němu nic nepřičítá), lze
interně rekurzi převést na smyčku. Jedno z&nbsp;možných řešení může vypadat
takto:</p>

<pre>
<strong>fun accumulate ([], a) = a</strong>
  <strong>| accumulate ((_::tail), a) = accumulate(tail, (1 + a));</strong>
&nbsp;
<strong>fun length lst = accumulate(lst, 0);</strong>
</pre>

<p>Vytvořili jsme zde pomocnou funkci <strong>accumulate</strong>, která je
sice rekurzivní, ale využívá se zde koncové rekurze &ndash; funkce sice volá
sama sebe, ale takovým způsobem, že není nutné používat zásobník. Tuto pomocnou
funkci pak zavoláme s&nbsp;tím, že akumulátor <strong>a</strong> je
inicializován na nulu.</p>

<p><div class="rs-tip-major">Poznámka: idiomatičtější zápis využívá programové
konstrukce, které prozatím neznáme:</div></p>

<pre>
<strong>fun length lst = let</strong>
    <strong>fun accumulate [] a = a</strong>
      <strong>| accumulate (_::tail) a = accumulate tail (1 + a)</strong>
  <strong>in accumulate lst 0</strong>
<strong>end</strong>
</pre>



<p><a name="k10"></a></p>
<h2 id="k10">10. Funkce vyššího řádu</h2>

<p>Ve funkcionálních programovacích jazycích mají funkce stejně plnohodnotný
význam, jako jakékoli jiné datové typy. Výjimkou není, jak již ostatně víme,
ani programovací jazyk ML, v&nbsp;němž je typ funkce odvozen od typů parametrů
a návratové hodnoty. Pokud je ovšem funkce plnohodnotným datovým typem, znamená
to, že může být předána jako parametr do jiné funkce popř.&nbsp;vrácena jako
návratová hodnota (jiné) funkce. Funkcím, které jako svůj parametr akceptují
jinou funkci popř.&nbsp;které vrací funkci, se říká <i>funkce vyššího řádu</i>.
Takové funkce jsou v&nbsp;jazyku ML plně podporovány a nalezneme je i ve
standardní knihovně tohoto jazyka. Podívejme se na asi nejtypičtější prakticky
použitelnou funkci vyššího řádu. Jedná se o funkci <strong>map</strong>, která
aplikuje (jinou) funkci na jednotlivé prvky seznamu, přičemž výsledkem bude
nový seznam. Funkci <strong>map</strong> lze realizovat rekurzivně:</p>

<pre>
<i>(* Implementace funkce map *)</i>
&nbsp;
<strong>fun map f [] = []</strong>
  <strong>| map f (head::tail) = (f head) :: (map f tail);</strong>
</pre>

<p>Pokud ve vstupním seznamu existuje alespoň jeden prvek
(<strong>head</strong>), je na něj aplikována funkce <strong>f</strong> předaná
jako parametr a rekurzivně se zavolá <strong>map</strong> pro zbytek seznamu.
Zajímavý je typ funkce <strong>map</strong> získaný automatickým odvozením:</p>

<pre>
val map = fn: ∀ 'a 'b . ('a → 'b) → 'a list → 'b list;
</pre>

<p><div class="rs-tip-major">Poznámka: opět se jedná o generickou funkci, ovšem
s&nbsp;precizně specifikovaným typem vstupních parametrů i návratové
hodnoty.</div></p>



<p><a name="k11"></a></p>
<h2 id="k11">11. Otestování funkce <strong>map</strong></h2>

<p>Funkci <strong>map</strong> si můžeme snadno otestovat, například tak, že na
prvky seznamu budeme aplikovat funkci <strong>inc</strong>:</p>

<pre>
<strong>fun inc x = x + 1;</strong>
&nbsp;
<strong>map inc [1,2,3];</strong>
</pre>

<p>S&nbsp;výsledkem:</p>

<pre>
val it = [2, 3, 4]: int list;
</pre>

<p>Funkci <strong>map</strong> ovšem můžeme použít i pro výpočty nad vektory
reálných čísel:</p>

<pre>
<strong>fun half x = x / 2.0;</strong>
&nbsp;
<strong>map half [1.0,2.0,3.0,4.0,5.0];</strong>
</pre>

<p>Tentokrát s&nbsp;výsledkem:</p>

<pre>
<strong>val it = [0.5, 1.0, 1.5, 2.0, 2.5]: real list;</strong>
</pre>

<p>Ovšem stále je zaručena typová korektnost:</p>

<pre>
<strong>map half [1, 2, 3, 4, 5];</strong>
Elaboration failed: Type clash. Functions of type "real list → real list"
cannot take an argument of type "int list": Cannot merge "real" and "int".
</pre>



<p><a name="k12"></a></p>
<h2 id="k12">12. Explicitní určení typů</h2>

<p>Vraťme se opět k&nbsp;funkci <strong>sum</strong>, kterou jsme definovali
následovně:</p>

<pre>
<i>(* Výpočet součtu prvků v seznamu *)</i>
&nbsp;
<strong>fun sum([]) = 0</strong>
  <strong>| sum(x::y) = x + sum y;</strong>
</pre>

<p>U takto definované funkce je odvozen datový typ:</p>

<pre>
val sum = fn: int list → int;
</pre>

<p>Což znamená, že je funkce použitelná pouze pro seznamy celých čísel.</p>

<p>Alternativně je možné náhradou 0 za 0.0 dosáhnout toho, že funkce bude
použitelná pro seznamy reálných čísel (ovšem již ne čísel celých):</p>

<pre>
<i>(* Výpočet součtu prvků v seznamu *)</i>
&nbsp;
<strong>fun sum([]) = 0.0</strong>
  <strong>| sum(x::y) = x + sum y;</strong>
&nbsp;
&nbsp;
<strong>sum([1.1, 2.2, 3.3]);</strong>
</pre>

<p>Typ můžeme specifikovat i explicitně, například u parametru (a klidně i
v&nbsp;jediné větvi):</p>

<pre>
<i>(* Výpočet součtu prvků v seznamu *)</i>
&nbsp;
<strong>fun sum([] : real list) = 0.0</strong>
  <strong>| sum(x::y) = x + sum y;</strong>
&nbsp;
&nbsp;
<strong>sum([1.1, 2.2, 3.3]);</strong>
</pre>

<p>Podobně je tomu u funkce <strong>add</strong>:</p>

<pre>
<i>(* Definice funkce se dvěma parametry *)</i>
&nbsp;
<strong>fun add (x, y) = x + y;</strong>
&nbsp;
&nbsp;
<strong>add(3,4);</strong>
</pre>

<p>Explicitní specifikace typu jednoho z&nbsp;parametrů (ovlivní i + a tím i
druhý parametr):</p>

<pre>
<i>(* Definice funkce se dvěma parametry typu real *)</i>
&nbsp;
<strong>fun add(x:real,y) = x+y;</strong>
&nbsp;
&nbsp;
<strong>add(1.2, 3.4);</strong>
</pre>



<p><a name="k13"></a></p>
<h2 id="k13">13. Spojení řetězců předaných v&nbsp;seznamu</h2>

<p>Spojení dvou řetězců lze provést operátorem <strong>^</strong>, takže je
snadné napsat rekurzivní podobu funkce, která spojí všechny řetězce předané
v&nbsp;seznamu. Stále přitom používáme stejný základ &ndash; pattern matching,
rozdělení seznamu na hlavu a tělo a rekurzi:</p>

<pre>
<i>(* Spojení řetězců předaných v seznamu *)</i>
&nbsp;
<strong>fun join([] : string list) = ""</strong>
  <strong>| join(x::y) = x ^ join y;</strong>
&nbsp;
&nbsp;
<strong>join(["foo", " ", "bar", " ", "baz"]);</strong>
</pre>



<p><a name="k14"></a></p>
<h2 id="k14">14. Vyvolání výjimky</h2>

<p>Již na konci předchozího článku jsme si ukázali funkci, která vrátí první
prvek seznamu. Pokud první prvek neexistuje, vyvolá se výjimka:</p>

<pre>
<i>(* Vrácení prvního prvku ze seznamu *)</i>
&nbsp;
<strong>fun car([]) = raise Empty</strong>
  <strong>| car(x::y) = x;</strong>
&nbsp;
&nbsp;
car([]);
car([1]);
car([1,2]);
car([1,2,3]);
car(["foo", "bar"]);
</pre>

<p><div class="rs-tip-major">Poznámka: jméno této funkce je sice odvozeno od
lispovské funkce <strong>car</strong>, ovšem chování je a musí být odlišné.
V&nbsp;LISPu se pro prázdný seznam bez problémů vracela hodnota
<strong>nil</strong>, což ovšem v&nbsp;silně typovaném jazyce typu ML není
možné (jednoduše) zařídit &ndash; typ návratové hodnoty totiž musí odpovídat
typu prvků v&nbsp;seznamu ('a je na obou stranách shodný typ):</div></p>

<pre>
val car = fn: ∀ 'a . 'a list → 'a;
</pre>



<p><a name="k15"></a></p>
<h2 id="k15">15. Odvození typu parametru z&nbsp;typu návratové hodnoty</h2>

<p>Kouzlo typového systému programovacího jazyka ML spočívá v&nbsp;tom, že typ
parametru lze odvodit z&nbsp;typu návratové hodnoty (či naopak). Pokud je tedy
typ návratové hodnoty určen explicitně, bude to bráno v&nbsp;úvahu
v&nbsp;typovém odvozování. A to i tehdy, pokud je typ návratové hodnoty určen
v&nbsp;jediné větvi pattern matchingu (viz podtrženou část kódu):</p>

<pre>
<i>(* Vrácení prvního prvku ze seznamu *)</i>
&nbsp;
<strong>fun car([]) = raise Empty</strong>
  <strong>| car(x::y) = x : int;</strong>
</pre>

<p>Nyní bude typ funkce <strong>car</strong> odvozen do:</p>

<pre>
val car = fn: int list → int;
</pre>

<p>zatímco předchozí typ byl:</p>

<pre>
val car = fn: ∀ 'a . 'a list → 'a;
</pre>

<p><div class="rs-tip-major">Poznámka: za typovým odvozováním stojí solidní
teorie, ale celý proces si můžeme zjednodušeně představit tak, že se informace
o konkrétních typech (ať již vzniknou kdekoli) šíří do všech směrů, až
překladač zjistí o funkci všechny potřebné informace &ndash; a na jejich
základě odvodí typ parametrů i návratové hodnoty popř.&nbsp;vypíše informaci o
kolizi typů.</div></p>



<p><a name="k16"></a></p>
<h2 id="k16">16. Typ <strong>option</strong></h2>

<p>Na závěr se musíme zmínit o velmi užitečném datovém typu nazvaném
<strong>option</strong> (ten jsme si již popsali <a
href="https://www.root.cz/serialy/programovaci-jazyk-rust/">v&nbsp;seriálu o
Rustu</a>). Tento datový typ se používá například ve chvílích, kdy je zapotřebí
reprezentovat neznámou hodnotu, chybovou hodnotu (ovšem bez vyvolání výjimky),
vytvořit funkci s&nbsp;volitelnými parametry či vytvořit typově bezpečnou
obdobu odkazu typu <strong>null</strong> (<strong>null</strong> samo o sobě je
v&nbsp;IT zlo :-). Typ <strong>option</strong> si můžeme představit jako unii
se dvěma hodnotami <strong>NONE</strong> a <strong>SOME</strong>, přičemž
hodnota <strong>SOME</strong> je kontejnerem pro jinou hodnotu, například
výsledek výpočtu.</p>

<p>Poměrně typickým příkladem je funkce pro dělení, která ve chvíli, kdy je
dělitel nulový, vrátí hodnotu <strong>NONE</strong> a při nenulovém děliteli
pak hodnotu <strong>SOME</strong>, která obaluje vypočtený podíl:</p>

<pre>
<i>(* Použití typu option *)</i>
&nbsp;
<strong>fun divide(x, 0) = NONE</strong>
  <strong>| divide(x, y) = SOME(x div y);</strong>
&nbsp;
&nbsp;
divide(10, 5);
divide(10, 0);
</pre>

<p>Typ funkce je:</p>

<pre>
val divide = fn: int * int → int option;
</pre>

<p>A vypočtené výsledky:</p>

<pre>
val it = SOME 2: int option;
val it = NONE: int option;
</pre>



<p><a name="k17"></a></p>
<h2 id="k17">17. Příloha: funkce pro operaci nad seznamy</h2>

<p>V&nbsp;příloze jsou vypsány standardní funkce určené pro provádění operací
nad seznamy. U funkcí schválně neuvádím bližší popis, ale pouze jejich typový
popis, z&nbsp;něhož je (při kombinaci s&nbsp;názvem funkce) mnohdy přímo patrné
jaká operace se provádí. Jedná se o další z&nbsp;předností silného typového
systému:</p>

<table>
<tr><th>Funkce</th><th>Typový popis</th></tr>
<tr><td>null</td><td>'a list -&gt; bool</td></tr>
<tr><td>length</td><td>'a list -&gt; int</td></tr>
<tr><td>@</td><td>'a list * 'a list -&gt; 'a list</td></tr>
<tr><td>hd</td><td>'a list -&gt; 'a</td></tr>
<tr><td>tl</td><td>'a list -&gt; 'a list</td></tr>
<tr><td>last</td><td>'a list -&gt; 'a</td></tr>
<tr><td>getItem</td><td>'a list -&gt; ('a * 'a list) option</td></tr>
<tr><td>nth</td><td>'a list * int -&gt; 'a</td></tr>
<tr><td>take</td><td>'a list * int -&gt; 'a list</td></tr>
<tr><td>drop</td><td>'a list * int -&gt; 'a list</td></tr>
<tr><td>rev</td><td>'a list -&gt; 'a list</td></tr>
<tr><td>concat</td><td>'a list list -&gt; 'a list</td></tr>
<tr><td>revAppend</td><td>'a list * 'a list -&gt; 'a list</td></tr>
<tr><td>app</td><td>('a -&gt; unit) -&gt; 'a list -&gt; unit</td></tr>
<tr><td>map</td><td>('a -&gt; 'b) -&gt; 'a list -&gt; 'b list</td></tr>
<tr><td>mapPartial</td><td>('a -&gt; 'b option) -&gt; 'a list -&gt; 'b list</td></tr>
<tr><td>find</td><td>('a -&gt; bool) -&gt; 'a list -&gt; 'a option</td></tr>
<tr><td>filter</td><td>('a -&gt; bool) -&gt; 'a list -&gt; 'a list</td></tr>
<tr><td>partition</td><td>('a -&gt; bool) -&gt; 'a list -&gt; 'a list * 'a list</td></tr>
<tr><td>foldl</td><td>('a * 'b -&gt; 'b) -&gt; 'b -&gt; 'a list -&gt; 'b</td></tr>
<tr><td>foldr</td><td>('a * 'b -&gt; 'b) -&gt; 'b -&gt; 'a list -&gt; 'b</td></tr>
<tr><td>exists</td><td>('a -&gt; bool) -&gt; 'a list -&gt; bool</td></tr>
<tr><td>all</td><td>('a -&gt; bool) -&gt; 'a list -&gt; bool</td></tr>
<tr><td>tabulate</td><td>int * (int -&gt; 'a) -&gt; 'a list</td></tr>
<tr><td>collate</td><td>('a * 'a -&gt; order) -&gt; 'a list * 'a list -&gt; order</td></tr>
</table>



<p><a name="k18"></a></p>
<h2 id="k18">18. Repositář s&nbsp;demonstračními příklady</h2>

<p>Všechny výše popsané demonstrační příklady byly uloženy do repositáře
dostupného na adrese <a
href="https://github.com/tisnik/ml-examples/">https://github.com/tisnik/ml-examples/</a>.
V&nbsp;tabulce umístěné pod tímto odstavcem jsou uvedeny odkazy na tyto
příklady:</p>

<table>
<tr><th> #</th><th>Příklad</th><th>Popis příkladu</th><th>Cesta</th></tr>
<tr><td> 1</td><td>01_function_definition.ml</td><td>definice funkce s&nbsp;jediným parametrem</td><td><a href="https://github.com/tisnik/ml-examples/tree/master/article_02/01_function_definition.ml">https://github.com/tisnik/ml-examples/tree/master/article_02/01_function_definition.ml</a></td></tr>
<tr><td> 2</td><td>02_add_function.ml</td><td>definice funkce se dvěma parametry</td><td><a href="https://github.com/tisnik/ml-examples/tree/master/article_02/02_add_function.ml">https://github.com/tisnik/ml-examples/tree/master/article_02/02_add_function.ml</a></td></tr>
<tr><td> 3</td><td>03_length_function_naive.ml</td><td>naivní implementace funkce length</td><td><a href="https://github.com/tisnik/ml-examples/tree/master/article_02/03_length_function_naive.ml">https://github.com/tisnik/ml-examples/tree/master/article_02/03_length_function_naive.ml</a></td></tr>
<tr><td> 4</td><td>04_length_pattern_matching.ml</td><td>implementace funkce <strong>length</strong> založená na pattern matchingu</td><td><a href="https://github.com/tisnik/ml-examples/tree/master/article_02/04_length_pattern_matching.ml">https://github.com/tisnik/ml-examples/tree/master/article_02/04_length_pattern_matching.ml</a></td></tr>
<tr><td> 5</td><td>05_length_pattern_matching.ml</td><td>implementace funkce <strong>length</strong> založená na pattern matchingu</td><td><a href="https://github.com/tisnik/ml-examples/tree/master/article_02/05_length_pattern_matching.ml">https://github.com/tisnik/ml-examples/tree/master/article_02/05_length_pattern_matching.ml</a></td></tr>
<tr><td> 6</td><td>06_length_pattern_matching.ml</td><td>implementace funkce <strong>length</strong> založená na pattern matchingu</td><td><a href="https://github.com/tisnik/ml-examples/tree/master/article_02/06_length_pattern_matching.ml">https://github.com/tisnik/ml-examples/tree/master/article_02/06_length_pattern_matching.ml</a></td></tr>
<tr><td> 7</td><td>07_append_function_naive.ml</td><td>naivní implementace funkce append</td><td><a href="https://github.com/tisnik/ml-examples/tree/master/article_02/07_append_function_naive.ml">https://github.com/tisnik/ml-examples/tree/master/article_02/07_append_function_naive.ml</a></td></tr>
<tr><td> 8</td><td>08_append_function_pattern_matching.ml</td><td>implementace funkce <strong>append</strong> založená na pattern matchingu</td><td><a href="https://github.com/tisnik/ml-examples/tree/master/article_02/08_append_function_pattern_matching.ml">https://github.com/tisnik/ml-examples/tree/master/article_02/08_append_function_pattern_matching.ml</a></td></tr>
<tr><td> 9</td><td>09_reverse_function_naive.ml</td><td>naivní implementace funkce reverse</td><td><a href="https://github.com/tisnik/ml-examples/tree/master/article_02/09_reverse_function_naive.ml">https://github.com/tisnik/ml-examples/tree/master/article_02/09_reverse_function_naive.ml</a></td></tr>
<tr><td>10</td><td>10_reverse_function_pattern_matching.ml</td><td>implementace funkce reverse pattern matchingem</td><td><a href="https://github.com/tisnik/ml-examples/tree/master/article_02/10_reverse_function_pattern_matching.ml">https://github.com/tisnik/ml-examples/tree/master/article_02/10_reverse_function_pattern_matching.ml</a></td></tr>
<tr><td>11</td><td>11_reverse_function_pattern_matching.ml</td><td>alternativní implementace funkce reverse pattern matchingem</td><td><a href="https://github.com/tisnik/ml-examples/tree/master/article_02/11_reverse_function_pattern_matching.ml">https://github.com/tisnik/ml-examples/tree/master/article_02/11_reverse_function_pattern_matching.ml</a></td></tr>
<tr><td>12</td><td>12_fibonacci_naive.ml</td><td>naivní implementace výpočtu Fibonacciho posloupnosti</td><td><a href="https://github.com/tisnik/ml-examples/tree/master/article_02/12_fibonacci_naive.ml">https://github.com/tisnik/ml-examples/tree/master/article_02/12_fibonacci_naive.ml</a></td></tr>
<tr><td>13</td><td>13_fibonacci_pattern_matching.ml</td><td>implementace výpočtu Fibonacciho posloupnosti s využitím pattern matchingu</td><td><a href="https://github.com/tisnik/ml-examples/tree/master/article_02/13_fibonacci_pattern_matching.ml">https://github.com/tisnik/ml-examples/tree/master/article_02/13_fibonacci_pattern_matching.ml</a></td></tr>
<tr><td>14</td><td>14_sum.ml</td><td>výpočet součtu prvků v&nbsp;seznamu celých čísel</td><td><a href="https://github.com/tisnik/ml-examples/tree/master/article_02/14_sum.ml">https://github.com/tisnik/ml-examples/tree/master/article_02/14_sum.ml</a></td></tr>
<tr><td>15</td><td>15_map.ml</td><td>implementace funkce <strong>map</strong></td><td><a href="https://github.com/tisnik/ml-examples/tree/master/article_02/15_map.ml">https://github.com/tisnik/ml-examples/tree/master/article_02/15_map.ml</a></td></tr>
<tr><td>16</td><td>16_map.ml</td><td>použití funkce <strong>map</strong></td><td><a href="https://github.com/tisnik/ml-examples/tree/master/article_02/16_map.ml">https://github.com/tisnik/ml-examples/tree/master/article_02/16_map.ml</a></td></tr>
<tr><td>17</td><td>17_sum_real.ml</td><td>výpočet součtu prvků v&nbsp;seznamu reálných čísel</td><td><a href="https://github.com/tisnik/ml-examples/tree/master/article_02/17_sum_real.ml">https://github.com/tisnik/ml-examples/tree/master/article_02/17_sum_real.ml</a></td></tr>
<tr><td>18</td><td>18_add_real.ml</td><td>součet dvou reálných čísel</td><td><a href="https://github.com/tisnik/ml-examples/tree/master/article_02/18_add_real.ml">https://github.com/tisnik/ml-examples/tree/master/article_02/18_add_real.ml</a></td></tr>
<tr><td>19</td><td>19_sum_real.ml</td><td>alternativní výpočet součtu prvků v&nbsp;seznamu reálných čísel</td><td><a href="https://github.com/tisnik/ml-examples/tree/master/article_02/19_sum_real.ml">https://github.com/tisnik/ml-examples/tree/master/article_02/19_sum_real.ml</a></td></tr>
<tr><td>20</td><td>20_string_join.ml</td><td>funkce <strong>join</strong> pro spojení řetězců</td><td><a href="https://github.com/tisnik/ml-examples/tree/master/article_02/20_string_join.ml">https://github.com/tisnik/ml-examples/tree/master/article_02/20_string_join.ml</a></td></tr>
<tr><td>21</td><td>21_car.ml</td><td>generická funkce <strong>car</strong></td><td><a href="https://github.com/tisnik/ml-examples/tree/master/article_02/21_car.ml">https://github.com/tisnik/ml-examples/tree/master/article_02/21_car.ml</a></td></tr>
<tr><td>22</td><td>22_car_int.ml</td><td>funkce <strong>car</strong> s&nbsp;uvedením typů</td><td><a href="https://github.com/tisnik/ml-examples/tree/master/article_02/22_car_int.ml">https://github.com/tisnik/ml-examples/tree/master/article_02/22_car_int.ml</a></td></tr>
<tr><td>23</td><td>23_some_none.ml</td><td>využití typu <strong>option</strong></td><td><a href="https://github.com/tisnik/ml-examples/tree/master/article_02/23_some_none.ml">https://github.com/tisnik/ml-examples/tree/master/article_02/23_some_none.ml</a></td></tr>
</table>



<p><a name="k19"></a></p>
<h2 id="k19">19. Literatura</h2>

<p><div class="rs-tip-major">Poznámka: v&nbsp;této kapitole jsou uvedeny
nejenom knihy o jazyku ML resp.&nbsp;Standard ML, ale i knihy o programovacím
jazyku OCaml, který ze Standard ML ze značné míry vychází.</div></p>

<ol>

<li>ML for the Working Programmer<br />
<a href="https://www.cl.cam.ac.uk/~lp15/MLbook/pub-details.html">https://www.cl.cam.ac.uk/~lp15/MLbook/pub-details.html</a>
</li>

<li>Elements of ML Programming, 2nd Edition (ML97)<br />
<a href="http://infolab.stanford.edu/~ullman/emlp.html">http://infolab.stanford.edu/~ullman/emlp.html</a>
</li>

<li>A tour of Standard ML<br />
<a href="https://saityi.github.io/sml-tour/tour/welcome">https://saityi.github.io/sml-tour/tour/welcome</a>
</li>

<li>The History of Standard ML<br />
<a href="https://smlfamily.github.io/history/SML-history.pdf">https://smlfamily.github.io/history/SML-history.pdf</a>
</li>

<li>The Standard ML Basis Library<br />
<a href="https://smlfamily.github.io/Basis/">https://smlfamily.github.io/Basis/</a>
</li>

<li>Programming in Standard ML<br />
<a href="http://www.cs.cmu.edu/~rwh/isml/book.pdf">http://www.cs.cmu.edu/~rwh/isml/book.pdf</a>
</li>

<li>Programming in Standard ML '97: A Tutorial Introduction<br />
<a href="http://www.lfcs.inf.ed.ac.uk/reports/97/ECS-LFCS-97-364/">http://www.lfcs.inf.ed.ac.uk/reports/97/ECS-LFCS-97-364/</a>
</li>

<li>Programming in Standard ML '97: An On-line Tutorial<br />
<a href="https://homepages.inf.ed.ac.uk/stg/NOTES/">https://homepages.inf.ed.ac.uk/stg/NOTES/</a>
</li>

<li>The OCaml system  release 4.13<br />
<a href="https://ocaml.org/releases/4.13/htmlman/index.html">https://ocaml.org/releases/4.13/htmlman/index.html</a>
</li>

<li>Real World OCaml: Functional programming for the masses<br />
<a href="https://dev.realworldocaml.org/">https://dev.realworldocaml.org/</a>
</li>

<li>OCaml from the Very Beginning<br />
<a href="http://ocaml-book.com/">http://ocaml-book.com/</a>
</li>

<li>OCaml from the Very Beginning: More OCaml : Algorithms, Methods &amp; Diversions<br />
<a href="http://ocaml-book.com/more-ocaml-algorithms-methods-diversions/">http://ocaml-book.com/more-ocaml-algorithms-methods-diversions/</a>
</li>

<li>Unix system programming in OCaml<br />
<a href="http://ocaml.github.io/ocamlunix/">http://ocaml.github.io/ocamlunix/</a>
</li>

<li>OCaml for Scientists<br />
<a href="https://www.ffconsultancy.com/products/ocaml_for_scientists/index.html">https://www.ffconsultancy.com/products/ocaml_for_scientists/index.html</a>
</li>

<li>Using, Understanding, and Unraveling The OCaml Language<br />
<a href="https://caml.inria.fr/pub/docs/u3-ocaml/">https://caml.inria.fr/pub/docs/u3-ocaml/</a>
</li>

<li>Developing Applications With objective Caml<br />
<a href="https://caml.inria.fr/pub/docs/oreilly-book/index.html">https://caml.inria.fr/pub/docs/oreilly-book/index.html</a>
</li>

<li>Introduction to Objective Caml<br />
<a href="http://courses.cms.caltech.edu/cs134/cs134b/book.pdf">http://courses.cms.caltech.edu/cs134/cs134b/book.pdf</a>
</li>

<li>How to Think Like a (Functional) Programmer<br />
<a href="https://greenteapress.com/thinkocaml/index.html">https://greenteapress.com/thinkocaml/index.html</a>
</li>

</ol>



<p><a name="k20"></a></p>
<h2 id="k20">20. Odkazy na Internetu</h2>

<ol>

<li>Standard ML of New Jersey<br />
<a href="https://www.smlnj.org/">https://www.smlnj.org/</a>
</li>

<li>Programming Languages: Standard ML - 1 (a navazující videa)<br />
<a href="https://www.youtube.com/watch?v=2sqjUWGGzTo">https://www.youtube.com/watch?v=2sqjUWGGzTo</a>
</li>

<li>6 Excellent Free Books to Learn Standard ML<br />
<a href="https://www.linuxlinks.com/excellent-free-books-learn-standard-ml/">https://www.linuxlinks.com/excellent-free-books-learn-standard-ml/</a>
</li>

<li>SOSML: The Online Interpreter for Standard ML<br />
<a href="https://sosml.org/">https://sosml.org/</a>
</li>

<li>ML (Computer program language)<br />
<a href="https://www.barnesandnoble.com/b/books/other-programming-languages/ml-computer-program-language/_/N-29Z8q8Zvy7">https://www.barnesandnoble.com/b/books/other-programming-languages/ml-computer-program-language/_/N-29Z8q8Zvy7</a>
</li>

<li>Strong Typing<br />
<a href="https://perl.plover.com/yak/typing/notes.html">https://perl.plover.com/yak/typing/notes.html</a>
</li>

<li>What to know before debating type systems<br />
<a href="http://blogs.perl.org/users/ovid/2010/08/what-to-know-before-debating-type-systems.html">http://blogs.perl.org/users/ovid/2010/08/what-to-know-before-debating-type-systems.html</a>
</li>

<li>Types, and Why You Should Care (Youtube)<br />
<a href="https://www.youtube.com/watch?v=0arFPIQatCU">https://www.youtube.com/watch?v=0arFPIQatCU</a>
</li>

<li>DynamicTyping (Martin Fowler)<br />
<a href="https://www.martinfowler.com/bliki/DynamicTyping.html">https://www.martinfowler.com/bliki/DynamicTyping.html</a>
</li>

<li>DomainSpecificLanguage (Martin Fowler)<br />
<a href="https://www.martinfowler.com/bliki/DomainSpecificLanguage.html">https://www.martinfowler.com/bliki/DomainSpecificLanguage.html</a>
</li>

<li>Language Workbenches: The Killer-App for Domain Specific Languages?<br />
<a href="https://www.martinfowler.com/articles/languageWorkbench.html">https://www.martinfowler.com/articles/languageWorkbench.html</a>
</li>

<li>Effective ML (Youtube)<br />
<a href="https://www.youtube.com/watch?v=-J8YyfrSwTk">https://www.youtube.com/watch?v=-J8YyfrSwTk</a>
</li>

<li>Why OCaml (Youtube)<br />
<a href="https://www.youtube.com/watch?v=v1CmGbOGb2I">https://www.youtube.com/watch?v=v1CmGbOGb2I</a>
</li>

<li>CSE 341: Functions and patterns<br />
<a href="https://courses.cs.washington.edu/courses/cse341/04wi/lectures/03-ml-functions.html">https://courses.cs.washington.edu/courses/cse341/04wi/lectures/03-ml-functions.html</a>
</li>

<li>Comparing Objective Caml and Standard ML<br />
<a href="http://adam.chlipala.net/mlcomp/">http://adam.chlipala.net/mlcomp/</a>
</li>

<li>What are the key differences between Standard ML and OCaml?<br />
<a href="https://www.quora.com/What-are-the-key-differences-between-Standard-ML-and-OCaml?share=1">https://www.quora.com/What-are-the-key-differences-between-Standard-ML-and-OCaml?share=1</a>
</li>

<li>Cheat Sheets (pro OCaml)<br />
<a href="https://www.ocaml.org/docs/cheat_sheets.html">https://www.ocaml.org/docs/cheat_sheets.html</a>
</li>

<li>Syllabus (FAS CS51)<br />
<a href="https://cs51.io/college/syllabus/">https://cs51.io/college/syllabus/</a>
</li>

<li>Abstraction and Design In Computation<br />
<a href="http://book.cs51.io/">http://book.cs51.io/</a>
</li>

<li>Learn X in Y minutes Where X=Standard ML<br />
<a href="https://learnxinyminutes.com/docs/standard-ml/">https://learnxinyminutes.com/docs/standard-ml/</a>
</li>

<li>CSE307 Online - Summer 2018: Principles of Programing Languages course<br />
<a href="https://www3.cs.stonybrook.edu/~pfodor/courses/summer/cse307.html">https://www3.cs.stonybrook.edu/~pfodor/courses/summer/cse307.html</a>
</li>

<li>CSE307 Principles of Programming Languages course: SML part 1<br />
<a href="https://www.youtube.com/watch?v=p1n0_PsM6hw">https://www.youtube.com/watch?v=p1n0_PsM6hw</a>
</li>

<li>CSE 307 &ndash; Principles of Programming Languages &ndash; SML<br />
<a href="https://www3.cs.stonybrook.edu/~pfodor/courses/summer/CSE307/L01_SML.pdf">https://www3.cs.stonybrook.edu/~pfodor/courses/summer/CSE307/L01_SML.pdf</a>
</li>

<li>SML, Some Basic Examples<br />
<a href="https://cs.fit.edu/~ryan/sml/intro.html">https://cs.fit.edu/~ryan/sml/intro.html</a>
</li>

<li>History of programming languages<br />
<a href="https://devskiller.com/history-of-programming-languages/">https://devskiller.com/history-of-programming-languages/</a>
</li>

<li>History of programming languages (Wikipedia)<br />
<a href="https://en.wikipedia.org/wiki/History_of_programming_languages">https://en.wikipedia.org/wiki/History_of_programming_languages</a>
</li>

<li>Jemný úvod do rozsáhlého světa jazyků LISP a Scheme<br />
<a href="https://www.root.cz/clanky/jemny-uvod-do-rozsahleho-sveta-jazyku-lisp-a-scheme/">https://www.root.cz/clanky/jemny-uvod-do-rozsahleho-sveta-jazyku-lisp-a-scheme/</a>
</li>

<li>The Evolution Of Programming Languages<br />
<a href="https://www.i-programmer.info/news/98-languages/8809-the-evolution-of-programming-languages.html">https://www.i-programmer.info/news/98-languages/8809-the-evolution-of-programming-languages.html</a>
</li>

<li>Evoluce programovacích jazyků<br />
<a href="https://ccrma.stanford.edu/courses/250a-fall-2005/docs/ComputerLanguagesChart.png">https://ccrma.stanford.edu/courses/250a-fall-2005/docs/ComputerLanguagesChart.png</a>
</li>

<li>Poly/ML Homepage<br />
<a href="https://polyml.org/">https://polyml.org/</a>
</li>

<li>PolyConf 16: A brief history of F# / Rachel Reese<br />
<a href="https://www.youtube.com/watch?v=cbDjpi727aY">https://www.youtube.com/watch?v=cbDjpi727aY</a>
</li>

<li>Programovací jazyk Clojure 18: základní techniky optimalizace aplikací<br />
<a href="https://www.root.cz/clanky/programovaci-jazyk-clojure-18-zakladni-techniky-optimalizace-aplikaci/">https://www.root.cz/clanky/programovaci-jazyk-clojure-18-zakladni-techniky-optimalizace-aplikaci/</a>
</li>

<li>Moscow ML Language Overview<br />
<a href="https://itu.dk/people/sestoft/mosml/mosmlref.pdf">https://itu.dk/people/sestoft/mosml/mosmlref.pdf</a>
</li>

</ol>



<p></p><p></p>
<p><small>Autor: <a href="http://www.fit.vutbr.cz/~tisnovpa">Pavel Tišnovský</a> &nbsp; 2022</small></p>
</body>
</html>

<!--
    07:00 - 08:00       22000
    08:00 - 09:00       24000
    09:00 - 10:00       26000
    10:00 - 11:00       28000
    11:00 - 12:00       30000
    12:00 - 13:00       32000
    13:00 - 14:00       34000
    14:00 - 15:00       36000
    15:00 - 16:00       38000
-->
