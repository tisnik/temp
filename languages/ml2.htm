<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
        "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html>
<head>
<title>Funkce a typový systém programovacího jazyka ML</title>
<meta name="Author" content="Pavel Tisnovsky" />
<meta name="Generator" content="vim" />
<meta http-equiv="content-type" content="text/html; charset=utf-8" />
<style type="text/css">
         body {color:#000000; background:#ffffff;}
         h1  {font-family: arial, helvetica, sans-serif; color:#ffffff; background-color:#c00000; text-align:center; padding-left:1em}
         h2  {font-family: arial, helvetica, sans-serif; color:#ffffff; background-color:#0000c0; padding-left:1em; text-align:left}
         h3  {font-family: arial, helvetica, sans-serif; color:#000000; background-color:#c0c0c0; padding-left:1em; text-align:left}
         h4  {font-family: arial, helvetica, sans-serif; color:#000000; background-color:#e0e0e0; padding-left:1em; text-align:left}
         a   {font-family: arial, helvetica, sans-serif;}
         li  {font-family: arial, helvetica, sans-serif; color:#000000; text-align:justify; width:450px;}
         ol  {font-family: arial, helvetica, sans-serif; color:#000000; text-align:justify; width:450px;}
         ul  {font-family: arial, helvetica, sans-serif; color:#000000; text-align:justify; width:450px;}
         p   {font-family: arial, helvetica, sans-serif; color:#000000; text-align:justify;}
         pre {background:#e0e0e0}
</style>
</head>

<body>

<h1></h1>

<h3>Pavel Tišnovský</h3>

<p></p>

<h1>Úvodník</h1>

<p></p>



<h2>Obsah</h2>

<p><a href="#k01">1. Referenčně transparentní funkce a jejich význam při optimalizaci aplikací</a></p>
<p><a href="#k02">2. Definice běžných funkcí, volání funkcí s&nbsp;předáváním parametrů</a></p>
<p><a href="#k03">*** 3. Rekurzivní funkce</a></p>
<p><a href="#k04">*** 4. </a></p>
<p><a href="#k05">*** 5. </a></p>
<p><a href="#k06">*** 6. </a></p>
<p><a href="#k07">*** 7. </a></p>
<p><a href="#k08">*** 8. </a></p>
<p><a href="#k09">*** 9. </a></p>
<p><a href="#k10">*** 10. </a></p>
<p><a href="#k11">*** 11. </a></p>
<p><a href="#k12">*** 12. </a></p>
<p><a href="#k13">*** 13. </a></p>
<p><a href="#k14">*** 14. </a></p>
<p><a href="#k15">*** 15. </a></p>
<p><a href="#k16">*** 16. </a></p>
<p><a href="#k17">*** 17. </a></p>
<p><a href="#k18">18. Repositář s&nbsp;demonstračními příklady</a></p>
<p><a href="#k19">19. Literatura</a></p>
<p><a href="#k20">20. Odkazy na Internetu</a></p>



<p><a name="k01"></a></p>
<h2 id="k01">1. Referenčně transparentní funkce a jejich význam při optimalizaci aplikací</h2>

<p>Již <a
href="https://www.root.cz/clanky/ml-funkcionalni-jazyk-s-revolucnim-typovym-systemem/">v&nbsp;úvodním
článku o programovacím jazyce ML</a> jsme si řekli, že tento jazyk patří,
společně s&nbsp;klasickým LISPem, Scheme, Haskellem či Erlangem do skupiny (ne
vždy nutně čistě) funkcionálních jazyků, tj.&nbsp;programovacích jazyků
vycházejících z&nbsp;teorie takzvaného <i>λ-kalkulu</i>, jehož autorem je
Alonzo Church (na první návrhy LISPu se dokonce můžeme dívat jako na jeden
z&nbsp;formalizovaných způsobů zápisu λ-kalkulu, pro nějž jen tak mimochodem
existuje mechanismus vyhodnocování jednotlivých λ výrazů; taktéž se tím
například vysvětluje přítomnost znaku lambda v&nbsp;logu jazyka Clojure nebo
Racketu). Ve skutečnosti sice ML není čistě funkcionálním jazykem, ovšem
v&nbsp;případě, že vývojář bude při tvorbě svých aplikací dodržovat zásady
funkcionálního programování, bude pro něj mnohem snadnější vytvářet skutečně
výkonné aplikace (navíc bezpečné z&nbsp;hlediska souběhu).</p>

<p>Připomeňme si taktéž, že v&nbsp;programovacím jazyce ML jsou funkce
považovány za plnohodnotné datové typy, což znamená, že funkce lze navázat na
libovolný symbol (a tím vlastně původně anonymní funkci pojmenovat), funkce lze
předávat jako parametry do jiných funkcí a funkce mohou být taktéž návratovou
hodnotou jiných funkcí &ndash; funkce tedy může vytvořit a vrátit jinou funkci.
ML taktéž podporuje práci s&nbsp;uzávěry (<i>closure(s)</i>), tj.&nbsp;funkcí
svázaných s&nbsp;nějakým symbolem (symboly) vytvořenými vně funkce. Podpora
uzávěrů umožňuje například tvorbu funkcí sdílejících společný kontext (GUI),
líné vyhodnocování atd. Taktéž lze ovšem vytvářet funkce s&nbsp;vedlejším
efektem, které například zapisují data do souborů, mění hodnotu navázanou na
globální symboly atd.</p>

<p>Vývojáři by však neměli tyto možnosti nabízené programovacím jazykem ML
zneužívat, protože tím znemožňují využití některých optimalizačních technik a
v&nbsp;neposlední řadě si taktéž komplikují možnost testování takto vytvořených
funkcí. Namísto toho se ukazuje být velmi výhodné vytvářet takzvané
<i>referenčně transparentní funkce</i>, což jsou funkce, které nepřistupují
k&nbsp;žádným globálním symbolům, nemají žádný vedlejší efekt ani si nepamatují
žádný vnitřní stav (příkladem &bdquo;funkce&ldquo; s&nbsp;vnitřním stavem je
například funkce <strong>random</strong>). Referenčně transparentní funkci jsou
při jejím volání předány parametry a funkce pouze na základě hodnot předaných
parametrů vrátí nějaký výsledek. Tato (pochopitelná) vlastnost má jeden
důležitý důsledek &ndash; chování referenčně transparentní funkce je nezávislé
na stavu aplikace a je taktéž zcela nezávislé na tom, kdy je funkce
zavolána.</p>

<p><div class="rs-tip-major">Poznámka: můžeme jít ještě dále a zaručit, že
funkce nebude měnit (mutovat) ani hodnoty svých lokálních proměnných. Jediná
změna stavu nastává při volání další funkce (nebo i té samé funkce), což
mj.&nbsp;znamená, že všechny změny jsou uloženy na zásobníku.</div></p>



<p><a name="k02"></a></p>
<h2 id="k02">2. Definice běžných funkcí, volání funkcí s&nbsp;předáváním parametrů</h2>

<p>Připomeňme si, jakým způsobem se v&nbsp;programovacím jazyku ML definují
funkce. V&nbsp;případě, že se má jednat o pojmenovanou (tedy neanonymní)
funkci, používá se pro definici takové funkce snadno zapamatovatelné slovo
<strong>fun</strong>, za nímž následuje jméno funkce, seznam formálních
parametrů, znak = a tělo funkce (už z&nbsp;tohoto zápisu je patrné, že se
počítá s&nbsp;tím, že se jedná o referenčně transparentní funkce).</p>

<p>Příklad definice funkce s&nbsp;jediným parametrem:</p>

<pre>
<i>(* Definice funkce s jedním parametrem *)</i>
&nbsp;
<strong>fun inc n = n + 1;</strong>
</pre>

<p>Takto definovanou funkci lze zavolat dvěma způsoby &ndash; bez kulatých
závorek popř.&nbsp;naopak s&nbsp;využitím závorek:</p>

<pre>
inc 1;
inc(1);
</pre>

<p>Velmi podobně lze definovat funkci se dvěma parametry:</p>

<pre>
<i>(* Definice funkce se dvěma parametry *)</i>
&nbsp;
<strong>fun add (x, y) = x + y;</strong>
</pre>

<p>V&nbsp;tomto případě však bude volání vyžadovat použití kulatých
závorek:</p>

<pre>
add(3,4);
</pre>

<p>V&nbsp;dalším textu se budeme zabývat datovými typy, takže se podívejme,
jakého typu jsou obě výše definované funkce. Typ funkce je v&nbsp;ML odvozen
nejenom od počtu parametrů, ale i od typů těchto parametrů i typu návratové
hodnoty. V&nbsp;případě, že tyto typy nejsou přímo určeny programátorem (a to
v&nbsp;našem případě nejsou), bude se provádět odvozování. V&nbsp;těchto
konkrétních případech se typ odvodí z&nbsp;výrazů <i>n + 1</i> a <i>x + y</i>
následovně:</p>

<pre>
<strong>fun inc n = n + 1;</strong>
&gt; val inc = fn: int → int;
&nbsp;
<strong>fun add (x, y) = x + y;</strong>
&gt; val add = fn: int * int → int;
</pre>

<p><div class="rs-tip-major">Poznámka: zápis <i>int * int</i> značí kombinaci
dvou hodnot typu <strong>int</strong>.</div></p>



<p><a name="k03"></a></p>
<h2 id="k03">3. Rekurzivní funkce</h2>

<p>Rekurze, neboli volání nějaké funkce v&nbsp;těle té samé funkce (přímá
rekurze) nebo prostřednictvím funkce jiné (takzvaná nepřímá rekurze),
představuje jednu ze základních programátorských technik, na kterých je ML
postaven, podobně jako další funkcionální jazyky. Můžeme zde spatřovat velkou
inspiraci Lispem, ve kterém se rekurze také velmi často používá; ostatně
samotné Lispovské příkazy, například <i>apply</i>, <i>map</i> či <i>forall</i>
jsou definovány rekurzivně, podobně jako v&nbsp;dalším Lispovsky orientovaném
jazyce &ndash; ve Scheme. Samotná myšlenka rekurze je však starší než všechny
programovací jazyky, protože je hluboce zakořeněna jak v podstatě některých
přírodních i umělých jevů či objektů, tak i v&nbsp;matematice, v&nbsp;například
v&nbsp;definicích různých algebraických a geometrických struktur.</p>

<pre>
<i>(* Naivní implementace funkce length *)</i>

fun length(x) = if null(x) then 0
                else 1 + length(tl(x));


length([]);
length([1]);
length([1,2,3,4]);
</pre>

<pre>
<i>(* Implementace funkce length založená na pattern matchingu *)</i>

fun length([]) = 0
  | length(lst) = 1 + length(tl(lst));


length([]);
length([1]);
length([1,2,3,4]);
</pre>

<pre>
<i>(* Implementace funkce length založená na pattern matchingu *)</i>

fun length [] = 0
  | length lst = 1 + length(tl(lst));
</pre>

<pre>
<i>(* Implementace funkce length založená na pattern matchingu *)</i>

fun length([]) = 0
  | length(head::tail) = 1 + length(tail);
</pre>



<p><a name="k03"></a></p>
<h2 id="k03">3. </h2>

<pre>
<i>(* Naivní implementace funkce append *)</i>

fun append(x, y) = if null(x) then y
                   else hd(x) :: append(tl(x), y);


append([], [1, 2, 3]);
append([1, 2, 3], []);
append([1, 2, 3], [4, 5]);
append([], []);
</pre>

<pre>
<i>(* Implementace funkce append založená na pattern matchingu *)</i>

fun append([], y) = y
  | append(head::tail, y) = head :: append(tail, y);
</pre>



<p><a name="k04"></a></p>
<h2 id="k04">4. </h2>

<pre>
<i>(* Naivní implementace funkce reverse *)</i>

fun reverse(x) = if null(x) then x
                 else reverse(tl(x)) @ [hd(x)];


reverse([]);
reverse([1,2]);
reverse([1,2,3,4]);
</pre>

<pre>
<i>(* Implementace funkce reverse pattern matchingem *)</i>

fun reverse([]) = []
  | reverse(lst) = reverse(tl(lst)) @ [hd(lst)];
</pre>

<pre>
<i>(* Implementace funkce reverse pattern matchingem *)</i>

fun reverse([]) = []
  | reverse(head::tail) = reverse(tail) @ [head];
</pre>



<p><a name="k05"></a></p>
<h2 id="k05">5. </h2>

<pre>
<i>(* Naivní implementace výpočtu Fibonacciho posloupnosti *)</i>

fun fib n =
    if n = 0 then 0 else
    if n = 1 then 1 else
    fib (n - 1) + fib (n - 2);


fib 0;
fib 1;
fib 10;
</pre>

<pre>
<i>(* Implementace výpočtu Fibonacciho posloupnosti s využitím pattern matchingu *)</i>

fun fib 0 = 0
  | fib 1 = 1
  | fib n = fib (n - 1) + fib (n - 2);


fib 0;
fib 1;
fib 10;
</pre>

<pre>
<i>(* Výpočet součtu prvků v seznamu *)</i>

fun sum([]) = 0
  | sum(x::y) = x + sum y;


sum([1,2,3]);
</pre>



<p><a name="k06"></a></p>
<h2 id="k06">6. </h2>



<p><a name="k07"></a></p>
<h2 id="k07">7. </h2>

<pre>
<i>(* Implementace funkce map *)</i>

fun map f [] = []
  | map f (head::tail) = (f head) :: (map f tail);


fun inc x = x + 1;

map inc [1,2,3];
</pre>



<p><a name="k08"></a></p>
<h2 id="k08">8. </h2>

<pre>
<i>(* Implementace funkce map *)</i>

fun map f [] = []
  | map f (head::tail) = (f head) :: (map f tail);


fun half x = x / 2.0;

map half [1.0,2.0,3.0,4.0,5.0];
</pre>



<p><a name="k09"></a></p>
<h2 id="k09">9. </h2>

<pre>
<i>(* Výpočet součtu prvků v seznamu *)</i>

fun sum([]) = 0
  | sum(x::y) = x + sum y;
</pre>

<pre>
<i>(* Výpočet součtu prvků v seznamu *)</i>

fun sum([]) = 0.0
  | sum(x::y) = x + sum y;


sum([1.1, 2.2, 3.3]);
</pre>



<p><a name="k10"></a></p>
<h2 id="k10">10. </h2>

<pre>
<i>(* Definice funkce se dvěma parametry *)</i>

fun add (x, y) = x + y;


add(3,4);
</pre>

<pre>
<i>(* Definice funkce se dvěma parametry typu real *)</i>

fun add(x:real,y) = x+y;


add(1.2, 3.4);
</pre>



<p><a name="k11"></a></p>
<h2 id="k11">11. </h2>

<pre>
<i>(* Výpočet součtu prvků v seznamu *)</i>

fun sum([] : real list) = 0.0
  | sum(x::y) = x + sum y;


sum([1.1, 2.2, 3.3]);
</pre>



<p><a name="k12"></a></p>
<h2 id="k12">12. </h2>

<pre>
<i>(* Spojení řetězců předaných v seznamu *)</i>

fun join([] : string list) = ""
  | join(x::y) = x ^ join y;


join(["foo", " ", "bar", " ", "baz"]);
</pre>



<p><a name="k13"></a></p>
<h2 id="k13">13. </h2>

<pre>
<i>(* Vrácení prvního prvku ze seznamu *)</i>

fun car([]) = raise Empty
  | car(x::y) = x;


car([]);
car([1]);
car([1,2]);
car([1,2,3]);
car(["foo", "bar"]);
</pre>

<pre>
<i>(* Vrácení prvního prvku ze seznamu *)</i>

fun car([]) = raise Empty
  | car(x::y) = x : int;
</pre>




<p><a name="k14"></a></p>
<h2 id="k14">14. </h2>



<p><a name="k15"></a></p>
<h2 id="k15">15. </h2>

<pre>
<i>(* Použití typu option *)</i>

fun divide(x, 0) = NONE
  | divide(x, y) = SOME(x div y);


divide(10, 5);
divide(10, 0);
</pre>



<p><a name="k16"></a></p>
<h2 id="k16">16. </h2>



<p><a name="k17"></a></p>
<h2 id="k17">17. </h2>



<p><a name="k18"></a></p>
<h2 id="k18">18. Repositář s&nbsp;demonstračními příklady</h2>

<p>Všechny výše popsané demonstrační příklady byly uloženy do repositáře
dostupného na adrese <a
href="https://github.com/tisnik/ml-examples/">https://github.com/tisnik/ml-examples/</a>.
V&nbsp;tabulce umístěné pod tímto odstavcem jsou uvedeny odkazy na tyto
příklady:</p>

<table>
<tr><th> #</th><th>Příklad</th><th>Popis příkladu</th><th>Cesta</th></tr>
<tr><td> 1</td><td>01_function_definition.ml</td><td>definice funkce s&nbsp;jediným parametrem</td><td><a href="https://github.com/tisnik/ml-examples/tree/master/article_02/01_function_definition.ml">https://github.com/tisnik/ml-examples/tree/master/article_02/01_function_definition.ml</a></td></tr>
<tr><td> 2</td><td>02_add_function.ml</td><td>definice funkce se dvěma parametry</td><td><a href="https://github.com/tisnik/ml-examples/tree/master/article_02/02_add_function.ml">https://github.com/tisnik/ml-examples/tree/master/article_02/02_add_function.ml</a></td></tr>
<tr><td> 3</td><td>03_length_function_naive.ml</td><td>naivní implementace funkce length</td><td><a href="https://github.com/tisnik/ml-examples/tree/master/article_02/03_length_function_naive.ml">https://github.com/tisnik/ml-examples/tree/master/article_02/03_length_function_naive.ml</a></td></tr>
<tr><td> 4</td><td>04_length_pattern_matching.ml</td><td>implementace funkce <strong>length</strong> založená na pattern matchingu</td><td><a href="https://github.com/tisnik/ml-examples/tree/master/article_02/04_length_pattern_matching.ml">https://github.com/tisnik/ml-examples/tree/master/article_02/04_length_pattern_matching.ml</a></td></tr>
<tr><td> 5</td><td>05_length_pattern_matching.ml</td><td>implementace funkce <strong>length</strong> založená na pattern matchingu</td><td><a href="https://github.com/tisnik/ml-examples/tree/master/article_02/05_length_pattern_matching.ml">https://github.com/tisnik/ml-examples/tree/master/article_02/05_length_pattern_matching.ml</a></td></tr>
<tr><td> 6</td><td>06_length_pattern_matching.ml</td><td>implementace funkce <strong>length</strong> založená na pattern matchingu</td><td><a href="https://github.com/tisnik/ml-examples/tree/master/article_02/06_length_pattern_matching.ml">https://github.com/tisnik/ml-examples/tree/master/article_02/06_length_pattern_matching.ml</a></td></tr>
<tr><td> 7</td><td>07_append_function_naive.ml</td><td>naivní implementace funkce append</td><td><a href="https://github.com/tisnik/ml-examples/tree/master/article_02/07_append_function_naive.ml">https://github.com/tisnik/ml-examples/tree/master/article_02/07_append_function_naive.ml</a></td></tr>
<tr><td> 8</td><td>08_append_function_pattern_matching.ml</td><td>implementace funkce <strong>append</strong> založená na pattern matchingu</td><td><a href="https://github.com/tisnik/ml-examples/tree/master/article_02/08_append_function_pattern_matching.ml">https://github.com/tisnik/ml-examples/tree/master/article_02/08_append_function_pattern_matching.ml</a></td></tr>
<tr><td> 9</td><td>09_reverse_function_naive.ml</td><td>naivní implementace funkce reverse</td><td><a href="https://github.com/tisnik/ml-examples/tree/master/article_02/09_reverse_function_naive.ml">https://github.com/tisnik/ml-examples/tree/master/article_02/09_reverse_function_naive.ml</a></td></tr>
<tr><td>10</td><td>10_reverse_function_pattern_matching.ml</td><td>implementace funkce reverse pattern matchingem</td><td><a href="https://github.com/tisnik/ml-examples/tree/master/article_02/10_reverse_function_pattern_matching.ml">https://github.com/tisnik/ml-examples/tree/master/article_02/10_reverse_function_pattern_matching.ml</a></td></tr>
<tr><td>11</td><td>11_reverse_function_pattern_matching.ml</td><td>alternativní implementace funkce reverse pattern matchingem</td><td><a href="https://github.com/tisnik/ml-examples/tree/master/article_02/11_reverse_function_pattern_matching.ml">https://github.com/tisnik/ml-examples/tree/master/article_02/11_reverse_function_pattern_matching.ml</a></td></tr>
<tr><td>12</td><td>12_fibonacci_naive.ml</td><td>naivní implementace výpočtu Fibonacciho posloupnosti</td><td><a href="https://github.com/tisnik/ml-examples/tree/master/article_02/12_fibonacci_naive.ml">https://github.com/tisnik/ml-examples/tree/master/article_02/12_fibonacci_naive.ml</a></td></tr>
<tr><td>13</td><td>13_fibonacci_pattern_matching.ml</td><td>implementace výpočtu Fibonacciho posloupnosti s využitím pattern matchingu</td><td><a href="https://github.com/tisnik/ml-examples/tree/master/article_02/13_fibonacci_pattern_matching.ml">https://github.com/tisnik/ml-examples/tree/master/article_02/13_fibonacci_pattern_matching.ml</a></td></tr>
<tr><td>14</td><td>14_sum.ml</td><td>výpočet součtu prvků v&nbsp;seznamu celých čísel</td><td><a href="https://github.com/tisnik/ml-examples/tree/master/article_02/14_sum.ml">https://github.com/tisnik/ml-examples/tree/master/article_02/14_sum.ml</a></td></tr>
<tr><td>15</td><td>15_map.ml</td><td>implementace funkce <strong>map</strong></td><td><a href="https://github.com/tisnik/ml-examples/tree/master/article_02/15_map.ml">https://github.com/tisnik/ml-examples/tree/master/article_02/15_map.ml</a></td></tr>
<tr><td>16</td><td>16_map.ml</td><td>použití funkce <strong>map</strong></td><td><a href="https://github.com/tisnik/ml-examples/tree/master/article_02/16_map.ml">https://github.com/tisnik/ml-examples/tree/master/article_02/16_map.ml</a></td></tr>
<tr><td>17</td><td>17_sum_real.ml</td><td>výpočet součtu prvků v&nbsp;seznamu reálných čísel</td><td><a href="https://github.com/tisnik/ml-examples/tree/master/article_02/17_sum_real.ml">https://github.com/tisnik/ml-examples/tree/master/article_02/17_sum_real.ml</a></td></tr>
<tr><td>18</td><td>18_add_real.ml</td><td>součet dvou reálných čísel</td><td><a href="https://github.com/tisnik/ml-examples/tree/master/article_02/18_add_real.ml">https://github.com/tisnik/ml-examples/tree/master/article_02/18_add_real.ml</a></td></tr>
<tr><td>19</td><td>19_sum_real.ml</td><td>alternativní výpočet součtu prvků v&nbsp;seznamu reálných čísel</td><td><a href="https://github.com/tisnik/ml-examples/tree/master/article_02/19_sum_real.ml">https://github.com/tisnik/ml-examples/tree/master/article_02/19_sum_real.ml</a></td></tr>
<tr><td>20</td><td>20_string_join.ml</td><td>funkce <strong>join</strong> pro spojení řetězců</td><td><a href="https://github.com/tisnik/ml-examples/tree/master/article_02/20_string_join.ml">https://github.com/tisnik/ml-examples/tree/master/article_02/20_string_join.ml</a></td></tr>
<tr><td>21</td><td>21_car.ml</td><td>generická funkce <strong>car</strong></td><td><a href="https://github.com/tisnik/ml-examples/tree/master/article_02/21_car.ml">https://github.com/tisnik/ml-examples/tree/master/article_02/21_car.ml</a></td></tr>
<tr><td>22</td><td>22_car_int.ml</td><td>funkce <strong>car</strong> s&nbsp;uvedením typů</td><td><a href="https://github.com/tisnik/ml-examples/tree/master/article_02/22_car_int.ml">https://github.com/tisnik/ml-examples/tree/master/article_02/22_car_int.ml</a></td></tr>
<tr><td>23</td><td>23_some_none.ml</td><td>využití typu <strong>option</strong></td><td><a href="https://github.com/tisnik/ml-examples/tree/master/article_02/23_some_none.ml">https://github.com/tisnik/ml-examples/tree/master/article_02/23_some_none.ml</a></td></tr>
</table>



<p><a name="k19"></a></p>
<h2 id="k19">19. Literatura</h2>

<p><div class="rs-tip-major">Poznámka: v&nbsp;této kapitole jsou uvedeny
nejenom knihy o jazyku ML resp.&nbsp;Standard ML, ale i knihy o programovacím
jazyku OCaml, který ze Standard ML ze značné míry vychází.</div></p>

<ol>

<li>ML for the Working Programmer<br />
<a href="https://www.cl.cam.ac.uk/~lp15/MLbook/pub-details.html">https://www.cl.cam.ac.uk/~lp15/MLbook/pub-details.html</a>
</li>

<li>Elements of ML Programming, 2nd Edition (ML97)<br />
<a href="http://infolab.stanford.edu/~ullman/emlp.html">http://infolab.stanford.edu/~ullman/emlp.html</a>
</li>

<li>A tour of Standard ML<br />
<a href="https://saityi.github.io/sml-tour/tour/welcome">https://saityi.github.io/sml-tour/tour/welcome</a>
</li>

<li>The History of Standard ML<br />
<a href="https://smlfamily.github.io/history/SML-history.pdf">https://smlfamily.github.io/history/SML-history.pdf</a>
</li>

<li>The Standard ML Basis Library<br />
<a href="https://smlfamily.github.io/Basis/">https://smlfamily.github.io/Basis/</a>
</li>

<li>Programming in Standard ML<br />
<a href="http://www.cs.cmu.edu/~rwh/isml/book.pdf">http://www.cs.cmu.edu/~rwh/isml/book.pdf</a>
</li>

<li>Programming in Standard ML '97: A Tutorial Introduction<br />
<a href="http://www.lfcs.inf.ed.ac.uk/reports/97/ECS-LFCS-97-364/">http://www.lfcs.inf.ed.ac.uk/reports/97/ECS-LFCS-97-364/</a>
</li>

<li>Programming in Standard ML '97: An On-line Tutorial<br />
<a href="https://homepages.inf.ed.ac.uk/stg/NOTES/">https://homepages.inf.ed.ac.uk/stg/NOTES/</a>
</li>

<li>The OCaml system  release 4.13<br />
<a href="https://ocaml.org/releases/4.13/htmlman/index.html">https://ocaml.org/releases/4.13/htmlman/index.html</a>
</li>

<li>Real World OCaml: Functional programming for the masses<br />
<a href="https://dev.realworldocaml.org/">https://dev.realworldocaml.org/</a>
</li>

<li>OCaml from the Very Beginning<br />
<a href="http://ocaml-book.com/">http://ocaml-book.com/</a>
</li>

<li>OCaml from the Very Beginning: More OCaml : Algorithms, Methods &amp; Diversions<br />
<a href="http://ocaml-book.com/more-ocaml-algorithms-methods-diversions/">http://ocaml-book.com/more-ocaml-algorithms-methods-diversions/</a>
</li>

<li>Unix system programming in OCaml<br />
<a href="http://ocaml.github.io/ocamlunix/">http://ocaml.github.io/ocamlunix/</a>
</li>

<li>OCaml for Scientists<br />
<a href="https://www.ffconsultancy.com/products/ocaml_for_scientists/index.html">https://www.ffconsultancy.com/products/ocaml_for_scientists/index.html</a>
</li>

<li>Using, Understanding, and Unraveling The OCaml Language<br />
<a href="https://caml.inria.fr/pub/docs/u3-ocaml/">https://caml.inria.fr/pub/docs/u3-ocaml/</a>
</li>

<li>Developing Applications With objective Caml<br />
<a href="https://caml.inria.fr/pub/docs/oreilly-book/index.html">https://caml.inria.fr/pub/docs/oreilly-book/index.html</a>
</li>

<li>Introduction to Objective Caml<br />
<a href="http://courses.cms.caltech.edu/cs134/cs134b/book.pdf">http://courses.cms.caltech.edu/cs134/cs134b/book.pdf</a>
</li>

<li>How to Think Like a (Functional) Programmer<br />
<a href="https://greenteapress.com/thinkocaml/index.html">https://greenteapress.com/thinkocaml/index.html</a>
</li>

</ol>



<p><a name="k20"></a></p>
<h2 id="k20">20. Odkazy na Internetu</h2>

<ol>

<li>Standard ML of New Jersey<br />
<a href="https://www.smlnj.org/">https://www.smlnj.org/</a>
</li>

<li>Programming Languages: Standard ML - 1 (a navazující videa)<br />
<a href="https://www.youtube.com/watch?v=2sqjUWGGzTo">https://www.youtube.com/watch?v=2sqjUWGGzTo</a>
</li>

<li>6 Excellent Free Books to Learn Standard ML<br />
<a href="https://www.linuxlinks.com/excellent-free-books-learn-standard-ml/">https://www.linuxlinks.com/excellent-free-books-learn-standard-ml/</a>
</li>

<li>SOSML: The Online Interpreter for Standard ML<br />
<a href="https://sosml.org/">https://sosml.org/</a>
</li>

<li>ML (Computer program language)<br />
<a href="https://www.barnesandnoble.com/b/books/other-programming-languages/ml-computer-program-language/_/N-29Z8q8Zvy7">https://www.barnesandnoble.com/b/books/other-programming-languages/ml-computer-program-language/_/N-29Z8q8Zvy7</a>
</li>

<li>Strong Typing<br />
<a href="https://perl.plover.com/yak/typing/notes.html">https://perl.plover.com/yak/typing/notes.html</a>
</li>

<li>What to know before debating type systems<br />
<a href="http://blogs.perl.org/users/ovid/2010/08/what-to-know-before-debating-type-systems.html">http://blogs.perl.org/users/ovid/2010/08/what-to-know-before-debating-type-systems.html</a>
</li>

<li>Types, and Why You Should Care (Youtube)<br />
<a href="https://www.youtube.com/watch?v=0arFPIQatCU">https://www.youtube.com/watch?v=0arFPIQatCU</a>
</li>

<li>DynamicTyping (Martin Fowler)<br />
<a href="https://www.martinfowler.com/bliki/DynamicTyping.html">https://www.martinfowler.com/bliki/DynamicTyping.html</a>
</li>

<li>DomainSpecificLanguage (Martin Fowler)<br />
<a href="https://www.martinfowler.com/bliki/DomainSpecificLanguage.html">https://www.martinfowler.com/bliki/DomainSpecificLanguage.html</a>
</li>

<li>Language Workbenches: The Killer-App for Domain Specific Languages?<br />
<a href="https://www.martinfowler.com/articles/languageWorkbench.html">https://www.martinfowler.com/articles/languageWorkbench.html</a>
</li>

<li>Effective ML (Youtube)<br />
<a href="https://www.youtube.com/watch?v=-J8YyfrSwTk">https://www.youtube.com/watch?v=-J8YyfrSwTk</a>
</li>

<li>Why OCaml (Youtube)<br />
<a href="https://www.youtube.com/watch?v=v1CmGbOGb2I">https://www.youtube.com/watch?v=v1CmGbOGb2I</a>
</li>

<li>CSE 341: Functions and patterns<br />
<a href="https://courses.cs.washington.edu/courses/cse341/04wi/lectures/03-ml-functions.html">https://courses.cs.washington.edu/courses/cse341/04wi/lectures/03-ml-functions.html</a>
</li>

<li>Comparing Objective Caml and Standard ML<br />
<a href="http://adam.chlipala.net/mlcomp/">http://adam.chlipala.net/mlcomp/</a>
</li>

<li>What are the key differences between Standard ML and OCaml?<br />
<a href="https://www.quora.com/What-are-the-key-differences-between-Standard-ML-and-OCaml?share=1">https://www.quora.com/What-are-the-key-differences-between-Standard-ML-and-OCaml?share=1</a>
</li>

<li>Cheat Sheets (pro OCaml)<br />
<a href="https://www.ocaml.org/docs/cheat_sheets.html">https://www.ocaml.org/docs/cheat_sheets.html</a>
</li>

<li>Syllabus (FAS CS51)<br />
<a href="https://cs51.io/college/syllabus/">https://cs51.io/college/syllabus/</a>
</li>

<li>Abstraction and Design In Computation<br />
<a href="http://book.cs51.io/">http://book.cs51.io/</a>
</li>

<li>Learn X in Y minutes Where X=Standard ML<br />
<a href="https://learnxinyminutes.com/docs/standard-ml/">https://learnxinyminutes.com/docs/standard-ml/</a>
</li>

<li>CSE307 Online - Summer 2018: Principles of Programing Languages course<br />
<a href="https://www3.cs.stonybrook.edu/~pfodor/courses/summer/cse307.html">https://www3.cs.stonybrook.edu/~pfodor/courses/summer/cse307.html</a>
</li>

<li>CSE307 Principles of Programming Languages course: SML part 1<br />
<a href="https://www.youtube.com/watch?v=p1n0_PsM6hw">https://www.youtube.com/watch?v=p1n0_PsM6hw</a>
</li>

<li>CSE 307 &ndash; Principles of Programming Languages &ndash; SML<br />
<a href="https://www3.cs.stonybrook.edu/~pfodor/courses/summer/CSE307/L01_SML.pdf">https://www3.cs.stonybrook.edu/~pfodor/courses/summer/CSE307/L01_SML.pdf</a>
</li>

<li>SML, Some Basic Examples<br />
<a href="https://cs.fit.edu/~ryan/sml/intro.html">https://cs.fit.edu/~ryan/sml/intro.html</a>
</li>

<li>History of programming languages<br />
<a href="https://devskiller.com/history-of-programming-languages/">https://devskiller.com/history-of-programming-languages/</a>
</li>

<li>History of programming languages (Wikipedia)<br />
<a href="https://en.wikipedia.org/wiki/History_of_programming_languages">https://en.wikipedia.org/wiki/History_of_programming_languages</a>
</li>

<li>Jemný úvod do rozsáhlého světa jazyků LISP a Scheme<br />
<a href="https://www.root.cz/clanky/jemny-uvod-do-rozsahleho-sveta-jazyku-lisp-a-scheme/">https://www.root.cz/clanky/jemny-uvod-do-rozsahleho-sveta-jazyku-lisp-a-scheme/</a>
</li>

<li>The Evolution Of Programming Languages<br />
<a href="https://www.i-programmer.info/news/98-languages/8809-the-evolution-of-programming-languages.html">https://www.i-programmer.info/news/98-languages/8809-the-evolution-of-programming-languages.html</a>
</li>

<li>Evoluce programovacích jazyků<br />
<a href="https://ccrma.stanford.edu/courses/250a-fall-2005/docs/ComputerLanguagesChart.png">https://ccrma.stanford.edu/courses/250a-fall-2005/docs/ComputerLanguagesChart.png</a>
</li>

<li>Poly/ML Homepage<br />
<a href="https://polyml.org/">https://polyml.org/</a>
</li>

<li>PolyConf 16: A brief history of F# / Rachel Reese<br />
<a href="https://www.youtube.com/watch?v=cbDjpi727aY">https://www.youtube.com/watch?v=cbDjpi727aY</a>
</li>

<li>Programovací jazyk Clojure 18: základní techniky optimalizace aplikací<br />
<a href="https://www.root.cz/clanky/programovaci-jazyk-clojure-18-zakladni-techniky-optimalizace-aplikaci/">https://www.root.cz/clanky/programovaci-jazyk-clojure-18-zakladni-techniky-optimalizace-aplikaci/</a>
</li>

</ol>



<p></p><p></p>
<p><small>Autor: <a href="http://www.fit.vutbr.cz/~tisnovpa">Pavel Tišnovský</a> &nbsp; 2022</small></p>
</body>
</html>

<!--
    07:00 - 08:00       21000
    08:00 - 09:00       22000
    09:00 - 10:00       23000
    10:00 - 11:00       24000
    11:00 - 12:00       25000
    12:00 - 13:00       26000
-->
