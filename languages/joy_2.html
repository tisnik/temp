<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
        "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html>
<head>
<title>Joy: programovací jazyk od protino¾cù</title>
<meta name="Author" content="Pavel Tisnovsky" />
<meta name="Generator" content="vim" />
<meta http-equiv="content-type" content="text/html; charset=iso-8859-2" />
<style type="text/css">
         body {color:#000000; background:#ffffff;}
         h1  {font-family: arial, helvetica, sans-serif; color:#ffffff; background-color:#c00000; text-align:center; padding-left:1em}
         h2  {font-family: arial, helvetica, sans-serif; color:#ffffff; background-color:#0000c0; padding-left:1em; text-align:left}
         h3  {font-family: arial, helvetica, sans-serif; color:#000000; background-color:#c0c0c0; padding-left:1em; text-align:left}
         h4  {font-family: arial, helvetica, sans-serif; color:#000000; background-color:#e0e0e0; padding-left:1em; text-align:left}
         a   {font-family: arial, helvetica, sans-serif;}
         li  {font-family: arial, helvetica, sans-serif; color:#000000; text-align:justify; width:450px;}
         ol  {font-family: arial, helvetica, sans-serif; color:#000000; text-align:justify; width:450px;}
         ul  {font-family: arial, helvetica, sans-serif; color:#000000; text-align:justify; width:450px;}
         p   {font-family: arial, helvetica, sans-serif; color:#000000; text-align:justify;}
         pre {background:#e0e0e0}
</style>
</head>

<body>

<h1>Joy: programovací jazyk od protino¾cù</h1>

<h3>Pavel Ti¹novský</h3>

<p></p>

<h1>Úvodník</h1>

<p>Druhá èást èlánku o netradièním programovacím jazyku Joy je zamìøena pøedev¹ím na popis datových typù, se kterými je mo¾né v tomto jazyku pracovat. Také si uká¾eme nìkteré ponìkud netradièní zpùsoby programování, je¾ jsou umo¾nìny syntaxí i sémantikou Joye, tj. postfixovou notací a citací programù.</p>



<h1>Obsah</h1>
<p>
<a href="#k01">1. Základní a agregaèní datové typy podporované v&nbsp;jazyce Joy</a><br />
<a href="#k02">2. Zpracování základních datových typù</a><br />
<a href="#k03">3. Práce se seznamy</a><br />
<a href="#k04">4. Mno¾iny</a><br />
<a href="#k05">5. Znaky a øetìzce</a><br />
<a href="#k06">6. Citace programù a jejich následná evaluace</a><br />
<a href="#k07">7. Vyu¾ití citace programù v&nbsp;praxi</a><br />
<a href="#k08">8. Odkazy na Internetu</a><br />
<a href="#k09">9. Obsah závìreèné èásti èlánku</a><br />

</p>


<p><a name="k01"></a></p>
<h1>1. Základní a agregaèní datové typy podporované v&nbsp;jazyce Joy</h1>

<p>Podobnì jako v&nbsp;mnoha dal¹ích programovacích jazycích, i v&nbsp;jazyce
<i>Joy</i> se odli¹ují základní (primitivní) a agregaèní (kompozitní, slo¾ené
èi strukturované) datové typy. Jazyk <i>Joy</i> sice nepou¾ívá promìnné,
dokonce ani tento termín nezavádí, ale rozli¹uje a dùslednì kontroluje, jaká
hodnota èi hodnoty jsou ulo¾eny na zásobníku &ndash; z&nbsp;tohoto pohledu se
tedy jedná o dynamicky typovaný jazyk, ve kterém je datový typ pøímo pøiøazen
hodnotì ulo¾ené na zásobníku.</p>

<p>Mezi základní, neboli primitivní datové typy patøí pøedev¹ím celá èísla
(<i>integer</i>), znaky (<i>character</i>), pravdivostní hodnoty
<strong>true</strong> a <strong>false</strong> (<i>truth values, boolean</i>) a
nakonec byla do jazyka navíc, tj.&nbsp;oproti pùvodnímu návrhu, pøidána i
podpora pro èíselné hodnoty reprezentované v&nbsp;systému pohyblivé øádové
èárky (<i>float</i>).</p>

<p>Mezi agregaèní datové typy patøí seznam (<i>list</i>), mno¾ina (<i>set</i>)
a øetìzec (<i>string</i>). Kupodivu není pøímo v&nbsp;jazyce zabudován datový
typ asociativní pole èili he¹ovací mapa, ov¹em to jde pomìrnì jednodu¹e
nahradit podle potøeb buï seznamem nebo mno¾inou.</p>

<image id="5547" original="no" />
<p-center>Jeden z&nbsp;prvních kalkulátorù s&nbsp;RPN od firmy HP (HP 9810)</p-center>



<p><a name="k02"></a></p>
<h1>2. Zpracování základních datových typù</h1>

<p>Práce s&nbsp;celými èísly, které mohou mít znaménko a rozsah vìt¹inou od
-2<sup>31</sup>..2<sup>31</sup>-1 (v&nbsp;závislosti na cílové platformì i
vy¹¹í) do znaèné míry reflektuje klasické RPN (<i>Reverse Polish Notation</i>)
kalkulaèky i zásobníkový programovací jazyk <i>Forth</i>. Podle oèekávání jsou
k&nbsp;dispozici základní aritmetické operace pøedstavované postfixovými
funkcemi <strong>+</strong>, <strong>-</strong>, <strong>*</strong> a
<strong>/</strong>.</p>

<p>Navíc je mo¾né spoèítat zbytek po dìlení pomocí funkce <strong>rem</strong>,
absolutní hodnotu funkcí <strong>abs</strong>, zjistit znaménko èi nulovost
èísla pomocí <strong>sign</strong>, otoèit znaménko pøes <strong>neg</strong>,
pou¾ít inkrementaci èi dekrementaci (<strong>succ</strong>,
<strong>pred</strong>) a samozøejmì na dvojici celých èísel aplikovat i bì¾né
relaèní operace typu <strong>&lt;</strong>, <strong>&lt;=</strong>,
<strong>&gt;</strong>, <strong>&gt;=</strong>, <strong>=</strong> èi
<strong>!=</strong>. Nesmíme ov¹em zapomenout na to, ¾e se v¹echny vzorce
zapisují v&nbsp;postfixové notaci:</p>

<code-area>

<i>operátor teèky zajistí tisk èíselné hodnoty</i>
<i>ulo¾ené na vrcholu zásobníku</i>
<strong>1 2 + .</strong>
3

<i>v¹echny operace mají stejnou prioritu</i>
<strong>2 3 4 * + .</strong>
14

<i>obrácení poøadí aplikace operátorù dá</i>
<i>v tomto pøípadì kupodivu :-) stejný výsledek</i>
<strong>2 3 4 + * .</strong>
14

<i>inkrementace</i>
<strong>2 succ 3 succ + .</strong>
7

<i>v¹echny poèetní operace lze</i>
<i>samozøejmì vzájemnì zkombinovat</i>
<strong>5 4 max 3 2 min rem .</strong>
1

<i>za dìlení nulou nám poèítaè skoro</i>
<i>ve v¹ech programovacích jazycích vynadá</i>
<strong>2 1 pred / .</strong>
run time error: non-zero divisor needed for /

<i>vytvoøení a pou¾ití funkce, která souèasnì</i>
<i>vypoète zbytek po dìlení i celoèíselný podíl</i>
<i>a následnì ulo¾í oba výsledky na zásobník</i>
<strong>DEFINE</strong>
<strong>divmod == dup swapd dupd / rotate rem</strong>
<strong>.</strong>

<strong>7 2 divmod ..</strong>
1
3
<strong>6 2 divmod ..</strong>
0
3
<strong>6 3 divmod ..</strong>
0
2
<strong>6 4 divmod ..</strong>
2
1

</code-area>

<p>Práce s&nbsp;pravdivostními hodnotami <strong>true</strong> a
<strong>false</strong> je obdobná, jako v&nbsp;dal¹ích programovacích jazycích.
K&nbsp;dispozici jsou základní logické operace jako <strong>not</strong>,
<strong>and</strong>, <strong>or</strong> èi <strong>xor</strong>, pøièem¾
výsledkem tìchto operací je opìt pravdivostní hodnota, nikoli èíslo 0 èi 1, jak
je tomu napøíklad v&nbsp;céèku. Také výsledek aplikace relaèních operátorù na
èísla èi znaky nabývá pravdivostní hodnoty <strong>true</strong> èi
<strong>false</strong>:</p>

<code-area>

<i>tisk pravdivostní tabulky logické funkce not</i>
<strong>true not .</strong>
false
<strong>false not .</strong>
true

<i>tisk pravdivostní tabulky logické funkce and</i>
<strong>false false and .</strong>
false
<strong>false true and .</strong>
false
<strong>true false and .</strong>
false
<strong>true true and .</strong>
true

<i>tisk pravdivostní tabulky logické funkce or</i>
<strong>false false or .</strong>
false
<strong>false true or .</strong>
true
<strong>true false or .</strong>
true
<strong>true true or .</strong>
true

<i>tisk pravdivostní tabulky logické funkce xor</i>
<strong>false false xor .</strong>
false
<strong>false true xor .</strong>
true
<strong>true false xor .</strong>
true
<strong>true true xor .</strong>
false

<i>kombinovaný logický výraz</i>
<strong>3 2 &gt; 10 5 &lt;= and .</strong>
false

</code-area>

<p>Znaky, pøesnìji øeèeno znakové literály, jsou uvozeny prefixem ' (apostrof)
a práce s&nbsp;nimi je v&nbsp;mnoha ohledech obdobná práci s&nbsp;èíselnými
hodnotami. Ke znaku je mo¾né pøièíst celé èíslo (potom se patøièným zpùsobem
zmìní ASCII kód znaku), znaky je mo¾né porovnávat pomocí relaèních operátorù,
existují funkce pro pøevod znaku na ASCII kód èi naopak pro pøevod ASCII kódu
na znak (<strong>chr</strong>, <strong>ord</strong>) atd. Opìt následují
jednoduché ukázky:</p>

<code-area>

<strong>'a .</strong>
'a
<strong>'a 10 + .</strong>
'k
<strong>'a ord .</strong>
97
<strong>64 chr .</strong>
'@
<strong>65 chr .</strong>
'A
<strong>65 32 + chr .</strong>
'a
<strong>'a 'b &lt; .</strong>
true
<strong>'z 'b &lt; .</strong>
false

</code-area>



<p><a name="k03"></a></p>
<h1>3. Práce se seznamy</h1>

<p>Jedním z&nbsp;agregaèních (nìkdy také nazývaných kompozitních) datových
typù, se kterými programovací jazyk <i>Joy</i> nativnì pracuje, jsou seznamy.
Zde je patrná souvislost s&nbsp;vìt¹inou zavedených funkcionálních jazykù, ve
kterých se práce se seznamy velmi èasto objevuje jako jedna ze základních
podporovaných operací. Pøíkladem mù¾e být <i>Lisp</i>, ve kterém je seznam
reprezentován speciálnì zkonstruovaným øetìzcem na sebe navazujících
<i>teèka-dvojic</i> (na nejni¾¹í úrovni tedy <i>Lisp</i> nepracuje se seznamy
ale právì s&nbsp;teèka-dvojicemi). V&nbsp;programovacím jazyce <i>Joy</i> jsou
polo¾ky nacházející se v&nbsp;seznamech zapisované do hranatých závorek,
pøièem¾ oddìlovaèem je libovolný bílý znak. Seznamy mohou být i prázdné (takový
seznam se potom zapisuje pouze jako dvojice hranatých závorek bez hodnot mezi
tìmito závorkami), èi mohou naopak obsahovat dal¹í podseznamy &ndash; to je
mimochodem jeden z&nbsp;pøíkladù datové rekurze.</p>

<p>Seznamy je mo¾né vytváøet (konstruovat) pomocí funkce <strong>cons</strong>.
V&nbsp;pøípadì pou¾ití této funkce musí být na vrcholu zásobníku umístìn seznam
a na druhém místì pak hodnota do seznamu pøidávaná (klidnì se mù¾e jednat o
dal¹í seznam). Pokud je program napsán tak, ¾e jsou polo¾ky na zásobníku
prohozeny, tj.&nbsp;na vrcholu je ulo¾ena pøidávaná hodnota (co¾ je docela
obvyklý pøípad), lze místo funkce <strong>cons</strong> pou¾ít funkci nazvanou
<strong>swons</strong>, která je vlastnì kompozicí funkcí <strong>swap</strong>
a <strong>cons</strong>. Pro pøístup k&nbsp;první polo¾ce ("hlavì",
<i>head</i>) resp.&nbsp;zbytku seznamu ("ocasu", <i>tail</i>) se pou¾ívají
funkce <strong>first</strong> a <strong>rest</strong> (<i>Lispaøi</i>
v&nbsp;nich jistì poznali slavné <strong>car</strong> a <strong>cdr</strong>).
Pokroèilej¹í práci se seznamy si uvedeme v&nbsp;dal¹ím textu, zde pouze pro
ukázku uvedu nìkolik základních operací a jejich výsledkù:</p>

<code-area>

<i>získání prvního prvku seznamu (head) a jeho výpis</i>
<strong>[1 2 3 4] first .</strong>
1

<i>získání seznamu bez prvního prvku (tail) a jeho výpis</i>
<strong>[1 2 3 4] rest .</strong>
[2 3 4]

<i>nad prázdným seznamem není mo¾né pou¾ít funkci first</i>
<strong>[] first .</strong>
run time error: non-empty list needed for first

<i>ani funkci rest</i>
<strong>[] rest .</strong>
run time error: non-empty list needed for rest

<i>ov¹em funkce rest mù¾e naopak vrátit prázdný seznam</i>
<strong>[1] rest.</strong>
[]

<i>tro¹ku slo¾itìj¹í kompozice funkcí</i>
<i>nad seznamem obsahujícím podseznam</i>
<strong>[1 [2 3] 4] rest first .</strong>
[2 3]

<i>vytvoøení seznamu &ndash; pøidání</i>
<i>prvku do stávajícího seznamu</i>
<strong>1 [2] cons .</strong>
[1 2]

<i>v¾dy je nutné pøidávat polo¾ky do seznamu,</i>
<i>i kdy¾ ten mù¾e být zpoèátku prázdný</i>
<i>(nelze spojit dva prvky, ale v¾dy prvek a seznam)</i>
<strong>1 2 3 4 [] cons cons cons cons .</strong>
[1 2 3 4]

<i>pøíklad pou¾ití funkce swons</i>
<strong>[] 1 swons .</strong>
[1]

<i>ukázka rozdílu mezi funkcemi cons a swons</i>
<strong>[1 2] [3 4] cons .</strong>
[[1 2] 3 4]
<strong>[1 2] [3 4] swons .</strong>
[[3 4] 1 2]

</code-area>

<p>Ve standardní knihovnì programovacího jazyka <i>Joy</i> jsou dostupné i
dal¹í funkce, které je mo¾né pou¾ít pro práci se seznamy. Jejich význam bude
patrný z&nbsp;ní¾e uvedených demonstraèních pøíkladù.</p>

<h2>Pøístup k&nbsp;obsahu seznamu:</h2>

<code-area>

<i>funkce "at" slou¾í k pøístupu k polo¾kám seznamù</i>
<strong>[10 20 30 40] 0 at .</strong>
10

<strong>[10 20 30 40] 1 at .</strong>
20

<i>èíslování polo¾ek zaèíná od nuly,</i>
<i>tj. nejvy¹¹í index je v tomto pøípadì roven 3</i>
<strong>[10 20 30 40] 4 at .</strong>
run time error: smaller index needed for at

<i>záporné indexy nelze pou¾ít (na rozdíl od Pythonu)</i>
<strong>[10 20 30 40] -1 at .</strong>
run time error: non-negative integer needed for at

<i>funkce "of" pracuje s opaèným poøadím</i>
<i>operandù ne¾ funkce "at"</i>
<strong>0 [10 20 30 40] of .</strong>
10

<strong>1 [10 20 30 40] of .</strong>
20

<strong>4 [10 20 30 40] of .</strong>
run time error: smaller index needed for of

</code-area>

<h2>Odstraòování polo¾ek ze seznamù:</h2>

<code-area>

<i>odstranìní celého seznamu ze zásobníku</i>
<strong>[1 2 3] pop .</strong>
_

<i>rozdìlení seznamu na první prvek</i>
<i>a zbytek (opak konstrukce seznamu)</i>
<strong>[1 2 3] uncons ..</strong>
[2 3]
1

<i>opak operace "swons"</i>
<strong>[1 2 3] unswons ..</strong>
1
[2 3]

<i>odstranìní prvních N polo¾ek ze seznamu</i>
<strong>[1 2 3 4] 2 drop .</strong>
[3 4]
<strong>[1 2 3 4] 0 drop .</strong>
[1 2 3 4]
<strong>[1 2 3 4] 1000 drop .</strong>
[]

<i>odstranìní polo¾ek od N-tého indexu</i>
<strong>[1 2 3 4] 2 take .</strong>
[1 2]
<strong>[1 2 3 4] 0 take .</strong>
[]
<strong>[1 2 3 4] 1000 take .</strong>
[1 2 3 4]

</code-area>

<h2>Dal¹í operace se seznamy:</h2>

<code-area>

<i>zji¹tìní délky seznamu (s jeho</i>
<i>odstranìním ze zásobníku)</i>
<strong>[1 2 3] size .</strong>
3

<i>zji¹tìní délky bez odstranìní</i>
<i>vlastního seznamu ze zásobníku</i>
<strong>[1 2 3] dup size ..</strong>
3
[1 2 3]

<i>polo¾ky seznamu je mo¾né ulo¾it</i>
<i>jednu po druhé na zásobník</i>
<strong>[1 2 3] unstack .</strong>
1
2
3

<i>spojení dvou seznamù</i>
<i>(rozdílné chování oproti cons!)</i>
<strong>[1 2 3] [4 5 6] concat .</strong>
[1 2 3 4 5 6]
<strong>[1 2 3] [4 5 6] cons .</strong>
[[1 2 3] 4 5 6]

</code-area>

<image id="5548" />
<p-center>Kalkulátor s&nbsp;RPN z&nbsp;roku 1968 (HP 9100)</p-center>



<p><a name="k04"></a></p>
<h1>4. Mno¾iny</h1>

<p>Agregaèní datový typ mno¾ina (<i>set</i>) je v&nbsp;mnoha ohledech zajímavý,
u¾ jen z&nbsp;toho dùvodu, ¾e mnohé programovací jazyky tento typ ani
neimplementují, co¾ je ¹koda, proto¾e by se hodil v&nbsp;mnoha algoritmech.
Mno¾ina je vytváøena podobnì jako seznam, ale místo hranatých závorek
umístìných okolo hodnot, se pou¾ívají závorky slo¾ené, tj.&nbsp;znaky
<strong>{</strong> a <strong>}</strong>. Mno¾ina mù¾e být &ndash; podobnì jako
seznam &ndash; prázdná, potom je pou¾ito prázdných závorek.</p>

<p>Do mno¾in je mo¾né ukládat jak celoèíselné hodnoty, tak i znaky, které jsou
v¹ak pøed ulo¾ením do interní reprezentace mno¾iny pøevedeny na své ASCII
hodnoty. V&nbsp;programovacím jazyce <i>Joy</i> je maximální velikost mno¾iny,
tj.&nbsp;poèet prvkù, shora omezen, typicky na hodnotu 32 (to odpovídá
implementaci mno¾iny v&nbsp;jednom 32bitovém registru procesoru). Ov¹em toto
omezení maximálního poètu prvkù má vliv i na zpùsob výpoètu èíselné hodnoty
v&nbsp;pøípadì, ¾e se do mno¾iny vkládají znaky &ndash; jejich ASCII hodnota je
bitovì maskována tak, aby výsledek le¾el v&nbsp;rozsahu 0..31.</p>

<p>Nad mno¾inami je mo¾né provádìt základní mno¾inové operace,
tj.&nbsp;sjednocení (funkce <strong>or</strong>), prùnik (funkce
<strong>and</strong>), symetrický rozdíl dvou mno¾in (funkce
<strong>xor</strong>) a výpoèet doplòku mno¾in (funkce <strong>not</strong>)
vùèi "jednotkové" mno¾inì, která obsahuje v¹ech 32 prvkù. V¹imnìte si, ¾e názvy
mno¾inových funkcí jsou stejné, jako u funkcí pracujících s&nbsp;logickými
hodnotami, jedná se tedy o jakousi podobu pøetí¾ených operátorù známých
z&nbsp;jiných programovacích jazykù. Toto chování je umo¾nìno pomocí takzvaných
<i>predikátù</i>, jejich¾ zavoláním je mo¾né zjistit, jaké datové typy mají
hodnoty ulo¾ené na zásobníku.</p>

<p>Prvky nemusí být pøi vkládání do mno¾iny seøazeny (na poøadí tedy nezále¾í,
jako u skuteèných mno¾in) a samozøejmì je dovoleno i vkládání duplikátù.
Výsledná mno¾ina je pøi tisku setøídìna (opìt to vyplývá z&nbsp;interního
zpùsobu práce s&nbsp;mno¾inami) a duplikáty nejsou vypsány. Následuje nìkolik
okomentovaných pøíkladù, na kterých je práce s&nbsp;mno¾inami ozøejmena:</p>

<code-area>

<i>sjednocení dvou tøíprvkových mno¾in</i>
<strong>{1 2 3} {3 4 5} or .</strong>
{1 2 3 4 5}

<i>prùnik dvou tøíprvkových mno¾in</i>
<strong>{1 2 3} {3 4 5} and .</strong>
{3}

<i>symetrický rozdíl dvou mno¾in</i>
<i>(ve výsledné mno¾inì zùstanou pouze prvky,</i>
<i>které NEle¾í v obou mno¾inách)</i>
<strong>{1 2 3} {3 4 5} xor .</strong>
{1 2 4 5}

<i>výsledkem nìkterých mno¾inových operací</i>
<i>mù¾e být prázdná mno¾ina</i>
<strong>{1} {2} and .</strong>
{}

<i>doplnìk mno¾iny vùèi "jednotkové"</i>
<i>mno¾inì s 32 prvky</i>
<strong>{0 1 2 3 4 5 6 7 8 9 10} not .</strong>
{11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31}

<i>prvky mno¾in jsou v¾dy ti¹tìny setøídìné</i>
<strong>{9 8 7 6 5 4 3 2 1} .</strong>
{1 2 3 4 5 6 7 8 9}

<i>znaky jsou pøed vlo¾ením do mno¾iny</i>
<i>pøevedeny na své ASCII kódy</i>
<strong>{'a 'b 'c 'd} .</strong>
{1 2 3 4}

<i>pøevod znakù na ASCII kódy funguje</i>
<i>i pøi mno¾inových operacích</i>
<strong>{'a 'b 'c 'd} {'b 'c 'd 'e} and .</strong>
{2 3 4}

<i>nìkteré rozdílné znakové literály</i>
<i>a èíselné hodnoty pøedstavují jako</i>
<i>prvek mno¾in ve skuteènosti duplikáty</i>
<strong>{1 'a 'A}.</strong>
{1}

</code-area>



<p><a name="k05"></a></p>
<h1>5. Znaky a øetìzce</h1>

<p>Práci se znaky jsme si popsali v&nbsp;první kapitole vìnované práci se
základními (primitivními) datovými typy. Podobnì jako v&nbsp;dal¹ích
programovacích jazycích, i v&nbsp;jazyku <i>Joy</i> je umo¾nìno zpracování
øetìzcù, pøièem¾ øetìzce jsou chápány tradiènì jako sekvence znakù. Zatímco
jednotlivé znakové literály jsou uvozeny pouze prefixem <strong>'</strong>
(apostrof), u øetìzcù musí být zadány uvozovky, a to jak pøed jeho zaèátkem,
tak i za jeho koncem. Je to ostatnì logické, proto¾e zatímco délka jednoho
znaku je v¾dy konstantní a pøedem známá, je do øetìzcù nutné zapisovat i
takzvané bílé znaky, tj.&nbsp;mezery a tabulátory. Prázdný øetìzec,
tj.&nbsp;øetìzec o délce nula znakù, ze zapisuje tak, jak je to obvyklé
v&nbsp;dal¹ích programovacích jazycích: pomocí dvojice uvozovek. Pro práci
s&nbsp;øetìzci existuje nìkolik zabudovaných i knihovních funkcí, z&nbsp;nich¾
nìkteré jsou uvedeny v&nbsp;následujících demonstraèních pøíkladech:</p>

<code-area>

<i>ulo¾ení øetìzce na zásobník s jeho</i>
<i>výpisem a odstranìním</i>
<strong>"hello Joy" .</strong>
"hello Joy"

<i>výpis øetìzce bez uvozovek pomocí</i>
<i>funkce putchars</i>
<strong>"Hello world" putchars .</strong>
Hello world

<i>spojení dvou øetìzcù pomocí operátoru concat</i>
<strong>"hello " "world" concat .</strong>
"hello world"

<i>pøevod èísla ulo¾eného v øetìzci na skuteènou</i>
<i>numerickou hodnotu se specifikací báze (soustavy)</i>
<strong>"1234" 8 strtol .</strong>
668

<i>pokud je èíselná soustava nulová, pokusí se</i>
<i>funkce strtol sama zjistit základ</i>
<strong>"1234" 0 strtol .</strong>
1234

<i>jako základ je v tomto pøípadì zvolena ¹estnáctka</i>
<strong>"0x1234" 0 strtol .</strong>
4660
<strong>"0xffff" 0 strtol .</strong>
65535

<i>nyní naopak osmièka (céèkovská konvence)</i>
<strong>"0100" 0 strtol .</strong>
64

<i>pøevod øetìzce obsahujícího desetinné èíslo</i>
<i>na skuteènou hodnotu typu float</i>
<strong>"52.5" strtod .</strong>
52.5

</code-area>

<p>Øetìzce tvoøí plnohodnotný datový typ, to znamená, ¾e je mo¾né ukládat
øetìzce do seznamù, zapisovat øetìzce do souborù èi je naopak ze souborù
naèítat apod. Naopak øetìzec jako celek je mo¾né pokládat za seznam a
pøistupovat k&nbsp;jeho jednotlivým polo¾kám nebo podøetìzcùm pomocí funkcí
pracujících se seznamy. V&nbsp;dal¹ích pøíkladech jsou ukázány nìkteré èasto
pou¾ívané operace, které se s&nbsp;øetìzci mohou provádìt:</p>

<code-area>

<i>øetìzce je mo¾né vlo¾it do seznamu</i>
<strong>"Hello" "world" [] cons cons .</strong>
["Hello" "world"]

<i>naètení øetìzce (jednoho øádku)</i>
<i>ze standardního vstupu</i>
<strong>stdin fgets .</strong>
vypí¹e se zadaný vstup

<i>získání prvního znaku v øetìzci</i>
<strong>"Hello" first</strong>
'H

<i>získání podøetìzce bez prvního znaku</i>
<strong>"Hello" rest .</strong>
"ello"

<i>pøístup k jednotlivým znakùm pomocí operátoru at</i>
<strong>"Hello" 3 at .</strong>
'l

<i>pøístup k jednotlivým znakùm pomocí operátoru of</i>
<strong>4 "Hello" of .</strong>
'o

<i>lexikografické porovnání dvou øetìzcù</i>
<strong>"abc" "zzz" &lt; .</strong>
true

<i>lexikografické porovnání dvou øetìzcù</i>
<strong>"abc" "ABC" &lt; .</strong>
false

</code-area>

<image id="5549" />
<p-center>Dal¹í kalkulaèka s&nbsp;RPN, tentokrát vyrobená v&nbsp;SSSR (B3-19M)</p-center>



<p><a name="k06"></a></p>
<h1>6. Citace programù a jejich následná evaluace</h1>

<p><i>Joy</i> se podobá programovacímu jazyku <i>Lisp</i> èi <i>Scheme</i> nebo
i <i>Logu</i> tím, ¾e striktnì nerozli¹uje mezi programem a daty. Stejnì jako
v&nbsp;<i>Lispu</i> je program pova¾ován za seznam pøíkazù, tj.&nbsp;volání
funkcí èi kombinátorù. To samozøejmì pøedstavuje velmi silnou zbraò tohoto
jazyka, proto¾e programy nebo jejich èásti lze s&nbsp;vyu¾itím v¹ech funkcí a
kombinátorù vytváøet nebo modifikovat (tyto operace probíhají na zásobníku,
ostatnì jako v¹echny výpoèty). Zdaleka nejbì¾nìj¹ím idiomem je <i>citace
programù</i>, která spoèívá v&nbsp;tom, ¾e je program zapsán na zásobník jako
bì¾ný seznam, tj.&nbsp;s&nbsp;vyu¾itím hranatých závorek a posléze je tento
program buï pøímo spu¹tìn nebo pou¾it v&nbsp;dal¹ích operacích, napøíklad
podmínìných výrazech, smyèkách èi náhradì rekurze pomocí rekurzivních
manipulátorù.</p>

<p>Nejjednodu¹¹í mo¾ností, jak s&nbsp;èástí programu zapsanou v&nbsp;seznamu
pracovat, je jeho spu¹tìní. To lze provést pomocí operátoru <strong>i</strong>
(<i>interpret</i>), který svým pou¾itím odpovídá pøíkazu <strong>eval</strong>
známého z&nbsp;jiných programovacích jazykù. Uka¾me si jednoduchý pøíklad:</p>

<code-area>

<strong>[1 2 + 3 * print] i</strong>
<strong>.</strong>
9

</code-area>

<p>Nejprve je zapsán blok kódu do hranatých závorek, tj.&nbsp;jedná se o bì¾ný
seznam, se kterým interpreter jazyka <i>Joy</i> nic dal¹ího neprovádí, pouze
tento seznam ulo¾í na vrchol zásobníku. Poté je v¹ak zavolán operátor
<strong>i</strong>, který ze zásobníku vyjme seznam (pokud se tam samozøejmì
nachází, jinak by se jednalo o bìhovou chybu) a pokusí se tento seznam
<i>interpretovat</i>, tj.&nbsp;postupnì spou¹tìt jeho jednotlivé polo¾ky.
Vzhledem k&nbsp;tomu, ¾e je v&nbsp;seznamu opravdu ulo¾en validní programový
kód (konkrétnì sekvence operací <strong>push</strong>, souèet, násobení a tisk
hodnoty ulo¾ené na vrcholu zásobníku), je tento program interpretován a pomocí
operátoru teèky se mù¾eme pøesvìdèit, ¾e se výpoèet skuteènì provedl
korektnì.</p>

<p>O tom, ¾e se s&nbsp;vý¹e zapsaným programem-seznamem dá pracovat i
s&nbsp;pomocí funkcí pro zpracování seznamu, svìdèí napøíklad následující
úryvek kódu, ve kterém se spoète délka seznamu, posléze se získá jeho tøetí a¾
¹estý prvek a nakonec jeho prvek poslední:</p>

<code-area>

<i>na zásobník ulo¾íme seznam stejný,</i>
<i>jako v pøedchozím pøíkladu</i>
<strong>[1 2 + 3 * print]</strong>

<i>vypí¹eme délku tohoto seznamu</i>
<i>(duplikace zabrání odstranìní seznamu</i>
<i>ze zásobníku, proto¾e seznam budeme</i>
<i>vyu¾ívat v dal¹ích operacích)</i>
<strong>dup size .</strong>
6

<i>získáme tøetí a¾ ¹estý prvek seznamu</i>
<i>(opìt je nutná duplikace)</i>
<strong>rest rest dup .</strong>
[+ 3 * print]

<i>nakonec získáme poslední prvek seznamu</i>
<strong>rest rest rest first .</strong>
print

<i>a pøesvìdèíme se, ¾e zásobník skuteènì</i>
<i>zùstal prázdný</i>
<strong>.</strong>
_

</code-area>


<p><a name="k07"></a></p>
<h1>7. Vyu¾ití citace programù v&nbsp;praxi</h1>

<p>Citace programù se velmi èasto pou¾ívá v&nbsp;praxi. Typickým pøíkladem
pou¾ití je náhrada podmínìného pøíkazu (který <i>Joy</i> jako zvlá¹tní
syntaktickou kategorii ani nezná) za operátor nazvaný <strong>ifte</strong>
(<i>if-then-else</i>). Tento operátor oèekává na zásobníku tøi citované
programy &ndash; první je spu¹tìn (vyhodnocen) ihned po zavolání operátoru
<strong>ifte</strong> a podle výsledku vyhodnocení <i>true/false</i> se buï
spustí druhý citovaný program nebo naopak tøetí citovaný program. Po probìhnutí
operátoru <strong>ifte</strong> jsou v¹echny tøi citované programy ze zásobníku
odstranìny:</p>

<code-area>

<i>jednoduché rozvìtvení na základì podmínky</i>
<strong>[1 2 &lt;] ["je mensi"] ["je vetsi"] ifte .</strong>
"je mensi"

<i>nastavíme poèáteèní podmínky tak,</i>
<i>aby se podmínka negovala</i>
<strong>[1 -2 &lt;] ["je mensi"] ["je vetsi"] ifte .</strong>
"je vetsi"

<i>test, zda hodnota ulo¾ená na vrcholu zásobníku</i>
<i>le¾í v rozsahu (0, 10)</i>
<strong>5 [dup 0 &gt; swap 10 &lt; and] [100 *] ["chyba rozsahu"] ifte .</strong>
500

<strong>50 [dup 0 &gt; swap 10 &lt; and] [100 *] ["chyba rozsahu"] ifte .</strong>
"chyba rozsahu"

<strong>0 [dup 0 &gt; swap 10 &lt; and] [100 *] ["chyba rozsahu"] ifte .</strong>
"chyba rozsahu"

<i>vytvoøení funkce pro výpoèet hyperbolického</i>
<i>prùbìhu s testem na nulový parametr</i>
<strong>DEFINE</strong>
<strong>hyperbola == [dup 0 =] [0] [1000 swap /] ifte</strong>
<strong>.</strong>

<i>test novì nadefinované funkce hyperbola</i>
<strong>1 hyperbola .</strong>
1000

<strong>2 hyperbola .</strong>
500

<strong>3 hyperbola .</strong>
333

<strong>10 hyperbola .</strong>
100

<i>nyní zkusíme zadat testovaný parametr 0</i>
<strong>0 hyperbola .</strong>
0

</code-area>

<p>Citaci programù si uká¾eme i v&nbsp;poslední èásti tohoto èlánku, proto¾e i
u rekurzivních kombinátorù se citace velmi èasto pou¾ívá, a» u¾ pro zadání
výrazu volaného pro test, zda se má rekurze ukonèit, èi pro zápis vlastního
rekurzivnì volaného tìla funkce. Pøíkladem jednoduchého kombinátoru mù¾e být
rekurzivní kombinátor <strong>while</strong>, který svým pou¾itím simuluje
klasickou smyèku typu <i>while</i> známou z&nbsp;imperativních programovacích
jazykù:</p>

<code-area>

<i>    podmínka  tìlo funkce    volání kombinátoru</i>
<strong>10   [0 &gt;]   [dup put 1 -]   while .</strong>
10 9 8 7 6 5 4 3 2 1 0
<i>(poslední hodnota není vypsána smyèkou, ale operátorem .)</i>

<i>jednodu¹¹í zpùsob vyu¾ívající operátoru pred</i>
<strong>10   [0 &gt;]   [dup put pred]  while .</strong>
10 9 8 7 6 5 4 3 2 1 0
<i>(poslední hodnota není vypsána smyèkou, ale operátorem .)</i>

</code-area>

<image id="5550" />
<p-center>V&nbsp;SSSR se vyrábìlo nìkolik typù RPN kalkulaèek (B3-21)<br />
(zajímavé je, ¾e nìkteré klávesy jsou psané latinkou a dal¹í azbukou)</p-center>



<p><a name="k08"></a></p>
<h1>8. Odkazy na Internetu</h1>

<ul>

<li>Domácí stránka programovacího jazyka Joy:<br />
<a href="http://www.latrobe.edu.au/philosophy/phimvt/joy.html">http://www.latrobe.edu.au/philosophy/phimvt/joy.html</a>
</li>

<li>Tutorial on Joy:<br />
<a href="http://www.latrobe.edu.au/philosophy/phimvt/joy/j01tut.html">http://www.latrobe.edu.au/philosophy/phimvt/joy/j01tut.html</a>
</li>

<li>Programming in Joy:<br />
<a href="http://www.latrobe.edu.au/philosophy/phimvt/joy/j06prg.html">http://www.latrobe.edu.au/philosophy/phimvt/joy/j06prg.html</a>
</li>

<li>Synopsis of the language:<br />
<a href="http://www.latrobe.edu.au/philosophy/phimvt/joy/synops.html">http://www.latrobe.edu.au/philosophy/phimvt/joy/synops.html</a>
</li>

<li>Frequently Asked Questions about Joy:<br />
<a href="http://www.latrobe.edu.au/philosophy/phimvt/joy/faq.html">http://www.latrobe.edu.au/philosophy/phimvt/joy/faq.html</a>
</li>

<li>Factor (programming language):<br />
<a href="http://en.wikipedia.org/wiki/Factor_(programming_language)">http://en.wikipedia.org/wiki/Factor_(programming_language)</a>
</li>

<li>Wikipedia EN: Joy (programming language):<br />
<a href="http://en.wikipedia.org/wiki/Joy_(programming_language)">http://en.wikipedia.org/wiki/Joy_(programming_language)</a>
</li>

</ul>

<image id="5551" original="no" />
<p-center>I zde je patrná inspirace designem kalkulaèek HP (MK-52, podobná HP-42)</p-center>



<p><a name="k09"></a></p>
<h1>9. Obsah závìreèné èásti èlánku</h1>

<p>Ústøedním tématem tøetí a souèasnì i poslední èásti èlánku o netradièním
programovacím jazyce <i>Joy</i> bude podrobnìj¹í vysvìtlení rekurzivních
kombinátorù. Teoretická èást bude samozøejmì doplnìna i mnoha demonstraèními
pøíklady, vèetnì nerekurzivních variant pùvodnì rekurzivnì napsaných
algoritmù.</p>



<p></p><p></p>
<p><small>Autor: <a href="http://www.fit.vutbr.cz/~tisnovpa">Pavel Ti¹novský</a> &nbsp; 2008</small></p>
</body>
</html>

