<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
        "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html>
<head>
<title>ML - funkcionální jazyk s revolučním typovým systémem</title>
<meta name="Author" content="Pavel Tisnovsky" />
<meta name="Generator" content="vim" />
<meta http-equiv="content-type" content="text/html; charset=utf-8" />
<style type="text/css">
         body {color:#000000; background:#ffffff;}
         h1  {font-family: arial, helvetica, sans-serif; color:#ffffff; background-color:#c00000; text-align:center; padding-left:1em}
         h2  {font-family: arial, helvetica, sans-serif; color:#ffffff; background-color:#0000c0; padding-left:1em; text-align:left}
         h3  {font-family: arial, helvetica, sans-serif; color:#000000; background-color:#c0c0c0; padding-left:1em; text-align:left}
         h4  {font-family: arial, helvetica, sans-serif; color:#000000; background-color:#e0e0e0; padding-left:1em; text-align:left}
         a   {font-family: arial, helvetica, sans-serif;}
         li  {font-family: arial, helvetica, sans-serif; color:#000000; text-align:justify; width:450px;}
         ol  {font-family: arial, helvetica, sans-serif; color:#000000; text-align:justify; width:450px;}
         ul  {font-family: arial, helvetica, sans-serif; color:#000000; text-align:justify; width:450px;}
         p   {font-family: arial, helvetica, sans-serif; color:#000000; text-align:justify;}
         pre {background:#e0e0e0}
</style>
</head>

<body>

<h1>ML - funkcionální jazyk s revolučním typovým systémem</h1>

<h3>Pavel Tišnovský</h3>

<p></p>

<h1>Úvodník</h1>

<p>Před neuvěřitelnými 49 lety vznikl první koncept jazyka ML. Jedná se o programovací jazyk, který byl v mnoha ohledech přelomový, a to díky svému typovému systému, jenž byl zkombinovaný s pattern matchingem. Jazykem ML se inspiroval nejenom jazyk OCaml, ale taktéž programovací jazyk F#.</p>



<h2>Obsah</h2>

<p><a href="#k01">*** 1. ML &ndash; funkcionální jazyk s&nbsp;revolučním typovým systémem</a></p>
<p><a href="#k02">2. Vznik jazyka Standard ML</a></p>
<p><a href="#k03">3. Od Standard ML k&nbsp;jazykům Caml, OCaml a F#</a></p>
<p><a href="#k04">4. Online varianta jazyka Standard ML</a></p>
<p><a href="#k05">5. Instalace Standard ML z&nbsp;nabízených balíčků</a></p>
<p><a href="#k06">6. Instalace Standard ML ze zdrojových kódů</a></p>
<p><a href="#k07">7. Komentáře</a></p>
<p><a href="#k08">8. Výrazy v&nbsp;jazyku ML</a></p>
<p><a href="#k09">9. Proměnné</a></p>
<p><a href="#k10">10. Základní datové typy jazyka ML</a></p>
<p><a href="#k11">11. Složené datové typy: n-tice a záznamy</a></p>
<p><a href="#k12">12. Seznamy</a></p>
<p><a href="#k13">13. Funkce</a></p>
<p><a href="#k14">14. Rekurzivní funkce</a></p>
<p><a href="#k15">15. Anonymní funkce</a></p>
<p><a href="#k16">16. Pattern matching</a></p>
<p><a href="#k17">17. Obsah druhé části článku</a></p>
<p><a href="#k18">18. Repositář s&nbsp;demonstračními příklady</a></p>
<p><a href="#k19">19. Literatura</a></p>
<p><a href="#k20">20. Odkazy na Internetu</a></p>



<p><a name="k01"></a></p>
<h2 id="k01">1. ML &ndash; funkcionální jazyk s&nbsp;revolučním typovým systémem</h2>

<p>V&nbsp;dnešním článku se seznámíme se základními vlastnostmi programovacího
jazyka <i>ML</i> neboli <i>Meta Language</i>. Jedná se o funkcionální a
modulární jazyk se silným (statickým) typovým systémem a pattern matchingem,
jehož počátky můžeme datovat až do roku 1972. Později byl tento jazyk formálně
specifikován (je tedy popsán specifikací a nikoli referenční implementací) a
začal se nazývat <i>Standard ML</i> popř.&nbsp;zkráceně pouze <i>SML</i>. ML je
zajímavý sám o sobě, ovšem nejenom to &ndash; inspiroval totiž autory celé řady
dalších programovacích jazyků, ať již se to týká přímých následovníků
<i>Caml</i> a <i>OCaml</i> či jazyků, které byly ML silně inspirovány:
<i>F#</i>, <i>Haskell</i>, <i>Scala</i> a v&nbsp;neposlední řadě <i>Rust</i> a
částečně i <i>Go</i>.</p>

<p><div class="rs-tip-major">Poznámka: </div></p>

samotný standard resp. specifikace relativně krátká v porovnání s tím o jak mocný jazyk se jedná

vždy rozhodování mezi svobodou zápisu a potenciálními problémy nebo např.
striktním vyžadováním case analysis atd.

typove informace = part of design process
sweet stop - typovy system, ovsem kratky zapis programu (v porovnani s
tradicnimi staticky typovanymi jazyky)

<p>O typovém systému jazyka <i>ML</i> (a od něj odvozeného <i>OCamlu</i>) se často říká, že se jeho tvůrcům podařilo najít takové řešení, které umožňuje krátký a výstižný zápis algoritmů (což je doménou dynamicky typovaných jazyků), ovšem současně se podařilo zajistit typovou bezpečnost, a to v&nbsp;mnoha případech vyšší, než jaká je očekávána od tradičních staticky typovaných jazyků. Příklady si ukážeme níže a bude z&nbsp;nich patrné, že většina algoritmů implementovaných v&nbsp;<i>ML</i> skutečně nikde neobsahuje explicitně zapsané typové informace &ndash; ty jsou totiž odvozeny ze samotného algoritmu.</p>

<p><div class="rs-tip-major">Poznámka: <i>type inference</i> se začalo prosazovat i v&nbsp;dalších programovacích jazycích, i když někdy jen v&nbsp;omezené míře. Například v&nbsp;jazyku Go lze deklarovat proměnnou pouze uvedením jejího jména a hodnoty, přičemž typ proměnné je odvozen od hodnoty. I taková zdánlivá maličkost ovšem &bdquo;pocitově&ldquo; (styl zápisu, rychlost tvorby nového kódu) jazyk Go posouvá do takové míry, že mi několik vývojářů řeklo &bdquo;ten jazyk je nakonec vlastně hodně podobný Pythonu&ldquo;.</div></p>

20 let kariery, takze prvni tydny ni neznamenaji

inference - odvozování
algebraické datové typy



<p><a name="k02"></a></p>
<h2 id="k02">2. Vznik jazyka Standard ML</h2>

<p>Jazyk ML vznikl v&nbsp;univerzitním prostředí ve Velké Británii, takže se
jedná o další oblast, v&nbsp;níž vznikl nějaký důležitý koncept v&nbsp;oblasti
teorie programovacích jazyků (mezi další takové &bdquo;líhně&ldquo; patřily
pochopitelně USA s&nbsp;MIT, Bell Labs, IBM a taktéž kontinentální Evropa
s&nbsp;Prologem a pascalskou větví programovacích jazyků). První kroky vedoucí
později ke vzniku ML provedla na začátku sedmdesátých let minulého století
skupina vědců z&nbsp;laboratoře pro výzkum umělé inteligence z&nbsp;univerzity
v&nbsp;Edinburgu. Jak bylo v&nbsp;té době v&nbsp;oblasti AI prakticky nepsaným
standardem, používal se převážně <a
href="https://www.root.cz/clanky/jemny-uvod-do-rozsahleho-sveta-jazyku-lisp-a-scheme/">programovací
jazyk LISP</a>, který byl ovšem doplněný o Prolog, což byla tehdy žhavá
novinka, protože Prolog vznikl v&nbsp;roce 1972.</p>

<p><div class="rs-tip-major">Poznámka: traduje se sice rivalita panující mezi
výzkumnými skupinami používajícími LISP se skupinami používajícími Prolog, ale
zde je vidět, že je možné využít možností obou konceptuálně odlišných
jazyků.</div></p>

<p>Výše zmíněná skupina pro oblast umělé inteligence pracovala na vývoji
systému <i>LCF</i> (<i>Logic For Computable Functions</i>), jenž byl určen pro
dokazování teorémů. Tento systém byl naprogramován v&nbsp;LISPu. Poněkud
předbíháme, ale na tomto místě je vhodné poznamenat, že ideové stopy LISPu jsou
v&nbsp;jazyku ML poměrně dobře patrné. A právě pro potřeby LCF vznikl nový
(tehdy vlastně doménově specifický) jazyk ML. To vlastně znamená, že samotný ML
byl pouze vedlejším produktem práce na LCF, teprve poději došlo
k&nbsp;osamostatnění ML.</p>

<p>První varianta ML pro LCF vznikala v&nbsp;období 1973 až 1978. Původně byly
zdrojové kódy transpilovány do LISPu a teprve poté překládány do strojového
(objektového) kódu. Ovšem kromě technických detailů (jakkoli jsou zajímavé) je
důležité, kdo se na vývoji ML podílel a jaké myšlenky zde byly využity. Jednou
z&nbsp;inspirací byl jazyk ISWIM (If you See What I Mean) Petera Landina
z&nbsp;šedesátých let. Tento jazyk byl založen na lambda kalkulu, podporoval
funkce vyššího řádu a používal dynamické typování a lexikální obory platnosti.
Peter Landin pro tento projekt vytvořil <a
href="https://en.wikipedia.org/wiki/J_operator">operátor J</a>. Na vývoji ML se
nepřímo podílel i Christopher Strachey, jenž dříve vytvořil jazyk CPL, což je
praprapředek céčka (CPL &rarr; BCPL &rarr; B &rarr; C). Mimochodem, právě
Christopher Strachey zavedl v&nbsp;IT několik nových termínů, například od něj
pochází &bdquo;syntactic sugar&ldquo;.</p>

<p>Pro vznik ML byl důležitý i jazyk HOPE s&nbsp;pattern matchingem. Funkce
zapsaná v&nbsp;jazyku HOPE se až na několik detailů shoduje s&nbsp;ML:</p>

<pre>
def fact : num -&gt; num;
--- fact 0 &lt;= 1;
--- fact n &lt;= n*fact(n-1);
</pre>

<p>V&nbsp;ML se objevilo i automatické odvozování typů, což je technika, která
byla shrnuta v&nbsp;roce 1978 pod jménem Hindley-Milner type inference. A ve
stejném roce byl ML pro LCF konečně dokončen.</p>

<p>Vzhledem k&nbsp;tomu, že ML byl součástí LCF a nebylo ho možné používat mimo
tento systém (proto se taktéž někdy setkáme s&nbsp;označením LCF/ML), objevily
se snahy o plné oddělení ML jako samostatného jazyka. Takto vznikl &bdquo;ML
under VAX&ldquo; neboli zkráceně &bdquo;VAX ML&ldquo;. Jednalo se o samostatně
použitelnou variantu ML, která byla naprogramována v&nbsp;Pascalu. Překladač do
strojového kódu VAXu byl dokončen v&nbsp;roce 1981. Prakticky právě od této
chvíle se začala psát historie skutečně dostupného ML. Ostatně je to patrné i
na tom, že o rok později byl jazyk portován do Unixu (stále v&nbsp;Pascalu).
Později byl runtime jazyka přepsán do C, ovšem samotný překladač zůstal
v&nbsp;Pascalu.</p>

<p>V&nbsp;roce 1983 se autoři programovacího jazyka ML setkali na universitě
v&nbsp;Edinburgu s&nbsp;cílem formálně jazyk ML specifikovat. Na rozdíl od
například Pythonu měl být tedy jazyk ML založen na formální definici a nikoli
na referenční implementaci. Výsledkem tohoto setkání byl popis ML, článek
&bdquo;Compiling a Functional Language&ldquo; a zhruba v&nbsp;této době se
namísto ML začalo používat označení <i>Standard ML</i> neboli zkráceně
<i>SML</i>.</p>



<p><a name="k03"></a></p>
<h2 id="k03">3. Od Standard ML k&nbsp;jazykům Caml, OCaml a F#</h2>

<p>Na konci předchozí kapitoly byl zmíněn rok 1983. Z&nbsp;hlediska historie
programovacích jazyků se jednalo o zajímavé období, protože se prakticky
&bdquo;všude&ldquo; začalo mluvit o objektově orientovaném programování jako o
stříbrné kulce, která má vyřešit (skoro) všechny programátorské problémy a
současně se předpokládalo, že právě objektově orientované programování bude
paradigmatem používaným v&nbsp;budoucnu (což se nakonec ukázal být pravdivý
předpoklad, i když nakonec zvítězilo &bdquo;třídní OOP&ldquo; a nikoli koncept
posílání zpráv). Ostatně v&nbsp;roce 1983 vzniklo C++, v&nbsp;roce 1989 pak
C++2.0. Začátek práce na Javě se datuje do roku 1991, první verze pak byla
vydána v&nbsp;roce 1995. A tématu se chytily i další společnosti, takže
například vznikly assemblery podporující objektově orientované programování
(což v&nbsp;praxi nebyla tak úplně pravda, ale na krabici se to pěkně
vyjímalo).</p>

<p>V&nbsp;rámci plánů dalších verzí jazyka ML (přednášky ML-2000) se začalo
mluvit o podpoře objektově orientovaného programování i v&nbsp;tomto jazyce.
Nejprve v&nbsp;roce 1985 vznikl jazyk <i>Caml</i> (<i>Categorical Abstract
Machine Language</i>), jehož poslední verze nabízela OO vrstvu. Na základě
zkušeností s&nbsp;Camlem byl v&nbsp;roce 1996 vydán jazyk <i>OCaml</i>
(Objective Caml), jenž je používán dodnes. A zapomenout nesmíme na jazyk <a
href="https://fsharp.org/">F#</a>, jenž se taktéž nechal inspirovat jazykem ML.
Tomuto velmi zajímavému programovacímu jazyku bude věnován samostatný článek
(s&nbsp;vydáním jsem čekal deset let, protože jsem popravdě věřil, že firma
Microsoft tento jazyk &bdquo;zařízne&ldquo;, podobně jako mnoho dalších
technologií).</p>

<p><div class="rs-tip-major">Poznámka: vývoj důležitých programovacích jazyků
se shrnut <a
href="https://ccrma.stanford.edu/courses/250a-fall-2005/docs/ComputerLanguagesChart.png">na
tomto grafu</a>.</div></p>



<p><a name="k04"></a></p>
<h2 id="k04">4. Online varianta jazyka Standard ML</h2>

<p>Jazyk Standard ML si můžete prakticky vyzkoušet, a to hned několika způsoby.
Nejjednodušší resp.&nbsp;časově nejméně náročné je použití online verze, pro
jejíž zprovoznění postačuje pouze nějaký moderní webový prohlížeč
(s&nbsp;JavaScriptem) a není tedy vyžadována instalace klasického
interaktivního prostředí a překladače SML. Online verzí jazyka ML
v&nbsp;současnosti existuje několik, přičemž jedním z&nbsp;příkladů takového
jednoduše pojatého vývojového prostředí je online <i>REPL (Read Eval Print
Loop)</i> dostupný na adrese <a
href="https://sosml.org/">https://sosml.org/</a> (<i>SOSML</i>). Předností této
varianty je fakt, že dlouhotrvající výpočty jsou automaticky ukončeny, čímž je
například zajištěno, že se program &bdquo;zotaví&ldquo; z&nbsp;nekonečné
rekurze. Použití <i>SOSML</i> je jednoduché &ndash; do levého textového pole se
zapisují poznámky, výrazy a definice. Po ukončení výrazu či definice středníkem
je provedeno jeho vyhodnocení a výsledek se zapíše do pravého textového pole
(středník je zde tedy velmi důležitý).  Jak příkazy, tak i jejich výsledky jsou
barevně odlišeny; navíc je odlišeno a případné hlášení o chybě.</p>

*** image ***
<p><i>Obrázek 1: Interaktivní webové prostředí SOSML.</i></p>

<p><div class="rs-tip-major">Poznámka: demonstrační příklady, které si ukážeme
v&nbsp;dalších kapitolách, byly otestovány mj.&nbsp;i právě ve webovém
prostředí SOSML.</div></p>



<p><a name="k05"></a></p>
<h2 id="k05">5. Instalace Standard ML z&nbsp;nabízených balíčků</h2>

<p>Pro plné využití možností nabízených programovacím jazykem ML
(resp.&nbsp;přesněji řečeno Standard ML) již nebude webové uživatelské
prostředí dostačující a bude nutné si nainstalovat nějakou vhodnou nativní
variantu tohoto jazyka. Většina nejvýznamnějších distribucí Linuxu nabízí
nějakou variantu jazyka Standard ML již ve svém standardním repositáři.
Konkrétně se jedná o balíčky <strong>mlton</strong>, <strong>smlnj</strong> či
<strong>polyml</strong> (pokaždé se jedná o jinou implementaci, to nám však
v&nbsp;dnešním článku nemusí vůbec vadit):</p>

<ul>

<li><strong>mlton</strong>: Optimizing compiler for Standard ML MLton is a
whole-program optimizing compiler for Standard ML. MLton generates standalone
executables with excellent runtime performance, is SML 97 compliant, and has a
complete basis library. MLton has source-level profiling, a fast C FFI, an
interface to the GNU multiprecision library, and lots of useful libraries.</li>

<li><strong>smlnj</strong>: SML/NJ is an implementation of the Standard ML
programming language. Standard ML has many features, including type safety,
polymorphism, algebraic data types with pattern matching, higher-order
functions, and a sophisticated module system. It is especially well-suited for
writing compilers and other language processors.</li>

<li><strong>polyml</strong>: interpreter and interactive compiler for Standard
ML. Poly/ML is an implementation of the Standard ML programming language
Standard ML is a general-purpose, modular, type-safe, strict, functional
programming language. Poly/ML is SML 97 compliant interpreter and compiler that
supports the generation of stand-alone executables with an interactive toplevel
(REPL).</li>

</ul>

<p>Příklady instalace balíčků <strong>mlton</strong> a <strong>polyml</strong>
na systému <i>Fedora release 34 (Thirty Four)</i>:</p>

<pre>
# <strong>dnf install mlton</strong>
&nbsp;
$ <strong>mlton</strong>
</pre>

<pre>
# <strong>dnf install polyml</strong>
&nbsp;
$ <strong>poly -version</strong>
Poly/ML 5.8.2 Release
</pre>

<p><div class="rs-tip-major">Poznámka: <strong>mlton</strong> je překladač,
takže pro interaktivní způsob programování se příliš nehodí. V&nbsp;tomto
ohledu je lepší použít <strong>polyml</strong> či
<strong>smlnj</strong>.</div></p>



<p><a name="k06"></a></p>
<h2 id="k06">6. Instalace Standard ML ze zdrojových kódů</h2>

<p>V&nbsp;případě, že žádný podobný balíček v&nbsp;repositáři vaší distribuce
nenajdete, bude nutné nainstalovat prostředí i překladač jazyka Standard ML ze
zdrojových kódů. Postup není ve skutečnosti příliš složitý (jen časově náročný)
a je popsán v&nbsp;navazujících odstavcích, a to pro pro implementace Standard
ML of New Jersey a Poly/ML.</p>

<p>Nejprve je nutné stáhnout tarball obsahující zdrojové kódy skriptů a dalších
nástrojů určených pro překlad SML:</p>

<pre>
$ <strong>wget http://smlnj.cs.uchicago.edu/dist/working/110.98.1/config.tgz</strong>
&nbsp;
--2020-12-17 20:44:12--  http://smlnj.cs.uchicago.edu/dist/working/110.98.1/config.tgz
Resolving smlnj.cs.uchicago.edu (smlnj.cs.uchicago.edu)... 128.135.164.125
Connecting to smlnj.cs.uchicago.edu (smlnj.cs.uchicago.edu)|128.135.164.125|:80... connected.
HTTP request sent, awaiting response... 200 OK
Length: 517536 (505K) [application/x-gzip]
Saving to: ‘config.tgz’
&nbsp;
config.tgz          100%[===================&gt;] 505.41K   920KB/s    in 0.5s    
&nbsp;
2020-12-17 20:44:13 (920 KB/s) - ‘config.tgz’ saved [517536/517536]
</pre>

<p><div class="rs-tip-major">Poznámka: jak již jméno a ostatně i velikost
staženého tarballu naznačuje, neobsahuje všechny potřebné zdrojové kódy, ale
&bdquo;pouze&ldquo; konfigurační a instalační skripty.</div></p>

<p>Tarball běžným způsobem rozbalíme:</p>

<pre>
$ <strong>tar xvf config.tgz</strong>
</pre>

<p>A spustíme vlastní instalaci:</p>

<pre>
$ <strong>config/install.sh -default 64</strong>
&nbsp;
[scanning (183299-export.cm):driver/(sources.cm):../front-end/(sources.cm):typechecker/(sources.cm):../../back-end/(sources.cm):cxx/(sources.cm):../../views/sources.cm]
[scanning (183299-export.cm):driver/(sources.cm):../front-end/(sources.cm):typechecker/(sources.cm):../../back-end/(sources.cm):cxx/(sources.cm):../util/sources.cm]
[scanning (183299-export.cm):driver/(sources.cm):../front-end/(sources.cm):typechecker/(sources.cm):../../back-end/(sources.cm):sml/sources.cm]
[parsing (183299-export.cm):183299-export.sml]
[creating directory .cm/SKEL]
[compiling (183299-export.cm):183299-export.sml]
[creating directory .cm/GUID]
[creating directory .cm/amd64-unix]
[code: 229, data: 29, env: 39 bytes]
config/install.sh: Installation complete.
</pre>

<p>Po dokončení předchozího kroku by se měl v&nbsp;podadresáři
<strong>bin</strong> objevit mj.&nbsp;i spustitelný soubor nazvaný
<strong>sml</strong>. Po spuštění tohoto souboru se zobrazí REPL (tedy
interaktivní prostředí) jazyka Standard ML:</p>

<pre>
$ <strong>cd bin</strong>
&nbsp;
$ <strong>./sml</strong>
&nbsp;
Standard ML of New Jersey (64-bit) v110.98.1 [built: Thu Dec 17 20:45:35 2021]
</pre>

<p>Překlad a instalace další implementace jazyka Standard ML, konkrétně
projektu <i>Poly/ML</i>, vyžaduje instalaci C++, ovšem celý postup je
snazší:</p>

<p>Nejprve stáhneme poslední verzi zdrojových kódů:</p>

<pre>
$ <strong>wget https://github.com/polyml/polyml/archive/refs/tags/v5.9.tar.gz</strong>
&nbsp;
--2022-02-06 04:59:05--  https://github.com/polyml/polyml/archive/refs/tags/v5.9.tar.gz
Resolving github.com (github.com)... 140.82.112.4
Connecting to github.com (github.com)|140.82.112.4|:443... connected.
HTTP request sent, awaiting response... 302 Found
Location: https://codeload.github.com/polyml/polyml/tar.gz/refs/tags/v5.9 [following]
--2022-02-06 04:59:05--  https://codeload.github.com/polyml/polyml/tar.gz/refs/tags/v5.9
Resolving codeload.github.com (codeload.github.com)... 140.82.113.9
Connecting to codeload.github.com (codeload.github.com)|140.82.113.9|:443... connected.
HTTP request sent, awaiting response... 200 OK
Length: unspecified [application/x-gzip]
Saving to: ‘v5.9.tar.gz’
&nbsp;
v5.9.tar.gz             [    &lt;=&gt;  ]   3.59M  5.54MB/s    in 0.6s    
&nbsp;
2022-02-06 04:59:06 (5.54 MB/s) - ‘v5.9.tar.gz’ saved [3764115]
</pre>

<p>Získaný tarball rozbalíme:</p>

<pre>
$ <strong>tar xvfz v5.9.tar.gz</strong>
</pre>

<p>Provedeme konfiguraci projektu, a to zcela standardním způsobem:</p>

<pre>
$ <strong>cd polyml-5.9/</strong>
$ <strong>./configure</strong>
</pre>

<p>Následuje vlastní překlad:</p>

<pre>
$ <strong>make</strong>
</pre>

<p>Nakonec otestujeme, zda je možné interaktivní běhové prostředí spustit a
použít:</p>

<pre>
$ <strong>./poly</strong>
Poly/ML 5.9 Release
&nbsp;
&gt; <strong>6*7;</strong>
val it = 42: int
</pre>



<p><a name="k07"></a></p>
<h2 id="k07">7. Komentáře</h2>

<p><div class="rs-tip-major">Poznámka na úvod: <i>syntaxe</i> jazyka ML
resp.&nbsp;Standard ML může být na první pohled poněkud podivná, zejména pro
programátory, kteří pracují s&nbsp;programovacími jazyky patřícími do céčkové
větve (tedy například s&nbsp;C, C++, Javou, JavaScriptem či C#). Ovšem
v&nbsp;praxi se ukazuje, že <i>syntaxe</i> je tím nejmenším problémem, protože
důležitá je především <i>sémantika</i> a na tu se po popisu základních konceptů
zaměříme (ostatně například Caml/OCaml dovolují vytvořit si v&nbsp;případě
potřeby vlastní syntaxi).</div></p>

<p>Nyní, když máme k&nbsp;dispozici na výběr mezi <a href="#k04">webovým
rozhraním</a> a <a href="#k05">řádkovým (terminálovým) rozhraním jazyka
SML</a>, si můžeme popsat a ihned také ukázat základní vlastnosti
programovacího jazyka ML. Začneme tím nejzákladnějším (a nejméně
problematickým) prvkem jazyka, kterým jsou komentáře. Ty se zapisují
&bdquo;Pascalovským&ldquo; způsobem mezi dvojici komentářových závorek
<strong>(*</strong> a <strong>*)</strong>, tedy následovně:</p>

<pre>
<i>(* komentáře *)</i>
</pre>

<p>Komentáře mohou být v&nbsp;případě potřeby víceřádkové, takže je možné
například zakomentovat celý blok s&nbsp;definicí funkce:</p>

<pre>
<i>(*</i>
<i>fun fib 0 = 0</i>
<i>  | fib 1 = 1</i>
<i>  | fib n = fib (n - 1) + fib (n - 2)</i>
<i>*)</i>
</pre>

<p><div class="rs-tip-major">Poznámka: prozatím se netrapte tím, <i>jak</i>
zápis funkce vypadá. K&nbsp;tomuto problému se dostaneme později.</div></p>

<p>Velmi užitečné je, že komentáře mohou (na rozdíl od mnoha céčkových jazyků)
obsahovat další komentáře, takže je snadné například zakomentovat část kódu,
která obsahuje běžné komentáře:</p>

<pre>
<i>(*</i>
<i>(* Výpočet Fibonacciho posloupnosti *)</i>
<i>fun fib 0 = 0</i>
<i>  | fib 1 = 1</i>
<i>  | fib n = fib (n - 1) + fib (n - 2)</i>
<i>*)</i>
</pre>



<p><a name="k08"></a></p>
<h2 id="k08">8. Výrazy v&nbsp;jazyku ML</h2>

<p>Nyní si ukažme práci s&nbsp;výrazy. Samotné výrazy (více o nich níže) se
zapisují přímo, není zapotřebí je nějakým způsobem speciálně označovat:</p>

<pre>
<strong>výraz</strong>
</pre>

<p><div class="rs-tip-major">Poznámka: některé varianty jazyka ML vykonají
(resp.&nbsp;přesněji řečeno vyhodnotí) výraz až ve chvíli, kdy je za něj zapsán
středník:</div></p>

<pre>
<strong>výraz;</strong>
</pre>

<p>Příklad výrazů s&nbsp;jejich okamžitým vyhodnocením:</p>

<pre>
&gt; <strong>1;</strong>
val it = 1: int
&nbsp;
&gt; <strong>6*7;</strong>
val it = 42: int
&nbsp;
&gt; <strong>"foo";</strong>
val it = "foo": string
&nbsp;
&gt; <strong>[1, 2, 3];</strong>
val it = [1, 2, 3]: int list
&nbsp;
&gt; <strong>false;</strong>
val it = false: bool
</pre>

<p>Povšimněte si důležité vlastnosti jazyka ML &ndash; výsledek vyhodnocení
výrazu není tvořen pouze vypočtenou hodnotou, ale <i>vždy</i> obsahuje i
informace o typu této hodnoty.</p>

<p>Součástí výrazu může být i volání funkce:</p>

<pre>
&gt; <strong>abs(1-5);</strong>
val it = 4: int
</pre>

<p>Volání funkce s&nbsp;jedním parametrem lze zapsat se závorkami okolo
parametru či bez závorek:</p>

<pre>
&gt; <strong>abs(1);</strong>
val it = 4: int
&nbsp;
&gt; <strong>abs 1;</strong>
val it = 1: int
</pre>

<p><div class="rs-tip-major">Poznámka: možná se chtěli autoři ML vyvarovat
jednoho (jediného?) problematického rysu LISPu, kterou je nadužívání
závorek.</div></p>

<p>Ovšem pozor je zapotřebí dát u funkcí s&nbsp;více parametry:</p>

<pre>
&gt; <strong>abs(1-5);</strong>
val it = 4: int
&nbsp;
&gt; <strong>abs 1-5;</strong>
val it = ~4: int
</pre>

<p>V&nbsp;prvním případě se vrátila hodnota 4, tedy skutečně absolutní hodnota
rozdílu 1-5. Ve druhém případě se vrátila hodnota -4, což je výsledek rozdílu
mezi absolutní hodnotou 1 a 5.</p>

<p><div class="rs-tip-major">Poznámka: zde můžeme vidět další (dnes)
nestandardní syntaxi jazyka ML &ndash; záporné hodnoty se zapisují pomocí znaku
&bdquo;~&ldquo;.</div></p>



<p><a name="k09"></a></p>
<h2 id="k09">9. Proměnné</h2>

<p>Proměnné, které jsou v&nbsp;jazyce ML vždy silně typované (tj.&nbsp;typ je
přiřazen i k&nbsp;proměnné, nikoli k&nbsp;hodnotě) se deklarují s&nbsp;využitím
slova <strong>val</strong>. Opět si ukažme několik příkladů:</p>

<pre>
&gt; <strong>val x = 10;</strong>
val x = 10: int
&nbsp;
&gt; <strong>val y = 3.14;</strong>
val y = 3.14: real
&nbsp;
&gt; <strong>val z = true;</strong>
val z = true: bool
&nbsp;
&gt; <strong>val w = "foobar";</strong>
val w = "foobar": string
</pre>

<p>Zde jsme narazili na první důležitý koncept programovacího jazyka ML. Tento
koncept se nazývá <i>odvození typů</i> neboli <i>type inference</i>. Spočívá
v&nbsp;tom, že na základě typu <i>hodnoty</i> dokáže ML odvodit i typ
<i>proměnné</i>, <i>výrazu</i> nebo parametru či návratové hodnoty
<i>funkce</i>. Výše uvedený příklad povede k&nbsp;automatickému odvození typů
všech čtyř proměnných, typ se od této chvíle stává součástí metainformace o
proměnných.</p>

<p>Totéž platí i pro proměnné, jimž je přiřazen výsledek nějakého složitějšího
výrazu:</p>

<pre>
&gt; <strong>val a = 6*7;</strong>
val a = 42: int
&nbsp;
&gt; <strong>val b = 10.0 / 4.0;</strong>
val b = 2.5: real
&nbsp;
&gt; <strong>val c = 10 div 4;</strong>
val c = 2: int
</pre>

<p>Výsledek posledního výrazu je uložen do speciální proměnné nazvané
<strong>it</strong>:</p>

<pre>
&gt; <strong>42;</strong>
val it = 42: int;
</pre>

<p>Obsah i typ této proměnné je neustále přepisován:</p>

<pre>
&gt; <strong>1;</strong>
val it = 1: int
&nbsp;
&gt; <strong>it;</strong>
val it = 1: int
&nbsp;
&gt; <strong>1+2;</strong>
val it = 3: int
&nbsp;
&gt; <strong>it;</strong>
val it = 3: int
</pre>



<p><a name="k10"></a></p>
<h2 id="k10">10. Základní datové typy jazyka ML</h2>

<p>S&nbsp;některými datovými typy, které jsou jazykem ML podporovány, jsme se
(vlastně trošku mimochodem) setkali v&nbsp;předchozích kapitolách. Ovšem pro
další články o ML je nutné zmínit všechny podporované datové typy.</p>

<p>První datový typ se jmenuje <i>unit</i>, ovšem většinou se mu říká
&bdquo;null type&ldquo;. Je reprezentován prázdnými kulatými závorkami a
technicky se jedná o n-tici bez prvků:</p>

<pre>
&gt; <strong>();</strong>
val it = (): unit
</pre>

<p><div class="rs-tip-major">Poznámka: tento datový typ je v&nbsp;praxi velmi
užitečný. Podobným typem známým z&nbsp;céčkovské větve jazyků je typ
<strong>void</strong>, jehož jméno ovšem (chybně?) naznačuje, že neexistuje
žádný prvek tohoto typu.</div></p>

<p>Dalším datovým typem je typ <i>bool</i>. Ten již není, na rozdíl od typu
<i>unit</i> nijak výjimečný. Obsahuje dvě hodnoty <strong>true</strong> a
<strong>false</strong>:</p>

<pre>
&gt; <strong>true;</strong>
val it = true: bool
&nbsp;
&gt; <strong>false;</strong>
val it = false: bool
</pre>

<p>Následuje celočíselný typ <i>int</i>, u něhož je zvláštní fakt, že se
záporné hodnoty zapisují s&nbsp;tildou a nikoli znakem &bdquo;-&ldquo;:</p>

<pre>
&gt; <strong>42;</strong>
val it = 42: int
&nbsp;
&gt; <strong>0 - 42;</strong>
val it = ~42: int
</pre>

<p>Přetečení může být v&nbsp;některých případech detekováno již v&nbsp;čase
překladu (což ovšem není nic překvapujícího):</p>

<pre>
&gt; <strong>10000000000000000000000000;</strong>
poly: : error: Overflow exception raised while converting 10000000000000000000000000 to int
Found near 10000000000000000000000000
Static Errors
</pre>

<p>Následuje datový typ <i>real</i>, jehož hodnoty jsou interně reprezentovány
s&nbsp;využitím systému s&nbsp;plovoucí řádovou čárkou:</p>

<pre>
&gt; <strong>3.14;</strong>
val it = 3.14: real
&nbsp;
&gt; <strong>0.0 - 3.14;</strong>
val it = ~3.14: real
</pre>

<p>Následují řetězce, neboli typ <i>string</i>:</p>

<pre>
&gt; <strong>"foobar";</strong>
val it = "foobar": string
</pre>

<p>A konečně typ <i>char</i> reprezentující jediný znak:</p>

<pre>
&gt; <strong>#"a";</strong>
val it = #"a": char
&nbsp;
&gt; <strong>#"ab";</strong>
poly: : error: Conversion exception (Not exactly one character) raised while converting ab to char
Found near #"ab"
Static Errors
</pre>

<p>U proměnných lze typ specifikovat i explicitně:</p>

<pre>
val i : int = 10;
val j : real = 10.0;
val k = i;
</pre>



<p><a name="k11"></a></p>
<h2 id="k11">11. Složené datové typy: n-tice a záznamy</h2>

<p>V&nbsp;ML jsou podporovány tři složené datové typy: n-tice, záznamy a
seznamy. Nejjednodušší jsou n-tice, které mohou obsahovat prvky libovolných
typů. Typ n-tice jako celku je pak odvozen od typů jednotlivých prvků.
Speciálním případem je n-tice bez prvků, neboli typ <i>unit</i> zmíněný
výše:</p>

<pre>
&gt; <strong>();</strong>
val it = (): unit
</pre>

<p>Následuje příklad n-tic s&nbsp;větším množstvím prvků. Povšimněte si toho,
jak je zapsán datový typ takové n-tice:</p>

<pre>
&gt; <strong>(1,2);</strong>
val it = (1, 2): int * int
&nbsp;
&gt; <strong>("foo", "bar");</strong>
val it = ("foo", "bar"): string * string
&nbsp;
&gt; <strong>(1, "foo", 3.14);</strong>
val it = (1, "foo", 3.14): int * string * real
</pre>

<p>Vzhledem k&nbsp;tomu, že n-tice s&nbsp;jediným prvkem nemá praktický význam,
není podporována (na rozdíl od Pythonu, kde se však jedná o syntakticky
problematický rys jazyka):</p>

<pre>
&gt; <strong>(2);</strong>
val it = 2: int
</pre>

<p>Následují záznamy, v&nbsp;nichž jsou prvky taktéž libovolného typu, ovšem na
rozdíl od n-tic jsou tyto prvky pojmenovány:</p>

<pre>
&gt; <strong>{color="silver", make="Toyota", model="Corolla", year=1986};</strong>
val it = {color = "silver", make = "Toyota", model = "Corolla", year = 1986}:
   {color: string, make: string, model: string, year: int}
</pre>

<p>Blíže se s&nbsp;tímto datovým typem seznámíme příště.</p>



<p><a name="k12"></a></p>
<h2 id="k12">12. Seznamy</h2>

<p>A konečně, nejdůležitějším složeným datovým typem jsou seznamy
(<i>lists</i>). Ty jsou homogenní, tj.&nbsp;všechny prvky seznamů musí být
stejného typu:</p>

<pre>
&gt; <strong>[1,2,3];</strong>
val it = [1, 2, 3]: int list
&nbsp;
&gt; <strong>["foo", "bar"];</strong>
val it = ["foo", "bar"]: string list
</pre>

<p>Pokus o vytvoření heterogenního seznamu skončí s&nbsp;chybou:</p>

<pre>
&gt; <strong>[1, "foo"];</strong>
poly: : error: Elements in a list have different types.
   Item 1: 1 : int
   Item 2: "foo" : string
   Reason:
      Can't unify int (*In Basis*) with string (*In Basis*)
         (Different type constructors)
Found near [1, "foo"]
Static Errors
</pre>

<p>Víme již, že speciálním případem n-tice je n-tice bez prvků. I u seznamů se
jedná o speciální případ, o čemž se můžeme velmi snadno přesvědčit (viz typ
výrazu):</p>

<pre>
&gt; <strong>[];</strong>
val it = []: 'a list
&nbsp;
</pre>

<p><div class="rs-tip-major">Poznámka: o speciální případ se zde jedná
z&nbsp;toho důvodu, že ML nedokáže z&nbsp;prázdného seznamu odvodit typ prvků.
V&nbsp;mnoha programových konstrukcích tak musí předpokládat, že se může jednat
o libovolný seznam.</div></p>

<p>Inspirace LISPem se nezapře v&nbsp;tom, že prázdný seznam je možné zapsat i
slovem <strong>nil</strong>:</p>

<pre>
&gt; <strong>nil;</strong>
val it = []: 'a list
</pre>

<p>Sémantika seznamů je ze značné míry převzata z&nbsp;LISPu, ovšem syntaxe
práce s&nbsp;nimi je odlišná. Seznam může být v&nbsp;tomto kontextu definován
rekurzivně:</p>

<ul>
<li>buď je seznam prázdný</li>
<li>nebo má formu <strong>hlava::tělo</strong>, kde <strong>hlava</strong> je první prvek seznamu</li>
</ul>

<p>To například znamená, že seznam <strong>[42]</strong> je shodný se seznamem
<strong>42::[]</strong>:</p>

<pre>
&gt; <strong>[42];</strong>
val it = [42]: int list
&nbsp;
&gt; <strong>42::[];</strong>
val it = [42]: int list
</pre>

<p>Zápis <strong>hlava::tělo</strong> se používá jak pro konstrukci seznamu,
tak i například ve vzorech (<i>patterns</i>), s&nbsp;nimiž se seznámíme
později.</p>

<p>Některé důležité funkce pro práci se seznamy:</p>

<table>
<tr><th>Funkce</th><th>Stručný popis</th></tr>
<tr><td>null(x)</td><td>test na prázdný seznam</td></tr>
<tr><td>length(x)</td><td>délka seznamu</td></tr>
<tr><td>hd(x)</td><td>první prvek seznamu</td></tr>
<tr><td>tl(x)</td><td>tělo seznamu (bez prvního prvku)</td></tr>
<tr><td>nth(x)</td><td>n-tý prvek seznamu</td></tr>
</table>

<p>Navíc je možné operátorem @ spojit dva seznamy. Schválně není pro tento účel
použit operátor +, aby nedošlo k&nbsp;jeho zbytečnému několikanásobnému
přetížení.</p>



<p><a name="k13"></a></p>
<h2 id="k13">13. Funkce</h2>

<p>Ve funkcionálních programovacích jazycích mají funkce stejně plnohodnotný
význam, jako jakékoli jiné typy. Výjimkou není ani jazyk ML, v&nbsp;němž je typ
funkce odvozen od typů parametrů a návratové hodnoty (automaticky odvozené od
použitých výrazů!). Funkce je definována klíčovým slovem
<strong>fun</strong>:</p>

<pre>
<strong>fun &lt;jméno-funkce&gt; &lt;formální-parametry-funkce&gt; = &lt;tělo-funkce&gt;</strong>
</pre>

<p>Pro zajímavost se podívejme, jaká klíčová slova pro definici funkce se
používají v&nbsp;těch programovacích jazycích, v&nbsp;nichž je tento koncept
použit (vynecháme tedy klasické céčkové jazyky):</p>

<table>
<tr><th>Jazyk</th><th>Klíčové slovo</th></tr>
<tr><td>ML</td><td>fun</td></tr>
<tr><td>LISP</td><td>defun</td></tr>
<tr><td>Scheme</td><td>define</td></tr>
<tr><td>Clojure</td><td>defn</td></tr>
<tr><td>Python</td><td>def</td></tr>
<tr><td>JavaScript</td><td>function</td></tr>
<tr><td>Julia</td><td>function</td></tr>
<tr><td>Lua</td><td>function</td></tr>
<tr><td>Pascal</td><td>function</td></tr>
<tr><td>Go</td><td>func</td></tr>
<tr><td>Rust</td><td>fn</td></tr>
</table>

<p>Podívejme se nyní na definici jednoduché funkce, která zvýší obsah svého
parametru o jedničku a vrátí novou hodnotu. Funkce se bude jmenovat
<strong>inc</strong> a její parametr <strong>n</strong>:</p>

<pre>
<strong>fun inc n = n + 1;</strong>
</pre>

<p><div class="rs-tip-major">Poznámka: nejedná se o zápis přiřazení, ale o
funkci s&nbsp;parametrem <strong>n</strong>, jejíž tělo je
<strong>n+1</strong>.</div></p>

<p>U této funkce je zajímavé především to, že jsme nikde neuvedli typ parametru
ani typ návratové hodnoty a přesto jazyk ML zjistil, že se jedná o funkci
<i>int &rarr; int</i>. Přitom se vychází z&nbsp;těla funkce, tedy z&nbsp;výrazu
<strong>n+1</strong>, což je v&nbsp;jazyku ML striktně součet dvou celých
čísel.</p>

<p>Zavolání takové funkce je jednoduché:</p>

<pre>
<strong>int 10;</strong>
</pre>

<p>Pozor si musíte dát na to, že se používá levá asociativita, což u funkcí
volaných bez kulatých závorek povede ke špatným výsledkům (chybě při
překladu):</p>

<pre>
<strong>f g x</strong> znamená <strong>(f g) x</strong>
</pre>

<p>Můžete si to ostatně sami otestovat:</p>

<pre>
<i>(* Kompozice funkcí *)</i>
&nbsp;
<strong>fun inc x = x + 1;</strong>
<strong>fun double x = x * 2;</strong>
&nbsp;
<strong>inc(double 1);</strong>
&nbsp;
<strong>inc double 1;</strong>
</pre>

<p>Definice a zavolání funkce se dvěma parametry:</p>

<pre>
<i>(* Definice funkce *)</i>
&nbsp;
<strong>fun add (x, y) = x + y;</strong>
&nbsp;
<strong>add(3,4);</strong>
</pre>

<p><div class="rs-tip-major">Poznámka: opět se bude jednat o funkci akceptující
jako své parametry celá čísla a vracející celé číslo.</div></p>



<p><a name="k14"></a></p>
<h2 id="k14">14. Rekurzivní funkce</h2>

<p>Ve funkcionálních jazycích se velmi často setkáme s&nbsp;rekurzivními
funkcemi, typicky založenými na principu postupného zjednodušování problému.
Například poněkud naivní implementace funkce pro výpočet délky seznamu může být
zapsána takto:</p>

<pre>
<strong>fun length(x) = if null(x) then 0</strong>
                <strong>else 1 + length(tl(x));</strong>
</pre>

<p>Podobně si můžeme nadefinovat funkci <strong>append</strong>, která vrací
nový seznam vzniklý spojením dvou seznamů <strong>x</strong> a
<strong>y</strong>. Tedy například:</p>

<pre>
<strong>append([1, 2], [3, 4, 5])</strong>
[1, 2, 3, 4, 5]
</pre>

<p>Na problém implementace této funkce můžeme použít princi postupného
zjednodušování problému. Známe totiž dva invarianty:</p>

<pre>
append([],z) == z
append(a :: y, z) == a :: append(y,z)
</pre>

<p>Postupně tedy budeme zkracovat první seznam až dojdeme do situace, kdy je
tento seznam prázdný. Přímo z&nbsp;těchto podmínek je možné odvodit
implementaci funkce <strong>append</strong>:</p>

<pre>
<strong>fun append(x, y) = if null(x) then y</strong>
                   <strong>else hd(x) :: append(tl(x), y)</strong>
</pre>

<p><div class="rs-tip-major">Poznámka: navíc se nám automaticky splnily všechny
okrajové podmínky, tedy konkrétně situace, kdy je jeden ze seznamů
prázdný.</div></p>

<p>Při zavolání:</p>

<pre>
<strong>append([1,2], [3,4,5])</strong>
</pre>

<p>dojde k&nbsp;postupnému vykonání fáze <i>navíjení</i> a <i>odvíjení</i>, což
si můžeme naznačit graficky:</p>

<pre>
1 :: append([2], [3,4,5])
1 :: 2 :: append([], [3,4,5])
1 :: 2 :: [3,4,5]
1 :: [2,3,4,5]
[1,2,3,4,5]
</pre>

<p>Důležitý je i typ nové funkce:</p>

<pre>
val append = fn: ∀ 'a . 'a list * 'a list → 'a list;
</pre>

<p>Tento zápis nám říká, že funkce bude akceptovat dva seznamy typu
&bdquo;any&ldquo; a výsledkem bude další seznam typu &bdquo;any&ldquo;. Typ
prvků seznamů sice není určen (ML ho nemá jak odvodit), ovšem je zaručeno, že
oba dva vstupní seznamy budou mít stejný typ prvků, jako seznam výsledný:</p>

<pre>
<strong>append([1,2,3], [4,5,6]);</strong>
val it = [1, 2, 3, 4, 5, 6]: int list;
&nbsp;
<strong>append(["foo", "bar"], ["baz"]);</strong>
val it = ["foo", "bar", "baz"]: string list;
&nbsp;
<strong>append(["foo", "bar"], [4]);</strong>
Elaboration failed: Type clash. Functions of type "'a list * 'a list → 'a list" cannot take an argument of type "string list * int list": Cannot merge "int" and "string".
</pre>

<p><div class="rs-tip-major">Poznámka: zcela přirozenou cestou jsme tak
vytvořili generickou, ovšem typově bezpečnou funkci.</div></p>



<p><a name="k15"></a></p>
<h2 id="k15">15. Anonymní funkce</h2>

<p>V&nbsp;programovacím jazyku ML je možné deklarovat i anonymní funkce. Opět
se nejedná o nic překvapivého, zvláště když si uvědomíme, kolik
<i>sémantiky</i> (nikoli však <i>syntaxe</i>) bylo převzato z&nbsp;Lispovských
jazyků. Anonymní funkce se deklaruje slovem <strong>fn</strong> a používá se
zde znak šipky =&gt;. Příkladem jednoduché anonymní funkce je funkce, která
vrátí hodnotu svého parametru zvýšeného o jedničku (jedná se tedy o funkci
s&nbsp;parametrem typu <strong>int</strong> a návratovou hodnotou typu
<strong>int</strong>):</p>

<pre>
<strong>fn x =&gt; 1 + x;</strong>
&nbsp;
&gt; val it = fn: int → int;
</pre>

<p>Pochopitelně je možné vytvořit i anonymní funkce akceptující větší množství
parametrů:</p>

<pre>
<strong>fn (x, y) =&gt; x + y;</strong>
&nbsp;
&gt; val it = fn: int * int → int;
</pre>

<p><div class="rs-tip-major">Poznámka: anonymními funkcemi se budeme podrobněji
zabývat ve druhé části miniseriálu o programovacím jazyku ML.</div></p>



<p><a name="k16"></a></p>
<h2 id="k16">16. Pattern matching</h2>

<p>Velmi důležitým konceptem, který byl rozvinut právě v&nbsp;programovacím
jazyku ML, je takzvaný <i>pattern matching</i> neboli rozpoznávání vzorů. Ten
byl později s&nbsp;menšími či většími úpravami převzat i do dalších
programovacích jazyků. Podívejme se na praktické použití této techniky.</p>

<p>Obecný zápis funkce s&nbsp;pattern matchingem vypadá následovně:</p>

<pre>
<strong>fun &lt;jméno&gt; &lt;vzorek&gt; = &lt;tělo/výraz&gt;</strong>
</pre>

<p>Většinou se však používá větší množství vzorků, které jsou spojeny znakem
&bdquo;or&ldquo;. V&nbsp;takovém případě jsou vzorky postupně procházeny a
pokud budou vyhovovat předaným datům, bude příslušná větev funkce vykonána:</p>

<pre>
<strong>fun &lt;jméno&gt; &lt;vzorek&gt; = &lt;tělo/výraz&gt;</strong>
 <strong>|  &lt;jméno&gt; &lt;vzorek&gt; = &lt;tělo/výraz&gt;</strong>
 <strong>|  &lt;jméno&gt; &lt;vzorek&gt; = &lt;tělo/výraz&gt;</strong>
 <strong>|  &lt;jméno&gt; &lt;vzorek&gt; = &lt;tělo/výraz&gt;</strong>
</pre>

<p>O tom, jak vypadá zápis běžné funkce, jsme se dozvěděli <a href="#k13">ve
třinácté kapitole</a>. Příkladem je funkce <strong>length</strong>:</p>

<pre>
<strong>fun length(x) = if null(x) then 0</strong>
                <strong>else 1 + length(tl(x));</strong>
</pre>

<p>V&nbsp;této funkci se provede vždy jedna z&nbsp;větví na základě zapsané
podmínky (<i>case analysis</i>). Ovšem díky existenci pattern matchingu lze
stejnou funkci zapsat odlišně &ndash; a to vyjmenováním invariantů:</p>

<pre>
<strong>fun length([]) = 0</strong>
  <strong>| length(a::x) = 1 + length(x)</strong>
</pre>

<p>Tímto zápisem vlastně popisujeme, že pro prázdný seznam je délka rovna nule
a pro seznam skládající se z&nbsp;hlavy a těla je délka tohoto seznamu rovna
délce těla + 1.</p>

<p>Existují však i zajímavější vzorky. Například funkci <strong>car</strong>
vracející hlavu seznamu (první prvek) lze zapsat opět vyjmenováním
invarianty:</p>

<pre>
<strong>fun car(x::y) = x;</strong>
</pre>

<p>V&nbsp;tomto případě ML rozezná, že nejsou pokryty všechny možné
varianty:</p>

<pre>
&gt; val car = fn: ∀ 'a . 'a list → 'a;
&nbsp;
WARN: Pattern matching is not exhaustive.
</pre>

<p><div class="rs-tip-major">Poznámka: nejprve si povšimněte typu funkce
(generická funkce, ovšem hlídající správné typy) a taktéž varování, ke kterému
se hned dostaneme (a které není radno ignorovat).</div></p>

<p>To, zda tato funkce pracuje podle očekávání, si můžeme snadno ověřit:</p>

<pre>
<strong>car([1,2,3]);</strong>
&gt; val it = 1: int;
&nbsp;
<strong>car(["foo", "bar"]);</strong>
&gt; val it = "foo": string;
&nbsp;
<strong>car(["first"]);</strong>
&gt; val it = "first": string;
&nbsp;
<strong>car([]);</strong>
Uncaught SML exception: Match
</pre>

<p>Na posledním příkladu je patrné, že ML měl pravdu &ndash; kód funkce
nepokrývá všechny okrajové podmínky. Náprava je snadná, protože stačí přidat
vzorek pro prázdný seznam na vstupu:</p>

<pre>
<strong>fun car([]) = 0</strong>
  <strong>| car(x::y) = x;</strong>
&gt; val car = fn: int list → int;
&nbsp;
<strong>car([1,2,3]);</strong>
&gt; val it = 1: int;
&nbsp;
<strong>car([]);</strong>
&gt; val it = 0: int;
</pre>

<p>Nebo ještě lépe &ndash; vyhodíme výjimku (viz navazující článek):</p>

<pre>
<strong>fun car nil = raise Empty</strong>
  <strong>| car(x::y) = x;</strong>
&gt; val car = fn: ∀ 'a . 'a list → 'a;
&nbsp;
<strong>car([1,2,3]);</strong>
&gt; val it = 1: int;
&nbsp;
<strong>car([]);</strong>
Uncaught SML exception: Empty
</pre>

<p><div class="rs-tip-major">Poznámka: na těchto jednoduchých příkladech to
sice není tak patrné, ale spojením pattern matchingu se silným typovým systémem
vzniká velmi bezpečný programovací jazyk, zejména pokud programátor skutečně
reaguje na všechna varování vypisovaná při analýze jeho zdrojového
kódu.</div></p>



<p><a name="k17"></a></p>
<h2 id="k17">17. Obsah druhé části článku</h2>

<p>Ve druhé části článku (resp.&nbsp;celého miniseriálu) o programovacím jazyku
ML se zaměříme především na podrobnější popis typového systému tohoto jazyka a
taktéž na složitější funkce, které používají pattern matching.</p>



<p><a name="k18"></a></p>
<h2 id="k18">18. Repositář s&nbsp;demonstračními příklady</h2>

<p>Všechny výše popsané demonstrační příklady byly uloženy do repositáře
dostupného na adrese <a
href="https://github.com/tisnik/ml-examples/">https://github.com/tisnik/ml-examples/</a>.
V&nbsp;tabulce umístěné pod tímto odstavcem jsou uvedeny odkazy na tyto
příklady:</p>

<table>
<tr><th> #</th><th>Příklad</th><th>Popis příkladu</th><th>Cesta</th></tr>
<tr><td> 1</td><td>01_simple_comments.ml</td><td>jednořádkový komentář</td><td><a href="https://github.com/tisnik/ml-examples/tree/master/article_01/01_simple_comments.ml">https://github.com/tisnik/ml-examples/tree/master/article_01/01_simple_comments.ml</a></td></tr>
<tr><td> 2</td><td>02_block_comment.ml</td><td>víceřádkový (blokový) komentář</td><td><a href="https://github.com/tisnik/ml-examples/tree/master/article_01/02_block_comment.ml">https://github.com/tisnik/ml-examples/tree/master/article_01/02_block_comment.ml</a></td></tr>
<tr><td> 3</td><td>03_nested_comments.ml</td><td>vnořené komentáře</td><td><a href="https://github.com/tisnik/ml-examples/tree/master/article_01/03_nested_comments.ml">https://github.com/tisnik/ml-examples/tree/master/article_01/03_nested_comments.ml</a></td></tr>
<tr><td> 4</td><td>04_expressions.ml</td><td>jednoduché výrazy</td><td><a href="https://github.com/tisnik/ml-examples/tree/master/article_01/04_expressions.ml">https://github.com/tisnik/ml-examples/tree/master/article_01/04_expressions.ml</a></td></tr>
<tr><td> 5</td><td>05_function_call.ml</td><td>volání funkce</td><td><a href="https://github.com/tisnik/ml-examples/tree/master/article_01/05_function_call.ml">https://github.com/tisnik/ml-examples/tree/master/article_01/05_function_call.ml</a></td></tr>
<tr><td> 6</td><td>06_function_call_wo_parenthesis.ml</td><td>volání funkce s&nbsp;jedním parametrem bez použití závorek</td><td><a href="https://github.com/tisnik/ml-examples/tree/master/article_01/06_function_call_wo_parenthesis.ml">https://github.com/tisnik/ml-examples/tree/master/article_01/06_function_call_wo_parenthesis.ml</a></td></tr>
<tr><td> 7</td><td>07_function_call_wo_parenthesis.ml</td><td>problematický rys zkráceného volání funkce</td><td><a href="https://github.com/tisnik/ml-examples/tree/master/article_01/07_function_call_wo_parenthesis.ml">https://github.com/tisnik/ml-examples/tree/master/article_01/07_function_call_wo_parenthesis.ml</a></td></tr>
<tr><td> 8</td><td>08_variables.ml</td><td>proměnné</td><td><a href="https://github.com/tisnik/ml-examples/tree/master/article_01/08_variables.ml">https://github.com/tisnik/ml-examples/tree/master/article_01/08_variables.ml</a></td></tr>
<tr><td> 9</td><td>09_variables_from_expressions.ml</td><td>proměnné inicializované vyhodnocením složitějšího výrazu</td><td><a href="https://github.com/tisnik/ml-examples/tree/master/article_01/09_variables_from_expressions.ml">https://github.com/tisnik/ml-examples/tree/master/article_01/09_variables_from_expressions.ml</a></td></tr>
<tr><td>10</td><td>10_elementary_data_types.ml</td><td>základní datové typy jazyka ML</td><td><a href="https://github.com/tisnik/ml-examples/tree/master/article_01/10_elementary_data_types.ml">https://github.com/tisnik/ml-examples/tree/master/article_01/10_elementary_data_types.ml</a></td></tr>
<tr><td>11</td><td>11_tuples.ml</td><td>n-tice</td><td><a href="https://github.com/tisnik/ml-examples/tree/master/article_01/11_tuples.ml">https://github.com/tisnik/ml-examples/tree/master/article_01/11_tuples.ml</a></td></tr>
<tr><td>12</td><td>12_records.ml</td><td>záznamy</td><td><a href="https://github.com/tisnik/ml-examples/tree/master/article_01/12_records.ml">https://github.com/tisnik/ml-examples/tree/master/article_01/12_records.ml</a></td></tr>
<tr><td>13</td><td>13_empty_list.ml</td><td>zápis prázdného seznamu</td><td><a href="https://github.com/tisnik/ml-examples/tree/master/article_01/13_empty_list.ml">https://github.com/tisnik/ml-examples/tree/master/article_01/13_empty_list.ml</a></td></tr>
<tr><td>14</td><td>14_list.ml</td><td>seznamy</td><td><a href="https://github.com/tisnik/ml-examples/tree/master/article_01/14_list.ml">https://github.com/tisnik/ml-examples/tree/master/article_01/14_list.ml</a></td></tr>
<tr><td>15</td><td>15_function.ml</td><td>deklarace funkce</td><td><a href="https://github.com/tisnik/ml-examples/tree/master/article_01/15_function.ml">https://github.com/tisnik/ml-examples/tree/master/article_01/15_function.ml</a></td></tr>
<tr><td>16</td><td>16_add.ml</td><td>funkce se dvěma parametry</td><td><a href="https://github.com/tisnik/ml-examples/tree/master/article_01/16_add.ml">https://github.com/tisnik/ml-examples/tree/master/article_01/16_add.ml</a></td></tr>
<tr><td>17</td><td>17_composition.ml</td><td>pokus o kompozici funkcí</td><td><a href="https://github.com/tisnik/ml-examples/tree/master/article_01/17_composition.ml">https://github.com/tisnik/ml-examples/tree/master/article_01/17_composition.ml</a></td></tr>
<tr><td>18</td><td>18_length_function.ml</td><td>definice funkce <strong>length</strong></td><td><a href="https://github.com/tisnik/ml-examples/tree/master/article_01/18_length_function.ml">https://github.com/tisnik/ml-examples/tree/master/article_01/18_length_function.ml</a></td></tr>
<tr><td>19</td><td>19_append_function.ml</td><td>definice funkce <strong>append</strong></td><td><a href="https://github.com/tisnik/ml-examples/tree/master/article_01/19_append_function.ml">https://github.com/tisnik/ml-examples/tree/master/article_01/19_append_function.ml</a></td></tr>
<tr><td>20</td><td>20_reverse_function.ml</td><td>definice funkce <strong>reverse</strong></td><td><a href="https://github.com/tisnik/ml-examples/tree/master/article_01/20_reverse_function.ml">https://github.com/tisnik/ml-examples/tree/master/article_01/20_reverse_function.ml</a></td></tr>
</table>



<p><a name="k19"></a></p>
<h2 id="k19">19. Literatura</h2>

<p><div class="rs-tip-major">Poznámka: v&nbsp;této kapitole jsou uvedeny
nejenom knihy o jazyku ML resp.&nbsp;Standard ML, ale i knihy o programovacím
jazyku OCaml, který ze Standard ML ze značné míry vychází.</div></p>

<ol>

<li>ML for the Working Programmer<br />
<a href="https://www.cl.cam.ac.uk/~lp15/MLbook/pub-details.html">https://www.cl.cam.ac.uk/~lp15/MLbook/pub-details.html</a>
</li>

<li>Elements of ML Programming, 2nd Edition (ML97)<br />
<a href="http://infolab.stanford.edu/~ullman/emlp.html">http://infolab.stanford.edu/~ullman/emlp.html</a>
</li>

<li>A tour of Standard ML<br />
<a href="https://saityi.github.io/sml-tour/tour/welcome">https://saityi.github.io/sml-tour/tour/welcome</a>
</li>

<li>The History of Standard ML<br />
<a href="https://smlfamily.github.io/history/SML-history.pdf">https://smlfamily.github.io/history/SML-history.pdf</a>
</li>

<li>The Standard ML Basis Library<br />
<a href="https://smlfamily.github.io/Basis/">https://smlfamily.github.io/Basis/</a>
</li>

<li>Programming in Standard ML<br />
<a href="http://www.cs.cmu.edu/~rwh/isml/book.pdf">http://www.cs.cmu.edu/~rwh/isml/book.pdf</a>
</li>

<li>Programming in Standard ML '97: A Tutorial Introduction<br />
<a href="http://www.lfcs.inf.ed.ac.uk/reports/97/ECS-LFCS-97-364/">http://www.lfcs.inf.ed.ac.uk/reports/97/ECS-LFCS-97-364/</a>
</li>

<li>Programming in Standard ML '97: An On-line Tutorial<br />
<a href="https://homepages.inf.ed.ac.uk/stg/NOTES/">https://homepages.inf.ed.ac.uk/stg/NOTES/</a>
</li>

<li>The OCaml system  release 4.13<br />
<a href="https://ocaml.org/releases/4.13/htmlman/index.html">https://ocaml.org/releases/4.13/htmlman/index.html</a>
</li>

<li>Real World OCaml: Functional programming for the masses<br />
<a href="https://dev.realworldocaml.org/">https://dev.realworldocaml.org/</a>
</li>

<li>OCaml from the Very Beginning<br />
<a href="http://ocaml-book.com/">http://ocaml-book.com/</a>
</li>

<li>OCaml from the Very Beginning: More OCaml : Algorithms, Methods &amp; Diversions<br />
<a href="http://ocaml-book.com/more-ocaml-algorithms-methods-diversions/">http://ocaml-book.com/more-ocaml-algorithms-methods-diversions/</a>
</li>

<li>Unix system programming in OCaml<br />
<a href="http://ocaml.github.io/ocamlunix/">http://ocaml.github.io/ocamlunix/</a>
</li>

<li>OCaml for Scientists<br />
<a href="https://www.ffconsultancy.com/products/ocaml_for_scientists/index.html">https://www.ffconsultancy.com/products/ocaml_for_scientists/index.html</a>
</li>

<li>Using, Understanding, and Unraveling The OCaml Language<br />
<a href="https://caml.inria.fr/pub/docs/u3-ocaml/">https://caml.inria.fr/pub/docs/u3-ocaml/</a>
</li>

<li>Developing Applications With objective Caml<br />
<a href="https://caml.inria.fr/pub/docs/oreilly-book/index.html">https://caml.inria.fr/pub/docs/oreilly-book/index.html</a>
</li>

<li>Introduction to Objective Caml<br />
<a href="http://courses.cms.caltech.edu/cs134/cs134b/book.pdf">http://courses.cms.caltech.edu/cs134/cs134b/book.pdf</a>
</li>

<li>How to Think Like a (Functional) Programmer<br />
<a href="https://greenteapress.com/thinkocaml/index.html">https://greenteapress.com/thinkocaml/index.html</a>
</li>

</ol>



<p><a name="k20"></a></p>
<h2 id="k20">20. Odkazy na Internetu</h2>

<ol>

<li>Standard ML of New Jersey<br />
<a href="https://www.smlnj.org/">https://www.smlnj.org/</a>
</li>

<li>Programming Languages: Standard ML - 1 (a navazující videa)<br />
<a href="https://www.youtube.com/watch?v=2sqjUWGGzTo">https://www.youtube.com/watch?v=2sqjUWGGzTo</a>
</li>

<li>6 Excellent Free Books to Learn Standard ML<br />
<a href="https://www.linuxlinks.com/excellent-free-books-learn-standard-ml/">https://www.linuxlinks.com/excellent-free-books-learn-standard-ml/</a>
</li>

<li>SOSML: The Online Interpreter for Standard ML<br />
<a href="https://sosml.org/">https://sosml.org/</a>
</li>

<li>ML (Computer program language)<br />
<a href="https://www.barnesandnoble.com/b/books/other-programming-languages/ml-computer-program-language/_/N-29Z8q8Zvy7">https://www.barnesandnoble.com/b/books/other-programming-languages/ml-computer-program-language/_/N-29Z8q8Zvy7</a>
</li>

<li>Strong Typing<br />
<a href="https://perl.plover.com/yak/typing/notes.html">https://perl.plover.com/yak/typing/notes.html</a>
</li>

<li>What to know before debating type systems<br />
<a href="http://blogs.perl.org/users/ovid/2010/08/what-to-know-before-debating-type-systems.html">http://blogs.perl.org/users/ovid/2010/08/what-to-know-before-debating-type-systems.html</a>
</li>

<li>Types, and Why You Should Care (Youtube)<br />
<a href="https://www.youtube.com/watch?v=0arFPIQatCU">https://www.youtube.com/watch?v=0arFPIQatCU</a>
</li>

<li>DynamicTyping (Martin Fowler)<br />
<a href="https://www.martinfowler.com/bliki/DynamicTyping.html">https://www.martinfowler.com/bliki/DynamicTyping.html</a>
</li>

<li>DomainSpecificLanguage (Martin Fowler)<br />
<a href="https://www.martinfowler.com/bliki/DomainSpecificLanguage.html">https://www.martinfowler.com/bliki/DomainSpecificLanguage.html</a>
</li>

<li>Language Workbenches: The Killer-App for Domain Specific Languages?<br />
<a href="https://www.martinfowler.com/articles/languageWorkbench.html">https://www.martinfowler.com/articles/languageWorkbench.html</a>
</li>

<li>Effective ML (Youtube)<br />
<a href="https://www.youtube.com/watch?v=-J8YyfrSwTk">https://www.youtube.com/watch?v=-J8YyfrSwTk</a>
</li>

<li>Why OCaml (Youtube)<br />
<a href="https://www.youtube.com/watch?v=v1CmGbOGb2I">https://www.youtube.com/watch?v=v1CmGbOGb2I</a>
</li>

<li>CSE 341: Functions and patterns<br />
<a href="https://courses.cs.washington.edu/courses/cse341/04wi/lectures/03-ml-functions.html">https://courses.cs.washington.edu/courses/cse341/04wi/lectures/03-ml-functions.html</a>
</li>

<li>Comparing Objective Caml and Standard ML<br />
<a href="http://adam.chlipala.net/mlcomp/">http://adam.chlipala.net/mlcomp/</a>
</li>

<li>What are the key differences between Standard ML and OCaml?<br />
<a href="https://www.quora.com/What-are-the-key-differences-between-Standard-ML-and-OCaml?share=1">https://www.quora.com/What-are-the-key-differences-between-Standard-ML-and-OCaml?share=1</a>
</li>

<li>Cheat Sheets (pro OCaml)<br />
<a href="https://www.ocaml.org/docs/cheat_sheets.html">https://www.ocaml.org/docs/cheat_sheets.html</a>
</li>

<li>Syllabus (FAS CS51)<br />
<a href="https://cs51.io/college/syllabus/">https://cs51.io/college/syllabus/</a>
</li>

<li>Abstraction and Design In Computation<br />
<a href="http://book.cs51.io/">http://book.cs51.io/</a>
</li>

<li>Learn X in Y minutes Where X=Standard ML<br />
<a href="https://learnxinyminutes.com/docs/standard-ml/">https://learnxinyminutes.com/docs/standard-ml/</a>
</li>

<li>CSE307 Online - Summer 2018: Principles of Programing Languages course<br />
<a href="https://www3.cs.stonybrook.edu/~pfodor/courses/summer/cse307.html">https://www3.cs.stonybrook.edu/~pfodor/courses/summer/cse307.html</a>
</li>

<li>CSE307 Principles of Programming Languages course: SML part 1<br />
<a href="https://www.youtube.com/watch?v=p1n0_PsM6hw">https://www.youtube.com/watch?v=p1n0_PsM6hw</a>
</li>

<li>CSE 307 &ndash; Principles of Programming Languages &ndash; SML<br />
<a href="https://www3.cs.stonybrook.edu/~pfodor/courses/summer/CSE307/L01_SML.pdf">https://www3.cs.stonybrook.edu/~pfodor/courses/summer/CSE307/L01_SML.pdf</a>
</li>

<li>SML, Some Basic Examples<br />
<a href="https://cs.fit.edu/~ryan/sml/intro.html">https://cs.fit.edu/~ryan/sml/intro.html</a>
</li>

<li>History of programming languages<br />
<a href="https://devskiller.com/history-of-programming-languages/">https://devskiller.com/history-of-programming-languages/</a>
</li>

<li>History of programming languages (Wikipedia)<br />
<a href="https://en.wikipedia.org/wiki/History_of_programming_languages">https://en.wikipedia.org/wiki/History_of_programming_languages</a>
</li>

<li>Jemný úvod do rozsáhlého světa jazyků LISP a Scheme<br />
<a href="https://www.root.cz/clanky/jemny-uvod-do-rozsahleho-sveta-jazyku-lisp-a-scheme/">https://www.root.cz/clanky/jemny-uvod-do-rozsahleho-sveta-jazyku-lisp-a-scheme/</a>
</li>

<li>The Evolution Of Programming Languages<br />
<a href="https://www.i-programmer.info/news/98-languages/8809-the-evolution-of-programming-languages.html">https://www.i-programmer.info/news/98-languages/8809-the-evolution-of-programming-languages.html</a>
</li>

<li>Evoluce programovacích jazyků<br />
<a href="https://ccrma.stanford.edu/courses/250a-fall-2005/docs/ComputerLanguagesChart.png">https://ccrma.stanford.edu/courses/250a-fall-2005/docs/ComputerLanguagesChart.png</a>
</li>

<li>Poly/ML Homepage<br />
<a href="https://polyml.org/">https://polyml.org/</a>
</li>

<li>PolyConf 16: A brief history of F# / Rachel Reese<br />
<a href="https://www.youtube.com/watch?v=cbDjpi727aY">https://www.youtube.com/watch?v=cbDjpi727aY</a>
</li>

</ol>



<p></p><p></p>
<p><small>Autor: <a href="http://www.fit.vutbr.cz/~tisnovpa">Pavel Tišnovský</a> &nbsp; 2022</small></p>
</body>
</html>

