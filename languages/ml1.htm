<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
        "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html>
<head>
<title>ML - funkcionální jazyk s revolučním typovým systémem</title>
<meta name="Author" content="Pavel Tisnovsky" />
<meta name="Generator" content="vim" />
<meta http-equiv="content-type" content="text/html; charset=utf-8" />
<style type="text/css">
         body {color:#000000; background:#ffffff;}
         h1  {font-family: arial, helvetica, sans-serif; color:#ffffff; background-color:#c00000; text-align:center; padding-left:1em}
         h2  {font-family: arial, helvetica, sans-serif; color:#ffffff; background-color:#0000c0; padding-left:1em; text-align:left}
         h3  {font-family: arial, helvetica, sans-serif; color:#000000; background-color:#c0c0c0; padding-left:1em; text-align:left}
         h4  {font-family: arial, helvetica, sans-serif; color:#000000; background-color:#e0e0e0; padding-left:1em; text-align:left}
         a   {font-family: arial, helvetica, sans-serif;}
         li  {font-family: arial, helvetica, sans-serif; color:#000000; text-align:justify; width:450px;}
         ol  {font-family: arial, helvetica, sans-serif; color:#000000; text-align:justify; width:450px;}
         ul  {font-family: arial, helvetica, sans-serif; color:#000000; text-align:justify; width:450px;}
         p   {font-family: arial, helvetica, sans-serif; color:#000000; text-align:justify;}
         pre {background:#e0e0e0}
</style>
</head>

<body>

<h1>ML - funkcionální jazyk s revolučním typovým systémem</h1>

<h3>Pavel Tišnovský</h3>

<p></p>

<h1>Úvodník</h1>

<p></p>



<h2>Obsah</h2>

<p><a href="#k01">*** 1. ML &ndash; funkcionální jazyk s&nbsp;revolučním typovým systémem</a></p>
<p><a href="#k02">*** 2. Vznik jazyka Standard ML</a></p>
<p><a href="#k03">*** 3. Od Standard ML k&nbsp;jazykům Caml a OCaml</a></p>
<p><a href="#k04">4. Online varianta jazyka Standard ML</a></p>
<p><a href="#k05">5. Instalace Standard ML z&nbsp;nabízených balíčků</a></p>
<p><a href="#k06">6. Instalace Standard ML ze zdrojových kódů</a></p>
<p><a href="#k07">7. Komentáře</a></p>
<p><a href="#k08">8. Výrazy v&nbsp;jazyku ML</a></p>
<p><a href="#k09">9. Proměnné</a></p>
<p><a href="#k10">10. Základní datové typy jazyka ML</a></p>
<p><a href="#k11">*** 11. Složené datové typy</a></p>
<p><a href="#k12">*** 12. </a></p>
<p><a href="#k13">*** 13. </a></p>
<p><a href="#k14">*** 14. </a></p>
<p><a href="#k15">*** 15. </a></p>
<p><a href="#k16">*** 16. </a></p>
<p><a href="#k17">*** 17. Obsah druhé části článku</a></p>
<p><a href="#k18">*** 18. Repositář s&nbsp;demonstračními příklady</a></p>
<p><a href="#k19">19. Literatura</a></p>
<p><a href="#k20">20. Odkazy na Internetu</a></p>



<p><a name="k01"></a></p>
<h2 id="k01">1. ML &ndash; funkcionální jazyk s&nbsp;revolučním typovým systémem</h2>

ML = Meta Language
funkcionalni, modularni, compile time check, type inference

Programming in Standard ML
striktní, staticky typovaný a funkcionální jazyk
type inference
imperativní struktury
pattern matching

ovlivnil další jazyky ze stejné skupiny: OCaml, F#, Haskell, Scalu
ale i mnohé další

Standard ML = standard znamená, že byl jazyk skutečně specifikován
a nikoli založen na referenční implementaci
dalším příkladem může být LISP nebo Algol 68

samotný standard resp. specifikace relativně krátká v porovnání s tím o jak mocný jazyk se jedná

vždy rozhodování mezi svobodou zápisu a potenciálními problémy nebo např.
striktním vyžadováním case analysis atd.

typove informace = part of design process
sweet stop - typovy system, ovsem kratky zapis programu (v porovnani s
tradicnimi staticky typovanymi jazyky)

<p>O typovém systému jazyka <i>ML</i> (a od něj odvozeného <i>OCamlu</i>) se často říká, že se jeho tvůrcům podařilo najít takové řešení, které umožňuje krátký a výstižný zápis algoritmů (což je doménou dynamicky typovaných jazyků), ovšem současně se podařilo zajistit typovou bezpečnost, a to v&nbsp;mnoha případech vyšší, než jaká je očekávána od tradičních staticky typovaných jazyků. Příklady si ukážeme níže a bude z&nbsp;nich patrné, že většina algoritmů implementovaných v&nbsp;<i>ML</i> skutečně nikde neobsahuje explicitně zapsané typové informace &ndash; ty jsou totiž odvozeny ze samotného algoritmu.</p>

<p><div class="rs-tip-major">Poznámka: <i>type inference</i> se začalo prosazovat i v&nbsp;dalších programovacích jazycích, i když někdy jen v&nbsp;omezené míře. Například v&nbsp;jazyku Go lze deklarovat proměnnou pouze uvedením jejího jména a hodnoty, přičemž typ proměnné je odvozen od hodnoty. I taková zdánlivá maličkost ovšem &bdquo;pocitově&ldquo; (styl zápisu, rychlost tvorby nového kódu) jazyk Go posouvá do takové míry, že mi několik vývojářů řeklo &bdquo;ten jazyk je nakonec vlastně hodně podobný Pythonu&ldquo;.</div></p>

20 let kariery, takze prvni tydny ni neznamenaji

inference - odvozování
algebraické datové typy



<p><a name="k02"></a></p>
<h2 id="k02">2. Vznik jazyka Standard ML</h2>

<p>Jazyk ML vznikl v&nbsp;univerzitním prostředí ve Velké Británii, takže se
jedná o další oblast, v&nbsp;níž vznikl nějaký důležitý koncept v&nbsp;oblasti
teorie programovacích jazyků (mezi další takové &bdquo;líhně&ldquo; patřily
pochopitelně USA s&nbsp;MIT, Bell Labs, IBM a taktéž kontinentální Evropa
s&nbsp;Prologem a pascalskou větví programovacích jazyků). První kroky vedoucí
později ke vzniku ML provedla na začátku sedmdesátých let minulého století
skupina vědců z&nbsp;laboratoře pro výzkum umělé inteligence z&nbsp;univerzity
v&nbsp;Edinburgu. Jak bylo v&nbsp;té době v&nbsp;oblasti AI prakticky nepsaným
standardem, používal se převážně <a
href="https://www.root.cz/clanky/jemny-uvod-do-rozsahleho-sveta-jazyku-lisp-a-scheme/">programovací
jazyk LISP</a>, který byl ovšem doplněný o Prolog, což byla tehdy žhavá
novinka, protože Prolog vznikl v&nbsp;roce 1972.</p>

<p><div class="rs-tip-major">Poznámka: traduje se sice rivalita panující mezi
výzkumnými skupinami používajícími LISP se skupinami používajícími Prolog, ale
zde je vidět, že je možné využít možností obou konceptuálně odlišných
jazyků.</div></p>

<p>Výše zmíněná skupina pro oblast umělé inteligence pracovala na vývoji systému <i>LCF</i> (<i>Logic For Computable Functions</i>), jenž byl určen pro dokazování teorémů. Tento systém byl naprogramován v&nbsp;LISPu.</p>

(ostatně stopy LISPu jsou v ML docela patrné)

Robin Milner a jeho skupina začala 1973 skončil 1978
transpilace do LISPu a poté teprve do strojového/objektového kódu

taktéž inspirováno jazykem ISWIM (If you see what I mean.) Petera Landina (šedesátá léta), založen na lambda kalkulu, funkce vyššího řádu atd. z ISWIMu byl odvozen PAL (Pedagogical Algorithmic Language)
nicméně ISWIM používal dynamické typy

novinka - escape traping mechanism
polymorfické typy

zpočátku byl ML součástí LCF a nebylo ho možné používat mimo tento systém (proto se taktéž
někdy setkáme s označením LCF/ML

později vznikl "ML under VAX" neboli "VAX ML", použitelné samostatně
tato varianta byla naprogramována v Pascalu, překladač do strojového kódu VAXu
dokončeno v roce 1981, prakticky zde se začala psát historie skutečně dostupného ML
ostatně je to patrné i na tom, že o rok později
portace do unixu (v Pascalu) 1982
runtime později přepis do C, ovšem samotný překladač zůstal v pascalu

už v roce 1983 meeting Standard ML v Edinburghu
popis ML, na základě toho vznikl i důležitý článek “Compiling a Functional Language”

1985 Caml, první skutečně dostupná verze 1987
objective caml 1996 , OCaml

OCaml 1996 Xavier Leroy, Jérôme Vouillon, Damien Doligez, Didier Rémy




<p><a name="k03"></a></p>
<h2 id="k03">3. Od Standard ML k&nbsp;jazykům Caml a OCaml</h2>

https://ccrma.stanford.edu/courses/250a-fall-2005/docs/ComputerLanguagesChart.png



<p><a name="k04"></a></p>
<h2 id="k04">4. Online varianta jazyka Standard ML</h2>

<p>Jazyk Standard ML si můžete prakticky vyzkoušet, a to hned několika způsoby.
Nejjednodušší resp.&nbsp;časově nejméně náročné je použití online verze, pro
jejíž zprovoznění postačuje pouze nějaký moderní webový prohlížeč
(s&nbsp;JavaScriptem) a není tedy vyžadována instalace klasického
interaktivního prostředí a překladače SML. Online verzí jazyka ML
v&nbsp;současnosti existuje několik, přičemž jedním z&nbsp;příkladů takového
jednoduše pojatého vývojového prostředí je online <i>REPL (Read Eval Print
Loop)</i> dostupný na adrese <a
href="https://sosml.org/">https://sosml.org/</a> (<i>SOSML</i>). Předností této
varianty je fakt, že dlouhotrvající výpočty jsou automaticky ukončeny, čímž je
například zajištěno, že se program &bdquo;zotaví&ldquo; z&nbsp;nekonečné
rekurze. Použití <i>SOSML</i> je jednoduché &ndash; do levého textového pole se
zapisují poznámky, výrazy a definice. Po ukončení výrazu či definice středníkem
je provedeno jeho vyhodnocení a výsledek se zapíše do pravého textového pole
(středník je zde tedy velmi důležitý).  Jak příkazy, tak i jejich výsledky jsou
barevně odlišeny; navíc je odlišeno a případné hlášení o chybě.</p>

*** image ***
<p><i>Obrázek 1: Interaktivní webové prostředí SOSML.</i></p>

<p><div class="rs-tip-major">Poznámka: demonstrační příklady, které si ukážeme
v&nbsp;dalších kapitolách, byly otestovány mj.&nbsp;i právě ve webovém
prostředí SOSML.</div></p>



<p><a name="k05"></a></p>
<h2 id="k05">5. Instalace Standard ML z&nbsp;nabízených balíčků</h2>

<p>Pro plné využití možností nabízených programovacím jazykem ML
(resp.&nbsp;přesněji řečeno Standard ML) již nebude webové uživatelské
prostředí dostačující a bude nutné si nainstalovat nějakou vhodnou nativní
variantu tohoto jazyka. Většina nejvýznamnějších distribucí Linuxu nabízí
nějakou variantu jazyka Standard ML již ve svém standardním repositáři.
Konkrétně se jedná o balíčky <strong>mlton</strong>, <strong>smlnj</strong> či
<strong>polyml</strong> (pokaždé se jedná o jinou implementaci, to nám však
v&nbsp;dnešním článku nemusí vůbec vadit):</p>

<ul>

<li><strong>mlton</strong>: Optimizing compiler for Standard ML MLton is a
whole-program optimizing compiler for Standard ML. MLton generates standalone
executables with excellent runtime performance, is SML 97 compliant, and has a
complete basis library. MLton has source-level profiling, a fast C FFI, an
interface to the GNU multiprecision library, and lots of useful libraries.</li>

<li><strong>smlnj</strong>: SML/NJ is an implementation of the Standard ML
programming language. Standard ML has many features, including type safety,
polymorphism, algebraic data types with pattern matching, higher-order
functions, and a sophisticated module system. It is especially well-suited for
writing compilers and other language processors.</li>

<li><strong>polyml</strong>: interpreter and interactive compiler for Standard
ML. Poly/ML is an implementation of the Standard ML programming language
Standard ML is a general-purpose, modular, type-safe, strict, functional
programming language. Poly/ML is SML 97 compliant interpreter and compiler that
supports the generation of stand-alone executables with an interactive toplevel
(REPL).</li>

</ul>

<p></p>

<pre>
# <strong>dnf install mlton</strong>
&nbsp;
$ <strong>mlton</strong>
</pre>

<pre>
# <strong>dnf install polyml</strong>
&nbsp;
$ <strong>poly -version</strong>
Poly/ML 5.8.2 Release
</pre>

<p><div class="rs-tip-major">Poznámka: <strong>mlton</strong> je překladač,
takže pro interaktivní způsob programování se příliš nehodí. V&nbsp;tomto
ohledu je lepší použít <strong>polyml</strong> či
<strong>smlnj</strong>.</div></p>



<p><a name="k06"></a></p>
<h2 id="k06">6. Instalace Standard ML ze zdrojových kódů</h2>

<p>V&nbsp;případě, že žádný podobný balíček v&nbsp;repositáři vaší distribuce
nenajdete, bude nutné nainstalovat prostředí i překladač jazyka Standard ML ze
zdrojových kódů. Postup není ve skutečnosti příliš složitý (jen časově náročný)
a je popsán v&nbsp;navazujících odstavcích, a to pro pro implementace Standard
ML of New Jersey a Poly/ML.</p>

<p>Nejprve je nutné stáhnout tarball obsahující zdrojové kódy skriptů a dalších
nástrojů určených pro překlad SML:</p>

<pre>
$ <strong>wget http://smlnj.cs.uchicago.edu/dist/working/110.98.1/config.tgz</strong>
&nbsp;
--2020-12-17 20:44:12--  http://smlnj.cs.uchicago.edu/dist/working/110.98.1/config.tgz
Resolving smlnj.cs.uchicago.edu (smlnj.cs.uchicago.edu)... 128.135.164.125
Connecting to smlnj.cs.uchicago.edu (smlnj.cs.uchicago.edu)|128.135.164.125|:80... connected.
HTTP request sent, awaiting response... 200 OK
Length: 517536 (505K) [application/x-gzip]
Saving to: ‘config.tgz’
&nbsp;
config.tgz          100%[===================&gt;] 505.41K   920KB/s    in 0.5s    
&nbsp;
2020-12-17 20:44:13 (920 KB/s) - ‘config.tgz’ saved [517536/517536]
</pre>

<p><div class="rs-tip-major">Poznámka: jak již jméno a ostatně i velikost
staženého tarballu naznačuje, neobsahuje všechny potřebné zdrojové kódy, ale
&bdquo;pouze&ldquo; konfigurační a instalační skripty.</div></p>

<p>Tarball běžným způsobem rozbalíme:</p>

<pre>
$ <strong>tar xvf config.tgz</strong>
</pre>

<p>A spustíme vlastní instalaci:</p>

<pre>
$ <strong>config/install.sh -default 64</strong>
&nbsp;
[scanning (183299-export.cm):driver/(sources.cm):../front-end/(sources.cm):typechecker/(sources.cm):../../back-end/(sources.cm):cxx/(sources.cm):../../views/sources.cm]
[scanning (183299-export.cm):driver/(sources.cm):../front-end/(sources.cm):typechecker/(sources.cm):../../back-end/(sources.cm):cxx/(sources.cm):../util/sources.cm]
[scanning (183299-export.cm):driver/(sources.cm):../front-end/(sources.cm):typechecker/(sources.cm):../../back-end/(sources.cm):sml/sources.cm]
[parsing (183299-export.cm):183299-export.sml]
[creating directory .cm/SKEL]
[compiling (183299-export.cm):183299-export.sml]
[creating directory .cm/GUID]
[creating directory .cm/amd64-unix]
[code: 229, data: 29, env: 39 bytes]
config/install.sh: Installation complete.
</pre>

<p>Po dokončení předchozího kroku by se měl v&nbsp;podadresáři
<strong>bin</strong> objevit mj.&nbsp;i spustitelný soubor nazvaný
<strong>sml</strong>. Po spuštění tohoto souboru se zobrazí REPL (tedy
interaktivní prostředí) jazyka Standard ML:</p>

<pre>
$ <strong>cd bin</strong>
&nbsp;
$ <strong>./sml</strong>
&nbsp;
Standard ML of New Jersey (64-bit) v110.98.1 [built: Thu Dec 17 20:45:35 2021]
</pre>

<p>Překlad a instalace další implementace jazyka Standard ML, konkrétně
projektu <i>Poly/ML</i>, vyžaduje instalaci C++, ovšem celý postup je
snazší:</p>

<p>Nejprve stáhneme poslední verzi zdrojových kódů:</p>

<pre>
$ <strong>wget https://github.com/polyml/polyml/archive/refs/tags/v5.9.tar.gz</strong>
&nbsp;
--2022-02-06 04:59:05--  https://github.com/polyml/polyml/archive/refs/tags/v5.9.tar.gz
Resolving github.com (github.com)... 140.82.112.4
Connecting to github.com (github.com)|140.82.112.4|:443... connected.
HTTP request sent, awaiting response... 302 Found
Location: https://codeload.github.com/polyml/polyml/tar.gz/refs/tags/v5.9 [following]
--2022-02-06 04:59:05--  https://codeload.github.com/polyml/polyml/tar.gz/refs/tags/v5.9
Resolving codeload.github.com (codeload.github.com)... 140.82.113.9
Connecting to codeload.github.com (codeload.github.com)|140.82.113.9|:443... connected.
HTTP request sent, awaiting response... 200 OK
Length: unspecified [application/x-gzip]
Saving to: ‘v5.9.tar.gz’
&nbsp;
v5.9.tar.gz             [    &lt;=&gt;  ]   3.59M  5.54MB/s    in 0.6s    
&nbsp;
2022-02-06 04:59:06 (5.54 MB/s) - ‘v5.9.tar.gz’ saved [3764115]
</pre>

<p>Získaný tarball rozbalíme:</p>

<pre>
$ <strong>tar xvfz v5.9.tar.gz</strong>
</pre>

<p>Provedeme konfiguraci projektu, a to zcela standardním způsobem:</p>

<pre>
$ <strong>cd polyml-5.9/</strong>
$ <strong>./configure</strong>
</pre>

<p>Následuje vlastní překlad:</p>

<pre>
$ <strong>make</strong>
</pre>

<p>Nakonec otestujeme, zda je možné interaktivní běhové prostředí spustit a
použít:</p>

<pre>
$ <strong>./poly</strong>
Poly/ML 5.9 Release
&nbsp;
&gt; <strong>6*7;</strong>
val it = 42: int
</pre>



<p><a name="k07"></a></p>
<h2 id="k07">7. Komentáře</h2>

<p><div class="rs-tip-major">Poznámka na úvod: <i>syntaxe</i> jazyka ML
resp.&nbsp;Standard ML může být na první pohled poněkud podivná, zejména pro
programátory, kteří pracují s&nbsp;programovacími jazyky patřícími do céčkové
větve (tedy například s&nbsp;C, C++, Javou, JavaScriptem či C#). Ovšem
v&nbsp;praxi se ukazuje, že <i>syntaxe</i> je tím nejmenším problémem, protože
důležitá je především <i>sémantika</i> a na tu se po popisu základních konceptů
zaměříme (ostatně například Caml/OCaml dovolují vytvořit si v&nbsp;případě
potřeby vlastní syntaxi).</div></p>

<p>Nyní, když máme k&nbsp;dispozici na výběr mezi <a href="#k04">webovým
rozhraním</a> a <a href="#k05">řádkovým (terminálovým) rozhraním jazyka
SML</a>, si můžeme popsat a ihned také ukázat základní vlastnosti
programovacího jazyka ML. Začneme tím nejzákladnějším (a nejméně
problematickým) prvkem jazyka, kterým jsou komentáře. Ty se zapisují
&bdquo;Pascalovským&ldquo; způsobem mezi dvojici komentářových závorek
<strong>(*</strong> a <strong>*)</strong>, tedy následovně:</p>

<pre>
<i>(* komentáře *)</i>
</pre>

<p>Komentáře mohou být v&nbsp;případě potřeby víceřádkové, takže je možné
například zakomentovat celý blok s&nbsp;definicí funkce:</p>

<pre>
<i>(*</i>
<i>fun fib 0 = 0</i>
<i>  | fib 1 = 1</i>
<i>  | fib n = fib (n - 1) + fib (n - 2)</i>
<i>*)</i>
</pre>

<p><div class="rs-tip-major">Poznámka: prozatím se netrapte tím, <i>jak</i>
zápis funkce vypadá. K&nbsp;tomuto problému se dostaneme později.</div></p>

<p>Velmi užitečné je, že komentáře mohou (na rozdíl od mnoha céčkových jazyků)
obsahovat další komentáře, takže je snadné například zakomentovat část kódu,
která obsahuje běžné komentáře:</p>

<pre>
<i>(*</i>
<i>(* Výpočet Fibonacciho posloupnosti *)</i>
<i>fun fib 0 = 0</i>
<i>  | fib 1 = 1</i>
<i>  | fib n = fib (n - 1) + fib (n - 2)</i>
<i>*)</i>
</pre>



<p><a name="k08"></a></p>
<h2 id="k08">8. Výrazy v&nbsp;jazyku ML</h2>

<p>Nyní si ukažme práci s&nbsp;výrazy. Samotné výrazy (více o nich níže) se
zapisují přímo, není zapotřebí je nějakým způsobem speciálně označovat:</p>

<pre>
<strong>výraz</strong>
</pre>

<p><div class="rs-tip-major">Poznámka: některé varianty jazyka ML vykonají
(resp.&nbsp;přesněji řečeno vyhodnotí) výraz až ve chvíli, kdy je za něj zapsán
středník:</div></p>

<pre>
<strong>výraz;</strong>
</pre>

<p>Příklad výrazů s&nbsp;jejich okamžitým vyhodnocením:</p>

<pre>
&gt; <strong>1;</strong>
val it = 1: int
&nbsp;
&gt; <strong>6*7;</strong>
val it = 42: int
&nbsp;
&gt; <strong>"foo";</strong>
val it = "foo": string
&nbsp;
&gt; <strong>[1, 2, 3];</strong>
val it = [1, 2, 3]: int list
&nbsp;
&gt; <strong>false;</strong>
val it = false: bool
</pre>

<p>Povšimněte si důležité vlastnosti jazyka ML &ndash; výsledek vyhodnocení
výrazu není tvořen pouze vypočtenou hodnotou, ale <i>vždy</i> obsahuje i
informace o typu této hodnoty.</p>

<p>Součástí výrazu může být i volání funkce:</p>

<pre>
&gt; <strong>abs(1-5);</strong>
val it = 4: int
</pre>

<p>Volání funkce s&nbsp;jedním parametrem lze zapsat se závorkami okolo
parametru či bez závorek:</p>

<pre>
&gt; <strong>abs(1);</strong>
val it = 4: int
&nbsp;
&gt; <strong>abs 1;</strong>
val it = 1: int
</pre>

<p>Ovšem pozor je zapotřebí dát u funkcí s&nbsp;více parametry:</p>

<pre>
&gt; <strong>abs(1-5);</strong>
val it = 4: int
&nbsp;
&gt; <strong>abs 1-5;</strong>
val it = ~4: int
</pre>

<p>V&nbsp;prvním případě se vrátila hodnota 4, tedy skutečně absolutní hodnota
rozdílu 1-5. Ve druhém případě se vrátila hodnota -4, což je výsledek rozdílu
mezi absolutní hodnotou 1 a 5.</p>

<p><div class="rs-tip-major">Poznámka: zde můžeme vidět další (dnes)
nestandardní syntaxi jazyka ML &ndash; záporné hodnoty se zapisují pomocí znaku
&bdquo;~&ldquo;.</div></p>



<p><a name="k09"></a></p>
<h2 id="k09">9. Proměnné</h2>

<p>Proměnné, které jsou v&nbsp;jazyce ML vždy silně typované (tj.&nbsp;typ je
přiřazen i k&nbsp;proměnné, nikoli k&nbsp;hodnotě) se deklarují s&nbsp;využitím
slova <strong>val</strong>. Opět si ukažme několik příkladů:</p>

<pre>
&gt; <strong>val x = 10;</strong>
val x = 10: int
&nbsp;
&gt; <strong>val y = 3.14;</strong>
val y = 3.14: real
&nbsp;
&gt; <strong>val z = true;</strong>
val z = true: bool
&nbsp;
&gt; <strong>val w = "foobar";</strong>
val w = "foobar": string
</pre>

<p>Zde jsme narazili na první důležitý koncept programovacího jazyka ML. Tento
koncept se nazývá <i>odvození typů</i> neboli <i>type inference</i>. Spočívá
v&nbsp;tom, že na základě typu <i>hodnoty</i> dokáže ML odvodit i typ
<i>proměnné</i>, <i>výrazu</i> nebo parametru či návratové hodnoty
<i>funkce</i>. Výše uvedený příklad povede k&nbsp;automatickému odvození typů
všech čtyř proměnných, typ se od této chvíle stává součástí metainformace o
proměnných.</p>

<p>Totéž platí i pro proměnné, jimž je přiřazen výsledek nějakého složitějšího
výrazu:</p>

<pre>
&gt; <strong>val a = 6*7;</strong>
val a = 42: int
&nbsp;
&gt; <strong>val b = 10.0 / 4.0;</strong>
val b = 2.5: real
&nbsp;
&gt; <strong>val c = 10 div 4;</strong>
val c = 2: int
</pre>

<p>Výsledek posledního výrazu je uložen do speciální proměnné nazvané
<strong>it</strong>:</p>

<pre>
&gt; <strong>42;</strong>
val it = 42: int;
</pre>

<p>Obsah i typ této proměnné je neustále přepisován:</p>

<pre>
&gt; <strong>1;</strong>
val it = 1: int
&nbsp;
&gt; <strong>it;</strong>
val it = 1: int
&nbsp;
&gt; <strong>1+2;</strong>
val it = 3: int
&nbsp;
&gt; <strong>it;</strong>
val it = 3: int
</pre>



<p><a name="k10"></a></p>
<h2 id="k10">10. Základní datové typy jazyka ML</h2>

<p>S&nbsp;některými datovými typy, které jsou jazykem ML podporovány, jsme se
(vlastně trošku mimochodem) setkali v&nbsp;předchozích kapitolách. Ovšem pro
další články o ML je nutné zmínit všechny podporované datové typy.</p>

<p>První datový typ se jmenuje <i>unit</i>, ovšem většinou se mu říká
&bdquo;null type&ldquo;. Je reprezentován prázdnými kulatými závorkami a
technicky se jedná o n-tici bez prvků:</p>

<pre>
&gt; <strong>();</strong>
val it = (): unit
</pre>

<p><div class="rs-tip-major">Poznámka: tento datový typ je v&nbsp;praxi velmi
užitečný. Podobným typem známým z&nbsp;céčkovské větve jazyků je typ
<strong>void</strong>, jehož jméno ovšem (chybně?) naznačuje, že neexistuje
žádný prvek tohoto typu.</div></p>

<p>Dalším datovým typem je typ <i>bool</i>. Ten již není, na rozdíl od typu
<i>unit</i> nijak výjimečný. Obsahuje dvě hodnoty <strong>true</strong> a
<strong>false</strong>:</p>

<pre>
&gt; <strong>true;</strong>
val it = true: bool
&nbsp;
&gt; <strong>false;</strong>
val it = false: bool
</pre>

<p>Následuje celočíselný typ <i>int</i>, u něhož je zvláštní fakt, že se
záporné hodnoty zapisují s&nbsp;tildou a nikoli znakem &bdquo;-&ldquo;:</p>

<pre>
&gt; <strong>42;</strong>
val it = 42: int
&nbsp;
&gt; <strong>0 - 42;</strong>
val it = ~42: int
</pre>

<p>Přetečení může být v&nbsp;některých případech detekováno již v&nbsp;čase
překladu (což ovšem není nic překvapujícího):</p>

<pre>
&gt; <strong>10000000000000000000000000;</strong>
poly: : error: Overflow exception raised while converting 10000000000000000000000000 to int
Found near 10000000000000000000000000
Static Errors
</pre>

<p>Následuje datový typ <i>real</i>, jehož hodnoty jsou interně reprezentovány
s&nbsp;využitím systému s&nbsp;plovoucí řádovou čárkou:</p>

<pre>
&gt; <strong>3.14;</strong>
val it = 3.14: real
&nbsp;
&gt; <strong>0.0 - 3.14;</strong>
val it = ~3.14: real
</pre>

<p>Následují řetězce, neboli typ <i>string</i>:</p>

<pre>
&gt; <strong>"foobar";</strong>
val it = "foobar": string
</pre>

<p>A konečně typ <i>char</i> reprezentující jediný znak:</p>

<pre>
&gt; <strong>#"a";</strong>
val it = #"a": char
&nbsp;
&gt; <strong>#"ab";</strong>
poly: : error: Conversion exception (Not exactly one character) raised while converting ab to char
Found near #"ab"
Static Errors
</pre>



<p><a name="k11"></a></p>
<h2 id="k11">11. Složené datové typy</h2>

> ();
val it = (): unit
> (1,2);
val it = (1, 2): int * int
> ("foo", "bar");
val it = ("foo", "bar"): string * string
> (1, "foo", 3.14);
val it = (1, "foo", 3.14): int * string * real

> {color="silver",make="Toyota",model="Corolla",year=1986}
# ;
val it = {color = "silver", make = "Toyota", model = "Corolla", year = 1986}:
   {color: string, make: string, model: string, year: int}

> [];
val it = []: 'a list
> [1,2,3];
val it = [1, 2, 3]: int list
> ["foo", "bar"];
val it = ["foo", "bar"]: string list
> [1, "foo"];
poly: : error: Elements in a list have different types.
   Item 1: 1 : int
   Item 2: "foo" : string
   Reason:
      Can't unify int (*In Basis*) with string (*In Basis*)
         (Different type constructors)
Found near [1, "foo"]
Static Errors





val i = 10
val j : real = 10.0
val k = i

val lexpr =
  let val x = 1
      val y = 2
  in x + y
  end
val lexpr = 3 : int


seznamy
stejne typy prvku!

Příklady seznamů

[];
[1,2,3];
["foo","bar"];

seznam je:
bud prazdny
nebo ma formu h::t (head, tail)
[7] je shodny s 7::[]
pro konstrukci seznamu nebo pro ziskavani prvku ze seznamu

některé důležité funkce pro práci se seznamy
null(x)
hd(x) head
tl(x) tail

cons je nahrazen za
a::x konstrukce


funkce
fun <name> <formalni-parametry> = <body>
fun inc n = n + 1;
^
automaticke odvozeni typu parametru i funkce
f(x) nebo f x
f g x znamena (f g) x <- leva asociativita

Poněkud naivní implementace
postupné zjednodušování řešeného problému - redukce seznamu
odstraněním jeho prvního prvku

fun length(x) = if null(x) then 0
                else 1 + length(tl(x));

lineární rekurze
protože funkce length() volá sebe samu jen jeden krát a 
na pravé straně výrazu

append(x,y)
vraci novy seznam obsahujici nejrpve prvky z x a pote z y
append([1,2], [3,4,5])
[1,2,3,4,5]

nebo taktez
[1,2] @ [3,4,5]

plati: append([],z) == z
plati: append(a :: y, z) == a :: append(y,z)

primo z techto podminek je mozne odvodit implementaci funkce append

fun append(x, y) = if null(x) then y
                   else hd(x) :: append(tl(x), y)

navíc je zaručeno splnění okrajové podmínky, tedy situace, kdy
je jeden ze seznamů prázdný

append([1,2], [3,4,5])
postupné vykonání fází navíjení a odvíjení
1 :: append([2], [3,4,5])
1 :: 2 :: append([], [3,4,5])
1 :: 2 :: [3,4,5]
1 :: [2,3,4,5]
[1,2,3,4,5]


reverse(x, y)
- otočení x přidání před z
reverse([2, 3, 4], [1]) == [4, 3, 2, 1]

opět bude platit
reverse([], y) = y
reverse(a :: x, y) = reverse(x, a :: y)

fun reverse(x, y) = if null(x) then y
                    else reverse(tl(x), hd(x)::y)

reverse([2, 3, 4], [1])
reverse([3, 4], 2 :: [1])
reverse([3, 4], [2, 1])
reverse([4], 3 :: [2, 1])
reverse([4], [3, 2, 1])
reverse([],  4 :: [3, 2, 1])
reverse([],  [4, 3, 2, 1])
[4, 3, 2, 1]

case analysis, patterns

fun <jméno> <vzorek> = <tělo/výraz>

příklady
fun first(x, y) = x
fun first(x, _) = x

ovšem vzorkem může být například i a::x nebo (x,y)

více vzorků využívá se operátor "or"

fun <jméno> <vzorek> = <tělo/výraz>
|   <jméno> <vzorek> = <tělo/výraz>
|   <jméno> <vzorek> = <tělo/výraz>
|   <jméno> <vzorek> = <tělo/výraz>

fun car(x::y) = x;

car([1,2,3]);
car(["foo", "bar"]);
car(["first"]);
car([]);



&gt; val car = fn: ∀ 'a . 'a list → 'a;

WARN: Pattern matching is not exhaustive.

&gt; val it = 1: int;

&gt; val it = "foo": string;

&gt; val it = "first": string;

Uncaught SML exception: Match



fun car([]) = 0
  | car(x::y) = x;

car([1,2,3]);
car([]);

&gt; val car = fn: int list → int;

&gt; val it = 1: int;

&gt; val it = 0: int;


fun car nil = raise Empty
  | car(x::y) = x;

car([1,2,3]);
car([]);

&gt; val car = fn: ∀ 'a . 'a list → 'a;

&gt; val it = 1: int;

Uncaught SML exception: Empty



fun length(x) = if null(x) then 0
                else 1 + length(tl(x));

fun length([]) = 0
|   length(a::x) = 1 + length(x)


fun fib n =
    if n = 0 then 0 else
    if n = 1 then 1 else
    fib (n - 1) + fib (n - 2)

fun fib 0 = 0
  | fib 1 = 1
  | fib n = fib (n - 1) + fib (n - 2)


fun map f [] = []
  | map f (a::x) = (f a) :: (map f y)

fun inc x = x + 1;

map inc [1,2,3];

&gt; val map = fn: ∀ 'a 'b . ('a → 'b) → 'a list → 'b list;

&gt; val inc = fn: int → int;

&gt; val it = [2, 3, 4]: int list;

ofun map f [] = []
  | map f (a::x) = (f a) :: (map f x)


fun inc x = x + 1;

map inc [1,2,3];

fun half x = x / 2.0;


map half [1.0, 2.0, 3.0];

map half [1,2,3];

Elaboration failed: Type clash. Functions of type "real list → real list" cannot take an argument of type "int list": Cannot merge "real" and "int".


<p>V&nbsp;programovacím jazyku ML je možné deklarovat i anonymní funkce. Opět se nejedná o nic překvapivého, zvláště když si uvědomíme, kolik <i>sémantiky</i> (nikoli však <i>syntaxe</i>) bylo převzato z&nbsp;Lispovských jazyků. Anonymní funkce se deklaruje slovem <strong>fn</strong> a používá se zde znak šipky =&gt;. Příkladem jednoduché anonymní funkce je funkce, která vrátí hodnotu svého parametru zvýšeného o jedničku (jedná se tedy o funkci s&nbsp;parametrem typu <strong>int</strong> a návratovou hodnotou typu <strong>int</strong>):</p>

<pre>
<strong>fn x =&gt; 1 + x;</strong>
&nbsp;
&gt; val it = fn: int → int;
</pre>

<p>Pochopitelně je možné vytvořit i anonymní funkce akceptující větší množství parametrů:</p>

<pre>
<strong>fn (x, y) =&gt; x + y;</strong>
&nbsp;
&gt; val it = fn: int * int → int;
</pre>

map(fn x =&gt; 1 + x)[1,2,3]


&gt; val it = [2, 3, 4]: int list;


fun fib (0, operator) = 0
  | fib (1, operator) = 1
  | fib (n, operator) = operator(fib (n - 1, operator), fib (n - 2, operator))

fib(20, fn (x, y) =&gt; x + y);

&gt; val fib = fn: int * (int * int → int) → int;

&gt; val it = 6765: int;

fib(20, fn (x, y) =&gt; x + y + 1);



&gt; val fib = fn: int * (int * int → int) → int;

&gt; val it = 17710: int;


fun divide (x, 0) = NONE
  | divide (x, y) = SOME (x div y);

divide(10, 0);
divide(10, 3);



<p><a name="k10"></a></p>
<h2 id="k10">10. </h2>



<p><a name="k13"></a></p>
<h2 id="k13">13. </h2>



<p><a name="k14"></a></p>
<h2 id="k14">14. </h2>



<p><a name="k15"></a></p>
<h2 id="k15">15. </h2>



<p><a name="k16"></a></p>
<h2 id="k16">16. </h2>



<p><a name="k17"></a></p>
<h2 id="k17">17. Obsah druhé části článku</h2>

<p></p>



<p><a name="k18"></a></p>
<h2 id="k18">18. Repositář s&nbsp;demonstračními příklady</h2>



<p><a name="k19"></a></p>
<h2 id="k19">19. Literatura</h2>

<p><div class="rs-tip-major">Poznámka: v&nbsp;této kapitole jsou uvedeny
nejenom knihy o jazyku ML resp.&nbsp;Standard ML, ale i knihy o programovacím
jazyku OCaml, který ze Standard ML ze značné míry vychází.</div></p>

<ol>

<li>ML for the Working Programmer<br />
<a href="https://www.cl.cam.ac.uk/~lp15/MLbook/pub-details.html">https://www.cl.cam.ac.uk/~lp15/MLbook/pub-details.html</a>
</li>

<li>Elements of ML Programming, 2nd Edition (ML97)<br />
<a href="http://infolab.stanford.edu/~ullman/emlp.html">http://infolab.stanford.edu/~ullman/emlp.html</a>
</li>

<li>A tour of Standard ML<br />
<a href="https://saityi.github.io/sml-tour/tour/welcome">https://saityi.github.io/sml-tour/tour/welcome</a>
</li>

<li>The History of Standard ML<br />
<a href="https://smlfamily.github.io/history/SML-history.pdf">https://smlfamily.github.io/history/SML-history.pdf</a>
</li>

<li>The Standard ML Basis Library<br />
<a href="https://smlfamily.github.io/Basis/">https://smlfamily.github.io/Basis/</a>
</li>

<li>Programming in Standard ML<br />
<a href="http://www.cs.cmu.edu/~rwh/isml/book.pdf">http://www.cs.cmu.edu/~rwh/isml/book.pdf</a>
</li>

<li>Programming in Standard ML '97: A Tutorial Introduction<br />
<a href="http://www.lfcs.inf.ed.ac.uk/reports/97/ECS-LFCS-97-364/">http://www.lfcs.inf.ed.ac.uk/reports/97/ECS-LFCS-97-364/</a>
</li>

<li>Programming in Standard ML '97: An On-line Tutorial<br />
<a href="https://homepages.inf.ed.ac.uk/stg/NOTES/">https://homepages.inf.ed.ac.uk/stg/NOTES/</a>
</li>

<li>The OCaml system  release 4.13<br />
<a href="https://ocaml.org/releases/4.13/htmlman/index.html">https://ocaml.org/releases/4.13/htmlman/index.html</a>
</li>

<li>Real World OCaml: Functional programming for the masses<br />
<a href="https://dev.realworldocaml.org/">https://dev.realworldocaml.org/</a>
</li>

<li>OCaml from the Very Beginning<br />
<a href="http://ocaml-book.com/">http://ocaml-book.com/</a>
</li>

<li>OCaml from the Very Beginning: More OCaml : Algorithms, Methods &amp; Diversions<br />
<a href="http://ocaml-book.com/more-ocaml-algorithms-methods-diversions/">http://ocaml-book.com/more-ocaml-algorithms-methods-diversions/</a>
</li>

<li>Unix system programming in OCaml<br />
<a href="http://ocaml.github.io/ocamlunix/">http://ocaml.github.io/ocamlunix/</a>
</li>

<li>OCaml for Scientists<br />
<a href="https://www.ffconsultancy.com/products/ocaml_for_scientists/index.html">https://www.ffconsultancy.com/products/ocaml_for_scientists/index.html</a>
</li>

<li>Using, Understanding, and Unraveling The OCaml Language<br />
<a href="https://caml.inria.fr/pub/docs/u3-ocaml/">https://caml.inria.fr/pub/docs/u3-ocaml/</a>
</li>

<li>Developing Applications With objective Caml<br />
<a href="https://caml.inria.fr/pub/docs/oreilly-book/index.html">https://caml.inria.fr/pub/docs/oreilly-book/index.html</a>
</li>

<li>Introduction to Objective Caml<br />
<a href="http://courses.cms.caltech.edu/cs134/cs134b/book.pdf">http://courses.cms.caltech.edu/cs134/cs134b/book.pdf</a>
</li>

<li>How to Think Like a (Functional) Programmer<br />
<a href="https://greenteapress.com/thinkocaml/index.html">https://greenteapress.com/thinkocaml/index.html</a>
</li>

</ol>



<p><a name="k20"></a></p>
<h2 id="k20">20. Odkazy na Internetu</h2>

<ol>

<li>Standard ML of New Jersey<br />
<a href="https://www.smlnj.org/">https://www.smlnj.org/</a>
</li>

<li>Programming Languages: Standard ML - 1 (a navazující videa)<br />
<a href="https://www.youtube.com/watch?v=2sqjUWGGzTo">https://www.youtube.com/watch?v=2sqjUWGGzTo</a>
</li>

<li>6 Excellent Free Books to Learn Standard ML<br />
<a href="https://www.linuxlinks.com/excellent-free-books-learn-standard-ml/">https://www.linuxlinks.com/excellent-free-books-learn-standard-ml/</a>
</li>

<li>SOSML: The Online Interpreter for Standard ML<br />
<a href="https://sosml.org/">https://sosml.org/</a>
</li>

<li>ML (Computer program language)<br />
<a href="https://www.barnesandnoble.com/b/books/other-programming-languages/ml-computer-program-language/_/N-29Z8q8Zvy7">https://www.barnesandnoble.com/b/books/other-programming-languages/ml-computer-program-language/_/N-29Z8q8Zvy7</a>
</li>

<li>Strong Typing<br />
<a href="https://perl.plover.com/yak/typing/notes.html">https://perl.plover.com/yak/typing/notes.html</a>
</li>

<li>What to know before debating type systems<br />
<a href="http://blogs.perl.org/users/ovid/2010/08/what-to-know-before-debating-type-systems.html">http://blogs.perl.org/users/ovid/2010/08/what-to-know-before-debating-type-systems.html</a>
</li>

<li>Types, and Why You Should Care (Youtube)<br />
<a href="https://www.youtube.com/watch?v=0arFPIQatCU">https://www.youtube.com/watch?v=0arFPIQatCU</a>
</li>

<li>DynamicTyping (Martin Fowler)<br />
<a href="https://www.martinfowler.com/bliki/DynamicTyping.html">https://www.martinfowler.com/bliki/DynamicTyping.html</a>
</li>

<li>DomainSpecificLanguage (Martin Fowler)<br />
<a href="https://www.martinfowler.com/bliki/DomainSpecificLanguage.html">https://www.martinfowler.com/bliki/DomainSpecificLanguage.html</a>
</li>

<li>Language Workbenches: The Killer-App for Domain Specific Languages?<br />
<a href="https://www.martinfowler.com/articles/languageWorkbench.html">https://www.martinfowler.com/articles/languageWorkbench.html</a>
</li>

<li>Effective ML (Youtube)<br />
<a href="https://www.youtube.com/watch?v=-J8YyfrSwTk">https://www.youtube.com/watch?v=-J8YyfrSwTk</a>
</li>

<li>Why OCaml (Youtube)<br />
<a href="https://www.youtube.com/watch?v=v1CmGbOGb2I">https://www.youtube.com/watch?v=v1CmGbOGb2I</a>
</li>

<li>CSE 341: Functions and patterns<br />
<a href="https://courses.cs.washington.edu/courses/cse341/04wi/lectures/03-ml-functions.html">https://courses.cs.washington.edu/courses/cse341/04wi/lectures/03-ml-functions.html</a>
</li>

<li>Comparing Objective Caml and Standard ML<br />
<a href="http://adam.chlipala.net/mlcomp/">http://adam.chlipala.net/mlcomp/</a>
</li>

<li>What are the key differences between Standard ML and OCaml?<br />
<a href="https://www.quora.com/What-are-the-key-differences-between-Standard-ML-and-OCaml?share=1">https://www.quora.com/What-are-the-key-differences-between-Standard-ML-and-OCaml?share=1</a>
</li>

<li>Cheat Sheets (pro OCaml)<br />
<a href="https://www.ocaml.org/docs/cheat_sheets.html">https://www.ocaml.org/docs/cheat_sheets.html</a>
</li>

<li>Syllabus (FAS CS51)<br />
<a href="https://cs51.io/college/syllabus/">https://cs51.io/college/syllabus/</a>
</li>

<li>Abstraction and Design In Computation<br />
<a href="http://book.cs51.io/">http://book.cs51.io/</a>
</li>

<li>Learn X in Y minutes Where X=Standard ML<br />
<a href="https://learnxinyminutes.com/docs/standard-ml/">https://learnxinyminutes.com/docs/standard-ml/</a>
</li>

<li>CSE307 Online - Summer 2018: Principles of Programing Languages course<br />
<a href="https://www3.cs.stonybrook.edu/~pfodor/courses/summer/cse307.html">https://www3.cs.stonybrook.edu/~pfodor/courses/summer/cse307.html</a>
</li>

<li>CSE307 Principles of Programming Languages course: SML part 1<br />
<a href="https://www.youtube.com/watch?v=p1n0_PsM6hw">https://www.youtube.com/watch?v=p1n0_PsM6hw</a>
</li>

<li>CSE 307 &ndash; Principles of Programming Languages &ndash; SML<br />
<a href="https://www3.cs.stonybrook.edu/~pfodor/courses/summer/CSE307/L01_SML.pdf">https://www3.cs.stonybrook.edu/~pfodor/courses/summer/CSE307/L01_SML.pdf</a>
</li>

<li>SML, Some Basic Examples<br />
<a href="https://cs.fit.edu/~ryan/sml/intro.html">https://cs.fit.edu/~ryan/sml/intro.html</a>
</li>

<li>History of programming languages<br />
<a href="https://devskiller.com/history-of-programming-languages/">https://devskiller.com/history-of-programming-languages/</a>
</li>

<li>History of programming languages (Wikipedia)<br />
<a href="https://en.wikipedia.org/wiki/History_of_programming_languages">https://en.wikipedia.org/wiki/History_of_programming_languages</a>
</li>

<li>Jemný úvod do rozsáhlého světa jazyků LISP a Scheme<br />
<a href="https://www.root.cz/clanky/jemny-uvod-do-rozsahleho-sveta-jazyku-lisp-a-scheme/">https://www.root.cz/clanky/jemny-uvod-do-rozsahleho-sveta-jazyku-lisp-a-scheme/</a>
</li>

<li>The Evolution Of Programming Languages<br />
<a href="https://www.i-programmer.info/news/98-languages/8809-the-evolution-of-programming-languages.html">https://www.i-programmer.info/news/98-languages/8809-the-evolution-of-programming-languages.html</a>
</li>

<li>Evoluce programovacích jazyků<br />
<a href="https://ccrma.stanford.edu/courses/250a-fall-2005/docs/ComputerLanguagesChart.png">https://ccrma.stanford.edu/courses/250a-fall-2005/docs/ComputerLanguagesChart.png</a>
</li>

<li>Poly/ML Homepage<br />
<a href="https://polyml.org/">https://polyml.org/</a>
</li>

</ol>



<p></p><p></p>
<p><small>Autor: <a href="http://www.fit.vutbr.cz/~tisnovpa">Pavel Tišnovský</a> &nbsp; 2022</small></p>
</body>
</html>

