<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
        "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html>
<head>
<title></title>
<meta name="Author" content="Pavel Tisnovsky" />
<meta name="Generator" content="vim" />
<meta http-equiv="content-type" content="text/html; charset=utf-8" />
<style type="text/css">
         body {color:#000000; background:#ffffff;}
         h1  {font-family: arial, helvetica, sans-serif; color:#ffffff; background-color:#c00000; text-align:center; padding-left:1em}
         h2  {font-family: arial, helvetica, sans-serif; color:#ffffff; background-color:#0000c0; padding-left:1em; text-align:left}
         h3  {font-family: arial, helvetica, sans-serif; color:#000000; background-color:#c0c0c0; padding-left:1em; text-align:left}
         h4  {font-family: arial, helvetica, sans-serif; color:#000000; background-color:#e0e0e0; padding-left:1em; text-align:left}
         a   {font-family: arial, helvetica, sans-serif;}
         li  {font-family: arial, helvetica, sans-serif; color:#000000; text-align:justify; width:450px;}
         ol  {font-family: arial, helvetica, sans-serif; color:#000000; text-align:justify; width:450px;}
         ul  {font-family: arial, helvetica, sans-serif; color:#000000; text-align:justify; width:450px;}
         p   {font-family: arial, helvetica, sans-serif; color:#000000; text-align:justify;}
         pre {background:#e0e0e0}
</style>
</head>

<body>

<h1></h1>

<h3>Pavel Tišnovský</h3>

<p></p>

<h1>Úvodník</h1>

<p></p>



<h2>Obsah</h2>

<p><a href="#k01">*** 1. </a></p>
<p><a href="#k02">*** 2. </a></p>
<p><a href="#k03">*** 3. Od Standard ML k&nbsp;jazykům Caml a OCaml</a></p>
<p><a href="#k04">*** 4. Instalace Standard ML</a></p>
<p><a href="#k05">*** 5. </a></p>
<p><a href="#k06">*** 6. </a></p>
<p><a href="#k07">*** 7. </a></p>
<p><a href="#k08">*** 8. </a></p>
<p><a href="#k09">*** 9. </a></p>
<p><a href="#k10">*** 10. </a></p>
<p><a href="#k11">*** 11. </a></p>
<p><a href="#k12">*** 12. </a></p>
<p><a href="#k13">*** 13. </a></p>
<p><a href="#k14">*** 14. </a></p>
<p><a href="#k15">*** 15. </a></p>
<p><a href="#k16">*** 16. </a></p>
<p><a href="#k17">*** 17. </a></p>
<p><a href="#k18">*** 18. </a></p>
<p><a href="#k19">*** 19. </a></p>
<p><a href="#k20">*** 20. Odkazy na Internetu</a></p>



<p><a name="k01"></a></p>
<h2 id="k01">1. </h2>

ML = Meta Language
funkcionalni, modularni, compile time check, type inference

Programming in Standard ML
striktní, staticky typovaný a funkcionální jazyk
type inference
imperativní struktury
pattern matching

ovlivnil další jazyky ze stejné skupiny: OCaml, F#, Haskell, Scalu
ale i mnohé další

Standard ML = standard znamená, že byl jazyk skutečně specifikován
a nikoli založen na referenční implementaci
dalším příkladem může být LISP nebo Algol 68

samotný standard resp. specifikace relativně krátká v porovnání s tím o jak mocný jazyk se jedná

vždy rozhodování mezi svobodou zápisu a potenciálními problémy nebo např.
striktním vyžadováním case analysis atd.

typove informace = part of design process
sweet stop - typovy system, ovsem kratky zapis programu (v porovnani s
tradicnimi staticky typovanymi jazyky)

20 let kariery, takze prvni tydny ni neznamenaji


<p><a name="k02"></a></p>
<h2 id="k02">2. </h2>

britská univerzitní kultura
konkrétně univerzita v Edinburgu, skupina pro AI používající LISP a Prolog
(ostatně stopy LISPu jsou v ML docela patrné)

Robin Milner a jeho skupina začala 1973 skončil 1978
založeno na systému LCF pro dokazování teorémů (ten byl naprogramován v lispu)
transpilace do LISPu a poté teprve do strojového/objektového kódu

taktéž inspirováno jazykem ISWIM (If you see what I mean.) Petera Landina (šedesátá léta), založen na lambda kalkulu, funkce vyššího řádu atd. z ISWIMu byl odvozen PAL (Pedagogical Algorithmic Language)
nicméně ISWIM používal dynamické typy

novinka - escape traping mechanism
polymorfické typy

zpočátku byl ML součástí LCF a nebylo ho možné používat mimo tento systém (proto se taktéž
někdy setkáme s označením LCF/ML

později vznikl "ML under VAX" neboli "VAX ML", použitelné samostatně
tato varianta byla naprogramována v Pascalu, překladač do strojového kódu VAXu
dokončeno v roce 1981, prakticky zde se začala psát historie skutečně dostupného ML
ostatně je to patrné i na tom, že o rok později
portace do unixu (v Pascalu) 1982
runtime později přepis do C, ovšem samotný překladač zůstal v pascalu

už v roce 1983 meeting Standard ML v Edinburghu
popis ML, na základě toho vznikl i důležitý článek “Compiling a Functional Language”

1985 Caml, první skutečně dostupná verze 1987
objective caml 1996 , OCaml

OCaml 1996 Xavier Leroy, Jérôme Vouillon, Damien Doligez, Didier Rémy

inference - odvozování


<p><a name="k03"></a></p>
<h2 id="k03">3. Od Standard ML k&nbsp;jazykům Caml a OCaml</h2>



<p><a name="k04"></a></p>
<h2 id="k04">4. Instalace Standard ML</h2>

<p>Jazyk Standard ML si můžete prakticky vyzkoušet, a to hned několika způsoby. Nejjednodušší je použití online verze, pro jejíž zprovoznění postačuje pouze webový prohlížeč a není vyžadována instalace klasického SML. Online verzí v&nbsp;současnosti existuje několik, přičemž jedním z&nbsp;příkladů takového jednoduše pojatého vývojového prostředí je online <i>REPL</i> dostupný na adrese <a href="https://sosml.org/">https://sosml.org/</a> (<i>SOSML</i>). Předností této varianty je fakt, že dlouhotrvající výpočty jsou automaticky ukončeny, čímž je například zajištěno, že se program &bdquo;zotaví&ldquo; z&nbsp;nekonečné rekurze. Použití <i>SOSML</i> je jednoduché &ndash; do levého textového pole se zapisují poznámky a výrazy. Po ukončení výrazu středníkem je provedeno jeho vyhodnocení a výsledek se zapíše do pravého textového pole. Jak příkazy, tak i jejich výsledky jsou barevně odlišeny; navíc je odlišeno a případné hlášení o chybě.</p>

*** image ***
<p><i>Obrázek :</i></p>

<p>Pro plné využití možností nabízených jazykem ML (resp. Standard ML) již nebude webové uživatelské prostředí dostačující a bude nutné si nainstalovat nativní variantu tohoto jazyka. Postup není ve skutečnosti příliš složitý (jen časově náročný) a je popsán v&nbsp;navazujících odstavcích.</p>

<p>Nejprve je nutné stáhnout tarball obsahující zdrojové kódy skriptů a dalších nástrojů určených pro překlad SML:</p>

<pre>
$ <strong>wget http://smlnj.cs.uchicago.edu/dist/working/110.98.1/config.tgz</strong>
&nbsp;
--2020-12-17 20:44:12--  http://smlnj.cs.uchicago.edu/dist/working/110.98.1/config.tgz
Resolving smlnj.cs.uchicago.edu (smlnj.cs.uchicago.edu)... 128.135.164.125
Connecting to smlnj.cs.uchicago.edu (smlnj.cs.uchicago.edu)|128.135.164.125|:80... connected.
HTTP request sent, awaiting response... 200 OK
Length: 517536 (505K) [application/x-gzip]
Saving to: ‘config.tgz’
&nbsp;
config.tgz          100%[===================&gt;] 505.41K   920KB/s    in 0.5s    
&nbsp;
2020-12-17 20:44:13 (920 KB/s) - ‘config.tgz’ saved [517536/517536]
</pre>

<p><div class="rs-tip-major">Poznámka: jak jméno staženého tarballu naznačuje, neobsahuje všechny potřebné zdrojové kódy, ale &bdquo;pouze&ldquo; konfigurační a instalační skripty.</div></p>

<p>Tarball běžným způsobem rozbalíme:</p>

<pre>
$ <strong>tar xvf config.tgz</strong>
</pre>

<p>A spustíme instalaci:</p>

<pre>
$ <strong>config/install.sh -default 64</strong>
&nbsp;
[scanning (183299-export.cm):driver/(sources.cm):../front-end/(sources.cm):typechecker/(sources.cm):../../back-end/(sources.cm):cxx/(sources.cm):../../views/sources.cm]
[scanning (183299-export.cm):driver/(sources.cm):../front-end/(sources.cm):typechecker/(sources.cm):../../back-end/(sources.cm):cxx/(sources.cm):../util/sources.cm]
[scanning (183299-export.cm):driver/(sources.cm):../front-end/(sources.cm):typechecker/(sources.cm):../../back-end/(sources.cm):sml/sources.cm]
[parsing (183299-export.cm):183299-export.sml]
[creating directory .cm/SKEL]
[compiling (183299-export.cm):183299-export.sml]
[creating directory .cm/GUID]
[creating directory .cm/amd64-unix]
[code: 229, data: 29, env: 39 bytes]
config/install.sh: Installation complete.
</pre>

<p>Po dokončení předchozího kroku by se měl v&nbsp;podadresáři <strong>bin</strong> objevit mj.&nbsp;i spustitelný soubor nazvaný <strong>sml</strong>:</p>

<pre>
$ <strong>cd bin</strong>
&nbsp;
$ <strong>./sml</strong>
&nbsp;
Standard ML of New Jersey (64-bit) v110.98.1 [built: Thu Dec 17 20:45:35 2021]
</pre>



<p><a name="k05"></a></p>
<h2 id="k05">5. </h2>

<p><div class="rs-tip-major">Poznámka na úvod: <i>syntaxe</i> jazyka SML může být na první pohled poněkud podivná, zejména pro programátory, kteří pracují s&nbsp;programovacími jazyky z&nbsp;céčkové větve. Ovšem v&nbsp;praxi je <i>syntaxe</i> tím nejmenším problémem, protože důležitá je <i>sémantika</i> a na tu se po popisu základních konceptů zaměříme (ostatně například Caml/OCaml dovolují vytvořit si vlastní syntaxi).</div></p>

<p>Nyní, když máme k&nbsp;dispozici na výběr mezi webovým rozhraním a řádkovým (terminálovým) rozhraním jazyka SML, si můžeme popsat a ihned také ukázat základní vlastnosti jazyka ML. Začneme tím nejjednodušším prvkem jazyka, kterým jsou komentáře. Ty se zapisují &bdquo;Pascalovským&ldquo; způsobem mezi dvojici komentářových závorek (* a *), tedy následovně:</p>

<pre>
(* komentáře *)
</pre>

<p>Samotné výrazy (více o nich níže) se zapisují přímo, není zapotřebí je nějakým způsobem speciálně označovat:</p>

<pre>
výraz
</pre>

<p><div class="rs-tip-major">Poznámka: některé varianty jazyka ML vykonají (resp.&nbsp;přesněji řečeno vyhodnotí) výraz až ve chvíli, kdy je za něj zapsán středník:</div></p>

<pre>
výraz;
</pre>


(* Unit -- has only one value: () *)
val u : unit = ()

(* Booleans : bool *)
val b : bool = true

(* Integers : int *)
val i : int = 1

(* Note that negation is performed using a tilde *)
val iNegative = ~1

(* Floating point numbers : real *)
val r : real = 2.0

(* Note that negation is performed using a tilde *)
val rNegative = ~2.0

(* Strings : string *)
val s : string = "s"

(* ASCII Characters : char *)
val c : char = #"c"

val u = () : unit

val b = true : bool

val i = 1 : int

val iNegative = ~1 : int

val r = 2.0 : real

val rNegative = ~2.0 : real

val s = "s" : string

val c = #"c" : char

val i = 10
val j : real = 10.0
val k = i

val lexpr =
  let val x = 1
      val y = 2
  in x + y
  end
val lexpr = 3 : int


seznamy
stejne typy prvku!

Příklady seznamů

[];
[1,2,3];
["foo","bar"];

seznam je:
bud prazdny
nebo ma formu h::t (head, tail)
[7] je shodny s 7::[]
pro konstrukci seznamu nebo pro ziskavani prvku ze seznamu

některé důležité funkce pro práci se seznamy
null(x)
hd(x) head
tl(x) tail

cons je nahrazen za
a::x konstrukce


funkce
fun <name> <formalni-parametry> = <body>
fun inc n = n + 1;
^
automaticke odvozeni typu parametru i funkce
f(x) nebo f x
f g x znamena (f g) x <- leva asociativita

Poněkud naivní implementace
postupné zjednodušování řešeného problému - redukce seznamu
odstraněním jeho prvního prvku

fun length(x) = if null(x) then 0
                else 1 + length(tl(x));

lineární rekurze
protože funkce length() volá sebe samu jen jeden krát a 
na pravé straně výrazu

append(x,y)
vraci novy seznam obsahujici nejrpve prvky z x a pote z y
append([1,2], [3,4,5])
[1,2,3,4,5]

nebo taktez
[1,2] @ [3,4,5]

plati: append([],z) == z
plati: append(a :: y, z) == a :: append(y,z)

primo z techto podminek je mozne odvodit implementaci funkce append

fun append(x, y) = if null(x) then y
                   else hd(x) :: append(tl(x), y)

navíc je zaručeno splnění okrajové podmínky, tedy situace, kdy
je jeden ze seznamů prázdný

append([1,2], [3,4,5])
postupné vykonání fází navíjení a odvíjení
1 :: append([2], [3,4,5])
1 :: 2 :: append([], [3,4,5])
1 :: 2 :: [3,4,5]
1 :: [2,3,4,5]
[1,2,3,4,5]


reverse(x, y)
- otočení x přidání před z
reverse([2, 3, 4], [1]) == [4, 3, 2, 1]

opět bude platit
reverse([], y) = y
reverse(a :: x, y) = reverse(x, a :: y)

fun reverse(x, y) = if null(x) then y
                    else reverse(tl(x), hd(x)::y)

reverse([2, 3, 4], [1])
reverse([3, 4], 2 :: [1])
reverse([3, 4], [2, 1])
reverse([4], 3 :: [2, 1])
reverse([4], [3, 2, 1])
reverse([],  4 :: [3, 2, 1])
reverse([],  [4, 3, 2, 1])
[4, 3, 2, 1]

case analysis, patterns

fun <jméno> <vzorek> = <tělo/výraz>

příklady
fun first(x, y) = x
fun first(x, _) = x

ovšem vzorkem může být například i a::x nebo (x,y)

více vzorků využívá se operátor "or"

fun <jméno> <vzorek> = <tělo/výraz>
|   <jméno> <vzorek> = <tělo/výraz>
|   <jméno> <vzorek> = <tělo/výraz>
|   <jméno> <vzorek> = <tělo/výraz>

fun car(x::y) = x;

car([1,2,3]);
car(["foo", "bar"]);
car(["first"]);
car([]);



&gt; val car = fn: ∀ 'a . 'a list → 'a;

WARN: Pattern matching is not exhaustive.

&gt; val it = 1: int;

&gt; val it = "foo": string;

&gt; val it = "first": string;

Uncaught SML exception: Match



fun car([]) = 0
  | car(x::y) = x;

car([1,2,3]);
car([]);

&gt; val car = fn: int list → int;

&gt; val it = 1: int;

&gt; val it = 0: int;


fun car nil = raise Empty
  | car(x::y) = x;

car([1,2,3]);
car([]);

&gt; val car = fn: ∀ 'a . 'a list → 'a;

&gt; val it = 1: int;

Uncaught SML exception: Empty



fun length(x) = if null(x) then 0
                else 1 + length(tl(x));

fun length([]) = 0
|   length(a::x) = 1 + length(x)



fun fib 0 = 0
  | fib 1 = 1
  | fib n = fib (n - 1) + fib (n - 2)


fun map f [] = []
  | map f (a::x) = (f a) :: (map f y)

fun inc x = x + 1;

map inc [1,2,3];

&gt; val map = fn: ∀ 'a 'b . ('a → 'b) → 'a list → 'b list;

&gt; val inc = fn: int → int;

&gt; val it = [2, 3, 4]: int list;

ofun map f [] = []
  | map f (a::x) = (f a) :: (map f x)


fun inc x = x + 1;

map inc [1,2,3];

fun half x = x / 2.0;


map half [1.0, 2.0, 3.0];

map half [1,2,3];

Elaboration failed: Type clash. Functions of type "real list → real list" cannot take an argument of type "int list": Cannot merge "real" and "int".


<p>V&nbsp;programovacím jazyku ML je možné deklarovat i anonymní funkce. Opět se nejedná o nic překvapivého, zvláště když si uvědomíme, kolik <i>sémantiky</i> (nikoli však <i>syntaxe</i>) bylo převzato z&nbsp;Lispovských jazyků. Anonymní funkce se deklaruje slovem <strong>fn</strong> a používá se zde znak šipky =&gt;. Příkladem jednoduché anonymní funkce je funkce, která vrátí hodnotu svého parametru zvýšeného o jedničku (jedná se tedy o funkci s&nbsp;parametrem typu <strong>int</strong> a návratovou hodnotou typu <strong>int</strong>):</p>

<pre>
<strong>fn x =&gt; 1 + x;</strong>
&nbsp;
&gt; val it = fn: int → int;
</pre>

<p>Pochopitelně je možné vytvořit i anonymní funkce akceptující větší množství parametrů:</p>

<pre>
<strong>fn (x, y) =&gt; x + y;</strong>
&nbsp;
&gt; val it = fn: int * int → int;
</pre>

map(fn x =&gt; 1 + x)[1,2,3]


&gt; val it = [2, 3, 4]: int list;


fun fib (0, operator) = 0
  | fib (1, operator) = 1
  | fib (n, operator) = operator(fib (n - 1, operator), fib (n - 2, operator))

fib(20, fn (x, y) =&gt; x + y);

&gt; val fib = fn: int * (int * int → int) → int;

&gt; val it = 6765: int;

fib(20, fn (x, y) =&gt; x + y + 1);



&gt; val fib = fn: int * (int * int → int) → int;

&gt; val it = 17710: int;



<p><a name="k06"></a></p>
<h2 id="k06">6. </h2>



<p><a name="k07"></a></p>
<h2 id="k07">7. </h2>



<p><a name="k08"></a></p>
<h2 id="k08">8. </h2>



<p><a name="k09"></a></p>
<h2 id="k09">9. </h2>



<p><a name="k10"></a></p>
<h2 id="k10">10. </h2>



<p><a name="k11"></a></p>
<h2 id="k11">11. </h2>



<p><a name="k12"></a></p>
<h2 id="k12">12. </h2>



<p><a name="k13"></a></p>
<h2 id="k13">13. </h2>



<p><a name="k14"></a></p>
<h2 id="k14">14. </h2>



<p><a name="k15"></a></p>
<h2 id="k15">15. </h2>



<p><a name="k16"></a></p>
<h2 id="k16">16. </h2>



<p><a name="k17"></a></p>
<h2 id="k17">17. </h2>



<p><a name="k18"></a></p>
<h2 id="k18">18. </h2>



<p><a name="k19"></a></p>
<h2 id="k19">19. </h2>

<ol>

<li>ML for the Working Programmer<br />
<a href="https://www.cl.cam.ac.uk/~lp15/MLbook/pub-details.html">https://www.cl.cam.ac.uk/~lp15/MLbook/pub-details.html</a>
</li>

<li>Elements of ML Programming, 2nd Edition (ML97)<br />
<a href="http://infolab.stanford.edu/~ullman/emlp.html">http://infolab.stanford.edu/~ullman/emlp.html</a>
</li>

<li>A tour of Standard ML<br />
<a href="https://saityi.github.io/sml-tour/tour/welcome">https://saityi.github.io/sml-tour/tour/welcome</a>
</li>

<li>The History of Standard ML<br />
<a href="https://smlfamily.github.io/history/SML-history.pdf">https://smlfamily.github.io/history/SML-history.pdf</a>
</li>

<li>The Standard ML Basis Library<br />
<a href="https://smlfamily.github.io/Basis/">https://smlfamily.github.io/Basis/</a>
</li>

<li>Programming in Standard ML<br />
<a href="http://www.cs.cmu.edu/~rwh/isml/book.pdf">http://www.cs.cmu.edu/~rwh/isml/book.pdf</a>
</li>

<li>Programming in Standard ML '97: A Tutorial Introduction<br />
<a href="http://www.lfcs.inf.ed.ac.uk/reports/97/ECS-LFCS-97-364/">http://www.lfcs.inf.ed.ac.uk/reports/97/ECS-LFCS-97-364/</a>
</li>

<li>Programming in Standard ML '97: An On-line Tutorial<br />
<a href="https://homepages.inf.ed.ac.uk/stg/NOTES/">https://homepages.inf.ed.ac.uk/stg/NOTES/</a>
</li>

</ol>



<p><a name="k20"></a></p>
<h2 id="k20">20. Odkazy na Internetu</h2>

<ol>

<li>Standard ML of New Jersey<br />
<a href="https://www.smlnj.org/">https://www.smlnj.org/</a>
</li>

<li>Programming Languages: Standard ML - 1 (a navazující videa)<br />
<a href="https://www.youtube.com/watch?v=2sqjUWGGzTo">https://www.youtube.com/watch?v=2sqjUWGGzTo</a>
</li>

<li>6 Excellent Free Books to Learn Standard ML<br />
<a href="https://www.linuxlinks.com/excellent-free-books-learn-standard-ml/">https://www.linuxlinks.com/excellent-free-books-learn-standard-ml/</a>
</li>

<li>SOSML: The Online Interpreter for Standard ML<br />
<a href="https://sosml.org/">https://sosml.org/</a>
</li>

<li>ML (Computer program language)<br />
<a href="https://www.barnesandnoble.com/b/books/other-programming-languages/ml-computer-program-language/_/N-29Z8q8Zvy7">https://www.barnesandnoble.com/b/books/other-programming-languages/ml-computer-program-language/_/N-29Z8q8Zvy7</a>
</li>

<li>Strong Typing<br />
<a href="https://perl.plover.com/yak/typing/notes.html">https://perl.plover.com/yak/typing/notes.html</a>
</li>

<li>What to know before debating type systems<br />
<a href="http://blogs.perl.org/users/ovid/2010/08/what-to-know-before-debating-type-systems.html">http://blogs.perl.org/users/ovid/2010/08/what-to-know-before-debating-type-systems.html</a>
</li>

<li>Types, and Why You Should Care<br />
<a href="https://www.youtube.com/watch?v=0arFPIQatCU">https://www.youtube.com/watch?v=0arFPIQatCU</a>
</li>

<li>DynamicTyping (Martin Fowler)<br />
<a href="https://www.martinfowler.com/bliki/DynamicTyping.html">https://www.martinfowler.com/bliki/DynamicTyping.html</a>
</li>

<li>DomainSpecificLanguage (Martin Fowler)<br />
<a href="https://www.martinfowler.com/bliki/DomainSpecificLanguage.html">https://www.martinfowler.com/bliki/DomainSpecificLanguage.html</a>
</li>

<li>Language Workbenches: The Killer-App for Domain Specific Languages?<br />
<a href="https://www.martinfowler.com/articles/languageWorkbench.html">https://www.martinfowler.com/articles/languageWorkbench.html</a>
</li>

<li>Effective ML<br />
<a href="https://www.youtube.com/watch?v=-J8YyfrSwTk">https://www.youtube.com/watch?v=-J8YyfrSwTk</a>
</li>

<li>Why OCaml<br />
<a href="https://www.youtube.com/watch?v=v1CmGbOGb2I">https://www.youtube.com/watch?v=v1CmGbOGb2I</a>
</li>

<li>CSE 341: Functions and patterns<br />
<a href="https://courses.cs.washington.edu/courses/cse341/04wi/lectures/03-ml-functions.html">https://courses.cs.washington.edu/courses/cse341/04wi/lectures/03-ml-functions.html</a>
</li>

</ol>



<p></p><p></p>
<p><small>Autor: <a href="http://www.fit.vutbr.cz/~tisnovpa">Pavel Tišnovský</a> &nbsp; 2022</small></p>
</body>
</html>

