<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
        "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html>
<head>
<title>Přetěžování operátorů v programovacím jazyce C3</title>
<meta name="Author" content="Pavel Tisnovsky" />
<meta name="Generator" content="vim" />
<meta http-equiv="content-type" content="text/html; charset=utf-8" />
<style type="text/css">
         body {color:#000000; background:#ffffff;}
         h1  {font-family: arial, helvetica, sans-serif; color:#ffffff; background-color:#c00000; text-align:center; padding-left:1em}
         h2  {font-family: arial, helvetica, sans-serif; color:#ffffff; background-color:#0000c0; padding-left:1em; text-align:left}
         h3  {font-family: arial, helvetica, sans-serif; color:#000000; background-color:#c0c0c0; padding-left:1em; text-align:left}
         h4  {font-family: arial, helvetica, sans-serif; color:#000000; background-color:#e0e0e0; padding-left:1em; text-align:left}
         a   {font-family: arial, helvetica, sans-serif;}
         li  {font-family: arial, helvetica, sans-serif; color:#000000; text-align:justify; width:450px;}
         ol  {font-family: arial, helvetica, sans-serif; color:#000000; text-align:justify; width:450px;}
         ul  {font-family: arial, helvetica, sans-serif; color:#000000; text-align:justify; width:450px;}
         p   {font-family: arial, helvetica, sans-serif; color:#000000; text-align:justify;}
         pre {background:#e0e0e0}
</style>
</head>

<body>

<h1>Přetěžování operátorů v programovacím jazyce C3</h1>

<h3>Pavel Tišnovský</h3>

<p></p>

<h1>Úvodník</h1>

<p>Mezi jednu z důležitých vlastností programovacího jazyka C3 patří možnost přetěžování vybraných operátorů pro nové datové typy. C3 se snaží o rozumné rovnováhy mezi vyjadřovacími schopnostmi jazyka na straně jedné a čitelností a udržovatelností programů na straně druhé.</p>



<h2>Obsah</h2>

<p><a href="#k01">1. Přetěžování operátorů v&nbsp;programovacím jazyce C3</a></p>
<p><a href="#k02">2. Rozdělení programovacích jazyků podle jejich přístupu k&nbsp;operátorům</a></p>
<p><a href="#k03">3. Operátory a další speciální znaky v&nbsp;jazyku C3</a></p>
<p><a href="#k04">4. Krátké připomenutí: definice a volání metod v&nbsp;jazyku C3</a></p>
<p><a href="#k05">5. Metoda pro součet vektorů, která vrací nový vektor</a></p>
<p><a href="#k06">6. Přetížení operátoru + tak, aby se provedl součet dvou vektorů</a></p>
<p><a href="#k07">7. Předání operandů hodnotou nebo odkazem?</a></p>
<p><a href="#k08">8. Několikanásobné přetížení stejného operátoru: přičtení skalární hodnoty vs součet vektorů</a></p>
<p><a href="#k09">9. Přetížení operátoru &bdquo;zleva&ldquo; nebo &bdquo;zprava&ldquo;</a></p>
<p><a href="#k10">10. Symetrická varianta přetíženého operátoru součtu</a></p>
<p><a href="#k11">*** 11. Přetížení unárního operátoru - (otočení znaménka)</a></p>
<p><a href="#k12">*** 12. Přetížení operátoru pro porovnání dvou hodnot (rovnost)</a></p>
<p><a href="#k13">*** 13. Přetížení operátoru pro součin tak, aby se prováděl skalární součin dvou vektorů</a></p>
<p><a href="#k14">*** 14. Vynásobení složek vektoru skalární konstantou versus skalární součin vektorů</a></p>
<p><a href="#k15">*** 15. Další operátory, které je možné přetížit</a></p>
<p><a href="#k16">*** 16. Přetížení operátoru pro výběr prvku pro čtení pomocí indexu</a></p>
<p><a href="#k17">*** 17. Klíč ve formě řetězce namísto celočíselného indexu, přetížení přiřazení</a></p>
<p><a href="#k18">*** 18. Přetížení speciálního operátoru <strong>len</strong></a></p>
<p><a href="#k19">19. Repositář s&nbsp;demonstračními příklady</a></p>
<p><a href="#k20">20. Odkazy na Internetu</a></p>



<p><a name="k01"></a></p>
<h2 id="k01">1. Přetěžování operátorů v&nbsp;programovacím jazyce C3</h2>

<p>Operátory hrají v&nbsp;programovacích jazycích odvozených od jazyka C (nebo
možná přesněji řečeno už od Algolu 60) velmi důležité role. Ostatně není divu,
že poměrně velká část specifikace těchto jazyků je zaměřena právě na popis
vlastností operátorů (jejich sémantiky, priority, asociativity, komutativity
atd.). V&nbsp;samotném jazyku C je definováno několik desítek operátorů, které
mají pevně daný význam &ndash; specifikace tedy přesně určuje, pro jaké typy
hodnot je možné operátory použít, jakou mají prioritu atd., které operace
nejsou povoleny, které jsou nedefinovány apod. V&nbsp;kontextu dnešního článku
je zajímavé, že mnohé standardní céčkovské operátory jsou definovány pro různé
datové typy, což nepřímo znamená, že specifikace céčka musí obsahovat popis
toho, jak se má část programu chovat v&nbsp;případě, že se například sčítá celé
číslo s&nbsp;hodnotou s&nbsp;plovoucí řádovou čárkou atd.</p>

<p>V&nbsp;mnoha programovacích jazycích (z&nbsp;nichž mnohé vznikly až po výše
zmíněném céčku) se setkáme s&nbsp;takzvanými <i>přetíženými operátory</i>.
Jedná se o operátory, jejichž funkce a vlastnosti se mění podle typu operandů.
Pravděpodobně nejznámější formou standardně (již v&nbsp;jazyku) přetížených
operátorů jsou operátory určené pro provádění základních aritmetických operací,
které bývají definovány pro různé numerické datové typy. Ovšem například
operátor <strong>+</strong> může být přetížen vícekrát, typicky pro operaci
spojení řetězců (viz například Javu) či například n-tic a seznamů (tak je tento
operátor přetížen v&nbsp;Pythonu). V&nbsp;těchto případech se nejenom mění
funkce operátoru (protože součet je zcela rozdílná operace od spojení řetězců),
ale i jejich další vlastnosti, v&nbsp;tomto případě například komutativita (a
nepřímo taktéž asociativita v&nbsp;případě hodnot s&nbsp;plovoucí řádovou
čárkou).</p>

<p>Některé programovací jazyky umožňují definici zcela nových operátorů
popř.&nbsp;alespoň přetížení existujících operátorů. Z&nbsp;tohoto pohledu
můžeme programovací jazyky rozdělit do čtyř skupin na základě dvou vlastností
(které jsou na sobě do určité míry nezávislé):</p>

<ol>
<li>Lze definovat nové operátory?</li>
<li>Lze přetížit stávající operátory?</li>
</ol>

<p><div class="rs-tip-major">Poznámka: existující &bdquo;původní&ldquo;
operátory jsou v&nbsp;mnoha programovacích jazycích již přetíženy tvůrci
jazyka, což ovšem nic neříká o tom, zda je možné je dále přetížit na úrovni
programu nebo knihovny. Dobrým příkladem je například již zmíněná Java,
v&nbsp;níž není možné dále přetížit operátor <strong>+</strong> pro různé
třídy, například typu <strong>BigDecimal</strong>, i když by to bylo sémanticky
naprosto vyhovující.</div></p>



<p><a name="k02"></a></p>
<h2 id="k02">2. Rozdělení programovacích jazyků podle jejich přístupu k&nbsp;operátorům</h2>

<p>Zajímavé je, že každá ze čtyř možných kombinací zmíněných <a
href="#k02">v&nbsp;úvodní kapitole</a> je obsazena nějakým programovacím
jazykem, a to zcela nezávisle na dalších vlastnostech daného jazyka, tedy
nezávisle na jeho typovém systému, podpoře objektově orientovaného
programování, existence maker atd.:</p>



<h3>Jazyky, do nichž nelze přidávat další operátory a existující operátory nelze dále přetěžovat</h3>

<table>
<tr><td>BASIC</td></tr>
<tr><td>C</td></tr>
<tr><td>Go</td></tr>
<tr><td>Java</td></tr>
<tr><td>JavaScript</td></tr>
<tr><td>Modula-2</td></tr>
<tr><td>Objective-C</td></tr>
<tr><td>Pascal</td></tr>
<tr><td>TypeScript</td></tr>
<tr><td>Visual Basic</td></tr>
</table>



<h3>Jazyky, do nichž nelze přidávat nové operátory, ale existující operátory je možné přetěžovat</h3>

<table>
<tr><td>C3</td></tr>
<tr><td>Ada</td></tr>
<tr><td>C#</td></tr>
<tr><td>C++</td></tr>
<tr><td>D</td></tr>
<tr><td>Dart</td></tr>
<tr><td>FreeBASIC</td></tr>
<tr><td>Groovy</td></tr>
<tr><td>Java</td></tr>
<tr><td>Kotlin</td></tr>
<tr><td>Lua</td></tr>
<tr><td>MATLAB</td></tr>
<tr><td>Object Pascal</td></tr>
<tr><td>PHP</td></tr>
<tr><td>Perl</td></tr>
<tr><td>Python</td></tr>
<tr><td>Ruby</td></tr>
<tr><td>Rust</td></tr>
<tr><td>Visual Basic .NET</td></tr>
</table>

<p><div class="rs-tip-major">Poznámka: programovací jazyk C3 patří právě do
této kategorie programovacích jazyků. Umožňuje tedy přetěžování operátorů (pro
nové datové typy!), ovšem nelze v&nbsp;něm vytvářet operátory nové ani
v&nbsp;něm není možné měnit další vlastnosti operátorů, tj.&nbsp;jejich
asociativitu, komutativitu ani prioritu.</div></p>



<h3>Jazyky v&nbsp;nichž je možné definovat nové operátory, existující operátory ovšem nelze dále přetěžovat</h3>

<table>
<tr><td>ML</td></tr>
<tr><td>Pico</td></tr>
<tr><td>Prolog</td></tr>
<tr><td>Smalltalk</td></tr>
</table>



<h3>Jazyky v&nbsp;nichž lze definovat nové operátory, navíc je možné přetěžovat i existující operátory</h3>

<table>
<tr><td>ALGOL 68</td></tr>
<tr><td>Eiffel</td></tr>
<tr><td>Fortran</td></tr>
<tr><td>F#</td></tr>
<tr><td>Haskell</td></tr>
<tr><td>Io</td></tr>
<tr><td>Nim</td></tr>
<tr><td>R</td></tr>
<tr><td>Raku</td></tr>
<tr><td>Scala</td></tr>
<tr><td>Swift</td></tr>
</table>



<p><a name="k03"></a></p>
<h2 id="k03">3. Operátory a další speciální znaky v&nbsp;jazyku C3</h2>

<p>Vzhledem k&nbsp;tomu, že je jazyk C3 odvozen od standardního céčka, nebude
větším překvapením, že i v&nbsp;něm nalezneme poměrně velké množství různých
operátorů (vlastně ještě větší množství, než v&nbsp;céčku). Tyto operátory jsou
společně s&nbsp;dalšími speciálními znaky vypsány pod tímto odstavcem:</p>

<pre>
&amp;       @       ~       |       ^       :
,       /       $       .       ;       )
&gt;       &lt;       #       {       }       -
(       )       *       [       ]       %
&gt;=      &lt;=      +       +=      -=      !
?       ?:      &amp;&amp;      ??      &amp;=      |=
^=      /=      ..      ==      ({      })
[&lt;      &gt;]      ++      --      %=      !=
||      ::      &lt;&lt;      &gt;&gt;      !!      ...
&lt;&lt;=     &gt;&gt;=
</pre>

<p>Ty znaky nebo skupiny znaků, které tvoří operátory, by bylo teoreticky možné
všechny přetížit, ovšem tvůrci jazyka C3 omezili množství operátorů, které se
mohou přetížit, na:</p>

<ul>
<li>Standardní aritmetické operátory +, -, *, / a %</li>
<li>Unární operátory + a -</li>
<li>Bitové operátory ^, | a &amp;</li>
<li>Bitové posuny &lt;&lt; a &gt;&gt;</li>
<li>Operátor indexování [] pro čtení a/nebo i zápis</li>
<li>Speciální operátor <strong>len</strong> (viz další text)</li>
</ul>

<p>Přitom se předpokládá, že operátory budou přetíženy &bdquo;příčetně&ldquo;,
tj.&nbsp;například při implementaci vlastních numerických typů. Zejména se
<i>nedoporučuje</i> přístup jazyka C++, který například přetěžuje operátory
&lt;&lt; a &gt;&gt; pro operace, které nijak nesouvisí s&nbsp;bitovými posuny.
Ostatně právě toto &bdquo;nepříčetné&ldquo; přetěžování operátorů vede
k&nbsp;tomu, že je přetěžování operátorů některými vývojáři zamítnuto (což vede
k&nbsp;onomu pověstnému vylití dítěte s&nbsp;vaničkou).</p>

<p><div class="rs-tip-major">Poznámka: povšimněte si zejména absence relačních
operátorů.</div></p>



<p><a name="k04"></a></p>
<h2 id="k04">4. Krátké připomenutí: definice a volání metod v&nbsp;jazyku C3</h2>

<p>V&nbsp;jazyce C3 je možné operátory přetížit pouze pro nové uživatelsky
definované datové typy. Samotné přetěžování se provádí definicí <i>metod</i>,
do jejichž hlaviček je přidána informace o tom, že se kromě definice metody
provádí i definice přetíženého operátoru. Proto si v&nbsp;krátkosti připomeňme,
jak se vlastně v&nbsp;C3 s&nbsp;metodami pracuje. Co jsou to metody? Jedná se
vlastně o funkce vztažené k&nbsp;nějakému datovému typu. Metody je možné volat
dvěma rozličnými způsoby, které si oba ukážeme v&nbsp;demonstračních
příkladech.</p>

<p>Nejprve si zadefinujeme nějaký uživatelský datový typ. Pro jednoduchost se
může jednat o reprezentaci vektoru v&nbsp;3D prostoru pomocí tří složek
(s&nbsp;tímto typem se dnes setkáme ještě mnohokrát):</p>

<pre>
struct <strong>Vector3d</strong>
{
    int x;
    int y;
    int z;
}
</pre>

<p>V&nbsp;případě, že budeme chtít pro tento datový typ definovat novou metodu,
například metodu určenou pro součet dvou vektorů, může řešení vypadat
následovně. Tato metoda mění (mutuje) první vektor, který je jí předán (a proto
musí být předán odkazem):</p>

<pre>
fn void <strong>Vector3d.add</strong>(Vector3d* first, Vector3d* second)
{
    first.x += second.x;
    first.y += second.y;
    first.z += second.z;
}
</pre>

<p><div class="rs-tip-major">Poznámka: ve skutečnosti nemusí být druhý parametr
předáván odkazem (přes ukazatel) ale přímo hodnotou (sami si to
vyzkoušejte).</div></p>

<p>Výše uvedenou metodu můžeme volat tak, jakoby se jednalo o funkci umístěnou
ve jmenném prostoru <strong>Vector3d</strong>:</p>

<pre>
Vector3d v1 = {1, 2, 3};
Vector3d v2 = {10, 10, 10};
&nbsp;
Vector3d.add(&amp;v1, &amp;v2);
</pre>

<p>Celý příklad s&nbsp;definicí metody i s&nbsp;jejím voláním může vypadat
následovně:</p>

<pre>
module <strong>operator_overloading</strong>;
import std::io;
&nbsp;
struct <strong>Vector3d</strong>
{
    int x;
    int y;
    int z;
}
&nbsp;
fn void <strong>Vector3d.add</strong>(Vector3d* first, Vector3d* second)
{
    first.x += second.x;
    first.y += second.y;
    first.z += second.z;
}
&nbsp;
fn void <strong>main</strong>()
{
    Vector3d v1 = {1, 2, 3};
    Vector3d v2 = {10, 10, 10};
&nbsp;
    Vector3d.add(&amp;v1, &amp;v2);
&nbsp;
    io::printf("[%d %d %d]\n", v1.x, v1.y, v1.z);
}
</pre>

<p>Otestování funkcionality tohoto demonstračního příkladu je snadné:</p>

<pre>
[11 12 13]
</pre>

<p>Varianta, ve které je druhý vektor předán hodnotou a nikoli odkazem:</p>

<pre>
module <strong>operator_overloading</strong>;
import std::io;
&nbsp;
struct <strong>Vector3d</strong>
{
    int x;
    int y;
    int z;
}
&nbsp;
fn void <strong>Vector3d.add</strong>(Vector3d* first, Vector3d second)
{
    first.x += second.x;
    first.y += second.y;
    first.z += second.z;
}
&nbsp;
fn void <strong>main</strong>()
{
    Vector3d v1 = {1, 2, 3};
    Vector3d v2 = {10, 10, 10};
&nbsp;
    Vector3d.add(&amp;v1, v2);
&nbsp;
    io::printf("[%d %d %d]\n", v1.x, v1.y, v1.z);
}
</pre>

<p>Ovšem na druhou stranu další demonstrační příklad již funkční nebude,
resp.&nbsp;nebude modifikovat první vektor předaný do metody (ale jen jeho
kopii)!</p>

<pre>
module <strong>operator_overloading</strong>;
import std::io;
&nbsp;
struct <strong>Vector3d</strong>
{
    int x;
    int y;
    int z;
}
&nbsp;
fn void <strong>Vector3d.add</strong>(Vector3d first, Vector3d second)
{
    first.x += second.x;
    first.y += second.y;
    first.z += second.z;
}
&nbsp;
fn void <strong>main</strong>()
{
    Vector3d v1 = {1, 2, 3};
    Vector3d v2 = {10, 10, 10};
&nbsp;
    Vector3d.add(v1, v2);
&nbsp;
    io::printf("[%d %d %d]\n", v1.x, v1.y, v1.z);
}
</pre>

<p>Ve skutečnosti není výše uvedené volání metody:</p>

<pre>
    Vector3d.add(&amp;v1, &amp;v2);
</pre>

<p>v&nbsp;mnoha programovacích jazycích příliš idiomatické. Z&nbsp;tohoto
důvodu nabízí programovací jazyk C3 i známější a dnes používanější způsob
zápisu volání metody:</p>

<pre>
v1.add(&amp;v2);
</pre>

<p><div class="rs-tip-major">Poznámka: povšimněte si, že není nutné rozlišovat,
jestli je první parametr metody (příjemce) předán hodnotou nebo odkazem (přes
ukazatel).</div></p>

<p>Pro úplnost si uveďme úplný zdrojový kód demonstračního příkladu upraveného
do podoby, ve které se používá idiomatičtější způsob zápisu volání metody:</p>

<pre>
module <strong>operator_overloading</strong>;
import std::io;
&nbsp;
struct <strong>Vector3d</strong>
{
    int x;
    int y;
    int z;
}
&nbsp;
fn void <strong>Vector3d.add</strong>(Vector3d* first, Vector3d* second)
{
    first.x += second.x;
    first.y += second.y;
    first.z += second.z;
}
&nbsp;
fn void <strong>main</strong>()
{
    Vector3d v1 = {1, 2, 3};
    Vector3d v2 = {10, 10, 10};
&nbsp;
    <strong>v1.add(&amp;v2)</strong>;
&nbsp;
    io::printf("[%d %d %d]\n", v1.x, v1.y, v1.z);
}
</pre>

<p>Otestování funkcionality:</p>

<pre>
[11 12 13]
</pre>



<p><a name="k05"></a></p>
<h2 id="k05">5. Metoda pro součet vektorů, která vrací nový vektor</h2>

<p>Ještě předtím, než si ukážeme, jakým způsobem je možné přetížit nějaký
aritmetický operátor (nebo všechny operátory) pro naši datovou strukturu
<strong>Vector3d</strong>, provedeme poslední úpravu metody provádějící součet
vektorů. Tato metoda totiž může vracet nový vektor, který vznikne součtem obou
vstupních vektorů (operandů). To sice nemusí být příliš efektivní
z&nbsp;pohledu využití operační paměti, ovšem jedná se o velmi idiomatický
způsob implementace:</p>

<pre>
fn Vector3d <strong>Vector3d.add</strong>(Vector3d first, Vector3d second)
{
    Vector3d result;
    result.x = first.x + second.x;
    result.y = first.y + second.y;
    result.z = first.z + second.z;
    return result;
}
</pre>

<p>Volání této metody:</p>

<pre>
Vector3d v1 = {1, 2, 3};
Vector3d v2 = {10, 10, 10};
&nbsp;
Vector3d v3 = <strong>Vector3d.add(v1, v2)</strong>;
</pre>

<p>Tento způsob volání je ukázán v&nbsp;dalším demonstračním příkladu:</p>

<pre>
module <strong>operator_overloading</strong>;
import std::io;
&nbsp;
struct <strong>Vector3d</strong>
{
    int x;
    int y;
    int z;
}
&nbsp;
fn Vector3d <strong>Vector3d.add</strong>(Vector3d first, Vector3d second)
{
    Vector3d result;
    result.x = first.x + second.x;
    result.y = first.y + second.y;
    result.z = first.z + second.z;
    return result;
}
&nbsp;
fn void <strong>main</strong>()
{
    Vector3d v1 = {1, 2, 3};
    Vector3d v2 = {10, 10, 10};
&nbsp;
    Vector3d v3 = Vector3d.add(v1, v2);
&nbsp;
    io::printf("[%d %d %d]\n", v3.x, v3.y, v3.z);
}
</pre>

<p>Ovšem (jak již víme z&nbsp;předchozích kapitol) je možné metodu
<strong>add</strong> volat i odlišným způsobem:</p>

<pre>
Vector3d v1 = {1, 2, 3};
Vector3d v2 = {10, 10, 10};
&nbsp;
Vector3d v3 = <strong>v1.add(v2)</strong>;
</pre>

<p>Opět si pro úplnost ukažme, jak vypadá celý zdrojový kód takto upraveného
příkladu:</p>

<pre>
module <strong>operator_overloading</strong>;
import std::io;
&nbsp;
struct <strong>Vector3d</strong>
{
    int x;
    int y;
    int z;
}
&nbsp;
fn Vector3d <strong>Vector3d.add</strong>(Vector3d first, Vector3d second)
{
    Vector3d result;
    result.x = first.x + second.x;
    result.y = first.y + second.y;
    result.z = first.z + second.z;
    return result;
}
&nbsp;
fn void <strong>main</strong>()
{
    Vector3d v1 = {1, 2, 3};
    Vector3d v2 = {10, 10, 10};
&nbsp;
    Vector3d v3 = v1.add(v2);
&nbsp;
    io::printf("[%d %d %d]\n", v3.x, v3.y, v3.z);
}
</pre>



<p><a name="k06"></a></p>
<h2 id="k06">6. Přetížení operátoru + tak, aby se provedl součet dvou vektorů</h2>

<p>Nyní se již konečně dostáváme k&nbsp;přetěžování operátorů. Ve skutečnosti
je to v&nbsp;našem případě velmi snadné, protože stačí do původní definici
metody <strong>add</strong>:</p>

<pre>
fn Vector3d <strong>Vector3d.add</strong>(Vector3d first, Vector3d second)
{
    Vector3d result;
    result.x = first.x + second.x;
    result.y = first.y + second.y;
    result.z = first.z + second.z;
    return result;
}
</pre>

<p>Přidat dekorátor, který překladač jazyka C3 &bdquo;donutí&ldquo; přetížit
operátor <strong>+</strong>:</p>

<pre>
fn Vector3d <strong>Vector3d.add</strong>(Vector3d first, Vector3d second) <strong>@operator(+)</strong>
{
    Vector3d result;
    result.x = first.x + second.x;
    result.y = first.y + second.y;
    result.z = first.z + second.z;
    return result;
}
</pre>

<p>Použití nového operátoru je již zcela idiomatické:</p>

<pre>
Vector3d v1 = {1, 2, 3};
Vector3d v2 = {10, 10, 10};
&nbsp;
Vector3d v3 = v1 + v2;
</pre>

<p>Opět si ukažme celý zdrojový kód takto upraveného demonstračního
příkladu:</p>

<pre>
module <strong>operator_overloading</strong>;
import std::io;
&nbsp;
struct <strong>Vector3d</strong>
{
    int x;
    int y;
    int z;
}
&nbsp;
fn Vector3d <strong>Vector3d.add</strong>(Vector3d first, Vector3d second) <strong>@operator(+)</strong>
{
    Vector3d result;
    result.x = first.x + second.x;
    result.y = first.y + second.y;
    result.z = first.z + second.z;
    return result;
}
&nbsp;
fn void <strong>main</strong>()
{
    Vector3d v1 = {1, 2, 3};
    Vector3d v2 = {10, 10, 10};
&nbsp;
    Vector3d v3 = v1 + v2;
&nbsp;
    io::printf("[%d %d %d]\n", v3.x, v3.y, v3.z);
}
</pre>



<p><a name="k07"></a></p>
<h2 id="k07">7. Předání operandů hodnotou nebo odkazem?</h2>

<p>Většinou se v&nbsp;definicích metod, které současně přetěžují nějaký
aritmetický (binární) operátor, setkáme s&nbsp;tím, že prvním parametrem metody
je levý operand popř.&nbsp;reference na tento operand (tedy adresa). To, zda
budeme předávat hodnotu nebo referenci, se projevuje pouze na zápisu hlavičky
metody, protože její nepřímé volání (přes operand) zůstane naprosto stejné.
Ostatně postačuje se podívat na následující dvojici demonstračních příkladů,
které se od sebe odlišují pouze hlavičkou metody <strong>add</strong>:</p>

<pre>
module <strong>operator_overloading</strong>;
import std::io;
&nbsp;
struct <strong>Vector3d</strong>
{
    int x;
    int y;
    int z;
}
&nbsp;
fn Vector3d <strong>Vector3d.add</strong>(self, Vector3d second) <strong>@operator(+)</strong>
{
    Vector3d result;
    result.x = self.x + second.x;
    result.y = self.y + second.y;
    result.z = self.z + second.z;
    return result;
}
&nbsp;
fn void <strong>main</strong>()
{
    Vector3d v1 = {1, 2, 3};
    Vector3d v2 = {10, 10, 10};
&nbsp;
    Vector3d v3 = v1 + v2;
&nbsp;
    io::printf("[%d %d %d]\n", v3.x, v3.y, v3.z);
}
</pre>

<p>Prakticky totožný zápis, ovšem první parametr je do metody předáván odkazem
a nikoli hodnotou:</p>

<pre>
module <strong>operator_overloading</strong>;
import std::io;
&nbsp;
struct <strong>Vector3d</strong>
{
    int x;
    int y;
    int z;
}
&nbsp;
fn Vector3d <strong>Vector3d.add</strong>(&amp;self, Vector3d second) <strong>@operator(+)</strong>
{
    self.x += second.x;
    self.y += second.y;
    self.z += second.z;
    return *self;
}
&nbsp;
fn void <strong>main</strong>()
{
    Vector3d v1 = {1, 2, 3};
    Vector3d v2 = {10, 10, 10};
&nbsp;
    Vector3d v3 = v1 + v2;
&nbsp;
    io::printf("[%d %d %d]\n", v3.x, v3.y, v3.z);
}
</pre>



<p><a name="k08"></a></p>
<h2 id="k08">8. Několikanásobné přetížení stejného operátoru: přičtení skalární hodnoty vs součet vektorů</h2>

<p>V&nbsp;některých případech se setkáme s&nbsp;požadavkem přetížení nějakého
operátoru tak, aby na pravé straně akceptoval operandy různého typu. Příkladem
může být požadavek, aby bylo možné k&nbsp;našemu vektoru v&nbsp;prostoru
přičíst buď skalární hodnotu nebo další vektor. V&nbsp;jazyku C3 je to možné,
protože volání metody lze odlišit na základě jejího jména (pochopitelně),
přičemž metody odlišných jmen mohou akceptovat odlišné typy parametrů. Ovšem i
u dvou metod s&nbsp;odlišným jménem (a odlišnými typy parametrů) lze
dekorátorem dopsat přetížení toho stejného operátoru. Můžeme tedy implementovat
dvě varianty operátoru +:</p>

<pre>
fn Vector3d <strong>Vector3d.add_scalar</strong>(self, int scalar) <strong>@operator(+)</strong>
    ...
    ...
    ...
</pre>

<p>a současně:</p>

<pre>
fn Vector3d <strong>Vector3d.add_vector</strong>(self, Vector3d second) <strong>@operator(+)</strong>
    ...
    ...
    ...
</pre>

<p>Chování takto přetíženého operátoru si můžeme snadno ověřit pokusem o součet
vektorů popř.&nbsp;o přičtení skalární hodnoty k&nbsp;vektoru:</p>

<pre>
module <strong>operator_overloading</strong>;
import std::io;
&nbsp;
struct <strong>Vector3d</strong>
{
    int x;
    int y;
    int z;
}
&nbsp;
fn Vector3d <strong>Vector3d.add_scalar</strong>(self, int scalar) @operator(+)
{
    Vector3d result;
    result.x = self.x + scalar;
    result.y = self.y + scalar;
    result.z = self.z + scalar;
    return result;
}
&nbsp;
fn Vector3d <strong>Vector3d.add_vector</strong>(self, Vector3d second) @operator(+)
{
    Vector3d result;
    result.x = self.x + second.x;
    result.y = self.y + second.y;
    result.z = self.z + second.z;
    return result;
}
&nbsp;
fn void <strong>main</strong>()
{
    Vector3d v1 = {1, 2, 3};
    Vector3d v2 = {10, 10, 10};
&nbsp;
    Vector3d v3 = v1 + v2;
&nbsp;
    io::printf("[%d %d %d]\n", v3.x, v3.y, v3.z);
&nbsp;
    Vector3d v4 = v3 + 100;
    io::printf("[%d %d %d]\n", v4.x, v4.y, v4.z);
}
</pre>

<p>Výsledky ukazují, že vše funguje podle očekávání:</p>

<pre>
[11 12 13]
[111 112 113]
</pre>



<p><a name="k09"></a></p>
<h2 id="k09">9. Přetížení operátoru &bdquo;zleva&ldquo; nebo &bdquo;zprava&ldquo;</h2>

<p>V&nbsp;demonstračním příkladu <a href="#k08">z&nbsp;předchozí kapitoly</a>
jsme přičítali skalární hodnotu k&nbsp;vektoru, což znamenalo, že se vektor
nacházel na levé straně přetíženého operátoru +, zatímco skalární hodnota se
nacházela na jeho pravé straně:</p>

<pre>
Vector3d v4 = v3 + 100;
</pre>

<p>Co se ovšem stane v&nbsp;případě, že oba operandy prohodíme? V&nbsp;tomto
případě bude první operand typu celé číslo a druhý operand typu Vector3d:</p>

<pre>
Vector3d v4 = 100 + v3;
</pre>

<p>Můžeme si to vyzkoušet pokusem o překlad následujícího příkladu:</p>

<pre>
module <strong>operator_overloading</strong>;
import std::io;
&nbsp;
struct <strong>Vector3d</strong>
{
    int x;
    int y;
    int z;
}
&nbsp;
fn Vector3d <strong>Vector3d.add_scalar</strong>(self, int scalar) @operator(+)
{
    Vector3d result;
    result.x = self.x + scalar;
    result.y = self.y + scalar;
    result.z = self.z + scalar;
    return result;
}
&nbsp;
fn Vector3d <strong>Vector3d.add_vector</strong>(self, Vector3d second) @operator(+)
{
    Vector3d result;
    result.x = self.x + second.x;
    result.y = self.y + second.y;
    result.z = self.z + second.z;
    return result;
}
&nbsp;
fn void <strong>main</strong>()
{
    Vector3d v1 = {1, 2, 3};
    Vector3d v2 = {10, 10, 10};
&nbsp;
    Vector3d v3 = v1 + v2;
&nbsp;
    io::printf("[%d %d %d]\n", v3.x, v3.y, v3.z);
&nbsp;
    Vector3d v4 = 100 + v3;
    io::printf("[%d %d %d]\n", v4.x, v4.y, v4.z);
}
</pre>

<p>Překladač jazyka C3 v&nbsp;tomto případě ohlásí problém, protože není, jakou
metodu by měl pro vyžadovaný součet zavolat:</p>

<pre>
 35:
 36:     io::printf("[%d %d %d]\n", v3.x, v3.y, v3.z);
 37:
 38:     Vector3d v4 = 100 + v3;
                       ^^^^^^^^
(/tmp/ramdisk/c3c/build/add_operator_7.c3:38:19) Error: Cannot do the addition 'int' + 'Vector3d'.
</pre>

<p>Řešením může být doplnění původní implementace operátoru +:</p>

<pre>
fn Vector3d <strong>Vector3d.add_scalar</strong>(self, int scalar) <strong>@operator(+)</strong>
...
...
...
</pre>

<p>Za implementaci &bdquo;otočeného&ldquo; operátoru +. Povšimněte si, že nyní
namísto dekorátoru <strong>@operator</strong> použijeme dekorátor
<strong>@operator_r</strong>, kde <strong>_r</strong> můžeme číst jako
<i>reverse</i>:</p>

<pre>
fn Vector3d <strong>Vector3d.add_scalar_r</strong>(self, int scalar) <strong>@operator_r(+)</strong>
...
...
...
</pre>

<p>Celý zdrojový kód příkladu doplněného o nový &bdquo;převrácený&ldquo;
operátor vypadá následovně:</p>

<pre>
module <strong>operator_overloading</strong>;
import std::io;
&nbsp;
struct <strong>Vector3d</strong>
{
    int x;
    int y;
    int z;
}
&nbsp;
fn Vector3d <strong>Vector3d.add_scalar</strong>(self, int scalar) <strong>@operator(+)</strong>
{
    Vector3d result;
    result.x = self.x + scalar;
    result.y = self.y + scalar;
    result.z = self.z + scalar;
    return result;
}
&nbsp;
fn Vector3d <strong>Vector3d.add_scalar_r</strong>(self, int scalar) <strong>@operator_r(+)</strong>
{
    Vector3d result;
    result.x = self.x + scalar;
    result.y = self.y + scalar;
    result.z = self.z + scalar;
    return result;
}
&nbsp;
fn Vector3d <strong>Vector3d.add_vector</strong>(self, Vector3d second) <strong>@operator(+)</strong>
{
    Vector3d result;
    result.x = self.x + second.x;
    result.y = self.y + second.y;
    result.z = self.z + second.z;
    return result;
}
&nbsp;
fn void <strong>main</strong>()
{
    Vector3d v1 = {1, 2, 3};
    Vector3d v2 = {10, 10, 10};
&nbsp;
    Vector3d v3 = v1 + v2;
&nbsp;
    io::printf("[%d %d %d]\n", v3.x, v3.y, v3.z);
&nbsp;
    Vector3d v4 = 100 + v3;
    io::printf("[%d %d %d]\n", v4.x, v4.y, v4.z);
}
</pre>

<p>Nyní bude možné příklad bez problémů přeložit a spustit:</p>

<pre>
$ <strong>./c3c compile-run add_operator_8.c3</strong>
Program linked to executable './operator_overloading'.
Launching ./operator_overloading
[11 12 13]
[111 112 113]
</pre>



<p><a name="k10"></a></p>
<h2 id="k10">10. Symetrická varianta přetíženého operátoru součtu</h2>

<p>Současná definice přetíženého operátoru + v&nbsp;jeho původní variantě
<strong>vektor+další_hodnota</strong> i v&nbsp;převrácené variantě
<strong>další_hodnota+vektor</strong> je sice v&nbsp;některých případech nutná,
ovšem pokud má být implementovaná operace komutativní, je dvojí definice spíše
kontraproduktivní (prakticky se totiž opakuje totožný kód, pouze se prohodí
parametry metody). Z&nbsp;tohoto důvodu programovací jazyk C3 podporuje
&bdquo;symetrickou&ldquo; variantu přetíženého operátoru, která se definuje
nikoli pomocí <strong>@operator</strong> ani <strong>@operator_r</strong>, ale
s&nbsp;využitím dekorátoru <strong>@operator_s</strong> (suffix
<strong>s</strong> je odvozen od slova <i>symmetric</i>). Pokud je operátor
přetížen tímto dekorátorem, bude funkční jak ve své přímé, tak i
&bdquo;převrácené&ldquo; variantě.</p>

<p>To tedy znamená, že operátor určený pro přičtení skaláru k&nbsp;vektoru nebo
vektoru ke skaláru lze definovat jedinou metodou:</p>

<pre>
fn Vector3d <strong>Vector3d.add_scalar</strong>(self, int scalar) <strong>@operator_s(+)</strong>
</pre>

<p>Otestujme si to na následujícím demonstračním příkladu, který provede dvě
varianty součtu: <strong>vektor+vektor</strong> (ten je vždy symetrický) a
<strong>skalár+vektor</strong>:</p>

<pre>
module <strong>operator_overloading</strong>;
import std::io;
&nbsp;
struct <strong>Vector3d</strong>
{
    int x;
    int y;
    int z;
}
&nbsp;
fn Vector3d <strong>Vector3d.add_scalar</strong>(self, int scalar) <strong>@operator_s(+)</strong>
{
    Vector3d result;
    result.x = self.x + scalar;
    result.y = self.y + scalar;
    result.z = self.z + scalar;
    return result;
}
&nbsp;
fn Vector3d <strong>Vector3d.add_vector</strong>(self, Vector3d second) <strong>@operator(+)</strong>
{
    Vector3d result;
    result.x = self.x + second.x;
    result.y = self.y + second.y;
    result.z = self.z + second.z;
    return result;
}
&nbsp;
fn void <strong>main</strong>()
{
    Vector3d v1 = {1, 2, 3};
    Vector3d v2 = {10, 10, 10};
&nbsp;
    Vector3d v3 = v1 + v2;
&nbsp;
    io::printf("[%d %d %d]\n", v3.x, v3.y, v3.z);
&nbsp;
    Vector3d v4 = 100 + v3;
    io::printf("[%d %d %d]\n", v4.x, v4.y, v4.z);
}
</pre>

<p>Výsledky:</p>

<pre>
$ <strong>./c3c compile-run add_operator_9.c3 </strong>
Program linked to executable './operator_overloading'.
Launching ./operator_overloading
[11 12 13]
[111 112 113]
</pre>



<p><a name="k11"></a></p>
<h2 id="k11">11. Přetížení unárního operátoru - (otočení znaménka)</h2>

<p></p>

<pre>
fn Vector3d <strong>Vector3d.unary_minus</strong>(self) <strong>@operator(-)</strong>
{
    Vector3d result;
    result.x = -self.x;
    result.y = -self.y;
    result.z = -self.z;
    return result;
}
</pre>

<p></p>

<pre>
module <strong>operator_overloading</strong>;
import std::io;
&nbsp;
struct <strong>Vector3d</strong>
{
    int x;
    int y;
    int z;
}
&nbsp;
fn Vector3d <strong>Vector3d.unary_minus</strong>(self) <strong>@operator(-)</strong>
{
    Vector3d result;
    result.x = -self.x;
    result.y = -self.y;
    result.z = -self.z;
    return result;
}
&nbsp;
fn void <strong>main</strong>()
{
    Vector3d v1 = {1, 2, 3};
&nbsp;
    io::printf("[%d %d %d]\n", v1.x, v1.y, v1.z);
&nbsp;
    Vector3d v2 = -v1;
    io::printf("[%d %d %d]\n", v2.x, v2.y, v2.z);
}
</pre>

<p></p>

<pre>
$ <strong>./c3c compile-run unary_minus.c3</strong>
&nbsp;
[1 2 3]
[-1 -2 -3]
</pre>



<p><a name="k12"></a></p>
<h2 id="k12">12. Přetížení operátoru pro porovnání dvou hodnot (rovnost)</h2>

<pre>
module <strong>operator_overloading</strong>;
import std::io;
&nbsp;
struct <strong>Vector3d</strong>
{
    int x;
    int y;
    int z;
}
&nbsp;
fn bool <strong>Vector3d.compare</strong>(self, Vector3d second) @operator(==)
{
    bool result;
    result = self.x == second.x;
    result &amp;= self.y == second.y;
    result &amp;= self.z == second.z;
    return result;
}
&nbsp;
fn void <strong>main</strong>()
{
    Vector3d v1 = {1, 2, 3};
    Vector3d v2 = {10, 10, 10};
    Vector3d v3 = {10, 10, 10};
&nbsp;
    io::printf("v1 == v2: %b\n", v1 == v2);
    io::printf("v1 == v3: %b\n", v1 == v3);
    io::printf("v2 == v3: %b\n", v2 == v3);
&nbsp;
    io::printf("v1 != v2: %b\n", v1 != v2);
    io::printf("v1 != v3: %b\n", v1 != v3);
    io::printf("v2 != v3: %b\n", v2 != v3);
}
</pre>

<pre>
$ <strong>./c3c compile-run equality_operator.c3 </strong>
&nbsp;
v1 == v2: 0
v1 == v3: 0
v2 == v3: 1
v1 != v2: 1
v1 != v3: 1
v2 != v3: 0
</pre>



<p><a name="k13"></a></p>
<h2 id="k13">13. Přetížení operátoru pro součin tak, aby se prováděl skalární součin dvou vektorů</h2>



<pre>
module <strong>operator_overloading</strong>;
import std::io;
&nbsp;
struct <strong>Vector3d</strong>
{
    int x;
    int y;
    int z;
}
&nbsp;
fn int Vector3d.dot_product(self, Vector3d second) @operator(*)
{
    int result;
    result = self.x * second.x;
    result += self.y * second.y;
    result += self.z * second.z;
    return result;
}
&nbsp;
fn void <strong>main</strong>()
{
    Vector3d v1 = {1, 2, 3};
    Vector3d v2 = {10, 10, 10};
&nbsp;
    int dp = v1 * v2;
    io::printf("%d\n", dp);
}
</pre>

<p></p>

<pre>
60
</pre>

<pre>
module <strong>operator_overloading</strong>;
import std::io;
&nbsp;
struct <strong>Vector3d</strong>
{
    int x;
    int y;
    int z;
}
&nbsp;
fn int Vector3d.dot_product(&amp;self, Vector3d second) @operator(*)
{
    int result;
    result = self.x * second.x;
    result += self.y * second.y;
    result += self.z * second.z;
    return result;
}
&nbsp;
fn void <strong>main</strong>()
{
    Vector3d v1 = {1, 2, 3};
    Vector3d v2 = {10, 10, 10};
&nbsp;
    int dp = v1 * v2;
    io::printf("%d\n", dp);
}
</pre>

<p></p>

<pre>
60
</pre>



<p><a name="k14"></a></p>
<h2 id="k14">14. Vynásobení složek vektoru skalární konstantou versus skalární součin vektorů</h2>

<pre>
module <strong>operator_overloading</strong>;
import std::io;
&nbsp;
struct <strong>Vector3d</strong>
{
    int x;
    int y;
    int z;
}
&nbsp;
fn Vector3d <strong>Vector3d.mul_scalar</strong>(&amp;self, int scalar) @operator_s(*)
{
    Vector3d result;
    result.x = self.x * scalar;
    result.y = self.y * scalar;
    result.z = self.z * scalar;
    return result;
}
&nbsp;
fn int <strong>Vector3d.dot_product</strong>(&amp;self, Vector3d second) @operator(*)
{
    int result;
    result = self.x * second.x;
    result += self.y * second.y;
    result += self.z * second.z;
    return result;
}
&nbsp;
fn void <strong>main</strong>()
{
    Vector3d v1 = {1, 2, 3};
    Vector3d v2 = {10, 10, 10};
&nbsp;
    int dp = v1 * v2;
    io::printf("%d\n", dp);
&nbsp;
    Vector3d v3 = v1 * 2;
    io::printf("[%d %d %d]\n", v3.x, v3.y, v3.z);
&nbsp;
    Vector3d v4 = 2 * v2;
    io::printf("[%d %d %d]\n", v4.x, v4.y, v4.z);
}
</pre>

<p></p>

<pre>
60
[2 4 6]
[20 20 20]
</pre>



<p><a name="k15"></a></p>
<h2 id="k15">15. Další operátory, které je možné přetížit</h2>

<p></p>



<p><a name="k16"></a></p>
<h2 id="k16">16. Přetížení operátoru pro výběr prvku pro čtení pomocí indexu</h2>

<p></p>

<pre>
module <strong>operator_overloading</strong>;
import std::io;
&nbsp;
struct <strong>Vector3d</strong>
{
    int x;
    int y;
    int z;
}
&nbsp;
fn int <strong>Vector3d.get</strong>(self, usz i) <strong>@operator([])</strong>
{
    switch (i) {
        case 0: return self.x;
        case 1: return self.y;
        case 2: return self.z;
        default: return 0;
    }
}
&nbsp;
fn void <strong>main</strong>()
{
    Vector3d v1 = {10, 20, 30};
&nbsp;
    for (int i=0; i&lt;=3; i++) {
        io::printf("v1[%d] = %d\n", i, v1[i]);
    }
}
</pre>

<p></p>

<pre>
v1[0] = 10
v1[1] = 20
v1[2] = 30
v1[3] = 0
</pre>

<p></p>

<pre>
module <strong>operator_overloading</strong>;
import std::io;
&nbsp;
struct <strong>Vector3d</strong>
{
    int x;
    int y;
    int z;
}
&nbsp;
fn int <strong>Vector3d.get</strong>(&amp;self, usz i) <strong>@operator([])</strong>
{
    switch (i) {
        case 0: return self.x;
        case 1: return self.y;
        case 2: return self.z;
        default: return 0;
    }

}
&nbsp;
fn void <strong>main</strong>()
{
    Vector3d v1 = {10, 20, 30};
&nbsp;
    for (int i=0; i&lt;=3; i++) {
        io::printf("v1[%d] = %d\n", i, v1[i]);
    }
}
</pre>

<p></p>

<pre>
v1[0] = 10
v1[1] = 20
v1[2] = 30
v1[3] = 0
</pre>



<p><a name="k17"></a></p>
<h2 id="k17">17. Klíč ve formě řetězce namísto celočíselného indexu, přetížení přiřazení</h2>

<p></p>

<pre>
module <strong>operator_overloading</strong>;
import std::io;
&nbsp;
struct <strong>Vector3d</strong>
{
    int x;
    int y;
    int z;
}
&nbsp;
fn int <strong>Vector3d.get</strong>(&amp;self, String key) <strong>@operator([])</strong>
{
    switch (key) {
        case "x": return self.x;
        case "y": return self.y;
        case "z": return self.z;
        default: return 0;
    }
}
&nbsp;
fn void <strong>main</strong>()
{
    Vector3d v1 = {10, 20, 30};

    io::printf("v1[x] = %d\n", v1["x"]);
    io::printf("v1[y] = %d\n", v1["y"]);
    io::printf("v1[z] = %d\n", v1["z"]);
}
</pre>

<p></p>

<pre>
v1[x] = 10
v1[y] = 20
v1[z] = 30
</pre>

<p></p>

<pre>
module <strong>operator_overloading</strong>;
import std::io;
&nbsp;
struct <strong>Vector3d</strong>
{
    int x;
    int y;
    int z;
}
&nbsp;
fn int Vector3d.get(&amp;self, String key) @operator([])
{
    switch (key) {
        case "x": return self.x;
        case "y": return self.y;
        case "z": return self.z;
        default: return 0;
    }
}
&nbsp;
fn void Vector3d.set(&amp;self, String key, int new_value) @operator([]=)
{
    switch (key) {
        case "x": self.x=new_value;
        case "y": self.y=new_value;
        case "z": self.z=new_value;
    }
}
&nbsp;
fn void <strong>main</strong>()
{
    Vector3d v1 = {10, 20, 30};
&nbsp;
    io::printf("v1[x] = %d\n", v1["x"]);
    io::printf("v1[y] = %d\n", v1["y"]);
    io::printf("v1[z] = %d\n", v1["z"]);
&nbsp;
    v1["x"] = 100;
    v1["y"] = 200;
    v1["z"] = 300;
&nbsp;
    io::printf("v1[x] = %d\n", v1["x"]);
    io::printf("v1[y] = %d\n", v1["y"]);
    io::printf("v1[z] = %d\n", v1["z"]);
}
</pre>

<p></p>

<pre>
v1[x] = 10
v1[y] = 20
v1[z] = 30
v1[x] = 100
v1[y] = 200
v1[z] = 300
</pre>



<p><a name="k18"></a></p>
<h2 id="k18">18. Přetížení speciálního operátoru <strong>len</strong></h2>

<p></p>

<pre>
module <strong>operator_overloading</strong>;
import std::io;
&nbsp;
struct <strong>Vector3d</strong>
{
    int x;
    int y;
    int z;
}
&nbsp;
fn int Vector3d.get(&amp;self, usz i) @operator([])
{
    switch (i) {
        case 0: return self.x;
        case 1: return self.y;
        case 2: return self.z;
        default: return 0;
    }
}
&nbsp;
fn void Vector3d.set(&amp;self, usz i, int new_value) @operator([]=)
{
    switch (i) {
        case 0: self.x=new_value;
        case 1: self.y=new_value;
        case 2: self.z=new_value;
    }
}
&nbsp;
fn usz Vector3d.len(&amp;self) @operator(len)
{
    return 3;
}
&nbsp;
fn void <strong>main</strong>()
{
    Vector3d v1 = {10, 20, 30};
&nbsp;
    foreach (item : v1)
    {
        io::printf("%d ", item);
    }
    io::printn();
&nbsp;
    v1[0] = 100;
    v1[1] = 200;
    v1[2] = 300;
&nbsp;
    foreach (item : v1)
    {
        io::printf("%d ", item);
    }
    io::printn();
}
</pre>

<p></p>

<pre>
10 20 30 
100 200 300 
</pre>



<p><a name="k19"></a></p>
<h2 id="k19">19. Repositář s&nbsp;demonstračními příklady</h2>

<p>Demonstrační příklady vytvořené pro nejnovější verzi programovacího jazyka
C3 byly uloženy do repositáře dostupného na adrese <a
href="https://github.com/tisnik/c3-examples">https://github.com/tisnik/c3-examples</a>.
Následují odkazy na jednotlivé příklady (či jejich nedokončené části).</p>

<p>Demonstrační příklady <a
href="https://www.root.cz/clanky/programovaci-jazyk-c3-evoluce-nikoli-revoluce/">z&nbsp;prvního
článku o programovacím jazyku C3</a>:</p>

<table>
<tr><th> #</th><th>Příklad</th><th>Stručný popis</th><th>Adresa</th></tr>
<tr><td> 1</td><td>factorial.c3</td><td>realizace výpočtu faktoriálu</td><td><a href="https://github.com/tisnik/c3-examples/blob/master/introduction/factorial.c3">https://github.com/tisnik/c3-examples/blob/master/introduction/factorial.c3</a></td></tr>
<tr><td> 2</td><td>factorial_macro.c3</td><td>výpočet faktoriálu konkrétní hodnoty implementovaný formou makra</td><td><a href="https://github.com/tisnik/c3-examples/blob/master/introduction/factorial_macro.c3">https://github.com/tisnik/c3-examples/blob/master/introduction/factorial_macro.c3</a></td></tr>
<tr><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td></tr>
<tr><td> 3</td><td>swap_macro.c3</td><td>makro realizující prohození dvou hodnot</td><td><a href="https://github.com/tisnik/c3-examples/blob/master/introduction/swap_macro.c3">https://github.com/tisnik/c3-examples/blob/master/introduction/swap_macro.c3</a></td></tr>
<tr><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td></tr>
<tr><td> 4</td><td>renderer.c</td><td>výpočet a vykreslení Juliovy množiny implementovaný v&nbsp;jazyku C</td><td><a href="https://github.com/tisnik/c3-examples/blob/master/introduction/renderer.c">https://github.com/tisnik/c3-examples/blob/master/introduction/renderer.c</a></td></tr>
<tr><td> 5</td><td>renderer_v1.c3</td><td>definice datové struktury s&nbsp;rozměry rastrového obrázku a skeleton všech funkcí</td><td><a href="https://github.com/tisnik/c3-examples/blob/master/introduction/renderer_v1.c3">https://github.com/tisnik/c3-examples/blob/master/introduction/renderer_v1.c3</a></td></tr>
<tr><td> 6</td><td>renderer_v2.c3</td><td>anotace parametrů funkcí typu ukazatel (<i>pointer</i>)</td><td><a href="https://github.com/tisnik/c3-examples/blob/master/introduction/renderer_v2.c3">https://github.com/tisnik/c3-examples/blob/master/introduction/renderer_v2.c3</a></td></tr>
<tr><td> 7</td><td>renderer_v3.c3</td><td>statická kontrola, zda se nepředávají neinicializované ukazatele</td><td><a href="https://github.com/tisnik/c3-examples/blob/master/introduction/renderer_v3.c3">https://github.com/tisnik/c3-examples/blob/master/introduction/renderer_v3.c3</a></td></tr>
<tr><td> 8</td><td>renderer_v4.c3</td><td>runtime kontrola, zda se nepředávají neinicializované ukazatele</td><td><a href="https://github.com/tisnik/c3-examples/blob/master/introduction/renderer_v4.c3">https://github.com/tisnik/c3-examples/blob/master/introduction/renderer_v4.c3</a></td></tr>
<tr><td> 9</td><td>renderer_v5.c3</td><td>první (nekorektní) varianta funkce pro inicializaci barvové palety</td><td><a href="https://github.com/tisnik/c3-examples/blob/master/introduction/renderer_v5.c3">https://github.com/tisnik/c3-examples/blob/master/introduction/renderer_v5.c3</a></td></tr>
<tr><td>10</td><td>renderer_v6.c3</td><td>druhá (korektní) varianta funkce pro inicializaci barvové palety</td><td><a href="https://github.com/tisnik/c3-examples/blob/master/introduction/renderer_v6.c3">https://github.com/tisnik/c3-examples/blob/master/introduction/renderer_v6.c3</a></td></tr>
<tr><td>11</td><td>renderer_v7.c3</td><td>volání knihovní I/O funkce a volání nativní céčkovské funkce</td><td><a href="https://github.com/tisnik/c3-examples/blob/master/introduction/renderer_v7.c3">https://github.com/tisnik/c3-examples/blob/master/introduction/renderer_v7.c3</a></td></tr>
<tr><td>12</td><td>renderer_v8.c3</td><td>plně funkční program pro výpočet a vykreslení Juliovy množiny</td><td><a href="https://github.com/tisnik/c3-examples/blob/master/introduction/renderer_v8.c3">https://github.com/tisnik/c3-examples/blob/master/introduction/renderer_v8.c3</a></td></tr>
</table>

<p>Demonstrační příklady <a
href="https://www.root.cz/clanky/programovaci-jazyk-c3-datove-typy-pro-moderni-architektury/">ze
druhého článku o jazyku C3</a>:</p>

<table>
<tr><th> #</th><th>Příklad</th><th>Stručný popis</th><th>Adresa</th></tr>
<tr><td>13</td><td>01_just_main.c3</td><td>struktura nejjednoduššího programu obsahujícího pouze prázdnou funkci <strong>main</strong></td><td><a href="https://github.com/tisnik/c3-examples/blob/master/c3-basics/01_just_main.c3">https://github.com/tisnik/c3-examples/blob/master/c3-basics/01_just_main.c3</a></td></tr>
<tr><td>14</td><td>02_module_name.c3</td><td>struktura programu s&nbsp;uvedeným plným jménem modulu</td><td><a href="https://github.com/tisnik/c3-examples/blob/master/c3-basics/02_module_name.c3">https://github.com/tisnik/c3-examples/blob/master/c3-basics/02_module_name.c3</a></td></tr>
<tr><td>15</td><td>03_hello_world.c3</td><td>klasický program typu &bdquo;Hello, world!&ldquo; napsaný v&nbsp;jazyku C3</td><td><a href="https://github.com/tisnik/c3-examples/blob/master/c3-basics/03_hello_world.c3">https://github.com/tisnik/c3-examples/blob/master/c3-basics/03_hello_world.c3</a></td></tr>
<tr><td>16</td><td>04_exit_value.c3</td><td>ukončení procesu s&nbsp;předáním návratového kódu zpět volajícímu programu</td><td><a href="https://github.com/tisnik/c3-examples/blob/master/c3-basics/04_exit_value.c3">https://github.com/tisnik/c3-examples/blob/master/c3-basics/04_exit_value.c3</a></td></tr>
<tr><td>17</td><td>05_c_function.c3</td><td>zavolání funkce definované v&nbsp;knihovně programovacího jazyka C</td><td><a href="https://github.com/tisnik/c3-examples/blob/master/c3-basics/05_c_function.c3">https://github.com/tisnik/c3-examples/blob/master/c3-basics/05_c_function.c3</a></td></tr>
<tr><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td></tr>
<tr><td>18</td><td>06_bool_type.c3</td><td>definice proměnných typu <i>pravdivostní hodnota</i> (<strong>bool</strong>)</td><td><a href="https://github.com/tisnik/c3-examples/blob/master/c3-basics/06_bool_type.c3">https://github.com/tisnik/c3-examples/blob/master/c3-basics/06_bool_type.c3</a></td></tr>
<tr><td>19</td><td>07_int_to_bool.c3</td><td>implicitní převod hodnoty typu <strong>int</strong> na pravdivostní hodnotu (nekorektní řešení)</td><td><a href="https://github.com/tisnik/c3-examples/blob/master/c3-basics/07_int_to_bool.c3">https://github.com/tisnik/c3-examples/blob/master/c3-basics/07_int_to_bool.c3</a></td></tr>
<tr><td>20</td><td>08_int_to_bool.c3</td><td>explicitní převod hodnoty typu <strong>int</strong> na pravdivostní hodnotu (korektní řešení)</td><td><a href="https://github.com/tisnik/c3-examples/blob/master/c3-basics/08_int_to_bool.c3">https://github.com/tisnik/c3-examples/blob/master/c3-basics/08_int_to_bool.c3</a></td></tr>
<tr><td>21</td><td>09_int_to_bool.c3</td><td>explicitní převod hodnoty typu <strong>int</strong> na pravdivostní hodnotu (nekorektní řešení)</td><td><a href="https://github.com/tisnik/c3-examples/blob/master/c3-basics/09_int_to_bool.c3">https://github.com/tisnik/c3-examples/blob/master/c3-basics/09_int_to_bool.c3</a></td></tr>
<tr><td>22</td><td>10_bool_sizeof.c3</td><td>zjištění velikosti paměti obsazené hodnotou typu <strong>bool</strong></td><td><a href="https://github.com/tisnik/c3-examples/blob/master/c3-basics/10_bool_sizeof.c3">https://github.com/tisnik/c3-examples/blob/master/c3-basics/10_bool_sizeof.c3</a></td></tr>
<tr><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td></tr>
<tr><td>23</td><td>11_int_types.c3</td><td>definice proměnných typu <i>celé číslo se znaménkem</i> s&nbsp;různou bitovou šířkou</td><td><a href="https://github.com/tisnik/c3-examples/blob/master/c3-basics/11_int_types.c3">https://github.com/tisnik/c3-examples/blob/master/c3-basics/11_int_types.c3</a></td></tr>
<tr><td>24</td><td>12_uint_types.c3</td><td>definice proměnných typu <i>celé číslo bez znaménka</i> s&nbsp;různou bitovou šířkou</td><td><a href="https://github.com/tisnik/c3-examples/blob/master/c3-basics/12_uint_types.c3">https://github.com/tisnik/c3-examples/blob/master/c3-basics/12_uint_types.c3</a></td></tr>
<tr><td>25</td><td>13_no_suffixes.c3</td><td>celočíselné konstanty bez uvedení suffixu (bitové šířky)</td><td><a href="https://github.com/tisnik/c3-examples/blob/master/c3-basics/13_no_suffixes.c3">https://github.com/tisnik/c3-examples/blob/master/c3-basics/13_no_suffixes.c3</a></td></tr>
<tr><td>26</td><td>14_suffixes.c3</td><td>celočíselné konstanty s&nbsp;uvedením sufficu (bitové šířky)</td><td><a href="https://github.com/tisnik/c3-examples/blob/master/c3-basics/14_suffixes.c3">https://github.com/tisnik/c3-examples/blob/master/c3-basics/14_suffixes.c3</a></td></tr>
<tr><td>27</td><td>15_int_sizeof.c3</td><td>zjištění velikosti paměti obsazené celočíselnými hodnotami se znaménkem</td><td><a href="https://github.com/tisnik/c3-examples/blob/master/c3-basics/15_int_sizeof.c3">https://github.com/tisnik/c3-examples/blob/master/c3-basics/15_int_sizeof.c3</a></td></tr>
<tr><td>28</td><td>16_uint_sizeof.c3</td><td>zjištění velikosti paměti obsazené celočíselnými hodnotami bez znaménka</td><td><a href="https://github.com/tisnik/c3-examples/blob/master/c3-basics/16_uint_sizeof.c3">https://github.com/tisnik/c3-examples/blob/master/c3-basics/16_uint_sizeof.c3</a></td></tr>
<tr><td>29</td><td>17_int_conversions.c3</td><td>korektní převody mezi celočíselnými hodnotami s&nbsp;různou bitovou šířkou</td><td><a href="https://github.com/tisnik/c3-examples/blob/master/c3-basics/17_int_conversions.c3">https://github.com/tisnik/c3-examples/blob/master/c3-basics/17_int_conversions.c3</a></td></tr>
<tr><td>30</td><td>18_int_conversions.c3</td><td>nekorektní převody mezi celočíselnými hodnotami s&nbsp;různou bitovou šířkou</td><td><a href="https://github.com/tisnik/c3-examples/blob/master/c3-basics/18_int_conversions.c3">https://github.com/tisnik/c3-examples/blob/master/c3-basics/18_int_conversions.c3</a></td></tr>
<tr><td>31</td><td>19_int_conversions.c3</td><td>explicitní převody a přetečení hodnot</td><td><a href="https://github.com/tisnik/c3-examples/blob/master/c3-basics/19_int_conversions.c3">https://github.com/tisnik/c3-examples/blob/master/c3-basics/19_int_conversions.c3</a></td></tr>
<tr><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td></tr>
<tr><td>32</td><td>20_float_types.c3</td><td>definice proměnných typu <i>numerická hodnota s&nbsp;plovoucí řádovou čárkou (tečkou)</i></td><td><a href="https://github.com/tisnik/c3-examples/blob/master/c3-basics/20_float_types.c3">https://github.com/tisnik/c3-examples/blob/master/c3-basics/20_float_types.c3</a></td></tr>
<tr><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td></tr>
<tr><td>33</td><td>21_vector_type.c3</td><td>definice vektoru obsahujícího celočíselné hodnoty</td><td><a href="https://github.com/tisnik/c3-examples/blob/master/c3-basics/21_vector_type.c3">https://github.com/tisnik/c3-examples/blob/master/c3-basics/21_vector_type.c3</a></td></tr>
<tr><td>34</td><td>22_vector_operations.c3</td><td>základní operace s&nbsp;celými vektory</td><td><a href="https://github.com/tisnik/c3-examples/blob/master/c3-basics/22_vector_operations.c3">https://github.com/tisnik/c3-examples/blob/master/c3-basics/22_vector_operations.c3</a></td></tr>
<tr><td>35</td><td>23_vector_sizes.c3</td><td>zjištění a tisk velikosti vektorů (různé datové typy prvků vektorů, shodná délka)</td><td><a href="https://github.com/tisnik/c3-examples/blob/master/c3-basics/23_vector_sizes.c3">https://github.com/tisnik/c3-examples/blob/master/c3-basics/23_vector_sizes.c3</a></td></tr>
<tr><td>36</td><td>24_vector_sizes.c3</td><td>zjištění a tisk velikosti vektorů (stejné datové typy prvků vektorů, odlišná délka)</td><td><a href="https://github.com/tisnik/c3-examples/blob/master/c3-basics/24_vector_sizes.c3">https://github.com/tisnik/c3-examples/blob/master/c3-basics/24_vector_sizes.c3</a></td></tr>
</table>

<p>Demonstrační příklady použité <a
href="https://www.root.cz/clanky/programovaci-jazyk-c3-slozene-datove-typy-a-kontejnery/">ve
třetím článku o jazyku C3</a>:</p>

<table>
<tr><th> #</th><th>Příklad</th><th>Stručný popis</th><th>Adresa</th></tr>
<tr><td>37</td><td>01_vector_type.c3</td><td>definice vektoru, modifikace prvků vektoru, tisk obsahu celého vektoru</td><td><a href="https://github.com/tisnik/c3-examples/blob/master/c3-containers/01_vector_type.c3">https://github.com/tisnik/c3-examples/blob/master/c3-containers/01_vector_type.c3</a></td></tr>
<tr><td>38</td><td>02_vector_parameter.c3</td><td>předání vektoru do funkce hodnotou</td><td><a href="https://github.com/tisnik/c3-examples/blob/master/c3-containers/02_vector_parameter.c3">https://github.com/tisnik/c3-examples/blob/master/c3-containers/02_vector_parameter.c3</a></td></tr>
<tr><td>39</td><td>03_vector_pointer.c3</td><td>předání vektoru do funkce odkazem (přes ukazatel)</td><td><a href="https://github.com/tisnik/c3-examples/blob/master/c3-containers/03_vector_pointer.c3">https://github.com/tisnik/c3-examples/blob/master/c3-containers/03_vector_pointer.c3</a></td></tr>
<tr><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td></tr>
<tr><td>40</td><td>04_array_type.c3</td><td>definice pole, modifikace prvků pole, tisk obsahu celého pole</td><td><a href="https://github.com/tisnik/c3-examples/blob/master/c3-containers/04_array_type.c3">https://github.com/tisnik/c3-examples/blob/master/c3-containers/04_array_type.c3</a></td></tr>
<tr><td>41</td><td>05_array_parameter.c3</td><td>předání pole do funkce hodnotou</td><td><a href="https://github.com/tisnik/c3-examples/blob/master/c3-containers/05_array_parameter.c3">https://github.com/tisnik/c3-examples/blob/master/c3-containers/05_array_parameter.c3</a></td></tr>
<tr><td>42</td><td>06_array_pointer.c3</td><td>předání pole do funkce odkazem (přes ukazatel)</td><td><a href="https://github.com/tisnik/c3-examples/blob/master/c3-containers/06_array_pointer.c3">https://github.com/tisnik/c3-examples/blob/master/c3-containers/06_array_pointer.c3</a></td></tr>
<tr><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td></tr>
<tr><td>43</td><td>07_slice_type.c3</td><td>vytvoření (konstrukce) řezu (<i>slice</i>)</td><td><a href="https://github.com/tisnik/c3-examples/blob/master/c3-containers/07_slice_type.c3">https://github.com/tisnik/c3-examples/blob/master/c3-containers/07_slice_type.c3</a></td></tr>
<tr><td>44</td><td>08_slice_parameter.c3</td><td>předání řezu do funkce</td><td><a href="https://github.com/tisnik/c3-examples/blob/master/c3-containers/08_slice_parameter.c3">https://github.com/tisnik/c3-examples/blob/master/c3-containers/08_slice_parameter.c3</a></td></tr>
<tr><td>45</td><td>09_slice_slicing.c3</td><td>konstrukce řezu z&nbsp;pole stejně pojmenovanou operací (řez od..do)</td><td><a href="https://github.com/tisnik/c3-examples/blob/master/c3-containers/09_slice_slicing.c3">https://github.com/tisnik/c3-examples/blob/master/c3-containers/09_slice_slicing.c3</a></td></tr>
<tr><td>46</td><td>10_slice_slicing.c3</td><td>konstrukce řezu z&nbsp;pole stejně pojmenovanou operací (záporné indexy)</td><td><a href="https://github.com/tisnik/c3-examples/blob/master/c3-containers/10_slice_slicing.c3">https://github.com/tisnik/c3-examples/blob/master/c3-containers/10_slice_slicing.c3</a></td></tr>
<tr><td>47</td><td>11_slice_slicing.c3</td><td>konstrukce řezu z&nbsp;pole stejně pojmenovanou operací (určení délky řezu)</td><td><a href="https://github.com/tisnik/c3-examples/blob/master/c3-containers/11_slice_slicing.c3">https://github.com/tisnik/c3-examples/blob/master/c3-containers/11_slice_slicing.c3</a></td></tr>
<tr><td>48</td><td>12_slice_of_slice.c3</td><td>konstrukce řezu z&nbsp;jiného řezu</td><td><a href="https://github.com/tisnik/c3-examples/blob/master/c3-containers/12_slice_of_slice.c3">https://github.com/tisnik/c3-examples/blob/master/c3-containers/12_slice_of_slice.c3</a></td></tr>
<tr><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td></tr>
<tr><td>49</td><td>13_list_type.c3</td><td>vytvoření (konstrukce) seznamu</td><td><a href="https://github.com/tisnik/c3-examples/blob/master/c3-containers/13_list_type.c3">https://github.com/tisnik/c3-examples/blob/master/c3-containers/13_list_type.c3</a></td></tr>
<tr><td>50</td><td>14_list_parameter.c3</td><td>předání seznamu do funkce</td><td><a href="https://github.com/tisnik/c3-examples/blob/master/c3-containers/14_list_parameter.c3">https://github.com/tisnik/c3-examples/blob/master/c3-containers/14_list_parameter.c3</a></td></tr>
<tr><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td></tr>
<tr><td>51</td><td>15_dynamic_array.c3</td><td>vytvoření (konstrukce) dynamicky alokovaného pole</td><td><a href="https://github.com/tisnik/c3-examples/blob/master/c3-containers/15_dynamic_array.c3">https://github.com/tisnik/c3-examples/blob/master/c3-containers/15_dynamic_array.c3</a></td></tr>
<tr><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td></tr>
<tr><td>52</td><td>16_string_type.c3</td><td>základní typ řetězce <strong>string</strong></td><td><a href="https://github.com/tisnik/c3-examples/blob/master/c3-containers/16_string_type.c3">https://github.com/tisnik/c3-examples/blob/master/c3-containers/16_string_type.c3</a></td></tr>
<tr><td>53</td><td>17_string_unicode.c3</td><td>Unicode znaky v&nbsp;řetězci typu <strong>string</strong></td><td><a href="https://github.com/tisnik/c3-examples/blob/master/c3-containers/17_string_unicode.c3">https://github.com/tisnik/c3-examples/blob/master/c3-containers/17_string_unicode.c3</a></td></tr>
<tr><td>54</td><td>18_zstring_type.c3</td><td>řetězce ukončené nulou (C-string, ASCIIZ)</td><td><a href="https://github.com/tisnik/c3-examples/blob/master/c3-containers/18_zstring_type.c3">https://github.com/tisnik/c3-examples/blob/master/c3-containers/18_zstring_type.c3</a></td></tr>
<tr><td>55</td><td>19_zstring_unicode.c3</td><td>Unicode znaky v&nbsp;řetězci typu <strong>zstring</strong></td><td><a href="https://github.com/tisnik/c3-examples/blob/master/c3-containers/19_zstring_unicode.c3">https://github.com/tisnik/c3-examples/blob/master/c3-containers/19_zstring_unicode.c3</a></td></tr>
<tr><td>56</td><td>20_string_comparison.c3</td><td>porovnávání obsahu řetězců</td><td><a href="https://github.com/tisnik/c3-examples/blob/master/c3-containers/20_string_comparison.c3">https://github.com/tisnik/c3-examples/blob/master/c3-containers/20_string_comparison.c3</a></td></tr>
</table>

<p>Demonstrační příklady <a
href="https://www.root.cz/clanky/programovaci-jazyk-c3-podminky-rozvetveni-a-programove-smycky/">ze
čtvrtého</a> o jazyku C3:</p>

<table>
<tr><th> #</th><th>Příklad</th><th>Stručný popis</th><th>Adresa</th></tr>
<tr><td>57</td><td>01_program_stub.c3</td><td>struktura programu s&nbsp;uvedeným plným jménem modulu</td><td><a href="https://github.com/tisnik/c3-examples/blob/master/c3-control-flow/01_program_stub.c3">https://github.com/tisnik/c3-examples/blob/master/c3-control-flow/01_program_stub.c3</a></td></tr>
<tr><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td></tr>
<tr><td>58</td><td>02_if.c3</td><td>nejjednodušší forma rozvětvení založené na konstrukci <strong>if</strong></td><td><a href="https://github.com/tisnik/c3-examples/blob/master/c3-control-flow/02_if.c3">https://github.com/tisnik/c3-examples/blob/master/c3-control-flow/02_if.c3</a></td></tr>
<tr><td>59</td><td>03_if_else.c3</td><td>plné rozvětvení realizované konstrukcí <strong>if-else</strong></td><td><a href="https://github.com/tisnik/c3-examples/blob/master/c3-control-flow/03_if_else.c3">https://github.com/tisnik/c3-examples/blob/master/c3-control-flow/03_if_else.c3</a></td></tr>
<tr><td>60</td><td>04_improper_if.c3</td><td>nekorektní způsob zápisu programové konstrukce <strong>if-else</strong> (porovnání s&nbsp;jazykem C)</td><td><a href="https://github.com/tisnik/c3-examples/blob/master/c3-control-flow/04_improper_if.c3">https://github.com/tisnik/c3-examples/blob/master/c3-control-flow/04_improper_if.c3</a></td></tr>
<tr><td>61</td><td>05_improper_if.c3</td><td>nekorektní způsob zápisu programové konstrukce <strong>if-else</strong> (porovnání s&nbsp;jazykem C)</td><td><a href="https://github.com/tisnik/c3-examples/blob/master/c3-control-flow/05_improper_if.c3">https://github.com/tisnik/c3-examples/blob/master/c3-control-flow/05_improper_if.c3</a></td></tr>
<tr><td>62</td><td>06_if_else_if.c3</td><td>složitější rozvětvení založené na programové konstrukci <strong>if-else if-else</strong></td><td><a href="https://github.com/tisnik/c3-examples/blob/master/c3-control-flow/06_if_else_if.c3">https://github.com/tisnik/c3-examples/blob/master/c3-control-flow/06_if_else_if.c3</a></td></tr>
<tr><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td></tr>
<tr><td>63</td><td>07_switch_basic.c3</td><td>základní forma vícenásobného rozvětvení založeného na konstrukci <strong>switch-case</strong></td><td><a href="https://github.com/tisnik/c3-examples/blob/master/c3-control-flow/07_switch_basic.c3">https://github.com/tisnik/c3-examples/blob/master/c3-control-flow/07_switch_basic.c3</a></td></tr>
<tr><td>64</td><td>08_switch_basic.c3</td><td>větší množství podmínek a programová konstrukce <strong>switch-case</strong></td><td><a href="https://github.com/tisnik/c3-examples/blob/master/c3-control-flow/08_switch_basic.c3">https://github.com/tisnik/c3-examples/blob/master/c3-control-flow/08_switch_basic.c3</a></td></tr>
<tr><td>65</td><td>09_switch_condition.c3</td><td>podmínky zapsané ve větvích programové konstrukci <strong>switch-case</strong> vyhodnocované v&nbsp;čase běhu procesu</td><td><a href="https://github.com/tisnik/c3-examples/blob/master/c3-control-flow/09_switch_condition.c3">https://github.com/tisnik/c3-examples/blob/master/c3-control-flow/09_switch_condition.c3</a></td></tr>
<tr><td>66</td><td>10_switch_true.c3</td><td>konstrukce <strong>switch-case</strong> bez uvedeného výrazu za klíčovým slovem <strong>switch</strong></td><td><a href="https://github.com/tisnik/c3-examples/blob/master/c3-control-flow/10_switch_true.c3">https://github.com/tisnik/c3-examples/blob/master/c3-control-flow/10_switch_true.c3</a></td></tr>
<tr><td>67</td><td>11_switch_break.c3</td><td>zápis prázdné větve <strong>default</strong> v&nbsp;programové konstrukci <strong>switch-case</strong></td><td><a href="https://github.com/tisnik/c3-examples/blob/master/c3-control-flow/11_switch_break.c3">https://github.com/tisnik/c3-examples/blob/master/c3-control-flow/11_switch_break.c3</a></td></tr>
<tr><td>68</td><td>12_switch_nextcase.c3</td><td>pokračování ve vykonávání konstrukce <strong>switch-case</strong> vynucené klíčovým slovem <strong>nextcase</strong></td><td><a href="https://github.com/tisnik/c3-examples/blob/master/c3-control-flow/12_switch_nextcase.c3">https://github.com/tisnik/c3-examples/blob/master/c3-control-flow/12_switch_nextcase.c3</a></td></tr>
<tr><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td></tr>
<tr><td>69</td><td>13_for_loop.c3</td><td>základní forma programové smyčky realizované klíčovým slovem <strong>for</strong></td><td><a href="https://github.com/tisnik/c3-examples/blob/master/c3-control-flow/13_for_loop.c3">https://github.com/tisnik/c3-examples/blob/master/c3-control-flow/13_for_loop.c3</a></td></tr>
<tr><td>70</td><td>14_foreach_loop.c3</td><td>základní forma programové smyčky typu <strong>for-each</strong></td><td><a href="https://github.com/tisnik/c3-examples/blob/master/c3-control-flow/14_foreach_loop.c3">https://github.com/tisnik/c3-examples/blob/master/c3-control-flow/14_foreach_loop.c3</a></td></tr>
<tr><td>71</td><td>15_foreach_loop.c3</td><td>programová smyčka <strong>for-each</strong> vracející index prvku i hodnotu prvku</td><td><a href="https://github.com/tisnik/c3-examples/blob/master/c3-control-flow/15_foreach_loop.c3">https://github.com/tisnik/c3-examples/blob/master/c3-control-flow/15_foreach_loop.c3</a></td></tr>
<tr><td>72</td><td>16_foreach_loop.c3</td><td>modifikace obsahu pole v&nbsp;programové smyčce <strong>for-each</strong></td><td><a href="https://github.com/tisnik/c3-examples/blob/master/c3-control-flow/16_foreach_loop.c3">https://github.com/tisnik/c3-examples/blob/master/c3-control-flow/16_foreach_loop.c3</a></td></tr>
<tr><td>73</td><td>17_foreach_loop.c3</td><td>pokus o modifikaci obsahu procházeného pole</td><td><a href="https://github.com/tisnik/c3-examples/blob/master/c3-control-flow/17_foreach_loop.c3">https://github.com/tisnik/c3-examples/blob/master/c3-control-flow/17_foreach_loop.c3</a></td></tr>
<tr><td>74</td><td>18_foreach_loop.c3</td><td>modifikace procházeného pole přes ukazatel na prvek</td><td><a href="https://github.com/tisnik/c3-examples/blob/master/c3-control-flow/18_foreach_loop.c3">https://github.com/tisnik/c3-examples/blob/master/c3-control-flow/18_foreach_loop.c3</a></td></tr>
<tr><td>75</td><td>19_foreach_r_loop.c3</td><td>programová smyčka <strong>for-each</strong>, ve které se sekvencí prochází v&nbsp;opačném pořadí</td><td><a href="https://github.com/tisnik/c3-examples/blob/master/c3-control-flow/19_foreach_r_loop.c3">https://github.com/tisnik/c3-examples/blob/master/c3-control-flow/19_foreach_r_loop.c3</a></td></tr>
<tr><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td></tr>
<tr><td>76</td><td>20_while_loop.c3</td><td>základní forma programové smyčky typu <strong>while</strong></td><td><a href="https://github.com/tisnik/c3-examples/blob/master/c3-control-flow/20_while_loop.c3">https://github.com/tisnik/c3-examples/blob/master/c3-control-flow/20_while_loop.c3</a></td></tr>
<tr><td>77</td><td>21_while_loop_2.c3</td><td>programová smyčka typu <strong>while</strong> s&nbsp;konstrukcí <strong>break</strong></td><td><a href="https://github.com/tisnik/c3-examples/blob/master/c3-control-flow/21_while_loop_2.c3">https://github.com/tisnik/c3-examples/blob/master/c3-control-flow/21_while_loop_2.c3</a></td></tr>
<tr><td>78</td><td>22_nested_loops.c3</td><td>realizace vnořených programových smyček</td><td><a href="https://github.com/tisnik/c3-examples/blob/master/c3-control-flow/22_nested_loops.c3">https://github.com/tisnik/c3-examples/blob/master/c3-control-flow/22_nested_loops.c3</a></td></tr>
<tr><td>79</td><td>23_break.c3</td><td>vnořené programové smyčky a příkaz <strong>break</strong>: ukončení vnitřní smyčky</td><td><a href="https://github.com/tisnik/c3-examples/blob/master/c3-control-flow/23_break.c3">https://github.com/tisnik/c3-examples/blob/master/c3-control-flow/23_break.c3</a></td></tr>
<tr><td>80</td><td>24_break.c3</td><td>vnořené programové smyčky a příkaz <strong>break</strong>: ukončení vnější smyčky</td><td><a href="https://github.com/tisnik/c3-examples/blob/master/c3-control-flow/24_break.c3">https://github.com/tisnik/c3-examples/blob/master/c3-control-flow/24_break.c3</a></td></tr>
<tr><td>81</td><td>25_break.c3</td><td>vnořené programové smyčky a příkaz <strong>break</strong>, varianta se smyčkami typu <strong>while</strong></td><td><a href="https://github.com/tisnik/c3-examples/blob/master/c3-control-flow/25_break.c3">https://github.com/tisnik/c3-examples/blob/master/c3-control-flow/25_break.c3</a></td></tr>
</table>

<p>Demonstrační příklady <a
href="https://www.root.cz/clanky/programovaci-jazyk-c3-podminky-rozvetveni-a-programove-smycky/">z&nbsp;pátého</a>
článku o jazyku C3:</p>

<table>
<tr><th> #</th><th>Příklad</th><th>Stručný popis</th><th>Adresa</th></tr>
<tr><td>82</td><td>01_regular_variable.c3</td><td>definice běžné proměnné typu <strong>int</strong>, přístup k&nbsp;hodnotě této proměnné</td><td><a href="https://github.com/tisnik/c3-examples/blob/master/c3-errors-handling/01_regular_variable.c3">https://github.com/tisnik/c3-examples/blob/master/c3-errors-handling/01_regular_variable.c3</a></td></tr>
<tr><td>83</td><td>02_optional_value.c3</td><td>definice proměnné typu <strong>Optional int</strong>, pokus o přímý přístup k&nbsp;hodnotě této proměnné (nekorektní varianta)</td><td><a href="https://github.com/tisnik/c3-examples/blob/master/c3-errors-handling/02_optional_value.c3">https://github.com/tisnik/c3-examples/blob/master/c3-errors-handling/02_optional_value.c3</a></td></tr>
<tr><td>84</td><td>03_optional_value.c3</td><td>korektní čtení proměnné typu <strong>Optional int</strong> s&nbsp;detekcí chyby</td><td><a href="https://github.com/tisnik/c3-examples/blob/master/c3-errors-handling/03_optional_value.c3">https://github.com/tisnik/c3-examples/blob/master/c3-errors-handling/03_optional_value.c3</a></td></tr>
<tr><td>85</td><td>04_optional_value.c3</td><td>korektní čtení proměnné typu <strong>Optional int</strong> s&nbsp;detekcí chyby</td><td><a href="https://github.com/tisnik/c3-examples/blob/master/c3-errors-handling/04_optional_value.c3">https://github.com/tisnik/c3-examples/blob/master/c3-errors-handling/04_optional_value.c3</a></td></tr>
<tr><td>86</td><td>05_fault.c3</td><td>uživatelsky definovaný typ nesoucí informaci o chybě</td><td><a href="https://github.com/tisnik/c3-examples/blob/master/c3-errors-handling/05_fault.c3">https://github.com/tisnik/c3-examples/blob/master/c3-errors-handling/05_fault.c3</a></td></tr>
<tr><td>87</td><td>06_fault.c3</td><td>uživatelsky definovaný typ nesoucí informaci o chybě</td><td><a href="https://github.com/tisnik/c3-examples/blob/master/c3-errors-handling/06_fault.c3">https://github.com/tisnik/c3-examples/blob/master/c3-errors-handling/06_fault.c3</a></td></tr>
<tr><td>88</td><td>07_force_unwrap.c3</td><td>použití operátoru !! (<strong>force unwrap</strong>)</td><td><a href="https://github.com/tisnik/c3-examples/blob/master/c3-errors-handling/07_force_unwrap.c3">https://github.com/tisnik/c3-examples/blob/master/c3-errors-handling/07_force_unwrap.c3</a></td></tr>
<tr><td>89</td><td>08_force_unwrap.c3</td><td>použití operátoru !! (<strong>force unwrap</strong>)</td><td><a href="https://github.com/tisnik/c3-examples/blob/master/c3-errors-handling/08_force_unwrap.c3">https://github.com/tisnik/c3-examples/blob/master/c3-errors-handling/08_force_unwrap.c3</a></td></tr>
<td><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td></td>
<tr><td>90</td><td>09_factorial.c3</td><td>běžný výpočet faktoriálu bez reakce na neplatný vstup</td><td><a href="https://github.com/tisnik/c3-examples/blob/master/c3-errors-handling/09_factorial.c3">https://github.com/tisnik/c3-examples/blob/master/c3-errors-handling/09_factorial.c3</a></td></tr>
<tr><td>91</td><td>10_factorial.c3</td><td>výpočet faktoriálu s&nbsp;reakcí na neplatný vstup &ndash; řešení bez kontroly návratové hodnoty</td><td><a href="https://github.com/tisnik/c3-examples/blob/master/c3-errors-handling/10_factorial.c3">https://github.com/tisnik/c3-examples/blob/master/c3-errors-handling/10_factorial.c3</a></td></tr>
<tr><td>92</td><td>11_factorial.c3</td><td>výpočet faktoriálu s&nbsp;reakcí na neplatný vstup &ndash; řešení s&nbsp;kontrolou návratové hodnoty</td><td><a href="https://github.com/tisnik/c3-examples/blob/master/c3-errors-handling/11_factorial.c3">https://github.com/tisnik/c3-examples/blob/master/c3-errors-handling/11_factorial.c3</a></td></tr>
<td><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td></td>
<tr><td>93</td><td>12_defer_basic_usage.c3</td><td>konstrukce <strong>defer</strong> v&nbsp;programovacím jazyce C3</td><td><a href="https://github.com/tisnik/c3-examples/blob/master/c3-errors-handling/12_defer_basic_usage.c3">https://github.com/tisnik/c3-examples/blob/master/c3-errors-handling/12_defer_basic_usage.c3</a></td></tr>
<tr><td>94</td><td>13_more_defers.c3</td><td>pořadí provádění příkazů v&nbsp;blocích <strong>defer</strong></td><td><a href="https://github.com/tisnik/c3-examples/blob/master/c3-errors-handling/13_more_defers.c3">https://github.com/tisnik/c3-examples/blob/master/c3-errors-handling/13_more_defers.c3</a></td></tr>
<tr><td>95</td><td>14_defer_scope.c3</td><td>konstrukce <strong>defer</strong> definovaná ve vnitřních blocích v&nbsp;jazyce C3</td><td><a href="https://github.com/tisnik/c3-examples/blob/master/c3-errors-handling/14_defer_scope.c3">https://github.com/tisnik/c3-examples/blob/master/c3-errors-handling/14_defer_scope.c3</a></td></tr>
<tr><td>96</td><td>15_defer_return.c3</td><td>konstrukce <strong>defer</strong> a <strong>return</strong></td><td><a href="https://github.com/tisnik/c3-examples/blob/master/c3-errors-handling/15_defer_return.c3">https://github.com/tisnik/c3-examples/blob/master/c3-errors-handling/15_defer_return.c3</a></td></tr>
<td><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td></td>
<tr><td>97</td><td>16_init_finalize.c3</td><td>funkce označené jako <strong>@init</strong> a <strong>@finalizer</strong></td><td><a href="https://github.com/tisnik/c3-examples/blob/master/c3-errors-handling/16_init_finalize.c3">https://github.com/tisnik/c3-examples/blob/master/c3-errors-handling/16_init_finalize.c3</a></td></tr>
<td><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td></td>
<tr><td>98</td><td>defer.go</td><td>konstrukce <strong>defer</strong> v&nbsp;programovacím jazyce Go</td><td><a href="https://github.com/tisnik/c3-examples/blob/master/c3-errors-handling/defer.go">https://github.com/tisnik/c3-examples/blob/master/c3-errors-handling/defer.go</a></td></tr>
<tr><td>99</td><td>defer_scope.go</td><td>konstrukce <strong>defer</strong> definovaná ve vnitřních blocích v&nbsp;jazyce Go</td><td><a href="https://github.com/tisnik/c3-examples/blob/master/c3-errors-handling/defer_scope.go">https://github.com/tisnik/c3-examples/blob/master/c3-errors-handling/defer_scope.go</a></td></tr>
</table>

<p>Následují odkazy na demonstrační příklady z&nbsp;článku
předchozího:</p>

<table>
<tr><th> #</th><th>Příklad</th><th>Stručný popis</th><th>Adresa</th></tr>
<tr><td>100</td><td>01_regular_function.c3</td><td>deklarace běžných funkcí v&nbsp;jazyku C3</td><td><a href="https://github.com/tisnik/c3-examples/blob/master/c3-functions/01_regular_function.c3">https://github.com/tisnik/c3-examples/blob/master/c3-functions/01_regular_function.c3</a></td></tr>
<tr><td>101</td><td>02_check_arguments.c3</td><td>kontrola parametrů předávaných do funkce překladačem jazyka C3</td><td><a href="https://github.com/tisnik/c3-examples/blob/master/c3-functions/02_check_arguments.c3">https://github.com/tisnik/c3-examples/blob/master/c3-functions/02_check_arguments.c3</a></td></tr>
<td><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td></td>
<tr><td>102</td><td>03_default_arguments.c3</td><td>funkce s&nbsp;jedním parametrem, který má nastavenou výchozí hodnotu a jedním běžným parametrem (korektní pořadí parametrů)</td><td><a href="https://github.com/tisnik/c3-examples/blob/master/c3-functions/03_default_arguments.c3">https://github.com/tisnik/c3-examples/blob/master/c3-functions/03_default_arguments.c3</a></td></tr>
<tr><td>103</td><td>04_default_arguments.c3</td><td>funkce se všemi parametry s&nbsp;nastavenu výchozí hodnotou</td><td><a href="https://github.com/tisnik/c3-examples/blob/master/c3-functions/04_default_arguments.c3">https://github.com/tisnik/c3-examples/blob/master/c3-functions/04_default_arguments.c3</a></td></tr>
<tr><td>104</td><td>05_default_arguments.c3</td><td>funkce s&nbsp;jedním parametrem, který má nastavenou výchozí hodnotu a jedním běžným parametrem (nekorektní pořadí parametrů)</td><td><a href="https://github.com/tisnik/c3-examples/blob/master/c3-functions/05_default_arguments.c3">https://github.com/tisnik/c3-examples/blob/master/c3-functions/05_default_arguments.c3</a></td></tr>
<td><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td></td>
<tr><td>105</td><td>06_named_arguments.c3</td><td>explicitní uvedení jmen parametrů při volání funkce</td><td><a href="https://github.com/tisnik/c3-examples/blob/master/c3-functions/06_named_arguments.c3">https://github.com/tisnik/c3-examples/blob/master/c3-functions/06_named_arguments.c3</a></td></tr>
<tr><td>106</td><td>07_named_arguments.c3</td><td>explicitní uvedení jmen parametrů při volání funkce</td><td><a href="https://github.com/tisnik/c3-examples/blob/master/c3-functions/07_named_arguments.c3">https://github.com/tisnik/c3-examples/blob/master/c3-functions/07_named_arguments.c3</a></td></tr>
<tr><td>107</td><td>08_named_default_arguments.c3</td><td>pojmenování parametrů s&nbsp;výchozí hodnotou při volání funkce</td><td><a href="https://github.com/tisnik/c3-examples/blob/master/c3-functions/08_named_default_arguments.c3">https://github.com/tisnik/c3-examples/blob/master/c3-functions/08_named_default_arguments.c3</a></td></tr>
<td><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td></td>
<tr><td>108</td><td>09_sum.c3</td><td>realizace funkce pro výpočet součtu všech předaných hodnot</td><td><a href="https://github.com/tisnik/c3-examples/blob/master/c3-functions/09_sum.c3">https://github.com/tisnik/c3-examples/blob/master/c3-functions/09_sum.c3</a></td></tr>
<tr><td>109</td><td>10_sum.c3</td><td>předání obsahu pole do funkce s&nbsp;proměnným počtem parametrů</td><td><a href="https://github.com/tisnik/c3-examples/blob/master/c3-functions/10_sum.c3">https://github.com/tisnik/c3-examples/blob/master/c3-functions/10_sum.c3</a></td></tr>
<tr><td>110</td><td>11_varargs.c3</td><td>pořadí předávání parametrů do funkce s&nbsp;proměnným počtem parametrů (nekorektní způsob použití)</td><td><a href="https://github.com/tisnik/c3-examples/blob/master/c3-functions/11_varargs.c3">https://github.com/tisnik/c3-examples/blob/master/c3-functions/11_varargs.c3</a></td></tr>
<tr><td>111</td><td>12_varargs.c3</td><td>pořadí předávání parametrů do funkce s&nbsp;proměnným počtem parametrů (korektní způsob použití)</td><td><a href="https://github.com/tisnik/c3-examples/blob/master/c3-functions/12_varargs.c3">https://github.com/tisnik/c3-examples/blob/master/c3-functions/12_varargs.c3</a></td></tr>
<td><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td></td>
<tr><td>112</td><td>13_optional.c3</td><td>funkce vracející hodnotu typu <i>Optional</i></td><td><a href="https://github.com/tisnik/c3-examples/blob/master/c3-functions/13_optional.c3">https://github.com/tisnik/c3-examples/blob/master/c3-functions/13_optional.c3</a></td></tr>
<tr><td>113</td><td>14_optional.c3</td><td>využití operátoru <strong>??</strong></td><td><a href="https://github.com/tisnik/c3-examples/blob/master/c3-functions/14_optional.c3">https://github.com/tisnik/c3-examples/blob/master/c3-functions/14_optional.c3</a></td></tr>
<td><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td></td>
<tr><td>114</td><td>15_contract.c3</td><td>kontrakty uvedené u funkcí</td><td><a href="https://github.com/tisnik/c3-examples/blob/master/c3-functions/15_contract.c3">https://github.com/tisnik/c3-examples/blob/master/c3-functions/15_contract.c3</a></td></tr>
<tr><td>115</td><td>16_contract.c3</td><td>kontrakty uvedené u funkcí</td><td><a href="https://github.com/tisnik/c3-examples/blob/master/c3-functions/16_contract.c3">https://github.com/tisnik/c3-examples/blob/master/c3-functions/16_contract.c3</a></td></tr>
<td><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td></td>
<tr><td>116</td><td>17_c_declaration.c3</td><td>deklarace funkce bez parametrů &bdquo;céčkovým způsobem&ldquo; (nekorektní zápis)</td><td><a href="https://github.com/tisnik/c3-examples/blob/master/c3-functions/17_c_declaration.c3">https://github.com/tisnik/c3-examples/blob/master/c3-functions/17_c_declaration.c3</a></td></tr>
<tr><td>117</td><td>18_check_return_type.c3</td><td>kontrola návratové hodnoty překladačem jazyka C3</td><td><a href="https://github.com/tisnik/c3-examples/blob/master/c3-functions/18_check_return_type.c3">https://github.com/tisnik/c3-examples/blob/master/c3-functions/18_check_return_type.c3</a></td></tr>
<tr><td>118</td><td>19_check_return_value.c3</td><td>kontrola počtu návratových hodnot překladačem jazyka C3</td><td><a href="https://github.com/tisnik/c3-examples/blob/master/c3-functions/19_check_return_value.c3">https://github.com/tisnik/c3-examples/blob/master/c3-functions/19_check_return_value.c3</a></td></tr>
<tr><td>119</td><td>20_in_out_params.c3</td><td>předání ukazatelů do volané funkce</td><td><a href="https://github.com/tisnik/c3-examples/blob/master/c3-functions/20_in_out_params.c3">https://github.com/tisnik/c3-examples/blob/master/c3-functions/20_in_out_params.c3</a></td></tr>
<tr><td>120</td><td>21_in_out_params.c3</td><td>označení ukazatelů kontrakty <strong>[in]</strong> a <strong>[out]</strong></td><td><a href="https://github.com/tisnik/c3-examples/blob/master/c3-functions/21_in_out_params.c3">https://github.com/tisnik/c3-examples/blob/master/c3-functions/21_in_out_params.c3</a></td></tr>
<tr><td>121</td><td>22_in_out_params.c3</td><td>označení ukazatelů kontrakty <strong>[in]</strong> a <strong>[out]</strong></td><td><a href="https://github.com/tisnik/c3-examples/blob/master/c3-functions/22_in_out_params.c3">https://github.com/tisnik/c3-examples/blob/master/c3-functions/22_in_out_params.c3</a></td></tr>
<tr><td>122</td><td>23_void_pointer.c3</td><td>předávání ukazatelů typu <strong>void *</strong> do volané funkce</td><td><a href="https://github.com/tisnik/c3-examples/blob/master/c3-functions/23_void_pointer.c3">https://github.com/tisnik/c3-examples/blob/master/c3-functions/23_void_pointer.c3</a></td></tr>
<tr><td>123</td><td>24_contract.c3</td><td>kontrakt zapsaný před hlavičkou funkce</td><td><a href="https://github.com/tisnik/c3-examples/blob/master/c3-functions/24_contract.c3">https://github.com/tisnik/c3-examples/blob/master/c3-functions/24_contract.c4</a></td></tr>
</table>

<p>Demonstrační příklady <a
href="https://www.root.cz/clanky/funkce-a-metody-v-programovacim-jazyku-c3-dokonceni/">z&nbsp;předchozího
článku o funkcích v&nbsp;C3</a>:</p>

<table>
<tr><th> #</th><th>Příklad</th><th>Stručný popis</th><th>Adresa</th></tr>
<tr><td>124</td><td>25_function_type.c3</td><td>definice nového datového typu &bdquo;funkce&ldquo;</td><td><a href="https://github.com/tisnik/c3-examples/blob/master/c3-functions/25_function_type.c3">https://github.com/tisnik/c3-examples/blob/master/c3-functions/25_function_type.c3</a></td></tr>
<tr><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td></tr>
<tr><td>125</td><td>26_short_function.c3</td><td>zkrácený způsob zápisu běžné funkce</td><td><a href="https://github.com/tisnik/c3-examples/blob/master/c3-functions/26_short_function.c3">https://github.com/tisnik/c3-examples/blob/master/c3-functions/26_short_function.c3</a></td></tr>
<tr><td>126</td><td>27_short_default_argument.c3</td><td>zkrácený způsob zápisu funkce s&nbsp;výchozí hodnotou parametru</td><td><a href="https://github.com/tisnik/c3-examples/blob/master/c3-functions/27_short_default_argument.c3">https://github.com/tisnik/c3-examples/blob/master/c3-functions/27_short_default_argument.c3</a></td></tr>
<tr><td>127</td><td>28_short_default_argument.c3</td><td>zkrácený způsob zápisu funkce s&nbsp;výchozí hodnotou parametrů</td><td><a href="https://github.com/tisnik/c3-examples/blob/master/c3-functions/28_short_default_argument.c3">https://github.com/tisnik/c3-examples/blob/master/c3-functions/28_short_default_argument.c3</a></td></tr>
<tr><td>128</td><td>29_short_named_argument.c3</td><td>zkrácený způsob zápisu funkce, při jejím volání jsou explicitně uvedena jména parametrů</td><td><a href="https://github.com/tisnik/c3-examples/blob/master/c3-functions/29_short_named_argument.c3">https://github.com/tisnik/c3-examples/blob/master/c3-functions/29_short_named_argument.c3</a></td></tr>
<tr><td>129</td><td>30_short_first.c3</td><td>zkrácený způsob zápisu funkce akceptující proměnný počet parametrů</td><td><a href="https://github.com/tisnik/c3-examples/blob/master/c3-functions/30_short_first.c3">https://github.com/tisnik/c3-examples/blob/master/c3-functions/30_short_first.c3</a></td></tr>
<tr><td>130</td><td>31_short_ternary.c3</td><td>zkrácený způsob zápisu funkce, která ve svém těle vyžaduje ternární operátor</td><td><a href="https://github.com/tisnik/c3-examples/blob/master/c3-functions/31_short_ternary.c3">https://github.com/tisnik/c3-examples/blob/master/c3-functions/31_short_ternary.c3</a></td></tr>
<tr><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td></tr>
<tr><td>131</td><td>32_anonymous.c3</td><td>příklad, v&nbsp;němž jsou definovány dvě <i>logicky</i> podobné funkce</td><td><a href="https://github.com/tisnik/c3-examples/blob/master/c3-functions/32_anonymous.c3">https://github.com/tisnik/c3-examples/blob/master/c3-functions/32_anonymous.c3</a></td></tr>
<tr><td>132</td><td>33_anonymous.c3</td><td>využití anonymních funkcí namísto dvojice <i>logicky</i> podobných funkcí</td><td><a href="https://github.com/tisnik/c3-examples/blob/master/c3-functions/33_anonymous.c3">https://github.com/tisnik/c3-examples/blob/master/c3-functions/33_anonymous.c3</a></td></tr>
<tr><td>133</td><td>34_anonymous.c3</td><td>definice a zavolání anonymní funkce provedené na jediném řádku zdrojového kódu</td><td><a href="https://github.com/tisnik/c3-examples/blob/master/c3-functions/34_anonymous.c3">https://github.com/tisnik/c3-examples/blob/master/c3-functions/34_anonymous.c3</a></td></tr>
<tr><td>134</td><td>35_anonymous.c3</td><td>pokus o definici uzávěru (<i>closure</i>)</td><td><a href="https://github.com/tisnik/c3-examples/blob/master/c3-functions/35_anonymous.c3">https://github.com/tisnik/c3-examples/blob/master/c3-functions/35_anonymous.c3</a></td></tr>
<tr><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td></tr>
<tr><td>135</td><td>36_function_pointers.c3</td><td>předání ukazatele na funkce</td><td><a href="https://github.com/tisnik/c3-examples/blob/master/c3-functions/36_function_pointers.c3">https://github.com/tisnik/c3-examples/blob/master/c3-functions/36_function_pointers.c3</a></td></tr>
<tr><td>136</td><td>37_function_pointers.c3</td><td>předání ukazatele na funkce (zkrácený zápis funkce)</td><td><a href="https://github.com/tisnik/c3-examples/blob/master/c3-functions/37_function_pointers.c3">https://github.com/tisnik/c3-examples/blob/master/c3-functions/37_function_pointers.c3</a></td></tr>
<tr><td>137</td><td>38_return_function.c3</td><td>funkce vracející jinou funkci</td><td><a href="https://github.com/tisnik/c3-examples/blob/master/c3-functions/38_return_function.c3">https://github.com/tisnik/c3-examples/blob/master/c3-functions/38_return_function.c3</a></td></tr>
<tr><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td></tr>
<tr><td>138</td><td>39_call_c_function.c3</td><td>volání standardní céčkové funkce <strong>puts</strong></td><td><a href="https://github.com/tisnik/c3-examples/blob/master/c3-functions/39_call_c_function.c3">https://github.com/tisnik/c3-examples/blob/master/c3-functions/39_call_c_function.c3</a></td></tr>
<tr><td>139</td><td>40_call_c_function.c3</td><td>volání nativní céčkové funkce <strong>add</strong></td><td><a href="https://github.com/tisnik/c3-examples/blob/master/c3-functions/40_call_c_function.c3">https://github.com/tisnik/c3-examples/blob/master/c3-functions/40_call_c_function.c3</a></td></tr>
<tr><td>140</td><td>41_call_c_function.c3</td><td>volání nativní céčkové funkce <strong>multiply</strong> s&nbsp;korektními datovými typy</td><td><a href="https://github.com/tisnik/c3-examples/blob/master/c3-functions/41_call_c_function.c3">https://github.com/tisnik/c3-examples/blob/master/c3-functions/41_call_c_function.c3</a></td></tr>
<tr><td>141</td><td>42_call_c_function.c3</td><td>volání nativní céčkové funkce akceptující pole (první způsob)</td><td><a href="https://github.com/tisnik/c3-examples/blob/master/c3-functions/42_call_c_function.c3">https://github.com/tisnik/c3-examples/blob/master/c3-functions/42_call_c_function.c3</a></td></tr>
<tr><td>142</td><td>43_call_c_function.c3</td><td>volání nativní céčkové funkce akceptující pole (druhý způsob)</td><td><a href="https://github.com/tisnik/c3-examples/blob/master/c3-functions/43_call_c_function.c3">https://github.com/tisnik/c3-examples/blob/master/c3-functions/43_call_c_function.c3</a></td></tr>
<tr><td>141</td><td>42_call_c_function.c3</td><td>volání nativní céčkové funkce akceptující pole (první způsob)</td><td><a href="https://github.com/tisnik/c3-examples/blob/master/c3-functions/42_call_c_function.c3">https://github.com/tisnik/c3-examples/blob/master/c3-functions/42_call_c_function.c3</a></td></tr>
<tr><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td></tr>
<tr><td>143</td><td>44_method.c3</td><td>zavolání metody (první způsob)</td><td><a href="https://github.com/tisnik/c3-examples/blob/master/c3-functions/44_method.c3">https://github.com/tisnik/c3-examples/blob/master/c3-functions/44_method.c3</a></td></tr>
<tr><td>144</td><td>45_method.c3</td><td>zavolání metody (druhý způsob)</td><td><a href="https://github.com/tisnik/c3-examples/blob/master/c3-functions/45_method.c3">https://github.com/tisnik/c3-examples/blob/master/c3-functions/45_method.c3</a></td></tr>
</table>

<p>Příklady z&nbsp;článku s&nbsp;popisem makrosystému jazyka C3:</p>

<table>
<tr><th> #</th><th>Příklad</th><th>Stručný popis</th><th>Adresa</th></tr>
<tr><td>145</td><td>01_add_macro.c3</td><td>jednoduché makro, které může být expandováno v&nbsp;rámci výrazu</td><td><a href="https://github.com/tisnik/c3-examples/blob/master/c3-macros/01_add_macro.c3">https://github.com/tisnik/c3-examples/blob/master/c3-macros/01_add_macro.c3</a></td></tr>
<tr><td>146</td><td>02_add_macro.c3</td><td>makro je generické, lze použít s&nbsp;hodnotami různých typů</td><td><a href="https://github.com/tisnik/c3-examples/blob/master/c3-macros/02_add_macro.c3">https://github.com/tisnik/c3-examples/blob/master/c3-macros/02_add_macro.c3</a></td></tr>
<tr><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td></tr>
<tr><td>147</td><td>03_macro_expansion_1.c</td><td>expanze makro provedená preprocesorem jazyka C (parametry nejsou uzávorkovány)</td><td><a href="https://github.com/tisnik/c3-examples/blob/master/c3-macros/03_macro_expansion_1.c">https://github.com/tisnik/c3-examples/blob/master/c3-macros/03_macro_expansion_1.c</a></td></tr>
<tr><td>148</td><td>03_macro_expansion_2.c</td><td>expanze makro provedená preprocesorem jazyka C (parametry jsou uzávorkovány)</td><td><a href="https://github.com/tisnik/c3-examples/blob/master/c3-macros/03_macro_expansion_2.c">https://github.com/tisnik/c3-examples/blob/master/c3-macros/03_macro_expansion_2.c</a></td></tr>
<tr><td>149</td><td>03_macro_expansion.c3</td><td>řešení v&nbsp;jazyku C3 bez nutnosti uzávorkování parametrů makra</td><td><a href="https://github.com/tisnik/c3-examples/blob/master/c3-macros/03_macro_expansion.c3">https://github.com/tisnik/c3-examples/blob/master/c3-macros/03_macro_expansion.c3</a></td></tr>
<tr><td>150</td><td>04_macro_expansion_1.c</td><td>expanze makro provedená preprocesorem jazyka C (tělo makra není v&nbsp;závorkách)</td><td><a href="https://github.com/tisnik/c3-examples/blob/master/c3-macros/04_macro_expansion_1.c">https://github.com/tisnik/c3-examples/blob/master/c3-macros/04_macro_expansion_1.c</a></td></tr>
<tr><td>151</td><td>04_macro_expansion_2.c</td><td>expanze makro provedená preprocesorem jazyka C (tělo makra je v&nbsp;závorkách)</td><td><a href="https://github.com/tisnik/c3-examples/blob/master/c3-macros/04_macro_expansion_2.c">https://github.com/tisnik/c3-examples/blob/master/c3-macros/04_macro_expansion_2.c</a></td></tr>
<tr><td>152</td><td>04_macro_expansion.c3</td><td>řešení v&nbsp;jazyku C3 bez nutnosti zápisu těla makra do závorek</td><td><a href="https://github.com/tisnik/c3-examples/blob/master/c3-macros/04_macro_expansion.c3">https://github.com/tisnik/c3-examples/blob/master/c3-macros/04_macro_expansion.c3</a></td></tr>
<tr><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td></tr>
<tr><td>153</td><td>05_typed_macro.c3</td><td>makro s&nbsp;definicí typů parametrů</td><td><a href="https://github.com/tisnik/c3-examples/blob/master/c3-macros/05_typed_macro.c3">https://github.com/tisnik/c3-examples/blob/master/c3-macros/05_typed_macro.c3</a></td></tr>
<tr><td>154</td><td>06_typed_macro.c3</td><td>makro s&nbsp;definicí typů parametrů: příklad jeho expanze</td><td><a href="https://github.com/tisnik/c3-examples/blob/master/c3-macros/06_typed_macro.c3">https://github.com/tisnik/c3-examples/blob/master/c3-macros/06_typed_macro.c3</a></td></tr>
<tr><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td></tr>
<tr><td>155</td><td>07_compile_time_1.c3</td><td>expanze makra v&nbsp;čase překladu: nefunkční varianta s&nbsp;konstantami</td><td><a href="https://github.com/tisnik/c3-examples/blob/master/c3-macros/07_compile_time_1.c3">https://github.com/tisnik/c3-examples/blob/master/c3-macros/07_compile_time_1.c3</a></td></tr>
<tr><td>156</td><td>08_compile_time_2.c3</td><td>expanze makra v&nbsp;čase překladu: funkční varianta s&nbsp;konstantami</td><td><a href="https://github.com/tisnik/c3-examples/blob/master/c3-macros/08_compile_time_2.c3">https://github.com/tisnik/c3-examples/blob/master/c3-macros/08_compile_time_2.c3</a></td></tr>
<tr><td>157</td><td>09_compile_time_3.c3</td><td>expanze makra v&nbsp;čase překladu: nefunkční varianta s&nbsp;proměnnými</td><td><a href="https://github.com/tisnik/c3-examples/blob/master/c3-macros/09_compile_time_3.c3">https://github.com/tisnik/c3-examples/blob/master/c3-macros/09_compile_time_3.c3</a></td></tr>
<tr><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td></tr>
<tr><td>158</td><td>10_swap_macro_1.c3</td><td>realizace makra pro prohození obsahu dvou proměnných: nefunkční varianta</td><td><a href="https://github.com/tisnik/c3-examples/blob/master/c3-macros/10_swap_macro_1.c3">https://github.com/tisnik/c3-examples/blob/master/c3-macros/10_swap_macro_1.c3</a></td></tr>
<tr><td>159</td><td>11_swap_macro_2.c3</td><td>realizace makra pro prohození obsahu dvou proměnných: funkční varianta</td><td><a href="https://github.com/tisnik/c3-examples/blob/master/c3-macros/11_swap_macro_2.c3">https://github.com/tisnik/c3-examples/blob/master/c3-macros/11_swap_macro_2.c3</a></td></tr>
<tr><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td></tr>
<tr><td>160</td><td>12_varargs.c3</td><td>makro s&nbsp;proměnným počtem argumentů</td><td><a href="https://github.com/tisnik/c3-examples/blob/master/c3-macros/12_varargs.c3">https://github.com/tisnik/c3-examples/blob/master/c3-macros/12_varargs.c3</a></td></tr>
</table>

<p>Demonstrační příklady uvedené v&nbsp;minulém článku s&nbsp;popisem nedefinovaného chování v&nbsp;C3:</p>

<table>
<tr><th> #</th><th>Příklad</th><th>Stručný popis</th><th>Adresa</th></tr>
<tr><td>161</td><td>01_div_by_zero.c3</td><td>nedefinované chování při dělení nulou</td><td><a href="https://github.com/tisnik/c3-examples/blob/master/c3-undefined-behaviour/01_div_by_zero.c3">https://github.com/tisnik/c3-examples/blob/master/c3-undefined-behaviour/01_div_by_zero.c3</a></td></tr>
<tr><td>162</td><td>02_mod_by_zero.c3</td><td>nedefinované chování při výpočtu zbytku po dělení nulou</td><td><a href="https://github.com/tisnik/c3-examples/blob/master/c3-undefined-behaviour/02_mod_by_zero.c3">https://github.com/tisnik/c3-examples/blob/master/c3-undefined-behaviour/02_mod_by_zero.c3</a></td></tr>
<tr><td>163</td><td>03_min_int_1.c3</td><td>změna znaménka nejmenší celočíselné hodnoty (daného typu) se znaménkem</td><td><a href="https://github.com/tisnik/c3-examples/blob/master/c3-undefined-behaviour/03_min_int_1.c3">https://github.com/tisnik/c3-examples/blob/master/c3-undefined-behaviour/03_min_int_1.c3</a></td></tr>
<tr><td>164</td><td>04_min_int_2.c3</td><td>změna znaménka nejmenší celočíselné hodnoty operací součinu</td><td><a href="https://github.com/tisnik/c3-examples/blob/master/c3-undefined-behaviour/04_min_int_2.c3">https://github.com/tisnik/c3-examples/blob/master/c3-undefined-behaviour/04_min_int_2.c3</a></td></tr>
<tr><td>165</td><td>05_undefined_value.c3</td><td>nedefinované hodnoty lokálních konstant v&nbsp;různých režimech překladu</td><td><a href="https://github.com/tisnik/c3-examples/blob/master/c3-undefined-behaviour/05_undefined_value.c3">https://github.com/tisnik/c3-examples/blob/master/c3-undefined-behaviour/05_undefined_value.c3</a></td></tr>
<tr><td>166</td><td>06_out_of_bounds_1.c3</td><td>přístup k&nbsp;prvku pole s&nbsp;indexem, který přesahuje meze pole</td><td><a href="https://github.com/tisnik/c3-examples/blob/master/c3-undefined-behaviour/06_out_of_bounds_1.c3">https://github.com/tisnik/c3-examples/blob/master/c3-undefined-behaviour/06_out_of_bounds_1.c3</a></td></tr>
<tr><td>167</td><td>07_out_of_bounds_2.c3</td><td>přístup k&nbsp;prvku pole s&nbsp;indexem, který přesahuje meze pole</td><td><a href="https://github.com/tisnik/c3-examples/blob/master/c3-undefined-behaviour/07_out_of_bounds_2.c3">https://github.com/tisnik/c3-examples/blob/master/c3-undefined-behaviour/07_out_of_bounds_2.c3</a></td></tr>
<tr><td>168</td><td>08_null_pointer.c3</td><td>přístup do paměti přes nulový ukazatel</td><td><a href="https://github.com/tisnik/c3-examples/blob/master/c3-undefined-behaviour/08_null_pointer.c3">https://github.com/tisnik/c3-examples/blob/master/c3-undefined-behaviour/08_null_pointer.c3</a></td></tr>
<tr><td>169</td><td>09_contract.c3</td><td>nedodržení specifikovaného kontraktu: podmínka pro vstupní parametry</td><td><a href="https://github.com/tisnik/c3-examples/blob/master/c3-undefined-behaviour/09_contract.c3">https://github.com/tisnik/c3-examples/blob/master/c3-undefined-behaviour/09_contract.c3</a></td></tr>
<tr><td>170</td><td>10_contract.c3</td><td>nedodržení specifikovaného kontraktu: podmínka pro výslednou hodnotu</td><td><a href="https://github.com/tisnik/c3-examples/blob/master/c3-undefined-behaviour/10_contract.c3">https://github.com/tisnik/c3-examples/blob/master/c3-undefined-behaviour/10_contract.c3</a></td></tr>
<tr><td>171</td><td>11_out_of_bounds_slice.c3</td><td>překročení meze u řezů (<i>slice</i>)</td><td><a href="https://github.com/tisnik/c3-examples/blob/master/c3-undefined-behaviour/11_out_of_bounds_slice.c3">https://github.com/tisnik/c3-examples/blob/master/c3-undefined-behaviour/11_out_of_bounds_slice.c3</a></td></tr>
<tr><td>172</td><td>12_local_variable_pointer.c</td><td>přístup k&nbsp;lokální proměnné mimo oblast její platnosti (příklad v&nbsp;C)</td><td><a href="https://github.com/tisnik/c3-examples/blob/master/c3-undefined-behaviour/12_local_variable_pointer.c">https://github.com/tisnik/c3-examples/blob/master/c3-undefined-behaviour/12_local_variable_pointer.c</a></td></tr>
<tr><td>173</td><td>12_local_variable_pointer.c3</td><td>přístup k&nbsp;lokální proměnné mimo oblast její platnosti (příklad v&nbsp;C3)</td><td><a href="https://github.com/tisnik/c3-examples/blob/master/c3-undefined-behaviour/12_local_variable_pointer.c3">https://github.com/tisnik/c3-examples/blob/master/c3-undefined-behaviour/12_local_variable_pointer.c3</a></td></tr>
<tr><td>174</td><td>13_div_by_minus_one.c3</td><td>změna znaménka nejmenší celočíselné hodnoty operací podílu</td><td><a href="https://github.com/tisnik/c3-examples/blob/master/c3-undefined-behaviour/13_div_by_minus_one.c3">https://github.com/tisnik/c3-examples/blob/master/c3-undefined-behaviour/13_div_by_minus_one.c3</a></td></tr>
<tr><td>175</td><td>14_signed_overflow.c3</td><td>přetečení celočíselné hodnoty se znaménkem</td><td><a href="https://github.com/tisnik/c3-examples/blob/master/c3-undefined-behaviour/14_signed_overflow.c3">https://github.com/tisnik/c3-examples/blob/master/c3-undefined-behaviour/14_signed_overflow.c3</a></td></tr>
<tr><td>176</td><td>15_negative_shift.c3</td><td>bitový posun o zápornou hodnotu</td><td><a href="https://github.com/tisnik/c3-examples/blob/master/c3-undefined-behaviour/15_negative_shift.c3">https://github.com/tisnik/c3-examples/blob/master/c3-undefined-behaviour/15_negative_shift.c3</a></td></tr>
<tr><td>177</td><td>16_large_shift.c3</td><td>bitový posun o hodnotu přesahující bitovou šířku operandu</td><td><a href="https://github.com/tisnik/c3-examples/blob/master/c3-undefined-behaviour/16_large_shift.c3">https://github.com/tisnik/c3-examples/blob/master/c3-undefined-behaviour/16_large_shift.c3</a></td></tr>
</table>

<table>
<tr><th> #</th><th>Příklad</th><th>Stručný popis</th><th>Adresa</th></tr>
<tr><td>178</td><td>add_operator_1.c3</td><td>metoda <strong>add</strong> definovaná pro dvojici vektorů</td><td><a href="https://github.com/tisnik/c3-examples/blob/master/c3-operators-overloading/add_operator_1.c3">https://github.com/tisnik/c3-examples/blob/master/c3-operators-overloading/add_operator_1.c3</a></td></tr>
<tr><td>179</td><td>add_operator_2.c3</td><td>odlišný způsob volání metody <strong>add</strong> pro provedení součtu dvou vektorů</td><td><a href="https://github.com/tisnik/c3-examples/blob/master/c3-operators-overloading/add_operator_2.c3">https://github.com/tisnik/c3-examples/blob/master/c3-operators-overloading/add_operator_2.c3</a></td></tr>
<tr><td>180</td><td>add_operator_3.c3</td><td>přetížení operátoru + pro součet dvou vektorů</td><td><a href="https://github.com/tisnik/c3-examples/blob/master/c3-operators-overloading/add_operator_3.c3">https://github.com/tisnik/c3-examples/blob/master/c3-operators-overloading/add_operator_3.c3</a></td></tr>
<tr><td>181</td><td>add_operator_4.c3</td><td>idiomatický způsob zápisu definice přetíženého operátoru +</td><td><a href="https://github.com/tisnik/c3-examples/blob/master/c3-operators-overloading/add_operator_4.c3">https://github.com/tisnik/c3-examples/blob/master/c3-operators-overloading/add_operator_4.c3</a></td></tr>
<tr><td>182</td><td>add_operator_5.c3</td><td>úprava předchozího příkladu: předání vektoru odkazem, nikoli hodnotou</td><td><a href="https://github.com/tisnik/c3-examples/blob/master/c3-operators-overloading/add_operator_5.c3">https://github.com/tisnik/c3-examples/blob/master/c3-operators-overloading/add_operator_5.c3</a></td></tr>
<tr><td>183</td><td>add_operator_6.c3</td><td>současná definice přičtení skalární hodnoty i součtu dvou vektorů</td><td><a href="https://github.com/tisnik/c3-examples/blob/master/c3-operators-overloading/add_operator_6.c3">https://github.com/tisnik/c3-examples/blob/master/c3-operators-overloading/add_operator_6.c3</a></td></tr>
<tr><td>184</td><td>add_operator_7.c3</td><td>otestování komutativity operace součtu</td><td><a href="https://github.com/tisnik/c3-examples/blob/master/c3-operators-overloading/add_operator_7.c3">https://github.com/tisnik/c3-examples/blob/master/c3-operators-overloading/add_operator_7.c3</a></td></tr>
<tr><td>185</td><td>add_operator_8.c3</td><td>přetížení operátoru součtu pro prohozené operandy</td><td><a href="https://github.com/tisnik/c3-examples/blob/master/c3-operators-overloading/add_operator_8.c3">https://github.com/tisnik/c3-examples/blob/master/c3-operators-overloading/add_operator_8.c3</a></td></tr>
<tr><td>186</td><td>add_operator_9.c3</td><td>symetrická operace součtu</td><td><a href="https://github.com/tisnik/c3-examples/blob/master/c3-operators-overloading/add_operator_9.c3">https://github.com/tisnik/c3-examples/blob/master/c3-operators-overloading/add_operator_9.c3</a></td></tr>
<tr><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td></tr>
<tr><td>187</td><td>dot_product_1.c3</td><td>skalární součin volaný přetíženým operátorem *</td><td><a href="https://github.com/tisnik/c3-examples/blob/master/c3-operators-overloading/dot_product_1.c3">https://github.com/tisnik/c3-examples/blob/master/c3-operators-overloading/dot_product_1.c3</a></td></tr>
<tr><td>188</td><td>dot_product_2.c3</td><td>úprava předchozího příkladu: předání vektoru odkazem, nikoli hodnotou</td><td><a href="https://github.com/tisnik/c3-examples/blob/master/c3-operators-overloading/dot_product_2.c3">https://github.com/tisnik/c3-examples/blob/master/c3-operators-overloading/dot_product_2.c3</a></td></tr>
<tr><td>189</td><td>dot_product_3.c3</td><td>skalární součin vs. násobení vektoru skalární konstantou</td><td><a href="https://github.com/tisnik/c3-examples/blob/master/c3-operators-overloading/dot_product_3.c3">https://github.com/tisnik/c3-examples/blob/master/c3-operators-overloading/dot_product_3.c3</a></td></tr>
<tr><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td></tr>
<tr><td>190</td><td>equality_operator.c3</td><td>přetížení operátoru rovnosti</td><td><a href="https://github.com/tisnik/c3-examples/blob/master/c3-operators-overloading/equality_operator.c3">https://github.com/tisnik/c3-examples/blob/master/c3-operators-overloading/equality_operator.c3</a></td></tr>
<tr><td>191</td><td>unary_minus.c3</td><td>přetížení operátoru pro unární - (otočení znaménka)</td><td><a href="https://github.com/tisnik/c3-examples/blob/master/c3-operators-overloading/unary_minus.c3">https://github.com/tisnik/c3-examples/blob/master/c3-operators-overloading/unary_minus.c3</a></td></tr>
<tr><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td></tr>
<tr><td>192</td><td>index_operator_1.c3</td><td>přetížení operátoru indexování pro celočíselné indexy</td><td><a href="https://github.com/tisnik/c3-examples/blob/master/c3-operators-overloading/index_operator_1.c3">https://github.com/tisnik/c3-examples/blob/master/c3-operators-overloading/index_operator_1.c3</a></td></tr>
<tr><td>193</td><td>index_operator_2.c3</td><td>úprava předchozího příkladu: předání vektoru odkazem, nikoli hodnotou</td><td><a href="https://github.com/tisnik/c3-examples/blob/master/c3-operators-overloading/index_operator_2.c3">https://github.com/tisnik/c3-examples/blob/master/c3-operators-overloading/index_operator_2.c3</a></td></tr>
<tr><td>194</td><td>index_operator_3.c3</td><td>přetížení operátoru indexování pro klíče, nikoli celočíselné indexy</td><td><a href="https://github.com/tisnik/c3-examples/blob/master/c3-operators-overloading/index_operator_3.c3">https://github.com/tisnik/c3-examples/blob/master/c3-operators-overloading/index_operator_3.c3</a></td></tr>
<tr><td>195</td><td>index_set_operator.c3</td><td>přetížení operátoru indexování pro zápis do objektu</td><td><a href="https://github.com/tisnik/c3-examples/blob/master/c3-operators-overloading/index_set_operator.c3">https://github.com/tisnik/c3-examples/blob/master/c3-operators-overloading/index_set_operator.c3</a></td></tr>
<tr><td>196</td><td>len_operator.c3</td><td>přetížení speciálního operátoru <strong>len</strong></td><td><a href="https://github.com/tisnik/c3-examples/blob/master/c3-operators-overloading/len_operator.c3">https://github.com/tisnik/c3-examples/blob/master/c3-operators-overloading/len_operator.c3</a></td></tr>
</table>



<p><a name="k20"></a></p>
<h2 id="k20">20. Odkazy na Internetu</h2>

<ol>

<li>Programovací jazyk C3: evoluce, nikoli revoluce<br />
<a href="https://www.root.cz/clanky/programovaci-jazyk-c3-evoluce-nikoli-revoluce/">https://www.root.cz/clanky/programovaci-jazyk-c3-evoluce-nikoli-revoluce/</a>
</li>

<li>Programovací jazyk C3: datové typy pro moderní architektury<br />
<a href="https://www.root.cz/clanky/programovaci-jazyk-c3-datove-typy-pro-moderni-architektury/">https://www.root.cz/clanky/programovaci-jazyk-c3-datove-typy-pro-moderni-architektury/</a>
</li>

<li>Programovací jazyk C3: složené datové typy a kontejnery<br />
<a href="https://www.root.cz/clanky/programovaci-jazyk-c3-slozene-datove-typy-a-kontejnery/">https://www.root.cz/clanky/programovaci-jazyk-c3-slozene-datove-typy-a-kontejnery/</a>
</li>

<li>The C3 Programming Language<br />
<a href="https://c3-lang.org/">https://c3-lang.org/</a>
</li>

<li>C3 For C Programmers<br />
<a href="https://c3-lang.org/language-overview/primer/">https://c3-lang.org/language-overview/primer/</a>
</li>

<li>C3 is a C-like language trying to be an incremental improvement over C rather than a whole new language<br />
<a href="https://www.reddit.com/r/ProgrammingLanguages/comments/oohij6/c3_is_a_clike_language_trying_to_be_an/">https://www.reddit.com/r/ProgrammingLanguages/comments/oohij6/c3_is_a_clike_language_trying_to_be_an/</a>
</li>

<li>Tiobe index<br />
<a href="https://www.tiobe.com/tiobe-index/">https://www.tiobe.com/tiobe-index/</a>
</li>

<li>PYPL PopularitY of Programming Language<br />
<a href="https://pypl.github.io/PYPL.html">https://pypl.github.io/PYPL.html</a>
</li>

<li>C3 Tutorial<br />
<a href="https://learn-c3.org/">https://learn-c3.org/</a>
</li>

<li>History of programming languages<br />
<a href="https://devskiller.com/history-of-programming-languages/">https://devskiller.com/history-of-programming-languages/</a>
</li>

<li>History of programming languages (Wikipedia)<br />
<a href="https://en.wikipedia.org/wiki/History_of_programming_languages">https://en.wikipedia.org/wiki/History_of_programming_languages</a>
</li>

<li>D language<br />
<a href="https://dlang.org/">https://dlang.org/</a>
</li>

<li>Zig programming language<br />
<a href="https://ziglang.org/">https://ziglang.org/</a>
</li>

<li>V language<br />
<a href="https://vlang.io/">https://vlang.io/</a>
</li>

<li>D programming language<br />
<a href="https://en.wikipedia.org/wiki/D_(programming_language)">https://en.wikipedia.org/wiki/D_(programming_language)</a>
</li>

<li>Zig programming language (Wikipedia)<br />
<a href="https://en.wikipedia.org/wiki/Zig_(programming_language)">https://en.wikipedia.org/wiki/Zig_(programming_language)</a>
</li>

<li>V programming language (Wikipedia)<br />
<a href="https://en.wikipedia.org/wiki/V_(programming_language)">https://en.wikipedia.org/wiki/V_(programming_language)</a>
</li>

<li>Syntax highlighting for C3's programming language<br />
<a href="https://github.com/Airbus5717/c3.vim">https://github.com/Airbus5717/c3.vim</a>
</li>

<li>Go factorial<br />
<a href="https://gist.github.com/esimov/9622710">https://gist.github.com/esimov/9622710</a>
</li>

<li>Generational list of programming languages<br />
<a href="https://en.wikipedia.org/wiki/Generational_list_of_programming_languages">https://en.wikipedia.org/wiki/Generational_list_of_programming_languages</a>
</li>

<li>The Language Tree: Almost Every Programming Language Ever Made<br />
<a href="https://github.com/Phileosopher/langmap">https://github.com/Phileosopher/langmap</a>
</li>

<li>List of C-family programming languages<br />
<a href="https://en.wikipedia.org/wiki/List_of_C-family_programming_languages">https://en.wikipedia.org/wiki/List_of_C-family_programming_languages</a>
</li>

<li>Compatibility of C and C++<br />
<a href="https://en.wikipedia.org/wiki/Compatibility_of_C_and_C%2B%2B">https://en.wikipedia.org/wiki/Compatibility_of_C_and_C%2B%2B</a>
</li>

<li>C++23: compatibility with C<br />
<a href="https://www.sandordargo.com/blog/2023/08/23/cpp23-c-compatibility">https://www.sandordargo.com/blog/2023/08/23/cpp23-c-compatibility</a>
</li>

<li>Can C++ Run C Code? Understanding Language Compatibility<br />
<a href="https://www.codewithc.com/can-c-run-c-code-understanding-language-compatibility/">https://www.codewithc.com/can-c-run-c-code-understanding-language-compatibility/</a>
</li>

<li>C3: Comparisons With Other Languages<br />
<a href="https://c3-lang.org/faq/compare-languages/">https://c3-lang.org/faq/compare-languages/</a>
</li>

<li>C3 Programming Language Gains Traction as Modern C Alternative<br />
<a href="https://biggo.com/news/202504040125_C3_Programming_Language_Alternative_to_C">https://biggo.com/news/202504040125_C3_Programming_Language_Alternative_to_C</a>
</li>

<li>The case against a C alternative<br />
<a href="https://c3.handmade.network/blog/p/8486-the_case_against_a_c_alternative">https://c3.handmade.network/blog/p/8486-the_case_against_a_c_alternative</a>
</li>

<li>C (programming language) Alternatives<br />
<a href="https://alternativeto.net/software/c-programming-language-/">https://alternativeto.net/software/c-programming-language-/</a>
</li>

<li>Seriál Programovací jazyk Go<br />
<a href="https://www.root.cz/serialy/programovaci-jazyk-go/">https://www.root.cz/serialy/programovaci-jazyk-go/</a>
</li>

<li>Is C3 the Underdog That Will Overtake Zig and Odin?<br />
<a href="https://bitshifters.cc/2025/05/22/c3-c-tradition.html">https://bitshifters.cc/2025/05/22/c3-c-tradition.html</a>
</li>

<li>"Hello, World!" program<br />
<a href="https://en.wikipedia.org/wiki/%22Hello%2C_World!%22_program">https://en.wikipedia.org/wiki/%22Hello%2C_World!%22_program</a>
</li>

<li>The C Programming Language<br />
<a href="https://en.wikipedia.org/wiki/The_C_Programming_Language">https://en.wikipedia.org/wiki/The_C_Programming_Language</a>
</li>

<li>Kontejner (abstraktní datový typ)<br />
<a href="https://cs.wikipedia.org/wiki/Kontejner_(abstraktn%C3%AD_datov%C3%BD_typ)">https://cs.wikipedia.org/wiki/Kontejner_(abstraktn%C3%AD_datov%C3%BD_typ)</a>
</li>

<li>Are arrays not considered containers because they are not based off of a class?<br />
<a href="https://stackoverflow.com/questions/37710975/are-arrays-not-considered-containers-because-they-are-not-based-off-of-a-class">https://stackoverflow.com/questions/37710975/are-arrays-not-considered-containers-because-they-are-not-based-off-of-a-class</a>
</li>

<li>Array declaration (C, C++)<br />
<a href="https://en.cppreference.com/w/cpp/language/array.html">https://en.cppreference.com/w/cpp/language/array.html</a>
</li>

<li>Understanding the Apple ‘goto fail;’ vulnerability<br />
<a href="https://www.blackduck.com/blog/understanding-apple-goto-fail-vulnerability-2.html">https://www.blackduck.com/blog/understanding-apple-goto-fail-vulnerability-2.html</a>
</li>

<li>Branch (computer science)<br />
<a href="https://en.wikipedia.org/wiki/Branch_(computer_science)">https://en.wikipedia.org/wiki/Branch_(computer_science)</a>
</li>

<li>Conditional (computer programming)<br />
<a href="https://en.wikipedia.org/wiki/Conditional_(computer_programming)">https://en.wikipedia.org/wiki/Conditional_(computer_programming)</a>
</li>

<li>Dangling else<br />
<a href="https://en.wikipedia.org/wiki/Dangling_else">https://en.wikipedia.org/wiki/Dangling_else</a>
</li>

<li>Switch statement<br />
<a href="https://en.wikipedia.org/wiki/Switch_statement">https://en.wikipedia.org/wiki/Switch_statement</a>
</li>

<li>Compiler correctness<br />
<a href="https://en.wikipedia.org/wiki/Compiler_correctness">https://en.wikipedia.org/wiki/Compiler_correctness</a>
</li>

<li>Anonymous function<br />
<a href="https://en.wikipedia.org/wiki/Anonymous_function">https://en.wikipedia.org/wiki/Anonymous_function</a>
</li>

<li>Closure (computer programming)<br />
<a href="https://en.wikipedia.org/wiki/Closure_(computer_programming)">https://en.wikipedia.org/wiki/Closure_(computer_programming)</a>
</li>

<li>How to implement closures in C<br />
<a href="https://hokstad.com/how-to-implement-closures">https://hokstad.com/how-to-implement-closures</a>
</li>

<li>An Overview of Macros in Rust<br />
<a href="http://words.steveklabnik.com/an-overview-of-macros-in-rust">http://words.steveklabnik.com/an-overview-of-macros-in-rust</a>
</li>

<li>A Practical Intro to Macros in Rust 1.0<br />
<a href="https://danielkeep.github.io/practical-intro-to-macros.html">https://danielkeep.github.io/practical-intro-to-macros.html</a>
</li>

<li>The Rust Programming Language: macros<br />
<a href="https://doc.rust-lang.org/beta/book/macros.html">https://doc.rust-lang.org/beta/book/macros.html</a>
</li>

<li>Rust by example: 15 macro_rules!<br />
<a href="http://rustbyexample.com/macros.html">http://rustbyexample.com/macros.html</a>
</li>

<li>Undefined behavior<br />
<a href="https://en.wikipedia.org/wiki/Undefined_behavior">https://en.wikipedia.org/wiki/Undefined_behavior</a>
</li>

<li>Undefined Behavior in C and C++<br />
<a href="https://www.geeksforgeeks.org/cpp/undefined-behavior-c-cpp/">https://www.geeksforgeeks.org/cpp/undefined-behavior-c-cpp/</a>
</li>

<li>The Rust reference: Behavior considered undefined<br />
<a href="https://doc.rust-lang.org/reference/behavior-considered-undefined.html#behavior-considered-undefined">https://doc.rust-lang.org/reference/behavior-considered-undefined.html#behavior-considered-undefined</a>
</li>

<li>Why would a language have a concept of undefined behavior instead of raising an error?<br />
<a href="https://langdev.stackexchange.com/questions/481/why-would-a-language-have-a-concept-of-undefined-behavior-instead-of-raising-an">https://langdev.stackexchange.com/questions/481/why-would-a-language-have-a-concept-of-undefined-behavior-instead-of-raising-an</a>
</li>

<li>Undefined behavior<br />
<a href="https://riptutorial.com/c/topic/364/undefined-behavior">https://riptutorial.com/c/topic/364/undefined-behavior</a>
</li>

<li>C3: Undefined Behaviour<br />
<a href="https://c3-lang.org/language-rules/undefined-behaviour/">https://c3-lang.org/language-rules/undefined-behaviour/</a>
</li>

<li>Undefined behavior in C and C++<br />
<a href="https://russellw.github.io/undefined-behavior">https://russellw.github.io/undefined-behavior</a>
</li>

<li>C3 goes game and maths friendly with operator overloading<br />
<a href="https://c3.handmade.network/blog/p/9019-c3_goes_game_and_maths_friendly_with_operator_overloading">https://c3.handmade.network/blog/p/9019-c3_goes_game_and_maths_friendly_with_operator_overloading</a>
</li>

<li>Are operator overloadings in C++ more trouble than they're worth?<br />
<a href="https://stackoverflow.com/questions/707081/are-operator-overloadings-in-c-more-trouble-than-theyre-worth">https://stackoverflow.com/questions/707081/are-operator-overloadings-in-c-more-trouble-than-theyre-worth</a>
</li>

<li>Why is operator overloading sometimes considered a bad practice?<br />
<a href="https://www.reddit.com/r/ProgrammingLanguages/comments/19cl30z/why_is_operator_overloading_sometimes_considered/">https://www.reddit.com/r/ProgrammingLanguages/comments/19cl30z/why_is_operator_overloading_sometimes_considered/</a>
</li>

<li>I don't understand the arguments against operator overloading<br />
<a href="https://softwareengineering.stackexchange.com/questions/25154/i-dont-understand-the-arguments-against-operator-overloading">https://softwareengineering.stackexchange.com/questions/25154/i-dont-understand-the-arguments-against-operator-overloading</a>
</li>

</ol>



<p></p><p></p>
<p><small>Autor: <a href="https://github.com/tisnik/">Pavel Tišnovský</a> &nbsp; 2025</small></p>
</body>
</html>

