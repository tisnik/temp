<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
        "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html>
<head>
<title></title>
<meta name="Author" content="Pavel Tisnovsky" />
<meta name="Generator" content="vim" />
<meta http-equiv="content-type" content="text/html; charset=utf-8" />
<style type="text/css">
         body {color:#000000; background:#ffffff;}
         h1  {font-family: arial, helvetica, sans-serif; color:#ffffff; background-color:#c00000; text-align:center; padding-left:1em}
         h2  {font-family: arial, helvetica, sans-serif; color:#ffffff; background-color:#0000c0; padding-left:1em; text-align:left}
         h3  {font-family: arial, helvetica, sans-serif; color:#000000; background-color:#c0c0c0; padding-left:1em; text-align:left}
         h4  {font-family: arial, helvetica, sans-serif; color:#000000; background-color:#e0e0e0; padding-left:1em; text-align:left}
         a   {font-family: arial, helvetica, sans-serif;}
         li  {font-family: arial, helvetica, sans-serif; color:#000000; text-align:justify; width:450px;}
         ol  {font-family: arial, helvetica, sans-serif; color:#000000; text-align:justify; width:450px;}
         ul  {font-family: arial, helvetica, sans-serif; color:#000000; text-align:justify; width:450px;}
         p   {font-family: arial, helvetica, sans-serif; color:#000000; text-align:justify;}
         pre {background:#e0e0e0}
</style>
</head>

<body>

<h1></h1>

<h3>Pavel Tišnovský</h3>

<p></p>

<h1>Úvodník</h1>

<p></p>



<h2>Obsah</h2>

<p><a href="#k01">*** 1. </a></p>
<p><a href="#k02">*** 2. Podpora n-rozměrných polí v&nbsp;programovacích jazycích a knihovnách</a></p>
<p><a href="#k03">*** 3. Jenže ... co si vlastně představit pod jménem <strong>pole</strong>?</a></p>
<p><a href="#k04">*** 4. Rozdílný přístup k&nbsp;práci s&nbsp;poli v&nbsp;různých programovacích jazycích</a></p>
<p><a href="#k05">*** 5. Optimalizace operací s&nbsp;poli, paralelní výpočty a zpracování signálů</a></p>
<p><a href="#k06">*** 6. Příklady rozdílných přístupů programovacích jazyků při práci s&nbsp;poli</a></p>
<p><a href="#k07">*** 7. Vektory a matice v&nbsp;Dartmouth BASICu popř.&nbsp;v&nbsp;BBS BASICu</a></p>
<p><a href="#k08">*** 8. Pole v&nbsp;programovacím jazyce Julia</a></p>
<p><a href="#k09">*** 9. Vícerozměrná pole, sloupcové a řádkové vektory</a></p>
<p><a href="#k10">*** 10. Změna tvaru pole funkcí <strong>reshape</strong></a></p>
<p><a href="#k11">*** 11. Jeden z&nbsp;důsledků typového systému jazyka Julia a měnitelnosti polí</a></p>
<p><a href="#k12">*** 12. </a></p>
<p><a href="#k13">*** 13. Knihovna <strong>core.matrix</strong></a></p>
<p><a href="#k14">*** 14. Projekt Incanter</a></p>
<p><a href="#k15">*** 15. </a></p>
<p><a href="#k16">*** 16. Vektory v&nbsp;programovacím jazyku Kawa</a></p>
<p><a href="#k17">*** 17. N-rozměrná pole (ND-Array) v&nbsp;jazyku Kawa</a></p>
<p><a href="#k18">*** 18. </a></p>
<p><a href="#k19">*** 19. Shrnutí úvodního článku</a></p>
<p><a href="#k20">*** 20. Odkazy na Internetu</a></p>



<p><a name="k01"></a></p>
<h2 id="k01">1. </h2>

<p>Dnes se začneme zabývat jednou poměrně rozsáhlou a současně i poněkud specifickou oblastí v&nbsp;IT. Tou je zpracování vektorů, matic a taktéž vícerozměrných polí &ndash; obecně se v&nbsp;tomto kontextu mluví o n-rozměrných polích. S&nbsp;těmito užitečnými datovými strukturami se můžeme setkat v&nbsp;různých (mnohdy zdánlivě velmi vzdálených) disciplínách, například ve finančnictví, pojišťovnictví, statistice, zpracování numerických dat, simulacích, zpracování 1D a 2D signálů atd. Zapomenout ovšem nesmíme ani na strojové učení (<i>machine learning</i>) a umělou inteligencí (<i>artifical intelligence</i>), protože například datové struktury pro uložení neuronových sítí (zejména konvolučních sítí) je realizováno n-rozměrnými poli. Současně se jedná i o velmi zajímavou oblast, neboť právě kvůli nutnosti co nejrychlejší práce s&nbsp;velkými maticemi byly vytvořeny speciální výpočetní bloky v&nbsp;některých superpočítačích (příkladem mohou být superpočítače <i>Cray</i>) a došlo tak k&nbsp;důležitému podnětu pro další rozvoj výpočetní techniky (ten nepřímo vedl k&nbsp;vývoji moderních GPU).</p>

<p>Současné knihovny pro práci s&nbsp;n-rozměrnými poli dokážou v&nbsp;případě potřeby využít jak některé rozšíření instrukčních sad (SIMD instrukce typu SSE neboli Streaming SIMD Extensions, původně též MMX či 3DNow!), tak i programovatelné grafické akcelerátory (GPU). SIMD instrukcemi jsme se již na stránkách Roota zabývali v&nbsp;samostatných článcích, zejména pak v&nbsp;této trojici článků:</p>

<ol>

<li>SIMD instrukce využívané v moderních mikroprocesorech řady x86<br />
<a href="https://www.root.cz/clanky/simd-instrukce-vyuzivane-v-modernich-mikroprocesorech-rady-x86/">https://www.root.cz/clanky/simd-instrukce-vyuzivane-v-modernich-mikroprocesorech-rady-x86/</a>
</li>

<li>SIMD instrukce v moderních mikroprocesorech řady x86 (2.část: SSE)<br />
<a href="https://www.root.cz/clanky/simd-instrukce-v-modernich-mikroprocesorech-rady-x86-2-cast-sse/">https://www.root.cz/clanky/simd-instrukce-v-modernich-mikroprocesorech-rady-x86-2-cast-sse/</a>
</li>

<li>SIMD instrukce v moderních mikroprocesorech řady x86 (3.část: SSE2)<br />
<a href="https://www.root.cz/clanky/simd-instrukce-v-modernich-mikroprocesorech-rady-x86-3-cast-sse2/">https://www.root.cz/clanky/simd-instrukce-v-modernich-mikroprocesorech-rady-x86-3-cast-sse2/</a>
</li>

</ol>



<p><a name="k02"></a></p>
<h2 id="k02">2. Podpora n-rozměrných polí v&nbsp;programovacích jazycích a knihovnách</h2>

<p>Práce s&nbsp;vektory a maticemi byla (a samozřejmě doposud je) podporována v&nbsp;překladačích FORTRANu, které začaly být po vzniku superpočítačů vybaveny specializovanými algoritmy, které dokázaly převést některé typy programových smyček na &bdquo;vektorové operace&ldquo;. Paralelně vznikly i specializované jazyky určené téměř výhradně pro práci s&nbsp;vektory i maticemi. Velmi dobrým příkladem jsou programovací jazyky <i>APL</i> a <i>J</i>. I těmito neobvyklými (ale stále používanými!) programovacími jazyky jsme se na stránkách Rootu již zabývali, a to v&nbsp;následujících článcích:</p>

<ol>

<li>Programování mainframů: jazyk APL<br />
<a href="https://www.root.cz/clanky/programovani-mainframu-jazyk-apl/">https://www.root.cz/clanky/programovani-mainframu-jazyk-apl/</a>
</li>

<li>Programovací jazyk APL: programování bez smyček<br />
<a href="https://www.root.cz/clanky/programovaci-jazyk-apl-programovani-bez-smycek/">https://www.root.cz/clanky/programovaci-jazyk-apl-programovani-bez-smycek/</a>
</li>

<li>Programovací jazyk APL - dokončení<br />
<a href="https://www.root.cz/clanky/programovaci-jazyk-apl-dokonceni/">https://www.root.cz/clanky/programovaci-jazyk-apl-dokonceni/</a>
</li>

<li>Programovací jazyk J – od hieroglyfů k ASCII znakům<br />
<a href="https://www.root.cz/clanky/programovaci-jazyk-j-ndash-od-hieroglyfu-k-nbsp-ascii-znakum/">https://www.root.cz/clanky/programovaci-jazyk-j-ndash-od-hieroglyfu-k-nbsp-ascii-znakum/</a>
</li>

<li>Programujeme v jazyku J: vektory a matice<br />
<a href="https://www.root.cz/clanky/programujeme-v-jazyku-j-ndash-vektory-a-matice/">https://www.root.cz/clanky/programujeme-v-jazyku-j-ndash-vektory-a-matice/</a>
</li>

<li>Programovací jazyk J: operátory, uživatelské funkce a tacit programming<br />
<a href="https://www.root.cz/clanky/programovaci-jazyk-j-operatory-uzivatelske-funkce-a-tacit-programming/">https://www.root.cz/clanky/programovaci-jazyk-j-operatory-uzivatelske-funkce-a-tacit-programming/</a>
</li>

<li>Oslava 55 let od vzniku první implementace jazyka APL<br />
<a href="https://www.root.cz/clanky/oslava-55-let-od-vzniku-prvni-implementace-programovaciho-jazyka-apl/">https://www.root.cz/clanky/oslava-55-let-od-vzniku-prvni-implementace-programovaciho-jazyka-apl/</a>
</li>

</ol>

<p>Velmi dobrou podporu pro práci s&nbsp;maticemi ovšem nabízí i framework <a href="https://www.root.cz/serialy/torch-framework-pro-strojove-uceni/">Torch</a> založený na programovacím jazyku Lua, <a href="https://www.root.cz/serialy/programovaci-jazyk-julia/">programovací jazyk Julia</a> a knihovna <a href="https://www.numpy.org/">Numpy</a> určená pro programovací jazyk Python. Opět uvedu odkazy na články, v&nbsp;níž se touto populární a velmi často používanou knihovnou zabýváme do větší hloubky, než to umožňuje rozsah dnešního článku:</p>

<ol>

<li>Zpracování vektorů, matic a N-rozměrných polí v&nbsp;programovacím jazyku Kawa<br />
<a href="https://www.root.cz/clanky/zpracovani-vektoru-matic-a-n-rozmernych-poli-v-programovacim-jazyku-kawa/">https://www.root.cz/clanky/zpracovani-vektoru-matic-a-n-rozmernych-poli-v-programovacim-jazyku-kawa/</a>
</li>

<li>Rust: knihovna ndarray pro práci s&nbsp;n-rozměrnými poli<br />
<a href="https://www.root.cz/clanky/rust-knihovna-ndarray-pro-praci-s-n-rozmernymi-poli/">https://www.root.cz/clanky/rust-knihovna-ndarray-pro-praci-s-n-rozmernymi-poli/</a>
</li>

<li>Programovací jazyk Clojure a knihovny pro práci s&nbsp;vektory a maticemi<br />
<a href="https://www.root.cz/clanky/programovaci-jazyk-clojure-a-knihovny-pro-praci-s-vektory-a-maticemi/">https://www.root.cz/clanky/programovaci-jazyk-clojure-a-knihovny-pro-praci-s-vektory-a-maticemi/</a>
</li>

<li>Programovací jazyk Clojure a knihovny pro práci s vektory a maticemi (2)<br />
<a href="https://www.root.cz/clanky/programovaci-jazyk-clojure-a-knihovny-pro-praci-s-vektory-a-maticemi-2/">https://www.root.cz/clanky/programovaci-jazyk-clojure-a-knihovny-pro-praci-s-vektory-a-maticemi-2/</a>
</li>

<li>Gophernotes: kombinace interaktivního prostředí Jupyteru s jazykem Go<br />
<a href="https://www.root.cz/clanky/gophernotes-kombinace-interaktivniho-prostredi-jupyteru-s-jazykem-go/">https://www.root.cz/clanky/gophernotes-kombinace-interaktivniho-prostredi-jupyteru-s-jazykem-go/</a>
</li>

<li>Popis vybraných balíčků nabízených projektem Gonum<br />
<a href="https://www.root.cz/clanky/popis-vybranych-balicku-nabizenych-projektem-gonum/">https://www.root.cz/clanky/popis-vybranych-balicku-nabizenych-projektem-gonum/</a>
</li>

<li>Integrovaná vývojová prostředí ve Fedoře: vykreslování grafů s využitím knihoven Numpy a matplotlib<br />
<a href="https://mojefedora.cz/integrovana-vyvojova-prostredi-ve-fedore-vykreslovani-grafu-s-vyuzitim-knihoven-numpy-a-matplotlib/">https://mojefedora.cz/integrovana-vyvojova-prostredi-ve-fedore-vykreslovani-grafu-s-vyuzitim-knihoven-numpy-a-matplotlib/</a>
</li>

<li>Integrovaná vývojová prostředí ve Fedoře: praktické použití IPython Notebooku a knihovny Numpy (2.část)<br />
<a href="https://mojefedora.cz/integrovana-vyvojova-prostredi-ve-fedore-prakticke-pouziti-ipython-notebooku-a-knihovny-numpy-2-cast/">https://mojefedora.cz/integrovana-vyvojova-prostredi-ve-fedore-prakticke-pouziti-ipython-notebooku-a-knihovny-numpy-2-cast/</a>
</li>

<li>Integrovaná vývojová prostředí ve Fedoře: praktické použití IPython Notebooku a knihovny Numpy<br />
<a href="https://mojefedora.cz/integrovana-vyvojova-prostredi-ve-fedore-prakticke-pouziti-ipython-notebooku-a-knihovny-numpy/">https://mojefedora.cz/integrovana-vyvojova-prostredi-ve-fedore-prakticke-pouziti-ipython-notebooku-a-knihovny-numpy/</a>
</li>

</ol>



<p><a name="k03"></a></p>
<h2 id="k03">3. Jenže ... co si vlastně představit pod jménem <strong>pole</strong>?</h2>



<p><a name="k04"></a></p>
<h2 id="k04">4. Rozdílný přístup k&nbsp;práci s&nbsp;poli v&nbsp;různých programovacích jazycích</h2>

<ol>

<li>Jsou jednotlivé osy na sobě nezávislé?</li>

<li>Je možné indexy na jednotlivých osách pojmenovat?</li>

<li>Jedná se o homogenní nebo o heterogenní datovou strukturu? Homogenní struktura může uchovávat prvky jediného (typicky předem definovaného) typu zatímco v&nbsp;heterogenní struktuře mohou být umístěny prvky různých typů.</li>

</ol>




<p><a name="k05"></a></p>
<h2 id="k05">5. Optimalizace operací s&nbsp;poli, paralelní výpočty a zpracování signálů</h2>

<p>Překladače FORTRANu začaly být po vzniku superpočítačů vybavovány algoritmy, které dokázaly převést některé typy programových smyček na &bdquo;vektorové operace&ldquo;. Paralelně vznikly i specializované jazyky určené téměř výhradně pro práci s&nbsp;vektory i maticemi &ndash; příkladem je již zmíněná dvojice <i>APL</i> a <i>J</i>.</p>



<p><a name="k06"></a></p>
<h2 id="k06">6. Příklady rozdílných přístupů programovacích jazyků při práci s&nbsp;poli</h2>



<p><a name="k07"></a></p>
<h2 id="k07">7. Vektory a matice v&nbsp;Dartmouth BASICu popř.&nbsp;v&nbsp;BBS BASICu</h2>



<p><a name="k08"></a></p>
<h2 id="k08">8. Pole v&nbsp;programovacím jazyce Julia</h2>

<p>Základní homogenní datovou strukturou, kterou programovací jazyk Julia svým uživatelům nabízí, jsou jednorozměrná pole. Všechny prvky pole mají stejný typ (ostatně právě proto je to homogenní datová struktura) a ke každému prvku je možné přistupovat přes jeho index, přičemž indexování prvků má konstantní složitost (nezáleží tedy na délce pole). Prvky v&nbsp;běžných jednorozměrných polích je možné modifikovat, takže pole jsou měnitelné datové struktury (<i>mutable</i>). Podívejme se nyní na způsob vytvoření jednorozměrných polí v&nbsp;tomto programovacím jazyce:</p>

<pre>
julia&gt; <strong>a=[1, 2, 3, 4, 5]</strong>
5-element Array{Int64,1}:
 1
 2
 3
 4
 5
</pre>

<p>Při konstrukci pole se automaticky může zjistit datový typ prvků
(resp.&nbsp;typ, který všem prvkům odpovídá po případné konverzi). Povšimněte
si, jak se jazyk rozhoduje, který typ použít:</p>

<pre>
julia&gt; <strong>a=[1, 2.1, 1//3]</strong>
3-element Array{Float64,1}:
 1.0
 2.1
 0.333333
&nbsp;
julia&gt; <strong>a=[1, 2, 1//3]</strong>
3-element Array{Rational{Int64},1}:
 1//1
 2//1
 1//3
&nbsp;
julia&gt; <strong>a=[1/0, -1/0, 0/0]</strong>
3-element Array{Float64,1}:
  Inf
 -Inf
  NaN
&nbsp;
julia&gt; <strong>a=[pi, pi]</strong>
2-element Array{Irrational{:π},1}:
 π = 3.1415926535897...
 π = 3.1415926535897...
</pre>

<p>Typ je možné specifikovat explicitně:</p>

<pre>
julia&gt; <strong>Int8[1, 2, 3, 4, 5]</strong>
5-element Array{Int8,1}:
 1
 2
 3
 4
 5
&nbsp;
julia&gt; <strong>Float16[1, 2, 3, 4, 5]</strong>
5-element Array{Float16,1}:
 1.0
 2.0
 3.0
 4.0
 5.0
</pre>

<p>Pokud vynecháte čárky, vytvoří se ve skutečnosti dvourozměrné pole
s&nbsp;jedním řádkem:</p>

<pre>
julia&gt; <strong>a=[1 2 3 4 5]</strong>
1x5 Array{Int64,2}:
 1  2  3  4  5
&nbsp;
julia&gt; <strong>Float16[1 2 3 4 5]</strong>
1x5 Array{Float16,2}:
 1.0  2.0  3.0  4.0  5.0
&nbsp;
julia&gt; <strong>a=[1 2 3 4]</strong>
1x4 Array{Int64,2}:
 1  2  3  4
</pre>



<p><a name="k09"></a></p>
<h2 id="k09">9. Vícerozměrná pole, sloupcové a řádkové vektory</h2>

<p>Jak se však vytváří dvourozměrná pole? První pokus, který může vycházet ze
zkušeností z&nbsp;jiných programovacích jazyků, není příliš úspěšný:</p>

<pre>
julia&gt; <strong>[[1,2,3], [4,5,6]]</strong>
WARNING: [a,b] concatenation is deprecated; use [a;b] instead
 in depwarn at deprecated.jl:73
 in oldstyle_vcat_warning at ./abstractarray.jl:29
 in vect at abstractarray.jl:32
while loading no file, in expression starting on line 0
6-element Array{Int64,1}:
 1
 2
 3
 4
 5
 6
</pre>

<p>Problém představuje čárka vložená mezi oba vektory. Jedno z&nbsp;možných
řešení může vypadat takto &ndash; vytvoříme vlastně pole složené ze dvou
sloupců (povšimněte si chybějící čárky mezi vektory):</p>

<pre>
julia&gt; <strong>[[1,2,3] [4,5,6]]</strong>
3x2 Array{Int64,2}:
 1  4
 2  5
 3  6
</pre>

<p>Pokud preferujete zápis po řádcích, lze použít tento alternativní způsob se
středníkem. Je to sice poněkud neobvyklé, ale středník zde nahrazuje volání
funkce <strong>hvcat()</strong> zmíněné níže:</p>

<pre>
julia&gt; <strong>a=[1 2; 3 4]</strong>
2x2 Array{Int64,2}:
 1  2
 3  4
</pre>

<p>Pole se dvěma řádky a třemi sloupci:</p>

<pre>
julia&gt; <strong>[1 2 3 ; 3 4 5]</strong>
2x3 Array{Int64,2}:
 1  2  3
 3  4  5
</pre>

<p>Kromě zápisu prvků pole do hranatých závorek lze pro konstrukci použít i
funkce <strong>hcat</strong> (&bdquo;horizontal concatenate&ldquo;),
<strong>vcat</strong> (&bdquo;vertical concatenate&ldquo;) a
<strong>hvcat</strong> (kombinace obou možností se specifikací počtu
sloupců):</p>

<pre>
julia&gt; <strong>hcat(1,2,3,4)</strong>
1x4 Array{Int64,2}:
 1  2  3  4
</pre>

<pre>
julia&gt; <strong>vcat(1,2,3,4)</strong>
4-element Array{Int64,1}:
 1
 2
 3
 4
</pre>

<p>U funkce <strong>hvcat()</strong> si povšimněte, že první parametr
specifikuje počet sloupců a až po něm následují jednotlivé prvky:</p>

<pre>
julia&gt; <strong>hvcat(2,1,2,3,4)</strong>
2x2 Array{Int64,2}:
 1  2
 3  4
</pre>

<pre>
julia&gt; <strong>hvcat(1,1,2,3,4)</strong>
4x1 Array{Int64,2}:
 1
 2
 3
 4
</pre>

<pre>
julia&gt; <strong>hvcat(4,1,2,3,4)</strong>
1x4 Array{Int64,2}:
 1  2  3  4
</pre>

<p>Pro vytvoření pole s&nbsp;udáním typu prvků (ovšem bez inicializace
jednotlivých prvků) slouží konstruktor nazvaný jednoduše
<strong>Array</strong>. Při volání tohoto konstruktoru se nejprve ve složených
závorkách specifikuje typ prvků a již běžně v&nbsp;kulatých závorkách pak
rozměry pole v&nbsp;jednotlivých dimenzích:</p>

<pre>
help?&gt; <strong>Array</strong>
search: Array SubArray BitArray DenseArray StridedArray mmap_array
&nbsp;
  Array(dims)
&nbsp;
  Array{T}(dims) constructs an uninitialized dense array with element type T.
  dims may be a tuple or a series of integer arguments. The syntax Array(T,
  dims) is also available, but deprecated.
</pre>

<p>Konstrukce pole o rozměrech 2&times;2 prvky typu Int8 (osmibitové celé číslo
se znaménkem):</p>

<pre>
julia&gt; <strong>a=Array{Int8}(2,2)</strong>
2x2 Array{Int8,2}:
 112  -26
  82  -34
</pre>

<p>Vidíme, že se tato operace nepodařila, a to z&nbsp;toho důvodu, že se prvky
indexují od jedničky a nikoli od nuly. To se sice může zdát poněkud neobvyklé,
ovšem ve skutečnosti mnoho jazyků (dovolím si říci, že většina jazyků
NEodvozených od céčka) zvolilo stejný přístup: Fortran, Mathematica, R, MATLAB,
Lua atd. Správně tedy má příkaz vypadat takto:</p>

<pre>
julia&gt; <strong>a[1,1]=42</strong>
42
</pre>

<p>Prvek pole se skutečně změnil:</p>

<pre>
julia&gt; <strong>a</strong>
10x10 Array{Float16,2}:
 42.0  0.0  0.0  0.0  0.0  0.0  0.0  0.0  0.0  0.0
  0.0  0.0  0.0  0.0  0.0  0.0  0.0  0.0  0.0  0.0
  0.0  0.0  0.0  0.0  0.0  0.0  0.0  0.0  0.0  0.0
  0.0  0.0  0.0  0.0  0.0  0.0  0.0  0.0  0.0  0.0
  0.0  0.0  0.0  0.0  0.0  0.0  0.0  0.0  0.0  0.0
  0.0  0.0  0.0  0.0  0.0  0.0  0.0  0.0  0.0  0.0
  0.0  0.0  0.0  0.0  0.0  0.0  0.0  0.0  0.0  0.0
  0.0  0.0  0.0  0.0  0.0  0.0  0.0  0.0  0.0  0.0
  0.0  0.0  0.0  0.0  0.0  0.0  0.0  0.0  0.0  0.0
  0.0  0.0  0.0  0.0  0.0  0.0  0.0  0.0  0.0  0.0
</pre>

<p>Podívejme se nyní na složitější indexování, tentokrát vektoru:</p>

<pre>
julia&gt; <strong>v=[1 2 3 4 10 -1]</strong>
1x6 Array{Int64,2}:
 1  2  3  4  10  -1
</pre>

<p>Přístup k&nbsp;prvnímu prvku:</p>

<pre>
julia&gt; <strong>v[1]</strong>
1
</pre>

<p>Přístup k&nbsp;prvkům 2 až 4:</p>

<pre>
julia&gt; <strong>v[2:4]</strong>
3-element Array{Int64,1}:
 2
 3
 4
</pre>

<p>Přístup ke všem prvkům:</p>

<pre>
julia&gt; <strong>v[:]</strong>
6-element Array{Int64,1}:
  1
  2
  3
  4
 10
 -1
</pre>

<p>Pokud potřebujeme přistoupit k&nbsp;poslednímu prvku, není možné použít
index -1 (to lze v&nbsp;jiných jazycích), ale používá se zde slovo
<strong>end</strong>.  To opět není nijak unikátní, podobně se toto slovo
používá i v&nbsp;MATLABu:</p>

<pre>
julia&gt; <strong>v[end]</strong>
-1
</pre>

<p>Kombinace předchozích způsobů &ndash; od čtvrtého prvku do konce
vektoru:</p>

<pre>
julia&gt; <strong>v[4:end]</strong>
3-element Array{Int64,1}:
  4
 10
 -1
</pre>

<p>Zajímavý je výběr sekvence libovolných prvků vektoru (pole), a to
s&nbsp;využitím jiného vektoru obsahujícího indexy prvků. Povšimněte si
nutnosti použití dvojitých hranatých závorek &ndash; vnější závorky představují
operaci výběru prvků, vnitřní závorky vektor indexů:</p>

<pre>
julia&gt; <strong>v[[1,5,6,2,5,5]]</strong>
6-element Array{Int64,1}:
  1
 10
 -1
  2
 10
 10
</pre>



<p><a name="k10"></a></p>
<h2 id="k10">10. Změna tvaru pole funkcí <strong>reshape</strong></h2>



<p><a name="k11"></a></p>
<h2 id="k11">11. Jeden z&nbsp;důsledků typového systému jazyka Julia a měnitelnosti polí</h2>



<p><a name="k12"></a></p>
<h2 id="k12">12. </h2>



<p><a name="k13"></a></p>
<h2 id="k13">13. Knihovna <strong>core.matrix</strong></h2>

<p>Knihovna nazvaná <strong>core.matrix</strong> je určená těm vývojářům, kteří ve svých projektech potřebují provádět velké množství operací s&nbsp;maticemi různých dimenzí, a to na poměrně vysoké úrovni, tj.&nbsp;bez nutnosti přesně specifikovat, jak mají být matice uloženy v&nbsp;paměti, jakým způsobem provádět operaci násobení matic atd. Díky tomuto přístupu a taktéž díky vlastnostem programovacího jazyka <i>Clojure</i> (existence tzv.&nbsp;threading makra a funkcí vyššího řádu) se práce s&nbsp;maticemi do značné míry začíná podobat práci v&nbsp;APL, až na ten rozdíl, že algoritmy zapisované v&nbsp;<i>Clojure</i> jsou pro většinu vývojářů přece jen čitelnější :-).  Taktéž je důležité, že <i>rozhraní</i> definované v&nbsp;knihovně <strong>core.matrix</strong> může mít několik implementací. V&nbsp;současnosti se jedná o <i>vectorz-clj</i>, <i>Clatrix</i> a <i>NDArray</i>.  V&nbsp;<strong>core.matrix</strong> navíc došlo k&nbsp;rozšíření operátorů +, - atd. takovým způsobem, že je lze použít i pro zpracování vektorů a matic (ve skutečnosti se samozřejmě nejedná o skutečné operátory, protože tento koncept <i>Clojure</i> nepotřebuje).</p>



<p><a name="k14"></a></p>
<h2 id="k14">14. Projekt Incanter</h2>

<p></p>

<p>Projekt <i>Incanter</i> je založen na zpracování (rozsáhlých) matic a tzv.&nbsp;datasetů. Ve skutečnosti však klasicky chápané matice v&nbsp;Clojure příliš podporovány nejsou. Při studiu základních knihoven Clojure lze dojít k&nbsp;závěru, že vlastně jen velmi málo funkcí a maker je určeno pro práci s&nbsp;těmito datovými typy, i když je samozřejmě možné jak vektory, tak i matice velmi snadno reprezentovat s&nbsp;využitím základních sekvenčních datových struktur Clojure &ndash; seznamů a vektorů. Ve skutečnosti to však není zcela ideální řešení, a to hned z&nbsp;několika důvodů, jejichž společným rysem je rychlost prováděných operací. Z&nbsp;tohoto důvodu je v&nbsp;případě implementace algoritmů, v&nbsp;nichž se intenzivně používají operace s&nbsp;maticemi, mnohem výhodnější využít možností specializovaných knihoven.  My se dnes seznámíme především s&nbsp;elegantně navrženou knihovnou <strong>core.matrix</strong>, protože ta je používána i projektem <i>Incanter</i>.</p>

<p><div class="rs-tip-major">Poznámka: nesmíme taktéž zapomenout na způsob reprezentace datových struktur v&nbsp;operační paměti. Matice jsou většinou homogenní datovou strukturou, kterou lze v&nbsp;případě, že prvky jsou primitivního datového typu, uložit v&nbsp;kompaktní podobě. U obecných vektorů a sekvencí jazyka Clojure tomu tak však není. Problematikou uložené polí primitivních typů na haldě v&nbsp;JVM jsme se zabývali v&nbsp;článku <a href="https://www.root.cz/clanky/pohled-pod-kapotu-jvm-jak-efektivne-jsou-ulozena-pole-a-retezce-na-halde/">Pohled pod kapotu JVM - jak efektivně jsou uložena pole a řetězce na haldě?</a> (viz například šestou kapitolu).</div></p>

<p>V&nbsp;přednášce nazvané velmi příhodně &bdquo;Enter the Matrix&ldquo;, která je dostupná na adrese <a href="http://www.slideshare.net/mikeranderson/2013-1114-enter-thematrix">http://www.slideshare.net/mikeranderson/2013-1114-enter-thematrix</a>, je mj.&nbsp;ukázáno, jakým způsobem jsou v&nbsp;Clojure implementována různá paradigmata programování. Díky podpoře maker a způsobu zápisu programového kódu v&nbsp;Clojure lze velmi snadno implementovat různé doménově specifické jazyky (DSL), mj.&nbsp;i právě jazyk pro array programming:</p>

<table>
<tr><th>Paradigma</th><th>Jazyk</th><th>Implementace v&nbsp;Clojure</th></tr>
<tr><td>funkcionální</td><td>Haskell</td><td>clojure.core</td></tr>
<tr><td>OOP</td><td>Smalltalk</td><td>clojure.core</td></tr>
<tr><td>metaprogramování</td><td>Lisp</td><td>clojure.core</td></tr>
<tr><td>logické</td><td>Prolog</td><td>core.logic</td></tr>
<tr><td>array programming</td><td>APL, J</td><td>core.matrix</td></tr>
</table>

<p><div class="rs-tip-major">Poznámka: původní tabulka byla upravena a doplněna.</div></p>



<p><a name="k15"></a></p>
<h2 id="k15">15. </h2>



<p><a name="k16"></a></p>
<h2 id="k16">16. Vektory v&nbsp;programovacím jazyku Kawa</h2>

<p>Javovská pole podporovaná v&nbsp;programovacím jazyku <i>Kawa</i> přináší několik výhod, ale pochopitelně i nevýhod. Samotná pole mají pevnou délku a jejich prvky jsou vždy stejného typu. Tato vlastnost (výhoda a nevýhoda současně) umožňuje velmi efektivní přístup k&nbsp;prvkům pole, který má u jednorozměrných polí konstantní složitost. Současně jsme však omezeni například tím, že do javovských polí není možné jednoduše ukládat zlomky, celá čísla s&nbsp;libovolným rozsahem atd. V&nbsp;případě, že budeme potřebovat i tuto funkcionalitu, je nutné namísto polí použít odlišné datové typy programovacího jazyka <i>Kawa</i>. Může se jednat o <i>vektory</i> podporované v&nbsp;mnoha implementacích LISPu i Scheme (a taktéž v&nbsp;jazyku Clojure, i když zde mají vektory zcela odlišné vnitřní uspořádání) nebo o typ pojmenovaný pro větší zmatek v&nbsp;terminologii <i>array</i>.</p>

<p>V&nbsp;této kapitole si ukážeme práci s&nbsp;takzvanými vektory.</p>

<table>
<tr><th>#</th><th>Funkce</th><th>Stručný popis funkce</th></tr>
<tr><td>1</td><td>vector</td><td>konstrukce vektoru a inicializace jeho prvků</td></tr>
<tr><td>2</td><td>vector-ref</td><td>přístup k&nbsp;prvku vektoru</td></tr>
<tr><td>3</td><td>vector-set!</td><td>změna hodnoty prvku vektoru</td></tr>
<tr><td>4</td><td>vector?</td><td>predikát: dotaz, zda je předaná hodnota typu vektor či nikoli</td></tr>
<tr><td>5</td><td>vector-length</td><td>vrací délku vektoru, tedy počet jeho prvků</td></tr>
<tr><td>6</td><td>vector-&gt;list</td><td>převod vektoru na seznam</td></tr>
<tr><td>7</td><td>list-&gt;vector</td><td>opačný převod</td></tr>
</table>

<p>Vektor lze zkonstruovat speciálním &bdquo;konstruktorem&ldquo;, v&nbsp;němž se jednotlivé prvky vektoru zapisují do hranatých závorek (což již známe z&nbsp;programovacího jazyka Clojure). K&nbsp;prvkům vektoru se přistupuje funkcí <strong>vector-ref</strong>:</p>

<pre>
(define vector1 <strong>[1 2 3 4]</strong>)
&nbsp;
(display vector1)
(newline)
&nbsp;
(display (<strong>vector-ref</strong> vector1 0))
(display (<strong>vector-ref</strong> vector1 10))
</pre>

<p>Výsledek:</p>

<pre>
#(1 2 3 4)
java.lang.ArrayIndexOutOfBoundsException: 10
        at gnu.lists.FVector.get(FVector.java:105)
        at kawa.lib.vectors.vectorRef(vectors.scm:21)
        at Vectors1.run(Vectors1.scm:7)
        at gnu.expr.ModuleExp.evalModule2(ModuleExp.java:289)
        at gnu.expr.CompiledModule.evalModule(CompiledModule.java:42)
        at gnu.expr.CompiledModule.evalModule(CompiledModule.java:60)
        at kawa.Shell.runFile(Shell.java:565)
        at kawa.Shell.runFileOrClass(Shell.java:468)
        at kawa.repl.processArgs(repl.java:700)
        at kawa.repl.main(repl.java:820)
</pre>

<p><div class="rs-tip-major">Poznámka: chyba nastala při přístupu k&nbsp;prvku
s&nbsp;indexem 10, který ve čtyřprvkovém vektoru pochopitelně
neexistuje.</div></p>

<p>Vektory lze taktéž zapsat stylem <strong>#()</strong>, který je kompatibilní s&nbsp;R7RS:</p>

<pre>
#|kawa:1|# <strong>#(1 2 3)</strong>
#(1 2 3)
&nbsp;
#|kawa:2|# <strong>[1 2 3]</strong>
#(1 2 3)
&nbsp;
#|kawa:3|# <strong>(eq? #(1 2 3) [1 2 3])</strong>
#f
&nbsp;
#|kawa:4|# <strong>(equal? #(1 2 3) [1 2 3])</strong>
#t
</pre>

<p>V&nbsp;dalším příkladu je namísto zápisu prvků vektoru do hranatých závorek použit konstruktor představovaný funkcí nazvanou jednoduše <strong>vector</strong>. Taktéž je zde ukázána změna hodnoty vybraného prvku s&nbsp;využitím funkce <strong>vector-set!</strong> (tato funkce opět obsahuje ve svém jménu vykřičník, protože mění stav aplikace):</p>

<pre>
(define vector2 (<strong>vector 1 2 3 4 5</strong>))
&nbsp;
(display vector2)
(newline)
&nbsp;
(display (<strong>vector-ref</strong> vector2 0))
(newline)
&nbsp;
(<strong>vector-set!</strong> vector2 2 -1)
&nbsp;
(display vector2)
(newline)
</pre>

<p>Výsledek:</p>

<pre>
#(1 2 3 4 5)
1
#(1 2 -1 4 5)
</pre>

<p>Dotazy, zda je daná hodnota vektorem či nikoli, používají predikát <strong>vector?</strong>:</p>

<pre>
#|kawa:25|# <strong>(vector? "A")</strong>
#f
&nbsp;
#|kawa:26|# <strong>(vector? [1 2 3])</strong>
#t
&nbsp;
#|kawa:27|# <strong>(vector? '(1 2 3))</strong>
#f
</pre>

<p>Další funkce je určena pro získání velikosti vektoru, tedy počtu jeho prvků:</p>

<pre>
#|kawa:28|# <strong>(vector-length [1 2 3])</strong>
3
&nbsp;
#|kawa:29|# <strong>(vector-length [])</strong>
0
</pre>



<p><a name="k17"></a></p>
<h2 id="k17">17. N-rozměrná pole (ND-Array) v&nbsp;jazyku Kawa</h2>

<p>V&nbsp;této kapitole se ve stručnost seznámíme s&nbsp;možnostmi typu <i>array</i>, což je datový typ představující N-rozměrná pole. Kromě toho si ukážeme i práci s&nbsp;takzvanými &bdquo;rozsahy&ldquo; (<i>range</i>), které do značné míry s&nbsp;poli souvisí.</p>

<p>Datový typ <i>array</i> se používá nejenom v&nbsp;jazyce <i>Kawa</i>, ale například i v&nbsp;programovacím jazyce <i>Racket</i> (jedná se pravděpodobně o nejrozsáhlejší a nejúplnější implementaci Scheme vůbec). Samotné pole se skládá ze dvou částí: hodnot jednotlivých prvků a tvaru pole neboli <i>shape</i>. Tvar pole je důležitou strukturou, protože (nepřímo) určuje, jakým způsobem jsou prvky v&nbsp;poli uspořádány. To však není vše, protože je možné jednoduše tvar pole změnit a tím pádem prvky zdánlivě zpřeházet (interně se ovšem v&nbsp;operační paměti s&nbsp;prvky v&nbsp;některých případech manipulovat nemusí). Další důležitou vlastností datového typu <i>array</i> je možnost uložit do pole libovolné hodnoty; jedná se tedy o <i>heterogenní kontejner</i>, na rozdíl od běžných javovských polí.</p>

<p>Ke konstrukci N-rozměrného pole slouží funkce nazvaná <strong>make-array</strong>. Této funkci se předává vektor obsahující velikosti (rozsah indexů) N-rozměrného pole ve všech dimenzích. Počet prvků tohoto vektoru tedy odpovídá počtu dimenzí. Dále je možné této funkci předat i hodnoty jednotlivých prvků, což si ukážeme v&nbsp;dalším textu. Funkci <strong>make-array</strong> si můžeme velmi snadno otestovat přímo v&nbsp;interaktivní smyčce REPL programovacího jazyka Kawa.</p>

<p>Mezním případem je prázdné pole:</p>

<pre>
#|kawa:3|# <strong>(make-array [0])</strong>
&nbsp;
#()
</pre>

<p>Konstrukce jednoprvkového jednorozměrné pole vypadá takto:</p>

<pre>
#|kawa:8|# <strong>(make-array [1])</strong>
&nbsp;
#(#!null)
</pre>

<p><div class="rs-tip-major">Poznámka: povšimněte si, jaká je výchozí hodnota jediného prvku vytvořeného pole.</div></p>

<p>Desetiprvkový vektor, jehož všechny prvky mají výchozí hodnotu:</p>

<pre>
#|kawa:5|# <strong>(make-array [10])</strong>
&nbsp;
#(#!null #!null #!null #!null #!null #!null #!null #!null #!null #!null)
</pre>

<p>Konstrukce matice typu 1&times;1, tedy matice s&nbsp;jediným prvkem, který má výchozí hodnotu:</p>

<pre>
#|kawa:9|# <strong>(make-array [1 1])</strong>
&nbsp;
╔#2a:1:1
║#!null║
╚══════╝
</pre>

<p>Konstrukce matice s&nbsp;jedním řádkem a dvěma sloupci:</p>

<pre>
#|kawa:7|# <strong>(make-array [1 2])</strong>
&nbsp;
╔#2a:1:2══════╗
║#!null│#!null║
╚══════╧══════╝
</pre>

<p><div class="rs-tip-major">Poznámka: povšimněte si, jakým způsobem interpret programovacího jazyka <i>Kawa</i> zobrazuje obsah zkonstruovaného pole. U jednorozměrných polí je výsledek zobrazen formou připomínající běžný seznam nebo vektor, ale u dvourozměrných polí zobrazuje tabulku s&nbsp;obsahem jednotlivých prvků, přičemž je na prvním řádku upřesněn jak počet dimenzí, tak i rozsah indexů v&nbsp;jednotlivých dimenzích (zde konkrétně počet řádků oddělený od počtu sloupců dvojtečkou).</div></p>

<p>Pokračujme s&nbsp;nepatrně složitější maticí, konkrétně s&nbsp;maticí se dvěma řádky a třemi sloupci:</p>

<pre>
#|kawa:10|# <strong>(make-array [2 3])</strong>
&nbsp;
╔#2a:2:3══════╤══════╗
║#!null│#!null│#!null║
╟──────┼──────┼──────╢
║#!null│#!null│#!null║
╚══════╧══════╧══════╝
</pre>

<p>Trojrozměrná struktura 2&times;3&times;4 prvky:</p>

<pre>
#|kawa:11|# <strong>(make-array [2 3 4])</strong>
&nbsp;
╔#3a:2:3:4════╤══════╤══════╗
║#!null│#!null│#!null│#!null║
╟──────┼──────┼──────┼──────╢
║#!null│#!null│#!null│#!null║
╟──────┼──────┼──────┼──────╢
║#!null│#!null│#!null│#!null║
╠══════╪══════╪══════╪══════╣
║#!null│#!null│#!null│#!null║
╟──────┼──────┼──────┼──────╢
║#!null│#!null│#!null│#!null║
╟──────┼──────┼──────┼──────╢
║#!null│#!null│#!null│#!null║
╚══════╧══════╧══════╧══════╝
</pre>

<p><div class="rs-tip-major">Poznámka: u trojrozměrné a taktéž u vícerozměrných struktur je již nutné použít oddělovač jednotlivých 2D podmatic tak, jak je to ukázáno na předchozím výstupu z&nbsp;interpretru programovacího jazyka <i>Kawa</i>. Podrobnější informace najdete na stránce <a href="https://www.gnu.org/software/guile/manual/html_node/Array-Syntax.html">https://www.gnu.org/software/guile/manual/html_node/Array-Syntax.html</a>.</div></p>

<p>Taktéž trojrozměrná struktura, ovšem tentokrát s&nbsp;tvarem 4&times;3&times;2 prvky:</p>

<pre>
#|kawa:12|# <strong>(make-array [4 3 2])</strong>
&nbsp;
╔#3a:4:3:2════╗
║#!null│#!null║
╟──────┼──────╢
║#!null│#!null║
╟──────┼──────╢
║#!null│#!null║
╠══════╪══════╣
║#!null│#!null║
╟──────┼──────╢
║#!null│#!null║
╟──────┼──────╢
║#!null│#!null║
╠══════╪══════╣
║#!null│#!null║
╟──────┼──────╢
║#!null│#!null║
╟──────┼──────╢
║#!null│#!null║
╠══════╪══════╣
║#!null│#!null║
╟──────┼──────╢
║#!null│#!null║
╟──────┼──────╢
║#!null│#!null║
╚══════╧══════╝
</pre>

<p>Čtyřrozměrné pole:</p>

<pre>
#|kawa:7|# <strong>(make-array [2 2 2 2])</strong>
&nbsp;
╔#4a:2:2:2:2══╗
║#!null│#!null║
╟──────┼──────╢
║#!null│#!null║
╠══════╪══════╣
║#!null│#!null║
╟──────┼──────╢
║#!null│#!null║
╠══════╪══════╣
║#!null│#!null║
╟──────┼──────╢
║#!null│#!null║
╠══════╪══════╣
║#!null│#!null║
╟──────┼──────╢
║#!null│#!null║
╚══════╧══════╝
</pre>

<p>Pole, které má v&nbsp;jedné dimenzi nulovou velikost a celkově tedy nula
prvků:</p>

<pre>
#|kawa:11|# <strong>(make-array [0 2 2 2])</strong>
&nbsp;
#4a:0:2:2:2 ()
</pre>

<p>Funkci <strong>make-arrray</strong>, s&nbsp;jejím základním použitím jsme se seznámili v&nbsp;předchozím textu, je možné předat i hodnoty jednotlivých prvků vytvářeného pole. Pokud je počet zadaných hodnot menší než počet prvků, budou se prvky opakovat tak dlouho, až se pole postupně vyplní. Samozřejmě se opět podíváme na příklady.</p>

<p>Vektor obsahující stejné hodnoty ve všech prvcích:</p>

<pre>
#|kawa:13|# <strong>(make-array [10] 1/2)</strong>
&nbsp;
#(1/2 1/2 1/2 1/2 1/2 1/2 1/2 1/2 1/2 1/2)
</pre>

<p>Dvourozměrné pole (matice) se dvěma řádky a čtyřmi sloupci:</p>

<pre>
#|kawa:1|# <strong>(make-array [2 4] 1 2 3 4 5)</strong>
&nbsp;
╔#2a:2:4╗
║1│2│3│4║
╟─┼─┼─┼─╢
║5│1│2│3║
╚═╧═╧═╧═╝
</pre>

<p>Pole 5&times;5 prvků se shodnými řádky:</p>

<pre>
#|kawa:14|# <strong>(make-array [5 5] 1 2 3 4 5)</strong>
&nbsp;
╔#2a:5:5╤═╗
║1│2│3│4│5║
╟─┼─┼─┼─┼─╢
║1│2│3│4│5║
╟─┼─┼─┼─┼─╢
║1│2│3│4│5║
╟─┼─┼─┼─┼─╢
║1│2│3│4│5║
╟─┼─┼─┼─┼─╢
║1│2│3│4│5║
╚═╧═╧═╧═╧═╝
</pre>

<p>Trojrozměrné pole 2&times;3&times;4 prvky:</p>

<pre>
#|kawa:2|# <strong>(make-array [2 3 4] 1 2 3 4 5)</strong>
&nbsp;
#3a:2:3:4
║1│2│3│4║
╟─┼─┼─┼─╢
║5│1│2│3║
╟─┼─┼─┼─╢
║4│5│1│2║
╠═╪═╪═╪═╣
║3│4│5│1║
╟─┼─┼─┼─╢
║2│3│4│5║
╟─┼─┼─┼─╢
║1│2│3│4║
╚═╧═╧═╧═╝
</pre>

<p>Čtyřrozměrné pole 2&times;2&times;2&times;3 prvky:</p>

<pre>
#|kawa:11|# <strong>(make-array [2 2 2 3] 1 2 3)</strong>
&nbsp;
#4a═╤═╗
║1│2│3║
╟─┼─┼─╢
║1│2│3║
╠═╪═╪═╣
║1│2│3║
╟─┼─┼─╢
║1│2│3║
╠═╪═╪═╣
║1│2│3║
╟─┼─┼─╢
║1│2│3║
╠═╪═╪═╣
║1│2│3║
╟─┼─┼─╢
║1│2│3║
╚═╧═╧═╝
</pre>

<p>Při inicializaci polí se používá konstrukce <i>range</i>. Jedná se o jeden ze způsobů, jakým lze v&nbsp;programovacím jazyku <i>Kawa</i> popsat sekvenci hodnot bez toho, aby bylo nutné explicitně vypsat všechny prvky v&nbsp;sekvenci (a navíc může být zápis názornější, než v&nbsp;případě použití funkce <strong>range</strong> známé z&nbsp;mnoha jiných programovacích jazyků). Nejnázornější bude si ukázat možnosti, které při specifikaci rozsahů máme.</p>

<p>Hodnoty od 1 do 9 (hodnota 10 již v&nbsp;rozsahu není):</p>

<pre>
#|kawa:1|# <strong>[1 &lt;: 10]</strong>
&nbsp;
#(1 2 3 4 5 6 7 8 9)
</pre>

<p>Hodnoty od 1 do 10, včetně obou mezí:</p>

<pre>
#|kawa:2|# <strong>[1 &lt;=: 10]</strong>
&nbsp;
#(1 2 3 4 5 6 7 8 9 10)
</pre>

<p>Počítání směrem k&nbsp;záporné ose (bez uvedení kroku):</p>

<pre>
#|kawa:3|# <strong>[10 &gt;: 0]</strong>
&nbsp;
#(10 9 8 7 6 5 4 3 2 1)
</pre>

<p>Dtto, ale včetně nuly:</p>

<pre>
#|kawa:5|# <strong>[10 &gt;=: 0]</strong>
&nbsp;
#(10 9 8 7 6 5 4 3 2 1 0)
</pre>

<p>Specifikace kroku:</p>

<pre>
#|kawa:4|# <strong>[10 by: -2 >: 0]</strong>
&nbsp;
#(10 8 6 4 2)
</pre>

<p>Dtto, ale včetně nuly:</p>

<pre>
#|kawa:6|# <strong>[10 by: -2 &gt;=: 0]</strong>
&nbsp;
#(10 8 6 4 2 0)
</pre>

<p>Práce se zlomky:</p>

<pre>
#|kawa:7|# <strong>[1 by: 1/2 &lt;=: 10]</strong>
&nbsp;
#(1 3/2 2 5/2 3 7/2 4 9/2 5 11/2 6 13/2 7 15/2 8 17/2 9 19/2 10)
</pre>

<p>Počítání po 1/10 (což v&nbsp;IEEE 754 není možné):</p>

<pre>
#|kawa:8|# <strong>[0 by: 1/10 &lt;=: 1]</strong>
&nbsp;
#(0 1/10 1/5 3/10 2/5 1/2 3/5 7/10 4/5 9/10 1)
</pre>

<p>Výsledkem bude prázdný vektor:</p>

<pre>
#|kawa:14|# <strong>[0 by: 1 &lt;=: -1]</strong>
&nbsp;
#()
</pre>

<pre>
#|kawa:2|# <strong>(index-array [[1 &lt;: 10]])</strong>
&nbsp;
╔#1a@1:9╤═╤═╤═╤═╤═╗
║0│1│2│3│4│5│6│7│8║
╚═╧═╧═╧═╧═╧═╧═╧═╧═╝
</pre>

<p>Popř.:</p>

<pre>
#|kawa:3|# <strong>(index-array [[1 &lt;=: 10]])</strong>
╔#1a@1:10═╤═╤═╤═╤═╤═╗
║0│1│2│3│4│5│6│7│8│9║
╚═╧═╧═╧═╧═╧═╧═╧═╧═╧═╝
</pre>

<p>Dvourozměrné pole:</p>

<pre>
#|kawa:3|# <strong>(index-array [[1 &lt;: 3] [2 &lt;: 6]])</strong>
&nbsp;
#2a@1:2@2:4
║0│1│2│3║
╟─┼─┼─┼─╢
║4│5│6│7║
╚═╧═╧═╧═╝
</pre>

<p>Trojrozměrné pole:</p>

<pre>
#|kawa:5|# <strong>(index-array [[1 &lt;: 4] [1 &lt;: 4] [1 &lt;: 4]])</strong>
&nbsp;
#3a@1:3@1:3@1:3
║ 0│ 1│ 2║
╟──┼──┼──╢
║ 3│ 4│ 5║
╟──┼──┼──╢
║ 6│ 7│ 8║
╠══╪══╪══╣
║ 9│10│11║
╟──┼──┼──╢
║12│13│14║
╟──┼──┼──╢
║15│16│17║
╠══╪══╪══╣
║18│19│20║
╟──┼──┼──╢
║21│22│23║
╟──┼──┼──╢
║24│25│26║
╚══╧══╧══╝
</pre>

<p>Odlišný spodní index:</p>

<pre>
#|kawa:12|# <strong>(index-array [[3 &lt;: 7] [3 &lt;: 7] [3 &lt;: 7]])</strong>
&nbsp;
#3a@3:4@3:4@3:4
║ 0│ 1│ 2│ 3║
╟──┼──┼──┼──╢
║ 4│ 5│ 6│ 7║
╟──┼──┼──┼──╢
║ 8│ 9│10│11║
╟──┼──┼──┼──╢
║12│13│14│15║
╠══╪══╪══╪══╣
║16│17│18│19║
╟──┼──┼──┼──╢
║20│21│22│23║
╟──┼──┼──┼──╢
║24│25│26│27║
╟──┼──┼──┼──╢
║28│29│30│31║
╠══╪══╪══╪══╣
║32│33│34│35║
╟──┼──┼──┼──╢
║36│37│38│39║
╟──┼──┼──┼──╢
║40│41│42│43║
╟──┼──┼──┼──╢
║44│45│46│47║
╠══╪══╪══╪══╣
║48│49│50│51║
╟──┼──┼──┼──╢
║52│53│54│55║
╟──┼──┼──┼──╢
║56│57│58│59║
╟──┼──┼──┼──╢
║60│61│62│63║
╚══╧══╧══╧══╝
</pre>

<p><a name="k18"></a></p>
<h2 id="k18">18. </h2>



<p><a name="k19"></a></p>
<h2 id="k19">19. Shrnutí úvodního článku</h2>



<p><a name="k20"></a></p>
<h2 id="k20">20. Odkazy na Internetu</h2>

<ol>

<li>What is an Array?<br />
<a href="https://vector.org.uk/what-is-an-array/">https://vector.org.uk/what-is-an-array/</a>
</li>

<li>Vector (Wolfram MathWorld)<br />
<a href="https://mathworld.wolfram.com/Vector.html">https://mathworld.wolfram.com/Vector.html</a>
</li>

<li>n-Tuple (Wolfram MathWorld)<br />
<a href="https://mathworld.wolfram.com/n-Tuple.html">https://mathworld.wolfram.com/n-Tuple.html</a>
</li>

<li>n-Vector (Wolfram MathWorld)<br />
<a href="https://mathworld.wolfram.com/n-Vector.html">https://mathworld.wolfram.com/n-Vector.html</a>
</li>

<li>Matrix (Wolfram MathWorld)<br />
<a href="https://mathworld.wolfram.com/Matrix.html">https://mathworld.wolfram.com/Matrix.html</a>
</li>

<li>Array (Wolfram MathWorld)<br />
<a href="https://mathworld.wolfram.com/Array.html">https://mathworld.wolfram.com/Array.html</a>
</li>

<li>ND Arrays (Tensors) in different languages<br />
<a href="https://www.youtube.com/watch?v=WbpbEilgQBc">https://www.youtube.com/watch?v=WbpbEilgQBc</a>
</li>

<li>Extending APL to Infinity\<br />
<a href="https://www.jsoftware.com/papers/eem/infinity.htm">https://www.jsoftware.com/papers/eem/infinity.htm</a>
</li>

<li>Vector Library (R7RS-compatible)<br />
<a href="https://srfi.schemers.org/srfi-133/srfi-133.html">https://srfi.schemers.org/srfi-133/srfi-133.html</a>
</li>

<li>Vectors (pro Gauche)<br />
<a href="https://practical-scheme.net/gauche/man/gauche-refe/Vectors.html">https://practical-scheme.net/gauche/man/gauche-refe/Vectors.html</a>
</li>

<li>Kawa: Compiling Scheme to Java<br />
<a href="https://www.mit.edu/afs.new/sipb/project/kawa/doc/kawa-tour.html">https://www.mit.edu/afs.new/sipb/project/kawa/doc/kawa-tour.html</a>
</li>

<li>Kawa in Languages shootout<br />
<a href="http://per.bothner.com/blog/2010/Kawa-in-shootout/">http://per.bothner.com/blog/2010/Kawa-in-shootout/</a>
</li>

<li>Kawa 2.0 Supports Scheme R7RS<br />
<a href="https://developers.slashdot.org/story/14/12/13/2259225/kawa-20-supports-scheme-r7rs/">https://developers.slashdot.org/story/14/12/13/2259225/kawa-20-supports-scheme-r7rs/</a>
</li>

<li>Kawa — fast scripting on the Java platform<br />
<a href="https://lwn.net/Articles/623349/">https://lwn.net/Articles/623349/</a>
</li>

<li>Incanter is a Clojure-based, R-like platform for statistical computing and graphics.<br />
<a href="http://incanter.org/">http://incanter.org/</a>
</li>

<li>Evolution of incanter (Gource Visualization)<br />
<a href="https://www.youtube.com/watch?v=TVfL5nPELr4">https://www.youtube.com/watch?v=TVfL5nPELr4</a>
</li>

<li>Questions tagged [incanter] (na Stack Overflow)<br />
<a href="https://stackoverflow.com/questions/tagged/incanter?sort=active">https://stackoverflow.com/questions/tagged/incanter?sort=active</a>
</li>

<li>Data Sorcery with Clojure<br />
<a href="https://data-sorcery.org/contents/">https://data-sorcery.org/contents/</a>
</li>

<li>Back to the Future: Lisp as a Base for a Statistical Computing System<br />
<a href="https://rd.springer.com/chapter/10.1007/978-3-7908-2084-3_2">https://rd.springer.com/chapter/10.1007/978-3-7908-2084-3_2</a>
</li>

<li>Incanter Cheat Sheet<br />
<a href="http://incanter.org/docs/incanter-cheat-sheet.pdf">http://incanter.org/docs/incanter-cheat-sheet.pdf</a>
</li>

<li>Back to the Future: Lisp as a Base for a Statistical Computing System (celá verze článku)<br />
<a href="https://www.researchgate.net/publication/227019917_Back_to_the_Future_Lisp_as_a_Base_for_a_Statistical_Computing_System">https://www.researchgate.net/publication/227019917_Back_to_the_Future_Lisp_as_a_Base_for_a_Statistical_Computing_System</a>
</li>

<li>BQN: finally, an APL for your flying saucer<br />
<a href="https://mlochbaum.github.io/BQN/">https://mlochbaum.github.io/BQN/</a>
</li>

<li>Is BQN stable?<br />
<a href="https://mlochbaum.github.io/BQN/commentary/stability.html">https://mlochbaum.github.io/BQN/commentary/stability.html</a>
</li>

<li>Specification: BQN system-provided values<br />
<a href="https://mlochbaum.github.io/BQN/spec/system.html">https://mlochbaum.github.io/BQN/spec/system.html</a>
</li>

<li>Tutorial: BQN expressions<br />
<a href="https://mlochbaum.github.io/BQN/tutorial/expression.html">https://mlochbaum.github.io/BQN/tutorial/expression.html</a>
</li>

<li>BQN primitives<br />
<a href="https://mlochbaum.github.io/BQN/doc/primitive.html">https://mlochbaum.github.io/BQN/doc/primitive.html</a>
</li>

<li>Function trains<br />
<a href="https://mlochbaum.github.io/BQN/doc/train.html">https://mlochbaum.github.io/BQN/doc/train.html</a>
</li>

<li>BQN community links<br />
<a href="https://mlochbaum.github.io/BQN/community/index.html">https://mlochbaum.github.io/BQN/community/index.html</a>
</li>

<li>BQN UV<br />
<a href="https://observablehq.com/@lsh/bqn-uv">https://observablehq.com/@lsh/bqn-uv</a>
</li>

<li>APL Wiki<br />
<a href="https://aplwiki.com/wiki/">https://aplwiki.com/wiki/</a>
</li>

<li>The Array Cast<br />
<a href="https://www.arraycast.com/episodes/episode-03-what-is-an-array">https://www.arraycast.com/episodes/episode-03-what-is-an-array</a>
</li>

<li>EnthusiastiCon 2019 – An Introduction to APL<br />
<a href="https://www.youtube.com/watch?v=UltnvW83_CQ">https://www.youtube.com/watch?v=UltnvW83_CQ</a>
</li>

<li>Dyalog<br />
<a href="https://www.dyalog.com/">https://www.dyalog.com/</a>
</li>

<li>Try APL!<br />
<a href="https://tryapl.org/">https://tryapl.org/</a>
</li>

<li>Lisp-Stat Information<br />
<a href="http://homepage.cs.uiowa.edu/~luke/xls/xlsinfo/">http://homepage.cs.uiowa.edu/~luke/xls/xlsinfo/</a>
</li>

<li>Sample Plots in Incanter<br />
<a href="https://github.com/incanter/incanter/wiki/Sample-Plots-in-Incanter#line">https://github.com/incanter/incanter/wiki/Sample-Plots-in-Incanter#line</a>
</li>

<li>vectorz-clj<br />
<a href="https://github.com/mikera/vectorz-clj">https://github.com/mikera/vectorz-clj</a>
</li>

<li>vectorz - Examples<br />
<a href="https://github.com/mikera/vectorz-clj/wiki/Examples">https://github.com/mikera/vectorz-clj/wiki/Examples</a>
</li>

<li>Basic Vector and Matrix Operations in Julia: Quick Reference and Examples<br />
<a href="https://queirozf.com/entries/basic-vector-and-matrix-operations-in-julia-quick-reference-and-examples">https://queirozf.com/entries/basic-vector-and-matrix-operations-in-julia-quick-reference-and-examples</a>
</li>

<li>Vectors and matrices in Julia<br />
<a href="https://fncbook.github.io/v1.0/linsys/demos/matrices-julia.html">https://fncbook.github.io/v1.0/linsys/demos/matrices-julia.html</a>
</li>

<li>Array vs Matrix in R Programming<br />
<a href="https://www.geeksforgeeks.org/array-vs-matrix-in-r-programming/">https://www.geeksforgeeks.org/array-vs-matrix-in-r-programming/</a>
</li>

<li>Concurrency (computer science)<br />
<a href="https://en.wikipedia.org/wiki/Category:Concurrency_%28computer_science%29">https://en.wikipedia.org/wiki/Category:Concurrency_%28computer_science%29</a>
</li>

<li>Koprogram<br />
<a href="https://cs.wikipedia.org/wiki/Koprogram">https://cs.wikipedia.org/wiki/Koprogram</a>
</li>

<li>Coroutine<br />
<a href="https://en.wikipedia.org/wiki/Coroutine">https://en.wikipedia.org/wiki/Coroutine</a>
</li>

<li>Coroutines in C<br />
<a href="http://www.chiark.greenend.org.uk/~sgtatham/coroutines.html">http://www.chiark.greenend.org.uk/~sgtatham/coroutines.html</a>
</li>

<li>S-expression (Wikipedia)<br />
<a href="https://en.wikipedia.org/wiki/S-expression">https://en.wikipedia.org/wiki/S-expression</a>
</li>

<li>S-Expressions (Rosetta Code)<br />
<a href="http://rosettacode.org/wiki/S-Expressions">http://rosettacode.org/wiki/S-Expressions</a>
</li>

<li>Introducing Julia/Metaprogramming<br />
<a href="https://en.wikibooks.org/wiki/Introducing_Julia/Metaprogramming">https://en.wikibooks.org/wiki/Introducing_Julia/Metaprogramming</a>
</li>

<li>Tutorial for the Common Lisp Loop Macro<br />
<a href="http://www.ai.sri.com/pkarp/loop.html">http://www.ai.sri.com/pkarp/loop.html</a>
</li>

<li>Clojure Macro Tutorial (Part I, Getting the Compiler to Write Your Code For You)<br />
<a href="http://www.learningclojure.com/2010/09/clojure-macro-tutorial-part-i-getting.html">http://www.learningclojure.com/2010/09/clojure-macro-tutorial-part-i-getting.html</a>
</li>

<li>Clojure Macro Tutorial (Part II: The Compiler Strikes Back)<br />
<a href="http://www.learningclojure.com/2010/09/clojure-macro-tutorial-part-ii-compiler.html">http://www.learningclojure.com/2010/09/clojure-macro-tutorial-part-ii-compiler.html</a>
</li>

<li>Clojure Macro Tutorial (Part III: Syntax Quote)<br />
<a href="http://www.learningclojure.com/2010/09/clojure-macro-tutorial-part-ii-syntax.html">http://www.learningclojure.com/2010/09/clojure-macro-tutorial-part-ii-syntax.html</a>
</li>

<li>Clojure Macros and Metaprogramming<br />
<a href="http://clojure-doc.org/articles/language/macros.html">http://clojure-doc.org/articles/language/macros.html</a>
</li>

<li>Fatvat - Exploring functional programming: Clojure Macros<br />
<a href="http://www.fatvat.co.uk/2009/02/clojure-macros.html">http://www.fatvat.co.uk/2009/02/clojure-macros.html</a>
</li>

<li>CS 2101 Parallel Computing with Julia<br />
<a href="https://www.coursehero.com/file/11508091/CS-2101-Parallel-Computing-with-Julia/">https://www.coursehero.com/file/11508091/CS-2101-Parallel-Computing-with-Julia/</a>
</li>

<li>Julia By Example<br />
<a href="https://samuelcolvin.github.io/JuliaByExample/">https://samuelcolvin.github.io/JuliaByExample/</a>
</li>

<li>Array Programming<br />
<a href="https://en.wikipedia.org/wiki/Array_programming">https://en.wikipedia.org/wiki/Array_programming</a>
</li>

<li>Discovering Array Languages<br />
<a href="http://archive.vector.org.uk/art10008110">http://archive.vector.org.uk/art10008110</a>
</li>

<li>no stinking loops -- Kalothi<br />
<a href="http://www.nsl.com/">http://www.nsl.com/</a>
</li>

<li>Vector (obsahuje odkazy na články, knihy a blogy o programovacích jazycích APL, J a K)<br />
<a href="http://www.vector.org.uk/">http://www.vector.org.uk/</a>
</li>

<li>APL Interpreters<br />
<a href="http://www.vector.org.uk/?area=interpreters">http://www.vector.org.uk/?area=interpreters</a>
</li>

<li>APL_(programming_language<br />
<a href="http://en.wikipedia.org/wiki/APL_(programming_language">http://en.wikipedia.org/wiki/APL_(programming_language</a>
</li>

<li>APL FAQ<br />
<a href="http://www.faqs.org/faqs/apl-faq/">http://www.faqs.org/faqs/apl-faq/</a>
</li>

<li>APL FAQ (nejnovější verze)<br />
<a href="http://home.earthlink.net/~swsirlin/apl.faq.html">http://home.earthlink.net/~swsirlin/apl.faq.html</a>
</li>

<li>A+<br />
<a href="http://www.aplusdev.org/">http://www.aplusdev.org/</a>
</li>

<li>APLX<br />
<a href="http://www.microapl.co.uk/">http://www.microapl.co.uk/</a>
</li>

<li>FreeAPL<br />
<a href="http://www.pyr.fi/apl/index.htm">http://www.pyr.fi/apl/index.htm</a>
</li>

<li>J: a modern, high-level, general-purpose, high-performance programming language<br />
<a href="http://www.jsoftware.com/">http://www.jsoftware.com/</a>
</li>

<li>K, Kdb: an APL derivative for Solaris, Linux, Windows<br />
<a href="http://www.kx.com">http://www.kx.com</a>
</li>

<li>openAPL (GPL)<br />
<a href="http://sourceforge.net/projects/openapl">http://sourceforge.net/projects/openapl</a>
</li>

<li>Parrot APL (GPL)<br />
<a href="http://www.parrotcode.org/">http://www.parrotcode.org/</a>
</li>

<li>Learning J (Roger Stokes)<br />
<a href="http://www.jsoftware.com/help/learning/contents.htm">http://www.jsoftware.com/help/learning/contents.htm</a>
</li>

<li>Rosetta Code<br />
<a href="http://rosettacode.org/wiki/Main_Page">http://rosettacode.org/wiki/Main_Page</a>
</li>

<li>Why APL<br />
<a href="http://www.acm.org/sigapl/whyapl.htm">http://www.acm.org/sigapl/whyapl.htm</a>
</li>

<li>Introducing Julia/Functions<br />
<a href="https://en.wikibooks.org/wiki/Introducing_Julia/Functions">https://en.wikibooks.org/wiki/Introducing_Julia/Functions</a>
</li>

<li>Functions (Julia documentation)<br />
<a href="https://docs.julialang.org/en/v1/manual/functions/">https://docs.julialang.org/en/v1/manual/functions/</a>
</li>

<li>Evaluate binomial coefficients<br />
<a href="http://rosettacode.org/wiki/Evaluate_binomial_coefficients">http://rosettacode.org/wiki/Evaluate_binomial_coefficients</a>
</li>

<li>Ackermann function<br />
<a href="http://rosettacode.org/wiki/Ackermann_function">http://rosettacode.org/wiki/Ackermann_function</a>
</li>

<li>Julia (front page)<br />
<a href="http://julialang.org/">http://julialang.org/</a>
</li>

<li>Julia &ndash; dokumentace<br />
<a href="http://docs.julialang.org/">http://docs.julialang.org/</a>
</li>

<li>Julia &ndash; repositář na GitHubu<br />
<a href="https://github.com/JuliaLang/julia">https://github.com/JuliaLang/julia</a>
</li>

<li>Julia (programming language)<br />
<a href="https://en.wikipedia.org/wiki/Julia_%28programming_language%29">https://en.wikipedia.org/wiki/Julia_%28programming_language%29</a>
</li>

<li>IJulia<br />
<a href="https://github.com/JuliaLang/IJulia.jl">https://github.com/JuliaLang/IJulia.jl</a>
</li>

<li>Introducing Julia<br />
<a href="https://en.wikibooks.org/wiki/Introducing_Julia">https://en.wikibooks.org/wiki/Introducing_Julia</a>
</li>

<li>Julia: the REPL<br />
<a href="https://en.wikibooks.org/wiki/Introducing_Julia/The_REPL">https://en.wikibooks.org/wiki/Introducing_Julia/The_REPL</a>
</li>

<li>Month of Julia<br />
<a href="https://github.com/DataWookie/MonthOfJulia">https://github.com/DataWookie/MonthOfJulia</a>
</li>

<li>Learn X in Y minutes (where X=Julia)<br />
<a href="https://learnxinyminutes.com/docs/julia/">https://learnxinyminutes.com/docs/julia/</a>
</li>

<li>New Julia language seeks to be the C for scientists<br />
<a href="http://www.infoworld.com/article/2616709/application-development/new-julia-language-seeks-to-be-the-c-for-scientists.html">http://www.infoworld.com/article/2616709/application-development/new-julia-language-seeks-to-be-the-c-for-scientists.html</a>
</li>

<li>Julia: A Fast Dynamic Language for Technical Computing<br />
<a href="http://karpinski.org/publications/2012/julia-a-fast-dynamic-language">http://karpinski.org/publications/2012/julia-a-fast-dynamic-language</a>
</li>

<li>The LLVM Compiler Infrastructure<br />
<a href="http://llvm.org/">http://llvm.org/</a>
</li>

<li>Julia: benchmarks<br />
<a href="http://julialang.org/benchmarks/">http://julialang.org/benchmarks/</a>
</li>

<li>Type system<br />
<a href="https://en.wikipedia.org/wiki/Type_system">https://en.wikipedia.org/wiki/Type_system</a>
</li>

<li>Half-precision floating-point format<br />
<a href="https://en.wikipedia.org/wiki/Half-precision_floating-point_format">https://en.wikipedia.org/wiki/Half-precision_floating-point_format</a>
</li>

<li>Dartmouth BASIC<br />
<a href="https://en.wikipedia.org/wiki/Dartmouth_BASIC">https://en.wikipedia.org/wiki/Dartmouth_BASIC</a>
</li>

<li>BASIC 4th Edition<br />
<a href="http://www.bitsavers.org/pdf/dartmouth/BASIC_4th_Edition_Jan68.pdf">http://www.bitsavers.org/pdf/dartmouth/BASIC_4th_Edition_Jan68.pdf</a>
</li>

<li>VECTRAN<br />
<a href="https://encyclopedia2.thefreedictionary.com/VECTRAN">https://encyclopedia2.thefreedictionary.com/VECTRAN</a>
</li>

<li>Comparison of programming languages (array)<br />
<a href="https://en.wikipedia.org/wiki/Comparison_of_programming_languages_(array)">https://en.wikipedia.org/wiki/Comparison_of_programming_languages_(array)</a>
</li>

<li>BASIC at 50<br />
<a href="https://www.dartmouth.edu/basicfifty/commands.html">https://www.dartmouth.edu/basicfifty/commands.html</a>
</li>

<li>BBC Basic - arrays<br />
<a href="http://www.riscos.com/support/developers/bbcbasic/part2/arrays.html">http://www.riscos.com/support/developers/bbcbasic/part2/arrays.html</a>
</li>

<li>Datová struktura<br />
<a href="https://cs.wikipedia.org/wiki/Datov%C3%A1_struktura">https://cs.wikipedia.org/wiki/Datov%C3%A1_struktura</a>
</li>

</ol>



<p></p><p></p>
<p><small>Autor: <a href="http://www.fit.vutbr.cz/~tisnovpa">Pavel Tišnovský</a> &nbsp; 2021</small></p>
</body>
</html>

