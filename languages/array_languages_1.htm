<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
        "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html>
<head>
<title>Jazyky umožňující operace s poli aneb rozsáhlý svět &bdquo;array programmingu&ldquo;</title>
<meta name="Author" content="Pavel Tisnovsky" />
<meta name="Generator" content="vim" />
<meta http-equiv="content-type" content="text/html; charset=utf-8" />
<style type="text/css">
         body {color:#000000; background:#ffffff;}
         h1  {font-family: arial, helvetica, sans-serif; color:#ffffff; background-color:#c00000; text-align:center; padding-left:1em}
         h2  {font-family: arial, helvetica, sans-serif; color:#ffffff; background-color:#0000c0; padding-left:1em; text-align:left}
         h3  {font-family: arial, helvetica, sans-serif; color:#000000; background-color:#c0c0c0; padding-left:1em; text-align:left}
         h4  {font-family: arial, helvetica, sans-serif; color:#000000; background-color:#e0e0e0; padding-left:1em; text-align:left}
         a   {font-family: arial, helvetica, sans-serif;}
         li  {font-family: arial, helvetica, sans-serif; color:#000000; text-align:justify; width:450px;}
         ol  {font-family: arial, helvetica, sans-serif; color:#000000; text-align:justify; width:450px;}
         ul  {font-family: arial, helvetica, sans-serif; color:#000000; text-align:justify; width:450px;}
         p   {font-family: arial, helvetica, sans-serif; color:#000000; text-align:justify;}
         pre {background:#e0e0e0}
</style>
</head>

<body>

<h1>Jazyky umožňující operace s poli aneb rozsáhlý svět &bdquo;array programmingu&ldquo;</h1>

<h3>Pavel Tišnovský</h3>

<p></p>

<h1>Úvodník</h1>

<p>Dnes navštívíme rozsáhlý svět jazyků navržených a optimalizovaných pro manipulaci s poli. Taktéž si vysvětlíme, co si vlastně máme pod pojmem &bdquo;pole&ldquo; představit &ndash; to totiž ani zdaleka není tak zřejmý termín, jak by se mohlo zdát.</p>



<h2>Obsah</h2>

<p><a href="#k01">1. Jazyky umožňující operace s&nbsp;poli aneb rozsáhlý svět &bdquo;array programmingu&ldquo;</a></p>
<p><a href="#k02">2. Podpora n-rozměrných polí v&nbsp;programovacích jazycích a knihovnách</a></p>
<p><a href="#k03">3. Jenže ... co si vlastně představit pod jménem <strong>pole</strong>?</a></p>
<p><a href="#k04">4. Rozdílný přístup k&nbsp;práci s&nbsp;poli v&nbsp;různých programovacích jazycích</a></p>
<p><a href="#k05">5. Optimalizace operací s&nbsp;poli, paralelní výpočty a zpracování signálů</a></p>
<p><a href="#k06">6. Příklady rozdílných přístupů programovacích jazyků při práci s&nbsp;poli</a></p>
<p><a href="#k07">7. Vektory a matice v&nbsp;Dartmouth BASICu popř.&nbsp;v&nbsp;BBS BASICu</a></p>
<p><a href="#k08">8. Pole v&nbsp;programovacím jazyce Julia</a></p>
<p><a href="#k09">9. Vícerozměrná pole, sloupcové a řádkové vektory</a></p>
<p><a href="#k10">10. Změna tvaru pole funkcí <strong>reshape</strong></a></p>
<p><a href="#k11">11. Jeden z&nbsp;důsledků typového systému jazyka Julia a měnitelnosti polí</a></p>
<p><a href="#k12">12. N-rozměrná pole v&nbsp;LISPovské rodině programovacích jazyků</a></p>
<p><a href="#k13">13. Knihovna <strong>core.matrix</strong></a></p>
<p><a href="#k14">14. Projekt Incanter</a></p>
<p><a href="#k15">15. Infixová notace řešená přes makrosystém jazyka Clojure</a></p>
<p><a href="#k16">16. Broadcasting</a></p>
<p><a href="#k17">17. Vektory v&nbsp;programovacím jazyku Kawa</a></p>
<p><a href="#k18">18. N-rozměrná pole (ND-Array) v&nbsp;jazyku Kawa</a></p>
<p><a href="#k19">19. Obsah navazujícího článku</a></p>
<p><a href="#k20">20. Odkazy na Internetu</a></p>



<p><a name="k01"></a></p>
<h2 id="k01">1. Jazyky umožňující operace s&nbsp;poli aneb rozsáhlý svět &bdquo;array programmingu&ldquo;</h2>

<p>V&nbsp;dnešním článku se začneme zabývat jednou poměrně rozsáhlou a současně
i poněkud specifickou oblastí v&nbsp;informatice. Tou je zpracování vektorů,
matic a taktéž vícerozměrných polí &ndash; obecně se v&nbsp;tomto kontextu
mluví o n-rozměrných polích. S&nbsp;těmito velmi užitečnými datovými
strukturami se můžeme setkat v&nbsp;různých (mnohdy zdánlivě i velmi
vzdálených) disciplínách, například ve finančnictví, pojišťovnictví,
statistice, zpracování numerických dat, simulacích, zpracování 1D a 2D signálů
atd. Zapomenout ovšem nesmíme ani na strojové učení (<i>machine learning</i>) a
umělou inteligencí (<i>artifical intelligence</i>), protože například datové
struktury určené pro uložení neuronových sítí (zejména konvolučních sítí) jsou
realizovány n-rozměrnými poli. Současně se jedná i o velmi zajímavou oblast,
neboť právě kvůli nutnosti co nejrychlejší práce s&nbsp;velkými maticemi byly
vytvořeny speciální výpočetní bloky v&nbsp;některých superpočítačích (příkladem
mohou být superpočítače <i>Cray</i>) a došlo tak k&nbsp;důležitému podnětu pro
další rozvoj výpočetní techniky (ten nepřímo vedl k&nbsp;vývoji moderních GPU).
A pokud zůstaneme u 1D a 2D polí &ndash; zde došlo k&nbsp;rozšíření digitálních
signálových procesorů orientovaných a optimalizovaných právě na tuto
oblast.</p>

<p>Operace s&nbsp;poli jsou buď součástí syntaxe a sémantiky programovacích
jazyků nebo jsou realizovány formou knihovny. Současné knihovny určené pro
práci s&nbsp;n-rozměrnými poli dokážou v&nbsp;případě potřeby využít jak
některé rozšíření instrukčních sad (SIMD instrukce typu SSE neboli Streaming
SIMD Extensions, původně též MMX či 3DNow!), tak i v&nbsp;některých případech
programovatelné grafické akcelerátory (GPU). SIMD instrukcemi jsme se již na
stránkách Roota zabývali v&nbsp;samostatných článcích, zejména pak v&nbsp;této
trojici článků:</p>

<ol>

<li>SIMD instrukce využívané v&nbsp;moderních mikroprocesorech řady x86<br />
<a href="https://www.root.cz/clanky/simd-instrukce-vyuzivane-v-modernich-mikroprocesorech-rady-x86/">https://www.root.cz/clanky/simd-instrukce-vyuzivane-v-modernich-mikroprocesorech-rady-x86/</a>
</li>

<li>SIMD instrukce v&nbsp;moderních mikroprocesorech řady x86 (2.část: SSE)<br />
<a href="https://www.root.cz/clanky/simd-instrukce-v-modernich-mikroprocesorech-rady-x86-2-cast-sse/">https://www.root.cz/clanky/simd-instrukce-v-modernich-mikroprocesorech-rady-x86-2-cast-sse/</a>
</li>

<li>SIMD instrukce v&nbsp;moderních mikroprocesorech řady x86 (3.část: SSE2)<br />
<a href="https://www.root.cz/clanky/simd-instrukce-v-modernich-mikroprocesorech-rady-x86-3-cast-sse2/">https://www.root.cz/clanky/simd-instrukce-v-modernich-mikroprocesorech-rady-x86-3-cast-sse2/</a>
</li>

</ol>



<p><a name="k02"></a></p>
<h2 id="k02">2. Podpora n-rozměrných polí v&nbsp;programovacích jazycích a knihovnách</h2>

<p>Zmiňme se nyní o některých programovacích jazycích, v&nbsp;nichž manipulace
s&nbsp;poli tvoří nedílnou součást takového jazyka (a určuje tak i oblast,
v&nbsp;níž se daný programovací jazyk používá). Práce s&nbsp;vektory a maticemi
byla (a samozřejmě doposud je) podporována zejména v&nbsp;překladačích
FORTRANu, které začaly být po vzniku superpočítačů vybaveny specializovanými
algoritmy. Tyto algoritmy dokázaly převést některé typy programových smyček na
&bdquo;vektorové operace&ldquo; (což ve skutečnosti byly operace aplikované na
&bdquo;konvoj&ldquo; prvků v&nbsp;hluboké pipeline). Paralelně k&nbsp;různým
rozšířením FORTRANu ovšem vznikly i specializované jazyky určené téměř výhradně
pro práci s&nbsp;vektory i maticemi. Velmi dobrým příkladem jsou programovací
jazyky <i>APL</i> a <i>J</i>. I těmito neobvyklými (ale stále používanými!)
programovacími jazyky jsme se na stránkách Rootu již zabývali, a to
v&nbsp;následujících článcích:</p>

<ol>

<li>Programování mainframů: jazyk APL<br />
<a href="https://www.root.cz/clanky/programovani-mainframu-jazyk-apl/">https://www.root.cz/clanky/programovani-mainframu-jazyk-apl/</a>
</li>

<li>Programovací jazyk APL: programování bez smyček<br />
<a href="https://www.root.cz/clanky/programovaci-jazyk-apl-programovani-bez-smycek/">https://www.root.cz/clanky/programovaci-jazyk-apl-programovani-bez-smycek/</a>
</li>

<li>Programovací jazyk APL - dokončení<br />
<a href="https://www.root.cz/clanky/programovaci-jazyk-apl-dokonceni/">https://www.root.cz/clanky/programovaci-jazyk-apl-dokonceni/</a>
</li>

<li>Programovací jazyk J – od hieroglyfů k ASCII znakům<br />
<a href="https://www.root.cz/clanky/programovaci-jazyk-j-ndash-od-hieroglyfu-k-nbsp-ascii-znakum/">https://www.root.cz/clanky/programovaci-jazyk-j-ndash-od-hieroglyfu-k-nbsp-ascii-znakum/</a>
</li>

<li>Programujeme v jazyku J: vektory a matice<br />
<a href="https://www.root.cz/clanky/programujeme-v-jazyku-j-ndash-vektory-a-matice/">https://www.root.cz/clanky/programujeme-v-jazyku-j-ndash-vektory-a-matice/</a>
</li>

<li>Programovací jazyk J: operátory, uživatelské funkce a tacit programming<br />
<a href="https://www.root.cz/clanky/programovaci-jazyk-j-operatory-uzivatelske-funkce-a-tacit-programming/">https://www.root.cz/clanky/programovaci-jazyk-j-operatory-uzivatelske-funkce-a-tacit-programming/</a>
</li>

<li>Oslava 55 let od vzniku první implementace jazyka APL<br />
<a href="https://www.root.cz/clanky/oslava-55-let-od-vzniku-prvni-implementace-programovaciho-jazyka-apl/">https://www.root.cz/clanky/oslava-55-let-od-vzniku-prvni-implementace-programovaciho-jazyka-apl/</a>
</li>

</ol>

<p>Velmi dobrou podporu pro práci s&nbsp;maticemi ovšem nabízí i framework <a
href="https://www.root.cz/serialy/torch-framework-pro-strojove-uceni/">Torch</a>
založený na programovacím jazyku Lua, s&nbsp;vektory a maticemi lze pracovat
v&nbsp;<a
href="https://www.root.cz/serialy/programovaci-jazyk-julia/">programovacím
jazyku Julia</a> a zapomenout nesmíme ani na knihovnu <a
href="https://www.numpy.org/">Numpy</a>. Ta je určená pro programovací jazyk
Python. Opět uvedu odkazy na články, v&nbsp;níž se touto populární a velmi
často používanou knihovnou zabýváme do větší hloubky, než to umožňuje rozsah
dnešního článku:</p>

<ol>

<li>Zpracování vektorů, matic a N-rozměrných polí v&nbsp;programovacím jazyku Kawa<br />
<a href="https://www.root.cz/clanky/zpracovani-vektoru-matic-a-n-rozmernych-poli-v-programovacim-jazyku-kawa/">https://www.root.cz/clanky/zpracovani-vektoru-matic-a-n-rozmernych-poli-v-programovacim-jazyku-kawa/</a>
</li>

<li>Rust: knihovna ndarray pro práci s&nbsp;n-rozměrnými poli<br />
<a href="https://www.root.cz/clanky/rust-knihovna-ndarray-pro-praci-s-n-rozmernymi-poli/">https://www.root.cz/clanky/rust-knihovna-ndarray-pro-praci-s-n-rozmernymi-poli/</a>
</li>

<li>Programovací jazyk Clojure a knihovny pro práci s&nbsp;vektory a maticemi<br />
<a href="https://www.root.cz/clanky/programovaci-jazyk-clojure-a-knihovny-pro-praci-s-vektory-a-maticemi/">https://www.root.cz/clanky/programovaci-jazyk-clojure-a-knihovny-pro-praci-s-vektory-a-maticemi/</a>
</li>

<li>Programovací jazyk Clojure a knihovny pro práci s vektory a maticemi (2)<br />
<a href="https://www.root.cz/clanky/programovaci-jazyk-clojure-a-knihovny-pro-praci-s-vektory-a-maticemi-2/">https://www.root.cz/clanky/programovaci-jazyk-clojure-a-knihovny-pro-praci-s-vektory-a-maticemi-2/</a>
</li>

<li>Gophernotes: kombinace interaktivního prostředí Jupyteru s jazykem Go<br />
<a href="https://www.root.cz/clanky/gophernotes-kombinace-interaktivniho-prostredi-jupyteru-s-jazykem-go/">https://www.root.cz/clanky/gophernotes-kombinace-interaktivniho-prostredi-jupyteru-s-jazykem-go/</a>
</li>

<li>Popis vybraných balíčků nabízených projektem Gonum<br />
<a href="https://www.root.cz/clanky/popis-vybranych-balicku-nabizenych-projektem-gonum/">https://www.root.cz/clanky/popis-vybranych-balicku-nabizenych-projektem-gonum/</a>
</li>

<li>Integrovaná vývojová prostředí ve Fedoře: vykreslování grafů s využitím knihoven Numpy a matplotlib<br />
<a href="https://mojefedora.cz/integrovana-vyvojova-prostredi-ve-fedore-vykreslovani-grafu-s-vyuzitim-knihoven-numpy-a-matplotlib/">https://mojefedora.cz/integrovana-vyvojova-prostredi-ve-fedore-vykreslovani-grafu-s-vyuzitim-knihoven-numpy-a-matplotlib/</a>
</li>

<li>Integrovaná vývojová prostředí ve Fedoře: praktické použití IPython Notebooku a knihovny Numpy (2.část)<br />
<a href="https://mojefedora.cz/integrovana-vyvojova-prostredi-ve-fedore-prakticke-pouziti-ipython-notebooku-a-knihovny-numpy-2-cast/">https://mojefedora.cz/integrovana-vyvojova-prostredi-ve-fedore-prakticke-pouziti-ipython-notebooku-a-knihovny-numpy-2-cast/</a>
</li>

<li>Integrovaná vývojová prostředí ve Fedoře: praktické použití IPython Notebooku a knihovny Numpy<br />
<a href="https://mojefedora.cz/integrovana-vyvojova-prostredi-ve-fedore-prakticke-pouziti-ipython-notebooku-a-knihovny-numpy/">https://mojefedora.cz/integrovana-vyvojova-prostredi-ve-fedore-prakticke-pouziti-ipython-notebooku-a-knihovny-numpy/</a>
</li>

</ol>



<p><a name="k03"></a></p>
<h2 id="k03">3. Jenže ... co si vlastně představit pod jménem <strong>pole</strong>?</h2>

<p>V&nbsp;programovacích jazycích se termín &bdquo;pole&ldquo;
resp.&nbsp;<i>array</i> používá velmi často, ovšem ani zdaleka ne konzistentně.
V&nbsp;případě, že se v&nbsp;dokumentaci jazyka bez dalších podrobností termín
<i>array</i> použije, je vhodné hledat odpovědi na následující otázky:</p>

<ol>

<li>Kolik dimenzí může pole mít? Typicky 1 a 2, někdy i více.</li>

<li>Začínají indexy prvků od 0, 1 či je první index volitelný?</li>

<li>Jsou podporována obdélníková pole nebo nepravidelná pole?</li>

<li>Jsou jednotlivé osy na sobě nezávislé? (což vylučuje nepravidelná
pole)</li>

<li>Je možné indexy na jednotlivých osách pojmenovat? (a vytvořit tak vlastně
datový rámec)</li>

<li>Jedná se o homogenní nebo o heterogenní datovou strukturu? Homogenní
struktura může uchovávat prvky jediného (typicky předem definovaného) typu
zatímco v&nbsp;heterogenní struktuře mohou být umístěny prvky různých
typů.</li>

<li>Je nějakým způsobem omezen datový typ prvků pole? (například jen na celá
čísla a čísla reálná).</li>

<li>Lze prvky pole měnit (<i>mutable</i>) nebo je pole neměnitelné
(<i>immutable</i>).</li>

<li>Pokud jsou pole heterogenní a měnitelná, může prvek pole obsahovat to samé
pole?</li>

<li>Obsahuje pole přímo hodnoty prvků nebo jen reference na prvky?</li>

<li>Jsou prvky v&nbsp;poli uloženy v&nbsp;operační paměti za sebou nebo se
jedná o strukturu s&nbsp;ukazateli?</li>

<li>Jsou prvky v&nbsp;2D poli uloženy po řádcích nebo po sloupcích? (C versus
Fortran).</li>

<li>Lze měnit tvar (<i>shape</i>) pole?</li>

<li>Podporuje jazyk operace nad celými poli?</li>

<li>Podporuje jazyk takzvaný <i>broadcasting</i> (aplikaci skaláru na všechny
prvky pole atd.)?</li>

<li>Jsou pole plnohodnotným datovým typem nebo speciální strukturou?</li>

<li>Je podporován &bdquo;literál typu pole&ldquo;?</li>

</ol>



<p><a name="k04"></a></p>
<h2 id="k04">4. Rozdílný přístup k&nbsp;práci s&nbsp;poli v&nbsp;různých programovacích jazycích</h2>

<p>Různé programovací jazyky přistupují k&nbsp;implementaci polí rozdílným
způsobem. Některé jazyky mají striktně omezen počet dimenzí na jednorozměrná
pole a dvourozměrné matice. Mezi takové jazyky patří například osmibitové
BASICy. Dále je možné pole reprezentovat jako jedinou souvislou oblast paměti
(APL) s&nbsp;oddělenými metainformacemi o tvaru pole (<i>shape</i>); další
jazyky reprezentují vícerozměrná pole jako pole polí (Java). U jazyků, kde jsou
pole uložena v&nbsp;jediném souvislém bloku taktéž záleží na tom, zda je
uložení provedeno po řádcích nebo po sloupcích (což je nejviditelnější na
dvourozměrných polích). Zajímavým důsledkem oddělení metainformací o tvaru pole
od prvků je možnost existence operace pro změnu tvaru pole, tj.&nbsp;například
pro konverzi vektoru s&nbsp;24 prvky na pole s&nbsp;2&times;3&times;4 prvky
atd. Poměrně velký rozdíl taktéž spočívá v&nbsp;tom, zda jsou pole homogenní či
heterogenní. A pochopitelně samostatný problém představuje uložení pole do
prvku sebe sama (což musí být detekováno a řešeno v&nbsp;runtime jazyka).</p>



<p><a name="k05"></a></p>
<h2 id="k05">5. Optimalizace operací s&nbsp;poli, paralelní výpočty a zpracování signálů</h2>

<p>V&nbsp;oblasti numerických simulací, což byl jeden z&nbsp;prvních úkolů, na
které byly programovatelné počítače nasazeny, se často provádí operace
s&nbsp;vektory a maticemi. Ostatně právě pro tento typ úkolů byl navržen
programovací jazyk FORTRAN. A po vzniku superpočítačů začaly být překladače
FORTRANu vybavovány algoritmy, které dokázaly převést některé typy programových
smyček souvisejících s&nbsp;vektorovými a maticovými operacemi na
&bdquo;vektorové operace&ldquo;. Paralelně vznikly i specializované jazyky
určené téměř výhradně pro práci s&nbsp;vektory i maticemi &ndash; příkladem je
již zmíněná dvojice <i>APL</i> a <i>J</i>. Touto problematikou (kde
superpočítače předběhly dobu) se budeme podrobněji zabývat příště.</p>

<p>Operace s&nbsp;poli, přesněji řečeno většinou s&nbsp;jednorozměrnými vektory
a maticemi, souvisí i se zpracováním signálů, což je oblast, pro kterou byly
vyvinuty specializované čipy &ndash; DSP. První typy digitálních signálových
procesorů, tj.&nbsp;DSP umístěných na jediném čipu, vznikly až na přelomu
sedmdesátých a osmdesátých let minulého století, ovšem o zpracování číslicových
signálů v&nbsp;reálném čase se inženýři a posléze i programátoři pokoušeli již
dříve. První úspěšné a dá se říci i reálně použitelné systémy vznikly již na
minipočítačích na počátku sedmdesátých let minulého století, ovšem vzhledem
k&nbsp;poměrně vysoké ceně minipočítačů, jejich velikosti i spotřebě (nenechme
se zmýlit předponou mini-, ta vyjadřovala cenu, velikost a výkonnost
minipočítačů vzhledem k&nbsp;mainframům :-) byla oblast jejich nasazení omezená
pouze na ty technologické provozy, kde nebyla k&nbsp;dispozici dostatečně
robustní alternativa. Pokud nebylo možné minipočítače použít, používaly se buď
signálové procesory sestavené z&nbsp;více čipů, nebo se namísto zpracování
číslicových signálů používala mnohem starší, a nutno říci, že v&nbsp;dané době
i propracovanější technologie &ndash; analogové počítače, které ovšem pracují
na zcela jiném principu, než programovatelné číslicové počítače.</p>

<p>DSP byly optimalizovány na dvě operace &ndash; násobení (tj.&nbsp;obsahovaly
rychlou násobičku) a na přístup k&nbsp;prvkům vektorů, což zasahuje do oblasti,
které se věnujeme dnes. Efektivní adresace prvků vektorů umožnila například
realizovat operaci konvoluce, korelace, výpočet FFT atd. Těmito specifickými
oblastmi se budeme zabývat později.</p>



<p><a name="k06"></a></p>
<h2 id="k06">6. Příklady rozdílných přístupů programovacích jazyků při práci s&nbsp;poli</h2>

<p>Na <a href="#k03">třetí kapitolu</a>, v&nbsp;níž jsme se zmínili o různých
významech pojmu <i>array</i>, nyní navážeme, protože si ukážeme, jak
s&nbsp;poli (ať již tento název konkrétně znamená cokoli) pracují různé
programovací jazyky. Začneme původním <a href="#k07">Dartmouth BASICem</a> a na
něj navazujícím BBC BASICem, v&nbsp;němž je podpora pro práci s&nbsp;poli až
překvapivě dobrá. Zapomenout pochopitelně nemůžeme na <a
href="#k08">programovací jazyk Julia</a>, který s&nbsp;poli pracuje odlišným
způsobem (což je zapříčiněno mj.&nbsp;i typovým systémem tohoto jazyka). A ve
<a href="#k12">druhé polovině článku</a> si ukážeme práci s&nbsp;poli
v&nbsp;LISPovských programovacích jazycích.</p>

<p><div class="rs-tip-major">Poznámka: na &bdquo;klasické&ldquo; jazyky
z&nbsp;této oblasti ovšem nezapomeneme. Příště si porovnáme především FORTRAN,
VectorPascal, R, APL, jazyk J a jazyk BQN (což je mix APL a J, v&nbsp;němž je
většina problémů původního APL opravena).</div></p>



<p><a name="k07"></a></p>
<h2 id="k07">7. Vektory a matice v&nbsp;Dartmouth BASICu popř.&nbsp;v&nbsp;BBS BASICu</h2>

<p>Podpora pro manipulace s&nbsp;maticemi (tedy s&nbsp;dvourozměrnými poli) se
objevila v&nbsp;Dartmouth BASICu, což je prapředek všech ostatních variant
programovacího jazyka BASIC. Ovšem v&nbsp;dalších BASICech, zejména v&nbsp;těch
určených pro osmibitové domácí mikropočítače, práci s&nbsp;maticemi nenalezneme
&ndash; a kupodivu ji nenalezneme ani v&nbsp;moderních BASICech (což ukazuje na
neznalost historie :-). Podívejme se na základní podporu pro práci
s&nbsp;maticemi v&nbsp;Darthmouth BASICu. Tento jazyk umožňuje zapsat maticové
operace s&nbsp;využitím prefixu <strong>MAT</strong>, tedy následujícím
způsobem:</p>

<pre>
DIM A(4),B(4),C(4)
MAT A = 1
MAT B = 2 * A
MAT C = A + B
MAT PRINT A,B,C
</pre>

<p><div class="rs-tip-major">Poznámka: &bdquo;skalární&ldquo; operace by se
zapisovaly podobně, akorát by se namísto <strong>MAT</strong> použil příkaz
<strong>LET</strong>.</div></p>

<p>V&nbsp;BBC BASICu jsou do určité míry podporována n-rozměrná pole.
Jednorozměrné vektory se alokují a používají takto. Povšimněte si toho, že
vektor <strong>V</strong> ve skutečnosti obsahuje <i>jedenáct</i> prvků:</p>

<pre>
10 REM
11 REM Alokace vektoru
12 REM
15 DIM V(10)
20 REM
21 REM Naplneni vektoru daty
22 REM
30 FOR I=0 TO 10
40   V(I) = I*1
50 NEXT I
60 REM
61 REM Vypis obsahu vektoru
62 REM
70 FOR I=0 TO 10
80   PRINT I,V(I)
90 NEXT I
</pre>

<p>Výsledek:</p>

<pre>
 0         0
 1         1
 2         2
 3         3
 4         4
 5         5
 6         6
 7         7
 8         8
 9         9
10        10
</pre>

<p>Pravidlo &bdquo;n+1&ldquo; platí i pro dvojrozměrná pole neboli matice.
Zajímavé je, že <strong>DIM</strong> jako příkaz alokuje pole a jako funkce
vrací počet dimenzí (což do určité míry připomíná APL s&nbsp;monadickými a
dyadickými operátory):</p>

<pre>
10 REM
11 REM Alokace pole 4x5 prvku
12 REM
20 DIM A(3,4)
30 PRINT DIM(A())
</pre>

<p>Výsledek získaný po spuštění tohoto příkladu:</p>

<pre>
2
</pre>

<p>Získat lze i velikosti pole v&nbsp;každé dimenzi, tedy <i>rank</i>, a to
voláním funkce <strong>DIM</strong> se dvěma parametry &ndash; polem a indexem
dimenze:</p>

<pre>
10 REM
11 REM Alokace pole 4x5 prvku
12 REM
20 DIM A(3,4)
30 PRINT DIM(A())
40 REM
41 REM Vypis velikosti pole v kazde dimenzi
42 REM
50 FOR D=1 TO DIM(A())
60   PRINT D,DIM(A(),D)
70 NEXT D
</pre>

<p>Výsledek (<i>rank</i> vrací hodnoty 3 a 4):</p>

<pre>
2
1         3
2         4
</pre>

<p>Počet dimenzí ve skutečnosti není omezen na 1 či 2; vytvořit lze například i
trojrozměrné pole:</p>

<pre>
10 REM
11 REM Alokace pole 5x6x7 prvku
12 REM
20 DIM A(4,5,6)
30 PRINT DIM(A())
</pre>

<p><i>rank</i> zjišťovaný pro trojrozměrná pole:</p>

<pre>
10 REM
11 REM Alokace pole 5x6x7 prvku
12 REM
20 DIM A(4,5,6)
30 PRINT DIM(A())
40 REM
41 REM Vypis velikosti pole v kazde dimenzi
42 REM
50 FOR D=1 TO DIM(A())
60   PRINT D,DIM(A(),D)
70 NEXT D
</pre>

<p>Výsledek:</p>

<pre>
 3
 1         4
 2         5
 3         6
</pre>

<p>Kupodivu není podporován tisk celého pole, takže si musíme pomoci dvojicí
programových smyček (v&nbsp;případě trojrozměrného pole pak trojicí vnořených
programových smyček):</p>

<pre>
10 REM
11 REM Alokace pole 4x5 prvku
12 REM
20 DIM A(3,4)
30 PRINT DIM(A())
40 REM
41 REM Naplneni prvku pole
42 REM
50 FOR J=0 TO DIM(A(),2)
51   FOR I=0 TO DIM(A(),1)
52     A(I,J) = I*J
53   NEXT I
54 NEXT J
60 REM
61 REM Vypis obsahu pole
62 REM
70 FOR J=0 TO DIM(A(),2)
71   FOR I=0 TO DIM(A(),1)
72     PRINT A(I,J);
73   NEXT I
74   PRINT
75 NEXT J
</pre>

<p>Výsledek:</p>

<pre>
2
0         0         0         0
0         1         2         3
0         2         4         6
0         3         6         9
0         4         8        12
</pre>

<p>BBC Basic podporuje i operace nad celými poli, což je pro zdánlivě
primitivní jazyk neobvyklé. Jednotlivé podporované operace jsou vypsány
v&nbsp;následující dvojici tabulek. V&nbsp;první tabulce jsou binární
operátory, jejichž levým parametrem je pole:</p>

<table>
<tr><th>Levý operand</th><th>Operátor</th><th>Pravý operand</th><th>Stručný popis</th></tr>
<tr><td>pole  </td><td>+</td><td>pole  </td><td>součet prvek po prvku</td></tr>
<tr><td>pole  </td><td>-</td><td>pole  </td><td>rozdíl prvek po prvku</td></tr>
<tr><td>pole  </td><td>*</td><td>pole  </td><td>součin prvek po prvku</td></tr>
<tr><td>pole  </td><td>/</td><td>pole  </td><td>podíl prvek po prvku</td></tr>
<tr><td>pole  </td><td>+</td><td>skalár</td><td>přičtení skaláru ke všem prvkům pole</td></tr>
<tr><td>skalár</td><td>+</td><td>pole  </td><td>přičtení skaláru ke všem prvkům pole</td></tr>
<tr><td>pole  </td><td>-</td><td>skalár</td><td>odečtení skaláru ke všem prvkům pole</td></tr>
<tr><td>skalár</td><td>-</td><td>pole  </td><td>odečtení skaláru od všech prvků pole</td></tr>
<tr><td>pole  </td><td>*</td><td>skalár</td><td>vynásobení všech prvků pole konstantou</td></tr>
<tr><td>skalár</td><td>*</td><td>pole  </td><td>vynásobení všech prvků pole konstantou</td></tr>
<tr><td>pole  </td><td>/</td><td>skalár</td><td>vydělení všech prvků pole konstantou</td></tr>
<tr><td>skalár</td><td>/</td><td>pole  </td><td>výpočet skalár/prvek</td></tr>
<tr><td>pole  </td><td>.</td><td>pole  </td><td>maticový součin</td></tr>
</table>

<p>V&nbsp;tabulce druhé jsou vypsány operátory zkombinované
s&nbsp;přiřazením:</p>

<table>
<tr><th>Levá strana</th><th>Operátor</th><th>Pravá strana</th><th>Stručný popis</th></tr>
<tr><td>pole</td><td>=</td><td>pole</td><td>kopie celého pole</td></tr>
<tr><td>pole</td><td>=</td><td>skalár</td><td>nastavení všech prvků pole na zadanou hodnotu</td></tr>
<tr><td>pole</td><td>=</td><td>-pole</td><td>speciální případ, kopie celého pole s&nbsp;otočením znaménka všech prvků</td></tr>
<tr><td>pole</td><td>+=</td><td>skalár/pole</td><td>zkrácený zápis pole = pole + skalár/pole</td></tr>
<tr><td>pole</td><td>-=</td><td>skalár/pole</td><td>zkrácený zápis pole = pole - skalár/pole</td></tr>
</table>

<p>Můžeme vidět, že některé operace bychom skutečně u
&bdquo;jednoduchého&ldquo; BASICu nečekali.</p>

<p>Ukázka operace pole = pole + skalár:</p>

<pre>
10 REM
11 REM Alokace pole 4x5 prvku
12 REM
20 DIM A(3,4)
30 PRINT DIM(A())
40 REM
41 REM Naplneni prvku pole
42 REM
50 FOR J=0 TO DIM(A(),2)
51   FOR I=0 TO DIM(A(),1)
52     A(I,J) = I*J
53   NEXT I
54 NEXT J
60 REM
61 REM Operace s celym polem
62 REM
65 <strong>A() = A() + 1</strong>
70 REM
71 REM Vypis obsahu pole
72 REM
80 FOR J=0 TO DIM(A(),2)
81   FOR I=0 TO DIM(A(),1)
82     PRINT A(I,J);
83   NEXT I
84   PRINT
85 NEXT J
</pre>

<p>Výsledek:</p>

<pre>
2
1         1         1         1
1         2         3         4
1         3         5         7
1         4         7        10
1         5         9        13
</pre>

<p>Ukázka operace pole += skalár:</p>

<pre>
10 REM
11 REM Alokace pole 4x5 prvku
12 REM
20 DIM A(3,4)
30 PRINT DIM(A())
40 REM
41 REM Naplneni prvku pole
42 REM
50 FOR J=0 TO DIM(A(),2)
51   FOR I=0 TO DIM(A(),1)
52     A(I,J) = I*J
53   NEXT I
54 NEXT J
60 REM
61 REM Operace s celym polem
62 REM
65 <strong>A() += 1</strong>
70 REM
71 REM Vypis obsahu pole
72 REM
80 FOR J=0 TO DIM(A(),2)
81   FOR I=0 TO DIM(A(),1)
82     PRINT A(I,J);
83   NEXT I
84   PRINT
85 NEXT J
</pre>

<p>Výsledek:</p>

<pre>
2
1         1         1         1
1         2         3         4
1         3         5         7
1         4         7        10
1         5         9        13
</pre>

<p>Vynásobení odpovídajících si prvků pole:</p>

<pre>
10 REM
11 REM Alokace pole 4x5 prvku
12 REM
20 DIM A(3,4)
30 PRINT DIM(A())
40 REM
41 REM Naplneni prvku pole
42 REM
50 FOR J=0 TO DIM(A(),2)
51   FOR I=0 TO DIM(A(),1)
52     A(I,J) = I*J
53   NEXT I
54 NEXT J
60 REM
61 REM Operace s celym polem - nasobeni prvek po prvku
62 REM
65 <strong>A() *= A()</strong>
70 REM
71 REM Vypis obsahu pole
72 REM
80 FOR J=0 TO DIM(A(),2)
81   FOR I=0 TO DIM(A(),1)
82     PRINT A(I,J);
83   NEXT I
84   PRINT
85 NEXT J
</pre>

<p>Výsledek:</p>

<pre>
2
0         0         0         0
0         1         4         9
0         4        16        36
0         9        36        81
0        16        64       144
</pre>

<p>A konečně nejdelší příklad &ndash; maticový součin:</p>

<pre>
10 REM
11 REM Alokace prvniho pole 5x2 prvku
12 REM
20 DIM A(4,1)
21 PRINT DIM(A())
30 REM
31 REM Naplneni prvku pole
32 REM
40 FOR J=0 TO DIM(A(),2)
41   FOR I=0 TO DIM(A(),1)
42     A(I,J) = I*J
43   NEXT I
44 NEXT J
50 REM
51 REM Alokace druheho pole 2x6 prvku
52 REM
60 DIM B(1,5)
61 PRINT DIM(B())
70 REM
71 REM Naplneni prvku pole
72 REM
80 FOR J=0 TO DIM(B(),2)
81   FOR I=0 TO DIM(B(),1)
82     B(I,J) = I*J
83   NEXT I
84 NEXT J
90 REM
92 REM Maticovy soucin
92 REM
90 DIM C(4,5)
91 <strong>C() = A().B()</strong>
92 REM
93 REM Vypis obsahu pole
94 REM
95 FOR J=0 TO DIM(C(),2)
96   FOR I=0 TO DIM(C(),1)
97     PRINT C(I,J);
98   NEXT I
99   PRINT
100 NEXT J
</pre>

<p>Výsledek:</p>

<pre>
 2
 2
 0         0         0         0         0
 0         1         2         3         4
 0         2         4         6         8
 0         3         6         9        12
 0         4         8        12        16
 0         5        10        15        20
</pre>



<p><a name="k08"></a></p>
<h2 id="k08">8. Pole v&nbsp;programovacím jazyce Julia</h2>

<p>Dalším jazykem, který práci s&nbsp;vícerozměrnými poli podporuje na velmi
dobré úrovni (i když s&nbsp;několika problematickými rysy), je programovací
jazyk Julia. Základní <i>homogenní</i> datovou strukturou, kterou programovací
jazyk Julia svým uživatelům nabízí, jsou jednorozměrná pole. Všechny prvky pole
mají stejný typ (ostatně právě proto je to homogenní datová struktura a nikoli
struktura heterogenní) a ke každému prvku je možné přistupovat přes jeho index,
přičemž indexování prvků má konstantní složitost (nezáleží tedy na délce pole).
Prvky v&nbsp;běžných jednorozměrných polích je možné modifikovat, takže pole
jsou v&nbsp;jazyku Julia měnitelnými datovými strukturami (<i>mutable</i>).
Podívejme se nyní na způsob vytvoření jednorozměrných polí v&nbsp;tomto
programovacím jazyce:</p>

<pre>
julia&gt; <strong>a=[1, 2, 3, 4, 5]</strong>
5-element Array{Int64,1}:
 1
 2
 3
 4
 5
</pre>

<p>Při konstrukci pole se automaticky může zjistit datový typ prvků
(resp.&nbsp;typ, který všem prvkům odpovídá po případné konverzi). Povšimněte
si, jak se jazyk rozhoduje, který typ použít ve chvíli, kdy budeme chtít do
pole uložit tři prvky různého typu:</p>

<pre>
julia&gt; <strong>a=[1, 2.1, 1//3]</strong>
3-element Array{Float64,1}:
 1.0
 2.1
 0.333333
&nbsp;
julia&gt; <strong>a=[1, 2, 1//3]</strong>
3-element Array{Rational{Int64},1}:
 1//1
 2//1
 1//3
&nbsp;
julia&gt; <strong>a=[1/0, -1/0, 0/0]</strong>
3-element Array{Float64,1}:
  Inf
 -Inf
  NaN
&nbsp;
julia&gt; <strong>a=[pi, pi]</strong>
2-element Array{Irrational{:π},1}:
 π = 3.1415926535897...
 π = 3.1415926535897...
</pre>

<p>Typ je ovšem v&nbsp;případě potřeby možné specifikovat explicitně:</p>

<pre>
julia&gt; <strong>Int8[1, 2, 3, 4, 5]</strong>
5-element Array{Int8,1}:
 1
 2
 3
 4
 5
&nbsp;
julia&gt; <strong>Float16[1, 2, 3, 4, 5]</strong>
5-element Array{Float16,1}:
 1.0
 2.0
 3.0
 4.0
 5.0
</pre>

<p>V&nbsp;případě, že vynecháte čárky, vytvoří se ve skutečnosti dvourozměrné
pole s&nbsp;jedním řádkem:</p>

<pre>
julia&gt; <strong>a=[1 2 3 4 5]</strong>
1x5 Array{Int64,2}:
 1  2  3  4  5
&nbsp;
julia&gt; <strong>Float16[1 2 3 4 5]</strong>
1x5 Array{Float16,2}:
 1.0  2.0  3.0  4.0  5.0
&nbsp;
julia&gt; <strong>a=[1 2 3 4]</strong>
1x4 Array{Int64,2}:
 1  2  3  4
</pre>



<p><a name="k09"></a></p>
<h2 id="k09">9. Vícerozměrná pole, sloupcové a řádkové vektory</h2>

<p><a href="#k08">V&nbsp;předchozí kapitole</a> jsme si ukázali způsob tvorby
jednorozměrných polí v&nbsp;programovacím jazyku Julia. Jak se však vytváří
dvourozměrná pole? První pokus, který může vycházet ze zkušeností z&nbsp;jiných
programovacích jazyků (například z&nbsp;Pythonu), nebude příliš úspěšný:</p>

<pre>
julia&gt; <strong>[[1,2,3], [4,5,6]]</strong>
WARNING: [a,b] concatenation is deprecated; use [a;b] instead
 in depwarn at deprecated.jl:73
 in oldstyle_vcat_warning at ./abstractarray.jl:29
 in vect at abstractarray.jl:32
while loading no file, in expression starting on line 0
6-element Array{Int64,1}:
 1
 2
 3
 4
 5
 6
</pre>

<p>Problém v&nbsp;předchozím zápisu představovala čárka vložená mezi oba
vektory. Jedno z&nbsp;možných řešení může vypadat takto &ndash; vytvoříme
vlastně pole složené ze dvou sloupců (povšimněte si chybějící čárky mezi
vektory):</p>

<pre>
julia&gt; <strong>[[1,2,3] [4,5,6]]</strong>
3x2 Array{Int64,2}:
 1  4
 2  5
 3  6
</pre>

<p>V&nbsp;případě, že preferujete zápis po řádcích, lze použít tento
alternativní způsob se středníkem. Je to sice poněkud neobvyklé, ale středník
zde nahrazuje volání funkce <strong>hvcat()</strong> zmíněné níže:</p>

<pre>
julia&gt; <strong>a=[1 2; 3 4]</strong>
2x2 Array{Int64,2}:
 1  2
 3  4
</pre>

<p>Pole se dvěma řádky a třemi sloupci se tedy vytvoří následovně:</p>

<pre>
julia&gt; <strong>[1 2 3 ; 3 4 5]</strong>
2x3 Array{Int64,2}:
 1  2  3
 3  4  5
</pre>

<p>Kromě zápisu prvků pole do hranatých závorek lze pro konstrukci použít i
funkce <strong>hcat</strong> (což znamená &bdquo;horizontal
concatenate&ldquo;), <strong>vcat</strong> (&bdquo;vertical concatenate&ldquo;)
a <strong>hvcat</strong> (kombinace obou možností se specifikací počtu
sloupců):</p>

<pre>
julia&gt; <strong>hcat(1,2,3,4)</strong>
1x4 Array{Int64,2}:
 1  2  3  4
</pre>

<pre>
julia&gt; <strong>vcat(1,2,3,4)</strong>
4-element Array{Int64,1}:
 1
 2
 3
 4
</pre>

<p>U funkce <strong>hvcat()</strong> si povšimněte, že první parametr
specifikuje počet sloupců a až po něm následují jednotlivé prvky, což může být
poněkud matoucí:</p>

<pre>
julia&gt; <strong>hvcat(2,1,2,3,4)</strong>
2x2 Array{Int64,2}:
 1  2
 3  4
</pre>

<p>Jednosloupcové pole:</p>

<pre>
julia&gt; <strong>hvcat(1,1,2,3,4)</strong>
4x1 Array{Int64,2}:
 1
 2
 3
 4
</pre>

<p>Čtyřsloupcové pole (s&nbsp;jedním řádkem):</p>

<pre>
julia&gt; <strong>hvcat(4,1,2,3,4)</strong>
1x4 Array{Int64,2}:
 1  2  3  4
</pre>

<p>Pro vytvoření pole s&nbsp;udáním typu prvků (ovšem bez inicializace
jednotlivých prvků) slouží konstruktor nazvaný jednoduše
<strong>Array</strong>. Při volání tohoto konstruktoru se nejprve ve složených
závorkách specifikuje typ prvků a již běžně v&nbsp;kulatých závorkách pak
rozměry pole v&nbsp;jednotlivých dimenzích:</p>

<pre>
help?&gt; <strong>Array</strong>
search: Array SubArray BitArray DenseArray StridedArray mmap_array
&nbsp;
  Array(dims)
&nbsp;
  Array{T}(dims) constructs an uninitialized dense array with element type T.
  dims may be a tuple or a series of integer arguments. The syntax Array(T,
  dims) is also available, but deprecated.
</pre>

<p>Konstrukce pole o rozměrech 2&times;2 prvky typu Int8 (osmibitové celé číslo
se znaménkem) se provede takto:</p>

<pre>
julia&gt; <strong>a=Array{Int8}(2,2)</strong>
2x2 Array{Int8,2}:
 112  -26
  82  -34
</pre>

<p>Zkusme nyní změnit hodnotu prvku v&nbsp;poli 10&times;10 prvků:</p>

<pre>
julia&gt; <strong>a[0,0]=42</strong>
&nbsp;
ERROR: LoadError: BoundsError: attempt to access 2×2 Array{Int8,2} at index [0, 0]
Stacktrace:
 [1] setindex!(::Array{Int8,2}, ::Int64, ::Int64, ::Int64) at ./array.jl:550
while loading /home/cg/root/5386118/main.jl, in expression starting on line 3
</pre>

<p>Vidíme, že se tato operace nepodařila, a to z&nbsp;toho důvodu, že se prvky
indexují od jedničky a nikoli od nuly. To se sice může zdát poněkud neobvyklé,
ovšem ve skutečnosti mnoho jazyků (dovolím si dokonce říci, že většina jazyků
NEodvozených od céčka) zvolilo stejný přístup: Fortran, Mathematica, R, MATLAB,
Lua atd. Správně tedy má příkaz vypadat takto:</p>

<pre>
julia&gt; <strong>a[1,1]=42</strong>
42
</pre>

<p>Prvek pole se skutečně změnil:</p>

<pre>
julia&gt; <strong>a</strong>
10x10 Array{Float16,2}:
 42.0  0.0  0.0  0.0  0.0  0.0  0.0  0.0  0.0  0.0
  0.0  0.0  0.0  0.0  0.0  0.0  0.0  0.0  0.0  0.0
  0.0  0.0  0.0  0.0  0.0  0.0  0.0  0.0  0.0  0.0
  0.0  0.0  0.0  0.0  0.0  0.0  0.0  0.0  0.0  0.0
  0.0  0.0  0.0  0.0  0.0  0.0  0.0  0.0  0.0  0.0
  0.0  0.0  0.0  0.0  0.0  0.0  0.0  0.0  0.0  0.0
  0.0  0.0  0.0  0.0  0.0  0.0  0.0  0.0  0.0  0.0
  0.0  0.0  0.0  0.0  0.0  0.0  0.0  0.0  0.0  0.0
  0.0  0.0  0.0  0.0  0.0  0.0  0.0  0.0  0.0  0.0
  0.0  0.0  0.0  0.0  0.0  0.0  0.0  0.0  0.0  0.0
</pre>

<p>Podívejme se nyní na složitější indexování, tentokrát vektoru:</p>

<pre>
julia&gt; <strong>v=[1 2 3 4 10 -1]</strong>
1x6 Array{Int64,2}:
 1  2  3  4  10  -1
</pre>

<p>Přístup k&nbsp;prvnímu prvku:</p>

<pre>
julia&gt; <strong>v[1]</strong>
1
</pre>

<p>Přístup k&nbsp;prvkům 2 až 4:</p>

<pre>
julia&gt; <strong>v[2:4]</strong>
3-element Array{Int64,1}:
 2
 3
 4
</pre>

<p>Přístup ke všem prvkům vektoru:</p>

<pre>
julia&gt; <strong>v[:]</strong>
6-element Array{Int64,1}:
  1
  2
  3
  4
 10
 -1
</pre>

<p>Pokud potřebujeme přistoupit k&nbsp;poslednímu prvku, není možné použít
index -1 (to lze v&nbsp;jiných jazycích), ale používá se zde slovo
<strong>end</strong>.  To opět není nijak unikátní, podobně se toto slovo
používá i v&nbsp;MATLABu:</p>

<pre>
julia&gt; <strong>v[end]</strong>
-1
</pre>

<p>Kombinace předchozích způsobů &ndash; od čtvrtého prvku do konce
vektoru:</p>

<pre>
julia&gt; <strong>v[4:end]</strong>
3-element Array{Int64,1}:
  4
 10
 -1
</pre>

<p>Zajímavý je výběr sekvence libovolných prvků vektoru (pole), a to
s&nbsp;využitím jiného vektoru obsahujícího indexy prvků. Povšimněte si
nutnosti použití dvojitých hranatých závorek &ndash; vnější závorky představují
operaci výběru prvků, vnitřní závorky vektor indexů:</p>

<pre>
julia&gt; <strong>v[[1,5,6,2,5,5]]</strong>
6-element Array{Int64,1}:
  1
 10
 -1
  2
 10
 10
</pre>



<p><a name="k10"></a></p>
<h2 id="k10">10. Změna tvaru pole funkcí <strong>reshape</strong></h2>

<p>Další velmi důležitou funkcí, s&nbsp;níž se v&nbsp;praxi často setkáme, je
funkce nazvaná <strong>reshape()</strong>, která dokáže změnit velikost matice
a vhodným způsobem přeorganizovat prvky v&nbsp;původní matici (převzato
z&nbsp;APL &ndash; jak jinak). Této funkci se předávají dva parametry &ndash;
prvním parametrem je vstupní pole (vektor, matice, ...), druhým parametrem
(popř.&nbsp;více parametry) pak specifikace tvaru výsledného pole. Podívejme se
nejdříve na oficiální popis této funkce:</p>

<pre>
help?&gt; <strong>reshape</strong>
search: reshape promote_shape
&nbsp;
  reshape(A, dims)
&nbsp;
  Create an array with the same data as the given array, but with different
  dimensions. An implementation for a particular type of array may choose
  whether the data is copied or shared.
</pre>

<p>Vytvořme si testovací vektor s&nbsp;dvanácti prvky (což je číslo dělitelné
2, 3, 4 i 6):</p>

<pre>
julia&gt; <strong>a=[1 2 3 4 5 6 7 8 9 10 11 12]</strong>
1x12 Array{Int64,2}:
 1  2  3  4  5  6  7  8  9  10  11  12
</pre>

<p>Z&nbsp;tohoto vektoru pak snadno získáme matice o rozměrech 4&times;3,
3&times;4, 2&times;6, 6&times;2 či 1&times;12:</p>

<pre>
julia&gt; <strong>reshape(a, 4, 3)</strong>
4x3 Array{Int64,2}:
 1  5   9
 2  6  10
 3  7  11
 4  8  12
</pre>

<pre>
julia&gt; <strong>reshape(a, 3, 4)</strong>
3x4 Array{Int64,2}:
 1  4  7  10
 2  5  8  11
 3  6  9  12
</pre>

<pre>
julia&gt; <strong>reshape(a, 2, 6)</strong>
2x6 Array{Int64,2}:
 1  3  5  7   9  11
 2  4  6  8  10  12
</pre>

<pre>
julia&gt; <strong>reshape(a, 6, 2)</strong>
6x2 Array{Int64,2}:
 1   7
 2   8
 3   9
 4  10
 5  11
 6  12
</pre>

<p>Vytvoření trojrozměrných polí je stejně snadné (a opět je nutné zachovat
počet prvků):</p>

<pre>
julia&gt; <strong>reshape(a, 2, 3, 2)</strong>
2x3x2 Array{Int64,3}:
[:, :, 1] =
 1  3  5
 2  4  6
&nbsp;
[:, :, 2] =
 7   9  11
 8  10  12
</pre>



<p><a name="k11"></a></p>
<h2 id="k11">11. Jeden z&nbsp;důsledků typového systému jazyka Julia a měnitelnosti polí</h2>

<p>Víme již, že v&nbsp;jazyku Julia se typ pole odvozuje od prvků, které jsou
do pole přiřazeny. Pole celých čísel se tedy vytvoří a použije takto:</p>

<pre>
<strong>a = [1,2,3]</strong>
<strong>println(a)</strong>
&nbsp;
<strong>a[2] = -1</strong>
<strong>println(a)</strong>
</pre>

<p>Pole je sice homogenním datovým typem, ovšem typový systém jazyka Julia
umožňuje vytvořit pole prvků typu <strong>Any</strong>, což může být další
pole:</p>

<pre>
<strong>a = [1,[],3]</strong>
<strong>println(a)</strong>
-&gt; Any[1, Any[], 3]
&nbsp;
<strong>a[2] = [10,10]</strong>
<strong>println(a)</strong>
-&gt; Any[1, [10, 10], 3]
</pre>

<p>Takže &ndash; pole jsou měnitelné datové struktury a mohou obsahovat prvky
typu <strong>Any</strong>. To ovšem znamená, že prvkem pole může být to samé
pole!</p>

<pre>
<strong>a[2] = a</strong>
<strong>println(a)</strong>
</pre>

<p>S&nbsp;výsledkem:</p>

<pre>
Any[1, Any[#= circular reference @-1 =#], 3]
</pre>

<p>Dtto při přístupu do (nekonečně zanořené) struktury:</p>

<pre>
<strong>println(a[2])</strong>
Any[1, Any[#= circular reference @-1 =#], 3]
</pre>

<p><div class="rs-tip-major">Poznámka: podobné chování lze nalézt například i
v&nbsp;některých verzích APL nebo v&nbsp;Pythonovských seznamech (což ovšem
nejsou plnohodnotná pole).</div></p>



<p><a name="k12"></a></p>
<h2 id="k12">12. N-rozměrná pole v&nbsp;LISPovské rodině programovacích jazyků</h2>

<p>Manipulace s&nbsp;N-rozměrnými poli jsou zdánlivě vyhrazeny pouze
programovacím jazykům odvozeným od FORTRANu. To ovšem ve skutečnosti není
pravda, protože se poměrně často můžeme setkat s&nbsp;mnohdy velmi vyspělými
knihovnami pro práci s&nbsp;těmito datovými typy, které jsou určeny pro
LISPovské programovací jazyky. V&nbsp;dalším textu si ve stručnosti popíšeme
knihovny resp.&nbsp;přesněji řečeno podporu pro práci s&nbsp;n-rozměrnými poli
v&nbsp;jazyku Clojure a taktéž v&nbsp;programovacím jazyku Kawa.</p>

<p>V&nbsp;přednášce nazvané velmi příhodně &bdquo;Enter the Matrix&ldquo;,
která je dostupná na adrese <a
href="http://www.slideshare.net/mikeranderson/2013-1114-enter-thematrix">http://www.slideshare.net/mikeranderson/2013-1114-enter-thematrix</a>,
je mj.&nbsp;ukázáno, jakým způsobem jsou v&nbsp;Clojure implementována různá
paradigmata programování. Díky podpoře maker a způsobu zápisu programového kódu
v&nbsp;Clojure lze velmi snadno implementovat různé doménově specifické jazyky
(DSL), mj.&nbsp;i právě jazyk pro array programming:</p>

<table>
<tr><th>Paradigma</th><th>Jazyk</th><th>Implementace v&nbsp;Clojure</th></tr>
<tr><td>funkcionální</td><td>Haskell</td><td>clojure.core</td></tr>
<tr><td>OOP</td><td>Smalltalk</td><td>clojure.core</td></tr>
<tr><td>metaprogramování</td><td>Lisp</td><td>clojure.core</td></tr>
<tr><td>logické</td><td>Prolog</td><td>core.logic</td></tr>
<tr><td>array programming</td><td>APL, J</td><td>core.matrix</td></tr>
</table>

<p><div class="rs-tip-major">Poznámka: původní tabulka byla upravena a
doplněna.</div></p>



<p><a name="k13"></a></p>
<h2 id="k13">13. Knihovna <strong>core.matrix</strong></h2>

<p>Nejprve se ve stručnosti seznámíme s&nbsp;knihovnou určenou pro práci
s&nbsp;n-dimenzionálními poli v&nbsp;programovacím jazyku Clojure. Konkrétně se
bude jednat o knihovnu nazvanou <strong>core.matrix</strong>. Tato knihovna je
určená těm vývojářům, kteří ve svých projektech potřebují provádět velké
množství operací s&nbsp;maticemi různých dimenzí, a to na poměrně vysoké
úrovni, tj.&nbsp;bez nutnosti přesně specifikovat, jakým způsobem mají být
matice uloženy v&nbsp;paměti, jakým způsobem se má provádět operace násobení
matic atd. Díky tomuto přístupu a taktéž díky vlastnostem programovacího jazyka
<i>Clojure</i> (existence tzv.&nbsp;<i>threading makra</i> a funkcí vyššího
řádu) se práce s&nbsp;maticemi do značné míry začíná podobat práci
v&nbsp;jazyku APL, až na ten rozdíl, že algoritmy zapisované
v&nbsp;<i>Clojure</i> jsou pro většinu vývojářů přece jen čitelnější :-).
Taktéž je důležité, že <i>rozhraní</i> definované v&nbsp;knihovně
<strong>core.matrix</strong> může mít několik implementací. V&nbsp;současnosti
se jedná o implementace poskytované knihovnami <i>vectorz-clj</i>,
<i>Clatrix</i> a <i>NDArray</i>.  V&nbsp;<strong>core.matrix</strong> navíc
došlo k&nbsp;rozšíření operátorů +, - atd. takovým způsobem, že je lze použít i
pro zpracování vektorů a matic (ve skutečnosti se samozřejmě nejedná o skutečné
operátory, protože tento koncept <i>Clojure</i> nepotřebuje).</p>

<p>Příklady vybraných operací s&nbsp;maticemi:</p>

<pre>
matrixtest.core=&gt; <strong>(def M1 (matrix [[1 2][3 4]]))</strong>
#'matrixtest.core/M1
&nbsp;
matrixtest.core=&gt; <strong>(def M2 (matrix [[5 6][7 8]]))</strong>
#'matrixtest.core/M2
&nbsp;
matrixtest.core=&gt; <strong>(pm (+ M1 M2))</strong>
[[ 6.000  8.000]
 [10.000 12.000]]
&nbsp;
matrixtest.core=&gt; <strong>(def v (matrix [1 2 3 4 5 6]))</strong>
#'matrixtest.core/v
&nbsp;
matrixtest.core=&gt; <strong>(def M (matrix [[1 2] [3 4]]))</strong>
#'matrixtest.core/M
&nbsp;
<i>; trojrozměrná matice</i>
matrixtest.core=&gt; <strong>(def MD (matrix [[ [1 2] [3 4] ] [ [5 6] [7 8] ] ]))</strong>
#'matrixtest.core/MD
&nbsp;
matrixtest.core=&gt; <strong>(pm MD)</strong>
[[[1.000 2.000]
  [3.000 4.000]]
 [[5.000 6.000]
  [7.000 8.000]]]
</pre>

<p>Získání informací o matici:</p>

<pre>
matrixtest.core=&gt; <strong>(dimensionality v)</strong>
1
&nbsp;
matrixtest.core=&gt; <strong>(dimensionality M)</strong>
2
&nbsp;
matrixtest.core=&gt; <strong>(dimensionality MD)</strong>
3
&nbsp;
matrixtest.core=&gt; <strong>(dimensionality 1)</strong>
0
&nbsp;
matrixtest.core=&gt; <strong>(shape M)</strong>
[2 2]
&nbsp;
matrixtest.core=&gt; <strong>(shape v)</strong>
[6]
&nbsp;
matrixtest.core=&gt; <strong>(shape MD)</strong>
[2 2 2]
</pre>

<p>Změna tvaru matice:</p>

<pre>
matrixtest.core=&gt; <strong>(def v (matrix [1 2 3 4 5 6]))</strong>
#'matrixtest.core/v
&nbsp;
matrixtest.core=&gt; <strong>v</strong>
[1 2 3 4 5 6]
&nbsp;
<i>; velmi užitečná funkce převzatá z APL: vektor převeden na matici</i>
matrixtest.core=&gt; <strong>(reshape v [2 3])</strong>
[[1 2 3] [4 5 6]]
&nbsp;
matrixtest.core=&gt; <strong>(pm *1)</strong>
[[1.000 2.000 3.000]
 [4.000 5.000 6.000]]
&nbsp;
<i>; jiný tvar matice</i>
matrixtest.core=&gt; <strong>(reshape v [3 2])</strong>
[[1 2] [3 4] [5 6]]
&nbsp;
matrixtest.core=&gt; <strong>(pm *1)</strong>
[[1.000 2.000]
 [3.000 4.000]
 [5.000 6.000]]
&nbsp;
matrixtest.core=&gt; <strong>(reshape v [1 6])</strong>
[[1 2 3 4 5 6]]
&nbsp;
matrixtest.core=&gt; <strong>(pm *1)</strong>
[[1.000 2.000 3.000 4.000 5.000 6.000]]
&nbsp;
matrixtest.core=&gt; <strong>(reshape v [6 1])</strong>
[[1] [2] [3] [4] [5] [6]]
&nbsp;
<i>; sloupec z&nbsp;vektoru</i>
matrixtest.core=&gt; <strong>(pm *1)</strong>
[[1.000]
 [2.000]
 [3.000]
 [4.000]
 [5.000]
 [6.000]]
</pre>



<p><a name="k14"></a></p>
<h2 id="k14">14. Projekt Incanter</h2>

<p>Projekt <i>Incanter</i>, jenž je taktéž určen pro jazyk Clojure, je založen
na zpracování (rozsáhlých) matic a tzv.&nbsp;datasetů. Ve skutečnosti však
klasicky chápané matice v&nbsp;Clojure příliš podporovány nejsou. Při studiu
základních knihoven Clojure lze dojít k&nbsp;závěru, že vlastně jen velmi málo
funkcí a maker je určeno pro práci s&nbsp;těmito datovými typy, i když je
samozřejmě možné jak vektory, tak i matice velmi snadno reprezentovat
s&nbsp;využitím základních sekvenčních datových struktur Clojure &ndash;
seznamů a vektorů. Ve skutečnosti to však není zcela ideální řešení, a to hned
z&nbsp;několika důvodů, jejichž společným rysem je rychlost prováděných
operací. Z&nbsp;tohoto důvodu je v&nbsp;případě implementace algoritmů,
v&nbsp;nichž se intenzivně používají operace s&nbsp;maticemi, mnohem výhodnější
využít možností specializovaných knihoven. Projektem <i>Incanter</i> je proto
interně používána knihovna <strong>core.matrix</strong>, která byla ve
stručnosti představena v&nbsp;předchozí kapitole.</p>

<p><div class="rs-tip-major">Poznámka: nesmíme taktéž zapomenout na způsob
reprezentace datových struktur v&nbsp;operační paměti. Matice jsou většinou
homogenní datovou strukturou, kterou lze v&nbsp;případě, že prvky jsou
primitivního datového typu, uložit v&nbsp;kompaktní podobě. U obecných vektorů
a sekvencí jazyka Clojure tomu tak však není. Problematikou uložené polí
primitivních typů na haldě v&nbsp;JVM jsme se zabývali v&nbsp;článku <a
href="https://www.root.cz/clanky/pohled-pod-kapotu-jvm-jak-efektivne-jsou-ulozena-pole-a-retezce-na-halde/">Pohled
pod kapotu JVM - jak efektivně jsou uložena pole a řetězce na haldě?</a> (viz
například šestou kapitolu).</div></p>



<p><a name="k15"></a></p>
<h2 id="k15">15. Infixová notace řešená přes makrosystém jazyka Clojure</h2>

<p><i>Incanter</i> je sice knihovna (resp.&nbsp;skupina knihoven) určená pro
programovací jazyk Clojure, který je založen na lispovské syntaxi volání
funkcí, ovšem díky existenci makra <strong>$=</strong> je možné výrazy
zapisovat i v&nbsp;infixové podobě, a to včetně správného vyhodnocení priorit
operátorů. Podívejme se na několik příkladů.</p>

<p>Základní aritmetické operátory s&nbsp;vyhodnocením priorit:</p>

<pre>
incanter.irepl=&gt; <strong>($= 1 + 2)</strong>
3
&nbsp;
incanter.irepl=&gt; <strong>($= 1 + 2 * 3)</strong>
7
</pre>

<p>Zpracovat lze dokonce i vektory a matice (operátory jsou přetížené):</p>

<pre>
incanter.irepl=&gt; <strong>($= [1 2 3] + [4 5 6])</strong>
[5 7 9]
&nbsp;
incanter.irepl=&gt; <strong>($= [1 2 3] * [4 5 6])</strong>
[4 10 18]
&nbsp;
incanter.irepl=&gt; <strong>($= [[1 2][3 4]] + [[5 6][7 8]])</strong>
[[6 8] [10 12]]
</pre>

<p>Využití <i>broadcastingu</i> zmíněného v&nbsp;další kapitole:</p>

<pre>
incanter.irepl=&gt; <strong>($= [1 2 3] + 10)</strong>
[11 12 13]
&nbsp;
incanter.irepl=&gt; <strong>($= [1 2 3] * -1)</strong>
[-1 -2 -3]
</pre>



<p><a name="k16"></a></p>
<h2 id="k16">16. Broadcasting</h2>

<p>Podívejme se nyní na některé základní operace s&nbsp;maticemi, zejména na
takzvaný <i>broadcasting</i>:</p>

<pre>
incanter.irepl=&gt; <strong>(def A (matrix [[1 2 3]</strong>
            #_=&gt;                 <strong>[4 5 6]</strong>
            #_=&gt;                 <strong>[7 8 9]]))</strong>
#'incanter.irepl/A
</pre>

<p>Broadcasting umožňuje převést číslo (přesněji řečeno skalár) na matici
stejného řádu, jakou má druhý operand:</p>

<pre>
incanter.irepl=&gt; <strong>($= A + 2)</strong>
#vectorz/matrix [[3.0,4.0,5.0],
[6.0,7.0,8.0],
[9.0,10.0,11.0]]
</pre>

<p>Vynásobení matice konstantou (skalárem):</p>

<pre>
incanter.irepl=&gt; <strong>($= A * -1)</strong>
#vectorz/matrix [[-1.0,-2.0,-3.0],
[-4.0,-5.0,-6.0],
[-7.0,-8.0,-9.0]]
</pre>

<p>Vynásobení matice a vektoru, který byl opět rozšířen na matici:</p>

<pre>
incanter.irepl=&gt; <strong>($= A * [5 0 5])</strong>
#vectorz/matrix [[5.0,0.0,15.0],
[20.0,0.0,30.0],
[35.0,0.0,45.0]]
</pre>

<p>Skutečný &bdquo;maticový&ldquo; součin matice a vektoru:</p>

<pre>
incanter.irepl=&gt; <strong>(mmult A [5 0 0])</strong>
#vectorz/vector [5.0,20.0,35.0]
</pre>

<p>Matici můžeme transponovat:</p>

<pre>
incanter.irepl=&gt; <strong>(trans A)</strong>
#vectorz/matrix [[1.0,4.0,7.0],
[2.0,5.0,8.0],
[3.0,6.0,9.0]]
</pre>

<p>Můžeme provést vynásobení původní matice s&nbsp;maticí transponovanou:</p>

<pre>
incanter.irepl=&gt; <strong>(mmult A (trans A))</strong>
#vectorz/matrix [[14.0,32.0,50.0],
[32.0,77.0,122.0],
[50.0,122.0,194.0]]
</pre>

<p>Další složitější varianta:</p>

<pre>
incanter.irepl=&gt; <strong>(mmult A (trans A) A)</strong>
#vectorz/matrix [[492.0,588.0,684.0],
[1194.0,1425.0,1656.0],
[1896.0,2262.0,2628.0]]
</pre>



<p><a name="k17"></a></p>
<h2 id="k17">17. Vektory v&nbsp;programovacím jazyku Kawa</h2>

<p>Dalším LISPovským jazykem je <i>Kawa</i> určená pro běh ve virtuálním stroji
Javy. Klasická javovská pole podporovaná v&nbsp;programovacím jazyku
<i>Kawa</i> přináší několik výhod, ale pochopitelně i nevýhod. Samotná pole
mají pevnou délku a jejich prvky jsou vždy stejného typu (homogenita). Tato
vlastnost (což je výhoda a nevýhoda současně) umožňuje velmi efektivní přístup
k&nbsp;prvkům pole, který má u jednorozměrných polí konstantní složitost.
Současně jsme však omezeni například tím, že do javovských polí není možné
jednoduše ukládat zlomky, celá čísla s&nbsp;libovolným rozsahem atd.
V&nbsp;případě, že budeme potřebovat využít i tuto funkcionalitu, je nutné
namísto polí použít odlišné datové typy programovacího jazyka <i>Kawa</i>. Může
se jednat o <i>vektory</i> podporované v&nbsp;mnoha implementacích LISPu i
Scheme (a taktéž v&nbsp;jazyku Clojure, i když zde mají vektory zcela odlišné
vnitřní uspořádání) nebo o typ pojmenovaný pro větší zmatek v&nbsp;terminologii
<i>array</i>.</p>

<p>V&nbsp;této kapitole si ve stručnosti ukážeme práci s&nbsp;takzvanými
vektory. Podporovány jsou tyto funkce:</p>

<table>
<tr><th>#</th><th>Funkce</th><th>Stručný popis funkce</th></tr>
<tr><td>1</td><td>vector</td><td>konstrukce vektoru a inicializace jeho prvků</td></tr>
<tr><td>2</td><td>vector-ref</td><td>přístup k&nbsp;prvku vektoru</td></tr>
<tr><td>3</td><td>vector-set!</td><td>změna hodnoty prvku vektoru</td></tr>
<tr><td>4</td><td>vector?</td><td>predikát: dotaz, zda je předaná hodnota typu vektor či nikoli</td></tr>
<tr><td>5</td><td>vector-length</td><td>vrací délku vektoru, tedy počet jeho prvků</td></tr>
<tr><td>6</td><td>vector-&gt;list</td><td>převod vektoru na seznam</td></tr>
<tr><td>7</td><td>list-&gt;vector</td><td>opačný převod</td></tr>
</table>

<p>Vektor je možné zkonstruovat speciálním &bdquo;konstruktorem&ldquo;,
v&nbsp;němž se jednotlivé prvky vektoru zapisují do hranatých závorek (což již
známe z&nbsp;programovacího jazyka Clojure). K&nbsp;prvkům vektoru se
přistupuje funkcí <strong>vector-ref</strong>:</p>

<pre>
(define vector1 <strong>[1 2 3 4]</strong>)
&nbsp;
(display vector1)
(newline)
&nbsp;
(display (<strong>vector-ref</strong> vector1 0))
(display (<strong>vector-ref</strong> vector1 10))
</pre>

<p>Výsledek:</p>

<pre>
#(1 2 3 4)
java.lang.ArrayIndexOutOfBoundsException: 10
        at gnu.lists.FVector.get(FVector.java:105)
        at kawa.lib.vectors.vectorRef(vectors.scm:21)
        at Vectors1.run(Vectors1.scm:7)
        at gnu.expr.ModuleExp.evalModule2(ModuleExp.java:289)
        at gnu.expr.CompiledModule.evalModule(CompiledModule.java:42)
        at gnu.expr.CompiledModule.evalModule(CompiledModule.java:60)
        at kawa.Shell.runFile(Shell.java:565)
        at kawa.Shell.runFileOrClass(Shell.java:468)
        at kawa.repl.processArgs(repl.java:700)
        at kawa.repl.main(repl.java:820)
</pre>

<p><div class="rs-tip-major">Poznámka: chyba nastala při přístupu k&nbsp;prvku
s&nbsp;indexem 10, který ve čtyřprvkovém vektoru pochopitelně
neexistuje.</div></p>

<p>Vektory lze ovšem taktéž zapsat stylem <strong>#()</strong>, který je
kompatibilní s&nbsp;R7RS:</p>

<pre>
#|kawa:1|# <strong>#(1 2 3)</strong>
#(1 2 3)
&nbsp;
#|kawa:2|# <strong>[1 2 3]</strong>
#(1 2 3)
&nbsp;
#|kawa:3|# <strong>(eq? #(1 2 3) [1 2 3])</strong>
#f
&nbsp;
#|kawa:4|# <strong>(equal? #(1 2 3) [1 2 3])</strong>
#t
</pre>

<p>V&nbsp;dalším demonstračním příkladu je namísto zápisu prvků vektoru do
hranatých závorek použit konstruktor představovaný funkcí nazvanou jednoduše
<strong>vector</strong>. Taktéž je zde ukázána změna hodnoty vybraného prvku
s&nbsp;využitím funkce <strong>vector-set!</strong> (tato funkce opět obsahuje
ve svém jménu vykřičník, protože mění stav aplikace):</p>

<pre>
(define vector2 (<strong>vector 1 2 3 4 5</strong>))
&nbsp;
(display vector2)
(newline)
&nbsp;
(display (<strong>vector-ref</strong> vector2 0))
(newline)
&nbsp;
(<strong>vector-set!</strong> vector2 2 -1)
&nbsp;
(display vector2)
(newline)
</pre>

<p>Výsledek:</p>

<pre>
#(1 2 3 4 5)
1
#(1 2 -1 4 5)
</pre>

<p>Dotazy, zda je daná hodnota vektorem či nikoli, používají predikát
<strong>vector?</strong> (všechny predikáty končí otazníkem):</p>

<pre>
#|kawa:25|# <strong>(vector? "A")</strong>
#f
&nbsp;
#|kawa:26|# <strong>(vector? [1 2 3])</strong>
#t
&nbsp;
#|kawa:27|# <strong>(vector? '(1 2 3))</strong>
#f
</pre>

<p>Další funkce je určena pro získání velikosti vektoru, tedy počtu jeho
prvků:</p>

<pre>
#|kawa:28|# <strong>(vector-length [1 2 3])</strong>
3
&nbsp;
#|kawa:29|# <strong>(vector-length [])</strong>
0
</pre>



<p><a name="k18"></a></p>
<h2 id="k18">18. N-rozměrná pole (ND-Array) v&nbsp;jazyku Kawa</h2>

<p>V&nbsp;této kapitole se ve stručnost seznámíme s&nbsp;možnostmi typu
<i>array</i>, což je v&nbsp;jazyce <i>Kawa</i> datový typ představující
N-rozměrná pole (neboli nosné téma dnešního článku). Kromě toho si ukážeme i
práci s&nbsp;takzvanými &bdquo;rozsahy&ldquo; (<i>range</i>), které do značné
míry s&nbsp;poli souvisí.</p>

<p>Datový typ <i>array</i> se používá nejenom v&nbsp;jazyce <i>Kawa</i>, ale
například i v&nbsp;programovacím jazyce <i>Racket</i> (jedná se pravděpodobně o
nejrozsáhlejší a nejúplnější implementaci Scheme vůbec). Samotné pole se skládá
ze dvou částí: hodnot jednotlivých prvků a tvaru pole neboli <i>shape</i>. Tvar
pole je důležitou strukturou, protože (nepřímo) určuje, jakým způsobem jsou
prvky v&nbsp;poli uspořádány. To však není vše, protože je možné jednoduše tvar
pole změnit a tím pádem prvky zdánlivě zpřeházet (interně se ovšem
v&nbsp;operační paměti s&nbsp;prvky v&nbsp;některých případech manipulovat
nemusí). Další důležitou vlastností datového typu <i>array</i> je možnost
uložit do pole libovolné hodnoty; jedná se tedy o <i>heterogenní kontejner</i>,
na rozdíl od běžných javovských polí.</p>

<p>Ke konstrukci N-rozměrného pole slouží funkce nazvaná
<strong>make-array</strong>. Této funkci se předává vektor obsahující velikosti
(rozsah indexů) N-rozměrného pole ve všech dimenzích. Počet prvků tohoto
vektoru tedy odpovídá počtu dimenzí. Dále je možné této funkci předat i hodnoty
jednotlivých prvků, což si ukážeme v&nbsp;dalším textu. Funkci
<strong>make-array</strong> si můžeme velmi snadno otestovat přímo
v&nbsp;interaktivní smyčce REPL programovacího jazyka Kawa.</p>

<p>Mezním případem je prázdné pole:</p>

<pre>
#|kawa:3|# <strong>(make-array [0])</strong>
&nbsp;
#()
</pre>

<p>Konstrukce jednoprvkového jednorozměrné pole vypadá takto:</p>

<pre>
#|kawa:8|# <strong>(make-array [1])</strong>
&nbsp;
#(#!null)
</pre>

<p><div class="rs-tip-major">Poznámka: povšimněte si, jaká je výchozí hodnota
jediného prvku vytvořeného pole.</div></p>

<p>Desetiprvkový vektor, jehož všechny prvky mají výchozí hodnotu:</p>

<pre>
#|kawa:5|# <strong>(make-array [10])</strong>
&nbsp;
#(#!null #!null #!null #!null #!null #!null #!null #!null #!null #!null)
</pre>

<p>Konstrukce matice typu 1&times;1, tedy matice s&nbsp;jediným prvkem, který
má výchozí hodnotu:</p>

<pre>
#|kawa:9|# <strong>(make-array [1 1])</strong>
&nbsp;
╔#2a:1:1
║#!null║
╚══════╝
</pre>

<p>Konstrukce matice s&nbsp;jedním řádkem a dvěma sloupci:</p>

<pre>
#|kawa:7|# <strong>(make-array [1 2])</strong>
&nbsp;
╔#2a:1:2══════╗
║#!null│#!null║
╚══════╧══════╝
</pre>

<p><div class="rs-tip-major">Poznámka: povšimněte si, jakým způsobem interpret
programovacího jazyka <i>Kawa</i> zobrazuje obsah zkonstruovaného pole. U
jednorozměrných polí je výsledek zobrazen formou připomínající běžný seznam
nebo vektor, ale u dvourozměrných polí zobrazuje tabulku s&nbsp;obsahem
jednotlivých prvků, přičemž je na prvním řádku upřesněn jak počet dimenzí, tak
i rozsah indexů v&nbsp;jednotlivých dimenzích (zde konkrétně počet řádků
oddělený od počtu sloupců dvojtečkou).</div></p>

<p>Pokračujme s&nbsp;nepatrně složitější maticí, konkrétně s&nbsp;maticí se
dvěma řádky a třemi sloupci:</p>

<pre>
#|kawa:10|# <strong>(make-array [2 3])</strong>
&nbsp;
╔#2a:2:3══════╤══════╗
║#!null│#!null│#!null║
╟──────┼──────┼──────╢
║#!null│#!null│#!null║
╚══════╧══════╧══════╝
</pre>

<p>Trojrozměrná struktura 2&times;3&times;4 prvky:</p>

<pre>
#|kawa:11|# <strong>(make-array [2 3 4])</strong>
&nbsp;
╔#3a:2:3:4════╤══════╤══════╗
║#!null│#!null│#!null│#!null║
╟──────┼──────┼──────┼──────╢
║#!null│#!null│#!null│#!null║
╟──────┼──────┼──────┼──────╢
║#!null│#!null│#!null│#!null║
╠══════╪══════╪══════╪══════╣
║#!null│#!null│#!null│#!null║
╟──────┼──────┼──────┼──────╢
║#!null│#!null│#!null│#!null║
╟──────┼──────┼──────┼──────╢
║#!null│#!null│#!null│#!null║
╚══════╧══════╧══════╧══════╝
</pre>

<p><div class="rs-tip-major">Poznámka: u trojrozměrné a taktéž u vícerozměrných
struktur je již nutné použít oddělovač jednotlivých 2D podmatic tak, jak je to
ukázáno na předchozím výstupu z&nbsp;interpretru programovacího jazyka
<i>Kawa</i>. Podrobnější informace najdete na stránce <a
href="https://www.gnu.org/software/guile/manual/html_node/Array-Syntax.html">https://www.gnu.org/software/guile/manual/html_node/Array-Syntax.html</a>.</div></p>

<p>Taktéž trojrozměrná struktura, ovšem tentokrát s&nbsp;tvarem
4&times;3&times;2 prvky:</p>

<pre>
#|kawa:12|# <strong>(make-array [4 3 2])</strong>
&nbsp;
╔#3a:4:3:2════╗
║#!null│#!null║
╟──────┼──────╢
║#!null│#!null║
╟──────┼──────╢
║#!null│#!null║
╠══════╪══════╣
║#!null│#!null║
╟──────┼──────╢
║#!null│#!null║
╟──────┼──────╢
║#!null│#!null║
╠══════╪══════╣
║#!null│#!null║
╟──────┼──────╢
║#!null│#!null║
╟──────┼──────╢
║#!null│#!null║
╠══════╪══════╣
║#!null│#!null║
╟──────┼──────╢
║#!null│#!null║
╟──────┼──────╢
║#!null│#!null║
╚══════╧══════╝
</pre>

<p>Čtyřrozměrné pole:</p>

<pre>
#|kawa:7|# <strong>(make-array [2 2 2 2])</strong>
&nbsp;
╔#4a:2:2:2:2══╗
║#!null│#!null║
╟──────┼──────╢
║#!null│#!null║
╠══════╪══════╣
║#!null│#!null║
╟──────┼──────╢
║#!null│#!null║
╠══════╪══════╣
║#!null│#!null║
╟──────┼──────╢
║#!null│#!null║
╠══════╪══════╣
║#!null│#!null║
╟──────┼──────╢
║#!null│#!null║
╚══════╧══════╝
</pre>

<p>Pole, které má v&nbsp;jedné dimenzi nulovou velikost a celkově tedy nula
prvků:</p>

<pre>
#|kawa:11|# <strong>(make-array [0 2 2 2])</strong>
&nbsp;
#4a:0:2:2:2 ()
</pre>

<p>Funkci <strong>make-arrray</strong>, s&nbsp;jejím základním použitím jsme se
seznámili v&nbsp;předchozím textu, je možné předat i hodnoty jednotlivých prvků
vytvářeného pole. Pokud je počet zadaných hodnot menší než počet prvků, budou
se prvky opakovat tak dlouho, až se pole postupně vyplní. Samozřejmě se opět
podíváme na příklady.</p>

<p>Vektor obsahující stejné hodnoty ve všech prvcích:</p>

<pre>
#|kawa:13|# <strong>(make-array [10] 1/2)</strong>
&nbsp;
#(1/2 1/2 1/2 1/2 1/2 1/2 1/2 1/2 1/2 1/2)
</pre>

<p>Dvourozměrné pole (matice) se dvěma řádky a čtyřmi sloupci:</p>

<pre>
#|kawa:1|# <strong>(make-array [2 4] 1 2 3 4 5)</strong>
&nbsp;
╔#2a:2:4╗
║1│2│3│4║
╟─┼─┼─┼─╢
║5│1│2│3║
╚═╧═╧═╧═╝
</pre>

<p>Pole 5&times;5 prvků se shodnými řádky:</p>

<pre>
#|kawa:14|# <strong>(make-array [5 5] 1 2 3 4 5)</strong>
&nbsp;
╔#2a:5:5╤═╗
║1│2│3│4│5║
╟─┼─┼─┼─┼─╢
║1│2│3│4│5║
╟─┼─┼─┼─┼─╢
║1│2│3│4│5║
╟─┼─┼─┼─┼─╢
║1│2│3│4│5║
╟─┼─┼─┼─┼─╢
║1│2│3│4│5║
╚═╧═╧═╧═╧═╝
</pre>

<p>Trojrozměrné pole 2&times;3&times;4 prvky:</p>

<pre>
#|kawa:2|# <strong>(make-array [2 3 4] 1 2 3 4 5)</strong>
&nbsp;
#3a:2:3:4
║1│2│3│4║
╟─┼─┼─┼─╢
║5│1│2│3║
╟─┼─┼─┼─╢
║4│5│1│2║
╠═╪═╪═╪═╣
║3│4│5│1║
╟─┼─┼─┼─╢
║2│3│4│5║
╟─┼─┼─┼─╢
║1│2│3│4║
╚═╧═╧═╧═╝
</pre>

<p>Čtyřrozměrné pole 2&times;2&times;2&times;3 prvky:</p>

<pre>
#|kawa:11|# <strong>(make-array [2 2 2 3] 1 2 3)</strong>
&nbsp;
#4a═╤═╗
║1│2│3║
╟─┼─┼─╢
║1│2│3║
╠═╪═╪═╣
║1│2│3║
╟─┼─┼─╢
║1│2│3║
╠═╪═╪═╣
║1│2│3║
╟─┼─┼─╢
║1│2│3║
╠═╪═╪═╣
║1│2│3║
╟─┼─┼─╢
║1│2│3║
╚═╧═╧═╝
</pre>

<p>Při inicializaci polí se používá konstrukce <i>range</i>. Jedná se o jeden
ze způsobů, jakým lze v&nbsp;programovacím jazyku <i>Kawa</i> popsat sekvenci
hodnot bez toho, aby bylo nutné explicitně vypsat všechny prvky v&nbsp;sekvenci
(a navíc může být zápis názornější, než v&nbsp;případě použití funkce
<strong>range</strong> známé z&nbsp;mnoha jiných programovacích jazyků).
Nejnázornější bude si ukázat možnosti, které při specifikaci rozsahů máme.</p>

<p>Hodnoty od 1 do 9 (hodnota 10 již v&nbsp;rozsahu není):</p>

<pre>
#|kawa:1|# <strong>[1 &lt;: 10]</strong>
&nbsp;
#(1 2 3 4 5 6 7 8 9)
</pre>

<p>Hodnoty od 1 do 10, včetně obou mezí:</p>

<pre>
#|kawa:2|# <strong>[1 &lt;=: 10]</strong>
&nbsp;
#(1 2 3 4 5 6 7 8 9 10)
</pre>

<p>Počítání směrem k&nbsp;záporné ose (bez uvedení kroku):</p>

<pre>
#|kawa:3|# <strong>[10 &gt;: 0]</strong>
&nbsp;
#(10 9 8 7 6 5 4 3 2 1)
</pre>

<p>Dtto, ale včetně nuly:</p>

<pre>
#|kawa:5|# <strong>[10 &gt;=: 0]</strong>
&nbsp;
#(10 9 8 7 6 5 4 3 2 1 0)
</pre>

<p>Specifikace kroku:</p>

<pre>
#|kawa:4|# <strong>[10 by: -2 >: 0]</strong>
&nbsp;
#(10 8 6 4 2)
</pre>

<p>Dtto, ale včetně nuly:</p>

<pre>
#|kawa:6|# <strong>[10 by: -2 &gt;=: 0]</strong>
&nbsp;
#(10 8 6 4 2 0)
</pre>

<p>Práce se zlomky:</p>

<pre>
#|kawa:7|# <strong>[1 by: 1/2 &lt;=: 10]</strong>
&nbsp;
#(1 3/2 2 5/2 3 7/2 4 9/2 5 11/2 6 13/2 7 15/2 8 17/2 9 19/2 10)
</pre>

<p>Počítání po 1/10 (což v&nbsp;IEEE 754 není možné):</p>

<pre>
#|kawa:8|# <strong>[0 by: 1/10 &lt;=: 1]</strong>
&nbsp;
#(0 1/10 1/5 3/10 2/5 1/2 3/5 7/10 4/5 9/10 1)
</pre>

<p>Výsledkem bude prázdný vektor:</p>

<pre>
#|kawa:14|# <strong>[0 by: 1 &lt;=: -1]</strong>
&nbsp;
#()
</pre>

<pre>
#|kawa:2|# <strong>(index-array [[1 &lt;: 10]])</strong>
&nbsp;
╔#1a@1:9╤═╤═╤═╤═╤═╗
║0│1│2│3│4│5│6│7│8║
╚═╧═╧═╧═╧═╧═╧═╧═╧═╝
</pre>

<p>Popř.:</p>

<pre>
#|kawa:3|# <strong>(index-array [[1 &lt;=: 10]])</strong>
╔#1a@1:10═╤═╤═╤═╤═╤═╗
║0│1│2│3│4│5│6│7│8│9║
╚═╧═╧═╧═╧═╧═╧═╧═╧═╧═╝
</pre>

<p>Dvourozměrné pole:</p>

<pre>
#|kawa:3|# <strong>(index-array [[1 &lt;: 3] [2 &lt;: 6]])</strong>
&nbsp;
#2a@1:2@2:4
║0│1│2│3║
╟─┼─┼─┼─╢
║4│5│6│7║
╚═╧═╧═╧═╝
</pre>

<p>Trojrozměrné pole:</p>

<pre>
#|kawa:5|# <strong>(index-array [[1 &lt;: 4] [1 &lt;: 4] [1 &lt;: 4]])</strong>
&nbsp;
#3a@1:3@1:3@1:3
║ 0│ 1│ 2║
╟──┼──┼──╢
║ 3│ 4│ 5║
╟──┼──┼──╢
║ 6│ 7│ 8║
╠══╪══╪══╣
║ 9│10│11║
╟──┼──┼──╢
║12│13│14║
╟──┼──┼──╢
║15│16│17║
╠══╪══╪══╣
║18│19│20║
╟──┼──┼──╢
║21│22│23║
╟──┼──┼──╢
║24│25│26║
╚══╧══╧══╝
</pre>

<p>Odlišný spodní index:</p>

<pre>
#|kawa:12|# <strong>(index-array [[3 &lt;: 7] [3 &lt;: 7] [3 &lt;: 7]])</strong>
&nbsp;
#3a@3:4@3:4@3:4
║ 0│ 1│ 2│ 3║
╟──┼──┼──┼──╢
║ 4│ 5│ 6│ 7║
╟──┼──┼──┼──╢
║ 8│ 9│10│11║
╟──┼──┼──┼──╢
║12│13│14│15║
╠══╪══╪══╪══╣
║16│17│18│19║
╟──┼──┼──┼──╢
║20│21│22│23║
╟──┼──┼──┼──╢
║24│25│26│27║
╟──┼──┼──┼──╢
║28│29│30│31║
╠══╪══╪══╪══╣
║32│33│34│35║
╟──┼──┼──┼──╢
║36│37│38│39║
╟──┼──┼──┼──╢
║40│41│42│43║
╟──┼──┼──┼──╢
║44│45│46│47║
╠══╪══╪══╪══╣
║48│49│50│51║
╟──┼──┼──┼──╢
║52│53│54│55║
╟──┼──┼──┼──╢
║56│57│58│59║
╟──┼──┼──┼──╢
║60│61│62│63║
╚══╧══╧══╧══╝
</pre>



<p><a name="k19"></a></p>
<h2 id="k19">19. Obsah navazujícího článku</h2>

<p>V&nbsp;navazujícím článku se zaměříme na vybrané &bdquo;klasické&ldquo;
jazyky určené pro manipulaci s&nbsp;poli. Jedná se především o FORTRAN (dnes
vlastně již psán &bdquo;Fortran&ldquo;), dále o jazyky APL a J doplněné o
novinku představovanou jazykem BQN a taktéž se zmíníme o dnes již prakticky
neznámém projektu VectorPascal. V&nbsp;dalších dílech si pak ukážeme některé
možnosti jazyka Fortress.</p>



<p><a name="k20"></a></p>
<h2 id="k20">20. Odkazy na Internetu</h2>

<ol>

<li>What is an Array?<br />
<a href="https://vector.org.uk/what-is-an-array/">https://vector.org.uk/what-is-an-array/</a>
</li>

<li>Vector (Wolfram MathWorld)<br />
<a href="https://mathworld.wolfram.com/Vector.html">https://mathworld.wolfram.com/Vector.html</a>
</li>

<li>n-Tuple (Wolfram MathWorld)<br />
<a href="https://mathworld.wolfram.com/n-Tuple.html">https://mathworld.wolfram.com/n-Tuple.html</a>
</li>

<li>n-Vector (Wolfram MathWorld)<br />
<a href="https://mathworld.wolfram.com/n-Vector.html">https://mathworld.wolfram.com/n-Vector.html</a>
</li>

<li>Matrix (Wolfram MathWorld)<br />
<a href="https://mathworld.wolfram.com/Matrix.html">https://mathworld.wolfram.com/Matrix.html</a>
</li>

<li>Array (Wolfram MathWorld)<br />
<a href="https://mathworld.wolfram.com/Array.html">https://mathworld.wolfram.com/Array.html</a>
</li>

<li>ND Arrays (Tensors) in different languages<br />
<a href="https://www.youtube.com/watch?v=WbpbEilgQBc">https://www.youtube.com/watch?v=WbpbEilgQBc</a>
</li>

<li>Extending APL to Infinity\<br />
<a href="https://www.jsoftware.com/papers/eem/infinity.htm">https://www.jsoftware.com/papers/eem/infinity.htm</a>
</li>

<li>Vector Library (R7RS-compatible)<br />
<a href="https://srfi.schemers.org/srfi-133/srfi-133.html">https://srfi.schemers.org/srfi-133/srfi-133.html</a>
</li>

<li>Vectors (pro Gauche)<br />
<a href="https://practical-scheme.net/gauche/man/gauche-refe/Vectors.html">https://practical-scheme.net/gauche/man/gauche-refe/Vectors.html</a>
</li>

<li>Kawa: Compiling Scheme to Java<br />
<a href="https://www.mit.edu/afs.new/sipb/project/kawa/doc/kawa-tour.html">https://www.mit.edu/afs.new/sipb/project/kawa/doc/kawa-tour.html</a>
</li>

<li>Kawa in Languages shootout<br />
<a href="http://per.bothner.com/blog/2010/Kawa-in-shootout/">http://per.bothner.com/blog/2010/Kawa-in-shootout/</a>
</li>

<li>Kawa 2.0 Supports Scheme R7RS<br />
<a href="https://developers.slashdot.org/story/14/12/13/2259225/kawa-20-supports-scheme-r7rs/">https://developers.slashdot.org/story/14/12/13/2259225/kawa-20-supports-scheme-r7rs/</a>
</li>

<li>Kawa — fast scripting on the Java platform<br />
<a href="https://lwn.net/Articles/623349/">https://lwn.net/Articles/623349/</a>
</li>

<li>Incanter is a Clojure-based, R-like platform for statistical computing and graphics.<br />
<a href="http://incanter.org/">http://incanter.org/</a>
</li>

<li>Evolution of incanter (Gource Visualization)<br />
<a href="https://www.youtube.com/watch?v=TVfL5nPELr4">https://www.youtube.com/watch?v=TVfL5nPELr4</a>
</li>

<li>Questions tagged [incanter] (na Stack Overflow)<br />
<a href="https://stackoverflow.com/questions/tagged/incanter?sort=active">https://stackoverflow.com/questions/tagged/incanter?sort=active</a>
</li>

<li>Data Sorcery with Clojure<br />
<a href="https://data-sorcery.org/contents/">https://data-sorcery.org/contents/</a>
</li>

<li>Back to the Future: Lisp as a Base for a Statistical Computing System<br />
<a href="https://rd.springer.com/chapter/10.1007/978-3-7908-2084-3_2">https://rd.springer.com/chapter/10.1007/978-3-7908-2084-3_2</a>
</li>

<li>Incanter Cheat Sheet<br />
<a href="http://incanter.org/docs/incanter-cheat-sheet.pdf">http://incanter.org/docs/incanter-cheat-sheet.pdf</a>
</li>

<li>Back to the Future: Lisp as a Base for a Statistical Computing System (celá verze článku)<br />
<a href="https://www.researchgate.net/publication/227019917_Back_to_the_Future_Lisp_as_a_Base_for_a_Statistical_Computing_System">https://www.researchgate.net/publication/227019917_Back_to_the_Future_Lisp_as_a_Base_for_a_Statistical_Computing_System</a>
</li>

<li>BQN: finally, an APL for your flying saucer<br />
<a href="https://mlochbaum.github.io/BQN/">https://mlochbaum.github.io/BQN/</a>
</li>

<li>Is BQN stable?<br />
<a href="https://mlochbaum.github.io/BQN/commentary/stability.html">https://mlochbaum.github.io/BQN/commentary/stability.html</a>
</li>

<li>Specification: BQN system-provided values<br />
<a href="https://mlochbaum.github.io/BQN/spec/system.html">https://mlochbaum.github.io/BQN/spec/system.html</a>
</li>

<li>Tutorial: BQN expressions<br />
<a href="https://mlochbaum.github.io/BQN/tutorial/expression.html">https://mlochbaum.github.io/BQN/tutorial/expression.html</a>
</li>

<li>BQN primitives<br />
<a href="https://mlochbaum.github.io/BQN/doc/primitive.html">https://mlochbaum.github.io/BQN/doc/primitive.html</a>
</li>

<li>Function trains<br />
<a href="https://mlochbaum.github.io/BQN/doc/train.html">https://mlochbaum.github.io/BQN/doc/train.html</a>
</li>

<li>BQN community links<br />
<a href="https://mlochbaum.github.io/BQN/community/index.html">https://mlochbaum.github.io/BQN/community/index.html</a>
</li>

<li>BQN UV<br />
<a href="https://observablehq.com/@lsh/bqn-uv">https://observablehq.com/@lsh/bqn-uv</a>
</li>

<li>APL Wiki<br />
<a href="https://aplwiki.com/wiki/">https://aplwiki.com/wiki/</a>
</li>

<li>The Array Cast<br />
<a href="https://www.arraycast.com/episodes/episode-03-what-is-an-array">https://www.arraycast.com/episodes/episode-03-what-is-an-array</a>
</li>

<li>EnthusiastiCon 2019 – An Introduction to APL<br />
<a href="https://www.youtube.com/watch?v=UltnvW83_CQ">https://www.youtube.com/watch?v=UltnvW83_CQ</a>
</li>

<li>Dyalog<br />
<a href="https://www.dyalog.com/">https://www.dyalog.com/</a>
</li>

<li>Try APL!<br />
<a href="https://tryapl.org/">https://tryapl.org/</a>
</li>

<li>Lisp-Stat Information<br />
<a href="http://homepage.cs.uiowa.edu/~luke/xls/xlsinfo/">http://homepage.cs.uiowa.edu/~luke/xls/xlsinfo/</a>
</li>

<li>Sample Plots in Incanter<br />
<a href="https://github.com/incanter/incanter/wiki/Sample-Plots-in-Incanter#line">https://github.com/incanter/incanter/wiki/Sample-Plots-in-Incanter#line</a>
</li>

<li>vectorz-clj<br />
<a href="https://github.com/mikera/vectorz-clj">https://github.com/mikera/vectorz-clj</a>
</li>

<li>vectorz - Examples<br />
<a href="https://github.com/mikera/vectorz-clj/wiki/Examples">https://github.com/mikera/vectorz-clj/wiki/Examples</a>
</li>

<li>Basic Vector and Matrix Operations in Julia: Quick Reference and Examples<br />
<a href="https://queirozf.com/entries/basic-vector-and-matrix-operations-in-julia-quick-reference-and-examples">https://queirozf.com/entries/basic-vector-and-matrix-operations-in-julia-quick-reference-and-examples</a>
</li>

<li>Vectors and matrices in Julia<br />
<a href="https://fncbook.github.io/v1.0/linsys/demos/matrices-julia.html">https://fncbook.github.io/v1.0/linsys/demos/matrices-julia.html</a>
</li>

<li>Array vs Matrix in R Programming<br />
<a href="https://www.geeksforgeeks.org/array-vs-matrix-in-r-programming/">https://www.geeksforgeeks.org/array-vs-matrix-in-r-programming/</a>
</li>

<li>Concurrency (computer science)<br />
<a href="https://en.wikipedia.org/wiki/Category:Concurrency_%28computer_science%29">https://en.wikipedia.org/wiki/Category:Concurrency_%28computer_science%29</a>
</li>

<li>Koprogram<br />
<a href="https://cs.wikipedia.org/wiki/Koprogram">https://cs.wikipedia.org/wiki/Koprogram</a>
</li>

<li>Coroutine<br />
<a href="https://en.wikipedia.org/wiki/Coroutine">https://en.wikipedia.org/wiki/Coroutine</a>
</li>

<li>Coroutines in C<br />
<a href="http://www.chiark.greenend.org.uk/~sgtatham/coroutines.html">http://www.chiark.greenend.org.uk/~sgtatham/coroutines.html</a>
</li>

<li>S-expression (Wikipedia)<br />
<a href="https://en.wikipedia.org/wiki/S-expression">https://en.wikipedia.org/wiki/S-expression</a>
</li>

<li>S-Expressions (Rosetta Code)<br />
<a href="http://rosettacode.org/wiki/S-Expressions">http://rosettacode.org/wiki/S-Expressions</a>
</li>

<li>Introducing Julia/Metaprogramming<br />
<a href="https://en.wikibooks.org/wiki/Introducing_Julia/Metaprogramming">https://en.wikibooks.org/wiki/Introducing_Julia/Metaprogramming</a>
</li>

<li>Tutorial for the Common Lisp Loop Macro<br />
<a href="http://www.ai.sri.com/pkarp/loop.html">http://www.ai.sri.com/pkarp/loop.html</a>
</li>

<li>Clojure Macro Tutorial (Part I, Getting the Compiler to Write Your Code For You)<br />
<a href="http://www.learningclojure.com/2010/09/clojure-macro-tutorial-part-i-getting.html">http://www.learningclojure.com/2010/09/clojure-macro-tutorial-part-i-getting.html</a>
</li>

<li>Clojure Macro Tutorial (Part II: The Compiler Strikes Back)<br />
<a href="http://www.learningclojure.com/2010/09/clojure-macro-tutorial-part-ii-compiler.html">http://www.learningclojure.com/2010/09/clojure-macro-tutorial-part-ii-compiler.html</a>
</li>

<li>Clojure Macro Tutorial (Part III: Syntax Quote)<br />
<a href="http://www.learningclojure.com/2010/09/clojure-macro-tutorial-part-ii-syntax.html">http://www.learningclojure.com/2010/09/clojure-macro-tutorial-part-ii-syntax.html</a>
</li>

<li>Clojure Macros and Metaprogramming<br />
<a href="http://clojure-doc.org/articles/language/macros.html">http://clojure-doc.org/articles/language/macros.html</a>
</li>

<li>Fatvat - Exploring functional programming: Clojure Macros<br />
<a href="http://www.fatvat.co.uk/2009/02/clojure-macros.html">http://www.fatvat.co.uk/2009/02/clojure-macros.html</a>
</li>

<li>CS 2101 Parallel Computing with Julia<br />
<a href="https://www.coursehero.com/file/11508091/CS-2101-Parallel-Computing-with-Julia/">https://www.coursehero.com/file/11508091/CS-2101-Parallel-Computing-with-Julia/</a>
</li>

<li>Julia By Example<br />
<a href="https://samuelcolvin.github.io/JuliaByExample/">https://samuelcolvin.github.io/JuliaByExample/</a>
</li>

<li>Array Programming<br />
<a href="https://en.wikipedia.org/wiki/Array_programming">https://en.wikipedia.org/wiki/Array_programming</a>
</li>

<li>Discovering Array Languages<br />
<a href="http://archive.vector.org.uk/art10008110">http://archive.vector.org.uk/art10008110</a>
</li>

<li>no stinking loops -- Kalothi<br />
<a href="http://www.nsl.com/">http://www.nsl.com/</a>
</li>

<li>Vector (obsahuje odkazy na články, knihy a blogy o programovacích jazycích APL, J a K)<br />
<a href="http://www.vector.org.uk/">http://www.vector.org.uk/</a>
</li>

<li>APL Interpreters<br />
<a href="http://www.vector.org.uk/?area=interpreters">http://www.vector.org.uk/?area=interpreters</a>
</li>

<li>APL_(programming_language<br />
<a href="http://en.wikipedia.org/wiki/APL_(programming_language">http://en.wikipedia.org/wiki/APL_(programming_language</a>
</li>

<li>APL FAQ<br />
<a href="http://www.faqs.org/faqs/apl-faq/">http://www.faqs.org/faqs/apl-faq/</a>
</li>

<li>APL FAQ (nejnovější verze)<br />
<a href="http://home.earthlink.net/~swsirlin/apl.faq.html">http://home.earthlink.net/~swsirlin/apl.faq.html</a>
</li>

<li>A+<br />
<a href="http://www.aplusdev.org/">http://www.aplusdev.org/</a>
</li>

<li>APLX<br />
<a href="http://www.microapl.co.uk/">http://www.microapl.co.uk/</a>
</li>

<li>FreeAPL<br />
<a href="http://www.pyr.fi/apl/index.htm">http://www.pyr.fi/apl/index.htm</a>
</li>

<li>J: a modern, high-level, general-purpose, high-performance programming language<br />
<a href="http://www.jsoftware.com/">http://www.jsoftware.com/</a>
</li>

<li>K, Kdb: an APL derivative for Solaris, Linux, Windows<br />
<a href="http://www.kx.com">http://www.kx.com</a>
</li>

<li>openAPL (GPL)<br />
<a href="http://sourceforge.net/projects/openapl">http://sourceforge.net/projects/openapl</a>
</li>

<li>Parrot APL (GPL)<br />
<a href="http://www.parrotcode.org/">http://www.parrotcode.org/</a>
</li>

<li>Learning J (Roger Stokes)<br />
<a href="http://www.jsoftware.com/help/learning/contents.htm">http://www.jsoftware.com/help/learning/contents.htm</a>
</li>

<li>Rosetta Code<br />
<a href="http://rosettacode.org/wiki/Main_Page">http://rosettacode.org/wiki/Main_Page</a>
</li>

<li>Why APL<br />
<a href="http://www.acm.org/sigapl/whyapl.htm">http://www.acm.org/sigapl/whyapl.htm</a>
</li>

<li>Introducing Julia/Functions<br />
<a href="https://en.wikibooks.org/wiki/Introducing_Julia/Functions">https://en.wikibooks.org/wiki/Introducing_Julia/Functions</a>
</li>

<li>Functions (Julia documentation)<br />
<a href="https://docs.julialang.org/en/v1/manual/functions/">https://docs.julialang.org/en/v1/manual/functions/</a>
</li>

<li>Evaluate binomial coefficients<br />
<a href="http://rosettacode.org/wiki/Evaluate_binomial_coefficients">http://rosettacode.org/wiki/Evaluate_binomial_coefficients</a>
</li>

<li>Ackermann function<br />
<a href="http://rosettacode.org/wiki/Ackermann_function">http://rosettacode.org/wiki/Ackermann_function</a>
</li>

<li>Julia (front page)<br />
<a href="http://julialang.org/">http://julialang.org/</a>
</li>

<li>Julia &ndash; dokumentace<br />
<a href="http://docs.julialang.org/">http://docs.julialang.org/</a>
</li>

<li>Julia &ndash; repositář na GitHubu<br />
<a href="https://github.com/JuliaLang/julia">https://github.com/JuliaLang/julia</a>
</li>

<li>Julia (programming language)<br />
<a href="https://en.wikipedia.org/wiki/Julia_%28programming_language%29">https://en.wikipedia.org/wiki/Julia_%28programming_language%29</a>
</li>

<li>IJulia<br />
<a href="https://github.com/JuliaLang/IJulia.jl">https://github.com/JuliaLang/IJulia.jl</a>
</li>

<li>Introducing Julia<br />
<a href="https://en.wikibooks.org/wiki/Introducing_Julia">https://en.wikibooks.org/wiki/Introducing_Julia</a>
</li>

<li>Julia: the REPL<br />
<a href="https://en.wikibooks.org/wiki/Introducing_Julia/The_REPL">https://en.wikibooks.org/wiki/Introducing_Julia/The_REPL</a>
</li>

<li>Month of Julia<br />
<a href="https://github.com/DataWookie/MonthOfJulia">https://github.com/DataWookie/MonthOfJulia</a>
</li>

<li>Learn X in Y minutes (where X=Julia)<br />
<a href="https://learnxinyminutes.com/docs/julia/">https://learnxinyminutes.com/docs/julia/</a>
</li>

<li>New Julia language seeks to be the C for scientists<br />
<a href="http://www.infoworld.com/article/2616709/application-development/new-julia-language-seeks-to-be-the-c-for-scientists.html">http://www.infoworld.com/article/2616709/application-development/new-julia-language-seeks-to-be-the-c-for-scientists.html</a>
</li>

<li>Julia: A Fast Dynamic Language for Technical Computing<br />
<a href="http://karpinski.org/publications/2012/julia-a-fast-dynamic-language">http://karpinski.org/publications/2012/julia-a-fast-dynamic-language</a>
</li>

<li>The LLVM Compiler Infrastructure<br />
<a href="http://llvm.org/">http://llvm.org/</a>
</li>

<li>Julia: benchmarks<br />
<a href="http://julialang.org/benchmarks/">http://julialang.org/benchmarks/</a>
</li>

<li>Type system<br />
<a href="https://en.wikipedia.org/wiki/Type_system">https://en.wikipedia.org/wiki/Type_system</a>
</li>

<li>Half-precision floating-point format<br />
<a href="https://en.wikipedia.org/wiki/Half-precision_floating-point_format">https://en.wikipedia.org/wiki/Half-precision_floating-point_format</a>
</li>

<li>Dartmouth BASIC<br />
<a href="https://en.wikipedia.org/wiki/Dartmouth_BASIC">https://en.wikipedia.org/wiki/Dartmouth_BASIC</a>
</li>

<li>BASIC 4th Edition<br />
<a href="http://www.bitsavers.org/pdf/dartmouth/BASIC_4th_Edition_Jan68.pdf">http://www.bitsavers.org/pdf/dartmouth/BASIC_4th_Edition_Jan68.pdf</a>
</li>

<li>VECTRAN<br />
<a href="https://encyclopedia2.thefreedictionary.com/VECTRAN">https://encyclopedia2.thefreedictionary.com/VECTRAN</a>
</li>

<li>Comparison of programming languages (array)<br />
<a href="https://en.wikipedia.org/wiki/Comparison_of_programming_languages_(array)">https://en.wikipedia.org/wiki/Comparison_of_programming_languages_(array)</a>
</li>

<li>BASIC at 50<br />
<a href="https://www.dartmouth.edu/basicfifty/commands.html">https://www.dartmouth.edu/basicfifty/commands.html</a>
</li>

<li>BBC Basic - arrays<br />
<a href="http://www.riscos.com/support/developers/bbcbasic/part2/arrays.html">http://www.riscos.com/support/developers/bbcbasic/part2/arrays.html</a>
</li>

<li>Datová struktura<br />
<a href="https://cs.wikipedia.org/wiki/Datov%C3%A1_struktura">https://cs.wikipedia.org/wiki/Datov%C3%A1_struktura</a>
</li>

<li>SIMD instrukce využívané v&nbsp;moderních mikroprocesorech řady x86<br />
<a href="https://www.root.cz/clanky/simd-instrukce-vyuzivane-v-modernich-mikroprocesorech-rady-x86/">https://www.root.cz/clanky/simd-instrukce-vyuzivane-v-modernich-mikroprocesorech-rady-x86/</a>
</li>

<li>SIMD instrukce v&nbsp;moderních mikroprocesorech řady x86 (2.část: SSE)<br />
<a href="https://www.root.cz/clanky/simd-instrukce-v-modernich-mikroprocesorech-rady-x86-2-cast-sse/">https://www.root.cz/clanky/simd-instrukce-v-modernich-mikroprocesorech-rady-x86-2-cast-sse/</a>
</li>

<li>SIMD instrukce v&nbsp;moderních mikroprocesorech řady x86 (3.část: SSE2)<br />
<a href="https://www.root.cz/clanky/simd-instrukce-v-modernich-mikroprocesorech-rady-x86-3-cast-sse2/">https://www.root.cz/clanky/simd-instrukce-v-modernich-mikroprocesorech-rady-x86-3-cast-sse2/</a>
</li>

<li>Programování mainframů: jazyk APL<br />
<a href="https://www.root.cz/clanky/programovani-mainframu-jazyk-apl/">https://www.root.cz/clanky/programovani-mainframu-jazyk-apl/</a>
</li>

<li>Programovací jazyk APL: programování bez smyček<br />
<a href="https://www.root.cz/clanky/programovaci-jazyk-apl-programovani-bez-smycek/">https://www.root.cz/clanky/programovaci-jazyk-apl-programovani-bez-smycek/</a>
</li>

<li>Programovací jazyk APL - dokončení<br />
<a href="https://www.root.cz/clanky/programovaci-jazyk-apl-dokonceni/">https://www.root.cz/clanky/programovaci-jazyk-apl-dokonceni/</a>
</li>

<li>Programovací jazyk J – od hieroglyfů k ASCII znakům<br />
<a href="https://www.root.cz/clanky/programovaci-jazyk-j-ndash-od-hieroglyfu-k-nbsp-ascii-znakum/">https://www.root.cz/clanky/programovaci-jazyk-j-ndash-od-hieroglyfu-k-nbsp-ascii-znakum/</a>
</li>

<li>Programujeme v jazyku J: vektory a matice<br />
<a href="https://www.root.cz/clanky/programujeme-v-jazyku-j-ndash-vektory-a-matice/">https://www.root.cz/clanky/programujeme-v-jazyku-j-ndash-vektory-a-matice/</a>
</li>

<li>Programovací jazyk J: operátory, uživatelské funkce a tacit programming<br />
<a href="https://www.root.cz/clanky/programovaci-jazyk-j-operatory-uzivatelske-funkce-a-tacit-programming/">https://www.root.cz/clanky/programovaci-jazyk-j-operatory-uzivatelske-funkce-a-tacit-programming/</a>
</li>

<li>Oslava 55 let od vzniku první implementace jazyka APL<br />
<a href="https://www.root.cz/clanky/oslava-55-let-od-vzniku-prvni-implementace-programovaciho-jazyka-apl/">https://www.root.cz/clanky/oslava-55-let-od-vzniku-prvni-implementace-programovaciho-jazyka-apl/</a>
</li>

<li>Zpracování vektorů, matic a N-rozměrných polí v&nbsp;programovacím jazyku Kawa<br />
<a href="https://www.root.cz/clanky/zpracovani-vektoru-matic-a-n-rozmernych-poli-v-programovacim-jazyku-kawa/">https://www.root.cz/clanky/zpracovani-vektoru-matic-a-n-rozmernych-poli-v-programovacim-jazyku-kawa/</a>
</li>

<li>Rust: knihovna ndarray pro práci s&nbsp;n-rozměrnými poli<br />
<a href="https://www.root.cz/clanky/rust-knihovna-ndarray-pro-praci-s-n-rozmernymi-poli/">https://www.root.cz/clanky/rust-knihovna-ndarray-pro-praci-s-n-rozmernymi-poli/</a>
</li>

<li>Programovací jazyk Clojure a knihovny pro práci s&nbsp;vektory a maticemi<br />
<a href="https://www.root.cz/clanky/programovaci-jazyk-clojure-a-knihovny-pro-praci-s-vektory-a-maticemi/">https://www.root.cz/clanky/programovaci-jazyk-clojure-a-knihovny-pro-praci-s-vektory-a-maticemi/</a>
</li>

<li>Programovací jazyk Clojure a knihovny pro práci s vektory a maticemi (2)<br />
<a href="https://www.root.cz/clanky/programovaci-jazyk-clojure-a-knihovny-pro-praci-s-vektory-a-maticemi-2/">https://www.root.cz/clanky/programovaci-jazyk-clojure-a-knihovny-pro-praci-s-vektory-a-maticemi-2/</a>
</li>

<li>Gophernotes: kombinace interaktivního prostředí Jupyteru s jazykem Go<br />
<a href="https://www.root.cz/clanky/gophernotes-kombinace-interaktivniho-prostredi-jupyteru-s-jazykem-go/">https://www.root.cz/clanky/gophernotes-kombinace-interaktivniho-prostredi-jupyteru-s-jazykem-go/</a>
</li>

<li>Popis vybraných balíčků nabízených projektem Gonum<br />
<a href="https://www.root.cz/clanky/popis-vybranych-balicku-nabizenych-projektem-gonum/">https://www.root.cz/clanky/popis-vybranych-balicku-nabizenych-projektem-gonum/</a>
</li>

<li>Integrovaná vývojová prostředí ve Fedoře: vykreslování grafů s využitím knihoven Numpy a matplotlib<br />
<a href="https://mojefedora.cz/integrovana-vyvojova-prostredi-ve-fedore-vykreslovani-grafu-s-vyuzitim-knihoven-numpy-a-matplotlib/">https://mojefedora.cz/integrovana-vyvojova-prostredi-ve-fedore-vykreslovani-grafu-s-vyuzitim-knihoven-numpy-a-matplotlib/</a>
</li>

<li>Integrovaná vývojová prostředí ve Fedoře: praktické použití IPython Notebooku a knihovny Numpy (2.část)<br />
<a href="https://mojefedora.cz/integrovana-vyvojova-prostredi-ve-fedore-prakticke-pouziti-ipython-notebooku-a-knihovny-numpy-2-cast/">https://mojefedora.cz/integrovana-vyvojova-prostredi-ve-fedore-prakticke-pouziti-ipython-notebooku-a-knihovny-numpy-2-cast/</a>
</li>

<li>Integrovaná vývojová prostředí ve Fedoře: praktické použití IPython Notebooku a knihovny Numpy<br />
<a href="https://mojefedora.cz/integrovana-vyvojova-prostredi-ve-fedore-prakticke-pouziti-ipython-notebooku-a-knihovny-numpy/">https://mojefedora.cz/integrovana-vyvojova-prostredi-ve-fedore-prakticke-pouziti-ipython-notebooku-a-knihovny-numpy/</a>
</li>

</ol>



<p></p><p></p>
<p><small>Autor: <a href="http://www.fit.vutbr.cz/~tisnovpa">Pavel Tišnovský</a> &nbsp; 2021</small></p>
</body>
</html>

