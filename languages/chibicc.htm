<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
        "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html>
<head>
<title>Minimalistické překladače jazyka C: tcc a Chibicc</title>
<meta name="Author" content="Pavel Tisnovsky" />
<meta name="Generator" content="vim" />
<meta http-equiv="content-type" content="text/html; charset=utf-8" />
<style type="text/css">
         body {color:#000000; background:#ffffff;}
         h1  {font-family: arial, helvetica, sans-serif; color:#ffffff; background-color:#c00000; text-align:center; padding-left:1em}
         h2  {font-family: arial, helvetica, sans-serif; color:#ffffff; background-color:#0000c0; padding-left:1em; text-align:left}
         h3  {font-family: arial, helvetica, sans-serif; color:#000000; background-color:#c0c0c0; padding-left:1em; text-align:left}
         h4  {font-family: arial, helvetica, sans-serif; color:#000000; background-color:#e0e0e0; padding-left:1em; text-align:left}
         a   {font-family: arial, helvetica, sans-serif;}
         li  {font-family: arial, helvetica, sans-serif; color:#000000; text-align:justify; width:450px;}
         ol  {font-family: arial, helvetica, sans-serif; color:#000000; text-align:justify; width:450px;}
         ul  {font-family: arial, helvetica, sans-serif; color:#000000; text-align:justify; width:450px;}
         p   {font-family: arial, helvetica, sans-serif; color:#000000; text-align:justify;}
         pre {background:#e0e0e0}
</style>
</head>

<body>

<h1>Minimalistické překladače jazyka C: tcc a Chibicc</h1>

<h3>Pavel Tišnovský</h3>

<p></p>

<h1>Úvodník</h1>

<p></p>



<h2>Obsah</h2>

<p><a href="#k01">1. Minimalistické překladače jazyka C: tcc a Chibicc</a></p>
<p><a href="#k02">2. Programovací jazyk C</a></p>
<p><a href="#k03">3. Překladače programovacího jazyka C v&nbsp;Linuxu</a></p>
<p><a href="#k04">4. Tiny C Compiler</a></p>
<p><a href="#k05">5. Získání, konfigurace a překlad Tiny C Compileru</a></p>
<p><a href="#k06">*** 6. Překladač céčka Chibicc</a></p>
<p><a href="#k07">*** 7. Překlad překladače (sic) Chibicc</a></p>
<p><a href="#k08">*** 8. Programy použité pro porovnání Tiny C Compileru a překladače Chibicc s&nbsp;GCC</a></p>
<p><a href="#k09">*** 9. </a></p>
<p><a href="#k10">*** 10. </a></p>
<p><a href="#k11">*** 11. </a></p>
<p><a href="#k12">*** 12. </a></p>
<p><a href="#k13">*** 13. </a></p>
<p><a href="#k14">*** 14. </a></p>
<p><a href="#k15">*** 15. </a></p>
<p><a href="#k16">*** 16. </a></p>
<p><a href="#k17">*** 17. </a></p>
<p><a href="#k18">*** 18. </a></p>
<p><a href="#k19">*** 19. Repositář s&nbsp;demonstračními příklady</a></p>
<p><a href="#k20">*** 20. Odkazy na Internetu</a></p>



<p><a name="k01"></a></p>
<h2 id="k01">1. Minimalistické překladače jazyka C: tcc a Chibicc</h2>

<p>Když vývojář používající operační systém Linux (nebo abychom neurazili, tak
GNU/Linux) použije sousloví &bdquo;překladač céčka&ldquo;, je prakticky
stoprocentně jisté, že má na mysli překladač programovacího jazyka C patřící do
rodiny GCC (GNU Compiler Collection) nebo Clang (postavený nad LLVM). Ovšem ve
skutečnosti existuje pro Linux mnohem větší množství překladačů programovacího
jazyka C. Mezi ně patří například minimalisticky pojatý projekt <i>Tiny C
Compiler</i>, jehož největší předností je velká rychlost překladu i možnost
použít tento překladač ve funkci interpretru &ndash; je jím tedy možné céčkové
programy přímo &bdquo;spouštět&ldquo;, podobně jako skripty psané v&nbsp;Perlu
či v&nbsp;BASHi, Pythonu, Ruby atd. atd. Ovšem existuje i relativně velké
množství dalších překladačů céčka.  V&nbsp;dnešním článku se kromě již
zmíněného <i>Tiny C Compileru</i> (zkráceně jen <i>tcc</i>) zaměříme i na
překladač nazvaný <i>chibicc: A Small C Compiler</i> (zkracovat to budeme na
<i>chibicc</i>).</p>



<p><a name="k02"></a></p>
<h2 id="k02">2. Programovací jazyk C</h2>

<p>Jedním z&nbsp;nejpopulárnějších v&nbsp;současnosti používaných
programovacích jazyků je stále (což je mimochodem zajímavé a hodně to vypovídá
o realitě v&nbsp;IT) programovací jazyk C navržený Dennisem Ritchiem. Jazyk C
se postupně vyvinul z&nbsp;programovacích jazyků BPCL (autor Martin Richards,
1966) a B (autor Ken Thompson, 1970) až do současné podoby, která byla
standardizována v&nbsp;několika normách, z&nbsp;nichž nejznámější je
pravděpodobně stále ještě ISO/IEC 9899:1999 známá pod zkráceným označením
<i>C99</i> (následoval <i>C11</i> neboli ISO/IEC 9899:2011, <i>C17</i> neboli
ISO/IEC 9899:2018 a konečně <i>C23</i> neboli ISO/IEC 9899:2024 ). Starší,
dodnes v&nbsp;některých případech stále ještě používaný standard se jmenuje ISO
9899:1990, tento starší standard je prakticky shodný (až na jiné číslování
jednotlivých paragrafů) s&nbsp;normou ANSI C (ANSI X3.159-1989
&bdquo;Programming Language C&ldquo;) a zkráceně se označuje <i>C89</i> či méně
často <i>C90</i>. Se všemi zkratkami C89, C90, C99, C11, C17 a C23 se ještě
v&nbsp;tomto článku setkáme.</p>

<p>Programovací jazyk C je i přes absenci některých důležitých vlastností
(například mu chybí automatický správce paměti či podpora silného typování a
práce s&nbsp;objekty, výjimkami, uzávěry atd.) využívaný jak pro tvorbu open
source aplikací, tak i v&nbsp;čistě komerční oblasti &ndash; nejedná se jen o
vývoj aplikací pro desktopy a servery, ale i pro mikrořadiče či digitální
signálové procesory (DSP). Céčko je mnohdy využíváno i ve funkci cílového
jazyka, do něhož se překládají (transpilují) programy zapsané v&nbsp;některých
vyšších programovacích jazycích &ndash; vývojáři, kteří překladače těchto
jazyků vytváří, se tak nemusí starat například o nízkoúrovňové optimalizace,
protože je za ně již naprogramovali vývojáři překladače céčka.
Z&nbsp;historického hlediska je zajímavé, že právě tímto způsobem vznikla první
verze jazyka C++ (nástroj Cpre), i když moderní překladače C++ jsou již řešeny
odděleně.</p>

<p>To však není zdaleka vše, protože programovací jazyk C je dodnes důležitý i
z&nbsp;toho důvodu, že jak rozhraní jader některých operačních systémů (Linux,
Microsoft Windows i dalších systémů), tak rozhraní systémových knihoven bylo
navrženo s&nbsp;ohledem na jmenné konvence céčka i s&nbsp;ohledem na možnosti
jeho linkeru (a ostatní jazyky toto rozhraní s&nbsp;většími či menšími problémy
dodržují).</p>



<p><a name="k03"></a></p>
<h2 id="k03">3. Překladače programovacího jazyka C v&nbsp;Linuxu</h2>

<p>Vývoj operačního systému GNU/Linux byl do značné míry ovlivněn, a možná bych
si dokonce dovolil říci, že vůbec umožněn tím, že na něj byly portovány
nástroje označované souhrnným názvem <i>GNU Compiler Collection</i> neboli
zkráceně <i>GCC</i>. Tyto nástroje obsahují překladače několika programovacích
jazyků, především pak překladače jazyků C, C++, Objective C, Objective C++,
Java, Ada a Fortran (později byly přidány překladače pro Go a nedávno i pro
Rust, ovšem prozatím ve fázi vývoje). Kromě překladačů jsou součástí GCC i
další nástroje, zejména preprocesor používaný jazyky C a C++, dále GNU
assembler (<i>gas</i>), linker, nástroj sledující pokrytí kódu testy
(<i>gcov</i>) atd. Jedná se o velmi kvalitní nástroje, které navíc podporují
obrovské množství různých platforem, operačních systémů a procesorových
architektur, samozřejmě včetně procesorů řady x86 a x86_64.</p>

<p>Kromě překladače céčka patřícího do skupiny nástrojů GCC (i samotný
překladač se jmenuje GCC &ndash; GNU C Compiler, což může být poněkud matoucí,
je tedy nutné vždy sledovat kontext, ve kterém se o GCC mluví či píše) je možné
v&nbsp;operačním systému Linux použít i další překladače. Mezi ně patří
například Clang z&nbsp;projektu LLVM, jenž je zajímavý především po
technologické stránce a s&nbsp;jehož technologií se seznámíme v&nbsp;některém
z&nbsp;navazujících článků. Dále se pak můžeme (či jsme se mohli) setkat
s&nbsp;překladači komerčních firem, například s&nbsp;překladačem vytvořeným
společností Intel, který v&nbsp;případě některých typů optimalizací překonával
GCC a Clang/LLVM. V&nbsp;neposlední řadě je pak možné v&nbsp;Linuxu (a nutno
říci, že nejenom v&nbsp;něm) použít překladače nazvané <i>Tiny C Compiler</i>
(zkráceně <i>tcc</i>) a <i>Chibicc</i>, jejichž popisem a porovnáním s&nbsp;GCC
se budeme zabývat v&nbsp;navazujících kapitolách.</p>



<p><a name="k04"></a></p>
<h2 id="k04">4. Tiny C Compiler</h2>

<p><i>Tiny C Compiler</i> (zkracovat ho budeme na <i>tcc</i>) je překladač
programovacího jazyka C, který byl původně vytvořen Fabricem Bellardem a nyní
se o jeho další vývoj a portaci na nové platformy stará komunita vývojářů,
protože se samozřejmě jedná o open-source projekt (i když je nutno poznamenat,
že vývoj v&nbsp;žádném případě není nijak bouřlivý). Tiny C Compiler
v&nbsp;sobě kromě vlastního překladače obsahuje i linker, což znamená, že jeden
binární program může sloužit jak pro překlad zdrojových textů (včetně
preprocesingu) do objektového kódu, tak pro vytvoření výsledného spustitelného
binárního programu. Všechny tři zmíněné funkce jsou implementovány
v&nbsp;jediném spustitelném souboru, jehož velikost na platformě x86
nepřesahuje tři sta kilobajtů, což je například v&nbsp;porovnání s&nbsp;GCC
zcela zanedbatelná velikost (dokonce i pouze GNU assembler je v&nbsp;binární
podobě větší než celý <i>tcc</i>).</p>

<p>Tiny C Compiler podporuje standard C89/C90 i velkou část standardu C99, a to
do té míry, že úpravy zdrojových kódů určených pro GCC většinou nejsou
zapotřebí. Největší devizou překladače <i>tcc</i> je ovšem blesková rychlost
překladu, protože vlastní překlad je jednoprůchodový. Na stránkách tohoto
projektu se uvádí, že <i>tcc</i> je přibližně osmkrát rychlejší než překladač
GCC (s&nbsp;použitím standardních voleb, tj.&nbsp;bez optimalizací), ovšem jak
se můžete dozvědět z&nbsp;dalšího textu, může být <i>tcc</i> v extrémním
případě rychlejší zhruba čtyřicetkrát! (a v&nbsp;některých jiných případech jen
třikrát rychlejší). Na druhou stranu však <i>tcc</i> za většinou ostatních
moderních překladačů céčka významně pokulhává v&nbsp;případě optimalizací
prováděných při překladu. O tom, do jaké míry se absence většiny
optimalizačních metod projeví na demonstračních příkladech (benchmarcích), si
řekneme v&nbsp;navazujících kapitolách.</p>

<p>Co to však znamená pro každodenní praxi vývojáře? Podle mého názoru je
ideální zkombinovat vlastnosti <i>tcc</i> (doslova blesková rychlost překladu)
a GCC či Clang (optimalizace na několika úrovních) takovým způsobem, že pro
samotný vývoj se použije překladač <i>tcc</i> a pro tvorbu výsledné binární
podoby programu se naopak využije překladač GCC s&nbsp;příslušnými přepínači
(-O3 atd.). <i>Tiny C Compiler</i> lze použít především na architekturách x86 a
x86_64, i když existují i verze využitelné na procesorech ARM a DSP čipech řady
TMS320C67xx. Všechna měření, jejichž výsledky jsou uvedeny v dalších
kapitolách, byly provedeny na počítači s&nbsp;architekturou x86-64.</p>



<p><a name="k05"></a></p>
<h2 id="k05">5. Získání, konfigurace a překlad Tiny C Compileru</h2>

<p>Některé distribuce Linuxu obsahují balíček s&nbsp;Tiny C Compilerem. Poté je
jeho instalace triviální. Příkladem mohou být distribuce postavené na
Debianu/Mintu atd., v&nbsp;nichž je možné Tiny C Compiler nainstalovat
takto:</p>

<pre>
$ <strong>sudo apt-get install tcc</strong>
</pre>

<p>Samotná instalace vyžaduje pouze minimum místa na disku (alespoň
z&nbsp;dnešního pohledu):</p>

<pre>
The following NEW packages will be installed:
  tcc
0 upgraded, 1 newly installed, 0 to remove and 22 not upgraded.
Need to get 242 kB of archives.
After this operation, 709 kB of additional disk space will be used.
Get:1 http://archive.ubuntu.com/ubuntu focal/universe amd64 tcc amd64 0.9.27-8 [242 kB]
Fetched 242 kB in 1s (215 kB/s)
Selecting previously unselected package tcc.
(Reading database ... 330120 files and directories currently installed.)
Preparing to unpack .../tcc_0.9.27-8_amd64.deb ...
Unpacking tcc (0.9.27-8) ...
Setting up tcc (0.9.27-8) ...
Processing triggers for install-info (6.7.0.dfsg.2-5) ...
Processing triggers for doc-base (0.10.9) ...
Processing 1 added doc-base file...
Processing triggers for man-db (2.9.1-1) ...
</pre>

<p>Zjistíme, která verze se skutečně nainstalovala:</p>

<pre>
$ <strong>tcc -v</strong>
&nbsp;
tcc version 0.9.27 (x86_64 Linux)
</pre>

<p>V&nbsp;případě, že není balíček dostupný nebo pokud si budete chtít
vyzkoušet jeho nejnovější verzi, můžeme provést překlad a instalaci přímo ze
zdrojových kódů. Je to ve skutečnosti velmi snadné a potřebujeme k&nbsp;tomu
pouze jiný překladač céčka (nebo samotný <i>tcc</i>, který umí sám sebe
přeložit), <i>git</i> a některé další nástroje dostupné na počítači
vývojářů.</p>

<p>Nejprve si naklonujeme repositář s&nbsp;tcc:</p>

<pre>
$ <strong>git clone git://repo.or.cz/tinycc.git</strong>
&nbsp;
Cloning into 'tinycc'...
remote: Counting objects: 16864, done.
remote: Compressing objects: 100% (4304/4304), done.
remote: Total 16864 (delta 12447), reused 16819 (delta 12405)
Receiving objects: 100% (16864/16864), 4.77 MiB | 1.34 MiB/s, done.
Resolving deltas: 100% (12447/12447), done.
</pre>

<p>Následně spustíme skript <strong>configure</strong>, který zjistí aktuálně
použitý systém, architekturu procesoru a překladač, který bude použitý pro
překlad. Výsledek se uloží, takže bude možné použít <strong>make</strong> pro
překlad:</p>

<pre>
$ <strong>./configure </strong>
&nbsp;
Binary directory    /usr/local/bin
TinyCC directory    /usr/local/lib/tcc
Library directory   /usr/local/lib
Include directory   /usr/local/include
Manual directory    /usr/local/share/man
Info directory      /usr/local/share/info
Doc directory       /usr/local/share/doc
Source path         /tmp/ramdisk/tinycc
Build OS            Linux x86_64
C compiler          gcc (9.4)
Target OS           Linux
CPU                 x86_64
Triplet             x86_64-linux-gnu
Creating config.mak and config.h
</pre>

<p>Dále již stačí spustit klasický <strong>make</strong>:</p>

<pre>
$ <strong>make</strong>
</pre>

<p>Po několika sekundách či desítkách sekund by měl překlad doběhnout.
Výsledkem bude spustitelný soubor <strong>tcc</strong> s&nbsp;velikostí
nepřesahující 400kB:</p>

<pre>
$ <strong>ls -sh tcc</strong>
&nbsp;
348K tcc
</pre>

<p>Tento soubor lze ještě zmenšit na cca 320 kB (předchozí verze <i>tcc</i>
dokonce na velikosti 100kB):</p>

<pre>
$ <strong>strip tcc</strong>
&nbsp;
$ <strong>ls -sh tcc</strong>
&nbsp;
320K tcc
</pre>

<p>Nakonec ověříme, jakou verzi <i>tcc</i> jsme vlastně přeložili:</p>

<pre>
$ <strong>./tcc -v</strong>
&nbsp;
tcc version 0.9.28rc 2024-03-13 mob@2b0a663d (x86_64 Linux)
</pre>



<p><a name="k06"></a></p>
<h2 id="k06">6. Překladač céčka Chibicc</h2>

<p></p>



<p><a name="k07"></a></p>
<h2 id="k07">7. Překlad překladače (sic) Chibicc</h2>

<p></p>

<pre>
$ <strong>git clone git@github.com:rui314/chibicc.git</strong>
&nbsp;
Cloning into 'chibicc'...
remote: Enumerating objects: 4584, done.
remote: Counting objects: 100% (686/686), done.
remote: Compressing objects: 100% (292/292), done.
remote: Total 4584 (delta 409), reused 664 (delta 394), pack-reused 3898
Receiving objects: 100% (4584/4584), 822.69 KiB | 1.61 MiB/s, done.
Resolving deltas: 100% (3406/3406), done.
</pre>

<pre>
$ <strong>ls -l *.[hc]</strong>
&nbsp;
-rw-rw-r-- 1 ptisnovs ptisnovs  9811 Dec 31 14:26 chibicc.h
-rw-rw-r-- 1 ptisnovs ptisnovs 43920 Dec 31 14:26 codegen.c
-rw-rw-r-- 1 ptisnovs ptisnovs  4564 Dec 31 14:26 hashmap.c
-rw-rw-r-- 1 ptisnovs ptisnovs 18392 Dec 31 14:26 main.c
-rw-rw-r-- 1 ptisnovs ptisnovs 91158 Dec 31 14:26 parse.c
-rw-rw-r-- 1 ptisnovs ptisnovs 33021 Dec 31 14:26 preprocess.c
-rw-rw-r-- 1 ptisnovs ptisnovs   690 Dec 31 14:26 strings.c
-rw-rw-r-- 1 ptisnovs ptisnovs 19317 Dec 31 14:26 tokenize.c
-rw-rw-r-- 1 ptisnovs ptisnovs  7503 Dec 31 14:26 type.c
-rw-rw-r-- 1 ptisnovs ptisnovs  6980 Dec 31 14:26 unicode.c
</pre>



<pre>
$ <strong>cd chibicc/</strong>
$ <strong>make</strong>
cc -std=c11 -g -fno-common -Wall -Wno-switch   -c -o strings.o strings.c
cc -std=c11 -g -fno-common -Wall -Wno-switch   -c -o tokenize.o tokenize.c
cc -std=c11 -g -fno-common -Wall -Wno-switch   -c -o hashmap.o hashmap.c
cc -std=c11 -g -fno-common -Wall -Wno-switch   -c -o type.o type.c
cc -std=c11 -g -fno-common -Wall -Wno-switch   -c -o main.o main.c
cc -std=c11 -g -fno-common -Wall -Wno-switch   -c -o parse.o parse.c
cc -std=c11 -g -fno-common -Wall -Wno-switch   -c -o codegen.o codegen.c
cc -std=c11 -g -fno-common -Wall -Wno-switch   -c -o preprocess.o preprocess.c
cc -std=c11 -g -fno-common -Wall -Wno-switch   -c -o unicode.o unicode.c
cc -std=c11 -g -fno-common -Wall -Wno-switch -o chibicc strings.o tokenize.o hashmap.o type.o main.o parse.o codegen.o preprocess.o unicode.o
</pre>

<pre>
$ <strong>make clean</strong>
$ <strong>time make</strong>
cc -std=c11 -g -fno-common -Wall -Wno-switch   -c -o strings.o strings.c
cc -std=c11 -g -fno-common -Wall -Wno-switch   -c -o tokenize.o tokenize.c
cc -std=c11 -g -fno-common -Wall -Wno-switch   -c -o hashmap.o hashmap.c
cc -std=c11 -g -fno-common -Wall -Wno-switch   -c -o type.o type.c
cc -std=c11 -g -fno-common -Wall -Wno-switch   -c -o main.o main.c
cc -std=c11 -g -fno-common -Wall -Wno-switch   -c -o parse.o parse.c
cc -std=c11 -g -fno-common -Wall -Wno-switch   -c -o codegen.o codegen.c
cc -std=c11 -g -fno-common -Wall -Wno-switch   -c -o preprocess.o preprocess.c
cc -std=c11 -g -fno-common -Wall -Wno-switch   -c -o unicode.o unicode.c
cc -std=c11 -g -fno-common -Wall -Wno-switch -o chibicc strings.o tokenize.o hashmap.o type.o main.o parse.o codegen.o preprocess.o unicode.o

real    0m0,667s
user    0m0,563s
sys     0m0,098s
</pre>

<pre>
$ <strong>ls -l chibicc</strong>
&nbsp;
-rwxrwxr-x 1 ptisnovs ptisnovs 315128 Dec 31 14:28 chibicc
</pre>

<pre>
$ <strong>./chibicc --help</strong>
&nbsp;
chibicc [ -o &lt;path&gt; ] &lt;file&gt;
</pre>


<p></p>

<pre>
$ <strong>chibicc -I/usr/include -I/usr/include/SDL2/ main.c gfx.c</strong>
</pre>

<pre>
/usr/include/SDL2/SDL_cpuinfo.h:86: #include <immintrin.h>
                                             ^ immintrin.h: cannot open file: No such file or directory
</pre>



<p><a name="k08"></a></p>
<h2 id="k08">8. Programy použité pro porovnání Tiny C Compileru a překladače Chibicc s&nbsp;GCC</h2>

<p>Pro porovnání vlastností Tiny C Compileru, překladače Chibicc a překladače
céčka, jenž je součástí skupiny překladačů GCC, jsem zvolil tři diametrálně
odlišné zdrojové kódy. Prvním zdrojovým kódem je kód projektu <i>tth</i> (plným
jménem <i>TeX to HTML Translator</i>), který je dostupný na adrese <a
href="http://silas.psfc.mit.edu/tth/tars/download.html">http://silas.psfc.mit.edu/tth/tars/download.html</a>.
Tento projekt je v&nbsp;několika ohledech extrémní, protože je uložen
v&nbsp;jediném céčkovém zdrojovém kódu o velikosti 1192 kB, který má celkem
29&nbsp;068 řádků! (v&nbsp;jediném zdrojovém souboru). Překlad takto velkého
souboru je pro překladač (přesněji řečeno pro překladač GCC) skutečně tvrdým
oříškem, o čemž se ostatně přesvědčíme v&nbsp;další kapitole.</p>

<p>Druhým testovacím programem je generátor fraktálů, který při svém spuštění
velmi intenzivně používá operace s&nbsp;hodnotami s&nbsp;plovoucí řádovou
čárkou (<i>floating point</i>). V&nbsp;tomto programu se názorně ukáže, jak
dobře (či naopak špatně) provádí překladač různé optimalizace &ndash; a to jak
optimalizace výpočtů, tak například i rozbalení smyček. Zdrojový kód tohoto
programu vypadá následovně:</p>

<pre>
</pre>

<p>Třetím příkladem je program pro řešení Sudoku. Algoritmus řešení je velmi
jednoduchý a naivní, což však není v&nbsp;tomto případě podstatné, jelikož nás
zajímá rychlost překladu a kvalita výsledného kódu. V&nbsp;tomto programu se
velmi často používají operace pro práci s&nbsp;prvky dvourozměrných a
trojrozměrných polí, takže se zde ukáže, jak dokáže překladač optimalizovat
tento typ operací:</p>

<pre>
/* ------------------------------------------------------------------ */
/* Snizeni poctu moznych kombinaci zjistenim duplicit na radcich      */
/* ------------------------------------------------------------------ */
void testRadku0(void)
{
    int radek, sloupec;
    int cifry[9], cifra;
    int i;
    for (radek=0; radek<9; radek++) {
        for (i=0; i<9; i++)
            cifry[i]=0;
        /* projdi vsechny bunky ve sloupci a zjisti zapsana cisla */
        for (sloupec=0; sloupec<9; sloupec++) {
            cifra=src[radek][sloupec];
            if (cifra>0) { /* obsad cifru */
                cifry[cifra-1]=1;
            }
        }
        /* v matici povol zmeni cely sloupec */
        for (sloupec=0; sloupec<9; sloupec++) {
            if (src[radek][sloupec]==0) {
                for (i=0; i<9; i++) {
                    if (cifry[i])
                        povol[radek][sloupec][i]=0;
                }
            }
        }
    }
}



/* ------------------------------------------------------------------ */
/* Snizeni poctu moznych kombinaci zjistenim duplicit v blocich 3x3   */
/* ------------------------------------------------------------------ */
void testBloky0(void)
{
    int blokx, bloky;
    int cifry[9], cifra;
    int i, j;
    for (bloky=0; bloky<9; bloky+=3) {
        for (blokx=0; blokx<9; blokx+=3) {
            for (i=0; i<9; i++) /* v kazdem bloku 3x3 nejprve vymazeme seznam cifer */
                cifry[i]=0;
            for (j=0; j<3; j++) { /* projdi blok a zjisti cisla */
                for (i=0; i<3; i++) {
                    cifra=src[j+bloky][i+blokx];
                    if (cifra>0) { /* obsad cifru */
                        cifry[cifra-1]=1;
                    }
                }
            }
            for (j=0; j<3; j++) { /* projdi blok a znuluj nalezene cifry */
                for (i=0; i<3; i++) {
                    if (src[j+bloky][i+blokx]==0) { /* v tomto poli ma smysl menit cifry */
                        int k;
                        for (k=0; k<9; k++) {
                            if (cifry[k])
                                povol[j+bloky][i+blokx][k]=0;
                        }
                    }
                }
            }
        }
    }
}



/* ------------------------------------------------------------------ */
/* Test, zda je ve vsech sloupcich devet ruznych hodnot               */
/* ------------------------------------------------------------------ */
int testSloupce(void)
{
    int radek, sloupec;
    int cifry[9];
    for (sloupec=0; sloupec<9; sloupec++) {
        for (radek = 0; radek<9; radek++) {
            cifry[radek] = 0;
        }
        /* projdu vsechny polozky v radku a zjistim cisla */
        for (radek=0; radek < 9; radek++) {
            /* cifra je uz obsazena? */
            if (cifry[wrk[radek][sloupec]-1] != 0)
                return 0;
            else  /* obsad cifru */
                cifry[wrk[radek][sloupec]-1]=1;
        }
    }
    return 1;
}



/* ------------------------------------------------------------------ */
/* Test, zda je na vsech radcich devet ruznych hodnot                 */
/* ------------------------------------------------------------------ */
int testRadky(void)
{
    int radek, sloupec;
    int cifry[9];
    for (radek=0; radek<9; radek++) {
        for (sloupec=0; sloupec<9; sloupec++) {
            cifry[sloupec] = 0;
        }
        /* projdu vsechny polozky v radku a zjistim cisla */
        for (sloupec=0; sloupec<9; sloupec++) {
            /* cifra je uz obsazena? */
            if (cifry[wrk[radek][sloupec]-1] != 0)
                return 0;
            else  /* obsad cifru */
                cifry[wrk[radek][sloupec]-1]=1;
        }
    }
    return 1;
}



/* ------------------------------------------------------------------ */
/* Test, zda je ve vsech blocich 3x3 devet ruznych hodnot             */
/* ------------------------------------------------------------------ */
int testBloky(void)
{
    int blokx, bloky;
    int cifry[9], cifra;
    int i, j;
    for (bloky=0; bloky<9; bloky+=3) {
        for (blokx=0; blokx<9; blokx+=3) {
            memset(cifry, 0, 9 * sizeof(int));
            for (j=0; j<3; j++) {
                for (i=0; i<3; i++) {
                    cifra=wrk[j+bloky][i+blokx];
                    if (cifry[cifra-1])
                        return 0;
                    else  /* obsad cifru */
                        cifry[cifra-1]=1;
                }
            }
        }
    }
    return 1;
}



/* ------------------------------------------------------------------ */
/* Tisk nalezeneho reseni                                             */
/* ------------------------------------------------------------------ */
void tiskVysledku(void)
{
    int i, j;
    putchar('\n');
    ODDELOVAC
    for (j=0; j<9; j++) {
        printf("| ");
        for (i=0; i<9; i++) {
            printf("%d ", wrk[j][i]);
            if (i % 3 == 2) printf(" | ");
        }
        putchar('\n');
        if (j % 3 == 2)
            ODDELOVAC
    }
}



/* ------------------------------------------------------------------ */
/* Reseni Sudoku                                                      */
/* ------------------------------------------------------------------ */
void solve(void)
{
    int i, j, k;
    int done=0;
    double counter=0;
    double max=1;
    int cnt=0;

    /* zjisteni poctu kombinaci pro vypis */
    for (j=0; j<9; j++) {
        for (i=0; i<9; i++) {
            int cnt=0;
            for (k=0; k<9; k++) {
                if (povol[j][i][k])
                    cnt++;
            }
            max=max*cnt;
        }
    }

    while (!done) {
        /* test, zda je Sudoku vyreseno */
        if (testRadky() && testSloupce() && testBloky()) {
            tiskVysledku();
            return;
        }

        /* vypis prubeznych vysledku */
        if (cnt==5e6) {
            printf("Kombinaci: %.0f z %.f  zbyva %.f = %7.3f%%\n", counter, max, max-counter, 100.0 - 100.0*counter/max);
            cnt=0;
        }
        for (j=0; j<9; j++) {
            for (i=0; i<9; i++) {
                if (!src[j][i]) { /* jde o nevyplnenou polozku -> zvysime jeji hodnotu */
                    if (wrk[j][i]<9) {
                        do { /* prejit na dalsi povolenou cifru */
                            wrk[j][i]++;
                            k=wrk[j][i];
                        } while (povol[j][i][k-1]==0 && k<=9);
                        if (k>9 || povol[j][i][k-1]==0) { /* uz jsme na konci rady povolenych cisel? */
                            wrk[j][i]=minim[j][i];        /* prejdeme na dalsi policko */
                        }
                        else {
                            goto KONEC;
                        }
                    }
                    else { /* jsme na konci -> nastavime prvni povolenou cifru */
                        wrk[j][i]=minim[j][i];
                        if (j==8 && i==8) done=1;
                    }
                }
            }
        }
KONEC:
        counter++;
        cnt++;
    }
}



/* ------------------------------------------------------------------ */
/* Vypis vsech kombinaci cisel pro kazde policko                      */
/* ------------------------------------------------------------------ */
void vypisPovol()
{
    double counter=1;
    int i, j, k;
    /* vypsani povol matice */
    for (j=0; j<9; j++) {
        for (i=0; i<9; i++) {
            int cnt=0;
            int prvniCislo=1;
            putchar('(');
            for (k=0; k<9; k++) {
                if (povol[j][i][k]) {
                    if (prvniCislo)
                        prvniCislo = 0;
                    else
                        putchar(' ');
                    putchar('1'+k);
                    cnt++;
                }
            }
            putchar(')');
            putchar(' ');
            putchar(' ');
            counter=counter*cnt;
        }
        putchar('\n');
    }
    printf("Kombinaci celkem: %g\n\n", counter);
}



/* ------------------------------------------------------------------ */
/* Funkce zavolana po startu konzolove aplikace                       */
/* ------------------------------------------------------------------ */
int main(void)
{
    int i, j, k;

    /* inicializace pracovni matice */
    for (j=0; j<9; j++)
        for (i=0; i<9; i++) {
            wrk[j][i]=src[j][i];
            if (wrk[j][i]==0) wrk[j][i]=1;
        }

    /* inicializace povol matice */
    for (j=0; j<9; j++) {
        for (i=0; i<9; i++) {
            for (k=0; k<9; k++) {
                povol[j][i][k]=1;
            }
        }
    }
    puts("Pocet kombinaci v nevyplnenych polickach:");
    vypisPovol();

    /* zruseni polozek v matici SRC */
    for (j=0; j<9; j++) {
        for (i=0; i<9; i++) {
            if (src[j][i]>0)
                for (k=0; k<9; k++) {
                    if (k+1!=src[j][i])
                        povol[j][i][k]=0;
                }
        }
    }

    testSloupce0();
    puts("Odstraneni jiz vyplnenych cislic ve sloupcich:");
    vypisPovol();

    testRadku0();
    puts("Odstraneni jiz vyplnenych cislic v radcich:");
    vypisPovol();

    testBloky0();
    puts("Odstraneni jiz vyplnenych cislic v blocich 3x3:");
    vypisPovol();

    /* inicializace minimalnich polozek */
    for (j=0; j<9; j++) {
        for (i=0; i<9; i++) {
            if (src[j][i]==0) { /* volna polozka */
                for (k=0; k<9; k++) {
                    if (povol[j][i][k]) {
                        minim[j][i]=k+1;
                        break;
                    }
                }
            }
        }
    }

    /* nastaveni prvnich volnych polozek */
    for (j=0; j<9; j++) {
        for (i=0; i<9; i++) {
            if (src[j][i]==0) /* volna polozka */
                wrk[j][i]=minim[j][i];
        }
    }

    puts("Mozne kombinace cisel:");
    vypisPovol();

    puts("Jdeme na to ... trpelivost ...");
    solve();

    return 0;
}



/* ------------------------------------------------------------------ */
/* finito                                                             */
/* ------------------------------------------------------------------ */

</pre>



<p><a name="k09"></a></p>
<h2 id="k09">9. </h2>

<p>Překladač Tiny C Compiler je slovy svých tvůrců přibližně devětkrát rychlejší než překladač GCC, a to dokonce za předpokladu, že GCC nebude provádět žádné optimalizace (výchozím stavem je tedy přepínač -O0). O tom, do jaké míry je či není toto tvrzení pravdivé, se ale raději přesvědčíme sami. V následujících třech tabulkách jsou zobrazeny časy překladu pro všechny tři výše zmíněné demonstrační příklady. Nejprve byl překlad proveden s využitím Tiny C Compileru, posléze byl použit GCC bez dalších voleb a poslední dva překlady proběhly taktéž s využitím překladače GCC, ovšem v tomto případě byly použity volby -O3 (optimalizace na rychlost výsledného kódu) a -Os (optimalizace na velikost výsledného kódu).</p>


<p><a name="k10"></a></p>
<h2 id="k10">10. </h2>



<p><a name="k11"></a></p>
<h2 id="k11">11. </h2>



<p><a name="k12"></a></p>
<h2 id="k12">12. </h2>



<p><a name="k13"></a></p>
<h2 id="k13">13. </h2>



<p><a name="k14"></a></p>
<h2 id="k14">14. </h2>



<p><a name="k15"></a></p>
<h2 id="k15">15. </h2>



<p><a name="k16"></a></p>
<h2 id="k16">16. </h2>



<p><a name="k17"></a></p>
<h2 id="k17">17. </h2>



<p><a name="k18"></a></p>
<h2 id="k18">18. </h2>



<p><a name="k19"></a></p>
<h2 id="k19">19. Repositář s&nbsp;demonstračními příklady</h2>



<p><a name="k20"></a></p>
<h2 id="k20">20. Odkazy na Internetu</h2>

<ol>

<li>Chibicc na GitHubu<br />
<a href="https://github.com/rui314/chibicc">https://github.com/rui314/chibicc</a>
</li>

<li>Původní domovská stránka Tiny C Compileru<br />
<a href="https://bellard.org/tcc/">https://bellard.org/tcc/</a>
</li>

<li>Tiny C Compiler na Wikipedii<br />
<a href="https://en.wikipedia.org/wiki/Tiny_C_Compiler">https://en.wikipedia.org/wiki/Tiny_C_Compiler</a>
</li>

<li>Repositář Tiny C Compileru<br />
<a href="https://repo.or.cz/w/tinycc.git">https://repo.or.cz/w/tinycc.git</a>
</li>

<li>Defending Against Compiler-Based Backdoors<br />
<a href="https://blog.regehr.org/archives/1241">https://blog.regehr.org/archives/1241</a>
</li>

<li>Reflections on Trusting Trust<br />
<a href="https://www.win.tue.nl/~aeb/linux/hh/thompson/trust.html">https://www.win.tue.nl/~aeb/linux/hh/thompson/trust.html</a>
</li>

<li>Coding Machines (povídka)<br />
<a href="https://www.teamten.com/lawrence/writings/coding-machines/">https://www.teamten.com/lawrence/writings/coding-machines/</a>
</li>

<li>Stage0<br />
<a href="https://bootstrapping.miraheze.org/wiki/Stage0">https://bootstrapping.miraheze.org/wiki/Stage0</a>
</li>

<li>Projekt stage0 na GitHubu<br />
<a href="https://github.com/oriansj/stage0">https://github.com/oriansj/stage0</a>
</li>

<li>Bootstraping wiki<br />
<a href="https://bootstrapping.miraheze.org/wiki/Main_Page">https://bootstrapping.miraheze.org/wiki/Main_Page</a>
</li>

<li>Bootstrapped 6502 Assembler<br />
<a href="https://github.com/robinluckey/bootstrap-6502">https://github.com/robinluckey/bootstrap-6502</a>
</li>

<li>IBM Basic assembly language and successors (Wikipedia)<br />
<a href="https://en.wikipedia.org/wiki/IBM_Basic_assembly_language_and_successors">https://en.wikipedia.org/wiki/IBM_Basic_assembly_language_and_successors</a>
</li>

<li>X86 Assembly/Bootloaders<br />
<a href="https://en.wikibooks.org/wiki/X86_Assembly/Bootloaders">https://en.wikibooks.org/wiki/X86_Assembly/Bootloaders</a>
</li>

<li>run6502, lib6502 — 6502 microprocessor emulator<br />
<a href="http://piumarta.com/software/lib6502/">http://piumarta.com/software/lib6502/</a>
</li>

<li>Simple Computer Simulator Instruction-Set<br />
<a href="http://www.science.smith.edu/dftwiki/index.php/Simple_Computer_Simulator_Instruction-Set">http://www.science.smith.edu/dftwiki/index.php/Simple_Computer_Simulator_Instruction-Set</a>
</li>

<li>Bootstrapping#Computing (Wikipedia)<br />
<a href="https://en.wikipedia.org/wiki/Bootstrapping#Computing">https://en.wikipedia.org/wiki/Bootstrapping#Computing</a>
</li>

<li>Bootstrapping (compilers)<br />
<a href="https://en.wikipedia.org/wiki/Bootstrapping_%28compilers%29">https://en.wikipedia.org/wiki/Bootstrapping_%28compilers%29</a>
</li>

<li>Bootstrapable Builds<br />
<a href="http://bootstrappable.org/">http://bootstrappable.org/</a>
</li>

<li>What is a coder's worst nightmare?<br />
<a href="https://www.quora.com/What-is-a-coders-worst-nightmare/answer/Mick-Stute">https://www.quora.com/What-is-a-coders-worst-nightmare/answer/Mick-Stute</a>
</li>

<li>Linux Assembly<br />
<a href="http://asm.sourceforge.net/">http://asm.sourceforge.net/</a>
</li>

<li>Tombstone diagram (Wikipedia)<br />
<a href="https://en.wikipedia.org/wiki/Tombstone_diagram">https://en.wikipedia.org/wiki/Tombstone_diagram</a>
</li>

<li>History of compiler construction (Wikipedia)<br />
<a href="https://en.wikipedia.org/wiki/History_of_compiler_construction">https://en.wikipedia.org/wiki/History_of_compiler_construction</a>
</li>

<li>Self-hosting (Wikipedia)<br />
<a href="https://en.wikipedia.org/wiki/Self-hosting">https://en.wikipedia.org/wiki/Self-hosting</a>
</li>

<li>GNU Mes: Maxwell Equations of Software<br />
<a href="https://gitlab.com/janneke/mes">https://gitlab.com/janneke/mes</a>
</li>

<li>Tiny C Compiler<br />
<a href="https://bellard.org/tcc/">https://bellard.org/tcc/</a>
</li>

<li>Welcome to C--<br />
<a href="https://www.cs.tufts.edu/~nr/c--/index.html">https://www.cs.tufts.edu/~nr/c--/index.html</a>
</li>

<li>c4 - C in four functions<br />
<a href="https://github.com/rswier/c4">https://github.com/rswier/c4</a>
</li>

<li>Tiny BASIC (Wikipedia)<br />
<a href="https://en.wikipedia.org/wiki/Tiny_BASIC">https://en.wikipedia.org/wiki/Tiny_BASIC</a>
</li>

<li>David A. Wheeler’s Page on Fully Countering Trusting Trust through Diverse Double-Compiling (DDC) - Countering Trojan Horse attacks on Compilers<br />
<a href="https://www.dwheeler.com/trusting-trust/">https://www.dwheeler.com/trusting-trust/</a>
</li>

<li>Reviewing Microsoft's Automatic Insertion of Telemetry into C++ Binaries<br />
<a href="https://www.infoq.com/news/2016/06/visual-cpp-telemetry">https://www.infoq.com/news/2016/06/visual-cpp-telemetry</a>
</li>

<li>Visual Studio adding telemetry function calls to binary?<br />
<a href="https://www.reddit.com/r/cpp/comments/4ibauu/visual_studio_adding_telemetry_function_calls_to/d30dmvu/">https://www.reddit.com/r/cpp/comments/4ibauu/visual_studio_adding_telemetry_function_calls_to/d30dmvu/</a>
</li>

<li>LWN - The Trojan Horse<br />
<a href="https://www.dwheeler.com/trusting-trust/spencer-19981123.txt">https://www.dwheeler.com/trusting-trust/spencer-19981123.txt</a>
</li>

<li>reproducible-builds.org<br />
<a href="https://reproducible-builds.org/">https://reproducible-builds.org/</a>
</li>

<li>Other Assemblers<br />
<a href="http://asm.sourceforge.net/howto/other.html">http://asm.sourceforge.net/howto/other.html</a>
</li>

<li>Projekt bootstrap<br />
<a href="https://github.com/ras52/bootstrap">https://github.com/ras52/bootstrap</a>
</li>

<li>Projekt bcompiler<br />
<a href="https://github.com/certik/bcompiler">https://github.com/certik/bcompiler</a>
</li>

<li>Zadní vrátka<br />
<a href="https://cs.wikipedia.org/wiki/Zadn%C3%AD_vr%C3%A1tka#Reflections_on_Trusting_Trust">https://cs.wikipedia.org/wiki/Zadn%C3%AD_vr%C3%A1tka#Reflections_on_Trusting_Trust</a>
</li>

<li>David A. Wheeler’s Personal Home Page<br />
<a href="https://www.dwheeler.com/">https://www.dwheeler.com/</a>
</li>

<li>David A. Wheeler<br />
<a href="https://en.wikipedia.org/wiki/David_A._Wheeler">https://en.wikipedia.org/wiki/David_A._Wheeler</a>
</li>

<li>Multics Security Evaluation: Vulnerability Analysis<br />
<a href="http://csrc.nist.gov/publications/history/karg74.pdf">http://csrc.nist.gov/publications/history/karg74.pdf</a>
</li>

<li>Reflections on Rusting Trust<br />
<a href="https://manishearth.github.io/blog/2016/12/02/reflections-on-rusting-trust/">https://manishearth.github.io/blog/2016/12/02/reflections-on-rusting-trust/</a>
</li>

<li>Reflections on Trusting Trust for Go (slajdy)<br />
<a href="https://www.slideshare.net/yeokm1/reflections-on-trusting-trust-for-go">https://www.slideshare.net/yeokm1/reflections-on-trusting-trust-for-go</a>
</li>

<li>Reflections on Trusting Trust for Go (zdrojové materiály)<br />
<a href="https://github.com/yeokm1/reflections-on-trusting-trust-go">https://github.com/yeokm1/reflections-on-trusting-trust-go</a>
</li>

<li>Reflections on Trusting Trust for Go - GopherConSG 2018<br />
<a href="https://www.youtube.com/watch?v=T82JttlJf60">https://www.youtube.com/watch?v=T82JttlJf60</a>
</li>

<li>Reproducing Go binaries byte-by-byte<br />
<a href="https://blog.filippo.io/reproducing-go-binaries-byte-by-byte/">https://blog.filippo.io/reproducing-go-binaries-byte-by-byte/</a>
</li>

<li>Trojský kůň<br />
<a href="https://cs.wikipedia.org/wiki/Trojsk%C3%BD_k%C5%AF%C5%88_%28program%29">https://cs.wikipedia.org/wiki/Trojsk%C3%BD_k%C5%AF%C5%88_%28program%29</a>
</li>

</ol>



<p></p><p></p>
<p><small>Autor: <a href="http://www.fit.vutbr.cz/~tisnovpa">Pavel Tišnovský</a> &nbsp; 2022</small></p>
</body>
</html>

