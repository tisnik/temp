<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
        "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html>
<head>
<title>Specializované jazyky pro práci s N-dimenzionálními poli: jazyk J</title>
<meta name="Author" content="Pavel Tisnovsky" />
<meta name="Generator" content="vim" />
<meta http-equiv="content-type" content="text/html; charset=utf-8" />
<style type="text/css">
         body {color:#000000; background:#ffffff;}
         h1  {font-family: arial, helvetica, sans-serif; color:#ffffff; background-color:#c00000; text-align:center; padding-left:1em}
         h2  {font-family: arial, helvetica, sans-serif; color:#ffffff; background-color:#0000c0; padding-left:1em; text-align:left}
         h3  {font-family: arial, helvetica, sans-serif; color:#000000; background-color:#c0c0c0; padding-left:1em; text-align:left}
         h4  {font-family: arial, helvetica, sans-serif; color:#000000; background-color:#e0e0e0; padding-left:1em; text-align:left}
         a   {font-family: arial, helvetica, sans-serif;}
         li  {font-family: arial, helvetica, sans-serif; color:#000000; text-align:justify; width:450px;}
         ol  {font-family: arial, helvetica, sans-serif; color:#000000; text-align:justify; width:450px;}
         ul  {font-family: arial, helvetica, sans-serif; color:#000000; text-align:justify; width:450px;}
         p   {font-family: arial, helvetica, sans-serif; color:#000000; text-align:justify;}
         pre {background:#e0e0e0}
</style>
</head>

<body>

<h1>Specializované jazyky pro práci s N-dimenzionálními poli: jazyk J</h1>

<h3>Pavel Tišnovský</h3>

<p></p>

<h1>Úvodník</h1>

<p>Na úvodní článek o programovacích jazycích určených pro provádění operací s poli dnes navážeme. Zatímco minule jsme se zabývali především univerzálními jazyky, dnes se zaměříme na programovací jazyk J, který je přímo určen pro práci s poli jedná se o skvělý doménově specifický jazyk.</p>



<h2>Obsah</h2>

<p><a href="#k01">1. Specializované jazyky pro práci s&nbsp;N-dimenzionálními poli: jazyk J</a></p>
<p><a href="#k02">2. Od APL k&nbsp;programovacímu jazyku J</a></p>
<p><a href="#k03">3. Překlad interpretru jazyka J</a></p>
<p><a href="#k04">4. Zápis programů v&nbsp;jazyku J</a></p>
<p><a href="#k05">5. Atomy a N-dimenzionální pole v&nbsp;programovacím jazyku J</a></p>
<p><a href="#k06">6. Primitivní funkce jazyka J</a></p>
<p><a href="#k07">7. Pravidla pro pojmenování primitivních funkcí</a></p>
<p><a href="#k08">8. Vyhodnocování aritmetických a logických výrazů</a></p>
<p><a href="#k09">9. Operace s&nbsp;vektory v&nbsp;programovacím jazyku J</a></p>
<p><a href="#k10">10. Základní aritmetické funkce aplikované na vektory</a></p>
<p><a href="#k11">11. Výběr prvků z&nbsp;vektorů (selektory)</a></p>
<p><a href="#k12">12. Konstrukce vektorů založená na generátorech (indexů)</a></p>
<p><a href="#k13">13. Matice</a></p>
<p><a href="#k14">14. Výběr prvků z&nbsp;matic</a></p>
<p><a href="#k15">15. Predikáty pracující s&nbsp;atomy, vektory i maticemi</a></p>
<p><a href="#k16">16. Různé způsoby spojení polí</a></p>
<p><a href="#k17">17. Pokročilejší operace nad poli</a></p>
<p><a href="#k18">18. Operátor <strong>/</strong> (reduce)</a></p>
<p><a href="#k19">*** 19. Dyadická forma operátoru <strong>/</strong></a></p>
<p><a href="#k20">20. Odkazy na Internetu</a></p>



<p><a name="k01"></a></p>
<h2 id="k01">1. Specializované jazyky pro práci s&nbsp;N-dimenzionálními poli: jazyk J</h2>

<p><i>&bdquo;It is easier to learn enough Basic or Java to solve trivial
problems, but it is easier to learn enough J to solve more interesting and
challenging problems.&ldquo;</i></p>

<p>Na <a
href="https://www.root.cz/clanky/jazyky-umoznujici-operace-s-poli-aneb-rozsahly-svet-bdquo-array-programmingu-ldquo/">úvodní
článek</a> o programovacích jazycích určených pro provádění operací s&nbsp;poli
dnes navážeme. Zatímco minule jsme se zabývali především univerzálními jazyky,
dnes se zaměříme na programovací jazyk <i>J</i>, který je přímo určen pro práci
s&nbsp;poli (a lze ho považovat za skvělý doménově specifický jazyk). Jedná se
o ideového pokračovatele jazyka APL, takže v&nbsp;žádném případě nečekejte
&bdquo;mainstreamový&ldquo; přístup. Je tomu naopak, protože prakticky všechny
operace a funkce se zapisují odlišně, než je tomu v&nbsp;běžnějších
programovacích jazycích. V&nbsp;rámci dnešního článku si taktéž odpovíme na
dotazy zmíněné minule: </p>

<ol>

<li>Kolik dimenzí může pole mít? Typicky 1 a 2, někdy i více.</li>

<li>Začínají indexy prvků od 0, 1 či je první index volitelný?</li>

<li>Jsou podporována obdélníková pole nebo nepravidelná pole?</li>

<li>Jsou jednotlivé osy na sobě nezávislé? (což vylučuje nepravidelná
pole)</li>

<li>Je možné indexy na jednotlivých osách pojmenovat? (a vytvořit tak vlastně
datový rámec)</li>

<li>Jedná se o homogenní nebo o heterogenní datovou strukturu? Homogenní
struktura může uchovávat prvky jediného (typicky předem definovaného) typu
zatímco v&nbsp;heterogenní struktuře mohou být umístěny prvky různých
typů.</li>

<li>Je nějakým způsobem omezen datový typ prvků pole? (například jen na celá
čísla a čísla reálná).</li>

<li>Lze prvky pole měnit (<i>mutable</i>) nebo je pole neměnitelné
(<i>immutable</i>).</li>

<li>Pokud jsou pole heterogenní a měnitelná, může prvek pole obsahovat to samé
pole?</li>

<li>Obsahuje pole přímo hodnoty prvků nebo jen reference na prvky?</li>

<li>Jsou prvky v&nbsp;poli uloženy v&nbsp;operační paměti za sebou nebo se
jedná o strukturu s&nbsp;ukazateli?</li>

<li>Jsou prvky v&nbsp;2D poli uloženy po řádcích nebo po sloupcích? (C versus
Fortran).</li>

<li>Lze měnit tvar (<i>shape</i>) pole?</li>

<li>Podporuje jazyk operace nad celými poli?</li>

<li>Podporuje jazyk takzvaný <i>broadcasting</i> (aplikaci skaláru na všechny
prvky pole atd.)?</li>

<li>Jsou pole plnohodnotným datovým typem nebo speciální strukturou?</li>

<li>Je podporován &bdquo;literál typu pole&ldquo;?</li>

</ol>

<p><div class="rs-tip-major">Poznámka: i když se to nezdá, spočívá největší
nevýhoda programovacího jazyka J v&nbsp;tom, že pokud se vývojář seznámí se
způsobem práce s&nbsp;poli v&nbsp;tomto jazyku, bude v&nbsp;běžných
(mainstreamových) jazycích doslova trpět při řešení problémů z&nbsp;této
oblasti.</div></p>



<p><a name="k02"></a></p>
<h2 id="k02">2. Od APL k&nbsp;programovacímu jazyku J</h2>

<p><i>&bdquo;Real Programmers don't write in APL, unless the whole program can
be written on one line&ldquo;</i></p>

<p>Historie programovacího jazyka <i>APL</i>, s&nbsp;nímž jsme se seznámili již
<a
href="https://www.root.cz/clanky/oslava-55-let-od-vzniku-prvni-implementace-programovaciho-jazyka-apl/">v&nbsp;tomto
článku</a>, se začala psát již v&nbsp;roce 1957. Právě tehdy <i>Kenneth E.
Iverson</i>, který v&nbsp;té době pracoval na Harvardské universitě, navrhl
zcela novou notaci určenou pro jednotný zápis matematických funkcí i pro tvorbu
funkcí nových. Tato notace byla prakticky ve všech ohledech odlišná od zavedené
notace (resp.&nbsp;přesněji řečeno) notací, které se v&nbsp;matematice
používaly. V&nbsp;roce 1962 byla tato notace popsána v&nbsp;knize nazvané
&bdquo;A Programming Language&ldquo; a (což původně vlastně ani nebylo
plánováno) o několik let později se začaly objevovat skutečné interpretry i
překladače programovacího jazyka používajícího stejné symboly, jaké popsal
Iverson ve své knize. Konkrétně se jednalo o jazyk nazvaný <i>IVSYS</i>, který
byl implementovaný v&nbsp;roce 1966 (což ovšem ještě nebyl <i>skutečný</i> APL,
který byl následován jazykem <i>APL\360</i> z&nbsp;roku 1966 a poté jazykem
<i>APL\1130</i> z&nbsp;roku 1968, jenž pracoval na počítači <i>IBM
1130</i>.</p>

<p>Kenneth Iverson se rozvoji a propagaci jazyka <i>APL</i> aktivně věnoval
více než 20 let, za což mu poprávu byla v&nbsp;roce 1979 udělena Turingova cena
(<i>Turing Award</i>). Později Iverson navrhl programovací jazyk <i>J</i>,
v&nbsp;němž se místo speciálních symbolů používají pouze znaky obsažené
v&nbsp;ASCII tabulce (viz další kapitoly s&nbsp;podrobnějšími informacemi).
Vraťme se však k&nbsp;<i>APL</i>. Specifikace tohoto programovacího jazyka se
od poloviny šedesátých let minulého století několikrát změnila (rozšířila).
Jedním z&nbsp;nejvíce důležitých rozšíření je <i>APL2</i> od J.&nbsp;Browna
z&nbsp;IBM, které do jazyka zavedlo podporu pro rekurzivní datové struktury
(tedy, jak uvidíme dále, pro pole jako prvky jiných polí, což je mimochodem
dále zobecněno v&nbsp;jazyku <i>BQN</i> a vlastně i v&nbsp;jazyku <i>J</i>).
Většina dnešních implementací tohoto programovacího jazyka se snaží dodržovat
specifikaci <i>APL2</i>, i když je jazyk dále rozšiřován (například
v&nbsp;<i>APLX verze 4</i> byla přidána podpora pro objektově orientované
programování, i když v&nbsp;poněkud jiné podobě, než ji známe
z&nbsp;mainstreamových programovacích jazyků). Z&nbsp;moderních implementací
APL se pak musíme zmínit o komerčním projektu <i>Dyalog APL</i>.</p>

<p>Nesmíme ovšem ignorovat fakt, že i přes všechny zajímavé rysy má
programovací jazyk <i>APL</i> i několik nectností, ostatně jako každý
programovací jazyk, který vznikl na samotném začátku vývoje interpretrů a
překladačů, tj.&nbsp;v&nbsp;době, kdy ještě nebyla teorie překladačů tak
rozvinutá jako v&nbsp;pozdějších letech (nejvíce byla neexistence teorie
překladačů patrná u prvního překladače <i>Fortranu</i> vytvořeného firmou IBM,
jehož vývoj by byl při uplatnění dnešních znalostí mnohem rychlejší, levnější,
samozřejmě i samotný jazyk by vypadal poněkud jinak). Už při letmém pohledu na
algoritmy resp.&nbsp;celé programy napsané v&nbsp;programovacím jazyce
<i>APL</i> je zřejmé, že se v&nbsp;něm používá velké množství symbolů, které se
nenachází ve znakové sadě ASCII, což je sice velmi unikátní vlastnost (právě
proto mnozí v&nbsp;<i>APL</i> programují čistě pro radost z&nbsp;vizuální
podoby programů), ale způsobuje poměrně velké problémy, jak při zápisu programů
(rozložení znaků na klávesnici), tak i při jejich úpravách, prezentaci na
Internetu (zdaleka ne všechny fonty obsahují všechny požadované symboly)
atd.</p>

<p><div class="rs-tip-major">Poznámka: ve skutečnosti jsou tyto problémy do
značné míry již vyřešeny, protože <a
href="http://xahlee.info/comp/unicode_APL_symbols.html">znaky jazyka APL byl
přidány do Unicode</a>.</div></p>

<p>Některé nedostatky programovacího jazyka <i>APL</i> jsou obsaženy i
v&nbsp;jeho samotné sémantice, což je mnohem závažnější, než
&bdquo;pouhý&ldquo; vzhled zápisu nebo problémy při tisku nebo prezentacích.
Jmenujme například zápis řídicích struktur s&nbsp;využitím čísel řádků (podobně
jako v&nbsp;BASICu, i když čísla řádků jsou v&nbsp;<i>APL</i> pro každou funkci
lokální, což například znemožňuje provádět skoky dovnitř funkcí o odstraňuje
vzájemnou závislost jednotlivých funkcí). A taktéž se ukázalo, že by bylo
vhodné, aby byl do mnohem větší míry podporován <i>tacit programming</i>, jímž
jsme se zabývali <a
href="https://www.root.cz/clanky/programovaci-technika-nazvana-tacit-programming/">v&nbsp;samostatném
článku</a>. Z&nbsp;výše uvedených důvodů otec jazyka <i>APL</i> (již zmiňovaný
<i>Kenneth Iverson</i>) na počátku devadesátých let minulého století navrhl
nový programovací jazyk nazvaný jednoduše <i>J</i>, který některé výše zmíněné
nedostatky jazyka <i>APL</i> odstranil a navíc tento nový programovací jazyk
rozšířil o některé důležité nové rysy, primitivní funkce i operátory.
V&nbsp;dalších kapitolách si stručně popíšeme zejména ty vlastnosti jazyka
<i>J</i>, které souvisí se zpracováním polí a vůbec k&nbsp;přístupu k&nbsp;této
velmi důležité datové struktuře.</p>

<p><div class="rs-tip-major">Poznámka: na tomto místě je pro úplnost nutno
dodat, že moderní dialekty jazyka APL už vyřešily většinu výše zmíněných
problémů. Moderní APL se tedy v&nbsp;tomto ohledu přiblížilo k&nbsp;jazyku J,
kterým se budeme zabývat dnes (což se týká i podpory pro tacit programming
apod.).</div></p>



<p><a name="k03"></a></p>
<h2 id="k03">3. Překlad interpretru jazyka J</h2>

<p>Na stránce <a href="http://www.jsoftware.com">http://www.jsoftware.com</a>
jsou nabízeny balíčky s&nbsp;interpretrem jazyka <i>J</i> určené pro všechny
tři nejrozšířenější desktopové operační systémy. Po instalaci (která
v&nbsp;případě Linuxu spočívá v&nbsp;prostém spuštění staženého skriptu
s&nbsp;parametrem <tt>-install</tt>) se nainstaluje jak interpret
programovacího jazyka <i>J</i> (představovaného knihovnou <i>libj.so</i> popř.
<i>j.dll</i>), tak i konzolové (řádkové) rozhraní k&nbsp;interpretru
(<i>jconsole</i>) a vývojové prostředí naprogramované původně v&nbsp;Javě
(<i>jwd</i>), dnes dostupné přes webové rozhraní.  Pro odzkoušení
demonstračních programů postačuje spustit řádkové rozhraní interpretru jazyka
<i>J</i> z&nbsp;terminálu resp.&nbsp;z&nbsp;konzole &ndash; jedná se o program
nazvaný <i>jconsole</i>.</p>

<p><div class="rs-tip-major">Poznámka: pozor &ndash; tento program je nutné
spustit s&nbsp;uvedením cesty, například <tt>./jconsole</tt>, v&nbsp;opačném
případě by se mohla spustit stejnojmenná utilita dodávaná spolu
s&nbsp;JDK.</div></p>

<p>Protože se však nacházíme na Rootu, ukážeme si, jakým způsobem je možné
konzoli s&nbsp;interpretrem programovacího jazyka J přeložit přímo ze
zdrojových kódů. Projekt s&nbsp;jazykem J totiž po velmi dlouhé době, kdy se
jednalo o projekt dosti izolovaný od ostatního světa a s&nbsp;relativně
uzavřenou a malou komunitou, nabízí zdrojové kódy dostupné přes GitHub a
přeložitelné jednoduše z&nbsp;příkazové řádky.</p>

<p>Celý postup překladu je jednoduchý. Nejdříve je nutné naklonovat repositář
se zdrojovými kódy (kombinace C a J):</p>

<pre>
$ <strong>git clone git@github.com:jsoftware/jsource.git</strong>
</pre>

<p>Dále se v&nbsp;podadresáři <strong>make2</strong> spustí skript nazvaný
<strong>build_all</strong>:</p>

<pre>
$ <strong>cd make2</strong>
$ <strong>./build_all</strong>
</pre>

<p>Překlad je ve výchozím nastavení prováděn v&nbsp;jediném vláknu, ovšem ani
tak netrvá dlouho. Po dokončení činnosti skriptu <strong>build_all</strong> by
se měl v&nbsp;podadresáři <strong>bin/linux/j64avx</strong> objevit jak
interpret (představovaný knihovnou), tak i aplikace <strong>jconsole</strong>,
která interpret jazyka J spustí:</p>

<pre>
$ <strong>cd ..</strong>
</pre>

<p>O výsledku překladu se snadno přesvědčíme:</p>

<pre>
$ <strong>ls -la bin/linux/j64avx/</strong>
&nbsp;
total 4192
drwxrwxr-x 2 ptisnovs ptisnovs     100 Dec  6 19:54 .
drwxrwxr-x 3 ptisnovs ptisnovs      60 Dec  6 19:46 ..
-rwxrwxr-x 1 ptisnovs ptisnovs   57184 Dec  6 19:52 jconsole
-rwxrwxr-x 1 ptisnovs ptisnovs 4201104 Dec  6 19:54 libj.so
-rwxrwxr-x 1 ptisnovs ptisnovs   31984 Dec  6 19:54 libtsdll.so
</pre>

<p>Samotný interpret je možné spustit takto:</p>

<pre>
$ <strong>bin/linux/j64avx/jconsole</strong>
</pre>

<a href="http://i.iinfo.cz/images/25/j-lang1-4.png"><img src="http://i.iinfo.cz/images/25/j-lang1-4-prev.png" width="370" height="265" alt="j_lang1_4" /></a>
<p><i>Obrázek 1: Původní vývojové prostředí (vytvořené v&nbsp;Javě) dodávané
spolu s&nbsp;interpretrem programovacího jazyka J.</i></p>



<p><a name="k04"></a></p>
<h2 id="k04">4. Zápis programů v&nbsp;jazyku J</h2>

<p>Nyní, když již máme k&nbsp;dispozici interpret jazyka J, si můžeme prakticky
vyzkoušet některé jeho vlastnosti. Nejprve si řekneme, jak vypadá struktura
zapsaných programů. Způsob zápisu programů v&nbsp;programovacím jazyku <i>J</i>
se v&nbsp;mnoha ohledech podobá zápisu používaném v&nbsp;programovacím jazyku
<i>APL</i>. Na každém textovém řádku je (tedy většinou &ndash; pokud je autor
při smyslech) zapsán jeden výraz, který je interpretrem ihned po svém zápisu
zpracován a vyhodnocen. V&nbsp;případě, že je výraz zapsaný
v&nbsp;interaktivním režimu (například z&nbsp;aplikace <i>jconsole</i>), je
výsledek výrazu ihned po jeho vyhodnocení vytištěn na terminál &ndash; právě
tento způsob práce, který je ostatně společný většině interpretovaných
programovacích jazyků, budeme používat ve všech následujících demonstračních
příkladech (příkazy zadávané uživatelem jsou pro odlišení zpráv interpretru
odsazeny od levého okraje, což je implicitní chování nástroje <i>jconsole</i>;
taktéž jsou příkazy zadávané uživatelem zvýrazněny pomocí tučného písma).</p>

<p>Zajímavý a nutno říci, že i dosti neobvyklý je i zápis komentářů.
V&nbsp;mnoha programovacích jazycích se pro označení začátku jednořádkových
komentářů používá speciální znak či znaky. Například v&nbsp;<i>C++</i>,
<i>Javě</i> či <i>JavaScriptu</i> se jedná o dvojici znaků &bdquo;//&ldquo;
(nebo o &bdquo;komentářové závorky&ldquo; /* a */ pro víceřádkové komentáře) a
v&nbsp;shellu i Pythonu o jeden znak &bdquo;#&ldquo;. V&nbsp;programovacím
jazyku <i>J</i> je ovšem vše jinak. Zde se totiž začátek komentáře označuje
trojicí znaků &bdquo;NB.&ldquo;. Veškerý text na řádku zapsaný za těmito znaky
je interpretrem ignorován. To tedy znamená, že můžeme psát:</p>

<pre>
   <i>NB. komentar umisteny na zacatku programoveho radku</i>
&nbsp;
   <strong>1+2*3</strong> <i>NB. komentar umisteny za vyrazem, samotny vyraz se vykona a vypise se jeho vysledek</i>
7
   <i>NB. tento vyraz se nevykona, nebot je soucasti komentare: 1+2*3</i>
</pre>

<p><div class="rs-tip-major">Poznámka: způsob zápisu komentářů v&nbsp;různých
programovacích jazycích je shrnut na stránce <a
href="http://www.gavilan.edu/csis/languages/comments.html">http://www.gavilan.edu/csis/languages/comments.html</a>.</div></p>



<p><a name="k05"></a></p>
<h2 id="k05">5. Atomy a N-dimenzionální pole v&nbsp;programovacím jazyku J</h2>

<p>V&nbsp;programovacím jazyku J se primárně rozlišují dvě skupiny typů hodnot.
První skupinu tvoří <i>atomy</i> (<i>atom</i>), druhou skupinu pak <i>pole</i>
(<i>array</i>). Atomy neboli skaláry je skupina tvořená třemi datovými
typy:</p>

<ol>
<li>numerický typ</li>
<li>znakový typ</li>
<i><i>box</i></i>
</ol>

<p>Nejzajímavějším atomárním neboli skalárním datovým typem je <i>box</i>.
Tento název je velmi přiléhavý, protože se skutečně jedná o jakýsi obal, který
může obsahovat libovolnou jinou hodnotu &ndash; ať již skalární, tak i pole.
Díky existenci <i>boxů</i> je sice typový systém programovacího jazyka J
poměrně flexibilní, ovšem ukazuje se, že komplikuje práci s&nbsp;poli. Proto je
například v&nbsp;jazyku <i>BQN</i>, který je ideovým pokračovatelem APL i J,
použit odlišný typový systém.</p>

<p>Ústředním prvkem jazyka J jsou ovšem &ndash; jak lze snadno uhodnout &ndash;
<i>pole</i>. Na pole se můžeme dívat jako na skupinu atomů organizovaných podél
os (<i>axes</i>), přičemž počet os určuje dimenzi pole. Os přitom může být
(prakticky) libovolný počet &ndash; J tedy nemá žádná omezení, která jsme mohli
vidět například v&nbsp;BBC BASICU či v&nbsp;Dartmouth BASICu. Další důležitou
vlastností polí je, že jsou <i>homogenní</i>, tj.&nbsp;obsahují prvky stejného
typu (nebo boxy). A navíc jsou pole měnitelná, neboli <i>mutable</i> &ndash;
prvky polí je tedy možné modifikovat. Od jazyka APL se J odlišuje v&nbsp;tom,
že se prvky podél os indexují od nuly a nikoli od jedničky, což si ukážeme na
demonstračních příkladech.</p>

<p>Pole s&nbsp;počtem dimenzí (resp.&nbsp;os) 1 až 3 mají v&nbsp;jazyku J
specifické názvy:</p>

<table>
<tr><th>Počet dimenzí/os</th><th>Název pole</th></tr>
<tr><td>1</td><td>list</td></tr>
<tr><td>2</td><td>table</td></tr>
<tr><td>3</td><td>brick</td></tr>
</table>

<p><div class="rs-tip-major">Poznámka: pozor na to, že seznam s&nbsp;jediným
prvkem se striktně odlišuje od skaláru!</div></p>

<p>Pole s&nbsp;jednou, dvěma a třemi osami lze vytvořit funkcí
<strong>i.</strong>, která zhruba odpovídá generátoru <strong>range</strong>
z&nbsp;Pythonu, ovšem s&nbsp;tím, rozdílem, že počet os a tvar pole je
volitelný:</p>

<pre>
   <strong>i. 3</strong>
0 1 2
&nbsp;
   <strong>i. 2 3</strong>
0 1 2
3 4 5
&nbsp;
   <strong>i. 2 3 4</strong>
 0  1  2  3
 4  5  6  7
 8  9 10 11
&nbsp;
12 13 14 15
16 17 18 19
20 21 22 23
</pre>

<p>Přečtení tvaru pole &ndash; seznamu obsahujícího počet atomů podél každé osy
funkcí <strong>$</strong> (<i>shape</i>):</p>

<pre>
   <strong>$ 42</strong>
&nbsp;
&nbsp;
   <strong>$ 1 2 3</strong>
3
&nbsp;
   <strong>$ i. 2 3</strong>
2 3
&nbsp;
   <strong>$ i. 2 3 4</strong>
2 3 4
&nbsp;
   <strong>$ (&lt;'abc'),(&lt;1;2;3),(&lt;1;2)</strong>
3
</pre>

<p>Získání počtu os monadickou funkcí <strong>#</strong> (<i>rank</i>)
zkombinovanou s&nbsp;<strong>#</strong>:</p>

<pre>
   <strong># $ 42</strong>
0
&nbsp;
   <strong># $ 1 2 3</strong>
1
&nbsp;
   <strong># $ 1 2 3 4</strong>
1
&nbsp;
   <strong># $ i. 2 3</strong>
2
&nbsp;
   <strong># $ i. 2 3 4</strong>
3
&nbsp;
   <strong># $ (&lt;'abc'),(&lt;1;2;3),(&lt;1;2)</strong>
1
</pre>

<p>Víme již, že pole musí být homogenní, což je podmínka, kterou lze
&bdquo;obejít&ldquo; použitím boxů. Termínem <i>boxing</i> se označuje
vytvoření atomu (boxu), jehož obsah je prakticky libovolný, tedy může se
vytvořit homogenní pole boxů. Samozřejmě jsou ovšem nutná nějaká omezení,
protože box není numerickým typem a tudíž ho nelze použít v&nbsp;aritmetických
operacích. Box je ovšem možné otevřít (<i>open</i>) a získat tak jeho
obsah.</p>

<p>Vytvoření boxu &ndash; zabalení hodnoty:</p>

<pre>
   <strong>(&lt;'abc')</strong>
+---+
|abc|
+---+
</pre>

<p><div class="rs-tip-major">Poznámka: už víte, proč se používá termín
&bdquo;box&ldquo;?</div></p>

<p>Spojení dvou boxů do vektoru:</p>

<pre>
   <strong>(&lt;'abc'),(&lt;1 2 3)</strong>
+---+-----+
|abc|1 2 3|
+---+-----+
</pre>

<p>Box jako prvek pole s&nbsp;boxy:</p>

<pre>
   <strong>(&lt;'abc'),(&lt;1 2 3),(&lt;1;2)</strong>
+---+-----+-----+
|abc|1 2 3|+-+-+|
|   |     ||1|2||
|   |     |+-+-+|
+---+-----+-----+
&nbsp;
   <strong>(&lt;'abc'),(&lt;1;2;3),(&lt;1;2)</strong>
+---+-------+-----+
|abc|+-+-+-+|+-+-+|
|   ||1|2|3|||1|2||
|   |+-+-+-+|+-+-+|
+---+-------+-----+
</pre>

<p>A konečně si ukažme funkci <i>amend</i>, která dokáže změnit obsah vybraného
prvku pole:</p>

<pre>
   <strong>100 (&lt; 2) } i. 10</strong>
0 1 100 3 4 5 6 7 8 9
</pre>



<p><a name="k06"></a></p>
<h2 id="k06">6. Primitivní funkce jazyka J</h2>

<p>Podobně jako v&nbsp;programovacím jazyku <i>APL</i>, nalezneme i v&nbsp;dnes
popisovaném jazyku <i>J</i> poměrně velké množství primitivních (neboli
základních) funkcí. Ty však nejsou reprezentovány speciálními symboly
(&bdquo;hieroglyfy&ldquo;), ale jedním nebo větším množstvím nealfanumerických
ASCII znaků, takže jejich zápis i editace je jednodušší, než tomu bylo
v&nbsp;případě <i>APL</i> (na druhou stranu nevypadají zapsané algoritmy tak
efektně a možná i elegantně :-). Primitivní funkce mohou akceptovat buď jeden
parametr (to jsou takzvané <i>monadické funkce</i>) nebo parametry dva
(<i>funkce dyadické</i>). Název monadických funkcí je uveden
v&nbsp;<i>prefixové</i> podobě, tj.&nbsp;vždy před svým parametrem, zatímco
dyadické funkce jsou zapisovány v&nbsp;podobě infixové &ndash; mezi oběma
parametry, čímž se efektivně v&nbsp;mnoha případech eliminuje nutnost použití
závorek (ty jsou ovšem taktéž podporovány). Znaky, kterými jsou primitivní
funkce pojmenovány, jsou většinou použity minimálně dvakrát &ndash; jednou pro
zápis monadické funkce, podruhé pro zápis funkce dyadické, jejíž význam bývá
v&nbsp;menší či větší míře podobný příslušné monadické funkci.</p>

<p><div class="rs-tip-major">Poznámka: na monadické i dyadické funkce se taktéž
můžeme dívat jako na operátory, protože se ostatně jako operátory zapisují
&ndash; buď před operand nebo mezi oba operandy.</div></p>

<a href="http://i.iinfo.cz/images/72/j-lang1-5.png"><img src="http://i.iinfo.cz/images/72/j-lang1-5-prev.png" width="370" height="265" alt="j_lang1_5" /></a>
<p><i>Obrázek 2: Interpret jazyka J je poměrně bohatě vybaven i možností práce
s&nbsp;různými typy grafů, což je (spolu s&nbsp;podporou snadné práce
s&nbsp;vektory a maticemi) jeden z&nbsp;důvodů poměrně velké oblíbenosti tohoto
jazyka mezi inženýry.</i></p>



<p><a name="k07"></a></p>
<h2 id="k07">7. Pravidla pro pojmenování primitivních funkcí</h2>

<p>Kromě použití stejného znaku pro pojmenování nějaké primitivní monadické a
současně i dyadické funkce může být navíc za znakem představujícím jméno
primitivní funkce uveden symbol &bdquo;:&ldquo; (dvojtečka) nebo
&bdquo;.&ldquo; (tečka), což v&nbsp;praxi znamená, že tentýž znak může být ve
skutečnosti použit pro pojmenování až šesti různých primitivních funkcí.
Například pro znak &bdquo;&lt;&ldquo; existuje celkem pět různých forem, které
byly Iversonem a jeho kolegy při návrhu jazyka <i>J</i> zvoleny takovým
způsobem, aby buď přímo odpovídaly významu tohoto znaku v&nbsp;matematickém
zápisu, nebo měly alespoň logicky podobný význam. Zmíněný znak je (nejenom)
v&nbsp;matematice spojen se slovem &bdquo;menší&ldquo;, takže je použit i pro
implementaci funkce vyhledání minima či dekrementaci/zmenšení operandu o
jedničku, jak je to ostatně patrné z&nbsp;následujících výrazů a jejich
výsledku po vyhodnocení interpretrem programovacího jazyka <i>J</i>
(v&nbsp;příkladech jsou jako parametry použity i vektory):</p>

<pre>
   <i>NB. dyadicka funkce &lt;</i>
   <i>NB. porovnani dvou hodnot na relaci "mensi nez"</i>
   <strong>1 &lt; 2</strong>
1
   <strong>2 &lt; 2</strong>
0
&nbsp;
   <i>NB. porovnavat lze i slozky vektoru, vysledkem bude bitovy vektor</i>
   <strong>1 2 3 &lt; 3 2 1</strong>
1 0 0
&nbsp;
   <i>NB. Dyadicka funkce ukoncena dvojteckou</i>
   <i>NB. porovnani dvou hodnot na relaci "mensi nebo rovno"</i>
   <strong>1 &lt;: 2</strong>
1
   <strong>2 &lt;: 2</strong>
1
   <i>NB. opet lze porovnavat i slozky vektoru</i>
   <strong>1 2 3 &lt;: 3 2 1</strong>
1 1 0
&nbsp;
   <i>NB. dyadicka funkce ukoncena teckou</i>
   <i>NB. vrati mensi operand (parametr) = odpovida funkci min</i>
   <strong>1 &lt;. 2</strong>
1
   <strong>2 &lt;. 1</strong>
1
   <i>NB. porovnani prislusnych slozek vektoru a vraceni mensi z nich</i>
   <strong>1 2 1 &lt;: 3 2 1</strong>
1 2 1
&nbsp;
   <i>NB. monadicka funkce ukoncena teckou</i>
   <i>NB. zaokrouhleni smerem dolu (obdoba ceckove funkce floor)</i>
   <strong>&lt;. 2.5</strong>
2
   <strong>&lt;. 2.9</strong>
2
&nbsp;
   <i>NB. tuto funkci lze samozrejme volat i na vektory</i>
   <strong>&lt;. 1.9 2.0 2.1 2.9</strong>
1 2 2 2
&nbsp;
   <i>NB. monadicka funkce ukoncena dvojteckou</i>
   <i>NB. operace dekrementace (obdoba ceckoveho operatoru --)</i>
   <strong>&lt;: 1</strong>
0
   <strong>&lt;: 10</strong>
9
   <strong>&lt;: 1 2 3</strong>
0 1 2
   <strong>&lt;: 0 1 2</strong>
_1 0 1
</pre>

<p><div class="rs-tip-major">Poznámka: podobných funkcí uvidíme v&nbsp;dalším
textu ještě mnoho.</div></p>



<p><a name="k08"></a></p>
<h2 id="k08">8. Vyhodnocování aritmetických a logických výrazů</h2>

<p>Aritmetické a logické výrazy, které většinou tvoří nejdůležitější součást
všech programů zapisovaných v&nbsp;jazyku <i>J</i>, se vyhodnocují stejným
způsobem, jako v&nbsp;již popsaném programovacím jazyku <i>APL</i>,
tj.&nbsp;zprava doleva bez toho, aby některé funkce měly vyšší prioritu než
funkce jiné. Funkce se zapisují stejným způsobem jako v&nbsp;jiných jazycích
prefixové a infixové operátory, tj.&nbsp;buď mezi oba argumenty (operandy) při
volání dyadických funkcí nebo před jediný argument v&nbsp;případě, že se volá
funkce monadická. V&nbsp;případě, že je zapotřebí změnit pořadí volání funkcí,
lze k&nbsp;tomuto účelu použít obligátní kulaté závorky. V&nbsp;jazyku <i>J</i>
je k&nbsp;dispozici pět základních aritmetických funkcí, které jsou vypsány
v&nbsp;tabulce pod odstavcem (povšimněte si především odlišného způsobu zápisu
funkce podílu dvou hodnot). Do tabulky jsou pro úplnost dopsány i tři další
funkce pro výpočet mocniny, odmocniny a faktoriálu. Způsob použití těchto
funkcí i způsob úpravy priority (pořadí volání) je patrný z&nbsp;demonstračních
příkladů uvedených pod tabulkou.</p>

<table>
<tr><th>Znak funkce</th><th>Monadická funkce</th><th>Dyadická funkce</th></tr>
<tr><td>+ </td><td>negace imaginární složky komplexního čísla</td><td>součet (skalárů, vektorů, matic...)</td></tr>
<tr><td>- </td><td>negace</td><td>rozdíl</td></tr>
<tr><td>* </td><td>vrací znaménko</td><td>součin</td></tr>
<tr><td>% </td><td>převrácená hodnota</td><td>podíl</td></tr>
<tr><td>| </td><td>absolutní hodnota</td><td>zbytek</td></tr>
<tr><td>^ </td><td>&nbsp;</td><td>umocnění x<sup>y</sup></td></tr>
<tr><td>*:</td><td>druhá mocnina x<sup>2</sup></td><td>&nbsp;</td></tr>
<tr><td>%:</td><td>druhá odmocnina x<sup>1/2</sup></td><td>&nbsp;</td></tr>
<tr><td>! </td><td>faktoriál</td><td>&nbsp;</td></tr>
</table>

<p>Příklad použití operací:</p>

<pre>
   <i>NB. priorita je vždy zprava doleva</i>
   <strong>1+2*3</strong>
7
&nbsp;
   <i>NB. specifikace priority zavorkami</i>
   <strong>1+(2*3)</strong>
7
&nbsp;
   <i>NB. specifikace priority zavorkami</i>
   <strong>(1+2)*3</strong>
9
&nbsp;
   <i>NB. funkce jsou vyhodnocovany zprava doleva,</i>
   <i>NB. tj. zde nejdrive soucet a teprve pote soucin</i>
   <strong>3*2+1</strong>
9
&nbsp;
   <i>NB. specifikace priority zavorkami</i>
   <strong>3*(2+1)</strong>
9
&nbsp;
   <i>NB. zmena poradi vyhodnoceni funkci pomoci zavorek</i>
   <strong>(3*2)+1</strong>
7
&nbsp;
   <i>NB. zaporna cisla jsou zapisovana se symbolem _</i>
   <strong>10-20</strong>
_10
&nbsp;
   <i>NB. podil se zapisuje symbolem %</i>
   <strong>42%3</strong>
14
&nbsp;
   <i>NB. druha mocnina je zapisovana pomoci monadicke funkce *:</i>
   <strong>*: 10</strong>
100
&nbsp;
   <i>NB. vypocet prevracene (reciproke) hodnoty</i>
   <strong>% 3</strong>
0.33333
&nbsp;
   <i>NB. vypocet desate mocniny</i>
   <strong>2^10</strong>
1024
&nbsp;
   <i>NB. zaporny exponent</i>
   <strong>2^(_10)</strong>
0.000976562
&nbsp;
   <i>NB. aritmeticke funkce lze pouzit i pro soucet vektoru</i>
   <strong>1 2 3 + 4 5 6</strong>
5 7 9
&nbsp;
   <i>NB. vydeleni skalarni hodnoty postupne vsemi slozkami vektoru</i>
   <strong>42 % 2 3 4</strong>
21 14 10.5
&nbsp;
   <i>NB. kazda slozka vektoru je umocnena na desatou</i>
   <strong>2 3 4 ^ 10</strong>
1024 59049 1.04858e6
&nbsp;
   <i>NB. vypocet druhych mocnin vsech slozek vektoru</i>
   <strong>*: 1 2 3 4</strong>
1 4 9 16
&nbsp;
   <i>NB. vypocet faktorialu (samozrejme je pouzit prefixovy zapis)</i>
   <strong>!6</strong>
720
&nbsp;
   <strong>!170</strong>
7.25742e306
&nbsp;
   <i>NB. tento zapis si podrobneji vysvetlime pozdeji</i>
   <strong>!i.10</strong>
1 1 2 6 24 120 720 5040 40320 362880
</pre>



<p><a name="k09"></a></p>
<h2 id="k09">9. Operace s&nbsp;vektory v&nbsp;programovacím jazyku J</h2>

<p>Jak jsme se již dozvěděli z&nbsp;úvodního textu, je programovací jazyk
<i>J</i>, ostatně podobně jako jeho ideový předchůdce <i>APL</i>, určen
především pro tvorbu aplikací, v&nbsp;nichž se zpracovávají data uložená ve
vektorech, maticích či polích s&nbsp;větším počtem dimenzí (může se jednat
například o hierarchické mřížky atd., a to mj.&nbsp;i díky možnosti použít
<i>boxing</i>). Z&nbsp;tohoto důvodu je jazyk <i>J</i> vybaven jak jednoduchou
syntaxí určenou pro zápis vektorů a matic, tak i sadou primitivních
(základních) funkcí, pomocí nichž lze nad vektory i maticemi provádět různé
operace. Nejprve si popíšeme primitivní funkce určené pro vytváření i další
práci s&nbsp;vektory, které jsou vypsány v&nbsp;následující tabulce.</p>

<p><div class="rs-tip-major">Poznámka: v&nbsp;rozporu s&nbsp;oficiální
dokumentací jazyka J používám termín <i>vektor</i>, i když v&nbsp;J se používá
termín <i>seznam (list)</i>. To je však zavádějící vzhledem k&nbsp;tomu, jaký
má seznam význam v&nbsp;jiných programovacích jazycích.</div></p>

<p>U všech popisovaných funkcí bude uvedena i informace o tom, zda se jedná o
funkci <i>monadickou</i> (tj.&nbsp;s&nbsp;jedním parametrem zapisovaným za
symbol funkce) či <i>dyadickou</i> (s&nbsp;dvojicí parametrů, z&nbsp;nichž
první se zapisuje před a druhý za symbol funkce). Tato informace je
v&nbsp;případě jazyků <i>J</i> i <i>APL</i> velmi důležitá, protože již víme,
že stejný symbol může být použit pro pojmenování dvou primitivních funkcí
lišících se &bdquo;pouze&ldquo; počtem svých parametrů:</p>

<table>
<tr><th>Symbol funkce</th><th>Forma funkce</th><th>Popis funkce (význam)</th></tr>
<tr><td>+ - * %</td><td>dyadická</td><td>základní aritmetické operace prováděné nad dvojicí vektorů na korespondujících prvcích (též prováděné nad skalárem a vektorem)</td></tr>
<tr><td>&lt; &lt;: &gt; &gt;: = ~:</td><td>dyadická</td><td>porovnání korespondujících prvků dvou vektorů</td></tr>
<tr><td># </td><td>monadická</td><td>vrací délku vektoru</td></tr>
<tr><td># </td><td>dyadická </td><td>kopie prvků vektoru představovaného druhým parametrem</td></tr>
<tr><td>{ </td><td>dyadická </td><td>výběr prvku či více prvků z&nbsp;vektoru na základě indexů vybíraných prvků</td></tr>
<tr><td>{.</td><td>dyadická </td><td>výběr prvních <i>n</i> prvků z&nbsp;vektoru</td></tr>
<tr><td>}.</td><td>dyadická </td><td>výběr posledních <i>délka-n</i> prvků vektoru (= odstranění prvních <i>n</i> prvků)</td></tr>
<tr><td>, </td><td>dyadická </td><td>spojení dvou vektorů či vektoru se skalárem</td></tr>
<tr><td>/:</td><td>monadická</td><td>setřídění prvků vektoru sestupně (funkce vrací indexy prvků, ne jejich hodnoty)</td></tr>
<tr><td>\:</td><td>monadická</td><td>setřídění prvků vektoru vzestupně (funkce též vrací indexy prvků, ne jejich hodnoty)</td></tr>
<tr><td>i.</td><td>monadická</td><td>vytváří seznam (vektor) obsahující řadu čísel začínající nulou, popř.&nbsp;prázdný vektor</td></tr>
<tr><td>i:</td><td>monadická</td><td>vytváří seznam (vektor) obsahující čísla on <i>-n</i> do <i>n</i>, kde <i>n</i> je parametr funkce</td></tr>
<tr><td>p.</td><td>monadická</td><td>výpočet kořenů polynomu reprezentovaného vektorem obsahujícím koeficienty <i>a<sub>i</sub></i></td></tr>
</table>

<p><div class="rs-tip-major">Poznámka: první čtyři funkce už byly zmíněny
v&nbsp;souvislosti s&nbsp;operacemi prováděnými nad skaláry. Platí zde stále
stejná pravidla &ndash; vyhodnocování je prováděno zprava doleva, čímž je
automaticky určena i priorita operací. Tu lze změnit jen pomocí kulatých
závorek.</div></p>



<p><a name="k10"></a></p>
<h2 id="k10">10. Základní aritmetické funkce aplikované na vektory</h2>

<p>Základní aritmetické operace, se kterými jsme se již seznámili
v&nbsp;předchozích kapitolách (aplikovaných na skaláry), je možné využít i při
práci s&nbsp;vektory. V&nbsp;tomto případě se operace provádí vždy nad dvojicí
odpovídajících prvků (<i>dyadické funkce</i>) popř.&nbsp;postupně pro všechny
prvky vektoru (<i>funkce monadické</i>). Pokud nejsou délky vektorů shodné,
nahlásí interpretr jazyka <i>J</i> chybu typu &bdquo;length error&ldquo; (jen u
několika specifických operací se délka kratšího vektoru &bdquo;dorovná&ldquo;
s&nbsp;vektorem delším):</p>

<pre>
   <i>NB. Nejdříve vytvoříme tři proměnné</i>
   <i>NB. představující trojici vektorů (různé délky)</i>
   <strong>x =: 1 2 3 4</strong>
   <strong>y =: 9 8 7 6</strong>
   <strong>z =: 11 12</strong>
&nbsp;
   <i>NB. Čtyři základní aritmetické operace</i>
   <i>NB. (součet, rozdíl, součin, podíl)</i>
   <i>NB. prováděné nad prvky vektorů</i>
   <strong>x+y</strong>
10 10 10 10
&nbsp;
   <strong>y-x</strong>
8 6 4 2
&nbsp;
   <strong>x*y</strong>
9 16 21 24
&nbsp;
   <strong>x%y</strong>
0.111111 0.25 0.428571 0.666667
&nbsp;
   <i>NB. Následující příkaz skončí s chybou</i>
   <i>NB. neboť délky vektorů (=počty jejich</i>
   <i>NB. prvků) nejsou shodné</i>
   <strong>x+z</strong>
|length error
|   x    +z
</pre>

<p>Při použití aritmetických funkcí může být jedním z&nbsp;parametrů i skalární
hodnota, která je aplikována na všechny prvky vektoru. Viz též následující
demonstrační příklady:</p>

<pre>
   <i>NB. Při volání aritmetických funkcí</i>
   <i>NB. je možné zkombinovat skalární hodnotu</i>
   <i>NB. s vektorem</i>
   <strong>2 * x</strong>
2 4 6 8
&nbsp;
   <strong>x * 2</strong>
2 4 6 8
&nbsp;
   <i>NB. Předchozí dva výrazy 2 * x a 2 * y</i>
   <i>NB. sice vrátily shodný výsledek, ale některé</i>
   <i>NB. další aritmetické operace nejsou</i>
   <i>NB. komutativní, například dělení:</i>
   <strong>10 % x</strong>
10 5 3.33333 2.5
&nbsp;
   <strong>x % 10</strong>
0.1 0.2 0.3 0.4
</pre>

<p>Následují dva příklady použití dalších funkcí, konkrétně dyadické
exponenciální funkce a monadické funkce pro výpočet faktoriálu:</p>

<pre>
   <i>NB. Při práci s vektory lze samozřejmě</i>
   <i>NB. použít i další primitivní funkce,</i>
   <i>NB. zde například funkci exponenciální</i>
   <strong>x^y</strong>
1 256 2187 4096
&nbsp;
   <i>NB. Monadická funkce (výpočet faktoriálu)</i>
   <strong>! x</strong>
1 2 6 24
</pre>



<p><a name="k11"></a></p>
<h2 id="k11">11. Výběr prvků z&nbsp;vektorů (selektory)</h2>

<p>Další důležitou a současně i velmi často používanou skupinou základních
(primitivních) funkcí určených pro práci s&nbsp;vektory jsou funkce, které
umožňují z&nbsp;vektoru vybrat hodnoty některých prvků. Jedná se o rozšíření
funkcí &bdquo;take&ldquo; a &bdquo;drop&ldquo;, se kterými jsme se již
seznámili při popisu programovacího jazyka <i>APL</i>, ovšem s&nbsp;tím
rozdílem, že prvky vektorů jsou v&nbsp;případě jazyka <i>J</i> číslovány od
nuly, tj.&nbsp;první prvek má index roven 0 a index posledního prvku je roven
délce vektoru-1 (což je mimochodem poměrně zvláštní ústupek mainstreamu &ndash;
v&nbsp;jiných ohledech je J tak vzdálen od mainstreamu tak, jak je to jen
možné).  Dále se v&nbsp;této skupině nachází funkce umožňující provést spojení
dvou vektorů, která se zapisuje pomocí ASCII znaku "<strong>,</strong>" &ndash;
čárka. V&nbsp;aplikacích se poměrně často vyskytuje i funkce vracející délku
vektoru (ASCII znak "<strong>#</strong>"). V&nbsp;případě matic či polí tato
funkce vrací rozměr všech jejich dimenzí, což si ukážeme v&nbsp;navazujících
kapitolách.</p>

<p>Základní způsoby použití selektorů si pochopitelně opět ukážeme na
demonstračních příkladech:</p>

<pre>
   <i>NB. Nejdříve opět vytvoříme tři proměnné</i>
   <i>NB. představující trojici vektorů</i>
   <strong>x =: 1 2 3 4</strong>
   <strong>y =: 9 8 7 6</strong>
   <strong>z =: 11 12</strong>
&nbsp;
   <i>NB. Zjistíme délky (počet prvků) všech vektorů</i>
   <strong>#x</strong>
4
   <strong>#y</strong>
4
   <strong>#z</strong>
2
&nbsp;
   <i>NB. Spojení vektorů pomocí primitivní</i>
   <i>NB. funkce , (čárka)</i>
   <strong>w =: x,y,z</strong>
   <strong>w</strong>
1 2 3 4 9 8 7 6 11 12
&nbsp;
   <i>NB. Jak je výsledný vektor w dlouhý?</i>
   <strong>#w</strong>
10
&nbsp;
   <i>NB. Výběr pátého prvku (s indexem 4)</i>
   <strong>4 { w</strong>
9
&nbsp;
   <i>NB. Výběr pátého, šestého a sedmého</i>
   <i>NB. prvku vektoru w (obdoba funkce take)</i>
   <strong>4 5 6 { w</strong>
9 8 7
&nbsp;
   <i>NB. Výběr prvních čtyř prvků vektoru</i>
   <strong>4 {. w</strong>
1 2 3 4
&nbsp;
   <i>NB. Vrácení vektoru BEZ jeho prvních</i>
   <i>NB. čtyř prvků (obdoba funkce drop)</i>
   <strong>4 }. w</strong>
9 8 7 6 11 12
</pre>

<p>Funkce pro výběr prvků mají svoje názvy:</p>

<table>
<tr><th>Funkce</th><th>Forma</th><th>Jméno</th></tr>
<tr><td>{.</td><td>dyadická</td><td>take</td></tr>
<tr><td>}.</td><td>dyadická</td><td>drop</td></tr>
<tr><td>{.</td><td>monadická</td><td>head</td></tr>
<tr><td>}.</td><td>monadická</td><td>behead</td></tr>
<tr><td>{:</td><td>monadická</td><td>tail</td></tr>
<tr><td>}:</td><td>monadická</td><td>curtail</td></tr>
</table>

<p>Funkce <strong>take</strong> vrátí prvních n prvků vektoru. V&nbsp;případě
potřeby je vektor zprava doplněn nulami. Lze použít i záporný počet prvků:</p>

<pre>
   <strong>i. 10</strong>
0 1 2 3 4 5 6 7 8 9
&nbsp;
   <strong>3 {. i. 10</strong>
0 1 2
&nbsp;
   <strong>30 {. i. 10</strong>
0 1 2 3 4 5 6 7 8 9 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
&nbsp;
   <strong>_5 {. i. 10</strong>
5 6 7 8 9
</pre>

<p>Funkce <strong>drop</strong> vrátí vektor bez prvních n prvků. Lze použít i
záporný počet prvků:</p>

<pre>
   <strong>3 }. i. 10</strong>
3 4 5 6 7 8 9
&nbsp;
   <strong>_3 }. i. 10</strong>
0 1 2 3 4 5 6
</pre>

<p>Monadická funkce <strong>head</strong> vrátí první prvek vektoru:</p>

<pre>
   <strong>{. i. 10</strong>
0
</pre>

<p>Funkce <strong>behead</strong> vrátí vektor bez prvního prvku:</p>

<pre>
   <strong>}. i. 10</strong>
1 2 3 4 5 6 7 8 9
</pre>

<p>Monadická funkce <strong>tail</strong> vrátí poslední prvek vektoru:</p>

<pre>
   <strong>{: i. 10</strong>
9
</pre>

<p>A konečně funkce <strong>curtail</strong> vrátí vektor bez posledního
prvku:</p>

<pre>
   <strong>}: i. 10</strong>
0 1 2 3 4 5 6 7 8
</pre>



<p><a name="k12"></a></p>
<h2 id="k12">12. Konstrukce vektorů založená na generátorech (indexů)</h2>

<p>Nyní si ve stručnosti ukážeme způsob použití takzvaných <i>generátorů
indexů</i> představovaných primitivními funkcemi zapisovanými pomocí symbolů
<i>i.</i> a <i>i:</i>. Jedná se o velmi užitečné a v&nbsp;praxi často využívané
funkce, které odpovídají primitivní funkci &iota;, s&nbsp;níž jsme se již
seznámili při popisu programovacího jazyka <i>APL</i>, ovšem s&nbsp;tím
podstatným rozdílem, že první číslo generované funkcí <i>i.</i> má hodnotu
nula, nikoli jedna, a poslední číslo má hodnotu <i>n-1</i> a nikoli <i>n</i>
(to souvisí s&nbsp;tím, že v&nbsp;programovacím jazyce <i>J</i> jsou položky
vektorů číslovány&ndash;indexovány od nuly, podobně jako například
v&nbsp;programovacích jazycích C, C++ či Java &ndash; viz též předchozí
kapitolu věnovanou indexování). Povšimněte si taktéž, že se pomocí funkce
<i>i.</i> dá vytvořit velké množství různých (nejenom) aritmetických řad, takže
pro tyto účely není nutné používat programové smyčky. Navíc mohou být
primitivní funkce <i>i.</i> a <i>i:</i> součástí nějakého složitějšího výrazu,
čehož se při psaní aplikací poměrně často využívá, například při programové
tvorbě matic (jednotková matice, trojúhelníková matice atd.).</p>

<p><div class="rs-tip-major">Poznámka: zde je nutno upozornit na to, že se
vektor skutečně vytvoří &ndash; funkce <strong>i.</strong> tedy není
&bdquo;líná&ldquo; tak, jako například generátory v&nbsp;Pythonu.</div></p>

<pre>
   <i>NB. Základní použití generátoru indexů</i>
   <strong>i. 10</strong>
0 1 2 3 4 5 6 7 8 9
&nbsp;
   <i>NB. Poměrně snadno můžeme dosáhnout toho,</i>
   <i>NB. aby se počáteční hodnota generované</i>
   <i>NB. číselné řady "posunula"</i>
   <strong>20 + i. 10</strong>
20 21 22 23 24 25 26 27 28 29
&nbsp;
   <i>NB. Řada začínající hodnotou -10</i>
   <strong>_10 + i. 10</strong>
_10 _9 _8 _7 _6 _5 _4 _3 _2 _1
&nbsp;
   <i>NB. Posun a současně i změna "kroku"</i>
   <i>NB. při generování číselné řady</i>
   <strong>3 + 0.5 * i. 15</strong>
3 3.5 4 4.5 5 5.5 6 6.5 7 7.5 8 8.5 9 9.5 10
&nbsp;
   <i>NB. Mocninná řada čísla 2 vytvořená</i>
   <i>NB. bez použití programové smyčky</i>
   <strong>2 ^ i. 10</strong>
1 2 4 8 16 32 64 128 256 512
&nbsp;
   <i>NB. Výpočet prvních faktoriálu prvních deseti</i>
   <i>NB. přirozených čísel a nuly.</i>
   <i>NB. (připomeňme si, že funkce se vyhodnocují</i>
   <i>NB.  zprava doleva, tj. nejdříve se vytvoří</i>
   <i>NB.  vektor čísel, na jehož prvky je aplikována</i>
   <i>NB.  primitivní funkce představující faktoriál)</i>
   <strong>! i. 10</strong>
1 1 2 6 24 120 720 5040 40320 362880
&nbsp;
   <i>NB. Pomocí primitivní funkce i: lze vygenerovat</i>
   <i>NB. číselnou řadu symetrickou okolo nuly</i>
   <strong>i: 10</strong>
_10 _9 _8 _7 _6 _5 _4 _3 _2 _1 0 1 2 3 4 5 6 7 8 9 10
&nbsp;
   <i>NB. Změna kroku číselné řady</i>
   <strong>2* i: 10</strong>
_20 _18 _16 _14 _12 _10 _8 _6 _4 _2 0 2 4 6 8 10 12 14 16 18 20
&nbsp;
   <i>NB. Opět výpočet mocnin čísla 2, tentokrát však</i>
   <i>NB. včetně záporných exponentů</i>
   <strong>2^ i: 5</strong>
0.03125 0.0625 0.125 0.25 0.5 1 2 4 8 16 32
&nbsp;
   <i>NB. Vytvoření prázdného vektoru (jedna z nejčastěji</i>
   <i>NB. používaných možností tvorby prázdného vektoru)</i>
   <strong>i. 0</strong>
&nbsp;
&nbsp;
   <i>NB. Ovšem pozor: v následujícím případě</i>
   <i>NB. se vytvoří vektor obsahující jeden prvek</i>
   i<strong>: 0</strong>
0
</pre>

<p><div class="rs-tip-major">Poznámka: v&nbsp;předchozích ukázkách bylo poměrně
dobře vidět, jak odlišný je přístup při řešení některých problémů
v&nbsp;mainstreamových jazycích v&nbsp;porovnání s&nbsp;jazykem J. Například
vytvoření mocninné řady o základu 2 atd. &ndash; vše bez nutnosti použití
programových smyček.</div></p>

<p>Vektor s&nbsp;nulami se tvoří podobnou funkcí <strong>I.</strong>:</p>

<pre>
   <strong>I.1</strong>
0
&nbsp;
   <strong>I.10</strong>
0 0 0 0 0 0 0 0 0 0
</pre>



<p><a name="k13"></a></p>
<h2 id="k13">13. Matice</h2>

<p>Práce s&nbsp;maticemi je v&nbsp;programovacím jazyku <i>J</i> stejně snadná
jako práce s&nbsp;vektory. Základní funkci při práci s&nbsp;maticemi
představuje funkce <i>reshape</i> zapisovaná pomocí symbolu <strong>$</strong>.
Tato funkce má stejné vlastnosti jako funkce &rho; zmiňovaná při popisu
programovacího jazyka <i>APL</i> &ndash; v&nbsp;prvním parametru (zapisovaného
nalevo od symbolu <strong>$</strong>) jsou uloženy rozměry matice,
v&nbsp;parametru druhém (uváděném napravo od symbolu <strong>$</strong>) pak
její jednotlivé prvky, typicky uložené ve vektoru nebo v&nbsp;jiné matici.
Naopak monadická forma funkce <strong>$</strong> <i>vrací</i> tvar pole (zde je
symetrie dokonalá).</p>

<p><div class="rs-tip-major">Poznámka: opět se zde odchyluji od oficiálních
termínů používaných v&nbsp;jazyce J. Dvourozměrná pole by se totiž měla nazývat
<i>table</i>, ovšem tento pojem má v&nbsp;jiných jazycích poněkud odlišný
význam, takže zůstanu i přece jen zavedenějšího termínu <i>matice
(matrix)</i>.</div></p>

<pre>
   <i>NB. Vytvoření nulové matice</i>
   <i>NB. o rozměrech 3x3 prvky</i>
   <strong>3 3 $ 0</strong>
0 0 0
0 0 0
0 0 0
&nbsp;
   <i>NB. Vytvoření matice a současně</i>
   <i>NB. i nastavení hodnot jejích prvků</i>
   <strong>3 2 $ 1 2 3 4 5 6</strong>
1 2
3 4
5 6
&nbsp;
   <i>NB. Použití generátoru indexů</i>
   <i>NB. při vytváření matice</i>
   <strong>3 4 $ i. 12</strong>
0 1  2  3
4 5  6  7
8 9 10 11
&nbsp;
   <strong>2 2 $ 0 1 2 3</strong>
0 1
2 3
&nbsp;
   <strong>2 3 $ 0 1 2 3 4 5</strong>
0 1 2
3 4 5
&nbsp;
   <i>NB. Odlišný tvar, ovšem stejný obsah prvků</i>
   <strong>3 2 $ 0 1 2 3 4 5</strong>
0 1
2 3
4 5
</pre>

<p>Dvourozměrná nečtvercová matice:</p>

<pre>
   <strong>2 3 $ i. 6</strong>
0 1 2
3 4 5
</pre>

<p>Trojrozměrná matice (<i>brick</i>):</p>

<pre>
   <strong>2 3 4 $ i. 24</strong>
 0  1  2  3
 4  5  6  7
 8  9 10 11
&nbsp;
12 13 14 15
16 17 18 19
20 21 22 23
</pre>

<p>Odlišný tvar čtyřrozměrné matice:</p>

<pre>
   <strong>4 3 2 $ i. 24</strong>
 0  1
 2  3
 4  5
&nbsp;
 6  7
 8  9
10 11
&nbsp;
12 13
14 15
16 17
&nbsp;
18 19
20 21
22 23
</pre>

<p>Zpětné získání tvaru pole pomocí monadické funkce <strong>$</strong>:</p>

<pre>
   <strong>$ 4 3 2 $ i. 24</strong>
4 3 2
</pre>

<p>Konstrukce prázdného pole:</p>

<pre>
   <strong>0 $ 10</strong>
</pre>

<p>Velmi důležitou &bdquo;maticovou&ldquo; funkcí je funkce pro výpočet
inverzní matice zapisovaná symbolem <strong>%.</strong>. S&nbsp;využitím této
funkce lze například vypočítat soustavu <i>n</i> rovnic o <i>n</i>
neznámých:</p>

<pre>
        x + 2y -3z = 15
        x + y + z = 12
       2x - y - z = 0
</pre>

<p>Nejprve vytvoříme příslušnou matici a zapíšeme do ní koeficienty
(multiplikativní konstanty) uvedené před neznámými:</p>

<pre>
   <i>NB. Prvky ležící na jednotlivých řádcích jsou</i>
   <i>NB. od sebe pro větší přehlednost odděleny</i>
   <i>NB. trojicí mezer.</i>
   <strong>m =: 3 3 $   1 2 _3   1 1 1   2 _1 _1</strong>
   <strong>m</strong>
1  2 _3
1  1  1
2 _1 _1
</pre>

<p>S&nbsp;využitím funkce <strong>%.m</strong> lze snadno vypočítat inverzní
matici:</p>

<pre>
   <strong>%.m</strong>
   0 0.333333   0.333333
 0.2 0.333333  _0.266667
_0.2 0.333333 _0.0666667
</pre>

<p>Po vynásobení inverzní matice vektorem obsahujícím pravé strany rovnic
dostaneme kýžený výsledek &ndash; hodnoty neznámých <i>x</i>, <i>y</i> a
<i>z</i>:</p>

<pre>
   <strong>15 12 0 %.m</strong>
4 7 1
</pre>



<p><a name="k14"></a></p>
<h2 id="k14">14. Výběr prvků z&nbsp;matic</h2>

<p>Pro výběr prvků z&nbsp;matic se používají stejné funkce, jako pro výběr
prvků z&nbsp;vektorů. Pouze nesmíme zapomenout na to, že výběrem jedním indexem
získáme z&nbsp;matice vektor.</p>

<p>Nejprve si zopakujeme způsob výběru prvků z&nbsp;vektoru:</p>

<p>Výběr prvků z vektoru s využitím indexu:</p>

<pre>
   <strong>0 { 5 6 7 8</strong>
5
</pre>

<p>Index prvního prvku je roven nule:</p>

<pre>
   <strong>1 { 5 6 7 8</strong>
6
</pre>

<p>Použití záporného indexu:</p>

<pre>
   <strong>_1 { 5 6 7 8</strong>
8
</pre>

<p>Použití záporného indexu:</p>

<pre>
   <strong>_2 { 5 6 7 8</strong>
7
</pre>

<p>Pozor na to, že funkce - není stejná jako znaménko _:</p>

<pre>
   <strong>-1 { 5 6 7 8</strong>
_6
</pre>

<p>Výběr více prvků z&nbsp;vektoru:</p>

<pre>
   <strong>0 2 3 { 5 6 7 8</strong>
5 7 8
</pre>

<p>Výběr více prvků z&nbsp;vektoru, kombinace se záporným indexem:</p>

<pre>
   <strong>0 2 _1 { 5 6 7 8</strong>
5 7 8
</pre>

<p>Výběr více prvků z&nbsp;vektoru, kombinace se záporným indexem:</p>

<pre>
   <strong>0 2 _2 { 5 6 7 8</strong>
5 7 7
</pre>

<p>A konečně výběry prvků z&nbsp;matice:</p>

<p>Konstrukce matice:</p>

<pre>
   <strong>3 3 $ i. 9</strong>
0 1 2
3 4 5
6 7 8
</pre>

<p>Výběr celého řádku z&nbsp;matice:</p>

<pre>
   <strong>1 { 3 3 $ i. 9</strong>
3 4 5
</pre>

<p>Záporný index při výběru:</p>

<pre>
   <strong>_1 { 3 3 $ i. 9</strong>
6 7 8
</pre>

<p>Výběr řádků v&nbsp;opačném pořadí z&nbsp;matice:</p>

<pre>
   <strong>2 1 0 { 3 3 $ i. 9</strong>
6 7 8
3 4 5
0 1 2
</pre>

<p>Zopakování vybraných řádků:</p>

<pre>
   <strong>2 1 2 1 2 1 { 3 3 $ i. 9</strong>
6 7 8
3 4 5
6 7 8
3 4 5
6 7 8
3 4 5
</pre>

<p>Výběr konkrétního prvku z&nbsp;matice:</p>

<pre>
   <strong>(&lt; 1 ; 1) { 3 3 $ i. 9</strong>
4
</pre>

<p>Výběr podmatice:</p>

<pre>
   <strong>(&lt; 1 2 ; 1 2) { 3 3 $ i. 9</strong>
4 5
7 8
</pre>

<p>Výběr podmatice:</p>

<pre>
   <strong>(&lt; 0 1 ; 0 1) { 3 3 $ i. 9</strong>
0 1
3 4
</pre>

<p>Výběr sloupce z&nbsp;matice:</p>

<pre>
   <strong>(&lt; 0 1 2; 1) { 3 3 $ i. 9</strong>
1 4 7
</pre>



<p><a name="k15"></a></p>
<h2 id="k15">15. Predikáty pracující s&nbsp;atomy, vektory i maticemi</h2>

<p>Pro vzájemné porovnávání skalárních hodnot i hodnot prvků uložených ve
vektorech, maticích i polích s&nbsp;vyššími dimenzemi se používají predikátové
funkce nahrazující relační operátory známé z&nbsp;jiných programovacích jazyků
(slovo <i>operátor</i> má v&nbsp;jazyce J odlišný význam). Návratovou hodnotou
těchto funkcí je buď skalární hodnota 0 nebo 1, popř.&nbsp;vektor či matice
obsahující pouze nuly a jedničky (nula samozřejmě značí nepravdu, jednička
pravdu). Tyto funkce jsou popsány v&nbsp;následující tabulce. Povšimněte si
především způsobu zápisu podmínky &bdquo;menší nebo rovno&ldquo;, &bdquo;větší
nebo rovno&ldquo; a &bdquo;nerovnost&ldquo;, protože se v&nbsp;nich používají
znaky, které jsou oproti jiným programovacím jazykům odlišné (jenže
<strong>co</strong> není v&nbsp;jazyce J odlišné, že?):</p>

<table>
<tr><th>Symbol funkce</th><th>Forma funkce</th><th>Popis (význam)</th></tr>
<tr><td>&lt; </td><td>dyadická</td><td>predikát &bdquo;menší než&ldquo;</td></tr>
<tr><td>&lt;:</td><td>dyadická</td><td>predikát &bdquo;menší nebo rovno&ldquo;</td></tr>
<tr><td>&gt; </td><td>dyadická</td><td>predikát &bdquo;větší než&ldquo;</td></tr>
<tr><td>&gt;:</td><td>dyadická</td><td>predikát &bdquo;větší nebo rovno&ldquo;</td></tr>
<tr><td>=    </td><td>dyadická</td><td>predikát rovnosti</td></tr>
<tr><td>~:   </td><td>dyadická</td><td>predikát nerovnosti</td></tr>
<tr><td>e.   </td><td>dyadická</td><td>predikát &bdquo;obsahuje&ldquo;</td></tr>
</table>

<p>Použití výše uvedených funkcí při porovnávání skalárních hodnot je velmi
snadné, o čemž se můžeme velmi snadno přesvědčit:</p>

<pre>
   <strong>1 &lt;: 2</strong>
1
&nbsp;
   <strong>1 &gt;: 2</strong>
0
&nbsp;
   <strong>1 &lt;: 1</strong>
1
&nbsp;
   <strong>1 ~: 2</strong>
1
&nbsp;
   <strong>1 ~: 1</strong>
0
</pre>

<p>Kromě vzájemného porovnání skalárních hodnot je možné porovnat všechny prvky
vektoru (matice) se skalární hodnotou, popř.&nbsp;prvky dvou vektorů (matic)
navzájem. V&nbsp;tomto případě je výsledkem porovnání též vektor či matice
obsahující hodnoty 0 a 1 (tedy vlastně bitová maska):</p>

<pre>
   <i>NB. Porovnání všech prvků vektoru se skalární hodnotou</i>
   <strong>1 2 3 4 &gt; 2</strong>
0 0 1 1
&nbsp;
   <strong>1 2 3 4 &lt; 2</strong>
1 0 0 0
&nbsp;
   <strong>1 2 3 4 = 2</strong>
0 1 0 0
&nbsp;
   <i>NB. Porovnání dvou vektorů, které v tomto</i>
   <i>NB. případě musí mít shodnou délku.</i>
   <strong>1 2 3 4 &lt; 4 3 2 1</strong>
1 1 0 0
</pre>

<p>Poslední funkcí, kterou si v&nbsp;této kapitole popíšeme, je funkce
testující existenci prvku (prvků) ve vektoru či matici. Jedná se o funkci
označovanou symbolem <strong>e.</strong>, jejímž prvním parametrem je skalární
hodnota či vektor hodnot, které se hledají v&nbsp;datové struktuře předané ve
druhém parametru této funkce. Návratovou hodnotou funkce <strong>e.</strong> je
pravdivostní hodnota 0 nebo 1 udávající, zda se příslušná hledaná hodnota
(první parametr) skutečně ve druhém parametru nachází. Pokud se současně
vyhledává více hodnot, je návratovou hodnotou vektor nul a jedniček (tedy opět
bitové pole), jak je to ostatně ukázáno v&nbsp;následujících demonstračních
příkladech:</p>

<pre>
   <i>NB. Vytvoření vektoru čísel</i>
   <strong>x=:1 2 3 4 5 0.3 _1 42</strong>
&nbsp;
   <i>NB. Zjištění, zda vektor obsahuje hodnotu 10</i>
   <strong>10 e. x</strong>
0
&nbsp;
   <i>NB. Zjištění, zda vektor obsahuje hodnotu 1</i>
   <strong>1 e. x</strong>
1
&nbsp;
   <i>NB. Dtto pro hodnotu 2</i>
   <strong>2 e. x</strong>
1
&nbsp;
   <i>NB. Vytvoření vektoru hledaných čísel</i>
   <strong>y=:1 3 5</strong>
&nbsp;
   <i>NB. Zjištění, zda vektor x obsahuje čísla 1, 3 a 5</i>
   <strong>y e. x</strong>
1 1 1
&nbsp;
   <i>NB. Vyhledání více prvků bez použití</i>
   <i>NB. pomocného vektoru</i>
   <strong>1 10 100 1000 42 e. x</strong>
1 0 0 0 1
&nbsp;
   <i>NB. Vektor, ve kterém je prováděno vyhledávání,</i>
   <i>NB. může být sestrojen funkcí i.</i>
   <strong>1 5 10 e. i. 10</strong>
1 1 0
&nbsp;
   <i>NB. Vyhledání všech násobků dvou v řadě</i>
   <i>NB. obsahující násobky čísla 3.</i>
   <strong>(2* i. 20) e. (3* i. 20)</strong>
1 0 0 1 0 0 1 0 0 1 0 0 1 0 0 1 0 0 1 0
</pre>

<p><div class="rs-tip-major">Poznámka: v&nbsp;posledním příkladu je již vidět
základ pro výpočet prvočísel:</div></p>

<pre>
   <strong>I.2=+/0=|/~ i.100</strong>
2 3 5 7 11 13 17 19 23 29 31 37 41 43 47 53 59 61 67 71 73 79 83 89 97
</pre>



<p><a name="k16"></a></p>
<h2 id="k16">16. Různé způsoby spojení polí</h2>

<p>V&nbsp;jazyku J existuje hned několik různých operací pro spojení dvou
polí:</p>

<table>
<tr><th>Symbol funkce</th><th>Forma funkce</th><th>Jméno</th></tr>
<tr><td>,</td><td>dyadická</td><td>append</td></tr>
<tr><td>,.</td><td>dyadická</td><td>stitch</td></tr>
<tr><td>,:</td><td>dyadická</td><td>laminate</td></tr>
<tr><td>;</td><td>dyadická</td><td>link</td></tr>
</table>

<p>Tyto funkce budou ukázány na několika příkladech:</p>

<p>Spojení vektorů funkcí <strong>append</strong>:</p>

<pre>
   <strong>1 2 3 , 4 5 6</strong>
1 2 3 4 5 6
</pre>

<p>Spojení matic funkcí <strong>append</strong> (&bdquo;pod sebe&ldquo;):</p>

<pre>
   <strong>(2 3 $ i. 6) , 2 3 $ i. 6</strong>
0 1 2
3 4 5
0 1 2
3 4 5
</pre>

<p>Matice nemusí mít stejný počet řádků:</p>

<pre>
   <strong>(2 3 $ i. 6) , 3 3 $ i. 9</strong>
0 1 2
3 4 5
0 1 2
3 4 5
6 7 8
</pre>

<p>Připojení skaláru k&nbsp;vektoru s&nbsp; možným opakováním skalární hodnoty:</p>

<pre>
   <strong>(i. 6) , 100</strong>
0 1 2 3 4 5 100
</pre>

<p>Připojení skaláru k&nbsp;matici s&nbsp; možným opakováním skalární hodnoty:</p>

<pre>
   <strong>(2 3 $ i. 6) , 100</strong>
  0   1   2
  3   4   5
100 100 100
</pre>

<p>Odlišný tvar původní matice:</p>

<pre>
   <strong>(3 2 $ i. 6) , 100</strong>
  0   1
  2   3
  4   5
100 100
</pre>

<p>Zopakujme si použití funkce <strong>append</strong> pro dvě matice:</p>

<pre>
   <strong>(2 3 $ i. 6) , 2 3 $ i. 6</strong>
0 1 2
3 4 5
0 1 2
3 4 5
</pre>

<p>Rozdílné chování funkce <strong>stitching</strong> pro dvě matice (spojení &bdquo;za sebou&ldquo;):</p>

<pre>
   <strong>(2 3 $ i. 6) ,. 2 3 $ i. 6</strong>
0 1 2 0 1 2
3 4 5 3 4 5
</pre>

<p>Funkce <strong>stitching</strong> a kombinace matice a skalární hodnoty:</p>

<pre>
   <strong>(2 3 $ i. 6) ,. 100</strong>
0 1 2 100
3 4 5 100
</pre>

<p>Funkce <strong>stitching</strong> a kombinace matice a skalární hodnoty:</p>

<pre>
   <strong>(3 2 $ i. 6) ,. 100</strong>
0 1 100
2 3 100
4 5 100
</pre>

<p>Funkce <strong>laminating</strong> spojuje dvě matice ještě jiným způsobem &ndash; jako dva boxy:</p>

<pre>
   <strong>(2 3 $ i. 6) ,: 2 3 $ i. 6</strong>
0 1 2
3 4 5
&nbsp;
0 1 2
3 4 5
</pre>

<p>Výsledkem je vždy pole obsahující &bdquo;kompatibilní&ldquo; prvky</p>

<pre>
   <strong>(2 3 $ i. 6) ,: 3 2 $ i. 6</strong>
0 1 2
3 4 5
0 0 0
&nbsp;
0 1 0
2 3 0
4 5 0
</pre>

<p>Další příklad kombinující matici a skalár &ndash; výsledkem je matice s&nbsp;dvojicí &bdquo;kompatibilních&ldquo; prvků:</p>

<pre>
   <strong>(2 3 $ i. 6) ,: 100</strong>
  0   1   2
  3   4   5
&nbsp;
100 100 100
100 100 100
</pre>



<p><a name="k17"></a></p>
<h2 id="k17">17. Pokročilejší operace nad poli</h2>

<p>Popišme si ještě další operace, které lze s&nbsp;poli provádět:</p>

<table>
<tr><th>Symbol funkce</th><th>Forma funkce</th><th>Jméno</th></tr>
<tr><td>;</td><td>dyadická</td><td>linking</td></tr>
<tr><td>;</td><td>monadická</td><td>razing</td></tr>
<tr><td>,</td><td>monadická</td><td>ravelling</td></tr>
<tr><td>,.</td><td><td>monadická</td><td>itemizing</td></tr>
</table>

<p>Funkce <strong>linking</strong> slouží ke konstrukci seznamu boxů
obsahujících jakékoli prvky:</p>

<pre>
   <strong>(2 3 $ i. 6) ; 100</strong>
+-----+---+
|0 1 2|100|
|3 4 5|   |
+-----+---+
&nbsp;
   <strong>(2 3 $ i. 6) ; 100 ; 'abcd'</strong>
+-----+---+----+
|0 1 2|100|abcd|
|3 4 5|   |    |
+-----+---+----+
&nbsp;
   <strong>(2 3 $ i. 6) ; 100 ; 'abcd' ; (4 2 $ i. 8)</strong>
+-----+---+----+---+
|0 1 2|100|abcd|0 1|
|3 4 5|   |    |2 3|
|     |   |    |4 5|
|     |   |    |6 7|
+-----+---+----+---+
</pre>

<p>Monadická funkce <strong>razing</strong> naopak rozdělí pole boxů na seznam
prvků:</p>

<pre>
   <strong>2 2 $ 1;2;3;4</strong>
+-+-+
|1|2|
+-+-+
|3|4|
+-+-+
&nbsp;
   <strong>; 2 2 $ 1;2;3;4</strong>
1 2 3 4
</pre>

<p>Naproti tomu monadická funkce <strong>ravelling</strong> rozdělí pole boxů
na seznam boxů:</p>

<pre>
   <strong>, 2 2 $ 1;2;3;4</strong>
+-+-+-+-+
|1|2|3|4|
+-+-+-+-+
</pre>

<p>A konečně funkce <strong>itemizing</strong> zvyšuje dimenzi pole o jedničku
&ndash; zabalí prvky původního pole:</p>

<pre>
   <strong>2 2 $ 1;2;3;4</strong>
+-+-+
|1|2|
+-+-+
|3|4|
+-+-+
&nbsp;
   <strong>,. 2 2 $ 1;2;3;4</strong>
+-+-+
|1|2|
+-+-+
|3|4|
+-+-+
&nbsp;
   <strong>$ 2 2 $ 1;2;3;4</strong>
2 2
&nbsp;
   <strong>$ ,: 2 2 $ 1;2;3;4</strong>
1 2 2
</pre>



<p><a name="k18"></a></p>
<h2 id="k18">18. Operátor <strong>/</strong> (reduce)</h2>

<p>Programovací jazyk <i>J</i> však kromě poměrně rozsáhlé řady primitivních
funkcí obsahuje, ostatně podobně jako již popsaný jazyk <i>APL</i>, několik
<i>operátorů</i>, pomocí nichž jsou funkce aplikovány nikoli na jeden či dva
parametry, ale postupně na celé vektory nebo matice. Díky operátorům (význam
tohoto slova je odlišný od významu, který toto slovo má v&nbsp;jiných
programovacích jazycích!) je možné eliminovat velké množství programových
smyček a mnohdy tak například několikařádkovou proceduru zapsat pomocí jediného
výrazu. Jedním z&nbsp;nejdůležitějších operátorů jazyka <i>J</i> je operátor
<strong>/</strong>, který jsme si již v&nbsp;jednodušší podobě představili při
popisu jazyka <i>APL</i>. Tento operátor, který se zapisuje za identifikátor
primitivní či uživatelské funkce, postupně danou funkci aplikuje na první dva
prvky argumentu, dále ji aplikuje na průběžný výsledek a třetí prvek atd., do
doby, než jsou všechny prvky argumentu zpracovány (jinými slovy &ndash; daná
dyadická funkce je jakoby zapsána mezi všechny prvky předané datové struktury,
počet operací je roven <i>n-1</i> v&nbsp;případě, že předaný vektor má počet
prvků <i>n</i>):</p>

<pre>
   <i>NB. Součet všech čísel v řadě od 1 do 10.</i>
   <strong>+ / 1 2 3 4 5 6 7 8 9 10</strong>
55
&nbsp;
   <i>NB. Vektor hodnot můžeme vytvořit</i>
   <i>NB. taktéž s využitím generátoru</i>
   <i>NB. indexů (viz předchozí části</i>
   <i>NB. seriálu). Ovšem pozor - indexy</i>
   <i>NB. se generují od 0, nikoli od 1.</i>
   <strong>+ / i. 10</strong>
45
&nbsp;
   <i>NB. Zde se již vektor skutečně vygeneruje</i>
   <i>NB. tak, že jeho první prvek má</i>
   <i>NB. jedničkovou hodnotu.</i>
   <strong>+ / 1 + i. 10</strong>
55
</pre>

<p>Operátor <strong>/</strong> je však samozřejmě možné použít i
v&nbsp;kombinaci s&nbsp;libovolnou dyadickou funkcí &ndash; může se jednat jak
o aritmetické funkce, tak i o funkce logické (booleovské), porovnávací
(relační), maticové aj. Následují příklady použití některých těchto funkcí;
nejprve funkcí booleovských aplikovaných na vektory binárních hodnot:</p>

<pre>
   <i>NB. Použití booleovské funkce "or"</i>
   <i>NB. (logický součet)</i>
   <strong>+./ 0 0 0 0</strong>
0
&nbsp;
   <strong>+./ 0 0 0 1</strong>
1
&nbsp;
   <strong>+./ 1 1 1 1</strong>
1
&nbsp;
   <i>NB. Použití booleovské funkce "and"</i>
   <i>NB. (logický součin)</i>
   <strong>*./ 0 0 0 0</strong>
0
&nbsp;
   <strong>*./ 0 0 0 1</strong>
0
&nbsp;
   <strong>*./ 1 1 1 1</strong>
1
&nbsp;
   <i>NB. Použití booleovské funkce ekvivalence</i>
   <strong>=/ 0 0 0 0</strong>
1
&nbsp;
   <strong>=/ 0 0 0 1</strong>
0
&nbsp;
   <strong>=/ 1 1 1 1</strong>
1
&nbsp;
   <i>NB. Použití booleovské funkce "xor"</i>
   <i>NB. (nonekvivalence)</i>
   <strong>~:/ 0 0 0 0</strong>
0
&nbsp;
   <strong>~:/ 0 0 0 1</strong>
1
&nbsp;
   <strong>~:/ 1 1 1 1</strong>
0
</pre>

<p>Mezi další dyadické funkce, které lze zkombinovat s&nbsp;operátorem
<strong>/</strong>, patří například funkce pro výpočet (zjištění) minima,
maxima, součinu (zde korespondujících prvků vektorů) a mocniny o zvoleném
základu:</p>

<pre>
   <i>NB. Výběr nejmenšího prvku z vektoru.</i>
   <strong>&lt;. / 5 4 67 2 1 42 3 7 6</strong>
1
&nbsp;
   <i>NB. Výběr největšího prvku z vektoru.</i>
   <strong>&gt;. / 5 4 67 2 1 42 3 7 6</strong>
67
&nbsp;
   <i>NB. Jeden ze způsobů výpočtu skalárního</i>
   <i>NB. součinu dvou vektorů.</i>
   <strong>+/ (1 2 3) * (1 2 3)</strong>
14
&nbsp;
   <i>NB. Skalární součin dvou na sebe kolmých</i>
   <i>NB. vektorů je vždy nulový.</i>
   <strong>+/ (1 0 0) * (0 1 0)</strong>
0
&nbsp;
   <i>NB. Výpočet prvních deseti mocnin</i>
   <i>NB. základu 2 (včetně 2^0).</i>
   <strong>2 ^ i. 10</strong>
1 2 4 8 16 32 64 128 256 512
&nbsp;
   <i>NB. Suma prvních deseti mocnin</i>
   <i>NB. základu 2. Výsledek by měl</i>
   <i>NB. být roven: (2^(n+1))-1</i>
   <strong>+ / 2 ^ i. 10</strong>
1023
&nbsp;
   <i>NB. Výpočet známé úlohy se šachovnicí a semínky</i>
   <i>NB. kladenými na jednotlivá políčka šachovnice.</i>
   <strong>2 ^ i. 64</strong>
1 2 4 8 16 32 64 128 256 512 1024 2048 4096 8192
16384 32768 65536 131072 262144 524288 1.04858e6
2.09715e6 4.1943e6 8.38861e6 1.67772e7 3.35544e7
6.71089e7 1.34218e8 2.68435e8 5.36871e8 1.07374e9
2.14748e9 4.29497e9 8.58993e9 1.71799e10 3.43597e10 6.87195...
&nbsp;
   <i>NB. Celkový počet všech semínek na šachovnici.</i>
   <strong>+ / 2 ^ i. 64</strong>
1.84467e19
</pre>

<p>Nyní si ukážeme příklad převzatý z&nbsp;elektronické knihy &bdquo;J for C
Programmers&ldquo;, ve kterém je předvedeno, jakým způsobem je možné pomocí
operátoru <strong>/</strong> nalézt největší prvek v&nbsp;matici (zmíněná
elektronická kniha je obsažena přímo v&nbsp;instalaci vývojového prostředí
programovacího jazyka <i>J</i>). Nejprve si uveďme odpovídající céčkový
program, který nalezne prvek s&nbsp;maximální hodnotou v&nbsp;(dvourozměrné)
matici <i>x</i>, jejíž rozměry jsou uloženy v&nbsp;konstantách <i>xsize0</i> a
<i>xsize1</i>:</p>

<pre>
int i, j;
float maxval = x[0][0];
for (i = 0; i&jt;=xsize0; ++i)
{
    for (j = 0; j&lt;=xsize1; ++j)
    {
        if (x[i][j] &gt; maxval)
        {
            maxval = x[i][j];
        }
    }
}
</pre>

<p>V&nbsp;programovacím jazyku <i>J</i> lze maximální prvek v&nbsp;matici
nalézt dvojí aplikací operátoru <strong>/</strong> zkombinovaného s&nbsp;funkcí
<strong>&gt;.</strong> (ta provádí výběr větší hodnoty z&nbsp;dvojice předaných
parametrů, tj.&nbsp;jak skalárních hodnot, tak i vektorů popř.&nbsp;matic).
První aplikace operátoru <strong>/</strong> slouží k&nbsp;výběru těch prvků na
jednotlivých řádcích matice, které mají největší hodnotu, druhá aplikace pak
již z&nbsp;tohoto mezivýsledku (tj.&nbsp;vektoru) vybere přímo maximální
hodnotu, takže se celá sekvence zanořených smyček a podmíněného příkazu
v&nbsp;programovacím jazyku <i>J</i> zmenší na jediný výraz. Ve skutečnosti je
však možné podmíněný příkaz eliminovat i v&nbsp;céčkovém programu, stačí ho
nahradit například voláním makra <strong>MAX</strong>, což však již není možné
v&nbsp;příkladu uvedeném níže. Navíc si nikde nemusíme pamatovat rozměry pole
(matice), neboť ty lze kdykoli za běhu programu zjistit:</p>

<pre>
   <i>NB. Nejprve si vytvoříme matici</i>
   <i>NB. s testovacími daty.</i>
   <strong>matice =: 3 3 $ _4 + i.9</strong>
   <strong>matice</strong>
_4 _3 _2
_1  0  1
 2  3  4
&nbsp;
   <i>NB. Nalezneme největší prvek v matici</i>
   <i>NB. dvojím použitím operátoru /</i>
   <strong>(&lt;./) &lt;./ matice</strong>
4
</pre>

<p>Druhý demonstrační příklad je již poněkud složitější &ndash; nalezení
sloupce, ve kterém se nachází prvek s&nbsp;maximální hodnotou &ndash;, ale při
použití programovacího jazyka <i>J</i> se opět obejdeme bez nutnosti použití
programových smyček a podmínek. Sloupec, ve kterém se prvek s&nbsp;největší
hodnotou v&nbsp;matici nachází, lze zjistit s&nbsp;využitím dyadické funkce
<strong>i.</strong> (<i>index of</i>), která vrací index prvního prvku
obsahujícího danou hodnotu (prvním parametrem této funkce je většinou vektor,
druhým parametrem hledaná hodnota). Povšimněte si především použití závorek,
které eliminují nutnost dvojího použití mezivýsledku &gt;./ matice
v&nbsp;zapisovaném výrazu:</p>

<pre>
<strong>(i. &gt;./) &gt;./ matice</strong>
</pre>

<p>Céčkovský ekvivalent je stále mnohonásobně delší kvůli nutnosti použití
programových smyček a podmínek:</p>

<pre>
int i, j, maxcol = 0;
float maxval = x[0][0];
for (i = 0; i&jt;=xsize0; ++i)
{
    for (j = 0; j&lt;=xsize1; ++j)
    {
        if (x[i][j] &gt; maxval)
        {
            maxval = x[i][j];
            maxcol = j
        }
    }
}
</pre>



<p><a name="k19"></a></p>
<h2 id="k19">19. Dyadická forma operátoru <strong>/</strong></h2>

<p>Při popisu programovacího jazyka <i>APL</i> jsme se mj.&nbsp;zmínili i o
operátoru &bdquo;outer product&ldquo; zapisovaného dvojicí symbolů &#9702;.
(kolečko+tečka) za nimiž následovalo jméno či symbol nějaké primitivní funkce
popř.&nbsp;identifikátor uživatelské dyadické funkce. Tento operátor je založen
na principu aplikace zvolené dyadické funkce na dvojici vektorů <i>x</i> a
<i>y</i>, přičemž vybraná funkce je aplikována na všechny možné kombinace
složek prvního a druhého vektoru. Výsledkem této operace je matice <i>Z</i>
obsahující v&nbsp;prvku <i>z<sub>ij</sub></i> návratovou hodnotu funkce
aplikované na prvky <i>x<sub>i</sub></i> a <i>y<sub>j</sub></i>. Význam tohoto
operátoru jsme si vysvětlili na příkladu, ve kterém se vytvořila a následně
vypsala část tabulky malé násobilky (pozor &ndash; následující úryvek kódu je
zapsaný v&nbsp;syntaxi odpovídající programovacímu jazyku <i>APL</i>, nikoli
<i>J</i>):</p>

<pre>
     <strong>1 2 3 4 5 &#9702;.&times; 1 2 3 4 5</strong>
1 2 3 4 5
2 4 6 8 10
3 6 9 12 15
4 8 12 16 20
5 10 15 20 25
</pre>

<p>Podobně jsme v&nbsp;APL postupovali při výpočtu prvočísel:</p>

<pre>
(~R∊R∘.×R)/R←1↓⍳x
</pre>



<p><a name="k20"></a></p>
<h2 id="k20">20. Odkazy na Internetu</h2>

<ol>

<li>Jazyky umožňující operace s&nbsp;poli aneb rozsáhlý svět „array programmingu“<br />
<a href="https://www.root.cz/clanky/jazyky-umoznujici-operace-s-poli-aneb-rozsahly-svet-bdquo-array-programmingu-ldquo/">https://www.root.cz/clanky/jazyky-umoznujici-operace-s-poli-aneb-rozsahly-svet-bdquo-array-programmingu-ldquo/</a>
</li>

<li>Programovací technika nazvaná <i>tacit programming</i><br />
<a href="https://www.root.cz/clanky/programovaci-technika-nazvana-tacit-programming/">https://www.root.cz/clanky/programovaci-technika-nazvana-tacit-programming/</a>
</li>

<li>Oslava 55 let od vzniku první implementace jazyka APL<br />
<a href="https://www.root.cz/clanky/oslava-55-let-od-vzniku-prvni-implementace-programovaciho-jazyka-apl/">https://www.root.cz/clanky/oslava-55-let-od-vzniku-prvni-implementace-programovaciho-jazyka-apl/</a>
</li>

<li>NuVoc<br />
<a href="https://code.jsoftware.com/wiki/NuVoc">https://code.jsoftware.com/wiki/NuVoc</a>
</li>

<li>J (programming language) [Wikipedia]<br />
<a href="https://en.wikipedia.org/wiki/J_%28programming_language%29">https://en.wikipedia.org/wiki/J_%28programming_language%29</a>
</li>

<li>J &ndash; Absolutely Essential Terms<br />
<a href="https://code.jsoftware.com/wiki/Vocabulary/AET">https://code.jsoftware.com/wiki/Vocabulary/AET</a>
</li>

<li>J &ndash; Atoms and Arrays<br />
<a href="https://code.jsoftware.com/wiki/Vocabulary/Nouns#Atom">https://code.jsoftware.com/wiki/Vocabulary/Nouns#Atom</a>
</li>

<li>Why J<br />
<a href="https://www.jsoftware.com/help/primer/why_j.htm">https://www.jsoftware.com/help/primer/why_j.htm</a>
</li>

<li>What is an Array?<br />
<a href="https://vector.org.uk/what-is-an-array/">https://vector.org.uk/what-is-an-array/</a>
</li>

<li>Comments<br />
<a href="http://www.gavilan.edu/csis/languages/comments.html">http://www.gavilan.edu/csis/languages/comments.html</a>
</li>

<li>Vector (Wolfram MathWorld)<br />
<a href="https://mathworld.wolfram.com/Vector.html">https://mathworld.wolfram.com/Vector.html</a>
</li>

<li>n-Tuple (Wolfram MathWorld)<br />
<a href="https://mathworld.wolfram.com/n-Tuple.html">https://mathworld.wolfram.com/n-Tuple.html</a>
</li>

<li>n-Vector (Wolfram MathWorld)<br />
<a href="https://mathworld.wolfram.com/n-Vector.html">https://mathworld.wolfram.com/n-Vector.html</a>
</li>

<li>Matrix (Wolfram MathWorld)<br />
<a href="https://mathworld.wolfram.com/Matrix.html">https://mathworld.wolfram.com/Matrix.html</a>
</li>

<li>Array (Wolfram MathWorld)<br />
<a href="https://mathworld.wolfram.com/Array.html">https://mathworld.wolfram.com/Array.html</a>
</li>

<li>ND Arrays (Tensors) in different languages<br />
<a href="https://www.youtube.com/watch?v=WbpbEilgQBc">https://www.youtube.com/watch?v=WbpbEilgQBc</a>
</li>

<li>Extending APL to Infinity\<br />
<a href="https://www.jsoftware.com/papers/eem/infinity.htm">https://www.jsoftware.com/papers/eem/infinity.htm</a>
</li>

<li>Vector Library (R7RS-compatible)<br />
<a href="https://srfi.schemers.org/srfi-133/srfi-133.html">https://srfi.schemers.org/srfi-133/srfi-133.html</a>
</li>

<li>Vectors (pro Gauche)<br />
<a href="https://practical-scheme.net/gauche/man/gauche-refe/Vectors.html">https://practical-scheme.net/gauche/man/gauche-refe/Vectors.html</a>
</li>

<li>Kawa: Compiling Scheme to Java<br />
<a href="https://www.mit.edu/afs.new/sipb/project/kawa/doc/kawa-tour.html">https://www.mit.edu/afs.new/sipb/project/kawa/doc/kawa-tour.html</a>
</li>

<li>Kawa in Languages shootout<br />
<a href="http://per.bothner.com/blog/2010/Kawa-in-shootout/">http://per.bothner.com/blog/2010/Kawa-in-shootout/</a>
</li>

<li>Kawa 2.0 Supports Scheme R7RS<br />
<a href="https://developers.slashdot.org/story/14/12/13/2259225/kawa-20-supports-scheme-r7rs/">https://developers.slashdot.org/story/14/12/13/2259225/kawa-20-supports-scheme-r7rs/</a>
</li>

<li>Kawa — fast scripting on the Java platform<br />
<a href="https://lwn.net/Articles/623349/">https://lwn.net/Articles/623349/</a>
</li>

<li>Incanter is a Clojure-based, R-like platform for statistical computing and graphics.<br />
<a href="http://incanter.org/">http://incanter.org/</a>
</li>

<li>Evolution of incanter (Gource Visualization)<br />
<a href="https://www.youtube.com/watch?v=TVfL5nPELr4">https://www.youtube.com/watch?v=TVfL5nPELr4</a>
</li>

<li>Questions tagged [incanter] (na Stack Overflow)<br />
<a href="https://stackoverflow.com/questions/tagged/incanter?sort=active">https://stackoverflow.com/questions/tagged/incanter?sort=active</a>
</li>

<li>Data Sorcery with Clojure<br />
<a href="https://data-sorcery.org/contents/">https://data-sorcery.org/contents/</a>
</li>

<li>Back to the Future: Lisp as a Base for a Statistical Computing System<br />
<a href="https://rd.springer.com/chapter/10.1007/978-3-7908-2084-3_2">https://rd.springer.com/chapter/10.1007/978-3-7908-2084-3_2</a>
</li>

<li>Incanter Cheat Sheet<br />
<a href="http://incanter.org/docs/incanter-cheat-sheet.pdf">http://incanter.org/docs/incanter-cheat-sheet.pdf</a>
</li>

<li>Back to the Future: Lisp as a Base for a Statistical Computing System (celá verze článku)<br />
<a href="https://www.researchgate.net/publication/227019917_Back_to_the_Future_Lisp_as_a_Base_for_a_Statistical_Computing_System">https://www.researchgate.net/publication/227019917_Back_to_the_Future_Lisp_as_a_Base_for_a_Statistical_Computing_System</a>
</li>

<li>BQN: finally, an APL for your flying saucer<br />
<a href="https://mlochbaum.github.io/BQN/">https://mlochbaum.github.io/BQN/</a>
</li>

<li>Is BQN stable?<br />
<a href="https://mlochbaum.github.io/BQN/commentary/stability.html">https://mlochbaum.github.io/BQN/commentary/stability.html</a>
</li>

<li>Specification: BQN system-provided values<br />
<a href="https://mlochbaum.github.io/BQN/spec/system.html">https://mlochbaum.github.io/BQN/spec/system.html</a>
</li>

<li>Tutorial: BQN expressions<br />
<a href="https://mlochbaum.github.io/BQN/tutorial/expression.html">https://mlochbaum.github.io/BQN/tutorial/expression.html</a>
</li>

<li>BQN primitives<br />
<a href="https://mlochbaum.github.io/BQN/doc/primitive.html">https://mlochbaum.github.io/BQN/doc/primitive.html</a>
</li>

<li>Function trains<br />
<a href="https://mlochbaum.github.io/BQN/doc/train.html">https://mlochbaum.github.io/BQN/doc/train.html</a>
</li>

<li>BQN community links<br />
<a href="https://mlochbaum.github.io/BQN/community/index.html">https://mlochbaum.github.io/BQN/community/index.html</a>
</li>

<li>BQN UV<br />
<a href="https://observablehq.com/@lsh/bqn-uv">https://observablehq.com/@lsh/bqn-uv</a>
</li>

<li>APL Wiki<br />
<a href="https://aplwiki.com/wiki/">https://aplwiki.com/wiki/</a>
</li>

<li>The Array Cast<br />
<a href="https://www.arraycast.com/episodes/episode-03-what-is-an-array">https://www.arraycast.com/episodes/episode-03-what-is-an-array</a>
</li>

<li>EnthusiastiCon 2019 &ndash; An Introduction to APL<br />
<a href="https://www.youtube.com/watch?v=UltnvW83_CQ">https://www.youtube.com/watch?v=UltnvW83_CQ</a>
</li>

<li>Dyalog<br />
<a href="https://www.dyalog.com/">https://www.dyalog.com/</a>
</li>

<li>Try APL!<br />
<a href="https://tryapl.org/">https://tryapl.org/</a>
</li>

<li>Lisp-Stat Information<br />
<a href="http://homepage.cs.uiowa.edu/~luke/xls/xlsinfo/">http://homepage.cs.uiowa.edu/~luke/xls/xlsinfo/</a>
</li>

<li>Sample Plots in Incanter<br />
<a href="https://github.com/incanter/incanter/wiki/Sample-Plots-in-Incanter#line">https://github.com/incanter/incanter/wiki/Sample-Plots-in-Incanter#line</a>
</li>

<li>vectorz-clj<br />
<a href="https://github.com/mikera/vectorz-clj">https://github.com/mikera/vectorz-clj</a>
</li>

<li>vectorz &ndash; Examples<br />
<a href="https://github.com/mikera/vectorz-clj/wiki/Examples">https://github.com/mikera/vectorz-clj/wiki/Examples</a>
</li>

<li>Basic Vector and Matrix Operations in Julia: Quick Reference and Examples<br />
<a href="https://queirozf.com/entries/basic-vector-and-matrix-operations-in-julia-quick-reference-and-examples">https://queirozf.com/entries/basic-vector-and-matrix-operations-in-julia-quick-reference-and-examples</a>
</li>

<li>Vectors and matrices in Julia<br />
<a href="https://fncbook.github.io/v1.0/linsys/demos/matrices-julia.html">https://fncbook.github.io/v1.0/linsys/demos/matrices-julia.html</a>
</li>

<li>Array vs Matrix in R Programming<br />
<a href="https://www.geeksforgeeks.org/array-vs-matrix-in-r-programming/">https://www.geeksforgeeks.org/array-vs-matrix-in-r-programming/</a>
</li>

<li>Concurrency (computer science)<br />
<a href="https://en.wikipedia.org/wiki/Category:Concurrency_%28computer_science%29">https://en.wikipedia.org/wiki/Category:Concurrency_%28computer_science%29</a>
</li>

<li>Koprogram<br />
<a href="https://cs.wikipedia.org/wiki/Koprogram">https://cs.wikipedia.org/wiki/Koprogram</a>
</li>

<li>Coroutine<br />
<a href="https://en.wikipedia.org/wiki/Coroutine">https://en.wikipedia.org/wiki/Coroutine</a>
</li>

<li>Coroutines in C<br />
<a href="http://www.chiark.greenend.org.uk/~sgtatham/coroutines.html">http://www.chiark.greenend.org.uk/~sgtatham/coroutines.html</a>
</li>

<li>S-expression (Wikipedia)<br />
<a href="https://en.wikipedia.org/wiki/S-expression">https://en.wikipedia.org/wiki/S-expression</a>
</li>

<li>S-Expressions (Rosetta Code)<br />
<a href="http://rosettacode.org/wiki/S-Expressions">http://rosettacode.org/wiki/S-Expressions</a>
</li>

<li>Introducing Julia/Metaprogramming<br />
<a href="https://en.wikibooks.org/wiki/Introducing_Julia/Metaprogramming">https://en.wikibooks.org/wiki/Introducing_Julia/Metaprogramming</a>
</li>

<li>Tutorial for the Common Lisp Loop Macro<br />
<a href="http://www.ai.sri.com/pkarp/loop.html">http://www.ai.sri.com/pkarp/loop.html</a>
</li>

<li>Clojure Macro Tutorial (Part I, Getting the Compiler to Write Your Code For You)<br />
<a href="http://www.learningclojure.com/2010/09/clojure-macro-tutorial-part-i-getting.html">http://www.learningclojure.com/2010/09/clojure-macro-tutorial-part-i-getting.html</a>
</li>

<li>Clojure Macro Tutorial (Part II: The Compiler Strikes Back)<br />
<a href="http://www.learningclojure.com/2010/09/clojure-macro-tutorial-part-ii-compiler.html">http://www.learningclojure.com/2010/09/clojure-macro-tutorial-part-ii-compiler.html</a>
</li>

<li>Clojure Macro Tutorial (Part III: Syntax Quote)<br />
<a href="http://www.learningclojure.com/2010/09/clojure-macro-tutorial-part-ii-syntax.html">http://www.learningclojure.com/2010/09/clojure-macro-tutorial-part-ii-syntax.html</a>
</li>

<li>Clojure Macros and Metaprogramming<br />
<a href="http://clojure-doc.org/articles/language/macros.html">http://clojure-doc.org/articles/language/macros.html</a>
</li>

<li>Fatvat &ndash; Exploring functional programming: Clojure Macros<br />
<a href="http://www.fatvat.co.uk/2009/02/clojure-macros.html">http://www.fatvat.co.uk/2009/02/clojure-macros.html</a>
</li>

<li>CS 2101 Parallel Computing with Julia<br />
<a href="https://www.coursehero.com/file/11508091/CS-2101-Parallel-Computing-with-Julia/">https://www.coursehero.com/file/11508091/CS-2101-Parallel-Computing-with-Julia/</a>
</li>

<li>Julia By Example<br />
<a href="https://samuelcolvin.github.io/JuliaByExample/">https://samuelcolvin.github.io/JuliaByExample/</a>
</li>

<li>Array Programming<br />
<a href="https://en.wikipedia.org/wiki/Array_programming">https://en.wikipedia.org/wiki/Array_programming</a>
</li>

<li>Discovering Array Languages<br />
<a href="http://archive.vector.org.uk/art10008110">http://archive.vector.org.uk/art10008110</a>
</li>

<li>no stinking loops -- Kalothi<br />
<a href="http://www.nsl.com/">http://www.nsl.com/</a>
</li>

<li>Vector (obsahuje odkazy na články, knihy a blogy o programovacích jazycích APL, J a K)<br />
<a href="http://www.vector.org.uk/">http://www.vector.org.uk/</a>
</li>

<li>APL Interpreters<br />
<a href="http://www.vector.org.uk/?area=interpreters">http://www.vector.org.uk/?area=interpreters</a>
</li>

<li>APL_(programming_language<br />
<a href="http://en.wikipedia.org/wiki/APL_(programming_language">http://en.wikipedia.org/wiki/APL_(programming_language</a>
</li>

<li>APL FAQ<br />
<a href="http://www.faqs.org/faqs/apl-faq/">http://www.faqs.org/faqs/apl-faq/</a>
</li>

<li>APL FAQ (nejnovější verze)<br />
<a href="http://home.earthlink.net/~swsirlin/apl.faq.html">http://home.earthlink.net/~swsirlin/apl.faq.html</a>
</li>

<li>A+<br />
<a href="http://www.aplusdev.org/">http://www.aplusdev.org/</a>
</li>

<li>APLX<br />
<a href="http://www.microapl.co.uk/">http://www.microapl.co.uk/</a>
</li>

<li>FreeAPL<br />
<a href="http://www.pyr.fi/apl/index.htm">http://www.pyr.fi/apl/index.htm</a>
</li>

<li>Learning J (Roger Stokes)<br />
<a href="http://www.jsoftware.com/help/learning/contents.htm">http://www.jsoftware.com/help/learning/contents.htm</a>
</li>

<li>J: a modern, high-level, general-purpose, high-performance programming language<br />
<a href="http://www.jsoftware.com/">http://www.jsoftware.com/</a>
</li>

<li>K, Kdb: an APL derivative for Solaris, Linux, Windows<br />
<a href="http://www.kx.com">http://www.kx.com</a>
</li>

<li>openAPL (GPL)<br />
<a href="http://sourceforge.net/projects/openapl">http://sourceforge.net/projects/openapl</a>
</li>

<li>Parrot APL (GPL)<br />
<a href="http://www.parrotcode.org/">http://www.parrotcode.org/</a>
</li>

<li>Learning J (Roger Stokes)<br />
<a href="http://www.jsoftware.com/help/learning/contents.htm">http://www.jsoftware.com/help/learning/contents.htm</a>
</li>

<li>Rosetta Code<br />
<a href="http://rosettacode.org/wiki/Main_Page">http://rosettacode.org/wiki/Main_Page</a>
</li>

<li>Why APL<br />
<a href="http://www.acm.org/sigapl/whyapl.htm">http://www.acm.org/sigapl/whyapl.htm</a>
</li>

<li>Introducing Julia/Functions<br />
<a href="https://en.wikibooks.org/wiki/Introducing_Julia/Functions">https://en.wikibooks.org/wiki/Introducing_Julia/Functions</a>
</li>

<li>Functions (Julia documentation)<br />
<a href="https://docs.julialang.org/en/v1/manual/functions/">https://docs.julialang.org/en/v1/manual/functions/</a>
</li>

<li>Evaluate binomial coefficients<br />
<a href="http://rosettacode.org/wiki/Evaluate_binomial_coefficients">http://rosettacode.org/wiki/Evaluate_binomial_coefficients</a>
</li>

<li>Ackermann function<br />
<a href="http://rosettacode.org/wiki/Ackermann_function">http://rosettacode.org/wiki/Ackermann_function</a>
</li>

<li>Julia (front page)<br />
<a href="http://julialang.org/">http://julialang.org/</a>
</li>

<li>Julia &ndash; dokumentace<br />
<a href="http://docs.julialang.org/">http://docs.julialang.org/</a>
</li>

<li>Julia &ndash; repositář na GitHubu<br />
<a href="https://github.com/JuliaLang/julia">https://github.com/JuliaLang/julia</a>
</li>

<li>Julia (programming language)<br />
<a href="https://en.wikipedia.org/wiki/Julia_%28programming_language%29">https://en.wikipedia.org/wiki/Julia_%28programming_language%29</a>
</li>

<li>IJulia<br />
<a href="https://github.com/JuliaLang/IJulia.jl">https://github.com/JuliaLang/IJulia.jl</a>
</li>

<li>Introducing Julia<br />
<a href="https://en.wikibooks.org/wiki/Introducing_Julia">https://en.wikibooks.org/wiki/Introducing_Julia</a>
</li>

<li>Julia: the REPL<br />
<a href="https://en.wikibooks.org/wiki/Introducing_Julia/The_REPL">https://en.wikibooks.org/wiki/Introducing_Julia/The_REPL</a>
</li>

<li>Month of Julia<br />
<a href="https://github.com/DataWookie/MonthOfJulia">https://github.com/DataWookie/MonthOfJulia</a>
</li>

<li>Learn X in Y minutes (where X=Julia)<br />
<a href="https://learnxinyminutes.com/docs/julia/">https://learnxinyminutes.com/docs/julia/</a>
</li>

<li>New Julia language seeks to be the C for scientists<br />
<a href="http://www.infoworld.com/article/2616709/application-development/new-julia-language-seeks-to-be-the-c-for-scientists.html">http://www.infoworld.com/article/2616709/application-development/new-julia-language-seeks-to-be-the-c-for-scientists.html</a>
</li>

<li>Julia: A Fast Dynamic Language for Technical Computing<br />
<a href="http://karpinski.org/publications/2012/julia-a-fast-dynamic-language">http://karpinski.org/publications/2012/julia-a-fast-dynamic-language</a>
</li>

<li>The LLVM Compiler Infrastructure<br />
<a href="http://llvm.org/">http://llvm.org/</a>
</li>

<li>Julia: benchmarks<br />
<a href="http://julialang.org/benchmarks/">http://julialang.org/benchmarks/</a>
</li>

<li>Type system<br />
<a href="https://en.wikipedia.org/wiki/Type_system">https://en.wikipedia.org/wiki/Type_system</a>
</li>

<li>Half-precision floating-point format<br />
<a href="https://en.wikipedia.org/wiki/Half-precision_floating-point_format">https://en.wikipedia.org/wiki/Half-precision_floating-point_format</a>
</li>

<li>Dartmouth BASIC<br />
<a href="https://en.wikipedia.org/wiki/Dartmouth_BASIC">https://en.wikipedia.org/wiki/Dartmouth_BASIC</a>
</li>

<li>BASIC 4th Edition<br />
<a href="http://www.bitsavers.org/pdf/dartmouth/BASIC_4th_Edition_Jan68.pdf">http://www.bitsavers.org/pdf/dartmouth/BASIC_4th_Edition_Jan68.pdf</a>
</li>

<li>VECTRAN<br />
<a href="https://encyclopedia2.thefreedictionary.com/VECTRAN">https://encyclopedia2.thefreedictionary.com/VECTRAN</a>
</li>

<li>Comparison of programming languages (array)<br />
<a href="https://en.wikipedia.org/wiki/Comparison_of_programming_languages_(array)">https://en.wikipedia.org/wiki/Comparison_of_programming_languages_(array)</a>
</li>

<li>BASIC at 50<br />
<a href="https://www.dartmouth.edu/basicfifty/commands.html">https://www.dartmouth.edu/basicfifty/commands.html</a>
</li>

<li>BBC Basic - arrays<br />
<a href="http://www.riscos.com/support/developers/bbcbasic/part2/arrays.html">http://www.riscos.com/support/developers/bbcbasic/part2/arrays.html</a>
</li>

<li>Datová struktura<br />
<a href="https://cs.wikipedia.org/wiki/Datov%C3%A1_struktura">https://cs.wikipedia.org/wiki/Datov%C3%A1_struktura</a>
</li>

<li>SIMD instrukce využívané v&nbsp;moderních mikroprocesorech řady x86<br />
<a href="https://www.root.cz/clanky/simd-instrukce-vyuzivane-v-modernich-mikroprocesorech-rady-x86/">https://www.root.cz/clanky/simd-instrukce-vyuzivane-v-modernich-mikroprocesorech-rady-x86/</a>
</li>

<li>SIMD instrukce v&nbsp;moderních mikroprocesorech řady x86 (2.část: SSE)<br />
<a href="https://www.root.cz/clanky/simd-instrukce-v-modernich-mikroprocesorech-rady-x86-2-cast-sse/">https://www.root.cz/clanky/simd-instrukce-v-modernich-mikroprocesorech-rady-x86-2-cast-sse/</a>
</li>

<li>SIMD instrukce v&nbsp;moderních mikroprocesorech řady x86 (3.část: SSE2)<br />
<a href="https://www.root.cz/clanky/simd-instrukce-v-modernich-mikroprocesorech-rady-x86-3-cast-sse2/">https://www.root.cz/clanky/simd-instrukce-v-modernich-mikroprocesorech-rady-x86-3-cast-sse2/</a>
</li>

</ol>



<p></p><p></p>
<p><small>Autor: <a href="http://www.fit.vutbr.cz/~tisnovpa">Pavel Tišnovský</a> &nbsp; 2021</small></p>
</body>
</html>

