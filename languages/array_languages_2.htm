<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
        "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html>
<head>
<title>Specializované jazyky pro práci s N-dimenzionálními poli: jazyk J</title>
<meta name="Author" content="Pavel Tisnovsky" />
<meta name="Generator" content="vim" />
<meta http-equiv="content-type" content="text/html; charset=utf-8" />
<style type="text/css">
         body {color:#000000; background:#ffffff;}
         h1  {font-family: arial, helvetica, sans-serif; color:#ffffff; background-color:#c00000; text-align:center; padding-left:1em}
         h2  {font-family: arial, helvetica, sans-serif; color:#ffffff; background-color:#0000c0; padding-left:1em; text-align:left}
         h3  {font-family: arial, helvetica, sans-serif; color:#000000; background-color:#c0c0c0; padding-left:1em; text-align:left}
         h4  {font-family: arial, helvetica, sans-serif; color:#000000; background-color:#e0e0e0; padding-left:1em; text-align:left}
         a   {font-family: arial, helvetica, sans-serif;}
         li  {font-family: arial, helvetica, sans-serif; color:#000000; text-align:justify; width:450px;}
         ol  {font-family: arial, helvetica, sans-serif; color:#000000; text-align:justify; width:450px;}
         ul  {font-family: arial, helvetica, sans-serif; color:#000000; text-align:justify; width:450px;}
         p   {font-family: arial, helvetica, sans-serif; color:#000000; text-align:justify;}
         pre {background:#e0e0e0}
</style>
</head>

<body>

<h1>Specializované jazyky pro práci s N-dimenzionálními poli: jazyk J</h1>

<h3>Pavel Tišnovský</h3>

<p></p>

<h1>Úvodník</h1>

<p></p>



<h2>Obsah</h2>

<p><a href="#k01">*** 1. Specializované jazyky pro práci s&nbsp;N-dimenzionálními poli: jazyk J</a></p>
<p><a href="#k02">2. Od APL k&nbsp;programovacímu jazyku J</a></p>
<p><a href="#k03">3. Překlad interpretru jazyka J</a></p>
<p><a href="#k04">4. Zápis programů v&nbsp;jazyku J</a></p>
<p><a href="#k05">*** 5. Atomy a N-dimenzionální pole v&nbsp;programovacím jazyku J</a></p>
<p><a href="#k06">6. Primitivní funkce jazyka J</a></p>
<p><a href="#k07">*** 7. Pravidla pro pojmenování primitivních funkcí</a></p>
<p><a href="#k08">*** 8. Vyhodnocování aritmetických a logických výrazů</a></p>
<p><a href="#k09">*** 9. Operace s&nbsp;vektory v&nbsp;programovacím jazyku J</a></p>
<p><a href="#k10">*** 10. Základní aritmetické operátory aplikované na vektory</a></p>
<p><a href="#k11">*** 11. Výběr prvků z&nbsp;vektorů (selektory)</a></p>
<p><a href="#k12">*** 12. Konstrukce vektorů založená na generátorech (indexů)</a></p>
<p><a href="#k13">*** 13. Matice</a></p>
<p><a href="#k14">*** 14. Predikáty pracující s&nbsp;atomy, vektory i maticemi</a></p>
<p><a href="#k15">*** 15. </a></p>
<p><a href="#k16">*** 16. </a></p>
<p><a href="#k17">*** 17. </a></p>
<p><a href="#k18">*** 18. </a></p>
<p><a href="#k19">*** 19. Cyklus se uzavírá: od APL přes jazyk J k&nbsp;BQN</a></p>
<p><a href="#k20">20. Odkazy na Internetu</a></p>



<p><a name="k01"></a></p>
<h2 id="k01">1. Specializované jazyky pro práci s&nbsp;N-dimenzionálními poli: jazyk J</h2>

<p><i>&bdquo;It is easier to learn enough Basic or Java to solve trivial
problems, but it is easier to learn enough J to solve more interesting and
challenging problems.&ldquo;</i></p>

<p></p>



<p><a name="k02"></a></p>
<h2 id="k02">2. Od APL k&nbsp;programovacímu jazyku J</h2>

<p><i>&bdquo;Real Programmers don't write in APL, unless the whole program can
be written on one line&ldquo;</i></p>

<p>Historie programovacího jazyka <i>APL</i>, s&nbsp;nímž jsme se seznámili již
<a
href="https://www.root.cz/clanky/oslava-55-let-od-vzniku-prvni-implementace-programovaciho-jazyka-apl/">v&nbsp;tomto
článku</a>, se začala psát již v&nbsp;roce 1957. Právě tehdy <i>Kenneth E.
Iverson</i>, který v&nbsp;té době pracoval na Harvardské universitě, navrhl
zcela novou notaci určenou pro jednotný zápis matematických funkcí i pro tvorbu
funkcí nových. Tato notace byla prakticky ve všech ohledech odlišná od zavedené
notace (resp.&nbsp;přesněji řečeno) notací, které se v&nbsp;matematice
používaly. V&nbsp;roce 1962 byla tato notace popsána v&nbsp;knize nazvané
&bdquo;A Programming Language&ldquo; a (což původně vlastně ani nebylo
plánováno) o několik let později se začaly objevovat skutečné interpretry i
překladače programovacího jazyka používajícího stejné symboly, jaké popsal
Iverson ve své knize. Konkrétně se jednalo o jazyk nazvaný <i>IVSYS</i>, který
byl implementovaný v&nbsp;roce 1966 (což ovšem ještě nebyl <i>skutečný</i> APL,
který byl následován jazykem <i>APL\360</i> z&nbsp;roku 1966 a poté jazykem
<i>APL\1130</i> z&nbsp;roku 1968, jenž pracoval na počítači <i>IBM
1130</i>.</p>

<p>Kenneth Iverson se rozvoji a propagaci jazyka <i>APL</i> aktivně věnoval
více než 20 let, za což mu poprávu byla v&nbsp;roce 1979 udělena Turingova cena
(<i>Turing Award</i>). Později Iverson navrhl programovací jazyk <i>J</i>,
v&nbsp;němž se místo speciálních symbolů používají pouze znaky obsažené
v&nbsp;ASCII tabulce (viz další kapitoly s&nbsp;podrobnějšími informacemi).
Vraťme se však k&nbsp;<i>APL</i>. Specifikace tohoto programovacího jazyka se
od poloviny šedesátých let minulého století několikrát změnila (rozšířila).
Jedním z&nbsp;nejvíce důležitých rozšíření je <i>APL2</i> od J.&nbsp;Browna
z&nbsp;IBM, které do jazyka zavedlo podporu pro rekurzivní datové struktury
(tedy, jak uvidíme dále, pro pole jako prvky jiných polí, což je mimochodem
dále zobecněno v&nbsp;jazyku <i>BQN</i> a vlastně i v&nbsp;jazyku <i>J</i>).
Většina dnešních implementací tohoto programovacího jazyka se snaží dodržovat
specifikaci <i>APL2</i>, i když je jazyk dále rozšiřován (například
v&nbsp;<i>APLX verze 4</i> byla přidána podpora pro objektově orientované
programování, i když v&nbsp;poněkud jiné podobě, než ji známe
z&nbsp;mainstreamových programovacích jazyků). Z&nbsp;moderních implementací
APL se pak musíme zmínit o komerčním projektu <i>Dyalog APL</i>.</p>

<p>Nesmíme ovšem ignorovat fakt, že i přes všechny zajímavé rysy má
programovací jazyk <i>APL</i> i několik nectností, ostatně jako každý
programovací jazyk, který vznikl na samotném začátku vývoje interpretrů a
překladačů, tj.&nbsp;v&nbsp;době, kdy ještě nebyla teorie překladačů tak
rozvinutá jako v&nbsp;pozdějších letech (nejvíce byla neexistence teorie
překladačů patrná u prvního překladače <i>Fortranu</i> vytvořeného firmou IBM,
jehož vývoj by byl při uplatnění dnešních znalostí mnohem rychlejší, levnější,
samozřejmě i samotný jazyk by vypadal poněkud jinak). Už při letmém pohledu na
algoritmy resp.&nbsp;celé programy napsané v&nbsp;programovacím jazyce
<i>APL</i> je zřejmé, že se v&nbsp;něm používá velké množství symbolů, které se
nenachází ve znakové sadě ASCII, což je sice velmi unikátní vlastnost (právě
proto mnozí v&nbsp;<i>APL</i> programují čistě pro radost z&nbsp;vizuální
podoby programů), ale způsobuje poměrně velké problémy, jak při zápisu programů
(rozložení znaků na klávesnici), tak i při jejich úpravách, prezentaci na
Internetu (zdaleka ne všechny fonty obsahují všechny požadované symboly)
atd.</p>

<p><div class="rs-tip-major">Poznámka: ve skutečnosti jsou tyto problémy do
značné míry již vyřešeny, protože <a
href="http://xahlee.info/comp/unicode_APL_symbols.html">znaky jazyka APL byl
přidány do Unicode</a>.</div></p>

<p>Některé nedostatky programovacího jazyka <i>APL</i> jsou obsaženy i
v&nbsp;jeho samotné sémantice, což je mnohem závažnější, než
&bdquo;pouhý&ldquo; vzhled zápisu nebo problémy při tisku nebo prezentacích.
Jmenujme například zápis řídicích struktur s&nbsp;využitím čísel řádků (podobně
jako v&nbsp;BASICu, i když čísla řádků jsou v&nbsp;<i>APL</i> pro každou funkci
lokální, což například znemožňuje provádět skoky dovnitř funkcí o odstraňuje
vzájemnou závislost jednotlivých funkcí). A taktéž se ukázalo, že by bylo
vhodné, aby byl do mnohem větší míry podporován <i>tacit programming</i>, jímž
jsme se zabývali <a
href="https://www.root.cz/clanky/programovaci-technika-nazvana-tacit-programming/">v&nbsp;samostatném
článku</a>. Z&nbsp;výše uvedených důvodů otec jazyka <i>APL</i> (již zmiňovaný
<i>Kenneth Iverson</i>) na počátku devadesátých let minulého století navrhl
nový programovací jazyk nazvaný jednoduše <i>J</i>, který některé výše zmíněné
nedostatky jazyka <i>APL</i> odstranil a navíc tento nový programovací jazyk
rozšířil o některé důležité nové rysy, primitivní funkce i operátory.
V&nbsp;dalších kapitolách si stručně popíšeme zejména ty vlastnosti jazyka
<i>J</i>, které souvisí se zpracováním polí a vůbec k&nbsp;přístupu k&nbsp;této
velmi důležité datové struktuře.</p>

<p><div class="rs-tip-major">Poznámka: na tomto místě je pro úplnost nutno
dodat, že moderní dialekty jazyka APL už vyřešily většinu výše zmíněných
problémů. Moderní APL se tedy v&nbsp;tomto ohledu přiblížilo k&nbsp;jazyku J,
kterým se budeme zabývat dnes (což se týká i podpory pro tacit programming
apod.).</div></p>



<p><a name="k03"></a></p>
<h2 id="k03">3. Překlad interpretru jazyka J</h2>

<p>Na stránce <a href="http://www.jsoftware.com">http://www.jsoftware.com</a>
jsou nabízeny balíčky s&nbsp;interpretrem jazyka <i>J</i> určené pro všechny
tři nejrozšířenější desktopové operační systémy. Po instalaci (která
v&nbsp;případě Linuxu spočívá v&nbsp;prostém spuštění staženého skriptu
s&nbsp;parametrem <tt>-install</tt>) se nainstaluje jak interpret
programovacího jazyka <i>J</i> (představovaného knihovnou <i>libj.so</i> popř.
<i>j.dll</i>), tak i konzolové (řádkové) rozhraní k&nbsp;interpretru
(<i>jconsole</i>) a vývojové prostředí naprogramované původně v&nbsp;Javě
(<i>jwd</i>), dnes dostupné přes webové rozhraní.  Pro odzkoušení
demonstračních programů postačuje spustit řádkové rozhraní interpretru jazyka
<i>J</i> z&nbsp;terminálu resp.&nbsp;z&nbsp;konzole &ndash; jedná se o program
nazvaný <i>jconsole</i>.</p>

<p><div class="rs-tip-major">Poznámka: pozor &ndash; tento program je nutné
spustit s&nbsp;uvedením cesty, například <tt>./jconsole</tt>, v&nbsp;opačném
případě by se mohla spustit stejnojmenná utilita dodávaná spolu
s&nbsp;JDK.</div></p>

<p>Protože se však nacházíme na Rootu, ukážeme si, jakým způsobem je možné
konzoli s&nbsp;interpretrem programovacího jazyka J přeložit přímo ze
zdrojových kódů. Projekt s&nbsp;jazykem J totiž po velmi dlouhé době, kdy se
jednalo o projekt dosti izolovaný od ostatního světa a s&nbsp;relativně
uzavřenou a malou komunitou, nabízí zdrojové kódy dostupné přes GitHub a
přeložitelné jednoduše z&nbsp;příkazové řádky.</p>

<p>Celý postup překladu je jednoduchý. Nejdříve je nutné naklonovat repositář
se zdrojovými kódy (kombinace C a J):</p>

<pre>
$ <strong>git clone git@github.com:jsoftware/jsource.git</strong>
</pre>

<p>Dále se v&nbsp;podadresáři <strong>make2</strong> spustí skript nazvaný
<strong>build_all</strong>:</p>

<pre>
$ <strong>cd make2</strong>
$ <strong>./build_all</strong>
</pre>

<p>Překlad je ve výchozím nastavení prováděn v&nbsp;jediném vláknu, ovšem ani
tak netrvá dlouho. Po dokončení činnosti skriptu <strong>build_all</strong> by
se měl v&nbsp;podadresáři <strong>bin/linux/j64avx</strong> objevit jak
interpret (představovaný knihovnou), tak i aplikace <strong>jconsole</strong>,
která interpret jazyka J spustí:</p>

<pre>
$ <strong>cd ..</strong>
</pre>

<p>O výsledku překladu se snadno přesvědčíme:</p>

<pre>
$ <strong>ls -la bin/linux/j64avx/</strong>
&nbsp;
total 4192
drwxrwxr-x 2 ptisnovs ptisnovs     100 Dec  6 19:54 .
drwxrwxr-x 3 ptisnovs ptisnovs      60 Dec  6 19:46 ..
-rwxrwxr-x 1 ptisnovs ptisnovs   57184 Dec  6 19:52 jconsole
-rwxrwxr-x 1 ptisnovs ptisnovs 4201104 Dec  6 19:54 libj.so
-rwxrwxr-x 1 ptisnovs ptisnovs   31984 Dec  6 19:54 libtsdll.so
</pre>

<p>Samotný interpret je možné spustit takto:</p>

<pre>
$ <strong>bin/linux/j64avx/jconsole</strong>
</pre>

<a href="http://i.iinfo.cz/images/25/j-lang1-4.png"><img src="http://i.iinfo.cz/images/25/j-lang1-4-prev.png" width="370" height="265" alt="j_lang1_4" /></a>
<p><i>Obrázek 1: Původní vývojové prostředí (vytvořené v&nbsp;Javě) dodávané
spolu s&nbsp;interpretrem programovacího jazyka J.</i></p>



<p><a name="k04"></a></p>
<h2 id="k04">4. Zápis programů v&nbsp;jazyku J</h2>

<p>Nyní, když již máme k&nbsp;dispozici interpret jazyka J, si můžeme prakticky
vyzkoušet některé jeho vlastnosti. Nejprve si řekneme, jak vypadá struktura
zapsaných programů. Způsob zápisu programů v&nbsp;programovacím jazyku <i>J</i>
se v&nbsp;mnoha ohledech podobá zápisu používaném v&nbsp;programovacím jazyku
<i>APL</i>. Na každém textovém řádku je (tedy většinou &ndash; pokud je autor
při smyslech) zapsán jeden výraz, který je interpretrem ihned po svém zápisu
zpracován a vyhodnocen. V&nbsp;případě, že je výraz zapsaný
v&nbsp;interaktivním režimu (například z&nbsp;aplikace <i>jconsole</i>), je
výsledek výrazu ihned po jeho vyhodnocení vytištěn na terminál &ndash; právě
tento způsob práce, který je ostatně společný většině interpretovaných
programovacích jazyků, budeme používat ve všech následujících demonstračních
příkladech (příkazy zadávané uživatelem jsou pro odlišení zpráv interpretru
odsazeny od levého okraje, což je implicitní chování nástroje <i>jconsole</i>;
taktéž jsou příkazy zadávané uživatelem zvýrazněny pomocí tučného písma).</p>

<p>Zajímavý a nutno říci, že i dosti neobvyklý je i zápis komentářů.
V&nbsp;mnoha programovacích jazycích se pro označení začátku jednořádkových
komentářů používá speciální znak či znaky. Například v&nbsp;<i>C++</i>,
<i>Javě</i> či <i>JavaScriptu</i> se jedná o dvojici znaků &bdquo;//&ldquo;
(nebo o &bdquo;komentářové závorky&ldquo; /* a */ pro víceřádkové komentáře) a
v&nbsp;shellu i Pythonu o jeden znak &bdquo;#&ldquo;. V&nbsp;programovacím
jazyku <i>J</i> je ovšem vše jinak. Zde se totiž začátek komentáře označuje
trojicí znaků &bdquo;NB.&ldquo;. Veškerý text na řádku zapsaný za těmito znaky
je interpretrem ignorován. To tedy znamená, že můžeme psát:</p>

<pre>
   <i>NB. komentar umisteny na zacatku programoveho radku</i>
&nbsp;
   <strong>1+2*3</strong> <i>NB. komentar umisteny za vyrazem, samotny vyraz se vykona a vypise se jeho vysledek</i>
7
   <i>NB. tento vyraz se nevykona, nebot je soucasti komentare: 1+2*3</i>
</pre>

<p><div class="rs-tip-major">Poznámka: způsob zápisu komentářů v&nbsp;různých
programovacích jazycích je shrnut na stránce <a
href="http://www.gavilan.edu/csis/languages/comments.html">http://www.gavilan.edu/csis/languages/comments.html</a>.</div></p>



<p><a name="k05"></a></p>
<h2 id="k05">5. Atomy a N-dimenzionální pole v&nbsp;programovacím jazyku J</h2>

<p>V&nbsp;programovacím jazyku J se primárně rozlišují dvě skupiny typů hodnot.
První skupinu tvoří <i>atomy</i> (<i>atom</i>), druhou skupinu pak <i>pole</i>
(<i>array</i>). Atomy neboli skaláry je skupina tvořená třemi datovými
typy:</p>

<ol>
<li>numerický typ</li>
<li>znakový typ</li>
<i><i>box</i></i>
</ol>

<p>Nejzajímavějším atomárním neboli skalárním datovým typem je <i>box</i>.
Tento název je velmi přiléhavý, protože se skutečně jedná o jakýsi obal, který
může obsahovat libovolnou jinou hodnotu &ndash; ať již skalární, tak i pole.
Díky existenci <i>boxů</i> je sice typový systém programovacího jazyka J
poměrně flexibilní, ovšem ukazuje se, že komplikuje práci s&nbsp;poli. Proto je
například v&nbsp;jazyku BQN, který je ideovým pokračovatelem APL i J, použit
odlišný typový systém.</p>

<p>Ústředním prvkem jazyka J jsou ovšem <i>pole</i>. Na pole se můžeme dívat jako na skupinu atomů organizovaných podél os (<i>axes</i>), přičemž počet os určuje dimenzi pole. Os přitom může být (prakticky) libovolný počet &ndash; J tedy nemá žádná omezení, která jsme mohli vidět například v&nbsp;BBC BASICU či v&nbsp;Dartmouth BASICu..</p>

pole
atomy organizovane podel os (axes)
homogenni!
spec. nazvy
list - pole s jednou osou
table - pole se dvema osami
brick - pole se tremi osami
pozor - seznam s jedním prvkem je odlišný od skaláru!

   i. 3
0 1 2

   i. 2 3
0 1 2
3 4 5

   i. 2 3 4
 0  1  2  3
 4  5  6  7
 8  9 10 11

12 13 14 15
16 17 18 19
20 21 22 23

vyse - homogenni
boxy umoznuji obejiti teto podminky
boxing - vytvoreni atomu (boxu) jehoz obsah je prakticky libovolny
lze tedy vytvorit pole boxu
omezeni - box neni numerickym typem, tudiz nelze pouzit v aritmetickych operacich
box je mozne otevrit (open) a ziskat tak jeho obsah

   (<'abc')   NB. Put the string into a box
+---+
|abc|
+---+
   (<'abc'),(<1 2 3)   NB. OK to join two boxes
+---+-----+
|abc|1 2 3|
+---+-----+
   (<'abc'),(<1 2 3),(<1;2)
+---+-----+-----+
|abc|1 2 3|+-+-+|
|   |     ||1|2||
|   |     |+-+-+|
+---+-----+-----+

   (<'abc'),(<1;2;3),(<1;2)
+---+-------+-----+
|abc|+-+-+-+|+-+-+|
|   ||1|2|3|||1|2||
|   |+-+-+-+|+-+-+|
+---+-------+-----+

rank - počet os
atom 0
list 1
table 2
brick 3

   # $ 42
0
   # $ 1 2 3
1
   # $ 1 2 3 4
1
   # $ i. 2 3
2
   # $ i. 2 3 4
3
   # $ (<'abc'),(<1;2;3),(<1;2)
1


shape - seznam obsahující počet atomů podél každé osy
prázdný seznam pro atom

   $ 42

   $ 1 2 3
3
   $ i. 2 3
2 3
   $ i. 2 3 4
2 3 4
   $ (<'abc'),(<1;2;3),(<1;2)
3

index list of an atom of an array is a list, whose length is the rank of the array, which gives the coordinates of the atom in the array

cell
"nekompletní" index

příklad "bricku" s tvarem 2 3 4
k  An array with frame  of k-cells whose shape is
0  2 3 4  empty
1  2 3  4
2  2  3 4
3  empty  2 3 4



<p><a name="k06"></a></p>
<h2 id="k06">6. Primitivní funkce jazyka J</h2>

<p>Podobně jako v&nbsp;programovacím jazyku <i>APL</i>, nalezneme i v&nbsp;dnes
popisovaném jazyku <i>J</i> poměrně velké množství primitivních (neboli
základních) funkcí. Ty však nejsou reprezentovány speciálními symboly
(&bdquo;hieroglyfy&ldquo;), ale jedním nebo větším množstvím nealfanumerických
ASCII znaků, takže jejich zápis i editace je jednodušší, než tomu bylo
v&nbsp;případě <i>APL</i> (na druhou stranu nevypadají zapsané algoritmy tak
efektně a možná i elegantně :-). Primitivní funkce mohou akceptovat buď jeden
parametr (to jsou takzvané <i>monadické funkce</i>) nebo parametry dva
(<i>funkce dyadické</i>). Název monadických funkcí je uveden
v&nbsp;<i>prefixové</i> podobě, tj.&nbsp;vždy před svým parametrem, zatímco
dyadické funkce jsou zapisovány v&nbsp;podobě infixové &ndash; mezi oběma
parametry, čímž se efektivně v&nbsp;mnoha případech eliminuje nutnost použití
závorek (ty jsou ovšem taktéž podporovány). Znaky, kterými jsou primitivní
funkce pojmenovány, jsou většinou použity minimálně dvakrát &ndash; jednou pro
zápis monadické funkce, podruhé pro zápis funkce dyadické, jejíž význam bývá
v&nbsp;menší či větší míře podobný příslušné monadické funkci.</p>

<p><div class="rs-tip-major">Poznámka: na monadické i dyadické funkce se taktéž
můžeme dívat jako na operátory, protože se ostatně jako operátory zapisují
&ndash; buď před operand nebo mezi oba operandy.</div></p>

<a href="http://i.iinfo.cz/images/72/j-lang1-5.png"><img src="http://i.iinfo.cz/images/72/j-lang1-5-prev.png" width="370" height="265" alt="j_lang1_5" /></a>
<p><i>Obrázek 2: Interpret jazyka J je poměrně bohatě vybaven i možností práce
s&nbsp;různými typy grafů, což je (spolu s&nbsp;podporou snadné práce
s&nbsp;vektory a maticemi) jeden z&nbsp;důvodů poměrně velké oblíbenosti tohoto
jazyka mezi inženýry.</i></p>



<p><a name="k07"></a></p>
<h2 id="k07">7. Pravidla pro pojmenování primitivních funkcí</h2>

<p>Kromě použití stejného znaku pro pojmenování nějaké primitivní monadické a současně i dyadické funkce může být navíc za znakem představujícím jméno primitivní funkce uveden symbol &bdquo;:&ldquo; (dvojtečka) nebo &bdquo;.&ldquo; (tečka), což v&nbsp;praxi znamená, že tentýž znak může být ve skutečnosti použit pro pojmenování až šesti různých primitivních funkcí. Například pro znak &bdquo;&lt;&ldquo; existuje celkem pět různých forem, které byly Iversonem a jeho kolegy při návrhu jazyka <i>J</i> zvoleny tak, aby buď přímo odpovídaly významu tohoto znaku v&nbsp;matematickém zápisu, nebo měly alespoň podobný význam. Zmíněný znak je (nejenom) v&nbsp;matematice spojen se slovem &bdquo;menší&ldquo;, takže je použit i pro implementaci funkce vyhledání minima či dekrementaci/zmenšení operandu o jedničku, jak je ostatně patrné z&nbsp;následujících výrazů a jejich výsledku po vyhodnocení interpretrem programovacího jazyka <i>J</i> (v&nbsp;příkladech jsou jako parametry použity i vektory):</p>

<pre>
   NB. dyadicka funkce
   NB. porovnani dvou hodnot na relaci "mensi nez"
   1 &lt; 2
1
   2 &lt; 2
0
   NB. porovnavat lze i slozky vektoru
   1 2 3 &lt; 3 2 1
1 0 0
&nbsp;
   NB. Dyadicka funkce ukoncena dvojteckou
   NB. porovnani dvou hodnot na relaci "mensi nebo rovno"
   1 &lt;: 2
1
   2 &lt;: 2
1
   NB. opet lze porovnavat i slozky vektoru
   1 2 3 &lt;: 3 2 1
1 1 0
&nbsp;
   NB. dyadicka funkce ukoncena teckou
   NB. vrati mensi operand (parametr) = odpovida funkci min
   1 &lt;. 2
1
   2 &lt;. 1
1
   NB. porovnani prislusnych slozek vektoru a vraceni mensi z nich
   1 2 1 &lt;: 3 2 1
1 2 1

   NB. monadicka funkce ukoncena teckou
   NB. zaokrouhleni smerem dolu (obdoba ceckove funkce floor)
   &lt;. 2.5
2
   &lt;. 2.9
2
   NB. tuto funkci lze samozrejme volat i na vektory
   &lt;. 1.9 2.0 2.1 2.9
1 2 2 2
&nbsp;
   NB. monadicka funkce ukoncena dvojteckou
   NB. operace dekrementace (obdoba ceckoveho operatoru --)
   &lt;: 1
0
   &lt;: 10
9
   &lt;: 1 2 3
0 1 2
   &lt;: 0 1 2
_1 0 1
</pre>



<p><a name="k08"></a></p>
<h2 id="k08">8. Vyhodnocování aritmetických a logických výrazů</h2>

<p>Aritmetické a logické výrazy, které tvoří nejdůležitější součást všech
programů zapisovaných v&nbsp;jazyku <i>J</i>, se vyhodnocují stejným způsobem,
jako v&nbsp;již popsaném programovacím jazyku <i>APL</i>, tj.&nbsp;zprava
doleva bez toho, aby některé funkce měly vyšší prioritu než funkce jiné. Funkce
se zapisují stejným způsobem jako v&nbsp;jiných jazycích prefixové a infixové
operátory, tj.&nbsp;buď mezi oba argumenty (operandy) při volání dyadických
funkcí nebo před jediný argument v&nbsp;případě, že se volá funkce monadická.
Pokud je zapotřebí změnit pořadí volání funkcí, lze k&nbsp;tomuto účelu použít
obligátní kulaté závorky. V&nbsp;jazyku <i>J</i> je k&nbsp;dispozici pět
základních aritmetických funkcí, které jsou vypsány v&nbsp;tabulce pod
odstavcem (povšimněte si především odlišného způsobu zápisu funkce podílu dvou
hodnot). Způsob použití těchto funkcí i způsob úpravy priority (pořadí volání)
je patrný z&nbsp;demonstračních příkladů uvedených pod tabulkou.</p>

<table>
<tr><th>Znak funkce</th><th>Monadická funkce</th><th>Dyadická funkce</th></tr>
<tr><td>+ </td><td>negace imaginární složky komplexního čísla</td><td>součet (skalárů, vektorů, matic...)</td></tr>
<tr><td>- </td><td>negace            </td><td>rozdíl</td></tr>
<tr><td>* </td><td>vrací znaménko    </td><td>součin</td></tr>
<tr><td>% </td><td>převrácená hodnota</td><td>podíl</td></tr>
<tr><td>| </td><td>absolutní hodnota </td><td>zbytek</td></tr>
<tr><td>^ </td><td>&nbsp;            </td><td>umocnění x<sup>y</sup></td></tr>
<tr><td>*:</td><td>druhá mocnina x<sup>2</sup></td><td>&nbsp;</td></tr>
<tr><td>%:</td><td>druhá odmocnina x<sup>1/2</sup></td><td>&nbsp;</td></tr>
<tr><td>! </td><td>faktoriál</td><td>&nbsp;</td></tr>
</table>

<pre>
   1+2*3
7
   1+(2*3)
7
   (1+2)*3
9
   NB. funkce jsou vyhodnocovany zprava doleva,
   NB. tj. zde nejdrive soucet a teprve pote soucin
   3*2+1
9
   3*(2+1)
9
   NB. zmena poradi vyhodnoceni funkci pomoci zavorek
   (3*2)+1
7
   NB. zaporna cisla jsou zapisovana se symbolem _
   10-20
_10
   42%3
14

   NB. druha mocnina je zapisovana pomoci monadicke funkce *:
   *: 10
100

   NB. vypocet prevracene (reciproke) hodnoty
   % 3
0.33333

   NB. vypocet desate mocniny
   2^10
1024
   2^(_10)
0.000976562

   NB. aritmeticke funkce lze pouzit i pro soucet vektoru
   1 2 3 + 4 5 6
5 7 9

   NB. vydeleni skalarni hodnoty postupne vsemi slozkami vektoru
   42 % 2 3 4
21 14 10.5

   NB. kazda slozka vektoru je umocnena na desatou
   2 3 4 ^ 10
1024 59049 1.04858e6

   NB. vypocet druhych mocnin vsech slozek vektoru
   *: 1 2 3 4
1 4 9 16

   NB. vypocet faktorialu (samozrejme je pouzit prefixovy zapis)
   !6
720
   !170
7.25742e306
   NB. tento zapis si podrobneji vysvetlime priste
   !i.10
1 1 2 6 24 120 720 5040 40320 362880
</pre>



<p><a name="k09"></a></p>
<h2 id="k09">9. Operace s&nbsp;vektory v&nbsp;programovacím jazyku J</h2>

<p>Jak jsme se již dozvěděli z&nbsp;úvodního textu, je programovací jazyk <i>J</i>, podobně jako jeho ideový předchůdce <i>APL</i>, určen především pro tvorbu aplikací, v&nbsp;nichž se zpracovávají data uložená ve vektorech, maticích či polích s&nbsp;větším počtem dimenzí (může se jednat například o hierarchické mřížky atd.). Z&nbsp;tohoto důvodu je jazyk <i>J</i> vybaven jak jednoduchou syntaxí určenou pro zápis vektorů a matic, tak i sadou primitivních (základních) funkcí, pomocí nichž lze nad vektory i maticemi provádět různé operace. Nejprve si popíšeme primitivní funkce určené pro vytváření i další práci s&nbsp;vektory, které jsou vypsány v&nbsp;následující tabulce. U všech popisovaných funkcí bude uvedena i informace o tom, zda se jedná o funkci <i>monadickou</i> (tj.&nbsp;s&nbsp;jedním parametrem zapisovaným za symbol funkce) či <i>dyadickou</i> (s&nbsp;dvojicí parametrů, z&nbsp;nichž první se zapisuje před a druhý za symbol funkce). Tato informace je v&nbsp;případě jazyků <i>J</i> i <i>APL</i> velmi důležitá, protože již víme, že stejný symbol může být použit pro pojmenování dvou primitivních funkcí lišících se &bdquo;pouze&ldquo; počtem svých parametrů:</p>

<table>
<tr><th>Symbol funkce</th><th>Forma funkce</th><th>Popis funkce (význam)</th></tr>
<tr><td>+ - * %</td><td>dyadická</td><td>základní aritmetické operace prováděné nad dvojicí vektorů na korespondujících prvcích (též prováděné nad skalárem a vektorem)</td></tr>
<tr><td>&lt; &lt;: &gt; &gt;: = ~:</td><td>dyadická</td><td>porovnání korespondujících prvků dvou vektorů</td></tr>
<tr><td># </td><td>monadická</td><td>vrací délku vektoru</td></tr>
<tr><td># </td><td>dyadická </td><td>kopie prvků vektoru představovaného druhým parametrem</td></tr>
<tr><td>{ </td><td>dyadická </td><td>výběr prvku či více prvků z&nbsp;vektoru na základě indexů vybíraných prvků</td></tr>
<tr><td>{.</td><td>dyadická </td><td>výběr prvních <i>n</i> prvků z&nbsp;vektoru</td></tr>
<tr><td>}.</td><td>dyadická </td><td>výběr posledních <i>délka-n</i> prvků vektoru (= odstranění prvních <i>n</i> prvků)</td></tr>
<tr><td>, </td><td>dyadická </td><td>spojení dvou vektorů či vektoru se skalárem</td></tr>
<tr><td>/:</td><td>monadická</td><td>setřídění prvků vektoru sestupně (funkce vrací indexy prvků, ne jejich hodnoty)</td></tr>
<tr><td>\:</td><td>monadická</td><td>setřídění prvků vektoru vzestupně (funkce též vrací indexy prvků, ne jejich hodnoty)</td></tr>
<tr><td>i.</td><td>monadická</td><td>vytváří seznam (vektor) obsahující řadu čísel začínající nulou, popř.&nbsp;prázdný vektor</td></tr>
<tr><td>i:</td><td>monadická</td><td>vytváří seznam (vektor) obsahující čísla on <i>-n</i> do <i>n</i>, kde <i>n</i> je parametr funkce</td></tr>
<tr><td>p.</td><td>monadická</td><td>výpočet kořenů polynomu reprezentovaného vektorem obsahujícím koeficienty <i>a<sub>i</sub></i></td></tr>
</table>



<p><a name="k10"></a></p>
<h2 id="k10">10. Základní aritmetické operátory aplikované na vektory</h2>

<p>Základní aritmetické operace, se kterými jsme se již seznámili v&nbsp;předchozích kapitolách, je možné využít i při práci s&nbsp;vektory. V&nbsp;tomto případě se operace provádí vždy nad dvojicí odpovídajících prvků (<i>dyadické funkce</i>) popř.&nbsp;postupně pro všechny prvky vektoru (<i>funkce monadické</i>). Pokud nejsou délky vektorů shodné, nahlásí interpretr jazyka <i>J</i> chybu typu &bdquo;length error&ldquo;:</p>

<pre>
   NB. Nejdříve vytvoříme tři proměnné
   NB. představující trojici vektorů
   x =: 1 2 3 4
   y =: 9 8 7 6
   z =: 11 12

   NB. Čtyři základní aritmetické operace
   NB. (součet, rozdíl, součin, podíl)
   NB. prováděné nad prvky vektorů
   x+y
10 10 10 10
   y-x
8 6 4 2
   x*y
9 16 21 24
   x%y
0.111111 0.25 0.428571 0.666667

   NB. Následující příkaz skončí s chybou
   NB. neboť délky vektorů (=počty jejich
   NB. prvků) nejsou shodné
   x+z
|length error
|   x    +z
</pre>

<p>Při použití aritmetických funkcí může být jedním z&nbsp;parametrů i skalární
hodnota, viz následující demonstrační příklady:</p>

<pre>
   NB. Při volání aritmetických funkcí
   NB. je možné zkombinovat skalární hodnotu
   NB. s vektorem
   2 * x
2 4 6 8
   x * 2
2 4 6 8

   NB. Předchozí dva výrazy 2 * x a 2 * y
   NB. sice vrátily shodný výsledek, ale některé
   NB. další aritmetické operace nejsou
   NB. komutativní, například dělení:
   10 % x
10 5 3.33333 2.5
   x % 10
0.1 0.2 0.3 0.4
</pre>

<p>Následují dva příklady použití dalších funkcí, konkrétně dyadické
exponenciální funkce a monadické funkce pro výpočet faktoriálu:</p>

<pre>
   NB. Při práci s vektory lze samozřejmě
   NB. použít i další primitivní funkce,
   NB. zde například funkci exponenciální
   x^y
1 256 2187 4096

   NB. Monadická funkce (výpočet faktoriálu)
   ! x
1 2 6 24
</pre>



<p><a name="k11"></a></p>
<h2 id="k11">11. Výběr prvků z&nbsp;vektorů (selektory)</h2>

<p>Další důležitou a současně i často používanou skupinou základních
(primitivních) funkcí určených pro práci s&nbsp;vektory jsou funkce, které
umožňují z&nbsp;vektoru vybrat hodnoty některých prvků. Jedná se o rozšíření
funkcí &bdquo;take&ldquo; a &bdquo;drop&ldquo;, se kterými jsme se již
seznámili při popisu programovacího jazyka <i>APL</i>, ovšem s&nbsp;tím
rozdílem, že prvky vektorů jsou v&nbsp;případě jazyka <i>J</i> číslovány od
nuly, tj.&nbsp;první prvek má index roven 0 a index posledního prvku je roven
délce vektoru-1. Dále se v&nbsp;této skupině nachází funkce umožňující provést
spojení dvou vektorů, která se zapisuje pomocí ASCII znaku "<strong>,</strong>"
&ndash; čárka. V&nbsp;aplikacích se poměrně často vyskytuje i funkce vracející
délku vektoru (ASCII znak "<strong>#</strong>"). V&nbsp;případě matic či polí
tato funkce vrací rozměr všech jejich dimenzí, což si ukážeme
v&nbsp;navazujících kapitolách:</p>

<pre>
   NB. Nejdříve opět vytvoříme tři proměnné
   NB. představující trojici vektorů
   x =: 1 2 3 4
   y =: 9 8 7 6
   z =: 11 12

   NB. Zjistíme délky (počet prvků) všech vektorů
   #x
4
   #y
4
   #z
2

   NB. Spojení vektorů pomocí primitivní
   NB. funkce , (čárka)
   w =: x,y,z
   w
1 2 3 4 9 8 7 6 11 12

   NB. Jak je výsledný vektor w dlouhý?
   #w
10

   NB. Výběr pátého prvku (s indexem 4)
   4 { w
9
   NB. Výběr pátého, šestého a sedmého
   NB. prvku vektoru w (obdoba funkce take)
   4 5 6 { w
9 8 7

   NB. Výběr prvních čtyř prvků vektoru
   4 {. w
1 2 3 4

   NB. Vrácení vektoru BEZ jeho prvních
   NB. čtyř prvků (obdoba funkce drop)
   4 }. w
9 8 7 6 11 12
</pre>



<p><a name="k12"></a></p>
<h2 id="k12">12. Konstrukce vektorů založená na generátorech (indexů)</h2>

<p>Nyní si ve stručnosti ukážeme způsob použití takzvaných <i>generátorů
indexů</i> představovaných primitivními funkcemi zapisovanými pomocí
symbolů <i>i.</i> a <i>i:</i>. Jedná se o funkce, které odpovídají primitivní
funkci &iota;, s&nbsp;níž jsme se již seznámili při popisu programovacího jazyka
<i>APL</i>, ovšem s&nbsp;tím podstatným rozdílem, že první číslo generované
funkcí <i>i.</i> má hodnotu nula, nikoli jedna, a poslední číslo má hodnotu
<i>n-1</i> a nikoli <i>n</i> (to souvisí s&nbsp;tím, že v&nbsp;programovacím
jazyce <i>J</i> jsou položky vektorů číslovány&ndash;indexovány od nuly,
podobně jako například v&nbsp;programovacích jazycích C, C++ či Java &ndash;
viz též předchozí kapitolu věnovanou indexování). Povšimněte si taktéž, že se
pomocí funkce <i>i.</i> dá vytvořit velké množství různých (nejenom)
aritmetických řad, takže pro tyto účely není nutné používat programové smyčky.
Navíc mohou být primitivní funkce <i>i.</i> a <i>i:</i> součástí nějakého
složitějšího výrazu, čehož se při psaní aplikací poměrně často využívá,
například při programové tvorbě matic (jednotková matice, trojúhelníková matice
atd.):</p>

<pre>
   NB. Základní použití generátoru indexů
   i. 10
0 1 2 3 4 5 6 7 8 9

   NB. Poměrně snadno můžeme dosáhnout toho,
   NB. aby se počáteční hodnota generované
   NB. číselné řady "posunula"
   20 + i. 10
20 21 22 23 24 25 26 27 28 29

   NB. Řada začínající hodnotou -10
   _10 + i. 10
_10 _9 _8 _7 _6 _5 _4 _3 _2 _1

   NB. Posun a současně i změna "kroku"
   NB. při generování číselné řady
   3 + 0.5 * i. 15
3 3.5 4 4.5 5 5.5 6 6.5 7 7.5 8 8.5 9 9.5 10

   NB. Mocninná řada čísla 2 vytvořená
   NB. bez použití programové smyčky
   2 ^ i. 10
1 2 4 8 16 32 64 128 256 512

   NB. Výpočet prvních faktoriálu prvních deseti
   NB. přirozených čísel a nuly.
   NB. (připomeňme si, že funkce se vyhodnocují
   NB.  zprava doleva, tj. nejdříve se vytvoří
   NB.  vektor čísel, na jehož prvky je aplikována
   NB.  primitivní funkce představující faktoriál)
   ! i. 10
1 1 2 6 24 120 720 5040 40320 362880

   NB. Pomocí primitivní funkce i: lze vygenerovat
   NB. číselnou řadu symetrickou okolo nuly
   i: 10
_10 _9 _8 _7 _6 _5 _4 _3 _2 _1 0 1 2 3 4 5 6 7 8 9 10

   NB. Změna kroku číselné řady
   2* i: 10
_20 _18 _16 _14 _12 _10 _8 _6 _4 _2 0 2 4 6 8 10 12 14 16 18 20

   NB. Opět výpočet mocnin čísla 2, tentokrát však
   NB. včetně záporných exponentů
   2^ i: 5
0.03125 0.0625 0.125 0.25 0.5 1 2 4 8 16 32

   NB. Vytvoření prázdného vektoru (jedna z nejčastěji
   NB. používaných možností tvorby prázdného vektoru)
   i. 0


   NB. Ovšem pozor: v následujícím případě
   NB. se vytvoří vektor obsahující jeden prvek
   i: 0
0
</pre>



<p><a name="k13"></a></p>
<h2 id="k13">13. Matice</h2>

<p>Práce s&nbsp;maticemi je v&nbsp;programovacím jazyku <i>J</i> stejně snadná
jako práce s&nbsp;vektory. Základní funkci při práci s&nbsp;maticemi
představuje funkce <i>reshape</i> zapisovaná pomocí symbolu <strong>$</strong>.
Tato funkce má stejné vlastnosti jako funkce &rho; zmiňovaná při popisu
programovacího jazyka <i>APL</i> &ndash; v&nbsp;prvním parametru (zapisovaného
nalevo od symbolu <strong>$</strong>) jsou uloženy rozměry matice,
v&nbsp;parametru druhém (uváděném napravo od symbolu <strong>$</strong>) pak
její jednotlivé prvky, typicky uložené ve vektoru nebo v&nbsp;jiné matici:</p>

<pre>
   NB. Vytvoření nulové matice
   NB. o rozměrech 3x3 prvky
   3 3 $ 0
0 0 0
0 0 0
0 0 0

   NB. Vytvoření matice a současně
   NB. i nastavení hodnot jejích prvků
   3 2 $ 1 2 3 4 5 6
1 2
3 4
5 6

   NB. Použití generátoru indexů
   NB. při vytváření matice
   3 4 $ i. 12
0 1  2  3
4 5  6  7
8 9 10 11
</pre>

<p>Velmi důležitou &bdquo;maticovou&ldquo; funkcí je funkce pro výpočet
inverzní matice zapisovaná symbolem <strong>%.</strong>. Pomocí této funkce lze
například vypočítat soustavu <i>n</i> rovnic o <i>n</i> neznámých:</p>

<pre>
        x + 2y -3z = 15
        x + y + z = 12
       2x - y - z = 0
</pre>

<p>Nejprve vytvoříme příslušnou matici a zapíšeme do ní koeficienty
(multiplikativní konstanty) uvedené před neznámými:</p>

<pre>
   NB. Prvky ležící na jednotlivých řádcích jsou
   NB. od sebe pro větší přehlednost odděleny
   NB. trojicí mezer.
   m =: 3 3 $   1 2 _3   1 1 1   2 _1 _1
   m
1  2 _3
1  1  1
2 _1 _1
</pre>

<p>S&nbsp;využitím funkce <strong>%.m</strong> lze snadno vypočítat inverzní
matici:</p>

<pre>
   %.m
   0 0.333333   0.333333
 0.2 0.333333  _0.266667
_0.2 0.333333 _0.0666667
</pre>

<p>Po vynásobení inverzní matice vektorem obsahujícím pravé strany rovnic
dostaneme kýžený výsledek &ndash; hodnoty neznámých <i>x</i>, <i>y</i> a
<i>z</i>:</p>

<pre>
   15 12 0 %.m
4 7 1
</pre>



<p><a name="k14"></a></p>
<h2 id="k14">14. Predikáty pracující s&nbsp;atomy, vektory i maticemi</h2>

<p>Pro vzájemné porovnávání skalárních hodnot i hodnot prvků uložených ve
vektorech, maticích i polích s&nbsp;vyššími dimenzemi se používají predikátové
funkce nahrazující relační operátory známé z&nbsp;jiných programovacích jazyků.
Návratovou hodnotou těchto funkcí je buď skalární hodnota 0 nebo 1,
popř.&nbsp;vektor či matice obsahující pouze nuly a jedničky (nula samozřejmě
značí nepravdu, jednička pravdu). Tyto funkce jsou popsány v&nbsp;následující
tabulce. Povšimněte si především způsobu zápisu podmínky &bdquo;menší nebo
rovno&ldquo;, &bdquo;větší nebo rovno&ldquo; a &bdquo;nerovnost&ldquo;, protože
se v&nbsp;nich používají znaky, které jsou oproti jiným programovacím jazykům
odlišné (jenže <strong>co</strong> není v&nbsp;jazyce J odlišné, že?):</p>

<table>
<tr><th>Symbol funkce</th><th>Forma funkce</th><th>Popis (význam)</th></tr>
<tr><td>&lt; </td><td>dyadická</td><td>predikát &bdquo;menší než&ldquo;</td></tr>
<tr><td>&lt;:</td><td>dyadická</td><td>predikát &bdquo;menší nebo rovno&ldquo;</td></tr>
<tr><td>&gt; </td><td>dyadická</td><td>predikát &bdquo;větší než&ldquo;</td></tr>
<tr><td>&gt;:</td><td>dyadická</td><td>predikát &bdquo;větší nebo rovno&ldquo;</td></tr>
<tr><td>=    </td><td>dyadická</td><td>predikát rovnosti</td></tr>
<tr><td>~:   </td><td>dyadická</td><td>predikát nerovnosti</td></tr>
<tr><td>e.   </td><td>dyadická</td><td>predikát &bdquo;obsahuje&ldquo;</td></tr>
</table>

<p>Použití výše uvedených funkcí při porovnávání skalárních hodnot je velmi
snadné:</p>

<pre>
   1 &lt;: 2
1
   1 &gt;: 2
0
   1 &lt;: 1
1
   1 ~: 2
1
   1 ~: 1
0
</pre>

<p>Kromě vzájemného porovnání skalárních hodnot je možné porovnat všechny prvky
vektoru (matice) se skalární hodnotou, popř.&nbsp;prvky dvou vektorů (matic)
navzájem. V&nbsp;tomto případě je výsledkem porovnání též vektor či matice
obsahující hodnoty 0 a 1:</p>

<pre>
   NB. Porovnání všech prvků vektoru se skalární hodnotou
   1 2 3 4 &gt; 2
0 0 1 1
   1 2 3 4 &lt; 2
1 0 0 0
   1 2 3 4 = 2
0 1 0 0

   NB. Porovnání dvou vektorů, které v tomto
   NB. případě musí mít shodnou délku.
   1 2 3 4 &lt; 4 3 2 1
1 1 0 0
</pre>

<p>Poslední funkcí, kterou si v&nbsp;této kapitole popíšeme, je funkce
testující existenci prvku (prvků) ve vektoru či matici. Jedná se o funkci
označovanou symbolem <strong>e.</strong>, jejímž prvním parametrem je skalární
hodnota či vektor hodnot, které se hledají v&nbsp;datové struktuře předané ve
druhém parametru této funkce. Návratovou hodnotou funkce <strong>e.</strong> je
pravdivostní hodnota 0 nebo 1 udávající, zda se příslušná hledaná hodnota
(první parametr) skutečně ve druhém parametru nachází. Pokud se současně
vyhledává více hodnot, je návratovou hodnotou vektor nul a jedniček, jak je to
ostatně ukázáno v&nbsp;následujících demonstračních příkladech:</p>



<p><a name="k15"></a></p>
<h2 id="k15">15. </h2>



<p><a name="k16"></a></p>
<h2 id="k16">16. </h2>



<p><a name="k17"></a></p>
<h2 id="k17">17. </h2>



<p><a name="k18"></a></p>
<h2 id="k18">18. </h2>



<p><a name="k19"></a></p>
<h2 id="k19">19. Cyklus se uzavírá: od APL přes jazyk J k&nbsp;BQN</h2>



<p><a name="k20"></a></p>
<h2 id="k20">20. Odkazy na Internetu</h2>

<ol>

<li>Jazyky umožňující operace s&nbsp;poli aneb rozsáhlý svět „array programmingu“<br />
<a href="https://www.root.cz/clanky/jazyky-umoznujici-operace-s-poli-aneb-rozsahly-svet-bdquo-array-programmingu-ldquo/">https://www.root.cz/clanky/jazyky-umoznujici-operace-s-poli-aneb-rozsahly-svet-bdquo-array-programmingu-ldquo/</a>
</li>

<li>Programovací technika nazvaná <i>tacit programming</i><br />
<a href="https://www.root.cz/clanky/programovaci-technika-nazvana-tacit-programming/">https://www.root.cz/clanky/programovaci-technika-nazvana-tacit-programming/</a>
</li>

<li>Oslava 55 let od vzniku první implementace jazyka APL<br />
<a href="https://www.root.cz/clanky/oslava-55-let-od-vzniku-prvni-implementace-programovaciho-jazyka-apl/">https://www.root.cz/clanky/oslava-55-let-od-vzniku-prvni-implementace-programovaciho-jazyka-apl/</a>
</li>

<li>NuVoc<br />
<a href="https://code.jsoftware.com/wiki/NuVoc">https://code.jsoftware.com/wiki/NuVoc</a>
</li>

<li>J (programming language) [Wikipedia]<br />
<a href="https://en.wikipedia.org/wiki/J_%28programming_language%29">https://en.wikipedia.org/wiki/J_%28programming_language%29</a>
</li>

<li>J &ndash; Absolutely Essential Terms<br />
<a href="https://code.jsoftware.com/wiki/Vocabulary/AET">https://code.jsoftware.com/wiki/Vocabulary/AET</a>
</li>

<li>J &ndash; Atoms and Arrays<br />
<a href="https://code.jsoftware.com/wiki/Vocabulary/Nouns#Atom">https://code.jsoftware.com/wiki/Vocabulary/Nouns#Atom</a>
</li>

<li>Why J<br />
<a href="https://www.jsoftware.com/help/primer/why_j.htm">https://www.jsoftware.com/help/primer/why_j.htm</a>
</li>

<li>What is an Array?<br />
<a href="https://vector.org.uk/what-is-an-array/">https://vector.org.uk/what-is-an-array/</a>
</li>

<li>Comments<br />
<a href="http://www.gavilan.edu/csis/languages/comments.html">http://www.gavilan.edu/csis/languages/comments.html</a>
</li>

<li>Vector (Wolfram MathWorld)<br />
<a href="https://mathworld.wolfram.com/Vector.html">https://mathworld.wolfram.com/Vector.html</a>
</li>

<li>n-Tuple (Wolfram MathWorld)<br />
<a href="https://mathworld.wolfram.com/n-Tuple.html">https://mathworld.wolfram.com/n-Tuple.html</a>
</li>

<li>n-Vector (Wolfram MathWorld)<br />
<a href="https://mathworld.wolfram.com/n-Vector.html">https://mathworld.wolfram.com/n-Vector.html</a>
</li>

<li>Matrix (Wolfram MathWorld)<br />
<a href="https://mathworld.wolfram.com/Matrix.html">https://mathworld.wolfram.com/Matrix.html</a>
</li>

<li>Array (Wolfram MathWorld)<br />
<a href="https://mathworld.wolfram.com/Array.html">https://mathworld.wolfram.com/Array.html</a>
</li>

<li>ND Arrays (Tensors) in different languages<br />
<a href="https://www.youtube.com/watch?v=WbpbEilgQBc">https://www.youtube.com/watch?v=WbpbEilgQBc</a>
</li>

<li>Extending APL to Infinity\<br />
<a href="https://www.jsoftware.com/papers/eem/infinity.htm">https://www.jsoftware.com/papers/eem/infinity.htm</a>
</li>

<li>Vector Library (R7RS-compatible)<br />
<a href="https://srfi.schemers.org/srfi-133/srfi-133.html">https://srfi.schemers.org/srfi-133/srfi-133.html</a>
</li>

<li>Vectors (pro Gauche)<br />
<a href="https://practical-scheme.net/gauche/man/gauche-refe/Vectors.html">https://practical-scheme.net/gauche/man/gauche-refe/Vectors.html</a>
</li>

<li>Kawa: Compiling Scheme to Java<br />
<a href="https://www.mit.edu/afs.new/sipb/project/kawa/doc/kawa-tour.html">https://www.mit.edu/afs.new/sipb/project/kawa/doc/kawa-tour.html</a>
</li>

<li>Kawa in Languages shootout<br />
<a href="http://per.bothner.com/blog/2010/Kawa-in-shootout/">http://per.bothner.com/blog/2010/Kawa-in-shootout/</a>
</li>

<li>Kawa 2.0 Supports Scheme R7RS<br />
<a href="https://developers.slashdot.org/story/14/12/13/2259225/kawa-20-supports-scheme-r7rs/">https://developers.slashdot.org/story/14/12/13/2259225/kawa-20-supports-scheme-r7rs/</a>
</li>

<li>Kawa — fast scripting on the Java platform<br />
<a href="https://lwn.net/Articles/623349/">https://lwn.net/Articles/623349/</a>
</li>

<li>Incanter is a Clojure-based, R-like platform for statistical computing and graphics.<br />
<a href="http://incanter.org/">http://incanter.org/</a>
</li>

<li>Evolution of incanter (Gource Visualization)<br />
<a href="https://www.youtube.com/watch?v=TVfL5nPELr4">https://www.youtube.com/watch?v=TVfL5nPELr4</a>
</li>

<li>Questions tagged [incanter] (na Stack Overflow)<br />
<a href="https://stackoverflow.com/questions/tagged/incanter?sort=active">https://stackoverflow.com/questions/tagged/incanter?sort=active</a>
</li>

<li>Data Sorcery with Clojure<br />
<a href="https://data-sorcery.org/contents/">https://data-sorcery.org/contents/</a>
</li>

<li>Back to the Future: Lisp as a Base for a Statistical Computing System<br />
<a href="https://rd.springer.com/chapter/10.1007/978-3-7908-2084-3_2">https://rd.springer.com/chapter/10.1007/978-3-7908-2084-3_2</a>
</li>

<li>Incanter Cheat Sheet<br />
<a href="http://incanter.org/docs/incanter-cheat-sheet.pdf">http://incanter.org/docs/incanter-cheat-sheet.pdf</a>
</li>

<li>Back to the Future: Lisp as a Base for a Statistical Computing System (celá verze článku)<br />
<a href="https://www.researchgate.net/publication/227019917_Back_to_the_Future_Lisp_as_a_Base_for_a_Statistical_Computing_System">https://www.researchgate.net/publication/227019917_Back_to_the_Future_Lisp_as_a_Base_for_a_Statistical_Computing_System</a>
</li>

<li>BQN: finally, an APL for your flying saucer<br />
<a href="https://mlochbaum.github.io/BQN/">https://mlochbaum.github.io/BQN/</a>
</li>

<li>Is BQN stable?<br />
<a href="https://mlochbaum.github.io/BQN/commentary/stability.html">https://mlochbaum.github.io/BQN/commentary/stability.html</a>
</li>

<li>Specification: BQN system-provided values<br />
<a href="https://mlochbaum.github.io/BQN/spec/system.html">https://mlochbaum.github.io/BQN/spec/system.html</a>
</li>

<li>Tutorial: BQN expressions<br />
<a href="https://mlochbaum.github.io/BQN/tutorial/expression.html">https://mlochbaum.github.io/BQN/tutorial/expression.html</a>
</li>

<li>BQN primitives<br />
<a href="https://mlochbaum.github.io/BQN/doc/primitive.html">https://mlochbaum.github.io/BQN/doc/primitive.html</a>
</li>

<li>Function trains<br />
<a href="https://mlochbaum.github.io/BQN/doc/train.html">https://mlochbaum.github.io/BQN/doc/train.html</a>
</li>

<li>BQN community links<br />
<a href="https://mlochbaum.github.io/BQN/community/index.html">https://mlochbaum.github.io/BQN/community/index.html</a>
</li>

<li>BQN UV<br />
<a href="https://observablehq.com/@lsh/bqn-uv">https://observablehq.com/@lsh/bqn-uv</a>
</li>

<li>APL Wiki<br />
<a href="https://aplwiki.com/wiki/">https://aplwiki.com/wiki/</a>
</li>

<li>The Array Cast<br />
<a href="https://www.arraycast.com/episodes/episode-03-what-is-an-array">https://www.arraycast.com/episodes/episode-03-what-is-an-array</a>
</li>

<li>EnthusiastiCon 2019 &ndash; An Introduction to APL<br />
<a href="https://www.youtube.com/watch?v=UltnvW83_CQ">https://www.youtube.com/watch?v=UltnvW83_CQ</a>
</li>

<li>Dyalog<br />
<a href="https://www.dyalog.com/">https://www.dyalog.com/</a>
</li>

<li>Try APL!<br />
<a href="https://tryapl.org/">https://tryapl.org/</a>
</li>

<li>Lisp-Stat Information<br />
<a href="http://homepage.cs.uiowa.edu/~luke/xls/xlsinfo/">http://homepage.cs.uiowa.edu/~luke/xls/xlsinfo/</a>
</li>

<li>Sample Plots in Incanter<br />
<a href="https://github.com/incanter/incanter/wiki/Sample-Plots-in-Incanter#line">https://github.com/incanter/incanter/wiki/Sample-Plots-in-Incanter#line</a>
</li>

<li>vectorz-clj<br />
<a href="https://github.com/mikera/vectorz-clj">https://github.com/mikera/vectorz-clj</a>
</li>

<li>vectorz &ndash; Examples<br />
<a href="https://github.com/mikera/vectorz-clj/wiki/Examples">https://github.com/mikera/vectorz-clj/wiki/Examples</a>
</li>

<li>Basic Vector and Matrix Operations in Julia: Quick Reference and Examples<br />
<a href="https://queirozf.com/entries/basic-vector-and-matrix-operations-in-julia-quick-reference-and-examples">https://queirozf.com/entries/basic-vector-and-matrix-operations-in-julia-quick-reference-and-examples</a>
</li>

<li>Vectors and matrices in Julia<br />
<a href="https://fncbook.github.io/v1.0/linsys/demos/matrices-julia.html">https://fncbook.github.io/v1.0/linsys/demos/matrices-julia.html</a>
</li>

<li>Array vs Matrix in R Programming<br />
<a href="https://www.geeksforgeeks.org/array-vs-matrix-in-r-programming/">https://www.geeksforgeeks.org/array-vs-matrix-in-r-programming/</a>
</li>

<li>Concurrency (computer science)<br />
<a href="https://en.wikipedia.org/wiki/Category:Concurrency_%28computer_science%29">https://en.wikipedia.org/wiki/Category:Concurrency_%28computer_science%29</a>
</li>

<li>Koprogram<br />
<a href="https://cs.wikipedia.org/wiki/Koprogram">https://cs.wikipedia.org/wiki/Koprogram</a>
</li>

<li>Coroutine<br />
<a href="https://en.wikipedia.org/wiki/Coroutine">https://en.wikipedia.org/wiki/Coroutine</a>
</li>

<li>Coroutines in C<br />
<a href="http://www.chiark.greenend.org.uk/~sgtatham/coroutines.html">http://www.chiark.greenend.org.uk/~sgtatham/coroutines.html</a>
</li>

<li>S-expression (Wikipedia)<br />
<a href="https://en.wikipedia.org/wiki/S-expression">https://en.wikipedia.org/wiki/S-expression</a>
</li>

<li>S-Expressions (Rosetta Code)<br />
<a href="http://rosettacode.org/wiki/S-Expressions">http://rosettacode.org/wiki/S-Expressions</a>
</li>

<li>Introducing Julia/Metaprogramming<br />
<a href="https://en.wikibooks.org/wiki/Introducing_Julia/Metaprogramming">https://en.wikibooks.org/wiki/Introducing_Julia/Metaprogramming</a>
</li>

<li>Tutorial for the Common Lisp Loop Macro<br />
<a href="http://www.ai.sri.com/pkarp/loop.html">http://www.ai.sri.com/pkarp/loop.html</a>
</li>

<li>Clojure Macro Tutorial (Part I, Getting the Compiler to Write Your Code For You)<br />
<a href="http://www.learningclojure.com/2010/09/clojure-macro-tutorial-part-i-getting.html">http://www.learningclojure.com/2010/09/clojure-macro-tutorial-part-i-getting.html</a>
</li>

<li>Clojure Macro Tutorial (Part II: The Compiler Strikes Back)<br />
<a href="http://www.learningclojure.com/2010/09/clojure-macro-tutorial-part-ii-compiler.html">http://www.learningclojure.com/2010/09/clojure-macro-tutorial-part-ii-compiler.html</a>
</li>

<li>Clojure Macro Tutorial (Part III: Syntax Quote)<br />
<a href="http://www.learningclojure.com/2010/09/clojure-macro-tutorial-part-ii-syntax.html">http://www.learningclojure.com/2010/09/clojure-macro-tutorial-part-ii-syntax.html</a>
</li>

<li>Clojure Macros and Metaprogramming<br />
<a href="http://clojure-doc.org/articles/language/macros.html">http://clojure-doc.org/articles/language/macros.html</a>
</li>

<li>Fatvat &ndash; Exploring functional programming: Clojure Macros<br />
<a href="http://www.fatvat.co.uk/2009/02/clojure-macros.html">http://www.fatvat.co.uk/2009/02/clojure-macros.html</a>
</li>

<li>CS 2101 Parallel Computing with Julia<br />
<a href="https://www.coursehero.com/file/11508091/CS-2101-Parallel-Computing-with-Julia/">https://www.coursehero.com/file/11508091/CS-2101-Parallel-Computing-with-Julia/</a>
</li>

<li>Julia By Example<br />
<a href="https://samuelcolvin.github.io/JuliaByExample/">https://samuelcolvin.github.io/JuliaByExample/</a>
</li>

<li>Array Programming<br />
<a href="https://en.wikipedia.org/wiki/Array_programming">https://en.wikipedia.org/wiki/Array_programming</a>
</li>

<li>Discovering Array Languages<br />
<a href="http://archive.vector.org.uk/art10008110">http://archive.vector.org.uk/art10008110</a>
</li>

<li>no stinking loops -- Kalothi<br />
<a href="http://www.nsl.com/">http://www.nsl.com/</a>
</li>

<li>Vector (obsahuje odkazy na články, knihy a blogy o programovacích jazycích APL, J a K)<br />
<a href="http://www.vector.org.uk/">http://www.vector.org.uk/</a>
</li>

<li>APL Interpreters<br />
<a href="http://www.vector.org.uk/?area=interpreters">http://www.vector.org.uk/?area=interpreters</a>
</li>

<li>APL_(programming_language<br />
<a href="http://en.wikipedia.org/wiki/APL_(programming_language">http://en.wikipedia.org/wiki/APL_(programming_language</a>
</li>

<li>APL FAQ<br />
<a href="http://www.faqs.org/faqs/apl-faq/">http://www.faqs.org/faqs/apl-faq/</a>
</li>

<li>APL FAQ (nejnovější verze)<br />
<a href="http://home.earthlink.net/~swsirlin/apl.faq.html">http://home.earthlink.net/~swsirlin/apl.faq.html</a>
</li>

<li>A+<br />
<a href="http://www.aplusdev.org/">http://www.aplusdev.org/</a>
</li>

<li>APLX<br />
<a href="http://www.microapl.co.uk/">http://www.microapl.co.uk/</a>
</li>

<li>FreeAPL<br />
<a href="http://www.pyr.fi/apl/index.htm">http://www.pyr.fi/apl/index.htm</a>
</li>

<li>Learning J (Roger Stokes)<br />
<a href="http://www.jsoftware.com/help/learning/contents.htm">http://www.jsoftware.com/help/learning/contents.htm</a>
</li>

<li>J: a modern, high-level, general-purpose, high-performance programming language<br />
<a href="http://www.jsoftware.com/">http://www.jsoftware.com/</a>
</li>

<li>K, Kdb: an APL derivative for Solaris, Linux, Windows<br />
<a href="http://www.kx.com">http://www.kx.com</a>
</li>

<li>openAPL (GPL)<br />
<a href="http://sourceforge.net/projects/openapl">http://sourceforge.net/projects/openapl</a>
</li>

<li>Parrot APL (GPL)<br />
<a href="http://www.parrotcode.org/">http://www.parrotcode.org/</a>
</li>

<li>Learning J (Roger Stokes)<br />
<a href="http://www.jsoftware.com/help/learning/contents.htm">http://www.jsoftware.com/help/learning/contents.htm</a>
</li>

<li>Rosetta Code<br />
<a href="http://rosettacode.org/wiki/Main_Page">http://rosettacode.org/wiki/Main_Page</a>
</li>

<li>Why APL<br />
<a href="http://www.acm.org/sigapl/whyapl.htm">http://www.acm.org/sigapl/whyapl.htm</a>
</li>

<li>Introducing Julia/Functions<br />
<a href="https://en.wikibooks.org/wiki/Introducing_Julia/Functions">https://en.wikibooks.org/wiki/Introducing_Julia/Functions</a>
</li>

<li>Functions (Julia documentation)<br />
<a href="https://docs.julialang.org/en/v1/manual/functions/">https://docs.julialang.org/en/v1/manual/functions/</a>
</li>

<li>Evaluate binomial coefficients<br />
<a href="http://rosettacode.org/wiki/Evaluate_binomial_coefficients">http://rosettacode.org/wiki/Evaluate_binomial_coefficients</a>
</li>

<li>Ackermann function<br />
<a href="http://rosettacode.org/wiki/Ackermann_function">http://rosettacode.org/wiki/Ackermann_function</a>
</li>

<li>Julia (front page)<br />
<a href="http://julialang.org/">http://julialang.org/</a>
</li>

<li>Julia &ndash; dokumentace<br />
<a href="http://docs.julialang.org/">http://docs.julialang.org/</a>
</li>

<li>Julia &ndash; repositář na GitHubu<br />
<a href="https://github.com/JuliaLang/julia">https://github.com/JuliaLang/julia</a>
</li>

<li>Julia (programming language)<br />
<a href="https://en.wikipedia.org/wiki/Julia_%28programming_language%29">https://en.wikipedia.org/wiki/Julia_%28programming_language%29</a>
</li>

<li>IJulia<br />
<a href="https://github.com/JuliaLang/IJulia.jl">https://github.com/JuliaLang/IJulia.jl</a>
</li>

<li>Introducing Julia<br />
<a href="https://en.wikibooks.org/wiki/Introducing_Julia">https://en.wikibooks.org/wiki/Introducing_Julia</a>
</li>

<li>Julia: the REPL<br />
<a href="https://en.wikibooks.org/wiki/Introducing_Julia/The_REPL">https://en.wikibooks.org/wiki/Introducing_Julia/The_REPL</a>
</li>

<li>Month of Julia<br />
<a href="https://github.com/DataWookie/MonthOfJulia">https://github.com/DataWookie/MonthOfJulia</a>
</li>

<li>Learn X in Y minutes (where X=Julia)<br />
<a href="https://learnxinyminutes.com/docs/julia/">https://learnxinyminutes.com/docs/julia/</a>
</li>

<li>New Julia language seeks to be the C for scientists<br />
<a href="http://www.infoworld.com/article/2616709/application-development/new-julia-language-seeks-to-be-the-c-for-scientists.html">http://www.infoworld.com/article/2616709/application-development/new-julia-language-seeks-to-be-the-c-for-scientists.html</a>
</li>

<li>Julia: A Fast Dynamic Language for Technical Computing<br />
<a href="http://karpinski.org/publications/2012/julia-a-fast-dynamic-language">http://karpinski.org/publications/2012/julia-a-fast-dynamic-language</a>
</li>

<li>The LLVM Compiler Infrastructure<br />
<a href="http://llvm.org/">http://llvm.org/</a>
</li>

<li>Julia: benchmarks<br />
<a href="http://julialang.org/benchmarks/">http://julialang.org/benchmarks/</a>
</li>

<li>Type system<br />
<a href="https://en.wikipedia.org/wiki/Type_system">https://en.wikipedia.org/wiki/Type_system</a>
</li>

<li>Half-precision floating-point format<br />
<a href="https://en.wikipedia.org/wiki/Half-precision_floating-point_format">https://en.wikipedia.org/wiki/Half-precision_floating-point_format</a>
</li>

<li>Dartmouth BASIC<br />
<a href="https://en.wikipedia.org/wiki/Dartmouth_BASIC">https://en.wikipedia.org/wiki/Dartmouth_BASIC</a>
</li>

<li>BASIC 4th Edition<br />
<a href="http://www.bitsavers.org/pdf/dartmouth/BASIC_4th_Edition_Jan68.pdf">http://www.bitsavers.org/pdf/dartmouth/BASIC_4th_Edition_Jan68.pdf</a>
</li>

<li>VECTRAN<br />
<a href="https://encyclopedia2.thefreedictionary.com/VECTRAN">https://encyclopedia2.thefreedictionary.com/VECTRAN</a>
</li>

<li>Comparison of programming languages (array)<br />
<a href="https://en.wikipedia.org/wiki/Comparison_of_programming_languages_(array)">https://en.wikipedia.org/wiki/Comparison_of_programming_languages_(array)</a>
</li>

<li>BASIC at 50<br />
<a href="https://www.dartmouth.edu/basicfifty/commands.html">https://www.dartmouth.edu/basicfifty/commands.html</a>
</li>

<li>BBC Basic - arrays<br />
<a href="http://www.riscos.com/support/developers/bbcbasic/part2/arrays.html">http://www.riscos.com/support/developers/bbcbasic/part2/arrays.html</a>
</li>

<li>Datová struktura<br />
<a href="https://cs.wikipedia.org/wiki/Datov%C3%A1_struktura">https://cs.wikipedia.org/wiki/Datov%C3%A1_struktura</a>
</li>

<li>SIMD instrukce využívané v&nbsp;moderních mikroprocesorech řady x86<br />
<a href="https://www.root.cz/clanky/simd-instrukce-vyuzivane-v-modernich-mikroprocesorech-rady-x86/">https://www.root.cz/clanky/simd-instrukce-vyuzivane-v-modernich-mikroprocesorech-rady-x86/</a>
</li>

<li>SIMD instrukce v&nbsp;moderních mikroprocesorech řady x86 (2.část: SSE)<br />
<a href="https://www.root.cz/clanky/simd-instrukce-v-modernich-mikroprocesorech-rady-x86-2-cast-sse/">https://www.root.cz/clanky/simd-instrukce-v-modernich-mikroprocesorech-rady-x86-2-cast-sse/</a>
</li>

<li>SIMD instrukce v&nbsp;moderních mikroprocesorech řady x86 (3.část: SSE2)<br />
<a href="https://www.root.cz/clanky/simd-instrukce-v-modernich-mikroprocesorech-rady-x86-3-cast-sse2/">https://www.root.cz/clanky/simd-instrukce-v-modernich-mikroprocesorech-rady-x86-3-cast-sse2/</a>
</li>

</ol>



<p></p><p></p>
<p><small>Autor: <a href="http://www.fit.vutbr.cz/~tisnovpa">Pavel Tišnovský</a> &nbsp; 2021</small></p>
</body>
</html>

