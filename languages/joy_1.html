<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
        "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html>
<head>
<title>Joy - radost z programování</title>
<meta name="Author" content="Pavel Tisnovsky" />
<meta name="Generator" content="vim" />
<meta http-equiv="content-type" content="text/html; charset=iso-8859-2" />
<style type="text/css">
         body {color:#000000; background:#ffffff;}
         h1  {font-family: arial, helvetica, sans-serif; color:#ffffff; background-color:#c00000; text-align:center; padding-left:1em}
         h2  {font-family: arial, helvetica, sans-serif; color:#ffffff; background-color:#0000c0; padding-left:1em; text-align:left}
         h3  {font-family: arial, helvetica, sans-serif; color:#000000; background-color:#c0c0c0; padding-left:1em; text-align:left}
         h4  {font-family: arial, helvetica, sans-serif; color:#000000; background-color:#e0e0e0; padding-left:1em; text-align:left}
         a   {font-family: arial, helvetica, sans-serif;}
         li  {font-family: arial, helvetica, sans-serif; color:#000000; text-align:justify; width:450px;}
         ol  {font-family: arial, helvetica, sans-serif; color:#000000; text-align:justify; width:450px;}
         ul  {font-family: arial, helvetica, sans-serif; color:#000000; text-align:justify; width:450px;}
         p   {font-family: arial, helvetica, sans-serif; color:#000000; text-align:justify;}
         pre {background:#e0e0e0}
</style>
</head>

<body>

<h1>Joy - radost z programování</h1>

<h3>Pavel Ti¹novský</h3>

<p></p>

<h1>Úvodník</h1>

<p>V tomto èlánku si pøedstavíme netradièní programovací jazyk nazvaný Joy, jen¾ je odvozený od velmi jednoduchých funkcionálních základù a minimalistické syntaxi. Oproti dal¹ím funkcionálním jazykùm, které jsou postaveny na lambda kalkulu, je Joy zalo¾en na kompozici funkcí, co¾ vede k syntaxi podobné Forthu.</p>



<h1>Obsah</h1>
<p>
<a href="#k01">1. Joy - radost z programování</a><br />
<a href="#k02">2. Paradigma programovacího jazyka Joy</a><br />
<a href="#k03">3. Joy v&nbsp;porovnání s&nbsp;Lispem (Scheme) a Forthem</a><br />
<a href="#k04">4. Postfixová notace a RPN</a><br />
<a href="#k05">5. Zásobníkové manipulátory</a><br />
<a href="#k06">6. Definice nových funkcí</a><br />
<a href="#k07">7. Odkazy na Internetu</a><br />
<a href="#k08">8. Obsah druhé èásti èlánku</a><br />
</p>



<p><a name="k01"></a></p>
<h1>1. Joy - radost z programování</h1>

<p>Programovací jazyk <i>Joy</i> byl pøed nìkolika lety navr¾en Mangredem von
Thunem pro úèely výzkumu odli¹ného pøístupu k&nbsp;funkcionálnímu programování,
ne¾ nabízejí &ndash; v&nbsp;tomto oboru ji¾ klasické a zavedené &ndash; jazyky
typu <i>Lisp</i> èi <i>Scheme</i>. Jedná se o minimalistický jazyk, který v¹ak
v&nbsp;sobì skrývá velké mo¾nosti, které nemusí být na první pohled zøejmé.
Minimalismus je vidìt i na velikosti samotného interpreteru &ndash; spustitelný
soubor s&nbsp;interpreterem a základní knihovnou funkcí má po pøelo¾ení
céèkových zdrojových kódù velikost cca 110kB a po aplikaci UPX èi podobného
nástroje se velikost dokonce sní¾ila na pouhých 27kB (zde je nutné øíci, ¾e
v&nbsp;tomto spustitelném souboru je ulo¾en také celý manuál o délce pøes
2 kilobytù, jen¾ je dostupný pod pøíkazem <strong>manual</strong>). Zatímco ostatní
funkcionální jazyky jsou zalo¾eny na aplikaci funkcí (v&nbsp;obecnìj¹ím pohledu
tedy na teorii <i>lambda kalkulu</i>), je srdcem programování v&nbsp;Joyi
<i>kompozice funkcí</i> spolu s&nbsp;takzvanou <i>citací programù</i>.</p>

<p>V&nbsp;mnoha ohledech je <i>Joy</i> èistì funkcionální jazyk, proto¾e
neobsahuje pøiøazovací pøíkaz a dokonce ani bì¾né promìnné.
V&nbsp;imperativních jazycích bì¾né konstrukce jako smyèky èi podmínky, jsou
zde nahrazeny <i>kombinátory</i> a rekurzí, popø.&nbsp;takzvanými
<i>rekurzivními manipulátory</i>, které samy o sobì pøedstavují snad
nejzajímavìj¹í èást tohoto netradièního jazyka, který na první pohled zaujme
svojí neobvyklou syntaxí a sevøeným zpùsobem zápisu programù.</p>

<p>Ptáte se, jak je mo¾né v&nbsp;takovém jazyce vùbec programovat? Po pochopení
základù je to docela jednoduché a pøitom zábavné, zvlá¹tì kdy¾ si èlovìk
uvìdomí, na jak jednoduchých pravidlech mù¾e být programovací jazyk postaven.
Základy programování si spolu s&nbsp;demonstraèními pøíklady uká¾eme
v&nbsp;následujících kapitolách a druhé i tøetí èásti tohoto èlánku.</p>



<p><a name="k02"></a></p>
<h1>2. Paradigma programovacího jazyka Joy</h1>

<p>Z&nbsp;pøedchozí kapitoly ji¾ víme, ¾e <i>Joy</i> spadá do kategorie
funkcionálních programovacích jazykù, co¾ je pomìrnì velká rodina jazykù, mezi
její¾ èleny patøí pøedev¹ím známý <i>Lisp</i>, od nìj odvozené <i>Scheme</i>,
dále pak jazyk <i>ML</i> nebo pomìrnì populární <i>Haskell</i>. V¹echny ètyøi
zmínìné jazyky jsou ve svých základech zalo¾eny na <i>lambda kalkulu</i>. Ov¹em
<i>Joy</i> je v&nbsp;tomto ohledu odli¹ný, proto¾e je postaven na kompozici
funkcí a citaci programù. Nejprve si vysvìtleme význam kompozice funkcí.
Z&nbsp;teorie vyèíslitelnosti je známé, ¾e vyèíslitelné (spoèitatelné) funkce
je mo¾né získat z&nbsp;takzvaných poèáteèních funkcí, co¾ je nulová funkce
(<i>zero function</i>), funkce následníka (<i>successor function</i>) a
projekce (<i>projection</i>), ze kterých jsou vytváøeny funkce slo¾itìj¹í.</p>

<p>Mezi základní zpùsoby tvorby slo¾itìj¹ích funkcí patøí <i>kombinace
funkcí</i>, <i>kompozice funkcí</i> a <i>primitivní rekurze</i>. V&nbsp;jazyce
<i>Joy</i> se pou¾ívá pøedev¹ím kompozice funkcí, která bývá v&nbsp;matematice
zapisována speciálním symbolem koleèka &deg; v&nbsp;infixové notaci,
tj.&nbsp;symbol koleèka se umis»uje mezi názvy dvou funkcí, na které je
aplikován (u¾ z&nbsp;podstaty se toti¾ jedná o binární operaci). Ov¹em
<i>Joy</i>, pøesnìji øeèeno jeho syntaxe, je zalo¾ena na notaci postfixové, to
znamená, ¾e nejprve je zapsán operand (operandy) a teprve po nìm jednotlivé
funkce, které se na operand (operandy) aplikují. Díky tomuto zpùsobu zápisu se
zcela eliminuje nutnost zápisu &deg; do programù, proto¾e ji¾ z&nbsp;pozice
jmen jednotlivých funkcí je zøejmé, jaké je poøadí operací &ndash; je urèeno
pøesnì tím poøadím, jakým program èteme, tj.&nbsp;zleva doprava, neboli opaènì,
ne¾ je tomu u funkcionálních programovacích jazykù zalo¾ených na lambda
kalkulu.</p>

<pre>

<i>zpùsob kompozice funkcí pomocí funkce</i>
<i>vy¹¹ího øádu "map" a citace programu</i>
<strong>[0 1 2 3] [square] map</strong>

<i>tisk výsledku pomocí operátoru "teèky"</i>
<i>.</i>
[1 4 9 16]

</pre>

<p>Druhým základem, na kterém je <i>Joy</i> zalo¾ený, je citace programù, co¾
není nic jiného ne¾ zpùsob zápisu (ale i dynamické tvorby) programového kódu
bez jeho spu¹tìní. Znalci programovacích jazykù <i>Lisp</i> èi <i>Scheme</i>
jistì znají speciální formy, které vyu¾ívají stejného principu &ndash;
programový kód je mo¾né pova¾ovat za seznam pøíkazù/funkcí/operátorù,
tj.&nbsp;ve skuteènosti za data, která je mo¾né ve vhodném okam¾iku "spustit",
tj.&nbsp;pøedat je funkci typu <strong>eval</strong>. Stejným zpùsobem je
citace programù vyøe¹ena i v&nbsp;<i>Joyovi</i>, ostatnì je to základ takových
funkcí, které se v&nbsp;nefunkcionálních programovacích jazycích transformují
do podoby pøíkazù <strong>while</strong>, <strong>if-then-else</strong> atd. Ve
funkcionálních jazycích se bez tìchto speciálních syntaktických prvkù hravì
obejdeme:</p>

<pre>

<i>funkce ifte nahrazuje "plný" vìtvicí pøíkaz typu if-then-else</i>
<strong>[1000 &gt;]  [2 /]  [3 *]  ifte</strong>

<i>pøíklad pou¾ití (teèka zajistí výpis polo¾ky na zásobníku):</i>
<strong>10 [1000 &gt;]  [2 /]  [3 *]  ifte .</strong>
30

<strong>2000 [1000 &gt;]  [2 /]  [3 *]  ifte .</strong>
1000

</pre>

<p>Pro srovnání si uveïme obdobný Lispovský kód se <i>speciální formou</i>
<strong>if</strong>:</p>

<pre>

(if (&gt; x 1000) (/ x 2) (* x 3))

</pre>

<p>Sám autor tohoto jazyka jej oznaèuje názvem <i>concatenative language</i>,
èím¾ je my¹len fakt, ¾e je kompozice funkcí zapisována v&nbsp;postfixové
notaci, tj.&nbsp;jednotlivé funkce jsou za sebou zøetìzeny.</p>



<p><a name="k03"></a></p>
<h1>3. Joy v&nbsp;porovnání s&nbsp;Lispem (Scheme) a Forthem</h1>

<p>Svými mo¾nostmi a celkovým dojmem je mo¾né <i>Joy</i> pova¾ovat za jakéhosi
hybrida, který pøebírá vìt¹inu dobrých vlastností z&nbsp;programovacích jazykù
<i>Lisp</i> a <i>Forth</i>. To v¹ak v&nbsp;¾ádném pøípadì neznamená, ¾e by byl
<i>Joy</i> vytvoøen ve stylu "jak pejsek s&nbsp;koèièkou vaøili dort". Právì
naopak &ndash; <i>Joy</i> je postaven na velmi jednoduchých funkcionálních
základech a minimalistické syntaxi, podobnì jako <i>Lisp</i>, pøièem¾ samotný
výpoèet (vyèíslení funkcí) je zalo¾en na manipulaci se zásobníky, co¾ je naopak
doména <i>Forthu</i>.</p>

<p><i>Joy</i> není jediný programovací jazyk, který se vydal tímto smìrem,
proto¾e na podobných principech je postaven i programovací jazyk <i>Factor</i>
autora Slavy Pestova (známý je pøedev¹ím jeho multiplatformní programátorský
editor <a href="http://www.jedit.org">JEdit</a>), o kterém se pozdìji také
zmíníme (ve skuteènosti je vývoj <i>Factoru</i> do velké míry ovlivnìn právì
<i>Joyem</i> a u¾ zde je nutné øíci, ¾e zatímco <i>Joy</i> je pøedev¹ím
"akademický" programovací jazyk, je naopak <i>Factor</i> ve vìt¹í míøe zamìøený
na praktické programování). Dal¹ím podobným jazykem je <i>Cat</i>, který má
dokonce vlastní GUI.</p>

<img src="joy_1_1.png" />
<p-center>Prostøedí programovacího jazyka <i>Cat</i></p-center>

<p>Ve struènosti je mo¾né øíci, ¾e programování v&nbsp;<i>Joy</i>ovi je
zalo¾ené na provádìní operací nad polo¾kami ulo¾enými na zásobníku, podobnì
jako <i>Forth</i>, ov¹em s&nbsp;tím rozdílem, ¾e je roz¹íøen repertoár datových
typù a pøedev¹ím v&nbsp;tom, ¾e na zásobníku mohou být ulo¾eny také takzvané
citované programy, s&nbsp;nimi¾ je mo¾né manipulovat stejným zpùsobem, jako je
tomu v&nbsp;<i>Lispu</i>. Bez podrobnìj¹ího vysvìtlování, na které bude èas
dále, se podívejme na ukázku nìkolika jednoduchých algoritmù zapsaných
v&nbsp;programovacím jazyce <i>Joy</i>, aby byla vidìt syntaktická podoba
s&nbsp;programovacími jazyky zalo¾enými na postfixové notaci a souèasnì i
sémantická podoba s&nbsp;jazyky funkcionálními (funkce resp.&nbsp;operátor
"teèka" provede výpis polo¾ky obsa¾ené na vrcholu zásobníku):</p>

<pre>

<i>aplikace základních aritmetických operací</i>
<i>s tiskem výsledku pomocí operátoru teèky</i>
<strong>20  3  4  +  *  6  -  100  rem .</strong>

<i>definice nové funkce</i>
<strong>square   ==   dup  *</strong>

<i>aplikace funkce na numerické hodnoty ulo¾ené v seznamu</i>
<i>(výsledkem bude seznam s druhými mocninami pùvodních hodnot)</i>
<strong>[1 2 3 4]  [dup *]  map</strong>

</pre>



<p><a name="k04"></a></p>
<h1>4. Postfixová notace a RPN</h1>

<i>If you're a frequent calculator user, you owe it to yourself to investigate
the advantages of RPN. RPN stands for Reverse Polish Notation. Reverse Polish
Notation was developed in 1920 by Jan Lukasiewicz as a way to write a
mathematical expression without using parentheses and brackets. Hewlett-Packard
Co., realizing that Lukasiewicz's method was superior to standard algebraic
expressions when using calculators and computers, adapted RPN for its first
hand-held scientific calculator, the HP35, in 1972.<br />
Hewlett-Packard Development Company The RPN Method: An Overview and History
</i>

<p>Zápis ve¹kerých operací, tj.&nbsp;zpùsob øazení operandù a operátorù èi
parametrù funkcí, je v&nbsp;programovacím jazyce <i>Joy</i> zalo¾ený na
takzvané <i>postfixové notaci</i>, známé také pod názvem obrácená Polská notace
(<i>RPN &ndash; Reverse Polish Notation</i>). Název Polská notace byl zvolen na
poèest polského matematika Jana Lukasiewicze, který u¾ v&nbsp;roce 1920 navrhl
dvì mo¾nosti psaní matematických výrazù bez nutnosti explicitní definice
priorit operací a také bez pou¾ití závorek, kterým se pøi pou¾ití dnes
nejpou¾ívanìj¹í <i>infixové notace</i>, v&nbsp;mnoha pøípadech nevyhneme.
Notace, pøi které se operátory pí¹ou a¾ za operandy (tedy "obrácenì") se nazývá
RPN èi postfixová notace; druhou notací zavedenou Lukasiewiczem je prefixová
notace, která v&nbsp;urèitém ohledu pøipomíná zápis pou¾itý
v&nbsp;programovacím jazyce <i>Lisp</i> èi <i>Scheme</i>.</p> 

<img src="joy_1_2.png" />
<p-center>Slavný kalkulátor HP-35 s&nbsp;RPN<br />(35 v&nbsp;názvu znaèí poèet tlaèítek)</p-center>

<p>U¾ na základní ¹kole se v¹ak ka¾dý èlovìk uèí takzvanou <strong>infixovou
notaci zápisu</strong>, ve které se nejèastìji pou¾ívané matematické operátory,
jakými jsou sèítání, odèítání, násobení a dìlení, zapisují mezi své operandy.
Vzhledem k&nbsp;rùzné prioritì operátorù (napøíklad operátor násobení má
definitoricky vìt¹í prioritu ne¾ sèítání) je v¹ak nutné v&nbsp;infixové notaci
pøi zápisu slo¾itìj¹ích výrazù velmi èasto pou¾ívat závorky. Rozdíl mezi
následujícími dvìma výrazy uvedenými v&nbsp;infixové notaci je zøejmý (znakem
&times; je zapsán operátor násobení):</p>

<code-area>

a+b&times;c
(a+b)&times;c

</code-area>

<p>Infixová notace se pou¾ívá i pøi zápisu dal¹ích operací, napøíklad operací
logických (konjunkce, disjunkce) èi mno¾inových (sjednocení mno¾in, prùnik
mno¾in, doplnìk mno¾iny atd.). I u takových výrazù se mnohdy nevyhneme
závorkám. Pøi pou¾ití postfixové notace v¹ak nejsou závorky ve výrazech
<strong>nikdy</strong> zapotøebí, proto¾e se priorita operací vyjadøuje pøímo
posloupností operátorù. Vý¹e uvedené dva výrazy lze tedy do postfixové notace
pøepsat následovnì:</p>

<code-area>

a b c * +   nebo té¾   b c * a +
a b + c *   nebo té¾   c a b + *

</code-area>

<p>V¹imnìte si, ¾e u vý¹e uvedených RPN výrazù &nbsp;promìnnými a, b a c
napsaných na levé stranì se oproti infixové notaci nemìní poøadí operátorù.
Toho se velmi èasto vyu¾ívá pøi algoritmickém pøevodu mezi infixovou a
postfixovou notací a také pøi ruèním zápisu RPN výrazù. Tento pøevod provádí
vlastnì ka¾dý pøekladaè èi interpreter programovacího jazyka, a to buï pøímo
(mimochodem vìt¹inou opìt s&nbsp;vyu¾itím zásobníku, do kterého jsou ukládány
kódy po¾adovaných matematických operací a pozice závorek), nebo takzvaným
rekurzivním sestupem podle gramatických pravidel daného jazyka. V&nbsp;pøípadì
pou¾ití programovacího jazyka <i>Joy</i> se jeho interpreter tímto pøevodem
nemusí zabývat, proto¾e na vstupu má ji¾ dopøedu zpracovaný postfixový kód,
který je mo¾né bez dal¹ího slo¾itého zpracování pøímo interpretovat, co¾ si
mù¾eme ukázat na praktickém pøíkladu v&nbsp;jazyce <i>Joy</i>:</p>

<pre>

<strong>2 3 4 * + .</strong>
14

<strong>2 3 * 4 + .</strong>
10

<strong>2 3 4 + * .</strong>
14

</pre>

<img src="joy_1_3.png" />
<p-center>Kalkulátor HP-65 takté¾ s&nbsp;RPN</p-center>

<p>Jaké jsou v¹ak výhody postfixového zápisu výrazù oproti zápisu infixovému?
Mezi základní pøednost patøí u¾ zmínìná absence závorek, pomocí nich¾ se
v&nbsp;infixové notaci mìní priority operací. Priorita je toti¾
v&nbsp;postfixové notaci velmi intuitivnì urèena pøímo pozicí operátoru èi
funkce ve výrazu. Toho vyu¾ívaly i kalkulaèky HP, které ¾ádné klávesy se
závorkami neobsahovaly. Pùvodní klávesnice byly vybaveny pouze tlaèítky
s&nbsp;èíslicemi, ètyømi klávesami pro základní matematické operace (ty se
zadávaly za operandy) a klávesou <strong>[Enter]</strong>, která provádìla
ulo¾ení právì zobrazené hodnoty na displeji do zásobníku operandù (konkrétnì na
jeho vrchol oznaèovaný symboly TOP, TOS èi SP).</p>

<p>Mezi druhou výhodu postfixové notace patøí &ndash; pro mnohé mo¾ná ponìkud
pøekvapivì &ndash; konzistence zápisu. Ve skuteènosti se toti¾ v&nbsp;bì¾nì
pou¾ívané infixové notaci zapisují pouze nìkteré základní matematické operace,
jako je sèítání, násobení nebo dìlení. Dal¹í operace se zapisují pomocí funkcí
v&nbsp;prefixové notaci (napøíklad sinus, odmocnina, logaritmus, minimum) a
nìkteré dokonce v&nbsp;notaci postfixové (pravdìpodobnì nejznámìj¹í
"postfixovou funkcí" je faktoriál, který se zapisuje znakem vykøièníku
umístìného za operand). Podobné je to i u programovacích jazykù, které pro
nìkteré operace mají rezervovány pøíslu¹ná klíèová slova èi znaky (+, -, *, %,
! atd.) s&nbsp;pevnì danou syntaxí i prioritou a v¹echny dal¹í operace je nutné
zapisovat formou funkcí.</p>

<img src="joy_1_4.png" />
<p-center>Kalkulátory s&nbsp;RPN se vyrábìly i v&nbsp;SSSR</p-center>

<p>Pomocí postfixové notace je mo¾né zapisovat v¹echny operace i funkce,
dokonce ani nezále¾í na poètu operandù (stírá se tím rozdíl mezi unárními,
binárními, ternárními apod. operacemi). Ve skuteènosti není v&nbsp;postfixové
notaci prakticky ¾ádný rozdíl mezi operacemi a funkcemi, tak¾e pro nì není
nutné zavádìt nìjaká zvlá¹tní syntaktická pravidla. Mezi bì¾nì pou¾ívané
funkce, které mají dva operandy, patøí logaritmus o libovolném základu,
exponenciální funkce a napøíklad také (spí¹e programátorská av¹ak velmi
praktická) funkce <i>atan2</i>.</p>

<img src="joy_1_5.png" />
<p-center>Rarita: RPN kalkulaèka firmy Sinclair (Spectristùm netøeba pøedstavovat)</p-center>

<p>Dùsledkem vý¹e uvedených skuteèností je fakt, ¾e znaky bì¾nì pou¾ívané pro
aritmetické operátory je mo¾né v&nbsp;programovacím jazyce <i>Joy</i> pou¾ít i
pro jiné úèely, podobnì jako napøíklad v&nbsp;jazyce <i>Lisp</i> nebo
<i>Scheme</i>, co¾ jsou, jak jsme se dozvìdìli v&nbsp;úvodu této kapitoly
jazyky pou¾ívající prefixovou notaci, tou se v¹ak v&nbsp;dal¹ím textu nebudeme
zabývat.</p>



<p><a name="k05"></a></p>
<h1>5. Zásobníkové manipulátory</h1>

<p>V&nbsp;pøedchozí kapitole jsme si øekli, ¾e postfixová notace je zalo¾ena na
zápisu operátorù a¾ za v¹echny operandy èi parametrù funkcí pøed vlastní volání
funkce. Ve¹keré výpoèty jsou pøitom provádìny na zásobníku (<i>stack</i>), co¾
je datová struktura typu LIFO (<i>Last In &ndash; First Out</i>). To ov¹em
znamená, ¾e je zapotøebí operandy nìjakým zpùsobem umístit na zásobník, ze
kterého budou následnì pøi provádìní operace opìt vyjmuty, pøièem¾ se na
zásobník vrátí výsledek operace. Umístìní operandù je velmi jednoduché &ndash;
samotný zápis operandu, napøíklad èísla èi pravdivostní hodnoty je pova¾ován za
operaci typu <strong>push</strong>, tj.&nbsp;vlo¾ení hodnoty operandu na
aktuální vrchol zásobníku. Zcela stejný zpùsob zápisu je podporován
v&nbsp;programovacím jazyku <i>Forth</i>, grafickém metaformátu
<i>PostScript</i> nebo tradièní Unixové utilitì <i>dc (Desk Calculator)</i>.
Programovací jazyk <i>Joy</i> sice na zásobník umo¾òuje ukládat i slo¾itìj¹í
datové èi programové struktury, ov¹em princip zùstává stále stejný.</p>

<img src="joy_1_6.png" />
<p-center>Základní operace se zásobníkem</p-center>

<p>Ov¹em vzhledem k&nbsp;tomu, ¾e programovací jazyk <i>Joy</i> neobsahuje
explicitní pøiøazovací pøíkaz a tím pádem ani pojmenované promìnné, je
v&nbsp;nìkterých pøípadech nutné zmìnit zpùsob øazení operandù/parametrù na
zásobníku, nìkteré operandy odstranit èi je naopak zkopírovat (zduplikovat).
K&nbsp;tomuto úèelu jsou v&nbsp;jazyce <i>Joy</i> urèeny takzvané
<i>zásobníkové manipulátory</i>. Ve své podstatì se jedná o funkce, které
roz¹iøují èistì zásobníkový automat (nazývaný také <i>push-pull automata</i>) o
dal¹í úroveò zpracování. Vzhledem k&nbsp;tomu, ¾e je <i>Joy</i> navr¾en
minimalisticky, obsahuje pouze tøi základní zásobníkové manipulátory, které
jsou vypsány v&nbsp;následující tabulce.</p>

<table>
<tr><th>Název zásobníkového manipulátoru</th><th>Význam</th></tr>
<tr><td><strong>pop</strong></td><td>odstranìní nejvy¹¹í polo¾ky z&nbsp;vrcholu zásobníku (opak implicitní operace <strong>push</strong>)</td></tr>
<tr><td><strong>dup</strong></td><td>polo¾ka na vrcholu zásobníku je zkopírována (zduplikována)</td></tr>
<tr><td><strong>swap</strong></td><td>prohození dvou polo¾ek umístìných na nejvy¹¹ích dvou místech zásobníku</td></tr>
</table>

<p>Kromì tìchto tøí základních zásobníkových manipulátorù je mo¾né ve
standardní knihovnì najít i operátor nazvaný <strong>dip</strong>, který na
zásobníku oèekává dvì polo¾ky: <i>citovaný program</i> (viz dal¹í èást tohoto
seriálu) a libovolnou dal¹í hodnotu. Tato hodnota je po "spu¹tìní" operátoru
<strong>dip</strong> ulo¾ena mimo zásobník, citovaný program, který je typicky
zapsaný mezi závorky <strong>[</strong> a <strong>]</strong>, je spu¹tìn a
následnì je pùvodní, mimo zásobník ulo¾ená hodnota, opìt obnovena. Pomocí v¹ech
ètyø popsaných zásobníkových manipulátorù lze vytvoøit i manipulátory dal¹í,
napøíklad:</p>

<table>
<tr><th>Název zásobníkového manipulátoru</th><th>Programovový kód</th><th>Význam</th></tr>
<tr><td><strong>popd</strong></td><td>[pop] dip</td><td>odstranìní druhé nejvy¹¹í polo¾ky na zásobníku</td></tr>
<tr><td><strong>dupd</strong></td><td>[dup] dip</td><td>duplikace druhé nejvy¹¹í polo¾ky na zásobníku</td></tr>
<tr><td><strong>swapd</strong></td><td>[swap] dip</td><td>prohození druhé a tøetí polo¾ky</td></tr>
<tr><td><strong>rollup</strong></td><td>swap [swap] dip</td><td>rotace tøí nejvy¹¹ích polo¾ek</td></tr>
<tr><td><strong>rolldown</strong></td><td>[swap] dip swap</td><td>opaèná rotace tøí nejvy¹¹ích polo¾ek</td></tr>
<tr><td><strong>rotate</strong></td><td>swap [swap] dip swap</td><td>prohození první a tøetí nejvy¹¹í polo¾ky</td></tr>
</table>

<p>Podobným zpùsobem je mo¾né aplikovat i slo¾itìj¹í zásobníkové operace, které
zasahují do stále ní¾e umístìných datových èi programových polo¾ek umístìných
na zásobníku. Poznámka: na zásobník nemusí být ukládány pouze èíselné hodnoty,
ale napøíklad i seznamy, øetìzce èi mno¾iny.</p>

<img src="joy_1_7.png" />
<p-center>Operace <strong>push</strong> a <strong>pop</strong> znázornìné na mechanické analogii zásobníku</p-center>



<p><a name="k06"></a></p>
<h1>6. Definice nových funkcí</h1>

<p>Zpùsob vytváøení nových funkcí je, alespoò po syntaktické stránce, zcela
zjevnì inspirován programovacím jazykem <i>Forth</i>. Pojïme se bez vìt¹ího
teoretizování podívat na pøíklad vytvoøení dvou nových funkcí pojmenovaných
jednodu¹e <strong>square</strong> a <strong>cube</strong>. Z&nbsp;pøíkladu je
patrné, ¾e vytváøení nových funkcí zaèíná slovem <strong>DEFINE</strong>, za
ním¾ následuje v¾dy název funkce, znaky <strong>==</strong> oddìlující název
funkce od jejího tìla a poté vlastní tìlo funkce. Jednotlivé definice jsou od
sebe oddìleny znakem støedníku, co¾ pøipomíná ji¾ zmínìný jazyk <i>Forth</i>,
konec definic v¹ech funkcí zaøídí operátor teèky.</p>

<pre>

<strong>DEFINE</strong>
<strong>    square  ==  dup * ;</strong>
<strong>    cube    ==  dup dup * * .</strong>

</pre>

<p>V¹imnìte si jedné zajímavosti, která dosti podstatným zpùsobem odli¹uje
"zásobníkové" programovací jazyky od zbytku svìta: v&nbsp;tìle funkcí ani
v&nbsp;jejich názvu se nikde nevyskytují názvy parametrù, proto¾e se
pøedpokládá, ¾e ty budou ulo¾eny na zásobníku. Není tedy nutné nìjakým slo¾itým
zpùsobem nahrazovat formální parametry za parametry skuteèné. Má to je¹tì jednu
výhodu &ndash; tìlo funkce je mo¾né zkopírovat, pøenést na pøíkazový øádek a
funkci pøímo spustit èi jinak testovat bez nutnosti mìnit by» jediný znak
v&nbsp;tìle funkce. Jinými slovy: aplikace funkce pøímo v&nbsp;programu
(tj.&nbsp;zápis tìla funkce) i její definice jsou zcela stejné, èeho¾ lze velmi
dobøe vyu¾ít pøi ladìní a testování:</p>

<pre>

<i>definice nové funkce nazvané xx:</i>
<strong>DEFINE</strong>
<strong>    xx == [1000 &gt;] [2 /] [3 *] ifte</strong>
<strong>.</strong>

<i>pou¾ití této funkce:</i>
<strong>20 xx .</strong>
60
<strong>1000 xx .</strong>
3000
<strong>1001 xx .</strong>
500

<i>pøímé pou¾ití tìla funkce:</i>
<strong>20 [1000 &gt;] [2 /] [3 *] ifte .</strong>
60
<strong>1000 [1000 &gt;] [2 /] [3 *] ifte .</strong>
3000
<strong>1001 [1000 &gt;] [2 /] [3 *] ifte .</strong>
500

</pre>

<p>Následuje klasický pøíklad funkce vracející maximální hodnotu z&nbsp;dvojice
èísel ulo¾ených na zásobník. Pøíklad jsem upravil tak, aby vyu¾ívat vý¹e
zmínìné zásobníkové manipulátory <strong>dup</strong>, <strong>dupd</strong>,
<strong>pop</strong>, <strong>popd</strong> a <strong>swapd</strong>. Nejprve
jsou zduplikovány obì hodnoty umístìné na zásobíku, poté jsou porovnány
(pøièem¾ se pùvodní hodnoty zahodí, proto je nutná duplikace) a posléze se na
základì vyhodnocení porovnání ze zásobníku odstraní men¹í hodnota a výsledek,
tj. hodnota vìt¹í, zùstane umístìná na nejvy¹¹ím místì zásobníku, proto¾e ten
slou¾í jako odkládací místo pro výsledky funkcí:</p>

<pre>

<i>definice funkce max</i>
<i>(pøepí¹eme tím sice pùvodní funkci, to v¹ak v této chvíli není na ¹kodu)</i>
<strong>DEFINE</strong>
<strong>    max == [dup swapd dupd &gt;] [pop] [popd] ifte</strong>
warning: overwriting inbuilt 'max'
<strong>.</strong>

<i>test funkce max:</i>
<strong>10 20 max .</strong>
20
<strong>20 10 max .</strong>
20
<strong>10 10 max .</strong>
10
<strong>3 1 2 max max .</strong>
3
<strong>-1 -3 -2 -4 -5 max max max max .</strong>
-1

</pre>

<p>Ve skuteènosti v¹ak lze funkci <strong>max</strong> napsat i jiným zpùsobem
bez explicitního pou¾ití <strong>ifte</strong>, napøíklad následovnì:</p>

<pre>

<strong>DEFINE</strong>
<strong>    max == dup swapd dupd &gt; rotate choice</strong>
<strong>.</strong>

</pre>



<p><a name="k07"></a></p>
<h1>7. Odkazy na Internetu</h1>

<ul>

<li><a href="http://www.latrobe.edu.au/philosophy/phimvt/joy.html">http://www.latrobe.edu.au/philosophy/phimvt/joy.html</a> &ndash; 
Joy Programming Language, stránka s&nbsp;rozcestníkem informací o programovacím jazyku Joy</li>

<li><a href="http://www.latrobe.edu.au/philosophy/phimvt/joy/j01tut.html">http://www.latrobe.edu.au/philosophy/phimvt/joy/j01tut.html</a> &ndash; Tutorial on Joy</li>

<li><a href="http://www.latrobe.edu.au/philosophy/phimvt/joy/j06prg.html">http://www.latrobe.edu.au/philosophy/phimvt/joy/j06prg.html</a> &ndash; Programming in Joy</li>

<li><a href="http://www.latrobe.edu.au/philosophy/phimvt/joy/synops.html">http://www.latrobe.edu.au/philosophy/phimvt/joy/synops.html</a> &ndash; Synopsis of the language Joy</li>

<li><a href="http://www.latrobe.edu.au/philosophy/phimvt/joy/faq.html">http://www.latrobe.edu.au/philosophy/phimvt/joy/faq.html</a> &ndash; Frequently Asked Questions about Joy, obsahuje i èásteèné porovnání s&nbsp;dal¹ími programovacími jazyky zalo¾enými na zásobníkovém kódu</li>

</ul>

<img src="joy_1_8.png" />
<p-center>HP 49g+ &ndash; kalkulaèka pracující "pod obojí", tedy jak v&nbsp;re¾imu RPN, tak i v&nbsp;algebraickém re¾imu</p-center>



<p><a name="k08"></a></p>
<h1>8. Obsah druhé èásti èlánku</h1>

<p>Ve druhé èásti celkem trojdílného èlánku o programovacím jazyce Joy si
uká¾eme ty nejzajímavìj¹í vlastnosti tohoto netradièního jazyka. Pøedev¹ím se
bude jednat o zpùsob citace programù, který pøedstavuje základ pokroèilej¹ího
funkcionálního programování a souèasnì i metodu pro tvorbu maker, dále o
pou¾ití kombinátorù a pøedev¹ím náhrady klasicky pojaté rekurze pomocí
takzvaných <i>rekurzivních kombinátorù</i>. Jako návnadu pro pøeètení druhé
èásti uká¾u zpùsob zápisu programu pro výpoèet faktoriálu a zobrazení výsledku
výpoètu:</p>

<pre>

<strong>èíslo [1] [*] primrec .</strong>

</pre>

<p>Docela krátký zápis, ¾e?</p>

<p>Pøejete si nìco slo¾itìj¹ího, napøíklad algoritmus <i>QuickSort</i>
aplikovaný na seznam?</p>

<pre>

<strong>qsort  ==</strong>
<strong>    [ small ]</strong>
<strong>    [ ]</strong>
<strong>    [ uncons [&gt;] split ]</strong>
<strong>    [ swap23 cons concat ]</strong>
<strong>    binrec</strong>

</pre>



<p></p><p></p>
<p><small>Autor: <a href="http://www.fit.vutbr.cz/~tisnovpa">Pavel Ti¹novský</a> &nbsp; 2007</small></p>
</body>
</html>

