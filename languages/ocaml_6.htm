<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
        "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html>
<head>
<title>Definice uživatelských datových typů v jazyku OCaml</title>
<meta name="Author" content="Pavel Tisnovsky" />
<meta name="Generator" content="vim" />
<meta http-equiv="content-type" content="text/html; charset=utf-8" />
<style type="text/css">
         body {color:#000000; background:#ffffff;}
         h1  {font-family: arial, helvetica, sans-serif; color:#ffffff; background-color:#c00000; text-align:center; padding-left:1em}
         h2  {font-family: arial, helvetica, sans-serif; color:#ffffff; background-color:#0000c0; padding-left:1em; text-align:left}
         h3  {font-family: arial, helvetica, sans-serif; color:#000000; background-color:#c0c0c0; padding-left:1em; text-align:left}
         h4  {font-family: arial, helvetica, sans-serif; color:#000000; background-color:#e0e0e0; padding-left:1em; text-align:left}
         a   {font-family: arial, helvetica, sans-serif;}
         li  {font-family: arial, helvetica, sans-serif; color:#000000; text-align:justify; width:450px;}
         ol  {font-family: arial, helvetica, sans-serif; color:#000000; text-align:justify; width:450px;}
         ul  {font-family: arial, helvetica, sans-serif; color:#000000; text-align:justify; width:450px;}
         p   {font-family: arial, helvetica, sans-serif; color:#000000; text-align:justify;}
         pre {background:#e0e0e0}
</style>
</head>

<body>

<h1>Definice uživatelských datových typů v jazyku OCaml</h1>

<h3>Pavel Tišnovský</h3>

<p></p>

<h1>Úvodník</h1>

<p>Na článek o definicích uživatelských datových typů v jazyku F# dnes navážeme, protože si řekneme, jakým způsobem lze uživatelské datové typy definovat v programovacím jazyku OCaml. Uvidíme, že mezi oběma jazyky existují v této oblasti rozdíly, většinou však jen syntaktické.</p>



<h2>Obsah</h2>

<p><a href="#k01">1. Definice uživatelských datových typů v&nbsp;jazyku OCaml</a></p>
<p><a href="#k02">2. Datový typ záznam (<i>record</i>)</a></p>
<p><a href="#k03">3. Funkce akceptující parametr typu záznam</a></p>
<p><a href="#k04">4. Chování algoritmu typové inference v&nbsp;případě dvou struktur se shodnými prvky</a></p>
<p><a href="#k05">5. Datový typ výčet (<i>enum</i>)</a></p>
<p><a href="#k06">6. Datový typ n-tice (<i>tuple</i>)</a></p>
<p><a href="#k07">7. N-tice a pattern matching</a></p>
<p><a href="#k08">8. Disjunktní sjednocení s&nbsp;prvky typu n-tice</a></p>
<p><a href="#k09">9. Rekurzivní datová struktura: výraz</a></p>
<p><a href="#k10">10. Rekurzivní generická datová struktura: strom</a></p>
<p><a href="#k11">11. Třídy a objekty v&nbsp;ML jazycích</a></p>
<p><a href="#k12">12. Deklarace třídy</a></p>
<p><a href="#k13">13. Metoda deklarovaná ve třídě</a></p>
<p><a href="#k14">14. Konstrukce nové instance třídy realizovaná v&nbsp;metodě</a></p>
<p><a href="#k15">15. Přetížení operátoru pro instance třídy</a></p>
<p><a href="#k16">16. Deklarace přetíženého operátoru a automatické odvození typů operandů</a></p>
<p><a href="#k17">17. Kam dál? GADT</a></p>
<p><a href="#k18">18. Repositář s&nbsp;demonstračními příklady</a></p>
<p><a href="#k19">19. Odkazy na Internetu</a></p>



<p><a name="k01"></a></p>
<h2 id="k01">1. Definice uživatelských datových typů v&nbsp;jazyku OCaml</h2>

<p>Na tento týden vydaný <a
href="https://www.root.cz/clanky/definice-uzivatelskych-datovych-typu-v-jazyku-f/">článek
o definicích uživatelských datových typů v&nbsp;jazyku F#</a> dnes navážeme,
protože si řekneme, jakým způsobem lze uživatelské datové typy definovat
v&nbsp;programovacím jazyku OCaml. Uvidíme, že mezi oběma jazyky existují
v&nbsp;této oblasti rozdíly, většinou však jen syntaktické (ovšem prozatím jsme
se nevěnovali GADT, kde jsou již rozdíly dosti velké). Pro možnost rychlého
vizuálního srovnání společných vlastností a rozdílů v&nbsp;syntaxi dnes zkusíme
novinku &ndash; všechny příklady budou zapsány jak v&nbsp;jazyce OCaml, tak i
v&nbsp;jazyce F# a budou zobrazeny vedle sebe, přičemž odpovídající si řádky
budou skutečně zobrazeny na společném řádku (samozřejmě jen tam, kde je to
možné &ndash; tedy až na poslední dva příklady).</p>

<p>Původní zdrojové kódy všech demonstračních příkladů tak nebude možné
vykopírovat přímo z&nbsp;textu článku, ovšem samozřejmě jsou k&nbsp;dispozici
zdrojové kódy všech příkladů uvedené <a href="#k18">v&nbsp;osmnácté
kapitole</a>.</p>



<p><a name="k02"></a></p>
<h2 id="k02">2. Datový typ záznam (<i>record</i>)</h2>

<p>Datový typ záznam (<i>record</i>), jenž byl z&nbsp;pohledu programovacího
jazyka F# popsán <a
href="https://www.root.cz/clanky/definice-uzivatelskych-datovych-typu-v-jazyku-f/#k02">zde</a>,
lze samozřejmě použít i v&nbsp;OCamlu. Mezi oběma jazyky však v&nbsp;této
oblasti existují určité syntaktické rozdíly. Například v&nbsp;OCamlu jsou prvky
popsány malými písmeny a jako oddělovače mezi prvky se jak v&nbsp;definici typu
záznam, tak i při deklaraci hodnoty používají středníky. Rozdíly jsou dobře
patrné při porovnání zdrojového kódu v&nbsp;OCamlu a F# (zobrazeno vedle
sebe):</p>

<pre>
(* OCaml *)                    (* F# *)
&nbsp;
type user = {                  type User = 
  id: int;                         { ID: int
  name: string;                      Name: string
  surname: string;                   Surname: string}
} ;;                           
 &nbsp;                              
let pepa = {                   let pepa =
  id = 42;                         { ID = 42
  name = "Josef";                    Name = "Josef"
  surname = "Vyskočil"}              Surname = "Vyskočil"}
;;
&nbsp;
&nbsp;
pepa;;                         printf "%A\n" pepa
</pre>



<p><a name="k03"></a></p>
<h2 id="k03">3. Funkce akceptující parametr typu záznam</h2>

<p>Samozřejmě nám nic nebrání ve vytvoření funkce, která jako svůj parametr (či
parametry) akceptuje hodnotu typu záznam, což je téma, kterému jsme se věnovali
<a
href="https://www.root.cz/clanky/definice-uzivatelskych-datovych-typu-v-jazyku-f/#k03">v&nbsp;této
kapitole</a>. Opět se podívejme na (nepatrné &ndash; syntaktické) rozdíly mezi
jazyky OCaml a F# při definici a volání takové funkce:</p>

<pre>
(* OCaml *)                                   (* F# *)
&nbsp;
type user = {                                 type User = 
  id: int;                                        { ID: int
  name: string;                                     Name: string
  surname: string;                                  Surname: string
} ;;                                          }
&nbsp;
let print_user (u:user) =                     let print_user (x:User) =
  Printf.printf "%s %s\n" u.name u.surname        printf "%s %s" x.Name x.Surname
;;                                            
                                              
let pepa = {                                  
  id = 42;                                    let pepa =
  name = "Josef";                                 { ID = 42
  surname = "Vyskočil"}                             Name = "Josef"
;;                                              Surname = "Vyskočil"}
&nbsp;
&nbsp;
print_user pepa;;                             print_user pepa
</pre>

<p>Oba programovací jazyky OCaml i F# používají velmi (podobně koncipovaný)
sofistikovaný algoritmus pro typovou inferenci (<i>type inference</i>), který
například dokáže doplnit typ parametrů do definované funkce, a to na základě
jejího těla (nikoli na základě parametrů použitých při jejím volání). Opět se
pouze podívejme na syntaktické rozdíly mezi oběma jazyky, protože
z&nbsp;pohledu sémantiky jsme se tomuto tématu již věnovali:</p>

<pre>
(* OCaml *)                                   (* F# *)
&nbsp;
type user = {                                 type User = 
  id: int;                                        { ID: int
  name: string;                                     Name: string
  surname: string;                                  Surname: string
} ;;                                          }
&nbsp;
let print_user u =                            let print_user x =
  Printf.printf "%s %s\n" u.name u.surname        printf "%s %s" x.Name x.Surname
;;                                            
&nbsp;
let pepa = {                                  let pepa =
  id = 42;                                        { ID = 42
  name = "Josef";                                   Name = "Josef"
  surname = "Vyskočil"}                         Surname = "Vyskočil"}
;;
&nbsp;
&nbsp;
print_user pepa;;                             print_user pepa
</pre>



<p><a name="k04"></a></p>
<h2 id="k04">4. Chování algoritmu typové inference v&nbsp;případě dvou struktur se shodnými prvky</h2>

<p>Ve <a
href="https://www.root.cz/clanky/definice-uzivatelskych-datovych-typu-v-jazyku-f/#k04">čtvrté
kapitole</a> <a
href="https://www.root.cz/clanky/definice-uzivatelskych-datovych-typu-v-jazyku-f/">předchozího
článku</a> jsme si ukázali některá úskalí algoritmu typové inference. Ten jsme
totiž &bdquo;zmátli&ldquo; tím, že se ve funkci <strong>print_user</strong>
pracuje jen s&nbsp;položkami <strong>Name</strong> a <strong>Surname</strong>,
takže typová inference odvodí, že by se mohlo jednat o parametr typu
<strong>UserWithoutID</strong>. Ovšem ve skutečnosti bude funkce volána
s&nbsp;parametrem typu <strong>User</strong>, což vede k&nbsp;chybě při
překladu. V&nbsp;programovacím jazyku OCaml dojde k&nbsp;naprosto stejné
situaci (až &ndash; opět &ndash; na poněkud odlišnou syntaxi):</p>

<pre>
(* OCaml *)                                   (* F# *)
&nbsp;
type user = {                                 type User = 
  id: int;                                        { ID: int
  name: string;                                     Name: string
  surname: string;                                  Surname: string
} ;;                                          }
&nbsp;
type user_without_id = {                      type UserWithoutID = 
  name: string;                                   { Name: string
  surname: string;                                  Surname: string
} ;;
&nbsp;
let print_user u =                            let print_user x =
  Printf.printf "%s %s\n" u.name u.surname        printf "%s %s" x.Name x.Surname
;;
&nbsp;
let pepa =  {                                 let pepa =
  id = 42;                                        { ID = 42
  name = "Josef";                                   Name = "Josef"
  surname = "Vyskočil"}                         Surname = "Vyskočil"}
;;
&nbsp;
&nbsp;
(* nefunkcni varianta *)                      (* nefunkcni varianta *)
print_user pepa;;                             print_user pepa
</pre>

<p>Řešením je explicitní specifikace typu parametru funkce
<strong>print_user</strong>. Po této úpravě je již možné oba zdrojové kódy
přeložit a spustit:</p>

<pre>
(* OCaml *)                                   (* F# *)
&nbsp;
type user = {                                 type User = 
  id: int;                                        { ID: int
  name: string;                                     Name: string
  surname: string;                                  Surname: string
} ;;                                          }
&nbsp;
type user_without_id = {                      type UserWithoutID = 
  name: string;                                   { Name: string
  surname: string;                                  Surname: string
} ;;                                          }
&nbsp;
let print_user (u:user) =                     let print_user (x:User) =
  Printf.printf "%s %s\n" u.name u.surname        printf "%s %s" x.Name x.Surname
;;
&nbsp;
let pepa =  {                                 let pepa =
  id = 42;                                        { ID = 42
  name = "Josef";                                   Name = "Josef"
  surname = "Vyskočil"}                         Surname = "Vyskočil"}
;;
&nbsp;
&nbsp;
(* funkcni varianta *)                        (* funkcni varianta *)
print_user pepa;;                             print_user pepa
</pre>



<p><a name="k05"></a></p>
<h2 id="k05">5. Datový typ výčet (<i>enum</i>)</h2>

<p>Připomeňme si, že v&nbsp;programovacím jazyku F# existuje datový typ výčet,
v&nbsp;němž můžeme definovat jak prvky ve výčtu, tak i jejich hodnoty.
V&nbsp;praxi je použití tohoto typu snadné, protože pouze postačuje
specifikovat názvy a hodnoty jednotlivých prvků uložených ve výčtu. Hodnoty se
získají snadno &ndash; opět se použije tečková notace, tedy podobně, jako je
tomu u výše uvedených záznamů:</p>

<pre>
type Day = Po=1 | Ut=2 | St=3 | Ct=4 | Pa=5 | So=6 | Ne=7
&nbsp;
let x = Day.St
&nbsp;
printf "%A\n" x
</pre>

<p>Zápis je možné provést i odlišným způsobem (který je sice delší, zato
přehlednější):</p>

<pre>
type Day =
     | Po=1
     | Ut=2
     | St=3
     | Ct=4
     | Pa=5
     | So=6
     | Ne=7
let x = Day.St
printf "%A\n" x
</pre>

<p>Tento datový typ v&nbsp;přesné podobě v&nbsp;OCamlu sice nenajdeme, ovšem
kromě toho existuje i typ <i>disjunktní sjednocení</i> (<i>discriminated
union</i>). V&nbsp;té nejjednodušší podobě může být tento typ definován pouhým
výčtem možností a zde již v&nbsp;OCamlu najdeme stejný typ:</p>

<pre>
(* OCaml *)                                      (* F# *)
&nbsp;
type day = Po | Ut | St | Ct | Pa | So | Ne;;    type Day = Po | Ut | St | Ct | Pa | So | Ne
&nbsp;
let x = St;;                                     let x = St
&nbsp;
x;;                                              printf "%A\n" x
</pre>

<p>Popř.:</p>

<pre>
(* OCaml *)           (* F# *)
&nbsp;
type day =            type Day =
    | Po                   | Po
    | Ut                   | Ut
    | St                   | St
    | Ct                   | Ct
    | Pa                   | Pa
    | So                   | So
    | Ne;;                 | Ne
&nbsp;
let x = St;;          let x = St
&nbsp;
x;;                   printf "%A\n" x </pre>
</pre>

<p>Opět se tedy jedná o nepatrnou změnu syntaxe, nikoli sémantiky.</p>



<p><a name="k06"></a></p>
<h2 id="k06">6. Datový typ n-tice (<i>tuple</i>)</h2>

<p>Datový typ n-tice byl z&nbsp;pohledu programovacího jazyka F# popsán <a
href="https://www.root.cz/clanky/definice-uzivatelskych-datovych-typu-v-jazyku-f/#k07">minule
v&nbsp;sedmé kapitole</a>. V&nbsp;jazyku OCaml se používá naprosto stejná
deklarace a i samotné hodnoty typu n-tice lze zpracovávat zcela stejným
způsobem, včetně <i>destructuringu</i> (není divu, jedná se o dědictví ze
společného prapředka &ndash; jazyka ML):</p>

<pre>
(* OCaml *)                                   (* F# *)
&nbsp;
type rectangle = int * int;;                  type Rectangle = int * int
&nbsp;
let print_rectange r =                        let print_rectange r =
  let (width, height) = r in                      let (width, height) = r in
  Printf.printf "rect: %dx%d\n" width height          printf "rect: %dx%d\n" width height
;;
&nbsp;
let r1 = (10, 20);;                           let r1 = (10, 20)
&nbsp;
print_rectange r1;;                           print_rectange r1
</pre>

<p><div class="rs-tip-major">Poznámka: pro oba popisované jazyky je typické, že
konstruktor je zapisován stejně jako výraz s&nbsp;&bdquo;rozpadem&ldquo; n-tice
na jednotlivé prvky.</div></p>



<p><a name="k07"></a></p>
<h2 id="k07">7. N-tice a pattern matching</h2>

<p>Při čtení prvků z&nbsp;n-tice se často setkáme s&nbsp;využitím <i>pattern
matchingu</i>, který v&nbsp;tomto případě může mít jen jedinou větev. Podívejme
se na následující příklad, v&nbsp;němž z&nbsp;n-tice obsahující šířku a výšku
obdélníku získáme obě délky v&nbsp;samostatných lokálních proměnných
<strong>width</strong> a <strong>height</strong>. Samozřejmě opět porovnáme
variantu napsanou v&nbsp;OCamlu s&nbsp;variantou naprogramovanou v&nbsp;jazyku
F#:</p>

<pre>
(* OCaml *)                                                        (* F# *)
&nbsp;
type rectangle = int * int;;                                       type Rectangle = int * int
&nbsp;
let print_rectange (r:rectangle) =                                 let print_rectange (r : Rectangle) =
  match r with                                                         match r with
  | (width, height) -&gt; Printf.printf "rect: %dx%d\n" width height      | (width, height) -&gt; printf "rect: %dx%d\n" width height
;;
&nbsp;
let r1 = (10, 20);;                                                let r1 = (10, 20)
&nbsp;
print_rectange r1;;                                                print_rectange r1
</pre>

<p>Mnohdy se taktéž setkáme s&nbsp;následujícím zápisem, který nás již
připravuje na seznámení se s&nbsp;dalšími možnostmi zápisu disjunktního
sjednocení (<i>discriminated union</i>):</p>

<pre>
(* OCaml *)                                                          (* F# *)
&nbsp;
type rectangle = R of int * int;;                                    type Rectangle = R of int * int
&nbsp;
let print_rectange (r : rectangle) =                                 let print_rectange (r : Rectangle) =
  match r with                                                           match r with
  | R(width, height) -&gt; Printf.printf "rect: %dx%d\n" width height       | R(width, height) -&gt; printf "rect: %dx%d\n" width height
;;
&nbsp;
let r1 = R(10, 20);;                                                 let r1 = R(10, 20)
&nbsp;
print_rectange r1;;                                                  print_rectange r1
</pre>

<p>Shodné pojmenování typu a prvku sjednocení v&nbsp;jazyce F# většinou
v&nbsp;OCaml nevyužijeme:</p>

<pre>
(* OCaml *)                                                               (* F# *)
&nbsp;
type rectangle = Rectangle of int * int;;                                 type Rectangle = Rectangle of int * int
&nbsp;
let print_rectange (r:rectangle) =                                        let print_rectange (r : Rectangle) =
  match r with                                                                match r with
  | Rectangle(width, height) -&gt; Printf.printf "rect: %dx%d\n" width height    | Rectangle(width, height) -&gt; printf "rect: %dx%d\n" width height   
;;
&nbsp;
let r1 = Rectangle(10, 20);;                                              let r1 = Rectangle(10, 20)
&nbsp;
print_rectange r1;;                                                       print_rectange r1
</pre>



<p><a name="k08"></a></p>
<h2 id="k08">8. Disjunktní sjednocení s&nbsp;prvky typu n-tice</h2>

<p><a
href="https://www.root.cz/clanky/definice-uzivatelskych-datovych-typu-v-jazyku-f/#k10">Minule
jsme si taktéž ukázali</a> velmi důležitý rys ML jazyků &ndash; možnost
definovat typ reprezentující několik různých hodnot, které samy o sobě nejsou
stejného typu. Příkladem je typ nazvaný <strong>Shape</strong>, který ve
skutečnosti znamená, že buď pracujeme s&nbsp;hodnotou typu
<strong>Rectangle</strong> nebo hodnotou typu <strong>Circle</strong>.
Použijeme zde disjunktní sjednocení, které se v&nbsp;obou jazycích,
tj.&nbsp;jak v OCamlu, tak i v&nbsp;jazyku F#, zapisuje prakticky totožným
způsobem:</p>

<pre>
(* OCaml *)                                                                  (* F# *)
&nbsp;
type shape = Rectangle of int * int | Circle of int;;                        type Shape = Rectangle of int * int | Circle of int
&nbsp;
let print_shape (s : shape) =                                                let print_shape (s : Shape) =
  match s with                                                                 match s with
  | Circle r -&gt; Printf.printf "circle: %d\n" r                                 | Circle r -&gt; printf "circle: %d\n" r
  | Rectangle (width, height) -&gt; Printf.printf "rect: %dx%d\n" width height    | Rectangle (width, height) -&gt; printf "rect: %dx%d\n" width height
;;
&nbsp;
let r1 = Rectangle (10, 20);;                                                let r1 = Rectangle (10, 20)
let c = Circle 100;;                                                         let c = Circle 100
&nbsp;
print_shape r1;;                                                             print_shape r1
print_shape c;;                                                              print_shape c
</pre>

<p>V&nbsp;praxi se velmi často setkáme s&nbsp;tím, že deklarace typu
<strong>Shape/shape</strong> se zapisuje na více řádcích, aby tak po vizuální
stránce odpovídala blokům <strong>match</strong>, v&nbsp;nichž s&nbsp;hodnotami
tohoto typu pracujeme (každý konkrétní typ pak začíná řádkem začínajícím znakem
|):</p>

<pre>
(* OCaml *)                                                                  (* F# *)
&nbsp;
type shape =                                                                 type Shape = 
  | Rectangle of int * int                                                       | Circle of int
  | Circle of int;;                                                              | Rectangle of int * int
&nbsp;
let print_shape (s : shape) =                                                let print_shape (s : Shape) =
  match s with                                                                 match s with
  | Circle r -&gt; Printf.printf "circle: %d\n" r                                 | Circle r -&gt; printf "circle: %d\n" r
  | Rectangle (width, height) -&gt; Printf.printf "rect: %dx%d\n" width height    | Rectangle (width, height) -&gt; printf "rect: %dx%d\n" width height
;;
&nbsp;
let r1 = Rectangle (10, 20);;                                                let r1 = Rectangle (10, 20)
let c = Circle 100;;                                                         let c = Circle 100
&nbsp;
print_shape r1;;                                                             print_shape r1
print_shape c;;                                                              print_shape c
</pre>



<p><a name="k09"></a></p>
<h2 id="k09">9. Rekurzivní datová struktura: výraz</h2>

<p>Disjunktní sjednocení zkombinované s&nbsp;n-ticemi ve skutečnosti
představuje velmi silný rys programovacích jazyků F# i OCaml. Tento rys je
navíc umocněn tím, že je možné definovat i rekurzivní datový typ, kdy jedna
z&nbsp;položek sjednocení je typem obsahujícím samotné sjednocení. Příkladem je
reprezentace výrazu (<i>expression</i>); ostatně právě OCaml se často používá
při implementaci překladačů, kde se s&nbsp;podobnými objekty můžeme velmi často
setkat. Zápis takového rekurzivního typu je v&nbsp;obou jazycích prakticky
totožný:</p>

<pre>
(* OCaml *)                                           (* F# *)
&nbsp;
type expr =                                           type expr =
  | Plus of expr * expr        (* a + b *)                | Plus of expr * expr        (* a + b *)
  | Minus of expr * expr       (* a - b *)                | Minus of expr * expr       (* a - b *)
  | Times of expr * expr       (* a * b *)                | Times of expr * expr       (* a * b *)
  | Divide of expr * expr      (* a / b *)                | Divide of expr * expr      (* a / b *)
  | Var of string                                         | Var of string    
;;                                                    
&nbsp;
let x = Times (Var "n", Plus (Var "x", Var "y"));;    let x = Times (Var "n", Plus (Var "x", Var "y"))
&nbsp;
x;;                                                   printf "%A\n" x
</pre>



<p><a name="k10"></a></p>
<h2 id="k10">10. Rekurzivní generická datová struktura: strom</h2>

<p>Možnosti typového systému jazyků OCaml a F# jdou ve skutečnosti ještě dále,
protože můžeme vytvořit generický rekurzivní datový typ. Tentokrát se bude
jednat o datový typ představující strom (přesněji řečeno binární strom), což je
pochopitelně rekurzivní datová struktura. Povšimněte si, že existují dva typy
prvků (uzlů). Prázdný (koncový uzel) nebo uzel představovaný n-ticí obsahující
levý podstrom, hodnotu uloženou v&nbsp;uzlu a pravý podstrom (samozřejmě, že
podstromy mohou být prázdné, takže se může jednat o list stromu). V&nbsp;jazyku
OCaml se v&nbsp;tomto případě používá poněkud odlišný zápis &ndash; podle mého
skromného názoru čitelnější, než v&nbsp;případě F#, ovšem F# je v&nbsp;tomto
ohledu poplatný jazykům odvozeným od C++ či Javy:</p>

<pre>
(* OCaml *)                                            (* F# *)
&nbsp;
type 'a tree =                                         type Tree&lt;'a&gt; =
  | E                                                      | E
  | T of 'a tree * 'a * 'a tree                            | T of Tree&lt;'a&gt; * 'a * Tree&lt;'a&gt;
;;                                                     
&nbsp;
let t1 = T(E, "foo", E);;                              let t1 = T(E, "foo", E)
let t2 = T(T(E, "foo", E), "bar", T(E, "baz", E));;    let t2 = T(T(E, "foo", E), "bar", T(E, "baz", E))
&nbsp;                                                      
t1;;                                                   printf "%A\n" t1
t2;;                                                   printf "%A\n" t2
</pre>



<p><a name="k11"></a></p>
<h2 id="k11">11. Třídy a objekty v&nbsp;ML jazycích</h2>

<p>Písmeno &bdquo;O&ldquo; v&nbsp;názvu jazyka OCaml znamená
&bdquo;objective&ldquo;, což nám prozrazuje, že tento programovací jazyk nabízí
programátorům možnost práce s&nbsp;objekty (jejichž typem je třída). Zatímco
v&nbsp;OCamlu se jednalo o více či méně užitečnou &bdquo;úlitbu&ldquo; dobovým
požadavkům, je podpora objektově orientovaného programování v&nbsp;jazyku F#
prakticky nutností, protože programy psané v&nbsp;tomto jazyku musí
spolupracovat s&nbsp;dalšími jazyky v&nbsp;ekosystému .NET. Z&nbsp;tohoto
důvodu si v&nbsp;dalších kapitolách připomeneme základy OOP v&nbsp;jazyku F# i
to, jak se podobné koncepty realizují v&nbsp;jazyku OCaml (jenž je starší a
nebyl navržen tak, aby se podobal například C++).</p>



<p><a name="k12"></a></p>
<h2 id="k12">12. Deklarace třídy</h2>

<p>Podívejme se nyní na deklaraci jednoduché třídy <strong>Rectangle</strong>,
jejíž instance budou mít dva atributy nazvané <strong>X</strong> a
<strong>Y</strong> (rozměry v&nbsp;jednotlivých osách) a s&nbsp;konstruktorem,
který akceptuje dva parametry typu <strong>int</strong> (výchozí hodnoty
rozměrů). Zde se již syntaxe obou jazyků poměrně významně odlišuje:</p>

<pre>
(* OCaml *)                         (* F# *)
&nbsp;
class rectangle (x:int) (y:int) =   type Rectangle(x: int, y: int) =
  object (self)                         member this.X = x
    val x = x                           member this.Y = y
    val y = y
  end;;
&nbsp;
 &nbsp;   
let r1 = new rectangle 10 20;;      let r1 = Rectangle(10, 20)
&nbsp;
r1;;                                printf "%A\n" r1
</pre>

<p><div class="rs-tip-major">Poznámka: v&nbsp;tomto případě je zápis
v&nbsp;programovacím jazyku F# řešen poměrně elegantnějším způsobem &ndash; typ
&bdquo;třída&ldquo; je na stejné úrovni, jako jakýkoli jiný typ.</div></p>



<p><a name="k13"></a></p>
<h2 id="k13">13. Metoda deklarovaná ve třídě</h2>

<p>Do deklarace třídy můžeme přidat i metody. Například se může jednat o metodu
nazvanou <strong>Print</strong> (v&nbsp;OCamlu <strong>print</strong>), která
vytiskne jak název objektu, tak i jeho atributy. Zde již narazíme na dnes možná
poněkud zvláštní způsob zápisu volání metody v&nbsp;OCamlu, kdy se namísto
tečkové notace používá křížek (ale samozřejmě je snadné si na to zvyknout):</p>

<pre>
(* OCaml *)                                                (* F# *)
&nbsp;
class rectangle (x:int) (y:int) =                          type Rectangle(x: int, y: int) =
  object (self)                                                member this.X = x
    val x = x                                                  member this.Y = y
    val y = y                                                  member this.Print() =
    method print = Printf.printf "Rectangle: %dx%d\n" x y          printf "Rectangle: %dx%d\n" x y
  end;;
&nbsp;
let r1 = new rectangle 10 20;;                             let r1 = Rectangle(10, 20)
&nbsp;
r1#print;;                                                 r1.Print()
</pre>



<p><a name="k14"></a></p>
<h2 id="k14">14. Konstrukce nové instance třídy realizovaná v&nbsp;metodě</h2>

<p>Ve shodně očíslované <a
href="https://www.root.cz/clanky/definice-uzivatelskych-datovych-typu-v-jazyku-f/#k14">čtrnácté
kapitole</a> jsme si minule řekli, že se relativně často setkáme s&nbsp;tím, že
nějaká metoda má změnit stav objektu, tj.&nbsp;vlastně hodnoty jeho atributů.
To lze samozřejmě zařídit tak, že se příslušné atributy deklarují takovým
způsobem, aby byly měnitelné. Ovšem mnohdy je výhodnější použít odlišný přístup
&ndash; taková metoda bude vracet nový objekt, ovšem již se změněným stavem.
Příkladem může být požadavek na změnu velikosti obdélníka, tedy získání
obdélníka, jehož rozměry na x-ové a y-ové ose budou zvětšeny nebo zmenšeny o
nějaké hodnoty <strong>dx</strong> a <strong>dy</strong>. Pro tento účel lze
deklarovat metodu <strong>Enlarge</strong>, která vrací novou instanci
<strong>Rectangle</strong> (ale stávající instanci nijak nemění).</p>

<p>Realizace v&nbsp;obou porovnávaných jazycích by mohla vypadat
následovně:</p>

<pre>
(* OCaml *)                                                          (* F# *)
&nbsp;
class rectangle (x:int) (y:int) =                                    type Rectangle(x: int, y: int) =
  object (self)                                                          member this.X = x
    val x = x                                                            member this.Y = y
    val y = y                                                            member this.Print() =
    method print = Printf.printf "Rectangle: %dx%d\n" x y                    printf "Rectangle: %dx%d\n" this.X this.Y
    method enlarge (xd:int) (yd:int) = new rectangle (x+xd) (y+yd)       member this.Enlarge(dx, dy) =
  end;;                                                                      Rectangle(this.X + dx, this.Y + dy)
&nbsp;
let r1 = new rectangle 10 20;;                                       let r1 = Rectangle(10, 20)
let r2 = r1#enlarge 1 2;;                                            let r2 = r1.Enlarge(1, 2)
&nbsp;
r1#print;;                                                           r1.Print()
r2#print;;                                                           r2.Print()
</pre>



<p><a name="k15"></a></p>
<h2 id="k15">15. Přetížení operátoru pro instance třídy</h2>

<p>V&nbsp;dnešním posledním demonstračním příkladu, v&nbsp;němž budeme
porovnávat sémantické a syntaktické shody a rozdíly mezi programovacími jazyky
OCaml a F#, si ukážeme definici přetíženého operátoru pro instance třídy
<strong>Vector</strong> resp.&nbsp;<strong>vector</strong>. V&nbsp;případě
jazyka OCaml je tento operátor přetížen na úrovni modulu, zatímco v&nbsp;jazyku
F# můžeme operátor definovat jako statickou metodu třídy
<strong>Vector</strong>. Výsledek ovšem bude stejný &ndash; možnost sčítat
vektory tak, jak je to běžné v&nbsp;matematice, tedy s&nbsp;využitím
k&nbsp;tomu určeného (přetíženého) operátoru +:</p>

<pre>
(* OCaml *)                                           (* F# *)
&nbsp;
class vector (x:int) (y:int) =                        type Vector(x: int, y: int) =
  object (self)                                           member this.X = x
    val x = x                                             member this.Y = y
    val y = y                                             member this.Print() =
    method print = Printf.printf "Vector: %dx%d\n" x y        printf "Vector: %dx%d\n" this.X this.Y
    method get_x = x
    method get_y = y
  end;;
&nbsp;
let(+) (a: vector) (b: vector) =                          static member (+) (a : Vector, b : Vector) =
    new vector (a#get_x+b#get_x) (a#get_y+b#get_y);;          Vector(a.X + b.X, a.Y + b.Y)
&nbsp;
let v1 = new vector 10 20;;                           let v1 = Vector(10, 20)
v1#print;;                                            v1.Print()
&nbsp;
let v2 = new vector 1 2;;                             let v2 = Vector(1, 2)
v2#print;;                                            v2.Print()
&nbsp;
let v3 = v1 + v2;;                                    let v3 = v1 + v2
v3#print;;                                            v3.Print()
</pre>

<p><div class="rs-tip-major">Poznámka: původní funkcionalita operátoru + však
nebude v&nbsp;případě jazyka OCaml zachována! Použijte raději jiný
operátor:</div></p>

<pre>
let(+@) (a: vector) (b: vector) = new vector (a#get_x+b#get_x) (a#get_y+b#get_y);;
</pre>

<p><div class="rs-tip-major">Poznámka: zde můžeme vidět nejenom syntaktický
rozdíl, ale i rozdíl v&nbsp;sémantice.</div></p>



<p><a name="k16"></a></p>
<h2 id="k16">16. Deklarace přetíženého operátoru a automatické odvození typů operandů</h2>

<p>Díky algoritmu typové inference je možné vynechat explicitní určení typů
parametrů pro nově definovaný (či přetížený) operátor. Výsledkem bude kratší
programový kód, který však od programátora již vyžaduje znalost kontextu:</p>

<pre>
class vector x y =
  object (self)
    val x = x
    val y = y
    method print = Printf.printf "Vector: %dx%d\n" x y
    method get_x = x
    method get_y = y
  end;;
&nbsp;
let(+?) a b = new vector (a#get_x+b#get_x) (a#get_y+b#get_y);;
&nbsp;
let v1 = new vector 10 20;;
v1#print;;
&nbsp;
let v2 = new vector 1 2;;
v2#print;;
&nbsp;
let v3 = v1 +? v2;;
v3#print;;
</pre>



<p><a name="k17"></a></p>
<h2 id="k17">17. Kam dál? GADT</h2>

<p>Až doposud bylo patrné, že jazyky F# a OCaml mají prakticky totožnou
sémantiku a většinou i velmi podobnou syntaxi. Ovšem právě v&nbsp;oblasti
typových systémů se začínají oba jazyky postupně rozcházet. Je tomu tak
především proto, že v&nbsp;OCamlu lze od verze 4.00 používat takzvaný
<i>GADT</i> neboli <i>Generalized algebraic data type</i>. Jedná se o velmi
zajímavý a užitečný koncept, kterému se budeme věnovat v&nbsp;samostatném
článku (resp.&nbsp;s&nbsp;velkou pravděpodobností ve dvou článcích). Ovšem
stále nám zbývá popis společných vlastností obou jazyků. Například jsme se
doposud nezabývali všemi řídicími konstrukcemi jazyků F# a OCaml atd.</p>



<p><a name="k18"></a></p>
<h2 id="k18">18. Repositář s&nbsp;demonstračními příklady</h2>

<p>Všechny výše popsané demonstrační příklady byly uloženy do repositáře
dostupného na adrese <a
href="https://github.com/tisnik/ocaml-examples/">https://github.com/tisnik/ocaml-examples/</a>.
V&nbsp;tabulce umístěné pod tímto odstavcem jsou uvedeny odkazy na tyto
příklady:</p>

<table>
<tr><th> #</th><th>Příklad</th><th>Popis příkladu</th><th>Cesta</th></tr>
<tr><td> 1</td><td>article_01/hello_world_1.ml</td><td>zavolání funkce <strong>print_string</strong></td><td><a href="https://github.com/tisnik/ocaml-examples/tree/master/article_01/hello_world_1.ml">https://github.com/tisnik/ocaml-examples/tree/master/article_01/hello_world_1.ml</a></td></tr>
<tr><td> 2</td><td>article_01/hello_world_2.ml</td><td>zavolání funkce <strong>printf.Printf</strong></td><td><a href="https://github.com/tisnik/ocaml-examples/tree/master/article_01/hello_world_2.ml">https://github.com/tisnik/ocaml-examples/tree/master/article_01/hello_world_2.ml</a></td></tr>
<tr><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td></tr>
<tr><td> 3</td><td>article_01/function.ml</td><td>definice funkce</td><td><a href="https://github.com/tisnik/ocaml-examples/tree/master/article_01/function.ml">https://github.com/tisnik/ocaml-examples/tree/master/article_01/function.ml</a></td></tr>
<tr><td> 4</td><td>article_01/lambda.ml</td><td>anonymní funkce</td><td><a href="https://github.com/tisnik/ocaml-examples/tree/master/article_01/lambda.ml">https://github.com/tisnik/ocaml-examples/tree/master/article_01/lambda.ml</a></td></tr>
<tr><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td></tr>
<tr><td> 5</td><td>article_01/function_type_1.ml</td><td>explicitní specifikace typu návratové hodnoty funkce</td><td><a href="https://github.com/tisnik/ocaml-examples/tree/master/article_01/function_type_1.ml">https://github.com/tisnik/ocaml-examples/tree/master/article_01/function_type_1.ml</a></td></tr>
<tr><td> 6</td><td>article_01/function_type_2.ml</td><td>explicitní specifikace typu návratové hodnoty funkce</td><td><a href="https://github.com/tisnik/ocaml-examples/tree/master/article_01/function_type_2.ml">https://github.com/tisnik/ocaml-examples/tree/master/article_01/function_type_2.ml</a></td></tr>
<tr><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td></tr>
<tr><td> 7</td><td>article_01/call_function_1.ml</td><td>definice jednoduché funkce s&nbsp;jejím zavoláním</td><td><a href="https://github.com/tisnik/ocaml-examples/tree/master/article_01/call_function_1.ml">https://github.com/tisnik/ocaml-examples/tree/master/article_01/call_function_1.ml</a></td></tr>
<tr><td> 8</td><td>article_01/call_function_2.ml</td><td>definice jednoduché funkce s&nbsp;jejím zavoláním</td><td><a href="https://github.com/tisnik/ocaml-examples/tree/master/article_01/call_function_2.ml">https://github.com/tisnik/ocaml-examples/tree/master/article_01/call_function_2.ml</a></td></tr>
<tr><td> 9</td><td>article_01/call_function_3.ml</td><td>použití operátoru <strong>+</strong> pro dvojici hodnot typu <strong>float</strong></td><td><a href="https://github.com/tisnik/ocaml-examples/tree/master/article_01/call_function_3.ml">https://github.com/tisnik/ocaml-examples/tree/master/article_01/call_function_3.ml</a></td></tr>
<tr><td>10</td><td>article_01/call_function_4.ml</td><td>použití operátoru <strong>+.</strong> pro dvojici hodnot typu <strong>float</strong></td><td><a href="https://github.com/tisnik/ocaml-examples/tree/master/article_01/call_function_4.ml">https://github.com/tisnik/ocaml-examples/tree/master/article_01/call_function_4.ml</a></td></tr>
<tr><td>11</td><td>article_01/call_function_5.ml</td><td>plná deklarace funkce bez syntaktického cukru</td><td><a href="https://github.com/tisnik/ocaml-examples/tree/master/article_01/call_function_5.ml">https://github.com/tisnik/ocaml-examples/tree/master/article_01/call_function_5.ml</a></td></tr>
<tr><td>12</td><td>article_01/call_function_6.ml</td><td>plná deklarace funkce bez syntaktického cukru</td><td><a href="https://github.com/tisnik/ocaml-examples/tree/master/article_01/call_function_6.ml">https://github.com/tisnik/ocaml-examples/tree/master/article_01/call_function_6.ml</a></td></tr>
<tr><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td></tr>
<tr><td>13</td><td>article_01/local_binding_1.ml</td><td>definice lokálních symbolů</td><td><a href="https://github.com/tisnik/ocaml-examples/tree/master/article_01/local_binding_1.ml">https://github.com/tisnik/ocaml-examples/tree/master/article_01/local_binding_1.ml</a></td></tr>
<tr><td>14</td><td>article_01/local_binding_2.ml</td><td>definice lokálních symbolů</td><td><a href="https://github.com/tisnik/ocaml-examples/tree/master/article_01/local_binding_2.ml">https://github.com/tisnik/ocaml-examples/tree/master/article_01/local_binding_2.ml</a></td></tr>
<tr><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td></tr>
<tr><td>15</td><td>article_02/basic_binding.ml</td><td>navázání hodnoty na symbol (deklarace proměnné)</td><td><a href="https://github.com/tisnik/ocaml-examples/tree/master/article_02/basic_binding.ml">https://github.com/tisnik/ocaml-examples/tree/master/article_02/basic_binding.ml</a></td></tr>
<tr><td>16</td><td>article_02/print_variable.ml</td><td>tisk hodnoty proměnné</td><td><a href="https://github.com/tisnik/ocaml-examples/tree/master/article_02/print_variable.ml">https://github.com/tisnik/ocaml-examples/tree/master/article_02/print_variable.ml</a></td></tr>
<tr><td>17</td><td>article_02/variables_and_functions.ml</td><td>předání proměnné do funkce</td><td><a href="https://github.com/tisnik/ocaml-examples/tree/master/article_02/variables_and_functions.ml">https://github.com/tisnik/ocaml-examples/tree/master/article_02/variables_and_functions.ml</a></td></tr>
<tr><td>18</td><td>article_02/redefine_symbol_1.ml</td><td>pokus o redefinici symbolu</td><td><a href="https://github.com/tisnik/ocaml-examples/tree/master/article_02/redefine_symbol_1.ml">https://github.com/tisnik/ocaml-examples/tree/master/article_02/redefine_symbol_1.ml</a></td></tr>
<tr><td>19</td><td>article_02/redefine_symbol_2.ml</td><td>pokus o redefinici symbolu (složitější příklad)</td><td><a href="https://github.com/tisnik/ocaml-examples/tree/master/article_02/redefine_symbol_2.ml">https://github.com/tisnik/ocaml-examples/tree/master/article_02/redefine_symbol_2.ml</a></td></tr>
<tr><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td></tr>
<tr><td>20</td><td>article_02/requal_operator_1.ml</td><td>operátor =</td><td><a href="https://github.com/tisnik/ocaml-examples/tree/master/article_02/equal_operator_1.ml">https://github.com/tisnik/ocaml-examples/tree/master/article_02/equal_operator_1.ml</a></td></tr>
<tr><td>21</td><td>article_02/requal_operator_2.ml</td><td>operátor =</td><td><a href="https://github.com/tisnik/ocaml-examples/tree/master/article_02/equal_operator_2.ml">https://github.com/tisnik/ocaml-examples/tree/master/article_02/equal_operator_2.ml</a></td></tr>
<tr><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td></tr>
<tr><td>22</td><td>article_02/immutable_variable.ml</td><td>&bdquo;změna&ldquo; neměnitelné proměnné</td><td><a href="https://github.com/tisnik/ocaml-examples/tree/master/article_02/immutable_variable.ml">https://github.com/tisnik/ocaml-examples/tree/master/article_02/immutable_variable.ml</a></td></tr>
<tr><td>22</td><td>article_02/mutable_variable.ml</td><td>změna měnitelné proměnné</td><td><a href="https://github.com/tisnik/ocaml-examples/tree/master/article_02/mutable_variable.ml">https://github.com/tisnik/ocaml-examples/tree/master/article_02/mutable_variable.ml</a></td></tr>
<tr><td>23</td><td>article_02/shadow.ml</td><td>shadowing symbolu</td><td><a href="https://github.com/tisnik/ocaml-examples/tree/master/article_02/shadow.ml">https://github.com/tisnik/ocaml-examples/tree/master/article_02/shadow.ml</a></td></tr>
<tr><td>24</td><td>article_02/incr.ml</td><td>standardní funkce <strong>incr</strong></td><td><a href="https://github.com/tisnik/ocaml-examples/tree/master/article_02/incr.ml">https://github.com/tisnik/ocaml-examples/tree/master/article_02/incr.ml</a></td></tr>
<tr><td>25</td><td>article_02/ident.ml</td><td>nejjednodušší polymorfická funkce</td><td><a href="https://github.com/tisnik/ocaml-examples/tree/master/article_02/ident.ml">https://github.com/tisnik/ocaml-examples/tree/master/article_02/ident.ml</a></td></tr>
<tr><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td></tr>
<tr><td>26</td><td>article_02/tuple1.ml</td><td>datový typ n-tice (<i>tuple</i>)</td><td><a href="https://github.com/tisnik/ocaml-examples/tree/master/article_02/tuple1.ml">https://github.com/tisnik/ocaml-examples/tree/master/article_02/tuple1.ml</a></td></tr>
<tr><td>27</td><td>article_02/tuple2.ml</td><td>datový typ n-tice (<i>tuple</i>)</td><td><a href="https://github.com/tisnik/ocaml-examples/tree/master/article_02/tuple2.ml">https://github.com/tisnik/ocaml-examples/tree/master/article_02/tuple2.ml</a></td></tr>
<tr><td>28</td><td>article_02/record1.ml</td><td>datový typ záznam (<i>record</i>), deklarace proměnné tohoto typu</td><td><a href="https://github.com/tisnik/ocaml-examples/tree/master/article_02/record1.ml">https://github.com/tisnik/ocaml-examples/tree/master/article_02/record1.ml</a></td></tr>
<tr><td>29</td><td>article_02/record2.ml</td><td>datový typ záznam (<i>record</i>) a typová inference</td><td><a href="https://github.com/tisnik/ocaml-examples/tree/master/article_02/record2.ml">https://github.com/tisnik/ocaml-examples/tree/master/article_02/record2.ml</a></td></tr>
<tr><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td></tr>
<tr><td>30</td><td>article_02/unit.ml</td><td>datový typ <strong>unit</strong> a rozdíl oproti funkcím bez parametrů</td><td><a href="https://github.com/tisnik/ocaml-examples/tree/master/article_02/unit.ml">https://github.com/tisnik/ocaml-examples/tree/master/article_02/unit.ml</a></td></tr>
<tr><td>31</td><td>article_02/polymorphic.ml</td><td>použití polymorfických funkcí</td><td><a href="https://github.com/tisnik/ocaml-examples/tree/master/article_02/polymorphic.ml">https://github.com/tisnik/ocaml-examples/tree/master/article_02/polymorphic.ml</a></td></tr>
<tr><td>32</td><td>article_02/two_same_records.ml</td><td>dva datové typy záznam se shodnými prvky</td><td><a href="https://github.com/tisnik/ocaml-examples/tree/master/article_02/two_same_records.ml">https://github.com/tisnik/ocaml-examples/tree/master/article_02/two_same_records.ml</a></td></tr>
<tr><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td></tr>
<tr><td>33</td><td>article_03/recursion1.ml</td><td>pokus o deklaraci funkce s&nbsp;přímou rekurzí založený na <strong>let</strong></td><td><a href="https://github.com/tisnik/ocaml-examples/tree/master/article_03/recursion1.ml">https://github.com/tisnik/ocaml-examples/tree/master/article_03/recursion1.ml</a></td></tr>
<tr><td>34</td><td>article_03/recursion2.ml</td><td>deklarace funkce s&nbsp;přímou rekurzí založená na <strong>let rec</strong></td><td><a href="https://github.com/tisnik/ocaml-examples/tree/master/article_03/recursion2.ml">https://github.com/tisnik/ocaml-examples/tree/master/article_03/recursion2.ml</a></td></tr>
<tr><td>35</td><td>article_03/recursion3.ml</td><td>využití tail rekurze pro výpočet členu Fibonacciho posloupnosti</td><td><a href="https://github.com/tisnik/ocaml-examples/tree/master/article_03/recursion3.ml">https://github.com/tisnik/ocaml-examples/tree/master/article_03/recursion3.ml</a></td></tr>
<tr><td>36</td><td>article_03/recursion4.ml</td><td>obyčejná nerekurzivní funkce definovaná přes <strong>let rec</strong></td><td><a href="https://github.com/tisnik/ocaml-examples/tree/master/article_03/recursion4.ml">https://github.com/tisnik/ocaml-examples/tree/master/article_03/recursion4.ml</a></td></tr>
<tr><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td></tr>
<tr><td>37</td><td>article_03/odd_even_1.ml</td><td>nepřímá rekurze (nekorektní varianta)</td><td><a href="https://github.com/tisnik/ocaml-examples/tree/master/article_03/odd_even_1.ml">https://github.com/tisnik/ocaml-examples/tree/master/article_03/odd_even_1.ml</a></td></tr>
<tr><td>38</td><td>article_03/odd_even_2.ml</td><td>nepřímá rekurze (taktéž nekorektní varianta)</td><td><a href="https://github.com/tisnik/ocaml-examples/tree/master/article_03/odd_even_2.ml">https://github.com/tisnik/ocaml-examples/tree/master/article_03/odd_even_2.ml</a></td></tr>
<tr><td>39</td><td>article_03/odd_even_3.ml</td><td>jediný korektní zápis nepřímé rekurze</td><td><a href="https://github.com/tisnik/ocaml-examples/tree/master/article_03/odd_even_3.ml">https://github.com/tisnik/ocaml-examples/tree/master/article_03/odd_even_3.ml</a></td></tr>
<tr><td>40</td><td>article_03/odd_even_4.ml</td><td>nepřímá rekurze bez použití klíčového slova <strong>rec</strong></td><td><a href="https://github.com/tisnik/ocaml-examples/tree/master/article_03/odd_even_4.ml">https://github.com/tisnik/ocaml-examples/tree/master/article_03/odd_even_4.ml</a></td></tr>
<tr><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td></tr>
<tr><td>41</td><td>article_03/pattern1.ml</td><td>výpočet Faktoriálu založený na pattern matchingu</td><td><a href="https://github.com/tisnik/ocaml-examples/tree/master/article_03/pattern1.ml">https://github.com/tisnik/ocaml-examples/tree/master/article_03/pattern1.ml</a></td></tr>
<tr><td>42</td><td>article_03/pattern2.ml</td><td>výpočet Faktoriálu založený na pattern matchingu, sloučení vstupů se stejným výstupem</td><td><a href="https://github.com/tisnik/ocaml-examples/tree/master/article_03/pattern2.ml">https://github.com/tisnik/ocaml-examples/tree/master/article_03/pattern2.ml</a></td></tr>
<tr><td>43</td><td>article_03/pattern3.ml</td><td>kontrola neplatného vstupu</td><td><a href="https://github.com/tisnik/ocaml-examples/tree/master/article_03/pattern3.ml">https://github.com/tisnik/ocaml-examples/tree/master/article_03/pattern3.ml</a></td></tr>
<tr><td>44</td><td>article_03/pattern4.ml</td><td>pattern matching pro větší množství hodnot</td><td><a href="https://github.com/tisnik/ocaml-examples/tree/master/article_03/pattern4.ml">https://github.com/tisnik/ocaml-examples/tree/master/article_03/pattern4.ml</a></td></tr>
<tr><td>45</td><td>article_03/pattern5.ml</td><td>rekurzivní implementace Ackermannovy funkce</td><td><a href="https://github.com/tisnik/ocaml-examples/tree/master/article_03/pattern5.ml">https://github.com/tisnik/ocaml-examples/tree/master/article_03/pattern5.ml</a></td></tr>
<tr><td>46</td><td>article_03/pattern6.ml</td><td>kontrola neplatných vstupních hodnot pro Ackermannovu funkci</td><td><a href="https://github.com/tisnik/ocaml-examples/tree/master/article_03/pattern6.ml">https://github.com/tisnik/ocaml-examples/tree/master/article_03/pattern6.ml</a></td></tr>
<tr><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td></tr>
<tr><td>47</td><td>article_03/fibonacci1.ml</td><td>výpočet Fibonacciho posloupnosti založený na pattern matchingu</td><td><a href="https://github.com/tisnik/ocaml-examples/tree/master/article_03/fibonacci1.ml">https://github.com/tisnik/ocaml-examples/tree/master/article_03/fibonacci1.ml</a></td></tr>
<tr><td>48</td><td>article_03/fibonacci2.ml</td><td>výpočet Fibonacciho posloupnosti založený na pattern matchingu (více idiomatický zápis)</td><td><a href="https://github.com/tisnik/ocaml-examples/tree/master/article_03/fibonacci2.ml">https://github.com/tisnik/ocaml-examples/tree/master/article_03/fibonacci2.ml</a></td></tr>
<tr><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td></tr>
<tr><td>49</td><td>article_03/first.ml</td><td>funkce vracející první prvek z&nbsp;dvojice založená na pattern matchingu</td><td><a href="https://github.com/tisnik/ocaml-examples/tree/master/article_03/first.ml">https://github.com/tisnik/ocaml-examples/tree/master/article_03/first.ml</a></td></tr>
<tr><td>50</td><td>article_03/second.ml</td><td>funkce vracející druhý prvek z&nbsp;dvojice založená na pattern matchingu</td><td><a href="https://github.com/tisnik/ocaml-examples/tree/master/article_03/second.ml">https://github.com/tisnik/ocaml-examples/tree/master/article_03/second.ml</a></td></tr>
<tr><td>51</td><td>article_03/zero_coordinate.ml</td><td>test na nulovou souřadnici/souřadnice založený na pattern matchingu</td><td><a href="https://github.com/tisnik/ocaml-examples/tree/master/article_03/zero_coordinate.ml">https://github.com/tisnik/ocaml-examples/tree/master/article_03/zero_coordinate.ml</a></td></tr>
<tr><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td></tr>
<tr><td>52</td><td>article_03/get_model.ml</td><td>získání prvku ze záznamu (opět založeno na pattern matchingu)</td><td><a href="https://github.com/tisnik/ocaml-examples/tree/master/article_03/get_model.ml">https://github.com/tisnik/ocaml-examples/tree/master/article_03/get_model.ml</a></td></tr>
<tr><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td></tr>
<tr><td>53</td><td>article_03/list_literal_1.ml</td><td>seznam se třemi prvky typu celé číslo</td><td><a href="https://github.com/tisnik/ocaml-examples/tree/master/article_03/list_literal_1.ml">https://github.com/tisnik/ocaml-examples/tree/master/article_03/list_literal_1.ml</a></td></tr>
<tr><td>54</td><td>article_03/list_literal_2.ml</td><td>seznam se třemi prvky typu řetězec</td><td><a href="https://github.com/tisnik/ocaml-examples/tree/master/article_03/list_literal_2.ml">https://github.com/tisnik/ocaml-examples/tree/master/article_03/list_literal_2.ml</a></td></tr>
<tr><td>55</td><td>article_03/list_literal_3.ml</td><td>seznam se třemi prvky typu n-tice</td><td><a href="https://github.com/tisnik/ocaml-examples/tree/master/article_03/list_literal_3.ml">https://github.com/tisnik/ocaml-examples/tree/master/article_03/list_literal_3.ml</a></td></tr>
<tr><td>56</td><td>article_03/list_literal_4.ml</td><td>nekorektní pokus o vytvoření seznamu s&nbsp;prvky různých typů</td><td><a href="https://github.com/tisnik/ocaml-examples/tree/master/article_03/list_literal_4.ml">https://github.com/tisnik/ocaml-examples/tree/master/article_03/list_literal_4.ml</a></td></tr>
<tr><td>57</td><td>article_03/empty_list.ml</td><td>konstrukce prázdného seznamu</td><td><a href="https://github.com/tisnik/ocaml-examples/tree/master/article_03/empty_list.ml">https://github.com/tisnik/ocaml-examples/tree/master/article_03/empty_list.ml</a></td></tr>
<tr><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td></tr>
<tr><td>58</td><td>article_03/head_tail_1.ml</td><td>složení seznamu se dvěma prvky s&nbsp;využitím operátoru <strong>::</strong></td><td><a href="https://github.com/tisnik/ocaml-examples/tree/master/article_03/head_tail_1.ml">https://github.com/tisnik/ocaml-examples/tree/master/article_03/head_tail_1.ml</a></td></tr>
<tr><td>59</td><td>article_03/head_tail_2.ml</td><td>složení seznamu se třemi prvky s&nbsp;využitím operátoru <strong>::</strong></td><td><a href="https://github.com/tisnik/ocaml-examples/tree/master/article_03/head_tail_2.ml">https://github.com/tisnik/ocaml-examples/tree/master/article_03/head_tail_2.ml</a></td></tr>
<tr><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td></tr>
<tr><td>60</td><td>article_03/list_properties.ml</td><td>vlastnosti (<i>properties</i>) seznamů</td><td><a href="https://github.com/tisnik/ocaml-examples/tree/master/article_03/list_properties.ml">https://github.com/tisnik/ocaml-examples/tree/master/article_03/list_properties.ml</a></td></tr>
<tr><td>61</td><td>article_03/len_1.ml</td><td>naivní rekurzivní výpočet délky seznamu</td><td><a href="https://github.com/tisnik/ocaml-examples/tree/master/article_03/len_1.ml">https://github.com/tisnik/ocaml-examples/tree/master/article_03/len_1.ml</a></td></tr>
<tr><td>62</td><td>article_03/len_2.ml</td><td>vylepšený rekurzivní výpočet délky seznamu</td><td><a href="https://github.com/tisnik/ocaml-examples/tree/master/article_03/len_2.ml">https://github.com/tisnik/ocaml-examples/tree/master/article_03/len_2.ml</a></td></tr>
<tr><td>63</td><td>article_03/len_3.ml</td><td>vylepšený rekurzivní výpočet délky seznamu</td><td><a href="https://github.com/tisnik/ocaml-examples/tree/master/article_03/len_3.ml">https://github.com/tisnik/ocaml-examples/tree/master/article_03/len_3.ml</a></td></tr>
<tr><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td></tr>
<tr><td>64</td><td>article_03/join_lists.ml</td><td>spojení dvou seznamů operátorem <strong>::</strong></td><td><a href="https://github.com/tisnik/ocaml-examples/tree/master/article_03/join_lists.ml">https://github.com/tisnik/ocaml-examples/tree/master/article_03/join_lists.ml</a></td></tr>
<tr><td>65</td><td>article_03/append_1.ml</td><td>implementace spojení dvou seznamů rekurzivním výpočtem</td><td><a href="https://github.com/tisnik/ocaml-examples/tree/master/article_03/append_1.ml">https://github.com/tisnik/ocaml-examples/tree/master/article_03/append_1.ml</a></td></tr>
<tr><td>66</td><td>article_03/append_2.ml</td><td>implementace spojení dvou seznamů rekurzivním výpočtem, použití pattern matchingu</td><td><a href="https://github.com/tisnik/ocaml-examples/tree/master/article_03/append_2.ml">https://github.com/tisnik/ocaml-examples/tree/master/article_03/append_2.ml</a></td></tr>
<tr><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td></tr>
<tr><td>67</td><td>article_03/sum_1.ml</td><td>součet hodnot všech prvků v&nbsp;seznamu (bez tail rekurze)</td><td><a href="https://github.com/tisnik/ocaml-examples/tree/master/article_03/sum_1.ml">https://github.com/tisnik/ocaml-examples/tree/master/article_03/sum_1.ml</a></td></tr>
<tr><td>68</td><td>article_03/sum_2.ml</td><td>součet hodnot všech prvků v&nbsp;seznamu (s&nbsp;využitím tail rekurze)</td><td><a href="https://github.com/tisnik/ocaml-examples/tree/master/article_03/sum_2.ml">https://github.com/tisnik/ocaml-examples/tree/master/article_03/sum_2.ml</a></td></tr>
<tr><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td></tr>
<tr><td>69</td><td>article_03/print_int_list.ml</td><td>tisk seznamu celých čísel</td><td><a href="https://github.com/tisnik/ocaml-examples/tree/master/article_03/print_int_list.ml">https://github.com/tisnik/ocaml-examples/tree/master/article_03/print_int_list.ml</a></td></tr>
<tr><td>70</td><td>article_03/print_string_list.ml</td><td>tisk seznamu řetězců</td><td><a href="https://github.com/tisnik/ocaml-examples/tree/master/article_03/print_string_list.ml">https://github.com/tisnik/ocaml-examples/tree/master/article_03/print_string_list.ml</a></td></tr>
<tr><td>71</td><td>article_03/print_list_prefix.ml</td><td>tisk seznamu s&nbsp;prefixem</td><td><a href="https://github.com/tisnik/ocaml-examples/tree/master/article_03/print_list_prefix.ml">https://github.com/tisnik/ocaml-examples/tree/master/article_03/print_list_prefix.ml</a></td></tr>
<tr><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td></tr>
<tr><td>72</td><td>article_04/none_value.ml</td><td>hodnota <strong>None</strong></td><td><a href="https://github.com/tisnik/ocaml-examples/tree/master/article_04/none_value.ml">https://github.com/tisnik/ocaml-examples/tree/master/article_04/none_value.ml</a></td></tr>
<tr><td>73</td><td>article_04/some_value1.ml</td><td>hodnota <strong>Some(typ)</strong></td><td><a href="https://github.com/tisnik/ocaml-examples/tree/master/article_04/some_value1.ml">https://github.com/tisnik/ocaml-examples/tree/master/article_04/some_value1.ml</a></td></tr>
<tr><td>74</td><td>article_04/some_value2.ml</td><td>hodnota <strong>Some(typ)</strong></td><td><a href="https://github.com/tisnik/ocaml-examples/tree/master/article_04/some_value2.ml">https://github.com/tisnik/ocaml-examples/tree/master/article_04/some_value2.ml</a></td></tr>
<tr><td>75</td><td>article_04/some_value3.ml</td><td>hodnota <strong>Some(typ)</strong></td><td><a href="https://github.com/tisnik/ocaml-examples/tree/master/article_04/some_value3.ml">https://github.com/tisnik/ocaml-examples/tree/master/article_04/some_value3.ml</a></td></tr>
<tr><td>76</td><td>article_04/option_exists1.ml</td><td>základní pattern matching, korektní varianta</td><td><a href="https://github.com/tisnik/ocaml-examples/tree/master/article_04/option_exists1.ml">https://github.com/tisnik/ocaml-examples/tree/master/article_04/option_exists1.ml</a></td></tr>
<tr><td>77</td><td>article_04/option_exists2.ml</td><td>základní pattern matching, nekorektní varianta</td><td><a href="https://github.com/tisnik/ocaml-examples/tree/master/article_04/option_exists2.ml">https://github.com/tisnik/ocaml-examples/tree/master/article_04/option_exists2.ml</a></td></tr>
<tr><td>78</td><td>article_04/option_exists3.ml</td><td>základní pattern matching, nekorektní varianta</td><td><a href="https://github.com/tisnik/ocaml-examples/tree/master/article_04/option_exists3.ml">https://github.com/tisnik/ocaml-examples/tree/master/article_04/option_exists3.ml</a></td></tr>
<tr><td>79</td><td>article_04/find_in_list1.ml</td><td>vyhledávání prvku v&nbsp;seznamu založené na pattern matchingu</td><td><a href="https://github.com/tisnik/ocaml-examples/tree/master/article_04/find_in_list1.ml">https://github.com/tisnik/ocaml-examples/tree/master/article_04/find_in_list1.ml</a></td></tr>
<tr><td>80</td><td>article_04/find_in_list2.ml</td><td>varianta předchozího programu</td><td><a href="https://github.com/tisnik/ocaml-examples/tree/master/article_04/find_in_list2.ml">https://github.com/tisnik/ocaml-examples/tree/master/article_04/find_in_list2.ml</a></td></tr>
<tr><td>81</td><td>article_04/option_get.ml</td><td>pokus o přečtení hodnoty obalené typem <strong>Option</strong></td><td><a href="https://github.com/tisnik/ocaml-examples/tree/master/article_04/option_get.ml">https://github.com/tisnik/ocaml-examples/tree/master/article_04/option_get.ml</a></td></tr>
<tr><td>82</td><td>article_04/is_none_is_some.ml</td><td>predikáty <strong>is_none</strong> a <strong>is_some</strong></td><td><a href="https://github.com/tisnik/ocaml-examples/tree/master/article_04/is_none_is_some.ml">https://github.com/tisnik/ocaml-examples/tree/master/article_04/is_none_is_some.ml</a></td></tr>
<tr><td>83</td><td>article_04/option_equal.ml</td><td>ekvivalence dvou obalených hodnot</td><td><a href="https://github.com/tisnik/ocaml-examples/tree/master/article_04/option_equal.ml">https://github.com/tisnik/ocaml-examples/tree/master/article_04/option_equal.ml</a></td></tr>
<tr><td>84</td><td>article_04/some_none.ml</td><td>obalení obalené hodnoty</td><td><a href="https://github.com/tisnik/ocaml-examples/tree/master/article_04/some_none.ml">https://github.com/tisnik/ocaml-examples/tree/master/article_04/some_none.ml</a></td></tr>
<tr><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td></tr>
<tr><td>85</td><td>article_04/result_divide1.ml</td><td>ukázka použití datového typu <strong>Result</strong></td><td><a href="https://github.com/tisnik/ocaml-examples/tree/master/article_04/result_divide1.ml">https://github.com/tisnik/ocaml-examples/tree/master/article_04/result_divide1.ml</a></td></tr>
<tr><td>86</td><td>article_04/result_divide2.ml</td><td>ukázka použití datového typu <strong>Result</strong> a pattern matchingu</td><td><a href="https://github.com/tisnik/ocaml-examples/tree/master/article_04/result_divide2.ml">https://github.com/tisnik/ocaml-examples/tree/master/article_04/result_divide2.ml</a></td></tr>
<tr><td>87</td><td>article_04/result_divide3.ml</td><td>stejné jako result_divide1.fs, ovšem bez explicitního zápisu typů</td><td><a href="https://github.com/tisnik/ocaml-examples/tree/master/article_04/result_divide3.ml">https://github.com/tisnik/ocaml-examples/tree/master/article_04/result_divide3.ml</a></td></tr>
<tr><td>88</td><td>article_04/result_divide4.ml</td><td>stejné jako result_divide2.fs, ovšem bez explicitního zápisu typů</td><td><a href="https://github.com/tisnik/ocaml-examples/tree/master/article_04/result_divide4.ml">https://github.com/tisnik/ocaml-examples/tree/master/article_04/result_divide4.ml</a></td></tr>
<tr><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td></tr>
<tr><td>89</td><td>article_04/array_value.ml</td><td>deklarace pole výčtem jeho prvků</td><td><a href="https://github.com/tisnik/ocaml-examples/tree/master/article_04/array_value.ml">https://github.com/tisnik/ocaml-examples/tree/master/article_04/array_value.ml</a></td></tr>
<tr><td>90</td><td>article_04/array_make.ml</td><td>funkce <strong>Array.make</strong> pro konstrukci pole</td><td><a href="https://github.com/tisnik/ocaml-examples/tree/master/article_04/array_make.ml">https://github.com/tisnik/ocaml-examples/tree/master/article_04/array_make.ml</a></td></tr>
<tr><td>91</td><td>article_04/array_init1.ml</td><td>inicializace prvků pole funkcí <strong>Array.init</strong></td><td><a href="https://github.com/tisnik/ocaml-examples/tree/master/article_04/array_init1.ml">https://github.com/tisnik/ocaml-examples/tree/master/article_04/array_init1.ml</a></td></tr>
<tr><td>92</td><td>article_04/array_init2.ml</td><td>inicializace prvků pole funkcí <strong>Array.init</strong></td><td><a href="https://github.com/tisnik/ocaml-examples/tree/master/article_04/array_init2.ml">https://github.com/tisnik/ocaml-examples/tree/master/article_04/array_init2.ml</a></td></tr>
<tr><td>93</td><td>article_04/array_init3.ml</td><td>inicializace prvků pole funkcí <strong>Array.init</strong></td><td><a href="https://github.com/tisnik/ocaml-examples/tree/master/article_04/array_init3.ml">https://github.com/tisnik/ocaml-examples/tree/master/article_04/array_init3.ml</a></td></tr>
<tr><td>94</td><td>article_04/array_indexing.ml</td><td>indexování prvků pole</td><td><a href="https://github.com/tisnik/ocaml-examples/tree/master/article_04/array_indexing.ml">https://github.com/tisnik/ocaml-examples/tree/master/article_04/array_indexing.ml</a></td></tr>
<tr><td>95</td><td>article_04/array_mutation.ml</td><td>mutace pole: modifikace hodnot jeho prvků</td><td><a href="https://github.com/tisnik/ocaml-examples/tree/master/article_04/array_mutation.ml">https://github.com/tisnik/ocaml-examples/tree/master/article_04/array_mutation.ml</a></td></tr>
<tr><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td></tr>
<tr><td>96</td><td>article_04/option_no_bind.ml</td><td>zřetězení volání funkcí, které si předávají hodnoty typu <strong>Option</strong> &ndash; neidiomatické řešení</td><td><a href="https://github.com/tisnik/ocaml-examples/tree/master/article_04/option_no_bind.ml">https://github.com/tisnik/ocaml-examples/tree/master/article_04/option_no_bind.ml</a></td></tr>
<tr><td>97</td><td>article_04/option_bind.ml</td><td>řešení založené na <strong>bind</strong></td><td><a href="https://github.com/tisnik/ocaml-examples/tree/master/article_04/option_bind.ml">https://github.com/tisnik/ocaml-examples/tree/master/article_04/option_bind.ml</a></td></tr>
<tr><td>98</td><td>article_04/bind_infix_operator.ml</td><td>funkce <strong>Option.bind</strong> zapsaná formou infixového operátoru</td><td><a href="https://github.com/tisnik/ocaml-examples/tree/master/article_04/bind_infix_operator.ml">https://github.com/tisnik/ocaml-examples/tree/master/article_04/bind_infix_operator.ml</a></td></tr>
<tr><td>99</td><td>article_04/bind_infix_operator_2.ml</td><td>zřetězení funkcí s&nbsp;využitím <strong>Result.bind</strong></td><td><a href="https://github.com/tisnik/ocaml-examples/tree/master/article_04/bind_infix_operator_2.ml">https://github.com/tisnik/ocaml-examples/tree/master/article_04/bind_infix_operator_2.ml</a></td></tr>
<tr><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td></tr>
<tr><td>100</td><td>article_05/unary_arithmetic.ml</td><td>unární aritmetické operátory</td><td><a href="https://github.com/tisnik/ocaml-examples/tree/master/article_05/unary_arithmetic.ml">https://github.com/tisnik/ocaml-examples/tree/master/article_05/unary_arithmetic.ml</a></td></tr>
<tr><td>101</td><td>article_05/binary_arithmetic.ml</td><td>binární aritmetické operátory</td><td><a href="https://github.com/tisnik/ocaml-examples/tree/master/article_05/binary_arithmetic.ml">https://github.com/tisnik/ocaml-examples/tree/master/article_05/binary_arithmetic.ml</a></td></tr>
<tr><td>102</td><td>article_05/boolean_operators.ml</td><td>booleovské operátory</td><td><a href="https://github.com/tisnik/ocaml-examples/tree/master/article_05/boolean_operators.ml">https://github.com/tisnik/ocaml-examples/tree/master/article_05/boolean_operators.ml</a></td></tr>
<tr><td>103</td><td>article_05/relational.ml</td><td>základní čtveřice relačních operátorů</td><td><a href="https://github.com/tisnik/ocaml-examples/tree/master/article_05/relational.ml">https://github.com/tisnik/ocaml-examples/tree/master/article_05/relational.ml</a></td></tr>
<tr><td>104</td><td>article_05/equality.ml</td><td>operátory zjišťující ekvivalenci hodnot</td><td><a href="https://github.com/tisnik/ocaml-examples/tree/master/article_05/equality.ml">https://github.com/tisnik/ocaml-examples/tree/master/article_05/equality.ml</a></td></tr>
<tr><td>105</td><td>article_05/joins.ml</td><td>operátory pro spojení řetězců a seznamů</td><td><a href="https://github.com/tisnik/ocaml-examples/tree/master/article_05/joins.ml">https://github.com/tisnik/ocaml-examples/tree/master/article_05/joins.ml</a></td></tr>
<tr><td>106</td><td>article_05/references.ml</td><td>operátory pro práci s&nbsp;referencemi</td><td><a href="https://github.com/tisnik/ocaml-examples/tree/master/article_05/references.ml">https://github.com/tisnik/ocaml-examples/tree/master/article_05/references.ml</a></td></tr>
<tr><td>107</td><td>article_05/function_operators.ml</td><td>operátory pro aplikaci funkcí</td><td><a href="https://github.com/tisnik/ocaml-examples/tree/master/article_05/function_operators.ml">https://github.com/tisnik/ocaml-examples/tree/master/article_05/function_operators.ml</a></td></tr>
<tr><td>108</td><td>article_05/conwoy.ml</td><td>konvoj vytvořený operátorem |&gt;</td><td><a href="https://github.com/tisnik/ocaml-examples/tree/master/article_05/conwoy.ml">https://github.com/tisnik/ocaml-examples/tree/master/article_05/conwoy.ml</a></td></tr>
<tr><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td></tr>
<tr><td>109</td><td>article_05/usage_unary_arithmetic.ml</td><td>test unárních operátorů</td><td><a href="https://github.com/tisnik/ocaml-examples/tree/master/article_05/usage_unary_arithmetic.ml">https://github.com/tisnik/ocaml-examples/tree/master/article_05/usage_unary_arithmetic.ml</a></td></tr>
<tr><td>110</td><td>article_05/usage_binary_arithmetic.ml</td><td>test binárních operátorů</td><td><a href="https://github.com/tisnik/ocaml-examples/tree/master/article_05/usage_binary_arithmetic.ml">https://github.com/tisnik/ocaml-examples/tree/master/article_05/usage_binary_arithmetic.ml</a></td></tr>
<tr><td>111</td><td>article_05/usage_boolean.ml</td><td>test booleovských operátorů</td><td><a href="https://github.com/tisnik/ocaml-examples/tree/master/article_05/usage_boolean.ml">https://github.com/tisnik/ocaml-examples/tree/master/article_05/usage_boolean.ml</a></td></tr>
<tr><td>112</td><td>article_05/usage_relational.ml</td><td>test relačních operátorů vůči různým hodnotám</td><td><a href="https://github.com/tisnik/ocaml-examples/tree/master/article_05/usage_relational.ml">https://github.com/tisnik/ocaml-examples/tree/master/article_05/usage_relational.ml</a></td></tr>
<tr><td>113</td><td>article_05/usage_relational_tuples.ml</td><td>test relačních operátorů vůči n-ticím</td><td><a href="https://github.com/tisnik/ocaml-examples/tree/master/article_05/usage_relational_tuples.ml">https://github.com/tisnik/ocaml-examples/tree/master/article_05/usage_relational_tuples.ml</a></td></tr>
<tr><td>114</td><td>article_05/usage_equality.ml</td><td>testy na strukturální a fyzickou rovnost</td><td><a href="https://github.com/tisnik/ocaml-examples/tree/master/article_05/usage_equality.ml">https://github.com/tisnik/ocaml-examples/tree/master/article_05/usage_equality.ml</a></td></tr>
<tr><td>115</td><td>article_05/usage_joins.ml</td><td>testy operátorů pro spojení řetězců a seznamů</td><td><a href="https://github.com/tisnik/ocaml-examples/tree/master/article_05/usage_joins.ml">https://github.com/tisnik/ocaml-examples/tree/master/article_05/usage_joins.ml</a></td></tr>
<tr><td>116</td><td>article_05/usage_function.ml</td><td>testy operátorů pro aplikaci funkcí</td><td><a href="https://github.com/tisnik/ocaml-examples/tree/master/article_05/usage_function.ml">https://github.com/tisnik/ocaml-examples/tree/master/article_05/usage_function.ml</a></td></tr>
<tr><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td></tr>
<tr><td>117</td><td>article_05/operator_unary_1.ml</td><td>vlastní unární operátor</td><td><a href="https://github.com/tisnik/ocaml-examples/tree/master/article_05/operator_unary_1.ml">https://github.com/tisnik/ocaml-examples/tree/master/article_05/operator_unary_1.ml</a></td></tr>
<tr><td>118</td><td>article_05/operator_unary_2.ml</td><td>vlastní unární operátory</td><td><a href="https://github.com/tisnik/ocaml-examples/tree/master/article_05/operator_unary_2.ml">https://github.com/tisnik/ocaml-examples/tree/master/article_05/operator_unary_2.ml</a></td></tr>
<tr><td>119</td><td>article_05/operator_binary_1.ml</td><td>vlastní binární operátor s&nbsp;asociativitou zleva</td><td><a href="https://github.com/tisnik/ocaml-examples/tree/master/article_05/operator_binary_1.ml">https://github.com/tisnik/ocaml-examples/tree/master/article_05/operator_binary_1.ml</a></td></tr>
<tr><td>120</td><td>article_05/operator_binary_2.ml</td><td>vlastní binární operátor s&nbsp;asociativitou zprava</td><td><a href="https://github.com/tisnik/ocaml-examples/tree/master/article_05/operator_binary_2.ml">https://github.com/tisnik/ocaml-examples/tree/master/article_05/operator_binary_2.ml</a></td></tr>
<tr><td>121</td><td>article_05/operator_binary_3.ml</td><td>vlastní binární operátory s&nbsp;rozdílnou prioritou</td><td><a href="https://github.com/tisnik/ocaml-examples/tree/master/article_05/operator_binary_3.ml">https://github.com/tisnik/ocaml-examples/tree/master/article_05/operator_binary_3.ml</a></td></tr>
<tr><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td></tr>
<tr><td>122</td><td>article_06/circle_rectangle_1.ml</td><td>datový typ přestavující buď kružnici nebo obdélník</td><td><a href="https://github.com/tisnik/ocaml-examples/tree/master/article_06/circle_rectangle_1.ml">https://github.com/tisnik/ocaml-examples/tree/master/article_06/circle_rectangle_1.ml</a></td></tr>
<tr><td>123</td><td>article_06/circle_rectangle_2.ml</td><td>datový typ přestavující buď kružnici nebo obdélník</td><td><a href="https://github.com/tisnik/ocaml-examples/tree/master/article_06/circle_rectangle_2.ml">https://github.com/tisnik/ocaml-examples/tree/master/article_06/circle_rectangle_2.ml</a></td></tr>
<tr><td>124</td><td>article_06/enum_1.ml</td><td>příklad použití datového typu <i>výčet</i></td><td><a href="https://github.com/tisnik/ocaml-examples/tree/master/article_06/enum_1.ml">https://github.com/tisnik/ocaml-examples/tree/master/article_06/enum_1.ml</a></td></tr>
<tr><td>125</td><td>article_06/enum_2.ml</td><td>příklad použití datového typu <i>výčet</i></td><td><a href="https://github.com/tisnik/ocaml-examples/tree/master/article_06/enum_2.ml">https://github.com/tisnik/ocaml-examples/tree/master/article_06/enum_2.ml</a></td></tr>
<tr><td>126</td><td>article_06/expr.ml</td><td>datový typ představující rekurzivní definici výrazu (<i>expression</i>)</td><td><a href="https://github.com/tisnik/ocaml-examples/tree/master/article_06/expr.ml">https://github.com/tisnik/ocaml-examples/tree/master/article_06/expr.ml</a></td></tr>
<tr><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td></tr>
<tr><td>127</td><td>article_06/object_1.ml</td><td>jednoduchá třída s&nbsp;dvojicí atributů</td><td><a href="https://github.com/tisnik/ocaml-examples/tree/master/article_06/object_1.ml">https://github.com/tisnik/ocaml-examples/tree/master/article_06/object_1.ml</a></td></tr>
<tr><td>128</td><td>article_06/object_2.ml</td><td>přidání metody do třídy</td><td><a href="https://github.com/tisnik/ocaml-examples/tree/master/article_06/object_2.ml">https://github.com/tisnik/ocaml-examples/tree/master/article_06/object_2.ml</a></td></tr>
<tr><td>129</td><td>article_06/object_3.ml</td><td>metoda vytvářející nový objekt</td><td><a href="https://github.com/tisnik/ocaml-examples/tree/master/article_06/object_3.ml">https://github.com/tisnik/ocaml-examples/tree/master/article_06/object_3.ml</a></td></tr>
<tr><td>130</td><td>article_06/object_4.ml</td><td>doplnění předchozí třídy o přetížený operátor +</td><td><a href="https://github.com/tisnik/ocaml-examples/tree/master/article_06/object_4.ml">https://github.com/tisnik/ocaml-examples/tree/master/article_06/object_4.ml</a></td></tr>
<tr><td>131</td><td>article_06/object_5.ml</td><td>doplnění předchozí třídy o přetížený operátor + s&nbsp;automatickým odvozením typu</td><td><a href="https://github.com/tisnik/ocaml-examples/tree/master/article_06/object_5.ml">https://github.com/tisnik/ocaml-examples/tree/master/article_06/object_5.ml</a></td></tr>
<tr><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td></tr>
<tr><td>132</td><td>article_06/rectangle_1.ml</td><td>typ Rectangle založený na n-tici</td><td><a href="https://github.com/tisnik/ocaml-examples/tree/master/article_06/rectangle_1.ml">https://github.com/tisnik/ocaml-examples/tree/master/article_06/rectangle_1.ml</a></td></tr>
<tr><td>133</td><td>article_06/rectangle_2.ml</td><td>úprava předchozího příkladu; pattern matching</td><td><a href="https://github.com/tisnik/ocaml-examples/tree/master/article_06/rectangle_2.ml">https://github.com/tisnik/ocaml-examples/tree/master/article_06/rectangle_2.ml</a></td></tr>
<tr><td>134</td><td>article_06/rectangle_3.ml</td><td>úprava předchozího příkladu, explicitní pojmenování</td><td><a href="https://github.com/tisnik/ocaml-examples/tree/master/article_06/rectangle_3.ml">https://github.com/tisnik/ocaml-examples/tree/master/article_06/rectangle_3.ml</a></td></tr>
<tr><td>135</td><td>article_06/rectangle_4.ml</td><td>různé jmenné prostory</td><td><a href="https://github.com/tisnik/ocaml-examples/tree/master/article_06/rectangle_4.ml">https://github.com/tisnik/ocaml-examples/tree/master/article_06/rectangle_4.ml</a></td></tr>
<tr><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td></tr>
<tr><td>136</td><td>article_06/struct_type_1.ml</td><td>definice záznamu (record, struct)</td><td><a href="https://github.com/tisnik/ocaml-examples/tree/master/article_06/struct_type_1.ml">https://github.com/tisnik/ocaml-examples/tree/master/article_06/struct_type_1.ml</a></td></tr>
<tr><td>137</td><td>article_06/struct_type_2.ml</td><td>rozšíření o funkci pro tisk záznamu</td><td><a href="https://github.com/tisnik/ocaml-examples/tree/master/article_06/struct_type_2.ml">https://github.com/tisnik/ocaml-examples/tree/master/article_06/struct_type_2.ml</a></td></tr>
<tr><td>138</td><td>article_06/struct_type_3.ml</td><td>automatické odvození datového typu parametru funkce</td><td><a href="https://github.com/tisnik/ocaml-examples/tree/master/article_06/struct_type_3.ml">https://github.com/tisnik/ocaml-examples/tree/master/article_06/struct_type_3.ml</a></td></tr>
<tr><td>139</td><td>article_06/struct_type_4.ml</td><td>otestování mezí automatického odvozování typů parametrů (nefunkční varianta)</td><td><a href="https://github.com/tisnik/ocaml-examples/tree/master/article_06/struct_type_4.ml">https://github.com/tisnik/ocaml-examples/tree/master/article_06/struct_type_4.ml</a></td></tr>
<tr><td>140</td><td>article_06/struct_type_5.ml</td><td>otestování mezí automatického odvozování typů parametrů (funkční varianta)</td><td><a href="https://github.com/tisnik/ocaml-examples/tree/master/article_06/struct_type_5.ml">https://github.com/tisnik/ocaml-examples/tree/master/article_06/struct_type_5.ml</a></td></tr>
<tr><td>141</td><td>article_06/tree.ml</td><td>datový typ představující rekurzivní definici binárního stromu</td><td><a href="https://github.com/tisnik/ocaml-examples/tree/master/article_06/tree.ml">https://github.com/tisnik/ocaml-examples/tree/master/article_06/tree.ml</a></td></tr>
</table>



<p><a name="k19"></a></p>
<h2 id="k19">19. Odkazy na Internetu</h2>

<ol>

<li>General-Purpose, Industrial-Strength, Expressive, and Safe<br />
<a href="https://ocaml.org/">https://ocaml.org/</a>
</li>

<li>OCaml playground<br />
<a href="https://ocaml.org/play">https://ocaml.org/play</a>
</li>

<li>Online Ocaml Compiler IDE<br />
<a href="https://www.jdoodle.com/compile-ocaml-online/">https://www.jdoodle.com/compile-ocaml-online/</a>
</li>

<li>Get Started - OCaml<br />
<a href="https://www.ocaml.org/docs">https://www.ocaml.org/docs</a>
</li>

<li>Get Up and Running With OCaml<br />
<a href="https://www.ocaml.org/docs/up-and-running">https://www.ocaml.org/docs/up-and-running</a>
</li>

<li>Better OCaml (Online prostředí)<br />
<a href="https://betterocaml.ml/?version=4.14.0">https://betterocaml.ml/?version=4.14.0</a>
</li>

<li>OCaml file extensions<br />
<a href="https://blog.waleedkhan.name/ocaml-file-extensions/">https://blog.waleedkhan.name/ocaml-file-extensions/</a>
</li>

<li>First thoughts on Rust vs OCaml<br />
<a href="https://blog.darklang.com/first-thoughts-on-rust-vs-ocaml/">https://blog.darklang.com/first-thoughts-on-rust-vs-ocaml/</a>
</li>

<li>Standard ML of New Jersey<br />
<a href="https://www.smlnj.org/">https://www.smlnj.org/</a>
</li>

<li>Programming Languages: Standard ML - 1 (a navazující videa)<br />
<a href="https://www.youtube.com/watch?v=2sqjUWGGzTo">https://www.youtube.com/watch?v=2sqjUWGGzTo</a>
</li>

<li>6 Excellent Free Books to Learn Standard ML<br />
<a href="https://www.linuxlinks.com/excellent-free-books-learn-standard-ml/">https://www.linuxlinks.com/excellent-free-books-learn-standard-ml/</a>
</li>

<li>SOSML: The Online Interpreter for Standard ML<br />
<a href="https://sosml.org/">https://sosml.org/</a>
</li>

<li>ML (Computer program language)<br />
<a href="https://www.barnesandnoble.com/b/books/other-programming-languages/ml-computer-program-language/_/N-29Z8q8Zvy7">https://www.barnesandnoble.com/b/books/other-programming-languages/ml-computer-program-language/_/N-29Z8q8Zvy7</a>
</li>

<li>Strong Typing<br />
<a href="https://perl.plover.com/yak/typing/notes.html">https://perl.plover.com/yak/typing/notes.html</a>
</li>

<li>What to know before debating type systems<br />
<a href="http://blogs.perl.org/users/ovid/2010/08/what-to-know-before-debating-type-systems.html">http://blogs.perl.org/users/ovid/2010/08/what-to-know-before-debating-type-systems.html</a>
</li>

<li>Types, and Why You Should Care (Youtube)<br />
<a href="https://www.youtube.com/watch?v=0arFPIQatCU">https://www.youtube.com/watch?v=0arFPIQatCU</a>
</li>

<li>DynamicTyping (Martin Fowler)<br />
<a href="https://www.martinfowler.com/bliki/DynamicTyping.html">https://www.martinfowler.com/bliki/DynamicTyping.html</a>
</li>

<li>DomainSpecificLanguage (Martin Fowler)<br />
<a href="https://www.martinfowler.com/bliki/DomainSpecificLanguage.html">https://www.martinfowler.com/bliki/DomainSpecificLanguage.html</a>
</li>

<li>Language Workbenches: The Killer-App for Domain Specific Languages?<br />
<a href="https://www.martinfowler.com/articles/languageWorkbench.html">https://www.martinfowler.com/articles/languageWorkbench.html</a>
</li>

<li>Effective ML (Youtube)<br />
<a href="https://www.youtube.com/watch?v=-J8YyfrSwTk">https://www.youtube.com/watch?v=-J8YyfrSwTk</a>
</li>

<li>Why OCaml (Youtube)<br />
<a href="https://www.youtube.com/watch?v=v1CmGbOGb2I">https://www.youtube.com/watch?v=v1CmGbOGb2I</a>
</li>

<li>Try OCaml<br />
<a href="https://try.ocaml.pro/">https://try.ocaml.pro/</a>
</li>

<li>CSE 341: Functions and patterns<br />
<a href="https://courses.cs.washington.edu/courses/cse341/04wi/lectures/03-ml-functions.html">https://courses.cs.washington.edu/courses/cse341/04wi/lectures/03-ml-functions.html</a>
</li>

<li>Comparing Objective Caml and Standard ML<br />
<a href="http://adam.chlipala.net/mlcomp/">http://adam.chlipala.net/mlcomp/</a>
</li>

<li>What are the key differences between Standard ML and OCaml?<br />
<a href="https://www.quora.com/What-are-the-key-differences-between-Standard-ML-and-OCaml?share=1">https://www.quora.com/What-are-the-key-differences-between-Standard-ML-and-OCaml?share=1</a>
</li>

<li>Cheat Sheets (pro OCaml)<br />
<a href="https://www.ocaml.org/docs/cheat_sheets.html">https://www.ocaml.org/docs/cheat_sheets.html</a>
</li>

<li>Think OCaml: How to Think Like a (Functional) Programmer<br />
<a href="https://www.greenteapress.com/thinkocaml/thinkocaml.pdf">https://www.greenteapress.com/thinkocaml/thinkocaml.pdf</a>
</li>

<li>The OCaml Language Cheat Sheet<br />
<a href="https://ocamlpro.github.io/ocaml-cheat-sheets/ocaml-lang.pdf">https://ocamlpro.github.io/ocaml-cheat-sheets/ocaml-lang.pdf</a>
</li>

<li>Syllabus (FAS CS51)<br />
<a href="https://cs51.io/college/syllabus/">https://cs51.io/college/syllabus/</a>
</li>

<li>Abstraction and Design In Computation<br />
<a href="http://book.cs51.io/">http://book.cs51.io/</a>
</li>

<li>Learn X in Y minutes Where X=Standard ML<br />
<a href="https://learnxinyminutes.com/docs/standard-ml/">https://learnxinyminutes.com/docs/standard-ml/</a>
</li>

<li>CSE307 Online - Summer 2018: Principles of Programing Languages course<br />
<a href="https://www3.cs.stonybrook.edu/~pfodor/courses/summer/cse307.html">https://www3.cs.stonybrook.edu/~pfodor/courses/summer/cse307.html</a>
</li>

<li>CSE307 Principles of Programming Languages course: SML part 1<br />
<a href="https://www.youtube.com/watch?v=p1n0_PsM6hw">https://www.youtube.com/watch?v=p1n0_PsM6hw</a>
</li>

<li>CSE 307 &ndash; Principles of Programming Languages &ndash; SML<br />
<a href="https://www3.cs.stonybrook.edu/~pfodor/courses/summer/CSE307/L01_SML.pdf">https://www3.cs.stonybrook.edu/~pfodor/courses/summer/CSE307/L01_SML.pdf</a>
</li>

<li>SML, Some Basic Examples<br />
<a href="https://cs.fit.edu/~ryan/sml/intro.html">https://cs.fit.edu/~ryan/sml/intro.html</a>
</li>

<li>History of programming languages<br />
<a href="https://devskiller.com/history-of-programming-languages/">https://devskiller.com/history-of-programming-languages/</a>
</li>

<li>History of programming languages (Wikipedia)<br />
<a href="https://en.wikipedia.org/wiki/History_of_programming_languages">https://en.wikipedia.org/wiki/History_of_programming_languages</a>
</li>

<li>Jemný úvod do rozsáhlého světa jazyků LISP a Scheme<br />
<a href="https://www.root.cz/clanky/jemny-uvod-do-rozsahleho-sveta-jazyku-lisp-a-scheme/">https://www.root.cz/clanky/jemny-uvod-do-rozsahleho-sveta-jazyku-lisp-a-scheme/</a>
</li>

<li>The Evolution Of Programming Languages<br />
<a href="https://www.i-programmer.info/news/98-languages/8809-the-evolution-of-programming-languages.html">https://www.i-programmer.info/news/98-languages/8809-the-evolution-of-programming-languages.html</a>
</li>

<li>Evoluce programovacích jazyků<br />
<a href="https://ccrma.stanford.edu/courses/250a-fall-2005/docs/ComputerLanguagesChart.png">https://ccrma.stanford.edu/courses/250a-fall-2005/docs/ComputerLanguagesChart.png</a>
</li>

<li>Poly/ML Homepage<br />
<a href="https://polyml.org/">https://polyml.org/</a>
</li>

<li>PolyConf 16: A brief history of F# / Rachel Reese<br />
<a href="https://www.youtube.com/watch?v=cbDjpi727aY">https://www.youtube.com/watch?v=cbDjpi727aY</a>
</li>

<li>Programovací jazyk Clojure 18: základní techniky optimalizace aplikací<br />
<a href="https://www.root.cz/clanky/programovaci-jazyk-clojure-18-zakladni-techniky-optimalizace-aplikaci/">https://www.root.cz/clanky/programovaci-jazyk-clojure-18-zakladni-techniky-optimalizace-aplikaci/</a>
</li>

<li>Moscow ML Language Overview<br />
<a href="https://itu.dk/people/sestoft/mosml/mosmlref.pdf">https://itu.dk/people/sestoft/mosml/mosmlref.pdf</a>
</li>

<li>ForLoops<br />
<a href="http://mlton.org/ForLoops">http://mlton.org/ForLoops</a>
</li>

<li>Funkcionální dobrodružství v&nbsp;JavaScriptu<br />
<a href="https://blog.kolman.cz/2015/12/funkcionalni-dobrodruzstvi-v-javascriptu.html">https://blog.kolman.cz/2015/12/funkcionalni-dobrodruzstvi-v-javascriptu.html</a>
</li>

<li>Recenze knihy Functional Thinking (Paradigm over syntax)<br />
<a href="https://www.root.cz/clanky/recenze-knihy-functional-thinking-paradigm-over-syntax/">https://www.root.cz/clanky/recenze-knihy-functional-thinking-paradigm-over-syntax/</a>
</li>

<li>Currying<br />
<a href="https://sw-samuraj.cz/2011/02/currying/">https://sw-samuraj.cz/2011/02/currying/</a>
</li>

<li>Používání funkcí v&nbsp;F#<br />
<a href="https://docs.microsoft.com/cs-cz/dotnet/fsharp/tutorials/using-functions">https://docs.microsoft.com/cs-cz/dotnet/fsharp/tutorials/using-functions</a>
</li>

<li>Funkce vyššího řádu<br />
<a href="http://naucte-se.haskell.cz/funkce-vyssiho-radu">http://naucte-se.haskell.cz/funkce-vyssiho-radu</a>
</li>

<li>Currying (Wikipedia)<br />
<a href="https://en.wikipedia.org/wiki/Currying">https://en.wikipedia.org/wiki/Currying</a>
</li>

<li>Currying (Haskell wiki)<br />
<a href="https://wiki.haskell.org/Currying">https://wiki.haskell.org/Currying</a>
</li>

<li>Haskell Curry<br />
<a href="https://en.wikipedia.org/wiki/Haskell_Curry">https://en.wikipedia.org/wiki/Haskell_Curry</a>
</li>

<li>Moses Schönfinkel<br />
<a href="https://en.wikipedia.org/wiki/Moses_Sch%C3%B6nfinkel">https://en.wikipedia.org/wiki/Moses_Sch%C3%B6nfinkel</a>
</li>

<li>.NET framework<br />
<a href="https://dotnet.microsoft.com/en-us/">https://dotnet.microsoft.com/en-us/</a>
</li>

<li>F# - .NET Blog<br />
<a href="https://devblogs.microsoft.com/dotnet/category/fsharp/">https://devblogs.microsoft.com/dotnet/category/fsharp/</a>
</li>

<li>Playground: OCaml<br />
<a href="https://ocaml.org/play">https://ocaml.org/play</a>
</li>

<li>The F# Survival Guide<br />
<a href="https://web.archive.org/web/20110715231625/http://www.ctocorner.com/fsharp/book/default.aspx">https://web.archive.org/web/20110715231625/http://www.ctocorner.com/fsharp/book/default.aspx</a>
</li>

<li>Object-Oriented Programming — The Trillion Dollar Disaster<br />
<a href="https://betterprogramming.pub/object-oriented-programming-the-trillion-dollar-disaster-92a4b666c7c7">https://betterprogramming.pub/object-oriented-programming-the-trillion-dollar-disaster-92a4b666c7c7</a>
</li>

<li>Goodbye, Object Oriented Programming<br />
<a href="https://cscalfani.medium.com/goodbye-object-oriented-programming-a59cda4c0e53">https://cscalfani.medium.com/goodbye-object-oriented-programming-a59cda4c0e53</a>
</li>

<li>So You Want to be a Functional Programmer (Part 1)<br />
<a href="https://cscalfani.medium.com/so-you-want-to-be-a-functional-programmer-part-1-1f15e387e536">https://cscalfani.medium.com/so-you-want-to-be-a-functional-programmer-part-1-1f15e387e536</a>
</li>

<li>So You Want to be a Functional Programmer (Part 2)<br />
<a href="https://cscalfani.medium.com/so-you-want-to-be-a-functional-programmer-part-2-7005682cec4a">https://cscalfani.medium.com/so-you-want-to-be-a-functional-programmer-part-2-7005682cec4a</a>
</li>

<li>So You Want to be a Functional Programmer (Part 3)<br />
<a href="https://cscalfani.medium.com/so-you-want-to-be-a-functional-programmer-part-3-1b0fd14eb1a7">https://cscalfani.medium.com/so-you-want-to-be-a-functional-programmer-part-3-1b0fd14eb1a7</a>
</li>

<li>So You Want to be a Functional Programmer (Part 4)<br />
<a href="https://cscalfani.medium.com/so-you-want-to-be-a-functional-programmer-part-4-18fbe3ea9e49">https://cscalfani.medium.com/so-you-want-to-be-a-functional-programmer-part-4-18fbe3ea9e49</a>
</li>

<li>So You Want to be a Functional Programmer (Part 5)<br />
<a href="https://cscalfani.medium.com/so-you-want-to-be-a-functional-programmer-part-5-c70adc9cf56a">https://cscalfani.medium.com/so-you-want-to-be-a-functional-programmer-part-5-c70adc9cf56a</a>
</li>

<li>So You Want to be a Functional Programmer (Part 6)<br />
<a href="https://cscalfani.medium.com/so-you-want-to-be-a-functional-programmer-part-6-db502830403">https://cscalfani.medium.com/so-you-want-to-be-a-functional-programmer-part-6-db502830403</a>
</li>

<li>Don Syme<br />
<a href="https://en.wikipedia.org/wiki/Don_Syme">https://en.wikipedia.org/wiki/Don_Syme</a>
</li>

<li>Python to OCaml: Retrospective<br />
<a href="http://roscidus.com/blog/blog/2014/06/06/python-to-ocaml-retrospective/">http://roscidus.com/blog/blog/2014/06/06/python-to-ocaml-retrospective/</a>
</li>

<li>Why does Cambridge teach OCaml as the first programming language?<br />
<a href="https://www.youtube.com/watch?v=6APBx0WsgeQ">https://www.youtube.com/watch?v=6APBx0WsgeQ</a>
</li>

<li>OCaml and 7 Things You Need To Know About It In 2021 | Functional Programming | Caml<br />
<a href="https://www.youtube.com/watch?v=s0itOsgcf9Q">https://www.youtube.com/watch?v=s0itOsgcf9Q</a>
</li>

<li>OCaml 2021 - 25 years of OCaml<br />
<a href="https://www.youtube.com/watch?v=-u_zKPXj6mw">https://www.youtube.com/watch?v=-u_zKPXj6mw</a>
</li>

<li>Introduction | OCaml Programming | Chapter 1 Video 1<br />
<a href="https://www.youtube.com/watch?v=MUcka_SvhLw&amp;list=PLre5AT9JnKShBOPeuiD9b-I4XROIJhkIU">https://www.youtube.com/watch?v=MUcka_SvhLw&amp;list=PLre5AT9JnKShBOPeuiD9b-I4XROIJhkIU</a>
</li>

<li>Functional Programming - What | OCaml Programming | Chapter 1 Video 2<br />
<a href="https://www.youtube.com/watch?v=JTEwC3HihFc&amp;list=PLre5AT9JnKShBOPeuiD9b-I4XROIJhkIU&amp;index=2">https://www.youtube.com/watch?v=JTEwC3HihFc&amp;list=PLre5AT9JnKShBOPeuiD9b-I4XROIJhkIU&amp;index=2</a>
</li>

<li>Functional Programming - Why Part 1 | OCaml Programming | Chapter 1 Video 3<br />
<a href="https://www.youtube.com/watch?v=SKr3ItChPSI&amp;list=PLre5AT9JnKShBOPeuiD9b-I4XROIJhkIU&amp;index=3">https://www.youtube.com/watch?v=SKr3ItChPSI&amp;list=PLre5AT9JnKShBOPeuiD9b-I4XROIJhkIU&amp;index=3</a>
</li>

<li>Functional Programming - Why Part 2 | OCaml Programming | Chapter 1 Video 4<br />
<a href="https://www.youtube.com/watch?v=eNLm5Xbgmd0&amp;list=PLre5AT9JnKShBOPeuiD9b-I4XROIJhkIU&amp;index=4">https://www.youtube.com/watch?v=eNLm5Xbgmd0&amp;list=PLre5AT9JnKShBOPeuiD9b-I4XROIJhkIU&amp;index=4</a>
</li>

<li>OCaml | OCaml Programming | Chapter 1 Video 5<br />
<a href="https://www.youtube.com/watch?v=T-DIW1dhYzo&amp;list=PLre5AT9JnKShBOPeuiD9b-I4XROIJhkIU&amp;index=5">https://www.youtube.com/watch?v=T-DIW1dhYzo&amp;list=PLre5AT9JnKShBOPeuiD9b-I4XROIJhkIU&amp;index=5</a>
</li>

<li>Five Aspects of Learning a Programming Language | OCaml Programming | Chapter 2 Video 1<br />
<a href="https://www.youtube.com/watch?v=A5IHFZtRfBs&amp;list=PLre5AT9JnKShBOPeuiD9b-I4XROIJhkIU&amp;index=6">https://www.youtube.com/watch?v=A5IHFZtRfBs&amp;list=PLre5AT9JnKShBOPeuiD9b-I4XROIJhkIU&amp;index=6</a>
</li>

<li>Expressions | OCaml Programming | Chapter 2 Video 2<br />
<a href="https://www.youtube.com/watch?v=3fzrFY-2ZQ8&amp;list=PLre5AT9JnKShBOPeuiD9b-I4XROIJhkIU&amp;index=7">https://www.youtube.com/watch?v=3fzrFY-2ZQ8&amp;list=PLre5AT9JnKShBOPeuiD9b-I4XROIJhkIU&amp;index=7</a>
</li>

<li>If Expressions | OCaml Programming | Chapter 2 Video 3<br />
<a href="https://www.youtube.com/watch?v=XJ6QPtlPD7s&amp;list=PLre5AT9JnKShBOPeuiD9b-I4XROIJhkIU&amp;index=8">https://www.youtube.com/watch?v=XJ6QPtlPD7s&amp;list=PLre5AT9JnKShBOPeuiD9b-I4XROIJhkIU&amp;index=8</a>
</li>

<li>Let Definitions | OCaml Programming | Chapter 2 Video 4<br />
<a href="https://www.youtube.com/watch?v=eRnG4gwOTlI&amp;list=PLre5AT9JnKShBOPeuiD9b-I4XROIJhkIU&amp;index=10">https://www.youtube.com/watch?v=eRnG4gwOTlI&amp;list=PLre5AT9JnKShBOPeuiD9b-I4XROIJhkIU&amp;index=10</a>
</li>

<li>Let Expressions | OCaml Programming | Chapter 2 Video 5<br />
<a href="https://www.youtube.com/watch?v=ug3L97FXC6A&amp;list=PLre5AT9JnKShBOPeuiD9b-I4XROIJhkIU&amp;index=10">https://www.youtube.com/watch?v=ug3L97FXC6A&amp;list=PLre5AT9JnKShBOPeuiD9b-I4XROIJhkIU&amp;index=10</a>
</li>

<li>Variable Expressions and Scope | OCaml Programming | Chapter 2 Video 6<br />
<a href="https://www.youtube.com/watch?v=_TpTC6eo34M&amp;list=PLre5AT9JnKShBOPeuiD9b-I4XROIJhkIU&amp;index=11">https://www.youtube.com/watch?v=_TpTC6eo34M&amp;list=PLre5AT9JnKShBOPeuiD9b-I4XROIJhkIU&amp;index=11</a>
</li>

<li>Scope and the Toplevel | OCaml Programming | Chapter 2 Video 7<br />
<a href="https://www.youtube.com/watch?v=4SqMkUwakEA&amp;list=PLre5AT9JnKShBOPeuiD9b-I4XROIJhkIU&amp;index=12">https://www.youtube.com/watch?v=4SqMkUwakEA&amp;list=PLre5AT9JnKShBOPeuiD9b-I4XROIJhkIU&amp;index=12</a>
</li>

<li>Anonymous Functions | OCaml Programming | Chapter 2 Video 8<br />
<a href="https://www.youtube.com/watch?v=JwoIIrj0bcM&amp;list=PLre5AT9JnKShBOPeuiD9b-I4XROIJhkIU&amp;index=13">https://www.youtube.com/watch?v=JwoIIrj0bcM&amp;list=PLre5AT9JnKShBOPeuiD9b-I4XROIJhkIU&amp;index=13</a>
</li>

<li>Lambdas | OCaml Programming | Chapter 2 Video 9<br />
<a href="https://www.youtube.com/watch?v=zHHCD7MOjmw&amp;list=PLre5AT9JnKShBOPeuiD9b-I4XROIJhkIU&amp;index=15">https://www.youtube.com/watch?v=zHHCD7MOjmw&amp;list=PLre5AT9JnKShBOPeuiD9b-I4XROIJhkIU&amp;index=15</a>
</li>

<li>Operators<br />
<a href="https://ocaml.org/docs/operators">https://ocaml.org/docs/operators</a>
</li>

<li>Operator overloading<br />
<a href="https://en.wikipedia.org/wiki/Operator_overloading">https://en.wikipedia.org/wiki/Operator_overloading</a>
</li>

<li>Generalized algebraic data type<br />
<a href="https://en.wikipedia.org/wiki/Generalized_algebraic_data_type">https://en.wikipedia.org/wiki/Generalized_algebraic_data_type</a>
</a>

</ol>



<p></p><p></p>
<p><small>Autor: <a href="http://www.fit.vutbr.cz/~tisnovpa">Pavel Tišnovský</a> &nbsp; 2023</small></p>
</body>
</html>

