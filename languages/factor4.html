<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
        "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html>
<head>
<title>Factor: revoluce v programování nebo propadák?</title>
<meta name="Author" content="Pavel Tisnovsky" />
<meta name="Generator" content="vim" />
<meta http-equiv="content-type" content="text/html; charset=iso-8859-2" />
<style type="text/css">
         body {color:#000000; background:#ffffff;}
         h1  {font-family: arial, helvetica, sans-serif; color:#ffffff; background-color:#c00000; text-align:center; padding-left:1em}
         h2  {font-family: arial, helvetica, sans-serif; color:#ffffff; background-color:#0000c0; padding-left:1em; text-align:left}
         h3  {font-family: arial, helvetica, sans-serif; color:#000000; background-color:#c0c0c0; padding-left:1em; text-align:left}
         h4  {font-family: arial, helvetica, sans-serif; color:#000000; background-color:#e0e0e0; padding-left:1em; text-align:left}
         a   {font-family: arial, helvetica, sans-serif;}
         li  {font-family: arial, helvetica, sans-serif; color:#000000; text-align:justify; width:450px;}
         ol  {font-family: arial, helvetica, sans-serif; color:#000000; text-align:justify; width:450px;}
         ul  {font-family: arial, helvetica, sans-serif; color:#000000; text-align:justify; width:450px;}
         p   {font-family: arial, helvetica, sans-serif; color:#000000; text-align:justify;}
         pre {background:#e0e0e0}
</style>
</head>

<body>

<h1>Factor: revoluce v programování nebo propadák?</h1>

<h3>Pavel Ti¹novský</h3>

<p></p>

<h1>Úvodník</h1>

<p>V závìreèné èásti èlánku o programovacím jazyce Factor si popí¹eme zpùsob psaní funkcionálních programù. Na závìr se pokusím uvést nìkolik dùvodù, proè se má smysl zabývat programovacími jazyky, které se nachází mimo "hlavní proud" (mainstream) programovacích jazykù.</p>



<h1>Obsah</h1>
<p>
<a href="#k01">1. Factor: revoluce v programování nebo propadák?</a><br />
<a href="#k02">2. Základy funkcionálního programování ve Factoru</a><br />
<a href="#k03">3. Práce s&nbsp;kolekcemi a sekvencemi</a><br />
<a href="#k04">4. Pøíklad rùzných pøístupù k&nbsp;programování: výpoèet faktoriálu</a><br />
<a href="#k05">5. Smysl programovacích jazykù, které nespadají do hlavního proudu</a><br />
<a href="#k06">6. Literatura a odkazy na Internetu</a><br />
</p>



<p><a name="k01"></a></p>
<h1>1. Factor: revoluce v programování nebo propadák?</h1>

<p>Programovací jazyky <strong>Joy</strong> a <strong>Factor</strong>, které
popisuji v&nbsp;tomto seriálu, sice nepatøí mezi pøíli¹ známou ani roz¹íøenou
skupinu programovacích jazykù, ov¹em jedná se o jazyky, které do programování
pøinesly pomìrnì zásadní novinku spoèívající v&nbsp;pou¾ití paradigmatu
zalo¾eného na <i>kompozici funkcí</i>, ukládání citovaných programù na zásobník
(s&nbsp;mo¾ností dal¹í manipulace s&nbsp;nimi) a také na pou¾ití
<i>rekurzivních kombinátorù</i>.</p>

<p>U¾ jenom díky tìmto vlastnostem se jedná o plnohodnotné funkcionální jazyky,
co¾ pøedstavuje pomìrnì zásadní prùlom v&nbsp;nazírání na v¹echny "zásobníkové"
jazyky &ndash; ty jsou odvozeny od <strong>Forthu</strong>, tj.&nbsp;jazyka
imperativního (pro zajímavost: <strong>Forth</strong> byl jeden z&nbsp;prvních
reálnì pou¾itelných programovacích jazykù, které podporovaly procedurální zápis
algoritmù). V&nbsp;prùbìhu témìø ètyøiceti let od vzniku Forthu se sice
programátoøi sna¾ili tento jazyk o funkcionální paradigma roz¹íøit, opravdu
èistì a elegantnì se to ale podaøilo a¾ v&nbsp;programovacím jazyku
<strong>Joy</strong>, kterým byl inspirován i zde popisovaný
<strong>Factor</strong>.</p>

<p>Ov¹em ve <strong>Factoru</strong> je mo¾né kromì funkcionálního paradigmatu
pou¾ívat i paradigma objektové. V&nbsp;souèasnosti se &ndash; nutno øíci, ¾e
pro støednì velké a velké projekty celkem oprávnìnì &ndash; toto paradigma
pou¾ívá nejèastìji, dokonce se mnoho objektových knihoven zcela zjevnì
inspirovalo funkcionálním programováním &ndash; viz napøíklad nemìnné objekty
pou¾ívané v&nbsp;nìkolika návrhových vzorech a doporuèované i takovým
odborníkem, jakým je <a href="http://en.wikipedia.org/wiki/Joshua_Bloch">Joshua
Bloch</a>.</p>

<p>V&nbsp;následujících kapitolách si nejdøíve popí¹eme funkcionální
programování ve Factoru, a posléze si dovolím pøipsat krátké zamý¹lení nad
smyslem programovacích jazykù, které z&nbsp;rùzných dùvodù nespadají do
hlavního "vývojáøského proudu" a které mohou z&nbsp;pohledu mana¾erù vypadat
jako bezvýznamnosti. Samozøejmì budu psát pøedev¹ím o vá¾nì mínìných
netradièních jazycích, i kdy¾ i takové jazykové perly jako <i>Unlambda</i>,
<i>BrainF*ck</i> nebo <i>Whitespace</i> pøiná¹í do vývojáøského svìta tro¹ku
potøebného humoru a osvì¾ení.</p>



<p><a name="k02"></a></p>
<h1>2. Základy funkcionálního programování ve Factoru</h1>

<p>V&nbsp;èlánku o programovacím jazyce <strong>Joy</strong> (viz odkazy na
konci textu) jsme si øekli, ¾e vyèíslitelné (spoèitatelné) funkce je mo¾né
získat z&nbsp;takzvaných poèáteèních funkcí, co¾ je nulová funkce (<i>zero
function</i>), funkce následníka (<i>successor function</i>) a projekce
(<i>projection</i>), ze kterých jsou vytváøeny funkce slo¾itìj¹í. Mezi základní
zpùsoby tvorby slo¾itìj¹ích funkcí patøí <i>kombinace funkcí</i>, <i>kompozice
funkcí</i> a <i>primitivní rekurze</i>. Pro parciálnì rekurzivní funkce se
zavádí je¹tì operace zvaná <i>minimalizace</i>.</p>

<p>V&nbsp;jazyce <strong>Joy</strong> i <strong>Factor</strong> se ve velké
míøe vyu¾ívá pøedev¹ím kompozice funkcí. Jedná se o binární operaci, ov¹em
vzhledem k&nbsp;tomu, ¾e v&nbsp;obou tìchto jazycích je pou¾ita postfixová
notace, tak se zcela eliminuje nutnost zápisu operace kompozice funkcí pøímo do
zdrojových textù programù, proto¾e ji¾ ze vzájemné pozice jmen jednotlivých
funkcí je zøejmé, jaké je poøadí operací &ndash; je urèeno pøesnì tím poøadím,
jakým program èteme, tj.&nbsp;zleva doprava, neboli opaènì, ne¾ je tomu u
vìt¹iny funkcionálních programovacích jazykù zalo¾ených na lambda kalkulu.</p>

<p>Pro zaèátek si zopakujme, ¾e ve <strong>Factoru</strong> se nové funkce
vytváøí naprosto stejným zpùsobem jako ve <strong>Forthu</strong>,
tj.&nbsp;zaèátek definované funkce je uvozen znakem <strong>:</strong>
(dvojteèka) a konec znakem <strong>;</strong> (støedník), který je internì
pøekládán jako návrat z&nbsp;funkce (return). V&nbsp;nìkteré literatuøe se
tento zpùsob vytváøení nových funkcí nazývá <i>colon definition</i>. V¹echny
funkce své parametry ètou ze zásobníku a výsledek nebo výsledky (mù¾e jich být
i více) opìt ukládají na zásobník. To mnohdy vede k&nbsp;velmi úspornému zápisu
kódu:</p>

<code-area>
<i>! vytvoøení nové funkce square, která vypoète druhou mocninu argumentu</i>
<strong>: square dup * ;</strong>

<i>! novou funkci si mù¾eme ihned otestovat</i>
<strong>42 square .s</strong>
1764

<i>! vytvoøení nové funkce neg, která zmìní znaménko svého argumentu</i>
<strong>: new 0 swap - ;</strong>

<i>! opìt mù¾eme provést jednoduchý test</i>
<strong>6502 neg .</strong>
-6502

</code-area>

<p>Kromì toho je mo¾né ve <strong>Factoru</strong>, podobnì jako v&nbsp;døíve
popsaném jazyku <strong>Joy</strong>, pou¾ívat takzvané <i>citované
programy</i>. Jedná se o libovolnì dlouhou a samozøejmì také libovolnì slo¾itou
sekvenci pøíkazù ulo¾enou mezi hranaté závorky <strong>[</strong> a
<strong>]</strong>. Jinými slovy to znamená, ¾e program je zapsán na zásobník
jako bì¾ný seznam a posléze je tento program buï pøímo spu¹tìn nebo pou¾it
v&nbsp;dal¹ích operacích, napøíklad podmínìných výrazech, smyèkách èi náhradì
rekurze pomocí rekurzivních manipulátorù.</p>

<p>Nejjednodu¹¹í mo¾ností, jak s&nbsp;èástí programu zapsanou v&nbsp;seznamu
pracovat, je jeho spu¹tìní. To lze provést pomocí operátoru
<strong>call</strong> (<i>zavolej (podprogram)</i>), který svým pou¾itím
odpovídá pøíkazu <strong>eval</strong> známého z&nbsp;jiných programovacích
jazykù. Uka¾me si jednoduchý pøíklad:</p>

<code-area>
<i>! pøímé spu¹tìní sekvence pøíkazù</i>
<strong>21 2 * .</strong>
42

<i>! ulo¾ení citovaného programu na zásobník</i>
<strong>[ 21 2 * . ]</strong>

<i>! kontrola, zda je program skuteènì na zásobníku ulo¾en</i>
<strong>.s</strong>
[ 21 2 * . ]

<i>! zkusíme program spustit</i>
<strong>call</strong>
42
</code-area>

<p>Dal¹ím pøíkladem je opakované spu¹tìní urèité èásti kódu. Ve své podstatì se
nejedná o nic jiného, ne¾ o jednoduchý ekvivalent poèítané programové smyèky
nahrazené funkcí <strong>times</strong>, která na zásobníku oèekává poèet
opakování, tj.&nbsp;celoèíselnou hodnotu a dále citovaný program, který se bude
<i>n</i>-krát opakovat:</p>

<code-area>
<strong>10 [ "Nebudu se paní uèitelce smát za zády do oèí" print ] times</strong>
Nebudu se paní uèitelce smát za zády do oèí
Nebudu se paní uèitelce smát za zády do oèí
Nebudu se paní uèitelce smát za zády do oèí
Nebudu se paní uèitelce smát za zády do oèí
Nebudu se paní uèitelce smát za zády do oèí
Nebudu se paní uèitelce smát za zády do oèí
Nebudu se paní uèitelce smát za zády do oèí
Nebudu se paní uèitelce smát za zády do oèí
Nebudu se paní uèitelce smát za zády do oèí
Nebudu se paní uèitelce smát za zády do oèí
</code-area>



<p><a name="k03"></a></p>
<h1>3. Práce s&nbsp;kolekcemi a sekvencemi</h1>

<p>Programovací jazyk <strong>Factor</strong> plnì podporuje práci
s&nbsp;kolekcemi. Kolekcí je v&nbsp;tomto kontextu my¹lena sekvence (pøedev¹ím
<i>pole</i>, <i>vektor</i>, <i>øetìzec</i> a <i>citovaný program</i>,
popø.&nbsp;jakýkoli jiný objekt implementující dané rozhraní), <i>asociativní
pole</i> (známé také pod oznaèením <i>he¹ovací mapa</i>) nebo dal¹í slo¾itìj¹í
datová struktura, do které se ukládají hodnoty (z&nbsp;implementovaných kolekcí
jmenujme <i>dvojitì vázaný seznam</i>, <i>orientovaný graf</i> atd.).</p>

<p>Zajímavé je, ¾e dal¹í datové struktury je mo¾né do jazyka pomìrnì
jednoduchým zpùsobem pøidat, co¾ by je¹tì nebylo nijak zvlá¹tní, ale lze pro nì
vytvoøit i speciální syntaxi, co¾ u¾ tak bì¾né není. Je to umo¾nìno zejména
díky tomu, ¾e <strong>Factor</strong> má sám o sobì syntaxi tak jednoduchou, ¾e
si nemusí rezervovat prakticky ¾ádné speciální znaky ani klíèová slova, která
by mìla speciální význam; tudí¾ je mo¾né tyto znaky pou¾ít mimo jiné i pro
vytváøení kolekcí. Typickým pøíkladem mohou být <i>pole</i>, pro která jsou
vytvoøena slova/funkce pojmenovaná symboly <strong>{</strong> a
<strong>}</strong>. Tyto symboly slou¾í, jak jste ostatnì mohli uhodnout, ke
konstrukci pole:</p>

<code-area>
{ 1 2 3 10 20 }
</code-area>

<p>Podobné je to s&nbsp;<i>vektory</i>, pro nì¾ je vytvoøeno slovo
<strong>V{</strong>, které takté¾ nahrazuje konstruktor kolekce:</p>

<code-area>
V{ 1 2 3 4 5 }
</code-area>

<p>Existuje pouze málo programovacích jazykù, které nabízí takovou volnost pøi
vytváøení vlastní syntaxe. Èestnou výjimkou je <strong>Lisp</strong> a
z&nbsp;nìho odvozené jazyky.</p>

<p>Ve <strong>Factoru</strong> se, podobnì jako v&nbsp;dal¹ích funkcionálních
jazycích, velmi èasto pou¾ívají funkce, které jako svùj argument pøijímají jiné
funkce. Typickým pøíkladem je funkce <strong>map</strong>, pomocí které je
mo¾né aplikovat libovolnou funkci zapsanou <i>citovaným programem</i> na seznam
nebo pole (to je ulo¾eno na druhém nejvy¹¹ím místì zásobníku):</p>

<code-area>
<i>! výpoèet druhé mocniny pro v¹echny prvky seznamu</i>
<strong>[ 1 2 3 4 ] [ dup * ] map .s</strong>
[ 1 4 9 16]

<i>! definice nového slova/funkce square</i>
<strong>: square dup * ;</strong>

<i>! pou¾ití slova/funkce square na celé pole</i>
<strong>{ 1 2 3 4 } [ square ] map .s</strong>
{ 1 4 9 16 }

<i>! výpoèet pøevrácené hodnoty pro zadaný seznam</i>
<strong>: inv 1.0 swap / ;</strong>
<strong>[ 1 2 5 10 ] [ inv ] map .</strong>
[ 1.0 0.5 0.2 0.1 ]

</code-area>

<p>Dal¹ím typicky funkcionálním obratem je pou¾ití funkce
<strong>reduce</strong>, která postupnì aplikuje nìjakou binární operaci na
sekvenci (které je funkci <strong>reduce</strong> pøedána v&nbsp;jednom
parametru) a mezivýsledek. V&nbsp;první iteraci je místo mezivýsledku pou¾ita
hodnota ulo¾ená na druhém místì zásobníku (tato hodnota se nìkdy nazývá
<i>identita</i>):</p>

<code-area>
<i>! [ 1 2 3 4 5 ] - vstupní sekvence</i>
<i>! 100           - identita</i>
<i>! [ + ]         - aplikovaná binární operace</i>
<strong>[ 1 2 3 4 5 ] 100 [ + ] reduce .</strong>
115
</code-area>



<p><a name="k04"></a></p>
<h1>4. Pøíklad rùzných pøístupù k&nbsp;programování: výpoèet faktoriálu</h1>

<p>Výpoèet faktoriálu patøí mezi typické algoritmy, na nich¾ se dají ukázat
rùzné pøístupy k&nbsp;programování. ©kolní implementace bývají typicky zalo¾eny
na "naivní" rekurzi, v&nbsp;bì¾ných programech se programátoøi vìt¹inou
spoléhají na klasickou programovou smyèku a ve funkcionálních jazycích lze
s&nbsp;výhodou pou¾ít koncovou rekurzi (<i>tail recursion</i>). Dalo by se
øíci, ¾e klasická "¹kolní rekurze" je tou nejhor¹í variantou, pojïme v¹ak dále.
Ve <strong>Factoru</strong> lze pou¾ít vý¹e uvedenou funkci
<strong>reduce</strong> a zapsat faktoriál následujícím zpùsobem:</p>

<code-area>
<strong>: factorial1 1 [ 1+ * ] reduce ;</strong>
</code-area>

<p>Pøi spu¹tìní této funkce je ze zásobníku pøeètena celoèíselná hodnota, která
je pou¾ita jako výchozí sekvence. Je zde vyu¾ito faktu, ¾e i jedno èíslo se
mù¾e chovat jako sekvence. Napøíklad èíslo 3 se chová jako sekvence hodnot 0, 1
a 2. Právì této skvìlé vlastnosti (která kupodivu chybí i v&nbsp;jinak skvìlém
Lispu) je vyu¾ito pøi výpoètu faktoriálu. Funkce <strong>1+</strong>
pøedstavuje prostou inkrementaci hodnoty, tj.&nbsp;náhradu literálu
<strong>1</strong> a funkce <strong>+</strong>. Výsledek si ihned mù¾eme
otestovat:</p>

<code-area>
<strong>0 factorial1 .</strong>
1
<strong>-10 factorial1 .</strong>
1
<strong>2 factorial1 .</strong>
2
<strong>42 factorial1 .</strong>
1405006117752879898543142606244511569936384000000000
</code-area>

<p>Ov¹em to není jediná cesta, jak dojít ke ký¾enému výsledku. Pokud se budeme
chtít vyhnout klasickým smyèkám a rekurzi, mù¾eme je¹tì vyu¾ít dal¹ího slova,
které nám <strong>Factor</strong> nabízí. Jedná se o slovo
<strong>product</strong>, které oèekává na zásobníku sekvenci a vrátí její
produkt, tj.&nbsp;hodnotu vzniklou postupným vynásobením v¹ech hodnot ulo¾ených
v&nbsp;této sekvenci. Zbývá nám tedy sekvenci vytvoøit na základì zadané
hodnoty.</p>

<p>Samozøejmì není vhodné pou¾ít smyèku (to bychom vlastnì vytloukali klín
klínem), ale mù¾eme pou¾ít napøíklad funkci nazvanou zajímavì ale docela vhodnì
<strong>[1,b]</strong>, která je ulo¾ena ve slovníku
<strong>"math.ranges"</strong>. Jedná se o funkci, která po pøeètení celého
kladného èísla ze zásobníku ulo¾í nazpìt sekvenci od 1 a¾ do velikosti tohoto
èísla (jde o podobnou operaci, jakou nabízí tøeba <strong>Haskell</strong>).
Výsledný program pro výpoèet faktoriálu tedy mù¾e být velmi jednoduchý:</p>

<code-area>
<i>! import knihovny math.ranges</i>
<strong>USING: math.ranges ;</strong>

<i>! vytvoøení nové varianty funkce faktoriálu</i>
<strong>: factorial2 [1,b] product ;</strong>

<i>! test</i>
<strong>0 factorial2 .</strong>
0 (!!!)
<strong>-10 factorial2 .</strong>
0 (!!!)
<strong>2 factorial2 .</strong>
2
<strong>42 factorial2 .</strong>
1405006117752879898543142606244511569936384000000000
</code-area>

<p>Pro zcela korektní výpoèet by bylo vhodné místo <strong>[1,b]</strong> volat
spí¹e upravenou funkci, která pro hodnoty men¹í ne¾ 1 vrací sekvenci
s&nbsp;jedinou hodnotou 1 a ne nula. Úprava je mo¾ná buï s&nbsp;vyu¾itím
operátoru <strong>if</strong> nebo <strong>min</strong>.</p>



<p><a name="k05"></a></p>
<h1>5. Smysl programovacích jazykù, které nespadají do hlavního proudu</h1>

<p>Na <strong>Rootu</strong> bylo publikováno u¾ nìkolik èlánkù o
programovacích jazycích, které zcela jistì není mo¾né zaøadit do hlavního
vývojáøského proudu. Kromì specialit vhodných spí¹e pro pobavení
(<i>BrainF*uck</i>, <i>Whitespace</i>) ne¾ pro seriózní práci nebo výzkum byly
popsány i jazyky, které ve své dobì naznaèily dal¹í smìr vývoje celé této
oblasti IT. Jde napøíklad o <i>Forth</i> (absolutnì minimalistický a pøitom
praktický jazyk, který programátorùm odhaluje i své interní struktury),
<i>Perl</i> a <i>Tcl</i> (tyto jazyky zapøíèinily vzestup skriptovacích
jazykù), <i>Lisp</i> èi <i>APL</i> (velmi expresivní jazyk se zajímavou :-)
sadou operátorù). Ka¾dý z&nbsp;tìchto jazykù pøinesl nìjaké nosné nápady èi
u¾iteèné techniky, které byly pozdìji okopírovány do jazykù dal¹ích a mnohdy i
úspì¹nìj¹ích.</p>

<image id="5750" original="no" />
<p-center>Strom vývoje programovacích jazykù (poloruènì vytvoøeno z&nbsp;PostScriptového zdroje; pùvodní autor je uveden vlevo dole)</p-center>

<p>Tak jako v&nbsp;jiných oblastech, i v&nbsp;programovacích jazycích mù¾e na
první pohled bláznivý èi "nepraktický" nápad vést ke vzniku u¾iteèné techniky,
která je následnì v¹emi okopírována. Jako pøíklad lze uvést napøíklad regulární
výrazy zabudované pøímo do jazyka. V&nbsp;dobách kralování Céèka, Fortranu a
Ady bylo prakticky nemyslitelné do jazyka pøidávat tak abstraktní konstrukce
jako regulární výrazy &ndash; pro nì byly vyhrazeny speciální utility a
jednoúèelové nástroje typu awk èi grep. Ov¹em poté, co se ukázala jejich
u¾iteènost v&nbsp;Perlu se prakticky nesetkáme s&nbsp;dynamickým programovacím
jazykem, který by regulární výrazy neobsahoval a algolská vìtev jazykù (mezi
nì¾ øadím napøíklad i Javu) je alespoò obsahuje ve svých standardních
knihovnách.</p>

<p>Obdobné je to s&nbsp;nìkterými funkcionálními prvky, které se postupnì
z&nbsp;Lispu èi Smalltalku pøená¹í pøes moderní dynamické jazyky (Perl, Python,
Ruby, Tcl) do mainstreamových jazykù. Pøíkladem je velmi u¾iteèná funkcionální
konstrukce typu <i>for-each</i>, která po tom, co se objevila v&nbsp;Javì 1.5
(<i>Tiger</i>), prakticky nahradila (snad kromì numerických algoritmù)
klasickou procedurální smyèku <i>for</i>. Na funkce vy¹¹ího øádu typu
<i>map</i>, <i>apply</i> èi <i>reduce</i> zase mù¾eme narazit v&nbsp;jazycích
typu Python, nebo i v&nbsp;Logu èi právì ve Factoru.</p>

<p>Myslím si, ¾e je jen otázkou èasu, kdy se nìkteré konstrukce a
programátorské obraty zavedené napøíklad v&nbsp;<strong>Haskellu</strong>
(mimochodem: dal¹í nepatøiènì opomíjený jazyk), <strong>Selfu</strong> nebo
<strong>Factoru</strong> objeví v&nbsp;dnes nejèastìji pou¾ívaných jazycích.
Zda to u¹kodí èistotì tìchto jazykù je otázkou, ale vý¹e zmínìný pøíklad
pomìrnì èistì implantované konstrukce typu <i>for-each</i> do Javy je
pøíslibem, ¾e se vhodné øe¹ení dá vymyslet.</p>

<p>Stejné je to i se sekvencemi popsanými ve tøetí a ètvrté kapitole tohoto
èlánku, které mohou pøi správném pou¾ití mnoho algoritmù zjednodu¹it a nahradit
mnohdy do sebe zamotané programové smyèky èistým funkcionální o objektovým
kódem. I to je jeden z&nbsp;dùvodù, proè dal¹í programovací jazyky vznikají a
proè jsou o tìch zajímavìj¹ích publikovány èlánky.</p>



<p><a name="k06"></a></p>
<h1>6. Literatura a odkazy na Internetu</h1>

<ol>

<li>
John Backus:<br />
<i>Can programming by liberated from the von Neumann style?: A functional style and its algebra of programs</i>,<br />
Source Communications of the ACM archive, 21(8):613-641, August 1978.
</li>

<li>
H.B.Curry and R.Feys:<br />
<i>Combinatory Logic</i>,<br />
North-Holland Publishing Company, 1958.
</li>

<li>
Paul Hudak et al.:<br />
<i>Report on the programming language Haskell: a non-strict, purely functional language version 1.2.</i>,<br />
SIGPLAN Not., 27(5):1-164, 1992. ISSN 0362-1340.
</li>

<li>
Charles Moore:<br />
<i>Forth: a new way to program a mini-computer</i><br />
Astronomy and Astrophysics Supplement, (15), 1974.
</li>

<li>
Robert Morris and Lorinda Cherry:<br />
<i>Dc - an interactive desk calculator</i><br />
Technical report, AT&amp;T Bell Laboratories
</li>

<li>
Jaanus P.:<br />
<i>Typing tools for typeless stack languages</i><br />
In Proceedings from the 23rd EuroForth Conference, pages 40-46, 2006.
</li>

<li>
Manfred von Thun.:<br />
<i>Joy: Forth's functional cousin</i><br />
In Proceedings from the 17th EuroForth Conference, 2001.
</li>

<li>
Factor programming language:<br />
<a href="http://factorcode.org/">http://factorcode.org/</a>
</li>

<li>
Factor documentation:<br />
<a href="http://factorcode.org/responder/help/">http://factorcode.org/responder/help/</a>
</li>

<li>
Factor FAQ:<br />
<a href="http://factorcode.org/faq.fhtml">http://factorcode.org/faq.fhtml</a>
</li>

<li>
Factor: a practical stack language (blogpost):<br />
<a href="http://factor-language.blogspot.com/">http://factor-language.blogspot.com/</a>
</li>

<li>
Factor-talk --:<br />
<a href="https://lists.sourceforge.net/lists/listinfo/factor-talk">https://lists.sourceforge.net/lists/listinfo/factor-talk</a>
</li>

<li>
Factor-talk -- archive:<br />
<a href="http://sourceforge.net/mailarchive/forum.php?forum_name=factor-talk">http://sourceforge.net/mailarchive/forum.php?forum_name=factor-talk</a>
</li>

<li>
Wikipedia: Factor (programming language):<br />
<a href="http://en.wikipedia.org/wiki/Factor_(programming_language)">http://en.wikipedia.org/wiki/Factor_(programming_language)</a>
</li>

<li>
Wikipedia: Slava Pestov:<br />
<a href="http://en.wikipedia.org/wiki/Slava_Pestov">http://en.wikipedia.org/wiki/Slava_Pestov</a>
</li>

<li>
Pastebin (collaborative development over IRC):<br />
<a href="http://paste.factorcode.org/">http://paste.factorcode.org/</a>
</li>

<li>
planet-factor:<br />
<a href="http://planet.factorcode.org/">http://planet.factorcode.org/</a>
</li>

<li>
Slava Pestov's retro HTML 1.0 home page:<br />
<a href="http://factorcode.org/slava/">http://factorcode.org/slava/</a>
</li>

<li>
concatenative (IRC kanál o podobných programovacích jazycích):<br />
<a href="http://www.ircbrowse.com/cdates.html?channel=concatenative">http://www.ircbrowse.com/cdates.html?channel=concatenative</a>
</li>

<li>
Vocabulary index (dnes ji¾ docela rozsáhlé):<br />
<a href="http://factorcode.org/responder/help/show-help?topic=vocab-index">http://factorcode.org/responder/help/show-help?topic=vocab-index</a>
</li>

<li>
Factor Magic:<br />
<a href="http://fun-factor.blogspot.com/2007/03/factor-magic.html">http://fun-factor.blogspot.com/2007/03/factor-magic.html</a>
</li>

<li>
Factor Magic, Part 2:<br />
<a href="http://fun-factor.blogspot.com/2007/04/factor-magic-part-2.html">http://fun-factor.blogspot.com/2007/04/factor-magic-part-2.html</a>
</li>

<li><a href="http://www.latrobe.edu.au/philosophy/phimvt/joy.html">http://www.latrobe.edu.au/philosophy/phimvt/joy.html</a> &ndash; 
Joy Programming Language, stránka s&nbsp;rozcestníkem informací o programovacím jazyku Joy</li>

<li><a href="http://www.latrobe.edu.au/philosophy/phimvt/joy/j01tut.html">http://www.latrobe.edu.au/philosophy/phimvt/joy/j01tut.html</a> &ndash; Tutorial on Joy</li>

<li><a href="http://www.latrobe.edu.au/philosophy/phimvt/joy/j06prg.html">http://www.latrobe.edu.au/philosophy/phimvt/joy/j06prg.html</a> &ndash; Programming in Joy</li>

<li><a href="http://www.latrobe.edu.au/philosophy/phimvt/joy/synops.html">http://www.latrobe.edu.au/philosophy/phimvt/joy/synops.html</a> &ndash; Synopsis of the language Joy</li>

<li><a href="http://www.latrobe.edu.au/philosophy/phimvt/joy/faq.html">http://www.latrobe.edu.au/philosophy/phimvt/joy/faq.html</a> &ndash; Frequently Asked Questions about Joy, obsahuje i èásteèné porovnání s&nbsp;dal¹ími programovacími jazyky zalo¾enými na zásobníkovém kódu</li>

<li><a href="http://www.madore.org/~david/programs/unlambda/">http://www.madore.org/~david/programs/unlambda/</a> &ndash; Programovací jazyk Unlambda</li>

</ol>



<p></p><p></p>
<p><small>Autor: <a href="http://www.fit.vutbr.cz/~tisnovpa">Pavel Ti¹novský</a> &nbsp; 2008</small></p>
</body>
</html>

