<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
        "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html>
<head>
<title>Programovací jazyk C3: reakce na chyby, odložení vykonání příkazů</title>
<meta name="Author" content="Pavel Tisnovsky" />
<meta name="Generator" content="vim" />
<meta http-equiv="content-type" content="text/html; charset=utf-8" />
<style type="text/css">
         body {color:#000000; background:#ffffff;}
         h1  {font-family: arial, helvetica, sans-serif; color:#ffffff; background-color:#c00000; text-align:center; padding-left:1em}
         h2  {font-family: arial, helvetica, sans-serif; color:#ffffff; background-color:#0000c0; padding-left:1em; text-align:left}
         h3  {font-family: arial, helvetica, sans-serif; color:#000000; background-color:#c0c0c0; padding-left:1em; text-align:left}
         h4  {font-family: arial, helvetica, sans-serif; color:#000000; background-color:#e0e0e0; padding-left:1em; text-align:left}
         a   {font-family: arial, helvetica, sans-serif;}
         li  {font-family: arial, helvetica, sans-serif; color:#000000; text-align:justify; width:450px;}
         ol  {font-family: arial, helvetica, sans-serif; color:#000000; text-align:justify; width:450px;}
         ul  {font-family: arial, helvetica, sans-serif; color:#000000; text-align:justify; width:450px;}
         p   {font-family: arial, helvetica, sans-serif; color:#000000; text-align:justify;}
         pre {background:#e0e0e0}
</style>
</head>

<body>

<h1>Programovací jazyk C3: reakce na chyby, odložení vykonání příkazů</h1>

<h3>Pavel Tišnovský</h3>

<p></p>

<h1>Úvodník</h1>

<p>Programovací jazyk C3 obsahuje v porovnání s původním jazykem C několik novinek. Mezi nové vlastnosti patří podpora pro práci s volitelnými (optional) hodnotami a taktéž konstrukce zajišťující odložené volání nějakého příkazu (defer). S těmito vlastnostmi se dnes seznámíme.</p>



<h2>Obsah</h2>

<p><a href="#k01">1. Programovací jazyk C3: reakce na chyby, odložení vykonání příkazů</a></p>
<p><a href="#k02">*** 2. Jak reprezentovat chybějící hodnotu nebo informaci o chybě?</a></p>
<p><a href="#k03">3. Rozšíření datových typů: <strong>Optional</strong></a></p>
<p><a href="#k04">4. Přístup k&nbsp;hodnotě typu <strong>Optional</strong> s&nbsp;detekcí chyby</a></p>
<p><a href="#k05">5. Uživatelsky definovaný typ s&nbsp;informací o chybě</a></p>
<p><a href="#k06">6. Vynucení přístupu k&nbsp;hodnotě operátorem !!</a></p>
<p><a href="#k07">7. Chování operátoru !! v&nbsp;případě, že je namísto hodnoty uložena informace o chybě</a></p>
<p><a href="#k08">8. Praktické použití: výpočet faktoriálu bez vracení informace o chybě</a></p>
<p><a href="#k09">9. Výpočet faktoriálu s&nbsp;detekcí nekorektního vstupu</a></p>
<p><a href="#k10">10. Pokus o přímý přístup k&nbsp;vrácené hodnotě operátorem !!</a></p>
<p><a href="#k11">11. Konstrukce <strong>defer</strong></a></p>
<p><a href="#k12">12. Základní porovnání konstrukce <strong>defer</strong> v&nbsp;jazycích Go a C3</a></p>
<p><a href="#k13">13. Proč byla konstrukce <strong>defer</strong> do jazyka C3 přidána?</a></p>
<p><a href="#k14">14. Pořadí volání příkazů zaregistrovaných s&nbsp;využitím příkazu <strong>defer</strong></a></p>
<p><a href="#k15">15. Sémantika <strong>defer</strong> v&nbsp;jazyce Go</a></p>
<p><a href="#k16">16. Sémantika <strong>defer</strong> v&nbsp;jazyce C3</a></p>
<p><a href="#k17">17. Konstrukce <strong>defer</strong> a <strong>return</strong></a></p>
<p><a href="#k18">18. Funkce volané na začátku a konci procesu</a></p>
<p><a href="#k19">19. Repositář s&nbsp;demonstračními příklady</a></p>
<p><a href="#k20">20. Odkazy na Internetu</a></p>



<p><a name="k01"></a></p>
<h2 id="k01">1. Programovací jazyk C3: reakce na chyby, odložení vykonání příkazů</h2>

<p>V&nbsp;již páté části <a
href="https://www.root.cz/serialy/programovaci-jazyk-c3/">seriálu o
programovacím jazyce C3</a> se budeme zabývat velmi důležitým tématem, který
byl do jisté míry v&nbsp;původním jazyce C poněkud odsunut do pozadí. Jedná se
o způsoby, jakými může aplikace reagovat na nějaké chybové hodnoty
resp.&nbsp;na chybějící hodnoty atd. S&nbsp;touto problematikou souvisí i
rozšíření typového systému programovacího jazyka C3 o typ <i>Optional</i>. Ve
skutečnosti se nejedná o žádnou žhavou novinku, protože typ <i>Optional</i>
vznikl jako varianta typů <i>Option</i> a <i>Result</i> známých z&nbsp;dalších
programovacích jazyků.</p>

<p>Popíšeme si taktéž programovou konstrukci, kterou lze použít pro odložené
vykonání nějakých příkazů. Tato konstrukce se zapisuje klíčovým slovem
<strong>defer</strong>, jehož sémantika je však v&nbsp;jazyce C3 odlišná, než
například v&nbsp;programovacím jazyce Go (stejný zápis povede k&nbsp;odlišnému
způsobu vykonání bloků <strong>defer</strong>).</p>



<p><a name="k02"></a></p>
<h2 id="k02">2. Jak reprezentovat chybějící hodnotu nebo informaci o chybě?</h2>

<p></p>



<p><a name="k03"></a></p>
<h2 id="k03">3. Rozšíření datových typů: <strong>Optional</strong></h2>

<p>Nejprve si ukažme triviální příklad, ve kterém je definována běžná lokální
proměnná typu <strong>int</strong>, je provedena inicializace této proměnné a
následně je hodnota proměnné vypsána na standardní výstup:</p>

<pre>
module error_handling;
import std::io;
&nbsp;
fn void <strong>main</strong>()
{
    int i = 42;
    io::printf("i=%d\n", i);
}
</pre>

<p>Výsledek bude pochopitelně následující:</p>

<pre>
i=42
</pre>

<p>V&nbsp;případě, že budeme chtít pracovat s&nbsp;potenciálně neuvedenými nebo
neznámými hodnotami (tedy <i>Optional</i>) postačuje definici datového typu
doplnit o otazník &ndash; viz podtrženou část kódu:</p>

<pre>
module error_handling;
import std::io;
&nbsp;
fn void <strong>main</strong>()
{
    <u>int? i = 42</u>;
    io::printf("i=%d\n", i);
}
</pre>

<p>S&nbsp;takto definovanou proměnnou <strong>i</strong> se ovšem pracuje
odlišným způsobem, na což nás upozorní překladač:</p>

<pre>
 4: fn void main()
 5: {
 6:     int? i = 42;
 7:     io::printf("i=%d\n", i);
        ^^^^^^^^^^^^^^^^^^^^^^^
(/home/ptisnovs/src/c3-examples/c3-errors-handling/02_optional_value.c3:7:5)
Error: The result of this call is optional due to its argument(s). This
optional result may not be implicitly discarded. Please assign it to a
variable, ignore it with '(void)', rethrow with '!' or panic with '!!'.
</pre>

<p>Z&nbsp;chybového hlášení překladače je patrné, že se k&nbsp;proměnné
<strong>i</strong> musíme chovat jinak, než k&nbsp;běžné proměnné typu
<strong>int</strong>. Jak bude zpracování její hodnoty vypadat, je ukázáno
v&nbsp;navazující kapitole.</p>



<p><a name="k04"></a></p>
<h2 id="k04">4. Přístup k&nbsp;hodnotě typu <strong>Optional</strong> s&nbsp;detekcí chyby</h2>

<p>Korektní způsob přístupu (čtení) hodnoty, která je typu
<strong>Optional</strong>, vyžaduje, aby se otestovaly obě možnosti, které
mohou nastat &ndash; tj.&nbsp;jak situace, kdy proměnná obsahuje korektní
hodnotu, tak i situace, kdy hodnotu neobsahuje popř.&nbsp;je namísto běžné
hodnoty v&nbsp;proměnné uložena informace o chybě. Typicky se v&nbsp;této
situaci setkáme s&nbsp;využitím rozvětvení typu <strong>if-else</strong>, které
může vypadat následovně:</p>

<pre>
module error_handling;
import std::io;
&nbsp;
fn void <strong>main</strong>()
{
    int? i = 42;
&nbsp;
    if (<u>catch excuse = i</u>)
    {
        io::printfn("Fault: %s", excuse);
    } else {
        io::printf("i=%d\n", i);
    }
}
</pre>

<p>Překladač zjistí, že se korektně testují oba možné stavy a dovolí zdrojový
kód přeložit (a spustit):</p>

<pre>
i=42
</pre>

<p>V&nbsp;případě, že se v&nbsp;první větvi vyskakuje z&nbsp;celé funkce nebo
bloku (<strong>break</strong>, <strong>continue</strong>,
<strong>return</strong>), není nutné zapisovat větev <strong>else</strong>,
neboť překladač opět dokáže zjistit, že v&nbsp;podmínce testujeme potenciální
chybový stav a navíc se z&nbsp;větve <strong>if</strong> řízení programu vrací
zpět do volající funkce. To znamená, že i následující zápis je z&nbsp;pohledu
překladače plně korektní a tudíž i přeložitelný:</p>

<pre>
module error_handling;
import std::io;
&nbsp;
fn void <strong>main</strong>()
{
    int? i = 42;
&nbsp;
    if (catch excuse = i)
    {
        io::printfn("Fault: %s", excuse);
        return;
    }
    io::printf("i=%d\n", i);
}
</pre>



<p><a name="k05"></a></p>
<h2 id="k05">5. Uživatelsky definovaný typ s&nbsp;informací o chybě</h2>

<p>Připomeňme si, že proměnná typu <i>Optional</i> může obsahovat buď přímo
hodnotu (například 42) nebo informaci o chybě. Jak však taková informace o
chybě vypadá? Jedná se o samostatnou hodnotu, kterou je možné definovat
s&nbsp;využitím specializovaného klíčového slova <strong>faultdef</strong>.
Definice může v&nbsp;tom nejjednodušším případě vypadat následovně:</p>

<pre>
faultdef MY_ERROR;
</pre>

<p>Tuto hodnotu můžeme přiřadit do proměnné typu <i>Optional</i>. Povšimněte si
otazníku na konci přiřazení:</p>

<pre>
module error_handling;
import std::io;
&nbsp;
<u>faultdef MY_ERROR</u>;
&nbsp;
fn void <strong>main</strong>()
{
    int? i = <u>MY_ERROR?</u>;
&nbsp;
    if (catch excuse = i)
    {
        io::printfn("Fault: %s", excuse);
    } else {
        io::printf("i=%d\n", i);
    }
}
</pre>

<p>Výsledek získaný po překladu a spuštění tohoto příkladu:</p>

<pre>
Fault: error_handling::MY_ERROR
</pre>

<p>Samozřejmě lze použít i alternativní zápis bez větve
<strong>else</strong>:</p>

<pre>
module error_handling;
import std::io;
&nbsp;
<u>faultdef MY_ERROR</u>;
&nbsp;
fn void <strong>main</strong>()
{
    int? i = MY_ERROR?;
&nbsp;
    if (catch excuse = i)
    {
        io::printfn("Fault: %s", excuse);
        return;
    }
    io::printf("i=%d\n", i);
}
</pre>

<p>Výsledky:</p>

<pre>
Fault: error_handling::MY_ERROR
</pre>



<p><a name="k06"></a></p>
<h2 id="k06">6. Vynucení přístupu k&nbsp;hodnotě operátorem !!</h2>

<p>Programovací jazyk C3 vývojářům nabízí speciální operátor reprezentovaný
dvojicí znaků <strong>!!</strong>, který je zapisovaný za jméno proměnné nebo
výrazu typu <i>Optional</i>. Tento operátor se pokouší provádět
&bdquo;unwrapping&ldquo; hodnoty, která je do <i>Optional</i> zabalena &ndash;
počítá tedy optimisticky s&nbsp;tím, že proměnná skutečně hodnotu obsahuje (a
nikoli chybu). Pokud proměnná/výraz skutečně obsahuje běžnou hodnotu, bude
výsledkem tato hodnota, což si ostatně velmi snadno ověříme v&nbsp;dalším
demonstračním příkladu:</p>

<pre>
module error_handling;
import std::io;
&nbsp;
faultdef MY_ERROR;
&nbsp;
fn void main()
{
    int? i = 42;
&nbsp;
    io::printf("i=%d\n", <u>i!!</u>);
}
</pre>

<p>Vzhledem k&nbsp;tomu, že proměnná <strong>i</strong> (typu <i>Optional</i>)
obsahuje běžnou hodnotu 42, je tato hodnota výrazem <strong>i!!</strong>
vyhodnocena a vrácena:</p>

<pre>
i=42
</pre>



<p><a name="k07"></a></p>
<h2 id="k07">7. Chování operátoru !! v&nbsp;případě, že je namísto hodnoty uložena informace o chybě</h2>

<p>Pokud naopak do proměnné <strong>i</strong> namísto běžné hodnoty uložíme
informaci o chybě a budeme chtít provést operaci typu <i>unwrap</i> nad touto
proměnnou, musí runtime programovacího jazyka C3 na tuto skutečnost nějakým
vhodným způsobem zareagovat &ndash; zde konkrétně tak, že dojde k&nbsp;běhové
chybě a program zhavaruje:</p>

<pre>
module error_handling;
import std::io;
&nbsp;
faultdef MY_ERROR;
&nbsp;
fn void <strong>main</strong>()
{
    int? i = MY_ERROR?;
&nbsp;
    io::printf("i=%d\n", i!!);
}
</pre>

<p>Z&nbsp;výpisu, který se zobrazí po pádu programu, lze dohledat, k&nbsp;jaké
chybě došlo i v&nbsp;jakém místě programu musíme hledat příslušný programový
řádek:</p>

<pre>
ERROR: 'Unexpected fault 'error_handling::MY_ERROR' was unwrapped!'
  in std.core.builtin.default_panic (/home/ptisnovs/xy/c3c/build/lib/std/core/builtin.c3:175) [/home/ptisnovs/src/c3-examples/c3-errors-handling/error_handling]
  in std.core.builtin.panicf (/home/ptisnovs/xy/c3c/build/lib/std/core/builtin.c3:231) [/home/ptisnovs/src/c3-examples/c3-errors-handling/error_handling]
  in error_handling.main (/home/ptisnovs/src/c3-examples/c3-errors-handling/08_force_unwrap.c3:10) [/home/ptisnovs/src/c3-examples/c3-errors-handling/error_handling]
  in @main_to_void_main (/home/ptisnovs/xy/c3c/build/lib/std/core/private/main_stub.c3:18) [/home/ptisnovs/src/c3-examples/c3-errors-handling/error_handling] [inline]
  in main (/home/ptisnovs/src/c3-examples/c3-errors-handling/08_force_unwrap.c3:6) [/home/ptisnovs/src/c3-examples/c3-errors-handling/error_handling]
  in __libc_start_call_main (source unavailable) [/lib64/libc.so.6]
  in __libc_start_main_alias_2 (source unavailable) [/lib64/libc.so.6]
  in _start (source unavailable) [/home/ptisnovs/src/c3-examples/c3-errors-handling/error_handling]
</pre>



<p><a name="k08"></a></p>
<h2 id="k08">8. Praktické použití: výpočet faktoriálu bez vracení informace o chybě</h2>

<p>Podívejme se nyní na praktické použití datového typu, který může nést
informaci o hodnotě nebo naopak informaci o chybě. Typickým příkladem je
výpočet faktoriálu, přičemž samotný faktoriál je definován pouze pro kladné
hodnoty. Otázkou tedy je, &bdquo;co&ldquo; se má vrátit v&nbsp;případě, že
budeme chtít počítat faktoriál pro zápornou hodnotu (to by ještě bylo možné
obejít vhodným typem parametru) nebo pro příliš vysokou hodnotu. První řešení
spočívá v&nbsp;tom, že budeme nekorektní parametr do jisté míry ignorovat a
vrátíme nějakou &bdquo;magickou&ldquo; hodnotu (nebo test na chybný vstup vůbec
neprovedeme):</p>

<pre>
module error_handling;
import std::io;
&nbsp;
fn int <strong>factorial</strong>(int n)
{
    int result = 1;
    for (int i = 1; i &lt;= n; ++i)
    {
        result *= i;
    }
    return result;
}
&nbsp;
fn void <strong>main</strong>()
{
    for (int n = 10; n &gt;= -10; n--)
    {
        io::printf("%d! = %d\n", n, factorial(n));
    }
}
</pre>

<p>Výpočet faktoriálu pro vstupní hodnoty v&nbsp;rozmezí 10..-10 dopadne
v&nbsp;tomto případě následovně:</p>

<pre>
10! = 3628800
9! = 362880
8! = 40320
7! = 5040
6! = 720
5! = 120
4! = 24
3! = 6
2! = 2
1! = 1
0! = 1
-1! = 1
-2! = 1
-3! = 1
-4! = 1
-5! = 1
-6! = 1
-7! = 1
-8! = 1
-9! = 1
-10! = 1
</pre>

<p><div class="rs-tip-major">Poznámka: zde se tedy neplatný parametr do jisté
míry ignoroval a vrátila se hodnota 1.</div></p>



<p><a name="k09"></a></p>
<h2 id="k09">9. Výpočet faktoriálu s&nbsp;detekcí nekorektního vstupu</h2>

<p>Výpočet faktoriálu ovšem můžeme upravit tak, aby se detekovaly záporné
parametry a pokud je opravdu záporný parametr předán, vrátí se chybová hodnota
<strong>NEGATIVE_INPUT</strong>. Povšimněte si, že návratovou hodnotou funkce
pro výpočet faktoriálu, není typ <strong>int</strong> ale
<strong>int?</strong>:</p>

<pre>
module error_handling;
import std::io;
&nbsp;
faultdef NEGATIVE_INPUT;
&nbsp;
fn <u>int?</u> <strong>factorial</strong>(int n)
{
    if (n &lt; 0) {
        return NEGATIVE_INPUT?;
    }
    int result = 1;
    for (int i = 1; i &lt;= n; ++i)
    {
        result *= i;
    }
    return result;
}
&nbsp;
fn void <strong>main</strong>()
{
    for (int n = 10; n &gt;= -10; n--)
    {
        int? result = factorial(n);
        if (catch excuse = result)
        {
            io::printfn("Fault: %s: %d", excuse, n);
        } else {
            io::printf("%d!=%d\n", n, result);
        }
    }
}
</pre>

<p>V&nbsp;programu (<strong>main</strong>) korektně reagujeme na chybové
hodnoty vrácené z&nbsp;funkce <strong>factorial</strong>:</p>

<pre>
10!=3628800
9!=362880
8!=40320
7!=5040
6!=720
5!=120
4!=24
3!=6
2!=2
1!=1
0!=1
Fault: error_handling::NEGATIVE_INPUT: -1
Fault: error_handling::NEGATIVE_INPUT: -2
Fault: error_handling::NEGATIVE_INPUT: -3
Fault: error_handling::NEGATIVE_INPUT: -4
Fault: error_handling::NEGATIVE_INPUT: -5
Fault: error_handling::NEGATIVE_INPUT: -6
Fault: error_handling::NEGATIVE_INPUT: -7
Fault: error_handling::NEGATIVE_INPUT: -8
Fault: error_handling::NEGATIVE_INPUT: -9
Fault: error_handling::NEGATIVE_INPUT: -10
</pre>



<p><a name="k10"></a></p>
<h2 id="k10">10. Pokus o přímý přístup k&nbsp;vrácené hodnotě operátorem !!</h2>

<p>Ještě si pro úplnost ukažme, jak dopadne pokus o unwrapping vrácené hodnoty
bez testování, zda nebyla vrácena chyba:</p>

<pre>
module error_handling;
import std::io;
&nbsp;
faultdef NEGATIVE_INPUT;
&nbsp;
fn <u>int?</u> <strong>factorial</strong>(int n)
{
    if (n &lt; 0) {
        return NEGATIVE_INPUT?;
    }
    int result = 1;
    for (int i = 1; i &lt;= n; ++i)
    {
        result *= i;
    }
    return result;
}
&nbsp;
fn void <strong>main</strong>()
{
    for (int n = 10; n &gt;= -10; n--)
    {
        int result = <u>factorial(n)!!</u>;
        io::printf("%d!=%d\n", n, result);
    }
}
</pre>

<p>Takto upravený program po svém překladu a spuštění podle očekávání
zhavaruje:</p>

<pre>
ERROR: 'Unexpected fault 'error_handling::NEGATIVE_INPUT' was unwrapped!'
  in std.core.builtin.default_panic (/home/ptisnovs/xy/c3c/build/lib/std/core/builtin.c3:175) [/home/ptisnovs/src/c3-examples/c3-errors-handling/error_handling]
  in std.core.builtin.panicf (/home/ptisnovs/xy/c3c/build/lib/std/core/builtin.c3:231) [/home/ptisnovs/src/c3-examples/c3-errors-handling/error_handling]
  in error_handling.main (/home/ptisnovs/src/c3-examples/c3-errors-handling/11_factorial.c3:23) [/home/ptisnovs/src/c3-examples/c3-errors-handling/error_handling]
  in @main_to_void_main (/home/ptisnovs/xy/c3c/build/lib/std/core/private/main_stub.c3:18) [/home/ptisnovs/src/c3-examples/c3-errors-handling/error_handling] [inline]
  in main (/home/ptisnovs/src/c3-examples/c3-errors-handling/11_factorial.c3:19) [/home/ptisnovs/src/c3-examples/c3-errors-handling/error_handling]
  in __libc_start_call_main (source unavailable) [/lib64/libc.so.6]
  in __libc_start_main_alias_2 (source unavailable) [/lib64/libc.so.6]
  in _start (source unavailable) [/home/ptisnovs/src/c3-examples/c3-errors-handling/error_handling]
Program interrupted by signal 4.
</pre>



<p><a name="k11"></a></p>
<h2 id="k11">11. Konstrukce <strong>defer</strong></h2>

<p>Další jazykovou konstrukcí, která slouží k&nbsp;ovlivnění toku programu
(<i>control flow</i>), je příkaz (resp.&nbsp;přesněji řečeno programová
konstrukce) reprezentovaná klíčovým slovem <strong>defer</strong>. Touto
konstrukcí je možné zaregistrovat požadavek na volání nějakého uceleného
programového kódu (tj.&nbsp;typicky běžné funkce či anonymní funkce) do
zásobníku, jehož obsah se vykoná při odchodu z&nbsp;toho bloku, ve kterém je
příkaz <strong>defer</strong> použit. Z&nbsp;tohoto důvodu se tato technika
nazývá <i>odložené volání</i> funkce nebo anonymní funkce. Předchozí dvě věty
sice mohou znít poměrně složitě, zvláště pokud jste se s&nbsp;tímto konceptem
dříve nesetkali, ale samotné použití konstrukce <strong>defer</strong> je ve
skutečnosti poměrně přímočaré, jak si to ostatně ukážeme v&nbsp;demonstračních
příkladech.</p>

<p><div class="rs-tip-major">Poznámka: pozor &ndash; konstrukce
<strong>defer</strong> má v&nbsp;jazyce C3 odlišnou sémantiku, než stejné
klíčové slovo v&nbsp;jazyce Go!</div></p>



<p><a name="k12"></a></p>
<h2 id="k12">12. Základní porovnání konstrukce <strong>defer</strong> v&nbsp;jazycích Go a C3</h2>

<p>Konstrukce <strong>defer</strong> je velmi užitečnou součástí programovacího
jazyka Go zmíněného v&nbsp;předchozí kapitole. Ukažme si tedy alespoň ve
stručnosti, jak se tato konstrukce v&nbsp;Go používá:</p>

<pre>
package main
&nbsp;
import "fmt"
&nbsp;
func <strong>main</strong>() {
        <u>defer</u> fmt.Println("Too late")
&nbsp;
        fmt.Println("Hello")
}
</pre>

<p>Z&nbsp;výše zobrazeného zdrojového kódu tohoto příkladu je patrné, že ve
funkci <strong>main</strong> je použit příkaz <strong>defer</strong>, kterým
požadujeme, aby se při ukončování funkce <strong>main</strong> zavolala jiná
funkce, konkrétně funkce nazvaná <strong>fmt.Println</strong> (které se
v&nbsp;tomto případě předá jediný parametr). Tím, že je před volání funkce
<strong>fmt.Println</strong> zapsáno klíčové slovo <strong>defer</strong>,
dojde k&nbsp;onomu odložení volání &ndash; runtime systém si jen zapamatuje, že
má tuto funkci zavolat později.</p>

<p>Z&nbsp;chování programu je parné, že došlo k&nbsp;odloženému volání
funkce:</p>

<pre>
Hello
Too late
</pre>

<p>V&nbsp;programovacím jazyku C3 se konstrukce <strong>defer</strong> zapisuje
prakticky stejným způsobem, jako tomu bylo v&nbsp;Go. Ostatně neuškodí krátké
porovnání:</p>

<pre>
module error_handling;
import std::io;
&nbsp;
fn void <strong>main</strong>()
{
    <u>defer io::printn("Too late")</u>;
    io::printn("Hello");
}
</pre>

<p>Opět se podívejme, jaké zprávy (a v&nbsp;jakém pořadí) se vypíšou po
překladu a spuštění tohoto demonstračního příkladu:</p>

<pre>
Hello
Too late
</pre>



<p><a name="k13"></a></p>
<h2 id="k13">13. Proč byla konstrukce <strong>defer</strong> do jazyka C3 přidána?</h2>

<p>Nyní tedy víme (prozatím alespoň ve stručnosti), jakým způsobem se
konstrukce <strong>defer</strong> zapisuje a používá, ale musíme si samozřejmě
vysvětlit, proč vůbec v&nbsp;jazyku C3 existuje. V&nbsp;mnoha programech je
totiž nutné nějakým způsobem a za jakýchkoli okolností uzavírat určité
prostředky (<i>resources</i>). Může se jednat o připojení k&nbsp;databázi,
otevřené připojení ke klientovi, otevřený soubor atd. A právě toto uzavírání
prostředků lze poměrně elegantním způsobem realizovat v&nbsp;bloku či
v&nbsp;několika blocích <strong>defer</strong>. Jedná se vlastně o zobecnění
programového bloku typu <strong>finally</strong> používaného v&nbsp;programové
konstrukci <strong>try-catch-finally</strong> v&nbsp;některých jiných
programovacích jazycích.</p>

<p><div class="rs-tip-major">Poznámka: konstrukci <strong>defer</strong>
s&nbsp;funkcí pro uzavření nějakého prostředku (souboru, ...) do zdrojového
kódu zapište na nejbližší logické místo, například ihned po příkazu, který
soubor otevírá. Tak dáte případným čtenářům kódu jasně najevo, jakým způsobem
ošetřujete chyby &ndash; toto s&nbsp;klasickými bloky
<strong>try-catch-finally</strong> obecně nelze provést.</div></p>



<p><a name="k14"></a></p>
<h2 id="k14">14. Pořadí volání příkazů zaregistrovaných s&nbsp;využitím příkazu <strong>defer</strong></h2>

<p>Nic nám pochopitelně nebrání použít v&nbsp;rámci jedné funkce (nebo
jakéhokoli jiného bloku) hned několik příkazů <strong>defer</strong>. Zajímavé
bude ovšem zjistit, jak se bude tato funkce chovat při spuštění programu,
tj.&nbsp;v&nbsp;<i>runtime</i>. Můžeme si to snadno otestovat, protože již
víme, že v&nbsp;bloku <strong>defer</strong> je možné funkci (či obecně kódu
zde zapsaném) předat libovolné argumenty. To mj.&nbsp;znamená, že můžeme
<strong>defer</strong> použít například v&nbsp;programové smyčce atd. Ovšem my
se obejdeme bez smyčky &ndash; pouze zaregistrujeme tři odložené příkazy:</p>

<pre>
module error_handling;
import std::io;
&nbsp;
fn void <strong>main</strong>()
{
    <u>defer io::printn("Defer #1")</u>;
    <u>defer io::printn("Defer #2")</u>;
    <u>defer io::printn("Defer #3")</u>;
    io::printn("Hello");
}
</pre>

<p>Ze zobrazených výsledků je patrné, že se odložené příkazy volají
v&nbsp;opačném pořadí, než v&nbsp;jakém byly zaregistrovány. Je tomu tak
z&nbsp;toho důvodu, že tyto příkazy jsou uloženy do zásobníku, tedy do
struktury typu LIFO (<i>Last In First Out</i>):</p>

<pre>
Hello
Defer #3
Defer #2
Defer #1
</pre>



<p><a name="k15"></a></p>
<h2 id="k15">15. Sémantika <strong>defer</strong> v&nbsp;jazyce Go</h2>

<p>V&nbsp;programovacím jazyce Go se odložené příkazy vykonají (v&nbsp;opačném
pořadí) vždy při opouštění funkce nebo metody, a to nezávisle na tom, zda byly
zapsány v&nbsp;nějakém (zanořeném) bloku kódu. Ukažme si to na jednoduchém
demonstračním příkladu se třemi bloky <strong>defer</strong>, které jsou
definovány na úrovni funkce <strong>main</strong>, v&nbsp;jednom zanořeném
bloku a nakonec v&nbsp;bloku zanořeném do nějakého jiného bloku:</p>

<pre>
package main
&nbsp;
import "fmt"
&nbsp;
func <strong>main</strong>() {
    fmt.Println("Hello")
    <u>defer fmt.Println("Defer #1")</u>
    {
        <u>defer fmt.Println("Defer #2")</u>
        {
            <u>defer fmt.Println("Defer #3")</u>
        }
    }
    fmt.Println("Bye")
}
</pre>

<p>Pořadí zobrazení zpráv po spuštění tohoto příkladu:</p>

<pre>
Hello
Bye
Defer #3
Defer #2
Defer #1
</pre>

<p>Z&nbsp;tohoto výpisu je patrné, že skutečně nezáleží na tom, zda je
<strong>defer</strong> použit přímo v&nbsp;dané funkci nebo v&nbsp;nějakém
vloženém bloku.</p>



<p><a name="k16"></a></p>
<h2 id="k16">16. Sémantika <strong>defer</strong> v&nbsp;jazyce C3</h2>

<p>Programovací jazyk C3 se chová odlišně od jazyka Go, protože odložené
příkazy (<strong>defer</strong>) jsou zavolány nikoli na konci funkce, ale na
konci <i>každého bloku</i>. To tedy znamená, že i když je syntaxe zápisu bloků
<strong>defer</strong> v&nbsp;obou jazycích totožná, sémantika (chování)
v&nbsp;runtime může být zcela odlišné. Pokusme se přepsat příklad <a
href="#k15">z&nbsp;předchozí kapitoly</a> z&nbsp;Go do C3:</p>

<pre>
module error_handling;
import std::io;
&nbsp;
fn void <strong>main</strong>()
{
    io::printn("Hello");
    <u>defer io::printn("Defer #1")</u>;
    {
        <u>defer io::printn("Defer #2")</u>;
        {
            <u>defer io::printn("Defer #3")</u>;
        }
    }
    io::printn("Bye");
}
</pre>

<p>Nyní je ze zobrazených zpráv patrné, že třetí a druhý odložený příkaz se
vykonají ještě před výpisem zprávy <strong>Bye</strong> a pouze první odložený
příkaz je skutečně zavolán při ukončování funkce (tělo funkce je samo o sobě
blokem):</p>

<pre>
Hello
Defer #3
Defer #2
Bye
Defer #1
</pre>



<p><a name="k17"></a></p>
<h2 id="k17">17. Konstrukce <strong>defer</strong> a <strong>return</strong></h2>

<p>Ještě si ovšem musíme ukázat jednu kombinaci jazykových konstrukcí a to
konkrétně kombinaci <strong>defer</strong> a <strong>return</strong>.
Konstrukce <strong>return</strong> ukončuje běh funkce a tudíž se vykonají i
odložené příkazy, ovšem dokážeme tímto způsobem například modifikovat
návratovou hodnotu funkce? Vyzkoušejme si to:</p>

<pre>
module error_handling;
import std::io;
&nbsp;
fn int <strong>function</strong>()
{
    int a = 10;
&nbsp;
    io::printn("Hello");
&nbsp;
    defer a++;
    io::printn("Bye");
&nbsp;
    return a;
}
&nbsp;
fn void <strong>main</strong>()
{
    io::printn(function());
}
</pre>

<p>Z&nbsp;výpisu je patrné, že takto jednoduché to nebude:</p>

<pre>
Hello
Bye
10
</pre>

<p><div class="rs-tip-major">Poznámka: příště si ukážeme trik, jak dosáhnou
modifikace návratové hodnoty blokem <strong>defer</strong>.</div></p>



<p><a name="k18"></a></p>
<h2 id="k18">18. Funkce volané na začátku a konci procesu</h2>

<p>Konstrukce <strong>defer</strong> umožňuje modifikovat pořadí provádění kódu
na úrovni jednotlivých příkazů (<i>statement</i>). Programovací jazyk C3 kromě
toho podporuje i označení vybraných funkcí pomocí <strong>@init</strong> a
<strong>@finalizer</strong>. Funkce označená jako <strong>@init</strong> bude
provedena na začátku procesu a pochopitelně funkce označená
<strong>@finalizer</strong> na konci procesu. Pokusme se tedy jednotlivé
způsoby zkombinovat do jednoho (umělého) příkladu:</p>

<pre>
import std::io;
&nbsp;
fn void <strong>main</strong>()
{
    defer io::printf("world");
&nbsp;
    io::printf(", ");
}
&nbsp;
fn void <strong>hello</strong>() <u>@init</u>
{
    io::printf("Hello");
}
&nbsp;
fn void <strong>world</strong>() <u>@finalizer</u>
{
    io::printn("!");
}
</pre>

<p>Tento demonstrační příklad by měl po svém spuštění vypsat klasickou
zprávu:</p>

<pre>
Hello, world!
</pre>



<p><a name="k19"></a></p>
<h2 id="k19">19. Repositář s&nbsp;demonstračními příklady</h2>

<p>Demonstrační příklady vytvořené pro nejnovější verzi programovacího jazyka
C3 byly uloženy do repositáře dostupného na adrese <a
href="https://github.com/tisnik/c3-examples">https://github.com/tisnik/c3-examples</a>.
Následují odkazy na jednotlivé příklady (či jejich nedokončené části).</p>

<p>Demonstrační příklady <a
href="https://www.root.cz/clanky/programovaci-jazyk-c3-evoluce-nikoli-revoluce/">z&nbsp;prvního
článku o programovacím jazyku C3</a>:</p>

<table>
<tr><th> #</th><th>Příklad</th><th>Stručný popis</th><th>Adresa</th></tr>
<tr><td> 1</td><td>factorial.c3</td><td>realizace výpočtu faktoriálu</td><td><a href="https://github.com/tisnik/c3-examples/blob/master/introduction/factorial.c3">https://github.com/tisnik/c3-examples/blob/master/introduction/factorial.c3</a></td></tr>
<tr><td> 2</td><td>factorial_macro.c3</td><td>výpočet faktoriálu konkrétní hodnoty implementovaný formou makra</td><td><a href="https://github.com/tisnik/c3-examples/blob/master/introduction/factorial_macro.c3">https://github.com/tisnik/c3-examples/blob/master/introduction/factorial_macro.c3</a></td></tr>
<tr><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td></tr>
<tr><td> 3</td><td>swap_macro.c3</td><td>makro realizující prohození dvou hodnot</td><td><a href="https://github.com/tisnik/c3-examples/blob/master/introduction/swap_macro.c3">https://github.com/tisnik/c3-examples/blob/master/introduction/swap_macro.c3</a></td></tr>
<tr><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td></tr>
<tr><td> 4</td><td>renderer.c</td><td>výpočet a vykreslení Juliovy množiny implementovaný v&nbsp;jazyku C</td><td><a href="https://github.com/tisnik/c3-examples/blob/master/introduction/renderer.c">https://github.com/tisnik/c3-examples/blob/master/introduction/renderer.c</a></td></tr>
<tr><td> 5</td><td>renderer_v1.c3</td><td>definice datové struktury s&nbsp;rozměry rastrového obrázku a skeleton všech funkcí</td><td><a href="https://github.com/tisnik/c3-examples/blob/master/introduction/renderer_v1.c3">https://github.com/tisnik/c3-examples/blob/master/introduction/renderer_v1.c3</a></td></tr>
<tr><td> 6</td><td>renderer_v2.c3</td><td>anotace parametrů funkcí typu ukazatel (<i>pointer</i>)</td><td><a href="https://github.com/tisnik/c3-examples/blob/master/introduction/renderer_v2.c3">https://github.com/tisnik/c3-examples/blob/master/introduction/renderer_v2.c3</a></td></tr>
<tr><td> 7</td><td>renderer_v3.c3</td><td>statická kontrola, zda se nepředávají neinicializované ukazatele</td><td><a href="https://github.com/tisnik/c3-examples/blob/master/introduction/renderer_v3.c3">https://github.com/tisnik/c3-examples/blob/master/introduction/renderer_v3.c3</a></td></tr>
<tr><td> 8</td><td>renderer_v4.c3</td><td>runtime kontrola, zda se nepředávají neinicializované ukazatele</td><td><a href="https://github.com/tisnik/c3-examples/blob/master/introduction/renderer_v4.c3">https://github.com/tisnik/c3-examples/blob/master/introduction/renderer_v4.c3</a></td></tr>
<tr><td> 9</td><td>renderer_v5.c3</td><td>první (nekorektní) varianta funkce pro inicializaci barvové palety</td><td><a href="https://github.com/tisnik/c3-examples/blob/master/introduction/renderer_v5.c3">https://github.com/tisnik/c3-examples/blob/master/introduction/renderer_v5.c3</a></td></tr>
<tr><td>10</td><td>renderer_v6.c3</td><td>druhá (korektní) varianta funkce pro inicializaci barvové palety</td><td><a href="https://github.com/tisnik/c3-examples/blob/master/introduction/renderer_v6.c3">https://github.com/tisnik/c3-examples/blob/master/introduction/renderer_v6.c3</a></td></tr>
<tr><td>11</td><td>renderer_v7.c3</td><td>volání knihovní I/O funkce a volání nativní céčkovské funkce</td><td><a href="https://github.com/tisnik/c3-examples/blob/master/introduction/renderer_v7.c3">https://github.com/tisnik/c3-examples/blob/master/introduction/renderer_v7.c3</a></td></tr>
<tr><td>12</td><td>renderer_v8.c3</td><td>plně funkční program pro výpočet a vykreslení Juliovy množiny</td><td><a href="https://github.com/tisnik/c3-examples/blob/master/introduction/renderer_v8.c3">https://github.com/tisnik/c3-examples/blob/master/introduction/renderer_v8.c3</a></td></tr>
</table>

<p>Demonstrační příklady <a
href="https://www.root.cz/clanky/programovaci-jazyk-c3-datove-typy-pro-moderni-architektury/">ze
druhého článku o jazyku C3</a>:</p>

<table>
<tr><th> #</th><th>Příklad</th><th>Stručný popis</th><th>Adresa</th></tr>
<tr><td>13</td><td>01_just_main.c3</td><td>struktura nejjednoduššího programu obsahujícího pouze prázdnou funkci <strong>main</strong></td><td><a href="https://github.com/tisnik/c3-examples/blob/master/c3-basics/01_just_main.c3">https://github.com/tisnik/c3-examples/blob/master/c3-basics/01_just_main.c3</a></td></tr>
<tr><td>14</td><td>02_module_name.c3</td><td>struktura programu s&nbsp;uvedeným plným jménem modulu</td><td><a href="https://github.com/tisnik/c3-examples/blob/master/c3-basics/02_module_name.c3">https://github.com/tisnik/c3-examples/blob/master/c3-basics/02_module_name.c3</a></td></tr>
<tr><td>15</td><td>03_hello_world.c3</td><td>klasický program typu &bdquo;Hello, world!&ldquo; napsaný v&nbsp;jazyku C3</td><td><a href="https://github.com/tisnik/c3-examples/blob/master/c3-basics/03_hello_world.c3">https://github.com/tisnik/c3-examples/blob/master/c3-basics/03_hello_world.c3</a></td></tr>
<tr><td>16</td><td>04_exit_value.c3</td><td>ukončení procesu s&nbsp;předáním návratového kódu zpět volajícímu programu</td><td><a href="https://github.com/tisnik/c3-examples/blob/master/c3-basics/04_exit_value.c3">https://github.com/tisnik/c3-examples/blob/master/c3-basics/04_exit_value.c3</a></td></tr>
<tr><td>17</td><td>05_c_function.c3</td><td>zavolání funkce definované v&nbsp;knihovně programovacího jazyka C</td><td><a href="https://github.com/tisnik/c3-examples/blob/master/c3-basics/05_c_function.c3">https://github.com/tisnik/c3-examples/blob/master/c3-basics/05_c_function.c3</a></td></tr>
<tr><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td></tr>
<tr><td>18</td><td>06_bool_type.c3</td><td>definice proměnných typu <i>pravdivostní hodnota</i> (<strong>bool</strong>)</td><td><a href="https://github.com/tisnik/c3-examples/blob/master/c3-basics/06_bool_type.c3">https://github.com/tisnik/c3-examples/blob/master/c3-basics/06_bool_type.c3</a></td></tr>
<tr><td>19</td><td>07_int_to_bool.c3</td><td>implicitní převod hodnoty typu <strong>int</strong> na pravdivostní hodnotu (nekorektní řešení)</td><td><a href="https://github.com/tisnik/c3-examples/blob/master/c3-basics/07_int_to_bool.c3">https://github.com/tisnik/c3-examples/blob/master/c3-basics/07_int_to_bool.c3</a></td></tr>
<tr><td>20</td><td>08_int_to_bool.c3</td><td>explicitní převod hodnoty typu <strong>int</strong> na pravdivostní hodnotu (korektní řešení)</td><td><a href="https://github.com/tisnik/c3-examples/blob/master/c3-basics/08_int_to_bool.c3">https://github.com/tisnik/c3-examples/blob/master/c3-basics/08_int_to_bool.c3</a></td></tr>
<tr><td>21</td><td>09_int_to_bool.c3</td><td>explicitní převod hodnoty typu <strong>int</strong> na pravdivostní hodnotu (nekorektní řešení)</td><td><a href="https://github.com/tisnik/c3-examples/blob/master/c3-basics/09_int_to_bool.c3">https://github.com/tisnik/c3-examples/blob/master/c3-basics/09_int_to_bool.c3</a></td></tr>
<tr><td>22</td><td>10_bool_sizeof.c3</td><td>zjištění velikosti paměti obsazené hodnotou typu <strong>bool</strong></td><td><a href="https://github.com/tisnik/c3-examples/blob/master/c3-basics/10_bool_sizeof.c3">https://github.com/tisnik/c3-examples/blob/master/c3-basics/10_bool_sizeof.c3</a></td></tr>
<tr><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td></tr>
<tr><td>23</td><td>11_int_types.c3</td><td>definice proměnných typu <i>celé číslo se znaménkem</i> s&nbsp;různou bitovou šířkou</td><td><a href="https://github.com/tisnik/c3-examples/blob/master/c3-basics/11_int_types.c3">https://github.com/tisnik/c3-examples/blob/master/c3-basics/11_int_types.c3</a></td></tr>
<tr><td>24</td><td>12_uint_types.c3</td><td>definice proměnných typu <i>celé číslo bez znaménka</i> s&nbsp;různou bitovou šířkou</td><td><a href="https://github.com/tisnik/c3-examples/blob/master/c3-basics/12_uint_types.c3">https://github.com/tisnik/c3-examples/blob/master/c3-basics/12_uint_types.c3</a></td></tr>
<tr><td>25</td><td>13_no_suffixes.c3</td><td>celočíselné konstanty bez uvedení suffixu (bitové šířky)</td><td><a href="https://github.com/tisnik/c3-examples/blob/master/c3-basics/13_no_suffixes.c3">https://github.com/tisnik/c3-examples/blob/master/c3-basics/13_no_suffixes.c3</a></td></tr>
<tr><td>26</td><td>14_suffixes.c3</td><td>celočíselné konstanty s&nbsp;uvedením sufficu (bitové šířky)</td><td><a href="https://github.com/tisnik/c3-examples/blob/master/c3-basics/14_suffixes.c3">https://github.com/tisnik/c3-examples/blob/master/c3-basics/14_suffixes.c3</a></td></tr>
<tr><td>27</td><td>15_int_sizeof.c3</td><td>zjištění velikosti paměti obsazené celočíselnými hodnotami se znaménkem</td><td><a href="https://github.com/tisnik/c3-examples/blob/master/c3-basics/15_int_sizeof.c3">https://github.com/tisnik/c3-examples/blob/master/c3-basics/15_int_sizeof.c3</a></td></tr>
<tr><td>28</td><td>16_uint_sizeof.c3</td><td>zjištění velikosti paměti obsazené celočíselnými hodnotami bez znaménka</td><td><a href="https://github.com/tisnik/c3-examples/blob/master/c3-basics/16_uint_sizeof.c3">https://github.com/tisnik/c3-examples/blob/master/c3-basics/16_uint_sizeof.c3</a></td></tr>
<tr><td>29</td><td>17_int_conversions.c3</td><td>korektní převody mezi celočíselnými hodnotami s&nbsp;různou bitovou šířkou</td><td><a href="https://github.com/tisnik/c3-examples/blob/master/c3-basics/17_int_conversions.c3">https://github.com/tisnik/c3-examples/blob/master/c3-basics/17_int_conversions.c3</a></td></tr>
<tr><td>30</td><td>18_int_conversions.c3</td><td>nekorektní převody mezi celočíselnými hodnotami s&nbsp;různou bitovou šířkou</td><td><a href="https://github.com/tisnik/c3-examples/blob/master/c3-basics/18_int_conversions.c3">https://github.com/tisnik/c3-examples/blob/master/c3-basics/18_int_conversions.c3</a></td></tr>
<tr><td>31</td><td>19_int_conversions.c3</td><td>explicitní převody a přetečení hodnot</td><td><a href="https://github.com/tisnik/c3-examples/blob/master/c3-basics/19_int_conversions.c3">https://github.com/tisnik/c3-examples/blob/master/c3-basics/19_int_conversions.c3</a></td></tr>
<tr><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td></tr>
<tr><td>32</td><td>20_float_types.c3</td><td>definice proměnných typu <i>numerická hodnota s&nbsp;plovoucí řádovou čárkou (tečkou)</i></td><td><a href="https://github.com/tisnik/c3-examples/blob/master/c3-basics/20_float_types.c3">https://github.com/tisnik/c3-examples/blob/master/c3-basics/20_float_types.c3</a></td></tr>
<tr><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td></tr>
<tr><td>33</td><td>21_vector_type.c3</td><td>definice vektoru obsahujícího celočíselné hodnoty</td><td><a href="https://github.com/tisnik/c3-examples/blob/master/c3-basics/21_vector_type.c3">https://github.com/tisnik/c3-examples/blob/master/c3-basics/21_vector_type.c3</a></td></tr>
<tr><td>34</td><td>22_vector_operations.c3</td><td>základní operace s&nbsp;celými vektory</td><td><a href="https://github.com/tisnik/c3-examples/blob/master/c3-basics/22_vector_operations.c3">https://github.com/tisnik/c3-examples/blob/master/c3-basics/22_vector_operations.c3</a></td></tr>
<tr><td>35</td><td>23_vector_sizes.c3</td><td>zjištění a tisk velikosti vektorů (různé datové typy prvků vektorů, shodná délka)</td><td><a href="https://github.com/tisnik/c3-examples/blob/master/c3-basics/23_vector_sizes.c3">https://github.com/tisnik/c3-examples/blob/master/c3-basics/23_vector_sizes.c3</a></td></tr>
<tr><td>36</td><td>24_vector_sizes.c3</td><td>zjištění a tisk velikosti vektorů (stejné datové typy prvků vektorů, odlišná délka)</td><td><a href="https://github.com/tisnik/c3-examples/blob/master/c3-basics/24_vector_sizes.c3">https://github.com/tisnik/c3-examples/blob/master/c3-basics/24_vector_sizes.c3</a></td></tr>
</table>

<p>Demonstrační příklady použité <a
href="https://www.root.cz/clanky/programovaci-jazyk-c3-slozene-datove-typy-a-kontejnery/">ve
třetím článku o jazyku C3</a>:</p>

<table>
<tr><th> #</th><th>Příklad</th><th>Stručný popis</th><th>Adresa</th></tr>
<tr><td>37</td><td>01_vector_type.c3</td><td>definice vektoru, modifikace prvků vektoru, tisk obsahu celého vektoru</td><td><a href="https://github.com/tisnik/c3-examples/blob/master/c3-containers/01_vector_type.c3">https://github.com/tisnik/c3-examples/blob/master/c3-containers/01_vector_type.c3</a></td></tr>
<tr><td>38</td><td>02_vector_parameter.c3</td><td>předání vektoru do funkce hodnotou</td><td><a href="https://github.com/tisnik/c3-examples/blob/master/c3-containers/02_vector_parameter.c3">https://github.com/tisnik/c3-examples/blob/master/c3-containers/02_vector_parameter.c3</a></td></tr>
<tr><td>39</td><td>03_vector_pointer.c3</td><td>předání vektoru do funkce odkazem (přes ukazatel)</td><td><a href="https://github.com/tisnik/c3-examples/blob/master/c3-containers/03_vector_pointer.c3">https://github.com/tisnik/c3-examples/blob/master/c3-containers/03_vector_pointer.c3</a></td></tr>
<tr><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td></tr>
<tr><td>40</td><td>04_array_type.c3</td><td>definice pole, modifikace prvků pole, tisk obsahu celého pole</td><td><a href="https://github.com/tisnik/c3-examples/blob/master/c3-containers/04_array_type.c3">https://github.com/tisnik/c3-examples/blob/master/c3-containers/04_array_type.c3</a></td></tr>
<tr><td>41</td><td>05_array_parameter.c3</td><td>předání pole do funkce hodnotou</td><td><a href="https://github.com/tisnik/c3-examples/blob/master/c3-containers/05_array_parameter.c3">https://github.com/tisnik/c3-examples/blob/master/c3-containers/05_array_parameter.c3</a></td></tr>
<tr><td>42</td><td>06_array_pointer.c3</td><td>předání pole do funkce odkazem (přes ukazatel)</td><td><a href="https://github.com/tisnik/c3-examples/blob/master/c3-containers/06_array_pointer.c3">https://github.com/tisnik/c3-examples/blob/master/c3-containers/06_array_pointer.c3</a></td></tr>
<tr><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td></tr>
<tr><td>43</td><td>07_slice_type.c3</td><td>vytvoření (konstrukce) řezu (<i>slice</i>)</td><td><a href="https://github.com/tisnik/c3-examples/blob/master/c3-containers/07_slice_type.c3">https://github.com/tisnik/c3-examples/blob/master/c3-containers/07_slice_type.c3</a></td></tr>
<tr><td>44</td><td>08_slice_parameter.c3</td><td>předání řezu do funkce</td><td><a href="https://github.com/tisnik/c3-examples/blob/master/c3-containers/08_slice_parameter.c3">https://github.com/tisnik/c3-examples/blob/master/c3-containers/08_slice_parameter.c3</a></td></tr>
<tr><td>45</td><td>09_slice_slicing.c3</td><td>konstrukce řezu z&nbsp;pole stejně pojmenovanou operací (řez od..do)</td><td><a href="https://github.com/tisnik/c3-examples/blob/master/c3-containers/09_slice_slicing.c3">https://github.com/tisnik/c3-examples/blob/master/c3-containers/09_slice_slicing.c3</a></td></tr>
<tr><td>46</td><td>10_slice_slicing.c3</td><td>konstrukce řezu z&nbsp;pole stejně pojmenovanou operací (záporné indexy)</td><td><a href="https://github.com/tisnik/c3-examples/blob/master/c3-containers/10_slice_slicing.c3">https://github.com/tisnik/c3-examples/blob/master/c3-containers/10_slice_slicing.c3</a></td></tr>
<tr><td>47</td><td>11_slice_slicing.c3</td><td>konstrukce řezu z&nbsp;pole stejně pojmenovanou operací (určení délky řezu)</td><td><a href="https://github.com/tisnik/c3-examples/blob/master/c3-containers/11_slice_slicing.c3">https://github.com/tisnik/c3-examples/blob/master/c3-containers/11_slice_slicing.c3</a></td></tr>
<tr><td>48</td><td>12_slice_of_slice.c3</td><td>konstrukce řezu z&nbsp;jiného řezu</td><td><a href="https://github.com/tisnik/c3-examples/blob/master/c3-containers/12_slice_of_slice.c3">https://github.com/tisnik/c3-examples/blob/master/c3-containers/12_slice_of_slice.c3</a></td></tr>
<tr><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td></tr>
<tr><td>49</td><td>13_list_type.c3</td><td>vytvoření (konstrukce) seznamu</td><td><a href="https://github.com/tisnik/c3-examples/blob/master/c3-containers/13_list_type.c3">https://github.com/tisnik/c3-examples/blob/master/c3-containers/13_list_type.c3</a></td></tr>
<tr><td>50</td><td>14_list_parameter.c3</td><td>předání seznamu do funkce</td><td><a href="https://github.com/tisnik/c3-examples/blob/master/c3-containers/14_list_parameter.c3">https://github.com/tisnik/c3-examples/blob/master/c3-containers/14_list_parameter.c3</a></td></tr>
<tr><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td></tr>
<tr><td>51</td><td>15_dynamic_array.c3</td><td>vytvoření (konstrukce) dynamicky alokovaného pole</td><td><a href="https://github.com/tisnik/c3-examples/blob/master/c3-containers/15_dynamic_array.c3">https://github.com/tisnik/c3-examples/blob/master/c3-containers/15_dynamic_array.c3</a></td></tr>
<tr><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td></tr>
<tr><td>52</td><td>16_string_type.c3</td><td>základní typ řetězce <strong>string</strong></td><td><a href="https://github.com/tisnik/c3-examples/blob/master/c3-containers/16_string_type.c3">https://github.com/tisnik/c3-examples/blob/master/c3-containers/16_string_type.c3</a></td></tr>
<tr><td>53</td><td>17_string_unicode.c3</td><td>Unicode znaky v&nbsp;řetězci typu <strong>string</strong></td><td><a href="https://github.com/tisnik/c3-examples/blob/master/c3-containers/17_string_unicode.c3">https://github.com/tisnik/c3-examples/blob/master/c3-containers/17_string_unicode.c3</a></td></tr>
<tr><td>54</td><td>18_zstring_type.c3</td><td>řetězce ukončené nulou (C-string, ASCIIZ)</td><td><a href="https://github.com/tisnik/c3-examples/blob/master/c3-containers/18_zstring_type.c3">https://github.com/tisnik/c3-examples/blob/master/c3-containers/18_zstring_type.c3</a></td></tr>
<tr><td>55</td><td>19_zstring_unicode.c3</td><td>Unicode znaky v&nbsp;řetězci typu <strong>zstring</strong></td><td><a href="https://github.com/tisnik/c3-examples/blob/master/c3-containers/19_zstring_unicode.c3">https://github.com/tisnik/c3-examples/blob/master/c3-containers/19_zstring_unicode.c3</a></td></tr>
<tr><td>56</td><td>20_string_comparison.c3</td><td>porovnávání obsahu řetězců</td><td><a href="https://github.com/tisnik/c3-examples/blob/master/c3-containers/20_string_comparison.c3">https://github.com/tisnik/c3-examples/blob/master/c3-containers/20_string_comparison.c3</a></td></tr>
</table>

<p>Demonstrační příklady <a
href="https://www.root.cz/clanky/programovaci-jazyk-c3-podminky-rozvetveni-a-programove-smycky/">z&nbsp;předchozího
článku</a> o jazyku C3:</p>

<table>
<tr><th> #</th><th>Příklad</th><th>Stručný popis</th><th>Adresa</th></tr>
<tr><td>57</td><td>01_program_stub.c3</td><td>struktura programu s&nbsp;uvedeným plným jménem modulu</td><td><a href="https://github.com/tisnik/c3-examples/blob/master/c3-control-flow/01_program_stub.c3">https://github.com/tisnik/c3-examples/blob/master/c3-control-flow/01_program_stub.c3</a></td></tr>
<tr><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td></tr>
<tr><td>58</td><td>02_if.c3</td><td>nejjednodušší forma rozvětvení založené na konstrukci <strong>if</strong></td><td><a href="https://github.com/tisnik/c3-examples/blob/master/c3-control-flow/02_if.c3">https://github.com/tisnik/c3-examples/blob/master/c3-control-flow/02_if.c3</a></td></tr>
<tr><td>59</td><td>03_if_else.c3</td><td>plné rozvětvení realizované konstrukcí <strong>if-else</strong></td><td><a href="https://github.com/tisnik/c3-examples/blob/master/c3-control-flow/03_if_else.c3">https://github.com/tisnik/c3-examples/blob/master/c3-control-flow/03_if_else.c3</a></td></tr>
<tr><td>60</td><td>04_improper_if.c3</td><td>nekorektní způsob zápisu programové konstrukce <strong>if-else</strong> (porovnání s&nbsp;jazykem C)</td><td><a href="https://github.com/tisnik/c3-examples/blob/master/c3-control-flow/04_improper_if.c3">https://github.com/tisnik/c3-examples/blob/master/c3-control-flow/04_improper_if.c3</a></td></tr>
<tr><td>61</td><td>05_improper_if.c3</td><td>nekorektní způsob zápisu programové konstrukce <strong>if-else</strong> (porovnání s&nbsp;jazykem C)</td><td><a href="https://github.com/tisnik/c3-examples/blob/master/c3-control-flow/05_improper_if.c3">https://github.com/tisnik/c3-examples/blob/master/c3-control-flow/05_improper_if.c3</a></td></tr>
<tr><td>62</td><td>06_if_else_if.c3</td><td>složitější rozvětvení založené na programové konstrukci <strong>if-else if-else</strong></td><td><a href="https://github.com/tisnik/c3-examples/blob/master/c3-control-flow/06_if_else_if.c3">https://github.com/tisnik/c3-examples/blob/master/c3-control-flow/06_if_else_if.c3</a></td></tr>
<tr><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td></tr>
<tr><td>63</td><td>07_switch_basic.c3</td><td>základní forma vícenásobného rozvětvení založeného na konstrukci <strong>switch-case</strong></td><td><a href="https://github.com/tisnik/c3-examples/blob/master/c3-control-flow/07_switch_basic.c3">https://github.com/tisnik/c3-examples/blob/master/c3-control-flow/07_switch_basic.c3</a></td></tr>
<tr><td>64</td><td>08_switch_basic.c3</td><td>větší množství podmínek a programová konstrukce <strong>switch-case</strong></td><td><a href="https://github.com/tisnik/c3-examples/blob/master/c3-control-flow/08_switch_basic.c3">https://github.com/tisnik/c3-examples/blob/master/c3-control-flow/08_switch_basic.c3</a></td></tr>
<tr><td>65</td><td>09_switch_condition.c3</td><td>podmínky zapsané ve větvích programové konstrukci <strong>switch-case</strong> vyhodnocované v&nbsp;čase běhu procesu</td><td><a href="https://github.com/tisnik/c3-examples/blob/master/c3-control-flow/09_switch_condition.c3">https://github.com/tisnik/c3-examples/blob/master/c3-control-flow/09_switch_condition.c3</a></td></tr>
<tr><td>66</td><td>10_switch_true.c3</td><td>konstrukce <strong>switch-case</strong> bez uvedeného výrazu za klíčovým slovem <strong>switch</strong></td><td><a href="https://github.com/tisnik/c3-examples/blob/master/c3-control-flow/10_switch_true.c3">https://github.com/tisnik/c3-examples/blob/master/c3-control-flow/10_switch_true.c3</a></td></tr>
<tr><td>67</td><td>11_switch_break.c3</td><td>zápis prázdné větve <strong>default</strong> v&nbsp;programové konstrukci <strong>switch-case</strong></td><td><a href="https://github.com/tisnik/c3-examples/blob/master/c3-control-flow/11_switch_break.c3">https://github.com/tisnik/c3-examples/blob/master/c3-control-flow/11_switch_break.c3</a></td></tr>
<tr><td>68</td><td>12_switch_nextcase.c3</td><td>pokračování ve vykonávání konstrukce <strong>switch-case</strong> vynucené klíčovým slovem <strong>nextcase</strong></td><td><a href="https://github.com/tisnik/c3-examples/blob/master/c3-control-flow/12_switch_nextcase.c3">https://github.com/tisnik/c3-examples/blob/master/c3-control-flow/12_switch_nextcase.c3</a></td></tr>
<tr><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td></tr>
<tr><td>69</td><td>13_for_loop.c3</td><td>základní forma programové smyčky realizované klíčovým slovem <strong>for</strong></td><td><a href="https://github.com/tisnik/c3-examples/blob/master/c3-control-flow/13_for_loop.c3">https://github.com/tisnik/c3-examples/blob/master/c3-control-flow/13_for_loop.c3</a></td></tr>
<tr><td>70</td><td>14_foreach_loop.c3</td><td>základní forma programové smyčky typu <strong>for-each</strong></td><td><a href="https://github.com/tisnik/c3-examples/blob/master/c3-control-flow/14_foreach_loop.c3">https://github.com/tisnik/c3-examples/blob/master/c3-control-flow/14_foreach_loop.c3</a></td></tr>
<tr><td>71</td><td>15_foreach_loop.c3</td><td>programová smyčka <strong>for-each</strong> vracející index prvku i hodnotu prvku</td><td><a href="https://github.com/tisnik/c3-examples/blob/master/c3-control-flow/15_foreach_loop.c3">https://github.com/tisnik/c3-examples/blob/master/c3-control-flow/15_foreach_loop.c3</a></td></tr>
<tr><td>72</td><td>16_foreach_loop.c3</td><td>modifikace obsahu pole v&nbsp;programové smyčce <strong>for-each</strong></td><td><a href="https://github.com/tisnik/c3-examples/blob/master/c3-control-flow/16_foreach_loop.c3">https://github.com/tisnik/c3-examples/blob/master/c3-control-flow/16_foreach_loop.c3</a></td></tr>
<tr><td>73</td><td>17_foreach_loop.c3</td><td>pokus o modifikaci obsahu procházeného pole</td><td><a href="https://github.com/tisnik/c3-examples/blob/master/c3-control-flow/17_foreach_loop.c3">https://github.com/tisnik/c3-examples/blob/master/c3-control-flow/17_foreach_loop.c3</a></td></tr>
<tr><td>74</td><td>18_foreach_loop.c3</td><td>modifikace procházeného pole přes ukazatel na prvek</td><td><a href="https://github.com/tisnik/c3-examples/blob/master/c3-control-flow/18_foreach_loop.c3">https://github.com/tisnik/c3-examples/blob/master/c3-control-flow/18_foreach_loop.c3</a></td></tr>
<tr><td>75</td><td>19_foreach_r_loop.c3</td><td>programová smyčka <strong>for-each</strong>, ve které se sekvencí prochází v&nbsp;opačném pořadí</td><td><a href="https://github.com/tisnik/c3-examples/blob/master/c3-control-flow/19_foreach_r_loop.c3">https://github.com/tisnik/c3-examples/blob/master/c3-control-flow/19_foreach_r_loop.c3</a></td></tr>
<tr><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td></tr>
<tr><td>76</td><td>20_while_loop.c3</td><td>základní forma programové smyčky typu <strong>while</strong></td><td><a href="https://github.com/tisnik/c3-examples/blob/master/c3-control-flow/20_while_loop.c3">https://github.com/tisnik/c3-examples/blob/master/c3-control-flow/20_while_loop.c3</a></td></tr>
<tr><td>77</td><td>21_while_loop_2.c3</td><td>programová smyčka typu <strong>while</strong> s&nbsp;konstrukcí <strong>break</strong></td><td><a href="https://github.com/tisnik/c3-examples/blob/master/c3-control-flow/21_while_loop_2.c3">https://github.com/tisnik/c3-examples/blob/master/c3-control-flow/21_while_loop_2.c3</a></td></tr>
<tr><td>78</td><td>22_nested_loops.c3</td><td>realizace vnořených programových smyček</td><td><a href="https://github.com/tisnik/c3-examples/blob/master/c3-control-flow/22_nested_loops.c3">https://github.com/tisnik/c3-examples/blob/master/c3-control-flow/22_nested_loops.c3</a></td></tr>
<tr><td>79</td><td>23_break.c3</td><td>vnořené programové smyčky a příkaz <strong>break</strong>: ukončení vnitřní smyčky</td><td><a href="https://github.com/tisnik/c3-examples/blob/master/c3-control-flow/23_break.c3">https://github.com/tisnik/c3-examples/blob/master/c3-control-flow/23_break.c3</a></td></tr>
<tr><td>80</td><td>24_break.c3</td><td>vnořené programové smyčky a příkaz <strong>break</strong>: ukončení vnější smyčky</td><td><a href="https://github.com/tisnik/c3-examples/blob/master/c3-control-flow/24_break.c3">https://github.com/tisnik/c3-examples/blob/master/c3-control-flow/24_break.c3</a></td></tr>
<tr><td>81</td><td>25_break.c3</td><td>vnořené programové smyčky a příkaz <strong>break</strong>, varianta se smyčkami typu <strong>while</strong></td><td><a href="https://github.com/tisnik/c3-examples/blob/master/c3-control-flow/25_break.c3">https://github.com/tisnik/c3-examples/blob/master/c3-control-flow/25_break.c3</a></td></tr>
</table>

<p>A konečně následují odkazy na demonstrační příklady z&nbsp;článku
dnešního:</p>

<table>
<tr><th> #</th><th>Příklad</th><th>Stručný popis</th><th>Adresa</th></tr>
<tr><td>82</td><td>01_regular_variable.c3</td><td>definice běžné proměnné typu <strong>int</strong>, přístup k&nbsp;hodnotě této proměnné</td><td><a href="https://github.com/tisnik/c3-examples/blob/master/c3-errors-handling/01_regular_variable.c3">https://github.com/tisnik/c3-examples/blob/master/c3-errors-handling/01_regular_variable.c3</a></td></tr>
<tr><td>83</td><td>02_optional_value.c3</td><td>definice proměnné typu <strong>Optional int</strong>, pokus o přímý přístup k&nbsp;hodnotě této proměnné (nekorektní varianta)</td><td><a href="https://github.com/tisnik/c3-examples/blob/master/c3-errors-handling/02_optional_value.c3">https://github.com/tisnik/c3-examples/blob/master/c3-errors-handling/02_optional_value.c3</a></td></tr>
<tr><td>84</td><td>03_optional_value.c3</td><td>korektní čtení proměnné typu <strong>Optional int</strong> s&nbsp;detekcí chyby</td><td><a href="https://github.com/tisnik/c3-examples/blob/master/c3-errors-handling/03_optional_value.c3">https://github.com/tisnik/c3-examples/blob/master/c3-errors-handling/03_optional_value.c3</a></td></tr>
<tr><td>85</td><td>04_optional_value.c3</td><td>korektní čtení proměnné typu <strong>Optional int</strong> s&nbsp;detekcí chyby</td><td><a href="https://github.com/tisnik/c3-examples/blob/master/c3-errors-handling/04_optional_value.c3">https://github.com/tisnik/c3-examples/blob/master/c3-errors-handling/04_optional_value.c3</a></td></tr>
<tr><td>86</td><td>05_fault.c3</td><td>uživatelsky definovaný typ nesoucí informaci o chybě</td><td><a href="https://github.com/tisnik/c3-examples/blob/master/c3-errors-handling/05_fault.c3">https://github.com/tisnik/c3-examples/blob/master/c3-errors-handling/05_fault.c3</a></td></tr>
<tr><td>87</td><td>06_fault.c3</td><td>uživatelsky definovaný typ nesoucí informaci o chybě</td><td><a href="https://github.com/tisnik/c3-examples/blob/master/c3-errors-handling/06_fault.c3">https://github.com/tisnik/c3-examples/blob/master/c3-errors-handling/06_fault.c3</a></td></tr>
<tr><td>88</td><td>07_force_unwrap.c3</td><td>použití operátoru !! (<strong>force unwrap</strong>)</td><td><a href="https://github.com/tisnik/c3-examples/blob/master/c3-errors-handling/07_force_unwrap.c3">https://github.com/tisnik/c3-examples/blob/master/c3-errors-handling/07_force_unwrap.c3</a></td></tr>
<tr><td>89</td><td>08_force_unwrap.c3</td><td>použití operátoru !! (<strong>force unwrap</strong>)</td><td><a href="https://github.com/tisnik/c3-examples/blob/master/c3-errors-handling/08_force_unwrap.c3">https://github.com/tisnik/c3-examples/blob/master/c3-errors-handling/08_force_unwrap.c3</a></td></tr>
<td><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td></td>
<tr><td>90</td><td>09_factorial.c3</td><td>běžný výpočet faktoriálu bez reakce na neplatný vstup</td><td><a href="https://github.com/tisnik/c3-examples/blob/master/c3-errors-handling/09_factorial.c3">https://github.com/tisnik/c3-examples/blob/master/c3-errors-handling/09_factorial.c3</a></td></tr>
<tr><td>91</td><td>10_factorial.c3</td><td>výpočet faktoriálu s&nbsp;reakcí na neplatný vstup &ndash; řešení bez kontroly návratové hodnoty</td><td><a href="https://github.com/tisnik/c3-examples/blob/master/c3-errors-handling/10_factorial.c3">https://github.com/tisnik/c3-examples/blob/master/c3-errors-handling/10_factorial.c3</a></td></tr>
<tr><td>92</td><td>11_factorial.c3</td><td>výpočet faktoriálu s&nbsp;reakcí na neplatný vstup &ndash; řešení s&nbsp;kontrolou návratové hodnoty</td><td><a href="https://github.com/tisnik/c3-examples/blob/master/c3-errors-handling/11_factorial.c3">https://github.com/tisnik/c3-examples/blob/master/c3-errors-handling/11_factorial.c3</a></td></tr>
<td><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td></td>
<tr><td>93</td><td>12_defer_basic_usage.c3</td><td>konstrukce <strong>defer</strong> v&nbsp;programovacím jazyce C3</td><td><a href="https://github.com/tisnik/c3-examples/blob/master/c3-errors-handling/12_defer_basic_usage.c3">https://github.com/tisnik/c3-examples/blob/master/c3-errors-handling/12_defer_basic_usage.c3</a></td></tr>
<tr><td>94</td><td>13_more_defers.c3</td><td>pořadí provádění příkazů v&nbsp;blocích <strong>defer</strong></td><td><a href="https://github.com/tisnik/c3-examples/blob/master/c3-errors-handling/13_more_defers.c3">https://github.com/tisnik/c3-examples/blob/master/c3-errors-handling/13_more_defers.c3</a></td></tr>
<tr><td>95</td><td>14_defer_scope.c3</td><td>konstrukce <strong>defer</strong> definovaná ve vnitřních blocích v&nbsp;jazyce C3</td><td><a href="https://github.com/tisnik/c3-examples/blob/master/c3-errors-handling/14_defer_scope.c3">https://github.com/tisnik/c3-examples/blob/master/c3-errors-handling/14_defer_scope.c3</a></td></tr>
<tr><td>96</td><td>15_defer_return.c3</td><td>konstrukce <strong>defer</strong> a <strong>return</strong></td><td><a href="https://github.com/tisnik/c3-examples/blob/master/c3-errors-handling/15_defer_return.c3">https://github.com/tisnik/c3-examples/blob/master/c3-errors-handling/15_defer_return.c3</a></td></tr>
<td><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td></td>
<tr><td>97</td><td>16_init_finalize.c3</td><td>funkce označené jako <strong>@init</strong> a <strong>@finalizer</strong></td><td><a href="https://github.com/tisnik/c3-examples/blob/master/c3-errors-handling/16_init_finalize.c3">https://github.com/tisnik/c3-examples/blob/master/c3-errors-handling/16_init_finalize.c3</a></td></tr>
<td><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td></td>
<tr><td>98</td><td>defer.go</td><td>konstrukce <strong>defer</strong> v&nbsp;programovacím jazyce Go</td><td><a href="https://github.com/tisnik/c3-examples/blob/master/c3-errors-handling/defer.go">https://github.com/tisnik/c3-examples/blob/master/c3-errors-handling/defer.go</a></td></tr>
<tr><td>99</td><td>defer_scope.go</td><td>konstrukce <strong>defer</strong> definovaná ve vnitřních blocích v&nbsp;jazyce Go</td><td><a href="https://github.com/tisnik/c3-examples/blob/master/c3-errors-handling/defer_scope.go">https://github.com/tisnik/c3-examples/blob/master/c3-errors-handling/defer_scope.go</a></td></tr>
</table>



<p><a name="k20"></a></p>
<h2 id="k20">20. Odkazy na Internetu</h2>

<ol>

<li>Programovací jazyk C3: evoluce, nikoli revoluce<br />
<a href="https://www.root.cz/clanky/programovaci-jazyk-c3-evoluce-nikoli-revoluce/">https://www.root.cz/clanky/programovaci-jazyk-c3-evoluce-nikoli-revoluce/</a>
</li>

<li>Programovací jazyk C3: datové typy pro moderní architektury<br />
<a href="https://www.root.cz/clanky/programovaci-jazyk-c3-datove-typy-pro-moderni-architektury/">https://www.root.cz/clanky/programovaci-jazyk-c3-datove-typy-pro-moderni-architektury/</a>
</li>

<li>Programovací jazyk C3: složené datové typy a kontejnery<br />
<a href="https://www.root.cz/clanky/programovaci-jazyk-c3-slozene-datove-typy-a-kontejnery/">https://www.root.cz/clanky/programovaci-jazyk-c3-slozene-datove-typy-a-kontejnery/</a>
</li>

<li>The C3 Programming Language<br />
<a href="https://c3-lang.org/">https://c3-lang.org/</a>
</li>

<li>C3 For C Programmers<br />
<a href="https://c3-lang.org/language-overview/primer/">https://c3-lang.org/language-overview/primer/</a>
</li>

<li>C3 is a C-like language trying to be an incremental improvement over C rather than a whole new language<br />
<a href="https://www.reddit.com/r/ProgrammingLanguages/comments/oohij6/c3_is_a_clike_language_trying_to_be_an/">https://www.reddit.com/r/ProgrammingLanguages/comments/oohij6/c3_is_a_clike_language_trying_to_be_an/</a>
</li>

<li>Tiobe index<br />
<a href="https://www.tiobe.com/tiobe-index/">https://www.tiobe.com/tiobe-index/</a>
</li>

<li>PYPL PopularitY of Programming Language<br />
<a href="https://pypl.github.io/PYPL.html">https://pypl.github.io/PYPL.html</a>
</li>

<li>C3 Tutorial<br />
<a href="https://learn-c3.org/">https://learn-c3.org/</a>
</li>

<li>History of programming languages<br />
<a href="https://devskiller.com/history-of-programming-languages/">https://devskiller.com/history-of-programming-languages/</a>
</li>

<li>History of programming languages (Wikipedia)<br />
<a href="https://en.wikipedia.org/wiki/History_of_programming_languages">https://en.wikipedia.org/wiki/History_of_programming_languages</a>
</li>

<li>D language<br />
<a href="https://dlang.org/">https://dlang.org/</a>
</li>

<li>Zig programming language<br />
<a href="https://ziglang.org/">https://ziglang.org/</a>
</li>

<li>V language<br />
<a href="https://vlang.io/">https://vlang.io/</a>
</li>

<li>D programming language<br />
<a href="https://en.wikipedia.org/wiki/D_(programming_language)">https://en.wikipedia.org/wiki/D_(programming_language)</a>
</li>

<li>Zig programming language (Wikipedia)<br />
<a href="https://en.wikipedia.org/wiki/Zig_(programming_language)">https://en.wikipedia.org/wiki/Zig_(programming_language)</a>
</li>

<li>V programming language (Wikipedia)<br />
<a href="https://en.wikipedia.org/wiki/V_(programming_language)">https://en.wikipedia.org/wiki/V_(programming_language)</a>
</li>

<li>Syntax highlighting for C3's programming language<br />
<a href="https://github.com/Airbus5717/c3.vim">https://github.com/Airbus5717/c3.vim</a>
</li>

<li>Go factorial<br />
<a href="https://gist.github.com/esimov/9622710">https://gist.github.com/esimov/9622710</a>
</li>

<li>Generational list of programming languages<br />
<a href="https://en.wikipedia.org/wiki/Generational_list_of_programming_languages">https://en.wikipedia.org/wiki/Generational_list_of_programming_languages</a>
</li>

<li>The Language Tree: Almost Every Programming Language Ever Made<br />
<a href="https://github.com/Phileosopher/langmap">https://github.com/Phileosopher/langmap</a>
</li>

<li>List of C-family programming languages<br />
<a href="https://en.wikipedia.org/wiki/List_of_C-family_programming_languages">https://en.wikipedia.org/wiki/List_of_C-family_programming_languages</a>
</li>

<li>Compatibility of C and C++<br />
<a href="https://en.wikipedia.org/wiki/Compatibility_of_C_and_C%2B%2B">https://en.wikipedia.org/wiki/Compatibility_of_C_and_C%2B%2B</a>
</li>

<li>C++23: compatibility with C<br />
<a href="https://www.sandordargo.com/blog/2023/08/23/cpp23-c-compatibility">https://www.sandordargo.com/blog/2023/08/23/cpp23-c-compatibility</a>
</li>

<li>Can C++ Run C Code? Understanding Language Compatibility<br />
<a href="https://www.codewithc.com/can-c-run-c-code-understanding-language-compatibility/">https://www.codewithc.com/can-c-run-c-code-understanding-language-compatibility/</a>
</li>

<li>C3: Comparisons With Other Languages<br />
<a href="https://c3-lang.org/faq/compare-languages/">https://c3-lang.org/faq/compare-languages/</a>
</li>

<li>C3 Programming Language Gains Traction as Modern C Alternative<br />
<a href="https://biggo.com/news/202504040125_C3_Programming_Language_Alternative_to_C">https://biggo.com/news/202504040125_C3_Programming_Language_Alternative_to_C</a>
</li>

<li>The case against a C alternative<br />
<a href="https://c3.handmade.network/blog/p/8486-the_case_against_a_c_alternative">https://c3.handmade.network/blog/p/8486-the_case_against_a_c_alternative</a>
</li>

<li>C (programming language) Alternatives<br />
<a href="https://alternativeto.net/software/c-programming-language-/">https://alternativeto.net/software/c-programming-language-/</a>
</li>

<li>Seriál Programovací jazyk Go<br />
<a href="https://www.root.cz/serialy/programovaci-jazyk-go/">https://www.root.cz/serialy/programovaci-jazyk-go/</a>
</li>

<li>Is C3 the Underdog That Will Overtake Zig and Odin?<br />
<a href="https://bitshifters.cc/2025/05/22/c3-c-tradition.html">https://bitshifters.cc/2025/05/22/c3-c-tradition.html</a>
</li>

<li>"Hello, World!" program<br />
<a href="https://en.wikipedia.org/wiki/%22Hello%2C_World!%22_program">https://en.wikipedia.org/wiki/%22Hello%2C_World!%22_program</a>
</li>

<li>The C Programming Language<br />
<a href="https://en.wikipedia.org/wiki/The_C_Programming_Language">https://en.wikipedia.org/wiki/The_C_Programming_Language</a>
</li>

<li>Kontejner (abstraktní datový typ)<br />
<a href="https://cs.wikipedia.org/wiki/Kontejner_(abstraktn%C3%AD_datov%C3%BD_typ)">https://cs.wikipedia.org/wiki/Kontejner_(abstraktn%C3%AD_datov%C3%BD_typ)</a>
</li>

<li>Are arrays not considered containers because they are not based off of a class?<br />
<a href="https://stackoverflow.com/questions/37710975/are-arrays-not-considered-containers-because-they-are-not-based-off-of-a-class">https://stackoverflow.com/questions/37710975/are-arrays-not-considered-containers-because-they-are-not-based-off-of-a-class</a>
</li>

<li>Array declaration (C, C++)<br />
<a href="https://en.cppreference.com/w/cpp/language/array.html">https://en.cppreference.com/w/cpp/language/array.html</a>
</li>

<li>Understanding the Apple ‘goto fail;’ vulnerability<br />
<a href="https://www.blackduck.com/blog/understanding-apple-goto-fail-vulnerability-2.html">https://www.blackduck.com/blog/understanding-apple-goto-fail-vulnerability-2.html</a>
</li>

<li>Branch (computer science)<br />
<a href="https://en.wikipedia.org/wiki/Branch_(computer_science)">https://en.wikipedia.org/wiki/Branch_(computer_science)</a>
</li>

<li>Conditional (computer programming)<br />
<a href="https://en.wikipedia.org/wiki/Conditional_(computer_programming)">https://en.wikipedia.org/wiki/Conditional_(computer_programming)</a>
</li>

<li>Dangling else<br />
<a href="https://en.wikipedia.org/wiki/Dangling_else">https://en.wikipedia.org/wiki/Dangling_else</a>
</li>

<li>Switch statement<br />
<a href="https://en.wikipedia.org/wiki/Switch_statement">https://en.wikipedia.org/wiki/Switch_statement</a>
</li>

</ol>



<p></p><p></p>
<p><small>Autor: <a href="https://github.com/tisnik/">Pavel Tišnovský</a> &nbsp; 2025</small></p>
</body>
</html>

