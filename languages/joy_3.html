<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
        "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html>
<head>
<title>Jazyk Joy a rekurzivní kombinátory</title>
<meta name="Author" content="Pavel Tisnovsky" />
<meta name="Generator" content="vim" />
<meta http-equiv="content-type" content="text/html; charset=iso-8859-2" />
<style type="text/css">
         body {color:#000000; background:#ffffff;}
         h1  {font-family: arial, helvetica, sans-serif; color:#ffffff; background-color:#c00000; text-align:center; padding-left:1em}
         h2  {font-family: arial, helvetica, sans-serif; color:#ffffff; background-color:#0000c0; padding-left:1em; text-align:left}
         h3  {font-family: arial, helvetica, sans-serif; color:#000000; background-color:#c0c0c0; padding-left:1em; text-align:left}
         h4  {font-family: arial, helvetica, sans-serif; color:#000000; background-color:#e0e0e0; padding-left:1em; text-align:left}
         a   {font-family: arial, helvetica, sans-serif;}
         li  {font-family: arial, helvetica, sans-serif; color:#000000; text-align:justify; width:450px;}
         ol  {font-family: arial, helvetica, sans-serif; color:#000000; text-align:justify; width:450px;}
         ul  {font-family: arial, helvetica, sans-serif; color:#000000; text-align:justify; width:450px;}
         p   {font-family: arial, helvetica, sans-serif; color:#000000; text-align:justify;}
         pre {background:#e0e0e0}
</style>
</head>

<body>

<h1>Jazyk Joy a rekurzivní kombinátory</h1>

<h3>Pavel Ti¹novský</h3>

<p></p>

<h1>Úvodník</h1>

<p>Ústøedním tématem tøetí a souèasnì i poslední èásti èlánku o netradièním programovacím jazyce Joy bude podrobnìj¹í vysvìtlení rekurzivních kombinátorù. Teoretická èást bude samozøejmì doplnìna i mnoha demonstraèními pøíklady, vèetnì nerekurzivních variant pùvodnì rekurzivnì napsaných algoritmù.</p>



<h1>Obsah</h1>
<p>
<a href="#k01">1. Náhrada rekurze pomocí rekurzivních kombinátorù</a><br />
<a href="#k02">2. Kombinátor nahrazující poèítanou smyèku typu <i>for</i></a><br />
<a href="#k03">3. Kombinátor nahrazující nepoèítanou smyèku typu <i>foreach</i></a><br />
<a href="#k04">4. Kombinátor nahrazující smyèku typu <i>while</i></a><br />
<a href="#k05">5. Lineární rekurze</a><br />
<a href="#k06">6. Primitivní rekurze</a><br />
<a href="#k07">7. Binární rekurze</a><br />
<a href="#k08">8. Nerekurzivní verze známých algoritmù</a><br />
<a href="#k09">9. Odkazy na Internetu</a><br />
</p>



<p><a name="k01"></a></p>
<h1>1. Náhrada rekurze pomocí rekurzivních kombinátorù</h1>

<p>Jednou z&nbsp;nejzajímavìj¹ích vlastností programovacího jazyka <i>Joy</i>
je zpùsob náhrady rekurzivních funkcí a programových smyèek pomocí takzvaných
<i>rekurzivních kombinátorù</i>. <i>Joy</i> samozøejmì, ostatnì jako naprostá
vìt¹ina programovacích jazykù (snad s&nbsp;výjimkou starého <i>Fortranu</i> a
<i>Basicu</i>), podporuje normální rekurzi, tj.&nbsp;volání té samé funkce
z&nbsp;jejího tìla. Lze také pou¾ít rekurzi nepøímou, co¾ znamená, ¾e se
z&nbsp;nìjaké funkce <strong>A</strong> volá funkce <strong>B</strong> a
v&nbsp;jejím tìle opìt funkce <strong>A</strong>.</p>

<p>Volání je samozøejmì mo¾né provádìt i pøes vìt¹í poèet funkcí, napøíklad
formou
<strong>A</strong>-&gt;<strong>B</strong>-&gt;<strong>C</strong>-&gt;<strong>A</strong>.
V&nbsp;dal¹ích kapitolách si zpùsob provádìní rekurze vysvìtlíme jak
teoreticky, tak i na nìkolika praktických pøíkladech. Uvidíme, ¾e nìkteré formy
rekurze lze nahradit lineárním kódem pomìrnì snadno, u dal¹ích je to ji¾ tì¾¹í
a ve speciálních pøípadech (matematici by spí¹e øekli v&nbsp;obecných
pøípadech) je to dokonce nemo¾né.</p>

<p>Mnoho funkcionálních programovacích jazykù, mezi jinými i <i>Lisp</i>
(pøesnìji øeèeno pouze nìkteré implementace Lispu) a <i>Scheme</i>, obsahuje
techniku zvanou <i>tail recursion</i>. Ta je bez zásahu programátora do jím
vytváøeného programu pou¾ita pro náhradu rekurze za smyèku v&nbsp;dobì pøekladu
èi bìhu programu. Pokud v¹ak programátor chce pou¾ít tail rekurzi, musí dodr¾et
jistá pravidla zápisu funkce; pøedev¹ím se to týká vlastního rekurzivního
volání.</p>

<p>Jedná se vlastnì o optimalizaèní techniku, která v&nbsp;mnoha pøípadech vede
jak ke sní¾ení mno¾ství alokované operaèní pamìti, tak i ke zrychlení bìhu
programu, proto¾e skuteèné provedení rekurze, tj.&nbsp;volání funkce, je
implementaènì i èasovì slo¾itìj¹í, ne¾ pou¾ití programové smyèky. Tail rekurze
je v¹ak vìt¹inou omezena pøedev¹ím na <i>lineární rekurzi</i> popsanou <a
href="#k04">ve ètvrté kapitole</a> a samozøejmì je pou¾itelná i pro <i>rekurzi
primitivní</i> popsanou <a href="#k05">v&nbsp;kapitole páté</a>. Pro vy¹¹í
formy rekurze u¾ se tato optimalizaèní technika neuplatòuje.</p>

<p>Je¹tì pøed vysvìtlením konkrétních kombinátorù si vysvìtleme, o jaké
jazykové konstrukce se jedná. <i>Rekurzivní kombinátor</i> je vlastnì bì¾ný
operátor, který na zásobníku oèekává buï jeden nebo nìkolik citovaných
programù, popø.&nbsp;dal¹í parametry, napøíklad poèet opakování. Jak ji¾ víme
z&nbsp;pøedchozí èásti tohoto èlánku, je citovaný program na zásobníku ulo¾en
ve formì seznamu, tj.&nbsp;v&nbsp;hranatých závorkách.</p>

<p>Podle typu rekurzivního kombinátoru je citovaný program/programy opakovanì
spou¹tìn, pøièem¾ je specifickým zpùsobem (popsaným v&nbsp;dal¹ích kapitolách)
mìnìn obsah zásobníku tak, aby se simulovalo skuteèné provádìní rekurze.
Rekurzivní kombinátory nemají ¾ádnou specifickou syntaxi, jedná se o bì¾né
funkce/operátory zapisované nám ji¾ známou postfixovou notací, tj.&nbsp;samotný
programovací jazyk nemusel být kvùli jejich aplikaci ¾ádným zpùsobem mìnìn. I
tato skuteènost vypovídá o kvalitním a promy¹leném návrhu tohoto jazyka.</p>

<image id="5593" />
<p-center>Aplikace gcalculator pøepnutá do re¾imu RPN</p-center>



<p><a name="k02"></a></p>
<h1>2. Kombinátor nahrazující poèítanou smyèku typu <i>for</i></h1>

<p>Pravdìpodobnì nejjednodu¹¹ím typem kombinátoru je kombinátor nahrazující
klasickou poèítanou smyèku typu <i>for</i> (mám teï na mysli podobu smyèky
známou napøíklad z&nbsp;<i>Pascalu</i>, <i>Fortranu</i> (pùvodní smyèka typu
<i>do</i>) nebo <i>Basicu</i>, nikoli céèkovskou variantu, která má daleko
¹ir¹í mo¾nosti). Tento kombinátor, který dostal pøiléhavý název
<strong>times</strong>, pracuje následujícím zpùsobem: pøi spu¹tìní operátoru
se pøedpokládá, ¾e jsou na zásobníku ulo¾eny dvì hodnoty: na vrcholu zásobníku
seznam, jen¾ pøedstavuje tìlo smyèky v&nbsp;imperativních jazycích,
tj.&nbsp;citovaný program a pod vrcholem zásobníku je oèekávána èíselná hodnota
udávající, kolikrát se má citovaný program provést. Pou¾ití tohoto kombinátoru
je velmi jednoduché (funkce <strong>putchars</strong> zajistí tisk øetìzce bez
uvozovek a speciální znak <strong>\n</strong> slou¾í k&nbsp;odøádkování):</p>

<code-area>

<strong>10 ["hello\n" putchars] times .</strong>
hello
hello
hello
hello
hello
hello
hello
hello
hello
hello

</code-area>



<p><a name="k03"></a></p>
<h1>3. Kombinátor nahrazující nepoèítanou smyèku typu <i>foreach</i></h1>

<p>V&nbsp;mnoha programovacích jazycích se také objevuje smyèka typu
<i>for-each</i>. Nejedná se o smyèku poèítanou, jak tomu bylo v&nbsp;pøedchozím
pøípadì, ale o smyèku provádìnou nad v¹emi prvky nìjakého datového kontejneru,
typicky pole, seznamu nebo asociativního pole (poèet prvkù ulo¾ených
v&nbsp;kontejnerech není v&nbsp;dobì pøekladu obecnì známý). I za tento typ
smyèky existuje v&nbsp;jazyce <i>Joy</i> náhrada ve formì kombinátoru
<strong>map</strong>. Pou¾ití tohoto kombinátoru je snadné &ndash; citovaný
program pøedávaný na vrcholu zásobníku je aplikován na v¹echny polo¾ky seznamu
èi øetìzce ulo¾eného na druhém místì zásobníku. Výsledkem je nový seznam nebo
øetìzec:</p>

<code-area>

<strong>[1 2 3 4]  [dup *]  map .</strong>
[1 4 9 16]

</code-area>

<p>Podobným zpùsobem pracuje i kombinátor nazvaný <strong>filter</strong>,
který ov¹em do novì vytváøeného seznamu èi øetìzce vkládá ty polo¾ky, které
splòují zadané kritérium, tj.&nbsp;polo¾ky jsou skuteènì filtrovány na základì
neustále vyhodnocované podmínky:</p>

<code-area>

<i>ze seznamu získáme pouze sudá èísla</i>
<i>(dìlitelná dvìma)</i>
<strong>[0 1 2 3 4 5 6 7 8 9 10] [2 rem 0 =] filter .</strong>
[0 2 4 6 8 10]

<i>opak pøedchozího pøíkladu, získání</i>
<i>lichých èísel z pøedaného seznamu</i>
<strong>[0 1 2 3 4 5 6 7 8 9 10] [2 rem 0 !=] filter .</strong>
[1 3 5 7 9]

<i>z øetìzce se vyberou v¹echny znaky, jejich¾</i>
<i>poøadí v ASCII le¾í pod znakem 'a'</i>
<i>(v tomto pøípadì se odstraní malá písmena)</i>
<strong>"Hello World" ['a &lt;] filter .</strong>
"H W"

<i>z øetìzce se vyberou v¹echny znaky, jejich¾</i>
<i>poøadí v ASCII le¾í nad znakem 'Z'</i>
<i>(v tomto pøípadì se odstraní velká písmena a mezery)</i>
<strong>"Hello World" ['Z &gt;] filter .</strong>
"elloorld"

<i>filtrace mezer</i>
<i>(v¹imnìte si zpùsobu zápisu mezery pomocí apostrofu)</i>
<strong>"Hello World" [' !=] filter .</strong>
"HelloWorld"

<i>filtrace v¹ech znakù kromì mezer</i>
<strong>"Hello World" [' =] filter .</strong>
" "

</code-area>

<p>Do podobné kategorie patøí i kombinátor <strong>step</strong>, pomocí
kterého je mo¾né zpracovávat seznamy, øetìzce nebo mno¾iny, ov¹em s&nbsp;tím
rozdílem, ¾e se výsledek nevrací do stejné datové struktury (seznamu atd.), ale
na nové místo v&nbsp;zásobníku. Jedno z&nbsp;mo¾ných pou¾ití tohoto kombinátoru
je rozklad seznamu na sekvenci jeho prvkù:</p>

<code-area>

<i>rozklad seznamu na sekvenci prvkù</i>
<strong>[1 2 3 4 5] [nop] step .....</strong>
5
4
3
2
1

<i>ukázka rozdílu mezi kombinátory step a map</i>
<strong>[1 2 3 4 5] [nop] map .....</strong>
[1 2 3 4 5]

<i>na zpracovávané prvky lze samozøejmì aplikovat rùzné operace</i>
<strong>[1 2 3 4 5] [succ] step .....</strong>
6
5
4
3
2

<i>výsledek je opìt odli¹ný od kombinátoru map</i>
<strong>[1 2 3 4 5] [succ] map .....</strong>
[2 3 4 5 6]

<i>slo¾itìj¹í operace - vytvoøení pøevráceného seznamu</i>
<i>(postupnì se provádí operace '[] 1 swap cons')</i>
<strong>[] [1 2 3 4 5] [swap cons] step .....</strong>
[5 4 3 2 1]

</code-area>

<image id="5594" />
<p-center>RPN kalkulaèka urèená pro PDA<br />
(nahoøe vlevo je vidìt prozatím prázdná èást zásobníku)</p-center>



<p><a name="k04"></a></p>
<h1>4. Kombinátor nahrazující smyèku typu <i>while</i></h1>

<p>Nepoèítaná smyèka typu <i>while</i> známá z&nbsp;mnoha imperativních jazykù,
je v&nbsp;programovacím jazyce <i>Joy</i> nahrazena ponìkud pøekvapivì
kombinátorem nazvaným právì <strong>while</strong> :-) Pøed voláním tohoto
kombinátoru musí být na zásobník ulo¾eny dva citované programy. První program
pøedstavuje podmínku, která je vyhodnocena pøed ka¾dým opakováním smyèky, druhý
program pøedstavuje vlastní tìlo smyèky, které je opakovanì voláno
v&nbsp;závislosti na vyhodnocení podmínky. Uèebnicovým pøíkladem pou¾ití tohoto
kombinátoru je tvorba poèítaného cyklu, pøièem¾ nesmíme zapomenout na zásobníku
vytvoøit èíselnou hodnotu, která se bude pøi opakování smyèky zvìt¹ovat nebo
naopak zmen¹ovat (funkce <strong>put</strong> provádí tisk èísla ulo¾eného na
vrcholu zásobníku):</p>

<code-area>

<i>    podmínka  tìlo funkce    volání kombinátoru</i>
<strong>10   [0 &lt;]   [dup put 1 -]   while .</strong>
10 9 8 7 6 5 4 3 2 1 0

<i>jednodu¹¹í zpùsob vyu¾ívající operátoru pred</i>
<i>(poslední vyti¹tìná hodnota je výsledkem operátoru teèka)</i>
<strong>10   [0 &gt;]   [dup put pred]  while .</strong>
10 9 8 7 6 5 4 3 2 1 0

<i>zápis opaèné podmínky a zmìna poèáteèní hodnoty</i>
<i>(poslední vyti¹tìná hodnota je opìt výsledkem operátoru</i>
<i> teèka, nikoli bìhu smyèky)</i>
<strong>0 [10 &lt;] [dup put succ] while .</strong>
0 1 2 3 4 5 6 7 8 9 10

<i>odstranìní poslední hodnoty, která zùstává na zásobníku</i>
<strong>0 [10 &lt;] [dup put succ] while pop .</strong>
0 1 2 3 4 5 6 7 8 9

<i>tisk sudých èísel</i>
<strong>0 [10 &lt;] [dup put succ succ] while .</strong>
0 2 4 6 8 10

<i>tisk násobkù tøí</i>
<strong>0 [10 &lt;] [dup put 3 +] while .</strong>
0 3 6 9 12

<i>o tom, ¾e poslední èíselná hodnota ji¾ není tìlem</i>
<i>smyèky zpracovávána se mù¾eme jednodu¹e pøesvìdèit</i>
<strong>0 [10 &lt;] ["-&gt;" putchars dup put succ "\n" putchars] while .</strong>
-&gt;0
-&gt;1
-&gt;2
-&gt;3
-&gt;4
-&gt;5
-&gt;6
-&gt;7
-&gt;8
-&gt;9
10

</code-area>

<image id="5595" />
<p-center>Podpora drag and drop v&nbsp;RPN kalkulaèce urèené pro PDA<br />
(numerické klávesy v&nbsp;tomto pøípadì slou¾í jako deset nezávislých pamìtí!)</p-center>



<p><a name="k05"></a></p>
<h1>5. Lineární rekurze</h1>

<p>Velmi èasto se pøi programování setkáváme s&nbsp;pøípady algoritmù, které se
dají efektivnì øe¹it pomocí takzvané <i>lineární rekurze</i>. Jedná se vlastnì
o takový pøípad rekurze, kdy funkce volá sebe samu ve svém tìle pouze jednou.
Nejprve si øeknìme, co si pod pojmem lineární rekurze vùbec máme pøedstavit a
v&nbsp;dal¹ích odstavcích si uká¾eme rekurzivní kombinátor, který slou¾í
k&nbsp;zápisu lineárnì rekurzivních algoritmù.</p>

<p>Nìjaká naprogramovaná funkce <strong>f</strong> je nazývána <i>lineárnì
rekurzivní</i> v&nbsp;pøípadì, ¾e aktivace této funkce (tj.&nbsp;její zavolání)
vyvolá nejvý¹e jednu novou aktivaci té samé funkce <strong>f</strong>. Typickým
pøíkladem lineárnì rekurzivní funkce je funkce faktoriál, v&nbsp;matematice
oznaèovaná postfixovým operátorem ! (vykøièník). Pøíkladem funkce, která není
lineárnì rekurzivní, je funkce pro výpoèet Fibonacciho èísel &ndash;
v&nbsp;tìle této funkce (nazvìme ji napøíklad pro jednoduchost
<strong>Fib</strong>) jsou vyvolány dvì aktivace té samé funkce
<strong>Fib</strong>. Vra»me se v¹ak ke zmínìné typické lineárnì rekurzivní
funkci faktoriál, kterou lze matematicky definovat následujícím zpùsobem:</p>

<p><i>Fact(x)=1 &nbsp;&nbsp; pro x=0</i><br />
<i>Fact(x)=x&times;Fact(x-1) &nbsp;&nbsp; pro x&gt;0</i></p>

<p>Z&nbsp;praktického hlediska je zajímavý pøedev¹ím zpùsob výpoètu lineárnì
rekurzivní funkce, tj.&nbsp;vyjádøení její hodnoty pro zadaný parametr.
Vyhodnocování je mo¾né obecnì rozdìlit do dvou po sobì následujících èástí:</p>

<p><strong>Fáze navíjení</strong> (<i>winding phase</i>): v&nbsp;této fázi jsou
postupnì volány, tj.&nbsp;aktivovány takzvané aktivace rekurzivní funkce,
obecnì s&nbsp;rùznými hodnotami parametrù.</p>

<p><strong>Fáze odvíjení</strong> (<i>unwinding phase</i>): tato fáze nastane
po splnìní nìjaké ukonèující podmínky rekurze. Øízení, tj.&nbsp;bod, ve kterém
se bì¾ící proces nachází, se postupnì vrací jednotlivým vytvoøeným
aktivacím.</p>

<p>V&nbsp;klasických imperativních i funkcionálních jazycích se lineárnì
rekurzivní funkce skuteènì zapisují pomocí rekurze, tj.&nbsp;v&nbsp;tìle funkce
je volána (aktivována) ta samá funkce. Kromì toho je nutné zajistit, aby
rekurze byla koneèná, co¾ je provedeno pomocí nìjaké podmínky, je¾
v&nbsp;podstatì tvoøí hranici mezi fází navíjení a fází odvíjení. Uka¾me si,
jakým zpùsobem by byla zapsána lineárnì rekurzivní funkce pro výpoèet
faktoriálu v&nbsp;bì¾ném programovacím jazyku (podobným zpùsobem, i kdy¾ tro¹ku
jednodu¹¹ím, by se výpoèet provedl i ve funkcionálních jazycích, napøíklad
<i>Lispu</i> nebo <i>Scheme</i>):</p>

<code-area>

unsigned int fact(unsigned int n)
{
    if (n==0)          // podmínka pro ukonèení rekurze
        return 1;      // =&gt; pøechod mezi fází navíjení a odvíjení
    else
        n*fact(n-1);   // rekurzivní volání funkce fact()
}

</code-area>

<p>Programovací jazyk <i>Joy</i> se od vìt¹iny jiných funkcionálních jazykù
odli¹uje tím, ¾e se lineárnì rekurzivní funkce nemusí zapisovat pomocí rekurze
(i to je v¹ak samozøejmì mo¾né); místo toho nabízí speciální <i>rekurzivní
kombinátor</i> pøedstavovaný slovem <strong>linrec</strong>. Tento kombinátor
pøi svém zavolání po¾aduje, aby byly na zásobníku ulo¾eny následující ètyøi
fragmenty citovaných programù:</p>

<ul>

<li><strong>P</strong> &ndash; tento citovaný program, který je nazývaný
<i>if-part</i>, je spu¹tìn pøed ka¾dým rekurzivním zanoøením (nebo jeho obdobì,
pokud je rekurze nahrazena jiným výpoètem). Podle výsledku vyhodnocení programu
je buï spu¹tìn citovaný program <strong>T</strong> (<strong>P</strong> se
vyhodnotí na hodnotu <i>true</i>), nebo je spu¹tìn program <strong>R1</strong>,
je provedena rekurze a následnì je spu¹tìn program <strong>R2</strong>
(spu¹tìní tohoto programu mù¾e být èasovì velmi vzdálené od spu¹tìní programu
<strong>R1</strong>, v&nbsp;závislosti na poètu zanoøení do rekurzivní
funkce).</li>

<li><strong>T</strong> &ndash; tento citovaný program je nazývaný
<i>then-part</i> podle podobnosti s&nbsp;funkcí podobného programu u operátoru
<strong>ifte</strong>. Slou¾í k&nbsp;"úklidu" po rekurzivním zanoøování
v&nbsp;pøípadì, ¾e je splnìna podmínka zapsaná ve vý¹e uvedeném programu
<strong>P</strong>.</li>

<li><strong>R1</strong> &ndash; citovaný blok programu nazývaný
<i>else-part-1</i> je vykonán v&nbsp;pøípadì, ¾e není splnìna podmínka
vyhodnocovaná citovaným programem <strong>P</strong>, je¹tì pøed vlastním
provedením rekurze.</li>

<li><strong>R2</strong> &ndash; citovaný blok programu nazývaný
<i>else-part-2</i> je vykonán po provedení rekurzivního zanoøení do
funkce.</li>

</ul>

<p>Lineární rekurzi si mù¾eme ukázat na oblíbeném pøíkladu výpoètu faktoriálu,
který lze zapsat buï klasicky rekurzivnì:</p>

<code-area>

<strong>DEFINE</strong>
<strong>factorial == [0 =] [pop 1] [dup 1 - factorial *] ifte</strong>
<strong>.</strong>

</code-area>

<p>Nebo s&nbsp;vyu¾itím rekurzivního kombinátoru:</p>

<code-area>

<strong>DEFINE</strong>
<strong>factorial2 == [dup 0 =] [1 +] [dup 1 -] [*] linrec</strong>
<strong>.</strong>

</code-area>

<p>Popø.&nbsp;po náhradì nìkterých aritmetických výrazù za funkce vykonávající
stejnou èinnost:</p>

<code-area>

<strong>DEFINE</strong>
<strong>factorial3 == [null]  [succ]  [dup pred]  [*]  linrec</strong>
<strong>.</strong>

</code-area>

<p>A mù¾eme si v¹e otestovat:</p>

<code-area>

<strong>[1 2 3 4 5 6] [factorial3] map .</strong>
[1 2 6 24 120 720]

</code-area>

<p>nebo lze èíselnou øadu vytvoøit je¹tì lépe a radostnìji:</p>

<code-area>

<strong>0 [10 &lt;] [dup factorial3 put succ] while pop .</strong>
1 1 2 6 24 120 720 5040 40320 362880

</code-area>

<image id="5596" />
<p-center>RPN kalkulaèky urèené pro PDA jsou evidentnì oblíbené &ndash; aplikace MathU Pro<br />
(proè vùbec mají telefony klávesnici otoèenou oproti kalkulaèkám nebo poèítaèovým klávesnicím?)</p-center>



<p><a name="k06"></a></p>
<h1>6. Primitivní rekurze</h1>

<p>Programovací jazyk <i>Joy</i> podporuje kromì kombinátoru umo¾òujícího
provádìní <i>lineární rekurze</i> i kombinátor, který slou¾í pro zápis takzvané
<i>primitivní rekurze</i>. V&nbsp;podstatì se jedná o zredukovanou verzi
kombinátoru <strong>linrec</strong>, ov¹em s&nbsp;tím rozdílem, ¾e citovaný
blok nazvaný <i>if-part</i> a <i>else-part-1</i> je automaticky doplnìn o kód
zaji¹»ující automatické zji¹tìní, kdy má být rekurze ukonèena. Vzhledem
k&nbsp;tomu, ¾e je blok <i>else-part-1</i> doplnìn automaticky, nelze nic
provádìt ve chvíli rekurzivního zanoøování/navíjení (tím se napøíklad zamezí
vzniku nekoneèné rekurze), ale prùbìh vynoøování/odvíjení z&nbsp;rekurze je ji¾
øízen blokem <i>else-part-2</i>, který je pøítomen.</p>

<p>Následují velmi jednoduché pøíklady pou¾ití primitivní rekurze:</p>

<code-area>

<i>nejprve se zásobník naplní sekvencí 5 4 3 2 1</i>
<i>a poté je tato sekvence v opaèném poøadí</i>
<i>vypsána pomocí funkce put</i>
<strong>5 [] [put] primrec .</strong>
1 2 3 4 5

<i>fáze navíjení je stejná jako v pøedchozím pøípadì</i>
<i>ov¹em ve fázi odvíjení je proveden výpoèet</i>
<i>(0-hodnota) a teprve výsledek tohoto výpoètu</i>
<i>je vypsán</i>
<strong>5 [] [0 swap - put] primrec .</strong>
-1 -2 -3 -4 -5

<i>obdobný pøípad, akorát se ve fázi odvíjení</i>
<i>ka¾dá hodnota na zásobníku vynásobí dvìma</i>
<strong>5 [] [2 * put] primrec .</strong>
2 4 6 8 10

<i>opìt se jedná o obdobný pøíklad s tím rozdílem,</i>
<i>¾e se vypoèítá druhá mocnina hodnot ulo¾ených</i>
<i>na zásobníku</i>
<strong>5 [] [dup * put] primrec .</strong>
1 4 9 16 25

<i>mù¾eme ovlivnit také poèáteèní podmínku</i>
<strong>5 ['A] [put] primrec .</strong>
'A 1 2 3 4 5

</code-area>



<p><a name="k07"></a></p>
<h1>7. Binární rekurze</h1>

<p>V&nbsp;praxi se také nìkdy setkáme s&nbsp;algoritmem, který vede na tvorbu
funkce, je¾ není lineárnì rekurzivní, tj.&nbsp;v&nbsp;jejím tìle se ta samá
funkce volá minimálnì dvakrát. Jednou z&nbsp;takových funkcí je i známá
rekurzivnì zadaná matematická funkce slou¾ící k&nbsp;výpoètu jedné hodnoty
le¾ící na Fibonacciho øadì. Pro ka¾dé èíslo Fibonacciho øady platí vztah:</p>

<p>
<i>x<sub>n</sub>=x<sub>n-1</sub>+x<sub>n-2</sub></i>
</p>

<p>Pøièem¾ je definitoricky nastaveno <i>x<sub>1</sub>=x<sub>2</sub>=1</i></p>

<p>Pøi pou¾ití rekurzivního kombinátoru <strong>binrec</strong> je výpoèet
<i>n</i>-té hodnoty Fibonacciho øady velmi jednoduchý, i kdy¾ pomalý, proto¾e
se nepamatují pøedchozí vypoètené hodnoty. První blok citovaného programu
slou¾í pro test, zda je hodnota ulo¾ená na zásobníku rovna nule nebo jedné
(docela pøíjemná funkce ne?). Pokud je podmínka splnìna, je spu¹tìn druhý blok,
který neprovádí ¾ádnou èinnost a tudí¾ na zásobníku ponechá pùvodní hodnotu.
Tøetí blok programu je zavolán pøed provedením rekurze, pøièem¾ by se zde
typicky mìl zvý¹it poèet polo¾ek ulo¾ených na zásobníku, proto¾e pro dvì
nejvy¹¹í polo¾ky je provedena rekurze. Poslední blok programu je proveden ve
fázi odvíjení a slou¾í ke zpìtnému zkombinování dvou polo¾ek umístìných na
vrcholu zásobníku. Výsledkem je následující program:</p>

<code-area>

<strong>[small] [] [pred dup pred] [+] binrec</strong>

</code-area>

<code-area>

<i>výpoèet prvních deseti hodnot Fibonacciho øady</i>
<strong>1 [12 &lt;] [dup [small] [] [pred dup pred] [+] binrec put succ] while pop.</strong>
1 1 2 3 5 8 13 21 34 55 89

</code-area>



<p><a name="k08"></a></p>
<h1>8. Nerekurzivní verze známých algoritmù</h1>

<p>V&nbsp;této kapitole si uká¾eme, jakým zpùsobem je mo¾né pou¾ít vý¹e popsané
rekurzivní kombinátory k&nbsp;úpravì pùvodnì rekurzivních algoritmù na jejich
nerekurzivní variantu, tj.&nbsp;na variantu, ve které se explicitnì nevyskytuje
pøímá èi nepøímá rekurze. Nerekurzivní úpravu je samozøejmì mo¾né pou¾ít
v&nbsp;témìø jakémkoli programovacím jazyce, ov¹em vìt¹inou za cenu
explicitního vytvoøení zásobníku nebo podobné netriviální úpravy
(v&nbsp;nìkterých pøípadech pomù¾e <i>tail rekurze</i>, ov¹em pouze jako
optimalizace primitivní a lineární rekurze). V&nbsp;programovacím jazyce
<i>Joy</i> je vytvoøení nerekurzivních algoritmù s&nbsp;vyu¾itím rekurzivních
kombinátorù pomìrnì snadné.</p>

<code-area>

<i>nejjednodu¹¹í forma výpoètu faktoriálu</i>
<i>pomocí primitivní rekurze</i>
<strong>[1] [*] primrec .</strong>

<i>ukázka zanoøování blokù kódu</i>
<i>pøi výpoètu faktoriálu</i>
<strong>[0 1 2 3 4 5 6] [[1] [*] primrec] map .</strong>
[1 1 2 6 24 120 720]

<i>vytvoøení seznamu obsahujícího sekvenci hodnot</i>
<strong>10 [[]] [cons] primrec .</strong>
[10 9 8 7 6 5 4 3 2 1]

<i>vytvoøení rekurzivnì vkládaných podseznamù</i>
<strong>6 [[]]  [[] cons cons]  primrec .</strong>
[6 [5 [4 [3 [2 [1 []]]]]]]

<i>algoritmus QuickSort</i>
<strong>[small] [] [uncons [&gt;] split] [[swap] dip cons concat] binrec</strong>

</code-area>



<p><a name="k09"></a></p>
<h1>9. Odkazy na Internetu</h1>

<ul>

<li><a href="http://www.latrobe.edu.au/philosophy/phimvt/joy.html">http://www.latrobe.edu.au/philosophy/phimvt/joy.html</a> <br />&ndash; 
Joy Programming Language, stránka s&nbsp;rozcestníkem informací o programovacím jazyku Joy</li>

<li><a href="http://www.latrobe.edu.au/philosophy/phimvt/joy/j01tut.html">http://www.latrobe.edu.au/philosophy/phimvt/joy/j01tut.html</a> <br />&ndash; Tutorial on Joy</li>

<li><a href="http://www.latrobe.edu.au/philosophy/phimvt/joy/j06prg.html">http://www.latrobe.edu.au/philosophy/phimvt/joy/j06prg.html</a> <br />&ndash; Programming in Joy</li>

<li><a href="http://www.latrobe.edu.au/philosophy/phimvt/joy/synops.html">http://www.latrobe.edu.au/philosophy/phimvt/joy/synops.html</a> <br />&ndash; Synopsis of the language Joy</li>

<li><a
href="http://www.latrobe.edu.au/philosophy/phimvt/joy/faq.html">http://www.latrobe.edu.au/philosophy/phimvt/joy/faq.html</a>
<br />&ndash; Frequently Asked Questions about Joy, obsahuje i èásteèné
porovnání s&nbsp;nìkterými dal¹ími programovacími jazyky zalo¾enými na
zásobníkovém kódu</li>

<li><a
href="http://en.wikipedia.org/wiki/Factor_(programming_language)">http://en.wikipedia.org/wiki/Factor_(programming_language)</a>
<br />&ndash; Factor Programming Language, programovací jazyk znaènì
inspirovaný Joyem</li>

<li><a href="http://www.fig-uk.org/">http://www.fig-uk.org/</a> <br />&ndash; stránka
sdru¾ení <i>FIG UK &ndash; The United Kingdom Forth Interest Group</i>. Jedná se o
jedno z&nbsp;prvních sdru¾ení FIG, které se zamìøuje na vydávání èasopisu
<i>ForthWrite</i> (v&nbsp;minulosti 6 èísel za rok) a také údr¾bì a roz¹iøování rozsáhlé
knihovny zamìøené na Forth. Èlenové tohoto sdru¾ení pochází zejména z&nbsp;Velké
Británie, nìkteøí èlenové jsou v¹ak i z&nbsp;USA, Ruska, Japonska apod.</li>

<li><a href="http://www.colorforth.com/">http://www.colorforth.com/</a> <br />&ndash;
domácí stránka Chucka Moorea, vynálezce Forthu. Na této stránce jsou
k&nbsp;dispozici nìkteré technické detaily o zásobníkových procesorech a
zejména popis systému <i>ColorForth</i> spolu s&nbsp;jeho zdrojovými texty
(<i>bootstrap code</i>) napsanými v&nbsp;assembleru x86.</li>

<li><a href="http://zforth.com/">http://zforth.com/</a> <br />&ndash; takzvaný <i>The
Forth Programming Webring</i>, poèátek øetìzce stránek vìnovaných Forthu a
pøíbuzným tématùm. Zajímavé a mo¾ná i pøíznaèné je, ¾e tento server je vytvoøen pomocí systému
<i>zHTTP</i>, který je napsaný v&nbsp;dialektu programovacího jazyka Forth
nazvaného <i>zForth</i>.</li>

<li><a
href="http://www.hp.com/calculators/articles/rpn.html">http://www.hp.com/calculators/articles/rpn.html</a>
<br />&ndash; stránka firmy HP, na které je velmi podrobnì popsána obrácená Polská notace
(RPN &ndash; Reverse Polish Notation), která je pou¾itá jak u kalkulátorù této firmy,
tak i pøi zápisu výrazù v&nbsp;programovacích jazycích Forth, PostScript i Joy.</li>

<li><a
href="http://en.wikipedia.org/wiki/Forth_programming_language">http://en.wikipedia.org/wiki/Forth_programming_language</a>
<br />&ndash; stránka Wikipedie o programovacím jazyku Forth.</li>

<li><a
href="http://en.wikipedia.org/wiki/Chuck_Moore">http://en.wikipedia.org/wiki/Chuck_Moore</a>
<br />&ndash; stránka Wikipedie o Chucku Moorovi, vynálezci Forthu.</li>

<li><a href="http://en.wikipedia.org/wiki/Joy_(programming_language)">http://en.wikipedia.org/wiki/Joy_(programming_language)</a> <br />&ndash; Wikipedia EN: Joy (programming language)</li>

<li><a href="http://en.wikipedia.org/wiki/Primitive_recursive_function">http://en.wikipedia.org/wiki/Primitive_recursive_function</a> <br />&ndash; Wikipedia EN: Primitive recursive function</li>

<li><a href="http://en.wikipedia.org/wiki/Mu-recursive_function">http://en.wikipedia.org/wiki/Mu-recursive_function</a> <br />&ndash; Wikipedia EN: &micro;-recursive function</li>

<li><a href="http://cs.wikipedia.org/wiki/Primitivnì_rekurzivní_funkce">http://cs.wikipedia.org/wiki/Primitivnì_rekurzivní_funkce</a> <br />&ndash; Wikipedia CS: Primitivnì rekurzivní funkce</li>

<li><a href="http://cs.wikipedia.org/wiki/Èásteènì_rekurzivní_funkce">http://cs.wikipedia.org/wiki/Èásteènì_rekurzivní_funkce</a> <br />&ndash; Wikipedia CS: Èásteènì rekurzivní funkce</li>

<li><a
href="http://home.earthlink.net/~mrob/pub/lang_srom.html">http://home.earthlink.net/~mrob/pub/lang_srom.html</a>
<br />&ndash; porovnání programovacích jazykù podle názoru programátorù.</li>

<li><a
href="http://www.forth.com/resources/evolution/index.html">http://www.forth.com/resources/evolution/index.html</a>
<br />&ndash; The Evolution of Forth &ndash; velmi dobøe zpracovaná historie Forthu.</li>

<li>Wikipedia EN: Primitive recursive function:<br />
<a href="http://en.wikipedia.org/wiki/Primitive_recursive_function">http://en.wikipedia.org/wiki/Primitive_recursive_function</a>
</li>

<li>Wikipedia EN: &micro;-recursive function:<br />
<a href="http://en.wikipedia.org/wiki/Mu-recursive_function">http://en.wikipedia.org/wiki/Mu-recursive_function</a>
</li>

<li>Wikipedia CS: Primitivnì rekurzivní funkce:<br />
<a href="http://cs.wikipedia.org/wiki/Primitivnì_rekurzivní_funkce">http://cs.wikipedia.org/wiki/Primitivnì_rekurzivní_funkce</a>
</li>

<li>Wikipedia CS: Èásteènì rekurzivní funkce:<br />
<a href="http://cs.wikipedia.org/wiki/Èásteènì_rekurzivní_funkce">http://cs.wikipedia.org/wiki/Èásteènì_rekurzivní_funkce</a>
</li>

<li>Simulátor kultovní kalkulaèky HP-35 vytvoøený v&nbsp;JavaScriptu:<br />
<a href="http://www.mac-net.com/host/pages/hp35/calc.html">http://www.mac-net.com/host/pages/hp35/calc.html</a>
</li>

</ul>



<p></p><p></p>
<p><small>Autor: <a href="http://www.fit.vutbr.cz/~tisnovpa">Pavel Ti¹novský</a> &nbsp; 2008</small></p>
</body>
</html>

