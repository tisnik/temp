<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
        "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html>
<head>
<title>Programovací jazyk C3: evoluce, nikoli revoluce (2)</title>
<meta name="Author" content="Pavel Tisnovsky" />
<meta name="Generator" content="vim" />
<meta http-equiv="content-type" content="text/html; charset=utf-8" />
<style type="text/css">
         body {color:#000000; background:#ffffff;}
         h1  {font-family: arial, helvetica, sans-serif; color:#ffffff; background-color:#c00000; text-align:center; padding-left:1em}
         h2  {font-family: arial, helvetica, sans-serif; color:#ffffff; background-color:#0000c0; padding-left:1em; text-align:left}
         h3  {font-family: arial, helvetica, sans-serif; color:#000000; background-color:#c0c0c0; padding-left:1em; text-align:left}
         h4  {font-family: arial, helvetica, sans-serif; color:#000000; background-color:#e0e0e0; padding-left:1em; text-align:left}
         a   {font-family: arial, helvetica, sans-serif;}
         li  {font-family: arial, helvetica, sans-serif; color:#000000; text-align:justify; width:450px;}
         ol  {font-family: arial, helvetica, sans-serif; color:#000000; text-align:justify; width:450px;}
         ul  {font-family: arial, helvetica, sans-serif; color:#000000; text-align:justify; width:450px;}
         p   {font-family: arial, helvetica, sans-serif; color:#000000; text-align:justify;}
         pre {background:#e0e0e0}
</style>
</head>

<body>

<h1>Programovací jazyk C3: evoluce, nikoli revoluce (2)</h1>

<h3>Pavel Tišnovský</h3>

<p></p>

<h1>Úvodník</h1>

<p></p>



<h2>Obsah</h2>

<p><a href="#k01">1. Rezervovaná klíčová slova programovacího jazyka C3</a></p>
<p><a href="#k02">2. Nejkratší možný program: definice prázdné funkce <strong>main</strong></a></p>
<p><a href="#k03">3. Definice jména modulu</a></p>
<p><a href="#k04">4. Klasický program typu &bdquo;Hello, world!&ldquo;</a></p>
<p><a href="#k05">5. Návratová hodnota procesu</a></p>
<p><a href="#k06">6. Volání nativní céčkovské funkce</a></p>
<p><a href="#k07">7. Datový typ <strong>bool</strong></a></p>
<p><a href="#k08">8. Automatické konverze celočíselných hodnot do proměnných typu <strong>bool</strong>?<strong>bool</strong></a></p>
<p><a href="#k09">9. Explicitní konverze mezi celými čísly a typy <strong>bool</strong></a></p>
<p><a href="#k10">10. Zjištění velikosti obsazeného bloku paměti v&nbsp;čase překladu</a></p>
<p><a href="#k11">11. Celočíselné datové typy</a></p>
<p><a href="#k12">12. Zápis konstant celočíselných datových typů</a></p>
<p><a href="#k13">13. Zjištění velikosti obsazeného bloku paměti pro celočíselné datové typy</a></p>
<p><a href="#k14">*** 14. Automatické a explicitní konverze mezi celočíselnými datovými typy</a></p>
<p><a href="#k15">*** 15. Numerické hodnoty s&nbsp;plovoucí řádovou čárkou</a></p>
<p><a href="#k16">16. Velmi užitečný datový typ &ndash; vektor</a></p>
<p><a href="#k17">17. Operace prováděné s&nbsp;celými vektory</a></p>
<p><a href="#k18">18. Zjištění velikosti bloku obsazeného vektorem v&nbsp;operační paměti</a></p>
<p><a href="#k19">19. Repositář s&nbsp;demonstračními příklady</a></p>
<p><a href="#k20">20. Odkazy na Internetu</a></p>



<p><a name="k01"></a></p>
<h2 id="k01">1. Rezervovaná klíčová slova programovacího jazyka C3</h2>

<p>V&nbsp;programovacím jazyku C3 je definováno poměrně velké množství
klíčových slov (možná až moc velký počet na céčkovský jazyk). Jedná se o
následující slova, mezi nimiž mj.&nbsp;nalezneme i jména základních datových
typů:</p>

<pre>
void        bool        char        double
float       float16     int128      ichar
int         iptr        isz         long
short       uint128     uint        ulong
uptr        ushort      usz         float128
any         fault       typeid      assert
asm         bitstruct   break       case
catch       const       continue    alias
default     defer       typedef     do
else        enum        extern      false
for         foreach     foreach_r   fn
tlocal      if          inline      import
macro       module      nextcase    null
return      static      struct      switch
true        try         union       var
while       attrdef
</pre>

<p>Některá klíčová slova začínají znakem dolaru a většina z&nbsp;nich se
používá v&nbsp;makrech, což je téma, kterému se budeme věnovat příště (makra
v&nbsp;C3 jsou zcela odlišná od maker známých z&nbsp;jazyka C):</p>

<pre>
$alignof    $assert     $case       $default
$defined    $echo       $embed      $exec
$else       $endfor     $endforeach $endif
$endswitch  $eval       $evaltype   $error
$extnameof  $for        $foreach    $if
$include    $nameof     $offsetof   $qnameof
$sizeof     $stringify  $switch     $typefrom
$typeof     $vacount    $vatype     $vaconst
$vaarg      $vaexpr     $vasplat
</pre>

<p><div class="rs-tip-major">Poznámka: zajímavé je, že v&nbsp;částečně podobném
<a href="https://www.root.cz/serialy/programovaci-jazyk-go/">jazyce Go</a> je
rezervovaných klíčových slov mnohem méně &ndash; konkrétně jen 25. Je tomu tak
mj.&nbsp;i z&nbsp;toho důvodu, že sem nespadají jména základních datových
typů:</div></p>

<pre>
break        default      func         interface    select
case         defer        go           map          struct
chan         else         goto         package      switch
const        fallthrough  if           range        type
continue     for          import       return       var
</pre>



<p><a name="k02"></a></p>
<h2 id="k02">2. Nejkratší možný program: definice prázdné funkce <strong>main</strong></h2>

<p>Podívejme se nyní na to, jak vypadá nejkratší možný program zapsaný
v&nbsp;jazyce C3. V&nbsp;C3 není nutné explicitně zapisovat jméno modulu atd.
atd. &ndash; pouze postačuje definice prázdné funkce nazvané
<strong>main</strong>. Jak jsme si již řekli minule, začíná definice funkce
klíčovým slovem <strong>fn</strong>, za kterým následuje jméno funkce,
popř.&nbsp;její parametry v&nbsp;závorkách:</p>

<pre>
<u>fn</u> <u>void</u> <strong>main</strong>()
{
}
</pre>

<p><div class="rs-tip-major">Poznámka: v&nbsp;tomto případě bude jméno
spustitelného souboru získaného překladem (<strong>c3c compile</strong>)
odvozeno od jména souboru se zdrojovým kódem.</div></p>



<p><a name="k03"></a></p>
<h2 id="k03">3. Definice jména modulu</h2>

<p>Na prvním řádku ve zdrojovém kódu může být specifikováno jméno modulu,
v&nbsp;jehož rámci budou definovány všechny další symboly (globální proměnné,
funkce atd.). Před jménem modulu je uvedeno klíčové slovo
<strong>module</strong>, takže celý zápis vypadá následovně:</p>

<pre>
<u>module</u> program_stub;
&nbsp;
<u>fn</u> <u>void</u> <strong>main</strong>()
{
}
</pre>

<p>Jméno modulu má vliv i na jméno výsledného spustitelného souboru &ndash; to
se již nebude odvozovat od jména souboru se zdrojovým kódem, ale právě od jména
modulu.</p>

<p><div class="rs-tip-major">Poznámka: do jisté míry se <strong>module</strong>
podobá klíčovému slovu <strong>package</strong> z&nbsp;jazyka Go, ovšem
v&nbsp;C3 není jméno modulu povinné a liší se i další detaily, ke kterým se
ještě vrátíme.</div></p>



<p><a name="k04"></a></p>
<h2 id="k04">4. Klasický program typu &bdquo;Hello, world!&ldquo;</h2>

<p>Již téměř 47 let, konkrétně od vydání slavné knihy <i>The C Programming
Language</i>, je dobrým zvykem ukazovat základní vlastnosti nějakého
programovacího jazyka na programu typu &bdquo;Hello, world!&ldquo;. Můžeme
postupovat stejně &ndash; v&nbsp;C3 tento program vypadá následovně:</p>

<pre>
<u>module</u> hello_world;
<u>import</u> std::io;
&nbsp;
<u>fn</u> <u>void</u> <strong>main</strong>()
{
    io::printn("Hello, world!");
}
</pre>

<p>Zde jsou skutečně ukázány některé zajímavé vlastnosti jazyka C3, konkrétně
jeho práce s&nbsp;moduly (definice vlastního modulu a import jiného modulu),
práce se jmennými prostory (tím se C3 do značné míry podobá již výše zmíněnému
jazyku Go) i to, že prakticky veškeré definice začínají klíčovým slovem,
zatímco v&nbsp;klasickém céčku začínají jménem typu (výjimkou je asi jen
<strong>typedef</strong>).</p>



<p><a name="k05"></a></p>
<h2 id="k05">5. Návratová hodnota procesu</h2>

<p>V&nbsp;případě, že má proces vracet nějakou celočíselnou hodnotu (odlišnou
od nuly) do volajícího procesu, typicky do shellu, postačuje tuto hodnotu
vrátit z&nbsp;funkce <strong>main</strong>, a to naprosto stejným způsobem,
jako je tomu v&nbsp;jazyku C. Nemusíme tedy používat obezličky typu
<strong>os.Exit</strong>, <strong>sys.exit</strong> atd.:</p>

<pre>
<u>module</u> exit_value;
<u>import</u> std::io;
&nbsp;
<u>fn</u> <u>int</u> main()
{
    io::printn("Hello, world!");
    <u>return</u> 42;
}
</pre>

<p>Ukázka použití:</p>

<pre>
$ <strong>c3c compile 04_exit_value.c3</strong>
Program linked to executable './exit_value'.
&nbsp;
$ <strong>./exit_value</strong>
Hello, world!
&nbsp;
$ <strong>echo $?</strong>
42
</pre>

<p><div class="rs-tip-major">Poznámka: povšimněte si, kolik rezervovaných
klíčových slov jsme již použili, a to většinou bez nutnosti jejich podrobného
popisu &ndash; jazyk C3 se podobá C do takové míry, že detailnější popis
většinou není nutný.</div></p>



<p><a name="k06"></a></p>
<h2 id="k06">6. Volání nativní céčkovské funkce</h2>

<p>Jednou z&nbsp;nejdůležitějších vlastností programovacího jazyka C3 je jeho
schopnost bezproblémového volání céčkovských funkcí, například funkcí
definovaných ve standardní céčkovské knihovně. Díky tomu je možné C3 relativně
snadno nasadit v&nbsp;ekosystému postaveném okolo jazyka C, aniž by bylo nutné
&bdquo;znovuvynalézat&ldquo; FFI atd.</p>

<p>Vyzkoušejme si to na příkladu volání céčkovské funkce <strong>puts</strong>
ze standardní knihovny. Tato funkce jako svůj parametr akceptuje řetězec;
přičemž řetězce jsou v&nbsp;C3 prakticky stejné, jako řetězce v&nbsp;C (akorát
je plně podporováno UTF-8). V&nbsp;příkladu importujeme céčkovskou knihovnu
<strong>libc</strong> tak, jakoby se jednalo o běžný modul v&nbsp;C3, akorát
bez jmenného prostoru. Díky tomu je možné volat funkci <strong>puts</strong>,
která je v&nbsp;této knihovně definována:</p>

<pre>
module c_function_call;
import libc;
&nbsp;
extern fn int puts(char*);
&nbsp;
fn void <strong>main</strong>()
{
    puts("Hello, world!");
}
</pre>



<p><a name="k07"></a></p>
<h2 id="k07">7. Datový typ <strong>bool</strong></h2>

<p>Jazyk C3 se od klasického céčka v&nbsp;některých ohledech odlišuje. Týká se
to mj.&nbsp;i typového systému, takže se nyní pokusíme na některé rozdíly
upozornit. V&nbsp;jazyku C3 je možné, podobně jako v&nbsp;mnoha dalších
programovacích jazycích, pracovat s&nbsp;hodnotami typu <strong>bool</strong>,
tj.&nbsp;pravdivostními hodnotami <strong>true</strong> a
<strong>false</strong>. Základní způsob práce s&nbsp;těmito hodnotami je dobře
pochopitelný:</p>

<pre>
module bool_type;
import std::io;
&nbsp;
fn void <strong>main</strong>()
{
    bool x = true;
    bool y = false;
    io::printf("Bool value=%b\n", x);
    io::printf("Bool value=%b\n", y);
}
</pre>

<p>Výsledky:</p>

<pre>
Bool value=1
Bool value=0
</pre>

<p>I když tento příklad vypsat numerické výsledky, není v&nbsp;C3 možné
s&nbsp;hodnotami typu <strong>bool</strong> provádět například součty (což
například v&nbsp;Pythonu je možné):</p>

<pre>
module bool_add;
import std::io;
&nbsp;
fn void <strong>main</strong>()
{
    bool x = true;
    bool y = false;
    io::printf("%d\n", x+y);
}
</pre>

<p>Tento příklad není přeložitelný, což je ostatně dobře:</p>

<pre>
 5: {
 6:     bool x = true;
 7:     bool y = false;
 8:     io::printf("%d\n", x+y);
                           ^^^
(/home/ptisnovs/src/c3-examples/c3-basics/1.c3:8:24) Error: Cannot do the addition 'bool' + 'bool'.
</pre>



<p><a name="k08"></a></p>
<h2 id="k08">8. Automatické konverze celočíselných hodnot do proměnných typu <strong>bool</strong>?</h2>

<p>V&nbsp;některých programovacích jazycích je typ <strong>bool</strong> chápán
jako podmnožina celočíselných datových typů, což například umožňuje do proměnné
typu <strong>bool</strong> přiřadit celočíselnou hodnotu. V&nbsp;jazyku C3 tomu
tak ovšem není a pokud se o podobné přiřazení pokusíme, dojde k&nbsp;chybě při
překladu, což si můžeme velmi snadno ověřit na dalším demonstračním
příkladu:</p>

<pre>
module int_to_bool_1;
import std::io;
&nbsp;
fn void <strong>main</strong>()
{
    <u>bool x = 1</u>;
    <u>bool y = 0</u>;
    <u>bool z = 42</u>;
    io::printf("Bool value=%b\n", x);
    io::printf("Bool value=%b\n", y);
    io::printf("Bool value=%b\n", z);
}
</pre>

<p>Překladač jazyka C3 v&nbsp;tomto případě vypíše chybu u všech tří přiřazení,
nikoli pouze u přiřazení posledního:</p>

<pre>
 3:
 4: fn void main()
 5: {
 6:     bool x = 1;
                 ^
(/home/ptisnovs/src/c3-examples/c3-basics/07_int_to_bool.c3:6:14) Error: 'int' cannot implicitly be converted to 'bool', but you may use a cast.

 4: fn void main()
 5: {
 6:     bool x = 1;
 7:     bool y = 0;
                 ^
(/home/ptisnovs/src/c3-examples/c3-basics/07_int_to_bool.c3:7:14) Error: 'int' cannot implicitly be converted to 'bool', but you may use a cast.

 5: {
 6:     bool x = 1;
 7:     bool y = 0;
 8:     bool z = 42;
                 ^^
(/home/ptisnovs/src/c3-examples/c3-basics/07_int_to_bool.c3:8:14) Error: 'int' cannot implicitly be converted to 'bool', but you may use a cast.
</pre>



<p><a name="k09"></a></p>
<h2 id="k09">9. Explicitní konverze mezi celými čísly a typy <strong>bool</strong></h2>

<p>V&nbsp;případě, že je vyžadováno provést konverzi celého čísla na typ
<strong>bool</strong>, je nutné konverzi zapsat explicitně. Nulové hodnoty
budou převedeny na <strong>false</strong>, ostatní hodnoty (včetně hodnot
záporných) na <strong>true</strong>. Operace konverze se zapisuje naprosto
stejným způsobem, jako v&nbsp;klasickém céčku, tedy následovně:</p>

<pre>
module int_to_bool_2;
import std::io;
&nbsp;
fn void <strong>main</strong>()
{
    bool x = <u>(bool)1</u>;
    bool y = <u>(bool)0</u>;
    bool z = <u>(bool)42</u>;
    io::printf("Bool value=%b\n", x);
    io::printf("Bool value=%b\n", y);
    io::printf("Bool value=%b\n", z);
}
</pre>

<p>Výsledky:</p>

<pre>
Bool value=1
Bool value=0
Bool value=1
</pre>

<p><div class="rs-tip-major">Poznámka: skutečně musíme konverzi zapsat
&bdquo;céčkovským&ldquo; způsobem. Pokud se pokusíte o zápis známý
z&nbsp;jazyka Go, bude při překladu nahlášena chyba:</div></p>

<pre>
module int_to_bool_3;
import std::io;
&nbsp;
fn void <strong>main</strong>()
{
    bool x = <u>bool(1)</u>;
    bool y = <u>bool(0)</u>;
    bool z = <u>bool(42)</u>;
    io::printf("Bool value=%b\n", x);
    io::printf("Bool value=%b\n", y);
    io::printf("Bool value=%b\n", z);
}
</pre>

<p>Popis chyby je v&nbsp;tomto případě velmi dobře čitelný:</p>

<pre>
 3: 
 4: fn void main()
 5: {
 6:     bool x = bool(1);
                 ^^^^^^^
(/home/ptisnovs/src/c3-examples/c3-basics/09_int_to_bool.c3:6:14) Error: A type cannot be followed by (), if you intended a cast, use '(type) expression'.

 4: fn void main()
 5: {
 6:     bool x = bool(1);
 7:     bool y = bool(0);
                 ^^^^^^^
(/home/ptisnovs/src/c3-examples/c3-basics/09_int_to_bool.c3:7:14) Error: A type cannot be followed by (), if you intended a cast, use '(type) expression'.

 5: {
 6:     bool x = bool(1);
 7:     bool y = bool(0);
 8:     bool z = bool(42);
                 ^^^^^^^^
(/home/ptisnovs/src/c3-examples/c3-basics/09_int_to_bool.c3:8:14) Error: A type cannot be followed by (), if you intended a cast, use '(type) expression'.
</pre>



<p><a name="k10"></a></p>
<h2 id="k10">10. Zjištění velikosti obsazeného bloku paměti v&nbsp;čase překladu</h2>

<p>Mezi další užitečnou vlastnost programovacího jazyka C3 patří schopnost
zjištění velikosti bloku, který se v&nbsp;operační paměti musí alokovat pro
zadaný datový typ. Zatímco v&nbsp;céčku se pro tyto účely používá operátor
<strong>sizeof</strong>, v&nbsp;jazyku C3 má každý datový typ definován
pseudoatribut nazvaný <strong>sizeof</strong>. Přečtení velikosti paměťového
bloku pro typ <strong>bool</strong> je tedy snadné:</p>

<pre>
module bool_sizeof;
import std::io;
&nbsp;
fn void <strong>main</strong>()
{
    io::printf("Bool size=%d\n", <u>bool.sizeof</u>);
}
</pre>

<p>Tento program by měl po svém překladu a spuštění vypsat velikost bloku
reprezentovanou v&nbsp;bajtech:</p>

<pre>
Bool size=1
</pre>



<p><a name="k11"></a></p>
<h2 id="k11">11. Celočíselné datové typy</h2>

<p>Jazyk C3 programátorům nabízí běžnou &bdquo;sadu&ldquo; celočíselných
datových typů, a to jak typů se znaménkem, tak i bez znaménka. U všech těchto
typů je definitoricky určena jejich velikost v&nbsp;bajtech i rozsah hodnot
(minimální a maximální hodnota) &ndash; a to na všech platformách. Celočíselné
typy se znaménkem používají dvojkový doplněk a pojmenovány jsou
<strong>ichar</strong>, <strong>short</strong>, <strong>int</strong>,
<strong>long</strong> a <strong>int128</strong>. Nejedná se o modifikátory
velikosti, ale přímo o jména datových typů:</p>

<pre>
module int_types;
import std::io;
&nbsp;
fn void <strong>main</strong>()
{
    <u>ichar</u> a = '*';
    <u>short</u> b = -42;
    <u>int</u> c = -42;
    <u>long</u> d = -42;
    <u>int128</u> e = -42;
&nbsp;
    io::printf("ichar value=%c\n", a);
    io::printf("short value=%d\n", b);
    io::printf("int value=%d\n", c);
    io::printf("long value=%d\n", d);
    io::printf("int128 value=%d\n", e);
}
</pre>

<p>Výsledky vypsané tímto demonstračním příkladem by měly vypadat
následovně:</p>

<pre>
ichar value=*
short value=-42
int value=-42
long value=-42
int128 value=-42
</pre>

<p>Celočíselné typy se znaménkem se jmenují <strong>char</strong>,
<strong>ushort</strong>, <strong>uint</strong>, <strong>ulong</strong> a
<strong>uint128</strong>:</p>

<pre>
module uint_types;
import std::io;
&nbsp;
fn void <strong>main</strong>()
{
    <u>char</u> a = '*';
    <u>ushort</u> b = 42;
    <u>uint</u> c = 42;
    <u>ulong</u> d = 42;
    <u>uint128</u> e = 42;
&nbsp;
    io::printf("ichar value=%c\n", a);
    io::printf("short value=%d\n", b);
    io::printf("int value=%d\n", c);
    io::printf("long value=%d\n", d);
    io::printf("int128 value=%d\n", e);
}
</pre>

<p>Opět se podívejme na výsledky:</p>

<pre>
ichar value=*
short value=42
int value=42
long value=42
int128 value=42
</pre>

<p><div class="rs-tip-major">Poznámka: pozor je nutné dávat především na typ
<strong>char</strong>, který má v&nbsp;jiných jazycích odlišný význam (a může
se jednat o typ se znaménkem či dokonce o hodnotu uloženou ve více
bajtech).</div></p>



<p><a name="k12"></a></p>
<h2 id="k12">12. Zápis konstant celočíselných datových typů</h2>

<p>Pokusme se nyní přeložit následující program, ve kterém do celočíselných
proměnných přiřazujeme celočíselné hodnoty vypočtené v&nbsp;čase překladu
(výrazy jsou konstantní):</p>

<pre>
module no_suffixes;
import std::io;
&nbsp;
fn void <strong>main</strong>()
{
    uint128 a = <u>100</u>;
    uint128 b = <u>100*100</u>;
    uint128 c = <u>100*100*100</u>;
    uint128 d = <u>100*100*100*100</u>;
    uint128 e = <u>100*100*100*100*100</u>;
    uint128 f = <u>100*100*100*100*100*100</u>;
&nbsp;
    io::printf("a=%d\n", a);
    io::printf("b=%d\n", b);
    io::printf("c=%d\n", c);
    io::printf("d=%d\n", d);
    io::printf("e=%d\n", e);
    io::printf("f=%d\n", f);
}
</pre>

<p>Tento zdrojový kód se sice přeloží, ale výsledky budou pro poslední dvě
hodnoty špatné, protože interně došlo k&nbsp;přetečení (resp.&nbsp;zde
k&nbsp;přenosu) při výpočtu konstant ukládaných do proměnných:</p>

<pre>
a=100
b=10000
c=1000000
d=100000000
e=1410065408
f=340282366920938463463374607431040831488
</pre>

<p>Pro korektní výpočty je nutné alespoň u jednoho čísla použít <i>suffix</i>,
který určí typ této konstanty. Konkrétně pro hodnoty typu
<strong>uint128</strong> je tímto suffixem sekvence znaků
<strong>u128</strong>:</p>

<pre>
module no_suffixes;
import std::io;
&nbsp;
fn void <strong>main</strong>()
{
    uint128 a = <u>100u128</u>;
    uint128 b = <u>100u128*100</u>;
    uint128 c = <u>100u128*100*100</u>;
    uint128 d = <u>100u128*100*100*100</u>;
    uint128 e = <u>100u128*100*100*100*100</u>;
    uint128 f = <u>100u128*100*100*100*100*100</u>;
&nbsp;
    io::printf("a=%d\n", a);
    io::printf("b=%d\n", b);
    io::printf("c=%d\n", c);
    io::printf("d=%d\n", d);
    io::printf("e=%d\n", e);
    io::printf("f=%d\n", f);
}
</pre>

<p>Výsledky jsou nyní korektní:</p>

<pre>
a=100
b=10000
c=1000000
d=100000000
e=10000000000
f=1000000000000
</pre>

<p>Pro úplnost si vypišme všechny podporované suffixy pro celočíselné hodnoty:</p>

<table>
<tr><th>suffix</th><th>typ</th></tr>
<tr><td>i8    </td><td>ichar</td></tr>
<tr><td>i16   </td><td>short</td></tr>
<tr><td>i32   </td><td>int</td></tr>
<tr><td>i64   </td><td>long</td></tr>
<tr><td>i128  </td><td>int128</td></tr>
<tr><td>&nbsp;</td><td>&nbsp;</td></tr>
<tr><td>u8    </td><td>char</td></tr>
<tr><td>u16   </td><td>ushort</td></tr>
<tr><td>u32   </td><td>uint</td></tr>
<tr><td>u     </td><td>uint</td></tr>
<tr><td>u64   </td><td>ulong</td></tr>
<tr><td>u128  </td><td>uint128</td></tr>
</table>



<p><a name="k13"></a></p>
<h2 id="k13">13. Zjištění velikosti obsazeného bloku paměti pro celočíselné datové typy</h2>

<p>I u celočíselných datových typů můžeme zjistit jejich velikost v&nbsp;paměti
s&nbsp;využitím pseudoatributu <strong>sizeof</strong>. Nejdříve si tento
postup vyzkoušíme u typů se znaménkem:</p>

<pre>
module uint_types;
import std::io;
&nbsp;
fn void <strong>main</strong>()
{
    io::printf("sizeof ichar  = %d\n", ichar.sizeof);
    io::printf("sizeof short  = %d\n", short.sizeof);
    io::printf("sizeof int    = %d\n", int.sizeof);
    io::printf("sizeof long   = %d\n", long.sizeof);
    io::printf("sizeof int128 = %d\n", int128.sizeof);
}
</pre>

<p>Výsledky by neměly být překvapivé:</p>

<pre>
sizeof ichar  = 1
sizeof short  = 2
sizeof int    = 4
sizeof long   = 8
sizeof int128 = 16
</pre>

<p>Stejný postup použijeme pro zjištění velikosti celočíselných datových typů
bez znaménka:</p>

<pre>
module uint_types;
import std::io;
&nbsp;
fn void <strong>main</strong>()
{
    io::printf("sizeof char    = %d\n", char.sizeof);
    io::printf("sizeof ushort  = %d\n", ushort.sizeof);
    io::printf("sizeof uint    = %d\n", uint.sizeof);
    io::printf("sizeof ulong   = %d\n", ulong.sizeof);
    io::printf("sizeof uint128 = %d\n", uint128.sizeof);
}
</pre>

<p>Výsledky:</p>

<pre>
sizeof char    = 1
sizeof ushort  = 2
sizeof uint    = 4
sizeof ulong   = 8
sizeof uint128 = 16
</pre>



<p><a name="k14"></a></p>
<h2 id="k14">14. Automatické a explicitní konverze mezi celočíselnými datovými typy</h2>

<p></p>

<pre>
module int_conversions;
import std::io;

fn void <strong>main</strong>()
{
    ichar a = 100;
    short b = 100*100;
    int c = 100*100*100;

    io::printf("a=%d\n", a);
    io::printf("b=%d\n", b);
    io::printf("c=%d\n", c);

    int x = a;
    int y = b;
    int z = c;

    io::printf("x=%d\n", x);
    io::printf("y=%d\n", y);
    io::printf("z=%d\n", z);
}
</pre>

<pre>
module int_conversions;
import std::io;

fn void <strong>main</strong>()
{
    ichar a = 100;
    short b = 100*100;
    int c = 100*100*100;

    io::printf("a=%d\n", a);
    io::printf("b=%d\n", b);
    io::printf("c=%d\n", c);

    short x = a;
    short y = b;
    short z = c;

    io::printf("x=%d\n", x);
    io::printf("y=%d\n", y);
    io::printf("z=%d\n", z);
}
</pre>

<pre>
module int_conversions;
import std::io;

fn void <strong>main</strong>()
{
    ichar a = 100;
    short b = 100*100;
    int c = 100*100*100;

    io::printf("a=%d\n", a);
    io::printf("b=%d\n", b);
    io::printf("c=%d\n", c);

    short x = (short)a;
    short y = (short)b;
    short z = (short)c;

    io::printf("x=%d\n", x);
    io::printf("y=%d\n", y);
    io::printf("z=%d\n", z);
}
</pre>



<p><a name="k15"></a></p>
<h2 id="k15">15. Numerické hodnoty s&nbsp;plovoucí řádovou čárkou</h2>

<p></p>

<pre>
module float_types;
import std::io;

fn void <strong>main</strong>()
{
    float16 x = 1e1;
    float y = 1e10;
    double z = 1e100;
    float128 w = 1e100;

    io::printf("x=%s\n", x);
    io::printf("y=%s\n", y);
    io::printf("z=%s\n", z);
    io::printf("w=%s\n", w);
}
</pre>



<p><a name="k16"></a></p>
<h2 id="k16">16. Velmi užitečný datový typ &ndash; vektor</h2>

<p>V&nbsp;programovacím jazyce C3 nalezneme jeden důležitý datový typ, který má
sice (z&nbsp;mnoha dobrých důvodů) různá omezení, ovšem v&nbsp;praxi je velmi
užitečný. Jedná se o <i>vektory</i>. Tento datový typ je generický, protože je
možné (resp.&nbsp;přesněji řečeno nutné) explicitně určit typ prvků vektoru.
Počet prvků musí být znám již v&nbsp;době překladu, což je největší rozdíl
oproti klasickým polím. Ovšem díky tomu, že překladač zná délku vektoru, může
s&nbsp;nimi provádět optimalizované operace, typicky s&nbsp;využitím
vektorových instrukcí (SIMD) nabízených moderními mikroprocesory. I
z&nbsp;tohoto důvodu platí ještě jedno omezení: typy prvků vektorů jsou omezeny
na numerické hodnoty, pravdivostní hodnoty popř.&nbsp;na ukazatele.</p>

<p>V&nbsp;dalším demonstračním příkladu je ukázáno, jakým způsobem se deklaruje
proměnná typu vektor. Povšimněte si, že počet prvků vektoru je konstantní a
musí být umístěn mezi úhlové závorky (podtržená část kódu):</p>

<pre>
module float_types;
import std::io;
&nbsp;
fn void <strong>main</strong>()
{
    int[&lt;10&gt;] a = {1, 2, 3, 4, 5, 6, 7, 8, 9, 10};
&nbsp;
    io::printf("a=%s\n", a);
}
</pre>

<p>Po překladu a spuštění tohoto příkladu se celý vektor vypíše na standardní
výstup (povšimněte si způsobu výpisu):</p>

<pre>
a=[&lt;1, 2, 3, 4, 5, 6, 7, 8, 9, 10&gt;]
</pre>



<p><a name="k17"></a></p>
<h2 id="k17">17. Operace prováděné s&nbsp;celými vektory</h2>

<p>V&nbsp;čem ovšem spočívá užitečnost vektorů v&nbsp;porovnání s&nbsp;běžnými
(popř.&nbsp;s&nbsp;dynamicky alokovanými) poli? Nad prvky vektorů jsou
definovány například běžné aritmetické operace. Ty se provádí
s&nbsp;odpovídajícími si prvky vektorů, takže vektory lze sečíst, odečíst atd.
Navíc je možné dva vektory porovnat na rovnost nebo nerovnost, přičemž
výsledkem bude jediná pravdivostní hodnota <strong>true</strong> či
<strong>false</strong>, která nezávisí na tom, zda se jedná o odlišné instance
či o jediný objekt v&nbsp;paměti.</p>

<p>V&nbsp;dalším demonstračním příkladu jsou ukázány základní aritmetické
operace nad odpovídajícími si prvky vektorů. Za těmito operacemi jsou provedeny
aritmetické operace mezi vektorem a skalární hodnotou (skalární hodnota je
&bdquo;roztažena&ldquo; do formy vektoru a teprve poté se operace provede). A
nakonec si otestujeme porovnání různých vektorů na rovnost a nerovnost:</p>

<pre>
module float_types;
import std::io;
&nbsp;
fn void <strong>main</strong>()
{
    int[&lt;10&gt;] a = {1, 2, 3, 4, 5, 6, 7, 8, 9, 10};
    int[&lt;10&gt;] b = {2, 2, 2, 2, 2, 2, 2, 2, 2, 2};
&nbsp;
    io::printf("a=%s\n", a);
    io::printf("b=%s\n", b);
&nbsp;
    io::printn();
&nbsp;
    io::printf("a+b=%s\n", a+b);
    io::printf("a-b=%s\n", a-b);
    io::printf("a*b=%s\n", a*b);
    io::printf("a/b=%s\n", a/b);
&nbsp;
    io::printn();
&nbsp;
    io::printf("a+2=%s\n", a+2);
    io::printf("a-2=%s\n", a-2);
    io::printf("a*2=%s\n", a*2);
    io::printf("a/2=%s\n", a/2);
&nbsp;
    io::printn();
&nbsp;
    io::printf("a==b=%s\n", a==b);
    io::printf("a!=b=%s\n", a!=b);
    io::printf("a==a=%s\n", a==a);
    io::printf("a!=a=%s\n", a!=a);

    io::printn();
    io::printf("%s\n", a-a==b-b);
    io::printf("%s\n", a+b==b+a);
}
</pre>

<p>Po překladu a spuštění tohoto příkladu se nejdříve vypíšou oba vektory:</p>

<pre>
a=[&lt;1, 2, 3, 4, 5, 6, 7, 8, 9, 10&gt;]
b=[&lt;2, 2, 2, 2, 2, 2, 2, 2, 2, 2&gt;]
</pre>

<p>V&nbsp;dalším kroku se zobrazí výsledek provedení aritmetických operací mezi
prvky vektorů:</p>

<pre>
a+b=[&lt;3, 4, 5, 6, 7, 8, 9, 10, 11, 12&gt;]
a-b=[&lt;-1, 0, 1, 2, 3, 4, 5, 6, 7, 8&gt;]
a*b=[&lt;2, 4, 6, 8, 10, 12, 14, 16, 18, 20&gt;]
a/b=[&lt;0, 1, 1, 2, 2, 3, 3, 4, 4, 5&gt;]
</pre>

<p>Následuje blok s&nbsp;výsledky provedení aritmetických operací mezi vektorem
a skalární hodnotou:</p>

<pre>
a+2=[&lt;3, 4, 5, 6, 7, 8, 9, 10, 11, 12&gt;]
a-2=[&lt;-1, 0, 1, 2, 3, 4, 5, 6, 7, 8&gt;]
a*2=[&lt;2, 4, 6, 8, 10, 12, 14, 16, 18, 20&gt;]
a/2=[&lt;0, 1, 1, 2, 2, 3, 3, 4, 4, 5&gt;]
</pre>

<p>Nakonec jsou vypsány výsledky porovnání vektorů:</p>

<pre>
a==b=false
a!=b=true
a==a=true
a!=a=false
&nbsp;
true
true
</pre>

<p><div class="rs-tip-major">Poznámka: existují i metody pro práci
s&nbsp;vektory. O těchto metodách se zmíníme v&nbsp;navazujícím
textu.</div></p>



<p><a name="k18"></a></p>
<h2 id="k18">18. Zjištění velikosti bloku obsazeného vektorem v&nbsp;operační paměti</h2>

<p>I pro vektory je definována vlastnost <strong>sizeof</strong>, která nám
umožňuje zjistit (pochopitelně již v&nbsp;čase překladu), jakou velikost bude
mít vektor po své alokaci v&nbsp;operační paměti. V&nbsp;dnešním předposledním
demonstračním příkladu zjistíme velikosti bloků pro desetiprvkové vektory,
přičemž se budou lišit typy prvků:</p>

<pre>
module float_types;
import std::io;
&nbsp;
fn void <strong>main</strong>()
{
    io::printf("10 items of bool: %d\n", bool[&lt;10&gt;].sizeof);
    io::printf("10 items of ichar: %d\n", ichar[&lt;10&gt;].sizeof);
    io::printf("10 items of short: %d\n", short[&lt;10&gt;].sizeof);
    io::printf("10 items of int: %d\n", int[&lt;10&gt;].sizeof);
    io::printf("10 items of long: %d\n", long[&lt;10&gt;].sizeof);
    io::printf("10 items of int128: %d\n", int128[&lt;10&gt;].sizeof);
    io::printf("10 items of float16: %d\n", float16[&lt;10&gt;].sizeof);
    io::printf("10 items of float: %d\n", float[&lt;10&gt;].sizeof);
    io::printf("10 items of double: %d\n", double[&lt;10&gt;].sizeof);
    io::printf("10 items of float128: %d\n", float128[&lt;10&gt;].sizeof);
}
</pre>

<p>Z&nbsp;vypsaných hodnot je patrné, že se obecně obsadí větší paměťový
prostor, než který odpovídá výsledku <strong>počet_prvků * sizeof
prvek</strong>:</p>

<pre>
10 items of bool: 16
10 items of ichar: 16
10 items of short: 32
10 items of int: 64
10 items of long: 128
10 items of int128: 256
10 items of float16: 32
10 items of float: 64
10 items of double: 128
10 items of float128: 256
</pre>

<p>Jak přesně je délka alokovaného bloku odvozena od počtu prvků vektoru
zjistíme v&nbsp;dnešním posledním demonstračním příkladu. V&nbsp;něm si necháme
vypočítat velikost alokovaného bloku pro vektory se shodnými typy prvků, ale
s&nbsp;odlišnou délkou:</p>

<pre>
module float_types;
import std::io;
&nbsp;
fn void <strong>main</strong>()
{
    io::printf("1 items of int: %d\n", int[&lt;1&gt;].sizeof);
    io::printf("2 items of int: %d\n", int[&lt;2&gt;].sizeof);
    io::printf("3 items of int: %d\n", int[&lt;3&gt;].sizeof);
    io::printf("4 items of int: %d\n", int[&lt;4&gt;].sizeof);
    io::printf("5 items of int: %d\n", int[&lt;5&gt;].sizeof);
    io::printf("6 items of int: %d\n", int[&lt;6&gt;].sizeof);
    io::printf("7 items of int: %d\n", int[&lt;7&gt;].sizeof);
    io::printf("8 items of int: %d\n", int[&lt;8&gt;].sizeof);
    io::printf("9 items of int: %d\n", int[&lt;9&gt;].sizeof);
    io::printf("10 items of int: %d\n", int[&lt;10&gt;].sizeof);
    io::printf("11 items of int: %d\n", int[&lt;11&gt;].sizeof);
    io::printf("12 items of int: %d\n", int[&lt;12&gt;].sizeof);
    io::printf("13 items of int: %d\n", int[&lt;13&gt;].sizeof);
    io::printf("14 items of int: %d\n", int[&lt;14&gt;].sizeof);
    io::printf("15 items of int: %d\n", int[&lt;15&gt;].sizeof);
}
</pre>

<p>Výsledky pro situaci, kdy <strong>sizeof int==4</strong>:</p>

<pre>
1 items of int: 4
2 items of int: 8
3 items of int: 16
4 items of int: 16
5 items of int: 32
6 items of int: 32
7 items of int: 32
8 items of int: 32
9 items of int: 64
10 items of int: 64
11 items of int: 64
12 items of int: 64
13 items of int: 64
14 items of int: 64
15 items of int: 64
</pre>

<p><div class="rs-tip-major">Poznámka: v&nbsp;tomto příkladu není možné použít
klasickou počítanou smyčku, protože délka vektoru musí být známa v&nbsp;čase
překladu. Pomoci nám může makro, což je však téma na samostatný
článek.</div></p>



<p><a name="k19"></a></p>
<h2 id="k19">19. Repositář s&nbsp;demonstračními příklady</h2>

<p>Dnes i <a href="">minule</a> ukázané demonstrační příklady byly uloženy do repositáře dostupného na
adrese <a
href="https://github.com/tisnik/c3-examples">https://github.com/tisnik/c3-examples</a>.
Následují odkazy na jednotlivé příklady (či jejich nedokončené části):</p>

<table>
<tr><th> #</th><th>Příklad</th><th>Stručný popis</th><th>Adresa</th></tr>
<tr><td> 1</td><td>factorial.c3</td><td>realizace výpočtu faktoriálu</td><td><a href="https://github.com/tisnik/c3-examples/blob/master/introduction/factorial.c3">https://github.com/tisnik/c3-examples/blob/master/introduction/factorial.c3</a></td></tr>
<tr><td> 2</td><td>factorial_macro.c3</td><td>výpočet faktoriálu konkrétní hodnoty implementovaný formou makra</td><td><a href="https://github.com/tisnik/c3-examples/blob/master/introduction/factorial_macro.c3">https://github.com/tisnik/c3-examples/blob/master/introduction/factorial_macro.c3</a></td></tr>
<tr><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td></tr>
<tr><td> 3</td><td>swap_macro.c3</td><td>makro realizující prohození dvou hodnot</td><td><a href="https://github.com/tisnik/c3-examples/blob/master/introduction/swap_macro.c3">https://github.com/tisnik/c3-examples/blob/master/introduction/swap_macro.c3</a></td></tr>
<tr><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td></tr>
<tr><td> 4</td><td>renderer.c</td><td>výpočet a vykreslení Juliovy množiny implementovaný v&nbsp;jazyku C</td><td><a href="https://github.com/tisnik/c3-examples/blob/master/introduction/renderer.c">https://github.com/tisnik/c3-examples/blob/master/introduction/renderer.c</a></td></tr>
<tr><td> 5</td><td>renderer_v1.c3</td><td>definice datové struktury s&nbsp;rozměry rastrového obrázku a skeleton všech funkcí</td><td><a href="https://github.com/tisnik/c3-examples/blob/master/introduction/renderer_v1.c3">https://github.com/tisnik/c3-examples/blob/master/introduction/renderer_v1.c3</a></td></tr>
<tr><td> 6</td><td>renderer_v2.c3</td><td>anotace parametrů funkcí typu ukazatel (<i>pointer</i>)</td><td><a href="https://github.com/tisnik/c3-examples/blob/master/introduction/renderer_v2.c3">https://github.com/tisnik/c3-examples/blob/master/introduction/renderer_v2.c3</a></td></tr>
<tr><td> 7</td><td>renderer_v3.c3</td><td>statická kontrola, zda se nepředávají neinicializované ukazatele</td><td><a href="https://github.com/tisnik/c3-examples/blob/master/introduction/renderer_v3.c3">https://github.com/tisnik/c3-examples/blob/master/introduction/renderer_v3.c3</a></td></tr>
<tr><td> 8</td><td>renderer_v4.c3</td><td>runtime kontrola, zda se nepředávají neinicializované ukazatele</td><td><a href="https://github.com/tisnik/c3-examples/blob/master/introduction/renderer_v4.c3">https://github.com/tisnik/c3-examples/blob/master/introduction/renderer_v4.c3</a></td></tr>
<tr><td> 9</td><td>renderer_v5.c3</td><td>první (nekorektní) varianta funkce pro inicializaci barvové palety</td><td><a href="https://github.com/tisnik/c3-examples/blob/master/introduction/renderer_v5.c3">https://github.com/tisnik/c3-examples/blob/master/introduction/renderer_v5.c3</a></td></tr>
<tr><td>10</td><td>renderer_v6.c3</td><td>druhá (korektní) varianta funkce pro inicializaci barvové palety</td><td><a href="https://github.com/tisnik/c3-examples/blob/master/introduction/renderer_v6.c3">https://github.com/tisnik/c3-examples/blob/master/introduction/renderer_v6.c3</a></td></tr>
<tr><td>11</td><td>renderer_v7.c3</td><td>volání knihovní I/O funkce a volání nativní céčkovské funkce</td><td><a href="https://github.com/tisnik/c3-examples/blob/master/introduction/renderer_v7.c3">https://github.com/tisnik/c3-examples/blob/master/introduction/renderer_v7.c3</a></td></tr>
<tr><td>12</td><td>renderer_v8.c3</td><td>plně funkční program pro výpočet a vykreslení Juliovy množiny</td><td><a href="https://github.com/tisnik/c3-examples/blob/master/introduction/renderer_v8.c3">https://github.com/tisnik/c3-examples/blob/master/introduction/renderer_v8.c3</a></td></tr>
<tr><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td></tr>
<tr><td>13</td><td>01_just_main.c3</td><td>struktura nejjednoduššího programu obsahujícího pouze prázdnou funkci <strong>main</strong></td><td><a href="https://github.com/tisnik/c3-examples/blob/master/c3-basics/01_just_main.c3">https://github.com/tisnik/c3-examples/blob/master/c3-basics/01_just_main.c3</a></td></tr>
<tr><td>14</td><td>02_module_name.c3</td><td>struktura programu s&nbsp;uvedeným plným jménem modulu</td><td><a href="https://github.com/tisnik/c3-examples/blob/master/c3-basics/02_module_name.c3">https://github.com/tisnik/c3-examples/blob/master/c3-basics/02_module_name.c3</a></td></tr>
<tr><td>15</td><td>03_hello_world.c3</td><td>klasický program typu &bdquo;Hello, world!&ldquo; napsaný v&nbsp;jazyku C3</td><td><a href="https://github.com/tisnik/c3-examples/blob/master/c3-basics/03_hello_world.c3">https://github.com/tisnik/c3-examples/blob/master/c3-basics/03_hello_world.c3</a></td></tr>
<tr><td>16</td><td>04_exit_value.c3</td><td>ukončení procesu s&nbsp;předáním návratového kódu zpět volajícímu programu</td><td><a href="https://github.com/tisnik/c3-examples/blob/master/c3-basics/04_exit_value.c3">https://github.com/tisnik/c3-examples/blob/master/c3-basics/04_exit_value.c3</a></td></tr>
<tr><td>17</td><td>05_c_function.c3</td><td>zavolání funkce definované v&nbsp;knihovně programovacího jazyka C</td><td><a href="https://github.com/tisnik/c3-examples/blob/master/c3-basics/05_c_function.c3">https://github.com/tisnik/c3-examples/blob/master/c3-basics/05_c_function.c3</a></td></tr>
<tr><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td></tr>
<tr><td>18</td><td>06_bool_type.c3</td><td>definice proměnných typu <i>pravdivostní hodnota</i> (<strong>bool</strong>)</td><td><a href="https://github.com/tisnik/c3-examples/blob/master/c3-basics/06_bool_type.c3">https://github.com/tisnik/c3-examples/blob/master/c3-basics/06_bool_type.c3</a></td></tr>
<tr><td>19</td><td>07_int_to_bool.c3</td><td>implicitní převod hodnoty typu <strong>int</strong> na pravdivostní hodnotu (nekorektní řešení)</td><td><a href="https://github.com/tisnik/c3-examples/blob/master/c3-basics/07_int_to_bool.c3">https://github.com/tisnik/c3-examples/blob/master/c3-basics/07_int_to_bool.c3</a></td></tr>
<tr><td>20</td><td>08_int_to_bool.c3</td><td>explicitní převod hodnoty typu <strong>int</strong> na pravdivostní hodnotu (korektní řešení)</td><td><a href="https://github.com/tisnik/c3-examples/blob/master/c3-basics/08_int_to_bool.c3">https://github.com/tisnik/c3-examples/blob/master/c3-basics/08_int_to_bool.c3</a></td></tr>
<tr><td>21</td><td>09_int_to_bool.c3</td><td>explicitní převod hodnoty typu <strong>int</strong> na pravdivostní hodnotu (nekorektní řešení)</td><td><a href="https://github.com/tisnik/c3-examples/blob/master/c3-basics/09_int_to_bool.c3">https://github.com/tisnik/c3-examples/blob/master/c3-basics/09_int_to_bool.c3</a></td></tr>
<tr><td>22</td><td>10_bool_sizeof.c3</td><td>zjištění velikosti paměti obsazené hodnotou typu <strong>bool</strong></td><td><a href="https://github.com/tisnik/c3-examples/blob/master/c3-basics/10_bool_sizeof.c3">https://github.com/tisnik/c3-examples/blob/master/c3-basics/10_bool_sizeof.c3</a></td></tr>
<tr><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td></tr>
<tr><td>23</td><td>11_int_types.c3</td><td>definice proměnných typu <i>celé číslo se znaménkem</i> s&nbsp;různou bitovou šířkou</td><td><a href="https://github.com/tisnik/c3-examples/blob/master/c3-basics/11_int_types.c3">https://github.com/tisnik/c3-examples/blob/master/c3-basics/11_int_types.c3</a></td></tr>
<tr><td>24</td><td>12_uint_types.c3</td><td>definice proměnných typu <i>celé číslo bez znaménka</i> s&nbsp;různou bitovou šířkou</td><td><a href="https://github.com/tisnik/c3-examples/blob/master/c3-basics/12_uint_types.c3">https://github.com/tisnik/c3-examples/blob/master/c3-basics/12_uint_types.c3</a></td></tr>
<tr><td>25</td><td>13_no_suffixes.c3</td><td>celočíselné konstanty bez uvedení suffixu (bitové šířky)</td><td><a href="https://github.com/tisnik/c3-examples/blob/master/c3-basics/13_no_suffixes.c3">https://github.com/tisnik/c3-examples/blob/master/c3-basics/13_no_suffixes.c3</a></td></tr>
<tr><td>26</td><td>14_suffixes.c3</td><td>celočíselné konstanty s&nbsp;uvedením sufficu (bitové šířky)</td><td><a href="https://github.com/tisnik/c3-examples/blob/master/c3-basics/14_suffixes.c3">https://github.com/tisnik/c3-examples/blob/master/c3-basics/14_suffixes.c3</a></td></tr>
<tr><td>27</td><td>15_int_sizeof.c3</td><td>zjištění velikosti paměti obsazené celočíselnými hodnotami se znaménkem</td><td><a href="https://github.com/tisnik/c3-examples/blob/master/c3-basics/15_int_sizeof.c3">https://github.com/tisnik/c3-examples/blob/master/c3-basics/15_int_sizeof.c3</a></td></tr>
<tr><td>28</td><td>16_uint_sizeof.c3</td><td>zjištění velikosti paměti obsazené celočíselnými hodnotami bez znaménka</td><td><a href="https://github.com/tisnik/c3-examples/blob/master/c3-basics/16_uint_sizeof.c3">https://github.com/tisnik/c3-examples/blob/master/c3-basics/16_uint_sizeof.c3</a></td></tr>
<tr><td>29</td><td>17_int_conversions.c3</td><td>korektní převody mezi celočíselnými hodnotami s&nbsp;různou bitovou šířkou</td><td><a href="https://github.com/tisnik/c3-examples/blob/master/c3-basics/17_int_conversions.c3">https://github.com/tisnik/c3-examples/blob/master/c3-basics/17_int_conversions.c3</a></td></tr>
<tr><td>30</td><td>18_int_conversions.c3</td><td>nekorektní převody mezi celočíselnými hodnotami s&nbsp;různou bitovou šířkou</td><td><a href="https://github.com/tisnik/c3-examples/blob/master/c3-basics/18_int_conversions.c3">https://github.com/tisnik/c3-examples/blob/master/c3-basics/18_int_conversions.c3</a></td></tr>
<tr><td>31</td><td>19_int_conversions.c3</td><td>explicitní převody a přetečení hodnot</td><td><a href="https://github.com/tisnik/c3-examples/blob/master/c3-basics/19_int_conversions.c3">https://github.com/tisnik/c3-examples/blob/master/c3-basics/19_int_conversions.c3</a></td></tr>
<tr><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td></tr>
<tr><td>32</td><td>20_float_types.c3</td><td>definice proměnných typu <i>numerická hodnota s&nbsp;plovoucí řádovou čárkou (tečkou)</i></td><td><a href="https://github.com/tisnik/c3-examples/blob/master/c3-basics/20_float_types.c3">https://github.com/tisnik/c3-examples/blob/master/c3-basics/20_float_types.c3</a></td></tr>
<tr><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td></tr>
<tr><td>33</td><td>21_vector_type.c3</td><td>definice vektoru obsahujícího celočíselné hodnoty</td><td><a href="https://github.com/tisnik/c3-examples/blob/master/c3-basics/21_vector_type.c3">https://github.com/tisnik/c3-examples/blob/master/c3-basics/21_vector_type.c3</a></td></tr>
<tr><td>34</td><td>22_vector_operations.c3</td><td>základní operace s&nbsp;celými vektory</td><td><a href="https://github.com/tisnik/c3-examples/blob/master/c3-basics/22_vector_operations.c3">https://github.com/tisnik/c3-examples/blob/master/c3-basics/22_vector_operations.c3</a></td></tr>
<tr><td>35</td><td>23_vector_sizes.c3</td><td>zjištění a tisk velikosti vektorů (různé datové typy prvků vektorů, shodná délka)</td><td><a href="https://github.com/tisnik/c3-examples/blob/master/c3-basics/23_vector_sizes.c3">https://github.com/tisnik/c3-examples/blob/master/c3-basics/23_vector_sizes.c3</a></td></tr>
<tr><td>36</td><td>24_vector_sizes.c3</td><td>zjištění a tisk velikosti vektorů (stejné datové typy prvků vektorů, odlišná délka)</td><td><a href="https://github.com/tisnik/c3-examples/blob/master/c3-basics/24_vector_sizes.c3">https://github.com/tisnik/c3-examples/blob/master/c3-basics/24_vector_sizes.c3</a></td></tr>
</table>



<p><a name="k20"></a></p>
<h2 id="k20">20. Odkazy na Internetu</h2>

<ol>

<li>The C3 Programming Language<br />
<a href="https://c3-lang.org/">https://c3-lang.org/</a>
</li>

<li>C3 For C Programmers<br />
<a href="https://c3-lang.org/language-overview/primer/">https://c3-lang.org/language-overview/primer/</a>
</li>

<li>C3 is a C-like language trying to be an incremental improvement over C rather than a whole new language<br />
<a href="https://www.reddit.com/r/ProgrammingLanguages/comments/oohij6/c3_is_a_clike_language_trying_to_be_an/">https://www.reddit.com/r/ProgrammingLanguages/comments/oohij6/c3_is_a_clike_language_trying_to_be_an/</a>
</li>

<li>Tiobe index<br />
<a href="https://www.tiobe.com/tiobe-index/">https://www.tiobe.com/tiobe-index/</a>
</li>

<li>PYPL PopularitY of Programming Language<br />
<a href="https://pypl.github.io/PYPL.html">https://pypl.github.io/PYPL.html</a>
</li>

<li>C3 Tutorial<br />
<a href="https://learn-c3.org/">https://learn-c3.org/</a>
</li>

<li>History of programming languages<br />
<a href="https://devskiller.com/history-of-programming-languages/">https://devskiller.com/history-of-programming-languages/</a>
</li>

<li>History of programming languages (Wikipedia)<br />
<a href="https://en.wikipedia.org/wiki/History_of_programming_languages">https://en.wikipedia.org/wiki/History_of_programming_languages</a>
</li>

<li>D language<br />
<a href="https://dlang.org/">https://dlang.org/</a>
</li>

<li>Zig programming language<br />
<a href="https://ziglang.org/">https://ziglang.org/</a>
</li>

<li>V language<br />
<a href="https://vlang.io/">https://vlang.io/</a>
</li>

<li>D programming language<br />
<a href="https://en.wikipedia.org/wiki/D_(programming_language)">https://en.wikipedia.org/wiki/D_(programming_language)</a>
</li>

<li>Zig programming language (Wikipedia)<br />
<a href="https://en.wikipedia.org/wiki/Zig_(programming_language)">https://en.wikipedia.org/wiki/Zig_(programming_language)</a>
</li>

<li>V programming language (Wikipedia)<br />
<a href="https://en.wikipedia.org/wiki/V_(programming_language)">https://en.wikipedia.org/wiki/V_(programming_language)</a>
</li>

<li>Syntax highlighting for C3's programming language<br />
<a href="https://github.com/Airbus5717/c3.vim">https://github.com/Airbus5717/c3.vim</a>
</li>

<li>Go factorial<br />
<a href="https://gist.github.com/esimov/9622710">https://gist.github.com/esimov/9622710</a>
</li>

<li>Generational list of programming languages<br />
<a href="https://en.wikipedia.org/wiki/Generational_list_of_programming_languages">https://en.wikipedia.org/wiki/Generational_list_of_programming_languages</a>
</li>

<li>The Language Tree: Almost Every Programming Language Ever Made<br />
<a href="https://github.com/Phileosopher/langmap">https://github.com/Phileosopher/langmap</a>
</li>

<li>List of C-family programming languages<br />
<a href="https://en.wikipedia.org/wiki/List_of_C-family_programming_languages">https://en.wikipedia.org/wiki/List_of_C-family_programming_languages</a>
</li>

<li>Compatibility of C and C++<br />
<a href="https://en.wikipedia.org/wiki/Compatibility_of_C_and_C%2B%2B">https://en.wikipedia.org/wiki/Compatibility_of_C_and_C%2B%2B</a>
</li>

<li>C++23: compatibility with C<br />
<a href="https://www.sandordargo.com/blog/2023/08/23/cpp23-c-compatibility">https://www.sandordargo.com/blog/2023/08/23/cpp23-c-compatibility</a>
</li>

<li>Can C++ Run C Code? Understanding Language Compatibility<br />
<a href="https://www.codewithc.com/can-c-run-c-code-understanding-language-compatibility/">https://www.codewithc.com/can-c-run-c-code-understanding-language-compatibility/</a>
</li>

<li>C3: Comparisons With Other Languages<br />
<a href="https://c3-lang.org/faq/compare-languages/">https://c3-lang.org/faq/compare-languages/</a>
</li>

<li>C3 Programming Language Gains Traction as Modern C Alternative<br />
<a href="https://biggo.com/news/202504040125_C3_Programming_Language_Alternative_to_C">https://biggo.com/news/202504040125_C3_Programming_Language_Alternative_to_C</a>
</li>

<li>The case against a C alternative<br />
<a href="https://c3.handmade.network/blog/p/8486-the_case_against_a_c_alternative">https://c3.handmade.network/blog/p/8486-the_case_against_a_c_alternative</a>
</li>

<li>C (programming language) Alternatives<br />
<a href="https://alternativeto.net/software/c-programming-language-/">https://alternativeto.net/software/c-programming-language-/</a>
</li>

<li>Seriál Programovací jazyk Go<br />
<a href="https://www.root.cz/serialy/programovaci-jazyk-go/">https://www.root.cz/serialy/programovaci-jazyk-go/</a>
</li>

<li>Is C3 the Underdog That Will Overtake Zig and Odin?<br />
<a href="https://bitshifters.cc/2025/05/22/c3-c-tradition.html">https://bitshifters.cc/2025/05/22/c3-c-tradition.html</a>
</li>

<li>"Hello, World!" program<br />
<a href="https://en.wikipedia.org/wiki/%22Hello%2C_World!%22_program">https://en.wikipedia.org/wiki/%22Hello%2C_World!%22_program</a>
</li>

<li>The C Programming Language<br />
<a href="https://en.wikipedia.org/wiki/The_C_Programming_Language">https://en.wikipedia.org/wiki/The_C_Programming_Language</a>
</li>

</ol>



<p></p><p></p>
<p><small>Autor: <a href="https://github.com/tisnik/">Pavel Tišnovský</a> &nbsp; 2025</small></p>
</body>
</html>

