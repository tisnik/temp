<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
        "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html>
<head>
<title></title>
<meta name="Author" content="Pavel Tisnovsky" />
<meta name="Generator" content="vim" />
<meta http-equiv="content-type" content="text/html; charset=utf-8" />
<style type="text/css">
         body {color:#000000; background:#ffffff;}
         h1  {font-family: arial, helvetica, sans-serif; color:#ffffff; background-color:#c00000; text-align:center; padding-left:1em}
         h2  {font-family: arial, helvetica, sans-serif; color:#ffffff; background-color:#0000c0; padding-left:1em; text-align:left}
         h3  {font-family: arial, helvetica, sans-serif; color:#000000; background-color:#c0c0c0; padding-left:1em; text-align:left}
         h4  {font-family: arial, helvetica, sans-serif; color:#000000; background-color:#e0e0e0; padding-left:1em; text-align:left}
         a   {font-family: arial, helvetica, sans-serif;}
         li  {font-family: arial, helvetica, sans-serif; color:#000000; text-align:justify; width:450px;}
         ol  {font-family: arial, helvetica, sans-serif; color:#000000; text-align:justify; width:450px;}
         ul  {font-family: arial, helvetica, sans-serif; color:#000000; text-align:justify; width:450px;}
         p   {font-family: arial, helvetica, sans-serif; color:#000000; text-align:justify;}
         pre {background:#e0e0e0}
</style>
</head>

<body>

<h1></h1>

<h3>Pavel Tišnovský</h3>

<p></p>

<h1>Úvodník</h1>

<p></p>



<h2>Obsah</h2>

<p><a href="#k01">*** 1. </a></p>
<p><a href="#k02">2. Instalace balíčků vyžadovaných pro překlad C3</a></p>
<p><a href="#k03">3. Překlad C3</a></p>
<p><a href="#k04">4. První spuštění překladače</a></p>
<p><a href="#k05">5. Je jazyk C3 zpětně kompatibilní s&nbsp;jazykem C?</a></p>
<p><a href="#k06">6. Porovnání syntaxe jazyka C s&nbsp;dalšími mainstreamovými programovacími jazyky</a></p>
<p><a href="#k07">7. První reálný program vytvořený v&nbsp;jazyku C3</a></p>
<p><a href="#k08">8. Makra v&nbsp;programovacím jazyku C3</a></p>
<p><a href="#k09">9. Od C k&nbsp;C3</a></p>
<p><a href="#k10">10. Definice datové struktury s&nbsp;rozměry rastrového obrázku</a></p>
<p><a href="#k11">11. Skeleton všech funkcí</a></p>
<p><a href="#k12">12. Anotace parametrů funkcí</a></p>
<p><a href="#k13">13. Statická kontrola, zda se nepředávají neinicializované ukazatele</a></p>
<p><a href="#k14">*** 14. </a></p>
<p><a href="#k15">*** 15. </a></p>
<p><a href="#k16">*** 16. </a></p>
<p><a href="#k17">*** 17. </a></p>
<p><a href="#k18">*** 18. </a></p>
<p><a href="#k19">19. Repositář s&nbsp;demonstračními příklady</a></p>
<p><a href="#k20">20. Odkazy na Internetu</a></p>



<p><a name="k01"></a></p>
<h2 id="k01">1. </h2>

<p></p>


    No mandatory header files
    Module level namespacing
    Parametric macro system
    C ABI compatibility
    Slices for safer array handling
    Built-in UTF-8 support
    Compile time reflection
    "Throw" functions for error handling
    Pre- and post conditions
    Less undefined behavior

<p><div class="rs-tip-major">Poznámka: jazyk C3 je na poli programovacích jazyků skutečně nováčkem. Ostatně prozatím ani nebyl přidán do seznamu jazyků více či méně odvozených od jazyka C (kam bezpochyby patří). Tento seznam lze nalézt na adrese <a href="https://en.wikipedia.org/wiki/List_of_C-family_programming_languages">https://en.wikipedia.org/wiki/List_of_C-family_programming_languages</a> (najdeme zde &bdquo;staré známé&ldquo;, včetně C++, Rustu i Go).</div></p>



<p><a name="k02"></a></p>
<h2 id="k02">2. Instalace balíčků vyžadovaných pro překlad C3</h2>

<p><a href="#k03">V&nbsp;navazující kapitole</a> si popíšeme způsob překladu
všech základních nástrojů programovacího jazyka C3, protože tyto nástroje ještě
nebývají součástí distribucí Linuxu (popř.&nbsp;jsou zastaralé) a není je tedy
možné nainstalovat přímo. Ovšem pro samotný překlad a slinkování C3 je nutné,
aby byly v&nbsp;systému nainstalovány další překladače (Clang, Git, cmake) a
knihovny (LLVM-devel atd.). Ukažme si instalaci balíčků s&nbsp;těmito nástroji
v&nbsp;systémech s&nbsp;RPM/DNF:</p>

<pre>
$ <strong>sudo dnf install cmake clang git llvm llvm-devel lld lld-devel ncurses-devel</strong>
</pre>

<p>Samotný průběh instalace pochopitelně do značné míry závisí na tom, které
balíčky již byly nainstalovány (zde například cmake a git) a které nikoli:</p>

<pre>
Last metadata expiration check: 0:14:31 ago on Fri 29 Aug 2025 11:36:33 AM CEST.
Package cmake-3.30.8-1.fc41.x86_64 is already installed.
Package git-2.49.0-1.fc41.x86_64 is already installed.
Dependencies resolved.
========================================================================================================================================
 Package                            Architecture             Version                                    Repository                 Size
========================================================================================================================================
Installing:
 clang                              x86_64                   18.1.8-2.fc41                              updates                    78 k
 lld                                x86_64                   18.1.8-1.fc41                              updates                    36 k
 lld-devel                          x86_64                   18.1.8-1.fc41                              updates                    25 k
 llvm                               x86_64                   18.1.8-4.fc41                              updates                    27 M
 llvm-devel                         x86_64                   18.1.8-4.fc41                              updates                   4.1 M
 ncurses-devel                      x86_64                   6.4-12.20240127.fc41                       fedora                    562 k
Installing dependencies:
 libedit-devel                      x86_64                   3.1-54.20250104cvs.fc41                    updates                    41 k
 lld-libs                           x86_64                   18.1.8-1.fc41                              updates                   1.5 M
 llvm-googletest                    x86_64                   18.1.8-4.fc41                              updates                   382 k
 llvm-static                        x86_64                   18.1.8-4.fc41                              updates                    36 M
 llvm-test                          x86_64                   18.1.8-4.fc41                              updates                   648 k
 ncurses-c++-libs                   x86_64                   6.4-12.20240127.fc41                       fedora                     38 k
&nbsp;
Transaction Summary
========================================================================================================================================
Install  12 Packages
&nbsp;
Total download size: 71 M
Installed size: 409 M
Is this ok [y/N]: 
&nbsp;
Installed:
  clang-18.1.8-2.fc41.x86_64           libedit-devel-3.1-54.20250104cvs.fc41.x86_64      lld-18.1.8-1.fc41.x86_64
  lld-devel-18.1.8-1.fc41.x86_64       lld-libs-18.1.8-1.fc41.x86_64                     llvm-18.1.8-4.fc41.x86_64
  llvm-devel-18.1.8-4.fc41.x86_64      llvm-googletest-18.1.8-4.fc41.x86_64              llvm-static-18.1.8-4.fc41.x86_64
  llvm-test-18.1.8-4.fc41.x86_64       ncurses-c++-libs-6.4-12.20240127.fc41.x86_64      ncurses-devel-6.4-12.20240127.fc41.x86_64
&nbsp;
Complete!
</pre>

<p>Po těchto krocích doinstalujeme ještě několik dalších knihoven (ve vývojové
verzi), které mohou být využity moduly programovacího jazyka C3. Instalace
těchto balíčků sice není nezbytně nutná, ovšem jejich neexistence omezí
možnosti programů psaných v&nbsp;C3:</p>

<pre>
$ <strong>sudo dnf install libcurl-devel zlib-devel libzstd-devel libxml2-devel libffi-devel</strong>
</pre>

<p>Z&nbsp;výpisu je opět patrné, že některé z&nbsp;těchto balíčků již byly
v&nbsp;systému nainstalovány:</p>

<pre>
Last metadata expiration check: 0:15:55 ago on Fri 29 Aug 2025 11:36:33 AM CEST.
Package zlib-ng-compat-devel-2.1.7-2.fc41.x86_64 is already installed.
Package libzstd-devel-1.5.7-1.fc41.x86_64 is already installed.
Package libxml2-devel-2.12.10-1.fc41.x86_64 is already installed.
Package libffi-devel-3.4.4-7.fc41.x86_64 is already installed.
Dependencies resolved.
========================================================================================================================================
 Package                            Architecture                Version                              Repository                    Size
========================================================================================================================================
Installing:
 libcurl-devel                      x86_64                      8.6.0-10.fc41                        updates                      851 k
&nbsp;
Transaction Summary
========================================================================================================================================
Install  1 Package
&nbsp;
Total download size: 851 k
Installed size: 1.2 M
Is this ok [y/N]:
&nbsp;
Installed:
  libcurl-devel-8.6.0-10.fc41.x86_64
&nbsp;
Complete!
</pre>



<p><a name="k03"></a></p>
<h2 id="k03">3. Překlad C3</h2>

<p>Nyní, když máme v&nbsp;operačním systému nainstalovány všechny potřebné
nástroje i knihovny, můžeme provést druhý důležitý krok. Tím je překlad
překladače (sic!) i dalších nástrojů ekosystému programovacího jazyka C3.
Nejprve naklonujeme repositář se zdrojovými kódy C3, což je snadné (je
vyžadován nástroj Git, který jsme nainstalovali v&nbsp;rámci předchozí
kapitoly):</p>

<pre>
$ <strong>git clone https://github.com/c3lang/c3c.git</strong>
</pre>

<p>Výsledkem by měl být nový adresář pojmenovaný &ndash; jak jinak &ndash;
<strong>c3c</strong>:</p>

<pre>
Cloning into 'c3c'...
remote: Enumerating objects: 52579, done.
remote: Counting objects: 100% (173/173), done.
remote: Compressing objects: 100% (97/97), done.
remote: Total 52579 (delta 107), reused 81 (delta 74), pack-reused 52406 (from 3)
Receiving objects: 100% (52579/52579), 18.51 MiB | 10.34 MiB/s, done.
Resolving deltas: 100% (38876/38876), done.
</pre>

<p>Následně do tohoto adresáře přejdeme a zavoláme <strong>cmake</strong>
(další již nainstalovaný nástroj) pro konfiguraci celého procesu překladu:</p>

<pre>
$ <strong>cd c3c</strong>
&nbsp;
$ <strong>cmake -B build -S . -DC3_LINK_DYNAMIC=1</strong>
&nbsp;
-- Output to: "/tmp/ramdisk/c3c/build"
-- Configuring done (1.7s)
-- Generating done (0.0s)
-- Build files have been written to: /tmp/ramdisk/c3c/build
&nbsp;
</pre>

<p>Následuje poslední příkaz, který provede celý překlad:</p>

<pre>
$ <strong>cmake --build build</strong>
&nbsp;
[  1%] Building C object CMakeFiles/miniz.dir/dependencies/miniz/miniz.c.o
[  2%] Linking C static library libminiz.a
[  2%] Built target miniz
[  3%] Building CXX object CMakeFiles/c3c_wrappers.dir/wrapper/src/wrapper.cpp.o
[  4%] Linking CXX static library libc3c_wrappers.a
[  4%] Built target c3c_wrappers
[  5%] Generating git_hash.h
Git Hash: ca2fabc9f9cf511f1abf671b95e6f058ec512f5a
[  6%] Building C object CMakeFiles/c3c.dir/src/build/builder.c.o
...
...
...
[ 96%] Building C object CMakeFiles/c3c.dir/src/compiler/llvm_codegen_value.c.o
[ 97%] Building C object CMakeFiles/c3c.dir/src/compiler/llvm_codegen_storeload.c.o
[ 98%] Building C object CMakeFiles/c3c.dir/src/compiler/llvm_codegen_builtins.c.o
[100%] Linking CXX executable c3c
[100%] Built target c3c
</pre>

<p>Výsledek by měl být uložen do podadresáře nazvaného <strong>build</strong>,
ve kterém (kromě dalších souborů) nalezneme i spustitelný soubor nazvaný
<strong>c3c</strong>. Ten použijeme v&nbsp;dalším textu:</p>

<pre>
$ <strong>cd build</strong>
$ <strong>ls -l</strong>
total 25664
-rwxr-xr-x.  1 ptisnovs ptisnovs 14267984 Aug 29 11:55 c3c
-rw-r--r--.  1 ptisnovs ptisnovs    23222 Aug 29 11:54 CMakeCache.txt
drwxr-xr-x. 11 ptisnovs ptisnovs      380 Aug 29 11:55 CMakeFiles
-rw-r--r--.  1 ptisnovs ptisnovs     3232 Aug 29 11:54 cmake_install.cmake
-rw-r--r--.  1 ptisnovs ptisnovs       73 Aug 29 11:55 git_hash.h
drwxr-xr-x.  3 ptisnovs ptisnovs       60 Aug 29 11:54 lib
-rw-r--r--.  1 ptisnovs ptisnovs 11505170 Aug 29 11:55 libc3c_wrappers.a
-rw-r--r--.  1 ptisnovs ptisnovs   368636 Aug 29 11:54 libminiz.a
-rw-r--r--.  1 ptisnovs ptisnovs    99155 Aug 29 11:54 Makefile
</pre>

<p><div class="rs-tip-major">Poznámka: výsledný spustitelný binární soubor je
sice poměrně rozsáhlý, ovšem obsahuje jak samotný překladač, tak i další
pomocné nástroje celého ekosystému postaveného okolo jazyka C3.</div></p>



<p><a name="k04"></a></p>
<h2 id="k04">4. První spuštění překladače</h2>

<p>Po (doufejme, že úspěšném) překladu se již můžeme pokusit o spuštění
překladače programovacího jazyka C3. Pokud se stále nacházíte v&nbsp;adresáři
<strong>c3/build</strong>, postačuje spustit <strong>c3c</strong> právě
z&nbsp;tohoto adresáře. Z&nbsp;výpisu dostupných příkazů je patrné, že i přes
své jméno není <strong>c3c</strong> &bdquo;pouhým&ldquo; překladačem, ale
integruje v&nbsp;sobě i mnohé další nástroje (tím se do jisté míry podobá
nástroji <strong>go</strong> pro stejnojmenný programovací jazyk):</p>

<pre>
$ <strong>./c3c</strong>
</pre>

<p>Výpis by měl vypadat následovně:</p>

<pre>
Usage: ./c3c [&lt;options&gt;] &lt;command&gt; [&lt;args&gt;]
&nbsp;
Commands:
&nbsp;
  compile &lt;file1&gt; [&lt;file2&gt; ...]                       Compile files without a project into an executable.
  init &lt;project name&gt;                                 Initialize a new project structure.
  init-lib &lt;library name&gt;                             Initialize a new library structure.
  build [&lt;target&gt;]                                    Build the target in the current project.
  benchmark [&lt;target&gt;]                                Run the benchmarks for the target in the current project.
  test [&lt;target&gt;]                                     Run the unit tests for the target in the current project.
  clean                                               Clean all build files.
  run [&lt;target&gt;] [-- [&lt;arg1&gt; ...]]                    Run (and build if needed) the target in the current project.
  dist [&lt;target&gt;]                                     Clean and build a target for distribution.
  clean-run [&lt;target&gt;] [-- [&lt;arg1&gt; ...]]              Clean, then run the target.
  compile-run &lt;file1&gt; [&lt;file2&gt; ...] [-- [&lt;arg1&gt; ...]] Compile files then immediately run the result.
  compile-only &lt;file1&gt; [&lt;file2&gt; ...]                  Compile files but do not perform linking.
  compile-benchmark &lt;file1&gt; [&lt;file2&gt; ...]             Compile files into a test-executable and run benchmarks.
  compile-test &lt;file1&gt; [&lt;file2&gt; ...]                  Compile files into a benchmark-executable and run unit tests.
  static-lib &lt;file1&gt; [&lt;file2&gt; ...]                    Compile files without a project into a static library.
  dynamic-lib &lt;file1&gt; [&lt;file2&gt; ...]                   Compile files without a project into a dynamic library.
  vendor-fetch &lt;library&gt; ...                          Fetches one or more libraries from the vendor collection.
  project &lt;subcommand&gt; ...                            Manipulate or view project files.

Common options:
  -h -hh --help              - Print the help, -h for the normal options, -hh for the full help.
  -V --version               - Print version information.
  -q --quiet                 - Silence unnecessary output.
  -v -vv -vvv                - Verbose output, -v for default, -vv and -vvv gives more information.
  -E                         - Lex only.
  -P                         - Only parse and output the AST as JSON.
  -C                         - Only lex, parse and check.
  -                          - Read code from standard in.
  -o &lt;file&gt;                  - Write output to &lt;file&gt;.
  -O0                        - Safe, no optimizations, emit debug info.
  -O1                        - Safe, high optimization, emit debug info.
  -O2                        - Unsafe, high optimization, emit debug info.
  -O3                        - Unsafe, high optimization, single module, emit debug info.
  -O4                        - Unsafe, highest optimization, relaxed maths, single module, emit debug info, no panic messages.
  -O5                        - Unsafe, highest optimization, fast maths, single module, emit debug info, no panic messages, no backtrace.
  -Os                        - Unsafe, high optimization, small code, single module, no debug info, no panic messages.
  -Oz                        - Unsafe, high optimization, tiny code, single module, no debug info, no panic messages, no backtrace.
  -D &lt;name&gt;                  - Add feature flag &lt;name&gt;.
  -U &lt;name&gt;                  - Remove feature flag &lt;name&gt;.

  --about                    - Prints a short description of C3.
  --build-env                - Prints build environment information (only valid with in combination with a command such as 'compile').
  --run-dir &lt;dir&gt;            - Set the directory from where to run the binary (only for run and compile-run).
  --libdir &lt;dir&gt;             - Add this directory to the c3l library search paths.
  --lib &lt;name&gt;               - Add this c3l library to the compilation.
  --sources &lt;file1&gt; [&lt;file2&gt; ...] - Add these additional sources to the compilation.

  -g                         - Emit debug info.
  -g0                        - Emit no debug info.

  -l &lt;library&gt;               - Link with the static or dynamic library provided.
  -L &lt;library dir&gt;           - Append the directory to the linker search paths.
  -z &lt;argument&gt;              - Send the &lt;argument&gt; as a parameter to the linker.

Use --help or -hh to view the full list of options.
</pre>

<p><div class="rs-tip-major">Poznámka: prozatím si v&nbsp;praktické části
článku vystačíme pouze se dvěma příkazy, a to konkrétně s&nbsp;příkazem
<strong>compile</strong> a taktéž s&nbsp;příkazem <strong>compile-run</strong>.
Jejich význam by měl být zřejmý; pouze si musíme dát pozor na to, že výsledkem
překladu je přímo spustitelný soubor &ndash; nemusíme explicitně provádět fázi
linkování.</div></p>



<p><a name="k05"></a></p>
<h2 id="k05">5. Je jazyk C3 zpětně kompatibilní s&nbsp;jazykem C?</h2>

<p>Na základě jména <strong>C3</strong> i toho, že se na úvodní stránce tohoto
jazyka píše &bdquo;the C-like for programmers who like C&ldquo;, bychom mohli
nabýt dojmu, že je tento jazyk po syntaktické a sémantické stránce
s&nbsp;původním céčkem kompatibilní (například tak, jako první verze jazyka
C++). Ve skutečnosti tomu tak ovšem není (jde o <i>C-like</i> jazyk), o čemž se
můžeme snadno přesvědčit pokusem o překlad libovolného céčkovského zdrojového
kódu překladačem <strong>c3c</strong>. Konkrétně použijeme <a
href="https://github.com/tisnik/c3-examples/blob/master/introduction/renderer.c">tento
zdrojový kód</a>, na který ještě později navážeme. Pokus o překlad dopadne
takto:</p>

<pre>
1: #include &lt;stdlib.h&gt;
   ^^^^^^^^
(/tmp/ramdisk/c3c/build/renderer.c3:1:1) Error: Expected the start of a global declaration here.
&nbsp;
 2: #include &lt;string.h&gt;
 3: #include &lt;stdio.h&gt;
 4: 
 5: #define NULL_CHECK(value)                                                      \
&nbsp;                                                                                   ^
(/tmp/ramdisk/c3c/build/renderer.c3:5:80) Error: '\' may not be placed outside of a string or comment, did you perhaps forget a " somewhere?
&nbsp;
 3: #include &lt;stdio.h&gt;
 4: 
 5: #define NULL_CHECK(value)                                                      \
 6:     if (value == NULL) {                                                       \
                                                                                   ^
(/tmp/ramdisk/c3c/build/renderer.c3:6:80) Error: '\' may not be placed outside of a string or comment, did you perhaps forget a " somewhere?
&nbsp;
 4: 
 5: #define NULL_CHECK(value)                                                      \
 6:     if (value == NULL) {                                                       \
 7:         fprintf(stderr, "NULL parameter: %s\n", #value);                       \
                                                                                   ^
(/tmp/ramdisk/c3c/build/renderer.c3:7:80) Error: '\' may not be placed outside of a string or comment, did you perhaps forget a " somewhere?
&nbsp;
 5: #define NULL_CHECK(value)                                                      \
 6:     if (value == NULL) {                                                       \
 7:         fprintf(stderr, "NULL parameter: %s\n", #value);                       \
 8:         return;                                                                \
                                                                                   ^
(/tmp/ramdisk/c3c/build/renderer.c3:8:80) Error: '\' may not be placed outside of a string or comment, did you perhaps forget a " somewhere?
</pre>

<p><div class="rs-tip-major">Poznámka: konkrétní rozdíly mezi programovacími
jazyky C a C3 budou podrobněji vysvětleny v&nbsp;navazujícím článku; dnes si
spíš popisujeme první pocity z&nbsp;práce s&nbsp;C3.</div></p>



<p><a name="k06"></a></p>
<h2 id="k06">6. Porovnání syntaxe jazyka C s&nbsp;dalšími mainstreamovými programovacími jazyky</h2>

<p>Jak jsme si již řekli <a href="#k01">v&nbsp;úvodní kapitole</a>, patří
programovací jazyk C3 do rozsáhlé rodiny takzvaných &bdquo;céčkovských&ldquo;
programovacích jazyků, tj.&nbsp;jazyků více či méně inspirovaných jazykem C
(typicky ANSI C, pozdější verze C jsou již do jisté míry specifické). Asi
nejznámějším příkladem je jazyk C++, který byl dokonce ve svých prvních verzích
s&nbsp;céčkem kompatibilní. Podobnost mezi céčkovskými jazyky není pouze
sémantická, ale můžeme zde vidět i značnou syntaktickou podobnost.</p>

<p>Ostatně si můžeme ukázat, jak se liší či naopak podobají zápisy stejných
algoritmů v&nbsp;různých jazycích z&nbsp;rodiny C. Pro jednoduchost zůstaneme u
klasického &bdquo;školního&ldquo; příkladu &ndash; výpočtu faktoriálu celého
(kladného) čísla. Nerekurzivní varianta psaná v&nbsp;C vypadá takto:</p>

<pre>
int <strong>factorial</strong>(int n) {
    int result = 1;
    for (int i = 1; i &lt;= n; ++i) {
        result *= i;
    }
    return result;
}
</pre>

<p>Rekurzivní variantu lze zapsat například takto (plná rekurze):</p>

<pre>
int <strong>factorial_recursive</strong>(int n) {
    return n == 0 ? 1 : n * factorial(n - 1);
}
</pre>

<p>V&nbsp;jazyce C3 bude zápis jen nepatrně odlišný (viz klíčové slovo
<strong>fn</strong>):</p>

<pre>
fn int <strong>factorial</strong>(int n)
{
    int result = 1;
    for (int i = 1; i &lt;= n; ++i)
    {
        result *= i;
    }
    return result;
}
</pre>

<p>Rekurzivní varianta:</p>

<pre>
fn int <strong>factorial_recursive</strong>(int n)
{
    return n == 0 ? 1 : n * factorial(n - 1);
}
</pre>

<p>Dalším céčkovským jazykem je jazyk V, ve kterém bude zápis vypadat takto
(bez středníků):</p>

<pre>
fn <strong>factorial_recursive</strong>(n int) int {
  if n == 0 {
    return 1
  }
  return n * factorial_r(n - 1)
}
</pre>

<p>V&nbsp;programovacím jazyku Zig se taktéž používá klíčové slovo
<strong>fn</strong>. Změnili jsme i datové typy &ndash; nyní striktně
bezznaménkové:</p>

<pre>
fn <strong>factorial_recursive</strong>(x: u32) u32 {
    if (x == 0) {
        return 1;
    } else {
        return fact(x - 1) * x;
    }
}
</pre>

<p>Následuje zápis obou algoritmů v&nbsp;jazyce Go.</p>

<p>Rekurzivní varianta:</p>

<pre>
func <strong>factorial</strong>(n uint) uint {
        if n == 0 {
                return 1
        }
        result := 1
        for i := 1; i &lt;= n; i++ {
                result *= i
        }
        return result
}
</pre>

<p>Nerekurzivní varianta:</p>

<pre>
func <strong>factorial_recursive</strong>(n uint64)(result uint64) {
        if (n &gt; 0) {
                result = n * Factorial(n-1)
                return result
        }
        return 1
}
</pre>

<p>A konečně se podívejme na jazyk Rust, ve kterém se již rozlišují měnitelné a
neměnitelné hodnoty:</p>

<pre>
fn <strong>factorial</strong>(number : u32) -&gt; u32{
    let mut factorial : u32 = 1;
&nbsp;
    for i in 1..(number+1) {
        factorial*=i;
    }
&nbsp;
    return factorial
}
</pre>

<pre>
fn <strong>factorial_recursive</strong>(number : u32) -&gt; u32{
    if number&lt;=1 {
        return 1;
    }
&nbsp;
    return number * factorial_recursive(number-1);
}
</pre>

<p><div class="rs-tip-major">Poznámka: ve skutečnosti jsou rozdíly mezi těmito
jazyky mnohem větší, to však uvidíme až při práci s&nbsp;moduly,
strukturovanými datovými typy, pamětí atd.</div></p>



<p><a name="k07"></a></p>
<h2 id="k07">7. První reálný program vytvořený v&nbsp;jazyku C3</h2>

<p><a href="#k06">V&nbsp;předchozí kapitole</a> byly ukázány syntaktické
rozdíly mezi různými jazyky odvozenými od klasického céčka. Mj.&nbsp;jsme si
ukázali i část zdrojového kódu napsaného přímo v&nbsp;jazyku C3. Ovšem
nejednalo se o ucelený kód, takže si ho nyní rozšiřme. Pod tímto odstavcem je
uveden celý (a přeložitelný) zdrojový kód, po jehož spuštění se vypíše tabulka
faktoriálů pro vstupní hodnoty od 0 do 10 (včetně). Povšimněte si zejména
způsobu definice funkce klíčovým slovem <strong>fn</strong>, dále importu
modulu <strong>std::io</strong> (nejvíce diskutovaný rozdíl oproti C) a volání
funkce <strong>printf</strong> z&nbsp;modulu <strong>io</strong>:</p>

<pre>
import std::io;
&nbsp;
fn int <strong>factorial</strong>(int n)
{
    int result = 1;
    for (int i = 1; i &lt;= n; ++i)
    {
        result *= i;
    }
    return result;
}
&nbsp;
fn void <strong>main</strong>()
{
    for (int n = 0; n &lt;= 10; n++)
    {
        io::printf("%d! = %d\n", n, factorial(n));
    }
}
</pre>

<p>Překlad a následně spuštění programu provedené ve dvou krocích:</p>

<pre>
$ <strong>./c3c compile factorial.c3</strong>
Program linked to executable './factorial'.
&nbsp;
$ <strong>./factorial</strong>
0! = 1
1! = 1
2! = 2
3! = 6
4! = 24
5! = 120
6! = 720
7! = 5040
8! = 40320
9! = 362880
10! = 3628800
</pre>

<p>Překlad a následné spuštění programu v&nbsp;jednom kroku:</p>

<pre>
$ <strong>./c3c compile-run factorial.c3</strong>
&nbsp;
Program linked to executable './factorial'.
Launching ./factorial
0! = 1
1! = 1
2! = 2
3! = 6
4! = 24
5! = 120
6! = 720
7! = 5040
8! = 40320
9! = 362880
10! = 3628800
</pre>



<p><a name="k08"></a></p>
<h2 id="k08">8. Makra v&nbsp;programovacím jazyku C3</h2>

<p>Poměrně specifickým rysem jazyka C3 je jeho podpora pro tvorbu maker a
pochopitelně i pro jejich expanzi v&nbsp;čase překladu. Na rozdíl od (poněkud
zjednodušeně řečeno) textových substitucí prováděných preprocesorem jazyka C
jsou makra v&nbsp;C3 navržena takovým způsobem, aby jejich tvorba i volání
(resp.&nbsp;expanze) byly prováděny bezpečněji. Makra tedy mají plnohodnotné
parametry, které lze v&nbsp;textu makra použít bez nutnosti jejich
uzávorkování. Taktéž je možné specifikovat typ návratové hodnoty makra atd.
Ostatně bez dalších podrobnějších popisů (tomu bude věnován samostatný text) si
ukažme makro pro výpočet faktoriálu. To je expandováno již v&nbsp;čase
překladu:</p>

<pre>
import std::io;
&nbsp;
<u>macro</u> int <strong>factorial</strong>($n)
{
    $if $n == 0:
        return 1;
    $else
        return $n * factorial($n - 1);
    $endif
}
&nbsp;
fn void <strong>main</strong>()
{
    const int N = 10;
    io::printf("%d! = %d\n", N, factorial(N));
}
</pre>

<p>Překlad programu s&nbsp;jeho spuštěním:</p>

<pre>
$ <strong>./c3c compile-run factorial_macro.c3</strong>
&nbsp;
Program linked to executable './factorial_macro'.
Launching ./factorial_macro
10! = 3628800
Program completed with exit code 0.
</pre>

<p><div class="rs-tip-major">Poznámka: jak již bylo napsáno na začátku této
kapitoly, budeme se makry podrobněji zabývat v&nbsp;dalším článku, protože se
jedná o dosti rozsáhlé téma.</div></p>



<p><a name="k09"></a></p>
<h2 id="k09">9. Od C k&nbsp;C3</h2>

<p>Dnes nebudeme podrobně popisovat ani syntaxi ani sémantiku jazyka C3.
Zvolíme spíše prakticky zaměřený přístup. Konkrétně se pokusíme o transformaci
následujícího zdrojového kódu napsaného v&nbsp;ANSI C do jazyka C3. Tento kód
po svém spuštění vygeneruje rastrový obrázek s&nbsp;vypočtenou Juliovou
množinou:</p>

*** image ***

<p>Povšimněte si, že se ve zdrojovém kódu používají struktury, ukazatele na
struktury, základní příkazy pro řízení toku programu (podmínky a smyčky),
ukazatele, makra, dynamická alokace paměti a v&nbsp;neposlední řadě taktéž
standardní knihovní funkce pro tisk na standardní výstup:</p>

<pre>
#include &lt;stdlib.h&gt;
#include &lt;string.h&gt;
#include &lt;stdio.h&gt;
&nbsp;
#define NULL_CHECK(value)                                                      \
    if (value == NULL) {                                                       \
        fprintf(stderr, "NULL parameter: %s\n", #value);                       \
        return;                                                                \
    }
&nbsp;
typedef struct {
    unsigned int width;
    unsigned int height;
} <strong>resolution_t</strong>;
&nbsp;
void <strong>calc_julia</strong>(resolution_t *resolution, const unsigned int maxiter, const unsigned char *palette, double cx, double cy)
{
    double zy0 = -1.5;
    int y;
&nbsp;
    NULL_CHECK(palette);
&nbsp;
    puts("P3");
    printf("%d %d\n", resolution&gt;-width, resolution&gt;-height);
    puts("255");
&nbsp;
    for (y=0; y &lt; resolution&gt;-height; y++) {
        double zx0 = -1.5;
        int x;
        for (x=0; x &lt; resolution&gt;-width; x++) {
            double zx = zx0;
            double zy = zy0;
            unsigned int i = 0;
            while (i &lt; maxiter) {
                double zx2 = zx * zx;
                double zy2 = zy * zy;
                if (zx2 + zy2 &gt; 4.0) {
                    break;
                }
                zy = 2.0 * zx * zy + cy;
                zx = zx2 - zy2 + cx;
                i++;
            }
            {
                const unsigned char *color = palette + 3*(i % 256);
                unsigned char r = *color++;
                unsigned char g = *color++;
                unsigned char b = *color;
                printf("%d %d %d\n", r, g, b);
            }
            zx0 += 3.0/resolution&gt;-width;
        }
        zy0 += 3.0/resolution&gt;-height;
    }
}
&nbsp;
<i>/* Generate color palette: 256 colors, each color is represented as RGB triple. */</i>
unsigned char *<strong>generate_palette</strong>(void) {
    unsigned char *palette = (unsigned char *)malloc(256 * 3);
    unsigned char *p = palette;
    int i;
&nbsp;
    if (palette == NULL) {
        return NULL;
    }
&nbsp;
    <i>/* fill in by black color */</i>
    memset(palette, 0, 256 * 3);
&nbsp;
    <i>/* green gradient */</i>
    for (i = 0; i &lt; 32; i++) {
        *p++ = 0;
        *p++ = 4 + i*6;
        *p++ = 0;
    }
&nbsp;
    <i>/* gradient from green to yellow */</i>
    for (i = 0; i &lt; 32; i++) {
        *p++ = 4 + i * 6;
        *p++ = i * 2 &lt; 52 ? 200 + i * 2 : 252;
        *p++ = 0;
    }
&nbsp;
    <i>/* gradient from yellow to white */</i>
    for (i = 0; i &lt; 32; i++) {
        *p++ = i * 2 &lt; 52 ? 200 + i * 2 : 252;
        *p++ = 252;
        *p++ = i * 6;
    }
&nbsp;
    <i>/* gradient from white to yellow */</i>
    for (i = 0; i &lt; 48; i++) {
        *p++ = 252;
        *p++ = 252;
        *p++ = 252 - i * 6;
    }
&nbsp;
    <i>/* gradient from yellow to green */</i>
    for (i = 0; i &lt; 48; i++) {
        *p++ = 252 - i * 6;
        *p++ = 252;
        *p++ = 0;
    }
&nbsp;
    <i>/* gradient green to black */</i>
    for (i = 0; i &lt; 48; i++) {
        *p++ = 0;
        *p++ = 252 - i * 6;
        *p++ = 0;
    }
&nbsp;
    return palette;
}
&nbsp;
int <strong>main</strong>(int argc, char **argv)
{
    resolution_t resolution;
    unsigned char *palette = generate_palette();
    int maxiter;
&nbsp;
    if (argc &lt; 4) {
        puts("usage: ./mandelbrot width height maxiter");
        return 1;
    }
    resolution.width = atoi(argv[1]);
    resolution.height = atoi(argv[2]);
    maxiter = atoi(argv[3]);
    calc_julia(&amp;resolution, maxiter, palette, -0.207190825, 0.676656625);
    return 0;
}
</pre>



<p><a name="k10"></a></p>
<h2 id="k10">10. Definice datové struktury s&nbsp;rozměry rastrového obrázku</h2>

<p>Nejprve se podíváme na to, jakým způsobem se v&nbsp;jazyce C3 definuje
datová struktura s&nbsp;popisem rastrového obrázku. V&nbsp;céčku je definice
takové struktury následující:</p>

<pre>
typedef struct {
    unsigned int width;
    unsigned int height;
} <strong>resolution_t</strong>;
</pre>

<p>V&nbsp;jazyce C3 je sémantika prakticky stejná, liší se jen způsob zápisu
(tedy syntaxe). Odlišují se i jména datových typů &ndash; namísto modifikátorů
typu <strong>int</strong> (viz C) přímo použijeme datový typ
<strong>uint</strong>:</p>

<pre>
struct <strong>Resolution</strong> {
    uint width;
    uint height;
}
</pre>

<p><div class="rs-tip-major">Poznámka: jazyk C3 striktně hlídá název struktury,
tj.&nbsp;uživatelského datového typu. Musí začínat velkým písmenem, jinak je
nahlášena chyba:</div></p>

<pre>
 6: struct resolution {
           ^^^^^^^^^^
(/tmp/ramdisk/c3c/build/renderer_v8.c1:6:8) Error: Names of structs must start with an uppercase letter.
</pre>



<p><a name="k11"></a></p>
<h2 id="k11">11. Skeleton všech funkcí</h2>

<p>Dále do první verze našeho programu dopíšeme skeleton všech tří funkcí,
které později budeme implementovat. Povšimněte si, že parametry lze předávat
jak hodnotou (<strong>maxiter</strong>, <strong>cx</strong>,
<strong>cy</strong>), tak i odkazem (<strong>resolution</strong>,
<strong>palette</strong>), tedy stejně, jako je tomu v&nbsp;jazyku C. A opět
&ndash; odlišuje se jen syntaxe, která nyní vyžaduje použití klíčového slova
<strong>fn</strong> na začátku hlaviček funkcí:</p>

<pre>
fn void <strong>calc_julia</strong>(Resolution *resolution, uint maxiter, char *palette, double cx, double cy) {
}
&nbsp;
fn char *<strong>generate_palette</strong>() {
}
&nbsp;
fn void <strong>main</strong>()
{
}
</pre>

<p>Ve skutečnosti by takový program nebylo možné přeložit, protože funkce
<strong>generate_palette</strong> musí vracet nějakou hodnotu (klidně i
<strong>null</strong>):</p>

<pre>
fn char *<strong>generate_palette</strong>() {
    char *palette = null;
    return palette;
}
</pre>

<p>První verze programu pro výpočet Juliovy množiny vypadá následovně:</p>

<pre>
struct <strong>Resolution</strong> {
    uint width;
    uint height;
}
&nbsp;
fn void <strong>calc_julia</strong>(Resolution *resolution, uint maxiter, char *palette, double cx, double cy)
{
}
&nbsp;
fn char *<strong>generate_palette</strong>() {
    char *palette = null;
    return palette;
}
&nbsp;
fn void <strong>main</strong>()
{
    calc_julia(null, 0, null, 0.0, 0.0);
}
</pre>

<p><div class="rs-tip-major">Poznámka: tento program lze přeložit i spustit,
ovšem pochopitelně (alespoň prozatím) nic nevykreslí.</div></p>



<p><a name="k12"></a></p>
<h2 id="k12">12. Anotace parametrů funkcí</h2>

<p>V&nbsp;programovacím jazyku C je možné specifikovat, že některé parametry
funkce nebudou uvnitř funkce modifikovány. K&nbsp;tomuto účelu se používá
klíčové slovo <strong>const</strong> (u ukazatelů si musíme dát pozor na to,
jestli je neměnný ukazatel nebo hodnota, na kterou ukazuje):</p>

<pre>
void <strong>calc_julia</strong>(resolution_t *resolution, const unsigned int maxiter, const unsigned char *palette, double cx, double cy)
</pre>

<p>V&nbsp;jazyku C3 se používá poněkud odlišný přístup. U parametrů typu
ukazatel lze s&nbsp;využitím anotací specifikovat, jestli se může (přes předaný
ukazatel) provádět zápis, nebo je paměťová oblast určena jen pro čtení (či pro
obě operace). Vzhledem k&nbsp;tomu, že ve funkci <strong>calc_julia</strong> se
přes oba ukazatele přistupuje ke struktuře resp.&nbsp;k&nbsp;poli, ze kterého
se pouze provádí čtení, můžeme u obou těchto ukazatelů specifikovat příslušnou
anotaci. Zápis je na první pohled poněkud zvláštní:</p>

<pre>
&lt;*
 @param [in] resolution
 @param [in] palette
*&gt;
fn void <strong>calc_julia</strong>(Resolution *resolution, uint maxiter, char *palette, double cx, double cy)
{
}
</pre>

<p>V&nbsp;případě, že se přes ukazatel pokusíme o zápis, povede to k&nbsp;chybě
při překladu:</p>

<pre>
&lt;*
 @param [in] resolution
 @param [in] palette
*&gt;
fn void <strong>calc_julia</strong>(Resolution *resolution, uint maxiter, char *palette, double cx, double cy)
{
    resolution.width=100;
}
</pre>

<p>Překladač nahlásí chybu:</p>

<pre>
11: *&gt;
12: fn void calc_julia(Resolution *resolution, uint maxiter, char *palette, double cx, double cy)
13: {
14:     resolution.width=100;
        ^^^^^^^^^^
(/tmp/ramdisk/c3c/build/renderer_v2.c3:14:5) Error: 'in' parameters may not be assigned to.
</pre>

<p><div class="rs-tip-major">Poznámka: poněkud předběhneme, ale zápis
<strong>resolution.width</strong> je skutečně syntakticky korektní &ndash;
nemusíme (a ani nemůžeme) použít operátor -&gt;</div></p>

<p>Druhá varianta demonstračního příkladu bude vypadat takto:</p>

<pre>
struct <strong>Resolution</strong> {
    uint width;
    uint height;
}
&nbsp;
&lt;*
 @param [in] resolution
 @param [in] palette
*&gt;
fn void <strong>calc_julia</strong>(Resolution *resolution, uint maxiter, char *palette, double cx, double cy)
{
}
&nbsp;
fn char *<strong>generate_palette</strong>() {
    char *palette = null;
    return palette;
}
&nbsp;
fn void <strong>main</strong>()
{
    calc_julia(null, 0, null, 0.0, 0.0);
}
</pre>



<p><a name="k13"></a></p>
<h2 id="k13">13. Statická kontrola, zda se nepředávají neinicializované ukazatele</h2>

<p>Překladač jazyka C3 dokáže provádět (i když prozatím dosti primitivním
způsobem) statickou kontrolu, zda se do funkce nepředává neinicializovaný
ukazatel. Prozatím umíme specifikovat, že se přes ukazatel nesmí provádět
zápisy:</p>

<pre>
&lt;*
 @param [in] resolution
 @param [in] palette
*&gt;
fn void <strong>calc_julia</strong>(Resolution *resolution, uint maxiter, char *palette, double cx, double cy)
{
}
</pre>

<p>Pokud navíc v&nbsp;anotaci před slovo <strong>in</strong> vložíme znak
ampersandu, znamená to, že ukazatel musí být inicializovaný a nesmí obsahovat
hodnotu <strong>null</strong>:</p>

<pre>
&lt;*
 @param [&amp;in] resolution
 @param [&amp;in] palette
*&gt;
fn void <strong>calc_julia</strong>(Resolution *resolution, uint maxiter, char *palette, double cx, double cy)
{
}
</pre>

<p><div class="rs-tip-major">Poznámka: použití znaku ampersandu je možná
poněkud matoucí, ale na druhou stranu se jedná o céčkovský jazyk, který je plný
různých operátorů a paznaků.</div></p>

<p>Podívejme se nyní na upravený zdrojový kód ukázkového příkladu, v&nbsp;němž
je použita upravená anotace ukazatelů předávaných do funkce
<strong>calc_julia</strong>:</p>

<pre>
struct <strong>Resolution</strong> {
    uint width;
    uint height;
}
&nbsp;
&lt;*
 @param [&amp;in] resolution
 @param [&amp;in] palette
*&gt;
fn void <strong>calc_julia</strong>(Resolution *resolution, uint maxiter, char *palette, double cx, double cy)
{
}
&nbsp;
fn char *<strong>generate_palette</strong>() {
    char *palette = null;
    return palette;
}
&nbsp;
fn void <strong>main</strong>()
{
    calc_julia(null, 0, null, 0.0, 0.0);
}
</pre>

<p>Při pokusu o překlad vypíše překladač programovacího jazyka C3 chybu,
protože při volání funkce <strong>calc_julia</strong> do ní skutečně předáváme
hodnotu <strong>null</strong>:</p>

<pre>
$ <strong>./c3c compile renderer_v3.c3</strong>
&nbsp;
20:
21: fn void main()
22: {
23:     calc_julia(null, 0, null, 0.0, 0.0);
                   ^^^^
(/tmp/ramdisk/c3c/build/renderer_v3.c3:23:16) Error: You may not pass null to the '&amp;' parameter.
&nbsp;
 9:  @param [&amp;in] resolution
10:  @param [&amp;in] palette
11: *&gt;
12: fn void calc_julia(Resolution *resolution, uint maxiter, char *palette, double cx, double cy)
            ^^^^^^^^^^
(/tmp/ramdisk/c3c/build/renderer_v3.c3:12:9) Note: The definition is here.
</pre>



<p><a name="k14"></a></p>
<h2 id="k14">14. </h2>

<p></p>

<pre>
import std::io;

struct Resolution {
    uint width;
    uint height;
}

<*
 @param [&in] resolution
 @param [&in] palette
*>
fn void calc_julia(Resolution *resolution, uint maxiter, char *palette, double cx, double cy)
{
}

fn char *generate_palette() {
    char *palette = null;
    return palette;
}

fn void main()
{
    Resolution resolution;
    resolution.width = 512;
    resolution.height = 512;

    char* palette = generate_palette();

    calc_julia(&resolution, 0, palette, 0.0, 0.0);
}
</pre>

<pre>
$ <strong>./c3c compile renderer_v4.c3</strong>
&nbsp;
Program linked to executable './renderer_v4'.
</pre>

<pre>
$ <strong>./renderer_v4</strong>
&nbsp;
ERROR: 'Reference parameter 'palette' was passed a null pointer argument.'
  in std.core.builtin.default_panic (/tmp/ramdisk/c3c/lib/std/core/builtin.c3:175) [./renderer_v4]
  in renderer_v4.calc_julia (/tmp/ramdisk/c3c/build/renderer_v4.c3:12) [./renderer_v4]
  in renderer_v4.main (/tmp/ramdisk/c3c/build/renderer_v4.c3:29) [./renderer_v4]
  in @main_to_void_main (/tmp/ramdisk/c3c/lib/std/core/private/main_stub.c3:18) [./renderer_v4] [inline]
  in main (/tmp/ramdisk/c3c/build/renderer_v4.c3:21) [./renderer_v4]
  in __libc_start_call_main (source unavailable) [/lib64/libc.so.6]
  in __libc_start_main_alias_2 (source unavailable) [/lib64/libc.so.6]
  in _start (source unavailable) [./renderer_v4]
Illegal instruction (core dumped)
</pre>



<p><a name="k14"></a></p>
<h2 id="k14">14. </h2>

<p></p>

<pre>
import std::io;
import libc;

struct Resolution {
    uint width;
    uint height;
}

<*
 @param [&in] resolution
 @param [&in] palette
*>
fn void calc_julia(Resolution *resolution, uint maxiter, char *palette, double cx, double cy)
{
}

fn char *generate_palette() {
    char *palette = malloc(256*3);
    char *p = palette;

    <i>/* fill in by black color */</i>
    libc::memset(palette, 0, 256 * 3);

    <i>/* green gradient */</i>
    for (int i = 0; i &lt; 32; i++) {
        *p++ = 0;
        *p++ = 4 + i*6;
        *p++ = 0;
    }

    <i>/* gradient from green to yellow */</i>
    for (int i = 0; i &lt; 32; i++) {
        *p++ = 4 + i * 6;
        *p++ = i * 2 &lt; 52 ? 200 + i * 2 : 252;
        *p++ = 0;
    }

    <i>/* gradient from yellow to white */</i>
    for (int i = 0; i &lt; 32; i++) {
        *p++ = i * 2 &lt; 52 ? 200 + i * 2 : 252;
        *p++ = 252;
        *p++ = i * 6;
    }

    <i>/* gradient from white to yellow */</i>
    for (int i = 0; i &lt; 48; i++) {
        *p++ = 252;
        *p++ = 252;
        *p++ = 252 - i * 6;
    }
    
    <i>/* gradient from yellow to green */</i>
    for (int i = 0; i &lt; 48; i++) {
        *p++ = 252 - i * 6;
        *p++ = 252;
        *p++ = 0;
    }
    
    <i>/* gradient green to black */</i>
    for (int i = 0; i &lt; 48; i++) {
        *p++ = 0;
        *p++ = 252 - i * 6;
        *p++ = 0;
    }

    return palette;
}

fn void main()
{
    Resolution resolution;
    resolution.width = 512;
    resolution.height = 512;

    char* palette = generate_palette();

    calc_julia(&resolution, 0, palette, 0.0, 0.0);
}
</pre>

<pre>
24:     /* green gradient */
25:     for (int i = 0; i < 32; i++) {
26:         *p++ = 0;
27:         *p++ = 4 + i*6;
                       ^
(/tmp/ramdisk/c3c/build/renderer_v5.c3:27:20) Error: 'int' cannot implicitly be converted to 'char', but you may use a cast.

 30: 
 31:     /* gradient from green to yellow */
 32:     for (int i = 0; i < 32; i++) {
 33:         *p++ = 4 + i * 6;
                        ^
(/tmp/ramdisk/c3c/build/renderer_v5.c3:33:20) Error: 'int' cannot implicitly be converted to 'char', but you may use a cast.

 31:     /* gradient from green to yellow */
 32:     for (int i = 0; i < 32; i++) {
 33:         *p++ = 4 + i * 6;
 34:         *p++ = i * 2 < 52 ? 200 + i * 2 : 252;
                                       ^
(/tmp/ramdisk/c3c/build/renderer_v5.c3:34:35) Error: 'int' cannot implicitly be converted to 'char', but you may use a cast.

 37: 
 38:     /* gradient from yellow to white */
 39:     for (int i = 0; i < 32; i++) {
 40:         *p++ = i * 2 < 52 ? 200 + i * 2 : 252;
                                       ^
(/tmp/ramdisk/c3c/build/renderer_v5.c3:40:35) Error: 'int' cannot implicitly be converted to 'char', but you may use a cast.

 39:     for (int i = 0; i < 32; i++) {
 40:         *p++ = i * 2 < 52 ? 200 + i * 2 : 252;
 41:         *p++ = 252;
 42:         *p++ = i * 6;
                    ^
(/tmp/ramdisk/c3c/build/renderer_v5.c3:42:16) Error: 'int' cannot implicitly be converted to 'char', but you may use a cast.

 46:     for (int i = 0; i < 48; i++) {
 47:         *p++ = 252;
 48:         *p++ = 252;
 49:         *p++ = 252 - i * 6;
                          ^
</pre>



<p><a name="k15"></a></p>
<h2 id="k15">15. </h2>

<p></p>

<pre>
import std::io;
import libc;

struct Resolution {
    uint width;
    uint height;
}

<*
 @param [&in] resolution
 @param [&in] palette
*>
fn void calc_julia(Resolution *resolution, uint maxiter, char *palette, double cx, double cy)
{
}

fn char *generate_palette() {
    char *palette = malloc(256*3);
    char *p = palette;

    <i>/* fill in by black color */</i>
    libc::memset(palette, 0, 256 * 3);

    <i>/* green gradient */</i>
    for (char i = 0; i &lt; 32; i++) {
        *p++ = 0;
        *p++ = 4 + i*6;
        *p++ = 0;
    }

    <i>/* gradient from green to yellow */</i>
    for (char i = 0; i &lt; 32; i++) {
        *p++ = 4 + i * 6;
        *p++ = i * 2 &lt; 52 ? 200 + i * 2 : 252;
        *p++ = 0;
    }

    <i>/* gradient from yellow to white */</i>
    for (char i = 0; i &lt; 32; i++) {
        *p++ = i * 2 &lt; 52 ? 200 + i * 2 : 252;
        *p++ = 252;
        *p++ = i * 6;
    }

    <i>/* gradient from white to yellow */</i>
    for (char i = 0; i &lt; 48; i++) {
        *p++ = 252;
        *p++ = 252;
        *p++ = 252 - i * 6;
    }
    
    <i>/* gradient from yellow to green */</i>
    for (char i = 0; i &lt; 48; i++) {
        *p++ = 252 - i * 6;
        *p++ = 252;
        *p++ = 0;
    }
    
    <i>/* gradient green to black */</i>
    for (char i = 0; i &lt; 48; i++) {
        *p++ = 0;
        *p++ = 252 - i * 6;
        *p++ = 0;
    }

    return palette;
}

fn void main()
{
    Resolution resolution;
    resolution.width = 512;
    resolution.height = 512;

    char* palette = generate_palette();

    calc_julia(&resolution, 0, palette, 0.0, 0.0);
}
</pre>



<p><a name="k16"></a></p>
<h2 id="k16">16. </h2>

<p></p>

<pre>
import std::io;
import libc;

extern fn int puts(char*);

struct Resolution {
    uint width;
    uint height;
}

<*
 @param [&in] resolution
 @param [&in] palette
*>
fn void calc_julia(Resolution *resolution, uint maxiter, char *palette, double cx, double cy)
{
    puts("P3");
    io::printf("%d %d\n", resolution.width, resolution.height);
    puts("255");
}

fn char *generate_palette() {
    char *palette = malloc(256*3);
    char *p = palette;

    <i>/* fill in by black color */</i>
    libc::memset(palette, 0, 256 * 3);

    <i>/* green gradient */</i>
    for (char i = 0; i &lt; 32; i++) {
        *p++ = 0;
        *p++ = 4 + i*6;
        *p++ = 0;
    }

    <i>/* gradient from green to yellow */</i>
    for (char i = 0; i &lt; 32; i++) {
        *p++ = 4 + i * 6;
        *p++ = i * 2 &lt; 52 ? 200 + i * 2 : 252;
        *p++ = 0;
    }

    <i>/* gradient from yellow to white */</i>
    for (char i = 0; i &lt; 32; i++) {
        *p++ = i * 2 &lt; 52 ? 200 + i * 2 : 252;
        *p++ = 252;
        *p++ = i * 6;
    }

    <i>/* gradient from white to yellow */</i>
    for (char i = 0; i &lt; 48; i++) {
        *p++ = 252;
        *p++ = 252;
        *p++ = 252 - i * 6;
    }
    
    <i>/* gradient from yellow to green */</i>
    for (char i = 0; i &lt; 48; i++) {
        *p++ = 252 - i * 6;
        *p++ = 252;
        *p++ = 0;
    }
    
    <i>/* gradient green to black */</i>
    for (char i = 0; i &lt; 48; i++) {
        *p++ = 0;
        *p++ = 252 - i * 6;
        *p++ = 0;
    }

    return palette;
}

fn void main()
{
    Resolution resolution;
    resolution.width = 512;
    resolution.height = 512;

    char* palette = generate_palette();

    calc_julia(&resolution, 0, palette, 0.0, 0.0);
}
</pre>



<p><a name="k17"></a></p>
<h2 id="k17">17. </h2>

<p></p>

<pre>
import std::io;
import libc;

extern fn int puts(char*);

struct Resolution {
    uint width;
    uint height;
}

<*
 @param [&in] resolution
 @param [&in] palette
*>
fn void calc_julia(Resolution *resolution, uint maxiter, char *palette, double cx, double cy)
{
    puts("P3");
    io::printf("%d %d\n", resolution.width, resolution.height);
    puts("255");

    double zy0 = -1.5;
    int y;

    for (y=0; y &lt; resolution.height; y++) {
        double zx0 = -1.5;
        int x;
        for (x=0; x &lt; resolution.width; x++) {
            double zx = zx0;
            double zy = zy0;
            uint i = 0;
            while (i &lt; maxiter) {
                double zx2 = zx * zx;
                double zy2 = zy * zy;
                if (zx2 + zy2 &gt; 4.0) {
                    break;
                }
                zy = 2.0 * zx * zy + cy;
                zx = zx2 - zy2 + cx;
                i++;
            }
            char *color = palette + 3*(i % 256);
            char r = *color++;
            char g = *color++;
            char b = *color;
            io::printf("%d %d %d\n", r, g, b);
            zx0 += 3.0/resolution.width;
        }
        zy0 += 3.0/resolution.height;
    }
}

fn char *generate_palette() {
    char *palette = malloc(256*3);
    char *p = palette;

    <i>/* fill in by black color */</i>
    libc::memset(palette, 0, 256 * 3);

    <i>/* green gradient */</i>
    for (char i = 0; i &lt; 32; i++) {
        *p++ = 0;
        *p++ = 4 + i*6;
        *p++ = 0;
    }

    <i>/* gradient from green to yellow */</i>
    for (char i = 0; i &lt; 32; i++) {
        *p++ = 4 + i * 6;
        *p++ = i * 2 &lt; 52 ? 200 + i * 2 : 252;
        *p++ = 0;
    }

    <i>/* gradient from yellow to white */</i>
    for (char i = 0; i &lt; 32; i++) {
        *p++ = i * 2 &lt; 52 ? 200 + i * 2 : 252;
        *p++ = 252;
        *p++ = i * 6;
    }

    <i>/* gradient from white to yellow */</i>
    for (char i = 0; i &lt; 48; i++) {
        *p++ = 252;
        *p++ = 252;
        *p++ = 252 - i * 6;
    }
    
    <i>/* gradient from yellow to green */</i>
    for (char i = 0; i &lt; 48; i++) {
        *p++ = 252 - i * 6;
        *p++ = 252;
        *p++ = 0;
    }
    
    <i>/* gradient green to black */</i>
    for (char i = 0; i &lt; 48; i++) {
        *p++ = 0;
        *p++ = 252 - i * 6;
        *p++ = 0;
    }

    return palette;
}

fn void main()
{
    Resolution resolution;
    resolution.width = 512;
    resolution.height = 512;

    char* palette = generate_palette();

    calc_julia(&resolution, 1000, palette, -0.207190825, 0.676656625);
}
</pre>



<p><a name="k18"></a></p>
<h2 id="k18">18. </h2>

<p></p>



<p><a name="k19"></a></p>
<h2 id="k19">19. Repositář s&nbsp;demonstračními příklady</h2>

<p>Dnes ukázané demonstrační příklady byly uloženy do repositáře dostupného na
adrese <a
href="https://github.com/tisnik/c3-examples">https://github.com/tisnik/c3-examples</a>.
Následují odkazy na jednotlivé příklady (či jejich nedokončené části):</p>

<table>
<tr><th> #</th><th>Příklad</th><th>Stručný popis</th><th>Adresa</th></tr>
<tr><td> 1</td><td>factorial.c3</td><td>realizace výpočtu faktoriálu</td><td><a href="https://github.com/tisnik/c3-examples/blob/master/factorial.c3">https://github.com/tisnik/c3-examples/blob/master/factorial.c3</a></td></tr>
<tr><td> 2</td><td>factorial_macro.c3</td><td>výpočet faktoriálu konkrétní hodnoty implementovaný formou makra</td><td><a href="https://github.com/tisnik/c3-examples/blob/master/factorial_macro.c3">https://github.com/tisnik/c3-examples/blob/master/factorial_macro.c3</a></td></tr>
<tr><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td></tr>
<tr><td> 3</td><td>swap_macro.c3</td><td>makro realizující prohození dvou hodnot</td><td><a href="https://github.com/tisnik/c3-examples/blob/master/swap_macro.c3">https://github.com/tisnik/c3-examples/blob/master/swap_macro.c3</a></td></tr>
<tr><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td></tr>
<tr><td> 4</td><td>renderer.c</td><td>výpočet a vykreslení Juliovy množiny implementovaný v&nbsp;jazyku C</td><td><a href="https://github.com/tisnik/c3-examples/blob/master/renderer.c">https://github.com/tisnik/c3-examples/blob/master/renderer.c</a></td></tr>
<tr><td> 5</td><td>renderer_v1.c3</td><td>definice datové struktury s&nbsp;rozměry rastrového obrázku a skeleton všech funkcí</td><td><a href="https://github.com/tisnik/c3-examples/blob/master/renderer_v1.c3">https://github.com/tisnik/c3-examples/blob/master/renderer_v1.c3</a></td></tr>
<tr><td> 6</td><td>renderer_v2.c3</td><td>anotace parametrů funkcí typu ukazatel (<i>pointer</i>)</td><td><a href="https://github.com/tisnik/c3-examples/blob/master/renderer_v2.c3">https://github.com/tisnik/c3-examples/blob/master/renderer_v2.c3</a></td></tr>
<tr><td> 7</td><td>renderer_v3.c3</td><td>statická kontrola, zda se nepředávají neinicializované ukazatele</td><td><a href="https://github.com/tisnik/c3-examples/blob/master/renderer_v3.c3">https://github.com/tisnik/c3-examples/blob/master/renderer_v3.c3</a></td></tr>
<tr><td> 8</td><td>renderer_v4.c3</td><td>runtime kontrola, zda se nepředávají neinicializované ukazatele</td><td><a href="https://github.com/tisnik/c3-examples/blob/master/renderer_v4.c3">https://github.com/tisnik/c3-examples/blob/master/renderer_v4.c3</a></td></tr>
<tr><td> 9</td><td>renderer_v5.c3</td><td>první (nekorektní) varianta funkce pro inicializaci barvové palety</td><td><a href="https://github.com/tisnik/c3-examples/blob/master/renderer_v5.c3">https://github.com/tisnik/c3-examples/blob/master/renderer_v5.c3</a></td></tr>
<tr><td>10</td><td>renderer_v6.c3</td><td>druhá (korektní) varianta funkce pro inicializaci barvové palety</td><td><a href="https://github.com/tisnik/c3-examples/blob/master/renderer_v6.c3">https://github.com/tisnik/c3-examples/blob/master/renderer_v6.c3</a></td></tr>
<tr><td>11</td><td>renderer_v7.c3</td><td>volání knihovní I/O funkce a volání nativní céčkovské funkce</td><td><a href="https://github.com/tisnik/c3-examples/blob/master/renderer_v7.c3">https://github.com/tisnik/c3-examples/blob/master/renderer_v7.c3</a></td></tr>
<tr><td>12</td><td>renderer_v8.c3</td><td>plně funkční program pro výpočet a vykreslení Juliovy množiny</td><td><a href="https://github.com/tisnik/c3-examples/blob/master/renderer_v8.c3">https://github.com/tisnik/c3-examples/blob/master/renderer_v8.c3</a></td></tr>
</table>



<p><a name="k20"></a></p>
<h2 id="k20">20. Odkazy na Internetu</h2>

<ol>

<li>The C3 Programming Language<br />
<a href="https://c3-lang.org/">https://c3-lang.org/</a>
</li>

<li>C3 For C Programmers<br />
<a href="https://c3-lang.org/language-overview/primer/">https://c3-lang.org/language-overview/primer/</a>
</li>

<li>C3 is a C-like language trying to be an incremental improvement over C rather than a whole new language<br />
<a href="https://www.reddit.com/r/ProgrammingLanguages/comments/oohij6/c3_is_a_clike_language_trying_to_be_an/">https://www.reddit.com/r/ProgrammingLanguages/comments/oohij6/c3_is_a_clike_language_trying_to_be_an/</a>
</li>

<li>Tiobe index<br />
<a href="https://www.tiobe.com/tiobe-index/">https://www.tiobe.com/tiobe-index/</a>
</li>

<li>PYPL PopularitY of Programming Language<br />
<a href="https://pypl.github.io/PYPL.html">https://pypl.github.io/PYPL.html</a>
</li>

<li>C3 Tutorial<br />
<a href="https://learn-c3.org/">https://learn-c3.org/</a>
</li>

<li>History of programming languages<br />
<a href="https://devskiller.com/history-of-programming-languages/">https://devskiller.com/history-of-programming-languages/</a>
</li>

<li>History of programming languages (Wikipedia)<br />
<a href="https://en.wikipedia.org/wiki/History_of_programming_languages">https://en.wikipedia.org/wiki/History_of_programming_languages</a>
</li>

<li>D language<br />
<a href="https://dlang.org/">https://dlang.org/</a>
</li>

<li>Zig programming language<br />
<a href="https://ziglang.org/">https://ziglang.org/</a>
</li>

<li>V language<br />
<a href="https://vlang.io/">https://vlang.io/</a>
</li>

<li>D programming language<br />
<a href="https://en.wikipedia.org/wiki/D_(programming_language)">https://en.wikipedia.org/wiki/D_(programming_language)</a>
</li>

<li>Zig programming language (Wikipedia)<br />
<a href="https://en.wikipedia.org/wiki/Zig_(programming_language)">https://en.wikipedia.org/wiki/Zig_(programming_language)</a>
</li>

<li>V programming language (Wikipedia)<br />
<a href="https://en.wikipedia.org/wiki/V_(programming_language)">https://en.wikipedia.org/wiki/V_(programming_language)</a>
</li>

<li>Syntax highlighting for C3's programming language<br />
<a href="https://github.com/Airbus5717/c3.vim">https://github.com/Airbus5717/c3.vim</a>
</li>

<li>Go factorial<br />
<a href="https://gist.github.com/esimov/9622710">https://gist.github.com/esimov/9622710</a>
</li>

<li>Generational list of programming languages<br />
<a href="https://en.wikipedia.org/wiki/Generational_list_of_programming_languages">https://en.wikipedia.org/wiki/Generational_list_of_programming_languages</a>
</li>

<li>The Language Tree: Almost Every Programming Language Ever Made<br />
<a href="https://github.com/Phileosopher/langmap">https://github.com/Phileosopher/langmap</a>
</li>

<li>List of C-family programming languages<br />
<a href="https://en.wikipedia.org/wiki/List_of_C-family_programming_languages">https://en.wikipedia.org/wiki/List_of_C-family_programming_languages</a>
</li>

<li>Compatibility of C and C++<br />
<a href="https://en.wikipedia.org/wiki/Compatibility_of_C_and_C%2B%2B">https://en.wikipedia.org/wiki/Compatibility_of_C_and_C%2B%2B</a>
</li>

<li>C++23: compatibility with C<br />
<a href="https://www.sandordargo.com/blog/2023/08/23/cpp23-c-compatibility">https://www.sandordargo.com/blog/2023/08/23/cpp23-c-compatibility</a>
</li>

<li>Can C++ Run C Code? Understanding Language Compatibility<br />
<a href="https://www.codewithc.com/can-c-run-c-code-understanding-language-compatibility/">https://www.codewithc.com/can-c-run-c-code-understanding-language-compatibility/</a>
</li>

<li>C3: Comparisons With Other Languages<br />
<a href="https://c3-lang.org/faq/compare-languages/">https://c3-lang.org/faq/compare-languages/</a>
</li>

<li>C3 Programming Language Gains Traction as Modern C Alternative<br />
<a href="https://biggo.com/news/202504040125_C3_Programming_Language_Alternative_to_C">https://biggo.com/news/202504040125_C3_Programming_Language_Alternative_to_C</a>
</li>

<li>The case against a C alternative<br />
<a href="https://c3.handmade.network/blog/p/8486-the_case_against_a_c_alternative">https://c3.handmade.network/blog/p/8486-the_case_against_a_c_alternative</a>
</li>

</ol>



<p></p><p></p>
<p><small>Autor: <a href="https://github.com/tisnik/">Pavel Tišnovský</a> &nbsp; 2025</small></p>
</body>
</html>

