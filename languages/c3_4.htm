<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
        "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html>
<head>
<title>Programovací jazyk C3: podmínky, rozvětvení a programové smyčky</title>
<meta name="Author" content="Pavel Tisnovsky" />
<meta name="Generator" content="vim" />
<meta http-equiv="content-type" content="text/html; charset=utf-8" />
<style type="text/css">
         body {color:#000000; background:#ffffff;}
         h1  {font-family: arial, helvetica, sans-serif; color:#ffffff; background-color:#c00000; text-align:center; padding-left:1em}
         h2  {font-family: arial, helvetica, sans-serif; color:#ffffff; background-color:#0000c0; padding-left:1em; text-align:left}
         h3  {font-family: arial, helvetica, sans-serif; color:#000000; background-color:#c0c0c0; padding-left:1em; text-align:left}
         h4  {font-family: arial, helvetica, sans-serif; color:#000000; background-color:#e0e0e0; padding-left:1em; text-align:left}
         a   {font-family: arial, helvetica, sans-serif;}
         li  {font-family: arial, helvetica, sans-serif; color:#000000; text-align:justify; width:450px;}
         ol  {font-family: arial, helvetica, sans-serif; color:#000000; text-align:justify; width:450px;}
         ul  {font-family: arial, helvetica, sans-serif; color:#000000; text-align:justify; width:450px;}
         p   {font-family: arial, helvetica, sans-serif; color:#000000; text-align:justify;}
         pre {background:#e0e0e0}
</style>
</head>

<body>

<h1>Programovací jazyk C3: podmínky, rozvětvení a programové smyčky</h1>

<h3>Pavel Tišnovský</h3>

<p></p>

<h1>Úvodník</h1>

<p>Ve čtvrtém článku o jazyku C3 se seznámíme s konstrukcemi pro řízení běhu programu. Jedná se o podmínky a různé formy rozvětvení (včetně rozšířené sémantiky switch-case) a dále o různé typy programových smyček. Jazyk C3 v tomto ohledu značně vylepšuje možnosti céčka.</p>



<h2>Obsah</h2>

<p><a href="#k01">1. Programovací jazyk C3: podmínky, rozvětvení a programové smyčky</a></p>
<p><a href="#k02">2. Rozvětvení běhu programu založené na konstrukcích <strong>if</strong> a <strong>if-else</strong></a></p>
<p><a href="#k03">3. Porovnání s&nbsp;jazykem C: nekorektní způsoby zápisu konstrukce <strong>if-else</strong></a></p>
<p><a href="#k04">4. Složitější rozvětvení založené na konstrukci <strong>if-else if-else</strong></a></p>
<p><a href="#k05">5. Základní forma rozvětvení založeného na konstrukci <strong>switch-case</strong></a></p>
<p><a href="#k06">6. Větší množství podmínek a konstrukce <strong>switch-case</strong></a></p>
<p><a href="#k07">7. Podmínky v&nbsp;konstrukci <strong>switch-case</strong> vyhodnocované v&nbsp;čase běhu procesu</a></p>
<p><a href="#k08">8. Konstrukce <strong>switch-case</strong> a příkaz <strong>break</strong></a></p>
<p><a href="#k09">9. Klíčové slovo <strong>nextcase</strong> v&nbsp;programové konstrukci <strong>switch-case</strong></a></p>
<p><a href="#k10">10. Základní forma počítané programové smyčky <strong>for</strong></a></p>
<p><a href="#k11">11. Průchod polem či jinou sekvencí smyčkou typu <strong>foreach</strong></a></p>
<p><a href="#k12">12. Průchod polem smyčkou <strong>foreach</strong> se získáním indexu i prvku v&nbsp;každé iteraci</a></p>
<p><a href="#k13">13. Modifikace prvků pole při jeho průchodu smyčkou <strong>foreach</strong></a></p>
<p><a href="#k14">14. Modifikace prvků pole přes ukazatel získaný v&nbsp;každé iteraci smyčky <strong>foreach</strong></a></p>
<p><a href="#k15">15. Průchod prvky sekvence v&nbsp;opačném pořadí s&nbsp;využitím smyčky <strong>foreach_r</strong></a></p>
<p><a href="#k16">16. Programová smyčka typu <strong>while</strong></a></p>
<p><a href="#k17">17. Vnořené programové smyčky</a></p>
<p><a href="#k18">18. Vnořené programové smyčky a příkaz <strong>break</strong></a></p>
<p><a href="#k19">19. Repositář s&nbsp;demonstračními příklady</a></p>
<p><a href="#k20">20. Odkazy na Internetu</a></p>



<p><a name="k01"></a></p>
<h2 id="k01">1. Programovací jazyk C3: podmínky, rozvětvení a programové smyčky</h2>

<p>V&nbsp;předchozích třech článcích o programovacím jazyce C3 jsme si
mj.&nbsp;řekli, že tento jazyk má poměrně velké množství rezervovaných
klíčových slov. Všechna tato slova jsou vypsána pod tímto odstavcem:</p>

<pre>
void        bool        char        double
float       float16     int128      ichar
int         iptr        isz         long
short       uint128     uint        ulong
uptr        ushort      usz         float128
any         fault       typeid      assert
asm         bitstruct   break       case
catch       const       continue    alias
default     defer       typedef     do
else        enum        extern      false
for         foreach     foreach_r   fn
tlocal      if          inline      import
macro       module      nextcase    null
return      static      struct      switch
true        try         union       var
while       attrdef
</pre>

<p>Některá slova již známe. Jedná se o názvy datových typů, o některé konstanty
a taktéž o slova používaná v&nbsp;definicích funkcí. Pokud tato slova ze seznam
odstraníme, zbude nám dosti zmenšený seznam:</p>

<pre>
any                     typeid      assert
asm         bitstruct   break       case
catch       const       continue    alias
default     defer       typedef     do
else        enum        extern
for         foreach     foreach_r   fn
tlocal      if          inline
macro                   nextcase
            static      struct      switch
            try         union
while       attrdef
</pre>

<p>V&nbsp;dnešním článku se seznámíme s&nbsp;konstrukcemi pro řízení běhu
programu, které jsou realizovány zvýrazněnými klíčovými slovy:</p>

<pre>
any                     typeid      assert
asm         bitstruct   <strong>break</strong>       <strong>case</strong>
catch       const       <strong>continue</strong>    alias
<strong>default</strong>     defer       typedef     <strong>do</strong>
<strong>else</strong>        enum        extern
<strong>for</strong>         <strong>foreach</strong>     <strong>foreach_r</strong>   fn
tlocal      <strong>if</strong>          inline
macro                   <strong>nextcase</strong>
            static      struct      <strong>switch</strong>
            try         union
<strong>while</strong>       attrdef
</pre>

<p>Pro připomenutí &ndash; všechny demonstrační příkladu ukázané
v&nbsp;navazujících kapitolách, jsou založeny na následující šabloně:</p>

<pre>
module program_stub;
&nbsp;
fn void <strong>main</strong>()
{
}
</pre>

<p>Jedná se o zápis plnohodnotného programu, který je možné přeložit a
spustit:</p>

<pre>
Program linked to executable './program_stub'.
Launching ./program_stub
Program completed with exit code 0.
</pre>



<p><a name="k02"></a></p>
<h2 id="k02">2. Rozvětvení běhu programu založené na konstrukcích <strong>if</strong> a <strong>if-else</strong></h2>

<p>V&nbsp;prakticky všech moderních programovacích jazycích se pro základní
rozvětvení běhu programu používá konstrukce založená na klíčovém slovu
<strong>if</strong>; v&nbsp;případě úplného rozvětvení (do dvou větví) pak
konstrukce založená na dvojici klíčových slov <strong>if</strong> a
<strong>else</strong>. Nejinak je tomu i v&nbsp;programovacím jazyku C3, ve
kterém se konstrukce <strong>if</strong> zapisuje následujícím způsobem (včetně
kulatých závorek okolo podmínky, tedy výrazu vyhodnocovaného na hodnotu typu
<strong>bool</strong>, a včetně zápisu příslušné větve do bloku ohraničeného
složenými závorkami):</p>

<pre>
module if_branch;
import std::io;
&nbsp;
fn void <strong>which_number</strong>(int x) {
    if (x % 2 == 0) {
        io::printfn("%d is even number", x);
    }
}
&nbsp;
fn void <strong>main</strong>()
{
    for (int i=0; i&lt;10; i++) {
        which_number(i);
    }
}
</pre>

<p>Tento program po svém překladu a spuštění vypíše pouze informace o tom, že
funkci <strong>which_number</strong> byl předán parametr obsahující sudé
číslo:</p>

<pre>
0 is even number
2 is even number
4 is even number
6 is even number
8 is even number
</pre>

<p>Úplné rozvětvení je realizováno s&nbsp;využitím klíčových slov
<strong>if</strong> a <strong>else</strong>, přičemž obě větve jsou zapsány
vlastním blokem (i když tento blok bude obsahovat jen jediný příkaz):</p>

<pre>
module if_else_branch;
import std::io;
&nbsp;
fn void <strong>which_number</strong>(int x) {
    if (x % 2 == 0) {
        io::printfn("%d is even number", x);
    }
    else {
        io::printfn("%d is odd number", x);
    }
}
&nbsp;
fn void <strong>main</strong>()
{
    for (int i=0; i&lt;10; i++) {
        which_number(i);
    }
}
</pre>

<p>Takto upravený program dokáže rozpoznat a vypsat jak sudá, tak i lichá
čísla, což je ostatně patrné i z&nbsp;vypsaných výsledků:</p>

<pre>
0 is even number
1 is odd number
2 is even number
3 is odd number
4 is even number
5 is odd number
6 is even number
7 is odd number
8 is even number
9 is odd number
</pre>



<p><a name="k03"></a></p>
<h2 id="k03">3. Porovnání s&nbsp;jazykem C: nekorektní způsoby zápisu konstrukce <strong>if-else</strong></h2>

<p>V&nbsp;programovacím jazyku C, a tím pádem i například v&nbsp;C++ nebo
v&nbsp;Javě (ale i v&nbsp;dalších programovacích jazycích) je možné ve větvi
<strong>if</strong> popř.&nbsp;ve větvi <strong>else</strong> zapsat jen jediný
příkaz, který nemusí být umístěn do samostatného bloku. Ovšem i kvůli zamezení
chybám typu <a
href="https://www.blackduck.com/blog/understanding-apple-goto-fail-vulnerability-2.html">Apple
Goto fail</a> takovou konstrukci jazyk C3 (ale například i Go) odmítne a bude
vyžadovat, aby se tento (jediný) příkaz zapsal přímo na řádek s&nbsp;podmínkou
<strong>if</strong>.</p>

<p>To si ostatně můžeme snadno otestovat na následující ukázce kódu:</p>

<pre>
module improper_if_else;
import std::io;
&nbsp;
fn void <strong>which_number</strong>(int x) {
    if (x % 2 == 0)
        io::printfn("%d is even number", x);
    else
        io::printfn("%d is odd number", x);
}
&nbsp;
fn void <strong>main</strong>()
{
    for (int i=0; i&lt;10; i++) {
        which_number(i);
    }
}
</pre>

<p>Překladač tuto konstrukci odmítne:</p>

<pre>
 3: 
 4: fn void which_number(int x) {
 5:     if (x % 2 == 0)
 6:         io::printfn("%d is even number", x);
            ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
(/tmp/ramdisk/c3-control-flow/04_improper_if.c3:6:9) Error: The 'then' part of a single line if-statement must start on the same line as the 'if' or use '{ }'
</pre>

<p>Pokud se jedná o neúplné rozvětvení (s&nbsp;<strong>if</strong>, ale bez
<strong>else</strong>), je podporován tento zápis:</p>

<pre>
module improper_if_else;
import std::io;
&nbsp;
fn void <strong>which_number</strong>(int x) {
    if (x % 2 == 0) io::printfn("%d is even number", x);
}
&nbsp;
fn void <strong>main</strong>()
{
    for (int i=0; i&lt;10; i++) {
        which_number(i);
    }
}
</pre>

<p>Ovšem v&nbsp;případě, že se jedná o rozvětvení úplné, vyžaduje překladač
jazyka C3 explicitní zápis programových bloků, tedy takový zápis, který byl
použit <a href="#k02">v&nbsp;předchozí kapitole</a>:</p>

<pre>
module improper_if_else;
import std::io;
&nbsp;
fn void <strong>which_number</strong>(int x) {
    if (x % 2 == 0) io::printfn("%d is even number", x);
    else io::printfn("%d is odd number", x);
}
&nbsp;
fn void <strong>main</strong>()
{
    for (int i=0; i&lt;10; i++) {
        which_number(i);
    }
}
</pre>

<p>Chybové hlášení překladače:</p>

<pre>
 2: import std::io;
 3: 
 4: fn void which_number(int x) {
 5:     if (x % 2 == 0) io::printfn("%d is even number", x);
                        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
(/tmp/ramdisk/c3-control-flow/05_improper_if.c3:5:21) Error: if-statements with an 'else' must use '{ }' even around a single statement.
</pre>



<p><a name="k04"></a></p>
<h2 id="k04">4. Složitější rozvětvení založené na konstrukci <strong>if-else if-else</strong></h2>

<p>V&nbsp;případě, že má být provedeno rozvětvení do většího množství větví
(typicky na základě složitější podmínky), můžeme využít konstrukci
<strong>if-else if else</strong>. Ve skutečnosti se jedná o běžné rozvětvení
<strong>if-else</strong>, ovšem ve větvi <strong>else</strong> je zapsáno další
rozvětvení. Výsledek není příliš čitelný a i z&nbsp;tohoto důvodu lze využít
rozšířenou konstrukci <strong>switch-case</strong> popsanou v&nbsp;navazujících
kapitolách. Nicméně se vraťme k&nbsp;rozvětvení realizovanému pomocí
<strong>if-else if-else</strong>. Vypadá následovně:</p>

<pre>
module if_else_if;
import std::io;
&nbsp;
fn void <strong>which_number</strong>(int x) {
    if (x == 0) {
        io::printfn("%d is zero", x);
    }
    else if (x % 2 == 0) {
        io::printfn("%d is even number", x);
    }
    else {
        io::printfn("%d is odd number", x);
    }
}
&nbsp;
fn void <strong>main</strong>()
{
    for (int i=0; i&lt;10; i++) {
        which_number(i);
    }
}
</pre>

<p>Takto upravený program rozliší, zda se do funkce
<strong>which_number</strong> předává nulová hodnota, hodnota kladná či naopak
hodnota záporná:</p>

<pre>
0 is zero
1 is odd number
2 is even number
3 is odd number
4 is even number
5 is odd number
6 is even number
7 is odd number
8 is even number
9 is odd number
</pre>

<p><div class="rs-tip-major">Poznámka: z&nbsp;tohoto popisu nepřímo vyplývá, že
v&nbsp;jazyku C3 neexistuje klíčové slovo <strong>elseif</strong> či
<strong>elif</strong>.</div></p>



<p><a name="k05"></a></p>
<h2 id="k05">5. Základní forma rozvětvení založeného na konstrukci <strong>switch-case</strong></h2>

<p><a href="#k04">V&nbsp;předchozí kapitole</a> bylo napsáno, že rozhodovací
konstrukce <strong>if-else if-else</strong> není příliš čitelná a většinou se
ani často v&nbsp;jazyku C3 nepoužívá. Je tomu tak z&nbsp;toho důvodu, že
programovací jazyk C3 nabízí vývojářům lepší, použitelnější i čitelnější
rozhodovací konstrukci <strong>switch-case</strong>. Ta se v&nbsp;některých
ohledech odlišuje od jazyka C a spíše se podobá programovacímu jazyku Go.</p>

<p>Podívejme se nejdříve na základní způsob zápisu této rozhodovací konstrukce.
Za klíčovým slovem <strong>switch</strong> je v&nbsp;kulatých závorkách zapsán
výraz, který se vyhodnotí a jeho výsledek je postupně porovnáván
s&nbsp;konstantami zapsanými za klíčová slova <strong>case</strong>.
V&nbsp;případě, že dojde ke shodě, tj.&nbsp;například pokud platí, že
<strong>x==1</strong>, jsou vykonány příkazy uvedené v&nbsp;bloku za
<strong>case</strong>. Oproti programovacímu jazyku C je zde jeden významný
rozdíl &ndash; není zapotřebí jednotlivé bloky explicitně ukončovat klíčovým
slovem <strong>break</strong>:</p>

<pre>
module switch_statement;
import std::io;
&nbsp;
fn void <strong>which_number</strong>(int x) {
    switch (x) {
        case 0:
            io::printfn("%d is zero", x);
        case 1:
            io::printfn("%d is odd number", x);
        case 2:
            io::printfn("%d is even number", x);
        default:
            io::printfn("I don't know what to say about %d", x);
    }
}
&nbsp;
fn void <strong>main</strong>()
{
    for (int i=0; i&lt;10; i++) {
        which_number(i);
    }
}
</pre>

<p>Výsledek by měl vypadat následovně:</p>

<pre>
0 is zero
1 is odd number
2 is even number
I don't know what to say about 3
I don't know what to say about 4
I don't know what to say about 5
I don't know what to say about 6
I don't know what to say about 7
I don't know what to say about 8
I don't know what to say about 9
</pre>

<p>Z&nbsp;důvodu (například) přepisu starších programů z&nbsp;C do C3 je ovšem
použití klíčového slova <strong>break</strong> povoleno:</p>

<pre>
module switch_statement;
import std::io;
&nbsp;
fn void <strong>which_number</strong>(int x) {
    switch (x) {
        case 0:
            io::printfn("%d is zero", x);
            <u>break;</u>
        case 1:
            io::printfn("%d is odd number", x);
            <u>break;</u>
        case 2:
            io::printfn("%d is even number", x);
            <u>break;</u>
        default:
            io::printfn("I don't know what to say about %d", x);
            <u>break;</u>
    }
}
&nbsp;
fn void <strong>main</strong>()
{
    for (int i=0; i&lt;10; i++) {
        which_number(i);
    }
}
</pre>

<p><div class="rs-tip-major">Poznámka: zde to sice není díky větvi
<strong>default</strong> patrné, ale jazyk C3 nevyžaduje, aby podmínky ve
větvích <strong>case</strong> pokrývaly všechny možné stavy (na rozdíl od
programovacího jazyka Rust).</div></p>



<p><a name="k06"></a></p>
<h2 id="k06">6. Větší množství podmínek a konstrukce <strong>switch-case</strong></h2>

<p>V&nbsp;případě, že budeme mít za úkol rozlišit, jaká čísla (sudá, lichá či
nula) v&nbsp;rozsahu od 0 do 9 jsou předána do funkce
<strong>which_number</strong>, můžeme realizaci tohoto algoritmu, i když bude
řešení dosti naivní a nerozšiřitelné, založit na konstrukci
<strong>switch-case</strong>, ovšem s&nbsp;tím, že budeme nějaký příkaz
(například výpis informace o tom, že se jedná a sudou hodnotu) provádět pro
více hodnot <strong>x</strong>. Realizace se do značné míry podobá zápisu,
který by byl použit v&nbsp;klasickém céčku, akorát není zapotřebí zapisovat
klíčové slovo <strong>break</strong> v&nbsp;každém bloku s&nbsp;výpisem typu
hodnoty:</p>

<pre>
module switch_statement;
import std::io;
&nbsp;
fn void <strong>which_number</strong>(int x) {
    switch (x) {
        case 0:
            io::printfn("%d is zero", x);
        case 1:
        case 3:
        case 5:
        case 7:
        case 9:
            io::printfn("%d is odd number", x);
        case 2:
        case 4:
        case 6:
        case 8:
        case 10:
            io::printfn("%d is even number", x);
        default:
            io::printfn("I don't know what to say about %d", x);
    }
}
&nbsp;
fn void <strong>main</strong>()
{
    for (int i=0; i&lt;10; i++) {
        which_number(i);
    }
}
</pre>

<p>Nyní bude výsledek vypadat podobně, jako tomu bylo při použití rozhodovací
konstrukce <strong>if-else if-else</strong>:</p>

<pre>
0 is zero
1 is odd number
2 is even number
3 is odd number
4 is even number
5 is odd number
6 is even number
7 is odd number
8 is even number
9 is odd number
</pre>

<p><div class="rs-tip-major">Poznámka: pochopitelně je tento způsob (prozatím)
nepříliš obecný, to ovšem změníme v&nbsp;navazující kapitole.</div></p>



<p><a name="k07"></a></p>
<h2 id="k07">7. Podmínky v&nbsp;konstrukci <strong>switch-case</strong> vyhodnocované v&nbsp;čase běhu procesu</h2>

<p>Ve skutečnosti ovšem programová konstrukce <strong>switch-case</strong>
implementovaná v&nbsp;programovacím jazyku C3 nabízí větší možnosti, než
podobně vypadající konstrukce v&nbsp;původním céčku. Například je možné za
klíčová slova <strong>case</strong> zapisovat výrazy vyhodnocované až
v&nbsp;čase běhu programu. To tedy znamená, že můžeme realizovat rozhodnutí,
zda je předaná celočíselná hodnota nulová, sudá či naopak lichá, například
následujícím způsobem:</p>

<pre>
module switch_statement;
import std::io;
&nbsp;
fn void <strong>which_number</strong>(int x) {
    switch (true) {
        case x == 0:
            io::printfn("%d is zero", x);
        case x % 2 == 0:
            io::printfn("%d is even number", x);
        default:
            io::printfn("%d is odd number", x);
    }
}
&nbsp;
fn void <strong>main</strong>()
{
    for (int i=0; i&lt;10; i++) {
        which_number(i);
    }
}
</pre>

<p>Výsledky získané po překladu a spuštění tohoto příkladu:</p>

<pre>
0 is zero
1 is odd number
2 is even number
3 is odd number
4 is even number
5 is odd number
6 is even number
7 is odd number
8 is even number
9 is odd number
</pre>

<p>Ve skutečnosti můžeme výraz za klíčovým slovem <strong>switch</strong> zcela
odstranit a provést rozvětvení následujícím způsobem:</p>

<pre>
module switch_statement;
import std::io;
&nbsp;
fn void <strong>which_number</strong>(int x) {
    switch {
        case x == 0:
            io::printfn("%d is zero", x);
        case x % 2 == 0:
            io::printfn("%d is even number", x);
        default:
            io::printfn("%d is odd number", x);
    }
}
&nbsp;
fn void <strong>main</strong>()
{
    for (int i=0; i&lt;10; i++) {
        which_number(i);
    }
}
</pre>

<p>Výsledky budou totožné s&nbsp;předchozím řešením:</p>

<pre>
0 is zero
1 is odd number
2 is even number
3 is odd number
4 is even number
5 is odd number
6 is even number
7 is odd number
8 is even number
9 is odd number
</pre>



<p><a name="k08"></a></p>
<h2 id="k08">8. Konstrukce <strong>switch-case</strong> a příkaz <strong>break</strong></h2>

<p>V&nbsp;předchozím textu jsme si řekli, že v&nbsp;rozhodovací konstrukci
<strong>switch-case</strong> není nutné jednotlivé větve &bdquo;uzavírat&ldquo;
slovem <strong>break</strong>. Ovšem můžeme se setkat se situací, kdy by větev
byla prázdná. V&nbsp;takovém případě se <strong>break</strong> hodí. Typickým
příkladem použití je explicitní zápis větve <strong>default</strong>, která je
prázdná (jazyk C3 její explicitní zápis ovšem nevyžaduje):</p>

<pre>
module switch_statement;
import std::io;
&nbsp;
fn void <strong>which_number</strong>(int x) {
    switch (true) {
        case x == 0:
            io::printfn("%d is zero", x);
        case x % 2 == 0:
            io::printfn("%d is even number", x);
        case x % 2 != 0:
            io::printfn("%d is odd number", x);
        default:
            break;
    }
}
&nbsp;
fn void <strong>main</strong>()
{
    for (int i=0; i&lt;10; i++) {
        which_number(i);
    }
}
</pre>

<p>Opět se podívejme na to, jaké zprávy budou tímto demonstračním příkladem
vypsány:</p>

<pre>
0 is zero
1 is odd number
2 is even number
3 is odd number
4 is even number
5 is odd number
6 is even number
7 is odd number
8 is even number
9 is odd number
</pre>



<p><a name="k09"></a></p>
<h2 id="k09">9. Klíčové slovo <strong>nextcase</strong> v&nbsp;programové konstrukci <strong>switch-case</strong></h2>

<p>V&nbsp;jazyku C3 je možné ve větvi <strong>case</strong> zapsat klíčové
slovo <strong>nextcase</strong>, které přenese řízení do další větve.
V&nbsp;mnoha ohledech se tedy <strong>nextcase</strong> podobá klíčovému slovu
<strong>fallthrough</strong> z&nbsp;programovacího jazyka Go. Podívejme se na
příklad použití. Ve větvi zavolané pro x==0 se po výpisu zprávy &bdquo;0 is
zero&ldquo; konstrukce <strong>switch-case</strong> neukončí, ale přejde se na
další větev, ve které se vypíše &bdquo;0 is even number&ldquo; (což je vlastně
taktéž korektní). Takto upravený demonstrační příklad vypadá následovně:</p>

<pre>
module switch_statement;
import std::io;
&nbsp;
fn void <strong>which_number</strong>(int x) {
    switch (true) {
        case x == 0:
            io::printfn("%d is zero", x);
            nextcase;
        case x % 2 == 0:
            io::printfn("%d is even number", x);
        case x % 2 != 0:
            io::printfn("%d is odd number", x);
        default:
            break;
    }
}
&nbsp;
fn void <strong>main</strong>()
{
    for (int i=0; i&lt;10; i++) {
        which_number(i);
    }
}
</pre>

<p>Povšimněte si, že se skutečně pro x==0 vypíše dvojice zpráv a nikoli pouze
informace o nulovém prvku:</p>

<pre>
0 is zero
0 is even number
1 is odd number
2 is even number
3 is odd number
4 is even number
5 is odd number
6 is even number
7 is odd number
8 is even number
9 is odd number
</pre>



<p><a name="k10"></a></p>
<h2 id="k10">10. Základní forma počítané programové smyčky <strong>for</strong></h2>

<p>Vzhledem k&nbsp;tomu, že je programovací jazyk C3 odvozen od klasického
céčka, nebude velkým překvapením, že i v&nbsp;C3 nalezneme programovou smyčku
realizovanou klíčovým slovem <strong>for</strong>. I v&nbsp;C3 je možné
specifikovat lokální proměnnou použitou jako počitadlo smyčky. Příkladem může
být program, který jsme si (i když v&nbsp;nepatrně odlišné variantě) ukázali
minule. V&nbsp;tomto programu je definováno desetiprvkové pole, přičemž hodnoty
prvků tohoto pole jsou naplněny právě v&nbsp;počítané smyčce
<strong>for</strong>:</p>

<pre>
module loops;
import std::io;
&nbsp;
fn void <strong>main</strong>()
{
    int[10] a;
&nbsp;
    for (int i=0; i&lt;a.len; i++) {
        a[i] = (i + 1)*10;
    }
    io::printf("a=%s\n", a);
}
</pre>

<p>Ze zobrazených výsledků je patrné, že je pole skutečně naplněno hodnotami
vypočtenými uvnitř programové smyčky:</p>

<pre>
a=[10, 20, 30, 40, 50, 60, 70, 80, 90, 100]
</pre>

<p>Ve smyčce <strong>for</strong> lze ovšem hodnotu počitadla měnit libovolným
způsobem, například:</p>

<pre>
module loops;
import std::io;
&nbsp;
fn void <strong>main</strong>()
{
    for (int i=1; i&lt;1000; i*=2) {
        io::printf("i=%s\n", i);
    }
}
</pre>

<p>Výsledky:</p>

<pre>
i=1
i=2
i=4
i=8
i=16
i=32
i=64
i=128
i=256
i=512
</pre>



<p><a name="k11"></a></p>
<h2 id="k11">11. Průchod polem či jinou sekvencí smyčkou typu <strong>foreach</strong></h2>

<p><a
href="https://www.root.cz/clanky/programovaci-jazyk-c3-slozene-datove-typy-a-kontejnery/">V&nbsp;předchozím
článku</a> jsme se seznámili s&nbsp;takzvanými <i>kontejnery</i>,
tj.&nbsp;s&nbsp;datovými typy, které jako své hodnoty obsahují nějakou sekvenci
prvků (obecně odlišného typu). Pro realizaci průchodu těmito prvky je
v&nbsp;programovacím jazyku C3 určena programová smyčka typu
<strong>forach</strong>, kterou je možné zapsat různými způsoby.</p>

<p>Nejjednodušší forma zápisu smyčky typu <strong>foreach</strong> je ukázána
na dalším demonstračním příkladu. Procházíme v&nbsp;něm polem
<strong>a</strong>, přičemž v&nbsp;každé iteraci bude hodnota n-tého prvku
uložena do lokální proměnné <strong>item</strong>. Povšimněte si, že není nutné
specifikovat typ této proměnné. A navíc bude tato proměnná viditelná pouze ve
vnitřním bloku smyčky <strong>foreach</strong>:</p>

<pre>
module loops;
import std::io;
&nbsp;
fn void <strong>main</strong>()
{
    int[10] a = {1, 2, 3, 4, 5, 6, 7, 8, 9, 10};
&nbsp;
    foreach (item : a)
    {
        io::printfn("item: %s", item);
    }
}
</pre>

<p>Výsledky, které by se měly zobrazit po překladu a spuštění tohoto
příkladu:</p>

<pre>
item: 1
item: 2
item: 3
item: 4
item: 5
item: 6
item: 7
item: 8
item: 9
item: 10
</pre>

<p><div class="rs-tip-major">Poznámka: tuto smyčku je možné použít i pro
uživatelem definované datové typy, ovšem aby byla aplikovatelná, je nutné
provést přetížení některých operátorů atd. v&nbsp;takových typech. Podrobnosti
si řekneme v&nbsp;navazujícím článku.</div></p>



<p><a name="k12"></a></p>
<h2 id="k12">12. Průchod polem smyčkou <strong>foreach</strong> se získáním indexu i prvku v&nbsp;každé iteraci</h2>

<p>Programová smyčka typu <strong>forarch</strong> dokáže v&nbsp;každé iteraci
získat jak hodnotu prvku pole (což jsme ostatně viděli i v&nbsp;předchozí
kapitole), tak i index tohoto prvku, což může být poměrně užitečné (modifikace
pole, tisk různých tabulek atd.). Zápis takové varianty programové smyčky je ve
skutečnosti velmi jednoduchý, jak je to ostatně patrné i z&nbsp;následujícího
demonstračního příkladu. Povšimněte si, že není nutné definovat ani typ
proměnné <strong>index</strong> ani <strong>item</strong> (a pochopitelně jsou
tato jména plně volitelná vývojářem):</p>

<pre>
module loops;
import std::io;
&nbsp;
fn void <strong>main</strong>()
{
    int[10] a = {1, 2, 3, 4, 5, 6, 7, 8, 9, 10};
&nbsp;
    foreach (index, item : a)
    {
        io::printfn("item #%d: %s", index, item);
    }
}
</pre>

<p>Po překladu a spuštění tohoto příkladu by se mělo vypsat deset řádků
s&nbsp;indexy i hodnotami prvků pole <strong>a</strong>:</p>

<pre>
item #0: 1
item #1: 2
item #2: 3
item #3: 4
item #4: 5
item #5: 6
item #6: 7
item #7: 8
item #8: 9
item #9: 10
</pre>



<p><a name="k13"></a></p>
<h2 id="k13">13. Modifikace prvků pole při jeho průchodu smyčkou <strong>foreach</strong></h2>

<p>Při průchodu polem s&nbsp;využitím programové smyčky
<strong>foreach</strong> je možné obsah tohoto pole přímo modifikovat (což ale
obecně nemusí platit pro všechny typy sekvencí). Využijeme přitom znalosti
indexu každého prvku pole. Pokud například budeme chtít do desetiprvkového pole
celých čísel postupně uložit hodnoty 10, 20, 30 ... 100, je možné postupovat
následujícím způsobem:</p>

<pre>
module loops;
import std::io;
&nbsp;
fn void <strong>main</strong>()
{
    int[10] a = {1, 2, 3, 4, 5, 6, 7, 8, 9, 10};
&nbsp;
    foreach (i, item : a)
    {
        a[i] = ((int)i + 1)*10;
    }
    io::printf("a=%s\n", a);
}
</pre>

<p>Po překladu a spuštění tohoto příkladu si lze snadno ověřit, že je výsledek
korektní:</p>

<pre>
a=[10, 20, 30, 40, 50, 60, 70, 80, 90, 100]
</pre>

<p><div class="rs-tip-major">Poznámka: v&nbsp;programovacích jazycích, jakými
je Go, je nutné deklarovanou proměnnou skutečně použít. V&nbsp;těchto jazycích
by se mohl namísto jména <strong>item</strong> použít náhradní znak
(<i>placeholder</i>) <strong>_</strong>. V&nbsp;C3 to však není možné a proto
nepůjde následující program přeložit:</div></p>

<pre>
module loops;
import std::io;
&nbsp;
fn void <strong>main</strong>()
{
    int[10] a = {1, 2, 3, 4, 5, 6, 7, 8, 9, 10};
&nbsp;
    foreach (i, _ : a)
    {
        a[i] = ((int)i + 1)*10;
    }
    io::printf("a=%s\n", a);
}
</pre>



<p><a name="k14"></a></p>
<h2 id="k14">14. Modifikace prvků pole přes ukazatel získaný v&nbsp;každé iteraci smyčky <strong>foreach</strong></h2>

<p>Při použití programové smyčky <strong>foreach</strong> ve formě:</p>

<pre>
foreach (i, item : a)
{
    ...
    ...
    ...
}
</pre>

<p>je v&nbsp;každé iteraci do proměnné <strong>item</strong> zkopírována
<i>hodnota</i> prvku. To ovšem znamená, že sice můžeme změnit hodnotu této
proměnné, ale na původní pole nebude mít tato modifikace žádný vliv.</p>

<p>To si ostatně můžeme velmi snadno ověřit:</p>

<pre>
module loops;
import std::io;
&nbsp;
fn void <strong>main</strong>()
{
    int[10] a = {1, 2, 3, 4, 5, 6, 7, 8, 9, 10};
&nbsp;
    foreach (i, item : a)
    {
        item = ((int)i + 1)*10;
    }
    io::printf("a=%s\n", a);
}
</pre>

<p>Po spuštění tohoto příkladu se vypíšou původní hodnoty prvků pole:</p>

<pre>
a=[1, 2, 3, 4, 5, 6, 7, 8, 9, 10]
</pre>

<p>Jazyk C3 ovšem umožňuje, aby se ve smyčce <strong>foreach</strong>
v&nbsp;každé iteraci získal <i>ukazatel</i> na prvek pole, což již umožňuje
zápis nové hodnoty do dané prvku (právě přes tento ukazatel). Syntaxe vypadá
takto:</p>

<pre>
foreach (i, <u>&amp;item</u> : a)
{
    ...
    ...
    ...
}
</pre>

<p>Ověřme si, jak lze takovou variantu programové smyčky využít:</p>

<pre>
module loops;
import std::io;
&nbsp;
fn void <strong>main</strong>()
{
    int[10] a = {1, 2, 3, 4, 5, 6, 7, 8, 9, 10};
&nbsp;
    foreach (i, &amp;item : a)
    {
        *item = ((int)i + 1)*10;
    }
    io::printf("a=%s\n", a);
}
</pre>

<p>Po spuštění tohoto demonstračního příkladu skutečně dojde k&nbsp;zápisu
nových hodnot do všech prvků pole:</p>

<pre>
a=[10, 20, 30, 40, 50, 60, 70, 80, 90, 100]
</pre>



<p><a name="k15"></a></p>
<h2 id="k15">15. Průchod prvky sekvence v&nbsp;opačném pořadí s&nbsp;využitím smyčky <strong>foreach_r</strong></h2>

<p>Programovací jazyk C3 umožňuje u některých typů sekvencí, mezi které patří
mj.&nbsp;i klasická pole, nejenom průchod od prvního prvku směrem k&nbsp;prvku
poslednímu, ale i opačný průchod, tj.&nbsp;od posledního prvku směrem
k&nbsp;prvku prvnímu. Pokud je zapotřebí v&nbsp;programu tento průchod
realizovat, používá se namísto programové smyčky <strong>foreach</strong>
smyčka zapisovaná klíčovým slovem <strong>foreach_r</strong>. Ta má &ndash;
pochopitelně kromě opačného směru iterací &ndash; naprosto stejné vlastnosti,
jako již popsaná smyčka <strong>foreach</strong>.</p>

<pre>
module loops;
import std::io;
&nbsp;
fn void <strong>main</strong>()
{
    int[10] a = {1, 2, 3, 4, 5, 6, 7, 8, 9, 10};
&nbsp;
    foreach_r (item : a)
    {
        io::printfn("item: %s", item);
    }
}
</pre>

<p>Výsledkem běhu tohoto programu bude následující sekvence hodnot přečtených
z&nbsp;pole:</p>

<pre>
item: 10
item: 9
item: 8
item: 7
item: 6
item: 5
item: 4
item: 3
item: 2
item: 1
</pre>



<p><a name="k16"></a></p>
<h2 id="k16">16. Programová smyčka typu <strong>while</strong></h2>

<p>Druhým typem programové smyčky, se kterou se dnes seznámíme, je smyčka typu
<strong>while</strong>. Jedná se o smyčku, ve které se podmínka, zda se má
provádět další iterace, provádí vždy na začátku každé iterace, tj.&nbsp;ještě
před vstupem do těla smyčky (smyčka se tedy nemusí provést ani jedenkrát).
Základní tvar této smyčky se v&nbsp;jazyku C3 vlastně nijak neodlišuje od
jazyka C, ovšem s&nbsp;tím upřesněním, že podmínka pro další iteraci musí být
zapsána výrazem typu <strong>bool</strong>.</p>

<p>Podívejme se na realizaci průchodu polem, tentokrát ovšem namísto smyčky
<strong>foreach</strong> použijeme smyčku <strong>while</strong> (která je
mimochodem v&nbsp;tomto kontextu nevhodná):</p>

<pre>
module loops;
import std::io;
&nbsp;
fn void <strong>main</strong>()
{
    int[10] a = {1, 2, 3, 4, 5, 6, 7, 8, 9, 10};
&nbsp;
    int i = 0;
    while (i&lt;a.len) {
        io::printfn("item: %s", a[i]);
        i++;
    }
}
</pre>

<p>Výsledky vypsané tímto demonstračním příkladem by měly být snadno
pochopitelné:</p>

<pre>
item: 1
item: 2
item: 3
item: 4
item: 5
item: 6
item: 7
item: 8
item: 9
item: 10
</pre>

<p>V&nbsp;této smyčce lze, pochopitelně podobně jako u dalších typů
programových smyček, použít příkaz <strong>break</strong> určený pro ukončení
těla smyčky (typicky při splnění nějaké další podmínky):</p>

<pre>
module loops;
import std::io;
&nbsp;
fn void <strong>main</strong>()
{
    int[10] a = {1, 2, 3, 4, 5, 6, 7, 8, 9, 10};
&nbsp;
    int i = 0;
    while (i&lt;a.len) {
        if (a[i] &gt;= 6) {
            break;
        }
        io::printfn("item: %s", a[i]);
        i++;
    }
}
</pre>

<p>Nyní se tělo smyčky ukončí při splnění zapsané podmínky (hodnota prvku pole
je větší nebo rovna šesti):</p>

<pre>
item: 1
item: 2
item: 3
item: 4
item: 5
</pre>



<p><a name="k17"></a></p>
<h2 id="k17">17. Vnořené programové smyčky</h2>

<p>V&nbsp;jazyku C3, ostatně podobně jako ve všech mainstreamových
programovacích jazycích, je možné programové smyčky vnořovat, s&nbsp;čímž
souvisí i syntaxe a zejména sémantika příkazů <strong>break</strong> a
<strong>continue</strong>. Podívejme se nejdříve na realizaci výpočtu malé
násobilky s&nbsp;využitím dvou vnořených smyček typu <strong>for</strong>:</p>

<pre>
module loops;
import std::io;
&nbsp;
fn void <strong>main</strong>()
{
    for (int y=1; y&lt;=10; y++) {
        for (int x=1; x&lt;=10; x++) {
            int z = x * y;
            io::printf("%3d ", z);
        }
        io::printn();
    }
}
</pre>

<p>Výsledkem bude následující tabulka vypsaná na standardní výstup:</p>

<pre>
  1   2   3   4   5   6   7   8   9  10 
  2   4   6   8  10  12  14  16  18  20 
  3   6   9  12  15  18  21  24  27  30 
  4   8  12  16  20  24  28  32  36  40 
  5  10  15  20  25  30  35  40  45  50 
  6  12  18  24  30  36  42  48  54  60 
  7  14  21  28  35  42  49  56  63  70 
  8  16  24  32  40  48  56  64  72  80 
  9  18  27  36  45  54  63  72  81  90 
 10  20  30  40  50  60  70  80  90 100 
</pre>

<p><div class="rs-tip-major">Poznámka: realizace založená na programových
smyčkách typu <strong>while</strong> není tak elegantní, vyžaduje proměnné
s&nbsp;větší oblastí viditelnosti a navíc zde hrozí zapomenutí příkazu pro
zvýšení hodnoty proměnné:</div></p>

<pre>
module loops;
import std::io;
&nbsp;
fn void <strong>main</strong>()
{
    int y=1;
    while (y&lt;=10) {
        int x=1;
        while (x&lt;=10) {
            int z = x * y;
            io::printf("%3d ", z);
            x++;
        }
        io::printn();
        y++;
    }
}
</pre>



<p><a name="k18"></a></p>
<h2 id="k18">18. Vnořené programové smyčky a příkaz <strong>break</strong></h2>

<p>Jak jsme se již řekli <a href="#k18">v&nbsp;předchozí kapitole</a>, přináší
možnost tvorby vnořených programových smyček jeden syntaktický a současně i
sémantický problém &ndash; jak řešit výskoky (ukončení) z&nbsp;vnitřních
smyček? V&nbsp;programovacím jazyku C k&nbsp;tomuto účelu sloužila konstrukce
<strong>goto</strong>, ovšem jazyk C3 se snaží být více strukturovaný. Proto
bylo nutné zavést způsob zápisu, který umožní výskok z&nbsp;vnitřních
smyček.</p>

<p>Nejprve si připomeňme, že ukončení vnitřní smyčky zajistí příkaz
<strong>break</strong>, a to bez dalších úprav:</p>

<pre>
module loops;
import std::io;
&nbsp;
fn void <strong>main</strong>()
{
    for (int y=1; y&lt;=10; y++) {
        for (int x=1; x&lt;=10; x++) {
            int z = x * y;
            io::printf("%3d ", z);
            if (z == 42) {
                <u>break;</u>
            }
        }
        io::printn();
    }
}
</pre>

<p>Po spuštění tohoto programu se vnitřní smyčka ukončí po dosažení hodnoty 42,
ovšem vnější smyčka stále pokračuje ve své činnosti. Výsledkem bude tabulka se
zkráceným šestým a sedmým řádkem:</p>

<pre>
  1   2   3   4   5   6   7   8   9  10 
  2   4   6   8  10  12  14  16  18  20 
  3   6   9  12  15  18  21  24  27  30 
  4   8  12  16  20  24  28  32  36  40 
  5  10  15  20  25  30  35  40  45  50 
  6  12  18  24  30  36  42 
  7  14  21  28  35  42 
  8  16  24  32  40  48  56  64  72  80 
  9  18  27  36  45  54  63  72  81  90 
 10  20  30  40  50  60  70  80  90 100 
</pre>

<p>Programovací jazyk C3 zavádí novou syntaxi zápisu <i>návěští</i>
(<i>label</i>), které umožňuje ukončení nejenom vnitřní smyčky, ale i libovolně
zvolené smyčky vnější. Návěští se zapisuje přímo za klíčové slovo, kterým
smyčka začíná:</p>

<pre>
module loops;
import std::io;
&nbsp;
fn void <strong>main</strong>()
{
    for <u>END:</u> (int y=1; y&lt;=10; y++) {
        for (int x=1; x&lt;=10; x++) {
            int z = x * y;
            io::printf("%3d ", z);
            if (z == 42) {
                <u>break END;</u>
            }
        }
        io::printn();
    }
}
</pre>

<p>V&nbsp;tomto demonstračním příkladu bude tisk tabulky zcela ukončen po
dosažení hodnoty 42:</p>

<pre>
  1   2   3   4   5   6   7   8   9  10 
  2   4   6   8  10  12  14  16  18  20 
  3   6   9  12  15  18  21  24  27  30 
  4   8  12  16  20  24  28  32  36  40 
  5  10  15  20  25  30  35  40  45  50 
  6  12  18  24  30  36  42
</pre>

<p>Naprosto stejným způsobem lze téhož dosáhnout i u programové smyčky typu
<strong>while</strong>:</p>

<pre>
module loops;
import std::io;
&nbsp;
fn void <strong>main</strong>()
{
    int y = 1;
    while <u>END:</u> (y&lt;=10) {
        int x = 1;
        while (x&lt;=10) {
            int z = x * y;
            io::printf("%3d ", z);
            if (z == 42) {
                <u>break END;</u>
            }
            x++;
        }
        io::printn();
        y++;
    }
}
</pre>

<p>Výsledek:</p>

<pre>
  1   2   3   4   5   6   7   8   9  10 
  2   4   6   8  10  12  14  16  18  20 
  3   6   9  12  15  18  21  24  27  30 
  4   8  12  16  20  24  28  32  36  40 
  5  10  15  20  25  30  35  40  45  50 
  6  12  18  24  30  36  42
</pre>

<p>Ještě si ukažme nepatrně komplikovanější příklad, ve kterém se příkazem
<strong>break</strong> vyskakuje ze dvou smyček, i když jsou v&nbsp;programu
realizovány celkem tři vnořené programové smyčky:</p>

<pre>
module loops;
import std::io;
&nbsp;
fn void <strong>main</strong>()
{
    for (int zaklad=1; zaklad&lt;=100; zaklad*=10) {
        for END: (int y=1; y&lt;=10; y++) {
            for (int x=1; x&lt;=10; x++) {
                int z = x * y;
                io::printf("%5d ", z*zaklad);
                if (z == 42) {
                    break END;
                }
            }
            io::printn();
        }
        io::printn();
        io::printn("-----------------------------------------------------------");
    }
}
</pre>

<p>Výsledky ukazují ukončení &bdquo;prostřední&ldquo; smyčky, nikoli smyčky
vnější:</p>

<pre>
    1     2     3     4     5     6     7     8     9    10
    2     4     6     8    10    12    14    16    18    20
    3     6     9    12    15    18    21    24    27    30
    4     8    12    16    20    24    28    32    36    40
    5    10    15    20    25    30    35    40    45    50
    6    12    18    24    30    36    42
-----------------------------------------------------------
   10    20    30    40    50    60    70    80    90   100
   20    40    60    80   100   120   140   160   180   200
   30    60    90   120   150   180   210   240   270   300
   40    80   120   160   200   240   280   320   360   400
   50   100   150   200   250   300   350   400   450   500
   60   120   180   240   300   360   420
-----------------------------------------------------------
  100   200   300   400   500   600   700   800   900  1000
  200   400   600   800  1000  1200  1400  1600  1800  2000
  300   600   900  1200  1500  1800  2100  2400  2700  3000
  400   800  1200  1600  2000  2400  2800  3200  3600  4000
  500  1000  1500  2000  2500  3000  3500  4000  4500  5000
  600  1200  1800  2400  3000  3600  4200
-----------------------------------------------------------
</pre>



<p><a name="k19"></a></p>
<h2 id="k19">19. Repositář s&nbsp;demonstračními příklady</h2>

<p>Demonstrační příklady vytvořené pro nejnovější verzi programovacího jazyka
C3 byly uloženy do repositáře dostupného na adrese <a
href="https://github.com/tisnik/c3-examples">https://github.com/tisnik/c3-examples</a>.
Následují odkazy na jednotlivé příklady (či jejich nedokončené části).</p>

<p>Demonstrační příklady <a
href="https://www.root.cz/clanky/programovaci-jazyk-c3-evoluce-nikoli-revoluce/">z&nbsp;prvního
článku o jazyku C3</a>:</p>

<table>
<tr><th> #</th><th>Příklad</th><th>Stručný popis</th><th>Adresa</th></tr>
<tr><td> 1</td><td>factorial.c3</td><td>realizace výpočtu faktoriálu</td><td><a href="https://github.com/tisnik/c3-examples/blob/master/introduction/factorial.c3">https://github.com/tisnik/c3-examples/blob/master/introduction/factorial.c3</a></td></tr>
<tr><td> 2</td><td>factorial_macro.c3</td><td>výpočet faktoriálu konkrétní hodnoty implementovaný formou makra</td><td><a href="https://github.com/tisnik/c3-examples/blob/master/introduction/factorial_macro.c3">https://github.com/tisnik/c3-examples/blob/master/introduction/factorial_macro.c3</a></td></tr>
<tr><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td></tr>
<tr><td> 3</td><td>swap_macro.c3</td><td>makro realizující prohození dvou hodnot</td><td><a href="https://github.com/tisnik/c3-examples/blob/master/introduction/swap_macro.c3">https://github.com/tisnik/c3-examples/blob/master/introduction/swap_macro.c3</a></td></tr>
<tr><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td></tr>
<tr><td> 4</td><td>renderer.c</td><td>výpočet a vykreslení Juliovy množiny implementovaný v&nbsp;jazyku C</td><td><a href="https://github.com/tisnik/c3-examples/blob/master/introduction/renderer.c">https://github.com/tisnik/c3-examples/blob/master/introduction/renderer.c</a></td></tr>
<tr><td> 5</td><td>renderer_v1.c3</td><td>definice datové struktury s&nbsp;rozměry rastrového obrázku a skeleton všech funkcí</td><td><a href="https://github.com/tisnik/c3-examples/blob/master/introduction/renderer_v1.c3">https://github.com/tisnik/c3-examples/blob/master/introduction/renderer_v1.c3</a></td></tr>
<tr><td> 6</td><td>renderer_v2.c3</td><td>anotace parametrů funkcí typu ukazatel (<i>pointer</i>)</td><td><a href="https://github.com/tisnik/c3-examples/blob/master/introduction/renderer_v2.c3">https://github.com/tisnik/c3-examples/blob/master/introduction/renderer_v2.c3</a></td></tr>
<tr><td> 7</td><td>renderer_v3.c3</td><td>statická kontrola, zda se nepředávají neinicializované ukazatele</td><td><a href="https://github.com/tisnik/c3-examples/blob/master/introduction/renderer_v3.c3">https://github.com/tisnik/c3-examples/blob/master/introduction/renderer_v3.c3</a></td></tr>
<tr><td> 8</td><td>renderer_v4.c3</td><td>runtime kontrola, zda se nepředávají neinicializované ukazatele</td><td><a href="https://github.com/tisnik/c3-examples/blob/master/introduction/renderer_v4.c3">https://github.com/tisnik/c3-examples/blob/master/introduction/renderer_v4.c3</a></td></tr>
<tr><td> 9</td><td>renderer_v5.c3</td><td>první (nekorektní) varianta funkce pro inicializaci barvové palety</td><td><a href="https://github.com/tisnik/c3-examples/blob/master/introduction/renderer_v5.c3">https://github.com/tisnik/c3-examples/blob/master/introduction/renderer_v5.c3</a></td></tr>
<tr><td>10</td><td>renderer_v6.c3</td><td>druhá (korektní) varianta funkce pro inicializaci barvové palety</td><td><a href="https://github.com/tisnik/c3-examples/blob/master/introduction/renderer_v6.c3">https://github.com/tisnik/c3-examples/blob/master/introduction/renderer_v6.c3</a></td></tr>
<tr><td>11</td><td>renderer_v7.c3</td><td>volání knihovní I/O funkce a volání nativní céčkovské funkce</td><td><a href="https://github.com/tisnik/c3-examples/blob/master/introduction/renderer_v7.c3">https://github.com/tisnik/c3-examples/blob/master/introduction/renderer_v7.c3</a></td></tr>
<tr><td>12</td><td>renderer_v8.c3</td><td>plně funkční program pro výpočet a vykreslení Juliovy množiny</td><td><a href="https://github.com/tisnik/c3-examples/blob/master/introduction/renderer_v8.c3">https://github.com/tisnik/c3-examples/blob/master/introduction/renderer_v8.c3</a></td></tr>
</table>

<p>Demonstrační příklady <a
href="https://www.root.cz/clanky/programovaci-jazyk-c3-datove-typy-pro-moderni-architektury/">ze
druhého článku o jazyku C3</a>:</p>

<table>
<tr><th> #</th><th>Příklad</th><th>Stručný popis</th><th>Adresa</th></tr>
<tr><td>13</td><td>01_just_main.c3</td><td>struktura nejjednoduššího programu obsahujícího pouze prázdnou funkci <strong>main</strong></td><td><a href="https://github.com/tisnik/c3-examples/blob/master/c3-basics/01_just_main.c3">https://github.com/tisnik/c3-examples/blob/master/c3-basics/01_just_main.c3</a></td></tr>
<tr><td>14</td><td>02_module_name.c3</td><td>struktura programu s&nbsp;uvedeným plným jménem modulu</td><td><a href="https://github.com/tisnik/c3-examples/blob/master/c3-basics/02_module_name.c3">https://github.com/tisnik/c3-examples/blob/master/c3-basics/02_module_name.c3</a></td></tr>
<tr><td>15</td><td>03_hello_world.c3</td><td>klasický program typu &bdquo;Hello, world!&ldquo; napsaný v&nbsp;jazyku C3</td><td><a href="https://github.com/tisnik/c3-examples/blob/master/c3-basics/03_hello_world.c3">https://github.com/tisnik/c3-examples/blob/master/c3-basics/03_hello_world.c3</a></td></tr>
<tr><td>16</td><td>04_exit_value.c3</td><td>ukončení procesu s&nbsp;předáním návratového kódu zpět volajícímu programu</td><td><a href="https://github.com/tisnik/c3-examples/blob/master/c3-basics/04_exit_value.c3">https://github.com/tisnik/c3-examples/blob/master/c3-basics/04_exit_value.c3</a></td></tr>
<tr><td>17</td><td>05_c_function.c3</td><td>zavolání funkce definované v&nbsp;knihovně programovacího jazyka C</td><td><a href="https://github.com/tisnik/c3-examples/blob/master/c3-basics/05_c_function.c3">https://github.com/tisnik/c3-examples/blob/master/c3-basics/05_c_function.c3</a></td></tr>
<tr><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td></tr>
<tr><td>18</td><td>06_bool_type.c3</td><td>definice proměnných typu <i>pravdivostní hodnota</i> (<strong>bool</strong>)</td><td><a href="https://github.com/tisnik/c3-examples/blob/master/c3-basics/06_bool_type.c3">https://github.com/tisnik/c3-examples/blob/master/c3-basics/06_bool_type.c3</a></td></tr>
<tr><td>19</td><td>07_int_to_bool.c3</td><td>implicitní převod hodnoty typu <strong>int</strong> na pravdivostní hodnotu (nekorektní řešení)</td><td><a href="https://github.com/tisnik/c3-examples/blob/master/c3-basics/07_int_to_bool.c3">https://github.com/tisnik/c3-examples/blob/master/c3-basics/07_int_to_bool.c3</a></td></tr>
<tr><td>20</td><td>08_int_to_bool.c3</td><td>explicitní převod hodnoty typu <strong>int</strong> na pravdivostní hodnotu (korektní řešení)</td><td><a href="https://github.com/tisnik/c3-examples/blob/master/c3-basics/08_int_to_bool.c3">https://github.com/tisnik/c3-examples/blob/master/c3-basics/08_int_to_bool.c3</a></td></tr>
<tr><td>21</td><td>09_int_to_bool.c3</td><td>explicitní převod hodnoty typu <strong>int</strong> na pravdivostní hodnotu (nekorektní řešení)</td><td><a href="https://github.com/tisnik/c3-examples/blob/master/c3-basics/09_int_to_bool.c3">https://github.com/tisnik/c3-examples/blob/master/c3-basics/09_int_to_bool.c3</a></td></tr>
<tr><td>22</td><td>10_bool_sizeof.c3</td><td>zjištění velikosti paměti obsazené hodnotou typu <strong>bool</strong></td><td><a href="https://github.com/tisnik/c3-examples/blob/master/c3-basics/10_bool_sizeof.c3">https://github.com/tisnik/c3-examples/blob/master/c3-basics/10_bool_sizeof.c3</a></td></tr>
<tr><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td></tr>
<tr><td>23</td><td>11_int_types.c3</td><td>definice proměnných typu <i>celé číslo se znaménkem</i> s&nbsp;různou bitovou šířkou</td><td><a href="https://github.com/tisnik/c3-examples/blob/master/c3-basics/11_int_types.c3">https://github.com/tisnik/c3-examples/blob/master/c3-basics/11_int_types.c3</a></td></tr>
<tr><td>24</td><td>12_uint_types.c3</td><td>definice proměnných typu <i>celé číslo bez znaménka</i> s&nbsp;různou bitovou šířkou</td><td><a href="https://github.com/tisnik/c3-examples/blob/master/c3-basics/12_uint_types.c3">https://github.com/tisnik/c3-examples/blob/master/c3-basics/12_uint_types.c3</a></td></tr>
<tr><td>25</td><td>13_no_suffixes.c3</td><td>celočíselné konstanty bez uvedení suffixu (bitové šířky)</td><td><a href="https://github.com/tisnik/c3-examples/blob/master/c3-basics/13_no_suffixes.c3">https://github.com/tisnik/c3-examples/blob/master/c3-basics/13_no_suffixes.c3</a></td></tr>
<tr><td>26</td><td>14_suffixes.c3</td><td>celočíselné konstanty s&nbsp;uvedením sufficu (bitové šířky)</td><td><a href="https://github.com/tisnik/c3-examples/blob/master/c3-basics/14_suffixes.c3">https://github.com/tisnik/c3-examples/blob/master/c3-basics/14_suffixes.c3</a></td></tr>
<tr><td>27</td><td>15_int_sizeof.c3</td><td>zjištění velikosti paměti obsazené celočíselnými hodnotami se znaménkem</td><td><a href="https://github.com/tisnik/c3-examples/blob/master/c3-basics/15_int_sizeof.c3">https://github.com/tisnik/c3-examples/blob/master/c3-basics/15_int_sizeof.c3</a></td></tr>
<tr><td>28</td><td>16_uint_sizeof.c3</td><td>zjištění velikosti paměti obsazené celočíselnými hodnotami bez znaménka</td><td><a href="https://github.com/tisnik/c3-examples/blob/master/c3-basics/16_uint_sizeof.c3">https://github.com/tisnik/c3-examples/blob/master/c3-basics/16_uint_sizeof.c3</a></td></tr>
<tr><td>29</td><td>17_int_conversions.c3</td><td>korektní převody mezi celočíselnými hodnotami s&nbsp;různou bitovou šířkou</td><td><a href="https://github.com/tisnik/c3-examples/blob/master/c3-basics/17_int_conversions.c3">https://github.com/tisnik/c3-examples/blob/master/c3-basics/17_int_conversions.c3</a></td></tr>
<tr><td>30</td><td>18_int_conversions.c3</td><td>nekorektní převody mezi celočíselnými hodnotami s&nbsp;různou bitovou šířkou</td><td><a href="https://github.com/tisnik/c3-examples/blob/master/c3-basics/18_int_conversions.c3">https://github.com/tisnik/c3-examples/blob/master/c3-basics/18_int_conversions.c3</a></td></tr>
<tr><td>31</td><td>19_int_conversions.c3</td><td>explicitní převody a přetečení hodnot</td><td><a href="https://github.com/tisnik/c3-examples/blob/master/c3-basics/19_int_conversions.c3">https://github.com/tisnik/c3-examples/blob/master/c3-basics/19_int_conversions.c3</a></td></tr>
<tr><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td></tr>
<tr><td>32</td><td>20_float_types.c3</td><td>definice proměnných typu <i>numerická hodnota s&nbsp;plovoucí řádovou čárkou (tečkou)</i></td><td><a href="https://github.com/tisnik/c3-examples/blob/master/c3-basics/20_float_types.c3">https://github.com/tisnik/c3-examples/blob/master/c3-basics/20_float_types.c3</a></td></tr>
<tr><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td></tr>
<tr><td>33</td><td>21_vector_type.c3</td><td>definice vektoru obsahujícího celočíselné hodnoty</td><td><a href="https://github.com/tisnik/c3-examples/blob/master/c3-basics/21_vector_type.c3">https://github.com/tisnik/c3-examples/blob/master/c3-basics/21_vector_type.c3</a></td></tr>
<tr><td>34</td><td>22_vector_operations.c3</td><td>základní operace s&nbsp;celými vektory</td><td><a href="https://github.com/tisnik/c3-examples/blob/master/c3-basics/22_vector_operations.c3">https://github.com/tisnik/c3-examples/blob/master/c3-basics/22_vector_operations.c3</a></td></tr>
<tr><td>35</td><td>23_vector_sizes.c3</td><td>zjištění a tisk velikosti vektorů (různé datové typy prvků vektorů, shodná délka)</td><td><a href="https://github.com/tisnik/c3-examples/blob/master/c3-basics/23_vector_sizes.c3">https://github.com/tisnik/c3-examples/blob/master/c3-basics/23_vector_sizes.c3</a></td></tr>
<tr><td>36</td><td>24_vector_sizes.c3</td><td>zjištění a tisk velikosti vektorů (stejné datové typy prvků vektorů, odlišná délka)</td><td><a href="https://github.com/tisnik/c3-examples/blob/master/c3-basics/24_vector_sizes.c3">https://github.com/tisnik/c3-examples/blob/master/c3-basics/24_vector_sizes.c3</a></td></tr>
</table>

<p>Demonstrační příklady z&nbsp;předchozího článku o jazyku C3:</p>

<table>
<tr><th> #</th><th>Příklad</th><th>Stručný popis</th><th>Adresa</th></tr>
<tr><td>37</td><td>01_vector_type.c3</td><td>definice vektoru, modifikace prvků vektoru, tisk obsahu celého vektoru</td><td><a href="https://github.com/tisnik/c3-examples/blob/master/c3-containers/01_vector_type.c3">https://github.com/tisnik/c3-examples/blob/master/c3-containers/01_vector_type.c3</a></td></tr>
<tr><td>38</td><td>02_vector_parameter.c3</td><td>předání vektoru do funkce hodnotou</td><td><a href="https://github.com/tisnik/c3-examples/blob/master/c3-containers/02_vector_parameter.c3">https://github.com/tisnik/c3-examples/blob/master/c3-containers/02_vector_parameter.c3</a></td></tr>
<tr><td>39</td><td>03_vector_pointer.c3</td><td>předání vektoru do funkce odkazem (přes ukazatel)</td><td><a href="https://github.com/tisnik/c3-examples/blob/master/c3-containers/03_vector_pointer.c3">https://github.com/tisnik/c3-examples/blob/master/c3-containers/03_vector_pointer.c3</a></td></tr>
<tr><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td></tr>
<tr><td>40</td><td>04_array_type.c3</td><td>definice pole, modifikace prvků pole, tisk obsahu celého pole</td><td><a href="https://github.com/tisnik/c3-examples/blob/master/c3-containers/04_array_type.c3">https://github.com/tisnik/c3-examples/blob/master/c3-containers/04_array_type.c3</a></td></tr>
<tr><td>41</td><td>05_array_parameter.c3</td><td>předání pole do funkce hodnotou</td><td><a href="https://github.com/tisnik/c3-examples/blob/master/c3-containers/05_array_parameter.c3">https://github.com/tisnik/c3-examples/blob/master/c3-containers/05_array_parameter.c3</a></td></tr>
<tr><td>42</td><td>06_array_pointer.c3</td><td>předání pole do funkce odkazem (přes ukazatel)</td><td><a href="https://github.com/tisnik/c3-examples/blob/master/c3-containers/06_array_pointer.c3">https://github.com/tisnik/c3-examples/blob/master/c3-containers/06_array_pointer.c3</a></td></tr>
<tr><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td></tr>
<tr><td>43</td><td>07_slice_type.c3</td><td>vytvoření (konstrukce) řezu (<i>slice</i>)</td><td><a href="https://github.com/tisnik/c3-examples/blob/master/c3-containers/07_slice_type.c3">https://github.com/tisnik/c3-examples/blob/master/c3-containers/07_slice_type.c3</a></td></tr>
<tr><td>44</td><td>08_slice_parameter.c3</td><td>předání řezu do funkce</td><td><a href="https://github.com/tisnik/c3-examples/blob/master/c3-containers/08_slice_parameter.c3">https://github.com/tisnik/c3-examples/blob/master/c3-containers/08_slice_parameter.c3</a></td></tr>
<tr><td>45</td><td>09_slice_slicing.c3</td><td>konstrukce řezu z&nbsp;pole stejně pojmenovanou operací (řez od..do)</td><td><a href="https://github.com/tisnik/c3-examples/blob/master/c3-containers/09_slice_slicing.c3">https://github.com/tisnik/c3-examples/blob/master/c3-containers/09_slice_slicing.c3</a></td></tr>
<tr><td>46</td><td>10_slice_slicing.c3</td><td>konstrukce řezu z&nbsp;pole stejně pojmenovanou operací (záporné indexy)</td><td><a href="https://github.com/tisnik/c3-examples/blob/master/c3-containers/10_slice_slicing.c3">https://github.com/tisnik/c3-examples/blob/master/c3-containers/10_slice_slicing.c3</a></td></tr>
<tr><td>47</td><td>11_slice_slicing.c3</td><td>konstrukce řezu z&nbsp;pole stejně pojmenovanou operací (určení délky řezu)</td><td><a href="https://github.com/tisnik/c3-examples/blob/master/c3-containers/11_slice_slicing.c3">https://github.com/tisnik/c3-examples/blob/master/c3-containers/11_slice_slicing.c3</a></td></tr>
<tr><td>48</td><td>12_slice_of_slice.c3</td><td>konstrukce řezu z&nbsp;jiného řezu</td><td><a href="https://github.com/tisnik/c3-examples/blob/master/c3-containers/12_slice_of_slice.c3">https://github.com/tisnik/c3-examples/blob/master/c3-containers/12_slice_of_slice.c3</a></td></tr>
<tr><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td></tr>
<tr><td>49</td><td>13_list_type.c3</td><td>vytvoření (konstrukce) seznamu</td><td><a href="https://github.com/tisnik/c3-examples/blob/master/c3-containers/13_list_type.c3">https://github.com/tisnik/c3-examples/blob/master/c3-containers/13_list_type.c3</a></td></tr>
<tr><td>50</td><td>14_list_parameter.c3</td><td>předání seznamu do funkce</td><td><a href="https://github.com/tisnik/c3-examples/blob/master/c3-containers/14_list_parameter.c3">https://github.com/tisnik/c3-examples/blob/master/c3-containers/14_list_parameter.c3</a></td></tr>
<tr><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td></tr>
<tr><td>51</td><td>15_dynamic_array.c3</td><td>vytvoření (konstrukce) dynamicky alokovaného pole</td><td><a href="https://github.com/tisnik/c3-examples/blob/master/c3-containers/15_dynamic_array.c3">https://github.com/tisnik/c3-examples/blob/master/c3-containers/15_dynamic_array.c3</a></td></tr>
<tr><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td></tr>
<tr><td>52</td><td>16_string_type.c3</td><td>základní typ řetězce <strong>string</strong></td><td><a href="https://github.com/tisnik/c3-examples/blob/master/c3-containers/16_string_type.c3">https://github.com/tisnik/c3-examples/blob/master/c3-containers/16_string_type.c3</a></td></tr>
<tr><td>53</td><td>17_string_unicode.c3</td><td>Unicode znaky v&nbsp;řetězci typu <strong>string</strong></td><td><a href="https://github.com/tisnik/c3-examples/blob/master/c3-containers/17_string_unicode.c3">https://github.com/tisnik/c3-examples/blob/master/c3-containers/17_string_unicode.c3</a></td></tr>
<tr><td>54</td><td>18_zstring_type.c3</td><td>řetězce ukončené nulou (C-string, ASCIIZ)</td><td><a href="https://github.com/tisnik/c3-examples/blob/master/c3-containers/18_zstring_type.c3">https://github.com/tisnik/c3-examples/blob/master/c3-containers/18_zstring_type.c3</a></td></tr>
<tr><td>55</td><td>19_zstring_unicode.c3</td><td>Unicode znaky v&nbsp;řetězci typu <strong>zstring</strong></td><td><a href="https://github.com/tisnik/c3-examples/blob/master/c3-containers/19_zstring_unicode.c3">https://github.com/tisnik/c3-examples/blob/master/c3-containers/19_zstring_unicode.c3</a></td></tr>
<tr><td>56</td><td>20_string_comparison.c3</td><td>porovnávání obsahu řetězců</td><td><a href="https://github.com/tisnik/c3-examples/blob/master/c3-containers/20_string_comparison.c3">https://github.com/tisnik/c3-examples/blob/master/c3-containers/20_string_comparison.c3</a></td></tr>
</table>

<p>Demonstrační příklady z&nbsp;dnešního článku o jazyku C3:</p>

<table>
<tr><th> #</th><th>Příklad</th><th>Stručný popis</th><th>Adresa</th></tr>
<tr><td>57</td><td>01_program_stub.c3</td><td>struktura programu s&nbsp;uvedeným plným jménem modulu</td><td><a href="https://github.com/tisnik/c3-examples/blob/master/c3-control-flow/01_program_stub.c3">https://github.com/tisnik/c3-examples/blob/master/c3-control-flow/01_program_stub.c3</a></td></tr>
<tr><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td></tr>
<tr><td>58</td><td>02_if.c3</td><td>nejjednodušší forma rozvětvení založené na konstrukci <strong>if</strong></td><td><a href="https://github.com/tisnik/c3-examples/blob/master/c3-control-flow/02_if.c3">https://github.com/tisnik/c3-examples/blob/master/c3-control-flow/02_if.c3</a></td></tr>
<tr><td>59</td><td>03_if_else.c3</td><td>plné rozvětvení realizované konstrukcí <strong>if-else</strong></td><td><a href="https://github.com/tisnik/c3-examples/blob/master/c3-control-flow/03_if_else.c3">https://github.com/tisnik/c3-examples/blob/master/c3-control-flow/03_if_else.c3</a></td></tr>
<tr><td>60</td><td>04_improper_if.c3</td><td>nekorektní způsob zápisu programové konstrukce <strong>if-else</strong> (porovnání s&nbsp;jazykem C)</td><td><a href="https://github.com/tisnik/c3-examples/blob/master/c3-control-flow/04_improper_if.c3">https://github.com/tisnik/c3-examples/blob/master/c3-control-flow/04_improper_if.c3</a></td></tr>
<tr><td>61</td><td>05_improper_if.c3</td><td>nekorektní způsob zápisu programové konstrukce <strong>if-else</strong> (porovnání s&nbsp;jazykem C)</td><td><a href="https://github.com/tisnik/c3-examples/blob/master/c3-control-flow/05_improper_if.c3">https://github.com/tisnik/c3-examples/blob/master/c3-control-flow/05_improper_if.c3</a></td></tr>
<tr><td>62</td><td>06_if_else_if.c3</td><td>složitější rozvětvení založené na programové konstrukci <strong>if-else if-else</strong></td><td><a href="https://github.com/tisnik/c3-examples/blob/master/c3-control-flow/06_if_else_if.c3">https://github.com/tisnik/c3-examples/blob/master/c3-control-flow/06_if_else_if.c3</a></td></tr>
<tr><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td></tr>
<tr><td>63</td><td>07_switch_basic.c3</td><td>základní forma vícenásobného rozvětvení založeného na konstrukci <strong>switch-case</strong></td><td><a href="https://github.com/tisnik/c3-examples/blob/master/c3-control-flow/07_switch_basic.c3">https://github.com/tisnik/c3-examples/blob/master/c3-control-flow/07_switch_basic.c3</a></td></tr>
<tr><td>64</td><td>08_switch_basic.c3</td><td>větší množství podmínek a programová konstrukce <strong>switch-case</strong></td><td><a href="https://github.com/tisnik/c3-examples/blob/master/c3-control-flow/08_switch_basic.c3">https://github.com/tisnik/c3-examples/blob/master/c3-control-flow/08_switch_basic.c3</a></td></tr>
<tr><td>65</td><td>09_switch_condition.c3</td><td>podmínky zapsané ve větvích programové konstrukci <strong>switch-case</strong> vyhodnocované v&nbsp;čase běhu procesu</td><td><a href="https://github.com/tisnik/c3-examples/blob/master/c3-control-flow/09_switch_condition.c3">https://github.com/tisnik/c3-examples/blob/master/c3-control-flow/09_switch_condition.c3</a></td></tr>
<tr><td>66</td><td>10_switch_true.c3</td><td>konstrukce <strong>switch-case</strong> bez uvedeného výrazu za klíčovým slovem <strong>switch</strong></td><td><a href="https://github.com/tisnik/c3-examples/blob/master/c3-control-flow/10_switch_true.c3">https://github.com/tisnik/c3-examples/blob/master/c3-control-flow/10_switch_true.c3</a></td></tr>
<tr><td>67</td><td>11_switch_break.c3</td><td>zápis prázdné větve <strong>default</strong> v&nbsp;programové konstrukci <strong>switch-case</strong></td><td><a href="https://github.com/tisnik/c3-examples/blob/master/c3-control-flow/11_switch_break.c3">https://github.com/tisnik/c3-examples/blob/master/c3-control-flow/11_switch_break.c3</a></td></tr>
<tr><td>68</td><td>12_switch_nextcase.c3</td><td>pokračování ve vykonávání konstrukce <strong>switch-case</strong> vynucené klíčovým slovem <strong>nextcase</strong></td><td><a href="https://github.com/tisnik/c3-examples/blob/master/c3-control-flow/12_switch_nextcase.c3">https://github.com/tisnik/c3-examples/blob/master/c3-control-flow/12_switch_nextcase.c3</a></td></tr>
<tr><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td></tr>
<tr><td>69</td><td>13_for_loop.c3</td><td>základní forma programové smyčky realizované klíčovým slovem <strong>for</strong></td><td><a href="https://github.com/tisnik/c3-examples/blob/master/c3-control-flow/13_for_loop.c3">https://github.com/tisnik/c3-examples/blob/master/c3-control-flow/13_for_loop.c3</a></td></tr>
<tr><td>70</td><td>14_foreach_loop.c3</td><td>základní forma programové smyčky typu <strong>for-each</strong></td><td><a href="https://github.com/tisnik/c3-examples/blob/master/c3-control-flow/14_foreach_loop.c3">https://github.com/tisnik/c3-examples/blob/master/c3-control-flow/14_foreach_loop.c3</a></td></tr>
<tr><td>71</td><td>15_foreach_loop.c3</td><td>programová smyčka <strong>for-each</strong> vracející index prvku i hodnotu prvku</td><td><a href="https://github.com/tisnik/c3-examples/blob/master/c3-control-flow/15_foreach_loop.c3">https://github.com/tisnik/c3-examples/blob/master/c3-control-flow/15_foreach_loop.c3</a></td></tr>
<tr><td>72</td><td>16_foreach_loop.c3</td><td>modifikace obsahu pole v&nbsp;programové smyčce <strong>for-each</strong></td><td><a href="https://github.com/tisnik/c3-examples/blob/master/c3-control-flow/16_foreach_loop.c3">https://github.com/tisnik/c3-examples/blob/master/c3-control-flow/16_foreach_loop.c3</a></td></tr>
<tr><td>73</td><td>17_foreach_loop.c3</td><td>pokus o modifikaci obsahu procházeného pole</td><td><a href="https://github.com/tisnik/c3-examples/blob/master/c3-control-flow/17_foreach_loop.c3">https://github.com/tisnik/c3-examples/blob/master/c3-control-flow/17_foreach_loop.c3</a></td></tr>
<tr><td>74</td><td>18_foreach_loop.c3</td><td>modifikace procházeného pole přes ukazatel na prvek</td><td><a href="https://github.com/tisnik/c3-examples/blob/master/c3-control-flow/18_foreach_loop.c3">https://github.com/tisnik/c3-examples/blob/master/c3-control-flow/18_foreach_loop.c3</a></td></tr>
<tr><td>75</td><td>19_foreach_r_loop.c3</td><td>programová smyčka <strong>for-each</strong>, ve které se sekvencí prochází v&nbsp;opačném pořadí</td><td><a href="https://github.com/tisnik/c3-examples/blob/master/c3-control-flow/19_foreach_r_loop.c3">https://github.com/tisnik/c3-examples/blob/master/c3-control-flow/19_foreach_r_loop.c3</a></td></tr>
<tr><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td></tr>
<tr><td>76</td><td>20_while_loop.c3</td><td>základní forma programové smyčky typu <strong>while</strong></td><td><a href="https://github.com/tisnik/c3-examples/blob/master/c3-control-flow/20_while_loop.c3">https://github.com/tisnik/c3-examples/blob/master/c3-control-flow/20_while_loop.c3</a></td></tr>
<tr><td>77</td><td>21_while_loop_2.c3</td><td>programová smyčka typu <strong>while</strong> s&nbsp;konstrukcí <strong>break</strong></td><td><a href="https://github.com/tisnik/c3-examples/blob/master/c3-control-flow/21_while_loop_2.c3">https://github.com/tisnik/c3-examples/blob/master/c3-control-flow/21_while_loop_2.c3</a></td></tr>
<tr><td>78</td><td>22_nested_loops.c3</td><td>realizace vnořených programových smyček</td><td><a href="https://github.com/tisnik/c3-examples/blob/master/c3-control-flow/22_nested_loops.c3">https://github.com/tisnik/c3-examples/blob/master/c3-control-flow/22_nested_loops.c3</a></td></tr>
<tr><td>79</td><td>23_break.c3</td><td>vnořené programové smyčky a příkaz <strong>break</strong>: ukončení vnitřní smyčky</td><td><a href="https://github.com/tisnik/c3-examples/blob/master/c3-control-flow/23_break.c3">https://github.com/tisnik/c3-examples/blob/master/c3-control-flow/23_break.c3</a></td></tr>
<tr><td>80</td><td>24_break.c3</td><td>vnořené programové smyčky a příkaz <strong>break</strong>: ukončení vnější smyčky</td><td><a href="https://github.com/tisnik/c3-examples/blob/master/c3-control-flow/24_break.c3">https://github.com/tisnik/c3-examples/blob/master/c3-control-flow/24_break.c3</a></td></tr>
<tr><td>81</td><td>25_break.c3</td><td>vnořené programové smyčky a příkaz <strong>break</strong>, varianta se smyčkami typu <strong>while</strong></td><td><a href="https://github.com/tisnik/c3-examples/blob/master/c3-control-flow/25_break.c3">https://github.com/tisnik/c3-examples/blob/master/c3-control-flow/25_break.c3</a></td></tr>
</table>



<p><a name="k20"></a></p>
<h2 id="k20">20. Odkazy na Internetu</h2>

<ol>

<li>Programovací jazyk C3: evoluce, nikoli revoluce<br />
<a href="https://www.root.cz/clanky/programovaci-jazyk-c3-evoluce-nikoli-revoluce/">https://www.root.cz/clanky/programovaci-jazyk-c3-evoluce-nikoli-revoluce/</a>
</li>

<li>Programovací jazyk C3: datové typy pro moderní architektury<br />
<a href="https://www.root.cz/clanky/programovaci-jazyk-c3-datove-typy-pro-moderni-architektury/">https://www.root.cz/clanky/programovaci-jazyk-c3-datove-typy-pro-moderni-architektury/</a>
</li>

<li>Programovací jazyk C3: složené datové typy a kontejnery<br />
<a href="https://www.root.cz/clanky/programovaci-jazyk-c3-slozene-datove-typy-a-kontejnery/">https://www.root.cz/clanky/programovaci-jazyk-c3-slozene-datove-typy-a-kontejnery/</a>
</li>

<li>The C3 Programming Language<br />
<a href="https://c3-lang.org/">https://c3-lang.org/</a>
</li>

<li>C3 For C Programmers<br />
<a href="https://c3-lang.org/language-overview/primer/">https://c3-lang.org/language-overview/primer/</a>
</li>

<li>C3 is a C-like language trying to be an incremental improvement over C rather than a whole new language<br />
<a href="https://www.reddit.com/r/ProgrammingLanguages/comments/oohij6/c3_is_a_clike_language_trying_to_be_an/">https://www.reddit.com/r/ProgrammingLanguages/comments/oohij6/c3_is_a_clike_language_trying_to_be_an/</a>
</li>

<li>Tiobe index<br />
<a href="https://www.tiobe.com/tiobe-index/">https://www.tiobe.com/tiobe-index/</a>
</li>

<li>PYPL PopularitY of Programming Language<br />
<a href="https://pypl.github.io/PYPL.html">https://pypl.github.io/PYPL.html</a>
</li>

<li>C3 Tutorial<br />
<a href="https://learn-c3.org/">https://learn-c3.org/</a>
</li>

<li>History of programming languages<br />
<a href="https://devskiller.com/history-of-programming-languages/">https://devskiller.com/history-of-programming-languages/</a>
</li>

<li>History of programming languages (Wikipedia)<br />
<a href="https://en.wikipedia.org/wiki/History_of_programming_languages">https://en.wikipedia.org/wiki/History_of_programming_languages</a>
</li>

<li>D language<br />
<a href="https://dlang.org/">https://dlang.org/</a>
</li>

<li>Zig programming language<br />
<a href="https://ziglang.org/">https://ziglang.org/</a>
</li>

<li>V language<br />
<a href="https://vlang.io/">https://vlang.io/</a>
</li>

<li>D programming language<br />
<a href="https://en.wikipedia.org/wiki/D_(programming_language)">https://en.wikipedia.org/wiki/D_(programming_language)</a>
</li>

<li>Zig programming language (Wikipedia)<br />
<a href="https://en.wikipedia.org/wiki/Zig_(programming_language)">https://en.wikipedia.org/wiki/Zig_(programming_language)</a>
</li>

<li>V programming language (Wikipedia)<br />
<a href="https://en.wikipedia.org/wiki/V_(programming_language)">https://en.wikipedia.org/wiki/V_(programming_language)</a>
</li>

<li>Syntax highlighting for C3's programming language<br />
<a href="https://github.com/Airbus5717/c3.vim">https://github.com/Airbus5717/c3.vim</a>
</li>

<li>Go factorial<br />
<a href="https://gist.github.com/esimov/9622710">https://gist.github.com/esimov/9622710</a>
</li>

<li>Generational list of programming languages<br />
<a href="https://en.wikipedia.org/wiki/Generational_list_of_programming_languages">https://en.wikipedia.org/wiki/Generational_list_of_programming_languages</a>
</li>

<li>The Language Tree: Almost Every Programming Language Ever Made<br />
<a href="https://github.com/Phileosopher/langmap">https://github.com/Phileosopher/langmap</a>
</li>

<li>List of C-family programming languages<br />
<a href="https://en.wikipedia.org/wiki/List_of_C-family_programming_languages">https://en.wikipedia.org/wiki/List_of_C-family_programming_languages</a>
</li>

<li>Compatibility of C and C++<br />
<a href="https://en.wikipedia.org/wiki/Compatibility_of_C_and_C%2B%2B">https://en.wikipedia.org/wiki/Compatibility_of_C_and_C%2B%2B</a>
</li>

<li>C++23: compatibility with C<br />
<a href="https://www.sandordargo.com/blog/2023/08/23/cpp23-c-compatibility">https://www.sandordargo.com/blog/2023/08/23/cpp23-c-compatibility</a>
</li>

<li>Can C++ Run C Code? Understanding Language Compatibility<br />
<a href="https://www.codewithc.com/can-c-run-c-code-understanding-language-compatibility/">https://www.codewithc.com/can-c-run-c-code-understanding-language-compatibility/</a>
</li>

<li>C3: Comparisons With Other Languages<br />
<a href="https://c3-lang.org/faq/compare-languages/">https://c3-lang.org/faq/compare-languages/</a>
</li>

<li>C3 Programming Language Gains Traction as Modern C Alternative<br />
<a href="https://biggo.com/news/202504040125_C3_Programming_Language_Alternative_to_C">https://biggo.com/news/202504040125_C3_Programming_Language_Alternative_to_C</a>
</li>

<li>The case against a C alternative<br />
<a href="https://c3.handmade.network/blog/p/8486-the_case_against_a_c_alternative">https://c3.handmade.network/blog/p/8486-the_case_against_a_c_alternative</a>
</li>

<li>C (programming language) Alternatives<br />
<a href="https://alternativeto.net/software/c-programming-language-/">https://alternativeto.net/software/c-programming-language-/</a>
</li>

<li>Seriál Programovací jazyk Go<br />
<a href="https://www.root.cz/serialy/programovaci-jazyk-go/">https://www.root.cz/serialy/programovaci-jazyk-go/</a>
</li>

<li>Is C3 the Underdog That Will Overtake Zig and Odin?<br />
<a href="https://bitshifters.cc/2025/05/22/c3-c-tradition.html">https://bitshifters.cc/2025/05/22/c3-c-tradition.html</a>
</li>

<li>"Hello, World!" program<br />
<a href="https://en.wikipedia.org/wiki/%22Hello%2C_World!%22_program">https://en.wikipedia.org/wiki/%22Hello%2C_World!%22_program</a>
</li>

<li>The C Programming Language<br />
<a href="https://en.wikipedia.org/wiki/The_C_Programming_Language">https://en.wikipedia.org/wiki/The_C_Programming_Language</a>
</li>

<li>Kontejner (abstraktní datový typ)<br />
<a href="https://cs.wikipedia.org/wiki/Kontejner_(abstraktn%C3%AD_datov%C3%BD_typ)">https://cs.wikipedia.org/wiki/Kontejner_(abstraktn%C3%AD_datov%C3%BD_typ)</a>
</li>

<li>Are arrays not considered containers because they are not based off of a class?<br />
<a href="https://stackoverflow.com/questions/37710975/are-arrays-not-considered-containers-because-they-are-not-based-off-of-a-class">https://stackoverflow.com/questions/37710975/are-arrays-not-considered-containers-because-they-are-not-based-off-of-a-class</a>
</li>

<li>Array declaration (C, C++)<br />
<a href="https://en.cppreference.com/w/cpp/language/array.html">https://en.cppreference.com/w/cpp/language/array.html</a>
</li>

<li>Understanding the Apple ‘goto fail;’ vulnerability<br />
<a href="https://www.blackduck.com/blog/understanding-apple-goto-fail-vulnerability-2.html">https://www.blackduck.com/blog/understanding-apple-goto-fail-vulnerability-2.html</a>
</li>

<li>Branch (computer science)<br />
<a href="https://en.wikipedia.org/wiki/Branch_(computer_science)">https://en.wikipedia.org/wiki/Branch_(computer_science)</a>
</li>

<li>Conditional (computer programming)<br />
<a href="https://en.wikipedia.org/wiki/Conditional_(computer_programming)">https://en.wikipedia.org/wiki/Conditional_(computer_programming)</a>
</li>

<li>Dangling else<br />
<a href="https://en.wikipedia.org/wiki/Dangling_else">https://en.wikipedia.org/wiki/Dangling_else</a>
</li>

<li>Switch statement<br />
<a href="https://en.wikipedia.org/wiki/Switch_statement">https://en.wikipedia.org/wiki/Switch_statement</a>
</li>

</ol>



<p></p><p></p>
<p><small>Autor: <a href="https://github.com/tisnik/">Pavel Tišnovský</a> &nbsp; 2025</small></p>
</body>
</html>

