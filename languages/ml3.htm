<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
        "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html>
<head>
<title>Curryfikace (currying), výjimky a vlastní operátory v jazyku ML</title>
<meta name="Author" content="Pavel Tisnovsky" />
<meta name="Generator" content="vim" />
<meta http-equiv="content-type" content="text/html; charset=utf-8" />
<style type="text/css">
         body {color:#000000; background:#ffffff;}
         h1  {font-family: arial, helvetica, sans-serif; color:#ffffff; background-color:#c00000; text-align:center; padding-left:1em}
         h2  {font-family: arial, helvetica, sans-serif; color:#ffffff; background-color:#0000c0; padding-left:1em; text-align:left}
         h3  {font-family: arial, helvetica, sans-serif; color:#000000; background-color:#c0c0c0; padding-left:1em; text-align:left}
         h4  {font-family: arial, helvetica, sans-serif; color:#000000; background-color:#e0e0e0; padding-left:1em; text-align:left}
         a   {font-family: arial, helvetica, sans-serif;}
         li  {font-family: arial, helvetica, sans-serif; color:#000000; text-align:justify; width:450px;}
         ol  {font-family: arial, helvetica, sans-serif; color:#000000; text-align:justify; width:450px;}
         ul  {font-family: arial, helvetica, sans-serif; color:#000000; text-align:justify; width:450px;}
         p   {font-family: arial, helvetica, sans-serif; color:#000000; text-align:justify;}
         pre {background:#e0e0e0}
</style>
</head>

<body>

<h1>Curryfikace (currying), výjimky a vlastní operátory v jazyku ML</h1>

<h3>Pavel Tišnovský</h3>

<p></p>

<h1>Úvodník</h1>

<p>Ve třetím článku o jazyce ML si ukážeme některé poněkud pokročilejší techniky. Nejdříve se seznámíme s technikou curryfikace (curryingu), která je v ML podporována, podobně jako například v Haskellu. Dále si ukážeme použití bloku let, seznámíme se s konceptem výjimek i s tvorbou vlastních nových operátorů.</p>



<h2>Obsah</h2>

<p><a href="#k01">1. Curryfikace (currying) a částečně vyhodnocené funkce</a></p>
<p><a href="#k02">2. Malá odbočka &ndash; funkce přistupující k&nbsp;symbolům ve svém prostředí (environment)</a></p>
<p><a href="#k03">3. Praktické využití curryfikace</a></p>
<p><a href="#k04">4. Skutečný počet parametrů všech funkcí v&nbsp;jazyce ML</a></p>
<p><a href="#k05">5. Generování funkcí pro výpočet n-té mocniny</a></p>
<p><a href="#k06">6. Druhý pohled na funkci vyššího řádu <strong>map</strong></a></p>
<p><a href="#k07">7. Proměnné a prostředí</a></p>
<p><a href="#k08">8. Konstrukce <strong>let</strong></a></p>
<p><a href="#k09">9. Konstrukce <strong>let</strong> v&nbsp;těle funkce</a></p>
<p><a href="#k10">10. Blok příkazů (s&nbsp;vedlejším efektem)</a></p>
<p><a href="#k11">11. Koncept výjimek v&nbsp;jazyku ML</a></p>
<p><a href="#k12">12. Standardní operátory</a></p>
<p><a href="#k13">13. Zápis standardních operátorů</a></p>
<p><a href="#k14">14. Definice vlastních operátorů</a></p>
<p><a href="#k15">15. Změna priority a asociativity operátorů</a></p>
<p><a href="#k16">16. Obsah navazujícího článku</a></p>
<p><a href="#k17">17. Repositář s&nbsp;demonstračními příklady</a></p>
<p><a href="#k18">18. Literatura</a></p>
<p><a href="#k19">19. Odkazy na Internetu</a></p>



<p><a name="k01"></a></p>
<h2 id="k01">1. Curryfikace (currying) a částečně vyhodnocené funkce</h2>

<p><i>&bdquo;Typically, developers learn new languages by applying what they
know about existing languages. But learning a new paradigm is difficult &ndash;
you must learn to see different solutions to familiar problems.&ldquo;</i></p>

<p>V&nbsp;úvodní části dnešního článku si ukážeme, jakým způsobem se
v&nbsp;programovacím jazyku ML provádí takzvaná <i>curryfikace</i> (anglicky
<i>currying</i>). Pod tímto termínem se v&nbsp;teorii programovacích jazyků
(ovšem i obecně v&nbsp;matematice) označuje proces, jímž se transformuje
funkce, která má více než jeden parametr, do řady vložených funkcí, přičemž
každá z&nbsp;nich má jen jediný parametr. Curryfikaci si můžeme představit jako
postupnou transformaci funkce s&nbsp;<i>n</i> parametry na jinak zkonstruovanou
funkci s&nbsp;<i>n-1</i> parametry atd. až rekurzivně dojdeme k&nbsp;funkci
s&nbsp;jediným parametrem:</p>

<pre>
x = f(a,b,c) &rarr;
    h = g(a)
    i = h(b)
    x = i(c)
</pre>

<p>Nebo na jediném řádku:</p>

<pre>
x = f(a,b,c) &rarr; g(a)(b)(c)
</pre>

<p><div class="rs-tip-major">Poznámka: povšimněte si, že funkce
<strong>g</strong> a <strong>h</strong> musí vracet jiné funkce.</div></p>

<p>To zní sice velmi složitě, ale v&nbsp;praxi je (v&nbsp;ML, ale i dalších
jazycích) proces curryfikace realizován, jak uvidíme v&nbsp;dalším textu,
z&nbsp;pohledu programátora automaticky již samotným zápisem funkce
s&nbsp;větším množstvím parametrů. To nám umožňuje realizovat <i>částečné
vyhodnocení funkce</i> (<i>partial application)</i>, konkrétně zavoláním nějaké
funkce (například funkce akceptující dva parametry) ve skutečnosti pouze
s&nbsp;jediným parametrem. Jenže &ndash; co má být výsledkem volání takové
funkce? Určitě ne výsledek implementované operace, protože nám chybí jeden
parametr pro to, aby byl výsledek vypočten a vrácen volajícím kódu. Ovšem
můžeme provést částečný výpočet dosazením (jediného) předaného parametru a
výsledek &ndash; tento částečný výpočet &ndash; vrátit. Výsledkem je tedy
obecně částečně aplikovaná funkce (tedy například funkce, které byly
v&nbsp;předchozím příkladu označeny symboly <strong>g</strong> a
<strong>h</strong>). Jedná se o jeden ze způsobů, jak programově (za běhu
aplikace) vytvářet nové funkce.</p>

<p><div class="rs-tip-major">Poznámka: curryfikace/currying se tedy ve
skutečnosti poněkud liší od tvorby částečně aplikovaných funkcí (i když se
mnohdy oba termíny zaměňují, nebo používají současně, což je ostatně i případ
předchozího odstavce).</div></p>

<p><div class="rs-tip-major">Poznámka<sup>2</sup>: název <i>currying</i> je
odvozen od jména známého matematika Haskella Curryho, po kterém je ostatně
pojmenován i další programovací jazyk Haskell (ten se ML v&nbsp;mnoha ohledech
podobá, právě i v&nbsp;kontextu curryingu a s&nbsp;ním souvisejícím faktem, že
funkce akceptují jeden parametr). Ve skutečnosti však Haskell tento proces
nevymyslel. Za původní myšlenkou tohoto procesu stojí Moses Schönfinkel, takže
se uvažovalo, že se tento proces bude nazývat &bdquo;Schönfinkelisation&ldquo;.
To by bylo asi férovější, ovšem uznejte sami, že se nejedná o tak snadno
zapamatovatelný název, jakým je currying.</div></p>



<p><a name="k02"></a></p>
<h2 id="k02">2. Malá odbočka &ndash; funkce přistupující k&nbsp;symbolům ve svém prostředí (environment)</h2>

<p>Zkusme si tedy ukázat, jak je currying interně implementován. Nejprve si
ovšem ukážeme, že v&nbsp;programovacím jazyku ML je možné vytvářet funkce (ať
již anonymní či pojmenované), které budou akceptovat nějaké parametry, ovšem
navíc budou přistupovat k&nbsp;&bdquo;externím&ldquo; proměnným dostupným
z&nbsp;jejich prostředí (<i>environment</i>). Začneme jednoduchou anonymní
funkcí, která akceptuje jediný parametr <strong>b</strong>, ovšem provádí
výpočet <strong>a+b</strong>, jehož výsledek posléze vrací:</p>

<pre>
<strong>fn b =&gt; a + b;</strong>
</pre>

<p>Tuto funkci nelze zpracovat bez toho, aniž by byla v&nbsp;prostředí
(<i>environment</i>, viz dále) deklarována proměnná <strong>a</strong>, na což
nás překladač správně upozorní:</p>

<pre>
Elaboration failed: Unbound value identifier "a".
</pre>

<p><div class="rs-tip-major">Poznámka: konkrétní chybové hlášení závisí na
použitém dialektu jazyka ML, ovšem význam je zřejmý.</div></p>

<p>Proměnnou <strong>a</strong> však můžeme vytvořit, a to konstrukcí
<strong>val</strong>. V&nbsp;takovém případě je již možné anonymní funkci
zapsat, a to bez nahlášení chyby překladačem:</p>

<pre>
<strong>val a = 10;</strong>
&nbsp;
<strong>fn b =&gt; a + b;</strong>
</pre>

<p>Výsledkem bude hodnota s&nbsp;typem:</p>

<pre>
val it = fn: int → int;
</pre>

<p><div class="rs-tip-major">Poznámka: pro pochopení dalšího textu je užitečné
se naučit číst typ funkce. Zde se konkrétně jedná o funkci akceptující jediný
parametr typu <strong>int</strong> a vracející hodnotu typu
<strong>int</strong>.</div></p>

<p>Po vyhodnocení výrazu jsme sice získali hodnotu typu funkce, ovšem tato
hodnota byla pouze meziuložena do speciální proměnné <strong>it</strong> a bude
brzy ztracena vyhodnocením jakéhokoli dalšího výrazu:</p>

<pre>
<strong>it(100);</strong>
val it = 110: int;
</pre>

<p>Nic nám však nebrání si výsledek, tedy funkci, uložit do proměnné, a de
facto tak deklarovat pojmenovanou funkci:</p>

<pre>
<strong>val a = 10;</strong>
&nbsp;
<strong>val f = fn b =&gt; a + b;</strong>
</pre>

<p>Výsledkem je nyní proměnná <strong>f</strong> s&nbsp;typem:</p>

<pre>
val f = fn: int → int;
</pre>

<p>Z&nbsp;tohoto zápisu již víme, že se jedná o funkci s&nbsp;jediným
parametrem, kterou lze zavolat:</p>

<pre>
<strong>f(20);</strong>
val it = 30: int;
</pre>

<p>Popř.&nbsp;můžeme vytvořit anonymní funkci a ihned ji zavolat, to vše na
jediném řádku:</p>

<pre>
<strong>val a = 10;</strong>
&nbsp;
<strong>(fn b =&gt; a + b)(20);</strong>
val it = 30: int;
</pre>

<p>Nyní již víme, že funkce mohou využívat hodnoty proměnných, které jsou
dostupné z&nbsp;jejich prostředí. Co to konkrétně znamená, se dozvíme později,
ale v&nbsp;jednoduchosti se jedná o proměnné s&nbsp;hodnotou a typem známým
v&nbsp;době tvorby funkce (může se jednat o globální proměnné, parametry
funkce, v&nbsp;jejím rámci je nová funkce definována atd.).</p>



<p><a name="k03"></a></p>
<h2 id="k03">3. Praktické využití curryfikace</h2>

<p>Podívejme se nyní na následující definici funkce <strong>adder</strong>:</p>

<pre>
<strong>fun adder a = fn b =&gt; a + b;</strong>
val adder = fn: int → int → int;
</pre>

<p>Tato funkce je poměrně zajímavá, protože její návratovou hodnotou je další
funkce s&nbsp;jediným parametrem <strong>b</strong>, která provádí výpočet
<strong>a+b</strong> (viz návratový typ <i>fn: int → int → int</i> odvozený a
následně i zobrazený překladačem).</p>

<p><div class="rs-tip-major">Poznámka: operátor → má pravou asociativitu, což
znamená, že zápis <i>fn: int → int → int</i> můžeme číst jako <i>fn: int → (int
→ int)</i>. Mezi další operátory s&nbsp;pravou asociativitou patří operátory
pro spojení seznamů a řetězců: &bdquo;::&ldquo; a &bdquo;@&ldquo;.</div></p>

<p>Samotná funkce <strong>adder</strong> je tedy generátorem dalších funkcí,
které se budou lišit tím, jaký výsledek počítají, a to na základě parametru
<strong>a</strong>, jenž byl do funkce <strong>adder</strong> předán ve chvíli
generování nových funkcí. Pokusme se takové funkce vytvořit (vygenerovat):</p>

<pre>
<strong>val inc = adder 1;</strong>
<strong>val inc2 = adder 2;</strong>
</pre>

<p>V&nbsp;předchozím příkladu jsme si nechali vygenerovat dvojici nových funkcí
nazvaných <strong>inc</strong> a <strong>inc2</strong>, jejichž typy odvozené
překladačem jsou:</p>

<pre>
val inc = fn: int → int;
val inc2 = fn: int → int;
</pre>

<p>Jedná se tedy o &bdquo;běžné&ldquo; funkce s&nbsp;jediným parametrem (a
pochopitelně i návratovou hodnotou), které lze běžným způsobem zavolat:</p>

<pre>
<strong>inc 10;</strong>
val it = 11: int;
&nbsp;
<strong>inc2 10;</strong>
val it = 12: int;
</pre>

<p>Můžeme zde vidět, že každá z&nbsp;těchto funkcí provedla odlišný výpočet, a
to z&nbsp;toho důvodu, že si každá funkce pamatuje odlišnou hodnotu
<strong>a</strong> získanou při vytvoření těchto funkcí. Stále však platí, že
se jedná o referenčně transparentní funkce &ndash; jejich návratové hodnoty
plně závisí pouze na předaném parametru.</p>

<p>To však není vše a právě zde se dostáváme k&nbsp;curryingu.
V&nbsp;programovacím jazyce ML je důležité, že zápis funkce
<strong>adder</strong>, který jsme použili výše:</p>

<pre>
<strong>fun adder a = fn b =&gt; a + b;</strong>
val adder = fn: int → int → int;
</pre>

<p>...je možné přepsat do zjednodušené podoby:</p>

<pre>
<strong>fun adder a b = a + b;</strong>
val adder = fn: int → int → int;
</pre>

<p>Už z&nbsp;typů obou funkcí je zřejmé, že se jedná o totožnou sémantiku.
V&nbsp;případě, že vytvoříme novou funkci (nezávisle na tom, zda funkci
anonymní či pojmenovanou) s&nbsp;větším množstvím parametrů (než jeden) a
současně parametry nezapíšeme formou n-tice do kulatých závorek, provede
překladač currying zcela automaticky.</p>

<p><div class="rs-tip-major">Poznámka: &bdquo;běžná&ldquo; funkce se dvěma
parametry (ve skutečnosti s&nbsp;jedním parametrem typu n-tice), která má
sečíst dvě celočíselné hodnoty, vypadá takto:</div></p>

<pre>
<strong>fun adder(a, b) = a + b;</strong>
val adder = fn: int * int → int;
</pre>

<p>Už z&nbsp;typu funkce vypsaného překladačem je zřejmé, že se jedná o značně
odlišnou funkci.</p>



<p><a name="k04"></a></p>
<h2 id="k04">4. Skutečný počet parametrů všech funkcí v&nbsp;jazyce ML</h2>

<p>Na celý problém se můžeme podívat i naopak &ndash; lze říci, že takto
definované funkce s&nbsp;větším počtem parametrů se interně reprezentují funkcí
s&nbsp;jediným parametrem, které vrací jinou funkci, která na sebe naváže druhý
parametr (a tato funkce popř.&nbsp;vrací další funkci navazující třetí parametr
atd.). Můžeme si to vyzkoušet na curryfikované funkci se čtyřmi parametry:</p>

<pre>
<strong>fun foobar x y z w = x + y + z + w;</strong>
val foobar = fn: int → int → int → int → int;
</pre>

<p>Jedná se o generátor generátorů funkcí:</p>

<pre>
<strong>val f1 = foobar(1);</strong>
val f1 = fn: int → int → int → int;
&nbsp;
<strong>val f2 = f1(2);</strong>
val f2 = fn: int → int → int;
&nbsp;
<strong>val f3 = f2(3);</strong>
val f3 = fn: int → int;
&nbsp;
<strong>val f4 = f3(4);</strong>
val f4 = 10: int;
</pre>

<p>Alternativní způsob generování funkcí (různých typů) při použití
jednořádkového zápisu:</p>

<pre>
<strong>fun foobar x y z w = x + y + z + w;</strong>
val foobar = fn: int → int → int → int → int;
&nbsp;
<strong>val f12 = foobar(1)(2);</strong>
val f12 = fn: int → int → int;
&nbsp;
<strong>val f123 = foobar(1)(2)(3);</strong>
val f123 = fn: int → int;
&nbsp;
<strong>val f1234 = foobar(1)(2)(3)(4);</strong>
val f1234 = 10: int;
</pre>

<p>Ve skutečnosti ovšem můžeme závorky zcela vynechat:</p>

<pre>
<strong>fun foobar x y z w = x + y + z + w;</strong>
val foobar = fn: int → int → int → int → int;
&nbsp;
<strong>val f1 = foobar 1;</strong>
val f1 = fn: int → int → int → int;
&nbsp;
<strong>val f2 = f1 2;</strong>
val f2 = fn: int → int → int;
&nbsp;
<strong>val f3 = f2 3;</strong>
val f3 = fn: int → int;
&nbsp;
<strong>val f4 = f3 4;</strong>
val f4 = 10: int;
</pre>

<p>Ve druhém případě pak:</p>

<pre>
<strong>fun foobar x y z w = x + y + z + w;</strong>
val foobar = fn: int → int → int → int → int;
&nbsp;
<strong>val f12 = foobar 1 2;</strong>
val f12 = fn: int → int → int;
&nbsp;
<strong>val f123 = foobar 1 2 3;</strong>
val f123 = fn: int → int;
&nbsp;
<strong>val f1234 = foobar 1 2 3 4;</strong>
val f1234 = 10: int;
&nbsp;
</pre>

<p><div class="rs-tip-major">Poznámka: bližší vysvětlení, o jaké funkce se
jedná (jaké mají parametry a návratovou hodnotu) je zde zbytečné, neboť je to
patrné z&nbsp;jejich typu odvozeného překladačem.</div></p>



<p><a name="k05"></a></p>
<h2 id="k05">5. Generování funkcí pro výpočet n-té mocniny</h2>

<p>Currying lze využít například pro generování funkcí pro výpočet zvolené n-té
mocniny. Budeme přitom vycházet z&nbsp;rekurzivní funkce, která dokáže
vypočítat m<sup>n</sup> pro dvě celočíselné hodnoty <strong>m</strong> a
<strong>n</strong>. Základní podoba této funkce není nijak složitá ani
překvapující:</p>

<pre>
<strong>fun pow(m, n) = if n = 0 then 1</strong>
                <strong>else m * pow(m, n-1);</strong>
</pre>

<p>Funkci lze snadno otestovat (pro jednoduchost neuvažujeme zápornou
mocninu):</p>

<pre>
<strong>pow(2, 8);</strong>
val it = 256: int;
&nbsp;
<strong>pow(3, 2);</strong>
val it = 9: int;
</pre>

<p>Ve druhém kroku tuto funkci upravíme. Nejprve prohodíme oba parametry, což
je sice na první pohled nelogické, ovšem currying (a na něj navázané vytváření
částečně vyhodnocených funkcí) vždy &bdquo;odstraňuje&ldquo; první parametr,
což by v&nbsp;našem případě měla být mocnina a nikoli základ:</p>

<pre>
<strong>fun pow(m, n) = if n = 0 then 1</strong>
                <strong>else n * pow(m-1, n)</strong>
</pre>

<p>Výsledky (se stejnými vstupními parametry) budou podle očekávání odlišné,
protože nyní je prvním parametrem mocnina a druhým parametrem základ:</p>

<pre>
<strong>pow(2, 8);</strong>
val it = 64: int;
&nbsp;
<strong>pow(3, 2);</strong>
val it = 8: int;
</pre>

<p>Třetí úprava spočívá v&nbsp;náhradě podmínky za čitelnější pattern
matching:</p>

<pre>
<strong>fun pow(0, n) = 1</strong>
  <strong>| pow(m, n) = n * pow(m-1, n);</strong>
&nbsp;
</pre>

<p>S&nbsp;výsledky:</p>

<pre>
<strong>pow(2, 8);</strong>
val it = 64: int;
&nbsp;
<strong>pow(3, 2);</strong>
val it = 8: int;
</pre>

<p>A konečně můžeme funkci přepsat do podoby, v&nbsp;níž je automaticky
proveden currying. Přepis je ryze mechanický a spočívá v&nbsp;odstranění
závorek při volání funkce a ve vlastních vzorcích:</p>

<pre>
<strong>fun pow 0 n = 1</strong>
  <strong>| pow m n = n * pow(m-1) n;</strong>
</pre>

<p>Alternativně:</p>

<pre>
<strong>fun pow m n = if m = 0 then 1</strong>
              <strong>else n * pow(m-1) n;</strong>
</pre>

<p>Důležitý je typ této funkce:</p>

<pre>
val pow = fn: int → int → int;
</pre>

<p>Tuto funkci můžeme zavolat, a to opět bez použití závorek, protože ve
skutečnosti voláme funkci s&nbsp;jediným parametrem; výsledkem je další funkce,
které předáme druhý parametr:</p>

<pre>
<strong>pow 2 8;</strong>
val it = 64: int;
&nbsp;
<strong>pow 3 2;</strong>
val it = 8: int;
</pre>

<p>Důležitější však je, že si můžeme nechat vygenerovat částečně vyhodnocené
funkce. První pro výpočet druhé mocniny, druhou pro výpočet třetí mocniny:</p>

<pre>
<strong>val square = pow 2;</strong>
val square = fn: int → int;
&nbsp;
<strong>val cube = pow 3;</strong>
val cube = fn: int → int;
</pre>

<p>Tyto funkce lze již bez problémů zavolat:</p>

<pre>
<strong>square 10;</strong>
val it = 100: int;
&nbsp;
<strong>cube 10;</strong>
val it = 1000: int;
</pre>



<p><a name="k06"></a></p>
<h2 id="k06">6. Druhý pohled na funkci vyššího řádu <strong>map</strong></h2>

<p><a
href="https://www.root.cz/clanky/funkce-a-typovy-system-programovaciho-jazyka-ml/">V&nbsp;předchozím
článku</a> jsme si kromě dalších věcí ukázali i implementaci funkce nazvané
<strong>map</strong>. Jedná se o funkci vyššího řádu, jejímž prvním parametrem
je jiná funkce, která je aplikována na všechny prvky seznamu. Funkce
<strong>map</strong> může být realizována tak, že se využije currying, což je
ostatně patrné i z&nbsp;jejího zápisu:</p>

<pre>
<i>(* Implementace funkce map *)</i>
&nbsp;
<strong>fun map f [] = []</strong>
  <strong>| map f (head::tail) = (f head) :: (map f tail);</strong>
</pre>

<p>Za povšimnutí stojí typ funkce <strong>map</strong>, který ukazuje, že
překladač jazyka ML skutečně korektně rozeznal typy obou parametrů (tedy že
první parametr je funkce, která transformuje prvky typu <strong>a</strong> na
prvky typu <strong>b</strong>) a z&nbsp;toho též odvodil druhý parametr (seznam
prvků typu <strong>a</strong>) i návratovou hodnotu (seznam prvků typu
<strong>b</strong>). Přitom to, o jaké konkrétní typy <strong>a</strong> a
<strong>b</strong> se jedná, se rozhodne až při volání této funkce &ndash;
funkce je tedy generická (resp.&nbsp;přesněji řečeno polymorfická):</p>

<pre>
val map = fn: ∀ 'a 'b . ('a → 'b) → 'a list → 'b list;
</pre>

<p>Funkci <strong>map</strong> lze použít například pro seznam číselných hodnot
typu <strong>real</strong>:</p>

<pre>
<strong>fun half x = x / 2.0;</strong>
&nbsp;
<strong>map half [1.0,2.0,3.0,4.0,5.0];</strong>
</pre>

<p>Možný je i zkrácený zápis s&nbsp;využitím anonymní funkce:</p>

<pre>
<strong>map(fn x =&gt; x/2.0, [1.0, 2.0, 3.0]);</strong>
</pre>

<p>Nic nám ovšem nebrání použít <strong>map</strong> pro vygenerování dalších
funkcí pracujících nad všemi prvky nějakého vstupního seznamu, což je již
poměrně silná programovací technika:</p>

<pre>
<strong>fun map f [] = []</strong>
  <strong>| map f (head::tail) = (f head) :: (map f tail);</strong>
val map = fn: ∀ 'a 'b . ('a → 'b) → 'a list → 'b list;
&nbsp;
<strong>val incrementor = map (fn n =&gt; n+1);</strong>
val incrementor = fn: int list → int list;
&nbsp;
<strong>incrementor [1,2,3,4];</strong>
val it = [2, 3, 4, 5]: int list;
&nbsp;
<strong>val doubler = map (fn n =&gt; n*2);</strong>
val doubler = fn: int list → int list;
&nbsp;
<strong>doubler [1,2,3,4];</strong>
val it = [2, 4, 6, 8]: int list;
</pre>



<p><a name="k07"></a></p>
<h2 id="k07">7. Proměnné a prostředí</h2>

<p>Již <a href="#k01">v&nbsp;úvodní kapitole</a> jsme se setkali s&nbsp;pojmem
<i>prostředí</i> neboli <i>environment</i>. Tento pojem se používá především
při definici funkcí, které nějakým způsobem přistupují k&nbsp;již deklarovaným
proměnným. V&nbsp;takové chvíli je zapotřebí vědět, jaká hodnota (a typ) se
v&nbsp;dané konkrétní funkci použije a zda nebude mít změna proměnné vliv na
to, jak se funkce bude vyhodnocovat.</p>

<p>Podívejme se na jednoduchý příklad, v&nbsp;němž je definována funkce nazvaná
<strong>incr</strong>. Ta vrátí součet dvou hodnot, přičemž jedna hodnota je
získána přímo z&nbsp;parametru funkce a druhá hodnota je přečtena
z&nbsp;proměnné <strong>x</strong>, která musí být deklarována před definicí
funkce a být součástí jejího prostředí:</p>

<pre>
val x = 1 : int
&nbsp;
fun incr y = x + y;
&nbsp;
incr 1;
&nbsp;
val x = 10;
incr 1;
</pre>

<p>Po spuštění tohoto prográmku by se měly na terminál vypsat tyto řádky:</p>

<pre>
val x = 1: int;
&nbsp;
val incr = fn: int → int;
&nbsp;
val it = 2: int;
&nbsp;
val x = 10: int;
&nbsp;
val it = 2: int;
</pre>

<p>Tyto řádky vypsané jazykem ML postupně znamenají:</p>

<table>
<tr><th>Řádek</th><th>Význam</th></tr>
<tr><td>val x = 1: int;</td><td>vytvoření proměnné <strong>x</strong> s&nbsp;hodnotou <strong>1</strong> a typem <strong>int</strong></td></tr>
<tr><td>val incr = fn: int → int;</td><td>vytvoření funkce <strong>incr</strong>, která má jediný parametr typu <strong>int</strong> a vrací <strong>int</strong></td></tr>
<tr><td>val it = 2: int;</td><td>výsledek po zavolání funkce <strong>incr</strong> s&nbsp;parametrem 1</td></tr>
<tr><td>val x = 10: int;</td><td>změna hodnoty proměnné <strong>x</strong></td></tr>
<tr><td>val it = 2: int;</td><td>výsledek po zavolání funkce <strong>incr</strong> s&nbsp;parametrem 1</td></tr>
</table>

<p>Vidíme, že funkce <strong>incr</strong> pro stejný vstupní parametr (1) vždy
vrací stejnou hodnotu, která není závislá na změně hodnoty proměnné
<strong>x</strong> <i>po</i> deklaraci funkce. Důležité je si uvědomit, že ve
funkci <strong>incr</strong> ve skutečnosti nepracujeme přímo s&nbsp;původní
proměnnou <strong>x</strong>. Namísto toho je v&nbsp;aktuálním <i>prostředí</i>
(<i>environment</i>) vytvořena vazba na původní hodnotu (a typ). Výsledkem toho
je fakt, že další změny proměnné <strong>x</strong> příkazem
<strong>val</strong> nemají žádný vliv na to, jakou hodnotu vrátí funkce
<strong>incr</strong>. Jediný vliv na návratovou hodnotu bude mít hodnota
argumentu této funkce v&nbsp;čase jejího volání. Jinými slovy &ndash; tato
vlastnost nejenom zabraňuje nepříjemným zmatkům, ale především zajišťuje
<i>referenční transparentnost</i> funkcí, což je (nejenom) ve funkcionálním
programování velmi důležitá vlastnost.</p>

<p><div class="rs-tip-major">Poznámka: současně nám ovšem tato vlastnost
nezabraňuje měnit hodnotu proměnné, <strong>x</strong> je tedy stále měnitelná
(<i>mutable</i>).</div></p>



<p><a name="k08"></a></p>
<h2 id="k08">8. Konstrukce <strong>let</strong></h2>

<p>Další vlastnost programovacího jazyka ML je s&nbsp;velkou pravděpodobností
inspirována jazykem <a
href="https://www.root.cz/clanky/jemny-uvod-do-rozsahleho-sveta-jazyku-lisp-a-scheme/">Scheme</a>.
Jedná se o konstrukci <strong>let</strong>, která umožňuje vytvářet bloky
s&nbsp;lokálními symboly, s&nbsp;nimiž je možné v&nbsp;těchto blocích pracovat,
ovšem vně bloku nebudou viditelné. Podívejme se na jednoduchý příklad,
v&nbsp;němž je použit lokální symbol <strong>x</strong>:</p>

<pre>
<strong>let</strong>
    <strong>val x = 10</strong>
<strong>in</strong>
    <strong>2*x</strong>
<strong>end;</strong>
</pre>

<p>Výsledkem bude hodnota:</p>
<pre>
val it = 20: int;
</pre>

<p>Přičemž vně celého bloku nebude <strong>x</strong> viditelné:</p>

<pre>
<strong>x;</strong>
Elaboration failed: Unbound value identifier "x".
</pre>

<p>Navíc se celý blok <strong>let</strong> chápe jako výraz, takže můžeme
psát:</p>

<pre>
let
    val x = 10
in
    2*x
end + 1;
</pre>

<p>Příklad složitějšího výrazu s&nbsp;blokem <strong>let</strong>:</p>

<pre>
<strong>val i = 10</strong>
<strong>val j : real = 10.0</strong>
<strong>val k = i</strong>
&nbsp;
<strong>val lexpr =</strong>
  <strong>let val x = 1</strong>
      <strong>val y = 2</strong>
  <strong>in x + y</strong>
  <strong>end;</strong>
&nbsp;
val lexpr = 3 : int
</pre>

<p><div class="rs-tip-major">Poznámka: zde mají lokální symboly
<strong>x</strong> a <strong>y</strong> pochopitelně přednost před symboly
vnějšími.</div></p>

<p>V&nbsp;případě, že vně bloku již existuje proměnná <strong>x</strong>, je
její hodnota a typ zachována:</p>

<pre>
<strong>val x = "foobar";</strong>
val x = "foobar": string;
&nbsp;
<strong>x;</strong>
val it = "foobar": string;
&nbsp;
<strong>let</strong>
    <strong>val x = 10</strong>
<strong>in</strong>
    <strong>2*x</strong>
<strong>end;</strong>
val it = 20: int;
&nbsp;
<strong>x;</strong>
val it = "foobar": string;
</pre>

<p>Na druhou stranu proměnné definované vně bloku jsou v&nbsp;tomto bloku
dostupné &ndash; viz použití proměnné <strong>z</strong> uvnitř bloku:</p>

<pre>
<strong>val z = 2;</strong>
&nbsp;
<strong>let</strong>
    <strong>val x = 10</strong>
<strong>in</strong>
    <strong>z*x</strong>
<strong>end;</strong>
&nbsp;
val it = 20: int;
</pre>



<p><a name="k09"></a></p>
<h2 id="k09">9. Konstrukce <strong>let</strong> v&nbsp;těle funkce</h2>

<p>S&nbsp;výše popsaným blokem <strong>let</strong> se velmi často setkáme při
tvorbě složitějších funkcí. Například v&nbsp;následující funkci, která má
vypočítat vzdálenost bodu [x,y] od počátku souřadné soustavy, využijeme dvou
mezivýpočtů, což sice funkci prodlouží, ale pojmenování výsledků mezivýpočtů
zde má (mj.) i dokumentační efekt:</p>

<pre>
<strong>fun distance(x, y) =</strong>
<strong>let</strong>
    <strong>val squaredx = x*x</strong>
    <strong>val squaredy = y*y</strong>
<strong>in</strong>
    <strong>Math.sqrt(squaredx + squaredy)</strong>
<strong>end;</strong>
</pre>

<p>Otestování základní funkcionality:</p>

<pre>
<strong>distance(1.0, 1.0);</strong>
val it = 1.4142135623730951: real;
</pre>



<p><a name="k10"></a></p>
<h2 id="k10">10. Blok příkazů (s&nbsp;vedlejším efektem)</h2>

<p>V&nbsp;programovacím jazyku ML lze vytvářet popř.&nbsp;volat funkce
s&nbsp;vedlejším efektem. Nejedná se tedy o referenčně transparentní funkce,
ovšem na druhou stranu jde o praktický nástroj určený pro použití
v&nbsp;reálných programech. Takovou typickou funkcí s&nbsp;vedlejším efektem je
funkce <strong>print</strong>:</p>

<pre>
<strong>print 42;</strong>
</pre>

<p>Při vyhodnocování takové funkce se jako vedlejší efekt vypíše hodnota
42:</p>

<pre>
Printed: 42
</pre>

<p>S&nbsp;funkcemi s&nbsp;vedlejším efektem souvisí i bloky příkazů, které u
referenčně transparentních funkcí postrádají smysl. Blok příkazů je zapisován
do kulatých závorek stylem:</p>

<pre>
(&lt;expression&gt;;&lt;expression&gt;;...)
</pre>

<p>Podívejme se na příklad použití &ndash; rozšíříme funkce
<strong>distance</strong> o výpis mezivýsledků při jejím zavolání:</p>

<pre>
<strong>fun distance(x, y) =</strong>
<strong>let</strong>
    <strong>val squaredx = x*x</strong>
    <strong>val squaredy = y*y</strong>
<strong>in</strong>
  <strong>(</strong>
    <strong>print("Squared x=", x);</strong>
    <strong>print("Squared y=", y);</strong>
    <strong>Math.sqrt(squaredx + squaredy)</strong>
  <strong>)</strong>
<strong>end;</strong>
</pre>

<p>Funkci si vyzkoušejme zavolat:</p>

<pre>
<strong>distance(1.0, 1.0);</strong>
Printed: ("Squared x=", 1.0)
Printed: ("Squared y=", 1.0)
val it = 1.4142135623730951: real;
</pre>

<p><div class="rs-tip-major">Poznámka: některé varianty programovacího jazyka
ML nejdříve vypíšou výsledek funkce a teprve poté výsledek volání
<strong>print</strong>.</div></p>



<p><a name="k11"></a></p>
<h2 id="k11">11. Koncept výjimek v&nbsp;jazyku ML</h2>

<p>S&nbsp;výjimkami jsme se krátce setkali již minule, a to konkrétně ve
funkci, která měla vracet první prvek ze seznamu. V&nbsp;případě, že byl seznam
prázdný, došlo k&nbsp;vyhození výjimky <strong>Empty</strong>:</p>

<pre>
<i>(* Vrácení prvního prvku ze seznamu *)</i>
&nbsp;
<strong>fun car([]) = raise Empty</strong>
  <strong>| car(x::y) = x;</strong>
&nbsp;
&nbsp;
car([]);
car([1]);
car([1,2]);
car([1,2,3]);
car(["foo", "bar"]);
</pre>

<p>Ve skutečnosti je však velmi snadné přidat si do aplikací vlastní nový typ
výjimky. Postačuje použít tento zápis:</p>

<pre>
<strong>exception Nomatch;</strong>
</pre>

<p>Přitom <strong>exception</strong> je klíčové slovo a
<strong>Nomatch</strong> je nový typ výjimky. Tuto výjimku můžeme použít ve
funkci nazvané <strong>member</strong>, která testuje, zda v&nbsp;nějakém
seznamu existuje prvek <strong>a</strong>. Pokud je seznam prázdný (a to po
rekurzivním sestupu), vyhodí se právě výjimka <strong>Nomatch</strong>:</p>

<pre>
<strong>fun member(a, []) = raise Nomatch</strong>
 <strong>|  member(a, b::y) = if a == b then b::y</strong>
                      <strong>else member(a, y);</strong>
</pre>

<p>Zachytávání výjimek vypadá syntakticky následovně:</p>

<pre>
&lt;epxression1&gt; handle &lt;exception_name&gt; =&gt; &lt;expression2&gt;
</pre>

<p>To znamená, že můžeme psát:</p>

<pre>
<strong>fun check(a,x) = member(a, x) handle Nomatch =&gt;</strong>
   <strong>(print("error!"); []);</strong>
</pre>



<p><a name="k12"></a></p>
<h2 id="k12">12. Standardní operátory</h2>

<p>V&nbsp;programovacím jazyce ML nalezneme relativně velké množství operátorů.
Musíme si však uvědomit, že operátory jsou definovány jako běžné funkce a
samotný zápis operátoru je pouhý syntaktický cukr (ovšem velmi praktický):</p>

<pre>
&lt;výraz1&gt; &lt;operátor;&gt; &lt;výraz2&gt;
</pre>

<p>je totožný se zápisem:</p>

<pre>
&lt;operátor;&gt;(&lt;výraz1&gt;, &lt;výraz2&gt;)
</pre>

<p>V&nbsp;následující tabulce jsou vypsány všechny standardní operátory
programovacího jazyka ML. Ty se od sebe liší (pochopitelně) nejenom prováděnou
operací, ale taktéž prioritou a asociativitou. Priorita určuje, v&nbsp;jakém
pořadí se budou operátory vyhodnocovat, pokud jsou použity v&nbsp;jediném
výrazu (například ve výrazu <strong>1+2*3</strong>). A asociativita určuje
uzávorkování operátorů se stejnou prioritou, tj.&nbsp;zda se provede
<strong>(1+2)+3</strong> nebo naopak <strong>1+(2+3)</strong>. Z&nbsp;tabulky
je patrné, že většina operátorů je asociativní zleva, ovšem skupina dvou
operátorů s&nbsp;prioritou 5 má asociativitu zprava (jedná se konkrétně o
operátory určené pro spojení řetězců popř.&nbsp;seznamů, s&nbsp;nimiž jsme se
seznámili minule):</p>

<table>
<tr><th>Operátor</th><th>Priorita</th><th>Asociativita</th></tr>
<tr><td>*</td><td>7</td><td>zleva</td></tr>
<tr><td>/</td><td>7</td><td>zleva</td></tr>
<tr><td>div</td><td>7</td><td>zleva</td></tr>
<tr><td>mod</td><td>7</td><td>zleva</td></tr>
<tr><td>+</td><td>6</td><td>zleva</td></tr>
<tr><td>-</td><td>6</td><td>zleva</td></tr>
<tr><td>^</td><td>6</td><td>zleva</td></tr>
<tr><td>::</td><td>5</td><td>zprava</td></tr>
<tr><td>@</td><td>5</td><td>zprava</td></tr>
<tr><td>=</td><td>4</td><td>zleva</td></tr>
<tr><td>&lt;&gt;</td><td>4</td><td>zleva</td></tr>
<tr><td>&gt;</td><td>4</td><td>zleva</td></tr>
<tr><td>&gt;=</td><td>4</td><td>zleva</td></tr>
<tr><td>&lt;</td><td>4</td><td>zleva</td></tr>
<tr><td>&lt;=</td><td>4</td><td>zleva</td></tr>
<tr><td>:=</td><td>3</td><td>zleva</td></tr>
<tr><td>o</td><td>3</td><td>zleva</td></tr>
<tr><td>before</td><td>0</td><td>zleva</td></tr>
</table>



<p><a name="k13"></a></p>
<h2 id="k13">13. Zápis standardních operátorů</h2>

<p>Všechny výše uvedené operátory jsou interně implementovány jako funkce a
dále jsou definovány slovy <strong>infix</strong> a
<strong>infixr</strong>:</p>

<pre>
<strong>infix  7  * / div mod</strong>
<strong>infix  6  + - ^</strong>
<strong>infixr 5  :: @</strong>
<strong>infix  4  = &lt;&gt; &gt; &gt;= &lt; &lt;=</strong>
<strong>infix  3  := o</strong>
<strong>infix  0  before</strong>
</pre>

<p><div class="rs-tip-major">Poznámka: povšimněte si, že ne všechny priority
jsou ve skutečnosti obsazeny standardními operátory, což pochopitelně není
náhoda.</div></p>



<p><a name="k14"></a></p>
<h2 id="k14">14. Definice vlastních operátorů</h2>

<p>V&nbsp;programovacím jazyku ML sice není (prakticky) možné přetěžovat
standardní operátory, ovšem samotný jazyk nám nezabraňuje ve vytváření
operátorů nových. U nových operátorů lze určit jejich prioritu i asociativitu,
což je <i>velmi</i> užitečné (podle mého skromného názoru dokonce mnohem
užitečnější, než pouhé přetěžování existujících operátorů).</p>

<p>Prvním krokem je definice funkce se dvěma parametry, která bude následně
zaregistrována jako nový binární operátor. Můžeme si například vyzkoušet funkci
pro umocnění m<sup>n</sup>. S&nbsp;touto funkcí jsme se již setkali
v&nbsp;úvodních kapitolách, takže jen ve zkratce:</p>

<pre>
<strong>fun pow(m, 0) = 1</strong>
  <strong>| pow(m, n) = m * pow(m, n-1);</strong>
</pre>

<p>Funkci převedeme na operátor, konkrétně na operátor asociativní zleva
s&nbsp;prioritou 8:</p>

<pre>
<strong>infix 8 pow;</strong>
</pre>

<p>Nyní je již možné nový operátor začít používat, a to se všemi výhodami,
které přináší statický typový systém programovacího jazyka ML:</p>

<pre>
<strong>2 pow 3;</strong>
<strong>2 pow 3 + 1;</strong>
</pre>

<p><div class="rs-tip-major">Poznámka: ve skutečnosti asi budete chtít pravou
asociativitu operátoru <strong>pow</strong>:</div></p>

<pre>
<strong>infixr 8 pow;</strong>
</pre>



<p><a name="k15"></a></p>
<h2 id="k15">15. Změna priority a asociativity operátorů</h2>

<p>Podívejme se nyní na ukázky dalších uživatelsky definovaných operátorů.
Užitečný může být operátor <strong>exists</strong> pro detekci, zda seznam
obsahuje určitý prvek či nikoli (lepší by bylo operátor pojmenovat
<strong>in</strong>, toto klíčové slovo je však již obsazeno). Vlastní
implementace <i>funkce</i> <strong>exists</strong> je relativně snadná:</p>

<pre>
<strong>fun exists(element, []) = false</strong>
  <strong>| exists(element, head::tail) = if element = head then true</strong>
                                  <strong>else exists(element, tail);</strong>
</pre>

<p>Funkci si samozřejmě můžeme otestovat:</p>

<pre>
<strong>exists(2, [1,2,3]);</strong>
<strong>exists(0, [1,2,3]);</strong>
<strong>exists(42, [42]);</strong>
<strong>exists(42, []);</strong>
</pre>

<p>A následně ji převést na operátor, a to konkrétně operátor s&nbsp;druhou
nejnižší prioritou:</p>

<pre>
<strong>infix 1 exists;</strong>
</pre>

<p>Nyní se bude test existence prvku v&nbsp;seznamu zapisovat skutečně jako
operátor:</p>

<pre>
<strong>2 exists [1,2,3];</strong>
<strong>0 exists [1,2,3];</strong>
<strong>42 exists [42];</strong>
<strong>42 exists [];</strong>
</pre>

<p>Sami si vyzkoušejte, jaký vliv má druhá nejnižší priorita (1) na tyto
výrazy:</p>

<pre>
<strong>1+1 exists [1,2,3];</strong>
<strong>3*1 exists [1,2,3];</strong>
<strong>1+1 exists [1,2] @ [3,4];</strong>
</pre>



<p><a name="k16"></a></p>
<h2 id="k16">16. Obsah navazujícího článku</h2>

<p>Prozatím jsme si do značné míry vystačili se základními datovými typy jazyka
ML. Ovšem velká síla tohoto jazyka spočívá v&nbsp;principu deklarace nových
datových typů. Podporován je algebraický typový systém, což je téma, kterému
bude věnován celý čtvrtý díl seriálu o jazyku ML.</p>



<p><a name="k17"></a></p>
<h2 id="k17">17. Repositář s&nbsp;demonstračními příklady</h2>

<p>Všechny výše popsané demonstrační příklady byly uloženy do repositáře
dostupného na adrese <a
href="https://github.com/tisnik/ml-examples/">https://github.com/tisnik/ml-examples/</a>.
V&nbsp;tabulce umístěné pod tímto odstavcem jsou uvedeny odkazy na tyto
příklady:</p>

<table>
<tr><th> #</th><th>Příklad</th><th>Popis příkladu</th><th>Cesta</th></tr>
<tr><td> 1</td><td>01_currying1.ml</td><td>anonymní funkce přistupující k&nbsp;proměnné uložené v&nbsp;jejím prostředí</td><td><a href="https://github.com/tisnik/ml-examples/tree/master/article_03/01_currying1.ml">https://github.com/tisnik/ml-examples/tree/master/article_03/01_currying1.ml</a></td></tr>
<tr><td> 2</td><td>02_currying2.ml</td><td>anonymní funkce přistupující k&nbsp;proměnné uložené v&nbsp;jejím prostředí</td><td><a href="https://github.com/tisnik/ml-examples/tree/master/article_03/02_currying2.ml">https://github.com/tisnik/ml-examples/tree/master/article_03/02_currying2.ml</a></td></tr>
<tr><td> 3</td><td>03_currying3.ml</td><td>předchozí příklad, ovšem zapsaný na jediném řádku</td><td><a href="https://github.com/tisnik/ml-examples/tree/master/article_03/03_currying3.ml">https://github.com/tisnik/ml-examples/tree/master/article_03/03_currying3.ml</a></td></tr>
<tr><td> 4</td><td>04_currying4.ml</td><td>částečná aplikace funkce</td><td><a href="https://github.com/tisnik/ml-examples/tree/master/article_03/04_currying4.ml">https://github.com/tisnik/ml-examples/tree/master/article_03/04_currying4.ml</a></td></tr>
<tr><td> 5</td><td>05_pow_curry1.ml</td><td>generátor funkce pro výpočet n-té mocniny</td><td><a href="https://github.com/tisnik/ml-examples/tree/master/article_03/05_pow_curry1.ml">https://github.com/tisnik/ml-examples/tree/master/article_03/05_pow_curry1.ml</a></td></tr>
<tr><td> 6</td><td>06_pow_curry2.ml</td><td>generátor funkce pro výpočet n-té mocniny, verze s&nbsp;pattern matchingem</td><td><a href="https://github.com/tisnik/ml-examples/tree/master/article_03/06_pow_curry2.ml">https://github.com/tisnik/ml-examples/tree/master/article_03/06_pow_curry2.ml</a></td></tr>
<tr><td> 7</td><td>07_currying_4_params.ml</td><td>currying funkce se čtyřmi parametry, verze s neanonymní funkcí, zápis se závorkami</td><td><a href="https://github.com/tisnik/ml-examples/tree/master/article_03/07_currying_4_params.ml">https://github.com/tisnik/ml-examples/tree/master/article_03/07_currying_4_params.ml</a></td></tr>
<tr><td> 8</td><td>08_currying_4_params.ml</td><td>currying funkce se čtyřmi parametry, verze s neanonymní funkcí, zápis bez závorek</td><td><a href="https://github.com/tisnik/ml-examples/tree/master/article_03/08_currying_4_params.ml">https://github.com/tisnik/ml-examples/tree/master/article_03/08_currying_4_params.ml</a></td></tr>
<tr><td> 9</td><td>09_environment.ml</td><td>prostředí a vazba na funkce</td><td><a href="https://github.com/tisnik/ml-examples/tree/master/article_03/09_environment.ml">https://github.com/tisnik/ml-examples/tree/master/article_03/09_environment.ml</a></td></tr>
<tr><td>10</td><td>10_distance.ml</td><td>výpočet vzdálenosti bodu od počátku</td><td><a href="https://github.com/tisnik/ml-examples/tree/master/article_03/10_distance.ml">https://github.com/tisnik/ml-examples/tree/master/article_03/10_distance.ml</a></td></tr>
<tr><td>11</td><td>11_exceptions1.ml</td><td>práce s&nbsp;výjimkami</td><td><a href="https://github.com/tisnik/ml-examples/tree/master/article_03/11_exceptions1.ml">https://github.com/tisnik/ml-examples/tree/master/article_03/11_exceptions1.ml</a></td></tr>
<tr><td>12</td><td>12_exceptions2.ml</td><td>práce s&nbsp;výjimkami</td><td><a href="https://github.com/tisnik/ml-examples/tree/master/article_03/12_exceptions2.ml">https://github.com/tisnik/ml-examples/tree/master/article_03/12_exceptions2.ml</a></td></tr>
<tr><td>13</td><td>13_increment.ml</td><td>zvýšení hodnoty prvků</td><td><a href="https://github.com/tisnik/ml-examples/tree/master/article_03/13_increment.ml">https://github.com/tisnik/ml-examples/tree/master/article_03/13_increment.ml</a></td></tr>
<tr><td>14</td><td>14_increment.ml</td><td>zvýšení hodnoty prvků</td><td><a href="https://github.com/tisnik/ml-examples/tree/master/article_03/14_increment.ml">https://github.com/tisnik/ml-examples/tree/master/article_03/14_increment.ml</a></td></tr>
<tr><td>15</td><td>15_let3.ml</td><td>blok <strong>let</strong></td><td><a href="https://github.com/tisnik/ml-examples/tree/master/article_03/15_let3.ml">https://github.com/tisnik/ml-examples/tree/master/article_03/15_let3.ml</a></td></tr>
<tr><td>16</td><td>16_pow_operator.ml</td><td>operátor <strong>pow</strong></td><td><a href="https://github.com/tisnik/ml-examples/tree/master/article_03/16_pow_operator.ml">https://github.com/tisnik/ml-examples/tree/master/article_03/16_pow_operator.ml</a></td></tr>
<tr><td>17</td><td>17_simple_let_1.ml</td><td>blok <strong>let</strong></td><td><a href="https://github.com/tisnik/ml-examples/tree/master/article_03/17_simple_let_1.ml">https://github.com/tisnik/ml-examples/tree/master/article_03/17_simple_let_1.ml</a></td></tr>
<tr><td>18</td><td>18_simple_let_2.ml</td><td>blok <strong>let</strong></td><td><a href="https://github.com/tisnik/ml-examples/tree/master/article_03/18_simple_let_2.ml">https://github.com/tisnik/ml-examples/tree/master/article_03/18_simple_let_2.ml</a></td></tr>
<tr><td>19</td><td>19_exists.ml</td><td>operátor <strong>exists</strong></td><td><a href="https://github.com/tisnik/ml-examples/tree/master/article_03/19_exists.ml">https://github.com/tisnik/ml-examples/tree/master/article_03/19_exists.ml</a></td></tr>
<tr><td>20</td><td>20_pow_associativity.ml</td><td>operátor <strong>pow</strong> se změnou asociativity</td><td><a href="https://github.com/tisnik/ml-examples/tree/master/article_03/20_pow_associativity.ml">https://github.com/tisnik/ml-examples/tree/master/article_03/20_pow_associativity.ml</a></td></tr>
<tr><td>21</td><td>21_exists1.ml</td><td>operátor <strong>exists</strong></td><td><a href="https://github.com/tisnik/ml-examples/tree/master/article_03/21_exists1.ml">https://github.com/tisnik/ml-examples/tree/master/article_03/21_exists1.ml</a></td></tr>
<tr><td>22</td><td>22_exists2.ml</td><td>operátor <strong>exists</strong></td><td><a href="https://github.com/tisnik/ml-examples/tree/master/article_03/22_exists2.ml">https://github.com/tisnik/ml-examples/tree/master/article_03/22_exists2.ml</a></td></tr>
<tr><td>23</td><td>23_exists3.ml</td><td>operátor <strong>exists</strong></td><td><a href="https://github.com/tisnik/ml-examples/tree/master/article_03/23_exists3.ml">https://github.com/tisnik/ml-examples/tree/master/article_03/23_exists3.ml</a></td></tr>
</table>



<p><a name="k18"></a></p>
<h2 id="k18">18. Literatura</h2>

<p><div class="rs-tip-major">Poznámka: v&nbsp;této kapitole jsou uvedeny
nejenom knihy o jazyku ML resp.&nbsp;Standard ML, ale i knihy o programovacím
jazyku OCaml, který ze Standard ML ze značné míry vychází.</div></p>

<ol>

<li>ML for the Working Programmer<br />
<a href="https://www.cl.cam.ac.uk/~lp15/MLbook/pub-details.html">https://www.cl.cam.ac.uk/~lp15/MLbook/pub-details.html</a>
</li>

<li>Elements of ML Programming, 2nd Edition (ML97)<br />
<a href="http://infolab.stanford.edu/~ullman/emlp.html">http://infolab.stanford.edu/~ullman/emlp.html</a>
</li>

<li>A tour of Standard ML<br />
<a href="https://saityi.github.io/sml-tour/tour/welcome">https://saityi.github.io/sml-tour/tour/welcome</a>
</li>

<li>The History of Standard ML<br />
<a href="https://smlfamily.github.io/history/SML-history.pdf">https://smlfamily.github.io/history/SML-history.pdf</a>
</li>

<li>The Standard ML Basis Library<br />
<a href="https://smlfamily.github.io/Basis/">https://smlfamily.github.io/Basis/</a>
</li>

<li>Programming in Standard ML<br />
<a href="http://www.cs.cmu.edu/~rwh/isml/book.pdf">http://www.cs.cmu.edu/~rwh/isml/book.pdf</a>
</li>

<li>Programming in Standard ML '97: A Tutorial Introduction<br />
<a href="http://www.lfcs.inf.ed.ac.uk/reports/97/ECS-LFCS-97-364/">http://www.lfcs.inf.ed.ac.uk/reports/97/ECS-LFCS-97-364/</a>
</li>

<li>Programming in Standard ML '97: An On-line Tutorial<br />
<a href="https://homepages.inf.ed.ac.uk/stg/NOTES/">https://homepages.inf.ed.ac.uk/stg/NOTES/</a>
</li>

<li>The OCaml system  release 4.13<br />
<a href="https://ocaml.org/releases/4.13/htmlman/index.html">https://ocaml.org/releases/4.13/htmlman/index.html</a>
</li>

<li>Real World OCaml: Functional programming for the masses<br />
<a href="https://dev.realworldocaml.org/">https://dev.realworldocaml.org/</a>
</li>

<li>OCaml from the Very Beginning<br />
<a href="http://ocaml-book.com/">http://ocaml-book.com/</a>
</li>

<li>OCaml from the Very Beginning: More OCaml : Algorithms, Methods &amp; Diversions<br />
<a href="http://ocaml-book.com/more-ocaml-algorithms-methods-diversions/">http://ocaml-book.com/more-ocaml-algorithms-methods-diversions/</a>
</li>

<li>Unix system programming in OCaml<br />
<a href="http://ocaml.github.io/ocamlunix/">http://ocaml.github.io/ocamlunix/</a>
</li>

<li>OCaml for Scientists<br />
<a href="https://www.ffconsultancy.com/products/ocaml_for_scientists/index.html">https://www.ffconsultancy.com/products/ocaml_for_scientists/index.html</a>
</li>

<li>Using, Understanding, and Unraveling The OCaml Language<br />
<a href="https://caml.inria.fr/pub/docs/u3-ocaml/">https://caml.inria.fr/pub/docs/u3-ocaml/</a>
</li>

<li>Developing Applications With objective Caml<br />
<a href="https://caml.inria.fr/pub/docs/oreilly-book/index.html">https://caml.inria.fr/pub/docs/oreilly-book/index.html</a>
</li>

<li>Introduction to Objective Caml<br />
<a href="http://courses.cms.caltech.edu/cs134/cs134b/book.pdf">http://courses.cms.caltech.edu/cs134/cs134b/book.pdf</a>
</li>

<li>How to Think Like a (Functional) Programmer<br />
<a href="https://greenteapress.com/thinkocaml/index.html">https://greenteapress.com/thinkocaml/index.html</a>
</li>

</ol>



<p><a name="k19"></a></p>
<h2 id="k19">19. Odkazy na Internetu</h2>

<ol>

<li>Standard ML of New Jersey<br />
<a href="https://www.smlnj.org/">https://www.smlnj.org/</a>
</li>

<li>Programming Languages: Standard ML - 1 (a navazující videa)<br />
<a href="https://www.youtube.com/watch?v=2sqjUWGGzTo">https://www.youtube.com/watch?v=2sqjUWGGzTo</a>
</li>

<li>6 Excellent Free Books to Learn Standard ML<br />
<a href="https://www.linuxlinks.com/excellent-free-books-learn-standard-ml/">https://www.linuxlinks.com/excellent-free-books-learn-standard-ml/</a>
</li>

<li>SOSML: The Online Interpreter for Standard ML<br />
<a href="https://sosml.org/">https://sosml.org/</a>
</li>

<li>ML (Computer program language)<br />
<a href="https://www.barnesandnoble.com/b/books/other-programming-languages/ml-computer-program-language/_/N-29Z8q8Zvy7">https://www.barnesandnoble.com/b/books/other-programming-languages/ml-computer-program-language/_/N-29Z8q8Zvy7</a>
</li>

<li>Strong Typing<br />
<a href="https://perl.plover.com/yak/typing/notes.html">https://perl.plover.com/yak/typing/notes.html</a>
</li>

<li>What to know before debating type systems<br />
<a href="http://blogs.perl.org/users/ovid/2010/08/what-to-know-before-debating-type-systems.html">http://blogs.perl.org/users/ovid/2010/08/what-to-know-before-debating-type-systems.html</a>
</li>

<li>Types, and Why You Should Care (Youtube)<br />
<a href="https://www.youtube.com/watch?v=0arFPIQatCU">https://www.youtube.com/watch?v=0arFPIQatCU</a>
</li>

<li>DynamicTyping (Martin Fowler)<br />
<a href="https://www.martinfowler.com/bliki/DynamicTyping.html">https://www.martinfowler.com/bliki/DynamicTyping.html</a>
</li>

<li>DomainSpecificLanguage (Martin Fowler)<br />
<a href="https://www.martinfowler.com/bliki/DomainSpecificLanguage.html">https://www.martinfowler.com/bliki/DomainSpecificLanguage.html</a>
</li>

<li>Language Workbenches: The Killer-App for Domain Specific Languages?<br />
<a href="https://www.martinfowler.com/articles/languageWorkbench.html">https://www.martinfowler.com/articles/languageWorkbench.html</a>
</li>

<li>Effective ML (Youtube)<br />
<a href="https://www.youtube.com/watch?v=-J8YyfrSwTk">https://www.youtube.com/watch?v=-J8YyfrSwTk</a>
</li>

<li>Why OCaml (Youtube)<br />
<a href="https://www.youtube.com/watch?v=v1CmGbOGb2I">https://www.youtube.com/watch?v=v1CmGbOGb2I</a>
</li>

<li>CSE 341: Functions and patterns<br />
<a href="https://courses.cs.washington.edu/courses/cse341/04wi/lectures/03-ml-functions.html">https://courses.cs.washington.edu/courses/cse341/04wi/lectures/03-ml-functions.html</a>
</li>

<li>Comparing Objective Caml and Standard ML<br />
<a href="http://adam.chlipala.net/mlcomp/">http://adam.chlipala.net/mlcomp/</a>
</li>

<li>What are the key differences between Standard ML and OCaml?<br />
<a href="https://www.quora.com/What-are-the-key-differences-between-Standard-ML-and-OCaml?share=1">https://www.quora.com/What-are-the-key-differences-between-Standard-ML-and-OCaml?share=1</a>
</li>

<li>Cheat Sheets (pro OCaml)<br />
<a href="https://www.ocaml.org/docs/cheat_sheets.html">https://www.ocaml.org/docs/cheat_sheets.html</a>
</li>

<li>Syllabus (FAS CS51)<br />
<a href="https://cs51.io/college/syllabus/">https://cs51.io/college/syllabus/</a>
</li>

<li>Abstraction and Design In Computation<br />
<a href="http://book.cs51.io/">http://book.cs51.io/</a>
</li>

<li>Learn X in Y minutes Where X=Standard ML<br />
<a href="https://learnxinyminutes.com/docs/standard-ml/">https://learnxinyminutes.com/docs/standard-ml/</a>
</li>

<li>CSE307 Online - Summer 2018: Principles of Programing Languages course<br />
<a href="https://www3.cs.stonybrook.edu/~pfodor/courses/summer/cse307.html">https://www3.cs.stonybrook.edu/~pfodor/courses/summer/cse307.html</a>
</li>

<li>CSE307 Principles of Programming Languages course: SML part 1<br />
<a href="https://www.youtube.com/watch?v=p1n0_PsM6hw">https://www.youtube.com/watch?v=p1n0_PsM6hw</a>
</li>

<li>CSE 307 &ndash; Principles of Programming Languages &ndash; SML<br />
<a href="https://www3.cs.stonybrook.edu/~pfodor/courses/summer/CSE307/L01_SML.pdf">https://www3.cs.stonybrook.edu/~pfodor/courses/summer/CSE307/L01_SML.pdf</a>
</li>

<li>SML, Some Basic Examples<br />
<a href="https://cs.fit.edu/~ryan/sml/intro.html">https://cs.fit.edu/~ryan/sml/intro.html</a>
</li>

<li>History of programming languages<br />
<a href="https://devskiller.com/history-of-programming-languages/">https://devskiller.com/history-of-programming-languages/</a>
</li>

<li>History of programming languages (Wikipedia)<br />
<a href="https://en.wikipedia.org/wiki/History_of_programming_languages">https://en.wikipedia.org/wiki/History_of_programming_languages</a>
</li>

<li>Jemný úvod do rozsáhlého světa jazyků LISP a Scheme<br />
<a href="https://www.root.cz/clanky/jemny-uvod-do-rozsahleho-sveta-jazyku-lisp-a-scheme/">https://www.root.cz/clanky/jemny-uvod-do-rozsahleho-sveta-jazyku-lisp-a-scheme/</a>
</li>

<li>The Evolution Of Programming Languages<br />
<a href="https://www.i-programmer.info/news/98-languages/8809-the-evolution-of-programming-languages.html">https://www.i-programmer.info/news/98-languages/8809-the-evolution-of-programming-languages.html</a>
</li>

<li>Evoluce programovacích jazyků<br />
<a href="https://ccrma.stanford.edu/courses/250a-fall-2005/docs/ComputerLanguagesChart.png">https://ccrma.stanford.edu/courses/250a-fall-2005/docs/ComputerLanguagesChart.png</a>
</li>

<li>Poly/ML Homepage<br />
<a href="https://polyml.org/">https://polyml.org/</a>
</li>

<li>PolyConf 16: A brief history of F# / Rachel Reese<br />
<a href="https://www.youtube.com/watch?v=cbDjpi727aY">https://www.youtube.com/watch?v=cbDjpi727aY</a>
</li>

<li>Programovací jazyk Clojure 18: základní techniky optimalizace aplikací<br />
<a href="https://www.root.cz/clanky/programovaci-jazyk-clojure-18-zakladni-techniky-optimalizace-aplikaci/">https://www.root.cz/clanky/programovaci-jazyk-clojure-18-zakladni-techniky-optimalizace-aplikaci/</a>
</li>

<li>Moscow ML Language Overview<br />
<a href="https://itu.dk/people/sestoft/mosml/mosmlref.pdf">https://itu.dk/people/sestoft/mosml/mosmlref.pdf</a>
</li>

<li>ForLoops<br />
<a href="http://mlton.org/ForLoops">http://mlton.org/ForLoops</a>
</li>

<li>Funkcionální dobrodružství v&nbsp;JavaScriptu<br />
<a href="https://blog.kolman.cz/2015/12/funkcionalni-dobrodruzstvi-v-javascriptu.html">https://blog.kolman.cz/2015/12/funkcionalni-dobrodruzstvi-v-javascriptu.html</a>
</li>

<li>Recenze knihy Functional Thinking (Paradigm over syntax)<br />
<a href="https://www.root.cz/clanky/recenze-knihy-functional-thinking-paradigm-over-syntax/">https://www.root.cz/clanky/recenze-knihy-functional-thinking-paradigm-over-syntax/</a>
</li>

<li>Currying<br />
<a href="https://sw-samuraj.cz/2011/02/currying/">https://sw-samuraj.cz/2011/02/currying/</a>
</li>

<li>Používání funkcí v&nbsp;F#<br />
<a href="https://docs.microsoft.com/cs-cz/dotnet/fsharp/tutorials/using-functions">https://docs.microsoft.com/cs-cz/dotnet/fsharp/tutorials/using-functions</a>
</li>

<li>Funkce vyššího řádu<br />
<a href="http://naucte-se.haskell.cz/funkce-vyssiho-radu">http://naucte-se.haskell.cz/funkce-vyssiho-radu</a>
</li>

<li>Currying (Wikipedia)<br />
<a href="https://en.wikipedia.org/wiki/Currying">https://en.wikipedia.org/wiki/Currying</a>
</li>

<li>Currying (Haskell wiki)<br />
<a href="https://wiki.haskell.org/Currying">https://wiki.haskell.org/Currying</a>
</li>

<li>Haskell Curry<br />
<a href="https://en.wikipedia.org/wiki/Haskell_Curry">https://en.wikipedia.org/wiki/Haskell_Curry</a>
</li>

<li>Moses Schönfinkel<br />
<a href="https://en.wikipedia.org/wiki/Moses_Sch%C3%B6nfinkel">https://en.wikipedia.org/wiki/Moses_Sch%C3%B6nfinkel</a>
</li>

</ol>



<p></p><p></p>
<p><small>Autor: <a href="http://www.fit.vutbr.cz/~tisnovpa">Pavel Tišnovský</a> &nbsp; 2022</small></p>
</body>
</html>

