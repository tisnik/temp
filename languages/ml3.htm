<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
        "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html>
<head>
<title></title>
<meta name="Author" content="Pavel Tisnovsky" />
<meta name="Generator" content="vim" />
<meta http-equiv="content-type" content="text/html; charset=utf-8" />
<style type="text/css">
         body {color:#000000; background:#ffffff;}
         h1  {font-family: arial, helvetica, sans-serif; color:#ffffff; background-color:#c00000; text-align:center; padding-left:1em}
         h2  {font-family: arial, helvetica, sans-serif; color:#ffffff; background-color:#0000c0; padding-left:1em; text-align:left}
         h3  {font-family: arial, helvetica, sans-serif; color:#000000; background-color:#c0c0c0; padding-left:1em; text-align:left}
         h4  {font-family: arial, helvetica, sans-serif; color:#000000; background-color:#e0e0e0; padding-left:1em; text-align:left}
         a   {font-family: arial, helvetica, sans-serif;}
         li  {font-family: arial, helvetica, sans-serif; color:#000000; text-align:justify; width:450px;}
         ol  {font-family: arial, helvetica, sans-serif; color:#000000; text-align:justify; width:450px;}
         ul  {font-family: arial, helvetica, sans-serif; color:#000000; text-align:justify; width:450px;}
         p   {font-family: arial, helvetica, sans-serif; color:#000000; text-align:justify;}
         pre {background:#e0e0e0}
</style>
</head>

<body>

<h1></h1>

<h3>Pavel Tišnovský</h3>

<p></p>

<h1>Úvodník</h1>

<p></p>



<h2>Obsah</h2>

<p><a href="#k01">1. Curryfikace (currying) a částečně vyhodnocené funkce</a></p>
<p><a href="#k02">2. Malá odbočka &ndash; funkce přistupující k&nbsp;symbolům ve svém prostředí (environment)</a></p>
<p><a href="#k03">3. Praktické využití curryfikace</a></p>
<p><a href="#k04">4. Skutečný počet parametrů všech funkcí v&nbsp;jazyce ML</a></p>
<p><a href="#k05">5. Generování funkcí pro výpočet n-té mocniny</a></p>
<p><a href="#k06">6. Druhý pohled na funkci vyššího řádu <strong>map</strong></a></p>
<p><a href="#k07">7. Proměnné a prostředí</a></p>
<p><a href="#k08">8. Konstrukce <strong>let</strong></a></p>
<p><a href="#k09">9. Konstrukce <strong>let</strong> v&nbsp;těle funkce</a></p>
<p><a href="#k10">10. Blok příkazů (s&nbsp;vedlejším efektem)</a></p>
<p><a href="#k11">*** 11. Koncept výjimek v&nbsp;jazyku ML</a></p>
<p><a href="#k12">*** 12. Standardní operátory</a></p>
<p><a href="#k13">*** 13. Definice vlastních operátorů</a></p>
<p><a href="#k14">*** 14. Změna priority a asociativity operátorů</a></p>
<p><a href="#k15">*** 15. Řídicí konstrukce</a></p>
<p><a href="#k16">*** 16. </a></p>
<p><a href="#k17">*** 17. </a></p>
<p><a href="#k18">*** 18. Repositář s&nbsp;demonstračními příklady</a></p>
<p><a href="#k19">*** 19. Literatura</a></p>
<p><a href="#k20">*** 20. Odkazy na Internetu</a></p>



<p><a name="k01"></a></p>
<h2 id="k01">1. Curryfikace (currying) a částečně vyhodnocené funkce</h2>

<p><i>&bdquo;Typically, developers learn new languages by applying what they
know about existing languages. But learning a new paradigm is difficult &ndash;
you must learn to see different solutions to familiar problems.&ldquo;</i></p>

<p>V&nbsp;úvodní části dnešního článku si ukážeme, jakým způsobem se
v&nbsp;programovacím jazyku ML provádí takzvaná <i>curryfikace</i> (anglicky
<i>currying</i>). Pod tímto termínem se v&nbsp;teorii programovacích jazyků
(ovšem i obecně v&nbsp;matematice) označuje proces, jímž se transformuje
funkce, která má více než jeden parametr, do řady vložených funkcí, přičemž
každá z&nbsp;nich má jen jediný parametr. Curryfikaci si můžeme představit jako
postupnou transformaci funkce s&nbsp;<i>n</i> parametry na jinak zkonstruovanou
funkci s&nbsp;<i>n-1</i> parametry atd. až rekurzivně dojdeme k&nbsp;funkci
s&nbsp;jediným parametrem:</p>

<pre>
x = f(a,b,c) &rarr;
    h = g(a)
    i = h(b)
    x = i(c)
</pre>

<p>Nebo na jediném řádku:</p>

<pre>
x = f(a,b,c) &rarr; g(a)(b)(c)
</pre>

<p><div class="rs-tip-major">Poznámka: povšimněte si, že funkce
<strong>g</strong> a <strong>h</strong> musí vracet jiné funkce.</div></p>

<p>To zní sice velmi složitě, ale v&nbsp;praxi je (v&nbsp;ML, ale i dalších
jazycích) proces curryfikace realizován, jak uvidíme v&nbsp;dalším textu,
z&nbsp;pohledu programátora automaticky již samotným zápisem funkce
s&nbsp;větším množstvím parametrů. To nám umožňuje realizovat <i>částečné
vyhodnocení funkce (<i>partial application)</i>, konkrétně zavoláním nějaké
funkce (například funkce akceptující dva parametry) ve skutečnosti pouze
s&nbsp;jediným parametrem. Jenže &ndash; co má být výsledkem volání takové
funkce? Určitě ne výsledek implementované operace, protože nám chybí jeden
parametr pro to, aby byl výsledek vypočten a vrácen volajícím kódu. Ovšem
můžeme provést částečný výpočet dosazením (jediného) předaného parametru a
výsledek &ndash; tento částečný výpočet &ndash; vrátit. Výsledkem je tedy
obecně částečně aplikovaná funkce (tedy například funkce, které byly
v&nbsp;předchozím příkladu označeny symboly <strong>g</strong> a
<strong>h</strong>). Jedná se o jeden ze způsobů, jak programově (za běhu
aplikace) vytvářet nové funkce.</p>

<p><div class="rs-tip-major">Poznámka: curryfikace/currying se tedy ve
skutečnosti poněkud liší od tvorby částečně aplikovaných funkcí (i když se
mnohdy oba termíny zaměňují, nebo používají současně, což je ostatně i případ
předchozího odstavce).</div></p>

<p><div class="rs-tip-major">Poznámka<sup>2</sup>: název <i>currying</i> je
odvozen od jména známého matematika Haskella Curryho, po kterém je ostatně
pojmenován i další programovací jazyk Haskell (ten se ML v&nbsp;mnoha ohledech
podobá, právě i v&nbsp;kontextu curryingu a s&nbsp;ním souvisejícím faktem, že
funkce akceptují jeden parametr). Ve skutečnosti však Haskell tento proces
nevymyslel. Za původní myšlenkou tohoto procesu stojí Moses Schönfinkel, takže
se uvažovalo, že se tento proces bude nazývat &bdquo;Schönfinkelisation&ldquo;.
To by bylo asi férovější, ovšem uznejte sami, že se nejedná o tak snadno
zapamatovatelný název, jakým je currying.</div></p>



<p><a name="k02"></a></p>
<h2 id="k02">2. Malá odbočka &ndash; funkce přistupující k&nbsp;symbolům ve svém prostředí (environment)</h2>

<p>Zkusme si tedy ukázat, jak je currying interně implementován. Nejprve si
ovšem ukážeme, že v&nbsp;programovacím jazyku ML je možné vytvářet funkce (ať
již anonymní či pojmenované), které budou akceptovat nějaké parametry, ovšem
navíc budou přistupovat k&nbsp;&bdquo;externím&ldquo; proměnným dostupným
z&nbsp;jejich prostředí (<i>environment</i>). Začneme jednoduchou anonymní
funkcí, která akceptuje jediný parametr <strong>b</strong>, ovšem provádí
výpočet <strong>a+b</strong>, jehož výsledek posléze vrací:</p>

<pre>
<strong>fn b =&gt; a + b;</strong>
</pre>

<p>Tuto funkci nelze zpracovat bez toho, aniž by byla v&nbsp;prostředí
(<i>environment</i>, viz dále) deklarována proměnná <strong>a</strong>, na což
nás překladač správně upozorní:</p>

<pre>
Elaboration failed: Unbound value identifier "a".
</pre>

<p><div class="rs-tip-major">Poznámka: konkrétní chybové hlášení závisí na
použitém dialektu jazyka ML, ovšem význam je zřejmý.</div></p>

<p>Proměnnou <strong>a</strong> však můžeme vytvořit, a to konstrukcí
<strong>val</strong>. V&nbsp;takovém případě je již možné anonymní funkci
zapsat, a to bez nahlášení chyby překladačem:</p>

<pre>
<strong>val a = 10;</strong>
&nbsp;
<strong>fn b =&gt; a + b;</strong>
</pre>

<p>Výsledkem bude hodnota s&nbsp;typem:</p>

<pre>
val it = fn: int → int;
</pre>

<p><div class="rs-tip-major">Poznámka: pro pochopení dalšího textu je užitečné
se naučit číst typ funkce. Zde se konkrétně jedná o funkci akceptující jediný
parametr typu <strong>int</strong> a vracející hodnotu typu
<strong>int</strong>.</div></p>

<p>Po vyhodnocení výrazu jsme sice získali hodnotu typu funkce, ovšem tato
hodnota byla pouze meziuložena do speciální proměnné <strong>it</strong> a bude
brzy ztracena vyhodnocením jakéhokoli dalšího výrazu:</p>

<pre>
<strong>it(100);</strong>
val it = 110: int;
</pre>

<p>Nic nám však nebrání si výsledek, tedy funkci, uložit do proměnné, a de
facto tak deklarovat pojmenovanou funkci:</p>

<pre>
<strong>val a = 10;</strong>
&nbsp;
<strong>val f = fn b =&gt; a + b;</strong>
</pre>

<p>Výsledkem je nyní proměnná <strong>f</strong> s&nbsp;typem:</p>

<pre>
val f = fn: int → int;
</pre>

<p>Z&nbsp;tohoto zápisu již víme, že se jedná o funkci s&nbsp;jediným
parametrem, kterou lze zavolat:</p>

<pre>
<strong>f(20);</strong>
val it = 30: int;
</pre>

<p>Popř.&nbsp;můžeme vytvořit anonymní funkci a ihned ji zavolat, to vše na
jediném řádku:</p>

<pre>
<strong>val a = 10;</strong>
&nbsp;
<strong>(fn b =&gt; a + b)(20);</strong>
val it = 30: int;
</pre>

<p>Nyní již víme, že funkce mohou využívat hodnoty proměnných, které jsou
dostupné z&nbsp;jejich prostředí. Co to konkrétně znamená, se dozvíme později,
ale v&nbsp;jednoduchosti se jedná o proměnné s&nbsp;hodnotou a typem známým
v&nbsp;době tvorby funkce (může se jednat o globální proměnné, parametry
funkce, v&nbsp;jejím rámci je nová funkce definována atd.).</p>



<p><a name="k03"></a></p>
<h2 id="k03">3. Praktické využití curryfikace</h2>

<p>Podívejme se nyní na následující definici funkce <strong>adder</strong>:</p>

<pre>
<strong>fun adder a = fn b =&gt; a + b;</strong>
val adder = fn: int → int → int;
</pre>

<p>Tato funkce je poměrně zajímavá, protože její návratovou hodnotou je další
funkce s&nbsp;jediným parametrem <strong>b</strong>, která provádí výpočet
<strong>a+b</strong> (viz návratový typ <i>fn: int → int → int</i> odvozený a
následně i zobrazený překladačem).</p>

<p><div class="rs-tip-major">Poznámka: operátor → má pravou asociativitu, což
znamená, že zápis <i>fn: int → int → int</i> můžeme číst jako <i>fn: int → (int
→ int)</i>. Mezi další operátory s&nbsp;pravou asociativitou patří operátory
pro spojení seznamů a řetězců: &bdquo;::&ldquo; a &bdquo;@&ldquo;.</div></p>

<p>Samotná funkce <strong>adder</strong> je tedy generátorem dalších funkcí,
které se budou lišit tím, jaký výsledek počítají, a to na základě parametru
<strong>a</strong>, jenž byl do funkce <strong>adder</strong> předán ve chvíli
generování nových funkcí. Pokusme se takové funkce vytvořit (vygenerovat):</p>

<pre>
<strong>val inc = adder 1;</strong>
<strong>val inc2 = adder 2;</strong>
</pre>

<p>V&nbsp;předchozím příkladu jsme si nechali vygenerovat dvojici nových funkcí
nazvaných <strong>inc</strong> a <strong>inc2</strong>, jejichž typy odvozené
překladačem jsou:</p>

<pre>
val inc = fn: int → int;
val inc2 = fn: int → int;
</pre>

<p>Jedná se tedy o &bdquo;běžné&ldquo; funkce s&nbsp;jediným parametrem (a
pochopitelně i návratovou hodnotou), které lze běžným způsobem zavolat:</p>

<pre>
<strong>inc 10;</strong>
val it = 11: int;
&nbsp;
<strong>inc2 10;</strong>
val it = 12: int;
</pre>

<p>Můžeme zde vidět, že každá z&nbsp;těchto funkcí provedla odlišný výpočet, a
to z&nbsp;toho důvodu, že si každá funkce pamatuje odlišnou hodnotu
<strong>a</strong> získanou při vytvoření těchto funkcí. Stále však platí, že
se jedná o referenčně transparentní funkce &ndash; jejich návratové hodnoty
plně závisí pouze na předaném parametru.</p>

<p>To však není vše a právě zde se dostáváme k&nbsp;curryingu.
V&nbsp;programovacím jazyce ML je důležité, že zápis funkce
<strong>adder</strong>, který jsme použili výše:</p>

<pre>
<strong>fun adder a = fn b =&gt; a + b;</strong>
val adder = fn: int → int → int;
</pre>

<p>...je možné přepsat do zjednodušené podoby:</p>

<pre>
<strong>fun adder a b = a + b;</strong>
val adder = fn: int → int → int;
</pre>

<p>Už z&nbsp;typů obou funkcí je zřejmé, že jde o totožnou sémantiku.</p>

<p><div class="rs-tip-major">Poznámka: na celý problém se můžeme podívat i naopak &ndash; lze říci, že takto definované funkce s&nbsp;větším počtem parametrů se interně reprezentují funkcí s&nbsp;jediným parametrem, které vrací jinou funkci, která na sebe naváže druhý parametr (a tato funkce popř.&nbsp;vrací další funkci navazující třetí parametr atd.):</div></p>



<pre>
fun pow(m, n) = if n = 0 then 1
                else m * pow(m, n-1);

</pre>

<pre>
pow(2, 8);
val it = 256: int;
&nbsp;
pow(3, 2);
val it = 9: int;
</pre>

<pre>
(* Implementace funkce map *)

fun map f [] = []
  | map f (head::tail) = (f head) :: (map f tail);


fun half x = x / 2.0;

map half [1.0,2.0,3.0,4.0,5.0];
</pre>



<p><a name="k03"></a></p>
<h2 id="k03">3. Generování funkcí pro výpočet n-té mocniny</h2>

<pre>
fun pow m n = if m = 0 then 1
              else n * pow(m-1) n;
</pre>

<pre>
val pow = fn: int → int → int;
</pre>

<pre>
val square = pow 2;
val cube = pow 3;
</pre>

<pre>
val square = fn: int → int;
val cube = fn: int → int;
</pre>

<pre>
square 10;
cube 10;
</pre>

<pre>
fun pow 0 n = 1
  | pow m n = n * pow(m-1) n;
</pre>



<p><a name="k04"></a></p>
<h2 id="k04">4. Proměnné a prostředí</h2>

<pre>
val x = 1 : int
&nbsp;
fun incr y = x + y;
&nbsp;
incr 1;
&nbsp;
val x = 10;
incr 1;
</pre>

<p>Po spuštění tohoto prográmku by se měly na terminál vypsat tyto řádky:</p>

<pre>
val x = 1: int;
&nbsp;
val incr = fn: int → int;
&nbsp;
val it = 2: int;
&nbsp;
val x = 10: int;
&nbsp;
val it = 2: int;
</pre>

<p>Tyto řádky postupně znamenají:</p>

<table>
<tr><th></th><th></th></tr>
<tr><td></td><td></td></tr>
</table>

<p>Důležité je si uvědomit, že ve funkci <strong>incr</strong> ve skutečnosti nepracujeme přímo s&nbsp;původní proměnnou <strong>x</strong>. Namísto toho je v&nbsp;aktuálním <i>prostředí</i> (<i>environment</i>) vytvořena vazba na původní hodnotu (a typ). Výsledkem toho je fakt, že další změny proměnné <strong>x</strong> příkazem <strong>val</strong> nemají žádný vliv na to, jakou hodnotu vrátí funkce <strong>incr</strong>. Jediný vliv na návratovou hodnotu bude mít hodnota argumentu této funkce v&nbsp;čase jejího volání. Jinými slovy &ndash; tato vlastnost nejenom zabraňuje nepříjemným zmatkům, ale především zajišťuje <i>referenční transparentnost</i> funkcí, což je (nejenom) ve funkcionálním programování velmi důležitá vlastnost.</p>

<p><div class="rs-tip-major">Poznámka: současně nám ovšem tato vlastnost nezabraňuje měnit hodnotu proměnné, <strong>x</strong> je tedy stále měnitelná (<i>mutable</i>).</div></p>



<p><a name="k05"></a></p>
<h2 id="k05">5. Konstrukce <strong>let</strong></h2>

scheme

<pre>
let
    val x = 10
in
    2*x
end;
</pre>

celé je to výraz!

<pre>
let
    val x = 10
in
    2*x
end + 1;
</pre>

<p>Příklad složitějšího výrazu s&nbsp;blokem <strong>let</strong>:</p>

<pre>
<strong>val i = 10</strong>
<strong>val j : real = 10.0</strong>
<strong>val k = i</strong>
&nbsp;
<strong>val lexpr =</strong>
  <strong>let val x = 1</strong>
      <strong>val y = 2</strong>
  <strong>in x + y</strong>
  <strong>end;</strong>
&nbsp;
val lexpr = 3 : int
</pre>

<p><div class="rs-tip-major">Poznámka: zde mají lokální symboly
<strong>x</strong> a <strong>y</strong> pochopitelně přednost před symboly
vnějšími.</div></p>

<p>V&nbsp;případě, že vně bloku již existuje proměnná <strong>x</strong>, je
její hodnota a typ zachována:</p>

<pre>
<strong>val x = "foobar";</strong>
val x = "foobar": string;
&nbsp;
<strong>x;</strong>
val it = "foobar": string;
&nbsp;
<strong>let</strong>
    <strong>val x = 10</strong>
<strong>in</strong>
    <strong>2*x</strong>
<strong>end;</strong>
val it = 20: int;
&nbsp;
<strong>x;</strong>
val it = "foobar": string;
</pre>

<p>Na druhou stranu proměnné definované vně bloku jsou v&nbsp;tomto bloku
dostupné &ndash; viz použití proměnné <strong>z</strong> uvnitř bloku:</p>

<pre>
<strong>val z = 2;</strong>
&nbsp;
<strong>let</strong>
    <strong>val x = 10</strong>
<strong>in</strong>
    <strong>z*x</strong>
<strong>end;</strong>
&nbsp;
val it = 20: int;
</pre>



<p><a name="k09"></a></p>
<h2 id="k09">9. Konstrukce <strong>let</strong> v&nbsp;těle funkce</h2>

<p>S&nbsp;výše popsaným blokem <strong>let</strong> se velmi často setkáme při
tvorbě složitějších funkcí. Například v&nbsp;následující funkci, která má
vypočítat vzdálenost bodu [x,y] od počátku souřadné soustavy, využijeme dvou
mezivýpočtů, což sice funkci prodlouží, ale pojmenování výsledků mezivýpočtů
zde má (mj.) i dokumentační efekt:</p>

<pre>
<strong>fun distance(x, y) =</strong>
<strong>let</strong>
    <strong>val squaredx = x*x</strong>
    <strong>val squaredy = y*y</strong>
<strong>in</strong>
    <strong>Math.sqrt(squaredx + squaredy)</strong>
<strong>end;</strong>
</pre>

<p>Otestování základní funkcionality:</p>

<pre>
<strong>distance(1.0, 1.0);</strong>
val it = 1.4142135623730951: real;
</pre>



<p><a name="k10"></a></p>
<h2 id="k10">10. Blok příkazů (s&nbsp;vedlejším efektem)</h2>

<p>V&nbsp;programovacím jazyku ML lze vytvářet popř.&nbsp;volat funkce
s&nbsp;vedlejším efektem. Nejedná se tedy o referenčně transparentní funkce,
ovšem na druhou stranu jde o praktický nástroj určený pro použití
v&nbsp;reálných programech. Takovou typickou funkcí s&nbsp;vedlejším efektem je
funkce <strong>print</strong>:</p>

<pre>
<strong>print 42;</strong>
</pre>

<p><a name="k06"></a></p>
<h2 id="k06">6. Konstrukce <strong>let</strong> v&nbsp;těle funkce</h2>

<pre>
fun distance(x, y) =
let
    val squaredx = x*x
    val squaredy = y*y
in
    Math.sqrt(squaredx + squaredy)
end;
</pre>

<p>S&nbsp;funkcemi s&nbsp;vedlejším efektem souvisí i bloky příkazů, které u
referenčně transparentních funkcí postrádají smysl. Blok příkazů je zapisován
do kulatých závorek stylem:</p>

<pre>
(&lt;expression&gt;;&lt;expression&gt;;...)
</pre>

<p>Podívejme se na příklad použití &ndash; rozšíříme funkce
<strong>distance</strong> o výpis mezivýsledků při jejím zavolání:</p>

<pre>
<strong>fun distance(x, y) =</strong>
<strong>let</strong>
    <strong>val squaredx = x*x</strong>
    <strong>val squaredy = y*y</strong>
<strong>in</strong>
  <strong>(</strong>
    <strong>print("Squared x=", x);</strong>
    <strong>print("Squared y=", y);</strong>
    <strong>Math.sqrt(squaredx + squaredy)</strong>
  <strong>)</strong>
<strong>end;</strong>
</pre>

val lexpr =
  let val x = 1
      val y = 2
  in x + y
  end
val lexpr = 3 : int

<pre>
<strong>distance(1.0, 1.0);</strong>
Printed: ("Squared x=", 1.0)
Printed: ("Squared y=", 1.0)
val it = 1.4142135623730951: real;
</pre>

<p><div class="rs-tip-major">Poznámka: některé varianty programovacího jazyka
ML nejdříve vypíšou výsledek funkce a teprve poté výsledek volání
<strong>print</strong>.</div></p>



<p><a name="k11"></a></p>
<h2 id="k11">11. Koncept výjimek v&nbsp;jazyku ML</h2>

<p></p>

Exceptions
- exception Nomatch;
- raide Jmeno;

exception Nomatch;

fun member(a, []) = raise Nomatch
 |  member(a, b::y) = if a == b then b::y
                      else memeber(a, y);

<epxression1> handle <exception_name> => <expression2>

fun check(a,x) = member(a, x) handle Nomatch =>
   (print("error!"); []);



<p><a name="k11"></a></p>
<h2 id="k11">11. Standardní operátory</h2>

operator = funkce
<expr> <op> <expr>
syntakticky cukr k zapisu
<op>(<expr>, <expr>)



<p><a name="k12"></a></p>
<h2 id="k12">12. Definice vlastních operátorů</h2>

priorita n
leva prava asociativita
infix n id1, ... idn
infixr n id1, ... idn

infix  7  * / div mod
infix  6  + - ^
infixr 5  :: @
infix  4  = <> > >= < <=
infix  3  := o
infix  0  before


infix 8 pow;

fun pow(m, 0) = 1
  | pow(m, n) = m * pow(m, n-1);


infix 8 pow;

2 pow 3;
2 pow 3 + 1;



<p><a name="k13"></a></p>
<h2 id="k13">13. Změna priority a asociativity operátorů</h2>


fun exists(element, []) = false
  | exists(element, head::tail) = if element = head then true
                                  else exists(element, tail);


exists(2, [1,2,3]);
exists(0, [1,2,3]);
exists(42, [42]);
exists(42, []);

fun exists(element, []) = false
  | exists(element, head::tail) = if element = head then true
                                  else exists(element, tail);

infix 1 exists;


2 exists [1,2,3];
0 exists [1,2,3];
42 exists [42];
42 exists [];

fun exists(element, []) = false
  | exists(element, head::tail) = if element = head then true
                                  else exists(element, tail);

infix 1 exists;


1+1 exists [1,2,3];
3*1 exists [1,2,3];

1+1 exists [1,2] @ [3,4];



<p><a name="k14"></a></p>
<h2 id="k14">14. Řídicí konstrukce</h2>

řídicí konstrukce
-------------------
v ML je program výrazem
což platí i pro podmínky atd.



<p><a name="k12"></a></p>
<h2 id="k12">12. </h2>

basic type
functional type
product type
list type

type tuples
-----------
int * string
product a*b (ntice)
pár (a,b)
(1, "one")

a*b*c (ntice)
(1, "one", 3.14)

-------------
"promenne"
vazba (asociace, binding) jmeno:typ -> hodnota:typ
v aktualnim prostredi (environment)


Blok příkazů
============

Unit
-----
neco jako void
jedina hodnota ()
pro funkce "bez argumentu"

fun hello() = "Hello world!";

jenze to neni pravda, tato funkce akceptuje/vyzaduje
jeden argument, prave unit

hello();


* composition

Poznámka: 

datatype bool = false | true
val not : bool -> bool
val toString : bool -> string
val scan       : (char, 'a) StringCvt.reader
                   -> (bool, 'a) StringCvt.reader
val fromString : string -> bool option


datatype 'a list = nil | :: of 'a * 'a list
exception Empty





<p><a name="k15"></a></p>
<h2 id="k15">15. </h2>



<p><a name="k16"></a></p>
<h2 id="k16">16. </h2>



<p><a name="k17"></a></p>
<h2 id="k17">17. </h2>



<p><a name="k18"></a></p>
<h2 id="k18">18. Repositář s&nbsp;demonstračními příklady</h2>

<p>Všechny výše popsané demonstrační příklady byly uloženy do repositáře
dostupného na adrese <a
href="https://github.com/tisnik/ml-examples/">https://github.com/tisnik/ml-examples/</a>.
V&nbsp;tabulce umístěné pod tímto odstavcem jsou uvedeny odkazy na tyto
příklady:</p>

<table>
<tr><th> #</th><th>Příklad</th><th>Popis příkladu</th><th>Cesta</th></tr>
<tr><td> 1</td><td>01_currying1.ml</td><td>anonymní funkce přistupující k&nbsp;proměnné uložené v&nbsp;jejím prostředí</td><td><a href="https://github.com/tisnik/ml-examples/tree/master/article_03/01_currying1.ml">https://github.com/tisnik/ml-examples/tree/master/article_03/01_currying1.ml</a></td></tr>
<tr><td> 2</td><td>02_currying2.ml</td><td>anonymní funkce přistupující k&nbsp;proměnné uložené v&nbsp;jejím prostředí</td><td><a href="https://github.com/tisnik/ml-examples/tree/master/article_03/02_currying2.ml">https://github.com/tisnik/ml-examples/tree/master/article_03/02_currying2.ml</a></td></tr>
<tr><td> 3</td><td>03_currying3.ml</td><td>předchozí příklad, ovšem zapsaný na jediném řádku</td><td><a href="https://github.com/tisnik/ml-examples/tree/master/article_03/03_currying3.ml">https://github.com/tisnik/ml-examples/tree/master/article_03/03_currying3.ml</a></td></tr>
<tr><td> 4</td><td>04_currying4.ml</td><td>částečná aplikace funkce</td><td><a href="https://github.com/tisnik/ml-examples/tree/master/article_03/04_currying4.ml">https://github.com/tisnik/ml-examples/tree/master/article_03/04_currying4.ml</a></td></tr>
<tr><td> 5</td><td>05_pow_curry1.ml</td><td>generátor funkce pro výpočet n-té mocniny</td><td><a href="https://github.com/tisnik/ml-examples/tree/master/article_03/05_pow_curry1.ml">https://github.com/tisnik/ml-examples/tree/master/article_03/05_pow_curry1.ml</a></td></tr>
<tr><td> 6</td><td>06_pow_curry2.ml</td><td>generátor funkce pro výpočet n-té mocniny, verze s&nbsp;pattern matchingem</td><td><a href="https://github.com/tisnik/ml-examples/tree/master/article_03/06_pow_curry2.ml">https://github.com/tisnik/ml-examples/tree/master/article_03/06_pow_curry2.ml</a></td></tr>
<tr><td> 7</td><td>07_currying_4_params.ml</td><td>currying funkce se čtyřmi parametry, verze s neanonymní funkcí, zápis se závorkami</td><td><a href="https://github.com/tisnik/ml-examples/tree/master/article_03/07_currying_4_params.ml">https://github.com/tisnik/ml-examples/tree/master/article_03/07_currying_4_params.ml</a></td></tr>
<tr><td> 8</td><td>08_currying_4_params.ml</td><td>currying funkce se čtyřmi parametry, verze s neanonymní funkcí, zápis bez závorek</td><td><a href="https://github.com/tisnik/ml-examples/tree/master/article_03/08_currying_4_params.ml">https://github.com/tisnik/ml-examples/tree/master/article_03/08_currying_4_params.ml</a></td></tr>
<tr><td> 9</td><td>09_environment.ml</td><td></td><td><a href="https://github.com/tisnik/ml-examples/tree/master/article_03/09_environment.ml">https://github.com/tisnik/ml-examples/tree/master/article_03/09_environment.ml</a></td></tr>
<tr><td>10</td><td>10_distance.ml</td><td></td><td><a href="https://github.com/tisnik/ml-examples/tree/master/article_03/10_distance.ml">https://github.com/tisnik/ml-examples/tree/master/article_03/10_distance.ml</a></td></tr>
<tr><td>11</td><td>11_exceptions1.ml</td><td></td><td><a href="https://github.com/tisnik/ml-examples/tree/master/article_03/11_exceptions1.ml">https://github.com/tisnik/ml-examples/tree/master/article_03/11_exceptions1.ml</a></td></tr>
<tr><td>12</td><td>12_exceptions2.ml</td><td></td><td><a href="https://github.com/tisnik/ml-examples/tree/master/article_03/12_exceptions2.ml">https://github.com/tisnik/ml-examples/tree/master/article_03/12_exceptions2.ml</a></td></tr>
<tr><td>13</td><td>13_increment.ml</td><td></td><td><a href="https://github.com/tisnik/ml-examples/tree/master/article_03/13_increment.ml">https://github.com/tisnik/ml-examples/tree/master/article_03/13_increment.ml</a></td></tr>
<tr><td>14</td><td>14_increment.ml</td><td></td><td><a href="https://github.com/tisnik/ml-examples/tree/master/article_03/14_increment.ml">https://github.com/tisnik/ml-examples/tree/master/article_03/14_increment.ml</a></td></tr>
<tr><td>15</td><td>15_let3.ml</td><td></td><td><a href="https://github.com/tisnik/ml-examples/tree/master/article_03/15_let3.ml">https://github.com/tisnik/ml-examples/tree/master/article_03/15_let3.ml</a></td></tr>
<tr><td>16</td><td>16_pow_operator.ml</td><td></td><td><a href="https://github.com/tisnik/ml-examples/tree/master/article_03/16_pow_operator.ml">https://github.com/tisnik/ml-examples/tree/master/article_03/16_pow_operator.ml</a></td></tr>
<tr><td>17</td><td>17_simple_let_1.ml</td><td></td><td><a href="https://github.com/tisnik/ml-examples/tree/master/article_03/17_simple_let_1.ml">https://github.com/tisnik/ml-examples/tree/master/article_03/17_simple_let_1.ml</a></td></tr>
<tr><td>18</td><td>18_simple_let_2.ml</td><td></td><td><a href="https://github.com/tisnik/ml-examples/tree/master/article_03/18_simple_let_2.ml">https://github.com/tisnik/ml-examples/tree/master/article_03/18_simple_let_2.ml</a></td></tr>
<tr><td>19</td><td>19_exists.ml</td><td></td><td><a href="https://github.com/tisnik/ml-examples/tree/master/article_03/19_exists.ml">https://github.com/tisnik/ml-examples/tree/master/article_03/19_exists.ml</a></td></tr>
<tr><td>20</td><td>20_pow_associativity.ml</td><td></td><td><a href="https://github.com/tisnik/ml-examples/tree/master/article_03/20_pow_associativity.ml">https://github.com/tisnik/ml-examples/tree/master/article_03/20_pow_associativity.ml</a></td></tr>
<tr><td>21</td><td>21_exists1.ml</td><td></td><td><a href="https://github.com/tisnik/ml-examples/tree/master/article_03/21_exists1.ml">https://github.com/tisnik/ml-examples/tree/master/article_03/21_exists1.ml</a></td></tr>
<tr><td>22</td><td>22_exists2.ml</td><td></td><td><a href="https://github.com/tisnik/ml-examples/tree/master/article_03/22_exists2.ml">https://github.com/tisnik/ml-examples/tree/master/article_03/22_exists2.ml</a></td></tr>
<tr><td>23</td><td>23_exists3.ml</td><td></td><td><a href="https://github.com/tisnik/ml-examples/tree/master/article_03/23_exists3.ml">https://github.com/tisnik/ml-examples/tree/master/article_03/23_exists3.ml</a></td></tr>
</table>



<p><a name="k19"></a></p>
<h2 id="k19">19. Literatura</h2>

<p><div class="rs-tip-major">Poznámka: v&nbsp;této kapitole jsou uvedeny
nejenom knihy o jazyku ML resp.&nbsp;Standard ML, ale i knihy o programovacím
jazyku OCaml, který ze Standard ML ze značné míry vychází.</div></p>

<ol>

<li>ML for the Working Programmer<br />
<a href="https://www.cl.cam.ac.uk/~lp15/MLbook/pub-details.html">https://www.cl.cam.ac.uk/~lp15/MLbook/pub-details.html</a>
</li>

<li>Elements of ML Programming, 2nd Edition (ML97)<br />
<a href="http://infolab.stanford.edu/~ullman/emlp.html">http://infolab.stanford.edu/~ullman/emlp.html</a>
</li>

<li>A tour of Standard ML<br />
<a href="https://saityi.github.io/sml-tour/tour/welcome">https://saityi.github.io/sml-tour/tour/welcome</a>
</li>

<li>The History of Standard ML<br />
<a href="https://smlfamily.github.io/history/SML-history.pdf">https://smlfamily.github.io/history/SML-history.pdf</a>
</li>

<li>The Standard ML Basis Library<br />
<a href="https://smlfamily.github.io/Basis/">https://smlfamily.github.io/Basis/</a>
</li>

<li>Programming in Standard ML<br />
<a href="http://www.cs.cmu.edu/~rwh/isml/book.pdf">http://www.cs.cmu.edu/~rwh/isml/book.pdf</a>
</li>

<li>Programming in Standard ML '97: A Tutorial Introduction<br />
<a href="http://www.lfcs.inf.ed.ac.uk/reports/97/ECS-LFCS-97-364/">http://www.lfcs.inf.ed.ac.uk/reports/97/ECS-LFCS-97-364/</a>
</li>

<li>Programming in Standard ML '97: An On-line Tutorial<br />
<a href="https://homepages.inf.ed.ac.uk/stg/NOTES/">https://homepages.inf.ed.ac.uk/stg/NOTES/</a>
</li>

<li>The OCaml system  release 4.13<br />
<a href="https://ocaml.org/releases/4.13/htmlman/index.html">https://ocaml.org/releases/4.13/htmlman/index.html</a>
</li>

<li>Real World OCaml: Functional programming for the masses<br />
<a href="https://dev.realworldocaml.org/">https://dev.realworldocaml.org/</a>
</li>

<li>OCaml from the Very Beginning<br />
<a href="http://ocaml-book.com/">http://ocaml-book.com/</a>
</li>

<li>OCaml from the Very Beginning: More OCaml : Algorithms, Methods &amp; Diversions<br />
<a href="http://ocaml-book.com/more-ocaml-algorithms-methods-diversions/">http://ocaml-book.com/more-ocaml-algorithms-methods-diversions/</a>
</li>

<li>Unix system programming in OCaml<br />
<a href="http://ocaml.github.io/ocamlunix/">http://ocaml.github.io/ocamlunix/</a>
</li>

<li>OCaml for Scientists<br />
<a href="https://www.ffconsultancy.com/products/ocaml_for_scientists/index.html">https://www.ffconsultancy.com/products/ocaml_for_scientists/index.html</a>
</li>

<li>Using, Understanding, and Unraveling The OCaml Language<br />
<a href="https://caml.inria.fr/pub/docs/u3-ocaml/">https://caml.inria.fr/pub/docs/u3-ocaml/</a>
</li>

<li>Developing Applications With objective Caml<br />
<a href="https://caml.inria.fr/pub/docs/oreilly-book/index.html">https://caml.inria.fr/pub/docs/oreilly-book/index.html</a>
</li>

<li>Introduction to Objective Caml<br />
<a href="http://courses.cms.caltech.edu/cs134/cs134b/book.pdf">http://courses.cms.caltech.edu/cs134/cs134b/book.pdf</a>
</li>

<li>How to Think Like a (Functional) Programmer<br />
<a href="https://greenteapress.com/thinkocaml/index.html">https://greenteapress.com/thinkocaml/index.html</a>
</li>

</ol>



<p><a name="k20"></a></p>
<h2 id="k20">20. Odkazy na Internetu</h2>

<ol>

<li>Standard ML of New Jersey<br />
<a href="https://www.smlnj.org/">https://www.smlnj.org/</a>
</li>

<li>Programming Languages: Standard ML - 1 (a navazující videa)<br />
<a href="https://www.youtube.com/watch?v=2sqjUWGGzTo">https://www.youtube.com/watch?v=2sqjUWGGzTo</a>
</li>

<li>6 Excellent Free Books to Learn Standard ML<br />
<a href="https://www.linuxlinks.com/excellent-free-books-learn-standard-ml/">https://www.linuxlinks.com/excellent-free-books-learn-standard-ml/</a>
</li>

<li>SOSML: The Online Interpreter for Standard ML<br />
<a href="https://sosml.org/">https://sosml.org/</a>
</li>

<li>ML (Computer program language)<br />
<a href="https://www.barnesandnoble.com/b/books/other-programming-languages/ml-computer-program-language/_/N-29Z8q8Zvy7">https://www.barnesandnoble.com/b/books/other-programming-languages/ml-computer-program-language/_/N-29Z8q8Zvy7</a>
</li>

<li>Strong Typing<br />
<a href="https://perl.plover.com/yak/typing/notes.html">https://perl.plover.com/yak/typing/notes.html</a>
</li>

<li>What to know before debating type systems<br />
<a href="http://blogs.perl.org/users/ovid/2010/08/what-to-know-before-debating-type-systems.html">http://blogs.perl.org/users/ovid/2010/08/what-to-know-before-debating-type-systems.html</a>
</li>

<li>Types, and Why You Should Care (Youtube)<br />
<a href="https://www.youtube.com/watch?v=0arFPIQatCU">https://www.youtube.com/watch?v=0arFPIQatCU</a>
</li>

<li>DynamicTyping (Martin Fowler)<br />
<a href="https://www.martinfowler.com/bliki/DynamicTyping.html">https://www.martinfowler.com/bliki/DynamicTyping.html</a>
</li>

<li>DomainSpecificLanguage (Martin Fowler)<br />
<a href="https://www.martinfowler.com/bliki/DomainSpecificLanguage.html">https://www.martinfowler.com/bliki/DomainSpecificLanguage.html</a>
</li>

<li>Language Workbenches: The Killer-App for Domain Specific Languages?<br />
<a href="https://www.martinfowler.com/articles/languageWorkbench.html">https://www.martinfowler.com/articles/languageWorkbench.html</a>
</li>

<li>Effective ML (Youtube)<br />
<a href="https://www.youtube.com/watch?v=-J8YyfrSwTk">https://www.youtube.com/watch?v=-J8YyfrSwTk</a>
</li>

<li>Why OCaml (Youtube)<br />
<a href="https://www.youtube.com/watch?v=v1CmGbOGb2I">https://www.youtube.com/watch?v=v1CmGbOGb2I</a>
</li>

<li>CSE 341: Functions and patterns<br />
<a href="https://courses.cs.washington.edu/courses/cse341/04wi/lectures/03-ml-functions.html">https://courses.cs.washington.edu/courses/cse341/04wi/lectures/03-ml-functions.html</a>
</li>

<li>Comparing Objective Caml and Standard ML<br />
<a href="http://adam.chlipala.net/mlcomp/">http://adam.chlipala.net/mlcomp/</a>
</li>

<li>What are the key differences between Standard ML and OCaml?<br />
<a href="https://www.quora.com/What-are-the-key-differences-between-Standard-ML-and-OCaml?share=1">https://www.quora.com/What-are-the-key-differences-between-Standard-ML-and-OCaml?share=1</a>
</li>

<li>Cheat Sheets (pro OCaml)<br />
<a href="https://www.ocaml.org/docs/cheat_sheets.html">https://www.ocaml.org/docs/cheat_sheets.html</a>
</li>

<li>Syllabus (FAS CS51)<br />
<a href="https://cs51.io/college/syllabus/">https://cs51.io/college/syllabus/</a>
</li>

<li>Abstraction and Design In Computation<br />
<a href="http://book.cs51.io/">http://book.cs51.io/</a>
</li>

<li>Learn X in Y minutes Where X=Standard ML<br />
<a href="https://learnxinyminutes.com/docs/standard-ml/">https://learnxinyminutes.com/docs/standard-ml/</a>
</li>

<li>CSE307 Online - Summer 2018: Principles of Programing Languages course<br />
<a href="https://www3.cs.stonybrook.edu/~pfodor/courses/summer/cse307.html">https://www3.cs.stonybrook.edu/~pfodor/courses/summer/cse307.html</a>
</li>

<li>CSE307 Principles of Programming Languages course: SML part 1<br />
<a href="https://www.youtube.com/watch?v=p1n0_PsM6hw">https://www.youtube.com/watch?v=p1n0_PsM6hw</a>
</li>

<li>CSE 307 &ndash; Principles of Programming Languages &ndash; SML<br />
<a href="https://www3.cs.stonybrook.edu/~pfodor/courses/summer/CSE307/L01_SML.pdf">https://www3.cs.stonybrook.edu/~pfodor/courses/summer/CSE307/L01_SML.pdf</a>
</li>

<li>SML, Some Basic Examples<br />
<a href="https://cs.fit.edu/~ryan/sml/intro.html">https://cs.fit.edu/~ryan/sml/intro.html</a>
</li>

<li>History of programming languages<br />
<a href="https://devskiller.com/history-of-programming-languages/">https://devskiller.com/history-of-programming-languages/</a>
</li>

<li>History of programming languages (Wikipedia)<br />
<a href="https://en.wikipedia.org/wiki/History_of_programming_languages">https://en.wikipedia.org/wiki/History_of_programming_languages</a>
</li>

<li>Jemný úvod do rozsáhlého světa jazyků LISP a Scheme<br />
<a href="https://www.root.cz/clanky/jemny-uvod-do-rozsahleho-sveta-jazyku-lisp-a-scheme/">https://www.root.cz/clanky/jemny-uvod-do-rozsahleho-sveta-jazyku-lisp-a-scheme/</a>
</li>

<li>The Evolution Of Programming Languages<br />
<a href="https://www.i-programmer.info/news/98-languages/8809-the-evolution-of-programming-languages.html">https://www.i-programmer.info/news/98-languages/8809-the-evolution-of-programming-languages.html</a>
</li>

<li>Evoluce programovacích jazyků<br />
<a href="https://ccrma.stanford.edu/courses/250a-fall-2005/docs/ComputerLanguagesChart.png">https://ccrma.stanford.edu/courses/250a-fall-2005/docs/ComputerLanguagesChart.png</a>
</li>

<li>Poly/ML Homepage<br />
<a href="https://polyml.org/">https://polyml.org/</a>
</li>

<li>PolyConf 16: A brief history of F# / Rachel Reese<br />
<a href="https://www.youtube.com/watch?v=cbDjpi727aY">https://www.youtube.com/watch?v=cbDjpi727aY</a>
</li>

<li>Programovací jazyk Clojure 18: základní techniky optimalizace aplikací<br />
<a href="https://www.root.cz/clanky/programovaci-jazyk-clojure-18-zakladni-techniky-optimalizace-aplikaci/">https://www.root.cz/clanky/programovaci-jazyk-clojure-18-zakladni-techniky-optimalizace-aplikaci/</a>
</li>

<li>Moscow ML Language Overview<br />
<a href="https://itu.dk/people/sestoft/mosml/mosmlref.pdf">https://itu.dk/people/sestoft/mosml/mosmlref.pdf</a>
</li>

<li>ForLoops<br />
<a href="http://mlton.org/ForLoops">http://mlton.org/ForLoops</a>
</li>

<li>Funkcionální dobrodružství v&nbsp;JavaScriptu<br />
<a href="https://blog.kolman.cz/2015/12/funkcionalni-dobrodruzstvi-v-javascriptu.html">https://blog.kolman.cz/2015/12/funkcionalni-dobrodruzstvi-v-javascriptu.html</a>
</li>

<li>Recenze knihy Functional Thinking (Paradigm over syntax)<br />
<a href="https://www.root.cz/clanky/recenze-knihy-functional-thinking-paradigm-over-syntax/">https://www.root.cz/clanky/recenze-knihy-functional-thinking-paradigm-over-syntax/</a>
</li>

<li>Currying<br />
<a href="https://sw-samuraj.cz/2011/02/currying/">https://sw-samuraj.cz/2011/02/currying/</a>
</li>

<li>Používání funkcí v&nbsp;F#<br />
<a href="https://docs.microsoft.com/cs-cz/dotnet/fsharp/tutorials/using-functions">https://docs.microsoft.com/cs-cz/dotnet/fsharp/tutorials/using-functions</a>
</li>

<li>Funkce vyššího řádu<br />
<a href="http://naucte-se.haskell.cz/funkce-vyssiho-radu">http://naucte-se.haskell.cz/funkce-vyssiho-radu</a>
</li>

<li>Currying (Wikipedia)<br />
<a href="https://en.wikipedia.org/wiki/Currying">https://en.wikipedia.org/wiki/Currying</a>
</li>

<li>Currying (Haskell wiki)<br />
<a href="https://wiki.haskell.org/Currying">https://wiki.haskell.org/Currying</a>
</li>

<li>Haskell Curry<br />
<a href="https://en.wikipedia.org/wiki/Haskell_Curry">https://en.wikipedia.org/wiki/Haskell_Curry</a>
</li>

<li>Moses Schönfinkel<br />
<a href="https://en.wikipedia.org/wiki/Moses_Sch%C3%B6nfinkel">https://en.wikipedia.org/wiki/Moses_Sch%C3%B6nfinkel</a>
</li>

</ol>



<p></p><p></p>
<p><small>Autor: <a href="http://www.fit.vutbr.cz/~tisnovpa">Pavel Tišnovský</a> &nbsp; 2022</small></p>
</body>
</html>

