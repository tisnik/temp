<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
        "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html>
<head>
<title>Rekurzivní datové typy v jazyku OCaml</title>
<meta name="Author" content="Pavel Tisnovsky" />
<meta name="Generator" content="vim" />
<meta http-equiv="content-type" content="text/html; charset=utf-8" />
<style type="text/css">
         body {color:#000000; background:#ffffff;}
         h1  {font-family: arial, helvetica, sans-serif; color:#ffffff; background-color:#c00000; text-align:center; padding-left:1em}
         h2  {font-family: arial, helvetica, sans-serif; color:#ffffff; background-color:#0000c0; padding-left:1em; text-align:left}
         h3  {font-family: arial, helvetica, sans-serif; color:#000000; background-color:#c0c0c0; padding-left:1em; text-align:left}
         h4  {font-family: arial, helvetica, sans-serif; color:#000000; background-color:#e0e0e0; padding-left:1em; text-align:left}
         a   {font-family: arial, helvetica, sans-serif;}
         li  {font-family: arial, helvetica, sans-serif; color:#000000; text-align:justify; width:450px;}
         ol  {font-family: arial, helvetica, sans-serif; color:#000000; text-align:justify; width:450px;}
         ul  {font-family: arial, helvetica, sans-serif; color:#000000; text-align:justify; width:450px;}
         p   {font-family: arial, helvetica, sans-serif; color:#000000; text-align:justify;}
         pre {background:#e0e0e0}
</style>
</head>

<body>

<h1>Rekurzivní datové typy v jazyku OCaml</h1>

<h3>Pavel Tišnovský</h3>

<p></p>

<h1>Úvodník</h1>

<p>V dnešním článku o programovacím jazyku OCaml se ještě jednou vrátíme k typovému systému tohoto zajímavého jazyka. Ukážeme si, jak lze realizovat datový typ pro reprezentaci barvy, a to v různých barvových modelech. Řešení nebude založeno na objektech, ale na pattern matchingu.</p>



<h2>Obsah</h2>

<p><a href="#k01">1. Definice výčtového typu s&nbsp;osmi základními barvami</a></p>
<p><a href="#k02">2. Nový unifikovaný typ <strong>color</strong> a funkce pro převod barvy na trojici složek RGB</a></p>
<p><a href="#k03">3. Realizace převodu všech základních barev na RGB</a></p>
<p><a href="#k04">4. Přidání podpory pro stupně šedi</a></p>
<p><a href="#k05">5. Úplný zdrojový kód druhé varianty příkladu</a></p>
<p><a href="#k06">6. Reprezentace obecné barvy v&nbsp;barvovém prostoru RGB</a></p>
<p><a href="#k07">7. Detekce chybějící větve ve funkci <strong>to_rgb</strong></a></p>
<p><a href="#k08">8. Doplnění funkce pro převod jakékoli barvy do barvového prostoru RGB</a></p>
<p><a href="#k09">9. Přidání možnosti modifikace základních barev o atribut <i>světlost</i></a></p>
<p><a href="#k10">10. Zjednodušení výpočtu tmavší varianty základních barev</a></p>
<p><a href="#k11">11. Malá odbočka: převod mezi barvovými modely HSV a RGB</a></p>
<p><a href="#k12">12. Realizace algoritmu převodu HSV do RGB v&nbsp;jazyku Python</a></p>
<p><a href="#k13">13. Realizace algoritmu převodu HSV do RGB v&nbsp;jazyku OCaml</a></p>
<p><a href="#k14">14. Přidání barev v&nbsp;prostoru HSV do našeho typového systému</a></p>
<p><a href="#k15">15. Důsledné využití zjednodušeného zápisu funkcí obsahujících jen pattern matching</a></p>
<p><a href="#k16">16. Poslední typ barvy: mix dvou barev (rekurzivní datový typ)</a></p>
<p><a href="#k17">17. Definice dvojice vzájemně rekurzivních funkcí pro rekurzivní datový typ</a></p>
<p><a href="#k18">18. Výsledná podoba projektu s&nbsp;typovým systémem barev</a></p>
<p><a href="#k19">19. Repositář s&nbsp;demonstračními příklady</a></p>
<p><a href="#k20">20. Odkazy na Internetu</a></p>



<p><a name="k01"></a></p>
<h2 id="k01">1. Definice výčtového typu s&nbsp;osmi základními barvami</h2>

<p>V&nbsp;dnešním článku o programovacím jazyku OCaml se ještě jednou vrátíme
k&nbsp;typovému systému tohoto zajímavého jazyka. Ukážeme si, jakým způsobem
lze realizovat datový typ pro reprezentaci barvy, a to v&nbsp;různých barvových
modelech. Řešení bude založeno na &bdquo;neobjektovém&ldquo; OCamlu (což zní
poněkud divně, protože &bdquo;O&ldquo; ve jménu &bdquo;OCaml&ldquo; znamená
&bdquo;objektový&ldquo;). Ukážeme a zopakujeme si jak vlastnosti typového
systému OCamlu, tak i pattern matching (s&nbsp;jeho možným zkráceným zápisem) a
v&nbsp;neposlední řadě se zmíníme o rekurzivních datových typech.</p>

<p>Začněme datovým typem, který bychom již měli dobře znát. Jedná se o takzvané
<i>disjunktní zobrazení</i>, které obsahuje pouze výčet jmen. Tento datový typ
použijeme pro reprezentaci základních osmi barev v&nbsp;barvové paletě:</p>

<pre>
type <strong>basic_color</strong> =
  | Black
  | Red
  | Green
  | Yellow
  | Blue
  | Magenta
  | Cyan
  | White
;;
</pre>

<p><div class="rs-tip-major">Poznámka: povšimněte si způsobu zápisu
s&nbsp;použitím znaků |. Velmi podobný zápis se používá i u pattern matchingu,
což není náhoda.</div></p>

<p>V&nbsp;případě potřeby ovšem můžeme celou definici datového typu zapsat i na
jediný řádek:</p>

<pre>
type <strong>basic_color</strong> = Black | Red | Green | Yellow | Blue | Magenta | Cyan | White;;
</pre>



<p><a name="k02"></a></p>
<h2 id="k02">2. Nový unifikovaný typ <strong>color</strong> a funkce pro převod barvy na trojici složek RGB</h2>

<p>V&nbsp;dalším textu budeme postupně budovat datový typ, který bude možné
využít pro uložení barvy v&nbsp;jakékoli reprezentaci. První verze tohoto typu
bude obsahovat jen jedinou možnost &ndash; již <a href="#k01">výše</a>
definovaný typ <strong>basic_color</strong>:</p>

<pre>
type <strong>color</strong> =
  | BasicColor of basic_color
;;
</pre>

<p>Postupně budeme přidávat i další možnosti.</p>

<p>Dále se pokusme definovat funkci, která převede barvu ze základní palety
osmi barev na tři složky RGB. Tyto složky můžeme reprezentovat trojicí
celočíselných hodnot a samotný převod lze realizovat funkcí (nazvěme ji
<strong>basic_color_to_rgb</strong>) s&nbsp;pattern matchingem. Prozatím se
pokusme v&nbsp;pattern matcheru zapsat jen jedinou barvu:</p>

<pre>
let <strong>basic_color_to_rgb</strong> c =
  match c with
  | Black -&gt; (0, 0, 0)
;;
</pre>

<p>Ovšem funkci, která má jen jediný parametr a jejím tělem je jen blok
s&nbsp;pattern matchingem, můžeme zapsat i jednodušším způsobem. Ten je založen
na použití klíčového slova <strong>function</strong>:</p>

<pre>
let <strong>basic_color_to_rgb</strong> = function
  | Black -&gt; (0, 0, 0)
;;
</pre>

<p>Povšimněte si, že takovou funkci lze sice vytvořit (a bude mít i korektní
typ), ovšem OCaml vypíše varování o tom, že jsme nepoužili všech osm barev:</p>

<pre>
let basic_color_to_rgb = function
  | Black -&gt; (0, 0, 0);;
&nbsp;
val basic_color_to_rgb : basic_color -&gt; int * int * int = <fun>
&nbsp;
1 Warning : this pattern-matching is not exhaustive.
Here is an example of a case that is not matched:
(Red|Green|Yellow|Blue|Magenta|Cyan|White)
</pre>

<img src="https://i.iinfo.cz/images/42/ocaml7-1.webp" class="image-1112976" width="695" height="177" alt="&#160;" title="Autor: tisnik, podle licence: &lt;a href=&quot;http://en.wikipedia.org/wiki/Rights_Managed&quot;&gt;Rights Managed&lt;/a&gt;" />
<p><i>Obrázek 1: Varování OCamlu.</i></p>

<p>První varianta příkladu, který budeme postupně vyvíjet, tedy bude vypadat
následovně:</p>

<pre>
type <strong>basic_color</strong> =
  | Black
  | Red
  | Green
  | Yellow
  | Blue
  | Magenta
  | Cyan
  | White
;;
&nbsp;
&nbsp;
type <strong>color</strong> =
  | BasicColor of basic_color
;;
&nbsp;
&nbsp;
let <strong>basic_color_to_rgb</strong> = function
  | Black -&gt; (0, 0, 0)
;;
&nbsp;
&nbsp;
let <strong>to_rgb</strong> c =
  match c with
  | BasicColor c -&gt; basic_color_to_rgb c
;;
</pre>



<p><a name="k03"></a></p>
<h2 id="k03">3. Realizace převodu všech základních barev na RGB</h2>

<p>V&nbsp;další variantě odstraníme korektní varování OCamlu. Rozšíříme totiž
funkci pro převod základních barev na RGB složky tak, že budou použity všechny
základní barvy:</p>

<pre>
type <strong>basic_color</strong> =
  | Black
  | Red
  | Green
  | Yellow
  | Blue
  | Magenta
  | Cyan
  | White
;;
&nbsp;
&nbsp;
type <strong>color</strong> =
  | BasicColor of basic_color
;;
&nbsp;
&nbsp;
let <strong>basic_color_to_rgb</strong> = function
  | Black -&gt; (0, 0, 0)
  | Red -&gt; (255, 0,0)
  | Green -&gt; (0, 255, 0)
  | Yellow -&gt; (255, 255, 0)
  | Blue -&gt; (0, 0, 255)
  | Magenta -&gt; (255, 0, 255)
  | Cyan -&gt; (0, 255, 255)
  | White -&gt; (255, 255, 255);;
&nbsp;
&nbsp;
let <strong>to_rgb</strong> c =
  match c with
  | BasicColor c -&gt; basic_color_to_rgb c
;;
</pre>

<p>Vše si otestujeme:</p>

<pre>
let c1 = BasicColor(Black);;
to_rgb c1;;
&nbsp;
let c2 = BasicColor(Red);;
to_rgb c2;;
</pre>

<p>S&nbsp;výsledky (černá a červená barva reprezentovaná RGB složkami):</p>

<pre>
- : int * int * int = (0, 0, 0)
- : int * int * int = (255, 0, 0)
</pre>

<p><div class="rs-tip-major">Poznámka: povšimněte si, že u funkce
<strong>basic_color_to_rgb</strong> ani <strong>to_rgb</strong> nejsou
specifikovány žádné datové typy. Odvození (<i>inferenci</i>) datových typů za
nás provede OCaml automaticky (a stále se bude jednat o silné
typování):</div></p>

<pre>
val <strong>basic_color_to_rgb</strong> : basic_color -&gt; int * int * int = &lt;fun&gt;
val <strong>to_rgb</strong> : color -&gt; int * int * int = &lt;fun&gt;
</pre>



<p><a name="k04"></a></p>
<h2 id="k04">4. Přidání podpory pro stupně šedi</h2>

<p>Podporu barev rozšíříme o možnost reprezentace barvy ve stupních šedi. Pro
jednoduchost budeme předpokládat, že taková barva bude specifikována jednou
celočíselnou hodnotou v&nbsp;rozsahu 0..255 (prozatím nebudeme kontrolovat
meze). Datový typ &bdquo;barva&ldquo; tedy bude muset být rozšířen o další
pojmenovaný prvek:</p>

<pre>
type <strong>color</strong> =
  | BasicColor of basic_color
  | Gray of int
;;
</pre>

<p>A rozšířit budeme muset i funkce <strong>to_rgb</strong> pro převod barvy na
trojici složek RGB. Pro jednoduchost bude převod ze stupňů šedi realizován tak,
že se vstupní hodnota rozkopíruje do všech třech složek RGB (což ale nemusí být
přesné &ndash; záleží na konkrétním barvovém prostoru):</p>

<pre>
let <strong>to_rgb</strong> c =
  match c with
  | BasicColor c -&gt; basic_color_to_rgb c
  | Gray g -&gt; (g, g, g)
</pre>

<p>Popř.&nbsp;můžeme použít kratší zápis založený na klíčovém slově
<strong>function</strong>:</p>

<pre>
let <strong>to_rgb</strong> = function
  | BasicColor (c, b) -&gt; basic_color_to_rgb c
  | Gray g -&gt; (g, g, g)
</pre>

<p><div class="rs-tip-major">Poznámka: opět si povšimněte, jak se definice
datového typu <strong>color</strong> podobá zápisu funkce
<strong>to_rgb</strong>.</div></p>

<p>Vše si opět otestujeme:</p>

<pre>
let g1 = Gray(0);;
to_rgb g1;;
&nbsp;
let g2 = Gray(255);;
to_rgb g2;;
</pre>

<p>S&nbsp;výsledky:</p>

<pre>
- : int * int * int = (0, 0, 0)
- : int * int * int = (255, 255, 255)
</pre>



<p><a name="k05"></a></p>
<h2 id="k05">5. Úplný zdrojový kód druhé varianty příkladu</h2>

<p>Shrnutí, jak nyní vypadá celý zdrojový kód:</p>

<pre>
type <strong>basic_color</strong> =
  | Black
  | Red
  | Green
  | Yellow
  | Blue
  | Magenta
  | Cyan
  | White
;;
&nbsp;
&nbsp;
type <strong>color</strong> =
  | BasicColor of basic_color
  | Gray of int
;;
&nbsp;
&nbsp;
let <strong>basic_color_to_rgb</strong> = function
  | Black -&gt; (0, 0, 0)
  | Red -&gt; (255, 0,0)
  | Green -&gt; (0, 255, 0)
  | Yellow -&gt; (255, 255, 0)
  | Blue -&gt; (0, 0, 255)
  | Magenta -&gt; (255, 0, 255)
  | Cyan -&gt; (0, 255, 255)
  | White -&gt; (255, 255, 255)
;;
&nbsp;
&nbsp;
let <strong>to_rgb</strong> = function
  | BasicColor (c, b) -&gt; basic_color_to_rgb c
  | Gray g -&gt; (g, g, g)
;;
&nbsp;
&nbsp;
let c1 = BasicColor(Black);;
to_rgb c1;;
&nbsp;
let c2 = BasicColor(Red);;
to_rgb c2;;
&nbsp;
let g1 = Gray(0);;
to_rgb g1;;
&nbsp;
let g2 = Gray(255);;
to_rgb g2;;
</pre>



<p><a name="k06"></a></p>
<h2 id="k06">6. Reprezentace obecné barvy v&nbsp;barvovém prostoru RGB</h2>

<p>Barvu je možné pochopitelně reprezentovat i přímo v&nbsp;barvovém prostoru
RGB specifikací tří složek R, G a B. Přidání tohoto typu barvy do našeho
obecného datového typu <strong>color</strong> je v&nbsp;tomto případě triviální
&ndash; přidáme specifikaci pro trojici hodnot typu <strong>int</strong>:</p>

<pre>
type <strong>color</strong> =
  | BasicColor of basic_color
  | Gray of int
  | RGB of int * int * int
;;
</pre>

<p>Zbytek příkladu zůstane prozatím nezměněn:</p>

<pre>
type <strong>basic_color</strong> =
  | Black
  | Red
  | Green
  | Yellow
  | Blue
  | Magenta
  | Cyan
  | White
;;
&nbsp;
&nbsp;
type <strong>color</strong> =
  | BasicColor of basic_color
  | Gray of int
  | RGB of int * int * int
;;
&nbsp;
&nbsp;
let <strong>basic_color_to_rgb</strong> = function
  | Black -&gt; (0, 0, 0)
  | Red -&gt; (255, 0,0)
  | Green -&gt; (0, 255, 0)
  | Yellow -&gt; (255, 255, 0)
  | Blue -&gt; (0, 0, 255)
  | Magenta -&gt; (255, 0, 255)
  | Cyan -&gt; (0, 255, 255)
  | White -&gt; (255, 255, 255)
;;
&nbsp;
&nbsp;
let <strong>to_rgb</strong> c =
  match c with
  | BasicColor c -&gt; basic_color_to_rgb c
  | Gray g -&gt; (g, g, g)
;;
&nbsp;
&nbsp;
let c1 = BasicColor(Black);;
to_rgb c1;;
&nbsp;
let c2 = BasicColor(Red);;
to_rgb c2;;
&nbsp;
let g1 = Gray(0);;
to_rgb g1;;
&nbsp;
let g2 = Gray(255);;
to_rgb g2;;
</pre>



<p><a name="k07"></a></p>
<h2 id="k07">7. Detekce chybějící větve ve funkci <strong>to_rgb</strong></h2>

<p>Aby byl datový typ <strong>color</strong> plně funkční, je nutné rozšířit
funkci <strong>to_rgb</strong> takovým způsobem, aby akceptovala i hodnoty typu
RGB. Pokud totiž funkci nerozšíříme, bude si OCaml zcela oprávněně stěžovat, že
funkce nebude korektně pracovat pro všechny možné varianty vstupních dat (ale
přeloží ji):</p>

<img src="https://i.iinfo.cz/images/42/ocaml7-2.webp" class="image-1112977" width="584" height="218" alt="&#160;" title="Autor: tisnik, podle licence: &lt;a href=&quot;http://en.wikipedia.org/wiki/Rights_Managed&quot;&gt;Rights Managed&lt;/a&gt;" />
<p><i>Obrázek 2: Detekce potenciálního problému v&nbsp;kódu &ndash; jedna
z&nbsp;možných variant vstupních dat není v&nbsp;kódu zmíněna.</i></p>

<p>Ovšem problém nastane při volání této funkce, pokud jí předáme barvu typu
<strong>RGB</strong>:</p>

<img src="https://i.iinfo.cz/images/42/ocaml7-3.webp" class="image-1112978" width="517" height="387" alt="&#160;" title="Autor: tisnik, podle licence: &lt;a href=&quot;http://en.wikipedia.org/wiki/Rights_Managed&quot;&gt;Rights Managed&lt;/a&gt;" />
<p><i>Obrázek 3: Pokus o předání barvy typu <strong>RGB</strong> do funkce
<strong>to_rgb</strong> nebude úspěšný.</i></p>



<p><a name="k08"></a></p>
<h2 id="k08">8. Doplnění funkce pro převod jakékoli barvy do barvového prostoru RGB</h2>

<p>Do funkce <strong>to_rgb</strong> přidáme větev pro barvu typu
<strong>RGB</strong>. Můžeme přitom ve vzorku (<i>pattern</i>) barvu nejprve
rozložit na složky R, G a B a ve výrazu (za šipkou) z&nbsp;nich zase složit
trojici (asi je zřejmé, že podpora například formátu BGR atd. by byla
triviální):</p>

<pre>
let <strong>to_rgb</strong> c =
  match c with
  | BasicColor c -&gt; basic_color_to_rgb c
  | Gray g -&gt; (g, g, g)
  | RGB(r,g,b) -&gt; (r, g, b)
</pre>

<p>Alternativní způsob zápisu s&nbsp;využitím klíčového slova
<strong>function</strong>:</p>

<pre>
let <strong>to_rgb</strong> = function
  | BasicColor c -&gt; basic_color_to_rgb c
  | Gray g -&gt; (g, g, g)
  | RGB(r,g,b) -&gt; (r, g, b)
</pre>

<p>Novou funkcionalitu <strong>to_rgb</strong> si snadno ověříme:</p>

<pre>
let rgb1 = RGB(0, 10, 20);;
to_rgb rgb1;;
&nbsp;
let rgb2 = RGB(0, 0, 255);;
to_rgb rgb2;;
&nbsp;
let rgb3 = RGB(255, 255, 255);;
to_rgb rgb3;;
</pre>

<p>Výše uvedených šest řádků kódu bude interpretováno následujícím
způsobem:</p>

<pre>
let rgb1 = RGB(0, 10, 20) ;;
val rgb1 : color = RGB (0, 10, 20)
&nbsp;
to_rgb rgb1 ;;
- : int * int * int = <strong>(0, 10, 20)</strong>
&nbsp;
let rgb2 = RGB(0, 0, 255) ;;
val rgb2 : color = RGB (0, 0, 255)
&nbsp;
to_rgb rgb2 ;;
- : int * int * int = <strong>(0, 0, 255)</strong>
&nbsp;
let rgb3 = RGB(255, 255, 255) ;;
val rgb3 : color = RGB (255, 255, 255)
&nbsp;
to_rgb rgb3 ;;
- : int * int * int = <strong>(255, 255, 255)</strong>
</pre>

<p>A pro úplnost si opět uvedeme úplný zdrojový kód upraveného příkladu:</p>

<pre>
type <strong>basic_color</strong> =
  | Black
  | Red
  | Green
  | Yellow
  | Blue
  | Magenta
  | Cyan
  | White
;;
&nbsp;
&nbsp;
type <strong>color</strong> =
  | BasicColor of basic_color
  | Gray of int
  | RGB  of int * int * int
;;
&nbsp;
&nbsp;
let <strong>basic_color_to_rgb</strong> = function
  | Black -&gt; (0, 0, 0)
  | Red -&gt; (255, 0,0)
  | Green -&gt; (0, 255, 0)
  | Yellow -&gt; (255, 255, 0)
  | Blue -&gt; (0, 0, 255)
  | Magenta -&gt; (255, 0, 255)
  | Cyan -&gt; (0, 255, 255)
  | White -&gt; (255, 255, 255)
;;
&nbsp;
&nbsp;
let <strong>to_rgb</strong> c =
  match c with
  | BasicColor c -&gt; basic_color_to_rgb c
  | Gray g -&gt; (g, g, g)
  | RGB(r,g,b) -&gt; (r, g, b)
;;
&nbsp;
&nbsp;
let c1 = BasicColor(Black);;
to_rgb c1;;
&nbsp;
let c2 = BasicColor(Red);;
to_rgb c2;;
&nbsp;
let g1 = Gray(0);;
to_rgb g1;;
&nbsp;
let g2 = Gray(255);;
to_rgb g2;;
&nbsp;
let rgb1 = RGB(0, 10, 20);;
to_rgb rgb1;;
&nbsp;
let rgb2 = RGB(0, 0, 255);;
to_rgb rgb2;;
&nbsp;
let rgb3 = RGB(255, 255, 255);;
to_rgb rgb3;;
</pre>



<p><a name="k09"></a></p>
<h2 id="k09">9. Přidání možnosti modifikace základních barev o atribut <i>světlost</i></h2>

<p>Nyní provedeme další rozšíření našeho systému barev. Přidáme možnost určit u
základních osmi barev jejich světlost, tj.&nbsp;atribut <strong>Dark</strong>
či <strong>Bright</strong>. Typ tohoto atributu je triviální:</p>

<pre>
type <strong>brightness</strong> =
  | Dark
  | Bright
;;
</pre>

<p>Důležitější ovšem je, že se změní i konstruktor pro základní barvy. Kromě
jména barvy (<strong>Red</strong> atd.) se musí specifikovat i její
světlost, takže výsledkem je (typově bezpečná) dvojice:</p>

<pre>
type <strong>color</strong> =
  | BasicColor of <strong>basic_color * brightness</strong>
  | Gray of int
  | RGB of int * int * int
;;
</pre>

<p>A pochopitelně musíme modifikovat i přepočet základních barev na RGB. Pokud
má být základní barva světlá, neprovedeme žádnou změnu, ale pokud má být tmavá,
podělíme všechny její barvové složky dvěma (to pro jednoduchost &ndash;
v&nbsp;praxi se spíše násobí konstantou 2/3):</p>

<pre>
let <strong>brightness</strong> rgb brightess =
  match brightess with
  | Dark -&gt; (match rgb with
      | (r, g, b) -&gt; (r/2, g/2, b/2))
  | Bright -&gt; rgb
;;
&nbsp;
&nbsp;
let <strong>to_rgb</strong> c =
  match c with
  | BasicColor (c, b) -&gt; brightness (basic_color_to_rgb c) b
  | Gray g -&gt; (g, g, g)
  | RGB(r,g,b) -&gt; (r, g, b)
;;
</pre>

<p>Výpočet si ověříme:</p>

<pre>
let c1 = BasicColor(Black, Dark);;
to_rgb c1;;
&nbsp;
let c2 = BasicColor(Black, Bright);;
to_rgb c2;;
&nbsp;
let c3 = BasicColor(Red, Dark);;
to_rgb c3;;
&nbsp;
let c4 = BasicColor(Red, Bright);;
to_rgb c4;;
</pre>

<p>Pro tyto čtyři řádky bychom měli získat následující RGB složky
(nejdůležitější je tmavě červená, tedy barva <strong>c3</strong>):</p>

<pre>
to_rgb c1 ;;
- : int * int * int = <strong>(0, 0, 0)</strong>
&nbsp;
to_rgb c2 ;;
- : int * int * int = <strong>(0, 0, 0)</strong>
&nbsp;
to_rgb c3 ;;
- : int * int * int = <strong>(127, 0, 0)</strong>
&nbsp;
to_rgb c4 ;;
- : int * int * int = <strong>(255, 0, 0)</strong>
</pre>

<p>A pro úplnost si opět uvedeme úplný zdrojový kód upraveného příkladu:</p>

<pre>
type <strong>basic_color</strong> =
  | Black
  | Red
  | Green
  | Yellow
  | Blue
  | Magenta
  | Cyan
  | White
;;
&nbsp;
&nbsp;
type <strong>brightness</strong> =
  | Dark
  | Bright
;;
&nbsp;
&nbsp;
type <strong>color</strong> =
  | BasicColor of basic_color * brightness
  | Gray of int
  | RGB of int * int * int
;;
&nbsp;
&nbsp;
let <strong>basic_color_to_rgb</strong> = function
  | Black -&gt; (0, 0, 0)
  | Red -&gt; (255, 0,0)
  | Green -&gt; (0, 255, 0)
  | Yellow -&gt; (255, 255, 0)
  | Blue -&gt; (0, 0, 255)
  | Magenta -&gt; (255, 0, 255)
  | Cyan -&gt; (0, 255, 255)
  | White -&gt; (255, 255, 255)
;;
&nbsp;
&nbsp;
let <strong>brightness</strong> rgb brightess =
  match brightess with
  | Dark -&gt; (match rgb with
      | (r, g, b) -&gt; (r/2, g/2, b/2))
  | Bright -&gt; rgb
;;
&nbsp;
&nbsp;
let <strong>to_rgb</strong> c =
  match c with
  | BasicColor (c, b) -&gt; brightness (basic_color_to_rgb c) b
  | Gray g -&gt; (g, g, g)
  | RGB(r,g,b) -&gt; (r, g, b)
;;
&nbsp;
&nbsp;
let c1 = BasicColor(Black, Dark);;
to_rgb c1;;
&nbsp;
let c2 = BasicColor(Black, Bright);;
to_rgb c2;;
&nbsp;
let c3 = BasicColor(Red, Dark);;
to_rgb c3;;
&nbsp;
let c4 = BasicColor(Red, Bright);;
to_rgb c4;;
&nbsp;
let g1 = Gray(0);;
to_rgb g1;;
&nbsp;
let g2 = Gray(255);;
to_rgb g2;;
&nbsp;
let rgb1 = RGB(0, 10, 20);;
to_rgb rgb1;;
&nbsp;
let rgb2 = RGB(0, 0, 255);;
to_rgb rgb2;;
&nbsp;
let rgb3 = RGB(255, 255, 255);;
to_rgb rgb3;;
</pre>



<p><a name="k10"></a></p>
<h2 id="k10">10. Zjednodušení výpočtu tmavší varianty základních barev</h2>

<p>V&nbsp;demonstračním příkladu <a href="#k09">z&nbsp;předchozí kapitoly</a>
jsme použili poněkud nešikovné řešení založené na vnořených konstrukcích
<strong>match</strong>. Tento koncept sice programovací jazyk OCaml podporuje,
ale výsledek není příliš čitelný, o čem se můžeme snadno přesvědčit:</p>

<pre>
let <strong>brightness</strong> rgb brightess =
  match brightess with
  | Dark -&gt; (match rgb with
      | (r, g, b) -&gt; (r/2, g/2, b/2))
  | Bright -&gt; rgb
;;
</pre>

<p>Lepší bude, když si vnitřní blok <strong>match</strong> převedeme do lokální
či globální funkce. Potom se předchozí kód změní na:</p>

<pre>
let <strong>darker</strong> rgb =
  match rgb with
  | (r, g, b) -&gt; (r/2, g/2, b/2)
;;
&nbsp;
&nbsp;
let <strong>brightness</strong> rgb brightess =
  match brightess with
  | Dark -&gt; darker rgb
  | Bright -&gt; rgb
;;
</pre>

<p>A úplný kód příkladu bude nyní vypadat následovně:</p>

<pre>
type <strong>basic_color</strong> =
  | Black
  | Red
  | Green
  | Yellow
  | Blue
  | Magenta
  | Cyan
  | White
;;
&nbsp;
&nbsp;
type <strong>brightness</strong> =
  | Dark
  | Bright
;;
&nbsp;
&nbsp;
type <strong>color</strong> =
  | BasicColor of basic_color * brightness
  | Gray of int
  | RGB of int * int * int
;;
&nbsp;
&nbsp;
let <strong>basic_color_to_rgb</strong> = function
  | Black -&gt; (0, 0, 0)
  | Red -&gt; (255, 0,0)
  | Green -&gt; (0, 255, 0)
  | Yellow -&gt; (255, 255, 0)
  | Blue -&gt; (0, 0, 255)
  | Magenta -&gt; (255, 0, 255)
  | Cyan -&gt; (0, 255, 255)
  | White -&gt; (255, 255, 255)
;;
&nbsp;
&nbsp;
let <strong>darker</strong> rgb =
  match rgb with
  | (r, g, b) -&gt; (r/2, g/2, b/2)
;;
&nbsp;
&nbsp;
let <strong>brightness</strong> rgb brightess =
  match brightess with
  | Dark -&gt; darker rgb
  | Bright -&gt; rgb
;;
&nbsp;
&nbsp;
let <strong>to_rgb</strong> c =
  match c with
  | BasicColor (c, b) -&gt; brightness (basic_color_to_rgb c) b
  | Gray g -&gt; (g, g, g)
  | RGB(r,g,b) -&gt; (r, g, b)
;;
&nbsp;
&nbsp;
let c1 = BasicColor(Black, Dark);;
to_rgb c1;;
&nbsp;
let c2 = BasicColor(Black, Bright);;
to_rgb c2;;
&nbsp;
let c3 = BasicColor(Red, Dark);;
to_rgb c3;;
&nbsp;
let c4 = BasicColor(Red, Bright);;
to_rgb c4;;
&nbsp;
let g1 = Gray(0);;
to_rgb g1;;
&nbsp;
let g2 = Gray(255);;
to_rgb g2;;
&nbsp;
let rgb1 = RGB(0, 10, 20);;
to_rgb rgb1;;
&nbsp;
let rgb2 = RGB(0, 0, 255);;
to_rgb rgb2;;
&nbsp;
let rgb3 = RGB(255, 255, 255);;
to_rgb rgb3;;
</pre>



<p><a name="k11"></a></p>
<h2 id="k11">11. Malá odbočka: převod mezi barvovými modely HSV a RGB</h2>

<p>V&nbsp;dalších kapitolách přidáme do našeho systému barev možnost
specifikace barvy v&nbsp;barvovém prostoru (modelu) HSV neboli <i>Hue,
Saturation, Value</i>. Taková barva je reprezentována trojicí složek
v&nbsp;rozsahu 0,0 až 1,0 (někdy jsou provedeny přepočty <i>hue</i> na úhly a
ostatních složek na hodnoty 0% až 100%). Složka <i>hue</i> určuje odstín barvy
v&nbsp;kruhu nebo šestiúhelníku, složka <i>saturation</i> pak čistotu barvy a
složka <i>value</i> její světlost. Barvový prostor HSV tedy zhruba <a
href="https://en.wikipedia.org/wiki/HSL_and_HSV#/media/File:HSV_color_solid_cylinder_saturation_gray.png">vypadá
následovně</a> (ve skutečnosti jsou ale barvy umístěny v&nbsp;kuželi, ne
v&nbsp;celém válci, protože na špičce kužele je černá barva bez sytosti a
odstínu).</p>



<p><a name="k12"></a></p>
<h2 id="k12">12. Realizace algoritmu převodu HSV do RGB v&nbsp;jazyku Python</h2>

<p>Nejdříve se podívejme na to, jak může vypadat realizace algoritmu pro převod
barvy z&nbsp;barvového prostoru HSV do prostoru RGB ve vysokoúrovňovém
pseudokódu, který je (čistě náhodou :-) i korektním Pythonovským zdrojovým
kódem. Na základě odstínu barvy (<i>hue</i>) je zjištěno, ve které šestině HSV
kužele se barva nachází a posléze je proveden přepočet pouze v&nbsp;rámci této
šestiny. Z&nbsp;tohoto důvodu je i v&nbsp;Pythonovském kódu použita konstrukce
pro pattern matching, i když se v&nbsp;ní ve skutečnosti nerozpoznávají žádné
složité vzory, ale pouze celočíselné konstanty 0 až 5:</p>

<pre>
def <strong>scale_rgb</strong>(r, g, b):
    return (int(255*r), int(255*g), int(255*b))
&nbsp;
&nbsp;
def <strong>hsv_to_rgb</strong>(h, s, v):
    if s==0:
        return scale_rgb(v, v, v)
    else:
        return hsv_to_rgb_(h, s, v)
&nbsp;
&nbsp;
def <strong>hsv_to_rgb_</strong>(h, s, v):
    if h == 1.0:
        h = 0.0
    i = int(h*6.0)
    f = h*6.0 - i
&nbsp;
    w = v * (1.0 - s)
    q = v * (1.0 - s * f)
    t = v * (1.0 - s * (1.0 - f))
&nbsp;
    match i:
        case 0:
            return scale_rgb(v, t, w)
        case 1:
            return scale_rgb(q, v, w)
        case 2:
            return scale_rgb(w, v, t)
        case 3:
            return scale_rgb(w, q, v)
        case 4:
            return scale_rgb(t, w, v)
        case 5:
            return scale_rgb(v, w, q)
&nbsp;
&nbsp;
print(hsv_to_rgb(0.0, 0.0, 1.0))
print(hsv_to_rgb(0.0, 0.0, 0.5))
&nbsp;
print(hsv_to_rgb(0.0, 1.0, 1.0))
print(hsv_to_rgb(0.3333, 1.0, 1.0))
print(hsv_to_rgb(0.6666, 1.0, 1.0))
print(hsv_to_rgb(1, 1.0, 1.0))
print(hsv_to_rgb(1.0, 0.5, 0.5))
</pre>



<p><a name="k13"></a></p>
<h2 id="k13">13. Realizace algoritmu převodu HSV do RGB v&nbsp;jazyku OCaml</h2>

<p>Zajímavé bude porovnání pythonovského (typově nezabezpečeného) kódu do
jazyka OCaml. Snažil jsem se o zachování stejné struktury kódu, takže se
sémantika nebude lišit. Na druhou stranu je syntaxe odlišná a současně je kód
typově bezpečný:</p>

<pre>
let <strong>scale_component</strong> x =
  int_of_float (255.*.x)
;;
&nbsp;
&nbsp;
let <strong>scale_rgb</strong> r g b =
  (scale_component r,
   scale_component g,
   scale_component b)
;;
&nbsp;
&nbsp;
let <strong>hsv_to_rgb_</strong> h s v =
  let h = 
    match h with
    | 1.0 -&gt; 0.0
    | _ -&gt; h
  in
  let i = int_of_float (h*.6.0) in
  let f = h *. 6.0 -. (float i) in
  let w = v *. (1.0 -. s) in
  let q = v *. (1.0 -. s*.f) in
  let t = v *. (1.0 -. s*.(1.0 -. f)) in
  match i with
  | 0 -&gt; scale_rgb v t w
  | 1 -&gt; scale_rgb q v w
  | 2 -&gt; scale_rgb w v t
  | 3 -&gt; scale_rgb w q v
  | 4 -&gt; scale_rgb t w v
  | 5 -&gt; scale_rgb v w q
  | _ -&gt; (0, 0, 0)
;;
&nbsp;
&nbsp;
let <strong>hsv_to_rgb</strong> h s v =
  match s with
  | 0.0 -&gt; (scale_rgb v v v)
  | _ -&gt; (hsv_to_rgb_ h s v)
;;
</pre>

<p>Jednotlivé převody barev si otestujeme:</p>

<pre>
hsv_to_rgb 0.0 0.0 1.0;;
hsv_to_rgb 0.0 0.0 0.5;;
hsv_to_rgb 0.0 1.0 1.0;;
hsv_to_rgb 0.3333 1.0 1.0;;
hsv_to_rgb 0.6666 1.0 1.0;;
hsv_to_rgb 1.0 1.0 1.0;;
hsv_to_rgb 1.0 0.5 0.5;;
</pre>

<p>S&nbsp;výsledky:</p>

<pre>
<i>čistě bílá barva</i>
hsv_to_rgb 0.0 0.0 1.0 ;;
- : int * int * int = (255, 255, 255)
&nbsp;
<i>šedá barva (50%)</i>
hsv_to_rgb 0.0 0.0 0.5 ;;
- : int * int * int = (127, 127, 127)
&nbsp;
<i>čistě červená barva (hue=0)</i>
hsv_to_rgb 0.0 1.0 1.0 ;;
- : int * int * int = (255, 0, 0)
&nbsp;
<i>čistě zelená barva (hue=1/3)</i>
hsv_to_rgb 0.3333 1.0 1.0 ;;
- : int * int * int = (0, 255, 0)
&nbsp;
<i>čistě modrá barva (hue=2/3)</i>
hsv_to_rgb 0.6666 1.0 1.0 ;;
- : int * int * int = (0, 0, 255)
&nbsp;
<i>čistě červená barva (hue=0 == hue=1)</i>
hsv_to_rgb 1.0 1.0 1.0 ;;
- : int * int * int = (255, 0, 0)
&nbsp;
<i>modifikace saturace</i>
hsv_to_rgb 1.0 0.5 0.5 ;;
- : int * int * int = (127, 63, 63)
</pre>



<p><a name="k14"></a></p>
<h2 id="k14">14. Přidání barev v&nbsp;prostoru HSV do našeho typového systému</h2>

<p>Nyní, když již víme, jakým způsobem je možné převést barvu z&nbsp;prostoru
HSV do prostoru RGB, bude rozšíření našeho typového systému barev o možnost
specifikace barvy v&nbsp;HSV ve skutečnosti dosti triviální. Nejdříve musíme
deklarovat novou variantu barvy <strong>HSV</strong> reprezentované trojicí
hodnot typu <strong>float</strong>. Úprava bude vypadat následovně:</p>

<pre>
type <strong>color</strong> =
  | BasicColor of basic_color * brightness
  | Gray of int
  | RGB of int * int * int
  | <u>HSV of float * float * float</u>
;;
</pre>

<p>A druhá změna se týká funkce pro převod jakékoli barvy na RGB. Zde opět
postačuje přidání jediného řádku:</p>

<pre>
let <strong>to_rgb</strong> c =
  match c with
  | BasicColor (c, b) -&gt; brightness (basic_color_to_rgb c) b
  | Gray g -&gt; (g, g, g)
  | RGB(r,g,b) -&gt; (r, g, b)
  | <u>HSV(h,s,v) -&gt; hsv_to_rgb h s v</u>
;;
</pre>



<p><a name="k15"></a></p>
<h2 id="k15">15. Důsledné využití zjednodušeného zápisu funkcí obsahujících jen pattern matching</h2>

<p>Náš postupně vznikající projekt ještě dále upravíme. Změníme všechny funkce,
které obsahují pouze blok <strong>match</strong>, na jejich jednodušší variantu
založenou na použití klíčového slova <strong>function</strong>. To je snadné,
protože se tento &bdquo;problém&ldquo; týká jen dvou funkcí:</p>

<pre>
let <strong>darker</strong> = function
  | (r, g, b) -&gt; (r/2, g/2, b/2)
;;
</pre>

<p>a:</p>

<pre>
let <strong>to_rgb</strong> = function
  | BasicColor (c, b) -&gt; brightness (basic_color_to_rgb c) b
  | Gray g -&gt; (g, g, g)
  | RGB(r,g,b) -&gt; (r, g, b)
  | HSV(h,s,v) -&gt; hsv_to_rgb h s v
;;
</pre>

<p>Předposlední verze projektu bude nyní vypadat takto:</p>

<pre>
let <strong>scale_component</strong> x =
  int_of_float (255.*.x)
;;
&nbsp;
&nbsp;
let <strong>scale_rgb</strong> r g b =
  (scale_component r,
   scale_component g,
   scale_component b)
;;
&nbsp;
&nbsp;
let <strong>hsv_to_rgb_</strong> h s v =
  let h = 
    match h with
    | 1.0 -&gt; 0.0
    | _ -&gt; h
  in
  let i = int_of_float (h*.6.0) in
  let f = h *. 6.0 -. (float i) in
  let w = v *. (1.0 -. s) in
  let q = v *. (1.0 -. s*.f) in
  let t = v *. (1.0 -. s*.(1.0 -. f)) in
  match i with
  | 0 -&gt; scale_rgb v t w
  | 1 -&gt; scale_rgb q v w
  | 2 -&gt; scale_rgb w v t
  | 3 -&gt; scale_rgb w q v
  | 4 -&gt; scale_rgb t w v
  | 5 -&gt; scale_rgb v w q
  | _ -&gt; (0, 0, 0)
;;
&nbsp;
&nbsp;
let <strong>hsv_to_rgb</strong> h s v =
  match s with
  | 0.0 -&gt; (scale_rgb v v v)
  | _ -&gt; (hsv_to_rgb_ h s v)
;;
&nbsp;
&nbsp;
type <strong>basic_color</strong> =
  | Black
  | Red
  | Green
  | Yellow
  | Blue
  | Magenta
  | Cyan
  | White
;;
&nbsp;
&nbsp;
type <strong>brightness</strong> =
  | Dark
  | Bright
;;
&nbsp;
&nbsp;
type <strong>color</strong> =
  | BasicColor of basic_color * brightness
  | Gray of int
  | RGB of int * int * int
  | HSV of float * float * float
;;
&nbsp;
&nbsp;
let <strong>basic_color_to_rgb</strong> = function
  | Black -&gt; (0, 0, 0)
  | Red -&gt; (255, 0,0)
  | Green -&gt; (0, 255, 0)
  | Yellow -&gt; (255, 255, 0)
  | Blue -&gt; (0, 0, 255)
  | Magenta -&gt; (255, 0, 255)
  | Cyan -&gt; (0, 255, 255)
  | White -&gt; (255, 255, 255);;
;;
&nbsp;
&nbsp;
let <strong>darker</strong> = function
  | (r, g, b) -&gt; (r/2, g/2, b/2)
;;
&nbsp;
&nbsp;
let <strong>brightness</strong> rgb brightess =
  match brightess with
  | Dark -&gt; darker rgb
  | Bright -&gt; rgb
;;
&nbsp;
&nbsp;
let <strong>to_rgb</strong> = function
  | BasicColor (c, b) -&gt; brightness (basic_color_to_rgb c) b
  | Gray g -&gt; (g, g, g)
  | RGB(r,g,b) -&gt; (r, g, b)
  | HSV(h,s,v) -&gt; hsv_to_rgb h s v
;;
&nbsp;
&nbsp;
let c1 = BasicColor(Black, Dark);;
to_rgb c1;;
&nbsp;
let c2 = BasicColor(Black, Bright);;
to_rgb c2;;
&nbsp;
let c3 = BasicColor(Red, Dark);;
to_rgb c3;;
&nbsp;
let c4 = BasicColor(Red, Bright);;
to_rgb c4;;
&nbsp;
let g1 = Gray(0);;
to_rgb g1;;
&nbsp;
let g2 = Gray(255);;
to_rgb g2;;
&nbsp;
let rgb1 = RGB(0, 10, 20);;
to_rgb rgb1;;
&nbsp;
let rgb2 = RGB(0, 0, 255);;
to_rgb rgb2;;
&nbsp;
let rgb3 = RGB(255, 255, 255);;
to_rgb rgb3;;
&nbsp;
let hsv1 = HSV(0.0, 0.0, 1.0);;
to_rgb hsv1;;
&nbsp;
let hsv2 = HSV(0.0, 0.0, 0.5);;
to_rgb hsv2;;
&nbsp;
let hsv3 = HSV(0.0, 1.0, 1.0);;
to_rgb hsv3;;
&nbsp;
let hsv4 = HSV(0.3333, 1.0, 1.0);;
to_rgb hsv4;;
&nbsp;
let hsv5 = HSV(0.6666, 1.0, 1.0);;
to_rgb hsv5;;
&nbsp;
let hsv6 = HSV(1.0, 1.0, 1.0);;
to_rgb hsv6;;
&nbsp;
let hsv7 = HSV(1.0, 0.5, 0.5);;
to_rgb hsv7;; 
</pre>



<p><a name="k16"></a></p>
<h2 id="k16">16. Poslední typ barvy: mix dvou barev (rekurzivní datový typ)</h2>

<p>Nyní se dostáváme k&nbsp;nejzajímavější části námi vytvářeného typového
systému barev. Přidáme do něj možnost definovat novou barvu mixem dvou jiných
barev, přičemž bude možné specifikovat poměr obou barev. Například tedy budeme
moci říci: &bdquo;nová barva je z&nbsp;10% tvořena základní červenou barvou a
z&nbsp;90% je tvořena HSV barvou (1.0, 0.5, 0.5)&ldquo; atd. Nebo samozřejmě
můžeme novou barvu vytvořit mixem barev, které vznikly mixem jiných barev.
Výsledkem je <i>rekurzivní datový typ</i>:</p>

<pre>
type <strong>color</strong> =
  | BasicColor of basic_color * brightness
  | Gray of int
  | RGB of int * int * int
  | HSV of float * float * float
  | <u>Mix of float * color * color</u>
;;
</pre>

<p>Samozřejmě budeme muset přidat novou větev do funkce
<strong>to_rgb</strong>. V&nbsp;případě, že budeme chtít použít novou variantu
<strong>Mix</strong>, je nutné z&nbsp;obou barev vypočítat jejich smíchané RGB
složky:</p>

<pre>
let <strong>to_rgb</strong> = function
  | BasicColor (c, b) -&gt; brightness (basic_color_to_rgb c) b
  | Gray g -&gt; (g, g, g)
  | RGB(r,g,b) -&gt; (r, g, b)
  | HSV(h,s,v) -&gt; hsv_to_rgb h s v
  | Mix(ratio, color1, color2) -&gt; mix_colors ratio color1 color2
;;
</pre>

<p>Samotný výpočet smíchané barvy není nijak komplikovaný, ovšem má jeden
problém &ndash; voláme v&nbsp;něm opět funkci <strong>to_rgb</strong>, protože
míchané barvy je nejprve nutné převést na jejich RGB složky:</p>

<pre>
let <strong>mix_components</strong> ratio c1 c2 =
  int_of_float ((float c1) *. ratio +. (float c2) *. (1.0 -. ratio))
;;
&nbsp;
&nbsp;
&nbsp;
let <strong>mix_colors</strong> ratio color1 color2 =
  let (r1, g1, b1) = <u>to_rgb color1</u> in
  let (r2, g2, b2) = <u>to_rgb color2</u> in
  (mix_components ratio r1 r2, mix_components ratio g1 g2, mix_components ratio b1 b2)
;;
</pre>

<p>Takto strukturovaný programový kód nebude možné přeložit, protože
z&nbsp;funkce <strong>to_rgb</strong> voláme funkci <strong>mix_colors</strong>
a z&nbsp;<strong>mix_colors</strong> voláme opět <strong>to_rgb</strong>.</p>



<p><a name="k17"></a></p>
<h2 id="k17">17. Definice dvojice vzájemně rekurzivních funkcí pro rekurzivní datový typ</h2>

<p>Při řešení problému s&nbsp;rekurzivní datovou strukturou a z&nbsp;ní
plynoucí rekurzí v&nbsp;programovém kódu musíme obě vzájemně rekurzivní funkce
definovat přes <strong>let rec</strong> a navíc je musíme definovat současně
&ndash; se spojkou <strong>and</strong> (což již známe):</p>

<pre>
<u>let rec</u> <strong>mix_colors</strong> ratio color1 color2 =
  let (r1, g1, b1) = to_rgb color1 in
  let (r2, g2, b2) = to_rgb color2 in
  (mix_components ratio r1 r2, mix_components ratio g1 g2, mix_components ratio b1 b2)
<u>and</u>
  <strong>to_rgb</strong> = function
  | BasicColor (c, b) -&gt; brightness (basic_color_to_rgb c) b
  | Gray g -&gt; (g, g, g)
  | RGB(r,g,b) -&gt; (r, g, b)
  | HSV(h,s,v) -&gt; hsv_to_rgb h s v
  | Mix(ratio, color1, color2) -&gt; mix_colors ratio color1 color2
;;
</pre>

<p>Nyní již bude možné kód bez problémů přeložit a spustit.</p>



<p><a name="k18"></a></p>
<h2 id="k18">18. Výsledná podoba projektu s&nbsp;typovým systémem barev</h2>

<p>Celý projekt s&nbsp;realizací poměrně komplikovaného datového typu
<strong>color</strong> byl vytvořen pouze s&nbsp;využitím typového systému
jazyka OCaml (rekurzivní typy + n-tice + disjunktní zobrazení) a pattern
matchingu. Jak je patrné, je celé řešení vlastně řešeno ortogonálně
v&nbsp;porovnání s&nbsp;objektovým přístupem. V&nbsp;OO řešení by se vytvořila
hierarchie tříd, každá třída by měla vlastní realizaci <strong>to_rgb</strong>
a stav i vlastní hodnota barvy by byla zapouzdřena a dostupná přes nějaké
metody. Řešení na úrovni typů je odlišné &ndash; typ je jeden (i když
rekurzivní) a i <strong>to_rgb</strong> je řešeno na jediném místě. Každý
z&nbsp;použitých přístupů má pochopitelně své přednosti a zápory, které se
týkají rozšiřitelnosti, čitelnosti, testovatelnosti apod.</p>

<p>Dále si povšimněte, že se v&nbsp;celém kódu setkáme jen s&nbsp;jedním
místem, v&nbsp;němž musíme konkrétně specifikovat datové typy. Jedná se o
samotnu definici typu <strong>color</strong>. Ostatní kód je již zcela založen
na automaticky prováděné typové inferenci jazyka OCaml:</p>

<pre>
let <strong>scale_component</strong> x =
  int_of_float (255.*.x)
;;
&nbsp;
&nbsp;
let <strong>scale_rgb</strong> r g b =
  (scale_component r,
   scale_component g,
   scale_component b)
;;
&nbsp;
&nbsp;
let <strong>hsv_to_rgb_</strong> h s v =
  let h = 
    match h with
    | 1.0 -&gt; 0.0
    | _ -&gt; h
  in
  let i = int_of_float (h*.6.0) in
  let f = h *. 6.0 -. (float i) in
  let w = v *. (1.0 -. s) in
  let q = v *. (1.0 -. s*.f) in
  let t = v *. (1.0 -. s*.(1.0 -. f)) in
  match i with
  | 0 -&gt; scale_rgb v t w
  | 1 -&gt; scale_rgb q v w
  | 2 -&gt; scale_rgb w v t
  | 3 -&gt; scale_rgb w q v
  | 4 -&gt; scale_rgb t w v
  | 5 -&gt; scale_rgb v w q
  | _ -&gt; (0, 0, 0)
;;
&nbsp;
&nbsp;
let <strong>hsv_to_rgb</strong> h s v =
  match s with
  | 0.0 -&gt; (scale_rgb v v v)
  | _ -&gt; (hsv_to_rgb_ h s v)
;;
&nbsp;
&nbsp;
type <strong>basic_color</strong> =
  | Black
  | Red
  | Green
  | Yellow
  | Blue
  | Magenta
  | Cyan
  | White
;;
&nbsp;
&nbsp;
type <strong>brightness</strong> =
  | Dark
  | Bright
;;
&nbsp;
&nbsp;
type <strong>color</strong> =
  | BasicColor of basic_color * brightness
  | Gray of int
  | RGB of int * int * int
  | HSV of float * float * float
  | Mix of float * color * color;;
;;
&nbsp;
&nbsp;
let <strong>basic_color_to_rgb</strong> = function
  | Black -&gt; (0, 0, 0)
  | Red -&gt; (255, 0,0)
  | Green -&gt; (0, 255, 0)
  | Yellow -&gt; (255, 255, 0)
  | Blue -&gt; (0, 0, 255)
  | Magenta -&gt; (255, 0, 255)
  | Cyan -&gt; (0, 255, 255)
  | White -&gt; (255, 255, 255)
;;
&nbsp;
&nbsp;
let <strong>darker</strong> = function
  | (r, g, b) -&gt; (r/2, g/2, b/2)
;;
&nbsp;
&nbsp;
let <strong>brightness</strong> rgb brightess =
  match brightess with
  | Dark -&gt; darker rgb
  | Bright -&gt; rgb
;;
&nbsp;
&nbsp;
let <strong>mix_components</strong> ratio c1 c2 =
  int_of_float ((float c1) *. ratio +. (float c2) *. (1.0 -. ratio))
;;
&nbsp;
&nbsp;
let rec <strong>mix_colors</strong> ratio color1 color2 =
  let (r1, g1, b1) = to_rgb color1 in
  let (r2, g2, b2) = to_rgb color2 in
  (mix_components ratio r1 r2, mix_components ratio g1 g2, mix_components ratio b1 b2)
and
  <strong>to_rgb</strong> = function
  | BasicColor (c, b) -&gt; brightness (basic_color_to_rgb c) b
  | Gray g -&gt; (g, g, g)
  | RGB(r,g,b) -&gt; (r, g, b)
  | HSV(h,s,v) -&gt; hsv_to_rgb h s v
  | Mix(ratio, color1, color2) -&gt; mix_colors ratio color1 color2
;;
&nbsp;
&nbsp;
let c1 = BasicColor(Black, Dark);;
to_rgb c1;;
&nbsp;
let c2 = BasicColor(Black, Bright);;
to_rgb c2;;
&nbsp;
let c3 = BasicColor(Red, Dark);;
to_rgb c3;;
&nbsp;
let c4 = BasicColor(Red, Bright);;
to_rgb c4;;
&nbsp;
let g1 = Gray(0);;
to_rgb g1;;
&nbsp;
let g2 = Gray(255);;
to_rgb g2;;
&nbsp;
let rgb1 = RGB(0, 10, 20);;
to_rgb rgb1;;
&nbsp;
let hsv1 = HSV(0.0, 0.0, 1.0);;
to_rgb hsv1;;
&nbsp;
let hsv2 = HSV(0.0, 0.0, 0.5);;
to_rgb hsv2;;
&nbsp;
let hsv3 = HSV(0.0, 1.0, 1.0);;
to_rgb hsv3;;
&nbsp;
let hsv4 = HSV(0.3333, 1.0, 1.0);;
to_rgb hsv4;;
&nbsp;
let hsv5 = HSV(0.6666, 1.0, 1.0);;
to_rgb hsv5;;
&nbsp;
let hsv6 = HSV(1.0, 1.0, 1.0);;
to_rgb hsv6;;
&nbsp;
let hsv7 = HSV(1.0, 0.5, 0.5);;
to_rgb hsv7;; 
&nbsp;
let mixed1 = Mix(0.0, BasicColor(Red, Bright), BasicColor(Blue, Bright));;
to_rgb mixed1;;
&nbsp;
let mixed2 = Mix(0.5, BasicColor(Red, Bright), BasicColor(Blue, Bright));;
to_rgb mixed2;;
&nbsp;
let mixed3 = Mix(1.0, BasicColor(Red, Bright), BasicColor(Blue, Bright));;
to_rgb mixed3;;
</pre>



<p><a name="k19"></a></p>
<h2 id="k19">19. Repositář s&nbsp;demonstračními příklady</h2>

<p>Všechny výše popsané demonstrační příklady byly uloženy do repositáře
dostupného na adrese <a
href="https://github.com/tisnik/ocaml-examples/">https://github.com/tisnik/ocaml-examples/</a>.
V&nbsp;tabulce umístěné pod tímto odstavcem jsou uvedeny odkazy na tyto
příklady:</p>

<table>
<tr><th> #</th><th>Příklad</th><th>Popis příkladu</th><th>Cesta</th></tr>
<tr><td> 1</td><td>article_01/hello_world_1.ml</td><td>zavolání funkce <strong>print_string</strong></td><td><a href="https://github.com/tisnik/ocaml-examples/tree/master/article_01/hello_world_1.ml">https://github.com/tisnik/ocaml-examples/tree/master/article_01/hello_world_1.ml</a></td></tr>
<tr><td> 2</td><td>article_01/hello_world_2.ml</td><td>zavolání funkce <strong>printf.Printf</strong></td><td><a href="https://github.com/tisnik/ocaml-examples/tree/master/article_01/hello_world_2.ml">https://github.com/tisnik/ocaml-examples/tree/master/article_01/hello_world_2.ml</a></td></tr>
<tr><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td></tr>
<tr><td> 3</td><td>article_01/function.ml</td><td>definice funkce</td><td><a href="https://github.com/tisnik/ocaml-examples/tree/master/article_01/function.ml">https://github.com/tisnik/ocaml-examples/tree/master/article_01/function.ml</a></td></tr>
<tr><td> 4</td><td>article_01/lambda.ml</td><td>anonymní funkce</td><td><a href="https://github.com/tisnik/ocaml-examples/tree/master/article_01/lambda.ml">https://github.com/tisnik/ocaml-examples/tree/master/article_01/lambda.ml</a></td></tr>
<tr><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td></tr>
<tr><td> 5</td><td>article_01/function_type_1.ml</td><td>explicitní specifikace typu návratové hodnoty funkce</td><td><a href="https://github.com/tisnik/ocaml-examples/tree/master/article_01/function_type_1.ml">https://github.com/tisnik/ocaml-examples/tree/master/article_01/function_type_1.ml</a></td></tr>
<tr><td> 6</td><td>article_01/function_type_2.ml</td><td>explicitní specifikace typu návratové hodnoty funkce</td><td><a href="https://github.com/tisnik/ocaml-examples/tree/master/article_01/function_type_2.ml">https://github.com/tisnik/ocaml-examples/tree/master/article_01/function_type_2.ml</a></td></tr>
<tr><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td></tr>
<tr><td> 7</td><td>article_01/call_function_1.ml</td><td>definice jednoduché funkce s&nbsp;jejím zavoláním</td><td><a href="https://github.com/tisnik/ocaml-examples/tree/master/article_01/call_function_1.ml">https://github.com/tisnik/ocaml-examples/tree/master/article_01/call_function_1.ml</a></td></tr>
<tr><td> 8</td><td>article_01/call_function_2.ml</td><td>definice jednoduché funkce s&nbsp;jejím zavoláním</td><td><a href="https://github.com/tisnik/ocaml-examples/tree/master/article_01/call_function_2.ml">https://github.com/tisnik/ocaml-examples/tree/master/article_01/call_function_2.ml</a></td></tr>
<tr><td> 9</td><td>article_01/call_function_3.ml</td><td>použití operátoru <strong>+</strong> pro dvojici hodnot typu <strong>float</strong></td><td><a href="https://github.com/tisnik/ocaml-examples/tree/master/article_01/call_function_3.ml">https://github.com/tisnik/ocaml-examples/tree/master/article_01/call_function_3.ml</a></td></tr>
<tr><td>10</td><td>article_01/call_function_4.ml</td><td>použití operátoru <strong>+.</strong> pro dvojici hodnot typu <strong>float</strong></td><td><a href="https://github.com/tisnik/ocaml-examples/tree/master/article_01/call_function_4.ml">https://github.com/tisnik/ocaml-examples/tree/master/article_01/call_function_4.ml</a></td></tr>
<tr><td>11</td><td>article_01/call_function_5.ml</td><td>plná deklarace funkce bez syntaktického cukru</td><td><a href="https://github.com/tisnik/ocaml-examples/tree/master/article_01/call_function_5.ml">https://github.com/tisnik/ocaml-examples/tree/master/article_01/call_function_5.ml</a></td></tr>
<tr><td>12</td><td>article_01/call_function_6.ml</td><td>plná deklarace funkce bez syntaktického cukru</td><td><a href="https://github.com/tisnik/ocaml-examples/tree/master/article_01/call_function_6.ml">https://github.com/tisnik/ocaml-examples/tree/master/article_01/call_function_6.ml</a></td></tr>
<tr><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td></tr>
<tr><td>13</td><td>article_01/local_binding_1.ml</td><td>definice lokálních symbolů</td><td><a href="https://github.com/tisnik/ocaml-examples/tree/master/article_01/local_binding_1.ml">https://github.com/tisnik/ocaml-examples/tree/master/article_01/local_binding_1.ml</a></td></tr>
<tr><td>14</td><td>article_01/local_binding_2.ml</td><td>definice lokálních symbolů</td><td><a href="https://github.com/tisnik/ocaml-examples/tree/master/article_01/local_binding_2.ml">https://github.com/tisnik/ocaml-examples/tree/master/article_01/local_binding_2.ml</a></td></tr>
<tr><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td></tr>
<tr><td>15</td><td>article_02/basic_binding.ml</td><td>navázání hodnoty na symbol (deklarace proměnné)</td><td><a href="https://github.com/tisnik/ocaml-examples/tree/master/article_02/basic_binding.ml">https://github.com/tisnik/ocaml-examples/tree/master/article_02/basic_binding.ml</a></td></tr>
<tr><td>16</td><td>article_02/print_variable.ml</td><td>tisk hodnoty proměnné</td><td><a href="https://github.com/tisnik/ocaml-examples/tree/master/article_02/print_variable.ml">https://github.com/tisnik/ocaml-examples/tree/master/article_02/print_variable.ml</a></td></tr>
<tr><td>17</td><td>article_02/variables_and_functions.ml</td><td>předání proměnné do funkce</td><td><a href="https://github.com/tisnik/ocaml-examples/tree/master/article_02/variables_and_functions.ml">https://github.com/tisnik/ocaml-examples/tree/master/article_02/variables_and_functions.ml</a></td></tr>
<tr><td>18</td><td>article_02/redefine_symbol_1.ml</td><td>pokus o redefinici symbolu</td><td><a href="https://github.com/tisnik/ocaml-examples/tree/master/article_02/redefine_symbol_1.ml">https://github.com/tisnik/ocaml-examples/tree/master/article_02/redefine_symbol_1.ml</a></td></tr>
<tr><td>19</td><td>article_02/redefine_symbol_2.ml</td><td>pokus o redefinici symbolu (složitější příklad)</td><td><a href="https://github.com/tisnik/ocaml-examples/tree/master/article_02/redefine_symbol_2.ml">https://github.com/tisnik/ocaml-examples/tree/master/article_02/redefine_symbol_2.ml</a></td></tr>
<tr><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td></tr>
<tr><td>20</td><td>article_02/requal_operator_1.ml</td><td>operátor =</td><td><a href="https://github.com/tisnik/ocaml-examples/tree/master/article_02/equal_operator_1.ml">https://github.com/tisnik/ocaml-examples/tree/master/article_02/equal_operator_1.ml</a></td></tr>
<tr><td>21</td><td>article_02/requal_operator_2.ml</td><td>operátor =</td><td><a href="https://github.com/tisnik/ocaml-examples/tree/master/article_02/equal_operator_2.ml">https://github.com/tisnik/ocaml-examples/tree/master/article_02/equal_operator_2.ml</a></td></tr>
<tr><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td></tr>
<tr><td>22</td><td>article_02/immutable_variable.ml</td><td>&bdquo;změna&ldquo; neměnitelné proměnné</td><td><a href="https://github.com/tisnik/ocaml-examples/tree/master/article_02/immutable_variable.ml">https://github.com/tisnik/ocaml-examples/tree/master/article_02/immutable_variable.ml</a></td></tr>
<tr><td>22</td><td>article_02/mutable_variable.ml</td><td>změna měnitelné proměnné</td><td><a href="https://github.com/tisnik/ocaml-examples/tree/master/article_02/mutable_variable.ml">https://github.com/tisnik/ocaml-examples/tree/master/article_02/mutable_variable.ml</a></td></tr>
<tr><td>23</td><td>article_02/shadow.ml</td><td>shadowing symbolu</td><td><a href="https://github.com/tisnik/ocaml-examples/tree/master/article_02/shadow.ml">https://github.com/tisnik/ocaml-examples/tree/master/article_02/shadow.ml</a></td></tr>
<tr><td>24</td><td>article_02/incr.ml</td><td>standardní funkce <strong>incr</strong></td><td><a href="https://github.com/tisnik/ocaml-examples/tree/master/article_02/incr.ml">https://github.com/tisnik/ocaml-examples/tree/master/article_02/incr.ml</a></td></tr>
<tr><td>25</td><td>article_02/ident.ml</td><td>nejjednodušší polymorfická funkce</td><td><a href="https://github.com/tisnik/ocaml-examples/tree/master/article_02/ident.ml">https://github.com/tisnik/ocaml-examples/tree/master/article_02/ident.ml</a></td></tr>
<tr><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td></tr>
<tr><td>26</td><td>article_02/tuple1.ml</td><td>datový typ n-tice (<i>tuple</i>)</td><td><a href="https://github.com/tisnik/ocaml-examples/tree/master/article_02/tuple1.ml">https://github.com/tisnik/ocaml-examples/tree/master/article_02/tuple1.ml</a></td></tr>
<tr><td>27</td><td>article_02/tuple2.ml</td><td>datový typ n-tice (<i>tuple</i>)</td><td><a href="https://github.com/tisnik/ocaml-examples/tree/master/article_02/tuple2.ml">https://github.com/tisnik/ocaml-examples/tree/master/article_02/tuple2.ml</a></td></tr>
<tr><td>28</td><td>article_02/record1.ml</td><td>datový typ záznam (<i>record</i>), deklarace proměnné tohoto typu</td><td><a href="https://github.com/tisnik/ocaml-examples/tree/master/article_02/record1.ml">https://github.com/tisnik/ocaml-examples/tree/master/article_02/record1.ml</a></td></tr>
<tr><td>29</td><td>article_02/record2.ml</td><td>datový typ záznam (<i>record</i>) a typová inference</td><td><a href="https://github.com/tisnik/ocaml-examples/tree/master/article_02/record2.ml">https://github.com/tisnik/ocaml-examples/tree/master/article_02/record2.ml</a></td></tr>
<tr><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td></tr>
<tr><td>30</td><td>article_02/unit.ml</td><td>datový typ <strong>unit</strong> a rozdíl oproti funkcím bez parametrů</td><td><a href="https://github.com/tisnik/ocaml-examples/tree/master/article_02/unit.ml">https://github.com/tisnik/ocaml-examples/tree/master/article_02/unit.ml</a></td></tr>
<tr><td>31</td><td>article_02/polymorphic.ml</td><td>použití polymorfických funkcí</td><td><a href="https://github.com/tisnik/ocaml-examples/tree/master/article_02/polymorphic.ml">https://github.com/tisnik/ocaml-examples/tree/master/article_02/polymorphic.ml</a></td></tr>
<tr><td>32</td><td>article_02/two_same_records.ml</td><td>dva datové typy záznam se shodnými prvky</td><td><a href="https://github.com/tisnik/ocaml-examples/tree/master/article_02/two_same_records.ml">https://github.com/tisnik/ocaml-examples/tree/master/article_02/two_same_records.ml</a></td></tr>
<tr><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td></tr>
<tr><td>33</td><td>article_03/recursion1.ml</td><td>pokus o deklaraci funkce s&nbsp;přímou rekurzí založený na <strong>let</strong></td><td><a href="https://github.com/tisnik/ocaml-examples/tree/master/article_03/recursion1.ml">https://github.com/tisnik/ocaml-examples/tree/master/article_03/recursion1.ml</a></td></tr>
<tr><td>34</td><td>article_03/recursion2.ml</td><td>deklarace funkce s&nbsp;přímou rekurzí založená na <strong>let rec</strong></td><td><a href="https://github.com/tisnik/ocaml-examples/tree/master/article_03/recursion2.ml">https://github.com/tisnik/ocaml-examples/tree/master/article_03/recursion2.ml</a></td></tr>
<tr><td>35</td><td>article_03/recursion3.ml</td><td>využití tail rekurze pro výpočet členu Fibonacciho posloupnosti</td><td><a href="https://github.com/tisnik/ocaml-examples/tree/master/article_03/recursion3.ml">https://github.com/tisnik/ocaml-examples/tree/master/article_03/recursion3.ml</a></td></tr>
<tr><td>36</td><td>article_03/recursion4.ml</td><td>obyčejná nerekurzivní funkce definovaná přes <strong>let rec</strong></td><td><a href="https://github.com/tisnik/ocaml-examples/tree/master/article_03/recursion4.ml">https://github.com/tisnik/ocaml-examples/tree/master/article_03/recursion4.ml</a></td></tr>
<tr><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td></tr>
<tr><td>37</td><td>article_03/odd_even_1.ml</td><td>nepřímá rekurze (nekorektní varianta)</td><td><a href="https://github.com/tisnik/ocaml-examples/tree/master/article_03/odd_even_1.ml">https://github.com/tisnik/ocaml-examples/tree/master/article_03/odd_even_1.ml</a></td></tr>
<tr><td>38</td><td>article_03/odd_even_2.ml</td><td>nepřímá rekurze (taktéž nekorektní varianta)</td><td><a href="https://github.com/tisnik/ocaml-examples/tree/master/article_03/odd_even_2.ml">https://github.com/tisnik/ocaml-examples/tree/master/article_03/odd_even_2.ml</a></td></tr>
<tr><td>39</td><td>article_03/odd_even_3.ml</td><td>jediný korektní zápis nepřímé rekurze</td><td><a href="https://github.com/tisnik/ocaml-examples/tree/master/article_03/odd_even_3.ml">https://github.com/tisnik/ocaml-examples/tree/master/article_03/odd_even_3.ml</a></td></tr>
<tr><td>40</td><td>article_03/odd_even_4.ml</td><td>nepřímá rekurze bez použití klíčového slova <strong>rec</strong></td><td><a href="https://github.com/tisnik/ocaml-examples/tree/master/article_03/odd_even_4.ml">https://github.com/tisnik/ocaml-examples/tree/master/article_03/odd_even_4.ml</a></td></tr>
<tr><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td></tr>
<tr><td>41</td><td>article_03/pattern1.ml</td><td>výpočet Faktoriálu založený na pattern matchingu</td><td><a href="https://github.com/tisnik/ocaml-examples/tree/master/article_03/pattern1.ml">https://github.com/tisnik/ocaml-examples/tree/master/article_03/pattern1.ml</a></td></tr>
<tr><td>42</td><td>article_03/pattern2.ml</td><td>výpočet Faktoriálu založený na pattern matchingu, sloučení vstupů se stejným výstupem</td><td><a href="https://github.com/tisnik/ocaml-examples/tree/master/article_03/pattern2.ml">https://github.com/tisnik/ocaml-examples/tree/master/article_03/pattern2.ml</a></td></tr>
<tr><td>43</td><td>article_03/pattern3.ml</td><td>kontrola neplatného vstupu</td><td><a href="https://github.com/tisnik/ocaml-examples/tree/master/article_03/pattern3.ml">https://github.com/tisnik/ocaml-examples/tree/master/article_03/pattern3.ml</a></td></tr>
<tr><td>44</td><td>article_03/pattern4.ml</td><td>pattern matching pro větší množství hodnot</td><td><a href="https://github.com/tisnik/ocaml-examples/tree/master/article_03/pattern4.ml">https://github.com/tisnik/ocaml-examples/tree/master/article_03/pattern4.ml</a></td></tr>
<tr><td>45</td><td>article_03/pattern5.ml</td><td>rekurzivní implementace Ackermannovy funkce</td><td><a href="https://github.com/tisnik/ocaml-examples/tree/master/article_03/pattern5.ml">https://github.com/tisnik/ocaml-examples/tree/master/article_03/pattern5.ml</a></td></tr>
<tr><td>46</td><td>article_03/pattern6.ml</td><td>kontrola neplatných vstupních hodnot pro Ackermannovu funkci</td><td><a href="https://github.com/tisnik/ocaml-examples/tree/master/article_03/pattern6.ml">https://github.com/tisnik/ocaml-examples/tree/master/article_03/pattern6.ml</a></td></tr>
<tr><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td></tr>
<tr><td>47</td><td>article_03/fibonacci1.ml</td><td>výpočet Fibonacciho posloupnosti založený na pattern matchingu</td><td><a href="https://github.com/tisnik/ocaml-examples/tree/master/article_03/fibonacci1.ml">https://github.com/tisnik/ocaml-examples/tree/master/article_03/fibonacci1.ml</a></td></tr>
<tr><td>48</td><td>article_03/fibonacci2.ml</td><td>výpočet Fibonacciho posloupnosti založený na pattern matchingu (více idiomatický zápis)</td><td><a href="https://github.com/tisnik/ocaml-examples/tree/master/article_03/fibonacci2.ml">https://github.com/tisnik/ocaml-examples/tree/master/article_03/fibonacci2.ml</a></td></tr>
<tr><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td></tr>
<tr><td>49</td><td>article_03/first.ml</td><td>funkce vracející první prvek z&nbsp;dvojice založená na pattern matchingu</td><td><a href="https://github.com/tisnik/ocaml-examples/tree/master/article_03/first.ml">https://github.com/tisnik/ocaml-examples/tree/master/article_03/first.ml</a></td></tr>
<tr><td>50</td><td>article_03/second.ml</td><td>funkce vracející druhý prvek z&nbsp;dvojice založená na pattern matchingu</td><td><a href="https://github.com/tisnik/ocaml-examples/tree/master/article_03/second.ml">https://github.com/tisnik/ocaml-examples/tree/master/article_03/second.ml</a></td></tr>
<tr><td>51</td><td>article_03/zero_coordinate.ml</td><td>test na nulovou souřadnici/souřadnice založený na pattern matchingu</td><td><a href="https://github.com/tisnik/ocaml-examples/tree/master/article_03/zero_coordinate.ml">https://github.com/tisnik/ocaml-examples/tree/master/article_03/zero_coordinate.ml</a></td></tr>
<tr><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td></tr>
<tr><td>52</td><td>article_03/get_model.ml</td><td>získání prvku ze záznamu (opět založeno na pattern matchingu)</td><td><a href="https://github.com/tisnik/ocaml-examples/tree/master/article_03/get_model.ml">https://github.com/tisnik/ocaml-examples/tree/master/article_03/get_model.ml</a></td></tr>
<tr><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td></tr>
<tr><td>53</td><td>article_03/list_literal_1.ml</td><td>seznam se třemi prvky typu celé číslo</td><td><a href="https://github.com/tisnik/ocaml-examples/tree/master/article_03/list_literal_1.ml">https://github.com/tisnik/ocaml-examples/tree/master/article_03/list_literal_1.ml</a></td></tr>
<tr><td>54</td><td>article_03/list_literal_2.ml</td><td>seznam se třemi prvky typu řetězec</td><td><a href="https://github.com/tisnik/ocaml-examples/tree/master/article_03/list_literal_2.ml">https://github.com/tisnik/ocaml-examples/tree/master/article_03/list_literal_2.ml</a></td></tr>
<tr><td>55</td><td>article_03/list_literal_3.ml</td><td>seznam se třemi prvky typu n-tice</td><td><a href="https://github.com/tisnik/ocaml-examples/tree/master/article_03/list_literal_3.ml">https://github.com/tisnik/ocaml-examples/tree/master/article_03/list_literal_3.ml</a></td></tr>
<tr><td>56</td><td>article_03/list_literal_4.ml</td><td>nekorektní pokus o vytvoření seznamu s&nbsp;prvky různých typů</td><td><a href="https://github.com/tisnik/ocaml-examples/tree/master/article_03/list_literal_4.ml">https://github.com/tisnik/ocaml-examples/tree/master/article_03/list_literal_4.ml</a></td></tr>
<tr><td>57</td><td>article_03/empty_list.ml</td><td>konstrukce prázdného seznamu</td><td><a href="https://github.com/tisnik/ocaml-examples/tree/master/article_03/empty_list.ml">https://github.com/tisnik/ocaml-examples/tree/master/article_03/empty_list.ml</a></td></tr>
<tr><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td></tr>
<tr><td>58</td><td>article_03/head_tail_1.ml</td><td>složení seznamu se dvěma prvky s&nbsp;využitím operátoru <strong>::</strong></td><td><a href="https://github.com/tisnik/ocaml-examples/tree/master/article_03/head_tail_1.ml">https://github.com/tisnik/ocaml-examples/tree/master/article_03/head_tail_1.ml</a></td></tr>
<tr><td>59</td><td>article_03/head_tail_2.ml</td><td>složení seznamu se třemi prvky s&nbsp;využitím operátoru <strong>::</strong></td><td><a href="https://github.com/tisnik/ocaml-examples/tree/master/article_03/head_tail_2.ml">https://github.com/tisnik/ocaml-examples/tree/master/article_03/head_tail_2.ml</a></td></tr>
<tr><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td></tr>
<tr><td>60</td><td>article_03/list_properties.ml</td><td>vlastnosti (<i>properties</i>) seznamů</td><td><a href="https://github.com/tisnik/ocaml-examples/tree/master/article_03/list_properties.ml">https://github.com/tisnik/ocaml-examples/tree/master/article_03/list_properties.ml</a></td></tr>
<tr><td>61</td><td>article_03/len_1.ml</td><td>naivní rekurzivní výpočet délky seznamu</td><td><a href="https://github.com/tisnik/ocaml-examples/tree/master/article_03/len_1.ml">https://github.com/tisnik/ocaml-examples/tree/master/article_03/len_1.ml</a></td></tr>
<tr><td>62</td><td>article_03/len_2.ml</td><td>vylepšený rekurzivní výpočet délky seznamu</td><td><a href="https://github.com/tisnik/ocaml-examples/tree/master/article_03/len_2.ml">https://github.com/tisnik/ocaml-examples/tree/master/article_03/len_2.ml</a></td></tr>
<tr><td>63</td><td>article_03/len_3.ml</td><td>vylepšený rekurzivní výpočet délky seznamu</td><td><a href="https://github.com/tisnik/ocaml-examples/tree/master/article_03/len_3.ml">https://github.com/tisnik/ocaml-examples/tree/master/article_03/len_3.ml</a></td></tr>
<tr><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td></tr>
<tr><td>64</td><td>article_03/join_lists.ml</td><td>spojení dvou seznamů operátorem <strong>::</strong></td><td><a href="https://github.com/tisnik/ocaml-examples/tree/master/article_03/join_lists.ml">https://github.com/tisnik/ocaml-examples/tree/master/article_03/join_lists.ml</a></td></tr>
<tr><td>65</td><td>article_03/append_1.ml</td><td>implementace spojení dvou seznamů rekurzivním výpočtem</td><td><a href="https://github.com/tisnik/ocaml-examples/tree/master/article_03/append_1.ml">https://github.com/tisnik/ocaml-examples/tree/master/article_03/append_1.ml</a></td></tr>
<tr><td>66</td><td>article_03/append_2.ml</td><td>implementace spojení dvou seznamů rekurzivním výpočtem, použití pattern matchingu</td><td><a href="https://github.com/tisnik/ocaml-examples/tree/master/article_03/append_2.ml">https://github.com/tisnik/ocaml-examples/tree/master/article_03/append_2.ml</a></td></tr>
<tr><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td></tr>
<tr><td>67</td><td>article_03/sum_1.ml</td><td>součet hodnot všech prvků v&nbsp;seznamu (bez tail rekurze)</td><td><a href="https://github.com/tisnik/ocaml-examples/tree/master/article_03/sum_1.ml">https://github.com/tisnik/ocaml-examples/tree/master/article_03/sum_1.ml</a></td></tr>
<tr><td>68</td><td>article_03/sum_2.ml</td><td>součet hodnot všech prvků v&nbsp;seznamu (s&nbsp;využitím tail rekurze)</td><td><a href="https://github.com/tisnik/ocaml-examples/tree/master/article_03/sum_2.ml">https://github.com/tisnik/ocaml-examples/tree/master/article_03/sum_2.ml</a></td></tr>
<tr><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td></tr>
<tr><td>69</td><td>article_03/print_int_list.ml</td><td>tisk seznamu celých čísel</td><td><a href="https://github.com/tisnik/ocaml-examples/tree/master/article_03/print_int_list.ml">https://github.com/tisnik/ocaml-examples/tree/master/article_03/print_int_list.ml</a></td></tr>
<tr><td>70</td><td>article_03/print_string_list.ml</td><td>tisk seznamu řetězců</td><td><a href="https://github.com/tisnik/ocaml-examples/tree/master/article_03/print_string_list.ml">https://github.com/tisnik/ocaml-examples/tree/master/article_03/print_string_list.ml</a></td></tr>
<tr><td>71</td><td>article_03/print_list_prefix.ml</td><td>tisk seznamu s&nbsp;prefixem</td><td><a href="https://github.com/tisnik/ocaml-examples/tree/master/article_03/print_list_prefix.ml">https://github.com/tisnik/ocaml-examples/tree/master/article_03/print_list_prefix.ml</a></td></tr>
<tr><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td></tr>
<tr><td>72</td><td>article_04/none_value.ml</td><td>hodnota <strong>None</strong></td><td><a href="https://github.com/tisnik/ocaml-examples/tree/master/article_04/none_value.ml">https://github.com/tisnik/ocaml-examples/tree/master/article_04/none_value.ml</a></td></tr>
<tr><td>73</td><td>article_04/some_value1.ml</td><td>hodnota <strong>Some(typ)</strong></td><td><a href="https://github.com/tisnik/ocaml-examples/tree/master/article_04/some_value1.ml">https://github.com/tisnik/ocaml-examples/tree/master/article_04/some_value1.ml</a></td></tr>
<tr><td>74</td><td>article_04/some_value2.ml</td><td>hodnota <strong>Some(typ)</strong></td><td><a href="https://github.com/tisnik/ocaml-examples/tree/master/article_04/some_value2.ml">https://github.com/tisnik/ocaml-examples/tree/master/article_04/some_value2.ml</a></td></tr>
<tr><td>75</td><td>article_04/some_value3.ml</td><td>hodnota <strong>Some(typ)</strong></td><td><a href="https://github.com/tisnik/ocaml-examples/tree/master/article_04/some_value3.ml">https://github.com/tisnik/ocaml-examples/tree/master/article_04/some_value3.ml</a></td></tr>
<tr><td>76</td><td>article_04/option_exists1.ml</td><td>základní pattern matching, korektní varianta</td><td><a href="https://github.com/tisnik/ocaml-examples/tree/master/article_04/option_exists1.ml">https://github.com/tisnik/ocaml-examples/tree/master/article_04/option_exists1.ml</a></td></tr>
<tr><td>77</td><td>article_04/option_exists2.ml</td><td>základní pattern matching, nekorektní varianta</td><td><a href="https://github.com/tisnik/ocaml-examples/tree/master/article_04/option_exists2.ml">https://github.com/tisnik/ocaml-examples/tree/master/article_04/option_exists2.ml</a></td></tr>
<tr><td>78</td><td>article_04/option_exists3.ml</td><td>základní pattern matching, nekorektní varianta</td><td><a href="https://github.com/tisnik/ocaml-examples/tree/master/article_04/option_exists3.ml">https://github.com/tisnik/ocaml-examples/tree/master/article_04/option_exists3.ml</a></td></tr>
<tr><td>79</td><td>article_04/find_in_list1.ml</td><td>vyhledávání prvku v&nbsp;seznamu založené na pattern matchingu</td><td><a href="https://github.com/tisnik/ocaml-examples/tree/master/article_04/find_in_list1.ml">https://github.com/tisnik/ocaml-examples/tree/master/article_04/find_in_list1.ml</a></td></tr>
<tr><td>80</td><td>article_04/find_in_list2.ml</td><td>varianta předchozího programu</td><td><a href="https://github.com/tisnik/ocaml-examples/tree/master/article_04/find_in_list2.ml">https://github.com/tisnik/ocaml-examples/tree/master/article_04/find_in_list2.ml</a></td></tr>
<tr><td>81</td><td>article_04/option_get.ml</td><td>pokus o přečtení hodnoty obalené typem <strong>Option</strong></td><td><a href="https://github.com/tisnik/ocaml-examples/tree/master/article_04/option_get.ml">https://github.com/tisnik/ocaml-examples/tree/master/article_04/option_get.ml</a></td></tr>
<tr><td>82</td><td>article_04/is_none_is_some.ml</td><td>predikáty <strong>is_none</strong> a <strong>is_some</strong></td><td><a href="https://github.com/tisnik/ocaml-examples/tree/master/article_04/is_none_is_some.ml">https://github.com/tisnik/ocaml-examples/tree/master/article_04/is_none_is_some.ml</a></td></tr>
<tr><td>83</td><td>article_04/option_equal.ml</td><td>ekvivalence dvou obalených hodnot</td><td><a href="https://github.com/tisnik/ocaml-examples/tree/master/article_04/option_equal.ml">https://github.com/tisnik/ocaml-examples/tree/master/article_04/option_equal.ml</a></td></tr>
<tr><td>84</td><td>article_04/some_none.ml</td><td>obalení obalené hodnoty</td><td><a href="https://github.com/tisnik/ocaml-examples/tree/master/article_04/some_none.ml">https://github.com/tisnik/ocaml-examples/tree/master/article_04/some_none.ml</a></td></tr>
<tr><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td></tr>
<tr><td>85</td><td>article_04/result_divide1.ml</td><td>ukázka použití datového typu <strong>Result</strong></td><td><a href="https://github.com/tisnik/ocaml-examples/tree/master/article_04/result_divide1.ml">https://github.com/tisnik/ocaml-examples/tree/master/article_04/result_divide1.ml</a></td></tr>
<tr><td>86</td><td>article_04/result_divide2.ml</td><td>ukázka použití datového typu <strong>Result</strong> a pattern matchingu</td><td><a href="https://github.com/tisnik/ocaml-examples/tree/master/article_04/result_divide2.ml">https://github.com/tisnik/ocaml-examples/tree/master/article_04/result_divide2.ml</a></td></tr>
<tr><td>87</td><td>article_04/result_divide3.ml</td><td>stejné jako result_divide1.fs, ovšem bez explicitního zápisu typů</td><td><a href="https://github.com/tisnik/ocaml-examples/tree/master/article_04/result_divide3.ml">https://github.com/tisnik/ocaml-examples/tree/master/article_04/result_divide3.ml</a></td></tr>
<tr><td>88</td><td>article_04/result_divide4.ml</td><td>stejné jako result_divide2.fs, ovšem bez explicitního zápisu typů</td><td><a href="https://github.com/tisnik/ocaml-examples/tree/master/article_04/result_divide4.ml">https://github.com/tisnik/ocaml-examples/tree/master/article_04/result_divide4.ml</a></td></tr>
<tr><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td></tr>
<tr><td>89</td><td>article_04/array_value.ml</td><td>deklarace pole výčtem jeho prvků</td><td><a href="https://github.com/tisnik/ocaml-examples/tree/master/article_04/array_value.ml">https://github.com/tisnik/ocaml-examples/tree/master/article_04/array_value.ml</a></td></tr>
<tr><td>90</td><td>article_04/array_make.ml</td><td>funkce <strong>Array.make</strong> pro konstrukci pole</td><td><a href="https://github.com/tisnik/ocaml-examples/tree/master/article_04/array_make.ml">https://github.com/tisnik/ocaml-examples/tree/master/article_04/array_make.ml</a></td></tr>
<tr><td>91</td><td>article_04/array_init1.ml</td><td>inicializace prvků pole funkcí <strong>Array.init</strong></td><td><a href="https://github.com/tisnik/ocaml-examples/tree/master/article_04/array_init1.ml">https://github.com/tisnik/ocaml-examples/tree/master/article_04/array_init1.ml</a></td></tr>
<tr><td>92</td><td>article_04/array_init2.ml</td><td>inicializace prvků pole funkcí <strong>Array.init</strong></td><td><a href="https://github.com/tisnik/ocaml-examples/tree/master/article_04/array_init2.ml">https://github.com/tisnik/ocaml-examples/tree/master/article_04/array_init2.ml</a></td></tr>
<tr><td>93</td><td>article_04/array_init3.ml</td><td>inicializace prvků pole funkcí <strong>Array.init</strong></td><td><a href="https://github.com/tisnik/ocaml-examples/tree/master/article_04/array_init3.ml">https://github.com/tisnik/ocaml-examples/tree/master/article_04/array_init3.ml</a></td></tr>
<tr><td>94</td><td>article_04/array_indexing.ml</td><td>indexování prvků pole</td><td><a href="https://github.com/tisnik/ocaml-examples/tree/master/article_04/array_indexing.ml">https://github.com/tisnik/ocaml-examples/tree/master/article_04/array_indexing.ml</a></td></tr>
<tr><td>95</td><td>article_04/array_mutation.ml</td><td>mutace pole: modifikace hodnot jeho prvků</td><td><a href="https://github.com/tisnik/ocaml-examples/tree/master/article_04/array_mutation.ml">https://github.com/tisnik/ocaml-examples/tree/master/article_04/array_mutation.ml</a></td></tr>
<tr><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td></tr>
<tr><td>96</td><td>article_04/option_no_bind.ml</td><td>zřetězení volání funkcí, které si předávají hodnoty typu <strong>Option</strong> &ndash; neidiomatické řešení</td><td><a href="https://github.com/tisnik/ocaml-examples/tree/master/article_04/option_no_bind.ml">https://github.com/tisnik/ocaml-examples/tree/master/article_04/option_no_bind.ml</a></td></tr>
<tr><td>97</td><td>article_04/option_bind.ml</td><td>řešení založené na <strong>bind</strong></td><td><a href="https://github.com/tisnik/ocaml-examples/tree/master/article_04/option_bind.ml">https://github.com/tisnik/ocaml-examples/tree/master/article_04/option_bind.ml</a></td></tr>
<tr><td>98</td><td>article_04/bind_infix_operator.ml</td><td>funkce <strong>Option.bind</strong> zapsaná formou infixového operátoru</td><td><a href="https://github.com/tisnik/ocaml-examples/tree/master/article_04/bind_infix_operator.ml">https://github.com/tisnik/ocaml-examples/tree/master/article_04/bind_infix_operator.ml</a></td></tr>
<tr><td>99</td><td>article_04/bind_infix_operator_2.ml</td><td>zřetězení funkcí s&nbsp;využitím <strong>Result.bind</strong></td><td><a href="https://github.com/tisnik/ocaml-examples/tree/master/article_04/bind_infix_operator_2.ml">https://github.com/tisnik/ocaml-examples/tree/master/article_04/bind_infix_operator_2.ml</a></td></tr>
<tr><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td></tr>
<tr><td>100</td><td>article_05/unary_arithmetic.ml</td><td>unární aritmetické operátory</td><td><a href="https://github.com/tisnik/ocaml-examples/tree/master/article_05/unary_arithmetic.ml">https://github.com/tisnik/ocaml-examples/tree/master/article_05/unary_arithmetic.ml</a></td></tr>
<tr><td>101</td><td>article_05/binary_arithmetic.ml</td><td>binární aritmetické operátory</td><td><a href="https://github.com/tisnik/ocaml-examples/tree/master/article_05/binary_arithmetic.ml">https://github.com/tisnik/ocaml-examples/tree/master/article_05/binary_arithmetic.ml</a></td></tr>
<tr><td>102</td><td>article_05/boolean_operators.ml</td><td>booleovské operátory</td><td><a href="https://github.com/tisnik/ocaml-examples/tree/master/article_05/boolean_operators.ml">https://github.com/tisnik/ocaml-examples/tree/master/article_05/boolean_operators.ml</a></td></tr>
<tr><td>103</td><td>article_05/relational.ml</td><td>základní čtveřice relačních operátorů</td><td><a href="https://github.com/tisnik/ocaml-examples/tree/master/article_05/relational.ml">https://github.com/tisnik/ocaml-examples/tree/master/article_05/relational.ml</a></td></tr>
<tr><td>104</td><td>article_05/equality.ml</td><td>operátory zjišťující ekvivalenci hodnot</td><td><a href="https://github.com/tisnik/ocaml-examples/tree/master/article_05/equality.ml">https://github.com/tisnik/ocaml-examples/tree/master/article_05/equality.ml</a></td></tr>
<tr><td>105</td><td>article_05/joins.ml</td><td>operátory pro spojení řetězců a seznamů</td><td><a href="https://github.com/tisnik/ocaml-examples/tree/master/article_05/joins.ml">https://github.com/tisnik/ocaml-examples/tree/master/article_05/joins.ml</a></td></tr>
<tr><td>106</td><td>article_05/references.ml</td><td>operátory pro práci s&nbsp;referencemi</td><td><a href="https://github.com/tisnik/ocaml-examples/tree/master/article_05/references.ml">https://github.com/tisnik/ocaml-examples/tree/master/article_05/references.ml</a></td></tr>
<tr><td>107</td><td>article_05/function_operators.ml</td><td>operátory pro aplikaci funkcí</td><td><a href="https://github.com/tisnik/ocaml-examples/tree/master/article_05/function_operators.ml">https://github.com/tisnik/ocaml-examples/tree/master/article_05/function_operators.ml</a></td></tr>
<tr><td>108</td><td>article_05/conwoy.ml</td><td>konvoj vytvořený operátorem |&gt;</td><td><a href="https://github.com/tisnik/ocaml-examples/tree/master/article_05/conwoy.ml">https://github.com/tisnik/ocaml-examples/tree/master/article_05/conwoy.ml</a></td></tr>
<tr><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td></tr>
<tr><td>109</td><td>article_05/usage_unary_arithmetic.ml</td><td>test unárních operátorů</td><td><a href="https://github.com/tisnik/ocaml-examples/tree/master/article_05/usage_unary_arithmetic.ml">https://github.com/tisnik/ocaml-examples/tree/master/article_05/usage_unary_arithmetic.ml</a></td></tr>
<tr><td>110</td><td>article_05/usage_binary_arithmetic.ml</td><td>test binárních operátorů</td><td><a href="https://github.com/tisnik/ocaml-examples/tree/master/article_05/usage_binary_arithmetic.ml">https://github.com/tisnik/ocaml-examples/tree/master/article_05/usage_binary_arithmetic.ml</a></td></tr>
<tr><td>111</td><td>article_05/usage_boolean.ml</td><td>test booleovských operátorů</td><td><a href="https://github.com/tisnik/ocaml-examples/tree/master/article_05/usage_boolean.ml">https://github.com/tisnik/ocaml-examples/tree/master/article_05/usage_boolean.ml</a></td></tr>
<tr><td>112</td><td>article_05/usage_relational.ml</td><td>test relačních operátorů vůči různým hodnotám</td><td><a href="https://github.com/tisnik/ocaml-examples/tree/master/article_05/usage_relational.ml">https://github.com/tisnik/ocaml-examples/tree/master/article_05/usage_relational.ml</a></td></tr>
<tr><td>113</td><td>article_05/usage_relational_tuples.ml</td><td>test relačních operátorů vůči n-ticím</td><td><a href="https://github.com/tisnik/ocaml-examples/tree/master/article_05/usage_relational_tuples.ml">https://github.com/tisnik/ocaml-examples/tree/master/article_05/usage_relational_tuples.ml</a></td></tr>
<tr><td>114</td><td>article_05/usage_equality.ml</td><td>testy na strukturální a fyzickou rovnost</td><td><a href="https://github.com/tisnik/ocaml-examples/tree/master/article_05/usage_equality.ml">https://github.com/tisnik/ocaml-examples/tree/master/article_05/usage_equality.ml</a></td></tr>
<tr><td>115</td><td>article_05/usage_joins.ml</td><td>testy operátorů pro spojení řetězců a seznamů</td><td><a href="https://github.com/tisnik/ocaml-examples/tree/master/article_05/usage_joins.ml">https://github.com/tisnik/ocaml-examples/tree/master/article_05/usage_joins.ml</a></td></tr>
<tr><td>116</td><td>article_05/usage_function.ml</td><td>testy operátorů pro aplikaci funkcí</td><td><a href="https://github.com/tisnik/ocaml-examples/tree/master/article_05/usage_function.ml">https://github.com/tisnik/ocaml-examples/tree/master/article_05/usage_function.ml</a></td></tr>
<tr><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td></tr>
<tr><td>117</td><td>article_05/operator_unary_1.ml</td><td>vlastní unární operátor</td><td><a href="https://github.com/tisnik/ocaml-examples/tree/master/article_05/operator_unary_1.ml">https://github.com/tisnik/ocaml-examples/tree/master/article_05/operator_unary_1.ml</a></td></tr>
<tr><td>118</td><td>article_05/operator_unary_2.ml</td><td>vlastní unární operátory</td><td><a href="https://github.com/tisnik/ocaml-examples/tree/master/article_05/operator_unary_2.ml">https://github.com/tisnik/ocaml-examples/tree/master/article_05/operator_unary_2.ml</a></td></tr>
<tr><td>119</td><td>article_05/operator_binary_1.ml</td><td>vlastní binární operátor s&nbsp;asociativitou zleva</td><td><a href="https://github.com/tisnik/ocaml-examples/tree/master/article_05/operator_binary_1.ml">https://github.com/tisnik/ocaml-examples/tree/master/article_05/operator_binary_1.ml</a></td></tr>
<tr><td>120</td><td>article_05/operator_binary_2.ml</td><td>vlastní binární operátor s&nbsp;asociativitou zprava</td><td><a href="https://github.com/tisnik/ocaml-examples/tree/master/article_05/operator_binary_2.ml">https://github.com/tisnik/ocaml-examples/tree/master/article_05/operator_binary_2.ml</a></td></tr>
<tr><td>121</td><td>article_05/operator_binary_3.ml</td><td>vlastní binární operátory s&nbsp;rozdílnou prioritou</td><td><a href="https://github.com/tisnik/ocaml-examples/tree/master/article_05/operator_binary_3.ml">https://github.com/tisnik/ocaml-examples/tree/master/article_05/operator_binary_3.ml</a></td></tr>
<tr><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td></tr>
<tr><td>122</td><td>article_06/circle_rectangle_1.ml</td><td>datový typ přestavující buď kružnici nebo obdélník</td><td><a href="https://github.com/tisnik/ocaml-examples/tree/master/article_06/circle_rectangle_1.ml">https://github.com/tisnik/ocaml-examples/tree/master/article_06/circle_rectangle_1.ml</a></td></tr>
<tr><td>123</td><td>article_06/circle_rectangle_2.ml</td><td>datový typ přestavující buď kružnici nebo obdélník</td><td><a href="https://github.com/tisnik/ocaml-examples/tree/master/article_06/circle_rectangle_2.ml">https://github.com/tisnik/ocaml-examples/tree/master/article_06/circle_rectangle_2.ml</a></td></tr>
<tr><td>124</td><td>article_06/enum_1.ml</td><td>příklad použití datového typu <i>výčet</i></td><td><a href="https://github.com/tisnik/ocaml-examples/tree/master/article_06/enum_1.ml">https://github.com/tisnik/ocaml-examples/tree/master/article_06/enum_1.ml</a></td></tr>
<tr><td>125</td><td>article_06/enum_2.ml</td><td>příklad použití datového typu <i>výčet</i></td><td><a href="https://github.com/tisnik/ocaml-examples/tree/master/article_06/enum_2.ml">https://github.com/tisnik/ocaml-examples/tree/master/article_06/enum_2.ml</a></td></tr>
<tr><td>126</td><td>article_06/expr.ml</td><td>datový typ představující rekurzivní definici výrazu (<i>expression</i>)</td><td><a href="https://github.com/tisnik/ocaml-examples/tree/master/article_06/expr.ml">https://github.com/tisnik/ocaml-examples/tree/master/article_06/expr.ml</a></td></tr>
<tr><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td></tr>
<tr><td>127</td><td>article_06/object_1.ml</td><td>jednoduchá třída s&nbsp;dvojicí atributů</td><td><a href="https://github.com/tisnik/ocaml-examples/tree/master/article_06/object_1.ml">https://github.com/tisnik/ocaml-examples/tree/master/article_06/object_1.ml</a></td></tr>
<tr><td>128</td><td>article_06/object_2.ml</td><td>přidání metody do třídy</td><td><a href="https://github.com/tisnik/ocaml-examples/tree/master/article_06/object_2.ml">https://github.com/tisnik/ocaml-examples/tree/master/article_06/object_2.ml</a></td></tr>
<tr><td>129</td><td>article_06/object_3.ml</td><td>metoda vytvářející nový objekt</td><td><a href="https://github.com/tisnik/ocaml-examples/tree/master/article_06/object_3.ml">https://github.com/tisnik/ocaml-examples/tree/master/article_06/object_3.ml</a></td></tr>
<tr><td>130</td><td>article_06/object_4.ml</td><td>doplnění předchozí třídy o přetížený operátor +</td><td><a href="https://github.com/tisnik/ocaml-examples/tree/master/article_06/object_4.ml">https://github.com/tisnik/ocaml-examples/tree/master/article_06/object_4.ml</a></td></tr>
<tr><td>131</td><td>article_06/object_5.ml</td><td>doplnění předchozí třídy o přetížený operátor + s&nbsp;automatickým odvozením typu</td><td><a href="https://github.com/tisnik/ocaml-examples/tree/master/article_06/object_5.ml">https://github.com/tisnik/ocaml-examples/tree/master/article_06/object_5.ml</a></td></tr>
<tr><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td></tr>
<tr><td>132</td><td>article_06/rectangle_1.ml</td><td>typ Rectangle založený na n-tici</td><td><a href="https://github.com/tisnik/ocaml-examples/tree/master/article_06/rectangle_1.ml">https://github.com/tisnik/ocaml-examples/tree/master/article_06/rectangle_1.ml</a></td></tr>
<tr><td>133</td><td>article_06/rectangle_2.ml</td><td>úprava předchozího příkladu; pattern matching</td><td><a href="https://github.com/tisnik/ocaml-examples/tree/master/article_06/rectangle_2.ml">https://github.com/tisnik/ocaml-examples/tree/master/article_06/rectangle_2.ml</a></td></tr>
<tr><td>134</td><td>article_06/rectangle_3.ml</td><td>úprava předchozího příkladu, explicitní pojmenování</td><td><a href="https://github.com/tisnik/ocaml-examples/tree/master/article_06/rectangle_3.ml">https://github.com/tisnik/ocaml-examples/tree/master/article_06/rectangle_3.ml</a></td></tr>
<tr><td>135</td><td>article_06/rectangle_4.ml</td><td>různé jmenné prostory</td><td><a href="https://github.com/tisnik/ocaml-examples/tree/master/article_06/rectangle_4.ml">https://github.com/tisnik/ocaml-examples/tree/master/article_06/rectangle_4.ml</a></td></tr>
<tr><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td></tr>
<tr><td>136</td><td>article_06/struct_type_1.ml</td><td>definice záznamu (record, struct)</td><td><a href="https://github.com/tisnik/ocaml-examples/tree/master/article_06/struct_type_1.ml">https://github.com/tisnik/ocaml-examples/tree/master/article_06/struct_type_1.ml</a></td></tr>
<tr><td>137</td><td>article_06/struct_type_2.ml</td><td>rozšíření o funkci pro tisk záznamu</td><td><a href="https://github.com/tisnik/ocaml-examples/tree/master/article_06/struct_type_2.ml">https://github.com/tisnik/ocaml-examples/tree/master/article_06/struct_type_2.ml</a></td></tr>
<tr><td>138</td><td>article_06/struct_type_3.ml</td><td>automatické odvození datového typu parametru funkce</td><td><a href="https://github.com/tisnik/ocaml-examples/tree/master/article_06/struct_type_3.ml">https://github.com/tisnik/ocaml-examples/tree/master/article_06/struct_type_3.ml</a></td></tr>
<tr><td>139</td><td>article_06/struct_type_4.ml</td><td>otestování mezí automatického odvozování typů parametrů (nefunkční varianta)</td><td><a href="https://github.com/tisnik/ocaml-examples/tree/master/article_06/struct_type_4.ml">https://github.com/tisnik/ocaml-examples/tree/master/article_06/struct_type_4.ml</a></td></tr>
<tr><td>140</td><td>article_06/struct_type_5.ml</td><td>otestování mezí automatického odvozování typů parametrů (funkční varianta)</td><td><a href="https://github.com/tisnik/ocaml-examples/tree/master/article_06/struct_type_5.ml">https://github.com/tisnik/ocaml-examples/tree/master/article_06/struct_type_5.ml</a></td></tr>
<tr><td>141</td><td>article_06/tree.ml</td><td>datový typ představující rekurzivní definici binárního stromu</td><td><a href="https://github.com/tisnik/ocaml-examples/tree/master/article_06/tree.ml">https://github.com/tisnik/ocaml-examples/tree/master/article_06/tree.ml</a></td></tr>
<tr><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td></tr>
<tr><td>142</td><td>article_07/color-type-1.ml</td><td>definice typu <strong>basic_color</strong></td><td><a href="https://github.com/tisnik/ocaml-examples/tree/master/article_07/color-type-1.ml">https://github.com/tisnik/ocaml-examples/tree/master/article_07/color-type-1.ml</a></td></tr>
<tr><td>143</td><td>article_07/color-type-2.ml</td><td>definice typu <strong>color</strong> a funkce pro převod na RGB</td><td><a href="https://github.com/tisnik/ocaml-examples/tree/master/article_07/color-type-2.ml">https://github.com/tisnik/ocaml-examples/tree/master/article_07/color-type-2.ml</a></td></tr>
<tr><td>144</td><td>article_07/color-type-3.ml</td><td>úplná funkce pro převod základních barev na RGB</td><td><a href="https://github.com/tisnik/ocaml-examples/tree/master/article_07/color-type-3.ml">https://github.com/tisnik/ocaml-examples/tree/master/article_07/color-type-3.ml</a></td></tr>
<tr><td>145</td><td>article_07/color-type-4.ml</td><td>přidání datového typu <strong>Gray</strong></td><td><a href="https://github.com/tisnik/ocaml-examples/tree/master/article_07/color-type-4.ml">https://github.com/tisnik/ocaml-examples/tree/master/article_07/color-type-4.ml</a></td></tr>
<tr><td>146</td><td>article_07/color-type-5.ml</td><td>přidání datového typu <strong>RGB</strong></td><td><a href="https://github.com/tisnik/ocaml-examples/tree/master/article_07/color-type-5.ml">https://github.com/tisnik/ocaml-examples/tree/master/article_07/color-type-5.ml</a></td></tr>
<tr><td>147</td><td>article_07/color-type-6.ml</td><td>převod RGB na RGB (pattern matching)</td><td><a href="https://github.com/tisnik/ocaml-examples/tree/master/article_07/color-type-6.ml">https://github.com/tisnik/ocaml-examples/tree/master/article_07/color-type-6.ml</a></td></tr>
<tr><td>148</td><td>article_07/color-type-7.ml</td><td>možnost specifikace světlosti libovolné základní barvy</td><td><a href="https://github.com/tisnik/ocaml-examples/tree/master/article_07/color-type-7.ml">https://github.com/tisnik/ocaml-examples/tree/master/article_07/color-type-7.ml</a></td></tr>
<tr><td>149</td><td>article_07/color-type-8.ml</td><td>refactoring předchozího příkladu</td><td><a href="https://github.com/tisnik/ocaml-examples/tree/master/article_07/color-type-8.ml">https://github.com/tisnik/ocaml-examples/tree/master/article_07/color-type-8.ml</a></td></tr>
<tr><td>150</td><td>article_07/color-type-9.ml</td><td>podpora pro barvový prostor HSV</td><td><a href="https://github.com/tisnik/ocaml-examples/tree/master/article_07/color-type-9.ml">https://github.com/tisnik/ocaml-examples/tree/master/article_07/color-type-9.ml</a></td></tr>
<tr><td>151</td><td>article_07/color-type-A.ml</td><td>refactoring předchozího příkladu: použití <strong>function</strong></td><td><a href="https://github.com/tisnik/ocaml-examples/tree/master/article_07/color-type-A.ml">https://github.com/tisnik/ocaml-examples/tree/master/article_07/color-type-A.ml</a></td></tr>
<tr><td>152</td><td>article_07/color-type-B.ml</td><td>podpora pro mix dvou barev se specifikací poměru obou barev</td><td><a href="https://github.com/tisnik/ocaml-examples/tree/master/article_07/color-type-B.ml">https://github.com/tisnik/ocaml-examples/tree/master/article_07/color-type-B.ml</a></td></tr>
<tr><td>153</td><td>article_07/hsv-to-rgb.ml</td><td>převod barvy z&nbsp;prostoru HSV to RGB</td><td><a href="https://github.com/tisnik/ocaml-examples/tree/master/article_07/hsv-to-rgb.ml">https://github.com/tisnik/ocaml-examples/tree/master/article_07/hsv-to-rgb.ml</a></td></tr>
</table>



<p><a name="k20"></a></p>
<h2 id="k20">20. Odkazy na Internetu</h2>

<ol>

<li>General-Purpose, Industrial-Strength, Expressive, and Safe<br />
<a href="https://ocaml.org/">https://ocaml.org/</a>
</li>

<li>OCaml playground<br />
<a href="https://ocaml.org/play">https://ocaml.org/play</a>
</li>

<li>Online Ocaml Compiler IDE<br />
<a href="https://www.jdoodle.com/compile-ocaml-online/">https://www.jdoodle.com/compile-ocaml-online/</a>
</li>

<li>Get Started - OCaml<br />
<a href="https://www.ocaml.org/docs">https://www.ocaml.org/docs</a>
</li>

<li>Get Up and Running With OCaml<br />
<a href="https://www.ocaml.org/docs/up-and-running">https://www.ocaml.org/docs/up-and-running</a>
</li>

<li>Better OCaml (Online prostředí)<br />
<a href="https://betterocaml.ml/?version=4.14.0">https://betterocaml.ml/?version=4.14.0</a>
</li>

<li>OCaml file extensions<br />
<a href="https://blog.waleedkhan.name/ocaml-file-extensions/">https://blog.waleedkhan.name/ocaml-file-extensions/</a>
</li>

<li>First thoughts on Rust vs OCaml<br />
<a href="https://blog.darklang.com/first-thoughts-on-rust-vs-ocaml/">https://blog.darklang.com/first-thoughts-on-rust-vs-ocaml/</a>
</li>

<li>Standard ML of New Jersey<br />
<a href="https://www.smlnj.org/">https://www.smlnj.org/</a>
</li>

<li>Programming Languages: Standard ML - 1 (a navazující videa)<br />
<a href="https://www.youtube.com/watch?v=2sqjUWGGzTo">https://www.youtube.com/watch?v=2sqjUWGGzTo</a>
</li>

<li>6 Excellent Free Books to Learn Standard ML<br />
<a href="https://www.linuxlinks.com/excellent-free-books-learn-standard-ml/">https://www.linuxlinks.com/excellent-free-books-learn-standard-ml/</a>
</li>

<li>SOSML: The Online Interpreter for Standard ML<br />
<a href="https://sosml.org/">https://sosml.org/</a>
</li>

<li>ML (Computer program language)<br />
<a href="https://www.barnesandnoble.com/b/books/other-programming-languages/ml-computer-program-language/_/N-29Z8q8Zvy7">https://www.barnesandnoble.com/b/books/other-programming-languages/ml-computer-program-language/_/N-29Z8q8Zvy7</a>
</li>

<li>Strong Typing<br />
<a href="https://perl.plover.com/yak/typing/notes.html">https://perl.plover.com/yak/typing/notes.html</a>
</li>

<li>What to know before debating type systems<br />
<a href="http://blogs.perl.org/users/ovid/2010/08/what-to-know-before-debating-type-systems.html">http://blogs.perl.org/users/ovid/2010/08/what-to-know-before-debating-type-systems.html</a>
</li>

<li>Types, and Why You Should Care (Youtube)<br />
<a href="https://www.youtube.com/watch?v=0arFPIQatCU">https://www.youtube.com/watch?v=0arFPIQatCU</a>
</li>

<li>DynamicTyping (Martin Fowler)<br />
<a href="https://www.martinfowler.com/bliki/DynamicTyping.html">https://www.martinfowler.com/bliki/DynamicTyping.html</a>
</li>

<li>DomainSpecificLanguage (Martin Fowler)<br />
<a href="https://www.martinfowler.com/bliki/DomainSpecificLanguage.html">https://www.martinfowler.com/bliki/DomainSpecificLanguage.html</a>
</li>

<li>Language Workbenches: The Killer-App for Domain Specific Languages?<br />
<a href="https://www.martinfowler.com/articles/languageWorkbench.html">https://www.martinfowler.com/articles/languageWorkbench.html</a>
</li>

<li>Effective ML (Youtube)<br />
<a href="https://www.youtube.com/watch?v=-J8YyfrSwTk">https://www.youtube.com/watch?v=-J8YyfrSwTk</a>
</li>

<li>Why OCaml (Youtube)<br />
<a href="https://www.youtube.com/watch?v=v1CmGbOGb2I">https://www.youtube.com/watch?v=v1CmGbOGb2I</a>
</li>

<li>Try OCaml<br />
<a href="https://try.ocaml.pro/">https://try.ocaml.pro/</a>
</li>

<li>CSE 341: Functions and patterns<br />
<a href="https://courses.cs.washington.edu/courses/cse341/04wi/lectures/03-ml-functions.html">https://courses.cs.washington.edu/courses/cse341/04wi/lectures/03-ml-functions.html</a>
</li>

<li>Comparing Objective Caml and Standard ML<br />
<a href="http://adam.chlipala.net/mlcomp/">http://adam.chlipala.net/mlcomp/</a>
</li>

<li>What are the key differences between Standard ML and OCaml?<br />
<a href="https://www.quora.com/What-are-the-key-differences-between-Standard-ML-and-OCaml?share=1">https://www.quora.com/What-are-the-key-differences-between-Standard-ML-and-OCaml?share=1</a>
</li>

<li>Cheat Sheets (pro OCaml)<br />
<a href="https://www.ocaml.org/docs/cheat_sheets.html">https://www.ocaml.org/docs/cheat_sheets.html</a>
</li>

<li>Think OCaml: How to Think Like a (Functional) Programmer<br />
<a href="https://www.greenteapress.com/thinkocaml/thinkocaml.pdf">https://www.greenteapress.com/thinkocaml/thinkocaml.pdf</a>
</li>

<li>The OCaml Language Cheat Sheet<br />
<a href="https://ocamlpro.github.io/ocaml-cheat-sheets/ocaml-lang.pdf">https://ocamlpro.github.io/ocaml-cheat-sheets/ocaml-lang.pdf</a>
</li>

<li>Syllabus (FAS CS51)<br />
<a href="https://cs51.io/college/syllabus/">https://cs51.io/college/syllabus/</a>
</li>

<li>Abstraction and Design In Computation<br />
<a href="http://book.cs51.io/">http://book.cs51.io/</a>
</li>

<li>Learn X in Y minutes Where X=Standard ML<br />
<a href="https://learnxinyminutes.com/docs/standard-ml/">https://learnxinyminutes.com/docs/standard-ml/</a>
</li>

<li>CSE307 Online - Summer 2018: Principles of Programing Languages course<br />
<a href="https://www3.cs.stonybrook.edu/~pfodor/courses/summer/cse307.html">https://www3.cs.stonybrook.edu/~pfodor/courses/summer/cse307.html</a>
</li>

<li>CSE307 Principles of Programming Languages course: SML part 1<br />
<a href="https://www.youtube.com/watch?v=p1n0_PsM6hw">https://www.youtube.com/watch?v=p1n0_PsM6hw</a>
</li>

<li>CSE 307 &ndash; Principles of Programming Languages &ndash; SML<br />
<a href="https://www3.cs.stonybrook.edu/~pfodor/courses/summer/CSE307/L01_SML.pdf">https://www3.cs.stonybrook.edu/~pfodor/courses/summer/CSE307/L01_SML.pdf</a>
</li>

<li>SML, Some Basic Examples<br />
<a href="https://cs.fit.edu/~ryan/sml/intro.html">https://cs.fit.edu/~ryan/sml/intro.html</a>
</li>

<li>History of programming languages<br />
<a href="https://devskiller.com/history-of-programming-languages/">https://devskiller.com/history-of-programming-languages/</a>
</li>

<li>History of programming languages (Wikipedia)<br />
<a href="https://en.wikipedia.org/wiki/History_of_programming_languages">https://en.wikipedia.org/wiki/History_of_programming_languages</a>
</li>

<li>Jemný úvod do rozsáhlého světa jazyků LISP a Scheme<br />
<a href="https://www.root.cz/clanky/jemny-uvod-do-rozsahleho-sveta-jazyku-lisp-a-scheme/">https://www.root.cz/clanky/jemny-uvod-do-rozsahleho-sveta-jazyku-lisp-a-scheme/</a>
</li>

<li>The Evolution Of Programming Languages<br />
<a href="https://www.i-programmer.info/news/98-languages/8809-the-evolution-of-programming-languages.html">https://www.i-programmer.info/news/98-languages/8809-the-evolution-of-programming-languages.html</a>
</li>

<li>Evoluce programovacích jazyků<br />
<a href="https://ccrma.stanford.edu/courses/250a-fall-2005/docs/ComputerLanguagesChart.png">https://ccrma.stanford.edu/courses/250a-fall-2005/docs/ComputerLanguagesChart.png</a>
</li>

<li>Poly/ML Homepage<br />
<a href="https://polyml.org/">https://polyml.org/</a>
</li>

<li>PolyConf 16: A brief history of F# / Rachel Reese<br />
<a href="https://www.youtube.com/watch?v=cbDjpi727aY">https://www.youtube.com/watch?v=cbDjpi727aY</a>
</li>

<li>Programovací jazyk Clojure 18: základní techniky optimalizace aplikací<br />
<a href="https://www.root.cz/clanky/programovaci-jazyk-clojure-18-zakladni-techniky-optimalizace-aplikaci/">https://www.root.cz/clanky/programovaci-jazyk-clojure-18-zakladni-techniky-optimalizace-aplikaci/</a>
</li>

<li>Moscow ML Language Overview<br />
<a href="https://itu.dk/people/sestoft/mosml/mosmlref.pdf">https://itu.dk/people/sestoft/mosml/mosmlref.pdf</a>
</li>

<li>ForLoops<br />
<a href="http://mlton.org/ForLoops">http://mlton.org/ForLoops</a>
</li>

<li>Funkcionální dobrodružství v&nbsp;JavaScriptu<br />
<a href="https://blog.kolman.cz/2015/12/funkcionalni-dobrodruzstvi-v-javascriptu.html">https://blog.kolman.cz/2015/12/funkcionalni-dobrodruzstvi-v-javascriptu.html</a>
</li>

<li>Recenze knihy Functional Thinking (Paradigm over syntax)<br />
<a href="https://www.root.cz/clanky/recenze-knihy-functional-thinking-paradigm-over-syntax/">https://www.root.cz/clanky/recenze-knihy-functional-thinking-paradigm-over-syntax/</a>
</li>

<li>Currying<br />
<a href="https://sw-samuraj.cz/2011/02/currying/">https://sw-samuraj.cz/2011/02/currying/</a>
</li>

<li>Používání funkcí v&nbsp;F#<br />
<a href="https://docs.microsoft.com/cs-cz/dotnet/fsharp/tutorials/using-functions">https://docs.microsoft.com/cs-cz/dotnet/fsharp/tutorials/using-functions</a>
</li>

<li>Funkce vyššího řádu<br />
<a href="http://naucte-se.haskell.cz/funkce-vyssiho-radu">http://naucte-se.haskell.cz/funkce-vyssiho-radu</a>
</li>

<li>Currying (Wikipedia)<br />
<a href="https://en.wikipedia.org/wiki/Currying">https://en.wikipedia.org/wiki/Currying</a>
</li>

<li>Currying (Haskell wiki)<br />
<a href="https://wiki.haskell.org/Currying">https://wiki.haskell.org/Currying</a>
</li>

<li>Haskell Curry<br />
<a href="https://en.wikipedia.org/wiki/Haskell_Curry">https://en.wikipedia.org/wiki/Haskell_Curry</a>
</li>

<li>Moses Schönfinkel<br />
<a href="https://en.wikipedia.org/wiki/Moses_Sch%C3%B6nfinkel">https://en.wikipedia.org/wiki/Moses_Sch%C3%B6nfinkel</a>
</li>

<li>.NET framework<br />
<a href="https://dotnet.microsoft.com/en-us/">https://dotnet.microsoft.com/en-us/</a>
</li>

<li>F# - .NET Blog<br />
<a href="https://devblogs.microsoft.com/dotnet/category/fsharp/">https://devblogs.microsoft.com/dotnet/category/fsharp/</a>
</li>

<li>Playground: OCaml<br />
<a href="https://ocaml.org/play">https://ocaml.org/play</a>
</li>

<li>The F# Survival Guide<br />
<a href="https://web.archive.org/web/20110715231625/http://www.ctocorner.com/fsharp/book/default.aspx">https://web.archive.org/web/20110715231625/http://www.ctocorner.com/fsharp/book/default.aspx</a>
</li>

<li>Object-Oriented Programming — The Trillion Dollar Disaster<br />
<a href="https://betterprogramming.pub/object-oriented-programming-the-trillion-dollar-disaster-92a4b666c7c7">https://betterprogramming.pub/object-oriented-programming-the-trillion-dollar-disaster-92a4b666c7c7</a>
</li>

<li>Goodbye, Object Oriented Programming<br />
<a href="https://cscalfani.medium.com/goodbye-object-oriented-programming-a59cda4c0e53">https://cscalfani.medium.com/goodbye-object-oriented-programming-a59cda4c0e53</a>
</li>

<li>So You Want to be a Functional Programmer (Part 1)<br />
<a href="https://cscalfani.medium.com/so-you-want-to-be-a-functional-programmer-part-1-1f15e387e536">https://cscalfani.medium.com/so-you-want-to-be-a-functional-programmer-part-1-1f15e387e536</a>
</li>

<li>So You Want to be a Functional Programmer (Part 2)<br />
<a href="https://cscalfani.medium.com/so-you-want-to-be-a-functional-programmer-part-2-7005682cec4a">https://cscalfani.medium.com/so-you-want-to-be-a-functional-programmer-part-2-7005682cec4a</a>
</li>

<li>So You Want to be a Functional Programmer (Part 3)<br />
<a href="https://cscalfani.medium.com/so-you-want-to-be-a-functional-programmer-part-3-1b0fd14eb1a7">https://cscalfani.medium.com/so-you-want-to-be-a-functional-programmer-part-3-1b0fd14eb1a7</a>
</li>

<li>So You Want to be a Functional Programmer (Part 4)<br />
<a href="https://cscalfani.medium.com/so-you-want-to-be-a-functional-programmer-part-4-18fbe3ea9e49">https://cscalfani.medium.com/so-you-want-to-be-a-functional-programmer-part-4-18fbe3ea9e49</a>
</li>

<li>So You Want to be a Functional Programmer (Part 5)<br />
<a href="https://cscalfani.medium.com/so-you-want-to-be-a-functional-programmer-part-5-c70adc9cf56a">https://cscalfani.medium.com/so-you-want-to-be-a-functional-programmer-part-5-c70adc9cf56a</a>
</li>

<li>So You Want to be a Functional Programmer (Part 6)<br />
<a href="https://cscalfani.medium.com/so-you-want-to-be-a-functional-programmer-part-6-db502830403">https://cscalfani.medium.com/so-you-want-to-be-a-functional-programmer-part-6-db502830403</a>
</li>

<li>Don Syme<br />
<a href="https://en.wikipedia.org/wiki/Don_Syme">https://en.wikipedia.org/wiki/Don_Syme</a>
</li>

<li>Python to OCaml: Retrospective<br />
<a href="http://roscidus.com/blog/blog/2014/06/06/python-to-ocaml-retrospective/">http://roscidus.com/blog/blog/2014/06/06/python-to-ocaml-retrospective/</a>
</li>

<li>Why does Cambridge teach OCaml as the first programming language?<br />
<a href="https://www.youtube.com/watch?v=6APBx0WsgeQ">https://www.youtube.com/watch?v=6APBx0WsgeQ</a>
</li>

<li>OCaml and 7 Things You Need To Know About It In 2021 | Functional Programming | Caml<br />
<a href="https://www.youtube.com/watch?v=s0itOsgcf9Q">https://www.youtube.com/watch?v=s0itOsgcf9Q</a>
</li>

<li>OCaml 2021 - 25 years of OCaml<br />
<a href="https://www.youtube.com/watch?v=-u_zKPXj6mw">https://www.youtube.com/watch?v=-u_zKPXj6mw</a>
</li>

<li>Introduction | OCaml Programming | Chapter 1 Video 1<br />
<a href="https://www.youtube.com/watch?v=MUcka_SvhLw&amp;list=PLre5AT9JnKShBOPeuiD9b-I4XROIJhkIU">https://www.youtube.com/watch?v=MUcka_SvhLw&amp;list=PLre5AT9JnKShBOPeuiD9b-I4XROIJhkIU</a>
</li>

<li>Functional Programming - What | OCaml Programming | Chapter 1 Video 2<br />
<a href="https://www.youtube.com/watch?v=JTEwC3HihFc&amp;list=PLre5AT9JnKShBOPeuiD9b-I4XROIJhkIU&amp;index=2">https://www.youtube.com/watch?v=JTEwC3HihFc&amp;list=PLre5AT9JnKShBOPeuiD9b-I4XROIJhkIU&amp;index=2</a>
</li>

<li>Functional Programming - Why Part 1 | OCaml Programming | Chapter 1 Video 3<br />
<a href="https://www.youtube.com/watch?v=SKr3ItChPSI&amp;list=PLre5AT9JnKShBOPeuiD9b-I4XROIJhkIU&amp;index=3">https://www.youtube.com/watch?v=SKr3ItChPSI&amp;list=PLre5AT9JnKShBOPeuiD9b-I4XROIJhkIU&amp;index=3</a>
</li>

<li>Functional Programming - Why Part 2 | OCaml Programming | Chapter 1 Video 4<br />
<a href="https://www.youtube.com/watch?v=eNLm5Xbgmd0&amp;list=PLre5AT9JnKShBOPeuiD9b-I4XROIJhkIU&amp;index=4">https://www.youtube.com/watch?v=eNLm5Xbgmd0&amp;list=PLre5AT9JnKShBOPeuiD9b-I4XROIJhkIU&amp;index=4</a>
</li>

<li>OCaml | OCaml Programming | Chapter 1 Video 5<br />
<a href="https://www.youtube.com/watch?v=T-DIW1dhYzo&amp;list=PLre5AT9JnKShBOPeuiD9b-I4XROIJhkIU&amp;index=5">https://www.youtube.com/watch?v=T-DIW1dhYzo&amp;list=PLre5AT9JnKShBOPeuiD9b-I4XROIJhkIU&amp;index=5</a>
</li>

<li>Five Aspects of Learning a Programming Language | OCaml Programming | Chapter 2 Video 1<br />
<a href="https://www.youtube.com/watch?v=A5IHFZtRfBs&amp;list=PLre5AT9JnKShBOPeuiD9b-I4XROIJhkIU&amp;index=6">https://www.youtube.com/watch?v=A5IHFZtRfBs&amp;list=PLre5AT9JnKShBOPeuiD9b-I4XROIJhkIU&amp;index=6</a>
</li>

<li>Expressions | OCaml Programming | Chapter 2 Video 2<br />
<a href="https://www.youtube.com/watch?v=3fzrFY-2ZQ8&amp;list=PLre5AT9JnKShBOPeuiD9b-I4XROIJhkIU&amp;index=7">https://www.youtube.com/watch?v=3fzrFY-2ZQ8&amp;list=PLre5AT9JnKShBOPeuiD9b-I4XROIJhkIU&amp;index=7</a>
</li>

<li>If Expressions | OCaml Programming | Chapter 2 Video 3<br />
<a href="https://www.youtube.com/watch?v=XJ6QPtlPD7s&amp;list=PLre5AT9JnKShBOPeuiD9b-I4XROIJhkIU&amp;index=8">https://www.youtube.com/watch?v=XJ6QPtlPD7s&amp;list=PLre5AT9JnKShBOPeuiD9b-I4XROIJhkIU&amp;index=8</a>
</li>

<li>Let Definitions | OCaml Programming | Chapter 2 Video 4<br />
<a href="https://www.youtube.com/watch?v=eRnG4gwOTlI&amp;list=PLre5AT9JnKShBOPeuiD9b-I4XROIJhkIU&amp;index=10">https://www.youtube.com/watch?v=eRnG4gwOTlI&amp;list=PLre5AT9JnKShBOPeuiD9b-I4XROIJhkIU&amp;index=10</a>
</li>

<li>Let Expressions | OCaml Programming | Chapter 2 Video 5<br />
<a href="https://www.youtube.com/watch?v=ug3L97FXC6A&amp;list=PLre5AT9JnKShBOPeuiD9b-I4XROIJhkIU&amp;index=10">https://www.youtube.com/watch?v=ug3L97FXC6A&amp;list=PLre5AT9JnKShBOPeuiD9b-I4XROIJhkIU&amp;index=10</a>
</li>

<li>Variable Expressions and Scope | OCaml Programming | Chapter 2 Video 6<br />
<a href="https://www.youtube.com/watch?v=_TpTC6eo34M&amp;list=PLre5AT9JnKShBOPeuiD9b-I4XROIJhkIU&amp;index=11">https://www.youtube.com/watch?v=_TpTC6eo34M&amp;list=PLre5AT9JnKShBOPeuiD9b-I4XROIJhkIU&amp;index=11</a>
</li>

<li>Scope and the Toplevel | OCaml Programming | Chapter 2 Video 7<br />
<a href="https://www.youtube.com/watch?v=4SqMkUwakEA&amp;list=PLre5AT9JnKShBOPeuiD9b-I4XROIJhkIU&amp;index=12">https://www.youtube.com/watch?v=4SqMkUwakEA&amp;list=PLre5AT9JnKShBOPeuiD9b-I4XROIJhkIU&amp;index=12</a>
</li>

<li>Anonymous Functions | OCaml Programming | Chapter 2 Video 8<br />
<a href="https://www.youtube.com/watch?v=JwoIIrj0bcM&amp;list=PLre5AT9JnKShBOPeuiD9b-I4XROIJhkIU&amp;index=13">https://www.youtube.com/watch?v=JwoIIrj0bcM&amp;list=PLre5AT9JnKShBOPeuiD9b-I4XROIJhkIU&amp;index=13</a>
</li>

<li>Lambdas | OCaml Programming | Chapter 2 Video 9<br />
<a href="https://www.youtube.com/watch?v=zHHCD7MOjmw&amp;list=PLre5AT9JnKShBOPeuiD9b-I4XROIJhkIU&amp;index=15">https://www.youtube.com/watch?v=zHHCD7MOjmw&amp;list=PLre5AT9JnKShBOPeuiD9b-I4XROIJhkIU&amp;index=15</a>
</li>

<li>Operators<br />
<a href="https://ocaml.org/docs/operators">https://ocaml.org/docs/operators</a>
</li>

<li>Operator overloading<br />
<a href="https://en.wikipedia.org/wiki/Operator_overloading">https://en.wikipedia.org/wiki/Operator_overloading</a>
</li>

<li>Generalized algebraic data type<br />
<a href="https://en.wikipedia.org/wiki/Generalized_algebraic_data_type">https://en.wikipedia.org/wiki/Generalized_algebraic_data_type</a>
</a>

</ol>



<p></p><p></p>
<p><small>Autor: <a href="http://www.fit.vutbr.cz/~tisnovpa">Pavel Tišnovský</a> &nbsp; 2023</small></p>
</body>
</html>

