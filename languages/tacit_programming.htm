<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
        "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html>
<head>
<title></title>
<meta name="Author" content="Pavel Tisnovsky" />
<meta name="Generator" content="vim" />
<meta http-equiv="content-type" content="text/html; charset=utf-8" />
<style type="text/css">
         body {color:#000000; background:#ffffff;}
         h1  {font-family: arial, helvetica, sans-serif; color:#ffffff; background-color:#c00000; text-align:center; padding-left:1em}
         h2  {font-family: arial, helvetica, sans-serif; color:#ffffff; background-color:#0000c0; padding-left:1em; text-align:left}
         h3  {font-family: arial, helvetica, sans-serif; color:#000000; background-color:#c0c0c0; padding-left:1em; text-align:left}
         h4  {font-family: arial, helvetica, sans-serif; color:#000000; background-color:#e0e0e0; padding-left:1em; text-align:left}
         a   {font-family: arial, helvetica, sans-serif;}
         li  {font-family: arial, helvetica, sans-serif; color:#000000; text-align:justify; width:450px;}
         ol  {font-family: arial, helvetica, sans-serif; color:#000000; text-align:justify; width:450px;}
         ul  {font-family: arial, helvetica, sans-serif; color:#000000; text-align:justify; width:450px;}
         p   {font-family: arial, helvetica, sans-serif; color:#000000; text-align:justify;}
         pre {background:#e0e0e0}
</style>
</head>

<body>

<h1></h1>

<h3>Pavel Tišnovský</h3>

<p></p>

<h1>Úvodník</h1>

<p></p>



<h2>Obsah</h2>

<p><a href="#k01">1. Programovací technika nazvaná <i>tacit programming</i></a></p>
<p><a href="#k02">2. Kolony (roury) v&nbsp;shellu</a></p>
<p><a href="#k03">3. Tacit programming a reálné programovací jazyky</a></p>
<p><a href="#k04">4. Programovací jazyky založené na zásobníku operandů a RPN</a></p>
<p><a href="#k05">5. Operace nad daty uloženými na zásobníku operandů</a></p>
<p><a href="#k06">6. Programovací jazyk Joy</a></p>
<p><a href="#k07">7. Definice nových funkcí v&nbsp;jazyku Joy, volání funkcí</a></p>
<p><a href="#k08">*** 8. Rekurzivní kombinátory v&nbsp;jazyce Joy</a></p>
<p><a href="#k09">*** 9. </a></p>
<p><a href="#k10">*** 10. </a></p>
<p><a href="#k11">*** 11. </a></p>
<p><a href="#k12">*** 12. </a></p>
<p><a href="#k13">*** 13. </a></p>
<p><a href="#k14">*** 14. </a></p>
<p><a href="#k15">*** 15. </a></p>
<p><a href="#k16">*** 16. </a></p>
<p><a href="#k17">*** 17. </a></p>
<p><a href="#k18">*** 18. </a></p>
<p><a href="#k19">*** 19. </a></p>
<p><a href="#k20">20. Odkazy na Internetu</a></p>



<p><a name="k01"></a></p>
<h2 id="k01">1. Programovací technika nazvaná <i>tacit programming</i></h2>

<p>V&nbsp;dnešním článku se seznámíme se zajímavou programovací technikou,
která je nazývána <i>point-free style</i> popř.&nbsp;v&nbsp;některých
programovacích jazycích <i>tacit programming</i>. Přesný a přitom dostatečně
jednoznačný český ekvivalent tohoto označení mě nenapadá, proto raději zůstanu
u termínu anglického, který se ostatně snadněji vyhledává. Co se ovšem pod
názvy <i>tacit programming</i> nebo <i>point-free style</i> skrývá? Jedná se o
styl zápisu bloků programů (typicky jednotlivých výrazů, ale i uživatelských
funkcí popř.&nbsp;sekvencí funkcí, někdy o zápis dekorátorů), ve kterých se
nachází volání jiných funkcí, ovšem bez explicitního udání jmen jejich
argumentů (parametrů). A nejenom to &ndash; většinou není naznačen ani počet
argumentů. Proč by se však <i>tacit programming</i> měl používat,
resp.&nbsp;jaká je jeho přednost? Základní idea spočívá v&nbsp;tom, že se
seskupením funkcí popř.&nbsp;operátorů vytvoří abstraktnější funkce nebo
operátor, takže je možné v&nbsp;programovacím jazyce vybaveném relativně
základními operacemi vytvářet vyšší úrovně abstrakce podle potřeb programátora,
a to za použití snadno pochopitelných a testovatelných prostředků a idiomů.</p>

<p><div class="rs-tip-major">Poznámka: poměrně často používám v&nbsp;článcích
pojem &bdquo;idiom&ldquo; pro ustálenou strukturu/notaci v&nbsp;daném obvyklou
programovacím jazyce. Důsledné používání idiomů vede ke kódu, který je
srozumitelný i pro další programátory. A nejenom to &ndash; v&nbsp;takovém kódu
se obecně nachází menší množství logických chyb. Naopak <i>ne</i>použití idiomu
programátory zbytečně zmate.</div></p>

<p>S&nbsp;<i>tacit programmingem</i> se můžeme setkat v&nbsp;mnoha navzájem
odlišných prostředích a v&nbsp;různých programovacích jazycích. Asi
nejznámějším příkladem jsou dobře známé <i>kolony</i> v&nbsp;shellu, dále
technika vytváření nových slov v&nbsp;jazycích založených na RPN (což jsou
jazyky jako Forth, Joy, Factor, PostScript, ...), technika operátorů použitá
v&nbsp;programovacích jazycích APL a J (zde se pravděpodobně poprvé objevuje
označení <i>train</i>) a zapomenout nesmíme ani na jazyk Haskell popř.&nbsp;na
Clojure (s&nbsp;threading makry a takzvanými <i>transducery</i>).</p>



<p><a name="k02"></a></p>
<h2 id="k02">2. Kolony (roury) v&nbsp;shellu</h2>

<p>Lze předpokládat, že naprostá většina čtenářů Roota se s&nbsp;programovací
technikou, kterou budeme v&nbsp;tomto článku označovat termínem <i>tacit
programming</i> již setkala, a to přímo v&nbsp;shellu. Konkrétně se jedná o
použití klasických <i>kolon</i>, protože každý příkaz uvnitř kolony čte data
z&nbsp;předchozího příkazu, transformuje či nějakým způsobem agreguje tato data
a posílá výsledky příkazu dalšímu (a pro propojení dvou zpracovávajících entit
v&nbsp;koloně se používá <i>roura</i>). Výjimkou je první popř.&nbsp;poslední
příkaz, který je ke koloně připojen jen zleva či zprava. Na následujícím
demonstračním příkladu je ukázána velmi jednoduchá kolona, přičemž ta část,
kterou bychom mohli označit termínem <i>tacit programming</i> nebo
<i>point-free style</i>, je zvýrazněna tučným písmem:</p>

<pre>
cat foobar | <strong>tr ',' '\n' | sort | uniq | rev | head -n 10</strong>
</pre>

<p><div class="rs-tip-major">Poznámka: povšimněte si, že se skutečně nikde
uvnitř kolony neuvádí žádná jména proměnných ani souborů, s&nbsp;nimiž se má
pracovat. U příkazu <strong>tr</strong> můžeme vidět ještě jednu techniku
&ndash; díky použití parametrů jsme vlastně z&nbsp;původního obecného příkazu
<strong>tr</strong> vytvořili nový (anonymní &ndash; tedy nepojmenovaný)
příkaz, který by ovšem klidně mohl být pojmenován, například
<strong>commas2endlines</strong> apod. Mimochodem &ndash; podobnou techniku
nalezneme i v&nbsp;některých dále popsaných &bdquo;plnohodnotných&ldquo;
programovacích jazycích, kde se v&nbsp;tomto kontextu většinou hovoří o
uzávěrech (<i>closures</i>) nebo <i>transducerech</i>.</div></p>

<p>Koncept kolon (a tím pádem i rour) je již poměrně starý, neboť byl popsán
již na začátku sedmdesátých let minulého století Douglasem McIlroyem a
implementován byl Kenem Thompsonem v&nbsp;roce 1973. I přes toto stáří se
dodnes jedná o velmi mocný koncept, který je používán dodnes, a to jak
v&nbsp;klasické verzi (tedy s&nbsp;daty reprezentovanými jako sekvence
textových řádků), tak i například ve formě <a
href="https://relational-pipes.globalcode.info/v_0/">Relational pipes</a>. Díky
jednoduše pochopitelnému a přitom efektivnímu konceptu se z&nbsp;rour stal
návrhový vzor &bdquo;roura&ldquo; a &bdquo;filtr&ldquo;.</p>



<p><a name="k03"></a></p>
<h2 id="k03">3. Tacit programming a reálné programovací jazyky</h2>

<p>Prozatím jsme si ukázali jeden sice velmi úspěšný, ale možná poněkud
specifický příklad <i>tacit programmingu</i>. Ovšem s&nbsp;tímto stylem
programování jsme se již mohli ve stručnosti seznámit ve starších miniseriálech
o programovacích jazycích <i>Forth</i>, <i>Joy</i> a <i>Factor</i> (viz <a
href="#k20">dvacátou kapitolu</a> s&nbsp;příslušnými odkazy na tyto seriály).
V&nbsp;těchto jazycích se využívalo toho, že všechny argumenty funkcí
(operátorů) se nacházely na nejvyšších místech takzvaného <i>zásobníku
operandů</i>, přičemž všechny operátory s&nbsp;těmito operandy pracovaly
implicitně, opět bez nutnosti explicitně uvádět jejich jména (příklady si
pochopitelně ukážeme v&nbsp;navazujících kapitolách). Ve všech třech zmíněných
programovacích jazycích, tedy ve Forthu, jazyce Joy i ve Factoru, se striktně
používá <i>obrácená polská notace</i> (<i>RPN – Reverse Polish Notation</i>),
která <i>tacit programming</i> umožňuje používat efektivně pro libovolný počet
argumentů funkcí popř.&nbsp;operandů nějakých operátorů (unární, binární,
ternární atd. operátory).</p>

<p>Název &bdquo;polská notace&ldquo; byl zvolen na počest polského matematika
<i>Jana Lukasiewicze</i>, který v&nbsp;roce 1920 navrhl dvě možnosti psaní
matematických výrazů bez nutnosti definice priorit operací a také bez použití
závorek, kterým se při použití dnes nejpoužívanější infixové notace
v&nbsp;mnoha případech nevyhneme. Notace, při které se operátory píšou až za
operandy (tedy &bdquo;obráceně&ldquo;), se nazývá RPN či postfixová notace. A
právě tato notace, která je interně založena na použití <i>zásobníku
operandů</i>, je spojovacím článkem mezi výše zmíněnými programovacími
jazyky.</p>

<p>Ve skutečnosti však není <i>tacit programming</i> v&nbsp;žádném případě
vázán pouze na použití RPN. Typickým příkladem programovacího jazyka,
v&nbsp;němž se <i>tacit programming</i> začal používat, je jazyk <i>APL</i>,
s&nbsp;jehož padesáti pětiletou historií jsme se nedávno <a
href="https://www.root.cz/clanky/oslava-55-let-od-vzniku-prvni-implementace-programovaciho-jazyka-apl/">seznámili
zde na Rootu</a>. A <i>APL</i> je jazykem založeným na klasické infixové
notaci. Myšlenka <i>tacit programmingu</i> ovšem nebyla v&nbsp;původním jazyku
<i>APL</i> plně rozvinuta; ke zobecnění této techniky došlo v&nbsp;jazyce
<i>J</i>, který je od <i>APL</i> odvozen. A konečně se můžeme s&nbsp;<i>tacit
programmingem</i> setkat v&nbsp;Haskellu (dokonce v&nbsp;několika variantách) a
taktéž v&nbsp;programovacím jazyku Clojure, který tento koncept nabízí taktéž
v&nbsp;několika variantách. Ani to však není zdaleka vše, protože podobný
koncept je realizován v&nbsp;jazyku <i>ML</i> (poněkud neprávem opomíjenému) a
taktéž v&nbsp;Mirandě popř.&nbsp;v&nbsp;jazyku FP a FL.</p>

<p>S&nbsp;jednotlivými variantami, které jsou sice syntakticky velmi odlišné,
ale realizují prakticky tutéž myšlenku, se seznámíme v&nbsp;navazujících
kapitolách.</p>



<p><a name="k04"></a></p>
<h2 id="k04">4. Programovací jazyky založené na zásobníku operandů a RPN</h2>

<p>V&nbsp;úvodním textu jsme se zmínili o jazycích <i>Forth</i>, <i>Joy</i>,
<i>Factor</i> či <i>PostScript</i>. I přesto, že se tyto jazyky od sebe
v&nbsp;mnoha ohledech odlišují, mají jednu důležitou vlastnost společnou
&ndash; výpočty, tj.&nbsp;aritmetické operace, logické operace a rozhodovací
(řídicí) konstrukce jsou prováděny s&nbsp;hodnotami uloženými na zásobníku.
Díky tomu bylo možné tyto jazyky interně značně zjednodušit, protože se o
transformaci výrazů z&nbsp;dnes běžné infixové podoby do podoby postfixové
(jinak známé pod taktéž již zmíněným názvem <i>Převrácená Polská Notace/Reverse
Polish Notation &ndash; RPN</i>) musí postarat sám programátor. To ve
skutečnosti není nijak složité, ostatně s&nbsp;prakticky stejným
(pseudo)problémem se musí potýkat i ti uživatelé, kteří například používají
kalkulačky <i>Hewlett-Packard</i>.</p>

<p><div class="rs-tip-major">Poznámka: mimochodem &ndash; podle názoru
některých vývojářů se všechny čtyři výše zmíněné programovací jazyky už nachází
na hranici mezi &bdquo;civilizovanými&ldquo; programovacími jazyky a jazyky
esoterickými, i když autor článku je velkým <a
href="http://www.root.cz/serialy/programovaci-jazyk-forth/">fandou</a>
zásobníkových jazyků, takže tento názor nesdílí :-).</div></p>



<p><a name="k05"></a></p>
<h2 id="k05">5. Operace nad daty uloženými na zásobníku operandů</h2>

<p>Zde si jen v&nbsp;krátkosti připomeňme, že při použití zásobníku operandů
přímo v&nbsp;programovacím jazyku jsou hodnoty na zásobník ukládány explicitně
(zápis <strong>42</strong> tedy většinou znamená uložení této hodnoty na vrchol
zásobníku operandů), aritmetické a logické operace používají implicitní
adresování operandů (vždy se totiž jedná o hodnotu uloženou na vrcholu
zásobníku či těsně pod ním) a kromě toho se většinou setkáme i s několika
pomocnými operacemi určenými pro manipulaci s&nbsp;obsahem zásobníku. Tyto
operace bývají nazývány <strong>dup</strong> (zduplikování hodnoty uložené na
vrcholu zásobníku), <strong>drop</strong> (odstranění hodnoty z&nbsp;vrcholu
zásobníku operandů), <strong>swap</strong> (prohození dvou nejvyšších prvků
uložených na zásobníku) a <strong>rot</strong> (rotace tří nejvyšších prvků).
Tyto názvy mají dnes již vlastně historický původ, protože byly použity
v&nbsp;programovacím jazyku Forth; později se začaly používat například i
v&nbsp;zásobníkových virtuálních strojích.</p>

<p><div class="rs-tip-major">Poznámka: vrchol zásobníku se označuje zkratkou
<i>TOS</i> neboli <i>Top Of Stack</i>.</div></p>

<p>Nicméně se vraťme k&nbsp;tacit programmingu. Ve <i>Forthu</i> je možné
napsat například následující funkci:</p>

<pre>
<strong>:foo + * ;</strong>
</pre>

<p>Tato funkce na zásobníku očekává alespoň tři číselné hodnoty, které ovšem
uvnitř funkce nejsou nikde explicitně pojmenovány ani (explicitně) použity.
Použití této funkce je stejně snadné jako její zápis, pochopitelně pokud si
zvyknete na RPN:</p>

<pre>
<strong>3 2 1 foo .</strong>
9
</pre>

<p>Nejprve jsme na zásobník uložili tři hodnoty. Posléze se zavolala funkce
<strong>foo</strong>, která tyto hodnoty nějakým způsobem zpracovala. Na
nakonec byla hodnota umístěná na TOS vypsána další funkcí se jménem . (ano,
toto je ve Forthu skutečně zcela legitimní jméno funkce).</p>

<p>Povšimněte si, že nyní těla funkce <strong>foo</strong>:

<pre>
<strong>+ *</strong>
</pre>

<p>Tělo této funkce obsahuje pouze dvě tzv.&nbsp;slova &bdquo;+&ldquo; a
&bdquo;*&ldquo;. Každé z&nbsp;těchto slov očekává na zásobníku operandů dvojici
hodnot, které jsou sečteny popř.&nbsp;vynásobeny a výsledek je uložen zpět na
zásobník operandů. Nikde tedy není nutné psát, jak se operandy jmenují a už
vůbec ne, jak se jmenuje výsledná hodnota. Navíc ani funkce
<strong>foo</strong> tyto údaje neobsahuje.</p>

<p><div class="rs-tip-major">Poznámka: a právě zápis <strong>:foo + *
;</strong> ukazuje typické znaky <i>tacit programmingu</i>. Na jednu stranu je
tento zápis velmi úsporný a v&nbsp;mnoha případech i idiomatický. Na stranu
druhou může být tento zápis těžko rozluštitelný, a to právě díky jeho
úspornosti &ndash; všechny nepodstatné detaily byly vynechány, takže kód
prakticky postrádá redundanci (která je například v&nbsp;hovorovém jazyce
užitečná, neboť usnadňuje porozumění zprávě i při jejím &bdquo;zašumění&ldquo;
či nedokonalé znalosti jazyka).</div></p>



<p><a name="k06"></a></p>
<h2 id="k06">6. Programovací jazyk Joy</h2>

<p>Ve Forthu bylo použití zásobníku operandů (a nepřímo i tacit programmingu)
omezeno na celá čísla popř.&nbsp;na reálné hodnoty. Ovšem samotnou myšlenku
implicitního využívání parametrů/operandů je možné rozšířit na hodnoty
libovolného datového typu. A právě tento koncept byl použit
v&nbsp;programovacím jazyku <i>Joy</i>.</p>

<p><div class="rs-tip-major">Poznámka: jazyky &bdquo;Forthovského stylu&ldquo;
se někdy označují termínem &bdquo;concatenative languages&ldquo;.</div></p>

<p>Programovací jazyk <i>Joy</i> byl prakticky přesně před dvaceti lety navržen
Mangredem von Thunem pro účely výzkumu odlišného přístupu k&nbsp;funkcionálnímu
programování, než nabízejí &ndash; v&nbsp;tomto oboru již klasické a zavedené
&ndash; jazyky typu Lisp, Scheme a Haskell. Jedná se o minimalistický jazyk,
který však v&nbsp;sobě skrývá velké možnosti, které nemusí být na první pohled
zřejmé. Minimalismus je vidět i na velikosti samotného interpretru &ndash;
spustitelný soubor s&nbsp;interpretrem a základní knihovnou funkcí má po
přeložení céčkových zdrojových kódů velikost cca 110 kB a po aplikaci UPX či
podobného nástroje se velikost dokonce snížila na pouhých 27 kB (zde je navíc
nutné dodat, že v&nbsp;tomto spustitelném souboru je uložen také celý manuál o
délce přes 2 kilobytů, jenž je dostupný pod příkazem manual). Zatímco ostatní
funkcionální jazyky jsou založeny na <i>aplikaci funkcí</i> (v&nbsp;obecnějším
pohledu tedy na teorii lambda kalkulu), je srdcem programování v&nbsp;Joyi
<i>kompozice funkcí</i> spolu s&nbsp;takzvanou citací programů.</p>

<pre>
<i>způsob kompozice funkcí pomocí funkce</i>
<i>vyššího řádu "map" a citace programu</i>
<strong>[1 2 3 4] [square] map</strong>
&nbsp;
<i>tisk výsledku pomocí operátoru "tečky"</i>
<i>(zobecnění převzaté z Forthu)</i>
<strong>.</strong>
<strong>[1 4 9 16]</strong>
</pre>

<p>Druhým základem, na kterém je programovací jazyk Joy založený, je <i>citace
programů</i>, což ve skutečnosti není nic jiného než způsob zápisu (ale i
dynamické tvorby) programového kódu bez jeho spuštění. Znalci programovacích
jazyků Lisp či Scheme jistě znají <i>speciální formy</i>, které využívají
stejného principu &ndash; programový kód je možné považovat za seznam
příkazů/funkcí/operátorů, tj.&nbsp;ve skutečnosti za data, která je možné ve
vhodném okamžiku &bdquo;spustit&ldquo;, tj.&nbsp;předat je funkci typu
<strong>eval</strong>. Prakticky shodným způsobem je citace programů vyřešena i
v&nbsp;Joyovi, ostatně je to základ takových funkcí, které se
v&nbsp;nefunkcionálních programovacích jazycích transformují do podoby příkazů
<strong>while</strong>, <strong>if-then-else</strong> atd. Ve funkcionálních
jazycích se bez těchto speciálních syntaktických prvků hravě obejdeme:</p>

<pre>
<i>funkce ifte nahrazuje "plný" větvicí příkaz typu if-then-else</i>
<strong>[1000 &gt;]  [2 /]  [3 *]  ifte</strong>
&nbsp;
<i>příklad použití (tečka zajistí výpis položky na zásobníku):</i>
<strong>10 [1000 &gt;]  [2 /]  [3 *]  ifte .</strong>
30
&nbsp;
<strong>2000 [1000 &gt;]  [2 /]  [3 *]  ifte .</strong>
1000
</pre>



<p><a name="k07"></a></p>
<h2 id="k07">7. Definice nových funkcí v&nbsp;jazyku Joy, volání funkcí</h2>

<p>Způsob vytváření nových funkcí je, alespoň po syntaktické stránce, zcela
zjevně inspirován programovacím jazykem Forth. Pojďme se tedy bez většího
teoretizování podívat na příklad vytvoření dvou nových funkcí pojmenovaných
jednoduše <strong>square</strong> a <strong>cube</strong>. Z&nbsp;příkladu je
patrné, že vytváření nových funkcí začíná slovem <strong>DEFINE</strong>, za
nímž následuje vždy název funkce, dále znaky <strong>==</strong> oddělující
název funkce od jejího těla a poté již vlastní tělo funkce. Jednotlivé definice
jsou od sebe odděleny znakem středníku, což opět připomíná již zmíněný jazyk
Forth, konec definic všech funkcí zařídí operátor tečky:</p>

<pre>
<strong>DEFINE</strong>
    <strong>square  ==  dup * ;</strong>
    <strong>cube    ==  dup dup * * .</strong>
</pre>

<p>Všimněte si (v&nbsp;tomto článku již podruhé) jedné zajímavosti, která dosti
podstatným způsobem odlišuje &bdquo;zásobníkové&ldquo; programovací jazyky od
zbytku světa a co je současně řadí do škatulky <i>tacit programmingu</i>:
v&nbsp;těle funkcí ani v&nbsp;jejich názvu se nikde nevyskytují názvy
parametrů, protože se předpokládá, že ty budou uloženy na zásobníku. Není tedy
nutné nějakým složitým způsobem nahrazovat formální parametry za parametry
skutečné.  Má to ještě jednu výhodu &ndash; tělo funkce je možné zkopírovat,
přenést na příkazový řádek a funkci přímo spustit či jinak testovat bez
nutnosti měnit byť jediný znak v&nbsp;těle funkce. Jinými slovy: aplikace
funkce přímo v&nbsp;programu (tj.&nbsp;zápis těla funkce) i její definice jsou
zcela stejné, čehož lze velmi dobře využít při ladění a testování:</p>

<pre>
<i>definice nové funkce nazvané xx:</i>
<strong>DEFINE</strong>
    <strong>xx == [1000 &gt;] [2 /] [3 *] ifte</strong>
<strong>.</strong>
&nbsp;
<i>použití této funkce:</i>
<strong>20 xx .</strong>
60
&nbsp;
<strong>1000 xx .</strong>
3000
&nbsp;
<strong>1001 xx .</strong>
500
&nbsp;
<i>přímé použití těla funkce:</i>
<strong>20 [1000 &gt;] [2 /] [3 *] ifte .</strong>
60
&nbsp;
<strong>1000 [1000 &gt;] [2 /] [3 *] ifte .</strong>
3000
&nbsp;
<strong>1001 [1000 &gt;] [2 /] [3 *] ifte .</strong>
500 
</pre>

<p>Ukázka citace (části) programu s&nbsp;jeho následným spuštěním příkazem
<strong>i</strong> (<i>interpret</i>):</p>

<pre>
<strong>[1 2 + 3 * print] i</strong>
<strong>.</strong>
9
</pre>

<p><div class="rs-tip-major">Poznámka: v&nbsp;tomto případě jsou jednotlivá
<i>slova</i>, z&nbsp;nichž se program skládá, uložena do seznamu. Žádné další
operace se s&nbsp;tímto seznamem neprovádí až do chvíle, kdy je zavoláno slovo
<strong>i</strong>, které obsah seznamu &bdquo;spustí&ldquo;.</div></p>



<p><a name="k08"></a></p>
<h2 id="k08">8. Rekurzivní kombinátory v&nbsp;jazyce Joy</h2>

<p>Jednou z&nbsp;nejzajímavějších vlastností programovacího jazyka Joy je
způsob náhrady rekurzivních funkcí a programových smyček s&nbsp;využitím
takzvaných <i>rekurzivních kombinátorů</i>. Joy samozřejmě, ostatně jako
naprostá většina programovacích jazyků (snad s&nbsp;výjimkou starého Fortranu a
Basicu), podporuje normální rekurzi, tj.&nbsp;volání té samé funkce
z&nbsp;jejího těla. Lze také použít rekurzi nepřímou, což znamená, že se
z&nbsp;nějaké funkce <strong>A</strong> volá funkce <strong>B</strong> a
v&nbsp;jejím těle se opět volá funkce <strong>A</strong>.</p>

<p>Ještě před vysvětlením konkrétních kombinátorů si vysvětleme, o jaké
jazykové konstrukce se jedná. <i>Rekurzivní kombinátor</i> je vlastně běžný
operátor, který na zásobníku očekává buď jeden nebo několik citovaných
programů, popř.&nbsp;další parametry, například počet opakování. Jak již víme
z&nbsp;předchozího textu, je citovaný program na zásobníku uložen ve formě
seznamu, tj. v&nbsp;hranatých závorkách. Podle typu rekurzivního kombinátoru je
citovaný program/programy opakovaně spouštěn, přičemž je specifickým způsobem
(popsaným v&nbsp;dalších odstavcích) měněn obsah zásobníku tak, aby se
simulovalo skutečné provádění rekurze. Rekurzivní kombinátory nemají žádnou
specifickou syntaxi, jedná se o běžné funkce/operátory zapisované nám již
známou postfixovou notací, tj.&nbsp;samotný programovací jazyk nemusel být
kvůli jejich aplikaci žádným způsobem měněn. I tato skutečnost vypovídá o
kvalitním a promyšleném návrhu tohoto jazyka.</p>

<p>Pravděpodobně nejjednodušším typem kombinátoru je kombinátor nahrazující
klasickou počítanou smyčku typu <strong>for</strong> (mám teď na mysli podobu
smyčky známou například z&nbsp;Pascalu, Fortranu (původní smyčka typu
<strong>do</strong>) nebo Basicu, nikoli céčkovskou variantu, která má daleko
širší možnosti). Tento kombinátor, který dostal přiléhavý název
<strong>times</strong>, pracuje následujícím způsobem: při spuštění operátoru
se předpokládá, že jsou na zásobníku uloženy dvě hodnoty: na vrcholu zásobníku
seznam, jenž představuje tělo smyčky v&nbsp;imperativních jazycích,
tj.&nbsp;citovaný program a pod vrcholem zásobníku je očekávána číselná hodnota
udávající, kolikrát se má citovaný program provést. Použití tohoto kombinátoru
je velmi jednoduché (funkce <strong>putchars</strong> zajistí tisk řetězce bez
uvozovek a speciální znak <strong>\n</strong> pochopitelně slouží
k&nbsp;odřádkování):</p>

<pre>
<strong>10 ["hello\n" putchars] times .</strong>
&nbsp;
hello
hello
hello
hello
hello
hello
hello
hello
hello
hello
</pre>

<p>V&nbsp;mnoha programovacích jazycích se také objevuje smyčka typu
<strong>for-each</strong>. Nejedná se o smyčku počítanou, jak tomu bylo
v&nbsp;předchozím případě, ale o smyčku prováděnou nad všemi prvky nějakého
datového kontejneru, typicky pole, seznamu nebo asociativního pole (počet prvků
uložených v&nbsp;kontejnerech není v&nbsp;době překladu obecně známý). I za
tento typ programové smyčky existuje v&nbsp;jazyce Joy náhrada ve formě
kombinátoru nazvaného <strong>map</strong>. Použití tohoto kombinátoru je
snadné &ndash; citovaný program předávaný na vrcholu zásobníku je aplikován na
všechny položky seznamu či řetězce uloženého na druhém místě zásobníku.
Výsledkem je nový seznam nebo řetězec:</p>

<pre>
<strong>[1 2 3 4]  [dup *]  map .</strong>
&nbsp;
[1 4 9 16] 
</pre>

<p>Podobným způsobem pracuje i kombinátor nazvaný <strong>filter</strong>,
který ovšem do nově vytvářeného seznamu či řetězce vkládá ty položky, které
splňují zadané kritérium, tj.&nbsp;položky jsou skutečně filtrovány na základě
neustále vyhodnocované podmínky:</p>

<pre>
<i>ze seznamu získáme pouze sudá čísla</i>
<i>(dělitelná dvěma)</i>
<strong>[0 1 2 3 4 5 6 7 8 9 10] [2 rem 0 =] filter .</strong>
[0 2 4 6 8 10]
&nbsp;
<i>opak předchozího příkladu, získání</i>
<i>lichých čísel z předaného seznamu</i>
<strong>[0 1 2 3 4 5 6 7 8 9 10] [2 rem 0 !=] filter .</strong>
[1 3 5 7 9]
&nbsp;
<i>z řetězce se vyberou všechny znaky, jejichž</i>
<i>pořadí v ASCII leží pod znakem 'a'</i>
<i>(v tomto případě se odstraní malá písmena)</i>
<strong>"Hello World" ['a &lt;] filter .</strong>
"H W"
&nbsp;
<i>z řetězce se vyberou všechny znaky, jejichž</i>
<i>pořadí v ASCII leží nad znakem 'Z'</i>
<i>(v tomto případě se odstraní velká písmena a mezery)</i>
<strong>"Hello World" ['Z &gt;] filter .</strong>
"elloorld"
&nbsp;
<i>filtrace mezer</i>
<i>(všimněte si způsobu zápisu mezery pomocí apostrofu)</i>
<strong>"Hello World" [' !=] filter .</strong>
"HelloWorld"
&nbsp;
<i>filtrace všech znaků kromě mezer</i>
<strong>"Hello World" [' =] filter .</strong>
" "
</pre>







<p>Podobným způsobem je možné vytvářet funkce i v&nbsp;programovacím jazyku
<i>J</i>. Typickým příkladem je funkce pro výpočet průměru číselných hodnot
uložených v&nbsp;nějakém vektoru. Průměr se vypočítá snadno: nejprve zjistíme
součet (sumu) všech prvků (funkce <strong>+</strong> zkombinovaná
s&nbsp;operátorem <strong>/</strong>) a následně tento součet vydělíme jejich
počtem (funkce <strong>#</strong> zjistí délku vektoru). Při těchto výpočtech
není nutné nikde explicitně pojmenovávat parametry &ndash; ty se použijí až
při aplikaci (použití) vytvořené kombinace funkcí v&nbsp;další části
programu:</p>

<pre>
   NB. mean=suma(a1..an)/n
   mean =: +/ % #
</pre>



Functional, or Applicative, programming is programming without assignment statements: one just applies functions to arguments. Examples: Scheme, Haskell, Miranda, ML.
Function-level programming does away with the variables; one combines functions with functionals, a.k.a. combinators. Examples: FP, FL, J. 


f(x) = h(g(x))
f = h . g





definice nové funkce nazvané xx:
DEFINE
    xx == [1000 >] [2 /] [3 *] ifte
.

použití této funkce:
20 xx .
60
1000 xx .
3000
1001 xx .
500

přímé použití těla funkce:
20 [1000 >] [2 /] [3 *] ifte .
60
1000 [1000 >] [2 /] [3 *] ifte .
3000
1001 [1000 >] [2 /] [3 *] ifte .
500

Následuje klasický příklad funkce vracející maximální hodnotu z dvojice čísel uložených na zásobník. Příklad jsem upravil tak, aby využívat výše zmíněné zásobníkové manipulátory dup, dupd, pop, popd a swapd. Nejprve jsou duplikovány obě hodnoty umístěné na zásobníku, poté jsou porovnány (přičemž se původní hodnoty zahodí, proto je nutná duplikace) a posléze se na základě vyhodnocení porovnání ze zásobníku odstraní menší hodnota a výsledek, tj. hodnota větší, zůstane umístěná na nejvyšším místě zásobníku, protože ten slouží jako odkládací místo pro výsledky funkcí:

definice funkce max
(přepíšeme tím sice původní funkci, to však v této chvíli není na škodu)
DEFINE
    max == [dup swapd dupd >] [pop] [popd] ifte
warning: overwriting inbuilt 'max'
.

test funkce max:
10 20 max .
20
20 10 max .
20
10 10 max .
10
3 1 2 max max .
3
-1 -3 -2 -4 -5 max max max max .
-1 

Ve skutečnosti však lze funkci max napsat i jiným způsobem bez explicitního použití ifte, například následovně:

DEFINE
    max == dup swapd dupd > rotate choice



(filter odd?)
(map inc)
(take 5)

(def xf
  (comp
    (filter odd?)
    (map inc)
    (take 5)))

(def xf (comp (filter odd?) (map inc)))
(transduce xf + (range 5))
;; => 6
(transduce xf + 100 (range 5))
;; => 106


(defn build-topology
  "Definice celé pipeliny (kolony) - základ aplikace."
  [builder topic-config]
  (-> (j/kstream builder (:input topic-config))
      (j/peek (fn [[k v]]
                (log/warn "Received message with key:   " k " and value:" v)))
      (j/through (:output-1 topic-config))
      (j/map etl-1)
      (j/peek (fn [[k v]]
                (log/warn "Transformed message with key:" k " and value:" v)))
      (j/through (:output-2 topic-config))
      (j/map etl-2)
      (j/peek (fn [[k v]]
                (log/warn "Transformed message with key:" k " and value:" v)))
      (j/to (:output-3 topic-config)))
  builder)

(defn etl-1
  "Transformační funkce."
  [[k v]]
  [k {:result (+ (:x v) (:y v))}])


(defn etl-2
  "Transformační funkce."
  [[k v]]
  [k (assoc v :timestamp (str (new java.util.Date)))])


(def etl-3
  "Transformační funkce vytvořená ve formě uzávěru."
  (let [counter (atom 0)]
    (fn [[k v]] (do
                  (swap! counter inc) 
                  [k (assoc v :counter @counter)]))))

(defn build-topology
  "Definice celé pipeliny (kolony) - základ aplikace."
  [builder topic-config]
  (-> (j/kstream builder (:input topic-config))
      (j/peek (fn [[k v]]
                (log/warn "Received message with key:   " k " and value:" v)))
      (j/through (:output-1 topic-config))
      (j/map etl-1)
      (j/peek (fn [[k v]]
                (log/warn "Transformed message with key:" k " and value:" v)))
      (j/through (:output-2 topic-config))
      (j/map etl-2)
      (j/peek (fn [[k v]]
                (log/warn "Transformed message with key:" k " and value:" v)))
      (j/through (:output-3 topic-config))
      (j/map etl-3)
      (j/peek (fn [[k v]]
                (log/warn "Transformed message with key:" k " and value:" v)))
      (j/to (:output-4 topic-config)))
  builder)



<p><a name="k09"></a></p>
<h2 id="k09">9. </h2>



<p><a name="k10"></a></p>
<h2 id="k10">10. </h2>



<p><a name="k11"></a></p>
<h2 id="k11">11. </h2>



<p><a name="k12"></a></p>
<h2 id="k12">12. </h2>



<p><a name="k13"></a></p>
<h2 id="k13">13. </h2>



<p><a name="k14"></a></p>
<h2 id="k14">14. </h2>



<p><a name="k15"></a></p>
<h2 id="k15">15. </h2>



<p><a name="k16"></a></p>
<h2 id="k16">16. </h2>



<p><a name="k17"></a></p>
<h2 id="k17">17. </h2>



<p><a name="k18"></a></p>
<h2 id="k18">18. </h2>



<p><a name="k19"></a></p>
<h2 id="k19">19. Repositář s&nbsp;demonstračními příklady</h2>



<p><a name="k20"></a></p>
<h2 id="k20">20. Odkazy na Internetu</h2>

<ol>

<li>Tacit programming (APL Wiki)<br />
<a href="https://aplwiki.com/wiki/Tacit_programming">https://aplwiki.com/wiki/Tacit_programming</a>
</li>

<li>Function trains<br />
<a href="https://mlochbaum.github.io/BQN/doc/train.html">https://mlochbaum.github.io/BQN/doc/train.html</a>
</li>

<li>Tacit programming (Wikipedia)<br />
<a href="https://en.wikipedia.org/wiki/Tacit_programming">https://en.wikipedia.org/wiki/Tacit_programming</a>
</li>

<li>Beyond Functional Programming: Manipulate Functions with the J Language<br />
<a href="https://www.adamtornhill.com/articles/jlang/beyondfunctional.html">https://www.adamtornhill.com/articles/jlang/beyondfunctional.html</a>
</li>

<li>Real World Uses of Tacit Programming: Part 1 of 2<br />
<a href="https://medium.com/@jesterxl/real-world-uses-of-tacit-programming-part-1-of-2-f2a0c3f9e00c">https://medium.com/@jesterxl/real-world-uses-of-tacit-programming-part-1-of-2-f2a0c3f9e00c</a>
</li>

<li>Programovací jazyk Forth a zásobníkové procesory<br />
<a href="http://www.root.cz/clanky/programovaci-jazyk-forth-a-zasobnikove-procesory/">http://www.root.cz/clanky/programovaci-jazyk-forth-a-zasobnikove-procesory/</a>
</li>

<li>Seriál Programovací jazyk Forth<br />
<a href="http://www.root.cz/serialy/programovaci-jazyk-forth/">http://www.root.cz/serialy/programovaci-jazyk-forth/</a>
</li>

<li>Programovací jazyk Factor<br />
<a href="http://www.root.cz/clanky/programovaci-jazyk-factor/">http://www.root.cz/clanky/programovaci-jazyk-factor/</a>
</li>

<li>Grafický metaformát PostScript<br />
<a href="http://www.root.cz/clanky/graficky-metaformat-postscript/">http://www.root.cz/clanky/graficky-metaformat-postscript/</a>
</li>

<li>Programovací jazyk Factor<br />
<a href="https://www.root.cz/clanky/programovaci-jazyk-factor/">https://www.root.cz/clanky/programovaci-jazyk-factor/</a>
</li>

<li>Factor: revoluce v&nbsp;programování nebo propadák?<br />
<a href="https://www.root.cz/clanky/factor-revoluce-v-programovani-nebo-propadak/">https://www.root.cz/clanky/factor-revoluce-v-programovani-nebo-propadak/</a>
</li>

<li>Integrované vývojové prostředí Factoru<br />
<a href="https://www.root.cz/clanky/integrovane-vyvojove-prostredi-factoru/">https://www.root.cz/clanky/integrovane-vyvojove-prostredi-factoru/</a>
</li>

<li>Programujeme ve Factoru<br />
<a href="https://www.root.cz/clanky/programujeme-ve-factoru/">https://www.root.cz/clanky/programujeme-ve-factoru/</a>
</li>

<li>Joy: radost z&nbsp;programování<br />
<a href="https://www.root.cz/clanky/joy-radost-z-programovani/">https://www.root.cz/clanky/joy-radost-z-programovani/</a>
</li>

<li>Joy: programovací jazyk od protinožců<br />
<a href="https://www.root.cz/clanky/joy-programovaci-jazyk-od-protinozcu/">https://www.root.cz/clanky/joy-programovaci-jazyk-od-protinozcu/</a>
</li>

<li>Jazyk Joy a rekurzivní kombinátory<br />
<a href="https://www.root.cz/clanky/jazyk-joy-a-rekurzivni-kombinatory/">https://www.root.cz/clanky/jazyk-joy-a-rekurzivni-kombinatory/</a>
</li>

<li>Point-Free or Die: Tacit Programming in Haskell and Beyond<br />
<a href="https://www.thestrangeloop.com/2016/point-free-or-die-tacit-programming-in-haskell-and-beyond.html">https://www.thestrangeloop.com/2016/point-free-or-die-tacit-programming-in-haskell-and-beyond.html</a>
</li>

<li>Threading macro (dokumentace k&nbsp;jazyku Clojure)<br />
<a href="https://clojure.github.io/clojure/clojure.core-api.html#clojure.core/-&gt;">https://clojure.github.io/clojure/clojure.core-api.html#clojure.core/-&gt;</a>
</li>

<li>Understanding the Clojure -&gt; macro<br />
<a href="http://blog.fogus.me/2009/09/04/understanding-the-clojure-macro/">http://blog.fogus.me/2009/09/04/understanding-the-clojure-macro/</a>
</li>

<li>Transducers<br />
<a href="https://clojure.org/reference/transducers">https://clojure.org/reference/transducers</a>
</li>

<li>dc (computer program)<br />
<a href="https://en.wikipedia.org/wiki/Dc_%28computer_program%29">https://en.wikipedia.org/wiki/Dc_%28computer_program%29</a>
</li>

<li>dc (na Esolang)<br />
<a href="http://esolangs.org/wiki/Dc">http://esolangs.org/wiki/Dc</a>
</li>

<li>Relational pipes<br />
<a href="https://relational-pipes.globalcode.info/v_0/">https://relational-pipes.globalcode.info/v_0/</a>
</li>

<li>Roura (Unix)<br />
<a href="https://cs.wikipedia.org/wiki/Roura_(Unix)">https://cs.wikipedia.org/wiki/Roura_(Unix)</a>
</li>

<li>Roura (software)<br />
<a href="https://cs.wikipedia.org/wiki/Roura_(software)">https://cs.wikipedia.org/wiki/Roura_(software)</a>
</li>

<li>APL Wiki<br />
<a href="https://aplwiki.com/wiki/">https://aplwiki.com/wiki/</a>
</li>

<li>The Array Cast<br />
<a href="https://www.arraycast.com/episodes/episode-03-what-is-an-array">https://www.arraycast.com/episodes/episode-03-what-is-an-array</a>
</li>

<li>EnthusiastiCon 2019 – An Introduction to APL<br />
<a href="https://www.youtube.com/watch?v=UltnvW83_CQ">https://www.youtube.com/watch?v=UltnvW83_CQ</a>
</li>

<li>Dyalog<br />
<a href="https://www.dyalog.com/">https://www.dyalog.com/</a>
</li>

<li>Try APL!<br />
<a href="https://tryapl.org/">https://tryapl.org/</a>
</li>

<li>APL na replit<br />
<a href="https://replit.com/languages/apl">https://replit.com/languages/apl</a>
</li>

<li>Advent of Code 2020 in APL!<br />
<a href="https://www.youtube.com/watch?v=0RQFW6P1Tt0">https://www.youtube.com/watch?v=0RQFW6P1Tt0</a>
</li>

<li>Python vs APL (1 Problem)<br />
<a href="https://www.youtube.com/watch?v=APdKFJkmBbM">https://www.youtube.com/watch?v=APdKFJkmBbM</a>
</li>

<li>APL Wins (vs C++, Java &amp; Python)<br />
<a href="https://www.youtube.com/watch?v=59vAjBS3yZM">https://www.youtube.com/watch?v=59vAjBS3yZM</a>
</li>

<li>A Tour de Force of APL in 16 Expressions by Roger Hui<br />
<a href="https://www.youtube.com/watch?v=e0rywC7-i0U">https://www.youtube.com/watch?v=e0rywC7-i0U</a>
</li>

<li>Conway's Game Of Life in APL<br />
<a href="https://www.youtube.com/watch?v=a9xAKttWgP4">https://www.youtube.com/watch?v=a9xAKttWgP4</a>
</li>

<li>A List of companies that use Array Languages (J, K, APL, q)<br />
<a href="https://github.com/interregna/arraylanguage-companies">https://github.com/interregna/arraylanguage-companies</a>
</li>

<li>APL - one of the greatest programming languages ever<br />
<a href="http://www.vaxman.de/publications/apl_slides.pdf">http://www.vaxman.de/publications/apl_slides.pdf</a>
</li>

<li>"The J Programming Language" by Tracy Harms (2013)<br />
<a href="https://www.youtube.com/watch?v=RWYkx6-L04Q">https://www.youtube.com/watch?v=RWYkx6-L04Q</a>
</li>

<li>Dyalog Modern Programming Language, Morten Kromberg, Talks at Google<br />
<a href="https://www.youtube.com/watch?v=PlM9BXfu7UY">https://www.youtube.com/watch?v=PlM9BXfu7UY</a>
</li>

<li>The J Language: Consistency, Adjacency, and Solution-Oriented Programming - Tracy Harms<br />
<a href="https://www.youtube.com/watch?v=gLULrFY2-fI">https://www.youtube.com/watch?v=gLULrFY2-fI</a>
</li>

<li>Un-directed programming<br />
<a href="https://www.sacrideo.us/un-structured-programming/">https://www.sacrideo.us/un-structured-programming/</a>
</li>

<li>Concatenative programming language<br />
<a href="https://en.wikipedia.org/wiki/Concatenative_programming_language">https://en.wikipedia.org/wiki/Concatenative_programming_language</a>
</li>

<li>Repositáře s&nbsp;jazykem Joy<br />
<a href="https://github.com/joy-language">https://github.com/joy-language</a>
</li>

</ol>



<p></p><p></p>
<p><small>Autor: <a href="http://www.fit.vutbr.cz/~tisnovpa">Pavel Tišnovský</a> &nbsp; 2021</small></p>
</body>
</html>

