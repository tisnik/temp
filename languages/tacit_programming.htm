<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
        "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html>
<head>
<title></title>
<meta name="Author" content="Pavel Tisnovsky" />
<meta name="Generator" content="vim" />
<meta http-equiv="content-type" content="text/html; charset=utf-8" />
<style type="text/css">
         body {color:#000000; background:#ffffff;}
         h1  {font-family: arial, helvetica, sans-serif; color:#ffffff; background-color:#c00000; text-align:center; padding-left:1em}
         h2  {font-family: arial, helvetica, sans-serif; color:#ffffff; background-color:#0000c0; padding-left:1em; text-align:left}
         h3  {font-family: arial, helvetica, sans-serif; color:#000000; background-color:#c0c0c0; padding-left:1em; text-align:left}
         h4  {font-family: arial, helvetica, sans-serif; color:#000000; background-color:#e0e0e0; padding-left:1em; text-align:left}
         a   {font-family: arial, helvetica, sans-serif;}
         li  {font-family: arial, helvetica, sans-serif; color:#000000; text-align:justify; width:450px;}
         ol  {font-family: arial, helvetica, sans-serif; color:#000000; text-align:justify; width:450px;}
         ul  {font-family: arial, helvetica, sans-serif; color:#000000; text-align:justify; width:450px;}
         p   {font-family: arial, helvetica, sans-serif; color:#000000; text-align:justify;}
         pre {background:#e0e0e0}
</style>
</head>

<body>

<h1></h1>

<h3>Pavel Tišnovský</h3>

<p></p>

<h1>Úvodník</h1>

<p></p>



<h2>Obsah</h2>

<p><a href="#k01">1. Programovací technika nazvaná <i>tacit programming</i></a></p>
<p><a href="#k02">2. Kolony (roury) v&nbsp;shellu</a></p>
<p><a href="#k03">3. Tacit programming a reálné programovací jazyky</a></p>
<p><a href="#k04">4. Programovací jazyky založené na zásobníku operandů a RPN</a></p>
<p><a href="#k05">5. Operace nad daty uloženými na zásobníku operandů</a></p>
<p><a href="#k06">6. Programovací jazyk Joy</a></p>
<p><a href="#k07">7. Definice nových funkcí v&nbsp;jazyku Joy, volání funkcí</a></p>
<p><a href="#k08">8. Rekurzivní kombinátory v&nbsp;jazyce Joy</a></p>
<p><a href="#k09">9. Lineární rekurze zapsaná formou <i>tacit programmingu</i></a></p>
<p><a href="#k10">10. Primární rekurze zapsaná formou <i>tacit programmingu</i></a></p>
<p><a href="#k11">11. Binární rekurze</a></p>
<p><a href="#k12">12. Známé algoritmy přepsané do formy tacit programmingu</a></p>
<p><a href="#k13">13. Tacit programming v&nbsp;programovacím jazyku J</a></p>
<p><a href="#k14">*** 14. Jazyk J a &bdquo;vláčky&ldquo;</a></p>
<p><a href="#k15">*** 15. </a></p>
<p><a href="#k16">*** 16. </a></p>
<p><a href="#k17">*** 17. </a></p>
<p><a href="#k18">*** 18. </a></p>
<p><a href="#k19">*** 19. </a></p>
<p><a href="#k20">20. Odkazy na Internetu</a></p>



<p><a name="k01"></a></p>
<h2 id="k01">1. Programovací technika nazvaná <i>tacit programming</i></h2>

<p>V&nbsp;dnešním článku se seznámíme se zajímavou programovací technikou,
která je nazývána <i>point-free style</i> popř.&nbsp;v&nbsp;některých
programovacích jazycích <i>tacit programming</i>. Přesný a přitom dostatečně
jednoznačný český ekvivalent tohoto označení mě nenapadá, proto raději zůstanu
u termínu anglického, který se ostatně snadněji vyhledává. Co se ovšem pod
názvy <i>tacit programming</i> nebo <i>point-free style</i> skrývá? Jedná se o
styl zápisu bloků programů (typicky jednotlivých výrazů, ale i uživatelských
funkcí popř.&nbsp;sekvencí funkcí, někdy o zápis dekorátorů), ve kterých se
nachází volání jiných funkcí, ovšem bez explicitního udání jmen jejich
argumentů (parametrů). A nejenom to &ndash; většinou není naznačen ani počet
argumentů. Proč by se však <i>tacit programming</i> měl používat,
resp.&nbsp;jaká je jeho přednost? Základní idea spočívá v&nbsp;tom, že se
seskupením funkcí popř.&nbsp;operátorů vytvoří abstraktnější funkce nebo
operátor, takže je možné v&nbsp;programovacím jazyce vybaveném relativně
základními operacemi vytvářet vyšší úrovně abstrakce podle potřeb programátora,
a to za použití snadno pochopitelných a testovatelných prostředků a idiomů.</p>

<p><div class="rs-tip-major">Poznámka: poměrně často používám v&nbsp;článcích
pojem &bdquo;idiom&ldquo; pro ustálenou strukturu/notaci v&nbsp;daném obvyklou
programovacím jazyce. Důsledné používání idiomů vede ke kódu, který je
srozumitelný i pro další programátory. A nejenom to &ndash; v&nbsp;takovém kódu
se obecně nachází menší množství logických chyb. Naopak <i>ne</i>použití idiomu
programátory zbytečně zmate.</div></p>

<p>S&nbsp;<i>tacit programmingem</i> se můžeme setkat v&nbsp;mnoha navzájem
odlišných prostředích a v&nbsp;různých programovacích jazycích. Asi
nejznámějším příkladem jsou dobře známé <i>kolony</i> v&nbsp;shellu, dále
technika vytváření nových slov v&nbsp;jazycích založených na RPN (což jsou
jazyky jako Forth, Joy, Factor, PostScript, ...), technika operátorů použitá
v&nbsp;programovacích jazycích APL a J (zde se pravděpodobně poprvé objevuje
označení <i>train</i>) a zapomenout nesmíme ani na jazyk Haskell popř.&nbsp;na
Clojure (s&nbsp;threading makry a takzvanými <i>transducery</i>).</p>



<p><a name="k02"></a></p>
<h2 id="k02">2. Kolony (roury) v&nbsp;shellu</h2>

<p>Lze předpokládat, že naprostá většina čtenářů Roota se s&nbsp;programovací
technikou, kterou budeme v&nbsp;tomto článku označovat termínem <i>tacit
programming</i> již setkala, a to přímo v&nbsp;shellu. Konkrétně se jedná o
použití klasických <i>kolon</i>, protože každý příkaz uvnitř kolony čte data
z&nbsp;předchozího příkazu, transformuje či nějakým způsobem agreguje tato data
a posílá výsledky příkazu dalšímu (a pro propojení dvou zpracovávajících entit
v&nbsp;koloně se používá <i>roura</i>). Výjimkou je první popř.&nbsp;poslední
příkaz, který je ke koloně připojen jen zleva či zprava. Na následujícím
demonstračním příkladu je ukázána velmi jednoduchá kolona, přičemž ta část,
kterou bychom mohli označit termínem <i>tacit programming</i> nebo
<i>point-free style</i>, je zvýrazněna tučným písmem:</p>

<pre>
cat foobar | <strong>tr ',' '\n' | sort | uniq | rev | head -n 10</strong>
</pre>

<p><div class="rs-tip-major">Poznámka: povšimněte si, že se skutečně nikde
uvnitř kolony neuvádí žádná jména proměnných ani souborů, s&nbsp;nimiž se má
pracovat. U příkazu <strong>tr</strong> můžeme vidět ještě jednu techniku
&ndash; díky použití parametrů jsme vlastně z&nbsp;původního obecného příkazu
<strong>tr</strong> vytvořili nový (anonymní &ndash; tedy nepojmenovaný)
příkaz, který by ovšem klidně mohl být pojmenován, například
<strong>commas2endlines</strong> apod. Mimochodem &ndash; podobnou techniku
nalezneme i v&nbsp;některých dále popsaných &bdquo;plnohodnotných&ldquo;
programovacích jazycích, kde se v&nbsp;tomto kontextu většinou hovoří o
uzávěrech (<i>closures</i>) nebo <i>transducerech</i>.</div></p>

<p>Koncept kolon (a tím pádem i rour) je již poměrně starý, neboť byl popsán
již na začátku sedmdesátých let minulého století Douglasem McIlroyem a
implementován byl Kenem Thompsonem v&nbsp;roce 1973. I přes toto stáří se
dodnes jedná o velmi mocný koncept, který je používán dodnes, a to jak
v&nbsp;klasické verzi (tedy s&nbsp;daty reprezentovanými jako sekvence
textových řádků), tak i například ve formě <a
href="https://relational-pipes.globalcode.info/v_0/">Relational pipes</a>. Díky
jednoduše pochopitelnému a přitom efektivnímu konceptu se z&nbsp;rour stal
návrhový vzor &bdquo;roura&ldquo; a &bdquo;filtr&ldquo;.</p>



<p><a name="k03"></a></p>
<h2 id="k03">3. Tacit programming a reálné programovací jazyky</h2>

<p>Prozatím jsme si ukázali jeden sice velmi úspěšný, ale možná poněkud
specifický příklad <i>tacit programmingu</i>. Ovšem s&nbsp;tímto stylem
programování jsme se již mohli ve stručnosti seznámit ve starších miniseriálech
o programovacích jazycích <i>Forth</i>, <i>Joy</i> a <i>Factor</i> (viz <a
href="#k20">dvacátou kapitolu</a> s&nbsp;příslušnými odkazy na tyto seriály).
V&nbsp;těchto jazycích se využívalo toho, že všechny argumenty funkcí
(operátorů) se nacházely na nejvyšších místech takzvaného <i>zásobníku
operandů</i>, přičemž všechny operátory s&nbsp;těmito operandy pracovaly
implicitně, opět bez nutnosti explicitně uvádět jejich jména (příklady si
pochopitelně ukážeme v&nbsp;navazujících kapitolách). Ve všech třech zmíněných
programovacích jazycích, tedy ve Forthu, jazyce Joy i ve Factoru, se striktně
používá <i>obrácená polská notace</i> (<i>RPN – Reverse Polish Notation</i>),
která <i>tacit programming</i> umožňuje používat efektivně pro libovolný počet
argumentů funkcí popř.&nbsp;operandů nějakých operátorů (unární, binární,
ternární atd. operátory).</p>

<p>Název &bdquo;polská notace&ldquo; byl zvolen na počest polského matematika
<i>Jana Lukasiewicze</i>, který v&nbsp;roce 1920 navrhl dvě možnosti psaní
matematických výrazů bez nutnosti definice priorit operací a také bez použití
závorek, kterým se při použití dnes nejpoužívanější infixové notace
v&nbsp;mnoha případech nevyhneme. Notace, při které se operátory píšou až za
operandy (tedy &bdquo;obráceně&ldquo;), se nazývá RPN či postfixová notace. A
právě tato notace, která je interně založena na použití <i>zásobníku
operandů</i>, je spojovacím článkem mezi výše zmíněnými programovacími
jazyky.</p>

<p>Ve skutečnosti však není <i>tacit programming</i> v&nbsp;žádném případě
vázán pouze na použití RPN. Typickým příkladem programovacího jazyka,
v&nbsp;němž se <i>tacit programming</i> začal používat, je jazyk <i>APL</i>,
s&nbsp;jehož padesáti pětiletou historií jsme se nedávno <a
href="https://www.root.cz/clanky/oslava-55-let-od-vzniku-prvni-implementace-programovaciho-jazyka-apl/">seznámili
zde na Rootu</a>. A <i>APL</i> je jazykem založeným na klasické infixové
notaci. Myšlenka <i>tacit programmingu</i> ovšem nebyla v&nbsp;původním jazyku
<i>APL</i> plně rozvinuta; ke zobecnění této techniky došlo v&nbsp;jazyce
<i>J</i>, který je od <i>APL</i> odvozen. A konečně se můžeme s&nbsp;<i>tacit
programmingem</i> setkat v&nbsp;Haskellu (dokonce v&nbsp;několika variantách) a
taktéž v&nbsp;programovacím jazyku Clojure, který tento koncept nabízí taktéž
v&nbsp;několika variantách. Ani to však není zdaleka vše, protože podobný
koncept je realizován v&nbsp;jazyku <i>ML</i> (poněkud neprávem opomíjenému) a
taktéž v&nbsp;Mirandě popř.&nbsp;v&nbsp;jazyku FP a FL.</p>

<p>S&nbsp;jednotlivými variantami, které jsou sice syntakticky velmi odlišné,
ale realizují prakticky tutéž myšlenku, se seznámíme v&nbsp;navazujících
kapitolách.</p>



<p><a name="k04"></a></p>
<h2 id="k04">4. Programovací jazyky založené na zásobníku operandů a RPN</h2>

<p>V&nbsp;úvodním textu jsme se zmínili o jazycích <i>Forth</i>, <i>Joy</i>,
<i>Factor</i> či <i>PostScript</i>. I přesto, že se tyto jazyky od sebe
v&nbsp;mnoha ohledech odlišují, mají jednu důležitou vlastnost společnou
&ndash; výpočty, tj.&nbsp;aritmetické operace, logické operace a rozhodovací
(řídicí) konstrukce jsou prováděny s&nbsp;hodnotami uloženými na zásobníku.
Díky tomu bylo možné tyto jazyky interně značně zjednodušit, protože se o
transformaci výrazů z&nbsp;dnes běžné infixové podoby do podoby postfixové
(jinak známé pod taktéž již zmíněným názvem <i>Převrácená Polská Notace/Reverse
Polish Notation &ndash; RPN</i>) musí postarat sám programátor. To ve
skutečnosti není nijak složité, ostatně s&nbsp;prakticky stejným
(pseudo)problémem se musí potýkat i ti uživatelé, kteří například používají
kalkulačky <i>Hewlett-Packard</i>.</p>

<p><div class="rs-tip-major">Poznámka: mimochodem &ndash; podle názoru
některých vývojářů se všechny čtyři výše zmíněné programovací jazyky už nachází
na hranici mezi &bdquo;civilizovanými&ldquo; programovacími jazyky a jazyky
esoterickými, i když autor článku je velkým <a
href="http://www.root.cz/serialy/programovaci-jazyk-forth/">fandou</a>
zásobníkových jazyků, takže tento názor nesdílí :-).</div></p>



<p><a name="k05"></a></p>
<h2 id="k05">5. Operace nad daty uloženými na zásobníku operandů</h2>

<p>Zde si jen v&nbsp;krátkosti připomeňme, že při použití zásobníku operandů
přímo v&nbsp;programovacím jazyku jsou hodnoty na zásobník ukládány explicitně
(zápis <strong>42</strong> tedy většinou znamená uložení této hodnoty na vrchol
zásobníku operandů), aritmetické a logické operace používají implicitní
adresování operandů (vždy se totiž jedná o hodnotu uloženou na vrcholu
zásobníku či těsně pod ním) a kromě toho se většinou setkáme i s několika
pomocnými operacemi určenými pro manipulaci s&nbsp;obsahem zásobníku. Tyto
operace bývají nazývány <strong>dup</strong> (zduplikování hodnoty uložené na
vrcholu zásobníku), <strong>drop</strong> (odstranění hodnoty z&nbsp;vrcholu
zásobníku operandů), <strong>swap</strong> (prohození dvou nejvyšších prvků
uložených na zásobníku) a <strong>rot</strong> (rotace tří nejvyšších prvků).
Tyto názvy mají dnes již vlastně historický původ, protože byly použity
v&nbsp;programovacím jazyku Forth; později se začaly používat například i
v&nbsp;zásobníkových virtuálních strojích.</p>

<p><div class="rs-tip-major">Poznámka: vrchol zásobníku se označuje zkratkou
<i>TOS</i> neboli <i>Top Of Stack</i>.</div></p>

<p>Nicméně se vraťme k&nbsp;tacit programmingu. Ve <i>Forthu</i> je možné
napsat například následující funkci:</p>

<pre>
<strong>:foo + * ;</strong>
</pre>

<p>Tato funkce na zásobníku očekává alespoň tři číselné hodnoty, které ovšem
uvnitř funkce nejsou nikde explicitně pojmenovány ani (explicitně) použity.
Použití této funkce je stejně snadné jako její zápis, pochopitelně pokud si
zvyknete na RPN:</p>

<pre>
<strong>3 2 1 foo .</strong>
9
</pre>

<p>Nejprve jsme na zásobník uložili tři hodnoty. Posléze se zavolala funkce
<strong>foo</strong>, která tyto hodnoty nějakým způsobem zpracovala. Na
nakonec byla hodnota umístěná na TOS vypsána další funkcí se jménem . (ano,
toto je ve Forthu skutečně zcela legitimní jméno funkce).</p>

<p>Povšimněte si, že nyní těla funkce <strong>foo</strong>:

<pre>
<strong>+ *</strong>
</pre>

<p>Tělo této funkce obsahuje pouze dvě tzv.&nbsp;slova &bdquo;+&ldquo; a
&bdquo;*&ldquo;. Každé z&nbsp;těchto slov očekává na zásobníku operandů dvojici
hodnot, které jsou sečteny popř.&nbsp;vynásobeny a výsledek je uložen zpět na
zásobník operandů. Nikde tedy není nutné psát, jak se operandy jmenují a už
vůbec ne, jak se jmenuje výsledná hodnota. Navíc ani funkce
<strong>foo</strong> tyto údaje neobsahuje.</p>

<p><div class="rs-tip-major">Poznámka: a právě zápis <strong>:foo + *
;</strong> ukazuje typické znaky <i>tacit programmingu</i>. Na jednu stranu je
tento zápis velmi úsporný a v&nbsp;mnoha případech i idiomatický. Na stranu
druhou může být tento zápis těžko rozluštitelný, a to právě díky jeho
úspornosti &ndash; všechny nepodstatné detaily byly vynechány, takže kód
prakticky postrádá redundanci (která je například v&nbsp;hovorovém jazyce
užitečná, neboť usnadňuje porozumění zprávě i při jejím &bdquo;zašumění&ldquo;
či nedokonalé znalosti jazyka).</div></p>



<p><a name="k06"></a></p>
<h2 id="k06">6. Programovací jazyk Joy</h2>

<p>Ve Forthu bylo použití zásobníku operandů (a nepřímo i tacit programmingu)
omezeno na celá čísla popř.&nbsp;na reálné hodnoty. Ovšem samotnou myšlenku
implicitního využívání parametrů/operandů je možné rozšířit na hodnoty
libovolného datového typu. A právě tento koncept byl použit
v&nbsp;programovacím jazyku <i>Joy</i>.</p>

<p><div class="rs-tip-major">Poznámka: jazyky &bdquo;Forthovského stylu&ldquo;
se někdy označují termínem &bdquo;concatenative languages&ldquo;.</div></p>

<p>Programovací jazyk <i>Joy</i> byl prakticky přesně před dvaceti lety navržen
Mangredem von Thunem pro účely výzkumu odlišného přístupu k&nbsp;funkcionálnímu
programování, než nabízejí &ndash; v&nbsp;tomto oboru již klasické a zavedené
&ndash; jazyky typu Lisp, Scheme a Haskell. Jedná se o minimalistický jazyk,
který však v&nbsp;sobě skrývá velké možnosti, které nemusí být na první pohled
zřejmé. Minimalismus je vidět i na velikosti samotného interpretru &ndash;
spustitelný soubor s&nbsp;interpretrem a základní knihovnou funkcí má po
přeložení céčkových zdrojových kódů velikost cca 110 kB a po aplikaci UPX či
podobného nástroje se velikost dokonce snížila na pouhých 27 kB (zde je navíc
nutné dodat, že v&nbsp;tomto spustitelném souboru je uložen také celý manuál o
délce přes 2 kilobytů, jenž je dostupný pod příkazem manual). Zatímco ostatní
funkcionální jazyky jsou založeny na <i>aplikaci funkcí</i> (v&nbsp;obecnějším
pohledu tedy na teorii lambda kalkulu), je srdcem programování v&nbsp;Joyi
<i>kompozice funkcí</i> spolu s&nbsp;takzvanou citací programů.</p>

<pre>
<i>způsob kompozice funkcí pomocí funkce</i>
<i>vyššího řádu "map" a citace programu</i>
<strong>[1 2 3 4] [square] map</strong>
&nbsp;
<i>tisk výsledku pomocí operátoru "tečky"</i>
<i>(zobecnění převzaté z Forthu)</i>
<strong>.</strong>
<strong>[1 4 9 16]</strong>
</pre>

<p>Druhým základem, na kterém je programovací jazyk Joy založený, je <i>citace
programů</i>, což ve skutečnosti není nic jiného než způsob zápisu (ale i
dynamické tvorby) programového kódu bez jeho spuštění. Znalci programovacích
jazyků Lisp či Scheme jistě znají <i>speciální formy</i>, které využívají
stejného principu &ndash; programový kód je možné považovat za seznam
příkazů/funkcí/operátorů, tj.&nbsp;ve skutečnosti za data, která je možné ve
vhodném okamžiku &bdquo;spustit&ldquo;, tj.&nbsp;předat je funkci typu
<strong>eval</strong>. Prakticky shodným způsobem je citace programů vyřešena i
v&nbsp;Joyovi, ostatně je to základ takových funkcí, které se
v&nbsp;nefunkcionálních programovacích jazycích transformují do podoby příkazů
<strong>while</strong>, <strong>if-then-else</strong> atd. Ve funkcionálních
jazycích se bez těchto speciálních syntaktických prvků hravě obejdeme:</p>

<pre>
<i>funkce ifte nahrazuje "plný" větvicí příkaz typu if-then-else</i>
<strong>[1000 &gt;]  [2 /]  [3 *]  ifte</strong>
&nbsp;
<i>příklad použití (tečka zajistí výpis položky na zásobníku):</i>
<strong>10 [1000 &gt;]  [2 /]  [3 *]  ifte .</strong>
30
&nbsp;
<strong>2000 [1000 &gt;]  [2 /]  [3 *]  ifte .</strong>
1000
</pre>



<p><a name="k07"></a></p>
<h2 id="k07">7. Definice nových funkcí v&nbsp;jazyku Joy, volání funkcí</h2>

<p>Způsob vytváření nových funkcí je, alespoň po syntaktické stránce, zcela
zjevně inspirován programovacím jazykem Forth. Pojďme se tedy bez většího
teoretizování podívat na příklad vytvoření dvou nových funkcí pojmenovaných
jednoduše <strong>square</strong> a <strong>cube</strong>. Z&nbsp;příkladu je
patrné, že vytváření nových funkcí začíná slovem <strong>DEFINE</strong>, za
nímž následuje vždy název funkce, dále znaky <strong>==</strong> oddělující
název funkce od jejího těla a poté již vlastní tělo funkce. Jednotlivé definice
jsou od sebe odděleny znakem středníku, což opět připomíná již zmíněný jazyk
Forth, konec definic všech funkcí zařídí operátor tečky:</p>

<pre>
<strong>DEFINE</strong>
    <strong>square  ==  dup * ;</strong>
    <strong>cube    ==  dup dup * * .</strong>
</pre>

<p>Všimněte si (v&nbsp;tomto článku již podruhé) jedné zajímavosti, která dosti
podstatným způsobem odlišuje &bdquo;zásobníkové&ldquo; programovací jazyky od
zbytku světa a co je současně řadí do škatulky <i>tacit programmingu</i>:
v&nbsp;těle funkcí ani v&nbsp;jejich názvu se nikde nevyskytují názvy
parametrů, protože se předpokládá, že ty budou uloženy na zásobníku. Není tedy
nutné nějakým složitým způsobem nahrazovat formální parametry za parametry
skutečné.  Má to ještě jednu výhodu &ndash; tělo funkce je možné zkopírovat,
přenést na příkazový řádek a funkci přímo spustit či jinak testovat bez
nutnosti měnit byť jediný znak v&nbsp;těle funkce. Jinými slovy: aplikace
funkce přímo v&nbsp;programu (tj.&nbsp;zápis těla funkce) i její definice jsou
zcela stejné, čehož lze velmi dobře využít při ladění a testování:</p>

<pre>
<i>definice nové funkce nazvané xx:</i>
<strong>DEFINE</strong>
    <strong>xx == [1000 &gt;] [2 /] [3 *] ifte</strong>
<strong>.</strong>
&nbsp;
<i>použití této funkce:</i>
<strong>20 xx .</strong>
60
&nbsp;
<strong>1000 xx .</strong>
3000
&nbsp;
<strong>1001 xx .</strong>
500
&nbsp;
<i>přímé použití těla funkce:</i>
<strong>20 [1000 &gt;] [2 /] [3 *] ifte .</strong>
60
&nbsp;
<strong>1000 [1000 &gt;] [2 /] [3 *] ifte .</strong>
3000
&nbsp;
<strong>1001 [1000 &gt;] [2 /] [3 *] ifte .</strong>
500 
</pre>

<p>Ukázka citace (části) programu s&nbsp;jeho následným spuštěním příkazem
<strong>i</strong> (<i>interpret</i>):</p>

<pre>
<strong>[1 2 + 3 * print] i</strong>
<strong>.</strong>
9
</pre>

<p><div class="rs-tip-major">Poznámka: v&nbsp;tomto případě jsou jednotlivá
<i>slova</i>, z&nbsp;nichž se program skládá, uložena do seznamu. Žádné další
operace se s&nbsp;tímto seznamem neprovádí až do chvíle, kdy je zavoláno slovo
<strong>i</strong>, které obsah seznamu &bdquo;spustí&ldquo;.</div></p>



<p><a name="k08"></a></p>
<h2 id="k08">8. Rekurzivní kombinátory v&nbsp;jazyce Joy</h2>

<p>Jednou z&nbsp;nejzajímavějších vlastností programovacího jazyka Joy je
způsob náhrady rekurzivních funkcí a programových smyček s&nbsp;využitím
takzvaných <i>rekurzivních kombinátorů</i>. Joy samozřejmě, ostatně jako
naprostá většina programovacích jazyků (snad s&nbsp;výjimkou starého Fortranu a
Basicu), podporuje normální rekurzi, tj.&nbsp;volání té samé funkce
z&nbsp;jejího těla. Lze také použít rekurzi nepřímou, což znamená, že se
z&nbsp;nějaké funkce <strong>A</strong> volá funkce <strong>B</strong> a
v&nbsp;jejím těle se opět volá funkce <strong>A</strong>.</p>

<p>Ještě před vysvětlením konkrétních kombinátorů si vysvětleme, o jaké
jazykové konstrukce se jedná. <i>Rekurzivní kombinátor</i> je vlastně běžný
operátor, který na zásobníku očekává buď jeden nebo několik citovaných
programů, popř.&nbsp;další parametry, například počet opakování. Jak již víme
z&nbsp;předchozího textu, je citovaný program na zásobníku uložen ve formě
seznamu, tj. v&nbsp;hranatých závorkách. Podle typu rekurzivního kombinátoru je
citovaný program/programy opakovaně spouštěn, přičemž je specifickým způsobem
(popsaným v&nbsp;dalších odstavcích) měněn obsah zásobníku tak, aby se
simulovalo skutečné provádění rekurze. Rekurzivní kombinátory nemají žádnou
specifickou syntaxi, jedná se o běžné funkce/operátory zapisované nám již
známou postfixovou notací, tj.&nbsp;samotný programovací jazyk nemusel být
kvůli jejich aplikaci žádným způsobem měněn. I tato skutečnost vypovídá o
kvalitním a promyšleném návrhu tohoto jazyka.</p>

<p>Pravděpodobně nejjednodušším typem kombinátoru je kombinátor nahrazující
klasickou počítanou smyčku typu <strong>for</strong> (mám teď na mysli podobu
smyčky známou například z&nbsp;Pascalu, Fortranu (původní smyčka typu
<strong>do</strong>) nebo Basicu, nikoli céčkovskou variantu, která má daleko
širší možnosti). Tento kombinátor, který dostal přiléhavý název
<strong>times</strong>, pracuje následujícím způsobem: při spuštění operátoru
se předpokládá, že jsou na zásobníku uloženy dvě hodnoty: na vrcholu zásobníku
seznam, jenž představuje tělo smyčky v&nbsp;imperativních jazycích,
tj.&nbsp;citovaný program a pod vrcholem zásobníku je očekávána číselná hodnota
udávající, kolikrát se má citovaný program provést. Použití tohoto kombinátoru
je velmi jednoduché (funkce <strong>putchars</strong> zajistí tisk řetězce bez
uvozovek a speciální znak <strong>\n</strong> pochopitelně slouží
k&nbsp;odřádkování):</p>

<pre>
<strong>10 ["hello\n" putchars] times .</strong>
&nbsp;
hello
hello
hello
hello
hello
hello
hello
hello
hello
hello
</pre>

<p>V&nbsp;mnoha programovacích jazycích se také objevuje smyčka typu
<strong>for-each</strong>. Nejedná se o smyčku počítanou, jak tomu bylo
v&nbsp;předchozím případě, ale o smyčku prováděnou nad všemi prvky nějakého
datového kontejneru, typicky pole, seznamu nebo asociativního pole (počet prvků
uložených v&nbsp;kontejnerech není v&nbsp;době překladu obecně známý). I za
tento typ programové smyčky existuje v&nbsp;jazyce Joy náhrada ve formě
kombinátoru nazvaného <strong>map</strong>. Použití tohoto kombinátoru je
snadné &ndash; citovaný program předávaný na vrcholu zásobníku je aplikován na
všechny položky seznamu či řetězce uloženého na druhém místě zásobníku.
Výsledkem je nový seznam nebo řetězec:</p>

<pre>
<strong>[1 2 3 4]  [dup *]  map .</strong>
&nbsp;
[1 4 9 16] 
</pre>

<p>Podobným způsobem pracuje i kombinátor nazvaný <strong>filter</strong>,
který ovšem do nově vytvářeného seznamu či řetězce vkládá ty položky, které
splňují zadané kritérium, tj.&nbsp;položky jsou skutečně filtrovány na základě
neustále vyhodnocované podmínky:</p>

<pre>
<i>ze seznamu získáme pouze sudá čísla</i>
<i>(dělitelná dvěma)</i>
<strong>[0 1 2 3 4 5 6 7 8 9 10] [2 rem 0 =] filter .</strong>
[0 2 4 6 8 10]
&nbsp;
<i>opak předchozího příkladu, získání</i>
<i>lichých čísel z předaného seznamu</i>
<strong>[0 1 2 3 4 5 6 7 8 9 10] [2 rem 0 !=] filter .</strong>
[1 3 5 7 9]
&nbsp;
<i>z řetězce se vyberou všechny znaky, jejichž</i>
<i>pořadí v ASCII leží pod znakem 'a'</i>
<i>(v tomto případě se odstraní malá písmena)</i>
<strong>"Hello World" ['a &lt;] filter .</strong>
"H W"
&nbsp;
<i>z řetězce se vyberou všechny znaky, jejichž</i>
<i>pořadí v ASCII leží nad znakem 'Z'</i>
<i>(v tomto případě se odstraní velká písmena a mezery)</i>
<strong>"Hello World" ['Z &gt;] filter .</strong>
"elloorld"
&nbsp;
<i>filtrace mezer</i>
<i>(všimněte si způsobu zápisu mezery pomocí apostrofu)</i>
<strong>"Hello World" [' !=] filter .</strong>
"HelloWorld"
&nbsp;
<i>filtrace všech znaků kromě mezer</i>
<strong>"Hello World" [' =] filter .</strong>
" "
</pre>

<p>Nepočítaná programová smyčka typu <strong>while</strong> známá z&nbsp;mnoha
imperativních jazyků, je v&nbsp;programovacím jazyce <i>Joy</i> nahrazena
(poněkud překvapivě, že...) kombinátorem nazvaným právě <strong>while</strong>.
Před voláním tohoto kombinátoru musí být na zásobník uloženy dva citované
programy. První program představuje podmínku, která je vyhodnocena před každým
opakováním smyčky, druhý program představuje vlastní tělo smyčky, které je
opakovaně voláno v&nbsp;závislosti na vyhodnocení podmínky. Učebnicovým
příkladem použití tohoto kombinátoru je tvorba počítaného cyklu, přičemž
nesmíme zapomenout na zásobníku vytvořit číselnou hodnotu, která se bude při
opakování smyčky zvětšovat nebo naopak zmenšovat (funkce put provádí tisk čísla
uloženého na vrcholu zásobníku):</p>

<pre>
    <i>podmínka  tělo funkce    volání kombinátoru</i>
<strong>10   [0 &lt;]   [dup put 1 -]   while .</strong>
10 9 8 7 6 5 4 3 2 1 0
&nbsp;
<i>jednodušší způsob využívající operátoru pred</i>
<i>(poslední vytištěná hodnota je výsledkem operátoru tečka)</i>
<strong>10   [0 &gt;]   [dup put pred]  while .</strong>
10 9 8 7 6 5 4 3 2 1 0
&nbsp;
<i>zápis opačné podmínky a změna počáteční hodnoty</i>
<i>(poslední vytištěná hodnota je opět výsledkem operátoru</i>
<i> tečka, nikoli běhu smyčky)</i>
<strong>0 [10 &lt;] [dup put succ] while .</strong>
0 1 2 3 4 5 6 7 8 9 10
&nbsp;
<i>odstranění poslední hodnoty, která zůstává na zásobníku</i>
<strong>0 [10 &lt;] [dup put succ] while pop .</strong>
0 1 2 3 4 5 6 7 8 9
&nbsp;
<i>tisk sudých čísel</i>
<strong>0 [10 &lt;] [dup put succ succ] while .</strong>
0 2 4 6 8 10
&nbsp;
<i>tisk násobků tří</i>
<strong>0 [10 &lt;] [dup put 3 +] while .</strong>
0 3 6 9 12
&nbsp;
<i>o tom, že poslední číselná hodnota již není tělem</i>
<i>smyčky zpracovávána, se můžeme jednoduše přesvědčit</i>
<strong>0 [10 &lt;] ["-&gt;" putchars dup put succ "\n" putchars] while .</strong>
-&gt;0
-&gt;1
-&gt;2
-&gt;3
-&gt;4
-&gt;5
-&gt;6
-&gt;7
-&gt;8
-&gt;9
10 
</pre>



<p><a name="k09"></a></p>
<h2 id="k09">9. Lineární rekurze zapsaná formou <i>tacit programmingu</i></h2>

<p>Velmi často se při programování setkáváme s&nbsp;případy algoritmů, které se
dají efektivně řešit pomocí takzvané <i>lineární rekurze</i>. Jedná se vlastně
o takový případ rekurze, kdy funkce volá sebe samu ve svém těle pouze jednou.
Nejprve si řekněme, co si pod pojmem lineární rekurze vůbec máme představit a
v&nbsp;dalších odstavcích si ukážeme rekurzivní kombinátor, který slouží
k&nbsp;zápisu lineárně rekurzivních algoritmů.</p>

<p>Nějaká naprogramovaná funkce <strong>f</strong> je nazývána <i>lineárně
rekurzivní</i> v&nbsp;případě, že aktivace této funkce (tj.&nbsp;její zavolání)
vyvolá nejvýše jednu novou aktivaci té samé funkce <strong>f</strong>. Typickým
příkladem lineárně rekurzivní funkce je funkce faktoriál, v&nbsp;matematice
označovaná postfixovým operátorem ! (vykřičník). Příkladem funkce, která není
lineárně rekurzivní, je funkce pro výpočet Fibonacciho čísel &ndash;
v&nbsp;těle této funkce (nazvěme ji například pro jednoduchost
<strong>Fib</strong>) jsou vyvolány dvě aktivace té samé funkce
<strong>Fib</strong>. Vraťme se však ke zmíněné typické lineárně rekurzivní
funkci faktoriál, kterou lze matematicky definovat následujícím způsobem:</p>

<p><i>Fact(x)=1 &nbsp;&nbsp; pro x=0</i><br />
<i>Fact(x)=x&times;Fact(x-1) &nbsp;&nbsp; pro x&gt;0</i></p>

<p>Z&nbsp;praktického hlediska je zajímavý především způsob výpočtu lineárně
rekurzivní funkce, tj.&nbsp;vyjádření její hodnoty pro zadaný parametr.
Vyhodnocování je možné obecně rozdělit do dvou po sobě následujících částí:</p>

<p><strong>Fáze navíjení</strong> (<i>winding phase</i>): v&nbsp;této fázi jsou
postupně volány, tj.&nbsp;aktivovány takzvané aktivace rekurzivní funkce,
obecně s&nbsp;různými hodnotami parametrů.</p>

<p><strong>Fáze odvíjení</strong> (<i>unwinding phase</i>): tato fáze nastane
po splnění nějaké ukončující podmínky rekurze. Řízení, tj.&nbsp;bod, ve kterém
se běžící proces nachází, se postupně vrací jednotlivým vytvořeným
aktivacím.</p>

<p>V&nbsp;klasických imperativních i funkcionálních jazycích se lineárně
rekurzivní funkce skutečně zapisují pomocí rekurze, tj.&nbsp;v&nbsp;těle funkce
je volána (aktivována) ta samá funkce. Kromě toho je nutné zajistit, aby
rekurze byla konečná, což je provedeno pomocí nějaké podmínky, jež
v&nbsp;podstatě tvoří hranici mezi fází navíjení a fází odvíjení. Ukažme si,
jakým způsobem by byla zapsána lineárně rekurzivní funkce pro výpočet
faktoriálu v&nbsp;běžném programovacím jazyku (podobným způsobem, i když trošku
jednodušším, by se výpočet provedl i ve funkcionálních jazycích, například
<i>Lispu</i> nebo <i>Scheme</i>):</p>

<pre>
unsigned int fact(unsigned int n)
{
    if (n==0)          <i>// podmínka pro ukončení rekurze</i>
        return 1;      <i>// =&gt; přechod mezi fází navíjení a odvíjení</i>
    else
        n*fact(n-1);   <i>// rekurzivní volání funkce fact()</i>
}
</pre>

<p>Programovací jazyk <i>Joy</i> se od většiny jiných funkcionálních jazyků
odlišuje tím, že se lineárně rekurzivní funkce nemusí zapisovat pomocí rekurze
(i to je však samozřejmě možné); místo toho nabízí speciální <i>rekurzivní
kombinátor</i> představovaný slovem <strong>linrec</strong>. Tento kombinátor
při svém zavolání požaduje, aby byly na zásobníku uloženy následující čtyři
fragmenty citovaných programů:</p>

<ul>

<li><strong>P</strong> &ndash; tento citovaný program, který je nazývaný
<i>if-part</i>, je spuštěn před každým rekurzivním zanořením (nebo jeho obdobě,
pokud je rekurze nahrazena jiným výpočtem). Podle výsledku vyhodnocení programu
je buď spuštěn citovaný program <strong>T</strong> (<strong>P</strong> se
vyhodnotí na hodnotu <i>true</i>), nebo je spuštěn program <strong>R1</strong>,
je provedena rekurze a následně je spuštěn program <strong>R2</strong>
(spuštění tohoto programu může být časově velmi vzdálené od spuštění programu
<strong>R1</strong>, v&nbsp;závislosti na počtu zanoření do rekurzivní
funkce).</li>

<li><strong>T</strong> &ndash; tento citovaný program je nazývaný
<i>then-part</i> podle podobnosti s&nbsp;funkcí podobného programu u operátoru
<strong>ifte</strong>. Slouží k&nbsp;"úklidu" po rekurzivním zanořování
v&nbsp;případě, že je splněna podmínka zapsaná ve výše uvedeném programu
<strong>P</strong>.</li>

<li><strong>R1</strong> &ndash; citovaný blok programu nazývaný
<i>else-part-1</i> je vykonán v&nbsp;případě, že není splněna podmínka
vyhodnocovaná citovaným programem <strong>P</strong>, ještě před vlastním
provedením rekurze.</li>

<li><strong>R2</strong> &ndash; citovaný blok programu nazývaný
<i>else-part-2</i> je vykonán po provedení rekurzivního zanoření do
funkce.</li>

</ul>

<p>Lineární rekurzi si můžeme ukázat na oblíbeném příkladu výpočtu faktoriálu,
který lze zapsat buď klasicky rekurzivně:</p>

<pre>
<strong>DEFINE</strong>
<strong>factorial == [0 =] [pop 1] [dup 1 - factorial *] ifte</strong>
<strong>.</strong>
</pre>

<p>Nebo s&nbsp;využitím rekurzivního kombinátoru:</p>

<pre>
<strong>DEFINE</strong>
<strong>factorial2 == [dup 0 =] [1 +] [dup 1 -] [*] linrec</strong>
<strong>.</strong>
</pre>

<p>Popř.&nbsp;po náhradě některých aritmetických výrazů za funkce vykonávající
stejnou činnost:</p>

<pre>
<strong>DEFINE</strong>
<strong>factorial3 == [null]  [succ]  [dup pred]  [*]  linrec</strong>
<strong>.</strong>
</pre>

<p><div class="rs-tip-major">Poznámka: povšimněte si, že se v&nbsp;tomto zápisu
nevyskytuje ani jediné jméno parametru, pomocné proměnné či rekurzivně volané
funkce (to je uvedeno jen na levé straně definice).</div></p>

<p>A můžeme si vše otestovat:</p>

<pre>
<strong>[1 2 3 4 5 6] [factorial3] map .</strong>
[1 2 6 24 120 720]
</pre>

<p>nebo lze číselnou řadu vytvořit ještě lépe a radostněji:</p>

<pre>
<strong>0 [10 &lt;] [dup factorial3 put succ] while pop .</strong>
1 1 2 6 24 120 720 5040 40320 362880
</pre>

<p><div class="rs-tip-major">Poznámka: ještě by bylo vhodné doplnit obdobu
generátoru <strong>range</strong> z&nbsp;Pythonu nebo operátoru
<strong>iota</strong> z&nbsp;jazyka APL.</div></p>



<p><a name="k10"></a></p>
<h2 id="k10">10. Primární rekurze zapsaná formou <i>tacit programmingu</i></h2>

<p>Programovací jazyk <i>Joy</i> podporuje kromě kombinátoru umožňujícího
provádění <i>lineární rekurze</i> i kombinátor, který slouží pro zápis takzvané
<i>primitivní rekurze</i>. V&nbsp;podstatě se jedná o zredukovanou verzi
kombinátoru <strong>linrec</strong>, ovšem s&nbsp;tím rozdílem, že citovaný
blok nazvaný <i>if-part</i> a <i>else-part-1</i> je automaticky doplněn o kód
zajišťující automatické zjištění, kdy má být rekurze ukončena. Vzhledem
k&nbsp;tomu, že je blok <i>else-part-1</i> doplněn automaticky, nelze nic
provádět ve chvíli rekurzivního zanořování/navíjení (tím se například zamezí
vzniku nekonečné rekurze), ale průběh vynořování/odvíjení z&nbsp;rekurze je již
řízen blokem <i>else-part-2</i>, který je přítomen.</p>

<p>Následují velmi jednoduché příklady použití primitivní rekurze:</p>

<pre>
<i>nejprve se zásobník naplní sekvencí 5 4 3 2 1</i>
<i>a poté je tato sekvence v opačném pořadí</i>
<i>vypsána pomocí funkce put</i>
<strong>5 [] [put] primrec .</strong>
1 2 3 4 5
&nbsp;
<i>fáze navíjení je stejná jako v předchozím případě</i>
<i>ovšem ve fázi odvíjení je proveden výpočet</i>
<i>(0-hodnota) a teprve výsledek tohoto výpočtu</i>
<i>je vypsán</i>
<strong>5 [] [0 swap - put] primrec .</strong>
-1 -2 -3 -4 -5
&nbsp;
<i>obdobný případ, akorát se ve fázi odvíjení</i>
<i>každá hodnota na zásobníku vynásobí dvěma</i>
<strong>5 [] [2 * put] primrec .</strong>
2 4 6 8 10
&nbsp;
<i>opět se jedná o obdobný příklad s tím rozdílem,</i>
<i>že se vypočítá druhá mocnina hodnot uložených</i>
<i>na zásobníku</i>
<strong>5 [] [dup * put] primrec .</strong>
1 4 9 16 25
&nbsp;
<i>můžeme ovlivnit také počáteční podmínku</i>
<strong>5 ['A] [put] primrec .</strong>
'A 1 2 3 4 5
</pre>



<p><a name="k11"></a></p>
<h2 id="k11">11. Binární rekurze</h2>

<p>V&nbsp;praxi se také někdy setkáme s&nbsp;algoritmem, který vede na tvorbu
funkce, jež není lineárně rekurzivní, tj.&nbsp;v&nbsp;jejím těle se ta samá
funkce volá minimálně dvakrát. Jednou z&nbsp;takových funkcí je i známá
rekurzivně zadaná matematická funkce sloužící k&nbsp;výpočtu jedné hodnoty
ležící na Fibonacciho řadě. Pro každé číslo Fibonacciho řady platí vztah:</p>

<p>
<i>x<sub>n</sub>=x<sub>n-1</sub>+x<sub>n-2</sub></i>
</p>

<p>Přičemž je definitoricky nastaveno <i>x<sub>1</sub>=x<sub>2</sub>=1</i></p>

<p>Při použití rekurzivního kombinátoru <strong>binrec</strong> je výpočet
<i>n</i>-té hodnoty Fibonacciho řady velmi jednoduchý, i když pomalý, protože
se nepamatují předchozí vypočtené hodnoty. První blok citovaného programu
slouží pro test, zda je hodnota uložená na zásobníku rovna nule nebo jedné
(docela příjemná funkce ne?). Pokud je podmínka splněna, je spuštěn druhý blok,
který neprovádí žádnou činnost a tudíž na zásobníku ponechá původní hodnotu.
Třetí blok programu je zavolán před provedením rekurze, přičemž by se zde
typicky měl zvýšit počet položek uložených na zásobníku, protože pro dvě
nejvyšší položky je provedena rekurze. Poslední blok programu je proveden ve
fázi odvíjení a slouží ke zpětnému zkombinování dvou položek umístěných na
vrcholu zásobníku. Výsledkem je následující program:</p>

<pre>
<strong>[small] [] [pred dup pred] [+] binrec</strong>
</pre>

<pre>
<i>výpočet prvních deseti hodnot Fibonacciho řady</i>
<strong>1 [12 &lt;] [dup [small] [] [pred dup pred] [+] binrec put succ] while pop.</strong>
1 1 2 3 5 8 13 21 34 55 89
</pre>



<p><a name="k12"></a></p>
<h2 id="k12">12. Známé algoritmy přepsané do formy tacit programmingu</h2>

<p>V&nbsp;této kapitole si ukážeme, jakým způsobem je možné použít výše popsané
rekurzivní kombinátory k&nbsp;úpravě původně rekurzivních algoritmů na jejich
nerekurzivní variantu, tj.&nbsp;na variantu, ve které se explicitně nevyskytuje
přímá či nepřímá rekurze. Nerekurzivní úpravu je samozřejmě možné použít
v&nbsp;téměř jakémkoli programovacím jazyce, ovšem většinou za cenu
explicitního vytvoření zásobníku nebo podobné netriviální úpravy
(v&nbsp;některých případech pomůže <i>tail rekurze</i>, ovšem pouze jako
optimalizace primitivní a lineární rekurze). V&nbsp;programovacím jazyce
<i>Joy</i> je vytvoření nerekurzivních algoritmů s&nbsp;využitím rekurzivních
kombinátorů poměrně snadné.</p>

<pre>
<i>nejjednodušší forma výpočtu faktoriálu</i>
<i>pomocí primitivní rekurze</i>
<strong>[1] [*] primrec .</strong>
&nbsp;
<i>ukázka zanořování bloků kódu</i>
<i>při výpočtu faktoriálu</i>
<strong>[0 1 2 3 4 5 6] [[1] [*] primrec] map .</strong>
[1 1 2 6 24 120 720]
&nbsp;
<i>vytvoření seznamu obsahujícího sekvenci hodnot</i>
<strong>10 [[]] [cons] primrec .</strong>
[10 9 8 7 6 5 4 3 2 1]
&nbsp;
<i>vytvoření rekurzivně vkládaných podseznamů</i>
<strong>6 [[]]  [[] cons cons]  primrec .</strong>
[6 [5 [4 [3 [2 [1 []]]]]]]
&nbsp;
<i>algoritmus QuickSort</i>
<strong>[small] [] [uncons [&gt;] split] [[swap] dip cons concat] binrec</strong>
</pre>



<p><a name="k13"></a></p>
<h2 id="k13">13. Tacit programming v&nbsp;programovacím jazyku J</h2>

<p>Podobným způsobem je možné vytvářet funkce i v&nbsp;programovacím jazyku
<i>J</i>. Typickým příkladem je funkce pro výpočet průměru číselných hodnot
uložených v&nbsp;nějakém vektoru. Průměr se vypočítá snadno: nejprve zjistíme
součet (sumu) všech prvků (funkce <strong>+</strong> zkombinovaná
s&nbsp;operátorem <strong>/</strong>) a následně tento součet vydělíme jejich
počtem (funkce <strong>#</strong> zjistí délku vektoru). Při těchto výpočtech
není nutné nikde explicitně pojmenovávat parametry &ndash; ty se použijí až při
aplikaci (použití) vytvořené kombinace funkcí v&nbsp;další části programu:</p>

<pre>
NB. mean=suma(a1..an)/n
mean =: +/ % #
</pre>

<p>Aby ovšem bylo možné tento program plně pochopit, musíme si říci, jak
pracuje operátor <strong>+/</strong> a primitivní funkce <strong>%</strong> a
<strong>#</strong>.</p>

<p>Aritmetické a logické výrazy, které tvoří nejdůležitější součást všech
programů zapisovaných v&nbsp;jazyku <i>J</i>, se vyhodnocují stejným způsobem,
jako v&nbsp;již zmíněném programovacím jazyku <i>APL</i>, tj.&nbsp;zprava
doleva bez toho, aby některé funkce měly vyšší prioritu než funkce jiné. Funkce
se zapisují stejným způsobem jako v&nbsp;jiných jazycích prefixové a infixové
operátory, tj.&nbsp;buď mezi oba argumenty (operandy) při volání dyadických
funkcí nebo před jediný argument v&nbsp;případě, že se volá funkce monadická.
Pokud je zapotřebí změnit pořadí volání funkcí, lze k&nbsp;tomuto účelu použít
obligátní kulaté závorky. V&nbsp;jazyku <i>J</i> je k&nbsp;dispozici pět
základních aritmetických funkcí, které jsou vypsány v&nbsp;tabulce pod
odstavcem (povšimněte si především odlišného způsobu zápisu funkce podílu dvou
hodnot). Způsob použití těchto funkcí i způsob úpravy priority (pořadí volání)
je patrný z&nbsp;demonstračních příkladů uvedených pod tabulkou.</p>

<table>
<tr><th>Znak funkce</th><th>Monadická funkce</th><th>Dyadická funkce</th></tr>
<tr><td>+ </td><td>negace imaginární složky komplexního čísla</td><td>součet (skalárů, vektorů, matic...)</td></tr>
<tr><td>- </td><td>negace            </td><td>rozdíl</td></tr>
<tr><td>* </td><td>vrací znaménko    </td><td>součin</td></tr>
<tr><td>% </td><td>převrácená hodnota</td><td>podíl</td></tr>
<tr><td>| </td><td>absolutní hodnota </td><td>zbytek</td></tr>
<tr><td>^ </td><td>&nbsp;            </td><td>umocnění x<sup>y</sup></td></tr>
<tr><td>*:</td><td>druhá mocnina x<sup>2</sup></td><td>&nbsp;</td></tr>
<tr><td>%:</td><td>druhá odmocnina x<sup>1/2</sup></td><td>&nbsp;</td></tr>
<tr><td>! </td><td>faktoriál</td><td>&nbsp;</td></tr>
</table>

<p><div class="rs-tip-major">Poznámka: nyní již tedy známe funkci dyadické
funkce <strong>%</strong> &ndash; jedná se o podíl.</div></p>

<p>Programovací jazyk <i>J</i> je, podobně jako jeho ideový předchůdce
<i>APL</i>, určen především pro tvorbu aplikací, v&nbsp;nichž se zpracovávají
data uložená ve vektorech, maticích či polích s&nbsp;větším počtem dimenzí
(může se jednat například o hierarchické mřížky atd.). Z&nbsp;tohoto důvodu je
jazyk <i>J</i> vybaven jak jednoduchou syntaxí určenou pro zápis vektorů a
matic, tak i sadou primitivních (základních) funkcí, pomocí nichž lze nad
vektory i maticemi provádět různé operace:</p>

<table>
<tr><th>Symbol funkce</th><th>Forma funkce</th><th>Popis funkce (význam)</th></tr>
<tr><td>+ - * %</td><td>dyadická</td><td>základní aritmetické operace prováděné nad dvojicí vektorů na korespondujících prvcích (též prováděné nad skalárem a vektorem)</td></tr>
<tr><td>&lt; &lt;: &gt; &gt;: = ~:</td><td>dyadická</td><td>porovnání korespondujících prvků dvou vektorů</td></tr>
<tr><td># </td><td>monadická</td><td>vrací délku vektoru</td></tr>
<tr><td># </td><td>dyadická </td><td>kopie prvků vektoru představovaného druhým parametrem</td></tr>
<tr><td>{ </td><td>dyadická </td><td>výběr prvku či více prvků z&nbsp;vektoru na základě indexů vybíraných prvků</td></tr>
<tr><td>{.</td><td>dyadická </td><td>výběr prvních <i>n</i> prvků z&nbsp;vektoru</td></tr>
<tr><td>}.</td><td>dyadická </td><td>výběr posledních <i>délka-n</i> prvků vektoru (= odstranění prvních <i>n</i> prvků)</td></tr>
<tr><td>, </td><td>dyadická </td><td>spojení dvou vektorů či vektoru se skalárem</td></tr>
<tr><td>/:</td><td>monadická</td><td>setřídění prvků vektoru sestupně (funkce vrací indexy prvků, ne jejich hodnoty)</td></tr>
<tr><td>\:</td><td>monadická</td><td>setřídění prvků vektoru vzestupně (funkce též vrací indexy prvků, ne jejich hodnoty)</td></tr>
<tr><td>i.</td><td>monadická</td><td>vytváří seznam (vektor) obsahující řadu čísel začínající nulou, popř.&nbsp;prázdný vektor</td></tr>
<tr><td>i:</td><td>monadická</td><td>vytváří seznam (vektor) obsahující čísla on <i>-n</i> do <i>n</i>, kde <i>n</i> je parametr funkce</td></tr>
<tr><td>p.</td><td>monadická</td><td>výpočet kořenů polynomu reprezentovaného vektorem obsahujícím koeficienty <i>a<sub>i</sub></i></td></tr>
</table>

<p><div class="rs-tip-major">Poznámka: ve výpočtu byla použita funkce
<strong>#</strong>, kterou již tedy taktéž známe &ndash; jde o zjištění délky
vektoru.</div></p>

<p>Jedním z&nbsp;nejdůležitějších operátorů jazyka <i>J</i> je operátor
<strong>/</strong>, který jsme si již v&nbsp;jednodušší podobě představili při
popisu jazyka <i>APL</i>. Tento operátor, který se zapisuje za identifikátor
primitivní či uživatelské funkce, postupně danou funkci aplikuje na první dva
prvky argumentu, dále ji aplikuje na průběžný výsledek a třetí prvek atd., do
doby, než jsou všechny prvky argumentu zpracovány (jinými slovy &ndash; daná
dyadická funkce je jakoby zapsána mezi všechny prvky předané datové struktury,
počet operací je roven <i>n-1</i> v&nbsp;případě, že předaný vektor má počet
prvků <i>n</i>):</p>

<pre>
   NB. Součet všech čísel v řadě od 1 do 10.
   + / 1 2 3 4 5 6 7 8 9 10
55
</pre>

<p><div class="rs-tip-major">Poznámka: známe tedy význam posledního dvojznaku
<strong>+/</strong>. Zbývá nám zjistit, jak je možné, že kombinace operátoru
<strong>+/</strong> a dvojice funkcí <strong>%</strong> a <strong>#</strong>
můžeme spojit do výpočtu průměru vektoru <strong>+/ % #</strong>. V&nbsp;tomto
zápisu nám chybí uvedení parametrů obou funkcí a operátoru.</div></p>



<p><a name="k14"></a></p>
<h2 id="k14">14. Jazyk J a &bdquo;vláčky&ldquo;</h2>

<pre>
<strong>sum    =: +/</strong>
<strong>square =: *:</strong>
</pre>

<pre>
<strong>(f @: g) y</strong>
</pre>

<p>je ve skutečnosti vyhodnocen jako:</p>

<pre>
<strong>f (g y)</strong>
</pre>

<pre>
<strong>sumsq =: sum @: square</strong>
</pre>

<pre>
<strong>sumsq 3 4</strong>
25
</pre>

(f g) y   means    y f (g y)
(f g h) y   means    (f y) g (h y)

sum  =: +/
mean =: sum % #

<table>
<tr><td>f</td><td>sum</th></tr>
<tr><td>g</td><td>%</th></tr>
<tr><td>h</td><td>#</th></tr>
<tr><td>y</td><td>y</th></tr>
</table>

<table>
<tr><th>Zápis</th><th>Ekvivalentní se zápisem</th></tr>
<tr><td>(f g h) y</td><td>(f y) g (h y)</td></tr>
<tr><td>(sum % #) y</td><td>(sum y) % (# y)</td></tr>
</table>

<pre>
y =: 1 2 3 4
</pre>

<table>
<tr><th>Výraz</th><th>Vyhodnoceno na</th>
<tr><td>y</td><td>1 2 3 4</td></tr>
<tr><td>sum y</td><td>10</td></tr>
<tr><td># y</td><td>4</td></tr>
<tr><td>(sum y) % (# y)</td><td>2.5</td></tr>
<tr><td>mean y</td><td>2.5</td></tr>
</table>

<table>
<tr><td>f</td><td>+/</th></tr>
<tr><td>g</td><td>%</th></tr>
<tr><td>h</td><td>#</th></tr>
<tr><td>y</td><td>y</th></tr>
</table>

<table>
<tr><th>Zápis</th><th>Ekvivalentní se zápisem</th></tr>
<tr><td>(f g h) y</td><td>(f y) g (h y)</td></tr>
<tr><td>(+/ % #) y</td><td>(+/ y) % (# y)</td></tr>
</table>







Functional, or Applicative, programming is programming without assignment statements: one just applies functions to arguments. Examples: Scheme, Haskell, Miranda, ML.
Function-level programming does away with the variables; one combines functions with functionals, a.k.a. combinators. Examples: FP, FL, J. 


f(x) = h(g(x))
f = h . g





(filter odd?)
(map inc)
(take 5)

(def xf
  (comp
    (filter odd?)
    (map inc)
    (take 5)))

(def xf (comp (filter odd?) (map inc)))
(transduce xf + (range 5))
;; => 6
(transduce xf + 100 (range 5))
;; => 106


(defn build-topology
  "Definice celé pipeliny (kolony) - základ aplikace."
  [builder topic-config]
  (-> (j/kstream builder (:input topic-config))
      (j/peek (fn [[k v]]
                (log/warn "Received message with key:   " k " and value:" v)))
      (j/through (:output-1 topic-config))
      (j/map etl-1)
      (j/peek (fn [[k v]]
                (log/warn "Transformed message with key:" k " and value:" v)))
      (j/through (:output-2 topic-config))
      (j/map etl-2)
      (j/peek (fn [[k v]]
                (log/warn "Transformed message with key:" k " and value:" v)))
      (j/to (:output-3 topic-config)))
  builder)

(defn etl-1
  "Transformační funkce."
  [[k v]]
  [k {:result (+ (:x v) (:y v))}])


(defn etl-2
  "Transformační funkce."
  [[k v]]
  [k (assoc v :timestamp (str (new java.util.Date)))])


(def etl-3
  "Transformační funkce vytvořená ve formě uzávěru."
  (let [counter (atom 0)]
    (fn [[k v]] (do
                  (swap! counter inc) 
                  [k (assoc v :counter @counter)]))))

(defn build-topology
  "Definice celé pipeliny (kolony) - základ aplikace."
  [builder topic-config]
  (-> (j/kstream builder (:input topic-config))
      (j/peek (fn [[k v]]
                (log/warn "Received message with key:   " k " and value:" v)))
      (j/through (:output-1 topic-config))
      (j/map etl-1)
      (j/peek (fn [[k v]]
                (log/warn "Transformed message with key:" k " and value:" v)))
      (j/through (:output-2 topic-config))
      (j/map etl-2)
      (j/peek (fn [[k v]]
                (log/warn "Transformed message with key:" k " and value:" v)))
      (j/through (:output-3 topic-config))
      (j/map etl-3)
      (j/peek (fn [[k v]]
                (log/warn "Transformed message with key:" k " and value:" v)))
      (j/to (:output-4 topic-config)))
  builder)



<p><a name="k15"></a></p>
<h2 id="k15">15. </h2>



<p><a name="k16"></a></p>
<h2 id="k16">16. </h2>



<p><a name="k17"></a></p>
<h2 id="k17">17. </h2>



<p><a name="k18"></a></p>
<h2 id="k18">18. </h2>



<p><a name="k19"></a></p>
<h2 id="k19">19. Repositář s&nbsp;demonstračními příklady</h2>



<p><a name="k20"></a></p>
<h2 id="k20">20. Odkazy na Internetu</h2>

<ol>

<li>Tacit programming (APL Wiki)<br />
<a href="https://aplwiki.com/wiki/Tacit_programming">https://aplwiki.com/wiki/Tacit_programming</a>
</li>

<li>Function trains<br />
<a href="https://mlochbaum.github.io/BQN/doc/train.html">https://mlochbaum.github.io/BQN/doc/train.html</a>
</li>

<li>Tacit programming (Wikipedia)<br />
<a href="https://en.wikipedia.org/wiki/Tacit_programming">https://en.wikipedia.org/wiki/Tacit_programming</a>
</li>

<li>Beyond Functional Programming: Manipulate Functions with the J Language<br />
<a href="https://www.adamtornhill.com/articles/jlang/beyondfunctional.html">https://www.adamtornhill.com/articles/jlang/beyondfunctional.html</a>
</li>

<li>Real World Uses of Tacit Programming: Part 1 of 2<br />
<a href="https://medium.com/@jesterxl/real-world-uses-of-tacit-programming-part-1-of-2-f2a0c3f9e00c">https://medium.com/@jesterxl/real-world-uses-of-tacit-programming-part-1-of-2-f2a0c3f9e00c</a>
</li>

<li>Programovací jazyk Forth a zásobníkové procesory<br />
<a href="http://www.root.cz/clanky/programovaci-jazyk-forth-a-zasobnikove-procesory/">http://www.root.cz/clanky/programovaci-jazyk-forth-a-zasobnikove-procesory/</a>
</li>

<li>Seriál Programovací jazyk Forth<br />
<a href="http://www.root.cz/serialy/programovaci-jazyk-forth/">http://www.root.cz/serialy/programovaci-jazyk-forth/</a>
</li>

<li>Programovací jazyk Factor<br />
<a href="http://www.root.cz/clanky/programovaci-jazyk-factor/">http://www.root.cz/clanky/programovaci-jazyk-factor/</a>
</li>

<li>Grafický metaformát PostScript<br />
<a href="http://www.root.cz/clanky/graficky-metaformat-postscript/">http://www.root.cz/clanky/graficky-metaformat-postscript/</a>
</li>

<li>Programovací jazyk Factor<br />
<a href="https://www.root.cz/clanky/programovaci-jazyk-factor/">https://www.root.cz/clanky/programovaci-jazyk-factor/</a>
</li>

<li>Factor: revoluce v&nbsp;programování nebo propadák?<br />
<a href="https://www.root.cz/clanky/factor-revoluce-v-programovani-nebo-propadak/">https://www.root.cz/clanky/factor-revoluce-v-programovani-nebo-propadak/</a>
</li>

<li>Integrované vývojové prostředí Factoru<br />
<a href="https://www.root.cz/clanky/integrovane-vyvojove-prostredi-factoru/">https://www.root.cz/clanky/integrovane-vyvojove-prostredi-factoru/</a>
</li>

<li>Programujeme ve Factoru<br />
<a href="https://www.root.cz/clanky/programujeme-ve-factoru/">https://www.root.cz/clanky/programujeme-ve-factoru/</a>
</li>

<li>Joy: radost z&nbsp;programování<br />
<a href="https://www.root.cz/clanky/joy-radost-z-programovani/">https://www.root.cz/clanky/joy-radost-z-programovani/</a>
</li>

<li>Joy: programovací jazyk od protinožců<br />
<a href="https://www.root.cz/clanky/joy-programovaci-jazyk-od-protinozcu/">https://www.root.cz/clanky/joy-programovaci-jazyk-od-protinozcu/</a>
</li>

<li>Jazyk Joy a rekurzivní kombinátory<br />
<a href="https://www.root.cz/clanky/jazyk-joy-a-rekurzivni-kombinatory/">https://www.root.cz/clanky/jazyk-joy-a-rekurzivni-kombinatory/</a>
</li>

<li>Point-Free or Die: Tacit Programming in Haskell and Beyond<br />
<a href="https://www.thestrangeloop.com/2016/point-free-or-die-tacit-programming-in-haskell-and-beyond.html">https://www.thestrangeloop.com/2016/point-free-or-die-tacit-programming-in-haskell-and-beyond.html</a>
</li>

<li>Threading macro (dokumentace k&nbsp;jazyku Clojure)<br />
<a href="https://clojure.github.io/clojure/clojure.core-api.html#clojure.core/-&gt;">https://clojure.github.io/clojure/clojure.core-api.html#clojure.core/-&gt;</a>
</li>

<li>Understanding the Clojure -&gt; macro<br />
<a href="http://blog.fogus.me/2009/09/04/understanding-the-clojure-macro/">http://blog.fogus.me/2009/09/04/understanding-the-clojure-macro/</a>
</li>

<li>Transducers<br />
<a href="https://clojure.org/reference/transducers">https://clojure.org/reference/transducers</a>
</li>

<li>dc (computer program)<br />
<a href="https://en.wikipedia.org/wiki/Dc_%28computer_program%29">https://en.wikipedia.org/wiki/Dc_%28computer_program%29</a>
</li>

<li>dc (na Esolang)<br />
<a href="http://esolangs.org/wiki/Dc">http://esolangs.org/wiki/Dc</a>
</li>

<li>Relational pipes<br />
<a href="https://relational-pipes.globalcode.info/v_0/">https://relational-pipes.globalcode.info/v_0/</a>
</li>

<li>Roura (Unix)<br />
<a href="https://cs.wikipedia.org/wiki/Roura_(Unix)">https://cs.wikipedia.org/wiki/Roura_(Unix)</a>
</li>

<li>Roura (software)<br />
<a href="https://cs.wikipedia.org/wiki/Roura_(software)">https://cs.wikipedia.org/wiki/Roura_(software)</a>
</li>

<li>APL Wiki<br />
<a href="https://aplwiki.com/wiki/">https://aplwiki.com/wiki/</a>
</li>

<li>The Array Cast<br />
<a href="https://www.arraycast.com/episodes/episode-03-what-is-an-array">https://www.arraycast.com/episodes/episode-03-what-is-an-array</a>
</li>

<li>EnthusiastiCon 2019 – An Introduction to APL<br />
<a href="https://www.youtube.com/watch?v=UltnvW83_CQ">https://www.youtube.com/watch?v=UltnvW83_CQ</a>
</li>

<li>Dyalog<br />
<a href="https://www.dyalog.com/">https://www.dyalog.com/</a>
</li>

<li>Try APL!<br />
<a href="https://tryapl.org/">https://tryapl.org/</a>
</li>

<li>APL na replit<br />
<a href="https://replit.com/languages/apl">https://replit.com/languages/apl</a>
</li>

<li>Advent of Code 2020 in APL!<br />
<a href="https://www.youtube.com/watch?v=0RQFW6P1Tt0">https://www.youtube.com/watch?v=0RQFW6P1Tt0</a>
</li>

<li>Python vs APL (1 Problem)<br />
<a href="https://www.youtube.com/watch?v=APdKFJkmBbM">https://www.youtube.com/watch?v=APdKFJkmBbM</a>
</li>

<li>APL Wins (vs C++, Java &amp; Python)<br />
<a href="https://www.youtube.com/watch?v=59vAjBS3yZM">https://www.youtube.com/watch?v=59vAjBS3yZM</a>
</li>

<li>A Tour de Force of APL in 16 Expressions by Roger Hui<br />
<a href="https://www.youtube.com/watch?v=e0rywC7-i0U">https://www.youtube.com/watch?v=e0rywC7-i0U</a>
</li>

<li>Conway's Game Of Life in APL<br />
<a href="https://www.youtube.com/watch?v=a9xAKttWgP4">https://www.youtube.com/watch?v=a9xAKttWgP4</a>
</li>

<li>A List of companies that use Array Languages (J, K, APL, q)<br />
<a href="https://github.com/interregna/arraylanguage-companies">https://github.com/interregna/arraylanguage-companies</a>
</li>

<li>APL - one of the greatest programming languages ever<br />
<a href="http://www.vaxman.de/publications/apl_slides.pdf">http://www.vaxman.de/publications/apl_slides.pdf</a>
</li>

<li>"The J Programming Language" by Tracy Harms (2013)<br />
<a href="https://www.youtube.com/watch?v=RWYkx6-L04Q">https://www.youtube.com/watch?v=RWYkx6-L04Q</a>
</li>

<li>Dyalog Modern Programming Language, Morten Kromberg, Talks at Google<br />
<a href="https://www.youtube.com/watch?v=PlM9BXfu7UY">https://www.youtube.com/watch?v=PlM9BXfu7UY</a>
</li>

<li>The J Language: Consistency, Adjacency, and Solution-Oriented Programming - Tracy Harms<br />
<a href="https://www.youtube.com/watch?v=gLULrFY2-fI">https://www.youtube.com/watch?v=gLULrFY2-fI</a>
</li>

<li>Un-directed programming<br />
<a href="https://www.sacrideo.us/un-structured-programming/">https://www.sacrideo.us/un-structured-programming/</a>
</li>

<li>Concatenative programming language<br />
<a href="https://en.wikipedia.org/wiki/Concatenative_programming_language">https://en.wikipedia.org/wiki/Concatenative_programming_language</a>
</li>

<li>Repositáře s&nbsp;jazykem Joy<br />
<a href="https://github.com/joy-language">https://github.com/joy-language</a>
</li>

<li>J language: Chapter 8: Composing Verbs<br />
<a href="https://www.jsoftware.com/help/learning/08.htm">https://www.jsoftware.com/help/learning/08.htm</a>
</li>

<li>J language: Chapter 9: Trains of Verbs<br />
<a href="https://www.jsoftware.com/help/learning/09.htm">https://www.jsoftware.com/help/learning/09.htm</a>
</li>

</ol>



<p></p><p></p>
<p><small>Autor: <a href="http://www.fit.vutbr.cz/~tisnovpa">Pavel Tišnovský</a> &nbsp; 2021</small></p>
</body>
</html>

