<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
        "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html>
<head>
<title></title>
<meta name="Author" content="Pavel Tisnovsky" />
<meta name="Generator" content="vim" />
<meta http-equiv="content-type" content="text/html; charset=utf-8" />
<style type="text/css">
         body {color:#000000; background:#ffffff;}
         h1  {font-family: arial, helvetica, sans-serif; color:#ffffff; background-color:#c00000; text-align:center; padding-left:1em}
         h2  {font-family: arial, helvetica, sans-serif; color:#ffffff; background-color:#0000c0; padding-left:1em; text-align:left}
         h3  {font-family: arial, helvetica, sans-serif; color:#000000; background-color:#c0c0c0; padding-left:1em; text-align:left}
         h4  {font-family: arial, helvetica, sans-serif; color:#000000; background-color:#e0e0e0; padding-left:1em; text-align:left}
         a   {font-family: arial, helvetica, sans-serif;}
         li  {font-family: arial, helvetica, sans-serif; color:#000000; text-align:justify; width:450px;}
         ol  {font-family: arial, helvetica, sans-serif; color:#000000; text-align:justify; width:450px;}
         ul  {font-family: arial, helvetica, sans-serif; color:#000000; text-align:justify; width:450px;}
         p   {font-family: arial, helvetica, sans-serif; color:#000000; text-align:justify;}
         pre {background:#e0e0e0}
</style>
</head>

<body>

<h1></h1>

<h3>Pavel Tišnovský</h3>

<p></p>

<h1>Úvodník</h1>

<p></p>



<h2>Obsah</h2>

<p><a href="#k01">*** 1. </a></p>
<p><a href="#k02">*** 2. </a></p>
<p><a href="#k03">*** 3. </a></p>
<p><a href="#k04">*** 4. </a></p>
<p><a href="#k05">*** 5. </a></p>
<p><a href="#k06">*** 6. </a></p>
<p><a href="#k07">*** 7. </a></p>
<p><a href="#k08">*** 8. </a></p>
<p><a href="#k09">*** 9. </a></p>
<p><a href="#k10">*** 10. </a></p>
<p><a href="#k11">*** 11. </a></p>
<p><a href="#k12">*** 12. </a></p>
<p><a href="#k13">*** 13. </a></p>
<p><a href="#k14">*** 14. </a></p>
<p><a href="#k15">*** 15. </a></p>
<p><a href="#k16">*** 16. </a></p>
<p><a href="#k17">*** 17. </a></p>
<p><a href="#k18">*** 18. </a></p>
<p><a href="#k19">*** 19. </a></p>
<p><a href="#k20">*** 20. Odkazy na Internetu</a></p>



<p><a name="k01"></a></p>
<h2 id="k01">1. </h2>

f(x) = h(g(x))
f = h . g

<p>V&nbsp;dnešním článku se seznámíme se zajímavou programovací technikou, která je nazývána <i>point-free style</i> popř.&nbsp;v&nbsp;některých programovacích jazycích <i>tacit programming</i>. Přesný a dostatečně jednoznačný český ekvivalent tohoto označení mě nenapadá, proto raději zůstanu u termínu anglického, který se ostatně snadněji vyhledává. Jedná se o styl zápisu bloků programů (typicky jednotlivých výrazů, ale i uživatelských funkcí popř.&nbsp;sekvencí funkcí), ve kterých se nachází volání jiných funkcí, ovšem bez explicitního udání jmen jejich argumentů (parametrů). Proč by se však <i>tacit programming</i> měl používat, resp.&nbsp;jaká je jeho přednost? Základní idea spočívá v&nbsp;tom, že se seskupením funkcí popř.&nbsp;operátorů vytvoří abstraktnější funkce/operátor, takže je možné v&nbsp;programovacím jazyce vybaveném relativně základními operacemi vytvářet vyšší úrovně abstrakce podle potřeb programátora, a to za použití snadno pochopitelných a testovatelných prostředků a idiomů.</p>

<p>S&nbsp;<i>tacit programmingem</i> se můžeme setkat v&nbsp;mnoha prostředích a v&nbsp;různých programovacích jazycích. Asi nejznámějším příkladem jsou <i>kolony</i> v&nbsp;shellu, dále technika vytváření nových slov v&nbsp;jazycích založených na RPM (Forth, Joy, Factor, PostScript, ...), technika operátorů použitá v&nbsp;jazycích APL a J (zde se pravděpodobně poprvé objevuje označení <i>train</i>) a zapomenout nesmíme ani na jazyk Haskell popř.&nbsp;na Clojure (threading macro a transducery).</p>

<p>Lze předpokládat, že naprostá většina čtenářů Roota se s&nbsp;programovací technikou, kterou budeme v&nbsp;tomto článku označovat termínem <i>tacit programming</i> již setkala, a to přímo v&nbsp;shellu. Konkrétně se jedná o použití <i>kolon</i>, protože každý příkaz uvnitř kolony čte data z&nbsp;předchozího příkazu, transformuje či agreguje tato data a posílá výsledky příkazu dalšímu. Výjimkou je první popř.&nbsp;poslední příkaz, který je ke koloně připojen jen zleva či zprava. Na příkladu je ukázána jednoduchá kolona, přičemž ta část, kterou bychom mohli označit termínem <i>tacit programming</i> nebo <i>point-free style</i>, je zvýrazněna tučným písmem</p>

<pre>
cat foobar | <strong>tr ',' '\n' | sort | uniq | rev</strong>
</pre>

<p><div class="rs-tip-major">Poznámka: povšimněte si, že se skutečně nikde uvnitř kolony neuvádí žádná jména proměnných ani souborů, s&nbsp;nimiž se má pracovat. U příkazu <strong>tr</strong> můžeme vidět ještě jednu techniku &ndash; díky použití parametrů jsme vlastně vytvořili nový (anonymní) příkaz, který by klidně mohl být pojmenován, například <strong>commas2endlines</strong> apod. Mimochodem &ndash; podobnou techniku nalezneme i v&nbsp;některých dále popsaných &bdquo;plnohodnotných&ldquo; programovacích jazycích, kde se v&nbsp;tomto kontextu většinou hovoří o uzávěrech (<i>closures</i>).</div></p>

<p>S&nbsp;tímto stylem programování jsme se již mohli ve stručnosti seznámit ve starších miniseriálech o programovacím jazyku <i>Forth</i>, <i>Joy</i> a <i>Factor</i> (viz <a href="#k20">dvacátou kapitolu</a> s&nbsp;příslušnými odkazy), v&nbsp;nichž se využívalo toho, že všechny argumenty funkcí (operátorů) se nacházely na nejvyšších místech zásobníku operandů, přičemž všechny operátory s&nbsp;těmito operandy pracovaly implicitně, opět bez nutnosti uvádět jejich jména (příklady si pochopitelně ukážeme v&nbsp;navazujících kapitolách). Ve všech třech zmíněných jazycích, tedy ve Forthu, jazyce Joy i ve Factoru se striktně používá <i>obrácená polská notace</i> (<i>RPN – Reverse Polish Notation</i>). Název &bdquo;polská notace&ldquo; byl zvolen na počest polského matematika <i>Jana Lukasiewicze</i>, který v&nbsp;roce 1920 navrhl dvě možnosti psaní matematických výrazů bez nutnosti definice priorit operací a také bez použití závorek, kterým se při použití dnes nejpoužívanější infixové notace v&nbsp;mnoha případech nevyhneme. Notace, při které se operátory píšou až za operandy (tedy &bdquo;obráceně&ldquo;), se nazývá RPN či postfixová notace.</p>

<p>Ve skutečnosti však není <i>tacit programming</i> v&nbsp;žádném případě vázán na použití RPN. Typickým příkladem programovacího jazyka, v&nbsp;němž se <i>tacit programming</i> začal používat, je jazyk <i>APL</i>, s&nbsp;jehož padesáti pětiletou historií jsme se nedávno <a href="https://www.root.cz/clanky/oslava-55-let-od-vzniku-prvni-implementace-programovaciho-jazyka-apl/">seznámili zde na Rootu</a>. A <i>APL</i> je jazykem založeným na klasické infixové notaci. Myšlenka <i>tacit programmingu</i> nebyla v&nbsp;původním jazyku <i>APL</i> plně rozvinuta; ke zobecnění této techniky došlo v&nbsp;jazyce <i>J</i>, který je od <i>APL</i> odvozen.</p>


Functional, or Applicative, programming is programming without assignment statements: one just applies functions to arguments. Examples: Scheme, Haskell, Miranda, ML.
Function-level programming does away with the variables; one combines functions with functionals, a.k.a. combinators. Examples: FP, FL, J. 


<p><a name="k02"></a></p>
<h2 id="k02">2. </h2>

Ve <i>Forthu</i> tedy bylo možné napsat například následující funkci:</p>

<pre>
:foo + * ;
</pre>

<p>která na zásobníku očekávala alespoň tři číselné hodnoty, které ovšem uvnitř
funkce nebyly nikde explicitně pojmenovány ani použity. Použití této funkce bylo
stejně snadné jako její zápis:</p>

<pre>
3 2 1 foo .
9
</pre>

<p>Podobným způsobem je možné vytvářet funkce i v&nbsp;programovacím jazyku
<i>J</i>. Typickým příkladem je funkce pro výpočet průměru číselných hodnot
uložených v&nbsp;nějakém vektoru. Průměr se vypočítá snadno: nejprve zjistíme
součet (sumu) všech prvků (funkce <strong>+</strong> zkombinovaná
s&nbsp;operátorem <strong>/</strong>) a následně tento součet vydělíme jejich
počtem (funkce <strong>#</strong> zjistí délku vektoru). Při těchto výpočtech
není nutné nikde explicitně pojmenovávat parametry &ndash; ty se použijí až
při aplikaci (použití) vytvořené kombinace funkcí v&nbsp;další části
programu:</p>

<pre>
   NB. mean=suma(a1..an)/n
   mean =: +/ % #
</pre>




<p><a name="k03"></a></p>
<h2 id="k03">3. </h2>

<p>V&nbsp;úvodním textu jsme se zmínili o jazycích <i>Forth</i>, <i>Joy</i>, <i>Factor</i> či <i>PostScript</i>. I přesto, že se tyto jazyky od sebe v&nbsp;mnoha ohledech liší, mají jednu důležitou vlastnost společnou &ndash; výpočty, tj.&nbsp;aritmetické operace, logické operace a rozhodovací (řídicí) konstrukce jsou prováděny s&nbsp;hodnotami uloženými na zásobníku. Díky tomu bylo možné jazyky značně zjednodušit, protože se o transformaci výrazů z&nbsp;dnes běžné infixové podoby do podoby postfixové (taktéž známé pod taktéž již zmíněným názvem <i>Převrácená Polská Notace/Reverse Polish Notation &ndash; RPN</i>) musí postarat sám programátor. To ve skutečnosti není nijak složité, ostatně s&nbsp;prakticky stejným problémem se musí potýkat i ti vývojáři, kteří pracují ve <i>Forthu</i>, <i>PostScriptu</i> či v&nbsp;jazycích <i>Joy</i> a <i>Factor</i> (podle názoru některých vývojářů se všechny čtyři zmíněné nástroje už nachází na hranici mezi &bdquo;civilizovanými&ldquo; programovacími jazyky a jazyky esoterickými, i když autor článku je velkým <a href="http://www.root.cz/serialy/programovaci-jazyk-forth/">fandou</a> zásobníkových jazyků, takže tento názor nesdílí :-).</p>


Definice nových funkcí v jazyku Joy

Způsob vytváření nových funkcí je, alespoň po syntaktické stránce, zcela zjevně inspirován programovacím jazykem Forth. Pojďme se bez většího teoretizování podívat na příklad vytvoření dvou nových funkcí pojmenovaných jednoduše square a cube. Z příkladu je patrné, že vytváření nových funkcí začíná slovem DEFINE, za nímž následuje vždy název funkce, znaky == oddělující název funkce od jejího těla a poté vlastní tělo funkce. Jednotlivé definice jsou od sebe odděleny znakem středníku, což připomíná již zmíněný jazyk Forth, konec definic všech funkcí zařídí operátor tečky.

DEFINE
    square  ==  dup * ;
    cube    ==  dup dup * * .

Všimněte si jedné zajímavosti, která dosti podstatným způsobem odlišuje „zásobníkové“ programovací jazyky od zbytku světa a co je současně řadí do škatulky <i>tacit programmingu</i>: v těle funkcí ani v jejich názvu se nikde nevyskytují názvy parametrů, protože se předpokládá, že ty budou uloženy na zásobníku. Není tedy nutné nějakým složitým způsobem nahrazovat formální parametry za parametry skutečné. Má to ještě jednu výhodu – tělo funkce je možné zkopírovat, přenést na příkazový řádek a funkci přímo spustit či jinak testovat bez nutnosti měnit byť jediný znak v těle funkce. Jinými slovy: aplikace funkce přímo v programu (tj. zápis těla funkce) i její definice jsou zcela stejné, čehož lze velmi dobře využít při ladění a testování:

definice nové funkce nazvané xx:
DEFINE
    xx == [1000 >] [2 /] [3 *] ifte
.

použití této funkce:
20 xx .
60
1000 xx .
3000
1001 xx .
500

přímé použití těla funkce:
20 [1000 >] [2 /] [3 *] ifte .
60
1000 [1000 >] [2 /] [3 *] ifte .
3000
1001 [1000 >] [2 /] [3 *] ifte .
500

Následuje klasický příklad funkce vracející maximální hodnotu z dvojice čísel uložených na zásobník. Příklad jsem upravil tak, aby využívat výše zmíněné zásobníkové manipulátory dup, dupd, pop, popd a swapd. Nejprve jsou duplikovány obě hodnoty umístěné na zásobníku, poté jsou porovnány (přičemž se původní hodnoty zahodí, proto je nutná duplikace) a posléze se na základě vyhodnocení porovnání ze zásobníku odstraní menší hodnota a výsledek, tj. hodnota větší, zůstane umístěná na nejvyšším místě zásobníku, protože ten slouží jako odkládací místo pro výsledky funkcí:

definice funkce max
(přepíšeme tím sice původní funkci, to však v této chvíli není na škodu)
DEFINE
    max == [dup swapd dupd >] [pop] [popd] ifte
warning: overwriting inbuilt 'max'
.

test funkce max:
10 20 max .
20
20 10 max .
20
10 10 max .
10
3 1 2 max max .
3
-1 -3 -2 -4 -5 max max max max .
-1 

Ve skutečnosti však lze funkci max napsat i jiným způsobem bez explicitního použití ifte, například následovně:

DEFINE
    max == dup swapd dupd > rotate choice



<p><a name="k04"></a></p>
<h2 id="k04">4. </h2>

(filter odd?)
(map inc)
(take 5)

(def xf
  (comp
    (filter odd?)
    (map inc)
    (take 5)))

(def xf (comp (filter odd?) (map inc)))
(transduce xf + (range 5))
;; => 6
(transduce xf + 100 (range 5))
;; => 106


<p><a name="k05"></a></p>
<h2 id="k05">5. </h2>

(defn build-topology
  "Definice celé pipeliny (kolony) - základ aplikace."
  [builder topic-config]
  (-> (j/kstream builder (:input topic-config))
      (j/peek (fn [[k v]]
                (log/warn "Received message with key:   " k " and value:" v)))
      (j/through (:output-1 topic-config))
      (j/map etl-1)
      (j/peek (fn [[k v]]
                (log/warn "Transformed message with key:" k " and value:" v)))
      (j/through (:output-2 topic-config))
      (j/map etl-2)
      (j/peek (fn [[k v]]
                (log/warn "Transformed message with key:" k " and value:" v)))
      (j/to (:output-3 topic-config)))
  builder)

(defn etl-1
  "Transformační funkce."
  [[k v]]
  [k {:result (+ (:x v) (:y v))}])


(defn etl-2
  "Transformační funkce."
  [[k v]]
  [k (assoc v :timestamp (str (new java.util.Date)))])


(def etl-3
  "Transformační funkce vytvořená ve formě uzávěru."
  (let [counter (atom 0)]
    (fn [[k v]] (do
                  (swap! counter inc) 
                  [k (assoc v :counter @counter)]))))

(defn build-topology
  "Definice celé pipeliny (kolony) - základ aplikace."
  [builder topic-config]
  (-> (j/kstream builder (:input topic-config))
      (j/peek (fn [[k v]]
                (log/warn "Received message with key:   " k " and value:" v)))
      (j/through (:output-1 topic-config))
      (j/map etl-1)
      (j/peek (fn [[k v]]
                (log/warn "Transformed message with key:" k " and value:" v)))
      (j/through (:output-2 topic-config))
      (j/map etl-2)
      (j/peek (fn [[k v]]
                (log/warn "Transformed message with key:" k " and value:" v)))
      (j/through (:output-3 topic-config))
      (j/map etl-3)
      (j/peek (fn [[k v]]
                (log/warn "Transformed message with key:" k " and value:" v)))
      (j/to (:output-4 topic-config)))
  builder)



<p><a name="k06"></a></p>
<h2 id="k06">6. </h2>



<p><a name="k07"></a></p>
<h2 id="k07">7. </h2>



<p><a name="k08"></a></p>
<h2 id="k08">8. </h2>



<p><a name="k09"></a></p>
<h2 id="k09">9. </h2>



<p><a name="k10"></a></p>
<h2 id="k10">10. </h2>



<p><a name="k11"></a></p>
<h2 id="k11">11. </h2>



<p><a name="k12"></a></p>
<h2 id="k12">12. </h2>



<p><a name="k13"></a></p>
<h2 id="k13">13. </h2>



<p><a name="k14"></a></p>
<h2 id="k14">14. </h2>



<p><a name="k15"></a></p>
<h2 id="k15">15. </h2>



<p><a name="k16"></a></p>
<h2 id="k16">16. </h2>



<p><a name="k17"></a></p>
<h2 id="k17">17. </h2>



<p><a name="k18"></a></p>
<h2 id="k18">18. </h2>



<p><a name="k19"></a></p>
<h2 id="k19">19. Repositář s&nbsp;demonstračními příklady</h2>



<p><a name="k20"></a></p>
<h2 id="k20">20. Odkazy na Internetu</h2>

<ol>

<li>Tacit programming (APL Wiki)<br />
<a href="https://aplwiki.com/wiki/Tacit_programming">https://aplwiki.com/wiki/Tacit_programming</a>
</li>

<li>Function trains<br />
<a href="https://mlochbaum.github.io/BQN/doc/train.html">https://mlochbaum.github.io/BQN/doc/train.html</a>
</li>

<li>Tacit programming (Wikipedia)<br />
<a href="https://en.wikipedia.org/wiki/Tacit_programming">https://en.wikipedia.org/wiki/Tacit_programming</a>
</li>

<li>Beyond Functional Programming: Manipulate Functions with the J Language<br />
<a href="https://www.adamtornhill.com/articles/jlang/beyondfunctional.html">https://www.adamtornhill.com/articles/jlang/beyondfunctional.html</a>
</li>

<li>Real World Uses of Tacit Programming: Part 1 of 2<br />
<a href="https://medium.com/@jesterxl/real-world-uses-of-tacit-programming-part-1-of-2-f2a0c3f9e00c">https://medium.com/@jesterxl/real-world-uses-of-tacit-programming-part-1-of-2-f2a0c3f9e00c</a>
</li>

<li>Programovací jazyk Forth a zásobníkové procesory<br />
<a href="http://www.root.cz/clanky/programovaci-jazyk-forth-a-zasobnikove-procesory/">http://www.root.cz/clanky/programovaci-jazyk-forth-a-zasobnikove-procesory/</a>
</li>

<li>Seriál Programovací jazyk Forth<br />
<a href="http://www.root.cz/serialy/programovaci-jazyk-forth/">http://www.root.cz/serialy/programovaci-jazyk-forth/</a>
</li>

<li>Programovací jazyk Factor<br />
<a href="http://www.root.cz/clanky/programovaci-jazyk-factor/">http://www.root.cz/clanky/programovaci-jazyk-factor/</a>
</li>

<li>Grafický metaformát PostScript<br />
<a href="http://www.root.cz/clanky/graficky-metaformat-postscript/">http://www.root.cz/clanky/graficky-metaformat-postscript/</a>
</li>

<li>Programovací jazyk Factor<br />
<a href="https://www.root.cz/clanky/programovaci-jazyk-factor/">https://www.root.cz/clanky/programovaci-jazyk-factor/</a>
</li>

<li>Factor: revoluce v&nbsp;programování nebo propadák?<br />
<a href="https://www.root.cz/clanky/factor-revoluce-v-programovani-nebo-propadak/">https://www.root.cz/clanky/factor-revoluce-v-programovani-nebo-propadak/</a>
</li>

<li>Integrované vývojové prostředí Factoru<br />
<a href="https://www.root.cz/clanky/integrovane-vyvojove-prostredi-factoru/">https://www.root.cz/clanky/integrovane-vyvojove-prostredi-factoru/</a>
</li>

<li>Programujeme ve Factoru<br />
<a href="https://www.root.cz/clanky/programujeme-ve-factoru/">https://www.root.cz/clanky/programujeme-ve-factoru/</a>
</li>

<li>Joy: radost z&nbsp;programování<br />
<a href="https://www.root.cz/clanky/joy-radost-z-programovani/">https://www.root.cz/clanky/joy-radost-z-programovani/</a>
</li>

<li>Joy: programovací jazyk od protinožců<br />
<a href="https://www.root.cz/clanky/joy-programovaci-jazyk-od-protinozcu/">https://www.root.cz/clanky/joy-programovaci-jazyk-od-protinozcu/</a>
</li>

<li>Jazyk Joy a rekurzivní kombinátory<br />
<a href="https://www.root.cz/clanky/jazyk-joy-a-rekurzivni-kombinatory/">https://www.root.cz/clanky/jazyk-joy-a-rekurzivni-kombinatory/</a>
</li>

<li>Point-Free or Die: Tacit Programming in Haskell and Beyond<br />
<a href="https://www.thestrangeloop.com/2016/point-free-or-die-tacit-programming-in-haskell-and-beyond.html">https://www.thestrangeloop.com/2016/point-free-or-die-tacit-programming-in-haskell-and-beyond.html</a>
</li>

<li>Threading macro (dokumentace k&nbsp;jazyku Clojure)<br />
<a href="https://clojure.github.io/clojure/clojure.core-api.html#clojure.core/-&gt;">https://clojure.github.io/clojure/clojure.core-api.html#clojure.core/-&gt;</a>
</li>

<li>Understanding the Clojure -&gt; macro<br />
<a href="http://blog.fogus.me/2009/09/04/understanding-the-clojure-macro/">http://blog.fogus.me/2009/09/04/understanding-the-clojure-macro/</a>
</li>

<li>Transducers<br />
<a href="https://clojure.org/reference/transducers">https://clojure.org/reference/transducers</a>
</li>

<li>dc (computer program)<br />
<a href="https://en.wikipedia.org/wiki/Dc_%28computer_program%29">https://en.wikipedia.org/wiki/Dc_%28computer_program%29</a>
</li>

<li>dc (na Esolang)<br />
<a href="http://esolangs.org/wiki/Dc">http://esolangs.org/wiki/Dc</a>
</li>

</ol>



<p></p><p></p>
<p><small>Autor: <a href="http://www.fit.vutbr.cz/~tisnovpa">Pavel Tišnovský</a> &nbsp; 2021</small></p>
</body>
</html>

