<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
        "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html>
<head>
<title></title>
<meta name="Author" content="Pavel Tisnovsky" />
<meta name="Generator" content="vim" />
<meta http-equiv="content-type" content="text/html; charset=utf-8" />
<style type="text/css">
         body {color:#000000; background:#ffffff;}
         h1  {font-family: arial, helvetica, sans-serif; color:#ffffff; background-color:#c00000; text-align:center; padding-left:1em}
         h2  {font-family: arial, helvetica, sans-serif; color:#ffffff; background-color:#0000c0; padding-left:1em; text-align:left}
         h3  {font-family: arial, helvetica, sans-serif; color:#000000; background-color:#c0c0c0; padding-left:1em; text-align:left}
         h4  {font-family: arial, helvetica, sans-serif; color:#000000; background-color:#e0e0e0; padding-left:1em; text-align:left}
         a   {font-family: arial, helvetica, sans-serif;}
         li  {font-family: arial, helvetica, sans-serif; color:#000000; text-align:justify; width:450px;}
         ol  {font-family: arial, helvetica, sans-serif; color:#000000; text-align:justify; width:450px;}
         ul  {font-family: arial, helvetica, sans-serif; color:#000000; text-align:justify; width:450px;}
         p   {font-family: arial, helvetica, sans-serif; color:#000000; text-align:justify;}
         pre {background:#e0e0e0}
</style>
</head>

<body>

<h1></h1>

<h3>Pavel Tišnovský</h3>

<p></p>

<h1>Úvodník</h1>

<p>Dnes se ve stručnosti seznámíme s programovacím jazykem K. Programy zapsané v tomto jazyce jsou velmi hutné (doslova několik znaků), ovšem mají podobu šumu na lince nebo zprávy poslané mimozemšťany. Zajímavé ovšem je, že i samotné zdrojové kódy K psané v céčku vypadají podobně. Za jejich vznikem stojí Arthur Whitney.</p>



<h2>Obsah</h2>

<p><a href="#k01">1. Programovací jazyk K &ndash; důkaz, že mezi námi žijí mimozemšťané</a></p>
<p><a href="#k02">2. Stručná historie jazyka K</a></p>
<p><a href="#k03">3. Arthur Whitney jakožto osobnost v&nbsp;IT</a></p>
<p><a href="#k04">4. Základní vlastnosti programovacího jazyka K</a></p>
<p><a href="#k05">5. K = vektory + seznamy + operátory + modifikátory + funkce</a></p>
<p><a href="#k06">6. Překlad volně dostupného interpretru programovacího jazyka K</a></p>
<p><a href="#k07">7. První spuštění interaktivní smyčky REPL jazyka K</a></p>
<p><a href="#k08">8. Skalární hodnoty a základní aritmetické operace podporované jazykem K</a></p>
<p><a href="#k09">9. Seznamy a vektory</a></p>
<p><a href="#k10">10. Aritmetické operace s&nbsp;vektory</a></p>
<p><a href="#k11">11. Proměnné a některé složitější operace se skaláry a vektory</a></p>
<p><a href="#k12">12. Konstrukce vektoru algoritmem</a></p>
<p><a href="#k13">13. Převod hodnoty do zvolené číselné soustavy</a></p>
<p><a href="#k14">14. Vyhledávání hodnot ve vektorech</a></p>
<p><a href="#k15">15. Další operace s&nbsp;vektory</a></p>
<p><a href="#k16">16. Modifikátory <strong>over</strong>, <strong>scan</strong> a <strong>each</strong></a></p>
<p><a href="#k17">17. Funkce</a></p>
<p><a href="#k18">18. Náhrada programových smyček pomocí modifikátorů</a></p>
<p><a href="#k19">19. Obsah druhé části článku</a></p>
<p><a href="#k20">20. Odkazy na Internetu</a></p>



<p><a name="k01"></a></p>
<h2 id="k01">1. Programovací jazyk K &ndash; důkaz, že mezi námi žijí mimozemšťané</h2>

<p><i>&bdquo;In C I never learned to use the debugger so I used to never make
mistakes&ldquo;<br />
Arthur Whitney</i></p>

<p>V&nbsp;dnešním článku se budeme zabývat programovacím jazykem, který se
jmenuje <i>K</i>. Jedná se o minimalisticky pojatý programovací jazyk, mezi
jehož ideové předchůdce patří již popsaný <a
href="https://www.root.cz/clanky/oslava-55-let-od-vzniku-prvni-implementace-programovaciho-jazyka-apl/">jazyk
APL</a>, ovšem taktéž <a
href="https://www.root.cz/clanky/jemny-uvod-do-rozsahleho-sveta-jazyku-lisp-a-scheme/">jazyk
Scheme</a>. A výsledek, který vznikl kombinací APL+Scheme, je velmi zajímavý.
Důležité je, že se v&nbsp;žádném případě nejedná jen o akademický jazyk (spíš
naopak &ndash; většinu zastánců IT jakožto vědy existence K spíše irituje).
Tento jazyk je totiž základem nástrojů vyvíjených společností <a
href="https://kx.com/">Kx Systems</a>, především pak velmi rychlé sloupcové
databáze <strong>kdb+</strong> (je tedy zřejmé, kde se vzalo jméno této
společnosti &ndash; ostatně autor jazyka K je současně spoluzakladatel této
firmy). Kx Systems nad kdb+ a jazykem K vyvíjí nástroje pro analýzu trhů,
on-line obchodování (jednalo se o jednu z&nbsp;prvních společností, která tuto
technologii nabízela), nástroje pro telekomunikační průmysl apod.</p>



<p><a name="k02"></a></p>
<h2 id="k02">2. Stručná historie jazyka K</h2>

<p><i>&bdquo;I never comment anything because I'm always trying to make it so
the code itself is the comment.&ldquo;<br />
Arthur Whitney</i></p>

<p>Autorem programovacího jazyka K je <i>Arthur Whitney</i>, což je v&nbsp;IT
možná poněkud méně známá, ale o to zajímavější a kontroverzní osobnost &ndash;
ostatně viz přiložené Arthurovy citáty. Arthur Whitney spolupracoval
s&nbsp;Kenem Iversonem na vývoji programovacího jazyka APL, což paradoxně
původně neměl být programovací jazyk, ale způsob zápisu matematických výrazů a
algoritmů s&nbsp;využitím nové jednotné notace. Arthur Whitney kromě práce na
APL vyvinul i interpret jazyka Scheme a právě znalost Scheme se později
promítla do návrhu jazyka K. Kromě APL vyvinul Arthur Whitney pro společnost
I.P.Sharp Associates i programovací jazyk nazvaný A+, který je jakýmsi
mezikrokem mezi APL a K. A+ je určen především pro zpracování velkého množství
dat, což je vlastnost, která tento jazyk (po 25 letech) opět uvádí na
scénu.</p>

<p>V&nbsp;roce 1993 Arthur Whitney vyvinul programovací jazyk K a poté založil
již <a href="#k01">v&nbsp;úvodu</a> zmíněnou společnost Kx Systems, která
dodnes existuje a zdá se být velmi úspěšná. Nad jazykem K byla vyvinuta
sloupcová databáze kdb+, která je mimochodem &bdquo;loop-free&ldquo;,
tj.&nbsp;v&nbsp;jejím zdrojovém kódu nenajdeme ani jednu explicitně zapsanou
programovou smyčku! Interpret i překladač jazyka K lze ze stránek Kx Systems
získat, ovšem nikoli pod svobodnou licencí. Existují však i jiné varianty
K.</p>



<p><a name="k03"></a></p>
<h2 id="k03">3. Arthur Whitney jakožto osobnost v&nbsp;IT</h2>

<p><i>&bdquo;The K binary weighs in at about 50Kb. Someone asked about the
interpreter source code. A frown flickered across the face of our visitor from
Microsoft: what could be interesting about that? “The source is currently 264
lines of C,” said Arthur. I thought I heard a sotto voce “that’s not possible.”
Arthur showed us how he had arranged his source code in five files so that he
could edit any one of them without scrolling. “Hate scrolling,” he
mumbled.&ldquo;</i></p>

<p>Pokud bychom měli charakterizovat styl, s&nbsp;jakým k&nbsp;vývoji (stále)
přistupuje Arthur Whitney, je to snaha o kombinaci několika základních operací
společně s&nbsp;k&nbsp;tomu vhodnými datovými strukturami tak, aby výsledkem
byl minimalistický kód, a to bez ohledu na čitelnost výsledného kódu nebo jeho
testovatelnost. Ideálním cílem je, aby se kód (jakékoli) aplikace vlezl na
jedinou obrazovku :-) &ndash; viz též motto této kapitoly. Tato snaha je patrná
i při pohledu na úryvky zdrojového kódu samotného interpretru a překladače
jazyka K. Původní Arthurův kód <a
href="https://github.com/tavmem/buddy/blob/master/a/b.c#L5">vypadá
následovně</a> (ono, jedná se o standardní céčko!):</p>

<pre>
#include "k.h"
I MZ[31]={1};Z I *MM[31];mi(){MZ[7]=MZ[13]=MZ[19]=MZ[25]=2;DO(30,MZ[i+1]+=MZ[i]*2)}
Z mmr(n,i){if(i&lt;18)i=18;R err(2,n),tmp((MZ[i]+2)&lt;&lt;2),1;} /* Dan MZ[i+1]? */
C *mab(m)unsigned m;{I *p,*r,i=2,n=m;for(n=(n+3)&gt;&gt;4;n;n&gt;&gt;=1)++i;
 do{if(p=MM[i])R MM[i]=(I*)*p,(C*)p;for(n=i;n&lt;30;)if(p=MM[++n]){
  for(MM[n]=(I*)*p,p[-1]=i;i&lt;n;)r=p+MZ[--n],MM[r[-1]=n]=r,*r=0;R(C*)p;}
  if(mc()&gt;=i)continue;} while(mmr(m,i));}
I *ma(m){R(I*)mab(m&lt;&lt;2);}
mf(p)I *p;{I i=p[-1];*p=(I)MM[i],MM[i]=p;}
mb(p,n)I *p;{I i=31,j;for(n-=2,++p;i--;)if(j=MZ[i],j&lt;=n)n-=j,*p=i,mf(p+1),p+=j;}
mc(){R 0;}
I *mz(){Z I b[31];I *p;DO(31,for(b[i]=0,p=MM[i];p;p=(I*)*p)++b[i])R b;}
</pre>

<p>Naproti tomu po přepisu do &bdquo;lidské&ldquo; podoby vypadá zdrojový kód
<a href="https://github.com/tavmem/buddy/blob/master/a/b.c#L37">takto</a> (je
samozřejmě mnohem delší, ovšem lze ho testovat, krokovat atd.).</p>

<p>Mimochodem, v&nbsp;<a
href="https://docs.google.com/document/d/1W83ME5JecI2hd5hAUqQ1BVF32wtCel8zxb7WPq-D4f8/edit">tomto
dokumentu</a> jsou postupně popsána jednotlivá makra, která jsou použita pro
vytvoření takto kompaktního kódu:</p>

<pre>
#define R return
#define P(b,a...)   if(b)return(a);
#define N(n,a...)   {I i=0,_n=(n);while(i&lt;_n){a;++i;}}
#define W(b...)     while((b))              //while
#define $(b,a...)   if(b){a;}else           //cond
#define C(i,a...)   case i:{a;}break;       //case
#define S(i,c,a...) switch(i){c default:a;} //switch
</pre>

<p><div class="rs-tip-major">Poznámka: mimochodem &ndash; původní myšlenka na
hutný a tím pádem i krátký kód, která vznikla v&nbsp;souvislosti s&nbsp;APL, je
velmi dobrá. Pokud máme například k&nbsp;dispozici obecný modifikátor pro
kombinaci libovolného binárního (dyadického) operátoru a řekněme vektorového
součinu, je už samotný zápis výrazu využívajícího tuto kombinaci dostatečně
idiomatický, že již není zapotřebí mnoha slov pro jeho vysvětlení a není nutné
ho ani testovat &ndash; ostatně stejně tak není nutné testovat, zda pracuje
správně například operátor +. Ovšem právě díky možnosti kombinace dvou či více
operátorů a navíc aplikace těchto operátorů na vektory a matice vzniká kód,
který skutečně vypadá jako zpráva poslaná mimozemšťany.</div></p>



<p><a name="k04"></a></p>
<h2 id="k04">4. Základní vlastnosti programovacího jazyka K</h2>

<p><i>&bdquo;Ken believed that notation should be as high level as possible
because, for example, if matrix product is plus-dot-times, there's no question
about that being correct.&ldquo;<br />
Arthur Whitney</i></p>

<p>Arthur Whitney navrhl jazyk K tak, že do něj vybral esenci z&nbsp;jazyků APL
a Scheme. Ovšem výsledkem není jakýsi kočkopes, jak by se mohlo zdát, ale
unikátní minimalisticky navržený programovací jazyk. Většina základních
operátorů je reprezentována jedním či dvěma ASCII znaky, a díky kompaktnímu
zápisu vypadá zdrojový kód K jako šum na lince (což není chyba, ale vlastnost,
kterou přiznávají i skalní příznivci jazyka K). V&nbsp;programech se typicky
pracuje s&nbsp;vektory a zcela jsou omezeny smyčky a do značné míry i
podmínky.</p>

<p>Do jaké míry je K kompaktní a (zdánlivě) nečitelný, dokazuje asi nejlépe
implementace plnohodnotného raytraceru na pouhých sedmi řádcích kódu (zbytek
jsou prázdné řádky a komentáře). Ostatně posuďte sami na <a
href="http://www.nsl.com/k/ray/ray.k">http://www.nsl.com/k/ray/ray.k</a>.</p>



<p><a name="k05"></a></p>
<h2 id="k05">5. K = vektory + seznamy + operátory + modifikátory + funkce</h2>

<p><i>&bdquo;What happened with A+?<br />
Within a month or two we were using it to analyze our historical data. A few
months later we used it to implement the trading system which bought and sold
$100 million worth of shares every day&ldquo;<br />
Arthur Whitney</i></p>

<p>Jazyk K je z&nbsp;velké míry postaven nad datovou strukturou <i>seznam</i>;
zde je vidět inspirace v&nbsp;jazyku Scheme. Seznamy jsou heterogenní datové
struktury, ovšem v&nbsp;případě, že jsou všechny prvky stejného typu, dojde
k&nbsp;uložení seznamů velmi efektivním způsobem &ndash; typ prvku se uloží jen
pro celý seznam a mezi prvky nejsou výplně. Výsledku pak říkáme <i>vektor</i>.
Z&nbsp;vektorů lze skládat vícerozměrné matice, i když se ve většině případů
pracuje &bdquo;pouze&ldquo; s&nbsp;dvourozměrnými a trojrozměrnými maticemi
(poli). V&nbsp;jazyku K nalezneme taktéž možnost definice uživatelských funkcí,
přičemž funkce jsou plnohodnotným datovým typem &ndash; opět podobně jako ve
Scheme.</p>

<p>Podobně jako v&nbsp;případě programovacího jazyka APL či od něj odvozeného
jazyka J, obsahuje i programovací jazyk K velké množství primitivních
(základních) operátorů. Ty však nejsou reprezentovány speciálními symboly, ale
jedním nebo více nealfanumerickými ASCII znaky, takže jejich zápis i editace je
jednodušší, než tomu bylo v&nbsp;případě APL (na druhou stranu nevypadají
zapsané algoritmy tak efektně :-). Vestavěné operátory mohou akceptovat buď
jeden parametr (monadické operátory) nebo parametry dva (operátory dyadické).
Symbol monadických operátorů je uveden v&nbsp;prefixové podobě, tj.&nbsp;vždy
před svým parametrem, zatímco dyadické operátory jsou zapisovány v&nbsp;podobě
infixové &ndash; mezi oba parametry (operandy), čímž se efektivně v&nbsp;mnoha
případech eliminuje nutnost použití závorek. Znaky, kterými jsou vestavěné
operátory ve zdrojovém kódu reprezentovány, jsou většinou použity minimálně
dvakrát &ndash; jednou pro zápis monadického operátoru, podruhé pro zápis
operátoru dyadického, jehož význam bývá v&nbsp;menší či větší míře podobný
příslušnému operátoru monadickému.</p>

<p><div class="rs-tip-major">Poznámka: z&nbsp;toho plyne, že všechny operátory
mají shodnou prioritu.</div></p>



<p><a name="k06"></a></p>
<h2 id="k06">6. Překlad volně dostupného interpretru programovacího jazyka K</h2>

<p><i>&bdquo;We had a portfolio that was a billion dollars: half a billion
long, half a billion short. We were trading every second electronically. The
data set was a terabyte, but we compressed it down. It was pairs trading, and I
wrote an APL to do all of that—the big database and the realtime trading—so our
entire department was using my language.&ldquo;<br />
Arthur Whitney</i></p>

<p>Oficiální interpret a současně i překladač programovacího jazyka <i>K</i> je
možné, společně s&nbsp;mnoha dalšími nástroji (i databází), získat na stránce
<a
href="https://kx.com/developers/download-licenses/">https://kx.com/developers/download-licenses/</a>.
My však, už jen proto, že se nacházíme na stránkách Roota, použijeme odlišnou
variantu jazyka K, která je distribuována se zdrojovými kódy a pod pro vývojáře
<a href="https://github.com/kevinlawler/kona/blob/master/LICENSE">příjemnější
licencí</a>. Tato varianta je dostupná na GitHubu (<a
href="https://github.com/kevinlawler/kona">https://github.com/kevinlawler/kona</a>)
a pro její zprovoznění je zapotřebí pouze překladač programovacího jazyka C (a
pochopitelně celý ekosystém postavený okolo tohoto překladače).</p>

<p>Nejprve je pochopitelně nutné repositář se zdrojovými kódy jazyka K
naklonovat do pracovního adresáře:</p>

<pre>
$ <strong>git clone git@github.com:kevinlawler/kona.git</strong>
&nbsp;
Cloning into 'kona'...
remote: Enumerating objects: 6516, done.
remote: Counting objects: 100% (215/215), done.
remote: Compressing objects: 100% (84/84), done.
remote: Total 6516 (delta 136), reused 204 (delta 131), pack-reused 6301
Receiving objects: 100% (6516/6516), 2.49 MiB | 691.00 KiB/s, done.
Resolving deltas: 100% (4696/4696), done.
</pre>

<p>Následně se přesuneme do vytvořeného adresáře:</p>

<pre>
$ <strong>cd cona</strong>
</pre>

<p>A použijeme standardní <strong>make</strong> pro překlad a slinkování
interpretru:</p>

<pre>
$ <strong>make</strong>
&nbsp;
OS="linux"
echo "#define KBUILD_DATE \"`date +%Y-%m-%d`\"" &gt;src/kbuild.h
cc -g -pthread -O3    -c -o src/0.o src/0.c
cc -g -pthread -O3    -c -o src/bswap.o src/bswap.c
cc -g -pthread -O3    -c -o src/c.o src/c.c
cc -g -pthread -O3    -c -o src/getline.o src/getline.c
cc -g -pthread -O3    -c -o src/mt.o src/mt.c
cc -g -pthread -O3    -c -o src/p.o src/p.c
cc -g -pthread -O3    -c -o src/r.o src/r.c
cc -g -pthread -O3    -c -o src/k.o src/k.c
cc -g -pthread -O3    -c -o src/kc.o src/kc.c
cc -g -pthread -O3    -c -o src/kx.o src/kx.c
...
...
...
cc -g -pthread -O3    -c -o src/vf.o src/vf.c
cc -g -pthread -O3    -c -o src/vg.o src/vg.c
cc -g -pthread -O3    -c -o src/vq.o src/vq.c
cc -g -pthread -O3    -c -o src/main.o src/main.c
cc -g -pthread -O3  src/0.o src/bswap.o src/c.o src/getline.o src/mt.o src/p.o src/r.o src/k.o src/kc.o src/kx.o src/kg.o src/km.o src/kn.o src/ko.o src/ks.o src/v.o src/va.o src/vc.o src/vd.o src/vf.o src/vg.o src/vq.o src/main.o -o k -lm -ldl
cc -g -pthread -O0 -g3 -DDEBUG -Wall -c  -o src/0.t.o src/0.c
cc -g -pthread -O0 -g3 -DDEBUG -Wall -c  -o src/bswap.t.o src/bswap.c
cc -g -pthread -O0 -g3 -DDEBUG -Wall -c  -o src/c.t.o src/c.c
cc -g -pthread -O0 -g3 -DDEBUG -Wall -c  -o src/getline.t.o src/getline.c
cc -g -pthread -O0 -g3 -DDEBUG -Wall -c  -o src/mt.t.o src/mt.c
cc -g -pthread -O0 -g3 -DDEBUG -Wall -c  -o src/p.t.o src/p.c
cc -g -pthread -O0 -g3 -DDEBUG -Wall -c  -o src/r.t.o src/r.c
...
...
...
cc -g -pthread -O0 -g3 -DDEBUG -Wall -c  -o src/tests.t.o src/tests.c
cc -g -pthread -O0 -g3 -DDEBUG -Wall src/0.t.o src/bswap.t.o src/c.t.o src/getline.t.o src/mt.t.o src/p.t.o src/r.t.o src/k.t.o src/kc.t.o src/kx.t.o src/kg.t.o src/km.t.o src/kn.t.o src/ko.t.o src/ks.t.o src/v.t.o src/va.t.o src/vc.t.o src/vd.t.o src/vf.t.o src/vg.t.o src/vq.t.o src/main.t.o src/tests.t.o -o k_test -lm -ldl
</pre>

<p>Výsledkem překladu by měl být spustitelný soubor <strong>k</strong> a taktéž
<strong>k_test</strong>:</p>

<pre>
$ <strong>ls -l</strong>
&nbsp;
total 2912
drwxrwxr-x 2 ptisnovs ptisnovs     120 Jul 18 17:02 bench
-rwxrwxr-x 1 ptisnovs ptisnovs <strong>1625848 Jul 18 17:03 k</strong>
-rw-rw-r-- 1 ptisnovs ptisnovs  156102 Jul 18 17:02 Kona.png
-rwxrwxr-x 1 ptisnovs ptisnovs <strong>1171664 Jul 18 17:03 k_test</strong>
-rw-rw-r-- 1 ptisnovs ptisnovs     772 Jul 18 17:02 LICENSE
-rw-rw-r-- 1 ptisnovs ptisnovs    6756 Jul 18 17:02 Makefile
drwxrwxr-x 2 ptisnovs ptisnovs     120 Jul 18 17:02 misc
-rw-rw-r-- 1 ptisnovs ptisnovs    4482 Jul 18 17:02 README.md
drwxrwxr-x 3 ptisnovs ptisnovs    2180 Jul 18 17:03 src
drwxrwxr-x 2 ptisnovs ptisnovs     100 Jul 18 17:02 verb
</pre>

<p>V&nbsp;předchozích kapitolách jsme si řekli, že K je poměrně malý jazyk,
čemuž ale neodpovídá velikost výsledného binárního souboru. Podle mých kritérií
se musí &bdquo;malý&ldquo; jazyk vejít na disketu :-) Takže zkusme:</p>

<pre>
$ <strong>strip k</strong>
</pre>

<p>Výsledkem je skutečně soubor, který se vejde i na disketu s&nbsp;formátem
double density:</p>

<pre>
$ <strong>ls -l k</strong>
&nbsp;
-rwxrwxr-x 1 ptisnovs ptisnovs 341712 Jul 18 17:11 k
</pre>

<p>Takto upravený interpret použijeme v&nbsp;navazujících kapitolách při popisu
různých vlastností programovacího jazyka K.</p>

<p>Interpret jazyka K není slinkován s&nbsp;knihovnami typu <i>readline</i>.
Proč je to však tak důležité, že se o tom explicitně zmiňujeme? Nepodpora
<i>readline</i>, mj.&nbsp;znamená, že neexistuje historie příkazového řádku,
není možné používat editační příkazy typu <strong>Ctrl+A</strong>,
<strong>Ctrl+E</strong>, ani vyhledávání v&nbsp;dříve zadaných příkazech pomocí
<strong>Ctrl+R</strong> atd. A navíc nefunguje automatické doplňování jmen
symbolů klávesou <strong>Tab</strong>. Tyto vlastnosti, které dnes od REPLů
prakticky automaticky očekáváme, je možné do jisté míry doplnit externím
nástrojem <strong>rlwrap</strong>. Tomu můžeme v&nbsp;případě potřeby předat
soubor se symboly pro automatické doplňování. Nástroj <strong>rlwrap</strong>
se instaluje snadno:</p>

<pre>
$ <strong>dnf install rlwrap</strong>
&nbsp;
Last metadata expiration check: 0:33:16 ago on Sat 09 Apr 2022 06:45:42 AM EDT.
Dependencies resolved.
================================================================================
 Package              Arch        Version              Repository          Size
================================================================================
Installing:
 rlwrap               x86_64      0.45.2-1.fc34        updates            132 k
Installing dependencies:
 perl-File-Slurp      noarch      9999.32-3.fc34       beaker-Fedora       31 k
 perl-lib             x86_64      0.65-477.fc34        updates             25 k
&nbsp;
Transaction Summary
================================================================================
Install  3 Packages
&nbsp;
Total download size: 188 k
Installed size: 399 k
Is this ok [y/N]: y
Downloading Packages:
(1/3): perl-File-Slurp-9999.32-3.fc34.noarch.rp 3.6 MB/s |  31 kB     00:00    
(2/3): perl-lib-0.65-477.fc34.x86_64.rpm        197 kB/s |  25 kB     00:00    
(3/3): rlwrap-0.45.2-1.fc34.x86_64.rpm          649 kB/s | 132 kB     00:00    
--------------------------------------------------------------------------------
Total                                           142 kB/s | 188 kB     00:01     
</pre>



<p><a name="k07"></a></p>
<h2 id="k07">7. První spuštění interaktivní smyčky REPL jazyka K</h2>

<p><i>&bdquo;You like short programs and simple languages, some might say your
languages are cryptic. Terse, yes. Cryptic, no. I like to simplify things:
shorter programs, fewer primitives, smaller systems to run on, all of which
makes for more productive, more cost-efficient programming.&ldquo;</i></p>

<p>Interpret programovacího jazyka K spustíme příkazem <strong>k</strong> bez
uvedení dalších parametrů:</p>

<pre>
$ <strong>./k </strong>
</pre>

<p>Popř.&nbsp;můžeme volání interpretru &bdquo;obalit&ldquo; nástrojem
<strong>rlwrap</strong>, který zajistí historii příkazového řádku, vyhledávání
v&nbsp;historii, editaci příkazového řádku atd.:</p>

<pre>
$ <strong>rlwrap ./k </strong>
</pre>

<p>Měla by se zobrazit jednořádková úvodní zpráva následovaná výzvou
(<i>prompt</i>):</p>

<pre>
kona      \ for help. \\ to exit.
&nbsp;
</pre>

<p>Příkazem \ si zkusíme zobrazit nápovědu. Ta je opět velmi stručná:</p>

<pre>
Backslash Commands:
\0        datatypes help
\+        verb help
\'        adverb help
\:        I/O verb help
\_        reserved word help
\.        assignment/amend, function, control flow help
\b [s|t]  show/set break mode (stop|trace|none)
\d [d|^]  change k directory (^=previous)
\e [n]    show/set error flag (0=off,1=on,2=exit)
\l f      load script f or f.k
\p [n]    show/set print precision (0=full)
\r [s]    show/set random seed (0=random)
\s f      step script f or f.k
\t [n]    show/set timer interval in msec (0=disable)
          calls niladic .m.ts
\t e      measure runtime of some k expression
\v [d|^]  show k directory (^=previous)
\w        show workspace resources used
\[cmd]    system command (also \[ cmd]), \echo hello
\\        exit (or ctrl+d)
</pre>

<p><div class="rs-tip-major">Poznámka: samotná výzva (<i>prompt</i>) není, na
rozdíl od mnoha dalších variant interaktivní smyčky REPL, představována nějakým
speciálním znakem. Poznáme ji pouze podle toho, že se kurzor nachází na třetím
sloupci, nikoli na sloupci prvním.</div></p>

<p>Samotný komentář se zapisuje za znak /, tedy například takto:</p>

<pre>
  / toto je komentář
</pre>



<p><a name="k08"></a></p>
<h2 id="k08">8. Skalární hodnoty a základní aritmetické operace podporované jazykem K</h2>

<p>Mezi skalární hodnoty podporované programovacím jazykem K patří především
celá čísla, čísla s&nbsp;plovoucí řádovou čárkou, znaky a symboly. Nejvíce
operací se pochopitelně provádí s&nbsp;celými čísly popř.&nbsp;s&nbsp;čísly
s&nbsp;plovoucí řádovou čárkou. Ukažme si tedy základní aritmetické operace
popř.&nbsp;některé funkce používané při numerických výpočtech. Základní
aritmetické operace se zapisují v&nbsp;infixové podobě:</p>

<pre>
  <strong>1+2</strong>
3
&nbsp;
  <strong>2*3</strong>
6
&nbsp;
  <strong>4-5</strong>
-1
</pre>

<p>Dělení se ovšem zapisuje znakem %, protože je to znak bližší skutečnému
symbolu dělení ÷ navíc je znak / již rezervován pro zápis komentářů (jak již
ostatně víme):</p>

<pre>
  <strong>6%3</strong>
2
</pre>

<p>Některé operátory mají význam i v&nbsp;monadickém režimu, tedy při použití
jediného operátoru. Jedná se o změnu znaménka a výpočet převrácené hodnoty:</p>

<pre>
  <strong>-42</strong>
42
&nbsp;
  <strong>%2</strong>
0.5
</pre>

<p>Pozor ovšem na to, že operátory jsou vyhodnocovány <i>zprava doleva</i>
(jako je tomu v&nbsp;jazyce APL) a nemají stanoveny žádné priority, přesněji
řečeno priority všech operátorů jsou totožné a záleží jen na jejich pořadí:</p>

<pre>
  <strong>1+2*3</strong>
7
&nbsp;
  <strong>3*2+1</strong>
9
</pre>

<p>Pro stanovení priorit můžeme použít závorky:</p>

<pre>
  <strong>(3*2)+1</strong>
7
</pre>

<p>Výpočet druhé mocniny a odmocniny je realizován funkcemi, které začínají
podtržítkem:</p>

<pre>
  _<strong>sqr 2</strong>
4.0
&nbsp;
  _<strong>sqrt 2</strong>
1.414214
</pre>

<p>Zajímavé jsou operátory | a &amp;, které zdánlivě slouží k&nbsp;výpočtu
logické operace &bdquo;nebo&ldquo; a &bdquo;a&ldquo;:</p>

<pre>
  <strong>1|0</strong>
1
&nbsp;
  <strong>1&amp;0</strong>
0
</pre>

<p>To je sice pravda, ovšem když se nad významem těchto operátorů zamyslíme
více, zjistíme, že mohou sloužit i pro nalezení největší a nejmenší
hodnoty:</p>

<pre>
  <strong>123|456</strong>
456
&nbsp;
  <strong>123&amp;456</strong>
123
</pre>

<p><div class="rs-tip-major">Poznámka: jedná se o velmi elegantní způsob, jak
operátory | a &amp; použít nejenom v&nbsp;&bdquo;céčkovském&ldquo; významu, ale
i v&nbsp;obecnějším pojetí.</div></p>

<p>K&nbsp;dispozici je i velké množství dalších často používaných funkcí:</p>

<pre>
  <strong>_exp 1</strong>
2.718282
&nbsp;
  <strong>_exp 2</strong>
7.389056
&nbsp;
  <strong>_log 10</strong>
2.302585
&nbsp;
  <strong>2^10</strong>
1024.0
</pre>



<p><a name="k09"></a></p>
<h2 id="k09">9. Seznamy a vektory</h2>

<p><i>&bdquo;OAG database of flight schedules: OAG published the data, but it
had never been automated and placed in a database. In 1980, OAG started
providing IP Sharp with the data on tape, and I loaded the tapes into a
database and made it available for OLAP-style queries. OAG was big even
then--two billion scheduled flights over many years. As far as I know, the
database has been in continual 24/7 use since 1980&ldquo;</i></p>

<p>Kromě <i>skalárních hodnot</i> (celá čísla, čísla s&nbsp;plovoucí řádovou
čárkou, znaky, symboly) podporuje programovací jazyk K i práci se
<i>seznamy</i> (ve speciálním případě s&nbsp;<i>vektory</i>). Seznamy se
konstruují jednoduše &ndash; postačuje všechny prvky zapsat do kulatých závorek
(zde je patrná inspirace programovacím jazykem Scheme), přičemž se jednotlivé
prvky oddělují pomocí středníků. V&nbsp;případě, že jsou všechny prvky stejného
typu (celé číslo, číslo s&nbsp;plovoucí řádovou čárkou, znak), bude seznam
uložen ve speciálním formátu, v&nbsp;němž se typ všech prvků uloží jen
jedenkrát jako vlastnost celého seznamu. Tento velmi úsporný formát uložení
nazýváme <i>vektor</i> (a jedná se o typ, který má jazyk K prakticky totožný
s&nbsp;jazykem APL):</p>

<pre>
  <strong>(1;2;3;4;5)</strong>
1 2 3 4 5
</pre>

<p>Ve skutečnosti je možné vektory zapisovat ještě jednodušeji než seznamy
&ndash; pouze vedle sebe zapíšeme hodnoty prvků oddělené mezerami:</p>

<pre>
  <strong>1 2 3 4 5</strong>
1 2 3 4 5
</pre>

<p>Totéž platí pro seznamy (a posléze) vektory s&nbsp;čísly s&nbsp;plovoucí
řádovou čárkou:</p>

<pre>
  <strong>(1.2;3.4;5.6)</strong>
1.2 3.4 5.6
</pre>

<p>popř.&nbsp;jen:</p>

<pre>
  <strong>1.2 3.4 5.6</strong>
1.2 3.4 5.6
</pre>

<p>Seznamy, jehož prvky jsou rozdílného typu, jsou stále ukládány
v&nbsp;heterogenní podobě (a tedy značně neefektivně, což nám ovšem nemusí
v&nbsp;mnoha případech vadit):</p>

<pre>
  <strong>(1.2;3;0)</strong>
(1.2;3;0)
</pre>

<p>I když to tak nemusí na první pohled vypadat, je i řetězec vlastně vektorem,
a to pochopitelně vektorem znaků:</p>

<pre>
  <strong>"foobarbaz"</strong>
"foobarbaz"
</pre>

<p><div class="rs-tip-major">Poznámka: to znamená, že mnoho operátorů a funkcí
popsaných níže lze aplikovat i na řetězce.</div></p>

<p>Seznamy či vektory lze spojit operátorem čárka:</p>

<pre>
  <strong>1 2 3 , 4 5 6</strong>
1 2 3 4 5 6
</pre>

<p>Tento operátor se opět vyhodnocuje zprava doleva:</p>

<pre>
  <strong>1 2 3 , 4 5 6 , 7 8 9</strong>
1 2 3 4 5 6 7 8 9
</pre>

<p><div class="rs-tip-major">Poznámka: tato operace více vynikne ve chvíli, kdy
se bude pracovat s&nbsp;proměnnými a nikoli pouze přímo
s&nbsp;hodnotami.</div></p>



<p><a name="k10"></a></p>
<h2 id="k10">10. Aritmetické operace s&nbsp;vektory</h2>

<p>Všechny aritmetické operace popsané <a href="#k08">v&nbsp;osmé kapitole</a>,
jsou plně aplikovatelné i na vektory popř.&nbsp;na kombinaci skalární hodnoty a
vektoru. Opět se podívejme na několik příkladů.</p>

<p>Součet skaláru s&nbsp;vektorem se provádí prvek po prvku:</p>

<pre>
  <strong>1 + 2 3 4</strong>
3 4 5
</pre>

<p>Možná je i druhá kombinace, tedy součet vektoru se skalární hodnotou:</p>

<pre>
  <strong>10 20 30 + 5</strong>
15 25 35
</pre>

<p>Sečíst můžeme i dva vektory:</p>

<pre>
  <strong>1 2 3 + 4 5 6 </strong>
5 7 9
</pre>

<p><div class="rs-tip-major">Poznámka: povšimněte si, že operátor má nižší
prioritu než &bdquo;konstruktor vektoru&ldquo;.</div></p>

<p>V&nbsp;případě, že se provádí součet vektorů (prvek po prvku), musí mít oba
vektory stejnou délku &ndash; K v&nbsp;tomto případě se tedy neprovádí
tzv.&nbsp;<i>broadcasting</i>:</p>

<pre>
  <strong>1 2 3 + 4 5 6 7</strong>
length error
1 2 3 + 4 5 6 7
      ^
</pre>

<p>V&nbsp;souvislosti s&nbsp;vektory můžeme použít i unární operace, například
operaci <strong>-</strong> pro změnu znaménka všech prvků vektoru:</p>

<pre>
  <strong>- 1 2 3</strong>
-1 -2 -3
</pre>

<p>Všechny funkce popsané výše v&nbsp;souvislosti se skalárními číselnými
hodnotami jsou použitelné i na prvky vektorů. To se týká i výpočtů druhé
mocniny i odmocniny:</p>

<pre>
  _<strong>sqr 1 2 3 4</strong>
1 4 9 16.0
&nbsp;
  _<strong>sqrt 1 2 3 4</strong>
1 1.414214 1.732051 2.0
</pre>

<p>Operátor # v&nbsp;monadické formě vrací délku vektoru:</p>

<pre>
  <strong>#1 2 3 4 5 0</strong>
6
</pre>



<p><a name="k11"></a></p>
<h2 id="k11">11. Proměnné a některé složitější operace se skaláry a vektory</h2>

<p>Proměnné se v&nbsp;jazyku K nemusí deklarovat, protože proměnná je vytvořena
při prvním přiřazení hodnoty:</p>

<pre>
  <strong>x:1</strong>
  <strong>y:2</strong>
</pre>

<p><div class="rs-tip-major">Poznámka: přiřazení je jedna z&nbsp;mála operací,
která nevypisuje svůj výsledek na terminál. Pokud si přejeme vypsat hodnotu
přiřazenou do proměnné, je nutné zapsat dvojtečku i na začátek celého
výrazu:</div></p>

<pre>
  <strong>:x:1+2</strong>
3
&nbsp;
  <strong>:y:x*x</strong>
9
</pre>

<p>Operace s&nbsp;proměnnými:</p>

<pre>
  <strong>x+y</strong>
3
</pre>

<p>V&nbsp;dalších demonstračních příkladech použijeme dvě proměnné
<strong>x</strong> a <strong>y</strong>, z&nbsp;nichž každá bude obsahovat
čtyřprvkový vektor:</p>

<pre>
  <strong>x:1 2 3 4</strong>
  <strong>y:10 20 30 40</strong>
</pre>

<p>Na prvky vektoru lze aplikovat všechny běžné aritmetické operace (jak
monadické, tak i dyadické):</p>

<pre>
  <strong>-x</strong>
-1 -2 -3 -4
&nbsp;
  <strong>x+y</strong>
11 22 33 44
&nbsp;
  <strong>y%x</strong>
10 10 10 10
&nbsp;
  <strong>_sqr x</strong>
1 4 9 16.0
&nbsp;
  <strong>_sqrt y</strong>
3.162278 4.472136 5.477226 6.324555
&nbsp;
  <strong>%x</strong>
1 0.5 0.3333333 0.25
</pre>

<p>Operace | a &amp; postupně projdou dva vektory a vyhledají největší
resp.&nbsp;naopak nejmenší prvek z&nbsp;dané dvojice (!10 vytvoří vektor 0 1 2
3 4 5 6 7 8 9):</p>

<pre>
  <strong>x | !10</strong>
9 6 9 3 4 5 6 7 8 9
&nbsp;
  <strong>x &amp; !10</strong>
0 1 2 3 3 0 4 5 4 7
</pre>

<p><div class="rs-tip-major">Poznámka: opět platí, že prakticky všechny mezery
jsou ignorovány a nemají pro interpret programovacího jazyka K žádný význam.
Stejně dobře tedy můžeme psát:</div></p>

<pre>
  <strong>x|!10 </strong>
&nbsp;
9 6 9 3 4 5 6 7 8 9
&nbsp;
  <strong>x&amp;!10</strong>
0 1 2 3 3 0 4 5 4 7
</pre>



<p><a name="k12"></a></p>
<h2 id="k12">12. Konstrukce vektoru algoritmem</h2>

<p><i>&bdquo;About two years ago I was introduced to a programming language that I really didn't like: it didn't have continuations, I didn't see any objects, it had too many operators, it didn't have a large community around it, it was strange and different, and it looked like line noise, like Perl, and I don't like Perl. However, I gave it a try.<br />
I had to learn that continuations may not be there, but first-class functions are; it may not have a normal object system, but that is because the language doesn't need it and gets it power by cutting across objects; all the operators are the functions that make up its standard library; it's community may not be large, but it is incredibly intelligent; it only looks strange until you understand its concepts; and well, it will always look like line noise, but you will stop caring because this also make the concise code easier to read. K has since become my language of choice.&ldquo;</i></p>

<p>Vektory lze zkonstruovat i na základě několika vestavěných algoritmů.
Příkladem může být vektor obsahující sekvenci hodnot od 0 do zadaného limitu
(kromě), tedy vzdálená obdoba generátoru <strong>range</strong>
z&nbsp;Pythonu:</p>

<pre>
  <strong>!10</strong>
0 1 2 3 4 5 6 7 8 9
</pre>

<p>Při potřebě začínat od hodnoty odlišné od nuly můžeme použít součet skaláru
s&nbsp;vektorem:</p>

<pre>
  <strong>1+!10</strong>
1 2 3 4 5 6 7 8 9 10
</pre>

<p>Vytvoření vektoru n zvolených hodnot:</p>

<pre>
  <strong>10#0</strong>
0 0 0 0 0 0 0 0 0 0
</pre>

<p>Vytvoření vektoru z&nbsp;opakujících se hodnot:</p>

<pre>
  <strong>10#1 2 3</strong>
1 2 3 1 2 3 1 2 3 1
</pre>

<p>Kombinace obou možností:</p>

<pre>
  <strong>20#!4</strong>
0 1 2 3 0 1 2 3 0 1 2 3 0 1 2 3 0 1 2 3
</pre>

<p>Výběr tří libovolných hodnot od 0 do 10 (kromě):</p>

<pre>
  <strong>3 _draw 10</strong>
2 7 8
</pre>

<p>Výběr deseti libovolných hodnot od 0 do 2 (kromě):</p>

<pre>
  <strong>10 _draw 2</strong>
0 1 0 0 0 0 1 1 1 1
</pre>

<p>Zde můžeme získat prvky se stejnou hodnotou:</p>

<pre>
  <strong>5 _draw 5</strong>
2 0 4 4 1
</pre>

<p>Zadáním záporného rozsahu zajistíme, že se prvky nebudou opakovat:</p>

<pre>
  <strong>5 _draw -5</strong>
4 0 2 3 1
</pre>

<p>Matice 2&times;3:</p>

<pre>
  <strong>2 3 _draw 6</strong>
(4 4 5
 4 5 3)
&nbsp;
  2 3 _draw -6
(1 3 5
 0 2 4)
</pre>

<p>Zamíchání 52 žolíkovými kartami s&nbsp;jejich rozdělením do čtyř hromádek po
třinácti kartách:</p>

<pre>
  <strong>4 13_draw-52</strong>
(31 29 21 12 20 10 4 15 39 2 38 49 27
 17 25 18 5 11 9 3 28 41 35 48 26 13
 8 22 19 40 51 44 0 33 24 43 6 7 46
 42 50 45 1 32 16 23 34 36 30 37 14 47)
</pre>



<p><a name="k13"></a></p>
<h2 id="k13">13. Převod hodnoty do zvolené číselné soustavy</h2>

<p>Pravděpodobně unikátní operací, kterou je možné v&nbsp;jazyku K provést, je
převod hodnoty do zvolené číselné soustavy, ovšem takovým způsobem že se vrátí
vektor s&nbsp;jednotlivými ciframi. Podívejme se na příklady použití.</p>

<p>Převod do binární soustavy:</p>

<pre>
  <strong>2_vs 255</strong>
1 1 1 1 1 1 1 1
&nbsp;
  <strong>2_vs 1000</strong>
1 1 1 1 1 0 1 0 0 0
</pre>

<p>Převod do šestnáctkové a dvanáctkové soustavy:</p>

<pre>
  <strong>16_vs 255</strong>
15 15
&nbsp;
  <strong>12_vs 1000</strong>
6 11 4
</pre>

<p>Převod hodnot od 0 do 9 do dvojkové soustavy &ndash; vrátí se seznam seznamů
(nikoli ovšem matice, protože každý řádek má odlišnou délku):</p>

<pre>
  <strong>2_vs !10</strong>
(!0
 ,1
 1 0
 1 1
 1 0 0
 1 0 1
 1 1 0
 1 1 1
 1 0 0 0
 1 0 0 1)
</pre>



<p><a name="k14"></a></p>
<h2 id="k14">14. Vyhledávání hodnot ve vektorech</h2>

<p>Programovací jazyk K nabízí programátorům hned několik operátorů určených
pro vyhledávání prvků ve vektorech. Tyto operátory si postupně popíšeme;
nejdříve si však necháme vytvořit desetiprvkový vektor s&nbsp;vyplněnými
náhodnými hodnotami, s&nbsp;nímž budeme provádět všechny další operace:</p>

<pre>
  <strong>x:10 _draw 10    </strong>
  <strong>x</strong>
9 6 9 3 3 0 4 5 4 7
</pre>

<p>Vyhledáme index prvního prvku s&nbsp;hodnotou 6 (indexuje se od nuly):</p>

<pre>
  <strong>x?6</strong>
1
</pre>

<p>Vyhledáme nulový prvek:</p>

<pre>
  <strong>x?0</strong>
5
</pre>

<p>Pokud vyhledávaný prvek neexistuje, vrátí se délka vektoru (což je index
neexistujícího prvku). Tento drobný trik umožňuje zjednodušit některé
algoritmy:</p>

<pre>
  <strong>x?10</strong>
10
&nbsp;
  <strong>x?-1</strong>
10
</pre>

<p>Vyhledání unikátních hodnot ve vektoru &ndash; zde se použije monadická
forma operátoru ?:</p>

<pre>
  <strong>?x</strong>
9 6 3 0 4 5 7
</pre>

<p>Maska s&nbsp;prvky nastavenými na jedničku tam, kde prvek původního vektoru
odpovídá zapsané podmínce:</p>

<pre>
  <strong>9=x</strong>
1 0 1 0 0 0 0 0 0 0
&nbsp;
  <strong>6=x</strong>
0 1 0 0 0 0 0 0 0 0
&nbsp;
  <strong>x&gt;5</strong>
1 1 1 0 0 0 0 0 0 1
&nbsp;
  <strong>x&lt;5</strong>
0 0 0 1 1 1 1 0 1 0
</pre>

<p>Získání informací, kolikrát a na jaké pozici se prvek opakuje:</p>

<pre>
  <strong>=x</strong>
(0 2
 ,1
 3 4
 ,5
 6 8
 ,7
 ,9)
</pre>

<p>Příklad: 0 2 na prvním řádku seznamu znamená, že prvek se opakuje na 0 a 2
pozici (jeho hodnotu zjistíme indexováním).</p>

<p>Získání indexů prvků odpovídajících podmínce:</p>

<pre>
  <strong>&amp;x&gt;5</strong>
0 1 2 9
&nbsp;
  <strong>&amp;x&lt;5</strong>
3 4 5 6 8
</pre>



<p><a name="k15"></a></p>
<h2 id="k15">15. Další operace s&nbsp;vektory</h2>

<p>Protože vektory (resp.&nbsp;přesněji řečeno seznamy, ovšem v&nbsp;praxi se
typicky jedná hlavně o vektory) jsou základním složeným datovým typem
programovacího jazyka K, existuje přímo v&nbsp;základní verzi tohoto jazyka
(tj.&nbsp;bez nutnost použití externích knihoven) velké množství dalších funkcí
a operátorů, které dokážou vektory zpracovat. Některé z&nbsp;těchto funkcí a
operátorů si ukážeme v&nbsp;této kapitole.</p>

<p>Operace pro získání prvního a posledního prvku vektoru jsou založeny na
operátorech *1 a *|1:</p>

<pre>
  <strong>*1 2 3</strong>
1
&nbsp;
  <strong>*|1 2 3</strong>
3
</pre>

<p>Získat lze i vektor bez prvního resp.&nbsp;bez posledního prvku, a to
konkrétně operátorem _, kterému se předá kladná či záporná hodnota:</p>

<pre>
  <strong>1_1 2 3</strong>
2 3
&nbsp;
  <strong>-1_1 2 3</strong>
1 2
</pre>

<p>Nepatrně složitější příklady založené na tomto operátoru a konstruktoru
vektoru:</p>

<pre>
  <strong>1_!10</strong>
1 2 3 4 5 6 7 8 9
&nbsp;
  <strong>-1_!10</strong>
0 1 2 3 4 5 6 7 8
</pre>

<p>Vektor lze velmi snadno otočit s&nbsp;využitím monadické formy operátoru |
(dyadická forma vyhledává maximum, což již dobře známe):</p>

<pre>
  <strong>|x</strong>
7 4 5 4 0 3 3 9 6 9
</pre>

<p>I řetězec je vektorem (znaků), takže otočení řetězce je triviální:</p>

<pre>
  <strong>|"foobarbaz"</strong>
"zabraboof"
</pre>

<p>Podobným způsobem lze prvky vektoru rotovat o zadaný počet prvku (rotace
doprava při kladném počtu):</p>

<pre>
  <strong>1!x</strong>
6 9 3 3 0 4 5 4 7 9
</pre>

<p>Další operátor slouží pro získání těch prvků vektoru, které odpovídají
binární masce (dalšímu vektoru). Jedná se vlastně o &bdquo;paralelní&ldquo;
implementaci filtru:</p>

<pre>
  x[&amp;x&gt;5]
9 6 9 7
&nbsp;
  x[&amp;x&lt;5]
3 3 0 4 4
</pre>

<p>Mimochodem, vlastní selekce prvků pomocí [] je vlastně jen syntaktickým
cukrem k&nbsp;operátoru @:</p>

<pre>
  <strong>1 2 3@1</strong>
2
</pre>

<p><div class="rs-tip-major">Poznámka: jedná se snad o jediný syntaktický cukr,
který v&nbsp;jazyku K nalezneme.</div></p>

<p>Poslední operátor se jmenuje <strong>where</strong>. Tento operátor vytvoří
nový vektor, v&nbsp;němž se vždy index prvku z&nbsp;původního vektoru opakuje
x-krát:</p>

<pre>
  <strong>&amp;x</strong>
0 0 0 0 0 0 0 0 0 1 1 1 1 1 1 2 2 2 2 2 2 2 2 2 3 3 3 4 4 4 6 6 6 6 7 7 7 7 7 8 8 8 8 9 9 9 9 9 9 9
</pre>



<p><a name="k16"></a></p>
<h2 id="k16">16. Modifikátory <strong>over</strong>, <strong>scan</strong> a <strong>each</strong></h2>

<p>Programovací jazyk K však kromě poměrně rozsáhlé řady primitivních funkcí
obsahuje, ostatně podobně jako již popsaný jazyk APL, několik
<i>modifikátorů</i>, pomocí nichž jsou funkce aplikovány nikoli na jeden či dva
parametry, ale postupně na celé vektory nebo matice. Díky modifikátorům (říká
se jim i operátory, ovšem význam tohoto slova je odlišný od významu, který toto
slovo má v&nbsp;jiných programovacích jazycích a proto ho nebudu používat) je
možné eliminovat velké množství programových smyček a mnohdy tak například
několikařádkovou proceduru zapsat pomocí jediného výrazu, což ostatně uvidíme i
v&nbsp;několika demonstračních příkladech.</p>

<p>Modifikátor <strong>over</strong> zapisovaný znakem / postupně aplikuje
zapsaný operátor na prvky vektoru, resp.&nbsp;na mezivýsledek a prvek vektoru.
Odpovídá tak funkci vyššího řádu <strong>reduce</strong>. Kombinace +/ sečte
všechny prvky vektoru:</p>

<pre>
  <strong>+/1 2 3</strong>
6
&nbsp;
  <strong>+/!10</strong>
45
</pre>

<p>Naproti tomu modifikátor <strong>scan</strong> zapisovaný zpětným lomítkem
vrací vektor se všemi vypočtenými mezivýsledky. Opět si ukažme kombinaci +\,
jenž vrátí mezivýsledky postupného součtu prvků:</p>

<pre>
  <strong>+\1 2 3</strong>
1 3 6
&nbsp;
  <strong>+\!10</strong>
0 1 3 6 10 15 21 28 36 45
</pre>

<p>Modifikátor <strong>each</strong> zapisovaný pomocí ' aplikuje programátorem
zvolený operátor na všechny prvky vektoru a vrací nový vektor:</p>

<pre>
  <strong>1+'!10</strong>
1 2 3 4 5 6 7 8 9 10
</pre>

<p>Aplikace operátoru + na dvojice prvků ze vstupního vektoru:</p>

<pre>
  <strong>+':1 2 3 4 5</strong>
3 5 7 9
</pre>

<p><div class="rs-tip-major">Poznámka: předchozí příklad je poněkud umělý,
protože můžeme použít i jednodušší a kratší 1+!10.</div></p>

<p>Takto se například vypočítá faktoriál deseti:</p>

<pre>
  <strong>*/1+!10</strong>
3628800
</pre>

<p>Opět poněkud umělý příklad na vyhledání největšího a nejmenšího prvku:</p>

<pre>
  <strong>x:10_draw 10</strong>
&nbsp;
  <strong>x</strong>
2 7 8 0 8 0 0 1 1 5
&nbsp;
  <strong>|/x</strong>
8
&nbsp;
  <strong>&amp;/x</strong>
0
</pre>

<p>Malý trik na výpočet délky odvěsny pravoúhlého trojúhelníka:</p>

<pre>
  <strong>_sqrt+/_sqr 3 4</strong>
5.0
</pre>



<p><a name="k17"></a></p>
<h2 id="k17">17. Funkce</h2>

<p>Poslední vlastností programovacího jazyka K, s&nbsp;níž se dnes setkáme, je
deklarace uživatelských funkcí. Začneme tvorbou funkcí s&nbsp;jediným
parametrem (a pochopitelně i jedinou výstupní hodnotou &ndash; více jich
ostatně není díky existenci seznamů a vektorů zapotřebí). Tělo funkce se
zapisuje do složených závorek, přičemž v&nbsp;těle funkce je možné použít
symbol <strong>x</strong> reprezentující hodnotu parametru předaného do volání
funkce. Taková funkce není pojmenovaná (je tedy <i>anonymní</i>) a voláme ji
stejně, jako vestavěný monadický operátor.</p>

<p>Příkladem může být funkce vracející hodnotu parametru zvýšenou o
jedničku:</p>

<pre>
  <strong>{1+x}10</strong>
11
&nbsp;
  <strong>{1+x}10 20 30</strong>
11 21 31
</pre>

<p>Anonymní funkce pro výpočet faktoriálu:</p>

<pre>
  <strong>{*/ 1+ !x} 5</strong>
120
</pre>

<p>Mezery jsou přebytečné, takže:</p>

<pre>
  <strong>{*/1+!x}5</strong>
120
</pre>

<p>Funkce je plnohodnotnou hodnotou, takže ji můžeme uložit do proměnné a tím
pádem ji pojmenovat:</p>

<pre>
  <strong>fact:{*/1+!x}</strong>
&nbsp;
  <strong>fact 10</strong>
3628800
</pre>

<p>Připomeňme si existenci modifikátoru ' (each). Lze ho použít i s&nbsp;naší
funkcí:</p>

<pre>
  <strong>fact' !10</strong>
1 1 2 6 24 120 720 5040 40320 362880
</pre>

<p>Funkce se dvěma parametry se již zapisuje nepatrně složitějším způsobem:</p>

<pre>
  <strong>plus:{[x;y]x+y}</strong>
  <strong>plus[1;2]</strong>
3
</pre>

<p>Podívejme se ještě na zápis funkce pro seřazení prvků ve vektoru:</p>

<pre>
  <strong>{x@&lt;x}3 2 1 4</strong>
1 2 3 4
</pre>

<p><div class="rs-tip-major">Poznámka: některé sofistikovanější funkce si
uvedeme příště.</div></p>



<p><a name="k18"></a></p>
<h2 id="k18">18. Náhrada programových smyček pomocí modifikátorů</h2>

<p>Ve této kapitole si pro ilustraci použití výše zmíněného modifikátoru /
v&nbsp;praxi ukážeme příklad převzatý z&nbsp;elektronické knihy &bdquo;J for C
Programmers&ldquo;, ve kterém je předvedeno, jakým způsobem je možné pomocí
modifikátoru / nalézt největší prvek v&nbsp;matici (mimochodem: zmíněná
elektronická kniha je obsažena přímo v&nbsp;instalaci vývojového prostředí
programovacího jazyka J). Příklad byl pochopitelně upraven takovým způsobem,
aby ho bylo možné spustit v&nbsp;jazyku K (kde je paradoxně ještě kratší, než
v&nbsp;případě už tak &bdquo;zhuštěného&ldquo; jazyka J). Nejprve si uveďme
odpovídající céčkový program, který nalezne prvek s&nbsp;maximální hodnotou
v&nbsp;(dvourozměrné) matici <strong>x</strong>, jejíž rozměry jsou uloženy
v&nbsp;konstantách <strong>xsize0</strong> a <strong>xsize1</strong>:</p>

<pre>
int i, j;
&nbsp;
float maxval = x[0][0];
&nbsp;
for (i = 0; i&lt;=xsize0; ++i)
{
    for (j = 0; j&lt;=xsize1; ++j)
    {
        if (x[i][j] &gt; maxval)
        {
            maxval = x[i][j];
        }
    }
}
</pre>

<p>V&nbsp;programovacím jazyku K je možné maximální prvek v&nbsp;matici nalézt
dvojí aplikací modifikátoru / zkombinovaného s&nbsp;operátorem | (tento
operátor, jak již víme, provádí výběr větší hodnoty z&nbsp;dvojice předaných
parametrů, tj.&nbsp;jak skalárních hodnot, tak i vektorů popř. matic). První
aplikace modifikátoru / slouží k&nbsp;výběru těch prvků na jednotlivých řádcích
matice, které mají největší hodnotu, druhá aplikace pak již z&nbsp;tohoto
mezivýsledku (tj.&nbsp;vektoru) vybere přímo maximální hodnotu, takže se celá
sekvence zanořených smyček a podmíněného příkazu v&nbsp;programovacím jazyku K
zmenší na jediný výraz, jehož délka je pouze čtyři znaky! Ve skutečnosti je
však možné podmíněný příkaz eliminovat i v&nbsp;céčkovém programu, stačí ho
nahradit například voláním makra MAX. Navíc si nikde nemusíme pamatovat rozměry
pole (matice), neboť ty lze kdykoli za běhu programu zjistit z&nbsp;matice
samotné:</p>

<pre>
  <strong>m:(1 2 3</strong>
     <strong>4 5 6</strong>
     <strong>7 8 9)</strong>
&nbsp;
  <strong>m</strong>
(1 2 3
 4 5 6
 7 8 9)
&nbsp;
  <strong>|/|/m</strong>
9
</pre>

<p>Příklad s&nbsp;náhodnými hodnotami:</p>

<pre>
  <strong>m:10 10 _draw 999</strong>
&nbsp;
  <strong>m</strong>
(273 779 884 97 859 19 21 122 104 500
 820 919 746 480 172 929 838 345 294 20
 306 256 697 866 662 792 472 961 527 214
 315 541 960 891 220 767 918 359 786 703
 843 793 871 538 446 457 365 580 998 309
 837 773 469 245 843 69 817 492 590 48
 931 93 559 366 177 460 731 137 998 216
 607 86 163 488 480 7 667 935 606 844
 131 365 974 655 752 179 320 326 394 695
 345 899 907 399 550 448 204 718 432 260)
&nbsp;
  <strong>|/m</strong>
931 919 974 891 859 929 918 961 998 844
&nbsp;
  <strong>|/|/m</strong>
998
</pre>



<p><a name="k19"></a></p>
<h2 id="k19">19. Obsah druhé části článku</h2>

<p>Ve druhé a současně i závěrečné části článku o neobvyklém programovacím
jazyku K si popíšeme způsob práce s&nbsp;maticemi, protože právě při zpracování
matic je možné využít zbývající standardní operátory, které jsou v&nbsp;jazyku
implementovány (a to bez nutnosti používání knihoven).</p>



<p><a name="k20"></a></p>
<h2 id="k20">20. Odkazy na Internetu</h2>

<ol>

<li>K language - an introduction<br />
<a href="http://www.math.bas.bg/bantchev/place/k.html">http://www.math.bas.bg/bantchev/place/k.html</a>
</li>

<li>K7 Tutorial<br />
<a href="https://cs.nyu.edu/~shasha/papers/tutorial">https://cs.nyu.edu/~shasha/papers/tutorial</a>
</li>

<li>An Interview with Arthur Whitney, Kx CEO and Developer of Kx Technology, January 4, 2004<br />
<a href="https://web.archive.org/web/20150813004101/http://kx.com/arthur-interview.php">https://web.archive.org/web/20150813004101/http://kx.com/arthur-interview.php</a>
</li>

<li>A Shallow Introduction to the K Programming Language<br />
<a href="https://web.archive.org/web/20130801233812/http://www.kuro5hin.org/story/2002/11/14/22741/791">https://web.archive.org/web/20130801233812/http://www.kuro5hin.org/story/2002/11/14/22741/791</a>
</li>

<li>A Conversation with Arthur Whitney<br />
<a href="https://queue.acm.org/detail.cfm?id=1531242">https://queue.acm.org/detail.cfm?id=1531242</a>
</li>

<li>Anecdote about Arthur Whitney<br />
<a href="https://news.ycombinator.com/item?id=13590065">https://news.ycombinator.com/item?id=13590065</a>
</li>

<li>K - list of idioms<br />
<a href="https://github.com/kevinlawler/kona/wiki/Idioms">https://github.com/kevinlawler/kona/wiki/Idioms</a>
</li>

<li>Appendix A. Incunabulum<br />
<a href="http://keiapl.org/rhui/remember.htm#incunabulum">http://keiapl.org/rhui/remember.htm#incunabulum</a>
</li>

<li>K code study<br />
<a href="https://docs.google.com/document/d/1W83ME5JecI2hd5hAUqQ1BVF32wtCel8zxb7WPq-D4f8/edit">https://docs.google.com/document/d/1W83ME5JecI2hd5hAUqQ1BVF32wtCel8zxb7WPq-D4f8/edit</a>
</li>

<li>K tutorial<br />
<a href="https://github.com/kevinlawler/kona/wiki/Tutorial">https://github.com/kevinlawler/kona/wiki/Tutorial</a>
</li>

<li>K by EXAMPLE<br />
<a href="http://vrabi.web.elte.hu/k/kbyeg.k">http://vrabi.web.elte.hu/k/kbyeg.k</a>
</li>

<li>BQN: An APL Variant from Marshall Lochbaum (mlochbaum.github.io)<br />
<a href="https://news.ycombinator.com/item?id=24167804">https://news.ycombinator.com/item?id=24167804</a>
</li>

<li>Raytracer in 7 lines in K<br />
<a href="http://www.nsl.com/k/ray/ray.k">http://www.nsl.com/k/ray/ray.k</a>
</li>

<li>Marshall Lochbaum<br />
<a href="https://www.aplwiki.com/wiki/Marshall_Lochbaum">https://www.aplwiki.com/wiki/Marshall_Lochbaum</a>
</li>

<li>BQN<br />
<a href="https://www.aplwiki.com/wiki/BQN">https://www.aplwiki.com/wiki/BQN</a>
</li>

<li>Co-dfns<br />
<a href="https://www.aplwiki.com/wiki/Co-dfns">https://www.aplwiki.com/wiki/Co-dfns</a>
</li>

<li>Array model<br />
<a href="https://www.aplwiki.com/wiki/Array_model#Based_array_theory">https://www.aplwiki.com/wiki/Array_model#Based_array_theory</a>
</li>

<li>Fonts for BQN<br />
<a href="https://mlochbaum.github.io/BQN/fonts.html">https://mlochbaum.github.io/BQN/fonts.html</a>
</li>

<li>Leading axis theory<br />
<a href="https://www.aplwiki.com/wiki/Leading_axis_theory">https://www.aplwiki.com/wiki/Leading_axis_theory</a>
</li>

<li>A based system for general arrays<br />
<a href="https://dl.acm.org/doi/abs/10.1145/586656.586663">https://dl.acm.org/doi/abs/10.1145/586656.586663</a>
</li>

<li>APL – A Glimpse of Heaven (2006)<br />
<a href="https://news.ycombinator.com/item?id=19325361">https://news.ycombinator.com/item?id=19325361</a>
</li>

<li>APL and J<br />
<a href="https://crypto.stanford.edu/~blynn/c/apl.html">https://crypto.stanford.edu/~blynn/c/apl.html</a>
</li>

<li>ivy (dokumentace)<br />
<a href="https://pkg.go.dev/robpike.io/ivy#section-readme">https://pkg.go.dev/robpike.io/ivy#section-readme</a>
</li>

<li>ivy na GitHubu<br />
<a href="https://github.com/robpike/ivy/">https://github.com/robpike/ivy/</a>
</li>

<li>Ivy na APL wiki<br />
<a href="https://aplwiki.com/wiki/Ivy">https://aplwiki.com/wiki/Ivy</a>
</li>

<li>Implementing a bignum calculator (slajdy)<br />
<a href="https://talks.godoc.org/github.com/robpike/ivy/talks/ivy.slide#1">https://talks.godoc.org/github.com/robpike/ivy/talks/ivy.slide#1</a>
</li>

<li>Implementing a bignum calculator - Rob Pike - golang-syd November 2014<br />
<a href="https://www.youtube.com/watch?v=PXoG0WX0r_E">https://www.youtube.com/watch?v=PXoG0WX0r_E</a>
</li>

<li>Rob Pike na Wikipedii<br />
<a href="https://en.wikipedia.org/wiki/Rob_Pike">https://en.wikipedia.org/wiki/Rob_Pike</a>
</li>

<li>Rob Pike na cat-v<br />
<a href="http://genius.cat-v.org/rob-pike/">http://genius.cat-v.org/rob-pike/</a>
</li>

<li>Jazyky umožňující operace s&nbsp;poli aneb rozsáhlý svět „array programmingu“<br />
<a href="https://www.root.cz/clanky/jazyky-umoznujici-operace-s-poli-aneb-rozsahly-svet-bdquo-array-programmingu-ldquo/">https://www.root.cz/clanky/jazyky-umoznujici-operace-s-poli-aneb-rozsahly-svet-bdquo-array-programmingu-ldquo/</a>
</li>

<li>Programovací technika nazvaná <i>tacit programming</i><br />
<a href="https://www.root.cz/clanky/programovaci-technika-nazvana-tacit-programming/">https://www.root.cz/clanky/programovaci-technika-nazvana-tacit-programming/</a>
</li>

<li>Oslava 55 let od vzniku první implementace jazyka APL<br />
<a href="https://www.root.cz/clanky/oslava-55-let-od-vzniku-prvni-implementace-programovaciho-jazyka-apl/">https://www.root.cz/clanky/oslava-55-let-od-vzniku-prvni-implementace-programovaciho-jazyka-apl/</a>
</li>

<li>NuVoc<br />
<a href="https://code.jsoftware.com/wiki/NuVoc">https://code.jsoftware.com/wiki/NuVoc</a>
</li>

<li>J (programming language) [Wikipedia]<br />
<a href="https://en.wikipedia.org/wiki/J_%28programming_language%29">https://en.wikipedia.org/wiki/J_%28programming_language%29</a>
</li>

<li>J &ndash; Absolutely Essential Terms<br />
<a href="https://code.jsoftware.com/wiki/Vocabulary/AET">https://code.jsoftware.com/wiki/Vocabulary/AET</a>
</li>

<li>J &ndash; Atoms and Arrays<br />
<a href="https://code.jsoftware.com/wiki/Vocabulary/Nouns#Atom">https://code.jsoftware.com/wiki/Vocabulary/Nouns#Atom</a>
</li>

<li>Why J<br />
<a href="https://www.jsoftware.com/help/primer/why_j.htm">https://www.jsoftware.com/help/primer/why_j.htm</a>
</li>

<li>What is an Array?<br />
<a href="https://vector.org.uk/what-is-an-array/">https://vector.org.uk/what-is-an-array/</a>
</li>

<li>Comments<br />
<a href="http://www.gavilan.edu/csis/languages/comments.html">http://www.gavilan.edu/csis/languages/comments.html</a>
</li>

<li>Vector (Wolfram MathWorld)<br />
<a href="https://mathworld.wolfram.com/Vector.html">https://mathworld.wolfram.com/Vector.html</a>
</li>

<li>n-Tuple (Wolfram MathWorld)<br />
<a href="https://mathworld.wolfram.com/n-Tuple.html">https://mathworld.wolfram.com/n-Tuple.html</a>
</li>

<li>n-Vector (Wolfram MathWorld)<br />
<a href="https://mathworld.wolfram.com/n-Vector.html">https://mathworld.wolfram.com/n-Vector.html</a>
</li>

<li>Matrix (Wolfram MathWorld)<br />
<a href="https://mathworld.wolfram.com/Matrix.html">https://mathworld.wolfram.com/Matrix.html</a>
</li>

<li>Array (Wolfram MathWorld)<br />
<a href="https://mathworld.wolfram.com/Array.html">https://mathworld.wolfram.com/Array.html</a>
</li>

<li>ND Arrays (Tensors) in different languages<br />
<a href="https://www.youtube.com/watch?v=WbpbEilgQBc">https://www.youtube.com/watch?v=WbpbEilgQBc</a>
</li>

<li>Extending APL to Infinity\<br />
<a href="https://www.jsoftware.com/papers/eem/infinity.htm">https://www.jsoftware.com/papers/eem/infinity.htm</a>
</li>

<li>Vector Library (R7RS-compatible)<br />
<a href="https://srfi.schemers.org/srfi-133/srfi-133.html">https://srfi.schemers.org/srfi-133/srfi-133.html</a>
</li>

<li>Vectors (pro Gauche)<br />
<a href="https://practical-scheme.net/gauche/man/gauche-refe/Vectors.html">https://practical-scheme.net/gauche/man/gauche-refe/Vectors.html</a>
</li>

<li>Kawa: Compiling Scheme to Java<br />
<a href="https://www.mit.edu/afs.new/sipb/project/kawa/doc/kawa-tour.html">https://www.mit.edu/afs.new/sipb/project/kawa/doc/kawa-tour.html</a>
</li>

<li>Kawa in Languages shootout<br />
<a href="http://per.bothner.com/blog/2010/Kawa-in-shootout/">http://per.bothner.com/blog/2010/Kawa-in-shootout/</a>
</li>

<li>Kawa 2.0 Supports Scheme R7RS<br />
<a href="https://developers.slashdot.org/story/14/12/13/2259225/kawa-20-supports-scheme-r7rs/">https://developers.slashdot.org/story/14/12/13/2259225/kawa-20-supports-scheme-r7rs/</a>
</li>

<li>Kawa — fast scripting on the Java platform<br />
<a href="https://lwn.net/Articles/623349/">https://lwn.net/Articles/623349/</a>
</li>

<li>Incanter is a Clojure-based, R-like platform for statistical computing and graphics.<br />
<a href="http://incanter.org/">http://incanter.org/</a>
</li>

<li>Evolution of incanter (Gource Visualization)<br />
<a href="https://www.youtube.com/watch?v=TVfL5nPELr4">https://www.youtube.com/watch?v=TVfL5nPELr4</a>
</li>

<li>Questions tagged [incanter] (na Stack Overflow)<br />
<a href="https://stackoverflow.com/questions/tagged/incanter?sort=active">https://stackoverflow.com/questions/tagged/incanter?sort=active</a>
</li>

<li>Data Sorcery with Clojure<br />
<a href="https://data-sorcery.org/contents/">https://data-sorcery.org/contents/</a>
</li>

<li>Back to the Future: Lisp as a Base for a Statistical Computing System<br />
<a href="https://rd.springer.com/chapter/10.1007/978-3-7908-2084-3_2">https://rd.springer.com/chapter/10.1007/978-3-7908-2084-3_2</a>
</li>

<li>Incanter Cheat Sheet<br />
<a href="http://incanter.org/docs/incanter-cheat-sheet.pdf">http://incanter.org/docs/incanter-cheat-sheet.pdf</a>
</li>

<li>Back to the Future: Lisp as a Base for a Statistical Computing System (celá verze článku)<br />
<a href="https://www.researchgate.net/publication/227019917_Back_to_the_Future_Lisp_as_a_Base_for_a_Statistical_Computing_System">https://www.researchgate.net/publication/227019917_Back_to_the_Future_Lisp_as_a_Base_for_a_Statistical_Computing_System</a>
</li>

<li>BQN: finally, an APL for your flying saucer<br />
<a href="https://mlochbaum.github.io/BQN/">https://mlochbaum.github.io/BQN/</a>
</li>

<li>Is BQN stable?<br />
<a href="https://mlochbaum.github.io/BQN/commentary/stability.html">https://mlochbaum.github.io/BQN/commentary/stability.html</a>
</li>

<li>Specification: BQN system-provided values<br />
<a href="https://mlochbaum.github.io/BQN/spec/system.html">https://mlochbaum.github.io/BQN/spec/system.html</a>
</li>

<li>Tutorial: BQN expressions<br />
<a href="https://mlochbaum.github.io/BQN/tutorial/expression.html">https://mlochbaum.github.io/BQN/tutorial/expression.html</a>
</li>

<li>BQN primitives<br />
<a href="https://mlochbaum.github.io/BQN/doc/primitive.html">https://mlochbaum.github.io/BQN/doc/primitive.html</a>
</li>

<li>Function trains<br />
<a href="https://mlochbaum.github.io/BQN/doc/train.html">https://mlochbaum.github.io/BQN/doc/train.html</a>
</li>

<li>BQN community links<br />
<a href="https://mlochbaum.github.io/BQN/community/index.html">https://mlochbaum.github.io/BQN/community/index.html</a>
</li>

<li>BQN UV<br />
<a href="https://observablehq.com/@lsh/bqn-uv">https://observablehq.com/@lsh/bqn-uv</a>
</li>

<li>APL Wiki<br />
<a href="https://aplwiki.com/wiki/">https://aplwiki.com/wiki/</a>
</li>

<li>The Array Cast<br />
<a href="https://www.arraycast.com/episodes/episode-03-what-is-an-array">https://www.arraycast.com/episodes/episode-03-what-is-an-array</a>
</li>

<li>EnthusiastiCon 2019 &ndash; An Introduction to APL<br />
<a href="https://www.youtube.com/watch?v=UltnvW83_CQ">https://www.youtube.com/watch?v=UltnvW83_CQ</a>
</li>

<li>Dyalog<br />
<a href="https://www.dyalog.com/">https://www.dyalog.com/</a>
</li>

<li>Try APL!<br />
<a href="https://tryapl.org/">https://tryapl.org/</a>
</li>

<li>Lisp-Stat Information<br />
<a href="http://homepage.cs.uiowa.edu/~luke/xls/xlsinfo/">http://homepage.cs.uiowa.edu/~luke/xls/xlsinfo/</a>
</li>

<li>Sample Plots in Incanter<br />
<a href="https://github.com/incanter/incanter/wiki/Sample-Plots-in-Incanter#line">https://github.com/incanter/incanter/wiki/Sample-Plots-in-Incanter#line</a>
</li>

<li>vectorz-clj<br />
<a href="https://github.com/mikera/vectorz-clj">https://github.com/mikera/vectorz-clj</a>
</li>

<li>vectorz &ndash; Examples<br />
<a href="https://github.com/mikera/vectorz-clj/wiki/Examples">https://github.com/mikera/vectorz-clj/wiki/Examples</a>
</li>

<li>Basic Vector and Matrix Operations in Julia: Quick Reference and Examples<br />
<a href="https://queirozf.com/entries/basic-vector-and-matrix-operations-in-julia-quick-reference-and-examples">https://queirozf.com/entries/basic-vector-and-matrix-operations-in-julia-quick-reference-and-examples</a>
</li>

<li>Vectors and matrices in Julia<br />
<a href="https://fncbook.github.io/v1.0/linsys/demos/matrices-julia.html">https://fncbook.github.io/v1.0/linsys/demos/matrices-julia.html</a>
</li>

<li>Array vs Matrix in R Programming<br />
<a href="https://www.geeksforgeeks.org/array-vs-matrix-in-r-programming/">https://www.geeksforgeeks.org/array-vs-matrix-in-r-programming/</a>
</li>

<li>Concurrency (computer science)<br />
<a href="https://en.wikipedia.org/wiki/Category:Concurrency_%28computer_science%29">https://en.wikipedia.org/wiki/Category:Concurrency_%28computer_science%29</a>
</li>

<li>Koprogram<br />
<a href="https://cs.wikipedia.org/wiki/Koprogram">https://cs.wikipedia.org/wiki/Koprogram</a>
</li>

<li>Coroutine<br />
<a href="https://en.wikipedia.org/wiki/Coroutine">https://en.wikipedia.org/wiki/Coroutine</a>
</li>

<li>Coroutines in C<br />
<a href="http://www.chiark.greenend.org.uk/~sgtatham/coroutines.html">http://www.chiark.greenend.org.uk/~sgtatham/coroutines.html</a>
</li>

<li>S-expression (Wikipedia)<br />
<a href="https://en.wikipedia.org/wiki/S-expression">https://en.wikipedia.org/wiki/S-expression</a>
</li>

<li>S-Expressions (Rosetta Code)<br />
<a href="http://rosettacode.org/wiki/S-Expressions">http://rosettacode.org/wiki/S-Expressions</a>
</li>

<li>Introducing Julia/Metaprogramming<br />
<a href="https://en.wikibooks.org/wiki/Introducing_Julia/Metaprogramming">https://en.wikibooks.org/wiki/Introducing_Julia/Metaprogramming</a>
</li>

<li>Tutorial for the Common Lisp Loop Macro<br />
<a href="http://www.ai.sri.com/pkarp/loop.html">http://www.ai.sri.com/pkarp/loop.html</a>
</li>

<li>Clojure Macro Tutorial (Part I, Getting the Compiler to Write Your Code For You)<br />
<a href="http://www.learningclojure.com/2010/09/clojure-macro-tutorial-part-i-getting.html">http://www.learningclojure.com/2010/09/clojure-macro-tutorial-part-i-getting.html</a>
</li>

<li>Clojure Macro Tutorial (Part II: The Compiler Strikes Back)<br />
<a href="http://www.learningclojure.com/2010/09/clojure-macro-tutorial-part-ii-compiler.html">http://www.learningclojure.com/2010/09/clojure-macro-tutorial-part-ii-compiler.html</a>
</li>

<li>Clojure Macro Tutorial (Part III: Syntax Quote)<br />
<a href="http://www.learningclojure.com/2010/09/clojure-macro-tutorial-part-ii-syntax.html">http://www.learningclojure.com/2010/09/clojure-macro-tutorial-part-ii-syntax.html</a>
</li>

<li>Clojure Macros and Metaprogramming<br />
<a href="http://clojure-doc.org/articles/language/macros.html">http://clojure-doc.org/articles/language/macros.html</a>
</li>

<li>Fatvat &ndash; Exploring functional programming: Clojure Macros<br />
<a href="http://www.fatvat.co.uk/2009/02/clojure-macros.html">http://www.fatvat.co.uk/2009/02/clojure-macros.html</a>
</li>

<li>CS 2101 Parallel Computing with Julia<br />
<a href="https://www.coursehero.com/file/11508091/CS-2101-Parallel-Computing-with-Julia/">https://www.coursehero.com/file/11508091/CS-2101-Parallel-Computing-with-Julia/</a>
</li>

<li>Julia By Example<br />
<a href="https://samuelcolvin.github.io/JuliaByExample/">https://samuelcolvin.github.io/JuliaByExample/</a>
</li>

<li>Array Programming<br />
<a href="https://en.wikipedia.org/wiki/Array_programming">https://en.wikipedia.org/wiki/Array_programming</a>
</li>

<li>Discovering Array Languages<br />
<a href="http://archive.vector.org.uk/art10008110">http://archive.vector.org.uk/art10008110</a>
</li>

<li>no stinking loops -- Kalothi<br />
<a href="http://www.nsl.com/">http://www.nsl.com/</a>
</li>

<li>Vector (obsahuje odkazy na články, knihy a blogy o programovacích jazycích APL, J a K)<br />
<a href="http://www.vector.org.uk/">http://www.vector.org.uk/</a>
</li>

<li>APL Interpreters<br />
<a href="http://www.vector.org.uk/?area=interpreters">http://www.vector.org.uk/?area=interpreters</a>
</li>

<li>APL_(programming_language<br />
<a href="http://en.wikipedia.org/wiki/APL_(programming_language">http://en.wikipedia.org/wiki/APL_(programming_language</a>
</li>

<li>APL FAQ<br />
<a href="http://www.faqs.org/faqs/apl-faq/">http://www.faqs.org/faqs/apl-faq/</a>
</li>

<li>APL FAQ (nejnovější verze)<br />
<a href="http://home.earthlink.net/~swsirlin/apl.faq.html">http://home.earthlink.net/~swsirlin/apl.faq.html</a>
</li>

<li>A+<br />
<a href="http://www.aplusdev.org/">http://www.aplusdev.org/</a>
</li>

<li>APLX<br />
<a href="http://www.microapl.co.uk/">http://www.microapl.co.uk/</a>
</li>

<li>FreeAPL<br />
<a href="http://www.pyr.fi/apl/index.htm">http://www.pyr.fi/apl/index.htm</a>
</li>

<li>Learning J (Roger Stokes)<br />
<a href="http://www.jsoftware.com/help/learning/contents.htm">http://www.jsoftware.com/help/learning/contents.htm</a>
</li>

<li>J: a modern, high-level, general-purpose, high-performance programming language<br />
<a href="http://www.jsoftware.com/">http://www.jsoftware.com/</a>
</li>

<li>K, Kdb: an APL derivative for Solaris, Linux, Windows<br />
<a href="http://www.kx.com">http://www.kx.com</a>
</li>

<li>openAPL (GPL)<br />
<a href="http://sourceforge.net/projects/openapl">http://sourceforge.net/projects/openapl</a>
</li>

<li>Parrot APL (GPL)<br />
<a href="http://www.parrotcode.org/">http://www.parrotcode.org/</a>
</li>

<li>Learning J (Roger Stokes)<br />
<a href="http://www.jsoftware.com/help/learning/contents.htm">http://www.jsoftware.com/help/learning/contents.htm</a>
</li>

<li>Rosetta Code<br />
<a href="http://rosettacode.org/wiki/Main_Page">http://rosettacode.org/wiki/Main_Page</a>
</li>

<li>Why APL<br />
<a href="http://www.acm.org/sigapl/whyapl.htm">http://www.acm.org/sigapl/whyapl.htm</a>
</li>

<li>Introducing Julia/Functions<br />
<a href="https://en.wikibooks.org/wiki/Introducing_Julia/Functions">https://en.wikibooks.org/wiki/Introducing_Julia/Functions</a>
</li>

<li>Functions (Julia documentation)<br />
<a href="https://docs.julialang.org/en/v1/manual/functions/">https://docs.julialang.org/en/v1/manual/functions/</a>
</li>

<li>Evaluate binomial coefficients<br />
<a href="http://rosettacode.org/wiki/Evaluate_binomial_coefficients">http://rosettacode.org/wiki/Evaluate_binomial_coefficients</a>
</li>

<li>Ackermann function<br />
<a href="http://rosettacode.org/wiki/Ackermann_function">http://rosettacode.org/wiki/Ackermann_function</a>
</li>

<li>Julia (front page)<br />
<a href="http://julialang.org/">http://julialang.org/</a>
</li>

<li>Julia &ndash; dokumentace<br />
<a href="http://docs.julialang.org/">http://docs.julialang.org/</a>
</li>

<li>Julia &ndash; repositář na GitHubu<br />
<a href="https://github.com/JuliaLang/julia">https://github.com/JuliaLang/julia</a>
</li>

<li>Julia (programming language)<br />
<a href="https://en.wikipedia.org/wiki/Julia_%28programming_language%29">https://en.wikipedia.org/wiki/Julia_%28programming_language%29</a>
</li>

<li>IJulia<br />
<a href="https://github.com/JuliaLang/IJulia.jl">https://github.com/JuliaLang/IJulia.jl</a>
</li>

<li>Introducing Julia<br />
<a href="https://en.wikibooks.org/wiki/Introducing_Julia">https://en.wikibooks.org/wiki/Introducing_Julia</a>
</li>

<li>Julia: the REPL<br />
<a href="https://en.wikibooks.org/wiki/Introducing_Julia/The_REPL">https://en.wikibooks.org/wiki/Introducing_Julia/The_REPL</a>
</li>

<li>Month of Julia<br />
<a href="https://github.com/DataWookie/MonthOfJulia">https://github.com/DataWookie/MonthOfJulia</a>
</li>

<li>Learn X in Y minutes (where X=Julia)<br />
<a href="https://learnxinyminutes.com/docs/julia/">https://learnxinyminutes.com/docs/julia/</a>
</li>

<li>New Julia language seeks to be the C for scientists<br />
<a href="http://www.infoworld.com/article/2616709/application-development/new-julia-language-seeks-to-be-the-c-for-scientists.html">http://www.infoworld.com/article/2616709/application-development/new-julia-language-seeks-to-be-the-c-for-scientists.html</a>
</li>

<li>Julia: A Fast Dynamic Language for Technical Computing<br />
<a href="http://karpinski.org/publications/2012/julia-a-fast-dynamic-language">http://karpinski.org/publications/2012/julia-a-fast-dynamic-language</a>
</li>

<li>The LLVM Compiler Infrastructure<br />
<a href="http://llvm.org/">http://llvm.org/</a>
</li>

<li>Julia: benchmarks<br />
<a href="http://julialang.org/benchmarks/">http://julialang.org/benchmarks/</a>
</li>

<li>Type system<br />
<a href="https://en.wikipedia.org/wiki/Type_system">https://en.wikipedia.org/wiki/Type_system</a>
</li>

<li>Half-precision floating-point format<br />
<a href="https://en.wikipedia.org/wiki/Half-precision_floating-point_format">https://en.wikipedia.org/wiki/Half-precision_floating-point_format</a>
</li>

<li>Dartmouth BASIC<br />
<a href="https://en.wikipedia.org/wiki/Dartmouth_BASIC">https://en.wikipedia.org/wiki/Dartmouth_BASIC</a>
</li>

<li>BASIC 4th Edition<br />
<a href="http://www.bitsavers.org/pdf/dartmouth/BASIC_4th_Edition_Jan68.pdf">http://www.bitsavers.org/pdf/dartmouth/BASIC_4th_Edition_Jan68.pdf</a>
</li>

<li>VECTRAN<br />
<a href="https://encyclopedia2.thefreedictionary.com/VECTRAN">https://encyclopedia2.thefreedictionary.com/VECTRAN</a>
</li>

<li>Comparison of programming languages (array)<br />
<a href="https://en.wikipedia.org/wiki/Comparison_of_programming_languages_(array)">https://en.wikipedia.org/wiki/Comparison_of_programming_languages_(array)</a>
</li>

<li>BASIC at 50<br />
<a href="https://www.dartmouth.edu/basicfifty/commands.html">https://www.dartmouth.edu/basicfifty/commands.html</a>
</li>

<li>BBC Basic - arrays<br />
<a href="http://www.riscos.com/support/developers/bbcbasic/part2/arrays.html">http://www.riscos.com/support/developers/bbcbasic/part2/arrays.html</a>
</li>

<li>Datová struktura<br />
<a href="https://cs.wikipedia.org/wiki/Datov%C3%A1_struktura">https://cs.wikipedia.org/wiki/Datov%C3%A1_struktura</a>
</li>

<li>SIMD instrukce využívané v&nbsp;moderních mikroprocesorech řady x86<br />
<a href="https://www.root.cz/clanky/simd-instrukce-vyuzivane-v-modernich-mikroprocesorech-rady-x86/">https://www.root.cz/clanky/simd-instrukce-vyuzivane-v-modernich-mikroprocesorech-rady-x86/</a>
</li>

<li>SIMD instrukce v&nbsp;moderních mikroprocesorech řady x86 (2.část: SSE)<br />
<a href="https://www.root.cz/clanky/simd-instrukce-v-modernich-mikroprocesorech-rady-x86-2-cast-sse/">https://www.root.cz/clanky/simd-instrukce-v-modernich-mikroprocesorech-rady-x86-2-cast-sse/</a>
</li>

<li>SIMD instrukce v&nbsp;moderních mikroprocesorech řady x86 (3.část: SSE2)<br />
<a href="https://www.root.cz/clanky/simd-instrukce-v-modernich-mikroprocesorech-rady-x86-3-cast-sse2/">https://www.root.cz/clanky/simd-instrukce-v-modernich-mikroprocesorech-rady-x86-3-cast-sse2/</a>
</li>

<li>Inductive type<br />
<a href="https://en.wikipedia.org/wiki/Inductive_type">https://en.wikipedia.org/wiki/Inductive_type</a>
</li>

<li>JuliaMono, a font for programming<br />
<a href="https://github.com/cormullion/juliamono">https://github.com/cormullion/juliamono</a>
</li>

<li>It’s arrays all the way down<br />
<a href="https://xpqz.github.io/learnapl/array.html">https://xpqz.github.io/learnapl/array.html</a>
</li>

</ol>



<p></p><p></p>
<p><small>Autor: <a href="http://www.fit.vutbr.cz/~tisnovpa">Pavel Tišnovský</a> &nbsp; 2022</small></p>
</body>
</html>

