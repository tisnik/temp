<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.0 Transitional//EN"
           "http://www.w3.org/TR/REC-html40/loose.dtd">
<html>
<head>
<title>Programovací jazyk Forth a zásobníkové procesory II</title>
<meta name="Author" content="Pavel Tisnovsky">
<meta name="Generator" content="vim">
<meta http-equiv="content-type" content="text/html; charset=utf-8">
<style type="text/css">
         H1  {font-family: arial, helvetica, sans-serif; color:#ffffff; background:#c00000; text-align:center; padding-left:1em}
         H2  {font-family: arial, helvetica, sans-serif; color:#ffffff; background:#0000c0; padding-left:1em; text-align:left}
         H3  {font-family: arial, helvetica, sans-serif; color:#000000; background:#c0c0c0; padding-left:1em; text-align:left}
         H4  {font-family: arial, helvetica, sans-serif; color:#000000; background:#e0e0e0; padding-left:1em; text-align:left}
         A   {font-family: arial, helvetica, sans-serif;}
         P   {font-family: arial, helvetica, sans-serif; color:#000000; text-align:justify; width:450px}
         LI  {font-family: arial, helvetica, sans-serif; color:#000000; text-align:justify; width:450px}
         OL  {font-family: arial, helvetica, sans-serif; color:#000000; text-align:justify; width:450px}
         UL  {font-family: arial, helvetica, sans-serif; color:#000000; text-align:justify; width:450px}
         PRE {background:#e0e0e0}
</style>
</head>

<body bgcolor="#ffffff" text="#000000" link="#0000ff" alink="#ff00ff" vlink="#ff0000">

<h2>Programovací jazyk Forth a zásobníkové procesory II</h2>

<h4>Pavel Tišnovský</h4>

<br><br>

<h3>Úvodník</h3>

<p>Ve druhém pokračování seriálu o programovacím jazyku Forth si popíšeme, ve
kterých oblastech probíhalo první nasazení Forthu, způsob vzniku jména tohoto
nevšedního programovacího jazyka a některé z důvodů, proč není Forth mezi
programátory více rozšířen.</p>



<h3>Obsah</h3>
<a href="#01">1. Historie vzniku jména Forth</a><br>
<a href="#02">2. Forth na mikropočítačích</a><br>
<a href="#03">3. Forth na osmibitových mikroprocesorech</a><br>
<a href="#04">4. Forth a osmibitové domácí počítače</a><br>
<a href="#05">5. Příčiny neoblíbenosti Forthu</a><br>
<a href="#06">6. Zápis matematických operací v postfixové notaci</a><br>
<a href="#07">7. Syndrom jednoho programovacího jazyka</a><br>
<a href="#08">9. Obsah dalšího pokračování</a><br>



<a name="01"></a>
<h3>1. Historie vzniku jména Forth</h3>

<p>Charles Moore svůj programovací jazyk považoval za představitele nové,
čtvrté, generace programovacích jazyků (v té době bylo módou používat slovo
generace, takže se například počítače rozdělovaly na generace, podobně jako
tehdejší procesory apod.). Proto jazyk pojmenoval jednoduše <em>Fourth</em>,
ale vzhledem k tomu, že operační systém, na kterém v té době pracoval,
podporoval pouze pět znaků ve jméně souborů (ne, nebyl to MS-DOS, ten podporuje
revolučních 8 znaků :-), zkrátil se název vyjmutím jedné samohlásky, což je v
počítačové angličtině běžné, na <em>Forth</em>.</p>

<p>Jedná se o název, který autoři různých verzí tohoto jazyka komolí, takže
existuje například dialekt <em>Forthu</em>, který se jmenuje <em>4th</em>
(nutno vyslovovat anglicky).</p>



<a name="02"></a>
<h3>2. Forth na mikropočítačích</h3>

<p>Jedny z prvních verzí <em>Forthu</em> byly, tehdy ještě ve formě maker
určených pro <em>assembler</em>, vytvořeny v National Radio Astronomy
Observatory na počátku sedmdesátých let. Tyto prvotiny však v žádném případě
nebylo možné nasadit v reálném provozu mimo observatoř, protože <em>Forth</em>
znali v té době maximálně dva lidé :-).</p>

<p>První skutečné, tj. reálně použitelné systémy založené na <em>Forthu</em>
byly vytvořeny teprve v roce 1970. Tyto systémy obsahovaly jádro
(<em>nucleus</em>) o velikosti typicky 4kB. V tomto jádře byly naprogramovány
základní nezbytné věci, jako přístup k disku nebo pásce, rozhraní k terminálům
a vytvoření a přístup ke slovníku slov/funkcí (<em>dictionary</em> - viz další
díly tohoto seriálu).</p>

<p>Toto jádro se používalo k překladu a následnému spuštění vlastního
vývojového prostředí, které obsahovalo assembler, textový editor, podporu pro
více uživatelů a několik desítek až stovek základních příkazů ve slovníku -
slov (<em>words</em>). Bootování systému a překlad prostředí zabralo na
tehdejších mikropočítačích řádově několik sekund. Při použití dnešních
mikroprocesorů by se jednalo pouze o několik desítek milisekund, což je pro
většinu aplikací zanedbatelná doba.</p>

<p>Ve Forthu byl naprogramován mimo jiné také <em>metacompiler</em>, pomocí
kterého se jádro překládalo. Zdrojové kódy metacompileru byly dlouhé cca 40
vytištěných stran. Bližší údaje nemám k dispozici, ale lze se domnívat, že na
jedné straně bylo natištěno cca 60 řádků, celý zdrojový kód tedy měl přibližně
2500 řádků. Zdrojové kódy algoritmů jsou však ve Forthu kratší než v jiných
programovacích jazycích, zvláště při použití preferovaného stylu programování,
tj. vytváření krátkých slov a jejich vzájemnému kombinování do "vět".</p>

<p>První systémy založené na <em>Forthu</em> byly vytvořeny tak, že
nepotřebovaly žádnou podporu ze strany operačního systému - ve skutečnosti se
operační systém vůbec nenahrával do operační paměti. V dalších letech se to pro
některé aplikace ukázalo jako velká výhoda, zejména se projevil rychlejší
přístup na disky a velmi rychlé přepínání kontextu běžících procesů.</p>



<a name="03"></a>
<h3>3. Forth na osmibitových mikroprocesorech</h3>

<p>V roce 1976 byla firma <a href="http://www.forth.com"><em>FORTH
Inc.</em></a> (jejím zakladatelem byl, kdo jiný než Chuck Moore) požádána, aby
<em>Forth</em> portovala na mikroprocesor <a
href="http://en.wikipedia.org/wiki/CDP1802">CDP-1802</a> (mimochodem, tento
procesor, určený pro vojenské a kosmické aplikace, měl velmi zajímavý
instrukční soubor - viz například stránka <a
href="http://www.sasktelwebsite.net/jbayko/cpu.html">Great Microprocessors of
the Past and Present</a>). Nový produkt byl nazván <em>microFORTH</em> a v
dalších letech byl portován na celou skupinu vzájemně odlišných mikroprocesorů,
zejména <a href="http://en.wikipedia.org/wiki/8080">Intel 8080</a>, <a
href="http://en.wikipedia.org/wiki/Motorola_6800">Motorola 6800</a>, <a
href="http://www.6502.org/">MOS 6502</a> a <a href="http://www.z80.info/">Zilog
Z80</a>. Systém <em>microFORTH</em> byl s úspěchem použit pro vytváření
průmyslových a řídicích aplikací, které využívaly právě tyto osmibitové
mikroprocesory. Mnohé tyto systémy prý pracují až do dnešní doby (tomu ostatně
po zhlédnutí historických sdělovacích a zabezpečovacích zařízení v některých
našich [polo]státních podnicích ochotně věřím - on také nebývá důvod měnit
fungující zařízení).</p>

<p>Všechny výše zmíněné mikroprocesory jsou osmibitové a v průmyslových
aplikacích byly osazeny operační pamětí o typické kapacitě 16kB. Tyto aplikace
byly spouštěny většinou z pamětí EPROM nebo PROM, protože disky se používaly
pouze v minipočítačích. Ostatní firmy pro tyto mikroprocesory dodávaly buď
pouze <em>assembler</em> nebo jazyk <em>PL/M</em> (raději na něj zapomeňte),
ostatní jazyky byly buď příliš náročné na systémové prostředky (<em>C</em>,
<em>Pascal</em>), nebo nevhodné pro programování složitějších aplikací
(<em>Basic</em>). V této "konkurenci" je jasné, že se <em>Forth</em> velmi
dobře prosazoval, zejména jako náhrada <em>assembleru</em>.</p>

<p>Jádro systému <em>microFORTH</em> mělo velikost pouze 1kB. V tomto jádru
byly definovány základní aritmetické operace (slova) pro datový typ integer a
řídicí cykly. Vývojové prostředí umožňovalo zápis a testování programů, stejně
jako ladění jádra. Na těchto systémech však nebyly podporovány databázové
funkce a také podpora multiprocessingu byla zprvu odstraněna (po několika
letech však byla opět přidána).</p>

<p>Zajímavé je, že firma FORTH Inc. prodávala <em>microFORTH</em>
prostřednictvím normální pošty. To v té době nebylo typické, protože bylo
zvykem, že se minipočítače instalovaly zákazníkovi až spolu s potřebným
softwarem. V případě <em>microFORTHu</em> stačilo poslat objednávku a po
několika dnech přišla osmipalcová disketa s aplikací :-)</p>

<p>Firma FORTH Inc. však nikdy neuvolnila metakompiler, který používala pro
překlad <em>microFORTHu</em>, což je na jednu stranu velká škoda, protože šlo o
velmi dobrý systém, na druhou stranu to pozitivně podnítilo vývoj dalších verzí
<em>Forthu</em>, zejména budoucího <em>FIG Forthu</em> a <em>ANS
Forthu</em>.</p>



<a name="04"></a>
<h3>4. Forth a osmibitové domácí počítače</h3>

<p>Programovací jazyk <em>Forth</em> byl s poměrně velkým úspěchem použit i na
osmibitových domácích počítačích. Zde se významně projevila schopnost
<em>Forthu</em> generovat krátký kód, který bylo možné zpracovat velmi
jednoduchým interpreterem. Ten byl dlouhý pouze několik strojových
instrukcí.</p>

<p>Jednou z prvních aplikací <em>Forthu</em> v oblasti osmibitových počítačů
byly některé systémové rutiny uložené v paměti ROM počítače <a
href="http://www.nvg.ntnu.no/sinclair/computers/zx81/zx81.htm">ZX-81</a>.
Jednalo se o operace s hodnotami uloženými v pohyblivé řádové čárce. Pomocí
<em>Forthu</em> byl vytvořen velmi krátký kód hojně používající smyčky a
iterace. Běh rutin byl díky tomu pomalý, proto byl v dalších počítačích firmy
<em>Sinclair Research</em> použit kód psaný přímo v <em>assembleru</em>, který
však byl delší.</p>

<div align="center">
<img src="forth02_1.jpg" alt="Osmibitový počítač ZX-81" border="0" width="450" height="319">
<p>Obrázek 1: Osmibitový počítač ZX-81</p>
</div>

<p>Firma <em>Level 9 Computing</em> vyvinula vlastní verzi <em>Forthu</em>, ve
které potom vytvářela velké množství her typu adventure, tj. textovek s
obrázky. I u těchto her bylo patrné, že se použil velmi kompaktní zápis
programového kódu. Byl využit dokonce primitivní multithreading, kdy se
vektorové (!) obrázky vykreslovaly současně s výpisem textu, což bylo velmi
efektní, protože příkazy do her bylo možné psát příkazy ještě před vykreslením
kompletních obrázků.</p>

<div align="center">
<img src="forth02_2.png" alt="Screenshot hry Jewels of Darkness běžící na osmibitovém počítači Atari 800XL" border="0" width="336" height="240">
<p>Obrázek 2: Screenshot hry Jewels of Darkness běžící na osmibitovém počítači Atari 800XL</p>
</div>

<div align="center">
<img src="forth02_3.png" alt="Screenshot hry Jewels of Darkness běžící na osmibitovém počítači Commodore C64" border="0" width="320" height="200">
<p>Obrázek 3: Screenshot hry Jewels of Darkness běžící na osmibitovém počítači Commodore C64</p>
</div>

<div align="center">
<img src="forth02_4.png" alt="Screenshot hry Jewels of Darkness běžící na osmibitovém počítači ZX Spectrum" border="0" width="256" height="192">
<p>Obrázek 4: Screenshot hry Jewels of Darkness běžící na osmibitovém počítači ZX Spectrum</p>
</div>

<div align="center">
<img src="forth02_5.png" alt="Tatáž hra, tentokrát na PC" border="0" width="328" height="230">
<p>Obrázek 5: Tatáž hra, tentokrát na PC</p>
</div>

<p>Vedlejším efektem použití <em>Forthu</em> byla i snadná přenositelnost
vytvořených her - viz přiložené obrázky rozšířené verze původní slavné hry
<strong>Adventure</strong>. V dnešní době multiplatformních knihoven a jazyků
to sice vypadá obyčejně, ale v době největšího rozmachu osmibitových domácích
počítačů byl kód ve <em>Forthu</em> patrně nejlépe přenositelný na další
platformy, protože jiné "přenositelné" jazyky buď vůbec neexistovaly
(<em>Java</em>, <em>C++</em>, <em>Perl</em>), nebo nebyly pro osmibitové
počítače ideální (<em>Common Lisp</em>, <em>SmallTalk</em>, <em>C</em>).</p>

<p>Osmibitové počítače ještě v době svého největšího rozmachu zažily vznik
oblíbeného <em>FIG Forthu</em>, jehož autoři si kladli za cíl vytvořit standard
mezi různými dialekty Forthu.</p>



<a name="05"></a>
<h3>5. Příčiny neoblíbenosti Forthu</h3>

<p><em>Forth</em> není mezi programátory příliš oblíbený (i když podle údajů
uvedených na stránce <a
href="http://home.earthlink.net/~mrob/pub/lang_srom.html">http://home.earthlink.net/~mrob/pub/lang_srom.html</a>
to není tak špatné). Důvodů je více, ale ten hlavní tkví ve způsobu zápisu
výrazů a příkazů. Další důvod tkví v takzvaném "syndromu jednoho programovacího
jazyka". Oba důvody si zkusíme v dalších odstavcích blíže vysvětlit.</p>



<a name="06"></a>
<h3>6. Zápis matematických operací v postfixové notaci</h3>

<p><em>If you're a frequent calculator user, you owe it to yourself to
investigate the advantages of RPN. RPN stands for Reverse Polish Notation.
Reverse Polish Notation was developed in 1920 by Jan Lukasiewicz as a way to
write a mathematical expression without using parentheses and brackets.
Hewlett-Packard Co., realizing that Lukasiewicz's method was superior to
standard algebraic expressions when using calculators and computers, adapted
RPN for its first hand-held scientific calculator, the HP35, in 1972.<br>

Hewlett-Packard Development Company The RPN Method: An Overview and History</em></p>

<p>Programátor, který zná některý z dnes používaných procedurálních nebo
objektově orientovaných jazyků (<em>C</em>, <em>C++</em>, <em>Java</em>,
<em>Perl</em>, <em>Ruby</em>, <em>Python</em>, <em>Visual Basic</em>), je
většinou překvapen, pokud poprvé uvidí program napsaný v jazyce <em>Forth</em>.
Toto překvapení (spíš zmatení :-) je způsobeno zejména tzv. postfixovou notací
zápisu aritmetických a logických operací.</p>

<p>Například výraz pro součet dvou čísel, který se ve většině programovacích
jazyků píše ve formě:</p>

<pre>

a+b

</pre>

<p>se ve <em>Forthu</em> zapíše jako:</p>

<pre>

a b +

</pre>

<p>Zjednodušeně řečeno to znamená, že se v postfixové notaci nejprve zapisují
operandy a teprve poté operátory. Postfixová notace se označuje také jako
<u>RPN</u> - <u>R</u>everse <u>P</u>olish <u>N</u>otation (obrácená polská
notace) a používají ji mimo jiné i některé kalkulačky od firmy Hewlett-Packard
(viz motto uvedené na začátku této kapitoly).</p>

<p>Způsoby zápisu programu ve <em>Forthu</em> se budeme věnovat někdy příště
(spolu s vysvětlením výhod RPN), už z výše uvedeného příkladu je však zřejmé,
že na člověka uvyklého běžné infixové notaci musí zápis v RPN působit
zmateně.</p>



<a name="07"></a>
<h3>7. Syndrom jednoho programovacího jazyka</h3>

<p>Začnu poněkud obšírně. Většina programátorů ví, že programovat na nejnižší
úrovni, tj. přímo ve strojovém kódu, není efektivní. Proto si většina z nich
volí prostředek na vyšší úrovni, minimálně assembler nebo vyšší programovací
jazyk, jako je například C.</p>

<p>Pokud programátor zná nějaký jazyk na vyšší úrovni, může ho z hlediska svých
dosavadních znalostí porovnávat s jazykem na stejné či nižší úrovni. Například
C-čkar může porovnávat svůj oblíbený jazyk s Pascalem, Algolem, Modulou nebo
níže s assemblerem.</p>

<p>Vyšší jazyky porovnávat dost dobře nemůže, protože přemýšlí právě v
paradigmatu toho svého jazyka. Proto je také přechod například z Pascalu do C
mnohem jednodušší než (opravdový přechod) z C do C++. Na první pohled je to
právě naopak, musíme však porovnávat vzniklé programy, nikoli syntaktickou
podobnost.</p>

<p>Sám si živě pamatuji na své první programy v Pascalu, na který jsem přešel z
Basicu a assembleru - často jsem používal globální proměnné a skoky, než jsem
se naučil rozumně strukturované funkce smyčky. Prostě assembler a Basic
vyžaduje k tvorbě programů jiný přístup, než strukturované nebo (ještě hůře)
OOP jazyky.</p>

<p>Přechod z Pascalu do C nebyl zas tak náročný, stačilo si osvojit odlišný
způsob zápisu funkcí a datových typů, zápis operátorů a rozšířenou práci s
ukazateli. Jinak jsou si Pascal a C (Modula, Algol, Fortran...) velmi podobné,
zejména v porovnání s logickými a funkcionálními jazyky.</p>

<p>Objektově orientované jazyky vyžadují odlišný přístup k řešení problémů, i
když je samozřejmě možné i v C++ a Javě psát pouze strukturovaně - stačí celý
kód obalit do jedné třídy, protože v rámci třídy jsou metody totéž co funkce a
atributy totéž co proměnné. Samozřejmě, že tento přístup není ideální, pouze má
upozornit na to, že každé paradigma programování vyžaduje jiný přístup k
algoritmizaci.</p>

<p>Stejný syndrom nastává při použití Forthu. Pokud programátor přímo s Forthem
nezačíná (takový programátor dnes snad ani neexistuje), musí některé své návyky
opustit a jiné se naučit, protože jinak se bude snažit tento velmi specifický
jazyk "ohnout", což pouze povede ke zklamání, chybám a k neefektivním
programům.</p>

<p><small>Poznámka: možná je škoda, že v Javě sice existuje rezervované slovo
<strong>goto</strong>, ale nelze ho použít jako klíčové slovo se zřejmým
významem. Teprve poté bysme se od některých takyprogramátorů dočkali krásných
začmodrchaných kódů :-) Dneska je nejlepší si přečíst nějaký komerční program
napsaný ve Visual Basicu - většinou jsou všechny proměnné typu Variant a místo
smyček se mnohdy vesele skáče. Z toho vyplývá, že efektivitu programování
neurčuje pouze programovací jazyk.</small></p>



<a name="08"></a>
<h3>8. Obsah dalšího pokračování</h3>

<p>V dalším pokračování si řekneme zajímavé informace a drby o duchovním otci
Forthu - Charlesi Moorovi. Zejména je zajímavý jeho poněkud kontraverzní pohled
na programovací techniky a nástroje i na budoucnost vývoje informačních
technologií. Kromě toho budou popsána některá dostupná vývojová prostředí
Forthu, zejména s ohledem na operační systém Linux.</p>



<br><br><br><hr>
<small>Autor: <a href="http://www.fit.vutbr.cz/~tisnovpa">Pavel Tišnovský</a> &nbsp; 2005</small>
</body>
</html>

