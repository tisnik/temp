<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
        "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html>
<head>
<title>Programovací jazyk C3: složené datové typy a kontejnery</title>
<meta name="Author" content="Pavel Tisnovsky" />
<meta name="Generator" content="vim" />
<meta http-equiv="content-type" content="text/html; charset=utf-8" />
<style type="text/css">
         body {color:#000000; background:#ffffff;}
         h1  {font-family: arial, helvetica, sans-serif; color:#ffffff; background-color:#c00000; text-align:center; padding-left:1em}
         h2  {font-family: arial, helvetica, sans-serif; color:#ffffff; background-color:#0000c0; padding-left:1em; text-align:left}
         h3  {font-family: arial, helvetica, sans-serif; color:#000000; background-color:#c0c0c0; padding-left:1em; text-align:left}
         h4  {font-family: arial, helvetica, sans-serif; color:#000000; background-color:#e0e0e0; padding-left:1em; text-align:left}
         a   {font-family: arial, helvetica, sans-serif;}
         li  {font-family: arial, helvetica, sans-serif; color:#000000; text-align:justify; width:450px;}
         ol  {font-family: arial, helvetica, sans-serif; color:#000000; text-align:justify; width:450px;}
         ul  {font-family: arial, helvetica, sans-serif; color:#000000; text-align:justify; width:450px;}
         p   {font-family: arial, helvetica, sans-serif; color:#000000; text-align:justify;}
         pre {background:#e0e0e0}
</style>
</head>

<body>

<h1>Programovací jazyk C3: složené datové typy a kontejnery</h1>

<h3>Pavel Tišnovský</h3>

<p></p>

<h1>Úvodník</h1>

<p>Ve třetím článku o programovacím jazyce C3 se zaměříme na popis složených datových typů a kontejnerů. Mezi základní typy kontejnerů patří vektory, staticky alokovaná pole, dynamicky alokovaná pole a můžeme sem zařadit i řezy. Ve standardní knihovně C3 pak nalezneme například seznamy či mapy.</p>



<h2>Obsah</h2>

<p><a href="#k01">1. Programovací jazyk C3: složené datové typy a kontejnery</a></p>
<p><a href="#k02">2. Vektory (<i>vector</i>)</a></p>
<p><a href="#k03">3. Konstrukce vektoru, modifikace prvků vektoru</a></p>
<p><a href="#k04">4. Předávání vektorů do funkcí</a></p>
<p><a href="#k05">5. Pole (<i>array</i>)</a></p>
<p><a href="#k06">6. Konstrukce pole, přístup k&nbsp;prvkům pole a modifikace prvků pole</a></p>
<p><a href="#k07">7. Předávání polí do funkcí</a></p>
<p><a href="#k08">8. Řezy (<i>slice</i>)</a></p>
<p><a href="#k09">9. Přímá konstrukce řezu s&nbsp;jeho inicializací</a></p>
<p><a href="#k10">10. Získání řezu z&nbsp;pole</a></p>
<p><a href="#k11">11. Další možnosti získání řezu: čím se C3 odlišuje od dalších jazyků</a></p>
<p><a href="#k12">12. Řezy získané z&nbsp;jiných řezů</a></p>
<p><a href="#k13">13. Kontejner typu seznam (<i>list</i>)</a></p>
<p><a href="#k14">14. Předání seznamu do funkcí</a></p>
<p><a href="#k15">15. Dynamicky alokované pole</a></p>
<p><a href="#k16">16. Různé varianty řetězců</a></p>
<p><a href="#k17">*** 17. Řetězce ukončené nulou</a></p>
<p><a href="#k18">18. Porovnání řetězců</a></p>
<p><a href="#k19">19. Repositář s&nbsp;demonstračními příklady</a></p>
<p><a href="#k20">20. Odkazy na Internetu</a></p>



<p><a name="k01"></a></p>
<h2 id="k01">1. Programovací jazyk C3: složené datové typy a kontejnery</h2>

<p>Ve třetím článku o programovacím jazyce C3 se zaměříme na popis složených
datových typů a kontejnerů. Definice <i>kontejneru</i> se většinou jazyk od
jazyka odlišuje, ale obecně za kontejnery považujeme takové datové typy, které
mohou jako své prvky obsahovat jiné objekty (v&nbsp;obecném smyslu se mezi
objekty počítají i numerické hodnoty, znaky, řetězce, struktury atd.). Jazyk C3
je navržen takovým způsobem, aby zjednodušil práci vývojářům přecházejícím
z&nbsp;jazyka C, ovšem aby se od C sémanticky příliš neodlišoval.</p>

<p>Z&nbsp;tohoto důvodu &ndash; jak ostatně uvidíme v&nbsp;následujících
kapitolách &ndash; jsou vlastnosti kontejnerů v&nbsp;C3 na půli cesty mezi
klasickým jazykem C na jedné straně (zde existují pouze statická a dynamicky
alokovaná pole, ostatní kontejnery se programují ručně) a <a
href="https://www.root.cz/serialy/programovaci-jazyk-go/">jazykem Go na straně
druhé</a> (podpora pro pole s&nbsp;rostoucím počtem prvků přes řezy &ndash;
<i>slices</i> a taktéž podpora pro práci s&nbsp;asociativními poli &ndash;
mapami). V&nbsp;jazyce C3 tedy nebude práce s&nbsp;dynamicky se měnícími
strukturami zcela bezproblémová, ovšem obecně bude snazší než v&nbsp;klasickém
jazyku C.</p>



<p><a name="k02"></a></p>
<h2 id="k02">2. Vektory (<i>vector</i>)</h2>

<p>Pro úplnost se v&nbsp;tomto článku zmíníme o všech kontejnerech nabízených
programovacím jazykem C3. To mj.&nbsp;znamená, že se alespoň ve stručnosti
znovu zmíníme o vektorech, které byly částečně popsány <a
href="https://www.root.cz/clanky/programovaci-jazyk-c3-datove-typy-pro-moderni-architektury/">v&nbsp;předchozím
článku</a>. Připomeňme si, že vektory jsou kontejnerem, který může obsahovat
předem známý počet prvků (tento počet zjišťuje překladač). Vektory se do značné
míry podobají klasickým polím (<i>array</i>), ovšem operace s&nbsp;vektory je
překládána do SIMD instrukcí, pochopitelně jen za předpokladu, že je to na dané
architektuře možné.  Ovšem kvůli této vlastnosti je možné do vektorů ukládat
pouze prvky celočíselných datových typů, typů s&nbsp;plovoucí řádovou čárkou,
pravdivostní hodnoty nebo ukazatele. Nelze tedy například pracovat
s&nbsp;vektory řetězců atd.; pokud je to nutné, musí se používat klasická
pole.</p>

<p><div class="rs-tip-major">Délka vektorů (počet prvků) není měnitelná,
tj.&nbsp;nelze do nich přidávat další prvky ani prvky mazat. Ovšem samotné
prvky vektoru jsou měnitelné (<i>mutable</i>).</div></p>



<p><a name="k03"></a></p>
<h2 id="k03">3. Konstrukce vektoru, modifikace prvků vektoru</h2>

<p>Datový typ vektor se v&nbsp;jazyku C3 zapisuje tímto způsobem:</p>

<pre>
typ_prvku[&lt;počet_prvků&gt;]
</pre>

<p>přičemž počet prvků musí být známý již v&nbsp;čase překladu, tedy jedná se o
konstantu. Příkladem může být vektor obsahující deset prvků typu
<strong>int</strong>, který můžeme ihned inicializovat:</p>

<pre>
int[&lt;10&gt;] a = {1, 2, 3, 4, 5, 6, 7, 8, 9, 10};
</pre>

<p>Délka vektoru, která je zjištěna při jeho definici, je dostupná přes atribut
nazvaný <strong>len</strong>. K&nbsp;prvkům vektorů se přistupuje
(z&nbsp;hlediska syntaxe) stejně, jako k&nbsp;prvkům polí. Jak již víme
z&nbsp;předchozího textu, jsou prvky vektorů obecně měnitelné (<i>mutable</i>),
takže můžeme obsah vektoru snadno modifikovat:</p>

<pre>
for (int i=0; i&lt;a.len; i++) {
    a[i] = (i + 1)*10;
}
</pre>

<p>V&nbsp;dnešním prvním demonstračním příkladu je ukázána deklarace vektoru
s&nbsp;jeho inicializací, dále výpis obsahu tohoto vektoru (hodnoty všech
prvků), modifikace prvků vektoru a znovu jeho výpis:</p>

<pre>
module containers;
import std::io;
&nbsp;
fn void <strong>main</strong>()
{
    io::printf("type: %s\n", int[&lt;10&gt;].nameof);
&nbsp;
    int[&lt;10&gt;] a = {1, 2, 3, 4, 5, 6, 7, 8, 9, 10};
&nbsp;
    io::printf("a=%s\n", a);
&nbsp;
    for (int i=0; i&lt;a.len; i++) {
        a[i] = (i + 1)*10;
    }
    io::printf("a=%s\n", a);
}
</pre>

<p>Výsledky:</p>

<pre>
type: int[&lt;10&gt;]
a=[&lt;1, 2, 3, 4, 5, 6, 7, 8, 9, 10&gt;]
a=[&lt;10, 20, 30, 40, 50, 60, 70, 80, 90, 100&gt;]
</pre>



<p><a name="k04"></a></p>
<h2 id="k04">4. Předávání vektorů do funkcí</h2>

<p>Zajímavé bude zjistit, jakým způsobem jsou vektory předávány (formou
parametrů) do funkcí. V&nbsp;současnosti používaných programovacích jazycích se
parametry předávají buď hodnotou (<i>value</i>) nebo odkazem
(<i>reference</i>), přičemž mnohé jazyky z&nbsp;různých důvodů tyto způsoby
předávání kombinují &ndash; hodnoty některých typů jsou tedy předávány hodnotou
a u jiných typů přes reference.</p>

<p>V&nbsp;demonstračním příkladu ukázaném pod tímto odstavcem je vytvořen
vektor, ten je předán do funkce nazvané <strong>update_vector</strong>, která
modifikuje prvky předaného vektoru a po návratu z&nbsp;této funkce je vektor
vypsán:</p>

<pre>
module containers;
import std::io;
&nbsp;
fn void <strong>update_vector</strong>(int[&lt;10&gt;] vector) {
    for (int i=0; i&lt;vector.len; i++) {
        vector[i] = (i + 1)*10;
    }
}
&nbsp;
fn void <strong>main</strong>()
{
    io::printf("type: %s\n", int[&lt;10&gt;].nameof);
&nbsp;
    int[&lt;10&gt;] a = {1, 2, 3, 4, 5, 6, 7, 8, 9, 10};
    io::printf("a=%s\n", a);
&nbsp;
    update_vector(a);
    io::printf("a=%s\n", a);
}
</pre>

<p>Z&nbsp;vypsaných výsledků je patrné, že volání funkce
<strong>update_vector</strong> původní vektor nijak nezměnilo. To znamená
jediné &ndash; vektor byl předán hodnotou (tudíž se provedla jako kopie) a
prvky byly změněny v&nbsp;této kopii, nikoli v&nbsp;původním vektoru:</p>

<pre>
type: int[&lt;10&gt;]
a=[&lt;1, 2, 3, 4, 5, 6, 7, 8, 9, 10&gt;]
a=[&lt;1, 2, 3, 4, 5, 6, 7, 8, 9, 10&gt;]
</pre>

<p>V&nbsp;případě, že budeme chtít, aby se skutečně modifikoval vektor předaný
do funkce <strong>update_vector</strong>, musíme explicitně vektor předat
odkazem, tj.&nbsp;přes ukazatel &ndash; viz podtržené části zdrojového
kódu:</p>

<pre>
module containers;
import std::io;
&nbsp;
fn void <strong>update_vector</strong>(<u>int[&lt;10&gt;] *vector</u>) {
    for (int i=0; i&lt;vector.len; i++) {
        <u>(*vector)[i]</u> = (i + 1)*10;
    }
}
&nbsp;
fn void <strong>main</strong>()
{
    io::printf("type: %s\n", int[&lt;10&gt;].nameof);
&nbsp;
    int[&lt;10&gt;] a = {1, 2, 3, 4, 5, 6, 7, 8, 9, 10};
    io::printf("a=%s\n", a);
&nbsp;
    update_vector(<u>&amp;a</u>);
    io::printf("a=%s\n", a);
}
</pre>

<p>Z&nbsp;výpisu je zřejmé, že skutečně došlo k&nbsp;modifikaci prvků původního
vektoru:</p>

<pre>
type: int[&lt;10&gt;]
a=[&lt;1, 2, 3, 4, 5, 6, 7, 8, 9, 10&gt;]
a=[&lt;10, 20, 30, 40, 50, 60, 70, 80, 90, 100&gt;]
</pre>

<p><div class="rs-tip-major">Poznámka: vektory se tedy předávají hodnotou,
stejně jako hodnoty primitivních typů.</div></p>



<p><a name="k05"></a></p>
<h2 id="k05">5. Pole (<i>array</i>)</h2>

<p>Dostáváme se k&nbsp;dalšímu typu kontejneru nabízeného programovacím jazykem
C3. Tento typ se nazývá pole (<i>array</i>) a do značné míry se podobá <a
href="#k02">výše zmíněným</a> vektorům. Jedním podstatným rozdílem je ovšem
fakt, že prvky pole mohou být jakéhokoli (předem známého) typu, tedy například
je možné vytvořit pole řetězců, pole uživatelem definovaných datových struktur,
pole vektorů, pole polí atd. I další vlastnosti polí jsou do značné míry
stejné, jako tomu bylo u vektorů &ndash; počet prvků polí musí být známý už
v&nbsp;době překladu, tento počet lze získat přes atribut <strong>len</strong>,
pole nelze (prostředky samotného jazyka) zvětšovat ani zmenšovat, ovšem je
možné prvky pole modifikovat.</p>

<p><div class="rs-tip-major">Poznámka: v&nbsp;oblasti práce s&nbsp;poli je
největším rozdílem mezi jazyky C a C3 fakt, že v&nbsp;C3 jsou i pole předávána
do funkcí hodnotou (<i>value</i>) a nikoli referencí. Pole tedy nemají
v&nbsp;C3 žádné výsadní postavení, což je oproti klasickému C méně matoucí,
zejména pro začátečníky.</div></p>



<p><a name="k06"></a></p>
<h2 id="k06">6. Konstrukce pole, přístup k&nbsp;prvkům pole a modifikace prvků pole</h2>

<p>Vzhledem k&nbsp;tomu, že zacházení s&nbsp;poli je v&nbsp;jazyce C3 prakticky
totožné, jako práce s&nbsp;vektory (až na to, že typ prvků polí není omezen),
ukažme si bez podrobnějšího popisu demonstrační příklad, ve kterém je vytvořeno
nové desetiprvkové pole, je ihned provedena jeho inicializace, pole je
vytištěno (to jazyk C3 umožňuje, což je velmi praktické), prvky pole jsou
modifikovány a následně je vypsán nový obsah pole:</p>

<pre>
module containers;
import std::io;
&nbsp;
fn void <strong>main</strong>()
{
    io::printf("type: %s\n", int[10].nameof);
&nbsp;
    int[10] a = {1, 2, 3, 4, 5, 6, 7, 8, 9, 10};
&nbsp;
    io::printf("a=%s\n", a);
&nbsp;
    for (int i=0; i&lt;a.len; i++) {
        a[i] = (i + 1)*10;
    }
    io::printf("a=%s\n", a);
}
</pre>

<p>Výsledky získané po překladu a spuštění tohoto demonstračního příkladu:</p>

<pre>
type: int[10]
a=[1, 2, 3, 4, 5, 6, 7, 8, 9, 10]
a=[10, 20, 30, 40, 50, 60, 70, 80, 90, 100]
</pre>

<p><div class="rs-tip-major">Poznámka: povšimněte si chybějících úhlových
závorek ve výpisu. Tím velmi snadno z&nbsp;výpisu poznáme, zda byl vytištěn
obsah pole nebo vektoru.</div></p>



<p><a name="k07"></a></p>
<h2 id="k07">7. Předávání polí do funkcí</h2>

<p>Pole je možné do funkcí předat buď hodnotou nebo odkazem, tj.&nbsp;naprosto
stejnými způsoby, jako tomu bylo u vektorů. A znovu si dovolím připomenout
&ndash; touto vlastností se jazyk C3 do značné míry liší od standardního jazyka
C. Rozdíl mezi předáním hodnotou a odkazem si můžeme (opět) snadno otestovat, a
to tak, že budeme prvky pole ve volané funkci modifikovat. Pokud je pole
předané hodnotou, nebude mít tato operace na původní pole vliv, pokud je ovšem
předané odkazem, tak se původní pole změní:</p>

<pre>
module containers;
import std::io;
&nbsp;
fn void <strong>update_array</strong>(int[10] array) {
    for (int i=0; i&lt;array.len; i++) {
        array[i] = (i + 1)*10;
    }
}
&nbsp;
fn void <strong>main</strong>()
{
    io::printf("type: %s\n", int[10].nameof);
&nbsp;
    int[10] a = {1, 2, 3, 4, 5, 6, 7, 8, 9, 10};
    io::printf("a=%s\n", a);
&nbsp;
    update_array(a);
    io::printf("a=%s\n", a);
}
</pre>

<p>Výsledky ukazují, že pole bylo skutečně předáno hodnotou:</p>

<pre>
type: int[10]
a=[1, 2, 3, 4, 5, 6, 7, 8, 9, 10]
a=[1, 2, 3, 4, 5, 6, 7, 8, 9, 10]
</pre>

<p>Explicitní předání pole odkazem, tj.&nbsp;přes ukazatel, lze realizovat
takto:</p>

<pre>
module containers;
import std::io;
&nbsp;
fn void <strong>update_array</strong>(<u>int[10] *array</u>) {
    for (int i=0; i&lt;array.len; i++) {
        <u>(*array)[i]</u> = (i + 1)*10;
    }
}
&nbsp;
fn void <strong>main</strong>()
{
    io::printf("type: %s\n", int[10].nameof);
&nbsp;
    int[10] a = {1, 2, 3, 4, 5, 6, 7, 8, 9, 10};
    io::printf("a=%s\n", a);
&nbsp;
    update_array(<u>&amp;a</u>);
    io::printf("a=%s\n", a);
}
</pre>

<p>Nyní se obsah původního pole změní, přesně podle očekávání:</p>

<pre>
type: int[10]
a=[1, 2, 3, 4, 5, 6, 7, 8, 9, 10]
a=[10, 20, 30, 40, 50, 60, 70, 80, 90, 100]
</pre>



<p><a name="k08"></a></p>
<h2 id="k08">8. Řezy (<i>slice</i>)</h2>

<p>Jak jsme si již řekli v&nbsp;úvodní kapitole, nemusí být klasické pole
(<i>array</i>) v&nbsp;praxi dostatečně flexibilní datovou strukturou, která by
plně vyhovovala potřebám vytvářené aplikace popř.&nbsp;implementovaného
algoritmu. Pro dosažení poněkud větší flexibility byl do programovacího jazyka
C3 přidán další datový typ nazývaný <i>řez</i> neboli <i>slice</i> (namísto
pojmu řez je možná názornější použít slovo <i>výsek</i>).</p>

<p>Interně se jedná o referenci na pole, které je explicitně
&bdquo;nasalámováno&ldquo; operací, s&nbsp;níž se seznámíme v&nbsp;navazujícím
textu. Zjednodušeně řečeno se na řezy můžeme dívat jako na dynamická pole
(protože klasická pole v&nbsp;C3 nemohou měnit svoji velikost, tj.&nbsp;počet
prvků). Koncept řezů ve skutečnosti není žádnou žhavou novinkou a setkáme se
s&nbsp;nimi i v&nbsp;dalších programovacích jazycích, například v&nbsp;Go nebo
Rustu (i když jejich vlastnosti jsou v&nbsp;porovnání s&nbsp;C3 poněkud odlišné
&ndash; C3 je méně flexibilní).</p>

<p>Každý řez je v&nbsp;operační paměti uložen ve formě dvojice hodnot. Jedná se
tedy o záznam &ndash; <strong>struct</strong>, v&nbsp;jiných jazycích též
nazývaný <strong>record</strong>. Konkrétně je řez tvořen touto dvojicí
hodnot:</p>

<ol>

<li>Ukazatel (<i>reference</i>) na zvolený prvek pole s&nbsp;daty, ke kterým
přes řez přistupujeme. Tento ukazatel nemusí ukazovat na první prvek pole, ale
na libovolný prvek.</li>

<li>Délka řezu (<i>length</i>), což značí počet skutečně prvků přístupných přes
řez.</li>

</ol>

<p><div class="rs-tip-major">Poznámka: Tato interní struktura řezů s&nbsp;sebou
přináší několik zajímavých důsledků. Je totiž možné, aby existovalo větší
množství řezů ukazujících na obecně různé prvky jediného pole a dokonce
majících i různé délky. Pokud v&nbsp;této situaci modifikujeme prvek
v&nbsp;jednom řezu, znamená to, že se vlastně modifikuje obsah původního pole a
i ostatní řezy nový prvek uvidí (přesněji řečeno pokud čteme data z&nbsp;jiného
řezu, získáme již modifikované prvky). Co je však užitečnější &ndash;
s&nbsp;řezy jako s&nbsp;datovým typem se velmi snadno pracuje; řezy mohou být
předávány do funkcí, vráceny z&nbsp;funkcí atd. Nedochází přitom ke kopiím
celého pole, což je paměťově i časově velmi náročná operace. Řez se sice stále
předává hodnotou, ale touto hodnotou je struktura s&nbsp;výše popsanou dvojicí
hodnot, nikoli celé (obecně velmi dlouhé) pole.</div></p>



<p><a name="k09"></a></p>
<h2 id="k09">9. Přímá konstrukce řezu s&nbsp;jeho inicializací</h2>

<p>Definice řezu vypadá v&nbsp;jazyce C3 následovně:</p>

<pre>
typ_prvků[]
</pre>

<p>což se odlišuje od definice polí:</p>

<pre>
typ_prvků[počet_prvků]
</pre>

<p>i od definice vektorů:</p>

<pre>
typ_prvků[&lt;počet_prvků&gt;]
</pre>

<p>Po konstrukci řezu se s&nbsp;řezem pracuje (alespoň zdánlivě) naprosto
stejně, jako s&nbsp;polem, což si ostatně můžeme velmi snadno ověřit:</p>

<pre>
module containers;
import std::io;
&nbsp;
fn void <strong>main</strong>()
{
    io::printf("type: %s\n", int[].nameof);
&nbsp;
    int[] a = {1, 2, 3, 4, 5, 6, 7, 8, 9, 10};
&nbsp;
    io::printf("a=%s\n", a);
&nbsp;
    for (int i=0; i&lt;a.len; i++) {
        a[i] = (i + 1)*10;
    }
    io::printf("a=%s\n", a);
}
</pre>

<p>Z&nbsp;výsledků je patrné, že se řezy (alespoň prozatím) chovají stejně jako
pole:</p>

<pre>
type: int[]
a=[1, 2, 3, 4, 5, 6, 7, 8, 9, 10]
a=[10, 20, 30, 40, 50, 60, 70, 80, 90, 100]
</pre>

<p>Odlišné chování uvidíme ve chvíli, kdy řez předáme do funkce, která provede
jeho modifikaci. Řez je totiž sice stále předáván hodnotou, ovšem touto
hodnotou je jen struktura ukazatel+délka, tj.&nbsp;<i>obsah</i> řezu je vlastně
předán odkazem:</p>

<pre>
module containers;
import std::io;
&nbsp;
fn void <strong>update_slice</strong>(int[] slice) {
    for (int i=0; i&lt;slice.len; i++) {
        slice[i] = (i + 1)*10;
    }
}
&nbsp;
fn void <strong>main</strong>()
{
    io::printf("type: %s\n", int[10].nameof);
&nbsp;
    int[] a = {1, 2, 3, 4, 5, 6, 7, 8, 9, 10};
    io::printf("a=%s\n", a);
&nbsp;
    update_slice(a);
    io::printf("a=%s\n", a);
}
</pre>

<p>Chování řezů je patrné z&nbsp;výsledků, které tento příklad vypíše:</p>

<pre>
type: int[10]
a=[1, 2, 3, 4, 5, 6, 7, 8, 9, 10]
a=[10, 20, 30, 40, 50, 60, 70, 80, 90, 100]
</pre>

<p><div class="rs-tip-major">Poznámka: z&nbsp;tohoto pohledu jsou řezy
v&nbsp;C3 blíže k&nbsp;céčkovským polím, než skutečná pole.</div></p>



<p><a name="k10"></a></p>
<h2 id="k10">10. Získání řezu z&nbsp;pole</h2>

<p>Datový typ <i>řez</i> získal svůj název kvůli existenci následující operace,
kterou lze provést s&nbsp;polem nebo s&nbsp;jiným řezem. Tato operace se
zapisuje takto:</p>

<pre>
pole[index1..index2]
</pre>

<p>nebo:</p>

<pre>
řez[index1..index2]
</pre>

<p>Výsledkem předchozího <i>výrazu</i> je nový (obecně zúžený) pohled na pole,
který se nazývá řez. Mohli bychom tedy psát:</p>

<pre>
řez = pole[index1..index2]
</pre>

<p>nebo:</p>

<pre>
nový_řez = původní_řez[index1..index2]
</pre>

<p>První index, druhý index, či oba indexy lze vynechat. Pokud je vynechán
první index, je namísto něho použita nula (začátek pole), pokud je vynechán
index druhý, je za něj dosazena hodnota odpovídající poslednímu prvku
(včetně).</p>

<p><div class="rs-tip-major">Poznámka: Přitom je důležité si uvědomit, že řez
jako takový neobsahuje zkopírované prvky původního pole nebo řezu, ale jen
odkaz na původní pole (neboli pohled na pole). Podrobnosti si uvedeme
v&nbsp;dalším textu.</div></p>

<p>Vyzkoušejme si to na jednoduchém příkladu, z&nbsp;něhož je navíc zřejmé, zda
se index posledního prvku uvádí &bdquo;včetně&ldquo; nebo
&bdquo;kromě&ldquo;:</p>

<pre>
module containers;
import std::io;
&nbsp;
fn void <strong>main</strong>()
{
    int[10] a = {1, 2, 3, 4, 5, 6, 7, 8, 9, 10};
    io::printf("a=%s\n", a);
&nbsp;
    int[] b = a[3..6];
    io::printf("b=%s\n", b);
&nbsp;
    int[] c = a[..6];
    io::printf("c=%s\n", c);
&nbsp;
    int[] d = a[3..];
    io::printf("d=%s\n", d);
&nbsp;
    int[] e = a[..];
    io::printf("e=%s\n", e);
}
</pre>

<p>Z&nbsp;výsledků je patrné, že horní index zahrnuje i prvek s&nbsp;tímto
indexem (&bdquo;včetně&ldquo;), čímž se chování jazyka C3 odlišuje od některých
dalších programovacích jazyků:</p>

<pre>
a=[1, 2, 3, 4, 5, 6, 7, 8, 9, 10]
b=[4, 5, 6, 7]
c=[1, 2, 3, 4, 5, 6, 7]
d=[4, 5, 6, 7, 8, 9, 10]
e=[1, 2, 3, 4, 5, 6, 7, 8, 9, 10]
</pre>



<p><a name="k11"></a></p>
<h2 id="k11">11. Další možnosti získání řezu: čím se C3 odlišuje od dalších jazyků</h2>

<p>Některé programovací jazyky nabízí možnost zápisu záporných indexů, což
značí, že prvky budou indexovány od konce pole, nikoli od jeho začátku.
V&nbsp;programovacím jazyku C3 však byla zvolena odlišná syntaxe &ndash;
namísto záporných prvků se provádí zápis <strong>^i</strong>, který je převeden
na <strong>len-i</strong>, kde <strong>len</strong> je délka pole:</p>

<pre>
module containers;
import std::io;
&nbsp;
fn void <strong>main</strong>()
{
    int[10] a = {1, 2, 3, 4, 5, 6, 7, 8, 9, 10};
    io::printf("a=%s\n", a);
&nbsp;
    int[] b = a[^6..^3];
    io::printf("b=%s\n", b);
&nbsp;
    int[] c = a[..^3];
    io::printf("c=%s\n", c);
&nbsp;
    int[] d = a[^6..];
    io::printf("d=%s\n", d);
&nbsp;
    int[] e = a[..];
    io::printf("e=%s\n", e);
}
</pre>

<p>Podívejme se na výsledky, které získáme po překladu a spuštění tohoto
příkladu a které ukazují, jakým způsobem jsou prvky vybírány od konce pole,
nikoli od jeho začátku:</p>

<pre>
a=[1, 2, 3, 4, 5, 6, 7, 8, 9, 10]
b=[5, 6, 7, 8]
c=[1, 2, 3, 4, 5, 6, 7, 8]
d=[5, 6, 7, 8, 9, 10]
e=[1, 2, 3, 4, 5, 6, 7, 8, 9, 10]
</pre>

<p>Taktéž je možné prvky vybírat ještě jedním stylem, konkrétně specifikací
prvního prvku a požadované délky řezu. Nyní se namísto dvojtečky zapsané
vertikálně použije dvojtečka zapsaná horizontálně:</p>

<pre>
module containers;
import std::io;
&nbsp;
fn void <strong>main</strong>()
{
    int[10] a = {1, 2, 3, 4, 5, 6, 7, 8, 9, 10};
    io::printf("a=%s\n", a);
&nbsp;
    int[] b = a[3 : 4];
    io::printf("b=%s\n", b);
&nbsp;
    int[] c = a[3 : 0];
    io::printf("c=%s\n", c);
&nbsp;
    int[] d = a[^6 : 4];
    io::printf("d=%s\n", d);
}
</pre>

<p>Nyní budou výsledky odlišné, ovšem povšimněte si, že počet prvků v&nbsp;řezu
nyní přesně odpovídá druhé zapsané hodnotě:</p>

<pre>
a=[1, 2, 3, 4, 5, 6, 7, 8, 9, 10]
b=[4, 5, 6, 7]
c=[]
d=[5, 6, 7, 8]
</pre>

<p><div class="rs-tip-major">Poznámka: současně se jedná o matoucí syntaktický
prvek programovacího jazyka C3, neboť v&nbsp;některých jiných jazycích má
dvojtečka odlišný význam odpovídající spíše zápisu ..</div></p>



<p><a name="k12"></a></p>
<h2 id="k12">12. Řezy získané z&nbsp;jiných řezů</h2>

<p>Při konstrukci řezů nejsme omezeni jen na provádění výseku pole. Stejnou
operaci totiž můžeme v&nbsp;případě potřeby provést i s&nbsp;jiným řezem, což
je ukázáno na následujícím demonstračním příkladu, ve kterém z&nbsp;původního
desetiprvkového pole vytvoříme řez s&nbsp;prvky kromě prvního a posledního.
Tuto operaci postupně opakujeme, přičemž další řezy jsou vytvořeny z&nbsp;řezu
předchozího:</p>

<pre>
module containers;
import std::io;
&nbsp;
fn void <strong>main</strong>()
{
    int[10] a = {1, 2, 3, 4, 5, 6, 7, 8, 9, 10};
    io::printf("a=%s\n", a);
&nbsp;
    int[] b = a[1 .. ^2];
    io::printf("b=%s\n", b);
&nbsp;
    int[] c = b[1 .. ^2];
    io::printf("c=%s\n", c);
&nbsp;
    int[] d = c[1 .. ^2];
    io::printf("d=%s\n", d);
&nbsp;
    int[] e = d[1 .. ^2];
    io::printf("e=%s\n", e);
}
</pre>

<p>Výsledky jasně ukazují, jak je postupné tvoření výseků bez prvního a
posledního prvku prováděno:</p>

<pre>
a=[1, 2, 3, 4, 5, 6, 7, 8, 9, 10]
b=[2, 3, 4, 5, 6, 7, 8, 9]
c=[3, 4, 5, 6, 7, 8]
d=[4, 5, 6, 7]
e=[5, 6]
</pre>



<p><a name="k13"></a></p>
<h2 id="k13">13. Kontejner typu seznam (<i>list</i>)</h2>

<p>Dalším typem kontejneru je seznam neboli <i>list</i>. Ten již není
podporován přímo syntaxí programovacího jazyka C3, ale jedná se o kontejner
realizovaný v&nbsp;knihovně <strong>std::collections::list</strong>. Tento
datový typ je (opět) striktně typovaný, takže je nutné dopředu určit typ prvků
seznamu. Nejjednodušší je definice typového aliasu (podrobnosti si uvedeme
příště):</p>

<pre>
alias ListInt = List {int};
</pre>

<p>Prvky se do seznamu přidávají metodou <strong>push</strong> a navíc se
(většinou) musíme postarat o alokaci i dealokaci paměti. V&nbsp;tom
nejjednodušším případě může práce se seznamem vypadat následovně:</p>

<pre>
module containers;
import std::io;
import std::collections::list;
&nbsp;
alias ListInt = List {int};
&nbsp;
fn void <strong>main</strong>()
{
    ListInt a;
&nbsp;
    a.init(mem);
&nbsp;
    for (int i=0; i&lt;10; i++) {
        a.push(i+1);
    }
&nbsp;
    io::printf("a=%s\n", a);
&nbsp;
    a.free();
}
</pre>

<p>Tento demonstrační příklad po svém překladu a spuštění vypíše obsah seznamu,
do kterého bylo postupně (dynamicky, v&nbsp;čase běhu aplikace) přidáno deset
prvků:</p>

<pre>
a=[1, 2, 3, 4, 5, 6, 7, 8, 9, 10]
</pre>

<p><div class="rs-tip-major">Poznámka: kromě metody <strong>push</strong> je
definováno i několik dalších metod určených pro práci se seznamy. S&nbsp;těmi
se seznámíme později, ovšem většinou se nejedná o žádné překvapivé chování.
Užitečné taktéž je, že celý seznam je možné vytisknout funkcí
<strong>io::printf</strong> i dalšími funkcemi z&nbsp;balíčku
<strong>io</strong>.</div></p>



<p><a name="k14"></a></p>
<h2 id="k14">14. Předání seznamu do funkcí</h2>

<p>Opět si, podobně jako v&nbsp;případě vektorů, polí i řezů, vyzkoušíme, jak
se chová kontejner typu seznam v&nbsp;případě, že ho předáme do funkce,
v&nbsp;níž se jednotlivé prvky seznamu budou modifikovat (mimochodem &ndash;
pomocí operátoru indexování, tj.s&nbsp;využitím hranatých závorek). Povšimněte
si jedné změny &ndash; délka seznamu (tedy počet v&nbsp;něm uložených prvků) se
zjišťuje <i>metodou</i> nazvanou <strong>len</strong>, nikoli <i>atributem</i>
se stejným jménem:</p>

<pre>
module containers;
import std::io;
import std::collections::list;
&nbsp;
alias ListInt = List {int};
&nbsp;
fn void <strong>update_list</strong>(ListInt lst) {
    for (int i=0; i&lt;lst.len(); i++) {
        lst[i] = (i + 1)*10;
    }
}
&nbsp;
fn void <strong>main</strong>()
{
    ListInt a;
&nbsp;
    a.init(mem);
&nbsp;
    for (int i=0; i&lt;10; i++) {
        a.push(i+1);
    }
&nbsp;
    io::printf("a=%s\n", a);
&nbsp;
    update_list(a);
    io::printf("a=%s\n", a);
&nbsp;
    a.free();
}
</pre>

<p>Po překladu a spuštění tohoto demonstračního příkladu zjistíme, že seznam je
možné ve funkci modifikovat. Je tomu tak z&nbsp;toho důvodu, že samotná
struktura seznamu se sice předává hodnotou, ovšem interně seznam obsahuje
ukazatele (reference) na jednotlivé prvky:</p>

<pre>
a=[1, 2, 3, 4, 5, 6, 7, 8, 9, 10]
a=[10, 20, 30, 40, 50, 60, 70, 80, 90, 100]
</pre>



<p><a name="k15"></a></p>
<h2 id="k15">15. Dynamicky alokované pole</h2>

<p>V&nbsp;programovacím jazyku C je možné alokovat pole funkcí nazvanou
<strong>malloc</strong>, protože (poněkud zjednodušeně řečeno) odpovídá výraz
<strong>pole[n]</strong> přístupu k&nbsp;n-tému prvku pole přes ukazatel (na
začátek pole) a vypočítaný offset, tedy výrazu <strong>*(pole+n)</strong>. Jen
na okraj: to ovšem znamená, že můžeme psát i <strong>n[pole]</strong>, tedy
například <strong>2[a]</strong>, i když to může vypadat podivně. I
v&nbsp;jazyku C3 lze podobným postupem vytvářet dynamicky alokovaná pole.
Dokonce se k&nbsp;tomuto účelu používají stejně pojmenované funkce
<strong>malloc</strong> (alokace pole, resp.&nbsp;obecně alokace bloku paměti)
a <strong>free</strong> (uvolnění dříve alokované paměti). Liší se však způsob
výpočtu velikosti alokovaného bloku, protože se namísto operátoru
<strong>sizeof</strong> využívá zápis <strong>jméno_type.sizeof</strong>:</p>

<pre>
int *a;
&nbsp;
a=malloc(SIZE * int.sizeof);
</pre>

<p><div class="rs-tip-major">Poznámka: vzhledem k&nbsp;tomu, že funkce
<strong>malloc</strong> a <strong>free</strong> jsou dostupné i ve výchozím
jmenném prostoru, není zapotřebí provádět jejich import.</div></p>

<p>Jakmile je pole alokováno výše zmíněnou funkcí <strong>malloc</strong>, je
možné k&nbsp;jeho prvkům přistupovat jak přes ukazatel, tak i zápisem
<strong>a[i]</strong>, přičemž ve druhém případě jazyk sám vypočte příslušnou
adresu. Ukažme si to na jednoduchém demonstračním příkladu:</p>

<pre>
module containers;
import std::io;
&nbsp;
const int SIZE = 10;
&nbsp;
fn void <strong>main</strong>()
{
    int *a;
&nbsp;
    a=malloc(SIZE * int.sizeof);
&nbsp;
    for (int i=0; i&lt;SIZE; i++) {
        io::printf("%d ", a[i]);
    }
    io::printn();
&nbsp;
    for (int i=0; i&lt;SIZE; i++) {
        a[i] = (i + 1)*10;
    }
&nbsp;
    for (int i=0; i&lt;SIZE; i++) {
        io::printf("%d ", a[i]);
    }
    io::printn();
&nbsp;
    free(a);
}
</pre>

<p>Po překladu a spuštění tohoto příkladu se nejdříve vypíše původní obsah pole
(zde konkrétně nuly, ale nemusí tomu tak být) a posléze obsah pole po
modifikaci obsahu všech jeho prvků:</p>

<pre>
0 0 0 0 0 0 0 0 0 0
10 20 30 40 50 60 70 80 90 100
</pre>

<p><div class="rs-tip-major">Poznámka: v&nbsp;jazyku C3 je vhodné stále
rozlišovat dynamicky alokované pole typu <strong>typ_prvku*</strong> od řezu
typu <strong>typ_prvku[]</strong>.</div></p>



<p><a name="k16"></a></p>
<h2 id="k16">16. Různé varianty řetězců</h2>

<p>Posledním datovým typem, se kterým se v&nbsp;dnešním článku alespoň ve
stručnosti seznámíme, jsou řetězce. Těch existuje několik typů. Nejčastěji se
setkáme s&nbsp;typy <strong>String</strong>, <strong>ZString</strong> a
<strong>DString</strong> (ovšem existuje i obdoba &bdquo;širokých&ldquo;
řetězců <strong>WString</strong>). Nejdříve se zaměřme na první typ, tedy
<strong>String</strong>. Jedná se o řetězce, které interně obsahují atribut
s&nbsp;délkou (<strong>len</strong>) a vlastní sekvenci znaků. Jedná se tedy o
určitou obdobu řetězců známých z&nbsp;jazyka Pascal. Práce s&nbsp;takovými
řetězci je snadná; v&nbsp;dalším příkladu je kromě jejich deklarace ukázán i
způsob získání podřetězce operátorem řezu (<i>slice</i>):</p>

<pre>
module containers;
import std::io;
&nbsp;
fn void <strong>main</strong>()
{
    String s = "Hello world!";
&nbsp;
    io::printf("string '%s' has length %d bytes\n", s, s.len);
&nbsp;
    io::printf("1st char=%s\n", s[0]);
&nbsp;
    String substr = s[6..^1];
    io::printf("substr=%s\n", substr);
}
</pre>

<p>Po spuštění tohoto demonstračního příkladu se vypíše délka řetězce, ASCII
hodnota jeho prvního znaku a taktéž vybraný podřetězec:</p>

<pre>
string 'Hello world!' has length 12 bytes
1st char=72
substr=world!
</pre>

<p>Zbývá nám ověřit, zda atribut <strong>len</strong> obsahuje délku vyjádřenou
ve znacích (resp.&nbsp;glyfech) nebo v&nbsp;bajtech. Víme již, že jazyk C3 plně
podporuje Unicode, takže do řetězce vložíme několik znaků
s&nbsp;nabodeníčky:</p>

<pre>
module containers;
import std::io;
&nbsp;
fn void <strong>main</strong>()
{
    String s = "ěščřžýáíéů";
&nbsp;
    io::printf("string '%s' has length %d bytes\n", s, s.len);
&nbsp;
    io::printf("1st char=%s\n", s[0]);
&nbsp;
    String substr = s[2..7];
    io::printf("substr=%s\n", substr);
}
</pre>

<p>Nyní se vypíšou odlišné hodnoty. Řetězec bude mít délku dvaceti bajtů (ovšem
má jen deset glyfů). Zajímavé je také zjištění, jak pracuje operace řezu
&ndash; ta počítá s&nbsp;indexy bajtů a nikoli znaků! To může vést
k&nbsp;mnohdy těžko odhalitelným problémům:</p>

<pre>
string 'ěščřžýáíéů' has length 20 bytes
1st char=196
substr=ščř
</pre>

<p><div class="rs-tip-major">Poznámka: operaci řezu můžeme zapsat i tak, že
bude začínat &bdquo;uprostřed&ldquo; kódu glyfu (vyzkoušejte si to zápisem
<strong>s[1..6]</strong> atd.). Výsledky sice budou stále konzistentní, ovšem
většinou těžko využitelné.</div></p>



<p><a name="k17"></a></p>
<h2 id="k17">17. Řetězce ukončené nulou</h2>

<p>Programovací jazyk C3 podporuje i céčkovské řetězce ukončené nulou (někdy se setkáme s&nbsp;označením <strong>ASCIIZ</strong>).</p>

<pre>
module containers;
import std::io;
&nbsp;
fn void <strong>main</strong>()
{
    ZString s = "Hello world!\0";
&nbsp;
    io::printf("zstring '%s' has length %d bytes\n", s, s.len());
}
</pre>

<p></p>

<pre>
zstring 'Hello world!' has length 12 bytes
</pre>

<p></p>

<pre>
module containers;
import std::io;
&nbsp;
fn void <strong>main</strong>()
{
    ZString s = "ěščřžýáíéů\0";
&nbsp;
    io::printf("zstring '%s' has length %d bytes\n", s, s.len());
}
</pre>

<p></p>

<pre>
zstring 'ěščřžýáíéů' has length 20 bytes
</pre>



<p><a name="k18"></a></p>
<h2 id="k18">18. Porovnání řetězců</h2>

<p>Řetězce je možné porovnávat s&nbsp;využitím operátorů == a != (nikoli však
dalších operátorů). Zde je vhodné upozornit na to, že se chování jazyka C3 může
odlišovat od jiných jazyků, v&nbsp;nichž se mohou pomocí stejných operátorů
porovnávat reference, tj.&nbsp;fakt, zda jsou dva řetězce umístěny ve stejné
oblasti operační paměti.</p>

<p>V&nbsp;dalším demonstračním příkladu jsou porovnány nikoli pouze konstantní
řetězce, ale i řetězec vůči řezu jiného řetězce:</p>

<pre>
module containers;
import std::io;
&nbsp;
fn void <strong>main</strong>()
{
    String s1 = "prvni";
    String s2 = "druhy";
    String s3 = "prvni";
    String s4 = "***druhy***";
    String s5;
&nbsp;
    io::printf("s1 == s2: %d\n", s1 == s2);
    io::printf("s1 != s2: %d\n", s1 != s2);
&nbsp;
    s5 = s4[3..7];
&nbsp;
    io::printf("s1 == s3: %d\n", s1 == s3);
    io::printf("s2 == s5: %d\n", s2 == s5);
}
</pre>

<p>Nuly znamenají, že výraz vrátil nepravdu (False), jednička znamená pravdu
(True):</p>

<pre>
s1 == s2: 0
s1 != s2: 1
s1 == s3: 1
s2 == s5: 1
</pre>



<p><a name="k19"></a></p>
<h2 id="k19">19. Repositář s&nbsp;demonstračními příklady</h2>

<p>Demonstrační příklady vytvořené pro nejnovější verzi programovacího jazyka
C3 byly uloženy do repositáře dostupného na adrese <a
href="https://github.com/tisnik/c3-examples">https://github.com/tisnik/c3-examples</a>.
Následují odkazy na jednotlivé příklady (či jejich nedokončené části).</p>

<p>Demonstrační příklady <a
href="https://www.root.cz/clanky/programovaci-jazyk-c3-evoluce-nikoli-revoluce/">z&nbsp;prvního
článku o jazyku C3</a>:</p>

<table>
<tr><th> #</th><th>Příklad</th><th>Stručný popis</th><th>Adresa</th></tr>
<tr><td> 1</td><td>factorial.c3</td><td>realizace výpočtu faktoriálu</td><td><a href="https://github.com/tisnik/c3-examples/blob/master/introduction/factorial.c3">https://github.com/tisnik/c3-examples/blob/master/introduction/factorial.c3</a></td></tr>
<tr><td> 2</td><td>factorial_macro.c3</td><td>výpočet faktoriálu konkrétní hodnoty implementovaný formou makra</td><td><a href="https://github.com/tisnik/c3-examples/blob/master/introduction/factorial_macro.c3">https://github.com/tisnik/c3-examples/blob/master/introduction/factorial_macro.c3</a></td></tr>
<tr><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td></tr>
<tr><td> 3</td><td>swap_macro.c3</td><td>makro realizující prohození dvou hodnot</td><td><a href="https://github.com/tisnik/c3-examples/blob/master/introduction/swap_macro.c3">https://github.com/tisnik/c3-examples/blob/master/introduction/swap_macro.c3</a></td></tr>
<tr><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td></tr>
<tr><td> 4</td><td>renderer.c</td><td>výpočet a vykreslení Juliovy množiny implementovaný v&nbsp;jazyku C</td><td><a href="https://github.com/tisnik/c3-examples/blob/master/introduction/renderer.c">https://github.com/tisnik/c3-examples/blob/master/introduction/renderer.c</a></td></tr>
<tr><td> 5</td><td>renderer_v1.c3</td><td>definice datové struktury s&nbsp;rozměry rastrového obrázku a skeleton všech funkcí</td><td><a href="https://github.com/tisnik/c3-examples/blob/master/introduction/renderer_v1.c3">https://github.com/tisnik/c3-examples/blob/master/introduction/renderer_v1.c3</a></td></tr>
<tr><td> 6</td><td>renderer_v2.c3</td><td>anotace parametrů funkcí typu ukazatel (<i>pointer</i>)</td><td><a href="https://github.com/tisnik/c3-examples/blob/master/introduction/renderer_v2.c3">https://github.com/tisnik/c3-examples/blob/master/introduction/renderer_v2.c3</a></td></tr>
<tr><td> 7</td><td>renderer_v3.c3</td><td>statická kontrola, zda se nepředávají neinicializované ukazatele</td><td><a href="https://github.com/tisnik/c3-examples/blob/master/introduction/renderer_v3.c3">https://github.com/tisnik/c3-examples/blob/master/introduction/renderer_v3.c3</a></td></tr>
<tr><td> 8</td><td>renderer_v4.c3</td><td>runtime kontrola, zda se nepředávají neinicializované ukazatele</td><td><a href="https://github.com/tisnik/c3-examples/blob/master/introduction/renderer_v4.c3">https://github.com/tisnik/c3-examples/blob/master/introduction/renderer_v4.c3</a></td></tr>
<tr><td> 9</td><td>renderer_v5.c3</td><td>první (nekorektní) varianta funkce pro inicializaci barvové palety</td><td><a href="https://github.com/tisnik/c3-examples/blob/master/introduction/renderer_v5.c3">https://github.com/tisnik/c3-examples/blob/master/introduction/renderer_v5.c3</a></td></tr>
<tr><td>10</td><td>renderer_v6.c3</td><td>druhá (korektní) varianta funkce pro inicializaci barvové palety</td><td><a href="https://github.com/tisnik/c3-examples/blob/master/introduction/renderer_v6.c3">https://github.com/tisnik/c3-examples/blob/master/introduction/renderer_v6.c3</a></td></tr>
<tr><td>11</td><td>renderer_v7.c3</td><td>volání knihovní I/O funkce a volání nativní céčkovské funkce</td><td><a href="https://github.com/tisnik/c3-examples/blob/master/introduction/renderer_v7.c3">https://github.com/tisnik/c3-examples/blob/master/introduction/renderer_v7.c3</a></td></tr>
<tr><td>12</td><td>renderer_v8.c3</td><td>plně funkční program pro výpočet a vykreslení Juliovy množiny</td><td><a href="https://github.com/tisnik/c3-examples/blob/master/introduction/renderer_v8.c3">https://github.com/tisnik/c3-examples/blob/master/introduction/renderer_v8.c3</a></td></tr>
</table>

<p>Demonstrační příklady <a
href="https://www.root.cz/clanky/programovaci-jazyk-c3-datove-typy-pro-moderni-architektury/">ze
druhého článku o jazyku C3</a>:</p>

<table>
<tr><th> #</th><th>Příklad</th><th>Stručný popis</th><th>Adresa</th></tr>
<tr><td>13</td><td>01_just_main.c3</td><td>struktura nejjednoduššího programu obsahujícího pouze prázdnou funkci <strong>main</strong></td><td><a href="https://github.com/tisnik/c3-examples/blob/master/c3-basics/01_just_main.c3">https://github.com/tisnik/c3-examples/blob/master/c3-basics/01_just_main.c3</a></td></tr>
<tr><td>14</td><td>02_module_name.c3</td><td>struktura programu s&nbsp;uvedeným plným jménem modulu</td><td><a href="https://github.com/tisnik/c3-examples/blob/master/c3-basics/02_module_name.c3">https://github.com/tisnik/c3-examples/blob/master/c3-basics/02_module_name.c3</a></td></tr>
<tr><td>15</td><td>03_hello_world.c3</td><td>klasický program typu &bdquo;Hello, world!&ldquo; napsaný v&nbsp;jazyku C3</td><td><a href="https://github.com/tisnik/c3-examples/blob/master/c3-basics/03_hello_world.c3">https://github.com/tisnik/c3-examples/blob/master/c3-basics/03_hello_world.c3</a></td></tr>
<tr><td>16</td><td>04_exit_value.c3</td><td>ukončení procesu s&nbsp;předáním návratového kódu zpět volajícímu programu</td><td><a href="https://github.com/tisnik/c3-examples/blob/master/c3-basics/04_exit_value.c3">https://github.com/tisnik/c3-examples/blob/master/c3-basics/04_exit_value.c3</a></td></tr>
<tr><td>17</td><td>05_c_function.c3</td><td>zavolání funkce definované v&nbsp;knihovně programovacího jazyka C</td><td><a href="https://github.com/tisnik/c3-examples/blob/master/c3-basics/05_c_function.c3">https://github.com/tisnik/c3-examples/blob/master/c3-basics/05_c_function.c3</a></td></tr>
<tr><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td></tr>
<tr><td>18</td><td>06_bool_type.c3</td><td>definice proměnných typu <i>pravdivostní hodnota</i> (<strong>bool</strong>)</td><td><a href="https://github.com/tisnik/c3-examples/blob/master/c3-basics/06_bool_type.c3">https://github.com/tisnik/c3-examples/blob/master/c3-basics/06_bool_type.c3</a></td></tr>
<tr><td>19</td><td>07_int_to_bool.c3</td><td>implicitní převod hodnoty typu <strong>int</strong> na pravdivostní hodnotu (nekorektní řešení)</td><td><a href="https://github.com/tisnik/c3-examples/blob/master/c3-basics/07_int_to_bool.c3">https://github.com/tisnik/c3-examples/blob/master/c3-basics/07_int_to_bool.c3</a></td></tr>
<tr><td>20</td><td>08_int_to_bool.c3</td><td>explicitní převod hodnoty typu <strong>int</strong> na pravdivostní hodnotu (korektní řešení)</td><td><a href="https://github.com/tisnik/c3-examples/blob/master/c3-basics/08_int_to_bool.c3">https://github.com/tisnik/c3-examples/blob/master/c3-basics/08_int_to_bool.c3</a></td></tr>
<tr><td>21</td><td>09_int_to_bool.c3</td><td>explicitní převod hodnoty typu <strong>int</strong> na pravdivostní hodnotu (nekorektní řešení)</td><td><a href="https://github.com/tisnik/c3-examples/blob/master/c3-basics/09_int_to_bool.c3">https://github.com/tisnik/c3-examples/blob/master/c3-basics/09_int_to_bool.c3</a></td></tr>
<tr><td>22</td><td>10_bool_sizeof.c3</td><td>zjištění velikosti paměti obsazené hodnotou typu <strong>bool</strong></td><td><a href="https://github.com/tisnik/c3-examples/blob/master/c3-basics/10_bool_sizeof.c3">https://github.com/tisnik/c3-examples/blob/master/c3-basics/10_bool_sizeof.c3</a></td></tr>
<tr><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td></tr>
<tr><td>23</td><td>11_int_types.c3</td><td>definice proměnných typu <i>celé číslo se znaménkem</i> s&nbsp;různou bitovou šířkou</td><td><a href="https://github.com/tisnik/c3-examples/blob/master/c3-basics/11_int_types.c3">https://github.com/tisnik/c3-examples/blob/master/c3-basics/11_int_types.c3</a></td></tr>
<tr><td>24</td><td>12_uint_types.c3</td><td>definice proměnných typu <i>celé číslo bez znaménka</i> s&nbsp;různou bitovou šířkou</td><td><a href="https://github.com/tisnik/c3-examples/blob/master/c3-basics/12_uint_types.c3">https://github.com/tisnik/c3-examples/blob/master/c3-basics/12_uint_types.c3</a></td></tr>
<tr><td>25</td><td>13_no_suffixes.c3</td><td>celočíselné konstanty bez uvedení suffixu (bitové šířky)</td><td><a href="https://github.com/tisnik/c3-examples/blob/master/c3-basics/13_no_suffixes.c3">https://github.com/tisnik/c3-examples/blob/master/c3-basics/13_no_suffixes.c3</a></td></tr>
<tr><td>26</td><td>14_suffixes.c3</td><td>celočíselné konstanty s&nbsp;uvedením sufficu (bitové šířky)</td><td><a href="https://github.com/tisnik/c3-examples/blob/master/c3-basics/14_suffixes.c3">https://github.com/tisnik/c3-examples/blob/master/c3-basics/14_suffixes.c3</a></td></tr>
<tr><td>27</td><td>15_int_sizeof.c3</td><td>zjištění velikosti paměti obsazené celočíselnými hodnotami se znaménkem</td><td><a href="https://github.com/tisnik/c3-examples/blob/master/c3-basics/15_int_sizeof.c3">https://github.com/tisnik/c3-examples/blob/master/c3-basics/15_int_sizeof.c3</a></td></tr>
<tr><td>28</td><td>16_uint_sizeof.c3</td><td>zjištění velikosti paměti obsazené celočíselnými hodnotami bez znaménka</td><td><a href="https://github.com/tisnik/c3-examples/blob/master/c3-basics/16_uint_sizeof.c3">https://github.com/tisnik/c3-examples/blob/master/c3-basics/16_uint_sizeof.c3</a></td></tr>
<tr><td>29</td><td>17_int_conversions.c3</td><td>korektní převody mezi celočíselnými hodnotami s&nbsp;různou bitovou šířkou</td><td><a href="https://github.com/tisnik/c3-examples/blob/master/c3-basics/17_int_conversions.c3">https://github.com/tisnik/c3-examples/blob/master/c3-basics/17_int_conversions.c3</a></td></tr>
<tr><td>30</td><td>18_int_conversions.c3</td><td>nekorektní převody mezi celočíselnými hodnotami s&nbsp;různou bitovou šířkou</td><td><a href="https://github.com/tisnik/c3-examples/blob/master/c3-basics/18_int_conversions.c3">https://github.com/tisnik/c3-examples/blob/master/c3-basics/18_int_conversions.c3</a></td></tr>
<tr><td>31</td><td>19_int_conversions.c3</td><td>explicitní převody a přetečení hodnot</td><td><a href="https://github.com/tisnik/c3-examples/blob/master/c3-basics/19_int_conversions.c3">https://github.com/tisnik/c3-examples/blob/master/c3-basics/19_int_conversions.c3</a></td></tr>
<tr><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td></tr>
<tr><td>32</td><td>20_float_types.c3</td><td>definice proměnných typu <i>numerická hodnota s&nbsp;plovoucí řádovou čárkou (tečkou)</i></td><td><a href="https://github.com/tisnik/c3-examples/blob/master/c3-basics/20_float_types.c3">https://github.com/tisnik/c3-examples/blob/master/c3-basics/20_float_types.c3</a></td></tr>
<tr><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td></tr>
<tr><td>33</td><td>21_vector_type.c3</td><td>definice vektoru obsahujícího celočíselné hodnoty</td><td><a href="https://github.com/tisnik/c3-examples/blob/master/c3-basics/21_vector_type.c3">https://github.com/tisnik/c3-examples/blob/master/c3-basics/21_vector_type.c3</a></td></tr>
<tr><td>34</td><td>22_vector_operations.c3</td><td>základní operace s&nbsp;celými vektory</td><td><a href="https://github.com/tisnik/c3-examples/blob/master/c3-basics/22_vector_operations.c3">https://github.com/tisnik/c3-examples/blob/master/c3-basics/22_vector_operations.c3</a></td></tr>
<tr><td>35</td><td>23_vector_sizes.c3</td><td>zjištění a tisk velikosti vektorů (různé datové typy prvků vektorů, shodná délka)</td><td><a href="https://github.com/tisnik/c3-examples/blob/master/c3-basics/23_vector_sizes.c3">https://github.com/tisnik/c3-examples/blob/master/c3-basics/23_vector_sizes.c3</a></td></tr>
<tr><td>36</td><td>24_vector_sizes.c3</td><td>zjištění a tisk velikosti vektorů (stejné datové typy prvků vektorů, odlišná délka)</td><td><a href="https://github.com/tisnik/c3-examples/blob/master/c3-basics/24_vector_sizes.c3">https://github.com/tisnik/c3-examples/blob/master/c3-basics/24_vector_sizes.c3</a></td></tr>
</table>

<p>Demonstrační příklady z&nbsp;dnešního článku o jazyku C3:</p>

<table>
<tr><th> #</th><th>Příklad</th><th>Stručný popis</th><th>Adresa</th></tr>
<tr><td>37</td><td>01_vector_type.c3</td><td>definice vektoru, modifikace prvků vektoru, tisk obsahu celého vektoru</td><td><a href="https://github.com/tisnik/c3-examples/blob/master/c3-containers/01_vector_type.c3">https://github.com/tisnik/c3-examples/blob/master/c3-containers/01_vector_type.c3</a></td></tr>
<tr><td>38</td><td>02_vector_parameter.c3</td><td>předání vektoru do funkce hodnotou</td><td><a href="https://github.com/tisnik/c3-examples/blob/master/c3-containers/02_vector_parameter.c3">https://github.com/tisnik/c3-examples/blob/master/c3-containers/02_vector_parameter.c3</a></td></tr>
<tr><td>39</td><td>03_vector_pointer.c3</td><td>předání vektoru do funkce odkazem (přes ukazatel)</td><td><a href="https://github.com/tisnik/c3-examples/blob/master/c3-containers/03_vector_pointer.c3">https://github.com/tisnik/c3-examples/blob/master/c3-containers/03_vector_pointer.c3</a></td></tr>
<tr><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td></tr>
<tr><td>40</td><td>04_array_type.c3</td><td>definice pole, modifikace prvků pole, tisk obsahu celého pole</td><td><a href="https://github.com/tisnik/c3-examples/blob/master/c3-containers/04_array_type.c3">https://github.com/tisnik/c3-examples/blob/master/c3-containers/04_array_type.c3</a></td></tr>
<tr><td>41</td><td>05_array_parameter.c3</td><td>předání pole do funkce hodnotou</td><td><a href="https://github.com/tisnik/c3-examples/blob/master/c3-containers/05_array_parameter.c3">https://github.com/tisnik/c3-examples/blob/master/c3-containers/05_array_parameter.c3</a></td></tr>
<tr><td>42</td><td>06_array_pointer.c3</td><td>předání pole do funkce odkazem (přes ukazatel)</td><td><a href="https://github.com/tisnik/c3-examples/blob/master/c3-containers/06_array_pointer.c3">https://github.com/tisnik/c3-examples/blob/master/c3-containers/06_array_pointer.c3</a></td></tr>
<tr><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td></tr>
<tr><td>43</td><td>07_slice_type.c3</td><td>vytvoření (konstrukce) řezu (<i>slice</i>)</td><td><a href="https://github.com/tisnik/c3-examples/blob/master/c3-containers/07_slice_type.c3">https://github.com/tisnik/c3-examples/blob/master/c3-containers/07_slice_type.c3</a></td></tr>
<tr><td>44</td><td>08_slice_parameter.c3</td><td>předání řezu do funkce</td><td><a href="https://github.com/tisnik/c3-examples/blob/master/c3-containers/08_slice_parameter.c3">https://github.com/tisnik/c3-examples/blob/master/c3-containers/08_slice_parameter.c3</a></td></tr>
<tr><td>45</td><td>09_slice_slicing.c3</td><td>konstrukce řezu z&nbsp;pole stejně pojmenovanou operací (řez od..do)</td><td><a href="https://github.com/tisnik/c3-examples/blob/master/c3-containers/09_slice_slicing.c3">https://github.com/tisnik/c3-examples/blob/master/c3-containers/09_slice_slicing.c3</a></td></tr>
<tr><td>46</td><td>10_slice_slicing.c3</td><td>konstrukce řezu z&nbsp;pole stejně pojmenovanou operací (záporné indexy)</td><td><a href="https://github.com/tisnik/c3-examples/blob/master/c3-containers/10_slice_slicing.c3">https://github.com/tisnik/c3-examples/blob/master/c3-containers/10_slice_slicing.c3</a></td></tr>
<tr><td>47</td><td>11_slice_slicing.c3</td><td>konstrukce řezu z&nbsp;pole stejně pojmenovanou operací (určení délky řezu)</td><td><a href="https://github.com/tisnik/c3-examples/blob/master/c3-containers/11_slice_slicing.c3">https://github.com/tisnik/c3-examples/blob/master/c3-containers/11_slice_slicing.c3</a></td></tr>
<tr><td>48</td><td>12_slice_of_slice.c3</td><td>konstrukce řezu z&nbsp;jiného řezu</td><td><a href="https://github.com/tisnik/c3-examples/blob/master/c3-containers/12_slice_of_slice.c3">https://github.com/tisnik/c3-examples/blob/master/c3-containers/12_slice_of_slice.c3</a></td></tr>
<tr><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td></tr>
<tr><td>49</td><td>13_list_type.c3</td><td>vytvoření (konstrukce) seznamu</td><td><a href="https://github.com/tisnik/c3-examples/blob/master/c3-containers/13_list_type.c3">https://github.com/tisnik/c3-examples/blob/master/c3-containers/13_list_type.c3</a></td></tr>
<tr><td>50</td><td>14_list_parameter.c3</td><td>předání seznamu do funkce</td><td><a href="https://github.com/tisnik/c3-examples/blob/master/c3-containers/14_list_parameter.c3">https://github.com/tisnik/c3-examples/blob/master/c3-containers/14_list_parameter.c3</a></td></tr>
<tr><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td></tr>
<tr><td>51</td><td>15_dynamic_array.c3</td><td>vytvoření (konstrukce) dynamicky alokovaného pole</td><td><a href="https://github.com/tisnik/c3-examples/blob/master/c3-containers/15_dynamic_array.c3">https://github.com/tisnik/c3-examples/blob/master/c3-containers/15_dynamic_array.c3</a></td></tr>
<tr><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td></tr>
<tr><td>52</td><td>16_string_type.c3</td><td>základní typ řetězce <strong>string</strong></td><td><a href="https://github.com/tisnik/c3-examples/blob/master/c3-containers/16_string_type.c3">https://github.com/tisnik/c3-examples/blob/master/c3-containers/16_string_type.c3</a></td></tr>
<tr><td>53</td><td>17_string_unicode.c3</td><td>Unicode znaky v&nbsp;řetězci typu <strong>string</strong></td><td><a href="https://github.com/tisnik/c3-examples/blob/master/c3-containers/17_string_unicode.c3">https://github.com/tisnik/c3-examples/blob/master/c3-containers/17_string_unicode.c3</a></td></tr>
<tr><td>54</td><td>18_zstring_type.c3</td><td>řetězce ukončené nulou (C-string, ASCIIZ)</td><td><a href="https://github.com/tisnik/c3-examples/blob/master/c3-containers/18_zstring_type.c3">https://github.com/tisnik/c3-examples/blob/master/c3-containers/18_zstring_type.c3</a></td></tr>
<tr><td>55</td><td>19_zstring_unicode.c3</td><td>Unicode znaky v&nbsp;řetězci typu <strong>zstring</strong></td><td><a href="https://github.com/tisnik/c3-examples/blob/master/c3-containers/19_zstring_unicode.c3">https://github.com/tisnik/c3-examples/blob/master/c3-containers/19_zstring_unicode.c3</a></td></tr>
<tr><td>56</td><td>20_string_comparison.c3</td><td>porovnávání obsahu řetězců</td><td><a href="https://github.com/tisnik/c3-examples/blob/master/c3-containers/20_string_comparison.c3">https://github.com/tisnik/c3-examples/blob/master/c3-containers/20_string_comparison.c3</a></td></tr>
</table>



<p><a name="k20"></a></p>
<h2 id="k20">20. Odkazy na Internetu</h2>

<ol>

<li>The C3 Programming Language<br />
<a href="https://c3-lang.org/">https://c3-lang.org/</a>
</li>

<li>C3 For C Programmers<br />
<a href="https://c3-lang.org/language-overview/primer/">https://c3-lang.org/language-overview/primer/</a>
</li>

<li>C3 is a C-like language trying to be an incremental improvement over C rather than a whole new language<br />
<a href="https://www.reddit.com/r/ProgrammingLanguages/comments/oohij6/c3_is_a_clike_language_trying_to_be_an/">https://www.reddit.com/r/ProgrammingLanguages/comments/oohij6/c3_is_a_clike_language_trying_to_be_an/</a>
</li>

<li>Tiobe index<br />
<a href="https://www.tiobe.com/tiobe-index/">https://www.tiobe.com/tiobe-index/</a>
</li>

<li>PYPL PopularitY of Programming Language<br />
<a href="https://pypl.github.io/PYPL.html">https://pypl.github.io/PYPL.html</a>
</li>

<li>C3 Tutorial<br />
<a href="https://learn-c3.org/">https://learn-c3.org/</a>
</li>

<li>History of programming languages<br />
<a href="https://devskiller.com/history-of-programming-languages/">https://devskiller.com/history-of-programming-languages/</a>
</li>

<li>History of programming languages (Wikipedia)<br />
<a href="https://en.wikipedia.org/wiki/History_of_programming_languages">https://en.wikipedia.org/wiki/History_of_programming_languages</a>
</li>

<li>D language<br />
<a href="https://dlang.org/">https://dlang.org/</a>
</li>

<li>Zig programming language<br />
<a href="https://ziglang.org/">https://ziglang.org/</a>
</li>

<li>V language<br />
<a href="https://vlang.io/">https://vlang.io/</a>
</li>

<li>D programming language<br />
<a href="https://en.wikipedia.org/wiki/D_(programming_language)">https://en.wikipedia.org/wiki/D_(programming_language)</a>
</li>

<li>Zig programming language (Wikipedia)<br />
<a href="https://en.wikipedia.org/wiki/Zig_(programming_language)">https://en.wikipedia.org/wiki/Zig_(programming_language)</a>
</li>

<li>V programming language (Wikipedia)<br />
<a href="https://en.wikipedia.org/wiki/V_(programming_language)">https://en.wikipedia.org/wiki/V_(programming_language)</a>
</li>

<li>Syntax highlighting for C3's programming language<br />
<a href="https://github.com/Airbus5717/c3.vim">https://github.com/Airbus5717/c3.vim</a>
</li>

<li>Go factorial<br />
<a href="https://gist.github.com/esimov/9622710">https://gist.github.com/esimov/9622710</a>
</li>

<li>Generational list of programming languages<br />
<a href="https://en.wikipedia.org/wiki/Generational_list_of_programming_languages">https://en.wikipedia.org/wiki/Generational_list_of_programming_languages</a>
</li>

<li>The Language Tree: Almost Every Programming Language Ever Made<br />
<a href="https://github.com/Phileosopher/langmap">https://github.com/Phileosopher/langmap</a>
</li>

<li>List of C-family programming languages<br />
<a href="https://en.wikipedia.org/wiki/List_of_C-family_programming_languages">https://en.wikipedia.org/wiki/List_of_C-family_programming_languages</a>
</li>

<li>Compatibility of C and C++<br />
<a href="https://en.wikipedia.org/wiki/Compatibility_of_C_and_C%2B%2B">https://en.wikipedia.org/wiki/Compatibility_of_C_and_C%2B%2B</a>
</li>

<li>C++23: compatibility with C<br />
<a href="https://www.sandordargo.com/blog/2023/08/23/cpp23-c-compatibility">https://www.sandordargo.com/blog/2023/08/23/cpp23-c-compatibility</a>
</li>

<li>Can C++ Run C Code? Understanding Language Compatibility<br />
<a href="https://www.codewithc.com/can-c-run-c-code-understanding-language-compatibility/">https://www.codewithc.com/can-c-run-c-code-understanding-language-compatibility/</a>
</li>

<li>C3: Comparisons With Other Languages<br />
<a href="https://c3-lang.org/faq/compare-languages/">https://c3-lang.org/faq/compare-languages/</a>
</li>

<li>C3 Programming Language Gains Traction as Modern C Alternative<br />
<a href="https://biggo.com/news/202504040125_C3_Programming_Language_Alternative_to_C">https://biggo.com/news/202504040125_C3_Programming_Language_Alternative_to_C</a>
</li>

<li>The case against a C alternative<br />
<a href="https://c3.handmade.network/blog/p/8486-the_case_against_a_c_alternative">https://c3.handmade.network/blog/p/8486-the_case_against_a_c_alternative</a>
</li>

<li>C (programming language) Alternatives<br />
<a href="https://alternativeto.net/software/c-programming-language-/">https://alternativeto.net/software/c-programming-language-/</a>
</li>

<li>Seriál Programovací jazyk Go<br />
<a href="https://www.root.cz/serialy/programovaci-jazyk-go/">https://www.root.cz/serialy/programovaci-jazyk-go/</a>
</li>

<li>Is C3 the Underdog That Will Overtake Zig and Odin?<br />
<a href="https://bitshifters.cc/2025/05/22/c3-c-tradition.html">https://bitshifters.cc/2025/05/22/c3-c-tradition.html</a>
</li>

<li>"Hello, World!" program<br />
<a href="https://en.wikipedia.org/wiki/%22Hello%2C_World!%22_program">https://en.wikipedia.org/wiki/%22Hello%2C_World!%22_program</a>
</li>

<li>The C Programming Language<br />
<a href="https://en.wikipedia.org/wiki/The_C_Programming_Language">https://en.wikipedia.org/wiki/The_C_Programming_Language</a>
</li>

<li>Kontejner (abstraktní datový typ)<br />
<a href="https://cs.wikipedia.org/wiki/Kontejner_(abstraktn%C3%AD_datov%C3%BD_typ)">https://cs.wikipedia.org/wiki/Kontejner_(abstraktn%C3%AD_datov%C3%BD_typ)</a>
</li>

<li>Are arrays not considered containers because they are not based off of a class?<br />
<a href="https://stackoverflow.com/questions/37710975/are-arrays-not-considered-containers-because-they-are-not-based-off-of-a-class">https://stackoverflow.com/questions/37710975/are-arrays-not-considered-containers-because-they-are-not-based-off-of-a-class</a>
</li>

<li>Array declaration (C, C++)<br />
<a href="https://en.cppreference.com/w/cpp/language/array.html">https://en.cppreference.com/w/cpp/language/array.html</a>
</li>

</ol>



<p></p><p></p>
<p><small>Autor: <a href="https://github.com/tisnik/">Pavel Tišnovský</a> &nbsp; 2025</small></p>
</body>
</html>

