<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
        "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html>
<head>
<title>Jazyk APL, kombinátory a point-free style</title>
<meta name="Author" content="Pavel Tisnovsky" />
<meta name="Generator" content="vim" />
<meta http-equiv="content-type" content="text/html; charset=utf-8" />
<style type="text/css">
         body {color:#000000; background:#ffffff;}
         h1  {font-family: arial, helvetica, sans-serif; color:#ffffff; background-color:#c00000; text-align:center; padding-left:1em}
         h2  {font-family: arial, helvetica, sans-serif; color:#ffffff; background-color:#0000c0; padding-left:1em; text-align:left}
         h3  {font-family: arial, helvetica, sans-serif; color:#000000; background-color:#c0c0c0; padding-left:1em; text-align:left}
         h4  {font-family: arial, helvetica, sans-serif; color:#000000; background-color:#e0e0e0; padding-left:1em; text-align:left}
         a   {font-family: arial, helvetica, sans-serif;}
         li  {font-family: arial, helvetica, sans-serif; color:#000000; text-align:justify; width:450px;}
         ol  {font-family: arial, helvetica, sans-serif; color:#000000; text-align:justify; width:450px;}
         ul  {font-family: arial, helvetica, sans-serif; color:#000000; text-align:justify; width:450px;}
         p   {font-family: arial, helvetica, sans-serif; color:#000000; text-align:justify;}
         pre {background:#e0e0e0}
</style>
</head>

<body>

<h1>Jazyk APL, kombinátory a point-free style</h1>

<h3>Pavel Tišnovský</h3>

<p></p>

<h1>Úvodník</h1>

<p>V pořadí již jedenáctém článku věnovaném programovacím jazykům z oblasti &bdquo;array programmingu&ldquo; se ještě jednou vrátíme ke slavnému jazyku APL. Ukážeme si totiž, jak se v nových verzích APL (Dyalog APL atd.) používá programovací technika nazývaná point-free style nebo též tacit programming.</p>



<h2>Obsah</h2>

<p><a href="#k01">1. Programovací jazyk APL, kombinátory a point-free style</a></p>
<p><a href="#k02">2. Od výrazů s&nbsp;explicitně zapsanými proměnnými k&nbsp;point-free stylu</a></p>
<p><a href="#k03">3. Refaktoring uživatelem definovaných funkcí tak, aby se využil point-free styl</a></p>
<p><a href="#k04">4. Zobrazení stromové struktury volání funkcí ve vláčku</a></p>
<p><a href="#k05">*** 5. S-kombinátor a &bdquo;vláčky&ldquo; v&nbsp;APL</a></p>
<p><a href="#k06">6. Výpočet matice s&nbsp;malou násobilkou</a></p>
<p><a href="#k07">*** 7. Symbol ⊢ v&nbsp;APL a S-kombinátor</a></p>
<p><a href="#k08">*** 8. Výpočet průměrné hodnoty prvků vektoru</a></p>
<p><a href="#k09">*** 9. Vláček se dvěma vagony</a></p>
<p><a href="#k10">*** 10. Vláček se čtyřmi vagony</a></p>
<p><a href="#k11">*** 11. Vláček s&nbsp;pěti vagony</a></p>
<p><a href="#k12">*** 12. </a></p>
<p><a href="#k13">*** 13. </a></p>
<p><a href="#k14">*** 14. </a></p>
<p><a href="#k15">*** 15. </a></p>
<p><a href="#k16">*** 16. </a></p>
<p><a href="#k17">*** 17. </a></p>
<p><a href="#k18">*** 18. </a></p>
<p><a href="#k19">19. Předchozí články o rozsáhlém světu &bdquo;array programmingu&ldquo;</a></p>
<p><a href="#k20">20. Odkazy na Internetu</a></p>



<p><a name="k01"></a></p>
<h2 id="k01">1. Programovací jazyk APL, kombinátory a point-free style</h2>

<p><i>&bdquo;Simplicity and elegance are unpopular because they require hard
work and discipline to achieve and education to be appreciated.&ldquo;<br />
Edsger Dijkstra</i></p>

<p>V&nbsp;pořadí již jedenáctém článku věnovaném programovacím jazykům
z&nbsp;oblasti &bdquo;array programmingu&ldquo; (viz též odkazy uvedené <a
href="#k19">v&nbsp;devatenácté kapitole</a>) se ještě jednou vrátíme ke
slavnému programovacímu jazyku APL, za jehož vývojem stál Kenneth E. Iverson.
Ukážeme si totiž, jak se v&nbsp;nových verzích APL (mezi které je zapotřebí
započítat především <a href="https://www.dyalog.com/">Dyalog APL</a> atd.)
používá programovací technika nazývaná <i>point-free style</i> nebo též
<i>tacit programming</i>, s&nbsp;jejímiž základy jsme se již seznámili
v&nbsp;článku <a
href="https://www.root.cz/clanky/programovaci-technika-nazvana-tacit-programming/">Programovací
technika nazvaná tacit programming</a>. Ukázky sice budou založeny na jazyku
APL, ovšem většinu myšlenek je možné přenést například do Haskellu, který se
(možná kupodivu) v&nbsp;tomto ohledu programovacímu jazyku APL do značné míry
podobá a i proto je možné v&nbsp;Haskellu mnoho algoritmů zapisovat velmi
elegantním způsobem.</p>

<p>Přesný a přitom dostatečně jednoznačný český ekvivalent označení <i>tacit
programming</i> mě nenapadá a proto i v&nbsp;dnešním článku raději zůstanu u
termínu anglického, který se ostatně snadněji vyhledává. Co se ovšem pod názvy
<i>tacit programming</i> nebo <i>point-free style</i> skrývá? Jedná se o styl
zápisu bloků programů (typicky jednotlivých výrazů, ale i uživatelských funkcí
popř.&nbsp;sekvencí funkcí, někdy o zápis dekorátorů), ve kterých se nachází
volání jiných funkcí, ovšem bez explicitního udání jmen jejich argumentů
(parametrů). A nejenom to &ndash; většinou není naznačen ani počet argumentů.
Proč by se však <i>tacit programming</i> měl používat, resp.&nbsp;jaká je jeho
přednost? Základní idea spočívá v&nbsp;tom, že se seskupením funkcí
popř.&nbsp;operátorů vytvoří abstraktnější funkce nebo operátor, takže je možné
v&nbsp;programovacím jazyce vybaveném relativně základními operacemi vytvářet
vyšší úrovně abstrakce podle potřeb programátora, a to za použití snadno
pochopitelných a testovatelných prostředků a idiomů &ndash; bez nutnosti zápisu
&bdquo;zbytečností&ldquo;, mezi něž patří názvy formálních i skutečných
parametrů atd.</p>

<p><div class="rs-tip-major">Poznámka: poměrně často používám v&nbsp;článcích
pojem &bdquo;idiom&ldquo; pro ustálenou strukturu/notaci v&nbsp;daném obvyklou
programovacím jazyce. Důsledné používání idiomů vede ke kódu, který je
srozumitelný i pro další programátory (ovšem pro programátory v&nbsp;tomto
jazyce &ndash; idiomy většinou nejsou snadno přenositelné). A nejenom to
&ndash; v&nbsp;takovém kódu se obecně nachází menší množství logických chyb.
Naopak <i>ne</i>použití idiomu programátory zbytečně zmate.</div></p>



<p><a name="k02"></a></p>
<h2 id="k02">2. Od výrazů s&nbsp;explicitně zapsanými proměnnými k&nbsp;point-free stylu</h2>

<p><div class="rs-tip-major">Poznámka na úvod: všechny dále uvedené
demonstrační příklady si můžete otestovat ve webovém prostředí jazyka <i>Dyalog
APL</i> (což je nejmodernější varianta APL). Toto prostředí je dostupné na
adrese <a href="https://tryapl.org/">https://tryapl.org/</a>.</div></p>

<p>Před ukázkou složitějších programových konstrukcí si ukažme, jak se
v&nbsp;programovacím jazyce APL vyhodnocují takzvané <i>monadické funkce</i>.
Jedná se o funkce, které mají jediný operand, jenž je zapisovaný za jméno
funkce (tedy napravo od jména funkce či od jejího symbolu). Podívejme se na
trojici standardních monadických funkcí, konkrétně na funkce pro otočení
znaménka operandu, výpočet převrácené hodnoty a výpočet absolutní hodnoty:</p>

<pre>
      <strong>-10</strong>
¯10
&nbsp;
      <strong>÷10</strong>
0.1
&nbsp;
      <strong>|10</strong>
10
&nbsp;
      <strong>|¯10</strong>
10
</pre>

<p>Samozřejmě nám nic nebrání v&nbsp;předání výsledné hodnoty funkce do funkce
jiné. Můžeme tedy například zapsat výpočet: otočení znaménka následované
výpočtem převrácené hodnoty a výpočtem absolutní hodnoty z&nbsp;výsledku:</p>

<pre>
      <strong>|(÷(-3))</strong>
0.3333333333
</pre>

<p>Funkce se v&nbsp;programovacím jazyce APL vyhodnocují zprava doleva, což
znamená, že se mnohdy (prakticky vždy) obejdeme bez nutnosti použití závorek.
Výpočet převrácené hodnoty následovaný otočením znaménka výsledku lze zapsat
takto (ve druhém výrazu je ¯10 konstantou se zápornou hodnotou):</p>

<pre>
      <strong>-÷10</strong>
¯0.1
&nbsp;
      <strong>-÷¯10</strong>
0.1
</pre>

<p>Nejsme ovšem omezeni pouze na dvě monadické funkce, ale můžeme použít funkce tři či více funkcí:</p>

<pre>
      <strong>-÷-3</strong>
0.3333333333
</pre>

<p>Jazyk APL je polním jazykem, proto prakticky všechny výpočty můžeme provádět
s&nbsp;prvky polí (zde s&nbsp;prvky vektoru). Týká se to i monadických funkcí
zmíněných výše:</p>

<pre>
      <strong>-÷ 1 2 3 4 5</strong>
¯1 ¯0.5 ¯0.3333333333 ¯0.25 ¯0.2
</pre>

<p>A nakonec si ukažme modifikaci předchozího příkladu, nyní s&nbsp;využitím
funkce nazvané <i>indices</i>, která se zapisuje symbolem <strong>⍳</strong>
(jedná se vlastně o obdobu generátoru <i>range</i>). Vypočteme opačné hodnoty
z&nbsp;převrácených hodnot 1 až 10:</p>

<pre>
      <strong>-÷⍳10</strong>
¯1 ¯0.5 ¯0.3333333333 ¯0.25 ¯0.2 ¯0.1666666667 ¯0.1428571429 ¯0.125 ¯0.1111111111 ¯0.1
</pre>



<p><a name="k03"></a></p>
<h2 id="k03">3. Refaktoring uživatelem definovaných funkcí tak, aby se využil point-free styl</h2>

<p>V&nbsp;této kapitole si ukážeme, jakým způsobem je možné modifikovat
uživatelské funkce tak, aby se namísto klasických funkcí s&nbsp;parametry
využil point-free styl, tedy zápis &bdquo;větší funkce&ldquo; bez parametrů
&ndash; pouhým uvedením jiných (jednodušších) funkcí. Připomeňme si opět, jak
vypadá zápis monadické funkce (tedy funkce s&nbsp;jediným parametrem)
v&nbsp;programovacím jazyku APL. Tělo funkce je uzavřeno do složených závorek a
pravý (jediný) parametr takové funkce se jmenuje <strong>⍵</strong> (u
dyadických funkcí je první parametr pojmenován <strong>⍺</strong> a druhý opět
<strong>⍵</strong>, což je elegantní).</p>

<p>Funkce, která vypočte absolutní hodnotu parametru, z&nbsp;výsledku vypočte
převrácenou hodnotu a nakonec otočí znaménko, bude vypadat následovně (původně
anonymní funkce je přiřazena symbolu <strong>foo</strong>):</p>

<pre>
      <strong>foo ← {-(÷(|⍵))}</strong>
</pre>

<p>Funkci si snadno otestujeme:</p>

<pre>
      <strong>foo 3</strong>
¯0.3333333333
</pre>

<p>Vzhledem k&nbsp;tomu, že uvnitř uživatelské funkce se používají pouze
monadické funkce, můžeme všechny vnitřní (kulaté) závorky odstranit:</p>

<pre>
      <strong>bar ← {-÷|⍵}</strong>
&nbsp;
      <strong>bar 3</strong>
¯0.3333333333
</pre>

<p>Z&nbsp;klasické funkce můžeme vytvořit i &bdquo;vláček&ldquo;
(<i>train</i>), a to konkrétně odstraněním složených závorek i odstraněním
jména parametru <strong>⍵</strong> (ten nelze odstranit vždy, ovšem nyní
ano):</p>

<pre>
      <strong>baz ← -(÷(|))</strong>
&nbsp;
      <strong>baz 3</strong>
¯0.3333333333
</pre>

<p>Vnitřní závorky okolo funkce | (absolutní hodnota) nejsou nezbytné:</p>

<pre>
      <strong>baz ← -(÷|)</strong>
      <strong>baz 3</strong>
¯0.3333333333
</pre>



<p><a name="k04"></a></p>
<h2 id="k04">4. Zobrazení stromové struktury volání funkcí ve vláčku</h2>

<p>Pokud ovšem z&nbsp;výše uvedeného vláčku odstraníme i druhý pár kulatých
závorek, bude výpočet nekorektní, resp.&nbsp;přesněji řečeno bude provádět něco
jiného, než jsme měli na mysli:</p>

<pre>
      <strong>baz ← -÷|</strong>
&nbsp;
      <strong>baz 3</strong>
¯1
</pre>

<p>Proč tomu tak je? Jednou z&nbsp;vlastností programovacího jazyka APL je
fakt, že jeden symbol, například <strong>÷</strong>, většinou představuje jak
monadickou funkci (zde výpočet převrácené hodnoty), tak i funkci dyadickou (zde
konkrétně podíl obou parametrů). To představuje problém ve výše uvedeném zápisu
<strong>-÷|</strong>, neboť všechny tři symboly představují jak monadické, tak
i dyadické funkce a parser jazyka APL dá v&nbsp;tomto případě přednost funkcím
dyadickým (což má svůj hlubší význam vysvětlený dále).</p>

<p>Způsob chápání zápisu interpretrem jazyka APL zjistíme snadno &ndash; na
vstup zadáme přímo daný výraz <i>bez parametrů</i>. V&nbsp;tomto případě Dyalog
APL vykreslí stromovou strukturu, z&nbsp;níž by mělo být zřejmé, jak parser
zapsaný výraz pochopil. Můžeme si to snadno otestovat:</p>

<pre>
      <strong>-÷</strong>
┌┴┐
- ÷
&nbsp;
      <strong>-(÷|)</strong>
┌┴─┐ 
- ┌┴┐
  ÷ |
&nbsp;
      <strong>-÷|</strong>
┌─┼─┐
- ÷ |
</pre>

<p><div class="rs-tip-major">Poznámka: povšimněte si, že poslední dva výrazy
mají skutečně odlišnou interní reprezentaci.</div></p>



<p><a name="k05"></a></p>
<h2 id="k05">5. S-kombinátor a &bdquo;vláčky&ldquo; v&nbsp;APL</h2>

<p>V&nbsp;moderních dialektech programovacího jazyka APL nalezneme, podobně
jako například již ve zmíněném Haskellu, podporu pro takzvaný S-kombinátor.
Jedná se o způsob zkrácení zápisů výrazů s&nbsp;trojicí funkcí, z&nbsp;nichž
funkce prostřední musí být dyadická a funkce nalevo a napravo mohou být
monadické nebo dyadické. Konkrétně se jedná o následující struktury výrazů:</p>

<pre>
<strong>(f ⍵) g (h ⍵)</strong>
</pre>

<ul>
<li><strong>⍵</strong> je parametr předávaný jak funkci <strong>f</strong>, tak i funkci <strong>h</strong></li>
<li><strong>f</strong> je monadická funkce s&nbsp;jediným parametrem <strong>⍵</strong></li>
<li><strong>h</strong> je monadická funkce s&nbsp;jediným parametrem <strong>⍵</strong></li>
<li><strong>g</strong> je dyadická funkce, které se předají výsledky z&nbsp;funkce <strong>f</strong> i <strong>h</strong></li>
</ul>

<p>Taktéž se může jednat o trojici dyadických funkcí:</p>

<pre>
<strong>(⍺ f ⍵) g (⍺ h ⍵)</strong>
</pre>

<p>:</p>

<ul>
<li><strong>⍺</strong> je parametr předávaný jak funkci <strong>f</strong>, tak i funkci <strong>h</strong></li>
<li><strong>⍵</strong> je parametr předávaný jak funkci <strong>f</strong>, tak i funkci <strong>h</strong></li>
</ul>
(f g h) ⍵ -> (f ⍵) g (h ⍵)
⍺ (f g h) ⍵ -> (⍺ f ⍵) g (⍺ h ⍵)


<p><a name="k06"></a></p>
<h2 id="k06">6. Výpočet matice s&nbsp;malou násobilkou</h2>

<p>Abychom si blíže vysvětlili, jak lze v&nbsp;S-kombinátoru využít jak
<i>dyadické funkce</i> (s&nbsp;levým i pravým operandem/parametrem), tak i
funkce <i>monadické</i> (pouze s&nbsp;pravým operandem), zaměříme se na
relativně jednoduchý příklad &ndash; na výpočet a tisk matice s&nbsp;malou
násobilkou. Budeme tedy chtít, aby se v&nbsp;matici objevily všechny možné
kombinace vstupních hodnot od 1 do 10. Takový výpočet lze realizovat snadno
s&nbsp;využitím operátoru <i>outer product</i> použitého společně s&nbsp;funkcí
součinu (<i>funkce</i> v&nbsp;APL mají stejný význam jako operátory
v&nbsp;jiných jazycích; naproti tomu <i>operátory</i> v&nbsp;APL většinou
odpovídají konstrukcím typu <i>foreach</i>, <i>apply</i>, <i>filter</i> či
<i>reduce</i>). Na levé i na pravé straně vnějšího součinu budou vektory
s&nbsp;hodnotami od 1 do 10:</p>

<pre>
<strong>(⍳10) ∘.× (⍳10)</strong>
</pre>

<p>Výsledek tohoto výpočtu bude skutečně obsahovat celou malou násobilku:</p>

<pre>
 1  2  3  4  5  6  7  8  9  10
 2  4  6  8 10 12 14 16 18  20
 3  6  9 12 15 18 21 24 27  30
 4  8 12 16 20 24 28 32 36  40
 5 10 15 20 25 30 35 40 45  50
 6 12 18 24 30 36 42 48 54  60
 7 14 21 28 35 42 49 56 63  70
 8 16 24 32 40 48 56 64 72  80
 9 18 27 36 45 54 63 72 81  90
10 20 30 40 50 60 70 80 90 100
</pre>

<p>Kombinace <strong>∘.×</strong> tvoří funkci se dvěma parametry (levým a
pravým), tedy funkci dyadickou. Naproti tomu funkce <i>indices</i> zapisovaná
znakem <strong>⍳</strong> je funkcí monadickou. Strukturu stromu pro
vyhodnocení si pochopitelně můžeme opět snadno zobrazit:</p>

<pre>
     <strong>(⍳ ∘.× ⍳)</strong>
&nbsp;
┌─┼─┐
⍳ . ⍳
 ┌┴┐ 
 ∘ × 
</pre>

<p>Závorky okolo celého výrazu nejsou nutné, tedy:</p>

<pre>
     <strong>⍳ ∘.× ⍳</strong>
&nbsp;
┌─┼─┐
⍳ . ⍳
 ┌┴┐ 
 ∘ × 
</pre>

<p>A ani mezery nemají v&nbsp;APL žádný význam, což znamená, že výraz lze
zapsat takto:</p>

<pre>
      <strong>⍳∘.×⍳</strong>
&nbsp;
┌─┼─┐
⍳ . ⍳
 ┌┴┐ 
 ∘ ×
</pre>

<p>Tento výraz (jenž je zapsaný &bdquo;vláčkem&ldquo;) použijeme pro výpočet
tabulky (resp.&nbsp;matice) s&nbsp;malou násobilkou:</p>

<pre>
<strong>(⍳∘.×⍳)10</strong>
</pre>

<p>S&nbsp;výsledkem:</p>

<pre>
 1  2  3  4  5  6  7  8  9  10
 2  4  6  8 10 12 14 16 18  20
 3  6  9 12 15 18 21 24 27  30
 4  8 12 16 20 24 28 32 36  40
 5 10 15 20 25 30 35 40 45  50
 6 12 18 24 30 36 42 48 54  60
 7 14 21 28 35 42 49 56 63  70
 8 16 24 32 40 48 56 64 72  80
 9 18 27 36 45 54 63 72 81  90
10 20 30 40 50 60 70 80 90 100
</pre>

<p><div class="rs-tip-major">Poznámka: důležité je, že prostřední funkce je
funkcí dyadickou. Pokud by tomu tak nebylo, nejednalo by se o S-kombinátor a
musely by se použít závorky.</div></p>



<p><a name="k05"></a></p>
<h2 id="k05">5. Symbol ⊢ v&nbsp;APL a S-kombinátor</h2>

<p></p>

<pre>
(⊢--)
</pre>

      (⊢*inc)
┌─┼─┐    
⊢ * {1+⍵}
      (⊢*inc)10
1E11
      (⊢×inc)10
110
      (⊢×inc)1
2
      (⊢×inc)2
6

      (⊢×inc(⊢×inc))2
7
      (⊢×inc(⊢×inc))
┌─┴─┐              
⊢ ┌─┼───────┐      
  × {1+⍵} ┌─┼─┐    
          ⊢ × {1+⍵}



<p><a name="k06"></a></p>
<h2 id="k06">6. Výpočet průměrné hodnoty prvků vektoru</h2>

<p></p>

<pre>
      <strong>Avg←{(+⌿⍵)÷≢⍵}</strong>
      <strong>Avg 1 2 3 4 5</strong>
&nbsp;
3
</pre>

<pre>
      <strong>(+⌿)÷≢</strong>
&nbsp;
  ┌─┼─┐
  ⌿ ÷ ≢
┌─┘    
+      
</pre>

<pre>
      <strong>Avg←(+⌿)÷≢</strong>
      <strong>Avg 1 2 3 4 5</strong>
3
</pre>



<p><a name="k07"></a></p>
<h2 id="k07">7. Vláček se dvěma vagony</h2>

<p></p>
abs.dif:(|-)



<p><a name="k08"></a></p>
<h2 id="k08">8. Vláček se čtyřmi vagony</h2>

<p></p>



<p><a name="k09"></a></p>
<h2 id="k09">9. Vláček s&nbsp;pěti vagony</h2>

<p></p>



<p><a name="k10"></a></p>
<h2 id="k10">10. </h2>

<p></p>



<p><a name="k11"></a></p>
<h2 id="k11">11. </h2>

<p></p>



<p><a name="k12"></a></p>
<h2 id="k12">12. </h2>

<p></p>



<p><a name="k13"></a></p>
<h2 id="k13">13. </h2>

<p></p>



<p><a name="k14"></a></p>
<h2 id="k14">14. </h2>

<p></p>



<p><a name="k15"></a></p>
<h2 id="k15">15. </h2>

<p></p>



<p><a name="k16"></a></p>
<h2 id="k16">16. </h2>

<p></p>



<p><a name="k17"></a></p>
<h2 id="k17">17. </h2>

<p></p>



<p><a name="k18"></a></p>
<h2 id="k18">18. </h2>

<p></p>



<p><a name="k19"></a></p>
<h2 id="k19">19. Předchozí články o rozsáhlém světu &bdquo;array programmingu&ldquo;</h2>

<p>Programovacími jazyky, které jsou z&nbsp;větší či menší míry odvozeny od
APL, jsme se již na stránkách Roota zabývali v&nbsp;několika článcích (a
samozřejmě i v&nbsp;dnešním článku). Odkazy na tyto články naleznete pod
odstavcem:</p>

<ol>

<li>Jazyky umožňující operace s&nbsp;poli aneb rozsáhlý svět &bdquo;array programmingu&ldquo;<br />
<a href="https://www.root.cz/clanky/jazyky-umoznujici-operace-s-poli-aneb-rozsahly-svet-bdquo-array-programmingu-ldquo/">https://www.root.cz/clanky/jazyky-umoznujici-operace-s-poli-aneb-rozsahly-svet-bdquo-array-programmingu-ldquo/</a>
</li>

<li>Specializované jazyky pro práci s&nbsp;N-dimenzionálními poli: jazyk J<br />
<a href="https://www.root.cz/clanky/specializovane-jazyky-pro-praci-s-n-dimenzionalnimi-poli-jazyk-j/">https://www.root.cz/clanky/specializovane-jazyky-pro-praci-s-n-dimenzionalnimi-poli-jazyk-j/</a>
</li>

<li>Programovací jazyky odvozené od APL: BQN a ivy aneb 1~×`1↓↕10<br />
<a href="https://www.root.cz/clanky/programovaci-jazyky-odvozene-od-apl-bqn-a-ivy-aneb-1-1-10/">https://www.root.cz/clanky/programovaci-jazyky-odvozene-od-apl-bqn-a-ivy-aneb-1-1-10/</a>
</li>

<li>Programovací jazyk K: důkaz, že mezi námi žijí mimozemšťané<br />
<a href="https://www.root.cz/clanky/programovaci-jazyk-k-dukaz-ze-mezi-nami-ziji-mimozemstane/">https://www.root.cz/clanky/programovaci-jazyk-k-dukaz-ze-mezi-nami-ziji-mimozemstane/</a>
</li>

<li>Programovací jazyk K: důkaz, že mezi námi žijí mimozemšťané (dokončení)<br />
<a href="https://www.root.cz/clanky/programovaci-jazyk-k-dukaz-ze-mezi-nami-ziji-mimozemstane-dokonceni/">https://www.root.cz/clanky/programovaci-jazyk-k-dukaz-ze-mezi-nami-ziji-mimozemstane-dokonceni/</a>
</li>

<li>Nial Array Language: další z&nbsp;jazyků inspirovaných APL<br />
<a href="https://www.root.cz/clanky/nial-array-language-dalsi-z-jazyku-inspirovanych-apl/">https://www.root.cz/clanky/nial-array-language-dalsi-z-jazyku-inspirovanych-apl/</a>
</li>

<li>Programování mainframů: jazyk APL<br />
<a href="https://www.root.cz/clanky/programovani-mainframu-jazyk-apl/">https://www.root.cz/clanky/programovani-mainframu-jazyk-apl/</a>
</li>

<li>Programovací jazyk APL: programování bez smyček<br />
<a href="https://www.root.cz/clanky/programovaci-jazyk-apl-programovani-bez-smycek/">https://www.root.cz/clanky/programovaci-jazyk-apl-programovani-bez-smycek/</a>
</li>

<li>Programovací jazyk APL - dokončení<br />
<a href="https://www.root.cz/clanky/programovaci-jazyk-apl-dokonceni/">https://www.root.cz/clanky/programovaci-jazyk-apl-dokonceni/</a>
</li>

<li>Oslava 55 let od vzniku první implementace jazyka APL<br />
<a href="https://www.root.cz/clanky/oslava-55-let-od-vzniku-prvni-implementace-programovaciho-jazyka-apl/">https://www.root.cz/clanky/oslava-55-let-od-vzniku-prvni-implementace-programovaciho-jazyka-apl/</a>
</li>

</ol>



<p><a name="k20"></a></p>
<h2 id="k20">20. Odkazy na Internetu</h2>

<ol>

<li>Tacit programming (APL Wiki)<br />
<a href="https://aplwiki.com/wiki/Tacit_programming">https://aplwiki.com/wiki/Tacit_programming</a>
</li>

<li>Function trains<br />
<a href="https://mlochbaum.github.io/BQN/doc/train.html">https://mlochbaum.github.io/BQN/doc/train.html</a>
</li>

<li>Tacit programming (Wikipedia)<br />
<a href="https://en.wikipedia.org/wiki/Tacit_programming">https://en.wikipedia.org/wiki/Tacit_programming</a>
</li>

<li>Beyond Functional Programming: Manipulate Functions with the J Language<br />
<a href="https://www.adamtornhill.com/articles/jlang/beyondfunctional.html">https://www.adamtornhill.com/articles/jlang/beyondfunctional.html</a>
</li>

<li>Real World Uses of Tacit Programming: Part 1 of 2<br />
<a href="https://medium.com/@jesterxl/real-world-uses-of-tacit-programming-part-1-of-2-f2a0c3f9e00c">https://medium.com/@jesterxl/real-world-uses-of-tacit-programming-part-1-of-2-f2a0c3f9e00c</a>
</li>

<li>Programovací jazyk Forth a zásobníkové procesory<br />
<a href="http://www.root.cz/clanky/programovaci-jazyk-forth-a-zasobnikove-procesory/">http://www.root.cz/clanky/programovaci-jazyk-forth-a-zasobnikove-procesory/</a>
</li>

<li>Seriál Programovací jazyk Forth<br />
<a href="http://www.root.cz/serialy/programovaci-jazyk-forth/">http://www.root.cz/serialy/programovaci-jazyk-forth/</a>
</li>

<li>Programovací jazyk Factor<br />
<a href="http://www.root.cz/clanky/programovaci-jazyk-factor/">http://www.root.cz/clanky/programovaci-jazyk-factor/</a>
</li>

<li>Grafický metaformát PostScript<br />
<a href="http://www.root.cz/clanky/graficky-metaformat-postscript/">http://www.root.cz/clanky/graficky-metaformat-postscript/</a>
</li>

<li>Factor: revoluce v&nbsp;programování nebo propadák?<br />
<a href="https://www.root.cz/clanky/factor-revoluce-v-programovani-nebo-propadak/">https://www.root.cz/clanky/factor-revoluce-v-programovani-nebo-propadak/</a>
</li>

<li>Integrované vývojové prostředí Factoru<br />
<a href="https://www.root.cz/clanky/integrovane-vyvojove-prostredi-factoru/">https://www.root.cz/clanky/integrovane-vyvojove-prostredi-factoru/</a>
</li>

<li>Programujeme ve Factoru<br />
<a href="https://www.root.cz/clanky/programujeme-ve-factoru/">https://www.root.cz/clanky/programujeme-ve-factoru/</a>
</li>

<li>Joy: radost z&nbsp;programování<br />
<a href="https://www.root.cz/clanky/joy-radost-z-programovani/">https://www.root.cz/clanky/joy-radost-z-programovani/</a>
</li>

<li>Joy: programovací jazyk od protinožců<br />
<a href="https://www.root.cz/clanky/joy-programovaci-jazyk-od-protinozcu/">https://www.root.cz/clanky/joy-programovaci-jazyk-od-protinozcu/</a>
</li>

<li>Jazyk Joy a rekurzivní kombinátory<br />
<a href="https://www.root.cz/clanky/jazyk-joy-a-rekurzivni-kombinatory/">https://www.root.cz/clanky/jazyk-joy-a-rekurzivni-kombinatory/</a>
</li>

<li>Point-Free or Die: Tacit Programming in Haskell and Beyond<br />
<a href="https://www.thestrangeloop.com/2016/point-free-or-die-tacit-programming-in-haskell-and-beyond.html">https://www.thestrangeloop.com/2016/point-free-or-die-tacit-programming-in-haskell-and-beyond.html</a>
</li>

<li>Threading macro (dokumentace k&nbsp;jazyku Clojure)<br />
<a href="https://clojure.github.io/clojure/clojure.core-api.html#clojure.core/-&gt;">https://clojure.github.io/clojure/clojure.core-api.html#clojure.core/-&gt;</a>
</li>

<li>Understanding the Clojure -&gt; macro<br />
<a href="http://blog.fogus.me/2009/09/04/understanding-the-clojure-macro/">http://blog.fogus.me/2009/09/04/understanding-the-clojure-macro/</a>
</li>

<li>Transducers<br />
<a href="https://clojure.org/reference/transducers">https://clojure.org/reference/transducers</a>
</li>

<li>dc (computer program)<br />
<a href="https://en.wikipedia.org/wiki/Dc_%28computer_program%29">https://en.wikipedia.org/wiki/Dc_%28computer_program%29</a>
</li>

<li>dc (na Esolang)<br />
<a href="http://esolangs.org/wiki/Dc">http://esolangs.org/wiki/Dc</a>
</li>

<li>Relational pipes<br />
<a href="https://relational-pipes.globalcode.info/v_0/">https://relational-pipes.globalcode.info/v_0/</a>
</li>

<li>Roura (Unix)<br />
<a href="https://cs.wikipedia.org/wiki/Roura_(Unix)">https://cs.wikipedia.org/wiki/Roura_(Unix)</a>
</li>

<li>Roura (software)<br />
<a href="https://cs.wikipedia.org/wiki/Roura_(software)">https://cs.wikipedia.org/wiki/Roura_(software)</a>
</li>

<li>APL Wiki<br />
<a href="https://aplwiki.com/wiki/">https://aplwiki.com/wiki/</a>
</li>

<li>The Array Cast<br />
<a href="https://www.arraycast.com/episodes/episode-03-what-is-an-array">https://www.arraycast.com/episodes/episode-03-what-is-an-array</a>
</li>

<li>EnthusiastiCon 2019 – An Introduction to APL<br />
<a href="https://www.youtube.com/watch?v=UltnvW83_CQ">https://www.youtube.com/watch?v=UltnvW83_CQ</a>
</li>

<li>Dyalog<br />
<a href="https://www.dyalog.com/">https://www.dyalog.com/</a>
</li>

<li>Try APL!<br />
<a href="https://tryapl.org/">https://tryapl.org/</a>
</li>

<li>APL na replit<br />
<a href="https://replit.com/languages/apl">https://replit.com/languages/apl</a>
</li>

<li>Advent of Code 2020 in APL!<br />
<a href="https://www.youtube.com/watch?v=0RQFW6P1Tt0">https://www.youtube.com/watch?v=0RQFW6P1Tt0</a>
</li>

<li>Python vs APL (1 Problem)<br />
<a href="https://www.youtube.com/watch?v=APdKFJkmBbM">https://www.youtube.com/watch?v=APdKFJkmBbM</a>
</li>

<li>APL Wins (vs C++, Java &amp; Python)<br />
<a href="https://www.youtube.com/watch?v=59vAjBS3yZM">https://www.youtube.com/watch?v=59vAjBS3yZM</a>
</li>

<li>A Tour de Force of APL in 16 Expressions by Roger Hui<br />
<a href="https://www.youtube.com/watch?v=e0rywC7-i0U">https://www.youtube.com/watch?v=e0rywC7-i0U</a>
</li>

<li>Conway's Game Of Life in APL<br />
<a href="https://www.youtube.com/watch?v=a9xAKttWgP4">https://www.youtube.com/watch?v=a9xAKttWgP4</a>
</li>

<li>A List of companies that use Array Languages (J, K, APL, q)<br />
<a href="https://github.com/interregna/arraylanguage-companies">https://github.com/interregna/arraylanguage-companies</a>
</li>

<li>APL - one of the greatest programming languages ever<br />
<a href="http://www.vaxman.de/publications/apl_slides.pdf">http://www.vaxman.de/publications/apl_slides.pdf</a>
</li>

<li>"The J Programming Language" by Tracy Harms (2013)<br />
<a href="https://www.youtube.com/watch?v=RWYkx6-L04Q">https://www.youtube.com/watch?v=RWYkx6-L04Q</a>
</li>

<li>Dyalog Modern Programming Language, Morten Kromberg, Talks at Google<br />
<a href="https://www.youtube.com/watch?v=PlM9BXfu7UY">https://www.youtube.com/watch?v=PlM9BXfu7UY</a>
</li>

<li>The J Language: Consistency, Adjacency, and Solution-Oriented Programming - Tracy Harms<br />
<a href="https://www.youtube.com/watch?v=gLULrFY2-fI">https://www.youtube.com/watch?v=gLULrFY2-fI</a>
</li>

<li>Un-directed programming<br />
<a href="https://www.sacrideo.us/un-structured-programming/">https://www.sacrideo.us/un-structured-programming/</a>
</li>

<li>Concatenative programming language<br />
<a href="https://en.wikipedia.org/wiki/Concatenative_programming_language">https://en.wikipedia.org/wiki/Concatenative_programming_language</a>
</li>

<li>Repositáře s&nbsp;jazykem Joy<br />
<a href="https://github.com/joy-language">https://github.com/joy-language</a>
</li>

<li>J language: Chapter 8: Composing Verbs<br />
<a href="https://www.jsoftware.com/help/learning/08.htm">https://www.jsoftware.com/help/learning/08.htm</a>
</li>

<li>J language: Chapter 9: Trains of Verbs<br />
<a href="https://www.jsoftware.com/help/learning/09.htm">https://www.jsoftware.com/help/learning/09.htm</a>
</li>

<li>Combinatory logic<br />
<a href="https://en.wikipedia.org/wiki/Combinatory_logic">https://en.wikipedia.org/wiki/Combinatory_logic</a>
</li>

<li>Four Features of Modern APL<br />
<a href="https://www.youtube.com/watch?v=cBuqDHA-zEI">https://www.youtube.com/watch?v=cBuqDHA-zEI</a>
</li>

<li>How to read trains in Dyalog APL code<br />
<a href="https://www.youtube.com/watch?v=kt4lMZbn-so">https://www.youtube.com/watch?v=kt4lMZbn-so</a>
</li>

<li>Tacit programming<br />
<a href="https://xpqz.github.io/cultivations/Trains.html">https://xpqz.github.io/cultivations/Trains.html</a>
</li>

<li>Function trains in APL<br />
<a href="https://www.youtube.com/watch?v=A2LqqBosvY0">https://www.youtube.com/watch?v=A2LqqBosvY0</a>
</li>

<li>Trainspotting (APL)<br />
<a href="https://xpqz.github.io/learnapl/tacit.html">https://xpqz.github.io/learnapl/tacit.html</a>
</li>

<li>Train Spotting in Dyalog APL – Dyalog Webinar with Richard Park<br />
<a href="https://www.youtube.com/watch?v=Enlh5qwwDuY">https://www.youtube.com/watch?v=Enlh5qwwDuY</a>
</li>

</ol>



<p></p><p></p>
<p><small>Autor: <a href="http://www.fit.vutbr.cz/~tisnovpa">Pavel Tišnovský</a> &nbsp; 2022</small></p>
</body>
</html>

