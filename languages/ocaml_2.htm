<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
        "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html>
<head>
<title>Proměnné, funkce a datové typy v jazyku OCaml</title>
<meta name="Author" content="Pavel Tisnovsky" />
<meta name="Generator" content="vim" />
<meta http-equiv="content-type" content="text/html; charset=utf-8" />
<style type="text/css">
         body {color:#000000; background:#ffffff;}
         h1  {font-family: arial, helvetica, sans-serif; color:#ffffff; background-color:#c00000; text-align:center; padding-left:1em}
         h2  {font-family: arial, helvetica, sans-serif; color:#ffffff; background-color:#0000c0; padding-left:1em; text-align:left}
         h3  {font-family: arial, helvetica, sans-serif; color:#000000; background-color:#c0c0c0; padding-left:1em; text-align:left}
         h4  {font-family: arial, helvetica, sans-serif; color:#000000; background-color:#e0e0e0; padding-left:1em; text-align:left}
         a   {font-family: arial, helvetica, sans-serif;}
         li  {font-family: arial, helvetica, sans-serif; color:#000000; text-align:justify; width:450px;}
         ol  {font-family: arial, helvetica, sans-serif; color:#000000; text-align:justify; width:450px;}
         ul  {font-family: arial, helvetica, sans-serif; color:#000000; text-align:justify; width:450px;}
         p   {font-family: arial, helvetica, sans-serif; color:#000000; text-align:justify;}
         pre {background:#e0e0e0}
</style>
</head>

<body>

<h1>Proměnné, funkce a datové typy v jazyku OCaml</h1>

<h3>Pavel Tišnovský</h3>

<p></p>

<h1>Úvodník</h1>

<p>Na druhý článek o programovacím jazyku F# dnes opět navážeme &bdquo;doplňujícím&ldquo; článkem, v němž si vysvětlíme stejné koncepty, nyní ovšem upravené do takové podoby, aby je bylo možné přímo využít v jazyku OCaml.</p>



<h2>Obsah</h2>

<p><a href="#k01">1. Proměnné, funkce a datové typy v&nbsp;jazyku OCaml</a></p>
<p><a href="#k02">2. Přiřazení hodnot k&nbsp;symbolům</a></p>
<p><a href="#k03">3. Shadowing</a></p>
<p><a href="#k04">4. Neměnitelné hodnoty</a></p>
<p><a href="#k05">5. Reference</a></p>
<p><a href="#k06">6. Použití referencí &ndash; jednoduchý čítač</a></p>
<p><a href="#k07">7. Standardní funkce <strong>incr</strong></a></p>
<p><a href="#k08">8. Základní datové typy v&nbsp;jazyku OCaml</a></p>
<p><a href="#k09">9. Typ <strong>unit</strong></a></p>
<p><a href="#k10">10. Polymorfické funkce</a></p>
<p><a href="#k11">11. n-tice</a></p>
<p><a href="#k12">12. Záznamy</a></p>
<p><a href="#k13">13. Typová inference u záznamů</a></p>
<p><a href="#k14">14. Repositář s&nbsp;demonstračními příklady</a></p>
<p><a href="#k15">15. Odkazy na Internetu</a></p>



<p><a name="k01"></a></p>
<h2 id="k01">1. Proměnné, funkce a datové typy v&nbsp;jazyku OCaml</h2>

<p>Na <a
href="https://www.root.cz/clanky/programovaci-jazyk-f-promenne-funkce-a-datove-typy/">druhý
článek</a> o programovacím jazyku F# dnes opět navážeme
&bdquo;doplňujícím&ldquo; článkem, v němž si vysvětlíme stejné koncepty, nyní
ovšem upravené do takové podoby, aby je bylo možné přímo využít
v&nbsp;programovacím jazyku OCaml. Vzhledem k&nbsp;tomu, že F# vychází právě
z&nbsp;OCamlu, neuvidíme prozatím žádné <i>podstatné</i> rozdíly, ovšem jak
bude seriál o F#/Ocamlu pokračovat, postupně uvidíme, že se oba na první pohled
prakticky totožné jazyky od sebe odlišují a že (možná poněkud paradoxně) je
v&nbsp;některých oblastech OCaml dále, než jazyk F#.</p>

<p>Připomeňme si způsob deklarace neměnitelné (<i>immutable</i>) proměnné, tedy
proměnné v&nbsp;původním matematickém slova smyslu:</p>

<pre>
let x = 42;;
</pre>

<p>OCaml z&nbsp;tohoto zápisu dokáže odvodit typ proměnné (<i>type
inference</i>):</p>

<pre>
val x : int = 42
</pre>

<p>Typ proměnné je svázán s&nbsp;její hodnotou i jejím identifikátorem.</p>

<p>Pro tisk hodnoty proměnné (nebo jiného výrazu) na standardní výstup můžeme
použít funkci nazvanou <strong>Printf.printf</strong>, které se předává
formátovací řetězec a další hodnota či hodnoty. Oproti jazyku F# je zde tedy
navíc specifikace jména modulu <strong>Printf</strong>:</p>

<pre>
let x = 42;;
&nbsp;
Printf.printf "x=%d\n" x;;
</pre>

<p><div class="rs-tip-major">Poznámka: počet a typ předávaných hodnot
kontroluje překladač!</div></p>

<p>V&nbsp;REPLu můžeme (alespoň zdánlivě) měnit hodnotu proměnné pomocí
deklarace s&nbsp;klíčovým slovem <strong>let</strong>. Ve skutečnosti však
vytvoříme novou proměnnou, která <i>zastíní</i> proměnnou předchozí:</p>

<pre>
let x = 42;;
Printf.printf "x=%d\n" x;;
&nbsp;
let x = 6502;;
Printf.printf "x=%d\n" x;;
</pre>

<p>Jednou deklarované proměnné lze pochopitelně použít i v&nbsp;dalších
výrazech:</p>

<pre>
let x = 42;;
Printf.printf "x=%d\n" x;;
&nbsp;
let y = x + 1;;
Printf.printf "y=%d\n" y;;
&nbsp;
let z = y + 1;;
Printf.printf "x=%d\n" z;;
</pre>

<p>Proměnné, ke kterým se přistupuje, však již musí existovat (neexistuje zde
tedy &bdquo;automagické&ldquo; vytvoření proměnné při jejím prvním
použití):</p>

<pre>
let w = neznama;;
</pre>

<p>Tento nedostatek překladač opět velmi rychle odhalí:</p>

<pre>
Line 1, characters 8-9:
Error: Unbound value w
</pre>



<p><a name="k02"></a></p>
<h2 id="k02">2. Přiřazení hodnot k&nbsp;symbolům</h2>

<p>Pro deklaraci proměnné (včetně proměnné typu funkce &ndash; funkce jsou
totiž v&nbsp;OCamlu plnohodnotnými typy) se používá klíčové slovo
<strong>let</strong>, které zajišťuje vazbu (<i>binding</i>) mezi novým
symbolem (jménem) a nějakou hodnotou, která je výsledkem nějakého výrazu (a
samozřejmě i zde platí, že konstanta je plnohodnotným výrazem). V&nbsp;tom
nejjednodušším případě může definice takové vazby vypadat naprosto stejně, jako
je tomu v&nbsp;programovacím jazyku F#:</p>

<pre>
let x = 42
</pre>

<p>Hodnotu navázanou na symbol pochopitelně můžeme přečíst a nějak ji
zpracovat, například vytisknout na terminál:</p>

<pre>
Printf.printf "x=%d\n" x;;
</pre>

<p>A můžeme ji použít při definici jiné proměnné:</p>

<pre>
let y = x + 1
printf "y=%d" y
</pre>

<p>Na druhou stranu ovšem není možné hodnotu takové proměnné měnit. A podobně
jako v&nbsp;programovacím jazyku F#, i v&nbsp;OCamlu znamená symbol = porovnání
a nikoli přiřazení, takže se v&nbsp;následujícím příkladu porovnává hodnota
<strong>x</strong> s&nbsp;hodnotou <strong>x+1</strong>, což znamená, že
výsledkem tohoto porovnání bude vždy <strong>false</strong>:</p>

<pre>
let x = 42;;
&nbsp;
Printf.printf "x=%d\n" x;;
&nbsp;
x = x + 1;;
&nbsp;
Printf.printf "x=%d\n" x;;
</pre>

<p>Tento příklad vypíše dvakrát hodnotu 42 a výsledkem výrazu <strong>x = x +
1</strong> bude podle očekávání:</p>

<pre>
- : bool = false
</pre>

<p>Chování operátoru = si můžeme ověřit na tomto jednoduchém příkladu
(povšimněte si, že ve formátovacím řetězci používáme "%b" a nikoli "%d", což je
opět jazykem kontrolováno):</p>

<pre>
let x = 42;;
&nbsp;
Printf.printf "x=%d\n" x;;
&nbsp;
Printf.printf "x=x+1: %b\n" (x=x+1);;
Printf.printf "x=42:  %b\n" (x=42);;
</pre>

<p>Výsledky tohoto prográmku jsou předvídatelné:</p>

<pre>
x=x+1: false
x=42:  true
</pre>



<p><a name="k03"></a></p>
<h2 id="k03">3. Shadowing</h2>

<p>Ve druhém článku o programovacím jazyku F# jsme si taktéž ukázali koncept
takzvaného <i>shadowingu</i>, kdy jeden symbol může v&nbsp;nějakém bloku
zastínit stejně pojmenovaný symbol z&nbsp;vnějšího bloku. V&nbsp;jazyku F# je
umožněn následující zápis, v&nbsp;němž se vrací hodnota vnitřního symbolu
<strong>a</strong> (tedy hodnota 2):</p>

<pre>
let shadow =
   let a = 1
   let a = 2
   a
&nbsp;
printf "%d" shadow
</pre>

<p>V&nbsp;programovacím jazyce OCaml není tento stručný zápis umožněn. Namísto
toho je nutné použít klíčové slovo <strong>in</strong>, které naznačuje, že
každý příkaz <strong>let</strong> ve skutečnosti vytváří nový blok:</p>

<pre>
let shadow =
   let a = 1 in
   let a = 2 in
   a;;
&nbsp;
Printf.printf "%d" shadow
</pre>

<p>Překladač jazyka OCaml navíc ohlásí, že jedna z&nbsp;proměnných
<strong>a</strong> není použita:</p>

<pre>
1 Warning : unused variable a.
</pre>

<p>V&nbsp;interaktivním webovém prostředí <a href="https://try.ocaml.pro/"></a>
vypadá toto varování následovně (povšimněte si, jak se proměnná označí):</p>

*** image ***
<p><i>Obrázek 1: Varování, že v&nbsp;bloku je nevyužitá proměnná.</i></p>



<p><a name="k04"></a></p>
<h2 id="k04">4. Neměnitelné hodnoty</h2>

<p>V&nbsp;jazyku OCaml jsou hodnoty navázané na symboly (neboli
<i>proměnné</i>) neměnitelné, stejně jako v&nbsp;programovacím jazyku F#.
Ostatně jazyk F# tuto vlastnost z&nbsp;OCamlu převzal, takže se nejedná o
žádnou novinku. Pokusme se, naprosto stejně jako v&nbsp;článku o jazyku F#,
nadeklarovat proměnnou <strong>x</strong>, vypsat její hodnotu a následně ji
změnit:</p>

<pre>
let x = 42;;
Printf.printf "x=%d\n" x;;
&nbsp;
<strong>x := x + 1;;</strong>
Printf.printf "x=%d\n" x;;
</pre>

<p>Překladač jazyka OCaml v&nbsp;tomto případě vypíše poněkud kryptické chybové
hlášení:</p>

<pre>
Line 4, characters 0-1:
Error: This expression has type int but an expression was expected of type 'a ref
</pre>

<p>Toto hlášení oznamuje, že modifikovat lze pouze referencované hodnoty
&ndash; viz <a href="#k05">navazující kapitolu</a>.</p>

<p><div class="rs-tip-major">Poznámka: v&nbsp;jazyku F# je, na rozdíl od
OCamlu, možné vytvářet měnitelné proměnné (<i>mutable variables</i>) a proto je
zde chybové hlášení pro uživatele jasnější:</div></p>

<pre>
This value is not mutable. Consider using the mutable keyword, e.g. 'let
mutable x = expression'.
</pre>



<p><a name="k05"></a></p>
<h2 id="k05">5. Reference</h2>

<p>V&nbsp;programovacím jazyku F# je umožněno vytvářet měnitelné proměnné, a to
následujícím zápisem:</p>

<pre>
let <strong>mutable</strong> x = 42
printf "x=%d" x
&nbsp;
x &lt;- x + 1
printf "x=%d" x
</pre>

<p>Tento zápis a vlastně i celý koncept není v&nbsp;jazyce OCaml umožněn (i
když modifikátor <strong>mutable</strong> zde existuje, ale v&nbsp;jiném
kontextu). Namísto měnitelných proměnných se používají referencované hodnoty,
zkráceně <i>reference</i> nebo jen <i>refy</i>. Referenci si můžeme představit
jako proměnnou obsahující adresu hodnoty uložené v&nbsp;operační paměti. Ovšem
na rozdíl od céčka s&nbsp;jeho konceptem ukazatelů jsou ve skutečnosti
reference v&nbsp;programovacím jazyku OCaml plně typované.</p>

<p>Proměnná obsahující referenci je deklarována s&nbsp;využitím modifikátoru
<strong>ref</strong>:</p>

<pre>
let x = ref 42
</pre>

<p>Modifikace referencované hodnoty se provádí s&nbsp;využitím operátoru :=,
tedy takto:</p>

<pre>
x := 0
</pre>

<p>A pro získání hodnoty se používá operátor !, což je ukázáno na dalším
řádku:</p>

<pre>
Printf.printf "x=%d\n" !x
</pre>

<p>V&nbsp;jazyce F# je tomu stejně, ovšem existuje zde navíc možnost použít
zápis <strong>x.Value</strong>.</p>



<p><a name="k06"></a></p>
<h2 id="k06">6. Použití referencí &ndash; jednoduchý čítač</h2>

<p>Podobně jako v&nbsp;článku o programovacím jazyku F# si nyní vytvořme
demonstrační příklad, v&nbsp;němž je reference využita pro realizaci
jednoduchého čítače. Bude se tedy jednat o proměnnou, jejíž hodnotu lze zvýšit
o jedničku popř.&nbsp;danou hodnotu přečíst. Víme již, že proměnnou
s&nbsp;referencí musíme deklarovat s&nbsp;využitím modifikátoru
<strong>ref</strong>, změnu reference zařizuje operátor := a přečtení
referencované hodnoty lze realizovat přes operátor !. Zbytek je již
jednoduchý:</p>

<pre>
let x = <strong>ref</strong> 42;;
Printf.printf "x=%d\n" !x;;
&nbsp;
<strong>x := !x + 1;;</strong>
Printf.printf "x=%d\n" !x;;
</pre>

<p>Tento prográmek po svém spuštění vypíše:</p>

<pre>
x=42
x=43
</pre>

<p><div class="rs-tip-major">Poznámka: při čtení referencované hodnoty se musí
použít operátor !, což je hlídáno překladačem. Pokud zapomeneme:</div></p>

<pre>
let x = ref 42;;
Printf.printf "x=%d\n" x;;
&nbsp;
x := x + 1;;
Printf.printf "x=%d\n" x;;
</pre>

<p>budeme na tuto chybu upozorněni překladačem:</p>

<pre>
Line 2, characters 23-24:
Error: This expression has type int ref but an expression was expected of type int
</pre>



<p><a name="k07"></a></p>
<h2 id="k07">7. Standardní funkce <strong>incr</strong></h2>

<p>V&nbsp;jazyku OCaml existuje standardní funkce nazvaná
<strong>incr</strong>, která dokáže zvýšit referencovanou celočíselnou hodnotu
o jedničku (a současně nevrací žádnou hodnotu, k&nbsp;čemuž se záhy dostaneme).
Typ této funkce tedy je:</p>

<pre>
val incr : int ref -&gt; unit
</pre>

<p>Použití je snadné:</p>

<pre>
let x = ref 42;;
Printf.printf "x=%d\n" !x;;
&nbsp;
<strong>incr x</strong>;;
Printf.printf "x=%d\n" !x;;
</pre>

<p><div class="rs-tip-major">Poznámka: funkci <strong>incr</strong> se
<i>musí</i> předat reference na celé číslo, nikoli samotná celočíselná hodnota.
Toto je tedy chybné použití:</div></p>

<pre>
let x = 42;;
Printf.printf "x=%d\n" x;;
&nbsp;
<strong>incr x;;</strong>
Printf.printf "x=%d\n" x;;
</pre>

<p>Zde překladač objeví a nahlásí chybu, která je &bdquo;opačná&ldquo;, než
chyba <a href="#k06">z&nbsp;předchozí kapitoly</a>:</p>

<pre>
Line 4, characters 5-6:
Error: This expression has type int but an expression was expected of type int ref
</pre>



<p><a name="k08"></a></p>
<h2 id="k08">8. Základní datové typy v&nbsp;jazyku OCaml</h2>

<p>Základní datové typy dostupné v&nbsp;jazyku OCaml se v&nbsp;několika
ohledech odlišují od typů, s&nbsp;nimiž jsme se seznámili při popisu
programovacího jazyka F#. Na jednu stranu je například menší nabídka
celočíselných datových typů (což lze řešit knihovnami), protože OCaml nemusí
spolupracovat s&nbsp;dalšími jazyky v&nbsp;rámci nějakého ekosystému (jak je
tomu v&nbsp;ekosystému .NET), na stranu druhou se v&nbsp;OCamlu rozlišuje mezi
měnitelnými (<strong>bytes</strong>) a neměnitelnými (<strong>string</strong>)
řetězci:</p>

<table>
<tr><th>Typ</th><th>Stručný popis</th><th>Poznámka</th></tr>
<tr><td>bool</td><td>pravdivostní hodnoty</td><td>true a false</td></tr>
<tr><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td></tr>
<tr><td>int</td><td>celá čísla se znaménkem</td><td>buď 31 bitů nebo 63 bitů (ano, jeden bit je rezervován)</td></tr>
<tr><td>int32</td><td>celá čísla se znaménkem</td><td>uložena v&nbsp;32 bitech</td></tr>
<tr><td>int64</td><td>celá čísla se znaménkem</td><td>uložena v&nbsp;64 bitech</td></tr>
<tr><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td></tr>
<tr><td>float</td><td>hodnoty s&nbsp;plovoucí řádovou čárkou</td><td>dvojitá přesnost dle IEEE 754</td></tr>
<tr><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td></tr>
<tr><td>char</td><td>ASCII znak</td><td>'A'</td></tr>
<tr><td>string</td><td>neměnitelný řetězec</td><td>"www.root.cz"</td></tr>
<tr><td>bytes</td><td>měnitelný řetězec</td><td></td></tr>
<tr><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td></tr>
<tr><td>unit</td><td>typ s&nbsp;jedinou hodnotou ()</td><td>viz <a href="#k09">navazující kapitolu</a></td></tr>
<tr><td>list</td><td>seznam</td><td>[1;2;3]</td></tr>
<tr><td>array</td><td>pole</td><td>[|1;2;3|]</td></tr>
<tr><td>tuple</td><td>n-tice</td><td>(1, "foo", 'b')</td></tr>
</table>

<p><div class="rs-tip-major">Poznámka: povšimněte si, že typ
<strong>int</strong> je buď 31bitový nebo 63bitový, protože jeden bit je použit
jako <i>tag</i> pro interní rozlišení mezi celočíselnou hodnotou a ukazatelem
na boxovanou hodnotu (například při automatické správě paměti). Jedná se o
implementační detail, ale když už na tuto vlastnost upozorňuji: tento bit bývá
nejnižší a u celočíselných hodnot je nastaven na jedničku (protože ukazatele
jsou zarovnány a tudíž jejich nejnižší bit či bity jsou nulové).</div></p>



<p><a name="k09"></a></p>
<h2 id="k09">9. Typ <strong>unit</strong></h2>

<p>I v&nbsp;programovacím jazyce OCaml se setkáme s&nbsp;datovým typem
<strong>unit</strong>, s&nbsp;nímž jsme se seznámili ve druhém článku o
programovacím jazyce F#. Připomeňme si jen, že se tato hodnota používá
v&nbsp;těch místech, kde je formálně nutné zapsat nějaký typ či hodnotu, ale
žádný takový typ ani hodnota nedává smysl. Příkladem je opět funkce
<strong>incr</strong>, která provádí nějakou činnost (zvyšuje hodnotu
referencované proměnné), ovšem nic nevrací. A právě návratovým typem takové
funkce je <strong>()</strong>. Tento typ se ovšem odlišuje od
<strong>void</strong> z&nbsp;céčka, k&nbsp;čemuž se ještě vrátíme (ve
stručnosti &ndash; <strong>void</strong> není plnohodnotným typem).</p>

<p>Způsob zápisu:</p>

<pre>
()
</pre>

<p>Výsledná hodnota a její typ:</p>

<pre>
- : unit = ()
</pre>

<p>Podívejme se pro úplnost na rozdíl mezi proměnnou typu <strong>unit</strong>
a funkcí bez parametrů:</p>

<pre>
let x = ();;
let y () = 42;;
</pre>

<p>Rozdíl je patrný při vyhodnocování:</p>

<pre>
<strong>y ;;</strong>
- : unit -&gt; int = &lt;fun&gt;
&nbsp;
<strong>y() ;;</strong>
- : int = 42
&nbsp;
<strong>x ;;</strong>
- : unit = ()
</pre>



<p><a name="k10"></a></p>
<h2 id="k10">10. Polymorfické funkce</h2>

<p>Jazyk F# převzal koncept polymorfických funkcí právě z&nbsp;programovacího
jazyka OCaml, takže je vhodné se o tomto konceptu ve stručnosti zmínit i dnes.
Pro ukázku si nadeklarujeme funkci (pro jednoduchost pojmenovanou
<strong>ident</strong>), která akceptuje nějaký parametr pojmenovaný
<strong>x</strong> a hodnotu tohoto parametru vrátí jako svůj výsledek. U této
funkce ovšem nikde nespecifikujeme ani typ parametru ani typ návratové
hodnoty:</p>

<pre>
let ident x = x;;
</pre>

<p>Typ takové funkce bude označen symbolem 'a:</p>

<pre>
val ident : 'a -&gt; 'a = &lt;fun&gt;
</pre>

<p>Značka 'a se původně zapisovala jako &alpha; a značí generický typ &ndash;
funkce tedy akceptuje a vrací libovolnou hodnotu. To ovšem znamená, že můžeme
bez problémů psát:</p>

<pre>
Printf.printf "ident=%d\n" (ident 10);;
Printf.printf "ident=%s\n" (ident "foo");;
</pre>

<p>Navíc to znamená, že funkci <strong>ident</strong> můžeme volat i
s&nbsp;hodnotou typu <strong>unit</strong> (tedy jakoby &bdquo;bez
parametrů&ldquo;). Zápis musí vypadat takto:</p>

<pre>
ident();;
</pre>

<p>Výsledkem bude:</p>

<pre>
- : unit = ()
</pre>

<p><div class="rs-tip-major">Poznámka: závorky je nutné uvést, protože samotný
výraz <strong>ident;;</strong> pouze vrátí instanci funkce
<strong>ident</strong>, nikoli výsledek jejího zavolání.</div></p>

<p>Zkusme si nyní složitější příklad polymorfních funkcí, u nichž překladač
nemůže dopředu odvodit jejich typ (a proto dosadí 'a):</p>

<pre>
let ident x = x;;
&nbsp;
let first x y = x;;
&nbsp;
let second x y = y;;
&nbsp;
let add x y = x + y;;
&nbsp;
ident (add (first 1 2) (second 1 2));;
</pre>

<p>Výsledkem bude hodnota 3 s&nbsp;typem <strong>int</strong>:</p>

<pre>
- : int = 3
</pre>

<p>To je ovšem zajímavé, protože typy jednotlivých funkcí jsou:</p>

<pre>
let ident x = x ;;
val ident : 'a -&gt; 'a = &lt;fun&gt;
&nbsp;
let first x y = x ;;
val first : 'a -&gt; 'b -&gt; 'a = &lt;fun&gt;
&nbsp;
let second x y = y ;;
val second : 'a -&gt; 'b -&gt; 'b = &lt;fun&gt;
&nbsp;
let add x y = x + y ;;
val add : int -&gt; int -&gt; int = &lt;fun&gt;
</pre>

<p>Překladač tedy odvodí typ funkcí až ve chvíli, kdy jsou tyto funkce volány
(stále se však jedná o čas překladu, nikoli čas běhu aplikace).</p>

<p><div class="rs-tip-major">Poznámka: povšimněte si, že se nyní rozlišují typy
<strong>'a</strong> a <strong>'b</strong>, protože nikde není naznačeno, že by
funkce <strong>first</strong> či <strong>second</strong> musela akceptovat
parametry se shodnými typy.</div></p>



<p><a name="k11"></a></p>
<h2 id="k11">11. n-tice</h2>

<p>Ze složených datových typů jsou v&nbsp;programovacím jazyku OCaml samozřejmě
podporovány n-tice. Ty mohou obsahovat prvky libovolných typů a stejně jako
v&nbsp;jazyku F# i zde je typ n-tice jako celku odvozen od typů jednotlivých
prvků.</p>

<pre>
let x = (1, 2, 3);;
</pre>

<p>Typ této n-tice se zapisuje následovně:</p>

<pre>
val x : int * int * int = (1, 2, 3)
</pre>

<p><div class="rs-tip-major">Poznámka: povšimněte si operátoru * v&nbsp;zápisu
typu n-tice. Tento operátor naznačuje, že se jedná o kartézský součin dvou
množin (tvořených všemi prvky jednotlivých typů). Asi ještě lépe to bude patrné
na tomto příkladu:</div></p>

<pre>
<strong>(true, true) ;;</strong>
&nbsp;
- : bool * bool = (true, true)
</pre>

<p>Typ této n-tice je <strong>bool * bool</strong>, tedy kartézský součin dvou
množin s&nbsp;prvky typu <strong>bool</strong> (true či false), takže lze
snadno odvodit, kolik unikátních hodnot tento typ reprezentuje.</p>

<p>Můžeme se pokusit zapsat i složitější n-tici:</p>

<pre>
let x = (1, "foo", (1,2,"bar"));;
</pre>

<p>Typ této n-tice je:</p>

<pre>
val x : int * string * (int * int * string) = (1, "foo", (1, 2, "bar"))
</pre>



<p><a name="k12"></a></p>
<h2 id="k12">12. Záznamy</h2>

<p>Jedním z&nbsp;nejužitečnějších složených (resp.&nbsp;možná přesněji řečeno
strukturovaných) datových typů jsou v&nbsp;programovacím jazyku OCaml záznamy
(<i>records</i>), v&nbsp;nichž mohou být uloženy prvky taktéž libovolného typu,
ovšem na rozdíl od n-tic jsou tyto prvky pojmenovány. Zde je již nutné
definovat nový datový typ s&nbsp;explicitním určením typů jednotlivých položek
(další možnosti si popíšeme jindy). Datový typ <strong>car</strong> může být
definován takto:</p>

<pre>
type car = {
  color: string;
  model: string;
  manufacturer: string;
  year: int;
}
</pre>

<p><div class="rs-tip-major">Poznámka: oproti programovacímu jazyku F# zde
můžeme vidět jeden poměrně velký rozdíl &ndash; prvky struktury začínají malými
písmeny.</div></p>

<p>Vytvoření proměnné s&nbsp;hodnotou tohoto typu se zapisuje následujícím
stylem:</p>

<pre>
let toyota :car = {color="silver"; model="Corolla"; manufacturer="Toyota"; year=1986};;
</pre>

<p>Typ této hodnoty je vypsán ve stylu, kdy se již neopisují typy prvků:</p>

<pre>
val toyota : car
</pre>

<p><div class="rs-tip-major">Poznámka: pro novou proměnnou
<strong>toyota</strong> platí všechny vlastnosti proměnných zmíněné výše,
tj.&nbsp;neměnitelnost atd.</div></p>

<p>Přístup (pro čtení) k&nbsp;prvkům datové struktury je triviální,
resp.&nbsp;přesněji řečeno se nijak zvlášť neliší od mainstreamových
programovacích jazyků:</p>

<pre>
# <strong>toyota.model;;</strong>
&nbsp;
- : string = "Corolla"
</pre>



<p><a name="k13"></a></p>
<h2 id="k13">13. Typová inference u záznamů</h2>

<p>I u proměnných či parametrů typu záznam se uplatňuje typová inference, což
konkrétně znamená, že například v&nbsp;následujícím příkladu nemusíme u
proměnné <strong>toyota</strong> explicitně deklarovat její typ:</p>

<pre>
type car = {
  color: string;
  model: string;
  manufacturer: string;
  year: int;
}
&nbsp;
let toyota = {color="silver"; model="Corolla"; manufacturer="Toyota"; year=1986};;
</pre>

<p>Výsledkem bude tato hodnota:</p>

<pre>
val toyota : car =
  {color = "silver"; model = "Corolla"; manufacturer = "Toyota"; year = 1986}
</pre>

<p>Někdy je ovšem nutné překladači pomoci a nespoléhat se na typovou inferenci:</p>

<pre>
type point = {
  x:int;
  y:int;
}
&nbsp;
type vector = {
  x:int;
  y:int;
}
&nbsp;
let p1 = {x=10; y=10;};;
let p2:point = {x=10; y=10;};;
</pre>

<p>V&nbsp;tomto případě překladač rozhodne, že hodnota <strong>p1</strong> bude
typu <strong>vector</strong> a nikoli <strong>point</strong>:</p>

<pre>
- : vector = {x = 10; y = 10}
</pre>

<p><div class="rs-tip-major">Poznámka: lepší by v&nbsp;tomto případě bylo
rozdělení do jmenných prostorů, o čemž se zmíníme příště.</div></p>



<p><a name="k14"></a></p>
<h2 id="k14">14. Repositář s&nbsp;demonstračními příklady</h2>

<p>Všechny výše popsané demonstrační příklady byly uloženy do repositáře
dostupného na adrese <a
href="https://github.com/tisnik/ocaml-examples/">https://github.com/tisnik/ocaml-examples/</a>.
V&nbsp;tabulce umístěné pod tímto odstavcem jsou uvedeny odkazy na tyto
příklady:</p>

<table>
<tr><th> #</th><th>Příklad</th><th>Popis příkladu</th><th>Cesta</th></tr>
<tr><td> 1</td><td>hello_world_1.ml</td><td>zavolání funkce <strong>print_string</strong></td><td><a href="https://github.com/tisnik/ocaml-examples/tree/master/article_01/hello_world_1.ml">https://github.com/tisnik/ocaml-examples/tree/master/article_01/hello_world_1.ml</a></td></tr>
<tr><td> 2</td><td>hello_world_2.ml</td><td>zavolání funkce <strong>printf.Printf</strong></td><td><a href="https://github.com/tisnik/ocaml-examples/tree/master/article_01/hello_world_2.ml">https://github.com/tisnik/ocaml-examples/tree/master/article_01/hello_world_2.ml</a></td></tr>
<tr><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td></tr>
<tr><td> 3</td><td>function.ml</td><td>definice funkce</td><td><a href="https://github.com/tisnik/ocaml-examples/tree/master/article_01/function.ml">https://github.com/tisnik/ocaml-examples/tree/master/article_01/function.ml</a></td></tr>
<tr><td> 4</td><td>lambda.ml</td><td>anonymní funkce</td><td><a href="https://github.com/tisnik/ocaml-examples/tree/master/article_01/lambda.ml">https://github.com/tisnik/ocaml-examples/tree/master/article_01/lambda.ml</a></td></tr>
<tr><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td></tr>
<tr><td> 5</td><td>function_type_1.ml</td><td>explicitní specifikace typu návratové hodnoty funkce</td><td><a href="https://github.com/tisnik/ocaml-examples/tree/master/article_01/function_type_1.ml">https://github.com/tisnik/ocaml-examples/tree/master/article_01/function_type_1.ml</a></td></tr>
<tr><td> 6</td><td>function_type_2.ml</td><td>explicitní specifikace typu návratové hodnoty funkce</td><td><a href="https://github.com/tisnik/ocaml-examples/tree/master/article_01/function_type_2.ml">https://github.com/tisnik/ocaml-examples/tree/master/article_01/function_type_2.ml</a></td></tr>
<tr><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td></tr>
<tr><td> 7</td><td>call_function_1.ml</td><td>definice jednoduché funkce s&nbsp;jejím zavoláním</td><td><a href="https://github.com/tisnik/ocaml-examples/tree/master/article_01/call_function_1.ml">https://github.com/tisnik/ocaml-examples/tree/master/article_01/call_function_1.ml</a></td></tr>
<tr><td> 8</td><td>call_function_2.ml</td><td>definice jednoduché funkce s&nbsp;jejím zavoláním</td><td><a href="https://github.com/tisnik/ocaml-examples/tree/master/article_01/call_function_2.ml">https://github.com/tisnik/ocaml-examples/tree/master/article_01/call_function_2.ml</a></td></tr>
<tr><td> 9</td><td>call_function_3.ml</td><td>použití operátoru <strong>+</strong> pro dvojici hodnot typu <strong>float</strong></td><td><a href="https://github.com/tisnik/ocaml-examples/tree/master/article_01/call_function_3.ml">https://github.com/tisnik/ocaml-examples/tree/master/article_01/call_function_3.ml</a></td></tr>
<tr><td>10</td><td>call_function_4.ml</td><td>použití operátoru <strong>+.</strong> pro dvojici hodnot typu <strong>float</strong></td><td><a href="https://github.com/tisnik/ocaml-examples/tree/master/article_01/call_function_4.ml">https://github.com/tisnik/ocaml-examples/tree/master/article_01/call_function_4.ml</a></td></tr>
<tr><td>11</td><td>call_function_5.ml</td><td>plná deklarace funkce bez syntaktického cukru</td><td><a href="https://github.com/tisnik/ocaml-examples/tree/master/article_01/call_function_5.ml">https://github.com/tisnik/ocaml-examples/tree/master/article_01/call_function_5.ml</a></td></tr>
<tr><td>12</td><td>call_function_6.ml</td><td>plná deklarace funkce bez syntaktického cukru</td><td><a href="https://github.com/tisnik/ocaml-examples/tree/master/article_01/call_function_6.ml">https://github.com/tisnik/ocaml-examples/tree/master/article_01/call_function_6.ml</a></td></tr>
<tr><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td></tr>
<tr><td>13</td><td>local_binding_1.ml</td><td>definice lokálních symbolů</td><td><a href="https://github.com/tisnik/ocaml-examples/tree/master/article_01/local_binding_1.ml">https://github.com/tisnik/ocaml-examples/tree/master/article_01/local_binding_1.ml</a></td></tr>
<tr><td>14</td><td>local_binding_2.ml</td><td>definice lokálních symbolů</td><td><a href="https://github.com/tisnik/ocaml-examples/tree/master/article_01/local_binding_2.ml">https://github.com/tisnik/ocaml-examples/tree/master/article_01/local_binding_2.ml</a></td></tr>
<tr><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td></tr>
<tr><td>15</td><td>basic_binding.ml</td><td>navázání hodnoty na symbol (deklarace proměnné)</td><td><a href="https://github.com/tisnik/ocaml-examples/tree/master/article_02/basic_binding.ml">https://github.com/tisnik/ocaml-examples/tree/master/article_02/basic_binding.ml</a></td></tr>
<tr><td>16</td><td>print_variable.ml</td><td>tisk hodnoty proměnné</td><td><a href="https://github.com/tisnik/ocaml-examples/tree/master/article_02/print_variable.ml">https://github.com/tisnik/ocaml-examples/tree/master/article_02/print_variable.ml</a></td></tr>
<tr><td>17</td><td>variables_and_functions.ml</td><td>předání proměnné do funkce</td><td><a href="https://github.com/tisnik/ocaml-examples/tree/master/article_02/variables_and_functions.ml">https://github.com/tisnik/ocaml-examples/tree/master/article_02/variables_and_functions.ml</a></td></tr>
<tr><td>18</td><td>redefine_symbol_1.ml</td><td>pokus o redefinici symbolu</td><td><a href="https://github.com/tisnik/ocaml-examples/tree/master/article_02/redefine_symbol_1.ml">https://github.com/tisnik/ocaml-examples/tree/master/article_02/redefine_symbol_1.ml</a></td></tr>
<tr><td>19</td><td>redefine_symbol_2.ml</td><td>pokus o redefinici symbolu (složitější příklad)</td><td><a href="https://github.com/tisnik/ocaml-examples/tree/master/article_02/redefine_symbol_2.ml">https://github.com/tisnik/ocaml-examples/tree/master/article_02/redefine_symbol_2.ml</a></td></tr>
<tr><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td></tr>
<tr><td>20</td><td>equal_operator_1.ml</td><td>operátor =</td><td><a href="https://github.com/tisnik/ocaml-examples/tree/master/article_02/equal_operator_1.ml">https://github.com/tisnik/ocaml-examples/tree/master/article_02/equal_operator_1.ml</a></td></tr>
<tr><td>21</td><td>equal_operator_2.ml</td><td>operátor =</td><td><a href="https://github.com/tisnik/ocaml-examples/tree/master/article_02/equal_operator_2.ml">https://github.com/tisnik/ocaml-examples/tree/master/article_02/equal_operator_2.ml</a></td></tr>
<tr><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td></tr>
<tr><td>22</td><td>immutable_variable.ml</td><td>&bdquo;změna&ldquo; neměnitelné proměnné</td><td><a href="https://github.com/tisnik/ocaml-examples/tree/master/article_02/immutable_variable.ml">https://github.com/tisnik/ocaml-examples/tree/master/article_02/immutable_variable.ml</a></td></tr>
<tr><td>22</td><td>mutable_variable.ml</td><td>změna měnitelné proměnné</td><td><a href="https://github.com/tisnik/ocaml-examples/tree/master/article_02/mutable_variable.ml">https://github.com/tisnik/ocaml-examples/tree/master/article_02/mutable_variable.ml</a></td></tr>
<tr><td>23</td><td>shadow.ml</td><td>shadowing symbolu</td><td><a href="https://github.com/tisnik/ocaml-examples/tree/master/article_02/shadow.ml">https://github.com/tisnik/ocaml-examples/tree/master/article_02/shadow.ml</a></td></tr>
<tr><td>24</td><td>incr.ml</td><td>standardní funkce <strong>incr</strong></td><td><a href="https://github.com/tisnik/ocaml-examples/tree/master/article_02/incr.ml">https://github.com/tisnik/ocaml-examples/tree/master/article_02/incr.ml</a></td></tr>
<tr><td>25</td><td>ident.ml</td><td>nejjednodušší polymorfická funkce</td><td><a href="https://github.com/tisnik/ocaml-examples/tree/master/article_02/ident.ml">https://github.com/tisnik/ocaml-examples/tree/master/article_02/ident.ml</a></td></tr>
<tr><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td></tr>
<tr><td>26</td><td>tuple1.ml</td><td>datový typ n-tice (<i>tuple</i>)</td><td><a href="https://github.com/tisnik/ocaml-examples/tree/master/article_02/tuple1.ml">https://github.com/tisnik/ocaml-examples/tree/master/article_02/tuple1.ml</a></td></tr>
<tr><td>27</td><td>tuple2.ml</td><td>datový typ n-tice (<i>tuple</i>)</td><td><a href="https://github.com/tisnik/ocaml-examples/tree/master/article_02/tuple2.ml">https://github.com/tisnik/ocaml-examples/tree/master/article_02/tuple2.ml</a></td></tr>
<tr><td>28</td><td>record1.ml</td><td>datový typ záznam (<i>record</i>), deklarace proměnné tohoto typu</td><td><a href="https://github.com/tisnik/ocaml-examples/tree/master/article_02/record1.ml">https://github.com/tisnik/ocaml-examples/tree/master/article_02/record1.ml</a></td></tr>
<tr><td>29</td><td>record2.ml</td><td>datový typ záznam (<i>record</i>) a typová inference</td><td><a href="https://github.com/tisnik/ocaml-examples/tree/master/article_02/record2.ml">https://github.com/tisnik/ocaml-examples/tree/master/article_02/record2.ml</a></td></tr>
<tr><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td></tr>
<tr><td>30</td><td>unit.ml</td><td>datový typ <strong>unit</strong> a rozdíl oproti funkcím bez parametrů</td><td><a href="https://github.com/tisnik/ocaml-examples/tree/master/article_02/unit.ml">https://github.com/tisnik/ocaml-examples/tree/master/article_02/unit.ml</a></td></tr>
<tr><td>31</td><td>polymorphic.ml</td><td>použití polymorfických funkcí</td><td><a href="https://github.com/tisnik/ocaml-examples/tree/master/article_02/polymorphic.ml">https://github.com/tisnik/ocaml-examples/tree/master/article_02/polymorphic.ml</a></td></tr>
<tr><td>32</td><td>two_same_records.ml</td><td>dva datové typy záznam se shodnými prvky</td><td><a href="https://github.com/tisnik/ocaml-examples/tree/master/article_02/two_same_records.ml">https://github.com/tisnik/ocaml-examples/tree/master/article_02/two_same_records.ml</a></td></tr>
</table>



<p><a name="k15"></a></p>
<h2 id="k15">15. Odkazy na Internetu</h2>

<ol>

<li>General-Purpose, Industrial-Strength, Expressive, and Safe<br />
<a href="https://ocaml.org/">https://ocaml.org/</a>
</li>

<li>OCaml playground<br />
<a href="https://ocaml.org/play">https://ocaml.org/play</a>
</li>

<li>Online Ocaml Compiler IDE<br />
<a href="https://www.jdoodle.com/compile-ocaml-online/">https://www.jdoodle.com/compile-ocaml-online/</a>
</li>

<li>Get Started - OCaml<br />
<a href="https://www.ocaml.org/docs">https://www.ocaml.org/docs</a>
</li>

<li>Get Up and Running With OCaml<br />
<a href="https://www.ocaml.org/docs/up-and-running">https://www.ocaml.org/docs/up-and-running</a>
</li>

<li>Better OCaml (Online prostředí)<br />
<a href="https://betterocaml.ml/?version=4.14.0">https://betterocaml.ml/?version=4.14.0</a>
</li>

<li>OCaml file extensions<br />
<a href="https://blog.waleedkhan.name/ocaml-file-extensions/">https://blog.waleedkhan.name/ocaml-file-extensions/</a>
</li>

<li>First thoughts on Rust vs OCaml<br />
<a href="https://blog.darklang.com/first-thoughts-on-rust-vs-ocaml/">https://blog.darklang.com/first-thoughts-on-rust-vs-ocaml/</a>
</li>

<li>Standard ML of New Jersey<br />
<a href="https://www.smlnj.org/">https://www.smlnj.org/</a>
</li>

<li>Programming Languages: Standard ML - 1 (a navazující videa)<br />
<a href="https://www.youtube.com/watch?v=2sqjUWGGzTo">https://www.youtube.com/watch?v=2sqjUWGGzTo</a>
</li>

<li>6 Excellent Free Books to Learn Standard ML<br />
<a href="https://www.linuxlinks.com/excellent-free-books-learn-standard-ml/">https://www.linuxlinks.com/excellent-free-books-learn-standard-ml/</a>
</li>

<li>SOSML: The Online Interpreter for Standard ML<br />
<a href="https://sosml.org/">https://sosml.org/</a>
</li>

<li>ML (Computer program language)<br />
<a href="https://www.barnesandnoble.com/b/books/other-programming-languages/ml-computer-program-language/_/N-29Z8q8Zvy7">https://www.barnesandnoble.com/b/books/other-programming-languages/ml-computer-program-language/_/N-29Z8q8Zvy7</a>
</li>

<li>Strong Typing<br />
<a href="https://perl.plover.com/yak/typing/notes.html">https://perl.plover.com/yak/typing/notes.html</a>
</li>

<li>What to know before debating type systems<br />
<a href="http://blogs.perl.org/users/ovid/2010/08/what-to-know-before-debating-type-systems.html">http://blogs.perl.org/users/ovid/2010/08/what-to-know-before-debating-type-systems.html</a>
</li>

<li>Types, and Why You Should Care (Youtube)<br />
<a href="https://www.youtube.com/watch?v=0arFPIQatCU">https://www.youtube.com/watch?v=0arFPIQatCU</a>
</li>

<li>DynamicTyping (Martin Fowler)<br />
<a href="https://www.martinfowler.com/bliki/DynamicTyping.html">https://www.martinfowler.com/bliki/DynamicTyping.html</a>
</li>

<li>DomainSpecificLanguage (Martin Fowler)<br />
<a href="https://www.martinfowler.com/bliki/DomainSpecificLanguage.html">https://www.martinfowler.com/bliki/DomainSpecificLanguage.html</a>
</li>

<li>Language Workbenches: The Killer-App for Domain Specific Languages?<br />
<a href="https://www.martinfowler.com/articles/languageWorkbench.html">https://www.martinfowler.com/articles/languageWorkbench.html</a>
</li>

<li>Effective ML (Youtube)<br />
<a href="https://www.youtube.com/watch?v=-J8YyfrSwTk">https://www.youtube.com/watch?v=-J8YyfrSwTk</a>
</li>

<li>Why OCaml (Youtube)<br />
<a href="https://www.youtube.com/watch?v=v1CmGbOGb2I">https://www.youtube.com/watch?v=v1CmGbOGb2I</a>
</li>

<li>Try OCaml<br />
<a href="https://try.ocaml.pro/">https://try.ocaml.pro/</a>
</li>

<li>CSE 341: Functions and patterns<br />
<a href="https://courses.cs.washington.edu/courses/cse341/04wi/lectures/03-ml-functions.html">https://courses.cs.washington.edu/courses/cse341/04wi/lectures/03-ml-functions.html</a>
</li>

<li>Comparing Objective Caml and Standard ML<br />
<a href="http://adam.chlipala.net/mlcomp/">http://adam.chlipala.net/mlcomp/</a>
</li>

<li>What are the key differences between Standard ML and OCaml?<br />
<a href="https://www.quora.com/What-are-the-key-differences-between-Standard-ML-and-OCaml?share=1">https://www.quora.com/What-are-the-key-differences-between-Standard-ML-and-OCaml?share=1</a>
</li>

<li>Cheat Sheets (pro OCaml)<br />
<a href="https://www.ocaml.org/docs/cheat_sheets.html">https://www.ocaml.org/docs/cheat_sheets.html</a>
</li>

<li>Think OCaml: How to Think Like a (Functional) Programmer<br />
<a href="https://www.greenteapress.com/thinkocaml/thinkocaml.pdf">https://www.greenteapress.com/thinkocaml/thinkocaml.pdf</a>
</li>

<li>The OCaml Language Cheat Sheet<br />
<a href="https://ocamlpro.github.io/ocaml-cheat-sheets/ocaml-lang.pdf">https://ocamlpro.github.io/ocaml-cheat-sheets/ocaml-lang.pdf</a>
</li>

<li>Syllabus (FAS CS51)<br />
<a href="https://cs51.io/college/syllabus/">https://cs51.io/college/syllabus/</a>
</li>

<li>Abstraction and Design In Computation<br />
<a href="http://book.cs51.io/">http://book.cs51.io/</a>
</li>

<li>Learn X in Y minutes Where X=Standard ML<br />
<a href="https://learnxinyminutes.com/docs/standard-ml/">https://learnxinyminutes.com/docs/standard-ml/</a>
</li>

<li>CSE307 Online - Summer 2018: Principles of Programing Languages course<br />
<a href="https://www3.cs.stonybrook.edu/~pfodor/courses/summer/cse307.html">https://www3.cs.stonybrook.edu/~pfodor/courses/summer/cse307.html</a>
</li>

<li>CSE307 Principles of Programming Languages course: SML part 1<br />
<a href="https://www.youtube.com/watch?v=p1n0_PsM6hw">https://www.youtube.com/watch?v=p1n0_PsM6hw</a>
</li>

<li>CSE 307 &ndash; Principles of Programming Languages &ndash; SML<br />
<a href="https://www3.cs.stonybrook.edu/~pfodor/courses/summer/CSE307/L01_SML.pdf">https://www3.cs.stonybrook.edu/~pfodor/courses/summer/CSE307/L01_SML.pdf</a>
</li>

<li>History of programming languages<br />
<a href="https://devskiller.com/history-of-programming-languages/">https://devskiller.com/history-of-programming-languages/</a>
</li>

<li>History of programming languages (Wikipedia)<br />
<a href="https://en.wikipedia.org/wiki/History_of_programming_languages">https://en.wikipedia.org/wiki/History_of_programming_languages</a>
</li>

<li>The Evolution Of Programming Languages<br />
<a href="https://www.i-programmer.info/news/98-languages/8809-the-evolution-of-programming-languages.html">https://www.i-programmer.info/news/98-languages/8809-the-evolution-of-programming-languages.html</a>
</li>

<li>Evoluce programovacích jazyků<br />
<a href="https://ccrma.stanford.edu/courses/250a-fall-2005/docs/ComputerLanguagesChart.png">https://ccrma.stanford.edu/courses/250a-fall-2005/docs/ComputerLanguagesChart.png</a>
</li>

<li>Currying<br />
<a href="https://sw-samuraj.cz/2011/02/currying/">https://sw-samuraj.cz/2011/02/currying/</a>
</li>

<li>Currying (Wikipedia)<br />
<a href="https://en.wikipedia.org/wiki/Currying">https://en.wikipedia.org/wiki/Currying</a>
</li>

<li>Currying (Haskell wiki)<br />
<a href="https://wiki.haskell.org/Currying">https://wiki.haskell.org/Currying</a>
</li>

<li>Haskell Curry<br />
<a href="https://en.wikipedia.org/wiki/Haskell_Curry">https://en.wikipedia.org/wiki/Haskell_Curry</a>
</li>

<li>Moses Schönfinkel<br />
<a href="https://en.wikipedia.org/wiki/Moses_Sch%C3%B6nfinkel">https://en.wikipedia.org/wiki/Moses_Sch%C3%B6nfinkel</a>
</li>

<li>So You Want to be a Functional Programmer (Part 1)<br />
<a href="https://cscalfani.medium.com/so-you-want-to-be-a-functional-programmer-part-1-1f15e387e536">https://cscalfani.medium.com/so-you-want-to-be-a-functional-programmer-part-1-1f15e387e536</a>
</li>

<li>So You Want to be a Functional Programmer (Part 2)<br />
<a href="https://cscalfani.medium.com/so-you-want-to-be-a-functional-programmer-part-2-7005682cec4a">https://cscalfani.medium.com/so-you-want-to-be-a-functional-programmer-part-2-7005682cec4a</a>
</li>

<li>So You Want to be a Functional Programmer (Part 3)<br />
<a href="https://cscalfani.medium.com/so-you-want-to-be-a-functional-programmer-part-3-1b0fd14eb1a7">https://cscalfani.medium.com/so-you-want-to-be-a-functional-programmer-part-3-1b0fd14eb1a7</a>
</li>

<li>So You Want to be a Functional Programmer (Part 4)<br />
<a href="https://cscalfani.medium.com/so-you-want-to-be-a-functional-programmer-part-4-18fbe3ea9e49">https://cscalfani.medium.com/so-you-want-to-be-a-functional-programmer-part-4-18fbe3ea9e49</a>
</li>

<li>So You Want to be a Functional Programmer (Part 5)<br />
<a href="https://cscalfani.medium.com/so-you-want-to-be-a-functional-programmer-part-5-c70adc9cf56a">https://cscalfani.medium.com/so-you-want-to-be-a-functional-programmer-part-5-c70adc9cf56a</a>
</li>

<li>So You Want to be a Functional Programmer (Part 6)<br />
<a href="https://cscalfani.medium.com/so-you-want-to-be-a-functional-programmer-part-6-db502830403">https://cscalfani.medium.com/so-you-want-to-be-a-functional-programmer-part-6-db502830403</a>
</li>

<li>Python to OCaml: Retrospective<br />
<a href="http://roscidus.com/blog/blog/2014/06/06/python-to-ocaml-retrospective/">http://roscidus.com/blog/blog/2014/06/06/python-to-ocaml-retrospective/</a>
</li>

<li>Why does Cambridge teach OCaml as the first programming language?<br />
<a href="https://www.youtube.com/watch?v=6APBx0WsgeQ">https://www.youtube.com/watch?v=6APBx0WsgeQ</a>
</li>

<li>OCaml and 7 Things You Need To Know About It In 2021 | Functional Programming | Caml<br />
<a href="https://www.youtube.com/watch?v=s0itOsgcf9Q">https://www.youtube.com/watch?v=s0itOsgcf9Q</a>
</li>

<li>OCaml 2021 - 25 years of OCaml<br />
<a href="https://www.youtube.com/watch?v=-u_zKPXj6mw">https://www.youtube.com/watch?v=-u_zKPXj6mw</a>
</li>

<li>Introduction | OCaml Programming | Chapter 1 Video 1<br />
<a href="https://www.youtube.com/watch?v=MUcka_SvhLw&amp;list=PLre5AT9JnKShBOPeuiD9b-I4XROIJhkIU">https://www.youtube.com/watch?v=MUcka_SvhLw&amp;list=PLre5AT9JnKShBOPeuiD9b-I4XROIJhkIU</a>
</li>

<li>Functional Programming - What | OCaml Programming | Chapter 1 Video 2<br />
<a href="https://www.youtube.com/watch?v=JTEwC3HihFc&amp;list=PLre5AT9JnKShBOPeuiD9b-I4XROIJhkIU&amp;index=2">https://www.youtube.com/watch?v=JTEwC3HihFc&amp;list=PLre5AT9JnKShBOPeuiD9b-I4XROIJhkIU&amp;index=2</a>
</li>

<li>Functional Programming - Why Part 1 | OCaml Programming | Chapter 1 Video 3<br />
<a href="https://www.youtube.com/watch?v=SKr3ItChPSI&amp;list=PLre5AT9JnKShBOPeuiD9b-I4XROIJhkIU&amp;index=3">https://www.youtube.com/watch?v=SKr3ItChPSI&amp;list=PLre5AT9JnKShBOPeuiD9b-I4XROIJhkIU&amp;index=3</a>
</li>

<li>Functional Programming - Why Part 2 | OCaml Programming | Chapter 1 Video 4<br />
<a href="https://www.youtube.com/watch?v=eNLm5Xbgmd0&amp;list=PLre5AT9JnKShBOPeuiD9b-I4XROIJhkIU&amp;index=4">https://www.youtube.com/watch?v=eNLm5Xbgmd0&amp;list=PLre5AT9JnKShBOPeuiD9b-I4XROIJhkIU&amp;index=4</a>
</li>

</ol>



<p></p><p></p>
<p><small>Autor: <a href="http://www.fit.vutbr.cz/~tisnovpa">Pavel Tišnovský</a> &nbsp; 2023</small></p>
</body>
</html>

