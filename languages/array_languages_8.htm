<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
        "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html>
<head>
<title>Uiua: nevšední kombinace zásobníkového jazyka s jazykem pro práci s poli</title>
<meta name="Author" content="Pavel Tisnovsky" />
<meta name="Generator" content="vim" />
<meta http-equiv="content-type" content="text/html; charset=utf-8" />
<style type="text/css">
         body {color:#000000; background:#ffffff;}
         h1  {font-family: arial, helvetica, sans-serif; color:#ffffff; background-color:#c00000; text-align:center; padding-left:1em}
         h2  {font-family: arial, helvetica, sans-serif; color:#ffffff; background-color:#0000c0; padding-left:1em; text-align:left}
         h3  {font-family: arial, helvetica, sans-serif; color:#000000; background-color:#c0c0c0; padding-left:1em; text-align:left}
         h4  {font-family: arial, helvetica, sans-serif; color:#000000; background-color:#e0e0e0; padding-left:1em; text-align:left}
         a   {font-family: arial, helvetica, sans-serif;}
         li  {font-family: arial, helvetica, sans-serif; color:#000000; text-align:justify; width:450px;}
         ol  {font-family: arial, helvetica, sans-serif; color:#000000; text-align:justify; width:450px;}
         ul  {font-family: arial, helvetica, sans-serif; color:#000000; text-align:justify; width:450px;}
         p   {font-family: arial, helvetica, sans-serif; color:#000000; text-align:justify;}
         pre {background:#e0e0e0}
</style>
</head>

<body>

<h1>Uiua: nevšední kombinace zásobníkového jazyka s jazykem pro práci s poli</h1>

<h3>Pavel Tišnovský</h3>

<p></p>

<h1>Úvodník</h1>

<p>Dnes se ve stručnosti seznámíme s programovacím jazykem, který lze zařadit jak mezi jazyky zásobníkové ("Forthovská" skupina), tak i mezi jazyky určené pro práci s n-rozměrnými poli ("APL" skupina). Tento neobvyklý programovací jazyk s esoterickou syntaxí i sémantikou, má i prapodivné jméno - Uiua.</p>



<h2>Obsah</h2>

<p><a href="#k01">1. Mainstreamové, ne-mainstreamové a esoterické programovací jazyky</a></p>
<p><a href="#k02">2. Uiua: nevšední kombinace zásobníkového jazyka s&nbsp;jazykem pro práci s&nbsp;poli</a></p>
<p><a href="#k03">3. Základní koncepty, na nichž je programovací jazyk Uiua postaven</a></p>
<p><a href="#k04">4. Programovací jazyky založené na zásobníku operandů a RPN</a></p>
<p><a href="#k05">5. Použití zásobníku v&nbsp;programovacím jazyku Uiua</a></p>
<p><a href="#k06">6. Funkce pro manipulace s&nbsp;prvky uloženými na zásobníku</a></p>
<p><a href="#k07">7. Základní monadické funkce pro zpracování skalárních hodnot</a></p>
<p><a href="#k08">8. Základní dyadické funkce pro zpracování skalárních hodnot</a></p>
<p><a href="#k09">9. Pole</a></p>
<p><a href="#k10">10. Konstrukce polí</a></p>
<p><a href="#k11">11. Zpracování polí prvek po prvku</a></p>
<p><a href="#k12">12. Monadické funkce pro operace nad celými poli</a></p>
<p><a href="#k13">13. Ukázka použití vybraných monadických funkcí</a></p>
<p><a href="#k14">14. Dyadické funkce pro operace nad celými poli</a></p>
<p><a href="#k15">15. Ukázka použití vybraných dyadických funkcí</a></p>
<p><a href="#k16">16. Agregační operace</a></p>
<p><a href="#k17">17. Iterace nad prvky polí</a></p>
<p><a href="#k18">18. Závěr</a></p>
<p><a href="#k19">19. Předchozí články o rozsáhlém světu &bdquo;array programmingu&ldquo;</a></p>
<p><a href="#k20">20. Odkazy na Internetu</a></p>



<p><a name="k01"></a></p>
<h2 id="k01">1. Mainstreamové, ne-mainstreamové a esoterické programovací jazyky</h2>

<p>Na stránkách Roota jsme se již mohli seznámit s&nbsp;různými programovacími
jazyky. Jednalo se jak o programovací jazyky patřící spíše do mainstreamu (do
této kategorie si v&nbsp;současnosti dovolím zařadit <a
href="https://www.root.cz/serialy/programovaci-jazyk-rust/">Rust</a> i <a
href="https://www.root.cz/serialy/programovaci-jazyk-go/">Go</a>), tak i o
programovací jazyky velmi specializované (<a
href="https://www.root.cz/serialy/programovaci-jazyk-julia/">Julia</a> či <a
href="https://www.root.cz/serialy/programovaci-jazyk-r/">R</a>). A zapomenout
nesmíme ani na různé více či méně esoterické programovací jazyky, o nichž jsme
psali v&nbsp;seriálu <a
href="https://www.root.cz/serialy/programovaci-jazyky-z-vyvojarskeho-pekla/">Programovací
jazyky z&nbsp;vývojářského pekla</a>.</p>

<p>Minimálně dvě skupiny programovacích jazyků, s&nbsp;nimiž jsme se prozatím
seznámili, nepatří (alespoň nikoli v&nbsp;současnosti) mezi mainstream.
V&nbsp;první skupině nalezneme jazyky založené na použití dvojice zásobníků
(konkrétně na <i>zásobníku operandů</i> a na <i>zásobníku návratových
hodnot</i>). Mezi tyto jazyky patří především <a
href="https://www.root.cz/serialy/programovaci-jazyk-forth/">programovací jazyk
Forth</a>, ale například taktéž jazyky <a
href="https://www.root.cz/serialy/zasobnikove-jazyky/">Joy a Factor</a>, které
jsou Forthem jasně inspirovány. A druhou skupinou ne-mainstreamových
programovacích jazyků tvoří jazyky specializované pro práci s&nbsp;n-rozměrnými
poli, tedy zejména APL, J, BQN, K, Q či jazyk Nial.</p>



<p><a name="k02"></a></p>
<h2 id="k02">2. Uiua: nevšední kombinace zásobníkového jazyka s&nbsp;jazykem pro práci s&nbsp;poli</h2>

<p>V&nbsp;dnešním článku se ve stručnosti seznámíme s&nbsp;programovacím
jazykem, který je možné zařadit jak mezi jazyky zásobníkové (tedy patřící do
&bdquo;Forthovské&ldquo; skupiny), tak i mezi jazyky určené pro práci
s&nbsp;n-rozměrnými poli (jde tedy o &bdquo;APL&ldquo; skupinu). Tento
neobvyklý programovací jazyk, jehož syntaxe a sémantika je poněkud esoterická,
má i dosti prapodivné jméno &ndash; <strong>Uiua</strong> (vyslovováno má být
jako <i>wee-wuh</i>). Mohlo by se zdát, že propojení zásobníkového jazyka
s&nbsp;jazykem pro práci s&nbsp;n-rozměrnými poli je poněkud umělé, ale
výsledek je až překvapivě konzistentní, i když bez předchozího tréninku
pochopitelně velmi špatně čitelný. Navíc je díky syntaxi zápisu umožněn a
podporován <i>tacit programming</i> neboli <i>point-free style</i>, což je
způsob programování bez nutnosti explicitního pojmenovávání předávaných
parametrů, jemuž jsme se věnovali v&nbsp;článku <a
href="https://www.root.cz/clanky/jazyk-apl-kombinatory-vlacky-a-point-free-style/">
Jazyk APL, kombinátory, vláčky a point-free style</a> (a který je vlastně
implicitně podporován prakticky všemi zásobníkovými jazyky).</p>



<p><a name="k03"></a></p>
<h2 id="k03">3. Základní koncepty, na nichž je programovací jazyk Uiua postaven</h2>

<p>Programovací jazyk Uiua je postaven na několika konceptech, s&nbsp;nimiž se
podrobněji setkáme v&nbsp;navazujících kapitolách:</p>

<ol>

<li>Prvním konceptem je fakt, že operandy jsou ukládány na zásobník
(<i>stack</i>). Zásobník zde funguje stejně, jako je tomu v&nbsp;mnoha
klasických zásobníkových jazycích, tj.&nbsp;poslední prvek vložený na zásobník
je umístěn na vrchol zásobníku (<i>TOS &ndash; Top of Stack</i>) a taktéž je
jako první ze zásobníku vyjmut. Jinými slovy &ndash; jedná se o datovou
struktury typu <i>LIFO &ndash; Last In, First Out</i>.</li>

<li>Další koncept spočívá ve způsobu zpracování jednotlivých programových řádků
po jejich parsingu. Operandy, funkce a modifikátory, jsou totiž čteny zprava
doleva (ano, čtete správně &ndash; zprava doleva). Pokud je nalezen operand
(hodnota), je uložen na zásobník, funkce své operandy čtou ze zásobníku a
modifikátory mění chování funkcí. Tím je vlastně popsána celá sémantika
:-)</li>

<li>Operandy jsou jen dvou typů &ndash; skaláry a pole.</li>

<li>Funkce mohou být <i>monadické</i> (s&nbsp;jedním operandem) nebo
<i>dyadické</i> (se dvěma operandy). Ovšem teoreticky lze díky použití
zásobníku mít i funkce s&nbsp;větším počtem operandů (na rozdíl od APL, kde je
to minimálně problematické až nemožné).</li>

<li>Funkce, které pracují se skaláry, dokážou postupně zpracovat i prvky pole
či odpovídající si prvky pole (například součet polí je realizován prvek po
prvku).</li>

<li>Poté existují funkce pracující pouze s&nbsp;poli. Příkladem je funkce
<i>reshape</i>, kterou nemá smysl aplikovat na skalární hodnotu.</li>

<li>V&nbsp;jazyku lze nalézt i takzvané <i>modifikátory</i>, kam spadají
například operace <i>reduce</i>, <i>fold</i> či <i>scan</i> apod. Jedná se o
nejsilnější koncept tohoto jazyka (převzatý z&nbsp;APL).</li>

<li>A nakonec se v&nbsp;jazyku nachází &bdquo;podivnosti&ldquo; nazvané Planet
a Ocean (viz závěrečné kapitoly).</li>

</ol>

<a href="https://www.root.cz/obrazek/1111425/"><img src="https://i.iinfo.cz/images/64/uiua-ide-prev.webp" class="image-1111425" width="370" height="181" data-prev-filename="https://i.iinfo.cz/images/64/uiua-ide-prev.webp" data-prev-width="370" data-prev-height="181" data-large-filename="https://i.iinfo.cz/images/64/uiua-ide-large.webp" data-large-width="720" data-large-height="352" alt="&#160;" title="Autor: tisnik, podle licence: &lt;a href=&quot;https://creativecommons.org/publicdomain/mark/1.0/deed.en&quot;&gt;Public Domain&lt;/a&gt;" /></a>
<p><i>Obrázek 1: Interaktivní webové prostředí programovacího jazyka Uiua.
V&nbsp;současnosti si lze základní vlastnosti většiny programovacích jazyků
ověřit právě v&nbsp;různých webových prostředích, takže není vyžadována (mnohdy
zbytečně komplikovaná) instalace.</i></p>



<p><a name="k04"></a></p>
<h2 id="k04">4. Programovací jazyky založené na zásobníku operandů a RPN</h2>

<p>V&nbsp;úvodním textu jsme se zmínili o programovacích jazycích <i>Forth</i>,
<i>Joy</i>, <i>Factor</i> (ale patří sem například i <i>PostScript</i>). I
přesto, že se tyto programovací jazyky od sebe v&nbsp;mnoha ohledech odlišují,
mají jednu důležitou vlastnost společnou &ndash; výpočty, tj.&nbsp;aritmetické
operace, logické operace a v&nbsp;neposlední řadě i rozhodovací (řídicí)
konstrukce jsou prováděny s&nbsp;hodnotami uloženými na zásobníku (ten je
z&nbsp;tohoto důvodu nazýván <i>zásobník operandů</i>). Díky tomu bylo možné
tyto programovací jazyky interně značně zjednodušit, protože se o transformaci
výrazů z&nbsp;dnes běžné infixové podoby do podoby postfixové (jinak známé pod
názvem <i>převrácená polská notace/Reverse Polish Notation, Reverse Polish
Notation &ndash; RPN</i>) musí postarat sám programátor. To ve skutečnosti není
nijak složité, ostatně s&nbsp;prakticky stejným (pseudo)problémem se musí
potýkat i ti uživatelé, kteří například používají kalkulačky vyráběné
společností <i>Hewlett-Packard</i>.</p>

<img src="https://i.iinfo.cz/images/537/hp-rpn.webp" class="image-1111423" width="330" height="600" alt="&#160;" title="Autor: Wikipedia, podle licence: &lt;a href=&quot;https://creativecommons.org/licenses/by/4.0/legalcode.cs&quot;&gt;CC-BY&lt;/a&gt;" />
<p><i>Obrázek 2: I moderní kalkulačky vyráběné společností Hewlett-Packard
podporují převrácenou polskou notaci.</i></p>  

<p><div class="rs-tip-major">Poznámka: mimochodem &ndash; podle názoru
některých vývojářů se všechny čtyři výše zmíněné programovací jazyky už nachází
na hranici mezi &bdquo;civilizovanými&ldquo; programovacími jazyky a jazyky
esoterickými, i když autor článku je velkým <a
href="http://www.root.cz/serialy/programovaci-jazyk-forth/">fandou</a>
zásobníkových jazyků, takže tento názor plně nesdílí :-).</div></p>

<p>V&nbsp;této kapitole si jen v&nbsp;krátkosti připomeňme, že při použití
zásobníku operandů přímo v&nbsp;programovacím jazyku jsou hodnoty na zásobník
ukládány explicitně (zápis <strong>42</strong> tedy většinou znamená uložení
této hodnoty na vrchol zásobníku operandů), aritmetické a logické operace
používají implicitní adresování operandů (vždy se totiž jedná o hodnotu
uloženou na vrcholu zásobníku či těsně pod ním) a kromě toho se většinou
setkáme i s&nbsp;několika pomocnými operacemi určenými pro manipulaci
s&nbsp;obsahem zásobníku. Tyto operace bývají nazývány <strong>dup</strong>
(zduplikování hodnoty uložené na vrcholu zásobníku, zásobník se o jeden prvek
zvětší), <strong>drop</strong> (odstranění hodnoty z&nbsp;vrcholu zásobníku
operandů, zásobník se o jeden prvek zmenší), <strong>swap</strong> (prohození
dvou nejvyšších prvků uložených na zásobníku, velikost zásobníku se nezmění) a
<strong>rot</strong> (rotace tří nejvyšších prvků, velikost zásobníku se opět
nezmění). Tyto názvy mají dnes již vlastně historický původ, protože byly
použity v&nbsp;programovacím jazyku Forth; později se začaly používat například
i v&nbsp;zásobníkových virtuálních strojích.</p>

<p><div class="rs-tip-major">Poznámka: vrchol zásobníku operandů se označuje
zkratkou <i>TOS</i> neboli <i>Top Of Stack</i>. Někdy se setkáme i se zkratkou
<i>TOS1</i> (popř.s&nbsp;dalšími čísly), které určují prvky uložené těsně pod
<i>TOS</i>. Tyto zkratky se používají například v&nbsp;bajtkódu programovacího
jazyka Python.</div></p>

<p>Nicméně se vraťme k&nbsp;zásobníku operandů a k&nbsp;tacit programmingu. Ve
<i>Forthu</i> je možné napsat například následující funkci:</p>

<pre>
<strong>:foo + * ;</strong>
</pre>

<p>Tato funkce na zásobníku očekává alespoň tři číselné hodnoty, které ovšem
uvnitř funkce nejsou nikde explicitně pojmenovány ani (explicitně) použity.
Použití této funkce je stejně snadné jako její zápis, pochopitelně pokud si
zvyknete na RPN:</p>

<pre>
<strong>3 2 1 foo .</strong>
9
</pre>

<p>Nejprve jsme na zásobník uložili tři hodnoty. Posléze se zavolala funkce
<strong>foo</strong>, která tyto hodnoty nějakým způsobem zpracovala. Na
nakonec byla hodnota umístěná na TOS vypsána další funkcí se jménem . (ano,
tečka je ve Forthu skutečně zcela legitimní jméno funkce).</p>

<p>Povšimněte si, že nyní těla funkce <strong>foo</strong>:

<pre>
<strong>+ *</strong>
</pre>

<p>Tělo této funkce obsahuje pouze dvě tzv.&nbsp;slova &bdquo;+&ldquo; a
&bdquo;*&ldquo;. Každé z&nbsp;těchto slov očekává na zásobníku operandů dvojici
hodnot, které jsou sečteny popř.&nbsp;vynásobeny a výsledek je uložen zpět na
zásobník operandů. Nikde tedy není nutné psát, jak se operandy jmenují a už
vůbec ne, jak se jmenuje výsledná hodnota. Navíc ani funkce
<strong>foo</strong> tyto údaje neobsahuje.</p>

<p><div class="rs-tip-major">Poznámka: a právě zápis <strong>:foo + *
;</strong> ukazuje typické znaky <i>tacit programmingu</i>. Na jednu stranu je
tento zápis velmi úsporný a v&nbsp;mnoha případech i idiomatický. Na stranu
druhou může být tento zápis dosti těžko rozluštitelný, a to právě díky jeho
úspornosti &ndash; všechny nepodstatné detaily byly vynechány, takže kód
prakticky postrádá redundanci (která je například v&nbsp;hovorovém jazyce
užitečná, neboť usnadňuje porozumění zprávě i při jejím &bdquo;zašumění&ldquo;
či nedokonalé znalosti jazyka).</div></p>



<p><a name="k05"></a></p>
<h2 id="k05">5. Použití zásobníku v&nbsp;programovacím jazyku Uiua</h2>

<p>Všechny dále uvedené příklady si můžeme vyzkoušet na adrese <a
href="https://www.uiua.org/">https://www.uiua.org/</a> přímo
v&nbsp;interaktivním prostředí pracujícím ve webovém prohlížeči.</p>

<p><div class="rs-tip-major">Poznámka: ve všech následujících demonstračních
příkladech bude prostředí programovacího jazyka Uiua zobrazovat obsah zásobníku
operandů. Přitom je použit takový způsob zobrazení, aby byl nejvyšší prvek
zásobníku operandů (<i>TOS &ndash; Top Of Stack</i>) zobrazen na nejvyšším
řádku (zásobník tedy v&nbsp;tomto pojetí poroste zdola nahoru, což ostatně
odpovídá i chování běžných mikroprocesorů). Toto chování je ovšem nutné
v&nbsp;interaktivním prostředí jazyka Uiua explicitně nastavit po kliknutí na
ikonu ozubeného kolečka (<i>show settings</i>) a výběrem položky &bdquo;Top at
Top&ldquo; ve výběrovém boxu <i>Stack</i>. V&nbsp;implicitním nastavení jsou
totiž prvky zásobníku zobrazeny v&nbsp;opačném pořadí, což však znamená, že
označení <i>Top Of Stack</i> nebude mít svoji vizuální obdobu.</div></p>

<a href="https://www.root.cz/obrazek/1111424/"><img src="https://i.iinfo.cz/images/58/uiua-prev.webp" class="image-1111424" width="370" height="132" data-prev-filename="https://i.iinfo.cz/images/58/uiua-prev.webp" data-prev-width="370" data-prev-height="132" data-large-filename="https://i.iinfo.cz/images/58/uiua-large.webp" data-large-width="720" data-large-height="257" alt="&#160;" title="Autor: tisnik, podle licence: &lt;a href=&quot;https://creativecommons.org/publicdomain/mark/1.0/deed.en&quot;&gt;Public Domain&lt;/a&gt;" /></a>
<p><i>Obrázek 3: Nastavení, které je nutné provést v&nbsp;interaktivním
vývojovém prostředí jazyka Uiua tak, aby se obsah zásobníku zobrazoval
způsobem, který dává zkratce TOS význam.</i></p>

<p>V&nbsp;programovacím jazyku <i>Uiua</i> se nepoužívá klasická a standardní
převrácená polská notace (tedy již popsaná <i>RPN</i>) ale určitá obdoba
(přímé) polské notace, což může být poměrně matoucí. Navíc se operátory a
operandy zapsané na řádku zpracovávají <i>zprava doleva</i>. To má sice své
logické důvody, o nichž se zmíníme dále, ovšem opět se jedná o koncept, který
může být dosti nezvyklý. Jak se ale tyto dvě vlastnosti, resp.&nbsp;jejich
kombinace, projeví v&nbsp;praxi? Pokud například na jediný řádek zapíšeme
trojici číselných hodnot, budou tyto hodnoty uloženy na zásobník (až potud je
vše očekávatelné). Ovšem číselné hodnoty jsou zpracovávány zprava doleva a
právě v&nbsp;tomto pořadí jsou uloženy na zásobník. Výsledkem tedy bude, že
první zapsaná hodnota bude uložena na vrchol zásobníku operandů, tedy zcela
opačně, než je tomu v&nbsp;klasické RPN:</p>

<pre>
<strong>1 2 3</strong>
&nbsp;
1
2
3
</pre>

<p>Povšimněte si, že po spuštění výše uvedeného programu (ten je zapsán tučně)
se v&nbsp;interaktivním prostředí pod programem zobrazí trojice hodnot tak, jak
jsou uloženy na zásobníku. Vzhledem ke způsobu vyhodnocování zprava doleva se
tedy na zásobník nejprve uloží hodnota 3, poté hodnota 2 a nakonec bude na
vrchol zásobníku bude uložena hodnota 1.</p>

<p>Můžeme si otestovat i nepatrně odlišný program, po jehož spuštění se
nejdříve na zásobník uloží hodnoty 2 a 1 (přesně v&nbsp;tomto pořadí) a
následně se tyto hodnoty sečtou spuštěním operace +, která ze zásobníku vyjme
dva prvky, sečte je a na zásobník vrátí výsledek součtu:</p>

<pre>
<strong>+ 1 2</strong>
&nbsp;
3
</pre>

<p>Operace + ovšem ve skutečnosti pracuje pouze se dvěma nejvyššími prvky
uloženými na zásobníku. Případné další prvky nejsou dotčeny:</p>

<pre>
<strong>+ 1 2 100 100</strong>
&nbsp;
3
100
100
</pre>

<p>Operátor zapsaný zcela nalevo bude proveden nejpozději, což zde konkrétně
znamená, že vynásobí hodnoty 3 a 100, přičemž výsledek opět uloží zpět na
zásobník:</p>

<pre>
<strong>× + 1 2 100 100</strong>
&nbsp;
300
100
</pre>

<p><div class="rs-tip-major">Poznámka: povšimněte si, jak se kombinace obou
výše uvedených vlastností projevuje na způsobu seřazení operátorů a
operandů.</div></p>

<p>Infixově zapsaná operace (1+2)&times;3 vypadá v&nbsp;pojetí programovacího
jazyka Uiua následovně:</p>

<pre>
<strong>× + 1 2 3</strong>
&nbsp;
9
</pre>

<p>Nebo též:</p>

<pre>
<strong>× 3 + 1 2</strong>
&nbsp;
9
</pre>

<p>Ovšem nic nám nebrání v&nbsp;zápisu přes více řádků:</p>

<pre>
<strong>+ 1 2</strong>
<strong>× 3</strong>
&nbsp;
9
</pre>

<p>nebo:</p>

<pre>
<strong>1 2 3</strong>
<strong>×+</strong>
&nbsp;
9
</pre>

<p>či dokonce:</p>

<pre>
<strong>1 2 3</strong>
<strong>+</strong>
<strong>×</strong>
&nbsp;
9
</pre>



<p><a name="k06"></a></p>
<h2 id="k06">6. Funkce pro manipulace s&nbsp;prvky uloženými na zásobníku</h2>

<p>V&nbsp;programovacím jazyku Uiua existuje šest funkcí, které jsou určeny pro
manipulace s&nbsp;prvky uloženými na zásobníku. Některé z&nbsp;těchto funkcí
známe již z&nbsp;popisu zásobníkových programovacích jazyků, ovšem poslední dvě
funkce jsou specifické pro Uiua. A pochopitelně, díky tomu, že se jedná o jazyk
odvozený od APL, jsou všechny funkce reprezentovány jednoznakovými symboly
(z&nbsp;Unicode):</p>

<table>
<tr><th>Symbol</th><th>Jméno</th><th>Stručný popis</th></tr>
<tr><td>.</td><td>duplicate</td><td>duplikace prvku na TOS</td></tr>
<tr><td>,</td><td>over</td><td>duplikace prvku <i>pod</i> TOS</td></tr>
<tr><td>:</td><td>flip</td><td>prohození dvou nejvyšších prvků na zásobníku</td></tr>
<tr><td>;</td><td>pop</td><td>odstranění prvku z&nbsp;TOS</td></tr>
<tr><td>∩</td><td>both</td><td>zavolá monadickou funkci na dva operandy (nebo dyadickou funkci na dvojici operandů)</td></tr>
<tr><td>⸮</td><td>trace</td><td>vypíše (<i>pretty print</i>) prvek na TOS, ovšem bez jeho odstranění ze zásobníku</td></tr>
</table>

<p>Otestování základního chování těchto funkcí:</p>

<p>Duplikace prvku na TOS:</p>

<pre>
<strong>. 1 2 3</strong>
&nbsp;
1
1
2
3
</pre>

<p>Duplikace prvku pod TOS:</p>

<pre>
<strong>, 1 2 3</strong>
&nbsp;
2
1
2
3
</pre>

<p>Prohození dvou nejvyšších prvků na zásobníku:</p>

<pre>
<strong>: 1 2 3</strong>
&nbsp;
2
1
3
</pre>

<p>Odstranění nejvyššího prvku z&nbsp;TOS:</p>

<pre>
<strong>; 1 2 3</strong>
&nbsp;
2
3
</pre>

<p>Změna znaménka u prvních dvou prvků:</p>

<pre>
<strong>∩¯ 1 2 3</strong>
&nbsp;
¯1
¯2
3
</pre>

<p>Výpis podrobnějších informací o prvku s&nbsp;hodnotou -1:</p>

<pre>
<strong>⸮∩¯ 1 2 3</strong>
&nbsp;
┌╴1:1
├╴¯1
└╴╴╴╴
¯1
¯2
3
</pre>



<p><a name="k07"></a></p>
<h2 id="k07">7. Základní monadické funkce pro zpracování skalárních hodnot</h2>

<p>Připomeňme si, že v&nbsp;programovacích jazycích odvozených od APL se
rozlišuje mezi funkcemi <i>monadickými</i> a <i>dyadickými</i>. Monadické
funkce mají pouze jeden operand (či parametr), kdežto dyadické funkce mají dva
operandy (parametry). Nejprve si tedy popišme tu nejjednodušší skupinu funkcí.
Jedná se o monadické funkce určené pro zpracování skalárních hodnot:</p>

<table>
<tr><th>Symbol</th><th>Jméno</th><th>Stručný popis</th></tr>
<tr><td>¬</td><td>not</td><td>logická negace</td></tr>
<tr><td>±</td><td>sign</td><td>vrací -1, 0 či +1 podle znaménka operandu</td></tr>
<tr><td>¯</td><td>negate</td><td>změna znaménka</td></tr>
<tr><td>⌵</td><td>absolute value</td><td>výpočet absolutní hodnoty</td></tr>
<tr><td>√</td><td>sqrt</td><td>výpočet druhé odmocniny</td></tr>
<tr><td>○</td><td>sine</td><td>výpočet goniometrické funkce sin</td></tr>
<tr><td>⌊</td><td>floor</td><td>zaokrouhlení směrem dolů</td></tr>
<tr><td>⌈</td><td>ceiling</td><td>zaokrouhlení směrem nahoru</td></tr>
<tr><td>⁅</td><td>round</td><td>zaokrouhlení</td></tr>
</table>

<p>Několik příkladů (již bez popisu):</p>
 
<pre>
<strong>± 42</strong>
&nbsp;
1
</pre>
 
<pre>
<strong>¯ 42</strong>
&nbsp;
¯42
</pre>
 
<pre>
<strong>⌵¯42</strong>
&nbsp;
42
</pre>
 
<pre>
<strong>√⌵¯100</strong>
&nbsp;
10
</pre>

<pre>
<strong>⌊1.5</strong>
&nbsp;
1
</pre>

<pre>
<strong>⌈1.5⌊</strong>
&nbsp;
2
</pre>



<p><a name="k08"></a></p>
<h2 id="k08">8. Základní dyadické funkce pro zpracování skalárních hodnot</h2>

<p>V&nbsp;programovacím jazyku Uiua nalezneme i dyadické funkce, které jsou
určené pro zpracování skalárních hodnot. Tyto funkce ze zásobníku získají dva
prvky, provedou s&nbsp;nimi vybranou operaci a výsledek nebo výsledky uloží
zpět na zásobník. Jedná se o následující funkce:</p>

<table>
<tr><th>Symbol</th><th>Jméno</th><th>Stručný popis</th></tr>
<tr><td>=</td><td>equals</td><td>test na rovnost dvou prvků</td></tr>
<tr><td>≠</td><td>not equals</td><td>test na nerovnost dvou prkvů</td></tr>
<tr><td>&lt;</td><td>less than</td><td>test na relaci dvou prvků</td></tr>
<tr><td>≤</td><td>less or equal</td><td>test na relaci dvou prvků</td></tr>
<tr><td>&gt;</td><td>greater than</td><td>test na relaci dvou prvků</td></tr>
<tr><td>≥</td><td>greater or equal</td><td>test na relaci dvou prvků</td></tr>
<tr><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td></tr>
<tr><td>+</td><td>add</td><td>součet</td></tr>
<tr><td>-</td><td>subtract</td><td>rozdíl</td></tr>
<tr><td>×</td><td>multiply</td><td>součin</td></tr>
<tr><td>÷</td><td>divide</td><td>podíl</td></tr>
<tr><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td></tr>
<tr><td>◿</td><td>modulus</td><td>zbytek po dělení</td></tr>
<tr><td>ⁿ</td><td>power</td><td>x^y</td></tr>
<tr><td>ₙ</td><td>logarithm</td><td>logaritmus o zvoleném základu</td></tr>
<tr><td>↧</td><td>minimum</td><td>menší hodnota</td></tr>
<tr><td>↥</td><td>maximum</td><td>větší hodnota</td></tr>
<tr><td>∠</td><td>atangent</td><td>arctan pro (dvě) přepony trojúhelníku</td></tr>
<tr><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td></tr>
<tr><td>ℂ</td><td>complex</td><td>konstrukce komplexního čísla z&nbsp;reálné a imaginární složky</td></tr>
</table>

<p>U některých výše zmíněných operací je nutné si dát pozor na pořadí operandů
uložených na zásobníku:</p>

<pre>
<strong>÷ 1 2</strong>
&nbsp;
2
</pre>

<pre>
<strong>÷ 2 1</strong>
&nbsp;
0.5
</pre>

<p>Logaritmus o zvoleném základu:</p>

<pre>
<strong>ₙ 10 10000</strong>
&nbsp;
4
</pre>

<pre>
<strong>ₙ 10000 10</strong>
&nbsp;
0.25
</pre>



<p><a name="k09"></a></p>
<h2 id="k09">9. Pole</h2>

<p>V&nbsp;programovacím jazyku Uiua se primárně rozlišují dvě skupiny typů
hodnot. První skupinu tvoří <i>atomy</i> (<i>atom</i>), druhou skupinu pak
<i>pole</i> (<i>array</i>). Na pole se můžeme dívat jako na skupinu atomů
organizovaných podél os (<i>axes</i>), přičemž počet os určuje dimenzi pole.
Každé pole má svůj <i>tvar</i>, který popisuje velikost pole měřenou podél
jednotlivých os (tedy pole s&nbsp;tvarem [2 3 4] má rozměry 2&times;3&times;4
prvky). Os přitom může být (prakticky) libovolný počet. Další důležitou
vlastností polí je, že jsou <i>homogenní</i>, tj.&nbsp;obsahují prvky stejného
typu.</p>

<p>Pole lze ukládat na zásobník, stejně jako skalární hodnoty. A navíc platí,
že monadické a dyadické funkce popsané v&nbsp;předchozích kapitolách, lze
aplikovat i na pole &ndash; potom se takové funkce buď aplikují na všechny
prvky pole (monadické funkce) nebo na všechny odpovídající si prvky ze dvou
polí (dyadické funkce).</p>



<p><a name="k10"></a></p>
<h2 id="k10">10. Konstrukce polí</h2>

<p>V&nbsp;programovacím jazyku Uiua existuje <i>literál</i> představující celé
pole. Tento literál se zapisuje formou hodnot jednotlivých prvků (musí se
jednat o hodnoty), které jsou spojeny (či odděleny &ndash; záleží na úhlu
pohledu) podtržítkem. Literál představující jednorozměrné pole se čtyřmi prvky
se zapíše takto:</p>

<pre>
<strong>1_2_3_4</strong>
&nbsp;
[1 2 3 4]
</pre>

<p>Můžeme také použít <i>konstruktor</i> pole, v&nbsp;němž se jednotlivé prvky
zapisují do hranatých závorek a odděleny jsou nějakým bílým znakem:</p>

<pre>
<strong>[1 2 3 4]</strong>
&nbsp;
[1 2 3 4]
</pre>

<p>V&nbsp;tomto případě jsou ovšem prvky vyhodnocovány (nejde o literál) a to
nám například umožňuje provést výpočet 1+2 a 3+4 s&nbsp;tím, že výsledky těchto
výpočtů budou zapsány do nově zkonstruovaného pole:</p>

<pre>
<strong>[+ 1 2 + 3 4]</strong>
&nbsp;
[3 7]
</pre>

<p>Konstrukce vícerozměrného pole je snadná &ndash; prvky n-rozměrného pole
jsou totiž n-1 rozměrná pole, takže použijeme konstruktor, kterému tato menší
pole předáme:</p>

<pre>
<strong>[[1 2][3 4]]</strong>
&nbsp;
╭─     
╷ 1 2  
  3 4  
      ╯
</pre>

<p>A takto vypadá konstrukce trojrozměrného pole:</p>

<pre>
<strong>[[[0 0][0 0]][[1 2][3 4]]]</strong>
&nbsp;
╭─     
╷ 0 0  
╷ 0 0  
       
  1 2  
  3 4  
      ╯
</pre>

<p>Jazyk Uiua pracuje i s&nbsp;řetězci. Řetězcový skalár se zapíše
následovně:</p>

<pre>
<strong>"Hello world"</strong>
&nbsp;
"Hello world"
</pre>

<p>Literál představující pole obsahující řetězce:</p>

<pre>
<strong>"Hello"_"world"</strong>
&nbsp;
╭─         
╷ "Hello"  
  "world"  
          ╯
</pre>

<p>Výsledné pole ovšem musí být homogenní &ndash; všechny prvky musí být
stejného typu:</p>

<pre>
<strong>"Hello"_"world"_42</strong>
&nbsp;
Error: Cannot append character array to number array
  at 1:1
1 | "Hello"_"world"_4
</pre>



<p><a name="k11"></a></p>
<h2 id="k11">11. Zpracování polí prvek po prvku</h2>

<p>Jak již víme z&nbsp;předchozího textu, lze všechny monadické a dyadické
funkce určené pro práci se skaláry použít i pro dvojici stejně velkých polí
(tedy polí se shodným <i>tvarem</i>). Takové funkce jsou aplikovány na
odpovídající si prvky polí.</p>

<p>Součet dvou polí prvek po prvku:</p>

<pre>
<strong>+ [1 2 3] [4 5 6]</strong>
&nbsp;
[5 7 9]
</pre>

<p>Takzvaný <i>broadcasting</i> umožňující přičíst hodnotu 10 ke každému prvku
pole:</p>

<pre>
<strong>+ [1 2 3] 10</strong>
&nbsp;
[11 12 13]
</pre>

<p>Výsledkem této operace je pole s&nbsp;pravdivostními hodnotami
reprezentovanými jako 1 a 0:</p>

<pre>
<strong>≠ [1 2 3] 2</strong>
&nbsp;
[1 0 1]
</pre>

<p>Porovnání polí prvek po prvku, výsledkem je opět pole (se shodným tvarem)
obsahující výsledky porovnání:</p>

<pre>
<strong>≤ [1 2 3 4] [4 3 2 1]</strong>
&nbsp;
[0 0 1 1]
</pre>

<p>Tvary polí (<i>shape</i>) ovšem musí být shodné:</p>

<pre>
<strong>≤ [1 2 3 4] [4 3 2 1 0]</strong>
&nbsp;
Error: Shapes [4] and [5] do not match
  at 1:1
1 | ≤ [1 2 3 4] [4 3 2 1 0]
</pre>

<p>Součet dvou (dvourozměrných) matic:</p>

<pre>
<strong>+ [[1 2][3 4]] [[5 6][7 8]]</strong>
&nbsp;
╭─       
╷  6  8  
  10 12  
        ╯
</pre>



<p><a name="k12"></a></p>
<h2 id="k12">12. Monadické funkce pro operace nad celými poli</h2>

<p>V&nbsp;jazyku Uiua jsou realizovány i funkce, které pracují nad celými poli
(nikoli tedy nutně prvek po prvku). Tyto funkce jsou vypsány v&nbsp;následující
tabulce:</p>

<table>
<tr><th>Symbol</th><th>Jméno</th><th>Stručný popis</th></tr>
<tr><td>⧻</td><td>length</td><td>vrací délku pole (v&nbsp;první dimenzi)</td></tr>
<tr><td>△</td><td>shape</td><td>vrací tvar pole (což je taktéž pole)</td></tr>
<tr><td>⇡</td><td>range</td><td>generátor pole se sekvencí hodnot</td></tr>
<tr><td>⊢</td><td>first</td><td>vrací první prvek pole</td></tr>
<tr><td>⇌</td><td>reverse</td><td>otočí celé pole (resp.&nbsp;prvky v&nbsp;něm)</td></tr>
<tr><td>♭</td><td>deshape</td><td>konverze pole o libovolném počtu dimenzí na pole s&nbsp;jednou dimenzí (vektorem)</td></tr>
<tr><td>¤</td><td>fix</td><td>přidá další dimenzi (vlastně uzavře pole do dalšího pole s&nbsp;jediným prvkem)</td></tr>
<tr><td>⋯</td><td>bits</td><td>každý prvek pole se převede na pole bitů, které reprezentují jeho hodnotu</td></tr>
<tr><td>⍉</td><td>transpose</td><td>rotace pole</td></tr>
<tr><td>⍏</td><td>rise</td><td>vytvoří pole s&nbsp;indexy původních prvků tak, aby bylo pole seřaditelné</td></tr>
<tr><td>⍖</td><td>fall</td><td>dtto, ale pro opačné řazení</td></tr>
<tr><td>⊚</td><td>where</td><td>získání indexů těch prvků, které jsou nenulové (lze tím nahradit programovou smyčku)</td></tr>
<tr><td>⊛</td><td>classify</td><td>každému unikátnímu prvku pole přiřadí unikátní index (stejné prvky budou mít shodné indexy)</td></tr>
<tr><td>⊝</td><td>deduplicate</td><td>odstraní z&nbsp;pole duplikátní prvky</td></tr>
<tr><td>□</td><td>box</td><td>vloží pole do takzvaného boxu, který umožní tvorbu de facto heterogenních polí (jako v&nbsp;jazyku K)</td></tr>
<tr><td>⊔</td><td>unbox</td><td>opak předchozí operace &ndash; vyjme pole z&nbsp;boxu</td></tr>
</table>

<p><div class="rs-tip-major">Poznámka: ve skutečnosti není možné používat
skutečná heterogenní pole. Ovšem můžeme použít pole boxů (tedy prvky jsou typu
box) a poté již můžeme do boxů vkládat (zabalit?) libovolné hodnoty.</div></p>
 


<p><a name="k13"></a></p>
<h2 id="k13">13. Ukázka použití vybraných monadických funkcí</h2>

<p>Podívejme se nyní na způsob použití několika vybraných monadických funkcí
určených pro zpracování celých polí.</p>

<p>Délka pole &ndash; počet prvků v&nbsp;nejvyšší dimenzi:</p>

<pre>
<strong>⧻ [[1 2][3 4]]</strong>
&nbsp;
2
</pre>

<p>Získání tvaru (<i>shape</i>) pole:</p>

<pre>
<strong>△ [[1 2][3 4]]</strong>
&nbsp;
[2 2]
</pre>

<p>Vygenerování vektoru obsahujícího sekvenci hodnot od 0 do 9:</p>

<pre>
<strong>⇡ 10</strong>
&nbsp;
[0 1 2 3 4 5 6 7 8 9]
</pre>

<p>Získání pole pravdivostních hodnot (reprezentovaných nulami a jedničkami) na
základě porovnání prvku každého pole s&nbsp;konstantou 4:</p>

<pre>
<strong>≤ 4 ⇡ 10</strong>
&nbsp;
[1 1 1 1 1 0 0 0 0 0]
</pre>

<p>Otočení pole vytvořeného funkcí <strong>range</strong>:</p>

<pre>
<strong>⇌ ⇡ 10</strong>
&nbsp;
[9 8 7 6 5 4 3 2 1 0]
</pre>

<p><i>Deshape</i> pole &ndash; převod na jednorozměrný vektor:</p>

<pre>
<strong>♭ [[1 2][3 4][5 6]]</strong>
&nbsp;
[1 2 3 4 5 6]
</pre>

<p>Kombinace funkce pro převod pole na jednorozměrný vektor s&nbsp;funkcí pro
otočení prvků pole:</p>

<pre>
<strong>⇌♭ [[1 2][3 4][5 6]]</strong>
&nbsp;
[6 5 4 3 2 1]
</pre>



<p><a name="k14"></a></p>
<h2 id="k14">14. Dyadické funkce pro operace nad celými poli</h2>

<p>Další funkce jsou dyadické, přičemž jedním z&nbsp;parametrů je v&nbsp;tomto
případě pole (a druhým parametrem může být skalár nebo taktéž pole). Jedná se o
následující funkce:</p>

<table>
<tr><th>Symbol</th><th>Jméno</th><th>Stručný popis</th></tr>
<tr><td>≍</td><td>match</td><td>test, zda jsou pole totožná</td></tr>
<tr><td>⊟</td><td>couple</td><td>spojení dvou polí (viz příklady)</td></tr>
<tr><td>⊂</td><td>join</td><td>spojení dvou polí (viz příklady)</td></tr>
<tr><td>⊏</td><td>select</td><td>výběr většího množství prvků na základě selektorů</td></tr>
<tr><td>⊡</td><td>pick</td><td>výběr celých řádků na základě selektorů</td></tr>
<tr><td>↯</td><td>reshape</td><td>změna tvaru pole (přeskupení prvků)</td></tr>
<tr><td>☇</td><td>rerank</td><td>změna počtu dimenzí pole</td></tr>
<tr><td>↙</td><td>take</td><td>přečtení prvních n prvků z&nbsp;pole</td></tr>
<tr><td>↘</td><td>drop</td><td>pole bez prvních n prvků</td></tr>
<tr><td>↻</td><td>rotate</td><td>rotace prvků v&nbsp;poli</td></tr>
<tr><td>▽</td><td>keep</td><td>zachová prvky s&nbsp;indexy, které jsou předány v&nbsp;prvním parametru</td></tr>
<tr><td>⌕</td><td>find</td><td>vyhledání prvků z&nbsp;jednoho pole v&nbsp;jiném poli (výsledkem je pole s 0 a 1)</td></tr>
<tr><td>∊</td><td>member</td><td>test, zda je zadaný řádek součástí pole</td></tr>
<tr><td>⊗</td><td>indexof</td><td>vyhledání prvku (prvků) s&nbsp;vrácením indexů</td></tr>
</table>

<p><div class="rs-tip-major">Poznámka: některé z&nbsp;těchto funkcí sice na
první pohled vypadají nepoužitelně, ovšem jejich kombinací lze realizovat
prakticky jakoukoli (rozumnou) operaci nad polem a vyhnout se tak nutnosti
explicitního zápisu programové smyčky.</div></p>
 


<p><a name="k15"></a></p>
<h2 id="k15">15. Ukázka použití vybraných dyadických funkcí</h2>

<p>Opět se podívejme na využití vybraných dyadických funkcí určených pro práci
s&nbsp;poli.</p>

<p>Spojení dvou polí funkcí <i>couple</i>:</p>

<pre>
<strong>⊟ [1 2 3 4] [5 6 7 8]</strong>
&nbsp;
╭─         
╷ 1 2 3 4  
  5 6 7 8  
          ╯
</pre>

<p>Spojení dvou polí funkcí <i>join</i>:</p>

<pre>
<strong>⊂ [1 2 3 4] [5 6 7 8]</strong>
&nbsp;
[1 2 3 4 5 6 7 8]
</pre>

<p>Výběr prvků ze druhého pole pomocí indexů v&nbsp;poli prvním:</p>

<pre>
<strong></strong>
&nbsp;
</pre>

<pre>
<strong></strong>
&nbsp;
</pre>



<p><a name="k16"></a></p>
<h2 id="k16">16. Agregační operace</h2>

<p></p>

<table>
<tr><th>Symbol</th><th>Jméno</th><th>Stručný popis</th></tr>
<tr><td>/</td><td>reduce   </td><td></td></tr>
<tr><td>∧</td><td>fold     </td><td></td></tr>
<tr><td>\</td><td>scan     </td><td></td></tr>
<tr><td>⊕</td><td>group    </td><td></td></tr>
<tr><td>⊜</td><td>partition</td><td></td></tr>
</table>

<pre>
<strong></strong>
&nbsp;
</pre>
 


<p><a name="k17"></a></p>
<h2 id="k17">17. Iterace nad prvky polí</h2>

<p></p>

<table>
<tr><th>Symbol</th><th>Jméno</th><th>Stručný popis</th></tr>
<tr><td>∵</td><td>each  </td><td></td></tr>
<tr><td>≡</td><td>rows  </td><td></td></tr>
<tr><td>⊞</td><td>table </td><td></td></tr>
<tr><td>⊠</td><td>cross </td><td></td></tr>
<tr><td>⍥</td><td>repeat</td><td></td></tr>
<tr><td>⍢</td><td>do    </td><td></td></tr>
</table>

<pre>
<strong>/×+1⇡10</strong>
&nbsp;
3628800
</pre>

<p>Ovšem v&nbsp;některých případech může být lepší použití <i>fold</i> se specifikací prvního prvku:</p>

<pre>
<strong>∧× [1 2 3 4] 10</strong>
&nbsp;
240
</pre>

<p>Lze zkombinovat s&nbsp;počátečním prvkem, který je polem:</p>

<pre>
<strong>∧× [1 2 3 4] [1 2 10]</strong>
&nbsp;
[24 48 240]
</pre>

<p>Dalším dobrým příkladem může být modifikátor nazvaný <i>scan</i>, který
postupně prochází všemi prvky, aplikuje zvolenou funkci na aktuální prvek a
akumulátor a na vstup posílá výsledek zvolené funkce. Jedná se tedy o obdobu
funkce <i>reduction</i> z&nbsp;jazyka APL.</p></p>

<p>Výčet tabulky faktoriálů operátorem <i>scan</i> (opět zapsáno bez
mezer):</p>

<pre>
<strong>\×+1⇡10</strong>
&nbsp;
[1 2 6 24 120 720 5040 40320 362880 3628800]
</pre>

<p>A konečně si ukažme <i>outer product</i>. S&nbsp;využitím tohoto operátoru
je možné zkonstruovat velké množství matic se speciálními vlastnostmi; tyto
matice mohou mít samozřejmě téměř libovolnou velikost. Jedná se například o
jednotkové matice (obsahují jedničky v&nbsp;diagonále, ostatní prvky jsou
nulové), trojúhelníkové matice různého typu (jedničky se nachází pod či nad
diagonálou, ostatní prvky jsou nulové) atd. Tvorba těchto matic je ilustrována
na následujících příkladech, ve kterých se často používají porovnávací
(relační) funkce:</p>

<pre>
<strong>⊞= ⇡10 ⇡10</strong>
&nbsp;
╭─                     
╷ 1 0 0 0 0 0 0 0 0 0  
  0 1 0 0 0 0 0 0 0 0  
  0 0 1 0 0 0 0 0 0 0  
  0 0 0 1 0 0 0 0 0 0  
  0 0 0 0 1 0 0 0 0 0  
  0 0 0 0 0 1 0 0 0 0  
  0 0 0 0 0 0 1 0 0 0  
  0 0 0 0 0 0 0 1 0 0  
  0 0 0 0 0 0 0 0 1 0  
  0 0 0 0 0 0 0 0 0 1  
                      ╯
</pre>

<pre>
<strong>⊞≤ ⇡10 ⇡10</strong>
&nbsp;
╭─                     
╷ 1 0 0 0 0 0 0 0 0 0  
  1 1 0 0 0 0 0 0 0 0  
  1 1 1 0 0 0 0 0 0 0  
  1 1 1 1 0 0 0 0 0 0  
  1 1 1 1 1 0 0 0 0 0  
  1 1 1 1 1 1 0 0 0 0  
  1 1 1 1 1 1 1 0 0 0  
  1 1 1 1 1 1 1 1 0 0  
  1 1 1 1 1 1 1 1 1 0  
  1 1 1 1 1 1 1 1 1 1  
                      ╯
</pre>

<p>Malá násobilka:</p>

<pre>
<strong>⊞× +1⇡10 +1⇡10</strong>
&nbsp;
╭─                                
╷  1  2  3  4  5  6  7  8  9  10  
   2  4  6  8 10 12 14 16 18  20  
   3  6  9 12 15 18 21 24 27  30  
   4  8 12 16 20 24 28 32 36  40  
   5 10 15 20 25 30 35 40 45  50  
   6 12 18 24 30 36 42 48 54  60  
   7 14 21 28 35 42 49 56 63  70  
   8 16 24 32 40 48 56 64 72  80  
   9 18 27 36 45 54 63 72 81  90  
  10 20 30 40 50 60 70 80 90 100  
                                 ╯
</pre>

<p><div class="rs-tip-major">Poznámka: <i>reduce</i>, <i>fold</i>, <i>scan</i>
a <i>table</i> (nebo <i>outer product</i>) jsou pravděpodobně nejsilnějšími
zbraněmi jazyků odvozených od APL.</div></p>



<p><a name="k18"></a></p>
<h2 id="k18">18. Závěr</h2>

<p>Už z&nbsp;předchozího popisu je pravděpodobně zřejmé, že se programovací
jazyk Uiua pravděpodobně nedostane do mainstreamu a dokonce je nepravděpodobné,
že začne být ve větší míře používán v&nbsp;nice <i>array programmingu</i> (kde
se dnes používá především Dyalog APL a poté jazyky K a Q, jenž jsou vyvíjeny
společností Kx pro sice poměrně velký, ale dosti specifický sektor). Na druhou
stranu je zajímavé, jak lze s&nbsp;využitím zásobníku a operací nad poli
vytvořit programovací jazyk, v&nbsp;němž lze velmi snadno realizovat point-free
styl (<i>tacit programming</i>). A jen na okraj: poslední dobou vznikly
minimálně dva jazyky pro niku <i>array programmingu</i>. Je to právě Uiua, ale
taktéž programovací jazyk <a
href="https://www.root.cz/clanky/programovaci-jazyky-odvozene-od-apl-bqn-a-ivy-aneb-1-1-10/#k02">BQN</a>,
který je postaven na myšlenkách APL, ovšem má některé základní koncepty
promyšlenější (a možná tak představuje nejlepší cestu do světa <i>array
processingu</i>).</p>



<p><a name="k19"></a></p>
<h2 id="k19">19. Předchozí články o rozsáhlém světu &bdquo;array programmingu&ldquo;</h2>

<p>Programovacími jazyky, které jsou z&nbsp;větší či menší míry odvozeny od
programovacího jazyka APL, jsme se již na stránkách Roota zabývali
v&nbsp;několika článcích (a samozřejmě i v&nbsp;dnešním článku). Odkazy na tyto
články naleznete pod odstavcem:</p>

<ol>

<li>Jazyky umožňující operace s&nbsp;poli aneb rozsáhlý svět &bdquo;array programmingu&ldquo;<br />
<a href="https://www.root.cz/clanky/jazyky-umoznujici-operace-s-poli-aneb-rozsahly-svet-bdquo-array-programmingu-ldquo/">https://www.root.cz/clanky/jazyky-umoznujici-operace-s-poli-aneb-rozsahly-svet-bdquo-array-programmingu-ldquo/</a>
</li>

<li>Specializované jazyky pro práci s&nbsp;N-dimenzionálními poli: jazyk J<br />
<a href="https://www.root.cz/clanky/specializovane-jazyky-pro-praci-s-n-dimenzionalnimi-poli-jazyk-j/">https://www.root.cz/clanky/specializovane-jazyky-pro-praci-s-n-dimenzionalnimi-poli-jazyk-j/</a>
</li>

<li>Programovací jazyky odvozené od APL: BQN a ivy aneb 1~×`1↓↕10<br />
<a href="https://www.root.cz/clanky/programovaci-jazyky-odvozene-od-apl-bqn-a-ivy-aneb-1-1-10/">https://www.root.cz/clanky/programovaci-jazyky-odvozene-od-apl-bqn-a-ivy-aneb-1-1-10/</a>
</li>

<li>Programovací jazyk K: důkaz, že mezi námi žijí mimozemšťané<br />
<a href="https://www.root.cz/clanky/programovaci-jazyk-k-dukaz-ze-mezi-nami-ziji-mimozemstane/">https://www.root.cz/clanky/programovaci-jazyk-k-dukaz-ze-mezi-nami-ziji-mimozemstane/</a>
</li>

<li>Programovací jazyk K: důkaz, že mezi námi žijí mimozemšťané (dokončení)<br />
<a href="https://www.root.cz/clanky/programovaci-jazyk-k-dukaz-ze-mezi-nami-ziji-mimozemstane-dokonceni/">https://www.root.cz/clanky/programovaci-jazyk-k-dukaz-ze-mezi-nami-ziji-mimozemstane-dokonceni/</a>
</li>

<li>Nial Array Language: další z&nbsp;jazyků inspirovaných APL<br />
<a href="https://www.root.cz/clanky/nial-array-language-dalsi-z-jazyku-inspirovanych-apl/">https://www.root.cz/clanky/nial-array-language-dalsi-z-jazyku-inspirovanych-apl/</a>
</li>

<li>Programování mainframů: jazyk APL<br />
<a href="https://www.root.cz/clanky/programovani-mainframu-jazyk-apl/">https://www.root.cz/clanky/programovani-mainframu-jazyk-apl/</a>
</li>

<li>Programovací jazyk APL: programování bez smyček<br />
<a href="https://www.root.cz/clanky/programovaci-jazyk-apl-programovani-bez-smycek/">https://www.root.cz/clanky/programovaci-jazyk-apl-programovani-bez-smycek/</a>
</li>

<li>Programovací jazyk APL - dokončení<br />
<a href="https://www.root.cz/clanky/programovaci-jazyk-apl-dokonceni/">https://www.root.cz/clanky/programovaci-jazyk-apl-dokonceni/</a>
</li>

<li>Oslava 55 let od vzniku první implementace jazyka APL<br />
<a href="https://www.root.cz/clanky/oslava-55-let-od-vzniku-prvni-implementace-programovaciho-jazyka-apl/">https://www.root.cz/clanky/oslava-55-let-od-vzniku-prvni-implementace-programovaciho-jazyka-apl/</a>
</li>

<li>Jazyk APL, kombinátory, vláčky a point-free style<br />
<a href="https://www.root.cz/clanky/jazyk-apl-kombinatory-vlacky-a-point-free-style/">https://www.root.cz/clanky/jazyk-apl-kombinatory-vlacky-a-point-free-style/</a>
</li>

</ol>



<p><a name="k20"></a></p>
<h2 id="k20">20. Odkazy na Internetu</h2>

<ol>

<li>Seriál: programovací jazyk Rust<br />
<a href="https://www.root.cz/serialy/programovaci-jazyk-rust/">https://www.root.cz/serialy/programovaci-jazyk-rust/</a>
</li>

<li>Seriál: programovací jazyk Go<br />
<a href="https://www.root.cz/serialy/programovaci-jazyk-go/">https://www.root.cz/serialy/programovaci-jazyk-go/</a>
</li>

<li>Seriál: programovací jazyk Julia<br />
<a href="https://www.root.cz/serialy/programovaci-jazyk-julia/">https://www.root.cz/serialy/programovaci-jazyk-julia/</a>
</li>

<li>Seriál: programovací jazyk R<br />
<a href="https://www.root.cz/serialy/programovaci-jazyk-r/">https://www.root.cz/serialy/programovaci-jazyk-r/</a>
</li>

<li>Uiua: A stack-based array programming language<br />
<a href="https://www.uiua.org/">https://www.uiua.org/</a>
</li>

<li>uiua na GitHubu<br />
<a href="https://github.com/uiua-lang/uiua">https://github.com/uiua-lang/uiua</a>
</li>

<li>Nial: A powerful, interactive array language with support for flexible multiparadigm code<br />
<a href="https://www.nial-array-language.org/">https://www.nial-array-language.org/</a>
</li>

<li>Nial: dokumentace<br />
<a href="https://www.nial-array-language.org/ndocs/">https://www.nial-array-language.org/ndocs/</a>
</li>

<li>Nial na GitHubu<br />
<a href="https://github.com/niallang/Nial_Development">https://github.com/niallang/Nial_Development</a>
</li>

<li>Nial na Rosetta Code<br />
<a href="https://rosettacode.org/wiki/Category:Nial">https://rosettacode.org/wiki/Category:Nial</a>
</li>

<li>Array language comparisons<br />
<a href="https://github.com/codereport/array-language-comparisons">https://github.com/codereport/array-language-comparisons</a>
</li>

<li>K language - an introduction<br />
<a href="http://www.math.bas.bg/bantchev/place/k.html">http://www.math.bas.bg/bantchev/place/k.html</a>
</li>

<li>K7 Tutorial<br />
<a href="https://cs.nyu.edu/~shasha/papers/tutorial">https://cs.nyu.edu/~shasha/papers/tutorial</a>
</li>

<li>An Interview with Arthur Whitney, Kx CEO and Developer of Kx Technology, January 4, 2004<br />
<a href="https://web.archive.org/web/20150813004101/http://kx.com/arthur-interview.php">https://web.archive.org/web/20150813004101/http://kx.com/arthur-interview.php</a>
</li>

<li>A Shallow Introduction to the K Programming Language<br />
<a href="https://web.archive.org/web/20130801233812/http://www.kuro5hin.org/story/2002/11/14/22741/791">https://web.archive.org/web/20130801233812/http://www.kuro5hin.org/story/2002/11/14/22741/791</a>
</li>

<li>A Conversation with Arthur Whitney<br />
<a href="https://queue.acm.org/detail.cfm?id=1531242">https://queue.acm.org/detail.cfm?id=1531242</a>
</li>

<li>Anecdote about Arthur Whitney<br />
<a href="https://news.ycombinator.com/item?id=13590065">https://news.ycombinator.com/item?id=13590065</a>
</li>

<li>K - list of idioms<br />
<a href="https://github.com/kevinlawler/kona/wiki/Idioms">https://github.com/kevinlawler/kona/wiki/Idioms</a>
</li>

<li>Appendix A. Incunabulum<br />
<a href="http://keiapl.org/rhui/remember.htm#incunabulum">http://keiapl.org/rhui/remember.htm#incunabulum</a>
</li>

<li>K code study<br />
<a href="https://docs.google.com/document/d/1W83ME5JecI2hd5hAUqQ1BVF32wtCel8zxb7WPq-D4f8/edit">https://docs.google.com/document/d/1W83ME5JecI2hd5hAUqQ1BVF32wtCel8zxb7WPq-D4f8/edit</a>
</li>

<li>K tutorial<br />
<a href="https://github.com/kevinlawler/kona/wiki/Tutorial">https://github.com/kevinlawler/kona/wiki/Tutorial</a>
</li>

<li>K by EXAMPLE<br />
<a href="http://vrabi.web.elte.hu/k/kbyeg.k">http://vrabi.web.elte.hu/k/kbyeg.k</a>
</li>

<li>BQN: An APL Variant from Marshall Lochbaum (mlochbaum.github.io)<br />
<a href="https://news.ycombinator.com/item?id=24167804">https://news.ycombinator.com/item?id=24167804</a>
</li>

<li>Raytracer in 7 lines in K<br />
<a href="http://www.nsl.com/k/ray/ray.k">http://www.nsl.com/k/ray/ray.k</a>
</li>

<li>Marshall Lochbaum<br />
<a href="https://www.aplwiki.com/wiki/Marshall_Lochbaum">https://www.aplwiki.com/wiki/Marshall_Lochbaum</a>
</li>

<li>BQN<br />
<a href="https://www.aplwiki.com/wiki/BQN">https://www.aplwiki.com/wiki/BQN</a>
</li>

<li>Co-dfns<br />
<a href="https://www.aplwiki.com/wiki/Co-dfns">https://www.aplwiki.com/wiki/Co-dfns</a>
</li>

<li>Array model<br />
<a href="https://www.aplwiki.com/wiki/Array_model#Based_array_theory">https://www.aplwiki.com/wiki/Array_model#Based_array_theory</a>
</li>

<li>Fonts for BQN<br />
<a href="https://mlochbaum.github.io/BQN/fonts.html">https://mlochbaum.github.io/BQN/fonts.html</a>
</li>

<li>Leading axis theory<br />
<a href="https://www.aplwiki.com/wiki/Leading_axis_theory">https://www.aplwiki.com/wiki/Leading_axis_theory</a>
</li>

<li>A based system for general arrays<br />
<a href="https://dl.acm.org/doi/abs/10.1145/586656.586663">https://dl.acm.org/doi/abs/10.1145/586656.586663</a>
</li>

<li>APL – A Glimpse of Heaven (2006)<br />
<a href="https://news.ycombinator.com/item?id=19325361">https://news.ycombinator.com/item?id=19325361</a>
</li>

<li>APL and J<br />
<a href="https://crypto.stanford.edu/~blynn/c/apl.html">https://crypto.stanford.edu/~blynn/c/apl.html</a>
</li>

<li>ivy (dokumentace)<br />
<a href="https://pkg.go.dev/robpike.io/ivy#section-readme">https://pkg.go.dev/robpike.io/ivy#section-readme</a>
</li>

<li>ivy na GitHubu<br />
<a href="https://github.com/robpike/ivy/">https://github.com/robpike/ivy/</a>
</li>

<li>Ivy na APL wiki<br />
<a href="https://aplwiki.com/wiki/Ivy">https://aplwiki.com/wiki/Ivy</a>
</li>

<li>Implementing a bignum calculator (slajdy)<br />
<a href="https://talks.godoc.org/github.com/robpike/ivy/talks/ivy.slide#1">https://talks.godoc.org/github.com/robpike/ivy/talks/ivy.slide#1</a>
</li>

<li>Implementing a bignum calculator - Rob Pike - golang-syd November 2014<br />
<a href="https://www.youtube.com/watch?v=PXoG0WX0r_E">https://www.youtube.com/watch?v=PXoG0WX0r_E</a>
</li>

<li>Rob Pike na Wikipedii<br />
<a href="https://en.wikipedia.org/wiki/Rob_Pike">https://en.wikipedia.org/wiki/Rob_Pike</a>
</li>

<li>Rob Pike na cat-v<br />
<a href="http://genius.cat-v.org/rob-pike/">http://genius.cat-v.org/rob-pike/</a>
</li>

<li>NuVoc<br />
<a href="https://code.jsoftware.com/wiki/NuVoc">https://code.jsoftware.com/wiki/NuVoc</a>
</li>

<li>J (programming language) [Wikipedia]<br />
<a href="https://en.wikipedia.org/wiki/J_%28programming_language%29">https://en.wikipedia.org/wiki/J_%28programming_language%29</a>
</li>

<li>J &ndash; Absolutely Essential Terms<br />
<a href="https://code.jsoftware.com/wiki/Vocabulary/AET">https://code.jsoftware.com/wiki/Vocabulary/AET</a>
</li>

<li>J &ndash; Atoms and Arrays<br />
<a href="https://code.jsoftware.com/wiki/Vocabulary/Nouns#Atom">https://code.jsoftware.com/wiki/Vocabulary/Nouns#Atom</a>
</li>

<li>Why J<br />
<a href="https://www.jsoftware.com/help/primer/why_j.htm">https://www.jsoftware.com/help/primer/why_j.htm</a>
</li>

<li>What is an Array?<br />
<a href="https://vector.org.uk/what-is-an-array/">https://vector.org.uk/what-is-an-array/</a>
</li>

<li>Comments<br />
<a href="http://www.gavilan.edu/csis/languages/comments.html">http://www.gavilan.edu/csis/languages/comments.html</a>
</li>

<li>Vector (Wolfram MathWorld)<br />
<a href="https://mathworld.wolfram.com/Vector.html">https://mathworld.wolfram.com/Vector.html</a>
</li>

<li>n-Tuple (Wolfram MathWorld)<br />
<a href="https://mathworld.wolfram.com/n-Tuple.html">https://mathworld.wolfram.com/n-Tuple.html</a>
</li>

<li>n-Vector (Wolfram MathWorld)<br />
<a href="https://mathworld.wolfram.com/n-Vector.html">https://mathworld.wolfram.com/n-Vector.html</a>
</li>

<li>Matrix (Wolfram MathWorld)<br />
<a href="https://mathworld.wolfram.com/Matrix.html">https://mathworld.wolfram.com/Matrix.html</a>
</li>

<li>Array (Wolfram MathWorld)<br />
<a href="https://mathworld.wolfram.com/Array.html">https://mathworld.wolfram.com/Array.html</a>
</li>

<li>ND Arrays (Tensors) in different languages<br />
<a href="https://www.youtube.com/watch?v=WbpbEilgQBc">https://www.youtube.com/watch?v=WbpbEilgQBc</a>
</li>

<li>Extending APL to Infinity\<br />
<a href="https://www.jsoftware.com/papers/eem/infinity.htm">https://www.jsoftware.com/papers/eem/infinity.htm</a>
</li>

<li>Vector Library (R7RS-compatible)<br />
<a href="https://srfi.schemers.org/srfi-133/srfi-133.html">https://srfi.schemers.org/srfi-133/srfi-133.html</a>
</li>

<li>Vectors (pro Gauche)<br />
<a href="https://practical-scheme.net/gauche/man/gauche-refe/Vectors.html">https://practical-scheme.net/gauche/man/gauche-refe/Vectors.html</a>
</li>

<li>Kawa: Compiling Scheme to Java<br />
<a href="https://www.mit.edu/afs.new/sipb/project/kawa/doc/kawa-tour.html">https://www.mit.edu/afs.new/sipb/project/kawa/doc/kawa-tour.html</a>
</li>

<li>Kawa in Languages shootout<br />
<a href="http://per.bothner.com/blog/2010/Kawa-in-shootout/">http://per.bothner.com/blog/2010/Kawa-in-shootout/</a>
</li>

<li>Kawa 2.0 Supports Scheme R7RS<br />
<a href="https://developers.slashdot.org/story/14/12/13/2259225/kawa-20-supports-scheme-r7rs/">https://developers.slashdot.org/story/14/12/13/2259225/kawa-20-supports-scheme-r7rs/</a>
</li>

<li>Kawa — fast scripting on the Java platform<br />
<a href="https://lwn.net/Articles/623349/">https://lwn.net/Articles/623349/</a>
</li>

<li>Incanter is a Clojure-based, R-like platform for statistical computing and graphics.<br />
<a href="http://incanter.org/">http://incanter.org/</a>
</li>

<li>Evolution of incanter (Gource Visualization)<br />
<a href="https://www.youtube.com/watch?v=TVfL5nPELr4">https://www.youtube.com/watch?v=TVfL5nPELr4</a>
</li>

<li>Questions tagged [incanter] (na Stack Overflow)<br />
<a href="https://stackoverflow.com/questions/tagged/incanter?sort=active">https://stackoverflow.com/questions/tagged/incanter?sort=active</a>
</li>

<li>Data Sorcery with Clojure<br />
<a href="https://data-sorcery.org/contents/">https://data-sorcery.org/contents/</a>
</li>

<li>Back to the Future: Lisp as a Base for a Statistical Computing System<br />
<a href="https://rd.springer.com/chapter/10.1007/978-3-7908-2084-3_2">https://rd.springer.com/chapter/10.1007/978-3-7908-2084-3_2</a>
</li>

<li>Incanter Cheat Sheet<br />
<a href="http://incanter.org/docs/incanter-cheat-sheet.pdf">http://incanter.org/docs/incanter-cheat-sheet.pdf</a>
</li>

<li>Back to the Future: Lisp as a Base for a Statistical Computing System (celá verze článku)<br />
<a href="https://www.researchgate.net/publication/227019917_Back_to_the_Future_Lisp_as_a_Base_for_a_Statistical_Computing_System">https://www.researchgate.net/publication/227019917_Back_to_the_Future_Lisp_as_a_Base_for_a_Statistical_Computing_System</a>
</li>

<li>BQN: finally, an APL for your flying saucer<br />
<a href="https://mlochbaum.github.io/BQN/">https://mlochbaum.github.io/BQN/</a>
</li>

<li>Is BQN stable?<br />
<a href="https://mlochbaum.github.io/BQN/commentary/stability.html">https://mlochbaum.github.io/BQN/commentary/stability.html</a>
</li>

<li>Specification: BQN system-provided values<br />
<a href="https://mlochbaum.github.io/BQN/spec/system.html">https://mlochbaum.github.io/BQN/spec/system.html</a>
</li>

<li>Tutorial: BQN expressions<br />
<a href="https://mlochbaum.github.io/BQN/tutorial/expression.html">https://mlochbaum.github.io/BQN/tutorial/expression.html</a>
</li>

<li>BQN primitives<br />
<a href="https://mlochbaum.github.io/BQN/doc/primitive.html">https://mlochbaum.github.io/BQN/doc/primitive.html</a>
</li>

<li>Function trains<br />
<a href="https://mlochbaum.github.io/BQN/doc/train.html">https://mlochbaum.github.io/BQN/doc/train.html</a>
</li>

<li>BQN community links<br />
<a href="https://mlochbaum.github.io/BQN/community/index.html">https://mlochbaum.github.io/BQN/community/index.html</a>
</li>

<li>BQN UV<br />
<a href="https://observablehq.com/@lsh/bqn-uv">https://observablehq.com/@lsh/bqn-uv</a>
</li>

<li>APL Wiki<br />
<a href="https://aplwiki.com/wiki/">https://aplwiki.com/wiki/</a>
</li>

<li>The Array Cast<br />
<a href="https://www.arraycast.com/episodes/episode-03-what-is-an-array">https://www.arraycast.com/episodes/episode-03-what-is-an-array</a>
</li>

<li>EnthusiastiCon 2019 &ndash; An Introduction to APL<br />
<a href="https://www.youtube.com/watch?v=UltnvW83_CQ">https://www.youtube.com/watch?v=UltnvW83_CQ</a>
</li>

<li>Dyalog<br />
<a href="https://www.dyalog.com/">https://www.dyalog.com/</a>
</li>

<li>Try APL!<br />
<a href="https://tryapl.org/">https://tryapl.org/</a>
</li>

<li>Lisp-Stat Information<br />
<a href="http://homepage.cs.uiowa.edu/~luke/xls/xlsinfo/">http://homepage.cs.uiowa.edu/~luke/xls/xlsinfo/</a>
</li>

<li>Sample Plots in Incanter<br />
<a href="https://github.com/incanter/incanter/wiki/Sample-Plots-in-Incanter#line">https://github.com/incanter/incanter/wiki/Sample-Plots-in-Incanter#line</a>
</li>

<li>vectorz-clj<br />
<a href="https://github.com/mikera/vectorz-clj">https://github.com/mikera/vectorz-clj</a>
</li>

<li>vectorz &ndash; Examples<br />
<a href="https://github.com/mikera/vectorz-clj/wiki/Examples">https://github.com/mikera/vectorz-clj/wiki/Examples</a>
</li>

<li>Basic Vector and Matrix Operations in Julia: Quick Reference and Examples<br />
<a href="https://queirozf.com/entries/basic-vector-and-matrix-operations-in-julia-quick-reference-and-examples">https://queirozf.com/entries/basic-vector-and-matrix-operations-in-julia-quick-reference-and-examples</a>
</li>

<li>Vectors and matrices in Julia<br />
<a href="https://fncbook.github.io/v1.0/linsys/demos/matrices-julia.html">https://fncbook.github.io/v1.0/linsys/demos/matrices-julia.html</a>
</li>

<li>Array vs Matrix in R Programming<br />
<a href="https://www.geeksforgeeks.org/array-vs-matrix-in-r-programming/">https://www.geeksforgeeks.org/array-vs-matrix-in-r-programming/</a>
</li>

<li>Concurrency (computer science)<br />
<a href="https://en.wikipedia.org/wiki/Category:Concurrency_%28computer_science%29">https://en.wikipedia.org/wiki/Category:Concurrency_%28computer_science%29</a>
</li>

<li>Koprogram<br />
<a href="https://cs.wikipedia.org/wiki/Koprogram">https://cs.wikipedia.org/wiki/Koprogram</a>
</li>

<li>Coroutine<br />
<a href="https://en.wikipedia.org/wiki/Coroutine">https://en.wikipedia.org/wiki/Coroutine</a>
</li>

<li>Coroutines in C<br />
<a href="http://www.chiark.greenend.org.uk/~sgtatham/coroutines.html">http://www.chiark.greenend.org.uk/~sgtatham/coroutines.html</a>
</li>

<li>S-expression (Wikipedia)<br />
<a href="https://en.wikipedia.org/wiki/S-expression">https://en.wikipedia.org/wiki/S-expression</a>
</li>

<li>S-Expressions (Rosetta Code)<br />
<a href="http://rosettacode.org/wiki/S-Expressions">http://rosettacode.org/wiki/S-Expressions</a>
</li>

<li>Introducing Julia/Metaprogramming<br />
<a href="https://en.wikibooks.org/wiki/Introducing_Julia/Metaprogramming">https://en.wikibooks.org/wiki/Introducing_Julia/Metaprogramming</a>
</li>

<li>Tutorial for the Common Lisp Loop Macro<br />
<a href="http://www.ai.sri.com/pkarp/loop.html">http://www.ai.sri.com/pkarp/loop.html</a>
</li>

<li>Clojure Macro Tutorial (Part I, Getting the Compiler to Write Your Code For You)<br />
<a href="http://www.learningclojure.com/2010/09/clojure-macro-tutorial-part-i-getting.html">http://www.learningclojure.com/2010/09/clojure-macro-tutorial-part-i-getting.html</a>
</li>

<li>Clojure Macro Tutorial (Part II: The Compiler Strikes Back)<br />
<a href="http://www.learningclojure.com/2010/09/clojure-macro-tutorial-part-ii-compiler.html">http://www.learningclojure.com/2010/09/clojure-macro-tutorial-part-ii-compiler.html</a>
</li>

<li>Clojure Macro Tutorial (Part III: Syntax Quote)<br />
<a href="http://www.learningclojure.com/2010/09/clojure-macro-tutorial-part-ii-syntax.html">http://www.learningclojure.com/2010/09/clojure-macro-tutorial-part-ii-syntax.html</a>
</li>

<li>Clojure Macros and Metaprogramming<br />
<a href="http://clojure-doc.org/articles/language/macros.html">http://clojure-doc.org/articles/language/macros.html</a>
</li>

<li>Fatvat &ndash; Exploring functional programming: Clojure Macros<br />
<a href="http://www.fatvat.co.uk/2009/02/clojure-macros.html">http://www.fatvat.co.uk/2009/02/clojure-macros.html</a>
</li>

<li>CS 2101 Parallel Computing with Julia<br />
<a href="https://www.coursehero.com/file/11508091/CS-2101-Parallel-Computing-with-Julia/">https://www.coursehero.com/file/11508091/CS-2101-Parallel-Computing-with-Julia/</a>
</li>

<li>Julia By Example<br />
<a href="https://samuelcolvin.github.io/JuliaByExample/">https://samuelcolvin.github.io/JuliaByExample/</a>
</li>

<li>Array Programming<br />
<a href="https://en.wikipedia.org/wiki/Array_programming">https://en.wikipedia.org/wiki/Array_programming</a>
</li>

<li>Discovering Array Languages<br />
<a href="http://archive.vector.org.uk/art10008110">http://archive.vector.org.uk/art10008110</a>
</li>

<li>no stinking loops -- Kalothi<br />
<a href="http://www.nsl.com/">http://www.nsl.com/</a>
</li>

<li>Vector (obsahuje odkazy na články, knihy a blogy o programovacích jazycích APL, J a K)<br />
<a href="http://www.vector.org.uk/">http://www.vector.org.uk/</a>
</li>

<li>APL Interpreters<br />
<a href="http://www.vector.org.uk/?area=interpreters">http://www.vector.org.uk/?area=interpreters</a>
</li>

<li>APL_(programming_language<br />
<a href="http://en.wikipedia.org/wiki/APL_(programming_language">http://en.wikipedia.org/wiki/APL_(programming_language</a>
</li>

<li>APL FAQ<br />
<a href="http://www.faqs.org/faqs/apl-faq/">http://www.faqs.org/faqs/apl-faq/</a>
</li>

<li>APL FAQ (nejnovější verze)<br />
<a href="http://home.earthlink.net/~swsirlin/apl.faq.html">http://home.earthlink.net/~swsirlin/apl.faq.html</a>
</li>

<li>A+<br />
<a href="http://www.aplusdev.org/">http://www.aplusdev.org/</a>
</li>

<li>APLX<br />
<a href="http://www.microapl.co.uk/">http://www.microapl.co.uk/</a>
</li>

<li>FreeAPL<br />
<a href="http://www.pyr.fi/apl/index.htm">http://www.pyr.fi/apl/index.htm</a>
</li>

<li>Learning J (Roger Stokes)<br />
<a href="http://www.jsoftware.com/help/learning/contents.htm">http://www.jsoftware.com/help/learning/contents.htm</a>
</li>

<li>J: a modern, high-level, general-purpose, high-performance programming language<br />
<a href="http://www.jsoftware.com/">http://www.jsoftware.com/</a>
</li>

<li>K, Kdb: an APL derivative for Solaris, Linux, Windows<br />
<a href="http://www.kx.com">http://www.kx.com</a>
</li>

<li>openAPL (GPL)<br />
<a href="http://sourceforge.net/projects/openapl">http://sourceforge.net/projects/openapl</a>
</li>

<li>Parrot APL (GPL)<br />
<a href="http://www.parrotcode.org/">http://www.parrotcode.org/</a>
</li>

<li>Learning J (Roger Stokes)<br />
<a href="http://www.jsoftware.com/help/learning/contents.htm">http://www.jsoftware.com/help/learning/contents.htm</a>
</li>

<li>Rosetta Code<br />
<a href="http://rosettacode.org/wiki/Main_Page">http://rosettacode.org/wiki/Main_Page</a>
</li>

<li>Why APL<br />
<a href="http://www.acm.org/sigapl/whyapl.htm">http://www.acm.org/sigapl/whyapl.htm</a>
</li>

<li>Introducing Julia/Functions<br />
<a href="https://en.wikibooks.org/wiki/Introducing_Julia/Functions">https://en.wikibooks.org/wiki/Introducing_Julia/Functions</a>
</li>

<li>Functions (Julia documentation)<br />
<a href="https://docs.julialang.org/en/v1/manual/functions/">https://docs.julialang.org/en/v1/manual/functions/</a>
</li>

<li>Evaluate binomial coefficients<br />
<a href="http://rosettacode.org/wiki/Evaluate_binomial_coefficients">http://rosettacode.org/wiki/Evaluate_binomial_coefficients</a>
</li>

<li>Ackermann function<br />
<a href="http://rosettacode.org/wiki/Ackermann_function">http://rosettacode.org/wiki/Ackermann_function</a>
</li>

<li>Julia (front page)<br />
<a href="http://julialang.org/">http://julialang.org/</a>
</li>

<li>Julia &ndash; dokumentace<br />
<a href="http://docs.julialang.org/">http://docs.julialang.org/</a>
</li>

<li>Julia &ndash; repositář na GitHubu<br />
<a href="https://github.com/JuliaLang/julia">https://github.com/JuliaLang/julia</a>
</li>

<li>Julia (programming language)<br />
<a href="https://en.wikipedia.org/wiki/Julia_%28programming_language%29">https://en.wikipedia.org/wiki/Julia_%28programming_language%29</a>
</li>

<li>IJulia<br />
<a href="https://github.com/JuliaLang/IJulia.jl">https://github.com/JuliaLang/IJulia.jl</a>
</li>

<li>Introducing Julia<br />
<a href="https://en.wikibooks.org/wiki/Introducing_Julia">https://en.wikibooks.org/wiki/Introducing_Julia</a>
</li>

<li>Julia: the REPL<br />
<a href="https://en.wikibooks.org/wiki/Introducing_Julia/The_REPL">https://en.wikibooks.org/wiki/Introducing_Julia/The_REPL</a>
</li>

<li>Month of Julia<br />
<a href="https://github.com/DataWookie/MonthOfJulia">https://github.com/DataWookie/MonthOfJulia</a>
</li>

<li>Learn X in Y minutes (where X=Julia)<br />
<a href="https://learnxinyminutes.com/docs/julia/">https://learnxinyminutes.com/docs/julia/</a>
</li>

<li>New Julia language seeks to be the C for scientists<br />
<a href="http://www.infoworld.com/article/2616709/application-development/new-julia-language-seeks-to-be-the-c-for-scientists.html">http://www.infoworld.com/article/2616709/application-development/new-julia-language-seeks-to-be-the-c-for-scientists.html</a>
</li>

<li>Julia: A Fast Dynamic Language for Technical Computing<br />
<a href="http://karpinski.org/publications/2012/julia-a-fast-dynamic-language">http://karpinski.org/publications/2012/julia-a-fast-dynamic-language</a>
</li>

<li>The LLVM Compiler Infrastructure<br />
<a href="http://llvm.org/">http://llvm.org/</a>
</li>

<li>Julia: benchmarks<br />
<a href="http://julialang.org/benchmarks/">http://julialang.org/benchmarks/</a>
</li>

<li>Type system<br />
<a href="https://en.wikipedia.org/wiki/Type_system">https://en.wikipedia.org/wiki/Type_system</a>
</li>

<li>Half-precision floating-point format<br />
<a href="https://en.wikipedia.org/wiki/Half-precision_floating-point_format">https://en.wikipedia.org/wiki/Half-precision_floating-point_format</a>
</li>

<li>Dartmouth BASIC<br />
<a href="https://en.wikipedia.org/wiki/Dartmouth_BASIC">https://en.wikipedia.org/wiki/Dartmouth_BASIC</a>
</li>

<li>BASIC 4th Edition<br />
<a href="http://www.bitsavers.org/pdf/dartmouth/BASIC_4th_Edition_Jan68.pdf">http://www.bitsavers.org/pdf/dartmouth/BASIC_4th_Edition_Jan68.pdf</a>
</li>

<li>VECTRAN<br />
<a href="https://encyclopedia2.thefreedictionary.com/VECTRAN">https://encyclopedia2.thefreedictionary.com/VECTRAN</a>
</li>

<li>Comparison of programming languages (array)<br />
<a href="https://en.wikipedia.org/wiki/Comparison_of_programming_languages_(array)">https://en.wikipedia.org/wiki/Comparison_of_programming_languages_(array)</a>
</li>

<li>BASIC at 50<br />
<a href="https://www.dartmouth.edu/basicfifty/commands.html">https://www.dartmouth.edu/basicfifty/commands.html</a>
</li>

<li>BBC Basic - arrays<br />
<a href="http://www.riscos.com/support/developers/bbcbasic/part2/arrays.html">http://www.riscos.com/support/developers/bbcbasic/part2/arrays.html</a>
</li>

<li>Datová struktura<br />
<a href="https://cs.wikipedia.org/wiki/Datov%C3%A1_struktura">https://cs.wikipedia.org/wiki/Datov%C3%A1_struktura</a>
</li>

<li>SIMD instrukce využívané v&nbsp;moderních mikroprocesorech řady x86<br />
<a href="https://www.root.cz/clanky/simd-instrukce-vyuzivane-v-modernich-mikroprocesorech-rady-x86/">https://www.root.cz/clanky/simd-instrukce-vyuzivane-v-modernich-mikroprocesorech-rady-x86/</a>
</li>

<li>SIMD instrukce v&nbsp;moderních mikroprocesorech řady x86 (2.část: SSE)<br />
<a href="https://www.root.cz/clanky/simd-instrukce-v-modernich-mikroprocesorech-rady-x86-2-cast-sse/">https://www.root.cz/clanky/simd-instrukce-v-modernich-mikroprocesorech-rady-x86-2-cast-sse/</a>
</li>

<li>SIMD instrukce v&nbsp;moderních mikroprocesorech řady x86 (3.část: SSE2)<br />
<a href="https://www.root.cz/clanky/simd-instrukce-v-modernich-mikroprocesorech-rady-x86-3-cast-sse2/">https://www.root.cz/clanky/simd-instrukce-v-modernich-mikroprocesorech-rady-x86-3-cast-sse2/</a>
</li>

<li>Inductive type<br />
<a href="https://en.wikipedia.org/wiki/Inductive_type">https://en.wikipedia.org/wiki/Inductive_type</a>
</li>

<li>JuliaMono, a font for programming<br />
<a href="https://github.com/cormullion/juliamono">https://github.com/cormullion/juliamono</a>
</li>

<li>It’s arrays all the way down<br />
<a href="https://xpqz.github.io/learnapl/array.html">https://xpqz.github.io/learnapl/array.html</a>
</li>

<li>APL vs BQN vs J vs Q vs NumPy vs Julia vs R<br />
<a href="https://www.youtube.com/watch?v=8ynsN4nJxzU">https://www.youtube.com/watch?v=8ynsN4nJxzU</a>
</li>

<li>Trainspotting (APL)<br />
<a href="https://xpqz.github.io/learnapl/tacit.html">https://xpqz.github.io/learnapl/tacit.html</a>
</li>

<li>Train Spotting in Dyalog APL – Dyalog Webinar with Richard Park<br />
<a href="https://www.youtube.com/watch?v=Enlh5qwwDuY">https://www.youtube.com/watch?v=Enlh5qwwDuY</a>
</li>

</ol>



<p></p><p></p>
<p><small>Autor: <a href="http://www.fit.vutbr.cz/~tisnovpa">Pavel Tišnovský</a> &nbsp; 2022</small></p>
</body>
</html>

