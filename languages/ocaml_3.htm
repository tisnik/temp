<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
        "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html>
<head>
<title>Programovací jazyk OCaml: rekurze, pattern matching a práce se seznamy</title>
<meta name="Author" content="Pavel Tisnovsky" />
<meta name="Generator" content="vim" />
<meta http-equiv="content-type" content="text/html; charset=utf-8" />
<style type="text/css">
         body {color:#000000; background:#ffffff;}
         h1  {font-family: arial, helvetica, sans-serif; color:#ffffff; background-color:#c00000; text-align:center; padding-left:1em}
         h2  {font-family: arial, helvetica, sans-serif; color:#ffffff; background-color:#0000c0; padding-left:1em; text-align:left}
         h3  {font-family: arial, helvetica, sans-serif; color:#000000; background-color:#c0c0c0; padding-left:1em; text-align:left}
         h4  {font-family: arial, helvetica, sans-serif; color:#000000; background-color:#e0e0e0; padding-left:1em; text-align:left}
         a   {font-family: arial, helvetica, sans-serif;}
         li  {font-family: arial, helvetica, sans-serif; color:#000000; text-align:justify; width:450px;}
         ol  {font-family: arial, helvetica, sans-serif; color:#000000; text-align:justify; width:450px;}
         ul  {font-family: arial, helvetica, sans-serif; color:#000000; text-align:justify; width:450px;}
         p   {font-family: arial, helvetica, sans-serif; color:#000000; text-align:justify;}
         pre {background:#e0e0e0}
</style>
</head>

<body>

<h1>Programovací jazyk OCaml: rekurze, pattern matching a práce se seznamy</h1>

<h3>Pavel Tišnovský</h3>

<p></p>

<h1>Úvodník</h1>

<p>Články o programovacím jazyku OCaml vždy do jisté míry kopírují obsah článků o jazyku F#. Dnes si ukážeme koncepty popsané ve třetím a současně i ve čtvrtém článku o F#. Budeme se tedy zabývat rekurzí, pattern matchingem a taktéž způsobem práce se seznamy (list).</p>



<h2>Obsah</h2>

<p><a href="#k01">1. Rekurzivní funkce &ndash; přímá rekurze</a></p>
<p><a href="#k02">2. Koncová rekurze</a></p>
<p><a href="#k03">3. Nepřímá rekurze</a></p>
<p><a href="#k04">4. Pattern matching</a></p>
<p><a href="#k05">5. Rekurzivní výpočet faktoriálu s&nbsp;pattern matchingem</a></p>
<p><a href="#k06">6. Pattern matching pro větší množství hodnot</a></p>
<p><a href="#k07">7. Získání zvoleného prvku z&nbsp;n-tice s&nbsp;využitím pattern matchingu</a></p>
<p><a href="#k08">8. Další více či méně užitečné ukázky pattern matchingu</a></p>
<p><a href="#k09">9. Práce se seznamy v&nbsp;OCamlu</a></p>
<p><a href="#k10">10. Konstruktor seznamů</a></p>
<p><a href="#k11">11. Prázdný seznam</a></p>
<p><a href="#k12">12. Rekurzivní definice seznamu a operátor <strong>::</strong></a></p>
<p><a href="#k13">13. Spojení seznamů operátorem <strong>@</strong></a></p>
<p><a href="#k14">14. Funkce pro zjištění vlastností seznamů</a></p>
<p><a href="#k15">15. Seznamy a pattern matching &ndash; výpočet délky seznamu</a></p>
<p><a href="#k16">16. Rekurzivní zápis funkce <strong>append</strong> pro spojení dvou seznamů</a></p>
<p><a href="#k17">17. Součet hodnot všech prvků uložených v&nbsp;seznamu</a></p>
<p><a href="#k18">18. Příloha: tisk seznamu v&nbsp;jazyku OCaml</a></p>
<p><a href="#k19">19. Repositář s&nbsp;demonstračními příklady</a></p>
<p><a href="#k20">20. Odkazy na Internetu</a></p>



<p><a name="k01"></a></p>
<h2 id="k01">1. Rekurzivní funkce &ndash; přímá rekurze</h2>

<p>Podobně jako v&nbsp;jazyku F# a prakticky všech ostatních funkcionálních
programovacích jazycích se i v&nbsp;OCamlu velmi často setkáme
s&nbsp;rekurzivními funkcemi, typicky založenými na principu postupného
zjednodušování problému. Rekurze může být <i>přímá</i>, což znamená, že
v&nbsp;nějaké funkci voláme tu samou funkci (ovšem typicky s&nbsp;rozdílnými
parametry) nebo <i>nepřímá</i>, kdy například funkce A volá funkci B a ta ve
svém těle volá opět funkci A.</p>

<p>Zápis funkce s&nbsp;přímou rekurzí, tedy funkce, která za určitých podmínek
volá samu sebe, by teoreticky měl vypadat takto:</p>

<pre>
let <strong>fib</strong> n =
  if n &lt; 2 then
    n
  else
    <strong>fib</strong> (n - 1) + <strong>fib</strong> (n - 2)
;;
&nbsp;
Printf.printf "%d" (fib 10);;
</pre>

<p>Ovšem my již víme, že překlad této funkce není možný, protože uvnitř těla
funkce není symbol <strong>fib</strong> ještě definovaný. Proč tomu tak je?
V&nbsp;průběhu deklarace funkce ještě skutečně není symbol <strong>fib</strong>
definován, protože výraz s&nbsp;<strong>let</strong> není ukončen (dvojicí
středníků). Řešení spočívá v&nbsp;&bdquo;nápovědě&ldquo; překladači přidáním
klíčového slova <strong>rec</strong> před jméno funkce, což vlastně vede
k&nbsp;tomu, že se symbol <strong>fib</strong> (před)definuje:</p>

<pre>
let <u>rec</u> <strong>fib</strong> n =
  if n &lt; 2 then
    n
  else
    <strong>fib</strong> (n - 1) + <strong>fib</strong> (n - 2)
;;
&nbsp;
Printf.printf "%d" (fib 10);;
</pre>

<p><div class="rs-tip-major">Poznámka: uvnitř těla funkce se vlastně používá
odlišný lokální symbol <strong>fib</strong>.</div></p>

<p>Klíčové slovo <strong>rec</strong> můžeme, i když je to zbytečné, použít i u
funkcí, které nejsou rekurzivní:</p>

<pre>
let <u>rec</u> <strong>add</strong> x y = x + y;;
&nbsp;
Printf.printf "%d" (add 1 2);;
</pre>



<p><a name="k02"></a></p>
<h2 id="k02">2. Koncová rekurze</h2>

<p>Pokud chceme v&nbsp;OCamlu využít <i>koncové rekurze</i>, musíme se sami
postarat o to, aby byla rekurze napsána tak, že se funkce budou volat
v&nbsp;koncové pozici. Takový zápis rekurze dokáže překladač nahradit za
programovou smyčku, která se pochopitelně vyhodnocuje rychleji, než skutečná
rekurze (odpadá předávání parametrů přes zásobník a vlastní volání funkce).
Ovšem přepis rekurze tak, aby bylo možné použít koncovou rekurzi, je již úloha
pro programátora, nikoli pro překladač (alespoň v&nbsp;současnosti). Typicky se
přepis provádí tak, že si vytvoříme pomocnou lokální funkci, které se namísto
jednoho parametru předávají další parametry, typicky včetně akumulátoru, do
něhož se postupně zapisují mezivýsledky výpočtu.</p>

<p>Výpočet Fibonacciho posloupnosti se tedy upraví tak, že v&nbsp;interní
pomocné funkci bude první parametr počitadlem a druhé dva parametry představují
členy <i>n</i> a <i>n+1</i>. Vlastně explicitně říkáme, jaké proměnné (či
parametry) jsou nutné v&nbsp;každém kroku iterace. Výsledná interní funkce
<strong>tailr</strong> je zapsána tak, že se rekurzivní volání nachází
v&nbsp;tail pozici a tudíž překladač bude moci použít smyčku:</p>

<pre>
let <strong>fib</strong> n =
  let <u>rec</u> <strong>tailr</strong> i a b =
    if i = 0 then a else <strong>tailr</strong> (i-1) b (a + b)
  in
  <strong>tailr</strong> n 0 1;;
&nbsp;
Printf.printf "%d" (fib 10);;
</pre>

<p><div class="rs-tip-major">Poznámka: povšimněte si, že deklarace interní
funkce se použije ve funkci <strong>fib</strong> až za klíčovým slovem
<strong>in</strong> (to již známe &ndash; právě takto se deklaruje blok,
v&nbsp;němž je lokální symbol <strong>tailr</strong> viditelný).</div></p>



<p><a name="k03"></a></p>
<h2 id="k03">3. Nepřímá rekurze</h2>

<p>I s&nbsp;nepřímou rekurzí, kdy jedna funkce <strong>A</strong> volá jinou
funkci <strong>B</strong> a ta opět volá funkci <strong>A</strong>, jsme se již
v&nbsp;článku o programovacím jazyku F# setkali. Implementačně se jedná o
snadnou záležitost, ovšem problém spočívá v&nbsp;syntaxi a hlavně sémantice
&ndash; jak zapsat vzájemnou rekurzi a neztratit přitom všechny výhody typové
inference.</p>

<p>Můžeme si zopakovat zápis algoritmu pro zjištění, zda je celočíselná hodnota
sudá nebo lichá. První pokus sice skutečně znamená nepřímou rekurzi, ovšem
nejedná se o korektní zápis, neboť jedna funkce nevidí symbol funkce druhé:</p>

<pre>
let <strong>even</strong> x =
  if x = 0
  then true
  else <strong>odd</strong> (x-1);;
&nbsp;
let <strong>odd</strong> x =
  if x = 0
  then false
  else <strong>even</strong> (x-1);;
&nbsp;
&nbsp;
Printf.printf "%b" (even 1);;
Printf.printf "%b" (even 2);;
Printf.printf "%b" (even 3);;
Printf.printf "%b" (even 4);;
</pre>

<p>Ani použití klíčových slov <strong>rec</strong> nepomůže, a to kvůli tomu,
co toto slovo znamená (to již víme &ndash; předdeklarace lokálního symbolu).
Ovšem my nedokážeme zapsat, že ve funkci <strong>even</strong> má být lokální
symbol <strong>odd</strong> a naopak. Proto ani tento zápis není korektní:</p>

<pre>
let <u>rec</u> <strong>even</strong> x =
  if x = 0
  then true
  else <strong>odd</strong> (x-1);;
&nbsp;
let <u>rec</u> <strong>odd</strong> x =
  if x = 0
  then false
  else <strong>even</strong> (x-1);;
&nbsp;
&nbsp;
Printf.printf "%b" (even 1);;
Printf.printf "%b" (even 2);;
Printf.printf "%b" (even 3);;
Printf.printf "%b" (even 4);;
</pre>

<p>Jediný korektní způsob zápisu nepřímé rekurze vyžaduje společnou deklaraci
obou funkcí, které se vzájemně volají. Obě deklarace se spojují &ndash; což
může být zpočátku poněkud matoucí &ndash; s&nbsp;využitím klíčového slova
<strong>and</strong>. A pochopitelně je nutné použít klíčové slovo
<strong>rec</strong>, které zajistí, že se interně (při deklaraci obou funkcí)
mohou používat symboly <strong>even</strong> a <strong>odd</strong>. Výsledek
by měl vypadat následovně:</p>

<pre>
let <u>rec</u> <strong>even</strong> x =
  if x = 0
  then true
  else <strong>odd</strong> (x-1)
and <strong>odd</strong> x =
  if x = 0
  then false
  else <strong>even</strong> (x-1);;
&nbsp;
&nbsp;
Printf.printf "%b" (even 1);;
Printf.printf "%b" (even 2);;
Printf.printf "%b" (even 3);;
Printf.printf "%b" (even 4);;
</pre>

<p>A taktéž již víme, že zápis bez <strong>rec</strong> nebude korektní,
protože se nevytvoří lokální symboly <strong>odd</strong> a
<strong>even</strong>, které by bylo možné použít pro volání (ještě
neexistujících) funkcí:</p>

<pre>
let <strong>even</strong> x =
  if x = 0
  then true
  else <strong>odd</strong> (x-1)
and <strong>odd</strong> x =
  if x = 0
  then false
  else <strong>even</strong> (x-1);;
&nbsp;
&nbsp;
Printf.printf "%b" (even 1);;
Printf.printf "%b" (even 2);;
Printf.printf "%b" (even 3);;
Printf.printf "%b" (even 4);;
</pre>



<p><a name="k04"></a></p>
<h2 id="k04">4. Pattern matching</h2>

<p>V&nbsp;jazyce OCaml pochopitelně nalezneme i podporu pro <i>pattern
matching</i>, neboť se jedná o technologii, která byla nedílnou součástí
programovacího jazyka ML &ndash; předchůdce jak OCamlu, tak i jazyka F#.
Podobně jako v&nbsp;případě F# se i nyní nejprve podívejme na příklad, který
<i>není</i> řešen s&nbsp;využitím pattern matchingu:</p>

<pre>
<i>(* Naivní implementace výpočtu Fibonacciho posloupnosti *)</i>
&nbsp;
<strong>let rec fib n =</strong>
    <strong>if n = 0 then 0 else</strong>
    <strong>if n = 1 then 1 else</strong>
    <strong>fib (n - 1) + fib (n - 2);</strong>
</pre>

<p>Pokud pattern matching použijeme, bude výsledkem mnohem přehlednější
kód:</p>

<pre>
let rec <strong>fib</strong> = function 
    0 -&gt; 0
  | 1 -&gt; 1
  | n -&gt; <strong>fib</strong> (n-1) + <strong>fib</strong> (n-2);;
&nbsp;
&nbsp;
Printf.printf "%d" (fib 0);;
Printf.printf "%d" (fib 1);;
Printf.printf "%d" (fib 20);;
</pre>

<p>Zápis s&nbsp;<strong>function</strong> lze ovšem přepsat do idiomatičtější
(častěji používané) podoby založené na klíčových slovech <strong>match</strong>
a <strong>with</strong>:</p>

<pre>
let rec <strong>fib</strong> n = 
  match n with
    0 -&gt; 0
  | 1 -&gt; 1
  | n -&gt; <strong>fib</strong> (n-1) + <strong>fib</strong> (n-2);;
&nbsp;
&nbsp;
Printf.printf "%d" (fib 0);;
Printf.printf "%d" (fib 1);;
Printf.printf "%d" (fib 20);;
</pre>



<p><a name="k05"></a></p>
<h2 id="k05">5. Rekurzivní výpočet faktoriálu s&nbsp;pattern matchingem</h2>

<p>Pro úplnost si ukažme příklad pro rekurzivní výpočet faktoriálu
s&nbsp;pattern matchingem. V&nbsp;OCamlu bude vypadat prakticky totožně, jako
v&nbsp;jazyku F# (povšimněte si poslední větve s&nbsp;&bdquo;výplňovým&ldquo;
znakem _:</p>

<pre>
let rec factorial n =
    match n with
    | 0 -&gt; 1
    | 1 -&gt; 1
    | _ -&gt; n * factorial(n-1);;
&nbsp;
&nbsp;
Printf.printf "%d" (factorial 0);;
Printf.printf "%d" (factorial 1);;
Printf.printf "%d" (factorial 10);;
</pre>

<p>I v&nbsp;jazyku OCaml lze jednotlivé vzorky spojit znakem | do jediné
větve:</p>

<pre>
let rec factorial n =
    match n with
    | 0 | 1 -&gt; 1
    | _ -&gt; n * factorial(n-1);;
&nbsp;
&nbsp;
Printf.printf "%d" (factorial 0);;
Printf.printf "%d" (factorial 1);;
Printf.printf "%d" (factorial 10);;
</pre>

<p>A dokonce můžeme reagovat na nekorektní parametr. Zde jsou již odlišnosti od
jazyka F# poněkud větší, jak je to ostatně patrné na tomto příkladu (viz
zvýrazněná větev):</p>

<pre>
let rec factorial n =
    match n with
    | <strong>n when n &lt; 0 -&gt; invalid_arg "non-negative integer expected"</strong>
    | 0 | 1 -&gt; 1
    | _ -&gt; n * factorial(n-1);;
&nbsp;
&nbsp;
Printf.printf "%d" (factorial 0);;
Printf.printf "%d" (factorial 1);;
Printf.printf "%d" (factorial 10);;
Printf.printf "%d" (factorial -10);;
</pre>



<p><a name="k06"></a></p>
<h2 id="k06">6. Pattern matching pro větší množství hodnot</h2>

<p>Technologii pattern matchingu můžeme použít nejenom pro jedinou
kontrolovanou hodnotu (v&nbsp;předchozích příkladech se jednalo o <i>n</i>),
ale i pro větší množství hodnot. Ukažme si, jak lze řešit například klasickou
úlohu pro výpočet největšího společného dělitele, což je funkce, která musí
akceptovat dva parametry. I v&nbsp;tomto případě lze pattern matching
využít:</p>

<pre>
let rec <strong>gcd</strong> a b = 
    match a, b with
    | (a,0) -&gt; a
    | (a,b) -&gt; gcd b (a mod b);;
&nbsp;
&nbsp;
Printf.printf "%d" (gcd 12 8);;
Printf.printf "%d" (gcd 3 7);;
</pre>

<p>Prakticky stejným způsobem, jen s&nbsp;odlišnými větvemi a výrazy, můžeme
realizovat rekurzivní výpočet <a
href="https://en.wikipedia.org/wiki/Ackermann_function">Ackermannovy
funkce</a>. Tato funkce není primitivně rekurzivní a tudíž se nedá přepsat do
podoby s&nbsp;tail pozicemi a tedy do podoby, v&nbsp;níž může překladač
nahradit rekurzivní volání za programovou smyčku:</p>

<pre>
let rec <strong>ackermann</strong> m n =
  match m, n with
  | (0,n) -&gt; n+1
  | (m,0) -&gt; ackermann (m-1) 1
  | (m,n) -&gt; ackermann (m-1) (ackermann m (n-1));;
&nbsp;
&nbsp;
Printf.printf "%d" (ackermann 2 10);;
Printf.printf "%d" (ackermann -2 10);;
</pre>

<p>Kontrola neplatného vstupu, tj.&nbsp;situace, kdy jsou jeden či oba
parametry záporné, se řeší takto:</p>

<pre>
let rec <strong>ackermann</strong> = function
  | m,n when m &lt; 0 || n &lt; 0 -&gt; invalid_arg "Ackermann's function is only defined over the non-negative integers"
  | 0,n -&gt; n+1
  | m,0 -&gt; ackermann (m-1,1)
  | m,n -&gt; ackermann (m-1,ackermann (m,n-1));;
&nbsp;
&nbsp;
Printf.printf "%d" (ackermann (2,10));;
</pre>



<p><a name="k07"></a></p>
<h2 id="k07">7. Získání zvoleného prvku z&nbsp;n-tice s&nbsp;využitím pattern matchingu</h2>

<p>Pattern matching je možné využít i pro mnoho dalších operací. Funkce pro
vrácení prvního prvku z&nbsp;n-tice může v&nbsp;podání jazyka OCaml vypadat
takto:</p>

<pre>
let <strong>first</strong> tuple =
  match tuple with
  | (x,_) -&gt; x;;
&nbsp;
&nbsp;
Printf.printf "%d" (first (1,2));;
Printf.printf "%s" (first ("foo","bar"));;
</pre>

<p>Typ této funkce ukazuje, že n-tice může mít naprosto libovolné typy
prvků:</p>

<pre>
val first : 'a * 'b -&gt; 'a = &lt;fun&gt;
</pre>

<p>Naprosto stejným způsobem můžeme pochopitelně napsat funkci, která vrátí
druhý prvek:</p>

<pre>
let <strong>second</strong> tuple =
  match tuple with
  | (_,y) -&gt; y;;
&nbsp;
&nbsp;
Printf.printf "%d" (second (1,2));;
Printf.printf "%s" (second ("foo","bar"));;
</pre>

<p>Nebo si můžeme nechat vrátit dvojici, ovšem s&nbsp;prohozenými prvky:</p>

<pre>
let <strong>swap</strong> tuple =
  match tuple with
  | (x,y) -&gt; (y,x) ;;
</pre>

<p>Typ této funkce napovídá, jaká operace se provádí:</p>

<pre>
val swap : 'a * 'b -&gt; 'b * 'a = &lt;fun&gt;
</pre>



<p><a name="k08"></a></p>
<h2 id="k08">8. Další více či méně užitečné ukázky pattern matchingu</h2>

<p>Podobně jako v&nbsp;článku o pattern matchingu v&nbsp;jazyku F# si i zde
ukážeme některé další příklady použití této technologie, tentokrát
v&nbsp;OCamlu. Popisy příkladů budou velmi stručné, protože bychom se jen
opakovali.</p>

<p>Test na nulovost jedné souřadnice v&nbsp;dvouprvkovém vektoru:</p>

<pre>
let <strong>zero_coordinate</strong> point =
    match point with
    | (0, 0) | (0, _) | (_, 0) -&gt; true
    | _ -&gt; false;;
&nbsp;
&nbsp;
Printf.printf "%b" (zero_coordinate (0, 1));;
Printf.printf "%b" (zero_coordinate (1, 0));;
Printf.printf "%b" (zero_coordinate (0, 0));;
Printf.printf "%b" (zero_coordinate (1, 1));;
</pre>

<p>Přečtení zvoleného prvku ze záznamu (<i>record</i>):</p>

<pre>
type <strong>car</strong> = {
    color: string;
    model: string;
    manufacturer: string;
    year: int;
}
&nbsp;
let <strong>get_model</strong> car =
  match car with
  {model = m} -&gt; m;;
&nbsp;
let <strong>toyota</strong> = {color="silver"; model="corolla"; manufacturer="toyota"; year=1986};;
&nbsp;
Printf.printf "%s" (get_model toyota);;
</pre>



<p><a name="k09"></a></p>
<h2 id="k09">9. Práce se seznamy v&nbsp;OCamlu</h2>

<p>Ve druhé části dnešního článku se budeme zabývat zdánlivě triviálním
tématem: datovým typem seznam (list). Ve skutečnosti se však v&nbsp;jazycích
odvozených od původního jazyka ML jedná o velmi flexibilní datový typ, pro
jehož zpracování (a to včetně pattern matchingu) navíc existují speciální
syntaktické prvky. Navážeme tak na článek <a
href="https://www.root.cz/clanky/prace-se-seznamy-v-jazyce-f/">Práce se seznamy
v&nbsp;jazyce F#</a>.</p>

<p>Seznamy (<i>lists</i>) jsou vedle záznamů (<i>record</i>) nejdůležitějším
složeným datovým typem programovacího jazyka F#. Jedná se o <i>homogenní</i>
datový typ, což znamená, že všechny prvky seznamů musí být stejného typu, což
je kontrolováno překladačem (příkladem heterogenních složených typů je právě
<i>záznam</i> nebo <i>n-tice</i>).</p>



<p><a name="k10"></a></p>
<h2 id="k10">10. Konstruktor seznamů</h2>

<p>Pokud je zřejmé, jaké prvky mají být v&nbsp;seznamu uloženy, lze pro
konstrukci seznamů použít následující zápis, v&nbsp;němž jsou prvky umístěny do
hranatých závorek a pro jejich vzájemné oddělení se používá středník (nikoli
čárka!). Zápis tříprvkového seznamu s&nbsp;prvky typu celé číslo tedy může
vypadat následovně:</p>

<pre>
let x = [1; 2; 3];;
</pre>

<p>Pochopitelně můžeme naprosto stejným způsobem vytvořit i seznam s&nbsp;prvky
odlišného typu:</p>

<pre>
let x = ["foo"; "bar"; "baz"];;
</pre>

<p>Prvky seznamů mohou být i záznamy, n-tice či další seznamy. Podívejme se na
příklad s&nbsp;n-ticemi, konkrétně s&nbsp;dvojicemi:</p>

<pre>
let x = [(1, 2); (2, 3); (3, 4)];;
</pre>

<p>Pokus o vytvoření heterogenního seznamu (tedy seznamu s&nbsp;prvky, jejichž
typ je odlišný) skončí s&nbsp;chybou detekovanou již překladačem:</p>

<pre>
let x = [1;"foo";3];;
</pre>

<p>Chybová zpráva:</p>

<pre>
Line 1, characters 11-16:
Error: This expression has type string but an expression was expected of type int
</pre>

<p>přičemž druhý prvek tohoto seznamu je podtržen (v&nbsp;utopu), takže je
zřejmé, na kterém místě chyba vznikla.</p>

<p>Zatímco v&nbsp;jazyce F# se zobrazilo přece jen logičtější chybové
hlášení:</p>

<pre>
All elements of a list must be of the same type as the first element, which
here is 'int'. This element has type 'string'.
</pre>



<p><a name="k11"></a></p>
<h2 id="k11">11. Prázdný seznam</h2>

<p>Prázdný seznam se konstruuje následovně a v&nbsp;OCamlu se nazývá
<strong>nil</strong> (tímto zdravíme <a
href="https://www.root.cz/clanky/jemny-uvod-do-rozsahleho-sveta-jazyku-lisp-a-scheme/">LISP</a>):</p>

<pre>
<i>(* Prázdný seznam *)</i>
&nbsp;
let x = [];;
</pre>

<p>Povšimněte si, jakého typu je tento seznam:</p>

<pre>
- : 'a list = []
</pre>

<p><div class="rs-tip-major">Poznámka: prázdný seznam se v&nbsp;mnoha ohledech
liší od typu <i>unit</i>!</div></p>



<p><a name="k12"></a></p>
<h2 id="k12">12. Rekurzivní definice seznamu a operátor <strong>::</strong></h2>

<p>Naprosto stejně jako v&nbsp;jazyku F# je i v&nbsp;OCamlu sémantika seznamů
do značné míry převzata z&nbsp;LISPu, ovšem syntaxe práce s&nbsp;nimi je do
značné míry odlišná. Seznam může být v&nbsp;tomto kontextu definován
rekurzivně:</p>

<ul>
<li>buď je seznam prázdný (což se zapisuje, jak již víme, prázdnými hranatými závorkami [])</li>
<li>nebo má formu <strong>hlava::ocas</strong>, kde <strong>hlava</strong> je
prvním prvkem seznamu a ocas tvoří zbytek prvků seznamu (opět jde o seznam).
Operátor :: se nazývá <i>cons</i>.</li>
</ul>

<p>To ovšem například znamená, že seznam <strong>[42]</strong> je shodný se
seznamem <strong>42::[]</strong>. To si ostatně můžeme snadno otestovat:</p>

<pre>
let print_list l =
  print_string (String.concat " " (List.map string_of_int l));;
&nbsp;
&nbsp;
let x = <strong>[42]</strong>;;
print_list x;;
&nbsp;
let y = <strong>42::[]</strong>;;
print_list y;;
</pre>

<p>Výsledky:</p>

<pre>
42
42
</pre>

<p><div class="rs-tip-major">Poznámka: v&nbsp;OCamlu si musíme při tisku
seznamů pomoci. Prozatím je vhodné tělo funkce <strong>print_list</strong>
ignorovat a spolehnout se na to, že bude korektní.</div></p>

<p>Pokusme se podobným způsobem realizovat seznam se třemi prvky:</p>

<pre>
let print_list l =
    print_string (String.concat " " l);;
&nbsp;
&nbsp;
let x = <strong>["foo"; "bar"; "baz"]</strong>;;
print_list x;;
&nbsp;
let y = <strong>"foo"::"bar"::"baz"::[]</strong>;;
print_list y;;
</pre>

<p>Výsledky:</p>

<pre>
foo bar baz
foo bar baz
</pre>

<p>Z&nbsp;tohoto demonstračního příkladu si můžeme odvodit dvě vlastnosti
programovacího jazyka OCaml (jsou naprosto stejné, jako v&nbsp;F#):</p>

<ol>
<li>Operátor <strong>::</strong> je vyhodnocován zprava doleva</li>
<li>Zápis seznamu stylem <strong>[prvek1;prvek2;prvek3;...]</strong> je ve
skutečnosti jen syntaktických cukrem k&nbsp;zápisu
<strong>prvek1::prvek2::prvek3...::[]</strong></li>
</ol>

<p><div class="rs-tip-major">Poznámka: prázdný seznam (nebo jakýkoli jiný
seznam) je na konci výrazu s&nbsp;operátorem :: nutností. Nelze tedy zapsat jen
1::2, to není z&nbsp;pohledu programovacího jazyka OCaml úplný výraz.</div></p>



<p><a name="k13"></a></p>
<h2 id="k13">13. Spojení seznamů operátorem <strong>@</strong></h2>

<p>Kromě operátoru <strong>::</strong> využijeme při práci se seznamy další
speciální operátor zapisovaný znakem <strong>@</strong>. Tento operátor slouží
pro spojení dvou seznamů (stejného typu!). Podívejme se na příklad použití:</p>

<pre>
let print_list l =
  print_string (String.concat " " (List.map string_of_int l));;
&nbsp;
&nbsp;
let x = [1; 2; 3];;
let y = [3; 4; 5];;
let z = <strong>x @ y</strong>;;
&nbsp;
print_list x;;
print_list y;;
print_list z;;
</pre>

<p>Výsledkem bude tento seznam:</p>

<pre>
1 2 3 3 4 5
</pre>



<p><a name="k14"></a></p>
<h2 id="k14">14. Funkce pro zjištění vlastností seznamů</h2>

<p>Při popisu programovacího jazyka F# jsme si řekli, že vlastnosti seznamů lze
získat přes takzvané <i>properties</i>, které se zapisují s&nbsp;využitím
tečkové notace. Základní vlastnosti mají následující názvy:</p>

<table>
<tr><th>Vlastnost</th><th>Stručný popis</th></tr>
<tr><td>list.IsEmpty</td><td>test na prázdný seznam</td></tr>
<tr><td>list.Length</td><td>délka seznamu</td></tr>
<tr><td>list.Head</td><td>první prvek seznamu</td></tr>
<tr><td>list.Tail</td><td>ocas seznamu (bez prvního prvku)</td></tr>
<tr><td>list.Item n</td><td>n-tý prvek seznamu</td></tr>
</table>

<p>V&nbsp;jazyku OCaml je celý problém pojat poněkud odlišně, protože se
namísto <i>properties</i> používají funkce, které nalezneme v&nbsp;balíčku
<strong>List</strong>:</p>

<table>
<tr><th>Funkce</th><th>Stručný popis</th></tr>
<tr><td>List.is_empty</td><td>test na prázdný seznam (vyžaduje OCaml 5.x)</td></tr>
<tr><td>List.length</td><td>délka seznamu</td></tr>
<tr><td>List.hd</td><td>první prvek seznamu</td></tr>
<tr><td>List.tl</td><td>ocas seznamu (bez prvního prvku)</td></tr>
<tr><td>List.nth</td><td>n-tý prvek seznamu</td></tr>
</table>

<p>Podívejme se nyní na způsob použití těchto funkcí:</p>

<pre>
let x = [1; 2; 3];;
let y = [3; 4; 5];;
let z = x @ y;;
&nbsp;
&nbsp;
let print_list prefix l =
  Printf.printf "%s%s" prefix (String.concat " " (List.map string_of_int l));;
&nbsp;
&nbsp;
<i>(* Printf.printf "empty?: %b" (List.is_empty z);; *)</i>
Printf.printf "length: %d" (List.length z);;
Printf.printf "head:   %d" (List.hd z);;
Printf.printf "nth:    %d" (List.nth z 3);;
print_list    "tail:   "   (List.tl z);;
</pre>

<p><div class="rs-tip-major">Poznámka: funkci <strong>List.is_empty</strong>
jsem zakomentoval, protože v&nbsp;OCamlu 4.x a nižším není dostupná.</div></p>



<p><a name="k15"></a></p>
<h2 id="k15">15. Seznamy a pattern matching &ndash; výpočet délky seznamu</h2>

<p>Operátor <strong>::</strong>, o němž jsme se zmínili v&nbsp;předchozích
kapitolách, lze využít i při zápisu vzoru (<i>pattern</i>) v&nbsp;bloku
<strong>match</strong>. To tedy znamená, že můžeme zapsat test, zda seznam
obsahuje na začátku nějaký prvek, jakou hodnotu má tento prvek atd. Jedná se o
velmi silný koncept, která nám umožňuje elegantní realizaci mnoha funkcí, které
musí zpracovat prvky seznamu. Většina těchto funkcí zpracovává seznam
sekvenčně, tedy nejdříve zpracuje jeho první prvek (hlavu) a poté rekurzivně
zbytek seznamu (ocas).</p>

<p>Rekurzivní výpočet délky seznamu <i>bez</i> použití pattern matchingu lze
zapsat takto:</p>

<pre>
<i>(* Naivní implementace funkce length *)</i>
&nbsp;
let rec <strong>len</strong> (x:'a list) =
  if x = [] then 0
  else 1 + (<strong>len</strong> (List.tl x));;
&nbsp;
&nbsp;
Printf.printf "%d" (len [1;2;3;4]);;
</pre>

<p>Tuto funkci můžeme velmi snadno přepsat do podoby, v&nbsp;níž se použije
<i>pattern matching</i>. Upravený tvar může vypadat následovně a velmi přesně
odpovídá teoretickému zápisu algoritmu:</p>

<pre>
<i>(* Méně naivní implementace funkce length *)</i>
&nbsp;
let rec <strong>len</strong> x =
    match x with
    | head :: tail -&gt; 1 + <strong>len</strong> tail
    | [] -&gt; 0;;
&nbsp;
&nbsp;
Printf.printf "%d" (len [1;2;3;4]);;
</pre>

<p>Povšimněte si, že ve větvi začínající vzorkem <strong>head :: tail</strong>
se ve skutečnosti nikde nepracuje s&nbsp;hodnotou prvního prvku seznamu
(<i>head</i>). Proto můžeme tento identifikátor nahradit za podtržítko.
Výsledkem bude naprosto stejná realizace algoritmu, ovšem bez přebytečných
identifikátorů:</p>

<pre>
<i>(* Méně naivní implementace funkce length *)</i>
&nbsp;
let rec <strong>len</strong> x =
    match x with
    | _ :: tail -&gt; 1 + <strong>len</strong> tail
    | [] -&gt; 0;;
&nbsp;
&nbsp;
Printf.printf "%d" (len [1;2;3;4]);;
</pre>



<p><a name="k16"></a></p>
<h2 id="k16">16. Rekurzivní zápis funkce <strong>append</strong> pro spojení dvou seznamů</h2>

<p>Naprosto stejným postupem si můžeme nadefinovat funkci
<strong>append</strong>, která vrací nový seznam vzniklý spojením dvou seznamů
<strong>x</strong> a <strong>y</strong>. Tedy například:</p>

<pre>
<i>(* Naivní implementace funkce append *)</i>
&nbsp; 
let rec <strong>append</strong> (x: 'a list) y =
  if x == [] then y
  else (List.hd x) :: (<strong>append</strong> (List.tl x) y);;
&nbsp; 
&nbsp; 
let print_list l =
  print_string (String.concat " " (List.map string_of_int l));;
&nbsp;
&nbsp;
print_list (append [] [1; 2; 3]);;
print_list (append [1; 2; 3] []);;
print_list (append [1; 2; 3] [4; 5]);;
print_list (append [] []);;
</pre>

<p><div class="rs-tip-major">Poznámka: navíc se nám automaticky splnily všechny
okrajové podmínky, tedy konkrétně situace, kdy je jeden ze seznamů
prázdný.</div></p>

<p>V&nbsp;praxi se vždy při zápisu algoritmů, v&nbsp;nichž se vyskytuje plná
podoba rozeskoku <strong>if-then-else</strong>, vyplatí popřemýšlet, zda nebude
výhodnější použít <i>pattern matching</i>. U funkce <strong>append</strong>
tomu tak skutečně je, protože její varianta s&nbsp;pattern matchingem je mnohem
čitelnější. Je v&nbsp;ní patrné, jak postupně přesunujeme prvky z&nbsp;prvního
seznamu do vznikajícího seznamu výsledného (a nakonec připojíme celý druhý
seznam):</p>

<pre>
<i>(* Implementace funkce append založená na pattern matchingu *)</i>
&nbsp; 
let rec <strong>append</strong> x y =
    match x with
    | [] -&gt; y
    | head :: tail -&gt; head :: <strong>append</strong> tail y
&nbsp; 
&nbsp; 
let print_list l =
  print_string (String.concat " " (List.map string_of_int l));;
&nbsp; 
&nbsp; 
print_list (append [] [1; 2; 3]);;
print_list (append [1; 2; 3] []);;
print_list (append [1; 2; 3] [4; 5]);;
print_list (append [] []);;
</pre>



<p><a name="k17"></a></p>
<h2 id="k17">17. Součet hodnot všech prvků uložených v&nbsp;seznamu</h2>

<p>Mnoho operací nad seznamy je založeno na postupném zpracování prvků seznamu,
konkrétně od prvku prvního (hlavy). To většinou vede k&nbsp;velmi podobnému
zápisu algoritmů, zejména při použití pattern matchingu. Ostatně si můžeme
ukázat realizaci dalšího algoritmu, tentokrát algoritmu pro součet všech prvků
v&nbsp;seznamu. Řešení bude opět rekurzivní a vzorky použité v&nbsp;bloku
<strong>match</strong> jsou totožné se vzorky z&nbsp;předchozích demonstračních
příkladů, což je ovšem logické, protože opět potřebujeme vyřešit dva případy
&ndash; prázdný seznam a seznam s&nbsp;minimálně jedním prvkem:</p>

<pre>
let rec <strong>sum</strong> x =
    match x with
    | [] -&gt; 0
    | head :: tail -&gt; head + sum tail;;
&nbsp;
&nbsp;
Printf.printf "%d" (sum []);;
Printf.printf "%d" (sum [1; 2; 3]);;
</pre>

<p>Přímá rekurze, která není v&nbsp;tail pozici a kterou jsme použili při
realizaci algoritmu pro součet prvků v&nbsp;seznamu, není v&nbsp;praxi příliš
efektivní. Proto se můžeme pokusit o její nahrazení variantou s&nbsp;tail
pozicí, což opět (prakticky nutně) vede k&nbsp;použití <i>akumulátoru</i> a
vnitřní pomocné funkce, která je založena na tail rekurzi a kterou voláme
s&nbsp;předáním akumulované hodnoty. Povšimněte si, že tato funkce
(<strong>sumr</strong>) má dva parametry &ndash; seznam a hodnotu akumulátoru a
skutečně volá sebe samu v&nbsp;tail pozici (tedy výsledek volané funkce je
současně i výsledkem funkce aktuálně prováděné):</p>

<pre>
let <strong>sum</strong> x =
  let rec <strong>sumr</strong> x a =
    match x with
    | [] -&gt; a
    | head :: tail -&gt; <strong>sumr</strong> tail (a + head)
  in
  <strong>sumr</strong> x 0
;;
&nbsp;
&nbsp;
Printf.printf "%d" (sum []);;
Printf.printf "%d" (sum [1; 2; 3]);;
</pre>

<p><div class="rs-tip-major">Poznámka: povšimněte si opět, že v&nbsp;jazyku
OCaml je nutné použít zápis s&nbsp;<strong>in</strong>, kterým říkáme,
v&nbsp;jakém bloku má být symbol <strong>sumr</strong> použit.</div></p>



<p><a name="k18"></a></p>
<h2 id="k18">18. Příloha: tisk seznamu v&nbsp;jazyku OCaml</h2>

<p>Při procházení demonstračních příkladů z&nbsp;předchozích kapitol jste si
pravděpodobně všimli, že jsme museli použít pomocné funkce pro tisk obsahu
seznamu. Nejjednodušší je tisk seznamu obsahujícího prvky typu řetězec, protože
celý problém je vlastně vyřešen knihovní funkcí <strong>String.concat</strong>,
který prvky spojí a vloží mezi ně nějaký oddělovač:</p>

<pre>
let <strong>print_list</strong> l =
    print_string (String.concat " " l);;
&nbsp;
&nbsp;
let x = ["foo"; "bar"; "baz"];;
print_list x;;
</pre>

<p>Poněkud složitější je tisk seznamu, jehož prvky nejsou řetězce, protože
nejprve musíme provést převod těchto prvků na řetězec. K&nbsp;tomu lze použít
funkci <strong>map</strong>, přesněji řečeno <strong>List.map</strong>, pomocí
níž aplikujeme funkci <strong>string_of_int</strong> (hrozné jméno) na každý
prvek seznamu, čímž získáme seznam řetězců:</p>

<pre>
let <strong>print_list</strong> l =
  print_string (String.concat " " (List.map string_of_int l));;
&nbsp;
&nbsp;
let x = [1; 2; 3; 4];;
print_list x;;
</pre>

<p>A konečně nám nic nebrání v&nbsp;tom vypsat seznam nějakým sofistikovanějším
způsobem &ndash; s&nbsp;prefixovými znaky, postfixovými znaky, vlastními
oddělovači atd. atd.:</p>

<pre>
let x = [1; 2; 3];;
&nbsp;
&nbsp;
let <strong>print_list</strong> prefix l =
  Printf.printf "%s%s" prefix (String.concat " " (List.map string_of_int l));;
&nbsp;
&nbsp;
print_list "my list: " x;;
</pre>



<p><a name="k19"></a></p>
<h2 id="k19">19. Repositář s&nbsp;demonstračními příklady</h2>

<p>Všechny výše popsané demonstrační příklady byly uloženy do repositáře
dostupného na adrese <a
href="https://github.com/tisnik/ocaml-examples/">https://github.com/tisnik/ocaml-examples/</a>.
V&nbsp;tabulce umístěné pod tímto odstavcem jsou uvedeny odkazy na tyto
příklady:</p>

<table>
<tr><th> #</th><th>Příklad</th><th>Popis příkladu</th><th>Cesta</th></tr>
<tr><td> 1</td><td>article_01/hello_world_1.ml</td><td>zavolání funkce <strong>print_string</strong></td><td><a href="https://github.com/tisnik/ocaml-examples/tree/master/article_01/hello_world_1.ml">https://github.com/tisnik/ocaml-examples/tree/master/article_01/hello_world_1.ml</a></td></tr>
<tr><td> 2</td><td>article_01/hello_world_2.ml</td><td>zavolání funkce <strong>printf.Printf</strong></td><td><a href="https://github.com/tisnik/ocaml-examples/tree/master/article_01/hello_world_2.ml">https://github.com/tisnik/ocaml-examples/tree/master/article_01/hello_world_2.ml</a></td></tr>
<tr><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td></tr>
<tr><td> 3</td><td>article_01/function.ml</td><td>definice funkce</td><td><a href="https://github.com/tisnik/ocaml-examples/tree/master/article_01/function.ml">https://github.com/tisnik/ocaml-examples/tree/master/article_01/function.ml</a></td></tr>
<tr><td> 4</td><td>article_01/lambda.ml</td><td>anonymní funkce</td><td><a href="https://github.com/tisnik/ocaml-examples/tree/master/article_01/lambda.ml">https://github.com/tisnik/ocaml-examples/tree/master/article_01/lambda.ml</a></td></tr>
<tr><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td></tr>
<tr><td> 5</td><td>article_01/function_type_1.ml</td><td>explicitní specifikace typu návratové hodnoty funkce</td><td><a href="https://github.com/tisnik/ocaml-examples/tree/master/article_01/function_type_1.ml">https://github.com/tisnik/ocaml-examples/tree/master/article_01/function_type_1.ml</a></td></tr>
<tr><td> 6</td><td>article_01/function_type_2.ml</td><td>explicitní specifikace typu návratové hodnoty funkce</td><td><a href="https://github.com/tisnik/ocaml-examples/tree/master/article_01/function_type_2.ml">https://github.com/tisnik/ocaml-examples/tree/master/article_01/function_type_2.ml</a></td></tr>
<tr><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td></tr>
<tr><td> 7</td><td>article_01/call_function_1.ml</td><td>definice jednoduché funkce s&nbsp;jejím zavoláním</td><td><a href="https://github.com/tisnik/ocaml-examples/tree/master/article_01/call_function_1.ml">https://github.com/tisnik/ocaml-examples/tree/master/article_01/call_function_1.ml</a></td></tr>
<tr><td> 8</td><td>article_01/call_function_2.ml</td><td>definice jednoduché funkce s&nbsp;jejím zavoláním</td><td><a href="https://github.com/tisnik/ocaml-examples/tree/master/article_01/call_function_2.ml">https://github.com/tisnik/ocaml-examples/tree/master/article_01/call_function_2.ml</a></td></tr>
<tr><td> 9</td><td>article_01/call_function_3.ml</td><td>použití operátoru <strong>+</strong> pro dvojici hodnot typu <strong>float</strong></td><td><a href="https://github.com/tisnik/ocaml-examples/tree/master/article_01/call_function_3.ml">https://github.com/tisnik/ocaml-examples/tree/master/article_01/call_function_3.ml</a></td></tr>
<tr><td>10</td><td>article_01/call_function_4.ml</td><td>použití operátoru <strong>+.</strong> pro dvojici hodnot typu <strong>float</strong></td><td><a href="https://github.com/tisnik/ocaml-examples/tree/master/article_01/call_function_4.ml">https://github.com/tisnik/ocaml-examples/tree/master/article_01/call_function_4.ml</a></td></tr>
<tr><td>11</td><td>article_01/call_function_5.ml</td><td>plná deklarace funkce bez syntaktického cukru</td><td><a href="https://github.com/tisnik/ocaml-examples/tree/master/article_01/call_function_5.ml">https://github.com/tisnik/ocaml-examples/tree/master/article_01/call_function_5.ml</a></td></tr>
<tr><td>12</td><td>article_01/call_function_6.ml</td><td>plná deklarace funkce bez syntaktického cukru</td><td><a href="https://github.com/tisnik/ocaml-examples/tree/master/article_01/call_function_6.ml">https://github.com/tisnik/ocaml-examples/tree/master/article_01/call_function_6.ml</a></td></tr>
<tr><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td></tr>
<tr><td>13</td><td>article_01/local_binding_1.ml</td><td>definice lokálních symbolů</td><td><a href="https://github.com/tisnik/ocaml-examples/tree/master/article_01/local_binding_1.ml">https://github.com/tisnik/ocaml-examples/tree/master/article_01/local_binding_1.ml</a></td></tr>
<tr><td>14</td><td>article_01/local_binding_2.ml</td><td>definice lokálních symbolů</td><td><a href="https://github.com/tisnik/ocaml-examples/tree/master/article_01/local_binding_2.ml">https://github.com/tisnik/ocaml-examples/tree/master/article_01/local_binding_2.ml</a></td></tr>
<tr><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td></tr>
<tr><td>15</td><td>article_02/basic_binding.ml</td><td>navázání hodnoty na symbol (deklarace proměnné)</td><td><a href="https://github.com/tisnik/ocaml-examples/tree/master/article_02/basic_binding.ml">https://github.com/tisnik/ocaml-examples/tree/master/article_02/basic_binding.ml</a></td></tr>
<tr><td>16</td><td>article_02/print_variable.ml</td><td>tisk hodnoty proměnné</td><td><a href="https://github.com/tisnik/ocaml-examples/tree/master/article_02/print_variable.ml">https://github.com/tisnik/ocaml-examples/tree/master/article_02/print_variable.ml</a></td></tr>
<tr><td>17</td><td>article_02/variables_and_functions.ml</td><td>předání proměnné do funkce</td><td><a href="https://github.com/tisnik/ocaml-examples/tree/master/article_02/variables_and_functions.ml">https://github.com/tisnik/ocaml-examples/tree/master/article_02/variables_and_functions.ml</a></td></tr>
<tr><td>18</td><td>article_02/redefine_symbol_1.ml</td><td>pokus o redefinici symbolu</td><td><a href="https://github.com/tisnik/ocaml-examples/tree/master/article_02/redefine_symbol_1.ml">https://github.com/tisnik/ocaml-examples/tree/master/article_02/redefine_symbol_1.ml</a></td></tr>
<tr><td>19</td><td>article_02/redefine_symbol_2.ml</td><td>pokus o redefinici symbolu (složitější příklad)</td><td><a href="https://github.com/tisnik/ocaml-examples/tree/master/article_02/redefine_symbol_2.ml">https://github.com/tisnik/ocaml-examples/tree/master/article_02/redefine_symbol_2.ml</a></td></tr>
<tr><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td></tr>
<tr><td>20</td><td>article_02/requal_operator_1.ml</td><td>operátor =</td><td><a href="https://github.com/tisnik/ocaml-examples/tree/master/article_02/equal_operator_1.ml">https://github.com/tisnik/ocaml-examples/tree/master/article_02/equal_operator_1.ml</a></td></tr>
<tr><td>21</td><td>article_02/requal_operator_2.ml</td><td>operátor =</td><td><a href="https://github.com/tisnik/ocaml-examples/tree/master/article_02/equal_operator_2.ml">https://github.com/tisnik/ocaml-examples/tree/master/article_02/equal_operator_2.ml</a></td></tr>
<tr><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td></tr>
<tr><td>22</td><td>article_02/immutable_variable.ml</td><td>&bdquo;změna&ldquo; neměnitelné proměnné</td><td><a href="https://github.com/tisnik/ocaml-examples/tree/master/article_02/immutable_variable.ml">https://github.com/tisnik/ocaml-examples/tree/master/article_02/immutable_variable.ml</a></td></tr>
<tr><td>22</td><td>article_02/mutable_variable.ml</td><td>změna měnitelné proměnné</td><td><a href="https://github.com/tisnik/ocaml-examples/tree/master/article_02/mutable_variable.ml">https://github.com/tisnik/ocaml-examples/tree/master/article_02/mutable_variable.ml</a></td></tr>
<tr><td>23</td><td>article_02/shadow.ml</td><td>shadowing symbolu</td><td><a href="https://github.com/tisnik/ocaml-examples/tree/master/article_02/shadow.ml">https://github.com/tisnik/ocaml-examples/tree/master/article_02/shadow.ml</a></td></tr>
<tr><td>24</td><td>article_02/incr.ml</td><td>standardní funkce <strong>incr</strong></td><td><a href="https://github.com/tisnik/ocaml-examples/tree/master/article_02/incr.ml">https://github.com/tisnik/ocaml-examples/tree/master/article_02/incr.ml</a></td></tr>
<tr><td>25</td><td>article_02/ident.ml</td><td>nejjednodušší polymorfická funkce</td><td><a href="https://github.com/tisnik/ocaml-examples/tree/master/article_02/ident.ml">https://github.com/tisnik/ocaml-examples/tree/master/article_02/ident.ml</a></td></tr>
<tr><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td></tr>
<tr><td>26</td><td>article_02/tuple1.ml</td><td>datový typ n-tice (<i>tuple</i>)</td><td><a href="https://github.com/tisnik/ocaml-examples/tree/master/article_02/tuple1.ml">https://github.com/tisnik/ocaml-examples/tree/master/article_02/tuple1.ml</a></td></tr>
<tr><td>27</td><td>article_02/tuple2.ml</td><td>datový typ n-tice (<i>tuple</i>)</td><td><a href="https://github.com/tisnik/ocaml-examples/tree/master/article_02/tuple2.ml">https://github.com/tisnik/ocaml-examples/tree/master/article_02/tuple2.ml</a></td></tr>
<tr><td>28</td><td>article_02/record1.ml</td><td>datový typ záznam (<i>record</i>), deklarace proměnné tohoto typu</td><td><a href="https://github.com/tisnik/ocaml-examples/tree/master/article_02/record1.ml">https://github.com/tisnik/ocaml-examples/tree/master/article_02/record1.ml</a></td></tr>
<tr><td>29</td><td>article_02/record2.ml</td><td>datový typ záznam (<i>record</i>) a typová inference</td><td><a href="https://github.com/tisnik/ocaml-examples/tree/master/article_02/record2.ml">https://github.com/tisnik/ocaml-examples/tree/master/article_02/record2.ml</a></td></tr>
<tr><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td></tr>
<tr><td>30</td><td>article_02/unit.ml</td><td>datový typ <strong>unit</strong> a rozdíl oproti funkcím bez parametrů</td><td><a href="https://github.com/tisnik/ocaml-examples/tree/master/article_02/unit.ml">https://github.com/tisnik/ocaml-examples/tree/master/article_02/unit.ml</a></td></tr>
<tr><td>31</td><td>article_02/polymorphic.ml</td><td>použití polymorfických funkcí</td><td><a href="https://github.com/tisnik/ocaml-examples/tree/master/article_02/polymorphic.ml">https://github.com/tisnik/ocaml-examples/tree/master/article_02/polymorphic.ml</a></td></tr>
<tr><td>32</td><td>article_02/two_same_records.ml</td><td>dva datové typy záznam se shodnými prvky</td><td><a href="https://github.com/tisnik/ocaml-examples/tree/master/article_02/two_same_records.ml">https://github.com/tisnik/ocaml-examples/tree/master/article_02/two_same_records.ml</a></td></tr>
<tr><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td></tr>
<tr><td>33</td><td>article_03/recursion1.ml</td><td>pokus o deklaraci funkce s&nbsp;přímou rekurzí založený na <strong>let</strong></td><td><a href="https://github.com/tisnik/ocaml-examples/tree/master/article_03/recursion1.ml">https://github.com/tisnik/ocaml-examples/tree/master/article_03/recursion1.ml</a></td></tr>
<tr><td>34</td><td>article_03/recursion2.ml</td><td>deklarace funkce s&nbsp;přímou rekurzí založená na <strong>let rec</strong></td><td><a href="https://github.com/tisnik/ocaml-examples/tree/master/article_03/recursion2.ml">https://github.com/tisnik/ocaml-examples/tree/master/article_03/recursion2.ml</a></td></tr>
<tr><td>35</td><td>article_03/recursion3.ml</td><td>využití tail rekurze pro výpočet členu Fibonacciho posloupnosti</td><td><a href="https://github.com/tisnik/ocaml-examples/tree/master/article_03/recursion3.ml">https://github.com/tisnik/ocaml-examples/tree/master/article_03/recursion3.ml</a></td></tr>
<tr><td>36</td><td>article_03/recursion4.ml</td><td>obyčejná nerekurzivní funkce definovaná přes <strong>let rec</strong></td><td><a href="https://github.com/tisnik/ocaml-examples/tree/master/article_03/recursion4.ml">https://github.com/tisnik/ocaml-examples/tree/master/article_03/recursion4.ml</a></td></tr>
<tr><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td></tr>
<tr><td>37</td><td>article_03/odd_even_1.ml</td><td>nepřímá rekurze (nekorektní varianta)</td><td><a href="https://github.com/tisnik/ocaml-examples/tree/master/article_03/odd_even_1.ml">https://github.com/tisnik/ocaml-examples/tree/master/article_03/odd_even_1.ml</a></td></tr>
<tr><td>38</td><td>article_03/odd_even_2.ml</td><td>nepřímá rekurze (taktéž nekorektní varianta)</td><td><a href="https://github.com/tisnik/ocaml-examples/tree/master/article_03/odd_even_2.ml">https://github.com/tisnik/ocaml-examples/tree/master/article_03/odd_even_2.ml</a></td></tr>
<tr><td>39</td><td>article_03/odd_even_3.ml</td><td>jediný korektní zápis nepřímé rekurze</td><td><a href="https://github.com/tisnik/ocaml-examples/tree/master/article_03/odd_even_3.ml">https://github.com/tisnik/ocaml-examples/tree/master/article_03/odd_even_3.ml</a></td></tr>
<tr><td>40</td><td>article_03/odd_even_4.ml</td><td>nepřímá rekurze bez použití klíčového slova <strong>rec</strong></td><td><a href="https://github.com/tisnik/ocaml-examples/tree/master/article_03/odd_even_4.ml">https://github.com/tisnik/ocaml-examples/tree/master/article_03/odd_even_4.ml</a></td></tr>
<tr><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td></tr>
<tr><td>41</td><td>article_03/pattern1.ml</td><td>výpočet Faktoriálu založený na pattern matchingu</td><td><a href="https://github.com/tisnik/ocaml-examples/tree/master/article_03/pattern1.ml">https://github.com/tisnik/ocaml-examples/tree/master/article_03/pattern1.ml</a></td></tr>
<tr><td>42</td><td>article_03/pattern2.ml</td><td>výpočet Faktoriálu založený na pattern matchingu, sloučení vstupů se stejným výstupem</td><td><a href="https://github.com/tisnik/ocaml-examples/tree/master/article_03/pattern2.ml">https://github.com/tisnik/ocaml-examples/tree/master/article_03/pattern2.ml</a></td></tr>
<tr><td>43</td><td>article_03/pattern3.ml</td><td>kontrola neplatného vstupu</td><td><a href="https://github.com/tisnik/ocaml-examples/tree/master/article_03/pattern3.ml">https://github.com/tisnik/ocaml-examples/tree/master/article_03/pattern3.ml</a></td></tr>
<tr><td>44</td><td>article_03/pattern4.ml</td><td>pattern matching pro větší množství hodnot</td><td><a href="https://github.com/tisnik/ocaml-examples/tree/master/article_03/pattern4.ml">https://github.com/tisnik/ocaml-examples/tree/master/article_03/pattern4.ml</a></td></tr>
<tr><td>45</td><td>article_03/pattern5.ml</td><td>rekurzivní implementace Ackermannovy funkce</td><td><a href="https://github.com/tisnik/ocaml-examples/tree/master/article_03/pattern5.ml">https://github.com/tisnik/ocaml-examples/tree/master/article_03/pattern5.ml</a></td></tr>
<tr><td>46</td><td>article_03/pattern6.ml</td><td>kontrola neplatných vstupních hodnot pro Ackermannovu funkci</td><td><a href="https://github.com/tisnik/ocaml-examples/tree/master/article_03/pattern6.ml">https://github.com/tisnik/ocaml-examples/tree/master/article_03/pattern6.ml</a></td></tr>
<tr><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td></tr>
<tr><td>47</td><td>article_03/fibonacci1.ml</td><td>výpočet Fibonacciho posloupnosti založený na pattern matchingu</td><td><a href="https://github.com/tisnik/ocaml-examples/tree/master/article_03/fibonacci1.ml">https://github.com/tisnik/ocaml-examples/tree/master/article_03/fibonacci1.ml</a></td></tr>
<tr><td>48</td><td>article_03/fibonacci2.ml</td><td>výpočet Fibonacciho posloupnosti založený na pattern matchingu (více idiomatický zápis)</td><td><a href="https://github.com/tisnik/ocaml-examples/tree/master/article_03/fibonacci2.ml">https://github.com/tisnik/ocaml-examples/tree/master/article_03/fibonacci2.ml</a></td></tr>
<tr><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td></tr>
<tr><td>49</td><td>article_03/first.ml</td><td>funkce vracející první prvek z&nbsp;dvojice založená na pattern matchingu</td><td><a href="https://github.com/tisnik/ocaml-examples/tree/master/article_03/first.ml">https://github.com/tisnik/ocaml-examples/tree/master/article_03/first.ml</a></td></tr>
<tr><td>50</td><td>article_03/second.ml</td><td>funkce vracející druhý prvek z&nbsp;dvojice založená na pattern matchingu</td><td><a href="https://github.com/tisnik/ocaml-examples/tree/master/article_03/second.ml">https://github.com/tisnik/ocaml-examples/tree/master/article_03/second.ml</a></td></tr>
<tr><td>51</td><td>article_03/zero_coordinate.ml</td><td>test na nulovou souřadnici/souřadnice založený na pattern matchingu</td><td><a href="https://github.com/tisnik/ocaml-examples/tree/master/article_03/zero_coordinate.ml">https://github.com/tisnik/ocaml-examples/tree/master/article_03/zero_coordinate.ml</a></td></tr>
<tr><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td></tr>
<tr><td>52</td><td>article_03/get_model.ml</td><td>získání prvku ze záznamu (opět založeno na pattern matchingu)</td><td><a href="https://github.com/tisnik/ocaml-examples/tree/master/article_03/get_model.ml">https://github.com/tisnik/ocaml-examples/tree/master/article_03/get_model.ml</a></td></tr>
<tr><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td></tr>
<tr><td>53</td><td>article_03/list_literal_1.ml</td><td>seznam se třemi prvky typu celé číslo</td><td><a href="https://github.com/tisnik/ocaml-examples/tree/master/article_03/list_literal_1.ml">https://github.com/tisnik/ocaml-examples/tree/master/article_03/list_literal_1.ml</a></td></tr>
<tr><td>54</td><td>article_03/list_literal_2.ml</td><td>seznam se třemi prvky typu řetězec</td><td><a href="https://github.com/tisnik/ocaml-examples/tree/master/article_03/list_literal_2.ml">https://github.com/tisnik/ocaml-examples/tree/master/article_03/list_literal_2.ml</a></td></tr>
<tr><td>55</td><td>article_03/list_literal_3.ml</td><td>seznam se třemi prvky typu n-tice</td><td><a href="https://github.com/tisnik/ocaml-examples/tree/master/article_03/list_literal_3.ml">https://github.com/tisnik/ocaml-examples/tree/master/article_03/list_literal_3.ml</a></td></tr>
<tr><td>56</td><td>article_03/list_literal_4.ml</td><td>nekorektní pokus o vytvoření seznamu s&nbsp;prvky různých typů</td><td><a href="https://github.com/tisnik/ocaml-examples/tree/master/article_03/list_literal_4.ml">https://github.com/tisnik/ocaml-examples/tree/master/article_03/list_literal_4.ml</a></td></tr>
<tr><td>57</td><td>article_03/empty_list.ml</td><td>konstrukce prázdného seznamu</td><td><a href="https://github.com/tisnik/ocaml-examples/tree/master/article_03/empty_list.ml">https://github.com/tisnik/ocaml-examples/tree/master/article_03/empty_list.ml</a></td></tr>
<tr><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td></tr>
<tr><td>58</td><td>article_03/head_tail_1.ml</td><td>složení seznamu se dvěma prvky s&nbsp;využitím operátoru <strong>::</strong></td><td><a href="https://github.com/tisnik/ocaml-examples/tree/master/article_03/head_tail_1.ml">https://github.com/tisnik/ocaml-examples/tree/master/article_03/head_tail_1.ml</a></td></tr>
<tr><td>59</td><td>article_03/head_tail_2.ml</td><td>složení seznamu se třemi prvky s&nbsp;využitím operátoru <strong>::</strong></td><td><a href="https://github.com/tisnik/ocaml-examples/tree/master/article_03/head_tail_2.ml">https://github.com/tisnik/ocaml-examples/tree/master/article_03/head_tail_2.ml</a></td></tr>
<tr><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td></tr>
<tr><td>60</td><td>article_03/list_properties.ml</td><td>vlastnosti (<i>properties</i>) seznamů</td><td><a href="https://github.com/tisnik/ocaml-examples/tree/master/article_03/list_properties.ml">https://github.com/tisnik/ocaml-examples/tree/master/article_03/list_properties.ml</a></td></tr>
<tr><td>61</td><td>article_03/len_1.ml</td><td>naivní rekurzivní výpočet délky seznamu</td><td><a href="https://github.com/tisnik/ocaml-examples/tree/master/article_03/len_1.ml">https://github.com/tisnik/ocaml-examples/tree/master/article_03/len_1.ml</a></td></tr>
<tr><td>62</td><td>article_03/len_2.ml</td><td>vylepšený rekurzivní výpočet délky seznamu</td><td><a href="https://github.com/tisnik/ocaml-examples/tree/master/article_03/len_2.ml">https://github.com/tisnik/ocaml-examples/tree/master/article_03/len_2.ml</a></td></tr>
<tr><td>63</td><td>article_03/len_3.ml</td><td>vylepšený rekurzivní výpočet délky seznamu</td><td><a href="https://github.com/tisnik/ocaml-examples/tree/master/article_03/len_3.ml">https://github.com/tisnik/ocaml-examples/tree/master/article_03/len_3.ml</a></td></tr>
<tr><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td></tr>
<tr><td>64</td><td>article_03/join_lists.ml</td><td>spojení dvou seznamů operátorem <strong>::</strong></td><td><a href="https://github.com/tisnik/ocaml-examples/tree/master/article_03/join_lists.ml">https://github.com/tisnik/ocaml-examples/tree/master/article_03/join_lists.ml</a></td></tr>
<tr><td>65</td><td>article_03/append_1.ml</td><td>implementace spojení dvou seznamů rekurzivním výpočtem</td><td><a href="https://github.com/tisnik/ocaml-examples/tree/master/article_03/append_1.ml">https://github.com/tisnik/ocaml-examples/tree/master/article_03/append_1.ml</a></td></tr>
<tr><td>66</td><td>article_03/append_2.ml</td><td>implementace spojení dvou seznamů rekurzivním výpočtem, použití pattern matchingu</td><td><a href="https://github.com/tisnik/ocaml-examples/tree/master/article_03/append_2.ml">https://github.com/tisnik/ocaml-examples/tree/master/article_03/append_2.ml</a></td></tr>
<tr><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td></tr>
<tr><td>67</td><td>article_03/sum_1.ml</td><td>součet hodnot všech prvků v&nbsp;seznamu (bez tail rekurze)</td><td><a href="https://github.com/tisnik/ocaml-examples/tree/master/article_03/sum_1.ml">https://github.com/tisnik/ocaml-examples/tree/master/article_03/sum_1.ml</a></td></tr>
<tr><td>68</td><td>article_03/sum_2.ml</td><td>součet hodnot všech prvků v&nbsp;seznamu (s&nbsp;využitím tail rekurze)</td><td><a href="https://github.com/tisnik/ocaml-examples/tree/master/article_03/sum_2.ml">https://github.com/tisnik/ocaml-examples/tree/master/article_03/sum_2.ml</a></td></tr>
<tr><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td></tr>
<tr><td>69</td><td>article_03/print_int_list.ml</td><td>tisk seznamu celých čísel</td><td><a href="https://github.com/tisnik/ocaml-examples/tree/master/article_03/print_int_list.ml">https://github.com/tisnik/ocaml-examples/tree/master/article_03/print_int_list.ml</a></td></tr>
<tr><td>70</td><td>article_03/print_string_list.ml</td><td>tisk seznamu řetězců</td><td><a href="https://github.com/tisnik/ocaml-examples/tree/master/article_03/print_string_list.ml">https://github.com/tisnik/ocaml-examples/tree/master/article_03/print_string_list.ml</a></td></tr>
<tr><td>71</td><td>article_03/print_list_prefix.ml</td><td>tisk seznamu s&nbsp;prefixem</td><td><a href="https://github.com/tisnik/ocaml-examples/tree/master/article_03/print_list_prefix.ml">https://github.com/tisnik/ocaml-examples/tree/master/article_03/print_list_prefix.ml</a></td></tr>
</table>



<p><a name="k20"></a></p>
<h2 id="k20">20. Odkazy na Internetu</h2>

<ol>

<li>General-Purpose, Industrial-Strength, Expressive, and Safe<br />
<a href="https://ocaml.org/">https://ocaml.org/</a>
</li>

<li>OCaml playground<br />
<a href="https://ocaml.org/play">https://ocaml.org/play</a>
</li>

<li>Online Ocaml Compiler IDE<br />
<a href="https://www.jdoodle.com/compile-ocaml-online/">https://www.jdoodle.com/compile-ocaml-online/</a>
</li>

<li>Get Started - OCaml<br />
<a href="https://www.ocaml.org/docs">https://www.ocaml.org/docs</a>
</li>

<li>Get Up and Running With OCaml<br />
<a href="https://www.ocaml.org/docs/up-and-running">https://www.ocaml.org/docs/up-and-running</a>
</li>

<li>Better OCaml (Online prostředí)<br />
<a href="https://betterocaml.ml/?version=4.14.0">https://betterocaml.ml/?version=4.14.0</a>
</li>

<li>OCaml file extensions<br />
<a href="https://blog.waleedkhan.name/ocaml-file-extensions/">https://blog.waleedkhan.name/ocaml-file-extensions/</a>
</li>

<li>First thoughts on Rust vs OCaml<br />
<a href="https://blog.darklang.com/first-thoughts-on-rust-vs-ocaml/">https://blog.darklang.com/first-thoughts-on-rust-vs-ocaml/</a>
</li>

<li>Standard ML of New Jersey<br />
<a href="https://www.smlnj.org/">https://www.smlnj.org/</a>
</li>

<li>Programming Languages: Standard ML - 1 (a navazující videa)<br />
<a href="https://www.youtube.com/watch?v=2sqjUWGGzTo">https://www.youtube.com/watch?v=2sqjUWGGzTo</a>
</li>

<li>6 Excellent Free Books to Learn Standard ML<br />
<a href="https://www.linuxlinks.com/excellent-free-books-learn-standard-ml/">https://www.linuxlinks.com/excellent-free-books-learn-standard-ml/</a>
</li>

<li>SOSML: The Online Interpreter for Standard ML<br />
<a href="https://sosml.org/">https://sosml.org/</a>
</li>

<li>ML (Computer program language)<br />
<a href="https://www.barnesandnoble.com/b/books/other-programming-languages/ml-computer-program-language/_/N-29Z8q8Zvy7">https://www.barnesandnoble.com/b/books/other-programming-languages/ml-computer-program-language/_/N-29Z8q8Zvy7</a>
</li>

<li>Strong Typing<br />
<a href="https://perl.plover.com/yak/typing/notes.html">https://perl.plover.com/yak/typing/notes.html</a>
</li>

<li>What to know before debating type systems<br />
<a href="http://blogs.perl.org/users/ovid/2010/08/what-to-know-before-debating-type-systems.html">http://blogs.perl.org/users/ovid/2010/08/what-to-know-before-debating-type-systems.html</a>
</li>

<li>Types, and Why You Should Care (Youtube)<br />
<a href="https://www.youtube.com/watch?v=0arFPIQatCU">https://www.youtube.com/watch?v=0arFPIQatCU</a>
</li>

<li>DynamicTyping (Martin Fowler)<br />
<a href="https://www.martinfowler.com/bliki/DynamicTyping.html">https://www.martinfowler.com/bliki/DynamicTyping.html</a>
</li>

<li>DomainSpecificLanguage (Martin Fowler)<br />
<a href="https://www.martinfowler.com/bliki/DomainSpecificLanguage.html">https://www.martinfowler.com/bliki/DomainSpecificLanguage.html</a>
</li>

<li>Language Workbenches: The Killer-App for Domain Specific Languages?<br />
<a href="https://www.martinfowler.com/articles/languageWorkbench.html">https://www.martinfowler.com/articles/languageWorkbench.html</a>
</li>

<li>Effective ML (Youtube)<br />
<a href="https://www.youtube.com/watch?v=-J8YyfrSwTk">https://www.youtube.com/watch?v=-J8YyfrSwTk</a>
</li>

<li>Why OCaml (Youtube)<br />
<a href="https://www.youtube.com/watch?v=v1CmGbOGb2I">https://www.youtube.com/watch?v=v1CmGbOGb2I</a>
</li>

<li>Try OCaml<br />
<a href="https://try.ocaml.pro/">https://try.ocaml.pro/</a>
</li>

<li>CSE 341: Functions and patterns<br />
<a href="https://courses.cs.washington.edu/courses/cse341/04wi/lectures/03-ml-functions.html">https://courses.cs.washington.edu/courses/cse341/04wi/lectures/03-ml-functions.html</a>
</li>

<li>Comparing Objective Caml and Standard ML<br />
<a href="http://adam.chlipala.net/mlcomp/">http://adam.chlipala.net/mlcomp/</a>
</li>

<li>What are the key differences between Standard ML and OCaml?<br />
<a href="https://www.quora.com/What-are-the-key-differences-between-Standard-ML-and-OCaml?share=1">https://www.quora.com/What-are-the-key-differences-between-Standard-ML-and-OCaml?share=1</a>
</li>

<li>Cheat Sheets (pro OCaml)<br />
<a href="https://www.ocaml.org/docs/cheat_sheets.html">https://www.ocaml.org/docs/cheat_sheets.html</a>
</li>

<li>Think OCaml: How to Think Like a (Functional) Programmer<br />
<a href="https://www.greenteapress.com/thinkocaml/thinkocaml.pdf">https://www.greenteapress.com/thinkocaml/thinkocaml.pdf</a>
</li>

<li>The OCaml Language Cheat Sheet<br />
<a href="https://ocamlpro.github.io/ocaml-cheat-sheets/ocaml-lang.pdf">https://ocamlpro.github.io/ocaml-cheat-sheets/ocaml-lang.pdf</a>
</li>

<li>Syllabus (FAS CS51)<br />
<a href="https://cs51.io/college/syllabus/">https://cs51.io/college/syllabus/</a>
</li>

<li>Abstraction and Design In Computation<br />
<a href="http://book.cs51.io/">http://book.cs51.io/</a>
</li>

<li>Learn X in Y minutes Where X=Standard ML<br />
<a href="https://learnxinyminutes.com/docs/standard-ml/">https://learnxinyminutes.com/docs/standard-ml/</a>
</li>

<li>CSE307 Online - Summer 2018: Principles of Programing Languages course<br />
<a href="https://www3.cs.stonybrook.edu/~pfodor/courses/summer/cse307.html">https://www3.cs.stonybrook.edu/~pfodor/courses/summer/cse307.html</a>
</li>

<li>CSE307 Principles of Programming Languages course: SML part 1<br />
<a href="https://www.youtube.com/watch?v=p1n0_PsM6hw">https://www.youtube.com/watch?v=p1n0_PsM6hw</a>
</li>

<li>CSE 307 &ndash; Principles of Programming Languages &ndash; SML<br />
<a href="https://www3.cs.stonybrook.edu/~pfodor/courses/summer/CSE307/L01_SML.pdf">https://www3.cs.stonybrook.edu/~pfodor/courses/summer/CSE307/L01_SML.pdf</a>
</li>

<li>History of programming languages<br />
<a href="https://devskiller.com/history-of-programming-languages/">https://devskiller.com/history-of-programming-languages/</a>
</li>

<li>History of programming languages (Wikipedia)<br />
<a href="https://en.wikipedia.org/wiki/History_of_programming_languages">https://en.wikipedia.org/wiki/History_of_programming_languages</a>
</li>

<li>The Evolution Of Programming Languages<br />
<a href="https://www.i-programmer.info/news/98-languages/8809-the-evolution-of-programming-languages.html">https://www.i-programmer.info/news/98-languages/8809-the-evolution-of-programming-languages.html</a>
</li>

<li>Evoluce programovacích jazyků<br />
<a href="https://ccrma.stanford.edu/courses/250a-fall-2005/docs/ComputerLanguagesChart.png">https://ccrma.stanford.edu/courses/250a-fall-2005/docs/ComputerLanguagesChart.png</a>
</li>

<li>Currying<br />
<a href="https://sw-samuraj.cz/2011/02/currying/">https://sw-samuraj.cz/2011/02/currying/</a>
</li>

<li>Currying (Wikipedia)<br />
<a href="https://en.wikipedia.org/wiki/Currying">https://en.wikipedia.org/wiki/Currying</a>
</li>

<li>Currying (Haskell wiki)<br />
<a href="https://wiki.haskell.org/Currying">https://wiki.haskell.org/Currying</a>
</li>

<li>Haskell Curry<br />
<a href="https://en.wikipedia.org/wiki/Haskell_Curry">https://en.wikipedia.org/wiki/Haskell_Curry</a>
</li>

<li>Moses Schönfinkel<br />
<a href="https://en.wikipedia.org/wiki/Moses_Sch%C3%B6nfinkel">https://en.wikipedia.org/wiki/Moses_Sch%C3%B6nfinkel</a>
</li>

<li>So You Want to be a Functional Programmer (Part 1)<br />
<a href="https://cscalfani.medium.com/so-you-want-to-be-a-functional-programmer-part-1-1f15e387e536">https://cscalfani.medium.com/so-you-want-to-be-a-functional-programmer-part-1-1f15e387e536</a>
</li>

<li>So You Want to be a Functional Programmer (Part 2)<br />
<a href="https://cscalfani.medium.com/so-you-want-to-be-a-functional-programmer-part-2-7005682cec4a">https://cscalfani.medium.com/so-you-want-to-be-a-functional-programmer-part-2-7005682cec4a</a>
</li>

<li>So You Want to be a Functional Programmer (Part 3)<br />
<a href="https://cscalfani.medium.com/so-you-want-to-be-a-functional-programmer-part-3-1b0fd14eb1a7">https://cscalfani.medium.com/so-you-want-to-be-a-functional-programmer-part-3-1b0fd14eb1a7</a>
</li>

<li>So You Want to be a Functional Programmer (Part 4)<br />
<a href="https://cscalfani.medium.com/so-you-want-to-be-a-functional-programmer-part-4-18fbe3ea9e49">https://cscalfani.medium.com/so-you-want-to-be-a-functional-programmer-part-4-18fbe3ea9e49</a>
</li>

<li>So You Want to be a Functional Programmer (Part 5)<br />
<a href="https://cscalfani.medium.com/so-you-want-to-be-a-functional-programmer-part-5-c70adc9cf56a">https://cscalfani.medium.com/so-you-want-to-be-a-functional-programmer-part-5-c70adc9cf56a</a>
</li>

<li>So You Want to be a Functional Programmer (Part 6)<br />
<a href="https://cscalfani.medium.com/so-you-want-to-be-a-functional-programmer-part-6-db502830403">https://cscalfani.medium.com/so-you-want-to-be-a-functional-programmer-part-6-db502830403</a>
</li>

<li>Python to OCaml: Retrospective<br />
<a href="http://roscidus.com/blog/blog/2014/06/06/python-to-ocaml-retrospective/">http://roscidus.com/blog/blog/2014/06/06/python-to-ocaml-retrospective/</a>
</li>

<li>Why does Cambridge teach OCaml as the first programming language?<br />
<a href="https://www.youtube.com/watch?v=6APBx0WsgeQ">https://www.youtube.com/watch?v=6APBx0WsgeQ</a>
</li>

<li>OCaml and 7 Things You Need To Know About It In 2021 | Functional Programming | Caml<br />
<a href="https://www.youtube.com/watch?v=s0itOsgcf9Q">https://www.youtube.com/watch?v=s0itOsgcf9Q</a>
</li>

<li>OCaml 2021 - 25 years of OCaml<br />
<a href="https://www.youtube.com/watch?v=-u_zKPXj6mw">https://www.youtube.com/watch?v=-u_zKPXj6mw</a>
</li>

<li>Introduction | OCaml Programming | Chapter 1 Video 1<br />
<a href="https://www.youtube.com/watch?v=MUcka_SvhLw&amp;list=PLre5AT9JnKShBOPeuiD9b-I4XROIJhkIU">https://www.youtube.com/watch?v=MUcka_SvhLw&amp;list=PLre5AT9JnKShBOPeuiD9b-I4XROIJhkIU</a>
</li>

<li>Functional Programming - What | OCaml Programming | Chapter 1 Video 2<br />
<a href="https://www.youtube.com/watch?v=JTEwC3HihFc&amp;list=PLre5AT9JnKShBOPeuiD9b-I4XROIJhkIU&amp;index=2">https://www.youtube.com/watch?v=JTEwC3HihFc&amp;list=PLre5AT9JnKShBOPeuiD9b-I4XROIJhkIU&amp;index=2</a>
</li>

<li>Functional Programming - Why Part 1 | OCaml Programming | Chapter 1 Video 3<br />
<a href="https://www.youtube.com/watch?v=SKr3ItChPSI&amp;list=PLre5AT9JnKShBOPeuiD9b-I4XROIJhkIU&amp;index=3">https://www.youtube.com/watch?v=SKr3ItChPSI&amp;list=PLre5AT9JnKShBOPeuiD9b-I4XROIJhkIU&amp;index=3</a>
</li>

<li>Functional Programming - Why Part 2 | OCaml Programming | Chapter 1 Video 4<br />
<a href="https://www.youtube.com/watch?v=eNLm5Xbgmd0&amp;list=PLre5AT9JnKShBOPeuiD9b-I4XROIJhkIU&amp;index=4">https://www.youtube.com/watch?v=eNLm5Xbgmd0&amp;list=PLre5AT9JnKShBOPeuiD9b-I4XROIJhkIU&amp;index=4</a>
</li>

<li>OCaml | OCaml Programming | Chapter 1 Video 5<br />
<a href="https://www.youtube.com/watch?v=T-DIW1dhYzo&amp;list=PLre5AT9JnKShBOPeuiD9b-I4XROIJhkIU&amp;index=5">https://www.youtube.com/watch?v=T-DIW1dhYzo&amp;list=PLre5AT9JnKShBOPeuiD9b-I4XROIJhkIU&amp;index=5</a>
</li>

<li>Five Aspects of Learning a Programming Language | OCaml Programming | Chapter 2 Video 1<br />
<a href="https://www.youtube.com/watch?v=A5IHFZtRfBs&amp;list=PLre5AT9JnKShBOPeuiD9b-I4XROIJhkIU&amp;index=6">https://www.youtube.com/watch?v=A5IHFZtRfBs&amp;list=PLre5AT9JnKShBOPeuiD9b-I4XROIJhkIU&amp;index=6</a>
</li>

<li>Expressions | OCaml Programming | Chapter 2 Video 2<br />
<a href="https://www.youtube.com/watch?v=3fzrFY-2ZQ8&amp;list=PLre5AT9JnKShBOPeuiD9b-I4XROIJhkIU&amp;index=7">https://www.youtube.com/watch?v=3fzrFY-2ZQ8&amp;list=PLre5AT9JnKShBOPeuiD9b-I4XROIJhkIU&amp;index=7</a>
</li>

<li>If Expressions | OCaml Programming | Chapter 2 Video 3<br />
<a href="https://www.youtube.com/watch?v=XJ6QPtlPD7s&amp;list=PLre5AT9JnKShBOPeuiD9b-I4XROIJhkIU&amp;index=8">https://www.youtube.com/watch?v=XJ6QPtlPD7s&amp;list=PLre5AT9JnKShBOPeuiD9b-I4XROIJhkIU&amp;index=8</a>
</li>

<li>Let Definitions | OCaml Programming | Chapter 2 Video 4<br />
<a href="https://www.youtube.com/watch?v=eRnG4gwOTlI&amp;list=PLre5AT9JnKShBOPeuiD9b-I4XROIJhkIU&amp;index=10">https://www.youtube.com/watch?v=eRnG4gwOTlI&amp;list=PLre5AT9JnKShBOPeuiD9b-I4XROIJhkIU&amp;index=10</a>
</li>

<li>Let Expressions | OCaml Programming | Chapter 2 Video 5<br />
<a href="https://www.youtube.com/watch?v=ug3L97FXC6A&amp;list=PLre5AT9JnKShBOPeuiD9b-I4XROIJhkIU&amp;index=10">https://www.youtube.com/watch?v=ug3L97FXC6A&amp;list=PLre5AT9JnKShBOPeuiD9b-I4XROIJhkIU&amp;index=10</a>
</li>

<li>Variable Expressions and Scope | OCaml Programming | Chapter 2 Video 6<br />
<a href="https://www.youtube.com/watch?v=_TpTC6eo34M&amp;list=PLre5AT9JnKShBOPeuiD9b-I4XROIJhkIU&amp;index=11">https://www.youtube.com/watch?v=_TpTC6eo34M&amp;list=PLre5AT9JnKShBOPeuiD9b-I4XROIJhkIU&amp;index=11</a>
</li>

<li>Scope and the Toplevel | OCaml Programming | Chapter 2 Video 7<br />
<a href="https://www.youtube.com/watch?v=4SqMkUwakEA&amp;list=PLre5AT9JnKShBOPeuiD9b-I4XROIJhkIU&amp;index=12">https://www.youtube.com/watch?v=4SqMkUwakEA&amp;list=PLre5AT9JnKShBOPeuiD9b-I4XROIJhkIU&amp;index=12</a>
</li>

<li>Anonymous Functions | OCaml Programming | Chapter 2 Video 8<br />
<a href="https://www.youtube.com/watch?v=JwoIIrj0bcM&amp;list=PLre5AT9JnKShBOPeuiD9b-I4XROIJhkIU&amp;index=13">https://www.youtube.com/watch?v=JwoIIrj0bcM&amp;list=PLre5AT9JnKShBOPeuiD9b-I4XROIJhkIU&amp;index=13</a>
</li>

<li>Lambdas | OCaml Programming | Chapter 2 Video 9<br />
<a href="https://www.youtube.com/watch?v=zHHCD7MOjmw&amp;list=PLre5AT9JnKShBOPeuiD9b-I4XROIJhkIU&amp;index=15">https://www.youtube.com/watch?v=zHHCD7MOjmw&amp;list=PLre5AT9JnKShBOPeuiD9b-I4XROIJhkIU&amp;index=15</a>
</li>

</ol>



<p></p><p></p>
<p><small>Autor: <a href="http://www.fit.vutbr.cz/~tisnovpa">Pavel Tišnovský</a> &nbsp; 2023</small></p>
</body>
</html>

