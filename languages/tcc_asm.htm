<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
        "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html>
<head>
<title>TinyCC Assembler: assembler, jenž je součástí Tiny C Compileru</title>
<meta name="Author" content="Pavel Tisnovsky" />
<meta name="Generator" content="vim" />
<meta http-equiv="content-type" content="text/html; charset=utf-8" />
<style type="text/css">
         body {color:#000000; background:#ffffff;}
         h1  {font-family: arial, helvetica, sans-serif; color:#ffffff; background-color:#c00000; text-align:center; padding-left:1em}
         h2  {font-family: arial, helvetica, sans-serif; color:#ffffff; background-color:#0000c0; padding-left:1em; text-align:left}
         h3  {font-family: arial, helvetica, sans-serif; color:#000000; background-color:#c0c0c0; padding-left:1em; text-align:left}
         h4  {font-family: arial, helvetica, sans-serif; color:#000000; background-color:#e0e0e0; padding-left:1em; text-align:left}
         a   {font-family: arial, helvetica, sans-serif;}
         li  {font-family: arial, helvetica, sans-serif; color:#000000; text-align:justify; width:450px;}
         ol  {font-family: arial, helvetica, sans-serif; color:#000000; text-align:justify; width:450px;}
         ul  {font-family: arial, helvetica, sans-serif; color:#000000; text-align:justify; width:450px;}
         p   {font-family: arial, helvetica, sans-serif; color:#000000; text-align:justify;}
         pre {background:#e0e0e0}
</style>
</head>

<body>

<h1>TinyCC Assembler: assembler, jenž je součástí Tiny C Compileru</h1>

<h3>Pavel Tišnovský</h3>

<p></p>

<h1>Úvodník</h1>

<p>Na článek Minimalistické překladače jazyka C: tcc a Chibicc, v němž jsme si mj. popsali překladač Tiny C Compiler, dnes navážeme. Tento překladač totiž obsahuje i vlastní assembler nazvaný TinyCC Assembler, který se podobná známému GNU Assembleru.</p>



<h2>Obsah</h2>

<p><a href="#k01">1. TinyCC Assembler: assembler, jenž je součástí Tiny C Compileru</a></p>
<p><a href="#k02">2. Assembler (jazyk symbolických adres)</a></p>
<p><a href="#k03">3. Použití assembleru v&nbsp;praxi</a></p>
<p><a href="#k04">4. Assemblery v&nbsp;Linuxu</a></p>
<p><a href="#k05">5. Assembler vestavěný to Tiny C Compileru (TinyCC Assembler)</a></p>
<p><a href="#k06">6. &bdquo;Hello, world!&ldquo; naprogramovaný v&nbsp;assembleru</a></p>
<p><a href="#k07">7. Volání funkcí kernelu na architektuře x86-64</a></p>
<p><a href="#k08">8. Porovnání výsledného programu: GNU Assembler vs TinyCC Assembler</a></p>
<p><a href="#k09">9. Výsledky překladu a slinkování</a></p>
<p><a href="#k10">10. Interní struktura souborů vzniklých překladem pomocí GNU Assembleru a GNU linkeru</a></p>
<p><a href="#k11">11. Interní struktura souborů vzniklých překladem pomocí TinyCC Assembleru</a></p>
<p><a href="#k12">*** 12. Detekce chyb ve zdrojových kódech psaných v&nbsp;assembleru</a></p>
<p><a href="#k13">*** 13. Reakce na zápis neexistující instrukce</a></p>
<p><a href="#k14">*** 14. Využití céčkovského preprocesoru</a></p>
<p><a href="#k15">*** 15. Kombinace assembleru a kódu v&nbsp;C v&nbsp;jediném zdrojovém souboru</a></p>
<p><a href="#k16">*** 16. Závěr</a></p>
<p><a href="#k17">*** 17. Repositář s&nbsp;demonstračními příklady</a></p>
<p><a href="#k18">18. Odkazy na Internetu</a></p>



<p><a name="k01"></a></p>
<h2 id="k01">1. TinyCC Assembler: assembler, jenž je součástí Tiny C Compileru</h2>

<p>Minulý týden jsme se v&nbsp;článku <a
href="https://www.root.cz/clanky/minimalisticke-prekladace-jazyka-c-tcc-a-chibicc/">Minimalistické
překladače jazyka C: tcc a Chibicc</a> seznámili mj.&nbsp;i se základními
vlastnostmi &bdquo;malého&ldquo; překladače programovacího jazyka C, který se
nazývá <i>Tiny C Compiler</i>. Připomeňme si, že předností tohoto překladače je
jeho vysoká rychlost překladu v&nbsp;porovnání s&nbsp;GCC či Clangem. Na druhou
stranu však Tiny C Compiler postrádá kvalitní optimalizaci výsledného
strojového kódu. Dnes si popíšeme ještě jednu další užitečnou součást Tiny C
Compileru. Tento překladač totiž obsahuje i assembler, který se nazývá
<i>TinyCC Assembler</i> (CC je často používaná zkratka pro &bdquo;C
compiler&ldquo;). <i>TinyCC Assembler</i> je do určité míry kompatibilní
s&nbsp;GNU Assemblerem a opět se jedná o velmi rychlý nástroj. Navíc je možné
TinyCC Assembler použít i pro &bdquo;assembling&ldquo; kódů, které vzniknou
preprocessingem s&nbsp;využitím klasického preprocesoru z&nbsp;jazyka C (což si
taktéž ukážeme). A navíc Tiny C podporuje i vkládání subrutin v&nbsp;assembleru
přímo do céčkového kódu.</p>



<p><a name="k02"></a></p>
<h2 id="k02">2. Assembler (jazyk symbolických adres)</h2>

<p>Naprostá většina programovacích jazyků, které se používají
v&nbsp;současnosti, patří mezi takzvané vysokoúrovňové jazyky, což
mj.&nbsp;znamená, že zdrojové kódy programů se v&nbsp;nich zapisují
s&nbsp;využitím takových jazykových konstrukcí, které mikroprocesor nedokáže
vykonat přímo. Aby bylo možné programy vytvořené například v&nbsp;jazyku Python
či v&nbsp;klasickém céčku skutečně spustit, je nutné je nějakým způsobem
transformovat do podoby, které již mikroprocesor dokáže provést. Výsledná
(transformovaná) podoba programu se nazývá <i>strojový kód (machine code)</i> a
pro zmíněnou transformaci se používají interpretry (což je případ jazyka
Python, Perl, Ruby, BASHe atd.) nebo překladače (případ programovacího jazyka
C, Go, Rustu).</p>

<p>V&nbsp;některých specifických situacích, zejména při programování
mikrořadičů, však může být vhodnější vytvářet programy či jejich části
v&nbsp;nízkoúrovňovém jazyku, který se přibližuje strojovému kódu. Důvodem může
být snaha o vytvoření co nejrychlejšího a/nebo co nejmenšího programového kódu,
popř.&nbsp;o přímý přístup k&nbsp;hardware (<i>bit banging</i>).</p>

<p>Vzhledem k&nbsp;tomu, že přímý zápis strojového kódu je pracný, náchylný
k&nbsp;chybám a prakticky dlouhodobě neudržovatelný, používá se poněkud odlišný
přístup &ndash; použití takzvaného <i>assembleru</i>. Assembler neboli též
<i>jazyk symbolických adres (JSA)</i> popř.&nbsp;alternativně <i>jazyk
symbolických instrukcí (JSI)</i> je nízkoúrovňovým programovacím jazykem, který
na hierarchii jazyků sice stojí poměrně vysoko nad strojovým kódem, ovšem na
straně druhé je umístěn hluboko pod vyššími kompilovanými programovacími jazyky
typu C či interpretovanými jazyky typu Python. Typickou vlastností assembleru
je jeho vazba na určitý typ mikroprocesoru popř.&nbsp;řadu mikroprocesorů
(architekturu). Týká se to především sady dostupných instrukcí. Programy se ve
většině typech assemblerů zapisují formou symbolických jmen instrukcí, přičemž
každá instrukce je představována svou mnemotechnickou zkratkou a případnými
operandy (konstantami, adresami, nepřímými adresami, jmény pracovních registrů
procesoru atd.).</p>



<p><a name="k03"></a></p>
<h2 id="k03">3. Použití assembleru v&nbsp;praxi</h2>

<p>Programování v&nbsp;jazyku symbolických adres již v&nbsp;současnosti není
(zcela podle očekávání) nijak masivní záležitostí, a to především z&nbsp;toho
důvodu, že tvorba aplikací ve vyšších programovacích jazycích je
v&nbsp;porovnání s&nbsp;assemblerem mnohem (mnohdy o jeden až dva řády)
rychlejší, aplikace jsou snáze přenositelné na jiné platformy a změna aplikací,
tj.&nbsp;přidávání nových vlastností či jejich refaktoring, je ve vyšších
programovacích jazycích významně jednodušší. Nesmíme taktéž zapomenout na to,
že díky vývoji překladačů vyšších programovacích jazyků se běžně stává, že
například algoritmus zapsaný v&nbsp;programovacím jazyku C může co do rychlosti
snadno soutěžit s&nbsp;programem napsaným průměrným programátorem
v&nbsp;assembleru. I přesto má assembler stále má své nezastupitelné místo, a
to jak při zkoumání systémových volání v&nbsp;Linuxu a programování speciálního
SW (části ovladačů, multimediální kodeky, některé kritické algoritmy typu FFT).
V&nbsp;neposlední řadě se díky použití assembleru můžeme seznámit
s&nbsp;principem funkce mikroprocesoru.</p>

<p><i>Assemblery</i> za sebou mají velmi dlouhý vývoj, protože první nástroje,
které se začaly tímto názvem označovat, vznikly již v&nbsp;padesátých letech
minulého století, a to na <i>mainframech</i> vyráběných společností IBM i
jejími konkurenty (UNIVAC, Burroughs, Honeywell, General Electric atd.). Před
vznikem skutečných assemblerů byla situace poněkud složitá. První aplikace pro
mainframy totiž byly programovány přímo ve strojovém kódu, který bylo možné
přímo zadávat z&nbsp;takzvaného <i>řídicího panelu (control panel)</i> počítače
či načítat z&nbsp;externích paměťových médií (děrných štítků, magnetických
pásek atd.). Ovšem zapisovat programy přímo ve strojovém kódu je zdlouhavé,
vedoucí k&nbsp;častým chybám a pro větší aplikace z&nbsp;mnoha důvodů
nepraktické. Z&nbsp;důvodu usnadnění práce programátorů tedy vznikly první
utility, jejichž úkolem bylo transformovat programy zapsané s&nbsp;využitím
symbolických jmen strojových instrukcí do (binárního) strojového kódu určeného
pro konkrétní typ počítače a jeho procesoru.</p>

<p>Těmto programům, jejichž možnosti se postupně vylepšovaly (například do nich
přibyla podpora textových maker, řízení víceprůchodového překladu, vytváření
výstupních sestav s&nbsp;překládanými symboly, později i skutečné linkování
s&nbsp;knihovnami atd.), se začalo říkat <i>assemblery</i> a jazyku určenému
pro symbolický zápis programů pak <i>jazyk symbolických instrukcí</i> či
<i>jazyk symbolických adres</i> &ndash; <i>assembly language</i> (někdy též
zkráceně nazývaný assembler, takže toto slovo má vlastně dodnes oba dva
významy). Jednalo se o svým způsobem převratnou myšlenku: sám počítač byl
použit pro tvorbu programů, čímž odpadla namáhavá práce s&nbsp;tužkou a
papírem. Posléze se zjistilo, že i programování přímo v&nbsp;assembleru je
většinou pracné a zdlouhavé, takže se na mainframech začaly používat různé
vyšší programovací jazyky, zejména FORTRAN a COBOL. Použití vyšších
programovacích jazyků bylo umožněno relativně vysokým výpočetním výkonem
mainframů i (opět relativně) velkou kapacitou operační paměti; naopak se díky
vyšším programovacím jazykům mohly aplikace přenášet na různé typy počítačů,
což je nesporná výhoda.</p>



<p><a name="k04"></a></p>
<h2 id="k04">4. Assemblery v&nbsp;Linuxu</h2>

<p>V&nbsp;tomto odstavci budeme pod termínem &bdquo;assembler&ldquo; chápat
programový nástroj, jenž je určený pro transformaci zdrojového kódu
naprogramovaného v&nbsp;jazyku symbolických adres do objektového kódu (ten je
nutné ještě slinkovat) nebo přímo do strojového kódu. Pro operační systém Linux
vzniklo hned několik takových nástrojů, přičemž některé nástroje jsou komerční
a jiné patří mezi open source. Z&nbsp;nekomerčních nástrojů se jedná o známý
<i>GNU Assembler</i>, dále pak o nástroj nazvaný <i>Netwide assembler
(NASM)</i>, nástroj <i>Yasm Modular Assembler</i> či až překvapivě výkonný
<i>vasm</i>. <i>NASM</i> a <i>Yasm</i> jsou pro první krůčky v&nbsp;assembleru
velmi dobře použitelné, neboť mají dobře zpracovaný mechanismus reakce na
chyby, dají se v&nbsp;nich psát čitelné programy atd.</p>

<p>Zásadní problém při snaze o použití <i>Netwide assembleru</i> či
<i>Yasmu</i> však nastává v&nbsp;případě, kdy je nutné vyvíjet aplikace určené
pro jinou architekturu, než je i386 či x86_64, a to z&nbsp;toho důvodu, že tyto
dva nástroje nedokážou pracovat s&nbsp;odlišnou instrukční sadou. Naproti tomu
<i>GNU Assembler</i> tímto problémem ani zdaleka netrpí, takže se
v&nbsp;následujícím textu s&nbsp;<i>GNU Assemblerem</i> ještě setkáme (a budeme
ho porovnávat s&nbsp;TinyCC Assemblerem).</p>

<p><i>GNU Assembler</i> (zkráceně jen <i>gas</i>) je součástí skupiny nástrojů
nazvaných <i>GNU Binutils</i>. Jedná se o nástroje určené pro vytváření a
správu binárních souborů obsahujících takzvaný &bdquo;objektový kód&ldquo;,
dále nástrojů určených pro práci s&nbsp;nativními knihovnami i pro takzvané
profilování (profilováním se testuje, ve které části programu se stráví nejvíce
času). Mezi nástroje spadající do <i>GNU Binutils</i> patří vedle <i>GNU
Assembleru</i> i linker <strong>ld</strong> (ten dnes použijeme), profiler
<strong>gprof</strong>, správce archivů strojových funkcí <strong>ar</strong>,
nástroj pro odstranění symbolů z&nbsp;objektových a spustitelných souborů
<strong>strip</strong> a několik pomocných utilit typu <strong>nm</strong>,
<strong>objdump</strong> (i ten dnes použijeme), <strong>size</strong> a
v&nbsp;neposlední řadě také <strong>strings</strong>.</p>

<p><i>GNU Assembler</i> je možné použít buď pro překlad uživatelem vytvořených
zdrojových kódů nebo pro zpracování kódů vygenerovaných překladači vyšších
programovacích jazyků (<strong>GCC</strong> atd.). Zajímavé je, že všechny
moderní verze <i>GNU Assembleru</i> podporují jak původní AT&amp;T syntaxi, tak
i (podle mnoha programátorů čitelnější) syntaxi používanou společností
Intel.</p>



<p><a name="k05"></a></p>
<h2 id="k05">5. Assembler vestavěný to Tiny C Compileru (TinyCC Assembler)</h2>

<p><a href="#k04">Výše zmíněný</a> GNU Assembler dnes porovnáme s&nbsp;TinyCC
Assemblerem, který je součástí Tiny C Compileru. Tento assembler do značné míry
podporuje stejnou syntaxi zápisu jako právě GNU Assembler (tedy AT&amp;T
syntaxi atd.). Pro překlad zdrojových programů v&nbsp;assembleru přímo do
výsledného spustitelného kódu se používá příkaz:</p>

<pre>
$ <strong>tcc assembly.s</strong>
</pre>

<p>Alternativně je možné nejprve na zdrojový kód aplikovat preprocesor
programovacího jazyka C. Potom volání assembleru vypadá nepatrně odlišně:</p>

<pre>
$ <strong>tcc assembly.S</strong>
</pre>

<p><div class="rs-tip-major">Poznámka: povšimněte si, že nyní koncovka ve jméně
souboru obsahuje &bdquo;.S&ldquo; a nikoli &bdquo;.s&ldquo;.</div></p>

<p>Navíc je možné část kódu v&nbsp;assembleru vložit přímo do céčkovského
zdrojového kódu, což je postup, který si ukážeme v&nbsp;navazujících
kapitolách.</p>



<p><a name="k06"></a></p>
<h2 id="k06">6. &bdquo;Hello, world!&ldquo; naprogramovaný v&nbsp;assembleru</h2>

<p>Pokusme se nyní v&nbsp;assembleru pro mikroprocesory s&nbsp;architekturou
x86-64 zapsat program, který na terminál vypíše zprávu &bdquo;Hello,
world!&ldquo; a následně se ukončí. Budeme tedy potřebovat realizovat dvě
operace:</p>

<ol>
<li>Výpis zprávy na terminál (tedy na STDOUT)</li>
<li>Ukončení procesu</li>
</ol>

<p>Vzhledem k&nbsp;tomu, že i ta nejjednodušší aplikace naprogramovaná
v&nbsp;assembleru musí nějakým způsobem ukončit svou činnost, je nutné buď
zavolat vhodnou knihovní funkci (z&nbsp;<strong>libc</strong>)
popř.&nbsp;použít takzvaný &bdquo;syscall&ldquo;. V&nbsp;kontextu operačního
systému Linux se pod tímto termínem skrývá volání nějaké funkce umístěné přímo
v&nbsp;jádru operačního systému.</p>

<p>V&nbsp;praxi to funguje následovně: podle požadavků konkrétní funkce se
naplní pracovní registry popř.&nbsp;datové struktury uložené v&nbsp;paměti,
následně se číslo služby uloží do pracovního registru <strong>r7</strong>
(32bitový ARM s&nbsp;použitím EABI) popř.&nbsp;<strong>x8</strong> (ARM64) a
následně se zavolá nějaká instrukce, která přepne kontext procesoru do
privilegovaného režimu &bdquo;jádra&ldquo; (vyvolá výjimku atd.). Na
procesorech s&nbsp;architekturou ARM32 je to instrukce <strong>SWI 0h</strong>
a u ARM64 instrukce <strong>SVC #0</strong>:</p>

<table>
<tr><th>Architektura</th><th>Číslo služby v</th><th>Instrukce pro syscall</th><th>Návratová hodnota v</th></tr>
<tr><td>ARM 32 s EABI</td><td>r7</td><td>SWI 0h</td><td>r0</td></tr>
<tr><td>ARM 64</td><td>x8</td><td>SVC #0</td><td>x0</td></tr>
<tr><td>i386</td><td>eax</td><td>INT 80h</td><td>eax</td></tr>
<tr><td>x86_64</td><td>rax</td><td>SYSCALL</td><td>rax</td></tr>
<tr><td>Motorola 68k</td><td>d0</td><td>TRAP #0</td><td>d0</td></tr>
</table>

<p>Programy, které si ukážeme a odladíme dnes, budou používat následující dvě
systémová volání (<i>syscally</i>):</p>

<table>
<tr><th>Syscall</th><th>Význam</th></tr>
<tr><td>sys_exit </td><td>ukončení procesu s&nbsp;předáním návratového kódu</td></tr>
<tr><td>sys_write</td><td>zápis přes deskriptor souboru (například do standardního výstupu)</td></tr>
</table>



<p><a name="k07"></a></p>
<h2 id="k07">7. Volání funkcí kernelu na architektuře x86-64</h2>

<p>Prvním programem, s&nbsp;nímž se dnes seznámíme, je program typu
&bdquo;Hello world!&ldquo; zmíněný <a href="#k06">v&nbsp;předchozí
kapitole</a>. Tento program je možné v&nbsp;assembleru procesorů řady x86-64
realizovat poměrně snadno, a to z&nbsp;toho důvodu, že samotné jádro operačního
systému obsahuje systémové volání (<i>syscall</i>) určené pro zápis sekvence
bajtů do souboru specifikovaného svým deskriptorem, což je konkrétně volání
<strong>sys_write</strong>, o kterém jsme se taktéž zmínili. My sice prozatím
neumíme v&nbsp;assembleru pracovat se soubory, to však vůbec nevadí, protože
pro každý nový proces jsou automaticky vytvořeny tři deskriptory: standardní
vstup, standardní výstup a chybový výstup. A právě standardní výstup použijeme
pro výpis řetězce &bdquo;Hello world!&ldquo;. Na 64bitovém systému vypadá
příslušný <i>syscall</i> takto:</p>

<table>
<tr><th>Registr</th><th>Význam</th><th>Obsah</th></tr>
<tr><td>rax</td><td>číslo syscallu</td><td>sys_write=1</td></tr>
<tr><td>rdi</td><td>číslo deskriptoru</td><td>stdout=1</td></tr>
<tr><td>rsi</td><td>adresa řetězce/bajtů</td><td>nastaví se do .text, .data atd. segmentu</td></tr>
<tr><td>rdx</td><td>počet bajtů pro zápis</td><td>strlen("Hello world!\n"), lze vypočítat při assemblingu</td></tr>
</table>

<p>A druhým voláním bude ukončení procesu. Zde je nutné naplnit registr
<strong>rax</strong> číslem syscallu a registr <strong>rdi</strong> návratovým
celočíselným kódem:</p>

<table>
<tr><th>Registr</th><th>Význam</th><th>Obsah</th></tr>
<tr><td>rax</td><td>číslo syscallu</td><td>sys_exit=60</td></tr>
<tr><td>rdi</td><td>návratový kód</td><td>0</td></tr>
</table>

<p><div class="rs-tip-major">Poznámka: čísla syscallů jsou na platformě x86-64
odlišná od syscallů na platformě x86! Pro x86-64 je naleznete na stránce <a
href="https://blog.rchapman.org/posts/Linux_System_Call_Table_for_x86_64/">https://blog.rchapman.org/posts/Linux_System_Call_Table_for_x86_64/</a>.</div></p>



<p><a name="k08"></a></p>
<h2 id="k08">8. Porovnání výsledného programu: GNU Assembler vs TinyCC Assembler</h2>

<p>Podívejme se nyní na to, jak bude vypadat zápis programu typu &bdquo;Hello
world!&ldquo; napsaný v&nbsp;GNU Assembleru ve variantě pro mikroprocesory
s&nbsp;architekturou x86-64. Celý program volá pouze dvě služby jádra zmíněné a
popsané výše: <strong>sys_write</strong> a <strong>sys_exit</strong>. U
<strong>sys_write</strong> se nastaví registry způsobem popsaným ve výše
uvedené tabulce (tedy číslo syscallu, adresu řetězce, délku řetězce a číslo
STDOUT). Z&nbsp;pohledu programátora je &bdquo;nejsložitější&ldquo; naplnění
registru <strong>rsi</strong>, protože ten musí obsahovat adresu řetězce
(resp.&nbsp;bloku bajtů). V&nbsp;AT&amp;T syntaxi to vypadá následovně:</p>

<pre>
mov  $message, %rsi        <i># adresa zpravy</i>
</pre>

<p>Přičemž <strong>message</strong> je jméno návěští (<i>label</i>) neboli
pojmenovaná adresa. Samotný řetězec může ležet buď v&nbsp;sekci
<strong>.data</strong> nebo i <strong>.text</strong> (což je kryptické označení
pro segment se strojovými instrukcemi). Povšimněte si, že řetězec není ukončen
znakem s&nbsp;ASCII kódem 0. To není nutné, protože systémová služba přesně zná
délku řetězce (bloku bajtů), na rozdíl od céčkovských funkcí, které naopak
hledají ukončující nulu. Navíc ihned poté vypočítáme délku řetězce jako rozdíl
mezi aktuální adresou (tečka) a adresou návěští <strong>message</strong>:</p>

<pre>
message:
        .ascii "Hello, world!\n"   <i># zprava, ktera se ma vypsat</i>
        length = . - message       <i># vypocet delky zpravy primo v prubehu preklad</i>
</pre>

<p><div class="rs-tip-major">Poznámka: tento výpočet je proveden při překladu
(assemblingu).</div></p>

<p>Úplný zdrojový kód vypadá následovně:</p>

<pre>
<i># asmsyntax=as</i>
&nbsp;
<i># Sablona pro zdrojovy kod Linuxoveho programu naprogramovaneho</i>
<i># v GNU assembleru (GAS).</i>
<i>#</i>
<i># Autor: Pavel Tisnovsky</i>
&nbsp;
&nbsp;
&nbsp;
<i># Linux kernel system call table</i>
sys_write = 1
sys_exit  = 60
&nbsp;
&nbsp;
.section .text
        .global _start             <i># tento symbol ma byt dostupny i linkeru</i>
&nbsp;
<strong>_start</strong>:
        mov  $sys_write, %rax      <i># cislo sycallu pro funkci "sys_write" na architekture x86-64</i>
        mov  $1, %rdi              <i># handle, 1 = STDOUT</i>
        mov  $message, %rsi        <i># adresa zpravy</i>
        mov  $length, %rdx         <i># delka zpravy</i>
        syscall                    <i># zavolat funkci Linuxoveho kernelu</i>
&nbsp;
        mov  $sys_exit, %rax       <i># cislo sycallu pro funkci "sys_exit" na architekture x86-64</i>
        mov  $0, %rdi              <i># exit code = 0</i>
        syscall                    <i># zavolat funkci Linuxoveho kernelu</i>
&nbsp;
<strong>message</strong>:
        .ascii "Hello, world!\n"   <i># zprava, ktera se ma vypsat</i>
        length = . - message       <i># vypocet delky zpravy primo v prubehu preklad</i>
</pre>

<p>Prakticky stejně bude vypadat kód upravený pro TinyCC Assembler. Pouze
(protože se slinkování provádí odlišně) zaměníme jméno symbolu
<strong>_start</strong> za <strong>main</strong>, což znamená, že vlastně
programujeme obdobu céčkovské funkce <strong>main</strong>:</p>

<pre>
<i># asmsyntax=as</i>
&nbsp;
<i># Sablona pro zdrojovy kod Linuxoveho programu naprogramovaneho</i>
<i># v assembleru tcc.</i>
<i>#</i>
<i># Autor: Pavel Tisnovsky</i>
&nbsp;
&nbsp;
&nbsp;
<i># Linux kernel system call table</i>
sys_write = 1
sys_exit  = 60
&nbsp;
&nbsp;
.section .text
        .global main               <i># tento symbol ma byt dostupny i linkeru</i>
&nbsp;
main:
        mov  $sys_write, %rax      <i># cislo sycallu pro funkci "sys_write" na architekture x86-64</i>
        mov  $1, %rdi              <i># handle, 1 = STDOUT</i>
        mov  $message, %rsi        <i># adresa zpravy</i>
        mov  $length, %rdx         <i># delka zpravy</i>
        syscall                    <i># zavolat funkci Linuxoveho kernelu</i>
&nbsp;
        mov  $sys_exit, %rax       <i># cislo sycallu pro funkci "sys_exit" na architekture x86-64</i>
        mov  $0, %rdi              <i># exit code = 0</i>
        syscall                    <i># zavolat funkci Linuxoveho kernelu</i>
&nbsp;
message:
        .ascii "Hello, world!\n"   <i># zprava, ktera se ma vypsat</i>
        length = . - message       <i># vypocet delky zpravy primo v prubehu preklad</i>
</pre>



<p><a name="k09"></a></p>
<h2 id="k09">9. Výsledky překladu a slinkování</h2>

<p>Překlad a slinkování s&nbsp;využitím GNU Assembleru provedeme příkazy:</p>

<pre>
$ <strong>as hello_world_x86_64_gas.s -o hello_world.o</strong>
$ <strong>ld -s hello_world.o</strong>
</pre>

<p>Výsledkem prvního příkazu bude soubor <strong>hello_world.o</strong> (který
je určený pro linker) a výsledkem druhého příkazu pak spustitelný soubor
<strong>a.out</strong>. Velikosti těchto souborů:</p>

<pre>
-rwxrwxr-x 1 ptisnovs ptisnovs 4368 Mar 23 16:54 a.out
-rw-rw-r-- 1 ptisnovs ptisnovs  984 Mar 23 16:54 hello_world.o
</pre>

<p>Soubor <strong>a.out</strong> můžeme spustit a zjistit, zda se skutečně
jedná o aplikaci typu &bdquo;Hello, world&ldquo;:</p>

<pre>
$ <strong>./a.out </strong>
&nbsp;
Hello, world!
</pre>

<p>Překlad a slinkování s&nbsp;využitím <i>TinyCC Assembleru</i> se provede
jediným příkazem:</p>

<pre>
$ <strong>tcc hello_world_x86_64_tcc.s</strong>
</pre>

<p>Výsledkem bude opět přímo spustitelný soubor <strong>a.out</strong>, který
je ovšem kratší:</p>

<pre>
-rwxrwxr-x 1 ptisnovs ptisnovs 2932 Mar 23 16:56 a.out
</pre>

<p>Opět si pro jistotu otestujme, že výsledný soubor je spustitelný a provádí
očekávanou činnost:</p>

<pre>
$ <strong>./a.out </strong>
&nbsp;
Hello, world!
</pre>



<p><a name="k10"></a></p>
<h2 id="k10">10. Interní struktura souborů vzniklých překladem pomocí GNU Assembleru a GNU linkeru</h2>

<p>Na interní obsah objektového souboru i výsledného spustitelného souboru se
můžeme podívat utilitkou <strong>objdump</strong>, a to následujícím
způsobem:</p>

<pre>
$ <strong>objdump -f -d -t -h jméno_souboru</strong>
</pre>

<p>Nejdříve se podívejme na objektový soubor <strong>hello_world.o</strong>
vygenerovaný GNU assemblerem po zadání příkazu:</p>

<pre>
$ <strong>as hello_world_x86_64_gas.s -o hello_world.o</strong>
</pre>

<p>Interní strukturu tohoto souboru si zobrazíme příkazem:</p>

<pre>
$ <strong>objdump -f -d -t -h hello_world.o</strong>
</pre>

<p>Výsledek by měl vypadat zhruba následovně:</p>

<pre>
hello_world.o:     file format elf64-x86-64
architecture: i386:x86-64, flags 0x00000011:
HAS_RELOC, HAS_SYMS
start address 0x0000000000000000
&nbsp;
Sections:
Idx Name          Size      VMA               LMA               File off  Algn
  0 .text         0000003c  0000000000000000  0000000000000000  00000040  2**0
                  CONTENTS, ALLOC, LOAD, RELOC, READONLY, CODE
  1 .data         00000000  0000000000000000  0000000000000000  0000007c  2**0
                  CONTENTS, ALLOC, LOAD, DATA
  2 .bss          00000000  0000000000000000  0000000000000000  0000007c  2**0
                  ALLOC
SYMBOL TABLE:
0000000000000000 l    d  .text  0000000000000000 .text
0000000000000000 l    d  .data  0000000000000000 .data
0000000000000000 l    d  .bss   0000000000000000 .bss
0000000000000001 l       *ABS*  0000000000000000 sys_write
000000000000003c l       *ABS*  0000000000000000 sys_exit
000000000000002e l       .text  0000000000000000 message
000000000000000e l       *ABS*  0000000000000000 length
0000000000000000 g       .text  0000000000000000 _start
&nbsp;
&nbsp;
&nbsp;
Disassembly of section .text:
&nbsp;
0000000000000000 &lt;_start&gt;:
   0:   48 c7 c0 01 00 00 00    mov    $0x1,%rax
   7:   48 c7 c7 01 00 00 00    mov    $0x1,%rdi
   e:   48 c7 c6 00 00 00 00    mov    $0x0,%rsi
  15:   48 c7 c2 0e 00 00 00    mov    $0xe,%rdx
  1c:   0f 05                   syscall 
  1e:   48 c7 c0 3c 00 00 00    mov    $0x3c,%rax
  25:   48 c7 c7 00 00 00 00    mov    $0x0,%rdi
  2c:   0f 05                   syscall 
&nbsp;
000000000000002e &lt;message&gt;:
  2e:   48                      rex.W
  2f:   65 6c                   gs insb (%dx),%es:(%rdi)
  31:   6c                      insb   (%dx),%es:(%rdi)
  32:   6f                      outsl  %ds:(%rsi),(%dx)
  33:   2c 20                   sub    $0x20,%al
  35:   77 6f                   ja     a6 &lt;sys_exit+0x6a&gt;
  37:   72 6c                   jb     a5 &lt;sys_exit+0x69&gt;
  39:   64 21 0a                and    %ecx,%fs:(%rdx)
</pre>

<p><div class="rs-tip-major">Poznámka: za návěštím &lt;message&gt; samozřejmě
následuje text zprávy, takže se nelekněte toho, že se i tuto sekvenci bajtů
snaží <strong>objdump</strong> reprezentovat formou instrukcí.</div></p>

<p>Pro zajímavost se pokusme zjistit, jak se liší struktura souboru
<strong>a.out</strong> vygenerovaného GNU linkerem:</p>

<pre>
a.out:     file format elf64-x86-64
architecture: i386:x86-64, flags 0x00000102:
EXEC_P, D_PAGED
start address 0x0000000000401000
&nbsp;
Sections:
Idx Name          Size      VMA               LMA               File off  Algn
  0 .text         0000003c  0000000000401000  0000000000401000  00001000  2**0
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
SYMBOL TABLE:
no symbols
&nbsp;
&nbsp;
&nbsp;
Disassembly of section .text:
&nbsp;
0000000000401000 &lt;.text&gt;:
  401000:       48 c7 c0 01 00 00 00    mov    $0x1,%rax
  401007:       48 c7 c7 01 00 00 00    mov    $0x1,%rdi
  40100e:       48 c7 c6 2e 10 40 00    mov    $0x40102e,%rsi
  401015:       48 c7 c2 0e 00 00 00    mov    $0xe,%rdx
  40101c:       0f 05                   syscall 
  40101e:       48 c7 c0 3c 00 00 00    mov    $0x3c,%rax
  401025:       48 c7 c7 00 00 00 00    mov    $0x0,%rdi
  40102c:       0f 05                   syscall 
  40102e:       48                      rex.W
  40102f:       65 6c                   gs insb (%dx),%es:(%rdi)
  401031:       6c                      insb   (%dx),%es:(%rdi)
  401032:       6f                      outsl  %ds:(%rsi),(%dx)
  401033:       2c 20                   sub    $0x20,%al
  401035:       77 6f                   ja     0x4010a6
  401037:       72 6c                   jb     0x4010a5
  401039:       64 21 0a                and    %ecx,%fs:(%rdx)
</pre>

<p><div class="rs-tip-major">Poznámka: povšimněte si, že některé informace již
nejsou plně&nbsp;dispozici (například návěští, která jsou běžně uložena
v&nbsp;tabulkách symbolů).</div></p>



<p><a name="k11"></a></p>
<h2 id="k11">11. Interní struktura souborů vzniklých překladem pomocí TinyCC Assembleru</h2>

<p>Stejným nástrojem, tj.&nbsp;využitím <strong>objdump</strong> si můžeme
prohlédnout i strukturu spustitelného souboru vygenerovaného s&nbsp;využitím
TinyCC Assembleru. Z&nbsp;výpisu bude patrné, že linker přidal větší množství
sekcí (většinou prázdných či jen minimální délky) a taktéž se kromě subrutiny
<strong>main</strong> (tu jsme naprogramovali my) objevila i subrutina
<strong>main-0x35</strong> umístěná na začátku segmentu <strong>.text</strong>
(linker tedy pracuje poměrně šablonovitě, ale to v&nbsp;praxi nevadí). Taktéž
si povšimněte sekcí <strong>.init</strong> a <strong>.fini</strong>:</p>

<pre>
a.out:     file format elf64-x86-64
architecture: i386:x86-64, flags 0x00000112:
EXEC_P, HAS_SYMS, D_PAGED
start address 0x0000000000400320
&nbsp;
Sections:
Idx Name          Size      VMA               LMA               File off  Algn
  0 .interp       0000001c  0000000000400158  0000000000400158  00000158  2**0
                  CONTENTS, ALLOC, LOAD, READONLY, DATA
  1 .dynsym       00000090  0000000000400174  0000000000400174  00000174  2**2
                  CONTENTS, ALLOC, LOAD, READONLY, DATA
  2 .dynstr       00000051  0000000000400204  0000000000400204  00000204  2**0
                  CONTENTS, ALLOC, LOAD, READONLY, DATA
  3 .hash         00000030  0000000000400258  0000000000400258  00000258  2**2
                  CONTENTS, ALLOC, LOAD, READONLY, DATA
  4 .rela.got     00000090  0000000000400288  0000000000400288  00000288  2**2
                  CONTENTS, ALLOC, LOAD, READONLY, DATA
  5 .text         000000f5  0000000000400320  0000000000400320  00000320  2**4
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  6 .rodata.cst4  00000004  0000000000400418  0000000000400418  00000418  2**2
                  CONTENTS, ALLOC, LOAD, READONLY, DATA
  7 .eh_frame     000000d8  0000000000400420  0000000000400420  00000420  2**3
                  CONTENTS, ALLOC, LOAD, READONLY, DATA
  8 .init         0000001b  00000000004004f8  00000000004004f8  000004f8  2**2
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  9 .fini         0000000d  0000000000400514  0000000000400514  00000514  2**2
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
 10 .preinit_array 00000000  0000000000400528  0000000000400528  00000528  2**3
                  CONTENTS, ALLOC, LOAD, READONLY, DATA
 11 .init_array   00000000  0000000000400528  0000000000400528  00000528  2**3
                  CONTENTS, ALLOC, LOAD, READONLY, DATA
 12 .fini_array   00000000  0000000000400528  0000000000400528  00000528  2**3
                  CONTENTS, ALLOC, LOAD, READONLY, DATA
 13 .data         00000004  0000000000600528  0000000000600528  00000528  2**3
                  CONTENTS, ALLOC, LOAD, DATA
 14 .dynamic      000000a0  000000000060052c  000000000060052c  0000052c  2**2
                  CONTENTS, ALLOC, LOAD, DATA
 15 .got          00000048  00000000006005d0  00000000006005d0  000005d0  2**3
                  CONTENTS, ALLOC, LOAD, DATA
 16 .bss          00000000  0000000000600618  0000000000600618  00000618  2**3
                  ALLOC
SYMBOL TABLE:
no symbols
&nbsp;
&nbsp;
&nbsp;
Disassembly of section .text:
&nbsp;
0000000000400320 &lt;main-0x35&gt;:
  400320:       f3 0f 1e fa             endbr64 
  400324:       31 ed                   xor    %ebp,%ebp
  400326:       49 89 d1                mov    %rdx,%r9
  400329:       5e                      pop    %rsi
  40032a:       48 89 e2                mov    %rsp,%rdx
  40032d:       48 83 e4 f0             and    $0xfffffffffffffff0,%rsp
  400331:       50                      push   %rax
  400332:       54                      push   %rsp
  400333:       4c 8b 05 ae 02 20 00    mov    0x2002ae(%rip),%r8        # 6005e8 &lt;__libc_csu_fini+0x2001d8&gt;
  40033a:       48 8b 0d af 02 20 00    mov    0x2002af(%rip),%rcx        # 6005f0 &lt;__libc_csu_fini+0x2001e0&gt;
  400341:       48 8b 3d b0 02 20 00    mov    0x2002b0(%rip),%rdi        # 6005f8 &lt;__libc_csu_fini+0x2001e8&gt;
  400348:       ff 15 b2 02 20 00       callq  *0x2002b2(%rip)        # 600600 &lt;__libc_csu_fini+0x2001f0&gt;
  40034e:       f4                      hlt    
  40034f:       90                      nop
  400350:       f3 0f 1e fa             endbr64 
  400354:       c3                      retq   
&nbsp;
0000000000400355 &lt;main&gt;:
  400355:       48 c7 c0 01 00 00 00    mov    $0x1,%rax
  40035c:       48 c7 c7 01 00 00 00    mov    $0x1,%rdi
  400363:       48 c7 c6 83 03 40 00    mov    $0x400383,%rsi
  40036a:       48 c7 c2 0e 00 00 00    mov    $0xe,%rdx
  400371:       0f 05                   syscall 
  400373:       48 c7 c0 3c 00 00 00    mov    $0x3c,%rax
  40037a:       48 c7 c7 00 00 00 00    mov    $0x0,%rdi
  400381:       0f 05                   syscall 
  400383:       48                      rex.W
  400384:       65 6c                   gs insb (%dx),%es:(%rdi)
  400386:       6c                      insb   (%dx),%es:(%rdi)
  400387:       6f                      outsl  %ds:(%rsi),(%dx)
  400388:       2c 20                   sub    $0x20,%al
  40038a:       77 6f                   ja     4003fb &lt;__libc_csu_init+0x5b&gt;
  40038c:       72 6c                   jb     4003fa &lt;__libc_csu_init+0x5a&gt;
  40038e:       64 21 0a                and    %ecx,%fs:(%rdx)
        ...
&nbsp;
00000000004003a0 &lt;__libc_csu_init&gt;:
  4003a0:       f3 0f 1e fa             endbr64 
  4003a4:       41 57                   push   %r15
  4003a6:       4c 8d 3d 7b 01 00 00    lea    0x17b(%rip),%r15        # 400528 &lt;__libc_csu_fini+0x118&gt;
  4003ad:       41 56                   push   %r14
  4003af:       49 89 d6                mov    %rdx,%r14
  4003b2:       41 55                   push   %r13
  4003b4:       49 89 f5                mov    %rsi,%r13
  4003b7:       41 54                   push   %r12
  4003b9:       41 89 fc                mov    %edi,%r12d
  4003bc:       55                      push   %rbp
  4003bd:       48 8d 2d 64 01 00 00    lea    0x164(%rip),%rbp        # 400528 &lt;__libc_csu_fini+0x118&gt;
  4003c4:       53                      push   %rbx
  4003c5:       4c 29 fd                sub    %r15,%rbp
  4003c8:       48 83 ec 08             sub    $0x8,%rsp
  4003cc:       e8 27 01 00 00          callq  4004f8 &lt;__libc_csu_fini+0xe8&gt;
  4003d1:       48 c1 fd 03             sar    $0x3,%rbp
  4003d5:       74 1f                   je     4003f6 &lt;__libc_csu_init+0x56&gt;
  4003d7:       31 db                   xor    %ebx,%ebx
  4003d9:       0f 1f 80 00 00 00 00    nopl   0x0(%rax)
  4003e0:       4c 89 f2                mov    %r14,%rdx
  4003e3:       4c 89 ee                mov    %r13,%rsi
  4003e6:       44 89 e7                mov    %r12d,%edi
  4003e9:       41 ff 14 df             callq  *(%r15,%rbx,8)
  4003ed:       48 83 c3 01             add    $0x1,%rbx
  4003f1:       48 39 dd                cmp    %rbx,%rbp
  4003f4:       75 ea                   jne    4003e0 &lt;__libc_csu_init+0x40&gt;
  4003f6:       48 83 c4 08             add    $0x8,%rsp
  4003fa:       5b                      pop    %rbx
  4003fb:       5d                      pop    %rbp
  4003fc:       41 5c                   pop    %r12
  4003fe:       41 5d                   pop    %r13
  400400:       41 5e                   pop    %r14
  400402:       41 5f                   pop    %r15
  400404:       c3                      retq   
  400405:       66 66 2e 0f 1f 84 00    data16 nopw %cs:0x0(%rax,%rax,1)
  40040c:       00 00 00 00 
&nbsp;
0000000000400410 &lt;__libc_csu_fini&gt;:
  400410:       f3 0f 1e fa             endbr64 
  400414:       c3                      retq   
&nbsp;
Disassembly of section .init:
&nbsp;
00000000004004f8 &lt;.init&gt;:
  4004f8:       f3 0f 1e fa             endbr64 
  4004fc:       48 83 ec 08             sub    $0x8,%rsp
  400500:       48 8b 05 09 01 20 00    mov    0x200109(%rip),%rax        # 600610 &lt;__gmon_start__&gt;
  400507:       48 85 c0                test   %rax,%rax
  40050a:       74 02                   je     40050e &lt;__libc_csu_fini+0xfe&gt;
  40050c:       ff d0                   callq  *%rax
  40050e:       48 83 c4 08             add    $0x8,%rsp
  400512:       c3                      retq   
&nbsp;
Disassembly of section .fini:
&nbsp;
0000000000400514 &lt;.fini&gt;:
  400514:       f3 0f 1e fa             endbr64 
  400518:       48 83 ec 08             sub    $0x8,%rsp
  40051c:       48 83 c4 08             add    $0x8,%rsp
  400520:       c3                      retq   
</pre>



<p><a name="k12"></a></p>
<h2 id="k12">12. Detekce chyb ve zdrojových kódech psaných v&nbsp;assembleru</h2>

<p></p>

<pre>
<i># Linux kernel system call table</i>
sys_write = 1
sys_exit  = 60
&nbsp;
&nbsp;
.section .text
        .global _start             <i># tento symbol ma byt dostupny i linkeru</i>
&nbsp;
_start:
        mov  $sys_write, %rax      <i># cislo sycallu pro funkci "sys_write" na architekture x86-64</i>
        mov  $1, %rdi              <i># handle, 1 = STDOUT</i>
        mov  $message_, %rsi       <i># adresa zpravy (spatny identifikator)</i>
        mov  $length, %rdx         <i># delka zpravy</i>
        syscall                    <i># zavolat funkci Linuxoveho kernelu</i>
&nbsp;
        mov  $sys_exit, %rax       <i># cislo sycallu pro funkci "sys_exit" na architekture x86-64</i>
        mov  $0, %rdi              <i># exit code = 0</i>
        syscall                    <i># zavolat funkci Linuxoveho kernelu</i>
&nbsp;
message:
        .ascii "Hello, world!\n"   <i># zprava, ktera se ma vypsat</i>
        length = . - message       <i># vypocet delky zpravy primo v prubehu preklad</i>
</pre>

<pre>
<i># Linux kernel system call table</i>
sys_write = 1
sys_exit  = 60
&nbsp;
&nbsp;
.section .text
        .global main               <i># tento symbol ma byt dostupny i linkeru</i>
&nbsp;
main:
        mov  $sys_write, %rax      <i># cislo sycallu pro funkci "sys_write" na architekture x86-64</i>
        mov  $1, %rdi              <i># handle, 1 = STDOUT</i>
        mov  $message_, %rsi       <i># adresa zpravy (spatny identifikator)</i>
        mov  $length, %rdx         <i># delka zpravy</i>
        syscall                    <i># zavolat funkci Linuxoveho kernelu</i>
&nbsp;
        mov  $sys_exit, %rax       <i># cislo sycallu pro funkci "sys_exit" na architekture x86-64</i>
        mov  $0, %rdi              <i># exit code = 0</i>
        syscall                    <i># zavolat funkci Linuxoveho kernelu</i>
&nbsp;
message:
        .ascii "Hello, world!\n"   <i># zprava, ktera se ma vypsat</i>
        length = . - message       <i># vypocet delky zpravy primo v prubehu preklad</i>
</pre>



<p><a name="k13"></a></p>
<h2 id="k13">13. Reakce na zápis neexistující instrukce</h2>

<pre>
<i># Linux kernel system call table</i>
sys_write = 1
sys_exit  = 60


.section .text
        .global _start             <i># tento symbol ma byt dostupny i linkeru</i>

_start:
        mov  $sys_write, %rax      <i># cislo sycallu pro funkci "sys_write" na architekture x86-64</i>
        mov  $1, %rdi              <i># handle, 1 = STDOUT</i>
        mov  $message, %rsi        <i># adresa zpravy</i>
        mvv  $length, %rdx         <i># delka zpravy (neznama instrukce)</i>
        syscall                    <i># zavolat funkci Linuxoveho kernelu</i>

        mov  $sys_exit, %rax       <i># cislo sycallu pro funkci "sys_exit" na architekture x86-64</i>
        mov  $0, %rdi              <i># exit code = 0</i>
        syscall                    <i># zavolat funkci Linuxoveho kernelu</i>

message:
        .ascii "Hello, world!\n"   <i># zprava, ktera se ma vypsat</i>
        length = . - message       <i># vypocet delky zpravy primo v prubehu preklad</i>
</pre>

<pre>
<i># Linux kernel system call table</i>
sys_write = 1
sys_exit  = 60


.section .text
        .global main               <i># tento symbol ma byt dostupny i linkeru</i>

main:
        mov  $sys_write, %rax      <i># cislo sycallu pro funkci "sys_write" na architekture x86-64</i>
        mov  $1, %rdi              <i># handle, 1 = STDOUT</i>
        mov  $message, %rsi        <i># adresa zpravy</i>
        mvv  $length, %rdx         <i># delka zpravy (neplatna instrukce)</i>
        syscall                    <i># zavolat funkci Linuxoveho kernelu</i>

        mov  $sys_exit, %rax       <i># cislo sycallu pro funkci "sys_exit" na architekture x86-64</i>
        mov  $0, %rdi              <i># exit code = 0</i>
        syscall                    <i># zavolat funkci Linuxoveho kernelu</i>

message:
        .ascii "Hello, world!\n"   <i># zprava, ktera se ma vypsat</i>
        length = . - message       <i># vypocet delky zpravy primo v prubehu preklad</i>
</pre>



<p><a name="k14"></a></p>
<h2 id="k14">14. Využití céčkovského preprocesoru</h2>

<pre>
sys_write = 1
sys_exit  = 60
</pre>

<pre>
<i># asmsyntax=as</i>

<i># Sablona pro zdrojovy kod Linuxoveho programu naprogramovaneho</i>
<i># v assembleru tcc.</i>
<i>#</i>
<i># Autor: Pavel Tisnovsky</i>



<i># Linux kernel system call table</i>
<strong>#include "syscalls.s"</strong>

<strong>#ifdef XYZZY</strong>
naprosto cizí text
naprosto cizí text
naprosto cizí text
<strong>#endif</strong>

.section .text
        .global main            <i># tento symbol ma byt dostupny i linkeru</i>

main:
        mov  $sys_write, %rax   <i># cislo sycallu pro funkci "write"</i>
        mov  $1, %rdi           <i># handle, 1 = STDOUT</i>
        mov  $message, %rsi     <i># adresa zpravy</i>
        mov  $length, %rdx      <i># delka zpravy</i>
        syscall

        mov  $sys_exit, %eax    <i># cislo sycallu pro funkci "exit"</i>
        mov  $0,%edi            <i># exit code = 0</i>
        syscall                 <i># volani Linuxoveho kernelu</i>

message:
        .ascii "Hello, world!\n"
        length = . - message
</pre>

<pre>
$ <strong></strong>
</pre>



<p><a name="k15"></a></p>
<h2 id="k15">15. Kombinace assembleru a kódu v&nbsp;C v&nbsp;jediném zdrojovém souboru</h2>



<p><a name="k16"></a></p>
<h2 id="k16">16. </h2>



<p><a name="k17"></a></p>
<h2 id="k17">17. Repositář s&nbsp;demonstračními příklady</h2>

<p>Všechny výše popsané demonstrační příklady byly uloženy do repositáře
dostupného na adrese <a
href="https://github.com/tisnik/presentations/">https://github.com/tisnik/presentations/</a>.
V&nbsp;tabulce umístěné pod tímto odstavcem jsou uvedeny odkazy na tyto
příklady:</p>

<table>
<tr><th>#</th><th>Příklad</th><th>Popis příkladu</th><th>Cesta</th></tr>
<tr><td>1</td><td>hello_world_x86_64_gas.s</td><td>program typu &bdquo;Hello, world!&ldquo; ve variantě pro GNU Assembler</td><td><a href="https://github.com/tisnik/presentations/tree/master/assembler/tcc/hello_world_x86_64_gas.s">https://github.com/tisnik/ocaml-examples/tree/master/assembler/tcc/hello_world_x86_64_gas.s</a></td></tr>
<tr><td>2</td><td>hello_world_x86_64_tcc.s</td><td>program typu &bdquo;Hello, world!&ldquo; ve variantě pro TinyCC Assembler</td><td><a href="https://github.com/tisnik/presentations/tree/master/assembler/tcc/hello_world_x86_64_tcc.s">https://github.com/tisnik/ocaml-examples/tree/master/assembler/tcc/hello_world_x86_64_tcc.s</a></td></tr>
<tr><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td></tr>
<tr><td>3</td><td>broken_gas_1.s</td><td>použití neplatného návěští (label) ve variantě pro GNU Assembler</td><td><a href="https://github.com/tisnik/presentations/tree/master/assembler/tcc/broken_gas_1.s">https://github.com/tisnik/ocaml-examples/tree/master/assembler/tcc/broken_gas_1.s</a></td></tr>
<tr><td>4</td><td>broken_gas_2.s</td><td>použití neplatné instrukce ve variantě pro GNU Assembler</td><td><a href="https://github.com/tisnik/presentations/tree/master/assembler/tcc/broken_gas_2.s">https://github.com/tisnik/ocaml-examples/tree/master/assembler/tcc/broken_gas_2.s</a></td></tr>
<tr><td>5</td><td>broken_tcc_1.s</td><td>použití neplatného návěští (label) ve variantě pro TinyCC Assembler</td><td><a href="https://github.com/tisnik/presentations/tree/master/assembler/tcc/broken_tcc_1.s">https://github.com/tisnik/ocaml-examples/tree/master/assembler/tcc/broken_tcc_1.s</a></td></tr>
<tr><td>6</td><td>broken_tcc_2.s</td><td>použití neplatné instrukce ve variantě pro TinyCC Assembler</td><td><a href="https://github.com/tisnik/presentations/tree/master/assembler/tcc/broken_tcc_2.s">https://github.com/tisnik/ocaml-examples/tree/master/assembler/tcc/broken_tcc_2.s</a></td></tr>
<tr><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td></tr>
<tr><td>7</td><td>preprocessor.S</td><td>využití možností poskytovaných preprocesorem programovacího jazyka C</td><td><a href="https://github.com/tisnik/presentations/tree/master/assembler/tcc/preprocessor.S">https://github.com/tisnik/ocaml-examples/tree/master/assembler/tcc/preprocessor.S</a></td></tr>
<tr><td>8</td><td>syscalls.s</td><td>soubor vkládaný pomocí <strong>#include</strong> do <strong>preprocessor.S</strong></td><td><a href="https://github.com/tisnik/presentations/tree/master/assembler/tcc/syscalls.s">https://github.com/tisnik/ocaml-examples/tree/master/assembler/tcc/syscalls.s</a></td></tr>
<tr><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td></tr>
<tr><td>9</td><td></td><td></td><td><a href="https://github.com/tisnik/presentations/tree/master/assembler/tcc/">https://github.com/tisnik/ocaml-examples/tree/master/assembler/tcc/</a></td></tr>
</table>



<p><a name="k18"></a></p>
<h2 id="k18">18. Odkazy na Internetu</h2>

<ol>

<li>Původní domovská stránka Tiny C Compileru<br />
<a href="https://bellard.org/tcc/">https://bellard.org/tcc/</a>
</li>

<li>Tiny C Compiler na Wikipedii<br />
<a href="https://en.wikipedia.org/wiki/Tiny_C_Compiler">https://en.wikipedia.org/wiki/Tiny_C_Compiler</a>
</li>

<li>TinyCC Assembler<br />
<a href="https://bellard.org/tcc/tcc-doc.html#asm">https://bellard.org/tcc/tcc-doc.html#asm</a>
</li>

<li>Repositář Tiny C Compileru<br />
<a href="https://repo.or.cz/w/tinycc.git">https://repo.or.cz/w/tinycc.git</a>
</li>

<li>Linux System Call Table for x86 64<br />
<a href="https://blog.rchapman.org/posts/Linux_System_Call_Table_for_x86_64/">https://blog.rchapman.org/posts/Linux_System_Call_Table_for_x86_64/</a>
</li>

<li>Bit banging<br />
<a href="https://en.wikipedia.org/wiki/Bit_banging">https://en.wikipedia.org/wiki/Bit_banging</a>
</li>

<li>Warnings Are Your Friend - A Code Quality Primer<br />
<a href="https://hackaday.com/2018/11/06/warnings-are-your-friend-a-code-quality-primer/">https://hackaday.com/2018/11/06/warnings-are-your-friend-a-code-quality-primer/</a>
</li>

<li>Defending Against Compiler-Based Backdoors<br />
<a href="https://blog.regehr.org/archives/1241">https://blog.regehr.org/archives/1241</a>
</li>

<li>Reflections on Trusting Trust<br />
<a href="https://www.win.tue.nl/~aeb/linux/hh/thompson/trust.html">https://www.win.tue.nl/~aeb/linux/hh/thompson/trust.html</a>
</li>

<li>Coding Machines (povídka)<br />
<a href="https://www.teamten.com/lawrence/writings/coding-machines/">https://www.teamten.com/lawrence/writings/coding-machines/</a>
</li>

<li>Stage0<br />
<a href="https://bootstrapping.miraheze.org/wiki/Stage0">https://bootstrapping.miraheze.org/wiki/Stage0</a>
</li>

<li>Projekt stage0 na GitHubu<br />
<a href="https://github.com/oriansj/stage0">https://github.com/oriansj/stage0</a>
</li>

<li>Bootstraping wiki<br />
<a href="https://bootstrapping.miraheze.org/wiki/Main_Page">https://bootstrapping.miraheze.org/wiki/Main_Page</a>
</li>

<li>Bootstrapped 6502 Assembler<br />
<a href="https://github.com/robinluckey/bootstrap-6502">https://github.com/robinluckey/bootstrap-6502</a>
</li>

<li>IBM Basic assembly language and successors (Wikipedia)<br />
<a href="https://en.wikipedia.org/wiki/IBM_Basic_assembly_language_and_successors">https://en.wikipedia.org/wiki/IBM_Basic_assembly_language_and_successors</a>
</li>

<li>X86 Assembly/Bootloaders<br />
<a href="https://en.wikibooks.org/wiki/X86_Assembly/Bootloaders">https://en.wikibooks.org/wiki/X86_Assembly/Bootloaders</a>
</li>

<li>run6502, lib6502 — 6502 microprocessor emulator<br />
<a href="http://piumarta.com/software/lib6502/">http://piumarta.com/software/lib6502/</a>
</li>

<li>Simple Computer Simulator Instruction-Set<br />
<a href="http://www.science.smith.edu/dftwiki/index.php/Simple_Computer_Simulator_Instruction-Set">http://www.science.smith.edu/dftwiki/index.php/Simple_Computer_Simulator_Instruction-Set</a>
</li>

<li>Bootstrapping#Computing (Wikipedia)<br />
<a href="https://en.wikipedia.org/wiki/Bootstrapping#Computing">https://en.wikipedia.org/wiki/Bootstrapping#Computing</a>
</li>

<li>Bootstrapping (compilers)<br />
<a href="https://en.wikipedia.org/wiki/Bootstrapping_%28compilers%29">https://en.wikipedia.org/wiki/Bootstrapping_%28compilers%29</a>
</li>

<li>Bootstrapable Builds<br />
<a href="http://bootstrappable.org/">http://bootstrappable.org/</a>
</li>

<li>What is a coder's worst nightmare?<br />
<a href="https://www.quora.com/What-is-a-coders-worst-nightmare/answer/Mick-Stute">https://www.quora.com/What-is-a-coders-worst-nightmare/answer/Mick-Stute</a>
</li>

<li>Linux Assembly<br />
<a href="http://asm.sourceforge.net/">http://asm.sourceforge.net/</a>
</li>

<li>Tombstone diagram (Wikipedia)<br />
<a href="https://en.wikipedia.org/wiki/Tombstone_diagram">https://en.wikipedia.org/wiki/Tombstone_diagram</a>
</li>

<li>History of compiler construction (Wikipedia)<br />
<a href="https://en.wikipedia.org/wiki/History_of_compiler_construction">https://en.wikipedia.org/wiki/History_of_compiler_construction</a>
</li>

<li>Self-hosting (Wikipedia)<br />
<a href="https://en.wikipedia.org/wiki/Self-hosting">https://en.wikipedia.org/wiki/Self-hosting</a>
</li>

<li>GNU Mes: Maxwell Equations of Software<br />
<a href="https://gitlab.com/janneke/mes">https://gitlab.com/janneke/mes</a>
</li>

<li>Tiny C Compiler<br />
<a href="https://bellard.org/tcc/">https://bellard.org/tcc/</a>
</li>

<li>Welcome to C--<br />
<a href="https://www.cs.tufts.edu/~nr/c--/index.html">https://www.cs.tufts.edu/~nr/c--/index.html</a>
</li>

<li>c4 - C in four functions<br />
<a href="https://github.com/rswier/c4">https://github.com/rswier/c4</a>
</li>

<li>Tiny BASIC (Wikipedia)<br />
<a href="https://en.wikipedia.org/wiki/Tiny_BASIC">https://en.wikipedia.org/wiki/Tiny_BASIC</a>
</li>

<li>ARM GCC Inline Assembler Cookbook<br />
<a href="http://www.ethernut.de/en/documents/arm-inline-asm.html">http://www.ethernut.de/en/documents/arm-inline-asm.html</a>
</li>

<li>Extended Asm - Assembler Instructions with C Expression Operands<br />
<a href="https://gcc.gnu.org/onlinedocs/gcc/Extended-Asm.html">https://gcc.gnu.org/onlinedocs/gcc/Extended-Asm.html</a>
</li>

<li>ARM inline asm secrets<br />
<a href="http://hardwarebug.org/2010/07/06/arm-inline-asm-secrets/">http://hardwarebug.org/2010/07/06/arm-inline-asm-secrets/</a>
</li>

<li>How to Use Inline Assembly Language in C Code<br />
<a href="https://gcc.gnu.org/onlinedocs/gcc/Using-Assembly-Language-with-C.html#Using-Assembly-Language-with-C">https://gcc.gnu.org/onlinedocs/gcc/Using-Assembly-Language-with-C.html#Using-Assembly-Language-with-C</a>
</li>

<li>GCC-Inline-Assembly-HOWTO<br />
<a href="http://ibiblio.org/gferg/ldp/GCC-Inline-Assembly-HOWTO.html">http://ibiblio.org/gferg/ldp/GCC-Inline-Assembly-HOWTO.html</a>
</li>

<li>A Brief Tutorial on GCC inline asm (x86 biased)<br />
<a href="http://www.osdever.net/tutorials/view/a-brief-tutorial-on-gcc-inline-asm">http://www.osdever.net/tutorials/view/a-brief-tutorial-on-gcc-inline-asm</a>
</li>

<li>GCC Inline ASM<br />
<a href="http://locklessinc.com/articles/gcc_asm/">http://locklessinc.com/articles/gcc_asm/</a>
</li>

<li>System cally pro AArch64 na Linuxu<br />
<a href="https://github.com/torvalds/linux/blob/master/include/uapi/asm-generic/unistd.h">https://github.com/torvalds/linux/blob/master/include/uapi/asm-generic/unistd.h</a>
</li>

<li>C Functions Without Arguments<br />
<a href="https://eklitzke.org/c-functions-without-arguments">https://eklitzke.org/c-functions-without-arguments</a>
</li>

<li>GNU Assembler Examples<br />
<a href="http://cs.lmu.edu/~ray/notes/gasexamples/">http://cs.lmu.edu/~ray/notes/gasexamples/</a>
</li>

<li>X86 Assembly/Arithmetic<br />
<a href="https://en.wikibooks.org/wiki/X86_Assembly/Arithmetic">https://en.wikibooks.org/wiki/X86_Assembly/Arithmetic</a>
</li>

<li>Art of Assembly - Arithmetic Instructions<br />
<a href="http://oopweb.com/Assembly/Documents/ArtOfAssembly/Volume/Chapter_6/CH06-2.html">http://oopweb.com/Assembly/Documents/ArtOfAssembly/Volume/Chapter_6/CH06-2.html</a>
</li>

<li>The GNU Assembler Tutorial<br />
<a href="http://tigcc.ticalc.org/doc/gnuasm.html">http://tigcc.ticalc.org/doc/gnuasm.html</a>
</li>

<li>The GNU Assembler - macros<br />
<a href="http://tigcc.ticalc.org/doc/gnuasm.html#SEC109">http://tigcc.ticalc.org/doc/gnuasm.html#SEC109</a>
</li>

<li>Generating Mixed Source and Assembly List using GCC<br />
<a href="http://www.systutorials.com/240/generate-a-mixed-source-and-assembly-listing-using-gcc/">http://www.systutorials.com/240/generate-a-mixed-source-and-assembly-listing-using-gcc/</a>
</li>

<li>Calling subroutines<br />
<a href="http://infocenter.arm.com/help/index.jsp?topic=/com.arm.doc.kui0100a/armasm_cihcfigg.htm">http://infocenter.arm.com/help/index.jsp?topic=/com.arm.doc.kui0100a/armasm_cihcfigg.htm</a>
</li>

<li>ARM Assembly Language Programming<br />
<a href="http://peter-cockerell.net/aalp/html/frames.html">http://peter-cockerell.net/aalp/html/frames.html</a>
</li>

<li>ASM Flags<br />
<a href="http://www.cavestory.org/guides/csasm/guide/asm_flags.html">http://www.cavestory.org/guides/csasm/guide/asm_flags.html</a>
</li>

<li>Status Register<br />
<a href="https://en.wikipedia.org/wiki/Status_register">https://en.wikipedia.org/wiki/Status_register</a>
</li>

<li>Linux assemblers: A comparison of GAS and NASM<br />
<a href="http://www.ibm.com/developerworks/library/l-gas-nasm/index.html">http://www.ibm.com/developerworks/library/l-gas-nasm/index.html</a>
</li>

<li>Programovani v assembleru na OS Linux<br />
<a href="http://www.cs.vsb.cz/grygarek/asm/asmlinux.html">http://www.cs.vsb.cz/grygarek/asm/asmlinux.html</a>
</li>

<li>Is it worthwhile to learn x86 assembly language today?<br />
<a href="https://www.quora.com/Is-it-worthwhile-to-learn-x86-assembly-language-today?share=1">https://www.quora.com/Is-it-worthwhile-to-learn-x86-assembly-language-today?share=1</a>
</li>

<li>Why Learn Assembly Language?<br />
<a href="http://www.codeproject.com/Articles/89460/Why-Learn-Assembly-Language">http://www.codeproject.com/Articles/89460/Why-Learn-Assembly-Language</a>
</li>

<li>Is Assembly still relevant?<br />
<a href="http://programmers.stackexchange.com/questions/95836/is-assembly-still-relevant">http://programmers.stackexchange.com/questions/95836/is-assembly-still-relevant</a>
</li>

<li>Why Learning Assembly Language Is Still a Good Idea<br />
<a href="http://www.onlamp.com/pub/a/onlamp/2004/05/06/writegreatcode.html">http://www.onlamp.com/pub/a/onlamp/2004/05/06/writegreatcode.html</a>
</li>

<li>Assembly language today<br />
<a href="http://beust.com/weblog/2004/06/23/assembly-language-today/">http://beust.com/weblog/2004/06/23/assembly-language-today/</a>
</li>

<li>Assembler: Význam assembleru dnes<br />
<a href="http://www.builder.cz/rubriky/assembler/vyznam-assembleru-dnes-155960cz">http://www.builder.cz/rubriky/assembler/vyznam-assembleru-dnes-155960cz</a>
</li>

<li>Assembler pod Linuxem<br />
<a href="http://phoenix.inf.upol.cz/linux/prog/asm.html">http://phoenix.inf.upol.cz/linux/prog/asm.html</a>
</li>

<li>AT&amp;T Syntax versus Intel Syntax<br />
<a href="https://www.sourceware.org/binutils/docs-2.12/as.info/i386-Syntax.html">https://www.sourceware.org/binutils/docs-2.12/as.info/i386-Syntax.html</a>
</li>

<li>Linux Assembly website<br />
<a href="http://asm.sourceforge.net/">http://asm.sourceforge.net/</a>
</li>

<li>Using Assembly Language in Linux<br />
<a href="http://asm.sourceforge.net/articles/linasm.html">http://asm.sourceforge.net/articles/linasm.html</a>
</li>

<li>vasm<br />
<a href="http://sun.hasenbraten.de/vasm/">http://sun.hasenbraten.de/vasm/</a>
</li>

<li>vasm &ndash; dokumentace<br />
<a href="http://sun.hasenbraten.de/vasm/release/vasm.html">http://sun.hasenbraten.de/vasm/release/vasm.html</a>
</li>

<li>The Yasm Modular Assembler Project<br />
<a href="http://yasm.tortall.net/">http://yasm.tortall.net/</a>
</li>

<li>680x0:AsmOne<br />
<a href="http://www.amigacoding.com/index.php/680x0:AsmOne">http://www.amigacoding.com/index.php/680x0:AsmOne</a>
</li>

<li>ASM-One Macro Assembler<br />
<a href="http://en.wikipedia.org/wiki/ASM-One_Macro_Assembler">http://en.wikipedia.org/wiki/ASM-One_Macro_Assembler</a>
</li>

<li>ASM-One pages<br />
<a href="http://www.theflamearrows.info/documents/asmone.html">http://www.theflamearrows.info/documents/asmone.html</a>
</li>

<li>Základní informace o ASM-One<br />
<a href="http://www.theflamearrows.info/documents/asminfo.html">http://www.theflamearrows.info/documents/asminfo.html</a>
</li>

<li>Linux Syscall Reference<br />
<a href="http://syscalls.kernelgrok.com/">http://syscalls.kernelgrok.com/</a>
</li>

<li>Programming from the Ground Up Book - Summary<br />
<a href="http://savannah.nongnu.org/projects/pgubook/">http://savannah.nongnu.org/projects/pgubook/</a>
</li>

</ol>



<p></p><p></p>
<p><small>Autor: <a href="http://www.fit.vutbr.cz/~tisnovpa">Pavel Tišnovský</a> &nbsp; 2024</small></p>
</body>
</html>

