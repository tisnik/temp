<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
        "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html>
<head>
<title>Pokročilejší operace nabízené systémem RabbitMQ</title>
<meta name="Author" content="Pavel Tisnovsky" />
<meta name="Generator" content="vim" />
<meta http-equiv="content-type" content="text/html; charset=utf-8" />
<style type="text/css">
         body {color:#000000; background:#ffffff;}
         h1  {font-family: arial, helvetica, sans-serif; color:#ffffff; background-color:#c00000; text-align:center; padding-left:1em}
         h2  {font-family: arial, helvetica, sans-serif; color:#ffffff; background-color:#0000c0; padding-left:1em; text-align:left}
         h3  {font-family: arial, helvetica, sans-serif; color:#000000; background-color:#c0c0c0; padding-left:1em; text-align:left}
         h4  {font-family: arial, helvetica, sans-serif; color:#000000; background-color:#e0e0e0; padding-left:1em; text-align:left}
         a   {font-family: arial, helvetica, sans-serif;}
         li  {font-family: arial, helvetica, sans-serif; color:#000000; text-align:justify; width:450px;}
         ol  {font-family: arial, helvetica, sans-serif; color:#000000; text-align:justify; width:450px;}
         ul  {font-family: arial, helvetica, sans-serif; color:#000000; text-align:justify; width:450px;}
         p   {font-family: arial, helvetica, sans-serif; color:#000000; text-align:justify;}
         pre {background:#e0e0e0}
</style>
</head>

<body>

<h1>Pokročilejší operace nabízené systémem RabbitMQ</h1>

<h3>Pavel Tišnovský</h3>

<p></p>

<h1>Úvodník</h1>

<p>Ve druhé části článku o systému RabbitMQ si ukážeme některé další možnosti, které lze při nasazení tohoto systému využít. Popíšeme si například způsob konfigurace tzv. rozvětvení (fanout), použití směrovačů či konfiguraci front s prioritami zpráv.</p>



<h2>Obsah</h2>

<p><a href="#k01">1. Pokročilejší operace nabízené systémem RabbitMQ</a></p>
<p><a href="#k02">2. Použití explicitně specifikované fronty pro posílání i pro výběr zpráv</a></p>
<p><a href="#k03">3. Upravené implementace producenta i konzumenta zpráv</a></p>
<p><a href="#k04">4. Zjištění aktuálně vytvořených front a směrovačů příkazem <strong>rabbitmqctl</strong></a></p>
<p><a href="#k05">5. Zobecnění předchozích skriptů</a></p>
<p><a href="#k06">6. Specifikace jména fronty použité producentem i konzumentem na příkazové řádce</a></p>
<p><a href="#k07">7. Rozvětvení (fanout) zpráv do většího množství front</a></p>
<p><a href="#k08">8. Konfigurace exchange s&nbsp;navázáním front</a></p>
<p><a href="#k09">9. Poslání zpráv s&nbsp;jejich rozvětvením do trojice front</a></p>
<p><a href="#k10">*** 10. Směrování zpráv do front na základě klíče a nakonfigurovaných regulárních výrazů</a></p>
<p><a href="#k11">*** 11. Konfigurace směrování a navázání front se specifikací směrovacího klíče</a></p>
<p><a href="#k12">*** 12. Implementace producenta posílajícího zprávy s&nbsp;tématem (<i>topicem</i>)</a></p>
<p><a href="#k13">13. Ukázka směrování v&nbsp;praxi</a></p>
<p><a href="#k14">14. Prioritní fronty v&nbsp;systému RabbitMQ</a></p>
<p><a href="#k15">15. Konfigurace prioritní fronty</a></p>
<p><a href="#k16">16. Vymazání vybrané fronty</a></p>
<p><a href="#k17">17. Specifikace priority posílané zprávy</a></p>
<p><a href="#k18">18. Pořadí přijatých zpráv s&nbsp;prioritami</a></p>
<p><a href="#k19">19. Repositář s&nbsp;demonstračními příklady</a></p>
<p><a href="#k20">20. Odkazy na Internetu</a></p>



<p><a name="k01"></a></p>
<h2 id="k01">1. Pokročilejší operace nabízené systémem RabbitMQ</h2>

<p><a
href="https://www.root.cz/clanky/rabbitmq-jedna-z-nejuspesnejsich-implementaci-brokera/">V&nbsp;úvodním
článku</a> jsme se seznámili se základními vlastnostmi systému RabbitMQ a
ukázali jsme si, jakým způsobem je možné použít jednoduchou aplikaci typu
producent-konzument, v&nbsp;níž se využije jediná pojmenovaná fronta
(<i>queue</i>) a výchozí konfigurace systému pro směrování zpráv do front
(<i>exchange</i>). Dnes si ukážeme některé další možnosti, které nám systém
RabbitMQ nabízí. Nejprve použijeme výchozí strategii směrování zpráv, ovšem
s&nbsp;využitím <a href="#k02">několika pojmenovaných front</a>. Posléze si
ukážeme způsob provedení <a href="#k07">rozvětvení</a> (<i>fanout</i>) zpráv do
většího množství front, což je druhá velmi často používaná strategie
(představit si můžeme například její využití v&nbsp;komunikačních programech
apod.). Samozřejmě nezapomeneme ani na další strategii směrování zpráv, která
se nazývá <i>topic</i> a v&nbsp;níž je možné při konfiguraci směrovače použít
regulární výrazy, což umožňuje i tvorbu aplikací s&nbsp;poměrně komplikovaným
směrováním zpráv.</p>

<p>V&nbsp;systému RabbitMQ je možné použít i takzvané prioritní fronty
(<i>priority queue</i>), které umožňují, aby zprávám posílaným do front byla
přiřazena priorita a zprávy byly podle této priority uspořádány (i když přesné
pořadí zpráv není systémem zaručeno). I s&nbsp;touto konfigurací se
pochopitelně seznámíme, i když se pravděpodobně v&nbsp;praxi nevyužívá tak
často (protože podobného chování můžeme dosáhnout využitím několika front).
Všechny dnes použité demonstrační příklady budou opět vytvořeny <a
href="https://www.python.org/">v&nbsp;programovacím jazyku Pythonu</a> a budou
postaveny nad <a href="https://pika.readthedocs.io/en/stable/">knihovnou
Pika</a>, kterou jsme využili i minule.</p>

<p><div class="rs-tip-major">Poznámka: demonstrační příklady by mělo být možné
spustit v&nbsp;Pythonu 2.7 popř.&nbsp;v&nbsp;Pythonu 3.4 (i ve všech vyšších
verzích). Otestovány byly na Pythonu 3.6.3.</div></p>



<p><a name="k02"></a></p>
<h2 id="k02">2. Použití explicitně specifikované fronty pro posílání i pro výběr zpráv</h2>

<p>Většina demonstračních příkladů, s&nbsp;nimiž jsme se seznámili minule,
používala jak pro producenta zpráv, tak i pro jejich konzumenta (konzumenty)
shodný modul nazvaný <strong>rabbitmq_connect.py</strong> s&nbsp;funkcí
pojmenovanou <strong>connect</strong>. Tato funkce je určena pro připojení
k&nbsp;systému RabbitMQ, otevření komunikačního kanálu a následně pro vytvoření
nové pojmenované fronty přiřazené ke zvolenému kanálu. Fronta se vytvoří pouze
ve chvíli, pokud ještě neexistuje, tj.&nbsp;v&nbsp;případě, že RabbitMQ
neobsahuje frontu shodného jména:</p>

<pre>
def <strong>connect</strong>(where='localhost', queue_name='test'):
    connection = pika.BlockingConnection(pika.ConnectionParameters(where))
    channel = connection.channel()
&nbsp;
    <i># pokus o nové vytvoření fronty ve skutečnosti neovlivní již existující frontu</i>
    channel.queue_declare(queue=queue_name)
    return connection, channel
</pre>

<p>Funkce <strong>connect</strong> sice skutečně může být v&nbsp;praxi použita,
ovšem ve chvíli, kdy budeme potřebovat pracovat s&nbsp;větším množstvím front
popř.&nbsp;bude nutné nějakým způsobem nakonfigurovat směrování zpráv, nám již
současné navázání připojení a otevření kanálu s&nbsp;konfigurací fronty nebude
dostačovat a budeme vyžadovat větší flexibilitu.</p>

<p>Z&nbsp;tohoto důvodu budeme v&nbsp;dalších demonstračních příkladech
používat upravený modul <a
href="https://github.com/tisnik/message-queues-examples/blob/master/rabbit-mq/python/example06/rabbitmq_connect.py">rabbitmq_connect.py</a>,
v&nbsp;němž jsou deklarovány dvě funkce. První z&nbsp;nich (jmenuje se
<strong>connect</strong>) slouží pouze k&nbsp;otevření připojení
k&nbsp;běžícímu serveru RabbitMQ (ve výchozím nastavení se jedná o server
provozovaný na stejném počítači) a druhá funkce otevře komunikační kanál a
pokusí se vytvořit frontu specifikovaného jména (výchozí jméno fronty je
&bdquo;test&ldquo;). Opět platí, že pokud fronta se zadaným jménem již
existuje, nebude mít pokus o její vytvoření žádný vliv ani na RabbitMQ, ani na
producenta či konzumenta. Jedná se tedy o <a
href="https://en.wikipedia.org/wiki/Idempotence">idempotentní operaci</a>. Nová
podoba modulu <strong>rabbitmq_connect</strong> bude následující:</p>

<pre>
import pika
&nbsp;
&nbsp;
def <strong>connect</strong>(where='localhost'):
    connection = pika.BlockingConnection(pika.ConnectionParameters(where))
    return connection
&nbsp;
&nbsp;
def <strong>open_channel</strong>(connection, queue_name='test'):
    <i># pokus o nové vytvoření fronty ve skutečnosti neovlivní již existující frontu</i>
    channel = connection.channel()
    channel.queue_declare(queue=queue_name)
    return channel
</pre>

<p><div class="rs-tip-major">Poznámka: v&nbsp;rámci navazujících kapitol budeme
možnosti tohoto modulu postupně rozšiřovat, ovšem prozatím nám bude postačovat,
aby bylo zajištěno připojení k&nbsp;serveru RabbitMQ, aby byl vytvořen
komunikační kanál a taktéž aby existovala fronta s&nbsp;uživatelsky
specifikovaným jménem.</div></p>



<p><a name="k03"></a></p>
<h2 id="k03">3. Upravené implementace producenta i konzumenta zpráv</h2>

<p>Producent, který bude používat novou implementaci výše popsaného modulu
<strong>rabbitmq_connect.py</strong>, se ve skutečnosti změní jen minimálně.
V&nbsp;následujícím <a
href="https://github.com/tisnik/message-queues-examples/blob/master/rabbit-mq/python/example06/enqueue_work.py">zdrojovém
kódu <strong>enqueue_work.py</strong></a>, v&nbsp;němž se posílá jediná zpráva
do fronty &bdquo;test&ldquo;, se pouze musí zavolat jak funkce
<strong>connect()</strong>, tak i funkce <strong>open_channel()</strong>;
samozřejmě v&nbsp;tomto vypsaném pořadí. Následně již můžeme do systému poslat
zprávy metodou <strong>channel.basic_publish()</strong> a spojení uzavřít
pomocí <strong>connection.close()</strong>:</p>

<pre>
<i>#!/usr/bin/env python</i>
from rabbitmq_connect import connect, open_channel
&nbsp;
connection = <strong>connect()</strong>
channel = <strong>open_channel(connection)</strong>
&nbsp;
channel.basic_publish(exchange='',
                      routing_key='test',
                      body='Hello World!')
&nbsp;
print("Sent 'Hello World!'")
connection.close()
</pre>

<p>V&nbsp;tomto skriptu se zpráva posílá metodou
<strong>channel.basic_publish</strong>. Povšimněte si, že v&nbsp;této metodě
specifikujeme tři pojmenované parametry. První z&nbsp;těchto parametrů
(<strong>exchange</strong>) určuje strategii směrování zpráv do front. Výchozí
strategií (prázdný řetězec) je směrování do fronty, jejíž název odpovídá
řetězci předaného v&nbsp;parametru <strong>routing_key</strong>. Parametr
<strong>body</strong> obsahuje vlastní tělo zprávy, což je buď řetězec nebo
sekvence bajtů.</p>

<p>Na následujícím schématu je naznačeno, že zprávy se nejprve pošlou do
<i>exchange</i> a teprve na základě zvolené konfigurace se přesměrují do nějaké
fronty popř.&nbsp;se rozvětví (<i>fanout</i>) do většího množství front:</p>

<a href="https://www.root.cz/obrazek/348765/"><img src="https://i.iinfo.cz/images/176/rabbitmq1-4-prev.png" class="image-348765" alt="&#160;" width="370" height="158" /></a>
<p><i>Obrázek 1: Interní konfigurovatelná struktura systému RabbitMQ.</i></p>

<p>Podobnou úpravu provedeme i <a
href="https://github.com/tisnik/message-queues-examples/blob/master/rabbit-mq/python/example06/enqueue_more_work.py">v&nbsp;producentovi
deseti zpráv</a> poslaných do fronty pojmenované &bdquo;test&ldquo;. Základní
struktura skriptu zůstává stejná, pouze se namísto jedné zprávy pošle zpráv
deset:</p>

<pre>
<i>#!/usr/bin/env python</i>
from rabbitmq_connect import connect, open_channel
&nbsp;
connection = <strong>connect()</strong>
channel = <strong>open_channel(connection)</strong>
&nbsp;
for i in range(1, 11):
    channel.basic_publish(exchange='',
                          routing_key='test',
                          body='Hello World! #{i}'.format(i=i))
&nbsp;
print("Sent 'Hello World!' ten times")
connection.close()
</pre>

<p><a
href="https://github.com/tisnik/message-queues-examples/blob/master/rabbit-mq/python/example06/consumer.py">Konzument
zpráv z&nbsp;fronty &bdquo;test&ldquo;</a> je složitější než producent, a to
z&nbsp;toho důvodu, že je zapotřebí naprogramovat <i>callback</i> funkci
zavolanou automaticky ve chvíli, kdy je z&nbsp;fronty vyzvednuta nová zpráva.
Současně budeme s&nbsp;využitím metody
<strong>channel.basic_qos(prefetch_count=1)</strong> specifikovat, že si
konzument nemá vyzvedávat větší množství zpráv, což by do určité míry
znemožnilo paralelní spuštění většího množství konzumentů (workerů), kteří by
se o zprávy spravedlivě dělili. Ovšem postup otevření připojení a získání
komunikačního kanálu zůstává zachován:</p>

<pre>
<i>#!/usr/bin/env python</i>
&nbsp;
from time import sleep
from rabbitmq_connect import connect, open_channel
&nbsp;
connection = <strong>connect()</strong>
channel = <strong>open_channel(connection)</strong>
&nbsp;
def <strong>on_receive</strong>(ch, method, properties, body):
    print("Received %r" % body)
    sleep(5)
    print("Done processing %r" % body)
    ch.basic_ack(delivery_tag = method.delivery_tag)
&nbsp;
&nbsp;
channel.basic_qos(prefetch_count=1)
channel.basic_consume(on_receive,
                      queue='test',
                      no_ack=False)
&nbsp;
print('Waiting for messages. To exit press CTRL+C')
print("...")
channel.start_consuming()
</pre>

<p><div class="rs-tip-major">Poznámka: v&nbsp;praxi je možné hodnotu
<strong>prefetch_count</strong> zvýšit, protože nám nemusí záležet na tom, zda
se konzumenti o zprávy dělí zcela spravedlivě (především ve chvíli, kdy je
zpráv větší množství), ovšem pro naše účely jednoduchého testování se dvěma či
třemi konzumenty je výhodnější a mnohem názornější použít
<strong>prefetch_count=1</strong>.</div></p>



<p><a name="k04"></a></p>
<h2 id="k04">4. Zjištění aktuálně vytvořených front a směrovačů příkazem <strong>rabbitmqctl</strong></h2>

<p><a
href="https://www.root.cz/clanky/rabbitmq-jedna-z-nejuspesnejsich-implementaci-brokera/#k07">V&nbsp;úvodním
článku o systému RabbitMQ</a> jsme si mj.&nbsp;řekli, že RabbitMQ se většinou
spouští ve funkci démona, resp.&nbsp;služby. Jakmile server běží, je možné
použít příkaz <strong>rabbitmqctl</strong>, který slouží pro změnu konfigurace
serveru, pro správu clusterů a v&nbsp;neposlední řadě taktéž pro zjištění
užitečných informací o tom, jaké fronty v&nbsp;daném okamžiku existují, jaké
jsou k&nbsp;dispozici směrovače (<i>exchange</i>) apod. Vzhledem k&nbsp;tomu,
že pro ovlivnění běžících démonů či služeb je nutné mít příslušné oprávnění,
budete (v&nbsp;tom nejjednodušším případě) muset <strong>rabbitmqctl</strong>
spouštět s&nbsp;právy Roota, tedy přes <strong>su</strong> či
<strong>sudo</strong> způsobem:</p>

<pre>
# <strong>systemctl enable rabbitmq-server.service</strong>
# <strong>systemctl start rabbitmq-server.service</strong>
</pre>

<p>popř. (pokud používáte klasický init systém:</p>

<pre>
# <strong>chkconfig rabbitmq-server on</strong>
# <strong>service rabbitmq-server start</strong>
</pre>

<p>Ve chvíli, kdy server systému RabbitMQ běží, můžeme použít již výše zmíněný
příkaz <strong>rabbitmq</strong>. Jedním z&nbsp;dostupných příkazů je zjištění
stavu uzlu:</p>

<pre>
$ <strong>sudo rabbitmqctl node_health_check</strong>
&nbsp;
Timeout: 70.0 seconds
Checking health of node rabbit@localhost
Health check passed
</pre>

<p>S&nbsp;využitím příkazu <strong>rabbitmqctl</strong> můžeme zjistit
například všechny uživatele, kteří mohou se systémem RabbitMQ pracovat, a to
včetně jejich rolí. Ve výchozím nastavení je k&nbsp;dispozici jen jediný
uživatel se jménem &bdquo;guest&ldquo;:</p>

<pre>
$ <strong>sudo rabbitmqctl list_users</strong>
&nbsp;
Listing users
guest   [administrator]
</pre>

<p>Pro zjištění jmen a stavu aktuálně vytvořených a používaných front se
použije příkaz <strong>rabbitmqctl list_queues</strong>. Jeho výstup může
vypadat následovně:</p>

<pre>
$ <strong>sudo rabbitmqctl list_queues</strong>
&nbsp;
Listing queues
t3      0
testX   0
test    0
t1      2
t2      0
</pre>

<p>Na tomto výpisu můžeme vidět několik front, které byly vytvořeny již
v&nbsp;rámci předchozího článku a v&nbsp;něm uvedených demonstračních příkladů;
ve výchozím stavu totiž není k&nbsp;dispozici žádná trvalá fronta (všechny
fronty se po vyprázdnění a odpojení klientů zahodí).</p>

<p>Nakonfigurované směrovače získáme příkazem. Každý směrovač má přiřazené
jméno a taktéž typ (<strong>direct</strong>, <strong>fanout</strong>,
<strong>headers</strong>, <strong>topic</strong>):</p>

<pre>
$ <strong>sudo rabbitmqctl list_exchanges</strong>
&nbsp;
Listing exchanges
amq.topic       topic
amq.rabbitmq.log        topic
amq.headers     headers
amq.fanout      fanout
        direct
amq.rabbitmq.trace      topic
amq.match       headers
amq.direct      direct
</pre>

<p><div class="rs-tip-major">Poznámka: povšimněte si především směrovače, který
nemá žádné jméno a je typu &bdquo;direct&ldquo;. Jedná se o výchozí směrovač,
který jsme až doposud používali ve všech demonstračních příkladech.</div></p>

<p>Velmi podrobné informace o systému RabbitMQ získáme příkazem:</p>

<pre>
$ <strong>sudo rabbitmqctl report</strong>
</pre>

<p>Výsledek je velmi dlouhý, takže z&nbsp;něj uvedu pouze zajímavé výňatky.</p>

<p>Všichni připojení klienti:</p>

<pre>
<strong>Connections:</strong>
pid     name    port    peer_port       host    peer_host       ssl     peer_cert_subject       peer_cert_issuer  peer_cert_validity      auth_mechanism  ssl_protocol    ssl_key_exchange        ssl_cipher      ssl_hash  protocol        user    vhost   timeout frame_max       channel_max     client_properties       connected_at      recv_oct        recv_cnt        send_oct        send_cnt        send_pend       state   channels  reductions      garbage_collection
&lt;rabbit@localhost.3.17007.0&gt;    127.0.0.1:52984 -&gt; 127.0.0.1:5672       5672    52984   127.0.0.1       127.0.0.1 false                           PLAIN                                   {0,9,1} guest   /       60131072  65535   [{"product","Pika Python Client Library"},{"platform","Python 3.6.3"},{"capabilities",[{"authentication_failure_close",true},{"basic.nack",true},{"connection.blocked",true},{"consumer_cancel_notify",true},{"publisher_confirms",true}]},{"information","See http://pika.rtfd.org"},{"version","0.12.0"}] 1546790531378     482     9       745     7       0       running 1       4658    [{max_heap_size,0}, {min_bin_vheap_size,46422}, {min_heap_size,233}, {fullsweep_after,65535}, {minor_gcs,7}]
</pre>

<p>Strategie směrování:</p>

<pre>
<strong>Exchanges on /:</strong>
name    type    durable auto_delete     internal        arguments       policy
        direct  true    false   false   []
amq.direct      direct  true    false   false   []
amq.fanout      fanout  true    false   false   []
amq.headers     headers true    false   false   []
amq.match       headers true    false   false   []
amq.rabbitmq.log        topic   true    false   true    []
amq.rabbitmq.trace      topic   true    false   true    []
amq.topic       topic   true    false   false   []
</pre>

<p>Vazby strategie směrování na fronty:</p>

<pre>
<strong>Bindings on /:</strong>
source_name     source_kind     destination_name        destination_kind        routing_key     argumentsvhost
        exchange        t1      queue   t1      []      /
        exchange        t2      queue   t2      []      /
        exchange        t3      queue   t3      []      /
        exchange        test    queue   test    []      /
        exchange        testX   queue   testX   []      /
</pre>

<p>Připojení konzumenti:</p>

<pre>
<strong>Consumers on /:</strong>
queue_name      channel_pid     consumer_tag    ack_required    prefetch_count  arguments
test    &lt;rabbit@localhost.3.17015.0&gt;    ctag1.1066b0a209074f83a46f399e5fd5e6e5  true    1       []
</pre>



<p><a name="k05"></a></p>
<h2 id="k05">5. Zobecnění předchozích skriptů</h2>

<p>Skripty popsané <a href="#k02">ve druhé</a> a <a href="#k03">ve třetí
kapitole</a> bude lepší z&nbsp;praktických důvodů upravit takovým způsobem, aby
producent i konzument nebyly volány přímo z&nbsp;hlavního těla skriptu, ale aby
byl jejich kód umístěn do funkcí.</p>

<p><a
href="https://github.com/tisnik/message-queues-examples/blob/master/rabbit-mq/python/example07/enqueue_work.py">Producent</a>,
který po svém spuštění pošle do fronty (přes směrovač) jedinou zprávu, bude
upraven takto:</p>

<pre>
<i>#!/usr/bin/env python</i>
from rabbitmq_connect import connect, open_channel
&nbsp;
&nbsp;
def <strong>run_producer</strong>(queue_name):
    connection = connect()
    channel = open_channel(connection, queue_name)
&nbsp;
    channel.basic_publish(exchange='',
                          routing_key=queue_name,
                          body='Hello World!')
&nbsp;
    print('Sent \'Hello World!\' message into the queue "{q}"'.format(q=queue_name))
&nbsp;
    connection.close()
&nbsp;
&nbsp;
run_producer('test')
</pre>

<p>Podobným způsobem je upraven i <a
href="https://github.com/tisnik/message-queues-examples/blob/master/rabbit-mq/python/example07/enqueue_more_work.py">producent deseti zpráv</a>:</p>

<pre>
<i>#!/usr/bin/env python</i>
from rabbitmq_connect import connect, open_channel
&nbsp;
&nbsp;
def <strong>run_producer</strong>(queue_name):
    connection = connect()
    channel = open_channel(connection)
&nbsp;
    for i in range(1, 11):
        channel.basic_publish(exchange='',
                              routing_key=queue_name,
                              body='Hello World! #{i}'.format(i=i))
&nbsp;
    print('Sent \'Hello World!\' ten times into the queue "{q}"'.format(q=queue_name))
    connection.close()
&nbsp;
&nbsp;
run_producer('test')
</pre>

<p>A konečně se podívejme na to, jak by bylo možné upravit <a
href="https://github.com/tisnik/message-queues-examples/blob/master/rabbit-mq/python/example07/consumer.py">konzumenta zpráv</a>:</p>

<pre>
<i>#!/usr/bin/env python</i>
&nbsp;
from time import sleep
from rabbitmq_connect import connect, open_channel
&nbsp;
&nbsp;
def <strong>on_receive</strong>(ch, method, properties, body):
    print("Received %r" % body)
    sleep(1)
    print("Done processing %r" % body)
    ch.basic_ack(delivery_tag=method.delivery_tag)
&nbsp;
&nbsp;
def <strong>run_consumer</strong>(queue_name):
    connection = connect()
    channel = open_channel(connection, queue_name)
    channel.basic_qos(prefetch_count=1)
    channel.basic_consume(on_receive,
                          queue=queue_name,
                          no_ack=False)
    print('Waiting for messages in queue "{q}". To exit press CTRL+C'.format(q=queue_name))
    print("...")
    channel.start_consuming()
&nbsp;
&nbsp;
run_consumer('test')
</pre>



<p><a name="k06"></a></p>
<h2 id="k06">6. Specifikace jména fronty použité producentem i konzumentem na příkazové řádce</h2>

<p>Ve druhé části článku si ukážeme použití různých <i>strategií</i> použitých
při přijetí zprávy. Na základě nakonfigurované strategie se zpráva zařadí do
jedné fronty či do několika front. V&nbsp;současné verzi serveru RabbitMQ jsou
podporovány čtyři strategie:</p>

<ul>

<li>Nejjednodušší strategie se jmenuje <i>direct</i>. Tato strategie je
založena na tom, že samotná zpráva obsahuje klíč (<i>key</i>), který slouží pro
výběr správné fronty. Pokud budeme mít k&nbsp;dispozici jedinou frontu a budeme
používat jeden klíč, celý broker se nám vlastně zúží na &bdquo;obyčejnou&ldquo;
frontu zpráv podporující různé protokoly a nabízejí řešení s&nbsp;vysokou
dostupností. Klíč je reprezentován jako běžný řetězec.</li>

<li>Další strategie se nazývá <i>topic</i>. Jedná se o složitější formu
navázání zprávy na frontu, v&nbsp;němž se opět používá klíč uložený ve zprávě.
Tento klíč se porovnává s&nbsp;regulárními výrazy specifikovanými
v&nbsp;konfiguraci směrovače. Ve chvíli, kdy klíč odpovídá nějakému regulárnímu
výrazu, je zpráva přesměrována do příslušné fronty. Můžeme tak například velmi
snadno směrovat zprávy do různých front (a tím pádem i do různých workerů) na
základě doménového jména serveru, kde zpráva vznikla apod.</li>

<li>Třetí strategie používá hlavičky (<i>headers</i>) připojené ke zprávě. To
umožňuje detailnější konfiguraci směrování; podrobnosti si popíšeme
v&nbsp;navazujícím článku.</li>

<li>A konečně čtvrtá strategie se nazývá <i>fanout</i>. Při použití této
strategie se přijatá zpráva přenese (zduplikuje) do několika nakonfigurovaných
front, což znamená, že bude přijata a zpracována několikrát. V&nbsp;praxi se
například může jednat o přeposlání zprávy napsané klientem na různé servery
implementující nějakou internetovou komunikační službu (Slack atd.).</li>

</ul>

<p>Při použití všech typů strategií je důležité znát a specifikovat jméno
fronty. Proto si nepatrně rozšíříme naše skripty o možnost specifikace jména
fronty z&nbsp;příkazového řádku. Začneme <a
href="https://github.com/tisnik/message-queues-examples/blob/master/rabbit-mq/python/example08/enqueue_work.py">producentem
jediné zprávy</a>:</p>

<pre>
<i>#!/usr/bin/env python</i>
from sys import exit, argv
from rabbitmq_connect import connect, open_channel
&nbsp;
&nbsp;
def <strong>run_producer</strong>(queue_name):
    connection = connect()
    channel = open_channel(connection, queue_name)
&nbsp;
    channel.basic_publish(exchange='',
                          routing_key=queue_name,
                          body='Hello World!')
&nbsp;
    print('Sent \'Hello World!\' message into the queue "{q}"'.format(q=queue_name))
&nbsp;
    connection.close()
&nbsp;
&nbsp;
if len(argv) &lt;= 1:
    print('Please provide queue name on the CLI')
    exit(1)
&nbsp;
run_producer(argv[1])
</pre>

<p>Naprosto stejným způsobem byl upraven <a
href="https://github.com/tisnik/message-queues-examples/blob/master/rabbit-mq/python/example08/enqueue_more_work.py">producent
deseti zpráv</a>:</p>

<pre>
<i>#!/usr/bin/env python</i>
from sys import exit, argv
from rabbitmq_connect import connect, open_channel
&nbsp;
&nbsp;
def <strong>run_producer</strong>(queue_name):
    connection = connect()
    channel = open_channel(connection)
&nbsp;
    for i in range(1, 11):
        channel.basic_publish(exchange='',
                              routing_key=queue_name,
                              body='Hello World! #{i}'.format(i=i))
&nbsp;
    print('Sent \'Hello World!\' ten times into the queue "{q}"'.format(q=queue_name))
    connection.close()
&nbsp;
&nbsp;
if len(argv) &lt;= 1:
    print('Please provide queue name on the CLI')
    exit(1)
&nbsp;
run_producer(argv[1])
</pre>

<p>Nakonec upravíme i <a
href="https://github.com/tisnik/message-queues-examples/blob/master/rabbit-mq/python/example08/consumer.py">základní
variantu konzumenta zpráv</a>:</p>

<pre>
<i>#!/usr/bin/env python</i>
&nbsp;
from sys import exit, argv
from time import sleep
from rabbitmq_connect import connect, open_channel
&nbsp;
&nbsp;
def <strong>on_receive</strong>(ch, method, properties, body):
    print("Received %r" % body)
    sleep(1)
    print("Done processing %r" % body)
    ch.basic_ack(delivery_tag=method.delivery_tag)
&nbsp;
&nbsp;
def <strong>run_consumer</strong>(queue_name):
    connection = connect()
    channel = open_channel(connection, queue_name)
    channel.basic_qos(prefetch_count=1)
    channel.basic_consume(on_receive,
                          queue=queue_name,
                          no_ack=False)
    print('Waiting for messages in queue "{q}". To exit press CTRL+C'.format(q=queue_name))
    print("...")
    channel.start_consuming()
&nbsp;
&nbsp;
if len(argv) &lt;= 1:
    print('Please provide queue name on the CLI')
    exit(1)
&nbsp;
run_consumer(argv[1])
</pre>

<p>Informace o frontách, které jsou v&nbsp;daný okamžik k&nbsp;dispozici,
můžeme získat příkazem <strong>rabbitmqctl list_queues</strong>, s&nbsp;nímž
jsme se seznámili <a href="#k04">ve čtvrté kapitole</a>:</p>

<pre>
$ <strong>sudo rabbitmqctl list_queues</strong>
&nbsp;
Listing queues
t3      0
testX   0
test    0
t1      2
t2      0
log     0
nova_fronta 0
dalsi_fronta 0
</pre>



<p><a name="k07"></a></p>
<h2 id="k07">7. Rozvětvení (fanout) zpráv do většího množství front</h2>

<p>Z&nbsp;předchozího textu již víme, že v&nbsp;případě potřeby je možné
nakonfigurovat rozvětvení (<i>fanout</i>) zpráv, tj.&nbsp;každá zpráva může být
doručena většímu množství příjemců. Příkladem může být vzájemná distribuce
textových zpráv mezi několika servery implementujícími internetová
&bdquo;kecátka&ldquo; (Slack, Mattermost, Jabber/XMPP...). Každý server přitom
může současně vystupovat v&nbsp;roli příjemce zpráv i producenta zpráv.</p>

<p>Rozvětvení je možné provést do libovolných front, což ovšem znamená, že do
nějaké fronty můžeme zprávy posílat z&nbsp;většího množství směrovačů
(exchange). Podívejme se na dva typické případy (stále uvažujeme variantu, kdy
celý RabbitMQ běží na jediném stroji):</p>

*** image ***
<p><i>Obrázek 2: Jedna z&nbsp;možných konfigurací rozvětvení. První směrovač
(exchange) zkopíruje přijatou zprávu do tří front. Poslední (čtvrtá) fronta
není v&nbsp;tomto případě nijak využita &ndash; rozvětvení se provádí jen do
předem <strong>vybraných</strong> front.</i></p>

*** image ***
<p><i>Obrázek 3: Další možná konfigurace rozvětvení, v&nbsp;níž je třetí fronta
použita oběma nakonfigurovanými směrovači. Zprávy z&nbsp;obou směrovačů se tedy
mohou promíchat.</i></p>

<p>Pokud si necháme vypsat všechny existující (nakonfigurované) směrovače,
zjistíme, že automaticky vytvořený směrovač <strong>amq.fanout</strong> provádí
rozvětvení zpráv do (vybraných) front:</p>

<pre>
$ <strong>sudo rabbitmqctl list_exchanges</strong>
&nbsp;
Listing exchanges
amq.topic       topic
amq.rabbitmq.log        topic
amq.headers     headers
<strong>amq.fanout      fanout</strong>
        direct
amq.rabbitmq.trace      topic
amq.match       headers
amq.direct      direct
</pre>

<p>Samozřejmě nám ovšem nic nebrání vytvořit si směrovač vlastní. Nový směrovač
se vytvoří metodou <strong>channel.exchange_declare</strong>, přičemž musíme
specifikovat jak jméno směrovače v&nbsp;parametru <strong>exchange</strong>,
tak i jeho typ v&nbsp;parametru <strong>exchange_type</strong>. Typ je
specifikován řetězcem &bdquo;direct&ldquo;, &bdquo;topic&ldquo;,
&bdquo;fanout&ldquo; či &bdquo;headers&ldquo;, V&nbsp;této kapitole nás zajímá
rozvětvení (<i>fanout</i>), takže použijeme typ &bdquo;fanout&ldquo;:</p>

<pre>
def <strong>use_fanout</strong>(channel, exchange_name='fanout_exchange'):
    print(exchange_name)
    channel.exchange_declare(exchange=exchange_name,
                             exchange_type='fanout')
</pre>



<p><a name="k08"></a></p>
<h2 id="k08">8. Konfigurace exchange s&nbsp;navázáním front</h2>

<p>Aby bylo možné vytvořit nový směrovač (<i>exchange</i>) typu <i>fanout</i>,
rozšíříme náš modul <a
href="https://github.com/tisnik/message-queues-examples/blob/master/rabbit-mq/python/example09/rabbitmq_connect.py">rabbitmq_connect.py</a>
o další funkci nazvanou <strong>use_fanout</strong>. Této funkci je nutné
předat vytvořený komunikační kanál a v&nbsp;nepovinném parametry i jméno
směrovače. V&nbsp;případě, že jméno nebude explicitně specifikováno, použije se
výchozí jméno &bdquo;fanout_exchange&ldquo;:</p>

<pre>
import pika
&nbsp;
&nbsp;
def <strong>connect</strong>(where='localhost'):
    connection = pika.BlockingConnection(pika.ConnectionParameters(where))
    return connection
&nbsp;
&nbsp;
def <strong>open_channel</strong>(connection, queue_name='test'):
    <i># pokus o nové vytvoření fronty ve skutečnosti neovlivní již existující frontu</i>
    channel = connection.channel()
    channel.queue_declare(queue=queue_name)
    return channel
&nbsp;
&nbsp;
def <strong>use_fanout</strong>(channel, exchange_name='fanout_exchange'):
    print(exchange_name)
    channel.exchange_declare(exchange=exchange_name,
                             exchange_type='fanout')
&nbsp;
&nbsp;
def <strong>bind_queue</strong>(channel, queue_name, exchange_name='fanout_exchange'):
    channel.queue_declare(queue=queue_name)
    channel.queue_bind(exchange=exchange_name,
                       queue=queue_name)
</pre>



<p><a name="k09"></a></p>
<h2 id="k09">9. Poslání zpráv s&nbsp;jejich rozvětvením do trojice front</h2>

<p>V&nbsp;tento okamžik je již vše připraveno na úpravu <a
href="https://github.com/tisnik/message-queues-examples/blob/master/rabbit-mq/python/example09/enqueue_work.py">nové
varianty producenta</a> takovým způsobem, aby se po jeho spuštění vytvořila
trojice front nazvaných &bdquo;fronta1&ldquo;, &bdquo;fronta2&ldquo; a
&bdquo;fronta3&ldquo;. Tyto tři fronty budou navázány na nový směrovač typu
<i>fanout</i>. Postup je jednoduchý:</p>

<pre>
use_fanout(channel)
bind_queue(channel, 'fronta1')
bind_queue(channel, 'fronta2')
bind_queue(channel, 'fronta3')
</pre>

<p>Úplný zdrojový kód producenta bude vypadat takto:</p>

<pre>
<i>#!/usr/bin/env python</i>
from sys import exit, argv
from rabbitmq_connect import connect, open_channel, use_fanout, bind_queue
&nbsp;
&nbsp;
def <strong>run_producer</strong>():
    connection = connect()
    channel = open_channel(connection)
&nbsp;
    use_fanout(channel)
    bind_queue(channel, 'fronta1')
    bind_queue(channel, 'fronta2')
    bind_queue(channel, 'fronta3')
&nbsp;
    for i in range(1, 11):
        channel.basic_publish(exchange='fanout_exchange',
                              routing_key='',
                              body='Hello World! #{i}'.format(i=i))
&nbsp;
    print('Sent \'Hello World!\' ten times into three queues "fronta1", "fronta2", and "fronta3"')
    connection.close()
&nbsp;
&nbsp;
run_producer()
</pre>

<p>Producenta spustíme:</p>

<pre>
$ <strong>python3 enqueue_work.py</strong>
&nbsp;
Sent 'Hello World!' message into three queues "fronta1", "fronta2", and "fronta3"
</pre>

<p>Nyní by se měl v&nbsp;seznamu směrovačů objevit nový směrovač typu
<i>fanout</i> se jménem &bdquo;fanout_exchange&ldquo;:</p>

<pre>
$ <strong>sudo rabbitmqctl list_exchanges</strong>
&nbsp;
Listing exchanges
amq.topic       topic
amq.rabbitmq.log        topic
amq.headers     headers
<strong>fanout_exchange fanout</strong>
amq.fanout      fanout
        direct
amq.rabbitmq.trace      topic
amq.match       headers
amq.direct      direct
</pre>

<p>Současně by měl seznam front obsahovat tři nové fronty:</p>

<pre>
$ <strong>sudo rabbitmqctl list_queues</strong>
&nbsp;
Listing queues
t3      0
testX   0
test    0
t1      2
t2      0
<strong>fronta2 1</strong>
<strong>fronta1 1</strong>
<strong>fronta3 1</strong>
xxx     0
</pre>

<p>Povšimněte si, že každá nová fronta obsahuje jedinou zprávu &ndash; poslanou
jedenkrát našim producentem a rozvětvenou nově vytvořeným směrovačem.</p>



<p><a name="k10"></a></p>
<h2 id="k10">10. Směrování zpráv do front na základě klíče a nakonfigurovaných regulárních výrazů</h2>

<p></p>

<pre>
def <strong>use_topic_exchange</strong>(channel, exchange_name='topic_exchange'):
    channel.exchange_declare(exchange=exchange_name,
                             exchange_type='topic')
</pre>



<p><a name="k11"></a></p>
<h2 id="k11">11. Konfigurace směrování a navázání front se specifikací směrovacího klíče</h2>

<pre>
import pika
&nbsp;
&nbsp;
def <strong>connect</strong>(where='localhost'):
    connection = pika.BlockingConnection(pika.ConnectionParameters(where))
    return connection
&nbsp;
&nbsp;
def <strong>open_channel</strong>(connection, queue_name='test'):
    <i># pokus o nové vytvoření fronty ve skutečnosti neovlivní již existující frontu</i>
    channel = connection.channel()
    channel.queue_declare(queue=queue_name)
    return channel
&nbsp;
&nbsp;
def <strong>use_fanout</strong>(channel, exchange_name='fanout_exchange'):
    channel.exchange_declare(exchange=exchange_name,
                             exchange_type='fanout')
&nbsp;
&nbsp;
def <strong>use_topic_exchange</strong>(channel, exchange_name='topic_exchange'):
    channel.exchange_declare(exchange=exchange_name,
                             exchange_type='topic')
&nbsp;
&nbsp;
def <strong>bind_queue</strong>(channel, queue_name, routing_pattern='', exchange_name='fanout_exchange'):
    channel.queue_declare(queue=queue_name)
    channel.queue_bind(exchange=exchange_name,
                       queue=queue_name,
                       routing_key=routing_pattern)
</pre>



<p><a name="k12"></a></p>
<h2 id="k12">12. Implementace producenta posílajícího zprávy s&nbsp;tématem (<i>topicem</i>)</h2>

<p></p>

<pre>
<i>#!/usr/bin/env python</i>
from sys import exit, argv
from rabbitmq_connect import connect, open_channel, use_topic_exchange, bind_queue
&nbsp;
&nbsp;
def <strong>run_producer</strong>():
    connection = connect()
    channel = open_channel(connection)
&nbsp;
    use_topic_exchange(channel)
    bind_queue(channel, 'europe_queue',
               routing_pattern='europe.*', exchange_name='topic_exchange')
    bind_queue(channel, 'asia_queue',
               routing_pattern='asia.*', exchange_name='topic_exchange')
    bind_queue(channel, 'americas_queue',
               routing_pattern='americas.*', exchange_name='topic_exchange')
&nbsp;
    keys = ("europe.cr", "europe.sr", "europe.pl",
            "asia.china",
            "americas.canada", "americas.chile")
    for key in keys:
        print(key)
        channel.basic_publish(exchange='topic_exchange',
                              routing_key=key,
                              body='Hello World! #{k}'.format(k=key))
&nbsp;
    print('Sent \'Hello World!\' to all selected regions')
    connection.close()
&nbsp;
&nbsp;
run_producer()
</pre>

<p></p>

<pre>
<i>#!/usr/bin/env python</i>
&nbsp;
from sys import exit, argv
from time import sleep
from rabbitmq_connect import connect, open_channel
&nbsp;
&nbsp;
def <strong>on_receive</strong>(ch, method, properties, body):
    print("Received %r" % body)
    sleep(1)
    print("Done processing %r" % body)
    ch.basic_ack(delivery_tag=method.delivery_tag)
&nbsp;
&nbsp;
def <strong>run_consumer</strong>(queue_name):
    connection = connect()
    channel = open_channel(connection, queue_name)
    channel.basic_qos(prefetch_count=1)
    channel.basic_consume(on_receive,
                          queue=queue_name,
                          no_ack=False)
    print('Waiting for messages in queue "{q}". To exit press CTRL+C'.format(q=queue_name))
    print("...")
    channel.start_consuming()
&nbsp;
&nbsp;
if len(argv) &lt;= 1:
    print('Please provide queue name on the CLI')
    exit(1)
&nbsp;
run_consumer(argv[1])
</pre>



<p><a name="k13"></a></p>
<h2 id="k13">13. Ukázka směrování v&nbsp;praxi</h2>

<p>Před spuštěním producenta popsaného <a href="#k12">v&nbsp;předchozí
kapitole</a> by seznam front neměl obsahovat ani jednu z&nbsp;front
&bdquo;americas_queue&ldquo;, &bdquo;asia_queue&ldquo; a
&bdquo;europe_queue&ldquo;. O tom se přesvědčíme snadno:</p>

<pre>
$ <strong>sudo rabbitmqctl list_queues</strong>
&nbsp;
Listing queues
t3      0
testX   0
test    0
t1      2
t2      0
fronta2 6
fronta1 16
fronta3 16
</pre>

<p>Nyní si můžeme zkusit producenta spustit:</p>

<pre>
$ <strong>python3 enqueue_more_work.py</strong>
&nbsp;
europe.cr
europe.sr
europe.pl
asia.china
americas.canada
americas.chile
Sent 'Hello World!' to all selected regions
</pre>

<p>Vidíme, že producent vytvořil a poslal celkem šest zpráv, které by se měly
nějakým způsobem rozdělit mezi tři nakonfigurované regiony: Evropa, Asie, obě
Ameriky. Zkusme si tedy vypsat stav všech front:</p>

<pre>
$ <strong>sudo rabbitmqctl list_queues</strong>
&nbsp;
Listing queues
t3      0
<i>americas_queue  2</i>
testX   0
test    0
t1      2
<i>asia_queue      1</i>
<i>europe_queue    3</i>
t2      0
fronta2 6
fronta1 16
fronta3 16
</pre>

<p>V&nbsp;dalším kroku spustíme producenta, který bude zpracovávat zprávy
z&nbsp;fronty &bdquo;americas_queue&ldquo;. Tato fronta obsahuje dvě zprávy, a
obě by se měly správně zpracovat:</p>

<pre>
$ <strong></strong>
&nbsp;
Waiting for messages in queue "americas_queue". To exit press CTRL+C
...
Received b'Hello World! #americas.canada'
Done processing b'Hello World! #americas.canada'
Received b'Hello World! #americas.chile'
Done processing b'Hello World! #americas.chile'
</pre>

<p>Po novém otestování obsahu front by již fronta &bdquo;americas_queue&ldquo;
neměla obsahovat žádné zprávy:</p>

<pre>
$ <strong>sudo rabbitmqctl list_queues</strong>
&nbsp;
Listing queues
t3      0
<i>americas_queue  0</i>
testX   0
test    0
t1      2
<i>asia_queue      1</i>
<i>europe_queue    3</i>
t2      0
fronta2 6
fronta1 16
fronta3 16
</pre>

<p>Nakonec spustíme producenta se specifikací front &bdquo;asia_queue&ldquo; a
&bdquo;europe_queue&ldquo;. Výsledkem by měly být sice existující, ovšem
prázdné fronty:</p>

<pre>
$ <strong>sudo rabbitmqctl list_queues</strong>
&nbsp;
Listing queues
t3      0
<i>americas_queue  0</i>
testX   0
test    0
t1      2
<i>asia_queue      0</i>
<i>europe_queue    0</i>
t2      0
fronta2 6
fronta1 16
fronta3 16
</pre>



<p><a name="k14"></a></p>
<h2 id="k14">14. Prioritní fronty v&nbsp;systému RabbitMQ</h2>

<p>Systém RabbitMQ podporuje práci s&nbsp;takzvanými prioritními frontami
(<i>priority queue</i>). V&nbsp;případě, že je nějaká fronta nakonfigurována
jako prioritní, je možné do ní posílat zprávy s&nbsp;nastavenou prioritou,
přičemž zprávy s&nbsp;vyšší prioritou budou přesunuty směrem k&nbsp;začátku
fronty. Systém sice nezaručuje, že pořadí zpráv ve frontě bude přesně odpovídat
<a href="https://www.rabbitmq.com/priority.html">zadané prioritě</a>, ovšem
většinou se zpráva skutečně zařadí na správné místo, což ostatně uvidíme i při
spuštění dnešních dvou posledních demonstračních příkladů.</p>

<p>Priorita zprávy může být specifikována celým kladným číslem
popř.&nbsp;nulou. Prakticky jsme však omezeni hodnotami ležícími v&nbsp;rozsahu
0 až 255, protože priorita zprávy může být reprezentována jediným bajtem.</p>



<p><a name="k15"></a></p>
<h2 id="k15">15. Konfigurace prioritní fronty</h2>

<p>Aby bylo možné do zvolené fronty či do několika zvolených front posílat
zprávy s&nbsp;nastavenou prioritou, je nutné frontu/fronty náležitým způsobem
nakonfigurovat. Při deklaraci nové fronty pomocí
<strong>channel.queue_declare()</strong> můžeme použít nepovinný parametr
nazvaný <strong>arguments</strong>. Hodnotou tohoto parametru je mapa (slovník)
obsahující dvojice klíč-hodnota. V&nbsp;našem konkrétním případě musíme
specifikovat maximální možnou prioritu, což je teoreticky libovolné celé kladné
číslo, ovšem z&nbsp;praktických důvodů jsme omezeni hodnotou 255, protože
v&nbsp;přenosovém protokolu je pro prioritu určen jediný bajt (ovšem 256
priorit by mělo být více než dostačující pro prakticky všechny myslitelné
případy). Maximální povolená priorita se specifikuje dvojicí, jejímž klíčem je
řetězec <strong>x-max-priority</strong> a hodnotou zvolená priorita:</p>

<pre>
channel.queue_declare(queue=queue_name, <strong>arguments={"x-max-priority": max_priority}</strong>)
</pre>

<p>Následující funkce, kterou nalezneme ve skriptu <a
href="https://github.com/tisnik/message-queues-examples/blob/master/rabbit-mq/python/example11/rabbitmq_connect.py">rabbitmq_connect.py</a>,
umožňuje specifikovat maximální prioritu zpráv zařazovaných do fronty, přičemž
výchozí hodnotou bude priorita 10 (zprávy tedy budou moci mít prioritu
v&nbsp;rozsahu od 0 do 10, a to včetně obou krajních hodnot):</p>

<pre>
def <strong>open_channel</strong>(connection, queue_name='test', max_priority=10):
    <i># pokus o nové vytvoření fronty ve skutečnosti neovlivní již existující frontu</i>
    channel = connection.channel()
    channel.queue_declare(queue=queue_name, <strong>arguments={"x-max-priority": max_priority}</strong>)
    return channel
</pre>



<p><a name="k16"></a></p>
<h2 id="k16">16. Vymazání vybrané fronty</h2>

<p>V&nbsp;případě, že fronta, u níž chceme nastavit prioritu, již existuje,
nebude možné změnit její konfiguraci, tudíž ani specifikovat, že mají být
podporovány zprávy s&nbsp;prioritou. Takovou frontu můžeme nejdříve smazat,
například <a
href="https://github.com/tisnik/message-queues-examples/blob/master/rabbit-mq/python/example11/delete_queue.py">následujícím skriptem</a>:</p>

<pre>
<i>#!/usr/bin/env python</i>
from sys import argv, exit
from rabbitmq_connect import connect
&nbsp;
&nbsp;
def <strong>delete_queue</strong>(queue_name):
    connection = connect()
    channel = connection.channel()
    channel.queue_delete(queue=queue_name)
    connection.close()
&nbsp;
&nbsp;
if len(argv) &lt;= 1:
    print('Please provide queue name on the CLI')
    exit(1)
&nbsp;
delete_queue(argv[1])
</pre>

<p>Stav front před spuštěním tohoto skriptu může vypadat například takto:</p>

<pre>
$ <strong>sudo rabbitmqctl list_queues</strong>
&nbsp;
Listing queues
priority_queue        0
test    0
t1      2
t2      0
fronta2 6
fronta1 16
fronta3 16
</pre>

<p>Vymazání fronty pojmenované &bdquo;priority_queue&ldquo;:</p>

<pre>
$ <strong>python3 delete_queue.py priority_queue</strong>
</pre>

<p>Po opětovném vypsání seznamu všech front zjistíme, že fronta
&bdquo;priority_queue&ldquo; byla skutečně vymazána:</p>

<pre>
$ <strong>sudo rabbitmqctl list_queues</strong>
&nbsp;
Listing queues
test    0
t1      2
t2      0
fronta2 6
fronta1 16
fronta3 16
</pre>

<p><div class="rs-tip-major">Poznámka: smazání neexistující fronty není
chyba:</div></p>

<pre>
$ <strong>python3 delete_queue.py neexistujici-fronta</strong>
&nbsp;
$ <strong>echo $?</strong>
0
</pre>



<p><a name="k17"></a></p>
<h2 id="k17">17. Specifikace priority posílané zprávy</h2>

<p>Priorita zprávy poslané do fronty (která priority podporuje) se nastavuje
přes vlastnosti (<i>properties</i>) zprávy. V&nbsp;případě použití knihovny
Pika jsou vlastnosti zpráv uloženy do objektu typu
<strong>BasicProperties</strong>, který obsahuje všechny vlastnosti zprávy.
Samotná priorita se nastavuje v&nbsp;konstruktoru
<strong>BasicProperties</strong> pomocí pojmenovaného parametru
<strong>priority</strong>, který nastavíme na zvolenou prioritu (v&nbsp;našem
případě na hodnotu od 0 do 10):</p>

<pre>
prop = <strong>BasicProperties(priority=priority)</strong>
</pre>

<p>Zbylé vlastnosti zprávy obsahují výchozí hodnoty (<i>default</i>).</p>

<p>Ve chvíli, kdy již máme vytvořenou instanci objektu
<strong>BasicProperties</strong>, můžeme tento objekt použít při poslání
zprávy:</p>

<pre>
channel.basic_publish(exchange='',
                      routing_key='priority_queue_2',
                      body='Hello World! #{i} msg with priority {p}'.format(i=i, p=priority),
                      <strong>properties=prop</strong>)
</pre>

<p>Úplný <a
href="https://github.com/tisnik/message-queues-examples/blob/master/rabbit-mq/python/example11/enqueue_more_work.py">zdrojový kód producenta</a> posílajícího zprávy s&nbsp;různou prioritou vypadá
takto:</p>

<pre>
<i>#!/usr/bin/env python</i>
from sys import exit, argv
from rabbitmq_connect import connect, open_channel
from pika.spec import BasicProperties
&nbsp;
&nbsp;
def <strong>run_producer</strong>():
    connection = connect()
    channel = open_channel(connection, queue_name='priority_queue_2', max_priority=10)
&nbsp;
    for i in range(1, 11):
        priority = 5 * (i % 3)
        prop = BasicProperties(priority=priority)
        channel.basic_publish(exchange='',
                              routing_key='priority_queue_2',
                              body='Hello World! #{i} msg with priority {p}'.format(i=i, p=priority),
                              properties=prop)
&nbsp;
    connection.close()
&nbsp;
&nbsp;
run_producer()
</pre>

<p>Tohoto producenta spustíme zcela stejným způsobem, jako jakéhokoli jiného
producenta, s&nbsp;nímž jsme se až doposud setkali:</p>

<pre>
$ <strong>python3 enqueue_more_work.py</strong>
</pre>

<p>Samotný konzument se nemusí měnit &ndash; priorita zpráv slouží pouze pro
jejich zařazení do front a nemá vliv na to, jak bude vypadat přijatá
zpráva.</p>



<p><a name="k18"></a></p>
<h2 id="k18">18. Pořadí přijatých zpráv s&nbsp;prioritami</h2>

<p>Ve chvíli, kdy spustíme konzumenta zpráv:</p>

<pre>
<strong>$ python3 consumer.py priority_queue</strong>
</pre>

<p>By se postupně měly začít jednotlivé zprávy zpracovávat:</p>

<pre>
Received b'Hello World! #1 msg with priority 5'
Done processing b'Hello World! #1 msg with priority 5'
Received b'Hello World! #2 msg with priority 10'
Done processing b'Hello World! #2 msg with priority 10'
Received b'Hello World! #5 msg with priority 10'
Done processing b'Hello World! #5 msg with priority 10'
Received b'Hello World! #8 msg with priority 10'
Done processing b'Hello World! #8 msg with priority 10'
Received b'Hello World! #4 msg with priority 5'
Done processing b'Hello World! #4 msg with priority 5'
Received b'Hello World! #7 msg with priority 5'
Done processing b'Hello World! #7 msg with priority 5'
Received b'Hello World! #10 msg with priority 5'
Done processing b'Hello World! #10 msg with priority 5'
Received b'Hello World! #3 msg with priority 0'
Done processing b'Hello World! #3 msg with priority 0'
Received b'Hello World! #6 msg with priority 0'
Done processing b'Hello World! #6 msg with priority 0'
Received b'Hello World! #9 msg with priority 0'
Done processing b'Hello World! #9 msg with priority 0'
</pre>

<p>Povšimněte si ovšem pořadí zpracovaných zpráv, které jsem pro přehlednost
přepsal do tabulky:</p>

<table>
<tr><th>Pořadí</th><th>Zpráva #</th><th>Priorita</th></tr>
<tr><td>1</td><td>1</td><td>5</td></tr>
<tr><td>2</td><td>2</td><td>10</td></tr>
<tr><td>3</td><td>5</td><td>10</td></tr>
<tr><td>4</td><td>8</td><td>10</td></tr>
<tr><td>5</td><td>4</td><td>5</td></tr>
<tr><td>6</td><td>7</td><td>5</td></tr>
<tr><td>7</td><td>10</td><td>5</td></tr>
<tr><td>8</td><td>3</td><td>0</td></tr>
<tr><td>9</td><td>6</td><td>0</td></tr>
<tr><td>10</td><td>9</td><td>0</td></tr>
</table>

<p>Z&nbsp;předchozí tabulky je patrné, že zprávy skutečně byly (až na zprávu
zcela první) seřazeny podle priority, což ostatně odpovídá i specifikaci AMQP
&ndash; priorita zpráv ovlivňuje jejich zařazení do fronty, ovšem není zaručeno
zcela přesné pořadí.</p>

<p>Podobným způsobem budou zprávy uspořádány podle priority i po spuštění <a
href="https://github.com/tisnik/message-queues-examples/tree/master/rabbit-mq/python/example12">dvanáctého
příkladu</a>:</p>

<pre>
Waiting for messages in queue "priority_queue_3". To exit press CTRL+C
...
Received b'Hello World! #0 msg with priority 100'
Done processing b'Hello World! #0 msg with priority 100'
Received b'Hello World! #1 msg with priority 99'
Done processing b'Hello World! #1 msg with priority 99'
Received b'Hello World! #2 msg with priority 98'
Done processing b'Hello World! #2 msg with priority 98'
Received b'Hello World! #3 msg with priority 97'
Done processing b'Hello World! #3 msg with priority 97'
Received b'Hello World! #4 msg with priority 96'
Done processing b'Hello World! #4 msg with priority 96'
Received b'Hello World! #5 msg with priority 95'
...
...
...
Done processing b'Hello World! #94 msg with priority 6'
Received b'Hello World! #95 msg with priority 5'
Done processing b'Hello World! #95 msg with priority 5'
Received b'Hello World! #96 msg with priority 4'
Done processing b'Hello World! #96 msg with priority 4'
Received b'Hello World! #97 msg with priority 3'
Done processing b'Hello World! #97 msg with priority 3'
Received b'Hello World! #98 msg with priority 2'
Done processing b'Hello World! #98 msg with priority 2'
Received b'Hello World! #99 msg with priority 1'
Done processing b'Hello World! #99 msg with priority 1'
</pre>



<p><a name="k19"></a></p>
<h2 id="k19">19. Repositář s&nbsp;demonstračními příklady</h2>

<table>
<tr><th>Příklad</th><th>Skript</th><th>Popis</th><th>Cesta</th></tr>
<tr><td>6</td><td>rabbitmq_connect.py</td><td>společná část pro producenta i konzumenta</td><td><a href="https://github.com/tisnik/message-queues-examples/blob/master/rabbit-mq/python/example06/rabbitmq_connect.py">https://github.com/tisnik/message-queues-examples/blob/master/rabbit-mq/python/example06/rabbitmq_connect.py</a></td></tr>
<tr><td>6</td><td>consumer.py</td><td>implementace konzumenta (workera)</td><td><a href="https://github.com/tisnik/message-queues-examples/blob/master/rabbit-mq/python/example06/consumer.py">https://github.com/tisnik/message-queues-examples/blob/master/rabbit-mq/python/example06/consumer.py</a></td></tr>
<tr><td>6</td><td>enqueue_work.py</td><td>skript pro vložení jedné zprávy do fronty</td><td><a href="https://github.com/tisnik/message-queues-examples/blob/master/rabbit-mq/python/example06/enqueue_work.py">https://github.com/tisnik/message-queues-examples/blob/master/rabbit-mq/python/example06/enqueue_work.py</a></td></tr>
<tr><td>6</td><td>enqueue_more_work.py</td><td>skript pro vložení deseti zpráv do fronty</td><td><a href="https://github.com/tisnik/message-queues-examples/blob/master/rabbit-mq/python/example06/enqueue_more_work.py">https://github.com/tisnik/message-queues-examples/blob/master/rabbit-mq/python/example06/enqueue_more_work.py</a></td></tr>
<tr><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td></tr>
<tr><td>7</td><td>rabbitmq_connect.py</td><td>společná část pro producenta i konzumenta</td><td><a href="https://github.com/tisnik/message-queues-examples/blob/master/rabbit-mq/python/example07/rabbitmq_connect.py">https://github.com/tisnik/message-queues-examples/blob/master/rabbit-mq/python/example07/rabbitmq_connect.py</a></td></tr>
<tr><td>7</td><td>consumer.py</td><td>implementace konzumenta (workera)</td><td><a href="https://github.com/tisnik/message-queues-examples/blob/master/rabbit-mq/python/example07/consumer.py">https://github.com/tisnik/message-queues-examples/blob/master/rabbit-mq/python/example07/consumer.py</a></td></tr>
<tr><td>7</td><td>enqueue_work.py</td><td>skript pro vložení jedné zprávy do fronty</td><td><a href="https://github.com/tisnik/message-queues-examples/blob/master/rabbit-mq/python/example07/enqueue_work.py">https://github.com/tisnik/message-queues-examples/blob/master/rabbit-mq/python/example07/enqueue_work.py</a></td></tr>
<tr><td>7</td><td>enqueue_more_work.py</td><td>skript pro vložení deseti zpráv do fronty</td><td><a href="https://github.com/tisnik/message-queues-examples/blob/master/rabbit-mq/python/example07/enqueue_more_work.py">https://github.com/tisnik/message-queues-examples/blob/master/rabbit-mq/python/example07/enqueue_more_work.py</a></td></tr>
<tr><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td></tr>
<tr><td>8</td><td>rabbitmq_connect.py</td><td>společná část pro producenta i konzumenta</td><td><a href="https://github.com/tisnik/message-queues-examples/blob/master/rabbit-mq/python/example08/rabbitmq_connect.py">https://github.com/tisnik/message-queues-examples/blob/master/rabbit-mq/python/example08/rabbitmq_connect.py</a></td></tr>
<tr><td>8</td><td>consumer.py</td><td>implementace konzumenta (workera)</td><td><a href="https://github.com/tisnik/message-queues-examples/blob/master/rabbit-mq/python/example08/consumer.py">https://github.com/tisnik/message-queues-examples/blob/master/rabbit-mq/python/example08/consumer.py</a></td></tr>
<tr><td>8</td><td>enqueue_work.py</td><td>skript pro vložení jedné zprávy do fronty</td><td><a href="https://github.com/tisnik/message-queues-examples/blob/master/rabbit-mq/python/example08/enqueue_work.py">https://github.com/tisnik/message-queues-examples/blob/master/rabbit-mq/python/example08/enqueue_work.py</a></td></tr>
<tr><td>8</td><td>enqueue_more_work.py</td><td>skript pro vložení deseti zpráv do fronty</td><td><a href="https://github.com/tisnik/message-queues-examples/blob/master/rabbit-mq/python/example08/enqueue_more_work.py">https://github.com/tisnik/message-queues-examples/blob/master/rabbit-mq/python/example08/enqueue_more_work.py</a></td></tr>
<tr><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td></tr>
<tr><td>9</td><td>rabbitmq_connect.py</td><td>společná část pro producenta i konzumenta (podpora pro fanout)</td><td><a href="https://github.com/tisnik/message-queues-examples/blob/master/rabbit-mq/python/example09/rabbitmq_connect.py">https://github.com/tisnik/message-queues-examples/blob/master/rabbit-mq/python/example09/rabbitmq_connect.py</a></td></tr>
<tr><td>9</td><td>consumer.py</td><td>implementace konzumenta (workera)</td><td><a href="https://github.com/tisnik/message-queues-examples/blob/master/rabbit-mq/python/example09/consumer.py">https://github.com/tisnik/message-queues-examples/blob/master/rabbit-mq/python/example09/consumer.py</a></td></tr>
<tr><td>9</td><td>enqueue_work.py</td><td>rozeslání zpráv všem zvoleným frontám</td><td><a href="https://github.com/tisnik/message-queues-examples/blob/master/rabbit-mq/python/example09/enqueue_work.py">https://github.com/tisnik/message-queues-examples/blob/master/rabbit-mq/python/example09/enqueue_work.py</a></td></tr>
<tr><td>9</td><td>enqueue_more_work.py</td><td>rozeslání zpráv všem zvoleným frontám</td><td><a href="https://github.com/tisnik/message-queues-examples/blob/master/rabbit-mq/python/example09/enqueue_more_work.py">https://github.com/tisnik/message-queues-examples/blob/master/rabbit-mq/python/example09/enqueue_more_work.py</a></td></tr>
<tr><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td></tr>
<tr><td>10</td><td>rabbitmq_connect.py</td><td>společná část pro producenta i konzumenta (podpora pro témata)</td><td><a href="https://github.com/tisnik/message-queues-examples/blob/master/rabbit-mq/python/example10/rabbitmq_connect.py">https://github.com/tisnik/message-queues-examples/blob/master/rabbit-mq/python/example10/rabbitmq_connect.py</a></td></tr>
<tr><td>10</td><td>consumer.py</td><td>implementace konzumenta (workera)</td><td><a href="https://github.com/tisnik/message-queues-examples/blob/master/rabbit-mq/python/example10/consumer.py">https://github.com/tisnik/message-queues-examples/blob/master/rabbit-mq/python/example10/consumer.py</a></td></tr>
<tr><td>10</td><td>enqueue_more_work.py</td><td>poslání několika zpráv s&nbsp;různými tématy</td><td><a href="https://github.com/tisnik/message-queues-examples/blob/master/rabbit-mq/python/example10/enqueue_more_work.py">https://github.com/tisnik/message-queues-examples/blob/master/rabbit-mq/python/example10/enqueue_more_work.py</a></td></tr>
<tr><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td></tr>
<tr><td>11</td><td>rabbitmq_connect.py</td><td>společná část pro producenta i konzumenta (fronty s&nbsp;prioritou)</td><td><a href="https://github.com/tisnik/message-queues-examples/blob/master/rabbit-mq/python/example11/rabbitmq_connect.py">https://github.com/tisnik/message-queues-examples/blob/master/rabbit-mq/python/example11/rabbitmq_connect.py</a></td></tr>
<tr><td>11</td><td>consumer.py</td><td>implementace konzumenta (workera)</td><td><a href="https://github.com/tisnik/message-queues-examples/blob/master/rabbit-mq/python/example11/consumer.py">https://github.com/tisnik/message-queues-examples/blob/master/rabbit-mq/python/example11/consumer.py</a></td></tr>
<tr><td>11</td><td>enqueue_more_work.py</td><td>poslání zpráv s&nbsp;prioritou</td><td><a href="https://github.com/tisnik/message-queues-examples/blob/master/rabbit-mq/python/example11/enqueue_more_work.py">https://github.com/tisnik/message-queues-examples/blob/master/rabbit-mq/python/example11/enqueue_more_work.py</a></td></tr>
<tr><td>11</td><td>delete_queue.py</td><td>vymazání zvolené fronty</td><td><a href="https://github.com/tisnik/message-queues-examples/blob/master/rabbit-mq/python/example11/delete_queue.py">https://github.com/tisnik/message-queues-examples/blob/master/rabbit-mq/python/example11/delete_queue.py</a></td></tr>
<tr><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td></tr>
<tr><td>12</td><td>rabbitmq_connect.py</td><td>společná část pro producenta i konzumenta (fronty s&nbsp;prioritou)</td><td><a href="https://github.com/tisnik/message-queues-examples/blob/master/rabbit-mq/python/example12/rabbitmq_connect.py">https://github.com/tisnik/message-queues-examples/blob/master/rabbit-mq/python/example12/rabbitmq_connect.py</a></td></tr>
<tr><td>12</td><td>consumer.py</td><td>implementace konzumenta (workera)</td><td><a href="https://github.com/tisnik/message-queues-examples/blob/master/rabbit-mq/python/example12/consumer.py">https://github.com/tisnik/message-queues-examples/blob/master/rabbit-mq/python/example12/consumer.py</a></td></tr>
<tr><td>12</td><td>enqueue_more_work.py</td><td>poslání zpráv s&nbsp;prioritou</td><td><a href="https://github.com/tisnik/message-queues-examples/blob/master/rabbit-mq/python/example12/enqueue_more_work.py">https://github.com/tisnik/message-queues-examples/blob/master/rabbit-mq/python/example12/enqueue_more_work.py</a></td></tr>
<tr><td>12</td><td>delete_queue.py</td><td>vymazání zvolené fronty</td><td><a href="https://github.com/tisnik/message-queues-examples/blob/master/rabbit-mq/python/example12/delete_queue.py">https://github.com/tisnik/message-queues-examples/blob/master/rabbit-mq/python/example12/delete_queue.py</a></td></tr>
</table>



<p><a name="k20"></a></p>
<h2 id="k20">20. Odkazy na Internetu</h2>

<ol>

<li>Advanced Message Queuing Protocol<br />
<a href="https://www.amqp.org/">https://www.amqp.org/</a>
</li>

<li>Advanced Message Queuing Protocol na Wikipedii<br />
<a href="https://en.wikipedia.org/wiki/Advanced_Message_Queuing_Protocol">https://en.wikipedia.org/wiki/Advanced_Message_Queuing_Protocol</a>
</li>

<li>Dokumentace k&nbsp;příkazu <strong>rabbitmqctl</strong><br />
<a href="https://www.rabbitmq.com/rabbitmqctl.8.html">https://www.rabbitmq.com/rabbitmqctl.8.html</a>
</li>

<li>RabbitMQ<br />
<a href="https://www.rabbitmq.com/">https://www.rabbitmq.com/</a>
</li>

<li>RabbitMQ Tutorials<br />
<a href="https://www.rabbitmq.com/getstarted.html">https://www.rabbitmq.com/getstarted.html</a>
</li>

<li>RabbitMQ: Clients and Developer Tools<br />
<a href="https://www.rabbitmq.com/devtools.html">https://www.rabbitmq.com/devtools.html</a>
</li>

<li>RabbitMQ na Wikipedii<br />
<a href="https://en.wikipedia.org/wiki/RabbitMQ">https://en.wikipedia.org/wiki/RabbitMQ</a>
</li>

<li>Streaming Text Oriented Messaging Protocol<br />
<a href="https://en.wikipedia.org/wiki/Streaming_Text_Oriented_Messaging_Protocol">https://en.wikipedia.org/wiki/Streaming_Text_Oriented_Messaging_Protocol</a>
</li>

<li>Message Queuing Telemetry Transport<br />
<a href="https://en.wikipedia.org/wiki/MQTT">https://en.wikipedia.org/wiki/MQTT</a>
</li>

<li>Erlang<br />
<a href="http://www.erlang.org/">http://www.erlang.org/</a>
</li>

<li>pika 0.12.0 na PyPi<br />
<a href="https://pypi.org/project/pika/">https://pypi.org/project/pika/</a>
</li>

<li>Introduction to Pika<br />
<a href="https://pika.readthedocs.io/en/stable/">https://pika.readthedocs.io/en/stable/</a>
</li>

<li>Langohr: An idiomatic Clojure client for RabbitMQ that embraces the AMQP 0.9.1 model<br />
<a href="http://clojurerabbitmq.info/">http://clojurerabbitmq.info/</a>
</li>

<li>AMQP 0-9-1 Model Explained<br />
<a href="http://www.rabbitmq.com/tutorials/amqp-concepts.html">http://www.rabbitmq.com/tutorials/amqp-concepts.html</a>
</li>

<li>Part 1: RabbitMQ for beginners - What is RabbitMQ?<br />
<a href="https://www.cloudamqp.com/blog/2015-05-18-part1-rabbitmq-for-beginners-what-is-rabbitmq.html">https://www.cloudamqp.com/blog/2015-05-18-part1-rabbitmq-for-beginners-what-is-rabbitmq.html</a>
</li>

<li>Downloading and Installing RabbitMQ<br />
<a href="https://www.rabbitmq.com/download.html">https://www.rabbitmq.com/download.html</a>
</li>

<li>celery na PyPi<br />
<a href="https://pypi.org/project/celery/">https://pypi.org/project/celery/</a>
</li>

<li>Databáze Redis (nejenom) pro vývojáře používající Python <br />
<a href="https://www.root.cz/clanky/databaze-redis-nejenom-pro-vyvojare-pouzivajici-python/">https://www.root.cz/clanky/databaze-redis-nejenom-pro-vyvojare-pouzivajici-python/</a>
</li>

<li>Databáze Redis (nejenom) pro vývojáře používající Python (dokončení)<br />
<a href="https://www.root.cz/clanky/databaze-redis-nejenom-pro-vyvojare-pouzivajici-python-dokonceni/">https://www.root.cz/clanky/databaze-redis-nejenom-pro-vyvojare-pouzivajici-python-dokonceni/</a>
</li>

<li>Použití nástroje RQ (Redis Queue) pro správu úloh zpracovávaných na pozadí<br />
<a href="https://www.root.cz/clanky/pouziti-nastroje-rq-redis-queue-pro-spravu-uloh-zpracovavanych-na-pozadi/">https://www.root.cz/clanky/pouziti-nastroje-rq-redis-queue-pro-spravu-uloh-zpracovavanych-na-pozadi/</a>
</li>

<li>Redis Queue (RQ)<br />
<a href="https://www.fullstackpython.com/redis-queue-rq.html">https://www.fullstackpython.com/redis-queue-rq.html</a>
</li>

<li>Python Celery &amp; RabbitMQ Tutorial<br />
<a href="https://tests4geeks.com/python-celery-rabbitmq-tutorial/">https://tests4geeks.com/python-celery-rabbitmq-tutorial/</a>
</li>

<li>Flower: Real-time Celery web-monitor<br />
<a href="http://docs.celeryproject.org/en/latest/userguide/monitoring.html#flower-real-time-celery-web-monitor">http://docs.celeryproject.org/en/latest/userguide/monitoring.html#flower-real-time-celery-web-monitor</a>
</li>

<li>Asynchronous Tasks With Django and Celery<br />
<a href="https://realpython.com/asynchronous-tasks-with-django-and-celery/">https://realpython.com/asynchronous-tasks-with-django-and-celery/</a>
</li>

<li>First Steps with Celery<br />
<a href="http://docs.celeryproject.org/en/latest/getting-started/first-steps-with-celery.html">http://docs.celeryproject.org/en/latest/getting-started/first-steps-with-celery.html</a>
</li>

<li>node-celery<br />
<a href="https://github.com/mher/node-celery">https://github.com/mher/node-celery</a>
</li>

<li>Full Stack Python: web development<br />
<a href="https://www.fullstackpython.com/web-development.html">https://www.fullstackpython.com/web-development.html</a>
</li>

<li>Introducing RQ<br />
<a href="https://nvie.com/posts/introducing-rq/">https://nvie.com/posts/introducing-rq/</a>
</li>

<li>Asynchronous Tasks with Flask and Redis Queue<br />
<a href="https://testdriven.io/asynchronous-tasks-with-flask-and-redis-queue">https://testdriven.io/asynchronous-tasks-with-flask-and-redis-queue</a>
</li>

<li>rq-dashboard<br />
<a href="https://github.com/eoranged/rq-dashboard">https://github.com/eoranged/rq-dashboard</a>
</li>

<li>Stránky projektu Redis<br />
<a href="https://redis.io/">https://redis.io/</a>
</li>

<li>Introduction to Redis<br />
<a href="https://redis.io/topics/introduction">https://redis.io/topics/introduction</a>
</li>

<li>Try Redis<br />
<a href="http://try.redis.io/">http://try.redis.io/</a>
</li>

<li>Redis tutorial, April 2010 (starší, ale pěkně udělaný)<br />
<a href="https://static.simonwillison.net/static/2010/redis-tutorial/">https://static.simonwillison.net/static/2010/redis-tutorial/</a>
</li>

<li>Python Redis<br />
<a href="https://redislabs.com/lp/python-redis/">https://redislabs.com/lp/python-redis/</a>
</li>

<li>Redis: key-value databáze v paměti i na disku<br />
<a href="https://www.zdrojak.cz/clanky/redis-key-value-databaze-v-pameti-i-na-disku/">https://www.zdrojak.cz/clanky/redis-key-value-databaze-v-pameti-i-na-disku/</a>
</li>

<li>Praktický úvod do Redis (1): vaše distribuovaná NoSQL cache<br />
<a href="http://www.cloudsvet.cz/?p=253">http://www.cloudsvet.cz/?p=253</a>
</li>

<li>Praktický úvod do Redis (2): transakce<br />
<a href="http://www.cloudsvet.cz/?p=256">http://www.cloudsvet.cz/?p=256</a>
</li>

<li>Praktický úvod do Redis (3): cluster<br />
<a href="http://www.cloudsvet.cz/?p=258">http://www.cloudsvet.cz/?p=258</a>
</li>

<li>Connection pool<br />
<a href="https://en.wikipedia.org/wiki/Connection_pool">https://en.wikipedia.org/wiki/Connection_pool</a>
</li>

<li>Instant Redis Sentinel Setup<br />
<a href="https://github.com/ServiceStack/redis-config">https://github.com/ServiceStack/redis-config</a>
</li>

<li>How to install REDIS in LInux<br />
<a href="https://linuxtechlab.com/how-install-redis-server-linux/">https://linuxtechlab.com/how-install-redis-server-linux/</a>
</li>

<li>Redis RDB Dump File Format<br />
<a href="https://github.com/sripathikrishnan/redis-rdb-tools/wiki/Redis-RDB-Dump-File-Format">https://github.com/sripathikrishnan/redis-rdb-tools/wiki/Redis-RDB-Dump-File-Format</a>
</li>

<li>Lempel–Ziv–Welch<br />
<a href="https://en.wikipedia.org/wiki/Lempel%E2%80%93Ziv%E2%80%93Welch">https://en.wikipedia.org/wiki/Lempel%E2%80%93Ziv%E2%80%93Welch</a>
</li>

<li>Redis Persistence<br />
<a href="https://redis.io/topics/persistence">https://redis.io/topics/persistence</a>
</li>

<li>Redis persistence demystified<br />
<a href="http://oldblog.antirez.com/post/redis-persistence-demystified.html">http://oldblog.antirez.com/post/redis-persistence-demystified.html</a>
</li>

<li>Redis reliable queues with Lua scripting<br />
<a href="http://oldblog.antirez.com/post/250">http://oldblog.antirez.com/post/250</a>
</li>

<li>Ost (knihovna)<br />
<a href="https://github.com/soveran/ost">https://github.com/soveran/ost</a>
</li>

<li>NoSQL<br />
<a href="https://en.wikipedia.org/wiki/NoSQL">https://en.wikipedia.org/wiki/NoSQL</a>
</li>

<li>Shard (database architecture)<br />
<a href="https://en.wikipedia.org/wiki/Shard_%28database_architecture%29">https://en.wikipedia.org/wiki/Shard_%28database_architecture%29</a>
</li>

<li>What is sharding and why is it important?<br />
<a href="https://stackoverflow.com/questions/992988/what-is-sharding-and-why-is-it-important">https://stackoverflow.com/questions/992988/what-is-sharding-and-why-is-it-important</a>
</li>

<li>What Is Sharding?<br />
<a href="https://btcmanager.com/what-sharding/">https://btcmanager.com/what-sharding/</a>
</li>

<li>Redis clients<br />
<a href="https://redis.io/clients">https://redis.io/clients</a>
</li>

<li>Category:Lua-scriptable software<br />
<a href="https://en.wikipedia.org/wiki/Category:Lua-scriptable_software">https://en.wikipedia.org/wiki/Category:Lua-scriptable_software</a>
</li>

<li>Seriál Programovací jazyk Lua<br />
<a href="https://www.root.cz/serialy/programovaci-jazyk-lua/">https://www.root.cz/serialy/programovaci-jazyk-lua/</a>
</li>

<li>Redis memory usage<br />
<a href="http://nosql.mypopescu.com/post/1010844204/redis-memory-usage">http://nosql.mypopescu.com/post/1010844204/redis-memory-usage</a>
</li>

<li>Ukázka konfigurace Redisu pro lokální testování<br />
<a href="https://github.com/tisnik/presentations/blob/master/redis/redis.conf">https://github.com/tisnik/presentations/blob/master/redis/redis.conf</a>
</li>

<li>Resque<br />
<a href="https://github.com/resque/resque">https://github.com/resque/resque</a>
</li>

<li>Nested transaction<br />
<a href="https://en.wikipedia.org/wiki/Nested_transaction">https://en.wikipedia.org/wiki/Nested_transaction</a>
</li>

<li>Publish–subscribe pattern<br />
<a href="https://en.wikipedia.org/wiki/Publish%E2%80%93subscribe_pattern">https://en.wikipedia.org/wiki/Publish%E2%80%93subscribe_pattern</a>
</li>

<li>Messaging pattern<br />
<a href="https://en.wikipedia.org/wiki/Messaging_pattern">https://en.wikipedia.org/wiki/Messaging_pattern</a>
</li>

<li>Using pipelining to speedup Redis queries<br />
<a href="https://redis.io/topics/pipelining">https://redis.io/topics/pipelining</a>
</li>

<li>Pub/Sub<br />
<a href="https://redis.io/topics/pubsub">https://redis.io/topics/pubsub</a>
</li>

<li>ZeroMQ distributed messaging<br />
<a href="http://zeromq.org/">http://zeromq.org/</a>
</li>

<li>ZeroMQ: Modern &amp; Fast Networking Stack<br />
<a href="https://www.igvita.com/2010/09/03/zeromq-modern-fast-networking-stack/">https://www.igvita.com/2010/09/03/zeromq-modern-fast-networking-stack/</a>
</li>

<li>Publish/Subscribe paradigm: Why must message classes not know about their subscribers?<br />
<a href="https://stackoverflow.com/questions/2908872/publish-subscribe-paradigm-why-must-message-classes-not-know-about-their-subscr">https://stackoverflow.com/questions/2908872/publish-subscribe-paradigm-why-must-message-classes-not-know-about-their-subscr</a>
</li>

<li>Python &amp; Redis PUB/SUB<br />
<a href="https://medium.com/@johngrant/python-redis-pub-sub-6e26b483b3f7">https://medium.com/@johngrant/python-redis-pub-sub-6e26b483b3f7</a>
</li>

<li>Message broker<br />
<a href="https://en.wikipedia.org/wiki/Message_broker">https://en.wikipedia.org/wiki/Message_broker</a>
</li>

<li>RESP Arrays<br />
<a href="https://redis.io/topics/protocol#array-reply">https://redis.io/topics/protocol#array-reply</a>
</li>

<li>Redis Protocol specification<br />
<a href="https://redis.io/topics/protocol">https://redis.io/topics/protocol</a>
</li>

<li>Redis Pub/Sub: Intro Guide<br />
<a href="https://www.redisgreen.net/blog/pubsub-intro/">https://www.redisgreen.net/blog/pubsub-intro/</a>
</li>

<li>Redis Pub/Sub: Howto Guide<br />
<a href="https://www.redisgreen.net/blog/pubsub-howto/">https://www.redisgreen.net/blog/pubsub-howto/</a>
</li>

<li>Comparing Publish-Subscribe Messaging and Message Queuing<br />
<a href="https://dzone.com/articles/comparing-publish-subscribe-messaging-and-message">https://dzone.com/articles/comparing-publish-subscribe-messaging-and-message</a>
</li>

<li>Apache Kafka<br />
<a href="https://kafka.apache.org/">https://kafka.apache.org/</a>
</li>

<li>Iron<br />
<a href="http://www.iron.io/mq">http://www.iron.io/mq</a>
</li>

<li>kue (založeno na Redisu, určeno pro node.js)<br />
<a href="https://github.com/Automattic/kue">https://github.com/Automattic/kue</a>
</li>

<li>Cloud Pub/Sub<br />
<a href="https://cloud.google.com/pubsub/">https://cloud.google.com/pubsub/</a>
</li>

<li>Introduction to Redis Streams<br />
<a href="https://redis.io/topics/streams-intro">https://redis.io/topics/streams-intro</a>
</li>

<li>glob (programming)<br />
<a href="https://en.wikipedia.org/wiki/Glob_(programming)">https://en.wikipedia.org/wiki/Glob_(programming)</a>
</li>

<li>Why and how Pricing Assistant migrated from Celery to RQ - Paris.py<br />
<a href="https://www.slideshare.net/sylvinus/why-and-how-pricing-assistant-migrated-from-celery-to-rq-parispy-2">https://www.slideshare.net/sylvinus/why-and-how-pricing-assistant-migrated-from-celery-to-rq-parispy-2</a>
</li>

<li>Enqueueing internals<br />
<a href="http://python-rq.org/contrib/">http://python-rq.org/contrib/</a>
</li>

<li>queue — A synchronized queue class<br />
<a href="https://docs.python.org/3/library/queue.html">https://docs.python.org/3/library/queue.html</a>
</li>

<li>Queues<br />
<a href="http://queues.io/">http://queues.io/</a>
</li>

<li>Windows Subsystem for Linux Documentation<br />
<a href="https://docs.microsoft.com/en-us/windows/wsl/about">https://docs.microsoft.com/en-us/windows/wsl/about</a>
</li>

<li>RestMQ<br />
<a href="http://restmq.com/">http://restmq.com/</a>
</li>

<li>ActiveMQ<br />
<a href="http://activemq.apache.org/">http://activemq.apache.org/</a>
</li>

<li>Amazon MQ<br />
<a href="https://aws.amazon.com/amazon-mq/">https://aws.amazon.com/amazon-mq/</a>
</li>

<li>Amazon Simple Queue Service<br />
<a href="https://aws.amazon.com/sqs/">https://aws.amazon.com/sqs/</a>
</li>

<li>Celery: Distributed Task Queue<br />
<a href="http://www.celeryproject.org/">http://www.celeryproject.org/</a>
</li>

<li>Disque, an in-memory, distributed job queue<br />
<a href="https://github.com/antirez/disque">https://github.com/antirez/disque</a>
</li>

<li>rq-dashboard<br />
<a href="https://github.com/eoranged/rq-dashboard">https://github.com/eoranged/rq-dashboard</a>
</li>

<li>Projekt RQ na PyPi<br />
<a href="https://pypi.org/project/rq/">https://pypi.org/project/rq/</a>
</li>

<li>rq-dashboard 0.3.12<br />
<a href="https://pypi.org/project/rq-dashboard/">https://pypi.org/project/rq-dashboard/</a>
</li>

<li>Job queue<br />
<a href="https://en.wikipedia.org/wiki/Job_queue">https://en.wikipedia.org/wiki/Job_queue</a>
</li>

<li>Why we moved from Celery to RQ<br />
<a href="https://frappe.io/blog/technology/why-we-moved-from-celery-to-rq">https://frappe.io/blog/technology/why-we-moved-from-celery-to-rq</a>
</li>

<li>Running multiple workers using Celery<br />
<a href="https://serverfault.com/questions/655387/running-multiple-workers-using-celery">https://serverfault.com/questions/655387/running-multiple-workers-using-celery</a>
</li>

<li>celery — Distributed processing<br />
<a href="http://docs.celeryproject.org/en/latest/reference/celery.html">http://docs.celeryproject.org/en/latest/reference/celery.html</a>
</li>

<li>Chains<br />
<a href="https://celery.readthedocs.io/en/latest/userguide/canvas.html#chains">https://celery.readthedocs.io/en/latest/userguide/canvas.html#chains</a>
</li>

<li>Routing<br />
<a href="http://docs.celeryproject.org/en/latest/userguide/routing.html#automatic-routing">http://docs.celeryproject.org/en/latest/userguide/routing.html#automatic-routing</a>
</li>

<li>Celery Distributed Task Queue in Go<br />
<a href="https://github.com/gocelery/gocelery/">https://github.com/gocelery/gocelery/</a>
</li>

<li>Python Decorators<br />
<a href="https://wiki.python.org/moin/PythonDecorators">https://wiki.python.org/moin/PythonDecorators</a>
</li>

<li>Periodic Tasks<br />
<a href="http://docs.celeryproject.org/en/latest/userguide/periodic-tasks.html">http://docs.celeryproject.org/en/latest/userguide/periodic-tasks.html</a>
</li>

<li>celery.schedules<br />
<a href="http://docs.celeryproject.org/en/latest/reference/celery.schedules.html#celery.schedules.crontab">http://docs.celeryproject.org/en/latest/reference/celery.schedules.html#celery.schedules.crontab</a>
</li>

<li>Pros and cons to use Celery vs. RQ<br />
<a href="https://stackoverflow.com/questions/13440875/pros-and-cons-to-use-celery-vs-rq">https://stackoverflow.com/questions/13440875/pros-and-cons-to-use-celery-vs-rq</a>
</li>

<li>Priority queue<br />
<a href="https://en.wikipedia.org/wiki/Priority_queue">https://en.wikipedia.org/wiki/Priority_queue</a>
</li>

</ol>



<p></p><p></p>
<p><small>Autor: <a href="http://www.fit.vutbr.cz/~tisnovpa">Pavel Tišnovský</a> &nbsp; 2019</small></p>
</body>
</html>

