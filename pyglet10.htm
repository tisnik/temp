<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
        "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html>
<head>
<title>Multimediální knihovna Pyglet - tvorba procedurálních textur</title>
<meta name="Author" content="Pavel Tisnovsky" />
<meta name="Generator" content="vim" />
<meta http-equiv="content-type" content="text/html; charset=utf-8" />
<style type="text/css">
         body {color:#000000; background:#ffffff;}
         h1  {font-family: arial, helvetica, sans-serif; color:#ffffff; background-color:#c00000; text-align:center; padding-left:1em}
         h2  {font-family: arial, helvetica, sans-serif; color:#ffffff; background-color:#0000c0; padding-left:1em; text-align:left}
         h3  {font-family: arial, helvetica, sans-serif; color:#000000; background-color:#c0c0c0; padding-left:1em; text-align:left}
         h4  {font-family: arial, helvetica, sans-serif; color:#000000; background-color:#e0e0e0; padding-left:1em; text-align:left}
         a   {font-family: arial, helvetica, sans-serif;}
         li  {font-family: arial, helvetica, sans-serif; color:#000000; text-align:justify; width:450px;}
         ol  {font-family: arial, helvetica, sans-serif; color:#000000; text-align:justify; width:450px;}
         ul  {font-family: arial, helvetica, sans-serif; color:#000000; text-align:justify; width:450px;}
         p   {font-family: arial, helvetica, sans-serif; color:#000000; text-align:justify;}
         pre {background:#e0e0e0}
</style>
</head>

<body>

<h1>Multimediální knihovna Pyglet - tvorba procedurálních textur</h1>

<h3>Pavel Tišnovský</h3>

<p></p>

<h1>Úvodník</h1>

<p></p>



<h2>Obsah</h2>

<p><a href="#k01">*** 1. Multimediální knihovna Pyglet &ndash; tvorba procedurálních textur</a></p>
<p><a href="#k02">*** 2. Moaré s&nbsp;kružnicovým vzorkem</a></p>
<p><a href="#k03">*** 3. První demonstrační příklad &ndash; základní moaré s&nbsp;kružnicovým vzorkem</a></p>
<p><a href="#k04">*** 4. Druhý demonstrační příklad &ndash; výběr barvové palety</a></p>
<p><a href="#k05">*** 5. Rozšíření repertoáru funkcí při tvorbě moaré</a></p>
<p><a href="#k06">*** 6. Třetí demonstrační příklad &ndash; použití dalších typů funkcí při tvorbě moaré</a></p>
<p><a href="#k07">*** 7. </a></p>
<p><a href="#k08">*** 8. </a></p>
<p><a href="#k09">*** 9. </a></p>
<p><a href="#k10">*** 10. </a></p>
<p><a href="#k11">*** 11. </a></p>
<p><a href="#k12">*** 12. </a></p>
<p><a href="#k13">*** 13. </a></p>
<p><a href="#k14">*** 14. </a></p>
<p><a href="#k15">*** 15. Repositář s&nbsp;demonstračními příklady</a></p>
<p><a href="#k16">*** 16. Odkazy na Internetu</a></p>



<p><a name="k01"></a></p>
<h2 id="k01">1. Multimediální knihovna Pyglet &ndash; tvorba procedurálních textur</h2>

*** image ***
<p><i>Obrázek 1: Procedurální textura použitá pro vykreslení jednoduchého modelu planety.</i></p>



<p><a name="k02"></a></p>
<h2 id="k02">2. Moaré s&nbsp;kružnicovým vzorkem</h2>

<p>Velmi zajímavý a přitom jednoduše vygenerovatelný vzorek založený na efektu takzvaného moaré vytvořil John Connett z&nbsp;Minnesotské univerzity. O tomto vzorku, který ve své podstatě názorně ukazuje vliv aliasu při tvorbě rastrových obrázků, později pojednal i A.&nbsp;K.&nbsp;Dewdney v&nbsp;časopise <i>Scientific American</i>. Tento vzorek je generovaný velmi jednoduchým způsobem: každému pixelu ve vytvářeném rastrovém obrázku (pixmapě) je přiřazena dvojice souřadnic <i>[x, y]</i>. Tyto souřadnice obecně neodpovídají celočíselným indexům pixelu, které můžeme například označit <i>[i, j]</i>. Posléze je pro každý pixel vypočtena hodnota <i>z</i> podle vztahu <i>z=x<sup>2</sup>+y<sup>2</sup></i>. To je vše &ndash; pouze se na základě vypočtené hodnoty <i>z</i> vybere vhodná barva z&nbsp;barvové palety a pixel se obarví.</p>

*** image ***
<p><i>Obrázek 2: Moaré s&nbsp;kružnicovým vzorkem.</i></p>

<p>Tímto přímočarým a jednoduchým způsobem je možné vytvářet fantastické vzorky, pouze stačí měnit barvovou paletu (ideální jsou plynulé přechody mezi barvami &ndash; <i>gradient</i>) a měřítko, pomocí kterého se převádí celočíselné pozice pixelů v&nbsp;rastru <i>[i, j]</i> na souřadnice <i>[x, y]</i>.</p>

*** image ***
<p><i>Obrázek 3: Mez zvětšení, při kterém již kružnicový vzorek začíná mizet.</i></p>

<p>To, že moaré s&nbsp;kružnicovým vzorkem netvoří fraktální strukturu (nelze ho libovolně zvětšovat, při určitém zvětšení textura zmizí), však nic nemění na tom, že se pomocí něho dají vytvářet zajímavé obrázky a textury, proto si jeho tvorbu podrobněji popíšeme v&nbsp;následujících dvou kapitolách. <i>Praktická poznámka:</i> pro 3D textury není tento vzorek vhodný, protože při různém pohledu na scénu (natáčení, přibližování apod.) dochází k&nbsp;několikanásobnému aliasu, který se projevuje nežádoucím poblikáváním a aplikace antialiasingu naopak může zcela vymazat původní detaily v&nbsp;textuře.</p>

*** image ***
<p><i>Obrázek 4: Při určitém měřítku narazíme na limit, pod kterým již nevidíme další detaily (viz střed obrázku, při jehož zvětšení již další detaily nebudou patrné).</i></p>



<p><a name="k03"></a></p>
<h2 id="k03">3. První demonstrační příklad &ndash; základní moaré s&nbsp;kružnicovým vzorkem</h2>

<pre>
#!/usr/bin/env python

# Vytvoreni textury s "kruznicovym moare"

from PIL import Image

# textura by mela byt ctvercova a jeji sirka i vyska by mela byt
# mocninou cisla 2
IMAGE_WIDTH = 256
IMAGE_HEIGHT = 256


# Funkce provadejici vypocet moare s kruznicovym vzorkem
def recalc_circle_pattern(image, xmin, ymin, xmax, ymax):
    width, height = image.size       # rozmery obrazku
    stepx = (xmax - xmin)/width
    stepy = (ymax - ymin)/height
    print(xmin, xmax, ymin, ymax, width, height, stepx, stepy)

    y1 = ymin
    for y in range(0, height):
        x1 = xmin
        for x in range(0, width):
            x1 += stepx
            x2 = x1 * x1
            y2 = y1 * y1
            i = (int)(x2 + y2) &amp; 255
            color = (i, i, i)
            image.putpixel((x, y), color)
        y1 += stepy


for i in range(0, 50, 10):
    image = Image.new("RGB", (IMAGE_WIDTH, IMAGE_HEIGHT))
    mez = (2 &lt;&lt; 5) + i * 2.5
    recalc_circle_pattern(image, -mez, -mez, mez, mez)
    fileName = "patternA{index:02d}.png".format(index=i)
    image.save(fileName)
</pre>

*** image ***
<p><i>Obrázek 5: </i></p>



<p><a name="k04"></a></p>
<h2 id="k04">4. Druhý demonstrační příklad &ndash; výběr barvové palety</h2>

<pre>
#!/usr/bin/env python

# Vytvoreni textury s "kruznicovym moare"

from PIL import Image
import palette_blues
import palette_greens
import palette_gold
import palette_ice
import palette_mandmap

# textura by mela byt ctvercova a jeji sirka i vyska by mela byt
# mocninou cisla 2
IMAGE_WIDTH = 256
IMAGE_HEIGHT = 256


# Funkce provadejici vypocet moare s kruznicovym vzorkem
def recalc_circle_pattern(image, palette, xmin, ymin, xmax, ymax):
    width, height = image.size       # rozmery obrazku
    stepx = (xmax - xmin)/width
    stepy = (ymax - ymin)/height

    y1 = ymin
    for y in range(0, height):
        x1 = xmin
        for x in range(0, width):
            x1 += stepx
            x2 = x1 * x1
            y2 = y1 * y1
            i = (int)(x2 + y2) &amp; 255
            color = (palette[i][0], palette[i][1], palette[i][2])
            image.putpixel((x, y), color)
        y1 += stepy


mez = (2 &lt;&lt; 5) + 50 * 2.5
image = Image.new("RGB", (IMAGE_WIDTH, IMAGE_HEIGHT))

image_pals = ((palette_blues.palette,   "blues"),
              (palette_greens.palette,  "greens"),
              (palette_gold.palette,    "gold"),
              (palette_ice.palette,     "ice"),
              (palette_mandmap.palette, "mandmap"))

for image_pal in image_pals:
    print(image_pal[1])
    recalc_circle_pattern(image, image_pal[0], -mez, -mez, mez, mez)
    image.save("patternB_{name}.png".format(name=image_pal[1]))
</pre>

*** image ***
<p><i>Obrázek 6: </i></p>

*** image ***
<p><i>Obrázek 7: </i></p>



<p><a name="k05"></a></p>
<h2 id="k05">5. Rozšíření repertoáru funkcí při tvorbě moaré</h2>

<p>Předchozí dva příklady je možné rozšířit o volbu dalších funkcí, které se použijí při výpočtu moaré. Výběr funkcí je takřka libovolný, pouze je žádoucí, aby při výpočtech docházelo k&nbsp;přetékání přes hodnotu 255 &ndash; tím vzniká požadovaný efekt tvořící základ vzorku. Některé níže uvedené &bdquo;vhodné&ldquo; funkce je jsou vypsány v&nbsp;tabulce:</p>

<table>
<tr><th>Označení funkce</th><th>Tvar funkce</th></tr>
<tr><td>circle</td><td>z<sub>factor</sub>&times;(x &times; x + y &times; y)</td></tr>
<tr><td>anticircle</td><td>z<sub>factor</sub>&times;(x &times; x - y &times; y)</td></tr>
<tr><td>xyfun</td><td>z<sub>factor</sub>&times;(x &times; x + xy<sub>factor</sub> &times; x &times; y + y &times; y)</td></tr>
<tr><td>x3y3</td><td>z<sub>factor</sub>&times;(x &times; x &times; x + y &times; y &times; y)</td></tr>
<tr><td>x4y4</td><td>z<sub>factor</sub>&times;(x &times; x &times; x &times; x + y &times; y &times; y &times; y)</td></tr>
<tr><td>x3y3_xy</td><td>z<sub>factor</sub>&times;(x &times; x &times; x + y &times; y &times; y) / (x &times; y)</td></tr>
<tr><td>xpy_xmy</td><td>z<sub>factor</sub>&times;(x + y) / (x - y)</td></tr>
</table>

<p><i>Obrázek 8: Moaré vypočtené s&nbsp;pomocí funkce nazvané x3y3.</i></p>

<p><i>Obrázek 9: Další možnosti tvorby moaré.</i></p>



<p><a name="k06"></a></p>
<h2 id="k06">6. Třetí demonstrační příklad &ndash; použití dalších typů funkcí při tvorbě moaré</h2>

<pre>
#!/usr/bin/env python

# Vytvoreni textury s "kruznicovym moare"

from PIL import Image
import palette_blues
import palette_greens
import palette_gold
import palette_ice
import palette_mandmap

# textura by mela byt ctvercova a jeji sirka i vyska by mela byt
# mocninou cisla 2
IMAGE_WIDTH = 256
IMAGE_HEIGHT = 256


# Funkce provadejici vypocet moare s kruznicovym vzorkem
def recalc_circle_pattern(image, palette, xmin, ymin, xmax, ymax, function):
    width, height = image.size       # rozmery obrazku
    stepx = (xmax - xmin)/width
    stepy = (ymax - ymin)/height

    y1 = ymin
    for y in range(0, height):
        x1 = xmin
        for x in range(0, width):
            x1 += stepx
            val = function(x1, y1)
            i = int(val) &amp; 255
            color = (palette[i][0], palette[i][1], palette[i][2])
            image.putpixel((x, y), color)
        y1 += stepy


image = Image.new("RGB", (IMAGE_WIDTH, IMAGE_HEIGHT))

mez = (2 &lt;&lt; 5) + 30 * 2.5
recalc_circle_pattern(image, palette_mandmap.palette, -mez, -mez, mez, mez, lambda x,y : x*x + y*y)
image.save("patternC_circle.png")

mez = (2 &lt;&lt; 5) + 30 * 2.5
recalc_circle_pattern(image, palette_mandmap.palette, -mez, -mez, mez, mez, lambda x,y : x*x - y*y)
image.save("patternC_anticircle.png")

mez = 20.0
recalc_circle_pattern(image, palette_mandmap.palette, -mez, -mez, mez, mez, lambda x,y : x**3 + y**3)
image.save("patternC_x3y3.png")

mez = 20.0
recalc_circle_pattern(image, palette_mandmap.palette, -mez, -mez, mez, mez, lambda x,y : x**4 + y**4)
image.save("patternC_x4y4.png")

mez = 90.0
recalc_circle_pattern(image, palette_mandmap.palette, -mez, -mez, mez, mez, lambda x,y : x*x + y*y + x*y*1.5)
image.save("patternC_var1.png")

mez = 20.0
recalc_circle_pattern(image, palette_mandmap.palette, -mez, -mez, mez, mez, lambda x,y : x*x*y + y*y*x)
image.save("patternC_var2.png")
</pre>



<p><a name="k07"></a></p>
<h2 id="k07">7. Algoritmy pro vykreslení textury &bdquo;plasmy&ldquo;</h2>

<p>V&nbsp;počítačové grafice, zejména v&nbsp;demech, byl velmi oblíbený efekt plasmy, ať už vykreslený jako statický obrázek, či animovaná sekvence postupně se měnící plasmy. Plasmu je možné vytvořit několika způsoby, typicky metodou rekurzivního dělení čtverce, Fourierovou syntézou či rekurzivním dělením plochy. Nejdříve si stručně popíšeme metodu rekurzivního dělení čtverce.</p>

*** image ***
<p><i>Obrázek : </i></p>

<p>Obrázek plasmy se v&nbsp;tomto případě generuje upraveným midpoint algoritmem (algoritmem posunu středního bodu) rozšířeného do dvourozměrného prostoru, přičemž čtverec je nahrazen rastrovým obrázkem (pro jednoduchost ve stupních šedi), kde pozice každého pixelu odpovídá souřadnicím bodu v&nbsp;rovině <i>x-y</i> a barva pixelu, tj.&nbsp;úroveň šedé, zbývající <i>z</i>-ové souřadnici bodu. Generování plasmy začíná v&nbsp;rozích rastrového obrázku a v&nbsp;jednotlivých krocích rekurze je obrázek dělen na čtvrtiny až do chvíle, kdy se dojde k&nbsp;velikosti jednoho pixelu, který se již dále samozřejmě nedělí. Kromě obrázků ve stupních šedi je možné generovat i barevné obrázky. Ty se tvoří dvojím způsobem &ndash; buď aplikací barvové palety, nebo vytvořením tří obrázků, z&nbsp;nichž každý odpovídá jednomu barvovému kanálu R, G, B.</p>

*** image ***
<p><i>Obrázek : </i></p>

<p>Pomocí výše uvedené metody je možné vytvářet působivé obrázky plasmy; pro některé vstupní parametry však mohou být na obrázcích patrné vodorovné a svislé přechody mezi barvami, které tvoří hranice mezi čtverci na několika nejvyšších úrovních dělení. Na nižších úrovních, cca od čtvrté iterace, hranice splývají, neboť dochází ke snižování amplitudy odchylky &Delta;. Opticky rušivé přechody vznikají z&nbsp;toho důvodu, že se při každém rozdělení čtverce posune pouze jeho prostřední bod (střed) a nikoli prostřední body jeho hran &ndash; pro jejich posun nemáme dostatek informací, protože nevíme, jakým způsobem budou rozděleny čtyři sousední čtverce. Existuje několik způsobů, jak nežádoucí přechody odstranit. Některé způsoby spočívají v&nbsp;odlišném dělení čtverce, například střídavě po úhlopříčkách a vodorovných/svislých hranách, jiné způsoby zavádí &bdquo;paměť&ldquo; posuvu prostředních bodů okolních čtverců apod.</p>

<p>Zajímavější (a poněkud neznámá) alternativní metoda, která už nespočívá v&nbsp;rekurzivním dělení čtverce, je založena na iterativním generování různě orientovaných přímek, které rozdělují obraz na dvě (obecně) nestejně velké poloviny. Po vygenerování náhodné přímky (ta po protnutí hranic obrázku vytvoří úsečku) se provedou následující operace:</p>

<ol>
<li>intenzita všech pixelů ležících nalevo od přímky se <i>sníží</i> o jedničku.</li>
<li>intenzita všech pixelů ležících napravo od přímky se naopak o jedničku <i>zvýší</i>.</p></li>
</ol>

<p>Pro vygenerování věrohodného obrázku plasmy je zapotřebí vytvoření přímky a snižování/zvyšování intenzity pixelů provádět v&nbsp;iterační smyčce mnohokrát, typická hodnota bývá 1&nbsp;000 &ndash; 10&nbsp;000 iterací. Po provedení takto vysokého množství iterací již hranice mezi různě orientovanými přímkami (resp.&nbsp;polorovinami) nejsou patrné. Po provedení všech iterací je nutné obrázek <i>normalizovat</i>, tj.&nbsp;nejnižší intenzitě pixelů (ta může být díky odčítání i záporná) přiřadit černou barvu a nejvyšší intenzitě barvu čistě bílou. Výsledkem těchto operací je plasma bez znatelných horizontálních či vertikálních hran.</p>



<p><a name="k08"></a></p>
<h2 id="k08">8. Dvourozměrná spektrální syntéza</h2>

<p>Spektrální syntéza je mimořádně vhodná pro použití v&nbsp;počítačové grafice, a to zejména z&nbsp;toho důvodu, že je ji možné relativně snadno rozšiřovat do více dimenzí (rozměrů). Pro jednorozměrný příklad je výsledkem křivka. Rozšíření do dvou dimenzí je jednoduché &ndash; výsledkem bude obrázek/textura plasmy a/nebo trojrozměrné výškové pole, které může představovat například model krajiny. Při použití tří dimenzí dostaneme jako výsledek trojrozměrnou mřížku, ve které jednotlivé objemové elementy (<i>voxely</i>) mohou představovat například hustotu prostoru v&nbsp;místě jejich výskytu. Tuto hustotu je posléze možné použít při generování reálně vypadajících modelů trojrozměrných oblak &ndash; to je velký rozdíl oproti oblakům vytvořených jako dvourozměrné textury, jejichž &bdquo;dvojrozměrnost&ldquo; je při některých projekcích patrná.</p>

<p>V&nbsp;případě dvourozměrné spektrální syntézy je fraktální dimenze výsledného obrázku rovna:</p>

<pre>
D=3-H
</pre>

<p>Přičemž hodnota takzvaného Hurstova exponentu H se pohybuje v rozsahu 0,0..1,0. Z&nbsp;toho vyplývá, že fraktální dimenze výsledné plasmy se pohybuje v&nbsp;rozsahu 2,0..3,0.</p>

<p>Pomocí těchto koeficientů je následně s využitím inverzní diskrétní Fourierovy transformace vypočten požadovaný obrázek plasmy:</p>

<pre>
X(x,y)=&sum;&sum;(A<sub>kl</sub>cos(kx+ly)­+B<sub>kl</sub>sin(kx+ly))
</pre>



<p><a name="k09"></a></p>
<h2 id="k09">9. Čtvrtý demonstrační příklad &ndash; použití dvourozměrné spektrální syntézy</h2>



<p><a name="k10"></a></p>
<h2 id="k10">10. Úplný zdrojový kód čtvrtého demonstračního příkladu</h2>

<pre>
#!/usr/bin/env python

# Vytvoreni textury typu "plasma"

from PIL import Image
from random import random
import palette_blues
import palette_greens
import palette_gold
import palette_ice
import palette_mandmap
import numpy as np
import math

# textura by mela byt ctvercova a jeji sirka i vyska by mela byt
# mocninou cisla 2
IMAGE_WIDTH = 256
IMAGE_HEIGHT = 256


def random_gauss():
    '''
    Vygenerovani nahodneho cisla v rozsahu 0..1 s pribliznym
    Gaussovym rozlozenim
    '''
    N = 50
    sum = 0.0
    for i in range(N):
        sum += random()
    return sum/N


def compute_min_max(bitmap, width, height):
    # pro prepocet intenzit pixelu
    min = float("inf")
    max = float("-inf")

    # ziskani statistiky o obrazku - minimalni a maximalni hodnoty
    for j in range(height):
        for i in range(width):
            z = bitmap[j][i]
            if max &lt; z:
                max = z
            if min &gt; z:
                min = z
    return min, max


def convert_to_image(bitmap, image, width, height, palette):
    print("contrast adjustment")

    min, max = compute_min_max(bitmap, width, height)
    k = 255.0 / (max - min)

    # zmena kontrastu a kopie bitmapy
    for y in range(height):
        for x in range(width):
            f = float(bitmap[y][x])
            f -= min
            f *= k
            i = int(f) &amp; 255
            color = (palette[i][0], palette[i][1], palette[i][2])
            image.putpixel((x, y), color)


# h ... Hurstuv exponent
# n ... pocet koeficientu spektralni syntezy
def spectral_synthesis(image, palette, n, h):
    width, height = image.size      # rozmery obrazku

    bitmap = np.zeros([height, width])

    A = np.empty([n/2, n/2])        # koeficienty Ak
    B = np.empty([n/2, n/2])        # koeficienty Bk
    beta = 2.0 * h + 1              # promenna svazana s Hurstovym koeficientem

    print("calculate coefficients")

    # vypocet koeficientu Ak a Bk
    for j in range(n/2):
        for i in range(n/2):
            rad_i = pow((i+1), -beta/2.0)*random_gauss()
            rad_j = pow((j+1), -beta/2.0)*random_gauss()
            phase_i = 2.0*math.pi*random()
            phase_j = 2.0*math.pi*random()
            A[j][i] = rad_i*math.cos(phase_i)*rad_j*math.cos(phase_j)
            B[j][i] = rad_i*math.sin(phase_i)*rad_j*math.sin(phase_j)

    print("plasma synthesis")

    # vygenerovani plasmy
    for j in range(height):
        for i in range(width):
            z = 0
            # inverzni Fourierova transformace
            for k in range(n/2):
                for l in range(n/2):
                    u = (i-n/2)*2.0*math.pi/width
                    v = (j-n/2)*2.0*math.pi/height
                    z += A[k][l]*math.cos(k*u+l*v)+B[k][l]*math.sin(k*u+l*v)
            bitmap[j][i] = z

    convert_to_image(bitmap, image, width, height, palette)


image = Image.new("RGB", (IMAGE_WIDTH, IMAGE_HEIGHT))

spectral_synthesis(image, palette_greens.palette, 4, 0.5)
image.save("patternD_plasma1.png")

spectral_synthesis(image, palette_blues.palette, 10, 0.5)
image.save("patternD_plasma2.png")

spectral_synthesis(image, palette_mandmap.palette, 5, 0.1)
image.save("patternD_plasma3.png")

spectral_synthesis(image, palette_mandmap.palette, 5, 1.0)
image.save("patternD_plasma4.png")

spectral_synthesis(image, palette_gold.palette, 15, 0.5)
image.save("patternD_plasma5.png")

spectral_synthesis(image, palette_ice.palette, 15, 0.8)
image.save("patternD_plasma6.png")
</pre>



<p><a name="k11"></a></p>
<h2 id="k11">11. Perlinova šumová funkce</h2>



<p><a name="k12"></a></p>
<h2 id="k12">12. Princip šumové funkce</h2>



<p><a name="k13"></a></p>
<h2 id="k13">13. Aplikace Perlinovy šumové funkce</h2>



<p><a name="k14"></a></p>
<h2 id="k14">14. Pátý demonstrační příklad &ndash; 2D textura vykreslená Perlinovou funkcí</h2>

<pre>
#!/usr/bin/env python

# Perlinuv sum

from PIL import Image
from random import random
import palette_blues
import palette_greens
import palette_gold
import palette_ice
import palette_mandmap
import numpy as np
import math

# textura by mela byt ctvercova a jeji sirka i vyska by mela byt
# mocninou cisla 2
IMAGE_WIDTH = 256
IMAGE_HEIGHT = 256


def compute_min_max(bitmap, width, height):
    # pro prepocet intenzit pixelu
    min = float("inf")
    max = float("-inf")

    # ziskani statistiky o obrazku - minimalni a maximalni hodnoty
    for j in range(height):
        for i in range(width):
            z = bitmap[j][i]
            if max &lt; z:
                max = z
            if min &gt; z:
                min = z
    return min, max


def convert_to_image(bitmap, image, width, height, palette):
    print("contrast adjustment")

    min, max = compute_min_max(bitmap, width, height)
    k = 255.0 / (max - min)

    # zmena kontrastu a kopie bitmapy
    for y in range(height):
        for x in range(width):
            f = float(bitmap[y][x])
            f -= min
            f *= k
            i = int(f) &amp; 255
            color = (palette[i][0], palette[i][1], palette[i][2])
            image.putpixel((x, y), color)


def random_array(width, height, amplitude):
    return [[random() * amplitude for i in range(width)]
            for j in range(height)]


def perlin_noise(image, palette, noise, octaves):
    width, height = image.size       # rozmery obrazku

    bitmap = np.zeros([height, width])

    # postupne vytvoreni 'octaves' vrstev v obrazku
    for k in range(octaves):
        size = 2 ** k + 1
        amplitude = noise ** k

        # vytvoreni pole nahodnych cisel o dane amplidude
        array = random_array(size, size, amplitude)

        n = width / float(size-1.0)

        # interpolace hodnot v poli nahodnych cisel
        for y in range(height):
            for x in range(width):
                i = int(x / n)   # prepocet mezi pozici pixelu a indexem v poli
                j = int(y / n)
                x0 = x - i * n
                x1 = n - x0
                y0 = y - j * n
                y1 = n - y0
                # interpolace
                z = array[j][i] * x1 * y1
                z += array[j][i + 1] * x0 * y1
                z += array[j + 1][i] * x1 * y0
                z += array[j + 1][i + 1] * x0 * y0
                z /= n * n
                bitmap[y][x] += z

    convert_to_image(bitmap, image, width, height, palette)


image = Image.new("RGB", (IMAGE_WIDTH, IMAGE_HEIGHT))

perlin_noise(image, palette_mandmap.palette, 0.7, 6)
image.save("patternE_perlin_noise1.png")

perlin_noise(image, palette_mandmap.palette, 0.7, 7)
image.save("patternE_perlin_noise2.png")

perlin_noise(image, palette_blues.palette, 0.7, 9)
image.save("patternE_perlin_noise3.png")

perlin_noise(image, palette_gold.palette, 0.7, 11)
image.save("patternE_perlin_noise4.png")

perlin_noise(image, palette_greens.palette, 0.3, 12)
image.save("patternE_perlin_noise5.png")
</pre>



<p><a name="k15"></a></p>
<h2 id="k15">15. Repositář s&nbsp;demonstračními příklady</h2>

<p>Všechny dnes popsané demonstrační příklady byly uloženy do Git repositáře dostupného na adrese <a href="https://github.com/tisnik/presentations">https://github.com/tisnik/presentations</a>. Příklady si můžete v&nbsp;případě potřeby stáhnout i jednotlivě bez nutnosti klonovat celý repositář. Pro jejich spuštění je nutné mít nainstalovanou jak knihovnu Pyglet, tak i podpůrné grafické knihovny OpenGL a GLU (což se většinou provede automaticky v&nbsp;rámci instalace balíčku s&nbsp;Pygletem, viz též <a href="https://mojefedora.cz/multimedialni-knihovna-pyglet/">úvodní díl tohoto seriálu</a>):</p>

<table>
<tr><th>Příklad</th><th>Odkaz</th></tr>
<tr><td></td><td><a href="https://github.com/tisnik/presentations/blob/master/pyglet/">https://github.com/tisnik/presentations/blob/master/pyglet/</a></td></tr>
<tr><td></td><td><a href="https://github.com/tisnik/presentations/blob/master/pyglet/">https://github.com/tisnik/presentations/blob/master/pyglet/</a></td></tr>
<tr><td></td><td><a href="https://github.com/tisnik/presentations/blob/master/pyglet/">https://github.com/tisnik/presentations/blob/master/pyglet/</a></td></tr>
<tr><td></td><td><a href="https://github.com/tisnik/presentations/blob/master/pyglet/">https://github.com/tisnik/presentations/blob/master/pyglet/</a></td></tr>
<tr><td></td><td><a href="https://github.com/tisnik/presentations/blob/master/pyglet/">https://github.com/tisnik/presentations/blob/master/pyglet/</a></td></tr>
<tr><td></td><td><a href="https://github.com/tisnik/presentations/blob/master/pyglet/">https://github.com/tisnik/presentations/blob/master/pyglet/</a></td></tr>
</table>



<p><a name="k16"></a></p>
<h2 id="k16">16. Odkazy na Internetu</h2>

<ol>

<li>The Perlin noise math FAQ<br />
<a href="https://mzucker.github.io/html/perlin-noise-math-faq.html">https://mzucker.github.io/html/perlin-noise-math-faq.html</a>
</li>

<li>Perlin noise<br />
<a href="https://en.wikipedia.org/wiki/Perlin_noise">https://en.wikipedia.org/wiki/Perlin_noise</a>
</li>

<li>Perlin Noise Generator (Python recipe)<br />
<a href="http://code.activestate.com/recipes/578470-perlin-noise-generator/">http://code.activestate.com/recipes/578470-perlin-noise-generator/</a>
</li>

<li>Simplex noise demystified<br />
<a href="http://www.itn.liu.se/~stegu/simplexnoise/simplexnoise.pdf">http://www.itn.liu.se/~stegu/simplexnoise/simplexnoise.pdf</a>
</li>

<li>glTexEnv - příkaz OpenGL<br />
<a href="https://www.khronos.org/registry/OpenGL-Refpages/gl2.1/xhtml/glTexEnv.xml">https://www.khronos.org/registry/OpenGL-Refpages/gl2.1/xhtml/glTexEnv.xml</a>
</li>

<li>glGetTexEnv - příkaz OpenGL<br />
<a href="https://www.khronos.org/registry/OpenGL-Refpages/gl2.1/xhtml/glGetTexEnv.xml">https://www.khronos.org/registry/OpenGL-Refpages/gl2.1/xhtml/glGetTexEnv.xml</a>
</li>

<li>Pyglet Home Page<br />
<a href="https://bitbucket.org/pyglet/pyglet/wiki/Home">https://bitbucket.org/pyglet/pyglet/wiki/Home</a>
</li>

<li>Dokumentace k verzi 1.2<br />
<a href="https://pyglet.readthedocs.io/en/pyglet-1.2-maintenance/">https://pyglet.readthedocs.io/en/pyglet-1.2-maintenance/</a>
</li>

<li>Dokumentace k verzi 1.2 ve formátu PDF<br />
<a href="https://readthedocs.org/projects/pyglet/downloads/pdf/pyglet-1.2-maintenance/">https://readthedocs.org/projects/pyglet/downloads/pdf/pyglet-1.2-maintenance/</a>
</li>

<li>PyOpenGL<br />
<a href="http://pyopengl.sourceforge.net/">http://pyopengl.sourceforge.net/</a>
</li>

<li>The #! magic, details about the shebang/hash-bang mechanism on various Unix flavours<br />
<a href="https://www.in-ulm.de/~mascheck/various/shebang/">https://www.in-ulm.de/~mascheck/various/shebang/</a>
</li>

<li>Shebang (Unix)<br />
<a href="https://en.wikipedia.org/wiki/Shebang_%28Unix%29">https://en.wikipedia.org/wiki/Shebang_%28Unix%29</a>
</li>

<li>Domovská stránka systému LÖVE<br />
<a href="http://love2d.org/">http://love2d.org/</a>
</li>

<li>Simple DirectMedia Layer (home page)<br />
<a href="http://www.libsdl.org/">http://www.libsdl.org/</a>
</li>

<li>Simple DirectMedia Layer (Wikipedia)<br />
<a href="https://en.wikipedia.org/wiki/Simple_DirectMedia_Layer">https://en.wikipedia.org/wiki/Simple_DirectMedia_Layer</a>
</li>

<li>Seriál Grafická knihovna OpenGL<br />
<a href="https://www.root.cz/serialy/graficka-knihovna-opengl/">https://www.root.cz/serialy/graficka-knihovna-opengl/</a>
</li>

<li>Pyglet event loop<br />
<a href="http://pyglet.readthedocs.io/en/latest/programming_guide/eventloop.html">http://pyglet.readthedocs.io/en/latest/programming_guide/eventloop.html</a>
</li>

<li>Decorators I: Introduction to Python Decorators<br />
<a href="http://www.artima.com/weblogs/viewpost.jsp?thread=240808">http://www.artima.com/weblogs/viewpost.jsp?thread=240808</a>
</li>

<li>3D Programming in Python - Part 1 <br />
<a href="https://greendalecs.wordpress.com/2012/04/21/3d-programming-in-python-part-1/">https://greendalecs.wordpress.com/2012/04/21/3d-programming-in-python-part-1/</a>
</li>

<li>A very basic Pyglet tutorial<br />
<a href="http://www.natan.termitnjak.net/tutorials/pyglet_basic.html">http://www.natan.termitnjak.net/tutorials/pyglet_basic.html</a>
</li>

<li>Alpha blending<br />
<a href="https://en.wikipedia.org/wiki/Alpha_compositing#Alpha_blending">https://en.wikipedia.org/wiki/Alpha_compositing#Alpha_blending</a>
</li>

</ol>



<p></p><p></p>
<p><small>Autor: <a href="http://www.fit.vutbr.cz/~tisnovpa">Pavel Tišnovský</a> &nbsp; 2017</small></p>
</body>
</html>

