<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
        "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html>
<head>
<title>Programovací jazyk Rust: rozhraní mezi Rustem a Pythonem (pokračování)</title>
<meta name="Author" content="Pavel Tisnovsky" />
<meta name="Generator" content="vim" />
<meta http-equiv="content-type" content="text/html; charset=utf-8" />
<style type="text/css">
         body {color:#000000; background:#ffffff;}
         h1  {font-family: arial, helvetica, sans-serif; color:#ffffff; background-color:#c00000; text-align:center; padding-left:1em}
         h2  {font-family: arial, helvetica, sans-serif; color:#ffffff; background-color:#0000c0; padding-left:1em; text-align:left}
         h3  {font-family: arial, helvetica, sans-serif; color:#000000; background-color:#c0c0c0; padding-left:1em; text-align:left}
         h4  {font-family: arial, helvetica, sans-serif; color:#000000; background-color:#e0e0e0; padding-left:1em; text-align:left}
         a   {font-family: arial, helvetica, sans-serif;}
         li  {font-family: arial, helvetica, sans-serif; color:#000000; text-align:justify; width:450px;}
         ol  {font-family: arial, helvetica, sans-serif; color:#000000; text-align:justify; width:450px;}
         ul  {font-family: arial, helvetica, sans-serif; color:#000000; text-align:justify; width:450px;}
         p   {font-family: arial, helvetica, sans-serif; color:#000000; text-align:justify;}
         pre {background:#e0e0e0}
</style>
</head>

<body>

<h1>Programovací jazyk Rust: rozhraní mezi Rustem a Pythonem (pokračování)</h1>

<h3>Pavel Tišnovský</h3>

<p></p>

<h1>Úvodník</h1>

<p>Na předchozí článek, v němž jsme si popsali základní způsob použití rozhraní mezi Pythonem a Rustem dnes navážeme. Nejdříve si ukážeme způsob předávání řetězců z Pythonu do Rustu i naopak a posléze se zaměříme na popis předávání řezů (slices), které nám nahradí pole i seznamy.</p>



<h2>Obsah</h2>

<p><a href="#k01">1. Programovací jazyk Rust: rozhraní mezi Rustem a Pythonem (pokračování)</a></p>
<p><a href="#k02">2. Rozhraní mezi Pythonem a Rustem při předávání řetězců</a></p>
<p><a href="#k03">3. Kdo se postará o uvolnění řetězce z&nbsp;operační paměti?</a></p>
<p><a href="#k04">4. Předání řetězce z&nbsp;Pythonu do Rustu</a></p>
<p><a href="#k05">5. Část aplikace naprogramovaná v&nbsp;Rustu</a></p>
<p><a href="#k06">6. Testovací skript určený pro Python 2.x</a></p>
<p><a href="#k07">7. Testovací skript určený pro Python 3.x</a></p>
<p><a href="#k08">8. Vytvoření řetězce v&nbsp;Rustu s&nbsp;jeho použitím v&nbsp;Pythonu</a></p>
<p><a href="#k09">9. Část aplikace naprogramovaná v&nbsp;Rustu</a></p>
<p><a href="#k10">10. Testovací skript určený pro Python</a></p>
<p><a href="#k11">11. Předání &bdquo;slice&ldquo; z&nbsp;Pythonu do Rustu</a></p>
<p><a href="#k12">12. Část aplikace naprogramovaná v&nbsp;Rustu</a></p>
<p><a href="#k13">13. Testovací skript určený pro Python</a></p>
<p><a href="#k14">14. Vylepšení aplikace pro předání &bdquo;slice&ldquo; z&nbsp;Pythonu do Rustu</a></p>
<p><a href="#k15">15. Repositář s&nbsp;demonstračními příklady</a></p>
<p><a href="#k16">16. Odkazy na Internetu</a></p>



<p><a name="k01"></a></p>
<h2 id="k01">1. Programovací jazyk Rust: rozhraní mezi Rustem a Pythonem (pokračování)</h2>

<p><a
href="https://www.root.cz/clanky/programovaci-jazyk-rust-rozhrani-mezi-rustem-a-pythonem/">V&nbsp;minulé
části</a> <a
href="https://www.root.cz/serialy/programovaci-jazyk-rust/">seriálu o
programovacím jazyku Rust</a> jsme si vysvětlili, jakým způsobem je možné
zajistit komunikaci mezi částí aplikace naprogramovanou v&nbsp;Rustu a částí
naprogramovanou v&nbsp;Pythonu. Popsaný princip byl poměrně jednoduchý &ndash;
část psaná v&nbsp;Rustu se musela přeložit do nativního (strojového) kódu
takovým způsobem, aby nedocházelo k&nbsp;<i>name manglingu</i> jmen funkcí;
překlad navíc musel být proveden do statické či ještě lépe dynamické knihovny.
Na straně programovacího jazyka Python se použil modul <strong>ctypes</strong>
popř.&nbsp;alternativně <strong>CFFI</strong>, který dynamickou knihovnu
načetl, umožnil přesně specifikovat typy argumentů nativních funkcí i jejich
návratové typy a nakonec umožnil zavolání nativních funkcí.</p>

<p>Připomeňme si, že u funkcí akceptujících argumenty primitivních datových
typů bylo použití <strong>ctypes</strong> velmi jednoduché:</p>

<pre>
pub extern fn add_integers(x: i32, y: i32) -&gt; i32 {
    x + y
}
</pre>

<p>Skript napsaný v&nbsp;Pythonu mohl tuto nativní funkci volat následovně:</p>

<pre>
#!/usr/bin/env python3
import ctypes
&nbsp;
testlib1 = ctypes.CDLL("cesta/ke/knihovně/libtest1.so")
&nbsp;
result = testlib1.add_integers(1, 2)
print("1 + 2 = {}".format(result))
</pre>

<p>Poněkud složitější je předávání struktur odkazem:</p>

<pre>
#[repr(C)]
pub struct Complex {
    real: f32,
    imag: f32,
}
&nbsp;
#[no_mangle]
pub extern fn add_complex_mut(c1: &amp;mut Complex, c2: Complex) -&gt; () {
    c1.real += c2.real;
    c1.imag += c2.imag;
}
</pre>

<p>Zde již skript psaný v&nbsp;Pythonu potřebuje explicitní informace o typech
parametrů:</p>

<pre>
#!/usr/bin/env python3
import ctypes
&nbsp;
testlib4 = ctypes.CDLL("cesta/ke/knihovně/libtest4.so")
&nbsp;
&nbsp;
class Complex(ctypes.Structure):
    _fields_ = [("real", ctypes.c_float), ("imag", ctypes.c_float)]
&nbsp;
    def __str__(self):
        return "Complex: %f + i%f" % (self.real, self.imag)
&nbsp;
&nbsp;
libtest4.add_complex_mut.argtypes = (ctypes.POINTER(Complex), Complex)
libtest4.add_complex_mut.restype = None
&nbsp;
c1 = Complex(1.0, 2.0)
c2 = Complex(3.0, 4.0)
&nbsp;
libtest4.add_complex_mut(<strong>ctypes.byref(c1)</strong>, c2)
print(c1)
</pre>



<p><a name="k02"></a></p>
<h2 id="k02">2. Rozhraní mezi Pythonem a Rustem při předávání řetězců</h2>

<p>Velmi často se setkáme s&nbsp;nutností předávání řetězců mezi Pythonem a
Rustem. Může se jednat o předání řetězců z&nbsp;Pythonu do Rustu či naopak o
získání řetězce z&nbsp;Rustu skriptem psaným v&nbsp;Pythonu. To, zda je řetězec
vytvořen v&nbsp;Pythonu či v&nbsp;Rustu má velký vliv na to, jak se
k&nbsp;řetězci budeme chovat, protože oba programovací jazyky používají odlišný
způsob alokace a dealokace objektů, takže může docházet k&nbsp;různým typům
problémů, od memory leaků až po pády aplikace. Další potenciální problémy mohou
být způsobeny tím, že rozhraní mezi Pythonem a Rustem je (nejenom)
z&nbsp;historických důvodů založeno na typovém systému céčka, takže vlastně
budeme pracovat s&nbsp;ukazateli na pole znaků. Naopak prakticky bezproblémové
je řešení problematiky kódování znaků v&nbsp;řetězcích, protože jak
programovací jazyk Rust, tak i Python (<a
href="https://docs.python.org/3/howto/unicode.html">Python 3 navíc i
implicitně</a>) používá <a
href="https://en.wikipedia.org/wiki/Unicode">Unicode</a> a kódování <a
href="https://en.wikipedia.org/wiki/UTF-8">UTF-8</a>.</p>



<p><a name="k03"></a></p>
<h2 id="k03">3. Kdo se postará o uvolnění řetězce z&nbsp;operační paměti?</h2>

<p>Programovací jazyk Rust používá pro určení, zda je nějaký objekt možné
uvolnit z&nbsp;paměti, viditelnost objektu určovanou v&nbsp;době překladu.
Python (přesněji řečeno v&nbsp;tomto kontextu CPython) naproti tomu používá
klasický garbage collector. Pokud je řetězec vytvořen v&nbsp;Pythonu a předán
do kódu psaného v&nbsp;Rustu, je předání typicky provedeno přes ukazatel a
tudíž překladač Rustu ví, že řetězec (resp.&nbsp;přesněji řečeno libovolný
objekt předaný přes ukazatel) nevlastní a tudíž nijak <a
href="https://www.root.cz/clanky/ukazatele-v-rustu-aneb-temna-strana-sily/#k11">nehlídá
jeho viditelnost/životnost</a>. To je ve skutečnosti velmi dobré chování, neboť
o odstranění řetězce se postará runtime Pythonu a tudíž nedojde k&nbsp;pokusu o
dvojí dealokaci. Musíme ovšem sami zajistit, aby část programu naprogramovaná
v&nbsp;Rustu k&nbsp;originálnímu řetězci již nepřistupovala, takže se typicky
musí provést explicitní kopie (ve skutečnosti se ovšem většinou s&nbsp;řetězcem
pracuje v&nbsp;jediné funkci, takže ani to není nutné). Pokud je naopak řetězec
vytvořen v&nbsp;Rustu, musíme ho předat (vrátit) do Pythonu přes ukazatel a
explicitně se postarat o jeho uvolnění!</p>



<p><a name="k04"></a></p>
<h2 id="k04">4. Předání řetězce z&nbsp;Pythonu do Rustu</h2>

<p>V&nbsp;dnešním prvním demonstračním příkladu se pokusíme vytvořit řetězec
v&nbsp;Pythonu (což samozřejmě není nic složitého) a následně ho předat do
funkce naprogramované v&nbsp;Rustu. Pro jednoduchost rustovská funkce řetězec
pouze vytiskne a neprovede s&nbsp;ním žádné další operace. Předání bude vypadat
zhruba následovně:</p>

<pre>
+-------------------------+
|    řetězec v Pythonu    |
+-------------------------+
            &dArr;
+-------------------------+
|     sekvence bajtů      |
+-------------------------+
            &dArr;
+-------------------------+
|          char *         |
+-------------------------+
            &dArr;
+-------------------------+
|          CStr           |
+-------------------------+
            &dArr;
+-------------------------+
| Result&lt;&amp;str, Utf8Error&gt; |
+-------------------------+
            &dArr;
+-------------------------+
|          &amp;str           |
+-------------------------+
</pre>

<p>To sice nevypadá příliš jednoduše, na druhou stranu jsou však jednotlivé
konverze otázkou jediného řádku kódu.</p>



<p><a name="k05"></a></p>
<h2 id="k05">5. Část aplikace naprogramovaná v&nbsp;Rustu</h2>

<p>Podívejme se, jak vypadá rustovská část aplikace. V&nbsp;ní vytvoříme funkci
nazvanou <strong>print_string()</strong>, která akceptuje jediný parametr typu
<strong>*const c_char</strong>, což je nejbližší obdoba <strong>const char
*</strong> v&nbsp;programovacím jazyku C. Nyní z&nbsp;tohoto ukazatele
vytvoříme hodnotu typu <strong>CStr</strong>, která je chápána jako
<i>borrowed</i>, tj.&nbsp;funkce ji nebude vlastnit a nedojde k&nbsp;pokusu o
automatickou dealokaci. Následně tento typ převedeme na běžný slice &amp;str,
s&nbsp;nímž je již možné běžně pracovat. Povšimněte si volání
<strong>unwrap()</strong>, které je zde nutné, protože ve skutečnosti metoda
<strong>to_str()</strong> vrací typ <strong>Result&lt;&amp;str,
Utf8Error&gt;</strong>, jelikož při pokusu o konverzi <i>libovolné</i> sekvence
bajtů do UTF-8 může dojít k&nbsp;chybám:</p>

<pre>
use std::ffi::CStr;
use std::os::raw::c_char;
&nbsp;
#[no_mangle]
pub extern fn print_string(what: *const c_char) -&gt; () {
    unsafe {
        let c_string = <strong>CStr::from_ptr(what).to_str().unwrap()</strong>;
        println!("{:?}", c_string);
    }
}
</pre>



<p><a name="k06"></a></p>
<h2 id="k06">6. Testovací skript určený pro Python 2.x</h2>

<p>Testovací skript nyní bude existovat ve dvou verzích, z&nbsp;nichž první je
určena pro Python 2.x a druhá pro Python 3.x. V&nbsp;Pythonu 2.x je nejprve
nutné specifikovat typ parametru funkce <strong>print_string</strong>, zde
konkrétně použijeme typ <strong>c_char_p</strong>. Následně je již možné funkci
zavolat a předat jí řetězec přetypovaný na <strong>c_char_p</strong>:</p>

<pre>
#!/usr/bin/env python2
# vim: set fileencoding=utf-8
&nbsp;
import ctypes
&nbsp;
libtest5 = ctypes.CDLL("target/debug/libtest5.so")
&nbsp;
libtest5.print_string.argtypes = (ctypes.c_char_p,)
&nbsp;
libtest5.print_string(ctypes.c_char_p("Hello world!"))
libtest5.print_string(ctypes.c_char_p("Příliš žluťoučký kůň"))
libtest5.print_string(ctypes.c_char_p("Ну, погоди!"))
</pre>

<p>Ve skutečnosti můžeme v&nbsp;Pythonu 2 celý zápis ještě více zkrátit a volat
nativní funkci <strong>print_string()</strong> bez explicitního
přetypování:</p>

<pre>
#!/usr/bin/env python2
# vim: set fileencoding=utf-8
&nbsp;
import ctypes
&nbsp;
libtest5 = ctypes.CDLL("target/debug/libtest5.so")
&nbsp;
libtest5.print_string.argtypes = (ctypes.c_char_p,)
&nbsp;
libtest5.print_string("Hello world!")
libtest5.print_string("Příliš žluťoučký kůň")
libtest5.print_string("Ну, погоди!")
</pre>

<p>Povšimněte si, že bez problémů používáme Unicode.</p>



<p><a name="k07"></a></p>
<h2 id="k07">7. Testovací skript určený pro Python 3.x</h2>

<p>V&nbsp;Pythonu 3 je nutné provést nepatrné úpravy, protože převod řetězce
(zde Unicode řetězce) na sekvenci bajtů vyžaduje explicitní volání metody <a
href="https://docs.python.org/3.3/library/stdtypes.html?highlight=encode#str.encode">str.encode()</a>
s&nbsp;určením konkrétního kódování:</p>

<pre>
#!/usr/bin/env python3
# vim: set fileencoding=utf-8
&nbsp;
import ctypes
&nbsp;
libtest5 = ctypes.CDLL("target/debug/libtest5.so")
&nbsp;
libtest5.print_string.argtypes = (ctypes.c_char_p,)
&nbsp;
libtest5.print_string("Hello world!".encode('utf-8'))
libtest5.print_string("Příliš žluťoučký kůň".encode('utf-8'))
libtest5.print_string("Ну, погоди!".encode('utf-8'))
</pre>

<p>Vzhledem k&nbsp;tomu, že pro <strong>encode()</strong> je kódování UTF-8
implicitní, lze skript ještě zjednodušit:</p>

<pre>
#!/usr/bin/env python3
# vim: set fileencoding=utf-8
&nbsp;
import ctypes
&nbsp;
libtest5 = ctypes.CDLL("target/debug/libtest5.so")
&nbsp;
libtest5.print_string.argtypes = (ctypes.c_char_p,)
&nbsp;
libtest5.print_string("Hello world!".encode())
libtest5.print_string("Příliš žluťoučký kůň".encode())
libtest5.print_string("Ну, погоди!".encode())
</pre>



<p><a name="k08"></a></p>
<h2 id="k08">8. Vytvoření řetězce v&nbsp;Rustu s&nbsp;jeho použitím v&nbsp;Pythonu</h2>

<p>Předchozí příklad byl poměrně jednoduchý, protože řetězec byl vytvořen
v&nbsp;Pythonu, jehož běhové prostředí se posléze automaticky postaralo o jeho
uvolnění z&nbsp;operační paměti. Co se však stane v&nbsp;opačném případě,
tj.&nbsp;ve chvíli, kdy řetězec vytvoříme v&nbsp;Rustu a předáme ho (jako
návratovou hodnotu) do Pythonu? V&nbsp;takovém případě musíme sami (!) zajistit
následující chování:</p>

<ol>

<li>Rust nesmí řetězec automaticky dealokovat při opuštění funkce či
bloku.</li>

<li>Python taktéž nesmí řetězec automaticky dealokovat (nepatří mu, navíc
provádí alokace a dealokace jiným způsobem).</li>

<li>Musíme vytvořit funkci pro dealokaci řetězce (v&nbsp;Rustu) a tu explicitně
zavolat.</li>

</ol>

<p>Řešením je použití takzvaných <i>raw pointerů</i>, kdy se při vytvoření raw
pointeru z&nbsp;nějakého objektu explicitně vzdáváme vlastnictví
(<i>ownership</i>).</p>



<p><a name="k09"></a></p>
<h2 id="k09">9. Část aplikace naprogramovaná v&nbsp;Rustu</h2>

<p>Část aplikace naprogramovaná v&nbsp;Rustu je nyní delší, protože obsahuje
jak funkci pro vytvoření řetězce (zde pro ilustraci řetězce se sekvencí
hvězdiček), tak i funkci, která řetězec bude dealokovat z&nbsp;operační paměti.
Povšimněte si, že nyní z&nbsp;řetězce (typ <strong>String</strong>) vytváříme
objekt <strong>CString</strong> a z&nbsp;něho získáme <i>raw pointer</i>. Raw
pointer je současně návratovou hodnotou funkce a navíc se řetězec neodstraní
z&nbsp;paměti před návratem z&nbsp;funkce (což je implicitní chování Rustu).
Naopak funkce pro uvolnění řetězce dealokaci provádí, ale implicitně &ndash;
z&nbsp;<i>raw pointeru</i> vytvoříme objekt <strong>CString</strong> (tím
současně získáme i vlastnictví/ownership) a ten ihned zahodíme &ndash; a právě
v&nbsp;této chvíli může Rust provést dealokaci:</p>

<pre>
use std::iter;
use std::ffi::CString;
use std::os::raw::c_char;
&nbsp;
#[no_mangle]
pub extern fn generate_stars(count: u8) -&gt; *mut c_char {
    let s: String = iter::repeat("*").take(count as usize).collect();
    let c_string = CString::new(s).unwrap();
    let raw = <strong>c_string.into_raw()</strong>;
    println!("output raw pointer:  {:?}", raw);
    raw
}
&nbsp;
#[no_mangle]
pub extern fn free_string(raw: *mut c_char) {
    unsafe {
        if raw.is_null() { return }
        println!("raw pointer to free: {:?}", raw);
        <strong>CString::from_raw(raw)</strong>
    };
}
</pre>

<p>Poznámka: obecně platí, že funkce <strong>Objekt.into_raw()</strong> a
<strong>from_raw()</strong> se musí vyskytovat ve dvojici. Pokud tomu tak není
(volá se jen <strong>into_raw()</strong>), bude v&nbsp;aplikaci pravděpodobně
docházet k&nbsp;memory leakům.</p>



<p><a name="k10"></a></p>
<h2 id="k10">10. Testovací skript určený pro Python</h2>

<p>I skript naprogramovaný v&nbsp;Pythonu je nepatrně delší, protože musíme
zajistit volání funkce <strong>free_string()</strong>, jelikož jinak by řetězec
nikdy nebyl uvolněn z&nbsp;paměti (což samozřejmě bude vadit ve chvíli, kdy
funkci <strong>generate_stars()</strong> voláme častěji popř.&nbsp;se jedná o
aplikaci běžící po dlouhou dobu). Uvolnění řetězce zajistíme jednoduše
konstrukcí <strong>try-(return)-finally</strong>:</p>

<pre>
#!/usr/bin/env python2
# vim: set fileencoding=utf-8
&nbsp;
import ctypes
&nbsp;
libtest6 = ctypes.CDLL("target/debug/libtest6.so")
&nbsp;
libtest6.generate_stars.argtypes = (ctypes.c_uint8, )
libtest6.generate_stars.restype = ctypes.c_void_p
&nbsp;
# pozor na nutnost uvedení čárky - máme n-tici s jediným prvkem
libtest6.free_string.argtypes = (ctypes.c_void_p, )
&nbsp;
def generate_stars(count):
    pointer = libtest6.generate_stars(count)
    try:
        return ctypes.cast(pointer, ctypes.c_char_p).value.decode('utf-8')
    finally:
        libtest6.free_string(pointer)
&nbsp;
print(generate_stars(42))
</pre>



<p><a name="k11"></a></p>
<h2 id="k11">11. Předání &bdquo;slice&ldquo; z&nbsp;Pythonu do Rustu</h2>

<p>V&nbsp;závěrečné třetině článku si ukážeme, jakým způsobem je možné předat
řez (slice) z&nbsp;Pythonu do Rustu. Řezy jsou velmi užitečnou datovou
strukturou, protože nabízí stejně efektivní způsob uložení prvků i stejně
efektivní přístup k&nbsp;prvkům jako pole a současně obsahují i počet prvků
(resp.&nbsp;délku řezu, protože délka závisí jak na počtu prvků, tak i na
jejich velikosti). To mj.&nbsp;znamená, že je možné řezy použít pro předávání
n-tic nebo seznamů z&nbsp;Pythonu do Rustu. Ve skutečnosti však nebude řez
předán jediným parametrem, ale parametry dvěma &ndash; ukazatelem na data
(pole) a velikostí řezu. Z&nbsp;těchto dvou parametrů pak funkcí
<strong>from_raw_parts(p: *const T, len: usize) -> &amp;'a [T]</strong>
vytvoříme řez, s&nbsp;nímž je možné dále pracovat. O dealokaci se nemusíme
starat, neboť tu zajistí běhové prostředí Pythonu; to však samozřejmě znamená,
že Rustovská část aplikace musí počítat s&nbsp;tím, že po opuštění volané
funkce může řez přestat existovat (tudíž si na něj nesmí vytvářet ukazatele,
předávat ownership atd.)</p>



<p><a name="k12"></a></p>
<h2 id="k12">12. Část aplikace naprogramovaná v&nbsp;Rustu</h2>

<p>V&nbsp;části aplikace naprogramované v&nbsp;Rustu je deklarována funkce,
která očekává ukazatel na prvky typu <strong>i32</strong> a taktéž počet prvků
řezu.  S&nbsp;těmito údaji je zavolána již výše zmíněná funkce
<strong>from_raw_parts()</strong> (navíc se délka musí přetypovat). Získaný řez
použijeme při výpočtu součtu všech prvků, které se v&nbsp;řezu nachází.
Výsledný součet je současně i návratovou hodnotou funkce:</p>

<pre>
use std::slice;
&nbsp;
#[no_mangle]
pub extern fn sum(items: *const i32, length: usize) -&gt; i32 {
    let numbers = unsafe {
        <strong>slice::from_raw_parts(items, length as usize)</strong>
    };
&nbsp;
    let mut sum:i32 = 0;
    for number in numbers {
        sum += *number
    }
    sum
}
</pre>

<p>Poznámka: <strong>length</strong> musí obsahovat počet prvků, nikoli délku
řezu v&nbsp;bajtech. Převod na bajty si provede funkce
<strong>from_raw_parts()</strong> sama.</p>



<p><a name="k13"></a></p>
<h2 id="k13">13. Testovací skript určený pro Python</h2>

<p>Testovací skript naprogramovaný v&nbsp;Pythonu obsahuje deklaraci pomocné
funkce <strong>sum()</strong>, jejímž účelem je získat seznam či sekvenci a
z&nbsp;ní vytvořit dvojici ukazatel_na_první_prvek+délka (počet prvků, ne počet
bajtů). Tyto dva údaje jsou předány rustovské funkci:</p>

<pre>
#!/usr/bin/env python2
# vim: set fileencoding=utf-8
&nbsp;
import ctypes
&nbsp;
libtest7 = ctypes.CDLL("target/debug/libtest7.so")
&nbsp;
libtest7.sum.argtypes = (ctypes.POINTER(ctypes.c_uint32), ctypes.c_size_t)
libtest7.sum.restype = ctypes.c_int32
&nbsp;
def sum(numbers):
    buf_type = ctypes.c_uint32 * len(numbers)
    buf = buf_type(*numbers)
    return libtest7.sum(buf, len(numbers))
&nbsp;
print(sum([1,2,3,4]))
&nbsp;
print(sum(range(11)))
</pre>

<p>Všimněte si, že do funkce <strong>sum()</strong> můžeme předat jak seznam,
tak i sekvenci (v&nbsp;Pythonu 3).</p>



<p><a name="k14"></a></p>
<h2 id="k14">14. Vylepšení aplikace pro předání &bdquo;slice&ldquo; z&nbsp;Pythonu do Rustu</h2>

<p>Nativní část aplikace psanou v&nbsp;Rustu je možné vylepšit. Nejprve do
bloku <strong>usafe</strong> přidáme aserci testující, zda se náhodou funkce
nevolá s&nbsp;prvním parametrem nastaveným na NULL. To obecně v&nbsp;Rustu není
možné, ovšem ukazatele získané z&nbsp;jiných jazyků jsou v&nbsp;tomto ohledu
výjimečné. Mimochodem si povšimněte, že celý blok <strong>unsafe</strong> je
ukončen výrazem (na jeho konci není středník), jehož výsledek se uloží do
proměnné <strong>numbers</strong>. Druhá úprava spočívá ve výpočtu sumy
napsaném na jediném řádku funkcionálním stylem, s&nbsp;nímž jsme se již
v&nbsp;Rustu několikrát setkali. Opět si povšimněte, že celý řádek je výrazem,
jehož výsledná hodnota je současně výsledkem celé funkce:</p>

<pre>
use std::slice;
&nbsp;
#[no_mangle]
pub extern fn sum(items: *const i32, length: usize) -&gt; i32 {
    let numbers = unsafe {
        <strong>assert!(!items.is_null());</strong>
&nbsp;
        slice::from_raw_parts(items, length as usize)
    };
&nbsp;
    <strong>numbers.iter().fold(0, |acc, v| acc + v)</strong>
}
</pre>



<p><a name="k15"></a></p>
<h2 id="k15">15. Repositář s&nbsp;demonstračními příklady</h2>

<p>Všechny čtyři dnes popisované demonstrační příklady (projekty) byly, ostatně
podobně jako ve všech předchozích částech <a
href="https://www.root.cz/serialy/programovaci-jazyk-rust/">tohoto seriálu</a>,
uloženy do Git repositáře dostupného na adrese <a
href="https://github.com/tisnik/presentations">https://github.com/tisnik/presentations</a>.
Demonstrační příklady si můžete v&nbsp;případě potřeby stáhnout i jednotlivě
bez nutnosti klonovat celý repositář (ovšem u projektů je lepší mít celý
repositář, abyste nemuseli pracně stahovat všechny potřebné soubory):</p>

<table>
<tr><th>Příklad</th><th>Adresa</th></tr>
<tr><td>Knihovna číslo 5</td><td>&nbsp;</td></tr>
<tr><td>Cargo.toml</td><td><a href="https://github.com/tisnik/presentations/blob/master/rust/libs/test5/Cargo.toml">https://github.com/tisnik/presentations/blob/master/rust/libs/test5/Cargo.toml</a></td></tr>
<tr><td>lib.rs</td><td><a href="https://github.com/tisnik/presentations/blob/master/rust/libs/test5/src/lib.rs">https://github.com/tisnik/presentations/blob/master/rust/libs/test4/src/lib.rs</a></td></tr>
<tr><td>test_python2.py</td><td><a href="https://github.com/tisnik/presentations/blob/master/rust/libs/test5/test_python2.py">https://github.com/tisnik/presentations/blob/master/rust/libs/test5/test_python2.py</a></td></tr>
<tr><td>test_python2_2.py</td><td><a href="https://github.com/tisnik/presentations/blob/master/rust/libs/test5/test_python2_2.py">https://github.com/tisnik/presentations/blob/master/rust/libs/test5/test_python2_2.py</a></td></tr>
<tr><td>test_python3.py</td><td><a href="https://github.com/tisnik/presentations/blob/master/rust/libs/test5/test_python3.py">https://github.com/tisnik/presentations/blob/master/rust/libs/test5/test_python3.py</a></td></tr>
<tr><td>test_python3_2.py</td><td><a href="https://github.com/tisnik/presentations/blob/master/rust/libs/test5/test_python3_2.py">https://github.com/tisnik/presentations/blob/master/rust/libs/test5/test_python3_2.py</a></td></tr>
<tr><td>&nbsp;</td><td>&nbsp;</td></tr>
<tr><td>Knihovna číslo 6</td><td>&nbsp;</td></tr>
<tr><td>Cargo.toml</td><td><a href="https://github.com/tisnik/presentations/blob/master/rust/libs/test6/Cargo.toml">https://github.com/tisnik/presentations/blob/master/rust/libs/test6/Cargo.toml</a></td></tr>
<tr><td>lib.rs</td><td><a href="https://github.com/tisnik/presentations/blob/master/rust/libs/test6/src/lib.rs">https://github.com/tisnik/presentations/blob/master/rust/libs/test6/src/lib.rs</a></td></tr>
<tr><td>test.py</td><td><a href="https://github.com/tisnik/presentations/blob/master/rust/libs/test6/test.py">https://github.com/tisnik/presentations/blob/master/rust/libs/test6/test.py</a></td></tr>
<tr><td>&nbsp;</td><td>&nbsp;</td></tr>
<tr><td>Knihovna číslo 7</td><td>&nbsp;</td></tr>
<tr><td>Cargo.toml</td><td><a href="https://github.com/tisnik/presentations/blob/master/rust/libs/test7/Cargo.toml">https://github.com/tisnik/presentations/blob/master/rust/libs/test7/Cargo.toml</a></td></tr>
<tr><td>lib.rs</td><td><a href="https://github.com/tisnik/presentations/blob/master/rust/libs/test7/src/lib.rs">https://github.com/tisnik/presentations/blob/master/rust/libs/test7/src/lib.rs</a></td></tr>
<tr><td>test.py</td><td><a href="https://github.com/tisnik/presentations/blob/master/rust/libs/test7/test.py">https://github.com/tisnik/presentations/blob/master/rust/libs/test7/test.py</a></td></tr>
<tr><td>&nbsp;</td><td>&nbsp;</td></tr>
<tr><td>Knihovna číslo 8</td><td>&nbsp;</td></tr>
<tr><td>Cargo.toml</td><td><a href="https://github.com/tisnik/presentations/blob/master/rust/libs/test8/Cargo.toml">https://github.com/tisnik/presentations/blob/master/rust/libs/test8/Cargo.toml</a></td></tr>
<tr><td>lib.rs</td><td><a href="https://github.com/tisnik/presentations/blob/master/rust/libs/test8/src/lib.rs">https://github.com/tisnik/presentations/blob/master/rust/libs/test8/src/lib.rs</a></td></tr>
<tr><td>test.py</td><td><a href="https://github.com/tisnik/presentations/blob/master/rust/libs/test8/test.py">https://github.com/tisnik/presentations/blob/master/rust/libs/test8/test.py</a></td></tr>
</table>



<p><a name="k16"></a></p>
<h2 id="k16">16. Odkazy na Internetu</h2>

<ol>

<li>Pragmatic Unicode<br />
<a href="https://nedbatchelder.com/text/unipain.html">https://nedbatchelder.com/text/unipain.html</a>
</li>

<li>The Rust FFI Omnibus<br />
<a href="http://jakegoulding.com/rust-ffi-omnibus/">http://jakegoulding.com/rust-ffi-omnibus/</a>
</li>

<li>class str (Python)<br />
<a href="https://docs.python.org/3/library/stdtypes.html#str">https://docs.python.org/3/library/stdtypes.html#str</a>
</li>

<li>Build Script Support<br />
<a href="http://doc.crates.io/build-script.html">http://doc.crates.io/build-script.html</a>
</li>

<li>Calling Rust From Python<br />
<a href="https://bheisler.github.io/post/calling-rust-in-python/">https://bheisler.github.io/post/calling-rust-in-python/</a>
</li>

<li>Calling Rust in Python (komentáře k předchozímu článku)<br />
<a href="https://www.reddit.com/r/rust/comments/63iy5a/calling_rust_in_python/">https://www.reddit.com/r/rust/comments/63iy5a/calling_rust_in_python/</a>
</li>

<li>CFFI Documentation<br />
<a href="https://cffi.readthedocs.io/en/latest/">https://cffi.readthedocs.io/en/latest/</a>
</li>

<li>Build Script Support<br />
<a href="http://doc.crates.io/build-script.html">http://doc.crates.io/build-script.html</a>
</li>

<li>Creating a shared and static library with the gnu compiler [gcc]<br />
<a href="http://www.adp-gmbh.ch/cpp/gcc/create_lib.html">http://www.adp-gmbh.ch/cpp/gcc/create_lib.html</a>
</li>

<li>ctypes — A foreign function library for Python<br />
<a href="https://docs.python.org/2/library/ctypes.html">https://docs.python.org/2/library/ctypes.html</a>
</li>

<li>FFI: Foreign Function Interface<br />
<a href="https://doc.rust-lang.org/book/ffi.html">https://doc.rust-lang.org/book/ffi.html</a>
</li>

<li>Primitive Type pointer<br />
<a href="https://doc.rust-lang.org/std/primitive.pointer.html">https://doc.rust-lang.org/std/primitive.pointer.html</a>
</li>

<li>Cargo: správce projektů a balíčků pro programovací jazyk Rust<br />
<a href="https://mojefedora.cz/cargo-spravce-projektu-a-balicku-pro-programovaci-jazyk-rust/">https://mojefedora.cz/cargo-spravce-projektu-a-balicku-pro-programovaci-jazyk-rust/</a>
</li>

<li>Network Communication and Serialization in Rust<br />
<a href="https://www.safaribooksonline.com/blog/2014/01/28/network-communication-serialization-rust/">https://www.safaribooksonline.com/blog/2014/01/28/network-communication-serialization-rust/</a>
</li>

<li>Crate bincode<br />
<a href="http://tyoverby.com/bincode/bincode/index.html">http://tyoverby.com/bincode/bincode/index.html</a>
</li>

<li>Struct std::fs::File<br />
<a href="https://doc.rust-lang.org/std/fs/struct.File.html">https://doc.rust-lang.org/std/fs/struct.File.html</a>
</li>

<li>Trait std::io::Seek<br />
<a href="https://doc.rust-lang.org/std/io/trait.Seek.html">https://doc.rust-lang.org/std/io/trait.Seek.html</a>
</li>

<li>Trait std::io::Read<br />
<a href="https://doc.rust-lang.org/std/io/trait.Read.html">https://doc.rust-lang.org/std/io/trait.Read.html</a>
</li>

<li>Trait std::io::Write<br />
<a href="https://doc.rust-lang.org/std/io/trait.Write.html">https://doc.rust-lang.org/std/io/trait.Write.html</a>
</li>

<li>Trait std::io::BufRead<br />
<a href="https://doc.rust-lang.org/std/io/trait.BufRead.html">https://doc.rust-lang.org/std/io/trait.BufRead.html</a>
</li>

<li>Module std::io::prelude<br />
<a href="https://doc.rust-lang.org/std/io/prelude/index.html">https://doc.rust-lang.org/std/io/prelude/index.html</a>
</li>

<li>std::net::IpAddr<br />
<a href="https://doc.rust-lang.org/std/net/enum.IpAddr.html">https://doc.rust-lang.org/std/net/enum.IpAddr.html</a>
</li>

<li>std::net::Ipv4Addr<br />
<a href="https://doc.rust-lang.org/std/net/struct.Ipv4Addr.html">https://doc.rust-lang.org/std/net/struct.Ipv4Addr.html</a>
</li>

<li>std::net::Ipv6Addr<br />
<a href="https://doc.rust-lang.org/std/net/struct.Ipv6Addr.html">https://doc.rust-lang.org/std/net/struct.Ipv6Addr.html</a>
</li>

<li>TcpListener<br />
<a href="https://doc.rust-lang.org/std/net/struct.TcpListener.html">https://doc.rust-lang.org/std/net/struct.TcpListener.html</a>
</li>

<li>TcpStream<br />
<a href="https://doc.rust-lang.org/std/net/struct.TcpStream.html">https://doc.rust-lang.org/std/net/struct.TcpStream.html</a>
</li>

<li>Binary heap (Wikipedia)<br />
<a href="https://en.wikipedia.org/wiki/Binary_heap">https://en.wikipedia.org/wiki/Binary_heap</a>
</li>

<li>Binární halda (Wikipedia)<br />
<a href="https://cs.wikipedia.org/wiki/Bin%C3%A1rn%C3%AD_halda">https://cs.wikipedia.org/wiki/Bin%C3%A1rn%C3%AD_halda</a>
</li>

<li>Halda (datová struktura)<br />
<a href="https://cs.wikipedia.org/wiki/Halda_%28datov%C3%A1_struktura%29">https://cs.wikipedia.org/wiki/Halda_%28datov%C3%A1_struktura%29</a>
</li>

<li>Struct std::collections::HashSet<br />
<a href="https://doc.rust-lang.org/std/collections/struct.HashSet.html">https://doc.rust-lang.org/std/collections/struct.HashSet.html</a>
</li>

<li>Struct std::collections::BTreeSet<br />
<a href="https://doc.rust-lang.org/std/collections/struct.BTreeSet.html">https://doc.rust-lang.org/std/collections/struct.BTreeSet.html</a>
</li>

<li>Struct std::collections::BinaryHeap<br />
<a href="https://doc.rust-lang.org/std/collections/struct.BinaryHeap.html">https://doc.rust-lang.org/std/collections/struct.BinaryHeap.html</a>
</li>

<li>Set (abstract data type)<br />
<a href="https://en.wikipedia.org/wiki/Set_%28abstract_data_type%29#Language_support">https://en.wikipedia.org/wiki/Set_%28abstract_data_type%29#Language_support</a>
</li>

<li>Associative array<br />
<a href="https://en.wikipedia.org/wiki/Associative_array">https://en.wikipedia.org/wiki/Associative_array</a>
</li>

<li>Hash Table<br />
<a href="https://en.wikipedia.org/wiki/Hash_table">https://en.wikipedia.org/wiki/Hash_table</a>
</li>

<li>B-tree<br />
<a href="https://en.wikipedia.org/wiki/B-tree">https://en.wikipedia.org/wiki/B-tree</a>
</li>

<li>Pedro Celis: Robin Hood Hashing (naskenované PDF!)<br />
<a href="https://cs.uwaterloo.ca/research/tr/1986/CS-86-14.pdf">https://cs.uwaterloo.ca/research/tr/1986/CS-86-14.pdf</a>
</li>

<li>Robin Hood hashing<br />
<a href="http://codecapsule.com/2013/11/11/robin-hood-hashing/">http://codecapsule.com/2013/11/11/robin-hood-hashing/</a>
</li>

<li>Robin Hood hashing: backward shift deletion<br />
<a href="http://codecapsule.com/2013/11/17/robin-hood-hashing-backward-shift-deletion/">http://codecapsule.com/2013/11/17/robin-hood-hashing-backward-shift-deletion/</a>
</li>

<li>Module std::collections<br />
<a href="https://doc.rust-lang.org/std/collections/">https://doc.rust-lang.org/std/collections/</a>
</li>

<li>Module std::vec<br />
<a href="https://doc.rust-lang.org/nightly/std/vec/index.html">https://doc.rust-lang.org/nightly/std/vec/index.html</a>
</li>

<li>Struct std::collections::VecDeque<br />
<a href="https://doc.rust-lang.org/std/collections/struct.VecDeque.html">https://doc.rust-lang.org/std/collections/struct.VecDeque.html</a>
</li>

<li>Struct std::collections::LinkedList<br />
<a href="https://doc.rust-lang.org/std/collections/struct.LinkedList.html">https://doc.rust-lang.org/std/collections/struct.LinkedList.html</a>
</li>

<li>Module std::fmt<br />
<a href="https://doc.rust-lang.org/std/fmt/">https://doc.rust-lang.org/std/fmt/</a>
</li>

<li>Macro std::println<br />
<a href="https://doc.rust-lang.org/std/macro.println.html">https://doc.rust-lang.org/std/macro.println.html</a>
</li>

<li>Enum std::result::Result<br />
<a href="https://doc.rust-lang.org/std/result/enum.Result.html">https://doc.rust-lang.org/std/result/enum.Result.html</a>
</li>

<li>Module std::result<br />
<a href="https://doc.rust-lang.org/std/result/">https://doc.rust-lang.org/std/result/</a>
</li>

<li>Result<br />
<a href="http://rustbyexample.com/std/result.html">http://rustbyexample.com/std/result.html</a>
</li>

<li>Rust stdlib: Option<br />
<a href="https://doc.rust-lang.org/std/option/enum.Option.html">https://doc.rust-lang.org/std/option/enum.Option.html</a>
</li>

<li>Module std::option<br />
<a href="https://doc.rust-lang.org/std/option/index.html">https://doc.rust-lang.org/std/option/index.html</a>
</li>

<li>Rust by example: option<br />
<a href="http://rustbyexample.com/std/option.html">http://rustbyexample.com/std/option.html</a>
</li>

<li>Rust by example: if-let<br />
<a href="http://rustbyexample.com/flow_control/if_let.html">http://rustbyexample.com/flow_control/if_let.html</a>
</li>

<li>Rust by example: while let<br />
<a href="http://rustbyexample.com/flow_control/while_let.html">http://rustbyexample.com/flow_control/while_let.html</a>
</li>

<li>Rust by example: Option&lt;i32&gt;<br />
<a href="http://rustbyexample.com/std/option.html">http://rustbyexample.com/std/option.html</a>
</li>

<li>An Overview of Macros in Rust<br />
<a href="http://words.steveklabnik.com/an-overview-of-macros-in-rust">http://words.steveklabnik.com/an-overview-of-macros-in-rust</a>
</li>

<li>A Practical Intro to Macros in Rust 1.0<br />
<a href="https://danielkeep.github.io/practical-intro-to-macros.html">https://danielkeep.github.io/practical-intro-to-macros.html</a>
</li>

<li>The Rust Programming Language: macros<br />
<a href="https://doc.rust-lang.org/beta/book/macros.html">https://doc.rust-lang.org/beta/book/macros.html</a>
</li>

<li>Rust by example: 15 macro_rules!<br />
<a href="http://rustbyexample.com/macros.html">http://rustbyexample.com/macros.html</a>
</li>

<li>Primitive Type isize<br />
<a href="https://doc.rust-lang.org/nightly/std/primitive.isize.html">https://doc.rust-lang.org/nightly/std/primitive.isize.html</a>
</li>

<li>Primitive Type usize<br />
<a href="https://doc.rust-lang.org/nightly/std/primitive.usize.html">https://doc.rust-lang.org/nightly/std/primitive.usize.html</a>
</li>

<li>Primitive Type array<br />
<a href="https://doc.rust-lang.org/nightly/std/primitive.array.html">https://doc.rust-lang.org/nightly/std/primitive.array.html</a>
</li>

<li>Module std::slice<br />
<a href="https://doc.rust-lang.org/nightly/std/slice/">https://doc.rust-lang.org/nightly/std/slice/</a>
</li>

<li>Rust by Example: 2.3 Arrays and Slices<br />
<a href="http://rustbyexample.com/primitives/array.html">http://rustbyexample.com/primitives/array.html</a>
</li>

<li>What is the difference between Slice and Array (stackoverflow)<br />
<a href="http://stackoverflow.com/questions/30794235/what-is-the-difference-between-slice-and-array">http://stackoverflow.com/questions/30794235/what-is-the-difference-between-slice-and-array</a>
</li>

<li>Learning Rust With Entirely Too Many Linked Lists<br />
<a href="http://cglab.ca/~abeinges/blah/too-many-lists/book/">http://cglab.ca/~abeinges/blah/too-many-lists/book/</a>
</li>

<li>Testcase: linked list<br />
<a href="http://rustbyexample.com/custom_types/enum/testcase_linked_list.html">http://rustbyexample.com/custom_types/enum/testcase_linked_list.html</a>
</li>

<li>Operators and Overloading<br />
<a href="https://doc.rust-lang.org/book/operators-and-overloading.html">https://doc.rust-lang.org/book/operators-and-overloading.html</a>
</li>

<li>Module std::ops<br />
<a href="https://doc.rust-lang.org/std/ops/index.html">https://doc.rust-lang.org/std/ops/index.html</a>
</li>

<li>Module std::cmp<br />
<a href="https://doc.rust-lang.org/std/cmp/index.html">https://doc.rust-lang.org/std/cmp/index.html</a>
</li>

<li>Trait std::ops::Add<br />
<a href="https://doc.rust-lang.org/stable/std/ops/trait.Add.html">https://doc.rust-lang.org/stable/std/ops/trait.Add.html</a>
</li>

<li>Trait std::ops::AddAssign<br />
<a href="https://doc.rust-lang.org/std/ops/trait.AddAssign.html">https://doc.rust-lang.org/std/ops/trait.AddAssign.html</a>
</li>

<li>Trait std::ops::Drop<br />
<a href="https://doc.rust-lang.org/std/ops/trait.Drop.html">https://doc.rust-lang.org/std/ops/trait.Drop.html</a>
</li>

<li>Trait std::cmp::Eq<br />
<a href="https://doc.rust-lang.org/std/cmp/trait.Eq.html">https://doc.rust-lang.org/std/cmp/trait.Eq.html</a>
</li>

<li>Struct std::boxed::Box<br />
<a href="https://doc.rust-lang.org/std/boxed/struct.Box.html">https://doc.rust-lang.org/std/boxed/struct.Box.html</a>
</li>

<li>Explore the ownership system in Rust<br />
<a href="https://nercury.github.io/rust/guide/2015/01/19/ownership.html">https://nercury.github.io/rust/guide/2015/01/19/ownership.html</a>
</li>

<li>Rust's ownership and move semantic<br/>
<a href="http://www.slideshare.net/saneyuki/rusts-ownership-and-move-semantics">http://www.slideshare.net/saneyuki/rusts-ownership-and-move-semantics</a>
</li>

<li>Trait std::marker::Copy<br/>
<a href="https://doc.rust-lang.org/stable/std/marker/trait.Copy.html">https://doc.rust-lang.org/stable/std/marker/trait.Copy.html</a>
</li>

<li>Trait std::clone::Clone<br />
<a href="https://doc.rust-lang.org/stable/std/clone/trait.Clone.html">https://doc.rust-lang.org/stable/std/clone/trait.Clone.html</a>
</li>

<li>The Stack and the Heap<br />
<a href="https://doc.rust-lang.org/book/the-stack-and-the-heap.html">https://doc.rust-lang.org/book/the-stack-and-the-heap.html</a>
</li>

<li>Rust Compare: Pointers &amp; References<br />
<a href="http://www.rust-compare.com/site/pointers.html">http://www.rust-compare.com/site/pointers.html</a>
</li>

<li>Rust Compare: Parameters<br />
<a href="http://www.rust-compare.com/site/params.html">http://www.rust-compare.com/site/params.html</a>
</li>

<li>Why does this compile? Automatic dereferencing?<br />
<a href="https://users.rust-lang.org/t/why-does-this-compile-automatic-dereferencing/2183">https://users.rust-lang.org/t/why-does-this-compile-automatic-dereferencing/2183</a>
</li>

<li>Understanding Pointers, Ownership, and Lifetimes in Rust<br />
<a href="http://koerbitz.me/posts/Understanding-Pointers-Ownership-and-Lifetimes-in-Rust.html">http://koerbitz.me/posts/Understanding-Pointers-Ownership-and-Lifetimes-in-Rust.html</a>
</li>

<li>Rust lang series episode #25 — pointers (#rust-series)<br />
<a href="https://steemit.com/rust-series/@jimmco/rust-lang-series-episode-25-pointers-rust-series">https://steemit.com/rust-series/@jimmco/rust-lang-series-episode-25-pointers-rust-series</a>
</li>

<li>Rust - home page<br />
<a href="https://www.rust-lang.org/en-US/">https://www.rust-lang.org/en-US/</a>
</li>

<li>Rust - Frequently Asked Questions<br />
<a href="https://www.rust-lang.org/en-US/faq.html">https://www.rust-lang.org/en-US/faq.html</a>
</li>

<li>Destructuring and Pattern Matching<br />
<a href="https://pzol.github.io/getting_rusty/posts/20140417_destructuring_in_rust/">https://pzol.github.io/getting_rusty/posts/20140417_destructuring_in_rust/</a>
</li>

<li>The Rust Programming Language<br />
<a href="https://doc.rust-lang.org/book/">https://doc.rust-lang.org/book/</a>
</li>

<li>Rust (programming language)<br />
<a href="https://en.wikipedia.org/wiki/Rust_%28programming_language%29">https://en.wikipedia.org/wiki/Rust_%28programming_language%29</a>
</li>

<li>Go - home page<br />
<a href="https://golang.org/">https://golang.org/</a>
</li>

<li>Stack Overflow - Most Loved, Dreaded, and Wanted language<br />
<a href="https://stackoverflow.com/research/developer-survey-2016#technology-most-loved-dreaded-and-wanted">https://stackoverflow.com/research/developer-survey-2016#technology-most-loved-dreaded-and-wanted</a>
</li>

<li>Rust vs Go (dva roky staré hodnocení, od té doby došlo k posunům v obou jazycích)<br />
<a href="http://jaredforsyth.com/2014/03/22/rust-vs-go/">http://jaredforsyth.com/2014/03/22/rust-vs-go/</a>
</li>

<li>Rust vs Go: My experience<br />
<a href="https://www.reddit.com/r/golang/comments/21m6jq/rust_vs_go_my_experience/">https://www.reddit.com/r/golang/comments/21m6jq/rust_vs_go_my_experience/</a>
</li>

<li>Friends of Rust (Organizations running Rust in production)<br />
<a href="https://www.rust-lang.org/en-US/friends.html">https://www.rust-lang.org/en-US/friends.html</a>
</li>

<li>Rust programs versus C++ g++<br />
<a href="https://benchmarksgame.alioth.debian.org/u64q/compare.php?lang=rust&lang2=gpp">https://benchmarksgame.alioth.debian.org/u64q/compare.php?lang=rust&lang2=gpp</a>
</li>

<li>Další benchmarky (nejedná se o reálné příklady &bdquo;ze života&ldquo;)<br />
<a href="https://github.com/kostya/benchmarks">https://github.com/kostya/benchmarks</a>
</li>

<li>Go na Redditu<br />
<a href="https://www.reddit.com/r/golang/">https://www.reddit.com/r/golang/</a>
</li>

<li>Rust vs. Go<br />
<a href="http://vschart.com/compare/rust/vs/go-language">http://vschart.com/compare/rust/vs/go-language</a>
</li>

<li>Abstraction without overhead: traits in Rust<br />
<a href="https://blog.rust-lang.org/2015/05/11/traits.html">https://blog.rust-lang.org/2015/05/11/traits.html</a>
</li>

<li>Method Syntax<br />
<a href="https://doc.rust-lang.org/book/method-syntax.html">https://doc.rust-lang.org/book/method-syntax.html</a>
</li>

<li>Traits in Rust<br />
<a href="https://doc.rust-lang.org/book/traits.html">https://doc.rust-lang.org/book/traits.html</a>
</li>

<li>Functional Programming in Rust - Part 1 : Function Abstraction<br />
<a href="http://blog.madhukaraphatak.com/functional-programming-in-rust-part-1/">http://blog.madhukaraphatak.com/functional-programming-in-rust-part-1/</a>
</li>

<li>Of the emerging systems languages Rust, D, Go and Nim, which is the strongest language and why?<br />
<a href="https://www.quora.com/Of-the-emerging-systems-languages-Rust-D-Go-and-Nim-which-is-the-strongest-language-and-why">https://www.quora.com/Of-the-emerging-systems-languages-Rust-D-Go-and-Nim-which-is-the-strongest-language-and-why</a>
</li>

<li>Chytré ukazatele (moderní verze jazyka C++) [MSDN]<br />
<a href="https://msdn.microsoft.com/cs-cz/library/hh279674.aspx">https://msdn.microsoft.com/cs-cz/library/hh279674.aspx</a>
</li>

<li>UTF-8 Everywhere<br />
<a href="http://utf8everywhere.org/">http://utf8everywhere.org/</a>
</li>

<li>Rust by Example<br />
<a href="http://rustbyexample.com/">http://rustbyexample.com/</a>
</li>

<li>Rust oficiálně ve Fedoře<br />
<a href="https://mojefedora.cz/rust-oficialne-ve-fedore/">https://mojefedora.cz/rust-oficialne-ve-fedore/</a>
</li>

<li>Resource acquisition is initialization<br />
<a href="https://en.wikipedia.org/wiki/Resource_acquisition_is_initialization">https://en.wikipedia.org/wiki/Resource_acquisition_is_initialization</a>
</li>

<li>TIOBE index (October 2016)<br />
<a href="http://www.tiobe.com/tiobe-index/">http://www.tiobe.com/tiobe-index/</a>
</li>

<li>Porovnání Go, D a Rustu na OpenHubu:<br />
<a href="https://www.openhub.net/languages/compare?language_name[]=-1&language_name[]=-1&language_name[]=dmd&language_name[]=golang&language_name[]=rust&language_name[]=-1&measure=commits">https://www.openhub.net/languages/compare?language_name[]=-1&language_name[]=-1&language_name[]=dmd&language_name[]=golang&language_name[]=rust&language_name[]=-1&measure=commits</a>
</li>

<li>String Types in Rust<br />
<a href="http://www.suspectsemantics.com/blog/2016/03/27/string-types-in-rust/">http://www.suspectsemantics.com/blog/2016/03/27/string-types-in-rust/</a>
</li>

<li>Trait (computer programming)<br />
<a href="https://en.wikipedia.org/wiki/Trait_%28computer_programming%29">https://en.wikipedia.org/wiki/Trait_%28computer_programming%29</a>
</li>

<li>Type inference<br />
<a href="https://en.wikipedia.org/wiki/Type_inference">https://en.wikipedia.org/wiki/Type_inference</a>
</li>

</ol>



<p></p><p></p>
<p><small>Autor: <a href="http://www.fit.vutbr.cz/~tisnovpa">Pavel Tišnovský</a> &nbsp; 2017</small></p>
</body>
</html>

