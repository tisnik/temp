<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
        "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html>
<head>
<title>Multimediální knihovna Pyglet: Phongův osvětlovací model použitý v OpenGL</title>
<meta name="Author" content="Pavel Tisnovsky" />
<meta name="Generator" content="vim" />
<meta http-equiv="content-type" content="text/html; charset=utf-8" />
<style type="text/css">
         body {color:#000000; background:#ffffff;}
         h1  {font-family: arial, helvetica, sans-serif; color:#ffffff; background-color:#c00000; text-align:center; padding-left:1em}
         h2  {font-family: arial, helvetica, sans-serif; color:#ffffff; background-color:#0000c0; padding-left:1em; text-align:left}
         h3  {font-family: arial, helvetica, sans-serif; color:#000000; background-color:#c0c0c0; padding-left:1em; text-align:left}
         h4  {font-family: arial, helvetica, sans-serif; color:#000000; background-color:#e0e0e0; padding-left:1em; text-align:left}
         a   {font-family: arial, helvetica, sans-serif;}
         li  {font-family: arial, helvetica, sans-serif; color:#000000; text-align:justify; width:450px;}
         ol  {font-family: arial, helvetica, sans-serif; color:#000000; text-align:justify; width:450px;}
         ul  {font-family: arial, helvetica, sans-serif; color:#000000; text-align:justify; width:450px;}
         p   {font-family: arial, helvetica, sans-serif; color:#000000; text-align:justify;}
         pre {background:#e0e0e0}
</style>
</head>

<body>

<h1>Multimediální knihovna Pyglet: Phongův osvětlovací model použitý v OpenGL</h1>

<h3>Pavel Tišnovský</h3>

<p></p>

<h1>Úvodník</h1>

<p>V&nbsp;dnešní části seriálu o multimediální knihovně Pyglet si podrobněji popíšeme princip Phongova osvětlovacího modelu, který se používá pro výpočet barvy na povrchu trojrozměrných těles. Také si popíšeme způsoby definování normál (normálových vektorů) k&nbsp;povrchu těles, protože při použití Phongova osvětlovacího modelu je zapotřebí nějakým způsobem určit normálu ke každému bodu na povrchu tělesa.</p>



<h2>Obsah</h2>

<p><a href="#k01">1. Multimediální knihovna Pyglet: Phongův osvětlovací model použitý v&nbsp;OpenGL</a></p>
<p><a href="#k02">2. Phongův osvětlovací model</a></p>
<p><a href="#k03">3. Význam členů rovnice Phongova osvětlovacího modelu</a></p>
<p><a href="#k04">4. Normálové vektory</a></p>
<p><a href="#k05">5. Normalizace normálových vektorů</a></p>
<p><a href="#k06">6. Typy stínování v&nbsp;OpenGL</a></p>
<p><a href="#k07">*** 7. Kvadriky vykreslované přes GLU a normálové vektory jejich ploch</a></p>
<p><a href="#k08">*** 8. Nastavení ambientní složky materiálu</a></p>
<p><a href="#k09">*** 9. Nastavení difúzní složky materiálu</a></p>
<p><a href="#k10">*** 10. Nastavení odlesků</a></p>
<p><a href="#k11">*** 11. Specifikace stínovacího modelu</a></p>
<p><a href="#k12">*** 12. První demonstrační příklad &ndash; vykreslení modelu koule, materiál má nastavenou jen ambientní složku</a></p>
<p><a href="#k13">*** 13. Druhý demonstrační příklad &ndash; vykreslení modelu koule, materiál má nastavenou ambientní a difúzní složku</a></p>
<p><a href="#k14">*** 14. Třetí demonstrační příklad &ndash; vykreslení modelu koule, materiál má nastavené i odlesky</a></p>
<p><a href="#k15">*** 15. Čtvrtý demonstrační příklad &ndash; osvětlovací model a těleso s&nbsp;plochami bez normálových vektorů</a></p>
<p><a href="#k16">*** 16. Repositář s&nbsp;demonstračními příklady</a></p>
<p><a href="#k17">17. Odkazy na Internetu</a></p>



<p><a name="k01"></a></p>
<h2 id="k01">1. Multimediální knihovna Pyglet: Phongův osvětlovací model použitý v&nbsp;OpenGL</h2>

<p>V&nbsp;grafické knihovně OpenGL, jejíž funkce lze z&nbsp;Pygletu volat, se pro výpočet barvy povrchu těles (složených z&nbsp;plošek) používá takzvaný <i>Phongův osvětlovací model</i> (pozor &ndash; neplést s&nbsp;Phongovým stínováním, což je sice podobně pojmenovaná, ovšem odlišná technologie). Tento osvětlovací model byl zvolen z&nbsp;toho důvodu, aby byl výpočet osvětlení co nejrychlejší, ale současně, aby osvětlení výsledné scény působilo přirozeně. Výsledkem obou těchto snah je samozřejmě určitý kompromisní model, který však poskytuje pozoruhodně kvalitní výsledky. Odborníci na počítačovou grafiku samozřejmě mohou oprávněně namítnout, že existují i fyzikálně přesnější modely, například model Cook-Torrancův, ty jsou však výpočetně složitější, proto se nehodí pro real-time grafiku (hry, dema, multimediální aplikace), na kterou je knihovna Pyglet a samozřejmě taktéž OpenGL zaměřena. Tyto přesnější modely lze využít například v&nbsp;některých pokročilejších raytracerech (ale nutno říci, že zdaleka ne ve všech).</p>

*** image ***
<p><i>Obrázek 1: Phongův osvětlovací model se používá i v&nbsp;raytracerech pro fotorealistické zobrazení scén.</i></p>



<p><a name="k02"></a></p>
<h2 id="k02">2. Phongův osvětlovací model</h2>

<p>V&nbsp;Phongově osvětlovacím modelu se světlo na povrchu tělesa rozkládá do tří typů světelných složek: ambientní složky (<i>ambient light</i>), difúzní složky (<i>diffuse light</i>) a odlesků (<i>specular light</i>). V&nbsp;tomto modelu se navíc celková intenzita světla počítá zvlášť pro každou barevnou složku z&nbsp;barvového modelu RGB (<i>red</i>, <i>green</i>, <i>blue</i>). Pro výpočet se používá vztah, který je aplikován na každou barevnou složku zvlášť, ve skutečnosti tedy počítáme intenzity <i>I<sub>red</sub>, I<sub>green</sub>, I<sub>blue</sub></i>. Rovnice pro výpočet barvy každého bodu na ploše objektů vypadá následovně:</p>

<p><i>I = c<sub>a</sub>I<sub>a</sub> + c<sub>d</sub>I<sub>d</sub>(NL) + c<sub>s</sub>I<sub>s</sub>(VR)<sup>n</sup></i></p>



<p><a name="k03"></a></p>
<h2 id="k03">3. Význam členů rovnice Phongova osvětlovacího modelu</h2>

<p>Význam jednotlivých členů použitých ve výše uvedeném vztahu je následující:</p>

<ul>

<li><i>I</i> představuje celkovou intenzitu světla tak, jak je vnímána uživatelem. Ve skutečnosti se vždy spočítají tři na sobě nezávislé barevné složky R, G, B, takže se předchozí vztah počítá třikrát (<i>I<sub>red</sub>, I<sub>green</sub>, I<sub>blue</sub></i>).</li>

<li><i>I<sub>a</sub></i> představuje intenzitu ambientní složky světla, tj.&nbsp;té části světla, která na osvětlované těleso dopadá ze všech směrů rovnoměrně. Intenzita odraženého světla (tj.&nbsp;součinu <i>c<sub>a</sub>I<sub>a</sub></i>) je nezávislá na vzájemné poloze zdroje, tělesa a pozorovatele. Hodnota tohoto členu v&nbsp;předchozí rovnici se nastavuje při vytváření <strong>světla</strong>.</li>

<li><i>I<sub>d</sub></i> představuje intenzitu difúzní složky světla, tj.&nbsp;té části světla, která dopadá na těleso z&nbsp;jednoho světelného zdroje (ať už bodového či směrového) a odráží se do všech směrů rovnoměrně. Intenzita odraženého světla (tj.&nbsp;součinu <i>c<sub>d</sub>I<sub>d</sub>(NL)</i>) je závislá na vzájemné poloze normály stěny tělesa <i>N</i> a vektoru dopadu světla <i>L</i> (viz další text). Hodnota tohoto členu v&nbsp;předchozí rovnici se nastavuje při vytváření <strong>světla</strong>.</li>

<li><i>I<sub>s</sub></i> představuje intenzitu odlesků, tj.&nbsp;té části světla, která dopadá na těleso z&nbsp;jednoho světelného zdroje (opět může jít buď o bodový nebo směrový zdroj světla) a odráží se převážně v&nbsp;jednom směru podle zákona odrazu světelných paprsků. Intenzita tohoto odraženého světla závisí na vzájemné poloze světelného zdroje, povrchu tělesa a pozice pozorovatele. Hodnota tohoto členu v&nbsp;předchozí rovnici se nastavuje při vytváření <strong>světla</strong>.</li>

<li><i>c<sub>a</sub></i> je koeficient (resp.&nbsp;přesněji řečeno faktor) materiálu pro ambientní složku světla. Pro běžné materiály nabývá tento koeficient hodnot v&nbsp;rozmezí 0 až 1, kde nulová hodnota znamená, že se ambientní světlo od materiálu vůbec neodráží, hodnota 1 naopak nastavuje úplnou odrazivost. Hodnota tohoto členu v&nbsp;předchozí rovnici se nastavuje při vytváření <strong>materiálu</strong>.</li>

<li><i>c<sub>d</sub></i> je koeficient materiálu pro difúzní složku světla. Pro běžné materiály nabývá tento koeficient hodnot v&nbsp;rozmezí 0 až 1 s&nbsp;podobným významem jako u předchozího koeficientu. Ve většině případů lze ambientní a difúzní koeficient materiálu nastavit na stejnou hodnotu, což je v&nbsp;OpenGL samozřejmě podporováno. Hodnota tohoto členu v&nbsp;předchozí rovnici se nastavuje při vytváření <strong>materiálu</strong>.</li>

<li><i>c<sub>s</sub></i> je koeficient odlesků s&nbsp;vlastnostmi podobnými jako u předchozích dvou koeficientů. Zde je nutné si uvědomit, že ve skutečnosti každý koeficient nastavujeme třikrát pro tři barevné složky RGB. Hodnota těchto koeficientů potom udává barvu materiálu při osvětlení bílým světlem, protože pouze bílé světlo je nastaveno na hodnotu (1.0, 1.0, 1.0). Při jiném osvětlení se mezi sebou pronásobí intenzity složek světelného zdroje a koeficienty materiálů, takže například sytě červený objekt bude v&nbsp;sytě modrém světle na obrazovce černý!</li>

<li>V&nbsp;součinu <i>NL</i> je použita normála k&nbsp;povrchu tělesa <i>N</i> a vektor ze světelného zdroje do bodu na povrchu tělesa, jehož barvu počítáme. Pokud jsou tyto vektory lineárně závislé (tj.&nbsp;rovnoběžné), je světelný zdroj umístěn kolmo nad povrchem tělesa a tím pádem je difúzní složka světla nejvíce intenzivní. Význam těchto dvou vektorů je zobrazen na prvním obrázku. Ještě před výpočtem skalárního součinu <i>NL</i> musí být oba vektory normalizovány, tj.&nbsp;jejich velikost musí být jednotková.</li>

<li>V&nbsp;součinu <i>VR</i> je použit vektor ideálně odraženého paprsku <i>R</i> a vektor z&nbsp;pozice pozorovatele do bodu na povrchu tělesa <i>V</i>, jehož barvu počítáme. Vektor <i>R</i> lze vypočítat ze znalosti vektorů <i>L</i> (vektor světla) a <i>N</i> (normála k&nbsp;povrchu) &ndash; postup je naznačen na druhém obrázku. Význam těchto dvou vektorů je zobrazen na prvním obrázku. Podobně jako u vektorů <i>N</i> a <i>L</i>, i vektory <i>V</i> a <i>R</i> musí být normalizovány.</li>

<li><i>n</i> je exponent u výrazu <i>(VR)<sup>n</sup></i>, který udává míru lesklosti tělesa. Difúzní těleso bude mít exponent nulový, vysoce lesklé těleso zde může mít hodnotu například 50. Čím vyšší je hodnota tohoto exponentu, tím jsou odlesky na tělese menší (plochou) ale intenzivnější. Vliv velikosti exponentu na lesklosti je zobrazený na třetím obrázku.</li>

</ul>

*** image ***
<p><i>Obrázek 2: Vektory použité v Phongově osvětlovacím modelu</i></p>

*** image ***
<p><i>Obrázek 3: Postup při výpočtu odraženého paprsku &ndash; vektoru R</i></p>

*** image ***
<p><i>Obrázek 4: Vliv velikosti exponentu na lesklost materiálu</i></p>



<p><a name="k04"></a></p>
<h2 id="k04">4. Normálové vektory</h2>

<p>Při výpočtu osvětlení je bezpodmínečně nutné zadávat u každého vrcholu jeho normálu (normálový vektor), jinak by nebylo možné spočítat barvu na povrchu tělesa (viz předchozí vzorec, kde se vyskytuje vektor <i>N</i>). Pokud není normála nastavena, bere se implicitní hodnota normály <i>N=(0.0, 0.0, 1.0)</i> (tj.&nbsp;normála míří ve směru osy <strong>z</strong>) což není v&nbsp;naprosté většině případů korektní. Příkaz pro nastavení normály je velmi podobný příkazu pro nastavení barvy nebo polohy vertexu, avšak na rozdíl od těchto příkazů, které existovaly ve více verzích s&nbsp;různým počtem parametrů, se vždy zadávají tři složky normálového vektoru: <i>nx</i>, <i>ny</i> a <i>nz</i>. Normála vrcholu je, podobně jako barva, stavová veličina, takže je možné jednu hodnotu normály použít i pro více vrcholů. V&nbsp;závislosti na typu dat použitých pro reprezentaci normály je možné zvolit jednu z&nbsp;těchto funkcí (v&nbsp;Pythonu se bude většinou jednat o typ <i>double</i>):</p>

<pre>
void glNormal3b(
  GLbyte nx,  
  GLbyte ny,  
  GLbyte nz   
);
 
void glNormal3s(
  GLshort nx,  
  GLshort ny,  
  GLshort nz   
);

void glNormal3i(
  GLint nx,  
  GLint ny,  
  GLint nz   
);
 
void glNormal3f(
  GLfloat nx,  
  GLfloat ny,  
  GLfloat nz   
);
 
void glNormal3d(
  GLdouble nx,  
  GLdouble ny,  
  GLdouble nz   
);
</pre>
 
<p>Další možností je použití funkcí, které jako svůj parametr akceptují pole o třech prvcích (opět je možné použít i v&nbsp;Pythonu):</p>

<pre>
void glNormal3bv(
  const GLbyte *v   
);
 
void glNormal3sv(
  const GLshort *v   
);
 
void glNormal3iv(
  const GLint *v   
);
 
void glNormal3fv(
  const GLfloat *v   
);
 
void glNormal3dv(
  const GLdouble *v   
);
</pre>



<p><a name="k05"></a></p>
<h2 id="k05">5. Normalizace normálových vektorů</h2>

<p>Pro korektní funkčnost výpočtu osvětlení musí být každý normálový vektor <i>normalizován</i>, tj.&nbsp;délka tohoto vektoru musí být jednotková. Normalizaci je možné provést buď programově, nebo automaticky s&nbsp;využitím příslušných funkcí OpenGL.</p>

<p>Programová normalizace spočívá v&nbsp;tom, že se vypočte délka normálového vektoru podle vzorce:</p>

<p><i>L=sqrt(n<sub>x</sub><sup>2</sup>+n<sub>y</sub><sup>2</sup>+n<sub>z</sub><sup>2</sup>)</i></p>

<p>Touto délkou se následně vydělí každá složka normálového vektoru:<br>
<i>n<sub>x</sub>'=n<sub>x</sub> / L</i><br>
<i>n<sub>y</sub>'=n<sub>y</sub> / L</i><br>
<i>n<sub>z</sub>'=n<sub>z</sub> / L</i></p>

<p>Druhou možností je povolení automatické normalizace, což se provede funkcí <strong>glEnable(GL_NORMALIZE)</strong>. Zakázání se provede příkazem <strong>glDisable(GL_NORMALIZE)</strong>. Při provádění automatické normalizace se však buď programově nebo na grafickém akcelerátoru provádí relativně složité matematické operace, jako jsou odmocniny a podíly, což může výrazně zpomalovat vykreslování celé trojrozměrné scény. Proto je výhodnější normalizaci provést programově před začátkem vykreslování nebo mít již normály uložené v&nbsp;normalizované podobě, tak jak to dělají některé 3D modelovací programy.</p>



<p><a name="k06"></a></p>
<h2 id="k06">6. Typy stínování v&nbsp;OpenGL</h2>

<p>V&nbsp;knihovně OpenGL lze používat dva typy stínování: <i>konstantní</i> a <i>Gouraudovo</i>. Pomocí speciálních programovacích technik však lze dosáhnout i <i>Phongova stínování</i> (pozor, neplést s&nbsp;Phongovým osvětlovacím modelem, který byl <a href="#k02">popsán výše</a>).</p>

<p>Při použití <i>konstantního stínování</i> je pro každou plošku (tj.&nbsp;například trojúhelník) spočítána jedna barva a celá ploška je při vykreslování touto barvou vykreslena. Výsledkem je, že jsou na zobrazovaném tělese jasně patrné všechny hrany mezi ploškami, což je nepříjemné zvláště u oblých tvarů.</p>

<p>Problém viditelnosti hran částečně řeší <i>Gouraudovo stínování</i>, u kterého se spočítají barvy jednotlivých vrcholů (normály jsou zadané pro vrcholy, takže se přímo použije dříve uvedený vzorec) a vykreslovaná ploška mezi těmito vrcholy je vyplněna přechodem mezi těmito barvami. Výsledkem jsou jemnější hrany, které jsou méně viditelné. Gouraudovo stínování samozřejmě způsobuje také vizuální chyby, protože se osvětlení počítá pouze ve vrcholech a ignorují se světelné podmínky na ploškách. To například znamená, že zejména na velkých plochách jsou jasně patrné absence odlesků.</p>

<p>Konstantní stínování se zapne příkazem <strong>glShadeModel(GL_FLAT)</strong>, Gouraudovo stínování potom příkazem <strong>glShadeModel(GL_SMOOTH)</strong>. Ukázky obou typů stínování jsou předvedeny v&nbsp;trojici demonstračních příkladů.</p>



<p><a name="k07"></a></p>
<h2 id="k07">7. Kvadriky vykreslované přes GLU a normálové vektory jejich ploch</h2>

<p></p>

<pre>
def draw_quadric(drawStyle, slices, stacks):
    radius = 8.0
    quadric = gluNewQuadric()                   # vytvoreni kvadriky
    gluQuadricDrawStyle(quadric, drawStyle)     # nastaveni vlastnosti kvadriky
    gluQuadricNormals(quadric, GLU_SMOOTH)      # smer generovanych normal
    gluSphere(quadric, radius, slices, stacks)  # vykresleni kvadriky
    gluDeleteQuadric(quadric)                   # zruseni kvadriky
</pre>

<p></p>

<pre>
quadricDrawStyle = GLU_FILL                     # styl vykreslovani kvadriky
sphereSlices = 20                               # rozdeleni koule na 'poledniky'
sphereStacks = 20                               # rozdeleni koule na 'rovnobezky'
</pre>

<p></p>

<pre>
@window.event
def on_key_press(symbol, modifiers):
    global quadricDrawStyle
    global sphereSlices, sphereStacks

    if symbol == key.L:
        quadricDrawStyle = GLU_LINE
    if symbol == key.P:
        quadricDrawStyle = GLU_POINT
    if symbol == key.F:
        quadricDrawStyle = GLU_FILL
    if symbol == key.PAGEUP:
        sphereStacks += 1
    if symbol == key.PAGEDOWN:
        if sphereStacks &gt; 1:
            sphereStacks -= 1
    if symbol == key.HOME:
        if sphereSlices &gt; 1:
            sphereSlices -= 1
    if symbol == key.END:
        sphereSlices += 1
</pre>



<p><a name="k08"></a></p>
<h2 id="k08">8. Nastavení ambientní složky materiálu</h2>

<p></p>

<pre>
materialAmbient = [1.0, 0.0, 0.0, 1.0]     # ambientni slozka barvy materialu

materialAmbient_gl = float_array(materialAmbient)
glMaterialfv(GL_FRONT, GL_AMBIENT, materialAmbient_gl)
</pre>

<pre>
def float_array(list):
    ''' Prevod seznamu na pole prvku typ GLfloat '''
    return (GLfloat * len(list))(*list)
</pre>



<p><a name="k09"></a></p>
<h2 id="k09">9. Nastavení difúzní složky materiálu</h2>

<p></p>

<pre>
materialDiffuse = [0.7, 0.7, 0.7, 0.0]     # difuzni slozka barvy materialu

materialDiffuse_gl = float_array(materialDiffuse)
glMaterialfv(GL_FRONT, GL_DIFFUSE, materialDiffuse_gl)
</pre>



<p><a name="k10"></a></p>
<h2 id="k10">10. Nastavení odlesků</h2>

<p></p>

<pre>
materialSpecular = [1.0, 1.0, 1.0, 1.0]    # barva odlesku
materialShininess = [50.0]                 # faktor odlesku

materialSpecular_gl = float_array(materialSpecular)
materialShininess_gl = float_array(materialShininess)

# nastaveni barvy odlesku
glMaterialfv(GL_FRONT, GL_SPECULAR, materialSpecular_gl)

# nastaveni faktoru odlesku
glMaterialfv(GL_FRONT, GL_SHININESS, materialShininess_gl)
</pre>



<p><a name="k11"></a></p>
<h2 id="k11">11. Specifikace stínovacího modelu</h2>

<pre>
shadeModel = GL_SMOOTH                     # algoritmus vyplnovani plosek
</pre>

<pre>
def set_shade_model(shadeModel):
    glShadeModel(shadeModel)
</pre>

<pre>
@window.event
def on_key_press(symbol, modifiers):
    global shadeModel

    if symbol == key.X:
        shadeModel = GL_FLAT
    if symbol == key.C:
        shadeModel = GL_SMOOTH
</pre>



<p><a name="k12"></a></p>
<h2 id="k12">12. První demonstrační příklad &ndash; vykreslení modelu koule, materiál má nastavenou jen ambientní složku</h2>

<pre>
#!/usr/bin/env python

import pyglet
from pyglet.gl import *
from pyglet.window import key

fov = 70.0                                 # zorny uhel (field of view)
nearPlane = 0.1                            # blizsi orezavaci rovina
farPlane = 90.0                            # vzdalenejsi orezavaci rovina

r1 = 0.0
r2 = 0.0
r3 = 0.0

depthBufferEnabled = True                  # povoleni ci zakaz Z-bufferu

shadeModel = GL_SMOOTH                     # algoritmus vyplnovani plosek

quadricDrawStyle = GLU_FILL                # styl vykreslovani kvadriky
sphereSlices = 20                          # rozdeleni koule na 'poledniky'
sphereStacks = 20                          # rozdeleni koule na 'rovnobezky'


window = pyglet.window.Window(width=500,
                              height=500,
                              caption="Pyglet library")

keys = key.KeyStateHandler()

# parametry, ktere ovlivnuji osvetleni
materialAmbient = [1.0, 0.0, 0.0, 1.0]     # ambientni slozka barvy materialu
materialDiffuse = [0.0, 0.0, 0.0, 0.0]     # difuzni slozka barvy materialu
lightPosition = [10.0, 10.0, 20.0, 0.0]    # pozice svetla


def float_array(list):
    ''' Prevod seznamu na pole prvku typ GLfloat '''
    return (GLfloat * len(list))(*list)


def set_material():
    materialAmbient_gl = float_array(materialAmbient)
    materialDiffuse_gl = float_array(materialDiffuse)

    # nastaveni ambientni slozky barvy materialu
    glMaterialfv(GL_FRONT, GL_AMBIENT, materialAmbient_gl)
    glMaterialfv(GL_FRONT, GL_DIFFUSE, materialDiffuse_gl)


def set_light():
    lightPosition_gl = (GLfloat * len(lightPosition))(*lightPosition)

    # nastaveni pozice svetla
    glLightfv(GL_LIGHT0, GL_POSITION, lightPosition_gl)

    glEnable(GL_LIGHTING)                  # globalni povoleni stinovani
    glEnable(GL_LIGHT0)                    # povoleni prvniho svetla


def init():
    glClearColor(0.0, 0.0, 0.8, 0.0)       # barva pozadi obrazku
    glPolygonMode(GL_FRONT, GL_FILL)       # nastaveni rezimu vykresleni modelu
    glPolygonMode(GL_BACK, GL_FILL)
    # zakaz odstranovani hran nebo sten podle jejich normal
    glDisable(GL_CULL_FACE)
    glDepthFunc(GL_LESS)                   # funkce pro testovani fragmentu

    glShadeModel(GL_SMOOTH)                # nastaveni stinovaciho rezimu
    glPointSize(3.0)                       # velikost vykreslovanych bodu

    set_material()
    set_light()


@window.event
def on_resize(width, height):
    init()
    glViewport(0, 0, width, height)        # viditelna oblast pres cele okno


def draw_quadric(drawStyle, slices, stacks):
    radius = 8.0
    quadric = gluNewQuadric()                   # vytvoreni kvadriky
    gluQuadricDrawStyle(quadric, drawStyle)     # nastaveni vlastnosti kvadriky
    gluQuadricNormals(quadric, GLU_SMOOTH)      # smer generovanych normal
    gluSphere(quadric, radius, slices, stacks)  # vykresleni kvadriky
    gluDeleteQuadric(quadric)                   # zruseni kvadriky


def set_depth_buffer(depthBufferEnabled):
    if depthBufferEnabled:
        glEnable(GL_DEPTH_TEST)
    else:
        glDisable(GL_DEPTH_TEST)


def clear_buffers(depthBufferEnabled):
    if depthBufferEnabled:
        # vymazani vsech bitovych rovin barvoveho bufferu i Z bufferu
        glClear(GL_COLOR_BUFFER_BIT | GL_DEPTH_BUFFER_BIT)
    else:
        # vymazani vsech bitovych rovin barvoveho bufferu
        glClear(GL_COLOR_BUFFER_BIT)


def set_projection_matrix(fov, nearPlane, farPlane):
    # zacatek modifikace projekcni matice
    glMatrixMode(GL_PROJECTION)
    # vymazani projekcni matice (=identita)
    glLoadIdentity()
    gluPerspective(fov, 1.0, nearPlane, farPlane)


def set_modelview_matrix(rotation1, rotation2):
    glMatrixMode(GL_MODELVIEW)
    glLoadIdentity()                       # nahrat jednotkovou matici

    gluLookAt(4.0, 6.0, 18.0,              # bod, odkud se kamera diva
              0.0, 2.0,  0.0,              # bod, kam se kamera diva
              0.0, 1.0,  0.0)              # poloha "stropu" ve scene

    glRotatef(rotation1, 1.0, 0.0, 0.0)    # rotace objektu
    glRotatef(rotation2, 0.0, 1.0, 0.0)


def set_shade_model(shadeModel):
    glShadeModel(shadeModel)


@window.event
def on_key_press(symbol, modifiers):
    global depthBufferEnabled
    global quadricDrawStyle
    global sphereSlices, sphereStacks
    global shadeModel

    if symbol == key.Z:
        depthBufferEnabled = not depthBufferEnabled
    if symbol == key.L:
        quadricDrawStyle = GLU_LINE
    if symbol == key.P:
        quadricDrawStyle = GLU_POINT
    if symbol == key.F:
        quadricDrawStyle = GLU_FILL
    if symbol == key.X:
        shadeModel = GL_FLAT
    if symbol == key.C:
        shadeModel = GL_SMOOTH
    if symbol == key.PAGEUP:
        sphereStacks += 1
    if symbol == key.PAGEDOWN:
        if sphereStacks &gt; 1:
            sphereStacks -= 1
    if symbol == key.HOME:
        if sphereSlices &gt; 1:
            sphereSlices -= 1
    if symbol == key.END:
        sphereSlices += 1


@window.event
def on_draw():
    global r1, r2, r3

    if keys[key.LEFT]:
        r2 -= 2
    if keys[key.RIGHT]:
        r2 += 2
    if keys[key.UP]:
        r1 -= 2
    if keys[key.DOWN]:
        r1 += 2
    if keys[key.Q]:
        r3 -= 2
    if keys[key.W]:
        r3 += 2

    clear_buffers(depthBufferEnabled)
    set_shade_model(shadeModel)
    set_depth_buffer(depthBufferEnabled)
    set_projection_matrix(fov, nearPlane, farPlane)
    set_modelview_matrix(r1, r2)

    # nastaveni pozice svetla
    glPushMatrix()
    lightPosition_gl = (GLfloat * len(lightPosition))(*lightPosition)
    glRotatef(r3, 1.0, 0.0, 0.0)
    glLightfv(GL_LIGHT0, GL_POSITION, lightPosition_gl)
    glPopMatrix()

    draw_quadric(quadricDrawStyle, sphereSlices, sphereStacks)


window.push_handlers(keys)
pyglet.app.run()
</pre>



<p><a name="k13"></a></p>
<h2 id="k13">13. Druhý demonstrační příklad &ndash; vykreslení modelu koule, materiál má nastavenou ambientní a difúzní složku</h2>

<pre>
#!/usr/bin/env python

import pyglet
from pyglet.gl import *
from pyglet.window import key

fov = 70.0                                 # zorny uhel (field of view)
nearPlane = 0.1                            # blizsi orezavaci rovina
farPlane = 90.0                            # vzdalenejsi orezavaci rovina

r1 = 0.0
r2 = 0.0
r3 = 0.0

depthBufferEnabled = True                  # povoleni ci zakaz Z-bufferu

shadeModel = GL_SMOOTH                     # algoritmus vyplnovani plosek

quadricDrawStyle = GLU_FILL                # styl vykreslovani kvadriky
sphereSlices = 20                          # rozdeleni koule na 'poledniky'
sphereStacks = 20                          # rozdeleni koule na 'rovnobezky'


window = pyglet.window.Window(width=500,
                              height=500,
                              caption="Pyglet library")

keys = key.KeyStateHandler()

# parametry, ktere ovlivnuji osvetleni
materialAmbient = [0.0, 0.0, 0.0, 1.0]     # ambientni slozka barvy materialu
materialDiffuse = [0.7, 0.7, 0.7, 0.0]     # difuzni slozka barvy materialu
lightPosition = [10.0, 10.0, 20.0, 0.0]    # pozice svetla


def float_array(list):
    ''' Prevod seznamu na pole prvku typ GLfloat '''
    return (GLfloat * len(list))(*list)


def set_material():
    materialAmbient_gl = float_array(materialAmbient)
    materialDiffuse_gl = float_array(materialDiffuse)

    # nastaveni ambientni slozky barvy materialu
    glMaterialfv(GL_FRONT, GL_AMBIENT, materialAmbient_gl)
    glMaterialfv(GL_FRONT, GL_DIFFUSE, materialDiffuse_gl)


def set_light():
    lightPosition_gl = (GLfloat * len(lightPosition))(*lightPosition)

    # nastaveni pozice svetla
    glLightfv(GL_LIGHT0, GL_POSITION, lightPosition_gl)

    glEnable(GL_LIGHTING)                  # globalni povoleni stinovani
    glEnable(GL_LIGHT0)                    # povoleni prvniho svetla


def init():
    glClearColor(0.0, 0.0, 0.3, 0.0)       # barva pozadi obrazku
    glPolygonMode(GL_FRONT, GL_FILL)       # nastaveni rezimu vykresleni modelu
    glPolygonMode(GL_BACK, GL_FILL)
    # zakaz odstranovani hran nebo sten podle jejich normal
    glDisable(GL_CULL_FACE)
    glDepthFunc(GL_LESS)                   # funkce pro testovani fragmentu

    glShadeModel(GL_SMOOTH)                # nastaveni stinovaciho rezimu
    glPointSize(3.0)                       # velikost vykreslovanych bodu

    set_material()
    set_light()


@window.event
def on_resize(width, height):
    init()
    glViewport(0, 0, width, height)        # viditelna oblast pres cele okno


def draw_quadric(drawStyle, slices, stacks):
    radius = 8.0
    quadric = gluNewQuadric()                   # vytvoreni kvadriky
    gluQuadricDrawStyle(quadric, drawStyle)     # nastaveni vlastnosti kvadriky
    gluQuadricNormals(quadric, GLU_SMOOTH)      # smer generovanych normal
    gluSphere(quadric, radius, slices, stacks)  # vykresleni kvadriky
    gluDeleteQuadric(quadric)                   # zruseni kvadriky


def set_depth_buffer(depthBufferEnabled):
    if depthBufferEnabled:
        glEnable(GL_DEPTH_TEST)
    else:
        glDisable(GL_DEPTH_TEST)


def clear_buffers(depthBufferEnabled):
    if depthBufferEnabled:
        # vymazani vsech bitovych rovin barvoveho bufferu i Z bufferu
        glClear(GL_COLOR_BUFFER_BIT | GL_DEPTH_BUFFER_BIT)
    else:
        # vymazani vsech bitovych rovin barvoveho bufferu
        glClear(GL_COLOR_BUFFER_BIT)


def set_projection_matrix(fov, nearPlane, farPlane):
    # zacatek modifikace projekcni matice
    glMatrixMode(GL_PROJECTION)
    # vymazani projekcni matice (=identita)
    glLoadIdentity()
    gluPerspective(fov, 1.0, nearPlane, farPlane)


def set_modelview_matrix(rotation1, rotation2):
    glMatrixMode(GL_MODELVIEW)
    glLoadIdentity()                       # nahrat jednotkovou matici

    gluLookAt(4.0, 6.0, 18.0,              # bod, odkud se kamera diva
              0.0, 2.0,  0.0,              # bod, kam se kamera diva
              0.0, 1.0,  0.0)              # poloha "stropu" ve scene

    glRotatef(rotation1, 1.0, 0.0, 0.0)    # rotace objektu
    glRotatef(rotation2, 0.0, 1.0, 0.0)


def set_shade_model(shadeModel):
    glShadeModel(shadeModel)


@window.event
def on_key_press(symbol, modifiers):
    global depthBufferEnabled
    global quadricDrawStyle
    global sphereSlices, sphereStacks
    global shadeModel

    if symbol == key.Z:
        depthBufferEnabled = not depthBufferEnabled
    if symbol == key.L:
        quadricDrawStyle = GLU_LINE
    if symbol == key.P:
        quadricDrawStyle = GLU_POINT
    if symbol == key.F:
        quadricDrawStyle = GLU_FILL
    if symbol == key.X:
        shadeModel = GL_FLAT
    if symbol == key.C:
        shadeModel = GL_SMOOTH
    if symbol == key.PAGEUP:
        sphereStacks += 1
    if symbol == key.PAGEDOWN:
        if sphereStacks &gt; 1:
            sphereStacks -= 1
    if symbol == key.HOME:
        if sphereSlices &gt; 1:
            sphereSlices -= 1
    if symbol == key.END:
        sphereSlices += 1


@window.event
def on_draw():
    global r1, r2, r3

    if keys[key.LEFT]:
        r2 -= 2
    if keys[key.RIGHT]:
        r2 += 2
    if keys[key.UP]:
        r1 -= 2
    if keys[key.DOWN]:
        r1 += 2
    if keys[key.Q]:
        r3 -= 2
    if keys[key.W]:
        r3 += 2

    clear_buffers(depthBufferEnabled)
    set_shade_model(shadeModel)
    set_depth_buffer(depthBufferEnabled)
    set_projection_matrix(fov, nearPlane, farPlane)
    set_modelview_matrix(r1, r2)

    # nastaveni pozice svetla
    glPushMatrix()
    lightPosition_gl = (GLfloat * len(lightPosition))(*lightPosition)
    glRotatef(r3, 1.0, 0.0, 0.0)
    glLightfv(GL_LIGHT0, GL_POSITION, lightPosition_gl)
    glPopMatrix()

    draw_quadric(quadricDrawStyle, sphereSlices, sphereStacks)


window.push_handlers(keys)
pyglet.app.run()
</pre>



<p><a name="k14"></a></p>
<h2 id="k14">14. Třetí demonstrační příklad &ndash; vykreslení modelu koule, materiál má nastavené i odlesky</h2>

<pre>
#!/usr/bin/env python

import pyglet
from pyglet.gl import *
from pyglet.window import key

fov = 70.0                                 # zorny uhel (field of view)
nearPlane = 0.1                            # blizsi orezavaci rovina
farPlane = 90.0                            # vzdalenejsi orezavaci rovina

r1 = 0.0
r2 = 0.0
r3 = 0.0

depthBufferEnabled = True                  # povoleni ci zakaz Z-bufferu

shadeModel = GL_SMOOTH                     # algoritmus vyplnovani plosek

quadricDrawStyle = GLU_FILL                # styl vykreslovani kvadriky
sphereSlices = 20                          # rozdeleni koule na 'poledniky'
sphereStacks = 20                          # rozdeleni koule na 'rovnobezky'


window = pyglet.window.Window(width=500,
                              height=500,
                              caption="Pyglet library")

keys = key.KeyStateHandler()

# parametry, ktere ovlivnuji osvetleni
materialAmbient = [1.0, 0.0, 0.0, 1.0]     # ambientni slozka barvy materialu
materialDiffuse = [0.7, 0.7, 0.7, 0.0]     # difuzni slozka barvy materialu
materialSpecular = [1.0, 1.0, 1.0, 1.0]    # barva odlesku
materialShininess = [50.0]                 # faktor odlesku
lightPosition = [10.0, 10.0, 20.0, 0.0]    # pozice svetla


def float_array(list):
    ''' Prevod seznamu na pole prvku typ GLfloat '''
    return (GLfloat * len(list))(*list)


def set_material():
    materialAmbient_gl = float_array(materialAmbient)
    materialDiffuse_gl = float_array(materialDiffuse)
    materialSpecular_gl = float_array(materialSpecular)
    materialShininess_gl = float_array(materialShininess)

    # nastaveni ambientni slozky barvy materialu
    glMaterialfv(GL_FRONT, GL_AMBIENT, materialAmbient_gl)
    glMaterialfv(GL_FRONT, GL_DIFFUSE, materialDiffuse_gl)

    # nastaveni barvy odlesku
    glMaterialfv(GL_FRONT, GL_SPECULAR, materialSpecular_gl)

    # nastaveni faktoru odlesku
    glMaterialfv(GL_FRONT, GL_SHININESS, materialShininess_gl)


def set_light():
    lightPosition_gl = (GLfloat * len(lightPosition))(*lightPosition)

    # nastaveni pozice svetla
    glLightfv(GL_LIGHT0, GL_POSITION, lightPosition_gl)

    glEnable(GL_LIGHTING)                  # globalni povoleni stinovani
    glEnable(GL_LIGHT0)                    # povoleni prvniho svetla


def init():
    glClearColor(0.0, 0.0, 0.3, 0.0)       # barva pozadi obrazku
    glPolygonMode(GL_FRONT, GL_FILL)       # nastaveni rezimu vykresleni modelu
    glPolygonMode(GL_BACK, GL_FILL)
    # zakaz odstranovani hran nebo sten podle jejich normal
    glDisable(GL_CULL_FACE)
    glDepthFunc(GL_LESS)                   # funkce pro testovani fragmentu

    glShadeModel(GL_SMOOTH)                # nastaveni stinovaciho rezimu
    glPointSize(3.0)                       # velikost vykreslovanych bodu

    set_material()
    set_light()


@window.event
def on_resize(width, height):
    init()
    glViewport(0, 0, width, height)        # viditelna oblast pres cele okno


def draw_quadric(drawStyle, slices, stacks):
    radius = 8.0
    quadric = gluNewQuadric()                   # vytvoreni kvadriky
    gluQuadricDrawStyle(quadric, drawStyle)     # nastaveni vlastnosti kvadriky
    gluQuadricNormals(quadric, GLU_SMOOTH)      # smer generovanych normal
    gluSphere(quadric, radius, slices, stacks)  # vykresleni kvadriky
    gluDeleteQuadric(quadric)                   # zruseni kvadriky


def set_depth_buffer(depthBufferEnabled):
    if depthBufferEnabled:
        glEnable(GL_DEPTH_TEST)
    else:
        glDisable(GL_DEPTH_TEST)


def clear_buffers(depthBufferEnabled):
    if depthBufferEnabled:
        # vymazani vsech bitovych rovin barvoveho bufferu i Z bufferu
        glClear(GL_COLOR_BUFFER_BIT | GL_DEPTH_BUFFER_BIT)
    else:
        # vymazani vsech bitovych rovin barvoveho bufferu
        glClear(GL_COLOR_BUFFER_BIT)


def set_projection_matrix(fov, nearPlane, farPlane):
    # zacatek modifikace projekcni matice
    glMatrixMode(GL_PROJECTION)
    # vymazani projekcni matice (=identita)
    glLoadIdentity()
    gluPerspective(fov, 1.0, nearPlane, farPlane)


def set_modelview_matrix(rotation1, rotation2):
    glMatrixMode(GL_MODELVIEW)
    glLoadIdentity()                       # nahrat jednotkovou matici

    gluLookAt(4.0, 6.0, 18.0,              # bod, odkud se kamera diva
              0.0, 2.0,  0.0,              # bod, kam se kamera diva
              0.0, 1.0,  0.0)              # poloha "stropu" ve scene

    glRotatef(rotation1, 1.0, 0.0, 0.0)    # rotace objektu
    glRotatef(rotation2, 0.0, 1.0, 0.0)


def set_shade_model(shadeModel):
    glShadeModel(shadeModel)


@window.event
def on_key_press(symbol, modifiers):
    global depthBufferEnabled
    global quadricDrawStyle
    global sphereSlices, sphereStacks
    global shadeModel

    if symbol == key.Z:
        depthBufferEnabled = not depthBufferEnabled
    if symbol == key.L:
        quadricDrawStyle = GLU_LINE
    if symbol == key.P:
        quadricDrawStyle = GLU_POINT
    if symbol == key.F:
        quadricDrawStyle = GLU_FILL
    if symbol == key.X:
        shadeModel = GL_FLAT
    if symbol == key.C:
        shadeModel = GL_SMOOTH
    if symbol == key.PAGEUP:
        sphereStacks += 1
    if symbol == key.PAGEDOWN:
        if sphereStacks &gt; 1:
            sphereStacks -= 1
    if symbol == key.HOME:
        if sphereSlices &gt; 1:
            sphereSlices -= 1
    if symbol == key.END:
        sphereSlices += 1


@window.event
def on_draw():
    global r1, r2, r3

    if keys[key.LEFT]:
        r2 -= 2
    if keys[key.RIGHT]:
        r2 += 2
    if keys[key.UP]:
        r1 -= 2
    if keys[key.DOWN]:
        r1 += 2
    if keys[key.Q]:
        r3 -= 2
    if keys[key.W]:
        r3 += 2

    clear_buffers(depthBufferEnabled)
    set_shade_model(shadeModel)
    set_depth_buffer(depthBufferEnabled)
    set_projection_matrix(fov, nearPlane, farPlane)
    set_modelview_matrix(r1, r2)

    # nastaveni pozice svetla
    glPushMatrix()
    lightPosition_gl = (GLfloat * len(lightPosition))(*lightPosition)
    glRotatef(r3, 1.0, 0.0, 0.0)
    glLightfv(GL_LIGHT0, GL_POSITION, lightPosition_gl)
    glPopMatrix()

    draw_quadric(quadricDrawStyle, sphereSlices, sphereStacks)


window.push_handlers(keys)
pyglet.app.run()
</pre>



<p><a name="k15"></a></p>
<h2 id="k15">15. Čtvrtý demonstrační příklad &ndash; osvětlovací model a těleso s&nbsp;plochami bez normálových vektorů</h2>

<pre>
#!/usr/bin/env python

import pyglet
from pyglet.gl import *
from pyglet.window import key

fov = 70.0                                 # zorny uhel (field of view)
nearPlane = 0.1                            # blizsi orezavaci rovina
farPlane = 90.0                            # vzdalenejsi orezavaci rovina

r1 = 0.0
r2 = 0.0
r3 = 0.0

depthBufferEnabled = True                  # povoleni ci zakaz Z-bufferu

texturesEnabled = False                    # povoleni ci zakaz textur

shadeModel = GL_SMOOTH                     # algoritmus vyplnovani plosek


window = pyglet.window.Window(width=500,
                              height=500,
                              caption="Pyglet library")

image_stream = open("gnome-globe.png", "rb")
image = pyglet.image.load('gnome-globe.png', file=image_stream)
texture = image.get_texture()

keys = key.KeyStateHandler()

# parametry, ktere ovlivnuji osvetleni
materialAmbient = [1.0, 0.0, 0.0, 1.0]     # ambientni slozka barvy materialu
materialDiffuse = [0.7, 0.7, 0.7, 0.0]     # difuzni slozka barvy materialu
materialSpecular = [1.0, 1.0, 1.0, 1.0]    # barva odlesku
materialShininess = [50.0]                 # faktor odlesku
lightPosition = [10.0, 10.0, 20.0, 0.0]    # pozice svetla


def float_array(list):
    ''' Prevod seznamu na pole prvku typ GLfloat '''
    return (GLfloat * len(list))(*list)


def set_material():
    materialAmbient_gl = float_array(materialAmbient)
    materialDiffuse_gl = float_array(materialDiffuse)
    materialSpecular_gl = float_array(materialSpecular)
    materialShininess_gl = float_array(materialShininess)

    # nastaveni ambientni slozky barvy materialu
    glMaterialfv(GL_FRONT, GL_AMBIENT, materialAmbient_gl)
    glMaterialfv(GL_FRONT, GL_DIFFUSE, materialDiffuse_gl)

    # nastaveni barvy odlesku
    glMaterialfv(GL_FRONT, GL_SPECULAR, materialSpecular_gl)

    # nastaveni faktoru odlesku
    glMaterialfv(GL_FRONT, GL_SHININESS, materialShininess_gl)


def set_light():
    lightPosition_gl = (GLfloat * len(lightPosition))(*lightPosition)

    # nastaveni pozice svetla
    glLightfv(GL_LIGHT0, GL_POSITION, lightPosition_gl)

    glEnable(GL_LIGHTING)                  # globalni povoleni stinovani
    glEnable(GL_LIGHT0)                    # povoleni prvniho svetla


def init():
    glClearColor(0.0, 0.0, 0.3, 0.0)       # barva pozadi obrazku
    glPolygonMode(GL_FRONT, GL_FILL)       # nastaveni rezimu vykresleni modelu
    glPolygonMode(GL_BACK, GL_FILL)
    # zakaz odstranovani hran nebo sten podle jejich normal
    glDisable(GL_CULL_FACE)
    glDepthFunc(GL_LESS)                   # funkce pro testovani fragmentu

    glShadeModel(GL_SMOOTH)                # nastaveni stinovaciho rezimu
    glPixelStorei(GL_UNPACK_ALIGNMENT, 1)
    glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MAG_FILTER, GL_LINEAR)
    glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MIN_FILTER, GL_LINEAR)
    glBindTexture(GL_TEXTURE_2D, texture.id)

    set_material()
    set_light()


@window.event
def on_resize(width, height):
    init()
    glViewport(0, 0, width, height)        # viditelna oblast pres cele okno



def draw_walls():
    glBegin(GL_QUADS)                         # vykresleni otevrene krychle - sten domecku
    glColor3f(0.0, 0.0, 1.0)                  # modra barva steny
    glTexCoord2f(0.0, 0.0)
    glVertex3f(-5.0, -5.0, -5.0)
    glTexCoord2f(0.7, 0.0)
    glVertex3f(-5.0, -5.0,  5.0)
    glTexCoord2f(0.7, 0.7)
    glVertex3f( 5.0, -5.0,  5.0)
    glTexCoord2f(0.0, 0.7)
    glVertex3f( 5.0, -5.0, -5.0)

    glColor3f(0.0, 1.0, 0.0)                  # zelena barva steny
    glTexCoord2f(0.0, 0.0)
    glVertex3f(-5.0,  5.0, -5.0)
    glTexCoord2f(0.7, 0.0)
    glVertex3f(-5.0,  5.0,  5.0)
    glTexCoord2f(0.7, 0.7)
    glVertex3f( 5.0,  5.0,  5.0)
    glTexCoord2f(0.0, 0.7)
    glVertex3f( 5.0,  5.0, -5.0)

    glColor3f(1.0, 0.0, 0.0)                  # cervena barva steny
    glTexCoord2f(0.0, 0.0)
    glVertex3f(-5.0, -5.0, -5.0)
    glTexCoord2f(0.7, 0.0)
    glVertex3f(-5.0, -5.0,  5.0)
    glTexCoord2f(0.7, 0.7)
    glVertex3f(-5.0,  5.0,  5.0)
    glTexCoord2f(0.0, 0.7)
    glVertex3f(-5.0,  5.0, -5.0)

    glColor3f(1.0, 1.0, 0.0)                  # zluta barva steny
    glTexCoord2f(0.0, 0.0)
    glVertex3f( 5.0, -5.0, -5.0)
    glTexCoord2f(0.7, 0.0)
    glVertex3f( 5.0, -5.0,  5.0)
    glTexCoord2f(0.7, 0.7)
    glVertex3f( 5.0,  5.0,  5.0)
    glTexCoord2f(0.0, 0.7)
    glVertex3f( 5.0,  5.0, -5.0)
    glEnd()



def draw_roof():
    glBegin(GL_TRIANGLES)                      # vykresleni strechy domecku z trojuhelniku
    glColor3f(0.0, 1.0, 1.0)
    glTexCoord2f(0.0, 0.0)
    glVertex3f(-5.0,  5.0, -5.0)
    glTexCoord2f(0.7, 0.0)
    glVertex3f( 5.0,  5.0, -5.0)
    glTexCoord2f(0.7, 0.7)
    glVertex3f( 0.0, 11.0,  0.0)
 
    glColor3f(1.0, 0.0, 1.0)
    glTexCoord2f(0.0, 0.0)
    glVertex3f( 5.0,  5.0, -5.0)
    glTexCoord2f(0.7, 0.0)
    glVertex3f( 5.0,  5.0,  5.0)
    glTexCoord2f(0.7, 0.7)
    glVertex3f( 0.0, 11.0,  0.0)
 
    glColor3f(1.0, 1.0, 1.0)
    glTexCoord2f(0.0, 0.0)
    glVertex3f( 5.0,  5.0,  5.0)
    glTexCoord2f(0.7, 0.0)
    glVertex3f(-5.0,  5.0,  5.0)
    glTexCoord2f(0.7, 0.7)
    glVertex3f( 0.0, 11.0,  0.0)
 
    glColor3f(0.0, 0.0, 0.0)
    glTexCoord2f(0.0, 0.0)
    glVertex3f(-5.0,  5.0,  5.0)
    glTexCoord2f(0.7, 0.0)
    glVertex3f(-5.0,  5.0, -5.0)
    glTexCoord2f(0.7, 0.7)
    glVertex3f( 0.0, 11.0,  0.0)
    glEnd()



def set_depth_buffer(depthBufferEnabled):
    if depthBufferEnabled:
        glEnable(GL_DEPTH_TEST)
    else:
        glDisable(GL_DEPTH_TEST)


def clear_buffers(depthBufferEnabled):
    if depthBufferEnabled:
        # vymazani vsech bitovych rovin barvoveho bufferu i Z bufferu
        glClear(GL_COLOR_BUFFER_BIT | GL_DEPTH_BUFFER_BIT)
    else:
        # vymazani vsech bitovych rovin barvoveho bufferu
        glClear(GL_COLOR_BUFFER_BIT)


def set_projection_matrix(fov, nearPlane, farPlane):
    # zacatek modifikace projekcni matice
    glMatrixMode(GL_PROJECTION)
    # vymazani projekcni matice (=identita)
    glLoadIdentity()
    gluPerspective(fov, 1.0, nearPlane, farPlane)


def set_modelview_matrix(rotation1, rotation2):
    glMatrixMode(GL_MODELVIEW)
    glLoadIdentity()                       # nahrat jednotkovou matici

    gluLookAt(4.0, 6.0, 18.0,              # bod, odkud se kamera diva
              0.0, 2.0,  0.0,              # bod, kam se kamera diva
              0.0, 1.0,  0.0)              # poloha "stropu" ve scene

    glRotatef(rotation1, 1.0, 0.0, 0.0)    # rotace objektu
    glRotatef(rotation2, 0.0, 1.0, 0.0)


def set_shade_model(shadeModel):
    glShadeModel(shadeModel)


@window.event
def on_key_press(symbol, modifiers):
    global depthBufferEnabled
    global shadeModel

    if symbol == key.Z:
        depthBufferEnabled = not depthBufferEnabled
    if symbol == key.X:
        shadeModel = GL_FLAT
    if symbol == key.C:
        shadeModel = GL_SMOOTH


@window.event
def on_draw():
    global r1, r2, r3

    if keys[key.LEFT]:
        r2 -= 2
    if keys[key.RIGHT]:
        r2 += 2
    if keys[key.UP]:
        r1 -= 2
    if keys[key.DOWN]:
        r1 += 2
    if keys[key.Q]:
        r3 -= 2
    if keys[key.W]:
        r3 += 2

    clear_buffers(depthBufferEnabled)
    set_shade_model(shadeModel)
    set_depth_buffer(depthBufferEnabled)
    set_projection_matrix(fov, nearPlane, farPlane)
    set_modelview_matrix(r1, r2)

    # nastaveni pozice svetla
    glPushMatrix()
    lightPosition_gl = (GLfloat * len(lightPosition))(*lightPosition)
    glRotatef(r3, 1.0, 0.0, 0.0)
    glLightfv(GL_LIGHT0, GL_POSITION, lightPosition_gl)
    glPopMatrix()

    if texturesEnabled:
        glEnable(GL_TEXTURE_2D)
    else:
        glDisable(GL_TEXTURE_2D)

    draw_walls()
    draw_roof()



window.push_handlers(keys)
pyglet.app.run()
</pre>



<p><a name="k16"></a></p>
<h2 id="k16">16. Repositář s&nbsp;demonstračními příklady</h2>



<p><a name="k17"></a></p>
<h2 id="k17">17. Odkazy na Internetu</h2>

<ol>

<li>The Perlin noise math FAQ<br />
<a href="https://mzucker.github.io/html/perlin-noise-math-faq.html">https://mzucker.github.io/html/perlin-noise-math-faq.html</a>
</li>

<li>Perlin noise<br />
<a href="https://en.wikipedia.org/wiki/Perlin_noise">https://en.wikipedia.org/wiki/Perlin_noise</a>
</li>

<li>Perlin Noise Generator (Python recipe)<br />
<a href="http://code.activestate.com/recipes/578470-perlin-noise-generator/">http://code.activestate.com/recipes/578470-perlin-noise-generator/</a>
</li>

<li>Simplex noise demystified<br />
<a href="http://www.itn.liu.se/~stegu/simplexnoise/simplexnoise.pdf">http://www.itn.liu.se/~stegu/simplexnoise/simplexnoise.pdf</a>
</li>

<li>glTexEnv - příkaz OpenGL<br />
<a href="https://www.khronos.org/registry/OpenGL-Refpages/gl2.1/xhtml/glTexEnv.xml">https://www.khronos.org/registry/OpenGL-Refpages/gl2.1/xhtml/glTexEnv.xml</a>
</li>

<li>glGetTexEnv - příkaz OpenGL<br />
<a href="https://www.khronos.org/registry/OpenGL-Refpages/gl2.1/xhtml/glGetTexEnv.xml">https://www.khronos.org/registry/OpenGL-Refpages/gl2.1/xhtml/glGetTexEnv.xml</a>
</li>

<li>Pyglet Home Page<br />
<a href="https://bitbucket.org/pyglet/pyglet/wiki/Home">https://bitbucket.org/pyglet/pyglet/wiki/Home</a>
</li>

<li>Dokumentace k verzi 1.2<br />
<a href="https://pyglet.readthedocs.io/en/pyglet-1.2-maintenance/">https://pyglet.readthedocs.io/en/pyglet-1.2-maintenance/</a>
</li>

<li>Dokumentace k verzi 1.2 ve formátu PDF<br />
<a href="https://readthedocs.org/projects/pyglet/downloads/pdf/pyglet-1.2-maintenance/">https://readthedocs.org/projects/pyglet/downloads/pdf/pyglet-1.2-maintenance/</a>
</li>

<li>PyOpenGL<br />
<a href="http://pyopengl.sourceforge.net/">http://pyopengl.sourceforge.net/</a>
</li>

<li>The #! magic, details about the shebang/hash-bang mechanism on various Unix flavours<br />
<a href="https://www.in-ulm.de/~mascheck/various/shebang/">https://www.in-ulm.de/~mascheck/various/shebang/</a>
</li>

<li>Shebang (Unix)<br />
<a href="https://en.wikipedia.org/wiki/Shebang_%28Unix%29">https://en.wikipedia.org/wiki/Shebang_%28Unix%29</a>
</li>

<li>Domovská stránka systému LÖVE<br />
<a href="http://love2d.org/">http://love2d.org/</a>
</li>

<li>Simple DirectMedia Layer (home page)<br />
<a href="http://www.libsdl.org/">http://www.libsdl.org/</a>
</li>

<li>Simple DirectMedia Layer (Wikipedia)<br />
<a href="https://en.wikipedia.org/wiki/Simple_DirectMedia_Layer">https://en.wikipedia.org/wiki/Simple_DirectMedia_Layer</a>
</li>

<li>Seriál Grafická knihovna OpenGL<br />
<a href="https://www.root.cz/serialy/graficka-knihovna-opengl/">https://www.root.cz/serialy/graficka-knihovna-opengl/</a>
</li>

<li>Pyglet event loop<br />
<a href="http://pyglet.readthedocs.io/en/latest/programming_guide/eventloop.html">http://pyglet.readthedocs.io/en/latest/programming_guide/eventloop.html</a>
</li>

<li>Decorators I: Introduction to Python Decorators<br />
<a href="http://www.artima.com/weblogs/viewpost.jsp?thread=240808">http://www.artima.com/weblogs/viewpost.jsp?thread=240808</a>
</li>

<li>3D Programming in Python - Part 1 <br />
<a href="https://greendalecs.wordpress.com/2012/04/21/3d-programming-in-python-part-1/">https://greendalecs.wordpress.com/2012/04/21/3d-programming-in-python-part-1/</a>
</li>

<li>A very basic Pyglet tutorial<br />
<a href="http://www.natan.termitnjak.net/tutorials/pyglet_basic.html">http://www.natan.termitnjak.net/tutorials/pyglet_basic.html</a>
</li>

<li>Alpha blending<br />
<a href="https://en.wikipedia.org/wiki/Alpha_compositing#Alpha_blending">https://en.wikipedia.org/wiki/Alpha_compositing#Alpha_blending</a>
</li>

</ol>



<p></p><p></p>
<p><small>Autor: <a href="http://www.fit.vutbr.cz/~tisnovpa">Pavel Tišnovský</a> &nbsp; 2017</small></p>
</body>
</html>

