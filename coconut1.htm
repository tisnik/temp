<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
        "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html>
<head>
<title>Coconut - funkcionální programovací jazyk s pattern matchingem kompatibilní s Pythonem</title>
<meta name="Author" content="Pavel Tisnovsky" />
<meta name="Generator" content="vim" />
<meta http-equiv="content-type" content="text/html; charset=utf-8" />
<style type="text/css">
         body {color:#000000; background:#ffffff;}
         h1  {font-family: arial, helvetica, sans-serif; color:#ffffff; background-color:#c00000; text-align:center; padding-left:1em}
         h2  {font-family: arial, helvetica, sans-serif; color:#ffffff; background-color:#0000c0; padding-left:1em; text-align:left}
         h3  {font-family: arial, helvetica, sans-serif; color:#000000; background-color:#c0c0c0; padding-left:1em; text-align:left}
         h4  {font-family: arial, helvetica, sans-serif; color:#000000; background-color:#e0e0e0; padding-left:1em; text-align:left}
         a   {font-family: arial, helvetica, sans-serif;}
         li  {font-family: arial, helvetica, sans-serif; color:#000000; text-align:justify; width:450px;}
         ol  {font-family: arial, helvetica, sans-serif; color:#000000; text-align:justify; width:450px;}
         ul  {font-family: arial, helvetica, sans-serif; color:#000000; text-align:justify; width:450px;}
         p   {font-family: arial, helvetica, sans-serif; color:#000000; text-align:justify;}
         pre {background:#e0e0e0}
</style>
</head>

<body>

<h1>Coconut - funkcionální programovací jazyk s pattern matchingem kompatibilní s Pythonem</h1>

<h3>Pavel Tišnovský</h3>

<p></p>

<h1>Úvodník</h1>

<p>Transpřekladače se v IT používají již několik desetiletí. Velkého rozšíření dosáhly tehdy, kdy se začaly používat pro ekosystém JavaScriptu. Poněkud stranou přitom stojí Python, pro jehož ekosystém vznikl velmi zajímavý programovací jazyk Coconut, který je navíc s Pythonem zpětně kompatibilní.</p>



<h2>Obsah</h2>

<p><a href="#k01">1. Coconut &ndash; funkcionální programovací jazyk s&nbsp;pattern matchingem kompatibilní s&nbsp;Pythonem</a></p>
<p><a href="#k02">2. Další transpřekladač?</a></p>
<p><a href="#k03">3. Přednosti a zápory implementace Coconutu ve formě transpřekladače</a></p>
<p><a href="#k04">4. Instalace transpřekladače Coconut a nastavení textového editoru</a></p>
<p><a href="#k05">5. Nastavení textového editoru Vim pro zjednodušení práce s&nbsp;transpřekladačem</a></p>
<p><a href="#k06">6. Použití interaktivní smyčky (REPL)</a></p>
<p><a href="#k07">7. Využití Coconutu pro transpřeklad</a></p>
<p><a href="#k08">8. Rozšířená tabulka operátorů</a></p>
<p><a href="#k09">9. Nové a staronové funkce používané při zpracování sekvencí</a></p>
<p><a href="#k10">10. Zkrácený zápis lambda výrazů (zjednodušených anonymních funkcí)</a></p>
<p><a href="#k11">11. Neměnitelné (immutable) datové typy</a></p>
<p><a href="#k12">12. Infixový zápis při volání funkcí</a></p>
<p><a href="#k13">13. Infixový zápis při definici nových funkcí</a></p>
<p><a href="#k14">14. Vytvoření &bdquo;kolony&ldquo; z&nbsp;funkcí</a></p>
<p><a href="#k15">15. Kompozice funkcí</a></p>
<p><a href="#k16">16. Čísla řádků a zachování původního zdrojového kódu ve vygenerovaném modulu</a></p>
<p><a href="#k17">17. Demonstrační příklady</a></p>
<p><a href="#k18">18. Odkazy na Internetu</a></p>



<p><a name="k01"></a></p>
<h2 id="k01">1. Coconut &ndash; funkcionální programovací jazyk s&nbsp;pattern matchingem kompatibilní s&nbsp;Pythonem</h2>

<p>V&nbsp;dnešním článku si popíšeme základní vlastnosti programovacího jazyka
Coconut, který je navržen takovým způsobem, aby byl zpětně kompatibilní
s&nbsp;Pythonem. To znamená, že skript napsaný v&nbsp;Pythonu je současně i
skriptem napsaným v&nbsp;jazyku Coconut (což je zajímavé, protože do Coconutu
byla přidána tři nová klíčová slova <strong>data</strong>,
<strong>match</strong> a <strong>case</strong>, jejichž význam se však
rozlišuje z&nbsp;kontextu). Coconut je tak možné považovat za sémantické i
syntaktické rozšíření Pythonu, přičemž se autor tohoto jazyka zaměřil především
na funkcionální rysy (funkce vyššího řádu, neměnitelné hodnoty, podpora pro
tvorbu kolon a kompozic funkcí atd.) a taktéž do Coconutu přidal podporu pro
pattern matching (inspiraci získal <a
href="https://github.com/Suor/patterns">zde</a>). Coconut může pracovat jako
interpret s&nbsp;interaktivní smyčkou REPL či jako transpřekladač
(transcompiler, transpiler) do jazyka Python, takže je možné použít celý
pythonovský ekosystém. Přesnější informace o tom, se kterými verzemi Pythonu je
Coconut kompatibilní, naleznete na adrese <a
href="http://coconut.readthedocs.io/en/master/DOCS.html#compatible-python-versions">http://coconut.readthedocs.io/en/master/DOCS.html#compatible-python-versions</a>.</p>



<p><a name="k02"></a></p>
<h2 id="k02">2. Další transpřekladač?</h2>

<p><i>&bdquo;Coconut's goal isn't to replace Python, but to extend
it&ldquo;</i></p>

<p>Problematikou takzvaných transpřekladačů (<i>transcompilers,
source-to-source compilers</i>) jsme se již na stránkách Rootu zabývali, a to
dokonce několikrát. Připomeňme si například projekty <a
href="https://www.root.cz/clanky/programovaci-jazyk-clojure-21-clojurescript-aneb-preklad-clojure-do-javascriptu/">ClojureScript</a>
(transpřekladač Clojure &rarr; JavaScript), <a
href="https://www.root.cz/clanky/programovaci-jazyk-lua-v-roli-skriptovaciho-jazyka-pro-www-stranky/#k06">lua2js</a>
(transpřekladač Lua &rarr; opět JavaScript) a <a
href="https://www.root.cz/clanky/propojeni-sveta-lispu-se-svetem-javascriptu-s-vyuzitim-transprekladace-wisp/">Wisp</a>
(programovací jazyk podobný Clojure). Připomeňme si, že transpřekladače jsou
nástroje sloužící pro překlad algoritmů zapsaných v&nbsp;nějakém zdrojovém
programovacím jazyce do zvoleného cílového jazyka (ovšem nikoli do nativního
kódu či bajtkódu, to je totiž role běžných překladačů).</p>

<p>Transpřekladače se v&nbsp;informatice používají již po několik desetiletí;
například se stále můžeme setkat s&nbsp;nástroji, které převádí kód
z&nbsp;nějakého vyššího programovacího jazyka do Céčka, které je dnes
s&nbsp;trochou nadsázky chápáno jako &bdquo;univerzální assembler&ldquo;. Asi
nejznámějším příkladem je nástroj nazvaný <strong>web2c</strong>, jenž slouží
pro transformaci zdrojových kódů <i>TeXu</i> do céčka. Transpřekladače se
stávají velmi populární i pro programátory webových aplikací, a to zejména
z&nbsp;toho důvodu, že webové prohlížeče nativně podporují většinou pouze
JavaScript, který je tak přirozeně cílovým jazykem transpřekladačů (proto se mu
také někdy říká &bdquo;assembler pro web&ldquo;, viz též <a href="#k18">odkazy
na konci článku</a>).</p>

<p>Z&nbsp;praxe můžeme uvést například následující projekty založené na
transpřekladači:</p>

<table>
<tr><th>#</th><th>Jazyk či transpřekladač</th><th>Poznámka</th></tr>
<tr><td>1</td><td>CoffeeScript</td><td>přidání syntaktického cukru do JavaScriptu</td></tr>
<tr><td>2</td><td><a href="https://www.root.cz/clanky/programovaci-jazyk-clojure-21-clojurescript-aneb-preklad-clojure-do-javascriptu/">ClojureScript</a></td><td>překlad aplikací psaných v&nbsp;Clojure do JavaScriptu</td></tr>
<tr><td>3</td><td>TypeScript</td><td>nadmnožina jazyka JavaScript, přidání datových typů</td></tr>
<tr><td>4</td><td>6to5</td><td>transpřeklad z&nbsp;ECMAScript 6 (nová varianta JavaScriptu) do starší varianty JavaScriptu</td></tr>
<tr><td>5</td><td>Kaffeine</td><td>rozšíření JavaScriptu o nové vlastnosti</td></tr>
<tr><td>6</td><td>RedScript</td><td>jazyk inspirovaný Ruby</td></tr>
<tr><td>7</td><td>GorillaScript</td><td>další rozšíření JavaScriptu</td></tr>
<tr><td>8</td><td>ghcjs</td><td>transpřekladač pro fanoušky programovacího jazyka Haskell</td></tr>
<tr><td>9</td><td>Haxe</td><td>transpřekladač, mezi jehož cílové jazyka patří i Java a JavaScript</td></tr>
<tr><td>10</td><td><a href="https://www.root.cz/clanky/propojeni-sveta-lispu-se-svetem-javascriptu-s-vyuzitim-transprekladace-wisp/">Wisp</a></td><td>transpřekladač jazyka podobného Clojure, opět do JavaScriptu</td></tr>
<tr><td>11</td><td>ScriptSharp</td><td>transpřekladač z&nbsp;C# do JavaScriptu</td></tr>
<tr><td>12</td><td>Dart</td><td>transpřekladač z&nbsp;jazyka Dart do JavaScriptu</td></tr>
<tr><td>13</td><td>COBOL &rarr; C</td><td>transpřekladač OpenCOBOL</td></tr>
<tr><td>14</td><td>COBOL &rarr; Java</td><td>transpřekladač P3COBOL</td></tr>
<tr><td>15</td><td><a href="https://www.root.cz/clanky/programovaci-jazyk-lua-v-roli-skriptovaciho-jazyka-pro-www-stranky/#k06">lua2js</a></td><td>transpřekladač jazyka Lua, opět do JavaScriptu</td></tr>
</table>



<p><a name="k03"></a></p>
<h2 id="k03">3. Přednosti a zápory implementace Coconutu ve formě transpřekladače</h2>

<p>Vzhledem k&nbsp;tomu, že je programovací jazyk Coconut implementován jako
transpřekladač a současně se jedná o jazyk tvořící nadmnožinu Pythonu, je
v&nbsp;něm možné použít prakticky všechny knihovny pythonovského ekosystému,
což platí zejména pro CPython a PyPy, i když větší problémy nelze předpokládat
ani v&nbsp;případě použití Jythonu či IronPythonu. Navíc je pro všechny
programátory znající Python vlastně velmi jednoduché přejít na Coconut &ndash;
stále je totiž možné využít stávající syntaxi a sémantiku Pythonu a rozšíření
přidaná Coconutem použít jen v&nbsp;těch místech, kde to má v&nbsp;daný okamžik
význam. To je zásadní rozdíl od některých jiných (nejenom funkcionálních)
jazyků, s&nbsp;nimiž se programátor může setkat a které mnohdy vyžadují, aby se
začal učit jak nový programovací jazyk, tak i jeho ekosystém (který je navíc u
nově vznikajících jazyků zpočátku malý, navíc může být spousta knihoven
dostupných jen v&nbsp;alfa verzích).</p>

<p>Použití transpřekladače však přináší i některé nevýhody, které se projeví
například ve chvíli, kdy v&nbsp;programu vznikne chyba či nezachycená výjimka.
V&nbsp;takovém případě totiž získáme <i>stack trace</i> platný pro výsledný
pythonovský program, nikoli pro uživatelem vytvořený kód. Totéž může nastat ve
chvíli, kdy budeme chtít program ladit, například přes GDB (nebo jeho
nadstavby). Jen částečné řešení přináší přidání korespondujících čísel řádků
v&nbsp;generovaném kódu, které lze povolit přepínačem <strong>-l</strong> nebo
<strong>--line-numbers</strong>. Ještě častěji se můžeme setkat s&nbsp;tím, že
syntaktická chyba zůstane nezachycena transpřekladačem Coconutu a vypíše ji až
interpret Pythonu. Chybové hlášení tedy bude obsahovat odkaz na generovaný kód,
nikoli na původní zdrojový kód vytvořený programátorem. Opět si lze alespoň
částečně pomoci čísly řádků vepsanými do vygenerovaného zdrojového kódu
v&nbsp;Pythonu.</p>



<p><a name="k04"></a></p>
<h2 id="k04">4. Instalace transpřekladače Coconut</h2>

<p>Transpřekladač Coconut se instaluje velmi jednoduše s&nbsp;využitím správce
balíčků <strong>pip</strong> (viz <a
href="https://pip.pypa.io/en/stable/">https://pip.pypa.io/en/stable</a>).
Instalaci lze provést takovým způsobem, aby byla dostupná všem uživatelům:</p>

<pre>
<strong>sudo pip install coconut</strong>
</pre>

<p>Popř.&nbsp;je možné provést instalaci do domácího adresáře aktivního
uživatele. V&nbsp;tomto případě bude transpřekladač jazyka Coconut dostupný
přes spustitelný soubor uložený v&nbsp;adresáři
<strong>~/.local/bin/coconut</strong> (přidejte si tuto cestu do PATH):</p>

<pre>
<strong>pip install --user coconut</strong>
&nbsp;
Collecting coconut
  Using cached coconut-1.2.3-py2.py3-none-any.whl
Requirement already satisfied: futures&gt;=3.1; python_version &lt; "3" in /usr/local/lib/python2.7/dist-packages (from coconut)
Requirement already satisfied: prompt-toolkit&gt;=1.0; python_version &gt;= "2.7" in /usr/local/lib/python2.7/dist-packages (from coconut)
Requirement already satisfied: pyparsing&lt;2.2.1,&gt;=2.2.0 in /usr/local/lib/python2.7/dist-packages (from coconut)
Requirement already satisfied: pygments&gt;=2.2; python_version &gt;= "2.7" in /usr/local/lib/python2.7/dist-packages (from coconut)
Requirement already satisfied: six&gt;=1.9.0 in /usr/local/lib/python2.7/dist-packages (from prompt-toolkit&gt;=1.0; python_version &gt;= "2.7"-&gt;coconut)
Requirement already satisfied: wcwidth in /usr/local/lib/python2.7/dist-packages (from prompt-toolkit&gt;=1.0; python_version &gt;= "2.7"-&gt;coconut)
Installing collected packages: coconut
Successfully installed coconut-1.2.3
</pre>

<p>Zda se instalace podařila lze zjistit velmi jednoduše:</p>

<pre>
<strong>coconut --help</strong>
&nbsp;
usage: coconut [-h] [-v] [-t version] [-i] [-p] [-a] [-l] [-k] [-w] [-r] [-n]
               [-d] [-q] [-s] [--no-tco] [-c code] [-j processes] [-f]
               [--minify] [--jupyter ...] [--mypy ...] [--tutorial]
               [--documentation] [--style name] [--recursion-limit limit]
               [--verbose]
               [source] [dest]
&nbsp;
http://coconut.readthedocs.io/en/v1.2.3/DOCS.html
&nbsp;
positional arguments:
  source                path to the Coconut file/folder to compile
  dest                  destination directory for compiled files (defaults to
                        the source directory)
&nbsp;
optional arguments:
  -h, --help            show this help message and exit
  -v, --version         print Coconut and Python version information
  -t version, --target version
                        specify target Python version (defaults to universal)
  -i, --interact        force the interpreter to start (otherwise starts if no
                        other command is given) (implies --run)
  -p, --package         compile source as part of a package (defaults to only
                        if source is a directory)
  -a, --standalone      compile source as standalone files (defaults to only
                        if source is a single file)
  -l, --line-numbers, --linenumbers
                        add line number comments for ease of debugging
  -k, --keep-lines, --keeplines
                        include source code in comments for ease of debugging
  -w, --watch           watch a directory and recompile on changes
  -r, --run             execute compiled Python
  -n, --no-write, --nowrite
                        disable writing compiled Python
  -d, --display         print compiled Python
  -q, --quiet           suppress all informational output (combine with
                        --display to write runnable code to stdout)
  -s, --strict          enforce code cleanliness standards
  --no-tco, --notco     disable tail call optimization for ease of debugging
  -c code, --code code  run Coconut passed in as a string (can also be piped
                        into stdin)
  -j processes, --jobs processes
                        number of additional processes to use (defaults to 0)
                        (pass 'sys' to use machine default)
  -f, --force           force overwriting of compiled Python (otherwise only
                        overwrites when source code or compilation parameters
                        change)
  --minify              reduce size of compiled Python
  --jupyter ..., --ipython ...
                        run Jupyter/IPython with Coconut as the kernel
                        (remaining args passed to Jupyter)
  --mypy ...            run MyPy on compiled Python (remaining args passed to
                        MyPy) (implies --package --no-tco)
  --tutorial            open the Coconut tutorial in the default web browser
  --documentation       open the Coconut documentation in the default web
                        browser
  --style name          Pygments syntax highlighting style (or 'none' to
                        disable) (defaults to COCONUT_STYLE environment
                        variable, if it exists, otherwise 'default')
  --recursion-limit limit, --recursionlimit limit
                        set maximum recursion depth in compiler (defaults to
                        2000)
  --verbose             print verbose debug output
</pre>



<p><a name="k05"></a></p>
<h2 id="k05">5. Nastavení textového editoru Vim pro zjednodušení práce s&nbsp;transpřekladačem</h2>

<p>Po instalaci Coconutu je vhodné si nastavit váš oblíbený textový editor
(nebo IDE). Především se to týká zvýraznění syntaxe a taktéž nakonfigurování
klávesových zkratek pro překlad (resp.&nbsp;přesněji řečeno transpřeklad)
z&nbsp;Coconutu do Pythonu. Pro <a
href="https://www.root.cz/serialy/textovy-editor-vim-jako-ide/">textový editor
Vim</a> existuje plugin pro zvýraznění syntaxe, který lze nainstalovat velmi
jednoduše &ndash; spuštěním následujícího příkazu a nakopírováním výsledné
struktury (bez podadresáře <strong>.git</strong>) do
<strong>~/.vim</strong>:</p>

<pre>
<strong>git clone https://github.com/manicmaniac/coconut.vim.git</strong>
&nbsp;
Cloning into 'coconut.vim'...
remote: Counting objects: 22, done.
remote: Total 22 (delta 0), reused 0 (delta 0), pack-reused 22
Unpacking objects: 100% (22/22), done.
Checking connectivity... done.
</pre>

<p>Následně si můžete nakonfigurovat dvě nové klávesové zkratky; první pro
(trans)překlad Coconut &rarr; Python, druhou pro spuštění výsledného skriptu.
Povšimněte si, jak se s&nbsp;využitím <strong>%:r</strong>
&bdquo;vykousne&ldquo; ze jména aktuálně editovaného souboru část bez koncovky,
koncovka se potom doplní nová (editujeme totiž soubor &bdquo;xyzzy.coco&ldquo;
a nikoli &bdquo;xyzzy.py&ldquo;):</p>

<pre>
:map &lt;F9&gt; :!coconut %&lt;cr&gt;
:map &lt;F5&gt; :!python %:r.py&lt;cr&gt;
</pre>

<p>Dále je možné si nastavit propojení Vimu s&nbsp;interaktivní smyčkou REPL, a
to pomocí pluginu <a
href="https://www.root.cz/clanky/uzitecne-skripty-a-pluginy-pro-textovy-editor-vim-7-cast/#k05">Vim
Slime</a>.</p>



<p><a name="k06"></a></p>
<h2 id="k06">6. Použití interaktivní smyčky (REPL)</h2>

<p>Pokud do příkazové řádky zadáme příkaz:</p>

<pre>
<strong>coconut</strong>
</pre>

<p>(při globální instalaci) či:</p>

<pre>
<strong>~/.local/bin/coconut</strong>
</pre>

<p>(při instalaci lokální), spustí se interaktivní smyčka <a
href="https://www.root.cz/clanky/clojure-aneb-jazyk-umoznujici-tvorbu-bezpecnych-vicevlaknovych-aplikaci-pro-jvm/#k05">REPL</a>
(<i>Read, Eval, Print, Loop</i>). Pokud jsou zadávané příkazy jednořádkové,
jsou ihned vykonány, pokud se jedná o příkazy víceřádkové (typicky o programové
smyčky), jsou vykonány až po jejich ukončení volným řádkem. Výrazy jsou
vyhodnoceny (vypočteny) a je zobrazen jejich výsledek, takže není zapotřebí
otrocky psát volání <strong>print</strong>. REPL navíc obarvuje kód; dokáže
zvýraznit operátory a především pak interní built-in funkce. V&nbsp;REPLu lze
samozřejmě používat i historii příkazů a základní klávesové zkratky pro
ovládání kurzoru (<strong>Ctrl+A</strong>, <strong>Ctrl+E</strong>,
<strong>Ctrl+W</strong>, <strong>Ctrl+K</strong> a další). REPL Cucumberu je
tedy oproti klasickému Pythonovskému REPLu vylepšen, ovšem na druhou stranu
nedosahuje kvalit ani možností IPythonu.</p>

<a href="https://www.root.cz/obrazek/302053/"><img src="https://i.iinfo.cz/images/112/coconut-repl-1-prev.png" class="image-302053" alt="&#160;" width="370" height="246" /></a>
<p><i>Obrázek 1: Terminál s&nbsp;interaktivní smyčkou (REPL) Coconutu.</i></p>

<p>Poznámka: interaktivní smyčka (REPL) používá vlastní obsluhu myši, takže
pokud vám nefunguje levé tlačítko pro výběr textu popř.&nbsp; prostřední
tlačítko pro jeho vložení do terminálu, zkuste namísto toho použít kombinaci
<strong>Shift+levé tlačítko</strong> popř.&nbsp;<strong>Shift+prostřední
tlačítko</strong>, podobně, jako to musíte udělat u podobných programů
(<i>Midnight Commander</i> atd.)</p>



<p><a name="k07"></a></p>
<h2 id="k07">7. Využití Coconutu pro transpřeklad</h2>

<p>Příkaz <strong>coconut</strong> spustí buď interaktivní smyčku REPL, což
jsme si již ukázali <a href="#k06">v&nbsp;předchozí kapitole</a>, nebo ho lze
použít pro transpřeklad Coconut &rarr; Python. Ukažme si tento druhý způsob
použití na velmi jednoduchém příkladu, který má na standardní výstup vypsat
řetězec &bdquo;Hello world!&ldquo;. S&nbsp;využitím nového operátoru <a
href="#k14">pro kolonu</a> (pipeline) lze takový program napsat například
následovně:</p>

<pre>
<strong>"Hello world!" |&gt; print</strong>
</pre>

<p>Pokud tento vysoce sofistikovaný program :-) uložíte do souboru
s&nbsp;názvem <strong>hello.coco</strong>, provede se transpřeklad takto:</p>

<pre>
<strong>coconut hello.coco</strong>
</pre>

<p>Výsledkem by měl být Pythonovský skript nazvaný <strong>hello.py</strong>,
jehož začátek a konec vypadá zhruba následovně:</p>

<pre>
#!/usr/bin/env python
# -*- coding: utf-8 -*-
# __coconut_hash__ = 0xa1980b4d
&nbsp;
# Compiled with Coconut version 1.2.3 [Colonel]
&nbsp;
# Coconut Header: --------------------------------------------------------
&nbsp;
...
...
...
500 řádků vygenerovaného pomocného kódu
...
...
...
&nbsp;
# Compiled Coconut: ------------------------------------------------------
&nbsp;
(print)("Hello world!")
</pre>

<p>Povšimněte si, že na samém konci se skutečně nachází volání funkce
<strong>print</strong> (ta je pro Python 2 naimportována přes <strong>from
__future__ import print_function</strong>).</p>

<p>S&nbsp;využitím přepínače <strong>--target</strong> můžeme určit, do jaké
verze Pythonu se má transpřeklad provést. Ve výchozím nastavení bude skript
použitelný jak v&nbsp;Pythonu 2.6 (a vyšší) nebo 3.2 (a vyšší).</p>



<p><a name="k08"></a></p>
<h2 id="k08">8. Rozšířená tabulka operátorů</h2>

<p>Pojďme si nyní stručně popsat některá rozšíření, která Coconut programátorům
nabízí. Především došlo k&nbsp;rozšíření použitelných operátorů.
V&nbsp;následující tabulce jsou operátory seřazeny podle své priority:</p>

<table>
<tr><th>Operátor</th><th>Vyhodnocení</th></tr>
<tr><td>..</td><td>&times;</td></tr>
<tr><td>**</td><td>zprava</td></tr>
<tr><td>+, -, ~</td><td>unární operátor psaný před operand</td></tr>
<tr><td>*, /, //, %, @</td><td>zleva</td></tr>
<tr><td>+, -</td><td>zleva</td></tr>
<tr><td>&lt;&lt;, &gt;&gt;</td><td>zleva</td></tr>
<tr><td>&amp;</td><td>zleva</td></tr>
<tr><td>^</td><td>zleva</td></tr>
<tr><td>|</td><td>zleva</td></tr>
<tr><td>::</td><td>&times;</td></tr>
<tr><td>a `b` c</td><td>zleva</td></tr>
<tr><td>??</td><td>zleva, zkrácené vyhodnocení</td></tr>
<tr><td>..&gt;, &lt;.., ..*&gt;, &lt;*..</td><td>&times;</td></tr>
<tr><td>|&gt;, &lt;|, |*&gt;, &lt;*|</td><td>zleva</td></tr>
<tr><td>==, !=, &lt;, &gt;,</td><td>&nbsp;</td></tr>
<tr><td>  &lt;=, &gt;=,</td><td>&nbsp;</td></tr>
<tr><td>  in, not in,</td><td>&nbsp;</td></tr>
<tr><td>  is, is not</td><td>&times;</td></tr>
<tr><td>not</td><td>unární operátor psaný před operand</td></tr>
<tr><td>and</td><td>zleva, zkrácené vyhodnocení</td></tr>
<tr><td>or</td><td>zleva , zkrácené vyhodnocení</td></tr>
<tr><td>a if b else c</td><td>ternární, zkrácené vyhodnocení</td></tr>
<tr><td>-&gt;</td><td>zprava</td></tr>
</table>



<p><a name="k09"></a></p>
<h2 id="k09">9. Nové a staronové funkce používané při zpracování sekvencí</h2>

<p>V&nbsp;Coconutu došlo k&nbsp;rozšíření funkcí (konkrétně built-in funkcí,
které není zapotřebí importovat). Tyto funkce je možné využít zejména při
zpracování různých sekvencí (n-tic, seznamů, iterátorů, ...). První užitečnou
funkcí (konkrétně funkcí vyššího řádu) je funkce nazvaná <strong>fmap</strong>,
která pracuje podobně jako standardní funkce <strong>map</strong> (aplikace
jiné zvolené funkce na sekvenci), ovšem výsledek je stejného typu, jako vstupní
sekvence. Příklad se seznamy:</p>

<pre>
<strong>map(lambda x: x*2, [1, 2, 3, 4])</strong>
map(&lt;function &lt;lambda&gt; at 0x7f0bf8da0d70&gt;, [1, 2, 3, 4])
&nbsp;
<strong>fmap( lambda x: x*2, [1, 2, 3, 4])</strong>
[2, 4, 6, 8]
</pre>

<p>Obě funkce můžeme použít i pro zpracování n-tic, ovšem opět s&nbsp;rozdílným
výsledkem:</p>

<pre>
<strong>map(lambda x: x*2, (1, 2, 3, 4))</strong>
map(&lt;function &lt;lambda&gt; at 0x7f0bf8c9bc80&gt;, (1, 2, 3, 4))
&nbsp;
<strong>fmap( lambda x: x*2, (1, 2, 3, 4))</strong>
(2, 4, 6, 8)
</pre>

<p>Použití u objektů typu <strong>range</strong>:</p>

<pre>
<strong>map(lambda x: x*2, range(10))</strong>
map(&lt;function &lt;lambda&gt; at 0x7f0bf8a53f50&gt;, range(10))
&nbsp;
<strong>fmap( lambda x: x*2, range(10))</strong>
map(&lt;function &lt;lambda&gt; at 0x7f0bf8d71320&gt;, range(10))
</pre>

<p>Další užitečnou funkcí vyššího řádu je funkce <strong>reduce</strong>, při
jejímž použití dochází k&nbsp;postupné redukci prvků uložených v&nbsp;sekvenci,
a to (postupnou) aplikací zvolené uživatelské funkce na jednotlivé prvky a po
krocích počítaný mezivýsledek, jenž se většinou nazývá <i>akumulátor</i>.
Příklad výpočtu faktoriálu deseti:</p>

<pre>
<strong>print(reduce(lambda acc, x: acc * x, range(1, 10)))</strong>
&nbsp;
362880
</pre>

<p>Návratovou hodnotou další užitečné funkce <strong>takewhile</strong> je
sekvence získaná ze vstupní sekvence, ovšem vráceno je pouze prvních <i>n</i>
prvků, pro něž predikát (typicky anonymní funkce, ale není to podmínkou) vrací
hodnotu <strong>True</strong>. Nejedná se však o klasický filtr, protože ihned
ve chvíli, kdy predikát poprvé vrátí hodnotu <strong>False</strong>, je
sekvence ukončena:</p>

<pre>
<strong>print(list(takewhile(lambda x: x &lt; 10, range(100))))</strong>
&nbsp;
[0, 1, 2, 3, 4, 5, 6, 7, 8, 9]
</pre>

<p>Opakem je funkce <strong>dropwhile</strong>, která naopak ignoruje ty prvky,
pro něž predikát vrací <strong>True</strong>. Po první detekci návratové
hodnoty <strong>False</strong> se vrátí zbytek sekvence:</p>

<pre>
<strong>print(list(dropwhile(lambda x: x &lt; 10, range(100))))</strong>
&nbsp;
[10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24,
 25, 26, 27, 28, 29, 30, 31, 32, 33, 34, 35, 36, 37, 38, 39,
 40, 41, 42, 43, 44, 45, 46, 47, 48, 49, 50, 51, 52, 53, 54,
 55, 56, 57, 58, 59, 60, 61, 62, 63, 64, 65, 66, 67, 68, 69,
 70, 71, 72, 73, 74, 75, 76, 77, 78, 79, 80, 81, 82, 83, 84,
 85, 86, 87, 88, 89, 90, 91, 92, 93, 94, 95, 96, 97, 98, 99]
</pre>

<p>Užitečná je funkce <strong>count</strong>, která může generovat konečnou či
nekonečnou aritmetickou řadu s&nbsp;nastavenou počáteční hodnotou a krokem.
Vytvoření nekonečné sekvence:</p>

<pre>
<strong>print(list(takewhile(lambda x: x &lt; 10, (count()))))</strong>
&nbsp;
[0, 1, 2, 3, 4, 5, 6, 7, 8, 9]
</pre>

<p>Explicitní specifikace počáteční hodnoty:</p>

<pre>
<strong>print(list(takewhile(lambda x: x &lt; 10, (count(0)))))</strong>
&nbsp;
[0, 1, 2, 3, 4, 5, 6, 7, 8, 9]
</pre>

<p>Explicitní specifikace počáteční hodnoty i kroku:</p>

<pre>
<strong>print(list(takewhile(lambda x: x &lt; 10, (count(0, 2)))))</strong>
&nbsp;
[0, 2, 4, 6, 8]
</pre>



<p><a name="k10"></a></p>
<h2 id="k10">10. Zkrácený zápis lambda výrazů (zjednodušených anonymních funkcí)</h2>

<p>Coconut programátorům nabízí i možnost zkráceného zápisu lambda výrazů (což
jsou v&nbsp;Pythonu anonymní funkce tvořené jediným výrazem). Následující dva
zápisy jsou ekvivalentní, přičemž výraz druhý je kratší a více se podobá
&bdquo;klasické&ldquo; lambdě:</p>

<pre>
<strong>print(list(map(lambda x: x * 2, [1, 2, 3])))</strong>
&nbsp;
[2, 4, 6]
</pre>

<pre>
<strong>print(list(map(x -&gt; x * 2, [1, 2, 3])))</strong>
&nbsp;
[2, 4, 6]
</pre>

<p>Zjednodušení předchozího zápisu s&nbsp;využitím <strong>fmap</strong>
namísto kombinace <strong>map+list</strong>:</p>

<pre>
<strong>print(fmap(x -&gt; x * 2, [1, 2, 3]))</strong>
&nbsp;
[2, 4, 6]
</pre>

<p>Pokud anonymní funkce akceptují dva či více parametrů, je nutné je uzavřít
do závorek!:</p>

<pre>
<strong>reduce( (acc,x) -&gt; acc*x, range(1,10))</strong>
&nbsp;
362880
</pre>

<p>Další příklad &ndash; vytvoření 2D matice:</p>

<pre>
<strong>print(list(map( (x,y,z) -&gt; [x,y,z], [1,2,3], [4,5,6], [7,8,9])))</strong>
&nbsp;
[[1, 4, 7], [2, 5, 8], [3, 6, 9]]
</pre>



<p><a name="k11"></a></p>
<h2 id="k11">11. Neměnitelné (immutable) datové typy</h2>

<p>Jazyk Coconut, podobně jako další funkcionální jazyky, podporuje tvorbu a
použití neměnitelných (<strong>immutable</strong>) datových typů. Příkladem
může být nový typ představující neměnitelná komplexní čísla. Povšimněte si, že
se používá nové klíčové slovo <strong>data</strong> a že pro nový typ můžeme
definovat i chování operátorů (zde unárního operátoru - a binárního operátoru
+):</p>

<pre>
data complex(real, imag):
&nbsp;
    def __abs__(self) =
        (self.real**2 + self.imag**2)**1/2
&nbsp;
    def __neg__(self) =
        (self.real, self.imag) |&gt; map$(-) |*&gt; complex
&nbsp;
    def __add__(self, other) = 
        complex(self.real + other.real, self.imag + other.imag)
</pre>

<p>Práce s&nbsp;novým datovým typem je jednoduchá a do značné míry se podobá
použití běžných objektů:</p>

<pre>
c1=complex(1.0, 2.0)
&nbsp;
print(-c1)
&nbsp;
print(c1)
&nbsp;
print(abs(c1))
&nbsp;
c1 |&gt; abs |&gt; print
&nbsp;
c2=complex(100.0, 50.0)
&nbsp;
print(c1+c2)
&nbsp;
print(c1+c1)
</pre>

<p>S&nbsp;výsledky:</p>

<pre>
complex(real=-1.0, imag=-2.0)
complex(real=1.0, imag=2.0)
2.5
2.5
complex(real=101.0, imag=52.0)
complex(real=2.0, imag=4.0)
</pre>

<p>Ovšem pozor &ndash; změna atributů není možná (což je ostatně přesně to, co
od immutable hodnot očekáváme):</p>

<pre>
<strong>c1.real=10</strong>
&nbsp;
Traceback (most recent call last):
  File "/home/tester/.local/lib/python2.7/site-packages/coconut/command/util.py", line 365, in handling_errors
    yield
  File "/home/tester/.local/lib/python2.7/site-packages/coconut/command/util.py", line 387, in run
    result = run_func(code, self.vars)
  File "/home/tester/.local/lib/python2.7/site-packages/coconut/command/util.py", line 147, in interpret
    exec_func(code, in_vars)
  File "/home/tester/.local/lib/python2.7/site-packages/coconut/command/util.py", line 132, in exec_func
    exec(code, glob_vars)
  File "&lt;string&gt;", line 1, in &lt;module&gt;
AttributeError: can't set attribute
</pre>

<p>Pro zajímavost se můžeme podívat, jak je vlastně nový typ &bdquo;komplexní
číslo&ldquo; deklarován v&nbsp;Pythonu. Celé kouzlo spočívá v&nbsp;použití
vhodné rodičovské třídy:</p>

<pre>
class complex(_coconut.collections.namedtuple("complex", "real imag"), _coconut.object):
    __slots__ = ()
    __ne__ = _coconut.object.__ne__
    def __abs__(self):
        return (self.real**2 + self.imag**2)**1 / 2
&nbsp;    
    @_coconut_tco
    def __neg__(self):
        raise _coconut_tail_call((complex), *map(_coconut_minus, (self.real, self.imag)))
&nbsp;
    @_coconut_tco
    def __add__(self, other):
        raise _coconut_tail_call(complex, self.real + other.real, self.imag + other.imag)
</pre>



<p><a name="k12"></a></p>
<h2 id="k12">12. Infixový zápis při volání funkcí</h2>

<p>Při volání funkcí akceptujících dva parametry (ovšem ani více, ani méně) lze
použít infixový zápis, v&nbsp;němž je první operand zapsán před jméno funkce,
samotné jméno funkce je umístěno ve zpětných apostrofech a po něm je zapsán
druhý operand. Tento zápis není výhodný vždy, ovšem v&nbsp;některých případech
je čitelnější a logičtější:</p>

<pre>
<strong>print("hello" `isinstance` str)</strong>
</pre>

<p>Podívejme se na poněkud složitější příklad s&nbsp;definicí funkce &bdquo;n
nad k&ldquo;, kterou lze volat dvěma způsoby &ndash; jako klasickou funkci i
v&nbsp;infixovém zápisu:</p>

<pre>
def factorial(n):
    if n &lt;= 1:
        return 1
    else:
        return range(1, n+1) |&gt; reduce$(*)
&nbsp;
def choose(n, k):
    return factorial(n)/(factorial(k)*factorial(n-k))
&nbsp;
print(factorial(10))
&nbsp;
for k in range(5):
    print(<strong>choose(4, k)</strong>)
&nbsp;
print()
&nbsp;
for k in range(5):
    print(<strong>4 `choose` k</strong>)
</pre>



<p><a name="k13"></a></p>
<h2 id="k13">13. Infixový zápis při definici nových funkcí</h2>

<p>Dokonce i při definici funkce je možné použít infixový zápis. Příkladem může
být funkce pojmenovaná <strong>nad</strong>, kterou lze definovat dvěma zcela
ekvivalentními způsoby:</p>

<pre>
def <strong>nad(n, k)</strong>:
    return factorial(n)/(factorial(k)*factorial(n-k))
&nbsp;
def <strong>n `nad` k</strong>:
    return factorial(n)/(factorial(k)*factorial(n-k))
</pre>

<p>Opět se podívejme na celý příklad, kde bude tato funkce použita:</p>

<pre>
def factorial(n):
    if n &lt;= 1:
        return 1
    else:
        return range(1, n+1) |&gt; reduce$(*)
&nbsp;
def n `nad` k:
    return factorial(n)/(factorial(k)*factorial(n-k))
&nbsp;
print()
&nbsp;
for k in range(5):
    print(4 `nad` k)
</pre>



<p><a name="k14"></a></p>
<h2 id="k14">14. Vytvoření &bdquo;kolony&ldquo; z&nbsp;funkcí</h2>

<p>Užitečná je i možnost vytvoření kolony (pipeline) z&nbsp;funkcí, což je
technologie, kterou velmi pravděpodobně znáte z&nbsp;shellu, ale najdeme ji
například i v&nbsp;programovacím jazyku <i>Clojure</i> (<i>threading
macro</i>). Základní kolona se sestaví operátorem |&gt;, který dokáže poslat
data ze své levé strany do funkce uvedené na straně pravé. Pokud taková funkce
vrací jiná data, je samozřejmě možné kolonu libovolným způsobem rozšiřovat.
Dnes si ukážeme to nejjednodušší použití kolony pro funkce s&nbsp;jediným
vstupem:</p>

<pre>
-42 |&gt; abs |&gt; print
&nbsp;
"B" |&gt; ord |&gt; abs |&gt; hex |&gt; print
&nbsp;
range(11) |&gt; sum |&gt; print
&nbsp;
range(11) |&gt; reversed |&gt; sum |&gt; print
&nbsp;
def evens(sequence):
    return filter(lambda x: x % 2 == 0, sequence)
&nbsp;
[1, 2, 3, 4, 5, 6, 30] |&gt; evens |&gt; sum |&gt; print
</pre>

<p>Pokud by kolony nebyly podporovány, musel by se druhý řádek:</p>

<pre>
"B" |&gt; ord |&gt; abs |&gt; hex |&gt; print
</pre>

<p>přepsat do prakticky nečitelného příkazu:</p>

<pre>
print(hex(abs(ord("B"))))
</pre>



<p><a name="k15"></a></p>
<h2 id="k15">15. Kompozice funkcí</h2>

<p>Z&nbsp;funkcí lze operátorem .. (dvě tečky) vytvořit i kompozici. To
znamená, že namísto zápisu:</p>

<pre>
"B" |&gt; ord |&gt; abs |&gt; hex |&gt; print
</pre>

<p>můžeme použít kompozici tří funkcí:</p>

<pre>
"B" |&gt; hex..abs..ord |&gt; print
</pre>

<p>Další příklady:</p>

<pre>
range(11) |&gt; reversed |&gt; sum |&gt; print
&nbsp;
range(11) |&gt; sum..reversed |&gt; print
&nbsp;
def evens(sequence):
    return filter(x -&gt; x % 2 == 0, sequence)
&nbsp;
[1, 2, 3, 4, 5, 6, 30] |&gt; sum..evens |&gt; print
</pre>

<p>Rozdíl oproti koloně spočívá v&nbsp;tom, že kompozice funkcí je možné použít
i pro vytvoření funkce nové:</p>

<pre>
comp = hex..abs..ord
</pre>

<p>Poznámka: existuje i operátor ..&gt;, v&nbsp;němž se funkce volají
v&nbsp;opačném pořadí, tj.&nbsp;tak, jak jsou zapsána jejich jména.</p>



<p><a name="k16"></a></p>
<h2 id="k16">16. Čísla řádků a zachování původního zdrojového kódu ve vygenerovaném modulu</h2>

<p>Na závěr článku se ještě podívejme na způsob transpřekladu a vkládaní
doplňkových informací do generovaného kódu. Mějme například následující
zdrojový kód s&nbsp;několika kolonami, a pojmenovanou funkcí:</p>

<pre>
-42 |&gt; abs |&gt; print
 
"B" |&gt; ord |&gt; abs |&gt; hex |&gt; print
&nbsp;
range(11) |&gt; sum |&gt; print
&nbsp;
range(11) |&gt; reversed |&gt; sum |&gt; print
&nbsp;
def evens(sequence):
    return filter(lambda x: x % 2 == 0, sequence)
&nbsp;
[1, 2, 3, 4, 5, 6, 30] |&gt; evens |&gt; sum |&gt; print
</pre>

<p>Při běžném překladu příkazem <strong>coconut</strong> bude výsledný
pythonovský kód vypadat zhruba takto:</p>

<pre>
# Compiled Coconut: -----------------------------------------------------------
&nbsp;
(print)((abs)(-42))
&nbsp;
(print)((hex)((abs)((ord)("B"))))
&nbsp;
(print)((sum)(range(11)))
&nbsp;
(print)((sum)((reversed)(range(11))))
&nbsp;
@_coconut_tco
def evens(sequence):
    return _coconut_tail_call(filter, lambda x: x % 2 == 0, sequence)
&nbsp;
(print)((sum)((evens)([1, 2, 3, 4, 5, 6, 30])))
</pre>

<p>Při ladění může být výhodné použít přepínač <strong>-l</strong> nebo
<strong>--line-numbers</strong>, který zajistí, že se do vygenerovaného kódu
vloží i čísla řádků, samozřejmě do poznámek:</p>

<pre>
# Compiled Coconut: -----------------------------------------------------------
&nbsp;
(print)((abs)(-42))  # line 1
&nbsp;
(print)((hex)((abs)((ord)("B"))))  # line 3
&nbsp;
(print)((sum)(range(11)))  # line 5
&nbsp;
(print)((sum)((reversed)(range(11))))  # line 7
&nbsp;
@_coconut_tco  # line 9
def evens(sequence):  # line 9
    return _coconut_tail_call(filter, lambda x: x % 2 == 0, sequence)  # line 10
&nbsp;
(print)((sum)((evens)([1, 2, 3, 4, 5, 6, 30])))  # line 12
</pre>

<p>Další přepínač <strong>-k</strong> popř.&nbsp;<strong>--keep-lines</strong>
navíc do vygenerovaného kódu přidá i úryvky z&nbsp;kódu zdrojového, což opět
může být použito například pro ladění či pro zkoumání, proč se některá
konstrukce nevykonává tak, jak by podle předpokladů měla:</p>

<pre>
# Compiled Coconut: -----------------------------------------------------------
&nbsp;
(print)((abs)(-42))  # line 1: -42 |&gt; abs |&gt; print
&nbsp;
(print)((hex)((abs)((ord)("B"))))  # line 3: "B" |&gt; ord |&gt; abs |&gt; hex |&gt; print
&nbsp;
(print)((sum)(range(11)))  # line 5: range(11) |&gt; sum |&gt; print
&nbsp;
(print)((sum)((reversed)(range(11))))  # line 7: range(11) |&gt; reversed |&gt; sum |&gt; print
&nbsp;
@_coconut_tco  # line 9: def evens(sequence):
def evens(sequence):  # line 9: def evens(sequence):
    return _coconut_tail_call(filter, lambda x: x % 2 == 0, sequence)  # line 10:     return filter(lambda x: x % 2 == 0, sequence)
&nbsp;
(print)((sum)((evens)([1, 2, 3, 4, 5, 6, 30])))  # line 12: [1, 2, 3, 4, 5, 6, 30] |&gt; evens |&gt; sum |&gt; print
</pre>



<p><a name="k17"></a></p>
<h2 id="k17">17. Demonstrační příklady</h2>

<p>Zdrojové kódy všech dnes popsaných demonstračních příkladů naleznete pod
následujícími odkazy:</p>

<table>
<tr><th>Zdrojový kód</th><th>Adresa</th></tr>
<tr><td>01-hello_world.coco</td><td><a href="https://github.com/tisnik/presentations/blob/master/coconut/01-hello_world.coco">https://github.com/tisnik/presentations/blob/master/coconut/01-hello_world.coco</a></td></tr>
<tr><td>02-sequences.coco</td><td><a href="https://github.com/tisnik/presentations/blob/master/coconut/02-sequences.coco">https://github.com/tisnik/presentations/blob/master/coconut/02-sequences.coco</a></td></tr>
<tr><td>03-anonymous-functions.coco</td><td><a href="https://github.com/tisnik/presentations/blob/master/coconut/03-anonymous-functions.coco">https://github.com/tisnik/presentations/blob/master/coconut/03-anonymous-functions.coco</a></td></tr>
<tr><td>04-immutable-types.coco</td><td><a href="https://github.com/tisnik/presentations/blob/master/coconut/04-immutable-types.coco">https://github.com/tisnik/presentations/blob/master/coconut/04-immutable-types.coco</a></td></tr>
<tr><td>05-infix-notation.coco</td><td><a href="https://github.com/tisnik/presentations/blob/master/coconut/05-infix-notation.coco">https://github.com/tisnik/presentations/blob/master/coconut/05-infix-notation.coco</a></td></tr>
<tr><td>06-pipeline.coco</td><td><a href="https://github.com/tisnik/presentations/blob/master/coconut/06-pipeline.coco">https://github.com/tisnik/presentations/blob/master/coconut/06-pipeline.coco</a></td></tr>
<tr><td>07-function-composition.coco</td><td><a href="https://github.com/tisnik/presentations/blob/master/coconut/07-function-composition.coco">https://github.com/tisnik/presentations/blob/master/coconut/07-function-composition.coco</a></td></tr>
<tr><td>06-pipeline_compiled_line_numbers.py</td><td><a href="https://github.com/tisnik/presentations/blob/master/coconut/06-pipeline_compiled_line_numbers.py">https://github.com/tisnik/presentations/blob/master/coconut/06-pipeline_compiled_line_numbers.py</a></td></tr>
<tr><td>06-pipeline_compiled_original_code.py</td><td><a href="https://github.com/tisnik/presentations/blob/master/coconut/06-pipeline_compiled_original_code.py">https://github.com/tisnik/presentations/blob/master/coconut/06-pipeline_compiled_original_code.py</a></td></tr>
<tr><td>06-pipeline_compiled.py</td><td><a href="https://github.com/tisnik/presentations/blob/master/coconut/06-pipeline_compiled.py">https://github.com/tisnik/presentations/blob/master/coconut/06-pipeline_compiled.py</a></td></tr>
</table>

<p>Poznámka: poslední tři soubory vznikly transpřekladem zdrojového kódu
<strong>06-pipeline.coco</strong> s&nbsp;různými parametry předanými
Coconutu.</p>



<p><a name="k18"></a></p>
<h2 id="k18">18. Odkazy na Internetu</h2>

<ol>

<li>Coconut: Simple, elegant, Pythonic functional programming<br />
<a href="http://coconut-lang.org/">http://coconut-lang.org/</a>
</li>

<li>coconut 1.1.0 (Python package index)<br />
<a href="https://pypi.python.org/pypi/coconut/1.1.0">https://pypi.python.org/pypi/coconut/1.1.0</a>
</li>

<li>Coconut Tutorial<br />
<a href="http://coconut.readthedocs.io/en/master/HELP.html">http://coconut.readthedocs.io/en/master/HELP.html</a>
</li>

<li>Coconut FAQ<br />
<a href="http://coconut.readthedocs.io/en/master/FAQ.html">http://coconut.readthedocs.io/en/master/FAQ.html</a>
</li>

<li>Coconut Documentation<br />
<a href="http://coconut.readthedocs.io/en/master/DOCS.html">http://coconut.readthedocs.io/en/master/DOCS.html</a>
</li>

<li>Coconut na Redditu<br />
<a href="https://www.reddit.com/r/Python/comments/4owzu7/coconut_functional_programming_in_python/">https://www.reddit.com/r/Python/comments/4owzu7/coconut_functional_programming_in_python/</a>
</li>

<li>Repositář na GitHubu<br />
<a href="https://github.com/evhub/coconut">https://github.com/evhub/coconut</a>
</li>

<li>patterns<br />
<a href="https://github.com/Suor/patterns">https://github.com/Suor/patterns</a>
</li>

<li>Source-to-source compiler<br />
<a href="https://en.wikipedia.org/wiki/Source-to-source_compiler">https://en.wikipedia.org/wiki/Source-to-source_compiler</a>
</li>

<li>The Lua VM, on the Web<br />
<a href="https://kripken.github.io/lua.vm.js/lua.vm.js.html">https://kripken.github.io/lua.vm.js/lua.vm.js.html</a>
</li>

<li>Lua.vm.js REPL<br />
<a href="https://kripken.github.io/lua.vm.js/repl.html">https://kripken.github.io/lua.vm.js/repl.html</a>
</li>

<li>lua2js<br />
<a href="https://www.npmjs.com/package/lua2js">https://www.npmjs.com/package/lua2js</a>
</li>

<li>Wisp na GitHubu<br />
<a href="https://github.com/Gozala/wisp">https://github.com/Gozala/wisp</a>
</li>

<li>Wisp playground<br />
<a href="http://www.jeditoolkit.com/try-wisp/">http://www.jeditoolkit.com/try-wisp/</a>
</li>

<li>REPL v prohlížeči<br />
<a href="http://www.jeditoolkit.com/interactivate-wisp/">http://www.jeditoolkit.com/interactivate-wisp/</a>
</li>

<li>Minification (programming)<br />
<a href="https://en.wikipedia.org/wiki/Minification_(programming)">https://en.wikipedia.org/wiki/Minification_(programming)</a>
</li>

<li>JavaScript is Assembly Language for the Web: Sematic Markup is Dead! Clean vs. Machine-coded HTML<br />
<a href="http://www.hanselman.com/blog/JavaScriptIsAssemblyLanguageForTheWebSematicMarkupIsDeadCleanVsMachinecodedHTML.aspx">http://www.hanselman.com/blog/JavaScriptIsAssemblyLanguageForTheWebSematicMarkupIsDeadCleanVsMachinecodedHTML.aspx</a>
</li>

<li>JavaScript is Web Assembly Language and that's OK.<br />
<a href="http://www.hanselman.com/blog/JavaScriptIsWebAssemblyLanguageAndThatsOK.aspx">http://www.hanselman.com/blog/JavaScriptIsWebAssemblyLanguageAndThatsOK.aspx</a>
</li>

<li>Dart<br />
<a href="https://www.dartlang.org/">https://www.dartlang.org/</a>
</li>

<li>CoffeeScript<br />
<a href="http://coffeescript.org/">http://coffeescript.org/</a>
</li>

<li>TypeScript<br />
<a href="http://www.typescriptlang.org/">http://www.typescriptlang.org/</a>
</li>

<li>JavaScript: The Web Assembly Language?<br />
<a href="http://www.informit.com/articles/article.aspx?p=1856657">http://www.informit.com/articles/article.aspx?p=1856657</a>
</li>

<li>asm.js<br />
<a href="http://asmjs.org/">http://asmjs.org/</a>
</li>

<li>List of languages that compile to JS<br />
<a href="https://github.com/jashkenas/coffeescript/wiki/List-of-languages-that-compile-to-JS">https://github.com/jashkenas/coffeescript/wiki/List-of-languages-that-compile-to-JS</a>
</li>

<li>Permutation<br />
<a href="https://en.wikipedia.org/wiki/Permutation">https://en.wikipedia.org/wiki/Permutation</a>
</li>

<li>Pattern matching<br />
<a href="https://en.wikipedia.org/wiki/Pattern_matching">https://en.wikipedia.org/wiki/Pattern_matching</a>
</li>

<li>Pattern matching v&nbsp;Rustu<br />
<a href="https://www.root.cz/clanky/rust-funkce-lambda-vyrazy-a-rozhodovaci-konstrukce-match/#k13">https://www.root.cz/clanky/rust-funkce-lambda-vyrazy-a-rozhodovaci-konstrukce-match/#k13</a>
</li>

<li>SNOBOL<br />
<a href="https://en.wikipedia.org/wiki/SNOBOL">https://en.wikipedia.org/wiki/SNOBOL</a>
</li>

<li>Podpůrný plugin pro Vim<br />
<a href="https://github.com/manicmaniac/coconut.vim">https://github.com/manicmaniac/coconut.vim</a>
</li>

<li>Příkaz (programování)<br />
<a href="https://cs.wikipedia.org/wiki/P%C5%99%C3%ADkaz_%28programov%C3%A1n%C3%AD%29">https://cs.wikipedia.org/wiki/P%C5%99%C3%ADkaz_%28programov%C3%A1n%C3%AD%29</a>
</li>

<li>Threading Macros Guide<br />
<a href="https://clojure.org/guides/threading_macros">https://clojure.org/guides/threading_macros</a>
</li>

</ol>



<p></p><p></p>
<p><small>Autor: <a href="http://www.fit.vutbr.cz/~tisnovpa">Pavel Tišnovský</a> &nbsp; 2017</small></p>
</body>
</html>
