<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
        "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html>
<head>
<title>Programovací jazyk Rust: práce se soubory a se standardními proudy</title>
<meta name="Author" content="Pavel Tisnovsky" />
<meta name="Generator" content="vim" />
<meta http-equiv="content-type" content="text/html; charset=utf-8" />
<style type="text/css">
         body {color:#000000; background:#ffffff;}
         h1  {font-family: arial, helvetica, sans-serif; color:#ffffff; background-color:#c00000; text-align:center; padding-left:1em}
         h2  {font-family: arial, helvetica, sans-serif; color:#ffffff; background-color:#0000c0; padding-left:1em; text-align:left}
         h3  {font-family: arial, helvetica, sans-serif; color:#000000; background-color:#c0c0c0; padding-left:1em; text-align:left}
         h4  {font-family: arial, helvetica, sans-serif; color:#000000; background-color:#e0e0e0; padding-left:1em; text-align:left}
         a   {font-family: arial, helvetica, sans-serif;}
         li  {font-family: arial, helvetica, sans-serif; color:#000000; text-align:justify; width:450px;}
         ol  {font-family: arial, helvetica, sans-serif; color:#000000; text-align:justify; width:450px;}
         ul  {font-family: arial, helvetica, sans-serif; color:#000000; text-align:justify; width:450px;}
         p   {font-family: arial, helvetica, sans-serif; color:#000000; text-align:justify;}
         pre {background:#e0e0e0}
</style>
</head>

<body>

<h1>Programovací jazyk Rust: práce se soubory a se standardními proudy</h1>

<h3>Pavel Tišnovský</h3>

<p></p>

<h1>Úvodník</h1>

<p>Většina běžných aplikací potřebuje pracovat se soubory popř.&nbsp;se standardními vstupními a výstupními proudy (stdin, stdout, stderr). Z&nbsp;tohoto důvodu se dnes seznámíme s&nbsp;některými traity a funkcemi, které se pro vstupně-výstupní operace používají.</p>



<h2>Obsah</h2>

<p><a href="#k01">1. Programovací jazyk Rust: práce se soubory a se standardními proudy</a></p>
<p><a href="#k02">2. Vytvoření nového souboru s&nbsp;provedením zápisu</a></p>
<p><a href="#k03">3. Pokus o vytvoření souboru v&nbsp;adresáři, kam uživatel nemá právo zápisu</a></p>
<p><a href="#k04">4. Návratové typy operací <strong>File::create()</strong> a <strong>File::write()</strong></a></p>
<p><a href="#k05">5. Kontrola všech I/O operací v&nbsp;Rustu</a></p>
<p><a href="#k06">6. Ve které chvíli se soubor zavře?</a></p>
<p><a href="#k07">7. Přečtení jednoho řádku ze standardního vstupu</a></p>
<p><a href="#k08">8. Iterátor pro přečtení všech řádků ze standardního vstupu</a></p>
<p><a href="#k09">9. Zpracování textových souborů</a></p>
<p><a href="#k10">10. Repositář s&nbsp;demonstračními příklady</a></p>
<p><a href="#k11">11. Odkazy na Internetu</a></p>



<p><a name="k01"></a></p>
<h2 id="k01">1. Práce se soubory a se standardními proudy</h2>

<p>Dnes se budeme zabývat základními strukturami a traity, které slouží
k&nbsp;práci se soubory (přesněji řečeno s&nbsp;obsahem souborů) a které můžeme
najít ve standardní knihovně Rustu. Kromě toho se seznámíme i s&nbsp;možnostmi
práce se standardním vstupním proudem (stdin), výstupním proudem (stdout) a
proudem používaným pro výpis chybových hlášení (stderr). Podobně jako
v&nbsp;dalších oblastech se i při návrhu I/O operací dbalo na bezpečnost, takže
v&nbsp;základní knihovně Rustu nenajdeme například tak potenciálně nebezpečné
funkce, jako je nechvalně známá <strong>gets()</strong> atd. V&nbsp;následující
tabulce jsou vypsány základní struktury a traity, které postupně použijeme
v&nbsp;demonstračních příkladech:</p>

<table>
<tr><th>Struktura</th><th>Implementované traity</th><th>Stručný popis</th></tr>
<tr><td><a href="https://doc.rust-lang.org/std/fs/struct.File.html">std::fs::File</a></td>
    <td><a href="https://doc.rust-lang.org/std/io/trait.Read.html">std::io::Read</a>, <a href="https://doc.rust-lang.org/std/io/trait.Write.html">std::io::Write</a>, <a href="https://doc.rust-lang.org/std/io/trait.Seek.html">std::io::Seek</a></td>
    <td>reprezentuje otevřený soubor (obdoba handle z&nbsp;céčka)</td></tr>
<tr><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td></tr>
<tr><td><a href="https://doc.rust-lang.org/std/io/struct.Stdin.html">std::io::Stdin</a></td>
    <td><a href="https://doc.rust-lang.org/std/io/trait.Read.html">std::io::Read</a></td>
    <td>standardní vstup</td></tr>
<tr><td><a href="https://doc.rust-lang.org/std/io/struct.Stdout.html">std::io::Stdout</a></td>
    <td><a href="https://doc.rust-lang.org/std/io/trait.Write.html">std::io::Write</a></td>
    <td>standardní výstup</td></tr>
<tr><td><a href="https://doc.rust-lang.org/std/io/struct.Stderr.html">std::io::Stderr</a></td>
    <td><a href="https://doc.rust-lang.org/std/io/trait.Write.html">std::io::Write</a></td>
    <td>chybový výstup</td></tr>
<tr><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td></tr>
<tr><td><a href="https://doc.rust-lang.org/std/io/struct.BufReader.html">std::io::BufReader</a></td>
    <td><a href="https://doc.rust-lang.org/std/io/trait.Read.html">std::io::Read</a>, <a href="https://doc.rust-lang.org/std/io/trait.BufRead.html">std::io::BufRead</a>, <a href="https://doc.rust-lang.org/std/io/trait.Seek.html">std::io::Seek</a></td>
    <td>bufferovaný vstup, umožňuje například pracovat s&nbsp;celými textovými řádky</td></tr>
<tr><td><a href="https://doc.rust-lang.org/std/io/struct.BufWriter.html">std::io::BufWriter</a></td>
    <td><a href="https://doc.rust-lang.org/std/io/trait.Write.html">std::io::Write</a>, <a href="https://doc.rust-lang.org/std/io/trait.Seek.html">std::io::Seek</a></td>
    <td>bufferovaný výstup</td></tr>
<tr><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td></tr>
<tr><td><a href="https://doc.rust-lang.org/std/io/struct.Error.html">std::io::Error</a></td>
    <td><a href="https://doc.rust-lang.org/std/error/trait.Error.html">std::error::Error</a></td>
    <td>reprezentuje nějakou formu chyby při vstupních a výstupních operacích</td></tr>
</table>

<p>Poznámka: použití traitu <strong>std::to::Seek</strong> při práci
s&nbsp;binárními soubory si ukážeme v&nbsp;navazující části tohoto seriálu.</p>



<p><a name="k02"></a></p>
<h2 id="k02">2. Vytvoření nového souboru s&nbsp;provedením zápisu</h2>

<p>První příklad bude velmi jednoduchý, protože v&nbsp;něm pouze vytvoříme nový
soubor metodou <strong>File::create()</strong>. Tato metoda vrací hodnotu typu
<strong>Result&lt;File&gt;</strong>, což konkrétně znamená, že se vrátí buď
handle otevřeného souboru reprezentovaný strukturou
<strong>std::fs::File</strong> nebo hodnotu typu
<strong>std::io::Error</strong>. Následně provedeme zápis do souboru metodou
<strong>File.write()</strong>, které se předá <i>slice</i> bajtů, tedy hodnot
typu <strong>u8</strong>. Tato metoda vrátí hodnotu typu
<strong>Result&lt;usize&gt;</strong>, tedy opět buď chybu nebo počet zapsaných
bajtů:</p>

<pre>
use std::io::prelude::*;
use std::fs::File;
&nbsp;
fn main() {
    let mut fout = <strong>File::create("test.txt")</strong>.unwrap();
    let written = <strong>fout.write(b"Hello, world!\n")</strong>.unwrap();
    println!("{} bytes written", written);
}
</pre>

<p>Poznámka: soubor není zapotřebí zavírat, protože překladač ve správný
okamžik (konkrétně na konci funkce main) zavolá destruktor struktury
<strong>File</strong>, která uzavření provede automaticky.</p>



<p><a name="k03"></a></p>
<h2 id="k03">3. Pokus o vytvoření souboru v&nbsp;adresáři, kam uživatel nemá právo zápisu</h2>

<p><a href="#k02">V&nbsp;předchozím</a> demonstračním příkladu jsme se
nesnažili o otestování, zda se soubor podařilo vytvořit a zda je do něj vůbec
možné zapisovat &ndash; jen jsme z&nbsp;hodnoty typu <strong>Result</strong>
získali příslušnou obalenou hodnotu metodou <strong>unwrap()</strong>. Toto
ignorování potenciálních chyb se nám může vymstít, což si můžeme ukázat na
jednoduchém příkladu, v&nbsp;němž se pokusíme zapisovat do adresáře
&bdquo;/bin&ldquo; (zde má právo zápisu pouze root):</p>

<pre>
use std::io::prelude::*;
use std::fs::File;
&nbsp;
fn main() {
    let mut fout = File::create(<strong>"/bin/test.txt"</strong>).unwrap();
    let written = fout.write(b"Hello, world!\n").unwrap();
    println!("{} bytes written", written);
}
</pre>

<p>Program by měl po svém spuštění napsat následující chybové hlášení (pokud ho
samozřejmě nespouštíte s&nbsp;právy superuživatele):</p>

<pre>
thread 'main' panicked at 'called `Result::unwrap()` on an `Err` value: Error { repr: Os { code: 13, message: "Permission denied" } }', ../src/
libcore/result.rs:788
note: Run with `RUST_BACKTRACE=1` for a backtrace.
</pre>

<p>Jinými slovy se v&nbsp;čase běhu programu (runtime) zjistilo, že se snažíme
zavolat metodu <strong>Result.unwrap()</strong> ve chvíli, kdy je v&nbsp;této
struktuře uložena struktura reprezentující chybu a nikoli handle otevřeného
souboru.</p>



<p><a name="k04"></a></p>
<h2 id="k04">4. Návratové typy operací <strong>File::create()</strong> a <strong>File::write()</strong></h2>

<p>Korektnější je samozřejmě důsledně testovat hodnoty vrácené operacemi
<strong>File::create()</strong> a <strong>File::write()</strong> a samozřejmě i
všech dalších I/O operací. To konkrétně znamená, že se namísto volání metody
<strong>unwrap()</strong>:</p>

<pre>
use std::io::prelude::*;
use std::fs::File;
&nbsp;
fn main() {
    let mut fout = File::create("test.txt")<strong>.unwrap()</strong>;
    let written = fout.write(b"Hello, world!\n")<strong>.unwrap()</strong>;
    println!("{} bytes written", written);
}
</pre>

<p>může metodami <strong>is_ok()</strong> a <strong>is_err()</strong>
otestovat, jaká hodnota je obalena v&nbsp;typu <strong>Result</strong>. Mnohem
lepší je však použití nám již dobře známého pattern matchingu, viz <a
href="#k05">navazující kapitolu</a>.</p>



<p><a name="k05"></a></p>
<h2 id="k05">5. Kontrola všech I/O operací v&nbsp;Rustu</h2>

<p>Další demonstrační příklad je již napsán mnohem lepším způsobem, protože se
v&nbsp;něm důsledně používá pattern matching pro přístup do datové struktury
<strong>Result</strong>. Díky pattern matchingu navíc ušetříme nepříjemné
používání metody <strong>unwrap()</strong> atd.:</p>

<pre>
use std::io::prelude::*;
use std::fs::File;
&nbsp;
fn write_message_to_file(mut fout: &amp;File) {
    <strong>match</strong> fout.write(b"Hello, world!\n") {
        Ok(written) <strong>=&gt;</strong> {
            println!("{} bytes written", written);
        }
        Err(error) <strong>=&gt;</strong> {
            println!("write error: {}", error);
        }
    }
}
&nbsp;
fn main() {
    <strong>match</strong> File::create("test.txt") {
        Ok(fout) <strong>=&gt;</strong> {
            write_message_to_file(&amp;fout);
        }
        Err(error) <strong>=&gt;</strong> {
            println!("file create error: {}", error);
        }
    }
}
</pre>

<p>Podívejme se nyní, co se stane ve chvíli, kdy se budeme snažit vytvořit
soubor v&nbsp;adresáři, kde pro tuto operaci nemáme příslušná práva:</p>

<pre>
use std::io::prelude::*;
use std::fs::File;
&nbsp;
fn write_message_to_file(mut fout: &amp;File) {
    match fout.write(b"Hello, world!\n") {
        Ok(written) =&gt; {
            println!("{} bytes written", written);
        }
        Err(error) =&gt; {
            println!("write error: {}", error);
        }
    }
}
&nbsp;
fn main() {
    match File::create(<strong>"/bin/test.txt"</strong>) {
        Ok(fout) =&gt; {
            write_message_to_file(&amp;fout);
        }
        Err(error) =&gt; {
            println!("file create error: {}", error);
        }
    }
}
</pre>

<pre>
file create error: Permission denied (os error 13)
</pre>



<p><a name="k06"></a></p>
<h2 id="k06">6. Ve které chvíli se soubor zavře?</h2>

<p>Ve druhé kapitole jsme si řekli, že se soubor automaticky zavře ve chvíli,
kdy skončí viditelnost hodnoty typu <strong>File</strong>. V&nbsp;tento okamžik
se zavolá destruktor, jehož úkolem je mj.&nbsp;i uzavření souboru. Ostatně se o
tom můžeme relativně snadno přesvědčit. Upravíme si předchozí demonstrační
příklad tak, aby se soubor vytvářel nikoli ve funkci <strong>main</strong>, ale
ve funkci <strong>create_hello_world_file</strong>, která se
z&nbsp;<strong>main</strong> volá. Na konci <strong>main</strong> navíc na
standardní výstup vypíšeme nějaké hlášení. Upravený příklad vypadá
následovně:</p>

<pre>
use std::io::prelude::*;
use std::fs::File;
&nbsp;
fn write_message_to_file(mut fout: &amp;File) {
    match fout.write(b"Hello, world!\n") {
        Ok(written) =&gt; {
            println!("{} bytes written", written);
        }
        Err(error) =&gt; {
            println!("write error: {}", error);
        }
    }
}
&nbsp;
fn create_hello_world_file(file_name: &amp;str) {
    match File::create(file_name) {
        Ok(fout) =&gt; {
            write_message_to_file(&amp;fout);
        }
        Err(error) =&gt; {
            println!("file create error: {}", error);
        }
    }
}
&nbsp;
fn main() {
    create_hello_world_file("test.txt");
    // here the file should be closed
    println!("end of main");
}
</pre>

<p>Příklad přeložíme s&nbsp;využitím <strong>rustc</strong> a potom spustíme
přes utilitu <a
href="https://www.root.cz/clanky/trasovani-a-ladeni-nativnich-aplikaci-v-linuxu/#k06">strace</a>,
která dokáže vypsat informace o systémových voláních. Výstup by měl být zhruba
následující (nebojte se, hned si ho vysvětlíme):</p>

<pre>
execve("./test", ["./test"], [/* 53 vars */]) = 0
brk(0)                                  = 0x7fa7a50df000
access("/etc/ld.so.nohwcap", F_OK)      = -1 ENOENT (No such file or directory)
mmap(NULL, 8192, PROT_READ|PROT_WRITE, MAP_PRIVATE|MAP_ANONYMOUS, -1, 0) = 0x7fa7a45c4000
access("/etc/ld.so.preload", R_OK)      = -1 ENOENT (No such file or directory)
open("/etc/ld.so.cache", O_RDONLY|O_CLOEXEC) = 3
fstat(3, {st_mode=S_IFREG|0644, st_size=136983, ...}) = 0
mmap(NULL, 136983, PROT_READ, MAP_PRIVATE, 3, 0) = 0x7fa7a45a2000
close(3)                                = 0
access("/etc/ld.so.nohwcap", F_OK)      = -1 ENOENT (No such file or directory)
open("/lib/x86_64-linux-gnu/libdl.so.2", O_RDONLY|O_CLOEXEC) = 3
read(3, "\177ELF\2\1\1\0\0\0\0\0\0\0\0\0\3\0&gt;\0\1\0\0\0\320\16\0\0\0\0\0\0"..., 832) = 832
fstat(3, {st_mode=S_IFREG|0644, st_size=14664, ...}) = 0
mmap(NULL, 2109744, PROT_READ|PROT_EXEC, MAP_PRIVATE|MAP_DENYWRITE, 3, 0) = 0x7fa7a41a0000
mprotect(0x7fa7a41a3000, 2093056, PROT_NONE) = 0
mmap(0x7fa7a43a2000, 8192, PROT_READ|PROT_WRITE, MAP_PRIVATE|MAP_FIXED|MAP_DENYWRITE, 3, 0x2000) = 0x7fa7a43a2000
close(3)                                = 0
access("/etc/ld.so.nohwcap", F_OK)      = -1 ENOENT (No such file or directory)
open("/lib/x86_64-linux-gnu/libpthread.so.0", O_RDONLY|O_CLOEXEC) = 3
read(3, "\177ELF\2\1\1\0\0\0\0\0\0\0\0\0\3\0&gt;\0\1\0\0\0po\0\0\0\0\0\0"..., 832) = 832
fstat(3, {st_mode=S_IFREG|0755, st_size=141574, ...}) = 0
mmap(NULL, 2217264, PROT_READ|PROT_EXEC, MAP_PRIVATE|MAP_DENYWRITE, 3, 0) = 0x7fa7a3f82000
mprotect(0x7fa7a3f9b000, 2093056, PROT_NONE) = 0
mmap(0x7fa7a419a000, 8192, PROT_READ|PROT_WRITE, MAP_PRIVATE|MAP_FIXED|MAP_DENYWRITE, 3, 0x18000) = 0x7fa7a419a000
mmap(0x7fa7a419c000, 13616, PROT_READ|PROT_WRITE, MAP_PRIVATE|MAP_FIXED|MAP_ANONYMOUS, -1, 0) = 0x7fa7a419c000
close(3)                                = 0
access("/etc/ld.so.nohwcap", F_OK)      = -1 ENOENT (No such file or directory)
open("/lib/x86_64-linux-gnu/libgcc_s.so.1", O_RDONLY|O_CLOEXEC) = 3
read(3, "\177ELF\2\1\1\0\0\0\0\0\0\0\0\0\3\0&gt;\0\1\0\0\0\260*\0\0\0\0\0\0"..., 832) = 832
fstat(3, {st_mode=S_IFREG|0644, st_size=90160, ...}) = 0
mmap(NULL, 4096, PROT_READ|PROT_WRITE, MAP_PRIVATE|MAP_ANONYMOUS, -1, 0) = 0x7fa7a45a1000
mmap(NULL, 2186016, PROT_READ|PROT_EXEC, MAP_PRIVATE|MAP_DENYWRITE, 3, 0) = 0x7fa7a3d6c000
mprotect(0x7fa7a3d82000, 2093056, PROT_NONE) = 0
mmap(0x7fa7a3f81000, 4096, PROT_READ|PROT_WRITE, MAP_PRIVATE|MAP_FIXED|MAP_DENYWRITE, 3, 0x15000) = 0x7fa7a3f81000
close(3)                                = 0
access("/etc/ld.so.nohwcap", F_OK)      = -1 ENOENT (No such file or directory)
open("/lib/x86_64-linux-gnu/libc.so.6", O_RDONLY|O_CLOEXEC) = 3
read(3, "\177ELF\2\1\1\0\0\0\0\0\0\0\0\0\3\0&gt;\0\1\0\0\0P \2\0\0\0\0\0"..., 832) = 832
fstat(3, {st_mode=S_IFREG|0755, st_size=1840928, ...}) = 0
mmap(NULL, 3949248, PROT_READ|PROT_EXEC, MAP_PRIVATE|MAP_DENYWRITE, 3, 0) = 0x7fa7a39a7000
mprotect(0x7fa7a3b61000, 2097152, PROT_NONE) = 0
mmap(0x7fa7a3d61000, 24576, PROT_READ|PROT_WRITE, MAP_PRIVATE|MAP_FIXED|MAP_DENYWRITE, 3, 0x1ba000) = 0x7fa7a3d61000
mmap(0x7fa7a3d67000, 17088, PROT_READ|PROT_WRITE, MAP_PRIVATE|MAP_FIXED|MAP_ANONYMOUS, -1, 0) = 0x7fa7a3d67000
close(3)                                = 0
access("/etc/ld.so.nohwcap", F_OK)      = -1 ENOENT (No such file or directory)
open("/lib/x86_64-linux-gnu/libm.so.6", O_RDONLY|O_CLOEXEC) = 3
read(3, "\177ELF\2\1\1\0\0\0\0\0\0\0\0\0\3\0&gt;\0\1\0\0\0\20V\0\0\0\0\0\0"..., 832) = 832
fstat(3, {st_mode=S_IFREG|0644, st_size=1071552, ...}) = 0
mmap(NULL, 3166568, PROT_READ|PROT_EXEC, MAP_PRIVATE|MAP_DENYWRITE, 3, 0) = 0x7fa7a36a1000
mprotect(0x7fa7a37a6000, 2093056, PROT_NONE) = 0
mmap(0x7fa7a39a5000, 8192, PROT_READ|PROT_WRITE, MAP_PRIVATE|MAP_FIXED|MAP_DENYWRITE, 3, 0x104000) = 0x7fa7a39a5000
close(3)                                = 0
mmap(NULL, 4096, PROT_READ|PROT_WRITE, MAP_PRIVATE|MAP_ANONYMOUS, -1, 0) = 0x7fa7a45a0000
mmap(NULL, 8192, PROT_READ|PROT_WRITE, MAP_PRIVATE|MAP_ANONYMOUS, -1, 0) = 0x7fa7a459e000
arch_prctl(ARCH_SET_FS, 0x7fa7a459e840) = 0
mprotect(0x7fa7a3d61000, 16384, PROT_READ) = 0
mprotect(0x7fa7a39a5000, 4096, PROT_READ) = 0
mprotect(0x7fa7a419a000, 4096, PROT_READ) = 0
mprotect(0x7fa7a43a2000, 4096, PROT_READ) = 0
mprotect(0x7fa7a4820000, 16384, PROT_READ) = 0
mprotect(0x7fa7a45c6000, 4096, PROT_READ) = 0
munmap(0x7fa7a45a2000, 136983)          = 0
set_tid_address(0x7fa7a459eb10)         = 4457
set_robust_list(0x7fa7a459eb20, 24)     = 0
futex(0x7fff548a3e60, FUTEX_WAIT_BITSET_PRIVATE|FUTEX_CLOCK_REALTIME, 1, NULL, 7fa7a459e840) = -1 EAGAIN (Resource temporarily unavailable)
rt_sigaction(SIGRTMIN, {0x7fa7a3f889f0, [], SA_RESTORER|SA_SIGINFO, 0x7fa7a3f92330}, NULL, 8) = 0
rt_sigaction(SIGRT_1, {0x7fa7a3f88a80, [], SA_RESTORER|SA_RESTART|SA_SIGINFO, 0x7fa7a3f92330}, NULL, 8) = 0
rt_sigprocmask(SIG_UNBLOCK, [RTMIN RT_1], NULL, 8) = 0
getrlimit(RLIMIT_STACK, {rlim_cur=8192*1024, rlim_max=RLIM64_INFINITY}) = 0
readlink("/etc/malloc.conf", 0x7fff548a2e10, 4096) = -1 ENOENT (No such file or directory)
brk(0)                                  = 0x7fa7a50df000
mmap(NULL, 2097152, PROT_READ|PROT_WRITE, MAP_PRIVATE|MAP_ANONYMOUS, -1, 0) = 0x7fa7a34a1000
munmap(0x7fa7a34a1000, 2097152)         = 0
mmap(NULL, 4190208, PROT_READ|PROT_WRITE, MAP_PRIVATE|MAP_ANONYMOUS, -1, 0) = 0x7fa7a32a2000
munmap(0x7fa7a32a2000, 1433600)         = 0
munmap(0x7fa7a3600000, 659456)          = 0
open("/sys/devices/system/cpu/online", O_RDONLY|O_CLOEXEC) = 3
read(3, "0-3\n", 8192)                  = 4
close(3)                                = 0
rt_sigaction(SIGPIPE, {SIG_IGN, [PIPE], SA_RESTORER|SA_RESTART, 0x7fa7a39ddcb0}, {SIG_DFL, [], 0}, 8) = 0
mmap(NULL, 2097152, PROT_READ|PROT_WRITE, MAP_PRIVATE|MAP_ANONYMOUS, -1, 0) = 0x7fa7a3200000
open("/proc/self/maps", O_RDONLY|O_CLOEXEC) = 3
getrlimit(RLIMIT_STACK, {rlim_cur=8192*1024, rlim_max=RLIM64_INFINITY}) = 0
fstat(3, {st_mode=S_IFREG|0444, st_size=0, ...}) = 0
mmap(NULL, 4096, PROT_READ|PROT_WRITE, MAP_PRIVATE|MAP_ANONYMOUS, -1, 0) = 0x7fa7a45c3000
read(3, "7fa7a3200000-7fa7a3600000 rw-p 0"..., 1024) = 1024
read(3, "           /lib/x86_64-linux-gnu"..., 1024) = 1024
read(3, "000 08:01 7341019               "..., 1024) = 1024
read(3, "26000 rw-p 00000000 00:00 0 \n7ff"..., 1024) = 274
close(3)                                = 0
munmap(0x7fa7a45c3000, 4096)            = 0
sched_getaffinity(4457, 32, {f, 0, 0, 0}) = 32
mmap(0x7fff540a6000, 4096, PROT_NONE, MAP_PRIVATE|MAP_FIXED|MAP_ANONYMOUS, -1, 0) = 0x7fff540a6000
rt_sigaction(SIGSEGV, {0x7fa7a45d6960, [], SA_RESTORER|SA_STACK|SA_SIGINFO, 0x7fa7a3f92330}, NULL, 8) = 0
rt_sigaction(SIGBUS, {0x7fa7a45d6960, [], SA_RESTORER|SA_STACK|SA_SIGINFO, 0x7fa7a3f92330}, NULL, 8) = 0
sigaltstack(NULL, {ss_sp=0, ss_flags=SS_DISABLE, ss_size=0}) = 0
mmap(NULL, 8192, PROT_READ|PROT_WRITE, MAP_PRIVATE|MAP_ANONYMOUS, -1, 0) = 0x7fa7a45c2000
sigaltstack({ss_sp=0x7fa7a45c2000, ss_flags=0, ss_size=8192}, NULL) = 0
open("test.txt", O_WRONLY|O_CREAT|O_TRUNC|O_CLOEXEC, 0666) = 3
ioctl(3, FIOCLEX)                       = 0
write(3, "Hello, world!\n", 14)         = 14
write(1, "14 bytes written\n", 17)      = 17
close(3)                                = 0
write(1, "end of main\n", 12)           = 12
sigaltstack({ss_sp=0, ss_flags=SS_DISABLE, ss_size=8192}, NULL) = 0
munmap(0x7fa7a45c2000, 8192)            = 0
exit_group(0)                           = ?
+++ exited with 0 +++
</pre>

<p>Důležité jsou především tyto čtyři řádky:</p>

<pre>
open("test.txt", O_WRONLY|O_CREAT|O_TRUNC|O_CLOEXEC, 0666) = <strong>3</strong>
write(<strong>3</strong>, "Hello, world!\n", 14)         = 14
close(<strong>3</strong>)                                = 0
write(<strong>1</strong>, "end of main\n", 12)           = 12
</pre>

<p>Z&nbsp;nichž se dozvíme, že:</p>

<ol>
<li>Byl otevřen soubor s&nbsp;názvem &bdquo;test.txt&ldquo; a byl mu přiřazen deskriptor 3.</li>
<li>Do tohoto souboru byl zapsán řetězec o délce čtrnácti bajtů.</li>
<li>Soubor byl zavřen.</li>
<li><i>Teprve poté</i> se vypsala zpráva na standardní výstup (do deskriptoru číslo 1).</li>
</ol>



<p><a name="k07"></a></p>
<h2 id="k07">7. Přečtení jednoho řádku ze standardního vstupu</h2>

<p>Další užitečnou operací je přečtení jednoho textového řádku ze standardního
vstupu. Zde je situace velmi jednoduchá, neboť je možné použít metodu
<strong>read_line()</strong> struktury <strong>std::io::Stdin</strong>. Metodě
<strong>read_line()</strong> se předává reference na String, který musí být
pochopitelně měnitelný (mutable):</p>

<pre>
use std::io;
&nbsp;
fn main() {
    let stdin = <strong>io::stdin()</strong>;
    let mut line = String::new();
&nbsp;
    <strong>stdin.read_line</strong>(&amp;mut line);
&nbsp;
    println!("Echo: '{}' ({} characters)", line.trim(), line.len());
}
</pre>

<p>Poznámka: povšimněte si, že není nutné specifikovat maximální délku řetězce,
předalokovávat String atd. Vše se děje automaticky a především bezpečně, na
rozdíl od již zmíněné známé funkce <strong>gets()</strong>.</p>



<p><a name="k08"></a></p>
<h2 id="k08">8. Iterátor pro přečtení všech řádků ze standardního vstupu</h2>

<p>Pokud je nutné přečíst větší množství řádků ze standardního vstupu, je
většinou nejjednodušší s&nbsp;využitím metody <strong>lock()</strong> získat
exkluzivní přístup ke standardnímu vstupu. Předností je, že vrácený typ
implementuje trait <strong>BufRead</strong> a tím pádem i metodu
<strong>lines()</strong> vracející iterátor pro jednotlivé řádky přečtené ze
standardního vstupu. Řádky jsou vráceny bez \n na konci:</p>

<pre>
use std::io;
use std::io::BufRead;
&nbsp;
fn main() {
    let stdin = <strong>io::stdin()</strong>;
    let stdin_lock = <strong>stdin.lock()</strong>;
&nbsp;
    for line in <strong>stdin_lock.lines()</strong> {
        match line {
            Ok(content) =&gt; {
                println!("Echo: '{}' ({} characters)", content.trim(), content.len());
            }
            Err(error) =&gt; {
                println!("stdin read error: {}", error);
            }
        }
    }
}
</pre>



<p><a name="k09"></a></p>
<h2 id="k09">9. Zpracování textových souborů</h2>

<p>Prakticky stejným způsobem, jakým jsme četli jednotlivé textové řádky ze
standardního vstupu, je možné číst textové řádky z&nbsp;libovolného otevřeného
souboru. To je ukázáno v&nbsp;následujícím demonstračním příkladu, v&nbsp;němž
nejdříve provedeme pokus o otevření souboru metodou
<strong>File::open()</strong>:</p>

<pre>
match <strong>File::open("/etc/passwd")</strong> {
    Ok(fin) =&gt; {
        read_content(&amp;fin);
    }
    Err(error) =&gt; {
        println!("file open error: {}", error);
    }
}
</pre>

<p>Struktura <strong>File</strong> implementuje trait <strong>Read</strong>,
takže je možné provádět čtení po jednotlivých bajtech či po sekvenci bajtů,
ovšem pokud potřebujeme pracovat s&nbsp;celými textovými řádky, je nutné použít
bufferovaný vstup reprezentovaný strukturou typu <strong>BufReader</strong>.
Její získání je snadné:</p>

<pre>
let reader = <strong>BufReader::new(struktura_typu_File)</strong>;
</pre>

<p>Následně lze iteraci přes textové řádky provést následujícím způsobem:</p>

<pre>
for line in <strong>reader.lines()</strong> {
    match line {
        Ok(content) =&gt; {
            println!("{}", content);
        }
        Err(error) =&gt; {
            println!("stdin read error: {}", error);
        }
    }
}
</pre>

<p>Iterátor v&nbsp;tomto případě korektně skončí ve chvíli, kdy je dosaženo
konce souboru. Jinými slovy: neprovede se větev
<strong>Err(error)</strong>.</p>

<p>Celý zdrojový kód vypadá následovně:</p>

<pre>
use std::io::BufRead;
use std::io::BufReader;
use std::fs::File;
&nbsp;
fn read_content(fin: &amp;File) {
    let reader = <strong>BufReader::new(fin)</strong>;
&nbsp;
    for line in <strong>reader.lines()</strong> {
        match line {
            Ok(content) =&gt; {
                println!("{}", content);
            }
            Err(error) =&gt; {
                println!("stdin read error: {}", error);
            }
        }
    }
}
&nbsp;
fn main() {
    match <strong>File::open("/etc/passwd")</strong> {
        Ok(fin) =&gt; {
            read_content(&amp;fin);
        }
        Err(error) =&gt; {
            println!("file open error: {}", error);
        }
    }
}
</pre>



<p><a name="k10"></a></p>
<h2 id="k10">10. Repositář s&nbsp;demonstračními příklady</h2>

<p>Všechny dnes popisované demonstrační příklady byly, ostatně podobně jako ve
všech předchozích částech <a
href="https://www.root.cz/serialy/programovaci-jazyk-rust/">tohoto seriálu</a>,
uloženy do Git repositáře dostupného na adrese <a
href="https://github.com/tisnik/presentations">https://github.com/tisnik/presentations</a>.
Příklady si můžete v&nbsp;případě potřeby stáhnout i jednotlivě bez nutnosti
klonovat celý repositář:</p>

<table>
<tr><th>Příklad</th><th>Adresa</th></tr>
<tr><td>298_file_create_1.rs</td><td><a href="https://github.com/tisnik/presentations/blob/master/rust/298_file_create_1.rs">https://github.com/tisnik/presentations/blob/master/rust/298_file_create_1.rs</a></td></tr>
<tr><td>299_file_create_error_panic.rs</td><td><a href="https://github.com/tisnik/presentations/blob/master/rust/299_file_create_error_panic.rs">https://github.com/tisnik/presentations/blob/master/rust/299_file_create_error_panic.rs</a></td></tr>
<tr><td>300_file_create_2.rs</td><td><a href="https://github.com/tisnik/presentations/blob/master/rust/300_file_create_2.rs">https://github.com/tisnik/presentations/blob/master/rust/300_file_create_2.rs</a></td></tr>
<tr><td>301_file_create_error.rs</td><td><a href="https://github.com/tisnik/presentations/blob/master/rust/301_file_create_error.rs">https://github.com/tisnik/presentations/blob/master/rust/301_file_create_error.rs</a></td></tr>
<tr><td>302_when_file_is_closed.rs</td><td><a href="https://github.com/tisnik/presentations/blob/master/rust/302_when_file_is_closed.rs">https://github.com/tisnik/presentations/blob/master/rust/302_when_file_is_closed.rs</a></td></tr>
<tr><td>303_stdin.rs</td><td><a href="https://github.com/tisnik/presentations/blob/master/rust/303_stdin.rs">https://github.com/tisnik/presentations/blob/master/rust/303_stdin.rs</a></td></tr>
<tr><td>304_stdin_lock.rs</td><td><a href="https://github.com/tisnik/presentations/blob/master/rust/304_stdin_lock.rs">https://github.com/tisnik/presentations/blob/master/rust/304_stdin_lock.rs</a></td></tr>
<tr><td>305_file_open.rs</td><td><a href="https://github.com/tisnik/presentations/blob/master/rust/305_file_open.rs">https://github.com/tisnik/presentations/blob/master/rust/305_file_open.rs</a></td></tr>
</table>

<p>Překlad se provede příkazem:</p>

<pre>
rustc jméno_zdrojového_souboru.rs
</pre>



<p><a name="k11"></a></p>
<h2 id="k11">11. Odkazy na Internetu</h2>

<ol>

<li>Struct std::fs::File<br />
<a href="https://doc.rust-lang.org/std/fs/struct.File.html">https://doc.rust-lang.org/std/fs/struct.File.html</a>
</li>

<li>Trait std::io::Seek<br />
<a href="https://doc.rust-lang.org/std/io/trait.Seek.html">https://doc.rust-lang.org/std/io/trait.Seek.html</a>
</li>

<li>Trait std::io::Read<br />
<a href="https://doc.rust-lang.org/std/io/trait.Read.html">https://doc.rust-lang.org/std/io/trait.Read.html</a>
</li>

<li>Trait std::io::Write<br />
<a href="https://doc.rust-lang.org/std/io/trait.Write.html">https://doc.rust-lang.org/std/io/trait.Write.html</a>
</li>

<li>Trait std::io::BufRead<br />
<a href="https://doc.rust-lang.org/std/io/trait.BufRead.html">https://doc.rust-lang.org/std/io/trait.BufRead.html</a>
</li>

<li>Module std::io::prelude<br />
<a href="https://doc.rust-lang.org/std/io/prelude/index.html">https://doc.rust-lang.org/std/io/prelude/index.html</a>
</li>

<li>std::net::IpAddr<br />
<a href="https://doc.rust-lang.org/std/net/enum.IpAddr.html">https://doc.rust-lang.org/std/net/enum.IpAddr.html</a>
</li>

<li>std::net::Ipv4Addr<br />
<a href="https://doc.rust-lang.org/std/net/struct.Ipv4Addr.html">https://doc.rust-lang.org/std/net/struct.Ipv4Addr.html</a>
</li>

<li>std::net::Ipv6Addr<br />
<a href="https://doc.rust-lang.org/std/net/struct.Ipv6Addr.html">https://doc.rust-lang.org/std/net/struct.Ipv6Addr.html</a>
</li>

<li>TcpListener<br />
<a href="https://doc.rust-lang.org/std/net/struct.TcpListener.html">https://doc.rust-lang.org/std/net/struct.TcpListener.html</a>
</li>

<li>TcpStream<br />
<a href="https://doc.rust-lang.org/std/net/struct.TcpStream.html">https://doc.rust-lang.org/std/net/struct.TcpStream.html</a>
</li>

<li>Binary heap (Wikipedia)<br />
<a href="https://en.wikipedia.org/wiki/Binary_heap">https://en.wikipedia.org/wiki/Binary_heap</a>
</li>

<li>Binární halda (Wikipedia)<br />
<a href="https://cs.wikipedia.org/wiki/Bin%C3%A1rn%C3%AD_halda">https://cs.wikipedia.org/wiki/Bin%C3%A1rn%C3%AD_halda</a>
</li>

<li>Halda (datová struktura)<br />
<a href="https://cs.wikipedia.org/wiki/Halda_%28datov%C3%A1_struktura%29">https://cs.wikipedia.org/wiki/Halda_%28datov%C3%A1_struktura%29</a>
</li>

<li>Struct std::collections::HashSet<br />
<a href="https://doc.rust-lang.org/std/collections/struct.HashSet.html">https://doc.rust-lang.org/std/collections/struct.HashSet.html</a>
</li>

<li>Struct std::collections::BTreeSet<br />
<a href="https://doc.rust-lang.org/std/collections/struct.BTreeSet.html">https://doc.rust-lang.org/std/collections/struct.BTreeSet.html</a>
</li>

<li>Struct std::collections::BinaryHeap<br />
<a href="https://doc.rust-lang.org/std/collections/struct.BinaryHeap.html">https://doc.rust-lang.org/std/collections/struct.BinaryHeap.html</a>
</li>

<li>Set (abstract data type)<br />
<a href="https://en.wikipedia.org/wiki/Set_%28abstract_data_type%29#Language_support">https://en.wikipedia.org/wiki/Set_%28abstract_data_type%29#Language_support</a>
</li>

<li>Associative array<br />
<a href="https://en.wikipedia.org/wiki/Associative_array">https://en.wikipedia.org/wiki/Associative_array</a>
</li>

<li>Hash Table<br />
<a href="https://en.wikipedia.org/wiki/Hash_table">https://en.wikipedia.org/wiki/Hash_table</a>
</li>

<li>B-tree<br />
<a href="https://en.wikipedia.org/wiki/B-tree">https://en.wikipedia.org/wiki/B-tree</a>
</li>

<li>Pedro Celis: Robin Hood Hashing (naskenované PDF!)<br />
<a href="https://cs.uwaterloo.ca/research/tr/1986/CS-86-14.pdf">https://cs.uwaterloo.ca/research/tr/1986/CS-86-14.pdf</a>
</li>

<li>Robin Hood hashing<br />
<a href="http://codecapsule.com/2013/11/11/robin-hood-hashing/">http://codecapsule.com/2013/11/11/robin-hood-hashing/</a>
</li>

<li>Robin Hood hashing: backward shift deletion<br />
<a href="http://codecapsule.com/2013/11/17/robin-hood-hashing-backward-shift-deletion/">http://codecapsule.com/2013/11/17/robin-hood-hashing-backward-shift-deletion/</a>
</li>

<li>Module std::collections<br />
<a href="https://doc.rust-lang.org/std/collections/">https://doc.rust-lang.org/std/collections/</a>
</li>

<li>Module std::vec<br />
<a href="https://doc.rust-lang.org/nightly/std/vec/index.html">https://doc.rust-lang.org/nightly/std/vec/index.html</a>
</li>

<li>Struct std::collections::VecDeque<br />
<a href="https://doc.rust-lang.org/std/collections/struct.VecDeque.html">https://doc.rust-lang.org/std/collections/struct.VecDeque.html</a>
</li>

<li>Struct std::collections::LinkedList<br />
<a href="https://doc.rust-lang.org/std/collections/struct.LinkedList.html">https://doc.rust-lang.org/std/collections/struct.LinkedList.html</a>
</li>

<li>Module std::fmt<br />
<a href="https://doc.rust-lang.org/std/fmt/">https://doc.rust-lang.org/std/fmt/</a>
</li>

<li>Macro std::println<br />
<a href="https://doc.rust-lang.org/std/macro.println.html">https://doc.rust-lang.org/std/macro.println.html</a>
</li>

<li>Enum std::result::Result<br />
<a href="https://doc.rust-lang.org/std/result/enum.Result.html">https://doc.rust-lang.org/std/result/enum.Result.html</a>
</li>

<li>Module std::result<br />
<a href="https://doc.rust-lang.org/std/result/">https://doc.rust-lang.org/std/result/</a>
</li>

<li>Result<br />
<a href="http://rustbyexample.com/std/result.html">http://rustbyexample.com/std/result.html</a>
</li>

<li>Rust stdlib: Option<br />
<a href="https://doc.rust-lang.org/std/option/enum.Option.html">https://doc.rust-lang.org/std/option/enum.Option.html</a>
</li>

<li>Module std::option<br />
<a href="https://doc.rust-lang.org/std/option/index.html">https://doc.rust-lang.org/std/option/index.html</a>
</li>

<li>Rust by example: option<br />
<a href="http://rustbyexample.com/std/option.html">http://rustbyexample.com/std/option.html</a>
</li>

<li>Rust by example: if-let<br />
<a href="http://rustbyexample.com/flow_control/if_let.html">http://rustbyexample.com/flow_control/if_let.html</a>
</li>

<li>Rust by example: while let<br />
<a href="http://rustbyexample.com/flow_control/while_let.html">http://rustbyexample.com/flow_control/while_let.html</a>
</li>

<li>Rust by example: Option&lt;i32&gt;<br />
<a href="http://rustbyexample.com/std/option.html">http://rustbyexample.com/std/option.html</a>
</li>

<li>An Overview of Macros in Rust<br />
<a href="http://words.steveklabnik.com/an-overview-of-macros-in-rust">http://words.steveklabnik.com/an-overview-of-macros-in-rust</a>
</li>

<li>A Practical Intro to Macros in Rust 1.0<br />
<a href="https://danielkeep.github.io/practical-intro-to-macros.html">https://danielkeep.github.io/practical-intro-to-macros.html</a>
</li>

<li>The Rust Programming Language: macros<br />
<a href="https://doc.rust-lang.org/beta/book/macros.html">https://doc.rust-lang.org/beta/book/macros.html</a>
</li>

<li>Rust by example: 15 macro_rules!<br />
<a href="http://rustbyexample.com/macros.html">http://rustbyexample.com/macros.html</a>
</li>

<li>Primitive Type isize<br />
<a href="https://doc.rust-lang.org/nightly/std/primitive.isize.html">https://doc.rust-lang.org/nightly/std/primitive.isize.html</a>
</li>

<li>Primitive Type usize<br />
<a href="https://doc.rust-lang.org/nightly/std/primitive.usize.html">https://doc.rust-lang.org/nightly/std/primitive.usize.html</a>
</li>

<li>Primitive Type array<br />
<a href="https://doc.rust-lang.org/nightly/std/primitive.array.html">https://doc.rust-lang.org/nightly/std/primitive.array.html</a>
</li>

<li>Module std::slice<br />
<a href="https://doc.rust-lang.org/nightly/std/slice/">https://doc.rust-lang.org/nightly/std/slice/</a>
</li>

<li>Rust by Example: 2.3 Arrays and Slices<br />
<a href="http://rustbyexample.com/primitives/array.html">http://rustbyexample.com/primitives/array.html</a>
</li>

<li>What is the difference between Slice and Array (stackoverflow)<br />
<a href="http://stackoverflow.com/questions/30794235/what-is-the-difference-between-slice-and-array">http://stackoverflow.com/questions/30794235/what-is-the-difference-between-slice-and-array</a>
</li>

<li>Learning Rust With Entirely Too Many Linked Lists<br />
<a href="http://cglab.ca/~abeinges/blah/too-many-lists/book/">http://cglab.ca/~abeinges/blah/too-many-lists/book/</a>
</li>

<li>Testcase: linked list<br />
<a href="http://rustbyexample.com/custom_types/enum/testcase_linked_list.html">http://rustbyexample.com/custom_types/enum/testcase_linked_list.html</a>
</li>

<li>Operators and Overloading<br />
<a href="https://doc.rust-lang.org/book/operators-and-overloading.html">https://doc.rust-lang.org/book/operators-and-overloading.html</a>
</li>

<li>Module std::ops<br />
<a href="https://doc.rust-lang.org/std/ops/index.html">https://doc.rust-lang.org/std/ops/index.html</a>
</li>

<li>Module std::cmp<br />
<a href="https://doc.rust-lang.org/std/cmp/index.html">https://doc.rust-lang.org/std/cmp/index.html</a>
</li>

<li>Trait std::ops::Add<br />
<a href="https://doc.rust-lang.org/stable/std/ops/trait.Add.html">https://doc.rust-lang.org/stable/std/ops/trait.Add.html</a>
</li>

<li>Trait std::ops::AddAssign<br />
<a href="https://doc.rust-lang.org/std/ops/trait.AddAssign.html">https://doc.rust-lang.org/std/ops/trait.AddAssign.html</a>
</li>

<li>Trait std::ops::Drop<br />
<a href="https://doc.rust-lang.org/std/ops/trait.Drop.html">https://doc.rust-lang.org/std/ops/trait.Drop.html</a>
</li>

<li>Trait std::cmp::Eq<br />
<a href="https://doc.rust-lang.org/std/cmp/trait.Eq.html">https://doc.rust-lang.org/std/cmp/trait.Eq.html</a>
</li>

<li>Struct std::boxed::Box<br />
<a href="https://doc.rust-lang.org/std/boxed/struct.Box.html">https://doc.rust-lang.org/std/boxed/struct.Box.html</a>
</li>

<li>Explore the ownership system in Rust<br />
<a href="https://nercury.github.io/rust/guide/2015/01/19/ownership.html">https://nercury.github.io/rust/guide/2015/01/19/ownership.html</a>
</li>

<li>Rust's ownership and move semantic<br/>
<a href="http://www.slideshare.net/saneyuki/rusts-ownership-and-move-semantics">http://www.slideshare.net/saneyuki/rusts-ownership-and-move-semantics</a>
</li>

<li>Trait std::marker::Copy<br/>
<a href="https://doc.rust-lang.org/stable/std/marker/trait.Copy.html">https://doc.rust-lang.org/stable/std/marker/trait.Copy.html</a>
</li>

<li>Trait std::clone::Clone<br />
<a href="https://doc.rust-lang.org/stable/std/clone/trait.Clone.html">https://doc.rust-lang.org/stable/std/clone/trait.Clone.html</a>
</li>

<li>The Stack and the Heap<br />
<a href="https://doc.rust-lang.org/book/the-stack-and-the-heap.html">https://doc.rust-lang.org/book/the-stack-and-the-heap.html</a>
</li>

<li>Rust Compare: Pointers &amp; References<br />
<a href="http://www.rust-compare.com/site/pointers.html">http://www.rust-compare.com/site/pointers.html</a>
</li>

<li>Rust Compare: Parameters<br />
<a href="http://www.rust-compare.com/site/params.html">http://www.rust-compare.com/site/params.html</a>
</li>

<li>Why does this compile? Automatic dereferencing?<br />
<a href="https://users.rust-lang.org/t/why-does-this-compile-automatic-dereferencing/2183">https://users.rust-lang.org/t/why-does-this-compile-automatic-dereferencing/2183</a>
</li>

<li>Understanding Pointers, Ownership, and Lifetimes in Rust<br />
<a href="http://koerbitz.me/posts/Understanding-Pointers-Ownership-and-Lifetimes-in-Rust.html">http://koerbitz.me/posts/Understanding-Pointers-Ownership-and-Lifetimes-in-Rust.html</a>
</li>

<li>Rust lang series episode #25 — pointers (#rust-series)<br />
<a href="https://steemit.com/rust-series/@jimmco/rust-lang-series-episode-25-pointers-rust-series">https://steemit.com/rust-series/@jimmco/rust-lang-series-episode-25-pointers-rust-series</a>
</li>

<li>Rust - home page<br />
<a href="https://www.rust-lang.org/en-US/">https://www.rust-lang.org/en-US/</a>
</li>

<li>Rust - Frequently Asked Questions<br />
<a href="https://www.rust-lang.org/en-US/faq.html">https://www.rust-lang.org/en-US/faq.html</a>
</li>

<li>Destructuring and Pattern Matching<br />
<a href="https://pzol.github.io/getting_rusty/posts/20140417_destructuring_in_rust/">https://pzol.github.io/getting_rusty/posts/20140417_destructuring_in_rust/</a>
</li>

<li>The Rust Programming Language<br />
<a href="https://doc.rust-lang.org/book/">https://doc.rust-lang.org/book/</a>
</li>

<li>Rust (programming language)<br />
<a href="https://en.wikipedia.org/wiki/Rust_%28programming_language%29">https://en.wikipedia.org/wiki/Rust_%28programming_language%29</a>
</li>

<li>Go - home page<br />
<a href="https://golang.org/">https://golang.org/</a>
</li>

<li>Stack Overflow - Most Loved, Dreaded, and Wanted language<br />
<a href="https://stackoverflow.com/research/developer-survey-2016#technology-most-loved-dreaded-and-wanted">https://stackoverflow.com/research/developer-survey-2016#technology-most-loved-dreaded-and-wanted</a>
</li>

<li>Rust vs Go (dva roky staré hodnocení, od té doby došlo k posunům v obou jazycích)<br />
<a href="http://jaredforsyth.com/2014/03/22/rust-vs-go/">http://jaredforsyth.com/2014/03/22/rust-vs-go/</a>
</li>

<li>Rust vs Go: My experience<br />
<a href="https://www.reddit.com/r/golang/comments/21m6jq/rust_vs_go_my_experience/">https://www.reddit.com/r/golang/comments/21m6jq/rust_vs_go_my_experience/</a>
</li>

<li>Friends of Rust (Organizations running Rust in production)<br />
<a href="https://www.rust-lang.org/en-US/friends.html">https://www.rust-lang.org/en-US/friends.html</a>
</li>

<li>Rust programs versus C++ g++<br />
<a href="https://benchmarksgame.alioth.debian.org/u64q/compare.php?lang=rust&lang2=gpp">https://benchmarksgame.alioth.debian.org/u64q/compare.php?lang=rust&lang2=gpp</a>
</li>

<li>Další benchmarky (nejedná se o reálné příklady &bdquo;ze života&ldquo;)<br />
<a href="https://github.com/kostya/benchmarks">https://github.com/kostya/benchmarks</a>
</li>

<li>Go na Redditu<br />
<a href="https://www.reddit.com/r/golang/">https://www.reddit.com/r/golang/</a>
</li>

<li>Rust vs. Go<br />
<a href="http://vschart.com/compare/rust/vs/go-language">http://vschart.com/compare/rust/vs/go-language</a>
</li>

<li>Abstraction without overhead: traits in Rust<br />
<a href="https://blog.rust-lang.org/2015/05/11/traits.html">https://blog.rust-lang.org/2015/05/11/traits.html</a>
</li>

<li>Method Syntax<br />
<a href="https://doc.rust-lang.org/book/method-syntax.html">https://doc.rust-lang.org/book/method-syntax.html</a>
</li>

<li>Traits in Rust<br />
<a href="https://doc.rust-lang.org/book/traits.html">https://doc.rust-lang.org/book/traits.html</a>
</li>

<li>Functional Programming in Rust - Part 1 : Function Abstraction<br />
<a href="http://blog.madhukaraphatak.com/functional-programming-in-rust-part-1/">http://blog.madhukaraphatak.com/functional-programming-in-rust-part-1/</a>
</li>

<li>Of the emerging systems languages Rust, D, Go and Nim, which is the strongest language and why?<br />
<a href="https://www.quora.com/Of-the-emerging-systems-languages-Rust-D-Go-and-Nim-which-is-the-strongest-language-and-why">https://www.quora.com/Of-the-emerging-systems-languages-Rust-D-Go-and-Nim-which-is-the-strongest-language-and-why</a>
</li>

<li>Chytré ukazatele (moderní verze jazyka C++) [MSDN]<br />
<a href="https://msdn.microsoft.com/cs-cz/library/hh279674.aspx">https://msdn.microsoft.com/cs-cz/library/hh279674.aspx</a>
</li>

<li>UTF-8 Everywhere<br />
<a href="http://utf8everywhere.org/">http://utf8everywhere.org/</a>
</li>

<li>Rust by Example<br />
<a href="http://rustbyexample.com/">http://rustbyexample.com/</a>
</li>

<li>Rust oficiálně ve Fedoře<br />
<a href="https://mojefedora.cz/rust-oficialne-ve-fedore/">https://mojefedora.cz/rust-oficialne-ve-fedore/</a>
</li>

<li>Resource acquisition is initialization<br />
<a href="https://en.wikipedia.org/wiki/Resource_acquisition_is_initialization">https://en.wikipedia.org/wiki/Resource_acquisition_is_initialization</a>
</li>

<li>TIOBE index (October 2016)<br />
<a href="http://www.tiobe.com/tiobe-index/">http://www.tiobe.com/tiobe-index/</a>
</li>

<li>Porovnání Go, D a Rustu na OpenHubu:<br />
<a href="https://www.openhub.net/languages/compare?language_name[]=-1&language_name[]=-1&language_name[]=dmd&language_name[]=golang&language_name[]=rust&language_name[]=-1&measure=commits">https://www.openhub.net/languages/compare?language_name[]=-1&language_name[]=-1&language_name[]=dmd&language_name[]=golang&language_name[]=rust&language_name[]=-1&measure=commits</a>
</li>

<li>String Types in Rust<br />
<a href="http://www.suspectsemantics.com/blog/2016/03/27/string-types-in-rust/">http://www.suspectsemantics.com/blog/2016/03/27/string-types-in-rust/</a>
</li>

<li>Trait (computer programming)<br />
<a href="https://en.wikipedia.org/wiki/Trait_%28computer_programming%29">https://en.wikipedia.org/wiki/Trait_%28computer_programming%29</a>
</li>

<li>Type inference<br />
<a href="https://en.wikipedia.org/wiki/Type_inference">https://en.wikipedia.org/wiki/Type_inference</a>
</li>

</ol>



<p></p><p></p>
<p><small>Autor: <a href="http://www.fit.vutbr.cz/~tisnovpa">Pavel Tišnovský</a> &nbsp; 2017</small></p>
</body>
</html>

