<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
        "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html>
<head>
<title>Úpravy Emacsu a tvorba nových modulů s využitím Emacs Lispu</title>
<meta name="Author" content="Pavel Tisnovsky" />
<meta name="Generator" content="vim" />
<meta http-equiv="content-type" content="text/html; charset=utf-8" />
<style type="text/css">
         body {color:#000000; background:#ffffff;}
         h1  {font-family: arial, helvetica, sans-serif; color:#ffffff; background-color:#c00000; text-align:center; padding-left:1em}
         h2  {font-family: arial, helvetica, sans-serif; color:#ffffff; background-color:#0000c0; padding-left:1em; text-align:left}
         h3  {font-family: arial, helvetica, sans-serif; color:#000000; background-color:#c0c0c0; padding-left:1em; text-align:left}
         h4  {font-family: arial, helvetica, sans-serif; color:#000000; background-color:#e0e0e0; padding-left:1em; text-align:left}
         a   {font-family: arial, helvetica, sans-serif;}
         li  {font-family: arial, helvetica, sans-serif; color:#000000; text-align:justify; width:450px;}
         ol  {font-family: arial, helvetica, sans-serif; color:#000000; text-align:justify; width:450px;}
         ul  {font-family: arial, helvetica, sans-serif; color:#000000; text-align:justify; width:450px;}
         p   {font-family: arial, helvetica, sans-serif; color:#000000; text-align:justify;}
         pre {background:#e0e0e0}
</style>
</head>

<body>

<h1>Úpravy Emacsu a tvorba nových modulů s využitím Emacs Lispu</h1>

<h3>Pavel Tišnovský</h3>

<p></p>

<h1>Úvodník</h1>

<p>Na předchozí článek, v&nbsp;němž jsme se seznámili se základními vlastnostmi režimu Evil, dnes nepřímo navážeme. Ukážeme si, jakým způsobem je možné měnit chování Emacsu, a to pomocí funkcí naprogramovaných v&nbsp;Emacs Lispu. Napřed si ovšem popíšeme základní vlastnosti tohoto jazyka.</p>



<h2>Obsah</h2>

<p><a href="#k01">1. Úpravy Emacsu a tvorba nových modulů s&nbsp;využitím Emacs Lispu</a></p>
<p><a href="#k02">2. LISP aneb jazyk, který nám nepřinesl AI</a></p>
<p><a href="#k03">3. Rozdíly mezi různými dialekty programovacího jazyka LISP</a></p>
<p><a href="#k04">4. Je Emacs Lisp funkcionálním jazykem?</a></p>
<p><a href="#k05">5. Základní nastavení Emacsu při zkoušení možností Emacs LISPu</a></p>
<p><a href="#k06">6. Scratch buffer ve funkci REPLu</a></p>
<p><a href="#k07">7. Spouštění příkladů naprogramovaných v&nbsp;Elispu z&nbsp;příkazového řádku</a></p>
<p><a href="#k08">8. Základní datové typy Elispu</a></p>
<p><a href="#k09">9. Prázdný seznam a rekurzivní datové struktury založené na seznamech</a></p>
<p><a href="#k10">10. Tečka-dvojice: základ pro tvorbu složitějších datových struktur</a></p>
<p><a href="#k11">11. Základní funkce pro konstrukci seznamů a pro přístup k&nbsp;prvkům seznamů</a></p>
<p><a href="#k12">12. Definice vlastních funkcí</a></p>
<p><a href="#k13">13. Funkce s&nbsp;nepovinnými parametry</a></p>
<p><a href="#k14">14. Funkce vyššího řádu</a></p>
<p><a href="#k15">15. Anonymní funkce</a></p>
<p><a href="#k16">16. Výpočet faktoriálu realizovaný funkcí vyššího řádu</a></p>
<p><a href="#k17">17. Repositář s&nbsp;demonstračními příklady</a></p>
<p><a href="#k18">18. Guile Emacs</a></p>
<p><a href="#k19">19. Literatura</a></p>
<p><a href="#k20">20. Odkazy na Internetu</a></p>



<p><a name="k01"></a></p>
<h2 id="k01">1. Úpravy Emacsu a tvorba nových modulů s&nbsp;využitím Emacs Lispu</h2>



<p><a name="k02"></a></p>
<h2 id="k02">2. LISP aneb jazyk, který nám nepřinesl AI</h2>

<p><a href="http://imgs.xkcd.com/comics/lisp_cycles.png">Syntaxe jazyka LISP je již po 50 let zdrojem inspirace pro autory vtipů</a></p>



<p><a name="k03"></a></p>
<h2 id="k03">3. Rozdíly mezi různými dialekty programovacího jazyka LISP</h2>



<p><a name="k04"></a></p>
<h2 id="k04">4. Je Emacs Lisp funkcionálním jazykem?</h2>



<p><a name="k05"></a></p>
<h2 id="k05">5. Základní nastavení Emacsu při zkoušení možností Emacs LISPu</h2>



<p><a name="k06"></a></p>
<h2 id="k06">6. Scratch buffer ve funkci REPLu</h2>



<p><a name="k07"></a></p>
<h2 id="k07">7. Spouštění příkladů naprogramovaných v&nbsp;Elispu z&nbsp;příkazového řádku</h2>



<p><a name="k08"></a></p>
<h2 id="k08">8. Základní datové typy Elispu</h2>



<p><a name="k09"></a></p>
<h2 id="k09">9. Prázdný seznam a rekurzivní datové struktury založené na seznamech</h2>




<p><a name="k10"></a></p>
<h2 id="k10">10. Tečka-dvojice: základ pro tvorbu složitějších datových struktur</h2>



<p><a name="k11"></a></p>
<h2 id="k11">11. Základní funkce pro konstrukci seznamů a pro přístup k&nbsp;prvkům seznamů</h2>



<p><a name="k12"></a></p>
<h2 id="k12">12. Definice vlastních funkcí</h2>



<p><a name="k13"></a></p>
<h2 id="k13">13. Funkce s&nbsp;nepovinnými parametry</h2>

<p>V&nbsp;Elispu se můžeme setkat s&nbsp;velkým množstvím funkcí, které mají
nepovinné parametry. Tyto parametry jsou od parametrů povinných odděleny pomocí
klauzule <strong>&amp;optional</strong>. Příkladem může být funkce pro součet
dvou nebo tří číselných hodnot (samozřejmě se jedná o dosti umělý příklad):</p>

<pre>
(defun add3
  (x y &amp;optional z)
  (if z
    (+ x y z)
    (+ x y)))
</pre>

<p>Funkci si můžeme vyzkoušet:</p>

<pre>
<strong>(add3 1 2 3)</strong>
6
&nbsp;
<strong>(add3 1 2)</strong>
3
&nbsp;
<strong>(add3 1)</strong>
Wrong number of arguments: (lambda (x y &amp;optional z) (if z (+ x y z) (+ x y))), 1
</pre>

<p>V&nbsp;posledním příkladu je ukázáno, že první dva parametry jsou skutečně
povinné.</p>



<p><a name="k14"></a></p>
<h2 id="k14">14. Funkce vyššího řádu</h2>

<p>Funkce jsou plnoprávnými datovými typy, takže je lze přiřadit do proměnné
atd. V&nbsp;Elispu pouze nastává jeden problém, protože interně jsou ke každému
symbolu (například ke jménu funkce) přiřazeny čtyři komponenty (nazývané
<i>cells</i>):</p>

<ol>
<li>Jméno symbolu tak, jak je zobrazeno uživateli</li>
<li>Hodnota (pokud se symbol používá jako proměnná)</li>
<li>Funkce</li>
<li>Seznam vlastností (property list) popsaný příště</li>
</ol>

<p>Proto je nutné rozlišovat mezi hodnotou a funkcí. Jsou možné dvě řešení:</p>

<pre>
(defun add (x y) (+ x y))
&nbsp;
(setq soucet 'add)
&nbsp;
(funcall soucet 10 20)
</pre>

<p>Druhé řešení pracuje přímo s&nbsp;funkcí, ovšem namísto
<strong>setq</strong> používá <strong>fset</strong>:</p>

<pre>
(fset 'soucet2 'add)
&nbsp;
(soucet2 100 200)
</pre>

<p>Toto je hlavní rozdíl mezi Elispem a mnoha ostatními dialekty Lispu a bude
vám možná zpočátku způsobovat problémy.</p>

<p><i>Elisp</i> sice není, na rozdíl od Haskellu a částečně i Clojure, čistě
funkcionální jazyk, nicméně i zde hrají při vývoji aplikací velkou roli funkce
vyššího řádu, tj.&nbsp;funkce, které jako své parametry akceptují jiné funkce
popř.&nbsp;dokonce vrací (nové) funkce jako svoji návratovou hodnotu. Mezi dvě
základní funkce vyššího řádu, které nalezneme prakticky ve všech dialektech
programovacího jazyka Lisp, patří funkce nazvané <strong>mapcar</strong> a
taktéž <strong>apply</strong>. Funkce <strong>mapcar</strong> jako svůj první
parametr akceptuje jinou funkci (s&nbsp;jedním parametrem) a druhým parametrem
musí být seznam. <strong>mapcar</strong> postupně aplikuje předanou funkci na
jednotlivé prvky seznamu a vytváří tak seznam nový (modifikovaný). Podívejme se
na jednoduchý příklad &ndash; aplikace funkce pro zvýšení hodnoty o jedničku na
seznam:</p>

<pre>
; regular function
(defun inc
  (x)
  (+ x 1)) 
&nbsp;
<i>; use inc in higher order function</i>
<strong>(print (mapcar 'inc '(1 2 3)))</strong>
(2 3 4)
</pre>

<p>Funkce <strong>apply</strong> se chová poněkud odlišně &ndash; aplikuje
totiž nějakou funkci (svůj první parametr) na předaný seznam. Typický
&bdquo;školní&ldquo; příklad s&nbsp;binární funkcí + (tj.&nbsp;funkcí se dvěma
parametry) může vypadat následovně:</p>

<pre>
<i>; use + in higher order function</i>
<strong>(print (apply '+ '(1 2 3 4)))</strong>
10
</pre>

<p>Podobně je tomu například u funkce *:</p>

<pre>
<i>; use * in higher order function</i>
<strong>(print (apply '* (number-sequence 1 6)))</strong>
720
</pre>

<p>Poslední zajímavou funkcí je <strong>cl-reduce</strong>, která postupně
zpracovává prvky předaného seznamu a pomocí akumulátoru tvoří výslednou
hodnotu:</p>

<pre>
(require 'cl-lib)
&nbsp;
(defun add
  (x y)
  (+ x y))
&nbsp;
; use add in higher order function reduce
(print (cl-reduce 'add '(1 2 3 4)))
&nbsp;
</pre>



<p><a name="k15"></a></p>
<h2 id="k15">15. Anonymní funkce</h2>

<p>Kromě pojmenovaných funkcí, které jsme si již představili v&nbsp;předchozích
kapitolách, je možné v&nbsp;<i>Elispu</i> použít i funkce anonymní,
tj.&nbsp;funkce, které nejsou navázány na žádné jméno. Pro tento účel se
používá lambda výraz, podobně jako v&nbsp;každém ortodoxním Lispu (kromě
PicoLispu). Podívejme se na typický příklad &ndash; budeme chtít ze vstupního
seznamu vytvořit výstupní seznam s&nbsp;hodnotami o jedničku zvýšenými. Pro
něco tak jednoduchého asi nemá smysl si vytvářet novou pojmenovanou funkci, ale
použijeme přímo funkci anonymní:</p>

<pre>
<i>; anonymous function used in higher order function</i>
<strong>(print (mapcar (lambda (x) (+ x 1) ) '(1 2 3 4)))</strong>
10
</pre>

<p>Zajímá vás řada n<sup>2</sup>?:</p>

<pre>
<i>; anonymous function used in higher order function</i>
<strong>(print (mapcar (lambda (x) (* x x)) (number-sequence 1 10)) )</strong>
(1 4 9 16 25 36 49 64 81 100)
</pre>



<p><a name="k16"></a></p>
<h2 id="k16">16. Výpočet faktoriálu realizovaný funkcí vyššího řádu</h2>

<p>Funkce vyššího řádu lze použít i pro přepis výpočtu faktoriálu. Ten lze
přepsat s&nbsp;využitím funkce <strong>apply</strong> a taktéž generátoru
sekvence čísel <strong>number-sequence</strong> (ten zhruba odpovídá
Pythonovskému <strong>range</strong>, ovšem generuje se i poslední mezní
hodnota):</p>

<pre>
; higher order function in other (regular) function
(defun factorial
  (n)
  (apply '* (number-sequence 1 n)))
</pre>

<p>Otestování je snadné:</p>

<pre>
(print (factorial 10))
</pre>

<p>Samozřejmě si můžeme vypsat sekvenci faktoriálu pro vstupní hodnoty n=1, n=2
atd.:</p>

<pre>
<i>; anonymous function used in higher order function</i>
<strong>(print (mapcar 'factorial (number-sequence 0 10)))</strong>
(1 1 2 6 24 120 720 5040 40320 362880 3628800)
</pre>

<p>Nebo celý výpočet napsat na jediný řádek s&nbsp;využitím dvou funkcí vyššího
řádu a jedné anonymní funkce:</p>

<pre>
<i>; anonymous function used in higher order function</i>
<strong>(print (mapcar (lambda (n) (apply '* (number-sequence 1 n) )) (number-sequence 1 10)) )</strong>
(1 2 6 24 120 720 5040 40320 362880 3628800)
</pre>



<p><a name="k17"></a></p>
<h2 id="k17">17. Repositář s&nbsp;demonstračními příklady</h2>

<p>Zdrojové kódy většiny dnes popsaných demonstračních příkladů byly uloženy do
Git repositáře dostupného na adrese <a
href="https://github.com/tisnik/elisp-examples">https://github.com/tisnik/elisp-examples</a>
(stále na GitHubu :-). V&nbsp;případě, že nebudete chtít klonovat celý
repositář (ten je ovšem stále velmi malý, dnes má doslova několik kilobajtů),
můžete namísto toho použít odkazy na jednotlivé příklady, které naleznete
v&nbsp;následující tabulce:</p>

<table>
<tr><th> #</th><th>Demonstrační příklad</th><th>Popis</th><th>Cesta</th></tr>
<tr><td> 1</td><td>01_hello_world.el</td><td>nejprimitivnější příklad &ndash; &bdquo;hello world&ldquo;</td><td><a href="https://github.com/tisnik/elisp-examples/blob/master/elisp-1/01_hello_world.el">https://github.com/tisnik/elisp-examples/blob/master/elisp-1/01_hello_world.el</a></td></tr>
<tr><td> 2</td><td>02_cl-loop.el</td><td>programová smyčka převzatá z&nbsp;Common Lispu</td><td><a href="https://github.com/tisnik/elisp-examples/blob/master/elisp-1/02_cl-loop.el">https://github.com/tisnik/elisp-examples/blob/master/elisp-1/02_cl-loop.el</a></td></tr>
<tr><td> 3</td><td>03_while_loop_A.el</td><td>programová smyčka while</td><td><a href="https://github.com/tisnik/elisp-examples/blob/master/elisp-1/03_while_loop_A.el">https://github.com/tisnik/elisp-examples/blob/master/elisp-1/03_while_loop_A.el</a></td></tr>
<tr><td> 4</td><td>04_while_loop_B.el</td><td>programová smyčka while</td><td><a href="https://github.com/tisnik/elisp-examples/blob/master/elisp-1/04_while_loop_B.el">https://github.com/tisnik/elisp-examples/blob/master/elisp-1/04_while_loop_B.el</a></td></tr>
<tr><td> 5</td><td>05_factorial.el</td><td>rekurzivní výpočet faktoriálu</td><td><a href="https://github.com/tisnik/elisp-examples/blob/master/elisp-1/05_factorial.el">https://github.com/tisnik/elisp-examples/blob/master/elisp-1/05_factorial.el</a></td></tr>
<tr><td> 6</td><td>06_map_C-j.el</td><td>mapování klávesy C-j</td><td><a href="https://github.com/tisnik/elisp-examples/blob/master/elisp-1/06_map_C-j.el">https://github.com/tisnik/elisp-examples/blob/master/elisp-1/06_map_C-j.el</a></td></tr>
<tr><td> 7</td><td>07_map_RET.el</td><td>mapování klávesy Return/Enter</td><td><a href="https://github.com/tisnik/elisp-examples/blob/master/elisp-1/07_map_RET.el">https://github.com/tisnik/elisp-examples/blob/master/elisp-1/07_map_RET.el</a></td></tr>
<tr><td> 8</td><td>08_dot_pairs.el</td><td>tečka-dvojice</td><td><a href="https://github.com/tisnik/elisp-examples/blob/master/elisp-1/08_dot_pairs.el">https://github.com/tisnik/elisp-examples/blob/master/elisp-1/08_dot_pairs.el</a></td></tr>
<tr><td> 9</td><td>09_cons.el</td><td>konstrukce tečka-dvojic</td><td><a href="https://github.com/tisnik/elisp-examples/blob/master/elisp-1/09_cons.el">https://github.com/tisnik/elisp-examples/blob/master/elisp-1/09_cons.el</a></td></tr>
<tr><td>10</td><td>10_lists.el</td><td>práce se seznamy</td><td><a href="https://github.com/tisnik/elisp-examples/blob/master/elisp-1/10_lists.el">https://github.com/tisnik/elisp-examples/blob/master/elisp-1/10_lists.el</a></td></tr>
<tr><td>11</td><td>11_functions.el</td><td>definice vlastních funkcí</td><td><a href="https://github.com/tisnik/elisp-examples/blob/master/elisp-1/11_functions.el">https://github.com/tisnik/elisp-examples/blob/master/elisp-1/11_functions.el</a></td></tr>
<tr><td>12</td><td>12_higher_order_functions.el</td><td>ukázka funkcí vyššího řádu</td><td><a href="https://github.com/tisnik/elisp-examples/blob/master/elisp-1/12_higher_order_functions.el">https://github.com/tisnik/elisp-examples/blob/master/elisp-1/12_higher_order_functions.el</a></td></tr>
<tr><td>13</td><td>13_anonymous_functions.el</td><td>anonymní funkce (lambda)</td><td><a href="https://github.com/tisnik/elisp-examples/blob/master/elisp-1/13_anonymous_functions.el">https://github.com/tisnik/elisp-examples/blob/master/elisp-1/13_anonymous_functions.el</a></td></tr>
<tr><td>14</td><td>14_factorial_B.el</td><td>přímý výpočet faktoriálu</td><td><a href="https://github.com/tisnik/elisp-examples/blob/master/elisp-1/14_factorial_B.el">https://github.com/tisnik/elisp-examples/blob/master/elisp-1/14_factorial_B.el</a></td></tr>
<tr><td>15</td><td>15_factorial_C.el</td><td>funkce pro výpočet faktoriálu založená na funkcích vyššího řádu</td><td><a href="https://github.com/tisnik/elisp-examples/blob/master/elisp-1/15_factorial_C.el">https://github.com/tisnik/elisp-examples/blob/master/elisp-1/15_factorial_C.el</a></td></tr>
</table>

<p>Všechny příklady se mohou spouštět z&nbsp;příkazové řádky následujícím
způsobem:</p>

<pre>
emacs --script priklad1.el
</pre>



<p><a name="k18"></a></p>
<h2 id="k18">18. Guile Emacs</h2>

<p>Pro zajímavost se v&nbsp;dnešním článku musíme zmínit o projektu nazvaném
<i>Guile Emacs</i>. Název tohoto projektu může být poněkud matoucí, protože se
ve skutečnosti <i>nejedná</i> o snahu nahradit Emacs Lisp jazykem Scheme
(resp.&nbsp;jeho konkrétní implementací pojmenovanou GNU Guile), ale o
zajištění, aby byly zdrojové kódy napsané v&nbsp;Elispu překládány stejným
způsobem (podobným překladačem), jako je tomu v&nbsp;případě Guile. Výsledkem
by měl být rychlejší běh jak samotného Emacsu, tak i jeho modulů, což může být
zajímavé pro rozsáhlejší moduly typu <i>org-mode</i>, webového prohlížeče atd.
Navíc se díky použití překladače Guile otevírá možnost rozšíření možností
samotného Elispu o vlastnosti podporované v&nbsp;Guile. Dále by mělo být možné
psát moduly buď v&nbsp;Elispu nebo přímo v&nbsp;Guile (které je sice taktéž
založeno na LISPovském dialektu, ale jedná se o matematicky čistější
implementaci, což některým programátorům může vyhovovat). Bližší informace o
tomto projektu je možné nalézt na <a
href="https://www.emacswiki.org/emacs/SiteMap">EmacsWiki</a>, konkrétně na
stránce <a
href="https://www.emacswiki.org/emacs/GuileEmacs">https://www.emacswiki.org/emacs/GuileEmacs</a>.</p>

<p><div class="rs-tip-major">Poznámka: Guile znamená &bdquo;GNU Ubiquitous
Intelligent Language for Extensions&ldquo;, takže plné jméno &bdquo;GNU
Guile&ldquo; vlastně obsahuje &bdquo;GNU&ldquo; hned dvakrát. Navíc je GNU
rekurzivní zkratka znamenající &bdquo;GNU's Not Unix!&ldquo;, takže je zde
poněkud přepakoňováno.</div></p>



<p><a name="k19"></a></p>
<h2 id="k19">19. Literatura</h2>

<ol>

<li>McCarthy<br />
<i>&bdquo;Recursive functions of symbolic expressions and their computation by machine, part I&ldquo;</i><br />
1960
</li>

<li>Guy L. Steele<br />
<i>&bdquo;History of Scheme&ldquo;</i><br />
2006, Sun Microsystems Laboratories
</li>

<li>
Kolář J., Muller K.:<br />
<i>&bdquo;Speciální programovací jazyky&ldquo;</i><br />
Praha 1981
</li>

<li>
<i>&bdquo;AutoLISP Release 9, Programmer's reference&ldquo;</i><br />
Autodesk Ltd., October 1987
</li>

<li>
<i>&bdquo;AutoLISP Release 10, Programmer's reference&ldquo;</i><br />
Autodesk Ltd., September 1988
</li>

<li>McCarthy, John; Abrahams, Paul W.; Edwards, Daniel J.; Hart, Timothy P.; Levin, Michael I.<br />
<i>&bdquo;LISP 1.5 Programmer's Manual&ldquo;</i><br />
MIT Press. ISBN 0 262 130 1 1 4
</li>

<li>Carl Hewitt; Peter Bishop and Richard Steiger<br />
<i>&bdquo;A Universal Modular Actor Formalism for Artificial Intelligence&ldquo;</i><br />
1973
</li>

<li>Feiman, J.<br />
<i>&bdquo;The Gartner Programming Language Survey (October 2001)&ldquo;</i><br />
Gartner Advisory
</li>

<li>Harold Abelson, Gerald Jay Sussman, Julie Sussman:<br />
<i>Structure and Interpretation of Computer Programs</i><br />
MIT Press. 1985, 1996 (a možná vyšel i další přetisk)
</li>

<li>Paul Graham:<br />
<i>On Lisp</i><br />
Prentice Hall, 1993<br />
Dostupné online na stránce <a href="http://www.paulgraham.com/onlisptext.html">http://www.paulgraham.com/onlisptext.html</a>
</li>

</ol>



<p><a name="k20"></a></p>
<h2 id="k20">20. Odkazy na Internetu</h2>

<ol>

<li>Evil (Emacs Wiki)<br />
<a href="https://www.emacswiki.org/emacs/Evil">https://www.emacswiki.org/emacs/Evil</a>
</li>

<li>Evil (na GitHubu)<br />
<a href="https://github.com/emacs-evil/evil">https://github.com/emacs-evil/evil</a>
</li>

<li>Evil (na stránkách repositáře MELPA)<br />
<a href="https://melpa.org/#/evil">https://melpa.org/#/evil</a>
</li>

<li>Evil Mode: How I Switched From VIM to Emacs<br />
<a href="https://blog.jakuba.net/2014/06/23/evil-mode-how-to-switch-from-vim-to-emacs.html">https://blog.jakuba.net/2014/06/23/evil-mode-how-to-switch-from-vim-to-emacs.html</a>
</li>

<li>GNU Emacs (home page)<br />
<a href="https://www.gnu.org/software/emacs/">https://www.gnu.org/software/emacs/</a>
</li>

<li>GNU Emacs (texteditors.org)<br />
<a href="http://texteditors.org/cgi-bin/wiki.pl?GnuEmacs">http://texteditors.org/cgi-bin/wiki.pl?GnuEmacs</a>
</li>

<li>An Introduction To Using GDB Under Emacs<br />
<a href="http://tedlab.mit.edu/~dr/gdbintro.html">http://tedlab.mit.edu/~dr/gdbintro.html</a>
</li>

<li>An Introduction to Programming in Emacs Lisp<br />
<a href="https://www.gnu.org/software/emacs/manual/html_node/eintr/index.html">https://www.gnu.org/software/emacs/manual/html_node/eintr/index.html</a>
</li>

<li>27.6 Running Debuggers Under Emacs<br />
<a href="https://www.gnu.org/software/emacs/manual/html_node/emacs/Debuggers.html">https://www.gnu.org/software/emacs/manual/html_node/emacs/Debuggers.html</a>
</li>

</ol>



<p></p><p></p>
<p><small>Autor: <a href="http://www.fit.vutbr.cz/~tisnovpa">Pavel Tišnovský</a> &nbsp; 2018</small></p>
</body>
</html>

