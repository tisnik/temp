<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
        "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html>
<head>
<title>Úpravy Emacsu a tvorba nových modulů s využitím Emacs Lispu</title>
<meta name="Author" content="Pavel Tisnovsky" />
<meta name="Generator" content="vim" />
<meta http-equiv="content-type" content="text/html; charset=utf-8" />
<style type="text/css">
         body {color:#000000; background:#ffffff;}
         h1  {font-family: arial, helvetica, sans-serif; color:#ffffff; background-color:#c00000; text-align:center; padding-left:1em}
         h2  {font-family: arial, helvetica, sans-serif; color:#ffffff; background-color:#0000c0; padding-left:1em; text-align:left}
         h3  {font-family: arial, helvetica, sans-serif; color:#000000; background-color:#c0c0c0; padding-left:1em; text-align:left}
         h4  {font-family: arial, helvetica, sans-serif; color:#000000; background-color:#e0e0e0; padding-left:1em; text-align:left}
         a   {font-family: arial, helvetica, sans-serif;}
         li  {font-family: arial, helvetica, sans-serif; color:#000000; text-align:justify; width:450px;}
         ol  {font-family: arial, helvetica, sans-serif; color:#000000; text-align:justify; width:450px;}
         ul  {font-family: arial, helvetica, sans-serif; color:#000000; text-align:justify; width:450px;}
         p   {font-family: arial, helvetica, sans-serif; color:#000000; text-align:justify;}
         pre {background:#e0e0e0}
</style>
</head>

<body>

<h1>Úpravy Emacsu a tvorba nových modulů s využitím Emacs Lispu</h1>

<h3>Pavel Tišnovský</h3>

<p></p>

<h1>Úvodník</h1>

<p>Na předchozí článek, v&nbsp;němž jsme se seznámili se základními vlastnostmi režimu Evil, dnes nepřímo navážeme. Ukážeme si, jakým způsobem je možné měnit chování Emacsu, a to pomocí funkcí naprogramovaných v&nbsp;Emacs Lispu. Napřed si ovšem popíšeme základní vlastnosti tohoto jazyka.</p>



<h2>Obsah</h2>

<p><a href="#k01">1. Úpravy Emacsu a tvorba nových modulů s&nbsp;využitím Emacs Lispu</a></p>
<p><a href="#k02">2. LISP aneb jazyk, který nám nepřinesl AI</a></p>
<p><a href="#k03">3. Rozdíly mezi různými dialekty programovacího jazyka LISP</a></p>
<p><a href="#k04">4. Je Emacs Lisp funkcionálním jazykem?</a></p>
<p><a href="#k05">5. Základní nastavení Emacsu při zkoušení možností Emacs LISPu</a></p>
<p><a href="#k06">6. Scratch buffer ve funkci REPLu</a></p>
<p><a href="#k07">7. Spouštění příkladů naprogramovaných v&nbsp;Elispu z&nbsp;příkazového řádku</a></p>
<p><a href="#k08">8. Základní datové typy Elispu</a></p>
<p><a href="#k09">9. Prázdný seznam a rekurzivní datové struktury založené na seznamech</a></p>
<p><a href="#k10">10. Tečka-dvojice: základ pro tvorbu složitějších datových struktur</a></p>
<p><a href="#k11">11. Základní funkce pro konstrukci seznamů a pro přístup k&nbsp;prvkům seznamů</a></p>
<p><a href="#k12">12. Definice vlastních funkcí</a></p>
<p><a href="#k13">13. Funkce s&nbsp;nepovinnými parametry</a></p>
<p><a href="#k14">14. Funkce vyššího řádu</a></p>
<p><a href="#k15">15. Anonymní funkce</a></p>
<p><a href="#k16">16. Výpočet faktoriálu realizovaný funkcí vyššího řádu</a></p>
<p><a href="#k17">17. Repositář s&nbsp;demonstračními příklady</a></p>
<p><a href="#k18">18. Guile Emacs</a></p>
<p><a href="#k19">19. Literatura</a></p>
<p><a href="#k20">20. Odkazy na Internetu</a></p>



<p><a name="k01"></a></p>
<h2 id="k01">1. Úpravy Emacsu a tvorba nových modulů s&nbsp;využitím Emacs Lispu</h2>



<p><a name="k02"></a></p>
<h2 id="k02">2. LISP aneb jazyk, který nám nepřinesl AI</h2>

<p><a href="http://imgs.xkcd.com/comics/lisp_cycles.png">Syntaxe jazyka LISP je již po 50 let zdrojem inspirace pro autory vtipů</a></p>



<p><a name="k03"></a></p>
<h2 id="k03">3. Rozdíly mezi různými dialekty programovacího jazyka LISP</h2>



<p><a name="k04"></a></p>
<h2 id="k04">4. Je Emacs Lisp funkcionálním jazykem?</h2>



<p><a name="k05"></a></p>
<h2 id="k05">5. Základní nastavení Emacsu při zkoušení možností Emacs LISPu</h2>



<p><a name="k06"></a></p>
<h2 id="k06">6. Scratch buffer ve funkci REPLu</h2>



<p><a name="k07"></a></p>
<h2 id="k07">7. Spouštění příkladů naprogramovaných v&nbsp;Elispu z&nbsp;příkazového řádku</h2>



<p><a name="k08"></a></p>
<h2 id="k08">8. Základní datové typy Elispu</h2>



<p><a name="k09"></a></p>
<h2 id="k09">9. Prázdný seznam a rekurzivní datové struktury založené na seznamech</h2>

<p>Poslední dva seznamy mají v&nbsp;Elispu zvláštní význam, protože jejich
první element představuje symbol reprezentující primitivní (základní) funkci.
Programovací jazyk <i>LISP</i> by tento seznam zpracoval tak, že by funkci
zavolal s&nbsp;tím, že jí jako parametry předá všechny další prvky seznamu
(případné podseznamy se nejdříve rekurzivně vyhodnotí naprosto stejným způsobem
&ndash; ostatně toto vyhodnocování je základ celého REPLu).</p>

<p><div class="rs-tip-major">Poznámka: vzhledem k&nbsp;tomu, že první prvek
seznamu je při jeho vyhodnocování chápán jako název funkce, budete muset při
testech v&nbsp;REPLu v&nbsp;prvních příkladech před seznam přidat znak ', což
je zkratka takzvané speciální formy <strong>quote</strong>. Pojmem speciální
forma se v&nbsp;Lispech označuje zápis, který se vyhodnocuje odlišně, než běžné
funkce. Příkladem může být speciální forma <strong>if</strong> zmíněná
dále.</div></p>



<p><a name="k10"></a></p>
<h2 id="k10">10. Tečka-dvojice: základ pro tvorbu složitějších datových struktur</h2>

<p><div class="rs-tip-major">Poznámka: tečka dvojice jsou podporovány
v&nbsp;naprosté většině dialektů LISPu. Jednou z&nbsp;mála výjimek je
programovací jazyk <i>Clojure</i>, protože v&nbsp;tomto jazyku jsou seznamy
reprezentovány odlišným způsobem a nemá tedy větší význam se snažit předstírat,
že se jedná o pouhé lineárně vázané seznamy.</div></p>

<p>V&nbsp;<a href="#k08">předchozí kapitole</a> jsme si řekli, že programovací
jazyk <i>LISP</i> je založen na zpracování seznamů. Jak jsou však seznamy
uloženy v&nbsp;operační paměti počítače a jak s&nbsp;nimi interpretry tohoto
jazyka pracují? Základní interní strukturou, která je však přímo dostupná i
programátorům aplikací v&nbsp;jazyce <i>LISP</i>, je takzvaná
<i>tečka-dvojice</i> (dotted-pair). Tuto strukturu si můžeme představit jako
dvojici ukazatelů, přičemž každý z&nbsp;těchto ukazatelů může obsahovat adresu
atomu, adresu další tečka-dvojice nebo speciální hodnotu <strong>nil</strong>
odpovídající v&nbsp;céčku hodnotě <strong>NULL</strong> či v&nbsp;Javě hodnotě
<strong>null</strong>, tj.&nbsp;jedná se o speciální hodnotu, která interpretru
říká, že daný ukazatel neobsahuje žádný odkaz.</p>

<p>Tečka-dvojici lze v&nbsp;LISPovských programech zapisovat formou dvojice
výrazů (takzvaných S-výrazů zmíněných v&nbsp;úvodních kapitolách) oddělených
tečkou, které jsou uzavřeny do kulatých závorek (i když je pravda, že se
s&nbsp;tečka-dvojicemi v&nbsp;reálných programech příliš často nesetkáme,
především z&nbsp;důvodu nepřehledného zápisu s&nbsp;velkým množstvím
závorek):</p>

<pre>
(1.2)
(1.nil)
(A.(B.C))
(A.(B.nil))
((A.B).C)
((A.B).(C.D))
(ABC.DEF)
((ABC.(DEF.UVW)).XYZ)
</pre>

<p>Pro přístup k&nbsp;informaci (atomu či další tečka dvojici), na kterou
odkazuje první ukazatel tečka dvojice, se používá primitivní funkce
<strong>car</strong>, a pro přístup k&nbsp;informaci, na níž se odkazuje druhý
ukazatel, lze použít funkci <strong>cdr</strong> (pozor na to, že Elisp
rozlišuje mezi malými a velkými písmeny, na rozdíl od některých dalších
dialektů LISPu).</p>

<p>Pomocí tečka-dvojic je možné vytvořit klasický seznam následujícím způsobem:
první ukazatel každé n-té tečka-dvojice odkazuje na n-tý prvek seznamu
(například atom), druhý ukazatel se odkazuje na další (n plus první)
tečka-dvojici. Speciálním případem je poslední tečka-dvojice, jejíž druhý
ukazatel obsahuje výše uvedenou speciální hodnotu <strong>nil</strong>.
Z&nbsp;následujícího příkladu (obsahujícího ekvivalentní datové struktury) je
patrné, že použití syntaxe pro zápis seznamů je přehlednější a současně i
mnohem kratší, než explicitní zápis tečka-dvojic; ovšem právě znalost vnitřní
reprezentace seznamů pomocí tečka-dvojic nám umožňuje pochopit, jak pracují
některé základní funkce, včetně již zmíněných funkcí <strong>car</strong> a
<strong>cdr</strong>:</p>

<pre>
<i>; seznam zapsaný pomocí tečka-dvojic</i>
<strong>(1.(2.(3.(4.(5.nil)))))</strong>
&nbsp;
<i>; běžný způsob zápisu seznamu</i>
<strong>(1 2 3 4 5)</strong>
</pre>

<pre>
; interní struktura seznamu v paměti
;         .
;        / \
;       1   .
;          / \
;         2   .
;            / \
;           3   .
;              / \
;             4   .
;                / \
;               5   nil
</pre>

<p>Poznamenejme, že další struktury vytvořené pomocí rekurzivně zanořených
tečka-dvojic není možné převést na běžné seznamy. Například jednoduchý binární
strom se třemi úrovněmi a čtyřmi listy lze reprezentovat buď pomocí
tečka-dvojic (v&nbsp;paměti se vytvoří skutečná obdoba binárního stromu),
popř.&nbsp;je možné tuto datovou strukturu &bdquo;simulovat&ldquo; pomocí
seznamů (ovšem v&nbsp;tomto případě bude paměťová náročnost nepatrně vyšší
kvůli nutnosti ukončení všech podseznamů tečka dvojicí obsahující ve svém
druhém ukazateli hodnotu <strong>nil</strong>):</p>

<pre>
<i>; binární strom se třemi úrovněmi a čtyřmi listy vytvořený pomocí tečka dvojic</i>
<strong>((A.B).(C.D))</strong>
; interní podoba této struktury v operační paměti:
;     .
;    / \
;   .   .
;  / \ / \
;  A B C D
&nbsp;
<i>; binární strom vytvořený pomocí LISPovských seznamů</i>
<strong>((A B) (C D))</strong>
; interní podoba této struktury v operační paměti:
;         .
;        / \
;       /   \
;      /     \
;     /       \
;    .         .
;   / \       / \
;   A  .     .  nil
;     / \   / \
;     B nil C  .
;             / \
;             D nil
</pre>

<p><div class="rs-tip-major">Poznámka: Pokud si budete chtít podobné složitější
datové struktury zobrazit vizuálně, můžete využít například projekt <a
href="https://github.com/cuichaox/visual-cells">Visual Cells</a>.</div></p>



<p><a name="k11"></a></p>
<h2 id="k11">11. Základní funkce pro konstrukci seznamů a pro přístup k&nbsp;prvkům seznamů</h2>

<p>Jednou ze základních funkcí, která se objevila už v&nbsp;původním návrhu
LISPu, je funkce nazvaná <strong>cons</strong>. Této funkci se předají dvě
hodnoty (atomy či strukturované hodnoty) a výsledkem bude tečka dvojice:</p>

<pre>
<strong>(print (cons 1 2))</strong>
(1 . 2)
&nbsp;
<strong>(print (cons 1 (cons 2 3)))</strong>
(1 2 . 3)
&nbsp;
<strong>(print '((1 . 2) . (3 . 4)))</strong>
((1 . 2) 3 . 4)
</pre>

<p>Vhodnou volbou argumentů funkce <strong>cons</strong> lze vytvořit seznam
(viz <a href="#k10">předchozí kapitolu</a>):</p>

<pre>
<i>; this is proper list</i>
<strong>(print (cons 1 (cons 2 (cons 3 nil))))</strong>
(1 2 3)
&nbsp;
<i>; this is proper list</i>
<strong>(print (cons 1 (cons 2 (cons 3 ()))))</strong>
(1 2 3)
</pre>

<p>Výše dva uvedené příklady sice skutečně vedou k&nbsp;vytvoření seznamu,
ovšem jejich zápis je velmi dlouhý a zbytečně pracný. Seznamy lze zkonstruovat
i jinak, a to konkrétně funkcí <strong>list</strong>, která všechny své
parametry (libovolný počet) vloží do nového seznamu:</p>

<pre>
<strong>(print (list 1 2 3 4))</strong>
(1 2 3 4)
</pre>

<p>Seznam můžeme přiřadit k&nbsp;proměnné, například k&nbsp;proměnné
<strong>a</strong>:</p>

<pre>
<i>; create list and assign it to symbol</i>
<i>; (=variable)</i>
(setq a '(1 2 3 4))
</pre>

<p>Dále máme k&nbsp;dispozici funkce <strong>car</strong> a
<strong>cdr</strong> vracející první prvek resp.&nbsp;všechny prvky kromě
prvního. Existují i další variace, například funkce <strong>cadr</strong>
odpovídající <strong>(car (cdr ...))</strong> či <strong>cddr</strong>
odpovídající <strong>(cdr (cdr ...))</strong>:</p>

<pre>
<i>; get the first item</i>
<strong>(print (car a))</strong>
1
&nbsp;
<i>; get the rest of a list</i>
<strong>(print (cdr a))</strong>
(2 3 4)
&nbsp;
<i>; combination of car+cdr</i>
<strong>(print (cadr a))</strong>
2
&nbsp;
<i>; combination of cdr+cdr</i>
<strong>(print (cddr a))</strong>
(3 4)
</pre>



<p><a name="k12"></a></p>
<h2 id="k12">12. Definice vlastních funkcí</h2>

<p>Podobně jako u každého dialektu programovacího jazyka LISP, i v&nbsp;případě
<i>Elispu</i> se program skládá především z&nbsp;funkcí. Ty mohou být anonymní
(nepojmenované) či naopak pojmenované. Nejprve se zabývejme pojmenovanými
funkcemi, protože ty se chovají prakticky stejně, jako běžné funkce
v&nbsp;jiných programovacích jazycích. Pojmenované funkce se definují pomocí
<strong>defun</strong> (zkratka od &bdquo;define function&ldquo;), za nímž
následuje jméno funkce. Každá funkce může mít libovolný počet parametrů,
jejichž jména se uvádí v&nbsp;seznamu za pojmenováním funkce. Poslední částí
formy <strong>defun</strong> je tělo funkce, přičemž po zavolání funkce se
vyhodnocená forma vrátí jako její výsledek (nikde se tedy nezapisuje slovo
&bdquo;return&ldquo; ani nic podobného):</p>

<pre>
<i>; one-liner function</i>
(defun add (x y) (+ x y))
</pre>

<p>Přehlednější je však zápis definice funkce na více řádků. První řádek
obsahuje jméno, druhý pojmenované parametry, další řádky pak tělo funkce:</p>

<pre>
<i>; function written on more lines</i>
(defun mul
  (x y)
  (* x y))
&nbsp;
<i>; function written on more lines</i>
(defun div
  (x y)
  (/ x y))
</pre>

<p>Zavolání funkce je jednoduché &ndash; používá se stále ten samý formát
seznamu, na jehož prvním místě je jméno funkce a za ním následují
parametry:</p>

<pre>
<i>; test functions</i>
(print (add 1 2))
(print (mul 6 7))
(print (div 10 3))
</pre>



<p><a name="k13"></a></p>
<h2 id="k13">13. Funkce s&nbsp;nepovinnými parametry</h2>

<p>V&nbsp;Elispu se můžeme setkat s&nbsp;velkým množstvím funkcí, které mají
nepovinné parametry. Tyto parametry jsou od parametrů povinných odděleny pomocí
klauzule <strong>&amp;optional</strong>. Příkladem může být funkce pro součet
dvou nebo tří číselných hodnot (samozřejmě se jedná o dosti umělý příklad):</p>

<pre>
(defun add3
  (x y &amp;optional z)
  (if z
    (+ x y z)
    (+ x y)))
</pre>

<p>Funkci si můžeme vyzkoušet:</p>

<pre>
<strong>(add3 1 2 3)</strong>
6
&nbsp;
<strong>(add3 1 2)</strong>
3
&nbsp;
<strong>(add3 1)</strong>
Wrong number of arguments: (lambda (x y &amp;optional z) (if z (+ x y z) (+ x y))), 1
</pre>

<p>V&nbsp;posledním příkladu je ukázáno, že první dva parametry jsou skutečně
povinné.</p>



<p><a name="k14"></a></p>
<h2 id="k14">14. Funkce vyššího řádu</h2>

<p>Funkce jsou plnoprávnými datovými typy, takže je lze přiřadit do proměnné
atd. V&nbsp;Elispu pouze nastává jeden problém, protože interně jsou ke každému
symbolu (například ke jménu funkce) přiřazeny čtyři komponenty (nazývané
<i>cells</i>):</p>

<ol>
<li>Jméno symbolu tak, jak je zobrazeno uživateli</li>
<li>Hodnota (pokud se symbol používá jako proměnná)</li>
<li>Funkce</li>
<li>Seznam vlastností (property list) popsaný příště</li>
</ol>

<p>Proto je nutné rozlišovat mezi hodnotou a funkcí. Jsou možné dvě řešení:</p>

<pre>
(defun add (x y) (+ x y))
&nbsp;
(setq soucet 'add)
&nbsp;
(funcall soucet 10 20)
</pre>

<p>Druhé řešení pracuje přímo s&nbsp;funkcí, ovšem namísto
<strong>setq</strong> používá <strong>fset</strong>:</p>

<pre>
(fset 'soucet2 'add)
&nbsp;
(soucet2 100 200)
</pre>

<p>Toto je hlavní rozdíl mezi Elispem a mnoha ostatními dialekty Lispu a bude
vám možná zpočátku způsobovat problémy.</p>

<p><i>Elisp</i> sice není, na rozdíl od Haskellu a částečně i Clojure, čistě
funkcionální jazyk, nicméně i zde hrají při vývoji aplikací velkou roli funkce
vyššího řádu, tj.&nbsp;funkce, které jako své parametry akceptují jiné funkce
popř.&nbsp;dokonce vrací (nové) funkce jako svoji návratovou hodnotu. Mezi dvě
základní funkce vyššího řádu, které nalezneme prakticky ve všech dialektech
programovacího jazyka Lisp, patří funkce nazvané <strong>mapcar</strong> a
taktéž <strong>apply</strong>. Funkce <strong>mapcar</strong> jako svůj první
parametr akceptuje jinou funkci (s&nbsp;jedním parametrem) a druhým parametrem
musí být seznam. <strong>mapcar</strong> postupně aplikuje předanou funkci na
jednotlivé prvky seznamu a vytváří tak seznam nový (modifikovaný). Podívejme se
na jednoduchý příklad &ndash; aplikace funkce pro zvýšení hodnoty o jedničku na
seznam:</p>

<pre>
; regular function
(defun inc
  (x)
  (+ x 1)) 
&nbsp;
<i>; use inc in higher order function</i>
<strong>(print (mapcar 'inc '(1 2 3)))</strong>
(2 3 4)
</pre>

<p>Funkce <strong>apply</strong> se chová poněkud odlišně &ndash; aplikuje
totiž nějakou funkci (svůj první parametr) na předaný seznam. Typický
&bdquo;školní&ldquo; příklad s&nbsp;binární funkcí + (tj.&nbsp;funkcí se dvěma
parametry) může vypadat následovně:</p>

<pre>
<i>; use + in higher order function</i>
<strong>(print (apply '+ '(1 2 3 4)))</strong>
10
</pre>

<p>Podobně je tomu například u funkce *:</p>

<pre>
<i>; use * in higher order function</i>
<strong>(print (apply '* (number-sequence 1 6)))</strong>
720
</pre>

<p>Poslední zajímavou funkcí je <strong>cl-reduce</strong>, která postupně
zpracovává prvky předaného seznamu a pomocí akumulátoru tvoří výslednou
hodnotu:</p>

<pre>
(require 'cl-lib)
&nbsp;
(defun add
  (x y)
  (+ x y))
&nbsp;
; use add in higher order function reduce
(print (cl-reduce 'add '(1 2 3 4)))
&nbsp;
</pre>



<p><a name="k15"></a></p>
<h2 id="k15">15. Anonymní funkce</h2>

<p>Kromě pojmenovaných funkcí, které jsme si již představili v&nbsp;předchozích
kapitolách, je možné v&nbsp;<i>Elispu</i> použít i funkce anonymní,
tj.&nbsp;funkce, které nejsou navázány na žádné jméno. Pro tento účel se
používá lambda výraz, podobně jako v&nbsp;každém ortodoxním Lispu (kromě
PicoLispu). Podívejme se na typický příklad &ndash; budeme chtít ze vstupního
seznamu vytvořit výstupní seznam s&nbsp;hodnotami o jedničku zvýšenými. Pro
něco tak jednoduchého asi nemá smysl si vytvářet novou pojmenovanou funkci, ale
použijeme přímo funkci anonymní:</p>

<pre>
<i>; anonymous function used in higher order function</i>
<strong>(print (mapcar (lambda (x) (+ x 1) ) '(1 2 3 4)))</strong>
10
</pre>

<p>Zajímá vás řada n<sup>2</sup>?:</p>

<pre>
<i>; anonymous function used in higher order function</i>
<strong>(print (mapcar (lambda (x) (* x x)) (number-sequence 1 10)) )</strong>
(1 4 9 16 25 36 49 64 81 100)
</pre>



<p><a name="k16"></a></p>
<h2 id="k16">16. Výpočet faktoriálu realizovaný funkcí vyššího řádu</h2>

<p>Funkce vyššího řádu lze použít i pro přepis výpočtu faktoriálu. Ten lze
přepsat s&nbsp;využitím funkce <strong>apply</strong> a taktéž generátoru
sekvence čísel <strong>number-sequence</strong> (ten zhruba odpovídá
Pythonovskému <strong>range</strong>, ovšem generuje se i poslední mezní
hodnota):</p>

<pre>
; higher order function in other (regular) function
(defun factorial
  (n)
  (apply '* (number-sequence 1 n)))
</pre>

<p>Otestování je snadné:</p>

<pre>
(print (factorial 10))
</pre>

<p>Samozřejmě si můžeme vypsat sekvenci faktoriálu pro vstupní hodnoty n=1, n=2
atd.:</p>

<pre>
<i>; anonymous function used in higher order function</i>
<strong>(print (mapcar 'factorial (number-sequence 0 10)))</strong>
(1 1 2 6 24 120 720 5040 40320 362880 3628800)
</pre>

<p>Nebo celý výpočet napsat na jediný řádek s&nbsp;využitím dvou funkcí vyššího
řádu a jedné anonymní funkce:</p>

<pre>
<i>; anonymous function used in higher order function</i>
<strong>(print (mapcar (lambda (n) (apply '* (number-sequence 1 n) )) (number-sequence 1 10)) )</strong>
(1 2 6 24 120 720 5040 40320 362880 3628800)
</pre>



<p><a name="k17"></a></p>
<h2 id="k17">17. Repositář s&nbsp;demonstračními příklady</h2>

<p>Zdrojové kódy většiny dnes popsaných demonstračních příkladů byly uloženy do
Git repositáře dostupného na adrese <a
href="https://github.com/tisnik/elisp-examples">https://github.com/tisnik/elisp-examples</a>
(stále na GitHubu :-). V&nbsp;případě, že nebudete chtít klonovat celý
repositář (ten je ovšem stále velmi malý, dnes má doslova několik kilobajtů),
můžete namísto toho použít odkazy na jednotlivé příklady, které naleznete
v&nbsp;následující tabulce:</p>

<table>
<tr><th> #</th><th>Demonstrační příklad</th><th>Popis</th><th>Cesta</th></tr>
<tr><td> 1</td><td>01_hello_world.el</td><td>nejprimitivnější příklad &ndash; &bdquo;hello world&ldquo;</td><td><a href="https://github.com/tisnik/elisp-examples/blob/master/elisp-1/01_hello_world.el">https://github.com/tisnik/elisp-examples/blob/master/elisp-1/01_hello_world.el</a></td></tr>
<tr><td> 2</td><td>02_cl-loop.el</td><td>programová smyčka převzatá z&nbsp;Common Lispu</td><td><a href="https://github.com/tisnik/elisp-examples/blob/master/elisp-1/02_cl-loop.el">https://github.com/tisnik/elisp-examples/blob/master/elisp-1/02_cl-loop.el</a></td></tr>
<tr><td> 3</td><td>03_while_loop_A.el</td><td>programová smyčka while</td><td><a href="https://github.com/tisnik/elisp-examples/blob/master/elisp-1/03_while_loop_A.el">https://github.com/tisnik/elisp-examples/blob/master/elisp-1/03_while_loop_A.el</a></td></tr>
<tr><td> 4</td><td>04_while_loop_B.el</td><td>programová smyčka while</td><td><a href="https://github.com/tisnik/elisp-examples/blob/master/elisp-1/04_while_loop_B.el">https://github.com/tisnik/elisp-examples/blob/master/elisp-1/04_while_loop_B.el</a></td></tr>
<tr><td> 5</td><td>05_factorial.el</td><td>rekurzivní výpočet faktoriálu</td><td><a href="https://github.com/tisnik/elisp-examples/blob/master/elisp-1/05_factorial.el">https://github.com/tisnik/elisp-examples/blob/master/elisp-1/05_factorial.el</a></td></tr>
<tr><td> 6</td><td>06_map_C-j.el</td><td>mapování klávesy C-j</td><td><a href="https://github.com/tisnik/elisp-examples/blob/master/elisp-1/06_map_C-j.el">https://github.com/tisnik/elisp-examples/blob/master/elisp-1/06_map_C-j.el</a></td></tr>
<tr><td> 7</td><td>07_map_RET.el</td><td>mapování klávesy Return/Enter</td><td><a href="https://github.com/tisnik/elisp-examples/blob/master/elisp-1/07_map_RET.el">https://github.com/tisnik/elisp-examples/blob/master/elisp-1/07_map_RET.el</a></td></tr>
<tr><td> 8</td><td>08_dot_pairs.el</td><td>tečka-dvojice</td><td><a href="https://github.com/tisnik/elisp-examples/blob/master/elisp-1/08_dot_pairs.el">https://github.com/tisnik/elisp-examples/blob/master/elisp-1/08_dot_pairs.el</a></td></tr>
<tr><td> 9</td><td>09_cons.el</td><td>konstrukce tečka-dvojic</td><td><a href="https://github.com/tisnik/elisp-examples/blob/master/elisp-1/09_cons.el">https://github.com/tisnik/elisp-examples/blob/master/elisp-1/09_cons.el</a></td></tr>
<tr><td>10</td><td>10_lists.el</td><td>práce se seznamy</td><td><a href="https://github.com/tisnik/elisp-examples/blob/master/elisp-1/10_lists.el">https://github.com/tisnik/elisp-examples/blob/master/elisp-1/10_lists.el</a></td></tr>
<tr><td>11</td><td>11_functions.el</td><td>definice vlastních funkcí</td><td><a href="https://github.com/tisnik/elisp-examples/blob/master/elisp-1/11_functions.el">https://github.com/tisnik/elisp-examples/blob/master/elisp-1/11_functions.el</a></td></tr>
<tr><td>12</td><td>12_higher_order_functions.el</td><td>ukázka funkcí vyššího řádu</td><td><a href="https://github.com/tisnik/elisp-examples/blob/master/elisp-1/12_higher_order_functions.el">https://github.com/tisnik/elisp-examples/blob/master/elisp-1/12_higher_order_functions.el</a></td></tr>
<tr><td>13</td><td>13_anonymous_functions.el</td><td>anonymní funkce (lambda)</td><td><a href="https://github.com/tisnik/elisp-examples/blob/master/elisp-1/13_anonymous_functions.el">https://github.com/tisnik/elisp-examples/blob/master/elisp-1/13_anonymous_functions.el</a></td></tr>
<tr><td>14</td><td>14_factorial_B.el</td><td>přímý výpočet faktoriálu</td><td><a href="https://github.com/tisnik/elisp-examples/blob/master/elisp-1/14_factorial_B.el">https://github.com/tisnik/elisp-examples/blob/master/elisp-1/14_factorial_B.el</a></td></tr>
<tr><td>15</td><td>15_factorial_C.el</td><td>funkce pro výpočet faktoriálu založená na funkcích vyššího řádu</td><td><a href="https://github.com/tisnik/elisp-examples/blob/master/elisp-1/15_factorial_C.el">https://github.com/tisnik/elisp-examples/blob/master/elisp-1/15_factorial_C.el</a></td></tr>
</table>

<p>Všechny příklady se mohou spouštět z&nbsp;příkazové řádky následujícím
způsobem:</p>

<pre>
emacs --script priklad1.el
</pre>



<p><a name="k18"></a></p>
<h2 id="k18">18. Guile Emacs</h2>

<p>Pro zajímavost se v&nbsp;dnešním článku musíme zmínit o projektu nazvaném
<i>Guile Emacs</i>. Název tohoto projektu může být poněkud matoucí, protože se
ve skutečnosti <i>nejedná</i> o snahu nahradit Emacs Lisp jazykem Scheme
(resp.&nbsp;jeho konkrétní implementací pojmenovanou GNU Guile), ale o
zajištění, aby byly zdrojové kódy napsané v&nbsp;Elispu překládány stejným
způsobem (podobným překladačem), jako je tomu v&nbsp;případě Guile. Výsledkem
by měl být rychlejší běh jak samotného Emacsu, tak i jeho modulů, což může být
zajímavé pro rozsáhlejší moduly typu <i>org-mode</i>, webového prohlížeče atd.
Navíc se díky použití překladače Guile otevírá možnost rozšíření možností
samotného Elispu o vlastnosti podporované v&nbsp;Guile. Dále by mělo být možné
psát moduly buď v&nbsp;Elispu nebo přímo v&nbsp;Guile (které je sice taktéž
založeno na LISPovském dialektu, ale jedná se o matematicky čistější
implementaci, což některým programátorům může vyhovovat). Bližší informace o
tomto projektu je možné nalézt na <a
href="https://www.emacswiki.org/emacs/SiteMap">EmacsWiki</a>, konkrétně na
stránce <a
href="https://www.emacswiki.org/emacs/GuileEmacs">https://www.emacswiki.org/emacs/GuileEmacs</a>.</p>

<p><div class="rs-tip-major">Poznámka: Guile znamená &bdquo;GNU Ubiquitous
Intelligent Language for Extensions&ldquo;, takže plné jméno &bdquo;GNU
Guile&ldquo; vlastně obsahuje &bdquo;GNU&ldquo; hned dvakrát. Navíc je GNU
rekurzivní zkratka znamenající &bdquo;GNU's Not Unix!&ldquo;, takže je zde
poněkud přepakoňováno.</div></p>



<p><a name="k19"></a></p>
<h2 id="k19">19. Literatura</h2>

<ol>

<li>McCarthy<br />
<i>&bdquo;Recursive functions of symbolic expressions and their computation by machine, part I&ldquo;</i><br />
1960
</li>

<li>Guy L. Steele<br />
<i>&bdquo;History of Scheme&ldquo;</i><br />
2006, Sun Microsystems Laboratories
</li>

<li>
Kolář J., Muller K.:<br />
<i>&bdquo;Speciální programovací jazyky&ldquo;</i><br />
Praha 1981
</li>

<li>
<i>&bdquo;AutoLISP Release 9, Programmer's reference&ldquo;</i><br />
Autodesk Ltd., October 1987
</li>

<li>
<i>&bdquo;AutoLISP Release 10, Programmer's reference&ldquo;</i><br />
Autodesk Ltd., September 1988
</li>

<li>McCarthy, John; Abrahams, Paul W.; Edwards, Daniel J.; Hart, Timothy P.; Levin, Michael I.<br />
<i>&bdquo;LISP 1.5 Programmer's Manual&ldquo;</i><br />
MIT Press. ISBN 0 262 130 1 1 4
</li>

<li>Carl Hewitt; Peter Bishop and Richard Steiger<br />
<i>&bdquo;A Universal Modular Actor Formalism for Artificial Intelligence&ldquo;</i><br />
1973
</li>

<li>Feiman, J.<br />
<i>&bdquo;The Gartner Programming Language Survey (October 2001)&ldquo;</i><br />
Gartner Advisory
</li>

<li>Harold Abelson, Gerald Jay Sussman, Julie Sussman:<br />
<i>Structure and Interpretation of Computer Programs</i><br />
MIT Press. 1985, 1996 (a možná vyšel i další přetisk)
</li>

<li>Paul Graham:<br />
<i>On Lisp</i><br />
Prentice Hall, 1993<br />
Dostupné online na stránce <a href="http://www.paulgraham.com/onlisptext.html">http://www.paulgraham.com/onlisptext.html</a>
</li>

</ol>



<p><a name="k20"></a></p>
<h2 id="k20">20. Odkazy na Internetu</h2>

<ol>

<li>Evil (Emacs Wiki)<br />
<a href="https://www.emacswiki.org/emacs/Evil">https://www.emacswiki.org/emacs/Evil</a>
</li>

<li>Evil (na GitHubu)<br />
<a href="https://github.com/emacs-evil/evil">https://github.com/emacs-evil/evil</a>
</li>

<li>Evil (na stránkách repositáře MELPA)<br />
<a href="https://melpa.org/#/evil">https://melpa.org/#/evil</a>
</li>

<li>Evil Mode: How I Switched From VIM to Emacs<br />
<a href="https://blog.jakuba.net/2014/06/23/evil-mode-how-to-switch-from-vim-to-emacs.html">https://blog.jakuba.net/2014/06/23/evil-mode-how-to-switch-from-vim-to-emacs.html</a>
</li>

<li>GNU Emacs (home page)<br />
<a href="https://www.gnu.org/software/emacs/">https://www.gnu.org/software/emacs/</a>
</li>

<li>GNU Emacs (texteditors.org)<br />
<a href="http://texteditors.org/cgi-bin/wiki.pl?GnuEmacs">http://texteditors.org/cgi-bin/wiki.pl?GnuEmacs</a>
</li>

<li>An Introduction To Using GDB Under Emacs<br />
<a href="http://tedlab.mit.edu/~dr/gdbintro.html">http://tedlab.mit.edu/~dr/gdbintro.html</a>
</li>

<li>An Introduction to Programming in Emacs Lisp<br />
<a href="https://www.gnu.org/software/emacs/manual/html_node/eintr/index.html">https://www.gnu.org/software/emacs/manual/html_node/eintr/index.html</a>
</li>

<li>27.6 Running Debuggers Under Emacs<br />
<a href="https://www.gnu.org/software/emacs/manual/html_node/emacs/Debuggers.html">https://www.gnu.org/software/emacs/manual/html_node/emacs/Debuggers.html</a>
</li>

</ol>



<p></p><p></p>
<p><small>Autor: <a href="http://www.fit.vutbr.cz/~tisnovpa">Pavel Tišnovský</a> &nbsp; 2018</small></p>
</body>
</html>

