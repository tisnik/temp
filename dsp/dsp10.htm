<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
        "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html>
<head>
<title>Mikrořadiče a DSP společnosti Infineon</title>
<meta name="Author" content="Pavel Tisnovsky" />
<meta name="Generator" content="vim" />
<meta http-equiv="content-type" content="text/html; charset=utf-8" />
<style type="text/css">
         body {color:#000000; background:#ffffff;}
         h1  {font-family: arial, helvetica, sans-serif; color:#ffffff; background-color:#c00000; text-align:center; padding-left:1em}
         h2  {font-family: arial, helvetica, sans-serif; color:#ffffff; background-color:#0000c0; padding-left:1em; text-align:left}
         h3  {font-family: arial, helvetica, sans-serif; color:#000000; background-color:#c0c0c0; padding-left:1em; text-align:left}
         h4  {font-family: arial, helvetica, sans-serif; color:#000000; background-color:#e0e0e0; padding-left:1em; text-align:left}
         a   {font-family: arial, helvetica, sans-serif;}
         li  {font-family: arial, helvetica, sans-serif; color:#000000; text-align:justify; width:450px;}
         ol  {font-family: arial, helvetica, sans-serif; color:#000000; text-align:justify; width:450px;}
         ul  {font-family: arial, helvetica, sans-serif; color:#000000; text-align:justify; width:450px;}
         p   {font-family: arial, helvetica, sans-serif; color:#000000; text-align:justify;}
         pre {background:#e0e0e0}
</style>
</head>

<body>

<h1>Mikrořadiče a DSP společnosti Infineon</h1>

<h3>Pavel Tišnovský</h3>

<p></p>

<h1>Úvodník</h1>

<p>Vývojem digitálních signálových procesorů se kromě již zmíněných společností TI a Motorola samozřejmě zabývají i další firmy. Dnes se seznámíme s&nbsp;některými zajímavými čipy určenými pro automobilové i průmyslové aplikace, které jsou vyvíjeny ve společnosti Infineon.</p>



<h2>Obsah</h2>

<p><a href="#k01">1. Mikrořadiče a DSP společnosti Infineon</a></p>
<p><a href="#k02">2. Osmibitové mikrořadiče založené na 8051</a></p>
<p><a href="#k03">3. Řada XC800, rodina A a I</a></p>
<p><a href="#k04">4. Moduly mikrořadičů řady XC800</a></p>
<p><a href="#k05">5. Vylepšené jádro 8051</a></p>
<p><a href="#k06">6. Paměťový subsystém</a></p>
<p><a href="#k07">7. Multiplication/Division Unit (MDU)</a></p>
<p><a href="#k08">8. Field Oriented Control (FOC)</a></p>
<p><a href="#k09">9. Algoritmus CORDIC (COrdinate Rotation DIgital Computer)</a></p>
<p><a href="#k10">10. Princip CORDICu: rotace vektoru r okolo počátku souřadného systému</a></p>
<p><a href="#k11">11. Úprava vztahu rotace vektoru pro algoritmus CORDIC</a></p>
<p><a href="#k12">12. Hodnoty úhlů, po kterých se provádí rotace</a></p>
<p><a href="#k13">13. Ukázka: výpočet funkcí sin a cos algoritmem CORDIC</a></p>
<p><a href="#k14">14. CORDIC a formát pevné řádové čárky</a></p>
<p><a href="#k15">15. CORDIC na čipech XC800</a></p>
<p><a href="#k16">16. Odkazy na Internetu</a></p>



<p><a name="k01"></a></p>
<h2 id="k01">1. Mikrořadiče a DSP společnosti Infineon</h2>

<p>Dalším výrobcem (nejenom) digitálních signálových procesorů je německá
společnost Infineon, která se zaměřuje na čipy určené pro automobilový průmysl
a taktéž pro různé řídicí systémy v&nbsp;průmyslu (průmyslová automatizace,
diagnostika atd.). Spektrum čipů, které Infineon vyráběl či vyrábí, je poměrně
široké: od osmibitových mikrořadičů (například řady C505, nověji XC800)
založených na dnes již pravěké, ale stále používané architektuře 8051 přes čipy
s&nbsp;některým ARMovským mikrořadičovým jádrem Cortex-M (řada XMC1000 používá
Cortex-M0 a řada XMC4000 Cortex-M4) až po 32bitové čipy s&nbsp;architekturou
<i>TriCore</i>, v&nbsp;nichž se kombinují možnosti RISCových procesorů,
digitálních signálových procesorů a mikrořadičů. Vzhledem k&nbsp;tomu, pro jaké
typy aplikací jsou čipy společnosti Infineon určeny, asi nepřekvapí, že jsou
v&nbsp;naprosté většině případů vybaveny rozhraním pro sběrnici CAN (<i>CAN
Bus</i>) popř.&nbsp;jednodušší sběrnice LIN a u mnoha mikrořadičů nalezneme i
pomocné &bdquo;koprocesory&ldquo; určené například pro řízení elektrických
motorů apod.</p>

<a href="http://i.iinfo.cz/images/293/pc124-15.jpg"><img src="http://i.iinfo.cz/images/293/pc124-15-prev.jpg" width="360" height="270" alt=" " /></a>
<p><i>Obrázek 1: Dobový vývojový kit s&nbsp;původním mikrořadičem Intel 8051
(MCS-51).</i></p>



<p><a name="k02"></a></p>
<h2 id="k02">2. Osmibitové mikrořadiče založené na 8051</h2>

<p>Některé významné čipy Infineon si v&nbsp;tomto seriálu postupně popíšeme.
Začneme přitom těmi nejméně výkonnými osmibitovými mikrořadiči, které jsou
postaveny na architektuře 8051. Aby byly tyto mikrořadiče použitelné i pro
řídicí účely, jsou vybaveny pomocnými moduly, typicky samostatnou násobičkou a
děličkou, modulem pro algoritmus CORDIC atd. (s&nbsp;velkou pravděpodobností
tyto moduly zabírají větší plochu čipu, než samotné jádro 8051). Díky přidání
pomocných modulů a taktéž navýšením kapacity pamětí pro programový kód a data
je možné čipy s&nbsp;jádrem 8051 nasadit i v&nbsp;těch oblastech, kde by jinak
byl vyžadován výkonnější mikrořadič, ať již osmibitový (<a
href="https://www.root.cz/clanky/rodina-mikroprocesoru-a-mikroradicu-h8/">H8</a>,
<a
href="https://www.root.cz/clanky/osmibitove-mikroradice-s-jadry-s08-a-rs08/">S08</a>),
šestnáctibitový (<a
href="https://www.root.cz/clanky/rodina-mikroprocesoru-a-mikroradicu-h8-rada-300h/">H8-300H</a>,
<a
href="https://www.root.cz/clanky/sestnactibitove-mikroradice-ti-rady-msp430/">MSP430</a>)
či 32bitový (<a
href="https://www.root.cz/clanky/pouziti-mikroradicu-s-jadrem-cortex-m-na-realnych-cipech/">Cortex-M0</a>,
<a
href="https://www.root.cz/clanky/architektura-mikroradicu-s-jadry-arm-cortex-m3/">Cortex-M3</a>,
<a
href="https://www.root.cz/clanky/architektura-mikroradicu-s-jadry-arm-cortex-m4/">Cortex-M4</a>,
<a
href="https://www.root.cz/clanky/nejvykonnejsi-mcu-aneb-architektura-mikroradicu-s-jadry-arm-cortex-m7/">Cortex-M7</a>,
<a
href="https://www.root.cz/clanky/mikroprocesory-a-mikroradice-s-instrukcni-sadou-superh-sh/">SuperH</a>).</p>

<a href="http://i.iinfo.cz/images/293/pc124-18.jpg"><img src="http://i.iinfo.cz/images/293/pc124-18-prev.jpg" width="370" height="184" alt=" " /></a>
<p><i>Obrázek 2: Připojení LCD s&nbsp;rozlišením 128&times;64 pixelů
k&nbsp;mikrořadiči 8051.</i></p>

<p>Již na tomto místě si však musíme říct, že největší nevýhody 8051 vlastně
vůbec nebyly odstraněny, což se týká jak omezeného adresního prostoru, tak i
malého množství pracovních registrů (jedná se akumulátorovou architekturu,
takže často musí docházet k&nbsp;přesunům dat, i když se další výrobci klonů
8051 snažili rozšířit instrukční soubor a toto omezení obejít), nízké kapacity
zásobníku a jen velmi jednoduchých adresovacích režimů (zejména se to týká
použití šestnáctibitových adres, kde lze použít jediný adresní registr). To vše
se negativně projevuje především při programování v&nbsp;céčku či
v&nbsp;dalších vyšších programovacích jazycích.</p>

<a href="http://i.iinfo.cz/images/293/pc124-19.jpg"><img src="http://i.iinfo.cz/images/293/pc124-19-prev.jpg" width="370" height="185" alt=" " /></a>
<p><i>Obrázek 3: &bdquo;Zbastlený&ldquo; video výstup založený na přímém
programovém ovládání tří signálů &ndash; LUMINANCE (světlost), BLANK (interval
v&nbsp;němž je obraz zatemněný &ndash; okraje a návrat paprsku) a SYNC
(synchronizační impuls) mikrořadičem 8051 (resp.&nbsp;přesněji řečeno jeho
rychlejší variantou). Všechny tři signály jsou pomocí čtveřice rezistorů
smíchány a tvoří tak vstup (kompozitní video bez barvonosné složky) pro
televizor pracující v&nbsp;normě PAL, SECAM či NTSC.</i></p>



<p><a name="k03"></a></p>
<h2 id="k03">3. Řada XC800, rodina A a I</h2>

<p>Mezi mikrořadiče s&nbsp;jádry založenými na 8051 patří především řada čipů
nazvaná <i>XC800</i>. Tyto čipy jsou rozděleny do dvou velkých rodin: <i>XC800
A-Family</i> a <i>XC800 I-Family</i>. A-Family obsahuje mikrořadiče určené pro
automobilový průmysl (<i>A</i> značí <i>automotive</i>), zatímco do I-Family
patří čipy pro průmyslovou automatizaci (<i>I</i> značí <i>industry</i>). Jak
jsme si již řekli <a href="#k03">v&nbsp;předchozí kapitole</a>, jsou tyto
mikrořadiče postaveny na jádru 8051, které ovšem bylo vylepšeno a při shodné
hodinové frekvenci by bylo šestkrát výkonnější, než původní Intel 8051 (ve
skutečnosti však čipy Infineon používají vyšší hodinové frekvence, typicky 24
až 27 MHz podle konkrétního typu čipu). Okolo vylepšeného jádra 8051 byly
přidány další moduly, které na původních mikrořadičích Intel 8051 a Intel 8052
nenajdeme. Typicky se jedná o sériové sběrnice a porty SPI, I<sup>2</sup>C,
většinou i CAN Bus (<i>Controller Area Network</i>) a/nebo poněkud jednodušší a
levnější LIN (<i>Local Interconnect Network</i>). Dále většina čipů řady XC800
obsahuje i vícekanálový A/D převodník s&nbsp;rozlišením deseti bitů, větší
kapacitu RAM i ROM a možnost použít paměť Flash jak pro program, tak i pro data
(viz navazující kapitoly). Nesmíme zapomenout ani na &bdquo;koprocesory&ldquo;,
jejichž popisu je věnována druhá polovina dnešního článku.</p>

<p>Čipy XC800 mohou být na jedné straně připojeny ke sběrnici CAN, na straně
druhé pak mohou přímo ovládat k&nbsp;nim připojená zařízení, a to přes SPI,
SSI, I<sup>2</sup>C a paralelní porty, číst stav čidel (jak digitálních, tak i
analogových) apod.</p>



<p><a name="k04"></a></p>
<h2 id="k04">4. Moduly mikrořadičů řady XC800</h2>

<p>Na následujícím obrázku jsou zobrazeny všechny základní moduly mikrořadičů
XC800 postavené okolo mikroprocesorového jádra založeného na 8051. Moduly jsou
rozděleny podle své funkce, nikoli podle toho, jakým způsobem jsou interně
zapojeny (interně čip obsahuje několik sběrnic atd.). Povšimněte si mnohých
rozšíření oproti &bdquo;klasickým&ldquo; starodávným mikrořadičům 8051.
Nalezneme zde více bloků paměti (navíc s&nbsp;mnohem vyšší kapacitou), větší
množství časovačů včetně šestnáctibitového watchdogu, sériové sběrnice a porty,
A/D převodníky, dva paralelní porty navíc a taktéž koprocesory nazvané
<i>MDU</i> a <i>CORDIC</i>:</p>

<a href="https://www.root.cz/obrazek/280299/"><img src="https://i.iinfo.cz/images/635/xc800-1-prev.png" class="image-280299" alt="&#160;" width="370" height="166" /></a>
<p><i>Obrázek 4: Základní moduly mikrořadičů XC800.</i></p>

<p>Význam některých použitých zkratek:</p>

<ol>

<li><i>BootROM</i> jediná skutečná ROM s&nbsp;uloženým programovým kódem pro
inicializaci MCU, spuštění ladění atd. Zbylá část programu je uložena
v&nbsp;paměti Flash. Typická velikost BootROM je 8KB.</li>

<li><i>Flash</i> je význačná tím, že se v&nbsp;ní používají ECC umožňující
opravit jednobitovou chybu v&nbsp;každém bajtu a odhalit dva chybné bity.
Typická kapacita dosahuje 52 až 64 KB.</li>

<li><i>XRAM</i> je běžný blok paměti RAM, která může být adresovaná buď jako
programová paměť nebo jako externí datová paměť. Jedná se o jediný blok paměti,
který je však dostupný jak přes instrukci <strong>MOVX</strong>, tak i
instrukcí <strong>MOVC</strong>. Původní význam zkratky XRAM je External RAM,
zde se však jedná o RAM umístěnou přímo na mikrořadiči.</li>

<li><i>UART</i> klasický sériový port s&nbsp;asynchronním přenosem dat a
konfigurovatelným počtem datových bitů, délky stop bitu, výpočtu parity
atd.</li>

<li><i>SSP (Synchronous Serial Port)</i> řadič podporující sběrnici <i>SPI</i>
i sériové rozhraní <i>SSI</i>.</li>

<li><i>SPI (Serial Peripheral Interface)</i> standardní <a
href="https://www.root.cz/clanky/externi-seriove-sbernice-spi-a-i2c/#k02">sériová
sběrnice</a>.</li>

<li><i>SSI (Synchronous Serial Interface)</i> jednodušší sériové rozhraní pro
jednosměrný přenos dat.</li>

<li><i>CAN (Controller Area Network)</i> je průmyslová sběrnice často používaná
v&nbsp;automotive i v&nbsp;průmyslových aplikacích.</li>

<li><i>MDU (Multiplication/Division Unit)</i> je koprocesor, který bude popsán
<a href="#k07">v&nbsp;sedmé kapitole</a>.</li>

<li><i>CORDIC (COrdinate Rotation DIgital Computer)</i> je koprocesor, který
bude popsán <a href="#k09">v&nbsp;deváté kapitole</a>.</li>

</ol>



<p><a name="k05"></a></p>
<h2 id="k05">5. Vylepšené jádro 8051</h2>

<p>Vylepšené jádro použité v&nbsp;mikrořadičích XC800, které je označováno
názvem &bdquo;E-warp&ldquo;, zachovává kompatibilitu s&nbsp;původními čipy
Intel 8051/Intel 8052 jak na binární úrovni, tak i na úrovni zdrojových kódů.
Došlo ovšem k&nbsp;vylepšení interní struktury, takže běžné instrukce se
namísto dvanácti cyklů provedou jen ve dvou cyklech (šestinásobné urychlení při
použití stejné hodinové frekvence). Existují ovšem i delší instrukce, konkrétně
instrukce provedené za čtyři cykly (<strong>INC DPTR</strong> protože chybí
16bitová ALU) o dokonce i za osm cyklů (<strong>MUL AB</strong> a <strong>DIV
AB</strong>, mimochodem tyto instrukce na původním 8051 trvaly 48 cyklů, takže
se stále jedná o šestinásobné urychlení). Nová a tím pádem i zpětně
nekompatibilní instrukce existuje jen jedna: <strong>MOVC @(DPTR++),
A</strong>, která je mapována na kód 0xA5, který původně nebyl použit
(v&nbsp;tabulce umístěné pod tímto odstavcem je tento kód reprezentován
prázdnou červenou buňkou).</p>

<a href="http://i.iinfo.cz/images/679/pc124instrukce.png"><img src="http://i.iinfo.cz/images/679/pc124instrukce-prev.png" width="370" height="185" alt=" " /></a>
<p><i>Obrázek 5: Instrukční sada mikrořadiče MCS-51.</i></p>

<p>U mikrořadičů 8051 se velké množství operací provádí s&nbsp;osmibitovým
akumulátorem <strong>A</strong>, jedním z&nbsp;pracovních registrů
<strong>R0</strong> až <strong>R7</strong>, popř.&nbsp;s&nbsp;buňkou paměti
adresovanou registrem <strong>R0</strong> či <strong>R1</strong>. Navíc je však
možné mnoho operací provádět přímo s&nbsp;paměťovými buňkami v&nbsp;interní
paměti údajů nebo s&nbsp;registry speciálních funkcí (SFR); existuje například
instrukce typu <strong>MOV adresa, #osmibitová_data</strong>, kterou lze
naplnit libovolnou buňku interní RAM (ležící na adresách 0x00 až 0x7f)
popř.&nbsp;SFR.</p>

<p>Kvůli tomu, že rozsah takzvané &bdquo;externí paměti&ldquo; RAM může
v&nbsp;případě původního 8051 nabývat až kapacity 64 kB, je množina pracovních
registrů doplněna o šestnáctibitový registr <strong>DPTR</strong> (<i>Data
Pointer</i>), do něhož lze přímo načíst šestnáctibitovou konstantu instrukcí
<strong>MOV DPTR, #šestnáctibitová_data</strong>, popř.&nbsp;zvýšit jeho
hodnotu o jedničku pomocí instrukce <strong>INC DPTR</strong>, což je užitečné
například při procházení polem.</p>



<p><a name="k06"></a></p>
<h2 id="k06">6. Paměťový subsystém</h2>

<p>Paměťový subsystém čipů XC800 je poměrně složitý, což vyplývá z&nbsp;omezení
samotné architektury 8051. Relativní složitost uspořádání pamětí a adresovacích
režimů vynikne zejména při porovnání s&nbsp;některými dalšími (novějšími)
osmibitovými mikrořadiči, například s&nbsp;čipy H8. Původní mikrořadiče 8051
totiž obsahovaly interní paměť údajů o kapacitě pouhých 128 bajtů
(v&nbsp;případě modelu 8052 dokonce &bdquo;celých&ldquo; 256 bajtů), ke které
byla navíc připojena paměťová oblast o velikosti taktéž 128 bajtů, do níž byly
mapovány registry speciálních funkcí (SFR). Prvních 128 bajtů RAM je dostupných
přímo; z&nbsp;pohledu programátora se jedná o adresy 0x00 až 0x7f.</p>

<p>Do adresového rozsahu 0x80 až 0xff, tj.&nbsp;do 128 bajtů ležících za pamětí
údajů, je namapována oblast takzvaných <i>registrů speciálních funkcí</i>
neboli <i>SFR (Special Function Registers)</i>. Jedná se o registry, pomocí
nichž se konfigurují různé moduly mikrořadiče Intel 8051, například
čítače/časovače, sériový port a paralelní porty, nebo jsou v&nbsp;nich naopak
uloženy různé příznaky a data naplňovaná samotným mikrořadičem, zejména příznak
přetečení čítače/časovače, znak přijatý sériovým portem, stav jednotlivých
přerušení atd. Mezi registry speciálních funkcí patří i samotný akumulátor
<strong>A/ACC</strong> uložený na adrese 0xe0, pomocný registr
<strong>B</strong> na adrese 0xf0, který je používán při násobení a dělení,
stavové slovo programu <strong>PSW</strong> či ukazatel na vrchol zásobníku
<strong>SP</strong>. Některé registry speciálních funkcí jsou dostupné pouze
jako celistvé bajty, tj.&nbsp;jejich obsah lze načíst například instrukcí
<strong>mov A,direct</strong>, ovšem několik těchto registrů lze alternativně
adresovat i po jednotlivých bitech, podobně jako oblast 128 bitů (16 bajtů)
v&nbsp;paměti údajů (tyto registry jsou součástí Boolovského procesoru).</p>

<a href="http://i.iinfo.cz/images/293/pc124-13.png"><img src="http://i.iinfo.cz/images/293/pc124-13-prev.png" width="370" height="217" alt=" " /></a>
<p><i>Obrázek 6: Obsah speciálních funkčních registrů zobrazený
v&nbsp;emulátoru J51.</i></p>

<p>Přístup k&nbsp;paměti údajů (tj.&nbsp;ke 128 bajtům na adresách 0x00 až
0x7f) i k&nbsp;registrům speciálních funkcí (128 bajtů na adresách 0x80 až
0xff) je jednoznačný v&nbsp;případě mikrořadiče <i>Intel 8051</i>, ovšem u
mikrořadiče <i>Intel 8052</i> museli jeho konstruktéři vyřešit, jakým způsobem
bude adresování probíhat ve chvíli, kdy má paměť údajů kapacitu 256 bajtů
namísto 128 bajtů, a adresy v&nbsp;instrukčních slovech mají pouze osmibitovou
délku. Řešení tohoto problému spočívá v&nbsp;tom, že horních 128 bajtů paměti
údajů je dostupných pouze při nepřímé adresaci (tj.&nbsp;použití instrukcí
s&nbsp;operandy <strong>@R0</strong> a <strong>@R1</strong>), zatímco dolních
128 bajtů paměti údajů a 128 bajtů se SFR je dostupných při adresaci přímé.</p>

<p>Situace se dále komplikuje v&nbsp;případě, že je k&nbsp;interní paměti údajů
navíc připojena paměť externí, musí se použít plná šestnáctibitová adresa,
která je uložená v&nbsp;šestnáctibitovém registru <strong>DPTR</strong>
(<i>Data Pointer</i>), popř.&nbsp;osmibitová adresa uložená v&nbsp;registru
<strong>R0</strong> či <strong>R1</strong>, ovšem horních osm bitů adresy musí
být při provedení instrukce &bdquo;vystaveno&ldquo; na portu číslo 2.</p>

<p>Poznámka: &bdquo;externí paměť&ldquo; je sice stále používaný termín, ovšem
na XC800 je i tato paměť umístěna na stejném čipu.</p>

<p>Programová paměť je z&nbsp;tohoto hlediska jednodušší, protože se může
jednat o jediný blok o velikosti 64 kB (původně jen 4 kB).</p>

<p>Konstruktéři čipů XC800 museli tyto vlastnosti původních mikrořadičů 8051 a
8052 brát v&nbsp;úvahu aby dodrželi zpětnou kompatibilitu. Proto navrhli systém
paměťových banků, který vlastně známe i z&nbsp;mnoha dalších typů
mikroprocesorů. Čipy XC800 totiž adresují až 1 MB paměti, která je rozdělena do
banků o velikosti 64 kB (takových banků je šestnáct). Banky se používají jak
pro programovou paměť, tak i pro paměť datovou. O přepínání banků se stará
modul <i>MMU</i> neboli <i>Memory Management Unit</i>, který obsahuje trojici
čtyřbitových registrů: <strong>CB</strong> (<i>Current Bank</i>),
<strong>NB</strong> (<i>Next Bank</i>) a <strong>IB</strong> (<i>Interrupt
Bank</i>).</p>

<p>Navíc se musí dodržet zpětná kompatibilita při přechodu mezi paměťovými
banky, což znamená, že relativní skoky nikdy bank nemění (pro tyto skoky paměť
stále končí na hranici 64 kB; chudáci programátoři překladačů). Jediné
instrukce, které bank mohou přepnout, jsou instrukce LJMP, LCALL a ACALL, u
datové paměti je přepnutí vždy explicitní. Navíc došlo k&nbsp;další změně
&ndash; zásobník o velikosti 128 bajtů může být umístěn kdekoli
v&nbsp;paměťovém rozsahu 1 MB, není tedy nutné, aby zabíral cenné bajty
v&nbsp;prvních dvou oblastech RAM (to sice není zpětně kompatibilní chování,
ale v&nbsp;případě potřeby lze zajistit původní umístění zásobníku).</p>

<p>O bloku XRAM jsme se již zmínili &ndash; ta je namapována do datového
prostoru v&nbsp;banku 2 a v&nbsp;programovém prostoru v&nbsp;posledním
šestnáctém banku. Lze ji tedy zpřístupnit jak instrukcí MOVX (přes DPTR či R0
R1) tak i MOVC.</p>



<p><a name="k07"></a></p>
<h2 id="k07">7. Multiplication/Division Unit (MDU)</h2>

<p>Vzhledem k&nbsp;tomu, že instrukce <strong>MUL AB</strong> akceptuje
osmibitové operandy se šestnáctibitovým výsledkem a instrukce <strong>DIV
AB</strong> počítá jen osmibitové výsledky, jsou čipy XC800 doplněny o
samostatně pracující koprocesor nazvaný <i>MDU</i> neboli
<i>Multiplication/Division Unit</i>. Tento obvod tvoří násobička a dělička
pracující nezávisle na CPU, která je doplněna o sadu dvanácti datových
registrů, jednoho řídicího registru a jednoho registru stavového (všechny
registry jsou samozřejmě osmibitové). Kromě operací násobení a dělení dokáže
<i>MDU</i> provést i bitové posuny doleva a doprava a taktéž operaci
&bdquo;normalizace&ldquo; vstupní hodnoty tak, aby nejvyšší bit byl vždy
jedničkový. Tato operace vrací i počet provedených posunů, takže ji lze využít
například při softwarové implementaci FP operací.</p>

<p><i>MDU</i> podporuje tyto operace:</p>

<table>
<tr><th>Operace</th><th>Typ</th><th>Operand 1</th><th>Operand 2</th><th>Výsledek</th><th>Zbytek</th><th>Počet hodinových cyklů</th></tr>
<tr><td>Násobení</td><td>signed</td><td>16bit</td><td>16bit</td><td>32bit</td><td>&times;</td><td>16</td></tr>
<tr><td>Dělení  </td><td>signed</td><td>32bit</td><td>16bit</td><td>32bit</td><td>16bit</td><td>33</td></tr>
<tr><td>Dělení  </td><td>signed</td><td>16bit</td><td>16bit</td><td>16bit</td><td>16bit</td><td>17</td></tr>
<tr><td>Násobení</td><td>unsigned</td><td>16bit</td><td>16bit</td><td>32bit</td><td>&times;</td><td>16</td></tr>
<tr><td>Dělení  </td><td>unsigned</td><td>32bit</td><td>16bit</td><td>32bit</td><td>16bit</td><td>32</td></tr>
<tr><td>Dělení  </td><td>unsigned</td><td>16bit</td><td>16bit</td><td>16bit</td><td>16bit</td><td>16</td></tr>
<tr><td>Normalizace</td><td>&times;</td><td>&times;</td><td>&times;</td><td>&times;</td><td>&times;</td><td>1&ndash;32</td></tr>
<tr><td>Posun L/R</td><td>&times;</td><td>&times;</td><td>&times;</td><td>&times;</td><td>&times;</td><td>1&ndash;32</td></tr>
</table>

<p>Tento modul obsahuje následující registry:</p>

<table>
<tr><th>Registr</th><th>Význam</th></tr>
<tr><td>MDUSTAT</td><td>stavový registru modulu</td></tr>
<tr><td>MDUCON </td><td>řídicí registr, obsahuje mj. i kód prováděné operace a příznak, že se operace provádí (nuluje se automaticky)</td></tr>
<tr><td>MD0</td><td>registr pro vstupní operand</td></tr>
<tr><td>MR0</td><td>registr pro uložení výsledku</td></tr>
<tr><td>MD1</td><td>-//-</td></tr>
<tr><td>MR1</td><td>-//-</td></tr>
<tr><td>MD2</td><td>-//-</td></tr>
<tr><td>MR2</td><td>-//-</td></tr>
<tr><td>MD3</td><td>-//-</td></tr>
<tr><td>MR3</td><td>-//-</td></tr>
<tr><td>MD4</td><td>-//-</td></tr>
<tr><td>MR4</td><td>-//-</td></tr>
<tr><td>MD5</td><td>-//-</td></tr>
<tr><td>MR5</td><td>-//-</td></tr>
</table>

<p>Příklady použití těchto registrů:</p>

<pre>
násobení 16bit &times; 16bit &rarr; 32bit:           MD1:MD0 &times; MD5:MD4 &rarr; MR3:MR2:MR1:MR0
dělení:  32bit &div; 16bit &rarr; 16bit (+zbytek): MD3:MD2:MD1:MD0 &div; MD5:MD5 &rarr; MR5:MR4 zbytek MR3:MR0
</pre>

<p>Poznámka: MDU lze zcela vypnout a snížit tak spotřebu celého čipu.</p>



<p><a name="k08"></a></p>
<h2 id="k08">8. Field Oriented Control (FOC)</h2>

<p>Důležitou součástí většiny mikrořadičů řady XC800 je modul nazvaný
<i>FOC</i> neboli <i>(Sensorless) Field Oriented Control</i><sup>*</sup>. Tento
modul je, jak již jeho název napovídá, určený pro přesné řízení synchronních
elektrických motorů (či mnohdy spíše motorků) s&nbsp;permanentními magnety
v&nbsp;rotoru (PMSM &ndash; Permanent Magnet Synchronous Motor). Na rozdíl od
krokových motorků vyžadují PMSM pro přesné řízení bez vzniku vibrací a zbytečně
velkého namáhání hřídele vytvoření točivého magnetického pole ideálně se
sinusovým průběhem. A právě pro vytvoření trojice analogových signálů se
sinusovým průběhem a vzájemným fázovým posunem 120&deg;, které navíc reaguje na
zatížení atd. je určen <i>FOC</i>. Interní struktura tohoto modulu je poměrně
složitá, ovšem nám postačuje vědět, že na vstupu je zapotřebí specifikovat
referenční rychlost a na výstupu modulu <i>FOC</i> se analogové signály
generují s&nbsp;využitím <i>PWM</i> (pulsně-šířkové modulace). Modul navíc musí
zjišťovat aktuální polohu rotoru měřením proudu protékajícího statorem, takže
obsahuje rychlý A/D převodník zapojený na výstup operačního zesilovače.</p>



<p><a name="k09"></a></p>
<h2 id="k09">9. Algoritmus CORDIC (COrdinate Rotation DIgital Computer)</h2>

<p>Velmi zajímavé je zařazení koprocesoru s&nbsp;implementovaným algoritmem
<i>CORDIC (COrdinate Rotation DIgital Computer)</i>. I zde se ukazuje, že
autoři mikrořadičů XC800 zvolili řešení založené na relativně primitivním jádře
8051 vybaveném specializovanými moduly oproti obecnému rychlejšímu jádru, které
by výpočty řešilo programově. Vraťme se však k&nbsp;CORDICu.</p>

<p>Jedná se o výpočetní metodu využívající iteraci, kterou pro účely
jednoduchého a rychlého výpočtu goniometrických funkcí bez použití násobiček a
děliček navrhl a zpopularizoval Jack Volder už v&nbsp;polovině minulého
století. Později se ukázalo, že tuto metodu je možné po malých úpravách použít
i pro výpočty dalších matematických funkcí, například arkustangenty, arkussinu,
arkuskosinu, ale i pro vyčíslení délky vektoru či jeho rychlou rotaci o
libovolný úhel; včetně transformace bodu či vektoru z&nbsp;polárních souřadnic
do souřadnic kartézských. Již větší úpravy si vyžádala aplikace metody CORDIC
pro výpočet hyperbolických funkcí (<i>sinh()</i>, <i>cosh()</i>, <i>tanh()</i>)
a funkcí logaritmických, základní myšlenka a princip práce však zůstává
stejný.</p>

<p>Vzhledem k&nbsp;tomu, že se při aplikaci algoritmu CORDIC využívají pouze ty
nejzákladnější matematické operace (bitový posun doleva a doprava, sečítání,
odečítání a porovnání dvou hodnot), je možné CORDIC využít ve všech číslicových
systémech, ve kterých je zapotřebí šetřit použitými prostředky, tj.&nbsp;počtem
logických hradel, kapacitou obsazené paměti, možnostmi použitých čipů atd.
CORDIC tak byl implementován a s&nbsp;úspěchem používán například
v&nbsp;kalkulačkách, osmibitových mikrořadičích (řada Intel 8051 a Motorola
68HC11), osmibitových domácích počítačích (Atari, Sinclair ZX Spectrum atd.) a
mnoha specializovaných obvodech vytvořených pomocí programovatelných polí FPGA.
Zajímavá je implementace CORDICu na mikrořadičové stavebnici Basic STAMP.
V&nbsp;největší míře však bylo CORDICu využito v&nbsp;některých matematických
koprocesorech (FPU), protože bylo zjištěno, že některé funkční bloky
zabezpečující chod CORDICu zůstávají stále stejné, bez ohledu na to, jaká
funkce je počítána, což do značné míry zjednodušilo (a tím pádem i zlevnilo)
výrobu FPU. Samozřejmě se také snížil počet hradel nutných pro implementaci
goniometrických, hyperbolických a logaritmických funkcí.</p>

<ol>

<li>Andraka, Ray: <i>"A survey of CORDIC algorithms for FPGA based computers"</i>,<br />ACM, 1998</li>
<li>Despain, A.M.:<i>"Fourier Transform Computations Using CORDIC Iterations"</i>,<br />IEEE Transactions on Computers, Volume 23, strany 993-1001, 1974</li>
<li>Mazenc C., Merrheim, X., Muller, J.M.: <i>"Computing Functions Arccos and Arcsin Using CORDIC"</i>,<br />IEEE Transactions on Computers, Volume 42, strany 118-122, 1993</li>
<li>Volder, Jack: <i>"Binary computation algorithms for coordinate rotation and function generation"</i>,<br />Convair Report IAR-1, 1956</li>
<li>Volder, Jack: <i>"The CORDIC Trigonometric Computing Technique"</i>,<br />IRE Transactions on Electronic Computing, Vol EC-8, strany 330-334, 1959</li>
<li>NVIDIA Corporation: <i>"Floating-Point Specials on the GPU"</i>,<br />2005</li>

</ol>



<p><a name="k10"></a></p>
<h2 id="k10">10. Princip CORDICu: rotace vektoru r okolo počátku souřadného systému</h2>

<p>Princip práce algoritmu CORDIC vychází z&nbsp;vyjádření rotace vektoru o
určitý úhel <i>&delta;</i> a z&nbsp;následné úpravy vzorce pro rotaci tak, aby
se eliminovaly zbytečně složité a časově náročné multiplikativní operace.
Nejprve si napišme vzorce pro hodnoty funkcí sinus a kosinus součtu dvou úhlů.
Jedná se o známé středoškolské vztahy používané pro úpravu výrazů
s&nbsp;goniometrickými funkcemi:</p>

<p><i>sin(&alpha;+&beta;)=sin &alpha; cos &beta; + cos &alpha; sin &beta;</i><br />
<i>cos(&alpha;+&beta;)=cos &alpha; cos &beta; - sin &alpha; sin &beta;</i></p>

<p>Jak si ukážeme o několik odstavců níže, je možné tyto vzorečky použít pro
vyjádření rotace vektoru. Vektor <strong>r</strong>, kterým budeme rotovat,
může být vyjádřen souřadnicemi <i>[x<sub>0</sub>, y<sub>0</sub>]</i>, přičemž
je možné provést převod z&nbsp;kartézských souřadnic do souřadnic
polárních:</p>

<p><i>x<sub>0</sub>=r cos &phi;</i><br />
<i>y<sub>0</sub>=r sin &phi;</i></p>

<p>kde <i>r</i> představuje délku vektoru <strong>r</strong> a <i>&phi;</i> je
úhel vektoru měřený od kladné horizontální poloosy souřadného systému. Pokud
bude vektor <strong>r</strong> rotován o úhel <i>&delta;</i>, změní se koncový
bod vektoru tak, že bude ležet na kružnici o stejném poloměru <i>r</i>, ale
úhel vektoru (opět měřený od kladné horizontální poloosy) se zvětší o
<i>&delta;</i>. Tuto skutečnost je možné vyjádřit vztahy:</p>

<p><i>x<sub>r</sub>=r cos (&phi;+&delta;)</i><br />
<i>y<sub>r</sub>=r sin (&phi;+&delta;)</i></p>

<p>Dále je možné rozepsat výrazy <i>cos (&phi;+&delta;)</i> a <i>sin
(&phi;+&delta;)</i> podle prvních dvou uvedených vzorečků a následně zpětně
dosadit za výrazy <i>r cos &phi;</i> a <i>r sin &phi;</i> původní souřadnice
vektoru <strong>r</strong>, tj.&nbsp;<i>x<sub>0</sub></i> a
<i>y<sub>0</sub></i>:</p>

<p><i>x<sub>r</sub>=r (cos &phi; cos &delta; - sin &phi; sin &delta;)=x<sub>0</sub> cos &delta; - y<sub>0</sub> sin &delta;</i><br />
<i>y<sub>r</sub>=r (sin &phi; cos &delta; + cos &phi; sin &delta;)=x<sub>0</sub> sin &delta; + y<sub>0</sub> cos &delta;</i></p>

<p>Všimněte si, že se ve výsledných vztazích nevyskytuje ani hodnota <i>r</i>
ani úhel původního vektoru <i>&phi;</i>. To znamená, že převod na polární
souřadnice pro nás byl pouze matematickou pomůckou při odvozování vzorce pro
rotaci a ve skutečnosti se nebude nikdy provádět.</p>



<p><a name="k11"></a></p>
<h2 id="k11">11. Úprava vztahu rotace vektoru pro algoritmus CORDIC</h2>

<p>Pro účely algoritmu CORDIC se tento vztah dále upravuje. První úprava
spočívá v&nbsp;tom, že se obě rovnice vydělí hodnotou <i>cos &delta;</i>, takže
dostaneme vztahy:</p>

<p><i>x<sub>r</sub> /cos &delta;=x<sub>0</sub> - y<sub>0</sub> sin &delta;/cos &delta;</i><br />
<i>y<sub>r</sub> /cos &delta;=x<sub>0</sub> sin &delta;/cos &delta; + y<sub>0</sub></i></p>

<p>Pokud si uvědomíme skutečnost, že <i>sin &delta;/cos &delta;=tan
&delta;</i>, můžeme pokračovat v&nbsp;úpravách:</p>

<p><i>x<sub>r</sub> /cos &delta;=x<sub>0</sub> - y<sub>0</sub> tan &delta;</i><br />
<i>y<sub>r</sub> /cos &delta;=y<sub>0</sub> + x<sub>0</sub> tan &delta;</i></p>

<p>a následně:</p>

<p><i>x<sub>r</sub>=cos &delta;(x<sub>0</sub> - y<sub>0</sub> tan &delta;)</i><br />
<i>y<sub>r</sub>=cos &delta;(y<sub>0</sub> + x<sub>0</sub> tan &delta;)</i></p>

<p>Nyní přichází základní myšlenka, na které je CORDIC postaven. Pokud budeme
volit úhel <i>&delta;</i> takovým způsobem, aby jeho tangenta nabývala hodnot
<i>2<sup>-i</sup></i> (pro <i>i&gt;0</i>), je možné tangentu ve vzorci nahradit
násobením zvolenou hodnotou <i>2<sup>-i</sup></i>; v&nbsp;tomto případě je však
možné násobení nahradit jednoduchým a přitom rychlým bitovým posunem. Omezení
hodnoty tangenty na zvolenou sadu hodnot však znamená, že se vektor nemůže
rotovat o libovolný úhel, ale pouze o úhel odpovídající tangentě z&nbsp;dané
sady. To však není problém, protože rotaci o libovolný je možné zapsat pomocí
série rotací (doprava či doleva), například:</p>

<p><i>&delta;=&delta;<sub>1</sub>+&delta;<sub>2</sub>-&delta;<sub>3</sub>+...</i></p>

<p>Naproti tomu, že se parciální rotace mohou provádět v&nbsp;obou směrech
(tj.&nbsp;jak doprava, tak i doleva), můžeme místo hodnoty <i>cos &delta;</i>
dosadit konstantu <i>K<sub>i</sub></i>, protože platí <i>cos &delta;=cos
-&delta;</i>. Nakonec místo <i>tan &delta;</i> přímo dosadíme mocninu dvojky
<i>2<sup>-i</sup></i> a pomocí parametru <i>d<sub>i</sub></i> směr rotace
(parametr <i>d<sub>i</sub></i> nabývá pouze hodnot +1 a -1):</p>

<p><i>x<sub>r</sub>=K<sub>i</sub> (x<sub>0</sub> - y<sub>0</sub> d<sub>i</sub> 2<sup>-i</sup>)</i><br />
<i>y<sub>r</sub>=K<sub>i</sub> (y<sub>0</sub> + x<sub>0</sub> d<sub>i</sub> 2<sup>-i</sup>)</i></p>

<p>Zbývá nám zjistit hodnotu konstanty <i>K<sub>i</sub></i>. Platí:</p>

<p><i>K<sub>i</sub>=cos (arctan 2<sup>-i</sup>)=1/(1+2<sup>-2i</sup>)<sup>1/2</sup></i></p>

<p>Limitně se součin hodnot <i>K<sub>i</sub></i> (po nekonečně mnoha iteracích) blíží
k&nbsp;<strong>0,6073</strong>, to znamená, že touto hodnotou bude
v&nbsp;některých případech nutné vydělit výsledek (v&nbsp;jiných případech nám
naopak toto <i>zesílení</i> při rotaci vadit nebude).</p>

<p>Veškerá práce algoritmu CORDIC spočívá v&nbsp;tom, že se nastaví počáteční
souřadnice vektoru <strong>r</strong> a iterativně se provádí rotace o předem
známé úhly <i>&delta;<sub>1</sub>...&delta;<sub>n</sub></i> tak, aby se dosáhlo
požadované hodnoty rotace <i>&delta;</i>.</p>



<p><a name="k12"></a></p>
<h2 id="k12">12. Hodnoty úhlů, po kterých se provádí rotace</h2>

<p>Jak jsme si uvedli v&nbsp;<a href="#k11">předchozí kapitole</a>, musí
tangenty úhlů použitých v&nbsp;CORDICu splňovat podmínku <i>tan
&delta;=2<sup>-i</sup></i>. Pokud budeme veškeré výpočty provádět v&nbsp;prvním
kvadrantu (ve skutečnosti však může počítat i ve čtvrtém kvadrantu), začíná se
s&nbsp;úhlem 45&deg;, tj.&nbsp;&pi;/4, protože <i>tan &pi;/4=1</i>. Další úhly
jsou samozřejmě menší; o jaké hodnoty se konkrétně jedná, nám dá přehled
následující tabulka:</p>

<table>
<tr><th>i</th><th>2<sup>1-i</sup></th><th>úhel &delta;</th></tr>
<tr><td>1 </td><td>1.0000000000</td><td>45.000000000</td></tr>
<tr><td>2 </td><td>0.5000000000</td><td>26.565051177</td></tr>
<tr><td>3 </td><td>0.2500000000</td><td>14.036243468</td></tr>
<tr><td>4 </td><td>0.1250000000</td><td> 7.125016349</td></tr>
<tr><td>5 </td><td>0.0625000000</td><td> 3.576334375</td></tr>
<tr><td>6 </td><td>0.0312500000</td><td> 1.789910608</td></tr>
<tr><td>7 </td><td>0.0156250000</td><td> 0.895173710</td></tr>
<tr><td>8 </td><td>0.0078125000</td><td> 0.447614171</td></tr>
<tr><td>9 </td><td>0.0039062500</td><td> 0.223810500</td></tr>
<tr><td>10</td><td>0.0019531250</td><td> 0.111905677</td></tr>
</table>



<p><a name="k13"></a></p>
<h2 id="k13">13. Ukázka: výpočet funkcí sin a cos algoritmem CORDIC</h2>

<p>Nyní si na jednoduchém příkladu ukážeme, jakým způsobem je možné algoritmus
CORDIC použít pro výpočet funkcí sinus a kosinus. Nejprve jsou spočteny tabulky
úhlů a hodnota druhých záporných mocnin hodnoty 2. Při implementaci CORDICu na
FPU, MCU či FPGA by se tyto tabulky samozřejmě znovu nevytvářely: tabulka úhlů
by byla uložena v&nbsp;paměti (či masce obvodu) a tabulka mocnin hodnoty 2 by
se implementovala pomocí bitových posunů.</p>

<p>Po vytvoření tabulek je již možné CORDIC spustit. Počáteční souřadnice
vektoru <strong>r</strong> jsou nastaveny na hodnotu <i>[1, 0]</i>. Vektor je
posléze v&nbsp;iterační smyčce rotován tak dlouho, dokud neproběhne daný počet
iterací. Úhel vektoru <strong>r</strong> se přitom neustále přibližuje
k&nbsp;zadanému úhlu <i>&delta;</i>, jelikož se v&nbsp;iterační smyčce
adaptivně zadaný úhel buď zmenšuje či zvětšuje o hodnotu uloženou
v&nbsp;tabulce <i>atans[]</i>. Výsledek, tj.&nbsp;hodnoty funkcí sinus a
kosinus, je uložen v&nbsp;nových souřadnicích vektoru <strong>r</strong>
(vynásobený o konstantu K) a to z&nbsp;toho důvodu, že vektor rotoval na
jednotkové kružnici a souřadnice jakéhokoli bodu ležícího na jednotkové
kružnici přímo odpovídají hodnotám sinu a kosinu úhlu tohoto bodu počítaného od
kladné horizontální poloosy.</p>

<pre>
// --------------------------------------------------------
// Výpočet hodnot funkcí sin() a cos() pomocí iteračního
// algoritmu CORDIC.
// --------------------------------------------------------
&nbsp;
#include &lt;stdio.h&gt;
#include &lt;math.h&gt;
&nbsp;
#ifndef M_PI
#define M_PI 3.14159265358979323846
#endif
&nbsp;
// maximální počet iterací při běhu algoritmu
#define MAX_ITER 10
&nbsp;
// "zesílení" při rotacích
#define K 0.6073
&nbsp;
// tabulka arkustangentu úhlů
double atans[MAX_ITER];
&nbsp;
// tabulka záporných celočíselných mocnin hodnoty 2
double pows[MAX_ITER];
&nbsp;
// naplnění tabulek atans[] a pows[]
void createTables(void)
{
    int i;
    for (i=0; i&lt;MAX_ITER; i++) {
        double p=pow(2.0, -i);
        atans[i]=atan(p);
        pows[i]=p;
    }
}
&nbsp;
// výpočet funkcí sin() a cos() pro zadaný úhel delta
void sincos(double delta, double *sinval, double *cosval)
{
    int i;
    double x0=1.0;                          // nastavení počátečních podmínek
    double y0=0.0;
    double xn;
    for (i=0; i&lt;MAX_ITER; i++) {            // iterační smyčka
        if (delta&lt;0) {                      // úhel je záporný =&gt; rotace doleva
            xn=x0+y0*pows[i];
            y0-=x0*pows[i];
            delta+=atans[i];
        }
        else {                              // úhel je kladný =&gt; rotace doprava
            xn=x0-y0*pows[i];
            y0+=x0*pows[i];
            delta-=atans[i];
        }
        x0=xn;
    }
    *sinval=y0*K;                           // opravit "zesílení" výsledku
    *cosval=x0*K;
}
&nbsp;
int main(void)
{
    int i;
    createTables();
    for (i=0; i&lt;=90; i++) {                 // výpočetní smyčka
        double delta;                       // úhel, ze kterého se počítá sin a cos
        double sinval;                      // vypočtené hodnoty
        double cosval;
        double sinerr;                      // absolutní chyby
        double coserr;
        delta=i*M_PI/180.0;                 // převod úhlu na radiány
        sincos(delta, &amp;sinval, &amp;cosval);    // výpočet sinu a kosinu
        sinerr=fabs(sinval-sin(delta));     // výpočet absolutních chyb
        coserr=fabs(cosval-cos(delta));
                                            // tisk výsledků
        printf("%02d\t%12.10f\t%12.10f\t%12.10f\t%12.10f\t%8.3f%%\t%8.3f%%\n",
                i,
                sinval, cosval,
                sinerr, coserr,
                100.0*sinerr/sinval, 100.0*coserr/cosval);
    }
    return 0;
}
&nbsp;
// finito
</pre>

<p>Výsledek běhu předchozího programu je zobrazen v&nbsp;následující tabulce.
Kromě vypočtených hodnot sinů a kosinů zadaného úhlu je spočtena i absolutní a
relativní chyba, přičemž je zapotřebí upozornit na to, že relativní chyba pro
obě krajní hodnoty (ty by měly vyjít nulové) je poněkud zavádějící.
V&nbsp;každém případě však výsledky běhu algoritmu pro deset iterací nejsou
špatné, zvláště když si uvědomíme, že se v&nbsp;každé iteraci provádělo pouze
několik základních operací, konkrétně dva bitové posuvy a tři součty (či
rozdíly):</p>

<pre>
--------------------------------------------------------------------------------------------------
vstupní   vypočtená       vypočtená       sin             cos              sin               cos
úhel    hodnota sin()   hodnota cos()   absolutní chyba absolutní chyba  rel.chyba       rel.chyba
--------------------------------------------------------------------------------------------------
00      0.0011726802    1.0000761814    0.0011726802    0.0000761814     100.000%          0.008%
01      0.0167806202    0.9999360752    0.0006717863    0.0000883801       4.003%          0.009%
02      0.0363058568    0.9994176447    0.0014063601    0.0000268177       3.874%          0.003%
03      0.0519144682    0.9987285075    0.0004214880    0.0000989728       0.812%          0.010%
04      0.0714093909    0.9975241564    0.0016529171    0.0000398938       2.315%          0.004%
05      0.0858859660    0.9963821278    0.0012697767    0.0001874297       1.478%          0.019%
06      0.1053286152    0.9945147694    0.0008001519    0.0000071260       0.760%          0.001%
07      0.1208522102    0.9927479474    0.0010171332    0.0002017957       0.842%          0.020%
08      0.1401999641    0.9902008452    0.0010268631    0.0000672235       0.732%          0.007%
09      0.1556537948    0.9878894877    0.0007806702    0.0002011471       0.502%          0.020%
...
40      0.6418729918    0.7669112114    0.0009146178    0.0008667682       0.142%          0.113%
41      0.6567280845    0.7542293861    0.0006690555    0.0004801942       0.102%          0.064%
42      0.6684306187    0.7438778473    0.0006999876    0.0007330218       0.105%          0.099%
43      0.6828308344    0.7306817333    0.0008324743    0.0006719683       0.122%          0.092%
44      0.6941513412    0.7199358716    0.0005070292    0.0005960713       0.073%          0.083%
45      0.7062435465    0.7080775359    0.0008632347    0.0009707547       0.122%          0.137%
46      0.7199358716    0.6941513412    0.0005960713    0.0005070292       0.083%          0.073%
47      0.7306817333    0.6828308344    0.0006719683    0.0008324743       0.092%          0.122%
48      0.7438778473    0.6684306187    0.0007330218    0.0006999876       0.099%          0.105%
49      0.7542293861    0.6567280845    0.0004801942    0.0006690555       0.064%          0.102%
50      0.7669112114    0.6418729918    0.0008667682    0.0009146178       0.113%          0.142%
...
81      0.9878894877    0.1556537948    0.0002011471    0.0007806702       0.020%          0.502%
82      0.9902008452    0.1401999641    0.0000672235    0.0010268631       0.007%          0.732%
83      0.9927479474    0.1208522102    0.0002017957    0.0010171332       0.020%          0.842%
84      0.9945147694    0.1053286152    0.0000071260    0.0008001519       0.001%          0.760%
85      0.9963821278    0.0858859660    0.0001874297    0.0012697767       0.019%          1.478%
86      0.9975241564    0.0714093909    0.0000398938    0.0016529171       0.004%          2.315%
87      0.9987285075    0.0519144682    0.0000989728    0.0004214880       0.010%          0.812%
88      0.9994176447    0.0363058568    0.0000268177    0.0014063601       0.003%          3.874%
89      0.9999360752    0.0167806202    0.0000883801    0.0006717863       0.009%          4.003%
90      1.0000761814    0.0011726802    0.0000761814    0.0011726802       0.008%        100.000%
</pre>



<p><a name="k14"></a></p>
<h2 id="k14">14. CORDIC a formát pevné řádové čárky</h2>

<p>Ve skutečnosti se CORDIC prakticky vždy implementuje takovým způsobem, že se
nepoužívají hodnoty typu <i>double</i>, ale formát s&nbsp;pevnou řádovou
čárkou. Násobení hodnotami z&nbsp;tabulky <strong>pows</strong> se nahradí
bitovým posunem, takže se v&nbsp;iterační smyčce používají jen základní
operace: součet, rozdíl a bitové posuny, <a
href="https://github.com/tisnik/presentations/blob/master/cordic/fx.c">zhruba
takto</a>:</p>

<pre>
/* datový typ, se kterým budeme pracovat */
typedef signed int fx;
&nbsp;
/* výpočet funkce sin() pro zadaný úhel delta */
fx fx_sin_cordic_optim_iter(fx delta, int iter)
{
    int i;
    static fx K_fx=(fx)(K_float*(2&lt;&lt;(B-1)));
    /* nastavení počátečních podmínek */
    fx x0=int2fx(1);
    fx y0=0;
    fx xn;
    for (i=0; i&lt;iter; i++) {                /* iterační smyčka */
        if (delta&lt;0) {                      /* úhel je záporný =&gt; rotace doleva */
            xn=x0 + y0&gt;&gt;i;                  /* místo násobení bitový posuv */
            y0-=x0&gt;&gt;i;
            delta+=atans[i];
        }
        else {                              /* úhel je kladný =&gt; rotace doprava */
            xn=x0 - y0&gt;&gt;i;
            y0+=x0&gt;&gt;i;
            delta-=atans[i];
        }
        x0=xn;
    }
    return fx_mul(y0, K_fx);                /* opravit "zesílení" výsledku */
}
</pre>

<p>Podobným způsobem je CORDIC implementován v&nbsp;koprocesoru mikrořadiče
XC800.</p>



<p><a name="k15"></a></p>
<h2 id="k15">15. CORDIC na čipech XC800</h2>

<p>Mikrořadiče XC800 obsahují koprocesor pro výpočet hodnot různých funkcí
s&nbsp;využitím algoritmu CORDIC, který je zde parametrizovatelný a umožňuje
používat nejenom předpočítané hodnoty funkce <strong>atan</strong> (rotace tak,
jak je chápána v&nbsp;Euklidovské geometrii), ale <strong>atanh</strong>
(rotace v&nbsp;hyperbolické geometrii) a lineární funkci (ta se hodí při
násobeních a děleních). Počet iterací při výpočtu dosahuje šestnácti kroků, což
je pro většinu použití plně dostačuje, a to jak z&nbsp;hlediska přesnosti
výsledku, tak i doby trvání výpočtu. Navíc je možné zvolit rychlost výpočtů
&ndash; buď se použije původní hodinový signál či signál vynásobený dvěma
(pravděpodobně se provede synchronizace na obě hrany signálu). Při použití
dvojnásobné rychlosti výpočtu a šestnácti iterací je výpočet dokončen
v&nbsp;přibližně 41 cyklech, což je hodnota, která by nebyla čistě softwarovými
prostředky vůbec možná, zvláště s&nbsp;ohledem na to, že výsledek je 16bitový a
mezivýpočty jsou prováděny s&nbsp;přesností 20 bitů.</p>

<p>Hodnoty e<sub>i</sub> jsou vybírány z&nbsp;tabulky hodnot funkcí
<strong>atan</strong> či <strong>atanh</strong> podle postupu popsaného
v&nbsp;předchozích kapitolách. Pro klasický CORDIC je m=1, pro hyperbolickou
geometrii je m=-1.</p>

<p>Tabulky hodnot funkcí <strong>atan</strong> a <strong>atanh</strong>
obsahují slova široká dvacet bitů; interně je použit formát FX (fixed point)
s&nbsp;devatenácti bity za řádovou čárkou (tečkou).</p>

<p>Komunikace s&nbsp;koprocesorem CORDIC probíhá přes několik registrů. Samotný
koprocesor pracuje nezávisle na CPU (který může jednoduše zjistit, zda již
došlo k&nbsp;dokončení výpočtu či zda je dostupný pouze mezivýsledek):</p>

<table>
<tr><th>Registr</th><th>Význam</th></tr>
<tr><td>CD_CORDxL</td><td>použit pro zápis prvotní hodnoty X pro algoritmus CORDIC</td></tr>
<tr><td>CD_CORDxH</td><td>dtto, ovšem obsahuje horních osm bitů</td></tr>
<tr><td>&nbsp;</td><td>&nbsp;</td></tr>
<tr><td>CD_CORDYL</td><td>podobný význam, ovšem pro hodnotu Y</td></tr>
<tr><td>CD_CORDYH</td><td>podobný význam, ovšem pro hodnotu Y</td></tr>
<tr><td>&nbsp;</td><td>&nbsp;</td></tr>
<tr><td>CD_CORDZL</td><td>podobný význam, ovšem pro hodnotu Z</td></tr>
<tr><td>CD_CORDZH</td><td>podobný význam, ovšem pro hodnotu Z</td></tr>
<tr><td>&nbsp;</td><td>&nbsp;</td></tr>
<tr><td>CD_STATC </td><td>stavový a datový registr, viz další tabulku</td></tr>
<tr><td>CD_CON   </td><td>řídicí registr</td></tr>
</table>



<p><a name="k16"></a></p>
<h2 id="k16">16. Odkazy na Internetu</h2>

<ol>

<li>XC800 family<br />
<a href="https://en.wikipedia.org/wiki/XC800_family">https://en.wikipedia.org/wiki/XC800_family</a>
</li>

<li>Permanent Magnet Synchronous Motor<br />
<a href="https://en.wikipedia.org/wiki/Synchronous_motor#Permanent_magnet_motors">https://en.wikipedia.org/wiki/Synchronous_motor#Permanent_magnet_motors</a>
</li>

<li>Implementing field oriented control of a brushless DC motor<br />
<a href="http://www.eetimes.com/document.asp?doc_id=1279321">http://www.eetimes.com/document.asp?doc_id=1279321</a>
</li>

<li>Vector control (motor)<br />
<a href="https://en.wikipedia.org/wiki/Vector_control_(motor)">https://en.wikipedia.org/wiki/Vector_control_(motor)</a>
</li>

<li>Motorola DSP56k<br />
<a href="https://www.rockbox.org/wiki/MotorolaDSP56k">https://www.rockbox.org/wiki/MotorolaDSP56k</a>
</li>

<li>Motorola 56000 (Wikipedia)<br />
<a href="http://en.wikipedia.org/wiki/Motorola_56000">http://en.wikipedia.org/wiki/Motorola_56000</a>
</li>

<li>Using the Motorola DSP56002EVM for Amateur Radio DSP Projects<br />
<a href="http://www.johanforrer.net/EVM/article.html">http://www.johanforrer.net/EVM/article.html</a>
</li>

<li>The Atari Falcon030 "Personal Integrated Media System"<br />
<a href="http://www.atarimuseum.com/computers/16bits/falcon030.html">http://www.atarimuseum.com/computers/16bits/falcon030.html</a>
</li>

<li>Turtle Beach Corporation (stránky společnosti)<br />
<a href="http://www.turtlebeach.com/">http://www.turtlebeach.com/</a>
</li>

<li>Turtle Beach Corporation (Wikipedia)<br />
<a href="https://en.wikipedia.org/wiki/Turtle_Beach_Corporation">https://en.wikipedia.org/wiki/Turtle_Beach_Corporation</a>
</li>

<li>Atari Falcon 030 DSP 3D engine test<br />
<a href="http://www.digiti.info/video/WHQwMjNRaExfLWs=/atari_falcon_030_dsp_3d_engine_test">http://www.digiti.info/video/WHQwMjNRaExfLWs=/atari_falcon_030_dsp_3d_engine_test</a>
</li>

<li>Atari Falcon030 (německy)<br />
<a href="http://www.maedicke.de/atari/hardware/falcon.htm">http://www.maedicke.de/atari/hardware/falcon.htm</a>
</li>

<li>Old-computers.com: Atari Falcon030<br />
<a href="http://www.old-computers.com/museum/computer.asp?c=125&st=1">http://www.old-computers.com/museum/computer.asp?c=125&st=1</a>
</li>

<li>Atari Falcon030 (Wikipedia)<br />
<a href="http://en.wikipedia.org/wiki/Atari_Falcon">http://en.wikipedia.org/wiki/Atari_Falcon</a>
</li>

<li>Past and current projects (including Falcon stuff)<br />
<a href="http://os.inf.tu-dresden.de/~nf2/projects/projects.html">http://os.inf.tu-dresden.de/~nf2/projects/projects.html</a>
</li>

<li>Atari Falcon 030: The Case For The Defence<br />
<a href="http://www.soundonsound.com/sos/1994_articles/sep94/atarifalcon.html">http://www.soundonsound.com/sos/1994_articles/sep94/atarifalcon.html</a>
</li>

<li>DaVinci processor family<br />
<a href="http://www.ti.com/general/docs/datasheetdiagram.tsp?genericPartNumber=TMS320DM365&diagramId=64193">http://www.ti.com/general/docs/datasheetdiagram.tsp?genericPartNumber=TMS320DM365&diagramId=64193</a>
</li>

<li>Texas Instruments DaVinci<br />
<a href="https://en.wikipedia.org/wiki/Texas_Instruments_DaVinci">https://en.wikipedia.org/wiki/Texas_Instruments_DaVinci</a>
</li>

<li>TMS320DM6446 (DaVinci)<br />
<a href="http://www.ti.com/product/tms320dm6446">http://www.ti.com/product/tms320dm6446</a>
</li>

<li>Digital Media Video Processors (TI)<br />
<a href="http://www.ti.com/lsds/ti/processors/dsp/media_processors/davinci/products.page#">http://www.ti.com/lsds/ti/processors/dsp/media_processors/davinci/products.page#</a>
</li>

<li>TI Wiki<br />
<a href="http://processors.wiki.ti.com/index.php/Main_Page">http://processors.wiki.ti.com/index.php/Main_Page</a>
</li>

<li>C5000 ultra-low-power DSP<br />
<a href="http://www.ti.com/lsds/ti/processors/dsp/c5000_dsp/overview.page">http://www.ti.com/lsds/ti/processors/dsp/c5000_dsp/overview.page</a>
</li>

<li>OMAP (Wikipedia)<br />
<a href="https://en.wikipedia.org/wiki/OMAP">https://en.wikipedia.org/wiki/OMAP</a>
</li>

<li>OMAP - TI Wiki<br />
<a href="http://processors.wiki.ti.com/index.php/OMAP">http://processors.wiki.ti.com/index.php/OMAP</a>
</li>

<li>Why OMAP can't compete in smartphones<br />
<a href="http://www.eetimes.com/author.asp?section_id=40&doc_id=1286602">http://www.eetimes.com/author.asp?section_id=40&doc_id=1286602</a>
</li>

<li>Applications Processors – The Heart of the Smartphone<br />
<a href="http://www.engineering.com/ElectronicsDesign/ElectronicsDesignArticles/ArticleID/5791/Applications-Processors-The-Heart-of-the-Smartphone.aspx">http://www.engineering.com/ElectronicsDesign/ElectronicsDesignArticles/ArticleID/5791/Applications-Processors-The-Heart-of-the-Smartphone.aspx</a>
</li>

<li>TI cuts 1,700 jobs in OMAP shift<br />
<a href="http://www.eetimes.com/document.asp?doc_id=1262782">http://www.eetimes.com/document.asp?doc_id=1262782</a>
</li>

<li>VLIW: Very Long Instruction Word: Texas Instruments TMS320C6x<br />
<a href="http://www.ecs.umass.edu/ece/koren/architecture/VLIW/2/ti1.html">http://www.ecs.umass.edu/ece/koren/architecture/VLIW/2/ti1.html</a>
</li>

<li>An Introduction To Very-Long Instruction Word (VLIW) Computer Architecture<br />
Philips Semiconductors
</li>

<li>VLIW Architectures for DSP: A Two-Part Lecture (PDF, slajdy)<br />
<a href="http://www.bdti.com/MyBDTI/pubs/vliw_icspat99.pdf">http://www.bdti.com/MyBDTI/pubs/vliw_icspat99.pdf</a>
</li>

<li>Very long instruction word (Wikipedia)<br />
<a href="https://en.wikipedia.org/wiki/Very_long_instruction_word">https://en.wikipedia.org/wiki/Very_long_instruction_word</a>
</li>

<li>A VLIW Approach to Architecture, Compilers and Tools<br />
<a href="http://www.vliw.org/book/">http://www.vliw.org/book/</a>
</li>

<li>VEX Toolchain (VEX = VLIW Example)<br />
<a href="http://www.hpl.hp.com/downloads/vex/">http://www.hpl.hp.com/downloads/vex/</a>
</li>

<li>Elbrus (computer)<br />
<a href="https://en.wikipedia.org/wiki/Elbrus_%28computer%29">https://en.wikipedia.org/wiki/Elbrus_%28computer%29</a>
</li>

<li>Super Harvard Architecture Single-Chip Computer<br />
<a href="https://en.wikipedia.org/wiki/Super_Harvard_Architecture_Single-Chip_Computer">https://en.wikipedia.org/wiki/Super_Harvard_Architecture_Single-Chip_Computer</a>
</li>

<li>Digital Signal Processors (stránky TI)<br />
<a href="http://www.ti.com/lsds/ti/processors/dsp/overview.page">http://www.ti.com/lsds/ti/processors/dsp/overview.page</a>
</li>

<li>C674x Low Power DSP (stránky TI)<br />
<a href="http://www.ti.com/lsds/ti/processors/dsp/c6000_dsp/c674x/overview.page">http://www.ti.com/lsds/ti/processors/dsp/c6000_dsp/c674x/overview.page</a>
</li>

<li>TMS320C30 (stránky TI)<br />
<a href="http://www.ti.com/product/tms320c30">http://www.ti.com/product/tms320c30</a>
</li>

<li>TMS320C6722B<br />
<a href="http://www.ti.com/product/tms320c6722b/description">http://www.ti.com/product/tms320c6722b/description</a>
</li>

<li>Introduction to DSP<br />
<a href="http://www.ti.com/lit/wp/spry281/spry281.pdf">http://www.ti.com/lit/wp/spry281/spry281.pdf</a>
</li>

<li>The Evolution of TMS (Family of DSPs)<br />
<a href="http://www.slideshare.net/moto_modx/theevo1">http://www.slideshare.net/moto_modx/theevo1</a>
</li>

<li>Datasheet k TMS32010<br />
<a href="http://www.datasheetarchive.com/dlmain/49326c32a52050140abffe6f0ac4894aa09889/M/TMS32010">http://www.datasheetarchive.com/dlmain/49326c32a52050140abffe6f0ac4894aa09889/M/TMS32010</a>
</li>

<li>1979: Single Chip Digital Signal Processor Introduced<br />
<a href="http://www.computerhistory.org/siliconengine/single-chip-digital-signal-processor-introduced/">http://www.computerhistory.org/siliconengine/single-chip-digital-signal-processor-introduced/</a>
</li>

<li>The TMS32010. The DSP chip that changed the destiny of a semiconductor giant<br />
<a href="http://www.tihaa.org/historian/TMS32010-12.pdf">http://www.tihaa.org/historian/TMS32010-12.pdf</a>
</li>

<li>Texas Instruments TMS320 (Wikipedia)<br />
<a href="https://en.wikipedia.org/wiki/Texas_Instruments_TMS320">https://en.wikipedia.org/wiki/Texas_Instruments_TMS320</a>
</li>

<li>Great Microprocessors of the Past and Present: Part IX: Signetics 8x300, Early cambrian DSP ancestor (1978):<br />
<a href="http://www.cpushack.com/CPU/cpu2.html#Sec2Part9">http://www.cpushack.com/CPU/cpu2.html#Sec2Part9</a>
</li>

<li>Great Microprocessors of the Past and Present (V 13.4.0)<br />
<a href="http://jbayko.sasktelwebsite.net/cpu.html">http://jbayko.sasktelwebsite.net/cpu.html</a>
</li>

<li>Introduction to DSP - DSP processors:<br />
<a href="http://www.bores.com/courses/intro/chips/index.htm">http://www.bores.com/courses/intro/chips/index.htm</a>
</li>

<li>The Scientist and Engineer's Guide to Digital Signal Processing:<br />
<a href="http://www.dspguide.com/">http://www.dspguide.com/</a>
</li>

<li>Digital signal processor (Wikipedia EN)<br />
<a href="http://en.wikipedia.org/wiki/Digital_signal_processor">http://en.wikipedia.org/wiki/Digital_signal_processor</a>
</li>

<li>Digitální signálový procesor (Wikipedia CZ)<br />
<a href="http://cs.wikipedia.org/wiki/Digitální_signálový_procesor">http://cs.wikipedia.org/wiki/Digitální_signálový_procesor</a>
</li>

<li>Digital Signal Processing FAQs<br />
<a href="http://dspguru.com/dsp/faqs">http://dspguru.com/dsp/faqs</a>
</li>

<li>Reprezentace numerických hodnot ve formátech FX a FP<br />
<a href="http://www.root.cz/clanky/fixed-point-arithmetic/">http://www.root.cz/clanky/fixed-point-arithmetic/</a>
</li>

<li>IEEE 754 a její příbuzenstvo: FP formáty<br />
<a href="http://www.root.cz/clanky/norma-ieee-754-a-pribuzni-formaty-plovouci-radove-tecky/">http://www.root.cz/clanky/norma-ieee-754-a-pribuzni-formaty-plovouci-radove-tecky/</a>
</li>

<li>Čtyři základní způsoby uložení čísel pomocí FX formátů<br />
<a href="http://www.root.cz/clanky/binarni-reprezentace-numerickych-hodnot-v-fx-formatu/">http://www.root.cz/clanky/binarni-reprezentace-numerickych-hodnot-v-fx-formatu/</a>
</li>

<li>Základní aritmetické operace prováděné v FX formátu<br />
<a href="http://www.root.cz/clanky/zakladni-aritmeticke-operace-provadene-ve-formatu-fx/">http://www.root.cz/clanky/zakladni-aritmeticke-operace-provadene-ve-formatu-fx/</a>
</li>

<li>Aritmetické operace s hodnotami uloženými ve formátu FP<br />
<a href="http://www.root.cz/clanky/aritmeticke-operace-s-hodnotami-ve-formatu-plovouci-radove-carky/">http://www.root.cz/clanky/aritmeticke-operace-s-hodnotami-ve-formatu-plovouci-radove-carky/</a>
</li>

<li>FIR Filter FAQ<br />
<a href="http://dspguru.com/dsp/faqs/fir">http://dspguru.com/dsp/faqs/fir</a>
</li>

<li>Finite impulse response (Wikipedia)<br />
<a href="http://en.wikipedia.org/wiki/Finite_impulse_response">http://en.wikipedia.org/wiki/Finite_impulse_response</a>
</li>

<li>DSPRelated<br />
<a href="http://www.dsprelated.com/">http://www.dsprelated.com/</a>
</li>

<li>Addressing mode (Wikipedia)<br />
<a href="https://en.wikipedia.org/wiki/Addressing_mode">https://en.wikipedia.org/wiki/Addressing_mode</a>
</li>

<li>Orthogonal instruction set<br />
<a href="https://en.wikipedia.org/wiki/Orthogonal_instruction_set">https://en.wikipedia.org/wiki/Orthogonal_instruction_set</a>
</li>

<li>TI 16-bit and 32-bit microcontrollers<br />
<a href="http://www.ti.com/lsds/ti/microcontrollers_16-bit_32-bit/overview.page">http://www.ti.com/lsds/ti/microcontrollers_16-bit_32-bit/overview.page</a>
</li>

<li>TMS 32010 Assembly Language Programmer's Guide (kniha na Amazonu)<br />
<a href="https://www.amazon.com/32010-Assembly-Language-Programmers-Guide/dp/0904047423">https://www.amazon.com/32010-Assembly-Language-Programmers-Guide/dp/0904047423</a>
</li>

<li>COSC2425: PC Architecture and Machine Language, PC Assembly Language<br />
<a href="http://www.austincc.edu/rblack/courses/COSC2425/index.html">http://www.austincc.edu/rblack/courses/COSC2425/index.html</a>
</li>

</ol>



<p></p><p></p>
<p><small>Autor: <a href="http://www.fit.vutbr.cz/~tisnovpa">Pavel Tišnovský</a> &nbsp; 2017</small></p>
</body>
</html>

