<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
        "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html>
<head>
<title>Mikrořadiče a DSP společnosti Infineon - vylepšená šestnáctibitová jádra C166S V2</title>
<meta name="Author" content="Pavel Tisnovsky" />
<meta name="Generator" content="vim" />
<meta http-equiv="content-type" content="text/html; charset=utf-8" />
<style type="text/css">
         body {color:#000000; background:#ffffff;}
         h1  {font-family: arial, helvetica, sans-serif; color:#ffffff; background-color:#c00000; text-align:center; padding-left:1em}
         h2  {font-family: arial, helvetica, sans-serif; color:#ffffff; background-color:#0000c0; padding-left:1em; text-align:left}
         h3  {font-family: arial, helvetica, sans-serif; color:#000000; background-color:#c0c0c0; padding-left:1em; text-align:left}
         h4  {font-family: arial, helvetica, sans-serif; color:#000000; background-color:#e0e0e0; padding-left:1em; text-align:left}
         a   {font-family: arial, helvetica, sans-serif;}
         li  {font-family: arial, helvetica, sans-serif; color:#000000; text-align:justify; width:450px;}
         ol  {font-family: arial, helvetica, sans-serif; color:#000000; text-align:justify; width:450px;}
         ul  {font-family: arial, helvetica, sans-serif; color:#000000; text-align:justify; width:450px;}
         p   {font-family: arial, helvetica, sans-serif; color:#000000; text-align:justify;}
         pre {background:#e0e0e0}
</style>
</head>

<body>

<h1>Mikrořadiče a DSP společnosti Infineon - vylepšená šestnáctibitová jádra C166S V2</h1>

<h3>Pavel Tišnovský</h3>

<p></p>

<h1>Úvodník</h1>

<p>Některé novější šestnáctibitové mikrořadiče firmy Infineon jsou založeny na vylepšených šestnáctibitových jádrech C166S V2. Jedná se o třetí generaci jader z rodiny C166, která je zpětně kompatibilní, ovšem je výkonnější a mj. obsahuje i modul MAC určený pro DSP operace.</p>



<h2>Obsah</h2>

<p><a href="#k01">1. Mikrořadiče a DSP společnosti Infineon - vylepšená šestnáctibitová jádra C166S V2</a></p>
<p><a href="#k02">2. Centrální procesorová jednotka: ALU, MAC a ADU</a></p>
<p><a href="#k03">3. MAC &ndash; Multiply Accumulate</a></p>
<p><a href="#k04">4. Instrukční pipeline</a></p>
<p><a href="#k05">5. Predikce skoků a nápověda předaná překladačem či uživatelem</a></p>
<p><a href="#k06">6. Rozšíření sady pracovních registrů, mapování registrů do paměti</a></p>
<p><a href="#k07">7. Rozšíření registru PSW (Program Status Word)</a></p>
<p><a href="#k08">8. Paměťový prostor větší než 64kB</a></p>
<p><a href="#k09">9. Rozdělení programové paměti na segmenty</a></p>
<p><a href="#k10">10. Adresování dat</a></p>
<p><a href="#k11">11. Obejití funkce stránkových registrů <strong>DPP</strong> instrukcemi <strong>EXT??</strong></a></p>
<p><a href="#k12">12. DSP operace</a></p>
<p><a href="#k13">13. Nové adresovací režimy pro DSP operace</a></p>
<p><a href="#k14">14. Instrukce <strong>ATOMIC</strong></a></p>
<p><a href="#k15">15. Odkazy na Internetu</a></p>



<p><a name="k01"></a></p>
<h2 id="k01">1. Mikrořadiče a DSP společnosti Infineon - vylepšená šestnáctibitová jádra C166S V2</h2>

<p>Původní šestnáctibitová mikrořadičová jádra <i>C166</i>, s&nbsp;nimiž jsme
se seznámili v&nbsp;předchozím článku, sice nabízela dostatečný výpočetní výkon
pro mnoho řídicích aplikací, ovšem ve chvíli, kdy bylo nutné provádět nějaké
DSP operace (zesílení/zeslabení, konvoluce, korelace, FIR) již bylo výhodnější
přejít na výkonnější mikrořadič, digitální signálový procesor či ještě lépe na
kombinaci MCU+DSP. Jádra pojmenovaná <i>C166S V2</i> představují právě onu
zajímavou kombinaci šestnáctibitového mikrořadiče a rychlé jednotky určené pro
provádění DSP operací se šestnáctibitovými vstupy a čtyřicetibitovými
mezivýsledky. I přesto, že se tato jádra jmenují <i>V2</i>, se ve skutečnosti
jedná již o třetí (nikoli druhou) generaci jader <i>C166</i>, ovšem
s&nbsp;odlišnou vnitřní architekturou a několika vylepšeními, která se týkají
jak instrukční sady (nové instrukce, nové adresovací režimy), tak i například
instrukční pipeline umožňující dokončit většinu instrukcí v&nbsp;jednom
cyklu.</p>



<p><a name="k02"></a></p>
<h2 id="k02">2. Centrální procesorová jednotka: ALU, MAC a ADU</h2>

<p>Centrální procesorová jednotka použitá u čipů s&nbsp;jádry <i>C166S V2</i>
obsahuje následující moduly:</p>

<ol>
<li>ALU (Aritmeticko-logická jednotka doplněná o samostatnou násobičku a děličku)</li>
<li>MAC (Modul Multiply Accumulate, ten je zcela oddělený od výše zmíněné násobičky a děličky)</li>
<li>ADU (Address Data Unit)</li>
<li>IPIP (instrukční pipeline)</li>
<li>IFU (jednotka řídicí načítání instrukcí, práci se zásobníkem návratových adres atd.)</li>
<li>WB (Write-back buffer pro data)</li>
<li>RF (dvě interní sady pracovních registrů, viz <a href="#k06">další text</a>)</li>
</ol>

<p>Aritmeticko-logická jednotka se skládá z&nbsp;klasické ALU, ovšem doplněné o
barrel shifter, násobičku a děličku (pracující podobně jako u <i>C166</i>) a
taktéž o novou jednotku <i>MAC</i> popsanou <a href="#k03">v&nbsp;navazující
kapitole</a>. Dále se v&nbsp;centrální procesorové jednotce nachází dvě sady
pracovních registrů a modul <i>ADU (Address Data Unit)</i>, jenž kromě
speciálních registrů použitých pro adresování (DPP0..DPP3, SPSEG, SP, STKOV..)
obsahuje i dvojici samostatně (paralelně s&nbsp;hlavní ALU) pracujících
sčítaček používaných pro postinkrement/dekrement a preinkrement/dekrement
adresy.</p>



<p><a name="k03"></a></p>
<h2 id="k03">3. MAC &ndash; Multiply Accumulate</h2>

<p>Jednotka <i>MAC</i> (<i>Multiply Accumulate</i>) tvoří základ pro ty
aplikace, v&nbsp;nichž je nutné nějakým způsobem zpracovávat signály (většinou
plynulý tok dat). Interně se <i>MAC</i> skládá z&nbsp;rychlé násobičky se
šestnáctibitovými vstupy, která je propojena s&nbsp;barrel shifterem a
akumulátorem. Jak posuvný registr, tak i akumulátor mají šířku čtyřicet bitů,
což efektivně umožňuje výpočty s&nbsp;hodnotami reprezentovanými v&nbsp;systému
pevné řádové čárky (<i>FX &ndash; Fixed Point</i>). Výpočty je možné provádět
s&nbsp;automatickou saturací výsledků (nedojde k&nbsp;přetečení) a vzhledem
k&nbsp;tomu, že násobička dokončí operaci v&nbsp;jediném cyklu, mohou být DSP
operace prováděné na <i>C166S V2</i> až desetkrát rychlejší v&nbsp;porovnání
s&nbsp;původními jádry <i>C166</i> (samozřejmě pokud porovnáváme čipy se
shodným hodinovým signálem).</p>

<p>Modul <i>MAC</i> je doplněn registry nazvané <strong>MAH</strong>,
<strong>MAL</strong> a <strong>MAE</strong> s&nbsp;obsahem akumulátoru (první
dva registry jsou šestnáctibitové, poslední je jen osmibitový), dále registr
<strong>MRW</strong> použitý při opakování programových smyček,
<strong>MCW</strong> (<i>MAC Unit Control Word</i>) pro nastavení režimu
saturace i posunu mezivýsledku po násobení a <strong>MSW</strong> (<i>MAC Unit
Status Word</i>), což je registr se stavem celé jednotky <i>MAC</i> (přenos,
přetečení, záporný výsledek poslední operace, nulový výsledek apod.)</p>



<p><a name="k04"></a></p>
<h2 id="k04">4. Instrukční pipeline</h2>

<p>Instrukční pipeline je u jader <i>C166S V2</i> rozdělena na dvě části,
přičemž první část se stará o načtení instrukce (<i>fetch</i>) a část druhá o
její vykonání. První část má dva řezy, část druhá pak pět řezů. Navíc první
část obsahuje logiku pro predikci skoků a dvojici bufferů pro přednačtené
instrukce. Podívejme se, jak tato první část instrukční pipeline vypadá,
protože se jedná o zajímavé a současně i výkonné řešení:</p>

<a href="https://www.root.cz/obrazek/282076/"><img src="https://i.iinfo.cz/images/425/c166-1-prev.png" class="image-282076" alt="&#160;" width="206" height="270" /></a>
<p><i>Obrázek 1: První část instrukční pipeline jader C166 V2.</i></p>

<p>Na diagramu můžeme vidět, že pipeline na vstupu obsahuje relativně malý
buffer, který může obsahovat až šest instrukcí. Instrukční kódy
(popř.&nbsp;konstanty) jsou z&nbsp;paměti programu načítány po interní sběrnici
o šířce 64 bitů, takže je možné (například po skoku) tento buffer naplnit
relativně rychle. Za vstupním bufferem se nachází logika pro detekci skokových
instrukcí a pro predikci skoků v&nbsp;prvních třech instrukcích z&nbsp;bufferu.
Pokud je skok detekován a logika usoudí, že bude proveden, je možné přeskočit
(<i>bypass</i>) další buffer a FIFO, u běžných instrukcí jsou pak instrukce
ukládány přes další buffer do FIFO. Instrukce skoku jsou prováděny paralelně
s&nbsp;instrukcí, která skoku předchází (což je opak klasického RISCového
branch delay slotu), což ovšem znamená, že logika v&nbsp;této části pipeline
musí instrukci skoku pozměnit (vypočítat absolutní adresu skoku atd.).</p>



<p><a name="k05"></a></p>
<h2 id="k05">5. Predikce skoků a nápověda předaná překladačem či uživatelem</h2>

<p>S&nbsp;instrukční pipeline, resp.&nbsp;přesněji řečeno s&nbsp;její první
částí (<i>prefetch</i>) poměrně úzce souvisí predikce skoků. Ta je u jader
<i>C166S V2</i> řešena poměrně jednoduchým způsobem, který ovšem umožňuje, aby
centrální procesorové jednotce mohl pomoci překladač či sám programátor
používající assembler. Prediktor skoků rozděluje všechny skokové instrukce do
několika kategorií a u jednotlivých kategorií určuje, v&nbsp;jakém případě se
má skok provést. Navíc existuje i kategorie skokových instrukcí, u nichž je
predikce provedena na základě bitu zapsaného do instrukčního slova. Tento bit
nastavuje překladač (na základě statické či runtime analýzy) či přímo
programátor pracující s&nbsp;assembleru:</p>

<ul>

<li>U instrukcí <strong>JMPS</strong> a <strong>CALLS</strong> se předpokládá,
že se skok vždy provede.</li>

<li>Totéž platí u instrukcí <strong>RET</strong>, <strong>RETS</strong>,
<strong>RETP</strong> a <strong>RETI</strong>.</li>

<li>U instrukcí <strong>JMPI</strong> a <strong>CALLI</strong> se předpokládá,
že se skok provede ve chvíli, kdy podmínka není zadána (suffix _UC),
v&nbsp;ostatních případech se předpokládá, že se skok neprovede.</li>

<li>U relativních podmíněných skoků se předpokládá, že skok bude proveden ve
chvíli, kdy se skáče směrem zpět (tj.&nbsp;skok je velmi pravděpodobně umístěn
na konci programové smyčky).</li>

<li>Totéž platí u všech skokových instrukcí &bdquo;booleovského
procesoru&ldquo;, tj. <strong>JB</strong>, <strong>JBC</strong>,
<strong>JNB</strong> a <strong>JNBS</strong>.</li>

<li>U instrukcí <strong>JMPA</strong> a <strong>CALLA</strong> může
programátor/překladač určit, zda skok bude či nebude pravděpodobně proveden.
Zápis je jednoduchý: <strong>JMPA+ podmínka, adresa</strong> a <strong>JMPA-
podmínka, adresa</strong>.</li>

</ul>



<p><a name="k06"></a></p>
<h2 id="k06">6. Rozšíření sady pracovních registrů, mapování registrů do paměti</h2>

<p>U původních mikrořadičových jader <i>C166</i> existovala sada šestnácti
šestnáctibitových pracovních registrů, přičemž osm z&nbsp;těchto registrů bylo
možné rozdělit na dvojice osmibitových registrů. U novějších jader <i>C166S
V2</i> existují hned tři sady (resp.&nbsp;přesněji řečeno banky) pracovních
registrů, přičemž jedna banka se nazývá globální a zbylé dvě banky pak lokální.
Globální banka registrů je mapována do operační paměti, takže tyto registry je
vlastně možné považovat &bdquo;jen&ldquo; za speciální formu offsetu použitého
při adresování. To, ve které části paměti se tato banka nachází, je určeno
obsahem registru <strong>CP</strong> (<i>Context Pointer</i>), v&nbsp;jehož
horních čtyřech bitech jsou vždy uloženy jedničky, aby se zaručilo, že banka
pracovních registrů bude vždy uložena v&nbsp;interní paměti.</p>

<p>Počáteční adresu globální banky registrů je možné nastavit instrukcí:</p>

<pre>
SCXT CP, #konstanta
</pre>

<p>Lokální banky nejsou mapovány do RAM (jsou součástí centrální procesorové
jednotky) a tudíž je nelze adresovat nepřímo. To, která banka registrů je
použita, je určeno <a href="#k07">dvěma novými bity</a>
v&nbsp;<strong>PSW</strong> a protože je tento registr automaticky obnoven při
ukončení přerušovací rutiny, je možné například jednu interní banku používat
právě v&nbsp;přerušovacích rutinách a nestarat se o to, aby přerušovací rutina
nenarušila obsah pracovních registrů používaných hlavním programem.</p>



<p><a name="k07"></a></p>
<h2 id="k07">7. Rozšíření registru PSW (Program Status Word)</h2>

<p>Původní jádra <i>C166</i> obsahovala stavový registr, v&nbsp;němž nebyly
některé bity využity. Jen pro připomenutí, struktura stavového registru
<strong>PSW</strong> byla následující:</p>

<table>
<tr><th>Bit</th><th>Označení</th><th>Význam</th></tr>
<tr><td> 0</td><td>N</td><td>příznak záporného výsledku</td></tr>
<tr><td> 1</td><td>C</td><td>příznak přenosu</td></tr>
<tr><td> 2</td><td>V</td><td>příznak přetečení</td></tr>
<tr><td> 3</td><td>Z</td><td>příznak nulovosti</td></tr>
<tr><td> 4</td><td>E</td><td>výsledkem operace je nejmenší hodnota (0x80 či 0x8000)</td></tr>
<tr><td> 5</td><td>MULIP</td><td>došlo k&nbsp;přerušení násobení či dělení (tyto operace lze přerušit během výpočtu)</td></tr>
<tr><td> 6</td><td>USR0</td><td>uživatelsky nastavitelný bit</td></tr>
<tr><td> 7</td><td>&times;</td><td></td></tr>
<tr><td> 8</td><td>&times;</td><td></td></tr>
<tr><td> 9</td><td>&times;</td><td></td></tr>
<tr><td>10</td><td>HLDEN</td><td>povolení <a href="https://en.wikipedia.org/wiki/Bus_mastering">externího řízení sběrnice</a> jiným čipem přes signály BREQ, HOLD a HLDA</td></tr>
<tr><td>11</td><td>IEN</td><td>povolení či zákaz přerušení</td></tr>
<tr><td>12</td><td>ILVL</td><td>úroveň přerušení</td></tr>
<tr><td>13</td><td>ILVL</td><td>úroveň přerušení</td></tr>
<tr><td>14</td><td>ILVL</td><td>úroveň přerušení</td></tr>
<tr><td>15</td><td>ILVL</td><td>úroveň přerušení</td></tr>
</table>

<p>U jader <i>C166S V2</i> se využily i zbývající tři bity, a to následujícím způsobem:</p>

<table>
<tr><th>Bit</th><th>Označení</th><th>Význam</th></tr>
<tr><td> 7</td><td>USR1</td><td>uživatelsky nastavitelný bit</td></tr>
<tr><td> 8</td><td>BANK</td><td>výběr banky pracovních registrů</td></tr>
<tr><td> 9</td><td>BANK</td><td>výběr banky pracovních registrů</td></tr>
</table>

<p>Bity 8 a 9 společně určují, jaká banka pracovních registrů se použije:</p>

<table>
<tr><th>Bit 9 a 8 PSW</th><th>význam</th></tr>
<tr><td>00</td><td>globální banka (mapovaná do paměti)</td></tr>
<tr><td>01</td><td>rezervováno</td></tr>
<tr><td>10</td><td>první lokální banka registrů</td></tr>
<tr><td>11</td><td>druhá lokální banka registrů</td></tr>
</table>



<p><a name="k08"></a></p>
<h2 id="k08">8. Paměťový prostor větší než 64kB a rozdělení programové paměti na segmenty</h2>

<p>Na rozdíl od některých dalších mikrořadičů se u jader <i>C166S V2</i>
používá jeden lineární adresový prostor společný jak pro datovou paměť, tak i
pro paměť programu, což mj.&nbsp;zjednodušuje instrukční soubor. Konkrétně to
znamená, že existuje prostor o maximální teoretické velikosti 16 MB, do něhož
se mapuje interní ROM, interní paměť Flash, interní DRAM, speciální funkční
registry (SFR) a popř.&nbsp;i všechny externí paměti. Na druhou stranu je však
nutné kvůli této konfiguraci vyřešit problém, jak efektivně adresovat
teoretický rozsah 16 MB na šestnáctibitovém mikroprocesoru.</p>

<p>O přenos instrukcí a konstant z&nbsp;paměti programu se stará modul nazvaný
<i>PMU</i> neboli <i>Program Management Unit</i>, který je s&nbsp;centrální
procesorovou jednotkou propojen přes již zmíněnou 64bitovou interní sběrnici.
Většina čipů limituje velikost paměti programu na 4MB (což v&nbsp;reálných
aplikacích prakticky nebude vadit).</p>



<p><a name="k09"></a></p>
<h2 id="k09">9. Rozdělení programové paměti na segmenty</h2>

<p>Při načítání instrukcí z&nbsp;programové paměti je použita metoda
segmentování. Již zmíněný rozsah adres do 16 MB (2<sup>24</sup> adres) je
rozdělen do 256 vzájemně se nepřekrývajících segmentů, takže každý segment má
velikost přesně 65536 adres. Pro uložení aktuálně používaného segmentu je
využit osmibitový registr <strong>CSP</strong>, ukazatel na zpracovávanou
instrukci <strong>IP</strong> je pouze šestnáctibitový a navíc je jeho nejnižší
bit vždy nulový, protože instrukce jsou zarovnány na šestnáctibitová slova.
Explicitní změnu obsahu registru <strong>CSP</strong> provádí instrukce
<strong>JMPS</strong> a <strong>CALLS</strong>, u nichž je kromě adresy skoku
v&nbsp;rámci segmentu použita i osmibitová konstanta značící nový segment:</p>

<pre>
CALLS segment, adresa
JMPS  segment, adresa
</pre>

<p>Poznámka: tyto instrukce mají šířku čtyř bajtů &ndash; jeden bajt pro kód
instrukce, další bajt pro segment a dvojice bajtů pro adresu v&nbsp;rámci
segmentu.</p>

<p>Implicitní změnu obsahu registru <strong>CSP</strong> provádí instrukce
<strong>RETS</strong> a <strong>RETI</strong>. V&nbsp;případě potřeby je možné
segmentaci (vliv registru <strong>CSP</strong> na výpočet absolutní adresy)
zakázat nastavením bitu <strong>SGTDIS</strong> v&nbsp;konfiguračním registru
<strong>CPUCON1</strong> (po resetu je segmentace implicitně povolena).</p>



<p><a name="k10"></a></p>
<h2 id="k10">10. Adresování dat</h2>

<p>Datová paměť je s&nbsp;centrální procesorovou jednotkou propojena pouze po
šestnáctibitové sběrnici a maximální kapacita interní datové paměti dosahuje u
většiny čipů &bdquo;jen&ldquo; 24 KB. Na druhou stranu se jedná o SRAM, takže
lze relativně nízkou kapacitu pochopit. K&nbsp;této paměti můžeme připočíst
ještě rychlejší DPRAM o kapacitě typicky 3 KB, které je přes <i>High Speed
System Bus</i> propojena s&nbsp;MPU (s&nbsp;CPU je propojena přímo &ndash; je
dokonce jeho součástí) a slouží především pro DSP operace. Pro komunikaci
s&nbsp;externími paměťmi se používá <i>EBC</i> neboli <i>External Bus
Controller</i>, velikost těchto pamětí již není nijak významně omezena, takže
prakticky vždy přesáhne 64 KB. A právě proto je nutné i při práci
s&nbsp;datovou pamětí použít nějaký systém adresování, který obejde omezení 64
KB při použití šestnáctibitových registrů.</p>

<p>Existuje několik režimů adresování datové paměti, ovšem základní režim je
založen na použití stránkových registrů nazvaných <i>Data Page Pointer</i>
neboli <i>DPP</i>. Tyto registry obsahují horních deset bitů adresy (její
celková šířka je 24 bitů). Přímo v&nbsp;instrukcích sloužících pro manipulaci
s&nbsp;daty se většinou specifikuje pouze šestnáctibitová adresa (obsah
pracovního registru, konstanta atd.). Tato část je rozdělena na offset o šířce
čtrnácti bitů a dvoubitový index, který vybírá jeden z&nbsp;Data Page Pointerů
(registry <strong>DPP0</strong> až <strong>DPP3</strong>). Z&nbsp;těchto
registrů se přečte již zmíněných spodních deset bitů (horních šest bitů se
ignoruje), které společně vytvoří výslednou fyzickou adresu:</p>

<pre>
                            15  pracovní registr či konstanta 0
                            +---------------------------------+
                            | r r b b b b b b b b b b b b b b |
                            +---------------------------------+
                              | |                 |
15             DPP0           v v 0               |
+---------------------------------+               |
| 0 0 0 0 0 0 a a a a a a a a a a | rr=00         |
+---------------------------------+               |
                              | |                 |
15             DPP1           v v 0               |
+---------------------------------+               |
| 0 0 0 0 0 0 a a a a a a a a a a | rr=01         |
+---------------------------------+               |
                              | |                 |
15             DPP2           v v 0               |
+---------------------------------+               |
| 0 0 0 0 0 0 a a a a a a a a a a | rr=10         |
+---------------------------------+               |
                              | |                 |
15             DPP3           v v 0               |
+---------------------------------+               |
| 0 0 0 0 0 0 a a a a a a a a a a | rr=11         |
+---------------------------------+               |
                                                  |
31         24 23                16 15             v            0
+---------------------------------+----------------------------+
| 0 0 0 0 0 0 a a a a a a a a a a |b b b b b b b b b b b b b b |
+---------------------------------+----------------------------+
</pre>



<p><a name="k11"></a></p>
<h2 id="k11">11. Obejití funkce stránkových registrů <strong>DPP</strong> instrukcemi <strong>EXT??</strong></h2>

<p>V&nbsp;některých případech je možné adresování s&nbsp;využitím stránkových
registrů <strong>DPPx</strong> zcela obejít. K&nbsp;tomu slouží čtyři nové
&bdquo;blokové&ldquo; instrukce <strong>EXTP</strong>, <strong>EXTPR</strong>,
<strong>EXTS</strong> a <strong>EXTSR</strong>.</p>

<p>Instrukci <strong>EXTP</strong> a <strong>EXTPR</strong> se předává
desetibitové číslo stránky a velikost bloku (počet instrukcí), pro něž se
adresa vypočte právě na základě předaného čísla stránky a čtrnáctibitového
offsetu (horní dva bity se ignorují):</p>

<pre>
EXTP #stránka, velikost_bloku
</pre>

<pre>
EXTPR #stránka, velikost_bloku
</pre>

<p>Třetí instrukce <strong>EXTS</strong> i čtvrtá instrukce
<strong>EXTSR</strong> spočítá adresu na základě šestnáctibitového offsetu a
osmibitového segmentu, přičemž osmibitový segment je součástí blokové
instrukce:</p>

<pre>
EXTS #segment, velikost_bloku
</pre>

<pre>
EXTSR #segment, velikost_bloku
</pre>

<p>Poznámka: při provádění celého bloku instrukcí se změněným adresovacím
režimem je zakázáno přerušení. Blok však ve skutečnosti není příliš dlouhý,
protože počitadlo velikosti bloku je jen dvoubitové.</p>



<p><a name="k12"></a></p>
<h2 id="k12">12. DSP operace</h2>

<p>Modul pro DSP operace se svým interním uspořádáním podobá většině dalších
digitálních signálových procesorů. Ostatně se podívejme na následující obrázek,
na němž je naznačena jeho struktura:</p>

<a href="https://www.root.cz/obrazek/282077/"><img src="https://i.iinfo.cz/images/425/c166-2-prev.png" class="image-282077" alt="&#160;" width="291" height="270" /></a>
<p><i>Obrázek 2: DSP modul<br />
(upraveno podle materiálů firmy Infineon)</i></p>

<p>Na vstupu se nachází sběrnice, po které lze přenášet dvojici
šestnáctibitových operandů. Ty lze buď navzájem vynásobit nebo je lze spojit do
jednoho 32bitového slova. Výsledek násobení/spojení je přenesen do sčítačky a
odčítačky tvořící druhou část operace MAC (Multiply Accumulate). Tato sčítačka
je již čtyřicetibitová, aby nebylo nutné po každém součtu kontrolovat, zda
došlo k&nbsp;přetečení. Výsledek operace MAC je uložen do akumulátoru,
z&nbsp;něhož může být přečten (popř.&nbsp;lze navíc aplikovat různé konverze,
saturace, limitaci výsledků na 16bitové hodnoty apod.) nebo přes shifter
přenesen ve zpětnovazební smyčce do sčítačky. Režim DSP je řízen několika bity
v&nbsp;řídicím registru <strong>MSW</strong> (MAC Status Word).</p>



<p><a name="k13"></a></p>
<h2 id="k13">13. Nové adresovací režimy pro DSP operace</h2>

<p>Pro DSP operace bylo do jader <i>C166S V2</i> přidáno několik nových
adresovacích režimů a taktéž několik nových registrů. Nejjednodušší je funkce
nových registrů <strong>QR0</strong> a <strong>QR1</strong>, které mohou být
použity pro postinkrementaci či postdekrementaci adresy po přístupu do paměti.
Tyto operace tedy již nejsou omezeny na přičtení či odečtení jedničky:</p>

<pre>
instrukce [Rw+QRx]   ; postinkrement o QRx po přístupu do paměti
instrukce [Rw-QRx]   ; postdekrement o QRx po přístupu do paměti
</pre>

<p>Další dva registry <strong>IDX0</strong> a <strong>IDX1</strong> lze použít
pro reprezentaci offsetu. V&nbsp;tomto případě se horní dva bity registrů
použijí pro výběr jednoho stránkového registru <strong>DPPx</strong> podle
schématu, <a href="#k10">který již známe</a>. Při použití <strong>IDX0</strong>
či <strong>IDX1</strong> lze jejich hodnotu automaticky zvýšit či snížit o
jedničku nebo o hodnotu uloženou v&nbsp;jednom z&nbsp;registrů
<strong>QX0</strong> či <strong>QX1</strong> (mnemotechnická pomůcka &ndash;
<strong>QRx</strong> slouží pro změnu registrů, jejichž jména začínají na
<strong>R</strong> zatímco <strong>QXx</strong> mění inde<strong>x</strong>ové
registry <strong>IDXx</strong>).</p>



<p><a name="k14"></a></p>
<h2 id="k14">14. Instrukce <strong>ATOMIC</strong></h2>

<p>Zajímavý koncept představuje instrukce <strong>ATOMIC</strong>. Této
instrukci lze předat dvoubitovou hodnotu specifikující velikost bloku (1-4)
instrukcí, které se provedou atomicky, tj.&nbsp;bez přerušení (povolena jsou
jen některá vybraná hardwarová přerušení). S&nbsp;touto technikou jsme se již
vlastně setkali &ndash; nalezneme ji i u čtyř instrukcí <strong>EXTP</strong>,
<strong>EXTPR</strong>, <strong>EXTS</strong> a <strong>EXTSR</strong>
popsaných <a href="#k11">v&nbsp;jedenácté kapitole</a>. Uvnitř atomického bloku
je možné použít libovolné instrukce, tj.&nbsp;mj.&nbsp;i instrukce DSP,
komunikaci s&nbsp;periferními zařízeními, podmíněné skoky apod.</p>



<p><a name="k15"></a></p>
<h2 id="k15">15. Odkazy na Internetu</h2>

<ol>

<li>C166®S V2 Architecture &amp; Core<br />
<a href="http://www.infineon.com/cms/en/product/microcontroller/16-bit-c166-microcontroller/c166-s-v2-architecture-and-core/channel.html?channel=db3a304312bef5660112c3011c7d01ae">http://www.infineon.com/cms/en/product/microcontroller/16-bit-c166-microcontroller/c166-s-v2-architecture-and-core/channel.html?channel=db3a304312bef5660112c3011c7d01ae</a>
</li>

<li>Memory segmentation<br />
<a href="https://en.wikipedia.org/wiki/Memory_segmentation">https://en.wikipedia.org/wiki/Memory_segmentation</a>
</li>

<li>Bus mastering<br />
<a href="https://en.wikipedia.org/wiki/Bus_mastering">https://en.wikipedia.org/wiki/Bus_mastering</a>
</li>

<li>ST10 16-bit MCUs<br />
<a href="http://www.st.com/en/microcontrollers/st10-16-bit-mcus.html?querycriteria=productId=LN1111">http://www.st.com/en/microcontrollers/st10-16-bit-mcus.html?querycriteria=productId=LN1111</a>
</li>

<li>XC800 family<br />
<a href="https://en.wikipedia.org/wiki/XC800_family">https://en.wikipedia.org/wiki/XC800_family</a>
</li>

<li>C166 (stránky společnosti Infineon)<br />
<a href="https://www.infineon.com/cms/en/product/microcontroller/16-bit-c166-microcontroller/channel.html?channel=ff80808112ab681d0112ab6b2eaf0759#ispnTab3">https://www.infineon.com/cms/en/product/microcontroller/16-bit-c166-microcontroller/channel.html?channel=ff80808112ab681d0112ab6b2eaf0759#ispnTab3</a>
</li>

<li>C166 Family<br />
<a href="https://en.wikipedia.org/wiki/C166_family">https://en.wikipedia.org/wiki/C166_family</a>
</li>

<li>Permanent Magnet Synchronous Motor<br />
<a href="https://en.wikipedia.org/wiki/Synchronous_motor#Permanent_magnet_motors">https://en.wikipedia.org/wiki/Synchronous_motor#Permanent_magnet_motors</a>
</li>

<li>Implementing field oriented control of a brushless DC motor<br />
<a href="http://www.eetimes.com/document.asp?doc_id=1279321">http://www.eetimes.com/document.asp?doc_id=1279321</a>
</li>

<li>Vector control (motor)<br />
<a href="https://en.wikipedia.org/wiki/Vector_control_(motor)">https://en.wikipedia.org/wiki/Vector_control_(motor)</a>
</li>

<li>Motorola DSP56k<br />
<a href="https://www.rockbox.org/wiki/MotorolaDSP56k">https://www.rockbox.org/wiki/MotorolaDSP56k</a>
</li>

<li>Motorola 56000 (Wikipedia)<br />
<a href="http://en.wikipedia.org/wiki/Motorola_56000">http://en.wikipedia.org/wiki/Motorola_56000</a>
</li>

<li>Using the Motorola DSP56002EVM for Amateur Radio DSP Projects<br />
<a href="http://www.johanforrer.net/EVM/article.html">http://www.johanforrer.net/EVM/article.html</a>
</li>

<li>The Atari Falcon030 "Personal Integrated Media System"<br />
<a href="http://www.atarimuseum.com/computers/16bits/falcon030.html">http://www.atarimuseum.com/computers/16bits/falcon030.html</a>
</li>

<li>Turtle Beach Corporation (stránky společnosti)<br />
<a href="http://www.turtlebeach.com/">http://www.turtlebeach.com/</a>
</li>

<li>Turtle Beach Corporation (Wikipedia)<br />
<a href="https://en.wikipedia.org/wiki/Turtle_Beach_Corporation">https://en.wikipedia.org/wiki/Turtle_Beach_Corporation</a>
</li>

<li>Atari Falcon 030 DSP 3D engine test<br />
<a href="http://www.digiti.info/video/WHQwMjNRaExfLWs=/atari_falcon_030_dsp_3d_engine_test">http://www.digiti.info/video/WHQwMjNRaExfLWs=/atari_falcon_030_dsp_3d_engine_test</a>
</li>

<li>Atari Falcon030 (německy)<br />
<a href="http://www.maedicke.de/atari/hardware/falcon.htm">http://www.maedicke.de/atari/hardware/falcon.htm</a>
</li>

<li>Old-computers.com: Atari Falcon030<br />
<a href="http://www.old-computers.com/museum/computer.asp?c=125&st=1">http://www.old-computers.com/museum/computer.asp?c=125&st=1</a>
</li>

<li>Atari Falcon030 (Wikipedia)<br />
<a href="http://en.wikipedia.org/wiki/Atari_Falcon">http://en.wikipedia.org/wiki/Atari_Falcon</a>
</li>

<li>Past and current projects (including Falcon stuff)<br />
<a href="http://os.inf.tu-dresden.de/~nf2/projects/projects.html">http://os.inf.tu-dresden.de/~nf2/projects/projects.html</a>
</li>

<li>Atari Falcon 030: The Case For The Defence<br />
<a href="http://www.soundonsound.com/sos/1994_articles/sep94/atarifalcon.html">http://www.soundonsound.com/sos/1994_articles/sep94/atarifalcon.html</a>
</li>

<li>DaVinci processor family<br />
<a href="http://www.ti.com/general/docs/datasheetdiagram.tsp?genericPartNumber=TMS320DM365&diagramId=64193">http://www.ti.com/general/docs/datasheetdiagram.tsp?genericPartNumber=TMS320DM365&diagramId=64193</a>
</li>

<li>Texas Instruments DaVinci<br />
<a href="https://en.wikipedia.org/wiki/Texas_Instruments_DaVinci">https://en.wikipedia.org/wiki/Texas_Instruments_DaVinci</a>
</li>

<li>TMS320DM6446 (DaVinci)<br />
<a href="http://www.ti.com/product/tms320dm6446">http://www.ti.com/product/tms320dm6446</a>
</li>

<li>Digital Media Video Processors (TI)<br />
<a href="http://www.ti.com/lsds/ti/processors/dsp/media_processors/davinci/products.page#">http://www.ti.com/lsds/ti/processors/dsp/media_processors/davinci/products.page#</a>
</li>

<li>TI Wiki<br />
<a href="http://processors.wiki.ti.com/index.php/Main_Page">http://processors.wiki.ti.com/index.php/Main_Page</a>
</li>

<li>C5000 ultra-low-power DSP<br />
<a href="http://www.ti.com/lsds/ti/processors/dsp/c5000_dsp/overview.page">http://www.ti.com/lsds/ti/processors/dsp/c5000_dsp/overview.page</a>
</li>

<li>OMAP (Wikipedia)<br />
<a href="https://en.wikipedia.org/wiki/OMAP">https://en.wikipedia.org/wiki/OMAP</a>
</li>

<li>OMAP - TI Wiki<br />
<a href="http://processors.wiki.ti.com/index.php/OMAP">http://processors.wiki.ti.com/index.php/OMAP</a>
</li>

<li>Why OMAP can't compete in smartphones<br />
<a href="http://www.eetimes.com/author.asp?section_id=40&doc_id=1286602">http://www.eetimes.com/author.asp?section_id=40&doc_id=1286602</a>
</li>

<li>Applications Processors – The Heart of the Smartphone<br />
<a href="http://www.engineering.com/ElectronicsDesign/ElectronicsDesignArticles/ArticleID/5791/Applications-Processors-The-Heart-of-the-Smartphone.aspx">http://www.engineering.com/ElectronicsDesign/ElectronicsDesignArticles/ArticleID/5791/Applications-Processors-The-Heart-of-the-Smartphone.aspx</a>
</li>

<li>TI cuts 1,700 jobs in OMAP shift<br />
<a href="http://www.eetimes.com/document.asp?doc_id=1262782">http://www.eetimes.com/document.asp?doc_id=1262782</a>
</li>

<li>VLIW: Very Long Instruction Word: Texas Instruments TMS320C6x<br />
<a href="http://www.ecs.umass.edu/ece/koren/architecture/VLIW/2/ti1.html">http://www.ecs.umass.edu/ece/koren/architecture/VLIW/2/ti1.html</a>
</li>

<li>An Introduction To Very-Long Instruction Word (VLIW) Computer Architecture<br />
Philips Semiconductors
</li>

<li>VLIW Architectures for DSP: A Two-Part Lecture (PDF, slajdy)<br />
<a href="http://www.bdti.com/MyBDTI/pubs/vliw_icspat99.pdf">http://www.bdti.com/MyBDTI/pubs/vliw_icspat99.pdf</a>
</li>

<li>Very long instruction word (Wikipedia)<br />
<a href="https://en.wikipedia.org/wiki/Very_long_instruction_word">https://en.wikipedia.org/wiki/Very_long_instruction_word</a>
</li>

<li>A VLIW Approach to Architecture, Compilers and Tools<br />
<a href="http://www.vliw.org/book/">http://www.vliw.org/book/</a>
</li>

<li>VEX Toolchain (VEX = VLIW Example)<br />
<a href="http://www.hpl.hp.com/downloads/vex/">http://www.hpl.hp.com/downloads/vex/</a>
</li>

<li>Elbrus (computer)<br />
<a href="https://en.wikipedia.org/wiki/Elbrus_%28computer%29">https://en.wikipedia.org/wiki/Elbrus_%28computer%29</a>
</li>

<li>Super Harvard Architecture Single-Chip Computer<br />
<a href="https://en.wikipedia.org/wiki/Super_Harvard_Architecture_Single-Chip_Computer">https://en.wikipedia.org/wiki/Super_Harvard_Architecture_Single-Chip_Computer</a>
</li>

<li>Digital Signal Processors (stránky TI)<br />
<a href="http://www.ti.com/lsds/ti/processors/dsp/overview.page">http://www.ti.com/lsds/ti/processors/dsp/overview.page</a>
</li>

<li>C674x Low Power DSP (stránky TI)<br />
<a href="http://www.ti.com/lsds/ti/processors/dsp/c6000_dsp/c674x/overview.page">http://www.ti.com/lsds/ti/processors/dsp/c6000_dsp/c674x/overview.page</a>
</li>

<li>TMS320C30 (stránky TI)<br />
<a href="http://www.ti.com/product/tms320c30">http://www.ti.com/product/tms320c30</a>
</li>

<li>TMS320C6722B<br />
<a href="http://www.ti.com/product/tms320c6722b/description">http://www.ti.com/product/tms320c6722b/description</a>
</li>

<li>Introduction to DSP<br />
<a href="http://www.ti.com/lit/wp/spry281/spry281.pdf">http://www.ti.com/lit/wp/spry281/spry281.pdf</a>
</li>

<li>The Evolution of TMS (Family of DSPs)<br />
<a href="http://www.slideshare.net/moto_modx/theevo1">http://www.slideshare.net/moto_modx/theevo1</a>
</li>

<li>Datasheet k TMS32010<br />
<a href="http://www.datasheetarchive.com/dlmain/49326c32a52050140abffe6f0ac4894aa09889/M/TMS32010">http://www.datasheetarchive.com/dlmain/49326c32a52050140abffe6f0ac4894aa09889/M/TMS32010</a>
</li>

<li>1979: Single Chip Digital Signal Processor Introduced<br />
<a href="http://www.computerhistory.org/siliconengine/single-chip-digital-signal-processor-introduced/">http://www.computerhistory.org/siliconengine/single-chip-digital-signal-processor-introduced/</a>
</li>

<li>The TMS32010. The DSP chip that changed the destiny of a semiconductor giant<br />
<a href="http://www.tihaa.org/historian/TMS32010-12.pdf">http://www.tihaa.org/historian/TMS32010-12.pdf</a>
</li>

<li>Texas Instruments TMS320 (Wikipedia)<br />
<a href="https://en.wikipedia.org/wiki/Texas_Instruments_TMS320">https://en.wikipedia.org/wiki/Texas_Instruments_TMS320</a>
</li>

<li>Great Microprocessors of the Past and Present: Part IX: Signetics 8x300, Early cambrian DSP ancestor (1978):<br />
<a href="http://www.cpushack.com/CPU/cpu2.html#Sec2Part9">http://www.cpushack.com/CPU/cpu2.html#Sec2Part9</a>
</li>

<li>Great Microprocessors of the Past and Present (V 13.4.0)<br />
<a href="http://jbayko.sasktelwebsite.net/cpu.html">http://jbayko.sasktelwebsite.net/cpu.html</a>
</li>

<li>Introduction to DSP - DSP processors:<br />
<a href="http://www.bores.com/courses/intro/chips/index.htm">http://www.bores.com/courses/intro/chips/index.htm</a>
</li>

<li>The Scientist and Engineer's Guide to Digital Signal Processing:<br />
<a href="http://www.dspguide.com/">http://www.dspguide.com/</a>
</li>

<li>Digital signal processor (Wikipedia EN)<br />
<a href="http://en.wikipedia.org/wiki/Digital_signal_processor">http://en.wikipedia.org/wiki/Digital_signal_processor</a>
</li>

<li>Digitální signálový procesor (Wikipedia CZ)<br />
<a href="http://cs.wikipedia.org/wiki/Digitální_signálový_procesor">http://cs.wikipedia.org/wiki/Digitální_signálový_procesor</a>
</li>

<li>Digital Signal Processing FAQs<br />
<a href="http://dspguru.com/dsp/faqs">http://dspguru.com/dsp/faqs</a>
</li>

<li>Reprezentace numerických hodnot ve formátech FX a FP<br />
<a href="http://www.root.cz/clanky/fixed-point-arithmetic/">http://www.root.cz/clanky/fixed-point-arithmetic/</a>
</li>

<li>IEEE 754 a její příbuzenstvo: FP formáty<br />
<a href="http://www.root.cz/clanky/norma-ieee-754-a-pribuzni-formaty-plovouci-radove-tecky/">http://www.root.cz/clanky/norma-ieee-754-a-pribuzni-formaty-plovouci-radove-tecky/</a>
</li>

<li>Čtyři základní způsoby uložení čísel pomocí FX formátů<br />
<a href="http://www.root.cz/clanky/binarni-reprezentace-numerickych-hodnot-v-fx-formatu/">http://www.root.cz/clanky/binarni-reprezentace-numerickych-hodnot-v-fx-formatu/</a>
</li>

<li>Základní aritmetické operace prováděné v FX formátu<br />
<a href="http://www.root.cz/clanky/zakladni-aritmeticke-operace-provadene-ve-formatu-fx/">http://www.root.cz/clanky/zakladni-aritmeticke-operace-provadene-ve-formatu-fx/</a>
</li>

<li>Aritmetické operace s hodnotami uloženými ve formátu FP<br />
<a href="http://www.root.cz/clanky/aritmeticke-operace-s-hodnotami-ve-formatu-plovouci-radove-carky/">http://www.root.cz/clanky/aritmeticke-operace-s-hodnotami-ve-formatu-plovouci-radove-carky/</a>
</li>

<li>FIR Filter FAQ<br />
<a href="http://dspguru.com/dsp/faqs/fir">http://dspguru.com/dsp/faqs/fir</a>
</li>

<li>Finite impulse response (Wikipedia)<br />
<a href="http://en.wikipedia.org/wiki/Finite_impulse_response">http://en.wikipedia.org/wiki/Finite_impulse_response</a>
</li>

<li>DSPRelated<br />
<a href="http://www.dsprelated.com/">http://www.dsprelated.com/</a>
</li>

<li>Addressing mode (Wikipedia)<br />
<a href="https://en.wikipedia.org/wiki/Addressing_mode">https://en.wikipedia.org/wiki/Addressing_mode</a>
</li>

<li>Orthogonal instruction set<br />
<a href="https://en.wikipedia.org/wiki/Orthogonal_instruction_set">https://en.wikipedia.org/wiki/Orthogonal_instruction_set</a>
</li>

<li>TI 16-bit and 32-bit microcontrollers<br />
<a href="http://www.ti.com/lsds/ti/microcontrollers_16-bit_32-bit/overview.page">http://www.ti.com/lsds/ti/microcontrollers_16-bit_32-bit/overview.page</a>
</li>

<li>TMS 32010 Assembly Language Programmer's Guide (kniha na Amazonu)<br />
<a href="https://www.amazon.com/32010-Assembly-Language-Programmers-Guide/dp/0904047423">https://www.amazon.com/32010-Assembly-Language-Programmers-Guide/dp/0904047423</a>
</li>

<li>COSC2425: PC Architecture and Machine Language, PC Assembly Language<br />
<a href="http://www.austincc.edu/rblack/courses/COSC2425/index.html">http://www.austincc.edu/rblack/courses/COSC2425/index.html</a>
</li>

</ol>



<p></p><p></p>
<p><small>Autor: <a href="http://www.fit.vutbr.cz/~tisnovpa">Pavel Tišnovský</a> &nbsp; 2017</small></p>
</body>
</html>

