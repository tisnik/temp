<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
        "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html>
<head>
<title>Mikrořadiče a DSP společnosti Infineon: šestnáctibitové čipy C166 a XC166</title>
<meta name="Author" content="Pavel Tisnovsky" />
<meta name="Generator" content="vim" />
<meta http-equiv="content-type" content="text/html; charset=utf-8" />
<style type="text/css">
         body {color:#000000; background:#ffffff;}
         h1  {font-family: arial, helvetica, sans-serif; color:#ffffff; background-color:#c00000; text-align:center; padding-left:1em}
         h2  {font-family: arial, helvetica, sans-serif; color:#ffffff; background-color:#0000c0; padding-left:1em; text-align:left}
         h3  {font-family: arial, helvetica, sans-serif; color:#000000; background-color:#c0c0c0; padding-left:1em; text-align:left}
         h4  {font-family: arial, helvetica, sans-serif; color:#000000; background-color:#e0e0e0; padding-left:1em; text-align:left}
         a   {font-family: arial, helvetica, sans-serif;}
         li  {font-family: arial, helvetica, sans-serif; color:#000000; text-align:justify; width:450px;}
         ol  {font-family: arial, helvetica, sans-serif; color:#000000; text-align:justify; width:450px;}
         ul  {font-family: arial, helvetica, sans-serif; color:#000000; text-align:justify; width:450px;}
         p   {font-family: arial, helvetica, sans-serif; color:#000000; text-align:justify;}
         pre {background:#e0e0e0}
</style>
</head>

<body>

<h1>Mikrořadiče a DSP společnosti Infineon: šestnáctibitové čipy C166 a XC166</h1>

<h3>Pavel Tišnovský</h3>

<p></p>

<h1>Úvodník</h1>

<p>Minule popsaná řada mikrořadičů XC800 byla založena na zastaralém osmibitovém jádru 8051. Jedním z&nbsp;výsledků snah o náhradu této architektury je rodina šestnáctibitových mikrořadičových jader C166 navržená firmami ST Microelectronic a Infineon (dříve Siemens).</p>



<h2>Obsah</h2>

<p><a href="#k01">1. Mikrořadiče a DSP společnosti Infineon: šestnáctibitové čipy C166 a XC166</a></p>
<p><a href="#k02">2. Řada C166</a></p>
<p><a href="#k03">3. Řada XC166 (Classic Series)</a></p>
<p><a href="#k04">4. Řada XC166H (High Line)</a></p>
<p><a href="#k05">5. Moduly USIC</a></p>
<p><a href="#k06">6. Sada pracovních registrů</a></p>
<p><a href="#k07">7. PSW &ndash; Processor Status Word</a></p>
<p><a href="#k08">8. Podmínky používané při skocích</a></p>
<p><a href="#k09">9. Adresovací režimy</a></p>
<p><a href="#k10">10. Instrukční soubor jader C166</a></p>
<p><a href="#k11">11. Aritmetické a logické instrukce</a></p>
<p><a href="#k12">12. Porovnání operandů, rotace a posuny</a></p>
<p><a href="#k13">13. Bitové operace &ndash; Booleovský Processor</a></p>
<p><a href="#k14">14. Podmíněné i nepodmíněné skoky, skoky do subrutin</a></p>
<p><a href="#k15">15. Instrukce pro násobení a dělení</a></p>
<p><a href="#k16">16. Odkazy na Internetu</a></p>



<p><a name="k01"></a></p>
<h2 id="k01">1. Mikrořadiče a DSP společnosti Infineon: šestnáctibitové čipy C166 a XC166</h2>

<p><a
href="https://www.root.cz/clanky/mikroradice-a-dsp-spolecnosti-infineon/">Minule</a>
jsme se seznámili s&nbsp;mikrořadiči řady XC800 vyráběnými společností
Infineon. Připomeňme si, že tyto mikrořadiče jsou postaveny na osmibitovém
jádru 8051, které je již v&nbsp;mnoha ohledech zastaralé, což se negativně
projevuje zejména při snaze psát aplikace pro tyto mikrořadiče ve vyšších
programovacích jazycích (typicky v&nbsp;céčku). Osmibitová jádra 8051 jsou či
byla používána v&nbsp;mnoha firmách vyrábějících čipy. Mezi tyto firmy patří
například Atmel, Infineon, NXP, Microchip, ST Microelectronic, TI, Analog
Devices a dalších několik desítek (!) společností. Většina výrobců si
uvědomovala zastaralost 8051 a proto není divu, že vznikly různé čipy, které
měly tuto řadu nahradit. Nové čipy nabídly především vylepšenou instrukční sadu
vhodnější pro použití vyšších programovacích jazyků; mnohé mikrořadiče navíc
zvýšily šířku ALU a datových sběrnic na šestnáct bitů.</p>

<p>V&nbsp;tomto seriálu jsme se již zmiňovali o některých osmibitových
alternativách k&nbsp;8051. Kromě řady Motorola 68HC11 se jedná například o <a
href="https://www.root.cz/clanky/osmibitove-mikroradice-avr-rady-attiny-a-atmega/">Atmel
AVR</a> (dnes populární mj.&nbsp;i díky Arduinu), <a
href="https://www.root.cz/clanky/rodina-mikroprocesoru-a-mikroradicu-h8/">H8</a>,
<a
href="https://www.root.cz/clanky/mikroradice-ez8-aneb-potomek-legendarniho-z80/">eZ8</a>
či <a
href="https://www.root.cz/clanky/osmibitove-mikroradice-rabbit-pravi-dedicove-mikroprocesoru-zilog-z80/">Rabbit</a>
(poslední dva čipy jsou založeny na Zilogu Z80). Nutno podotknout, že
osmibitové mikrořadiče se v&nbsp;současnosti stále používají a v&nbsp;některých
oblastech se s&nbsp;velkou pravděpodobností budou používat i nadále, protože
pořád existují požadavky na sice málo výkonný, ale levný čip s&nbsp;malou
spotřebou, který lze v&nbsp;případě potřeby doplnit o pomocné koprocesory (FOC
apod.).</p>

<p>Logickým krokem při vývoji výkonnějších mikrořadičů je zvýšení šířky ALU,
pracovních registrů a datových sběrnic z&nbsp;osmi na šestnáct bitů. I těmito
čipy jsme se již zabývali (i když ne v&nbsp;plné šíři). Připomeňme si zejména
řadu <a
href="https://www.root.cz/clanky/sestnactibitove-mikroradice-ti-rady-msp430/">MSP
430</a> společnosti TI či čipy <a
href="https://www.root.cz/clanky/rodina-mikroprocesoru-a-mikroradicu-h8-rada-300h/">H8/300H</a>
vyráběné holdingem Renesas. Podobnou cestou, tj.&nbsp;zvětšením šířky ALU a
pracovních registrů, se vydali inženýři ve formách ST Microelectronic a
Infineon při vývoji šestnáctibitových mikrořadičových jader
<strong>C166</strong>, na něž navázala zpětně kompatibilní jádra
<strong>XC166</strong>.</p>



<p><a name="k02"></a></p>
<h2 id="k02">2. Řada C166</h2>

<p>Při návrhu mikrořadičových jader <i>C166</i> si inženýři dobře uvědomovali,
že pouhé rozšíření ALU a registrů z&nbsp;osmi na šestnáct bitů není
dostačující. Pro efektivní práci se strojovým kódem vzniklým překladem
z&nbsp;céčka je totiž důležité mít k&nbsp;dispozici větší sadu univerzálně
použitelných pracovních registrů (8051 naproti tomu měla jen akumulátor,
dalších osm registrů mělo jen omezené možnosti) a taktéž adresovací režimy
korespondující s&nbsp;možnostmi céčka, tj.&nbsp;práci s&nbsp;poli, práci
s&nbsp;offsety při použití struktur atd. (opět &ndash; možnosti 8051 jsou zde
velmi omezené na použití šestnáctibitového registru DPTR, osmibitových registrů
R0, R1 a akumulátoru ve funkci offsetového registru). Navíc se ukázalo, že
v&nbsp;mnoha aplikacích je vhodné mít k&nbsp;dispozici násobičku a děličku o
šířce alespoň šestnácti bitů, která ovšem u těchto typů mikrořadičů nemusí být
tak rychlá, jako u klasických DSP (v&nbsp;nichž zabírala násobička velkou část
čipu).</p>

<p>Při návrhu <i>C166</i> již navíc byly k&nbsp;dispozici dobré i špatné
zkušenosti s&nbsp;vývojem RISCových mikroprocesorů s&nbsp;instrukční pipeline,
takže <i>C166</i> mají pipeline se čtyřmi řezy a jejich instrukční sada se
v&nbsp;některých ohledech podobá RISCovým procesorům, i když je nutné
poznamenat, že se nejedná o čistý RISC s&nbsp;Load a Store architekturou. Na
druhou stranu se návrháři <i>C166</i> snažili zachovat dobré vlastnosti 8051,
takže na těchto čipech nalezneme Booleovský procesor, dokonce oproti 8051
v&nbsp;několika ohledech vylepšený.</p>



<p><a name="k03"></a></p>
<h2 id="k03">3. Řada XC166 (Classic Series)</h2>

<p>Společnost Infineon používá jádra <i>C166</i> vylepšená o další funkce
(několik nových instrukcí) a doplněná o různé rozšiřující moduly, které okolo
těchto jader vytváří plnohodnotný mikrořadič. Řada XC166 nazývaná taktéž
&bdquo;Classic Series&ldquo; je založena na jádrech C166S V2, která mohou
používat hodinovou frekvenci až 80 MHz a teoreticky tak dosahovat maximální
výpočetní rychlosti 80 MIPS (reálně to však bude méně, zhruba 75% špičkové
rychlosti, i když je většina instrukcí v&nbsp;sedmiřezové pipeline dokončena
v&nbsp;jediném taktu). Kromě vlastního jádra je na mikrořadiči umístěna i
jednotka MAC (Multiply &amp; Accumulate), paměť RAM o typické kapacitě 24 KB až
82 KB (v&nbsp;závislosti na konkrétní verzi čipu), Flash paměť o kapacitě až
768 KB, modul pro PWM (pulsně-šířkovou modulaci), až šest modulů <a
href="#k05">USIC</a> a některé čipy mají i řadič pro CAN nebo MultiCAN.
Zajímavé je, že je podporován ECC, a to jak pro SRAM, tak i pro paměť Flash,
což je vlastnost více než vítaná (a patřičně drahá :-), především
v&nbsp;průmyslových aplikacích.</p>



<p><a name="k04"></a></p>
<h2 id="k04">4. Řada XC166H (High Line)</h2>

<p>Poněkud výkonnější řada se jmenuje <i>XC166H</i> neboli &bdquo;High
Line&ldquo;. Mikrořadičová jádra používají poněkud vyšší hodinovou frekvenci
(až 100 MHz, tedy teoreticky výkon 100 MIPS), mají čtyři jednotky PWM používané
například pro řízení motorů (včetně třífázových motorů), rychlé A/D převodníky
(taktéž používané při řízení motorů), počet <a href="#k05">USIC</a> se zvýšil
na deset (tedy celkově dvacet kanálů!) a používají dvouvodičový JTAG (původně
se používal klasický pětivodičový JTAG). I zde se můžeme setkat s&nbsp;použitím
ECC jak pro SRAM, tak i pro paměť Flash.</p>



<p><a name="k05"></a></p>
<h2 id="k05">5. Moduly USIC</h2>

<p>V&nbsp;mikrořadičích Infineon řady <i>XC166</i> se používají moduly
<strong>USIC</strong> neboli <i>Universal Serial Interface Channel</i>. Každý
z&nbsp;těchto modulů obsahuje dva konfigurovatelné kanály s&nbsp;totožnou
strukturou. Tyto kanály lze použít pro napojení mikrořadiče na různé typy portů
a sběrnic, včetně klasického UARTu, SPI a I<sup>2</sup>C. Každý
<strong>USIC</strong> také může generovat vlastní hodinový signál pro řízení
rychlosti přenosu dat (<i>baudrate</i>). Tento signál je nezávislý na dalších
<strong>USIC</strong>, takže je možné jeden mikrořadič propojit s&nbsp;různě
rychlými zařízeními po samostatných a oddělených SPI (navíc s&nbsp;volbou
poloduplexního či plně duplexního režimu).</p>



<p><a name="k06"></a></p>
<h2 id="k06">6. Sada pracovních registrů</h2>

<p>Mikrořadiče C166 obsahují šestnáct pracovních registrů, z&nbsp;nichž každý
má šířku šestnáct bitů. To je poměrně vysoký počet, a to i v&nbsp;porovnání
s&nbsp;konkurencí, protože i když například <i>MSP430</i> od TI má
&bdquo;papírově&ldquo; tentýž počet registrů, jsou čtyři z&nbsp;nich použity
pro jiné účely (čítač instrukcí, ukazatel na vrchol zásobníku, stavový registr
a generátor konstant). Zajímavé a užitečné je, že u C166 je možné k&nbsp;osmi
registrům přistupovat i po bajtech. K&nbsp;pracovním registrům lze připočítat i
dvojici registrů použitou pro násobení a dělení:</p>

<table>
<tr><th>Registry</th><th>Šířka</th><th>Význam</th></tr>
<tr><td>R0..R15</td><td>16 bitů</td><td>šestnáct pracovních registrů (GPR)</td></tr>
<tr><td>RL0..RL7</td><td>8 bitů</td><td>spodní bajty prvních osmi registrů R0..R7</td></tr>
<tr><td>RH0..RH7</td><td>8 bitů</td><td>horní bajty prvních osmi registrů R0..R7</td></tr>
<tr><td>MDH</td><td>16 bitů</td><td>použit ve dvojici MDH:MDL při dělení 32&div;16 bitů</td></tr>
<tr><td>MDL</td><td>16 bitů</td><td>použit jako dělenec při dělení 16&div;16 bitů</td></tr>
</table>



<p><a name="k07"></a></p>
<h2 id="k07">7. PSW &ndash; Processor Status Word</h2>

<p>Stav procesoru je z&nbsp;velké části uložen v&nbsp;registru nazvaném
<strong>PWD</strong> neboli <i>Processor Status Word</i>. Podobně jako další
registry má i tento šířku šestnácti bitů a je rozdělen na několik bitových polí
a na samostatné bitové příznaky (ty se nijak zvlášť neliší od dalších typů CPU
a MCU):</p>

<table>
<tr><th>Bit</th><th>Označení</th><th>Význam</th></tr>
<tr><td> 0</td><td>N</td><td>příznak záporného výsledku</td></tr>
<tr><td> 1</td><td>C</td><td>příznak přenosu</td></tr>
<tr><td> 2</td><td>V</td><td>příznak přetečení</td></tr>
<tr><td> 3</td><td>Z</td><td>příznak nulovosti</td></tr>
<tr><td> 4</td><td>E</td><td>výsledkem operace je nejmenší hodnota (0x80 či 0x8000)</td></tr>
<tr><td> 5</td><td>MULIP</td><td>došlo k&nbsp;přerušení násobení či dělení (tyto operace lze přerušit během výpočtu)</td></tr>
<tr><td> 6</td><td>USR0</td><td>uživatelsky nastavitelný bit</td></tr>
<tr><td> 7</td><td>&times;</td><td></td></tr>
<tr><td> 8</td><td>&times;</td><td></td></tr>
<tr><td> 9</td><td>&times;</td><td></td></tr>
<tr><td>10</td><td>HLDEN</td><td>povolení <a href="https://en.wikipedia.org/wiki/Bus_mastering">externího řízení sběrnice</a> jiným čipem přes signály BREQ, HOLD a HLDA</td></tr>
<tr><td>11</td><td>IEN</td><td>povolení či zákaz přerušení</td></tr>
<tr><td>12</td><td>ILVL</td><td>úroveň přerušení</td></tr>
<tr><td>13</td><td>ILVL</td><td>úroveň přerušení</td></tr>
<tr><td>14</td><td>ILVL</td><td>úroveň přerušení</td></tr>
<tr><td>15</td><td>ILVL</td><td>úroveň přerušení</td></tr>
</table>

<p>Nejvyšší čtyři bity definují jednu ze šestnácti úrovní přerušení.</p>

<p>Poznámka: k&nbsp;bitům 7 až 9 mohou mít na novějších čipech přiřazeny další
funkce.</p>



<p><a name="k08"></a></p>
<h2 id="k08">8. Podmínky používané při skocích</h2>

<p>U instrukcí <strong>JMPA</strong>, <strong>JMPI</strong>,
<strong>JMPR</strong>, <strong>CALLA</strong>, <strong>CALLI</strong> a
<strong>CALLR</strong>, které jsou popsány <a href="#k14">ve čtrnácté
kapitole</a> je možné s&nbsp;využitím čtyř bitů specifikovat podmínku, při
jejímž splnění se skok či volání subrutiny provede. Jedná se o následující
podmínky (některé jsou zdvojeny, takže tabulka má více řádků). Neobvyklá je
poslední podmínka, která používá příznak <strong>E</strong> a zjišťuje tak
hodnoty MIN_INT:</p>

<table>
<tr><th>Postfix</th><th>Testovaná podmínka</th><th>Význam</th></tr>
<tr><td>_UC </td><td>1 == 1</td><td>(instrukce je provedena vždy)</td></tr>
<tr><td>_Z  </td><td>Z == 1</td><td>(alias pro _EQ)</td></tr>
<tr><td>_NZ </td><td>Z == 0</td><td>(alias pro _NE)</td></tr>
<tr><td>_V  </td><td>V == 1</td><td>přetečení</td></tr>
<tr><td>_NV </td><td>V == 0</td><td>nedošlo k&nbsp;přetečení</td></tr>
<tr><td>_N  </td><td>N == 1</td><td>operace skončila se záporným výsledkem</td></tr>
<tr><td>_NN </td><td>N == 0</td><td>výsledek je kladný nebo nulový</td></tr>
<tr><td>_C  </td><td>C == 1</td><td>přenos</td></tr>
<tr><td>_NC </td><td>C == 0</td><td>nedošlo k&nbsp;přenosu</td></tr>
<tr><td>_EQ </td><td>Z == 1</td><td>(alias pro _Z)</td></tr>
<tr><td>_NE </td><td>Z == 0</td><td>(alias pro _NZ)</td></tr>
<tr><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td></tr>
<tr><td>_ULT</td><td>C == 1</td><td>&lt; bez znaménka (alias pro _C)</td></tr>
<tr><td>_ULE</td><td>(Z ∨ C) == 1</td><td>&le; bez znaménka</td></tr>
<tr><td>_UGE</td><td>C == 0</td><td>&ge; bez znaménka (alias pro _NC)</td></tr>
<tr><td>_UGT</td><td>(Z ∨ C) == 0</td><td>&gt; bez znaménka</td></tr>
<tr><td>_SLT</td><td>(N &oplus; V) == 1</td><td>&lt; se znaménkem</td></tr>
<tr><td>_SLE</td><td>(Z ∨ (N &oplus; V)) == 1</td><td>&le; se znaménkem</td></tr>
<tr><td>_SGE</td><td>(N &oplus; V) == 0</td><td>&ge; se znaménkem</td></tr>
<tr><td>_SGT</td><td>(Z ∨ (N &oplus; V)) == 0</td><td>&gt; se znaménkem</td></tr>
<tr><td>_NET</td><td>(Z ∨ E) == 0</td><td>&ne;</td></tr>
</table>



<p><a name="k09"></a></p>
<h2 id="k09">9. Adresovací režimy</h2>

<p>Při čtení či zápisu operandů je možné využít adresovací režimy zmíněné
v&nbsp;následující tabulce. Povšimněte si, že každý pracovní registr může
současně sloužit pro adresování, což (společně s&nbsp;režimy post-inkrementace
a pre-dekrementace) umožňuje efektivní provádění mnoha céčkových
konstrukcí:</p>

<table>
<tr><th>Zápis</th><th>Adresovací režim</th></tr>
<tr><td>Rw</td><td>libovolný 16bitový pracovní registr R0..R15</td></tr>
<tr><td>Rb</td><td>libovolný osmibitový pracovní registr RL0..RL7, RH0..RH7</td></tr>
<tr><td>reg</td><td>speciální funkční registr 0xff .. 0xef</td></tr>
<tr><td>bitaddr</td><td>použito při adresování bitů 0..15 na adresách 0x00 až 0xff</td></tr>
<tr><td>[Rw]</td><td>obsah adresy, na níž ukazuje zvolený GPR</td></tr>
<tr><td>[Rw+]</td><td>obsah adresy, na níž ukazuje zvolený GPR, post-inkrement obsahu registru</td></tr>
<tr><td>[-Rw]</td><td>obsah adresy, na níž ukazuje zvolený GPR, pre-dekrement obsahu registru</td></tr>
<tr><td>[Rw+#data]</td><td>zvolit lze i šestnáctibitový offset</td></tr>
<tr><td>#data3</td><td>tříbitová konstanta (součástí instrukce)</td></tr>
<tr><td>#data4</td><td>čtyřbitová konstanta (součástí instrukce)</td></tr>
<tr><td>#data8</td><td>osmibitová konstanta</td></tr>
<tr><td>#data16</td><td>šestnáctibitová konstanta</td></tr>
</table>

<p>Poznámka: SFR = <a
href="https://en.wikipedia.org/wiki/Special_function_register">speciální
funkční registr</a>, GPR = pracovní registr.</p>



<p><a name="k10"></a></p>
<h2 id="k10">10. Instrukční soubor jader C166</h2>

<p>Instrukční soubor jader <i>C166</i> obsahuje 75 instrukcí, v&nbsp;jádrech
<i>XC166</i> se jejich počet ještě nepatrně zvyšuje. V&nbsp;navazujících
kapitolách jsou popsány všechny základní instrukce; prozatím jsou však
vynechány instrukce určené pro přenosy dat a taktéž instrukce, které nejsou ve
všech jádrech používány &ndash; <strong>ATOMIC</strong>,
<strong>BFLDxxx</strong> a <strong>EXTxxx</strong>.



<p><a name="k11"></a></p>
<h2 id="k11">11. Aritmetické a logické instrukce</h2>

<p>Sada základních aritmetických instrukcí se podobá nabídce známé
z&nbsp;dalších typů mikrořadičů (kromě 8048, která neobsahuje instrukce rozdílu
a 8051, která neobsahuje <strong>SUB</strong> ale jen <strong>SUBB</strong>).
Zajímavé ovšem je, že všechny instrukce existují v&nbsp;šestnáctibitové i
osmibitové variantě:</p>

<table>
<tr><th>Instrukce</th><th>Varianta</th><th>Stručný popis</th></tr>
<tr><td>ADD</td><td>ADDB</td><td>součet</td></tr>
<tr><td>ADDC</td><td>ADDCB</td><td>součet + carry</td></tr>
<tr><td>SUB</td><td>SUBB</td><td>rozdíl</td></tr>
<tr><td>SUBC</td><td>SUBC</td><td>rozdíl - carry</td></tr>
<tr><td>CPL</td><td>CPLB</td><td>jedničkový doplněk (negace)</td></tr>
<tr><td>NEG</td><td>NEGB</td><td>dvojkový doplněk (změna znaménka)</td></tr>
</table>

<p>Poznámka: tyto instrukce nastavují příznaky <strong>N</strong>,
<strong>Z</strong>, <strong>V</strong>, <strong>C</strong> i
<strong>E</strong>.</p>

<p>Podobně je tomu u logických instrukcí, které se provádí bit po bitu; opět
buď pro šestnáctibitové operandy nebo i pro operandy osmibitové. Instrukce
nastavují příznaky <strong>N</strong>, <strong>Z</strong> a <strong>E</strong>
podle výsledku, zatímco příznaky <strong>V</strong> a <strong>C</strong> jsou
vynulovány:</p>

<table>
<tr><th>Instrukce</th><th>Varianta</th><th>Stručný popis</th></tr>
<tr><td>AND</td><td>ANDB</td><td>logický součin</td></tr>
<tr><td>OR</td><td>ORB</td><td>logický součet</td></tr>
<tr><td>XOR</td><td>XORB</td><td>logická nonekvivalence</td></tr>
<tr><td>SUBC</td><td>SUBC</td><td>rozdíl - carry</td></tr>
</table>

<p>Poznámka: instrukce pro násobení a dělení jsou prováděny mimo hlavní
aritmeticko-logickou jednotku a proto jsou popsány <a
href="#k15">v&nbsp;samostatné kapitole</a>.</p>



<p><a name="k12"></a></p>
<h2 id="k12">12. Porovnání operandů, rotace a posuny</h2>

<p>Zajímavá je sada instrukcí určených pro porovnání dvou operandů. Kromě běžné
instrukce <strong>CMP</strong> jsou podporovány i instrukce, které <i>po
porovnání</i> zvýší či sníží obsah prvního operandu (registru) o jedničku či
dvojku. Tímto operandem je vždy nějaký šestnáctibitový pracovní registr.
Pravděpodobně jste již uhodli, k&nbsp;čemu se tyto instrukce používají &ndash;
jde o implementaci různých typů počítaných programových smyček (procesor
naproti tomu nemá instrukci typu <strong>DJNZ</strong> či
<strong>CJNE</strong>):</p>

<table>
<tr><th>Instrukce</th><th>Varianta</th><th>Stručný popis</th></tr>
<tr><td>CMP</td><td>CMPB</td><td>porovnání dvou operandů a nastavení příznaků</td></tr>
<tr><td>CMPD1</td><td>&times;</td><td>porovnání + snížení obsahu registru o 1</td></tr>
<tr><td>CMPD2</td><td>&times;</td><td>porovnání + snížení obsahu registru o 2</td></tr>
<tr><td>CMPI1</td><td>&times;</td><td>porovnání + zvýšení obsahu registru o 1</td></tr>
<tr><td>CMPI2</td><td>&times;</td><td>porovnání + zvýšení obsahu registru o 2</td></tr>
</table>

<p>Dalších pět instrukcí opět pracuje se šestnáctibitovými pracovními registry
a umožňuje jejich rotaci, logický posun či aritmetický posun. I přesto, že
druhý operand může teoreticky obsahovat jakoukoli hodnotu, je rotace/posun
provedena maximálně o patnáct bitů (vyšší hodnoty se maskují 0x0f,
resp.&nbsp;se jejich vyšší bity úspěšně ignorují):</p>

<table>
<tr><th>Instrukce</th><th>Varianta</th><th>Stručný popis</th></tr>
<tr><td>SHL</td><td>&times;</td><td>bitový posun doleva (0..15)</td></tr>
<tr><td>SHR</td><td>&times;</td><td>bitový posun doprava (0..15)</td></tr>
<tr><td>ROL</td><td>&times;</td><td>rotace doleva (0..15)</td></tr>
<tr><td>ROR</td><td>&times;</td><td>rotace doprava (0..15)</td></tr>
<tr><td>ASHR</td><td>&times;</td><td>aritmetický posun doprava</td></tr>
</table>



<p><a name="k13"></a></p>
<h2 id="k13">13. Bitové operace &ndash; Booleovský Processor</h2>

<p>V&nbsp;oblasti mikrořadičů se již od dob čipu <i>Intel 8051 (MCS-51)</i>
můžeme setkat s&nbsp;implementací takzvaného Booleovského procesoru. Tímto
poněkud nadneseným jménem se označuje sada instrukcí, které dokážou pracovat na
úrovni jednotlivých bitů a nikoli celých slov, a to (většinou) dokonce takovým
způsobem, že i přístup do paměti či do řídicích registrů periferních zařízení
je prováděn po jednom bitu (například negace jediného bitu je rozdílná operace
od přečtení bajtu/slova do akumulátoru, negace vybraného bitu a zápis celého
bajtu/slova zpět). Jen pro zajímavost: na již zmíněném mikrořadiči
<i>MCS-51</i> je implementován úplný Booleovský procesor s&nbsp;jednobitovým
akumulátorem (tím je příznak <strong>C</strong>/carry), 128 bitovou oblastí RAM
a 128 bitovou oblastí speciálních řídicích registrů (SFR). Tento Booleovský
procesor měl k&nbsp;dispozici sedmnáct instrukcí.</p>

<p>U čipů <i>C166</i> se jedná o osm instrukcí doplněných o čtyři podmíněné
skoky popsané v&nbsp;další kapitole:</p>

<table>
<tr><th>Instrukce</th><th>Stručný popis</th></tr>
<tr><td>BCLR</td><td>vynulování bitu</td></tr>
<tr><td>BSET</td><td>nastavení bitu na jedničku</td></tr>
<tr><td>&nbsp;</td><td>&nbsp;</td></tr>
<tr><td>BMOV</td><td>přenos bitu</td></tr>
<tr><td>BMOVN</td><td>přenos bitu s&nbsp;jeho negací</td></tr>
<tr><td>&nbsp;</td><td>&nbsp;</td></tr>
<tr><td>BCMP</td><td>porovnání dvou bitů</td></tr>
<tr><td>&nbsp;</td><td>&nbsp;</td></tr>
<tr><td>BAND</td><td>operace AND se dvěma bity</td></tr>
<tr><td>BOR</td><td>operace OR se dvěma bity</td></tr>
<tr><td>BXOR</td><td>operace XOR se dvěma bity</td></tr>
</table>

<p>Poznámka: instrukce <strong>BCLR</strong> a <strong>BSET</strong> obsahují
index nulovaného či naopak nastavovaného bitu přímo v&nbsp;operačním kódu
instrukce. Vzhledem k&nbsp;tomu, že lze vybírat ze šestnácti bitů, znamená to,
že <strong>BCLR</strong> zabírá celých 16 instrukčních kódů z&nbsp;256 a totéž
platí i pro <strong>BSET</strong> (tímto odstavcem jsme si tedy popsali celých
12,5% všech instrukčních kódů :-).</p>

<p>Poznámka<sup>2</sup>: ostatních šest instrukcí má délku čtyř bajtů, protože
je nutné zakódovat typ instrukce (jeden bajt), zdrojový operand (jeden bajt),
cílový operand (taktéž jeden bajt) a následně 4+4 bity reprezentující indexy
bitů ve zdrojovém a v&nbsp;cílovém operandu.</p>



<p><a name="k14"></a></p>
<h2 id="k14">14. Podmíněné i nepodmíněné skoky, skoky do subrutin</h2>

<p>V&nbsp;této sekci se nejdříve zmíníme o podmíněných i nepodmíněných skocích.
Pro jejich implementaci lze použít čtyři instrukce, přičemž pouze
v&nbsp;poslední instrukci <strong>JMPS</strong> není možné použít podmínku.
Naopak se jedná o jedinou instrukci umožňující skok do jiného segmentu:</p>

<table>
<tr><th>Instrukce</th><th>Stručný popis</th></tr>
<tr><td>JMPA</td><td>absolutní skok při splnění podmínky</td></tr>
<tr><td>JMPI</td><td>nepřímý skok při splnění podmínky</td></tr>
<tr><td>JMPR</td><td>relativní skok při splnění podmínky</td></tr>
<tr><td>JMPS</td><td>absolutní skok do vybraného segmentu (bez podmínky)</td></tr>
</table>

<p>Následují čtyři instrukce doplňující výše popsaný Booleovský procesor. Jedná
se o skoky vykonané ve chvíli, kdy je zvolený bit nastaven na jedničku
popř.&nbsp;na nulu. Poslední dvě instrukce navíc dokážou hodnotu testovaného
bitu znegovat:</p>

<table>
<tr><th>Instrukce</th><th>Stručný popis</th></tr>
<tr><td>JB</td><td>relativní skok za podmínky, že je bit nastaven na 1</td></tr>
<tr><td>JNB</td><td>relativní skok za podmínky, že je bit vynulován</td></tr>
<tr><td>JBC</td><td>relativní skok za podmínky, že je bit nastaven a vynulování bitu</td></tr>
<tr><td>JNBS</td><td>relativní skok za podmínky, že je bit vynulován a nastavení bitu</td></tr>
</table>

<p>Další sada instrukcí slouží pro skok do subrutin (podprogramů) a návrat
z&nbsp;nich. První čtyři instrukce odpovídají již popsaným skokům, ovšem
návratová adresa je uložena na zásobník:</p>

<table>
<tr><th>Instrukce</th><th>Stručný popis</th></tr>
<tr><td>CALLA</td><td>zavolání subrutiny při splnění podmínky</td></tr>
<tr><td>CALLI</td><td>nepřímé volání subrutiny při splnění podmínky</td></tr>
<tr><td>CALLR</td><td>relativní volání subrutiny při splnění podmínky</td></tr>
<tr><td>CALLS</td><td></td></tr>
<tr><td>&nbsp;</td><td>&nbsp;</td></tr>
<tr><td>PCALL</td><td>uložení registru na zásobník a zavolání subrutiny</td></tr>
<tr><td>&nbsp;</td><td>&nbsp;</td></tr>
<tr><td>RET</td><td>návrat ze subrutiny (stejný segment)</td></tr>
<tr><td>RETS</td><td>návrat ze subrutiny (jiný segment)</td></tr>
<tr><td>RETP</td><td>návrat ze subrutiny a obnovení registru</td></tr>
<tr><td>RETI</td><td>návrat z&nbsp;přerušovací rutiny</td></tr>
</table>



<p><a name="k15"></a></p>
<h2 id="k15">15. Instrukce pro násobení a dělení</h2>

<p>Samostatnou skupinu tvoří instrukce určené pro násobení a dělení. U těchto
instrukcí se operandy ukládají jak do běžných pracovních registrů, tak i do
dvou již zmíněných speciálních funkčních registrů nazvaných
<strong>MDH</strong> a <strong>MDL</strong>. Tyto registry tvoří dvojici
<strong>MDH:MDL</strong> a slouží například pro uložení dělence při dělení
32&div;16 bitů. Násobička a dělička podporuje těchto šest instrukcí:</p>

<table>
<tr><th>Instrukce</th><th>Typ operandů</th><th>Stručný popis</th></tr>
<tr><td>MUL</td><td>se znaménkem</td><td>násobení 16&times;16 bitů</td></tr>
<tr><td>MULU</td><td>bez znaménka</td><td>násobení 16&times;16 bitů</td></tr>
<tr><td>DIV</td><td>se znaménkem</td><td>dělení 16&div;16 bitů</td></tr>
<tr><td>DIVU</td><td>bez znaménka</td><td>dělení 16&div;16 bitů</td></tr>
<tr><td>DIVL</td><td>se znaménkem</td><td>dělení 32&div;16 bitů</td></tr>
<tr><td>DIVLU</td><td>bez znaménka</td><td>dělení 32&div;16 bitů</td></tr>
</table>

<p>Poznámka: tyto instrukce lze přerušit, což se projeví nastavením příznaku
<strong>MULIP</strong> v&nbsp;<strong>PSW</strong>. Důvod je zřejmý &ndash; u
mikrořadičů požadujeme rychlou reakci na přerušení, takže je výhodnější nečekat
vždy na dokončení těchto dlouhotrvajících instrukcí.</p>



<p><a name="k16"></a></p>
<h2 id="k16">16. Odkazy na Internetu</h2>

<ol>

<li>Bus mastering<br />
<a href="https://en.wikipedia.org/wiki/Bus_mastering">https://en.wikipedia.org/wiki/Bus_mastering</a>
</li>

<li>ST10 16-bit MCUs<br />
<a href="http://www.st.com/en/microcontrollers/st10-16-bit-mcus.html?querycriteria=productId=LN1111">http://www.st.com/en/microcontrollers/st10-16-bit-mcus.html?querycriteria=productId=LN1111</a>
</li>

<li>XC800 family<br />
<a href="https://en.wikipedia.org/wiki/XC800_family">https://en.wikipedia.org/wiki/XC800_family</a>
</li>

<li>C166 (stránky společnosti Infineon)<br />
<a href="https://www.infineon.com/cms/en/product/microcontroller/16-bit-c166-microcontroller/channel.html?channel=ff80808112ab681d0112ab6b2eaf0759#ispnTab3">https://www.infineon.com/cms/en/product/microcontroller/16-bit-c166-microcontroller/channel.html?channel=ff80808112ab681d0112ab6b2eaf0759#ispnTab3</a>
</li>

<li>C166 Family<br />
<a href="https://en.wikipedia.org/wiki/C166_family">https://en.wikipedia.org/wiki/C166_family</a>
</li>

<li>Permanent Magnet Synchronous Motor<br />
<a href="https://en.wikipedia.org/wiki/Synchronous_motor#Permanent_magnet_motors">https://en.wikipedia.org/wiki/Synchronous_motor#Permanent_magnet_motors</a>
</li>

<li>Implementing field oriented control of a brushless DC motor<br />
<a href="http://www.eetimes.com/document.asp?doc_id=1279321">http://www.eetimes.com/document.asp?doc_id=1279321</a>
</li>

<li>Vector control (motor)<br />
<a href="https://en.wikipedia.org/wiki/Vector_control_(motor)">https://en.wikipedia.org/wiki/Vector_control_(motor)</a>
</li>

<li>Motorola DSP56k<br />
<a href="https://www.rockbox.org/wiki/MotorolaDSP56k">https://www.rockbox.org/wiki/MotorolaDSP56k</a>
</li>

<li>Motorola 56000 (Wikipedia)<br />
<a href="http://en.wikipedia.org/wiki/Motorola_56000">http://en.wikipedia.org/wiki/Motorola_56000</a>
</li>

<li>Using the Motorola DSP56002EVM for Amateur Radio DSP Projects<br />
<a href="http://www.johanforrer.net/EVM/article.html">http://www.johanforrer.net/EVM/article.html</a>
</li>

<li>The Atari Falcon030 "Personal Integrated Media System"<br />
<a href="http://www.atarimuseum.com/computers/16bits/falcon030.html">http://www.atarimuseum.com/computers/16bits/falcon030.html</a>
</li>

<li>Turtle Beach Corporation (stránky společnosti)<br />
<a href="http://www.turtlebeach.com/">http://www.turtlebeach.com/</a>
</li>

<li>Turtle Beach Corporation (Wikipedia)<br />
<a href="https://en.wikipedia.org/wiki/Turtle_Beach_Corporation">https://en.wikipedia.org/wiki/Turtle_Beach_Corporation</a>
</li>

<li>Atari Falcon 030 DSP 3D engine test<br />
<a href="http://www.digiti.info/video/WHQwMjNRaExfLWs=/atari_falcon_030_dsp_3d_engine_test">http://www.digiti.info/video/WHQwMjNRaExfLWs=/atari_falcon_030_dsp_3d_engine_test</a>
</li>

<li>Atari Falcon030 (německy)<br />
<a href="http://www.maedicke.de/atari/hardware/falcon.htm">http://www.maedicke.de/atari/hardware/falcon.htm</a>
</li>

<li>Old-computers.com: Atari Falcon030<br />
<a href="http://www.old-computers.com/museum/computer.asp?c=125&st=1">http://www.old-computers.com/museum/computer.asp?c=125&st=1</a>
</li>

<li>Atari Falcon030 (Wikipedia)<br />
<a href="http://en.wikipedia.org/wiki/Atari_Falcon">http://en.wikipedia.org/wiki/Atari_Falcon</a>
</li>

<li>Past and current projects (including Falcon stuff)<br />
<a href="http://os.inf.tu-dresden.de/~nf2/projects/projects.html">http://os.inf.tu-dresden.de/~nf2/projects/projects.html</a>
</li>

<li>Atari Falcon 030: The Case For The Defence<br />
<a href="http://www.soundonsound.com/sos/1994_articles/sep94/atarifalcon.html">http://www.soundonsound.com/sos/1994_articles/sep94/atarifalcon.html</a>
</li>

<li>DaVinci processor family<br />
<a href="http://www.ti.com/general/docs/datasheetdiagram.tsp?genericPartNumber=TMS320DM365&diagramId=64193">http://www.ti.com/general/docs/datasheetdiagram.tsp?genericPartNumber=TMS320DM365&diagramId=64193</a>
</li>

<li>Texas Instruments DaVinci<br />
<a href="https://en.wikipedia.org/wiki/Texas_Instruments_DaVinci">https://en.wikipedia.org/wiki/Texas_Instruments_DaVinci</a>
</li>

<li>TMS320DM6446 (DaVinci)<br />
<a href="http://www.ti.com/product/tms320dm6446">http://www.ti.com/product/tms320dm6446</a>
</li>

<li>Digital Media Video Processors (TI)<br />
<a href="http://www.ti.com/lsds/ti/processors/dsp/media_processors/davinci/products.page#">http://www.ti.com/lsds/ti/processors/dsp/media_processors/davinci/products.page#</a>
</li>

<li>TI Wiki<br />
<a href="http://processors.wiki.ti.com/index.php/Main_Page">http://processors.wiki.ti.com/index.php/Main_Page</a>
</li>

<li>C5000 ultra-low-power DSP<br />
<a href="http://www.ti.com/lsds/ti/processors/dsp/c5000_dsp/overview.page">http://www.ti.com/lsds/ti/processors/dsp/c5000_dsp/overview.page</a>
</li>

<li>OMAP (Wikipedia)<br />
<a href="https://en.wikipedia.org/wiki/OMAP">https://en.wikipedia.org/wiki/OMAP</a>
</li>

<li>OMAP - TI Wiki<br />
<a href="http://processors.wiki.ti.com/index.php/OMAP">http://processors.wiki.ti.com/index.php/OMAP</a>
</li>

<li>Why OMAP can't compete in smartphones<br />
<a href="http://www.eetimes.com/author.asp?section_id=40&doc_id=1286602">http://www.eetimes.com/author.asp?section_id=40&doc_id=1286602</a>
</li>

<li>Applications Processors – The Heart of the Smartphone<br />
<a href="http://www.engineering.com/ElectronicsDesign/ElectronicsDesignArticles/ArticleID/5791/Applications-Processors-The-Heart-of-the-Smartphone.aspx">http://www.engineering.com/ElectronicsDesign/ElectronicsDesignArticles/ArticleID/5791/Applications-Processors-The-Heart-of-the-Smartphone.aspx</a>
</li>

<li>TI cuts 1,700 jobs in OMAP shift<br />
<a href="http://www.eetimes.com/document.asp?doc_id=1262782">http://www.eetimes.com/document.asp?doc_id=1262782</a>
</li>

<li>VLIW: Very Long Instruction Word: Texas Instruments TMS320C6x<br />
<a href="http://www.ecs.umass.edu/ece/koren/architecture/VLIW/2/ti1.html">http://www.ecs.umass.edu/ece/koren/architecture/VLIW/2/ti1.html</a>
</li>

<li>An Introduction To Very-Long Instruction Word (VLIW) Computer Architecture<br />
Philips Semiconductors
</li>

<li>VLIW Architectures for DSP: A Two-Part Lecture (PDF, slajdy)<br />
<a href="http://www.bdti.com/MyBDTI/pubs/vliw_icspat99.pdf">http://www.bdti.com/MyBDTI/pubs/vliw_icspat99.pdf</a>
</li>

<li>Very long instruction word (Wikipedia)<br />
<a href="https://en.wikipedia.org/wiki/Very_long_instruction_word">https://en.wikipedia.org/wiki/Very_long_instruction_word</a>
</li>

<li>A VLIW Approach to Architecture, Compilers and Tools<br />
<a href="http://www.vliw.org/book/">http://www.vliw.org/book/</a>
</li>

<li>VEX Toolchain (VEX = VLIW Example)<br />
<a href="http://www.hpl.hp.com/downloads/vex/">http://www.hpl.hp.com/downloads/vex/</a>
</li>

<li>Elbrus (computer)<br />
<a href="https://en.wikipedia.org/wiki/Elbrus_%28computer%29">https://en.wikipedia.org/wiki/Elbrus_%28computer%29</a>
</li>

<li>Super Harvard Architecture Single-Chip Computer<br />
<a href="https://en.wikipedia.org/wiki/Super_Harvard_Architecture_Single-Chip_Computer">https://en.wikipedia.org/wiki/Super_Harvard_Architecture_Single-Chip_Computer</a>
</li>

<li>Digital Signal Processors (stránky TI)<br />
<a href="http://www.ti.com/lsds/ti/processors/dsp/overview.page">http://www.ti.com/lsds/ti/processors/dsp/overview.page</a>
</li>

<li>C674x Low Power DSP (stránky TI)<br />
<a href="http://www.ti.com/lsds/ti/processors/dsp/c6000_dsp/c674x/overview.page">http://www.ti.com/lsds/ti/processors/dsp/c6000_dsp/c674x/overview.page</a>
</li>

<li>TMS320C30 (stránky TI)<br />
<a href="http://www.ti.com/product/tms320c30">http://www.ti.com/product/tms320c30</a>
</li>

<li>TMS320C6722B<br />
<a href="http://www.ti.com/product/tms320c6722b/description">http://www.ti.com/product/tms320c6722b/description</a>
</li>

<li>Introduction to DSP<br />
<a href="http://www.ti.com/lit/wp/spry281/spry281.pdf">http://www.ti.com/lit/wp/spry281/spry281.pdf</a>
</li>

<li>The Evolution of TMS (Family of DSPs)<br />
<a href="http://www.slideshare.net/moto_modx/theevo1">http://www.slideshare.net/moto_modx/theevo1</a>
</li>

<li>Datasheet k TMS32010<br />
<a href="http://www.datasheetarchive.com/dlmain/49326c32a52050140abffe6f0ac4894aa09889/M/TMS32010">http://www.datasheetarchive.com/dlmain/49326c32a52050140abffe6f0ac4894aa09889/M/TMS32010</a>
</li>

<li>1979: Single Chip Digital Signal Processor Introduced<br />
<a href="http://www.computerhistory.org/siliconengine/single-chip-digital-signal-processor-introduced/">http://www.computerhistory.org/siliconengine/single-chip-digital-signal-processor-introduced/</a>
</li>

<li>The TMS32010. The DSP chip that changed the destiny of a semiconductor giant<br />
<a href="http://www.tihaa.org/historian/TMS32010-12.pdf">http://www.tihaa.org/historian/TMS32010-12.pdf</a>
</li>

<li>Texas Instruments TMS320 (Wikipedia)<br />
<a href="https://en.wikipedia.org/wiki/Texas_Instruments_TMS320">https://en.wikipedia.org/wiki/Texas_Instruments_TMS320</a>
</li>

<li>Great Microprocessors of the Past and Present: Part IX: Signetics 8x300, Early cambrian DSP ancestor (1978):<br />
<a href="http://www.cpushack.com/CPU/cpu2.html#Sec2Part9">http://www.cpushack.com/CPU/cpu2.html#Sec2Part9</a>
</li>

<li>Great Microprocessors of the Past and Present (V 13.4.0)<br />
<a href="http://jbayko.sasktelwebsite.net/cpu.html">http://jbayko.sasktelwebsite.net/cpu.html</a>
</li>

<li>Introduction to DSP - DSP processors:<br />
<a href="http://www.bores.com/courses/intro/chips/index.htm">http://www.bores.com/courses/intro/chips/index.htm</a>
</li>

<li>The Scientist and Engineer's Guide to Digital Signal Processing:<br />
<a href="http://www.dspguide.com/">http://www.dspguide.com/</a>
</li>

<li>Digital signal processor (Wikipedia EN)<br />
<a href="http://en.wikipedia.org/wiki/Digital_signal_processor">http://en.wikipedia.org/wiki/Digital_signal_processor</a>
</li>

<li>Digitální signálový procesor (Wikipedia CZ)<br />
<a href="http://cs.wikipedia.org/wiki/Digitální_signálový_procesor">http://cs.wikipedia.org/wiki/Digitální_signálový_procesor</a>
</li>

<li>Digital Signal Processing FAQs<br />
<a href="http://dspguru.com/dsp/faqs">http://dspguru.com/dsp/faqs</a>
</li>

<li>Reprezentace numerických hodnot ve formátech FX a FP<br />
<a href="http://www.root.cz/clanky/fixed-point-arithmetic/">http://www.root.cz/clanky/fixed-point-arithmetic/</a>
</li>

<li>IEEE 754 a její příbuzenstvo: FP formáty<br />
<a href="http://www.root.cz/clanky/norma-ieee-754-a-pribuzni-formaty-plovouci-radove-tecky/">http://www.root.cz/clanky/norma-ieee-754-a-pribuzni-formaty-plovouci-radove-tecky/</a>
</li>

<li>Čtyři základní způsoby uložení čísel pomocí FX formátů<br />
<a href="http://www.root.cz/clanky/binarni-reprezentace-numerickych-hodnot-v-fx-formatu/">http://www.root.cz/clanky/binarni-reprezentace-numerickych-hodnot-v-fx-formatu/</a>
</li>

<li>Základní aritmetické operace prováděné v FX formátu<br />
<a href="http://www.root.cz/clanky/zakladni-aritmeticke-operace-provadene-ve-formatu-fx/">http://www.root.cz/clanky/zakladni-aritmeticke-operace-provadene-ve-formatu-fx/</a>
</li>

<li>Aritmetické operace s hodnotami uloženými ve formátu FP<br />
<a href="http://www.root.cz/clanky/aritmeticke-operace-s-hodnotami-ve-formatu-plovouci-radove-carky/">http://www.root.cz/clanky/aritmeticke-operace-s-hodnotami-ve-formatu-plovouci-radove-carky/</a>
</li>

<li>FIR Filter FAQ<br />
<a href="http://dspguru.com/dsp/faqs/fir">http://dspguru.com/dsp/faqs/fir</a>
</li>

<li>Finite impulse response (Wikipedia)<br />
<a href="http://en.wikipedia.org/wiki/Finite_impulse_response">http://en.wikipedia.org/wiki/Finite_impulse_response</a>
</li>

<li>DSPRelated<br />
<a href="http://www.dsprelated.com/">http://www.dsprelated.com/</a>
</li>

<li>Addressing mode (Wikipedia)<br />
<a href="https://en.wikipedia.org/wiki/Addressing_mode">https://en.wikipedia.org/wiki/Addressing_mode</a>
</li>

<li>Orthogonal instruction set<br />
<a href="https://en.wikipedia.org/wiki/Orthogonal_instruction_set">https://en.wikipedia.org/wiki/Orthogonal_instruction_set</a>
</li>

<li>TI 16-bit and 32-bit microcontrollers<br />
<a href="http://www.ti.com/lsds/ti/microcontrollers_16-bit_32-bit/overview.page">http://www.ti.com/lsds/ti/microcontrollers_16-bit_32-bit/overview.page</a>
</li>

<li>TMS 32010 Assembly Language Programmer's Guide (kniha na Amazonu)<br />
<a href="https://www.amazon.com/32010-Assembly-Language-Programmers-Guide/dp/0904047423">https://www.amazon.com/32010-Assembly-Language-Programmers-Guide/dp/0904047423</a>
</li>

<li>COSC2425: PC Architecture and Machine Language, PC Assembly Language<br />
<a href="http://www.austincc.edu/rblack/courses/COSC2425/index.html">http://www.austincc.edu/rblack/courses/COSC2425/index.html</a>
</li>

</ol>



<p></p><p></p>
<p><small>Autor: <a href="http://www.fit.vutbr.cz/~tisnovpa">Pavel Tišnovský</a> &nbsp; 2017</small></p>
</body>
</html>

