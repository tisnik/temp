<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
        "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html>
<head>
<title>Architektura mikroprocesorů OpenRISC (dokončení)</title>
<meta name="Author" content="Pavel Tisnovsky" />
<meta name="Generator" content="vim" />
<meta http-equiv="content-type" content="text/html; charset=utf-8" />
<style type="text/css">
         body {color:#000000; background:#ffffff;}
         h1  {font-family: arial, helvetica, sans-serif; color:#ffffff; background-color:#c00000; text-align:center; padding-left:1em}
         h2  {font-family: arial, helvetica, sans-serif; color:#ffffff; background-color:#0000c0; padding-left:1em; text-align:left}
         h3  {font-family: arial, helvetica, sans-serif; color:#000000; background-color:#c0c0c0; padding-left:1em; text-align:left}
         h4  {font-family: arial, helvetica, sans-serif; color:#000000; background-color:#e0e0e0; padding-left:1em; text-align:left}
         a   {font-family: arial, helvetica, sans-serif;}
         li  {font-family: arial, helvetica, sans-serif; color:#000000; text-align:justify; width:450px;}
         ol  {font-family: arial, helvetica, sans-serif; color:#000000; text-align:justify; width:450px;}
         ul  {font-family: arial, helvetica, sans-serif; color:#000000; text-align:justify; width:450px;}
         p   {font-family: arial, helvetica, sans-serif; color:#000000; text-align:justify;}
         pre {background:#e0e0e0}
</style>
</head>

<body>

<h1>Architektura mikroprocesorů OpenRISC (dokončení)</h1>

<h3>Pavel Tišnovský</h3>

<p></p>

<h1>Úvodník</h1>

<p>Ve druhém článku o RISCových jádrech s architekturou OpenRISC dokončíme popis instrukčních sad těchto čipů. Zaměříme se jak na instrukce určené pro práci s hodnotami s plovoucí řádovou čárkou, tak i na takzvané &bdquo;vektorové&ldquo; operace.</p>



<h2>Obsah</h2>

<p><a href="#k01">1. Problematika operací pro celočíselný součin a podíl</a></p>
<p><a href="#k02">2. Operace s&nbsp;hodnotami s&nbsp;plovoucí řádovou čárkou</a></p>
<p><a href="#k03">3. Význam prefixů a sufixů u instrukcí</a></p>
<p><a href="#k04">4. Instrukční sady ORFPX32 a ORFPX64</a></p>
<p><a href="#k05">5. Registr FPSCR</a></p>
<p><a href="#k06">6. Rychlost provedení základních FP operací</a></p>
<p><a href="#k07">7. Základní aritmetické operace: součet, součin, rozdíl, podíl, zbytek po dělení</a></p>
<p><a href="#k08">8. Operace typu multiply-accumulate</a></p>
<p><a href="#k09">9. Konverzní operace</a></p>
<p><a href="#k10">10. Instrukce určené pro porovnání dvou hodnot s&nbsp;nastavením příznaku <strong>F</strong></a></p>
<p><a href="#k11">11. Stručné porovnání OpenRISCu s&nbsp;architekturou RISC-V v&nbsp;oblasti FP operací</a></p>
<p><a href="#k12">12. FP operace specifikované v&nbsp;ISA v&nbsp;RISC-V</a></p>
<p><a href="#k13">13. Implementace instrukcí SIMD na mikroprocesorech RISC</a></p>
<p><a href="#k14">14. &bdquo;Vektorové&ldquo; operace podporované architekturou OpenRISC</a></p>
<p><a href="#k15">15. Saturace při provádění SIMD operací</a></p>
<p><a href="#k16">16. Podporované typy vektorů a jejich prvků</a></p>
<p><a href="#k17">17. Aritmetické operace</a></p>
<p><a href="#k18">18. Porovnání dvou vektorů</a></p>
<p><a href="#k19">19. Spojení a rozdělení prvků vektorů</a></p>
<p><a href="#k20">20. Odkazy na Internetu</a></p>



<p><a name="k01"></a></p>
<h2 id="k01">1. Problematika operací pro celočíselný součin a podíl</h2>

<p>V&nbsp;úvodní kapitole se budeme zabývat problematikou provádění operací
součinu a podílu na RISCových mikroprocesorech, samozřejmě včetně jader
OpenRISC, které nás dnes zajímají nejvíce. Připomeňme si, že tyto operace patří
&ndash; alespoň z&nbsp;pohledu programátora &ndash; do skupiny <a
href="https://www.root.cz/clanky/architektura-mikroprocesoru-openrisc/#k12">aritmetických
operací</a>. Jádra OpenRISC mohou &ndash; v&nbsp;závislosti na konkrétní
konfiguraci čipu &ndash; podporovat následující množinu operací pro násobení a
dělení:</p>

<table>
<tr><th>#</th><th>Instrukce</th><th>Význam</th></tr>
<tr><td>1</td><td>l.mul</td><td>násobení (se znaménkem)</td></tr>
<tr><td>2</td><td>l.mulu</td><td>násobení (bez znaménka)</td></tr>
<tr><td>3</td><td>l.muli</td><td>násobení konstantou (se znaménkem)</td></tr>
<tr><td>4</td><td>l.muld</td><td>násobení s&nbsp;přesunem výsledku do jednotky MAC</td></tr>
<tr><td>5</td><td>l.muldu</td><td>násobení s&nbsp;přesunem výsledku do jednotky MAC</td></tr>
<tr><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td></tr>
<tr><td>6</td><td>l.div</td><td>celočíselné dělení (se znaménkem)</td></tr>
<tr><td>7</td><td>l.divu</td><td>celočíselné dělení (bez znaménka)</td></tr>
</table>

<p>Kde tedy spočívá onen zmíněný problém? Všechny ostatní operace vykonávané
aritmeticko-logickou jednotkou jsou totiž provedeny v&nbsp;jediném strojovém
cyklu, což je ostatně chování, které u RISCových jader očekáváme (připomeňme si
jen, že provedení operace odpovídá fázi <i>EX</i> v&nbsp;pipeline). Ovšem
operace násobení je složitější a je tedy provedena ve třech cyklech a dělení
dokonce v&nbsp;cyklech třiceti dvou! Podívejme se na následující tabulku
s&nbsp;většinou operací OpenRISCu spadajících do ISA ORBIS32 (kromě skoků, kde
záleží na existenci branch delay slotu):</p>

<table>
<tr><th>Instrukce</th><th>Počet cyklů pro výpočet</th></tr>
<tr><td>základní aritmetické operace</td><td>1</td></tr>
<tr><td>celočíselné násobení</td><td>3</td></tr>
<tr><td>celočíselné dělení</td><td>32</td></tr>
<tr><td>porovnání, nastavení <strong>F</strong></td><td>1</td></tr>
<tr><td>logické operace</td><td>1</td></tr>
<tr><td>rotace a posuny</td><td>1</td></tr>
<tr><td>přenosy dat</td><td>1</td></tr>
</table>

<p>To, že výpočet některých operací trvá déle, než jeden strojový cyklus,
představuje poměrně velký problém, zvláště pro RISCové procesory. Při návrhu
různých RISCových architektur se inženýři s&nbsp;tímto problémem vypořádali
různými způsoby. Pěkným příkladem může být řešení použité u architektury
MIPS-I, v&nbsp;níž byla násobička a dělička zcela oddělena od
aritmeticko-logické jednotky a dokonce se v&nbsp;ní využívaly vlastní registry
nazvané <strong>HI</strong> a <strong>LO</strong>, které byly odděleny od sady
pracovních registrů.</p>

<p>Odlišným způsobem bylo násobení a dělení řešeno v&nbsp;instrukční sadě
procesorů <i>SPARC-V7</i>. V&nbsp;této ISA je možné najít instrukci nazvanou
<strong>MULScc</strong>, neboli <i>Multiply Step and Modify icc</i>, která
dokázala při svém zavolání provést <strong>jeden krok</strong> násobení dvojice
32bitových celých čísel s&nbsp;64bitovým mezivýsledkem (polovina mezivýsledku
se ukládala do pomocného speciálního registru <strong>Y</strong> ležícího mimo
sadu 32 viditelných pracovních registrů). Optimalizovaný programový kód pro
násobení dokázal s&nbsp;využitím instrukce <strong>MULScc</strong> vynásobit
dvě celá čísla bez znaménka za 47 strojových cyklů, popř.&nbsp;dvě celá čísla
se znaménkem za 51 strojových cyklů, což sice není zanedbatelná doba, ale
operace násobení i dělení trvaly poměrně dlouho i u dalších dobových
mikroprocesorů, které je měly implementovány přímo v&nbsp;mikrokódu (například
80x86).</p>

<p>Jednou z&nbsp;nejviditelnějších změn, s&nbsp;níž se setkali programátoři
mikroprocesorů s&nbsp;architekturou <i>SPARC-V8</i>, bylo právě přidání nových
instrukcí určených pro provedení aritmetické operace celočíselného násobení a
dělení. Ukazuje se zde částečný odklon od čistého RISCového procesoru, kde
čistota návrhu byla vyvážena praktičtějším používáním. Navíc se díky tomu, že
násobení a dělení probíhá v&nbsp;součinnosti s&nbsp;ALU, mohly instrukce pro
násobení a dělení nastavovat příznakové bity, podobně jako to dokážou ostatní
ALU operace:</p>

<table>
<tr><th>#</th><th>Instrukce</th><th>Význam</th></tr>
<tr><td>1</td><td>MULScc</td><td>provedení jednoho kroku násobení (převzato z V7)</td></tr>
<tr><td>2</td><td>UMUL</td><td>násobení dvojice celočíselných hodnot bez znaménka</td></tr>
<tr><td>3</td><td>SMUL</td><td>násobení dvojice celočíselných hodnot se znaménkem</td></tr>
<tr><td>4</td><td>UDIV</td><td>dělení dvojice celočíselných hodnot bez znaménka</td></tr>
<tr><td>5</td><td>SDIV</td><td>dělení dvojice celočíselných hodnot se znaménkem</td></tr>
<tr><td>6</td><td>UMULcc</td><td>odpovídá instrukci <strong>UMUL</strong>, ovšem nastaví i příznakové bity</td></tr>
<tr><td>7</td><td>SMULcc</td><td>odpovídá instrukci <strong>SMUL</strong>, ovšem nastaví i příznakové bity</td></tr>
<tr><td>8</td><td>UDIVcc</td><td>odpovídá instrukci <strong>UDIV</strong>, ovšem nastaví i příznakové bity</td></tr>
<tr><td>9</td><td>SDIVcc</td><td>odpovídá instrukci <strong>SDIV</strong>, ovšem nastaví i příznakové bity</td></tr>
</table>

<img src="https://i.iinfo.cz/images/75/arm-mul-1.png" class="image-344198" alt="&#160;" width="602" height="767" />
<p><i>Obrázek 1: I první dvě generace RISCových mikroprocesorů ARM měly
násobičku oddělenou od běžného ALU. Násobička navíc prováděla zvolenou operaci
delší dobu než tomu bylo v&nbsp;aritmeticko-logické jednotce u kratších a
jednodušších operací.</i></p>



<p><a name="k02"></a></p>
<h2 id="k02">2. Operace s&nbsp;hodnotami s&nbsp;plovoucí řádovou čárkou</h2>

<p>Připomeňme si, že čipy s&nbsp;jádry OpenRISC jsou široce konfigurovatelné a
jejich tvůrci dokonce mají možnost volby, které instrukční sady budou
podporovány. Seznam instrukčních sad jsme si již uvedli minule, takže jen ve
stručnosti:</p>

<table>
<tr><th>#</th><th>Zkratka</th><th>Celé jméno</th><th>Stručný popis</th></tr>
<tr><td>1</td><td>ORBIS32</td><td>OpenRISC Basic Instruction Set</td><td>zpracování 32bitových operandů, skoky, podmínky, bitové operace</td></tr>
<tr><td>2</td><td>ORBIS64</td><td>OpenRISC Basic Instruction Set</td><td>rozšíření na 64bitové operandy</td></tr>
<tr><td>3</td><td>ORFPX32</td><td>OpenRISC Floating Point eXtension</td><td>operace s&nbsp;numerickými hodnotami typu float/single (jednoduchá přesnost)</td></tr>
<tr><td>4</td><td>ORFPX64</td><td>OpenRISC Floating Point eXtension</td><td>operace s&nbsp;numerickými hodnotami typu double (dvojitá přesnost)</td></tr>
<tr><td>5</td><td>ORVDX64</td><td>OpenRISC Vector/DSP eXtension</td><td>zpracování hodnot uložených v&nbsp;64bitových vektorech</td></tr>
</table>

<p>Instrukční sadu <strong>ORBIS32</strong> jsme si již poměrně podrobně <a
href="https://www.root.cz/clanky/architektura-mikroprocesoru-openrisc/">popsali
minule</a>. Dnes nás budou zajímat především ISA <strong>ORFPX32</strong> a
<strong>ORFPX64</strong>, což jsou instrukční sady realizující operace
s&nbsp;hodnotami reprezentovanými ve <a
href="https://www.root.cz/clanky/interni-reprezentace-numerickych-hodnot-od-skutecneho-pocitacoveho-praveku-po-ieee-754-2008-dokonceni#k02">formátu
s&nbsp;plovoucí řádovou čárkou</a>. Tyto dvě instrukční sady si popíšeme
společně, protože většina instrukcí je totožných a liší se jen typem
operandů.</p>



<p><a name="k03"></a></p>
<h2 id="k03">3. Význam prefixů a sufixů u instrukcí</h2>

<p>V&nbsp;úvodním článku o architektuře OpenRISC byly popsány instrukce, které
začínaly prefixem &bdquo;l.&ldquo;. Tímto prefixem se označují instrukce
z&nbsp;ISA <strong>ORBIS32</strong> popř.&nbsp;<strong>ORBIS64</strong>.
Všechny operace s&nbsp;hodnotami s&nbsp;plovoucí řádovou čárkou používají
prefix &bdquo;lf.&ldquo; a &bdquo;vektorové&ldquo; operace pak prefix
&bdquo;lv.&ldquo;:</p>

<table>
<tr><th>Prefix</th><th>Význam</th></tr>
<tr><td>l.</td><td>celočíselné operace, řídicí instrukce, load &amp; store atd.</td></tr>
<tr><td>lf.</td><td>operace s&nbsp;FP hodnotami</td></tr>
<tr><td>lv.</td><td>&bdquo;vektorové&ldquo; (SIMD) operace</td></tr>
</table>

<p>U některých instrukcí se navíc používá i sufix, tj.&nbsp;znak zapsaný za
jméno instrukce a oddělený od mnemotechnického kódu tečkou. V&nbsp;současné
variantě specifikace OpenRISC se setkáme s&nbsp;těmito sufixy:</p>

<table>
<tr><th>Sufix</th><th>Význam</th><th>Použito</th></tr>
<tr><td>s</td><td>single (float)</td><th>ORFPX32</th></tr>
<tr><td>d</td><td>double</td><td>ORFPX64</td></tr>
<tr><td>b</td><td>byte (8 bitů)</td><td>ORVDX64</td></tr>
<tr><td>h</td><td>half word (16 bitů)</td><td>ORVDX64</td></tr>
</table>

<p>Podívejme se nyní na příklady. Bude se jednat o instrukci součtu, ovšem
pokaždé provedeného odlišným způsobem:</p>

<table>
<tr><th>Instrukce</th><th>Význam</th></tr>
<tr><td>l.add</td><td>součet dvou celočíselných operandů uložených v&nbsp;pracovních registrech</td></tr>
<tr><td>lf.add.s</td><td>součet dvou FP operandů typu <i>single</i> uložených v&nbsp;pracovních registrech</td></tr>
<tr><td>lf.add.d</td><td>součet dvou FP operandů typu <i>double</i> uložených v&nbsp;pracovních registrech</td></tr>
<tr><td>lv.add.b</td><td>součet osmi operandů typu byte uložených v&nbsp;64bitových pracovních registrech</td></tr>
<tr><td>lv.add.h</td><td>součet čtyř operandů typu half word uložených v&nbsp;64bitových pracovních registrech</td></tr>
</table>

<p><div class="rs-tip-major">Poznámka: tento způsob zápisu sice může na první
pohled vypadat zbytečně rozvláčný, ovšem je čitelnější, než snaha o používání
znaků připojovaných přímo k&nbsp;mnemotechnickému kódu instrukce, jako je tomu
například u x86-64 <a
href="https://en.wikibooks.org/wiki/X86_Assembly/GAS_Syntax#Operation_Suffixes">v&nbsp;případě
GNU Assembleru</a> atd.</div></p>



<p><a name="k04"></a></p>
<h2 id="k04">4. Instrukční sady ORFPX32 a ORFPX64</h2>

<p>Ve specifikaci OpenRISC jsou (prozatím) popsány dvě instrukční sady určené
pro práci s&nbsp;hodnotami s&nbsp;plovoucí řádovou čárkou. První sada se
jmenuje <strong>ORFPX32</strong> a slouží pro zpracování hodnot typu
<i>float/single</i> podle normy IEEE 754. Další sada se jmenuje
<strong>ORFPX64</strong>. Tato sada je určena pro 64bitové čipy (!) a umožňuje
zpracování hodnot typu <i>double</i>, opět podle IEEE 754. Ve skutečnosti
obsahuje poslední úprava normy IEEE 754 i další formáty, ovšem široce
podporované jsou právě <i>float/single</i> a <i>double</i>:</p>

<table>
<tr><th>Norma/systém</th><th>Šířka (b)</th><th>Báze</th><th>Exponent (b)</th><th>Mantisa (b)</th></tr>
<tr><td>IEEE 754 half</td><td>16</td><td>2</td><td>5</td><td>10+1</td></tr>
<tr><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td></tr>
<tr><td><strong>IEEE 754 single</strong></td><td>32</td><td>2</td><td>8</td><td>23+1</td></tr>
<tr><td><strong>IEEE 754 double</strong></td><td>64</td><td>2</td><td>11</td><td>52+1</td></tr>
<tr><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td></tr>
<tr><td>IEEE 754 double extended</td><td>80</td><td>2</td><td>15</td><td>64</td></tr>
<tr><td>IEEE 754 quadruple</td><td>128</td><td>2</td><td>15</td><td>112+1</td></tr>
<tr><td>IEEE 754 octuple</td><td>256</td><td>2</td><td>19</td><td>236+1</td></tr>
</table>

<p>Instrukční sada s&nbsp;instrukcemi pro FP operace je pojata přísně
minimalisticky. Nalezneme zde především instrukce určené pro provádění
základních aritmetických operací, dále instrukce pro konverzi dat a taktéž
instrukce pro porovnání dvou hodnot s&nbsp;nastavením příznaku
<strong>F</strong>. Instrukční sada je malá i z&nbsp;toho důvodu, že všechny
operace jsou prováděny s&nbsp;hodnotami, které již musí být uloženy
v&nbsp;běžných pracovních registrech (<i>general purpose registers</i>), což je
dosti zvláštní řešení. Všech třicet v&nbsp;současnosti podporovaných instrukcí
je vypsáno v&nbsp;další tabulce:</p>

<table>
<tr><th>Instrukce</th><th>Instrukce</th><th>Instrukce</th><th>Instrukce</th><th>Instrukce</th></tr>
<tr><td>lf.add.s</td><td>lf.div.s</td><td>lf.sfeq.s</td><td>lf.sfgt.s</td><td>lf.ftoi.d</td></tr>
<tr><td>lf.add.d</td><td>lf.div.d</td><td>lf.sfeq.d</td><td>lf.sfgt.d</td><td>lf.ftoi.s</td></tr>
<tr><td>lf.sub.s</td><td>lf.rem.s</td><td>lf.sfne.s</td><td>lf.sfle.s</td><td>lf.itof.d</td></tr>
<tr><td>lf.sub.d</td><td>lf.rem.d</td><td>lf.sfne.d</td><td>lf.sfle.d</td><td>lf.itof.s</td></tr>
<tr><td>lf.mul.s</td><td>lf.madd.s</td><td>lf.sfge.s</td><td>lf.sflt.s</td><td>lf.cust1.s</td></tr>
<tr><td>lf.mul.d</td><td>lf.madd.d</td><td>lf.sfge.d</td><td>lf.sflt.d</td><td>lf.cust1.d</td></tr>
</table>

<p><div class="rs-tip-major">Poznámka: instrukce <strong>lf.cust1.s</strong> a
<strong>lf.cust1.d</strong> jsou rezervovány pro použití v&nbsp;případech, že
návrhář vytvoří čip s&nbsp;dalšími nestandardními FP operacemi.</div></p>



<p><a name="k05"></a></p>
<h2 id="k05">5. Registr FPSCR</h2>

<p>Všechny FP operace sice probíhají nad běžnými pracovními registry a výsledky
porovnávacích operací nastavují příznak <strong>F</strong>, ovšem jádra
OpenRISC, které FP operace podporují, ještě obsahují další specializovaný
registr nazvaný <strong>FPSCR</strong> neboli <i>Floating Point Control Status
Register</i> (prakticky totožné jméno mají tyto registry i na dalších
architekturách s&nbsp;výjimkou x86-64 :-). V&nbsp;tomto registru jsou umístěny
bity řídicí způsob provádění FP operací a další bity (vlastně příznaky) jsou
nastavovány po všech FP operacích, takže je lze použít pro zjištění, proč
například nastala při výpočtech výjimka atd.:</p>

<table>
<tr><th>Bity</th><th>Označení</th><th>Význam</th></tr>
<tr><td>0</td><td>FPEE</td><td>povolení či zákaz výjimek při FP operacích</td></tr>
<tr><td>1-2</td><td>RM</td><td>zaokrouhlovací režim: k&nbsp;nejbližšímu číslu, k 0, k -&infin;, k +&infin;</td></tr>
<tr><td>3</td><td>OVF</td><td>příznak přetečení</td></tr>
<tr><td>4</td><td>UNF</td><td>příznak podtečení</td></tr>
<tr><td>5</td><td>SNF</td><td>příznak &bdquo;signalling&ldquo; NaN</td></tr>
<tr><td>6</td><td>QNF</td><td>příznak &bdquo;quiet&ldquo; NaN</td></tr>
<tr><td>7</td><td>ZF</td><td>operace skončila s&nbsp;nulovým výsledkem</td></tr>
<tr><td>8</td><td>IXF</td><td>nepřesný výsledek (bez normalizace)</td></tr>
<tr><td>9</td><td>IVF</td><td>neplatný výsledek</td></tr>
<tr><td>10</td><td>INF</td><td>výsledkem je nekonečno</td></tr>
<tr><td>11</td><td>DZF</td><td>došlo k&nbsp;dělení nulou</td></tr>
<tr><td>12-31</td><td>reserved</td><td>rezervováno pro další rozšíření</td></tr>
</table>

<p><div class="rs-tip-major">Poznámka: rezervované bity při čtení vrací hodnotu
0, což je specifikované chování všech rezervovaných bitů u všech registrů se
speciálními funkcemi. Do rezervovaných bitů nelze provést zápis.</div></p>



<p><a name="k06"></a></p>
<h2 id="k06">6. Rychlost základních FP operací</h2>

<p>Podívejme se nyní, jak rychlé (nebo pomalé) je vykonání základních operací
s&nbsp;operandy reprezentovanými v&nbsp;systému plovoucí řádové čárky. Počet
strojových cyklů, který si můžete přečíst v&nbsp;následující tabulce, je
převzat ze specifikace referenční architektury, takže je možné, že
v&nbsp;budoucnu může dojít k&nbsp;vylepšení, většinou ovšem za cenu
komplikovanějšího čipu:</p>

<table>
<tr><th>Instrukce</th><th>Počet cyklů pro výpočet</th></tr>
<tr><td>součet, rozdíl</td><td>10</td></tr>
<tr><td>součin</td><td>38</td></tr>
<tr><td>podíl</td><td>37</td></tr>
<tr><td>porovnání, nastavení příznaku <strong>F</strong></td><td>2</td></tr>
<tr><td>konverze hodnot</td><td>7</td></tr>
</table>

<p><div class="rs-tip-major">Poznámka: porovnání je rychlejší než rozdíl,
protože se u něho nepočítá s&nbsp;normalizací výsledku atd.</div></p>



<p><a name="k07"></a></p>
<h2 id="k07">7. Základní aritmetické operace: součet, součin, rozdíl, podíl, zbytek po dělení</h2>

<p>V&nbsp;této kapitole jsou popsány všechny základní aritmetické operace,
tj.&nbsp;součet, rozdíl, součin, podíl a zbytek po dělení (tj.&nbsp;všechny FP
operace, s&nbsp;nimiž se setkáme například v&nbsp;jazyku C):</p>

<table>
<tr><th>#</th><th>Instrukce</th><th>Datový typ</th><th>Význam</th></tr>
<tr><td>1</td><td>lf.add.s</td><td>single</td><td>součet dvou operandů</td></tr>
<tr><td>2</td><td>lf.add.d</td><td>double</td><td>součet dvou operandů</td></tr>
<tr><td>3</td><td>lf.sub.s</td><td>single</td><td>rozdíl dvou operandů</td></tr>
<tr><td>4</td><td>lf.sub.d</td><td>double</td><td>rozdíl dvou operandů</td></tr>
<tr><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td></tr>
<tr><td>5</td><td>lf.mul.s</td><td>single</td><td>součin dvou operandů</td></tr>
<tr><td>6</td><td>lf.mul.d</td><td>double</td><td>součin dvou operandů</td></tr>
<tr><td>7</td><td>lf.div.s</td><td>single</td><td>podíl dvou operandů</td></tr>
<tr><td>8</td><td>lf.div.d</td><td>double</td><td>podíl dvou operandů</td></tr>
<tr><td>9</td><td>lf.rem.s</td><td>single</td><td>zbytek po dělení dvou operandů</td></tr>
<tr><td>10</td><td>lf.rem.d</td><td>double</td><td>zbytek po dělení dvou operandů</td></tr>
</table>

<p><div class="rs-tip-major">Poznámka: tyto instrukce sice nenastavují příznak
<strong>F</strong>, ovšem ovlivňují obsah registru
<strong>FPSCR</strong>.</div></p>

<p>Všechny tyto operace používají standardní formát <strong>R</strong>, který
je nepatrně upraven, protože bity 8 až 10 jsou rezervovány pro další případná
rozšíření instrukční sady:</p>

<pre>
  +-----+------+--------+--------+--------+-------+------------------+
  |31 30|29  26| 25  21 | 20  16 | 15  11 | 10  8 | 7              0 |
  +-----+------+--------+--------+--------+-------+------------------+
  |třída|opcode| rD (5) | rA (5) | rB (5) |rezerva| druhá část opcode|
  +-----+------+--------+--------+--------+-------+------------------+
</pre>

<p><div class="rs-tip-major">Poznámka: jen pro připomenutí &ndash; tyto operace
využívají standardní sadu pracovních registrů, nikoli nějaké další registry
vyhrazené jen pro práci matematického koprocesoru (takové registry na platformě
OpenRISC neexistují).</div></p>



<p><a name="k08"></a></p>
<h2 id="k08">8. Operace typu multiply-accumulate</h2>

<p>K&nbsp;aritmetickým instrukcím můžeme přiřadit i instrukce typu
multiply-accumulate neboli MAC. Již minule jsme se setkali s&nbsp;několika
instrukcemi tohoto typu, ovšem to se jednalo o instrukce celočíselné. Zajímavé
a užitečné je, že i v&nbsp;instrukčních sadách ORFPX32 a ORFPX64 podobné
instrukce nalezneme, což je patrné z&nbsp;následující tabulky:</p>

<table>
<tr><th>#</th><th>Instrukce</th><th>Význam</th></tr>
<tr><td>1</td><td>lf.madd.s</td><td>single</td><td>součin dvou registrů obsahujících hodnoty typu single</td></tr>
<tr><td>2</td><td>lf.madd.d</td><td>double</td><td>součin dvou registrů obsahujících hodnoty typu double</td></tr>
</table>

<p>Tyto instrukce se od běžného součinu liší především v&nbsp;tom ohledu, že se
výsledek součin neuloží do třetího pracovního registru, ale <i>přičte se</i>
k&nbsp;obsahu speciálních registrů <strong>FPMADDLO</strong> a
<strong>FPMADDHI</strong> (patřících do skupiny 11).</p>



<p><a name="k09"></a></p>
<h2 id="k09">9. Konverzní operace</h2>

<p>První dvě instrukce, s&nbsp;nimiž se seznámíme v&nbsp;této kapitole, slouží
pro zaokrouhlení hodnoty typu <i>float</i> popř.&nbsp;<i>double</i> na celé
číslo (pokud je to samozřejmě možné). Další dvě instrukce jsou určeny pro
konverzi hodnot mezi celočíselným typem <i>int (long)</i> na typ <i>float</i>
popř.&nbsp;na typ <i>double</i>. V&nbsp;tomto případě dochází ke ztrátě
přesnosti, protože několik bitů u FP hodnot je vždy použito pro uložení
exponentu:</p>

<table>
<tr><th>#</th><th>Instrukce</th><th>Význam</th></tr>
<tr><td>1</td><td>lf.ftoi.d</td><td>převod hodnoty typu <i>double</i> na 64bitové celé číslo</td></tr>
<tr><td>2</td><td>lf.ftoi.s</td><td>převod hodnoty typu <i>single/float</i> na 32bitové celé číslo</td></tr>
<tr><td>3</td><td>lf.itof.d</td><td>převod 64bitového celého čísla na <i>double</i></td></tr>
<tr><td>4</td><td>lf.itof.s</td><td>převod 32bitového celého čísla na <i>single/float</i></td></tr>
</table>



<p><a name="k10"></a></p>
<h2 id="k10">10. Instrukce určené pro porovnání dvou hodnot s&nbsp;nastavením příznaku <strong>F</strong></h2>

<p>Další skupina instrukcí slouží pro porovnání dvou hodnot, ať již typu
<i>single/float</i> či <i>double</i>. Výsledkem porovnání je pravdivostní
hodnota reprezentovaná jediným bitem, který je uložen do příznaku
<strong>F</strong>, s&nbsp;nímž jsme se seznámili minule. Povšimněte si, že se
toto chování odlišuje od mnoha dalších architektur, a to včetně ARMů či RISCu-V
atd. U většiny architektur je k&nbsp;dispozici méně instrukcí pro porovnání,
ovšem tyto instrukce nastavují větší množství příznaků (například současně
příznak nulovosti a zápornosti). U OpenRISCu máme k&nbsp;dispozici všechny
základní relační operace, které ovšem nastavují příznak jediný (podobné chování
mají velmi elegantně navržená jádra <a
href="https://www.root.cz/clanky/mikroprocesory-a-mikroradice-s-jadrem-sh-2a-a-koprocesorem-sh2a-fpu#k12">SH-2A</a>).</p>

<table>
<tr><th> #</th><th>Instrukce</th><th>Datový typ</th><th>Význam</th></tr>
<tr><td> 1</td><td>lf.sfeq.s</td><td>single</td><td>porovnání dvou hodnot na rovnost</td></tr>
<tr><td> 2</td><td>lf.sfeq.d</td><td>double</td><td>porovnání dvou hodnot na rovnost</td></tr>
<tr><td> 3</td><td>lf.sfne.s</td><td>single</td><td>porovnání dvou hodnot na nerovnost</td></tr>
<tr><td> 4</td><td>lf.sfne.d</td><td>double</td><td>porovnání dvou hodnot na nerovnost</td></tr>
<tr><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td></tr>
<tr><td> 5</td><td>lf.sfge.s</td><td>single</td><td>porovnání dvou hodnot na relaci &bdquo;větší nebo rovno&ldquo;</td></tr>
<tr><td> 6</td><td>lf.sfge.d</td><td>double</td><td>porovnání dvou hodnot na relaci &bdquo;větší nebo rovno&ldquo;</td></tr>
<tr><td> 7</td><td>lf.sfgt.s</td><td>single</td><td>porovnání dvou hodnot na relaci &bdquo;větší než&ldquo;</td></tr>
<tr><td> 8</td><td>lf.sfgt.d</td><td>double</td><td>porovnání dvou hodnot na relaci &bdquo;větší než&ldquo;</td></tr>
<tr><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td></tr>
<tr><td> 9</td><td>lf.sfle.s</td><td>single</td><td>porovnání dvou hodnot na relaci &bdquo;menší nebo rovno&ldquo;</td></tr>
<tr><td>10</td><td>lf.sfle.d</td><td>double</td><td>porovnání dvou hodnot na relaci &bdquo;menší nebo rovno&ldquo;</td></tr>
<tr><td>11</td><td>lf.sflt.s</td><td>single</td><td>porovnání dvou hodnot na relaci &bdquo;menší než&ldquo;</td></tr>
<tr><td>12</td><td>lf.sflt.d</td><td>double</td><td>porovnání dvou hodnot na relaci &bdquo;menší než&ldquo;</td></tr>
</table>

<p>Tyto instrukce používají instrukční slova, v&nbsp;nichž je několik bitů
nevyužitých:</p>

<pre>
  +-----+------+---------+--------+--------+-------+------------------+
  |31 30|29  26| 25   21 | 20  16 | 15  11 | 10  8 | 7              0 |
  +-----+------+---------+--------+--------+-------+------------------+
  |třída|opcode|nevyužito| rA (5) | rB (5) |rezerva| druhá část opcode|
  +-----+------+---------+--------+--------+-------+------------------+
</pre>



<p><a name="k11"></a></p>
<h2 id="k11">11. Stručné porovnání OpenRISCu s&nbsp;architekturou RISC-V v&nbsp;oblasti FP operací</h2>

<p>Jen pro zajímavost se ve stručnosti podívejme, jakým způsobem jsou výpočty
s&nbsp;hodnotami v&nbsp;pohyblivé řádové čárce realizovány v&nbsp;konkurenčním
projektu <i>RISC-V</i>. I tato zajímavá (a úspěšnější) architektura totiž
umožňuje &ndash; pokud je to samozřejmě s&nbsp;ohledem na řešený problém nutné
&ndash; FPU do čipu přidat. Ve skutečnosti existují dokonce dvě rozšíření
původní ISA. První rozšíření se jmenuje jednoduše &bdquo;F&ldquo;, protože
specifikuje instrukce s&nbsp;hodnotami typu <i>single/float</i>,
tj.&nbsp;s&nbsp;čísly s&nbsp;jednoduchou přesností podle normy IEEE 754-2008
(jedná se o zpřesnění původní slavné normy IEEE 754). Instrukce, které
v&nbsp;tomto rozšíření ISA nalezneme, zhruba odpovídají výše popsané instrukční
sadě <i>ORFPX32</i>.</p>

<p>Druhé rozšíření se podle očekávání jmenuje &bdquo;D&ldquo;, protože
předepisuje operace s&nbsp;hodnotami typu <i>double</i>, tj.&nbsp;s&nbsp;čísly
s&nbsp;přesností dvojitou. To zhruba odpovídá instrukční sadě <i>ORFPX64</i>.
Proč však došlo k&nbsp;rozdělení funkcí matematického koprocesoru na dvě části?
Existují totiž aplikace, v&nbsp;nichž postačuje pracovat s&nbsp;typem
<i>single/float</i>, takže by v&nbsp;tomto případě podpora dvojnásobné
přesnosti pouze přinášela komplikace v&nbsp;realizaci mikroprocesoru (ostatně i
tak jsou obecně operace s&nbsp;plovoucí řádovou čárkou pomalejší, než
celočíselné operace RISCové aritmeticko-logické jednotky). Dokonce existují i
aplikace vyžadující malý a rychlý mikroprocesor s&nbsp;nativní podporou typu
<i>half-float</i>, což jsou 16bitová čísla se znaménkem, mantisou i exponentem
(zavedeny byly například v&nbsp;dnes již zapomenutém jazyce Cg).</p>

<p>Dalším rozšířením instrukčních sad je rozšíření označené písmenem
&bdquo;Q&ldquo;. To přidává možnost práce s&nbsp;numerickými hodnotami
s&nbsp;plovoucí řádovou čárkou se čtyřnásobnou přesností. Formát uložení těchto
hodnot je specifikován v&nbsp;již několikrát zmíněné normě <i>IEEE
754-2008</i>. Ostatně podívejme se na následující tabulku, v&nbsp;níž jsou
vypsány vybrané formáty numerických hodnot, které jsou v&nbsp;této normě
specifikovány (vynechávám takzvané &bdquo;decimální&ldquo; formáty) a jak se
tyto formáty mapují na rozšířené instrukční sady mikroprocesorů RISC-V:</p>

<table>
<tr><th>Oficiální jméno</th><th>Známo též jako</th><th>Znaménko</th><th>Exponent</th><th>Mantisa</th><th>Celkem</th><th>Decimálních číslic</th><th>RISV-5</th></tr>
<tr><td>binary16</td><td>half</td><td>1</td><td> 5b</td><td>10b</td><td>16b</td><td>cca 3,3</td><td>není</td></tr>
<tr><td>binary32</td><td>single/float</td><td>1</td><td> 8b</td><td>23b</td><td>32b</td><td>cca 7,2</td><td>&bdquo;F&ldquo;</td></tr>
<tr><td>binary64</td><td>double</td><td>1</td><td>11b</td><td>52b</td><td>64b</td><td>cca 15,9</td><td>&bdquo;D&ldquo;</td></tr>
<tr><td>binary128</td><td>quadruple</td><td>1</td><td>15b</td><td>112b</td><td>128b</td><td>cca 34,0</td><td>&bdquo;Q&ldquo;</td></tr>
</table>

<p>Pro rozšíření se jménem &bdquo;F&ldquo; se používá nová sada pracovních
registrů. Tyto registry jsou pojmenovány <strong>f0</strong> až
<strong>f31</strong> a každý z&nbsp;těchto registrů má šířku 32 bitů. Podobně
je tomu u rozšíření &bdquo;D&ldquo;, ovšem s&nbsp;tím rozdílem, že registry
budou mít šířku celých 64 bitů. Navíc se u většiny operací používá i stavový a
řídicí registr nazvaný <strong>fcrs</strong>.</p>

<p><div class="rs-tip-major">Poznámka: zde můžeme vidět poměrně zásadní rozdíl
mezi RISC-V a OpenRISCem. U OpenRISCu jsou čísla s&nbsp;plovoucí řádovou čárkou
uložena v&nbsp;běžných pracovních registrech, zatímco u RISC-V se používají
specializované registry. Obě řešení mají své výhody a nevýhody. U RISC-V se za
cenu větší plochy čipu a jeho větší komplikovanosti prakticky zcela oddělila
klasická ALU od FPU, takže výpočty mohou běžet nezávisle na sobě (záleží na
konkrétní implementaci). Také rozšíření o dalších 32 registrů může zjednodušit
práci překladače. U OpenRISCu se používají stejné registry pro celočíselné i FP
operace, takže se sice zjednodušila instrukční sada (načtení FP hodnoty je
shodné s&nbsp;načtením celočíselné hodnoty atd.), ovšem za cenu větších omezení
(typ <i>double</i> u 32bitového čipu atd.)</div></p>



<p><a name="k12"></a></p>
<h2 id="k12">12. FP operace specifikované v&nbsp;ISA v&nbsp;RISC-V</h2>

<p>Následuje tabulka se všemi instrukcemi, které nalezneme v&nbsp;instrukční
sadě &bdquo;F&ldquo; čipů s&nbsp;jádrem RISC-V:</p>

<table>
<tr><th> #</th><th>Instrukce</th><th>Význam</th></tr>
<tr><td> 1</td><td>FLW</td><td>načtení FP hodnoty z&nbsp;paměti (adresa rs+offset)</td></tr>
<tr><td> 2</td><td>FSW</td><td>uložení FP hodnoty do paměti (adresa rs+offset)</td></tr>
<tr><td> 3</td><td>FADD.S</td><td>součet dvou FP hodnot (tříadresový kód)</td></tr>
<tr><td> 4</td><td>FSUB.S</td><td>rozdíl dvou FP hodnot</td></tr>
<tr><td> 5</td><td>FMUL.S</td><td>součin dvou FP hodnot</td></tr>
<tr><td> 6</td><td>FDIV.S</td><td>podíl dvou FP hodnot</td></tr>
<tr><td> 7</td><td>FMIN.S</td><td>vrací menší z&nbsp;obou FP hodnot</td></tr>
<tr><td> 8</td><td>FMAX.S</td><td>vrací větší z&nbsp;obou FP hodnot</td></tr>
<tr><td> 9</td><td>FSQRT.S</td><td>druhá odmocnina (použity jsou jen dva registry)</td></tr>
<tr><td>10</td><td>FMADD.S</td><td>rs1&times;rs2+rs3 (multiply-add, čtyřadresový kód!)</td></tr>
<tr><td>11</td><td>FMSUB.S</td><td>rs1&times;rs2-rs3</td></tr>
<tr><td>12</td><td>FNMADD.S</td><td>-(rs1&times;rs2+rs3)</td></tr>
<tr><td>13</td><td>FNMSUB.S</td><td>-(rs1&times;rs2-rs3)</td></tr>
<tr><td>14</td><td>FCVT.W.S</td><td>převod FP na integer</td></tr>
<tr><td>15</td><td>FCVT.S.W</td><td>převod integer na FP</td></tr>
<tr><td>16</td><td>FCVT.WU.S</td><td>převod FP na unsigned integer</td></tr>
<tr><td>17</td><td>FCVT.S.WU</td><td>převod unsigned integer na FP</td></tr>
<tr><td>18</td><td>FMV.X.S</td><td>pouze přesun mezi integer registrem a FP registrem (nikoli konverze)</td></tr>
<tr><td>19</td><td>FMV.S.X</td><td>pouze přesun mezi FP registrem a integer registrem (nikoli konverze)</td></tr>
<tr><td>20</td><td>FLT.S</td><td>porovnání dvou FP hodnot, zápis 0 či 1 do integer registru</td></tr>
<tr><td>21</td><td>FLE.S</td><td>porovnání dvou FP hodnot, zápis 0 či 1 do integer registru</td></tr>
<tr><td>22</td><td>FEQ.S</td><td>porovnání dvou FP hodnot, zápis 0 či 1 do integer registru</td></tr>
<tr><td>21</td><td>FCLASS</td><td>zjistí &bdquo;třídu&ldquo; FP hodnoty a nastaví deset bitů podle následující tabulky</td></tr>
</table>

<p>Výsledek instrukce <strong>FCLASS</strong> zapsaný do vybraného integer
registru:</p>

<table>
<tr><th>Index bitu</th><th>Význam</th></tr>
<tr><td>0</td><td>záporné nekonečno</td></tr>
<tr><td>1</td><td>záporné číslo (normalizovaná hodnota)</td></tr>
<tr><td>2</td><td>záporné číslo (nelze normalizovat)</td></tr>
<tr><td>3</td><td>záporná nula</td></tr>
<tr><td>4</td><td>kladná nula</td></tr>
<tr><td>5</td><td>kladné číslo (nelze normalizovat)</td></tr>
<tr><td>6</td><td>kladné číslo (normalizovaná hodnota)</td></tr>
<tr><td>7</td><td>kladné nekonečno</td></tr>
<tr><td>8</td><td>NaN (signaling)</td></tr>
<tr><td>9</td><td>NaN (quiet, lze je předat do mnoha instrukcí)</td></tr>
</table>

<p>Základní aritmetické operace v&nbsp;rozšíření &bdquo;D&ldquo; jsou prakticky
stejné, pouze mají odlišný postfix:</p>

<table>
<tr><th>#</th><th>Instrukce</th><th>Význam</th></tr>
<tr><td>1</td><td>FADD.D</td><td>součet dvou FP hodnot (tříadresový kód)</td></tr>
<tr><td>2</td><td>FSUB.D</td><td>rozdíl dvou FP hodnot</td></tr>
<tr><td>3</td><td>FMUL.D</td><td>součin dvou FP hodnot</td></tr>
<tr><td>4</td><td>FDIV.D</td><td>podíl dvou FP hodnot</td></tr>
<tr><td>5</td><td>FMIN.D</td><td>vrací menší z&nbsp;obou FP hodnot</td></tr>
<tr><td>6</td><td>FMAX.D</td><td>vrací větší z&nbsp;obou FP hodnot</td></tr>
<tr><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td></tr>
<tr><td>7</td><td>FSQRT.D</td><td>druhá odmocnina (použity jsou jen dva registry)</td></tr>
</table>

<p>Dále jsou definovány konverzní operace mezi hodnotami s&nbsp;jednoduchou
přesností a přesností dvojitou:</p>

<table>
<tr><th>#</th><th>Instrukce</th><th>Význam</th></tr>
<tr><td>1</td><td>FCVT.S.D</td><td>double na single (provádí se zaokrouhlení)</td></tr>
<tr><td>2</td><td>FCVT.D.S</td><td>single na double (hodnota se nezmění)</td></tr>
</table>

<p>Zapomenout nesmíme ani na konverzi mezi hodnotami typu <i>integer</i> a
<i>double</i>, ovšem některé konverze lze provádět pouze na 64bitových
procesorech s&nbsp;instrukční sadou <i>RV64I</i> (už jen z&nbsp;toho důvodu, že
na 32bitových procesorech nejsou k&nbsp;dispozici dostatečně široké pracovní
registry):</p>

<table>
<tr><th>#</th><th>Instrukce</th><th>Význam</th></tr>
<tr><td>1</td><td>FCVT.W.D</td><td>double &rarr; 32bit signed integer</td></tr>
<tr><td>2</td><td>FCVT.L.D</td><td>double &rarr; 64bit signed integer</td></tr>
<tr><td>3</td><td>FCVT.WU.D</td><td>double &rarr; 32bit unsigned integer</td></tr>
<tr><td>4</td><td>FCVT.LU.D</td><td>double &rarr; 64bit unsigned integer</td></tr>
<tr><td>5</td><td>FCVT.D.W</td><td>32bit signed integer &rarr; double</td></tr>
<tr><td>6</td><td>FCVT.D.L</td><td>64bit signed integer &rarr; double</td></tr>
<tr><td>7</td><td>FCVT.D.WU</td><td>32bit unsigned integer &rarr; double</td></tr>
<tr><td>8</td><td>FCVT.D.LU</td><td>64bit unsigned integer &rarr; double</td></tr>
</table>

<p>I instrukce pro práci se znaménky mají svoji 64bitovou obdobu:</p>

<table>
<tr><th>#</th><th>Instrukce</th><th>Význam</th></tr>
<tr><td>1</td><td>FSGNJ.D </td><td>kopie z&nbsp;registru <i>src1</i> do <i>dest</i>, ovšem kromě znaménka; to je přečteno ze <i>src2</i></td></tr>
<tr><td>2</td><td>FSGNJN.D</td><td>kopie z&nbsp;registru <i>src1</i> do <i>dest</i>, ovšem kromě znaménka; to je přečteno ze <i>src2</i> a znegováno</td></tr>
<tr><td>3</td><td>FSGNJX.D</td><td>kopie z&nbsp;registru <i>src1</i> do <i>dest</i>, ovšem kromě znaménka; to je získáno ze <i>src1</i> i <i>src2</i> s&nbsp;využitím operace XOR</td></tr>
</table>

<p>Stejně jako přesuny bitové kopie mezi celočíselným registrem a FP registrem
(opět platí pouze pro 64bitovou instrukční sadu):</p>

<table>
<tr><th>#</th><th>Instrukce</th><th>Význam</th></tr>
<tr><td>1</td><td>FMV.X.D</td><td>pouze přesun mezi integer registrem a FP registrem (nikoli konverze)</td></tr>
<tr><td>1</td><td>FMV.D.X</td><td>pouze přesun mezi FP registrem a integer registrem (nikoli konverze)</td></tr>
</table>



<p><a name="k13"></a></p>
<h2 id="k13">13. Implementace instrukcí SIMD na mikroprocesorech RISC</h2>

<p>Prakticky u všech RISCových architektur došlo (dříve či později)
k&nbsp;rozšíření jejich ISA o SIMD operace, což si samozřejmě vyžádalo
modifikace ALU. Ve skutečnosti se dokonce tento typ instrukcí poprvé objevil
právě na mikroprocesorech <i>RISC</i> a teprve se zhruba dvouletým zpožděním
byl převzat i na původně čistě <i>CISCovou</i> architekturu <i>x86</i> (ostatně
se zdaleka nejedná o první ani o poslední technologii, která byla na <i>x86</i>
převzata právě z&nbsp;<i>RISCových</i> procesorů).</p>

<img src="http://i.iinfo.cz/images/625/37cray-a-1.jpg" width="350" height="467" alt=" " />
<p><i>Obrázek 2: Superpočítač Cray-1 byl jedním ze superpočítačů s&nbsp;velmi
dobrou podporou vektorových operací, ať se to týkalo instrukční sady, tak i
podpory v&nbsp;překladači Fortranu. Ve skutečnosti se však dnešní
&bdquo;vektorové&ldquo; instrukce odlišují od implementace provedené Seymourem
Crayem.</i></p>

<p>Důvodů, proč se vlastně instrukce typu <i>SIMD</i> na RISCových procesorech
vůbec objevily, je větší množství. Jedním z&nbsp;nich je to, že se tyto
procesory začaly používat v&nbsp;grafických pracovních stanicích, mj.&nbsp;i
pro zpracování videa, provádění rastrových operací i 3D operací (před masivním
příchodem grafických akcelerátorů a GPU), což je přesně ta oblast, v&nbsp;níž
je možné informace zpracovávat nikoli jen ve formě skalárních dat, ale i jako
vektory pevné délky. Dalším důvodem byla snaha výrobců RISCových procesorů o
průnik na trh s&nbsp;počítači určenými pro náročné výpočty (jedná se o určitý
mezistupeň mezi výkonnými pracovními stanicemi a superpočítači). V&nbsp;tomto
oboru se mnoho algoritmů provádí nad maticemi a vektory obsahujícími numerické
hodnoty reprezentované v&nbsp;systému plovoucí řádové čárky (FP: Floating
Point). Třetím důvodem je samozřejmě snaha o zvýšení výpočetního výkonu a právě
<i>SIMD</i> instrukce k&nbsp;němu mohou vést, aniž by bylo nutné radikálně
měnit používanou výrobní technologii čipů (zvyšovat úroveň integrace, snižovat
napěťové úrovně či zvyšovat frekvenci, popř.&nbsp;přidávat vyrovnávací
paměti/cache).</p>

<img src="http://i.iinfo.cz/images/308/comp-hist-61-1.jpg" width="450" height="345" alt=" " />
<p><i>Obrázek 3: Superpočítač CDC 7600 je předchůdcem superpočítačů Cray. Dnes
se samozřejmě jedná o historický stroj z&nbsp;počítačového pravěku.</i></p>

<p>Prakticky každá významnější společnost (v&nbsp;případě PowerPC pak dokonce
aliance) navrhující mikroprocesory s&nbsp;architekturou <i>RISC</i> přišla
dříve či později na trh s&nbsp;instrukční sadou obsahující
&bdquo;vektorové&ldquo; instrukce, které jsou dnes souhrnně označovány zkratkou
<i>SIMD</i> (původní vektorové instrukce používané na superpočítačích jsou
v&nbsp;některých ohledech flexibilnější, proto budeme používat spíše zkratku
<i>SIMD</i>). Rozšiřující instrukční sady byly pojmenovávány nejrůznějšími
názvy a zkratkami a nikdy vlastně nedošlo &ndash; na rozdíl od platformy
<i>x86</i> &ndash; ke sjednocení těchto instrukcí do jediné skupiny &bdquo;SIMD
pro RISC&ldquo;, což je vlastně logické, protože procesory <i>RISC</i> jsou
mnohdy určeny pro specializované oblasti použití, od vestavných (embedded)
systémů přes smartphony a tablety až po superpočítače.</p>

<img src="http://i.iinfo.cz/images/491/pc147-2.jpg" width="220" height="220" alt=" " />
<p><i>Obrázek 4: Mikroprocesor HP PA-RISC 7300LC (PA=Precision Architecture).
Jedná se moderní variantu procesorů RISC se zabudovaným matematickým
koprocesorem a sadou 32bitových celočíselných registrů a taktéž 64bitových
registrů pro FPU operace.<br />
Zdroj obrázku: Wikipedia</i></p>

<p>Nejvýznamnější implementace instrukcí <i>SIMD</i> na mikroprocesorech
s&nbsp;architekturou <i>RISC</i>, ať již se jedná o instrukce určené pro
operace s&nbsp;celými čísly či s&nbsp;čísly reálnými (přesněji řečeno
s&nbsp;plovoucí řádovou čárkou), jsou vypsány v&nbsp;následující tabulce:</p>

<table>
<tr><th>#</th><th>Zkratka/název</th><th>Plný název</th><th>Rodina procesorů</th></tr>
<tr><td>1</td><td>MAX-1</td><td>Multimedia Acceleration eXtensions v1</td><td>HP-PA RISC</td></tr>
<tr><td>2</td><td>MAX-2</td><td>Multimedia Acceleration eXtensions v2</td><td>HP-PA RISC</td></tr>
<tr><td>3</td><td>VIS 1</td><td>Visual Instruction v1</td><td>Set SPARC V9</td></tr>
<tr><td>4</td><td>VIS 2</td><td>Visual Instruction v2</td><td>Set SPARC V9</td></tr>
<tr><td>5</td><td>AltiVec</td><td>(obchodní názvy Velocity Engine, VMX)</td><td>PowerPC</td></tr>
<tr><td>6</td><td>MDMX</td><td>MIPS Digital Media eXtension (MaDMaX)</td><td>MIPS</td></tr>
<tr><td>7</td><td>MIPS-3D</td><td>MIPS-3D</td><td>MIPS</td></tr>
<tr><td>8</td><td>MVI</td><td>Motion Video Instructions</td><td>DEC Alpha</td></tr>
<tr><td>9</td><td>NEON</td><td>Advanced SIMD</td><td>Cortex (ARMv7)</td></tr>
<tr><td>10</td><td>ORVDX64</td><td>OpenRISC Vector/DSP eXtension</td><td>OpenRISC</td></tr>
</table>



<p><a name="k14"></a></p>
<h2 id="k14">14. &bdquo;Vektorové&ldquo; operace podporované architekturou OpenRISC</h2>



<p><a name="k15"></a></p>
<h2 id="k15">15. Saturace při provádění SIMD operací</h2>

<p>Zatímco při provádění aritmetických operací s&nbsp;využitím klasické
aritmeticko-logické jednotky může docházet k&nbsp;přetečení či podtečení hodnot
při provádění instrukcí typu <strong>ADD</strong> či <strong>SUB</strong>
(součet, rozdíl), je chování instrukcí <i>ORVDX64</i> odlišné, protože operace
podporují takzvanou <i>saturaci</i>, což znamená, že v&nbsp;případě přetečení
se do výsledku uloží maximální reprezentovatelná hodnota a naopak při podtečení
minimální hodnota, což je například při zpracování signálu (většinou) žádoucí
chování. Ostatně podívejme se na následující obrázky, kde je význam saturace
popsán:</p>

<img src="http://i.iinfo.cz/images/51/pc140-11.png" width="256" height="256" alt=" " />
<p><i>Obrázek 5: Zdrojový rastrový obrázek (známá fotografie Lenny), který
tvoří zdroj pro jednoduchý konvoluční (FIR) filtr, jenž zvyšuje hodnoty pixelů
o pevně zadanou konstantu (offset).</i></p>

<img src="http://i.iinfo.cz/images/51/pc140-12.png" width="256" height="256" alt=" " />
<p><i>Obrázek 6: Pokud je pro přičtení offsetu použita operace součtu se
zanedbáním přenosu (carry), tj.&nbsp;když se počítá systémem &bdquo;modulo
N&ldquo;, dochází při překročení maximální hodnoty pixelu (čistě bílá barva)
k&nbsp;jasně viditelným chybám.</i></p>

<img src="http://i.iinfo.cz/images/51/pc140-13.png" width="256" height="256" alt=" " />
<p><i>Obrázek 7: Při použití operace součtu se saturací sice taktéž dojde ke
ztrátě informace (vzniknou oblasti s&nbsp;pixely majícími hodnotu 255), ovšem
viditelná chyba je mnohem menší, než na předchozím obrázku.</i></p>

<p><div class="rs-tip-major">Poznámka: podobně rušivé je přetečení i u operací
s&nbsp;audio signálem. Tam je saturace stejně důležitá, jako při zpracování
videa.</div></p>



<p><a name="k16"></a></p>
<h2 id="k16">16. Podporované typy vektorů a jejich prvků</h2>

<p>Většina nových instrukcí přidaných v&nbsp;rámci instrukční sady
<i>ORVDX64</i> je určena pro provádění aritmetických a bitových operací
s&nbsp;celočíselnými operandy o šířce 8 a 16 bitů, což pokrývá poměrně širokou
oblast multimediálních dat &ndash; osmibitových i šestnáctibitových zvukových
vzorků (samplů), barev pixelů (RGB, RGBA) atd. V&nbsp;následující tabulce jsou
vypsány nově podporované datové typy i způsob jejich uložení ve slovech o šířce
64 bitů, které jsou zpracovávány:</p>

<table>
<tr><th>Datový typ</th><th>Suffix instrukce</th><th>Bitová šířka operandu</th><th>Počet prvků vektoru</th></tr>
<tr><td>byte</td><td>.b</td><td>8 bitů</td><td>8</td></tr>
<tr><td>half word</td><td>.h</td><td>16 bitů</td><td>4</td></tr>
</table>

<p><div class="rs-tip-major">Poznámka: kupodivu není podporována práce
s&nbsp;dvojicí 32bitových operandů uložených do jediného 64bitového
registru.</div></p>



<p><a name="k16"></a></p>
<h2 id="k16">16. </h2>

<table>
<tr><th> #</th><th>Instrukce</th><th>Datový typ</th><th>Význam</th></tr>
<tr><td> 1</td><td>lv.add.b</td><td>signed byte</td><td>součet dvou osmiprvkových vektorů s&nbsp;přetečením</td></tr>
<tr><td> 2</td><td>lv.add.h</td><td>signed half</td><td>součet dvou čtyřprvkových vektorů s&nbsp;přetečením</td></tr>
<tr><td> 3</td><td>lv.adds.b</td><td>signed byte</td><td>součet dvou osmiprvkových vektorů se saturací</td></tr>
<tr><td> 4</td><td>lv.adds.h</td><td>signed half</td><td>součet dvou čtyřprvkových vektorů se saturací</td></tr>
<tr><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td></tr>
<tr><td> 5</td><td>lv.addu.b</td><td>unsigned byte</td><td>součet dvou osmiprvkových vektorů s&nbsp;přetečením</td></tr>
<tr><td> 6</td><td>lv.addu.h</td><td>unsigned half</td><td>součet dvou čtyřprvkových vektorů s&nbsp;přetečením</td></tr>
<tr><td> 7</td><td>lv.addus.b</td><td>unsigned byte</td><td>součet dvou osmiprvkových vektorů se saturací</td></tr>
<tr><td> 8</td><td>lv.addus.h</td><td>unsigned half word</td><td>součet dvou čtyřprvkových vektorů se saturací</td></tr>
<tr><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td></tr>
<tr><td> 9</td><td>lv.sub.b</td><td>signed byte</td><td>rozdíl dvou osmiprvkových vektorů s&nbsp;přetečením</td></tr>
<tr><td>10</td><td>lv.sub.h</td><td>signed half word</td><td>rozdíl dvou čtyřprvkových vektorů s&nbsp;přetečením</td></tr>
<tr><td>11</td><td>lv.subs.b</td><td>signed byte</td><td>rozdíl dvou osmiprvkových vektorů se saturací</td></tr>
<tr><td>12</td><td>lv.subs.h</td><td>signed half word</td><td>rozdíl dvou čtyřprvkových vektorů se saturací</td></tr>
<tr><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td></tr>
<tr><td>13</td><td>lv.subu.b</td><td>unsigned byte</td><td>rozdíl dvou osmiprvkových vektorů s&nbsp;přetečením</td></tr>
<tr><td>14</td><td>lv.subu.h</td><td>unsigned half word</td><td>rozdíl dvou čtyřprvkových vektorů s&nbsp;přetečením</td></tr>
<tr><td>15</td><td>lv.subus.b</td><td>unsigned byte</td><td>rozdíl dvou osmiprvkových vektorů se saturací</td></tr>
<tr><td>16</td><td>lv.subus.h</td><td>unsigned half word</td><td>rozdíl dvou čtyřprvkových vektorů se saturací</td></tr>
<tr><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td></tr>
<tr><td>17</td><td>lv.avg.b</td><td>unsigned byte</td><td>průměr korespondujících prvků</td></tr>
<tr><td>18</td><td>lv.avg.h</td><td>unsigned half word</td><td>průměr korespondujících prvků</td></tr>
<tr><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td></tr>
<tr><td>19</td><td>lv.madds.h</td><td>signed half word</td><td>operace multiply-accumulate</td></tr>
<tr><td>20</td><td>lv.subss.h</td><td>signed half word</td><td>operace multiply-accumulate</td></tr>
<tr><td>21</td><td>lv.muls.h</td><td>signed half word</td><td>násobení se saturací</td></tr>
<tr><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td></tr>
<tr><td>22</td><td>lv.max.b</td><td>byte</td><td>zjištění, který korespondující prvek vektorů je větší</td></tr>
<tr><td>23</td><td>lv.max.h</td><td>half word</td><td>zjištění, který korespondující prvek vektorů je větší</td></tr>
<tr><td>24</td><td>lv.min.b</td><td>byte</td><td>zjištění, který korespondující prvek vektorů je menší</td></tr>
<tr><td>25</td><td>lv.min.h</td><td>half word</td><td>zjištění, který korespondující prvek vektorů je menší</td></tr>
</table>




<p><a name="k18"></a></p>
<h2 id="k18">18. Porovnání dvou vektorů</h2>

<p>Následují instrukce, které porovnávají příslušné prvky dvou osmiprvkových
vektorů typu byte či vektorů čtyřprvkových typu half word. Pokud jsou všechny
podmínky (4 nebo 8) splněny, je nastaven příznak <strong>F</strong> a současně
se nastaví třetí (cílový) registr na samé jedničky. Pokud naopak podmínka není
splněna pro všechny porovnávané dvojice, je příznak <strong>F</strong>
vynulován a cílový registr je vynulován taktéž:</p>

<table>
<tr><th> #</th><th>Instrukce</th><th>Datový typ</th><th>Význam</th></tr>
<tr><td> 1</td><td>lv.all_eq.b</td><td>byte</td><td>porovnání dvou osmiprvkových vektorů na rovnost</td></tr>
<tr><td> 2</td><td>lv.all_eq.h</td><td>half word</td><td>porovnání dvou čtyřprvkových vektorů na rovnost</td></tr>
<tr><td> 3</td><td>lv.all_ne.b</td><td>byte</td><td>porovnání dvou osmiprvkových vektorů na nerovnost</td></tr>
<tr><td> 4</td><td>lv.all_ne.h</td><td>half word</td><td>porovnání dvou čtyřprvkových vektorů na nerovnost</td></tr>
<tr><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td></tr>
<tr><td> 5</td><td>lv.all_ge.b</td><td>byte</td><td>zjištění relace &bdquo;větší nebo rovno&ldquo;</td></tr>
<tr><td> 6</td><td>lv.all_ge.h</td><td>half word</td><td>zjištění relace &bdquo;větší nebo rovno&ldquo;</td></tr>
<tr><td> 7</td><td>lv.all_gt.b</td><td>byte</td><td>zjištění relace &bdquo;větší než&ldquo;</td></tr>
<tr><td> 8</td><td>lv.all_gt.h</td><td>half word</td><td>zjištění relace &bdquo;větší než&ldquo;</td></tr>
<tr><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td></tr>
<tr><td> 9</td><td>lv.all_le.b</td><td>byte</td><td>zjištění relace &bdquo;menší nebo rovno&ldquo;</td></tr>
<tr><td>10</td><td>lv.all_le.h</td><td>half word</td><td>zjištění relace &bdquo;menší nebo rovno&ldquo;</td></tr>
<tr><td>11</td><td>lv.all_lt.b</td><td>byte</td><td>zjištění relace &bdquo;menší než&ldquo;</td></tr>
<tr><td>12</td><td>lv.all_lt.h</td><td>half word</td><td>zjištění relace &bdquo;menší než&ldquo;</td></tr>
</table>

<p>Další instrukce jsou taktéž určeny pro porovnání, ovšem zjišťují, zda
podmínka není splněna alespoň pro jednu porovnávanou dvojici prvků (provádí
tedy <i>or</i> mezi prvky):</p>

<table>
<tr><th> #</th><th>Instrukce</th><th>Datový typ</th><th>Význam</th></tr>
<tr><td> 1</td><td>lv.any_eq.b</td><td>byte</td><td>porovnání dvou osmiprvkových vektorů na rovnost</td></tr>
<tr><td> 2</td><td>lv.any_eq.h</td><td>half word</td><td>porovnání dvou čtyřprvkových vektorů na rovnost</td></tr>
<tr><td> 3</td><td>lv.any_ne.b</td><td>byte</td><td>porovnání dvou osmiprvkových vektorů na nerovnost</td></tr>
<tr><td> 4</td><td>lv.any_ne.h</td><td>half word</td><td>porovnání dvou čtyřprvkových vektorů na nerovnost</td></tr>
<tr><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td></tr>
<tr><td> 5</td><td>lv.any_ge.b</td><td>byte</td><td>zjištění relace &bdquo;větší nebo rovno&ldquo;</td></tr>
<tr><td> 6</td><td>lv.any_ge.h</td><td>half word</td><td>zjištění relace &bdquo;větší nebo rovno&ldquo;</td></tr>
<tr><td> 7</td><td>lv.any_gt.b</td><td>byte</td><td>zjištění relace &bdquo;větší než&ldquo;</td></tr>
<tr><td> 8</td><td>lv.any_gt.h</td><td>half word</td><td>zjištění relace &bdquo;větší než&ldquo;</td></tr>
<tr><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td></tr>
<tr><td> 9</td><td>lv.any_le.b</td><td>byte</td><td>zjištění relace &bdquo;menší nebo rovno&ldquo;</td></tr>
<tr><td>10</td><td>lv.any_le.h</td><td>half word</td><td>zjištění relace &bdquo;menší nebo rovno&ldquo;</td></tr>
<tr><td>11</td><td>lv.any_lt.b</td><td>byte</td><td>zjištění relace &bdquo;menší než&ldquo;</td></tr>
<tr><td>12</td><td>lv.any_lt.h</td><td>half word</td><td>zjištění relace &bdquo;menší než&ldquo;</td></tr>
</table>

<p>Třetí sada instrukcí opět slouží pro porovnání dvou vektorů, ovšem u těchto
instrukcí je výsledek porovnání uložen do registru cílového (vždy do všech osmi
či čtyř bitů). Skupina jedniček znamená splněnou podmínku, skupina nul podmínku
nesplněnou:</p>

<table>
<tr><th> #</th><th>Instrukce</th><th>Datový typ</th><th>Význam</th></tr>
<tr><td> 1</td><td>lv.cmp_eq.b</td><td>byte</td><td>porovnání dvou osmiprvkových vektorů na rovnost</td></tr>
<tr><td> 2</td><td>lv.cmp_eq.h</td><td>half word</td><td>porovnání dvou čtyřprvkových vektorů na rovnost</td></tr>
<tr><td> 3</td><td>lv.cmp_ne.b</td><td>byte</td><td>porovnání dvou osmiprvkových vektorů na nerovnost</td></tr>
<tr><td> 4</td><td>lv.cmp_ne.h</td><td>half word</td><td>porovnání dvou čtyřprvkových vektorů na nerovnost</td></tr>
<tr><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td></tr>
<tr><td> 5</td><td>lv.cmp_ge.b</td><td>byte</td><td>zjištění relace &bdquo;větší nebo rovno&ldquo;</td></tr>
<tr><td> 6</td><td>lv.cmp_ge.h</td><td>half word</td><td>zjištění relace &bdquo;větší nebo rovno&ldquo;</td></tr>
<tr><td> 7</td><td>lv.cmp_gt.b</td><td>byte</td><td>zjištění relace &bdquo;větší než&ldquo;</td></tr>
<tr><td> 8</td><td>lv.cmp_gt.h</td><td>half word</td><td>zjištění relace &bdquo;větší než&ldquo;</td></tr>
<tr><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td></tr>
<tr><td> 9</td><td>lv.cmp_le.b</td><td>byte</td><td>zjištění relace &bdquo;menší nebo rovno&ldquo;</td></tr>
<tr><td>10</td><td>lv.cmp_le.h</td><td>half word</td><td>zjištění relace &bdquo;menší nebo rovno&ldquo;</td></tr>
<tr><td>11</td><td>lv.cmp_lt.b</td><td>byte</td><td>zjištění relace &bdquo;menší než&ldquo;</td></tr>
<tr><td>12</td><td>lv.cmp_lt.h</td><td>half word</td><td>zjištění relace &bdquo;menší než&ldquo;</td></tr>
</table>



<p><a name="k19"></a></p>
<h2 id="k19">19. Spojení a rozdělení prvků vektorů</h2>

<p>Zbylé instrukce jsou určeny pro spojení popř.&nbsp;pro rozdělení prvků
vektorů. Tyto operace jsou velmi užitečné, protože nám například umožňují
rozložit rastrový obrázek ve formátu RGB na jednotlivé barvové složky
apod.:</p>

<table>
<tr><th>#</th><th>Instrukce</th><th>Význam</th></tr>
<tr><td>1</td><td>lv.merge.b</td><td>spojení dvou vektorů (promíchání systémem sudá-lichá), pracuje s&nbsp;polovinou prvků</td></tr>
<tr><td>2</td><td>lv.merge.h</td><td>spojení dvou vektorů (promíchání systémem sudá-lichá), pracuje s&nbsp;polovinou prvků</td></tr>
<tr><td>3</td><td>lv.pack.b</td><td>spojení spodních polovin dvou vektorů (4 prvky vektoru prvního + 4 prvky vektoru druhého)</td></tr>
<tr><td>4</td><td>lv.pack.h</td><td>spojení spodních polovin dvou vektorů (2 prvky vektoru prvního + 2 prvky vektoru druhého)</td></tr>
<tr><td>5</td><td>lv.packs.b</td><td>spodní polovina bitů (4 bity) dvou vektorů se převedou na výsledný vektor</td></tr>
<tr><td>6</td><td>lv.packs.h</td><td>spodní polovina bitů (8 bitů) dvou vektorů se převedou na výsledný vektor</td></tr>
<tr><td>7</td><td>lv.packus.b</td><td>spodní polovina bitů (4 bity) dvou vektorů se převedou na výsledný vektor</td></tr>
<tr><td>8</td><td>lv.packus.h</td><td>spodní polovina bitů (8 bitů) dvou vektorů se převedou na výsledný vektor</td></tr>
<tr><td>9</td><td>lv.unpack.b</td><td>opak operace packs</td></tr>
<tr><td>10</td><td>lv.unpack.h</td><td>opak operace packs</td></tr>
</table>



<p><a name="k20"></a></p>
<h2 id="k20">20. Odkazy na Internetu</h2>

<ol>

<li>OpenRISC (oficiální stránky)<br />
<a href="http://openrisc.io/">http://openrisc.io/</a>
</li>

<li>OpenRISC architecture<br />
<a href="http://openrisc.io/architecture.html">http://openrisc.io/architecture.html</a>
</li>

<li>Emulátor OpenRISC CPU v JavaScriptu<br />
<a href="http://s-macke.github.io/jor1k/demos/main.html">http://s-macke.github.io/jor1k/demos/main.html</a>
</li>

<li>Why Not Build on OpenRISC?<br />
<a href="https://riscv.org/2014/10/why-not-build-on-openrisc/">https://riscv.org/2014/10/why-not-build-on-openrisc/</a>
</li>

<li>OpenRISC (Wikipedia)<br />
<a href="https://en.wikipedia.org/wiki/OpenRISC">https://en.wikipedia.org/wiki/OpenRISC</a>
</li>

<li>OpenRISC - instrukce<br />
<a href="http://sourceware.org/cgen/gen-doc/openrisc-insn.html">http://sourceware.org/cgen/gen-doc/openrisc-insn.html</a>
</li>

<li>OpenRISC - slajdy z přednášky<br />
<a href="https://iis.ee.ethz.ch/~gmichi/asocd/lecturenotes/Lecture6.pdf">https://iis.ee.ethz.ch/~gmichi/asocd/lecturenotes/Lecture6.pdf</a>
</li>

<li>OpenRISC System-on-Chip Design Emulation<br />
<a href="https://arxiv.org/pdf/1602.03095.pdf">https://arxiv.org/pdf/1602.03095.pdf</a>
</li>

<li>Cortex-M4 Devices Generic User Guide: Multiply and divide instructions<br />
<a href="http://infocenter.arm.com/help/index.jsp?topic=/com.arm.doc.dui0553a/BABFADHJ.html">http://infocenter.arm.com/help/index.jsp?topic=/com.arm.doc.dui0553a/BABFADHJ.html</a>
</li>

<li>Open cores<br />
<a href="https://opencores.org/">https://opencores.org/</a>
</li>

<li>Projekt OpenRISC 2000<br />
<a href="https://opencores.org/project/or2k">https://opencores.org/project/or2k</a>
</li>

<li>OpenRISC na GitHubu<br />
<a href="https://github.com/openrisc">https://github.com/openrisc</a>
</li>

<li>OpenRISC 1200<br />
<a href="https://en.wikipedia.org/wiki/OpenRISC_1200">https://en.wikipedia.org/wiki/OpenRISC_1200</a>
</li>

<li>OpenRISC 1200 IP Core Specification (Preliminary Draft)<br />
<a href="https://opencores.org/ocsvn/openrisc/openrisc/trunk/or1200/doc/openrisc1200_spec.pdf">https://opencores.org/ocsvn/openrisc/openrisc/trunk/or1200/doc/openrisc1200_spec.pdf</a>
</li>

<li>mor1kx - an OpenRISC processor IP core<br />
<a href="https://www.librecores.org/openrisc/mor1kx">https://www.librecores.org/openrisc/mor1kx</a>
</li>

<li>Multiply Without a Multiply Instruction<br />
<a href="http://www.robelle.com/smugbook/multiply.html">http://www.robelle.com/smugbook/multiply.html</a>
</li>

<li>MULT in a RISC - should instructions take the same amount of time in a RISC system<br />
<a href="https://cs.stackexchange.com/questions/77010/mult-in-a-risc-should-instructions-take-the-same-amount-of-time-in-a-risc-syst">https://cs.stackexchange.com/questions/77010/mult-in-a-risc-should-instructions-take-the-same-amount-of-time-in-a-risc-syst</a>
</li>

<li>Would removing the branch delay slots change the instructions set architecture?<br />
<a href="https://cs.stackexchange.com/questions/59565/would-removing-the-branch-delay-slots-change-the-instructions-set-architecture?rq=1">https://cs.stackexchange.com/questions/59565/would-removing-the-branch-delay-slots-change-the-instructions-set-architecture?rq=1</a>
</li>

<li>CRU: RISC-V, OpenRISC, LoRaWAN, and More<br />
<a href="https://abopen.com/news/cru-risc-v-openrisc-lorawan/">https://abopen.com/news/cru-risc-v-openrisc-lorawan/</a>
</li>

<li>Comparing four 32-bit soft processor cores<br />
<a href="http://www.eetimes.com/author.asp?section_id=14&doc_id=1286116">http://www.eetimes.com/author.asp?section_id=14&doc_id=1286116</a>
</li>

<li>RISC-V Instruction Set<br />
<a href="http://riscv.org/download.html#spec_compressed_isa">http://riscv.org/download.html#spec_compressed_isa</a>
</li>

<li>RISC-V Spike (ISA Simulator)<br />
<a href="http://riscv.org/download.html#isa-sim">http://riscv.org/download.html#isa-sim</a>
</li>

<li>RISC-V (Wikipedia)<br />
<a href="https://en.wikipedia.org/wiki/RISC-V">https://en.wikipedia.org/wiki/RISC-V</a>
</li>

<li>David Patterson (Wikipedia)<br />
<a href="https://en.wikipedia.org/wiki/David_Patterson_(computer_scientist)">https://en.wikipedia.org/wiki/David_Patterson_(computer_scientist)</a>
</li>

<li>Maska mikroprocesoru RISC 1<br />
<a href="http://www.cs.berkeley.edu/~pattrsn/Arch/RISC1.jpg">http://www.cs.berkeley.edu/~pattrsn/Arch/RISC1.jpg</a>
</li>

<li>Maska mikroprocesoru RISC 2<br />
<a href="http://www.cs.berkeley.edu/~pattrsn/Arch/RISC2.jpg">http://www.cs.berkeley.edu/~pattrsn/Arch/RISC2.jpg</a>
</li>

<li>C.E. Sequin and D.A.Patterson: Design and Implementation of RISC I<br />
<a href="http://www.eecs.berkeley.edu/Pubs/TechRpts/1982/CSD-82-106.pdf">http://www.eecs.berkeley.edu/Pubs/TechRpts/1982/CSD-82-106.pdf</a>
</li>

<li>Berkeley RISC<br />
<a href="http://en.wikipedia.org/wiki/Berkeley_RISC">http://en.wikipedia.org/wiki/Berkeley_RISC</a>
</li>

<li>Great moments in microprocessor history<br />
<a href="http://www.ibm.com/developerworks/library/pa-microhist.html">http://www.ibm.com/developerworks/library/pa-microhist.html</a>
</li>

<li>Microprogram-Based Processors<br />
<a href="http://research.microsoft.com/en-us/um/people/gbell/Computer_Structures_Principles_and_Examples/csp0167.htm">http://research.microsoft.com/en-us/um/people/gbell/Computer_Structures_Principles_and_Examples/csp0167.htm</a>
</li>

<li>Great Microprocessors of the Past and Present<br />
<a href="http://www.cpushack.com/CPU/cpu1.html">http://www.cpushack.com/CPU/cpu1.html</a>
</li>

<li>A Brief History of Microprogramming<br />
<a href="http://www.cs.clemson.edu/~mark/uprog.html">http://www.cs.clemson.edu/~mark/uprog.html</a>
</li>

<li>What is RISC?<br />
<a href="http://www-cs-faculty.stanford.edu/~eroberts/courses/soco/projects/2000-01/risc/whatis/">http://www-cs-faculty.stanford.edu/~eroberts/courses/soco/projects/2000-01/risc/whatis/</a>
</li>

<li>RISC vs. CISC<br />
<a href="http://www-cs-faculty.stanford.edu/~eroberts/courses/soco/projects/2000-01/risc/risccisc/">http://www-cs-faculty.stanford.edu/~eroberts/courses/soco/projects/2000-01/risc/risccisc/</a>
</li>

<li>RISC and CISC definitions:<br />
<a href="http://www.cpushack.com/CPU/cpuAppendA.html">http://www.cpushack.com/CPU/cpuAppendA.html</a>
</li>

<li>FPGA<br />
<a href="https://cs.wikipedia.org/wiki/Programovateln%C3%A9_hradlov%C3%A9_pole">https://cs.wikipedia.org/wiki/Programovateln%C3%A9_hradlov%C3%A9_pole</a>
</li>

<li>The Evolution of RISC<br />
<a href="http://www.ibm.com/developerworks/library/pa-microhist.html#sidebar1">http://www.ibm.com/developerworks/library/pa-microhist.html#sidebar1</a>
</li>

<li>SPARC Processor Family Photo<br />
<a href="http://thenetworkisthecomputer.com/site/?p=243">http://thenetworkisthecomputer.com/site/?p=243</a>
</li>

<li>SPARC: Decades of Continuous Technical Innovation<br />
<a href="http://blogs.oracle.com/ontherecord/entry/sparc_decades_of_continuous_technical">http://blogs.oracle.com/ontherecord/entry/sparc_decades_of_continuous_technical</a>
</li>

<li>The SPARC processors<br />
<a href="http://www.top500.org/2007_overview_recent_supercomputers/sparc_processors">http://www.top500.org/2007_overview_recent_supercomputers/sparc_processors</a>
</li>

<li>Reduced instruction set computing (Wikipedia)<br />
<a href="http://en.wikipedia.org/wiki/Reduced_instruction_set_computer">http://en.wikipedia.org/wiki/Reduced_instruction_set_computer</a>
</li>

<li>MIPS architecture (Wikipedia)<br />
<a href="http://en.wikipedia.org/wiki/MIPS_architecture">http://en.wikipedia.org/wiki/MIPS_architecture</a>
</li>

<li>Very long instruction word (Wikipedia)<br />
<a href="http://en.wikipedia.org/wiki/Very_long_instruction_word">http://en.wikipedia.org/wiki/Very_long_instruction_word</a>
</li>

<li>Classic RISC pipeline (Wikipedia)<br />
<a href="http://en.wikipedia.org/wiki/Classic_RISC_pipeline">http://en.wikipedia.org/wiki/Classic_RISC_pipeline</a>
</li>

<li>R2000 Microprocessor (Wikipedia)<br />
<a href="http://en.wikipedia.org/wiki/R2000_(microprocessor)">http://en.wikipedia.org/wiki/R2000_(microprocessor)</a>
</li>

<li>R3000 Microprocessor (Wikipedia)<br />
<a href="http://en.wikipedia.org/wiki/R3000">http://en.wikipedia.org/wiki/R3000</a>
</li>

<li>R4400 Microprocessor (Wikipedia)<br />
<a href="http://en.wikipedia.org/wiki/R4400">http://en.wikipedia.org/wiki/R4400</a>
</li>

<li>R8000 Microprocessor (Wikipedia)<br />
<a href="http://en.wikipedia.org/wiki/R8000">http://en.wikipedia.org/wiki/R8000</a>
</li>

<li>R10000 Microprocessor (Wikipedia)<br />
<a href="http://en.wikipedia.org/wiki/R10000">http://en.wikipedia.org/wiki/R10000</a>
</li>

<li>SPARC (Wikipedia)<br />
<a href="http://en.wikipedia.org/wiki/Sparc">http://en.wikipedia.org/wiki/Sparc</a>
</li>

<li>CPU design (Wikipedia)<br />
<a href="http://en.wikipedia.org/wiki/CPU_design">http://en.wikipedia.org/wiki/CPU_design</a>
</li>

<li>Control unit (Wikipedia)<br />
<a href="http://en.wikipedia.org/wiki/Control_unit">http://en.wikipedia.org/wiki/Control_unit</a>
</li>

<li>CPUID na x86-64<br />
<a href="http://www.felixcloutier.com/x86/CPUID.html">http://www.felixcloutier.com/x86/CPUID.html</a>
</li>

<li>Endianness<br />
<a href="https://en.wikipedia.org/wiki/Endianness">https://en.wikipedia.org/wiki/Endianness</a>
</li>

<li>Otevřené RISCové architektury OpenRISC a RISC-V<br />
<a href="https://www.root.cz/clanky/otevrene-riscove-architektury-openrisc-a-risc-v/">https://www.root.cz/clanky/otevrene-riscove-architektury-openrisc-a-risc-v/</a>
</li>

<li>Instrukční sada procesorových jader s otevřenou architekturou RISC-V<br />
<a href="https://www.root.cz/clanky/instrukcni-sada-procesorovych-jader-s-otevrenou-architekturou-risc-v/">https://www.root.cz/clanky/instrukcni-sada-procesorovych-jader-s-otevrenou-architekturou-risc-v/</a>
</li>

<li>Rozšíření instrukční sady procesorových jader s otevřenou architekturou RISC-V<br />
<a href="https://www.root.cz/clanky/rozsireni-instrukcni-sady-procesorovych-jader-s-otevrenou-architekturou-risc-v/">https://www.root.cz/clanky/rozsireni-instrukcni-sady-procesorovych-jader-s-otevrenou-architekturou-risc-v/</a>
</li>

<li>Instrukční sady procesorových jader s otevřenou architekturou RISC-V (dokončení)<br />
<a href="https://www.root.cz/clanky/instrukcni-sady-procesorovych-jader-s-otevrenou-architekturou-risc-v-dokonceni/">https://www.root.cz/clanky/instrukcni-sady-procesorovych-jader-s-otevrenou-architekturou-risc-v-dokonceni/</a>
</li>

<li>RISCové mikroprocesory s komprimovanými instrukčními sadami<br />
<a href="https://www.root.cz/clanky/riscove-mikroprocesory-s-komprimovanymi-instrukcnimi-sadami/">https://www.root.cz/clanky/riscove-mikroprocesory-s-komprimovanymi-instrukcnimi-sadami/</a>
</li>

<li>RISCové mikroprocesory s komprimovanými instrukčními sadami (2)<br />
<a href="https://www.root.cz/clanky/riscove-mikroprocesory-s-komprimovanymi-instrukcnimi-sadami-2/">https://www.root.cz/clanky/riscove-mikroprocesory-s-komprimovanymi-instrukcnimi-sadami-2/</a>
</li>

</ol>



<p></p><p></p>
<p><small>Autor: <a href="http://www.fit.vutbr.cz/~tisnovpa">Pavel Tišnovský</a> &nbsp; 2018</small></p>
</body>
</html>

