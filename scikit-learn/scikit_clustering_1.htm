<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
        "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html>
<head>
<title>Shluková analýza (clustering) a knihovna Scikit-learn</title>
<meta name="Author" content="Pavel Tisnovsky" />
<meta name="Generator" content="vim" />
<meta http-equiv="content-type" content="text/html; charset=utf-8" />
<style type="text/css">
         body {color:#000000; background:#ffffff;}
         h1  {font-family: arial, helvetica, sans-serif; color:#ffffff; background-color:#c00000; text-align:center; padding-left:1em}
         h2  {font-family: arial, helvetica, sans-serif; color:#ffffff; background-color:#0000c0; padding-left:1em; text-align:left}
         h3  {font-family: arial, helvetica, sans-serif; color:#000000; background-color:#c0c0c0; padding-left:1em; text-align:left}
         h4  {font-family: arial, helvetica, sans-serif; color:#000000; background-color:#e0e0e0; padding-left:1em; text-align:left}
         a   {font-family: arial, helvetica, sans-serif;}
         li  {font-family: arial, helvetica, sans-serif; color:#000000; text-align:justify; width:450px;}
         ol  {font-family: arial, helvetica, sans-serif; color:#000000; text-align:justify; width:450px;}
         ul  {font-family: arial, helvetica, sans-serif; color:#000000; text-align:justify; width:450px;}
         p   {font-family: arial, helvetica, sans-serif; color:#000000; text-align:justify;}
         pre {background:#e0e0e0}
</style>
</head>

<body>

<h1>Shluková analýza (clustering) a knihovna Scikit-learn</h1>

<h3>Pavel Tišnovský</h3>

<p></p>

<h1>Úvodník</h1>

<p>Knihovna Scikit-learn kromě modelů (a jejich tréninku) poskytuje i další nástroje. Jedním z užitečných nástrojů, které zde nalezneme, je podpora pro provádění takzvané shlukové analýzy (cluster analysis, clustering). Dnes si ukážeme základní způsob využití této techniky.</p>



<h2>Obsah</h2>

<p><a href="#k01">1. Shluková analýza (<i>clustering</i>) a knihovna Scikit-learn</a></p>
<p><a href="#k02">2. Příklad reálných dat, u nichž lze využít shlukovou analýzu</a></p>
<p><a href="#k03">3. Příprava dat pro shlukovou analýzu</a></p>
<p><a href="#k04">4. Vygenerování sady bodů v&nbsp;rovině funkcí <strong>sklearn.datasets.make_blobs</strong></a></p>
<p><a href="#k05">5. Malá odbočka: prohození x-ových a y-ových souřadnic</a></p>
<p><a href="#k06">6. Korelační diagram (bodový graf)</a></p>
<p><a href="#k07">7. Vykreslení bodů vygenerovaných funkcí <strong>sklearn.datasets.make_blobs</strong></a></p>
<p><a href="#k08">8. Úprava skriptu pro vykreslení většího množství bodů v&nbsp;rovině</a></p>
<p><a href="#k09">9. Obarvení bodů na základě toho, do jakého clusteru patří</a></p>
<p><a href="#k10">10. Algoritmus K-means pro shlukovou analýzu</a></p>
<p><a href="#k11">11. Nalezení centroidů algoritmem K-means</a></p>
<p><a href="#k12">12. Zobrazení centroidů společně se všemi body v&nbsp;rovině</a></p>
<p><a href="#k13">13. Výpočet clusterů</a></p>
<p><a href="#k14">14. Vizualizace clusterů</a></p>
<p><a href="#k15">15. Clustering pro větší počet bodů v&nbsp;případě, kdy se oblasti centroidů překrývají</a></p>
<p><a href="#k16">16. Pokus o nalezení clusterů v&nbsp;náhodných datech</a></p>
<p><a href="#k17">17. Limity standardního algoritmu K-means</a></p>
<p><a href="#k18">18. Obsah navazujícího článku</a></p>
<p><a href="#k19">19. Repositář s&nbsp;demonstračními příklady</a></p>
<p><a href="#k20">20. Odkazy na Internetu</a></p>



<p><a name="k01"></a></p>
<h2 id="k01">1. Shluková analýza (<i>clustering</i>) a knihovna Scikit-learn</h2>

<p>V&nbsp;článku <a
href="https://www.root.cz/clanky/rozpoznavani-obrazku-knihovnou-scikit-learn-prvni-kroky/">Rozpoznávání
obrázků knihovnou Scikit-learn: první kroky</a> jsme se ve stručnosti seznámili
s&nbsp;tím, jakým způsobem spolu dokážou kooperovat knihovny <i>NumPy</i>,
<i>Pandas</i> (či <i>Polars</i>), <i>Matplotlib</i> a <i>Scikit-Learn</i>. Tuto
kooperaci jsme si ukázali na příkladu rozpoznávání ručně napsaných číslic,
přičemž knihovna Scikit-Learn byla použita jako zdroj dat pro trénink i
validaci, ovšem navíc nám poskytla i model, který jsme mohli natrénovat.
Knihovna NumPy v&nbsp;tomto případě zajišťovala podporu základních datových
struktur (n-rozměrná pole, <i>nd-array</i>) i algoritmů a knihovna Matplotlib
sloužila pro vizualizaci vstupních dat, mezivýsledků i výsledků poskytovaných
natrénovaným modelem.</p>

<img src="https://i.iinfo.cz/images/542/scikit-learn-1-28.webp" class="image-1110870" width="640" height="480" alt="&#160;" title="Autor: Tisnik+MNiST authors, podle licence: &lt;a href=&quot;http://en.wikipedia.org/wiki/Rights_Managed&quot;&gt;Rights Managed&lt;/a&gt;" />
<p><i>Obrázek 1: Prvních patnáct číslic, které jsme v&nbsp;předchozím článku
použili pro trénink modelu.</i></p>

<p>Ovšem knihovna Scikit-learn ve skutečnosti nemusí být použita pouze pro
trénink modelů; dokonce je možné říci, že je to pro mnoho uživatelů zcela
okrajové téma. Scikit-learn totiž poskytuje i mnoho dalších nástrojů. Jedním
z&nbsp;velmi užitečných nástrojů, které zde nalezneme, je podpora pro provádění
takzvané <i>shlukové analýzy</i> (<i>cluster analysis</i>, <i>clustering</i>).
Jedná se o proces, který se používá jako vstup pro <i>klasifikaci</i> objektů.
Zjednodušeně řečeno se používá k&nbsp;rozdělení vstupních dat (či již nějakým
způsobem upravených dat) do skupin, přičemž se očekává, že data, která budou
náležet do stejné skupiny, budou představovat objekty (i když možná by bylo
lepší říci informace) s&nbsp;podobnými vlastnostmi.</p>

<img src="https://i.iinfo.cz/images/542/scikit-learn-1-29.webp" class="image-1110871" width="640" height="480" alt="&#160;" title="Autor: Tisnik+MNiST authors, podle licence: &lt;a href=&quot;http://en.wikipedia.org/wiki/Rights_Managed&quot;&gt;Rights Managed&lt;/a&gt;" />
<p><i>Obrázek 2: Výsledky modelu, který jsme natrénovali v&nbsp;rámci
předchozího článku.</i></p>



<p><a name="k02"></a></p>
<h2 id="k02">2. Příklad reálných dat, u nichž lze využít shlukovou analýzu</h2>

<p>Poměrně dobrým příkladem toho, kde může být shluková analýza užitečná, mohou
být data zjištěná o nějaké hvězdě (například informace o teplotě a zářivém
výkonu nebo velikosti). Pokud vyneseme do jednoduchého dvourozměrného grafu
hodnoty pro tyto dvě veličiny pro všechny pozorované (a změřené) hvězdy,
získáme slavný <i>Hertzsprungův–Russellův diagram</i>, zkráceně též
<i>H&ndash;R diagram</i>, který vypadá následovně:</p>

<img src="https://i.iinfo.cz/images/375/scikit-learn-clustering-1.webp" class="image-1111745" width="720" height="820" alt="&#160;" title="Autor: adam, podle licence: &lt;a href=&quot;http://en.wikipedia.org/wiki/Rights_Managed&quot;&gt;Rights Managed&lt;/a&gt;" />
<p><i>Obrázek 3: Ukázka H&ndash;R diagramu.<br />
Autor: Adam na projektu Wikipedie v jazyce čeština – Na Commons přeneseno z
cs.wikipedia., Volné dílo,
https://commons.wikimedia.org/w/index.php?curid=2157609</i></p>

<p>Na H-R diagramu jsou jasně patrné oblasti, do nichž jsou sdruženy hvězdy
s&nbsp;podobnými vlastnostmi (dokonce můžeme říci, že s&nbsp;podobným osudem).
A úkolem shlukové analýzy (<i>clusteringu</i>) je tyto oblasti nalézt
resp.&nbsp;vypočítat. V&nbsp;tomto konkrétním případě je to relativně
jednoduchá úloha, ovšem pochopitelně se v&nbsp;praxi ne vždy data shlukují
takto &bdquo;pěkným&ldquo; způsobem. Z&nbsp;tohoto důvodu existuje hned několik
algoritmů pro shlukovou analýzu &ndash; a nejtěžším úkolem je vybrat si ten
správný algoritmus a určit jeho parametry.</p>

<p><div class="rs-tip-major">Poznámka: pochopitelně se však nemusíme orientovat
pouze na astronomická data a astronomické objekty, protože shlukovou analýzu
lze provádět i na mnoha dalších datech, typicky ve chvíli, kdy sice tušíme, že
mezi jednotlivými veličinami (a požadovaným výsledkem) existuje nějaká
korelace, ale nevíme jaká. A shluková analýza navíc není omezena pouze na dvě
veličiny, tedy na dvourozměrný diagram. Počet shlukovaných veličin a tím pádem
i počet dimenzí diagramu ve skutečnosti není omezen, i když vizualizace (ta je
zde důležitá! &ndash; lidský mozek totiž dokáže výsledek velmi snadno
verifikovat) bude mít praktický význam především pro diagramy se dvěma či třemi
veličinami.  I proto se v&nbsp;praxi při zpracování dat setkáme s&nbsp;redukcí
počtu dimenzí (odstranění nějaké veličiny).</div></p>



<p><a name="k03"></a></p>
<h2 id="k03">3. Příprava dat pro shlukovou analýzu</h2>

<p>Dnes si otestujeme jeden konkrétní algoritmus určený pro provedení shlukové
analýzy, který se nazývá <i>K-means clustering</i>. Ovšem nejprve si musíme
připravit vhodná data, na kterých bude možné si vizuálně ověřit výsledky tohoto
algoritmu. Jak již víme z&nbsp;předchozího textu, může být shluková analýza
provedena v&nbsp;prakticky libovolném počtu dimenzí, ovšem pro jednoduchost
začneme dvoudimenzionálními daty. V&nbsp;praxi se tedy bude jednat o sadu
hodnot dvou veličin (nebo jedné veličiny) &ndash; například již zmíněné teploty
a zářivém výkonu hvězdy. Pro každý objekt vyneseme jednu hodnotu na x-ovou osu
a druhou hodnotu na y-ovou osu. Výsledkem bude bod v&nbsp;rovině.</p>

<p>Pro naše pokusy tedy potřebujeme získat sadu bodů v&nbsp;rovině, které však
nebudou rozmístěny zcela náhodně (tam poněkud postrádá shluková analýza smysl).
Existuje mnoho způsobů, jak body v&nbsp;rovině rozmístit. Pro velkou názornost
jsem pro dnešní článek vybral metodu realizovanou ve funkci
<strong>sklearn.datasets.make_blobs</strong>, která nejprve vybere <i>n</i>
centrálních bodů a poté rozmisťuje další body okolo těchto center tak, že
pravděpodobnost umístění bodu dále od centra klesá podle Gaussovy křivky
(teoreticky tedy může být bod umístěn na ploše kdekoli, ovšem s&nbsp;větší
vzdáleností od centrálních bodů pravděpodobnost jeho umístění do daného místa
klesá &ndash; což si ověříme vizuálně).</p>

<p><div class="rs-tip-major">Poznámka: poněkud podobný koncept, i když doplněný
o nalezení izoplochy, je použit i v&nbsp;modelovací technice založené na
<i>metaballs</i>, viz též poněkud starší článek <a
href="https://www.root.cz/clanky/implicitni-plochy-metaballs-v-pov-rayi/">Implicitní
plochy (metaballs) v&nbsp;POV-Rayi</a>.</div></p>



<p><a name="k04"></a></p>
<h2 id="k04">4. Vygenerování sady bodů v&nbsp;rovině funkcí <strong>sklearn.datasets.make_blobs</strong></h2>

<p>Podívejme se nyní na praktické použití funkce
<strong>sklearn.datasets.make_blobs</strong>. Této funkci musíme předat
především počet bodů, které se mají vygenerovat (<strong>n_samples</strong>),
počet centrálních bodů (<strong>centers</strong>) a další parametry ovlivňující
generování bodů (směrodatná odchylka atd.). Výsledkem bude dvojice hodnot
&ndash; pole se samotnými body a taktéž pole obsahující pro každý vygenerovaný
bod index centrálního body (<i>centroidu</i>), který je k&nbsp;němu nejblíže
(resp.&nbsp;přesněji index centrálního bodu, který byl použit v&nbsp;algoritmu
výpočtu pseudonáhodné pozice):</p>

<pre>
<i># import funkce, která dokáže vygenerovat množinu bodů v rovině sdružených do oblastí</i>
from sklearn.datasets import make_blobs
&nbsp;
<i># testovací data</i>
n_samples = 20
&nbsp;
<i># počet oblastí, kam se budou data sdružovat</i>
n_components = 6
&nbsp;
<i># vygenerovat množinu bodů v rovině sdružených do oblastí</i>
samples, labels = make_blobs(
    n_samples=n_samples, centers=n_components, cluster_std=0.60, random_state=0
)
&nbsp;
print("Points:")
print(samples)
print()
&nbsp;
print("Labels:")
print(labels)
</pre>

<p>Výsledky mohou pro daný počet dvaceti bodů vypadat následovně:</p>

<pre>
Before swap:
[[-1.45700306  7.9292694 ]
 [ 3.4171203   0.02504426]
 [-1.48065187  7.65407837]
 [-0.60723648  3.79949752]
 [ 5.29722082  0.81003989]
 [ 8.9674639  -2.5940142 ]
 [ 2.08272263  0.78535335]
 [-2.05957546  1.72940438]
 [ 4.86616205  0.45025423]
 [ 8.2494931  -1.16070439]
 [-0.51008137  8.55688792]
 [ 0.52347363  1.28983482]
 [ 1.87271752  4.18069237]
 [ 1.24258802  4.50399192]
 [ 5.08282355  1.04439261]
 [ 8.64412343 -3.18318039]
 [ 2.57392924  0.45236465]
 [ 1.43289271  4.37679234]
 [ 1.1641107   3.79132988]
 [-1.43393556  3.14477977]]
&nbsp;
Labels:
[3 1 3 2 5 4 1 2 5 4 3 1 0 0 5 4 1 0 0 2]
</pre>



<p><a name="k05"></a></p>
<h2 id="k05">5. Malá odbočka: prohození x-ových a y-ových souřadnic</h2>

<p>Při vizualizaci bodů v&nbsp;rovině je mnohdy vhodné prohodit jejich x-ové a
y-ové souřadnice (což může být případ výše zmíněného HR-diagramu). V&nbsp;praxi
toho dosáhneme velmi snadno, protože knihovna NumPy u n-rozměrných polí
přetěžuje jak operátor indexování, tak i operátor pro provedení řezu
(<i>slice</i>). V&nbsp;případě dvourozměrného pole, kde souřadnice jsou uloženy
ve dvou sloupcích, lze prohození sloupců s&nbsp;x-ovými a y-ovými souřadnicemi
realizovat následovně:</p>

<pre>
<strong>samples = samples[:, ::-1]</strong>
</pre>

<p>Což si lze snadno otestovat:</p>

<pre>
<i># import funkce, která dokáže vygenerovat množinu bodů v rovině sdružených do oblastí</i>
from sklearn.datasets import make_blobs
&nbsp;
<i># testovací data</i>
n_samples = 20
&nbsp;
<i># počet oblastí, kam se budou data sdružovat</i>
n_components = 6
&nbsp;
<i># vygenerovat množinu bodů v rovině sdružených do oblastí</i>
samples, labels = make_blobs(
    n_samples=n_samples, centers=n_components, cluster_std=0.60, random_state=0
)
&nbsp;
print("Before swap:")
print(samples)
print()
&nbsp;
<strong>samples = samples[:, ::-1]</strong>
print("After swap:")
print(samples)
print()
&nbsp;
print("Labels:")
print(labels)
</pre>

<p>Po spuštění tohoto skriptu se opět vypíšou souřadnice dvaceti bodů.
Tentokrát však budou odlišné od příkladu <a href="#k04">z&nbsp;předchozí
kapitoly</a>, protože došlo k&nbsp;prohození x-ových a y-ových souřadnic:</p>

<pre>
Before swap:
[[-1.45700306  7.9292694 ]
 [ 3.4171203   0.02504426]
 [-1.48065187  7.65407837]
 [-0.60723648  3.79949752]
 [ 5.29722082  0.81003989]
 [ 8.9674639  -2.5940142 ]
 [ 2.08272263  0.78535335]
 [-2.05957546  1.72940438]
 [ 4.86616205  0.45025423]
 [ 8.2494931  -1.16070439]
 [-0.51008137  8.55688792]
 [ 0.52347363  1.28983482]
 [ 1.87271752  4.18069237]
 [ 1.24258802  4.50399192]
 [ 5.08282355  1.04439261]
 [ 8.64412343 -3.18318039]
 [ 2.57392924  0.45236465]
 [ 1.43289271  4.37679234]
 [ 1.1641107   3.79132988]
 [-1.43393556  3.14477977]]
&nbsp;
After swap:
[[ 7.9292694  -1.45700306]
 [ 0.02504426  3.4171203 ]
 [ 7.65407837 -1.48065187]
 [ 3.79949752 -0.60723648]
 [ 0.81003989  5.29722082]
 [-2.5940142   8.9674639 ]
 [ 0.78535335  2.08272263]
 [ 1.72940438 -2.05957546]
 [ 0.45025423  4.86616205]
 [-1.16070439  8.2494931 ]
 [ 8.55688792 -0.51008137]
 [ 1.28983482  0.52347363]
 [ 4.18069237  1.87271752]
 [ 4.50399192  1.24258802]
 [ 1.04439261  5.08282355]
 [-3.18318039  8.64412343]
 [ 0.45236465  2.57392924]
 [ 4.37679234  1.43289271]
 [ 3.79132988  1.1641107 ]
 [ 3.14477977 -1.43393556]]
&nbsp;
Labels:
[3 1 3 2 5 4 1 2 5 4 3 1 0 0 5 4 1 0 0 2]
</pre>



<p><a name="k06"></a></p>
<h2 id="k06">6. Korelační diagram (bodový graf)</h2>

<p>Body vytvořené předchozími dvěma skripty je možné vykreslit (vizualizovat)
několika způsoby, ovšem jediným typem grafu, se kterým se dnes seznámíme, je
takzvaný <i>korelační diagram</i>, který je ovšem někdy známý i pod jménem
<i>bodový graf</i> (<i>scatter plot</i>). Tento graf se v&nbsp;knihovně
Matplotlib vykresluje funkcí <strong>matplotlib.pyplot.scatter</strong>, které
se předají minimálně informace o x-ových a y-ových souřadnicích bodů, jež se
mají do grafu vykreslit.</p>

<p>Všechny x-ové a všechny y-ové souřadnice získáme z&nbsp;našeho 2D pole (matice) takto:</p>

<pre>
xs = samples[:, 0]
ys = samples[:, 1]
</pre>



<p><a name="k07"></a></p>
<h2 id="k07">7. Vykreslení bodů vygenerovaných funkcí <strong>sklearn.datasets.make_blobs</strong></h2>

<p>Ukažme si tedy, jakým způsobem je možné v&nbsp;praxi realizovat vykreslení
bodů se souřadnicemi vygenerovanými funkcí
<strong>sklearn.datasets.make_blobs</strong>. K&nbsp;tomuto účelu použijeme
funkci nazvanou <strong>matplotlib.pyplot.scatter</strong>, které se v&nbsp;tom
nejjednodušším případě předají dva vektory (jednorozměrná pole). V&nbsp;prvním
vektoru budou uloženy x-ové souřadnice bodů, ve druhém vektoru pak jejich y-ové
souřadnice. Souřadnice grafu budou upraveny takovým způsobem, aby se zobrazily
všechny body a navíc aby byla plocha grafu vyplněna (bez prázdných
oblastí):</p>

<pre>
<i># budeme provádět vykreslování de facto standardní knihovnou Matplotlib</i>
import matplotlib.pyplot as plt
&nbsp;
<i># import funkce, která dokáže vygenerovat množinu bodů v rovině sdružených do oblastí</i>
from sklearn.datasets import make_blobs
&nbsp;
<i># testovací data</i>
n_samples = 100
&nbsp;
<i># počet oblastí, kam se budou data sdružovat</i>
n_components = 6
&nbsp;
<i># vygenerovat množinu bodů v rovině sdružených do oblastí</i>
samples, labels = make_blobs(
    n_samples=n_samples, centers=n_components, cluster_std=0.60, random_state=0
)
&nbsp;
samples = samples[:, ::-1]
&nbsp;
<i># vykreslení bodů v rovině</i>
<strong>plt.scatter(samples[:, 0], samples[:, 1])</strong>
&nbsp;
<i># uložení grafu do souboru</i>
plt.savefig("scatter_1.png")
&nbsp;
<i># vykreslení na obrazovku</i>
plt.show()
</pre>

<p>Výsledek bude vypadat následovně:</p>

<img src="https://i.iinfo.cz/images/593/scikit-learn-2-1.webp" class="image-1111746" width="640" height="480" alt="&#160;" title="Autor: tisnik, podle licence: &lt;a href=&quot;http://en.wikipedia.org/wiki/Rights_Managed&quot;&gt;Rights Managed&lt;/a&gt;" />
<p><i>Obrázek 4: Zobrazení 100 bodů rozmístěných v&nbsp;rovině pseudonáhodným
způsobem.</i></p>



<p><a name="k08"></a></p>
<h2 id="k08">8. Úprava skriptu pro vykreslení většího množství bodů v&nbsp;rovině</h2>

<p><a href="#k07">Výše uvedený příklad</a> je vhodné použít ve chvíli, kdy se
má zobrazit relativně malé množství bodů, odhadem několik set. Pokud je však
bodů větší množství, budou se překrývat, protože jejich <i>stopy</i>
v&nbsp;grafu jsou příliš velké. Ovšem je relativně snadné změnit jak tvar
zobrazené stopy (parametr <strong>marker</strong>), tak i její velikost
(parametr <strong>size</strong>). U velikosti je však vhodné si uvědomit, že je
udávána nikoli v&nbsp;pixelech, ale v&nbsp;typografických bodech (1/72 palce),
podobně jako na mnoha dalších místech Matplotlibu. Velikost je tedy poměrně
špatné odhadnout a je tedy vhodné skript spustit s&nbsp;několika parametry a
vybrat si tu &bdquo;správnou&ldquo; velikost (záleží i na tom, jak se body
shlukují apod.).</p>

<p>V&nbsp;dalším příkladu se pokusíme o zobrazení 1000 bodů, jejichž stopy však
budou menší, než tomu bylo v&nbsp;předchozím demonstračním příkladu:</p>

<pre>
<i># budeme provádět vykreslování de facto standardní knihovnou Matplotlib</i>
import matplotlib.pyplot as plt
&nbsp;
<i># import funkce, která dokáže vygenerovat množinu bodů v rovině sdružených do oblastí</i>
from sklearn.datasets import make_blobs
&nbsp;
<i># testovací data</i>
n_samples = 1000
&nbsp;
<i># počet oblastí, kam se budou data sdružovat</i>
n_components = 6
&nbsp;
<i># vygenerovat množinu bodů v rovině sdružených do oblastí</i>
samples, labels = make_blobs(
    n_samples=n_samples, centers=n_components, cluster_std=0.60, random_state=0
)
&nbsp;
samples = samples[:, ::-1]
&nbsp;
<i># vykreslení bodů v rovině</i>
<strong>plt.scatter(samples[:, 0], samples[:, 1], marker=".", s=10)</strong>
&nbsp;
<i># uložení grafu do souboru</i>
plt.savefig("scatter_2.png")
&nbsp;
<i># vykreslení na obrazovku</i>
plt.show()
</pre>

<p>A takto by měl vypadat výsledek:</p>

<img src="https://i.iinfo.cz/images/593/scikit-learn-2-2.webp" class="image-1111747" width="640" height="480" alt="&#160;" title="Autor: tisnik, podle licence: &lt;a href=&quot;http://en.wikipedia.org/wiki/Rights_Managed&quot;&gt;Rights Managed&lt;/a&gt;" />
<p><i>Obrázek 5: Zobrazení 1000 bodů rozmístěných v&nbsp;rovině pseudonáhodným
způsobem.</i></p>



<p><a name="k09"></a></p>
<h2 id="k09">9. Obarvení bodů na základě toho, do jakého clusteru patří</h2>

<p>V&nbsp;předchozím textu jsme si řekli, že funkce
<strong>sklearn.datasets.make_blobs</strong> vrací nejenom souřadnice bodů, ale
i index (celé číslo) udávající oblast (řekněme poněkud nepřesně
<i>cluster</i>), do které daný bod náleží. Tuto hodnotu můžeme využít ke dvěma
účelům:</p>

<ol>
<li>Pro ověření algoritmu pro shlukovou analýzu</li>
<li>Pro vizualizaci bodů, přesněji řečeno pro jejich obarvení podle oblasti</li>
</ol>

<p>Vyzkoušejme si nyní obarvení bodů podle oblasti. Je to snadné. Vytvoříme si
seznam (či n-tici) se šesti kódy barev:</p>

<pre>
colors = ["#4444cc", "#44bb44", "#cc4444", "#cccc44", "#44cccc", "#cc44cc"]
</pre>

<p>Dále budeme iterovat přes prvky této kolekce a vykreslíme pouze ty body,
které mají shodnou hodnotu <i>label</i> s&nbsp;indexem barvy (0-5):</p>

<pre>
for i, color in enumerate(colors):
    ...
    ...
    ...
</pre>

<p>Jak se vlastně provádí výběr bodů z&nbsp;dvourozměrného pole? Nejprve si
vytvoříme pomocný vektor obsahující pouze 0 a 1, kde 1 znamená, že se má
příslušný bod vybrat. Tento vektor bude použit jako <i>selektor</i> do
původního dvourozměrného pole se souřadnicemi:</p>

<pre>
for i, color in enumerate(colors):
    selector = labels == i
</pre>

<p>Zbývá nám jen selektor použít a vykreslit body zadanou barvou:</p>

<pre>
for i, color in enumerate(colors):
    selector = labels == i
    plt.scatter(samples[selector, 0], samples[selector, 1], c=color, marker=".", s=10)
</pre>

<p>Výsledek by měl vypadat následovně:</p>

<img src="https://i.iinfo.cz/images/593/scikit-learn-2-3.webp" class="image-1111748" width="640" height="480" alt="&#160;" title="Autor: tisnik, podle licence: &lt;a href=&quot;http://en.wikipedia.org/wiki/Rights_Managed&quot;&gt;Rights Managed&lt;/a&gt;" />
<p><i>Obrázek 6: Obarvení bodů na základě toho, do jakého clusteru patří.</i></p>

<p>Pro jistotu si ukažme celý skript, který toto vykreslení provede:</p>

<pre>
<i># budeme provádět vykreslování de facto standardní knihovnou Matplotlib</i>
import matplotlib.pyplot as plt
&nbsp;
<i># import funkce, která dokáže vygenerovat množinu bodů v rovině sdružených do oblastí</i>
from sklearn.datasets import make_blobs
&nbsp;
<i># testovací data</i>
n_samples = 1000
&nbsp;
<i># počet oblastí, kam se budou data sdružovat</i>
n_components = 6
&nbsp;
<i># vygenerovat množinu bodů v rovině sdružených do oblastí</i>
samples, labels = make_blobs(
    n_samples=n_samples, centers=n_components, cluster_std=0.60, random_state=0
)
&nbsp;
samples = samples[:, ::-1]
&nbsp;
<i># vykreslení bodů v rovině s jejich obarvením na základě labelu</i>
plt.figure(1)
colors = ["#4444cc", "#44bb44", "#cc4444", "#cccc44", "#44cccc", "#cc44cc"]
&nbsp;
for i, color in enumerate(colors):
    selector = labels == i
    plt.scatter(samples[selector, 0], samples[selector, 1], c=color, marker=".", s=10)
&nbsp;
<i># uložení grafu do souboru</i>
plt.savefig("scatter_3.png")
&nbsp;
<i># vykreslení na obrazovku</i>
plt.show()
</pre>



<p><a name="k10"></a></p>
<h2 id="k10">10. Algoritmus K-means pro shlukovou analýzu</h2>

<p>Vzhledem k&nbsp;tomu, že cíle shlukové analýzy jsou poměrně rozmanité a
různé je i rozmístění bodů, pro které hledáme vhodné clustery, existuje
minimálně několik desítek algoritmů, které shlukovou analýzu provádí. Tyto
algoritmy se liší jak svou výpočetní složitostí, tak i způsobem vyhledání
clusterů. Pro potřeby dnešního článku byl vybrán pravděpodobně nejznámější
algoritmus shlukové analýzy, který se jmenuje <i>K-means</i>. Tento algoritmus
je založen na předpokladu, že vstupní objekty jsou chápány jako skutečné body
v&nbsp;nějakém eukleidovském prostoru a již dopředu víme, kolik shluků
(clusterů) má existovat. Algoritmus nejprve nalezne takzvané <i>centroidy</i> a
následně jsou vstupní objekty (body) zařazeny k&nbsp;tomu centroidu, který je
k&nbsp;bodu nejblíže. Poté se provádí další iterace; centroidy se přesunou do
těžiště clusteru a provede se nové přiřazení.</p>



<p><a name="k11"></a></p>
<h2 id="k11">11. Nalezení centroidů algoritmem K-means</h2>

<p>Prvním úkolem algoritmu K-means je nalezení centroidů, tedy centra oblastí,
v&nbsp;nichž se body shlukují. V&nbsp;knihovně Scikit-learn můžeme tuto operaci
provést s&nbsp;využitím funkce <strong>kmeans_plusplus</strong> (viz též <a
href="https://en.wikipedia.org/wiki/K-means%2B%2B">tento článek</a>). Tato
funkce vrací ve své první návratové hodnotě dvourozměrné pole s&nbsp;nalezenými
centry oblastí. Povšimněte si, že funkci <strong>kmeans_plusplus</strong>
předáváme nejenom samotné pole se souřadnicemi bodů, ale i předpokládaný počet
oblastí. Tuto hodnotu tedy musíme dopředu znát či ji odhadnout (a postupovat
iterativním způsobem):</p>

<pre>
<i># nalézt centra oblastí</i>
<strong>centers_init, indices = kmeans_plusplus(samples, n_clusters=6, random_state=0)</strong>
</pre>

<p>Získané dvourozměrné pole s&nbsp;centroidy lze vykreslit způsobem, který již
dobře známe. Centroidů je nepatrný počet (6), takže je vykreslíme
s&nbsp;využitím větších stop (<strong>s=50</strong>) a pro přehlednost
použijeme červenou barvu:</p>

<pre>
<strong>plt.scatter(centers_init[:, 0], centers_init[:, 1], c="red", s=50)</strong>
</pre>

<p>Výsledek by měl vypadat následovně:</p>

<img src="https://i.iinfo.cz/images/593/scikit-learn-2-4.webp" class="image-1111749" width="640" height="480" alt="&#160;" title="Autor: tisnik, podle licence: &lt;a href=&quot;http://en.wikipedia.org/wiki/Rights_Managed&quot;&gt;Rights Managed&lt;/a&gt;" />
<p><i>Obrázek 7: Vizualizace centroidů nalezených algoritmem K-means.</i></p>

<p>Opět si pro jistotu ukažme celý skript, který tuto operaci provádí:</p>

<pre>
<i># budeme provádět vykreslování de facto standardní knihovnou Matplotlib</i>
import matplotlib.pyplot as plt
&nbsp;
<i># funkce s implementací algoritmu pro clustering</i>
from sklearn.cluster import kmeans_plusplus
&nbsp;
<i># import funkce, která dokáže vygenerovat množinu bodů v rovině sdružených do oblastí</i>
from sklearn.datasets import make_blobs
&nbsp;
<i># testovací data</i>
n_samples = 1000
&nbsp;
<i># počet oblastí, kam se budou data sdružovat</i>
n_components = 6
&nbsp;
<i># vygenerovat množinu bodů v rovině sdružených do oblastí</i>
samples, labels = make_blobs(
    n_samples=n_samples, centers=n_components, cluster_std=0.60, random_state=0
)
&nbsp;
samples = samples[:, ::-1]
&nbsp;
<i># nalézt centra oblastí</i>
<strong>centers_init, indices = kmeans_plusplus(samples, n_clusters=6, random_state=0)</strong>
&nbsp;
<strong>plt.scatter(centers_init[:, 0], centers_init[:, 1], c="red", s=50)</strong>
plt.title("K-Means++")
&nbsp;
<i># uložení grafu do souboru</i>
plt.savefig("k_means_1.png")
&nbsp;
<i># vykreslení na obrazovku</i>
plt.show()
</pre>



<p><a name="k12"></a></p>
<h2 id="k12">12. Zobrazení centroidů společně se všemi body v&nbsp;rovině</h2>

<p>Pro ověření, zda vypočtené centroidy skutečně leží (blízko) středů
jednotlivých clusterů, je pochopitelně nejlepší si nechat na jednom grafu
zobrazit jak vstupní body (vygenerované funkcí <strong>make_blobs</strong>),
tak i vlastní centroidy. Tuto funkcionalitu knihovna <i>Matplotlib</i>
podporuje, protože na jednu plochu výsledného grafu můžeme vložit větší
množství korelačních diagramů (což jsme si již ostatně ukázali při
&bdquo;obarvování&ldquo; bodů). Skript pro výpočet centroidů a vizualizaci
výsledků tedy můžeme upravit do následující podoby:</p>

<pre>
<i># budeme provádět vykreslování de facto standardní knihovnou Matplotlib</i>
import matplotlib.pyplot as plt
&nbsp;
<i># funkce s implementací algoritmu pro clustering</i>
from sklearn.cluster import kmeans_plusplus
&nbsp;
<i># import funkce, která dokáže vygenerovat množinu bodů v rovině sdružených do oblastí</i>
from sklearn.datasets import make_blobs
&nbsp;
<i># testovací data</i>
n_samples = 1000
&nbsp;
<i># počet oblastí, kam se budou data sdružovat</i>
n_components = 6
&nbsp;
<i># vygenerovat množinu bodů v rovině sdružených do oblastí</i>
samples, labels = make_blobs(
    n_samples=n_samples, centers=n_components, cluster_std=0.60, random_state=0
)
&nbsp;
samples = samples[:, ::-1]
&nbsp;
<i># vykreslení bodů v rovině s jejich obarvením na základě labelu</i>
plt.figure(1)
colors = ["#4444cc", "#44bb44", "#cc4444", "#cccc44", "#44cccc", "#cc44cc"]
&nbsp;
for i, color in enumerate(colors):
    selector = labels == i
    plt.scatter(samples[selector, 0], samples[selector, 1], c=color, marker=".", s=10)
&nbsp;
<i># nalézt centra oblastí</i>
centers_init, indices = kmeans_plusplus(samples, n_clusters=6, random_state=0)
&nbsp;
plt.scatter(centers_init[:, 0], centers_init[:, 1], c="red", s=50)
plt.title("K-Means++")
&nbsp;
<i># uložení grafu do souboru</i>
plt.savefig("k_means_2.png")
&nbsp;
<i># vykreslení na obrazovku</i>
plt.show()
</pre>

<p>A takto by měl vypadat výsledek:</p>

<img src="https://i.iinfo.cz/images/593/scikit-learn-2-5.webp" class="image-1111750" width="640" height="480" alt="&#160;" title="Autor: tisnik, podle licence: &lt;a href=&quot;http://en.wikipedia.org/wiki/Rights_Managed&quot;&gt;Rights Managed&lt;/a&gt;" />
<p><i>Obrázek 8: Vizualizace centroidů nalezených algoritmem K-means
zkombinovaná s&nbsp;původními vstupními body.</i></p>



<p><a name="k13"></a></p>
<h2 id="k13">13. Výpočet clusterů</h2>

<p>Pro výpočet clusterů, tedy pro rozřazení bodů do jednotlivých clusterů, se
nepoužívá funkce <strong>kmeans_plusplus</strong>, protože ta
&bdquo;pouze&ldquo; nalezne centroidy. Musíme namísto ní použít nepatrně
složitější způsob. Nejprve zkonstruujeme instanci třídy
<strong>KMeans</strong>, které je opět nutné předat očekávaný počet clusterů.
Následně výslednému objektu předáme vstupní body a zahájíme výpočet pro
nalezení clusterů metodou <strong>fit</strong>:</p>

<pre>
<i># clustering</i>
kmeans = KMeans(n_clusters=6, random_state=0, n_init="auto").fit(samples)
</pre>

<p>Objekt, který získáme po dokončení metody <strong>fit</strong>, obsahuje
mj.&nbsp;i dvojici atributů nazvaných <strong>labels_</strong> a
<strong>centers_</strong>. V&nbsp;prvním z&nbsp;těchto atributů jsou uloženy
indexy clusterů (číslují se od jedničky) pro všechny vstupní body (tedy
například index 3 na pozici <i>n</i> znamená, že bod <i>n</i> patří ke clusteru
číslo 3). A druhý atribut <strong>centers_</strong> obsahuje souřadnice
centroidů.</p>

<p>Oba atributy si necháme vypočítat a vypsat následujícím skriptem:</p>

<pre>
from sklearn.cluster import KMeans
from sklearn.datasets import make_blobs
&nbsp;
<i># testovací data</i>
n_samples = 1000
&nbsp;
<i># počet oblastí, kam se budou data sdružovat</i>
n_components = 6
&nbsp;
samples, labels = make_blobs(
    n_samples=n_samples, centers=n_components, cluster_std=0.60, random_state=0
)
&nbsp;
samples = samples[:, ::-1]
&nbsp;
<i># clustering</i>
kmeans = <strong>KMeans(n_clusters=6, random_state=0, n_init="auto").fit(samples)</strong>
&nbsp;
print("Labels:")
print(<strong>kmeans.labels_</strong>)
print()
&nbsp;
print("Centroids:")
print(<strong>kmeans.cluster_centers_</strong>)
</pre>

<p>Výsledky získané po spuštění skriptu:</p>

<pre>
Labels:
[4 1 0 5 4 2 4 0 1 2 3 3 4 0 3 0 1 3 3 4 3 3 0 3 3 4 1 2 1 2 0 2 2 5 3 4 1
 4 3 4 3 1 2 1 4 0 1 2 5 5 2 0 1 2 2 2 5 0 1 3 3 4 0 4 3 5 2 3 5 5 1 3 2 4
 4 4 1 3 3 4 4 4 3 5 0 5 4 0 4 4 5 3 1 1 0 2 5 4 3 3 1 5 0 5 3 0 3 5 0 1 2
 1 2 0 2 2 2 3 2 5 3 3 3 5 3 4 2 4 1 2 2 1 5 3 0 4 1 5 0 3 1 1 5 2 2 3 0 3
 3 5 3 4 4 4 2 0 5 3 4 2 0 3 2 4 5 3 0 3 4 0 3 4 3 1 4 0 4 3 1 3 3 3 5 2 4
 3 5 2 0 2 2 5 0 4 1 0 5 1 3 5 3 2 3 2 2 5 2 1 0 0 0 4 1 0 2 4 4 1 5 0 0 4
 2 3 0 3 1 1 2 0 5 1 5 2 3 1 0 4 2 3 0 4 0 0 1 2 1 0 3 0 0 2 0 3 2 4 1 4 5
 3 4 5 1 3 5 4 1 3 2 3 0 1 3 5 1 0 4 3 1 4 4 4 0 5 4 4 4 1 4 1 0 5 2 0 0 1
 4 4 3 1 4 1 5 0 4 2 2 0 0 0 4 0 2 4 5 2 1 0 3 5 3 3 3 4 0 4 3 1 2 3 4 3 2
 0 2 4 3 4 5 1 4 2 0 2 4 2 1 2 3 5 3 1 3 5 0 2 5 5 1 4 0 4 0 1 0 3 4 2 2 2
 0 3 3 0 5 4 2 1 4 1 3 4 0 2 5 4 5 1 0 4 4 4 3 5 5 2 0 5 4 1 2 4 2 4 5 4 2
 5 1 5 0 3 5 4 3 4 2 1 4 3 3 3 2 1 3 2 2 1 0 3 4 0 5 3 4 4 2 4 0 1 2 0 0 2
 2 4 5 4 0 1 3 5 4 5 4 1 2 2 0 5 3 3 3 1 5 3 4 1 5 2 0 4 0 0 2 5 0 2 4 5 5
 1 4 5 3 1 3 0 0 3 3 0 1 2 0 4 3 0 0 4 2 2 4 1 4 2 5 2 2 4 2 0 2 0 5 3 1 5
 1 0 4 4 5 5 1 2 4 0 1 3 3 1 5 0 5 3 2 2 2 1 2 2 1 2 3 4 5 5 0 0 3 5 3 1 2
 1 0 2 3 4 4 4 0 1 2 0 0 0 4 2 2 0 0 5 2 2 2 4 4 0 2 4 2 5 5 0 5 0 3 5 1 4
 2 0 3 3 1 2 3 1 0 1 3 1 2 1 1 4 4 5 5 3 2 0 1 1 0 5 3 1 1 3 5 2 2 3 0 0 2
 4 4 5 1 4 4 5 3 1 4 4 4 4 3 3 5 5 5 2 2 5 3 0 3 3 3 4 1 1 0 2 0 4 1 3 2 4
 3 1 1 4 3 5 2 2 3 2 2 4 3 1 2 5 0 5 4 5 1 3 5 4 0 0 0 2 2 0 1 1 4 0 1 4 5
 5 0 0 5 1 2 3 0 1 5 1 3 5 1 5 4 0 0 0 0 5 2 4 0 2 3 1 5 5 1 5 1 5 3 4 0 5
 2 3 3 1 0 3 0 5 2 0 3 4 2 5 1 1 5 1 5 0 3 2 5 2 0 2 5 5 0 5 3 1 1 5 5 1 4
 3 5 5 5 1 3 5 0 5 0 4 4 5 5 3 1 1 3 5 4 1 0 5 1 0 4 1 3 4 3 1 1 4 5 5 2 5
 1 1 3 0 4 3 0 0 2 0 2 1 0 2 1 0 1 0 1 2 1 5 0 2 0 0 0 5 1 5 2 2 3 2 5 5 4
 5 2 2 2 1 2 4 2 1 4 5 0 5 4 0 1 0 1 3 1 5 1 0 1 0 3 4 1 5 4 5 2 5 1 1 5 5
 0 3 5 2 1 3 0 2 1 5 3 4 5 1 4 4 0 0 3 0 2 4 3 3 5 2 3 5 1 1 3 1 0 5 1 5 3
 0 1 2 3 1 5 3 5 0 3 0 0 5 3 1 5 4 0 2 1 2 5 5 5 2 3 3 4 4 4 2 2 5 3 4 1 5
 0 4 1 4 2 3 2 1 1 4 4 3 1 2 3 4 2 2 2 5 2 5 0 2 5 2 5 1 5 4 1 1 4 1 1 5 1
 0]
&nbsp;
Centroids:
[[ 0.81049056  1.983196  ]
 [-2.23667661  9.21962615]
 [ 7.77287664 -1.16476714]
 [ 4.33349676  0.90584235]
 [ 0.53153869  5.83908411]
 [ 2.92830112 -1.52190078]]
</pre>



<p><a name="k14"></a></p>
<h2 id="k14">14. Vizualizace clusterů</h2>

<p>Nyní již máme k&nbsp;dispozici všechny potřebné typy informací:</p>

<ol>
<li>Souřadnice vstupních bodů</li>
<li>Souřadnice centroidů šesti clusterů (viz <a href="#k13">předchozí kapitolu</a>)</li>
<li>Určení, do kterého clusteru patří každý vstupní body (taktéž viz <a href="#k13">předchozí kapitolu</a>)</li>
</ol>

<p>Tyto tři typy informací nyní zkombinujeme a necháme si je zobrazit na
jediném grafu. Jak se zobrazují souřadnice bodů i souřadnice centroidů již
známe. Dokonce již víme, jak můžeme body obarvit. Ovšem tentokrát je budeme
obarvovat na základě toho, do kterého clusteru byly body přiřazeny algoritmem
<i>K-means</i> (budeme tedy ignorovat vektor <strong>labels</strong>). Pojďme
na to:</p>

<pre>
<i># budeme provádět vykreslování de facto standardní knihovnou Matplotlib</i>
import matplotlib.pyplot as plt
&nbsp;
<i># třída s implementací algoritmu pro clustering</i>
from sklearn.cluster import KMeans
&nbsp;
<i># import funkce, která dokáže vygenerovat množinu bodů v rovině sdružených do oblastí</i>
from sklearn.datasets import make_blobs
&nbsp;
<i># testovací data</i>
n_samples = 1000
&nbsp;
<i># počet oblastí, kam se budou data sdružovat</i>
n_components = 6
&nbsp;
<i># vygenerovat množinu bodů v rovině sdružených do oblastí</i>
samples, labels = make_blobs(
    n_samples=n_samples, centers=n_components, cluster_std=0.60, random_state=0
)
&nbsp;
samples = samples[:, ::-1]
&nbsp;
plt.figure(1)
colors = ["#4444cc", "#44bb44", "#cc4444", "#cccc44", "#44cccc", "#cc44cc"]
&nbsp;
<i># clustering</i>
kmeans = KMeans(n_clusters=6, random_state=0, n_init="auto").fit(samples)
&nbsp;
<i>#print(kmeans.labels_)</i>
<i>#print(kmeans.cluster_centers_)</i>
&nbsp;
<i># vykreslení bodů s jejich přiřazením ke clusteru</i>
for i, color in enumerate(colors):
    selector = kmeans.labels_ == i
    plt.scatter(samples[selector, 0], samples[selector, 1], c=color, marker=".", s=1)
&nbsp;
plt.scatter(kmeans.cluster_centers_[:, 0], kmeans.cluster_centers_[:, 1], c="red", s=50)
plt.title("K-Means++")
&nbsp;
<i># uložení grafu do souboru</i>
plt.savefig("k_means_3.png")
&nbsp;
<i># vykreslení na obrazovku</i>
plt.show()
</pre>

<p>Výsledek vypadá korektně:</p>

<img src="https://i.iinfo.cz/images/593/scikit-learn-2-6.webp" class="image-1111751" width="640" height="480" alt="&#160;" title="Autor: tisnik, podle licence: &lt;a href=&quot;http://en.wikipedia.org/wiki/Rights_Managed&quot;&gt;Rights Managed&lt;/a&gt;" />
<p><i>Obrázek 9: Vstupní body, centroidy i rozdělení bodů do jednotlivých
clusterů; vše na jediném grafu.</i></p>



<p><a name="k15"></a></p>
<h2 id="k15">15. Clustering pro větší počet bodů v&nbsp;případě, kdy se oblasti centroidů překrývají</h2>

<p>Změnou hodnoty směrodatné odchylky (viz zvýrazněný parametr funkce
<strong>make_blobs</strong>) lze dosáhnout různé hustoty bodů, které budou
posléze rozdělovány do clusterů (body mohou být více seskupeny okolo centra či
naopak mohou být rozmístěny do větší plochy prostoru). Pokusme se tedy
směrodatnou odchylku zvětšit, což by mělo vést k&nbsp;tomu, že se body rozmístí
dále od center a navíc se budou jednotlivé oblasti centroidů více překrývat.
Tím lépe pochopíme činnosti algoritmu <i>K-means</i>:</p>

<pre>
<i># budeme provádět vykreslování de facto standardní knihovnou Matplotlib</i>
import matplotlib.pyplot as plt
&nbsp;
<i># třída s implementací algoritmu pro clustering</i>
from sklearn.cluster import KMeans
&nbsp;
<i># import funkce, která dokáže vygenerovat množinu bodů v rovině sdružených do oblastí</i>
from sklearn.datasets import make_blobs
&nbsp;
<i># testovací data</i>
n_samples = 10000
&nbsp;
<i># počet oblastí, kam se budou data sdružovat</i>
n_components = 6
&nbsp;
<i># vygenerovat množinu bodů v rovině sdružených do oblastí</i>
samples, labels = make_blobs(
    n_samples=n_samples, centers=n_components, <strong>cluster_std=2.00</strong>, random_state=0
)
&nbsp;
samples = samples[:, ::-1]
&nbsp;
plt.figure(1)
colors = ["#4444cc", "#44bb44", "#cc4444", "#cccc44", "#44cccc", "#cc44cc"]
&nbsp;
<i># clustering</i>
kmeans = KMeans(n_clusters=6, random_state=0, n_init="auto").fit(samples)
&nbsp;
<i>#print(kmeans.labels_)</i>
<i>#print(kmeans.cluster_centers_)</i>
&nbsp;
<i># vykreslení bodů s jejich přiřazením ke clusteru</i>
for i, color in enumerate(colors):
    selector = kmeans.labels_ == i
    plt.scatter(samples[selector, 0], samples[selector, 1], c=color, marker=".", s=1)
&nbsp;
plt.scatter(kmeans.cluster_centers_[:, 0], kmeans.cluster_centers_[:, 1], c="red", s=50)
plt.title("K-Means++")
&nbsp;
<i># uložení grafu do souboru</i>
plt.savefig("k_means_4.png")
&nbsp;
<i># vykreslení na obrazovku</i>
plt.show()
</pre>

<p>Na výsledném grafu jsou patrné hranice mezi clustery a výsledek (nikoli
náhodou!) připomíná Voronoiův diagram:</p>

<img src="https://i.iinfo.cz/images/593/scikit-learn-2-7.webp" class="image-1111752" width="640" height="480" alt="&#160;" title="Autor: tisnik, podle licence: &lt;a href=&quot;http://en.wikipedia.org/wiki/Rights_Managed&quot;&gt;Rights Managed&lt;/a&gt;" />
<p><i>Obrázek 10: Výsledek clusteringu pro překrývající se oblasti centroidů.</i></p>



<p><a name="k16"></a></p>
<h2 id="k16">16. Pokus o nalezení clusterů v&nbsp;náhodných datech</h2>

<p>Pro zajímavost se podívejme na to, jak bude shluková analýza provedená
algoritmem K-means provedena na náhodných datech získaných funkcí
<strong>numpy.random.rand</strong> namísto funkce
<strong>sklearn.datasets.make_blobs</strong>. Upravíme tedy pouze jediný řádek
ve skriptu a budeme vyžadovat rozdělení bodů do šesti clusterů:</p>

<pre>
<i># budeme provádět vykreslování de facto standardní knihovnou Matplotlib</i>
import matplotlib.pyplot as plt
&nbsp;
from sklearn.cluster import KMeans
import numpy as np
&nbsp;
<i># testovací data</i>
n_samples = 10000
&nbsp;
<i># počet oblastí, kam se budou data sdružovat</i>
n_components = 6
&nbsp;
samples = np.random.rand(n_samples, 2)
&nbsp;
samples = samples[:, ::-1]
&nbsp;
plt.figure(1)
colors = ["#4444cc", "#44bb44", "#cc4444", "#cccc44", "#44cccc", "#cc44cc"]
&nbsp;
<i># clustering</i>
kmeans = KMeans(n_clusters=6, random_state=0, n_init="auto").fit(samples)
&nbsp;
<i>#print(kmeans.labels_)</i>
<i>#print(kmeans.cluster_centers_)</i>
&nbsp;
<i># vykreslení bodů s jejich přiřazením ke clusteru</i>
for i, color in enumerate(colors):
    selector = kmeans.labels_ == i
    plt.scatter(samples[selector, 0], samples[selector, 1], c=color, marker=".", s=1)
&nbsp;
plt.scatter(kmeans.cluster_centers_[:, 0], kmeans.cluster_centers_[:, 1], c="red", s=50)
plt.title("K-Means++")
&nbsp;
<i># uložení grafu do souboru</i>
plt.savefig(f"k_means_5.png")
&nbsp;
<i># vykreslení na obrazovku</i>
plt.show()
</pre>

<p>A takto bude vypadat výsledek:</p>

<img src="https://i.iinfo.cz/images/593/scikit-learn-2-8.webp" class="image-1111753" width="640" height="480" alt="&#160;" title="Autor: tisnik, podle licence: &lt;a href=&quot;http://en.wikipedia.org/wiki/Rights_Managed&quot;&gt;Rights Managed&lt;/a&gt;" />
<p><i>Obrázek 11: Výsledek shlukové analýzy náhodných dat.</i></p>



<p><a name="k17"></a></p>
<h2 id="k17">17. Limity standardního algoritmu K-means</h2>

<p>Algoritmus <i>K-means</i> byl sice v&nbsp;dnešních demonstračních příkladech
(až na příklad poslední) úspěšný, což ovšem neznamená, že je tento algoritmus
použitelný pro všechny myslitelné účely. Například můžeme předpokládat (a
příště si to ověříme), že nedokáže rozdělit hvězdy ve <a href="#k02">výše
zmíněném</a> HR diagramu do logických skupin, tedy do hvězd patřících do hlavní
posloupnosti atd. K&nbsp;těmto účelům byly navrženy odlišné algoritmy shlukové
analýzy a jedním z&nbsp;předpokladů úspěšné datové analýzy je tyto algoritmy
znát (jménem a použitím, ne interní implementaci) a vybrat si ten správný.</p>



<p><a name="k18"></a></p>
<h2 id="k18">18. Obsah navazujícího článku</h2>

<p>V&nbsp;navazujícím článku si nejprve ukážeme některé meze algoritmu K-means
a posléze se budeme zabývat dalšími vybranými algoritmy, které dokážou provádět
shlukové analýzy. Pro otestování chování těchto algoritmů použijeme další
funkce pro vygenerování bodů v&nbsp;pseudonáhodných pozicích, tedy funkce
obdobné dnes využité funkci <strong>make_blobs</strong>.</p>



<p><a name="k19"></a></p>
<h2 id="k19">19. Repositář s&nbsp;demonstračními příklady</h2>

<p>Všechny demonstrační příklady využívající knihovnu Scikit-learn, které jsme
si popsali <a
href="https://www.root.cz/clanky/rozpoznavani-obrazku-knihovnou-scikit-learn-prvni-kroky/">minule</a>
i dnes, lze nalézt v&nbsp;repositáři <a
href="https://github.com/tisnik/most-popular-python-libs">https://github.com/tisnik/most-popular-python-libs</a>.
Následují odkazy na jednotlivé příklady i na (Jupyter) diáře s&nbsp;postupem
výpočtů a analýz:</p>

<table>
<tr><th>#<th>Příklad</th><th>Stručný popis</th><th>Adresa příkladu</th></tr></i>
<tr><td> 1</td><td>01_show_matrix.py</td><td>kooperace mezi knihovnami Matplotlib a NumPy: vizualizace obsahu 2D matice</td><td><a href="https://github.com/tisnik/most-popular-python-libs/blob/master/sklearn/01_show_matrix.py">https://github.com/tisnik/most-popular-python-libs/blob/master/sklearn/01_show_matrix.py</a></td></tr>
<tr><td> 2</td><td>02_get_digits.py</td><td>datová množina obsahující naskenované ručně napsané číslice</td><td><a href="https://github.com/tisnik/most-popular-python-libs/blob/master/sklearn/02_get_digits.py">https://github.com/tisnik/most-popular-python-libs/blob/master/sklearn/02_get_digits.py</a></td></tr>
<tr><td> 3</td><td>03_get_features.py</td><td>další atributy datové množiny, které použijeme při trénování</td><td><a href="https://github.com/tisnik/most-popular-python-libs/blob/master/sklearn/03_get_features.py">https://github.com/tisnik/most-popular-python-libs/blob/master/sklearn/03_get_features.py</a></td></tr>
<tr><td> 4</td><td>04_get_images.py</td><td>přečtení a následné vykreslení jednotlivých ručně nakreslených číslic</td><td><a href="https://github.com/tisnik/most-popular-python-libs/blob/master/sklearn/04_get_images.py">https://github.com/tisnik/most-popular-python-libs/blob/master/sklearn/04_get_images.py</a></td></tr>
<tr><td> 5</td><td>05_show_grayscale_matrix.py</td><td>odstranění umělé aplikované barvové palety (obrázky ve stupních šedi)</td><td><a href="https://github.com/tisnik/most-popular-python-libs/blob/master/sklearn/05_show_grayscale_matrix.py">https://github.com/tisnik/most-popular-python-libs/blob/master/sklearn/05_show_grayscale_matrix.py</a></td></tr>
<tr><td> 6</td><td>06_grayscale_images.py</td><td>vykreslení ručně nakreslených číslic ve formě obrázků ve stupních šedi</td><td><a href="https://github.com/tisnik/most-popular-python-libs/blob/master/sklearn/06_grayscale_images.py">https://github.com/tisnik/most-popular-python-libs/blob/master/sklearn/06_grayscale_images.py</a></td></tr>
<tr><td> 7</td><td>07_multiplot.py</td><td>rozdělení plochy grafu do oblastí; vykreslení více obrázků do jediného grafu</td><td><a href="https://github.com/tisnik/most-popular-python-libs/blob/master/sklearn/07_multiplot.py">https://github.com/tisnik/most-popular-python-libs/blob/master/sklearn/07_multiplot.py</a></td></tr>
<tr><td> 8</td><td>08_model_preperation_1.py</td><td>obrázky s&nbsp;jejich ohodnocením</td><td><a href="https://github.com/tisnik/most-popular-python-libs/blob/master/sklearn/08_model_preperation_1.py">https://github.com/tisnik/most-popular-python-libs/blob/master/sklearn/08_model_preperation_1.py</a></td></tr>
<tr><td> 9</td><td>09_training_set.py</td><td>příprava dat pro trénink</td><td><a href="https://github.com/tisnik/most-popular-python-libs/blob/master/sklearn/09_training_set.py">https://github.com/tisnik/most-popular-python-libs/blob/master/sklearn/09_training_set.py</a></td></tr>
<tr><td>10</td><td>10_classification.py</td><td>klasifikace obrázků</td><td><a href="https://github.com/tisnik/most-popular-python-libs/blob/master/sklearn/10_classification.py">https://github.com/tisnik/most-popular-python-libs/blob/master/sklearn/10_classification.py</a></td></tr>
<tr><td>11</td><td>11_results.py</td><td>vykreslení obrázků společně s&nbsp;jejich klasifikací</td><td><a href="https://github.com/tisnik/most-popular-python-libs/blob/master/sklearn/11_results.py">https://github.com/tisnik/most-popular-python-libs/blob/master/sklearn/11_results.py</a></td></tr>
<tr><td>12</td><td>12_change_training_set.py</td><td>změna poměru rozdělení dat na tréninkovou a testovací množinu</td><td><a href="https://github.com/tisnik/most-popular-python-libs/blob/master/sklearn/12_change_training_set.py">https://github.com/tisnik/most-popular-python-libs/blob/master/sklearn/12_change_training_set.py</a></td></tr>
<tr><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td></tr>
<tr><td>13</td><td>13_blobs.py</td><td>použití funkce <strong>make_blobs</strong> pro vygenerování sady bodů v&nbsp;rovině sdružených do oblastí</td><td><a href="https://github.com/tisnik/most-popular-python-libs/blob/master/sklearn/13_blobs.py">https://github.com/tisnik/most-popular-python-libs/blob/master/sklearn/13_blobs.py</a></td></tr>
<tr><td>14</td><td>14_swap_coords.py</td><td>úprava předchozího příkladu: prohození souřadnic na osách</td><td><a href="https://github.com/tisnik/most-popular-python-libs/blob/master/sklearn/14_swap_coords.py">https://github.com/tisnik/most-popular-python-libs/blob/master/sklearn/14_swap_coords.py</a></td></tr>
<tr><td>15</td><td>15_blobs_scatter_plot.py</td><td>základní podoba bodového diagramu (<i>scatter plot</i>)</td><td><a href="https://github.com/tisnik/most-popular-python-libs/blob/master/sklearn/15_blobs_scatter_plot.py">https://github.com/tisnik/most-popular-python-libs/blob/master/sklearn/15_blobs_scatter_plot.py</a></td></tr>
<tr><td>16</td><td>16_blobs_scatter_plot.py</td><td>úprava bodového diagramu při zobrazení většího množství bodů</td><td><a href="https://github.com/tisnik/most-popular-python-libs/blob/master/sklearn/16_blobs_scatter_plot.py">https://github.com/tisnik/most-popular-python-libs/blob/master/sklearn/16_blobs_scatter_plot.py</a></td></tr>
<tr><td>17</td><td>17_colorized_blobs.py</td><td>obarvení bodů podle oblastí</td><td><a href="https://github.com/tisnik/most-popular-python-libs/blob/master/sklearn/17_colorized_blobs.py">https://github.com/tisnik/most-popular-python-libs/blob/master/sklearn/17_colorized_blobs.py</a></td></tr>
<tr><td>18</td><td>18_k-means.py</td><td>základní použití algoritmu K-means pro clustering</td><td><a href="https://github.com/tisnik/most-popular-python-libs/blob/master/sklearn/18_k-means.py">https://github.com/tisnik/most-popular-python-libs/blob/master/sklearn/18_k-means.py</a></td></tr>
<tr><td>19</td><td>19_combination.py</td><td>zobrazení centroidů společně s&nbsp;původními body</td><td><a href="https://github.com/tisnik/most-popular-python-libs/blob/master/sklearn/19_combination.py">https://github.com/tisnik/most-popular-python-libs/blob/master/sklearn/19_combination.py</a></td></tr>
<tr><td>20</td><td>20_combinations.py</td><td>vizualizace clusteringu původní množiny bodů</td><td><a href="https://github.com/tisnik/most-popular-python-libs/blob/master/sklearn/20_combinations.py">https://github.com/tisnik/most-popular-python-libs/blob/master/sklearn/20_combinations.py</a></td></tr>
<tr><td>21</td><td>21_other_settings.py</td><td>vizualizace clusteringu původní množiny bodů pro odlišnou množinu</td><td><a href="https://github.com/tisnik/most-popular-python-libs/blob/master/sklearn/21_other_settings.py">https://github.com/tisnik/most-popular-python-libs/blob/master/sklearn/21_other_settings.py</a></td></tr>
<tr><td>22</td><td>22_random_points.py</td><td>clustering pro náhodná data</td><td><a href="https://github.com/tisnik/most-popular-python-libs/blob/master/sklearn/22_random_points.py">https://github.com/tisnik/most-popular-python-libs/blob/master/sklearn/22_random_points.py</a></td></tr>
<tr><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td></tr>
<tr><td>23</td><td>pyproject.toml</td><td>projektový soubor (pro PDM) se všemi závislostmi</td><td><a href="https://github.com/tisnik/most-popular-python-libs/blob/master/sklearn/pyproject.toml">https://github.com/tisnik/most-popular-python-libs/blob/master/sklearn/pyproject.toml</a></td></tr>
<tr><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td></tr>
<tr><td>24</td><td>pdm.lock</td><td>lock soubor s&nbsp;konkrétními verzemi všech přímých i tranzitivních závislostí</td><td><a href="https://github.com/tisnik/most-popular-python-libs/blob/master/sklearn/pdm.lock">https://github.com/tisnik/most-popular-python-libs/blob/master/sklearn/pdm.lock</a></td></tr>
<tr><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td></tr>
<tr><td>25</td><td>Rozpoznání_obrazu_scikit-learn.ipynb</td><td>Jupyter notebook s&nbsp;celým postupem</td><td><a href="https://github.com/tisnik/most-popular-python-libs/blob/master/sklearn/Rozpoznání_obrazu_scikit-learn.ipynb">https://github.com/tisnik/most-popular-python-libs/blob/master/sklearn/Rozpoznání_obrazu_scikit-learn.ipynb</a></td></tr>
</table>



<p><a name="k20"></a></p>
<h2 id="k20">20. Odkazy na Internetu</h2>

<ol>

<li>scikit-learn: Machine Learning in Python<br />
<a href="https://scikit-learn.org/stable/index.html">https://scikit-learn.org/stable/index.html</a>
</li>

<li>Sklearn-pandas<br />
<a href="https://github.com/scikit-learn-contrib/sklearn-pandas">https://github.com/scikit-learn-contrib/sklearn-pandas</a>
</li>

<li>sklearn-xarray<br />
<a href="https://github.com/phausamann/sklearn-xarray/">https://github.com/phausamann/sklearn-xarray/</a>
</li>

<li>Clustering<br />
<a href="https://scikit-learn.org/stable/modules/clustering.html">https://scikit-learn.org/stable/modules/clustering.html</a>
</li>

<li>Cluster analysis (Wikipedia)<br />
<a href="https://en.wikipedia.org/wiki/Cluster_analysis">https://en.wikipedia.org/wiki/Cluster_analysis</a>
</li>

<li>Shluková analýza (Wikipedia)<br />
<a href="https://cs.wikipedia.org/wiki/Shlukov%C3%A1_anal%C3%BDza">https://cs.wikipedia.org/wiki/Shlukov%C3%A1_anal%C3%BDza</a>
</li>

<li>K-means<br />
<a href="https://cs.wikipedia.org/wiki/K-means">https://cs.wikipedia.org/wiki/K-means</a>
</li>

<li>k-means clustering<br />
<a href="https://en.wikipedia.org/wiki/K-means_clustering">https://en.wikipedia.org/wiki/K-means_clustering</a>
</li>

<li>Hertzsprungův–Russellův diagram<br />
<a href="https://cs.wikipedia.org/wiki/Hertzsprung%C5%AFv%E2%80%93Russell%C5%AFv_diagram">https://cs.wikipedia.org/wiki/Hertzsprung%C5%AFv%E2%80%93Russell%C5%AFv_diagram</a>
</li>

<li>Using Machine Learning in an HR Diagram<br />
<a href="https://cocalc.com/share/public_paths/08b6e03583cbdef3cdb9813a54ec68ff773c747f">https://cocalc.com/share/public_paths/08b6e03583cbdef3cdb9813a54ec68ff773c747f</a>
</li>

<li>Gaia H-R diagrams: Querying Gaia data for one million nearby stars<br />
<a href="https://vlas.dev/post/gaia-dr2-hrd/">https://vlas.dev/post/gaia-dr2-hrd/</a>
</li>

<li>The Hertzsprung–Russell diagram<br />
<a href="https://scipython.com/book2/chapter-9-data-analysis-with-pandas/problems/p92/the-hertzsprung-russell-diagram/">https://scipython.com/book2/chapter-9-data-analysis-with-pandas/problems/p92/the-hertzsprung-russell-diagram/</a>
</li>

<li>Animated Hertzsprung-Russell Diagram with 119,614 datapoints<br />
<a href="https://github.com/zonination/h-r-diagram">https://github.com/zonination/h-r-diagram</a>
</li>

<li>Neuraxle Pipelines<br />
<a href="https://github.com/Neuraxio/Neuraxle">https://github.com/Neuraxio/Neuraxle</a>
</li>

<li>scikit-learn: Getting Started<br />
<a href="https://scikit-learn.org/stable/getting_started.html">https://scikit-learn.org/stable/getting_started.html</a>
</li>

<li>Support Vector Machines<br />
<a href="https://scikit-learn.org/stable/modules/svm.html">https://scikit-learn.org/stable/modules/svm.html</a>
</li>

<li>Use Deep Learning to Detect Programming Languages<br />
<a href="http://searene.me/2017/11/26/use-neural-networks-to-detect-programming-languages/">http://searene.me/2017/11/26/use-neural-networks-to-detect-programming-languages/</a>
</li>

<li>Natural-language processing<br />
<a href="https://en.wikipedia.org/wiki/Natural-language_processing">https://en.wikipedia.org/wiki/Natural-language_processing</a>
</li>

<li>THE MNIST DATABASE of handwritten digits<br />
<a href="http://yann.lecun.com/exdb/mnist/">http://yann.lecun.com/exdb/mnist/</a>
</li>

<li>MNIST database (Wikipedia)<br />
<a href="https://en.wikipedia.org/wiki/MNIST_database">https://en.wikipedia.org/wiki/MNIST_database</a>
</li>

<li>MNIST For ML Beginners<br />
<a href="https://www.tensorflow.org/get_started/mnist/beginners">https://www.tensorflow.org/get_started/mnist/beginners</a>
</li>

<li>Stránka projektu Torch<br />
<a href="http://torch.ch/">http://torch.ch/</a>
</li>

<li>Torch: Serialization<br />
<a href="https://github.com/torch/torch7/blob/master/doc/serialization.md">https://github.com/torch/torch7/blob/master/doc/serialization.md</a>
</li>

<li>Torch: modul image<br />
<a href="https://github.com/torch/image/blob/master/README.md">https://github.com/torch/image/blob/master/README.md</a>
</li>

<li>Data pro neuronové sítě<br />
<a href="http://archive.ics.uci.edu/ml/index.php">http://archive.ics.uci.edu/ml/index.php</a>
</li>

<li>Torch na GitHubu (několik repositářů)<br />
<a href="https://github.com/torch">https://github.com/torch</a>
</li>

<li>Torch (machine learning), Wikipedia<br />
<a href="https://en.wikipedia.org/wiki/Torch_%28machine_learning%29">https://en.wikipedia.org/wiki/Torch_%28machine_learning%29</a>
</li>

<li>Torch Package Reference Manual<br />
<a href="https://github.com/torch/torch7/blob/master/README.md">https://github.com/torch/torch7/blob/master/README.md</a>
</li>

<li>Torch Cheatsheet<br />
<a href="https://github.com/torch/torch7/wiki/Cheatsheet">https://github.com/torch/torch7/wiki/Cheatsheet</a>
</li>

<li>Neural network containres (Torch)<br />
<a href="https://github.com/torch/nn/blob/master/doc/containers.md">https://github.com/torch/nn/blob/master/doc/containers.md</a>
</li>

<li>Simple layers<br />
<a href="https://github.com/torch/nn/blob/master/doc/simple.md#nn.Linear">https://github.com/torch/nn/blob/master/doc/simple.md#nn.Linear</a>
</li>

<li>Transfer Function Layers<br />
<a href="https://github.com/torch/nn/blob/master/doc/transfer.md#nn.transfer.dok">https://github.com/torch/nn/blob/master/doc/transfer.md#nn.transfer.dok</a>
</li>

<li>Feedforward neural network<br />
<a href="https://en.wikipedia.org/wiki/Feedforward_neural_network">https://en.wikipedia.org/wiki/Feedforward_neural_network</a>
</li>

<li>Biologické algoritmy (4) - Neuronové sítě<br />
<a href="https://www.root.cz/clanky/biologicke-algoritmy-4-neuronove-site/">https://www.root.cz/clanky/biologicke-algoritmy-4-neuronove-site/</a>
</li>

<li>Biologické algoritmy (5) - Neuronové sítě<br />
<a href="https://www.root.cz/clanky/biologicke-algoritmy-5-neuronove-site/">https://www.root.cz/clanky/biologicke-algoritmy-5-neuronove-site/</a>
</li>

<li>Umělá neuronová síť (Wikipedia)<br />
<a href="https://cs.wikipedia.org/wiki/Um%C4%9Bl%C3%A1_neuronov%C3%A1_s%C3%AD%C5%A5">https://cs.wikipedia.org/wiki/Um%C4%9Bl%C3%A1_neuronov%C3%A1_s%C3%AD%C5%A5</a>
</li>

<li>PyTorch<br />
<a href="http://pytorch.org/">http://pytorch.org/</a>
</li>

<li>JupyterLite na PyPi<br />
<a href="https://pypi.org/project/jupyterlite/">https://pypi.org/project/jupyterlite/</a>
</li>

<li>JupyterLite na GitHubu<br />
<a href="https://github.com/jupyterlite/jupyterlite">https://github.com/jupyterlite/jupyterlite</a>
</li>

<li>Dokumentace k&nbsp;projektu JupyterLite<br />
<a href="https://github.com/jupyterlite/jupyterlite">https://github.com/jupyterlite/jupyterlite</a>
</li>

<li>Matplotlib Home Page<br />
<a href="http://matplotlib.org/">http://matplotlib.org/</a>
</li>

<li>Matplotlib (Wikipedia)<br />
<a href="https://en.wikipedia.org/wiki/Matplotlib">https://en.wikipedia.org/wiki/Matplotlib</a>
</li>

<li>Popis barvových map modulu matplotlib.cm<br />
<a href="https://gist.github.com/endolith/2719900#id7">https://gist.github.com/endolith/2719900#id7</a>
</li>

<li>Ukázky (palety) barvových map modulu matplotlib.cm<br />
<a href="http://matplotlib.org/examples/color/colormaps_reference.html">http://matplotlib.org/examples/color/colormaps_reference.html</a>
</li>

<li>Galerie grafů vytvořených v&nbsp;Matplotlibu<br />
<a href="https://matplotlib.org/3.2.1/gallery/">https://matplotlib.org/3.2.1/gallery/</a>
</li>

</ol>



<p></p><p></p>
<p><small>Autor: <a href="http://www.fit.vutbr.cz/~tisnovpa">Pavel Tišnovský</a> &nbsp; 2023</small></p>
</body>
</html>

