<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
        "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html>
<head>
<title>Novinky představené v jazyku Julia verze 1.0</title>
<meta name="Author" content="Pavel Tisnovsky" />
<meta name="Generator" content="vim" />
<meta http-equiv="content-type" content="text/html; charset=utf-8" />
<style type="text/css">
         body {color:#000000; background:#ffffff;}
         h1  {font-family: arial, helvetica, sans-serif; color:#ffffff; background-color:#c00000; text-align:center; padding-left:1em}
         h2  {font-family: arial, helvetica, sans-serif; color:#ffffff; background-color:#0000c0; padding-left:1em; text-align:left}
         h3  {font-family: arial, helvetica, sans-serif; color:#000000; background-color:#c0c0c0; padding-left:1em; text-align:left}
         h4  {font-family: arial, helvetica, sans-serif; color:#000000; background-color:#e0e0e0; padding-left:1em; text-align:left}
         a   {font-family: arial, helvetica, sans-serif;}
         li  {font-family: arial, helvetica, sans-serif; color:#000000; text-align:justify; width:450px;}
         ol  {font-family: arial, helvetica, sans-serif; color:#000000; text-align:justify; width:450px;}
         ul  {font-family: arial, helvetica, sans-serif; color:#000000; text-align:justify; width:450px;}
         p   {font-family: arial, helvetica, sans-serif; color:#000000; text-align:justify;}
         pre {background:#e0e0e0}
</style>
</head>

<body>

<h1>Novinky představené v jazyku Julia verze 1.0</h1>

<h3>Pavel Tišnovský</h3>

<p></p>

<h1>Úvodník</h1>

<p>Před měsícem byla představena nová verze programovacího jazyka Julia. Autoři dali této verzi číslo 1.0, čímž naznačili, že došlo ke stabilizaci tohoto jazyka a že všechny nové vlastnosti budou s verzí 1.0 kompatibilní. Dnes si některé novinky představíme.</p>



<h2>Obsah</h2>

<p><a href="#k01">1. Novinky představené v&nbsp;jazyku Julia verze 1.0</a></p>
<p><a href="#k02">2. Instalace verze 1.0</a></p>
<p><a href="#k03">3. Otestování základní funkcionality nové verze</a></p>
<p><a href="#k04">4. Reprezentace chybějící hodnoty</a></p>
<p><a href="#k05">5. Deklarace nových operátorů</a></p>
<p><a href="#k06">6. Makro @enum a zápis hodnot v&nbsp;bloku</a></p>
<p><a href="#k07">7. Změna oblasti viditelnosti proměnných ve smyčce <strong>for</strong></a></p>
<p><a href="#k08">8. Použití klauzule <strong>outer</strong></a></p>
<p><a href="#k09">9. Nová makra pro logování</a></p>
<p><a href="#k10">10. Destructuring n-tic použitých pro předání parametrů do funkcí</a></p>
<p><a href="#k11">11. Pojmenované prvky v&nbsp;n-ticích</a></p>
<p><a href="#k12">12. Makro @isdefined</a></p>
<p><a href="#k13">13. Operátor ^ a celá záporná čísla reprezentující exponent</a></p>
<p><a href="#k14">14. Odlišná pravidla při interpolaci řetězců</a></p>
<p><a href="#k15">15. Implicitní spojení proměnné s&nbsp;řetězcovým literálem</a></p>
<p><a href="#k16">16. Hodnoty s&nbsp;plovoucí řádovou čárkou a &bdquo;tečkové&ldquo; operátory</a></p>
<p><a href="#k17">17. Přepis základních funkcí novým globálním symbolem se stejným jménem</a></p>
<p><a href="#k18">18. Pravděpodobně nezamýšlené změny v&nbsp;REPLu</a></p>
<p><a href="#k19">19. Proměnné, jejichž jména jsou tvořena podtržítky</a></p>
<p><a href="#k20">20. Odkazy na Internetu</a></p>



<p><a name="k01"></a></p>
<h2 id="k01">1. Novinky představené v&nbsp;jazyku Julia verze 1.0</h2>

<p>V&nbsp;dnešním článku se zaměříme na popis změn v&nbsp;jazyku Julia, které
nalezneme především ve verzi 1.0, s tím dovětkem, že některé novinky byly
představeny i ve verzi 0.7. Verze 0.7 je totiž taktéž nově vydaná, snaží se být
kompatibilní se staršími verzemi, ovšem některé příkazy zobrazují varování
&bdquo;deprecated&ldquo;, tj.&nbsp;informaci o tom, že již nebudou dále
podporovány. Ve verzi 1.0 už tyto vlastnosti nejsou podporovány vůbec.
V&nbsp;praxi to znamená, že je nejdříve vhodné přejít na verzi 0.7, v&nbsp;ní
si odladit vlastní skripty a aplikace (aby se nevypisovala varování) a teprve
poté přejít na verzi 1.0 (popř.&nbsp;mít lokálně nainstalovány obě verze).</p>

<p>Vydání verze 1.0 má spíše netechnické důvody: další změny v&nbsp;jazyku
zaváděné v&nbsp;budoucích verzích 1.1, 1.2 atd. totiž budou navrhovány takovým
způsobem, aby byly zpětně kompatibilní právě s&nbsp;verzí 1.0 (případné
nekompatibilní změny může přinést až verze 2.0, ta se však ještě neplánuje).
Doba relativně rychlého a možná i poněkud chaotického vývoje jazyka Julia je
tedy za námi, což je důležitá informace pro další využívání tohoto jazyka
v&nbsp;praxi.</p>

<p><div class="rs-tip-major">Poznámka: na druhou stranu bylo užitečné, že si
Julia prošla počátečním &bdquo;chaotickým&ldquo; vývojem, protože za šest let
vývoje bylo možné si vyzkoušet různé úpravy syntaxe a sémantiky, měnit chování
makrosystému atd.</div></p>



<p><a name="k02"></a></p>
<h2 id="k02">2. Instalace verze 1.0</h2>

<p>V&nbsp;mnoha Linuxových distribucích se ještě verze 1.0 programovacího
jazyka Julia <a href="https://pkgs.org/download/julia">nedostala do oficiálních
repositářů</a>. To si ostatně můžeme velmi snadno ověřit, například na <a
href="wikipedia.org/wiki/Fedora_(operating_system)#Releases">stále podporované
Fedoře 28</a> s&nbsp;využitím nástroje <strong>dnf</strong>. Povšimněte si, že
v&nbsp;této distribuci je k&nbsp;dispozici pouze verze 0.6.3, která ani zdaleka
neobsahuje všechny novinky uvedené ve verzi 0.7, natož ve verzi 1.0:</p>

<pre>
<strong>dnf info julia</strong>
&nbsp;
Last metadata expiration check: 1:29:20 ago on Thu 13 Sep 2018 06:44:42 AM EDT.
Available Packages
Name         : julia
Version      : <strong>0.6.3</strong>
Release      : 1.fc28
Arch         : x86_64
Size         : 13 M
Source       : julia-0.6.3-1.fc28.src.rpm
Repo         : updates
Summary      : High-level, high-performance dynamic language for technical
             : computing
             URL          : http://julialang.org/
             License      : MIT and LGPLv2+ and GPLv2+
</pre>

<p><div class="rs-tip-major">Poznámka: konkrétně pro Fedoru lze balíček získat
i alternativním způsobem <a
href="https://copr.fedorainfracloud.org/coprs/nalimilan/julia-nightlies/builds/">z&nbsp;copru</a>,
pokud vám nevadí používání nightly buildů.</div></p>

<p>To, že oficiální repositář distribuce ještě neobsahuje poslední verzi jazyka
Julia, nám však nemusí vadit v&nbsp;případě, že používáme jednu
z&nbsp;oficiálně podporovaných architektur, pro níž jsou již <a
href="https://julialang.org/downloads/">připraveny binární balíčky</a> i se
všemi potřebnými knihovnami (se všemi klady a zápory, které lokální instalace
všech takových knihoven přináší!). Instalace balíčku na architekturu x86-64 je
jednoduchá. Nejdříve si stáhneme příslušný tarball (archiv):</p>

<pre>
$ <strong>wget https://julialang-s3.julialang.org/bin/linux/x64/1.0/julia-1.0.0-linux-x86_64.tar.gz</strong>
&nbsp;
--2018-09-13 08:17:09--  https://julialang-s3.julialang.org/bin/linux/x64/1.0/julia-1.0.0-linux-x86_64.tar.gz
Connecting to julialang-s3.julialang.org (julialang-s3.julialang.org)|151.101.54.49|:443... connected.
HTTP request sent, awaiting response... 200 OK
Length: 88896624 (85M) [application/octet-stream]
Saving to: ‘julia-1.0.0-linux-x86_64.tar.gz’
&nbsp;
julia-1.0.0-linux-x 100%[===================&gt;]  84.78M  22.9MB/s    in 4.9s
&nbsp;
2018-09-13 08:17:14 (17.2 MB/s) - ‘julia-1.0.0-linux-x86_64.tar.gz’ saved [88896624/88896624]
</pre>

<p>A dále provedeme rozbalení archivu <a
href="https://www.xkcd.com/1168/">nástrojem tar</a>:</p>

<pre>
tar xvfz julia-1.0.0-linux-x86_64.tar.gz
</pre>

<p>Vznikne adresářová struktura uložená v&nbsp;podadresáři
&bdquo;~/julia-1.0.0&ldquo; a tudíž dostupná pouze pro aktuálně přihlášeného
uživatele (strom je zobrazen pouze do druhé úrovně):</p>

<pre>
julia-1.0.0
├── bin
│   └── julia
├── etc
│   └── julia
├── include
│   └── julia
├── lib
│   ├── julia
│   ├── libjulia.so -&gt; libjulia.so.1.0
│   ├── libjulia.so.1 -&gt; libjulia.so.1.0
│   └── libjulia.so.1.0
├── LICENSE.md
└── share
    ├── appdata
    ├── applications
    ├── doc
    ├── icons
    ├── julia
    └── man
</pre>

<p><div class="rs-tip-major">Poznámka: většina ukázek, s&nbsp;nimiž se
seznámíme v&nbsp;navazujících kapitolách, bude používat jednu nebo obě výše
uvedené verze jazyka Julia. Konkrétně se tedy bude jednat o starší verzi 0.6.3
nainstalovanou z&nbsp;oficiálních balíčků Fedory (28) a dále se bude jednat o
verzi 1.0.0 nainstalovanou jen lokálně (rozbalením tarballu). Interaktivní
smyčka REPL první verze se spouští běžně příkazem <strong>julia</strong>
(prakticky odkudkoli), druhá verze pak příkazem
<strong>~/julia-1.0.0/bin/julia</strong> (právě z&nbsp;důvodu použití dvou
různých variant jazyka asi není vhodné si přidávat
<strong>~/julia-1.0.0/bin/</strong> na <strong>PATH</strong>).</div></p>

<p>Další možnost představuje použití připraveného obrazu pro nástroj Docker.
Další informace o oficiálně připravených obrazech jsou dostupné na stránce <a
href="https://hub.docker.com/_/julia/">https://hub.docker.com/_/julia/</a></p>



<p><a name="k03"></a></p>
<h2 id="k03">3. Otestování základní funkcionality nové verze</h2>

<p>Po rozbalení tarballu s&nbsp;jazykem Julia verze 1.0 způsobem <a
href="#k02">ukázaným výše</a> si pro jistotu otestujeme jeho základní
funkcionalitu. Spustíme si proto interaktivní prostředí tohoto jazyka (neboli
<a
href="https://en.wikipedia.org/wiki/Read%E2%80%93eval%E2%80%93print_loop">REPL</a>),
a to následujícím příkazem (připomeňme si, že jsme nijak neupravovali proměnnou
<strong>PATH</strong>, tudíž musíme použít plnou cestu):</p>

<pre>
$ <strong>julia-1.0.0/bin/julia</strong>
</pre>

<p>Uvítat by nás měla následující zpráva. Pro jistotu si zkontrolujte, zda
skutečně používáte správnou verzi (viz tučně zvýrazněná část zprávy):</p>

<pre>
               _
   _       _ _(_)_     |  Documentation: https://docs.julialang.org
  (_)     | (_) (_)    |
   _ _   _| |_  __ _   |  Type "?" for help, "]?" for Pkg help.
  | | | | | | |/ _` |  |
  | | |_| | | | (_| |  |  <strong>Version 1.0.0</strong> (2018-08-08)
 _/ |\__'_|_|_|\__'_|  |  Official https://julialang.org/ release
|__/                   |
&nbsp;
julia&gt;
</pre>

<p>Podrobnější informace o verzi, podporované architektuře, použitých
knihovnách atd. získáme zavoláním funkce <strong>versioninfo()</strong>:</p>

<pre>
julia&gt; <strong>versioninfo()</strong>
&nbsp;
Julia Version 1.0.0
Commit 5d4eaca0c9 (2018-08-08 20:58 UTC)
Platform Info:
  OS: Linux (x86_64-pc-linux-gnu)
  CPU: Intel(R) Xeon(R) CPU           E5440  @ 2.83GHz
  WORD_SIZE: 64
  LIBM: libopenlibm
  LLVM: libLLVM-6.0.0 (ORCJIT, penryn)
</pre>

<p><div class="rs-tip-major">Poznámka: mimochodem si povšimněte verze libLLVM.
Starší verze Julie bývají linkovány oproti starší verzi LLVM, což se může
negativně odrazit na výkonu přeloženého kódu.</div></p>

<p>Výzva <strong>julia&gt;</strong> značí, že REPL jazyka Julia očekává zadání
příkazů či definici funkce. Stiskem klávesy &bdquo;?&ldquo; se přepneme do
režimu nápovědy:</p>

<pre>
help?&gt;
search: ...
&nbsp;
  Welcome to Julia 1.0.0. The full manual is available at
&nbsp;
  https://docs.julialang.org/
&nbsp;
  as well as many great tutorials and learning resources:
&nbsp;
  https://julialang.org/learning/
&nbsp;
  For help on a specific function or macro, type ? followed by its name, e.g. ?cos, or ?@time, and press enter. Type ; to enter shell mode, ]  to enter package mode.
</pre>

<p>Ještě pro jistotu otestujeme některé další vlastnosti interpretru.</p>

<p>Deklarace proměnné a použití proměnné ve výrazu (operátor násobení je
implicitní, stejně jako v&nbsp;matematice):</p>

<pre>
julia&gt; <strong>x=10</strong>
10
&nbsp;
julia&gt; <strong>2x+3x^2</strong>
320
</pre>

<p>Deklarace nové funkce s&nbsp;implicitním příkazem
<strong>return</strong>:</p>

<pre>
julia&gt; <strong>inc(x)=x+1</strong>
inc (generic function with 1 method)
</pre>

<p>Vytvoření objektu typu <i>range</i> a aplikace naší funkce
<strong>inc</strong> na hodnoty z&nbsp;tohoto objektu:</p>

<pre>
julia&gt; <strong>range(1, length=10)</strong>
1:10
&nbsp;
julia&gt; <strong>map(inc, range(1, length=10))</strong>
10-element Array{Int64,1}:
  2
  3
  4
  5
  6
  7
  8
  9
 10
 11
</pre>

<p><div class="rs-tip-major">Poznámka: zde již můžeme vidět první odchylku od
starších verzí jazyka Julia, v&nbsp;nichž stačilo napsat <strong>range(1,
10)</strong> a nikoli explicitně <strong>range(1, length=10)</strong>.
Explicitní uvedené druhého parametru je čitelnější, protože
v&nbsp;<strong>range</strong> lze specifikovat i krok.</div></p>



<p><a name="k04"></a></p>
<h2 id="k04">4. Reprezentace chybějící hodnoty</h2>

<p>Nově je v&nbsp;jazyku Julia definována speciální hodnota reprezentující
(jakoukoli) chybějící hodnotu. Díky tomu není nutné si vymýšlet vlastní
speciální hodnoty typu -1, prázdný řetězec atd. Tato speciální hodnota je
dostupná pod jménem <strong>missing</strong> (opět si povšimněte, že uživatelé
nejsou zbytečně zmateni z&nbsp;názvu typu <strong>null</strong>, který má pro
matematiky jiný význam):</p>

<pre>
julia&gt; <strong>missing</strong>
missing
</pre>

<p>Tato hodnota má samozřejmě svůj datový typ, a to
<strong>Missing</strong>:</p>

<pre>
julia&gt; <strong>typeof(missing)</strong>
Missing
</pre>

<p>Prakticky všechny operace s&nbsp;hodnotou <strong>missing</strong> jsou
povoleny, a to s&nbsp;tím, že výsledkem bude taktéž
<strong>missing</strong>:</p>

<pre>
julia&gt; <strong>missing + 10</strong>
missing
</pre>

<pre>
julia&gt; <strong>10 + missing</strong>
missing
</pre>

<p>Zajímavé je ovšem porovnání &ndash; <strong>missing</strong> evidentně
doplňuje dvouhodnotovou Booleovu algebru:</p>

<pre>
julia&gt; <strong>missing == missing</strong>
missing
</pre>

<pre>
julia&gt; <strong>missing != missing</strong>
missing
</pre>

<pre>
julia&gt; <strong>missing &gt; missing</strong>
missing
</pre>

<pre>
julia&gt; <strong>missing &lt; missing</strong>
missing
</pre>

<p>Porovnání na identitu:</p>

<pre>
julia&gt; <strong>missing === missing</strong>
true
</pre>

<pre>
julia&gt; <strong>missing !== missing</strong>
false
</pre>

<p>Existuje i funkce <strong>ismissing()</strong>, která nahrazuje výše zmíněné
porovnání a doporučuje se ji používat:</p>

<pre>
julia&gt; <strong>ismissing(10)</strong>
false
</pre>

<pre>
julia&gt; <strong>ismissing(missing)</strong>
true
</pre>

<p>Tato hodnota je využitelná všude, typicky může reprezentovat neznámou
hodnotu v&nbsp;poli (řídké matici...):</p>

<pre>
julia&gt; <strong>x=(1,2,3,missing,4,5)</strong>
(1, 2, 3, missing, 4, 5)
</pre>

<pre>
julia&gt; <strong>x=[1,2,3,missing,4,5]</strong>
6-element Array{Any,1}:
 1       
 2       
 3       
  missing
 4       
 5       
</pre>

<p>Jen pro úplnost si doplňme, jak vypadá porovnání a další operace
s&nbsp;další speciální hodnotou <strong>NaN</strong>. Ta má jiný význam a
odlišné chování:</p>

<pre>
julia&gt; <strong>NaN == NaN</strong>
false
</pre>

<pre>
julia&gt; <strong>NaN != NaN</strong>
true
</pre>

<pre>
julia&gt; <strong>NaN &gt; NaN</strong>
false
</pre>

<pre>
julia&gt; <strong>NaN &lt; NaN</strong>
false
</pre>

<pre>
julia&gt; <strong>NaN === NaN</strong>
true
</pre>



<p><a name="k05"></a></p>
<h2 id="k05">5. Deklarace nových operátorů</h2>

<p>Na začátek si připomeňme, že v&nbsp;jazyce Julia je možné vytvářet a
používat funkce (i proměnné), v&nbsp;jejichž jménu jsou znaky z&nbsp;Unicode.
Příkladem může být standardní funkce pro výpočet druhé odmocniny:</p>

<pre>
help?&gt; <strong>√</strong>
"√" can be typed by \sqrt&lt;tab&gt;
</pre>

<p>Příklad zavolání této funkce:</p>

<pre>
julia&gt; <strong>√2</strong>
1.4142135623730951
</pre>

<p>Podobně třetí odmocnina:</p>

<pre>
julia&gt; <strong>∛1000</strong>
10.0
</pre>

<p>Podobné funkce si samozřejmě můžeme snadno vytvořit. Totéž platí i pro
operátory, takže je možné vytvořit nový operátor pro Kroneckerův součin:</p>

<pre>
julia&gt; <strong>const ⊗ = kron</strong>
kron (generic function with 16 methods)
</pre>

<p>Příklady použití:</p>

<pre>
julia&gt; <strong>1 ⊗ 5</strong>
5
</pre>

<pre>
julia&gt; <strong>A = [1 2; 3 4]</strong>
2×2 Array{Int64,2}:
 1  2
 3  4
&nbsp;
julia&gt; <strong>B = [im 1; 1 -im]</strong>
2×2 Array{Complex{Int64},2}:
 0+1im  1+0im
 1+0im  0-1im
&nbsp;
julia&gt; <strong>A ⊗ B</strong>
4×4 Array{Complex{Int64},2}:
 0+1im  1+0im  0+2im  2+0im
 1+0im  0-1im  2+0im  0-2im
 0+3im  3+0im  0+4im  4+0im
 3+0im  0-3im  4+0im  0-4im
</pre>

<p>Nyní lze podobným způsobem vytvářet i nové operátory, které se skládají ze
symbolu nějakého existujícího operátoru (kvůli prioritě) a Unicode znaku
s&nbsp;horním či dolním indexem. Příklad vytvoření nového operátoru, který bude
počítat délku přepony:</p>

<pre>
julia&gt; <strong>+₂(a,b) = sqrt(a^2 + b^2)</strong>
+₂ (generic function with 1 method)
&nbsp;
julia&gt; <strong>1 +₂ 2</strong>
2.23606797749979
</pre>

<p>Operátor pro součet v&nbsp;modulární aritmetice (modulo 8).</p>

<pre>
julia&gt; <strong>+⁸(a,b) = (a+b)%8</strong>
</pre>

<p>Použití nového operátoru:</p>

<pre>
julia&gt; <strong>1 +⁸ 2</strong>
3
</pre>

<pre>
julia&gt; <strong>1 +⁸ 7</strong>
0
</pre>

<pre>
julia&gt; <strong>2 +⁸ 7</strong>
1
</pre>

<p>Podobně lze vytvořit operátor pro násobení:</p>

<pre>
julia&gt; <strong>*⁸(a,b) = (a*b)%8</strong>
*⁸ (generic function with 1 method)
&nbsp;
julia&gt; <strong>2 *⁸ 7</strong>
6
</pre>

<p>Ve starší verzi jazyka nebyly takto pojmenované operátory povoleny:</p>

<pre>
julia&gt; <strong>+⁸(a,b) = (a+b)%8</strong>
ERROR: syntax: invalid character "⁸"
Stacktrace:
 [1] macro expansion at ./REPL.jl:97 [inlined]
 [2] (::Base.REPL.##1#2{Base.REPL.REPLBackend})() at ./event.jl:73
</pre>



<p><a name="k06"></a></p>
<h2 id="k06">6. Makro @enum a zápis hodnot v&nbsp;bloku</h2>

<p>Další jazyková úprava může být velmi užitečná ve chvíli, kdy se vytváří
výčtový typ s&nbsp;mnoha hodnotami. Připomeňme si, že pro tento účel slouží
makro <strong>@enum</strong>:</p>

<pre>
help?&gt; <strong>@enum</strong>
  @enum EnumName[::BaseType] value1[=x] value2[=y]
&nbsp;
  Create an Enum{BaseType} subtype with name EnumName and enum member values
  of value1 and value2 with optional assigned values of x and y, respectively.
  EnumName can be used just like other types and enum member values as regular
  values, such as ...
</pre>

<p>Ve starších verzích a samozřejmě i ve verzi 1.0 se výčtový typ deklaruje
následujícím způsobem:</p>

<pre>
julia&gt; <strong>@enum Languages c=1 python=2 julia=3 rust=4</strong>
</pre>

<p>Příklad použití:</p>

<pre>
julia&gt; <strong>c::Languages</strong>
c::Languages = 1
&nbsp;
julia&gt; <strong>julia::Languages</strong>
julia::Languages = 3
</pre>

<p>Nově je možné ve verzi 1.0 použít i deklaraci výčtového typu rozepsanou na
více řádků, což je čitelnější. Používají se zde pomocná klíčová slova
<strong>begin</strong> a <strong>end</strong>:</p>

<pre>
<strong>@enum Languages begin</strong>
    <strong>c=1</strong>
    <strong>python=2</strong>
    <strong>julia=3</strong>
    <strong>rust=4</strong>
<strong>end</strong>
</pre>

<p>Příklad použití:</p>

<pre>
julia&gt; <strong>julia::Languages</strong>
julia::Languages = 3
</pre>

<p>Pokus o použití předchozí deklarace ve verzi 0.6.3 ovšem skončí
s&nbsp;chybou:</p>

<pre>
<strong>@enum Languages begin</strong>
    <strong>c=1</strong>
    <strong>python=2</strong>
    <strong>julia=3</strong>
    <strong>rust=4</strong>
<strong>end</strong>
&nbsp;
ERROR: ArgumentError: invalid argument for Enum Languages: begin  # REPL[15], line 2:
    c = 1 # REPL[15], line 3:
    python = 2 # REPL[15], line 4:
    julia = 3 # REPL[15], line 5:
    rust = 4
end
Stacktrace:
 [1] macro expansion at ./REPL.jl:97 [inlined]
 [2] (::Base.REPL.##1#2{Base.REPL.REPLBackend})() at ./event.jl:73
</pre>



<p><a name="k07"></a></p>
<h2 id="k07">7. Změna oblasti viditelnosti proměnných ve smyčce <strong>for</strong></h2>

<p>Programovací jazyk Julia je určen i lidem, kteří nemají vystudován žádný IT
obor, což znamená, že některé vlastnosti jazyka jsou navrženy takovým způsobem,
aby pro uživatele nepředstavovaly zbytečné pasti. Týká se to i změny konceptu
viditelnosti řídicích proměnných v&nbsp;programové smyčce <strong>for</strong>,
který se odlišuje od některých dalších (řekněme mainstreamových) jazyků, ovšem
je přirozenější. Nejdříve se podívejme, jak se řídicí proměnné chovají ve
starší verzi Julie.</p>

<p>Spustíme interpret Julie 0.6.3:</p>

<pre>
$ <strong>julia</strong>
&nbsp;
               _
   _       _ _(_)_     |  A fresh approach to technical computing
  (_)     | (_) (_)    |  Documentation: https://docs.julialang.org
   _ _   _| |_  __ _   |  Type "?help" for help.
  | | | | | | |/ _` |  |
  | | |_| | | | (_| |  |  Version 0.6.3 (2018-05-28 20:20 UTC)
 _/ |\__'_|_|_|\__'_|  |  
|__/                   |  x86_64-redhat-linux
</pre>

<p>Vytvoříme proměnnou <strong>i</strong> a nastavíme jí nějakou hodnotu:</p>

<pre>
julia&gt; <strong>i=-1000</strong>
-1000
</pre>

<p>Použijeme proměnnou téhož jména pro počítanou smyčku
<strong>for</strong>:</p>

<pre>
julia&gt; <strong>for i=1:10</strong>
           <strong>println(i)</strong>
       <strong>end</strong>
1
2
3
4
5
6
7
8
9
10
</pre>

<p>Podíváme se na hodnotu proměnné <strong>i</strong> po ukončení smyčky:</p>

<pre>
julia&gt; <strong>i</strong>
10
</pre>

<p>Můžeme vidět, že se hodnota proměnné změnila, konkrétně na poslední hodnotu,
kterou měla proměnná v&nbsp;programové smyčce. Takové chování najdeme i
v&nbsp;mnoha dalších programovacích jazycích, ovšem pro uživatele (matematiky,
fyziky) může být toto chování poněkud matoucí. V&nbsp;Julii 1.0.0 je
z&nbsp;tohoto důvodu situace odlišná, o čemž se opět můžeme přesvědčit:</p>

<pre>
julia&gt; <strong>i=-1000</strong>
-1000
&nbsp;
julia&gt; <strong>for i=1:10</strong>
           <strong>println(i)</strong>
       <strong>end</strong>
1
2
3
4
5
6
7
8
9
10
</pre>

<p>Po proběhnutí smyčky se podíváme na aktuální hodnotu proměnné
<strong>i</strong>:</p>

<pre>
julia&gt; <strong>i</strong>
-1000
</pre>

<p>Vidíme, že se hodnota proměnné nezměnila &ndash; evidentně se ve smyčce
použila jiná (lokální) proměnná</p>

<p><div class="rs-tip-major">Poznámka: podobné chování nalezneme i
v&nbsp;jazyku Lua, s&nbsp;nímž má Julia poměrně hodně společných vlastností
(indexování prvků v&nbsp;poli od jedničky, syntaxe s&nbsp;mnoha klíčovými slovy
atd.):</div></p>

<pre>
<strong>x=-1000</strong>
&nbsp;
<strong>for x = 1,10 do</strong>
    <strong>print(x)</strong>
<strong>end</strong>
&nbsp;
1
2
3
4
5
6
7
8
9
10
&nbsp;
<strong>print(x)</strong>
-1000
</pre>

<p>Mění se i chování vnořených programových smyček ve chvíli, kdy ve vnitřní
smyčce modifikujeme hodnotu počitadla smyčky vnější. Ve starší verzi měla tato
změna lokální vliv, ve verzi 1.0.0 je počitadlo vždy na začátku iterace
přepsáno svojí správnou hodnotou:</p>

<p>Chování starší verze:</p>

<pre>
<strong>for i in [1,2,3], j in [1,2,3]</strong>
    <strong>println(i*j)</strong>
<strong>end</strong>
&nbsp;
1
2
3
2
4
6
3
6
9
&nbsp;
<strong>for i in [1,2,3], j in [1,2,3]</strong>
    <strong>println(i*j)</strong>
    <strong>i = -1</strong>
<strong>end</strong>
&nbsp;
1
-2
-3
2
-2
-3
3
-2
-3
</pre>

<p>Chování verze 1.0, v&nbsp;níž je na začátku každé iterace vnitřní smyčky
obnovena hodnota počitadla smyčky vnější:</p>

<pre>
<strong>for i in [1,2,3], j in [1,2,3]</strong>
    <strong>println(i*j)</strong>
<strong>end</strong>
&nbsp;
1
2
3
2
4
6
3
6
9
&nbsp;
<strong>for i in [1,2,3], j in [1,2,3]</strong>
    <strong>println(i*j)</strong>
    <strong>i = -1</strong>
<strong>end</strong>
&nbsp;
1
2
3
2
4
6
3
6
9
</pre>

<p>Proměnná <strong>i</strong> <i>je</i> ovšem měnitelná, pouze se na začátku každé iterace obnoví:</p>

<pre>
<strong>for i in [1,2,3], j in [1,2,3]</strong>
    <strong>i = -1</strong>
    <strong>println(i*j)</strong>
<strong>end</strong>
&nbsp;
-1
-2
-3
-1
-2
-3
-1
-2
-3
</pre>



<p><a name="k08"></a></p>
<h2 id="k08">8. Použití klauzule <strong>outer</strong></h2>

<p>S&nbsp;předchozí změnou chování programových smyček souvisí i zavedení
klauzule <strong>outer</strong>, kterou je možné specifikovat, že programová
smyčka má namísto lokálního počitadla použít již dříve definovanou proměnnou.
Tato proměnná samozřejmě musí být v&nbsp;daném kontextu viditelná. Podívejme se
na způsob použití této klauzule uvnitř funkce:</p>

<pre>
julia&gt; <strong>function f()</strong>
           <strong>i = 0</strong>
               <strong>for outer i = 1:10</strong>
           <strong>end</strong>
           <strong>return i</strong>
       <strong>end</strong>
&nbsp;
f (generic function with 2 methods)
</pre>

<p>Při zavolání této funkce se vrátí hodnota 10, tj.&nbsp;koncová hodnota počitadla smyčky:</p>

<pre>
julia&gt; <strong>f()</strong>
10
</pre>

<p>Pokud naopak klauzuli <strong>outer</strong> nepoužijeme, bude se aplikovat
pravidlo o lokální proměnné popsané v&nbsp;předchozí kapitole:</p>

<pre>
julia&gt; <strong>function f()</strong>
           <strong>i = 0</strong>
               <strong>for i = 1:10</strong>
           <strong>end</strong>
           <strong>return i</strong>
       <strong>end</strong>
&nbsp;
f (generic function with 2 methods)
</pre>

<p>Nyní funkce po svém zavolání vrátí původní hodnotu přiřazenou do proměnné
<strong>i</strong>:</p>

<pre>
julia&gt; <strong>f()</strong>
0
</pre>



<p><a name="k09"></a></p>
<h2 id="k09">9. Nová makra pro logování</h2>

<p>Ve starších verzích programovacího jazyka Julia bylo možné pro logování
použít funkce <strong>info()</strong> a <strong>warn()</strong>. Jejich použití
je snadné a přímočaré:</p>

<pre>
julia&gt; <strong>info("341")</strong>
INFO: 341
</pre>

<pre>
julia&gt; <strong>warn("42")</strong>
WARNING: 42
</pre>

<p>Ve verzi 1.0 již tyto funkce neexistují a namísto nich byla vytvořena makra
<strong>@info</strong>, <strong>@warn</strong> a taktéž
<strong>@error</strong>:</p>

<p>O tom, že funkce <strong>info()</strong> již skutečně neexistuje, se
přesvědčíme snadno:</p>

<pre>
julia&gt; <strong>info("341")</strong>
ERROR: UndefVarError: info not defined
Stacktrace:
 [1] top-level scope at none:0
</pre>

<p>Použití nových maker <strong>@info</strong>, <strong>@warn</strong> a
<strong>@error</strong> je snadné:</p>

<pre>
julia&gt; <strong>@info("341")</strong>
[ Info: 341
</pre>

<pre>
julia&gt; <strong>@warn("asi prepisu cely disk")</strong>
┌ Warning: asi prepisu cely disk
└ @ Main REPL[7]:1
</pre>

<pre>
julia&gt; <strong>@error("Chyba pri zapisu")</strong>
┌ Error: Chyba pri zapisu
└ @ Main REPL[4]:1
</pre>

<p>Hlavní důvody, proč se namísto původních logovacích funkcí mají používat
makra, jsou pěkně shrnuty <a
href="https://github.com/JuliaLang/julia/pull/24490#issuecomment-342375477">v&nbsp;tomto
komentáři</a>:</p>

<ol>

<li>Makro umožňuje &bdquo;líné&ldquo; vygenerování zprávy jen ve chvíli, kdy je
to skutečně zapotřebí (parametry makra totiž není nutné vyhodnocovat před jeho
voláním).</li>

<li>Makra umožňují vytvářet unikátní identifikátory řádku, na němž se nachází,
takže je například umožněno preciznější filtrování dlouhých logů, například
nějakým externím nástrojem.</li>

<li>Makra umožňují shromažďovat různé (meta)informace již v&nbsp;čase
překladu.</li>

</ol>

<p>Navíc bych přidal další vlastnost &ndash; při zákazu logování se makra mohou
expandovat na prázdný příkaz, kdežto funkce se budou stále volat, i když
nebudou provádět žádnou činnost.</p>

<p><div class="rs-tip-major">Poznámka: je nutné si dát pozor na rozdíl mezi
makrem <strong>@error</strong> a funkcí <strong>error</strong>. Funkce
<strong>error</strong> totiž slouží k&nbsp;vyhození výjimky a její použití je
tedy odlišné:</div></p>

<pre>
julia&gt; <strong>error("Chyba pri zapisu")</strong>
ERROR: Chyba pri zapisu
Stacktrace:
 [1] error(::String) at ./error.jl:33
 [2] top-level scope at none:0
</pre>



<p><a name="k10"></a></p>
<h2 id="k10">10. Destructuring n-tic použitých pro předání parametrů do funkcí</h2>

<p>Další novou a užitečnou vlastností je takzvaný <i>destructuring</i> n-tic,
který se použije ve chvíli, kdy jsou n-tice použity při předávání parametrů do
funkcí. Již v&nbsp;hlavičce funkce je možné specifikovat nejenom fakt, že se
bude předávat n-tice, ale i kolik prvků bude tato n-tice mít a jak se budou (po
rozložení) jmenovat. Ukažme si jednoduchý příklad s&nbsp;funkcí, které se předá
n-tice se dvěma prvky a výsledkem volání funkce bude součet těchto dvou prvků.
Povšimněte si především zápisu: vnější závorky označují argumenty funkce,
kdežto závorky vnitřní fakt, že se bude předávat n-tice (x,y):</p>

<pre>
julia&gt; <strong>f((x,y),) = x+y</strong>
f (generic function with 1 method)
</pre>

<p>Vytvoříme si novou n-tici, konkrétně tedy dvojici s&nbsp;prvky 1 a 2 (opět
je nutné použít závorky):</p>

<pre>
julia&gt; <strong>dvojice=(1,2)</strong>
(1, 2)
</pre>

<p>A zavoláme funkci <strong>f</strong>, které předáme naši n-tici:</p>

<pre>
julia&gt; <strong>f(dvojice)</strong>
3
</pre>

<p>U předchozí verze 0.6 jazyka Julia nelze n-tice použít:</p>

<pre>
julia&gt; <strong>f((x,y),) = x+y</strong>
ERROR: syntax: "(x,y)" is not a valid function argument name
Stacktrace:
 [1] macro expansion at ./REPL.jl:97 [inlined]
 [2] (::Base.REPL.##1#2{Base.REPL.REPLBackend})() at ./event.jl:73
</pre>

<p><div class="rs-tip-major">Poznámka: s&nbsp;destructuringem n-tic jsme se již
<a
href="https://www.root.cz/clanky/rust-struktury-n-tice-a-vlastnictvi-objektu/#k06">setkali
například v&nbsp;jazyku Rust</a>.</div></p>



<p><a name="k11"></a></p>
<h2 id="k11">11. Pojmenované prvky v&nbsp;n-ticích</h2>

<p>I další vlastnost souvisí s&nbsp;n-ticemi. Syntaxe jazyka Julia byla
rozšířena o možnost používat pojmenované prvky v&nbsp;n-ticích. To je velmi
užitečná vlastnost, protože nám například umožňuje vytvořit si dvojici
představující bod v&nbsp;2D prostoru a přímo pojmenovat prvky (ty tedy nebudou
určeny pouze svým indexem):</p>

<pre>
julia&gt; <strong>point=(x=10, y=20)</strong>
(x = 10, y = 20)
</pre>

<p>Způsob zobrazení hodnoty n-tice:</p>

<pre>
julia&gt; <strong>point</strong>
(x = 10, y = 20)
</pre>

<p>Pro přístup k&nbsp;jednotlivým prvkům n-tice se používá tečková notace:</p>

<pre>
julia&gt; <strong>point.x</strong>
10
</pre>

<pre>
julia&gt; <strong>point.y</strong>
20
</pre>

<p>Opět platí, že ve starší verzi jazyka není tato nová syntaxe
podporována:</p>

<pre>
julia&gt; <strong>point=(x=10, y=20)</strong>
ERROR: syntax: assignment not allowed inside tuple
Stacktrace:
 [1] macro expansion at ./REPL.jl:97 [inlined]
 [2] (::Base.REPL.##1#2{Base.REPL.REPLBackend})() at ./event.jl:73
</pre>



<p><a name="k12"></a></p>
<h2 id="k12">12. Makro @isdefined</h2>

<p>Tato kapitola bude velmi stručná, protože se v&nbsp;ní pouze seznámíme
s&nbsp;existencí makra pojmenovaného <strong>@isdefined</strong>. Toto makro
lze kdykoli použít pro zjištění, zda je nějaká proměnná definována či nikoli.
Díky tomu, že se jedná o makro nemusí docházet k&nbsp;vyhodnocování
hodnoty.</p>

<p>Proměnná <strong>point</strong> byla definována v&nbsp;předchozí
kapitole:</p>

<pre>
julia&gt; <strong>@isdefined point</strong>
true
</pre>

<p>Zato proměnnou <strong>vector</strong> jsme prozatím vůbec nepoužili:</p>

<pre>
julia&gt; <strong>@isdefined vector</strong>
false
</pre>

<p>Makro <strong>@isdefined</strong> lze použít kdykoli a kdekoli:</p>

<pre>
julia&gt; <strong>for i in 1:10</strong>
           <strong>println(i)</strong>
           <strong>println(@isdefined i)</strong>
       <strong>end</strong>
</pre>



<p><a name="k13"></a></p>
<h2 id="k13">13. Operátor ^ a celá záporná čísla reprezentující exponent</h2>

<p>I tato kapitola bude velmi krátká a zmíníme se v&nbsp;ní o chování operátoru
^ v&nbsp;případě, že exponentem je záporné celé číslo. Starší verze jazyka
Julia neumožňovaly přímý zápis x^-1:</p>

<pre>
julia&gt; <strong>x=2</strong>
2
&nbsp;
julia&gt; <strong>x^-1</strong>
ERROR: DomainError:
Stacktrace:
 [1] literal_pow(::Base.#^, ::Int64, ::Type{Val{-1}}) at ./intfuncs.jl:208
 [2] macro expansion at ./REPL.jl:97 [inlined]
 [3] (::Base.REPL.##1#2{Base.REPL.REPLBackend})() at ./event.jl:73
</pre>

<p>Nová verze jazyka již tento zápis bez problémů umožňuje:</p>

<pre>
julia&gt; <strong>x=2</strong>
2
&nbsp;
julia&gt; <strong>x^-1</strong>
0.5
&nbsp;
julia&gt; <strong>x^-10</strong>
0.0009765625
</pre>



<p><a name="k14"></a></p>
<h2 id="k14">14. Odlišná pravidla při interpolaci řetězců</h2>

<p>Další změna se týká odlišných pravidel při interpolaci řetězců, tj.&nbsp;při
náhradě jména proměnné v&nbsp;řetězci její hodnotou (to dokáže i BASH, TCL
atd.). Ve starších verzích jazyka Julia lze interpolaci provést prakticky
jakkoli, pouze je důležité zajistit, aby název proměnné byl jednoznačný (nesmí
za ním ihned následovat alfanumerický znak):</p>

<pre>
julia&gt; <strong>x="hello"</strong>
</pre>

<p>Všechny následující interpolace budou funkční:</p>

<pre>
julia&gt; <strong>"$x world!"</strong>
"hello world!"
</pre>

<pre>
julia&gt; <strong>"$x`world!"</strong>
"hello`world!"
</pre>

<pre>
julia&gt; <strong>"$x෴ world!"</strong>
"hello෴ world!"
</pre>

<p>Nová verze jazyka je nepatrně odlišná a kontroluje, jestli není za názvem
řetězce nějaký nepovolený (unicode) znak:</p>

<pre>
julia&gt; <strong>x="hello"</strong>
</pre>

<pre>
julia&gt; <strong>"$x world!"</strong>
"hello world!"
</pre>

<pre>
julia&gt; <strong>"$x`world!"</strong>
"hello`world!"
</pre>

<p>Povšimněte si, že se dokonce vypíše i nápověda, jak interpolaci provést
korektně a naprosto jednoznačně:</p>

<pre>
julia&gt; <strong>"$x෴ world!"</strong>
ERROR: syntax: interpolated variable $x ends with invalid character "෴"; use "$(x)" instead.
</pre>



<p><a name="k15"></a></p>
<h2 id="k15">15. Implicitní spojení proměnné s&nbsp;řetězcovým literálem</h2>

<p>Ve starších verzích programovacího jazyka Julia bylo možné spojit hodnotu
proměnné (převedenou na řetězec) s&nbsp;řetězcovým literálem, a to bez
explicitního použití operátoru (podobně, jako u násobení).</p>

<pre>
julia&gt; <strong>x="world"</strong>
"world"
</pre>

<p>Spojení řetězcového literálu a proměnné:</p>

<pre>
julia&gt; <strong>"hello "x</strong>
"hello world"
</pre>

<p>Nové verze již toto chování zakazuje, protože výše uvedený zápis může velmi
pravděpodobně vzniknout spíše chybou uživatele:</p>

<pre>
julia&gt; <strong>x="world"</strong>
"world"
</pre>

<p>Při pokusu o spojení řetězcového literálu s&nbsp;proměnnou nyní dojde
k&nbsp;chybě:</p>

<pre>
julia&gt; <strong>"hello "x</strong>
ERROR: syntax: cannot juxtapose string literal
</pre>

<p>Pro spojení řetězců se nyní musí použít operátor *:</p>

<pre>
julia&gt; <strong>"hello " * x</strong>
"hello world"
</pre>

<p><div class="rs-tip-major">Poznámka: použití operátoru * a nikoli + opět
vychází z&nbsp;toho, že je jazyk Julia určen (i) matematikům a fyzikům. Obecně
je totiž operace + v&nbsp;naprosté většině případů <i>komutativní</i>, což ale
spojení řetězců určitě nesplňuje: "hello" + "world" != "world" + "hello".
Naproti tomu operace * komutativní být nemusí. Příkladem může být násobení
matic nebo <a
href="https://www.root.cz/clanky/fraktaly-vytvarene-ve-ctyrrozmernem-prostoru/#k03">kvaternionů</a>.</div></p>



<p><a name="k16"></a></p>
<h2 id="k16">16. Hodnoty s&nbsp;plovoucí řádovou čárkou a &bdquo;tečkové&ldquo; operátory</h2>

<p>Připomeňme si, že v&nbsp;programovacím jazyku Julia je možné použít různé
&bdquo;tečkové&ldquo; operátory, které slouží k&nbsp;tomu, aby se příslušná
operace provedla mezi všemi prvky předaného vektoru nebo matice. Příkladem může
být výpočet druhých mocnin každého prvku vstupního vektoru:</p>

<pre>
<strong>a=[1,2,3,4]</strong>
&nbsp;
<strong>print(a.^2)</strong>
&nbsp;
[1, 4, 9, 16]
</pre>

<p>Tečku lze použít prakticky před všemi operátory, ovšem problémy (nebo spíše
zmatky) nastávají ve chvíli, kdy je před operátorem zapsána například hodnota
&bdquo;2.&ldquo;, která samozřejmě odpovídá plnému zápisu
&bdquo;2.0&ldquo;.</p>

<p>Chování starších verzí jazyka při použití mezery za číslem a bez použití
mezery je následující:</p>

<pre>
julia&gt; <strong>2 .* [1,2,3]</strong>
3-element Array{Int64,1}:
 2
 4
 6
&nbsp;
julia&gt; <strong>2.*[1,2,3]</strong>
3-element Array{Int64,1}:
 2
 4
 6
</pre>

<p>Výše uvedené výsledky jsou logické, ovšem už méně logické je chování
v&nbsp;případě, že se &bdquo;tečkovým&ldquo; operátorem násobí dvě skalární
hodnoty:</p>

<pre>
julia&gt; <strong>typeof(2.*3)</strong>
Int64
</pre>

<p>V&nbsp;tomto případě se evidentně vynásobila dvě celá čísla a pro násobení
byl použit tečkový operátor.</p>

<p>Naproti tomu když mezi tečku a hvězdičku přidáme mezeru, provede se
vynásobení hodnoty 2.0 a 3, takže výsledkem bude číslo s&nbsp;plovoucí řádovou
čárkou:</p>

<pre>
julia&gt; <strong>typeof(2. *3)</strong>
Float64
</pre>

<p>Ve verzi 1.0 nejsou některé kombinace povoleny. Při použití mezery je vše
v&nbsp;pořádku:</p>

<pre>
julia&gt; <strong>2 .* [1,2,3]</strong>
3-element Array{Int64,1}:
 2
 4
 6
</pre>

<p>Ovšem vynechání mezery již znamená chybu (nejasnost pro uživatele), takže
tento zápis je v&nbsp;nové verzi zakázán:</p>

<pre>
julia&gt; <strong>2.*[1,2,3]</strong>
ERROR: syntax: invalid syntax "2.*"; add space(s) to clarify
</pre>

<pre>
julia&gt; <strong>typeof(2.*3)</strong>
ERROR: syntax: invalid syntax "2.*"; add space(s) to clarify
</pre>

<p>Lepší je tedy buď oddělovat operátory mezerou nebo namísto zkráceného zápisu
2. použít raději 2.0:</p>

<pre>
julia&gt; <strong>typeof(2. *3)</strong>
Float64
</pre>

<pre>
julia&gt; <strong>typeof(2.0*3)</strong>
Float64
</pre>



<p><a name="k17"></a></p>
<h2 id="k17">17. Přepis základních funkcí novým globálním symbolem se stejným jménem</h2>

<p>Ve starších verzích programovacího jazyka Julia bylo možné, například pouhým
omylem, přepsat některou ze základních funkcí. To sice na jednu stranu ukazuje
na velkou flexibilitu jazyka, na stranu druhou však takový přepis může vést
k&nbsp;chybám při volání dalších funkcí a při používání knihoven. Podívejme se
nyní na chování Julie 0.6.3.</p>

<p>Deklarace nové globální proměnné, jejíž jméno s&nbsp;ničím nekoliduje, je
samozřejmě bezproblémové:</p>

<pre>
julia&gt; <strong>global x = 10</strong>
10
</pre>

<p>Volání standardní funkce <strong>sin</strong>, opět bez problémů:</p>

<pre>
julia&gt; <strong>sin(pi/2)</strong>
1.0
</pre>

<p>Přepis funkce <strong>sin</strong> vytvořením globální proměnné stejného
jména:</p>

<pre>
julia&gt; <strong>global sin = 20</strong>
WARNING: imported binding for sin overwritten in module Main
20
</pre>

<p>Pouze se vypíše varování, ovšem přepis se zdařil.</p>

<p>Nyní již volání standardní funkce <strong>sin</strong> selže:</p>

<pre>
julia&gt; <strong>sin(pi/2)</strong>
ERROR: MethodError: objects of type Int64 are not callable
Stacktrace:
 [1] macro expansion at ./REPL.jl:97 [inlined]
 [2] (::Base.REPL.##1#2{Base.REPL.REPLBackend})() at ./event.jl:73
</pre>

<p>Nová verze jazyka Julia je v&nbsp;tomto ohledu mnohem striktnější:</p>

<p>Deklarace nové globální proměnné, jejíž jméno s&nbsp;ničím nekoliduje, je
opět bezproblémové:</p>

<pre>
julia&gt; <strong>global x = 10</strong>
10
</pre>

<p>Volání standardní funkce <strong>sin</strong>:</p>

<pre>
julia&gt; <strong>sin(pi/2)</strong>
1.0
</pre>

<p>Pokus o přepis funkce <strong>sin</strong> vytvořením globální proměnné
stejného jména ovšem nyní selže:</p>

<pre>
julia&gt; <strong>global sin = 20</strong>
ERROR: cannot assign variable Base.sin from module Main
Stacktrace:
 [1] top-level scope at none:0
</pre>

<p><div class="rs-tip-major">Poznámka: tato chyba je ovšem hlášena pouze tehdy,
pokud již byla funkce <strong>sin</strong> volána a tudíž importována. Pokud se
tedy nějaká standardní funkce nepoužívá, není důvod bránit se deklaracím
proměnných s&nbsp;jejím jménem (ostatně kdo si vůbec pamatuje všechny
standardní funkce?).</div></p>



<p><a name="k18"></a></p>
<h2 id="k18">18. Pravděpodobně nezamýšlené změny v&nbsp;REPLu</h2>

<p>Některé změny, které byly implementovány v&nbsp;rámci verzí 0.7 a 1.0 mohou
být nezamýšlené (tj.&nbsp;možná budou prohlášeny za chyby). Týká se to
například situace, v&nbsp;níž uvnitř programové smyčky měníme hodnotu vnější
proměnné &ndash; to vše v&nbsp;rámci interaktivního REPLu. U verze 0.6.3 a i u
všech starších verzí je chování předvídatelné a odpovídá tomu, že proměnná
<strong>a</strong> je viditelná na stejné úrovni, jako samotná programová
smyčka:</p>

<pre>
julia&gt; <strong>a = 0</strong>
0
&nbsp;
julia&gt; <strong>for i = 1:10</strong>
           <strong>a+=1</strong>
       <strong>end</strong>
&nbsp;
julia&gt; <strong>a</strong>
10
</pre>

<p>Ve verzi 1.0 se však setkáme s&nbsp;tím, že proměnná <strong>a</strong>
vůbec není uvnitř programové smyčky viditelná. Toto chování pravděpodobně
souvisí se změnami, které jsme si popsali <a href="#k07">v&nbsp;sedmé</a> a <a
href="#k08">osmé kapitole</a>:</p>

<pre>
julia&gt; <strong>a = 0</strong>
0
&nbsp;
julia&gt; <strong>for i = 1:10</strong>
           <strong>a+=1</strong>
       <strong>end</strong>
&nbsp;
ERROR: UndefVarError: a not defined
Stacktrace:
 [1] top-level scope at ./REPL[86]:2 [inlined]
 [2] top-level scope at ./none:0
</pre>

<p><div class="rs-tip-major">Poznámka: toto chování se skutečně projevuje
v&nbsp;REPLu, nikoli v&nbsp;běžných modulech ani ve funkcích:</div></p>

<pre>
julia&gt; <strong>function x()</strong>
           <strong>a=0</strong>
           <strong>for i=1:10</strong>
               <strong>a+=1</strong>
           <strong>end</strong>
           <strong>print(a)</strong>
       <strong>end</strong>
&nbsp;
x (generic function with 1 method)
&nbsp;
julia&gt; <strong>x()</strong>
10
</pre>



<p><a name="k19"></a></p>
<h2 id="k19">19. Proměnné, jejichž jména jsou tvořena podtržítky</h2>

<p>Na závěr se zmiňme o relativně malé a zdánlivě nevýznamné změně, která
souvisí s&nbsp;proměnnými, jejichž jména jsou tvořena pouze jedním podtržítkem
nebo větším množstvím podtržítek. Starší verze jazyka Julia rozpoznávala pouze
proměnnou pojmenovanou &bdquo;_&ldquo;, do které bylo možné přiřadit hodnotu a
dokonce i hodnotu přečíst (v&nbsp;tomto případě se jen hlásilo varování).
Naproti tomu proměnné &bdquo;__&ldquo;, &bdquo;___&ldquo; atd. byly považovány
za běžné proměnné a žádné kontroly při jejich čtení nebyly prováděny. Následuje
ukázka chování starších verzí Julie:</p>

<pre>
julia&gt; <strong>_=42</strong>
42
&nbsp;
julia&gt; <strong>_</strong>
&nbsp;
WARNING: deprecated syntax "_ as an rvalue".
42
&nbsp;
julia&gt; <strong>_+10</strong>
&nbsp;
WARNING: deprecated syntax "_ as an rvalue".
52
</pre>

<p>__ je ovšem (ve starší verzi) naprosto běžná proměnná:</p>

<pre>
julia&gt; <strong>__=-1</strong>
-1
</pre>

<pre>
julia&gt; <strong>__</strong>
-1
</pre>

<p>Nová verze jazyka Julia považuje všechny proměnné &bdquo;_&ldquo;,
&bdquo;__&ldquo;, &bdquo;___&ldquo; atd. za speciální skupinu proměnných, do
nichž je možné jen zapisovat, ale nikoli číst jejich hodnotu. Mají se tedy
použít pouze v&nbsp;případě, kdy je přiřazení nutné provést jen ze
syntaktického hlediska, ovšem všem čtenářům kódu se má připomenout, že se
hodnota ihned zahodí:</p>

<pre>
julia&gt; <strong>_=42</strong>
42
</pre>

<p>Čtení hodnoty této proměnné již není možné:</p>

<pre>
julia&gt; <strong>_</strong>
ERROR: all-underscore identifier used as rvalue
</pre>

<p>Použití ve výrazu (na pravé straně od přiřazení) je taktéž čtení:</p>

<pre>
julia&gt; <strong>_+10</strong>
ERROR: syntax: all-underscore identifier used as rvalue
</pre>

<p>Totéž platí i pro proměnnou &bdquo;__&ldquo;:</p>

<pre>
julia&gt; <strong>__=-1</strong>
-1
</pre>

<pre>
julia&gt; <strong>__</strong>
ERROR: all-underscore identifier used as rvalue
</pre>



<p><a name="k20"></a></p>
<h2 id="k20">20. Odkazy na Internetu</h2>

<ol>

<li>Dokumentace - Julia 1.0<br />
<a href="https://docs.julialang.org/en/v1/">https://docs.julialang.org/en/v1/</a>
</li>

<li>Julia 1.0<br />
<a href="https://julialang.org/blog/2018/08/one-point-zero">https://julialang.org/blog/2018/08/one-point-zero</a>
</li>

<li>Julia 1.0 Released<br />
<a href="https://juliacomputing.com/press/2018/08/10/Julia-1.0-Released.html">https://juliacomputing.com/press/2018/08/10/Julia-1.0-Released.html</a>
</li>

<li>Julia v0.7.0 Release Notes<br />
<a href="https://github.com/JuliaLang/julia/blob/master/HISTORY.md">https://github.com/JuliaLang/julia/blob/master/HISTORY.md</a>
</li>

<li>JuliaCan 2018<br />
<a href="http://juliacon.org/2018/">http://juliacon.org/2018/</a>
</li>

<li>Julia 1.0 release (Juliacon 2018 reception founders talk) - YouTube<br />
<a href="https://www.youtube.com/watch?v=1jN5wKvN-Uk&amp;index=2&amp;t=0s&amp;list=PLP8iPy9hna6Qsq5_-zrg0NTwqDSDYtfQB">https://www.youtube.com/watch?v=1jN5wKvN-Uk&amp;index=2&amp;t=0s&amp;list=PLP8iPy9hna6Qsq5_-zrg0NTwqDSDYtfQB</a>
</li>

<li>Julia v1.0.0 Release Notes<br />
<a href="https://github.com/JuliaLang/julia/blob/master/NEWS.md">https://github.com/JuliaLang/julia/blob/master/NEWS.md</a>
</li>

<li>Concurrency (computer science)<br />
<a href="https://en.wikipedia.org/wiki/Category:Concurrency_%28computer_science%29">https://en.wikipedia.org/wiki/Category:Concurrency_%28computer_science%29</a>
</li>

<li>Tasks (aka Coroutines) [Julia]<br />
<a href="http://julia.readthedocs.io/en/latest/manual/control-flow/#man-tasks">http://julia.readthedocs.io/en/latest/manual/control-flow/#man-tasks</a>
</li>

<li>Koprogram<br />
<a href="https://cs.wikipedia.org/wiki/Koprogram">https://cs.wikipedia.org/wiki/Koprogram</a>
</li>

<li>Coroutine<br />
<a href="https://en.wikipedia.org/wiki/Coroutine">https://en.wikipedia.org/wiki/Coroutine</a>
</li>

<li>Coroutines in C<br />
<a href="http://www.chiark.greenend.org.uk/~sgtatham/coroutines.html">http://www.chiark.greenend.org.uk/~sgtatham/coroutines.html</a>
</li>

<li>S-expression (Wikipedia)<br />
<a href="https://en.wikipedia.org/wiki/S-expression">https://en.wikipedia.org/wiki/S-expression</a>
</li>

<li>S-Expressions (Rosetta Code)<br />
<a href="http://rosettacode.org/wiki/S-Expressions">http://rosettacode.org/wiki/S-Expressions</a>
</li>

<li>Metaprogramming (Julia)<br />
<a href="http://julia.readthedocs.io/en/latest/manual/metaprogramming/">http://julia.readthedocs.io/en/latest/manual/metaprogramming/</a>
</li>

<li>Introducing Julia/Metaprogramming<br />
<a href="https://en.wikibooks.org/wiki/Introducing_Julia/Metaprogramming">https://en.wikibooks.org/wiki/Introducing_Julia/Metaprogramming</a>
</li>

<li>Tutorial for the Common Lisp Loop Macro<br />
<a href="http://www.ai.sri.com/pkarp/loop.html">http://www.ai.sri.com/pkarp/loop.html</a>
</li>

<li>CS 2101 Parallel Computing with Julia<br />
<a href="https://www.coursehero.com/file/11508091/CS-2101-Parallel-Computing-with-Julia/">https://www.coursehero.com/file/11508091/CS-2101-Parallel-Computing-with-Julia/</a>
</li>

<li>Julia By Example<br />
<a href="https://samuelcolvin.github.io/JuliaByExample/">https://samuelcolvin.github.io/JuliaByExample/</a>
</li>

<li>Tasks and Parallel Computing<br />
<a href="http://docs.julialang.org/en/release-0.4/stdlib/parallel/">http://docs.julialang.org/en/release-0.4/stdlib/parallel/</a>
</li>

<li>clock(3) - Linux man page<br />
<a href="http://linux.die.net/man/3/clock">http://linux.die.net/man/3/clock</a>
</li>

<li>rand_r(3) - Linux man page<br />
<a href="http://linux.die.net/man/3/rand_r">http://linux.die.net/man/3/rand_r</a>
</li>

<li>atan2(3) - Linux man page<br />
<a href="http://linux.die.net/man/3/atan2">http://linux.die.net/man/3/atan2</a>
</li>

<li>Calling C and Fortran Code<br />
<a href="http://docs.julialang.org/en/release-0.4/manual/calling-c-and-fortran-code/?highlight=symbol">http://docs.julialang.org/en/release-0.4/manual/calling-c-and-fortran-code/?highlight=symbol</a>
</li>

<li>Array Programming<br />
<a href="https://en.wikipedia.org/wiki/Array_programming">https://en.wikipedia.org/wiki/Array_programming</a>
</li>

<li>Discovering Array Languages<br />
<a href="http://archive.vector.org.uk/art10008110">http://archive.vector.org.uk/art10008110</a>
</li>

<li>no stinking loops -- Kalothi<br />
<a href="http://www.nsl.com/">http://www.nsl.com/</a>
</li>

<li>Vector (obsahuje odkazy na články, knihy a blogy o programovacích jazycích APL, J a K)<br />
<a href="http://www.vector.org.uk/">http://www.vector.org.uk/</a>
</li>

<li>APL Interpreters<br />
<a href="http://www.vector.org.uk/?area=interpreters">http://www.vector.org.uk/?area=interpreters</a>
</li>

<li>APL_(programming_language<br />
<a href="http://en.wikipedia.org/wiki/APL_(programming_language">http://en.wikipedia.org/wiki/APL_(programming_language</a>
</li>

<li>APL FAQ<br />
<a href="http://www.faqs.org/faqs/apl-faq/">http://www.faqs.org/faqs/apl-faq/</a>
</li>

<li>APL FAQ (nejnovější verze)<br />
<a href="http://home.earthlink.net/~swsirlin/apl.faq.html">http://home.earthlink.net/~swsirlin/apl.faq.html</a>
</li>

<li>A+<br />
<a href="http://www.aplusdev.org/">http://www.aplusdev.org/</a>
</li>

<li>APLX<br />
<a href="http://www.microapl.co.uk/">http://www.microapl.co.uk/</a>
</li>

<li>FreeAPL<br />
<a href="http://www.pyr.fi/apl/index.htm">http://www.pyr.fi/apl/index.htm</a>
</li>

<li>J: a modern, high-level, general-purpose, high-performance programming language<br />
<a href="http://www.jsoftware.com/">http://www.jsoftware.com/</a>
</li>

<li>K, Kdb: an APL derivative for Solaris, Linux, Windows<br />
<a href="http://www.kx.com">http://www.kx.com</a>
</li>

<li>openAPL (GPL)<br />
<a href="http://sourceforge.net/projects/openapl">http://sourceforge.net/projects/openapl</a>
</li>

<li>Parrot APL (GPL)<br />
<a href="http://www.parrotcode.org/">http://www.parrotcode.org/</a>
</li>

<li>Learning J (Roger Stokes)<br />
<a href="http://www.jsoftware.com/help/learning/contents.htm">http://www.jsoftware.com/help/learning/contents.htm</a>
</li>

<li>Rosetta Code<br />
<a href="http://rosettacode.org/wiki/Main_Page">http://rosettacode.org/wiki/Main_Page</a>
</li>

<li>Why APL<br />
<a href="http://www.acm.org/sigapl/whyapl.htm">http://www.acm.org/sigapl/whyapl.htm</a>
</li>

<li>Introducing Julia/Functions<br />
<a href="https://en.wikibooks.org/wiki/Introducing_Julia/Functions">https://en.wikibooks.org/wiki/Introducing_Julia/Functions</a>
</li>

<li>Functions (Julia documentation)<br />
<a href="http://docs.julialang.org/en/release-0.4/manual/functions/">http://docs.julialang.org/en/release-0.4/manual/functions/</a>
</li>

<li>Evaluate binomial coefficients<br />
<a href="http://rosettacode.org/wiki/Evaluate_binomial_coefficients">http://rosettacode.org/wiki/Evaluate_binomial_coefficients</a>
</li>

<li>Ackermann function<br />
<a href="http://rosettacode.org/wiki/Ackermann_function">http://rosettacode.org/wiki/Ackermann_function</a>
</li>

<li>Julia (front page)<br />
<a href="http://julialang.org/">http://julialang.org/</a>
</li>

<li>Julia &ndash; dokumentace<br />
<a href="http://docs.julialang.org/en/release-0.4/">http://docs.julialang.org/en/release-0.4/</a>
</li>

<li>Julia &ndash; repositář na GitHubu<br />
<a href="https://github.com/JuliaLang/julia">https://github.com/JuliaLang/julia</a>
</li>

<li>Julia (programming language, Wikipedia)<br />
<a href="https://en.wikipedia.org/wiki/Julia_%28programming_language%29">https://en.wikipedia.org/wiki/Julia_%28programming_language%29</a>
</li>

<li>IJulia<br />
<a href="https://github.com/JuliaLang/IJulia.jl">https://github.com/JuliaLang/IJulia.jl</a>
</li>

<li>Introducing Julia<br />
<a href="https://en.wikibooks.org/wiki/Introducing_Julia">https://en.wikibooks.org/wiki/Introducing_Julia</a>
</li>

<li>Julia: the REPL<br />
<a href="https://en.wikibooks.org/wiki/Introducing_Julia/The_REPL">https://en.wikibooks.org/wiki/Introducing_Julia/The_REPL</a>
</li>

<li>Month of Julia<br />
<a href="https://github.com/DataWookie/MonthOfJulia">https://github.com/DataWookie/MonthOfJulia</a>
</li>

<li>Learn X in Y minutes (where X=Julia)<br />
<a href="https://learnxinyminutes.com/docs/julia/">https://learnxinyminutes.com/docs/julia/</a>
</li>

<li>New Julia language seeks to be the C for scientists<br />
<a href="http://www.infoworld.com/article/2616709/application-development/new-julia-language-seeks-to-be-the-c-for-scientists.html">http://www.infoworld.com/article/2616709/application-development/new-julia-language-seeks-to-be-the-c-for-scientists.html</a>
</li>

<li>Julia: A Fast Dynamic Language for Technical Computing<br />
<a href="http://karpinski.org/publications/2012/julia-a-fast-dynamic-language">http://karpinski.org/publications/2012/julia-a-fast-dynamic-language</a>
</li>

<li>The LLVM Compiler Infrastructure<br />
<a href="http://llvm.org/">http://llvm.org/</a>
</li>

<li>Julia: benchmarks<br />
<a href="http://julialang.org/benchmarks/">http://julialang.org/benchmarks/</a>
</li>

<li>Type system<br />
<a href="https://en.wikipedia.org/wiki/Type_system">https://en.wikipedia.org/wiki/Type_system</a>
</li>

<li>Half-precision floating-point format<br />
<a href="https://en.wikipedia.org/wiki/Half-precision_floating-point_format">https://en.wikipedia.org/wiki/Half-precision_floating-point_format</a>
</li>

<li>These are a few of my Favourite Things (that are coming with Julia 1.0)<br />
<a href="https://white.ucc.asn.au/2018/06/01/Julia-Favourite-New-Things.html">https://white.ucc.asn.au/2018/06/01/Julia-Favourite-New-Things.html</a>
</li>

<li>A Julia Language Blog Aggregator<br />
<a href="https://www.juliabloggers.com/">https://www.juliabloggers.com/</a>
</li>

<li>What is the difference between 1.0 and 1. ?<br />
<a href="https://groups.google.com/forum/#!topic/julia-users/aycsd2iAktE">https://groups.google.com/forum/#!topic/julia-users/aycsd2iAktE</a>
</li>

<li>Julia in the classroom<br />
<a href="https://julialang.org/teaching/">https://julialang.org/teaching/</a>
</li>

<li>High-Performance Scientific Computing for Astrophysics<br />
<a href="http://www.personal.psu.edu/~ebf11/teach/astro585/">http://www.personal.psu.edu/~ebf11/teach/astro585/</a>
</li>

<li>Julia Scientific Programming (Coursera)<br />
<a href="https://www.coursera.org/learn/julia-programming">https://www.coursera.org/learn/julia-programming</a>
</li>

<li>Introducing Julia/Controlling the flow<br />
<a href="https://en.wikibooks.org/wiki/Introducing_Julia/Controlling_the_flow">https://en.wikibooks.org/wiki/Introducing_Julia/Controlling_the_flow</a>
</li>

<li>Julia Box: Run Julia in your Browser<br />
<a href="https://juliabox.com/">https://juliabox.com/</a>
</li>

<li>Intro to Julia for data science<br />
<a href="https://www.youtube.com/watch?v=SLE0vz85Rqo">https://www.youtube.com/watch?v=SLE0vz85Rqo</a>
</li>

<li>Intro to dynamical systems in Julia<br />
<a href="https://www.youtube.com/watch?v=13hqE_1a158">https://www.youtube.com/watch?v=13hqE_1a158</a>
</li>

</ol>



<p></p><p></p>
<p><small>Autor: <a href="http://www.fit.vutbr.cz/~tisnovpa">Pavel Tišnovský</a> &nbsp; 2018</small></p>
</body>
</html>

