<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
        "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html>
<head>
<title>Interní reprezentace řetězců v různých programovacích jazycích: od počítačového pravěku po současnost</title>
<meta name="Author" content="Pavel Tisnovsky" />
<meta name="Generator" content="vim" />
<meta http-equiv="content-type" content="text/html; charset=utf-8" />
<style type="text/css">
         body {color:#000000; background:#ffffff;}
         h1  {font-family: arial, helvetica, sans-serif; color:#ffffff; background-color:#c00000; text-align:center; padding-left:1em}
         h2  {font-family: arial, helvetica, sans-serif; color:#ffffff; background-color:#0000c0; padding-left:1em; text-align:left}
         h3  {font-family: arial, helvetica, sans-serif; color:#000000; background-color:#c0c0c0; padding-left:1em; text-align:left}
         h4  {font-family: arial, helvetica, sans-serif; color:#000000; background-color:#e0e0e0; padding-left:1em; text-align:left}
         a   {font-family: arial, helvetica, sans-serif;}
         li  {font-family: arial, helvetica, sans-serif; color:#000000; text-align:justify; width:450px;}
         ol  {font-family: arial, helvetica, sans-serif; color:#000000; text-align:justify; width:450px;}
         ul  {font-family: arial, helvetica, sans-serif; color:#000000; text-align:justify; width:450px;}
         p   {font-family: arial, helvetica, sans-serif; color:#000000; text-align:justify;}
         pre {background:#e0e0e0}
</style>
</head>

<body>

<h1>Interní reprezentace řetězců v různých programovacích jazycích: od počítačového pravěku po současnost</h1>

<h3>Pavel Tišnovský</h3>

<p></p>

<h1>Úvodník</h1>

<p>Textové řetězce &ndash; mohlo by se zdát, že práce s nimi vlastně není žádná věda, jedná se přece (zdánlivě) o pouhopouhou posloupnost znaků. Ve skutečnosti je však tato problematika poměrně rozsáhlá a může být řešena různými způsoby a technikami.</p>



<h2>Obsah</h2>

<p><a href="#k01">*** 1. Interní reprezentace řetězců v&nbsp;různých jazycích: od počítačového pravěku po současnost</a></p>
<p><a href="#k02">2. Assemblery</a></p>
<p><a href="#k03">3. Řetězec bez ukončujícího znaku se známou délkou</a></p>
<p><a href="#k04">4. Řetězec s&nbsp;předem známým ukončujícím znakem</a></p>
<p><a href="#k05">*** 5. Řetězce v&nbsp;původním Pascalu</a></p>
<p><a href="#k06">*** 6. Řetězce v&nbsp;programovacím jazyku C</a></p>
<p><a href="#k07">*** 7. Vylepšení práce s&nbsp;řetězci v&nbsp;UCSD Pascalu a Turbo Pascalu</a></p>
<p><a href="#k08">8. Interpretry a překladače BASICu</a></p>
<p><a href="#k09">9. Řetězce a pole řetězců v&nbsp;Sinclair BASICu</a></p>
<p><a href="#k10">*** 10. Řetězce v&nbsp;Atari BASICu</a></p>
<p><a href="#k11">*** 11. Novější verze Fortranu</a></p>
<p><a href="#k12">*** 12. Příchod moderních programovacích jazyků &ndash; automatická správa paměti, problematika &bdquo;širokých&ldquo; znaků</a></p>
<p><a href="#k13">*** 13. Řetězce podporující Unicode</a></p>
<p><a href="#k14">*** 14. Formát řetězců v&nbsp;Javě</a></p>
<p><a href="#k15">*** 15. Způsob ukládání řetězců na haldě v&nbsp;JVM</a></p>
<p><a href="#k16">*** 16. Řetězce v&nbsp;Rustu</a></p>
<p><a href="#k17">*** 17. Python 3.3 s&nbsp;flexibilní reprezentací řetězců</a></p>
<p><a href="#k18">*** 18. Otestování velikosti objektů typu řetězec v&nbsp;Pythonu 3.4.3</a></p>
<p><a href="#k19">*** 19. Interní reprezentace řetězce v&nbsp;Pythonu 3.4.3</a></p>
<p><a href="#k20">20. Odkazy na Internetu</a></p>



<p><a name="k01"></a></p>
<h2 id="k01">1. Interní reprezentace řetězců v&nbsp;různých jazycích: od počítačového pravěku po současnost</h2>

<p></p>

<ol>

<li>Jsou řetězce neměnitelné (<i>immutable</i>) či měnitelné (<i>mutable</i>)?
Obojí přístup má svoje výhody a samozřejmě i nevýhody. Mimochodem &ndash;
většina dalších otázek se týká především měnitelných řetězců.</li>

<li>Pokud jsou řetězce měnitelné, lze modifikovat i jejich délku či nikoli?
V&nbsp;případě, že je délka měnitelná, znamená to, že runtime jazyka musí
umožňovat realokaci paměti.</li>

<li>Má jazyk rozpoznávat konstantní (statické) řetězce od měnitelných řetězců a
zpracovávat je odlišným způsobem? Asi nejdále byla tato idea rozvinuta
v&nbsp;jazyku Rust.</li>

<li>Pokud je délka řetězce specifikována při jeho deklaraci a nelze ji dále
změnit, co se stane ve chvíli, kdy se do řetězce přidají další znaky či se
naopak znaky odeberou?  Možností je opět více, například uživatelé Sinclair
BASICu asi znají termín Prokrústéúv řetězec používaný u polí řetězců (více viz
další kapitoly).</li>

<li>Jakým způsobem a kde se uloží délka řetězce? K&nbsp;dispozici je několik
možností &ndash; délku může znát jen překladač (původní Pascal, Fortran a
kupodivu i některé moderní jazyky se statickými řetězci), délka může být
uložena ve struktuře obalující řetězec, nebo se může použít vybraný znak
reprezentující konec řetězce.</li>

<li>Má řetězec obsahovat i další metainformace, například o použité kódové
stránce? To je příklad typu AnsiString v&nbsp;Delphi 2009.</li>

<li>Jak budou kódovány znaky v&nbsp;řetězci? Historicky se používal zejména
EBCDIC a ASCII, později se rozšířily i takzvané &bdquo;široké znaky&ldquo; a
dnes je k&nbsp;výběru hned několik možností, jak reprezentovat všechny znaky
z&nbsp;Unicode či jejich podmnožinu.</li>

<li>V&nbsp;případě blokového přenosu (resp.&nbsp;častěji kopie) řetězců je
taktéž nutné odpovědět na otázku, jak přesně se bude pracovat s&nbsp;koncem
řetězce ve chvíli, kdy jeho délka nebude rovna celočíselnému násobku velikosti
přenášené informace (typicky 2, 4 či osm bajtů). Jinými slovy &ndash; může se
rutina pro práci s&nbsp;řetězci dovolit přistupovat ZA konec řetězce či
nikoli?</li>

</ol>



<p><a name="k02"></a></p>
<h2 id="k02">2. Assemblery</h2>

<p>Na stránkách <a href="http://www.root.cz">Rootu</a> jsme se již několikrát
mohli setkat s&nbsp;takzvaným <i>assemblerem</i> neboli jazykem symbolických
instrukcí (<i>JSI</i>), alternativně též nazývaným jazykem symbolických adres
(<i>JSA</i>). Připomeňme si, že se jedná o nižší programovací jazyk,
v&nbsp;němž je možné psát programy na úrovni jednotlivých strojových instrukcí
konkrétního (vybraného) mikroprocesoru. To mimochodem znamená, že vzniklo
prakticky nepřeberné množství assemblerů, mnohdy dokonce více assemblerů pro
jediný typ mikroprocesoru (a naopak, některé assemblery podporují více
architektur CPU). Assemblery vznikly proto, že programování na úrovni
strojového kódu je velmi pracné, zejména ve chvíli, kdy je nutné existující
program modifikovat a tím pádem měnit cílové adresy skoků, adresy globálních
proměnných atd.</p>

<a href="http://www.root.cz/obrazek/210813/"><img src="http://i.iinfo.cz/images/462/dev-8bit-9-prev.png" class="image-210813" width="370" height="264" alt="&#160;" /></a>
<p><i>Obrázek 1: Úryvek programu napsaný v&nbsp;assembleru mikroprocesoru MOS
6502.</i></p>

<p>Assemblery tedy představovaly (a stále představují) mnohem civilizovanější
způsob programování, než přímý zápis strojového kódu. Některé assemblery šly
ještě dále, protože byly vybaveny více či méně dokonalým systémem maker
(s&nbsp;parametry i bez parametrů, popř.s&nbsp;volitelným typem jejich
expanze). Ostatně i z&nbsp;této vlastnosti vychází jejich běžné označení
&ndash; <i>macroassembler</i>.</p>

<a href="http://www.root.cz/obrazek/211571/"><img src="http://i.iinfo.cz/images/322/a2-prev.png" class="image-211571" alt="&#160;" height="264" width="370" /></a>
<p><i>Obrázek 2: Vývojové prostředí Atari Macro Assembleru.</i></p>

<p>Na tomto místě si můžeme položit obvyklou otázku &ndash; jak se vlastně
s&nbsp;řetězci pracuje v&nbsp;assemblerech a jak jsou řetězce reprezentovány?
Vzhledem k&nbsp;tomu, že assembler je v&nbsp;hierarchii programovacích jazyků
umístěn těsně nad strojovým kódem, je asi zřejmé, že reprezentace řetězců bude
odpovídat zvyklostem architektury konkrétního mikroprocesoru a taktéž
požadavkům operačního systému či knihoven, které se z&nbsp;assembleru
volají.</p>

<a href="http://www.root.cz/obrazek/210819/"><img src="http://i.iinfo.cz/images/462/dev-8bit-15-prev.png" class="image-210819" width="360" height="270" alt="&#160;" /></a>
<p><i>Obrázek 3: Vývojové prostředí Zeus Assembleru.</i></p>



<p><a name="k03"></a></p>
<h2 id="k03">3. Řetězec bez ukončujícího znaku se známou délkou</h2>

<p>V&nbsp;tomto článku si ukážeme tři různé příklady, které se vždy týkají
řetězců používajících kódování ASCII. První příklad je naprogramován pro
mikroprocesory s&nbsp;architekturou x86-64 a je určen pro operační systém
Linux. Po překladu a spuštění by se měla na standardní výstup vypsat klasická
zpráva &bdquo;Hello world!&ldquo;, a to s&nbsp;využitím služby jádra operačního
systému <strong>sys_write</strong>, které se předá file deskriptor standardního
výstupu, adresa řetězce a jeho délka:</p>

<pre>
# asmsyntax=as
&nbsp;
&nbsp;
# Linux kernel system call table
sys_exit=1
sys_write=4
&nbsp;
&nbsp;
&nbsp;
#-----------------------------------------------------------------------------
.section .data
&nbsp;
hello_lbl:
        <strong>.string "Hello World!\n"</strong>
&nbsp;
#-----------------------------------------------------------------------------
.section .text
        .global _start          # tento symbol ma byt dostupny i linkeru
&nbsp;
_start:
        mov   $sys_write, %eax  # cislo syscallu pro funkci "write"
        mov   $1,%ebx           # standardni vystup
        mov   <strong>$hello_lbl</strong>,%ecx   # adresa retezce, ktery se ma vytisknout
        mov   <strong>$13</strong>,%edx          # pocet znaku, ktere se maji vytisknout
        int   $0x80             # volani Linuxoveho kernelu
&nbsp;
        movl  $sys_exit,%eax    # cislo sycallu pro funkci "exit"
        movl  $0,%ebx           # exit code = 0
        int   $0x80             # volani Linuxoveho kernelu
</pre>

<p>Povšimněte si, že řetězec je v&nbsp;tomto případě reprezentován jako sled
znaků, ovšem to samozřejmě <strong>nestačí</strong> &ndash; funkci jádra musíme
dodat i informaci o adrese začátku řetězce a navíc i jeho délku (počet znaků).
Díky tomu, že se délka řetězce předává v&nbsp;samostatném parametru, nemusí být
řetězec ukončen speciálním znakem (tak, jak je tomu v&nbsp;dalších
příkladech):</p>

<p>Pro architekturu AArch64 bude kód nepatrně odlišný (už jen proto, že se
změnily čísla syscallů), ovšem s&nbsp;řetězci se bude pracovat shodně:</p>

<pre>
# Linux kernel system call table
sys_exit=93
sys_write=64
&nbsp;
# List of syscalls for AArch64:
# https://github.com/torvalds/linux/blob/master/include/uapi/asm-generic/unistd.h
&nbsp;
&nbsp;
&nbsp;
#-----------------------------------------------------------------------------
.section .data
&nbsp;
hello_lbl:
        <strong>.string "Hello World!\n"</strong>
&nbsp;
#-----------------------------------------------------------------------------
.section .text
        .global _start          // tento symbol ma byt dostupny i linkeru
&nbsp;
_start:
        mov  x8, #sys_write     // cislo sycallu pro funkci "write"
        mov  x0, #1             // standardni vystup
        ldr  x1, <strong>=hello_lbl</strong>     // adresa retezce, ktery se ma vytisknout
        mov  x2, <strong>#13</strong>            // pocet znaku, ktere se maji vytisknout
        svc  0                  // volani Linuxoveho kernelu
&nbsp;
        mov  x8, #sys_exit      // cislo sycallu pro funkci "exit"
        mov  x0, #0             // exit code = 0
        svc  0                  // volani Linuxoveho kernelu
</pre>



<p><a name="k04"></a></p>
<h2 id="k04">4. Řetězec s&nbsp;předem známým ukončujícím znakem</h2>

<p>Zatímco první příklad byl určen pro moderní operační systém (Linux) i pro
moderní mikroprocesory (x86-64 a AArch64), pochází druhý assemblerovský příklad
z&nbsp;poměrně dávné počítačové historie, konkrétně z&nbsp;dob kralování
různých variant DOSu. Tento příklad, který poběží na všech mikroprocesorech
řady Intel 8086, po svém překladu a spuštění taktéž vypíše zprávu na standardní
výstup <a
href="https://en.wikipedia.org/wiki/MS-DOS_API#DOS_INT_21h_services">službou
číslo 9</a>, dále počká na stisk klávesy a následně se program ukončí
(v&nbsp;případě COM programů stačí pro ukončení instrukce
<strong>RET</strong>).</p>

<p>Opět se zaměřme na to, jak jsou reprezentovány řetězce. Nyní není
reprezentace určena instrukční sadou ani snahou o kompatibilitu s&nbsp;vyššími
programovacími jazyky, ale konvencemi použitého operačního systému, které
v&nbsp;některých případech byly mimochodem &bdquo;vypůjčeny&ldquo; ze staršího
systému CP/M. Tyto konvence říkají, že při volání některých služeb jádra jsou
řetězce ukončeny znakem $, takže jsme v&nbsp;assembleru museli tento znak
<i>explicitně</i> zapsat (assembler to za nás v&nbsp;tomto případě neudělá
automaticky). Vzhledem k&nbsp;tomu, že systém přesně ví, kde je řetězec
ukončen, nemusí se službě jádra předávat jeho délka:</p>

<pre>
ideal
model   tiny                    ;pametovy model CS=DS=SS mensi nez 64kB
p286                            ;povoleny instrukce procesoru 286+
&nbsp;
;-----------------------------------------------------------------------------
dataseg                         ;zacatek data-segmentu
&nbsp;
message   db      <strong>"Hello world!$"</strong>
&nbsp;
;-----------------------------------------------------------------------------
codeseg                         ;zacatek code-segmentu
org     0100h                   ;zacatek kodu pro programy typu COM
&nbsp;
start:
&nbsp;
;------ Tisk retezce na obrazovku
        mov     dx, <strong>offset message</strong>
        mov     ah, 9
        int     21h
&nbsp;
;------ Vyprazdnit buffer klavesnice a cekat na klavesu
        xor     ax, ax
        int     16h
&nbsp;
;------ Ukonceni procesu
        retn
end start
</pre>

<p>Vzhledem ke značné flexibilitě assembleru v&nbsp;něm můžeme řetězce
reprezentovat takovými způsoby, které budou vyhovovat vyšším programovacím
jazykům a jejich knihovnám. V&nbsp;dalším příkladu se snažíme z&nbsp;assembleru
volat známou funkci <strong>putc()</strong> ze standardní knihovny jazyka C.
V&nbsp;céčku jsou řetězce uloženy jako sekvence znaků s&nbsp;ukončujícím znakem
s&nbsp;kódem 0 (dnes jde většinou o znak NUL z&nbsp;ASCII), takže před voláním
céčkovské funkce budeme muset připravit řetězce v&nbsp;tomto vyžadovaném
formátu. To není prakticky žádný problém, protože pouze za vlastní sekvenci
znaků přidáme nulu popř.&nbsp;můžeme v&nbsp;některých assemblerech použít makro
či direktivu pojmenovanou například <strong>.asciz</strong> (GNU Assembler) či
<strong>ASCIIZ</strong> (původní assembler pro PDP-10), která nulu doplní
automaticky a samozřejmě pro ni zarezervuje bajt v&nbsp;operační paměti:</p>

<pre>
# asmsyntax=as
&nbsp;
# Program pro otestovani volani funkci ze standardni knihovny jazyka C
# - volani funkce 'puts'
&nbsp;
.intel_syntax noprefix
&nbsp;
&nbsp;
&nbsp;
#-----------------------------------------------------------------------------
.section .data
hello_world_message:
        <strong>.asciz "Hello world!\n"</strong>    # zprava, ktera se ma vytisknout na standardni vystup
&nbsp;
&nbsp;
&nbsp;
#-----------------------------------------------------------------------------
.section .text
        .global main               # tento symbol ma byt dostupny i linkeru
&nbsp;
main:
        sub  rsp, 8                # zajistit zarovnani RSP na adresu delitelnou 16
&nbsp;
                                   # jedinym parametrem je adresa zpravy
        mov  rdi, <strong>offset hello_world_message</strong>
        call puts                  # volani funkce 'puts' ze standardni knihovny
&nbsp;
        add  rsp, 8                # obnoveni puvodni hodnoty RSP
&nbsp;
        xor  eax, eax              # navratova hodnota (exit status)
        ret                        # ukonceni aplikace
</pre>



<p><a name="k05"></a></p>
<h2 id="k05">5. Řetězce v&nbsp;původním Pascalu</h2>



<p><a name="k06"></a></p>
<h2 id="k06">6. Řetězce v&nbsp;programovacím jazyku C</h2>



<p><a name="k07"></a></p>
<h2 id="k07">7. Vylepšení práce s&nbsp;řetězci v&nbsp;UCSD Pascalu a Turbo Pascalu</h2>



<p><a name="k08"></a></p>
<h2 id="k08">8. Interpretry a překladače BASICu</h2>

<p>Při popisu vývoje různých způsobů reprezentace řetězců samozřejmě nesmíme
zapomenout ani programovací jazyk, jehož více či méně kvalitní dialekty
existovaly prakticky pro všechny typy domácích (ale i profesionálních)
osmibitových počítačů. Jedná se samozřejmě o jazyk <i>BASIC</i> (<i>Beginner's
All-purpose Symbolic Instruction Code</i>), jehož syntaxe a především sémantika
pozitivně ale i negativně ovlivnily celou jednu generaci programátorů (včetně
autora tohoto článku :-). Ovšem tento programovací jazyk je z&nbsp;historického
hlediska zajímavý i proto, že se v&nbsp;souvislosti s&nbsp;jeho vývojem poprvé
objevují jména Bill Gates a Paul Allen spolu s&nbsp;jejich společností původně
nazývanou <i>Micro-Soft</i>.</p> 

<a href="http://www.root.cz/obrazek/210821/"><img src="http://i.iinfo.cz/images/462/dev-8bit-17-prev.png" class="image-210821" width="215" height="270" alt="&#160;" /></a>
<p><i>Obrázek 4: Manuál k&nbsp;původnímu BASICu.</i></p>

<p>Programovací jazyk <i>BASIC</i> byl vyvinut v&nbsp;roce 1964 J. G. Kemenym a
T. E. Kurtzem na universitě v&nbsp;Dartmouthu. Kemeny a Kurtz tento jazyk
navrhli s&nbsp;ohledem na to, aby umožnili rychlé osvojení ovládání počítačů i
jejich programování pracovníkům a studentům, kteří nejsou (a ani nechtějí být)
specialisty na programování, ale potřebují problémy řešené v&nbsp;jejich praxi
vhodným způsobem algoritmizovat a následně vhodným způsobem zapsat tak, aby
počítač mohl zapsané algoritmy skutečně provést. Důraz na co největší
jednoduchost jazyka se projevil například omezením počtu proměnných na 26,
automatickou deklarací a inicializací proměnných (což je u větších programů
velmi záludná vlastnost), existencí (původně) pouze jednoho datového typu
atd.</p>

<a href="http://www.root.cz/obrazek/210823/"><img src="http://i.iinfo.cz/images/462/dev-8bit-19-prev.jpg" class="image-210823" width="364" height="270" alt="&#160;" /></a>
<p><i>Obrázek 5: BASIC pro mikropočítače Apple-II.</i></p>



<p><a name="k09"></a></p>
<h2 id="k09">9. Řetězce a pole řetězců v&nbsp;Sinclair BASICu</h2>

<p>Zajímavé je, že první verze BASICu práci s&nbsp;řetězci vlastně vůbec
nepodporovala; tato velmi důležitá funkcionalita byla do jazyka přidána až o
rok později, tedy v&nbsp;roce 1965. Od té doby se však jednalo o nezbytnou
součást BASICu, i když funkce a operace pro práci s&nbsp;řetězci byly
v&nbsp;různých dialektech dosti odlišné. Pro představení dvou způsobů uložení
řetězců se podívejme na Sinclair Basic a Atari Basic, což jsou dva interpretry,
které se od sebe v&nbsp;mnoha ohledech velmi liší.</p>

<a href="http://www.root.cz/obrazek/210827/"><img src="http://i.iinfo.cz/images/462/dev-8bit-23-prev.png" class="image-210827" width="357" height="270" alt="&#160;" /></a>
<p><i>Obrázek 6: BASIC na slavném mikropočítači ZX-81.</i></p>

<p>Sinclair Basic podporuje práci s&nbsp;běžnými řetězci, které mohou mít
flexibilní délku, není nutné dopředu udávat jejich velikost a lze s&nbsp;nimi
provádět řadu zajímavých operací díky podpoře takzvaného &bdquo;slicingu&ldquo;
(specifikaci podřetězce zadáním indexu prvního a posledního znaku):</p>

<pre>
10 LET a$="abcdef"
20 FOR n=1 TO 6
30 PRINT a$(n TO 6)
40 NEXT n
50 STOP
</pre>

<p>Kromě běžných řetězců lze v&nbsp;Sinclair Basicu pracovat i s&nbsp;poli
řetězců, ovšem v&nbsp;tomto případě mají řetězce uložené v&nbsp;poli konstantní
velikost specifikovanou při vytváření pole příkazem <strong>DIM</strong>.
Všechny operace s&nbsp;řetězci uloženými v&nbsp;poli zajistí, že se nezmění
délka řetězce &ndash; kratší řetězce jsou doplněny na plnou délku, potenciálně
delší řetězce jsou uříznuty, opět tak, aby se řetězec nezvětšil nebo nedošlo
k&nbsp;přepisu paměti, která mu nepatří. Toto chování se někdy nazývá
Prokrústéovo přiřazení podle postavy <a
href="https://cs.wikipedia.org/wiki/Prokr%C3%BAst%C3%A9s">Prokrústéa</a>
z&nbsp;řecké mytologie (ten ovšem nepracoval s&nbsp;řetězci, ale s&nbsp;lidmi
:-).</p>

<a href="http://www.root.cz/obrazek/210833/"><img src="http://i.iinfo.cz/images/462/dev-8bit-29.png" class="image-210833" width="256" height="192" alt="&#160;" /></a>
<p><i>Obrázek 7: Editace programu na ZX Spectru v&nbsp;řádkovém
editoru.</i></p>

<p>Interně jsou řetězce uloženy ve formátu naznačeném na osmém obrázku.
Povšimněte si, že pro jméno řetězce zbylo jen pět bitů, takže jméno může být
jen jednopísmenné. Délka řetězce je &ndash; z&nbsp;pohledu kapacity operační
paměti ZX Spectra &ndash; neomezená, což je velký rozdíl oproti klasickým
&bdquo;Pascalovským řetězcům&ldquo; omezeným na 255 znaků.</p>

*** image ***
<p><i>Obrázek 8: Formát uložení řetězců.</i></p>



<p><a name="k10"></a></p>
<h2 id="k10">10. Řetězce v&nbsp;Atari BASICu</h2>

*** image ***
<p><i>Obrázek 9: </i></p>

*** image ***
<p><i>Obrázek 10: </i></p>

*** image ***
<p><i>Obrázek 11: </i></p>

*** image ***
<p><i>Obrázek 12: </i></p>

*** image ***
<p><i>Obrázek 13: </i></p>



<p><a name="k11"></a></p>
<h2 id="k11">11. Novější verze Fortranu</h2>

<a href="http://i.iinfo.cz/images/38/ibm-5-4.jpg"><img src="http://i.iinfo.cz/images/38/ibm-5-4-prev.jpg" alt="ibm-5" height="270" width="191" /></a>
<p><i>Obrázek 14: Spolu s&nbsp;rozšiřováním Fortranu z&nbsp;mainframů firmy IBM
na další architektury se zvyšovala potřeba standardizace tohoto jazyka.
Postupně vzniklo několik norem, například ANSI norma FORTRAN 66, FORTRAN 77, či
ANSI/ISO standard Fortran 90 (názvy standardů jsou uvedeny správně &ndash;
jméno jazyka se skutečně postupem času změnilo z &bdquo;FORTRAN&ldquo; na
&bdquo;Fortran&ldquo;).</i></p>



<p><a name="k12"></a></p>
<h2 id="k12">12. Příchod moderních programovacích jazyků &ndash; automatická správa paměti, problematika &bdquo;širokých&ldquo; znaků</h2>



<p><a name="k13"></a></p>
<h2 id="k13">13. Řetězce podporující Unicode</h2>



<p><a name="k14"></a></p>
<h2 id="k14">14. Formát řetězců v&nbsp;Javě</h2>



<p><a name="k15"></a></p>
<h2 id="k15">15. Způsob ukládání řetězců na haldě v&nbsp;JVM</h2>



<p><a name="k16"></a></p>
<h2 id="k16">16. Řetězce v&nbsp;Rustu</h2>



<p><a name="k17"></a></p>
<h2 id="k17">17. Python 3.3 s&nbsp;flexibilní reprezentací řetězců</h2>

<p></p>

<table>
<tr><th>Šířka znaku</th><th>Kódování</th><th>Prefix při zápisu kódu</th></tr>
<tr><td>1 bajt</td><td>Latin-1</td><td>\x</td></tr>
<tr><td>2 bajty</td><td>UCS-2</td><td>\u</td></tr>
<tr><td>4 bajty</td><td>UCS-4</td><td>\U</td></tr>
</table>



<p><a name="k18"></a></p>
<h2 id="k18">18. Otestování velikosti objektů typu řetězec v&nbsp;Pythonu 3.4.3</h2>

<p></p>

<pre>
Python 3.4.3 (default, Nov 17 2016, 01:08:31) 
[GCC 4.8.4] on linux
Type "help", "copyright", "credits" or "license" for more information.
&gt;&gt;&gt; import sys
</pre>

<p></p>

<pre>
&gt;&gt;&gt; sys.getsizeof("")
49
</pre>

<p></p>

<pre>
&gt;&gt;&gt; sys.getsizeof("e")
50
&gt;&gt;&gt; sys.getsizeof("e 123456789")
60
</pre>

<p></p>

<pre>
&gt;&gt;&gt; sys.getsizeof("ě")
76
</pre>

<p></p>

<pre>
&gt;&gt;&gt; sys.getsizeof("ě 123456789")
96
</pre>

<p></p>

<pre>
&gt;&gt;&gt; sys.getsizeof("\U0001ffff")
80
&gt;&gt;&gt; sys.getsizeof("\U0001ffff 123456789")
120
</pre>



<p><a name="k19"></a></p>
<h2 id="k19">19. Interní reprezentace řetězce v&nbsp;Pythonu 3.4.3</h2>

<p></p>



<p><a name="k20"></a></p>
<h2 id="k20">20. Odkazy na Internetu</h2>

<ol>

<li>The Most Expensive One-byte Mistake: Did Ken, Dennis, and Brian choose wrong with NUL-terminated text strings?<br />
<a href="http://queue.acm.org/detail.cfm?id=2010365">http://queue.acm.org/detail.cfm?id=2010365</a>
</li>

<li>UCSD Pascal<br />
<a href="https://en.wikipedia.org/wiki/UCSD_Pascal">https://en.wikipedia.org/wiki/UCSD_Pascal</a>
</li>

<li>D Language: Strings<br />
<a href="https://dlang.org/spec/arrays.html#strings">https://dlang.org/spec/arrays.html#strings</a>
</li>

<li>The History Behind the Definition of a 'String'<br />
<a href="https://stackoverflow.com/questions/880195/the-history-behind-the-definition-of-a-string">https://stackoverflow.com/questions/880195/the-history-behind-the-definition-of-a-string</a>
</li>

<li>Libc: Representation of Strings<br />
<a href="https://www.gnu.org/software/libc/manual/html_node/Representation-of-Strings.html">https://www.gnu.org/software/libc/manual/html_node/Representation-of-Strings.html</a>
</li>

<li>ATARI BASIC<br />
<a href="http://www.atariarchives.org/dere/chapt10.php">http://www.atariarchives.org/dere/chapt10.php</a>
</li>

<li>BASIC (Wikipedia EN)<br />
<a href="http://en.wikipedia.org/wiki/BASIC">http://en.wikipedia.org/wiki/BASIC</a>
</li>

<li>BASIC (Wikipedia CZ)<br />
<a href="http://cs.wikipedia.org/wiki/BASIC">http://cs.wikipedia.org/wiki/BASIC</a>
</li>

<li>Turbo BASIC (Wikipedia CZ)<br />
<a href="http://cs.wikipedia.org/wiki/Turbo_BASIC">http://cs.wikipedia.org/wiki/Turbo_BASIC</a>
</li>

<li>Sinclair BASIC (Wikipedia CZ)<br />
<a href="http://cs.wikipedia.org/wiki/Sinclair_BASIC">http://cs.wikipedia.org/wiki/Sinclair_BASIC</a>
</li>

<li>More BASIC Computer Games<br />
<a href="http://www.atariarchives.org/morebasicgames/">http://www.atariarchives.org/morebasicgames/</a>
</li>

<li>Dartmouth College Computation Center: 1964 &ndash; The original Dartmouth BASIC manual<br />
<a href="http://www.bitsavers.org/pdf/dartmouth/BASIC_Oct64.pdf">http://www.bitsavers.org/pdf/dartmouth/BASIC_Oct64.pdf</a>
</li>

<li>The Original BASIC<br />
<a href="http://www.truebasic.com/">http://www.truebasic.com/</a>
</li>

<li>BASIC - Beginners All-purpose Symbolic Instruction Code<br />
<a href="http://hopl.murdoch.edu.au/showlanguage.prx?exp=176">http://hopl.murdoch.edu.au/showlanguage.prx?exp=176</a>
</li>

<li>Universal Coded Character Set<br />
<a href="https://en.wikipedia.org/wiki/Universal_Coded_Character_Set">https://en.wikipedia.org/wiki/Universal_Coded_Character_Set</a>
</li>

<li>UTF-16<br />
<a href="https://en.wikipedia.org/wiki/UTF-16">https://en.wikipedia.org/wiki/UTF-16</a>
</li>

<li>PEP 393 -- Flexible String Representation<br />
<a href="https://www.python.org/dev/peps/pep-0393/">https://www.python.org/dev/peps/pep-0393/</a>
</li>

<li>In-memory size of a Python structure<br />
<a href="https://stackoverflow.com/questions/1331471/in-memory-size-of-a-python-structure">https://stackoverflow.com/questions/1331471/in-memory-size-of-a-python-structure</a>
</li>

<li>What is internal representation of string in Python 3.x<br />
<a href="https://stackoverflow.com/questions/1838170/what-is-internal-representation-of-string-in-python-3-x#9079985">https://stackoverflow.com/questions/1838170/what-is-internal-representation-of-string-in-python-3-x#9079985</a>
</li>

<li>How to profile memory usage in Python<br />
<a href="https://www.pluralsight.com/blog/tutorials/how-to-profile-memory-usage-in-python">https://www.pluralsight.com/blog/tutorials/how-to-profile-memory-usage-in-python</a>
</li>

<li>What's the rationale for null terminated strings?<br />
<a href="https://stackoverflow.com/questions/4418708/whats-the-rationale-for-null-terminated-strings">https://stackoverflow.com/questions/4418708/whats-the-rationale-for-null-terminated-strings</a>
</li>

<li>Unicode<br />
<a href="https://en.wikipedia.org/wiki/Unicode">https://en.wikipedia.org/wiki/Unicode</a>
</li>

<li>The Development of the C Language<br />
<a href="https://www.bell-labs.com/usr/dmr/www/chist.html">https://www.bell-labs.com/usr/dmr/www/chist.html</a>
</li>

<li>Borland Pascal Wiki: String operations<br />
<a href="http://borlandpascal.wikia.com/wiki/String_operations">http://borlandpascal.wikia.com/wiki/String_operations</a>
</li>

<li>Pascal Strings<br />
<a href="https://www.tutorialspoint.com/pascal/pascal_strings.htm">https://www.tutorialspoint.com/pascal/pascal_strings.htm</a>
</li>

<li>PChar - Null terminated strings<br />
<a href="https://www.freepascal.org/docs-html/ref/refsu12.html">https://www.freepascal.org/docs-html/ref/refsu12.html</a>
</li>

<li>Comparison of Pascal and C<br />
<a href="https://en.wikipedia.org/wiki/Comparison_of_Pascal_and_C">https://en.wikipedia.org/wiki/Comparison_of_Pascal_and_C</a>
</li>

<li>FORTRAN 66<br />
<a href="http://fortranwiki.org/fortran/show/FORTRAN+66">http://fortranwiki.org/fortran/show/FORTRAN+66</a>
</li>

<li>Fortran: strings<br />
<a href="https://en.wikibooks.org/wiki/Fortran/strings">https://en.wikibooks.org/wiki/Fortran/strings</a>
</li>

</ol>



<p></p><p></p>
<p><small>Autor: <a href="http://www.fit.vutbr.cz/~tisnovpa">Pavel Tišnovský</a> &nbsp; 2017</small></p>
</body>
</html>

