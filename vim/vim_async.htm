<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
        "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html>
<head>
<title></title>
<meta name="Author" content="Pavel Tisnovsky" />
<meta name="Generator" content="vim" />
<meta http-equiv="content-type" content="text/html; charset=utf-8" />
<style type="text/css">
         body {color:#000000; background:#ffffff;}
         h1  {font-family: arial, helvetica, sans-serif; color:#ffffff; background-color:#c00000; text-align:center; padding-left:1em}
         h2  {font-family: arial, helvetica, sans-serif; color:#ffffff; background-color:#0000c0; padding-left:1em; text-align:left}
         h3  {font-family: arial, helvetica, sans-serif; color:#000000; background-color:#c0c0c0; padding-left:1em; text-align:left}
         h4  {font-family: arial, helvetica, sans-serif; color:#000000; background-color:#e0e0e0; padding-left:1em; text-align:left}
         a   {font-family: arial, helvetica, sans-serif;}
         li  {font-family: arial, helvetica, sans-serif; color:#000000; text-align:justify; width:450px;}
         ol  {font-family: arial, helvetica, sans-serif; color:#000000; text-align:justify; width:450px;}
         ul  {font-family: arial, helvetica, sans-serif; color:#000000; text-align:justify; width:450px;}
         p   {font-family: arial, helvetica, sans-serif; color:#000000; text-align:justify;}
         pre {background:#e0e0e0}
</style>
</head>

<body>

<h1></h1>

<h3>Pavel Tišnovský</h3>

<p></p>

<h1>Úvodník</h1>

<p></p>



<h2>Obsah</h2>

<p><a href="#k01">*** 1. Pluginy využívající asynchronní volání ve Vimu</a></p>
<p><a href="#k02">*** 2. Podpora pro práci s&nbsp;datovým formátem JSON</a></p>
<p><a href="#k03">*** 3. Anonymní funkce</a></p>
<p><a href="#k04">*** 4. Reference na funkce</a></p>
<p><a href="#k05">*** 5. Časovače: cesta k&nbsp;asynchronnímu kódu</a></p>
<p><a href="#k06">*** 6. Vytvoření a použití několika časovačů</a></p>
<p><a href="#k07">*** 7. Kanály (channels)</a></p>
<p><a href="#k08">*** 8. Vytvoření kanálu a přenos dat</a></p>
<p><a href="#k09">*** 9. Úlohy (jobs)</a></p>
<p><a href="#k10">*** 10. Využití synergie mezi všemi zmíněnými technologiemi: skutečně fungující asynchronně běžící skripty</a></p>
<p><a href="#k11">*** 11. Plugin <strong>asyncrun</strong></a></p>
<p><a href="#k12">*** 12. Instalace pluginu <strong>asyncrun</strong></a></p>
<p><a href="#k13">*** 13. Použití pluginu <strong>asyncrun</strong></a></p>
<p><a href="#k14">*** 14. Plugin <strong>agrep</strong></a></p>
<p><a href="#k15">*** 15. Použití pluginu <strong>agrep</strong></a></p>
<p><a href="#k16">*** 16. Plugin <strong>amake</strong></a></p>
<p><a href="#k17">*** 17. Použití pluginu <strong>amake</strong></a></p>
<p><a href="#k18">*** 18. Interní funkce těchto pluginů</a></p>
<p><a href="#k19">*** 19. </a></p>
<p><a href="#k20">*** 20. Odkazy na Internetu</a></p>



<p><a name="k01"></a></p>
<h2 id="k01">1. Pluginy využívající asynchronní volání ve Vimu</h2>



<p><a name="k02"></a></p>
<h2 id="k02">2. Podpora pro práci s&nbsp;datovým formátem JSON</h2>

<p>Na první pohled sice možná ne příliš výraznou, ale o to důležitější a užitečnější novinkou, je přidání čtyř nových funkcí do skriptovacího engine Vimu. Tyto čtyři funkce slouží pro převod datových struktur VimScriptu do JSON formátu a zpět. Proč je vlastně tato novinka tak důležitá? Souvisí totiž s&nbsp;další novou technologií, konkrétně s&nbsp;úlohami (<i>jobs</i>) a kanály (<i>channels</i>). Úlohy umožňují přesně definovaným způsobem vytvářet pluginy (i externí pluginy) s&nbsp;tím, že tyto pluginy mohou běžet asynchronně, tj.&nbsp;částečně nezávisle na samotném Vimu. Důležité je, že pluginy s&nbsp;Vimem komunikují právě přes JSON formát, což je pěkně navržené řešení, protože <a href="http://json.org/">JSON</a> je dnes podporovaný v&nbsp;prakticky všech relevantních programovacích jazycích, v&nbsp;nichž se externí pluginy většinou píšou (typicky se jedná o Python, ale lze použít i jazyk Lua apod.).</p>

<p>Skriptovací engine Vimu nabízí programátorům dvě funkce určené pro převod datových struktur do formátu JSON (<i>encode</i>) a dvě funkce určené pro parsování JSON dat do interních struktur VimScriptu (<i>decode</i>). Dvě varianty jsou implementovány z&nbsp;toho důvodu, že někdy je zapotřebí, aby byly klíče objektů (či slovníků) reprezentovány řetězci a jinde se může jednat o identifikátory bez uvozovek (záleží na konkrétní situaci):</p>

<table>
<tr><th>Funkce</th><th>Stručný popis</th></tr>
<tr><td><strong>json_encode(výraz)</strong></td><td>převod výrazu do JSON formátu, který se vrátí ve formě řetězce</td></tr>
<tr><td><strong>json_decode(řetězec)</strong></td><td>opak předchozí funkce, parsování řetězce s&nbsp;daty uloženými v&nbsp;JSON formátu do interních datových struktur VimScriptu</td></tr>
<tr><td><strong>js_encode(výraz)</strong></td><td>podobné funkci <strong>json_encode()</strong>, ovšem klíče nejsou umístěny v&nbsp;uvozovkách</td></tr>
<tr><td><strong>js_decode(řetězec)</strong></td><td>podobné funkci <strong>json_decode()</strong>, ovšem při parsingu se nevyžaduje, aby byly klíče umístěny v&nbsp;uvozovkách</td></tr>
</table>

<p><div class="rs-tip-major">Poznámka: převod do JSON formátu se někdy nazývá <i>serializace</i>, zpětný převod pak pochopitelně <i>deserializace</i>.</div></p>

<p>Ve VimScriptu existuje celkem deset datových typů, přičemž pět z&nbsp;těchto typů do jisté míry koresponduje s&nbsp;typy používanými ve formátu JSON (Number, Float, String, List a Dictionary) a dva další typy (Boolean, None) lze taktéž do formátu JSON převést, pokud se ovšem dodrží určitá pravidla. Výše zmíněné čtyři funkce <strong>json_encode(), json_decode(), js_encode()</strong> a <strong>js_decode()</strong> provádí převody mezi jednotlivými typy (resp.&nbsp;mezi hodnotami různých typů) zcela automaticky, ovšem existuje několik potenciálně problematických výjimek, kterými se budeme zabývat v&nbsp;navazujících kapitolách. V&nbsp;následující tabulce jsou vypsány korespondující datové typy. Povšimněte si, že v&nbsp;JSON formátu se nerozlišuje mezi celými čísly a čísly s&nbsp;plovoucí řádovou čárkou, což do značné míry souvisí s&nbsp;původním návrhem tohoto formátu založeném na JavaScriptu:</p>

<table>
<tr><th>Typ ve VimScriptu</th><th>Převod do JSONu</th></tr>
<tr><td>Number</td><td>celé číslo, výjimky viz <a href="#k07">sedmou kapitolu</a></td></tr>
<tr><td>Float</td><td>číslo s desetinnou čárkou a/nebo exponentem</td></tr>
<tr><td>String</td><td>řetězec umístěný v&nbsp;uvozovkách</td></tr>
<tr><td>List</td><td>pole hodnot, viz <a href="#k05">pátou kapitolu</a></td></tr>
<tr><td>Dictionary</td><td>objekt (asociativní pole), viz <a href="#k06">šestou kapitolu</a></td></tr>
<tr><td>Funcref</td><td>nelze (teoreticky by se jednalo o serializaci kódu)</td></tr>
<tr><td>Boolean</td><td>True/False (viz <a href="#k08">kapitolu číslo 8</a>)</td></tr>
<tr><td>None</td><td>Null (viz <a href="#k08">kapitolu číslo 8</a>)</td></tr>
<tr><td>Job</td><td>nelze</td></tr>
<tr><td>Channel</td><td>nelze</td></tr>
</table>



<p><a name="k03"></a></p>
<h2 id="k03">3. Anonymní funkce</h2>

<p>Poměrně významnou novinkou, kterou nalezneme ve skriptovacím jazyku VimScript, jsou anonymní funkce (někdy se setkáme s&nbsp;možná přiléhavějším názvem <i>lambdy</i>, což je označení vycházející z&nbsp;lambda kalkulu). Anonymní funkce je možné použít ve všech místech programového kódu, kde jsou očekávány takzvané reference na funkce (<i>funcrefs</i>). Zápis anonymní funkce se v&nbsp;několika ohledech odlišuje od zápisu běžné funkce. Parametry i samotné tělo funkce jsou totiž umístěny do složených závorek {} a mezi parametry a tělem funkce se zapisuje dvojice znaků -&gt; (u parametrů se nemusí používat prefix a:, který je u běžných funkcí vyžadován). Velmi jednoduchou anonymní funkci, která po svém zavolání vrátí součet svých dvou parametrů, lze zapsat takto:</p>

<pre>
{x,y -&gt; x + y}
</pre>

<p>Volání takové funkce může vypadat například takto:</p>

<pre>
:echo {x,y -&gt; x + y}(1,2)
</pre>

<p><div class="rs-tip-major">Poznámka: ve skutečnosti není dvojtečka na začátku nutná ve chvíli, kdy se funkce volá ze skriptu (souboru s&nbsp;koncovkou <strong>.vim</strong>). Ovšem s&nbsp;dvojtečkou si můžeme volání funkce otestovat přímo z&nbsp;příkazového řádku Vimu.</div></p>

<p>Alternativně lze anonymní funkci přiřadit do proměnné (a tak ji vlastně pojmenovat):</p>

<pre>
:let Fce={x,y -&gt; x + y}
:echo Fce(1,2)
3
</pre>



<p><a name="k04"></a></p>
<h2 id="k04">4. Reference na funkce</h2>

<p><a href="#k03">V&nbsp;předchozí kapitole</a> jsme se &ndash; prozatím bez dalšího vysvětlení &ndash; setkali s&nbsp;termínem &bdquo;reference na funkci&ldquo; či zkráceně &bdquo;funcref&ldquo;. Nejedná se sice o nový koncept zavedený až ve Vimu 8, ale vzhledem k&nbsp;tomu, že se s&nbsp;referencemi na funkce setkáme i v&nbsp;několika dalších demonstračních příkladech, si stručně vysvětlíme, o co se vlastně jedná. Reference na funkci obsahuje odkaz na existující funkci (přičemž nás nezajímá, jak konkrétně je tento odkaz reprezentován) a lze ji považovat za plnohodnotný datový typ skriptovacího jazyka VimScript, což znamená, že reference na funkce lze ukládat do proměnných (globálních i lokálních) či je předávat do jiných funkcí (takzvaných funkcí vyššího řádu). Reference na existující funkci se získá zavoláním <strong>function(jméno_funkce)</strong>, tedy například následujícím způsobem:</p>

<pre>
function! DoubleValue(index, value)
    return a:value * 2
endfunction
&nbsp;
let Funcref = function("DoubleValue")
</pre>

<p><div class="rs-tip-major">Poznámka: povšimněte si, že se reference na funkci odlišuje od jména funkce, zatímco v&nbsp;jiných programovacích jazycích se jedná o totožný objekt. Zde se ukazuje určitá nekoncepčnost VimScriptu, který byl původně mnohem jednodušším jazykem v&nbsp;porovnání s&nbsp;jeho současnou verzí.</div></p>



<p><a name="k05"></a></p>
<h2 id="k05">5. Časovače: cesta k&nbsp;asynchronnímu kódu</h2>

<p>S&nbsp;anonymními funkcemi a funcrefy souvisí i další nová vlastnost Vimu 8. Jedná se o takzvané časovače (<i>timers</i>), které umožňují specifikovat, v&nbsp;jakém okamžiku se zavolá nějaká běžná či anonymní funkce. Tyto funkce jsou spouštěny asynchronně, tj.&nbsp;nezávisle na dalším běhu skriptu. Navíc je možné jednoduše specifikovat, kolikrát se má daná funkce zavolat, popř.&nbsp;je možné zajistit, aby se funkce volala periodicky až do ukončení běhu Vimu (to může být velmi užitečné, například u složitějších pluginů). Nový časovač se vytvoří zavoláním funkce nazvané příhodně <strong>timer_start</strong>. Této funkci je nutné předat minimálně dva parametry: časový interval specifikovaný v&nbsp;milisekundách a anonymní funkci či funcref, která se má po uplynutí daného intervalu zavolat:</p>

<pre>
timer_start(interval, funcref či anonymní funkce)
</pre>

<p>Taktéž je možné do <strong>timer_start</strong> předat třetí nepovinný parametr, kterým je slovník obsahující další upřesnění funkce časovače. V&nbsp;současnosti je podporována jen jediná vlastnost &ndash; počet opakování (<strong>repeat</strong>) popř.&nbsp;specifikace periodického opakování volání funkce:</p>

<pre>
timer_start(interval, funcref či anonymní funkce, {'repeat':počet_opakování})
</pre>

<p>Periodické opakování používá magickou konstantu -1:</p>

<pre>
timer_start(interval, funcref či anonymní funkce, {'repeat':-1})
</pre>

<p>Funkce <strong>timer_start</strong> vrátí jednoznačný identifikátor právě vytvořeného časovače.</p>



<p><a name="k06"></a></p>
<h2 id="k06">6. Vytvoření a použití několika časovačů</h2>

<p>O tom, že je základní použití časovačů vlastně velmi jednoduché, se lze snadno přesvědčit prozkoumáním následujícího příkladu, v&nbsp;němž jsou vytvořeny čtyři časovače volající uživatelskou funkci nazvanou <strong>PrintMessage</strong>. První časovač zavolá tuto funkci celkem šestkrát s&nbsp;periodou jedné sekundy, druhý časovač jedenkrát po 3,3 sekundách atd. Po spuštění tohoto skriptu sledujte zprávy vypisované do levého spodního rohu editoru:</p>

<pre>
" ---------------------------------------------
" Vim8 example script - timers
"
" How to use it:
" 1) start new Vim session
" 2) open this script in it
" 3) call :source %
" ---------------------------------------------

function! PrintMessage(message)
    echo a:message
endfunction

call PrintMessage("normal call")

let timer1 = timer_start(1000, 'PrintMessage', {'repeat':6})
echo "timer" timer1 "created"

let timer2 = timer_start(3300, 'PrintMessage')
echo "timer" timer2 "created"

let timer3 = timer_start(4400, 'PrintMessage')
echo "timer" timer3 "created"

let timer4 = timer_start(5500, 'PrintMessage')
echo "timer" timer4 "created"
</pre>



<p><a name="k07"></a></p>
<h2 id="k07">7. Kanály (channels)</h2>

<p>Zcela novou technologií, s&nbsp;níž se můžeme setkat ve Vimu 8, je koncept takzvaných kanálů (<i>channels</i>). Kanály slouží ke komunikaci mezi Vimem (resp.&nbsp;přesněji řečeno mezi VimScriptem) a externími pluginy, které jsou spuštěny v&nbsp;samostatném procesu. Vim s&nbsp;těmito pluginy komunikuje buď s&nbsp;využitím socketů nebo pipe. Pro přenos dat se typicky používá formát JSON a proto jsou tak užitečné ty funkce, které jsme si popsali v&nbsp;předchozích kapitolách. Ve skutečnosti se mohou používat čtyři typy zpráv: RAW, NL, JSON a JS:</p>

<table>
<tr><th>Typ zprávy</th><th>Význam</th></tr>
<tr><td>RAW</td><td>obecný formát, s&nbsp;nímž Vim nijak speciálně nenakládá, pouze zprávu pošle či přijme</td></tr>
<tr><td>NL</td><td>každá textová zpráva je ukončena znakem pro konec řádku (NL)</td></tr>
<tr><td>JSON</td><td>formát JSON</td></tr>
<tr><td>JS</td><td>formát JSON s&nbsp;klíči odpovídajícími JavaScriptu</td></tr>
</table>

<p>Samotné pluginy mohou pracovat ve čtyřech režimech:</p>

<table>
<tr><th>Režim</th><th>Připojení</th><th>Popis</th></tr>
<tr><td>démon</td><td>socket</td><td>proces, ke kterému se může připojit více instancí Vimu</td></tr>
<tr><td>úloha (job)</td><td>socket nebo pipe</td><td>proces, ke kterému se připojuje jedna instance Vimu (ten ho typicky i spustí)</td></tr>
<tr><td>krátká úloha</td><td>socket nebo pipe</td><td>dtto jako předchozí, typicky však proces neběží po celou dobu existence Vimu</td></tr>
<tr><td>filtr</td><td>pipe</td><td>spouští se synchronně, Vim čeká na výsledek operace</td></tr>
</table>



<p><a name="k08"></a></p>
<h2 id="k08">8. Vytvoření kanálu a přenos dat</h2>

<p>Nový kanál určený pro komunikaci s&nbsp;démonem či úlohou (viz tabulka v&nbsp;předchozí kapitole), se vytváří funkcí <strong>ch_open()</strong>. Například pro démona lokálně běžícího na stejném počítači a poslouchajícího na portu 1234 se použije tento příkaz:</p>

<pre>
let channel1 = ch_open("localhost:1234")
</pre>

<p>Jakmile je kanál vytvořen, lze démonu poslat data funkcí <strong>ch_evalexpr(kanál, data)</strong>:</p>

<pre>
ch_evalexpr(channel1, "Hello daemon")
</pre>

<p>Pokud démon vrátí nějakou zprávu, je tato zpráva vrácena jako výsledek funkce <strong>ch_evalexpr()</strong>:</p>

<pre>
let response = ch_evalexpr(channel1, "Hello daemon")
echo response
</pre>

<p>Na konci skriptu je nutné kanál zavřít a uvolnit tak příslušný socket:</p>

<pre>
ch_close(channel1)
</pre>



<p><a name="k09"></a></p>
<h2 id="k09">9. Úlohy (jobs)</h2>

<p>Pro spuštění pluginů v&nbsp;samostatných procesech se používá nová funkce nazvaná <strong>job_start()</strong>. Tato funkce má jeden nepovinný parametr, kterým je příkaz pro spuštění (například cesta ke skriptu atd.). Nepovinným parametrem <i>options</i> je možné funkci <strong>job_start()</strong> předat způsob spuštění úlohy, například zda se mají pro komunikaci použít kanály či pipy, jak dlouho se má čekat na dokončení volání (timeout) atd. Jakmile je úloha spuštěna, lze její stav zjistit zavoláním funkce <strong>job_status()</strong> vracející řetězec &bdquo;run&ldquo;, &bdquo;fail&ldquo; (nepodařil se start) nebo &bdquo;dead&ldquo; (start se podařil, nicméně úloha již skončila). Explicitní ukončení úlohy zajišťuje funkce pojmenovaná jednoduše <strong>job_stop()</strong>, které lze navíc v&nbsp;Linuxu předat signál pro ukončení: &bdquo;term&ldquo;, &bdquo;hup&ldquo;, &bdquo;quit&ldquo; apod. A to nejdůležitější na konec: pokud se úloha spustila, je možné získat komunikační kanál funkcí <strong>job_channel()</strong> a následně použít techniku popsanou v&nbsp;předchozích třech kapitolách.</p>



<p><a name="k10"></a></p>
<h2 id="k10">10. Využití synergie mezi všemi zmíněnými technologiemi: skutečně fungující asynchronně běžící skripty</h2>



<p><a name="k11"></a></p>
<h2 id="k11">11. Plugin <strong>asyncrun</strong></h2>



<p><a name="k12"></a></p>
<h2 id="k12">12. Instalace pluginu <strong>asyncrun</strong></h2>

<p>Při instalaci většího množství pluginů však stojíme před závažným problémem &ndash; jak tyto pluginy instalovat či odinstalovat bez rozbití konfigurace ostatních pluginů. Problém spočívá v&nbsp;tom, že v&nbsp;předchozích verzích Vimu byly cesty nastavené takovým způsobem, že se pluginy musely buď rozbalovat do společných adresářů (všechny nápovědy v&nbsp;jednom adresáři, syntaktické soubory v&nbsp;dalším adresáři, skripty v&nbsp;adresáři třetím atd.) popř.&nbsp;bylo nutné použít některý správce pluginů &ndash; typicky Vundle či Pathogen. Ovšem situace, kdy se pro správu pluginů musel používat jiný plugin, byla ... suboptimální :-). Z&nbsp;tohoto důvodu je ve Vimu 8 možné použít interního správce a postupně tak odstranit nutnost použití Vundle či Pathogenu. To ale nějaký čas potrvá, protože se musí stávající balíčky s&nbsp;pluginy upravit. Nicméně již dnes můžeme několik nových balíčků kompatibilních s&nbsp;Vimem 8 nalézt, popř.&nbsp;lze zkombinovat standardního správce s&nbsp;Vundlem či Pathogenem.</p>

<p>Při používání standardního správce balíčků z&nbsp;Vimu 8 je důležité, aby se pluginy po rozbalení umístily do správných adresářů, v&nbsp;nichž je bude Vim hledat. Nejjednodušší je instalace pluginů pouze pro aktivního uživatele, protože v&nbsp;tomto případě je celá adresářová struktura umístěna v&nbsp;adresáři <strong>~/.vim</strong>. Zde musí být vytvořen podadresář nazvaný <strong>pack</strong> a v&nbsp;něm další podadresář s&nbsp;libovolným jménem (já jsem v&nbsp;příkladu použil podadresář nazvaný <strong>balicky</strong>):</p>

<pre>
[~/.vim]$ <strong>tree</strong>
.
└── pack
    └── balicky
</pre>

<p>Další dělení je jednoduché &ndash; v&nbsp;dalším podadresáři nazvaném <strong>opt</strong> jsou umístěny ty pluginy, které se mají načítat až na základě žádosti uživatele (<i>optional</i>), zatímco v&nbsp;podadresáři <strong>start</strong> budou umístěny ty pluginy, které se načtou a inicializují automaticky.</p>

<p></p>

<pre>
cd ~/.vim/pack/balicky/start
git clone https://github.com/skywind3000/asyncrun.vim
</pre>

<p></p>

<pre>
.
├── autoload
├── doc
├── ftplugin
├── pack
│   └── balicky
│       └── start
│           └── asyncrun.vim
│               ├── doc
│               │   ├── asyncrun.txt
│               │   ├── cooperate_with_fugitive.gif
│               │   ├── errormarker.jpg
│               │   ├── screenshot.gif
│               │   └── simple.png
│               ├── LICENSE
│               ├── plugin
│               │   └── asyncrun.vim
│               └── README.md
├── plugin
├── spell
│   ├── cs.utf-8.add
│   ├── cs.utf-8.add.spl
│   ├── cs.utf-8.spl
│   ├── en.utf-8.add
│   └── en.utf-8.add.spl
└── syntax
</pre>



<p><a name="k13"></a></p>
<h2 id="k13">13. Použití pluginu <strong>asyncrun</strong></h2>



<p><a name="k14"></a></p>
<h2 id="k14">14. Plugin <strong>agrep</strong></h2>



<p><a name="k15"></a></p>
<h2 id="k15">15. Použití pluginu <strong>agrep</strong></h2>



<p><a name="k16"></a></p>
<h2 id="k16">16. Plugin <strong>amake</strong></h2>

<pre>
.
├── autoload
├── doc
├── ftplugin
├── pack
│   └── balicky
│       └── start
│           ├── agrep
│           │   ├── doc
│           │   │   └── agrep.txt
│           │   ├── perl
│           │   │   └── agrep.pl
│           │   ├── plugin
│           │   │   └── agrep.vim
│           │   ├── README.md
│           │   └── syntax
│           │       ├── agrep.vim
│           │       └── qf.vim
│           ├── asyncrun.vim
│           │   ├── doc
│           │   │   ├── asyncrun.txt
│           │   │   ├── cooperate_with_fugitive.gif
│           │   │   ├── errormarker.jpg
│           │   │   ├── screenshot.gif
│           │   │   └── simple.png
│           │   ├── LICENSE
│           │   ├── plugin
│           │   │   └── asyncrun.vim
│           │   └── README.md
│           └── vim-amake
│               ├── autoload
│               │   └── amake.vim
│               ├── plugin
│               │   └── amake.vim
│               └── README.md
├── plugin
├── spell
│   ├── cs.utf-8.add
│   ├── cs.utf-8.add.spl
│   ├── cs.utf-8.spl
│   ├── en.utf-8.add
│   └── en.utf-8.add.spl
└── syntax
</pre>


<p><a name="k17"></a></p>
<h2 id="k17">17. Použití pluginu <strong>amake</strong></h2>



<p><a name="k18"></a></p>
<h2 id="k18">18. Interní funkce těchto pluginů</h2>



<p><a name="k19"></a></p>
<h2 id="k19">19. </h2>



<p><a name="k20"></a></p>
<h2 id="k20">20. Odkazy na Internetu</h2>

<ol>

<li>Vim &ndash; the editor<br />
<a href="http://www.vim.org/">http://www.vim.org/</a>
</li>

<li>Vim 8.0 is released<br />
<a href="https://laravel-news.com/2016/09/vim-8-0-is-released/">https://laravel-news.com/2016/09/vim-8-0-is-released/</a>
</li>

<li>Vim: So long Pathogen, hello native package loading<br />
<a href="https://shapeshed.com/vim-packages/">https://shapeshed.com/vim-packages/</a>
</li>

<li>Asynchronous grep plugin for Vim<br />
<a href="https://github.com/ramele/agrep">https://github.com/ramele/agrep</a>
</li>

<li>:smile command was not backported! #5116<br />
<a href="https://github.com/neovim/neovim/issues/5116">https://github.com/neovim/neovim/issues/5116</a>
</li>

<li>Makejob<br />
<a href="http://www.vim.org/scripts/script.php?script_id=5479">http://www.vim.org/scripts/script.php?script_id=5479</a>
</li>

<li>Články o Vimu na Root.cz:<br />
<a href="http://www.root.cz/n/vim/clanky/">http://www.root.cz/n/vim/clanky/</a>
</li>

<li>Vim sedm - první část<br />
<a href="http://www.root.cz/clanky/vim-sedm-prvni-cast/">http://www.root.cz/clanky/vim-sedm-prvni-cast/</a>
</li>

<li>vim (man page)<br />
<a href="http://www.linux-tutorial.info/modules.php?name=ManPage&sec=1&manpage=vim">http://www.linux-tutorial.info/modules.php?name=ManPage&sec=1&manpage=vim</a>
</li>

<li>History of the Text Editor<br />
<a href="http://vanstee.me/history-of-the-text-editor.html">http://vanstee.me/history-of-the-text-editor.html</a>
</li>

<li>Interview with Bill Joy<br />
<a href="http://web.cecs.pdx.edu/~kirkenda/joy84.html">http://web.cecs.pdx.edu/~kirkenda/joy84.html</a>
</li>

<li>vi Editor Commands<br />
<a href="http://www.cs.rit.edu/~cslab/vi.html#A1.4">http://www.cs.rit.edu/~cslab/vi.html#A1.4</a>
</li>

<li>vi Manual<br />
<a href="http://www.cs.fsu.edu/general/vimanual.html">http://www.cs.fsu.edu/general/vimanual.html</a>
</li>

<li>Mastering the Vi Editor<br />
<a href="http://www.susnet.uk/mastering-the-vi-editor">http://www.susnet.uk/mastering-the-vi-editor</a>
</li>

<li>Vim as a Python IDE, or Python IDE as Vim<br />
<a href="http://blog.jetbrains.com/pycharm/2013/06/vim-as-a-python-ide-or-python-ide-as-vim/">http://blog.jetbrains.com/pycharm/2013/06/vim-as-a-python-ide-or-python-ide-as-vim/</a>
</li>

<li>Vi Improved<br />
<a href="https://wiki.python.org/moin/Vim">https://wiki.python.org/moin/Vim</a>
</li>

<li>Popis skriptu Vim Pathogen<br />
<a href="http://www.vim.org/scripts/script.php?script_id=2332">http://www.vim.org/scripts/script.php?script_id=2332</a>
</li>

<li>Poslední­verze skriptu Vim Pathogen<br />
<a href="https://tpo.pe/pathogen.vim">https://tpo.pe/pathogen.vim</a>
</li>

<li>Nejlepší pluginy pro Vim<br />
<a href="http://vimawesome.com/">http://vimawesome.com/</a>
</li>

<li>Nejlepší pluginy pro Vim<br />
<a href="http://www.vim.org/scripts/script_search_results.php?order_by=rating">http://www.vim.org/scripts/script_search_results.php?order_by=rating</a>
</li>

<li>Building Vim<br />
<a href="http://vim.wikia.com/wiki/Building_Vim">http://vim.wikia.com/wiki/Building_Vim</a>
</li>

<li>Vim plugins for developers<br />
<a href="http://www.linuxtoday.com/upload/vim-plugins-for-developers-140619094010.html">http://www.linuxtoday.com/upload/vim-plugins-for-developers-140619094010.html</a>
</li>

<li>Writing Vim Plugins<br />
<a href="http://stevelosh.com/blog/2011/09/writing-vim-plugins/">http://stevelosh.com/blog/2011/09/writing-vim-plugins/</a>
</li>

<li>how to understand this vim script?<br />
<a href="http://stackoverflow.com/questions/12625091/how-to-understand-this-vim-script">http://stackoverflow.com/questions/12625091/how-to-understand-this-vim-script</a>
</li>

<li>Novinky ve VIM 7: Skriptovací­ jazyk<br />
<a href="http://www.root.cz/vim-sedm-druha-cast/">http://www.root.cz/vim-sedm-druha-cast/</a>
</li>

<li>DirDiff.vim : A plugin to diff and merge two directories recursively.<br />
<a href="http://www.vim.org/scripts/script.php?script_id=102">http://www.vim.org/scripts/script.php?script_id=102</a>
</li>

<li>vim-dirdiff na GitHubu<br />
<a href="https://github.com/will133/vim-dirdiff">https://github.com/will133/vim-dirdiff</a>
</li>

<li>fakeclip : pseudo clipboard register for non-GUI version of Vim<br />
<a href="http://www.vim.org/scripts/script.php?script_id=2098">http://www.vim.org/scripts/script.php?script_id=2098</a>
</li>

<li>vim-fakeclip na GitHubu<br />
<a href="https://github.com/kana/vim-fakeclip">https://github.com/kana/vim-fakeclip</a>
</li>

<li>vim-fakeclip: Dokumentace<br />
<a href="http://kana.github.io/config/vim/fakeclip.html">http://kana.github.io/config/vim/fakeclip.html</a>
</li>

<li>Vim Multiple Cursors na GitHubu<br />
<a href="https://github.com/terryma/vim-multiple-cursors">https://github.com/terryma/vim-multiple-cursors</a>
</li>

<li>SLIME (Wikipedia)<br />
<a href="http://en.wikipedia.org/wiki/SLIME">http://en.wikipedia.org/wiki/SLIME</a>
</li>

<li>vim-slime na GitHubu<br />
<a href="https://github.com/jpalardy/vim-slime">https://github.com/jpalardy/vim-slime</a>
</li>

<li>The NERD tree: A tree explorer plugin for navigating the filesystem<br />
<a href="http://www.vim.org/scripts/script.php?script_id=1658">http://www.vim.org/scripts/script.php?script_id=1658</a>
</li>

<li>JavaBrowser : Shows java file class, package in a tree as in IDEs. Java source browser.<br />
<a href="http://www.vim.org/scripts/script.php?script_id=588">http://www.vim.org/scripts/script.php?script_id=588</a>
</li>

<li>snippetsEmu : An attempt to emulate TextMate's snippet expansion<br />
<a href="http://www.vim.org/scripts/script.php?script_id=1318">http://www.vim.org/scripts/script.php?script_id=1318</a>
</li>

<li>c.vim : C/C++ IDE key mappings<br />
<a href="http://lug.fh-swf.de/vim/vim-c/c-hotkeys.pdf">http://lug.fh-swf.de/vim/vim-c/c-hotkeys.pdf</a>
</li>

<li>Základní základy editoru Vim<br />
<a href="http://www.root.cz/clanky/zakladni-zaklady-editoru-vim/">http://www.root.cz/clanky/zakladni-zaklady-editoru-vim/</a>
</li>

<li>Jak si přizpůsobit Vim<br />
<a href="http://www.root.cz/serialy/jak-si-prizpusobit-vim/">http://www.root.cz/serialy/jak-si-prizpusobit-vim/</a>
</li>

<li>Taglist (plugin)<br />
<a href="http://www.vim.org/scripts/script.php?script_id=273">http://www.vim.org/scripts/script.php?script_id=273</a>
</li>

<li>Tutorial: Make Vim as Your C/C++ IDE Using c.vim Plugin<br />
<a href="http://www.thegeekstuff.com/2009/01/tutorial-make-vim-as-your-cc-ide-using-cvim-plugin/">http://www.thegeekstuff.com/2009/01/tutorial-make-vim-as-your-cc-ide-using-cvim-plugin/</a>
</li>

<li>c.vim : C/C++ IDE<br />
<a href="http://vim.sourceforge.net/scripts/script.php?script_id=213">http://vim.sourceforge.net/scripts/script.php?script_id=213</a>
</li>

</ol>



<p></p><p></p>
<p><small>Autor: <a href="http://www.fit.vutbr.cz/~tisnovpa">Pavel Tišnovský</a> &nbsp; 2018</small></p>
</body>
</html>

