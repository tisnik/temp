<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
        "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html>
<head>
<title>Asynchronní skripty: další přiblížení Vimu k možnostem IDE</title>
<meta name="Author" content="Pavel Tisnovsky" />
<meta name="Generator" content="vim" />
<meta http-equiv="content-type" content="text/html; charset=utf-8" />
<style type="text/css">
         body {color:#000000; background:#ffffff;}
         h1  {font-family: arial, helvetica, sans-serif; color:#ffffff; background-color:#c00000; text-align:center; padding-left:1em}
         h2  {font-family: arial, helvetica, sans-serif; color:#ffffff; background-color:#0000c0; padding-left:1em; text-align:left}
         h3  {font-family: arial, helvetica, sans-serif; color:#000000; background-color:#c0c0c0; padding-left:1em; text-align:left}
         h4  {font-family: arial, helvetica, sans-serif; color:#000000; background-color:#e0e0e0; padding-left:1em; text-align:left}
         a   {font-family: arial, helvetica, sans-serif;}
         li  {font-family: arial, helvetica, sans-serif; color:#000000; text-align:justify; width:450px;}
         ol  {font-family: arial, helvetica, sans-serif; color:#000000; text-align:justify; width:450px;}
         ul  {font-family: arial, helvetica, sans-serif; color:#000000; text-align:justify; width:450px;}
         p   {font-family: arial, helvetica, sans-serif; color:#000000; text-align:justify;}
         pre {background:#e0e0e0}
</style>
</head>

<body>

<h1>Asynchronní skripty: další přiblížení Vimu k možnostem IDE</h1>

<h3>Pavel Tišnovský</h3>

<p></p>

<h1>Úvodník</h1>

<p>Prakticky přesně před dvěma roky vyšla osmá verze editoru Vim. Jde o přelomovou událost, protože právě Vim 8 umožňuje tvorbu asynchronně běžících skriptů, které tak mohou přiblížit možnosti Vimu plnohodnotným IDE. Dnes se s touto technologií i jejím použitím seznámíme.</p>



<h2>Obsah</h2>

<p><a href="#k01">1. Pluginy využívající asynchronní volání ve Vimu</a></p>
<p><a href="#k02">2. Podpora pro práci s&nbsp;datovým formátem JSON</a></p>
<p><a href="#k03">3. Anonymní funkce</a></p>
<p><a href="#k04">4. Reference na funkce</a></p>
<p><a href="#k05">5. Časovače: cesta k&nbsp;asynchronnímu kódu</a></p>
<p><a href="#k06">6. Vytvoření a použití několika časovačů</a></p>
<p><a href="#k07">7. Kanály (channels)</a></p>
<p><a href="#k08">8. Vytvoření kanálu a přenos dat</a></p>
<p><a href="#k09">9. Úlohy (jobs)</a></p>
<p><a href="#k10">10. Využití synergie mezi všemi zmíněnými technologiemi: skutečně fungující asynchronně běžící skripty</a></p>
<p><a href="#k11">11. Plugin <strong>asyncrun</strong></a></p>
<p><a href="#k12">12. Instalace pluginu <strong>asyncrun</strong></a></p>
<p><a href="#k13">13. Použití pluginu <strong>asyncrun</strong></a></p>
<p><a href="#k14">14. Plugin <strong>agrep</strong></a></p>
<p><a href="#k15">*** 15. Použití pluginu <strong>agrep</strong></a></p>
<p><a href="#k16">*** 16. Plugin <strong>amake</strong></a></p>
<p><a href="#k17">*** 17. Použití pluginu <strong>amake</strong></a></p>
<p><a href="#k18">*** 18. Interní funkce těchto pluginů</a></p>
<p><a href="#k19">*** 19. Okno terminálu (novinka ve Vimu 8.1)</a></p>
<p><a href="#k20">20. Odkazy na Internetu</a></p>



<p><a name="k01"></a></p>
<h2 id="k01">1. Pluginy využívající asynchronní volání ve Vimu</h2>

<p>Textový editor Vim, s&nbsp;nímž se na stránkách Rootu <a
href="https://www.root.cz/n/vim/">setkáváme poměrně pravidelně</a>, je mezi
mnoha uživateli oblíbený jak díky svému modálnímu způsobu ovládání, tak i kvůli
tomu, že je ho možné nakonfigurovat přesně takovým způsobem, aby plně vyhovoval
všem uživatelským požadavkům. Ovšem kromě toho nesmíme zapomenout ani na fakt,
že pro Vim existuje velké množství modulů (pluginů), které možnosti tohoto
editoru <a href="https://www.root.cz/serialy/textovy-editor-vim-jako-ide/">dále
rozšiřují</a>. Moduly lze naprogramovat jak v&nbsp;jazyku Vim Script (ten se
prakticky objevil až <a
href="http://vimdoc.sourceforge.net/htmldoc/version5.html">v&nbsp;páté
verzi</a>), tak i například v&nbsp;<a
href="https://www.root.cz/clanky/textovy-editor-vim-jako-ide-16-cast-kooperace-mezi-vimem-a-skriptovacimi-jazyky/#k04">Pythonu</a>,
<a href="https://www.root.cz/clanky/textovy-editor-vim-jako-ide-17-cast-kooperace-mezi-vimem-a-jazykem-perl/">Perlu</a>
či <a href="https://www.root.cz/clanky/tvorba-pluginu-pro-vim-s-vyuzitim-programovaciho-jazyka-lua/">v&nbsp;programovacím
jazyku Lua</a>.</p>

*** image ***
<p><i>Obrázek 1: Jedna z&nbsp;prvních verzí Vimu 8.0 (tehdy ještě nebyla
zařazena do prakticky žádné stabilní distribuce).</i></p>

<p>I přesto, že je dnes možné ve Vimu naprogramovat i velmi složité moduly,
byly jejich možnosti v&nbsp;porovnání s&nbsp;plnohodnotnými IDE v&nbsp;jedné
oblasti omezené &ndash; všechny skripty běžely (velmi zjednodušeně řečeno) ve
stejném vláknu, jako zbytek textového editoru. To v&nbsp;praxi znamenalo, že
například při spuštění překladače musel uživatel čekat na dokončení překladu a
teprve poté bylo možné pokračovat v&nbsp;editaci popř.&nbsp;ve zkoumání chyb
vypsaných během překladu do tzv.&nbsp;<i>Quickfix window</i> (okno
s&nbsp;rychlým náhledem). Podobně tomu bylo i u dalších operací (vyhledávání,
volání LSP atd.  atd.). Situace se ovšem zásadně změnila právě ve Vimu 8, který
přinesl hned několik nových technologií využitelných právě pro tvorbu mnohem
lepších pluginů. Dnes se s&nbsp;těmito technologiemi postupně seznámíme a
ukážeme si jejich použití na trojici prakticky využitelných pluginů nazvaných
<a href="#k11">asyncrun</a>, <a href="#k14">agrep</a> a <a
href="k16">amake</a>.</p>

*** image ***
<p><i>Obrázek 2: Konfigurační volby, s&nbsp;nimiž byl přeložen Vim 8.0.</i></p>

<p><div class="rs-tip-major">Poznámka: ve skutečnosti byly některé nové
vlastnosti backportovány i do Vimu 7.4.x, ovšem přechod na Vim 8 je pro
naprostou většinu uživatelů zcela bezproblémový.</div></p>



<p><a name="k02"></a></p>
<h2 id="k02">2. Podpora pro práci s&nbsp;datovým formátem JSON</h2>

<p>Na první pohled sice možná ne příliš výraznou, ale o to důležitější a
užitečnější novinkou, je přidání čtyř nových funkcí do skriptovacího engine
Vimu. Tyto čtyři funkce slouží pro převod datových struktur Vim Scriptu do <a
href="http://www.json.org/">formátu JSON</a> a zpět. Proč je vlastně tato
novinka tak důležitá? Souvisí totiž s&nbsp;další novou technologií, konkrétně
s&nbsp;úlohami (<i>jobs</i>) a kanály (<i>channels</i>). Úlohy umožňují přesně
definovaným způsobem vytvářet pluginy (i externí pluginy) s&nbsp;tím, že tyto
pluginy mohou běžet asynchronně, tj.&nbsp;částečně nezávisle na samotném Vimu.
Důležité je, že pluginy s&nbsp;Vimem komunikují právě přes JSON formát, což je
pěkně navržené řešení, protože <a href="http://json.org/">JSON</a> je dnes
podporovaný v&nbsp;prakticky všech relevantních programovacích jazycích,
v&nbsp;nichž se externí pluginy většinou píšou (typicky se jedná o Python, ale
lze použít i jazyk Lua apod.).</p>
    
*** image ***
<p><i>Obrázek 3: Nejdůležitější novinka ve Vimu 8 &ndash; příkaz
<strong>:smile</strong>.</i></p>

<p><div class="rs-tip-major">Poznámka: na existenci těchto funkcí je ostatně
založen i <a
href="https://www.root.cz/clanky/pouziti-language-server-protocolu-v-textovem-editoru-vim/">nedávno
popsaný plugin vim-lsp</a>.</div></p>

<a href="https://www.root.cz/obrazek/339759/"><img src="https://i.iinfo.cz/images/633/vim-lsp-3-prev.png" class="image-339759" alt="&#160;" width="370" height="244" /></a>
<p><i>Obrázek 4: Příklad použití pluginu <strong>vim-lsp</strong>.</i></p>

<p>Skriptovací engine Vimu nabízí programátorům dvě funkce určené pro převod
datových struktur do formátu JSON (<i>encode</i>) a dvě funkce určené pro
parsování JSON dat do interních struktur Vim Scriptu (<i>decode</i>). Dvě
varianty jsou implementovány z&nbsp;toho důvodu, že v&nbsp;některých případech
je zapotřebí, aby byly klíče objektů (či slovníků) reprezentovány řetězci a
jinde se může jednat o identifikátory bez uvozovek (záleží na konkrétní
situaci):</p>

<table>
<tr><th>Funkce</th><th>Stručný popis</th></tr>
<tr><td><strong>json_encode(výraz)</strong></td><td>převod výrazu do JSON formátu, který se vrátí ve formě řetězce</td></tr>
<tr><td><strong>json_decode(řetězec)</strong></td><td>opak předchozí funkce, parsování řetězce s&nbsp;daty uloženými v&nbsp;JSON formátu do interních datových struktur Vim Scriptu</td></tr>
<tr><td><strong>js_encode(výraz)</strong></td><td>podobné funkci <strong>json_encode()</strong>, ovšem klíče nejsou umístěny v&nbsp;uvozovkách</td></tr>
<tr><td><strong>js_decode(řetězec)</strong></td><td>podobné funkci <strong>json_decode()</strong>, ovšem při parsingu se nevyžaduje, aby byly klíče umístěny v&nbsp;uvozovkách</td></tr>
</table>

<p><div class="rs-tip-major">Poznámka: převod do JSON formátu se někdy nazývá
<i>serializace</i>, zpětný převod pak pochopitelně
<i>deserializace</i>.</div></p>

*** image ***
<p><i>Obrázek 5: Nápověda k&nbsp;funkcím <strong>js_encode</strong> a <strong>js_decode</strong>.</i></p>

<p>Ve Vim Scriptu existuje celkem deset datových typů, přičemž pět
z&nbsp;těchto typů do jisté míry koresponduje s&nbsp;typy používanými ve
formátu JSON (Number, Float, String, List a Dictionary) a dva další typy
(Boolean, None) lze taktéž do formátu JSON převést, pokud se ovšem dodrží
určitá pravidla. Výše zmíněné čtyři funkce <strong>json_encode(),
json_decode(), js_encode()</strong> a <strong>js_decode()</strong> provádí
převody mezi jednotlivými typy (resp.&nbsp;mezi hodnotami různých typů) zcela
automaticky, ovšem existuje několik potenciálně problematických výjimek,
kterými se budeme zabývat v&nbsp;navazujícím textu.</p>

*** image ***
<p><i>Obrázek 6: Serializace základních hodnot do JSONu.</i></p>

<p>V&nbsp;následující tabulce jsou vypsány korespondující datové typy.
Povšimněte si, že v&nbsp;JSON formátu se nerozlišuje mezi celými čísly a čísly
s&nbsp;plovoucí řádovou čárkou, což do značné míry souvisí s&nbsp;původním
návrhem tohoto formátu založeném na JavaScriptu:</p>

<table>
<tr><th>Typ ve Vim Scriptu</th><th>Převod do JSONu</th></tr>
<tr><td>Number</td><td>celé číslo</td></tr>
<tr><td>Float</td><td>číslo s desetinnou čárkou a/nebo exponentem</td></tr>
<tr><td>String</td><td>řetězec umístěný v&nbsp;uvozovkách</td></tr>
<tr><td>List</td><td>pole hodnot</td></tr>
<tr><td>Dictionary</td><td>objekt (asociativní pole)</td></tr>
<tr><td>Funcref</td><td>nelze (teoreticky by se jednalo o serializaci kódu)</td></tr>
<tr><td>Boolean</td><td>True/False</td></tr>
<tr><td>None</td><td>Null</td></tr>
<tr><td>Job</td><td>nelze</td></tr>
<tr><td>Channel</td><td>nelze</td></tr>
</table>

<p>Převody mezi skalárními typy jsou ve většině běžných případů triviální,
proto se podívejme, jakým způsobem je možné v&nbsp;JSON formátu reprezentovat
složené datové typy Vim Scriptu. Prvním typem, s&nbsp;nímž se setká prakticky
každý programátor používající Vim Script, je seznam (<i>list</i>), který je
ovšem někdy taktéž nazýván vektorem (<i>vector)</i> či polem (<i>array</i>),
což ale není zcela přesné. V&nbsp;následujícím příkladu je do JSON formátu
převeden seznam čísel, dále seznam řetězců a dvě matice reprezentované seznamem
seznamů. Povšimněte si, že ve Vim Scriptu je nutné při zápisu výrazu či příkazu
na více řádků použít zpětné lomítko na začátku (nikoli na konci!) řádku, což je
dosti neobvyklé:</p>

<pre>
let vector1 = [1, 2, 3]
echo json_encode(vector1)
&nbsp;
let vector2 = ["Hello", "world", "!"]
echo json_encode(vector2)
&nbsp;
let matrix1 = [[1,2,3], [4,5,6], [7,8,9]]
&nbsp;
echo json_encode(matrix1)
&nbsp;
let matrix2 = [[1,2,3],
\             [4,5,6],
\             [7,8,9]]
&nbsp;
echo json_encode(matrix2)
</pre>

*** image ***
<p><i>Obrázek 7: Výsledek spuštění předchozího skriptu s&nbsp;funkcí
<strong>json_encode</strong>.</i></p>

<p>Samozřejmě můžeme namísto funkce <strong>json_encode()</strong> použít
funkci <strong>js_encode()</strong>, která ovšem vytvoří shodný výsledek
(prozatím totiž nepracujeme se slovníky):</p>

<pre>
let vector1 = [1, 2, 3]
echo js_encode(vector1)
&nbsp;
let vector2 = ["Hello", "world", "!"]
echo js_encode(vector2)
&nbsp;
let matrix1 = [[1,2,3], [4,5,6], [7,8,9]]
&nbsp;
echo js_encode(matrix1)
&nbsp;
let matrix2 = [[1,2,3],
\             [4,5,6],
\             [7,8,9]]
&nbsp;
echo js_encode(matrix2)
</pre>

*** image ***
<p><i>Obrázek 8: Výsledek spuštění předchozího skriptu s&nbsp;funkcí
<strong>js_encode</strong>.</i></p>

<p>Nejsložitější datovou strukturou, kterou je možné do JSON formátu uložit
(serializovat), jsou takzvané slovníky (<i>dictionary, dict</i>), které jsou
v&nbsp;jiných programovacích jazycích nazývány hashe či asociativní pole. Právě
u slovníků se projeví rozdíl mezi funkcemi <strong>json_encode()</strong> a
<strong>js_encode()</strong>, a to konkrétně při serializaci klíčů. Rozdíly
jsou shrnuty v&nbsp;následující tabulce:</p>

<table>
<tr><th>Typ klíče</th><th>json_encode()</th><th>js_encode()</th></tr>
<tr><td>řetězec odpovídající názvu proměnné v JS</td><td>klíč je zapsán do uvozovek</td><td>klíč je zapsán bez uvozovek</td></tr>
<tr><td>jiný řetězec (s mezerou, pomlčkou...)   </td><td>klíč je zapsán do uvozovek</td><td>klíč je zapsán do uvozovek</td></tr>
<tr><td>číslo</td><td>klíč je zapsán do uvozovek</td><td>klíč je zapsán do uvozovek</td></tr>
<tr><td>jiný typ (seznam...)</td><td>nelze použít</td><td>nelze použít</td></tr>
</table>

<p>Název proměnné v&nbsp;JavaScriptu musí začínat písmenem, podtržítkem či
znakem dolaru a musí obsahovat čísla, písmena (nikoli jen ASCII, možnosti jsou
zde větší), dolary či podtržítka.</p>

<p>V&nbsp;následujícím příkladu je ukázáno, jak je možné do JSON formátu
ukládat slovníky, slovníky se seznamy (hodnoty) či naopak seznam slovníků:</p>

<pre>
let dict1 = {"first": 1, "second" : 2, "third" : 3}
echo json_encode(dict1)
&nbsp;
let dict2 = {1 : "first", 2 : "second", 3 : "third"}
echo json_encode(dict2)
&nbsp;
let dict3 = {"first" : [1,2,3], "second" : [4,5,6]}
echo json_encode(dict3)
&nbsp;
let vectorOfDicts = [ {"first" : 1, "second" : 2}, {"another" : "dictionary"}]
echo json_encode(vectorOfDicts)
</pre>

*** image ***
<p><i>Obrázek 9: Výsledek spuštění předchozího skriptu s&nbsp;funkcí
<strong>json_encode</strong>.</i></p>

<p>Pokud budeme shodné datové struktury serializovat funkcí
<strong>js_encode()</strong>, budou se klíče ukládat rozdílným způsobem, ale
pouze pro ty řetězce, které odpovídají jménům proměnných
v&nbsp;JavaScriptu:</p>

<pre>
let dict1 = {"first": 1, "second" : 2, "third" : 3}
echo js_encode(dict1)
&nbsp;
let dict2 = {1 : "first", 2 : "second", 3 : "third"}
echo js_encode(dict2)
&nbsp;
let dict3 = {"first" : [1,2,3], "second" : [4,5,6]}
echo js_encode(dict3)
&nbsp;
let vectorOfDicts = [ {"first" : 1, "second" : 2}, {"another" : "dictionary"}]
echo js_encode(vectorOfDicts)
</pre>

*** image ***
<p><i>Obrázek 10: Výsledek spuštění předchozího skriptu s&nbsp;funkcí
<strong>js_encode</strong>.</i></p>



<p><a name="k03"></a></p>
<h2 id="k03">3. Anonymní funkce</h2>

<p>Poměrně významnou novinkou Vimu 8, kterou nalezneme ve skriptovacím jazyku
Vim Script, jsou takzvané <i>anonymní funkce</i> (někdy se setkáme s&nbsp;možná
přiléhavějším názvem <i>lambdy</i>, což je označení vycházející z&nbsp;lambda
kalkulu). Anonymní funkce je možné použít ve všech místech programového kódu,
kde jsou očekávány takzvané reference na funkce (<i>funcrefs</i>, viz <a
href="#k04">další kapitolu</a>). Zápis anonymní funkce se v&nbsp;několika
ohledech odlišuje od zápisu běžné funkce. Parametry i samotné tělo funkce jsou
totiž umístěny do složených závorek {} a mezi parametry a tělem funkce se
zapisuje dvojice znaků -&gt; (u parametrů se navíc nemusí používat prefix
<strong>a:</strong>, který je u běžných funkcí vyžadován). Velmi jednoduchou
anonymní funkci, která po svém zavolání vrátí součet svých dvou parametrů, lze
zapsat takto:</p>

<pre>
{x,y -&gt; x + y}
</pre>

*** image ***
<p><i>Obrázek 11: Nápověda k&nbsp;lambda výrazům (anonymním funkcím).</i></p>

<p>Volání takové funkce může vypadat například takto:</p>

<pre>
:echo {x,y -&gt; x + y}(1,2)
</pre>

<p>nebo (díky přetíženému operátoru +):</p>

<pre>
:echo {x,y -&gt; x + y}([1,2,3], [4,5,6])
</pre>

<p>popř: (výsledek vás může překvapit)</p>

<pre>
:echo {x,y -&gt; x + y}("1", "2")
</pre>

*** image ***
<p><i>Obrázek 12: Zavolání anonymní funkce.</i></p>

*** image ***
<p><i>Obrázek 13: Výsledek zavolání anonymní funkce.</i></p>

<p><div class="rs-tip-major">Poznámka: ve skutečnosti není dvojtečka na začátku
nutná ve chvíli, kdy se funkce volá ze skriptu (tedy typicky ze souboru
s&nbsp;koncovkou <strong>.vim</strong>). Ovšem s&nbsp;dvojtečkou si můžeme
volání funkce otestovat přímo z&nbsp;příkazového řádku Vimu.</div></p>

<p>Alternativně lze anonymní funkci přiřadit do proměnné (a tak ji vlastně
pojmenovat):</p>

<pre>
:let Fce={x,y -&gt; x + y}
:echo Fce(1,2)
3
</pre>

<p><div class="rs-tip-major">Poznámka: samotná výhoda existence anonymních
funkcí se ukáže až ve chvíli, kdy se seznámíme s&nbsp;dalšími možnostmi Vim
Scriptu.</div></p>



<p><a name="k04"></a></p>
<h2 id="k04">4. Reference na funkce</h2>

<p><a href="#k03">V&nbsp;předchozí kapitole</a> jsme se &ndash; prozatím bez
dalšího hlubšího vysvětlení &ndash; setkali s&nbsp;termínem &bdquo;reference na
funkci&ldquo; což je název běžně zkracovaný na &bdquo;funcref&ldquo;. Nejedná
se sice o nový koncept zavedený až ve Vimu 8, ale vzhledem k&nbsp;tomu, že se
s&nbsp;referencemi na funkce setkáme i v&nbsp;několika dalších demonstračních
příkladech, si stručně vysvětlíme, o co se vlastně jedná. Reference na funkci
obsahuje, což asi není příliš překvapivé, odkaz na existující funkci (přičemž
nás nezajímá, jak konkrétně je tento odkaz reprezentován) a lze ji považovat za
plnohodnotný datový typ skriptovacího jazyka Vim Script. To mj.&nbsp;znamená,
že reference na funkce lze ukládat do proměnných (globálních i lokálních) či je
předávat do jiných funkcí (takzvaných funkcí vyššího řádu). Reference na
existující funkci se získá zavoláním <strong>function(jméno_funkce)</strong>,
tedy například následujícím způsobem:</p>

<pre>
function! DoubleValue(index, value)
    return a:value * 2
endfunction
&nbsp;
let Funcref = function("DoubleValue")
</pre>

<p><div class="rs-tip-major">Poznámka: povšimněte si, že se reference na funkci
odlišuje od jména funkce, zatímco v&nbsp;mnoha jiných programovacích jazycích
se jedná o totožný objekt (pokud daný jazyk podobné konstrukce vůbec umožňuje).
Zde se ukazuje určitá nekoncepčnost Vim Scriptu, který byl původně mnohem
jednodušším jazykem v&nbsp;porovnání s&nbsp;jeho současnou verzí.</div></p>

*** image ***
<p><i>Obrázek 14: Nápověda k&nbsp;datovému typu reference na funkce.</i></p>



<p><a name="k05"></a></p>
<h2 id="k05">5. Časovače: cesta k&nbsp;asynchronnímu kódu</h2>

<p>S&nbsp;anonymními funkcemi a referencemi na funkce (funcrefy) do jisté míry
souvisí i další nová a velmi užitečná vlastnost Vimu 8. Jedná se o takzvané
časovače (<i>timers</i>), které umožňují specifikovat, v&nbsp;jakém okamžiku se
zavolá nějaká běžná či anonymní funkce. Důležité je, že tyto funkce jsou
spouštěny asynchronně, tj.&nbsp;nezávisle na dalším běhu skriptu (a nezávisle
na tom, jaké operace provádí uživatel!). Navíc je možné jednoduše specifikovat,
kolikrát se má daná funkce zavolat, popř.&nbsp;je možné zajistit, aby se funkce
volala periodicky až do ukončení běhu Vimu (to může být velmi užitečné,
například u složitějších pluginů). Nový časovač se ve Vim Scriptu vytvoří
zavoláním funkce nazvané příhodně <strong>timer_start()</strong>. Této funkci
je nutné předat minimálně dva parametry: časový interval specifikovaný
v&nbsp;milisekundách a anonymní funkci či funcref, která se má po uplynutí
daného intervalu zavolat:</p>

<pre>
timer_start(interval, funcref či anonymní funkce)
</pre>

<p>Taktéž je možné do funkce <strong>timer_start()</strong> předat třetí
nepovinný parametr, kterým je slovník obsahující další upřesnění funkce
časovače. V&nbsp;současnosti je podporována jen jediná vlastnost &ndash; počet
opakování (<strong>repeat</strong>) popř.&nbsp;specifikace periodického
opakování volání funkce:</p>

<pre>
timer_start(interval, funcref či anonymní funkce, {'repeat':počet_opakování})
</pre>

<p>Periodické opakování používá magickou konstantu -1:</p>

<pre>
timer_start(interval, funcref či anonymní funkce, {'repeat':-1})
</pre>

<p>Funkce <strong>timer_start</strong> vrátí jednoznačný identifikátor právě
vytvořeného časovače.</p>

<p>Příkladem použití může být snaha o zobrazení času na pravítku popř.&nbsp;na
stavovém řádku. Pokus o pouhou změnu formátu pravítka ovšem nestačí, protože
pravítko bude aktualizováno pouze tehdy, pokud uživatel bude provádět nějakou
činnost (zjednodušeně: pokud bude mačkat klávesy):</p>

<pre>
set laststatus=2
set ruler
set rulerformat=%55(%{strftime('%a\ %b\ %e\ %I:%M:%S\ %p')}\ %5l,%-6(%c%V%)\ %P%)
</pre>

<p>Díky existenci časovače <a
href="http://vim.wikia.com/wiki/Display_date-and-time_on_status_line">je ovšem
změna obsahu pravítka</a> například každou sekundu snadná:</p>

<pre>
set laststatus=2
set ruler
set rulerformat=%55(%{strftime('%a\ %b\ %e\ %I:%M:%S\ %p')}\ %5l,%-6(%c%V%)\ %P%)
&nbsp;
function! UpdateStatusBar(timer)
    execute 'let &amp;ro=&amp;ro'
endfunction
&nbsp;
let timer = timer_start(1000, 'UpdateStatusBar',{'repeat':-1})
</pre>

<p><div class="rs-tip-major">Poznámka: zde jsme použili malého triku popsaného
<a
href="http://vimdoc.sourceforge.net/htmldoc/options.html#%27statusline%27">v&nbsp;nápovědě
Vimu</a> &ndash; pokud budeme chtít změnit obsah pravítka, postačuje změnit
jakoukoli konfigurační volbu.</div></p>



<p><a name="k06"></a></p>
<h2 id="k06">6. Vytvoření a použití několika časovačů</h2>

<p>O tom, že je základní použití časovačů vlastně velmi jednoduché, se lze
snadno přesvědčit prozkoumáním následujícího demonstračního příkladu,
v&nbsp;němž jsou vytvořeny čtyři časovače volající uživatelskou funkci nazvanou
<strong>PrintMessage</strong>. První časovač zavolá tuto funkci celkem šestkrát
s&nbsp;periodou jedné sekundy, druhý časovač jedenkrát po 3,3 sekundách atd. Po
spuštění tohoto skriptu sledujte zprávy vypisované do levého spodního rohu
editoru:</p>

<pre>
" ---------------------------------------------
" Vim8 example script - timers
"
" How to use it:
" 1) start new Vim session
" 2) open this script in it
" 3) call :source %
" ---------------------------------------------
&nbsp;
function! PrintMessage(message)
    echo a:message
endfunction
&nbsp;
call PrintMessage("normal call")
&nbsp;
let timer1 = timer_start(1000, 'PrintMessage', {'repeat':6})
echo "timer" timer1 "created"
&nbsp;
let timer2 = timer_start(3300, 'PrintMessage')
echo "timer" timer2 "created"
&nbsp;
let timer3 = timer_start(4400, 'PrintMessage')
echo "timer" timer3 "created"
&nbsp;
let timer4 = timer_start(5500, 'PrintMessage')
echo "timer" timer4 "created"
</pre>



<p><a name="k07"></a></p>
<h2 id="k07">7. Kanály (channels)</h2>

<p>Zcela novou technologií, s&nbsp;níž se můžeme setkat ve Vimu 8, je koncept
takzvaných kanálů neboli <i>channels</i>. Kanály primárně slouží ke komunikaci
mezi Vimem (resp.&nbsp;přesněji řečeno mezi Vim Scriptem) a externími pluginy,
které jsou spuštěny v&nbsp;samostatném procesu. Textový editor Vim
s&nbsp;těmito pluginy komunikuje buď s&nbsp;využitím socketů nebo roury
(<i>pipe</i>). Pro přenos dat se typicky používá <a href="#k02">výše zmíněný
formát JSON</a> a proto jsou tak užitečné ty funkce, které jsme si popsali
v&nbsp;předchozích kapitolách. Ve skutečnosti se mohou používat čtyři typy
zpráv. Tyto typy jsou pojmenovány RAW, NL, JSON a JS, viz též následující
tabulku:</p>

<table>
<tr><th>Typ zprávy</th><th>Význam</th></tr>
<tr><td>RAW</td><td>obecný formát, s&nbsp;nímž Vim nijak speciálně nenakládá, pouze zprávu pošle či přijme</td></tr>
<tr><td>NL</td><td>každá textová zpráva je ukončena znakem pro konec řádku (NL)</td></tr>
<tr><td>JSON</td><td>formát JSON</td></tr>
<tr><td>JS</td><td>formát JSON s&nbsp;klíči odpovídajícími JavaScriptu</td></tr>
</table>

<p>Samotné pluginy mohou pracovat ve čtyřech režimech:</p>

<table>
<tr><th>Režim</th><th>Typ připojení</th><th>Popis</th></tr>
<tr><td>démon</td><td>socket</td><td>proces, ke kterému se může připojit více instancí Vimu</td></tr>
<tr><td>úloha (job)</td><td>socket nebo pipe</td><td>proces, ke kterému se připojuje jedna instance Vimu (ten ho typicky i spustí)</td></tr>
<tr><td>krátká úloha</td><td>socket nebo pipe</td><td>dtto jako předchozí, typicky však proces neběží po celou dobu existence Vimu</td></tr>
<tr><td>filtr</td><td>pipe</td><td>spouští se synchronně, Vim čeká na výsledek operace</td></tr>
</table>



<p><a name="k08"></a></p>
<h2 id="k08">8. Vytvoření kanálu a přenos dat</h2>

<p>Nový kanál určený pro komunikaci s&nbsp;démonem či úlohou (viz tabulka
uvedené <a href="#k07">v&nbsp;předchozí kapitole</a>), se vytváří funkcí
<strong>ch_open()</strong>. Například pro démona lokálně běžícího na stejném
počítači a poslouchajícího na portu 1234 se použije tento příkaz:</p>

<pre>
let channel1 = ch_open("localhost:1234")
</pre>

<p><div class="rs-tip-major">Poznámka: používejte čísla portů větší než 1024 a
samozřejmě neobsazená dalšími službami. Obsazené porty vypíše například nástroj
<strong>lsof</strong>.</div></p>

<p>Jakmile je kanál vytvořen, lze démonu poslat nějaká data, a to konkrétně
funkcí <strong>ch_evalexpr(kanál, data)</strong>:</p>

<pre>
ch_evalexpr(channel1, "Hello daemon")
</pre>

<p>Pokud démon vrátí nějakou zprávu, je tato zpráva vrácena jako výsledek
funkce <strong>ch_evalexpr()</strong>:</p>

<pre>
let response = ch_evalexpr(channel1, "Hello daemon")
echo response
</pre>

<p>Na konci skriptu je nutné kanál zavřít a uvolnit tak příslušný socket:</p>

<pre>
ch_close(channel1)
</pre>



<p><a name="k09"></a></p>
<h2 id="k09">9. Úlohy (jobs)</h2>

<p>Pro spuštění pluginů v&nbsp;samostatných procesech se používá nová funkce
nazvaná <strong>job_start()</strong>. Tato funkce má jeden nepovinný parametr,
kterým je příkaz pro spuštění (například cesta ke skriptu atd.). Nepovinným
parametrem <i>options</i> je možné funkci <strong>job_start()</strong> předat
způsob spuštění úlohy, například zda se mají pro komunikaci použít kanály či
roury (<i>pipy</i>), jak dlouho se má čekat na dokončení volání
(<i>timeout</i>) atd. Jakmile je úloha spuštěna, lze její stav zjistit
zavoláním funkce <strong>job_status()</strong> vracející řetězec
&bdquo;run&ldquo;, &bdquo;fail&ldquo; (nepodařil se start) nebo
&bdquo;dead&ldquo; (start se podařil, nicméně úloha již skončila). Explicitní
ukončení úlohy zajišťuje funkce pojmenovaná jednoduše
<strong>job_stop()</strong>, které lze navíc v&nbsp;Linuxu předat signál pro
ukončení: &bdquo;term&ldquo;, &bdquo;hup&ldquo;, &bdquo;quit&ldquo; apod. A to
nejdůležitější na konec: pokud se úloha spustila, je možné získat komunikační
kanál funkcí <strong>job_channel()</strong> a následně použít techniku popsanou
v&nbsp;předchozích třech kapitolách.</p>



<p><a name="k10"></a></p>
<h2 id="k10">10. Využití synergie mezi všemi zmíněnými technologiemi: skutečně fungující asynchronně běžící skripty</h2>

<p>Nyní již alespoň do určité míry známe všechny nové technologie, které je
možné použít při tvorbě pluginů (přídavných modulů), které mají běžet
asynchronně, tj.&nbsp;nezávisle na operacích prováděných uživatelem. Typicky si
takto fungující pluginy připraví nějaké okno (<i>Quickfix view</i> atd.), do
kterého postupně vypíšou informace získané při svém běhu. Asynchronně běžící
pluginy bývají spuštěny přes <a href="#05">časovač</a> (kterému se předává <a
href="#k04">funcref</a> nebo <a href="#k03">anonymní funkce</a>), pro
komunikaci používají <a href="#k07">kanál</a> (kanály) a vlastní komunikace
typicky probíhá <a href="#k02">s&nbsp;využitím JSONu</a> (i když to například u
dále popsaných pluginů neplatí &ndash; ty totiž vykonávají poměrně jednoduché
činnosti). Pojďme se tedy seznámit s&nbsp;trojicí praktických pluginů
pojmenovaných jednoduše <a href="#k11">asyncrun</a>, <a href="#k14">agrep</a> a
<a href="k16">amake</a>.</p>

*** image ***
<p><i>Obrázek 15: Nápověda k&nbsp;dále popsanému pluginu
<strong>agrep</strong>.</i></p>



<p><a name="k11"></a></p>
<h2 id="k11">11. Plugin <strong>asyncrun</strong></h2>

<p>První plugin, s&nbsp;nímž se v&nbsp;dnešním článku seznámíme, se jmenuje
<strong>asyncrun</strong>. Název pluginu je to skutečně příhodný, protože tento
přídavný modul slouží ke spuštění prakticky libovolného externího příkazu,
jehož výsledek se následně objeví v&nbsp;<i>quickfix</i> okně. Pokud externí
příkaz vypíše nějaké chyby, mohou být automaticky rozpoznány na základě volby
<strong>errorformat</strong> (viz vestavěná nápověda <strong>:help
errorformat</strong>) a bude možné použít standardní příkazy pro skok na
předchozí resp.&nbsp;na následující chybu, což jsme si již ukázali
v&nbsp;článku <a
href="https://www.root.cz/clanky/textovy-editor-vim-jako-ide-2-cast/#k03">Textový
editor Vim jako IDE (2.část)</a>. Důležité přitom je, že spuštěný externí
příkaz může běžet relativně dlouho, ovšem uživatele to nijak neomezuje &ndash;
ten může prakticky pokračovat v&nbsp;práci s&nbsp;textovým editorem. Po
ukončení skriptu může být uživatel informován pípnutím (pokud jste si ovšem
tuto možnost nevypnuli).</p>

*** image ***
<p><i>Obrázek 16: Volba <strong>errorformat</strong> je samozřejmě opět popsána
v&nbsp;nápovědě.</i></p>

<p>Funkci tohoto pluginu pěkně ukazuje animovaný GIF, který naleznete na adrese
<a
href="https://raw.githubusercontent.com/skywind3000/asyncrun.vim/master/doc/screenshot.gif">https://raw.githubusercontent.com/skywind3000/asyncrun.vim/master/doc/screenshot.gif</a>.</p>



<p><a name="k12"></a></p>
<h2 id="k12">12. Instalace pluginu <strong>asyncrun</strong></h2>

<p>Před popisem instalace pluginu <strong>asyncrun</strong> se alespoň krátce
zmiňme o další novince, kterou přinesl Vim 8. Jedná se o standardního správce
balíčků.</p>

<p>Při instalaci většího množství pluginů prakticky vždy stojíme před závažným
problémem &ndash; jak tyto pluginy instalovat či odinstalovat bez rozbití
konfigurace ostatních pluginů? Jádro problému spočívá v&nbsp;tom, že
v&nbsp;předchozích verzích Vimu (konkrétně od Vimu 5.0 do Vimu 7.x) byly cesty
nastavené takovým způsobem, že se pluginy musely buď rozbalovat do společných
adresářů (všechny nápovědy v&nbsp;jednom adresáři, všechny syntaktické soubory
v&nbsp;dalším adresáři, skripty v&nbsp;adresáři třetím atd.) popř.&nbsp;bylo
nutné použít některý správce pluginů &ndash; typicky Vundle či Pathogen. Ovšem
situace, kdy se pro správu pluginů musel používat jiný plugin, byla ...
suboptimální :-). Z&nbsp;tohoto důvodu je ve Vimu 8 možné použít interního
správce a postupně tak odstranit nutnost použití Vundle či Pathogenu. To ale
nějaký čas potrvá, protože se musí stávající balíčky s&nbsp;pluginy upravit.
Nicméně již dnes můžeme několik nových balíčků kompatibilních s&nbsp;Vimem 8
nalézt, popř.&nbsp;lze zkombinovat standardního správce s&nbsp;Vundlem či
Pathogenem.</p>

*** image ***
<p><i>Obrázek 17: Nápověda ke standardnímu správci balíčků.</i></p>

<p>Při používání standardního správce balíčků z&nbsp;Vimu 8 je důležité, aby se
pluginy po rozbalení umístily do správných adresářů, v&nbsp;nichž je bude Vim
po svém spuštění a inicializaci hledat. Nejjednodušší je instalace pluginů
pouze pro aktivního uživatele, protože v&nbsp;tomto případě je celá adresářová
struktura umístěna v&nbsp;adresáři <strong>~/.vim</strong>. V&nbsp;tomto
adresáři musí být vytvořen podadresář nazvaný <strong>pack</strong> a
v&nbsp;něm další podadresář s&nbsp;libovolným jménem (já jsem v&nbsp;příkladu
použil podadresář nazvaný <strong>balicky</strong>, ale můžete použít i jiné
označení):</p>

<pre>
[~/.vim]$ <strong>tree</strong>
&nbsp;
.
└── pack
    └── balicky
</pre>

<p>Další dělení je jednoduché &ndash; v&nbsp;dalším podadresáři nazvaném
<strong>opt</strong> jsou umístěny ty pluginy, které se mají načítat až na
základě žádosti uživatele (<i>optional</i>), zatímco v&nbsp;podadresáři
<strong>start</strong> budou umístěny ty pluginy, které se načtou a
inicializují automaticky:</p>

<pre>
├── pack
│   └── balicky
│       ├── start
│       └── opt
</pre>

<p>Nyní se tedy konečně dostáváme k&nbsp;tomu, jak nainstalovat balíček
<strong>asyncrun</strong>. Ve Vimu 8 k&nbsp;tomu potřebujeme pouze použít Git a
naklonovat si příslušný repositář do adresáře
<strong>~/.vim/pack/balicky/start</strong>:</p>

<pre>
cd ~/.vim/pack/balicky/start
git clone https://github.com/skywind3000/asyncrun.vim
</pre>

<p>Výsledek by měl vypadat přibližně následovně:</p>

<pre>
.
├── autoload
├── doc
├── ftplugin
├── pack
│   └── balicky
│       └── start
│           └── asyncrun.vim
│               ├── doc
│               │   ├── asyncrun.txt
│               │   ├── cooperate_with_fugitive.gif
│               │   ├── errormarker.jpg
│               │   ├── screenshot.gif
│               │   └── simple.png
│               ├── LICENSE
│               ├── plugin
│               │   └── asyncrun.vim
│               └── README.md
├── plugin
├── spell
│   ├── cs.utf-8.add
│   ├── cs.utf-8.add.spl
│   ├── cs.utf-8.spl
│   ├── en.utf-8.add
│   └── en.utf-8.add.spl
└── syntax
</pre>

<p>Po naklonování a restartu Vimu bude balíček připraven k&nbsp;použití.</p>



<p><a name="k13"></a></p>
<h2 id="k13">13. Použití pluginu <strong>asyncrun</strong></h2>

<p>Praktické použití tohoto pluginu je ve skutečnosti velmi jednoduché.
Postačuje totiž kromě standardního příkazu <strong>:! libovolný_externí_příkaz
argumenty</strong> použít volání <strong>:Asyncrun libovolný_externí_příkaz
argumenty</strong>. Zadaný externí příkaz se spustí asynchronně a jeho výstup
se postupně přidává do okna <i>quickfix</i>. Aby byl výstup skutečně viditelný,
nastavte si globální proměnnou <strong>g:asyncrun_open</strong> na nenulovou
hodnotu &ndash; viz též následující screenshot:</p>

*** image ***
<p><i>Obrázek 18: Nastavení hodnoty globální proměnné
<strong>g:asyncrun_open</strong>.</i></p>

<p>Chování tohoto pluginu je možné ovlivnit několika globálními proměnnými:</p>

<table>
<tr><th>Proměnná</th><th>Význam</th></tr>
<tr><td>g:asyncrun_open</td><td>výška quickfix okna (zadaná v&nbsp;počtu řádků), do kterého se vypíše výstup skriptu</td></tr>
<tr><td>g:asyncrun_bell</td><td>povolení či zákaz pípnutí po dokončení skriptu</td></tr>
<tr><td>g:asyncrun_mode</td><td>režim spuštění skriptu (synchronní, asynchronní, přes příkaz :shell)</td></tr>
<tr><td>g:asyncrun_exit</td><td>lze specifikovat skript/funkci spuštěnou po dokončení asynchronního skriptu</td></tr>
<tr><td>g:asyncrun_encs</td><td>kódování výstupu asynchronně spuštěného skriptu</td></tr>
</table>

*** image ***
<p><i>Obrázek 19: Asynchronní spuštění skriptu
<strong>./build.sh</strong>.</i></p>



<p><a name="k14"></a></p>
<h2 id="k14">14. Plugin <strong>agrep</strong></h2>

<p>Druhý plugin, s&nbsp;nímž se dnes ve stručnosti seznámíme, se jmenuje
<strong>agrep</strong>. Opět se jedná o přiléhavý název, protože tento modul do
značné míry nahrazuje příkazy <strong>:vimgrep</strong> a
<strong>:grep</strong>. Navíc tento plugin zobrazuje výsledek vyhledání
odlišným způsobem, který může být pro mnoho uživatelů čitelnější. Ostatně se
sami podívejte na následující <a
href="https://camo.githubusercontent.com/a33af9dadba0a02aed739b7324fae14ebda154e6/687474703a2f2f692e696d6775722e636f6d2f67573871304b6b2e6769663f31">animovaný
GIF</a>, v&nbsp;němž jsou některé možnosti tohoto přídavného modulu ukázány. Na
animaci je patrné, že vyhledávání skutečně probíhá asynchronně.</p>

*** image ***
<p><i>Obrázek 20: Nápověda k&nbsp;pluginu <strong>agrep</strong>.</i></p>

<p>Instalace pluginu <strong>agrep</strong> probíhá naprosto stejným způsobem,
jako tomu bylo u předchozího pluginu <strong>Asyncrun</strong>:</p>

<pre>
cd ~/.vim/pack/balicky/start
git clone https://github.com/ramele/agrep
</pre>

<p>Výsledná struktura adresáře <strong>.vim</strong> může vypadat
následovně:</p>

<pre>
.
├── autoload
├── doc
├── ftplugin
└── pack
    └── balicky
        └── start
            ├── agrep
            │   ├── doc
            │   │   └── agrep.txt
            │   ├── perl
            │   │   └── agrep.pl
            │   ├── plugin
            │   │   └── agrep.vim
            │   ├── README.md
            │   └── syntax
            │       ├── agrep.vim
            │       └── qf.vim
            └── asyncrun.vim
                ├── doc
                │   ├── asyncrun.txt
                │   ├── cooperate_with_fugitive.gif
                │   ├── errormarker.jpg
                │   ├── screenshot.gif
                │   └── simple.png
                ├── LICENSE
                ├── plugin
                │   └── asyncrun.vim
                └── README.md
</pre>



<p><a name="k15"></a></p>
<h2 id="k15">15. Použití pluginu <strong>agrep</strong></h2>

<p></p>


*** image ***
<p><i>Obrázek 21: Spuštění příkazu <strong>:Agrep</strong> nad celým domovským
adresářem.</i></p>

<p></p>

*** image ***
<p><i>Obrázek 22: Výsledky vyhledání všech souborů
&bdquo;requirements.txt&ldquo;.</i></p>



<p><a name="k16"></a></p>
<h2 id="k16">16. Plugin <strong>amake</strong></h2>

<pre>
.
├── autoload
├── doc
├── ftplugin
├── pack
│   └── balicky
│       └── start
│           ├── agrep
│           │   ├── doc
│           │   │   └── agrep.txt
│           │   ├── perl
│           │   │   └── agrep.pl
│           │   ├── plugin
│           │   │   └── agrep.vim
│           │   ├── README.md
│           │   └── syntax
│           │       ├── agrep.vim
│           │       └── qf.vim
│           ├── asyncrun.vim
│           │   ├── doc
│           │   │   ├── asyncrun.txt
│           │   │   ├── cooperate_with_fugitive.gif
│           │   │   ├── errormarker.jpg
│           │   │   ├── screenshot.gif
│           │   │   └── simple.png
│           │   ├── LICENSE
│           │   ├── plugin
│           │   │   └── asyncrun.vim
│           │   └── README.md
│           └── vim-amake
│               ├── autoload
│               │   └── amake.vim
│               ├── plugin
│               │   └── amake.vim
│               └── README.md
├── plugin
├── spell
│   ├── cs.utf-8.add
│   ├── cs.utf-8.add.spl
│   ├── cs.utf-8.spl
│   ├── en.utf-8.add
│   └── en.utf-8.add.spl
└── syntax
</pre>


<p><a name="k17"></a></p>
<h2 id="k17">17. Použití pluginu <strong>amake</strong></h2>



<p><a name="k18"></a></p>
<h2 id="k18">18. Interní funkce těchto pluginů</h2>



<p><a name="k19"></a></p>
<h2 id="k19">19. Okno terminálu (novinka ve Vimu 8.1)</h2>

<p></p>



<p><a name="k20"></a></p>
<h2 id="k20">20. Odkazy na Internetu</h2>

<ol>

<li>Vim &ndash; the editor<br />
<a href="http://www.vim.org/">http://www.vim.org/</a>
</li>

<li>Vim 8.0 is released<br />
<a href="https://laravel-news.com/2016/09/vim-8-0-is-released/">https://laravel-news.com/2016/09/vim-8-0-is-released/</a>
</li>

<li>Vim: So long Pathogen, hello native package loading<br />
<a href="https://shapeshed.com/vim-packages/">https://shapeshed.com/vim-packages/</a>
</li>

<li>Asynchronous grep plugin for Vim<br />
<a href="https://github.com/ramele/agrep">https://github.com/ramele/agrep</a>
</li>

<li>Run Async Shell Commands in Vim 8.0 / NeoVim and Output to Quickfix Window<br />
<a href="https://github.com/skywind3000/asyncrun.vim">https://github.com/skywind3000/asyncrun.vim</a>
</li>

<li>:smile command was not backported! #5116<br />
<a href="https://github.com/neovim/neovim/issues/5116">https://github.com/neovim/neovim/issues/5116</a>
</li>

<li>Run :make and :grep in background jobs (experimental)<br />
<a href="https://github.com/edkolev/vim-amake">https://github.com/edkolev/vim-amake</a>
</li>

<li>Favorite vim plugins<br />
<a href="http://sherifsoliman.com/2016/05/30/favorite-vim-plugins/">http://sherifsoliman.com/2016/05/30/favorite-vim-plugins/</a>
</li>

<li>Makejob<br />
<a href="http://www.vim.org/scripts/script.php?script_id=5479">http://www.vim.org/scripts/script.php?script_id=5479</a>
</li>

<li>Články o Vimu na Root.cz:<br />
<a href="http://www.root.cz/n/vim/clanky/">http://www.root.cz/n/vim/clanky/</a>
</li>

<li>Vim sedm - první část<br />
<a href="http://www.root.cz/clanky/vim-sedm-prvni-cast/">http://www.root.cz/clanky/vim-sedm-prvni-cast/</a>
</li>

<li>vim (man page)<br />
<a href="http://www.linux-tutorial.info/modules.php?name=ManPage&sec=1&manpage=vim">http://www.linux-tutorial.info/modules.php?name=ManPage&sec=1&manpage=vim</a>
</li>

<li>History of the Text Editor<br />
<a href="http://vanstee.me/history-of-the-text-editor.html">http://vanstee.me/history-of-the-text-editor.html</a>
</li>

<li>Interview with Bill Joy<br />
<a href="http://web.cecs.pdx.edu/~kirkenda/joy84.html">http://web.cecs.pdx.edu/~kirkenda/joy84.html</a>
</li>

<li>vi Editor Commands<br />
<a href="http://www.cs.rit.edu/~cslab/vi.html#A1.4">http://www.cs.rit.edu/~cslab/vi.html#A1.4</a>
</li>

<li>vi Manual<br />
<a href="http://www.cs.fsu.edu/general/vimanual.html">http://www.cs.fsu.edu/general/vimanual.html</a>
</li>

<li>Mastering the Vi Editor<br />
<a href="http://www.susnet.uk/mastering-the-vi-editor">http://www.susnet.uk/mastering-the-vi-editor</a>
</li>

<li>Vim as a Python IDE, or Python IDE as Vim<br />
<a href="http://blog.jetbrains.com/pycharm/2013/06/vim-as-a-python-ide-or-python-ide-as-vim/">http://blog.jetbrains.com/pycharm/2013/06/vim-as-a-python-ide-or-python-ide-as-vim/</a>
</li>

<li>Vi Improved<br />
<a href="https://wiki.python.org/moin/Vim">https://wiki.python.org/moin/Vim</a>
</li>

<li>Popis skriptu Vim Pathogen<br />
<a href="http://www.vim.org/scripts/script.php?script_id=2332">http://www.vim.org/scripts/script.php?script_id=2332</a>
</li>

<li>Poslední­verze skriptu Vim Pathogen<br />
<a href="https://tpo.pe/pathogen.vim">https://tpo.pe/pathogen.vim</a>
</li>

<li>Nejlepší pluginy pro Vim<br />
<a href="http://vimawesome.com/">http://vimawesome.com/</a>
</li>

<li>Nejlepší pluginy pro Vim<br />
<a href="http://www.vim.org/scripts/script_search_results.php?order_by=rating">http://www.vim.org/scripts/script_search_results.php?order_by=rating</a>
</li>

<li>Building Vim<br />
<a href="http://vim.wikia.com/wiki/Building_Vim">http://vim.wikia.com/wiki/Building_Vim</a>
</li>

<li>Vim plugins for developers<br />
<a href="http://www.linuxtoday.com/upload/vim-plugins-for-developers-140619094010.html">http://www.linuxtoday.com/upload/vim-plugins-for-developers-140619094010.html</a>
</li>

<li>Writing Vim Plugins<br />
<a href="http://stevelosh.com/blog/2011/09/writing-vim-plugins/">http://stevelosh.com/blog/2011/09/writing-vim-plugins/</a>
</li>

<li>how to understand this vim script?<br />
<a href="http://stackoverflow.com/questions/12625091/how-to-understand-this-vim-script">http://stackoverflow.com/questions/12625091/how-to-understand-this-vim-script</a>
</li>

<li>Novinky ve VIM 7: Skriptovací­ jazyk<br />
<a href="http://www.root.cz/vim-sedm-druha-cast/">http://www.root.cz/vim-sedm-druha-cast/</a>
</li>

<li>DirDiff.vim : A plugin to diff and merge two directories recursively.<br />
<a href="http://www.vim.org/scripts/script.php?script_id=102">http://www.vim.org/scripts/script.php?script_id=102</a>
</li>

<li>vim-dirdiff na GitHubu<br />
<a href="https://github.com/will133/vim-dirdiff">https://github.com/will133/vim-dirdiff</a>
</li>

<li>fakeclip : pseudo clipboard register for non-GUI version of Vim<br />
<a href="http://www.vim.org/scripts/script.php?script_id=2098">http://www.vim.org/scripts/script.php?script_id=2098</a>
</li>

<li>vim-fakeclip na GitHubu<br />
<a href="https://github.com/kana/vim-fakeclip">https://github.com/kana/vim-fakeclip</a>
</li>

<li>vim-fakeclip: Dokumentace<br />
<a href="http://kana.github.io/config/vim/fakeclip.html">http://kana.github.io/config/vim/fakeclip.html</a>
</li>

<li>Vim Multiple Cursors na GitHubu<br />
<a href="https://github.com/terryma/vim-multiple-cursors">https://github.com/terryma/vim-multiple-cursors</a>
</li>

<li>SLIME (Wikipedia)<br />
<a href="http://en.wikipedia.org/wiki/SLIME">http://en.wikipedia.org/wiki/SLIME</a>
</li>

<li>vim-slime na GitHubu<br />
<a href="https://github.com/jpalardy/vim-slime">https://github.com/jpalardy/vim-slime</a>
</li>

<li>The NERD tree: A tree explorer plugin for navigating the filesystem<br />
<a href="http://www.vim.org/scripts/script.php?script_id=1658">http://www.vim.org/scripts/script.php?script_id=1658</a>
</li>

<li>JavaBrowser : Shows java file class, package in a tree as in IDEs. Java source browser.<br />
<a href="http://www.vim.org/scripts/script.php?script_id=588">http://www.vim.org/scripts/script.php?script_id=588</a>
</li>

<li>snippetsEmu : An attempt to emulate TextMate's snippet expansion<br />
<a href="http://www.vim.org/scripts/script.php?script_id=1318">http://www.vim.org/scripts/script.php?script_id=1318</a>
</li>

<li>c.vim : C/C++ IDE key mappings<br />
<a href="http://lug.fh-swf.de/vim/vim-c/c-hotkeys.pdf">http://lug.fh-swf.de/vim/vim-c/c-hotkeys.pdf</a>
</li>

<li>Základní základy editoru Vim<br />
<a href="http://www.root.cz/clanky/zakladni-zaklady-editoru-vim/">http://www.root.cz/clanky/zakladni-zaklady-editoru-vim/</a>
</li>

<li>Jak si přizpůsobit Vim<br />
<a href="http://www.root.cz/serialy/jak-si-prizpusobit-vim/">http://www.root.cz/serialy/jak-si-prizpusobit-vim/</a>
</li>

<li>Taglist (plugin)<br />
<a href="http://www.vim.org/scripts/script.php?script_id=273">http://www.vim.org/scripts/script.php?script_id=273</a>
</li>

<li>Tutorial: Make Vim as Your C/C++ IDE Using c.vim Plugin<br />
<a href="http://www.thegeekstuff.com/2009/01/tutorial-make-vim-as-your-cc-ide-using-cvim-plugin/">http://www.thegeekstuff.com/2009/01/tutorial-make-vim-as-your-cc-ide-using-cvim-plugin/</a>
</li>

<li>c.vim : C/C++ IDE<br />
<a href="http://vim.sourceforge.net/scripts/script.php?script_id=213">http://vim.sourceforge.net/scripts/script.php?script_id=213</a>
</li>

<li>The History of Vim<br />
<a href="https://jovicailic.org/2014/06/the-history-of-vim/">https://jovicailic.org/2014/06/the-history-of-vim/</a>
</li>

<li>Display date-and-time on status line<br />
<a href="http://vim.wikia.com/wiki/Display_date-and-time_on_status_line">http://vim.wikia.com/wiki/Display_date-and-time_on_status_line</a>
</li>

</ol>



<p></p><p></p>
<p><small>Autor: <a href="http://www.fit.vutbr.cz/~tisnovpa">Pavel Tišnovský</a> &nbsp; 2018</small></p>
</body>
</html>

