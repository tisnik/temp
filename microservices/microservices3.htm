<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
        "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html>
<head>
<title>Posílání zpráv v aplikacích založených na mikroslužbách</title>
<meta name="Author" content="Pavel Tisnovsky" />
<meta name="Generator" content="vim" />
<meta http-equiv="content-type" content="text/html; charset=utf-8" />
<style type="text/css">
         body {color:#000000; background:#ffffff;}
         h1  {font-family: arial, helvetica, sans-serif; color:#ffffff; background-color:#c00000; text-align:center; padding-left:1em}
         h2  {font-family: arial, helvetica, sans-serif; color:#ffffff; background-color:#0000c0; padding-left:1em; text-align:left}
         h3  {font-family: arial, helvetica, sans-serif; color:#000000; background-color:#c0c0c0; padding-left:1em; text-align:left}
         h4  {font-family: arial, helvetica, sans-serif; color:#000000; background-color:#e0e0e0; padding-left:1em; text-align:left}
         a   {font-family: arial, helvetica, sans-serif;}
         li  {font-family: arial, helvetica, sans-serif; color:#000000; text-align:justify; width:450px;}
         ol  {font-family: arial, helvetica, sans-serif; color:#000000; text-align:justify; width:450px;}
         ul  {font-family: arial, helvetica, sans-serif; color:#000000; text-align:justify; width:450px;}
         p   {font-family: arial, helvetica, sans-serif; color:#000000; text-align:justify;}
         pre {background:#e0e0e0}
</style>
</head>

<body>

<h1>Posílání zpráv v aplikacích založených na mikroslužbách</h1>

<h3>Pavel Tišnovský</h3>

<p></p>

<h1>Úvodník</h1>

<p>Ve třetím článku o návrhu a tvorbě aplikací založených na mikroslužbách se budeme zabývat některými způsoby, jakými mezi sebou mikroslužby komunikují. Návrh správné komunikace je po rozdělení databáze (viz předchozí část) další kritickou částí celé architektury mikroslužeb.</p>



<h2>Obsah</h2>

<p><a href="#k01">1. Posílání zpráv v&nbsp;aplikacích založených na mikroslužbách</a></p>
<p><a href="#k02">2. Dvě klíčové součásti návrhu mikroslužeb: databáze a komunikace</a></p>
<p><a href="#k03">3. Zajištění nezávislosti mikroslužeb aneb koncept tlačítka STOP</a></p>
<p><a href="#k04">4. Význam pojmů CQS a CQRS</a></p>
<p><a href="#k05">5. Tři důvody, proč poslat zprávu</a></p>
<p><a href="#k06">6. Zpráva požadující provedení úlohy &ndash; <strong>COMMAND</strong></a></p>
<p><a href="#k07">7. Směrování používané při posílání příkazů (<strong>COMMAND</strong>)</a></p>
<p><a href="#k08">8. Zpráva poslaná ve chvíli, kdy došlo k&nbsp;nějaké události &ndash; <strong>EVENT</strong></a></p>
<p><a href="#k09">9. Směrování používané při vzniku události (<strong>EVENT</strong>)</a></p>
<p><a href="#k10">10. Zpráva pro získání nějaké informace &ndash; <strong>QUERY</strong></a></p>
<p><a href="#k11">11. Směrování používané při dotazech (<strong>QUERY</strong>)</a></p>
<p><a href="#k12">12. Vzájemné propojení mezi komponentami</a></p>
<p><a href="#k13">13. Škálování aplikace ve chvíli, kdy je vytvořen &bdquo;distribuovaný monolit&ldquo;</a></p>
<p><a href="#k14">14. Jediný centralizovaný message broker</a></p>
<p><a href="#k15">15. Hierarchický model</a></p>
<p><a href="#k16">16. Další dělení hierarchického modelu</a></p>
<p><a href="#k17">17. Obsah další části seriálu</a></p>
<p><a href="#k18">18. Odkazy na Internetu</a></p>



<p><a name="k01"></a></p>
<h2 id="k01">1. Posílání zpráv v&nbsp;aplikacích založených na mikroslužbách</h2>

<p><i>&bdquo;It's hard to get messaging right&ldquo;</i></p>

<p><a
href="https://www.root.cz/clanky/zpusoby-ulozeni-dat-v-aplikacich-zalozenych-na-mikrosluzbach/">V&nbsp;předchozí
části</a> <a href="https://www.root.cz/serialy/mikrosluzby/">seriálu o
mikroslužbách</a> jsme se věnovali velmi důležitému tématu &ndash; návrhem
databáze resp.&nbsp;přesněji řečeno namodelováním reprezentace <i>stavu</i>
celé aplikace, pochopitelně včetně způsobů změny tohoto stavu. Připomeňme si,
že bylo důležité rozdělit databázi takovým způsobem, aby každá komponenta měla
k&nbsp;dispozici právě tu část databáze, kterou pro svoji činnost nutně
potřebuje. Právě rozdělení databáze pro jednotlivé komponenty je kritickou
částí návrhu, která odlišuje takzvaný &bdquo;distribuovaný monolit&ldquo; od
skutečné aplikace založené na mikroslužbách. Kromě klasického rozdělení
databáze na jednotlivé části jsme si minule popsali i takzvanou <i>architekturu
kappa</i>, v&nbsp;níž je ústředním prvkem systém <a
href="https://www.root.cz/clanky/nats-streaming-server/">NATS Streaming
Server</a> či <a href="https://kafka.apache.org/">Apache Kafka</a>, který
obsahuje neměnitelné záznamy (<i>log</i>) se všemi změnami stavu celé aplikace.
Jednotlivé komponenty tyto změny postupně aplikují na svoje lokální databáze a
přibližují se tak postupně <i>okamžitému a pravdivému stavu</i>, který je
uložen formou neměnitelných záznamů se změnami.</p>

<p><div class="rs-tip-major">Poznámka: již v&nbsp;předchozím odstavci jsme
použili označení <i>komponenta</i> (<i>component</i>). Může se jednat jak o
nějakou mikroslužbu, tak i o pomocný nástroj typu <i>message broker</i>,
<i>message bus</i>, systém pro zachycování logovacích informací atd. Termín
&bdquo;komponenta&ldquo; bude použit i v&nbsp;dalším textu, už jen z&nbsp;toho
důvodu, že je poněkud obecnější než &bdquo;mikroslužba&ldquo;.</div></p>

<a href="https://www.root.cz/obrazek/361674/"><img src="https://i.iinfo.cz/images/447/microservices2-7-prev.png" class="image-361674" alt="&#160;" width="279" height="270" /></a>
<p><i>Obrázek 1: Příklad aplikace používající architekturu kappa.</i></p>

<p>Výsledkem návrhu by měla být architektura, ve které si každá služba
autonomně řídí svůj stav a taktéž případnou změnu svého stavu (ideální je
pochopitelně mít co nejvíce komponent bezstavových &ndash; <i>stateless</i>,
pokud je to možné). Požadavky na autonomnost služeb jsou ve skutečnosti ještě
větší. Kromě toho, že služba má svoji databázi, neměla by (kromě svého API)
sdílet svůj stav a už vůbec ne svůj interní (vnitřní) stav. Což ale nejsou
příliš překvapující požadavky, protože podobné požadavky existují i
v&nbsp;objektově orientovaném programování a nazýváme je <i>zapouzdření</i>
(<i>encapculation</i>). Dále je nutné, aby služby pro komunikaci používaly vždy
své API a nikoli nějaké postranní kanály.</p>

<p><div class="rs-tip-major">Poznámka: na tomto místě je dobré upozornit na to,
že prozatím neexistuje jediná &bdquo;správná&ldquo; cesta, jaká architektura je
nejlepší, ale mnozí před námi už zjistili, které cesty jsou slepé.</div></p>

<a href="https://www.root.cz/obrazek/361137/"><img src="https://i.iinfo.cz/images/372/microservices1-4-prev.png" class="image-361137" alt="&#160;" width="358" height="270" /></a>
<p><i>Obrázek 2: Jednotlivé mikroslužby mezi sebou mohou komunikovat například
s&nbsp;využitím protokolu HTTP (REST API), STOMP atd. Ovšem důležité je, že
každá mikroslužba má svoji databázi.</i></p>



<p><a name="k02"></a></p>
<h2 id="k02">2. Dvě klíčové součásti návrhu mikroslužeb: databáze a komunikace</h2>

<p><i>&bdquo;Monolith components are large components that contain a lot of
functionality&ldquo;</i></p>

<p>Návrh databáze je skutečně primární částí naplánování modelu celé
architektury aplikace (a měl by být proveden už na začátku, ideálně možná ještě
před založením repositáře se zdrojovými kódy :-), ovšem pochopitelně se nejedná
o jedinou součást návrhu, kterou je nutné vyřešit. Dalším důležitým
architektonickým rozhodnutím je určení, jakým způsobem vlastně budou mezi sebou
jednotlivé komponenty komunikovat. A podobně jako bylo možné (mnohdy nutné) pro
každou komponentu zvolit odlišnou databázi (SQL či nějakou NoSQL, ať již
dokumentovou, objektovou nebo grafovou atd.), i způsoby vzájemné komunikace
služeb &ndash; posílání zpráv &ndash; je nutné navrhnout podle toho, o jakou
komunikaci se jedná. V&nbsp;praxi to znamená, že se většinou použije větší
množství protokolů a většinou i několik instancí <i>message brokerů</i>,
popř.&nbsp;se klasičtí message brokeři zkombinují se <i>streamingem</i>
záznamů/událostí. A v&nbsp;neposlední řadě je nutné určit, zda spolu budou
jednotlivé komponenty komunikovat přímo či zda se vytvoří centrální
popř.&nbsp;hierarchicky umístěné uzly, k&nbsp;nimž se jednotlivé komponenty
budou připojovat.</p>

<a href="https://www.root.cz/obrazek/361136/"><img src="https://i.iinfo.cz/images/372/microservices1-3-prev.png" class="image-361136" alt="&#160;" width="370" height="184" /></a>
<p><i>Obrázek 3: Monolitická služba, která je sice naškálována, ale sdílí
společnou databázi.</i></p>

<p><div class="rs-tip-major">Poznámka: někdy se, například v&nbsp;diskuzích,
můžeme setkat s&nbsp;tvrzením &bdquo;používáme mikroslužby, protože všechna
komunikace je čistě přes REST API a zprávy používají formát JSON&ldquo;. Ve
skutečnosti spolu všechny zmíněné technologie souvisí jen částečně a obecně je
možné říct, že s&nbsp;čistým REST API se při dobře navrženém messagingu
nevystačí a většinou je nutné použít i další technologie, například AMQP, MQTT
atd.</div></p>



<p><a name="k03"></a></p>
<h2 id="k03">3. Zajištění nezávislosti mikroslužeb aneb koncept tlačítka STOP</h2>

<p><i>&bdquo;As a fan of microservices, I fear enterprises are blindly charging
forward and could be left disappointed with a microservices-based strategy if
the technology is not appropriately applied.&ldquo;<br />
Sinclair Schuller</i></p>

<p>Jak se vlastně pozná dobrý návrh architektury aplikace založené na
mikroslužbách? Samozřejmě je k&nbsp;dispozici velké množství kritérií,
například propustnost, maximální počet současně obsluhovaných klientů,
škálovatelnost, systémové nároky atd. atd. Existuje ovšem ještě jedno zajímavé
kritérium, které osobně označuji termínem &bdquo;tlačítko STOP&ldquo;. Celá
aplikace by totiž měla být &ndash; pochopitelně v&nbsp;ideálním světě &ndash;
schopna do jisté míry fungovat i tehdy, pokud nějakou z&nbsp;komponent
(mikroslužeb atd.) vypneme. A i když aplikace přestane nabízet některé služby,
měla by být schopna se automaticky vrátit k&nbsp;běžné činnosti ihned poté, co
se zastavená komponenta opět restartuje. Právě toto chování totiž vyžadujeme
&ndash; schopnost aplikace se &bdquo;vzpamatovat&ldquo; i po částečném výpadku,
a to bez toho, aby se musela celá aplikace vypnout s&nbsp;postupným zapínáním
služeb podle nějakého návodu (toto chování ponechme monolitním aplikacím).</p>

<img src="https://i.iinfo.cz/images/683/microservices3-1.jpg" class="image-362130" alt="&#160;" width="400" height="492" />
<p><i>Obrázek 4: Jedna z&nbsp;nejjednodušších forem testování mikroslužeb
&ndash; tlačítko STOP u každé mikroslužby.</i></p>

<p><div class="rs-tip-major">Poznámka: příkladem s&nbsp;velkou pravděpodobností
relativně dobře navržené architektury může být GitHub. Pokud intenzivně
používáte jeho API i GUI, mohli jste si v&nbsp;tomto roce povšimnout několika
krátkodobých výpadků, které ovšem většinou postihly pouze určitou část této
služby (například se na autorských stránkách nevypsaly správné informace o
činnostech provedených v&nbsp;posledním dni &ndash; počet commitů, počet
uzavřených issues atd.); typicky však vlastní Git fungoval. Díky oddělení
jednotlivých částí služby se restart jednotlivých komponent obešel bez nutnosti
restartu celé služby, což by pravděpodobně bylo komplikovanější a časově
náročnější. Navíc byly některé výpadky pro koncové uživatele prakticky
neviditelné a projevily se například jen zpožděným doručením notifikace,
zpožděním při poslání web hooku do CI atd. atd.</div></p>

<img src="https://i.iinfo.cz/images/683/microservices3-2.jpg" class="image-362131" alt="&#160;" width="257" height="236" />
<p><i>Obrázek 5: Výpadek složité služby, který byl viditelný i
zákazníkům.</i></p>



<p><a name="k04"></a></p>
<h2 id="k04">4. Význam pojmů CQS a CQRS</h2>

<p><i>&bdquo;“…organizations which design systems … are constrained to produce
designs which are copies of the communication structures of these
organizations.”&ldquo;</i></p>

<p>V&nbsp;souvislosti se zprávami i s&nbsp;celým návrhem architektury aplikace
založené na mikroslužbách se často setkáme s&nbsp;termíny <strong>CQS</strong>
a <strong>CQRS</strong>. Termín <strong>CQS</strong> znamená <i>Command–query
separation</i> a <strong>CQRS</strong> je zkratkou vzniklou
z&nbsp;<i>Command-query responsibility segregation</i> (nebo
<i>separation</i>). <strong>CQR</strong> se používá při vývoji a znamená takový
návrh aplikace (typicky založené na OOP, ale není to nutné), kdy každá funkce
či metoda provádí buď nějaký příkaz (<i>command</i>) nebo slouží k&nbsp;získání
dat (<i>query</i>); žádná z&nbsp;metod by neměla provádět obě akce. Zatímco se
metodika <strong>CQR</strong> typicky aplikuje na jednotlivé třídy, tedy na
relativně malou a izolovanou část aplikace, je druhá z&nbsp;metodik
<strong>CQRS</strong> aplikována na celou architekturu služeb a mikroslužeb,
přičemž <i>command</i> je ta část modelu aplikace, která slouží ke změně stavu
a <i>query</i> druhá část modelu používaná pro agregaci dat.</p>

<p>Jak by mohlo vypadat aplikování metodiky <strong>CQRS</strong> v&nbsp;praxi?
Představme si nějakou jednoduchou službu, jejímž úkolem je vést seznam
uživatelů, samozřejmě včetně jejich metadat. Tato služba bude mít svoje API,
jednoduchý model pro zápis nových uživatelů, dotaz, zda uživatel existuje,
agregace uživatelů podle různých kritérií atd. A samozřejmě bude tato služba
používat svoji databázi s&nbsp;tabulkou uživatelů a dalšími pomocnými
tabulkami.</p>

<p>Taková služba sice může dlouhou dobu pracovat bez problémů, ovšem při větší
zátěži se mohou ukázat limity používané databáze. Zjednodušeně řečeno &ndash;
pro zpracování dotazů (<strong>QUERY/SELECT</strong>) je nutné používat indexy,
ovšem existence těchto indexů obecně zhoršuje a zpomaluje operace typu
<strong>INSERT</strong>, <strong>UPDATE</strong> i <strong>DELETE</strong>.
V&nbsp;praxi se tedy musí vyvažovat mezi větším množstvím indexů pro všechny
používané dotazy a menším množstvím v&nbsp;případě, že se změny v&nbsp;databázi
negativně projevují na celkové výkonnosti služby.</p>

<p>Alternativně můžeme aplikovat metodiku <strong>CQRS</strong>. Model aplikace
se rozdělí na dvě části &ndash; změnu stavu (<strong>COMMAND</strong>) a dotazy
pro získání agregovaných dat (<strong>QUERY</strong>).</p>

<p>Řešení je ovšem možné ještě dále upravit, a to rozdělením databáze na dvě
části, z&nbsp;nichž jedna bude určena pro zápisy (těch bývá řádově menší
množství) a druhá část bude určena pro dotazy. Obě databáze ovšem bude nutné
synchronizovat.</p>

<p>V&nbsp;další iteraci může dojít k&nbsp;rozdělení celé služby na dvě části a
dokonce i k&nbsp;odstranění jedné databáze. K&nbsp;dispozici zůstane jen
databáze optimalizovaná na zápisy, kdežto namísto druhé databáze bude použita
prostá cache, pochopitelně synchronizovaná s&nbsp;databází (a zde již záleží na
tom, zda budeme potřebovat přesnou repliku či zda se spokojíme s&nbsp;tím, že
záznamy nemusí být v&nbsp;daný okamžik naprosto totožné).</p>



<p><a name="k05"></a></p>
<h2 id="k05">5. Tři důvody, proč poslat zprávu</h2>

<p><i>&bdquo;“Design the organisation you want, the architecture will follow
(kicking and screaming).”&ldquo;</i></p>

<p>Při návrhu komunikace mezi jednotlivými komponentami je dobré si uvědomit,
proč spolu vlastně jednotlivé komponenty potřebují komunikovat. V&nbsp;naprosté
většině případů se jedná o jednu ze tří možností vypsaných pod tímto
odstavcem:</p>

<ol>

<li>Jedna komponenta vyžaduje, aby některá z&nbsp;dalších komponent provedla
určitou činnost či určitý příkaz. Tento typ zprávy budeme označovat slovem
<strong>COMMAND</strong> a většinou znamená, že se změní stav aplikace
(například záznam informace o novém uživateli). Podobnost <a
href="#k04">s&nbsp;výše zmíněnou</a> metodikou <strong>CQRS</strong>
pochopitelně není náhodná.</li>

<li>Komponenta oznamuje dalším komponentám, že došlo k&nbsp;nějaké události.
Z&nbsp;tohoto důvodu budeme tento typ zprávy označovat slovem
<strong>EVENT</strong>. Samotné oznámení o vzniku události nemusí nutně
znamenat změnu stavu aplikace, ovšem na tuto zprávu mohou příjemci reagovat
posláním jiné zprávy typu <strong>COMMAND</strong>.</li>

<li>A konečně komponenta potřebuje získat nějaký údaj či údaje. Tento typ
zprávy pojmenujeme <strong>QUERY</strong> a typicky by se jejím posláním neměl
měnit stav aplikace (opět viz metodika <strong>CQRS</strong>). Z&nbsp;tohoto
hlediska se většinou jedná o nejjednodušeji implementovatelné zprávy, ovšem jak
uvidíme dále, i zde může dojít ke komplikacím v&nbsp;případě, že se o výsledku
může <i>hlasovat</i>.</li>

</ol>

<p>Tyto tři typy zpráv se odráží i v&nbsp;pojmenování některých technologií.
Můžeme se například setkat se systémy, v&nbsp;nichž se používají tři navzájem
nezávislé typy &bdquo;sběrnic zpráv&ldquo; typicky pojmenované
<strong>CommandBus</strong>, <strong>EventBus</strong> a
<strong>QueryBus</strong>.</p>



<p><a name="k06"></a></p>
<h2 id="k06">6. Zpráva požadující provedení úlohy: <strong>COMMAND</strong></h2>

<p><i>&bdquo;Microservice &ndash; “small autonomous services modelled around
business domain that work together“&ldquo;<br />
Sam Newman, jeden z&nbsp;původních autorů myšlenky mikroslužeb</i></p>

<p>Na jednotlivé typy zpráv popsaných <a href="#k05">v&nbsp;předchozí
kapitole</a> se můžeme podívat podrobněji. Zaměřme se nejdříve na první typ
zpráv, tj.&nbsp;na zprávy typu <strong>COMMAND</strong>. Tyto zprávy obecně
slouží ke změně stavu aplikace a obecně tedy provádí nějaký <i>side-effect</i>,
typicky modifikaci dat (kromě odpovědi se změní i nějaká další část aplikace,
například se zapíše záznam do databáze atd.). Můžeme se ale setkat i
s&nbsp;takovými zprávami typu <strong>COMMAND</strong>, které stav aplikace
nezmění. Poměrně dobrým příkladem může být žádost o poslání e-mailu uživateli
&ndash; zde se tedy mění spíše stav okolního systému (mailboxu příjemce).</p>

<p>Zprávy typu <strong>COMMAND</strong> jsou typické tím, že většinou existuje
pouze jediná komponenta, která může daný příkaz provést. To, o kterou
komponentu ve funkci příjemce zprávy se konkrétně jedná, však nemusí zdrojová
komponenta (tj.&nbsp;komponenta, která příkaz posílá) řešit,
resp.&nbsp;přesněji řečeno by to ani ve správně navržené aplikaci neměla řešit,
protože by se jednalo o zbytečně těsné svázání obou komponent
(mikroslužeb).</p>

<p>Většinou taktéž požadujeme, aby přijímající komponenta poslala odpověď na
zprávu typu <strong>COMMAND</strong>. V&nbsp;naprosté většině případů se jedná
o jednoduchou stavovou informaci typu <strong>OK</strong>/<strong>Not
OK</strong> popř.&nbsp;<strong>ACK</strong>/<strong>NACK</strong>, jen
výjimečně s&nbsp;dalšími daty (například s&nbsp;ID vytvořeného požadavku);
v&nbsp;případě, že by v&nbsp;odpovědi byla další data, jednalo by se
pravděpodobně o porušení <strong>CQRS</strong>. Tento typ odpovědi může být
poslán synchronně či asynchronně &ndash; viz též navazující kapitolu.</p>



<p><a name="k07"></a></p>
<h2 id="k07">7. Směrování používané při posílání příkazů (<strong>COMMAND</strong>)</h2>

<p><i>&bdquo;'Service' does not imply...Docker, Stateless, Kubernetes, JSON,
ESB, Cloud, NoSQL, ...&ldquo;<br />
Clemens Vasters</i></p>

<p>Existuje několik způsobů směrování (<i>routing</i>) používaných pro zprávy
typu <strong>COMMAND</strong>. Typicky je možné rozhodnout přímo na základě
příslušného příkazu, která komponenta má příkaz zpracovat (příklady příkazů:
<strong>create_new_user</strong>, <strong>send_notification_email</strong>
atd.). V&nbsp;tom nejjednodušším případě se příkaz ihned přepošle cílové
komponentě, ovšem většinou se setkáme s&nbsp;využitím <i>front zpráv</i>
(<i>message queue</i>), které slouží jak pro zajištění persistence zpráv
v&nbsp;případě, že přijímající komponenta není spuštěna či pokud je přetížena,
tak i případně pro <i>load balancin</i>. Použitou komunikační strategií je tedy
strategie <strong>PUSH-PULL</strong>.</p>

<img src="https://i.iinfo.cz/images/248/zmq-2-5.png" class="image-350900" alt="&#160;" width="570" height="116" />
<p><i>Obrázek 6: Komunikační strategie typu <strong>PUSH-PULL</strong> bez
použití fronty.</i></p>

<p>Samotné téma load balancingu pro zprávy typu <strong>COMMAND</strong> je
dosti rozsáhlé, protože tyto zprávy mění stav aplikace. Nicméně cílová
komponenta může být spuštěna několikrát a existuje hned několik strategií, jak
zprávy/příkazy z&nbsp;fronty přeposílat. Nejjednodušší a pravděpodobně i
nejpoužívanější řešení je založeno na tom, že se ta instance komponenty, která
má volné prostředky (strojový čas) sama přihlásí o přiřazení příkazu (úkolu),
což je zajištěno přes protokoly používané message brokery. Používají se však i
další způsoby; jeden z&nbsp;nich je založen na SLA. V&nbsp;praxi to znamená, že
příkazy související s&nbsp;&bdquo;VIP uživateli&ldquo; jsou zpracovány na
dedikovaných instancích popř.&nbsp;mají vyšší prioritu (a většina message
brokerů dokáže nějakým způsobem pracovat s&nbsp;prioritou zpráv, popř.&nbsp;lze
využít specializované prioritní fronty).</p>

<img src="https://i.iinfo.cz/images/248/zmq-2-6.png" class="image-350901" alt="&#160;" width="571" height="300" />
<p><i>Obrázek 7: Komunikační strategie typu <strong>PUSH-PULL</strong>
s&nbsp;větším počtem příjemců.</i></p>

<p>V&nbsp;předchozím textu jsme si řekli, že odpovědi na zprávy typu
<strong>COMMAND</strong> bývají většinou pouze potvrzující, tj.&nbsp;komponenta
získá informaci o tom, zda byl příkaz proveden či nikoli (popř.&nbsp;proč nebyl
proveden). Odpovědi mohou být synchronní, ovšem častěji se setkáme
s&nbsp;asynchronními odpověďmi, které umožňují, aby obě komponenty před
potvrzením mohly provádět jinou činnost. Jak se však realizují asynchronní
odpovědi? Jednou z&nbsp;možností je použití druhé fronty, do které bude zprávy
posílat příjemce příkazu (<strong>COMMAND</strong>). V&nbsp;takové odpovědi
bývá uvedeno jednoznačné ID příkazu. Alternativně se někdy můžeme setkat i
s&nbsp;tím, že přímo součástí příkazu bývá jméno nové dočasné fronty, kterou
příjemce příkazu vytvoří a která se posléze automaticky zruší (zde ovšem záleží
na typu použitého message brokera, do jaké míry je flexibilní při vytváření a
rušení front).</p>

<a href="https://www.root.cz/obrazek/348765/"><img src="https://i.iinfo.cz/images/176/rabbitmq1-4-prev.png" class="image-348765" alt="&#160;" width="370" height="158" /></a>
<p><i>Obrázek 8: Složitější konfigurace nabízená například systémem RabbitMQ.</i></p>



<p><a name="k08"></a></p>
<h2 id="k08">8. Zpráva poslaná ve chvíli, kdy došlo k&nbsp;nějaké události &ndash; <strong>EVENT</strong></h2>

<p>Druhý typ zpráv nazvaný <strong>EVENT</strong> je prakticky libovolnými
komponentami posílán ve chvíli, kdy dojde k&nbsp;určité události, o nichž chce
komponenta informovat okolní systém. Může se jednat o prakticky libovolnou
událost (tedy nikoli pouze o událost na GUI). Příkladem může být detekce změny
některých dat, zjištění, že došlo k&nbsp;překročení nějakého časového limitu,
informace o přetížení určitého uzlu v&nbsp;clusteru, informace o překročení
nastaveného limitu databáze, opakované pokusy o přihlášení atd. Můžeme sem
řadit i komponenty/mikroslužby typu <strong>cron</strong>, které slouží právě
k&nbsp;posílání informací o naplánovaných událostech, ať již periodických
(zaslání e-mailu se žádostí o změnu hesla, pravidelná kontrola jiné služby přes
její API), tak i neperiodických (ad-hoc události). Typicky komponenta pouze
oznámí, že došlo k&nbsp;nějaké události a neočekává žádné odpovědi.
Z&nbsp;implementačního hlediska je posílání a zpracování těchto zpráv
nejjednodušší.</p>



<p><a name="k09"></a></p>
<h2 id="k09">9. Směrování používané při vzniku události (<strong>EVENT</strong>)</h2>

<p>Zprávy typu <strong>EVENT</strong> se většinou směrují odlišným způsobem,
než zprávy typu <strong>COMMAND</strong>. Je tomu tak z&nbsp;toho důvodu, že na
události může reagovat obecně větší množství komponent, nikoli jediný typ
komponenty. Z&nbsp;tohoto důvodu se používá komunikační strategie
<strong>PUBLISH-SUBSCRIBE</strong> neboli <strong>PUB-SUB</strong>, která je
podporována většinou message brokerů. Ovšem můžeme se setkat i s&nbsp;dalšími
konfiguracemi, například s&nbsp;takzvanými soupeřícími konzumenty (<i>competing
consumers</i>) nebo s&nbsp;<i>balanced consumers</i>.</p>

<img src="https://i.iinfo.cz/images/248/zmq-2-4.png" class="image-350899" alt="&#160;" width="570" height="200" />
<p><i>Obrázek 9: Komunikační strategie typu <strong>PUBLISH-SUBSCRIBE</strong>
používaná při vzniku událostí.</i></p>

<p><div class="rs-tip-major">Poznámka: stále častěji se ovšem setkáme
s&nbsp;tím, že se namísto klasické komunikační strategie
<strong>PUBLISH-SUBSCRIBE</strong> použije technologie <i>streamingu</i>
událostí implementovaná v&nbsp;již zmíněném NATS Streaming Serveru nebo
v&nbsp;Apache Kafka. V&nbsp;takovém případě se záznam o události neztratí
(pokud ho komponenty nestihnou přijmout), ale je uložen do rostoucího
<i>logu</i> s&nbsp;neměnitelnými záznamy předchozích událostí. Toto řešení je
pro některé typy problémů takřka ideální, ovšem u některých aplikací můžeme
vidět i opačný problém &ndash; nasazování <i>streamingu</i> i tam, kde by neměl
být použit resp.&nbsp;tam, kde jeho použití pouze přináší větší nároky na
systémové zdroje.</div></p>



<p><a name="k10"></a></p>
<h2 id="k10">10. Zpráva pro získání nějaké informace &ndash; <strong>QUERY</strong></h2>

<p>Posledním typem zprávy jsou zprávy označované <strong>QUERY</strong>. Jak
již víme z&nbsp;předchozího textu, měly by tyto zprávy požadovat vrácení
nějakých dat popř.&nbsp;agregaci dat, ovšem přitom by nemělo dojít ke změně
stavu aplikace (<i>side-effect</i>). A opět platí &ndash; komponenta, která
data vyžaduje, by ideálně nemusela a vlastně ani neměla vědět, která komponenta
jí bude ve skutečnosti odpovídat. Jen tak je ostatně možné zaručit modularitu
celého systému i možnost výměny některé komponenty za odlišnou službu (nebo
dokonce jen za její <i>mock</i>).</p>

<p>Vzhledem k&nbsp;tomu, že tento typ zprávy vyžaduje odpověď, používá se zde
buď synchronní protokol typu <strong>REQUEST-RESPONSE</strong> nebo asynchronní
příprava dat &ndash; v&nbsp;tomto případě lze využít již zmíněné dvojice front,
kde do jedné fronty budou chodit požadavky, tj.&nbsp;zprávy typu
<strong>QUERY</strong> a do druhé fronty odpovědi s&nbsp;požadovanými daty.</p>



<p><a name="k11"></a></p>
<h2 id="k11">11. Směrování používané při dotazech (<strong>QUERY</strong>)</h2>

<p>Dotazy <strong>QUERY</strong> bývají zpracovány dvěma způsoby. V&nbsp;tom
jednodušším případě odpověď připraví a pošle jediná komponenta, která je za
poskytnutí odpovědi zodpovědná (tato komponenta ovšem může být
load-balancovaná). Odpovědi tohoto typu se zpracovávají velmi jednoduše,
protože pokud získáme jedinou odpověď, můžeme ji považovat za pravdivou.</p>

<img src="https://i.iinfo.cz/images/467/nanomsg-2-1.png" class="image-360383" alt="&#160;" width="570" height="121" />
<p><i>Obrázek 10: Synchronní odpovědi lze získat klasickou komunikační
strategií <strong>REQ-REP</strong>.</i></p>

<p>Existuje ovšem ještě jedna možnost používaná u rozsáhlých služeb. Někdy se
setkáme s&nbsp;označením <i>scatter-gather query</i> a v&nbsp;podstatě se jedná
o hlasování. Na samotný dotaz (<strong>QUERY</strong>) totiž může
v&nbsp;nastaveném časovém intervalu odpovědět větší množství komponent a každá
odpověď může být dokonce odlišná!</p>

<img src="https://i.iinfo.cz/images/467/nanomsg-2-2.png" class="image-360384" alt="&#160;" width="576" height="311" />
<p><i>Obrázek 11: Jeden dotaz s&nbsp;několika různými odpověďmi.</i></p>

<p>Dobrým příkladem může být dotaz na cenu nějaké služby nebo výrobku. Na tento
dotaz může odpovědět jedna komponenta, která zná obecné ceny, dále odpoví
komponenta, která řeší přesnější ceny a slevy pro VIP zákazníky, další
komponenta má k&nbsp;dispozici seznam slevových akcí atd. Nakonec záleží na
tazateli, kterou odpověď si vybere a jak případně zahrne všechny odpovědi do
své logiky.</p>

<p><div class="rs-tip-major">Poznámka: elasticitu tohoto řešení si můžeme
ukázat na speciální komponentě, ve které budou připraveny ceny pro určitou akci
typu <i>black friday</i>. Tuto komponentu je možné spustit jen v&nbsp;určitém
termínu a její zařazení do celé aplikace by mělo být naprosto bezproblémové
&ndash; bez nutnosti zásahu do zbylých částí aplikace! A po proběhnutí akce
<i>black friday</i> se komponenta běžným způsobem vypne, což by aplikace jako
celek měla přežít &ndash; viz výše zmíněné tlačítko
<strong>STOP</strong>.</div></p>



<p><a name="k12"></a></p>
<h2 id="k12">12. Vzájemné propojení mezi komponentami</h2>

<p>Dalším problémem, který je nutné při návrhu architektury aplikace uspokojivě
vyřešit, je konfigurace vzájemného popojení jednotlivých komponent. Zde máme
k&nbsp;dispozici hned několik možností, z&nbsp;nichž o některých již víme, že
nejsou ideální, resp.&nbsp;mnohem přesněji to ví ti vývojáři, které tyto
způsoby použili a narazili na jejich meze.</p>

<p>Mezi používané typy propojení patří:</p>

<ol>
<li>obecné propojení typu &bdquo;každý s&nbsp;každým&ldquo;</li>
<li>využití magického centralizovaného message brokeru</li>
<li>hierarchická struktura založená na tzv.&nbsp;clusterech</li>
</ol>



<p><a name="k13"></a></p>
<h2 id="k13">13. Škálování aplikace ve chvíli, kdy je vytvořen &bdquo;distribuovaný monolit&ldquo;</h2>

<p>Jeden z&nbsp;obecně nejhorších způsobů spočívá v&nbsp;tom, že každá
komponenta může přímo komunikovat s&nbsp;jinou komponentou na základě svého
vlastního rozhodnutí, přesněji řečeno na základě rozhodnutí programátora, který
danou komponentu navrhnul. Pravděpodobně vás již napadlo, že v&nbsp;tomto
případě může dojít k&nbsp;mnoha nepříjemnostem. V&nbsp;první řadě bude celá
struktura aplikace dosti chaotická, a to již ve chvíli, kdy bude aplikace
obsahovat jednotky až desítky služeb. Dále se tato architektura pravděpodobně
zcela automaticky nevzpamatuje při výpadku některého z&nbsp;uzlů (a pokud se
vzpamatuje, znamená to, že se jedná o časově náročnou práci vývojářů
jednotlivých komponent). Problematické až zcela nemožné je škálování
jednotlivých komponent, konfigurace load balancingu na základě požadavků SLA,
mechanismus, kterým se jednotlivé služby vyhledávají atd. atd.</p>

<img src="https://i.iinfo.cz/images/683/microservices3-3.png" class="image-362132" alt="&#160;" width="400" height="300" />
<p><i>Obrázek 12: Při malém množství komponent může být propojení typu
&bdquo;každý s&nbsp;každým&ldquo; zdánlivě snadno zvládnutelné.</i></p>

<p>Zajímavé a možná i typické a vlastně i pochopitelné je, že se tato
architektura používá ve chvíli, kdy se nějaký tým rozhodne rozdělit původně
monolitickou aplikaci na &bdquo;mikroslužby&ldquo;. Ovšem jedná se o ten druhý
nejhorší možný způsob, který pouze vede k&nbsp;vytvoření &bdquo;distribuovaného
monolitu&ldquo; (prvním nejhorším způsobem je postavit komponenty nad jedinou
databází).</p>

<img src="https://i.iinfo.cz/images/683/microservices3-4.png" class="image-362133" alt="&#160;" width="400" height="300" />
<p><i>Obrázek 13: Při rostoucím množství komponent se velmi rychle ukazují
limity této architektury.</i></p>



<p><a name="k14"></a></p>
<h2 id="k14">14. Jediný centralizovaný message broker</h2>

<p>Zatímco první způsob popsaný v&nbsp;předchozím textu představoval jeden
extrém, můžeme se setkat i s&nbsp;opačným extrémem. Ten bývá založen
(v&nbsp;tom lepším případě) na centrálním uzlu s&nbsp;message brokerem, přes
který jednotlivé služby komunikují. Přitom je zaručeno, že žádné jiné
komunikační cesty nebudou použity. Ve skutečnosti se nejedná o špatný návrh,
ovšem musíme počítat s&nbsp;tím, že se při jeho důsledném dodržování zhorší
škálovatelnost a i další růst aplikace o další komponenty/mikroslužby bude
omezen výkonem a škálovatelností message brokera (musíme navíc uvažovat i o
případných omezeních daných vrstvou a fyzickým oddělením jednotlivých komponent
na různé stroje). Pro menší aplikace se však může jednat o dobrý přístup.</p>

<img src="https://i.iinfo.cz/images/683/microservices3-5.png" class="image-362134" alt="&#160;" width="400" height="300" />
<p><i>Obrázek 14: Při relativně malém množství komponent bývá použití
centrálního message brokera dobrou volbou.</i></p>

<img src="https://i.iinfo.cz/images/683/microservices3-6.png" class="image-362135" alt="&#160;" width="400" height="394" />
<p><i>Obrázek 15: Pokud však počet komunikujících komponent překročí určitou
mez, může se message broker stát úzkým hrdlem celé aplikace.</i></p>



<p><a name="k15"></a></p>
<h2 id="k15">15. Hierarchický model</h2>

<p>V&nbsp;případě ještě větších aplikací s&nbsp;mnoha desítkami či dokonce se
stovkami komponent je však nutné způsob komunikace navrhnout ještě pečlivěji.
Setkáme se například se sdružováním jednotlivých komponent do větších
hierarchicky organizovaných celků (řekněme <i>clusterů</i> v&nbsp;původním
významu tohoto slova), přičemž každý z&nbsp;těchto clusterů sdružuje služby,
které k&nbsp;sobě logicky patří. V&nbsp;každém clusteru se typicky nachází
centrální message broker a všechny služby v&nbsp;clusteru komunikují pouze
s&nbsp;tímto uzlem. Jednotlivé clustery jsou spojeny dalším (tentokrát již
centrálním) message brokerem, takže výsledkem může být poměrně snadno
uchopitelná a elegantní rekurzivní struktura. Výkonnost tohoto řešení je
založená na předpokladu, že logicky související služby spolu komunikují
častěji, takže centrální message broker není přetěžován.</p>

<a href="https://www.root.cz/obrazek/362136/"><img src="https://i.iinfo.cz/images/683/microservices3-7-prev.png" class="image-362136" alt="&#160;" width="363" height="270" /></a>
<p><i>Obrázek 16: Hierarchický model aplikace se sdružením těch služeb, které
k&nbsp;sobě patří buď logicky, nebo podle toho, jak intenzivně spolu
komunikují.</i></p>



<p><a name="k16"></a></p>
<h2 id="k16">16. Další dělení hierarchického modelu</h2>

<p>Prakticky nic nám pochopitelně nebrání v&nbsp;tom, aby byl hierarchický model ještě více strukturovaný, což je naznačeno na následujícím obrázku:</p>

<a href="https://www.root.cz/obrazek/362137/"><img src="https://i.iinfo.cz/images/683/microservices3-8-prev.png" class="image-362137" alt="&#160;" width="370" height="251" /></a>
<p><i>Obrázek 17: Další dělení hierarchického modelu.</i></p>



<p><a name="k17"></a></p>
<h2 id="k17">17. Obsah další části seriálu</h2>

<p>Již mnohokrát jsme se v&nbsp;tomto seriálu setkali s&nbsp;nástrojem
<i>Apache Kafka</i>. Jedná se o velmi často používaný (někdy i nadužívaný)
nástroj, o jehož základních možnostech se zmíníme příště.</p>

<img src="https://i.iinfo.cz/images/447/microservices2-3.png" class="image-361670" alt="&#160;" width="450" height="134" />
<p><i>Obrázek 18: Logo nástroje Apache Kafka.</i></p>



<p><a name="k18"></a></p>
<h2 id="k18">18. Odkazy na Internetu</h2>

<ol>

<li>Microservices - Not a free lunch!<br />
<a href="http://highscalability.com/blog/2014/4/8/microservices-not-a-free-lunch.html">http://highscalability.com/blog/2014/4/8/microservices-not-a-free-lunch.html</a>
</li>

<li>Microservices, Monoliths, and NoOps<br />
<a href="http://blog.arungupta.me/microservices-monoliths-noops/">http://blog.arungupta.me/microservices-monoliths-noops/</a>
</li>

<li>Microservice Design Patterns<br />
<a href="http://blog.arungupta.me/microservice-design-patterns/">http://blog.arungupta.me/microservice-design-patterns/</a>
</li>

<li>Vision of a microservice revolution<br />
<a href="https://www.jolie-lang.org/vision.html">https://www.jolie-lang.org/vision.html</a>
</li>

<li>Microservices: a definition of this new architectural term<br />
<a href="https://martinfowler.com/articles/microservices.html">https://martinfowler.com/articles/microservices.html</a>
</li>

<li>Mikroslužby<br />
<a href="http://voho.eu/wiki/mikrosluzba/">http://voho.eu/wiki/mikrosluzba/</a>
</li>

<li>Microservice Prerequisites<br />
<a href="https://martinfowler.com/bliki/MicroservicePrerequisites.html">https://martinfowler.com/bliki/MicroservicePrerequisites.html</a>
</li>

<li>Microservices in Practice, Part 1: Reality Check and Service Design (vyžaduje registraci)<br />
<a href="https://ieeexplore.ieee.org/document/7819415">https://ieeexplore.ieee.org/document/7819415</a>
</li>

<li>Microservice Trade-Offs<br />
<a href="https://www.martinfowler.com/articles/microservice-trade-offs.html">https://www.martinfowler.com/articles/microservice-trade-offs.html</a>
</li>

<li>What is a microservice? (from a linguistic point of view)<br />
<a href="http://claudioguidi.blogspot.com/2017/03/what-microservice-from-linguisitc.html">http://claudioguidi.blogspot.com/2017/03/what-microservice-from-linguisitc.html</a>
</li>

<li>Microservices (Wikipedia)<br />
<a href="https://en.wikipedia.org/wiki/Microservices">https://en.wikipedia.org/wiki/Microservices</a>
</li>

<li>Fallacies of distributed computing (Wikipedia)<br />
<a href="https://en.wikipedia.org/wiki/Fallacies_of_distributed_computing">https://en.wikipedia.org/wiki/Fallacies_of_distributed_computing</a>
</li>

<li>Service (systems architecture)<br />
<a href="https://en.wikipedia.org/wiki/Service_(systems_architecture)">https://en.wikipedia.org/wiki/Service_(systems_architecture)</a>
</li>

<li>Microservices in a Nutshell<br />
<a href="https://www.thoughtworks.com/insights/blog/microservices-nutshell">https://www.thoughtworks.com/insights/blog/microservices-nutshell</a>
</li>

<li>What is Microservices?<br />
<a href="https://smartbear.com/solutions/microservices/">https://smartbear.com/solutions/microservices/</a>
</li>

<li>Mastering Chaos - A Netflix Guide to Microservices<br />
<a href="https://www.youtube.com/watch?v=CZ3wIuvmHeM&t=17s">https://www.youtube.com/watch?v=CZ3wIuvmHeM&amp;t=17s</a>
</li>

<li>Messaging in Microservice Architecture<br />
<a href="https://www.youtube.com/watch?v=MkQWQ5f-SEY">https://www.youtube.com/watch?v=MkQWQ5f-SEY</a>
</li>

<li>Pattern: Messaging<br />
<a href="https://microservices.io/patterns/communication-style/messaging.html">https://microservices.io/patterns/communication-style/messaging.html</a>
</li>

<li>Microservices Messaging: Why REST Isn’t Always the Best Choice<br />
<a href="https://blog.codeship.com/microservices-messaging-rest-isnt-always-best-choice/">https://blog.codeship.com/microservices-messaging-rest-isnt-always-best-choice/</a>
</li>

<li>Protocol buffers<br />
<a href="https://developers.google.com/protocol-buffers/">https://developers.google.com/protocol-buffers/</a>
</li>

<li>BSON<br />
<a href="http://bsonspec.org/">http://bsonspec.org/</a>
</li>

<li>Apache Avro!<br />
<a href="https://avro.apache.org/">https://avro.apache.org/</a>
</li>

<li>REST vs Messaging for Microservices – Which One is Best?<br />
<a href="https://solace.com/blog/experience-awesomeness-event-driven-microservices/">https://solace.com/blog/experience-awesomeness-event-driven-microservices/</a>
</li>

<li>How did we end up here?<br />
<a href="https://gotocon.com/dl/goto-chicago-2015/slides/MartinThompson_and_ToddMontgomery_HowDidWeEndUpHere.pdf">https://gotocon.com/dl/goto-chicago-2015/slides/MartinThompson_and_ToddMontgomery_HowDidWeEndUpHere.pdf</a>
</li>

<li>Scaling microservices with message queues to handle data bursts<br />
<a href="https://read.acloud.guru/scaling-microservices-with-message-queue-2d389be5b139">https://read.acloud.guru/scaling-microservices-with-message-queue-2d389be5b139</a>
</li>

<li>Microservices: What are smart endpoints and dumb pipes?<br />
<a href="https://stackoverflow.com/questions/26616962/microservices-what-are-smart-endpoints-and-dumb-pipes">https://stackoverflow.com/questions/26616962/microservices-what-are-smart-endpoints-and-dumb-pipes</a>
</li>

<li>Common Object Request Broker Architecture<br />
<a href="https://en.wikipedia.org/wiki/Common_Object_Request_Broker_Architecture">https://en.wikipedia.org/wiki/Common_Object_Request_Broker_Architecture</a>
</li>

<li>Enterprise service bus<br />
<a href="https://en.wikipedia.org/wiki/Enterprise_service_bus">https://en.wikipedia.org/wiki/Enterprise_service_bus</a>
</li>

<li>Microservices vs SOA : What’s the Difference<br />
<a href="https://www.edureka.co/blog/microservices-vs-soa/">https://www.edureka.co/blog/microservices-vs-soa/</a>
</li>

<li>Pravda o SOA<br />
<a href="https://businessworld.cz/reseni-a-realizace/pravda-o-soa-2980">https://businessworld.cz/reseni-a-realizace/pravda-o-soa-2980</a>
</li>

<li>Is it a good idea for Microservices to share a common database?<br />
<a href="https://www.quora.com/Is-it-a-good-idea-for-Microservices-to-share-a-common-database">https://www.quora.com/Is-it-a-good-idea-for-Microservices-to-share-a-common-database</a>
</li>

<li>Pattern: Shared database<br />
<a href="https://microservices.io/patterns/data/shared-database.html">https://microservices.io/patterns/data/shared-database.html</a>
</li>

<li>Is a Shared Database in Microservices Actually an Anti-pattern?<br />
<a href="https://hackernoon.com/is-shared-database-in-microservices-actually-anti-pattern-8cc2536adfe4">https://hackernoon.com/is-shared-database-in-microservices-actually-anti-pattern-8cc2536adfe4</a>
</li>

<li>Shared database in microservices is a problem, yep<br />
<a href="https://ayende.com/blog/186914-A/shared-database-in-microservices-is-a-problem-yep">https://ayende.com/blog/186914-A/shared-database-in-microservices-is-a-problem-yep</a>
</li>

<li>Microservices with shared database? using multiple ORM's?<br />
<a href="https://stackoverflow.com/questions/43612866/microservices-with-shared-database-using-multiple-orms">https://stackoverflow.com/questions/43612866/microservices-with-shared-database-using-multiple-orms</a>
</li>

<li>Examples of microservice architecture<br />
<a href="https://www.coursera.org/lecture/intro-ibm-microservices/examples-of-microservice-architecture-JXOFj">https://www.coursera.org/lecture/intro-ibm-microservices/examples-of-microservice-architecture-JXOFj</a>
</li>

<li>Microservices: The Rise Of Kafka<br />
<a href="https://movio.co/blog/microservices-rise-kafka/">https://movio.co/blog/microservices-rise-kafka/</a>
</li>

<li>Building a Microservices Ecosystem with Kafka Streams and KSQL<br />
<a href="https://www.confluent.io/blog/building-a-microservices-ecosystem-with-kafka-streams-and-ksql/">https://www.confluent.io/blog/building-a-microservices-ecosystem-with-kafka-streams-and-ksql/</a>
</li>

<li>An introduction to Apache Kafka and microservices communication<br />
<a href="https://medium.com/@ulymarins/an-introduction-to-apache-kafka-and-microservices-communication-bf0a0966d63">https://medium.com/@ulymarins/an-introduction-to-apache-kafka-and-microservices-communication-bf0a0966d63</a>
</li>

<li>ACID (computer science)<br />
<a href="https://en.wikipedia.org/wiki/ACID_(computer_science)">https://en.wikipedia.org/wiki/ACID_(computer_science)</a>
</li>

<li>Distributed transaction<br />
<a href="https://en.wikipedia.org/wiki/Distributed_transaction">https://en.wikipedia.org/wiki/Distributed_transaction</a>
</li>

<li>Two-phase commit protocol<br />
<a href="https://en.wikipedia.org/wiki/Two-phase_commit_protocol">https://en.wikipedia.org/wiki/Two-phase_commit_protocol</a>
</li>

<li>Why is 2-phase commit not suitable for a microservices architecture?<br />
<a href="https://stackoverflow.com/questions/55249656/why-is-2-phase-commit-not-suitable-for-a-microservices-architecture">https://stackoverflow.com/questions/55249656/why-is-2-phase-commit-not-suitable-for-a-microservices-architecture</a>
</li>

<li>4 reasons why microservices resonate<br />
<a href="https://www.oreilly.com/ideas/4-reasons-why-microservices-resonate">https://www.oreilly.com/ideas/4-reasons-why-microservices-resonate</a>
</li>

<li>Pattern: Microservice Architecture<br />
<a href="https://microservices.io/patterns/microservices.html">https://microservices.io/patterns/microservices.html</a>
</li>

<li>Pattern: Monolithic Architecture<br />
<a href="https://microservices.io/patterns/monolithic.html">https://microservices.io/patterns/monolithic.html</a>
</li>

<li>Pattern: Saga<br />
<a href="https://microservices.io/patterns/data/saga.html">https://microservices.io/patterns/data/saga.html</a>
</li>

<li>Pattern: Database per service<br />
<a href="https://microservices.io/patterns/data/database-per-service.html">https://microservices.io/patterns/data/database-per-service.html</a>
</li>

<li>Pattern: Access token<br />
<a href="https://microservices.io/patterns/security/access-token.html">https://microservices.io/patterns/security/access-token.html</a>
</li>

<li>Databázová integrita<br />
<a href="https://cs.wikipedia.org/wiki/Datab%C3%A1zov%C3%A1_integrita">https://cs.wikipedia.org/wiki/Datab%C3%A1zov%C3%A1_integrita</a>
</li>

<li>Referenční integrita<br />
<a href="https://cs.wikipedia.org/wiki/Referen%C4%8Dn%C3%AD_integrita">https://cs.wikipedia.org/wiki/Referen%C4%8Dn%C3%AD_integrita</a>
</li>

<li>Introduction into Microservices <br />
<a href="https://specify.io/concepts/microservices">https://specify.io/concepts/microservices</a>
</li>

<li>Are Microservices ‘SOA Done Right’?<br />
<a href="https://intellyx.com/2015/07/20/are-microservices-soa-done-right/">https://intellyx.com/2015/07/20/are-microservices-soa-done-right/</a>
</li>

<li>The Hardest Part About Microservices: Your Data<br />
<a href="https://blog.christianposta.com/microservices/the-hardest-part-about-microservices-data/">https://blog.christianposta.com/microservices/the-hardest-part-about-microservices-data/</a>
</li>

<li>From a monolith to microservices + REST<br />
<a href="https://www.slideshare.net/InfoQ/from-a-monolith-to-microservices-rest-the-evolution-of-linkedins-service-architecture">https://www.slideshare.net/InfoQ/from-a-monolith-to-microservices-rest-the-evolution-of-linkedins-service-architecture</a>
</li>

<li>DevOps and the Myth of Efficiency, Part I<br />
<a href="https://blog.christianposta.com/devops/devops-and-the-myth-of-efficiency-part-i/">https://blog.christianposta.com/devops/devops-and-the-myth-of-efficiency-part-i/</a>
</li>

<li>DevOps and the Myth of Efficiency, Part II<br />
<a href="https://blog.christianposta.com/devops/devops-and-the-myth-of-efficiency-part-ii/">https://blog.christianposta.com/devops/devops-and-the-myth-of-efficiency-part-ii/</a>
</li>

<li>Standing on Distributed Shoulders of Giants: Farsighted Physicists of Yore Were Danged Smart!<br />
<a href="https://queue.acm.org/detail.cfm?id=2953944">https://queue.acm.org/detail.cfm?id=2953944</a>
</li>

<li>Building DistributedLog: High-performance replicated log service<br />
<a href="https://blog.twitter.com/engineering/en_us/topics/infrastructure/2015/building-distributedlog-twitter-s-high-performance-replicated-log-servic.html">https://blog.twitter.com/engineering/en_us/topics/infrastructure/2015/building-distributedlog-twitter-s-high-performance-replicated-log-servic.html</a>
</li>

<li>Turning the database inside-out with Apache Samza<br />
<a href="https://www.confluent.io/blog/turning-the-database-inside-out-with-apache-samza/">https://www.confluent.io/blog/turning-the-database-inside-out-with-apache-samza/</a>
</li>

<li>Debezium: Stream changes from your databases.<br />
<a href="https://debezium.io/">https://debezium.io/</a>
</li>

<li>Change data capture<br />
<a href="https://en.wikipedia.org/wiki/Change_data_capture">https://en.wikipedia.org/wiki/Change_data_capture</a>
</li>

<li>Apache Samza (Wikipedia)<br />
<a href="https://en.wikipedia.org/wiki/Apache_Samza">https://en.wikipedia.org/wiki/Apache_Samza</a>
</li>

<li>Storm (event processor)<br />
<a href="https://en.wikipedia.org/wiki/Storm_(event_processor)">https://en.wikipedia.org/wiki/Storm_(event_processor)</a>
</li>

<li>kappa-architecture.com<br />
<a href="http://milinda.pathirage.org/kappa-architecture.com/">http://milinda.pathirage.org/kappa-architecture.com/</a>
</li>

<li>Questioning the Lambda Architecture<br />
<a href="https://www.oreilly.com/ideas/questioning-the-lambda-architecture">https://www.oreilly.com/ideas/questioning-the-lambda-architecture</a>
</li>

<li>Lambda architecture<br />
<a href="https://en.wikipedia.org/wiki/Lambda_architecture">https://en.wikipedia.org/wiki/Lambda_architecture</a>
</li>

<li>Event stream processing<br />
<a href="https://en.wikipedia.org/wiki/Event_stream_processing">https://en.wikipedia.org/wiki/Event_stream_processing</a>
</li>

<li>How to beat the CAP theorem<br />
<a href="http://nathanmarz.com/blog/how-to-beat-the-cap-theorem.html">http://nathanmarz.com/blog/how-to-beat-the-cap-theorem.html</a>
</li>

<li>Kappa Architecture Our Experience<br />
<a href="https://events.static.linuxfound.org/sites/events/files/slides/ASPgems%20-%20Kappa%20Architecture.pdf">https://events.static.linuxfound.org/sites/events/files/slides/ASPgems%20-%20Kappa%20Architecture.pdf</a>
</li>

<li>Messaging Patterns in Event Driven Microservice Architectures<br />
<a href="https://www.youtube.com/watch?v=3xDc4MEYuHI">https://www.youtube.com/watch?v=3xDc4MEYuHI</a>
</li>

<li>Why monolithic apps are often better than microservices<br />
<a href="https://gigaom.com/2015/11/06/why-monolithic-apps-are-often-better-than-microservices/">https://gigaom.com/2015/11/06/why-monolithic-apps-are-often-better-than-microservices/</a>
</li>

<li>How Enterprise PaaS Can Add Critical Value to Microservices<br />
<a href="https://apprenda.com/blog/enterprise-paas-microservices/">https://apprenda.com/blog/enterprise-paas-microservices/</a>
</li>

<li>Common React Mistakes: Monolithic Components and a Lack of Abstraction<br />
<a href="https://www.pmg.com/blog/common-react-mistakes-monolithic-components-lack-abstraction/">https://www.pmg.com/blog/common-react-mistakes-monolithic-components-lack-abstraction/</a>
</li>

<li>From monolith to microservices – to migrate or not to migrate?<br />
<a href="https://altkomsoftware.pl/en/blog/monolith-microservices/">https://altkomsoftware.pl/en/blog/monolith-microservices/</a>
</li>

<li>Command–query separation<br />
<a href="https://en.wikipedia.org/wiki/Command%E2%80%93query_separation">https://en.wikipedia.org/wiki/Command%E2%80%93query_separation</a>
</li>

<li>GOTO 2016: Messaging and Microservices (Clemens Vasters)<br />
<a href="https://www.youtube.com/watch?v=rXi5CLjIQ9kx">https://www.youtube.com/watch?v=rXi5CLjIQ9kx</a>
</li>

<li>GOTO Amsterdam 2019<br />
<a href="https://gotoams.nl/">https://gotoams.nl/</a>
</li>

<li>Lesson 2 - Kafka vs. Standard Messaging<br />
<a href="https://www.youtube.com/watch?v=lwMjjTT1Q-Q">https://www.youtube.com/watch?v=lwMjjTT1Q-Q</a>
</li>

<li>CommandQuerySeparation (Martin Fowler)<br />
<a href="https://martinfowler.com/bliki/CommandQuerySeparation.html">https://martinfowler.com/bliki/CommandQuerySeparation.html</a>
</li>

<li>Command–query separation<br />
<a href="https://en.wikipedia.org/wiki/Command%E2%80%93query_separation">https://en.wikipedia.org/wiki/Command%E2%80%93query_separation</a>
</li>

<li>CQRS - Martin Fowler<br />
<a href="https://martinfowler.com/bliki/CQRS.html">https://martinfowler.com/bliki/CQRS.html</a>
</li>

<li>Lesson 12 - CQRS and Microservices<br />
<a href="https://www.youtube.com/watch?v=pUGvXUBfvEE">https://www.youtube.com/watch?v=pUGvXUBfvEE</a>
</li>

</ol>



<p></p><p></p>
<p><small>Autor: <a href="http://www.fit.vutbr.cz/~tisnovpa">Pavel Tišnovský</a> &nbsp; 2019</small></p>
</body>
</html>

