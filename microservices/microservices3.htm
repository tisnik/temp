<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
        "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html>
<head>
<title>Posílání zpráv v aplikacích založených na mikroslužbách</title>
<meta name="Author" content="Pavel Tisnovsky" />
<meta name="Generator" content="vim" />
<meta http-equiv="content-type" content="text/html; charset=utf-8" />
<style type="text/css">
         body {color:#000000; background:#ffffff;}
         h1  {font-family: arial, helvetica, sans-serif; color:#ffffff; background-color:#c00000; text-align:center; padding-left:1em}
         h2  {font-family: arial, helvetica, sans-serif; color:#ffffff; background-color:#0000c0; padding-left:1em; text-align:left}
         h3  {font-family: arial, helvetica, sans-serif; color:#000000; background-color:#c0c0c0; padding-left:1em; text-align:left}
         h4  {font-family: arial, helvetica, sans-serif; color:#000000; background-color:#e0e0e0; padding-left:1em; text-align:left}
         a   {font-family: arial, helvetica, sans-serif;}
         li  {font-family: arial, helvetica, sans-serif; color:#000000; text-align:justify; width:450px;}
         ol  {font-family: arial, helvetica, sans-serif; color:#000000; text-align:justify; width:450px;}
         ul  {font-family: arial, helvetica, sans-serif; color:#000000; text-align:justify; width:450px;}
         p   {font-family: arial, helvetica, sans-serif; color:#000000; text-align:justify;}
         pre {background:#e0e0e0}
</style>
</head>

<body>

<h1>Posílání zpráv v aplikacích založených na mikroslužbách</h1>

<h3>Pavel Tišnovský</h3>

<p></p>

<h1>Úvodník</h1>

<p>Ve třetím článku o návrhu a tvorbě aplikací založených na mikroslužbách se budeme zabývat některými způsoby, jakými mezi sebou mikroslužby komunikují. Návrh správné komunikace je po rozdělení databáze (viz předchozí část) další kritickou částí celé architektury mikroslužeb.</p>



<h2>Obsah</h2>

<p><a href="#k01">*** 1. Posílání zpráv v&nbsp;aplikacích založených na mikroslužbách</a></p>
<p><a href="#k02">*** 2. Dvě klíčové součásti návrhu mikroslužeb: databáze a komunikace</a></p>
<p><a href="#k03">*** 3. Zajištění nezávislosti mikroslužeb aneb koncept tlačítka STOP</a></p>
<p><a href="#k04">*** 4. Význam pojmů CQS a CQRS</a></p>
<p><a href="#k05">*** 5. Tři důvody, proč poslat zprávu</a></p>
<p><a href="#k06">*** 6. Zpráva požadující provedení úlohy &ndash; <strong>COMMAND</strong></a></p>
<p><a href="#k07">*** 7. Směrování používané při posílání příkazů (<strong>COMMAND</strong>)</a></p>
<p><a href="#k08">*** 8. Zpráva poslaná ve chvíli, kdy došlo k&nbsp;nějaké události &ndash; <strong>EVENT</strong></a></p>
<p><a href="#k09">*** 9. Směrování používané při vzniku události (<strong>EVENT</strong>)</a></p>
<p><a href="#k10">*** 10. Zpráva pro získání nějaké informace &ndash; <strong>QUERY</strong></a></p>
<p><a href="#k11">*** 11. Směrování používané při dotazech (<strong>QUERY</strong>)</a></p>
<p><a href="#k12">*** 12. Vzájemná komunikace mezi komponentami</a></p>
<p><a href="#k13">*** 13. Škálování aplikace ve chvíli, kdy je vytvořen &bdquo;distribuovaný monolit&ldquo;</a></p>
<p><a href="#k14">*** 14. Jediný centralizovaný message broker</a></p>
<p><a href="#k15">*** 15. Hierarchický model</a></p>
<p><a href="#k16">*** 16. </a></p>
<p><a href="#k17">*** 17. </a></p>
<p><a href="#k18">*** 18. </a></p>
<p><a href="#k19">*** 19. </a></p>
<p><a href="#k20">*** 20. Odkazy na Internetu</a></p>



<p><a name="k01"></a></p>
<h2 id="k01">1. Posílání zpráv v&nbsp;aplikacích založených na mikroslužbách</h2>

<p><i>&bdquo;It's hard to get messaging right&ldquo;</i></p>

<p><a href="">V&nbsp;předchozí části</a> <a href="">seriálu o mikroslužbách</a> jsme se věnovali velmi důležitému tématu &ndash; návrhem databáze resp.&nbsp;přesněji řečeno namodelováním reprezentace <i>stavu</i> celé aplikace, pochopitelně včetně způsobů změny tohoto stavu. Připomeňme si, že bylo důležité rozdělit databázi takovým způsobem, aby každá komponenta měla k&nbsp;dispozici právě tu část databáze, kterou pro svoji činnost nutně potřebuje. Právě rozdělení databáze pro jednotlivé komponenty je kritickou částí návrhu, která odlišuje &bdquo;distribuovaný monolit&ldquo; od skutečné aplikace založené na mikroslužbách. Kromě klasického rozdělení databáze na jednotlivé části jsme si minule popsali i takzvanou <i>architekturu kappa</i>, v&nbsp;níž je ústředním prvkem systém <a href="">NATS Streaming</a> či <a href="">Apacha Kafka</a>, který obsahuje neměnitelné záznamy (<i>log</i>) se všemi změnami stavu celé aplikace. Jednotlivé komponenty tyto změny postupně aplikují na svoje lokální databáze a přibližují se tak postupně <i>okamžitému a pravdivému stavu</i>, který je uložen formou neměnitelných záznamů se změnami.</p>
<p></p>

<p><div class="rs-tip-major">Poznámka: již v&nbsp;předchozím odstavci jsme použili označení <i>komponenta</i> (<i>component</i>). Může se jednat jak o nějakou mikroslužbu, tak i o pomocný nástroj typu <i>message broker</i>, <i>message bus</i> atd. Termín &bdquo;komponenta&ldquo; bude použit v&nbsp;dalším textu, už jen z&nbsp;toho důvodu, že je poněkud obecnější než &bdquo;mikroslužba&ldquo;.</div></p>

<p>Výsledkem návrhu by měla být architektura, ve které si každá služba autonomně řídí svůj stav a případnou změnu svého stavu (ideální je pochopitelně mít co nejvíce komponent bezstavových &ndash; <i>stateless</i>). Požadavky na autonomnost služeb jsou ve skutečnosti ještě větší. Kromě toho, že služba má svoji databázi, neměla by (kromě svého API) sdílet svůj stav a už vůbec ne svůj interní (vnitřní) stav. Což ale nejsou příliš překvapující požadavky, protože podobné požadavky existují i v&nbsp;objektově orientovaném programování a nazýváme je <i>zapouzdření</i> (<i>encapculation</i>). Dále je nutné, aby služby pro komunikaci používaly vždy své API a nikoli nějaké postranní kanály.</p>

<p><div class="rs-tip-major">Poznámka: na tomto místě je dobré upozornit na to, že prozatím neexistuje jediná &bdquo;správná&ldquo; cesta, jaká architektura je nejlepší, ale mnozí před námi už zjistili, které cesty jsou slepé.</div></p>



<p><a name="k02"></a></p>
<h2 id="k02">2. Dvě klíčové součásti návrhu mikroslužeb: databáze a komunikace</h2>

<p><i>&bdquo;Monolith components are large components that contain a lot of
functionality&ldquo;</i></p>

<p>Návrh databáze je skutečně primární částí naplánování modelu celé architektury aplikace (a měl by být proveden už na začátku), ovšem pochopitelně se nejedná o jedinou součást návrhu, kterou je nutné vyřešit. Dalším důležitým architektonickým rozhodnutím je určení, jakým způsobem vlastně budou mezi sebou budou jednotlivé komponenty komunikovat. A podobně jako bylo možné (mnohdy nutné) pro každou komponentu zvolit odlišnou databázi (SQL či nějakou NoSQL, ať již dokumentovou, objektovou nebo grafovou atd.), i způsoby vzájemné komunikace služeb &ndash; posílání zpráv &ndash; je nutné navrhnout podle toho, o jakou komunikaci se jedná. V&nbsp;praxi to znamená, že se většinou použije větší množství protokolů a většinou i několik instancí <i>message brokerů</i>. A v&nbsp;neposlední řadě je nutné určit, zda spolu budou jednotlivé komponenty komunikovat přímo či zda se vytvoří centrální popř.&nbsp;hierarchicky umístěné uzly, k&nbsp;nimž se jednotlivé komponenty budou připojovat.</p>

<p><div class="rs-tip-major">Poznámka: někdy se, například v&nbsp;diskuzích, můžeme setkat s&nbsp;tvrzením &bdquo;používáme mikroslužby, protože všechna komunikace je čistě přes REST API a zprávy používají formát JSON&ldquo;. Ve skutečnosti spolu všechny zmíněné technologie souvisí jen částečně a obecně je možné říct, že s&nbsp;čistým REST API se při dobře navrženém messagingu nevystačí a většinou je nutné použít i další technologie, například AMQP, MQTT atd.</div></p>



<p><a name="k03"></a></p>
<h2 id="k03">3. Zajištění nezávislosti mikroslužeb aneb koncept tlačítka STOP</h2>

<p><i>&bdquo;As a fan of microservices, I fear enterprises are blindly charging
forward and could be left disappointed with a microservices-based strategy if
the technology is not appropriately applied.&ldquo;<br />
Sinclair Schuller</i></p>

<p>Jak se vlastně pozná dobrý návrh architektury aplikace založené na mikroslužbách? Samozřejmě je k&nbsp;dispozici velké množství kritérií, například propustnost, maximální počet současně obsluhovaných klientů, škálovatelnost, systémové nároky atd. atd. Existuje ovšem ještě jedno zajímavé kritérium, které osobně označuji termínem &bdquo;tlačítko STOP&ldquo;. Celá aplikace by totiž měla být &ndash; pochopitelně v&nbsp;ideálním světě &ndash; schopna do jisté míry fungovat i tehdy, pokud nějakou z&nbsp;komponent (mikroslužeb atd.) vypneme. A i když aplikace přestane nabízet některé služby, měla by být schopna se automaticky vrátit k&nbsp;běžné činnosti ihned poté, co se zastavená komponenta opět restartuje. Právě toto chování totiž vyžadujeme &ndash; schopnost aplikace se &bdquo;vzpamatovat&ldquo; i po částečném výpadku, a to bez toho, aby se musela celá aplikace vypnout s&nbsp;postupným zapínáním služeb podle nějakého návodu (toto chování ponechme monolitním aplikacím).</p>

<p><div class="rs-tip-major">Poznámka: příkladem s&nbsp;velkou pravděpodobností dobře navržené architektury může být GitHub. Pokud intenzivně používáte jeho API i GUI, mohli jste si v&nbsp;tomto roce povšimnout několika krátkodobých výpadků, které ovšem většinou postihly pouze určitou část této služby (například se na autorských stránkách nevypsaly správné informace o činnostech provedených v&nbsp;posledním dni &ndash; počet commitů, počet uzavřených issues atd.); typicky však vlastní Git fungoval. Díky oddělení jednotlivých částí služby se restart jednotlivých komponent obešel bez nutnosti restartu celé služby, což by pravděpodobně bylo komplikovanější a časově náročnější. Navíc byly některé výpadky pro koncové uživatele prakticky neviditelné a projevily se například jen zpožděným doručením notifikace, zpožděním při poslání web hooku do CI atd. atd.</div></p>



<p><a name="k04"></a></p>
<h2 id="k04">4. Význam pojmů CQS a CQRS</h2>

<p><i>&bdquo;“…organizations which design systems … are constrained to produce
designs which are copies of the communication structures of these
organizations.”&ldquo;</i></p>

<p>V&nbsp;souvislosti se zprávami se často setkáme s&nbsp;termíny <strong>CQS</strong> a <strong>CQRS</strong>.</p>



<p><a name="k05"></a></p>
<h2 id="k05">5. Tři důvody, proč poslat zprávu</h2>

<p><i>&bdquo;“Design the organisation you want, the architecture will follow
(kicking and screaming).”&ldquo;</i></p>

<p>Při návrhu komunikace mezi jednotlivými komponentami je dobré si uvědomit, proč spolu vlastně komponenty potřebují komunikovat. V&nbsp;naprosté většině případů se jedná o jednu ze tří možností vypsaných pod tímto odstavcem:</p>

<ol>

<li>Jedna komponenta vyžaduje, aby některá z&nbsp;dalších komponent provedla určitou činnost či určitý příkaz. Tento typ zprávy budeme označovat slovem <strong>COMMAND</strong> a většinou znamená, že se změní stav aplikace (například záznam informace o novém uživateli).</li>

<li>Komponenta oznamuje dalším komponentám, že došlo k&nbsp;nějaké události. Z&nbsp;tohoto důvodu budeme tento typ zprávy označovat slovem <strong>EVENT</strong>. Samotné oznámení o vzniku události nemusí nutně znamenat změnu stavu aplikace, ovšem na tuto zprávu mohou příjemci reagovat posláním jiné zprávy typu <strong>COMMAND</strong>.</li>

<li>A konečně komponenta potřebuje získat nějaký údaj či údaje. Tento typ zprávy pojmenujeme <strong>QUERY</strong> a typicky by se jejím posláním neměl měnit stav aplikace. Z&nbsp;tohoto hlediska se většinou jedná o nejjednodušeji implementovatelné zprávy, ovšem jak uvidíme dále, i zde může dojít ke komplikacím v&nbsp;případě, že se o výsledku může <i>hlasovat</i>.</li>

</ol>

<p>Tyto tři typy zpráv se odráží i v&nbsp;pojmenování některých technologií. Můžeme se například setkat se systémy, v&nbsp;nichž se používají tři typy &bdquo;sběrnic zpráv&ldquo; pojmenované <strong>CommandBus</strong>, <strong>EventBus</strong> a <strong>QueryBus</strong>.</p>



<p><a name="k06"></a></p>
<h2 id="k06">6. Zpráva požadující provedení úlohy: <strong>COMMAND</strong></h2>

<p><i>&bdquo;Microservice &ndash; “small autonomous services modelled around
business domain that work together“&ldquo;<br />
Sam Newman, jeden z&nbsp;původních autorů myšlenky mikroslužeb</i></p>

<p>Podívejme se nejdříve na první typ zpráv, tj.&nbsp;na zprávy typu <strong>COMMAND</strong>. Tyto zprávy obecně slouží ke změně stavu aplikace a provádí tedy <i>side-effect</i>, typicky modifikaci dat (kromě odpovědi se změní i nějaká další část aplikace, například se zapíše záznam do databáze atd.). Můžeme se ale setkat i s&nbsp;takovými zprávami typu <strong>COMMAND</strong>, které stav aplikace nezmění. Poměrně dobrým příkladem může být žádost o poslání e-mailu uživateli &ndash; zde se tedy mění spíše stav okolního systému (mailboxu).</p>

<p>Zprávy typu <strong>COMMAND</strong> jsou typické tím, že většinou existuje pouze jediná komponenta, která může daný příkaz provést. To, o kterou komponentu ve funkci příjemce zprávy se konkrétně jedná, však nemusí zdrojová komponenta řešit, resp.&nbsp;přesněji řečeno by to neměla řešit, protože by se jednalo o zbytečně těsné svázání obou komponent (mikroslužeb).</p>

<p>Většinou taktéž požadujeme, aby přijímající komponenta poslala odpověď na zprávu typu <strong>COMMAND</strong>. Většinou se jedná o jednoduchou stavovou informaci typu <strong>OK</strong>/<strong>Not OK</strong> popř.&nbsp;<strong>ACK</strong>/<strong>NACK</strong>, jen výjimečně s&nbsp;dalšími daty (například s&nbsp;ID vytvořeného požadavku). Tento typ odpovědi může být poslán synchronně či asynchronně &ndash; viz též navazující kapitolu.</p>



<p><a name="k07"></a></p>
<h2 id="k07">7. Směrování používané při posílání příkazů (<strong>COMMAND</strong>)</h2>

<p><i>&bdquo;'Service' does not imply...Docker, Stateless, Kubernetes, JSON,
ESB, Cloud, NoSQL, ...&ldquo;<br />
Clemens Vasters</i></p>

<p>Existuje několik způsobů směrování (<i>routing</i>) použité pro zprávy typu <strong>COMMAND</strong>. Typicky je možné rozhodnout přímo na základě příslušného příkazu, která komponenta má příkaz zpracovat (<strong>create_new_user</strong>, <strong>send_notification_email</strong> atd.). V&nbsp;tom nejjednodušším případě se příkaz ihned přepošle cílové komponentě, ovšem většinou se setkáme s&nbsp;využitím <i>front zpráv</i> (<i>message queue</i>), které slouží jak pro zajištění persistence zpráv v&nbsp;případě, že přijímající komponenta není spuštěna či pokud je přetížena, tak i případně pro <i>load balancin</i>. Použitou komunikační strategií je tedy strategie <strong>PUSH-PULL</strong>.</p>

<p>Samotné téma load balancingu pro zprávy typu <strong>COMMAND</strong> je dosti rozsáhlé, protože tyto zprávy mění stav aplikace. Nicméně cílová komponenta může být spuštěna několikrát a existuje hned několik strategií, jak zprávy/příkazy z&nbsp;fronty přeposílat. Nejjednodušší a pravděpodobně i nejpoužívanější řešení je založeno na tom, že se ta instance komponenty, která má volné prostředky (strojový čas) sama přihlásí o přiřazení příkazu (úkolu). Používají se však i další způsoby; jeden z&nbsp;nich je založen na SLA. V&nbsp;praxi to znamená, že příkazy související s&nbsp;&bdquo;VIP uživateli&ldquo; jsou zpracovány na dedikovaných instancích popř.&nbsp;mají vyšší prioritu (a většina message brokerů dokáže nějakým způsobem pracovat s&nbsp;prioritou zpráv, popř.&nbsp;lze využít specializované prioritní fronty).</p>



<p><a name="k08"></a></p>
<h2 id="k08">8. Zpráva poslaná ve chvíli, kdy došlo k&nbsp;nějaké události &ndash; <strong>EVENT</strong></h2>

<p>Druhý typ zpráv nazvaný <strong>EVENT</strong> je některými komponentami posílán ve chvíli, kdy dojde k&nbsp;určité události. Může se jednat o prakticky libovolnou událost (tedy nikoli pouze o událost na GUI); příkladem může být detekce změny některých dat, zjištění, že došlo k&nbsp;překročení nějakého časového limitu, informace o přetížení určitého uzlu v&nbsp;clusteru, informace o překročení nastaveného limitu databáze, opakované pokusy o přihlášení atd. Můžeme sem řadit i komponenty/mikroslužby typu <strong>cron</strong>, které slouží právě k&nbsp;informacím o naplánovaných událostech, ať již periodických (poslání e-mailu se žádostí o změnu hesla, pravidelná kontrola jiné služby přes její API), tak i neperiodických (ad-hoc události).</p>



<p><a name="k09"></a></p>
<h2 id="k09">9. Směrování používané při vzniku události (<strong>EVENT</strong>)</h2>

<p>Zprávy typu <strong>EVENT</strong> se většinou směrují odlišným způsobem, než zprávy typu <strong>COMMAND</strong>. Je tomu tak z&nbsp;toho důvodu, že na události může reagovat větší množství komponent, nikoli jediný typ komponenty. Z&nbsp;tohoto důvodu se používá komunikační strategie <strong>PUBLISH-SUBSCRIBE</strong> neboli <strong>PUB-SUB</strong>, která je podporována většinou message brokerů. Ovšem můžeme se setkat i s&nbsp;dalšími konfiguracemi, například s&nbsp;takzvanými soupeřícími konzumenty (<i>competing consumers</i>) nebo s&nbsp;<i>balanced consumers</i>.</p>

<p><div class="rs-tip-major">Poznámka:</div></p>



<p><a name="k10"></a></p>
<h2 id="k10">10. Zpráva pro získání nějaké informace &ndash; <strong>QUERY</strong></h2>

většinou (ideálně) side-effect free
<p></p>



<p><a name="k11"></a></p>
<h2 id="k11">11. Směrování používané při dotazech (<strong>QUERY</strong>)</h2>

velka vazba = point to point
(REST API), dobre pro single-true answers

single destination
scatter-gather query
 = muze se vratit vice odpovedi od ruznych komponent
   s ruznou presnosti
   (obecna cena, cena pro specialniho zakaznika, cena na zaklade nejake akce - black friday, zemi puvodu atd.)
   je na tazateli, aby si vybral :-)

priklad black friday - jen se prida nova komponenta na chvili,
ta zmeni chovani aplikace, ovsem bez toho, abysme museli nekam hrabat

<p></p>



<p><a name="k12"></a></p>
<h2 id="k12">12. Vzájemná komunikace mezi komponentami</h2>

<p>Dalším problémem, který je nutné při návrhu architektury aplikace uspokojivě vyřešit, je konfigurace vzájemného popojení jednotlivých komponent. Zde máme k&nbsp;dispozici hned několik možností, z&nbsp;nichž o některých již víme, že nejsou ideální (resp.&nbsp;mnohem přesněji to ví ti vývojáři, které tyto způsoby použili a narazili na jejich meze).</p>

<p></p>
point to point
magický centralizovaný message broker
hierarchická struktura






<p><a name="k13"></a></p>
<h2 id="k13">13. Škálování aplikace ve chvíli, kdy je vytvořen &bdquo;distribuovaný monolit&ldquo;</h2>

<p>Jeden z&nbsp;obecně nejhorších způsobů spočívá v&nbsp;tom, že každá komponenta může přímo komunikovat s&nbsp;jinou komponentou na základě svého vlastního rozhodnutí, přesněji řečeno na základě rozhodnutí programátora, který danou komponentu navrhnul. Pravděpodobně vás již napadlo, že v&nbsp;tomto případě může dojít k&nbsp;mnoha nepříjemnostem. V&nbsp;první řadě bude celá struktura aplikace dosti chaotická, a to již ve chvíli, kdy bude aplikace obsahovat jednotky až desítky služeb. Dále se tato architektura pravděpodobně zcela automaticky nevzpamatuje při výpadku některého z&nbsp;uzlů (a pokud se vzpamatuje, znamená to, že se jedná o časově náročnou práci vývojářů jednotlivých komponent). Problematické až zcela nemožné je škálování jednotlivých komponent, konfigurace load balancingu na základě požadavků SLA, mechanismus, kterým se jednotlivé služby vyhledávají atd. atd.</p>

<p>Zajímavé a možná i typické a pochopitelné je, že se tato architektura typicky používá ve chvíli, kdy se nějaký tým rozhodne rozdělit původně monolitickou aplikaci na &bdquo;mikroslužby&ldquo;. Ovšem jedná se o ten druhý nejhorší možný způsob, který pouze vede k&nbsp;vytvoření &bdquo;distribuovaného monolitu&ldquo; (prvním nejhorším způsobem je postavit komponenty nad jedinou databází).</p>
jediny message broker?

magická komponenta, ovšem kdo se o ni stará, kdo je vlastník, kdo řeší problémy

simplification through centralization
jenže skutečně škáluje?
pro jednotky a desítky komponent pravděpodobně bude fungovat bez problémů

<p></p>
vsechny komponenty musi "znat jazyk" ostatnich komponent




<p><a name="k14"></a></p>
<h2 id="k14">14. Jediný centralizovaný message broker</h2>

<p>Zatímco první způsob popsaný v&nbsp;předchozím textu představoval jeden extrém, můžeme se setkat i s&nbsp;opačným extrémem. Ten bývá založen (v&nbsp;tom lepším případě) na centrálním uzlu s&nbsp;message brokerem, přes který jednotlivé služby komunikují. Přitom je zaručeno, že žádné jiné komunikační cesty nebudou použity. Ve skutečnosti se nejedná o špatný návrh, ovšem musíme počítat s&nbsp;tím, že se při jeho důsledném dodržování zhorší škálovatelnost a i další růst aplikace o další komponenty/mikroslužby bude omezen výkonem a škálovatelností message brokera (musíme počítat i s&nbsp;případným omezením daným síťovou vrstvou a fyzickým oddělením jednotlivých komponent na různé stroje). Pro menší aplikace se však může jednat o dobrý přístup.</p>

DDD - Domain Driven Design

v rámci jednoho kontextu - centralni message broker

unifikovany broker uprostred

<p></p>



<p><a name="k15"></a></p>
<h2 id="k15">15. Hierarchický model</h2>

<p>V&nbsp;případě ještě větších aplikací s&nbsp;mnoha desítkami či dokonce se stovkami komponent je však nutné způsob komunikace navrhnout ještě pečlivěji. Setkáme se například se sdružováním jednotlivých komponent do větších hierarchicky organizovaných celků (řekněme <i>clusteru</i> v&nbsp;původním významu tohoto slov) , přičemž každý z&nbsp;těchto clusterů sdružuje služby, které k&nbsp;sobě logicky patří. V&nbsp;každém clusteru se typicky nachází centrální message broker a všechny služby v&nbsp;clusteru komunikují pouze s&nbsp;tímto uzlem. Jednotlivé clustery jsou spojeny dalším (tentokrát již centrálním) message brokerem, takže výsledkem může být poměrně snadno uchopitelná a elegantní rekurzivní struktura. Výkonnost tohoto řešení je založená na předpokladu, že logicky související služby spolu komunikují častěji, takže centrální message broker není přetěžován.</p>
<p></p>



<p><a name="k16"></a></p>
<h2 id="k16">16. </h2>

<p></p>



<p><a name="k17"></a></p>
<h2 id="k17">17. </h2>

<p></p>



<p><a name="k18"></a></p>
<h2 id="k18">18. </h2>

<p></p>



<p><a name="k19"></a></p>
<h2 id="k19">19. </h2>

<p></p>



<p><a name="k20"></a></p>
<h2 id="k20">20. Odkazy na Internetu</h2>

<ol>

<li>Microservices - Not a free lunch!<br />
<a href="http://highscalability.com/blog/2014/4/8/microservices-not-a-free-lunch.html">http://highscalability.com/blog/2014/4/8/microservices-not-a-free-lunch.html</a>
</li>

<li>Microservices, Monoliths, and NoOps<br />
<a href="http://blog.arungupta.me/microservices-monoliths-noops/">http://blog.arungupta.me/microservices-monoliths-noops/</a>
</li>

<li>Microservice Design Patterns<br />
<a href="http://blog.arungupta.me/microservice-design-patterns/">http://blog.arungupta.me/microservice-design-patterns/</a>
</li>

<li>Vision of a microservice revolution<br />
<a href="https://www.jolie-lang.org/vision.html">https://www.jolie-lang.org/vision.html</a>
</li>

<li>Microservices: a definition of this new architectural term<br />
<a href="https://martinfowler.com/articles/microservices.html">https://martinfowler.com/articles/microservices.html</a>
</li>

<li>Mikroslužby<br />
<a href="http://voho.eu/wiki/mikrosluzba/">http://voho.eu/wiki/mikrosluzba/</a>
</li>

<li>Microservice Prerequisites<br />
<a href="https://martinfowler.com/bliki/MicroservicePrerequisites.html">https://martinfowler.com/bliki/MicroservicePrerequisites.html</a>
</li>

<li>Microservices in Practice, Part 1: Reality Check and Service Design (vyžaduje registraci)<br />
<a href="https://ieeexplore.ieee.org/document/7819415">https://ieeexplore.ieee.org/document/7819415</a>
</li>

<li>Microservice Trade-Offs<br />
<a href="https://www.martinfowler.com/articles/microservice-trade-offs.html">https://www.martinfowler.com/articles/microservice-trade-offs.html</a>
</li>

<li>What is a microservice? (from a linguistic point of view)<br />
<a href="http://claudioguidi.blogspot.com/2017/03/what-microservice-from-linguisitc.html">http://claudioguidi.blogspot.com/2017/03/what-microservice-from-linguisitc.html</a>
</li>

<li>Microservices (Wikipedia)<br />
<a href="https://en.wikipedia.org/wiki/Microservices">https://en.wikipedia.org/wiki/Microservices</a>
</li>

<li>Fallacies of distributed computing (Wikipedia)<br />
<a href="https://en.wikipedia.org/wiki/Fallacies_of_distributed_computing">https://en.wikipedia.org/wiki/Fallacies_of_distributed_computing</a>
</li>

<li>Service (systems architecture)<br />
<a href="https://en.wikipedia.org/wiki/Service_(systems_architecture)">https://en.wikipedia.org/wiki/Service_(systems_architecture)</a>
</li>

<li>Microservices in a Nutshell<br />
<a href="https://www.thoughtworks.com/insights/blog/microservices-nutshell">https://www.thoughtworks.com/insights/blog/microservices-nutshell</a>
</li>

<li>What is Microservices?<br />
<a href="https://smartbear.com/solutions/microservices/">https://smartbear.com/solutions/microservices/</a>
</li>

<li>Mastering Chaos - A Netflix Guide to Microservices<br />
<a href="https://www.youtube.com/watch?v=CZ3wIuvmHeM&t=17s">https://www.youtube.com/watch?v=CZ3wIuvmHeM&amp;t=17s</a>
</li>

<li>Messaging in Microservice Architecture<br />
<a href="https://www.youtube.com/watch?v=MkQWQ5f-SEY">https://www.youtube.com/watch?v=MkQWQ5f-SEY</a>
</li>

<li>Pattern: Messaging<br />
<a href="https://microservices.io/patterns/communication-style/messaging.html">https://microservices.io/patterns/communication-style/messaging.html</a>
</li>

<li>Microservices Messaging: Why REST Isn’t Always the Best Choice<br />
<a href="https://blog.codeship.com/microservices-messaging-rest-isnt-always-best-choice/">https://blog.codeship.com/microservices-messaging-rest-isnt-always-best-choice/</a>
</li>

<li>Protocol buffers<br />
<a href="https://developers.google.com/protocol-buffers/">https://developers.google.com/protocol-buffers/</a>
</li>

<li>BSON<br />
<a href="http://bsonspec.org/">http://bsonspec.org/</a>
</li>

<li>Apache Avro!<br />
<a href="https://avro.apache.org/">https://avro.apache.org/</a>
</li>

<li>REST vs Messaging for Microservices – Which One is Best?<br />
<a href="https://solace.com/blog/experience-awesomeness-event-driven-microservices/">https://solace.com/blog/experience-awesomeness-event-driven-microservices/</a>
</li>

<li>How did we end up here?<br />
<a href="https://gotocon.com/dl/goto-chicago-2015/slides/MartinThompson_and_ToddMontgomery_HowDidWeEndUpHere.pdf">https://gotocon.com/dl/goto-chicago-2015/slides/MartinThompson_and_ToddMontgomery_HowDidWeEndUpHere.pdf</a>
</li>

<li>Scaling microservices with message queues to handle data bursts<br />
<a href="https://read.acloud.guru/scaling-microservices-with-message-queue-2d389be5b139">https://read.acloud.guru/scaling-microservices-with-message-queue-2d389be5b139</a>
</li>

<li>Microservices: What are smart endpoints and dumb pipes?<br />
<a href="https://stackoverflow.com/questions/26616962/microservices-what-are-smart-endpoints-and-dumb-pipes">https://stackoverflow.com/questions/26616962/microservices-what-are-smart-endpoints-and-dumb-pipes</a>
</li>

<li>Common Object Request Broker Architecture<br />
<a href="https://en.wikipedia.org/wiki/Common_Object_Request_Broker_Architecture">https://en.wikipedia.org/wiki/Common_Object_Request_Broker_Architecture</a>
</li>

<li>Enterprise service bus<br />
<a href="https://en.wikipedia.org/wiki/Enterprise_service_bus">https://en.wikipedia.org/wiki/Enterprise_service_bus</a>
</li>

<li>Microservices vs SOA : What’s the Difference<br />
<a href="https://www.edureka.co/blog/microservices-vs-soa/">https://www.edureka.co/blog/microservices-vs-soa/</a>
</li>

<li>Pravda o SOA<br />
<a href="https://businessworld.cz/reseni-a-realizace/pravda-o-soa-2980">https://businessworld.cz/reseni-a-realizace/pravda-o-soa-2980</a>
</li>

<li>Is it a good idea for Microservices to share a common database?<br />
<a href="https://www.quora.com/Is-it-a-good-idea-for-Microservices-to-share-a-common-database">https://www.quora.com/Is-it-a-good-idea-for-Microservices-to-share-a-common-database</a>
</li>

<li>Pattern: Shared database<br />
<a href="https://microservices.io/patterns/data/shared-database.html">https://microservices.io/patterns/data/shared-database.html</a>
</li>

<li>Is a Shared Database in Microservices Actually an Anti-pattern?<br />
<a href="https://hackernoon.com/is-shared-database-in-microservices-actually-anti-pattern-8cc2536adfe4">https://hackernoon.com/is-shared-database-in-microservices-actually-anti-pattern-8cc2536adfe4</a>
</li>

<li>Shared database in microservices is a problem, yep<br />
<a href="https://ayende.com/blog/186914-A/shared-database-in-microservices-is-a-problem-yep">https://ayende.com/blog/186914-A/shared-database-in-microservices-is-a-problem-yep</a>
</li>

<li>Microservices with shared database? using multiple ORM's?<br />
<a href="https://stackoverflow.com/questions/43612866/microservices-with-shared-database-using-multiple-orms">https://stackoverflow.com/questions/43612866/microservices-with-shared-database-using-multiple-orms</a>
</li>

<li>Examples of microservice architecture<br />
<a href="https://www.coursera.org/lecture/intro-ibm-microservices/examples-of-microservice-architecture-JXOFj">https://www.coursera.org/lecture/intro-ibm-microservices/examples-of-microservice-architecture-JXOFj</a>
</li>

<li>Microservices: The Rise Of Kafka<br />
<a href="https://movio.co/blog/microservices-rise-kafka/">https://movio.co/blog/microservices-rise-kafka/</a>
</li>

<li>Building a Microservices Ecosystem with Kafka Streams and KSQL<br />
<a href="https://www.confluent.io/blog/building-a-microservices-ecosystem-with-kafka-streams-and-ksql/">https://www.confluent.io/blog/building-a-microservices-ecosystem-with-kafka-streams-and-ksql/</a>
</li>

<li>An introduction to Apache Kafka and microservices communication<br />
<a href="https://medium.com/@ulymarins/an-introduction-to-apache-kafka-and-microservices-communication-bf0a0966d63">https://medium.com/@ulymarins/an-introduction-to-apache-kafka-and-microservices-communication-bf0a0966d63</a>
</li>

<li>ACID (computer science)<br />
<a href="https://en.wikipedia.org/wiki/ACID_(computer_science)">https://en.wikipedia.org/wiki/ACID_(computer_science)</a>
</li>

<li>Distributed transaction<br />
<a href="https://en.wikipedia.org/wiki/Distributed_transaction">https://en.wikipedia.org/wiki/Distributed_transaction</a>
</li>

<li>Two-phase commit protocol<br />
<a href="https://en.wikipedia.org/wiki/Two-phase_commit_protocol">https://en.wikipedia.org/wiki/Two-phase_commit_protocol</a>
</li>

<li>Why is 2-phase commit not suitable for a microservices architecture?<br />
<a href="https://stackoverflow.com/questions/55249656/why-is-2-phase-commit-not-suitable-for-a-microservices-architecture">https://stackoverflow.com/questions/55249656/why-is-2-phase-commit-not-suitable-for-a-microservices-architecture</a>
</li>

<li>4 reasons why microservices resonate<br />
<a href="https://www.oreilly.com/ideas/4-reasons-why-microservices-resonate">https://www.oreilly.com/ideas/4-reasons-why-microservices-resonate</a>
</li>

<li>Pattern: Microservice Architecture<br />
<a href="https://microservices.io/patterns/microservices.html">https://microservices.io/patterns/microservices.html</a>
</li>

<li>Pattern: Monolithic Architecture<br />
<a href="https://microservices.io/patterns/monolithic.html">https://microservices.io/patterns/monolithic.html</a>
</li>

<li>Pattern: Saga<br />
<a href="https://microservices.io/patterns/data/saga.html">https://microservices.io/patterns/data/saga.html</a>
</li>

<li>Pattern: Database per service<br />
<a href="https://microservices.io/patterns/data/database-per-service.html">https://microservices.io/patterns/data/database-per-service.html</a>
</li>

<li>Pattern: Access token<br />
<a href="https://microservices.io/patterns/security/access-token.html">https://microservices.io/patterns/security/access-token.html</a>
</li>

<li>Databázová integrita<br />
<a href="https://cs.wikipedia.org/wiki/Datab%C3%A1zov%C3%A1_integrita">https://cs.wikipedia.org/wiki/Datab%C3%A1zov%C3%A1_integrita</a>
</li>

<li>Referenční integrita<br />
<a href="https://cs.wikipedia.org/wiki/Referen%C4%8Dn%C3%AD_integrita">https://cs.wikipedia.org/wiki/Referen%C4%8Dn%C3%AD_integrita</a>
</li>

<li>Introduction into Microservices <br />
<a href="https://specify.io/concepts/microservices">https://specify.io/concepts/microservices</a>
</li>

<li>Are Microservices ‘SOA Done Right’?<br />
<a href="https://intellyx.com/2015/07/20/are-microservices-soa-done-right/">https://intellyx.com/2015/07/20/are-microservices-soa-done-right/</a>
</li>

<li>The Hardest Part About Microservices: Your Data<br />
<a href="https://blog.christianposta.com/microservices/the-hardest-part-about-microservices-data/">https://blog.christianposta.com/microservices/the-hardest-part-about-microservices-data/</a>
</li>

<li>From a monolith to microservices + REST<br />
<a href="https://www.slideshare.net/InfoQ/from-a-monolith-to-microservices-rest-the-evolution-of-linkedins-service-architecture">https://www.slideshare.net/InfoQ/from-a-monolith-to-microservices-rest-the-evolution-of-linkedins-service-architecture</a>
</li>

<li>DevOps and the Myth of Efficiency, Part I<br />
<a href="https://blog.christianposta.com/devops/devops-and-the-myth-of-efficiency-part-i/">https://blog.christianposta.com/devops/devops-and-the-myth-of-efficiency-part-i/</a>
</li>

<li>DevOps and the Myth of Efficiency, Part II<br />
<a href="https://blog.christianposta.com/devops/devops-and-the-myth-of-efficiency-part-ii/">https://blog.christianposta.com/devops/devops-and-the-myth-of-efficiency-part-ii/</a>
</li>

<li>Standing on Distributed Shoulders of Giants: Farsighted Physicists of Yore Were Danged Smart!<br />
<a href="https://queue.acm.org/detail.cfm?id=2953944">https://queue.acm.org/detail.cfm?id=2953944</a>
</li>

<li>Building DistributedLog: High-performance replicated log service<br />
<a href="https://blog.twitter.com/engineering/en_us/topics/infrastructure/2015/building-distributedlog-twitter-s-high-performance-replicated-log-servic.html">https://blog.twitter.com/engineering/en_us/topics/infrastructure/2015/building-distributedlog-twitter-s-high-performance-replicated-log-servic.html</a>
</li>

<li>Turning the database inside-out with Apache Samza<br />
<a href="https://www.confluent.io/blog/turning-the-database-inside-out-with-apache-samza/">https://www.confluent.io/blog/turning-the-database-inside-out-with-apache-samza/</a>
</li>

<li>Debezium: Stream changes from your databases.<br />
<a href="https://debezium.io/">https://debezium.io/</a>
</li>

<li>Change data capture<br />
<a href="https://en.wikipedia.org/wiki/Change_data_capture">https://en.wikipedia.org/wiki/Change_data_capture</a>
</li>

<li>Apache Samza (Wikipedia)<br />
<a href="https://en.wikipedia.org/wiki/Apache_Samza">https://en.wikipedia.org/wiki/Apache_Samza</a>
</li>

<li>Storm (event processor)<br />
<a href="https://en.wikipedia.org/wiki/Storm_(event_processor)">https://en.wikipedia.org/wiki/Storm_(event_processor)</a>
</li>

<li>kappa-architecture.com<br />
<a href="http://milinda.pathirage.org/kappa-architecture.com/">http://milinda.pathirage.org/kappa-architecture.com/</a>
</li>

<li>Questioning the Lambda Architecture<br />
<a href="https://www.oreilly.com/ideas/questioning-the-lambda-architecture">https://www.oreilly.com/ideas/questioning-the-lambda-architecture</a>
</li>

<li>Lambda architecture<br />
<a href="https://en.wikipedia.org/wiki/Lambda_architecture">https://en.wikipedia.org/wiki/Lambda_architecture</a>
</li>

<li>Event stream processing<br />
<a href="https://en.wikipedia.org/wiki/Event_stream_processing">https://en.wikipedia.org/wiki/Event_stream_processing</a>
</li>

<li>How to beat the CAP theorem<br />
<a href="http://nathanmarz.com/blog/how-to-beat-the-cap-theorem.html">http://nathanmarz.com/blog/how-to-beat-the-cap-theorem.html</a>
</li>

<li>Kappa Architecture Our Experience<br />
<a href="https://events.static.linuxfound.org/sites/events/files/slides/ASPgems%20-%20Kappa%20Architecture.pdf">https://events.static.linuxfound.org/sites/events/files/slides/ASPgems%20-%20Kappa%20Architecture.pdf</a>
</li>

<li>Messaging Patterns in Event Driven Microservice Architectures<br />
<a href="https://www.youtube.com/watch?v=3xDc4MEYuHI">https://www.youtube.com/watch?v=3xDc4MEYuHI</a>
</li>

<li>Why monolithic apps are often better than microservices<br />
<a href="https://gigaom.com/2015/11/06/why-monolithic-apps-are-often-better-than-microservices/">https://gigaom.com/2015/11/06/why-monolithic-apps-are-often-better-than-microservices/</a>
</li>

<li>How Enterprise PaaS Can Add Critical Value to Microservices<br />
<a href="https://apprenda.com/blog/enterprise-paas-microservices/">https://apprenda.com/blog/enterprise-paas-microservices/</a>
</li>

<li>Common React Mistakes: Monolithic Components and a Lack of Abstraction<br />
<a href="https://www.pmg.com/blog/common-react-mistakes-monolithic-components-lack-abstraction/">https://www.pmg.com/blog/common-react-mistakes-monolithic-components-lack-abstraction/</a>
</li>

<li>From monolith to microservices – to migrate or not to migrate?<br />
<a href="https://altkomsoftware.pl/en/blog/monolith-microservices/">https://altkomsoftware.pl/en/blog/monolith-microservices/</a>
</li>

<li>Command–query separation<br />
<a href="https://en.wikipedia.org/wiki/Command%E2%80%93query_separation">https://en.wikipedia.org/wiki/Command%E2%80%93query_separation</a>
</li>

<li>GOTO 2016: Messaging and Microservices (Clemens Vasters)<br />
<a href="https://www.youtube.com/watch?v=rXi5CLjIQ9kx">https://www.youtube.com/watch?v=rXi5CLjIQ9kx</a>
</li>

<li>GOTO Amsterdam 2019<br />
<a href="https://gotoams.nl/">https://gotoams.nl/</a>
</li>

</ol>



<p></p><p></p>
<p><small>Autor: <a href="http://www.fit.vutbr.cz/~tisnovpa">Pavel Tišnovský</a> &nbsp; 2019</small></p>
</body>
</html>

