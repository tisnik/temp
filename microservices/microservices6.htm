<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
        "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html>
<head>
<title>Mikroslužby založené na REST API</title>
<meta name="Author" content="Pavel Tisnovsky" />
<meta name="Generator" content="vim" />
<meta http-equiv="content-type" content="text/html; charset=utf-8" />
<style type="text/css">
         body {color:#000000; background:#ffffff;}
         h1  {font-family: arial, helvetica, sans-serif; color:#ffffff; background-color:#c00000; text-align:center; padding-left:1em}
         h2  {font-family: arial, helvetica, sans-serif; color:#ffffff; background-color:#0000c0; padding-left:1em; text-align:left}
         h3  {font-family: arial, helvetica, sans-serif; color:#000000; background-color:#c0c0c0; padding-left:1em; text-align:left}
         h4  {font-family: arial, helvetica, sans-serif; color:#000000; background-color:#e0e0e0; padding-left:1em; text-align:left}
         a   {font-family: arial, helvetica, sans-serif;}
         li  {font-family: arial, helvetica, sans-serif; color:#000000; text-align:justify; width:450px;}
         ol  {font-family: arial, helvetica, sans-serif; color:#000000; text-align:justify; width:450px;}
         ul  {font-family: arial, helvetica, sans-serif; color:#000000; text-align:justify; width:450px;}
         p   {font-family: arial, helvetica, sans-serif; color:#000000; text-align:justify;}
         pre {background:#e0e0e0}
</style>
</head>

<body>

<h1>Mikroslužby založené na REST API</h1>

<h3>Pavel Tišnovský</h3>

<p></p>

<h1>Úvodník</h1>

<p>V úvodních částech seriálu o mikroslužbách jsme se zabývali především teoretickým popisem technologií, které jsou při tvorbě a provozu mikroslužeb často používány. Pochopitelně nás však budou zajímat i praktické příklady, jimiž se začneme zabývat dnes.</p>



<h2>Obsah</h2>

<p><a href="#k01">1. Mikroslužby založené na REST API</a></p>
<p><a href="#k02">2. Jakou technologii vybrat pro implementaci mikroslužby s&nbsp;REST API?</a></p>
<p><a href="#k03">3. Jednoduchá aplikace s&nbsp;HTTP serverem naprogramovaná v&nbsp;Go</a></p>
<p><a href="#k04">4. Použití protokolu HTTPS namísto HTTP</a></p>
<p><a href="#k05">5. Druhá varianta serveru používajícího protokol HTTPS</a></p>
<p><a href="#k06">6. Použití frameworku Flask a Connexion při tvorbě služeb s&nbsp;REST API v&nbsp;Pythonu</a></p>
<p><a href="#k07">7. Nejjednodušší aplikace založená pouze na frameworku Flask</a></p>
<p><a href="#k08">8. Specifikace API s&nbsp;využitím Swaggeru</a></p>
<p><a href="#k09">9. Kostra služby</a></p>
<p><a href="#k10">10. První služba naprogramovaná v&nbsp;Pythonu</a></p>
<p><a href="#k11">11. Přidání dvou koncových bodů do specifikace služby</a></p>
<p><a href="#k12">12. Implementace <i>handlerů</i> nových koncových bodů</a></p>
<p><a href="#k13">13. Otestování druhé varianty služby pomocí Swagger UI i nástroje <strong>curl</strong></a></p>
<p><a href="#k14">14. Vylepšení služby &ndash; koncový bod pro poslání zprávy</a></p>
<p><a href="#k15">15. Specifikace nového koncového bodu s&nbsp;určením parametrů</a></p>
<p><a href="#k16">16. Demonstrační implementace nového koncového bodu a otestování služby</a></p>
<p><a href="#k17">17. Poslání zprávy přímo přes Swagger UI</a></p>
<p><a href="#k18">18. Čtvrtá varianta služby s&nbsp;koncovým bodem vracejícím data ve formátu JSON</a></p>
<p><a href="#k19">19. Repositář s&nbsp;demonstračními příklady</a></p>
<p><a href="#k20">20. Odkazy na Internetu</a></p>



<p><a name="k01"></a></p>
<h2 id="k01">1. Mikroslužby založené na REST API</h2>

<p>V&nbsp;prvních pěti částech <a
href="https://www.root.cz/serialy/mikrosluzby/">seriálu o mikroslužbách</a>
jsme se zabývali především teoretickým popisem vlastní architektury mikroslužeb
a taktéž některých základních technologií, které jsou ve světě mikroslužeb
často používány. Druhá část tohoto seriálu bude ovšem zaměřena více prakticky,
protože si postupně ukážeme způsoby použití jednotlivých technologií.
Demonstrační příklady budou většinou naprogramovány v&nbsp;<a
href="https://www.root.cz/n/python/">Pythonu</a> a taktéž v&nbsp;jazyku <a
href="https://www.root.cz/serialy/programovaci-jazyk-go/">Go</a>. Volba těchto
dvou programovacích jazyků samozřejmě není náhodná, protože se s&nbsp;oběma
zmíněnými jazyky ve světě mikroslužeb poměrně často setkáme, i když je na tomto
místě nutné říci, že se Python od Go v&nbsp;mnoha oblastech odlišuje (nebo
jinými slovy &ndash; tyto jazyky se vzájemně doplňují). Dále se pochopitelně
v&nbsp;této oblasti setkáme s&nbsp;Javou a dalšími programovacími jazyky
postavenými nad JVM (především se Scalou), popř.&nbsp;s&nbsp;C#,
s&nbsp;JavaScriptem a TypeScriptem (Node.js) a někdy též s&nbsp;jazykem
Ruby.</p>

<a href="https://www.root.cz/obrazek/361137/"><img src="https://i.iinfo.cz/images/372/microservices1-4-prev.png" class="image-361137" alt="&#160;" width="358" height="270" /></a>
<p><i>Obrázek 1: Jednotlivé mikroslužby mezi sebou mohou komunikovat například
s&nbsp;využitím protokolu HTTP (REST API), STOMP atd. Dnes nás bude zajímat
právě HTTP.</i></p>

<p><div class="rs-tip-major">Poznámka: z&nbsp;předchozích článků již víme, že
právě architektura mikroslužeb umožňuje, aby byly jednotlivé služby,
z&nbsp;nichž se celá aplikace postupně složí, vyvinuty v&nbsp;různých
programovacích jazycích. Je tedy například snadné identifikovat tu část
aplikace, která má velké nároky na výpočetní výkon a tu přepsat z&nbsp;Pythonu
(či JavaScriptu nebo TypeScriptu) do Go nebo Javy. Rozdělení monolitické
aplikace na menší a snadněji spravovatelné moduly tento postup umožňuje
aplikovat po částech a nezávisle na dalších funkcích aplikace.</div></p>

<p>Nejdříve si ukážeme, jakým způsobem se v&nbsp;Pythonu a Go vytváří služby
s&nbsp;rozhraním REST API. Ve skutečnosti se nemusí jednat o nic složitého,
protože REST API je postaveno na protokolu HTTP (popř.&nbsp;dnes spíše HTTPS) a
při použití vhodných knihoven a frameworků je implementace jednotlivých
koncových bodů (<i>endpointů</i>) REST API stejně přímočará, jako vytvoření
běžného API.</p>



<p><a name="k02"></a></p>
<h2 id="k02">2. Jakou technologii vybrat pro implementaci mikroslužby s&nbsp;REST API?</h2>

<p>Samotné mikroslužby mohou být realizovány relativně snadno (alespoň
z&nbsp;hlediska použitých technologií, protože business logika může být někdy
hodně složitá). Primárním způsobem komunikace mikroslužeb s&nbsp;okolím je
v&nbsp;současnosti protokol HTTP(S) a REST; ovšem nesmíme zapomenout ani na
protokoly používané při komunikaci s&nbsp;message brokerem (AMQP, MQTT, STOMP,
XMPP). Pro samotnou realizaci je možné použít různé programovací jazyky,
například (z&nbsp;těch používanějších jazyků) Javu, Python, Ruby, JavaScript
(TypeScript) a v&nbsp;neposlední řadě i <a
href="https://www.root.cz/serialy/programovaci-jazyk-go/">programovací jazyk
Go</a>. Pro každý z&nbsp;těchto jazyků popř.&nbsp;ekosystémů existují knihovny
a frameworky určené (mimo dalších použití) právě pro tvorbu mikroslužeb.
V&nbsp;následující tabulce jsou některé z&nbsp;těchto knihoven/frameworků
vypsány, ovšem pochopitelně se nejedná o úplný přehled, protože mikroslužbu
můžeme v&nbsp;případě potřeby naprogramovat například i v&nbsp;čistém céčku
s&nbsp;využitím socketů, knihoven <a
href="https://www.root.cz/clanky/0mq-knihovna-pro-asynchronni-predavani-zprav/">0MQ</a>,
<a
href="https://www.root.cz/clanky/implementace-ruznych-komunikacnich-strategii-s-vyuzitim-knihovny-nanomsg/">nanomsg</a>
atd.:</p>

<table>
<tr><th>#</th><th>Jazyk/ekosystém</th><th>Knihovna či framework</th></tr>
<tr><td>1</td><td>Java</td><td><a href="http://vertx.io/">Vert.x</a>, <a href="https://spring.io/projects/spring-boot">Spring Boot</a>, <a href="https://www.dropwizard.io/">Dropwizard</a>, <a href="http://www.ninjaframework.org/">Ninja</a></td></tr>
<tr><td>2</td><td>Python</td><td><a href="https://www.django-rest-framework.org/">Django REST framework</a>, <a href="https://flask-restful.readthedocs.io/en/latest/">FlaskRESTful</a>, <a href="https://github.com/toastdriven/restless">restless</a>, <a href="http://falconframework.org/">Falcon</a></td></tr>
<tr><td>3</td><td>Ruby</td><td><a href="https://rubyonrails.org/">Rails</a>, <a href="http://www.ruby-grape.org/">Grape</a>, <a href="http://sinatrarb.com/">Sinatra</a>, <a href="https://hanamirb.org/">Hanami</a></td></tr>
<tr><td>4</td><td>JavaScript/TypeScript</td><td><a href="http://senecajs.org/">Seneca</a>, <a href="https://koajs.com/">Koa</a>, <a href="https://loopback.io/">LoopBack</a></td></tr>
<tr><td>5</td><td>Go</td><td><a href="https://github.com/goadesign/goa">Goa</a>, <a href="https://golang.org/pkg/net/http/">standardní balíček net/http</a></td></tr>
<tr><td>6</td><td>Clojure</td><td><a href="https://github.com/ring-clojure/ring">Ring</a>, <a href="http://clojure-liberator.github.io/liberator/">Liberator</a>, <a href="https://github.com/weavejester/compojure">Compojure</a></td></tr>
</table>

<p><div class="rs-tip-major">Poznámka: pravděpodobně jste si všimli, že se
mnohdy jedná o &bdquo;obyčejné&ldquo; knihovny poskytující REST API. To je
v&nbsp;pořádku, protože mnohdy nic dalšího, než realizaci několika REST API
<i>endpointů</i> ani nevyžadujeme (ostatně samotný název
&bdquo;mikroslužby&ldquo; evokuje, že si mnohdy vystačíme pouze se základními
technologiemi).</div></p>

<p>Pro ukázku, že webovou službu (či její kostru) lze vytvořit v&nbsp;prakticky
v&nbsp;jakémkoli programovacím jazyce si ukažme primitivní službu
naprogramovanou v&nbsp;Clojure, v&nbsp;níž se využívá knihovna <i>Clojure
Ring</i>:</p>

<pre>
(ns webapp1.core
    (:gen-class))
&nbsp;
(require '[ring.adapter.jetty :as jetty])
&nbsp;
(defn <strong>app</strong>
    "Funkce predstavujici kostru webove aplikace."
    [request]
    {:status 200
     :headers {"Content-Type" "text/plain"}
     :body "Hello World"})
&nbsp;
(defn <strong>-main</strong>
    "Spusteni webove aplikace na portu 8080."
    [&amp; args]
(jetty/run-jetty app {:port 8080}))
</pre>

<p>Navíc je možné s&nbsp;využitím knihovny <i>Hiccup</i> vygenerovat i HTML
stránku z&nbsp;dat reprezentovaných rozšířenými S-výrazy:</p>

<pre>
(ns htmltest1.core
    (:gen-class))
&nbsp;
(require '[hiccup.page :as page])
&nbsp;
(defn html-page
    []
    (page/xhtml
        [:head
            [:title "Hiccup test #1"]
            [:meta {:name "Generator" :content "Clojure"}]
            [:meta {:http-equiv "Content-type" :content "text/html; charset=utf-8"}]
        ]
        [:body
            [:h1 "Hiccup test #1"]
            [:div "Hello world!"]
        ]))
</pre>

<p><div class="rs-tip-major">Poznámka: nemusíte se bát &ndash; další příklady
jsou naprogramovány v&nbsp;Go a Pythonu :-)</div></p>



<p><a name="k03"></a></p>
<h2 id="k03">3. Jednoduchá aplikace s&nbsp;HTTP serverem naprogramovaná v&nbsp;Go</h2>

<p>V&nbsp;programovacím jazyku Go můžeme pro implementaci HTTP serverů použít
balíček pojmenovaný výstižně <strong>net/http</strong>, který je součástí
standardní knihovny nainstalované současně s&nbsp;překladačem a dalšími
standardními nástroji ekosystému Go (jinými slovy &ndash; kromě samotného Go
již není vyžadována žádná další komponenta). Jak již název tohoto balíčku
napovídá, obsahuje funkce a nové datové typy určené pro práci s&nbsp;protokolem
HTTP, a to jak pro klienty, kteří posílají dotazy (<i>request</i>) na servery,
tak i pro implementaci vlastních serverů zpracovávajících dotazy a
vytvářejících odpovědi (<i>response</i>). Ostatně právě existence tohoto
balíčku měla poměrně velký vliv na oblíbenost programovacího jazyka Go pro
tvorbu síťově orientovaných aplikací a tím pádem i pro implementaci služeb a
mikroslužeb v&nbsp;tomto programovacím jazyku.</p>

<p>Nejužitečnější vlastností balíčku <strong>net/http</strong> je jeho podpora
pro vytvoření skutečného a plnohodnotného HTTP serveru, a to doslova na
několika řádcích programového kódu. Základem pro vytvoření HTTP serveru je
funkce nazvaná <strong>HandleFunc</strong>, která nám umožňuje zaregistrovat
obslužnou funkci (takzvaný <i>handler</i>) v&nbsp;případě, že je server volán
s&nbsp;určitým URL (endpointem). Můžeme si například zaregistrovat handler pro
endpoint /:</p>

<pre>
http.HandleFunc("/", mainEndpoint)
</pre>

<p>Hlavička funkce <strong>HandleFunc</strong> z&nbsp;balíčku
<strong>net/http</strong> vypadá takto:</p>

<pre>
func <strong>HandleFunc</strong>(pattern string, handler func(ResponseWriter, *Request))
</pre>

<p>Povšimněte si, že druhým parametrem této funkce je jiná funkce (onen
handler) s&nbsp;hlavičkou:</p>

<pre>
func <strong>MujHandler</strong>(ResponseWriter, *Request)
</pre>

<p>Tomuto handleru se předávají dva objekty &ndash; objekt sloužící pro zápis
hlavičky i těla odpovědi a objekt s&nbsp;informacemi o požadavku došlého od
klienta.</p>

<p>Konkrétně může implementace našeho handleru poslat na výstup (typu
<strong>ResponseWriter</strong>) jednoduchý text, který bude zaslán klientovi
v&nbsp;celé HTTP odpovědi (s&nbsp;hlavičkami, stavovým kódem, případnou délkou
zprávy, cookies, atd. atd.):</p>

<pre>
func <strong>mainEndpoint</strong>(writer http.ResponseWriter, request *http.Request) {
        io.WriteString(writer, "Hello world!\n")
}
</pre>

<p>Následně již stačí server spustit na určeném portu. My jsme si pro testovací
účely zvolili port 8000:</p>

<pre>
http.ListenAndServe(":8000", nil)
</pre>

<p><div class="rs-tip-major">Poznámka: číslo portu by mělo být větší než 1023,
protože porty s&nbsp;nižšími čísly vyžadují administrátorská práva a většinou
není nutné ani bezpečné spouštět služby s&nbsp;těmito právy
administrátora.</div></p>

<p>Úplná <a
href="https://github.com/tisnik/microservices/tree/master/REST-API/Go/service1.go">implementace
takto jednoduchého HTTP serveru</a> může vypadat takto:</p>

<pre>
package <strong>main</strong>
&nbsp;
import (
        "io"
        "net/http"
)
&nbsp;
func <strong>mainEndpoint</strong>(writer http.ResponseWriter, request *http.Request) {
        io.WriteString(writer, "Hello world!\n")
}
&nbsp;
func <strong>main</strong>() {
        http.HandleFunc("/", mainEndpoint)
        http.ListenAndServe(":8000", nil)
}
</pre>

<p>K&nbsp;otestování tohoto příkladu využijeme například známou utilitku
<strong>curl</strong>:</p>

<pre>
$ <strong>curl localhost:8000</strong>
&nbsp;
Hello world!
</pre>

<p>Popř.&nbsp;pro podrobnější výstup můžeme utilitě <strong>curl</strong>
předat přepínač <strong>-v</strong>:</p>

<pre>
$ <strong>curl -v localhost:8000</strong>
&nbsp;
* Rebuilt URL to: localhost:8000/
* Hostname was NOT found in DNS cache
*   Trying 127.0.0.1...
* Connected to localhost (127.0.0.1) port 8000 (#0)
&gt; GET / HTTP/1.1
&gt; User-Agent: curl/7.35.0
&gt; Host: localhost:8000
&gt; Accept: */*
&gt; 
&lt; HTTP/1.1 200 OK
&lt; Date: Wed, 13 Feb 2019 19:31:17 GMT
&lt; Content-Length: 13
&lt; Content-Type: text/plain; charset=utf-8
&lt; 
Hello world!
* Connection #0 to host localhost left intact
</pre>

<p>Nic nám samozřejmě nebrání otestovat naši službu přímo ve webovém
prohlížeči:</p>

<img src="https://i.iinfo.cz/images/598/microservices6-1.png" class="image-365489" alt="&#160;" width="299" height="132" />
<p><i>Obrázek 2: Výsledek zobrazený ve Firefoxu.</i></p>

<a href="https://www.root.cz/obrazek/365490/"><img src="https://i.iinfo.cz/images/598/microservices6-2-prev.png" class="image-365490" alt="&#160;" width="370" height="242" /></a>
<p><i>Obrázek 3: Výsledek zobrazený v&nbsp;prohlížeči Lynx.</i></p>



<p><a name="k04"></a></p>
<h2 id="k04">4. Použití protokolu HTTPS namísto HTTP</h2>

<p>V&nbsp;této kapitole si ukážeme, jakým způsobem je možné s&nbsp;využitím
programovacího jazyka Go a jeho základních knihoven implementovat HTTPS server.
Uvidíme, že samotná implementace bude velmi podobná implementaci HTTP serveru,
ovšem pro správnou funkčnost protokolu HTTPS budeme muset použít externího
nástroje pro vytvoření privátního klíče serveru a jeho certifikátu. Bližší
informace o samotném konceptu, na němž je HTTPS postaveno, naleznete například
na stránce <a
href="https://en.wikipedia.org/wiki/HTTPS">https://en.wikipedia.org/wiki/HTTPS</a>.</p>

<p><div class="rs-tip-major">Poznámka: v&nbsp;příkladu budeme používat port
4443 a nikoli obvyklejší port 443. Je tomu tak z&nbsp;toho důvodu, že pro
otevření portů s&nbsp;nižšími čísly je nutné mít práva
administrátora.</div></p>

<p>Samotná implementace jednoduchého HTTPS serveru se ve skutečnosti podobá
implementaci běžného HTTP serveru. Jediným rozdílem je, že se server bude
spouštět odlišným způsobem. Namísto:</p>

<pre>
http.ListenAndServe(":8000", nil)
</pre>

<p>použijeme:</p>

<pre>
http.ListenAndServeTLS(":4443", "server.crt", "server.key", nil)
</pre>

<p>kde &bdquo;server.crt&ldquo; a &bdquo;server.key&ldquo; jsou soubory, které
si vygenerujeme podle návodu uvedeného v&nbsp;navazující kapitole.</p>

<p>Korektnější bude provést kontrolu, zda funkce
<strong>http.ListenAndServeTLS</strong> neskončila s&nbsp;chybou:</p>

<pre>
err := http.ListenAndServeTLS(":4443", "server.crt", "server.key", nil)
if err != nil {
        log.Fatal("ListenAndServe: ", err)
}
</pre>



<p><a name="k05"></a></p>
<h2 id="k05">5. Druhá varianta serveru používajícího protokol HTTPS</h2>

<p><a
href="https://github.com/tisnik/microservices/tree/master/REST-API/Go/service2.go">Implementace
HTTPS serveru</a> bude vypadat takto:</p>

<pre>
package main
&nbsp;
import (
        "io"
        "log"
        "net/http"
)
&nbsp;
func <strong>mainEndpoint</strong>(writer http.ResponseWriter, request *http.Request) {
        writer.Header().Set("Content-Type", "text/plain")
        io.WriteString(writer, "Hello world!\n")
}
&nbsp;
func <strong>main</strong>() {
        http.HandleFunc("/", mainEndpoint)
        err := http.ListenAndServeTLS(":4443", "server.crt", "server.key", nil)
        if err != nil {
                log.Fatal("ListenAndServe: ", err)
        }
}
</pre>

<p>Prozatím ovšem ještě nemáme připraveny všechny potřebné soubory, a to ani na
straně serveru, ani na straně klienta. Proto se pokus o zavolání serveru
nezdaří:</p>

<pre>
$ <strong>curl -v https://localhost:4443</strong>
&nbsp;
* Rebuilt URL to: https://localhost:4443/
* Hostname was NOT found in DNS cache
*   Trying 127.0.0.1...
* Connected to localhost (127.0.0.1) port 4443 (#0)
* successfully set certificate verify locations:
*   CAfile: none
  CApath: /etc/ssl/certs
* SSLv3, TLS handshake, Client hello (1):
* SSLv3, TLS handshake, Server hello (2):
* SSLv3, TLS handshake, CERT (11):
* SSLv3, TLS alert, Server hello (2):
* SSL certificate problem: self signed certificate
* Closing connection 0
curl: (60) SSL certificate problem: self signed certificate
More details here: http://curl.haxx.se/docs/sslcerts.html
&nbsp;
curl performs SSL certificate verification by default, using a "bundle"
 of Certificate Authority (CA) public keys (CA certs). If the default
 bundle file isn't adequate, you can specify an alternate file
 using the --cacert option.
If this HTTPS server uses a certificate signed by a CA represented in
 the bundle, the certificate verification probably failed due to a
 problem with the certificate (it might be expired, or the name might
 not match the domain name in the URL).
If you'd like to turn off curl's verification of the certificate, use
 the -k (or --insecure) option.
</pre>

<p>Nyní musíme vygenerovat soubory <strong>server.key</strong> a
<strong>server.crt</strong>, které bude naše implementace HTTPS serveru
používat.</p>

<p>Privátní klíč používaný serverem vygenerujeme s&nbsp;využitím nástroje
<strong>openssl</strong>, který již pravděpodobně máte v&nbsp;systému
nainstalovaný:</p>

<pre>
$ <strong>openssl genrsa -out server.key 2048</strong>
</pre>

<p>Výsledkem by měl být soubor <strong>server.key</strong> obsahující klíč pro
2048bitové RSA:</p>

<pre>
-----BEGIN RSA PRIVATE KEY-----
MIIEowIBAAKCAQEAyhgV0Gmo0dCkdcEO5X0J//xKD73E+n0pyw7htM/1gPnU9h2X
JYNqFnq0xz9QsxTAPHYLkueW1SNhWT9gq3Sad/M3Cxb6uomB+i0qSk71Q6PkaqHQ
KveSsNNa4lw5DBFVjTD/JPnWhVvKS7v0A266snwmTi18+fRpWZ/TaQN5uQRy0bik
...
...
...
RbBs8QKBgB3dl+NGC+iTPVviPixjFkP5KAcf3Is57Pi0RUgTj4Fmq2q90Scoi6Vv
OzZoo2XHmqAnqxV75OWqA7NiKdBHwWg2O9BupFa+G3uRXgoP7cpCeT9ZoUbbMKww
j49BC9GHmOhlcz3fBT4YE3OgoeM5Fga8sVtWew9YkKe/gBAkR0+Y
-----END RSA PRIVATE KEY-----
</pre>

<p>Dále, opět nástrojem <strong>openssl</strong>, vytvoříme soubor
s&nbsp;certifikátem s&nbsp;uvedenou platností:</p>

<pre>
$ <strong>openssl req -new -x509 -sha256 -key server.key -out server.crt -days 3650</strong>
</pre>

<p>V&nbsp;tomto okamžiku se bude <strong>openssl</strong> interaktivně ptát na
několik údajů, které jsou v&nbsp;přepisu konverzace vypsány tučně:</p>

<pre>
You are about to be asked to enter information that will be incorporated
into your certificate request.
What you are about to enter is what is called a Distinguished Name or a DN.
There are quite a few fields but you can leave some blank
For some fields there will be a default value,
If you enter '.', the field will be left blank.
-----
Country Name (2 letter code) [AU]:<strong>CZ</strong>
State or Province Name (full name) [Some-State]:
Locality Name (eg, city) []:<strong>Kocourkov</strong>
Organization Name (eg, company) [Internet Widgits Pty Ltd]:<strong>Mestska garda</strong>
Organizational Unit Name (eg, section) []:
Common Name (e.g. server FQDN or YOUR name) []:<strong>localhost</strong>
Email Address []:<strong>nikdo@nikde.cz</strong>
</pre>

<p><div class="rs-tip-major">Poznámka: vyplnit můžete téměř jakékoli údaje,
pouze u &bdquo;Common Name&ldquo; ponechejte &bdquo;localhost&ldquo;
popř.&nbsp;pravé doménové jméno (pokud ho váš počítač má přiřazené).</div></p>

<p>Výsledný soubor nazvaný &bdquo;server.crt&ldquo; může vypadat takto:</p>

<pre>
-----BEGIN CERTIFICATE-----
MIIDlzCCAn+gAwIBAgIJALw/AUKjIONeMA0GCSqGSIb3DQEBCwUAMGIxCzAJBgNV
BAYTAkNaMRMwEQYDVQQIDApTb21lLVN0YXRlMRIwEAYDVQQHDAlLb2NvdXJrb3Yx
FjAUBgNVBAoMDU1lc3Rza2EgZ2FyZGExEjAQBgNVBAMMCWxvY2FsaG9zdDAeFw0x
...
...
...
rnPxzautFYD++NjhJ/j537I0Lcj9t/DkjvBiECZYkJF8p9dL4+lWZXc27n3RYS6L
7Dj+85WUXwxkfPqhkggGi8jSrZesUDtWw4XFw7bLGOaKTo2JMGxOfxL3RhrFtiMO
4j9Rvz9cr2R6a0Y=
-----END CERTIFICATE-----
</pre>

<p>HTTPS server již máme připravený (a pravděpodobně i úspěšně spuštěný), takže
ještě musíme provést konfiguraci na straně klienta. Nejprve získáme certifikát
z&nbsp;běžícího serveru, opět s&nbsp;využitím nástroje
<strong>openssl</strong>, který zkontaktuje HTTPS server a získá od něj všechny
potřebné údaje:</p>

<pre>
$ <strong>openssl s_client -showcerts -connect localhost:4443</strong>
</pre>

<p>Výsledek může vypadat následovně &ndash; nejprve je zobrazen vlastní
certifikát a posléze další metadata:</p>

<pre>
CONNECTED(00000003)
---
Certificate chain
 0 s:/C=CZ/ST=Some-State/L=Kocourkov/O=Mestska garda/CN=localhost
   i:/C=CZ/ST=Some-State/L=Kocourkov/O=Mestska garda/CN=localhost
-----BEGIN CERTIFICATE-----
MIIDlzCCAn+gAwIBAgIJALw/AUKjIONeMA0GCSqGSIb3DQEBCwUAMGIxCzAJBgNV
BAYTAkNaMRMwEQYDVQQIDApTb21lLVN0YXRlMRIwEAYDVQQHDAlLb2NvdXJrb3Yx
FjAUBgNVBAoMDU1lc3Rza2EgZ2FyZGExEjAQBgNVBAMMCWxvY2FsaG9zdDAeFw0x
OTAyMTYyMDE0MTJaFw0yOTAyMTMyMDE0MTJaMGIxCzAJBgNVBAYTAkNaMRMwEQYD
VQQIDApTb21lLVN0YXRlMRIwEAYDVQQHDAlLb2NvdXJrb3YxFjAUBgNVBAoMDU1l
c3Rza2EgZ2FyZGExEjAQBgNVBAMMCWxvY2FsaG9zdDCCASIwDQYJKoZIhvcNAQEB
BQADggEPADCCAQoCggEBAMoYFdBpqNHQpHXBDuV9Cf/8Sg+9xPp9KcsO4bTP9YD5
1PYdlyWDahZ6tMc/ULMUwDx2C5LnltUjYVk/YKt0mnfzNwsW+rqJgfotKkpO9UOj
5Gqh0Cr3krDTWuJcOQwRVY0w/yT51oVbyku79ANuurJ8Jk4tfPn0aVmf02kDebkE
ctG4pIsfu6HPfBPyMFgEBXYDiObKfGCEgpnGIeX8Li4n9r8Law45+KEFz4n2Yj3c
Jq77ZLopjV4w4n+JZYNXkK9JeV9twM5PrsYLqrLEvstXqyo/2ccYFtMvTsXx57SY
BEKABLYuPsEzYVzNo2lgtXJxxgcXfS+PrCnH6KhS4c0CAwEAAaNQME4wHQYDVR0O
BBYEFBdmG7K8HXslTnR5OkOLZCGVPD1hMB8GA1UdIwQYMBaAFBdmG7K8HXslTnR5
OkOLZCGVPD1hMAwGA1UdEwQFMAMBAf8wDQYJKoZIhvcNAQELBQADggEBAKYKeOz4
u0er6BQmy72Wc4H9ZjWnXjphfVAC0UK2gz7UHXDnyzfrBKR6FkVbeiIUjBzbrWG5
xUoHcZsfayefOEEpqcAyKpa8CRkbissHF6qtFZArt+cOWwTmmPfYQxfa9KqVP13L
FcZqcchyvTLdNTGD5ZBtLI9B5Pcm4a7vgEdMqdJb++FpSNhW9H2P0wvfhTK7Mh6/
rnPxzautFYD++NjhJ/j537I0Lcj9t/DkjvBiECZYkJF8p9dL4+lWZXc27n3RYS6L
7Dj+85WUXwxkfPqhkggGi8jSrZesUDtWw4XFw7bLGOaKTo2JMGxOfxL3RhrFtiMO
4j9Rvz9cr2R6a0Y=
-----END CERTIFICATE-----
---
Server certificate
subject=/C=CZ/ST=Some-State/L=Kocourkov/O=Mestska garda/CN=localhost
issuer=/C=CZ/ST=Some-State/L=Kocourkov/O=Mestska garda/CN=localhost
---
No client certificate CA names sent
---
SSL handshake has read 1529 bytes and written 421 bytes
---
New, TLSv1/SSLv3, Cipher is ECDHE-RSA-AES128-GCM-SHA256
Server public key is 2048 bit
Secure Renegotiation IS supported
Compression: NONE
Expansion: NONE
SSL-Session:
    Protocol  : TLSv1.2
    Cipher    : ECDHE-RSA-AES128-GCM-SHA256
    Session-ID: 1F74CA2806A25B6AE774B7A0D4E470A477D16B73130EAB527C03FE861086B076
    Session-ID-ctx: 
    Master-Key: 555000EA285A2EEFE95D5268756ED98CC71711075F8036251EC6B34494C7ED8F6861EDDDA842BC847922F536AC9CF0EA
    Key-Arg   : None
    PSK identity: None
    PSK identity hint: None
    SRP username: None
    TLS session ticket:
    0000 - 71 d2 38 c8 ec 5d e7 5e-c7 fe a7 f5 d4 33 03 e8   q.8..].^.....3..
    0010 - e9 ba 8d ff f2 1e e7 9f-8e 66 9b 0e 2b 34 eb db   .........f..+4..
    0020 - 83 c1 4b 96 f7 a4 67 71-26 3a a5 2d 65 2e 08 ae   ..K...gq&amp;:.-e...
    0030 - 84 38 3f bf 90 2e 04 0a-62 25 aa 0e 86 ca 31 4a   .8?.....b%....1J
    0040 - b7 2a 1b 1a b7 b0 b2 d9-d5 3c f4 9e 39 37 a1 69   .*.......&lt;..97.i
    0050 - 6c ac 2c 8b 83 d0 25 53-da 7c 43 17 4d 55 d6 fc   l.,...%S.|C.MU..
    0060 - 7a 55 2f 74 bd 6a e2 6f-59 b0 cc 16 d7 e0 a9 14   zU/t.j.oY.......
    0070 - 71 35 d4 62 27 85 93 f7-                          q5.b'...
&nbsp;
    Start Time: 1550348405
    Timeout   : 300 (sec)
    Verify return code: 18 (self signed certificate)
---
</pre>

<p>Nástroj budeme muset ukončit klávesovou zkratkou Ctrl+C.</p>

<p>Pro klienta je nejjednodušší přesměrovat výstup z&nbsp;předchozího volání
nástroje <strong>openssl</strong> do souboru, který bývá nazván
&bdquo;certs.pem&ldquo;:</p>

<pre>
$ <strong>openssl s_client -showcerts -connect localhost:4443 &gt; certs.pem</strong>
</pre>

<pre>
$ <strong>openssl s_client -showcerts -connect localhost:4443 &gt; certs.pem</strong>
</pre>

<p>To je ze strany klienta vše &ndash; klient pouze potřebuje pro každé volání
použít soubor &bdquo;certs.pem&ldquo; s&nbsp;certifikátem serveru, aby ho mohl
ověřit.</p>

<p>Nyní již máme vše připravené pro to, aby se klient mohl připojit
k&nbsp;serveru s&nbsp;využitím certifikátu uloženého v&nbsp;lokálním souboru
<strong>certs.pem</strong>. Příkaz volající utilitu <strong>curl</strong> bude
vypadat následovně:</p>

<pre>
$ <strong>curl -v --cacert certs.pem  https://localhost:4443</strong>
</pre>

<p>Po spuštění nástroje <strong>curl</strong> by se měl klient připojit
k&nbsp;serveru s&nbsp;využitím protokolu HTTPS, ověřit certifikát a následně
přečíst odpověď serveru (&bdquo;Hello world!&ldquo;):</p>

<pre>
* Rebuilt URL to: https://localhost:4443/
* Hostname was NOT found in DNS cache
  % Total    % Received % Xferd  Average Speed   Time    Time     Time  Current
                                 Dload  Upload   Total   Spent    Left  Speed
  0     0    0     0    0     0      0      0 --:--:-- --:--:-- --:--:--     0*   Trying 127.0.0.1...
* Connected to localhost (127.0.0.1) port 4443 (#0)
* successfully set certificate verify locations:
*   CAfile: certs.pem
  CApath: /etc/ssl/certs
* SSLv3, TLS handshake, Client hello (1):
} [data not shown]
* SSLv3, TLS handshake, Server hello (2):
{ [data not shown]
* SSLv3, TLS handshake, CERT (11):
{ [data not shown]
* SSLv3, TLS handshake, Server key exchange (12):
{ [data not shown]
* SSLv3, TLS handshake, Server finished (14):
{ [data not shown]
* SSLv3, TLS handshake, Client key exchange (16):
} [data not shown]
* SSLv3, TLS change cipher, Client hello (1):
} [data not shown]
* SSLv3, TLS handshake, Finished (20):
} [data not shown]
* SSLv3, TLS change cipher, Client hello (1):
{ [data not shown]
* SSLv3, TLS handshake, Finished (20):
{ [data not shown]
* SSL connection using ECDHE-RSA-AES128-GCM-SHA256
* Server certificate:
*        subject: C=CZ; ST=Some-State; L=Kocourkov; O=Mestska garda; CN=localhost
*        start date: 2019-02-16 20:14:12 GMT
*        expire date: 2029-02-13 20:14:12 GMT
*        common name: localhost (matched)
*        issuer: C=CZ; ST=Some-State; L=Kocourkov; O=Mestska garda; CN=localhost
*        SSL certificate verify ok.
&gt; GET / HTTP/1.1
&gt; User-Agent: curl/7.35.0
&gt; Host: localhost:4443
&gt; Accept: */*
&gt; 
&lt; HTTP/1.1 200 OK
&lt; Content-Type: text/plain
&lt; Date: Sat, 16 Feb 2019 20:20:29 GMT
&lt; Content-Length: 13
&lt; 
{ [data not shown]
100    13  100    13    0     0   1106      0 --:--:-- --:--:-- --:--:--  1181
* Connection #0 to host localhost left intact
Hello world!
</pre>

<p>Vidíme, že certifikát byl skutečně použit.</p>

<p>Pokud se používá webový prohlížeč s&nbsp;GUI, bývá práce s&nbsp;certifikáty
snazší:</p>

<a href="https://www.root.cz/obrazek/353546/"><img src="https://i.iinfo.cz/images/552/golang-12-1-prev.png" class="image-353546" alt="&#160;" width="272" height="270" /></a>
<p><i>Obrázek 4: Informace o certifikátu při prvním přístupu k&nbsp;našemu serveru. Certifikát jsme si podepsali sami a nebyl potvrzen žádnou certifikační autoritou.</i></p>

<a href="https://www.root.cz/obrazek/353547/"><img src="https://i.iinfo.cz/images/552/golang-12-2-prev.png" class="image-353547" alt="&#160;" width="231" height="270" /></a>
<p><i>Obrázek 5: Zobrazení dalších informací o certifikátu &ndash; tyto informace jsme zadali při jeho vytváření.</i></p>

<p>Po potvrzení, že certifikátu důvěřujeme, se již zobrazí kýžená webová
stránka.</p>



<p><a name="k06"></a></p>
<h2 id="k06">6. Použití frameworku Flask a Connexion při tvorbě služeb s&nbsp;REST API v&nbsp;Pythonu</h2>

<p>Ve druhé části dnešního článku o mikroslužbách si ukážeme, jakým způsobem je
možné vyvinout jednoduchou (mikro)službu s&nbsp;rozhraním REST API, tentokrát
však nikoli v&nbsp;jazyku Go, ale v&nbsp;Pythonu. Zatímco v&nbsp;případě
programovacího jazyka Go byl ukázán spíše nízkoúrovňový přístup, v&nbsp;němž
jsme jednotlivé koncové body registrovali ručně (a vlastně jsme vůbec neřešili
případ, kdy je část cesty v&nbsp;URL proměnná, což je v&nbsp;REST API časté),
v&nbsp;Pythonu použijeme frameworky pojmenované <strong>Flask</strong> a
<strong>Connexion</strong>, které umožňují, aby celé REST API bylo deklarativně
popsáno v&nbsp;samostatném souboru <strong>swagger.yaml</strong>. V&nbsp;tomto
souboru mohou být uvedeny všechny důležité metainformace o REST API, včetně
jmen funkcí, které implementují jednotlivé handlery požadavků.</p>

<p>To však není zdaleka vše, protože framework <strong>Connexion</strong>
umožňuje, aby služba obsahovala i automaticky generované webové uživatelské
rozhraní s&nbsp;popisem všech koncových bodů, které je možné z&nbsp;tohoto
rozhraní přímo volat. Nemusíme se tedy spoléhat na externí utilitu
<strong>curl</strong>, protože samotná služba obsahuje vše potřebné pro své
vlastní otestování.</p>

<a href="https://www.root.cz/obrazek/365491/"><img src="https://i.iinfo.cz/images/598/microservices6-3-prev.png" class="image-365491" alt="&#160;" width="370" height="193" /></a>
<p><i>Obrázek 6: Editor souborů s&nbsp;popisem REST API.</i></p>

<p><div class="rs-tip-major">Poznámka: samotný soubor
<strong>swagger.yaml</strong> s&nbsp;popisem REST API, včetně všech potřebných
metainformací, můžeme pochopitelně vytvořit v&nbsp;jakémkoli textovém editoru.
Existují ovšem i specializované webové nástroje, které tuto činnost mohou
zjednodušit, zejména pro ty uživatele, kteří formát YAML ani specifikaci
OpenAPI příliš neznají nebo s&nbsp;ní teprve začínají pracovat. Jedním
z&nbsp;těchto nástrojů je <a
href="https://editor.swagger.io/">https://editor.swagger.io/</a>, v&nbsp;němž
je možné vytvořit popis REST API a následně si nechat vygenerovat kostru celé
aplikace ve zvoleném programovacím jazyce.</div></p>



<p><a name="k07"></a></p>
<h2 id="k07">7. Nejjednodušší aplikace založená pouze na frameworku Flask</h2>

<p>S&nbsp;využitím frameworku Flask je vytvoření jednoduché webové aplikace
(služby) s&nbsp;malým množstvím koncových bodů velmi snadné. Ostatně se stačí
podívat na následující příklad, který po svém spuštění inicializuje HTTP
server, který po poslání požadavku na koncový bod / vrátí odpověď s&nbsp;textem
&bdquo;Hello, world!&ldquo;. Povšimněte si, jakým způsobem je s&nbsp;využitím
dekorátoru určena vazba mezi koncovým bodem a handlerem (funkcí zavolanou při
příchodu požadavku). Samotný handler v&nbsp;tom nejjednodušším případě pouze
vrátí řetězec, který je považován za tělo odpovědi (HTTP kód bude 200 OK):</p>

<pre>
from flask import Flask
&nbsp;
app = Flask(__name__)
&nbsp;
@app.route('/')
def <strong>hello_world</strong>():
    return 'Hello, World!\n'
</pre>

<pre>
export FLASK_APP=01_basic_app.py
PYTHONDONTWRITEBYTECODE=1 python3 -m flask run
</pre>

<p><div class="rs-tip-major">Poznámka: jedná se skutečně o to nejjednodušší
možné řešení, v&nbsp;němž například vůbec nerozdělujeme aplikaci podle vzoru
MVC. U větších aplikací je to většinou nutné, u malých mikroslužeb teoreticky
ne, ovšem MVC je i v&nbsp;této oblasti dobrým návrhovým vzorem.</div></p>



<p><a name="k08"></a></p>
<h2 id="k08">8. Specifikace API s&nbsp;využitím Swaggeru</h2>

<p>V&nbsp;předchozím textu jsme se zmínili o tom, že popis celého rozhraní REST
API je uložen v&nbsp;souborech se jménem <strong>swagger.yaml</strong>.
Koncovka <strong>.yaml</strong> je pochopitelná, protože se používá formát YAML
(<a href="https://yaml.org/">YAML Ain't Markup Language</a>). Ovšem proč se
soubor jmenuje <strong>swagger</strong>? Původně se totiž popis REST API
v&nbsp;tomto formátu objevil ve frameworku <a
href="https://swagger.io/">Swagger</a>, takže se pro něj vžilo označení
&bdquo;Swagger Specification&ldquo;. Ovšem samotný formát metadat
s&nbsp;popisem REST API se později přejmenoval ze &bdquo;Swagger
Specification&ldquo; na &bdquo;OpenAPI Specification&ldquo;; současně se o
vývoj tohoto formátu a nástrojů okolo něho postavených začala starat <i>OpenAPI
Initiative</i>. Bližší informace o OpenAPI je možné nalézt na stránce <a
href="https://swagger.io/specification/">https://swagger.io/specification/</a>,
popř.&nbsp;pro verzi 2.0 přímo na GitHubu na adrese <a
href="https://github.com/OAI/OpenAPI-Specification/blob/master/versions/2.0.md">https://github.com/OAI/OpenAPI-Specification/blob/master/versions/2.0.md</a>.
Základní informace a seznam dalších informačních zdrojů je uveden i na
Wikipedii, konkrétně na stránce <a
href="https://en.wikipedia.org/wiki/OpenAPI_Specification">https://en.wikipedia.org/wiki/OpenAPI_Specification</a>.
Dnes existuje velké množství nástrojů pro generování a editaci popisu REST API,
pro vytvoření serveru či klienta na základě tohoto popisu apod. Seznam těchto
nástrojů je dostupný na stránkách <a
href="https://github.com/OAI/OpenAPI-Specification/blob/master/IMPLEMENTATIONS.md#implementations">https://github.com/OAI/OpenAPI-Specification/blob/master/IMPLEMENTATIONS.md#implementations</a>
a <a
href="https://github.com/APIs-guru/awesome-openapi3">https://github.com/APIs-guru/awesome-openapi3</a>.</p>

<p><div class="rs-tip-major">Poznámka: v&nbsp;dále popsaných demonstračních
příkladech budeme používat OpenAPI 2.0, která se od novější specifikace OpenAPI
3.0 v&nbsp;některých maličkostech odlišuje. Týká se to zejména popisu dat,
která mohou být přenesena v&nbsp;těle požadavku (<i>request body</i>). Tento
popis použijeme ve třetím a čtvrtém demonstračním příkladu (první dva příklady
by měly být nezávislé na verzi OpenAPI).</div></p>



<p><a name="k09"></a></p>
<h2 id="k09">9. Kostra služby</h2>

<p>Nyní si ukážeme kostru webové služby vytvořenou s&nbsp;využitím frameworků
<i>Flask</i> a taktéž <i>Connexion</i>. Druhý z&nbsp;těchto frameworků
mj.&nbsp;poslouží pro zobrazení webové stránky, přes kterou bude možné webovou
službu ovládat. Kostra celé služby obsahuje jen minimum souborů a má
jednoduchou strukturu:</p>

<pre>
├── requirements.in
├── requirements.txt
├── run.sh
├── service1.py
├── setup.cfg
└── swagger
    └── swagger.yaml
</pre>

<p>Význam jednotlivých souborů:</p>

<table>
<tr><th>Soubor</th><th>Stručný popis</th></tr>
<tr><td>requirements.in</td><td>seznam balíčků, na kterých služba závisí</td></tr>
<tr><td>requirements.txt</td><td>balíčky i s&nbsp;uvedením verze (automaticky generováno z&nbsp;předchozího souboru)</td></tr>
<tr><td>run.sh</td><td>skript pro spuštění služby</td></tr>
<tr><td>service1.py</td><td>vlastní implementace webové služby</td></tr>
<tr><td>setup.cfg</td><td>pomocný soubor s&nbsp;konfigurací používaný různými nástroji pro Python</td></tr>
<tr><td>swagger/swagger.yaml</td><td>metainformace o REST API</td></tr>
</table>

<p>Obsah souboru <strong>requirements.in</strong> se seznamem balíčků, na
kterých služba závisí:</p>

<pre>
connexion
jsonschema
</pre>

<p>Obsah souboru <strong>requirements.txt</strong> obsahujícího balíčky i
s&nbsp;uvedením verze (automaticky generováno z&nbsp;předchozího souboru):</p>

<pre>
connexion==1.1.15
jsonschema==2.5.1
</pre>

<p>Skript pro inicializaci virtuálního prostředí Pythonu a spuštění webové
služby:</p>

<pre>
#!/bin/bash -ex
&nbsp;
export NOVENV=0
function prepare_venv() {
    virtualenv -p python3 venv &amp;&amp; source venv/bin/activate &amp;&amp; python3 "$(which pip3)" install -r requirements.txt
}
&nbsp;
[ "$NOVENV" == "1" ] || prepare_venv || exit 1
&nbsp;
PYTHONDONTWRITEBYTECODE=1 python3 service1.py
</pre>



<p><a name="k10"></a></p>
<h2 id="k10">10. První služba naprogramovaná v&nbsp;Pythonu</h2>

<p>Implementace webové služby (prozatím bez koncových bodů) vypadá následovně.
Můžeme v&nbsp;něm vidět pouze inicializaci serveru, předání adresáře
obsahujícího soubor <strong>swagger.yaml</strong> a spuštění serveru na portu
8080:</p>

<pre>
#!/usr/bin/env python3
&nbsp;
import connexion
&nbsp;
&nbsp;
def <strong>main</strong>():
    """Start the Flask app."""
    app = connexion.App(__name__, specification_dir='./swagger/')
    app.add_api('swagger.yaml', arguments={'title': 'Service 1'})
    app.run(port=8080)
&nbsp;
&nbsp;
if __name__ == '__main__':
    main()
</pre>

<p>Mnohem zajímavější jsou metainformace o REST API. Ty jsou zapsány
v&nbsp;souboru s&nbsp;formátem YAML, v&nbsp;němž se jednotlivé poduzly
specifikují odsazením a dvojtečkou, podobně jako v&nbsp;Pythonu. Povšimněte si,
že používáme specifikaci OpenAPI verze 2.0:</p>

<pre>
---
swagger: "2.0"
info:
  description: "Simple REST API service."
  version: "1.0.0"
  title: "Service 1"
  contact:
    email: "tisnik@somewhere.else"
  license:
    name: "Apache 2.0"
    url: "http://www.apache.org/licenses/LICENSE-2.0.html"
basePath: "/api/v1"
tags:
- name: "Service settings"
  description: "The service settings"
schemes:
- "https"
- "http"
paths: {}
definitions: {}
externalDocs:
  description: "Find out more about Swagger"
  url: "http://swagger.io"
</pre>

<p>První demonstrační příklad založený na frameworku <i>Flask</i> a
<i>Connexion</i> spustíme přes skript <strong>run.sh</strong>. Tento skript
nejdříve připraví virtuální prostředí Pythonu a následně inicializuje server.
Na posledním řádku je informace o portu, na kterém server naslouchá požadavkům
od klientů:</p>

<pre>
$ <strong>./run.sh</strong>
&nbsp;
+ python3 service1.py
 * Serving Flask app "service1" (lazy loading)
 * Environment: production
   WARNING: This is a development server. Do not use it in a production deployment.
   Use a production WSGI server instead.
 * Debug mode: off
 * Running on http://0.0.0.0:8080/ (Press CTRL+C to quit)
</pre>

<p>Po spuštění prvního demonstračního příkladu si můžeme vyzkoušet, zda služba
skutečně přijímá požadavky. Prozatím sice nemáme žádné koncové body REST API,
ovšem minimálně by mělo být možné získat popis REST API, tentokrát pro změnu ve
formátu JSON:</p>

<pre>
$ <strong>curl http://localhost:8080/api/v1/swagger.json</strong>
</pre>

<p>Výsledkem předchozího volání by měla být odpověď s&nbsp;nenaformátovaným
JSONem:</p>

<pre>
{"basePath":"/api/v1","definitions":{},"externalDocs":{"description":"Find out more about Swagger","url":"http://swagger.io"},"info":{"contact":{"email":"tisnik@somewhere.else"},"description":"Simple REST API service.","license":{"name":"Apache 2.0","url":"http://www.apache.org/licenses/LICENSE-2.0.html"},"title":"Service 1","version":"1.0.0"},"paths":{},"schemes":["https","http"],"swagger":"2.0","tags":[{"description":"The service settings","name":"Service settings"}]}
</pre>

<p>Po naformátování:</p>

<pre>
{
  "basePath": "/api/v1",
  "definitions": {
    
  },
  "externalDocs": {
    "description": "Find out more about Swagger",
    "url": "http://swagger.io"
  },
  "info": {
    "contact": {
      "email": "tisnik@somewhere.else"
    },
    "description": "Simple REST API service.",
    "license": {
      "name": "Apache 2.0",
      "url": "http://www.apache.org/licenses/LICENSE-2.0.html"
    },
    "title": "Service 1",
    "version": "1.0.0"
  },
  "paths": {
    
  },
  "schemes": [
    "https",
    "http"
  ],
  "swagger": "2.0",
  "tags": [
    {
      "description": "The service settings",
      "name": "Service settings"
    }
  ]
}
</pre>

<p>Samozřejmě se můžeme podívat i na všechny hlavičky posílané klientem na
server i serverem zpět na klienta:</p>

<pre>
$ <strong>curl -v http://localhost:8080/api/v1/swagger.json</strong>
</pre>

<p>Směr komunikace se pozná podle prefixů jednotlivých řádků. Požadavek klienta
začíná znakem &gt;, odpověď serveru naopak znakem &lt;:</p>

<pre>
*   Trying ::1...
* TCP_NODELAY set
* connect to ::1 port 8080 failed: Connection refused
*   Trying 127.0.0.1...
* TCP_NODELAY set
* Connected to localhost (127.0.0.1) port 8080 (#0)
&gt; GET /api/v1/swagger.json HTTP/1.1
&gt; Host: localhost:8080
&gt; User-Agent: curl/7.53.1
&gt; Accept: */*
&gt; 
* HTTP 1.0, assume close after body
&lt; HTTP/1.0 200 OK
&lt; Content-Type: application/json
&lt; Content-Length: 475
&lt; Server: Werkzeug/0.15.4 Python/3.6.3
&lt; Date: Wed, 10 Jul 2019 12:03:07 GMT
&lt; 
{"basePath":"/api/v1","definitions":{},"externalDocs":{"description":"Find out more about Swagger","url":"http://swagger.io"},"info":{"contact":{"email":"tisnik@somewhere.else"},"description":"Simple REST API service.","license":{"name":"Apache 2.0","url":"http://www.apache.org/licenses/LICENSE-2.0.html"},"title":"Service 1","version":"1.0.0"},"paths":{},"schemes":["https","http"],"swagger":"2.0","tags":[{"description":"The service settings","name":"Service settings"}]}
* Closing connection 0
</pre>

<img src="https://i.iinfo.cz/images/598/microservices6-4.png" class="image-365492" alt="&#160;" width="538" height="540" />
<p><i>Obrázek 7: Zobrazení popisu služby přímo v&nbsp;prohlížeči.</i></p>



<p><a name="k11"></a></p>
<h2 id="k11">11. Přidání dvou koncových bodů do specifikace služby</h2>

<p>Nyní do webové služby přidáme dva koncové body <strong>/liveness</strong> a
<strong>/readiness</strong>. Povšimněte si, že vazba na handlery (konkrétní
funkce zapsané plným jménem) je provedena přímo v&nbsp;souboru
<strong>swagger.yaml</strong> a nikoli ve zdrojovém kódu aplikace:</p>

<pre>
  /liveness:
    get:
      tags: [Service settings]
      operationId: "service2.get_liveness"
      summary: "Get service liveness"
      responses:
        200:
          description: Service is alive
  /readiness:
    get:
      tags: [Service settings]
      operationId: "service2.get_readiness"
      summary: "Get service readiness"
      responses:
        200:
          description: Service is ready
</pre>

<p>Úplný obsah souboru <strong>swagger.yaml</strong> vypadá následovně:</p>

<pre>
---
swagger: "2.0"
info:
  description: "Simple REST API service."
  version: "1.0.0"
  title: "Service 2"
  contact:
    email: "tisnik@somewhere.else"
  license:
    name: "Apache 2.0"
    url: "http://www.apache.org/licenses/LICENSE-2.0.html"
basePath: "/api/v1"
tags:
- name: "Service settings"
  description: "The service settings"
schemes:
- "https"
- "http"
paths:
  /liveness:
    get:
      tags: [Service settings]
      operationId: "service2.get_liveness"
      summary: "Get service liveness"
      responses:
        200:
          description: Service is alive
  /readiness:
    get:
      tags: [Service settings]
      operationId: "service2.get_readiness"
      summary: "Get service readiness"
      responses:
        200:
          description: Service is ready
definitions: {}
externalDocs:
  description: "Find out more about Swagger"
  url: "http://swagger.io"
</pre>



<p><a name="k12"></a></p>
<h2 id="k12">12. Implementace <i>handlerů</i> nových koncových bodů</h2>

<p>Samotná implementace obou handlerů (umístěná ve zdrojovém souboru
<strong>service2.py</strong>) je přímočará, protože ve skutečnosti vrátíme
prázdnou strukturu (objekt) a stavový kód HTTP bude za všech okolností 200
OK:</p>

<pre>
def <strong>health_check</strong>():
    """Check the health status of the service."""
    return {}, 200
&nbsp;
&nbsp;
def <strong>get_readiness</strong>():
    """Get service readiness status."""
    return health_check()
&nbsp;
&nbsp;
def <strong>get_liveness</strong>():
    """Get service liveness status."""
    return health_check()
</pre>

<p><div class="rs-tip-major">Poznámka: povšimněte si, že se jedná o běžné
funkce, které dokonce ani nemusí obsahovat žádný dekorátor.</div></p>

<p>Úplný zdrojový kód druhého příkladu vytvořeného v&nbsp;Pythonu vypadá
následovně:</p>

<pre>
#!/usr/bin/env python3
&nbsp;
import connexion
&nbsp;
def <strong>health_check</strong>():
    """Check the health status of the service."""
    return {}, 200
&nbsp;
&nbsp;
def <strong>get_readiness</strong>():
    """Get service readiness status."""
    return health_check()
&nbsp;
&nbsp;
def <strong>get_liveness</strong>():
    """Get service liveness status."""
    return health_check()
&nbsp;
&nbsp;
def <strong>main</strong>():
    """Start the Flask app."""
    app = connexion.App(__name__, specification_dir='./swagger/')
    app.add_api('swagger.yaml', arguments={'title': 'Service 2'})
    app.run(port=8080)
&nbsp;
&nbsp;
if __name__ == '__main__':
    main()
</pre>



<p><a name="k13"></a></p>
<h2 id="k13">13. Otestování druhé varianty služby pomocí Swagger UI i nástroje <strong>curl</strong></h2>

<p>Druhý demonstrační příklad již svým uživatelům (tedy klientům) nabízí dva
koncové body <strong>/api/v1/liveness</strong> a
<strong>/api/v1/readiness</strong>. Tyto koncové body by měly vracet prázdnou
strukturu ve formátu JSON a stavový kód HTTP odpovědi by měl být 200 OK,
tj.&nbsp;informace o tom, že požadavek byl korektní a server ho správně
zpracoval:</p>

<pre>
$ <strong>curl http://localhost:8080/api/v1/liveness</strong>
{}
</pre>

<p>I druhý koncový bod by se měl chovat naprosto stejným způsobem:</p>

<pre>
$ <strong>curl http://localhost:8080/api/v1/readiness</strong>
{}
</pre>

<p>Můžeme se pochopitelně přesvědčit i o HTTP stavovém kódu HTTP odpovědi (viz
též <a
href="https://en.wikipedia.org/wiki/List_of_HTTP_status_codes">https://en.wikipedia.org/wiki/List_of_HTTP_status_codes</a>).
Pro zobrazení celé odpovědi, samozřejmě včetně HTTP kódu, použijeme přepínač
<strong>-v</strong>:</p>

<pre>
$ <strong>curl -v http://localhost:8080/api/v1/liveness</strong>
&nbsp;
*   Trying ::1...
* TCP_NODELAY set
* connect to ::1 port 8080 failed: Connection refused
*   Trying 127.0.0.1...
* TCP_NODELAY set
* Connected to localhost (127.0.0.1) port 8080 (#0)
&gt; GET /api/v1/liveness HTTP/1.1
&gt; Host: localhost:8080
&gt; User-Agent: curl/7.53.1
&gt; Accept: */*
&gt; 
* HTTP 1.0, assume close after body
&lt; HTTP/1.0 200 OK
&lt; Content-Type: application/json
&lt; Content-Length: 3
&lt; Server: Werkzeug/0.15.4 Python/3.6.3
&lt; Date: Wed, 10 Jul 2019 12:56:16 GMT
&lt; 
{}
* Closing connection 0
</pre>

<p>Zajímavější ovšem bude přesměrovat webový prohlížeč na adresu
<strong>/api/v1/ui</strong>. Na této adrese se nachází dynamicky generovaná
HTML stránka obsahující jak popis REST API (všech koncových bodů), tak i
nástroje, které nám umožní tyto body zavolat:</p>

<a href="https://www.root.cz/obrazek/365493/"><img src="https://i.iinfo.cz/images/598/microservices6-5-prev.png" class="image-365493" alt="&#160;" width="370" height="162" /></a>
<p><i>Obrázek 8: Popis služby se zobrazením koncových bodů.</i></p>

<a href="https://www.root.cz/obrazek/365494/"><img src="https://i.iinfo.cz/images/598/microservices6-6-prev.png" class="image-365494" alt="&#160;" width="370" height="226" /></a>
<p><i>Obrázek 9: Zobrazení podrobnějších informací o vybraném koncovém bodu.</i></p>

<a href="https://www.root.cz/obrazek/365495/"><img src="https://i.iinfo.cz/images/598/microservices6-7-prev.png" class="image-365495" alt="&#160;" width="370" height="265" /></a>
<p><i>Obrázek 10: Otestování koncového bodu přímo z&nbsp;prohlížeče.</i></p>



<p><a name="k14"></a></p>
<h2 id="k14">14. Vylepšení služby &ndash; koncový bod pro poslání zprávy</h2>

<p>Webovou službu ještě vylepšíme, a to přidáním koncového bodu sloužícího pro
poslání zprávy vybranému uživateli (ve skutečnosti se zpráva nikam nepošle,
ovšem koncový bod bude existovat). Přitom bude služba kontrolovat, zda zadaný
uživatel existuje a zda mu lze poslat zprávu. Jedná se o komplikaci služby,
protože budeme muset:</p>

<ol>
<li>Přečíst parametr (jméno uživatele) předaného přes URL</li>
<li>Přečíst tělo požadavku, protože bude obsahovat text zprávy</li>
<li>Zkontrolovat oba parametry a v&nbsp;případě chyby vrátit vhodný stavový kód HTTP</li>
<li>Zkontrolovat existenci příjemce, opět s&nbsp;navrácením vhodného stavového kódu</li>
<li>Zkontrolovat, jestli příjemce může zprávy přijímat</li>
</ol>



<p><a name="k15"></a></p>
<h2 id="k15">15. Specifikace nového koncového bodu s&nbsp;určením parametrů</h2>

<p>Nový koncový bod je nakonfigurován následujícím způsobem:</p>

<pre>
  /message/{recipient}:
    post:
      tags: [Basic operations]
      operationId: "service3.send_message"
      summary: "Post a message"
      consumes:
      - "text/plain"
      produces:
      - "application/json"
      parameters:
      - name: "recipient"
        in: "path"
        description: "The recipient for the message"
        required: true
        type: "string"
      - name: "message"
        in: body
        description: "Message body"
        required: true
        schema:
          type: string
      responses:
        200:
          description: "Successful operation"
        400:
          description: "Invalid recipient supplied"
        404:
          description: "The specified recipient was not found"
        405:
          description: "Not allowed - it is not allowed to send the message to selected recipient"
        500:
          description: "Any other failure"
</pre>

<p>Povšimněte si, jak vypadá specifikace parametru předaného přes URL (ve
skutečnosti se nejedná o skutečný parametr, ale o součást URL). Dále je
specifikováno, že se v&nbsp;těle požadavku očekává běžný text (<i>plain
text</i>), zatímco v&nbsp;těle odpovědi bude JSON. Oba parametry (příjemce,
text zprávy) jsou dále podrobněji popsány a dokonce je pro uživatele REST API
specifikováno, které HTTP kódy může odpověď obsahovat a co přesně
v&nbsp;kontextu tohoto koncového bodu znamenají.</p>



<p><a name="k16"></a></p>
<h2 id="k16">16. Demonstrační implementace nového koncového bodu a otestování služby</h2>

<p>Do zdrojového kódu příkladu přidáme novou funkci, které se při jejím
zavolání <i>automaticky</i> předají oba parametry popsané v&nbsp;souboru
<strong>swagger.yaml</strong>. Kromě toho vytvoříme dvojici n-tic se seznamem
všech příjemců i se seznamem příjemců, kterým je dovoleno zprávy posílat:</p>

<pre>
KNOWN_RECIPIENTS = ("Puchmajer", "Meyer", "Pihrt", "Jason", "Drson", "Trachta", "Fristensky")
ALLOWED_RECIPIENTS = ("Jason", "Drson", "Trachta", "Fristensky")
&nbsp;
&nbsp;
def <strong>send_message</strong>(recipient, message):
    """Send a message to selected recipient."""
    if not recipient:
        return {"Status": "error",
                "Reason": "No recipient supplied"}, 400
&nbsp;
    if not message:
        return {"Status": "error",
                "Reason": "Message is empty"}, 400
&nbsp;
    if recipient not in KNOWN_RECIPIENTS:
        return {"Status": "not found",
                "Reason": "The specified recipient was not found"}, 404
&nbsp;
    if recipient not in ALLOWED_RECIPIENTS:
        return {"Status": "forbidden",
                "Reason": "Not allowed - it is not allowed to send the message to selected recipient"}, 405
&nbsp;
    try:
        # kod pro skutecne poslani zpravy
        return {"Status": "ok"}, 200
    except Exception as e:
        return {"Status": "error", "Reason": str(e)}, 500
</pre>

<p>Přístup ke koncovým bodům, ke kterým se přistupuje metodou POST, PUT či
DELETE, je nepatrně složitější, než je tomu u metody GET. Použitou metodu totiž
musíme specifikovat, a to přepínačem <strong>-X metoda</strong>. První pokus by
tedy mohl vypadat následovně:</p>

<pre>
$ <strong>curl -X POST http://localhost:8080/api/v1/message/Drson</strong>
</pre>

<p>V&nbsp;tomto případě ovšem server (zcela podle očekávání) odpoví, že nebylo
specifikováno tělo požadavku, v&nbsp;němž měla být uložena zpráva:</p>

<pre>
{
  "Reason": "Message is empty",
  "Status": "error"
}
</pre>

<p>Celý požadavek je tedy nutné strukturovat odlišně. Nejdříve nastavíme typ
dat v&nbsp;požadavku:</p>

<pre>
--header 'Content-Type: text/plain'
</pre>

<p>Následně (což ovšem není v&nbsp;tomto případě povinné) určíme, v&nbsp;jakém
formátu očekáváme odpověď:</p>

<pre>
--header 'Accept: application/json'
</pre>

<p>Samotné tělo požadavku s&nbsp;textem zprávy se specifikuje přepínačem
<strong>-d</strong> (ovšem musíme si dát pozor na to, aby nezačínalo
zavináčem):</p>

<pre>
-d 'Transfer Of Usd $21,500.000{Twenty - One Million, Five Hundred Thousand Us Dollars Only. I am a member of the Federal Government Of Nigerian National Petroleum Corporation (N.N.P.C). Sometime ago, a contract was awarded to a foreign firm in the Petroleum Trust Fund (P.T.F.) BY MY COMMITTEE'
</pre>

<p>Celé volání nástroje <strong>curl</strong> tedy může vypadat následovně:</p>

<pre>
$ <strong>curl -X POST --header 'Content-Type: text/plain' --header 'Accept: application/json' -d 'Transfer Of Usd $21,500.000{Twenty - One Million, Five Hundred Thousand Us Dollars Only. I am a member of the Federal Government Of Nigerian National Petroleum Corporation (N.N.P.C). Sometime ago, a contract was awarded to a foreign firm in the Petroleum Trust Fund (P.T.F.) BY MY COMMITTEE' 'http://localhost:8080/api/v1/message/Drson'</strong>
</pre>

<p>S&nbsp;výsledkem:</p>

<pre>
{
  "Status": "ok"
}
</pre>

<p><div class="rs-tip-major">Poznámka: zavináč na začátku zprávy způsobí
problémy, protože nástroj <strong>curl</strong> v&nbsp;tomto případě očekává,
že se bude jednat o jméno souboru s&nbsp;daty, které se mají poslat.</div></p>



<p><a name="k17"></a></p>
<h2 id="k17">17. Poslání zprávy přímo přes Swagger UI</h2>

<p>Zprávu samozřejmě můžeme poslat i přes UI. Postup je následující:</p>

<a href="https://www.root.cz/obrazek/365496/"><img src="https://i.iinfo.cz/images/598/microservices6-8-prev.png" class="image-365496" alt="&#160;" width="370" height="153" /></a>
<p><i>Obrázek 11: Popis třetí varianty webové služby.</i></p>

<a href="https://www.root.cz/obrazek/365497/"><img src="https://i.iinfo.cz/images/598/microservices6-9-prev.png" class="image-365497" alt="&#160;" width="309" height="270" /></a>
<p><i>Obrázek 12: Popis koncového bodu <strong>/message</strong>.</i></p>

<a href="https://www.root.cz/obrazek/365498/"><img src="https://i.iinfo.cz/images/598/microservices6-10-prev.png" class="image-365498" alt="&#160;" width="309" height="270" /></a>
<p><i>Obrázek 13: Oba parametry jsou povinné a je je nutné vyplnit.</i></p>

<a href="https://www.root.cz/obrazek/365499/"><img src="https://i.iinfo.cz/images/598/microservices6-11-prev.png" class="image-365499" alt="&#160;" width="285" height="270" /></a>
<p><i>Obrázek 14: Pokus o poslání zprávy neznámému příjemci.</i></p>

<a href="https://www.root.cz/obrazek/365500/"><img src="https://i.iinfo.cz/images/598/microservices6-12-prev.png" class="image-365500" alt="&#160;" width="293" height="270" /></a>
<p><i>Obrázek 15: Úspěšné doručení zprávy.</i></p>



<p><a name="k18"></a></p>
<h2 id="k18">18. Čtvrtá varianta služby s&nbsp;koncovým bodem vracejícím data ve formátu JSON</h2>

<p>Jen pro úplnost si demonstrační příklad rozšíříme o další koncový bod, který
bude sloužit pro získání statistiky o tom, kolik zpráv bylo jednotlivým
příjemcům prozatím posláno. Při poslání zprávy se informace o příjemci
zaznamená:</p>

<pre>
counter = Counter()
&nbsp;
&nbsp;
&nbsp;
def <strong>send_message</strong>(recipient, message):
    """Send a message to selected recipient."""
    if not recipient:
        return {"Status": "error",
                "Reason": "No recipient supplied"}, 400
&nbsp;
    if not message:
        return {"Status": "error",
                "Reason": "Message is empty"}, 400
&nbsp;
    if recipient not in KNOWN_RECIPIENTS:
        return {"Status": "not found",
                "Reason": "The specified recipient was not found"}, 404
&nbsp;
    if recipient not in ALLOWED_RECIPIENTS:
        return {"Status": "forbidden",
                "Reason": "Not allowed - it is not allowed to send the message to selected recipient"}, 405
&nbsp;
    try:
        # kod pro skutecne poslani zpravy
        counter[recipient] += 1
        return {"Status": "ok"}, 200
    except Exception as e:
        return {"Status": "error", "Reason": str(e)}, 500
</pre>

<p>Implementace logiky nového koncového bodu je v&nbsp;tomto případě opět
přímočará:</p>

<pre>
def <strong>message_statistic</strong>():
    """Returns message statistic."""
    return counter
</pre>

<p>Nový koncový bod samozřejmě budeme muset zaregistrovat a popsat:</p>

<pre>
---
swagger: "2.0"
info:
  description: "Simple REST API service."
  version: "1.0.0"
  title: "Service 4"
  contact:
    email: "tisnik@somewhere.else"
  license:
    name: "Apache 2.0"
    url: "http://www.apache.org/licenses/LICENSE-2.0.html"
basePath: "/api/v1"
tags:
- name: "Basic operations"
  description: "Basic operations"
- name: "Service settings"
  description: "The service settings"
schemes:
- "https"
- "http"
paths:
  /liveness:
    get:
      tags: [Service settings]
      operationId: "service4.get_liveness"
      summary: "Get service liveness"
      responses:
        200:
          description: Service is alive
  /readiness:
    get:
      tags: [Service settings]
      operationId: "service4.get_readiness"
      summary: "Get service readiness"
      responses:
        200:
          description: Service is ready
  /message_statistic:
    get:
      tags: [Basic operations]
      operationId: "service4.message_statistic"
      summary: "Returns basic statistic about sent messages"
      responses:
        200:
          description: Query was successful
      produces:
      - "application/json"
  /message/{recipient}:
    post:
      tags: [Basic operations]
      operationId: "service4.send_message"
      summary: "Post a message"
      consumes:
      - "text/plain"
      produces:
      - "application/json"
      parameters:
      - name: "recipient"
        in: "path"
        description: "The recipient for the message"
        required: true
        type: "string"
      - name: "message"
        in: body
        description: "Message body"
        required: true
        schema:
          type: string
      responses:
        200:
          description: "Successful operation"
        400:
          description: "Invalid recipient supplied"
        404:
          description: "The specified recipient was not found"
        405:
          description: "Not allowed - it is not allowed to send the message to selected recipient"
        500:
          description: "Any other failure"
definitions: {}
externalDocs:
  description: "Find out more about Swagger"
  url: "http://swagger.io"
</pre>

<p>Nyní si můžeme službu spustit, poslat několik zpráv a následně si zobrazit
statistiku:</p>

<pre>
$ <strong>curl http://localhost:8080/api/v1/message_statistic</strong>
</pre>

<p>S&nbsp;výsledkem:</p>

<pre>
{
  "Drson": 1,
  "Jason": 3
}
</pre>

<p>Totéž lze provést přes Swagger UI:</p>

<a href="https://www.root.cz/obrazek/365501/"><img src="https://i.iinfo.cz/images/598/microservices6-13-prev.png" class="image-365501" alt="&#160;" width="328" height="270" /></a>
<p><i>Obrázek 16: Použití nového koncového bodu ze Swagger UI.</i></p>

<a href="https://www.root.cz/obrazek/365502/"><img src="https://i.iinfo.cz/images/598/microservices6-14-prev.png" class="image-365502" alt="&#160;" width="370" height="187" /></a></p>
<p><i>Obrázek 17: Swagger editor dokonce dokáže vygenerovat celou kostru
aplikace.</i></p>



<p><a name="k19"></a></p>
<h2 id="k19">19. Repositář s&nbsp;demonstračními příklady</h2>

<p>Zdrojové kódy všech dnes použitých demonstračních příkladů byly uloženy do
Git repositáře, který je dostupný na adrese <a
href="https://github.com/tisnik/microservices">https://github.com/tisnik/microservices</a>
(stále na GitHubu :-). V&nbsp;případě, že nebudete chtít klonovat celý
repositář (ten je ovšem &ndash; alespoň prozatím &ndash; velmi malý, můžete
namísto toho použít odkazy na jednotlivé příklady, které naleznete
v&nbsp;následující tabulce:</p>

<table>
<tr><th>#</th><th>Příklad</th><th>Popis příkladu</th><th>Cesta</th></tr>
<tr><td>1</td><td>service1.go</td><td>jednoduchá aplikace s&nbsp;HTTP serverem</td><td><a href="https://github.com/tisnik/microservices/blob/master/REST-API/Go/service1.go">https://github.com/tisnik/microservices/blob/master/REST-API/Go/service1.go</a></td></tr>
<tr><td>2</td><td>service2.go</td><td>použití HTTPS namísto HTTP</td><td><a href="https://github.com/tisnik/microservices/blob/master/REST-API/Go/service2.go">https://github.com/tisnik/microservices/blob/master/REST-API/Go/service2.go</a></td></tr>
<tr><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td></tr>
<tr><td>3</td><td>service1</td><td>kostra webové služby naprogramované v&nbsp;Pythonu</td><td><a href="https://github.com/tisnik/microservices/blob/master/REST-API/Python/service1">https://github.com/tisnik/microservices/blob/master/REST-API/Python/service1</a></td></tr>
<tr><td>4</td><td>service2</td><td>webová služba v&nbsp;Pythonu s&nbsp;dvojicí koncových bodů</td><td><a href="https://github.com/tisnik/microservices/blob/master/REST-API/Python/service2">https://github.com/tisnik/microservices/blob/master/REST-API/Python/service2</a></td></tr>
<tr><td>5</td><td>service3</td><td>koncový bod vyžadující metodu POST</td><td><a href="https://github.com/tisnik/microservices/blob/master/REST-API/Python/service3">https://github.com/tisnik/microservices/blob/master/REST-API/Python/service3</a></td></tr>
<tr><td>6</td><td>service4</td><td>koncový bod se statistikou posílání zpráv</td><td><a href="https://github.com/tisnik/microservices/blob/master/REST-API/Python/service4">https://github.com/tisnik/microservices/blob/master/REST-API/Python/service4</a></td></tr>
<tr><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td></tr>
<tr><td>7</td><td>webapp1</td><td>jednoduchá služba naprogramovaná v&nbsp;Clojure</td><td><a href="https://github.com/tisnik/microservices/blob/master/REST-API/Clojure/webapp1">https://github.com/tisnik/microservices/blob/master/REST-API/Clojure/webapp1</a></td></tr>
<tr><td>8</td><td>webapp2</td><td>další jednoduchá služba naprogramovaná v&nbsp;Clojure</td><td><a href="https://github.com/tisnik/microservices/blob/master/REST-API/Clojure/webapp2">https://github.com/tisnik/microservices/blob/master/REST-API/Clojure/webapp2</a></td></tr>
</table>



<p><a name="k20"></a></p>
<h2 id="k20">20. Odkazy na Internetu</h2>

<ol>

<li>OpenAPI Initiative (OAI)<br />
<a href="https://www.openapis.org/">https://www.openapis.org/</a>
</li>

<li>OpenAPI Implementations<br />
<a href="https://github.com/OAI/OpenAPI-Specification/blob/master/IMPLEMENTATIONS.md#implementations">https://github.com/OAI/OpenAPI-Specification/blob/master/IMPLEMENTATIONS.md#implementations</a>
</li>

<li>awesome-openapi3<br />
<a href="https://github.com/APIs-guru/awesome-openapi3">https://github.com/APIs-guru/awesome-openapi3</a>
</li>

<li>Swagger (software)<br />
<a href="https://en.wikipedia.org/wiki/Swagger_(software)">https://en.wikipedia.org/wiki/Swagger_(software)</a>
</li>

<li>Editor pro swagger soubory s&nbsp;popisem REST API<br />
<a href="http://editor.swagger.io/#">http://editor.swagger.io/#</a>
</li>

<li>YAML<br />
<a href="https://yaml.org/">https://yaml.org/</a>
</li>

<li>YAML na Wikipedii<br />
<a href="https://en.wikipedia.org/wiki/YAML">https://en.wikipedia.org/wiki/YAML</a>
</li>

<li>Flask na PyPi<br />
<a href="https://pypi.org/project/Flask/">https://pypi.org/project/Flask/</a>
</li>

<li>Connexion na PyPi<br />
<a href="https://pypi.org/project/connexion/">https://pypi.org/project/connexion/</a>
</li>

<li>Werkzeug na PyPi<br />
<a href="https://pypi.org/project/Werkzeug/">https://pypi.org/project/Werkzeug/</a>
</li>

<li>gdbgui 0.7.8.3: browser-based gdb frontend using Flask and JavaScript to visually debug C, C++, Go, or Rust<br />
<a href="https://pypi.python.org/pypi/gdbgui">https://pypi.python.org/pypi/gdbgui</a>
</li>

<li>Alertmanager<br />
<a href="https://prometheus.io/docs/alerting/alertmanager/">https://prometheus.io/docs/alerting/alertmanager/</a>
</li>

<li>Grafana support for Prometheus<br />
<a href="https://prometheus.io/docs/visualization/grafana/">https://prometheus.io/docs/visualization/grafana/</a>
</li>

<li>goa<br />
<a href="https://stackshare.io/goa">https://stackshare.io/goa</a>
</li>

<li>goa (GitHub)<br />
<a href="https://github.com/goadesign/goa">https://github.com/goadesign/goa</a>
</li>

<li>Grafana support for Prometheus<br />
<a href="https://prometheus.io/docs/visualization/grafana/">https://prometheus.io/docs/visualization/grafana/</a>
</li>

<li>Useful Tools for Managing Complexity of Microservice Architecture<br />
<a href="https://blog.byndyusoft.com/useful-tools-for-managing-complexity-of-microservice-architecture-109a2289acc">https://blog.byndyusoft.com/useful-tools-for-managing-complexity-of-microservice-architecture-109a2289acc</a>
</li>

<li>Three pillars of microservice culture<br />
<a href="https://www.oreilly.com/ideas/three-pillars-of-microservice-culture">https://www.oreilly.com/ideas/three-pillars-of-microservice-culture</a>
</li>

<li>Prometheus: from metrics to insight<br />
<a href="https://prometheus.io/">https://prometheus.io/</a>
</li>

<li>Docker Swarm<br />
<a href="https://docs.docker.com/swarm/">https://docs.docker.com/swarm/</a>
</li>

<li>Kubernetes: production-Grade Container Orchestration<br />
<a href="https://kubernetes.io/">https://kubernetes.io/</a>
</li>

<li>29 Top Tools for Building Microservices on All Levels<br />
<a href="https://dzone.com/articles/30top-tools-for-building-microservices-on-all-leve">https://dzone.com/articles/30top-tools-for-building-microservices-on-all-leve</a>
</li>

<li>The 8 best open-source tools for building microservice apps<br />
<a href="https://techbeacon.com/enterprise-it/8-best-open-source-tools-building-microservice-apps">https://techbeacon.com/enterprise-it/8-best-open-source-tools-building-microservice-apps</a>
</li>

<li>Consul<br />
<a href="https://www.consul.io/">https://www.consul.io/</a>
</li>

<li>Apache ZooKeeper<br />
<a href="https://zookeeper.apache.org/">https://zookeeper.apache.org/</a>
</li>

<li>ZooKeeper: Because Coordinating Distributed Systems is a Zoo<br />
<a href="http://zookeeper.apache.org/doc/current/index.html">http://zookeeper.apache.org/doc/current/index.html</a>
</li>

<li>ZooKeeper: A Distributed Coordination Service for Distributed Applications<br />
<a href="http://zookeeper.apache.org/doc/current/zookeeperOver.html">http://zookeeper.apache.org/doc/current/zookeeperOver.html</a>
</li>

<li>Understanding Kafka with Legos (video)<br />
<a href="https://www.youtube.com/watch?v=Q5wOegcVa8E">https://www.youtube.com/watch?v=Q5wOegcVa8E</a>
</li>

<li>Apache Kafka Tutorial For Beginners (video)<br />
<a href="https://www.youtube.com/watch?v=U4y2R3v9tlY">https://www.youtube.com/watch?v=U4y2R3v9tlY</a>
</li>

<li>Franz Kafka (Wikipedia)<br />
<a href="https://en.wikipedia.org/wiki/Franz_Kafka">https://en.wikipedia.org/wiki/Franz_Kafka</a>
</li>

<li>NATS<br />
<a href="https://nats.io/about/">https://nats.io/about/</a>
</li>

<li>NATS Streaming Concepts<br />
<a href="https://nats.io/documentation/streaming/nats-streaming-intro/">https://nats.io/documentation/streaming/nats-streaming-intro/</a>
</li>

<li>NATS Streaming Server<br />
<a href="https://nats.io/download/nats-io/nats-streaming-server/">https://nats.io/download/nats-io/nats-streaming-server/</a>
</li>

<li>NATS Introduction<br />
<a href="https://nats.io/documentation/">https://nats.io/documentation/</a>
</li>

<li>NATS Client Protocol<br />
<a href="https://nats.io/documentation/internals/nats-protocol/">https://nats.io/documentation/internals/nats-protocol/</a>
</li>

<li>NATS Messaging (Wikipedia)<br />
<a href="https://en.wikipedia.org/wiki/NATS_Messaging">https://en.wikipedia.org/wiki/NATS_Messaging</a>
</li>

<li>Stránka Apache Software Foundation<br />
<a href="http://www.apache.org/">http://www.apache.org/</a>
</li>

<li>Logstash<br />
<a href="https://www.elastic.co/products/logstash">https://www.elastic.co/products/logstash</a>
</li>

<li>Elasticsearch<br />
<a href="https://www.elastic.co/products/elasticsearch">https://www.elastic.co/products/elasticsearch</a>
</li>

<li>Understanding When to use RabbitMQ or Apache Kafka<br />
<a href="https://content.pivotal.io/blog/understanding-when-to-use-rabbitmq-or-apache-kafka">https://content.pivotal.io/blog/understanding-when-to-use-rabbitmq-or-apache-kafka</a>
</li>

<li>Part 1: Apache Kafka for beginners - What is Apache Kafka?<br />
<a href="https://www.cloudkarafka.com/blog/2016-11-30-part1-kafka-for-beginners-what-is-apache-kafka.html">https://www.cloudkarafka.com/blog/2016-11-30-part1-kafka-for-beginners-what-is-apache-kafka.html</a>
</li>

<li>What are some alternatives to Apache Kafka?<br />
<a href="https://www.quora.com/What-are-some-alternatives-to-Apache-Kafka">https://www.quora.com/What-are-some-alternatives-to-Apache-Kafka</a>
</li>

<li>What is the best alternative to Kafka?<br />
<a href="https://www.slant.co/options/961/alternatives/~kafka-alternatives">https://www.slant.co/options/961/alternatives/~kafka-alternatives</a>
</li>

<li>Apache Flume<br />
<a href="https://flume.apache.org/index.html">https://flume.apache.org/index.html</a>
</li>

<li>Snare<br />
<a href="https://www.snaresolutions.com/">https://www.snaresolutions.com/</a>
</li>

<li>The Log: What every software engineer should know about real-time data's unifying abstraction<br />
<a href="https://engineering.linkedin.com/distributed-systems/log-what-every-software-engineer-should-know-about-real-time-datas-unifying">https://engineering.linkedin.com/distributed-systems/log-what-every-software-engineer-should-know-about-real-time-datas-unifying</a>
</li>

<li>A super quick comparison between Kafka and Message Queues<br />
<a href="https://hackernoon.com/a-super-quick-comparison-between-kafka-and-message-queues-e69742d855a8?gi=e965191e72d0">https://hackernoon.com/a-super-quick-comparison-between-kafka-and-message-queues-e69742d855a8?gi=e965191e72d0</a>
</li>

<li>Kafka Queuing: Kafka as a Messaging System<br />
<a href="https://dzone.com/articles/kafka-queuing-kafka-as-a-messaging-system">https://dzone.com/articles/kafka-queuing-kafka-as-a-messaging-system</a>
</li>

<li>Microservices - Not a free lunch!<br />
<a href="http://highscalability.com/blog/2014/4/8/microservices-not-a-free-lunch.html">http://highscalability.com/blog/2014/4/8/microservices-not-a-free-lunch.html</a>
</li>

<li>Microservices, Monoliths, and NoOps<br />
<a href="http://blog.arungupta.me/microservices-monoliths-noops/">http://blog.arungupta.me/microservices-monoliths-noops/</a>
</li>

<li>Microservice Design Patterns<br />
<a href="http://blog.arungupta.me/microservice-design-patterns/">http://blog.arungupta.me/microservice-design-patterns/</a>
</li>

<li>Vision of a microservice revolution<br />
<a href="https://www.jolie-lang.org/vision.html">https://www.jolie-lang.org/vision.html</a>
</li>

<li>Microservices: a definition of this new architectural term<br />
<a href="https://martinfowler.com/articles/microservices.html">https://martinfowler.com/articles/microservices.html</a>
</li>

<li>Mikroslužby<br />
<a href="http://voho.eu/wiki/mikrosluzba/">http://voho.eu/wiki/mikrosluzba/</a>
</li>

<li>Microservice Prerequisites<br />
<a href="https://martinfowler.com/bliki/MicroservicePrerequisites.html">https://martinfowler.com/bliki/MicroservicePrerequisites.html</a>
</li>

<li>Microservices in Practice, Part 1: Reality Check and Service Design (vyžaduje registraci)<br />
<a href="https://ieeexplore.ieee.org/document/7819415">https://ieeexplore.ieee.org/document/7819415</a>
</li>

<li>Microservice Trade-Offs<br />
<a href="https://www.martinfowler.com/articles/microservice-trade-offs.html">https://www.martinfowler.com/articles/microservice-trade-offs.html</a>
</li>

<li>What is a microservice? (from a linguistic point of view)<br />
<a href="http://claudioguidi.blogspot.com/2017/03/what-microservice-from-linguisitc.html">http://claudioguidi.blogspot.com/2017/03/what-microservice-from-linguisitc.html</a>
</li>

<li>Microservices (Wikipedia)<br />
<a href="https://en.wikipedia.org/wiki/Microservices">https://en.wikipedia.org/wiki/Microservices</a>
</li>

<li>Fallacies of distributed computing (Wikipedia)<br />
<a href="https://en.wikipedia.org/wiki/Fallacies_of_distributed_computing">https://en.wikipedia.org/wiki/Fallacies_of_distributed_computing</a>
</li>

<li>Service (systems architecture)<br />
<a href="https://en.wikipedia.org/wiki/Service_(systems_architecture)">https://en.wikipedia.org/wiki/Service_(systems_architecture)</a>
</li>

<li>Microservices in a Nutshell<br />
<a href="https://www.thoughtworks.com/insights/blog/microservices-nutshell">https://www.thoughtworks.com/insights/blog/microservices-nutshell</a>
</li>

<li>What is Microservices?<br />
<a href="https://smartbear.com/solutions/microservices/">https://smartbear.com/solutions/microservices/</a>
</li>

<li>Mastering Chaos - A Netflix Guide to Microservices<br />
<a href="https://www.youtube.com/watch?v=CZ3wIuvmHeM&t=17s">https://www.youtube.com/watch?v=CZ3wIuvmHeM&amp;t=17s</a>
</li>

<li>Messaging in Microservice Architecture<br />
<a href="https://www.youtube.com/watch?v=MkQWQ5f-SEY">https://www.youtube.com/watch?v=MkQWQ5f-SEY</a>
</li>

<li>Pattern: Messaging<br />
<a href="https://microservices.io/patterns/communication-style/messaging.html">https://microservices.io/patterns/communication-style/messaging.html</a>
</li>

<li>Microservices Messaging: Why REST Isn’t Always the Best Choice<br />
<a href="https://blog.codeship.com/microservices-messaging-rest-isnt-always-best-choice/">https://blog.codeship.com/microservices-messaging-rest-isnt-always-best-choice/</a>
</li>

<li>Protocol buffers<br />
<a href="https://developers.google.com/protocol-buffers/">https://developers.google.com/protocol-buffers/</a>
</li>

<li>BSON<br />
<a href="http://bsonspec.org/">http://bsonspec.org/</a>
</li>

<li>Apache Avro!<br />
<a href="https://avro.apache.org/">https://avro.apache.org/</a>
</li>

<li>REST vs Messaging for Microservices – Which One is Best?<br />
<a href="https://solace.com/blog/experience-awesomeness-event-driven-microservices/">https://solace.com/blog/experience-awesomeness-event-driven-microservices/</a>
</li>

<li>How did we end up here?<br />
<a href="https://gotocon.com/dl/goto-chicago-2015/slides/MartinThompson_and_ToddMontgomery_HowDidWeEndUpHere.pdf">https://gotocon.com/dl/goto-chicago-2015/slides/MartinThompson_and_ToddMontgomery_HowDidWeEndUpHere.pdf</a>
</li>

<li>Scaling microservices with message queues to handle data bursts<br />
<a href="https://read.acloud.guru/scaling-microservices-with-message-queue-2d389be5b139">https://read.acloud.guru/scaling-microservices-with-message-queue-2d389be5b139</a>
</li>

<li>Microservices: What are smart endpoints and dumb pipes?<br />
<a href="https://stackoverflow.com/questions/26616962/microservices-what-are-smart-endpoints-and-dumb-pipes">https://stackoverflow.com/questions/26616962/microservices-what-are-smart-endpoints-and-dumb-pipes</a>
</li>

<li>Common Object Request Broker Architecture<br />
<a href="https://en.wikipedia.org/wiki/Common_Object_Request_Broker_Architecture">https://en.wikipedia.org/wiki/Common_Object_Request_Broker_Architecture</a>
</li>

<li>Enterprise service bus<br />
<a href="https://en.wikipedia.org/wiki/Enterprise_service_bus">https://en.wikipedia.org/wiki/Enterprise_service_bus</a>
</li>

<li>Microservices vs SOA : What’s the Difference<br />
<a href="https://www.edureka.co/blog/microservices-vs-soa/">https://www.edureka.co/blog/microservices-vs-soa/</a>
</li>

<li>Pravda o SOA<br />
<a href="https://businessworld.cz/reseni-a-realizace/pravda-o-soa-2980">https://businessworld.cz/reseni-a-realizace/pravda-o-soa-2980</a>
</li>

<li>Is it a good idea for Microservices to share a common database?<br />
<a href="https://www.quora.com/Is-it-a-good-idea-for-Microservices-to-share-a-common-database">https://www.quora.com/Is-it-a-good-idea-for-Microservices-to-share-a-common-database</a>
</li>

<li>Pattern: Shared database<br />
<a href="https://microservices.io/patterns/data/shared-database.html">https://microservices.io/patterns/data/shared-database.html</a>
</li>

<li>Is a Shared Database in Microservices Actually an Anti-pattern?<br />
<a href="https://hackernoon.com/is-shared-database-in-microservices-actually-anti-pattern-8cc2536adfe4">https://hackernoon.com/is-shared-database-in-microservices-actually-anti-pattern-8cc2536adfe4</a>
</li>

<li>Shared database in microservices is a problem, yep<br />
<a href="https://ayende.com/blog/186914-A/shared-database-in-microservices-is-a-problem-yep">https://ayende.com/blog/186914-A/shared-database-in-microservices-is-a-problem-yep</a>
</li>

<li>Microservices with shared database? using multiple ORM's?<br />
<a href="https://stackoverflow.com/questions/43612866/microservices-with-shared-database-using-multiple-orms">https://stackoverflow.com/questions/43612866/microservices-with-shared-database-using-multiple-orms</a>
</li>

<li>Examples of microservice architecture<br />
<a href="https://www.coursera.org/lecture/intro-ibm-microservices/examples-of-microservice-architecture-JXOFj">https://www.coursera.org/lecture/intro-ibm-microservices/examples-of-microservice-architecture-JXOFj</a>
</li>

<li>Microservices: The Rise Of Kafka<br />
<a href="https://movio.co/blog/microservices-rise-kafka/">https://movio.co/blog/microservices-rise-kafka/</a>
</li>

<li>Building a Microservices Ecosystem with Kafka Streams and KSQL<br />
<a href="https://www.confluent.io/blog/building-a-microservices-ecosystem-with-kafka-streams-and-ksql/">https://www.confluent.io/blog/building-a-microservices-ecosystem-with-kafka-streams-and-ksql/</a>
</li>

<li>An introduction to Apache Kafka and microservices communication<br />
<a href="https://medium.com/@ulymarins/an-introduction-to-apache-kafka-and-microservices-communication-bf0a0966d63">https://medium.com/@ulymarins/an-introduction-to-apache-kafka-and-microservices-communication-bf0a0966d63</a>
</li>

<li>ACID (computer science)<br />
<a href="https://en.wikipedia.org/wiki/ACID_(computer_science)">https://en.wikipedia.org/wiki/ACID_(computer_science)</a>
</li>

<li>Distributed transaction<br />
<a href="https://en.wikipedia.org/wiki/Distributed_transaction">https://en.wikipedia.org/wiki/Distributed_transaction</a>
</li>

<li>Two-phase commit protocol<br />
<a href="https://en.wikipedia.org/wiki/Two-phase_commit_protocol">https://en.wikipedia.org/wiki/Two-phase_commit_protocol</a>
</li>

<li>Why is 2-phase commit not suitable for a microservices architecture?<br />
<a href="https://stackoverflow.com/questions/55249656/why-is-2-phase-commit-not-suitable-for-a-microservices-architecture">https://stackoverflow.com/questions/55249656/why-is-2-phase-commit-not-suitable-for-a-microservices-architecture</a>
</li>

<li>4 reasons why microservices resonate<br />
<a href="https://www.oreilly.com/ideas/4-reasons-why-microservices-resonate">https://www.oreilly.com/ideas/4-reasons-why-microservices-resonate</a>
</li>

<li>Pattern: Microservice Architecture<br />
<a href="https://microservices.io/patterns/microservices.html">https://microservices.io/patterns/microservices.html</a>
</li>

<li>Pattern: Monolithic Architecture<br />
<a href="https://microservices.io/patterns/monolithic.html">https://microservices.io/patterns/monolithic.html</a>
</li>

<li>Pattern: Saga<br />
<a href="https://microservices.io/patterns/data/saga.html">https://microservices.io/patterns/data/saga.html</a>
</li>

<li>Pattern: Database per service<br />
<a href="https://microservices.io/patterns/data/database-per-service.html">https://microservices.io/patterns/data/database-per-service.html</a>
</li>

<li>Pattern: Access token<br />
<a href="https://microservices.io/patterns/security/access-token.html">https://microservices.io/patterns/security/access-token.html</a>
</li>

<li>Databázová integrita<br />
<a href="https://cs.wikipedia.org/wiki/Datab%C3%A1zov%C3%A1_integrita">https://cs.wikipedia.org/wiki/Datab%C3%A1zov%C3%A1_integrita</a>
</li>

<li>Referenční integrita<br />
<a href="https://cs.wikipedia.org/wiki/Referen%C4%8Dn%C3%AD_integrita">https://cs.wikipedia.org/wiki/Referen%C4%8Dn%C3%AD_integrita</a>
</li>

<li>Introduction into Microservices <br />
<a href="https://specify.io/concepts/microservices">https://specify.io/concepts/microservices</a>
</li>

<li>Are Microservices ‘SOA Done Right’?<br />
<a href="https://intellyx.com/2015/07/20/are-microservices-soa-done-right/">https://intellyx.com/2015/07/20/are-microservices-soa-done-right/</a>
</li>

<li>The Hardest Part About Microservices: Your Data<br />
<a href="https://blog.christianposta.com/microservices/the-hardest-part-about-microservices-data/">https://blog.christianposta.com/microservices/the-hardest-part-about-microservices-data/</a>
</li>

<li>From a monolith to microservices + REST<br />
<a href="https://www.slideshare.net/InfoQ/from-a-monolith-to-microservices-rest-the-evolution-of-linkedins-service-architecture">https://www.slideshare.net/InfoQ/from-a-monolith-to-microservices-rest-the-evolution-of-linkedins-service-architecture</a>
</li>

<li>DevOps and the Myth of Efficiency, Part I<br />
<a href="https://blog.christianposta.com/devops/devops-and-the-myth-of-efficiency-part-i/">https://blog.christianposta.com/devops/devops-and-the-myth-of-efficiency-part-i/</a>
</li>

<li>DevOps and the Myth of Efficiency, Part II<br />
<a href="https://blog.christianposta.com/devops/devops-and-the-myth-of-efficiency-part-ii/">https://blog.christianposta.com/devops/devops-and-the-myth-of-efficiency-part-ii/</a>
</li>

<li>Standing on Distributed Shoulders of Giants: Farsighted Physicists of Yore Were Danged Smart!<br />
<a href="https://queue.acm.org/detail.cfm?id=2953944">https://queue.acm.org/detail.cfm?id=2953944</a>
</li>

<li>Building DistributedLog: High-performance replicated log service<br />
<a href="https://blog.twitter.com/engineering/en_us/topics/infrastructure/2015/building-distributedlog-twitter-s-high-performance-replicated-log-servic.html">https://blog.twitter.com/engineering/en_us/topics/infrastructure/2015/building-distributedlog-twitter-s-high-performance-replicated-log-servic.html</a>
</li>

<li>Turning the database inside-out with Apache Samza<br />
<a href="https://www.confluent.io/blog/turning-the-database-inside-out-with-apache-samza/">https://www.confluent.io/blog/turning-the-database-inside-out-with-apache-samza/</a>
</li>

<li>Debezium: Stream changes from your databases.<br />
<a href="https://debezium.io/">https://debezium.io/</a>
</li>

<li>Change data capture<br />
<a href="https://en.wikipedia.org/wiki/Change_data_capture">https://en.wikipedia.org/wiki/Change_data_capture</a>
</li>

<li>Apache Samza (Wikipedia)<br />
<a href="https://en.wikipedia.org/wiki/Apache_Samza">https://en.wikipedia.org/wiki/Apache_Samza</a>
</li>

<li>Storm (event processor)<br />
<a href="https://en.wikipedia.org/wiki/Storm_(event_processor)">https://en.wikipedia.org/wiki/Storm_(event_processor)</a>
</li>

<li>kappa-architecture.com<br />
<a href="http://milinda.pathirage.org/kappa-architecture.com/">http://milinda.pathirage.org/kappa-architecture.com/</a>
</li>

<li>Questioning the Lambda Architecture<br />
<a href="https://www.oreilly.com/ideas/questioning-the-lambda-architecture">https://www.oreilly.com/ideas/questioning-the-lambda-architecture</a>
</li>

<li>Lambda architecture<br />
<a href="https://en.wikipedia.org/wiki/Lambda_architecture">https://en.wikipedia.org/wiki/Lambda_architecture</a>
</li>

<li>Event stream processing<br />
<a href="https://en.wikipedia.org/wiki/Event_stream_processing">https://en.wikipedia.org/wiki/Event_stream_processing</a>
</li>

<li>How to beat the CAP theorem<br />
<a href="http://nathanmarz.com/blog/how-to-beat-the-cap-theorem.html">http://nathanmarz.com/blog/how-to-beat-the-cap-theorem.html</a>
</li>

<li>Kappa Architecture Our Experience<br />
<a href="https://events.static.linuxfound.org/sites/events/files/slides/ASPgems%20-%20Kappa%20Architecture.pdf">https://events.static.linuxfound.org/sites/events/files/slides/ASPgems%20-%20Kappa%20Architecture.pdf</a>
</li>

<li>Messaging Patterns in Event Driven Microservice Architectures<br />
<a href="https://www.youtube.com/watch?v=3xDc4MEYuHI">https://www.youtube.com/watch?v=3xDc4MEYuHI</a>
</li>

<li>Why monolithic apps are often better than microservices<br />
<a href="https://gigaom.com/2015/11/06/why-monolithic-apps-are-often-better-than-microservices/">https://gigaom.com/2015/11/06/why-monolithic-apps-are-often-better-than-microservices/</a>
</li>

<li>How Enterprise PaaS Can Add Critical Value to Microservices<br />
<a href="https://apprenda.com/blog/enterprise-paas-microservices/">https://apprenda.com/blog/enterprise-paas-microservices/</a>
</li>

<li>Common React Mistakes: Monolithic Components and a Lack of Abstraction<br />
<a href="https://www.pmg.com/blog/common-react-mistakes-monolithic-components-lack-abstraction/">https://www.pmg.com/blog/common-react-mistakes-monolithic-components-lack-abstraction/</a>
</li>

<li>From monolith to microservices – to migrate or not to migrate?<br />
<a href="https://altkomsoftware.pl/en/blog/monolith-microservices/">https://altkomsoftware.pl/en/blog/monolith-microservices/</a>
</li>

<li>Command–query separation<br />
<a href="https://en.wikipedia.org/wiki/Command%E2%80%93query_separation">https://en.wikipedia.org/wiki/Command%E2%80%93query_separation</a>
</li>

<li>GOTO 2016: Messaging and Microservices (Clemens Vasters)<br />
<a href="https://www.youtube.com/watch?v=rXi5CLjIQ9kx">https://www.youtube.com/watch?v=rXi5CLjIQ9kx</a>
</li>

<li>GOTO Amsterdam 2019<br />
<a href="https://gotoams.nl/">https://gotoams.nl/</a>
</li>

<li>Lesson 2 - Kafka vs. Standard Messaging<br />
<a href="https://www.youtube.com/watch?v=lwMjjTT1Q-Q">https://www.youtube.com/watch?v=lwMjjTT1Q-Q</a>
</li>

<li>CommandQuerySeparation (Martin Fowler)<br />
<a href="https://martinfowler.com/bliki/CommandQuerySeparation.html">https://martinfowler.com/bliki/CommandQuerySeparation.html</a>
</li>

<li>Command–query separation<br />
<a href="https://en.wikipedia.org/wiki/Command%E2%80%93query_separation">https://en.wikipedia.org/wiki/Command%E2%80%93query_separation</a>
</li>

<li>CQRS - Martin Fowler<br />
<a href="https://martinfowler.com/bliki/CQRS.html">https://martinfowler.com/bliki/CQRS.html</a>
</li>

<li>Lesson 12 - CQRS and Microservices<br />
<a href="https://www.youtube.com/watch?v=pUGvXUBfvEE">https://www.youtube.com/watch?v=pUGvXUBfvEE</a>
</li>

<li>Message queues - the right way to process and work with realtime data on your servers<br />
<a href="https://www.ably.io/blog/message-queues-the-right-way">https://www.ably.io/blog/message-queues-the-right-way</a>
</li>

<li>Function as a service<br />
<a href="https://en.wikipedia.org/wiki/Function_as_a_service">https://en.wikipedia.org/wiki/Function_as_a_service</a>
</li>

<li>AWS Lambda<br />
<a href="https://en.wikipedia.org/wiki/AWS_Lambda">https://en.wikipedia.org/wiki/AWS_Lambda</a>
</li>

</ol>



<p></p><p></p>
<p><small>Autor: <a href="http://www.fit.vutbr.cz/~tisnovpa">Pavel Tišnovský</a> &nbsp; 2019</small></p>
</body>
</html>

