<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
        "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html>
<head>
<title>Způsoby uložení dat v aplikacích založených na mikroslužbách</title>
<meta name="Author" content="Pavel Tisnovsky" />
<meta name="Generator" content="vim" />
<meta http-equiv="content-type" content="text/html; charset=utf-8" />
<style type="text/css">
         body {color:#000000; background:#ffffff;}
         h1  {font-family: arial, helvetica, sans-serif; color:#ffffff; background-color:#c00000; text-align:center; padding-left:1em}
         h2  {font-family: arial, helvetica, sans-serif; color:#ffffff; background-color:#0000c0; padding-left:1em; text-align:left}
         h3  {font-family: arial, helvetica, sans-serif; color:#000000; background-color:#c0c0c0; padding-left:1em; text-align:left}
         h4  {font-family: arial, helvetica, sans-serif; color:#000000; background-color:#e0e0e0; padding-left:1em; text-align:left}
         a   {font-family: arial, helvetica, sans-serif;}
         li  {font-family: arial, helvetica, sans-serif; color:#000000; text-align:justify; width:450px;}
         ol  {font-family: arial, helvetica, sans-serif; color:#000000; text-align:justify; width:450px;}
         ul  {font-family: arial, helvetica, sans-serif; color:#000000; text-align:justify; width:450px;}
         p   {font-family: arial, helvetica, sans-serif; color:#000000; text-align:justify;}
         pre {background:#e0e0e0}
</style>
</head>

<body>

<h1>Způsoby uložení dat v aplikacích založených na mikroslužbách</h1>

<h3>Pavel Tišnovský</h3>

<p></p>

<h1>Úvodník</h1>

<p>Ve druhé části seriálu o mikroslužbách si vysvětlíme, které problémy je nutné řešit ve chvíli, kdy bude každá mikroslužba obsahovat svoji databázi. Rozdělením původně monolitické databáze totiž ztratíme některé důležité vlastnosti (ACID), které je většinou užitečné nějakým způsobem kompenzovat.</p>



<h2>Obsah</h2>

<p><a href="#k01">1. Některé možné návrhy architektury aplikací založených na mikroslužbách</a></p>
<p><a href="#k02">2. Zamyšlení před přechodem na řešení založené na mikroslužbách...</a></p>
<p><a href="#k03">3. Distribuovaná datová úložiště</a></p>
<p><a href="#k04">4. Příklad databáze v&nbsp;monolitické aplikaci s&nbsp;implementací e-shopu</a></p>
<p><a href="#k05">5. Některé užitečné vlastnosti databáze použité v&nbsp;monolitické aplikaci</a></p>
<p><a href="#k06">6. Databáze v&nbsp;aplikaci postavené na mikroslužbách</a></p>
<p><a href="#k07">7. Dvoufázový commit v&nbsp;mikroslužbách?</a></p>
<p><a href="#k08">8. Další možnost: kompenzační transakce</a></p>
<p><a href="#k09">9. Použití nástrojů pro streaming: záznam a přehrávání sekvence událostí</a></p>
<p><a href="#k10">10. Koncepty, na nichž je streaming založen</a></p>
<p><a href="#k11">11. Nejznámější systémy podporující streaming</a></p>
<p><a href="#k12">12. Apache Kafka</a></p>
<p><a href="#k13">13. Nahrávání a přehrávání událostí při použití distribuovaných databází</a></p>
<p><a href="#k14">14. Architektura kappa</a></p>
<p><a href="#k15">15. Příklad architektury kappa</a></p>
<p><a href="#k16">16. Přednosti architektury kappa</a></p>
<p><a href="#k17">17. Odkazy na Internetu</a></p>



<p><a name="k01"></a></p>
<h2 id="k01">1. Některé možné návrhy architektury aplikací založených na mikroslužbách</h2>

<p><a
href="https://www.root.cz/clanky/mikrosluzby-moderni-aplikace-vyuzivajici-znamych-konceptu/">V&nbsp;úvodním
článku</a> jsme se seznámili s&nbsp;některými základními koncepty, na nichž
jsou postaveny mikroslužby. Připomeňme si, že cílem návrhu architektury
aplikace založené na mikroslužbách je dosažení co nejlepší izolace jednotlivých
mikroslužeb. Mikroslužby by v&nbsp;naprosté většině případů neměly sdílet
databáze a komunikovat by spolu měly pouze přes API volané přes síťové
protokoly (nikoli přímo, jak je to možné při běhu na jediném počítači a
operačním systému; samozřejmě ani není možné pro komunikaci použít sdílenou
paměť). Ovšem ještě lepší bývá stav, kdy spolu služby raději vůbec nekomunikují
:-), přesněji řečeno když komunikují pouze přes nějakého prostředníka, kterým
může být message bus, message broker, systém pro správu událostí atd.</p>

<p><i>&bdquo;It must be possible to feed a team that maintains a service with
two pizzas.&ldquo;<br />
Werner Vogels</i></p>

<p>Řešení postavené na mikroslužbách přináší některé výhody, například možnost
používat různé programovací jazyky a knihovny pro jednotlivé mikroslužby
(zmenší se tím pravděpodobnost, že celá obrovská aplikace morálně zastará),
provádět paralelní vývoj s&nbsp;několika samostatnými týmy s&nbsp;omezením
komunikace mezi těmito týmy, nasazovat jednotlivé služby samostatně, zlepšují
se možnosti load balancingu, škálovatelnosti atd. A samozřejmě, protože
v&nbsp;IT nedostaneme nic zadarmo, přináší mikroslužby pochopitelně i celou
řadu problémů. Dnes se budeme zabývat tím vůbec nejpalčivějším problémem
&ndash; co s&nbsp;daty resp.&nbsp;přesněji řečeno jak řešit změnu stavu celé
aplikace.</p>



<p><a name="k02"></a></p>
<h2 id="k02">2. Zamyšlení před přechodem na řešení založené na mikroslužbách...</h2>

<p><i>&bdquo;People try to copy Netflix, but they can only copy what they see.
They copy the results, not the process&ldquo;<br />
Adrian Cockcroft, former Netflix Chief Cloud Architect</i></p>

<p>Před případným přechodem z&nbsp;monolitických aplikací na mikroslužby je
v&nbsp;první řadě dobré si uvědomit jednu důležitou věc. Uživatelské služby
typu <i>Netflix</i> a <i>linkedId</i> skutečně mikroslužby velmi úspěšně
používají (pravděpodobně by ani s&nbsp;jinou architekturou nemohly uspět), ale
je tomu tak mj.&nbsp;i z&nbsp;toho důvodu, že typ aplikací/služeb, které
provozují, má v&nbsp;podstatě dosti jednoduchou strukturu (stavový prostor),
kterou lze relativně snadno rozdělit na mikroslužby. Naproti tomu běžné
dennodenně provozované podnikové aplikace sice nemusí dodávat videa nebo
publikovat tweeety stovkám milionů uživatelů, ale struktura a provázanost dat
v&nbsp;nich bývá mnohem větší. Proto se může velmi dobře stát, že přechod na
mikroslužby nemusí být úspěšný, protože na různé aplikace jsou kladeny dosti
rozdílné požadavky. Taktéž je nutné upozornit na to, že nasazování a
provozování mikroslužeb vyžaduje odlišný přístup, než je tomu u monolitických
aplikací. Stručně řečeno: mikroslužby nejsou řešením pro každou situaci a na
každý problém!</p>

<p>Přechod na mikroslužby navíc vyžaduje i změnu v&nbsp;myšlení architektů a
vývojářů. U monolitické aplikace je vše, zejména změny stavu, v&nbsp;podstatě
jednoduché a předvídatelné (ostatně je to důsledek vývoje, který trval
přibližně sedm desetiletí) &ndash; volání modulů dává zaručené výsledky,
databáze typicky podporuje všechny čtyři vlastnosti ACID atd. U mikroslužeb je
naproti tomu nutné brát do úvahy zejména problematické vlastnosti počítačové
sítě (viz též <a
href="https://www.root.cz/clanky/mikrosluzby-moderni-aplikace-vyuzivajici-znamych-konceptu/#k13">třináctou
kapitolu v&nbsp;předchozím článku</a>) a taktéž důsledky použití několika
izolovaných databází.</p>

<p><div class="rs-tip-major">Poznámka: i přesto, že se někdy používají dosti
sofistikované technologie typu SOAP, CORBA, RPC atd., nejsme nikdy od
vlastností počítačové sítě dokonale odstínění.</div></p>

<p>Velmi pěkně jsou některé vlastnosti (počítačových) sítí shrnuty ve článku <a
href="https://queue.acm.org/detail.cfm?id=2953944">Standing on Distributed
Shoulders of Giants: Farsighted Physicists of Yore Were Danged Smart!</a>.</p>



<p><a name="k03"></a></p>
<h2 id="k03">3. Distribuovaná datová úložiště</h2>

<p>V&nbsp;předchozím článku s&nbsp;úvodními informacemi o mikroslužbách jsme si
mj.&nbsp;řekli, že by jednotlivé služby mezi sebou neměly sdílet společnou
databázi. Tento požadavek je vlastně pochopitelný, protože se snažíme služby od
sebe oddělit, a to jak z&nbsp;hlediska architektury celé aplikace, tak i
z&nbsp;pohledu vývojářů &ndash; prakticky totiž mohou jednotlivé mikroslužby
vyvíjet oddělené týmy, které se musí domluvit na API, ovšem nikoli již na
interních záležitostech a logice. A právě sem spadají i databáze,
popř.&nbsp;obecněji řečeno datová úložiště &ndash; mnoho tabulek a jejich
sloupců (pokud se budeme držet relačních databází) nesouvisí s&nbsp;API služby
a s&nbsp;její požadovanou vnější funkcionalitou. Na druhou stranu i relativně
malá změna v&nbsp;databázovém schématu může rozbít všechny služby, které tuto
databázi společně používají.</p>

<p>Přístup k&nbsp;databázím se ve světě mikroslužeb skutečně dosti podstatným
způsobem odlišuje od světa monolitických aplikací, a již na začátku je nutné
upozornit na to, že mnohé vlastnosti databází, která běžně využíváme (ACID,
...) nebudou u mikroslužeb &bdquo;automagicky&ldquo; splněny a mnohdy se
programátoři musí sami postarat o to, aby byla příslušná vlastnost databáze
skutečně dodržena (pochopitelně jen za předpokladu, že je to skutečně
zapotřebí). Na druhou stranu se nám však otevírá celý nový prostor pro nová
řešení založená například na perzistentním logu s&nbsp;událostmi atd.</p>

<a href="https://www.root.cz/obrazek/361137/"><img src="https://i.iinfo.cz/images/372/microservices1-4-prev.png" class="image-361137" alt="&#160;" width="358" height="270" /></a>
<p><i>Obrázek 1: Jednotlivé mikroslužby mezi sebou mohou komunikovat například
s&nbsp;využitím protokolu HTTP (REST API), STOMP atd. Ovšem důležité je, že
každá mikroslužba má svoji databázi.</i></p>



<p><a name="k04"></a></p>
<h2 id="k04">4. Příklad databáze v&nbsp;monolitické aplikaci s&nbsp;implementací e-shopu</h2>

<p>Nejprve si ovšem ve stručnosti ukažme, jakým způsobem může být řešena
databáze v&nbsp;monolitické aplikaci při implementaci jednoduchého e-shopu.
Soustředit se budeme pouze na její jedinou část &ndash; vyřizování objednávek
provedených jednotlivými přihlášenými uživateli (u nichž budeme při vyřizování
objednávky znát jejich <strong>ID</strong>).</p>

<a href="https://www.root.cz/obrazek/361135/"><img src="https://i.iinfo.cz/images/372/microservices1-2-prev.png" class="image-361135" alt="&#160;" width="370" height="146" /></a>
<p><i>Obrázek 2: Služba v&nbsp;reálném provozu při použití HTTP serveru,
k&nbsp;němuž se připojují klienti.</i></p>

<p>V&nbsp;tom nejjednodušším případě uvažujme o tom, že databáze bude obsahovat
pouhé dvě tabulky nazvané <strong>ORDERS</strong> a <strong>CUSTOMERS</strong>.
Ve skutečnosti se ovšem pochopitelně bude muset pracovat s&nbsp;více tabulkami,
například seznamem zboží pro daný <strong>ORDERS.ID</strong>, historií nákupů
pro <strong>CUSTOMERS.ID</strong> atd. Tyto tabulky mohou (při značném
zjednodušení) vypadat například následovně.</p>

<p>Tabulka <strong>CUSTOMERS</strong> obsahuje základní informace o
zákaznících, přičemž si u každého zákazníka pamatuje i nejvyšší sumu, za kterou
tento zákazník může vytvořit objednávku popř.&nbsp;více objednávek. Business
logika aplikace musí zaručit, že tato suma nebude překročena:</p>

<pre>
CREATE TABLE <strong>CUSTOMERS</strong>(
    ID            INT NOT NULL,
    NAME          VARCHAR (20) NOT NULL,
    SURNAME       VARCHAR (30) NOT NULL,
    CREDIT_LIMIT  DECIMAL(8,2),
    ...
    ...
    ...
    PRIMARY KEY (ID)
);
</pre>

<p>Tabulka s&nbsp;objednávkami obsahuje seznam všech objednávek, přičemž každá
objednávka je na nějakou sumu a navíc je vztažena ke konkrétnímu zákazníkovi.
Další sloupce obsahují časové razítko vytvoření objednávky a popř.&nbsp;i její
stav:</p>

<pre>
CREATE TABLE <strong>ORDERS</strong>(
    ID            INT NOT NULL,
    DATE          DATETIME,
    CUSTOMER_ID   INT NOT NULL references CUSTOMERS(ID),
    TOTAL         DECIMAL(8,2),
    STATE         CHAR(1),
    ...
    ...
    ...
    PRIMARY KEY (ID)
);
</pre>

<p><div class="rs-tip-major">Poznámka: příklad, který si zde popisujeme, je do
značné míry podobný příkladu, jenž poměrně často zmiňuje Chris Richardson ve
svých přednáškách. Jako u každého umělého příkladu se samozřejmě jedná o značné
zjednodušení, které sice dobře ukazuje některé vlastnosti monolitických
aplikací i mikroslužeb, ovšem kvůli malé složitosti se zde příliš neukazuje,
z&nbsp;jakého důvodu začaly být mikroslužby v&nbsp;některých oborech IT tak
populární.</a></div></p>

<p>Při objednávce zboží je možné nad operacemi v&nbsp;databázi provádět všechny
potřebné kontroly, a to většinou naprosto triviálním způsobem. Například můžeme
zaručit, že se objednávka podaří jen ve chvíli, kdy bude platit podmínka:</p>

<pre>
sum(ORDERS.TOTAL) &lt;= CUSTOMER.CREDIT_LIMIT
</pre>

<p><div class="rs-tip-major">Poznámka: samozřejmě je nutné podmínku splnit
s&nbsp;příslušnými vazbami přes <strong>CUSTOMERS.ID</strong> atd.</div></p>



<p><a name="k05"></a></p>
<h2 id="k05">5. Některé užitečné vlastnosti databáze použité v&nbsp;monolitické aplikaci</h2>

<p>To pochopitelně není vše, protože pokud celou operaci objednávky uzavřeme do
transakce, zaručí výše zmíněná kontrola automatický rollback celé transakce
v&nbsp;případě, že se zákazník bude snažit objednat zboží, jehož celková cena
přesahuje jeho maximální povolený limit. Jak kontrolu, tak i transakci lze
přitom v&nbsp;monolitické aplikaci s&nbsp;jedinou databází naprogramovat
doslova na několika řádcích programového kódu. Dále je možné velmi snadno
zaručit automatickou serializaci transakcí pro jednoho zákazníka,
tj.&nbsp;vyloučí se například ty situace, kdy se nějaký zákazník bude snažit
provést dva nákupy současně, přičemž cena každého nákupu zvlášť se sice vejde
do limitní ceny, ale oba nákupy již finanční možnosti zákazníka převyšují. A
nakonec &ndash; opět díky transakcím &ndash; je stav databáze vždy
konzistentní, protože se objednávka buď provede (s&nbsp;odečtením kreditu) nebo
neprovede, což se například projeví úpravou <strong>ORDERS.STATUS</strong> na
hodnotu &bdquo;denied&ldquo;. Nebude zde nutné řešit speciální stavy typu
&bdquo;pending&ldquo; atd.</p>

<p>I z&nbsp;hlediska logiky samotné aplikace se jedná o triviální úkol:
uživatel stiskne tlačítko <strong>Order</strong>, aplikace se pokusí provést
transakci a pokud transakce proběhla, je o tom uživatel prakticky okamžitě
informován, podobně jako bude informován v&nbsp;případě zamítnutí objednávky.
Celý kód je proveden synchronně (s&nbsp;případnou výjimkou, která se týká
webového UI, ovšem předpokládejme, že zákazník bude moci použít i synchronní
API).</p>



<p><a name="k06"></a></p>
<h2 id="k06">6. Databáze v&nbsp;aplikaci postavené na mikroslužbách</h2>

<p>V&nbsp;případě, že budeme navrhovat aplikaci s&nbsp;e-shopem postavenou na
mikroslužbách, může vést tento návrh k&nbsp;tomu, že se vytvoří (kromě dalších
modulů) i mikroslužby nazvané například <strong>customer service</strong> a
<strong>order service</strong>. Každá z&nbsp;těchto mikroslužeb bude mít i
vlastní databázi. Konkrétně v&nbsp;případě první služby bude tato databáze
obsahovat tabulku nazvanou <strong>ORDERS</strong> (plus případné další
potřebné tabulky) a druhá služba pak bude obsahovat tabulku
<strong>CUSTOMERS</strong>. Již zde ovšem nebude možné nadeklarovat referenční
integritu, tj.&nbsp;definovat cizí klíč v&nbsp;podřízené tabulce
<strong>ORDERS</strong>:</p>

<pre>
CUSTOMER_ID   INT NOT NULL references CUSTOMERS(ID),
</pre>

<p>Samotné &bdquo;rozseknutí&ldquo; databáze na dvě samostatné databáze však
navíc vede k&nbsp;tomu, že ztratíme všechny vlastnosti ACIDu poskytované
vlastním databázovým systémem a pokud ACID (či některou z&nbsp;jeho čtyř
vlastností) budeme potřebovat, musíme ho nějakým způsobem reimplementovat.</p>

<a href="https://www.root.cz/obrazek/361668/"><img src="https://i.iinfo.cz/images/447/microservices2-1-prev.png" class="image-361668" alt="&#160;" width="370" height="222" /></a>
<p><i>Obrázek 3: Mikroslužby <strong>customer service</strong> a <strong>order
service</strong>, každá se svou vlastní databází.</i></p>



<p><a name="k07"></a></p>
<h2 id="k07">7. Dvoufázový commit v&nbsp;mikroslužbách?</h2>

<p>V&nbsp;klasických distribuovaných systémech se pro tento účel používá
dvoufázový commit neboli <i>two-phase commit</i>, zkráceně též <i>2PC</i>.
Teoreticky je pochopitelně možné dvoufázový commit použít i u aplikace založené
na mikroslužbách, ale tento koncept se v&nbsp;praxi příliš nedoporučuje
používat, neboť se tím zvyšuje počet zpráv posílaných mezi jednotlivými
mikroslužbami, služby jsou na úrovni databází propojené do větší míry, než je
většinou akceptovatelné a navíc se tím ztrácí i požadavek na to, aby byla
aplikace funkční i při (krátkodobém či střednědobém) výpadku jednotlivých uzlů;
zde konkrétně dojde k&nbsp;problému při výpadku uzlu, který celou transakci
musí koordinovat. Kromě toho vyžaduje dvoufázový commit předání několika zpráv
(minimálně čtyř), což může být u vysoce zatížených aplikací příliš mnoho. A
navíc, což je praktičtější problém: mnohé NoSQL databáze, brokery atd. koncept
dvoufázového commitu prozatím nepodporují.</p>



<p><a name="k08"></a></p>
<h2 id="k08">8. Další možnost: kompenzační transakce</h2>

<p>Jedna z&nbsp;náhrad dvoufázových commitů spočívá ve využití takzvaných
kompenzačních transakcí (což s&nbsp;velkou pravděpodobností není ustálený český
ekvivalent termínu <i>compensating transaction</i>). Princip je vlastně velmi
jednoduchý (o to komplikovanější bývá jeho nasazení v&nbsp;praxi): v&nbsp;každé
databázi se provádí změny v&nbsp;transakcích, ovšem pro každou takovou
transakci musí existovat i opačná operace, která původní transakci vyruší. Tato
kompenzační transakce je typicky vyvolána jinou službou. V&nbsp;našem
konkrétním případě by jedna z&nbsp;transakcí spočívala ve vyřízení objednávky
pro daného uživatele <strong>CUSTOMER.ID</strong> ve službě <strong>order
service</strong>. V&nbsp;tento okamžik by byla (například přes orchestraci nebo
choreografii) informována služba <strong>customer service</strong>, aby snížila
kredit pro zákazníka. Ovšem pokud kredit klesne na nulu, bude nutné objednávku
zrušit &ndash; a právě to je úkol pro kompenzační transakci.</p>

<img src="https://i.iinfo.cz/images/447/microservices2-2.png" class="image-361669" alt="&#160;" width="424" height="251" />
<p><i>Obrázek 4: Transakce a kompenzační transakce. Každá transakce je
provedena jinou mikroslužbou, ovšem pokud dojde ke vzniku chyby (malý kredit
atd.) je vyvolána zpětná transakce. Na tomto obrázku jsou běžné transakce
nazvány Tx, zpětné transakce Cx.</i></p>

<p><div class="rs-tip-major">Poznámka: situace je samozřejmě ještě složitější
ve chvíli, kdy se zákazník pokusí provést více objednávek.</div></p>



<p><a name="k09"></a></p>
<h2 id="k09">9. Použití nástrojů pro streaming: záznam a přehrávání sekvence událostí</h2>

<p>Připomeňme si, že jedním ze základních konceptů, na nichž jsou mikroslužby
založeny, je použití vzájemně izolovaných databází pro každou mikroslužbu, což
je jeden z&nbsp;přístupů umožňujících škálování jak samotné aplikace, tak i
vývojových týmů. Pochopitelně je však nutné nějakým způsobem zajistit, aby se
změny provedené v&nbsp;jedné databázi (změna limitu kreditu u zákazníka)
nějakým způsobem promítly do další služby. Jedním ze způsobů, jak to zařídit (a
to navíc poměrně elegantním způsobem) je využití nástrojů pro <i>streaming</i>.
Typicky se jedná o systém <a href="https://kafka.apache.org/">Apache Kafka</a>
popř.&nbsp;na Rootu popsaný nástroj <a
href="https://www.root.cz/clanky/nats-streaming-server/">NATS Streaming
Server</a>. Tyto nástroje umožňují zaznamenávat a později přehrávat
(<i>replay</i>) záznamy s&nbsp;informacemi o událostech, k&nbsp;nimž
v&nbsp;aplikaci došlo. Na tyto události mohou reagovat další mikroslužby a
případně na jejich základu provádět změny ve vlastní databázi.</p>



<p><a name="k10"></a></p>
<h2 id="k10">10. Koncepty, na nichž je streaming založen</h2>

<p>Streaming je založen na příjímaní a ukládání zpráv se zaručeným pořadím. Po
příjmu je každé zprávě přidělen jednoznačný celočíselný offset (a většinou i
časové razítko). To, že každá zpráva uložená do oddílu má přiřazen offset,
umožňuje, aby konzumenti zpráv specifikovali, od jakého offsetu potřebují
zprávy přijímat. Díky tomu je možné, aby se konzumenti připojovali a odpojovali
v&nbsp;jakýkoli okamžik a přitom měli možnost řídit, s&nbsp;jakými zprávami
budou pracovat. Konzument se například po pozdějším připojení může rozhodnout,
že bude zpracovávat nejnovější data a na případná starší data si (možná)
vyhradí svůj strojový čas později. Umožněn je i takzvaný <i>replay</i>,
tj.&nbsp;zpracování určité sekvence zpráv z&nbsp;minulosti. Postačuje znát jen
offset první zprávy ze sekvence.</p>

<p>Samotné posílání zpráv konzumentů si přitom řídí sami konzumenti, kteří si
zprávy (téma+oddíl+offset) musí vyžádat. Díky tomu si sami konzumenti určují,
kolik zpráv zpracují a jak tedy budou zatíženi.</p>

<p>To však ve skutečnosti není vše, protože zprávy poslané do message brokera
s&nbsp;podporou streamingu se v&nbsp;čase chovají odlišně, než v&nbsp;případě
použití běžné fronty. Zprávy jsou totiž rozšířeny o již výše zmíněné pořadové
číslo a většinou i o časové razítko. Takto rozšířené zprávy jsou uloženy do
takzvaného <i>logu</i> s&nbsp;daným tématem, kde jsou uchovány buď po neomezeně
dlouhou dobu, nebo až do chvíle, kdy je překročena kapacita logu
popř.&nbsp;maximální doba životnosti zprávy. Pokud dojde k&nbsp;alespoň jedné
této události, budou nejstarší zprávy smazány (kapacita logu je většinou zadána
jak celkovým objemem, tak i maximálním počtem zpráv, což je ostatně i případ
NATS Streaming Serveru). Nezáleží tedy na tom, zda a kolika konzumenty byla
zpráva přečtena a zpracována &ndash; přečtení a zpracování zprávy nemá vliv na
její umístění v&nbsp;logu, což vlastně znamená, že většinou dochází
k&nbsp;určitému zesložitění konzumentů, kteří si musí pamatovat, které zprávy
s&nbsp;daným tématem již zpracovaly a které nikoli.</p>

<p>Aby bylo možné konfigurovat a řídit, které zprávy mají být na message
brokeru uloženy a které již smazány, specifikuje se takzvaný <i>retention
time</i> zajišťující, aby počet zpráv/záznamů nepřekročil časovou mez. Mnohé
streaming servery dokážou omezit i celkový počet zpráv, počet zpráv
v&nbsp;tématu a/nebo počet zpráv na jednom serveru v&nbsp;clusteru. Totéž
omezení je možné aplikovat na celkovou velikost použitého paměťového či
diskového prostoru.</p>

<p>Dále se u streaming serverů setkáme s&nbsp;možností zapojení více serverů do
clusteru, což podporuje jak dnes popisovaný NATS Streaming Server, tak i Apache
Kafka.</p>



<p><a name="k11"></a></p>
<h2 id="k11">11. Nejznámější systémy podporující streaming</h2>

<p>Mezi nejznámější a pravděpodobně nejčastěji nasazované systémy podporující
streaming patří projekt <i>Apache Kafka</i> a taktéž <a
href="https://www.root.cz/clanky/nats-streaming-server/">již dříve popsaný</a>
<i>NATS Streaming Server</i>. Použít je možné i službu AWS Kinesis, ovšem
Kinesis se většinou používá v&nbsp;jiném kontextu (tímto nástrojem se budeme
zabývat v&nbsp;samostatném článku). Nejznámější je ovšem první zmíněný projekt
&ndash; Apache Kafka.</p>

<img src="https://i.iinfo.cz/images/447/microservices2-3.png" class="image-361670" alt="&#160;" width="450" height="134" />
<p><i>Obrázek 5: Logo systému Kafka.</i></p>

<img src="https://i.iinfo.cz/images/447/microservices2-4.png" class="image-361671" alt="&#160;" width="460" height="113" />
<p><i>Obrázek 6: Logo systému NATS.</i></p>

<p>Mezi další systémy, tentokrát určené pro záznam neměnitelných logů
(událostí), patří například:</p>

<ol>
<li>Apache Pulsar</li>
<li>Azure Cosmos DB Change Feed</li>
<li>Azure EventHub</li>
<li>DistributedLog</li>
<li>Chronicle Queue</li>
<li>Pravega</li>
</ol>



<p><a name="k12"></a></p>
<h2 id="k12">12. Apache Kafka</h2>

<p></p>



<p><a name="k13"></a></p>
<h2 id="k13">13. </h2>

<p></p>



<p><a name="k14"></a></p>
<h2 id="k14">14. </h2>

<p></p>



<p><a name="k15"></a></p>
<h2 id="k15">15. </h2>

<p></p>



<p><a name="k16"></a></p>
<h2 id="k16">16. </h2>

<p></p>



<p><a name="k17"></a></p>
<h2 id="k17">17. </h2>

<p></p>



<p><a name="k18"></a></p>
<h2 id="k18">18. </h2>

<p></p>



<p><a name="k19"></a></p>
<h2 id="k19">19. </h2>



<p><a name="k20"></a></p>
<h2 id="k20">20. Odkazy na Internetu</h2>

<ol>

<li>Microservices - Not a free lunch!<br />
<a href="http://highscalability.com/blog/2014/4/8/microservices-not-a-free-lunch.html">http://highscalability.com/blog/2014/4/8/microservices-not-a-free-lunch.html</a>
</li>

<li>Microservices, Monoliths, and NoOps<br />
<a href="http://blog.arungupta.me/microservices-monoliths-noops/">http://blog.arungupta.me/microservices-monoliths-noops/</a>
</li>

<li>Microservice Design Patterns<br />
<a href="http://blog.arungupta.me/microservice-design-patterns/">http://blog.arungupta.me/microservice-design-patterns/</a>
</li>

<li>Vision of a microservice revolution<br />
<a href="https://www.jolie-lang.org/vision.html">https://www.jolie-lang.org/vision.html</a>
</li>

<li>Microservices: a definition of this new architectural term<br />
<a href="https://martinfowler.com/articles/microservices.html">https://martinfowler.com/articles/microservices.html</a>
</li>

<li>Mikroslužby<br />
<a href="http://voho.eu/wiki/mikrosluzba/">http://voho.eu/wiki/mikrosluzba/</a>
</li>

<li>Microservice Prerequisites<br />
<a href="https://martinfowler.com/bliki/MicroservicePrerequisites.html">https://martinfowler.com/bliki/MicroservicePrerequisites.html</a>
</li>

<li>Microservices in Practice, Part 1: Reality Check and Service Design (vyžaduje registraci)<br />
<a href="https://ieeexplore.ieee.org/document/7819415">https://ieeexplore.ieee.org/document/7819415</a>
</li>

<li>Microservice Trade-Offs<br />
<a href="https://www.martinfowler.com/articles/microservice-trade-offs.html">https://www.martinfowler.com/articles/microservice-trade-offs.html</a>
</li>

<li>What is a microservice? (from a linguistic point of view)<br />
<a href="http://claudioguidi.blogspot.com/2017/03/what-microservice-from-linguisitc.html">http://claudioguidi.blogspot.com/2017/03/what-microservice-from-linguisitc.html</a>
</li>

<li>Microservices (Wikipedia)<br />
<a href="https://en.wikipedia.org/wiki/Microservices">https://en.wikipedia.org/wiki/Microservices</a>
</li>

<li>Fallacies of distributed computing (Wikipedia)<br />
<a href="https://en.wikipedia.org/wiki/Fallacies_of_distributed_computing">https://en.wikipedia.org/wiki/Fallacies_of_distributed_computing</a>
</li>

<li>Service (systems architecture)<br />
<a href="https://en.wikipedia.org/wiki/Service_(systems_architecture)">https://en.wikipedia.org/wiki/Service_(systems_architecture)</a>
</li>

<li>Microservices in a Nutshell<br />
<a href="https://www.thoughtworks.com/insights/blog/microservices-nutshell">https://www.thoughtworks.com/insights/blog/microservices-nutshell</a>
</li>

<li>What is Microservices?<br />
<a href="https://smartbear.com/solutions/microservices/">https://smartbear.com/solutions/microservices/</a>
</li>

<li>Mastering Chaos - A Netflix Guide to Microservices<br />
<a href="https://www.youtube.com/watch?v=CZ3wIuvmHeM&t=17s">https://www.youtube.com/watch?v=CZ3wIuvmHeM&amp;t=17s</a>
</li>

<li>Messaging in Microservice Architecture<br />
<a href="https://www.youtube.com/watch?v=MkQWQ5f-SEY">https://www.youtube.com/watch?v=MkQWQ5f-SEY</a>
</li>

<li>Pattern: Messaging<br />
<a href="https://microservices.io/patterns/communication-style/messaging.html">https://microservices.io/patterns/communication-style/messaging.html</a>
</li>

<li>Microservices Messaging: Why REST Isn’t Always the Best Choice<br />
<a href="https://blog.codeship.com/microservices-messaging-rest-isnt-always-best-choice/">https://blog.codeship.com/microservices-messaging-rest-isnt-always-best-choice/</a>
</li>

<li>Protocol buffers<br />
<a href="https://developers.google.com/protocol-buffers/">https://developers.google.com/protocol-buffers/</a>
</li>

<li>BSON<br />
<a href="http://bsonspec.org/">http://bsonspec.org/</a>
</li>

<li>Apache Avro!<br />
<a href="https://avro.apache.org/">https://avro.apache.org/</a>
</li>

<li>REST vs Messaging for Microservices – Which One is Best?<br />
<a href="https://solace.com/blog/experience-awesomeness-event-driven-microservices/">https://solace.com/blog/experience-awesomeness-event-driven-microservices/</a>
</li>

<li>How did we end up here?<br />
<a href="https://gotocon.com/dl/goto-chicago-2015/slides/MartinThompson_and_ToddMontgomery_HowDidWeEndUpHere.pdf">https://gotocon.com/dl/goto-chicago-2015/slides/MartinThompson_and_ToddMontgomery_HowDidWeEndUpHere.pdf</a>
</li>

<li>Scaling microservices with message queues to handle data bursts<br />
<a href="https://read.acloud.guru/scaling-microservices-with-message-queue-2d389be5b139">https://read.acloud.guru/scaling-microservices-with-message-queue-2d389be5b139</a>
</li>

<li>Microservices: What are smart endpoints and dumb pipes?<br />
<a href="https://stackoverflow.com/questions/26616962/microservices-what-are-smart-endpoints-and-dumb-pipes">https://stackoverflow.com/questions/26616962/microservices-what-are-smart-endpoints-and-dumb-pipes</a>
</li>

<li>Common Object Request Broker Architecture<br />
<a href="https://en.wikipedia.org/wiki/Common_Object_Request_Broker_Architecture">https://en.wikipedia.org/wiki/Common_Object_Request_Broker_Architecture</a>
</li>

<li>Enterprise service bus<br />
<a href="https://en.wikipedia.org/wiki/Enterprise_service_bus">https://en.wikipedia.org/wiki/Enterprise_service_bus</a>
</li>

<li>Microservices vs SOA : What’s the Difference<br />
<a href="https://www.edureka.co/blog/microservices-vs-soa/">https://www.edureka.co/blog/microservices-vs-soa/</a>
</li>

<li>Pravda o SOA<br />
<a href="https://businessworld.cz/reseni-a-realizace/pravda-o-soa-2980">https://businessworld.cz/reseni-a-realizace/pravda-o-soa-2980</a>
</li>

<li>Is it a good idea for Microservices to share a common database?<br />
<a href="https://www.quora.com/Is-it-a-good-idea-for-Microservices-to-share-a-common-database">https://www.quora.com/Is-it-a-good-idea-for-Microservices-to-share-a-common-database</a>
</li>

<li>Pattern: Shared database<br />
<a href="https://microservices.io/patterns/data/shared-database.html">https://microservices.io/patterns/data/shared-database.html</a>
</li>

<li>Is a Shared Database in Microservices Actually an Anti-pattern?<br />
<a href="https://hackernoon.com/is-shared-database-in-microservices-actually-anti-pattern-8cc2536adfe4">https://hackernoon.com/is-shared-database-in-microservices-actually-anti-pattern-8cc2536adfe4</a>
</li>

<li>Shared database in microservices is a problem, yep<br />
<a href="https://ayende.com/blog/186914-A/shared-database-in-microservices-is-a-problem-yep">https://ayende.com/blog/186914-A/shared-database-in-microservices-is-a-problem-yep</a>
</li>

<li>Microservices with shared database? using multiple ORM's?<br />
<a href="https://stackoverflow.com/questions/43612866/microservices-with-shared-database-using-multiple-orms">https://stackoverflow.com/questions/43612866/microservices-with-shared-database-using-multiple-orms</a>
</li>

<li>Examples of microservice architecture<br />
<a href="https://www.coursera.org/lecture/intro-ibm-microservices/examples-of-microservice-architecture-JXOFj">https://www.coursera.org/lecture/intro-ibm-microservices/examples-of-microservice-architecture-JXOFj</a>
</li>

<li>Microservices: The Rise Of Kafka<br />
<a href="https://movio.co/blog/microservices-rise-kafka/">https://movio.co/blog/microservices-rise-kafka/</a>
</li>

<li>Building a Microservices Ecosystem with Kafka Streams and KSQL<br />
<a href="https://www.confluent.io/blog/building-a-microservices-ecosystem-with-kafka-streams-and-ksql/">https://www.confluent.io/blog/building-a-microservices-ecosystem-with-kafka-streams-and-ksql/</a>
</li>

<li>An introduction to Apache Kafka and microservices communication<br />
<a href="https://medium.com/@ulymarins/an-introduction-to-apache-kafka-and-microservices-communication-bf0a0966d63">https://medium.com/@ulymarins/an-introduction-to-apache-kafka-and-microservices-communication-bf0a0966d63</a>
</li>

<li>ACID (computer science)<br />
<a href="https://en.wikipedia.org/wiki/ACID_(computer_science)">https://en.wikipedia.org/wiki/ACID_(computer_science)</a>
</li>

<li>Distributed transaction<br />
<a href="https://en.wikipedia.org/wiki/Distributed_transaction">https://en.wikipedia.org/wiki/Distributed_transaction</a>
</li>

<li>Two-phase commit protocol<br />
<a href="https://en.wikipedia.org/wiki/Two-phase_commit_protocol">https://en.wikipedia.org/wiki/Two-phase_commit_protocol</a>
</li>

<li>Why is 2-phase commit not suitable for a microservices architecture?<br />
<a href="https://stackoverflow.com/questions/55249656/why-is-2-phase-commit-not-suitable-for-a-microservices-architecture">https://stackoverflow.com/questions/55249656/why-is-2-phase-commit-not-suitable-for-a-microservices-architecture</a>
</li>

<li>4 reasons why microservices resonate<br />
<a href="https://www.oreilly.com/ideas/4-reasons-why-microservices-resonate">https://www.oreilly.com/ideas/4-reasons-why-microservices-resonate</a>
</li>

<li>Pattern: Microservice Architecture<br />
<a href="https://microservices.io/patterns/microservices.html">https://microservices.io/patterns/microservices.html</a>
</li>

<li>Pattern: Monolithic Architecture<br />
<a href="https://microservices.io/patterns/monolithic.html">https://microservices.io/patterns/monolithic.html</a>
</li>

<li>Pattern: Saga<br />
<a href="https://microservices.io/patterns/data/saga.html">https://microservices.io/patterns/data/saga.html</a>
</li>

<li>Pattern: Database per service<br />
<a href="https://microservices.io/patterns/data/database-per-service.html">https://microservices.io/patterns/data/database-per-service.html</a>
</li>

<li>Pattern: Access token<br />
<a href="https://microservices.io/patterns/security/access-token.html">https://microservices.io/patterns/security/access-token.html</a>
</li>

<li>Databázová integrita<br />
<a href="https://cs.wikipedia.org/wiki/Datab%C3%A1zov%C3%A1_integrita">https://cs.wikipedia.org/wiki/Datab%C3%A1zov%C3%A1_integrita</a>
</li>

<li>Referenční integrita<br />
<a href="https://cs.wikipedia.org/wiki/Referen%C4%8Dn%C3%AD_integrita">https://cs.wikipedia.org/wiki/Referen%C4%8Dn%C3%AD_integrita</a>
</li>

<li>Introduction into Microservices <br />
<a href="https://specify.io/concepts/microservices">https://specify.io/concepts/microservices</a>
</li>

<li>Are Microservices ‘SOA Done Right’?<br />
<a href="https://intellyx.com/2015/07/20/are-microservices-soa-done-right/">https://intellyx.com/2015/07/20/are-microservices-soa-done-right/</a>
</li>

<li>The Hardest Part About Microservices: Your Data<br />
<a href="https://blog.christianposta.com/microservices/the-hardest-part-about-microservices-data/">https://blog.christianposta.com/microservices/the-hardest-part-about-microservices-data/</a>
</li>

<li>From a monolith to microservices + REST<br />
<a href="https://www.slideshare.net/InfoQ/from-a-monolith-to-microservices-rest-the-evolution-of-linkedins-service-architecture">https://www.slideshare.net/InfoQ/from-a-monolith-to-microservices-rest-the-evolution-of-linkedins-service-architecture</a>
</li>

<li>DevOps and the Myth of Efficiency, Part I<br />
<a href="https://blog.christianposta.com/devops/devops-and-the-myth-of-efficiency-part-i/">https://blog.christianposta.com/devops/devops-and-the-myth-of-efficiency-part-i/</a>
</li>

<li>DevOps and the Myth of Efficiency, Part II<br />
<a href="https://blog.christianposta.com/devops/devops-and-the-myth-of-efficiency-part-ii/">https://blog.christianposta.com/devops/devops-and-the-myth-of-efficiency-part-ii/</a>
</li>

<li>Standing on Distributed Shoulders of Giants: Farsighted Physicists of Yore Were Danged Smart!<br />
<a href="https://queue.acm.org/detail.cfm?id=2953944">https://queue.acm.org/detail.cfm?id=2953944</a>
</li>

<li>Building DistributedLog: High-performance replicated log service<br />
<a href="https://blog.twitter.com/engineering/en_us/topics/infrastructure/2015/building-distributedlog-twitter-s-high-performance-replicated-log-servic.html">https://blog.twitter.com/engineering/en_us/topics/infrastructure/2015/building-distributedlog-twitter-s-high-performance-replicated-log-servic.html</a>
</li>

<li>Turning the database inside-out with Apache Samza<br />
<a href="https://www.confluent.io/blog/turning-the-database-inside-out-with-apache-samza/">https://www.confluent.io/blog/turning-the-database-inside-out-with-apache-samza/</a>
</li>

<li>Debezium: Stream changes from your databases.<br />
<a href="https://debezium.io/">https://debezium.io/</a>
</li>

<li>Change data capture<br />
<a href="https://en.wikipedia.org/wiki/Change_data_capture">https://en.wikipedia.org/wiki/Change_data_capture</a>
</li>

<li>Apache Samza (Wikipedia)<br />
<a href="https://en.wikipedia.org/wiki/Apache_Samza">https://en.wikipedia.org/wiki/Apache_Samza</a>
</li>

<li>Storm (event processor)<br />
<a href="https://en.wikipedia.org/wiki/Storm_(event_processor)">https://en.wikipedia.org/wiki/Storm_(event_processor)</a>
</li>

<li>kappa-architecture.com<br />
<a href="http://milinda.pathirage.org/kappa-architecture.com/">http://milinda.pathirage.org/kappa-architecture.com/</a>
</li>

<li>Questioning the Lambda Architecture<br />
<a href="https://www.oreilly.com/ideas/questioning-the-lambda-architecture">https://www.oreilly.com/ideas/questioning-the-lambda-architecture</a>
</li>

<li>Lambda architecture<br />
<a href="https://en.wikipedia.org/wiki/Lambda_architecture">https://en.wikipedia.org/wiki/Lambda_architecture</a>
</li>

<li>Event stream processing<br />
<a href="https://en.wikipedia.org/wiki/Event_stream_processing">https://en.wikipedia.org/wiki/Event_stream_processing</a>
</li>

<li>How to beat the CAP theorem<br />
<a href="http://nathanmarz.com/blog/how-to-beat-the-cap-theorem.html">http://nathanmarz.com/blog/how-to-beat-the-cap-theorem.html</a>
</li>

</ol>



<p></p><p></p>
<p><small>Autor: <a href="http://www.fit.vutbr.cz/~tisnovpa">Pavel Tišnovský</a> &nbsp; 2019</small></p>
</body>
</html>

