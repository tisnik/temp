<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
        "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html>
<head>
<title>Použití nástroje Apache Kafka v aplikacích založených na mikroslužbách</title>
<meta name="Author" content="Pavel Tisnovsky" />
<meta name="Generator" content="vim" />
<meta http-equiv="content-type" content="text/html; charset=utf-8" />
<style type="text/css">
         body {color:#000000; background:#ffffff;}
         h1  {font-family: arial, helvetica, sans-serif; color:#ffffff; background-color:#c00000; text-align:center; padding-left:1em}
         h2  {font-family: arial, helvetica, sans-serif; color:#ffffff; background-color:#0000c0; padding-left:1em; text-align:left}
         h3  {font-family: arial, helvetica, sans-serif; color:#000000; background-color:#c0c0c0; padding-left:1em; text-align:left}
         h4  {font-family: arial, helvetica, sans-serif; color:#000000; background-color:#e0e0e0; padding-left:1em; text-align:left}
         a   {font-family: arial, helvetica, sans-serif;}
         li  {font-family: arial, helvetica, sans-serif; color:#000000; text-align:justify; width:450px;}
         ol  {font-family: arial, helvetica, sans-serif; color:#000000; text-align:justify; width:450px;}
         ul  {font-family: arial, helvetica, sans-serif; color:#000000; text-align:justify; width:450px;}
         p   {font-family: arial, helvetica, sans-serif; color:#000000; text-align:justify;}
         pre {background:#e0e0e0}
</style>
</head>

<body>

<h1>Použití nástroje Apache Kafka v aplikacích založených na mikroslužbách</h1>

<h3>Pavel Tišnovský</h3>

<p></p>

<h1>Úvodník</h1>

<p>Již několikrát jsme se v tomto seriálu setkali s nástrojem <i>Apache Kafka</i>. Jedná se o velmi často používaný (někdy i nadužívaný) nástroj, o jehož základních možnostech se v kontextu mikroslužeb zmíníme.</p>



<h2>Obsah</h2>

<p><a href="#k01">1. Použití nástroje Apache Kafka v&nbsp;aplikacích založených na mikroslužbách</a></p>
<p><a href="#k02">2. Klasické systémy s&nbsp;frontami zpráv &ndash; <strong>PUSH-PULL</strong></a></p>
<p><a href="#k03">3. Rozesílání zpráv se strategií <strong>PUBLISH-SUBSCRIBE</strong></a></p>
<p><a href="#k04">4. Když nejsou možnosti klasických message brokerů dostačující...</a></p>
<p><a href="#k05">5. Shrnutí některých úskalí a problémů klasických message brokerů</a></p>
<p><a href="#k06">6. Práce se zprávami v&nbsp;systému Apache Kafka</a></p>
<p><a href="#k07">7. Témata a oddíly</a></p>
<p><a href="#k08">8. Replikace</a></p>
<p><a href="#k09">9. Kafka Streams</a></p>
<p><a href="#k10">10. Ekosystém Apache Kafky</a></p>
<p><a href="#k11">11. Použití systému Apache Kafka z&nbsp;různých programovacích jazyků</a></p>
<p><a href="#k12">12. Nástroj <strong>kafkacat</strong></a></p>
<p><a href="#k13">13. Příklady použití Apache Kafka</a></p>
<p><a href="#k14">14. Logovací platforma</a></p>
<p><a href="#k15">15. Architektura lambda</a></p>
<p><a href="#k16">16. Architektura kappa</a></p>
<p><a href="#k17">17. Apache Kafka ve funkci message brokera s&nbsp;frontami zpráv</a></p>
<p><a href="#k18">18. Alternativní řešení</a></p>
<p><a href="#k19">19. Odkazy na Internetu</a></p>



<p><a name="k01"></a></p>
<h2 id="k01">1. Použití nástroje Apache Kafka v aplikacích založených na mikroslužbách</h2>

<p>Ve čtvrté části <a href="https://www.root.cz/serialy/mikrosluzby/">seriálu o
mikroslužbách</a> se seznámíme se základními vlastnostmi projektu <i>Apache
Kafka</i>, který se v&nbsp;posledních několika letech stal velmi populární, a
to nikoli pouze u aplikací založených na mikroslužbách, ale i v&nbsp;dalších
oborech (zmiňme například oblasti jako <i>Machine Learning</i>, <i>Big data</i>
atd.). Díky konceptům, na nichž je projekt Kafka založen, je možné tento systém
použít v&nbsp;několika oblastech, například ve funkci distribuovaného logu,
databáze událostí (<i>events</i>), zobecněného message brokera, je ústředním
prvkem architektur <i>lambda</i> a <i>kappa</i>, příjemci zpráv se mohou
sdružovat do skupin atd. Ovšem i další vlastnosti, které projekt Kafka nabízí,
jsou velmi užitečné. Jedná se především o možnost nasazení celého clusteru
brokerů řízených z&nbsp;jednoho místa, možnost replikace záznamů (zpráv,
událostí), řízení, které zprávy mají být zachovány a které (ty starší) smazány
apod. Existují samozřejmě i alternativy k&nbsp;tomuto projektu, například
v&nbsp;závěru zmíněný NATS Streaming Server, ovšem ty většinou nenabízí všechny
výše zmíněné možnosti.</p>

<p><div class="rs-tip-major">Poznámka: samotné jméno systému <i>Apache
Kafka</i> (dříve, dokud se projekt nestal součástí projektu <a
href="http://apache.org/">Apache</a> jen <i>Kafka</i>) je odvozeno od příjmení
slavného spisovatele <a href="https://en.wikipedia.org/wiki/Franz_Kafka">Franze
Kafky</a>. Ovšem v&nbsp;běžné řeči se docela často mluví o &bdquo;té
kafce&ldquo; (kavce), tj.&nbsp;používá se ženský rod. V&nbsp;tomto článku se
budu snažit používat neutrální spojení &bdquo;systém Kafka&ldquo;,
&bdquo;projekt Kafka&ldquo;.</div></p>

<img src="https://i.iinfo.cz/images/447/microservices2-3.png" class="image-361670" alt="&#160;" width="450" height="134" />
<p><i>Obrázek 1: Logo nástroje Apache Kafka, kterému se budeme dnes
věnovat.</i></p>



<p><a name="k02"></a></p>
<h2 id="k02">2. Klasické systémy s&nbsp;frontami zpráv &ndash; <strong>PUSH-PULL</strong></h2>

<p>Nástroj Apache Kafka je určen především pro práci s&nbsp;kontinuálním tokem
zpráv (popř.&nbsp;událostí), které jsou v&nbsp;Kafce určitým způsobem uloženy
(typicky se zaručeným pořadím &ndash; viz další text) a je je možné zpracovávat
konzumenty (příjemci zpráv), kteří si sami určují, jaké zprávy budou potřebovat
a dokonce i v&nbsp;jakém pořadí. Možnosti Kafky rozšiřují a zobecňují
vlastnosti klasických message brokerů. Připomeňme si, že většina message
brokerů nabízí dva způsoby doručování zpráv. Jedná se o způsob (strategii)
nazvaný <strong>PUSH-PULL</strong> a dále o způsob pojmenovaný
<strong>PUBLISH-SUBSCRIBE</strong>.</p>

<p>První komunikační strategie, která se někdy nazývá
<strong>PUSH-PULL</strong> či pouze <strong>queueing</strong>, je založena na
pojmenovaných frontách zpráv (<strong>message queue</strong>) implementovaných
v&nbsp;message brokerovi. Zpráva bývá v&nbsp;tomto případě doručena jen
jedinému konzumentovi a pokud žádný konzument není k&nbsp;frontě připojen,
zůstane zpráva ve frontě uložena (teoreticky) po libovolně dlouhou dobu.
Message broker v&nbsp;takovém případě typicky podporuje <i>perzistenci</i>
zpráv, které tak dokážou přečkat jeho případné restarty. Mnoho message brokerů
navíc umožňuje, aby konzumenti potvrzovali zpracování zprávy, popř.&nbsp;je
dokonce možné provádět transakce. K&nbsp;pojmenovaným frontám se potom
přidávají další specializované fronty na nezpracované zprávy (<i>DLQ &ndash;
Dead Letters Queue</i>).</p>

<a href="https://www.root.cz/obrazek/348762/"><img src="https://i.iinfo.cz/images/176/rabbitmq1-1-prev.png" class="image-348762" alt="&#160;" width="370" height="62" /></a>
<p><i>Obrázek 2: Komunikační strategie <strong>PUSH-PULL</strong>.</i></p>



<p><a name="k03"></a></p>
<h2 id="k03">3. Rozesílání zpráv se strategií <strong>PUBLISH-SUBSCRIBE</strong></h2>

<p>Druhá komunikační strategie podporovaná většinou message brokerů se nazývá
<strong>PUBLISH-SUBSCRIBE</strong> (neboli zkráceně <strong>PUB-SUB</strong>) a
spočívá v&nbsp;tom, že se zprávy s&nbsp;nastaveným tématem (<i>topic</i>,
<i>subject</i>) posílají do message brokera, který tyto zprávy ihned přeposílá
konzumentům přihlášeným k&nbsp;danému tématu. V&nbsp;případě, že žádný takový
konzument neexistuje, je zpráva zahozena. Pokud konzumentů daného tématu naopak
existuje větší množství, je zpráva doručena všem takovým konzumentům. Samotný
message broker v&nbsp;tomto případě nepotřebuje zprávy ukládat, takže se
většinou nesetkáme ani s&nbsp;podporou pro persistenci zpráv. Příkladem
takového systému je například systém <a
href="https://www.root.cz/clanky/pouziti-message-brokeru-nats/">NATS</a> (bez
dalších rozšíření).</p>

<a href="https://www.root.cz/obrazek/348764/"><img src="https://i.iinfo.cz/images/176/rabbitmq1-3-prev.png" class="image-348764" alt="&#160;" width="370" height="125" /></a>
<p><i>Obrázek 3: Komunikační strategie <strong>PUBLISH-SUBSCRIBE</strong>.</i></p>

<p><div class="rs-tip-major">Poznámka: ve skutečnosti je možné tuto strategii
realizovat dvěma způsoby. První z&nbsp;těchto způsobů roztřiďuje zprávy pro
jednotlivé konzumenty již v&nbsp;message brokeru (který tak může být poměrně
silně zatěžován), druhý způsob naopak přeposílá zprávy všem aktuálně připojeným
konzumentům s&nbsp;tím, že si konzumenti filtraci provedou sami u sebe,
například s&nbsp;využitím mnohem složitějších pravidel. Záleží na konkrétní
situaci, který způsob použít, ovšem první způsob je v&nbsp;praxi
používanější.</div></p>



<p><a name="k04"></a></p>
<h2 id="k04">4. Když nejsou možnosti klasických message brokerů dostačující...</h2>

<p>V&nbsp;aplikacích, jejichž architektura je založena na mikroslužbách, se
s&nbsp;klasickými message brokery setkáme velmi často. Doručování zpráv typu
<strong>PUSH-PULL</strong> přes message brokera nejenže umožňuje, aby byly obě
komunikující strany co nejvíce odděleny, ale je automaticky podporován i
<i>load balancing</i>, systém se &bdquo;vzpamatuje&ldquo; i z&nbsp;případných
restartů konzumentů a existuje zde i možnost naplánování některých náročnějších
úloh až do okamžiku, kdy je k&nbsp;dispozici dostatek systémových prostředků
(<i>clearing</i> prováděný v&nbsp;noci atd.). Navíc, pokud je použit kvalitní
message broker, je zajištěna persistence zpráv, někdy i jejich replikace a
další vlastnosti, které od systému určeného pro mnohdy enormní zátěže
očekáváme. Nesmíme zapomenout ani na to, že konzumenti (příjemci zpráv) si
nemusí pamatovat, kterou zprávu zpracovávaly naposledy &ndash; toto je
automaticky zajištěno samotnou sémantikou fungování fronty (konzument tedy může
být bezstavový a tím pádem mnohem snadněji škálovatelný atd.).</p>

<a href="https://www.root.cz/obrazek/348765/"><img src="https://i.iinfo.cz/images/176/rabbitmq1-4-prev.png" class="image-348765" alt="&#160;" width="370" height="158" /></a>
<p><i>Obrázek 4: Složitější konfigurace nabízená například systémem RabbitMQ.</i></p>

<p>I strategie <strong>PUBLISH-SUBSCRIBE</strong> má v&nbsp;aplikacích
založených na mikroslužbách své místo. Jednotlivé komponenty se mohou navzájem
informovat o událostech, ke kterým došlo, mohou tímto způsobem předávat příkazy
(<i>command</i>) s&nbsp;tím, že opět platí, že producent zpráv nemusí být pevně
spojen s&nbsp;případnými konzumenty (a nemusí ani vědět o jejich
existenci).</p>

<p>V&nbsp;některých případech nám ovšem nemusí ani jedna z&nbsp;těchto
strategií vyhovovat a navíc &ndash; <strong>PUSH-PULL</strong> může být pro
mnohé aplikace relativně pomalý způsob předávání zpráv, zejména
v&nbsp;porovnání s&nbsp;řešením, s&nbsp;nímž se seznámíme v&nbsp;navazujících
kapitolách.</p>

<p>Jedním z&nbsp;problémů může být, že v&nbsp;klasickým message brokerech
orientovaných na komunikaci s&nbsp;využitím zpráv je každá zpráva většinou
spravována izolovaně od ostatních zpráv. I když některé implementace message
brokerů podporují prioritní fronty, není obecně vyžadováno (a ani se to
neočekává), aby se zprávy doručovaly přesně v&nbsp;takovém pořadí, v&nbsp;jakém
je message broker přijímá (což je u pojmenovaných front problematické).</p>

<p>Dále existují některé problémy, které se s&nbsp;použitím klasickým message
brokerů implementují velmi složitě popř.&nbsp;je nelze (na rozumném HW či na
cenově dostupném clusteru) implementovat vůbec. Příkladem může být systém pro
zaznamenání událostí, ovšem v&nbsp;tom pořadí, v&nbsp;jakém události vznikly a
s&nbsp;možností zpětného přehrávání (<i>replay</i>) zpráv/událostí. A právě pro
řešení těchto problémů vznikl koncept <i>streamingu</i> zpráv implementovaný
právě v&nbsp;systému Apache Kafka.</p>



<p><a name="k05"></a></p>
<h2 id="k05">5. Shrnutí některých úskalí a problémů klasických message brokerů</h2>

<p>Shrňme si tedy některá úskalí klasických message brokerů založených na obou
výše popsaných komunikačních strategiích. Většina těchto úskalí je do větší či
menší míry řešena moderními streaming brokery:</p>

<ol>

<li>U strategie <strong>PUBLISH-SUBSCRIBE</strong> získají zprávu jen ti
konzumenti, kteří jsou v&nbsp;daný okamžik přihlášeni k&nbsp;příjmu zpráv.
Pokud je nějaký konzument z&nbsp;nějakého důvodu odpojený, zprávu již nikdy
později nedostane. V&nbsp;případě streamingu si čtení zpráv od zadaného
okamžiku řídí samotný konzument zpráv, pochopitelně s&nbsp;tím omezením, že se
starší (většinou mnohem starší) zprávy mohou automaticky odstraňovat na základě
kritérií nastavených administrátorem (někdy to ovšem znamená, že si konzument
musí pamatovat například offset poslední zpracované zprávy).</li>

<li>U strategie <strong>PUSH-PULL</strong> je jednou doručená zpráva
z&nbsp;message brokera (přesněji řečeno z&nbsp;fronty implementované
v&nbsp;message brokeru) odstraněna a nelze se k&nbsp;ní později vrátit. Tím
pádem pochopitelně není umožněna ani podpora pro přehrávání zpráv
(<i>replay</i>). I toto je do značné míry vyřešeno v&nbsp;případě nasazení
streamingu; vše je omezeno nastavením provedeném administrátorem (a teoreticky
existuje pouze jedno omezení na 2<sup>63</sup>-1 zpráv v&nbsp;jedné oblasti,
což však v&nbsp;praxi prakticky nelze dosáhnout).</li>

<li>Původní strategie <strong>PUSH-PULL</strong> navíc předpokládá, že se
zpráva doručí jen jedinému konzumentovi. Někteří message brokeři ovšem
podporují i rozšíření funkcionality a implementují tak kombinaci obou
strategií, jak <strong>PUBLISH-SUBSCRIBE</strong>, tak i
<strong>PUSH-PULL</strong> (dobrým příkladem může být RabbitMQ, viz též obrázek
číslo 4). Streaming servery používají zobecněnou strategii
<strong>PUBLISH-SUBSCRIBE</strong>, takže toto omezení nemají, pochopitelně při
správném nastavení témat a jejich replikací.</li>


<li>U strategie <strong>PUSH-PULL</strong> je jednou doručená zpráva z&nbsp;message brokera (přesněji řečeno z&nbsp;fronty) odstraněna a nelze se k&nbsp;ní později vrátit. Tím pádem pochopitelně není podporována ani podpora pro přehrávání zpráv (<i>replay</i>).</li>

<li>Původní strategie <strong>PUSH-PULL</strong> navíc předpokládá, že se zpráva doručí jen jedinému konzumentovi. Někteří message brokeři ovšem podporují i rozšíření funkcionality a implementují tak kombinaci obou strategií, jak <strong>PUBLISH-SUBSCRIBE</strong>, tak i <strong>PUSH-PULL</strong> (dobrým příkladem může být RabbitMQ).</li>

<li>U strategie <strong>PUSH-PULL</strong> se v&nbsp;případě výchozího chování nijak nespecifikuje maximální počet zpráv ve frontě popř.&nbsp;maximální povolené obsazení místa na disku. V&nbsp;případě, že budou konzumenti delší dobu odpojeni, se může jednat o potenciální problém (opět platí, že u některých message brokerů se můžeme setkat s&nbsp;určitou podporu pro mazání starších zpráv při dosažení administrátorem specifikovaných limitů).</li>

<li>Problematický může být i relativně nízký výkon přeposílání zpráv systémem <strong>PUSH-PULL</strong> (přibližně do limitu 100 000 zpráv za sekundu při použití RabbitMQ v&nbsp;clusteru, zatímco systémy založené na Kafce mohou mít i řádově vyšší rychlost práce se zprávami).</li>

</ol>



<p><a name="k05"></a></p>
<h2 id="k05">5. Práce se zprávami v&nbsp;systému Apache Kafka</h2>

<p>V&nbsp;systému Apache Kafka se se zprávami (které se zde ale typicky nazývají záznamy, <i>record</i>) pracuje poněkud odlišným způsobem, který do jisté míry kombinuje jak možnosti klasické fronty zpráv, tak i rozesílání zpráv systémem <strong>PUBLISH-SUBSCRIBE</strong>. Zprávy se ovšem neukládají do fronty, ale (v&nbsp;tom zcela nejjednodušším případě) do neustále rostoucí sekvence záznamů, přičemž každému záznamu je přiřazeno jednoznačné číslo &ndash; <i>offset</i>. Z&nbsp;pohledu zdroje zpráv (<i>publisher</i>) vlastně nedochází k&nbsp;žádné podstatnější změně. Rozdílné je ovšem další zpracování záznamů. Tyto záznamy mohou číst příjemci zpráv (<i>subscribeři</i>), kteří si sami zvolí, od jakého <i>offsetu</i> potřebují zprávy přečíst.</p>

<p>Přečtením ovšem zpráva nezanikne, na rozdíl od klasické fronty, kde operace <strong>PULL</strong> zprávu z&nbsp;fronty navždy odstraní a message broker ji odstraní ze své paměti. A je zde i rozdíl oproti systému <strong>PUBLISH-SUBSCRIBE</strong>, protože <i>subscriber</i> zprávu může získat kdykoli později &ndash; nemusí být tedy připraven zprávu zpracovat v&nbsp;ten přesný okamžik, kdy je zpráva message brokerem rozesílána.</p>

<p>To však není jediná změna či vylepšení. Vzhledem k&nbsp;tomu, že příjemci zpráv (<i>subscribeři</i>) si sami volí offset, od kterého chtějí zprávy číst, je možné provádět takzvanou operaci <i>replay</i>, což není nic jiného, než nové zpracování zpráv od jejich začátku, od určitého (třeba i relativně zadaného časového okamžiku) atd. Tato vlastnost má dosti závažné důsledky pro oblasti, v&nbsp;nichž se systém Apache Kafka nasazuje. Umožňuje totiž postupné přidávání nových příjemců zpráv, kteří ihned mohou začít zpracovávat i historické záznamy. Ostatně to je i jeden z&nbsp;důvodů, proč je Apache Kafka tak populární v&nbsp;oblasti strojového učení (<i>machine learning</i> &ndash; <i>ML</i>), protože umožňuje prakticky dokonalé oddělení systémů sloužících pro sběr dat od modulů, které tato data nějakým způsobem dále zpracovávají.</p>



<p><a name="k05"></a></p>
<h2 id="k05">5. </h2>



<p><a name="k06"></a></p>
<h2 id="k06">6. </h2>



<p><a name="k07"></a></p>
<h2 id="k07">7. </h2>



<p><a name="k08"></a></p>
<h2 id="k08">8. Použití systému Apache Kafka z&nbsp;různých programovacích jazyků</h2>

<p>Samotný systém Apache Kafka je naprogramován v&nbsp;Javě, takže jeho primární platformou je pochopitelně JVM (<i>Java Virtual Machine</i>). To však pochopitelně neznamená, že se Kafka nedá použít i z&nbsp;dalších programovacích jazyků. Ve skutečnosti existují rozhraní pro prakticky všechny používané a/nebo populární (což není v&nbsp;IT vždy totéž) programovací jazyky. Tato rozhraní jsou vypsána v&nbsp;následující tabulce:</p>

<table>
<tr><th> #</th><th>Jazyk/platforma</th></tr>
<tr><td> 1</td><td><a href=""></a></td></tr>
<tr><td> 2</td><td><a href=""></a></td></tr>
<tr><td> 3</td><td><a href=""></a></td></tr>
<tr><td> 4</td><td><a href=""></a></td></tr>
<tr><td> 5</td><td><a href=""></a></td></tr>
<tr><td> 6</td><td><a href=""></a></td></tr>
<tr><td> 7</td><td><a href=""></a></td></tr>
<tr><td> 8</td><td><a href=""></a></td></tr>
<tr><td> 9</td><td><a href=""></a></td></tr>
<tr><td>10</td><td><a href=""></a></td></tr>
</table>



<p><a name="k09"></a></p>
<h2 id="k09">9. Ekosystém Apache Kafky</h2>

<p>Vzhledem k&nbsp;popularitě Kafky pravděpodobně nebude velkým překvapením, že okolo ní vznikl celý rozsáhlý ekosystém.</p>



<p><a name="k10"></a></p>
<h2 id="k10">10. Příklady použití Apache Kafka</h2>

<p>V&nbsp;navazujících kapitolách se zmíníme o některých možnostech použití Apache Kafky. Uvidíme, že možnosti nasazení Kafky jsou skutečně dosti široké a přesahují oblasti, v&nbsp;nichž jsou nasazováni klasičtí <i>message brokeři</i>. Většina příkladů použití je založena na možnosti přehrávání (<i>replay</i>) uložených záznamů.</p>



<p><a name="k11"></a></p>
<h2 id="k11">11. Logovací platforma</h2>

<p>V&nbsp;současnosti se používá poměrně velké množství systémů zajišťujících ukládání a základní zpracování logovacích informací, a to i ve chvíli, kdy se logy zpracovávají z&nbsp;distribuovaných zdrojů. Mezi často používané systémy patří například <a href="">Splunk</a>, <a href="">Snare</a> či <a href="https://www.elastic.co/products/logstash">Logstash</a>.</p>

<p>Ovšem pokud si uvědomíme, jaké jsou základní vlastnosti Apache Kafky, můžeme dojít k&nbsp;závěru, že i Kafku lze pro tento účel použít; a skutečně se takto i používá. Typicky se logovací informace ukládají do zvolených témat, přičemž jednotlivé záznamy jsou čteny buď jedním subscriberem (nejjednodušší případ, pokud se logy zpracovávají jediným systémem) nebo větším množstvím subscriberů (pokud pro zpracování logů máme k&nbsp;dispozici větší množství nástrojů). Výhoda tohoto řešení spočívá v&nbsp;tom, že jednou uložené logovací informace bude možné zpracovat i později nějakým dalším nástrojem, který lze do systému přidat kdykoli později. Taktéž &ndash; což vyplývá z&nbsp;vlastností samotného systému Kafka &ndash; je možné centrální řízení životnosti logovacích informací, jejich replikace atd.</p>

<p><div class="rs-tip-major">Poznámka: v&nbsp;současnosti je situace ve skutečnosti ještě zajímavější, protože v&nbsp;ekosystému, který okolo Apache Kafky vznikl, existují i konektory například pro zmíněný systém Logstash atd.</div></p>



<p><a name="k12"></a></p>
<h2 id="k12">12. </h2>



<p><a name="k13"></a></p>
<h2 id="k13">13. </h2>



<p><a name="k14"></a></p>
<h2 id="k14">14. Architektura kappa</h2>

<p>S&nbsp;architekturou nazývanou <i>kappa</i> jsme se již <a href="">v&nbsp;tomto seriálu setkali</a>. Připomeňme si, že se jedná o jedno z&nbsp;možných řešení pravděpodobně nejpalčivějšího problému, který se při návrhu a nasazování mikroslužeb musí řešit. Jedná se o problém distribuce dat a synchronizace databází jednotlivých mikroslužeb. V&nbsp;architektuře <i>kappa</i> je role databází invertována, protože databáze (každá přidružená k&nbsp;určité mikroslužbě) zde slouží pouze ve funkci materializovaného pohledu na data, přičemž skutečná data (dokonce i s&nbsp;historií) jsou uložena právě v&nbsp;Apache Kafka formou záznamů s&nbsp;informacemi o změnách. Každá mikroslužba postupně zpracovává záznamy čtené z&nbsp;Kafky a aplikuje tyto záznamy na svou databázi.</p>



<p><a name="k15"></a></p>
<h2 id="k15">15. Apache Kafka ve funkci message brokera s&nbsp;frontami zpráv</h2>

<p>Vzhledem k&nbsp;tomu, že Apache Kafka je dnes velmi populární technologií, používá se mnohdy i v&nbsp;těch oblastech, pro něž ve skutečnosti existují i lepší alternativy. Příkladem mohou být řešení, které Apache Kafku používají ve funkci klasického message brokera s&nbsp;frontami zpráv. Popišme si nyní, jak by takové řešení mohlo vypadat. Podrobnosti v&nbsp;případě zájmu najdete v&nbsp;článku <a href=""></a>.</p>

<p><div class="rs-tip-major">Poznámka: pokud potřebujete v&nbsp;systému použít klasickou frontu zpráv (což je v&nbsp;oblasti mikroslužeb velmi častý požadavek), použijte raději skutečného message brokera, například <i>RabbitMQ</i>, <i>Apache ActiveMQ</i>, <i>Artemis</i> atd. V&nbsp;případě, že se namísto fronty zpráv bude jednat spíše o frontu úloh (task, job), může být řešení ještě jednodušší &ndash; použijte <i>rq</i>, s&nbsp;nímž jsme se již na stránkách Roota <a href="">taktéž seznámili</a>. Zde popisované použití systému Apache Kafka spíše ukazuje flexibilitu Kafky a nikoli zcela &bdquo;neprůstřelný&ldquo; systém, který se dokáže zotavit z&nbsp;každé situace, která při provozu systému může nastat.</div></p>



<p><a name="k16"></a></p>
<h2 id="k16">16. </h2>



<p><a name="k17"></a></p>
<h2 id="k17">17. </h2>



<p><a name="k18"></a></p>
<h2 id="k18">18. </h2>



<p><a name="k19"></a></p>
<h2 id="k19">19. Alternativní řešení</h2>

<p>V&nbsp;oblasti nástrojů pro <i>streaming</i> je Apache Kafka v&nbsp;současnosti s&nbsp;velkou pravděpodobností nejpopulárnějším a nejpoužívanějším nástrojem, ovšem pochopitelně se nejedná o jediné řešení nabízející výše popsanou funkcionalitu. Na stránkách Roota jsme se již seznámili se systémem <a href="">NATS Streaming Server</a>, jenž je založen na message brokeru <a href="">NATS</a>, který je naprogramován v&nbsp;Go. Předností by měla být vyšší rychlost a menší systémové nároky, ovšem tyto údaje je pro reálně provozované systémy složité až nemožné získat &ndash; systémy by musely paralelně běžet jak s&nbsp;NATS Streaming Serverem, tak i s&nbsp;Apache Kafkou a porovnání by se muselo provést až po delší době provozu (ovšem aplikace tohoto typu psané v&nbsp;Go opravdu bývají kvalitní).</p>

<p>Vzhledem k&nbsp;tomu, že Apache Kafka je dnes velmi populární technologií,
používá se mnohdy i v&nbsp;těch oblastech, pro něž ve skutečnosti existují i
lepší alternativy. Příkladem mohou být řešení, které Apache Kafku používají ve
funkci klasického message brokera s&nbsp;frontami zpráv. Popišme si nyní, jak
by takové řešení mohlo vypadat. Podrobnosti v&nbsp;případě zájmu najdete
v&nbsp;článku <a
href="https://softwaremill.com/using-kafka-as-a-message-queue/">Using Kafka as
a message queue</a>.</p>

<p>Při této konfiguraci se používá několik témat, především téma nazvané
<strong>queue</strong>, které obsahuje zpracovávané zprávy. Jakmile se zpráva
z&nbsp;tohoto tématu přečte nějakým konzumentem, je nutné <i>offset</i> této
zprávy poslat společně se značkou <strong>START</strong> do tématu
<strong>markers</strong>. Ve chvíli, kdy je zpráva v&nbsp;příjemci zpracována
(k&nbsp;čemuž ovšem nemusí dojít &ndash; příjemce může zhavarovat nebo zprávu
nezpracovat), pošle se značka <strong>END</strong> s&nbsp;offsetem, a to opět
do tématu <strong>markers</strong>. V&nbsp;tomto tématu tedy budou
k&nbsp;dispozici informace o rozpracovaných zprávách i o zprávách zpracovaných.
A o tyto informace se musí starat další konzument, který zjistí, které zprávy
je nutné poslat znovu a případně je zařadí do tématu (tento konzument je ovšem
interně poměrně komplikovaný, protože musí zrekonstruovat skutečnou frontu).
Celý systém má několik problematických rysů, protože při &bdquo;vhodném&ldquo;
pádu některé z&nbsp;komponent se může informace o zpracování zprávy
ztratit, popř.&nbsp;bude nezpracovaná zpráva již zahozena.</p>

<p><div class="rs-tip-major">Poznámka: pokud potřebujete v&nbsp;systému použít
klasickou frontu zpráv (což je v&nbsp;oblasti mikroslužeb velmi častý
požadavek), použijte raději skutečného message brokera, například
<i>RabbitMQ</i>, <i>Apache ActiveMQ</i>, <i>Artemis</i> atd. V&nbsp;případě, že
se namísto fronty zpráv bude jednat spíše o frontu úloh (<i>task</i>,
<i>job</i>), může být řešení ještě jednodušší &ndash; použijte <i>rq</i>,
s&nbsp;nímž jsme se již na stránkách Roota <a
href="https://www.root.cz/clanky/pouziti-nastroje-rq-redis-queue-pro-spravu-uloh-zpracovavanych-na-pozadi/">taktéž
seznámili</a>. Zde popisované použití systému Apache Kafka spíše ukazuje
flexibilitu Kafky a nikoli zcela &bdquo;neprůstřelný&ldquo; systém, který se
dokáže zotavit z&nbsp;každé situace, která při provozu systému může
nastat.</div></p>



<p><a name="k18"></a></p>
<h2 id="k18">18. Alternativní řešení</h2>

<p>V&nbsp;oblasti nástrojů pro <i>streaming</i> je Apache Kafka
v&nbsp;současnosti s&nbsp;velkou pravděpodobností nejpopulárnějším a
nejpoužívanějším nástrojem, ovšem pochopitelně se nejedná o jediné řešení
nabízející výše popsanou funkcionalitu. Na stránkách Roota jsme se již
seznámili se systémem <a
href="https://www.root.cz/clanky/nats-streaming-server/">NATS Streaming
Server</a>, jenž je založen na message brokeru <a
href="https://www.root.cz/clanky/pouziti-message-brokeru-nats/">NATS</a>, který
je naprogramován v&nbsp;Go. Předností by měla být vyšší rychlost a menší
systémové nároky, ovšem tyto údaje je pro reálně provozované systémy složité až
nemožné získat &ndash; systémy by musely paralelně běžet jak s&nbsp;NATS
Streaming Serverem, tak i s&nbsp;Apache Kafkou a porovnání by se muselo provést
až po delší době provozu (ovšem aplikace tohoto typu psané v&nbsp;Go opravdu
bývají kvalitní).</p>



<p><a name="k20"></a></p>
<h2 id="k20">20. Odkazy na Internetu</h2>

<ol>

<li>Understanding Kafka with Legos (video)<br />
<a href="https://www.youtube.com/watch?v=Q5wOegcVa8E">https://www.youtube.com/watch?v=Q5wOegcVa8E</a>
</li>

<li>Apache Kafka Tutorial For Beginners (video)<br />
<a href="https://www.youtube.com/watch?v=U4y2R3v9tlY">https://www.youtube.com/watch?v=U4y2R3v9tlY</a>
</li>

<li>Franz Kafka (Wikipedia)<br />
<a href="https://en.wikipedia.org/wiki/Franz_Kafka">https://en.wikipedia.org/wiki/Franz_Kafka</a>
</li>

<li>NATS<br />
<a href="https://nats.io/about/">https://nats.io/about/</a>
</li>

<li>NATS Streaming Concepts<br />
<a href="https://nats.io/documentation/streaming/nats-streaming-intro/">https://nats.io/documentation/streaming/nats-streaming-intro/</a>
</li>

<li>NATS Streaming Server<br />
<a href="https://nats.io/download/nats-io/nats-streaming-server/">https://nats.io/download/nats-io/nats-streaming-server/</a>
</li>

<li>NATS Introduction<br />
<a href="https://nats.io/documentation/">https://nats.io/documentation/</a>
</li>

<li>NATS Client Protocol<br />
<a href="https://nats.io/documentation/internals/nats-protocol/">https://nats.io/documentation/internals/nats-protocol/</a>
</li>

<li>NATS Messaging (Wikipedia)<br />
<a href="https://en.wikipedia.org/wiki/NATS_Messaging">https://en.wikipedia.org/wiki/NATS_Messaging</a>
</li>

<li>Stránka Apache Software Foundation<br />
<a href="http://www.apache.org/">http://www.apache.org/</a>
</li>

<li>Logstash<br />
<a href="https://www.elastic.co/products/logstash">https://www.elastic.co/products/logstash</a>
</li>

<li>Elasticsearch<br />
<a href="https://www.elastic.co/products/elasticsearch">https://www.elastic.co/products/elasticsearch</a>
</li>

<li>Understanding When to use RabbitMQ or Apache Kafka<br />
<a href="https://content.pivotal.io/blog/understanding-when-to-use-rabbitmq-or-apache-kafka">https://content.pivotal.io/blog/understanding-when-to-use-rabbitmq-or-apache-kafka</a>
</li>

<li>Part 1: Apache Kafka for beginners - What is Apache Kafka?<br />
<a href="https://www.cloudkarafka.com/blog/2016-11-30-part1-kafka-for-beginners-what-is-apache-kafka.html">https://www.cloudkarafka.com/blog/2016-11-30-part1-kafka-for-beginners-what-is-apache-kafka.html</a>
</li>

<li>What are some alternatives to Apache Kafka?<br />
<a href="https://www.quora.com/What-are-some-alternatives-to-Apache-Kafka">https://www.quora.com/What-are-some-alternatives-to-Apache-Kafka</a>
</li>

<li>What is the best alternative to Kafka?<br />
<a href="https://www.slant.co/options/961/alternatives/~kafka-alternatives">https://www.slant.co/options/961/alternatives/~kafka-alternatives</a>
</li>

<li>Apache Flume<br />
<a href="https://flume.apache.org/index.html">https://flume.apache.org/index.html</a>
</li>

<li>Snare<br />
<a href="https://www.snaresolutions.com/">https://www.snaresolutions.com/</a>
</li>

<li>The Log: What every software engineer should know about real-time data's unifying abstraction<br />
<a href="https://engineering.linkedin.com/distributed-systems/log-what-every-software-engineer-should-know-about-real-time-datas-unifying">https://engineering.linkedin.com/distributed-systems/log-what-every-software-engineer-should-know-about-real-time-datas-unifying</a>
</li>

<li>A super quick comparison between Kafka and Message Queues<br />
<a href="https://hackernoon.com/a-super-quick-comparison-between-kafka-and-message-queues-e69742d855a8?gi=e965191e72d0">https://hackernoon.com/a-super-quick-comparison-between-kafka-and-message-queues-e69742d855a8?gi=e965191e72d0</a>
</li>

<li>Kafka Queuing: Kafka as a Messaging System<br />
<a href="https://dzone.com/articles/kafka-queuing-kafka-as-a-messaging-system">https://dzone.com/articles/kafka-queuing-kafka-as-a-messaging-system</a>
</li>

<li>Microservices - Not a free lunch!<br />
<a href="http://highscalability.com/blog/2014/4/8/microservices-not-a-free-lunch.html">http://highscalability.com/blog/2014/4/8/microservices-not-a-free-lunch.html</a>
</li>

<li>Microservices, Monoliths, and NoOps<br />
<a href="http://blog.arungupta.me/microservices-monoliths-noops/">http://blog.arungupta.me/microservices-monoliths-noops/</a>
</li>

<li>Microservice Design Patterns<br />
<a href="http://blog.arungupta.me/microservice-design-patterns/">http://blog.arungupta.me/microservice-design-patterns/</a>
</li>

<li>Vision of a microservice revolution<br />
<a href="https://www.jolie-lang.org/vision.html">https://www.jolie-lang.org/vision.html</a>
</li>

<li>Microservices: a definition of this new architectural term<br />
<a href="https://martinfowler.com/articles/microservices.html">https://martinfowler.com/articles/microservices.html</a>
</li>

<li>Mikroslužby<br />
<a href="http://voho.eu/wiki/mikrosluzba/">http://voho.eu/wiki/mikrosluzba/</a>
</li>

<li>Microservice Prerequisites<br />
<a href="https://martinfowler.com/bliki/MicroservicePrerequisites.html">https://martinfowler.com/bliki/MicroservicePrerequisites.html</a>
</li>

<li>Microservices in Practice, Part 1: Reality Check and Service Design (vyžaduje registraci)<br />
<a href="https://ieeexplore.ieee.org/document/7819415">https://ieeexplore.ieee.org/document/7819415</a>
</li>

<li>Microservice Trade-Offs<br />
<a href="https://www.martinfowler.com/articles/microservice-trade-offs.html">https://www.martinfowler.com/articles/microservice-trade-offs.html</a>
</li>

<li>What is a microservice? (from a linguistic point of view)<br />
<a href="http://claudioguidi.blogspot.com/2017/03/what-microservice-from-linguisitc.html">http://claudioguidi.blogspot.com/2017/03/what-microservice-from-linguisitc.html</a>
</li>

<li>Microservices (Wikipedia)<br />
<a href="https://en.wikipedia.org/wiki/Microservices">https://en.wikipedia.org/wiki/Microservices</a>
</li>

<li>Fallacies of distributed computing (Wikipedia)<br />
<a href="https://en.wikipedia.org/wiki/Fallacies_of_distributed_computing">https://en.wikipedia.org/wiki/Fallacies_of_distributed_computing</a>
</li>

<li>Service (systems architecture)<br />
<a href="https://en.wikipedia.org/wiki/Service_(systems_architecture)">https://en.wikipedia.org/wiki/Service_(systems_architecture)</a>
</li>

<li>Microservices in a Nutshell<br />
<a href="https://www.thoughtworks.com/insights/blog/microservices-nutshell">https://www.thoughtworks.com/insights/blog/microservices-nutshell</a>
</li>

<li>What is Microservices?<br />
<a href="https://smartbear.com/solutions/microservices/">https://smartbear.com/solutions/microservices/</a>
</li>

<li>Mastering Chaos - A Netflix Guide to Microservices<br />
<a href="https://www.youtube.com/watch?v=CZ3wIuvmHeM&t=17s">https://www.youtube.com/watch?v=CZ3wIuvmHeM&amp;t=17s</a>
</li>

<li>Messaging in Microservice Architecture<br />
<a href="https://www.youtube.com/watch?v=MkQWQ5f-SEY">https://www.youtube.com/watch?v=MkQWQ5f-SEY</a>
</li>

<li>Pattern: Messaging<br />
<a href="https://microservices.io/patterns/communication-style/messaging.html">https://microservices.io/patterns/communication-style/messaging.html</a>
</li>

<li>Microservices Messaging: Why REST Isn’t Always the Best Choice<br />
<a href="https://blog.codeship.com/microservices-messaging-rest-isnt-always-best-choice/">https://blog.codeship.com/microservices-messaging-rest-isnt-always-best-choice/</a>
</li>

<li>Protocol buffers<br />
<a href="https://developers.google.com/protocol-buffers/">https://developers.google.com/protocol-buffers/</a>
</li>

<li>BSON<br />
<a href="http://bsonspec.org/">http://bsonspec.org/</a>
</li>

<li>Apache Avro!<br />
<a href="https://avro.apache.org/">https://avro.apache.org/</a>
</li>

<li>REST vs Messaging for Microservices – Which One is Best?<br />
<a href="https://solace.com/blog/experience-awesomeness-event-driven-microservices/">https://solace.com/blog/experience-awesomeness-event-driven-microservices/</a>
</li>

<li>How did we end up here?<br />
<a href="https://gotocon.com/dl/goto-chicago-2015/slides/MartinThompson_and_ToddMontgomery_HowDidWeEndUpHere.pdf">https://gotocon.com/dl/goto-chicago-2015/slides/MartinThompson_and_ToddMontgomery_HowDidWeEndUpHere.pdf</a>
</li>

<li>Scaling microservices with message queues to handle data bursts<br />
<a href="https://read.acloud.guru/scaling-microservices-with-message-queue-2d389be5b139">https://read.acloud.guru/scaling-microservices-with-message-queue-2d389be5b139</a>
</li>

<li>Microservices: What are smart endpoints and dumb pipes?<br />
<a href="https://stackoverflow.com/questions/26616962/microservices-what-are-smart-endpoints-and-dumb-pipes">https://stackoverflow.com/questions/26616962/microservices-what-are-smart-endpoints-and-dumb-pipes</a>
</li>

<li>Common Object Request Broker Architecture<br />
<a href="https://en.wikipedia.org/wiki/Common_Object_Request_Broker_Architecture">https://en.wikipedia.org/wiki/Common_Object_Request_Broker_Architecture</a>
</li>

<li>Enterprise service bus<br />
<a href="https://en.wikipedia.org/wiki/Enterprise_service_bus">https://en.wikipedia.org/wiki/Enterprise_service_bus</a>
</li>

<li>Microservices vs SOA : What’s the Difference<br />
<a href="https://www.edureka.co/blog/microservices-vs-soa/">https://www.edureka.co/blog/microservices-vs-soa/</a>
</li>

<li>Pravda o SOA<br />
<a href="https://businessworld.cz/reseni-a-realizace/pravda-o-soa-2980">https://businessworld.cz/reseni-a-realizace/pravda-o-soa-2980</a>
</li>

<li>Is it a good idea for Microservices to share a common database?<br />
<a href="https://www.quora.com/Is-it-a-good-idea-for-Microservices-to-share-a-common-database">https://www.quora.com/Is-it-a-good-idea-for-Microservices-to-share-a-common-database</a>
</li>

<li>Pattern: Shared database<br />
<a href="https://microservices.io/patterns/data/shared-database.html">https://microservices.io/patterns/data/shared-database.html</a>
</li>

<li>Is a Shared Database in Microservices Actually an Anti-pattern?<br />
<a href="https://hackernoon.com/is-shared-database-in-microservices-actually-anti-pattern-8cc2536adfe4">https://hackernoon.com/is-shared-database-in-microservices-actually-anti-pattern-8cc2536adfe4</a>
</li>

<li>Shared database in microservices is a problem, yep<br />
<a href="https://ayende.com/blog/186914-A/shared-database-in-microservices-is-a-problem-yep">https://ayende.com/blog/186914-A/shared-database-in-microservices-is-a-problem-yep</a>
</li>

<li>Microservices with shared database? using multiple ORM's?<br />
<a href="https://stackoverflow.com/questions/43612866/microservices-with-shared-database-using-multiple-orms">https://stackoverflow.com/questions/43612866/microservices-with-shared-database-using-multiple-orms</a>
</li>

<li>Examples of microservice architecture<br />
<a href="https://www.coursera.org/lecture/intro-ibm-microservices/examples-of-microservice-architecture-JXOFj">https://www.coursera.org/lecture/intro-ibm-microservices/examples-of-microservice-architecture-JXOFj</a>
</li>

<li>Microservices: The Rise Of Kafka<br />
<a href="https://movio.co/blog/microservices-rise-kafka/">https://movio.co/blog/microservices-rise-kafka/</a>
</li>

<li>Building a Microservices Ecosystem with Kafka Streams and KSQL<br />
<a href="https://www.confluent.io/blog/building-a-microservices-ecosystem-with-kafka-streams-and-ksql/">https://www.confluent.io/blog/building-a-microservices-ecosystem-with-kafka-streams-and-ksql/</a>
</li>

<li>An introduction to Apache Kafka and microservices communication<br />
<a href="https://medium.com/@ulymarins/an-introduction-to-apache-kafka-and-microservices-communication-bf0a0966d63">https://medium.com/@ulymarins/an-introduction-to-apache-kafka-and-microservices-communication-bf0a0966d63</a>
</li>

<li>ACID (computer science)<br />
<a href="https://en.wikipedia.org/wiki/ACID_(computer_science)">https://en.wikipedia.org/wiki/ACID_(computer_science)</a>
</li>

<li>Distributed transaction<br />
<a href="https://en.wikipedia.org/wiki/Distributed_transaction">https://en.wikipedia.org/wiki/Distributed_transaction</a>
</li>

<li>Two-phase commit protocol<br />
<a href="https://en.wikipedia.org/wiki/Two-phase_commit_protocol">https://en.wikipedia.org/wiki/Two-phase_commit_protocol</a>
</li>

<li>Why is 2-phase commit not suitable for a microservices architecture?<br />
<a href="https://stackoverflow.com/questions/55249656/why-is-2-phase-commit-not-suitable-for-a-microservices-architecture">https://stackoverflow.com/questions/55249656/why-is-2-phase-commit-not-suitable-for-a-microservices-architecture</a>
</li>

<li>4 reasons why microservices resonate<br />
<a href="https://www.oreilly.com/ideas/4-reasons-why-microservices-resonate">https://www.oreilly.com/ideas/4-reasons-why-microservices-resonate</a>
</li>

<li>Pattern: Microservice Architecture<br />
<a href="https://microservices.io/patterns/microservices.html">https://microservices.io/patterns/microservices.html</a>
</li>

<li>Pattern: Monolithic Architecture<br />
<a href="https://microservices.io/patterns/monolithic.html">https://microservices.io/patterns/monolithic.html</a>
</li>

<li>Pattern: Saga<br />
<a href="https://microservices.io/patterns/data/saga.html">https://microservices.io/patterns/data/saga.html</a>
</li>

<li>Pattern: Database per service<br />
<a href="https://microservices.io/patterns/data/database-per-service.html">https://microservices.io/patterns/data/database-per-service.html</a>
</li>

<li>Pattern: Access token<br />
<a href="https://microservices.io/patterns/security/access-token.html">https://microservices.io/patterns/security/access-token.html</a>
</li>

<li>Databázová integrita<br />
<a href="https://cs.wikipedia.org/wiki/Datab%C3%A1zov%C3%A1_integrita">https://cs.wikipedia.org/wiki/Datab%C3%A1zov%C3%A1_integrita</a>
</li>

<li>Referenční integrita<br />
<a href="https://cs.wikipedia.org/wiki/Referen%C4%8Dn%C3%AD_integrita">https://cs.wikipedia.org/wiki/Referen%C4%8Dn%C3%AD_integrita</a>
</li>

<li>Introduction into Microservices <br />
<a href="https://specify.io/concepts/microservices">https://specify.io/concepts/microservices</a>
</li>

<li>Are Microservices ‘SOA Done Right’?<br />
<a href="https://intellyx.com/2015/07/20/are-microservices-soa-done-right/">https://intellyx.com/2015/07/20/are-microservices-soa-done-right/</a>
</li>

<li>The Hardest Part About Microservices: Your Data<br />
<a href="https://blog.christianposta.com/microservices/the-hardest-part-about-microservices-data/">https://blog.christianposta.com/microservices/the-hardest-part-about-microservices-data/</a>
</li>

<li>From a monolith to microservices + REST<br />
<a href="https://www.slideshare.net/InfoQ/from-a-monolith-to-microservices-rest-the-evolution-of-linkedins-service-architecture">https://www.slideshare.net/InfoQ/from-a-monolith-to-microservices-rest-the-evolution-of-linkedins-service-architecture</a>
</li>

<li>DevOps and the Myth of Efficiency, Part I<br />
<a href="https://blog.christianposta.com/devops/devops-and-the-myth-of-efficiency-part-i/">https://blog.christianposta.com/devops/devops-and-the-myth-of-efficiency-part-i/</a>
</li>

<li>DevOps and the Myth of Efficiency, Part II<br />
<a href="https://blog.christianposta.com/devops/devops-and-the-myth-of-efficiency-part-ii/">https://blog.christianposta.com/devops/devops-and-the-myth-of-efficiency-part-ii/</a>
</li>

<li>Standing on Distributed Shoulders of Giants: Farsighted Physicists of Yore Were Danged Smart!<br />
<a href="https://queue.acm.org/detail.cfm?id=2953944">https://queue.acm.org/detail.cfm?id=2953944</a>
</li>

<li>Building DistributedLog: High-performance replicated log service<br />
<a href="https://blog.twitter.com/engineering/en_us/topics/infrastructure/2015/building-distributedlog-twitter-s-high-performance-replicated-log-servic.html">https://blog.twitter.com/engineering/en_us/topics/infrastructure/2015/building-distributedlog-twitter-s-high-performance-replicated-log-servic.html</a>
</li>

<li>Turning the database inside-out with Apache Samza<br />
<a href="https://www.confluent.io/blog/turning-the-database-inside-out-with-apache-samza/">https://www.confluent.io/blog/turning-the-database-inside-out-with-apache-samza/</a>
</li>

<li>Debezium: Stream changes from your databases.<br />
<a href="https://debezium.io/">https://debezium.io/</a>
</li>

<li>Change data capture<br />
<a href="https://en.wikipedia.org/wiki/Change_data_capture">https://en.wikipedia.org/wiki/Change_data_capture</a>
</li>

<li>Apache Samza (Wikipedia)<br />
<a href="https://en.wikipedia.org/wiki/Apache_Samza">https://en.wikipedia.org/wiki/Apache_Samza</a>
</li>

<li>Storm (event processor)<br />
<a href="https://en.wikipedia.org/wiki/Storm_(event_processor)">https://en.wikipedia.org/wiki/Storm_(event_processor)</a>
</li>

<li>kappa-architecture.com<br />
<a href="http://milinda.pathirage.org/kappa-architecture.com/">http://milinda.pathirage.org/kappa-architecture.com/</a>
</li>

<li>Questioning the Lambda Architecture<br />
<a href="https://www.oreilly.com/ideas/questioning-the-lambda-architecture">https://www.oreilly.com/ideas/questioning-the-lambda-architecture</a>
</li>

<li>Lambda architecture<br />
<a href="https://en.wikipedia.org/wiki/Lambda_architecture">https://en.wikipedia.org/wiki/Lambda_architecture</a>
</li>

<li>Event stream processing<br />
<a href="https://en.wikipedia.org/wiki/Event_stream_processing">https://en.wikipedia.org/wiki/Event_stream_processing</a>
</li>

<li>How to beat the CAP theorem<br />
<a href="http://nathanmarz.com/blog/how-to-beat-the-cap-theorem.html">http://nathanmarz.com/blog/how-to-beat-the-cap-theorem.html</a>
</li>

<li>Kappa Architecture Our Experience<br />
<a href="https://events.static.linuxfound.org/sites/events/files/slides/ASPgems%20-%20Kappa%20Architecture.pdf">https://events.static.linuxfound.org/sites/events/files/slides/ASPgems%20-%20Kappa%20Architecture.pdf</a>
</li>

<li>Messaging Patterns in Event Driven Microservice Architectures<br />
<a href="https://www.youtube.com/watch?v=3xDc4MEYuHI">https://www.youtube.com/watch?v=3xDc4MEYuHI</a>
</li>

<li>Why monolithic apps are often better than microservices<br />
<a href="https://gigaom.com/2015/11/06/why-monolithic-apps-are-often-better-than-microservices/">https://gigaom.com/2015/11/06/why-monolithic-apps-are-often-better-than-microservices/</a>
</li>

<li>How Enterprise PaaS Can Add Critical Value to Microservices<br />
<a href="https://apprenda.com/blog/enterprise-paas-microservices/">https://apprenda.com/blog/enterprise-paas-microservices/</a>
</li>

<li>Common React Mistakes: Monolithic Components and a Lack of Abstraction<br />
<a href="https://www.pmg.com/blog/common-react-mistakes-monolithic-components-lack-abstraction/">https://www.pmg.com/blog/common-react-mistakes-monolithic-components-lack-abstraction/</a>
</li>

<li>From monolith to microservices – to migrate or not to migrate?<br />
<a href="https://altkomsoftware.pl/en/blog/monolith-microservices/">https://altkomsoftware.pl/en/blog/monolith-microservices/</a>
</li>

<li>Command–query separation<br />
<a href="https://en.wikipedia.org/wiki/Command%E2%80%93query_separation">https://en.wikipedia.org/wiki/Command%E2%80%93query_separation</a>
</li>

<li>GOTO 2016: Messaging and Microservices (Clemens Vasters)<br />
<a href="https://www.youtube.com/watch?v=rXi5CLjIQ9kx">https://www.youtube.com/watch?v=rXi5CLjIQ9kx</a>
</li>

<li>GOTO Amsterdam 2019<br />
<a href="https://gotoams.nl/">https://gotoams.nl/</a>
</li>

<li>Lesson 2 - Kafka vs. Standard Messaging<br />
<a href="https://www.youtube.com/watch?v=lwMjjTT1Q-Q">https://www.youtube.com/watch?v=lwMjjTT1Q-Q</a>
</li>

<li>CommandQuerySeparation (Martin Fowler)<br />
<a href="https://martinfowler.com/bliki/CommandQuerySeparation.html">https://martinfowler.com/bliki/CommandQuerySeparation.html</a>
</li>

<li>Command–query separation<br />
<a href="https://en.wikipedia.org/wiki/Command%E2%80%93query_separation">https://en.wikipedia.org/wiki/Command%E2%80%93query_separation</a>
</li>

<li>CQRS - Martin Fowler<br />
<a href="https://martinfowler.com/bliki/CQRS.html">https://martinfowler.com/bliki/CQRS.html</a>
</li>

<li>Lesson 12 - CQRS and Microservices<br />
<a href="https://www.youtube.com/watch?v=pUGvXUBfvEE">https://www.youtube.com/watch?v=pUGvXUBfvEE</a>
</li>

<li>Message queues - the right way to process and work with realtime data on your servers<br />
<a href="https://www.ably.io/blog/message-queues-the-right-way">https://www.ably.io/blog/message-queues-the-right-way</a>
</li>

</ol>



<p></p><p></p>
<p><small>Autor: <a href="http://www.fit.vutbr.cz/~tisnovpa">Pavel Tišnovský</a> &nbsp; 2019</small></p>
</body>
</html>

