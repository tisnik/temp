<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
        "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html>
<head>
<title>Použití nástroje Apache Kafka v aplikacích založených na mikroslužbách</title>
<meta name="Author" content="Pavel Tisnovsky" />
<meta name="Generator" content="vim" />
<meta http-equiv="content-type" content="text/html; charset=utf-8" />
<style type="text/css">
         body {color:#000000; background:#ffffff;}
         h1  {font-family: arial, helvetica, sans-serif; color:#ffffff; background-color:#c00000; text-align:center; padding-left:1em}
         h2  {font-family: arial, helvetica, sans-serif; color:#ffffff; background-color:#0000c0; padding-left:1em; text-align:left}
         h3  {font-family: arial, helvetica, sans-serif; color:#000000; background-color:#c0c0c0; padding-left:1em; text-align:left}
         h4  {font-family: arial, helvetica, sans-serif; color:#000000; background-color:#e0e0e0; padding-left:1em; text-align:left}
         a   {font-family: arial, helvetica, sans-serif;}
         li  {font-family: arial, helvetica, sans-serif; color:#000000; text-align:justify; width:450px;}
         ol  {font-family: arial, helvetica, sans-serif; color:#000000; text-align:justify; width:450px;}
         ul  {font-family: arial, helvetica, sans-serif; color:#000000; text-align:justify; width:450px;}
         p   {font-family: arial, helvetica, sans-serif; color:#000000; text-align:justify;}
         pre {background:#e0e0e0}
</style>
</head>

<body>

<h1>Použití nástroje Apache Kafka v aplikacích založených na mikroslužbách</h1>

<h3>Pavel Tišnovský</h3>

<p></p>

<h1>Úvodník</h1>

<p>Již několikrát jsme se v tomto seriálu setkali s nástrojem <i>Apache Kafka</i>. Jedná se o velmi často používaný (někdy i nadužívaný) nástroj, o jehož základních možnostech se v kontextu mikroslužeb zmíníme.</p>



<h2>Obsah</h2>

<p><a href="#k01">1. Použití nástroje Apache Kafka v&nbsp;aplikacích založených na mikroslužbách</a></p>
<p><a href="#k02">2. Klasické systémy s&nbsp;frontami zpráv &ndash; <strong>PUSH-PULL</strong></a></p>
<p><a href="#k03">3. Rozesílání zpráv se strategií <strong>PUBLISH-SUBSCRIBE</strong></a></p>
<p><a href="#k04">4. Když nejsou možnosti klasických message brokerů dostačující...</a></p>
<p><a href="#k05">5. Shrnutí některých úskalí a problémů klasických message brokerů</a></p>
<p><a href="#k06">6. Práce se zprávami v&nbsp;systému Apache Kafka</a></p>
<p><a href="#k07">7. Témata a oddíly</a></p>
<p><a href="#k08">8. Replikace</a></p>
<p><a href="#k09">9. Kafka Streams</a></p>
<p><a href="#k10">10. Ekosystém Apache Kafky</a></p>
<p><a href="#k11">11. Použití systému Apache Kafka z&nbsp;různých programovacích jazyků</a></p>
<p><a href="#k12">12. Nástroj <strong>kafkacat</strong></a></p>
<p><a href="#k13">13. Příklady použití Apache Kafka</a></p>
<p><a href="#k14">14. Logovací platforma</a></p>
<p><a href="#k15">15. Architektura lambda</a></p>
<p><a href="#k16">16. Architektura kappa</a></p>
<p><a href="#k17">17. Apache Kafka ve funkci message brokera s&nbsp;frontami zpráv</a></p>
<p><a href="#k18">18. Alternativní řešení</a></p>
<p><a href="#k19">19. Odkazy na Internetu</a></p>



<p><a name="k01"></a></p>
<h2 id="k01">1. Použití nástroje Apache Kafka v aplikacích založených na mikroslužbách</h2>

<p>Ve čtvrté části <a href="https://www.root.cz/serialy/mikrosluzby/">seriálu o
mikroslužbách</a> se seznámíme se základními vlastnostmi projektu <i>Apache
Kafka</i>, který se v&nbsp;posledních několika letech stal velmi populární, a
to nikoli pouze u aplikací založených na mikroslužbách, ale i v&nbsp;dalších
oborech (zmiňme například oblasti jako <i>Machine Learning</i>, <i>Big data</i>
atd.). Díky konceptům, na nichž je projekt Kafka založen, je možné tento systém
použít v&nbsp;několika oblastech, například ve funkci distribuovaného logu,
databáze událostí (<i>events</i>), zobecněného message brokera, je ústředním
prvkem architektur <i>lambda</i> a <i>kappa</i>, příjemci zpráv se mohou
sdružovat do skupin atd. Ovšem i další vlastnosti, které projekt Kafka nabízí,
jsou velmi užitečné. Jedná se především o možnost nasazení celého clusteru
brokerů řízených z&nbsp;jednoho místa, možnost replikace záznamů (zpráv,
událostí), řízení, které zprávy mají být zachovány a které (ty starší) smazány
apod. Existují samozřejmě i alternativy k&nbsp;tomuto projektu, například
v&nbsp;závěru zmíněný NATS Streaming Server, ovšem ty většinou nenabízí všechny
výše zmíněné možnosti.</p>

<p><div class="rs-tip-major">Poznámka: samotné jméno systému <i>Apache
Kafka</i> (dříve, dokud se projekt nestal součástí projektu <a
href="http://apache.org/">Apache</a> jen <i>Kafka</i>) je odvozeno od příjmení
slavného spisovatele <a href="https://en.wikipedia.org/wiki/Franz_Kafka">Franze
Kafky</a>. Ovšem v&nbsp;běžné řeči se docela často mluví o &bdquo;té
kafce&ldquo; (kavce), tj.&nbsp;používá se ženský rod. V&nbsp;tomto článku se
budu snažit používat neutrální spojení &bdquo;systém Kafka&ldquo;,
&bdquo;projekt Kafka&ldquo;.</div></p>

<img src="https://i.iinfo.cz/images/447/microservices2-3.png" class="image-361670" alt="&#160;" width="450" height="134" />
<p><i>Obrázek 1: Logo nástroje Apache Kafka, kterému se budeme dnes
věnovat.</i></p>



<p><a name="k02"></a></p>
<h2 id="k02">2. Klasické systémy s&nbsp;frontami zpráv &ndash; <strong>PUSH-PULL</strong></h2>

<p>Nástroj Apache Kafka je určen především pro práci s&nbsp;kontinuálním tokem
zpráv (popř.&nbsp;událostí), které jsou v&nbsp;Kafce určitým způsobem uloženy
(typicky se zaručeným pořadím &ndash; viz další text) a je je možné zpracovávat
konzumenty (příjemci zpráv), kteří si sami určují, jaké zprávy budou potřebovat
a dokonce i v&nbsp;jakém pořadí. Možnosti Kafky rozšiřují a zobecňují
vlastnosti klasických message brokerů. Připomeňme si, že většina message
brokerů nabízí dva způsoby doručování zpráv. Jedná se o způsob (strategii)
nazvaný <strong>PUSH-PULL</strong> a dále o způsob pojmenovaný
<strong>PUBLISH-SUBSCRIBE</strong>.</p>

<p>První komunikační strategie, která se někdy nazývá
<strong>PUSH-PULL</strong> či pouze <strong>queueing</strong>, je založena na
pojmenovaných frontách zpráv (<strong>message queue</strong>) implementovaných
v&nbsp;message brokerovi. Zpráva bývá v&nbsp;tomto případě doručena jen
jedinému konzumentovi a pokud žádný konzument není k&nbsp;frontě připojen,
zůstane zpráva ve frontě uložena (teoreticky) po libovolně dlouhou dobu.
Message broker v&nbsp;takovém případě typicky podporuje <i>perzistenci</i>
zpráv, které tak dokážou přečkat jeho případné restarty. Mnoho message brokerů
navíc umožňuje, aby konzumenti potvrzovali zpracování zprávy, popř.&nbsp;je
dokonce možné provádět transakce. K&nbsp;pojmenovaným frontám se potom
přidávají další specializované fronty na nezpracované zprávy (<i>DLQ &ndash;
Dead Letters Queue</i>).</p>

<a href="https://www.root.cz/obrazek/348762/"><img src="https://i.iinfo.cz/images/176/rabbitmq1-1-prev.png" class="image-348762" alt="&#160;" width="370" height="62" /></a>
<p><i>Obrázek 2: Komunikační strategie <strong>PUSH-PULL</strong>.</i></p>



<p><a name="k03"></a></p>
<h2 id="k03">3. Rozesílání zpráv se strategií <strong>PUBLISH-SUBSCRIBE</strong></h2>

<p>Druhá komunikační strategie podporovaná většinou message brokerů se nazývá
<strong>PUBLISH-SUBSCRIBE</strong> (neboli zkráceně <strong>PUB-SUB</strong>) a
spočívá v&nbsp;tom, že se zprávy s&nbsp;nastaveným tématem (<i>topic</i>,
<i>subject</i>) posílají do message brokera, který tyto zprávy ihned přeposílá
konzumentům přihlášeným k&nbsp;danému tématu. V&nbsp;případě, že žádný takový
konzument neexistuje, je zpráva zahozena. Pokud konzumentů daného tématu naopak
existuje větší množství, je zpráva doručena všem takovým konzumentům. Samotný
message broker v&nbsp;tomto případě nepotřebuje zprávy ukládat, takže se
většinou nesetkáme ani s&nbsp;podporou pro persistenci zpráv. Příkladem
takového systému je například systém <a
href="https://www.root.cz/clanky/pouziti-message-brokeru-nats/">NATS</a> (bez
dalších rozšíření).</p>

<a href="https://www.root.cz/obrazek/348764/"><img src="https://i.iinfo.cz/images/176/rabbitmq1-3-prev.png" class="image-348764" alt="&#160;" width="370" height="125" /></a>
<p><i>Obrázek 3: Komunikační strategie <strong>PUBLISH-SUBSCRIBE</strong>.</i></p>

<p><div class="rs-tip-major">Poznámka: ve skutečnosti je možné tuto strategii
realizovat dvěma způsoby. První z&nbsp;těchto způsobů roztřiďuje zprávy pro
jednotlivé konzumenty již v&nbsp;message brokeru (který tak může být poměrně
silně zatěžován), druhý způsob naopak přeposílá zprávy všem aktuálně připojeným
konzumentům s&nbsp;tím, že si konzumenti filtraci provedou sami u sebe,
například s&nbsp;využitím mnohem složitějších pravidel. Záleží na konkrétní
situaci, který způsob použít, ovšem první způsob je v&nbsp;praxi
používanější.</div></p>



<p><a name="k04"></a></p>
<h2 id="k04">4. Když nejsou možnosti klasických message brokerů dostačující...</h2>

<p>V&nbsp;aplikacích, jejichž architektura je založena na mikroslužbách, se
s&nbsp;klasickými message brokery setkáme velmi často. Doručování zpráv typu
<strong>PUSH-PULL</strong> přes message brokera nejenže umožňuje, aby byly obě
komunikující strany co nejvíce odděleny, ale je automaticky podporován i
<i>load balancing</i>, systém se &bdquo;vzpamatuje&ldquo; i z&nbsp;případných
restartů konzumentů a existuje zde i možnost naplánování některých náročnějších
úloh až do okamžiku, kdy je k&nbsp;dispozici dostatek systémových prostředků
(<i>clearing</i> prováděný v&nbsp;noci atd.). Navíc, pokud je použit kvalitní
message broker, je zajištěna persistence zpráv, někdy i jejich replikace a
další vlastnosti, které od systému určeného pro mnohdy enormní zátěže
očekáváme. Nesmíme zapomenout ani na to, že konzumenti (příjemci zpráv) si
nemusí pamatovat, kterou zprávu zpracovávaly naposledy &ndash; toto je
automaticky zajištěno samotnou sémantikou fungování fronty (konzument tedy může
být bezstavový a tím pádem mnohem snadněji škálovatelný atd.).</p>

<a href="https://www.root.cz/obrazek/348765/"><img src="https://i.iinfo.cz/images/176/rabbitmq1-4-prev.png" class="image-348765" alt="&#160;" width="370" height="158" /></a>
<p><i>Obrázek 4: Složitější konfigurace nabízená například systémem RabbitMQ.</i></p>

<p>I strategie <strong>PUBLISH-SUBSCRIBE</strong> má v&nbsp;aplikacích
založených na mikroslužbách své místo. Jednotlivé komponenty se mohou navzájem
informovat o událostech, ke kterým došlo, mohou tímto způsobem předávat příkazy
(<i>command</i>) s&nbsp;tím, že opět platí, že producent zpráv nemusí být pevně
spojen s&nbsp;případnými konzumenty (a nemusí ani vědět o jejich
existenci).</p>

<p>V&nbsp;některých případech nám ovšem nemusí ani jedna z&nbsp;těchto
strategií vyhovovat a navíc &ndash; <strong>PUSH-PULL</strong> může být pro
mnohé aplikace relativně pomalý způsob předávání zpráv, zejména
v&nbsp;porovnání s&nbsp;řešením, s&nbsp;nímž se seznámíme v&nbsp;navazujících
kapitolách.</p>

<p>Jedním z&nbsp;problémů může být, že v&nbsp;klasickým message brokerech
orientovaných na komunikaci s&nbsp;využitím zpráv je každá zpráva většinou
spravována izolovaně od ostatních zpráv. I když některé implementace message
brokerů podporují prioritní fronty, není obecně vyžadováno (a ani se to
neočekává), aby se zprávy doručovaly přesně v&nbsp;takovém pořadí, v&nbsp;jakém
je message broker přijímá (což je u pojmenovaných front problematické).</p>

<p>Dále existují některé problémy, které se s&nbsp;použitím klasickým message
brokerů implementují velmi složitě popř.&nbsp;je nelze (na rozumném HW či na
cenově dostupném clusteru) implementovat vůbec. Příkladem může být systém pro
zaznamenání událostí, ovšem v&nbsp;tom pořadí, v&nbsp;jakém události vznikly a
s&nbsp;možností zpětného přehrávání (<i>replay</i>) zpráv/událostí. A právě pro
řešení těchto problémů vznikl koncept <i>streamingu</i> zpráv implementovaný
právě v&nbsp;systému Apache Kafka.</p>



<p><a name="k05"></a></p>
<h2 id="k05">5. Shrnutí některých úskalí a problémů klasických message brokerů</h2>

<p>Shrňme si tedy některá úskalí klasických message brokerů založených na obou
výše popsaných komunikačních strategiích. Většina těchto úskalí je do větší či
menší míry řešena moderními streaming brokery:</p>

<ol>

<li>U strategie <strong>PUBLISH-SUBSCRIBE</strong> získají zprávu jen ti
konzumenti, kteří jsou v&nbsp;daný okamžik přihlášeni k&nbsp;příjmu zpráv.
Pokud je nějaký konzument z&nbsp;nějakého důvodu odpojený, zprávu již nikdy
později nedostane. V&nbsp;případě streamingu si čtení zpráv od zadaného
okamžiku řídí samotný konzument zpráv, pochopitelně s&nbsp;tím omezením, že se
starší (většinou mnohem starší) zprávy mohou automaticky odstraňovat na základě
kritérií nastavených administrátorem (někdy to ovšem znamená, že si konzument
musí pamatovat například offset poslední zpracované zprávy).</li>

<li>U strategie <strong>PUSH-PULL</strong> je jednou doručená zpráva
z&nbsp;message brokera (přesněji řečeno z&nbsp;fronty implementované
v&nbsp;message brokeru) odstraněna a nelze se k&nbsp;ní později vrátit. Tím
pádem pochopitelně není umožněna ani podpora pro přehrávání zpráv
(<i>replay</i>). I toto je do značné míry vyřešeno v&nbsp;případě nasazení
streamingu; vše je omezeno nastavením provedeném administrátorem (a teoreticky
existuje pouze jedno omezení na 2<sup>63</sup>-1 zpráv v&nbsp;jedné oblasti,
což však v&nbsp;praxi prakticky nelze dosáhnout).</li>

<li>Původní strategie <strong>PUSH-PULL</strong> navíc předpokládá, že se
zpráva doručí jen jedinému konzumentovi. Někteří message brokeři ovšem
podporují i rozšíření funkcionality a implementují tak kombinaci obou
strategií, jak <strong>PUBLISH-SUBSCRIBE</strong>, tak i
<strong>PUSH-PULL</strong> (dobrým příkladem může být RabbitMQ, viz též obrázek
číslo 4). Streaming servery používají zobecněnou strategii
<strong>PUBLISH-SUBSCRIBE</strong>, takže toto omezení nemají, pochopitelně při
správném nastavení témat a jejich replikací.</li>

<li>U strategie <strong>PUSH-PULL</strong> se v&nbsp;případě výchozího chování
nijak nespecifikuje maximální počet zpráv ve frontě popř.&nbsp;maximální
povolené obsazení místa na disku. V&nbsp;případě, že konzumenti budou delší
dobu odpojeni, se může jednat o potenciální problém (opět platí, že u některých
message brokerů se můžeme setkat s&nbsp;určitou podporu pro mazání starších
zpráv při dosažení administrátorem specifikovaných limitů). Řešení
v&nbsp;případě streaming serverů bylo zmíněno výše a ke konkrétním příkladům se
vrátíme v&nbsp;dalším článku.</li>

<li>Problematický může být i relativně nízký výkon přeposílání zpráv systémem
<strong>PUSH-PULL</strong> (přibližně do limitu 100 000 zpráv za sekundu při
použití RabbitMQ v&nbsp;clusteru, zatímco systémy založené na Kafce mohou mít i
řádově vyšší rychlost práce se zprávami).</li>

</ol>

<p><div class="rs-tip-major">Poznámka: u posledního bodu se možná na chvíli
zastavme. Klasičtí message brokeři jsou velmi často používání pro předávání i
relativně obsáhlých zpráv, kdežto u mnoha systémů s&nbsp;Apache Kafkou jsou
zprávy dosti krátké; většinou se jedná pouze o oznámení, že došlo k&nbsp;nějaké
události, jediný řádek logu, jedna změna ve stavu aplikace, update jednoho
řádku v&nbsp;databází atd. I to je jeden z&nbsp;důvodů, proč se poměrně snadno
dá (v&nbsp;clusteru) dosáhnout výkonu jednoho milionu zpráv za
sekundu.</div></p>



<p><a name="k06"></a></p>
<h2 id="k06">6. Práce se zprávami v&nbsp;systému Apache Kafka</h2>

<p>V&nbsp;systému Apache Kafka se se zprávami (které se zde ale typicky
nazývají záznamy, <i>record</i>, popř.&nbsp;možná poněkud nepřesně události,
<i>events</i>) pracuje poněkud odlišným způsobem, který do jisté míry kombinuje
jak možnosti klasické fronty zpráv, tak i rozesílání zpráv systémem
<strong>PUBLISH-SUBSCRIBE</strong>. Zprávy se ovšem neukládají do fronty, ale
(v&nbsp;tom zcela nejjednodušším případě) do neustále rostoucí sekvence
záznamů, přičemž každému záznamu je přiřazeno jednoznačné číslo &ndash;
<i>offset</i>. Z&nbsp;pohledu zdroje zpráv (<i>publisher</i>) vlastně nedochází
k&nbsp;žádné podstatnější změně. Rozdílné je ovšem další zpracování záznamů.
Tyto záznamy mohou číst příjemci zpráv (<i>subscribeři</i>), kteří si sami
zvolí, od jakého <i>offsetu</i> potřebují zprávy přečíst.</p>

<p>Přečtením ovšem zpráva nezanikne, na rozdíl od klasické fronty, kde operace
<strong>PULL</strong> zprávu z&nbsp;fronty navždy odstraní a message broker ji
ihned poté odstraní i ze své paměti a perzistentního úložiště. A je zde i
rozdíl oproti systému <strong>PUBLISH-SUBSCRIBE</strong>, protože
<i>subscriber</i> zprávu může získat kdykoli později &ndash; nemusí být tedy
připraven zprávu zpracovat v&nbsp;ten přesný okamžik, kdy je zpráva message
brokerem rozesílána.</p>

<p>To však není jediná změna či vylepšení. Vzhledem k&nbsp;tomu, že příjemci
zpráv (<i>subscribeři</i>) si sami volí offset, od kterého chtějí zprávy číst,
je možné provádět takzvanou operaci <i>replay</i>, což není nic jiného, než
nové zpracování zpráv od jejich začátku, od určitého (třeba i relativně
zadaného) časového okamžiku atd. Tato vlastnost má dosti závažné důsledky pro
oblasti, v&nbsp;nichž se systém Apache Kafka nasazuje. Umožňuje totiž postupné
přidávání nových příjemců zpráv, kteří ihned mohou začít zpracovávat i
historické záznamy. Ostatně to je i jeden z&nbsp;důvodů, proč je Apache Kafka
tak populární v&nbsp;oblasti strojového učení (<i>machine learning</i> &ndash;
<i>ML</i>), protože umožňuje prakticky dokonalé oddělení systémů sloužících pro
sběr dat od modulů, které tato data nějakým způsobem dále zpracovávají.</p>

<pre>
      +---+---+---+---+---+---+---+---+---+
téma  | 0 | 1 | 2 | 3 | 4 | 5 | 6 | 7 | 8 | ...
      +---+---+---+---+---+---+---+---+---+
                ^                            ^
                |                          zápis
              čtení
</pre>

<p>Aby bylo možné konfigurovat a řídit, které zprávy mají být na message
brokeru uloženy a které již smazány, specifikuje se takzvaný <i>retention
time</i> zajišťující, aby počet zpráv/záznamů nepřekročil časovou mez.
Streaming server dokáže omezit i celkový počet zpráv, počet zpráv v&nbsp;tématu
a/nebo počet zpráv na jednom serveru v&nbsp;clusteru. Totéž omezení je možné
aplikovat na celkovou velikost použitého paměťového či diskového prostoru.</p>



<p><a name="k07"></a></p>
<h2 id="k07">7. Témata a oddíly</h2>

<p>Apache Kafka umožňuje ukládání zpráv (zde se ovšem používá termín záznam
&ndash; <i>record</i>) do různých témat, přičemž každé téma je rozděleno do
oddílů neboli <i>partition</i> (samozřejmě je možné pro téma vyhradit pouze
jediný oddíl a tvářit se, že máme k&nbsp;dispozici &bdquo;vylepšenou&ldquo;
frontu). Rozdělení do oddílů se provádí z&nbsp;několika důvodů. Jedním
z&nbsp;nich je rozdělení zátěže, protože jednotlivé oddíly mohou být
provozovány na různých počítačích v&nbsp;clusteru.</p>

<p>Dále se dělení provádí z&nbsp;toho důvodu, že každý oddíl obsahuje neměnnou
(<i>immutable</i>) sekvenci zpráv. Oddíly pro jednotlivá témata lze zpracovávat
v&nbsp;několika brokerech umístěných do clusteru a tak zajistit potřebný
<i>load balancing</i>, případnou replikaci zpráv atd. Každá zpráva uložená do
oddílu má přiřazen jednoznačný offset (reprezentovaný v&nbsp;Javě typem
<strong>long</strong>). Navíc je možné, aby se pro každé téma udržovalo několik
logů (<i>partition logs</i>), což umožňuje připojení většího množství
konzumentů zpráv k&nbsp;jednomu tématu s&nbsp;tím, že tito konzumenti budou
pracovat paralelně a nezávisle na sobě.</p>

<img src="https://i.iinfo.cz/images/138/microservices4-2.png" class="image-362665" alt="&#160;" width="309" height="277" />
<p><i>Obrázek 5: Příklad rozdělení témat v&nbsp;clusteru.</i></p>



<p><a name="k08"></a></p>
<h2 id="k08">8. Replikace</h2>

<p>U většiny nasazení Kafky se taktéž počítá s&nbsp;využitím většího množství
instancí brokerů, z&nbsp;nichž je vytvořen cluster. Zde se setkáme
s&nbsp;důležitým termínem <i>replikace</i> &ndash; každý oddíl je typicky
replikován na několika message brokerech v&nbsp;clusteru (ovšem nemusí se
jednat o všechny brokery, replikace se provádí například na tři brokery ve
větším clusteru).</p>

<p>To však není vše, jelikož je ve skutečnosti konfigurace poněkud složitější
&ndash; každý oddíl totiž může být replikován na více počítačích, přičemž jeden
z&nbsp;těchto oddílů je takzvaným &bdquo;leaderem&ldquo; a ostatní jsou
&bdquo;followeři&ldquo;. Zápis nových zpráv popř.&nbsp;čtení se provádí vždy
jen v&nbsp;rámci <i>leaderu</i>, ovšem změny jsou replikovány na všechny kopie
oddílu. Ve chvíli, kdy z&nbsp;nějakého (libovolného) důvodu dojde k&nbsp;pádu
&bdquo;leadera&ldquo;, převezme jeho roli jeden z&nbsp;dalších uzlů. Pokud tedy
existuje N uzlů s&nbsp;replikou oddílu, bude systém funkční i ve chvíli, kdy
zhavaruje N-1 uzlů!</p>

<p>Téma zpracovávané Kafkou může na clusteru vypadat například následovně:</p>

<pre>
          +---+---+---+---+---+---+
oddíl #0  | 0 | 1 | 2 | 3 | 4 | 5 | ...
          +---+---+---+---+---+---+
oddíl #1  | 0 | 1 | 2 | ...
          +---+---+---+
oddíl #2  | ...
          +---+---+---+---+---+---+---+---+---+
oddíl #3  | 0 | 1 | 2 | 3 | 4 | 5 | 6 | 7 | 8 | ...
          +---+---+---+---+---+---+---+---+---+
</pre>

<p>Boxy s&nbsp;čísly odpovídají jednotlivým zprávám, kterým jsou tato pořadová
čísla v&nbsp;sekvenci postupně přiřazována. Zápis nových zpráv je prováděn do
oblastí označených třemi tečkami. Z&nbsp;tohoto diagramu můžeme odvodit, že
každý oddíl obsahuje vlastní sekvenci zpráv/záznamů, ke kterým se postupně
připojují záznamy další.</p>

<p><div class="rs-tip-major">Poznámka: někdy se setkáme i s&nbsp;opačným
nakreslením diagramu s&nbsp;oddíly a se zprávami v&nbsp;nich uloženými. Důvod
je vlastně dosti jednoduchý &ndash; z&nbsp;klasických message brokerů jsme
(minimálně národy píšící zleva doprava) zvyklí na to, že vstup do fronty je
nakreslen vlevo a výstup z&nbsp;fronty naopak napravo. Výše zobrazené oddíly
používají opačný způsob, protože zprávy jsou připojovány zprava a čteny zleva
doprava.</div></p>



<p><a name="k09"></a></p>
<h2 id="k09">9. Kafka Streams</h2>

<p>Při práci se systémem Apache Kafka (typicky z&nbsp;Javy či ze Scaly) se
často používá i knihovna nazvaná <i>Kafka Streams</i>. Jedná se o knihovnu
určenou pro zjednodušení tvorby mikroslužeb. Tato knihovna je přímo součástí
klientů (operace tedy probíhají u klientů a nikoli v&nbsp;brokeru), zatímco
vstupní data jsou čteny z&nbsp;Kafky a výstupní data jsou ukládány zpět do
Kafky (pochopitelně většinou do odlišného tématu). Předností této knihovny je i
to, že kromě vstupně-výstupní datové části je možné aplikace programovat tím
způsobem, na který jsou již programátoři zvyklí.</p>

<p>Další informace o Kafka Stream lze získat na adresách:</p>

<ul>

<li>Kafka Streams<br />
<a href="https://cwiki.apache.org/confluence/display/KAFKA/Kafka+Streams">https://cwiki.apache.org/confluence/display/KAFKA/Kafka+Streams</a>
</li>

<li>Kafka Streams<br />
<a href="http://kafka.apache.org/documentation/streams/">http://kafka.apache.org/documentation/streams/</a>
</li>

<li>Kafka Streams (FAQ)<br />
<a href="https://cwiki.apache.org/confluence/display/KAFKA/FAQ#FAQ-Streams">https://cwiki.apache.org/confluence/display/KAFKA/FAQ#FAQ-Streams</a>
</li>

</ul>



<p><a name="k10"></a></p>
<h2 id="k10">10. Ekosystém Apache Kafky</h2>

<p>Vzhledem k&nbsp;popularitě Kafky pravděpodobně nebude velkým překvapením, že
okolo ní vznikl celý rozsáhlý ekosystém. Jedná se především o:</p>

<ol>

<li>Knihovnu Kafka Streams zmíněnou <a href="#k09">v&nbsp;předchozí
kapitole</a>.</li>

<li>Knihovny umožňující připojení ke Kafce <a href="#k11">z&nbsp;mnoha
programovacích jazyků</a>.</li>

<li>Konektory pro další služby, produkující proud dat.</li>

<li>Konektory pro další služby, které naopak proudy dat konzumují.</li>

<li>Konektory pro různé databáze sloužící pro vstup dat (relační databáze
s&nbsp;JDBC driverem, Cassandra, Couchbase atd. atd.)</li>

<li>Konektory pro databáze pro uložení dat (Amazon S3, Hadoop, ...)</li>

<li>Rozhraní pro systémy pro zpracování logů.</li>

<li>Již připravení konzumenti zpráv.</li>

<li>Již připravení producenti zpráv &ndash; systémy pro poskytování metrik
atd.</li>

<li>Klient ovládaný z&nbsp;příkazové řádky (<strong>kafkacat</strong>)</li>

</ol>

<a href="https://www.root.cz/obrazek/362664/"><img src="https://i.iinfo.cz/images/138/microservices4-1-prev.png" class="image-362664" alt="&#160;" width="370" height="237" /></a>
<p><i>Obrázek 6: Příklad použití ekosystému Kafky (Kafka Streams, konektory pro
databáze atd.).</i></p>

<p>Ekosystém Kafky je ovšem ve skutečnosti ještě rozsáhlejší, protože pro ni
například vznikly operátory pro Kubernetes atd. Další informace je možné získat
například ze stránek:</p>

<ul>

<li>Kafka &ndash; ecosystem (Wiki)<br />
<a href="https://cwiki.apache.org/confluence/display/KAFKA/Ecosystem">https://cwiki.apache.org/confluence/display/KAFKA/Ecosystem</a>
</li>

<li>The Kafka Ecosystem - Kafka Core, Kafka Streams, Kafka Connect, Kafka REST Proxy, and the Schema Registry<br />
<a href="http://cloudurable.com/blog/kafka-ecosystem/index.html">http://cloudurable.com/blog/kafka-ecosystem/index.html</a>
</li>

<li>A Kafka Operator for Kubernetes<br />
<a href="https://github.com/krallistic/kafka-operator">https://github.com/krallistic/kafka-operator</a>
</li>

</ul>



<p><a name="k11"></a></p>
<h2 id="k11">11. Použití systému Apache Kafka z&nbsp;různých programovacích jazyků</h2>

<p>Samotný systém Apache Kafka je naprogramován v&nbsp;Javě, takže jeho
primární platformou je pochopitelně JVM (<i>Java Virtual Machine</i>). To však
pochopitelně neznamená, že se Kafka nedá použít i z&nbsp;dalších programovacích
jazyků. Ve skutečnosti existují rozhraní pro prakticky všechny používané a/nebo
populární (což není v&nbsp;IT vždy totéž) programovací jazyky. Tato rozhraní
jsou vypsána v&nbsp;následující tabulce:</p>

<table>
<tr><th> #</th><th>Jazyk/platforma</th></tr>
<tr><td> 1</td><td><a href="https://github.com/edenhill/librdkafka">C/C++</a></td></tr>
<tr><td> 2</td><td><a href="https://github.com/confluentinc/confluent-kafka-python">Python</a></td></tr>
<tr><td> 3</td><td><a href="https://github.com/Shopify/sarama">Go/Golang</a></td></tr>
<tr><td> 4</td><td><a href="https://github.com/klarna/brod">Erlang</a></td></tr>
<tr><td> 5</td><td><a href="https://github.com/confluentinc/confluent-kafka-dotnet">.NET</a></td></tr>
<tr><td> 6</td><td><a href="https://github.com/zendesk/ruby-kafka">Ruby</a></td></tr>
<tr><td> 7</td><td><a href="https://github.com/Blizzard/node-rdkafka">Node.js</a></td></tr>
<tr><td> 8</td><td><a href="https://github.com/TrackingSoft/Kafka">Perl</a></td></tr>
<tr><td> 9</td><td><a href="https://github.com/EVODelavega/phpkafka">PHP</a></td></tr>
<tr><td>10</td><td><a href="https://github.com/spicavigo/kafka-rust">Rust</a></td></tr>
<tr><td>11</td><td><a href="https://github.com/wurstmeister/storm-kafka-0.8-plus">Storm</a></td></tr>
<tr><td>12</td><td><a href="https://github.com/elodina/scala-kafka">Scala (DSL jazyk)</a></td></tr>
<tr><td>13</td><td><a href="https://github.com/pingles/clj-kafka">Clojure</a></td></tr>
<tr><td>14</td><td><a href="https://github.com/gerritjvv/kafka-fast">Clojure</a></td></tr>
<tr><td>15</td><td><a href="https://github.com/kellanburket/franz">Swift</a></td></tr>
<tr><td>&nbsp;</td><td>&nbsp;</td></tr>
<tr><td>16</td><td><a href="https://github.com/edenhill/kafkacat">CLI (stdin/stdout)</a></td></tr>
</table>

<p><div class="rs-tip-major">Poznámka: poslední šestnáctá implementace rozhraní
je nástroj určený pro ovládání z&nbsp;příkazové řádky, který je zmíněn <a
href="#k12">v&nbsp;navazující kapitole</a>.</div></p>



<p><a name="k12"></a></p>
<h2 id="k12">12. Nástroj <strong>kafkacat</strong></h2>

<p>Součástí ekosystému vytvořeného okolo Apache Kafky je i užitečný nástroj
nazvaný <strong>kafkacat</strong> (autoři ho taktéž označují jako &bdquo;netcat
for Kafka&ldquo;, v&nbsp;kontextu REST API by se hodilo i &bdquo;curl for
Kafka&ldquo;). Tento nástroj, který naleznete na adrese <a
href="https://github.com/edenhill/kafkacat">https://github.com/edenhill/kafkacat</a>
slouží pro komunikaci s&nbsp;brokery přímo z&nbsp;příkazové řádky. Pochopitelně
se s&nbsp;velkou pravděpodobností nebude jednat o řešení používané
v&nbsp;produkčním kódu, ovšem možnost vytvořit producenta zpráv či jejich
konzumenta přímo z&nbsp;CLI je použitelná jak při vývoji, tak i při řešení
problémů, které mohou při běhu aplikace nastat. Tento nástroj budeme používat
později, při ukázkách nasazení Apache Kafky, takže se jen krátce zmiňme o
příkladech použití převzatých z&nbsp;oficiální dokumentace:</p>

<p>Spuštění nového producenta zpráv čtených ze souborů specifikovaných na
příkazové řádce:</p>

<pre>
$ <strong>kafkacat -P -b jmeno_brokera -t filedrop -p 0 file1.bin file2.txt /etc/motd dalsi_soubor.tgz</strong>
</pre>

<p>Přečtení posledních 1000 zpráv z&nbsp;tématu &bdquo;téma1&ldquo;. Po této
operaci se konzument automaticky ukončí, tj.&nbsp;nebude čekat na další
zprávy:</p>

<pre>
$ <strong>kafkacat -C -b jmeno_brokera -t tema1 -p 0 -o -1000 -e</strong>
</pre>

<p>Spuštění konzumentů, kteří jsou přihlášení k&nbsp;tématu
&bdquo;téma1&ldquo;:</p>

<pre>
$ <strong>kafkacat -b jmeno_brokera -G skupina_konzumentů téma1</strong>
</pre>

<p>Přihlásit se lze i k&nbsp;odběru většího množství témat:</p>

<pre>
$ <strong>kafkacat -b jmeno_brokera -G skupina_konzumentů téma1 téma2</strong>
</pre>

<p><div class="rs-tip-major">Poznámka: možnosti nástroje
<strong>kafkacat</strong> jsou pochopitelně mnohem větší; některé z&nbsp;nich
si popíšeme v&nbsp;dalších částech seriálu o mikroslužbách.</div></p>



<p><a name="k13"></a></p>
<h2 id="k13">13. Příklady použití Apache Kafka</h2>

<p>V&nbsp;navazujících kapitolách se zmíníme o některých možnostech použití
Apache Kafky. Uvidíme, že možnosti nasazení Kafky jsou skutečně dosti široké a
do značné míry přesahují ty oblasti, v&nbsp;nichž jsou nasazováni klasičtí
<i>message brokeři</i>. Většina příkladů použití je založena na možnosti
přehrávání (<i>replay</i>) uložených záznamů a taktéž na tom, že jednotliví
konzumenti zpráv mohou pracovat nezávisle na sobě (a to díky rozšířené
strategii <strong>PUBLISH-SUBSCRIBE</strong>).</p>



<p><a name="k14"></a></p>
<h2 id="k14">14. Logovací platforma</h2>

<p>V&nbsp;současnosti se používá poměrně velké množství systémů zajišťujících
ukládání a základní zpracování logovacích informací, a to i ve chvíli, kdy se
logy zpracovávají z&nbsp;distribuovaných zdrojů. Mezi často používané systémy
patří například <a href="https://splunk.com/">Splunk</a>, <a
href="https://www.snaresolutions.com/">Snare</a> či <a
href="https://www.elastic.co/products/logstash">Logstash</a>.</p>

<p>Ovšem pokud si uvědomíme, jaké jsou základní vlastnosti Apache Kafky, můžeme
dojít k&nbsp;závěru, že i Kafku lze pro tento účel použít; a skutečně se takto
i používá. Typicky se logovací informace ukládají do zvolených témat, přičemž
jednotlivé záznamy jsou čteny buď jedním subscriberem (nejjednodušší případ,
pokud se logy zpracovávají jediným systémem) nebo větším množstvím subscriberů
(pokud pro zpracování logů máme k&nbsp;dispozici větší množství nástrojů).
Výhoda tohoto řešení spočívá v&nbsp;tom, že jednou uložené logovací informace
bude možné zpracovat i později nějakým dalším nástrojem, který lze do systému
přidat kdykoli později. Taktéž &ndash; což vyplývá z&nbsp;vlastností samotného
systému Kafka &ndash; je možné centrální řízení životnosti logovacích
informací, jejich replikace atd.</p>

<p><div class="rs-tip-major">Poznámka: v&nbsp;současnosti je situace ve
skutečnosti ještě zajímavější, protože v&nbsp;ekosystému, který okolo Apache
Kafky vznikl, existují i konektory například pro zmíněný systém Logstash
atd.</div></p>



<p><a name="k15"></a></p>
<h2 id="k15">15. Architektura lambda</h2>

<p>Architektura <i>lambda</i> se používá v&nbsp;těch oblastech, v&nbsp;nichž
jsou data využívána například na tréning různým modelů, přehrávání situací
(sekvence událostí), k&nbsp;nimž již došlo a které byly do Kafky uloženy. Tato
architektura je ve skutečnosti velmi přímočará a jejím ústředním prvkem je opět
Apache Kafka či jiný streaming broker (NATS Streaming atd.)</p>

<p>Data získávaná z&nbsp;brokera jsou typicky zpracovávána v&nbsp;několika
komponentách, přičemž jedna komponenta je optimalizována na získávání výsledků
v&nbsp;reálném čase, kdežto další je určena pro dávkové zpracování (a další
komponenta agreguje výsledky z&nbsp;této komponenty). Aby tyto dvě komponenty
mohly pracovat korektně, musí zdroj dat obsahovat neměnitelné
(<i>immutable</i>) záznamy, ke kterým se mohou připojovat záznamy další, ovšem
další operace (smazání, modifikace, změna pořadí) již nejsou povoleny. A právě
v&nbsp;této oblasti lze s&nbsp;výhodou použít systém Apache Kafka.</p>



<p><a name="k16"></a></p>
<h2 id="k16">16. Architektura kappa</h2>

<p>S&nbsp;architekturou nazývanou <i>kappa</i> jsme se již <a
href="https://www.root.cz/clanky/zpusoby-ulozeni-dat-v-aplikacich-zalozenych-na-mikrosluzbach/#k14">v&nbsp;tomto
seriálu setkali</a>. Připomeňme si, že se jedná o jedno z&nbsp;možných řešení
pravděpodobně nejpalčivějšího problému, který se při návrhu a nasazování
mikroslužeb musí řešit. Jedná se o problém distribuce dat a synchronizace
databází jednotlivých mikroslužeb. V&nbsp;architektuře <i>kappa</i> je role
databází invertována, protože databáze (přesněji řečeno každá databáze
přidružená k&nbsp;určité mikroslužbě) zde slouží pouze ve funkci
materializovaného pohledu na data, přičemž skutečná data (dokonce i
s&nbsp;historií) jsou uložena právě v&nbsp;Apache Kafka formou záznamů
s&nbsp;informacemi o změnách. Každá mikroslužba postupně zpracovává záznamy
čtené z&nbsp;Kafky a aplikuje tyto záznamy na svou databázi &ndash; tím se
provádí její postupná synchronizace s&nbsp;okolním světem.</p>


<p>Vzhledem k&nbsp;tomu, že Apache Kafka je dnes velmi populární technologií,
používá se mnohdy i v&nbsp;těch oblastech, pro něž ve skutečnosti existují i
lepší alternativy. Příkladem mohou být řešení, které Apache Kafku používají ve
funkci klasického message brokera s&nbsp;frontami zpráv. Popišme si nyní, jak
by takové řešení mohlo vypadat. Podrobnosti v&nbsp;případě zájmu najdete
v&nbsp;článku <a
href="https://softwaremill.com/using-kafka-as-a-message-queue/">Using Kafka as
a message queue</a>.</p>

<p>Při této konfiguraci se používá několik témat, především téma nazvané
<strong>queue</strong>, které obsahuje zpracovávané zprávy. Jakmile se zpráva
z&nbsp;tohoto tématu přečte nějakým konzumentem, je nutné <i>offset</i> této
zprávy poslat společně se značkou <strong>START</strong> do tématu
<strong>markers</strong>. Ve chvíli, kdy je zpráva v&nbsp;příjemci zpracována
(k&nbsp;čemuž ovšem nemusí dojít &ndash; příjemce může zhavarovat nebo zprávu
nezpracovat), pošle se značka <strong>END</strong> s&nbsp;offsetem, a to opět
do tématu <strong>markers</strong>. V&nbsp;tomto tématu tedy budou
k&nbsp;dispozici informace o rozpracovaných zprávách i o zprávách zpracovaných.
A o tyto informace se musí starat další konzument, který zjistí, které zprávy
je nutné poslat znovu a případně je zařadí do tématu (tento konzument je ovšem
interně poměrně komplikovaný, protože musí zrekonstruovat skutečnou frontu).
Celý systém má několik problematických rysů, protože při &bdquo;vhodném&ldquo;
pádu některé z&nbsp;komponent se může informace o zpracování zprávy
ztratit, popř.&nbsp;bude nezpracovaná zpráva již zahozena.</p>

<p><div class="rs-tip-major">Poznámka: pokud potřebujete v&nbsp;systému použít
klasickou frontu zpráv (což je v&nbsp;oblasti mikroslužeb velmi častý
požadavek), použijte raději skutečného message brokera, například
<i>RabbitMQ</i>, <i>Apache ActiveMQ</i>, <i>Artemis</i> atd. V&nbsp;případě, že
se namísto fronty zpráv bude jednat spíše o frontu úloh (<i>task</i>,
<i>job</i>), může být řešení ještě jednodušší &ndash; použijte <i>rq</i>,
s&nbsp;nímž jsme se již na stránkách Roota <a
href="https://www.root.cz/clanky/pouziti-nastroje-rq-redis-queue-pro-spravu-uloh-zpracovavanych-na-pozadi/">taktéž
seznámili</a>. Zde popisované použití systému Apache Kafka spíše ukazuje
flexibilitu Kafky a nikoli zcela &bdquo;neprůstřelný&ldquo; systém, který se
dokáže zotavit z&nbsp;každé situace, která při provozu systému může
nastat.</div></p>



<p><a name="k18"></a></p>
<h2 id="k18">18. Alternativní řešení</h2>

<p>V&nbsp;oblasti nástrojů pro <i>streaming</i> je Apache Kafka
v&nbsp;současnosti s&nbsp;velkou pravděpodobností nejpopulárnějším a
nejpoužívanějším nástrojem, ovšem pochopitelně se nejedná o jediné řešení
nabízející výše popsanou funkcionalitu. Na stránkách Roota jsme se již
seznámili se systémem <a
href="https://www.root.cz/clanky/nats-streaming-server/">NATS Streaming
Server</a>, jenž je založen na message brokeru <a
href="https://www.root.cz/clanky/pouziti-message-brokeru-nats/">NATS</a>, který
je naprogramován v&nbsp;Go. Předností by měla být vyšší rychlost a menší
systémové nároky, ovšem tyto údaje je pro reálně provozované systémy složité až
nemožné získat &ndash; systémy by musely paralelně běžet jak s&nbsp;NATS
Streaming Serverem, tak i s&nbsp;Apache Kafkou a porovnání by se muselo provést
až po delší době provozu (ovšem aplikace tohoto typu psané v&nbsp;Go opravdu
bývají kvalitní).</p>



<p><a name="k19"></a></p>
<h2 id="k19">19. Odkazy na Internetu</h2>

<ol>

<li>Understanding Kafka with Legos (video)<br />
<a href="https://www.youtube.com/watch?v=Q5wOegcVa8E">https://www.youtube.com/watch?v=Q5wOegcVa8E</a>
</li>

<li>Apache Kafka Tutorial For Beginners (video)<br />
<a href="https://www.youtube.com/watch?v=U4y2R3v9tlY">https://www.youtube.com/watch?v=U4y2R3v9tlY</a>
</li>

<li>Franz Kafka (Wikipedia)<br />
<a href="https://en.wikipedia.org/wiki/Franz_Kafka">https://en.wikipedia.org/wiki/Franz_Kafka</a>
</li>

<li>NATS<br />
<a href="https://nats.io/about/">https://nats.io/about/</a>
</li>

<li>NATS Streaming Concepts<br />
<a href="https://nats.io/documentation/streaming/nats-streaming-intro/">https://nats.io/documentation/streaming/nats-streaming-intro/</a>
</li>

<li>NATS Streaming Server<br />
<a href="https://nats.io/download/nats-io/nats-streaming-server/">https://nats.io/download/nats-io/nats-streaming-server/</a>
</li>

<li>NATS Introduction<br />
<a href="https://nats.io/documentation/">https://nats.io/documentation/</a>
</li>

<li>NATS Client Protocol<br />
<a href="https://nats.io/documentation/internals/nats-protocol/">https://nats.io/documentation/internals/nats-protocol/</a>
</li>

<li>NATS Messaging (Wikipedia)<br />
<a href="https://en.wikipedia.org/wiki/NATS_Messaging">https://en.wikipedia.org/wiki/NATS_Messaging</a>
</li>

<li>Stránka Apache Software Foundation<br />
<a href="http://www.apache.org/">http://www.apache.org/</a>
</li>

<li>Logstash<br />
<a href="https://www.elastic.co/products/logstash">https://www.elastic.co/products/logstash</a>
</li>

<li>Elasticsearch<br />
<a href="https://www.elastic.co/products/elasticsearch">https://www.elastic.co/products/elasticsearch</a>
</li>

<li>Understanding When to use RabbitMQ or Apache Kafka<br />
<a href="https://content.pivotal.io/blog/understanding-when-to-use-rabbitmq-or-apache-kafka">https://content.pivotal.io/blog/understanding-when-to-use-rabbitmq-or-apache-kafka</a>
</li>

<li>Part 1: Apache Kafka for beginners - What is Apache Kafka?<br />
<a href="https://www.cloudkarafka.com/blog/2016-11-30-part1-kafka-for-beginners-what-is-apache-kafka.html">https://www.cloudkarafka.com/blog/2016-11-30-part1-kafka-for-beginners-what-is-apache-kafka.html</a>
</li>

<li>What are some alternatives to Apache Kafka?<br />
<a href="https://www.quora.com/What-are-some-alternatives-to-Apache-Kafka">https://www.quora.com/What-are-some-alternatives-to-Apache-Kafka</a>
</li>

<li>What is the best alternative to Kafka?<br />
<a href="https://www.slant.co/options/961/alternatives/~kafka-alternatives">https://www.slant.co/options/961/alternatives/~kafka-alternatives</a>
</li>

<li>Apache Flume<br />
<a href="https://flume.apache.org/index.html">https://flume.apache.org/index.html</a>
</li>

<li>Snare<br />
<a href="https://www.snaresolutions.com/">https://www.snaresolutions.com/</a>
</li>

<li>The Log: What every software engineer should know about real-time data's unifying abstraction<br />
<a href="https://engineering.linkedin.com/distributed-systems/log-what-every-software-engineer-should-know-about-real-time-datas-unifying">https://engineering.linkedin.com/distributed-systems/log-what-every-software-engineer-should-know-about-real-time-datas-unifying</a>
</li>

<li>A super quick comparison between Kafka and Message Queues<br />
<a href="https://hackernoon.com/a-super-quick-comparison-between-kafka-and-message-queues-e69742d855a8?gi=e965191e72d0">https://hackernoon.com/a-super-quick-comparison-between-kafka-and-message-queues-e69742d855a8?gi=e965191e72d0</a>
</li>

<li>Kafka Queuing: Kafka as a Messaging System<br />
<a href="https://dzone.com/articles/kafka-queuing-kafka-as-a-messaging-system">https://dzone.com/articles/kafka-queuing-kafka-as-a-messaging-system</a>
</li>

<li>Microservices - Not a free lunch!<br />
<a href="http://highscalability.com/blog/2014/4/8/microservices-not-a-free-lunch.html">http://highscalability.com/blog/2014/4/8/microservices-not-a-free-lunch.html</a>
</li>

<li>Microservices, Monoliths, and NoOps<br />
<a href="http://blog.arungupta.me/microservices-monoliths-noops/">http://blog.arungupta.me/microservices-monoliths-noops/</a>
</li>

<li>Microservice Design Patterns<br />
<a href="http://blog.arungupta.me/microservice-design-patterns/">http://blog.arungupta.me/microservice-design-patterns/</a>
</li>

<li>Vision of a microservice revolution<br />
<a href="https://www.jolie-lang.org/vision.html">https://www.jolie-lang.org/vision.html</a>
</li>

<li>Microservices: a definition of this new architectural term<br />
<a href="https://martinfowler.com/articles/microservices.html">https://martinfowler.com/articles/microservices.html</a>
</li>

<li>Mikroslužby<br />
<a href="http://voho.eu/wiki/mikrosluzba/">http://voho.eu/wiki/mikrosluzba/</a>
</li>

<li>Microservice Prerequisites<br />
<a href="https://martinfowler.com/bliki/MicroservicePrerequisites.html">https://martinfowler.com/bliki/MicroservicePrerequisites.html</a>
</li>

<li>Microservices in Practice, Part 1: Reality Check and Service Design (vyžaduje registraci)<br />
<a href="https://ieeexplore.ieee.org/document/7819415">https://ieeexplore.ieee.org/document/7819415</a>
</li>

<li>Microservice Trade-Offs<br />
<a href="https://www.martinfowler.com/articles/microservice-trade-offs.html">https://www.martinfowler.com/articles/microservice-trade-offs.html</a>
</li>

<li>What is a microservice? (from a linguistic point of view)<br />
<a href="http://claudioguidi.blogspot.com/2017/03/what-microservice-from-linguisitc.html">http://claudioguidi.blogspot.com/2017/03/what-microservice-from-linguisitc.html</a>
</li>

<li>Microservices (Wikipedia)<br />
<a href="https://en.wikipedia.org/wiki/Microservices">https://en.wikipedia.org/wiki/Microservices</a>
</li>

<li>Fallacies of distributed computing (Wikipedia)<br />
<a href="https://en.wikipedia.org/wiki/Fallacies_of_distributed_computing">https://en.wikipedia.org/wiki/Fallacies_of_distributed_computing</a>
</li>

<li>Service (systems architecture)<br />
<a href="https://en.wikipedia.org/wiki/Service_(systems_architecture)">https://en.wikipedia.org/wiki/Service_(systems_architecture)</a>
</li>

<li>Microservices in a Nutshell<br />
<a href="https://www.thoughtworks.com/insights/blog/microservices-nutshell">https://www.thoughtworks.com/insights/blog/microservices-nutshell</a>
</li>

<li>What is Microservices?<br />
<a href="https://smartbear.com/solutions/microservices/">https://smartbear.com/solutions/microservices/</a>
</li>

<li>Mastering Chaos - A Netflix Guide to Microservices<br />
<a href="https://www.youtube.com/watch?v=CZ3wIuvmHeM&t=17s">https://www.youtube.com/watch?v=CZ3wIuvmHeM&amp;t=17s</a>
</li>

<li>Messaging in Microservice Architecture<br />
<a href="https://www.youtube.com/watch?v=MkQWQ5f-SEY">https://www.youtube.com/watch?v=MkQWQ5f-SEY</a>
</li>

<li>Pattern: Messaging<br />
<a href="https://microservices.io/patterns/communication-style/messaging.html">https://microservices.io/patterns/communication-style/messaging.html</a>
</li>

<li>Microservices Messaging: Why REST Isn’t Always the Best Choice<br />
<a href="https://blog.codeship.com/microservices-messaging-rest-isnt-always-best-choice/">https://blog.codeship.com/microservices-messaging-rest-isnt-always-best-choice/</a>
</li>

<li>Protocol buffers<br />
<a href="https://developers.google.com/protocol-buffers/">https://developers.google.com/protocol-buffers/</a>
</li>

<li>BSON<br />
<a href="http://bsonspec.org/">http://bsonspec.org/</a>
</li>

<li>Apache Avro!<br />
<a href="https://avro.apache.org/">https://avro.apache.org/</a>
</li>

<li>REST vs Messaging for Microservices – Which One is Best?<br />
<a href="https://solace.com/blog/experience-awesomeness-event-driven-microservices/">https://solace.com/blog/experience-awesomeness-event-driven-microservices/</a>
</li>

<li>How did we end up here?<br />
<a href="https://gotocon.com/dl/goto-chicago-2015/slides/MartinThompson_and_ToddMontgomery_HowDidWeEndUpHere.pdf">https://gotocon.com/dl/goto-chicago-2015/slides/MartinThompson_and_ToddMontgomery_HowDidWeEndUpHere.pdf</a>
</li>

<li>Scaling microservices with message queues to handle data bursts<br />
<a href="https://read.acloud.guru/scaling-microservices-with-message-queue-2d389be5b139">https://read.acloud.guru/scaling-microservices-with-message-queue-2d389be5b139</a>
</li>

<li>Microservices: What are smart endpoints and dumb pipes?<br />
<a href="https://stackoverflow.com/questions/26616962/microservices-what-are-smart-endpoints-and-dumb-pipes">https://stackoverflow.com/questions/26616962/microservices-what-are-smart-endpoints-and-dumb-pipes</a>
</li>

<li>Common Object Request Broker Architecture<br />
<a href="https://en.wikipedia.org/wiki/Common_Object_Request_Broker_Architecture">https://en.wikipedia.org/wiki/Common_Object_Request_Broker_Architecture</a>
</li>

<li>Enterprise service bus<br />
<a href="https://en.wikipedia.org/wiki/Enterprise_service_bus">https://en.wikipedia.org/wiki/Enterprise_service_bus</a>
</li>

<li>Microservices vs SOA : What’s the Difference<br />
<a href="https://www.edureka.co/blog/microservices-vs-soa/">https://www.edureka.co/blog/microservices-vs-soa/</a>
</li>

<li>Pravda o SOA<br />
<a href="https://businessworld.cz/reseni-a-realizace/pravda-o-soa-2980">https://businessworld.cz/reseni-a-realizace/pravda-o-soa-2980</a>
</li>

<li>Is it a good idea for Microservices to share a common database?<br />
<a href="https://www.quora.com/Is-it-a-good-idea-for-Microservices-to-share-a-common-database">https://www.quora.com/Is-it-a-good-idea-for-Microservices-to-share-a-common-database</a>
</li>

<li>Pattern: Shared database<br />
<a href="https://microservices.io/patterns/data/shared-database.html">https://microservices.io/patterns/data/shared-database.html</a>
</li>

<li>Is a Shared Database in Microservices Actually an Anti-pattern?<br />
<a href="https://hackernoon.com/is-shared-database-in-microservices-actually-anti-pattern-8cc2536adfe4">https://hackernoon.com/is-shared-database-in-microservices-actually-anti-pattern-8cc2536adfe4</a>
</li>

<li>Shared database in microservices is a problem, yep<br />
<a href="https://ayende.com/blog/186914-A/shared-database-in-microservices-is-a-problem-yep">https://ayende.com/blog/186914-A/shared-database-in-microservices-is-a-problem-yep</a>
</li>

<li>Microservices with shared database? using multiple ORM's?<br />
<a href="https://stackoverflow.com/questions/43612866/microservices-with-shared-database-using-multiple-orms">https://stackoverflow.com/questions/43612866/microservices-with-shared-database-using-multiple-orms</a>
</li>

<li>Examples of microservice architecture<br />
<a href="https://www.coursera.org/lecture/intro-ibm-microservices/examples-of-microservice-architecture-JXOFj">https://www.coursera.org/lecture/intro-ibm-microservices/examples-of-microservice-architecture-JXOFj</a>
</li>

<li>Microservices: The Rise Of Kafka<br />
<a href="https://movio.co/blog/microservices-rise-kafka/">https://movio.co/blog/microservices-rise-kafka/</a>
</li>

<li>Building a Microservices Ecosystem with Kafka Streams and KSQL<br />
<a href="https://www.confluent.io/blog/building-a-microservices-ecosystem-with-kafka-streams-and-ksql/">https://www.confluent.io/blog/building-a-microservices-ecosystem-with-kafka-streams-and-ksql/</a>
</li>

<li>An introduction to Apache Kafka and microservices communication<br />
<a href="https://medium.com/@ulymarins/an-introduction-to-apache-kafka-and-microservices-communication-bf0a0966d63">https://medium.com/@ulymarins/an-introduction-to-apache-kafka-and-microservices-communication-bf0a0966d63</a>
</li>

<li>ACID (computer science)<br />
<a href="https://en.wikipedia.org/wiki/ACID_(computer_science)">https://en.wikipedia.org/wiki/ACID_(computer_science)</a>
</li>

<li>Distributed transaction<br />
<a href="https://en.wikipedia.org/wiki/Distributed_transaction">https://en.wikipedia.org/wiki/Distributed_transaction</a>
</li>

<li>Two-phase commit protocol<br />
<a href="https://en.wikipedia.org/wiki/Two-phase_commit_protocol">https://en.wikipedia.org/wiki/Two-phase_commit_protocol</a>
</li>

<li>Why is 2-phase commit not suitable for a microservices architecture?<br />
<a href="https://stackoverflow.com/questions/55249656/why-is-2-phase-commit-not-suitable-for-a-microservices-architecture">https://stackoverflow.com/questions/55249656/why-is-2-phase-commit-not-suitable-for-a-microservices-architecture</a>
</li>

<li>4 reasons why microservices resonate<br />
<a href="https://www.oreilly.com/ideas/4-reasons-why-microservices-resonate">https://www.oreilly.com/ideas/4-reasons-why-microservices-resonate</a>
</li>

<li>Pattern: Microservice Architecture<br />
<a href="https://microservices.io/patterns/microservices.html">https://microservices.io/patterns/microservices.html</a>
</li>

<li>Pattern: Monolithic Architecture<br />
<a href="https://microservices.io/patterns/monolithic.html">https://microservices.io/patterns/monolithic.html</a>
</li>

<li>Pattern: Saga<br />
<a href="https://microservices.io/patterns/data/saga.html">https://microservices.io/patterns/data/saga.html</a>
</li>

<li>Pattern: Database per service<br />
<a href="https://microservices.io/patterns/data/database-per-service.html">https://microservices.io/patterns/data/database-per-service.html</a>
</li>

<li>Pattern: Access token<br />
<a href="https://microservices.io/patterns/security/access-token.html">https://microservices.io/patterns/security/access-token.html</a>
</li>

<li>Databázová integrita<br />
<a href="https://cs.wikipedia.org/wiki/Datab%C3%A1zov%C3%A1_integrita">https://cs.wikipedia.org/wiki/Datab%C3%A1zov%C3%A1_integrita</a>
</li>

<li>Referenční integrita<br />
<a href="https://cs.wikipedia.org/wiki/Referen%C4%8Dn%C3%AD_integrita">https://cs.wikipedia.org/wiki/Referen%C4%8Dn%C3%AD_integrita</a>
</li>

<li>Introduction into Microservices <br />
<a href="https://specify.io/concepts/microservices">https://specify.io/concepts/microservices</a>
</li>

<li>Are Microservices ‘SOA Done Right’?<br />
<a href="https://intellyx.com/2015/07/20/are-microservices-soa-done-right/">https://intellyx.com/2015/07/20/are-microservices-soa-done-right/</a>
</li>

<li>The Hardest Part About Microservices: Your Data<br />
<a href="https://blog.christianposta.com/microservices/the-hardest-part-about-microservices-data/">https://blog.christianposta.com/microservices/the-hardest-part-about-microservices-data/</a>
</li>

<li>From a monolith to microservices + REST<br />
<a href="https://www.slideshare.net/InfoQ/from-a-monolith-to-microservices-rest-the-evolution-of-linkedins-service-architecture">https://www.slideshare.net/InfoQ/from-a-monolith-to-microservices-rest-the-evolution-of-linkedins-service-architecture</a>
</li>

<li>DevOps and the Myth of Efficiency, Part I<br />
<a href="https://blog.christianposta.com/devops/devops-and-the-myth-of-efficiency-part-i/">https://blog.christianposta.com/devops/devops-and-the-myth-of-efficiency-part-i/</a>
</li>

<li>DevOps and the Myth of Efficiency, Part II<br />
<a href="https://blog.christianposta.com/devops/devops-and-the-myth-of-efficiency-part-ii/">https://blog.christianposta.com/devops/devops-and-the-myth-of-efficiency-part-ii/</a>
</li>

<li>Standing on Distributed Shoulders of Giants: Farsighted Physicists of Yore Were Danged Smart!<br />
<a href="https://queue.acm.org/detail.cfm?id=2953944">https://queue.acm.org/detail.cfm?id=2953944</a>
</li>

<li>Building DistributedLog: High-performance replicated log service<br />
<a href="https://blog.twitter.com/engineering/en_us/topics/infrastructure/2015/building-distributedlog-twitter-s-high-performance-replicated-log-servic.html">https://blog.twitter.com/engineering/en_us/topics/infrastructure/2015/building-distributedlog-twitter-s-high-performance-replicated-log-servic.html</a>
</li>

<li>Turning the database inside-out with Apache Samza<br />
<a href="https://www.confluent.io/blog/turning-the-database-inside-out-with-apache-samza/">https://www.confluent.io/blog/turning-the-database-inside-out-with-apache-samza/</a>
</li>

<li>Debezium: Stream changes from your databases.<br />
<a href="https://debezium.io/">https://debezium.io/</a>
</li>

<li>Change data capture<br />
<a href="https://en.wikipedia.org/wiki/Change_data_capture">https://en.wikipedia.org/wiki/Change_data_capture</a>
</li>

<li>Apache Samza (Wikipedia)<br />
<a href="https://en.wikipedia.org/wiki/Apache_Samza">https://en.wikipedia.org/wiki/Apache_Samza</a>
</li>

<li>Storm (event processor)<br />
<a href="https://en.wikipedia.org/wiki/Storm_(event_processor)">https://en.wikipedia.org/wiki/Storm_(event_processor)</a>
</li>

<li>kappa-architecture.com<br />
<a href="http://milinda.pathirage.org/kappa-architecture.com/">http://milinda.pathirage.org/kappa-architecture.com/</a>
</li>

<li>Questioning the Lambda Architecture<br />
<a href="https://www.oreilly.com/ideas/questioning-the-lambda-architecture">https://www.oreilly.com/ideas/questioning-the-lambda-architecture</a>
</li>

<li>Lambda architecture<br />
<a href="https://en.wikipedia.org/wiki/Lambda_architecture">https://en.wikipedia.org/wiki/Lambda_architecture</a>
</li>

<li>Event stream processing<br />
<a href="https://en.wikipedia.org/wiki/Event_stream_processing">https://en.wikipedia.org/wiki/Event_stream_processing</a>
</li>

<li>How to beat the CAP theorem<br />
<a href="http://nathanmarz.com/blog/how-to-beat-the-cap-theorem.html">http://nathanmarz.com/blog/how-to-beat-the-cap-theorem.html</a>
</li>

<li>Kappa Architecture Our Experience<br />
<a href="https://events.static.linuxfound.org/sites/events/files/slides/ASPgems%20-%20Kappa%20Architecture.pdf">https://events.static.linuxfound.org/sites/events/files/slides/ASPgems%20-%20Kappa%20Architecture.pdf</a>
</li>

<li>Messaging Patterns in Event Driven Microservice Architectures<br />
<a href="https://www.youtube.com/watch?v=3xDc4MEYuHI">https://www.youtube.com/watch?v=3xDc4MEYuHI</a>
</li>

<li>Why monolithic apps are often better than microservices<br />
<a href="https://gigaom.com/2015/11/06/why-monolithic-apps-are-often-better-than-microservices/">https://gigaom.com/2015/11/06/why-monolithic-apps-are-often-better-than-microservices/</a>
</li>

<li>How Enterprise PaaS Can Add Critical Value to Microservices<br />
<a href="https://apprenda.com/blog/enterprise-paas-microservices/">https://apprenda.com/blog/enterprise-paas-microservices/</a>
</li>

<li>Common React Mistakes: Monolithic Components and a Lack of Abstraction<br />
<a href="https://www.pmg.com/blog/common-react-mistakes-monolithic-components-lack-abstraction/">https://www.pmg.com/blog/common-react-mistakes-monolithic-components-lack-abstraction/</a>
</li>

<li>From monolith to microservices – to migrate or not to migrate?<br />
<a href="https://altkomsoftware.pl/en/blog/monolith-microservices/">https://altkomsoftware.pl/en/blog/monolith-microservices/</a>
</li>

<li>Command–query separation<br />
<a href="https://en.wikipedia.org/wiki/Command%E2%80%93query_separation">https://en.wikipedia.org/wiki/Command%E2%80%93query_separation</a>
</li>

<li>GOTO 2016: Messaging and Microservices (Clemens Vasters)<br />
<a href="https://www.youtube.com/watch?v=rXi5CLjIQ9kx">https://www.youtube.com/watch?v=rXi5CLjIQ9kx</a>
</li>

<li>GOTO Amsterdam 2019<br />
<a href="https://gotoams.nl/">https://gotoams.nl/</a>
</li>

<li>Lesson 2 - Kafka vs. Standard Messaging<br />
<a href="https://www.youtube.com/watch?v=lwMjjTT1Q-Q">https://www.youtube.com/watch?v=lwMjjTT1Q-Q</a>
</li>

<li>CommandQuerySeparation (Martin Fowler)<br />
<a href="https://martinfowler.com/bliki/CommandQuerySeparation.html">https://martinfowler.com/bliki/CommandQuerySeparation.html</a>
</li>

<li>Command–query separation<br />
<a href="https://en.wikipedia.org/wiki/Command%E2%80%93query_separation">https://en.wikipedia.org/wiki/Command%E2%80%93query_separation</a>
</li>

<li>CQRS - Martin Fowler<br />
<a href="https://martinfowler.com/bliki/CQRS.html">https://martinfowler.com/bliki/CQRS.html</a>
</li>

<li>Lesson 12 - CQRS and Microservices<br />
<a href="https://www.youtube.com/watch?v=pUGvXUBfvEE">https://www.youtube.com/watch?v=pUGvXUBfvEE</a>
</li>

<li>Message queues - the right way to process and work with realtime data on your servers<br />
<a href="https://www.ably.io/blog/message-queues-the-right-way">https://www.ably.io/blog/message-queues-the-right-way</a>
</li>

</ol>



<p></p><p></p>
<p><small>Autor: <a href="http://www.fit.vutbr.cz/~tisnovpa">Pavel Tišnovský</a> &nbsp; 2019</small></p>
</body>
</html>

