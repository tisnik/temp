<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
        "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html>
<head>
<title>Interní reprezentace numerických hodnot: od skutečného počítačového pravěku po IEEE 754-2008 (dokončení)</title>
<meta name="Author" content="Pavel Tisnovsky" />
<meta name="Generator" content="vim" />
<meta http-equiv="content-type" content="text/html; charset=utf-8" />
<style type="text/css">
         body {color:#000000; background:#ffffff;}
         h1  {font-family: arial, helvetica, sans-serif; color:#ffffff; background-color:#c00000; text-align:center; padding-left:1em}
         h2  {font-family: arial, helvetica, sans-serif; color:#ffffff; background-color:#0000c0; padding-left:1em; text-align:left}
         h3  {font-family: arial, helvetica, sans-serif; color:#000000; background-color:#c0c0c0; padding-left:1em; text-align:left}
         h4  {font-family: arial, helvetica, sans-serif; color:#000000; background-color:#e0e0e0; padding-left:1em; text-align:left}
         a   {font-family: arial, helvetica, sans-serif;}
         li  {font-family: arial, helvetica, sans-serif; color:#000000; text-align:justify; width:450px;}
         ol  {font-family: arial, helvetica, sans-serif; color:#000000; text-align:justify; width:450px;}
         ul  {font-family: arial, helvetica, sans-serif; color:#000000; text-align:justify; width:450px;}
         p   {font-family: arial, helvetica, sans-serif; color:#000000; text-align:justify;}
         pre {background:#e0e0e0}
</style>
</head>

<body>

<h1>Interní reprezentace numerických hodnot: od skutečného počítačového pravěku po IEEE 754-2008 (dokončení)</h1>

<h3>Pavel Tišnovský</h3>

<p></p>

<h1>Úvodník</h1>

<p>Ve druhé části článku o reprezentaci numerických hodnot se nejdříve zmíníme o standardních i rozšířených formátech definovaných v IEEE 754-2008, popíšeme si "malé" FP formáty a samozřejmě nezapomeneme ani na formáty používající BCD, ať již v původní či komprimované podobě.</p>



<h2>Obsah</h2>

<p><a href="#k01">1. Interní reprezentace numerických hodnot: od skutečného počítačového pravěku po IEEE 754-2008 (dokončení)</a></p>
<p><a href="#k02">2. Norma IEEE 754 a IEEE 754-2008</a></p>
<p><a href="#k03">3. Vliv existence IEEE 754 na další vývoj IT</a></p>
<p><a href="#k04">4. Varianta <strong>single</strong> &ndash; hodnoty s&nbsp;jednoduchou přesností</a></p>
<p><a href="#k05">5. Varianta <strong>double</strong> &ndash; hodnoty s&nbsp;dvojnásobnou přesností</a></p>
<p><a href="#k06">6. Denormalizovaná čísla, hodnoty typu NaN a nekonečna</a></p>
<p><a href="#k07">7. Rozšířený formát <strong>extended</strong>/<strong>temporary</strong></a></p>
<p><a href="#k08">8. Varianta <strong>quadruple</strong> &ndash; hodnoty se čtyřnásobnou přesností</a></p>
<p><a href="#k09">9. Varianta <strong>octuple</strong> &ndash; 256 bitů pro jedno číslo</a></p>
<p><a href="#k10">10. Varianta <strong>half</strong> &ndash; poloviční přesnost</a></p>
<p><a href="#k11">11. Další &bdquo;malé&ldquo; FP varianty</a></p>
<p><a href="#k12">12. Použití BCD pro uložení čísel i pro výpočty</a></p>
<p><a href="#k13">13. Podpora pro výpočty v&nbsp;BCD v&nbsp;instrukčních sadách mikroprocesorů</a></p>
<p><a href="#k14">14. Od BCD ke kódování EBCDIC</a></p>
<p><a href="#k15">15. Formáty s&nbsp;plovoucí řádovou čárkou s&nbsp;bází rovnou deseti</a></p>
<p><a href="#k16">16. Příklad FP s&nbsp;bází rovnou deseti: Packed Decimal u mikroprocesorů Motorola 68000</a></p>
<p><a href="#k17">17. &bdquo;Komprimované&ldquo; formáty založené na BCD aneb jak uložit tři číslice do deseti bitů</a></p>
<p><a href="#k18">18. Formáty decimal32, decimal64 a decimal128</a></p>
<p><a href="#k19">19. Alternativní formát uložení čísel &ndash; zlomky (<i>rational</i>)</a></p>
<p><a href="#k20">20. Odkazy na Internetu</a></p>



<p><a name="k01"></a></p>
<h2 id="k01">1. Interní reprezentace numerických hodnot: od skutečného počítačového pravěku po IEEE 754-2008 (dokončení)</h2>

<p><a
href="https://www.root.cz/clanky/interni-reprezentace-numerickych-hodnot-od-skutecneho-pocitacoveho-praveku-po-ieee-754-2008/">V&nbsp;první
části článku</a> o způsobech reprezentace numerických hodnot jsme se seznámili
především s&nbsp;různými variantami použití plovoucí řádové čárky (FP &ndash;
floating point), což je formát, který byl poměrně masivně používán už na první
generaci elektronkových mainframů firmy IBM. Dále jsme si řekli, jak byly
numerické hodnoty reprezentovány na některých starších počítačích
popř.&nbsp;v&nbsp;knihovnách různých jazyků &ndash; Sinclair BASICu, Atari
BASICu, Turbo Pascalu atd. Dnes toto poměrně rozsáhlé téma dokončíme. Nejdříve
si popíšeme základní formáty definované v&nbsp;normě IEEE 754 (ty ostatně
většina programátorů používá prakticky každý den), dále se zmíníme o
rozšířených formátech (nazývanými poněkud nepřesně &bdquo;half
precision&ldquo;, &bdquo;double extended/temporary&ldquo;, &bdquo;quadruple
precision&ldquo;, &bdquo;octuple precision&ldquo;), o takzvaných
&bdquo;malých&ldquo; FP formátech a samozřejmě nezapomeneme ani na formáty
používající BCD, ať již v&nbsp;původní formě, tak i v&nbsp;komprimované
podobě.</p>

<a href="http://i.iinfo.cz/images/580/38cray03.jpg"><img src="http://i.iinfo.cz/images/580/38cray03-prev.jpg" width="364" height="270" alt=" " /></a>
<p><i>Obrázek 1: Superpočítač CDC 7600, který lze považovat za předchůdce
superpočítačů CRAY. Tyto stroje byly optimalizovány na výpočty, nikoli
například na hromadné zpracování dat. Právě v&nbsp;souvislosti se superpočítači
CRAY se začala objevovat zkratka MFLOPS (později GFLOPS) udávající rychlost FP
výpočtů.</i></p>

<p>Tabulku s&nbsp;různými formáty numerických hodnot si rozšíříme o další
varianty:</p>

<table>
<tr><th>Počítač/norma/systém</th><th>Šířka (b)</th><th>Báze</th><th>Exponent (b)</th><th>Mantisa (b)</th></tr>
<tr><td><a href="#k11">&bdquo;microfloat&ldquo;</a></td><td>8</td><td>2</td><td>4</td><td>3+1</td></tr>
<tr><td><a href="#k10">IEEE 754 half</a></td><td>16</td><td>2</td><td>5</td><td>10+1</td></tr>
<tr><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td></tr>
<tr><td><a href="#k04">IEEE 754 single</a></td><td>32</td><td>2</td><td>8</td><td>23+1</td></tr>
<tr><td><a href="#k05">IEEE 754 double</a></td><td>64</td><td>2</td><td>11</td><td>52+1</td></tr>
<tr><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td></tr>
<tr><td><a href="#k07">IEEE 754 double extended</a></td><td>80</td><td>2</td><td>15</td><td>64</td></tr>
<tr><td><a href="#k08">IEEE 754 quadruple</a></td><td>128</td><td>2</td><td>15</td><td>112+1</td></tr>
<tr><td><a href="#k09">IEEE 754 octuple</a></td><td>256</td><td>2</td><td>19</td><td>236+1</td></tr>
<tr><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td></tr>
<tr><td><a href="#k18">IEEE 754 decimal32</a></td><td>32</td><td>10</td><td>variabilní</td><td>20</td></tr>
<tr><td><a href="#k18">IEEE 754 decimal64</a></td><td>32</td><td>10</td><td>variabilní</td><td>50</td></tr>
<tr><td><a href="#k18">IEEE 754 decimal128</a></td><td>32</td><td>10</td><td>variabilní</td><td>110</td></tr>
<tr><td><a href="https://www.root.cz/clanky/interni-reprezentace-numerickych-hodnot-od-skutecneho-pocitacoveho-praveku-po-ieee-754-2008/#k06">IBM řady 7xx</a></td><td>36</td><td>2</td><td>8</td><td>27</td></tr>
<tr><td><a href="https://www.root.cz/clanky/interni-reprezentace-numerickych-hodnot-od-skutecneho-pocitacoveho-praveku-po-ieee-754-2008/#k10">IBM 360 single</a></td><td>32</td><td>16</td><td>7</td><td>24</td></tr>
<tr><td><a href="https://www.root.cz/clanky/interni-reprezentace-numerickych-hodnot-od-skutecneho-pocitacoveho-praveku-po-ieee-754-2008/#k10">IBM 360 double</a></td><td>64</td><td>16</td><td>7</td><td>56</td></tr>
<tr><td>HP 3000 single</td><td>32</td><td>2</td><td>9</td><td>22</td></tr>
<tr><td>HP 3000 double</td><td>64</td><td>2</td><td>9</td><td>54</td></tr>
<tr><td>CDC 6000, 6600</td><td>60</td><td>2</td><td>11</td><td>48+1</td></tr>
<tr><td><a href="https://www.root.cz/clanky/interni-reprezentace-numerickych-hodnot-od-skutecneho-pocitacoveho-praveku-po-ieee-754-2008/#k11">Cray-1</a></td><td>64</td><td>2</td><td>15</td><td>48</td></tr>
<tr><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td></tr>
<tr><td><a href="https://www.root.cz/clanky/interni-reprezentace-numerickych-hodnot-od-skutecneho-pocitacoveho-praveku-po-ieee-754-2008/#k09">Strela</a></td><td>43</td><td>2</td><td>7</td><td>35</td></tr>
<tr><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td></tr>
<tr><td><a href="https://www.root.cz/clanky/interni-reprezentace-numerickych-hodnot-od-skutecneho-pocitacoveho-praveku-po-ieee-754-2008/#k13">Apple II</a></td><td>40</td><td>2</td><td>8</td><td>31+1</td></tr>
<tr><td><a href="https://www.root.cz/clanky/interni-reprezentace-numerickych-hodnot-od-skutecneho-pocitacoveho-praveku-po-ieee-754-2008/#k14">ZX Spectrum</a></td><td>40</td><td>2</td><td>8</td><td>31+1</td></tr>
<tr><td><a href="https://www.root.cz/clanky/interni-reprezentace-numerickych-hodnot-od-skutecneho-pocitacoveho-praveku-po-ieee-754-2008/#k15">Atari (FP rutiny)</a></td><td>48</td><td>10</td><td>7</td><td>40</td></tr>
<tr><td><a href="https://www.root.cz/clanky/interni-reprezentace-numerickych-hodnot-od-skutecneho-pocitacoveho-praveku-po-ieee-754-2008/#k16">Turbo Pascal real</a></td><td>48</td><td>2</td><td>8</td><td>39</td></tr>
</table>

<p>Poznámka: pro připomenutí &ndash; pokud je ve sloupci <i>Mantisa</i> napsána
hodnota n+1, znamená to, že hodnoty jsou normalizovány tak, aby první bit
mantisy byl vždy jedničkový. V&nbsp;takovém případě tento bit nemusíme nikam
zapisovat (víme, že je jednička) a tudíž se mantisa automaticky o tento jeden
bit rozšiřuje. To samozřejmě neplatí pro denormalizované hodnoty (blízké
nule).</p>

<a href="http://i.iinfo.cz/images/111/hist3916.png"><img src="http://i.iinfo.cz/images/111/hist3916-prev.png" width="370" height="153" alt=" " /></a>
<p><i>Obrázek 2: Některé typy programových smyček optimalizovaných překladačem
FORTRANu 77 pro počítače Cray-2. Většina optimalizací byla umožněna použitím
vektorů s&nbsp;FP hodnotami.<br />
(zdroj: materiály firmy Cray Research)</i></p>



<p><a name="k02"></a></p>
<h2 id="k02">2. Norma IEEE 754 a IEEE 754-2008</h2>

<p>Důležitým milníkem v&nbsp;reprezentaci reálných čísel se stala norma IEEE
754, která se používá u naprosté většiny polovodičových čipů vyrobených
v&nbsp;posledním čtvrtstoletí. V&nbsp;normě <i>IEEE 754</i>, jejíž první verze
je mimochodem v&nbsp;platnosti již od roku 1985, jsou specifikovány nejenom
vlastní formáty uložení numerických hodnot v&nbsp;systému pohyblivé řádové
čárky (FP formátu), ale i pravidla implementace základních aritmetických
operací s&nbsp;těmito hodnotami, aplikace zaokrouhlovacích režimů, způsoby
některých konverzí apod. Konkrétně je v&nbsp;této normě popsáno:</p>

<ol>
<li>Základní (<i>basic</i>) a rozšířený (<i>extended</i>) formát uložení numerických hodnot.</li>
<li>Způsob provádění základních matematických operací:
    <ul>
    <li>součet</li>
    <li>rozdíl</li>
    <li>součin</li>
    <li>podíl</li>
    <li>zbytek po dělení</li>
    <li>druhá odmocnina</li>
    <li>porovnání</li>
    </ul></li>
<li>Režimy zaokrouhlování.</li>
<li>Způsob práce s&nbsp;denormalizovanými hodnotami.</li>
<li>Pravidla konverze mezi celočíselnými formáty (<i>integer</i> bez a se znaménkem) a formáty s&nbsp;plovoucí řádovou čárkou.</li>
<li>Způsob konverze mezi různými formáty s&nbsp;plovoucí řádovou čárkou (<i>single</i> &rarr; <i>double</i> atd.).</li>
<li>Způsob konverze základního formátu s&nbsp;plovoucí řádovou čárkou na řetězec číslic (včetně nekonečen a nečíselných hodnot).</li>
<li>Práce s&nbsp;hodnotami NaN (<i>not a number</i>) a výjimkami, které mohou při výpočtech za určitých předpokladů vzniknout.</li>
</ol>

<a href="https://www.root.cz/obrazek/304890/"><img src="https://i.iinfo.cz/images/373/fp-nubmers-8-prev.png" class="image-304890" alt="&#160;" width="370" height="231" /></a>
<p><i>Obrázek 3: Mezí nabídkou datových typů pro FP hodnoty Turbo Pascalu 7
nalezneme i typ <strong>comp</strong>. Ten odpovídá 64bitovým celým číslům
(integer), ovšem výpočty s&nbsp;typem <strong>comp</strong> jsou prováděny
v&nbsp;matematickém koprocesoru a nikoli v&nbsp;ALU (ta ostatně byla jen
šestnáctibitová).</i></p>

<p>Podle bitové šířky čísel <strong>exp</strong>, <strong>bias</strong> a
<strong>m</strong> se rozlišují základní (<i>basic</i>) a rozšířené
(<i>extended</i>) formáty FP čísel; norma <i>IEEE 754</i> (její původní verze)
přitom explicitně zmiňuje dva základní formáty: jednoduchá přesnost
(<i>single</i>) a dvojitá přesnost (<i>double</i>). Druhá verze normy IEEE
754-2008 již obsahuje specifikaci většího množství formátů; navíc došlo
k&nbsp;přejmenování typů <i>single</i> a <i>double</i> na <i>binary32</i> a
<i>binary64</i>:</p>

<table>
<tr><th>Oficiální jméno</th><th>Základní</th><th>Známo též jako</th><th>Znaménko</th><th>Exponent</th><th>Mantisa</th><th>Celkem</th><th>Decimálních číslic</th></tr>
<tr><td>binary16</td><td>&times;</td><td>half precision</td><td>1b</td><td> 5b</td><td>10b</td><td>16b</td><td>cca 3,3</td></tr>
<tr><td>binary32</td><td>&#x2713;</td><td>single precision/float</td><td>1b</td><td> 8b</td><td>23b</td><td>32b</td><td>cca 7,2</td></tr>
<tr><td>binary64</td><td>&#x2713;</td><td>double precision</td><td>1b</td><td>11b</td><td>52b</td><td>64b</td><td>cca 15,9</td></tr>
<tr><td>binary128</td><td>&#x2713;</td><td>quadruple precision</td><td>1b</td><td>15b</td><td>112b</td><td>128b</td><td>cca 34,0</td></tr>
<tr><td>binary256</td><td>&times;</td><td>octuple precision</td><td>1b</td><td>19b</td><td>236b</td><td>256b</td><td>cca 71,3</td></tr>
</table>

*** image ***
<p><i>Obrázek 4: První čip, který používal formát definovaný v&nbsp;IEEE 754
&ndash; Intel 8087.<br />
Zdroj: Wikipedia, Autor: Dirk Oppelt</i></p>



<p><a name="k03"></a></p>
<h2 id="k03">3. Vliv existence IEEE 754 na další vývoj IT</h2>

<p>Podpora vybraných formátů definovaných v&nbsp;IEEE 754
popř.&nbsp;v&nbsp;IEEE 754-2008 je dnes prakticky univerzální a nezávislá na
procesorové architektuře a/nebo operačním systému. V&nbsp;minulosti byly FP
operace podporovány v&nbsp;samostatných matematických koprocesorech neboli
<i>FPU &ndash; Floating Point Units</i>. Jednalo se především o čipy Intel
8087, Intel i80287, Intel i80387, Intel i80487, Motorola M68881 a Motorola
M68882. Dnes je FPU většinou přímo součástí moderních mikroprocesorů (řada x86
od &bdquo;plnohodnotných&ldquo; mikroprocesorů i486, Motorola M68040, Power PC,
ARMy, AArch64, <a
href="https://www.root.cz/clanky/instrukcni-sady-procesorovych-jader-s-otevrenou-architekturou-risc-v-dokonceni/">RISC-V</a>,
<a
href="https://www.root.cz/clanky/procesory-risc-v-pracovnich-stanicich-a-serverech-architektura-sparc-v8-a-v9/#k04">SPARC</a>
některé typy mikrořadičů a signálových procesorů atd. (naproti tomu například
<a
href="https://www.root.cz/clanky/digitalni-signalove-procesory-zpracovavajici-hodnoty-s-plovouci-radovou-carkou/">TMS320C30</a>
vyžaduje konvertor).</p>

<img src="http://i.iinfo.cz/images/21/pc157-1.jpg" alt="" width="450" height="448" />
<p><i>Obrázek 5: Mikroprocesory Pentium i všechny další čipy řady 80x86 již
implicitně obsahují plnohodnotný FPU. Zlé jazyky tvrdí, že u první řady Pentií
byl FPU tak rychlý jen proto, že <a
href="https://en.wikipedia.org/wiki/Pentium_FDIV_bug">výsledky pouze
odhadoval</a> :-)</i></p>

<p>Díky široké podpoře IEEE 754 se zjednodušil přenos numerických údajů mezi
různými zařízeními. Pro mnoho programátorů je také výhodné to, že jeden
základní datový typ (například <i>float</i>) je možné použít pro reprezentaci
mnoha objektů či vlastností. Všechny tyto skutečnosti vedly k&nbsp;tomu, že FP
formát (či formáty) jsou v&nbsp;prakticky všech programovacích jazycích
implementovány jako základní datové typy.</p>

<img src="http://i.iinfo.cz/images/21/pc157-8.jpg" alt="" width="450" height="294" />
<p><i>Obrázek 6: Interní struktura mikroprocesorů Itanium. Asi nás nepřekvapí
červeně označené bloky s&nbsp;FPU (dvě jednotky) a jeho registry.</i></p>

<p>FP formát však má i některé zápory, které nás mohou v&nbsp;některých
případech &bdquo;donutit&ldquo; k&nbsp;použití nějaké alternativy. První
nevýhoda vychází z&nbsp;velké komplexnosti vlastního formátu, tj.&nbsp;způsobu
rozdělení údajů na mantisu a exponent. I taková základní matematická operace,
jako je součet, je kvůli FP formátu poměrně složitá a výsledek nemusí vždy
odpovídat intuitivnímu cítění programátora, který má tendenci FP formát
pokládat za ekvivalent reálných čísel (&bdquo;<strong>datový typ double je
přesný...</strong>&ldquo;).  Mnoho programátorů se například chybně spoléhá na
to, že i pouhý převod mezi typem <i>int32</i> na <i>single/float</i> a zpět na
<i>int</i> je bezeztrátový &ndash; pravý opak je pravdou a to vzhledem
k&nbsp;tomu, že se ztratí hodnoty minimálně osmi nejnižších bitů, které musely
být vyhrazeny pro uložení exponentu (dtto pro <i>int64</i> a <i>double</i>). FP
formát, resp.&nbsp;formát specifikovaný normou IEEE 754, se nehodí pro práci
s&nbsp;peněžními hodnotami; z&nbsp;tohoto důvodu se v&nbsp;některých vyšších
programovacích jazycích zavádí speciální datový typ <i>decimal</i>
resp.&nbsp;<i>currency</i>, určený speciálně pro peněžní hodnoty &ndash; viz
další kapitoly.</p>

<img src="http://i.iinfo.cz/images/394/pc146-7.jpg" alt=" " width="698" height="371" />
<p><i>Obrázek 7: Interní struktura novějších verzí mikroprocesorů s
architekturou SPARC, na níž můžeme najít jak moduly pro práci s&nbsp;celými
čísly, tak i moduly FPU.</i></p>



<p><a name="k04"></a></p>
<h2 id="k04">4. Varianta <strong>single</strong> &ndash; hodnoty s&nbsp;jednoduchou přesností</h2>

<p>Tento formát, který je v&nbsp;programovacích jazycích označován buď jako
<i>single</i> či <i>float</i>, je charakteristický tím, že se pro uložení
numerické hodnoty používá třiceti dvou bitů (4 byty), což pro mnoho aplikací
představuje velmi dobrý poměr mezi rozsahem hodnot, přesností a nároky na
úložný prostor, nehledě na to, že mnoho architektur stále používá 32bitové
sběrnice (klasické ARMy, ...). Oněch 32 bitů je rozděleno do třech částí.
V&nbsp;první části (představované nejvyšším bitem) je uloženo znaménko,
následuje osm bitů pro uložení posunutého exponentu a za nimi je zbývajících 23
bitů, které slouží pro uložení mantisy. Celé třiceti dvoubitové slovo s&nbsp;FP
hodnotou tedy vypadá následovně:</p>

<table>
<tr><th>bit</th><td>31</td><td>30 &nbsp; 29 ... 24 &nbsp; 23</td><td>22 &nbsp; 21 ... 3 &nbsp; 2 &nbsp; 1 &nbsp; 0</td></tr>
<tr><th>význam</th><td>s</td><td>exponent (8 bitů)</td><td>mantisa (23 bitů)</td></tr>
</table>

<p>Exponent je přitom posunutý o hodnotu <strong>bias</strong>, která je
nastavena na 127, protože je použit výše uvedený vztah:</p>

<p><i>bias=2<sup>eb-1</sup>-1</i></p>

<p>a po dosazení <i>eb=8 (bitů)</i> dostaneme:</p>

<p><i>bias=2<sup>8-1</sup>-1=2<sup>7</sup>-1=128-1=</i><strong>127</strong></p>

<p>Vzorec pro vyjádření reálné hodnoty vypadá následovně:</p>

<p><i>X<sub>single</sub>=(-1)<sup>s</sup>&nbsp;&times;&nbsp;2<sup>exp-127</sup>&nbsp;&times;&nbsp;m</i></p>

<p>Uložení znaménka číselné hodnoty je jednoduché: pokud je znaménkový bit
nastavený na jedničku, jedná se o zápornou hodnotu, v&nbsp;opačném případě jde
o hodnotu kladnou. Exponent je uložený v&nbsp;takzvané <strong>posunuté
formě</strong>, tj.&nbsp;jako binárně zakódované celé číslo v&nbsp;rozsahu
0..255. Po vyjádření neposunutého exponentu dostáváme rozsah -127..128, obě
krajní hodnoty jsou však použity pro speciální účely, proto dostáváme rozsah
exponentů pouze -126..127 pro normalizovaná čísla (krajními hodnotami jsou
takové exponenty, které mají všechny bity buď jedničkové nebo naopak
nulové).</p>

*** image ***
<p><i>Obrázek 8: Matematický koprocesor vyráběný firmou Weitek. Tento konkrétní
čip je určen pro procesory řady 486 (není kompatibilní s&nbsp;80487), ovšem
Weitek vyráběl koprocesory pro celou řadu dalších architektur, od 8087 přes
Motoroly řady 68k až po (micro)SPARC.</i></p>

<p>Ještě si však musíme říci, jakým způsobem je uložena mantisa. Ta je totiž
většinou (až na velmi malá čísla) <strong>normalizovaná</strong>, což znamená,
že se do mantisy ukládají pouze hodnoty v&nbsp;rozsahu
&lt;1,0;2,0-&epsilon;&gt;. Vzhledem k&nbsp;tomu, že první bit umístěný před
binární tečkou je u tohoto rozsahu vždy nastavený na jedničku, není ho
zapotřebí ukládat, což znamená, že ušetříme jeden bit z&nbsp;třiceti
dvoubitového slova (viz úvodní kapitolu). Pro normalizované hodnoty platí
následující vztah:</p>

<p><i>X<sub>single</sub>=(-1)<sup>s</sup>&nbsp;&times;&nbsp;2<sup>exp-127</sup>(1.M)<sub>2</sub></i></p>

<p>kde <strong>M</strong> je hodnota bitového vektoru mantisy, tj.:</p>

<p><i>M=m<sub>22</sub><sup>-1</sup>+m<sub>21</sub><sup>-2</sup>+m<sub>20</sub><sup>-3</sup>+...+m<sub>1</sub><sup>-22</sup>+m<sub>0</sub><sup>-23</sup></i></p>

<p>Rozsah hodnot, které je možné reprezentovat ve formátu jednoduché přesnosti
v&nbsp;normalizovaném tvaru je -3,4&times;10<sup>38</sup> až
3,4&times;10<sup>38</sup>. Nejnižší reprezentovatelná (normalizovaná) hodnota
je rovna 1,17549&times;10<sup>-38</sup>, denormalizovaná pak
1,40129&times;10<sup>-45</sup>. Jak jsme k&nbsp;těmto hodnotám došli? Zkuste se
podívat na následující vztahy:</p>

<table>
<tr><th>hexadecimální hodnota</th><th>výpočet FP</th><th>dekadický výsledek</th><th>normalizováno</th></tr>
<tr><td>0x00000001</td><td>2<sup>-126</sup>&times;2<sup>-23</sup></td><td>1,40129&times;10<sup>-45</sup></td><td>ne</td></tr>
<tr><td>0x00800000</td><td>2<sup>-126</sup></td><td>1,17549&times;10<sup>-38</sup></td><td>ano</td></tr>
<tr><td>0x7F7FFFFF</td><td>(2-2<sup>-23</sup>)&times;2<sup>127</sup></td><td>3,4&times;10<sup>38</sup></td><td>ano</td></tr>
</table>



<p><a name="k05"></a></p>
<h2 id="k05">5. Varianta <strong>double</strong> &ndash; hodnoty s&nbsp;dvojnásobnou přesností</h2>

<p>Formát s&nbsp;dvojitou přesností (<strong>double</strong>), který je
definovaný taktéž normou IEEE 754, se v&nbsp;mnoha ohledech podobá formátu
s&nbsp;jednoduchou přesností (<strong>single</strong>), pouze se zdvojnásobil
celkový počet bitů, ve kterých je hodnota uložena, tj.&nbsp;místo 32 bitů se
používá 64 bitů. Právě to je hlavní příčinou toho, proč se tento formát nazývá
double, ve skutečnosti je totiž přesnost více než dvojnásobná. 64 bitů
alokovaných pro FP hodnotu je v&nbsp;tomto případě rozděleno následujícím
způsobem:</p>

<ol>
<li>1 bit pro znaménko</li>
<li>11 bitů pro exponent</li>
<li>52 bitů pro mantisu</li>
</ol>

<p>Bitově vypadá rozdělení následovně:</p>

<table>
<tr><th>bit</th><td>63</td><td>62 ... 52</td><td>51 ... 0</td></tr>
<tr><th>význam</th><td>s</td><td>exponent (11 bitů)</td><td>mantisa (52 bitů)</td></tr>
</table>

<p>Exponent je v&nbsp;tomto případě posunutý o hodnotu
<strong>bias=2047</strong> a vzorec pro výpočet reálné hodnoty vypadá
takto:</p>

<p><i>X<sub>double</sub>=(-1)<sup>s</sup>&nbsp;&times;&nbsp;2<sup>exp-2047</sup>&nbsp;&times;&nbsp;m</i></p>

<p>Přičemž hodnotu mantisy je možné pro normalizované hodnoty získat pomocí
vztahu:</p>

<p><i>m=1+m<sub>51</sub><sup>-1</sup>+m<sub>50</sub><sup>-2</sup>+m<sub>49</sub><sup>-3</sup>+...+m<sub>0</sub><sup>-52</sup></i></p>

<p>(<i>m<sub>x</sub></i> představuje <i>x</i>-tý bit mantisy)</p>

<p>Rozsah hodnot ukládaných ve dvojité přesnosti je
-1,7&times;10<sup>308</sup>..1,7&times;10<sup>308</sup>, nejmenší možná
nenulová hodnota je rovna 2,2&times;10<sup>-308</sup>.</p>



<p><a name="k06"></a></p>
<h2 id="k06">6. Denormalizovaná čísla, hodnoty typu NaN a nekonečna</h2>

<p>Ještě si musíme vysvětlit význam těch exponentů, které mají minimální a
maximální hodnotu, tj.&nbsp;jsou buď nulové, nebo mají v&nbsp;případě formátu
<i>single</i> hodnotu 255 (obě samozřejmě před posunem). Vše je přehledně
uvedeno v&nbsp;následující tabulce:</p>

<table>
<tr><th>s-bit</th><th>exponent</th><th>mantisa</th><th>význam</th><th>šestnáctkově</th></tr>
<tr><td>0</td><td>0&lt;e&lt;255</td><td>&gt;0</td><td>normalizované kladné číslo</td><td>&nbsp;</td></tr>
<tr><td>1</td><td>0&lt;e&lt;255</td><td>&gt;0</td><td>normalizované záporné číslo</td><td>&nbsp;</td></tr>
<tr><td>0</td><td>0</td><td>&gt;0</td><td>denormalizované kladné číslo</td><td>&nbsp;</td></tr>
<tr><td>1</td><td>0</td><td>&gt;0</td><td>denormalizované záporné číslo</td><td>&nbsp;</td></tr>
<tr><td>0</td><td>0</td><td>0</td><td>kladná nula</td><td>0x00000000</td></tr>
<tr><td>1</td><td>0</td><td>0</td><td>záporná nula</td><td>0x80000000</td></tr>
<tr><td>0</td><td>255</td><td>0</td><td>kladné nekonečno</td><td>0x7F800000</td></tr>
<tr><td>1</td><td>255</td><td>0</td><td>záporné nekonečno</td><td>0xFF800000</td></tr>
<tr><td>0</td><td>255</td><td>&gt;0</td><td>NaN &ndash; not a number</td><td>&nbsp;</td></tr>
<tr><td>1</td><td>255</td><td>&gt;0</td><td>NaN &ndash; not a number</td><td>&nbsp;</td></tr>
</table>

<p>Pojmem <strong>denormalizovaná čísla</strong> označujeme takové hodnoty, u
kterých není první (explicitně nevyjádřený) bit mantisy roven jedničce, ale
naopak nule. Výpočty s&nbsp;těmito velmi malými hodnotami nejsou přesné,
zejména při násobení a dělení (a samozřejmě i všech odvozených operacích). Při
ukládání denormalizovaných čísel je exponent vždy nastaven na nejnižší hodnotu,
tj.&nbsp;na -126 a nejvyšší (explicitně neukládaný) bit mantisy je vždy nulový,
nikoli jedničkový, jak je tomu u normalizovaných hodnot.</p>

<p>Hodnota typu <strong>NaN</strong> vznikne v&nbsp;případě, že je použita
operace s&nbsp;nejasným výsledkem, například 0/0 nebo, a to v&nbsp;praxi snad
nejčastěji, při odmocňování záporných čísel. Nekonečná hodnota vzniká typicky
při dělení nulou (zde je možné zjistit znaménko), nebo při vyjádření funkcí
typu <i>log(0)</i> atd.</p>

<p>Minimální a maximální hodnota exponentu má speciální význam i u formátu
double:</p>

<table>
<tr><th>s-bit</th><th>exponent</th><th>mantisa</th><th>význam</th></tr>
<tr><td>0</td><td>0&lt;e&lt;2047</td><td>&gt;0</td><td>normalizované kladné číslo</td></tr>
<tr><td>1</td><td>0&lt;e&lt;2047</td><td>&gt;0</td><td>normalizované záporné číslo</td></tr>
<tr><td>0</td><td>0</td><td>&gt;0</td><td>denormalizované kladné číslo</td></tr>
<tr><td>1</td><td>0</td><td>&gt;0</td><td>denormalizované záporné číslo</td></tr>
<tr><td>0</td><td>0</td><td>0</td><td>kladná nula</td></tr>
<tr><td>1</td><td>0</td><td>0</td><td>záporná nula</td></tr>
<tr><td>0</td><td>2047</td><td>0</td><td>kladné nekonečno</td></tr>
<tr><td>1</td><td>2047</td><td>0</td><td>záporné nekonečno</td></tr>
<tr><td>0</td><td>2047</td><td>&gt;0</td><td>NaN &ndash; not a number</td></tr>
<tr><td>1</td><td>2047</td><td>&gt;0</td><td>NaN &ndash; not a number</td></tr>
</table>

<p>Kromě obou základních formátů (tj.&nbsp;jednoduché i dvojité přesnosti) je
v&nbsp;normě IEEE 754 povoleno používat i rozšířené formáty. Na platformě x86
je při výpočtech prováděných v&nbsp;matematickém koprocesoru používán rozšířený
formát nazývaný <strong>extended</strong> či <strong>temporary</strong>. Tento
formát je zajímavý tím, že pro uložení FP hodnot používá 80 bitů a je do něho
možné beze ztráty přesnosti uložit 64bitové hodnoty typu integer (což je
v&nbsp;mnoha oblastech velmi důležité, protože například převod 64bitový
integer &rarr; double je vždy doprovázen ztrátou nejnižších číslic!).
Osmdesátibitový vektor je rozdělený do třech částí následujícím způsobem:</p>

<ul>
<li>1 bit pro znaménko</li>
<li>15 bitů pro exponent (<i>BIAS</i> je roven 16383)</li>
<li>64 bitů pro mantisu (maximální hodnota přesahuje 10<sup>4932</sup>)</li>
</ul>

<p>U&nbsp;tohoto formátu je zajímavá funkce bitu s&nbsp;indexem 63. Podle
hodnoty tohoto bitu se rozlišují čísla normalizovaná a nenormalizovaná (tento
bit ve skutečnosti nahrazuje implicitně nastavovaný nejvyšší bit mantisy, jak
ho známe z&nbsp;předchozích formátů). Všechny možnosti, které mohou při
ukládání extended FP formátu nastat, jsou přehledně vypsány v&nbsp;následující
tabulce:</p>

<table>
<tr><th>s-bit</th><th>exponent</th><th>mantisa</th><th>m<sub>63</sub><th>význam</th></tr>
<tr><td>0</td><td>0&lt;e&lt;32767</td><td>&gt;0</td><td>1</td><td>normalizované kladné číslo</td></tr>
<tr><td>1</td><td>0&lt;e&lt;32767</td><td>&gt;0</td><td>1</td><td>normalizované záporné číslo</td></tr>
<tr><td>0</td><td>0&lt;e&lt;32767</td><td>&gt;0</td><td>0</td><td><strong>ne</strong>normalizované kladné číslo</td></tr>
<tr><td>1</td><td>0&lt;e&lt;32767</td><td>&gt;0</td><td>0</td><td><strong>ne</strong>normalizované záporné číslo</td></tr>
<tr><td>0</td><td>0</td><td>&gt;0</td><td>0</td><td><strong>de</strong>normalizované kladné číslo</td></tr>
<tr><td>1</td><td>0</td><td>&gt;0</td><td>0</td><td><strong>de</strong>normalizované záporné číslo</td></tr>
<tr><td>0</td><td>0</td><td>0</td><td>x</td><td>kladná nula</td></tr>
<tr><td>1</td><td>0</td><td>0</td><td>x</td><td>záporná nula</td></tr>
<tr><td>0</td><td>32767</td><td>0</td><td>x</td><td>kladné nekonečno</td></tr>
<tr><td>1</td><td>32767</td><td>0</td><td>x</td><td>záporné nekonečno</td></tr>
<tr><td>0</td><td>32767</td><td>&gt;0</td><td>x</td><td>NaN &ndash; not a number</td></tr>
<tr><td>1</td><td>32767</td><td>&gt;0</td><td>x</td><td>NaN &ndash; not a number</td></tr>
</table>

<p>Pro normalizované i nenormalizované hodnoty je možné uloženou hodnotu
vyjádřit pomocí vzorce (všimněte si, že bit 63 je umístěn před binární
tečkou):</p>

<p><i>X<sub>extended</sub>=(-1)<sup>s</sup>&nbsp;&times;&nbsp;2<sup>exp-16383</sup>&nbsp;&times;&nbsp;m</i></p>
<p><i>m=m<sub>63</sub><sup>0</sup>+m<sub>62</sub><sup>-1</sup>+m<sub>61</sub><sup>-2</sup>+...+m<sub>0</sub><sup>-63</sup></i></p>



<p><a name="k07"></a></p>
<h2 id="k07">7. Rozšířený formát <strong>extended</strong>/<strong>temporary</strong></h2>

<p>Kromě obou základních formátů (tj.&nbsp;jednoduché i dvojité přesnosti) je
v&nbsp;normě IEEE 754 povoleno používat i rozšířené formáty. Na platformě x86
je při výpočtech prováděných v&nbsp;FPU používán rozšířený formát nazývaný
<strong>extended</strong> či <strong>temporary</strong>. Tento formát je
zajímavý tím, že pro uložení FP hodnot používá 80 bitů a je do něho možné beze
ztráty přesnosti uložit 64bitové hodnoty typu integer (přesně taková je totiž
bitová šířka mantisy). Osmdesátibitový vektor je rozdělený do třech částí
následujícím způsobem:</p>

<ul>
<li>1 bit pro znaménko</li>
<li>15 bitů pro exponent (<i>BIAS</i> je roven 16383)</li>
<li>64 bitů pro mantisu (maximální hodnota přesahuje 10<sup>4932</sup>)</li>
</ul>

<p>U&nbsp;tohoto formátu je zajímavá funkce bitu s&nbsp;indexem 63. Podle
hodnoty tohoto bitu se rozlišují čísla normalizovaná a nenormalizovaná (tento
bit ve skutečnosti nahrazuje implicitně nastavovaný nejvyšší bit mantisy, jak
ho známe z&nbsp;předchozích formátů). Matematický koprocesor 8087 sice dokáže
pracovat s&nbsp;čísly nenormalizovanými, výsledkem jeho aritmetických operací
jsou však vždy hodnoty normalizované. Všechny možnosti, které mohou při
ukládání extended FP formátu nastat, jsou přehledně vypsány v&nbsp;následující
tabulce:</p>

<table>
<tr><th>s-bit</th><th>exponent</th><th>mantisa</th><th>m<sub>63</sub><th>význam</th></tr>
<tr><td>0</td><td>0&lt;e&lt;32767</td><td>&gt;0</td><td>1</td><td>normalizované kladné číslo</td></tr>
<tr><td>1</td><td>0&lt;e&lt;32767</td><td>&gt;0</td><td>1</td><td>normalizované záporné číslo</td></tr>
<tr><td>0</td><td>0&lt;e&lt;32767</td><td>&gt;0</td><td>0</td><td><strong>ne</strong>normalizované kladné číslo</td></tr>
<tr><td>1</td><td>0&lt;e&lt;32767</td><td>&gt;0</td><td>0</td><td><strong>ne</strong>normalizované záporné číslo</td></tr>
<tr><td>0</td><td>0</td><td>&gt;0</td><td>0</td><td><strong>de</strong>normalizované kladné číslo</td></tr>
<tr><td>1</td><td>0</td><td>&gt;0</td><td>0</td><td><strong>de</strong>normalizované záporné číslo</td></tr>
<tr><td>0</td><td>0</td><td>0</td><td>x</td><td>kladná nula</td></tr>
<tr><td>1</td><td>0</td><td>0</td><td>x</td><td>záporná nula</td></tr>
<tr><td>0</td><td>32767</td><td>0</td><td>x</td><td>kladné nekonečno</td></tr>
<tr><td>1</td><td>32767</td><td>0</td><td>x</td><td>záporné nekonečno</td></tr>
<tr><td>0</td><td>32767</td><td>&gt;0</td><td>x</td><td>NaN &ndash; not a number</td></tr>
<tr><td>1</td><td>32767</td><td>&gt;0</td><td>x</td><td>NaN &ndash; not a number</td></tr>
</table>

<p>Pro normalizované i nenormalizované hodnoty je možné uloženou hodnotu
vyjádřit pomocí vzorce (všimněte si, že bit 63 je umístěn <strong>před</strong>
binární tečkou):</p>

<p><i>X<sub>extended</sub>=(-1)<sup>s</sup>&nbsp;&times;&nbsp;2<sup>exp-16383</sup>&nbsp;&times;&nbsp;m</i></p>
<p><i>m=m<sub>63</sub><sup>0</sup>+m<sub>62</sub><sup>-1</sup>+m<sub>61</sub><sup>-2</sup>+...+m<sub>0</sub><sup>-63</sup></i></p>



<p><a name="k08"></a></p>
<h2 id="k08">8. Varianta <strong>quadruple</strong> &ndash; hodnoty se čtyřnásobnou přesností</h2>

<p><i>"For now the 10-byte Extended format is a tolerable compromise between
the value of extra-precise arithmetic and the price of implementing it to run
fast; very soon two more bytes of precision will become tolerable, and
ultimately a 16-byte format... That kind of gradual evolution towards wider
precision was already in view when IEEE Standard 754 for Floating-Point
Arithmetic was framed."<br />
William Kahan, architekt IEEE 754</i></p>

<p>Rozšiřování šířky mantisy i možných rozsahů exponentu se nezastavilo u <a
href="#08">výše popsaného</a> formátu <i>extended</i>. Ostatně formát
<i>extended</i> byl již v&nbsp;době svého vzniku pouze dočasným řešením,
protože tehdejší technologie neumožňovala, aby matematický koprocesor 8087
obsahoval příliš mnoho tranzistorů (jednalo by se o drahé řešení, navíc zvýšení
počtu tranzistorů vedlo k&nbsp;menší výtěžnosti výroby, což opět vede ke
zdražení). V&nbsp;novější normě IEEE 754-2008 je specifikován nepovinný formát
nazvaný <i>binary128</i>, který se ovšem běžně označuje <i>quadruple
precision</i> či jen <i>quad precision</i>. Tento formát je založen na slovech
širokých 128 bitů (16 bajtů), která jsou rozdělena takto:</p>

<ol>
<li>1 bit pro znaménko</li>
<li>15 bitů pro exponent</li>
<li>112 bitů pro mantisu</li>
</ol>

<p>Bitově vypadá rozdělení následovně:</p>

<table>
<tr><th>bit</th><td>127</td><td>126 ... 112</td><td>111 ... 0</td></tr>
<tr><th>význam</th><td>s</td><td>exponent (15 bitů)</td><td>mantisa (112 bitů)</td></tr>
</table>

<p>Exponent je v&nbsp;tomto případě posunutý o hodnotu
<strong>bias=16383</strong>. Dekadická přesnost u tohoto formátu dosahuje 34 cifer!</p>

<p>Formát <i>quadruple</i> je podporován těmi procesory s&nbsp;architekturou <a
href="https://www.root.cz/clanky/instrukcni-sada-procesorovych-jader-s-otevrenou-architekturou-risc-v/">RISC-V</a>,
které implementují rozšíření instrukční sady &bdquo;Q&ldquo;. Toto rozšíření je
platné pouze pro 64bitové varianty procesorů, které obsahují sadu <i>RV64I</i>
(u 32bitových variant CPU nebude &bdquo;Q&ldquo; podporována). V&nbsp;rámci
podpory rozšíření instrukční sady &bdquo;Q&ldquo; se zvětšila šířka FP
registrů, a to na 128 bitů. Většina původních FP instrukcí zůstala zachována,
pouze se změnil jejich postfix určující typ zpracovávaných numerických hodnot.
Jediné instrukce, které byly odstraněny, jsou instrukce pro bitovou kopii dat
mezi celočíselným registrem a FP registrem (to je vlastně pochopitelné), což
znamená nutnost načítání a ukládání operandů přímo do operační paměti.
V&nbsp;instrukční sadě &bdquo;Q&ldquo; tedy neexistují tyto dvě instrukce:
<strong>FMV.X.Q</strong> a <strong>FMV.Q.X</strong>.</p>

<p>Nové instrukce pro načítání a ukládání operandů do operační paměti:</p>

<table>
<tr><th>#</th><th>Instrukce</th><th>Význam</th></tr>
<tr><td>1</td><td>FLQ</td><td>načtení FP hodnoty z&nbsp;paměti (adresa rs+offset)</td></tr>
<tr><td>2</td><td>FSQ</td><td>uložení FP hodnoty do paměti (adresa rs+offset)</td></tr>
</table>

<p>Základní aritmetické operace jsou (opět) prakticky stejné, pouze mají
odlišný postfix:</p>

<table>
<tr><th>#</th><th>Instrukce</th><th>Význam</th></tr>
<tr><td>1</td><td>FADD.Q</td><td>součet dvou FP hodnot (tříadresový kód)</td></tr>
<tr><td>2</td><td>FSUB.Q</td><td>rozdíl dvou FP hodnot</td></tr>
<tr><td>3</td><td>FMUL.Q</td><td>součin dvou FP hodnot</td></tr>
<tr><td>4</td><td>FDIV.Q</td><td>podíl dvou FP hodnot</td></tr>
<tr><td>5</td><td>FMIN.Q</td><td>vrací menší z&nbsp;obou FP hodnot</td></tr>
<tr><td>6</td><td>FMAX.Q</td><td>vrací větší z&nbsp;obou FP hodnot</td></tr>
<tr><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td></tr>
<tr><td>7</td><td>FSQRT.Q</td><td>druhá odmocnina (použity jsou jen dva registry)</td></tr>
</table>

<p>Konverze mezi typy <i>single</i>, <i>float</i> a <i>quadruple</i>:</p>

<table>
<tr><th>#</th><th>Instrukce</th><th>Význam</th></tr>
<tr><td>1</td><td>FCVT.S.Q</td><td>quadruple &rarr; single</td></tr>
<tr><td>2</td><td>FCVT.Q.S</td><td>single &rarr; quadruple</td></tr>
<tr><td>3</td><td>FCVT.D.Q</td><td>quadruple &rarr; double</td></tr>
<tr><td>4</td><td>FCVT.Q.D</td><td>double &rarr; quadruple</td></tr>
</table>

<p>Operace se znaménkem:</p>

<table>
<tr><th>#</th><th>Instrukce</th><th>Význam</th></tr>
<tr><td>1</td><td>FSGNJ.Q </td><td>kopie z&nbsp;registru <i>src1</i> do <i>dest</i>, ovšem kromě znaménka; to je přečteno ze <i>src2</i></td></tr>
<tr><td>2</td><td>FSGNJN.Q</td><td>kopie z&nbsp;registru <i>src1</i> do <i>dest</i>, ovšem kromě znaménka; to je přečteno ze <i>src2</i> a znegováno</td></tr>
<tr><td>3</td><td>FSGNJX.Q</td><td>kopie z&nbsp;registru <i>src1</i> do <i>dest</i>, ovšem kromě znaménka; to je získáno ze <i>src1</i> i <i>src2</i> s&nbsp;využitím operace XOR</td></tr>
</table>



<p><a name="k09"></a></p>
<h2 id="k09">9. Varianta <strong>octuple</strong> &ndash; 256 bitů pro jedno číslo</h2>

<p>Jen krátce se zmiňme o poslední variantě FP formátu, který se nazývá
<i>binary256</i> či méně formálně <i>octuple precision</i>. Tento formát
využívá slova o šířce plných 256 bitů (32 bajtů) s&nbsp;následujícím
rozdělením:</p>

<ol>
<li>1 bit pro znaménko</li>
<li>19 bitů pro exponent</li>
<li>236 bitů pro mantisu</li>
</ol>

<p>(povšimněte si, že šířka exponentu nemusí růst nijak radikálně)</p>

<p>Bitově vypadá rozdělení následovně:</p>

<table>
<tr><th>bit</th><td>255</td><td>254 ... 236</td><td>235 ... 0</td></tr>
<tr><th>význam</th><td>s</td><td>exponent (19 bitů)</td><td>mantisa (235 bitů)</td></tr>
</table>

<p>Exponent je v&nbsp;tomto případě posunutý o hodnotu
<strong>bias=262143</strong>. Dekadická přesnost u tohoto formátu dosahuje 71
cifer, nejmenší (nenormalizovaná) reprezentovatelná hodnota rozdílná od nuly je
přibližně 10<sup>−78984</sup>, maximální hodnota pak 1.611
&times;10<sup>78913</sup> (těžko říct, zda je takový rozsah vůbec reálně
využitelný).</p>



<p><a name="k10"></a></p>
<h2 id="k10">10. Varianta <strong>half</strong> &ndash; poloviční přesnost</h2>

<p>Formát <strong>Minifloat</strong> je významný tím, že je implementován
v&nbsp;některých grafických procesorech GPU; používají ho i firmy ILM a Pixar
atd. Tento formát, někdy (zejména v&nbsp;programovacím jazyku <i>Cg</i>) také
nazývaný <strong>half</strong> či jednoduše <strong>fp16</strong>, používá pro
ukládání FP hodnot pouhých šestnáct bitů, tj.&nbsp;dva byty. Maximální hodnota
je rovna 65504 (FFE0<sub>16</sub>=1111111111100000<sub>2</sub>), minimální
hodnota přibližně 2,9&times;10<sup>-8</sup>. Předností tohoto formátu je malá
bitová šířka (umožňuje paralelní přenos po interních sběrnicích GPU) a také
větší rychlost zpracování základních operací, protože pro tak malou bitovou
šířku mantisy je možné některé operace "zadrátovat" a nepočítat pomocí ALU.
Také některé iterativní výpočty (sin, cos, sqrt) mohou být provedeny rychleji,
než v&nbsp;případě plnohodnotných typů <strong>float</strong> a
<strong>single</strong>.</p>

<table>
<tr><td>Celkový počet bitů (bytů):</td><td>16 (2)</td></tr>
<tr><td>Bitů pro znaménko:</td><td>1</td></tr>
<tr><td>Bitů pro exponent:</td><td>5</td></tr>
<tr><td>Bitů pro mantisu:</td><td>10</td></tr>
<tr><td>BIAS (offset exponentu):</td><td>15</td></tr>
<tr><td>Přesnost:</td><td>5-6 číslic</td></tr>
<tr><td>Maximální hodnota:</td><td>65504</td></tr>
<tr><td>Minimální hodnota:</td><td>-65504</td></tr>
<tr><td>Nejmenší kladná nenulová hodnota:</td><td>5,96&times;10<sup>-8</sup></td></tr>
<tr><td>Nejmenší kladná normalizovaná hodnota:</td><td>6,104&times;10<sup>-5</sup></td></tr>
</table>

<p>Tento formát nalezneme v&nbsp;některých programovacích jazycích a knihovnách
určených pro zpracování velkého množství numerických údajů. Příkladem je
programovací jazyk <a
href="https://www.root.cz/clanky/programovaci-jazyk-julia-typovy-system-funkce-a-metody/#k03">Julia
s&nbsp;datovým typem <strong>Float16</strong></a> či populární knihovna
<i>Numpy</i> s&nbsp;datovým typem s&nbsp;prakticky totožným názvem <a
href="https://docs.scipy.org/doc/numpy/user/basics.types.html">float16</a>.</p>

<img src="https://i.iinfo.cz/images/662/julia-1.png" alt="" />
<p><i>Logo programovacího jazyka Julia.</i></p>



<p><a name="k11"></a></p>
<h2 id="k11">11. Další &bdquo;malé&ldquo; FP varianty</h2>

<p>Nejmenším FP formátem, který je ještě možné prakticky použít, je formát
neoficiálně nazývaný <strong>microfloat</strong>. Tento formát, ve kterém jsou
hodnoty uložené na pouhých osmi bitech, tj.&nbsp;jednom bytu, se používá
například při ukládání hodnot naměřených z&nbsp;nelineárních čidel, digitálních
průběhů apod. Předností je značná úspora paměti a také snazší FP operace, které
je možné povětšinou zakódovat do vyhledávacích tabulek (na mikrořadičích do
paměti PROM). Nevýhodou je (logicky) malý rozsah a současně i přesnost. Kromě
normalizovaných číselných hodnot (nejmenší hodnotou je 1/64) je možné ukládat i
hodnoty nenormalizované (zde je nejmenší hodnotou 1/512), přičemž je možné
odlišit kladnou a zápornou nulu a samozřejmě i kladné a záporné nekonečno.
Základní charakteristika tohoto opravdu minimalistického FP formátu je
zobrazena v&nbsp;následující tabulce:</p>

<table>
<tr><td>Celkový počet bitů (bytů):</td><td>8 (1)</td></tr>
<tr><td>Bitů pro znaménko:</td><td>1</td></tr>
<tr><td>Bitů pro exponent:</td><td>4</td></tr>
<tr><td>Bitů pro mantisu:</td><td>3</td></tr>
<tr><td>BIAS:</td><td>7</td></tr>
<tr><td>Přesnost:</td><td>2-3 číslice</td></tr>
<tr><td>Maximální hodnota:</td><td>240</td></tr>
<tr><td>Minimální hodnota:</td><td>-240</td></tr>
<tr><td>Nejmenší kladná nenulová hodnota:</td><td>1/512 (denormalizovaná hodnota)</td></tr>
</table>

<p>Poznámka: pokud se tento formát používá pro přenos naměřených dat
z&nbsp;čidel atd., většinou se nepracuje ani s&nbsp;nenormalizovanými hodnotami
ani se speciálními (ne)čísly typu NaN či &pm;&infin;</p>

<p>Na některých univerzitách se používá ještě menší FP formát s&nbsp;šířkou
pouhých šesti bitů. V&nbsp;tomto formátu je jeden bit vyhrazen pro znaménko
(logicky), tři bity pro exponent (s&nbsp;biasem 3) a pouhé dva bity pro
mantisu. K&nbsp;čemu je takový formát vlastně dobrý? Šesti bity je možné
reprezentovat pouze 64 stavů a ty lze snadno namapovat na reálné hodnoty
vynesené na číselnou osu. Pokud se u tohoto formátu dodrží všechny mechanismy
specifikované v&nbsp;IEEE 754, lze pracovat s&nbsp;hodnotami NaN, +&infin;,
-&infin; atd., testovat, za jakých okolností dochází k&nbsp;přetečení, kdy se
snižuje přesnost výsledku atd. To, že je mantisa uložena jen ve dvou bitech
vůbec nevadí, spíš naopak (zmenšuje se stavový prostor).</p>

<p>Další &bdquo;mini-FP&ldquo; formát používá pouze pět bitů, přičemž dva bity
jsou vyhrazeny na exponent a tři na mantisu (bez znaménka). Tento formát se
používá na PC pro nastavení rychlosti automatického opakování znaků při držení
klávesy. Všech 32 kombinací pěti bitů je převedeno na hodnoty od 8 do 120. Na
tomto formátu lze dobře ilustrovat vlastnost všech FP formátů &ndash; čím vyšší
hodnoty používáme, tím větší krok je mezi dvěma sousedními hodnotami:</p>

<table>
<tr><th>Exponent</th><th>Mantisa</th><th>Výsledek (dekadicky)</th></tr>
<tr><td>00</td><td>000</td><td>8</td></tr>
<tr><td>00</td><td>001</td><td>9</td></tr>
<tr><td>00</td><td>010</td><td>10</td></tr>
<tr><td>00</td><td>011</td><td>11</td></tr>
<tr><td>00</td><td>100</td><td>12</td></tr>
<tr><td>00</td><td>101</td><td>13</td></tr>
<tr><td>00</td><td>110</td><td>14</td></tr>
<tr><td>00</td><td>111</td><td>15</td></tr>
<tr><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td></tr>
<tr><td>01</td><td>000</td><td>16</td></tr>
<tr><td>01</td><td>001</td><td>18</td></tr>
<tr><td>01</td><td>010</td><td>20</td></tr>
<tr><td>01</td><td>011</td><td>22</td></tr>
<tr><td>01</td><td>100</td><td>24</td></tr>
<tr><td>01</td><td>101</td><td>26</td></tr>
<tr><td>01</td><td>110</td><td>28</td></tr>
<tr><td>01</td><td>111</td><td>30</td></tr>
<tr><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td></tr>
<tr><td>10</td><td>000</td><td>32</td></tr>
<tr><td>10</td><td>001</td><td>36</td></tr>
<tr><td>10</td><td>010</td><td>40</td></tr>
<tr><td>10</td><td>011</td><td>44</td></tr>
<tr><td>10</td><td>100</td><td>48</td></tr>
<tr><td>10</td><td>101</td><td>52</td></tr>
<tr><td>10</td><td>110</td><td>56</td></tr>
<tr><td>10</td><td>111</td><td>60</td></tr>
<tr><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td></tr>
<tr><td>11</td><td>000</td><td>64</td></tr>
<tr><td>11</td><td>001</td><td>72</td></tr>
<tr><td>11</td><td>010</td><td>80</td></tr>
<tr><td>11</td><td>011</td><td>88</td></tr>
<tr><td>11</td><td>100</td><td>96</td></tr>
<tr><td>11</td><td>101</td><td>104</td></tr>
<tr><td>11</td><td>110</td><td>112</td></tr>
<tr><td>11</td><td>111</td><td>120</td></tr>
</table>



<p><a name="k12"></a></p>
<h2 id="k12">12. Použití BCD pro uložení čísel i pro výpočty</h2>

<p>Při popisu různých způsobů uložení numerických hodnot nesmíme zapomenout na
BCD (<i>Binary-coded decimal</i>), tedy na systém uložení každé desítkové cifry
ve čtyřech bitech. Typicky se tedy do jednoho bajtu mohou uložit dvě cifry, do
16bitového slova čtyři cifry, do 32bitového slova osm cifer atd. BCD se
v&nbsp;nejjednodušším případě používá pro uložení celých čísel, a to buď bez
znaménka (jednotlivé cifry) nebo se znaménkem (potom je znaménko typicky
uloženo ve vlastním bitu, nebo se používá dvojkový doplněk, to ovšem méně
často). Ovšem můžeme se setkat i s&nbsp;takzvaným FX formátem (fixed point),
v&nbsp;němž je desetinná tečka umístěna za předem známou cifrou a je neměnná
&ndash; počet cifer před desetinnou tečkou a za ní je stále stejný. To znamená,
že se v&nbsp;takovém případě nemusí ukládat exponent, který u výše popsaných FP
hodnot přímo či nepřímo určoval pozici řádové čárky v&nbsp;uloženém číslu.</p>



<p><a name="k13"></a></p>
<h2 id="k13">13. Podpora pro výpočty v&nbsp;BCD v&nbsp;instrukčních sadách mikroprocesorů</h2>

<p>Výpočty s&nbsp;číselnými hodnotami uloženými v&nbsp;kódu BCD se ve výpočetní
technice používají již od první generace (elektronkových) mainframů, které
společnost IBM vyráběla v&nbsp;padesátých letech minulého století. Dnes se
s&nbsp;BCD setkáme například při programování mikrořadičů, protože některé
sedmisegmentové LCD, čipy s&nbsp;hodinami reálného času či malé numerické
klávesnice kód BCD používají. Ostatně i z&nbsp;tohoto důvodu výpočty v&nbsp;BCD
podporuje většina mikrořadičů, s&nbsp;výjimkou některých řad osmibitových
mikrořadičů PIC. Čipy podporující výpočty v&nbsp;BCD můžeme rozdělit do tří
kategorií:</p>

<ol>

<li>Registry přímo obsahují BCD (typicky dvě číslice 00-99) a ALU taktéž
produkuje výsledek v&nbsp;BCD. Typickým příkladem je slavný osmibitový
mikroprocesor <i>MOS 6502</i>, který lze přepnout do &bdquo;dekadického
režimu&ldquo; instrukcí <strong>SED</strong> (<i>Set Decimal Mode</i>) či se
přepnout zpátky instrukcí <strong>CLD</strong> (<i>Clear Decimal
Mode</i>).</li>

<li>ALU sice provádí výpočty v&nbsp;binárním kódu, ale po provedení výpočtu je
možné explicitně provést úpravu výsledku na BCD (na základě nastavených
příznaků přenosu a polovičního přenosu). Typickým příkladem jsou čipy <i>Intel
8048</i>, <i>Intel 8051</i>, <i>Motorola 6809</i>, <i>Motorola 68HC11</i> atd.
atd. s&nbsp;instrukcí <strong>DAA</strong> či <strong>DA A</strong> používanou
po operaci součtu a rozdílu. Podobná je instrukce <strong>A6AAC</strong> u
čtyřbitových mikrořadičů TMS-1000.</li>

<li>ALU provádí většinu operací v&nbsp;binárním režimu, ovšem některé instrukce
ji mohou přepnout do režimu BCD. Příkladem je <i>Motorola 68000</i>
s&nbsp;instrukcemi <strong>ABCD</strong> (Add Binary Coded Decimal),
<strong>NBCD</strong> (Negate Binary Coded Decimal) a <strong>SBCD</strong>
(Subtract Binary Coded Decimal).</li>

</ol>

<img src="https://i.iinfo.cz/images/208/tms1000-4.jpg" class="image-284545" alt="&#160;" width="236" height="261" />
<p><i>Obrázek 9: Jedna z&nbsp;typických nasazení čtyřbitových mikrořadičů
&ndash; nejjednodušší kalkulačky .</i></p>

<p>Některé mikroprocesory obsahují větší množství instrukcí pro úpravu výsledku
a/nebo vstupních operandů. Příkladem může být čip 8086 (s&nbsp;instrukční sadou
udržovanou dodnes), podporující jak &bdquo;packed BCD&ldquo; (dvě cifry
v&nbsp;bajtu), tak i &bdquo;unpacked BCD&ldquo; (jediná cifra v&nbsp;bajtu).
V&nbsp;instrukční sadě nalezneme hned šest relevantních instrukcí:</p>

<table>
<tr><th>Operace</th><th>Packed BCD</th><th>Unpacked BCD</th></tr>
<tr><td>součet</td><td>DAA</td><td>AAA</td></tr>
<tr><td>rozdíl</td><td>DAS</td><td>AAS</td></tr>
<tr><td>součin</td><td>&times;</td><td>AAM</td></tr>
<tr><td>podíl</td><td>&times;</td><td>AAD</td></tr>
</table>

<p>BCD používá i matematický koprocesor x86 (konkrétně čip 8087 a kvůli zpětné
kompatibilitě i dnešní CPU+FPU), který dokáže do osmdesáti bitového slova
uložit 18 BCD cifer + znaménko (necelé dva bajty se přitom nevyužijí).</p>

<a href="https://www.root.cz/obrazek/284548/"><img src="https://i.iinfo.cz/images/208/tms1000-7-prev.jpg" class="image-284548" alt="&#160;" width="370" height="191" /></a></p>
<p><i>Obrázek 10: Segmentem, v&nbsp;němž se BCD používá dodnes, jsou
kalkulačky.</i></p>



<p><a name="k14"></a></p>
<h2 id="k14">14. Od BCD ke kódování EBCDIC</h2>

<p>S&nbsp;kódem BCD poměrně úzce souvisí i kódování znaků
<strong>EBCDIC</strong> neboli <i>Extended Binary Coded Decimal Interchange
Code</i>. Firma IBM toto kódování vytvořila v&nbsp;letech 1963&ndash;1964
v&nbsp;návaznosti na šestibitový kód využívaný u děrných štítků a použila ho u
počítačů <i>System/360</i>. Vzhledem k&nbsp;velké popularitě těchto počítačů se
kódování <strong>EBCDIC</strong> i přes jeho mnohé nevýhody (především
v&nbsp;porovnání s&nbsp;kódováním <strong>ASCII</strong>) rozšířilo i na další
počítače a jejich operační systémy, například <i>OS/390</i>, <i>z/OS</i>,
<i>OS/400</i> i některé počítačové systémy firem HP či Unisys.
V&nbsp;předchozím textu bylo napsáno, že <strong>EBCDIC</strong> má
v&nbsp;porovnání s&nbsp;dnes mnohem častěji používaným kódem
<strong>ASCII</strong> několik nevýhod. Některé z&nbsp;těchto nevýhod si
popíšeme v&nbsp;následujícím textu.</p>

<a href="http://i.iinfo.cz/images/503/ibm2-7.png"><img src="http://i.iinfo.cz/images/503/ibm2-7-prev.png" alt="ibm2" height="270" width="335" /></a>
<p><i>Obrázek 11: Architektura počítačů System/360.</i></p>

<p><strong>EBCDIC</strong> je založen na reprezentaci znaků pomocí osmi bitů,
což představuje rozdíl oproti sedmibitovému <strong>ASCII</strong>, i když
celkový počet znaků (včetně řídicích kódů) je zhruba stejný &ndash; pokrývá
totiž potřeby anglického jazyka. Alfanumerické i další znaky však nejsou
v&nbsp;tabulce všech 256 kombinací umístěny v&nbsp;přirozené posloupnosti (26
znaků velké abecedy, 26 znaků malé abecedy atd.), ale spíše po skupinách
čítajících devět či deset znaků, což je patrné z&nbsp;části této tabulky
vypsané na konci kapitoly (rozdíl mezi malými a velkými písmeny však spočívá
v&nbsp;negaci jednoho bitu, stejně jako v&nbsp;případě <strong>ASCII</strong>).
Nepravidelnost při tvorbě tabulky představovala pro programátory problém,
protože například nebylo jednoduché vygenerovat posloupnost všech písmen, nešlo
jednoduše zjistit, zda je nějaký znak platným písmenem
(v&nbsp;<strong>ASCII</strong> záležitost dvou porovnání),
<strong>EBCDIC</strong> se dal hůře zapamatovat (kupodivu i dnes je alespoň
základní znalost <strong>ASCII</strong> pro programátory velkou výhodou)
atd.</p>

<p>Navíc se při požadavku na rozšíření základní tabulky o další znaky
(například písmen s&nbsp;akcenty, řeckou abecedu, azbuku atd.) musely tyto
znaky přidávat na volné pozice rozmístěné po celé tabulce, na rozdíl od
sedmibitového kódu <strong>ASCII</strong>, který bylo možné celkem jednoduše
rozšířit přidáním osmého bitu &ndash; ostatně přesně tímto způsobem vzniklo
například populární kódování Kamenických, kódování dle normy ISO 8859-2 i mnoho
dalších kódování, u nichž byl prakticky vždy zachován význam prvních 128 kódů
odpovídajících <strong>ASCII</strong> (jednou z&nbsp;výjimek je kódování
použité u jehličkových tiskáren <i>Epson</i>, u nichž se některé znaky
s&nbsp;akcenty vkládaly do prvních 128 pozic na místo hranatých závorek a
několika dalších znaků, které se v&nbsp;běžně psaném textu vyskytují
v&nbsp;malém množství). Z&nbsp;výše zmíněných důvodů nebylo kódování
<strong>EBCDIC</strong> mezi programátory příliš oblíbeno, i když se ho firma
IBM kvůli zachování zpětné kompatibility drží prakticky až do dnešní doby.</p>

<p>Povšimněte si, jak je v&nbsp;EBCDIC schován kód BCD &ndash; jedná se o
poslední řádek s&nbsp;prefixem F-, tj.&nbsp;číslice jsou reprezentovány takto:
1111+BCD:</p>

<table>
<tr><th>  </th><th>-0</th><th>-1</th><th>-2</th><th>-3</th><th>-4</th><th>-5</th><th>-6</th><th>-7</th><th>-8</th><th>-9</th><th>-A</th><th>-B</th><th>-C</th><th>-D</th><th>-E</th><th>-F</th></tr>
<tr><th>8-</th><td>  </td><td>a </td><td>b </td><td>c </td><td>d </td><td>e </td><td>f </td><td>g </td><td>h </td><td>i </td><td>  </td><td>  </td><td>  </td><td>  </td><td>  </td><td>  </td></tr>
<tr><th>9-</th><td>  </td><td>j </td><td>k </td><td>l </td><td>m </td><td>n </td><td>o </td><td>p </td><td>q </td><td>r </td><td>  </td><td>  </td><td>  </td><td>  </td><td>  </td><td>  </td></tr>
<tr><th>A-</th><td>  </td><td>~ </td><td>s </td><td>t </td><td>u </td><td>v </td><td>w </td><td>x </td><td>y </td><td>z </td><td>  </td><td>  </td><td>  </td><td>  </td><td>  </td><td>  </td></tr>
<tr><th>B-</th><td>^ </td><td>  </td><td>  </td><td>  </td><td>  </td><td>  </td><td>  </td><td>  </td><td>  </td><td>  </td><td>[ </td><td>] </td><td>  </td><td>  </td><td>  </td><td>  </td></tr>
<tr><th>C-</th><td>{ </td><td>A </td><td>B </td><td>C </td><td>D </td><td>E </td><td>F </td><td>G </td><td>H </td><td>I </td><td>  </td><td>  </td><td>  </td><td>  </td><td>  </td><td>  </td></tr>
<tr><th>D-</th><td>} </td><td>J </td><td>K </td><td>L </td><td>M </td><td>N </td><td>O </td><td>P </td><td>Q </td><td>R </td><td>  </td><td>  </td><td>  </td><td>  </td><td>  </td><td>  </td></tr>
<tr><th>E-</th><td>\ </td><td>  </td><td>S </td><td>T </td><td>U </td><td>V </td><td>W </td><td>X </td><td>Y </td><td>Z </td><td>  </td><td>  </td><td>  </td><td>  </td><td>  </td><td>  </td></tr>
<tr><th>F-</th><td>0 </td><td>1 </td><td>2 </td><td>3 </td><td>4 </td><td>5 </td><td>6 </td><td>7 </td><td>8 </td><td>9 </td><td>  </td><td>  </td><td>  </td><td>  </td><td>  </td><td>  </td></tr>
</table>

<a href="http://i.iinfo.cz/images/503/ibm2-8.jpg"><img src="http://i.iinfo.cz/images/503/ibm2-8-prev.jpg" alt="ibm2" height="270" width="335" /></a>
<p><i>Obrázek 12: Některá úložná zařízení sálových počítačů firmy IBM &ndash;
v&nbsp;pozadí jednotky magnetických pásek, v&nbsp;popředí diskové
jednotky.</i></p>



<p><a name="k15"></a></p>
<h2 id="k15">15. Formáty s&nbsp;plovoucí řádovou čárkou s&nbsp;bází rovnou deseti</h2>

<p>Již <a
href="https://www.root.cz/clanky/interni-reprezentace-numerickych-hodnot-od-skutecneho-pocitacoveho-praveku-po-ieee-754-2008/#k14">minule</a>
jsme se seznámili s&nbsp;poněkud neobvyklým formátem čísel s&nbsp;plovoucí
řádovou čárkou, který byl používaný u osmibitových mikropočítačů Atari.
Připomeňme si, že se u tohoto formátu používala báze rovna hodnotě 100 (a
nikoli 2 či 16, což je u počítačů častější), navíc byla hodnota mantisy uložena
pomocí BCD kódu. Tento formát je skutečně v&nbsp;oblasti mikropočítačů poněkud
neobvyklý, ovšem poněkud častěji se můžeme setkat s&nbsp;použitím FP formátu,
v&nbsp;němž je báze reprezentována hodnotou 10.</p>

<p>Tento formát velmi často nalezneme i u kalkulaček, navíc kombinovaný
s&nbsp;mantisou uloženou v&nbsp;BCD. Například slavná <i>HP-35</i> používá
vlastně velmi podobný formát, jako již zmíněné osmibitové mikropočítače Atari,
ovšem s&nbsp;mnohem větší přesností:</p>

<ul>

<li>Exponent je uložen jako dvojice BCD číslic, může tedy mít hodnotu 0 .. 99
(to je obvyklé u většiny kalkulaček).</li>

<li>Mantisa je uložena jako deset BCD číslic (jednodušší kalkulačky mají jen
osm BCD číslic).</li>

<li>Další dva čtyřbitové &bdquo;nibbly&ldquo; jsou použity pro uložení znaménka
mantisy a exponentu (zde se poněkud plýtvá místem).</li>

</ul>

<p>Celkově je jedno číslo uloženo v&nbsp;56 bitech (14&times;4), což sice může
vypadat jako plýtvání místem, ovšem musíme si uvědomit, že kalkulačky pracují
pouze se dvěma či třemi registry, popř.&nbsp;u HP se zásobníkem se čtyřmi
prvky. Použití báze nastavené na 10 a BCD má své výhody, především není nutné
složitě kódovat vstup od uživatele na interní reprezentaci a naopak výsledky
dekódovat zpět na displej (nehledě na to, že u báze rovné deseti je zcela
přesně známá přesnost vyjádřená v&nbsp;počtu desetinných míst).</p>



<p><a name="k16"></a></p>
<h2 id="k16">16. Příklad FP s&nbsp;bází rovnou deseti: Packed Decimal u mikroprocesorů Motorola 68000</h2>

<p>U slavných mikroprocesorů Motorola 68000 se můžeme setkat s&nbsp;formátem
nazvaným <i>Packed Decimal</i> (který ovšem nemůže být přímo zpracováván
&ndash; je nutné použít k&nbsp;tomu určené subrutiny). Tento formát vychází
z&nbsp;formátu, který jsme si popsali v&nbsp;předchozí kapitole, ovšem je
zvětšen rozsah hodnot i jejich přesnost. Pro uložení numerické hodnoty se
používají tři 32bitová slova, tedy dohromady dvanáct bajtů. Exponent je
reprezentován třemi dekadickými ciframi (BCD), exponent pak sedmnácti
dekadickými ciframi, přičemž jedna cifra je umístěna před desetinnou čárkou,
dalších šestnáct cifer za touto čárkou:</p>

<table>
<tr><th>Slovo</th><th>Nibble 7</th><th>Nibble 6</th><th>Nibble 5</th><th>Nibble 4</th><th>Nibble 3</th><th>Nibble 2</th><th>Nibble 1</th><th>Nibble 0</th></tr>
<tr><td>1</td><td>příznaky</td><td>exponent</td><td>exponent</td><td>exponent</td><td>&times;</td><td>&times;</td><td>&times;</td><td>17.cifra</td></td></tr>
<tr><td>2</td><td>16.cifra</td><td>15.cifra</td><td>14.cifra</td><td>13.cifra</td><td>12.cifra</td><td>11.cifra</td><td>10.cifra</td><td>9.cifra</td></td></tr>
<tr><td>3</td><td>8.cifra</td><td>7.cifra</td><td>6.cifra</td><td>5.cifra</td><td>4.cifra</td><td>3.cifra</td><td>2.cifra</td><td>1.cifra</td></td></tr>
</table>

<p>V&nbsp;nejvyšším nibble prvního slova se nachází příznaky speciálních hodnot
(+&infin;, -&infin;, NAN, +0, -0), znaménko mantisy (SM) i znaménko exponentu
(SE),</p>



<p><a name="k17"></a></p>
<h2 id="k17">17. &bdquo;Komprimované&ldquo; formáty založené na BCD aneb jak uložit tři číslice do deseti bitů</h2>

<p>Samotný BCD není příliš úsporný. Představme si, že máme pracovat
s&nbsp;desítkovými hodnotami 0 až 999. Pokud použijeme BCD, budeme pro každou
hodnotu potřebovat 12 bitů (3 cifry &times; 4 bity), zatímco při použití
klasického binárního kódu nám bude stačit bitů 10 (2<sup>10</sup> = 1024 &gt;
1000). Aby se tento problém eliminoval, bylo vymyšleno několik způsobů
&bdquo;komprimace&ldquo; BCD číslic takovým způsobem, aby bylo možné
reprezentovat trojici desítkových cifer v&nbsp;pouhých deseti bitech. Delší
čísla se pak jednoduše získají skládáním trojice cifer za sebe. Existuje hned
několik variant tohoto řešení, z&nbsp;nichž nejznámější je formát <a
href="https://en.wikipedia.org/wiki/Densely_packed_decimal">DPD (Densely Packed
Decimal)</a>, jehož jednodušší varianta byla navržena <a
href="https://en.wikipedia.org/wiki/Chen%E2%80%93Ho_encoding">Chen–Ho(em)</a>.</p>

<p>V&nbsp;Chen-Hoově kódování, které je velmi elegantní, se desítková čísla 0
až 999 rozdělují do několika skupin, přičemž každá skupina se kóduje odlišným
způsobem:</p>

<table>
<tr><th>Čísla</th><th>Kombinací</th><th>Kódování</th><th>Poznámka</th></tr>
<tr><td>(0-7)(0-7)(0-7)</td><td>8&times;8&times;8=512</td><td>0+xxx+xxx+xxx</td><td>xxx představuje cifru 0-7</td></tr>
<tr><td>(8-9)(0-7)(0-7)</td><td>2&times;8&times;8=128</td><td>100+y+xxx+xxx</td><td>y rozlišuje mezi 8 a 9</td></tr>
<tr><td>(0-7)(8-9)(0-7)</td><td>8&times;2&times;8=128</td><td>101+y+xxx+xxx</td><td>alternativa k předchozímu formátu</td></tr>
<tr><td>(0-7)(0-7)(8-9)</td><td>8&times;8&times;2=128</td><td>110+y+xxx+xxx</td><td>alternativa k předchozímu formátu</td></tr>
<tr><td>(0-7)(8-9)(8-9)</td><td>8&times;2&times;2=32</td><td>111+x+00+yxxy</td><td>&nbsp;</td></tr>
<tr><td>(8-9)(0-7)(8-9)</td><td>2&times;8&times;2=32</td><td>111+y+01+xxxy</td><td>&nbsp;</td></tr>
<tr><td>(8-9)(8-9)(0-7)</td><td>2&times;2&times;8=32</td><td>111+y+10+yxxx</td><td>&nbsp;</td></tr>
<tr><td>(8-9)(8-9)(8-9)</td><td>2&times;2&times;2=8</td><td>111+y+11+y+00+y</td><td>kombinace 888, 889, 898, až 999</td></tr>
</table>

<p>Poznámka: <strong>xxx</strong> lze považovat za zkrácený BCD, který dokáže
reprezentovat cifru 0-7 (osm stavů). <strong>y</strong> je jediný bit, který
rozlišuje mezi cifrou 8 a 9.</p>



<p><a name="k18"></a></p>
<h2 id="k18">18. Formáty decimal32, decimal64 a decimal128</h2>

<p>Na <i>DPD (Densely Packed Decimal)</i> jsou založeny formáty
<strong>decimal32</strong>, <strong>decimal64</strong> a
<strong>decimal128</strong>, které jsou taktéž popsány v&nbsp;normě IEEE
754-2008. Základní vlastnosti těchto formátů jsou shrnuty v&nbsp;následující
tabulce:</p>

<table>
<tr><th>Formát</th><th>Šířka</th><th>Mantisa</th><th>Exponent</th></tr>
<tr><td>decimal32 </td><td> 32 bitů</td><td>7 cifer</td><td>−95 až +96</td></tr>
<tr><td>decimal64 </td><td> 64 bitů</td><td>16 cifer</td><td>−383 až +384</td></tr>
<tr><td>decimal128</td><td>128 bitů</td><td>34 cifer</td><td>−6143 až +6144</td></tr>
</table>

<p>Kvůli implicitnímu umístění desetinné tečky za první cifru jsou rozsahy
nejmenší (nenulové) hodnoty a největší hodnoty následující:</p>

<table>
<tr><th>Nejmenší kladná hodnota</th><th>Největší hodnota</th></tr>
<tr><td>0000001&times;10<sup>−101</sup></td><td>9999999&times;10<sup>90</sup></td></tr>
<tr><td>0000000000000001&times;10<sup>−398</sup></td><td>9999999999999999&times;10<sup>369</sup></td></tr>
<tr><td>0000000000000000000000000000000001&times;10<sup>−6176</sup></td><td>9999999999999999999999999999999999&times;10<sup>6111</sup></td></tr>
</table>

<p>Poznámka: kódování je symetrické, takže největší kladná a nejmenší záporná
hodnota se liší pouze znaménkem.</p>

<p>Kromě běžných hodnot existují i bitové kombinace pro NaN, +&infin; i pro
-&infin;.</p>



<p><a name="k19"></a></p>
<h2 id="k19">19. Alternativní formát uložení čísel &ndash; zlomky (<i>rational</i>)</h2>

<p>V&nbsp;mnoha programovacích jazycích odvozených od LISPu se setkáme
s&nbsp;podporou zlomků; tento formát se většinou nazývá <i>rational</i> či jen
<i>ratio</i>. Se zlomky lze pracovat například v&nbsp;jazyce <a
href="https://www.root.cz/vyhledavani/?qs=clojure">Clojure</a>, ve <a
href="https://www.root.cz/clanky/zaklady-programovani-v-jazyku-scheme/#k02">Scheme</a>
i v&nbsp;jazyku <a
href="https://www.root.cz/clanky/pixie-lehky-skriptovaci-jazyk-s-kouzelnymi-schopnostmi/#k10">Pixie</a>
odvozeném od Clojure. Konkrétní implementace zlomků se v&nbsp;různých jazycích
od sebe odlišuje. Většinou se jedná buď o dvojici celých čísel (například
32bitových integerů) nebo o dvojici hodnot typu <i>big integer</i>, které mají
neomezený rozsah. Ostatně právě tato reprezentace je použita v&nbsp;jazyku
Clojure pro jeho datový typ <a
href="https://github.com/clojure/clojure/blob/master/src/jvm/clojure/lang/Ratio.java">Ratio</a>.
Se zlomky se v&nbsp;LISPovských jazycích pracuje jednoduše, protože zápis x/y
znamená skutečně zápis zlomku a nikoli násobení (to se zapisuje prefixovou
funkcí). Většina výpočtů provádí automatické zjednodušování zlomků:</p>

<pre>
(/ 1 2)
1/2
</pre>

<pre>
(/ 1 2 3)
1/6
</pre>

<pre>
(/ 3 2)
3/2
</pre>

<pre>
(/ (+ 1 2) (+ 3 4))
3/7
</pre>

<pre>
(+ 1/2 (* 3/4 (/ 5/6 7/8)))
17/14
</pre>

<p>Převod na zlomek si můžeme i vynutit konverzní funkcí, ovšem výsledek
samozřejmě nebude přesný, protože není přesný samotný vstup do konverzní
funkce:</p>

<pre>
(rationalize Math/PI)
3141592653589793/1000000000000000
</pre>

<p>Další příklad: kombinace takzvaného threading makra, konstruktoru sekvence,
funkce vyššího řádu reduce a zlomků:</p>

<pre>
(-&gt;&gt; (repeat 10 3/7) (reduce *))
59049/282475249
</pre>

<p>Použití zlomků může být v&nbsp;mnoha oblastech výhodné, protože jimi lze
nahradit typy <i>decimal</i> či FP s&nbsp;bází rovnou deseti. Zaplatíme za to
ovšem delším časem výpočtu, protože zlomky nejsou přímo podporovány
v&nbsp;hardware a navíc se musí výsledek výpočtu (dvě celočíselné hodnoty x a
y) zjednodušovat.</p>

<img src="http://i.iinfo.cz/images/190/23-lisp3-9.jpg" width="400" height="378" alt="23_lisp3" />
<p><i>Obrázek 13: Design počítače Connection Machine 5 (s&nbsp;paralelním
LISPem) se skutečně povedl, jedná se pravděpodobně o nejelegantnější
superpočítač, který byl kdy vyroben.</i></p>



<p><a name="k20"></a></p>
<h2 id="k20">20. Odkazy na Internetu</h2>

<ol>

<li>Norma IEEE 754 a příbuzní: formáty plovoucí řádové tečky<br />
<a href="https://www.root.cz/clanky/norma-ieee-754-a-pribuzni-formaty-plovouci-radove-tecky/">https://www.root.cz/clanky/norma-ieee-754-a-pribuzni-formaty-plovouci-radove-tecky/</a>
</li>

<li>IEEE-754 Floating-Point Conversion<br />
<a href="http://babbage.cs.qc.cuny.edu/IEEE-754.old/32bit.html">http://babbage.cs.qc.cuny.edu/IEEE-754.old/32bit.html</a>
</li>

<li>Small Float Formats<br />
<a href="https://www.khronos.org/opengl/wiki/Small_Float_Formats">https://www.khronos.org/opengl/wiki/Small_Float_Formats</a>
</li>

<li>Binary-coded decimal<br />
<a href="https://en.wikipedia.org/wiki/Binary-coded_decimal">https://en.wikipedia.org/wiki/Binary-coded_decimal</a>
</li>

<li>Chen–Ho encoding<br />
<a href="https://en.wikipedia.org/wiki/Chen%E2%80%93Ho_encoding">https://en.wikipedia.org/wiki/Chen%E2%80%93Ho_encoding</a>
</li>

<li>Densely packed decimal<br />
<a href="https://en.wikipedia.org/wiki/Densely_packed_decimal">https://en.wikipedia.org/wiki/Densely_packed_decimal</a>
</li>

<li>A Summary of Chen-Ho Decimal Data encoding<br />
<a href="http://speleotrove.com/decimal/chen-ho.html">http://speleotrove.com/decimal/chen-ho.html</a>
</li>

<li>Art of Assembly language programming: The 80x87 Floating Point Coprocessors<br />
<a href="https://courses.engr.illinois.edu/ece390/books/artofasm/CH14/CH14-3.html">https://courses.engr.illinois.edu/ece390/books/artofasm/CH14/CH14-3.html</a>
</li>

<li>Art of Assembly language programming: The FPU Instruction Set<br />
<a href="https://courses.engr.illinois.edu/ece390/books/artofasm/CH14/CH14-4.html">https://courses.engr.illinois.edu/ece390/books/artofasm/CH14/CH14-4.html</a>
</li>

<li>INTEL 80387 PROGRAMMER'S REFERENCE MANUAL<br />
<a href="http://www.ragestorm.net/downloads/387intel.txt">http://www.ragestorm.net/downloads/387intel.txt</a>
</li>
<li>Floating-Point Formats<br />
<a href="http://www.quadibloc.com/comp/cp0201.htm">http://www.quadibloc.com/comp/cp0201.htm</a>
</li>

<li>Mainframe family tree and chronology<br />
<a href="http://www-03.ibm.com/ibm/history/exhibits/mainframe/mainframe_FT1.html">http://www-03.ibm.com/ibm/history/exhibits/mainframe/mainframe_FT1.html</a>
</li>

<li>704 Data Processing System<br />
<a href="http://www-03.ibm.com/ibm/history/exhibits/mainframe/mainframe_PP704.html">http://www-03.ibm.com/ibm/history/exhibits/mainframe/mainframe_PP704.html</a>
</li>

<li>705 Data Processing System<br />
<a href="http://www-03.ibm.com/ibm/history/exhibits/mainframe/mainframe_PP705.html">http://www-03.ibm.com/ibm/history/exhibits/mainframe/mainframe_PP705.html</a>
</li>

<li>The IBM 704<br />
<a href="http://www.columbia.edu/acis/history/704.html">http://www.columbia.edu/acis/history/704.html</a>
</li>

<li>IBM Mainframe album<br />
<a href="http://www-03.ibm.com/ibm/history/exhibits/mainframe/mainframe_album.html">http://www-03.ibm.com/ibm/history/exhibits/mainframe/mainframe_album.html</a>
</li>

<li>Mainframe computer<br />
<a href="http://en.wikipedia.org/wiki/Mainframe_computer">http://en.wikipedia.org/wiki/Mainframe_computer</a>
</li>

<li>IBM mainframe<br />
<a href="http://en.wikipedia.org/wiki/IBM_mainframe">http://en.wikipedia.org/wiki/IBM_mainframe</a>
</li>

<li>IBM 700/7000 series<br />
<a href="http://en.wikipedia.org/wiki/IBM_700/7000_series">http://en.wikipedia.org/wiki/IBM_700/7000_series</a>
</li>

<li>IBM System/360<br />
<a href="http://en.wikipedia.org/wiki/IBM_System/360">http://en.wikipedia.org/wiki/IBM_System/360</a>
</li>

<li>IBM System/370<br />
<a href="http://en.wikipedia.org/wiki/IBM_System/370">http://en.wikipedia.org/wiki/IBM_System/370</a>
</li>

<li>IBM Floating Point Architecture<br />
<a href="http://en.wikipedia.org/wiki/IBM_Floating_Point_Architecture">http://en.wikipedia.org/wiki/IBM_Floating_Point_Architecture</a>
</li>

<li>Extended Binary Coded Decimal Interchange Code<br />
<a href="http://en.wikipedia.org/wiki/EBCDIC">http://en.wikipedia.org/wiki/EBCDIC</a>
</li>

<li>ASCII/EBCDIC Conversion Table<br />
<a href="http://docs.hp.com/en/32212-90008/apcs01.html">http://docs.hp.com/en/32212-90008/apcs01.html</a>
</li>

<li>EBCDIC<br />
<a href="http://www.hansenb.pdx.edu/DMKB/dict/tutorials/ebcdic.php">http://www.hansenb.pdx.edu/DMKB/dict/tutorials/ebcdic.php</a>
</li>

<li>EBCDIC tables<br />
<a href="http://home.mnet-online.de/wzwz.de/temp/ebcdic/cc_en.htm">http://home.mnet-online.de/wzwz.de/temp/ebcdic/cc_en.htm</a>
</li>

<li>The Mainframe Blog<br />
<a href="http://mainframe.typepad.com/blog/2006/11/my_personal_mai.html">http://mainframe.typepad.com/blog/2006/11/my_personal_mai.html</a>
</li>

<li>IBM Tightens Stranglehold Over Mainframe Market Gets Hit with Antitrust Complaint in Europe<br />
<a href="http://www.ccianet.org/artmanager/publish/news/IBM_Tightens_Stranglehold_Over_Mainframe_Market_Gets_Hit_with_Antitrust_Complaint_in_Europe.shtml">http://www.ccianet.org/artmanager/publish/news/IBM_Tightens_Stranglehold_Over_Mainframe_Market_Gets_Hit_with_Antitrust_Complaint_in_Europe.shtml</a>
</li>

<li>Lectures in the History of Computing: Mainframes<br />
<a href="http://www.computinghistorymuseum.org/teaching/lectures/pptlectures/9-MainframeComputers.ppt">http://www.computinghistorymuseum.org/teaching/lectures/pptlectures/9-MainframeComputers.ppt</a>
</li>

<li>36-bit<br />
<a href="http://en.wikipedia.org/wiki/36-bit_word_length">http://en.wikipedia.org/wiki/36-bit_word_length</a>
</li>

<li>36bit.org<br />
<a href="http://www.36bit.org/">http://www.36bit.org/</a>
</li>

<li>Applesoft BASIC<br />
<a href="https://en.wikipedia.org/wiki/Applesoft_BASIC">https://en.wikipedia.org/wiki/Applesoft_BASIC</a>
</li>

<li>How did the Apple II do floating point?<br />
<a href="https://groups.google.com/forum/#!topic/comp.emulators.apple2/qSBiG2TAlRg">https://groups.google.com/forum/#!topic/comp.emulators.apple2/qSBiG2TAlRg</a>
</li>

<li>IBM Floating Point Architecture<br />
<a href="https://en.wikipedia.org/wiki/IBM_Floating_Point_Architecture">https://en.wikipedia.org/wiki/IBM_Floating_Point_Architecture</a>
</li>

<li>The Arithmetic Subroutines<br />
<a href="http://www.users.waitrose.com/~thunor/mmcoyzx81/chapter17.html">http://www.users.waitrose.com/~thunor/mmcoyzx81/chapter17.html</a>
</li>

<li>ZX Floating point to Decimal code in BASIC<br />
<a href="http://www.sinclairzxworld.com/viewtopic.php?t=1422">http://www.sinclairzxworld.com/viewtopic.php?t=1422</a>
</li>

<li>Floating Point Arithmetic Package<br />
<a href="http://www.retrocomputing.net/parts/atari/800/docs/atari_os/atari_os_user_manual_08.htm">http://www.retrocomputing.net/parts/atari/800/docs/atari_os/atari_os_user_manual_08.htm</a>
</li>

<li>704 Data Processing System<br />
<a href="https://www-03.ibm.com/ibm/history/exhibits/mainframe/mainframe_PP704.html">https://www-03.ibm.com/ibm/history/exhibits/mainframe/mainframe_PP704.html</a>
</li>

<li>Turbo Pascal Real<br />
<a href="http://www.shikadi.net/moddingwiki/Turbo_Pascal_Real">http://www.shikadi.net/moddingwiki/Turbo_Pascal_Real</a>
</li>

<li>THE FLOATING POINT ARITHMETIC PACKAGE<br />
<a href="http://www.atarimax.com/freenet/freenet_material/5.8-BitComputersSupportArea/7.TechnicalResourceCenter/showarticle.php?14">http://www.atarimax.com/freenet/freenet_material/5.8-BitComputersSupportArea/7.TechnicalResourceCenter/showarticle.php?14</a>
</li>

<li>Sinclair ZX81 BASIC Programming (by Steven Vickers)<br />
<a href="http://www.worldofspectrum.org/ZX81BasicProgramming/">http://www.worldofspectrum.org/ZX81BasicProgramming/</a>
</li>

<li>The Most Expensive One-byte Mistake: Did Ken, Dennis, and Brian choose wrong with NUL-terminated text strings?<br />
<a href="http://queue.acm.org/detail.cfm?id=2010365">http://queue.acm.org/detail.cfm?id=2010365</a>
</li>

<li>UCSD Pascal<br />
<a href="https://en.wikipedia.org/wiki/UCSD_Pascal">https://en.wikipedia.org/wiki/UCSD_Pascal</a>
</li>

<li>D Language: Strings<br />
<a href="https://dlang.org/spec/arrays.html#strings">https://dlang.org/spec/arrays.html#strings</a>
</li>

<li>The History Behind the Definition of a 'String'<br />
<a href="https://stackoverflow.com/questions/880195/the-history-behind-the-definition-of-a-string">https://stackoverflow.com/questions/880195/the-history-behind-the-definition-of-a-string</a>
</li>

<li>Libc: Representation of Strings<br />
<a href="https://www.gnu.org/software/libc/manual/html_node/Representation-of-Strings.html">https://www.gnu.org/software/libc/manual/html_node/Representation-of-Strings.html</a>
</li>

<li>ATARI BASIC<br />
<a href="http://www.atariarchives.org/dere/chapt10.php">http://www.atariarchives.org/dere/chapt10.php</a>
</li>

<li>BASIC (Wikipedia EN)<br />
<a href="http://en.wikipedia.org/wiki/BASIC">http://en.wikipedia.org/wiki/BASIC</a>
</li>

<li>BASIC (Wikipedia CZ)<br />
<a href="http://cs.wikipedia.org/wiki/BASIC">http://cs.wikipedia.org/wiki/BASIC</a>
</li>

<li>Turbo BASIC (Wikipedia CZ)<br />
<a href="http://cs.wikipedia.org/wiki/Turbo_BASIC">http://cs.wikipedia.org/wiki/Turbo_BASIC</a>
</li>

<li>Sinclair BASIC (Wikipedia CZ)<br />
<a href="http://cs.wikipedia.org/wiki/Sinclair_BASIC">http://cs.wikipedia.org/wiki/Sinclair_BASIC</a>
</li>

<li>More BASIC Computer Games<br />
<a href="http://www.atariarchives.org/morebasicgames/">http://www.atariarchives.org/morebasicgames/</a>
</li>

<li>Dartmouth College Computation Center: 1964 &ndash; The original Dartmouth BASIC manual<br />
<a href="http://www.bitsavers.org/pdf/dartmouth/BASIC_Oct64.pdf">http://www.bitsavers.org/pdf/dartmouth/BASIC_Oct64.pdf</a>
</li>

<li>The Original BASIC<br />
<a href="http://www.truebasic.com/">http://www.truebasic.com/</a>
</li>

<li>BASIC - Beginners All-purpose Symbolic Instruction Code<br />
<a href="http://hopl.murdoch.edu.au/showlanguage.prx?exp=176">http://hopl.murdoch.edu.au/showlanguage.prx?exp=176</a>
</li>

<li>Universal Coded Character Set<br />
<a href="https://en.wikipedia.org/wiki/Universal_Coded_Character_Set">https://en.wikipedia.org/wiki/Universal_Coded_Character_Set</a>
</li>

<li>UTF-16<br />
<a href="https://en.wikipedia.org/wiki/UTF-16">https://en.wikipedia.org/wiki/UTF-16</a>
</li>

<li>PEP 393 -- Flexible String Representation<br />
<a href="https://www.python.org/dev/peps/pep-0393/">https://www.python.org/dev/peps/pep-0393/</a>
</li>

<li>In-memory size of a Python structure<br />
<a href="https://stackoverflow.com/questions/1331471/in-memory-size-of-a-python-structure">https://stackoverflow.com/questions/1331471/in-memory-size-of-a-python-structure</a>
</li>

<li>What is internal representation of string in Python 3.x<br />
<a href="https://stackoverflow.com/questions/1838170/what-is-internal-representation-of-string-in-python-3-x#9079985">https://stackoverflow.com/questions/1838170/what-is-internal-representation-of-string-in-python-3-x#9079985</a>
</li>

<li>How to profile memory usage in Python<br />
<a href="https://www.pluralsight.com/blog/tutorials/how-to-profile-memory-usage-in-python">https://www.pluralsight.com/blog/tutorials/how-to-profile-memory-usage-in-python</a>
</li>

<li>What's the rationale for null terminated strings?<br />
<a href="https://stackoverflow.com/questions/4418708/whats-the-rationale-for-null-terminated-strings">https://stackoverflow.com/questions/4418708/whats-the-rationale-for-null-terminated-strings</a>
</li>

<li>Unicode<br />
<a href="https://en.wikipedia.org/wiki/Unicode">https://en.wikipedia.org/wiki/Unicode</a>
</li>

<li>The Development of the C Language<br />
<a href="https://www.bell-labs.com/usr/dmr/www/chist.html">https://www.bell-labs.com/usr/dmr/www/chist.html</a>
</li>

<li>Borland Pascal Wiki: String operations<br />
<a href="http://borlandpascal.wikia.com/wiki/String_operations">http://borlandpascal.wikia.com/wiki/String_operations</a>
</li>

<li>Pascal Strings<br />
<a href="https://www.tutorialspoint.com/pascal/pascal_strings.htm">https://www.tutorialspoint.com/pascal/pascal_strings.htm</a>
</li>

<li>PChar - Null terminated strings<br />
<a href="https://www.freepascal.org/docs-html/ref/refsu12.html">https://www.freepascal.org/docs-html/ref/refsu12.html</a>
</li>

<li>Comparison of Pascal and C<br />
<a href="https://en.wikipedia.org/wiki/Comparison_of_Pascal_and_C">https://en.wikipedia.org/wiki/Comparison_of_Pascal_and_C</a>
</li>

<li>FORTRAN 66<br />
<a href="http://fortranwiki.org/fortran/show/FORTRAN+66">http://fortranwiki.org/fortran/show/FORTRAN+66</a>
</li>

<li>Fortran: strings<br />
<a href="https://en.wikibooks.org/wiki/Fortran/strings">https://en.wikibooks.org/wiki/Fortran/strings</a>
</li>

<li>Strings in Atari BASIC<br />
<a href="http://www.cyberroach.com/analog/an11/strings.htm">http://www.cyberroach.com/analog/an11/strings.htm</a>
</li>

<li>String Arrays in Atari BASIC<br />
<a href="http://www.atarimagazines.com/compute/issue11/52_1_STRING_ARRAYS_IN_ATARI_BASIC.php">http://www.atarimagazines.com/compute/issue11/52_1_STRING_ARRAYS_IN_ATARI_BASIC.php</a>
</li>

<li>An Atari BASIC Tutorial<br />
<a href="http://www.cyberroach.com/analog/an25/basictutorial.htm">http://www.cyberroach.com/analog/an25/basictutorial.htm</a>
</li>

<li>Basic Multilingual Plane<br />
<a href="https://en.wikipedia.org/wiki/Plane_(Unicode)#Basic_Multilingual_Plane">https://en.wikipedia.org/wiki/Plane_(Unicode)#Basic_Multilingual_Plane</a>
</li>

</ol>



<p></p><p></p>
<p><small>Autor: <a href="http://www.fit.vutbr.cz/~tisnovpa">Pavel Tišnovský</a> &nbsp; 2017</small></p>
</body>
</html>

