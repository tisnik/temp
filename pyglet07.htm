<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
        "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html>
<head>
<title>Multimediální knihovna Pyglet: textury a texturování při vykreslování trojrozměrných scén</title>
<meta name="Author" content="Pavel Tisnovsky" />
<meta name="Generator" content="vim" />
<meta http-equiv="content-type" content="text/html; charset=utf-8" />
<style type="text/css">
         body {color:#000000; background:#ffffff;}
         h1  {font-family: arial, helvetica, sans-serif; color:#ffffff; background-color:#c00000; text-align:center; padding-left:1em}
         h2  {font-family: arial, helvetica, sans-serif; color:#ffffff; background-color:#0000c0; padding-left:1em; text-align:left}
         h3  {font-family: arial, helvetica, sans-serif; color:#000000; background-color:#c0c0c0; padding-left:1em; text-align:left}
         h4  {font-family: arial, helvetica, sans-serif; color:#000000; background-color:#e0e0e0; padding-left:1em; text-align:left}
         a   {font-family: arial, helvetica, sans-serif;}
         li  {font-family: arial, helvetica, sans-serif; color:#000000; text-align:justify; width:450px;}
         ol  {font-family: arial, helvetica, sans-serif; color:#000000; text-align:justify; width:450px;}
         ul  {font-family: arial, helvetica, sans-serif; color:#000000; text-align:justify; width:450px;}
         p   {font-family: arial, helvetica, sans-serif; color:#000000; text-align:justify;}
         pre {background:#e0e0e0}
</style>
</head>

<body>

<h1>Multimediální knihovna Pyglet: textury a texturování při vykreslování trojrozměrných scén</h1>

<h3>Pavel Tišnovský</h3>

<p></p>

<h1>Úvodník</h1>

<p></p>



<h2>Obsah</h2>

<p><a href="#k01">*** 1. Použití textur v&nbsp;knihovně Pyglet</a></p>
<p><a href="#k02">*** 2. Textury reprezentované rastrovými obrázky</a></p>
<p><a href="#k03">*** 3. Kdy a proč používat texturování?</a></p>
<p><a href="#k04">*** 4. Podpora pro práci s&nbsp;texturami v&nbsp;knihovnách OpenGL a Pyglet</a></p>
<p><a href="#k05">*** 5. Postup při použití textur ve skriptech používajících knihovnu Pyglet</a></p>
<p><a href="#k06">*** 6. Načtení textury z&nbsp;externího souboru</a></p>
<p><a href="#k07">*** 7. Nastavení parametrů textur a povolení texturování</a></p>
<p><a href="#k08">*** 8. Specifikace souřadnic v&nbsp;prostoru textury</a></p>
<p><a href="#k09">*** 9. První demonstrační příklad: převod rastrového obrázku na texturu</a></p>
<p><a href="#k10">*** 10. Nastavování parametrů textur</a></p>
<p><a href="#k11">*** 11. Druhý demonstrační příklad: nastavení způsobu opakování textur</a></p>
<p><a href="#k12">*** 12. Třetí demonstrační příklad: zrcadlení textur při opakování vzorku</a></p>
<p><a href="#k13">*** 13. Chování texturovacího engine při přibližování a vzdalování textur</a></p>
<p><a href="#k14">*** 14. Čtvrtý demonstrační příklad: výběr nejbližšího texelu</a></p>
<p><a href="#k15">*** 15. Pátý demonstrační příklad: použití bilineárního filtru</a></p>
<p><a href="#k16">*** 16. Šestý demonstrační příklad: nanesení textury na stěny 3D tělesa</a></p>
<p><a href="#k17">*** 17. Repositář s&nbsp;demonstračními příklady</a></p>
<p><a href="#k18">*** 18. Odkazy na Internetu</a></p>



<p><a name="k01"></a></p>
<h2 id="k01">1. Použití textur v&nbsp;knihovně Pyglet</h2>

<p>Texturování (resp. přesněji nanášení textur) se označuje princip obarvení povrchu zobrazovaných (většinou trojrozměrných) těles různými obrazci. Důležité přitom je, že se nijak nemění geometrické vlastnosti těles, pouze se jinak zobrazuje jejich povrch. Obrazce, které se na povrch těles nanášejí, se nazývají <i>textury</i> (<i>textures</i>). Tyto textury jsou většinou představovány plošnými obrázky (dvoudimenzionální textury), některé grafické systémy však podporují i vykreslování jednorozměrných a dokonce trojrozměrných (objemových) textur.</p>

<p>Obrazce pro textury se mohou vytvářet několika způsoby. Buď je možné použít klasické rastrové obrázky (vzniklé například namalováním, vyfocením nebo naskenováním), nebo se textura může vytvářet pomocí různých algoritmů založených většinou na fraktálních technikách &ndash; tímto způsobem vznikají takzvané <i>procedurální textury</i>. Procedurální textury lze použít buď pro výpočet rastrových obrázků před vlastním vykreslováním (po výpočtu obrázku se tato textura chová jako každý jiný rastrový obrázek se všemi výhodami i nevýhodami), nebo se může výpočet textur provádět v&nbsp;reálném čase až při vykreslování, přičemž se parametry výpočtu textury nastaví podle aktuální velikosti a orientace plošky, na kterou se textura nanáší. Tuto druhou možnost však OpenGL a tím pádem ani Pyglet přímo nepodporuje, výpočet procedurálních textur je tedy nutné provádět &bdquo;ručně&ldquo;. Na prvním obrázku je ukázána procedurální textura vzniklá sloučením více fraktálních obrazců s&nbsp;procedurální texturou mramoru (marble).</p>

*** image ***
<p><i>Obrázek 1: Ukázka procedurální textury.</i></p>



<p><a name="k02"></a></p>
<h2 id="k02">2. Textury reprezentované rastrovými obrázky</h2>

<p>V&nbsp;dalším textu se budeme téměř výhradně zabývat texturami reprezentovanými rastrovými obrázky, nezávisle na tom, jakým způsobem vznikly. I když řeč bude převážně o dvoudimenzionálních texturách (tedy bitmapách a pixmapách), většina zde popisovaných vlastností se vztahuje i na jednorozměrné a trojrozměrné textury. Případné výjimky a odlišnosti si samozřejmě postupně popíšeme. Na druhém obrázku je ukázána dvoudimenzionální, &bdquo;ručně&ldquo; nakreslená textura. Rastrové textury budeme v&nbsp;demonstračních příkladech vyrábět buď programově (různé šachovnice apod.), nebo je budeme načítat z&nbsp;externích souborů, k&nbsp;čemuž použijeme již známé funkce nabízené knihovnou Pyglet.</p>

<p>Podobně, jako je bitmapa či pixmapa složena ze základních rastrových elementů (<i>pixelů</i>), je textura složena z&nbsp;<i>texelů</i>. Pixel a texel mají stejné vlastnosti a podobný či dokonce ekvivalentní způsob uložení v&nbsp;paměti. V&nbsp;dalším textu však budeme oba pojmy navzájem oddělovat, tj.&nbsp;pixel je element vykreslovaný na obrazovce, kdežto texel je rastrový element (většinou) dvourozměrné textury. Texturování potom spočívá v&nbsp;nanášení texelů na vykreslovaný povrch.</p>

*** image ***
<p><i>Obrázek 2: Ukázka nakreslené rastrové textury.</i></p>



<p><a name="k03"></a></p>
<h2 id="k03">3. Kdy a proč používat texturování?</h2>

<p>Texturu je možné použít ve všech případech, kdy je nutné vykreslovat tělesa se složitě strukturovanými povrchy, která však nevykazují velké změny v&nbsp;geometrii (tedy tvaru) povrchu. Typickým příkladem je cihlová zeď, která je v&nbsp;reálném světě složená z&nbsp;jednotlivých cihel spojených maltou. Při modelování této zdi sice můžeme každou cihlu reprezentovat například kvádrem s&nbsp;vhodně zvolenou barvou, ale v&nbsp;případě vykreslování velkých zdí by počet vykreslovaných těles rostl příliš rychle, takže by se zbytečně plýtvalo jak pamětí, tak i výpočetním výkonem grafického subsystému. Ještě horší situace by nastala například u koberce, kde by bylo nutné vytvářet všechna barevná vlákna apod.</p>

<p>V&nbsp;těchto případech je možné zeď nebo koberec reprezentovat jednou plochou (složenou například ze dvou trojúhelníků nebo jednoho čtyřúhelníku) a na tuto plochu potom nanést předem vytvořený rastrový obrázek. V&nbsp;případě zdi se tak sice připravíme o geometrické nerovnosti povrchu (ty lze částečně &ndash; při vhodném natočení tělesa &ndash; simulovat například bump-mappingem), ale vykreslení bude na dnešních počítačích dostatečně rychlé a v&nbsp;případě dostatečné velikosti (rozlišení) textury i kvalitní.</p>

<p>Textury se také někdy používají poněkud jiným způsobem pro vytváření a následné vykreslení různých složitých modelů, například stromů. Buď je možné strom namodelovat jako těleso obsahující až několik tisíc polygonů, nebo je možné vytvořit dvourozměrný obrázek stromu z&nbsp;několika směrů a strom vykreslit jako několik vzájemně se protínajících ploch s&nbsp;nanesenou konturou stromu. V&nbsp;tomto případě však textura musí být v&nbsp;některých místech průhledná, což ovšem při vykreslování nepředstavuje větší problém. Tato technika se nazývá <i>billboarding</i>, protože se vychází z&nbsp;podobnosti s&nbsp;klasickými billboardy (například ty u dálnic).</p>

<p>V&nbsp;minulosti se často také používaly otexturované objekty (většinou obdélníky), které byly k&nbsp;pozorovateli natočeny vždy stejnou stranou. Tyto objekty se nazývají <i>sprity</i> a byly použity zejména v&nbsp;mnoha úspěšných hrách, například Doom, pro vykreslování předmětů a potvůrek ve hře. Sprity samozřejmě můžeme používat i v&nbsp;OpenGL, lze například vykreslovat pixmapy nebo vhodně natočený obdélník pokrytý texturou. Texturování může být v&nbsp;tomto případě výhodnější, protože se (narozdíl od vykreslování pixmap) nemusí stále přenášet pixmapová data po sběrnici/portu, ale jsou uložena přímo v&nbsp;paměti grafického akcelerátoru.</p>



<p><a name="k04"></a></p>
<h2 id="k04">4. Podpora pro práci s&nbsp;texturami v&nbsp;knihovnách OpenGL a Pyglet</h2>

<p>V OpenGL jsou podporovány pouze rastrové textury, které mohou být buď jednodimenzionální, dvoudimenzionální, nebo třídimenzionální. V případě jednodimenzio­nálních textur se prakticky jedná o pruh pixelů, pomocí něhož se dají realizovat různé barevné přechody. Dvoudimenzionální textury (rastrové bitmapy a pixmapy) jsou v dnešní době zdaleka nejpoužívanější a jsou podporovány na naprosté většině grafických akcelerátorů (dokonce bych napsal na všech, protože jsem zatím nezažil, že by texturování nefungovalo; veškeré chyby texturování spočívají buď v nedostatku paměti pro textury, nebo v chybě driveru, který musí textury přenášet přes port do grafického akcelerátoru).</p>

<p>Třídimenzionální textury (tj. objemové či voxelové textury) se používají především ve specializovaných aplikacích (medicína apod.), kdy je potřeba zobrazovat objemová data. Větší podporu tohoto typu textur můžeme očekávat až v dalších generacích grafických akcelerátorů, protože pro uložení dat prostorových textur je zapotřebí velkého množství paměti, která současně musí být dostatečně rychlá pro čtení.</p>

<p>Největší podpora ze strany grafických akcelerátorů je tedy u dvoudimenzionálních textur, které také splňují značnou část nároků programátora počítačové grafiky. Především tímto typem textur se budeme zabývat v dalším textu.</p>

<p>V OpenGL lze také zvolit různé filtrace textur, režimy mapování textur na plošky, multitexturování a další grafické efekty, které si dále probereme. Musíme si však uvědomit, že pokud použijeme některý grafický efekt, který není grafickým akcelerátorem podporován, dojde k výpočtům pomocí hlavního procesoru počítače, což značně zpomaluje celý systém. Proto je nejprve vhodné zjistit, které efekty jsou na grafickém akcelerátoru podporovány, a případně dát uživateli naší aplikace na výběr mezi kvalitou a rychlostí zobrazení.</p>

<p>Knihovna Pyglet taktéž podporuje práci s&nbsp;texturami, protože umožňuje načíst rastrový obrázek (to již známe) a převést ho na objekt reprezentující dvourozměrnou texturu. Právě tuto funkcionalitu využijeme v&nbsp;demonstračních příkladech.</p>



<p><a name="k05"></a></p>
<h2 id="k05">5. Postup při použití textur ve skriptech používajících knihovnu Pyglet</h2>

<p>Vykreslování objektů s nanesenou texturou vyžaduje provést několik vzájemně provázaných kroků:</p>

<ol>
<li>Vytvoření rastrové předlohy textury nebo její načtení ze souboru. K&nbsp;tomu lze využít funkce nabízené knihovnou Pyglet.</li>
<li>Vytvoření nového texturovacího objektu, přiřazení textury tomuto objektu a nastavení formátu textury. Poslední část není nutno provést explicitně, to opět zajistí knihovna Pyglet.</li>
<li>Nastavení způsobu nanášení textury na vykreslované povrchy.</li>
<li>Zapnutí (povolení) nanášení textur.</li>
<li>Vykreslení scény se zadanými texturovacími souřadnicemi pro každý vrchol.</li>
</ol>



<p><a name="k06"></a></p>
<h2 id="k06">6. Načtení textury z&nbsp;externího souboru</h2>

<pre>
import pyglet

image_stream = open("gnome-globe.png", "rb")
image = pyglet.image.load('gnome-globe.png', file=image_stream)
texture = image.get_texture()
</pre>



<p><a name="k07"></a></p>
<h2 id="k07">7. Nastavení parametrů textur a povolení texturování</h2>

<p>V&nbsp;knihovně OpenGL a nepřímo tedy i v&nbsp;Pygletu je možné parametry textur, tj. například způsob, jakým je textura mapována na povrch vykreslovaného tělesa, nastavit voláním funkce:</p>

<pre>
void glTexParameterf(
    GLenum  target,
    GLenum  pname,
    GLfloat value
);
</pre>

<p>popř.&nbsp;funkce:</p>

<pre>
void glTexParameteri(
    GLenum target,
    GLenum pname,
    GLint  value
);
</pre>

<p>V&nbsp;případě volání funkcí Pygletu z&nbsp;Pythonu se samozřejmě nemusíme zabývat explicitní specifikací typu parametrů, takže obě výše zmíněné funkce vypadají následovně:</p>

<pre>
def glTexParameterf(
    target,
    pname,
    value)
</pre>

<pre>
def glTexParameteri(
    target,
    pname,
    value)
</pre>

<p>První parametr (<strong>target</strong>) může podle zvolené dimenze textury nabývat hodnot <strong>GL_TEXTURE_1D</strong> (jednodimenzionální texura, tj. barevný přechod), <strong>GL_TEXTURE_2D</strong> (nejběžnější, rastrová textura) nebo <strong>GL_TEXTURE_3D</strong> (objemová textura). Hodnoty dalších dvou parametrů pname a value jsou uvedeny v&nbsp;následujícím seznamu:</p>

<table>
<tr><th>Parametr</th><th>Význam</th></tr>
<tr><td>GL_TEXTURE_WRAP_S</td><td>tímto parametrem specifikujeme, zda se má při překročení rozsahu texturovací souřadnice ve směru osy <i>s</i> provést opakování motivu na textuře nebo &bdquo;protažení&ldquo; první či poslední hodnoty. Opakování motivu na textuře je vhodné použít v&nbsp;případech, kdy zobrazujeme různé na sebe navazující motivy, například cihlové zdi, podlahy apod. Protažením textury lze v&nbsp;některých případech zamezit vizuálním artefaktům, které by se mohly objevit při napojování textur. Překročení rozsahu není tedy v&nbsp;žádném případě chybou.</td></tr>
<tr><td>GL_TEXTURE_WRAP_T</td><td>tento parametr má podobný význam jako parametr předchozí s&nbsp;tím rozdílem, že se místo na souřadnici ve směru osy <i>s</i> vztahuje na souřadnici ve směru osy <i>t</i>. U 1D textur nemá hodnota tohoto parametru vliv na zobrazení textury, použitelný je pouze u 2D a 3D textur. Opakování resp.&nbsp;protažení textury lze pro souřadnice ve směrech <i>s</i>, <i>t</i> a <i>r</i>.</td></tr>
<tr><td>GL_TEXTURE_WRAP_R</td><td>tento parametr má opět podobný význam jako předchozí dva parametry, ale vztahuje se na třetí souřadnici <i>r</i>, která je použita například u objemových textur.</td></tr>
<tr><td>GL_TEXTURE_MIN_FILTER</td><td>tímto parametrem je možné zvolit filtr použitý při zmenšování textury, tj.&nbsp;tehdy, jestliže na plochu jednoho vykreslovaného pixelu musíme použít barvy několika sousedních texelů.</td></tr>
<tr><td>GL_TEXTURE_MAX_FILTER</td><td>tímto parametrem se volí filtr použitý při zvětšování textury, tj.&nbsp;v případě, že vykreslovaný pixel obsahuje pouze malou plochu texelu.</td></tr>
</table>

<p>V&nbsp;další tabulce jsou uvedeny vztahy mezi parametry <strong>pname</strong> a <strong>value</strong>:</p>

<table>
<tr><th>Jméno parametru</th><th>Hodnota</th><th>Význam</th></tr>
<tr><td>GL_TEXTURE_WRAP_S</td><td>GL_REPEAT</td><td>opakování textury ve směru osy <i>s</i></td></tr>
<tr><td>GL_TEXTURE_WRAP_S</td><td>GL_CLAMP</td><td>protažení textury ve směru osy <i>s</i></td></tr>
<tr><td>GL_TEXTURE_WRAP_T</td><td>GL_REPEAT</td><td>opakování textury ve směru osy <i>t</i></td></tr>
<tr><td>GL_TEXTURE_WRAP_T</td><td>GL_CLAMP</td><td>protažení textury ve směru osy <i>t</i></td></tr>
<tr><td>GL_TEXTURE_WRAP_R</td><td>GL_REPEAT</td><td>opakování textury ve směru osy <i>r</i></td></tr>
<tr><td>GL_TEXTURE_WRAP_R</td><td>GL_CLAMP</td><td>protažení textury ve směru osy <i>r</i></td></tr>
<tr><td>GL_TEXTURE_MIN_FILTER</td><td>GL_NEAREST</td><td>nejjednodušší a nejrychlejší filtr, u tohoto filtru se barva vykreslovaného pixelu vypočte z&nbsp;barvy texelu, jehož souřadnice nejpřesněji odpovídají souřednicím zadaným do textury</td></tr>
<tr><td>GL_TEXTURE_MIN_FILTER</td><td>GL_LINEAR</td><td>sofistikovanější filtr, kdy se barva vykreslovaného pixelu spočítá pomocí bilineární interpolace z&nbsp;barev sousedních texelů</td></tr>
<tr><td>GL_TEXTURE_MIN_FILTER</td><td>GL_NEAREST_MIPMAP_NEAREST</td><td>sofistikovanější filtr, použití takzvaných mipmap</td></tr>
<tr><td>GL_TEXTURE_MIN_FILTER</td><td>GL_LINEAR_MIPMAP_NEAREST</td><td>sofistikovanější filtr, použití takzvaných mipmap</td></tr>
<tr><td>GL_TEXTURE_MIN_FILTER</td><td>GL_NEAREST_MIPMAP_LINEAR</td><td>sofistikovanější filtr, použití takzvaných mipmap</td></tr>
<tr><td>GL_TEXTURE_MAX_FILTER</td><td>GL_NEAREST</td><td>nejrychlejší způsob, použití nejbližšího texelu</td></tr>
<tr><td>GL_TEXTURE_MAX_FILTER</td><td>GL_LINEAR</td><td>použití lineárního či bilineárního filtru</td></tr>
</table>

<p>V&nbsp;prvním demonstračním příkladu, který bude uveden <a href="#k09">v&nbsp;deváté kapitole</a>, použijeme následující nastavení parametrů textury. Volání první funkce určuje způsob uložení (a dekódování) texelu v&nbsp;textuře:</p>

<pre>
glPixelStorei(GL_UNPACK_ALIGNMENT, 1)
glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_WRAP_S, GL_REPEAT)
glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_WRAP_T, GL_REPEAT)
glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MAG_FILTER, GL_NEAREST)
glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MIN_FILTER, GL_NEAREST)
</pre>

<p></p>

<pre>
glBindTexture(GL_TEXTURE_2D, texture.id)
</pre>

<p>Poslední krok je jednoduchý &ndash; pouze potřebujeme povolit texturování, tj.&nbsp;přepnout grafický akcelerátor do režimu, v&nbsp;němž texturovací jednotka pokrývá povrch těles jednotlivými texely:</p>

<pre>
glEnable(GL_TEXTURE_2D)
</pre>



<p><a name="k08"></a></p>
<h2 id="k08">8. Specifikace souřadnic v&nbsp;prostoru textury</h2>

<p></p>

<pre>
glBegin(GL_QUADS) 

glTexCoord2f(0.0, 0.0);
glVertex2i(x, y) 

glTexCoord2f(1.0, 0.0);
glVertex2i(x+150, y) 

glTexCoord2f(1.0, 1.0);
glVertex2i(x+150, y+150) 

glTexCoord2f(0.0, 1.0);
glVertex2i(x, y+150) 

glEnd() 
</pre>



<p><a name="k09"></a></p>
<h2 id="k09">9. První demonstrační příklad: převod rastrového obrázku na texturu</h2>

<p>Úplný zdrojový kód dnešního prvního demonstračního příkladu vypadá následovně:</p>

<pre>
#!/usr/bin/env python

import pyglet
from pyglet.gl import *

window = pyglet.window.Window(width=600,
                              height=250,
                              caption="Pyglet library")

image_stream = open("gnome-globe.png", "rb")
image = pyglet.image.load('gnome-globe.png', file=image_stream)
texture = image.get_texture()



def init():
    glClearColor(0.0, 0.0, 0.3, 0.0)          # barva pozadi obrazku
    glPolygonMode(GL_FRONT, GL_FILL)          # nastaveni rezimu vykresleni modelu
    glPolygonMode(GL_BACK, GL_FILL)
    glDisable(GL_CULL_FACE)                   # zadne hrany ani steny se nebudou odstranovat

    glPixelStorei(GL_UNPACK_ALIGNMENT, 1)
    glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_WRAP_S, GL_REPEAT)
    glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_WRAP_T, GL_REPEAT)
    glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MAG_FILTER, GL_NEAREST)
    glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MIN_FILTER, GL_NEAREST)
    glBindTexture(GL_TEXTURE_2D, texture.id)



@window.event
def on_resize(width, height):
    init()
    glViewport(0, 0, width, height)           # viditelna oblast pres cele okno



def draw_quad(x, y):
    glBegin(GL_QUADS) 

    glTexCoord2f(0.0, 0.0);
    glVertex2i(x, y) 

    glTexCoord2f(1.0, 0.0);
    glVertex2i(x+150, y) 

    glTexCoord2f(1.0, 1.0);
    glVertex2i(x+150, y+150) 

    glTexCoord2f(0.0, 1.0);
    glVertex2i(x, y+150) 

    glEnd() 


@window.event
def on_draw():
    glClear(GL_COLOR_BUFFER_BIT)              # vymazani vsech bitovych rovin barvoveho bufferu
    glLoadIdentity()
    glClearColor(0.0, 0.0, 0.0, 0.0)            # nastaveni mazaci barvy na cernou
    glClear(GL_COLOR_BUFFER_BIT)                # vymazani bitovych rovin barvoveho bufferu

    glEnable(GL_TEXTURE_2D)
    draw_quad(50, 50) 

    glDisable(GL_TEXTURE_2D)
    draw_quad(210, 50) 

    glEnable(GL_TEXTURE_2D)
    draw_quad(410, 50) 

pyglet.app.run()
</pre>



<p><a name="k10"></a></p>
<h2 id="k10">10. Nastavování parametrů textur</h2>



<p><a name="k11"></a></p>
<h2 id="k11">11. Druhý demonstrační příklad: nastavení způsobu opakování textur</h2>

<pre>
#!/usr/bin/env python

import pyglet
from pyglet.gl import *

window = pyglet.window.Window(width=500,
                              height=500,
                              caption="Pyglet library")

image_stream = open("gnome-globe.png", "rb")
image = pyglet.image.load('gnome-globe.png', file=image_stream)
texture = image.get_texture()



def init():
    glClearColor(0.0, 0.0, 0.3, 0.0)          # barva pozadi obrazku
    glPolygonMode(GL_FRONT, GL_FILL)          # nastaveni rezimu vykresleni modelu
    glPolygonMode(GL_BACK, GL_FILL)
    glDisable(GL_CULL_FACE)                   # zadne hrany ani steny se nebudou odstranovat

    glPixelStorei(GL_UNPACK_ALIGNMENT, 1)
    glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_WRAP_S, GL_REPEAT)
    glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_WRAP_T, GL_REPEAT)
    glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MAG_FILTER, GL_NEAREST)
    glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MIN_FILTER, GL_NEAREST)
    glBindTexture(GL_TEXTURE_2D, texture.id)



@window.event
def on_resize(width, height):
    init()
    glViewport(0, 0, width, height)           # viditelna oblast pres cele okno



def draw_quad(x, y):
    glBegin(GL_QUADS) 

    glTexCoord2f(0.0, 0.0);
    glVertex2i(x, y) 

    glTexCoord2f(2.0, 0.0);
    glVertex2i(x+400, y) 

    glTexCoord2f(2.0, 2.0);
    glVertex2i(x+400, y+400) 

    glTexCoord2f(0.0, 2.0);
    glVertex2i(x, y+400) 

    glEnd() 


@window.event
def on_draw():
    glClear(GL_COLOR_BUFFER_BIT)              # vymazani vsech bitovych rovin barvoveho bufferu
    glLoadIdentity()
    glClearColor(0.0, 0.0, 0.0, 0.0)            # nastaveni mazaci barvy na cernou
    glClear(GL_COLOR_BUFFER_BIT)                # vymazani bitovych rovin barvoveho bufferu

    glEnable(GL_TEXTURE_2D)
    draw_quad(50, 50) 

pyglet.app.run()
</pre>



<p><a name="k12"></a></p>
<h2 id="k12">12. Třetí demonstrační příklad: zrcadlení textur při opakování vzorku</h2>

<pre>
#!/usr/bin/env python

import pyglet
from pyglet.gl import *

window = pyglet.window.Window(width=500,
                              height=500,
                              caption="Pyglet library")

image_stream = open("gnome-globe.png", "rb")
image = pyglet.image.load('gnome-globe.png', file=image_stream)
texture = image.get_texture()



def init():
    glClearColor(0.0, 0.0, 0.3, 0.0)          # barva pozadi obrazku
    glPolygonMode(GL_FRONT, GL_FILL)          # nastaveni rezimu vykresleni modelu
    glPolygonMode(GL_BACK, GL_FILL)
    glDisable(GL_CULL_FACE)                   # zadne hrany ani steny se nebudou odstranovat

    glPixelStorei(GL_UNPACK_ALIGNMENT, 1)
    glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_WRAP_S, GL_MIRRORED_REPEAT)
    glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_WRAP_T, GL_MIRRORED_REPEAT)
    glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MAG_FILTER, GL_NEAREST)
    glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MIN_FILTER, GL_NEAREST)
    glBindTexture(GL_TEXTURE_2D, texture.id)



@window.event
def on_resize(width, height):
    init()
    glViewport(0, 0, width, height)           # viditelna oblast pres cele okno



def draw_quad(x, y):
    glBegin(GL_QUADS) 

    glTexCoord2f(0.0, 0.0);
    glVertex2i(x, y) 

    glTexCoord2f(2.0, 0.0);
    glVertex2i(x+400, y) 

    glTexCoord2f(2.0, 2.0);
    glVertex2i(x+400, y+400) 

    glTexCoord2f(0.0, 2.0);
    glVertex2i(x, y+400) 

    glEnd() 


@window.event
def on_draw():
    glClear(GL_COLOR_BUFFER_BIT)              # vymazani vsech bitovych rovin barvoveho bufferu
    glLoadIdentity()
    glClearColor(0.0, 0.0, 0.0, 0.0)            # nastaveni mazaci barvy na cernou
    glClear(GL_COLOR_BUFFER_BIT)                # vymazani bitovych rovin barvoveho bufferu

    glEnable(GL_TEXTURE_2D)
    draw_quad(50, 50) 

pyglet.app.run()
</pre>



<p><a name="k13"></a></p>
<h2 id="k13">13. Chování texturovacího engine při přibližování a vzdalování textur</h2>



<p><a name="k14"></a></p>
<h2 id="k14">14. Čtvrtý demonstrační příklad: výběr nejbližšího texelu</h2>

<pre>
#!/usr/bin/env python

import pyglet
from pyglet.gl import *

window = pyglet.window.Window(width=500,
                              height=500,
                              caption="Pyglet library")

image_stream = open("gnome-globe.png", "rb")
image = pyglet.image.load('gnome-globe.png', file=image_stream)
texture = image.get_texture()



def init():
    glClearColor(0.0, 0.0, 0.3, 0.0)          # barva pozadi obrazku
    glPolygonMode(GL_FRONT, GL_FILL)          # nastaveni rezimu vykresleni modelu
    glPolygonMode(GL_BACK, GL_FILL)
    glDisable(GL_CULL_FACE)                   # zadne hrany ani steny se nebudou odstranovat

    glPixelStorei(GL_UNPACK_ALIGNMENT, 1)
    glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MAG_FILTER, GL_NEAREST)
    glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MIN_FILTER, GL_NEAREST)
    glBindTexture(GL_TEXTURE_2D, texture.id)



@window.event
def on_resize(width, height):
    init()
    glViewport(0, 0, width, height)           # viditelna oblast pres cele okno



def draw_quad(x, y):
    glBegin(GL_QUADS) 

    glTexCoord2f(0.4, 0.4);
    glVertex2i(x, y) 

    glTexCoord2f(0.6, 0.4);
    glVertex2i(x+400, y) 

    glTexCoord2f(0.6, 0.6);
    glVertex2i(x+400, y+400) 

    glTexCoord2f(0.4, 0.6);
    glVertex2i(x, y+400) 

    glEnd() 


@window.event
def on_draw():
    glClear(GL_COLOR_BUFFER_BIT)              # vymazani vsech bitovych rovin barvoveho bufferu
    glLoadIdentity()
    glClearColor(0.0, 0.0, 0.0, 0.0)            # nastaveni mazaci barvy na cernou
    glClear(GL_COLOR_BUFFER_BIT)                # vymazani bitovych rovin barvoveho bufferu

    glEnable(GL_TEXTURE_2D)
    draw_quad(50, 50) 

pyglet.app.run()
</pre>



<p><a name="k15"></a></p>
<h2 id="k15">15. Pátý demonstrační příklad: použití bilineárního filtru</h2>

<pre>
#!/usr/bin/env python

import pyglet
from pyglet.gl import *

window = pyglet.window.Window(width=500,
                              height=500,
                              caption="Pyglet library")

image_stream = open("gnome-globe.png", "rb")
image = pyglet.image.load('gnome-globe.png', file=image_stream)
texture = image.get_texture()



def init():
    glClearColor(0.0, 0.0, 0.3, 0.0)          # barva pozadi obrazku
    glPolygonMode(GL_FRONT, GL_FILL)          # nastaveni rezimu vykresleni modelu
    glPolygonMode(GL_BACK, GL_FILL)
    glDisable(GL_CULL_FACE)                   # zadne hrany ani steny se nebudou odstranovat

    glPixelStorei(GL_UNPACK_ALIGNMENT, 1)
    glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MAG_FILTER, GL_LINEAR)
    glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MIN_FILTER, GL_LINEAR)
    glBindTexture(GL_TEXTURE_2D, texture.id)



@window.event
def on_resize(width, height):
    init()
    glViewport(0, 0, width, height)           # viditelna oblast pres cele okno



def draw_quad(x, y):
    glBegin(GL_QUADS) 

    glTexCoord2f(0.4, 0.4);
    glVertex2i(x, y) 

    glTexCoord2f(0.6, 0.4);
    glVertex2i(x+400, y) 

    glTexCoord2f(0.6, 0.6);
    glVertex2i(x+400, y+400) 

    glTexCoord2f(0.4, 0.6);
    glVertex2i(x, y+400) 

    glEnd() 


@window.event
def on_draw():
    glClear(GL_COLOR_BUFFER_BIT)              # vymazani vsech bitovych rovin barvoveho bufferu
    glLoadIdentity()
    glClearColor(0.0, 0.0, 0.0, 0.0)            # nastaveni mazaci barvy na cernou
    glClear(GL_COLOR_BUFFER_BIT)                # vymazani bitovych rovin barvoveho bufferu

    glEnable(GL_TEXTURE_2D)
    draw_quad(50, 50) 

pyglet.app.run()
</pre>



<p><a name="k16"></a></p>
<h2 id="k16">16. Šestý demonstrační příklad: nanesení textury na stěny 3D tělesa</h2>

<pre>
#!/usr/bin/env python

import pyglet
from pyglet.gl import *
from pyglet.window import key

fov = 70.0                                    # hodnota zorneho uhlu - field of view
nearPlane = 0.1                               # blizsi orezavaci rovina
farPlane = 90.0                               # vzdalenejsi orezavaci rovina

r1 = 0.0
r2 = 0.0

depthBufferEnabled = False                    # povoleni ci zakaz Z-bufferu
texturesEnabled = False                       # povoleni ci zakaz textur

window = pyglet.window.Window(width=500,
                              height=500,
                              caption="Pyglet library")

image_stream = open("gnome-globe.png", "rb")
image = pyglet.image.load('gnome-globe.png', file=image_stream)
texture = image.get_texture()

keys = key.KeyStateHandler()
window.push_handlers(keys)



def init():
    glClearColor(0.0, 0.0, 0.3, 0.0)          # barva pozadi obrazku
    glPolygonMode(GL_FRONT, GL_FILL)          # nastaveni rezimu vykresleni modelu
    glPolygonMode(GL_BACK, GL_FILL)
    glDisable(GL_CULL_FACE)                   # zadne hrany ani steny se nebudou odstranovat
    glDepthFunc(GL_LESS)                      # funkce pro testovani fragmentu

    glPixelStorei(GL_UNPACK_ALIGNMENT, 1)
    glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MAG_FILTER, GL_LINEAR)
    glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MIN_FILTER, GL_LINEAR)
    glBindTexture(GL_TEXTURE_2D, texture.id)



@window.event
def on_resize(width, height):
    init()
    glViewport(0, 0, width, height)           # viditelna oblast pres cele okno



def draw_walls():
    glBegin(GL_QUADS)                         # vykresleni otevrene krychle - sten domecku
    glColor3f(0.0, 0.0, 1.0)                  # modra barva steny
    glTexCoord2f(0.0, 0.0)
    glVertex3f(-5.0, -5.0, -5.0)
    glTexCoord2f(0.7, 0.0)
    glVertex3f(-5.0, -5.0,  5.0)
    glTexCoord2f(0.7, 0.7)
    glVertex3f( 5.0, -5.0,  5.0)
    glTexCoord2f(0.0, 0.7)
    glVertex3f( 5.0, -5.0, -5.0)

    glColor3f(0.0, 1.0, 0.0)                  # zelena barva steny
    glTexCoord2f(0.0, 0.0)
    glVertex3f(-5.0,  5.0, -5.0)
    glTexCoord2f(0.7, 0.0)
    glVertex3f(-5.0,  5.0,  5.0)
    glTexCoord2f(0.7, 0.7)
    glVertex3f( 5.0,  5.0,  5.0)
    glTexCoord2f(0.0, 0.7)
    glVertex3f( 5.0,  5.0, -5.0)

    glColor3f(1.0, 0.0, 0.0)                  # cervena barva steny
    glTexCoord2f(0.0, 0.0)
    glVertex3f(-5.0, -5.0, -5.0)
    glTexCoord2f(0.7, 0.0)
    glVertex3f(-5.0, -5.0,  5.0)
    glTexCoord2f(0.7, 0.7)
    glVertex3f(-5.0,  5.0,  5.0)
    glTexCoord2f(0.0, 0.7)
    glVertex3f(-5.0,  5.0, -5.0)

    glColor3f(1.0, 1.0, 0.0)                  # zluta barva steny
    glTexCoord2f(0.0, 0.0)
    glVertex3f( 5.0, -5.0, -5.0)
    glTexCoord2f(0.7, 0.0)
    glVertex3f( 5.0, -5.0,  5.0)
    glTexCoord2f(0.7, 0.7)
    glVertex3f( 5.0,  5.0,  5.0)
    glTexCoord2f(0.0, 0.7)
    glVertex3f( 5.0,  5.0, -5.0)
    glEnd()



def draw_roof():
    glBegin(GL_TRIANGLES)                      # vykresleni strechy domecku z trojuhelniku
    glColor3f(0.0, 1.0, 1.0)
    glTexCoord2f(0.0, 0.0)
    glVertex3f(-5.0,  5.0, -5.0)
    glTexCoord2f(0.7, 0.0)
    glVertex3f( 5.0,  5.0, -5.0)
    glTexCoord2f(0.7, 0.7)
    glVertex3f( 0.0, 11.0,  0.0)
 
    glColor3f(1.0, 0.0, 1.0)
    glTexCoord2f(0.0, 0.0)
    glVertex3f( 5.0,  5.0, -5.0)
    glTexCoord2f(0.7, 0.0)
    glVertex3f( 5.0,  5.0,  5.0)
    glTexCoord2f(0.7, 0.7)
    glVertex3f( 0.0, 11.0,  0.0)
 
    glColor3f(1.0, 1.0, 1.0)
    glTexCoord2f(0.0, 0.0)
    glVertex3f( 5.0,  5.0,  5.0)
    glTexCoord2f(0.7, 0.0)
    glVertex3f(-5.0,  5.0,  5.0)
    glTexCoord2f(0.7, 0.7)
    glVertex3f( 0.0, 11.0,  0.0)
 
    glColor3f(0.0, 0.0, 0.0)
    glTexCoord2f(0.0, 0.0)
    glVertex3f(-5.0,  5.0,  5.0)
    glTexCoord2f(0.7, 0.0)
    glVertex3f(-5.0,  5.0, -5.0)
    glTexCoord2f(0.7, 0.7)
    glVertex3f( 0.0, 11.0,  0.0)
    glEnd()



def set_depth_buffer(depthBufferEnabled):
    if depthBufferEnabled:
        glEnable(GL_DEPTH_TEST)
    else:
        glDisable(GL_DEPTH_TEST)



def clear_buffers(depthBufferEnabled):
    if depthBufferEnabled:
        glClear(GL_COLOR_BUFFER_BIT | GL_DEPTH_BUFFER_BIT) # vymazani i Z/W bufferu
    else:
        glClear(GL_COLOR_BUFFER_BIT)          # vymazani vsech bitovych rovin barvoveho bufferu



@window.event
def on_draw():
    global r1, r2
    global depthBufferEnabled
    global texturesEnabled

    if keys[key.LEFT]:
        r2 = r2 - 1
    if keys[key.RIGHT]:
        r2 = r2 + 1
    if keys[key.UP]:
        r1 = r1 - 1
    if keys[key.DOWN]:
        r1 = r1 + 1
    if keys[key.Z]:
        depthBufferEnabled = not depthBufferEnabled
    if keys[key.T]:
        texturesEnabled = not texturesEnabled


    clear_buffers(depthBufferEnabled)
    set_depth_buffer(depthBufferEnabled)

    glMatrixMode(GL_PROJECTION)               # zacatek modifikace projekcni matice
    glLoadIdentity()                          # vymazani projekcni matice (=identita)
    gluPerspective(fov, 1.0, nearPlane, farPlane);

    glMatrixMode(GL_MODELVIEW)
    glLoadIdentity()                          # nahrat jednotkovou matici

    gluLookAt(4.0, 6.0, 18.0,                 # bod, odkud se kamera diva
              0.0, 2.0,  0.0,                 # bod, kam se kamera diva
              0.0, 1.0,  0.0)                 # poloha "stropu" ve scene

    glRotatef(r1, 1.0, 0.0, 0.0)              # rotace objektu
    glRotatef(r2, 0.0, 1.0, 0.0) 

    if texturesEnabled:
        glEnable(GL_TEXTURE_2D)
    else:
        glDisable(GL_TEXTURE_2D)

    draw_walls()
    draw_roof()



pyglet.app.run()
</pre>



<p><a name="k17"></a></p>
<h2 id="k17">17. Repositář s&nbsp;demonstračními příklady</h2>

<p>Všechny dnes popsané demonstrační příklady byly uloženy do Git repositáře dostupného na adrese <a href="https://github.com/tisnik/presentations">https://github.com/tisnik/presentations</a>. Příklady si můžete v&nbsp;případě potřeby stáhnout i jednotlivě bez nutnosti klonovat celý repositář. Pro jejich spuštění je nutné mít nainstalovanou jak knihovnu Pyglet, tak i podpůrné grafické knihovny OpenGL a GLU (což se většinou provede automaticky v&nbsp;rámci instalace balíčku s&nbsp;Pygletem, viz též <a href="https://mojefedora.cz/multimedialni-knihovna-pyglet/">úvodní díl tohoto seriálu</a>):</p>

<table>
<tr><th>Příklad</th><th>Odkaz</th></tr>
<tr><td>36_textures.py</td><td><a href="https://github.com/tisnik/presentations/blob/master/pyglet/36_textures.py">https://github.com/tisnik/presentations/blob/master/pyglet/36_textures.py</a></td></tr>
<tr><td>37_texture_wrapping.py</td><td><a href="https://github.com/tisnik/presentations/blob/master/pyglet/37_texture_wrapping.py">https://github.com/tisnik/presentations/blob/master/pyglet/37_texture_wrapping.py</a></td></tr>
<tr><td>38_texture_mirror.py</td><td><a href="https://github.com/tisnik/presentations/blob/master/pyglet/38_texture_mirror.py">https://github.com/tisnik/presentations/blob/master/pyglet/38_texture_mirror.py</a></td></tr>
<tr><td>39_texture_magnification.py</td><td><a href="https://github.com/tisnik/presentations/blob/master/pyglet/39_texture_magnification.py">https://github.com/tisnik/presentations/blob/master/pyglet/39_texture_magnification.py</a></td></tr>
<tr><td>40_texture_smooth.py</td><td><a href="https://github.com/tisnik/presentations/blob/master/pyglet/40_texture_smooth.py">https://github.com/tisnik/presentations/blob/master/pyglet/40_texture_smooth.py</a></td></tr>
<tr><td>41_texture_on_3d.py</td><td><a href="https://github.com/tisnik/presentations/blob/master/pyglet/41_texture_on_3d.py">https://github.com/tisnik/presentations/blob/master/pyglet/41_texture_on_3d.py</a></td></tr>
</table>



<p><a name="k18"></a></p>
<h2 id="k18">18. Odkazy na Internetu</h2>

<ol>

<li>Pyglet Home Page<br />
<a href="https://bitbucket.org/pyglet/pyglet/wiki/Home">https://bitbucket.org/pyglet/pyglet/wiki/Home</a>
</li>

<li>Dokumentace k verzi 1.2<br />
<a href="https://pyglet.readthedocs.io/en/pyglet-1.2-maintenance/">https://pyglet.readthedocs.io/en/pyglet-1.2-maintenance/</a>
</li>

<li>Dokumentace k verzi 1.2 ve formátu PDF<br />
<a href="https://readthedocs.org/projects/pyglet/downloads/pdf/pyglet-1.2-maintenance/">https://readthedocs.org/projects/pyglet/downloads/pdf/pyglet-1.2-maintenance/</a>
</li>

<li>PyOpenGL<br />
<a href="http://pyopengl.sourceforge.net/">http://pyopengl.sourceforge.net/</a>
</li>

<li>The #! magic, details about the shebang/hash-bang mechanism on various Unix flavours<br />
<a href="https://www.in-ulm.de/~mascheck/various/shebang/">https://www.in-ulm.de/~mascheck/various/shebang/</a>
</li>

<li>Shebang (Unix)<br />
<a href="https://en.wikipedia.org/wiki/Shebang_%28Unix%29">https://en.wikipedia.org/wiki/Shebang_%28Unix%29</a>
</li>

<li>Domovská stránka systému LÖVE<br />
<a href="http://love2d.org/">http://love2d.org/</a>
</li>

<li>Simple DirectMedia Layer (home page)<br />
<a href="http://www.libsdl.org/">http://www.libsdl.org/</a>
</li>

<li>Simple DirectMedia Layer (Wikipedia)<br />
<a href="https://en.wikipedia.org/wiki/Simple_DirectMedia_Layer">https://en.wikipedia.org/wiki/Simple_DirectMedia_Layer</a>
</li>

<li>Seriál Grafická knihovna OpenGL<br />
<a href="https://www.root.cz/serialy/graficka-knihovna-opengl/">https://www.root.cz/serialy/graficka-knihovna-opengl/</a>
</li>

<li>Pyglet event loop<br />
<a href="http://pyglet.readthedocs.io/en/latest/programming_guide/eventloop.html">http://pyglet.readthedocs.io/en/latest/programming_guide/eventloop.html</a>
</li>

<li>Decorators I: Introduction to Python Decorators<br />
<a href="http://www.artima.com/weblogs/viewpost.jsp?thread=240808">http://www.artima.com/weblogs/viewpost.jsp?thread=240808</a>
</li>

<li>3D Programming in Python - Part 1 <br />
<a href="https://greendalecs.wordpress.com/2012/04/21/3d-programming-in-python-part-1/">https://greendalecs.wordpress.com/2012/04/21/3d-programming-in-python-part-1/</a>
</li>

<li>A very basic Pyglet tutorial<br />
<a href="http://www.natan.termitnjak.net/tutorials/pyglet_basic.html">http://www.natan.termitnjak.net/tutorials/pyglet_basic.html</a>
</li>

<li>Alpha blending<br />
<a href="https://en.wikipedia.org/wiki/Alpha_compositing#Alpha_blending">https://en.wikipedia.org/wiki/Alpha_compositing#Alpha_blending</a>
</li>

</ol>



<p></p><p></p>
<p><small>Autor: <a href="http://www.fit.vutbr.cz/~tisnovpa">Pavel Tišnovský</a> &nbsp; 2017</small></p>
</body>
</html>

