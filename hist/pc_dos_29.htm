<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
        "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html>
<head>
<title>Od reálného režimu k režimu chráněnému na procesorech 80286 a 80386 (1.část)</title>
<meta name="Author" content="Pavel Tisnovsky" />
<meta name="Generator" content="vim" />
<meta http-equiv="content-type" content="text/html; charset=utf-8" />
<style type="text/css">
         body {color:#000000; background:#ffffff;}
         h1  {font-family: arial, helvetica, sans-serif; color:#ffffff; background-color:#c00000; text-align:center; padding-left:1em}
         h2  {font-family: arial, helvetica, sans-serif; color:#ffffff; background-color:#0000c0; padding-left:1em; text-align:left}
         h3  {font-family: arial, helvetica, sans-serif; color:#000000; background-color:#c0c0c0; padding-left:1em; text-align:left}
         h4  {font-family: arial, helvetica, sans-serif; color:#000000; background-color:#e0e0e0; padding-left:1em; text-align:left}
         a   {font-family: arial, helvetica, sans-serif;}
         li  {font-family: arial, helvetica, sans-serif; color:#000000; text-align:justify; width:450px;}
         ol  {font-family: arial, helvetica, sans-serif; color:#000000; text-align:justify; width:450px;}
         ul  {font-family: arial, helvetica, sans-serif; color:#000000; text-align:justify; width:450px;}
         p   {font-family: arial, helvetica, sans-serif; color:#000000; text-align:justify;}
         pre {background:#e0e0e0}
</style>
</head>

<body>

<h1>Od reálného režimu k režimu chráněnému na procesorech 80286 a 80386 (1.část)</h1>

<h3>Pavel Tišnovský</h3>

<p></p>

<h1>Úvodník</h1>

<p>Dnes se seznámíme s dalšími vlastnostmi čipů 80286 a 80386, které souvisí s reálným režimem, nereálným (unreal) režimem a režimem chráněným. Zabývat se totiž budeme cachí s deskriptory segmentů, jenž se kupodivu projevuje i v reálném režimu.</p>



<h2>Obsah</h2>

<p><a href="#k01">1. Od reálného režimu k&nbsp;režimu chráněnému na procesorech 80286 a 80386</a></p>
<p><a href="#k02">2. Šestnáctibitové adresy v&nbsp;reálném režimu</a></p>
<p><a href="#k03">3. Šestnáctibitové adresy na čipech druhé a třetí generace 80x86</a></p>
<p><a href="#k04">4. Rozepsání programové smyčky pro blokový přenos mezi dvěma segmenty</a></p>
<p><a href="#k05">5. Offset přesahující hranici segmentu</a></p>
<p><a href="#k06">6. Druhý příklad s&nbsp;offsetem, který přesahuje hranice segmentu</a></p>
<p><a href="#k07">7. Chování mikroprocesoru Intel 80386 v&nbsp;reálném režimu</a></p>
<p><a href="#k08">8. Skrytá část 80286: cache s&nbsp;deskriptory segmentů</a></p>
<p><a href="#k09">9. Cache s&nbsp;deskriptory segmentů v&nbsp;reálném režimu</a></p>
<p><a href="#k10">10. 32bitové adresy v&nbsp;reálném režimu</a></p>
<p><a href="#k11">11. Deskriptory segmentů na čipech 80386</a></p>
<p><a href="#k12">12. Ukázka adresace 32bitovými registry v&nbsp;reálném režimu</a></p>
<p><a href="#k13">13. Rozepsání programové smyčky: přenos po 32bitech, offsety jsou realizovány 32bitovými registry</a></p>
<p><a href="#k14">14. Přístup do obrazové paměti přes segment 0x0000 a 32bitový offset</a></p>
<p><a href="#k15">15. Překročení limitu segmentu s&nbsp;využitím posunu adresy o konstantu</a></p>
<p><a href="#k16">16. Naplnění cache s&nbsp;deskriptory přes &bdquo;utajenou&ldquo; instrukci <strong>LOADALL</strong></a></p>
<p><a href="#k17">17. <strong>LOADALL</strong> na mikroprocesorech 80286</a></p>
<p><a href="#k18">18. <strong>LOADALL</strong> na mikroprocesorech 80386</a></p>
<p><a href="#k19">19. Repositář s&nbsp;demonstračními příklady</a></p>
<p><a href="#k20">20. Odkazy na Internetu</a></p>



<p><a name="k01"></a></p>
<h2 id="k01">1. Od reálného režimu k&nbsp;režimu chráněnému na procesorech 80286 a 80386</h2>

<p><a
href="https://www.root.cz/clanky/640k-by-melo-stacit-kazdemu-skutecne/">V&nbsp;předchozím
článku</a> o nechvalně známém limitu 640kB RAM dostupné v&nbsp;operačním
systému DOS jsme se zmínili o některých technikách, které vývojářům umožňovaly
tuto bariéru překročit a využít tak celou dostupnou paměť počítače vybaveného
mikroprocesory Intel 80286 a Intel 80386 [*]. Tyto techniky (kromě využití
<i>HMA</i>, což nám však přidalo jen 65530 bajtů) nějakým způsobem musely
pracovat s&nbsp;novým subsystémem mikroprocesorů &ndash; konkrétně se
subsystémem určeným pro provozování mikroprocesorů v&nbsp;takzvaném chráněném
režimu (<i>protected mode</i>). A &ndash; jako obvykle &ndash; se i v&nbsp;této
oblasti nacházela spousta pastí, ať již způsobených snahou o zpětnou
kompatibilitu, tak i &bdquo;optimalizacemi&ldquo; a opomenutími na straně
návrhu mikroprocesorů. Na druhou stranu však bylo možné využít různé triky a
celý koncept chráněného režimu vhodným způsobem ohnout; tak, že se větší
množství operační paměti dalo využít i v&nbsp;režimu reálném.</p>

<p><div class="rs-tip-major">Poznámka: stále budu psát Intel 80286 a Intel
80386, i když existovali i další výrobci těchto mikroprocesorů. Ti však
(tehdy!) nabízeli čipy plně kompatibilní s&nbsp;Intelem na úrovni instrukcí i
podporovaných režimů. A i když se mohlo jednat o rychlejší mikroprocesory
(Am386DX na 40MHz, IBM 386SLC s&nbsp;větší cache), tito sekundární výrobci
stále jen následovali Intel, což se změnilo až mnohem později.</div></p>

<p>Ještě před tím, než si ukážeme možnosti chráněného režimu, je vhodné si
zopakovat, jak se vlastně mikroprocesory chovaly v&nbsp;režimu reálném
z&nbsp;pohledu adresování paměti. Protože i v&nbsp;běžném reálném režimu se
dají využít některé vlastnosti režimu chráněného &ndash; jedná se o takzvané
nereálné režimy (<i>unreal mode</i>), což ve skutečnosti nejsou nové režimy
činnosti mikroprocesoru, ale ohnutí vlastností subsystému určeného pro chráněný
režim.</p>

<p><div class="rs-tip-major">Poznámka: v&nbsp;článku budu postupovat odlišně,
než to bývalo v&nbsp;dokumentaci běžné. Nepopíšu totiž ihned všechny vlastnosti
chráněného režimu; to je zbytečně velký skok. Nejdříve se seznámíme
s&nbsp;konceptem <i>deskriptorů</i>, které lze docela dobře použít i
v&nbsp;režimu reálném a provádět různé (řekněme neoficiální) triky
s&nbsp;pamětí. S&nbsp;touto problematikou souvisí i instrukce
<strong>LOADALL</strong> (ve dvou variantách), na níž nelze v&nbsp;souvislosti
s&nbsp;čipy 80286 a 80386 zapomenout.</div></p>



<p><a name="k02"></a></p>
<h2 id="k02">2. Šestnáctibitové adresy v&nbsp;reálném režimu</h2>

<p>Vraťme se na chvíli k&nbsp;prapůvodním čipům Intel 8086/8088. Připomeňme si,
že tyto čipy měly vyvedených jen dvacet adresových vodičů a dokázaly tak
adresovat přesně 1MB paměti. Výpočet adresy probíhal na základě kombinace
<i>segmentu</i> a <i>offsetu</i>:</p>

<pre>
adresa = segment &times; 16 + offset
</pre>

<p>Jenže to není přesná (resp.&nbsp;ucelená) informace. Je nutno dodat, jakým
způsobem byl vypočítán <i>offset</i>. Mikroprocesory Intel 8086/8088 totiž
podporovaly tyto adresovací režimy:</p>

<table>
<tr><th>Použitý zápis v&nbsp;assembleru</th><th>Adresovací režim</th></tr>
<tr><td>přímá adresa (16bit) </td><td>displacement/direct</td></tr>
<tr><td>&nbsp;</td><td>&nbsp;</td></tr>
<tr><td>[BX]</td><td>register indirect</td></tr>
<tr><td>[SI]</td><td>register indirect</td></tr>
<tr><td>[DI]</td><td>register indirect</td></tr>
<tr><td>&nbsp;</td><td>&nbsp;</td></tr>
<tr><td>[BX+SI]</td><td>based indexed mode</td></tr>
<tr><td>[BX+DI]</td><td>based indexed mode</td></tr>
<tr><td>[BP+SI]</td><td>based indexed mode</td></tr>
<tr><td>[BP+DI]</td><td>based indexed mode</td></tr>
<tr><td>&nbsp;</td><td>&nbsp;</td></tr>
<tr><td>[BP+offset_8_bit]</td><td>based mode</td></tr>
<tr><td>[BX+offset_8_bit]</td><td>based mode</td></tr>
<tr><td>[SI+offset_8_bit]</td><td>indexed mode</td></tr>
<tr><td>[DI+offset_8_bit]</td><td>indexed mode</td></tr>
<tr><td>&nbsp;</td><td>&nbsp;</td></tr>
<tr><td>[BP+offset_16_bit]</td><td>based mode</td></tr>
<tr><td>[BX+offset_16_bit]</td><td>based mode</td></tr>
<tr><td>[SI+offset_16_bit]</td><td>indexed mode</td></tr>
<tr><td>[DI+offset_16_bit]</td><td>indexed mode</td></tr>
<tr><td>&nbsp;</td><td>&nbsp;</td></tr>
<tr><td>[BX+SI+offset_8_bit]</td><td>based indexed displacement</td></tr>
<tr><td>[BX+DI+offset_8_bit]</td><td>based indexed displacement</td></tr>
<tr><td>[BP+SI+offset_8_bit]</td><td>based indexed displacement</td></tr>
<tr><td>[BP+DI+offset_8_bit]</td><td>based indexed displacement</td></tr>
<tr><td>&nbsp;</td><td>&nbsp;</td></tr>
<tr><td>[BX+SI+offset_16_bit]</td><td>based indexed displacement</td></tr>
<tr><td>[BX+DI+offset_16_bit]</td><td>based indexed displacement</td></tr>
<tr><td>[BP+SI+offset_16_bit]</td><td>based indexed displacement</td></tr>
<tr><td>[BP+DI+offset_16_bit]</td><td>based indexed displacement</td></tr>
</table>

<p>Co to znamená v&nbsp;praxi? Řekněme, že v&nbsp;segmentovém registru
<strong>DS</strong> bude uložena nula a v&nbsp;registru <strong>BX</strong>
bude uložena hodnota 0x8000. Následně použijeme instrukci:</p>

<pre>
mov DS:[BX+0x8001], AL
</pre>

<p>Otázka zní, do jaké fyzické buňky RAM se uloží obsah registru
<strong>AL</strong>? Máme dvě možnosti výpočtu. Triviální dosazení do vzorce
pro výpočet adresy by vedlo k&nbsp;výpočtu:</p>

<pre>
0x0000 &times; 16 + 0x8000 + 0x8000 = 0x10000
</pre>

<p>Ovšem můžeme si také uvědomit, že sčítačka pro offsety je realizována
v&nbsp;16bitové ALU a tedy proběhne spíše něco takového:</p>

<pre>
0x0000 &times; 16 + (0x8000 + 0x8000) &amp; 0xffff = 0x00000
</pre>

<p>Ve skutečnosti je správný druhý výpočet, protože <i>offset</i> je na čipech
Intel 8086/8088 vždy šestnáctibitový. To znamená, že veškeré výpočty offsetu
uvedené v&nbsp;předchozí tabulce za všech předpokladů vedou k&nbsp;hodnotám
v&nbsp;rozsahu 0x0000 až 0xffff a nikdy tedy nepřekročíme velikost
segmentu.</p>

<p><div class="rs-tip-major">Poznámka: tato vlastnost sice přímo vychází
s&nbsp;interní realizace výpočtů adresy na čipech 8086/8088, ovšem později
musela být emulována.</div></p>



<p><a name="k03"></a></p>
<h2 id="k03">3. Šestnáctibitové adresy na čipech druhé a třetí generace 80x86</h2>

<p>Mikroprocesory druhé a třetí generace 80x86, tedy jak 80286, tak i 80386,
sice interně počítají adresy odlišnými obvody, ovšem stále platí, že když se
výpočty offsetu provádí se šestnáctibitovými registry (a pouze za tohoto
předpokladu), bude výsledný offset vždy ležet v&nbsp;rozsahu 0x0000 až 0xffff,
tedy v&nbsp;rámci jediného segmentu. Ostatně si tuto vlastnost ukážeme na
demonstračních příkladech, které budou své výsledky zobrazovat ve vizuální
podobě.</p>

<p>Připomeňme si, že v&nbsp;grafickém režimu 13h karty VGA začíná obrazová
paměť na segmentu 0xa000 a má velikost 320&times;200=64000 bajtů. Můžeme tedy
snadno realizovat blokový přenos obrázku z&nbsp;RAM do VideoRAM, a to tak, že
zdrojová data budou adresována přes dvojici registrů DS:SI (SI=<i>source
index</i>) a cílová adresa bude uložena ve dvojici ES:DI (DI=<i>destination
index</i>):</p>

<pre>
        mov ax, cs
        mov ds, ax
        mov si, image       <i>; nyni dvojice DS:SI obsahuje adresu prvniho bajtu v obrazku</i>
&nbsp;
        mov ax, 0xa000      <i>; (lze i PUSH 0xa000 + POP ES)</i>
	mov es, ax
        xor di, di          <i>; nyni dvojice ES:DI obsahuje adresu prvniho pixelu ve video RAM   </i>
&nbsp;
        mov cx, 320*200/2   <i>; pocet zapisovanych 16bitovych slov (=dvojic pixelu)</i>
</pre>

<p>Samotný blokový přenos zajistí instrukce <strong>REP MOVSW</strong>, která
používá <strong>CX</strong> ve funkci počitadla a postupně zvyšuje indexové
registry <strong>SI</strong> a <strong>DI</strong>:</p>

<pre>
	rep movsw           <i>; prenos celeho obrazku po 16bitovych slovech </i>
</pre>

<p>Výsledkem by měl být celý obrázek (64000 bajtů) přenesený do obrazové
paměti:</p>

<a href="https://i.iinfo.cz/images/422/pc-18-1.webp"><img src="https://i.iinfo.cz/images/422/pc-18-1-prev.webp" class="image-1161168" width="360" height="270" data-prev-filename="https://i.iinfo.cz/images/422/pc-18-1-prev.webp" data-prev-width="360" data-prev-height="270" data-large-filename="https://i.iinfo.cz/images/422/pc-18-1-large.webp" data-large-width="700" data-large-height="525" alt="&#160;" title="Autor: tisnik + Intel 80386&#160;Reference Programmer's&#160;Manual, podle licence: &lt;a href=&quot;http://en.wikipedia.org/wiki/Rights_Managed&quot;&gt;Rights Managed&lt;/a&gt;" /></a>
<p><i>Obrázek 1: Výsledek přenosu celého obrázku do obrazové paměti.</i></p>

<p>Úplný zdrojový kód tohoto demonstračního příkladu vypadá následovně:</p>

<pre>
<i>; Graficky rezim karty VGA s rozlisenim 320x200 pixelu.</i>
<i>; Vykresleni rastroveho obrazku s explicitnim prenosem po dvou bajtech.</i>
<i>; Pro blokovy prenos se pouziva instrukce REP MOVSW</i>
<i>;</i>
<i>;-----------------------------------------------------------------------------</i>
&nbsp;
BITS 16         <i>; 16bitovy vystup pro DOS</i>
CPU  286        <i>; specifikace pouziteho instrukcniho souboru</i>
&nbsp;
<i>;-----------------------------------------------------------------------------</i>
&nbsp;
<i>; ukonceni procesu a navrat do DOSu</i>
%macro <strong>exit</strong> 0
        mov     ah, 0x4c    <i>; cislo sluzby DOSu</i>
        int     0x21        <i>; zavolani sluzby DOSu</i>
%endmacro
&nbsp;
<i>; vyprazdneni bufferu klavesnice a cekani na klavesu</i>
%macro <strong>wait_key</strong> 0
        xor     ax, ax      <i>; cislo sluzby BIOSu</i>
        int     0x16        <i>; zavolani sluzby BIOSu</i>
%endmacro
&nbsp;
<i>; nastaveni grafickeho rezimu</i>
%macro <strong>gfx_mode</strong> 1
        mov     ah, 0       <i>; cislo sluzby VGA BIOSu</i>
        mov     al, %1      <i>; cislo grafickeho rezimu</i>
        int     0x10        <i>; zavolani sluzby BIOSu</i>
%endmacro
&nbsp;
<i>; paleta ve stupnich sedi</i>
%macro <strong>grayscale_palette</strong> 0
        mov ax, 0x1010      <i>; cislo sluzby a podsluzby VGA BIOSu</i>
        xor bl, bl          <i>; index barvy</i>
next_dac:
        mov ch, bl          <i>; prvni barvova slozka</i>
        shr ch, 1
        shr ch, 1
        mov cl, ch          <i>; druha barvova slozka</i>
        mov dh, ch          <i>; treti barvova slozka</i>
        int 0x10            <i>; modifikace mapovani v DAC</i>
        inc bl              <i>; zvysit index v DAC</i>
        jnz next_dac        <i>; nastavit dalsi barvu, dokud nedosahneme hodnoty 256</i>
%endmacro
&nbsp;
<i>;-----------------------------------------------------------------------------</i>
org  0x100        <i>; zacatek kodu pro programy typu COM (vzdy se zacina na 256)</i>
&nbsp;
<strong>start</strong>:
        gfx_mode 0x13       <i>; nastaveni rezimu 320x200 s 256 barvami</i>
        grayscale_palette   <i>; nastaveni palety se stupni sedi</i>
&nbsp;
        mov ax, cs
        mov ds, ax
        mov si, image       <i>; nyni dvojice DS:SI obsahuje adresu prvniho bajtu v obrazku</i>
&nbsp;
        mov ax, 0xa000      <i>; (lze i PUSH 0xa000 + POP ES)</i>
	mov es, ax
        xor di, di          <i>; nyni dvojice ES:DI obsahuje adresu prvniho pixelu ve video RAM   </i>
&nbsp;
        mov cx, 320*200/2   <i>; pocet zapisovanych 16bitovych slov (=dvojic pixelu)</i>
	rep movsw           <i>; prenos celeho obrazku po 16bitovych slovech </i>
&nbsp;
        wait_key            <i>; cekani na stisk klavesy</i>
        exit                <i>; navrat do DOSu</i>
&nbsp;
<i>; pridani binarnich dat s rastrovym obrazkem</i>
<strong>image</strong>:
    incbin "image_320x200.bin"
</pre>



<p><a name="k04"></a></p>
<h2 id="k04">4. Rozepsání programové smyčky pro blokový přenos mezi dvěma segmenty</h2>

<p>Blokový přenos byl <a href="#k03">v&nbsp;předchozím příkladu</a> realizován
jedinou instrukcí:</p>

<pre>
	rep movsw           <i>; prenos celeho obrazku po 16bitovych slovech </i>
</pre>

<p>Tuto instrukci si pro další účely můžeme rozepsat do programové smyčky,
v&nbsp;níž se postupně načítají šestnáctibitová slova z&nbsp;adresy DS:[SI] a
ukládají se na adresu ES:[DI] tak, jak to již bylo popsáno. Indexové registry
se zvyšují o dvojku, protože přenos provádím po šestnácti bitech a nikoli po
osmi bitech. A nakonec instrukce <strong>LOOP</strong> snižuje počitadlo
v&nbsp;CX a provádí skok v&nbsp;případě, že se ještě nedosáhlo nuly:</p>

<pre>
<strong>move_loop</strong>:                  <i>; prenos celeho obrazku po 16bitovych slovech</i>
	mov ax, ds:[si]     <i>; nacteni dvou bajtu</i>
	mov es:[di], ax     <i>; ulozeni dvou bajtu</i>
	add si, 2           <i>; posun offsetu</i>
	add di, 2
	loop move_loop      <i>; opakujeme</i>
</pre>

<p>Výsledkem bude naprosto stejný obrázek, i když samotný blokový přenos bude
pomalejší (to ovšem bez profileru nepoznáme):</p>

<a href="https://i.iinfo.cz/images/422/pc-18-2.webp"><img src="https://i.iinfo.cz/images/422/pc-18-2-prev.webp" class="image-1161171" width="360" height="270" data-prev-filename="https://i.iinfo.cz/images/422/pc-18-2-prev.webp" data-prev-width="360" data-prev-height="270" data-large-filename="https://i.iinfo.cz/images/422/pc-18-2-large.webp" data-large-width="700" data-large-height="525" alt="&#160;" title="Autor: tisnik + Intel 80386&#160;Reference Programmer's&#160;Manual, podle licence: &lt;a href=&quot;http://en.wikipedia.org/wiki/Rights_Managed&quot;&gt;Rights Managed&lt;/a&gt;" /></a>
<p><i>Obrázek 2: Výsledek blokového přenosu by měl být naprosto totožný
s&nbsp;prvním obrázkem.</i></p>

<p>Opět si pro úplnost ukažme celý zdrojový kód tohoto příkladu:</p>

<pre>
<i>; Graficky rezim karty VGA s rozlisenim 320x200 pixelu.</i>
<i>; Vykresleni rastroveho obrazku s explicitnim prenosem po dvou bajtech.</i>
<i>; Pro blokovy prenos se pouziva programova smycka</i>
<i>;-----------------------------------------------------------------------------</i>
&nbsp;
BITS 16         <i>; 16bitovy vystup pro DOS</i>
CPU  286        <i>; specifikace pouziteho instrukcniho souboru</i>
&nbsp;
<i>;-----------------------------------------------------------------------------</i>
&nbsp;
<i>; ukonceni procesu a navrat do DOSu</i>
%macro <strong>exit</strong> 0
        mov     ah, 0x4c    <i>; cislo sluzby DOSu</i>
        int     0x21        <i>; zavolani sluzby DOSu</i>
%endmacro
&nbsp;
<i>; vyprazdneni bufferu klavesnice a cekani na klavesu</i>
%macro <strong>wait_key</strong> 0
        xor     ax, ax      <i>; cislo sluzby BIOSu</i>
        int     0x16        <i>; zavolani sluzby BIOSu</i>
%endmacro
&nbsp;
<i>; nastaveni grafickeho rezimu</i>
%macro <strong>gfx_mode</strong> 1
        mov     ah, 0       <i>; cislo sluzby VGA BIOSu</i>
        mov     al, %1      <i>; cislo grafickeho rezimu</i>
        int     0x10        <i>; zavolani sluzby BIOSu</i>
%endmacro
&nbsp;
<i>; paleta ve stupnich sedi</i>
%macro <strong>grayscale_palette</strong> 0
        mov ax, 0x1010      <i>; cislo sluzby a podsluzby VGA BIOSu</i>
        xor bl, bl          <i>; index barvy</i>
next_dac:
        mov ch, bl          <i>; prvni barvova slozka</i>
        shr ch, 1
        shr ch, 1
        mov cl, ch          <i>; druha barvova slozka</i>
        mov dh, ch          <i>; treti barvova slozka</i>
        int 0x10            <i>; modifikace mapovani v DAC</i>
        inc bl              <i>; zvysit index v DAC</i>
        jnz next_dac        <i>; nastavit dalsi barvu, dokud nedosahneme hodnoty 256</i>
%endmacro
&nbsp;
<i>;-----------------------------------------------------------------------------</i>
org  0x100        <i>; zacatek kodu pro programy typu COM (vzdy se zacina na 256)</i>
&nbsp;
<strong>start</strong>:
        gfx_mode 0x13       <i>; nastaveni rezimu 320x200 s 256 barvami</i>
        grayscale_palette   <i>; nastaveni palety se stupni sedi</i>
&nbsp;
        mov ax, cs
        mov ds, ax
        mov si, image       <i>; nyni dvojice DS:SI obsahuje adresu prvniho bajtu v obrazku</i>
&nbsp;
        mov ax, 0xa000      <i>; (lze i PUSH 0xa000 + POP ES)</i>
	mov es, ax
        xor di, di          <i>; nyni dvojice ES:DI obsahuje adresu prvniho pixelu ve video RAM   </i>
&nbsp;
        mov cx, 320*200/2   <i>; pocet zapisovanych 16bitovych slov (=dvojic pixelu)</i>
&nbsp;
<strong>move_loop</strong>:                  <i>; prenos celeho obrazku po 16bitovych slovech</i>
	mov ax, ds:[si]     <i>; nacteni dvou bajtu</i>
	mov es:[di], ax     <i>; ulozeni dvou bajtu</i>
	add si, 2           <i>; posun offsetu</i>
	add di, 2
	loop move_loop      <i>; opakujeme</i>
&nbsp;
        wait_key            <i>; cekani na stisk klavesy</i>
        exit                <i>; navrat do DOSu</i>
&nbsp;
<i>; pridani binarnich dat s rastrovym obrazkem</i>
<strong>image</strong>:
    incbin "image_320x200.bin"
</pre>



<p><a name="k05"></a></p>
<h2 id="k05">5. Offset přesahující hranici segmentu</h2>

<p>V&nbsp;obou předchozích příkladech ležela první cílová adresa na začátku
segmentu 0xa000. Konkrétně segmentový registr ES obsahoval hodnotu 0xa000
(segment) a registr DI nulu:</p>

<pre>
        mov ax, 0xa000      <i>; (lze i PUSH 0xa000 + POP ES)</i>
	mov es, ax
        xor di, di          <i>; nyni dvojice ES:DI obsahuje adresu prvniho pixelu ve video RAM   </i>
</pre>

<p>Co se však stane v&nbsp;případě, že nastavíme segmentový registr na hodnotu
0x9800 a budeme ukládat data s&nbsp;offsetem 0x8000? Nejdříve nastavíme
segmentový registr:</p>

<pre>
        mov ax, 0x9800
	mov es, ax
        xor di, di          <i>; nyni ES:DI obsahuje adresu Video RAM-32kB</i>
</pre>

<p>A následně upravíme programovou smyčku tak, aby se k&nbsp;obsahu registru DI
přidal ještě offset 0x8000:</p>

<pre>
<strong>move_loop</strong>:                     <i>; prenos celeho obrazku po 16bitovych slovech</i>
	mov ax, ds:[si]        <i>; nacteni dvou bajtu</i>
	mov es:[di+0x8000], ax <i>; ulozeni dvou bajtu, ovsem musime se posunouto 32kB nahoru</i>
	add si, 2              <i>; posun offsetu</i>
	add di, 2
	loop move_loop         <i>; opakujeme</i>
</pre>

<p>Výsledný obrázek naznačuje, co se stalo. První polovina obrázku byla
přenesena bez problémů, protože DI+0x8000 vracel <i>šestnáctibitovou</i>
hodnotu menší než 0x10000 (tedy hodnotu ležící v&nbsp;segmentu 0x9800), ovšem
druhá polovina byla přenesena nikoli do obrazové paměti, ale na začátek
segmentu 0x9800 (což bychom dělat neměli &ndash; nevíme, co se zde
nachází!).</p>

<a href="https://i.iinfo.cz/images/422/pc-18-3.webp"><img src="https://i.iinfo.cz/images/422/pc-18-3-prev.webp" class="image-1161174" width="360" height="270" data-prev-filename="https://i.iinfo.cz/images/422/pc-18-3-prev.webp" data-prev-width="360" data-prev-height="270" data-large-filename="https://i.iinfo.cz/images/422/pc-18-3-large.webp" data-large-width="700" data-large-height="525" alt="&#160;" title="Autor: tisnik + Intel 80386&#160;Reference Programmer's&#160;Manual, podle licence: &lt;a href=&quot;http://en.wikipedia.org/wiki/Rights_Managed&quot;&gt;Rights Managed&lt;/a&gt;" /></a>
<p><i>Obrázek 3: Do VideoRAM se přenesla jen polovina obrázku, druhá polovina
je &bdquo;ztracena&ldquo; v&nbsp;adresovém rozsahu 0x98000 až 0x9ffff.</i></p>

<p>Platí tedy, že i když se segmenty 0x9800 a 0xa000 částečně (přesně
polovinou) svého adresového prostoru překrývají, nemůžeme je jednoduše zaměnit
s&nbsp;tím, že použijeme vhodně upravený offset &ndash; tento offset totiž
nikdy nepřekročí šestnáctibitový rozsah.</p>

<p>Úplný zdrojový kód tohoto příkladu:</p>

<pre>
<i>; Graficky rezim karty VGA s rozlisenim 320x200 pixelu.</i>
<i>; Vykresleni rastroveho obrazku s explicitnim prenosem po dvou bajtech.</i>
<i>; Pro blokovy prenos se pouziva programova smycka</i>
<i>;-----------------------------------------------------------------------------</i>
&nbsp;
BITS 16         <i>; 16bitovy vystup pro DOS</i>
CPU  286        <i>; specifikace pouziteho instrukcniho souboru</i>
&nbsp;
<i>;-----------------------------------------------------------------------------</i>
&nbsp;
<i>; ukonceni procesu a navrat do DOSu</i>
%macro <strong>exit</strong> 0
        mov     ah, 0x4c    <i>; cislo sluzby DOSu</i>
        int     0x21        <i>; zavolani sluzby DOSu</i>
%endmacro
&nbsp;
<i>; vyprazdneni bufferu klavesnice a cekani na klavesu</i>
%macro <strong>wait_key</strong> 0
        xor     ax, ax      <i>; cislo sluzby BIOSu</i>
        int     0x16        <i>; zavolani sluzby BIOSu</i>
%endmacro
&nbsp;
<i>; nastaveni grafickeho rezimu</i>
%macro <strong>gfx_mode</strong> 1
        mov     ah, 0       <i>; cislo sluzby VGA BIOSu</i>
        mov     al, %1      <i>; cislo grafickeho rezimu</i>
        int     0x10        <i>; zavolani sluzby BIOSu</i>
%endmacro
&nbsp;
<i>; paleta ve stupnich sedi</i>
%macro <strong>grayscale_palette</strong> 0
        mov ax, 0x1010      <i>; cislo sluzby a podsluzby VGA BIOSu</i>
        xor bl, bl          <i>; index barvy</i>
next_dac:
        mov ch, bl          <i>; prvni barvova slozka</i>
        shr ch, 1
        shr ch, 1
        mov cl, ch          <i>; druha barvova slozka</i>
        mov dh, ch          <i>; treti barvova slozka</i>
        int 0x10            <i>; modifikace mapovani v DAC</i>
        inc bl              <i>; zvysit index v DAC</i>
        jnz next_dac        <i>; nastavit dalsi barvu, dokud nedosahneme hodnoty 256</i>
%endmacro
&nbsp;
<i>;-----------------------------------------------------------------------------</i>
org  0x100        <i>; zacatek kodu pro programy typu COM (vzdy se zacina na 256)</i>
&nbsp;
<strong>start</strong>:
        gfx_mode 0x13       <i>; nastaveni rezimu 320x200 s 256 barvami</i>
        grayscale_palette   <i>; nastaveni palety se stupni sedi</i>
&nbsp;
        mov ax, cs
        mov ds, ax
        mov si, image       <i>; nyni dvojice DS:SI obsahuje adresu prvniho bajtu v obrazku</i>
&nbsp;
        mov ax, 0x9800
	mov es, ax
        xor di, di          <i>; nyni ES:DI obsahuje adresu Video RAM-32kB</i>
&nbsp;
        mov cx, 320*200/2      <i>; pocet zapisovanych 16bitovych slov (=dvojic pixelu)</i>
&nbsp;
<strong>move_loop</strong>:                     <i>; prenos celeho obrazku po 16bitovych slovech</i>
	mov ax, ds:[si]        <i>; nacteni dvou bajtu</i>
	mov es:[di+0x8000], ax <i>; ulozeni dvou bajtu, ovsem musime se posunouto 32kB nahoru</i>
	add si, 2              <i>; posun offsetu</i>
	add di, 2
	loop move_loop         <i>; opakujeme</i>
&nbsp;
        wait_key            <i>; cekani na stisk klavesy</i>
        exit                <i>; navrat do DOSu</i>
&nbsp;
<i>; pridani binarnich dat s rastrovym obrazkem</i>
<strong>image</strong>:
    incbin "image_320x200.bin"
</pre>



<p><a name="k06"></a></p>
<h2 id="k06">6. Druhý příklad s&nbsp;offsetem, který přesahuje hranice segmentu</h2>

<p>Možná ještě názornější bude následující demonstrační příklad, v&nbsp;němž
budeme barvy pixelů ukládat do segmentu 0xa000, tedy skutečně přímo do obrazové
paměti:</p>

<pre>
        mov ax, 0xa000
	mov es, ax
        xor di, di          <i>; nyni ES:DI obsahuje adresu Video RAM+32kB</i>
</pre>

<p>Nicméně si zvolíme posun o 320&times;100 bajtů od začátku segmentu
s&nbsp;Video RAM, což znamená, že první vykreslený pixel bude začínat na
začátku stého prvního řádku:</p>

<pre>
<strong>move_loop</strong>:                     <i>; prenos celeho obrazku po 16bitovych slovech</i>
	mov ax, ds:[si]        <i>; nacteni dvou bajtu</i>
posun equ 320*100              <i>; vypocet posunu o 100 obrazovych radku</i>
	mov es:[di+posun], ax  <i>; ulozeni dvou bajtu s posunem</i>
	add si, 2              <i>; posun offsetu</i>
	add di, 2
	loop move_loop         <i>; opakujeme</i>
</pre>

<p>Výsledek bude následující &ndash; do spodní poloviny obrazovky se vykreslí
prvních 100 řádků rastrového obrázku. Dalších 1536 pixelů se vykreslí do
neviditelné části RAM (mezi offsety 64000 až 65535) a zbylé pixely (cca 95
obrazových řádků) &bdquo;přetečou&ldquo; na začátek obrazovky:</p>

<a href="https://i.iinfo.cz/images/422/pc-18-4.webp"><img src="https://i.iinfo.cz/images/422/pc-18-4-prev.webp" class="image-1161177" width="360" height="270" data-prev-filename="https://i.iinfo.cz/images/422/pc-18-4-prev.webp" data-prev-width="360" data-prev-height="270" data-large-filename="https://i.iinfo.cz/images/422/pc-18-4-large.webp" data-large-width="700" data-large-height="525" alt="&#160;" title="Autor: tisnik + Intel 80386&#160;Reference Programmer's&#160;Manual, podle licence: &lt;a href=&quot;http://en.wikipedia.org/wiki/Rights_Managed&quot;&gt;Rights Managed&lt;/a&gt;" /></a>
<p><i>Obrázek 4: Vykreslované pixely, pokud jsou ukládány do segmentu 0xa000,
nikdy nepřekročí hranice Video RAM. Po dosažení konce segmentu se pixely začnou
zapisovat opět od jeho začátku.</i></p>

<p>Opět jsme tedy nedokázali překročit hranici jednoho segmentu.</p>

<pre>
<i>; Graficky rezim karty VGA s rozlisenim 320x200 pixelu.</i>
<i>; Vykresleni rastroveho obrazku s explicitnim prenosem po dvou bajtech.</i>
<i>; Pro blokovy prenos se pouziva programova smycka, ovsem pro posunuty segment.</i>
<i>;-----------------------------------------------------------------------------</i>
&nbsp;
BITS 16         <i>; 16bitovy vystup pro DOS</i>
CPU  286        <i>; specifikace pouziteho instrukcniho souboru</i>
&nbsp;
<i>;-----------------------------------------------------------------------------</i>
&nbsp;
<i>; ukonceni procesu a navrat do DOSu</i>
%macro <strong>exit</strong> 0
        mov     ah, 0x4c    <i>; cislo sluzby DOSu</i>
        int     0x21        <i>; zavolani sluzby DOSu</i>
%endmacro
&nbsp;
<i>; vyprazdneni bufferu klavesnice a cekani na klavesu</i>
%macro <strong>wait_key</strong> 0
        xor     ax, ax      <i>; cislo sluzby BIOSu</i>
        int     0x16        <i>; zavolani sluzby BIOSu</i>
%endmacro
&nbsp;
<i>; nastaveni grafickeho rezimu</i>
%macro <strong>gfx_mode</strong> 1
        mov     ah, 0       <i>; cislo sluzby VGA BIOSu</i>
        mov     al, %1      <i>; cislo grafickeho rezimu</i>
        int     0x10        <i>; zavolani sluzby BIOSu</i>
%endmacro
&nbsp;
<i>; paleta ve stupnich sedi</i>
%macro <strong>grayscale_palette</strong> 0
        mov ax, 0x1010      <i>; cislo sluzby a podsluzby VGA BIOSu</i>
        xor bl, bl          <i>; index barvy</i>
next_dac:
        mov ch, bl          <i>; prvni barvova slozka</i>
        shr ch, 1
        shr ch, 1
        mov cl, ch          <i>; druha barvova slozka</i>
        mov dh, ch          <i>; treti barvova slozka</i>
        int 0x10            <i>; modifikace mapovani v DAC</i>
        inc bl              <i>; zvysit index v DAC</i>
        jnz next_dac        <i>; nastavit dalsi barvu, dokud nedosahneme hodnoty 256</i>
%endmacro
&nbsp;
<i>;-----------------------------------------------------------------------------</i>
org  0x100        <i>; zacatek kodu pro programy typu COM (vzdy se zacina na 256)</i>
&nbsp;
<strong>start</strong>:
        gfx_mode 0x13       <i>; nastaveni rezimu 320x200 s 256 barvami</i>
        grayscale_palette   <i>; nastaveni palety se stupni sedi</i>
&nbsp;
        mov ax, cs
        mov ds, ax
        mov si, image       <i>; nyni dvojice DS:SI obsahuje adresu prvniho bajtu v obrazku</i>
&nbsp;
        mov ax, 0xa000
	mov es, ax
        xor di, di          <i>; nyni ES:DI obsahuje adresu Video RAM+32kB</i>
&nbsp;
        mov cx, 320*200/2      <i>; pocet zapisovanych 16bitovych slov (=dvojic pixelu)</i>
&nbsp;
<strong>move_loop</strong>:                     <i>; prenos celeho obrazku po 16bitovych slovech</i>
	mov ax, ds:[si]        <i>; nacteni dvou bajtu</i>
posun equ 320*100              <i>; vypocet posunu o 100 obrazovych radku</i>
	mov es:[di+posun], ax  <i>; ulozeni dvou bajtu s posunem</i>
	add si, 2              <i>; posun offsetu</i>
	add di, 2
	loop move_loop         <i>; opakujeme</i>
&nbsp;
        wait_key            <i>; cekani na stisk klavesy</i>
        exit                <i>; navrat do DOSu</i>
&nbsp;
<i>; pridani binarnich dat s rastrovym obrazkem</i>
<strong>image</strong>:
    incbin "image_320x200.bin"
</pre>



<p><a name="k07"></a></p>
<h2 id="k07">7. Chování mikroprocesoru Intel 80386 v&nbsp;reálném režimu</h2>

<p>Po krátkém (ale jak dále uvidíme, tak důležitém) zopakování způsobu
adresování mikroprocesorů Intel 8086/8088 se přeneseme o pár let dále,
konkrétně k&nbsp;čipům 80386. Víme již, že tyto čipy nabízely programátorům
další dva segmentové registry FS a GS, což bude důležité zejména
v&nbsp;chráněném režimu. Ovšem pro nás zajímavější je fakt, že se rozšířily
všechny pracovní registry ze šestnácti bitů na 32 bitů:</p>

<table>
<tr><th>32bitový registr</th><th>Spodních 16 bitů</th><th>Rozdělení horní/dolní bajt</th><th>Funkce registru</th></tr>
<tr><td>EAX</td><td>AX</td><td>AH/AL</td><td>akumulátor</td></tr>
<tr><td>EBX</td><td>BX</td><td>BH/BL</td><td>bázový registr</td></tr>
<tr><td>ECX</td><td>CX</td><td>CH/CL</td><td>čítač</td></tr>
<tr><td>EDX</td><td>DX</td><td>DH/DL</td><td>datový registr</td></tr>
<tr><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td></tr>
<tr><td>ESP</td><td>SP</td><td>&nbsp;</td><td>ukazatel na vrchol zásobníku</td></tr>
<tr><td>EBP</td><td>BP</td><td>&nbsp;</td><td>báze zásobníkového rámce</td></tr>
<tr><td>ESI</td><td>SI</td><td>&nbsp;</td><td>indexový registr pro zdroj dat</td></tr>
<tr><td>EDI</td><td>DI</td><td>&nbsp;</td><td>indexový registr pro cíl dat</td></tr>
<tr><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td></tr>
<tr><td>EIP</td><td>IP</td><td>&nbsp;</td><td>ukazatel na prováděnou instrukci</td></tr>
</table>

<p>Co to znamená v&nbsp;praxi? Nyní můžeme při adresování používat 32bitové
offsety, a to i v&nbsp;reálném 16bitovém režimu! A i výpočet offsetu probíhá
s&nbsp;využitím <a
href="https://en.wikipedia.org/wiki/I386#/media/File:80386DX_arch.png">32bitové
sčítačky</a> a nikoli sčítačky 16bitové. Znamená to tedy, že konečně můžeme
překročit hranici 1MB a vlastně adresovat až 4GB RAM? Tak jednoduché nám to
Intel neudělal, a to kvůli jedné prozatím nezmíněné vlastnosti 80286, která
byla přenesena i do čipu 80386. Takže se v&nbsp;následující kapitole ještě
jednou vraťme k&nbsp;80286.</p>



<p><a name="k08"></a></p>
<h2 id="k08">8. Skrytá část 80286: cache s&nbsp;deskriptory segmentů</h2>

<p>V&nbsp;předchozím článku jsme si mj.&nbsp;řekli, že mikroprocesory 80286
byly prvními čipy z&nbsp;rodiny 80x86, které implementovaly chráněný režim
(<i>protected mode</i>). V&nbsp;tomto novém režimu, do kterého se ale musely
mikroprocesory explicitně přepnout, se změnilo adresování, zejména část
týkající se segmentu. Nyní totiž hodnota uložená v&nbsp;segmentovém registru
nespecifikovala přímou adresu (resp.&nbsp;její část), ale (poněkud zjednodušeně
řečeno) index to tabulky deskriptorů (<i>descriptor table</i>). Tato tabulka
obsahovala takzvané <i>deskriptory</i>, přičemž pro každý deskriptor bylo
vyhrazeno osm bajtů, z&nbsp;nichž bylo ovšem na 80286 využito jen šest bajtů.
Prozatím nás nebudou zajímat podrobnosti, jak přesně jsou hodnoty
v&nbsp;tabulce deskriptorů uloženy, ale alespoň si řekněme, jaké informace
každý deskriptor obsahuje:</p>

<table>
<tr><th>Označení</th><th>Počet bitů</th><th>Stručný popis</th></tr>
<tr><td>Base</td><td>24</td><td>adresa začátku segmentu kdekoli v&nbsp;prostoru 16MB</td></tr>
<tr><td>Limits</td><td>16</td><td>velikost segmentu (lze mít menší segment než 64kB)</td></tr>
<tr><td>Control bits</td><td>6</td><td>řízení práv k&nbsp;segmentu</td></tr>
<tr><td>DPL</td><td>2</td><td>úroveň oprávnění 0-3 (tzv.&nbsp;ring)</td></tr>
</table>

<p>Samozřejmě by nebylo efektivní, aby se při <i>každém</i> přístupu do paměti
četlo těchto šest bajtů stále z&nbsp;tabulky deskriptorů. A ani to nebylo
nutné, protože pokud každý záznam odpovídal hodnotě segmentu, bylo možné pro
každou <i>aktuálně</i> používanou hodnotu segmentu uložit oněch šest bajtů do
interních registrů mikroprocesoru &ndash; a na 80286 byly k&nbsp;dispozici
čtyři segmentové registry, takže mikroprocesor musel obsahovat pouze 4&times;6
bajtů interní cache s&nbsp;hodnotami deskriptorů. Ovšem kvůli potřebám
chráněného režimu (aby nebylo možné ochranu obejít) by tyto interní registry
neměly být přístupné programátorům.</p>



<p><a name="k09"></a></p>
<h2 id="k09">9. Cache s&nbsp;deskriptory segmentů v&nbsp;reálném režimu</h2>

<p>Proč se však o deskriptorech zmiňujeme v&nbsp;souvislosti s&nbsp;běžným
reálným režimem? Ukazuje se totiž, že tato cache má vliv i v&nbsp;reálném
režimu, což je dosti překvapující, ale jedná se o vlastnost, která se projeví
zejména u třetí generace 80x86. Na mikroprocesorech Intel 80286 se
v&nbsp;reálném režimu (podle dostupných informací! &ndash; nejedná se totiž o
oficiálně zdokumentované chování) využívá z&nbsp;každého ze čtyř deskriptorů
bitové pole <i>limits</i>. V&nbsp;této šestnáctibitové hodnotě je uložena
maximální hodnota <i>platného</i> offsetu. Co to znamená v&nbsp;praxi? Pokud by
tato hodnota byla nastavena na řekněme 0x7fff, znamenalo by to, že se daný
segment resp.&nbsp;jeho adresovatelná část, zmenší na offsety od 0x0000 do
0x7fff (včetně), zatímco při přístupu na offset 0x8000 až 0xffff dojde
k&nbsp;výjimce typu General protection fault (kterou však nemá v&nbsp;čistém
DOSu kdo zpracovat!).</p>

<a href="https://i.iinfo.cz/images/422/pc-18-5.webp"><img src="https://i.iinfo.cz/images/422/pc-18-5-prev.webp" class="image-1161180" width="370" height="167" data-prev-filename="https://i.iinfo.cz/images/422/pc-18-5-prev.webp" data-prev-width="370" data-prev-height="167" data-large-filename="https://i.iinfo.cz/images/422/pc-18-5-large.webp" data-large-width="720" data-large-height="325" alt="&#160;" title="Autor: tisnik + Intel 80386&#160;Reference Programmer's&#160;Manual, podle licence: &lt;a href=&quot;http://en.wikipedia.org/wiki/Rights_Managed&quot;&gt;Rights Managed&lt;/a&gt;" /></a>
<p><i>Obrázek 5: Výjimky dokážou zachytit takzvané DOS extendery; což ovšem
platí pro programy pracující v&nbsp;chráněném režimu.</i></p>

<p>To je ovšem problematické chování, protože čipy 80286 vlastně nejsou zpětně
kompatibilní s&nbsp;původní řadou 8086. Aby se zachovalo zdání kompatibility,
jsou v&nbsp;průběhu inicializace 80286 limity všech čtyř deskriptorů uložených
v&nbsp;cache nastaveny na hodnotu 0xffff, takže se na první pohled zdá vše
v&nbsp;pořádku, protože i 80286 dodržuje vlastnost zmíněnou výše &ndash;
výpočty offsetů probíhají v&nbsp;šestnácti bitech a nikdy tedy nedokážou
překročit právě onu hodnotu 0xffff.</p>



<p><a name="k10"></a></p>
<h2 id="k10">10. 32bitové adresy v&nbsp;reálném režimu</h2>

<p><a href="#k09">V&nbsp;předchozí kapitole</a> jsme si naznačili, že za cenu
jistého úsilí se Intelu podařilo zachovat zdání, že reálný režim je stále ten
&bdquo;starý dobrý&ldquo; reálný režim. Ale na další problémy již bylo zaděláno
&ndash; a to ve chvíli, kdy se v&nbsp;rámci čipu 80386 přešlo na 32bitové
offsetové registry (resp.&nbsp;všechny pracovní registry byly rozšířeny na
32bitů, včetně registrů použitých pro výpočet offsetu). Nastala totiž tato
otázka &ndash; jak se má čip <i>přesně</i> chovat ve chvíli, kdy se provádí
následující instrukce:</p>

<pre>
mov ax, [ebx + 0x12345678]
</pre>

<img src="https://i.iinfo.cz/images/422/pc-18-6.webp" class="image-1161183" width="640" height="300" alt="&#160;" title="Autor: tisnik + Intel 80386&#160;Reference Programmer's&#160;Manual, podle licence: &lt;a href=&quot;http://en.wikipedia.org/wiki/Rights_Managed&quot;&gt;Rights Managed&lt;/a&gt;" />
<p><i>Obrázek 6: Schéma výpočtu adresy vypadalo skvěle: konečně můžeme využít
celých 4GB a se stránkováním ještě více. Praxe bývala odlišná.<br />Zdroj:
Intel 80386 Reference Programmer's Manual</i></p>

<p>Bylo možné definovat několik různých scénářů chování:</p>

<ol>
<li>Specifikuje se, že z&nbsp;32bitových registrů se použije jen spodních 16 bitů a totéž pro konstanty</li>
<li>Specifikuje se, že se v&nbsp;případě, že jakákoli část adresy přesáhne 16 bitů, vyhodí výjimka</li>
<li>Specifikuje se, že se v&nbsp;případě, že výsledný offset přesáhne 16 bitů, vyhodí výjimka</li>
<li>Ponechá se 32bitové chování (tedy něco, čeho lze dosáhnout <i>nereálným režimem</i>)</li>
</ol>

<p>Vybrána nakonec byla druhá možnost, což znamenalo, že onen skvělý nový
(drahý) čip, který byl v&nbsp;reklamách označován za 32bitovou revoluci, se
stále v&nbsp;DOSu (a v&nbsp;mnoha překladačích) choval jako 80286. Navíc se
přidala nová vlastnost, na kterou mohli narazit programátoři, kteří si přáli
využít &bdquo;dlouhé 32bitové adresy&ldquo; &ndash; při překročení hranice 64kB
došlo buď k&nbsp;zamrznutí systému, nebo k&nbsp;jinému problému, a to
v&nbsp;závislosti na konkrétní konfiguraci (zda je použit správce paměti, zda
běží nějaký extender atd.).</p>



<p><a name="k11"></a></p>
<h2 id="k11">11. Deskriptory segmentů na čipech 80386</h2>

<p>I na čipech 80386 je v&nbsp;chráněném režimu použita tabulka deskriptorů. A
opět platí, že přímo v&nbsp;mikroprocesorech 80386 existuje cache pro
deskriptory odpovídající všem segmentovým registrům. Nyní je těchto deskriptorů
šest a nikoli jen čtyři, a to z&nbsp;toho důvodu, že kromě původních
segmentových registrů CS, DS, ES a SS byly přidány i dva nové segmentové
registry nazvané FS a GS.</p>

<p>To je ovšem spíše kosmetická změna. Důležitější je, že nyní má deskriptor
obsazených všech osm bajtů a nikoli jen šest bajtů. Proč tomu tak je? Zvětšil
se počet bitů pro bázovou adresu segmentu, a to na plných 32 bitů (rozsah 4GB
&ndash; opět je zde prostor pro novou A32 GATE namísto původní A20 GATE :-). A
taktéž se zvětšil počet bitů pro limit, a to z&nbsp;původních 16 bitů
(maximální limit 0xffff) na 20 bitů, ovšem s&nbsp;tím, že se namísto bajtů může
limit nastavit i v&nbsp;celých stránkách (to se přepíná dalším bitem).</p>

<img src="https://i.iinfo.cz/images/422/pc-18-7.webp" class="image-1161186" width="640" height="420" alt="&#160;" title="Autor: tisnik + Intel 80386&#160;Reference Programmer's&#160;Manual, podle licence: &lt;a href=&quot;http://en.wikipedia.org/wiki/Rights_Managed&quot;&gt;Rights Managed&lt;/a&gt;" />
<p><i>Obrázek 7: Ze struktury bitových polí deskriptorů je patrné, jak se nové bity přidávaly k&nbsp;bitům definovaným již u čipů 80286<br />Zdroj:
Intel 80386 Reference Programmer's Manual</i></p>

<p>Důležité je, že se limity opět projeví i v&nbsp;reálném režimu a Intel
zachoval původní hodnotu limitů &ndash; tedy je zde zapsána hodnota 0xffff.
V&nbsp;praxi to tedy znamená, že překročení velikosti offsetu nad tuto hranici
dojde k&nbsp;výjimce a tím pádem (obecně) k&nbsp;pádu aplikace pracující
v&nbsp;reálném režimu.</p>



<p><a name="k12"></a></p>
<h2 id="k12">12. Ukázka adresace 32bitovými registry v&nbsp;reálném režimu</h2>

<p>Demonstrační příklad <a href="#03">ze třetí kapitoly</a> si můžeme snadno
přepsat do podoby, ve které se použijí 32bitové přenosy:</p>

<pre>
        mov cx, 320*200/4   <i>; pocet zapisovanych 32bitovych slov (=ctveric pixelu)</i>
	rep movsd           <i>; prenos celeho obrazku po 32bitovych slovech </i>
</pre>

<p>Podle toho, zda je použit prefix 0x66, se navíc rozhoduje, zda budou adresy
specifikovány ve dvojicích DS:[SI] a ES:[DI] nebo se použijí dvojice DS:[ESI] a
ES:[EDI].</p>

<a href="https://i.iinfo.cz/images/422/pc-18-8.webp"><img src="https://i.iinfo.cz/images/422/pc-18-8-prev.webp" class="image-1161189" width="360" height="270" data-prev-filename="https://i.iinfo.cz/images/422/pc-18-8-prev.webp" data-prev-width="360" data-prev-height="270" data-large-filename="https://i.iinfo.cz/images/422/pc-18-8-large.webp" data-large-width="700" data-large-height="525" alt="&#160;" title="Autor: tisnik + Intel 80386&#160;Reference Programmer's&#160;Manual, podle licence: &lt;a href=&quot;http://en.wikipedia.org/wiki/Rights_Managed&quot;&gt;Rights Managed&lt;/a&gt;" /></a>
<p><i>Obrázek 8: Výsledek 32bitového přenosu by se neměl nijak lišit od
šestnáctibitového přenosu.</i></p>

<p>Úplný zdrojový kód tohoto příkladu vypadá následovně:</p>

<pre>
<i>; Graficky rezim karty VGA s rozlisenim 320x200 pixelu.</i>
<i>; Vykresleni rastroveho obrazku s explicitnim prenosem po ctyrech bajtech.</i>
<i>; Pro blokovy prenos se pouziva instrukce REP MOVSD</i>
<i>;</i>
<i>;-----------------------------------------------------------------------------</i>
&nbsp;
BITS 16         <i>; 16bitovy vystup pro DOS</i>
CPU  386        <i>; specifikace pouziteho instrukcniho souboru</i>
&nbsp;
<i>;-----------------------------------------------------------------------------</i>
&nbsp;
<i>; ukonceni procesu a navrat do DOSu</i>
%macro <strong>exit</strong> 0
        mov     ah, 0x4c    <i>; cislo sluzby DOSu</i>
        int     0x21        <i>; zavolani sluzby DOSu</i>
%endmacro
&nbsp;
<i>; vyprazdneni bufferu klavesnice a cekani na klavesu</i>
%macro <strong>wait_key</strong> 0
        xor     ax, ax      <i>; cislo sluzby BIOSu</i>
        int     0x16        <i>; zavolani sluzby BIOSu</i>
%endmacro
&nbsp;
<i>; nastaveni grafickeho rezimu</i>
%macro <strong>gfx_mode</strong> 1
        mov     ah, 0       <i>; cislo sluzby VGA BIOSu</i>
        mov     al, %1      <i>; cislo grafickeho rezimu</i>
        int     0x10        <i>; zavolani sluzby BIOSu</i>
%endmacro
&nbsp;
<i>; paleta ve stupnich sedi</i>
%macro <strong>grayscale_palette</strong> 0
        mov ax, 0x1010      <i>; cislo sluzby a podsluzby VGA BIOSu</i>
        xor bl, bl          <i>; index barvy</i>
next_dac:
        mov ch, bl          <i>; prvni barvova slozka</i>
        shr ch, 1
        shr ch, 1
        mov cl, ch          <i>; druha barvova slozka</i>
        mov dh, ch          <i>; treti barvova slozka</i>
        int 0x10            <i>; modifikace mapovani v DAC</i>
        inc bl              <i>; zvysit index v DAC</i>
        jnz next_dac        <i>; nastavit dalsi barvu, dokud nedosahneme hodnoty 256</i>
%endmacro
&nbsp;
<i>;-----------------------------------------------------------------------------</i>
org  0x100        <i>; zacatek kodu pro programy typu COM (vzdy se zacina na 256)</i>
&nbsp;
<strong>start</strong>:
        gfx_mode 0x13       <i>; nastaveni rezimu 320x200 s 256 barvami</i>
        grayscale_palette   <i>; nastaveni palety se stupni sedi</i>
&nbsp;
        mov ax, cs
        mov ds, ax
        mov esi, image      <i>; nyni dvojice DS:ESI obsahuje adresu prvniho bajtu v obrazku</i>
&nbsp;
        mov ax, 0xa000      <i>; (lze i PUSH 0xa000 + POP ES)</i>
	mov es, ax
        xor edi, edi        <i>; nyni dvojice ES:EDI obsahuje adresu prvniho pixelu ve video RAM   </i>
&nbsp;
        mov cx, 320*200/4   <i>; pocet zapisovanych 32bitovych slov (=ctveric pixelu)</i>
	rep movsd           <i>; prenos celeho obrazku po 32bitovych slovech </i>
&nbsp;
        wait_key            <i>; cekani na stisk klavesy</i>
        exit                <i>; navrat do DOSu</i>
&nbsp;
<i>; pridani binarnich dat s rastrovym obrazkem</i>
<strong>image</strong>:
    incbin "image_320x200.bin"
</pre>



<p><a name="k13"></a></p>
<h2 id="k13">13. Rozepsání programové smyčky: přenos po 32bitech, offsety jsou realizovány 32bitovými registry</h2>

<p>Blokový přenos <strong>rep movsd</strong> si opět můžeme přepsat do podoby
běžné programové smyčky. Nejdříve nastavíme zdrojové a cílové adresy, tentokrát
ovšem použijeme 32bitové offsetové registry:</p>

<pre>
        mov ax, cs
        mov ds, ax
        mov esi, image      <i>; nyni dvojice DS:ESI obsahuje adresu prvniho bajtu v obrazku</i>
&nbsp;
        mov ax, 0xa000      <i>; (lze i PUSH 0xa000 + POP ES)</i>
	mov es, ax
        xor edi, edi        <i>; nyni dvojice ES:EDI obsahuje adresu prvniho pixelu ve video RAM   </i>
</pre>

<p>Dále nastavíme počet opakování smyčky:</p>

<pre>
        mov cx, 320*200/4   <i>; pocet zapisovanych 32bitovych slov (=ctveric pixelu)</i>
</pre>

<p>A nakonec nám zbývá realizace této smyčky. Opět si povšimněte použití
32bitových offsetů (ovšem ty nikdy nepřesáhnou limit 64kB segmentu):</p>

<pre>
move_loop:                  <i>; prenos celeho obrazku po 32bitovych slovech</i>
	mov eax, ds:[esi]   <i>; nacteni ctyr bajtu</i>
	mov es:[edi], eax   <i>; ulozeni ctyr bajtu</i>
	add esi, 4          <i>; posun offsetu</i>
	add edi, 4
	loop move_loop      <i>; opakujeme</i>
</pre>

<p>Úplný zdrojový kód tohoto příkladu vypadá následovně:</p>

<pre>
<i>; Graficky rezim karty VGA s rozlisenim 320x200 pixelu.</i>
<i>; Vykresleni rastroveho obrazku s explicitnim prenosem po ctyrech bajtech.</i>
<i>; Pro blokovy prenos se pouziva programova smycka</i>
<i>;</i>
<i>;-----------------------------------------------------------------------------</i>
&nbsp;
BITS 16         <i>; 16bitovy vystup pro DOS</i>
CPU  386        <i>; specifikace pouziteho instrukcniho souboru</i>
&nbsp;
<i>;-----------------------------------------------------------------------------</i>
&nbsp;
<i>; ukonceni procesu a navrat do DOSu</i>
%macro <strong>exit</strong> 0
        mov     ah, 0x4c    <i>; cislo sluzby DOSu</i>
        int     0x21        <i>; zavolani sluzby DOSu</i>
%endmacro
&nbsp;
<i>; vyprazdneni bufferu klavesnice a cekani na klavesu</i>
%macro <strong>wait_key</strong> 0
        xor     ax, ax      <i>; cislo sluzby BIOSu</i>
        int     0x16        <i>; zavolani sluzby BIOSu</i>
%endmacro
&nbsp;
<i>; nastaveni grafickeho rezimu</i>
%macro <strong>gfx_mode</strong> 1
        mov     ah, 0       <i>; cislo sluzby VGA BIOSu</i>
        mov     al, %1      <i>; cislo grafickeho rezimu</i>
        int     0x10        <i>; zavolani sluzby BIOSu</i>
%endmacro
&nbsp;
<i>; paleta ve stupnich sedi</i>
%macro <strong>grayscale_palette</strong> 0
        mov ax, 0x1010      <i>; cislo sluzby a podsluzby VGA BIOSu</i>
        xor bl, bl          <i>; index barvy</i>
next_dac:
        mov ch, bl          <i>; prvni barvova slozka</i>
        shr ch, 1
        shr ch, 1
        mov cl, ch          <i>; druha barvova slozka</i>
        mov dh, ch          <i>; treti barvova slozka</i>
        int 0x10            <i>; modifikace mapovani v DAC</i>
        inc bl              <i>; zvysit index v DAC</i>
        jnz next_dac        <i>; nastavit dalsi barvu, dokud nedosahneme hodnoty 256</i>
%endmacro
&nbsp;
<i>;-----------------------------------------------------------------------------</i>
org  0x100        <i>; zacatek kodu pro programy typu COM (vzdy se zacina na 256)</i>
&nbsp;
<strong>start</strong>:
        gfx_mode 0x13       <i>; nastaveni rezimu 320x200 s 256 barvami</i>
        grayscale_palette   <i>; nastaveni palety se stupni sedi</i>
&nbsp;
        mov ax, cs
        mov ds, ax
        mov esi, image      <i>; nyni dvojice DS:ESI obsahuje adresu prvniho bajtu v obrazku</i>
&nbsp;
        mov ax, 0xa000      <i>; (lze i PUSH 0xa000 + POP ES)</i>
	mov es, ax
        xor edi, edi        <i>; nyni dvojice ES:EDI obsahuje adresu prvniho pixelu ve video RAM   </i>
&nbsp;
        mov cx, 320*200/4   <i>; pocet zapisovanych 32bitovych slov (=ctveric pixelu)</i>
&nbsp;
<strong>move_loop</strong>:                  <i>; prenos celeho obrazku po 32bitovych slovech</i>
	mov eax, ds:[esi]   <i>; nacteni ctyr bajtu</i>
	mov es:[edi], eax   <i>; ulozeni ctyr bajtu</i>
	add esi, 4          <i>; posun offsetu</i>
	add edi, 4
	loop move_loop      <i>; opakujeme</i>
&nbsp;
        wait_key            <i>; cekani na klavesu</i>
        exit                <i>; navrat do DOSu</i>
&nbsp;
<i>; pridani binarnich dat s rastrovym obrazkem</i>
<strong>image</strong>:
    incbin "image_320x200.bin"
</pre>



<p><a name="k14"></a></p>
<h2 id="k14">14. Přístup do obrazové paměti přes segment 0x0000 a 32bitový offset</h2>

<p>Pokusme se nyní předchozí ukázkový příklad upravit takovým způsobem, aby se
k&nbsp;Video RAM přistupovalo sice stále přes fyzické adresy 0xa0000-0xafff,
ale nyní přes segment 0x0000. To ovšem znamená nutnost použití 32bitového
offsetu. Úprava zdrojového kódu je snadná &ndash; vynulujeme registr ES a
nastavíme offset do registru EDI:</p>

<pre>
        mov ax, cs
        mov ds, ax
        mov esi, image      <i>; nyni dvojice DS:ESI obsahuje adresu prvniho bajtu v obrazku</i>
&nbsp;
        xor ax, ax
	mov es, ax          <i>; ES=0x0000 !!!</i>
	mov edi, 0xa0000    <i>; nyni dvojice ES:EDI obsahuje adresu prvniho pixelu ve video RAM   </i>
</pre>

<p>Dále nastavíme počitadlo opakování smyčky, a to už běžným způsobem:</p>

<pre>
        mov cx, 320*200/4   <i>; pocet zapisovanych 32bitovych slov (=ctveric pixelu)</i>
</pre>

<p>A pokusíme se provést vlastní blokový přenos.</p>

<pre>
<strong>move_loop</strong>:                  <i>; prenos celeho obrazku po 32bitovych slovech</i>
	mov eax, ds:[esi]   <i>; nacteni ctyr bajtu</i>
	mov es:[edi], eax   <i>; ulozeni ctyr bajtu</i>
	add esi, 4          <i>; posun offsetu</i>
	add edi, 4
	loop move_loop      <i>; opakujeme</i>
</pre>

<p>Chování aplikace se nyní může ubrat několika směry:</p>

<ul>
<li>V&nbsp;reálném režimu aplikace zamrzne (a uvidíme jen černou obrazovku)</li>
<li>V&nbsp;nereálném režimu (a podle všeho ho nastaví i některé verze HIMEM.SYS) se obrázek přenese bez problémů</li>
<li>V&nbsp;případě aktivního extenderu závisí na nastavení limitů, ale obecně dojde k&nbsp;pádu kvůli výjimce</li>
<li>V&nbsp;případě aktivního režimu V86 (virtuální režim) opět závisí na nastavení limitů</li>
<li>DOSBox limity nekontroluje a proto aplikace obrázek přenese bez problémů</li>
</ul>

<img src="https://i.iinfo.cz/images/422/pc-18-9.webp" class="image-1161192" width="640" height="400" alt="&#160;" title="Autor: tisnik + Intel 80386&#160;Reference Programmer's&#160;Manual, podle licence: &lt;a href=&quot;http://en.wikipedia.org/wiki/Rights_Managed&quot;&gt;Rights Managed&lt;/a&gt;" />
<p><i>Obrázek 9: Výjimka v&nbsp;chráněném režimu zachycená extenderem.</i></p>

<p>Úplný kód tohoto demonstračního příkladu vypadá následovně:</p>

<pre>
<i>; Graficky rezim karty VGA s rozlisenim 320x200 pixelu.</i>
<i>; Vykresleni rastroveho obrazku s explicitnim prenosem po ctyrech bajtech.</i>
<i>;-----------------------------------------------------------------------------</i>
&nbsp;
BITS 16         <i>; 16bitovy vystup pro DOS</i>
CPU  386        <i>; specifikace pouziteho instrukcniho souboru</i>
&nbsp;
<i>;-----------------------------------------------------------------------------</i>
&nbsp;
<i>; ukonceni procesu a navrat do DOSu</i>
%macro <strong>exit</strong> 0
        mov     ah, 0x4c    <i>; cislo sluzby DOSu</i>
        int     0x21        <i>; zavolani sluzby DOSu</i>
%endmacro
&nbsp;
<i>; vyprazdneni bufferu klavesnice a cekani na klavesu</i>
%macro <strong>wait_key</strong> 0
        xor     ax, ax      <i>; cislo sluzby BIOSu</i>
        int     0x16        <i>; zavolani sluzby BIOSu</i>
%endmacro
&nbsp;
<i>; nastaveni grafickeho rezimu</i>
%macro <strong>gfx_mode</strong> 1
        mov     ah, 0       <i>; cislo sluzby VGA BIOSu</i>
        mov     al, %1      <i>; cislo grafickeho rezimu</i>
        int     0x10        <i>; zavolani sluzby BIOSu</i>
%endmacro
&nbsp;
<i>; paleta ve stupnich sedi</i>
%macro <strong>grayscale_palette</strong> 0
        mov ax, 0x1010      <i>; cislo sluzby a podsluzby VGA BIOSu</i>
        xor bl, bl          <i>; index barvy</i>
next_dac:
        mov ch, bl          <i>; prvni barvova slozka</i>
        shr ch, 1
        shr ch, 1
        mov cl, ch          <i>; druha barvova slozka</i>
        mov dh, ch          <i>; treti barvova slozka</i>
        int 0x10            <i>; modifikace mapovani v DAC</i>
        inc bl              <i>; zvysit index v DAC</i>
        jnz next_dac        <i>; nastavit dalsi barvu, dokud nedosahneme hodnoty 256</i>
%endmacro
&nbsp;
<i>;-----------------------------------------------------------------------------</i>
org  0x100        <i>; zacatek kodu pro programy typu COM (vzdy se zacina na 256)</i>
&nbsp;
<strong>start</strong>:
        gfx_mode 0x13       <i>; nastaveni rezimu 320x200 s 256 barvami</i>
        grayscale_palette   <i>; nastaveni palety se stupni sedi</i>
&nbsp;
        mov ax, cs
        mov ds, ax
        mov esi, image      <i>; nyni dvojice DS:ESI obsahuje adresu prvniho bajtu v obrazku</i>
&nbsp;
        xor ax, ax
	mov es, ax          <i>; ES=0x0000 !!!</i>
	mov edi, 0xa0000    <i>; nyni dvojice ES:EDI obsahuje adresu prvniho pixelu ve video RAM   </i>
&nbsp;
        mov cx, 320*200/4   <i>; pocet zapisovanych 32bitovych slov (=ctveric pixelu)</i>
&nbsp;
<strong>move_loop</strong>:                  <i>; prenos celeho obrazku po 32bitovych slovech</i>
	mov eax, ds:[esi]   <i>; nacteni ctyr bajtu</i>
	mov es:[edi], eax   <i>; ulozeni ctyr bajtu</i>
	add esi, 4          <i>; posun offsetu</i>
	add edi, 4
	loop move_loop      <i>; opakujeme</i>
&nbsp;
        wait_key            <i>; cekani na klavesu</i>
        exit                <i>; navrat do DOSu</i>
&nbsp;
<i>; pridani binarnich dat s rastrovym obrazkem</i>
<strong>image</strong>:
    incbin "image_320x200.bin"
</pre>



<p><a name="k15"></a></p>
<h2 id="k15">15. Překročení limitu segmentu s&nbsp;využitím posunu adresy o konstantu</h2>

<p>Taktéž se můžeme pokusit o překročení limitu segmentu &bdquo;jen o
kousek&ldquo;, a to s&nbsp;využitím konstanty přičtené k&nbsp;registru EDI.
Nyní tedy (například) nastavíme segmentový registr ES na hodnotu 0x9800,
tj.&nbsp;32kB před první adresou Video RAM a vynulujeme registr EDI:</p>

<pre>
        mov ax, 0x9800
	mov es, ax          <i>; ES=0x9800 !!!</i>
	xor edi, edi        <i>; nyni ES:EDI obsahuje adresu Video RAM-32kB</i>
</pre>

<p>Samotná programová smyčka pro provedení blokových přenosů se pochopitelně
bude muset modifikovat, protože nyní k&nbsp;registru EDI přičteme konstantu
0x8000, abychom kompenzovali nižší adresu segmentu. Samotný EDI tedy nikdy
nepřekročí hodnotu 0xffff, čímž se zdánlivě vyhneme problému, na který jsme
narazili <a href="#k14">v&nbsp;předchozím příkladu</a>:</p>

<pre>
<strong>move_loop</strong>:                       <i>; prenos celeho obrazku po 32bitovych slovech</i>
	mov eax, ds:[esi]        <i>; nacteni ctyr bajtu</i>
	mov es:[edi+0x8000], eax <i>; ulozeni ctyr bajtu, ovsem s offsetem</i>
	add esi, 4               <i>; posun offsetu</i>
	add edi, 4
	loop move_loop           <i>; opakujeme</i>
</pre>

<p>V&nbsp;praxi ovšem po spuštění tohoto programu může dojít ke všem chováním,
které již byly popsány <a href="#k14">v&nbsp;předchozí kapitole</a>: od
bezproblémového zobrazení rastrového obrázku přes zamrznutí aplikace až po pád
po zachycení HW výjimky.</p>

<pre>
<i>; Graficky rezim karty VGA s rozlisenim 320x200 pixelu.</i>
<i>; Vykresleni rastroveho obrazku s explicitnim prenosem po ctyrech bajtech.</i>
<i>;</i>
<i>;-----------------------------------------------------------------------------</i>
&nbsp;
BITS 16         <i>; 16bitovy vystup pro DOS</i>
CPU  386        <i>; specifikace pouziteho instrukcniho souboru</i>
&nbsp;
<i>;-----------------------------------------------------------------------------</i>
&nbsp;
<i>; ukonceni procesu a navrat do DOSu</i>
%macro <strong>exit</strong> 0
        mov     ah, 0x4c    <i>; cislo sluzby DOSu</i>
        int     0x21        <i>; zavolani sluzby DOSu</i>
%endmacro
&nbsp;
<i>; vyprazdneni bufferu klavesnice a cekani na klavesu</i>
%macro <strong>wait_key</strong> 0
        xor     ax, ax      <i>; cislo sluzby BIOSu</i>
        int     0x16        <i>; zavolani sluzby BIOSu</i>
%endmacro
&nbsp;
<i>; nastaveni grafickeho rezimu</i>
%macro <strong>gfx_mode</strong> 1
        mov     ah, 0       <i>; cislo sluzby VGA BIOSu</i>
        mov     al, %1      <i>; cislo grafickeho rezimu</i>
        int     0x10        <i>; zavolani sluzby BIOSu</i>
%endmacro
&nbsp;
<i>; paleta ve stupnich sedi</i>
%macro <strong>grayscale_palette</strong> 0
        mov ax, 0x1010      <i>; cislo sluzby a podsluzby VGA BIOSu</i>
        xor bl, bl          <i>; index barvy</i>
next_dac:
        mov ch, bl          <i>; prvni barvova slozka</i>
        shr ch, 1
        shr ch, 1
        mov cl, ch          <i>; druha barvova slozka</i>
        mov dh, ch          <i>; treti barvova slozka</i>
        int 0x10            <i>; modifikace mapovani v DAC</i>
        inc bl              <i>; zvysit index v DAC</i>
        jnz next_dac        <i>; nastavit dalsi barvu, dokud nedosahneme hodnoty 256</i>
%endmacro
&nbsp;
<i>;-----------------------------------------------------------------------------</i>
org  0x100        <i>; zacatek kodu pro programy typu COM (vzdy se zacina na 256)</i>
&nbsp;
<strong>start</strong>:
        gfx_mode 0x13       <i>; nastaveni rezimu 320x200 s 256 barvami</i>
        grayscale_palette   <i>; nastaveni palety se stupni sedi</i>
&nbsp;
        mov ax, cs
        mov ds, ax
        mov esi, image      <i>; nyni dvojice DS:ESI obsahuje adresu prvniho bajtu v obrazku</i>
&nbsp;
        mov ax, 0x9800
	mov es, ax          <i>; ES=0x9800 !!!</i>
	xor edi, edi        <i>; nyni ES:EDI obsahuje adresu Video RAM-32kB</i>
&nbsp;
        mov cx, 320*200/4   <i>; pocet zapisovanych 32bitovych slov (=ctveric pixelu)</i>
&nbsp;
<strong>move_loop</strong>:                       <i>; prenos celeho obrazku po 32bitovych slovech</i>
	mov eax, ds:[esi]        <i>; nacteni ctyr bajtu</i>
	mov es:[edi+0x8000], eax <i>; ulozeni ctyr bajtu, ovsem s offsetem</i>
	add esi, 4               <i>; posun offsetu</i>
	add edi, 4
	loop move_loop           <i>; opakujeme</i>
&nbsp;
        wait_key            <i>; cekani na klavesu</i>
        exit                <i>; navrat do DOSu</i>
&nbsp;
<i>; pridani binarnich dat s rastrovym obrazkem</i>
<strong>image</strong>:
    incbin "image_320x200.bin"
</pre>



<p><a name="k16"></a></p>
<h2 id="k16">16. Naplnění cache s&nbsp;deskriptory přes &bdquo;utajenou&ldquo; instrukci <strong>LOADALL</strong></h2>

<p>Jedinou oficiální cestou, jakou lze naplnit cache s&nbsp;deskriptory, je
nastavení tabulek deskriptorů v&nbsp;operační paměti, přepnutí mikroprocesoru
do chráněného režimu a načtení nových adres do segmentových registrů.
V&nbsp;tomto případě se načtou příslušné hodnoty z&nbsp;tabulek deskriptorů do
cache s&nbsp;deskriptory a nové bázové adresy segmentů i jejich limity začnou
být platné. To jsou ovšem poměrně komplikované a taktéž pomalé operace, které
navíc následně vyžadují přepnutí zpět do reálného režimu, což není (zejména
v&nbsp;případě mikroprocesoru 80286 snadné a vlastně ani oficiálně možné
&ndash; pro tento účel bylo nutné upravit interní architekturu IBM PC tak, aby
se provedl reset mikroprocesoru). Ovšem nakonec se našla ještě zajímavější
cesta, jak naplnit cache. Pro tento účel se totiž začala používat instrukce
<strong>LOADALL</strong>.</p>

<p>Jedná se o instrukci, která nebyla oficiálně zdokumentována a byla
společnosti Intel navržena primárně pro testovací účely prováděné ještě před
instalací mikroprocesoru do základové desky. Ovšem to, že nějaká instrukce není
zdokumentována, neznamená, že ji nelze použít, navíc v&nbsp;případě, že
spolehlivě pracovala i na čipech vyráběných ostatními firmami (AMD, IBM). Navíc
bylo možné tuto instrukci použít i v&nbsp;reálném režimu, bez nutnosti
přepínání do režimu chráněného a zpět. V&nbsp;praxi se tedy tato instrukce
začala používat dokonce i v&nbsp;samotném DOSu (HIMEM.SYS) a bylo již možné
použít pro zavedení takzvaného nereálného režimu (<i>unreal mode</i>).</p>

<p>Na tomto místě je nutné zdůraznit, že instrukce <strong>LOADALL</strong> pro
mikroprocesor 80286 je zcela odlišná od stejně pojmenované instrukce pro 80386.
Dokonce se liší i operační kódy těchto instrukcí. Kód pro naplnění cache
s&nbsp;deskriptory tedy musel zjistit, na jakém procesoru běží a poté použít
odlišné větve v&nbsp;kódu.</p>



<p><a name="k17"></a></p>
<h2 id="k17">17. <strong>LOADALL</strong> na mikroprocesorech 80286</h2>

<p>Nejprve se podívejme, jakou operaci instrukce <strong>LOADALL</strong>
provádí na mikroprocesorech Intel 80286. Operační kód této instrukce je 0f 05,
přičemž se nespecifikují žádné operandy. Tato instrukce totiž očekává, že na
adrese 0x00800 (tedy například 0080:0000 nebo 0000:0800) bude uloženo 102
bajtů, které se všechny přenesou do viditelných registrů mikroprocesoru,
neviditelných registrů (nepřístupných programátorům) a taktéž se načte námi
používaná cache s&nbsp;deskriptory (tedy čtyři deskriptory pro čtyři segmentové
registry a další čtyři deskriptory pro adresy používané v&nbsp;chráněném
režimu). Jedná se o relativně pomalou instrukci, protože její provedení trvá
195 hodinových cyklů. Ovšem díky ní lze snadno zpřístupnit jakýkoli blok
rozšířené paměti, a to bez nutnosti blokové kopie dat (což je pochopitelně
mnohem delší).</p>

<p>Hodnoty uložené od výše zmíněné adresy 0x00800 mají tento význam:</p>

<table>
<tr><th>Adresa</th><th>Šířka dat</th><th>Stručný popis</th></tr>
<tr><td>0x00800</td><td>16 bitů</td><td>je vynulován</td></tr>
<tr><td>0x00802</td><td>16 bitů</td><td>je vynulován</td></tr>
<tr><td>0x00804</td><td>16 bitů</td><td>registr MSW</td></tr>
<tr><td>0x00806</td><td>16 bitů</td><td>?</td></tr>
<tr><td>0x00808</td><td>16 bitů</td><td>je vynulován</td></tr>
<tr><td>0x0080A</td><td>16 bitů</td><td>je vynulován</td></tr>
<tr><td>0x0080C</td><td>16 bitů</td><td>je vynulován</td></tr>
<tr><td>0x0080E</td><td>16 bitů</td><td>je vynulován</td></tr>
<tr><td>0x00810</td><td>16 bitů</td><td>je vynulován</td></tr>
<tr><td>0x00812</td><td>16 bitů</td><td>je vynulován</td></tr>
<tr><td>0x00814</td><td>16 bitů</td><td>je vynulován</td></tr>
<tr><td>0x00816</td><td>16 bitů</td><td>registr TR</td></tr>
<tr><td>0x00818</td><td>16 bitů</td><td>příznakový registr</td></tr>
<tr><td>0x0081A</td><td>16 bitů</td><td>registr IP</td></tr>
<tr><td>0x0081C</td><td>16 bitů</td><td>registr LDT</td></tr>
<tr><td>0x0081E</td><td>16 bitů</td><td>registr DS</td></tr>
<tr><td>0x00820</td><td>16 bitů</td><td>registr SS</td></tr>
<tr><td>0x00822</td><td>16 bitů</td><td>registr CS</td></tr>
<tr><td>0x00824</td><td>16 bitů</td><td>registr ES</td></tr>
<tr><td>0x00826</td><td>16 bitů</td><td>registr DI</td></tr>
<tr><td>0x00828</td><td>16 bitů</td><td>registr SI</td></tr>
<tr><td>0x0082A</td><td>16 bitů</td><td>registr BP</td></tr>
<tr><td>0x0082C</td><td>16 bitů</td><td>registr SP</td></tr>
<tr><td>0x0082E</td><td>16 bitů</td><td>registr BX</td></tr>
<tr><td>0x00830</td><td>16 bitů</td><td>registr DX</td></tr>
<tr><td>0x00832</td><td>16 bitů</td><td>registr CX</td></tr>
<tr><td>0x00834</td><td>16 bitů</td><td>registr AX</td></tr>
<tr><td>0x00836</td><td>48 bitů</td><td>deskriptor pro ES</td></tr>
<tr><td>0x0083C</td><td>48 bitů</td><td>deskriptor pro CS</td></tr>
<tr><td>0x00842</td><td>48 bitů</td><td>deskriptor pro SS</td></tr>
<tr><td>0x00848</td><td>48 bitů</td><td>deskriptor pro DS</td></tr>
<tr><td>0x0084E</td><td>48 bitů</td><td>deskriptor pro GDT</td></tr>
<tr><td>0x00854</td><td>48 bitů</td><td>deskriptor pro LDT</td></tr>
<tr><td>0x0085A</td><td>48 bitů</td><td>deskriptor pro IDT</td></tr>
<tr><td>0x00860</td><td>48 bitů</td><td>deskriptor pro TSS</td></tr>
<tr><td>0x00866</td><td>konec</td><td>konec tabulky</td></tr>
</table>

<p>Pokud si tedy tento blok připravíme a budeme pouze měnit deskriptory od
adresy 0X00836, je možné si postupně zpřístupnit veškerou nainstalovanou RAM.
Není to řešení elegantní, ale funguje.</p>



<p><a name="k18"></a></p>
<h2 id="k18">18. <strong>LOADALL</strong> na mikroprocesorech 80386</h2>

<p>Stejně pojmenovaná (a stejně oficiálně nezdokumentovaná &ndash; vlastně
ještě více utajovaná) je i instrukce <strong>LOADALL</strong> určená pro
mikroprocesory 80386. Tato instrukce má odlišný operační kód 0F 07 a liší se i
vyžadovaná struktura paměti, která je načtena do mikroprocesoru. Navíc se nyní
explicitně udává adresa tohoto bloku paměti, a to konkrétně v&nbsp;registrech
ES:EDI.</p>

<p>Zajímavé je, že bylo zjištěno, že ještě předtím, než se celá struktura načte
do paměti, provede mikroprocesor čtení deseti 32bitových slov z&nbsp;adresy
ES:EDI+0x100. Proč tomu tak je a kam se tato data ukládají, mi popravdě řečeno
není známo. Nicméně se vraťme ke známým faktům &ndash; <strong>LOADALL</strong>
opět načte obsahy registrů, kterých je na Intelu 80386 mnohem více. Taktéž se
načtou deskriptory, které mají délku osmi bajtů a nikoli šesti bajtů (větší
bázové adresy i limity). Podrobnosti o (což byl pravděpodobně nejrevolučnější
čip řady 80x86 až do doby, kdy vznikla 64bitová instrukční sada) si řekneme
příště:</p>

<table>
<tr><th>Šířka dat</th><th>Stručný popis</th></tr>
<tr><td>32 bitů</td><td>registr CR0</td></tr>
<tr><td>32 bitů</td><td>příznaky EFLAGS</td></tr>
<tr><td>32 bitů</td><td>registr EIP</td></tr>
<tr><td>32 bitů</td><td>registr EDI</td></tr>
<tr><td>32 bitů</td><td>registr ESI</td></tr>
<tr><td>32 bitů</td><td>registr EBP</td></tr>
<tr><td>32 bitů</td><td>registr ESP</td></tr>
<tr><td>32 bitů</td><td>registr EBX</td></tr>
<tr><td>32 bitů</td><td>registr EDX</td></tr>
<tr><td>32 bitů</td><td>registr ECX</td></tr>
<tr><td>32 bitů</td><td>registr EAX</td></tr>
<tr><td>32 bitů</td><td>registr DR6</td></tr>
<tr><td>32 bitů</td><td>registr DR7</td></tr>
<tr><td>32 bitů</td><td>registr TR</td></tr>
<tr><td>32 bitů</td><td>registr LDT</td></tr>
<tr><td>32 bitů</td><td>segmentový registr GS s&nbsp;výplní</td></tr>
<tr><td>32 bitů</td><td>segmentový registr FS s&nbsp;výplní</td></tr>
<tr><td>32 bitů</td><td>segmentový registr DS s&nbsp;výplní</td></tr>
<tr><td>32 bitů</td><td>segmentový registr SS s&nbsp;výplní</td></tr>
<tr><td>32 bitů</td><td>segmentový registr CS s&nbsp;výplní</td></tr>
<tr><td>32 bitů</td><td>segmentový registr ES s&nbsp;výplní</td></tr>
<tr><td>96 bitů</td><td>deskriptor pro registr TSS + výplň 32 bitů</td></tr>
<tr><td>96 bitů</td><td>deskriptor pro registr IDTD + výplň 32 bitů</td></tr>
<tr><td>96 bitů</td><td>deskriptor pro registr GDTD + výplň 32 bitů</td></tr>
<tr><td>96 bitů</td><td>deskriptor pro registr LDTD + výplň 32 bitů</td></tr>
<tr><td>96 bitů</td><td>deskriptor pro segmentový registr GS + výplň 32 bitů</td></tr>
<tr><td>96 bitů</td><td>deskriptor pro segmentový registr FS + výplň 32 bitů</td></tr>
<tr><td>96 bitů</td><td>deskriptor pro segmentový registr DS + výplň 32 bitů</td></tr>
<tr><td>96 bitů</td><td>deskriptor pro segmentový registr SS + výplň 32 bitů</td></tr>
<tr><td>96 bitů</td><td>deskriptor pro segmentový registr CS + výplň 32 bitů</td></tr>
<tr><td>96 bitů</td><td>deskriptor pro segmentový registr ES + výplň 32 bitů</td></tr>
</table>



<p><a name="k19"></a></p>
<h2 id="k19">19. Repositář s&nbsp;demonstračními příklady</h2>

<p>Demonstrační příklady napsané v&nbsp;assembleru, které jsou určené pro
překlad s&nbsp;využitím assembleru <strong>NASM</strong>, byly uloženy do Git
repositáře, který je dostupný na adrese <a
href="https://github.com/tisnik/8bit-fame">https://github.com/tisnik/8bit-fame</a>.
Jednotlivé demonstrační příklady si můžete v&nbsp;případě potřeby stáhnout i
jednotlivě bez nutnosti klonovat celý (dnes již poměrně rozsáhlý)
repositář:</p>

<table>
<tr><th> #</th><th>Příklad</th><th>Stručný popis</th><th>Adresa</th></tr>
<tr><td> 1</td><td>hello.asm</td><td>program typu &bdquo;Hello world&ldquo; naprogramovaný v&nbsp;assembleru pro systém DOS</td><td><a href="https://github.com/tisnik/8bit-fame/blob/master/pc-dos/hello.asm">https://github.com/tisnik/8bit-fame/blob/master/pc-dos/hello.asm</a></td></tr>
<tr><td> 2</td><td>hello_shorter.asm</td><td>kratší varianta výskoku z&nbsp;procesu zpět do DOSu</td><td><a href="https://github.com/tisnik/8bit-fame/blob/master/pc-dos/hello_shorter.asm">https://github.com/tisnik/8bit-fame/blob/master/pc-dos/hello_shorter.asm</a></td></tr>
<tr><td> 3</td><td>hello_wait.asm</td><td>čekání na stisk klávesy</td><td><a href="https://github.com/tisnik/8bit-fame/blob/master/pc-dos/hello_wait.asm">https://github.com/tisnik/8bit-fame/blob/master/pc-dos/hello_wait.asm</a></td></tr>
<tr><td> 4</td><td>hello_macros.asm</td><td>realizace jednotlivých částí programu makrem</td><td><a href="https://github.com/tisnik/8bit-fame/blob/master/pc-dos/hello_macros.asm">https://github.com/tisnik/8bit-fame/blob/master/pc-dos/hello_macros.asm</a></td></tr>
<tr><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td></tr>
<tr><td> 5</td><td>gfx_4_putpixel.asm</td><td>vykreslení pixelu v&nbsp;grafickém režimu 4</td><td><a href="https://github.com/tisnik/8bit-fame/blob/master/pc-dos/gfx_4_putpixel.asm">https://github.com/tisnik/8bit-fame/blob/master/pc-dos/gfx_4_putpixel.asm</a></td></tr>
<tr><td> 6</td><td>gfx_6_putpixel.asm</td><td>vykreslení pixelu v&nbsp;grafickém režimu 6</td><td><a href="https://github.com/tisnik/8bit-fame/blob/master/pc-dos/gfx_6_putpixel.asm">https://github.com/tisnik/8bit-fame/blob/master/pc-dos/gfx_6_putpixel.asm</a></td></tr>
<tr><td> 7</td><td>gfx_4_line.asm</td><td>vykreslení úsečky v&nbsp;grafickém režimu 4</td><td><a href="https://github.com/tisnik/8bit-fame/blob/master/pc-dos/gfx_4_line.asm">https://github.com/tisnik/8bit-fame/blob/master/pc-dos/gfx_4_line.asm</a></td></tr>
<tr><td> 8</td><td>gfx_6_line.asm</td><td>vykreslení úsečky v&nbsp;grafickém režimu 6</td><td><a href="https://github.com/tisnik/8bit-fame/blob/master/pc-dos/gfx_6_line.asm">https://github.com/tisnik/8bit-fame/blob/master/pc-dos/gfx_6_line.asm</a></td></tr>
<tr><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td></tr>
<tr><td> 9</td><td>gfx_6_fill_1.asm</td><td>vyplnění obrazovky v&nbsp;grafickém režimu, základní varianta</td><td><a href="https://github.com/tisnik/8bit-fame/blob/master/pc-dos/gfx_6_fill_1.asm">https://github.com/tisnik/8bit-fame/blob/master/pc-dos/gfx_6_fill_1.asm</a></td></tr>
<tr><td>10</td><td>gfx_6_fill_2.asm</td><td>vyplnění obrazovky v&nbsp;grafickém režimu, varianta s&nbsp;instrukcí <strong>LOOP</strong></td><td><a href="https://github.com/tisnik/8bit-fame/blob/master/pc-dos/gfx_6_fill_2.asm">https://github.com/tisnik/8bit-fame/blob/master/pc-dos/gfx_6_fill_2.asm</a></td></tr>
<tr><td>11</td><td>gfx_6_fill_3.asm</td><td>vyplnění obrazovky instrukcí <strong>REP STOSB</strong></td><td><a href="https://github.com/tisnik/8bit-fame/blob/master/pc-dos/gfx_6_fill_3.asm">https://github.com/tisnik/8bit-fame/blob/master/pc-dos/gfx_6_fill_3.asm</a></td></tr>
<tr><td>12</td><td>gfx_6_fill_4.asm</td><td>vyplnění obrazovky, synchronizace vykreslování s&nbsp;paprskem</td><td><a href="https://github.com/tisnik/8bit-fame/blob/master/pc-dos/gfx_6_fill_4.asm">https://github.com/tisnik/8bit-fame/blob/master/pc-dos/gfx_6_fill_4.asm</a></td></tr>
<tr><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td></tr>
<tr><td>13</td><td>gfx_4_image_1.asm</td><td>vykreslení rastrového obrázku získaného z&nbsp;binárních dat, základní varianta</td><td><a href="https://github.com/tisnik/8bit-fame/blob/master/pc-dos/gfx_4_image_1.asm">https://github.com/tisnik/8bit-fame/blob/master/pc-dos/gfx_4_image_1.asm</a></td></tr>
<tr><td>14</td><td>gfx_4_image_2.asm</td><td>varianta vykreslení rastrového obrázku s&nbsp;využitím instrukce <strong>REP MOVSB</strong></td><td><a href="https://github.com/tisnik/8bit-fame/blob/master/pc-dos/gfx_4_image_2.asm">https://github.com/tisnik/8bit-fame/blob/master/pc-dos/gfx_4_image_2.asm</a></td></tr>
<tr><td>15</td><td>gfx_4_image_3.asm</td><td>varianta vykreslení rastrového obrázku s&nbsp;využitím instrukce <strong>REP MOVSW</strong></td><td><a href="https://github.com/tisnik/8bit-fame/blob/master/pc-dos/gfx_4_image_3.asm">https://github.com/tisnik/8bit-fame/blob/master/pc-dos/gfx_4_image_3.asm</a></td></tr>
<tr><td>16</td><td>gfx_4_image_4.asm</td><td>korektní vykreslení všech sudých řádků bitmapy</td><td><a href="https://github.com/tisnik/8bit-fame/blob/master/pc-dos/gfx_4_image_4.asm">https://github.com/tisnik/8bit-fame/blob/master/pc-dos/gfx_4_image_4.asm</a></td></tr>
<tr><td>17</td><td>gfx_4_image_5.asm</td><td>korektní vykreslení všech sudých i lichých řádků bitmapy</td><td><a href="https://github.com/tisnik/8bit-fame/blob/master/pc-dos/gfx_4_image_5.asm">https://github.com/tisnik/8bit-fame/blob/master/pc-dos/gfx_4_image_5.asm</a></td></tr>
<tr><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td></tr>
<tr><td>18</td><td>gfx_4_image_6.asm</td><td>nastavení barvové palety před vykreslením obrázku</td><td><a href="https://github.com/tisnik/8bit-fame/blob/master/pc-dos/gfx_4_image_6.asm">https://github.com/tisnik/8bit-fame/blob/master/pc-dos/gfx_4_image_6.asm</a></td></tr>
<tr><td>19</td><td>gfx_4_image_7.asm</td><td>nastavení barvové palety před vykreslením obrázku, snížená intenzita barev</td><td><a href="https://github.com/tisnik/8bit-fame/blob/master/pc-dos/gfx_4_image_7.asm">https://github.com/tisnik/8bit-fame/blob/master/pc-dos/gfx_4_image_7.asm</a></td></tr>
<tr><td>20</td><td>gfx_4_image_8.asm</td><td>postupná změna barvy pozadí</td><td><a href="https://github.com/tisnik/8bit-fame/blob/master/pc-dos/gfx_4_image_8.asm">https://github.com/tisnik/8bit-fame/blob/master/pc-dos/gfx_4_image_8.asm</a></td></tr>
<tr><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td></tr>
<tr><td>21</td><td>gfx_6_putpixel_1.asm</td><td>vykreslení pixelu, základní varianta se 16bitovým násobením</td><td><a href="https://github.com/tisnik/8bit-fame/blob/master/pc-dos/gfx_6_putpixel_1.asm">https://github.com/tisnik/8bit-fame/blob/master/pc-dos/gfx_6_putpixel_1.asm</a></td></tr>
<tr><td>22</td><td>gfx_6_putpixel_2.asm</td><td>vykreslení pixelu, varianta s&nbsp;osmibitovým násobením</td><td><a href="https://github.com/tisnik/8bit-fame/blob/master/pc-dos/gfx_6_putpixel_2.asm">https://github.com/tisnik/8bit-fame/blob/master/pc-dos/gfx_6_putpixel_2.asm</a></td></tr>
<tr><td>23</td><td>gfx_6_putpixel_3.asm</td><td>vykreslení pixelu, varianta bez násobení</td><td><a href="https://github.com/tisnik/8bit-fame/blob/master/pc-dos/gfx_6_putpixel_3.asm">https://github.com/tisnik/8bit-fame/blob/master/pc-dos/gfx_6_putpixel_3.asm</a></td></tr>
<tr><td>24</td><td>gfx_6_putpixel_4.asm</td><td>vykreslení pixelu přes obrázek, nekorektní chování (přepis obrázku)</td><td><a href="https://github.com/tisnik/8bit-fame/blob/master/pc-dos/gfx_6_putpixel_4.asm">https://github.com/tisnik/8bit-fame/blob/master/pc-dos/gfx_6_putpixel_4.asm</a></td></tr>
<tr><td>25</td><td>gfx_6_putpixel_5.asm</td><td>vykreslení pixelu přes obrázek, korektní varianta pro bílé pixely</td><td><a href="https://github.com/tisnik/8bit-fame/blob/master/pc-dos/gfx_6_putpixel_5.asm">https://github.com/tisnik/8bit-fame/blob/master/pc-dos/gfx_6_putpixel_5.asm</a></td></tr>
<tr><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td></tr>
<tr><td>26</td><td>cga_text_mode_1.asm</td><td>standardní textový režim s&nbsp;rozlišením 40&times;25 znaků</td><td><a href="https://github.com/tisnik/8bit-fame/blob/master/pc-dos/cga_text_mode_1.asm">https://github.com/tisnik/8bit-fame/blob/master/pc-dos/cga_text_mode_1.asm</a></td></tr>
<tr><td>27</td><td>cga_text_mode_3.asm</td><td>standardní textový režim s&nbsp;rozlišením 80&times;25 znaků</td><td><a href="https://github.com/tisnik/8bit-fame/blob/master/pc-dos/cga_text_mode_3.asm">https://github.com/tisnik/8bit-fame/blob/master/pc-dos/cga_text_mode_3.asm</a></td></tr>
<tr><td>28</td><td>cga_text_mode_intensity.asm</td><td>změna významu nejvyššího bitu atributového bajtu: vyšší intenzita namísto blikání</td><td><a href="https://github.com/tisnik/8bit-fame/blob/master/pc-dos/cga_text_mode_intensity.asm">https://github.com/tisnik/8bit-fame/blob/master/pc-dos/cga_text_mode_intensity.asm</a></td></tr>
<tr><td>29</td><td>cga_text_mode_cursor.asm</td><td>změna tvaru textového kurzoru</td><td><a href="https://github.com/tisnik/8bit-fame/blob/master/pc-dos/cga_text_mode_cursor.asm">https://github.com/tisnik/8bit-fame/blob/master/pc-dos/cga_text_mode_cursor.asm</a></td></tr>
<tr><td>30</td><td>cga_text_gfx_1.asm</td><td>zobrazení &bdquo;rastrové mřížky&ldquo;: pseudografický režim 160&times;25 pixelů (interně textový režim)</td><td><a href="https://github.com/tisnik/8bit-fame/blob/master/pc-dos/cga_text_gfx_1.asm">https://github.com/tisnik/8bit-fame/blob/master/pc-dos/cga_text_gfx_1.asm</a></td></tr>
<tr><td>31</td><td>cga_text_mode_char_height.asm</td><td>změna výšky znaků</td><td><a href="https://github.com/tisnik/8bit-fame/blob/master/pc-dos/cga_text_mode_char_height.asm">https://github.com/tisnik/8bit-fame/blob/master/pc-dos/cga_text_mode_char_height.asm</a></td></tr>
<tr><td>32</td><td>cga_text_160x100.asm</td><td>grafický režim 160&times;100 se šestnácti barvami (interně upravený textový režim)</td><td><a href="https://github.com/tisnik/8bit-fame/blob/master/pc-dos/cga_text_160x100.asm">https://github.com/tisnik/8bit-fame/blob/master/pc-dos/cga_text_160x100.asm</a></td></tr>
<tr><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td></tr>
<tr><td>33</td><td>hercules_text_mode_1.asm</td><td>využití standardního textového režimu společně s&nbsp;kartou Hercules</td><td><a href="https://github.com/tisnik/8bit-fame/blob/master/pc-dos/hercules_text_mode_1.asm">https://github.com/tisnik/8bit-fame/blob/master/pc-dos/hercules_text_mode_1.asm</a></td></tr>
<tr><td>34</td><td>hercules_text_mode_2.asm</td><td>zákaz blikání v&nbsp;textových režimech</td><td><a href="https://github.com/tisnik/8bit-fame/blob/master/pc-dos/hercules_text_mode_2.asm">https://github.com/tisnik/8bit-fame/blob/master/pc-dos/hercules_text_mode_2.asm</a></td></tr>
<tr><td>35</td><td>hercules_turn_off.asm</td><td>vypnutí generování video signálu</td><td><a href="https://github.com/tisnik/8bit-fame/blob/master/pc-dos/hercules_turn_off.asm">https://github.com/tisnik/8bit-fame/blob/master/pc-dos/hercules_turn_off.asm</a></td></tr>
<tr><td>36</td><td>hercules_gfx_mode_1.asm</td><td>přepnutí karty Hercules do grafického režimu (základní varianta)</td><td><a href="https://github.com/tisnik/8bit-fame/blob/master/pc-dos/hercules_gfx_mode_1.asm">https://github.com/tisnik/8bit-fame/blob/master/pc-dos/hercules_gfx_mode_1.asm</a></td></tr>
<tr><td>37</td><td>hercules_gfx_mode_2.asm</td><td>přepnutí karty Hercules do grafického režimu (vylepšená varianta)</td><td><a href="https://github.com/tisnik/8bit-fame/blob/master/pc-dos/hercules_gfx_mode_2.asm">https://github.com/tisnik/8bit-fame/blob/master/pc-dos/hercules_gfx_mode_2.asm</a></td></tr>
<tr><td>38</td><td>hercules_putpixel.asm</td><td>subrutina pro vykreslení jediného pixelu na kartě Hercules</td><td><a href="https://github.com/tisnik/8bit-fame/blob/master/pc-dos/hercules_putpixel.asm">https://github.com/tisnik/8bit-fame/blob/master/pc-dos/hercules_putpixel.asm</a></td></tr>
<tr><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td></tr>
<tr><td>39</td><td>ega_text_mode_80x25.asm</td><td>standardní textový režim 80&times;25 znaků na kartě EGA</td><td><a href="https://github.com/tisnik/8bit-fame/blob/master/pc-dos/ega_text_mode_80x25.asm">https://github.com/tisnik/8bit-fame/blob/master/pc-dos/ega_text_mode_80x25.asm</a></td></tr>
<tr><td>40</td><td>ega_text_mode_80x43.asm</td><td>zobrazení 43 textových řádků na kartě EGA</td><td><a href="https://github.com/tisnik/8bit-fame/blob/master/pc-dos/ega_text_mode_80x43.asm">https://github.com/tisnik/8bit-fame/blob/master/pc-dos/ega_text_mode_80x43.asm</a></td></tr>
<tr><td>41</td><td>ega_gfx_mode_320x200.asm</td><td>přepnutí do grafického režimu 320&times;200 pixelů se šestnácti barvami</td><td><a href="https://github.com/tisnik/8bit-fame/blob/master/pc-dos/ega_gfx_mode_320x200.asm">https://github.com/tisnik/8bit-fame/blob/master/pc-dos/ega_gfx_mode_320x200.asm</a></td></tr>
<tr><td>42</td><td>ega_gfx_mode_640x200.asm</td><td>přepnutí do grafického režimu 640&times;200 pixelů se šestnácti barvami</td><td><a href="https://github.com/tisnik/8bit-fame/blob/master/pc-dos/ega_gfx_mode_640x200.asm">https://github.com/tisnik/8bit-fame/blob/master/pc-dos/ega_gfx_mode_640x200.asm</a></td></tr>
<tr><td>43</td><td>ega_gfx_mode_640x350.asm</td><td>přepnutí do grafického režimu 640&times;350 pixelů se čtyřmi nebo šestnácti barvami</td><td><a href="https://github.com/tisnik/8bit-fame/blob/master/pc-dos/ega_gfx_mode_640x350.asm">https://github.com/tisnik/8bit-fame/blob/master/pc-dos/ega_gfx_mode_640x350.asm</a></td></tr>
<tr><td>44</td><td>ega_gfx_mode_bitplanes_1.asm</td><td>ovládání zápisu do bitových rovin v&nbsp;planárních grafických režimech (základní způsob)</td><td><a href="https://github.com/tisnik/8bit-fame/blob/master/pc-dos/ega_gfx_mode_bitplanes_1.asm">https://github.com/tisnik/8bit-fame/blob/master/pc-dos/ega_gfx_mode_bitplanes_1.asm</a></td></tr>
<tr><td>45</td><td>ega_gfx_mode_bitplanes_2.asm</td><td>ovládání zápisu do bitových rovin v&nbsp;planárních grafických režimech (rychlejší způsob)</td><td><a href="https://github.com/tisnik/8bit-fame/blob/master/pc-dos/ega_gfx_mode_bitplanes_2.asm">https://github.com/tisnik/8bit-fame/blob/master/pc-dos/ega_gfx_mode_bitplanes_2.asm</a></td></tr>
<tr><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td></tr>
<tr><td>46</td><td>ega_320x200_putpixel.asm</td><td>vykreslení pixelu v&nbsp;grafickém režimu 320&times;200 pixelů se šestnácti barvami</td><td><a href="https://github.com/tisnik/8bit-fame/blob/master/pc-dos/ega_320x200_putpixel.asm">https://github.com/tisnik/8bit-fame/blob/master/pc-dos/ega_320x200_putpixel.asm</a></td></tr>
<tr><td>47</td><td>ega_640x350_putpixel.asm</td><td>vykreslení pixelu v&nbsp;grafickém režimu 640&times;350 pixelů se šestnácti barvami</td><td><a href="https://github.com/tisnik/8bit-fame/blob/master/pc-dos/ega_640x350_putpixel.asm">https://github.com/tisnik/8bit-fame/blob/master/pc-dos/ega_640x350_putpixel.asm</a></td></tr>
<tr><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td></tr>
<tr><td>48</td><td>ega_standard_font.asm</td><td>použití standardního fontu grafické karty EGA</td><td><a href="https://github.com/tisnik/8bit-fame/blob/master/pc-dos/ega_standard_font.asm">https://github.com/tisnik/8bit-fame/blob/master/pc-dos/ega_standard_font.asm</a></td></tr>
<tr><td>49</td><td>ega_custom_font.asm</td><td>načtení vlastního fontu s&nbsp;jeho zobrazením</td><td><a href="https://github.com/tisnik/8bit-fame/blob/master/pc-dos/ega_custom_font.asm">https://github.com/tisnik/8bit-fame/blob/master/pc-dos/ega_custom_font.asm</a></td></tr>
<tr><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td></tr>
<tr><td>50</td><td>ega_palette_1.asm</td><td>změna barvové palety (všech 16 barev) v&nbsp;grafickém režimu 320&times;200 se šestnácti barvami</td><td><a href="https://github.com/tisnik/8bit-fame/blob/master/pc-dos/ega_palette_1.asm">https://github.com/tisnik/8bit-fame/blob/master/pc-dos/ega_palette_1.asm</a></td></tr>
<tr><td>51</td><td>ega_palette_2.asm</td><td>změna barvové palety (všech 16 barev) v&nbsp;grafickém režimu 640&times;350 se šestnácti barvami</td><td><a href="https://github.com/tisnik/8bit-fame/blob/master/pc-dos/ega_palette_2.asm">https://github.com/tisnik/8bit-fame/blob/master/pc-dos/ega_palette_2.asm</a></td></tr>
<tr><td>52</td><td>ega_palette_3.asm</td><td>změna všech barev v&nbsp;barvové paletě s&nbsp;využitím programové smyčky</td><td><a href="https://github.com/tisnik/8bit-fame/blob/master/pc-dos/ega_palette_3.asm">https://github.com/tisnik/8bit-fame/blob/master/pc-dos/ega_palette_3.asm</a></td></tr>
<tr><td>53</td><td>ega_palette_4.asm</td><td>změna všech barev, včetně barvy okraje, v&nbsp;barvové paletě voláním funkce BIOSu</td><td><a href="https://github.com/tisnik/8bit-fame/blob/master/pc-dos/ega_palette_4.asm">https://github.com/tisnik/8bit-fame/blob/master/pc-dos/ega_palette_4.asm</a></td></tr>
<tr><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td></tr>
<tr><td>54</td><td>vga_text_mode_80x25.asm</td><td>standardní textový režim 80&times;25 znaků na kartě VGA</td><td><a href="https://github.com/tisnik/8bit-fame/blob/master/pc-dos/vga_text_mode_80x25.asm">https://github.com/tisnik/8bit-fame/blob/master/pc-dos/vga_text_mode_80x25.asm</a></td></tr>
<tr><td>55</td><td>vga_text_mode_80x50.asm</td><td>zobrazení 50 a taktéž 28 textových řádků na kartě VGA</td><td><a href="https://github.com/tisnik/8bit-fame/blob/master/pc-dos/vga_text_mode_80x50.asm">https://github.com/tisnik/8bit-fame/blob/master/pc-dos/vga_text_mode_80x50.asm</a></td></tr>
<tr><td>56</td><td>vga_text_mode_intensity_1.asm</td><td>změna chování atributového bitu pro blikání (nebezpečná varianta změny registrů)</td><td><a href="https://github.com/tisnik/8bit-fame/blob/master/pc-dos/vga_text_mode_intensity_1.asm">https://github.com/tisnik/8bit-fame/blob/master/pc-dos/vga_text_mode_intensity_1.asm</a></td></tr>
<tr><td>57</td><td>vga_text_mode_intensity_2.asm</td><td>změna chování atributového bitu pro blikání (bezpečnější varianta změny registrů)</td><td><a href="https://github.com/tisnik/8bit-fame/blob/master/pc-dos/vga_text_mode_intensity_2.asm">https://github.com/tisnik/8bit-fame/blob/master/pc-dos/vga_text_mode_intensity_2.asm</a></td></tr>
<tr><td>58</td><td>vga_text_mode_9th_column.asm</td><td>modifikace způsobu zobrazení devátého sloupce ve znakových režimech (720 pixelů na řádku)</td><td><a href="https://github.com/tisnik/8bit-fame/blob/master/pc-dos/vga_text_mode_9th_column.asm">https://github.com/tisnik/8bit-fame/blob/master/pc-dos/vga_text_mode_9th_column.asm</a></td></tr>
<tr><td>59</td><td>vga_text_mode_cursor_shape.asm</td><td>změna tvaru textového kurzoru na grafické kartě VGA</td><td><a href="https://github.com/tisnik/8bit-fame/blob/master/pc-dos/vga_text_mode_cursor_shape.asm">https://github.com/tisnik/8bit-fame/blob/master/pc-dos/vga_text_mode_cursor_shape.asm</a></td></tr>
<tr><td>60</td><td>vga_text_mode_custom_font.asm</td><td>načtení vlastního fontu s&nbsp;jeho zobrazením</td><td><a href="https://github.com/tisnik/8bit-fame/blob/master/pc-dos/vga_text_mode_custom_font.asm">https://github.com/tisnik/8bit-fame/blob/master/pc-dos/vga_text_mode_custom_font.asm</a></td></tr>
<tr><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td></tr>
<tr><td>61</td><td>vga_gfx_mode_640x480.asm</td><td>přepnutí do grafického režimu 640&times;480 pixelů se šestnácti barvami, vykreslení vzorků</td><td><a href="https://github.com/tisnik/8bit-fame/blob/master/pc-dos/vga_gfx_mode_640x480.asm">https://github.com/tisnik/8bit-fame/blob/master/pc-dos/vga_gfx_mode_640x480.asm</a></td></tr>
<tr><td>62</td><td>vga_gfx_mode_320x200.asm</td><td>přepnutí do grafického režimu 320&times;200 pixelů s&nbsp;256 barvami, vykreslení vzorků</td><td><a href="https://github.com/tisnik/8bit-fame/blob/master/pc-dos/vga_gfx_mode_320x200.asm">https://github.com/tisnik/8bit-fame/blob/master/pc-dos/vga_gfx_mode_320x200.asm</a></td></tr>
<tr><td>63</td><td>vga_gfx_mode_palette.asm</td><td>změna všech barev v&nbsp;barvové paletě grafické karty VGA</td><td><a href="https://github.com/tisnik/8bit-fame/blob/master/pc-dos/vga_gfx_mode_palette.asm">https://github.com/tisnik/8bit-fame/blob/master/pc-dos/vga_gfx_mode_palette.asm</a></td></tr>
<tr><td>64</td><td>vga_gfx_mode_dac_1.asm</td><td>využití DAC (neočekávané výsledky)</td><td><a href="https://github.com/tisnik/8bit-fame/blob/master/pc-dos/vga_gfx_mode_dac_1.asm">https://github.com/tisnik/8bit-fame/blob/master/pc-dos/vga_gfx_mode_dac_1.asm</a></td></tr>
<tr><td>65</td><td>vga_gfx_mode_dac_2.asm</td><td>využití DAC (očekávané výsledky)</td><td><a href="https://github.com/tisnik/8bit-fame/blob/master/pc-dos/vga_gfx_mode_dac_2.asm">https://github.com/tisnik/8bit-fame/blob/master/pc-dos/vga_gfx_mode_dac_2.asm</a></td></tr>
<tr><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td></tr>
<tr><td>66</td><td>vga_640x480_putpixel.asm</td><td>realizace algoritmu pro vykreslení pixelu v&nbsp;grafickém režimu 640&times;480 pixelů se šestnácti barvami</td><td><a href="https://github.com/tisnik/8bit-fame/blob/master/pc-dos/vga_640x480_putpixel.asm">https://github.com/tisnik/8bit-fame/blob/master/pc-dos/vga_640x480_putpixel.asm</a></td></tr>
<tr><td>67</td><td>vga_320x200_putpixel_1.asm</td><td>realizace algoritmu pro vykreslení pixelu v&nbsp;grafickém režimu 320&times;200 s&nbsp;256 barvami (základní varianta)</td><td><a href="https://github.com/tisnik/8bit-fame/blob/master/pc-dos/vga_320x200_putpixel_1.asm">https://github.com/tisnik/8bit-fame/blob/master/pc-dos/vga_320x200_putpixel_1.asm</a></td></tr>
<tr><td>68</td><td>vga_320x200_putpixel_2.asm</td><td>realizace algoritmu pro vykreslení pixelu v&nbsp;grafickém režimu 320&times;200 s&nbsp;256 barvami (rychlejší varianta)</td><td><a href="https://github.com/tisnik/8bit-fame/blob/master/pc-dos/vga_320x200_putpixel_2.asm">https://github.com/tisnik/8bit-fame/blob/master/pc-dos/vga_320x200_putpixel_2.asm</a></td></tr>
<tr><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td></tr>
<tr><td>69</td><td>vga_gfx_mode_dac_3.asm</td><td>přímé využití DAC v&nbsp;grafickém režimu 13h</td><td><a href="https://github.com/tisnik/8bit-fame/blob/master/pc-dos/vga_gfx_mode_dac_3.asm">https://github.com/tisnik/8bit-fame/blob/master/pc-dos/vga_gfx_mode_dac_3.asm</a></td></tr>
<tr><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td></tr>
<tr><td>70</td><td>vga_gfx_mode_unchained_step_1.asm</td><td>zobrazení barevných pruhů v&nbsp;režimu 13h</td><td><a href="https://github.com/tisnik/8bit-fame/blob/master/pc-dos/vga_gfx_mode_unchained_step_1.asm">https://github.com/tisnik/8bit-fame/blob/master/pc-dos/vga_gfx_mode_unchained_step_1.asm</a></td></tr>
<tr><td>71</td><td>vga_gfx_mode_unchained_step_2.asm</td><td>vypnutí zřetězení bitových rovin a změna způsobu adresování pixelů</td><td><a href="https://github.com/tisnik/8bit-fame/blob/master/pc-dos/vga_gfx_mode_unchained_step_2.asm">https://github.com/tisnik/8bit-fame/blob/master/pc-dos/vga_gfx_mode_unchained_step_2.asm</a></td></tr>
<tr><td>72</td><td>vga_gfx_mode_unchained_step_3.asm</td><td>vykreslení barevných pruhů do vybraných bitových rovin</td><td><a href="https://github.com/tisnik/8bit-fame/blob/master/pc-dos/vga_gfx_mode_unchained_step_3.asm">https://github.com/tisnik/8bit-fame/blob/master/pc-dos/vga_gfx_mode_unchained_step_3.asm</a></td></tr>
<tr><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td></tr>
<tr><td>73</td><td>vga_gfx_mode_320x400.asm</td><td>nestandardní grafický režim s&nbsp;rozlišením 320&times;400 pixelů a 256 barvami</td><td><a href="https://github.com/tisnik/8bit-fame/blob/master/pc-dos/vga_gfx_mode_320x400.asm">https://github.com/tisnik/8bit-fame/blob/master/pc-dos/vga_gfx_mode_320x400.asm</a></td></tr>
<tr><td>74</td><td>vga_320x200_image.asm</td><td>zobrazení rastrového obrázku ve standardním grafickém režimu 320&times;200 pixelů</td><td><a href="https://github.com/tisnik/8bit-fame/blob/master/pc-dos/vga_320x200_image.asm">https://github.com/tisnik/8bit-fame/blob/master/pc-dos/vga_320x200_image.asm</a></td></tr>
<tr><td>75</td><td>vga_320x200_unchained_image_1.asm</td><td>zobrazení rastrového obrázku v&nbsp;režimu s&nbsp;nezřetězenými rovinami (nekorektní řešení)</td><td><a href="https://github.com/tisnik/8bit-fame/blob/master/pc-dos/vga_320x200_unchained_image_1.asm">https://github.com/tisnik/8bit-fame/blob/master/pc-dos/vga_320x200_unchained_image_1.asm</a></td></tr>
<tr><td>76</td><td>vga_320x200_unchained_image_2.asm</td><td>zobrazení rastrového obrázku v&nbsp;režimu s&nbsp;nezřetězenými rovinami (korektní řešení)</td><td><a href="https://github.com/tisnik/8bit-fame/blob/master/pc-dos/vga_320x200_unchained_image_2.asm">https://github.com/tisnik/8bit-fame/blob/master/pc-dos/vga_320x200_unchained_image_2.asm</a></td></tr>
<tr><td>77</td><td>vga_320x400_unchained_image.asm</td><td>zobrazení rastrového obrázku v&nbsp;nestandardním režimu 320&times;400 pixelů</td><td><a href="https://github.com/tisnik/8bit-fame/blob/master/pc-dos/vga_320x400_unchained_image.asm">https://github.com/tisnik/8bit-fame/blob/master/pc-dos/vga_320x400_unchained_image.asm</a></td></tr>
<tr><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td></tr>
<tr><td>78</td><td>vga_vertical_scroll_1.asm</td><td>vertikální scrolling na kartě VGA v&nbsp;režimu s&nbsp;rozlišením 320&times;200 pixelů</td><td><a href="https://github.com/tisnik/8bit-fame/blob/master/pc-dos/vga_vertical_scroll_1.asm">https://github.com/tisnik/8bit-fame/blob/master/pc-dos/vga_vertical_scroll_1.asm</a></td></tr>
<tr><td>79</td><td>vga_vertical_scroll_2.asm</td><td>vertikální scrolling na kartě VGA v&nbsp;režimu s&nbsp;rozlišením 320&times;400 pixelů</td><td><a href="https://github.com/tisnik/8bit-fame/blob/master/pc-dos/vga_vertical_scroll_2.asm">https://github.com/tisnik/8bit-fame/blob/master/pc-dos/vga_vertical_scroll_2.asm</a></td></tr>
<tr><td>80</td><td>vga_split_screen_1.asm</td><td>režim split-screen a scrolling, nefunční varianta</td><td><a href="https://github.com/tisnik/8bit-fame/blob/master/pc-dos/vga_split_screen_1.asm">https://github.com/tisnik/8bit-fame/blob/master/pc-dos/vga_split_screen_1.asm</a></td></tr>
<tr><td>81</td><td>vga_split_screen_2.asm</td><td>režim split-screen a scrolling, plně funkční varianta</td><td><a href="https://github.com/tisnik/8bit-fame/blob/master/pc-dos/vga_split_screen_2.asm">https://github.com/tisnik/8bit-fame/blob/master/pc-dos/vga_split_screen_2.asm</a></td></tr>
<tr><td>82</td><td>vga_horizontal_scroll_1.asm</td><td>horizontální scrolling bez rozšíření počtu pixelů na virtuálním řádku</td><td><a href="https://github.com/tisnik/8bit-fame/blob/master/pc-dos/vga_horizontal_scroll_1.asm">https://github.com/tisnik/8bit-fame/blob/master/pc-dos/vga_horizontal_scroll_1.asm</a></td></tr>
<tr><td>83</td><td>vga_horizontal_scroll_2.asm</td><td>horizontální scrolling s&nbsp;rozšířením počtu pixelů na virtuálním řádku</td><td><a href="https://github.com/tisnik/8bit-fame/blob/master/pc-dos/vga_horizontal_scroll_2.asm">https://github.com/tisnik/8bit-fame/blob/master/pc-dos/vga_horizontal_scroll_2.asm</a></td></tr>
<tr><td>84</td><td>vga_horizontal_scroll_3.asm</td><td>jemný horizontální scrolling s&nbsp;rozšířením počtu pixelů na virtuálním řádku</td><td><a href="https://github.com/tisnik/8bit-fame/blob/master/pc-dos/vga_horizontal_scroll_3.asm">https://github.com/tisnik/8bit-fame/blob/master/pc-dos/vga_horizontal_scroll_3.asm</a></td></tr>
<tr><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td></tr>
<tr><td>85</td><td>vga_320x240_image.asm</td><td>nastavení grafického režimu Mode-X, načtení a vykreslení obrázku, scrolling</td><td><a href="https://github.com/tisnik/8bit-fame/blob/master/pc-dos/vga_320x240_image.asm">https://github.com/tisnik/8bit-fame/blob/master/pc-dos/vga_320x240_image.asm</a></td></tr>
<tr><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td></tr>
<tr><td>86</td><td>io.asm</td><td>knihovna maker pro I/O operace</td><td><a href="https://github.com/tisnik/8bit-fame/blob/master/pc-dos/io.asm">https://github.com/tisnik/8bit-fame/blob/master/pc-dos/io.asm</a></td></tr>
<tr><td>87</td><td>vga_lib.asm</td><td>knihovna maker a podprogramů pro programování karty VGA</td><td><a href="https://github.com/tisnik/8bit-fame/blob/master/pc-dos/vga_lib.asm">https://github.com/tisnik/8bit-fame/blob/master/pc-dos/vga_lib.asm</a></td></tr>
<tr><td>88</td><td>vga_320x240_lib.asm</td><td>nastavení grafického režimu Mode-X, tentokrát knihovními funkcemi</td><td><a href="https://github.com/tisnik/8bit-fame/blob/master/pc-dos/vga_320x240_lib.asm">https://github.com/tisnik/8bit-fame/blob/master/pc-dos/vga_320x240_lib.asm</a></td></tr>
<tr><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td></tr>
<tr><td>89</td><td>vga_bitblt_1.asm</td><td>první (naivní) implementace operace <i>BitBLT</i></td><td><a href="https://github.com/tisnik/8bit-fame/blob/master/pc-dos/vga_bitblt_1.asm">https://github.com/tisnik/8bit-fame/blob/master/pc-dos/vga_bitblt_1.asm</a></td></tr>
<tr><td>90</td><td>vga_bitblt_2.asm</td><td>operace <i>BitBLT</i> s&nbsp;výběrem bitových rovin pro zápis</td><td><a href="https://github.com/tisnik/8bit-fame/blob/master/pc-dos/vga_bitblt_2.asm">https://github.com/tisnik/8bit-fame/blob/master/pc-dos/vga_bitblt_2.asm</a></td></tr>
<tr><td>91</td><td>vga_bitblt_3.asm</td><td>operace <i>BitBLT</i> s&nbsp;výběrem bitových rovin pro čtení i zápis</td><td><a href="https://github.com/tisnik/8bit-fame/blob/master/pc-dos/vga_bitblt_3.asm">https://github.com/tisnik/8bit-fame/blob/master/pc-dos/vga_bitblt_3.asm</a></td></tr>
<tr><td>92</td><td>vga_bitblt_4.asm</td><td>korektní <i>BitBLT</i> pro 16barevný režim, realizace makry</td><td><a href="https://github.com/tisnik/8bit-fame/blob/master/pc-dos/vga_bitblt_4.asm">https://github.com/tisnik/8bit-fame/blob/master/pc-dos/vga_bitblt_4.asm</a></td></tr>
<tr><td>93</td><td>vga_bitblt_5.asm</td><td>korektní <i>BitBLT</i> pro 16barevný režim, realizace podprogramem</td><td><a href="https://github.com/tisnik/8bit-fame/blob/master/pc-dos/vga_bitblt_5.asm">https://github.com/tisnik/8bit-fame/blob/master/pc-dos/vga_bitblt_5.asm</a></td></tr>
<tr><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td></tr>
<tr><td>94</td><td>vga_bitblt_rotate.asm</td><td>zápisový režim s&nbsp;rotací bajtu</td><td><a href="https://github.com/tisnik/8bit-fame/blob/master/pc-dos/vga_bitblt_rotate.asm">https://github.com/tisnik/8bit-fame/blob/master/pc-dos/vga_bitblt_rotate.asm</a></td></tr>
<tr><td>95</td><td>vga_bitblt_fast.asm</td><td>rychlá korektní 32bitová operace typu <i>BitBLT</i></td><td><a href="https://github.com/tisnik/8bit-fame/blob/master/pc-dos/vga_bitblt_fast.asm">https://github.com/tisnik/8bit-fame/blob/master/pc-dos/vga_bitblt_fast.asm</a></td></tr>
<tr><td>96</td><td>vga_320x400_bitblt_1.asm</td><td>přenos obrázku v&nbsp;režimu 320&times;400 operací <i>BitBLT</i> (neúplná varianta)</td><td><a href="https://github.com/tisnik/8bit-fame/blob/master/pc-dos/vga_320x400_bitblt_1.asm">https://github.com/tisnik/8bit-fame/blob/master/pc-dos/vga_320x400_bitblt_1.asm</a></td></tr>
<tr><td>97</td><td>vga_320x400_bitblt_2.asm</td><td>přenos obrázku v&nbsp;režimu 320&times;400 operací <i>BitBLT</i> (úplná varianta)</td><td><a href="https://github.com/tisnik/8bit-fame/blob/master/pc-dos/vga_320x400_bitblt_2.asm">https://github.com/tisnik/8bit-fame/blob/master/pc-dos/vga_320x400_bitblt_2.asm</a></td></tr>
<tr><td>98</td><td>vga_write_modes_1.asm</td><td>volitelné zápisové režimy grafické karty VGA, zápis bez úpravy latche</td><td><a href="https://github.com/tisnik/8bit-fame/blob/master/pc-dos/vga_write_modes_1.asm">https://github.com/tisnik/8bit-fame/blob/master/pc-dos/vga_write_modes_1.asm</a></td></tr>
<tr><td>99</td><td>vga_write_modes_2.asm</td><td>volitelné zápisové režimy grafické karty VGA, zápis s&nbsp;modifikací latche</td><td><a href="https://github.com/tisnik/8bit-fame/blob/master/pc-dos/vga_write_modes_2.asm">https://github.com/tisnik/8bit-fame/blob/master/pc-dos/vga_write_modes_2.asm</a></td></tr>
<tr><td>100</td><td>vga_write_modes_3.asm</td><td>volitelné zápisové režimy grafické karty VGA, cílená modifikace latche vzorkem</td><td><a href="https://github.com/tisnik/8bit-fame/blob/master/pc-dos/vga_write_modes_3.asm">https://github.com/tisnik/8bit-fame/blob/master/pc-dos/vga_write_modes_3.asm</a></td></tr>
<tr><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td></tr>
<tr><td>101</td><td>instruction_jump.asm</td><td>použití instrukce <strong>JMP</strong></td><td><a href="https://github.com/tisnik/8bit-fame/blob/master/pc-dos/instruction_jump.asm">https://github.com/tisnik/8bit-fame/blob/master/pc-dos/instruction_jump.asm</a></td></tr>
<tr><td>102</td><td>instruction_jnz.asm</td><td>použití instrukce <strong>JNZ</strong> pro realizaci programové smyčky</td><td><a href="https://github.com/tisnik/8bit-fame/blob/master/pc-dos/instruction_jnz.asm">https://github.com/tisnik/8bit-fame/blob/master/pc-dos/instruction_jnz.asm</a></td></tr>
<tr><td>103</td><td>instruction_jz_jmp.asm</td><td>použití instrukcí <strong>JZ</strong> a <strong>JMP</strong> pro realizaci programové smyčky</td><td><a href="https://github.com/tisnik/8bit-fame/blob/master/pc-dos/instruction_jz_jmp.asm">https://github.com/tisnik/8bit-fame/blob/master/pc-dos/instruction_jz_jmp.asm</a></td></tr>
<tr><td>104</td><td>instruction_loop.asm</td><td>použití instrukce <strong>LOOP</strong> pro realizaci programové smyčky</td><td><a href="https://github.com/tisnik/8bit-fame/blob/master/pc-dos/instruction_loop.asm">https://github.com/tisnik/8bit-fame/blob/master/pc-dos/instruction_loop.asm</a></td></tr>
<tr><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td></tr>
<tr><td>105</td><td>instruction_template.asm</td><td>šablona všech následujících demonstračních příkladů</td><td><a href="https://github.com/tisnik/8bit-fame/blob/master/pc-dos/instruction_template.asm">https://github.com/tisnik/8bit-fame/blob/master/pc-dos/instruction_template.asm</a></td></tr>
<tr><td>106</td><td>instruction_print_hex.asm</td><td>tisk osmibitové hexadecimální hodnoty</td><td><a href="https://github.com/tisnik/8bit-fame/blob/master/pc-dos/instruction_print_hex.asm">https://github.com/tisnik/8bit-fame/blob/master/pc-dos/instruction_print_hex.asm</a></td></tr>
<tr><td>107</td><td>instruction_xlat.asm</td><td>využití instrukce <strong>XLAT</strong> pro získání tisknutelné hexadecimální cifry</td><td><a href="https://github.com/tisnik/8bit-fame/blob/master/pc-dos/instruction_xlat.asm">https://github.com/tisnik/8bit-fame/blob/master/pc-dos/instruction_xlat.asm</a></td></tr>
<tr><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td></tr>
<tr><td>108</td><td>instruction_daa.asm</td><td>operace součtu s&nbsp;využitím binární i BCD aritmetiky</td><td><a href="https://github.com/tisnik/8bit-fame/blob/master/pc-dos/instruction_daa.asm">https://github.com/tisnik/8bit-fame/blob/master/pc-dos/instruction_daa.asm</a></td></tr>
<tr><td>109</td><td>instruction_daa_sub.asm</td><td>instrukce <strong>DAA</strong> po provedení operace rozdílu</td><td><a href="https://github.com/tisnik/8bit-fame/blob/master/pc-dos/instruction_daa_sub.asm">https://github.com/tisnik/8bit-fame/blob/master/pc-dos/instruction_daa_sub.asm</a></td></tr>
<tr><td>110</td><td>instruction_das.asm</td><td>instrukce <strong>DAS</strong> po provedení operace rozdílu</td><td><a href="https://github.com/tisnik/8bit-fame/blob/master/pc-dos/instruction_das.asm">https://github.com/tisnik/8bit-fame/blob/master/pc-dos/instruction_das.asm</a></td></tr>
<tr><td>111</td><td>instruction_aaa.asm</td><td>korekce výsledku na jedinou BCD cifru operací <strong>AAA</strong></td><td><a href="https://github.com/tisnik/8bit-fame/blob/master/pc-dos/instruction_aaa.asm">https://github.com/tisnik/8bit-fame/blob/master/pc-dos/instruction_aaa.asm</a></td></tr>
<tr><td>112</td><td>instruction_mul.asm</td><td>ukázka výpočtu součinu dvou osmibitových hodnot</td><td><a href="https://github.com/tisnik/8bit-fame/blob/master/pc-dos/instruction_mul.asm">https://github.com/tisnik/8bit-fame/blob/master/pc-dos/instruction_mul.asm</a></td></tr>
<tr><td>113</td><td>instruction_aam.asm</td><td>BCD korekce po výpočtu součinu instrukcí <strong>AAM</strong></td><td><a href="https://github.com/tisnik/8bit-fame/blob/master/pc-dos/instruction_aam.asm">https://github.com/tisnik/8bit-fame/blob/master/pc-dos/instruction_aam.asm</a></td></tr>
<tr><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td></tr>
<tr><td>114</td><td>instruction_stosb.asm</td><td>blokový zápis dat instrukcí <strong>STOSB</strong></td><td><a href="https://github.com/tisnik/8bit-fame/blob/master/pc-dos/instruction_stosb.asm">https://github.com/tisnik/8bit-fame/blob/master/pc-dos/instruction_stosb.asm</a></td></tr>
<tr><td>115</td><td>instruction_rep_stosb.asm</td><td>opakované provádění instrukce <strong>STOSB</strong></td><td><a href="https://github.com/tisnik/8bit-fame/blob/master/pc-dos/instruction_rep_stosb.asm">https://github.com/tisnik/8bit-fame/blob/master/pc-dos/instruction_rep_stosb.asm</a></td></tr>
<tr><td>116</td><td>instruction_lodsb.asm</td><td>čtení dat instrukcí <strong>LODSB</strong></td><td><a href="https://github.com/tisnik/8bit-fame/blob/master/pc-dos/instruction_lodsb.asm">https://github.com/tisnik/8bit-fame/blob/master/pc-dos/instruction_lodsb.asm</a></td></tr>
<tr><td>117</td><td>instruction_movsb.asm</td><td>přenos jednoho bajtu instrukcí <strong>MOVSB</strong></td><td><a href="https://github.com/tisnik/8bit-fame/blob/master/pc-dos/instruction_movsb.asm">https://github.com/tisnik/8bit-fame/blob/master/pc-dos/instruction_movsb.asm</a></td></tr>
<tr><td>118</td><td>instruction_rep_movsb.asm</td><td>blokový přenos po bajtech instrukcí <strong>MOVSB</strong></td><td><a href="https://github.com/tisnik/8bit-fame/blob/master/pc-dos/instruction_rep_movsb.asm">https://github.com/tisnik/8bit-fame/blob/master/pc-dos/instruction_rep_movsb.asm</a></td></tr>
<tr><td>119</td><td>instruction_rep_scas.asm</td><td>vyhledávání v&nbsp;řetězci instrukcí <strong>SCAS</strong></td><td><a href="https://github.com/tisnik/8bit-fame/blob/master/pc-dos/instruction_rep_scas.asm">https://github.com/tisnik/8bit-fame/blob/master/pc-dos/instruction_rep_scas.asm</a></td></tr>
<tr><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td></tr>
<tr><td>120</td><td>vga_320x200_image_0B.asm</td><td>výsledek blokového přenosu ve chvíli, kdy je <strong>CX=0</strong></td><td><a href="https://github.com/tisnik/8bit-fame/blob/master/pc-dos/vga_320x200_image_0B.asm">https://github.com/tisnik/8bit-fame/blob/master/pc-dos/vga_320x200_image_0B.asm</a></td></tr>
<tr><td>121</td><td>vga_320x200_image_64kB.asm</td><td>výsledek blokového přenosu ve chvíli, kdy je <strong>CX=0xffff</strong></td><td><a href="https://github.com/tisnik/8bit-fame/blob/master/pc-dos/vga_320x200_image_64kB.asm">https://github.com/tisnik/8bit-fame/blob/master/pc-dos/vga_320x200_image_64kB.asm</a></td></tr>
<tr><td>122</td><td>vga_320x200_image_movsb.asm</td><td>blokový přenos v&nbsp;rámci obrazové paměti instrukcí <strong>REP MOVSB</strong></td><td><a href="https://github.com/tisnik/8bit-fame/blob/master/pc-dos/vga_320x200_image_movsb.asm">https://github.com/tisnik/8bit-fame/blob/master/pc-dos/vga_320x200_image_movsb.asm</a></td></tr>
<tr><td>123</td><td>vga_320x200_image_movsw.asm</td><td>blokový přenos v&nbsp;rámci obrazové paměti instrukcí <strong>REP MOVSW</strong></td><td><a href="https://github.com/tisnik/8bit-fame/blob/master/pc-dos/vga_320x200_image_movsw.asm">https://github.com/tisnik/8bit-fame/blob/master/pc-dos/vga_320x200_image_movsw.asm</a></td></tr>
<tr><td>124</td><td>vga_320x200_image_movsd.asm</td><td>blokový přenos v&nbsp;rámci obrazové paměti instrukcí <strong>REP MOVSD</strong></td><td><a href="https://github.com/tisnik/8bit-fame/blob/master/pc-dos/vga_320x200_image_movsd.asm">https://github.com/tisnik/8bit-fame/blob/master/pc-dos/vga_320x200_image_movsd.asm</a></td></tr>
<tr><td>125</td><td>vga_320x200_image_movsb_forward.asm</td><td>blokový přenos překrývajících se bloků paměti (zvyšující se adresy)</td><td><a href="https://github.com/tisnik/8bit-fame/blob/master/pc-dos/vga_320x200_image_movsb_forward.asm">https://github.com/tisnik/8bit-fame/blob/master/pc-dos/vga_320x200_image_movsb_forward.asm</a></td></tr>
<tr><td>126</td><td>vga_320x200_image_movsb_backward_1.asm</td><td>blokový přenos překrývajících se bloků paměti (snižující se adresy, nekorektní nastavení)</td><td><a href="https://github.com/tisnik/8bit-fame/blob/master/pc-dos/vga_320x200_image_movsb_backward_1.asm">https://github.com/tisnik/8bit-fame/blob/master/pc-dos/vga_320x200_image_movsb_backward_1.asm</a></td></tr>
<tr><td>127</td><td>vga_320x200_image_movsb_backward_2.asm</td><td>blokový přenos překrývajících se bloků paměti (snižující se adresy, korektní nastavení)</td><td><a href="https://github.com/tisnik/8bit-fame/blob/master/pc-dos/vga_320x200_image_movsb_backward_2.asm">https://github.com/tisnik/8bit-fame/blob/master/pc-dos/vga_320x200_image_movsb_backward_2.asm</a></td></tr>
<tr><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td></tr>
<tr><td>128</td><td>sound_bell.asm</td><td>přehrání zvuku pomocí tisku ASCII znaku BELL</td><td><a href="https://github.com/tisnik/8bit-fame/blob/master/pc-dos/sound_bell.asm">https://github.com/tisnik/8bit-fame/blob/master/pc-dos/sound_bell.asm</a></td></tr>
<tr><td>129</td><td>sound_beep.asm</td><td>přehrání zvuku o zadané frekvenci na PC Speakeru</td><td><a href="https://github.com/tisnik/8bit-fame/blob/master/pc-dos/sound_beep.asm">https://github.com/tisnik/8bit-fame/blob/master/pc-dos/sound_beep.asm</a></td></tr>
<tr><td>130</td><td>sound_play_pitch.asm</td><td>přehrání zvuku o zadané frekvenci na PC Speakeru, použití maker</td><td><a href="https://github.com/tisnik/8bit-fame/blob/master/pc-dos/sound_play_pitch.asm">https://github.com/tisnik/8bit-fame/blob/master/pc-dos/sound_play_pitch.asm</a></td></tr>
<tr><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td></tr>
<tr><td>131</td><td>sound_opl2_basic.asm</td><td>přehrání komorního A na OPL2</td><td><a href="https://github.com/tisnik/8bit-fame/blob/master/pc-dos/sound_opl2_basic.asm">https://github.com/tisnik/8bit-fame/blob/master/pc-dos/sound_opl2_basic.asm</a></td></tr>
<tr><td>132</td><td>sound_opl2_table.asm</td><td>přehrání komorního A na OPL2, použití tabulky s&nbsp;hodnotami registrů</td><td><a href="https://github.com/tisnik/8bit-fame/blob/master/pc-dos/sound_opl2_table.asm">https://github.com/tisnik/8bit-fame/blob/master/pc-dos/sound_opl2_table.asm</a></td></tr>
<tr><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td></tr>
<tr><td>133</td><td>sound_opl2_table_2.asm</td><td>přepis tabulky s&nbsp;obsahy registrů pro přehrání komorního A</td><td><a href="https://github.com/tisnik/8bit-fame/blob/master/pc-dos/sound_opl2_table_2.asm">https://github.com/tisnik/8bit-fame/blob/master/pc-dos/sound_opl2_table_2.asm</a></td></tr>
<tr><td>134</td><td>sound_key_on.asm</td><td>přímé ovládání bitu KEY ON mezerníkem</td><td><a href="https://github.com/tisnik/8bit-fame/blob/master/pc-dos/sound_key_on.asm">https://github.com/tisnik/8bit-fame/blob/master/pc-dos/sound_key_on.asm</a></td></tr>
<tr><td>135</td><td>sound_adsr.asm</td><td>nastavení obálky pro tón přehrávaný prvním kanálem</td><td><a href="https://github.com/tisnik/8bit-fame/blob/master/pc-dos/sound_adsr.asm">https://github.com/tisnik/8bit-fame/blob/master/pc-dos/sound_adsr.asm</a></td></tr>
<tr><td>136</td><td>sound_modulation.asm</td><td>řízení frekvence modulátoru klávesami 1 a 0</td><td><a href="https://github.com/tisnik/8bit-fame/blob/master/pc-dos/sound_modulation.asm">https://github.com/tisnik/8bit-fame/blob/master/pc-dos/sound_modulation.asm</a></td></tr>
<tr><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td></tr>
<tr><td>137</td><td>keyboard_basic.asm</td><td>přímá práce s&nbsp;klávesnicí IBM PC</td><td><a href="https://github.com/tisnik/8bit-fame/blob/master/pc-dos/keyboard_basic.asm">https://github.com/tisnik/8bit-fame/blob/master/pc-dos/keyboard_basic.asm</a></td></tr>
<tr><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td></tr>
<tr><td>138</td><td>sound_stereo_opl2.asm</td><td>stereo zvuk v&nbsp;konfiguraci DualOPL2</td><td><a href="https://github.com/tisnik/8bit-fame/blob/master/pc-dos/sound_stereo_opl2.asm">https://github.com/tisnik/8bit-fame/blob/master/pc-dos/sound_stereo_opl2.asm</a></td></tr>
<tr><td>139</td><td>sound_opl2_multichannel.asm</td><td>vícekanálový zvuk na OPL2 (klávesy), delší varianta</td><td><a href="https://github.com/tisnik/8bit-fame/blob/master/pc-dos/sound_opl2_multichannel.asm">https://github.com/tisnik/8bit-fame/blob/master/pc-dos/sound_opl2_multichannel.asm</a></td></tr>
<tr><td>140</td><td>sound_opl2_multichannel_2.asm</td><td>vícekanálový zvuk na OPL2 (klávesy), kratší varianta</td><td><a href="https://github.com/tisnik/8bit-fame/blob/master/pc-dos/sound_opl2_multichannel_2.asm">https://github.com/tisnik/8bit-fame/blob/master/pc-dos/sound_opl2_multichannel_2.asm</a></td></tr>
<tr><td>141</td><td>sound_opl3_stereo_1.asm</td><td>stereo výstup na OPL3 (v&nbsp;kompatibilním režimu)</td><td><a href="https://github.com/tisnik/8bit-fame/blob/master/pc-dos/sound_opl3_stereo_1.asm">https://github.com/tisnik/8bit-fame/blob/master/pc-dos/sound_opl3_stereo_1.asm</a></td></tr>
<tr><td>142</td><td>sound_opl3_stereo_2.asm</td><td>stereo výstup na OPL3 (v&nbsp;režimu OPL3)</td><td><a href="https://github.com/tisnik/8bit-fame/blob/master/pc-dos/sound_opl3_stereo_2.asm">https://github.com/tisnik/8bit-fame/blob/master/pc-dos/sound_opl3_stereo_2.asm</a></td></tr>
<tr><td>143</td><td>sound_opl3_multichannel.asm</td><td>vícekanálový zvuk na OPL3 (klávesy)</td><td><a href="https://github.com/tisnik/8bit-fame/blob/master/pc-dos/sound_opl3_multichannel.asm">https://github.com/tisnik/8bit-fame/blob/master/pc-dos/sound_opl3_multichannel.asm</a></td></tr>
<tr><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td></tr>
<tr><td>144</td><td>sound_opl3_waveform_1.asm</td><td>interaktivní modifikace tvaru vlny u prvního operátoru</td><td><a href="https://github.com/tisnik/8bit-fame/blob/master/pc-dos/sound_opl3_waveform_1.asm">https://github.com/tisnik/8bit-fame/blob/master/pc-dos/sound_opl3_waveform_1.asm</a></td></tr>
<tr><td>145</td><td>sound_opl3_waveform_2.asm</td><td>oprava chyby: povolení režimu kompatibilního s&nbsp;OPL3</td><td><a href="https://github.com/tisnik/8bit-fame/blob/master/pc-dos/sound_opl3_waveform_2.asm">https://github.com/tisnik/8bit-fame/blob/master/pc-dos/sound_opl3_waveform_2.asm</a></td></tr>
<tr><td>146</td><td>sound_opl3_waveform_3.asm</td><td>vliv tvaru vln na zvukový kanál s&nbsp;FM syntézou</td><td><a href="https://github.com/tisnik/8bit-fame/blob/master/pc-dos/sound_opl3_waveform_3.asm">https://github.com/tisnik/8bit-fame/blob/master/pc-dos/sound_opl3_waveform_3.asm</a></td></tr>
<tr><td>147</td><td>sound_opl3_waveform_4.asm</td><td>modifikace tvaru vlny nosné vlny i modulátoru</td><td><a href="https://github.com/tisnik/8bit-fame/blob/master/pc-dos/sound_opl3_waveform_4.asm">https://github.com/tisnik/8bit-fame/blob/master/pc-dos/sound_opl3_waveform_4.asm</a></td></tr>
<tr><td>148</td><td>sound_opl3_4operators_1.asm</td><td>výběr AM/FM režimu ve čtyřoperátorovém nastavení</td><td><a href="https://github.com/tisnik/8bit-fame/blob/master/pc-dos/sound_opl3_4operators_1.asm">https://github.com/tisnik/8bit-fame/blob/master/pc-dos/sound_opl3_4operators_1.asm</a></td></tr>
<tr><td>149</td><td>sound_opl3_4operators_2.asm</td><td>výběr AM/FM režimu ve čtyřoperátorovém nastavení</td><td><a href="https://github.com/tisnik/8bit-fame/blob/master/pc-dos/sound_opl3_4operators_2.asm">https://github.com/tisnik/8bit-fame/blob/master/pc-dos/sound_opl3_4operators_2.asm</a></td></tr>
<tr><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td></tr>
<tr><td>150</td><td>timer_basic.asm</td><td>základní obsluha přerušení od časovače/čítače</td><td><a href="https://github.com/tisnik/8bit-fame/blob/master/pc-dos/timer_basic.asm">https://github.com/tisnik/8bit-fame/blob/master/pc-dos/timer_basic.asm</a></td></tr>
<tr><td>151</td><td>timer_restore.asm</td><td>obnovení původní obsluhy přerušení při ukončování aplikace</td><td><a href="https://github.com/tisnik/8bit-fame/blob/master/pc-dos/timer_restore.asm">https://github.com/tisnik/8bit-fame/blob/master/pc-dos/timer_restore.asm</a></td></tr>
<tr><td>152</td><td>timer_restore_better_structure.asm</td><td>refaktoring předchozího demonstračního příkladu</td><td><a href="https://github.com/tisnik/8bit-fame/blob/master/pc-dos/timer_restore_better_structure.asm">https://github.com/tisnik/8bit-fame/blob/master/pc-dos/timer_restore_better_structure.asm</a></td></tr>
<tr><td>153</td><td>timer_faster_clock.asm</td><td>zrychlení čítače na 100 přerušení za sekundu</td><td><a href="https://github.com/tisnik/8bit-fame/blob/master/pc-dos/timer_faster_clock.asm">https://github.com/tisnik/8bit-fame/blob/master/pc-dos/timer_faster_clock.asm</a></td></tr>
<tr><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td></tr>
<tr><td>154</td><td>instruction_push_imm.asm</td><td>instrukce <strong>PUSH</strong> s&nbsp;konstantou</td><td><a href="https://github.com/tisnik/8bit-fame/blob/master/pc-dos/instruction_push_imm.asm">https://github.com/tisnik/8bit-fame/blob/master/pc-dos/instruction_push_imm.asm</a></td></tr>
<tr><td>155</td><td>instruction_imul_imm.asm</td><td>instrukce <strong>IMUL</strong> s&nbsp;konstantou</td><td><a href="https://github.com/tisnik/8bit-fame/blob/master/pc-dos/instruction_imul_imm.asm">https://github.com/tisnik/8bit-fame/blob/master/pc-dos/instruction_imul_imm.asm</a></td></tr>
<tr><td>156</td><td>instruction_into_1.asm</td><td>instrukce <strong>INTO</strong> s&nbsp;obsluhou přerušení</td><td><a href="https://github.com/tisnik/8bit-fame/blob/master/pc-dos/instruction_into_1.asm">https://github.com/tisnik/8bit-fame/blob/master/pc-dos/instruction_into_1.asm</a></td></tr>
<tr><td>157</td><td>instruction_into_2.asm</td><td>instrukce <strong>INTO</strong> s&nbsp;obsluhou přerušení</td><td><a href="https://github.com/tisnik/8bit-fame/blob/master/pc-dos/instruction_into_2.asm">https://github.com/tisnik/8bit-fame/blob/master/pc-dos/instruction_into_2.asm</a></td></tr>
<tr><td>158</td><td>instruction_bound_1.asm</td><td>instrukce <strong>BOUND</strong> s&nbsp;obsluhou přerušení (nekorektní řešení)</td><td><a href="https://github.com/tisnik/8bit-fame/blob/master/pc-dos/instruction_bound_1.asm">https://github.com/tisnik/8bit-fame/blob/master/pc-dos/instruction_bound_1.asm</a></td></tr>
<tr><td>159</td><td>instruction_bound_2.asm</td><td>instrukce <strong>BOUND</strong> s&nbsp;obsluhou přerušení (korektní řešení)</td><td><a href="https://github.com/tisnik/8bit-fame/blob/master/pc-dos/instruction_bound_2.asm">https://github.com/tisnik/8bit-fame/blob/master/pc-dos/instruction_bound_2.asm</a></td></tr>
<tr><td>160</td><td>vga_320x200_putpixel_286.asm</td><td>instrukce bitového posunu s&nbsp;konstantou větší než 1</td><td><a href="https://github.com/tisnik/8bit-fame/blob/master/pc-dos/vga_320x200_putpixel_286.asm">https://github.com/tisnik/8bit-fame/blob/master/pc-dos/vga_320x200_putpixel_286.asm</a></td></tr>
<tr><td>161</td><td>instruction_push_pop.asm</td><td>instrukce <strong>PUSH</strong> a <strong>POP</strong> se všemi pracovními registry</td><td><a href="https://github.com/tisnik/8bit-fame/blob/master/pc-dos/instruction_push_pop.asm">https://github.com/tisnik/8bit-fame/blob/master/pc-dos/instruction_push_pop.asm</a></td></tr>
<tr><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td></tr>
<tr><td>162</td><td>instruction_push_pop_B.asm</td><td>instrukce s&nbsp;novými segmentovými registry</td><td><a href="https://github.com/tisnik/8bit-fame/blob/master/pc-dos/instruction_push_pop_B.asm">https://github.com/tisnik/8bit-fame/blob/master/pc-dos/instruction_push_pop_B.asm</a></td></tr>
<tr><td>163</td><td>instruction_near_jz_jmp.asm</td><td>blízké skoky</td><td><a href="https://github.com/tisnik/8bit-fame/blob/master/pc-dos/instruction_near_jz_jmp.asm">https://github.com/tisnik/8bit-fame/blob/master/pc-dos/instruction_near_jz_jmp.asm</a></td></tr>
<tr><td>164</td><td>instruction_bsf.asm</td><td>nová instrukce <strong>BSF</strong></td><td><a href="https://github.com/tisnik/8bit-fame/blob/master/pc-dos/instruction_bsf.asm">https://github.com/tisnik/8bit-fame/blob/master/pc-dos/instruction_bsf.asm</a></td></tr>
<tr><td>165</td><td>instruction_bsr.asm</td><td>nová instrukce <strong>BSR</strong></td><td><a href="https://github.com/tisnik/8bit-fame/blob/master/pc-dos/instruction_bsr.asm">https://github.com/tisnik/8bit-fame/blob/master/pc-dos/instruction_bsr.asm</a></td></tr>
<tr><td>166</td><td>instruction_add_32bit.asm</td><td>32bitový součet</td><td><a href="https://github.com/tisnik/8bit-fame/blob/master/pc-dos/instruction_add_32bit.asm">https://github.com/tisnik/8bit-fame/blob/master/pc-dos/instruction_add_32bit.asm</a></td></tr>
<tr><td>167</td><td>instruction_inc_32bit.asm</td><td>32bitová instrukce <strong>INC</strong> v&nbsp;šestnáctibitovém režimu</td><td><a href="https://github.com/tisnik/8bit-fame/blob/master/pc-dos/instruction_inc_32bit.asm">https://github.com/tisnik/8bit-fame/blob/master/pc-dos/instruction_inc_32bit.asm</a></td></tr>
<tr><td>168</td><td>instruction_inc_32bit_B.asm</td><td>32bitová instrukce <strong>INC</strong> v&nbsp;32bitovém režimu</td><td><a href="https://github.com/tisnik/8bit-fame/blob/master/pc-dos/instruction_inc_32bit_B.asm">https://github.com/tisnik/8bit-fame/blob/master/pc-dos/instruction_inc_32bit_B.asm</a></td></tr>
<tr><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td></tr>
<tr><td>169</td><td>ems_status.asm</td><td>zjištění stavu (emulace) paměti EMS</td><td><a href="https://github.com/tisnik/8bit-fame/blob/master/pc-dos/ems_status.asm">https://github.com/tisnik/8bit-fame/blob/master/pc-dos/ems_status.asm</a></td></tr>
<tr><td>170</td><td>ems_total_mem.asm</td><td>získání celkové kapacity paměti EMS v&nbsp;blocích</td><td><a href="https://github.com/tisnik/8bit-fame/blob/master/pc-dos/ems_total_mem.asm">https://github.com/tisnik/8bit-fame/blob/master/pc-dos/ems_total_mem.asm</a></td></tr>
<tr><td>171</td><td>ems_free_mem.asm </td><td>získání volné kapacity paměti EMS v&nbsp;blocích</td><td><a href="https://github.com/tisnik/8bit-fame/blob/master/pc-dos/ems_free_mem.asm">https://github.com/tisnik/8bit-fame/blob/master/pc-dos/ems_free_mem.asm</a></td></tr>
<tr><td>172</td><td>xms_free_mem.asm </td><td>získání volné kapacity paměti XMS v&nbsp;blocích</td><td><a href="https://github.com/tisnik/8bit-fame/blob/master/pc-dos/xms_free_mem.asm">https://github.com/tisnik/8bit-fame/blob/master/pc-dos/xms_free_mem.asm</a></td></tr>
<tr><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td></tr>
<tr><td>173</td><td>vga_320x200_short_address_1.asm</td><td>blokový přenos provedený v&nbsp;rámci prostoru segmentu</td><td><a href="https://github.com/tisnik/8bit-fame/blob/master/pc-dos/vga_320x200_short_address_1.asm">https://github.com/tisnik/8bit-fame/blob/master/pc-dos/vga_320x200_short_address_1.asm</a></td></tr>
<tr><td>174</td><td>vga_320x200_short_address_2.asm</td><td>rozepsaný blokový přenos provedený v&nbsp;rámci prostoru segmentu</td><td><a href="https://github.com/tisnik/8bit-fame/blob/master/pc-dos/vga_320x200_short_address_2.asm">https://github.com/tisnik/8bit-fame/blob/master/pc-dos/vga_320x200_short_address_2.asm</a></td></tr>
<tr><td>175</td><td>vga_320x200_short_address_3.asm</td><td>přenos nelze provést přes hranici offsetu</td><td><a href="https://github.com/tisnik/8bit-fame/blob/master/pc-dos/vga_320x200_short_address_3.asm">https://github.com/tisnik/8bit-fame/blob/master/pc-dos/vga_320x200_short_address_3.asm</a></td></tr>
<tr><td>176</td><td>vga_320x200_short_address_4.asm</td><td>přenos nelze provést přes hranici offsetu</td><td><a href="https://github.com/tisnik/8bit-fame/blob/master/pc-dos/vga_320x200_short_address_4.asm">https://github.com/tisnik/8bit-fame/blob/master/pc-dos/vga_320x200_short_address_4.asm</a></td></tr>
<tr><td>177</td><td>vga_320x200_long_address_1.asm</td><td>32bitový blokový přenos</td><td><a href="https://github.com/tisnik/8bit-fame/blob/master/pc-dos/vga_320x200_long_address_1.asm">https://github.com/tisnik/8bit-fame/blob/master/pc-dos/vga_320x200_long_address_1.asm</a></td></tr>
<tr><td>178</td><td>vga_320x200_long_address_2.asm</td><td>rozepsaný 32bitový blokový přenos provedený v&nbsp;rámci prostoru segmentu</td><td><a href="https://github.com/tisnik/8bit-fame/blob/master/pc-dos/vga_320x200_long_address_2.asm">https://github.com/tisnik/8bit-fame/blob/master/pc-dos/vga_320x200_long_address_2.asm</a></td></tr>
<tr><td>179</td><td>vga_320x200_long_address_3.asm</td><td>přístup do obrazové paměti přes segment 0x0000 a 32bitový offset</td><td><a href="https://github.com/tisnik/8bit-fame/blob/master/pc-dos/vga_320x200_long_address_3.asm">https://github.com/tisnik/8bit-fame/blob/master/pc-dos/vga_320x200_long_address_3.asm</a></td></tr>
<tr><td>180</td><td>vga_320x200_long_address_4.asm</td><td>otestování, jak lze přenášet data s&nbsp;využitím 32bitového offsetu</td><td><a href="https://github.com/tisnik/8bit-fame/blob/master/pc-dos/vga_320x200_long_address_4.asm">https://github.com/tisnik/8bit-fame/blob/master/pc-dos/vga_320x200_long_address_4.asm</a></td></tr>
</table>



<p><a name="k20"></a></p>
<h2 id="k20">20. Odkazy na Internetu</h2>

<ol>

<li>The Intel 8088 Architecture and Instruction Set<br />
<a href="https://people.ece.ubc.ca/~edc/464/lectures/lec4.pdf">https://people.ece.ubc.ca/~edc/464/lectures/lec4.pdf</a>
</li>

<li>x86 Opcode Structure and Instruction Overview<br />
<a href="https://pnx.tf/files/x86_opcode_structure_and_instruction_overview.pdf">https://pnx.tf/files/x86_opcode_structure_and_instruction_overview.pdf</a>
</li>

<li>x86 instruction listings (Wikipedia)<br />
<a href="https://en.wikipedia.org/wiki/X86_instruction_listings">https://en.wikipedia.org/wiki/X86_instruction_listings</a>
</li>

<li>x86 assembly language (Wikipedia)<br />
<a href="https://en.wikipedia.org/wiki/X86_assembly_language">https://en.wikipedia.org/wiki/X86_assembly_language</a>
</li>

<li>Intel Assembler (Cheat sheet)<br />
<a href="http://www.jegerlehner.ch/intel/IntelCodeTable.pdf">http://www.jegerlehner.ch/intel/IntelCodeTable.pdf</a>
</li>

<li>25 Microchips That Shook the World<br />
<a href="https://spectrum.ieee.org/tech-history/silicon-revolution/25-microchips-that-shook-the-world">https://spectrum.ieee.org/tech-history/silicon-revolution/25-microchips-that-shook-the-world</a>
</li>

<li>Chip Hall of Fame: MOS Technology 6502 Microprocessor<br />
<a href="https://spectrum.ieee.org/tech-history/silicon-revolution/chip-hall-of-fame-mos-technology-6502-microprocessor">https://spectrum.ieee.org/tech-history/silicon-revolution/chip-hall-of-fame-mos-technology-6502-microprocessor</a>
</li>

<li>Chip Hall of Fame: Intel 8088 Microprocessor<br />
<a href="https://spectrum.ieee.org/tech-history/silicon-revolution/chip-hall-of-fame-intel-8088-microprocessor">https://spectrum.ieee.org/tech-history/silicon-revolution/chip-hall-of-fame-intel-8088-microprocessor</a>
</li>

<li>Jak se zrodil procesor?<br />
<a href="https://www.root.cz/clanky/jak-se-zrodil-procesor/">https://www.root.cz/clanky/jak-se-zrodil-procesor/</a>
</li>

<li>Apple II History Home<br />
<a href="http://apple2history.org/">http://apple2history.org/</a>
</li>

<li>The 8086/8088 Primer<br />
<a href="https://www.stevemorse.org/8086/index.html">https://www.stevemorse.org/8086/index.html</a>
</li>

<li>flat assembler: Assembly language resources<br />
<a href="https://flatassembler.net/">https://flatassembler.net/</a>
</li>

<li>FASM na Wikipedii<br />
<a href="https://en.wikipedia.org/wiki/FASM">https://en.wikipedia.org/wiki/FASM</a>
</li>

<li>Fresh IDE FASM inside<br />
<a href="https://fresh.flatassembler.net/">https://fresh.flatassembler.net/</a>
</li>

<li>MS-DOS Version 4.0 Programmer's Reference<br />
<a href="https://www.pcjs.org/documents/books/mspl13/msdos/dosref40/">https://www.pcjs.org/documents/books/mspl13/msdos/dosref40/</a>
</li>

<li>DOS API (Wikipedia)<br />
<a href="https://en.wikipedia.org/wiki/DOS_API">https://en.wikipedia.org/wiki/DOS_API</a>
</li>

<li>Bit banging<br />
<a href="https://en.wikipedia.org/wiki/Bit_banging">https://en.wikipedia.org/wiki/Bit_banging</a>
</li>

<li>IBM Basic assembly language and successors (Wikipedia)<br />
<a href="https://en.wikipedia.org/wiki/IBM_Basic_assembly_language_and_successors">https://en.wikipedia.org/wiki/IBM_Basic_assembly_language_and_successors</a>
</li>

<li>X86 Assembly/Bootloaders<br />
<a href="https://en.wikibooks.org/wiki/X86_Assembly/Bootloaders">https://en.wikibooks.org/wiki/X86_Assembly/Bootloaders</a>
</li>

<li>Počátky grafiky na PC: grafické karty CGA a Hercules<br />
<a href="https://www.root.cz/clanky/pocatky-grafiky-na-pc-graficke-karty-cga-a-hercules/">https://www.root.cz/clanky/pocatky-grafiky-na-pc-graficke-karty-cga-a-hercules/</a>
</li>

<li>Co mají společného Commodore PET/4000, BBC Micro, Amstrad CPC i grafické karty MDA, CGA a Hercules?<br />
<a href="https://www.root.cz/clanky/co-maji-spolecneho-commodore-pet-4000-bbc-micro-amstrad-cpc-i-graficke-karty-mda-cga-a-hercules/">https://www.root.cz/clanky/co-maji-spolecneho-commodore-pet-4000-bbc-micro-amstrad-cpc-i-graficke-karty-mda-cga-a-hercules/</a>
</li>

<li>Karta EGA: první použitelná barevná grafika na PC<br />
<a href="https://www.root.cz/clanky/karta-ega-prvni-pouzitelna-barevna-grafika-na-pc/">https://www.root.cz/clanky/karta-ega-prvni-pouzitelna-barevna-grafika-na-pc/</a>
</li>

<li>RGB Classic Games<br />
<a href="https://www.classicdosgames.com/">https://www.classicdosgames.com/</a>
</li>

<li>Turbo Assembler (Wikipedia)<br />
<a href="https://en.wikipedia.org/wiki/Turbo_Assembler">https://en.wikipedia.org/wiki/Turbo_Assembler</a>
</li>

<li>Microsoft Macro Assembler<br />
<a href="https://en.wikipedia.org/wiki/Microsoft_Macro_Assembler">https://en.wikipedia.org/wiki/Microsoft_Macro_Assembler</a>
</li>

<li>IBM Personal Computer (Wikipedia)<br />
<a href="https://en.wikipedia.org/wiki/IBM_Personal_Computer">https://en.wikipedia.org/wiki/IBM_Personal_Computer</a>
</li>

<li>Intel 8251<br />
<a href="https://en.wikipedia.org/wiki/Intel_8251">https://en.wikipedia.org/wiki/Intel_8251</a>
</li>

<li>Intel 8253<br />
<a href="https://en.wikipedia.org/wiki/Intel_8253">https://en.wikipedia.org/wiki/Intel_8253</a>
</li>

<li>Intel 8255<br />
<a href="https://en.wikipedia.org/wiki/Intel_8255">https://en.wikipedia.org/wiki/Intel_8255</a>
</li>

<li>Intel 8257<br />
<a href="https://en.wikipedia.org/wiki/Intel_8257">https://en.wikipedia.org/wiki/Intel_8257</a>
</li>

<li>Intel 8259<br />
<a href="https://en.wikipedia.org/wiki/Intel_8259">https://en.wikipedia.org/wiki/Intel_8259</a>
</li>

<li>Support/peripheral/other chips - 6800 family<br />
<a href="http://www.cpu-world.com/Support/6800.html">http://www.cpu-world.com/Support/6800.html</a>
</li>

<li>Motorola 6845<br />
<a href="http://en.wikipedia.org/wiki/Motorola_6845">http://en.wikipedia.org/wiki/Motorola_6845</a>
</li>

<li>The 6845 Cathode Ray Tube Controller (CRTC)<br />
<a href="http://www.tinyvga.com/6845">http://www.tinyvga.com/6845</a>
</li>

<li>CRTC operation<br />
<a href="http://www.6502.org/users/andre/hwinfo/crtc/crtc.html">http://www.6502.org/users/andre/hwinfo/crtc/crtc.html</a>
</li>

<li>The 6845 Cathode Ray Tube Controller (CRTC)<br />
<a href="http://www.tinyvga.com/6845">http://www.tinyvga.com/6845</a>
</li>

<li>Motorola 6845 and bitwise graphics<br />
<a href="https://retrocomputing.stackexchange.com/questions/10996/motorola-6845-and-bitwise-graphics">https://retrocomputing.stackexchange.com/questions/10996/motorola-6845-and-bitwise-graphics</a>
</li>

<li>IBM Monochrome Display Adapter<br />
<a href="http://en.wikipedia.org/wiki/Monochrome_Display_Adapter">http://en.wikipedia.org/wiki/Monochrome_Display_Adapter</a>
</li>

<li>Color Graphics Adapter<br />
<a href="http://en.wikipedia.org/wiki/Color_Graphics_Adapter">http://en.wikipedia.org/wiki/Color_Graphics_Adapter</a>
</li>

<li>Color Graphics Adapter and the Brown color in IBM 5153 Color Display<br />
<a href="https://www.aceinnova.com/en/electronics/cga-and-the-brown-color-in-ibm-5153-color-display/">https://www.aceinnova.com/en/electronics/cga-and-the-brown-color-in-ibm-5153-color-display/</a>
</li>

<li>The Modern Retrocomputer: An Arduino Driven 6845 CRT Controller<br />
<a href="https://hackaday.com/2017/05/14/the-modern-retrocomputer-an-arduino-driven-6845-crt-controller/">https://hackaday.com/2017/05/14/the-modern-retrocomputer-an-arduino-driven-6845-crt-controller/</a>
</li>

<li>flat assembler: Assembly language resources<br />
<a href="https://flatassembler.net/">https://flatassembler.net/</a>
</li>

<li>FASM na Wikipedii<br />
<a href="https://en.wikipedia.org/wiki/FASM">https://en.wikipedia.org/wiki/FASM</a>
</li>

<li>Fresh IDE FASM inside<br />
<a href="https://fresh.flatassembler.net/">https://fresh.flatassembler.net/</a>
</li>

<li>MS-DOS Version 4.0 Programmer's Reference<br />
<a href="https://www.pcjs.org/documents/books/mspl13/msdos/dosref40/">https://www.pcjs.org/documents/books/mspl13/msdos/dosref40/</a>
</li>

<li>DOS API (Wikipedia)<br />
<a href="https://en.wikipedia.org/wiki/DOS_API">https://en.wikipedia.org/wiki/DOS_API</a>
</li>

<li>IBM Basic assembly language and successors (Wikipedia)<br />
<a href="https://en.wikipedia.org/wiki/IBM_Basic_assembly_language_and_successors">https://en.wikipedia.org/wiki/IBM_Basic_assembly_language_and_successors</a>
</li>

<li>X86 Assembly/Arithmetic<br />
<a href="https://en.wikibooks.org/wiki/X86_Assembly/Arithmetic">https://en.wikibooks.org/wiki/X86_Assembly/Arithmetic</a>
</li>

<li>Art of Assembly - Arithmetic Instructions<br />
<a href="http://oopweb.com/Assembly/Documents/ArtOfAssembly/Volume/Chapter_6/CH06-2.html">http://oopweb.com/Assembly/Documents/ArtOfAssembly/Volume/Chapter_6/CH06-2.html</a>
</li>

<li>ASM Flags<br />
<a href="http://www.cavestory.org/guides/csasm/guide/asm_flags.html">http://www.cavestory.org/guides/csasm/guide/asm_flags.html</a>
</li>

<li>Status Register<br />
<a href="https://en.wikipedia.org/wiki/Status_register">https://en.wikipedia.org/wiki/Status_register</a>
</li>

<li>Linux assemblers: A comparison of GAS and NASM<br />
<a href="http://www.ibm.com/developerworks/library/l-gas-nasm/index.html">http://www.ibm.com/developerworks/library/l-gas-nasm/index.html</a>
</li>

<li>Programovani v assembleru na OS Linux<br />
<a href="http://www.cs.vsb.cz/grygarek/asm/asmlinux.html">http://www.cs.vsb.cz/grygarek/asm/asmlinux.html</a>
</li>

<li>Is it worthwhile to learn x86 assembly language today?<br />
<a href="https://www.quora.com/Is-it-worthwhile-to-learn-x86-assembly-language-today?share=1">https://www.quora.com/Is-it-worthwhile-to-learn-x86-assembly-language-today?share=1</a>
</li>

<li>Why Learn Assembly Language?<br />
<a href="http://www.codeproject.com/Articles/89460/Why-Learn-Assembly-Language">http://www.codeproject.com/Articles/89460/Why-Learn-Assembly-Language</a>
</li>

<li>Is Assembly still relevant?<br />
<a href="http://programmers.stackexchange.com/questions/95836/is-assembly-still-relevant">http://programmers.stackexchange.com/questions/95836/is-assembly-still-relevant</a>
</li>

<li>Why Learning Assembly Language Is Still a Good Idea<br />
<a href="http://www.onlamp.com/pub/a/onlamp/2004/05/06/writegreatcode.html">http://www.onlamp.com/pub/a/onlamp/2004/05/06/writegreatcode.html</a>
</li>

<li>Assembly language today<br />
<a href="http://beust.com/weblog/2004/06/23/assembly-language-today/">http://beust.com/weblog/2004/06/23/assembly-language-today/</a>
</li>

<li>Assembler: Význam assembleru dnes<br />
<a href="http://www.builder.cz/rubriky/assembler/vyznam-assembleru-dnes-155960cz">http://www.builder.cz/rubriky/assembler/vyznam-assembleru-dnes-155960cz</a>
</li>

<li>Programming from the Ground Up Book - Summary<br />
<a href="http://savannah.nongnu.org/projects/pgubook/">http://savannah.nongnu.org/projects/pgubook/</a>
</li>

<li>DOSBox<br />
<a href="https://www.dosbox.com/">https://www.dosbox.com/</a>
</li>

<li>The C Programming Language<br />
<a href="https://en.wikipedia.org/wiki/The_C_Programming_Language">https://en.wikipedia.org/wiki/The_C_Programming_Language</a>
</li>

<li>Hercules Graphics Card (HCG)<br />
<a href="https://en.wikipedia.org/wiki/Hercules_Graphics_Card">https://en.wikipedia.org/wiki/Hercules_Graphics_Card</a>
</li>

<li>Complete 8086 instruction set<br />
<a href="https://content.ctcd.edu/courses/cosc2325/m22/docs/emu8086ins.pdf">https://content.ctcd.edu/courses/cosc2325/m22/docs/emu8086ins.pdf</a>
</li>

<li>Complete 8086 instruction set<br />
<a href="https://yassinebridi.github.io/asm-docs/8086_instruction_set.html">https://yassinebridi.github.io/asm-docs/8086_instruction_set.html</a>
</li>

<li>8088 MPH by Hornet + CRTC + DESiRE (final version)<br />
<a href="https://www.youtube.com/watch?v=hNRO7lno_DM">https://www.youtube.com/watch?v=hNRO7lno_DM</a>
</li>

<li>Area 5150 by CRTC &amp; Hornet (Party Version) / IBM PC+CGA Demo, Hardware Capture<br />
<a href="https://www.youtube.com/watch?v=fWDxdoRTZPc">https://www.youtube.com/watch?v=fWDxdoRTZPc</a>
</li>

<li>80x86 Integer Instruction Set Timings (8088 - Pentium)<br />
<a href="http://aturing.umcs.maine.edu/~meadow/courses/cos335/80x86-Integer-Instruction-Set-Clocks.pdf">http://aturing.umcs.maine.edu/~meadow/courses/cos335/80x86-Integer-Instruction-Set-Clocks.pdf</a>
</li>

<li>Colour Graphics Adapter: Notes<br />
<a href="https://www.seasip.info/VintagePC/cga.html">https://www.seasip.info/VintagePC/cga.html</a>
</li>

<li>Restoring A Vintage CGA Card With Homebrew HASL<br />
<a href="https://hackaday.com/2024/06/12/restoring-a-vintage-cga-card-with-homebrew-hasl/">https://hackaday.com/2024/06/12/restoring-a-vintage-cga-card-with-homebrew-hasl/</a>
</li>

<li>Demoing An 8088<br />
<a href="https://hackaday.com/2015/04/10/demoing-an-8088/">https://hackaday.com/2015/04/10/demoing-an-8088/</a>
</li>

<li>Video Memory Layouts<br />
<a href="http://www.techhelpmanual.com/89-video_memory_layouts.html">http://www.techhelpmanual.com/89-video_memory_layouts.html</a>
</li>

<li>Screen Attributes<br />
<a href="http://www.techhelpmanual.com/87-screen_attributes.html">http://www.techhelpmanual.com/87-screen_attributes.html</a>
</li>

<li>IBM PC Family  -  BIOS Video Modes<br />
<a href="https://www.minuszerodegrees.net/video/bios_video_modes.htm">https://www.minuszerodegrees.net/video/bios_video_modes.htm</a>
</li>

<li>EGA Functions<br />
<a href="https://cosmodoc.org/topics/ega-functions/#the-hierarchy-of-the-ega">https://cosmodoc.org/topics/ega-functions/#the-hierarchy-of-the-ega</a>
</li>

<li>Why the EGA can only use 16 of its 64 colours in 200-line modes<br />
<a href="https://www.reenigne.org/blog/why-the-ega-can-only-use-16-of-its-64-colours-in-200-line-modes/">https://www.reenigne.org/blog/why-the-ega-can-only-use-16-of-its-64-colours-in-200-line-modes/</a>
</li>

<li>How 16 colors saved PC gaming - the story of EGA graphics<br />
<a href="https://www.custompc.com/retro-tech/ega-graphics">https://www.custompc.com/retro-tech/ega-graphics</a>
</li>

<li>List of 16-bit computer color palettes<br />
<a href="https://en.wikipedia.org/wiki/List_of_16-bit_computer_color_palettes">https://en.wikipedia.org/wiki/List_of_16-bit_computer_color_palettes</a>
</li>

<li>Why were those colors chosen to be the default palette for 256-color VGA?<br />
<a href="https://retrocomputing.stackexchange.com/questions/27994/why-were-those-colors-chosen-to-be-the-default-palette-for-256-color-vga">https://retrocomputing.stackexchange.com/questions/27994/why-were-those-colors-chosen-to-be-the-default-palette-for-256-color-vga</a>
</li>

<li>VGA Color Palettes<br />
<a href="https://www.fountainware.com/EXPL/vga_color_palettes.htm">https://www.fountainware.com/EXPL/vga_color_palettes.htm</a>
</li>

<li>Hardware Level VGA and SVGA Video Programming Information Page<br />
<a href="http://www.osdever.net/FreeVGA/vga/vga.htm">http://www.osdever.net/FreeVGA/vga/vga.htm</a>
</li>

<li>Hardware Level VGA and SVGA Video Programming Information Page - sequencer<br />
<a href="http://www.osdever.net/FreeVGA/vga/seqreg.htm">http://www.osdever.net/FreeVGA/vga/seqreg.htm</a>
</li>

<li>VGA Basics<br />
<a href="http://www.brackeen.com/vga/basics.html">http://www.brackeen.com/vga/basics.html</a>
</li>

<li>Introduction to VGA Mode 'X'<br />
<a href="https://web.archive.org/web/20160414072210/http://fly.srk.fer.hr/GDM/articles/vgamodex/vgamx1.html">https://web.archive.org/web/20160414072210/http://fly.srk.fer.hr/GDM/articles/vgamodex/vgamx1.html</a>
</li>

<li>VGA Mode-X<br />
<a href="https://web.archive.org/web/20070123192523/http://www.gamedev.net/reference/articles/article356.asp">https://web.archive.org/web/20070123192523/http://www.gamedev.net/reference/articles/article356.asp</a>
</li>

<li>Mode-X: 256-Color VGA Magic<br />
<a href="https://downloads.gamedev.net/pdf/gpbb/gpbb47.pdf">https://downloads.gamedev.net/pdf/gpbb/gpbb47.pdf</a>
</li>

<li>Instruction Format in 8086 Microprocessor<br />
<a href="https://www.includehelp.com/embedded-system/instruction-format-in-8086-microprocessor.aspx">https://www.includehelp.com/embedded-system/instruction-format-in-8086-microprocessor.aspx</a>
</li>

<li>How to use "AND," "OR," and "XOR" modes for VGA Drawing<br />
<a href="https://retrocomputing.stackexchange.com/questions/21936/how-to-use-and-or-and-xor-modes-for-vga-drawing">https://retrocomputing.stackexchange.com/questions/21936/how-to-use-and-or-and-xor-modes-for-vga-drawing</a>
</li>

<li>VGA Hardware<br />
<a href="https://wiki.osdev.org/VGA_Hardware">https://wiki.osdev.org/VGA_Hardware</a>
</li>

<li>Programmer's Guide to Yamaha YMF 262/OPL3 FM Music Synthesizer<br />
<a href="https://moddingwiki.shikadi.net/wiki/OPL_chip">https://moddingwiki.shikadi.net/wiki/OPL_chip</a>
</li>

<li>Does anybody understand how OPL2 percussion mode works?<br />
<a href="https://forum.vcfed.org/index.php?threads/does-anybody-understand-how-opl2-percussion-mode-works.60925/">https://forum.vcfed.org/index.php?threads/does-anybody-understand-how-opl2-percussion-mode-works.60925/</a>
</li>

<li>Yamaha YMF262 OPL3 music - MoonDriver for OPL3 DEMO [Oscilloscope View]<br />
<a href="https://www.youtube.com/watch?v=a7I-QmrkAak">https://www.youtube.com/watch?v=a7I-QmrkAak</a>
</li>

<li>Yamaha OPL vs OPL2 vs OPL3 comparison<br />
<a href="https://www.youtube.com/watch?v=5knetge5Gs0">https://www.youtube.com/watch?v=5knetge5Gs0</a>
</li>

<li>OPL3 Music Crockett's Theme<br />
<a href="https://www.youtube.com/watch?v=HXS008pkgSQ">https://www.youtube.com/watch?v=HXS008pkgSQ</a>
</li>

<li>Bad Apple (Adlib Tracker - OPL3)<br />
<a href="https://www.youtube.com/watch?v=2lEPH6Y3Luo">https://www.youtube.com/watch?v=2lEPH6Y3Luo</a>
</li>

<li>FM Synthesis Chips, Codecs and DACs<br />
<a href="https://www.dosdays.co.uk/topics/fm_synthesizers.php">https://www.dosdays.co.uk/topics/fm_synthesizers.php</a>
</li>

<li>The Zen Challenge - YMF262 OPL3 Original (For an upcoming game)<br />
<a href="https://www.youtube.com/watch?v=6JlFIFz1CFY">https://www.youtube.com/watch?v=6JlFIFz1CFY</a>
</li>

<li>[adlib tracker II techno music - opl3] orbit around alpha andromedae I<br />
<a href="https://www.youtube.com/watch?v=YqxJCu_WFuA">https://www.youtube.com/watch?v=YqxJCu_WFuA</a>
</li>

<li>[adlib tracker 2 music - opl3 techno] hybridisation process on procyon-ii<br />
<a href="https://www.youtube.com/watch?v=daSV5mN0sJ4">https://www.youtube.com/watch?v=daSV5mN0sJ4</a>
</li>

<li>Hyper Duel - Black Rain (YMF262 OPL3 Cover)<br />
<a href="https://www.youtube.com/watch?v=pu_mzRRq8Ho">https://www.youtube.com/watch?v=pu_mzRRq8Ho</a>
</li>

<li>IBM 5155-5160 Technical Reference<br />
<a href="https://www.minuszerodegrees.net/manuals/IBM/IBM_5155_5160_Technical_Reference_6280089_MAR86.pdf">https://www.minuszerodegrees.net/manuals/IBM/IBM_5155_5160_Technical_Reference_6280089_MAR86.pdf</a>
</li>

<li>a ymf262/opl3+pc speaker thing i made<br />
<a href="https://www.youtube.com/watch?v=E-Mx0lEmnZ0">https://www.youtube.com/watch?v=E-Mx0lEmnZ0</a>
</li>

<li>[OPL3] Like a Thunder<br />
<a href="https://www.youtube.com/watch?v=MHf06AGr8SU">https://www.youtube.com/watch?v=MHf06AGr8SU</a>
</li>

<li>(PC SPEAKER) bad apple<br />
<a href="https://www.youtube.com/watch?v=LezmKIIHyUg">https://www.youtube.com/watch?v=LezmKIIHyUg</a>
</li>

<li>Powering devices from PC parallel port<br />
<a href="http://www.epanorama.net/circuits/lptpower.html">http://www.epanorama.net/circuits/lptpower.html</a>
</li>

<li>Magic Mushroom (demo pro PC s DOSem)<br />
<a href="http://www.crossfire-designs.de/download/articles/soundcards//mushroom.rar">http://www.crossfire-designs.de/download/articles/soundcards//mushroom.rar</a>
</li>

<li>Píseň Magic Mushroom - originál<br />
<a href="http://www.crossfire-designs.de/download/articles/soundcards/speaker_mushroom_converted.mp3">http://www.crossfire-designs.de/download/articles/soundcards/speaker_mushroom_converted.mp3</a>
</li>

<li>Píseň Magic Mushroom - hráno na PC Speakeru<br />
<a href="http://www.crossfire-designs.de/download/articles/soundcards/speaker_mushroom_speaker.mp3">http://www.crossfire-designs.de/download/articles/soundcards/speaker_mushroom_speaker.mp3</a>
</li>

<li>Pulse Width Modulation (PWM) Simulation Example<br />
<a href="http://decibel.ni.com/content/docs/DOC-4599">http://decibel.ni.com/content/docs/DOC-4599</a>
</li>

<li>Resistor/Pulse Width Modulation DAC<br />
<a href="http://www.k9spud.com/traxmod/pwmdac.php">http://www.k9spud.com/traxmod/pwmdac.php</a>
</li>

<li>Class D Amplifier<br />
<a href="http://en.wikipedia.org/wiki/Electronic_amplifier#Class_D">http://en.wikipedia.org/wiki/Electronic_amplifier#Class_D</a>
</li>

<li>Covox Speech Thing / Disney Sound Source (1986)<br />
<a href="http://www.crossfire-designs.de/index.php?lang=en&amp;what=articles&amp;name=showarticle.htm&amp;article=soundcards/&amp;page=5">http://www.crossfire-designs.de/index.php?lang=en&amp;what=articles&amp;name=showarticle.htm&amp;article=soundcards/&amp;page=5</a>
</li>

<li>Covox Digital-Analog Converter (Rusky, obsahuje schémata)<br />
<a href="http://phantom.sannata.ru/konkurs/netskater002.shtml">http://phantom.sannata.ru/konkurs/netskater002.shtml</a>
</li>

<li>PC-GPE on the Web<br />
<a href="http://bespin.org/~qz/pc-gpe/">http://bespin.org/~qz/pc-gpe/</a>
</li>

<li>Keyboard Synthesizer<br />
<a href="http://www.solarnavigator.net/music/instruments/keyboards.htm">http://www.solarnavigator.net/music/instruments/keyboards.htm</a>
</li>

<li>FMS - Fully Modular Synthesizer<br />
<a href="http://fmsynth.sourceforge.net/">http://fmsynth.sourceforge.net/</a>
</li>

<li>Javasynth<br />
<a href="http://javasynth.sourceforge.net/">http://javasynth.sourceforge.net/</a>
</li>

<li>Software Sound Synthesis &amp; Music Composition Packages<br />
<a href="http://www.linux-sound.org/swss.html">http://www.linux-sound.org/swss.html</a>
</li>

<li>Mx44.1 Download Page (software synthesizer for linux)<br />
<a href="http://hem.passagen.se/ja_linux/">http://hem.passagen.se/ja_linux/</a>
</li>

<li>Software synthesizer<br />
<a href="http://en.wikipedia.org/wiki/Software_synthesizer">http://en.wikipedia.org/wiki/Software_synthesizer</a>
</li>

<li>Frequency modulation synthesis<br />
<a href="http://en.wikipedia.org/wiki/Frequency_modulation_synthesis">http://en.wikipedia.org/wiki/Frequency_modulation_synthesis</a>
</li>

<li>Yamaha DX7<br />
<a href="http://en.wikipedia.org/wiki/Yamaha_DX7">http://en.wikipedia.org/wiki/Yamaha_DX7</a>
</li>

<li>Wave of the Future<br />
<a href="http://www.wired.com/wired/archive/2.03/waveguides_pr.html">http://www.wired.com/wired/archive/2.03/waveguides_pr.html</a>
</li>

<li>Analog synthesizer<br />
<a href="http://en.wikipedia.org/wiki/Analog_synthesizer">http://en.wikipedia.org/wiki/Analog_synthesizer</a>
</li>

<li>Minimoog<br />
<a href="http://en.wikipedia.org/wiki/Minimoog">http://en.wikipedia.org/wiki/Minimoog</a>
</li>

<li>Moog synthesizer<br />
<a href="http://en.wikipedia.org/wiki/Moog_synthesizer">http://en.wikipedia.org/wiki/Moog_synthesizer</a>
</li>

<li>Tutorial for Frequency Modulation Synthesis<br />
<a href="http://www.sfu.ca/~truax/fmtut.html">http://www.sfu.ca/~truax/fmtut.html</a>
</li>

<li>An Introduction To FM<br />
<a href="http://ccrma.stanford.edu/software/snd/snd/fm.html">http://ccrma.stanford.edu/software/snd/snd/fm.html</a>
</li>

<li>John Chowning<br />
<a href="http://en.wikipedia.org/wiki/John_Chowning">http://en.wikipedia.org/wiki/John_Chowning</a>
</li>

<li>I'm Impressed, Adlib Music is AMAZING!<br />
<a href="https://www.youtube.com/watch?v=PJNjQYp1ras">https://www.youtube.com/watch?v=PJNjQYp1ras</a>
</li>

<li>Milinda- Diode Milliampere ( OPL3 )<br />
<a href="https://www.youtube.com/watch?v=oNhazT5HG0E">https://www.youtube.com/watch?v=oNhazT5HG0E</a>
</li>

<li>Dune 2 - Roland MT-32 Soundtrack <br />
<a href="https://www.youtube.com/watch?v=kQADZeB-z8M">https://www.youtube.com/watch?v=kQADZeB-z8M</a>
</li>

<li>Interrupts<br />
<a href="https://wiki.osdev.org/Interrupts#Types_of_Interrupts">https://wiki.osdev.org/Interrupts#Types_of_Interrupts</a>
</li>

<li>Assembly8086SoundBlasterDmaSingleCycleMode<br />
<a href="https://github.com/leonardo-ono/Assembly8086SoundBlasterDmaSingleCycleMode/blob/master/sbsc.asm">https://github.com/leonardo-ono/Assembly8086SoundBlasterDmaSingleCycleMode/blob/master/sbsc.asm</a>
</li>

<li>Interrupts in 8086 microprocessor<br />
<a href="https://www.geeksforgeeks.org/interrupts-in-8086-microprocessor/">https://www.geeksforgeeks.org/interrupts-in-8086-microprocessor/</a>
</li>

<li>Interrupt Structure of 8086<br />
<a href="https://www.eeeguide.com/interrupt-structure-of-8086/">https://www.eeeguide.com/interrupt-structure-of-8086/</a>
</li>

<li>A20 line<br />
<a href="https://en.wikipedia.org/wiki/A20_line">https://en.wikipedia.org/wiki/A20_line</a>
</li>

<li>Extended memory<br />
<a href="https://en.wikipedia.org/wiki/Extended_memory#eXtended_Memory_Specification_(XMS)">https://en.wikipedia.org/wiki/Extended_memory#eXtended_Memory_Specification_(XMS)</a>
</li>

<li>Expanded memory<br />
<a href="https://en.wikipedia.org/wiki/Expanded_memory">https://en.wikipedia.org/wiki/Expanded_memory</a>
</li>

<li>Protected mode<br />
<a href="https://en.wikipedia.org/wiki/Protected_mode">https://en.wikipedia.org/wiki/Protected_mode</a>
</li>

<li>Virtual 8086 mode<br />
<a href="https://en.wikipedia.org/wiki/Virtual_8086_mode">https://en.wikipedia.org/wiki/Virtual_8086_mode</a>
</li>

<li>Unreal mode<br />
<a href="https://en.wikipedia.org/wiki/Unreal_mode">https://en.wikipedia.org/wiki/Unreal_mode</a>
</li>

<li>DOS memory management<br />
<a href="https://en.wikipedia.org/wiki/DOS_memory_management">https://en.wikipedia.org/wiki/DOS_memory_management</a>
</li>

<li>Upper memory area<br />
<a href="https://en.wikipedia.org/wiki/Upper_memory_area">https://en.wikipedia.org/wiki/Upper_memory_area</a>
</li>

<li>Removing the Mystery from SEGMENT : OFFSET Addressing<br />
<a href="https://thestarman.pcministry.com/asm/debug/Segments.html">https://thestarman.pcministry.com/asm/debug/Segments.html</a>
</li>

<li>Segment descriptor<br />
<a href="https://en.wikipedia.org/wiki/Segment_descriptor">https://en.wikipedia.org/wiki/Segment_descriptor</a>
</li>

<li>When using a 32-bit register to address memory in the real mode, contents of the register must never exceed 0000FFFFH. Why?<br />
<a href="https://stackoverflow.com/questions/45094696/when-using-a-32-bit-register-to-address-memory-in-the-real-mode-contents-of-the">https://stackoverflow.com/questions/45094696/when-using-a-32-bit-register-to-address-memory-in-the-real-mode-contents-of-the</a>
</li>

<li>A Brief History of Unreal Mode<br />
<a href="https://www.os2museum.com/wp/a-brief-history-of-unreal-mode/">https://www.os2museum.com/wp/a-brief-history-of-unreal-mode/</a>
</li>

<li>Segment Limits<br />
<a href="https://wiki.osdev.org/Segment_Limits">https://wiki.osdev.org/Segment_Limits</a>
</li>

<li>How do 32 bit addresses in real mode work?<br />
<a href="https://forum.osdev.org/viewtopic.php?t=30642">https://forum.osdev.org/viewtopic.php?t=30642</a>
</li>

<li>The LOADALL Instruction by Robert Collins<br />
<a href="https://www.rcollins.org/articles/loadall/tspec_a3_doc.html">https://www.rcollins.org/articles/loadall/tspec_a3_doc.html</a>
</li>

</ol>



<p></p><p></p>
<p><small>Autor: <a href="http://www.fit.vutbr.cz/~tisnovpa">Pavel Tišnovský</a> &nbsp; 2024</small></p>
</body>
</html>

