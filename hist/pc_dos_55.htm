<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
        "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html>
<head>
<title></title>
<meta name="Author" content="Pavel Tisnovsky" />
<meta name="Generator" content="vim" />
<meta http-equiv="content-type" content="text/html; charset=utf-8" />
<style type="text/css">
         body {color:#000000; background:#ffffff;}
         h1  {font-family: arial, helvetica, sans-serif; color:#ffffff; background-color:#c00000; text-align:center; padding-left:1em}
         h2  {font-family: arial, helvetica, sans-serif; color:#ffffff; background-color:#0000c0; padding-left:1em; text-align:left}
         h3  {font-family: arial, helvetica, sans-serif; color:#000000; background-color:#c0c0c0; padding-left:1em; text-align:left}
         h4  {font-family: arial, helvetica, sans-serif; color:#000000; background-color:#e0e0e0; padding-left:1em; text-align:left}
         a   {font-family: arial, helvetica, sans-serif;}
         li  {font-family: arial, helvetica, sans-serif; color:#000000; text-align:justify; width:450px;}
         ol  {font-family: arial, helvetica, sans-serif; color:#000000; text-align:justify; width:450px;}
         ul  {font-family: arial, helvetica, sans-serif; color:#000000; text-align:justify; width:450px;}
         p   {font-family: arial, helvetica, sans-serif; color:#000000; text-align:justify;}
         pre {background:#e0e0e0}
</style>
</head>

<body>

<h1></h1>

<h3>Pavel Tišnovský</h3>

<p></p>

<h1>Úvodník</h1>

<p></p>



<h2>Obsah</h2>

<p><a href="#k01">1. Výpočty v&nbsp;systému pevné řádové čárky na platformě IBM PC</a></p>
<p><a href="#k02">2. Jakými způsoby je možné reprezentovat numerické hodnoty v&nbsp;operační paměti počítače?</a></p>
<p><a href="#k03">3. Uložení čísel ve formátu pevné řádové binární tečky</a></p>
<p><a href="#k04">4. Přednosti a zápory formátu pevné řádové tečky</a></p>
<p><a href="#k05">5. Dvojkový doplněk a čísla s&nbsp;pevnou řádovou binární čárkou</a></p>
<p><a href="#k06">6. Základní vlastnosti čísel reprezentovaných v&nbsp;systému pevné řádové čárky</a></p>
<p><a href="#k07">7. Praktická část</a></p>
<p><a href="#k08">8. Realizace operace součtu v&nbsp;systému pevné řádové čárky</a></p>
<p><a href="#k09">9. Součet realizovaný formou makra</a></p>
<p><a href="#k10">10. Realizace operace součinu: naivní varianta</a></p>
<p><a href="#k11">*** 11. Úprava operandů před provedením součinu</a></p>
<p><a href="#k12">*** 12. Úprava operandů po provedení součinu</a></p>
<p><a href="#k13">*** 13. </a></p>
<p><a href="#k14">*** 14. </a></p>
<p><a href="#k15">*** 15. Výpočet Mandelbrotovy množiny ve formátu s&nbsp;pevnou řádovou tečkou</a></p>
<p><a href="#k16">*** 16. Základní způsob realizace výpočtů</a></p>
<p><a href="#k17">*** 17. </a></p>
<p><a href="#k18">*** 18. </a></p>
<p><a href="#k19">*** 19. Repositář s&nbsp;demonstračními příklady</a></p>
<p><a href="#k20">20. Odkazy na Internetu</a></p>



<p><a name="k01"></a></p>
<h2 id="k01">1. Výpočty v&nbsp;systému pevné řádové čárky na platformě IBM PC</h2>

<p><a
href="https://www.root.cz/serialy/vyvoj-her-a-grafickych-dem-pro-platformu-pc/">V&nbsp;seriálu
o tvorbě her a dem pro úspěšnou i nenáviděnou platformu IBM PC</a> jsme si
popsali základní aritmetické instrukce mikroprocesorů řady Intel 80x86. Taktéž
jsme si podrobně popsali matematický koprocesor Intel 8087 i jeho následovníky
(zejména čipy 80287, 80387). Pokud mělo PC některý z&nbsp;těchto koprocesorů
nainstalován, mohlo poměrně rychle provádět operace s&nbsp;hodnotami uloženými
v&nbsp;systému plovoucí řádové čárky (<i>FP &ndash; Floating Point</i>). Ovšem
zdaleka ne všechna PC byla tímto relativně drahým čipem vybavena. Pokud
matematický koprocesor nebyl nainstalován, bylo nutné všechny FP operace
emulovat, což bylo poměrně pomalé (o řád až dva řády v&nbsp;porovnání
s&nbsp;reálným koprocesorem).</p>

<p>I z&nbsp;tohoto důvodu se například v&nbsp;mnoha hrách vůbec FP operace
neprováděly a využívala se zde odlišná technika. Ta byla založena na uložení
vybrané podmnožiny numerických hodnot v&nbsp;systému <i>pevné řádové (binární)
tečky</i>. V&nbsp;tomto článku se budeme záměrně dopouštět drobného prohřešku
oproti stávající normě českého jazyka, protože budeme neustále psát o řádové,
desetinné a binární <i>tečce</i> a nikoli o <i>čárce</i> &ndash;
z&nbsp;hlediska anglické terminologie to bude více konzistentní, i když
z&nbsp;češtinského hlediska by bylo zcela jistě korektnější psát o řádové
<i>čárce</i>, protože se v&nbsp;češtině celá část čísla od části desetinné
odděluje právě čárkou a nikoli tečkou, jak je tomu zvykem v&nbsp;anglosaských
zemích (programátoři, kterým je tento článek určen především, však tuto
skutečnost zcela jistě znají &ndash; ostatně IT je plná podobných podivností a
nepřesností &ndash; &bdquo;kilobajt&ldquo; apod.).</p>

<p>V&nbsp;anglické literatuře se zmíněná forma reprezentace číselných hodnot
označuje zkratkou <i>FX</i> nebo <i>FXP</i> (<i><i>f</i>i<i>x</i>ed
<i>p</i>oint</i>), zatímco dnes častěji používaná reprezentace v&nbsp;systému
plovoucí řádové tečky se všeobecně označuje zkratkou <i>FP</i> (<i>floating
point</i>). V&nbsp;jednom článku jsem dokonce místo zkratky <i>FX</i> viděl i
zkratku <i>XP</i> (<i>fi<u>x</u>ed <u>p</u>oint</i>), ale to bylo před mnoha
lety, v&nbsp;době Windows 95, tedy dávno před Windows XP :-).</p>

<p>Dnes si nejprve vysvětlíme princip obou metod použitých pro ukládání
podmnožiny racionálních čísel a posléze si také řekneme, jaké výhody a nevýhody
jednotlivé principy přináší v&nbsp;každodenní programátorské praxi a ve kterých
situacích je vhodnější použít pevnou řádovou čárku. V&nbsp;dalším textu budeme
formát pevné binární řádové tečky zkracovat na <i>FX formát</i> a formát
používající plovoucí řádovou tečku budeme zapisovat jako <i>FP formát</i>.</p>



<p><a name="k02"></a></p>
<h2 id="k02">2. Jakými způsoby je možné reprezentovat numerické hodnoty v&nbsp;operační paměti počítače?</h2>

<p>Při ukládání numerických hodnot do operační paměti počítače poměrně záhy
narazíme na některé problémy, z&nbsp;nichž některé souvisí s&nbsp;konečným
počtem bitů, které pro uložení dané hodnoty &bdquo;obětujeme&ldquo; a další
vycházejí z&nbsp;vlastního způsobu zpracování hodnot mikroprocesorem či
matematickým koprocesorem. V&nbsp;konečném počtu bitů je totiž pochopitelně
možné uložit pouze <i>konečné</i> množství různých hodnot a je plně
v&nbsp;rukou programátora, jak efektivně daný počet bitů využije či naopak
promrhá ukládáním nepodstatných informací. Poměrně často se totiž stává, že i
program využívající dvojitou či dokonce rozšířenou přesnost čísel při <i>FP</i>
operacích (tj.&nbsp;když používá datové typy <i>double</i> a
<i>extended/temporary</i>) dává nesprávné výsledky dané nepochopením principu
práce <i>FP</i> aritmetiky a přitom je v&nbsp;některých případech možné se
přesnějších výsledků dobrat i při použití pouhých 32 bitů, ale s&nbsp;pečlivě
vyváženými aritmetickými a bitovými operacemi.</p>

<p>Na druhou stranu nejsou dnes používané mikroprocesory tak univerzálními
zařízeními, jak by se na první pohled možná mohlo zdát. Mikroprocesory jsou
totiž (většinou) navrženy tak, aby účinně, například v&nbsp;rámci jedné operace
či instrukce, zpracovávaly pouze konstantní počet bitů zvolený výrobcem
mikroprocesoru. Příkladem mohou být dnes velmi rozšířené procesory řady x86
(x86-64), které jsou velmi dobré při práci s&nbsp;32 bitovými hodnotami nebo
hodnotami 64bitovými, ale při požadavku na aritmetické výpočty probíhající na
(řekněme) 21 bitech se veškerá jejich efektivita ztrácí a procesor se širokými
vnitřními sběrnicemi, matematickým koprocesorem atd.&nbsp;se potýká
s&nbsp;prohazováním jednotlivých bitů (a naopak &ndash; mnohé DSP pracují
s&nbsp;dvaceti nebo 24 bity a nikoli s&nbsp;32/64 bity).</p>

<p>Mnohem lepší situace nastane v&nbsp;případě, že se nějaká operace
implementuje na programovatelném poli FPGA &ndash; zde je možné vytvořit obvody
provádějící matematické a logické operace s&nbsp;libovolným počtem bitů, čímž
se oproti univerzálním řešením (např.&nbsp;konstantní bitová šířka sběrnice
a/nebo registrů) ušetří mnoho plochy těchto velmi zajímavých obvodů (FPGA mohou
mimochodem znamenat i velkou šanci pro hnutí open source &ndash; pomocí nich by
mohlo vznikat, a někde už vzniká <i>open hardware</i>, které by mohlo odstranit
závislost na &bdquo;uzavřených&ldquo; síťových a grafických kartách apod.).</p>

<p>Vraťme se však ke způsobům reprezentace číselných hodnot v&nbsp;operační
paměti počítače. Nejprve předpokládejme, že pro reprezentaci vlastností
určitého objektu či stavu z&nbsp;reálného světa použijeme <i>N</i> binárních
číslic (bitů), tj.&nbsp;základních jednotek informace, která může nabývat pouze
jedné ze dvou povolených hodnot (ty se značí například symboly <i>yes/no</i>
nebo <i>true</i>/<i>false</i>, ale my se budeme spíše držet označení <i>0</i> a
<i>1</i>). Pomocí této uspořádané <i>N</i>-tice je možné popsat celkem:</p>

<p><i>2<sub>0</sub>&times;2<sub>1</sub>&times;2<sub>2</sub> ... 2<sub>N-1</sub>=2<sup>N</sup></i></p>

<p>jednoznačných, tj.&nbsp;navzájem odlišných, stavů. Množina těchto stavů může
reprezentovat prakticky jakýkoliv abstraktní či reálný objekt. Přitom si musíme
uvědomit, že u této množiny není <i>nikde</i> implicitně řečeno ani myšleno, že
se jedná například o celá kladná čísla, to je pouze jedna z&nbsp;mnoha možných
interpretací zvolené <i>N</i>-tice (my programátoři máme tendenci považovat
celá kladná čísla za přirozenou interpretaci bitové <i>N</i>-tice, to však
vychází pouze z&nbsp;našeho pohledu na svět a z&nbsp;našich zkušeností).
Reprezentaci momentálního stavu abstraktního či reálného objektu si můžeme
představit jako zobrazení z&nbsp;množiny binárních stavů na elementy vzorové (a
obecně neuspořádané) množiny. Nejčastěji používanými zobrazeními jsou zobrazení
množiny binárních stavů na interval celých kladných čísel (<i>Unsigned
Integers</i>), popřípadě na interval celých čísel (<i>Signed Integers</i>).</p>



<p><a name="k03"></a></p>
<h2 id="k03">3. Uložení čísel ve formátu pevné řádové binární tečky</h2>

<p>Numerické hodnoty zapsané ve&nbsp;formátu <i>pevné řádové binární tečky</i>
se chápou jako podmnožina racionálních čísel, což jsou taková čísla, jejichž
hodnoty je možné vyjádřit vztahem:</p>

<p><i>x<sub>FX</sub>=a/b &nbsp;&nbsp; a,b leží v Z, b &ne; 0</i></p>

<p>Číselné hodnoty z&nbsp;uvažované podmnožiny jsou navíc omezeny další
podmínkou:</p>

<p><i>b=2<sup>k</sup> &nbsp;&nbsp; b leží v Z, k leží v Z<sup>+</sup></i></p>

<p>Protože <i>b</i> je celočíselnou mocninou dvojky (a ne desítky či jiného
základu), určuje jeho hodnota <i>n</i> polohu <i>binární tečky</i>
v&nbsp;uloženém čísle. Další podmínkou, která má však spíše implementační
charakter, je zachování stejného počtu binárních cifer v&nbsp;každém
reprezentovaném čísle, což mimo jiné znamená, že všechna čísla mají řádovou
binární tečku umístěnou na stejném místě &ndash; z&nbsp;této podmínky ostatně
plyne i název popisovaného způsobu reprezentace vybrané podmnožiny racionálních
čísel (to je zásadní rozdíl oproti <i>FP</i> formátům). Tak jako i
v&nbsp;jiných reprezentacích čísel, jsou nulové číslice před první nenulovou
cifrou a za poslední nenulovou cifrou nevýznamné, proto je není zapotřebí
uvádět (naše příklady jsou ovšem napsány poměrně primitivně a budou vypisovat
všechny uložené cifry).</p>

<p>Prakticky může být číselná hodnota v&nbsp;systému pevné řádové tečky uložena
na osmi bitech například následujícím způsobem (uvažujeme pouze kladné
hodnoty):</p>

<table>
<tr><td>Pozice bitu        </td><td>8&nbsp;&nbsp;&nbsp;&nbsp;</td><td>7&nbsp;&nbsp;&nbsp;&nbsp;</td><td>6&nbsp;&nbsp;&nbsp;&nbsp;</td><td>5&nbsp;&nbsp;&nbsp;&nbsp;</td><td>4&nbsp;&nbsp;&nbsp;&nbsp;</td><td>3&nbsp;&nbsp;&nbsp;&nbsp;</td><td>2&nbsp;&nbsp;&nbsp;&nbsp;</td><td>1&nbsp;&nbsp;&nbsp;&nbsp;</td></tr>
<tr><td>Váha bitu          </td><td>2<sup>4</sup></td><td>2<sup>3</sup></td><td>2<sup>2</sup></td><td>2<sup>1</sup></td><td>2<sup>0</sup></td><td>2<sup>-1</sup></td><td>2<sup>-2</sup></td><td>2<sup>-3</sup></td></tr>
<tr><td>Desítková váha bitu</td><td>16</td><td>8</td><td>4</td><td>2</td><td>1</td><td>0,5</td><td>0,25</td><td>0,125</td></tr>
</table>



<p><a name="k04"></a></p>
<h2 id="k04">4. Přednosti a zápory formátu pevné řádové tečky</h2>

<p>Ve výše uvedeném příkladu je <i>pevná</i> binární řádová tečka umístěna vždy
<i>napevno</i> mezi třetím a čtvrtým bitem. A vzhledem k&nbsp;tomu, že je tato
skutečnost dopředu známá algoritmům, které provádí zpracování čísel (součet,
rozdíl, součin, výpočet druhé odmocniny, výpočet goniometrické funkce atd.),
není zapotřebí spolu s&nbsp;číslem uchovávat i pozici binární tečky, což
výrazně snižuje počet bitů, které je zapotřebí rezervovat pro čísla ze zadaného
rozsahu. To je tedy první přednost systému pevné řádové tečky &ndash; pokud
programátor dokáže dopředu určit rozsah všech zpracovávaných hodnot a
požadovanou přesnost, může být výhodné tento systém použít. Programátor také
díky explicitním určení polohy řádové tečky může určit, ve kterém místě
programu se musí přesnost či rozsah zvýšit a kdy naopak snížit. Lépe se tak
využije počet bitů, které můžeme pro uložení jednoho čísla obětovat (typicky je
tento počet bitů roven délce slova mikroprocesoru, popř.&nbsp;jeho
celočíselnému násobku či naopak podílu).</p>

<p>Jak se dozvíme v&nbsp;následujících kapitolách, je možné základní
matematické operace (sčítání, odčítání, násobení a dělení) poměrně jednoduše
implementovat i při použití formátu pevné řádové tečky. V&nbsp;případě, že není
k&nbsp;dispozici specializovaný (a současně velmi komplikovaný) matematický
koprocesor, je mnohdy mnohem jednodušší a rychlejší implementovat matematické
operace v&nbsp;FX formátu. To je případ mnoha jednočipových mikroprocesorů
(mikrořadičů), signálových procesorů, ale i specializovaných zařízení
obsahujících programovatelné obvody CPLD či FPGA. A byl to i případ platformy
IBM PC až do (přibližně) roku 1995 (u nás ještě později). Dnes sice mají
komplikovanější (a dražší) FPGA implementovanou i jednotku FPU, ale mnohdy je
výhodnější použít FPGA bez této jednotky a potřebné operace si do tohoto obvodu
&bdquo;vypálit&ldquo; po svém.</p>

<p>Třetí výhodou je fakt, že u FX formátu může programátor navrhnout a posléze
také dodržet požadovanou přesnost všech prováděných výpočtů. To je velký rozdíl
oproti FP formátu (resp.&nbsp;jeho podmnožinám, které se nejčastěji používají).
Jak jsme si již řekli v&nbsp;úvodních kapitolách, není vzácností narazit na
aplikace, které používají datové typy <i>float</i> či <i>double</i> a přitom
jsou výpočty prováděné v&nbsp;těchto programech zatíženy velkou chybou, protože
si programátoři plně neuvědomují některé zásadní limity FP formátu. Kritické
jsou například výpočty s&nbsp;peněžními hodnotami, ale i pouhé sčítání čísel,
jež se od sebe o mnoho řádů liší, vede k&nbsp;velkým chybám, které dokonce
mohou zapříčinit vznik nekonečných smyček, populární dělení nulou atd.</p>

<p>FX formát má však i některé nevýhody. První nevýhoda spočívá v&nbsp;tom, že
tento formát není příliš podporován, a to ani po programové stránce (podpora
v&nbsp;programovacích jazycích), ani výrobci mikroprocesorů pro počítače PC.
Situace je však odlišná v&nbsp;oblasti jednočipových mikropočítačů, signálových
procesorů (DSP), řídicích systémů, nebo například u IBM RS 6000, který kromě
jednotky FPU obsahuje i FXU &ndash; jednotku pro provádění výpočtů v&nbsp;pevné
řádové binární čárce. Na platformě x86 je možné pro FX formát použít instrukce
<strong>MMX</strong> resp.&nbsp;v&nbsp;moderních PC spíše <strong>SSEx</strong>
a <strong>AVX</strong>.</p>

<p>Dále může být použití FX formátu nevýhodné v&nbsp;případě, že se mají
zpracovávat numerické hodnoty, které mají velkou <i>dynamiku</i>,
tj.&nbsp;poměr mezi nejvyšší a nejnižší absolutní hodnotou. V&nbsp;takovém
případě by se mohlo stát, že by se při použití FX formátu muselo pro každé
číslo alokovat velké množství bitů, které by mohlo dokonce překročit počet bitů
nutných pro FP formát. Také v&nbsp;případě, kdy dopředu nevíme, jaké hodnoty se
budou zpracovávat, může být výhodnější použití FP formátu. Zde se však nabízí
otázka, ve kterých případech nevíme, jaké hodnoty můžeme na vstupu získat:
většinou je již z&nbsp;podstaty úlohy dopředu známé, s&nbsp;čím je možné
počítat a které hodnoty jsou naprosto nesmyslné.</p>

<p>Je však pravdou, že takovou analýzu málokdo dělá a když při výpočtech ve
<i>floatech</i> dochází k&nbsp;chybám, tak se bez přemýšlení program přepíše na
<i>doubly</i> a problém se tak buď odstraní, nebo alespoň odsune na pozdější
dobu, například do chvíle, kdy jsou programu předložena reálná data a ne
&bdquo;pouze&ldquo; data testovací.</p>



<p><a name="k05"></a></p>
<h2 id="k05">5. Dvojkový doplněk a čísla s&nbsp;pevnou řádovou binární čárkou</h2>

<p>V&nbsp;praxi je pochopitelně mnohdy (ale zdaleka ne vždy!) nutné pracovat i
se zápornými hodnotami. Zde se typicky využívá takzvaný <i>dvojkový
doplněk</i>. Dvojkový doplněk hodnoty <i>x</i> (označovaný zde kvůli
nedostatkům HTML symbolem <i>#x</i>) lze získat z&nbsp;jejího jedničkového
doplňku <i>~x</i> (tedy prosté negace všech bitů) velmi jednoduše tak, že se
k&nbsp;tomuto doplňku přičte jednotka, tj.:</p>

<p><i>#x=~x+1=2<sup>N</sup>-x</i></p>

<p>Operaci jedničkového i dvojkového doplňku je možné provádět kromě
celočíselných reprezentací i u&nbsp;reprezentace v&nbsp;pevné řádové binární
čárce. Pokud je <i>N</i>-bitové slovo interpretováno ve&nbsp;vyjádření
v&nbsp;pevné řádové čárce, může nabývat hodnot ležících v&nbsp;podmnožině
<i>P<sub>2</sub></i> racionálních čísel:</p>

<p><i>P<sub>2</sub>=p/2<sup>b</sup> | -2<sup>N-1</sup> &le; p &le; 2<sup>N-1</sup>-1</i></p>

<p>Podmnožina <i>P<sub>2</sub></i> obsahuje stále <i>2<sup>N</sup></i> prvků,
stejně jako podmnožina <i>P<sub>1</sub></i> definovaná v&nbsp;předchozích
kapitolách. Novou reprezentaci čísel budu v&nbsp;dalším textu označovat
symbolem <i>A(a,b)</i>, kde platí <i>a=N-b-1</i>.</p>

<p>Hodnota <i>N</i>-bitového čísla <i>x</i> je v&nbsp;reprezentaci
<i>A(a,b)</i> vyjádřena výrazem:</p>

<p><i>x=1/2<sup>b</sup>(-2<sup>N-1</sup>x<sub>N-1</sub>+&sum;<sub>0</sub><sup>N-2</sup>2<sup>n</sup>x<sub>n</sub>)</i></p>

<p>kde symbol <i>x<sub>n</sub></i> značí hodnotu <i>n</i>-tého bitu čísla
<i>x</i>. Rozsah čísel reprezentovaných v&nbsp;<i>A(a,b)</i> je možné vyjádřit
nerovností:</p>

<p><i>-2<sup>N-1-b</sup> &le; x &le; 2<sup>N-1-b</sup>-1/2<sup>b</sup></i></p>

<p>Za zmínku stojí také skutečnost, že počet významových bitů je
v&nbsp;reprezentaci <i>A(a,b)</i> vždy o&nbsp;jednotku nižší, než
u&nbsp;reprezentace <i>U(a,b)</i>. Pro reprezentaci absolutní hodnoty čísla je
použito pouze nižších <i>N-1</i> bitů, nejvyšší bit je díky své funkci
označován jako <strong>znaménkový bit</strong> (<i>sign bit</i>), což je
ostatně patrné z&nbsp;podvýrazu <i>-2<sup>N-1</sup>x<sub>N-1</sub></i>.</p>



<p><a name="k06"></a></p>
<h2 id="k06">6. Základní vlastnosti čísel reprezentovaných v&nbsp;systému pevné řádové čárky</h2>

<p>V&nbsp;následujících odstavcích jsou vypsány základní vlastnosti numerických
hodnot, které jsou reprezentovány v&nbsp;systému s&nbsp;pevnou řádovou binární
čárkou. Pravidla jsou uvedena jak pro formát <i>U(a,b)</i> (tj.&nbsp;pouze pro
podmnožinu z&nbsp;kladných racionálních čísel), tak i pro formát <i>A(a,b)</i>,
tj.&nbsp;pro podmnožinu z&nbsp;kladných i záporných racionálních čísel. Každé
vlastnosti je věnována samostatná podkapitola.</p>



<p><a name="k061"></a></p>
<h2>6.1 Počet bitů</h2>

<p>Počet bitů nutných pro uložení číselné hodnoty v&nbsp;reprezentaci
<i>U(a,b)</i> je jednoduše roven výsledku výrazu <i>a+b</i>, což mimo jiné
značí, že&nbsp;všechny bity daného bitového vektoru jsou beze zbytku použity
pro uložení číselné hodnoty (nejsou rezervovány žádné speciální bity).
V&nbsp;reprezentaci <i>A(a,b)</i> je počet bitů roven hodnotě <i>a+b+1</i>,
protože jeden bit navíc je nutné rezervovat pro uložení znaménka ukládané
číselné hodnoty &ndash; viz výše zmíněný znaménkový bit.</p>



<p><a name="k062"></a></p>
<h2>6.2 Rozsah hodnot</h2>

<p>Rozsah hodnot v&nbsp;reprezentaci čísel ve&nbsp;formátu <i>U(a,b)</i> lze
vyjádřit vztahem <i>0&le; x<sub>1</sub> &le; 2<sup>a</sup>-2<sup>-b</sup></i>,
pro reprezentaci <i>A(a,b)</i> je rozsah hodnot vyjádřen nerovností:
<i>-2<sup>a</sup>&le; x<sub>2</sub> &le; 2<sup>a</sup>-2<sup>-b</sup></i>, což
značí, že&nbsp;ve druhém uvedeném typu reprezentace je možné zaznamenat
dvojnásobné množství navzájem odlišných hodnot &ndash; tato skutečnost je
ostatně dána i větším počtem bitů pro reprezentaci <i>A(a,b)</i> oproti
reprezentaci <i>U(a,b)</i> při stejných hodnotách parametrů <i>a</i> i
<i>b</i>.</p>



<p><a name="k063"></a></p>
<h2>6.3 Platnost aritmetické operace součtu či rozdílu</h2>

<p>Platnost aritmetické operace součtu či rozdílu hodnot uložených ve formátu
<i>U(a,b)</i> pro kladná čísla <i>U(a<sub>1</sub>,b<sub>1</sub>)<i> a
</i>U(a<sub>2</sub>,b<sub>2</sub>)</i> lze zaručit pouze tehdy, jestliže je
<i>a<sub>1</sub></i> rovno <i>a<sub>2</sub></i> a současně <i>b<sub>1</sub></i>
rovno <i>b<sub>2</sub></i>, tj.&nbsp;obě hodnoty jsou uloženy ve&nbsp;slově
(bitovém vektoru) se stejným množstvím (počtem) bitů a poloha řádové binární
čárky je konstantní. Pro číselné hodnoty uložené ve&nbsp;druhém popisovaném
formátu <i>A(a<sub>1</sub>,b<sub>1</sub>)<i> a
</i>A(a<sub>2</sub>,b<sub>2</sub>)</i> platí stejné podmínky. Pokud není
alespoň jedna z&nbsp;podmínek splněna, je nutné před provedením aditivní
operace provést konverzi hodnot na shodný formát <i>U(a<sub>x</sub>,
b<sub>y</sub>)</i> resp. <i>A(a<sub>x</sub>, b<sub>y</sub>)</i>.</p>



<p><a name="k064"></a></p>
<h2>6.4 Rozsah výsledků po aritmetické operaci sčítání</h2>

<p>Rozsah výsledků po aritmetické operaci sčítání dvou číselných hodnot
ve&nbsp;formátu <i>U(a,b)</i> lze vyjádřit následujícím způsobem:</p>

<p><i>U(a,b)+U(a,b)=U(a+1,b)</i></p>

<p>tj.&nbsp;pro uložení výsledku je obecně zapotřebí vyhradit slovo širší právě
o&nbsp;jeden bit. Pro dvě hodnoty ve&nbsp;formátu <i>A(a,b)</i> platí stejný
vztah, jelikož se počet bitů obecně také zvyšuje o&nbsp;jednotku bez ohledu na
znaménko výsledku:</p>

<p><i>A(a,b)+A(a,b)=A(a+1,b)</i></p>



<p><a name="k065"></a></p>
<h2>6.5 Rozsah výsledků po provedené aritmetické operaci násobení</h2>

<p>Rozsah výsledků po provedené aritmetické operaci násobení dvou libovolných
číselných hodnot uložených ve&nbsp;formátu
<i>U(a<sub>1</sub>,b<sub>1</sub>)</i> a <i>U(a<sub>2</sub>,b<sub>2</sub>)</i>
je možné vyjádřit následujícím vztahem:</p>

<p><i>U(a<sub>1</sub>, b<sub>1</sub>) &times; U(a<sub>2</sub>, b<sub>2</sub>)=U(a<sub>1</sub>+a<sub>2</sub>, b<sub>1</sub>+b<sub>2</sub>)</i></p>

<p>Výše uvedeným vztahem je popsáno, že se při ukládání výsledků takto
provedené multiplikativní operace zvyšuje jak počet významových bitů před
binární řádovou čárkou, tak i stejnou měrou počet zlomkových bitů,
tj.&nbsp;bitů umístěných za binární čárkou. Při provádění multiplikativní
operace s&nbsp;číselnými hodnotami uloženými ve&nbsp;formátu
<i>A(a<sub>1</sub>,b<sub>1</sub>)<i> a </i>A(a<sub>2</sub>,b<sub>2</sub>)</i>
je situace při ukládání výsledků následující:</p>

<p><i>A(a<sub>1</sub>,b<sub>1</sub>) &times; A(a<sub>2</sub>, b<sub>2</sub>)=A(a<sub>1</sub>+a<sub>2</sub>+1, b<sub>1</sub>+b<sub>2</sub>)</i></p>

<p>Tento vztah je poněkud odlišný od vztahu předchozího, ale při bližším
rozboru je opět snadno pochopitelný. U&nbsp;číselných hodnot ve&nbsp;formátu
<i>A(a,b)</i> je totiž jeden (nejvyšší) bit rezervován pro vyjádření znaménka
uložené hodnoty. Po násobení je také nutné vyjádřit znaménko výsledku, ale
opětovně pouze na jednom bitu, nikoli na bitech dvou.</p>

<p><div class="rs-tip-major">Poznámka: toto je důležitý závěr, který ovlivní
způsob realizace operace součinu.</div></p>



<p><a name="k07"></a></p>
<h2 id="k07">7. Praktická část</h2>

<p>Praktická část dnešního článku je rozdělena na dvě poloviny. V&nbsp;první
polovině si na jednoduchých příkladech ukážeme způsob realizace základních FX
operací, konkrétně operace součtu a taktéž operace součinu. A posléze si
ukážeme relativně složitější příklady, ve kterých budeme vykreslovat
Mandelbrotovu množinu (autorův oblíbený matematický objekt), a to plně
s&nbsp;využitím pouze FX operací a s&nbsp;využitím standardního grafického
režimu karty VGA s&nbsp;rozlišením 320&times;200 pixelů a s&nbsp;256 barvami.
Tyto příklady tedy budou bez problémů spustitelné i na IBM PC bez matematického
koprocesoru.</p>



<p><a name="k08"></a></p>
<h2 id="k08">8. Realizace operace součtu v&nbsp;systému pevné řádové čárky</h2>

<p>Implementačně nejjednodušší je realizace operace součtu nebo rozdílu,
protože tuto operaci je možné provést instrukcemi typu <strong>ADD</strong>,
<strong>SUB</strong> atd., a to bez ohledu na pozici binární řádové tečky.
V&nbsp;případě, že budeme pracovat s&nbsp;hodnotami s&nbsp;celkovou šířkou 32
bitů, přičemž 16 bitů je rezervováno pro část před tečkou a 16 bitů pro část za
tečkou, je součet triviální &ndash; použijeme instrukci <strong>ADD</strong>
s&nbsp;32bitovými registry použitými ve formě operandů:</p>

<pre>
<i>;-----------------------------------------------------------------------------</i>
org  0x100        <i>; zacatek kodu pro programy typu COM (vzdy se zacina na 256)</i>
&nbsp;
<strong>start</strong>:
        jmp main                   <i>; skok na zacatek kodu</i>
&nbsp;
%include "io.asm"                  <i>; nacist symboly, makra a podprogramy</i>
%include "print.asm"               <i>; nacist symboly, makra a podprogramy</i>
&nbsp;
P       equ     65536              <i>; poloha desetinne tecky v FX-pointu</i>
&nbsp;
<strong>main</strong>:
        mov  eax, 1 * P            <i>; konstanta v FX-pointu: 1.0</i>
        print_hex eax
&nbsp;
        mov  eax, 1 * P            <i>; konstanta v FX-pointu: 1.0</i>
        mov  ebx, 2 * P            <i>; konstanta v FX-pointu: 2.0</i>
        add  eax, ebx              <i>; scitani v FX-pointu</i>
        print_hex eax
&nbsp;
        mov  eax, 1 * P / 2        <i>; konstanta v FX-pointu: 0.5</i>
        print_hex eax
&nbsp;
        mov  eax, 3 * P / 2        <i>; konstanta v FX-pointu: 1.5</i>
        print_hex eax
&nbsp;
        mov  eax, 1 * P / 2        <i>; konstanta v FX-pointu: 0.5</i>
        mov  ebx, 3 * P / 2        <i>; konstanta v FX-pointu: 1.5</i>
        add  eax, ebx              <i>; scitani v FX-pointu</i>
        print_hex eax
&nbsp;
<strong>finish</strong>:
        wait_key                   <i>; cekani na klavesu</i>
        exit                       <i>; navrat do DOSu</i>
&nbsp;
&nbsp;
<i>; datova cast</i>
section .data
&nbsp;
section .bss
</pre>

<p>Výsledky v&nbsp;surové podobě tak, jak je vypsal příklad:</p>

<pre>
00010000
00030000
00008000
00018000
00020000
</pre>

<p>Což lze interpretovat následovně:</p>

<pre>
0001.0000 ≅ 1.0
&nbsp;
0003.0000 ≅ 1.0 + 2.0 = 3.0
&nbsp;
0000.8000 ≅ 0.5
0001.8000 ≅ 1.5
0002.0000 ≅ 0.5 + 1.5 = 2.0
</pre>



<p><a name="k09"></a></p>
<h2 id="k09">9. Součet realizovaný formou makra</h2>

<p>Vzhledem k&nbsp;jednoduchosti realizace součtu ve formátu pevné řádové tečky
můžeme tuto operaci navrhnout i formou makra, což se v&nbsp;assembleru NASM
provádí následujícím způsobem:</p>

<pre>
%macro <strong>fx_add</strong> 2
        add %1, %2
%endmacro
</pre>

<p>Celý příklad se potom změní jen nepatrně (expanze makra je podtržena):</p>

<pre>
<i>;-----------------------------------------------------------------------------</i>
org  0x100        <i>; zacatek kodu pro programy typu COM (vzdy se zacina na 256)</i>
&nbsp;
%macro <strong>fx_add</strong> 2
        add %1, %2
%endmacro
&nbsp;
&nbsp;
<strong>start</strong>:
        jmp main                   <i>; skok na zacatek kodu</i>
&nbsp;
%include "io.asm"                  <i>; nacist symboly, makra a podprogramy</i>
%include "print.asm"               <i>; nacist symboly, makra a podprogramy</i>
&nbsp;
P       equ     65536              <i>; poloha desetinne tecky v FX-pointu</i>
&nbsp;
<strong>main</strong>:
        mov  eax, 1 * P            <i>; konstanta v FX-pointu: 1.0</i>
        print_hex eax
&nbsp;
        mov  eax, 1 * P            <i>; konstanta v FX-pointu: 1.0</i>
        mov  ebx, 2 * P            <i>; konstanta v FX-pointu: 2.0</i>
        <u>fx_add eax, ebx</u>            <i>; scitani v FX-pointu</i>
        print_hex eax
&nbsp;
        mov  eax, 1 * P / 2        <i>; konstanta v FX-pointu: 0.5</i>
        mov  ebx, 3 * P / 2        <i>; konstanta v FX-pointu: 1.5</i>
        <u>fx_add eax, ebx</u>            <i>; scitani v FX-pointu</i>
        print_hex eax
&nbsp;
<strong>finish</strong>:
        wait_key                   <i>; cekani na klavesu</i>
        exit                       <i>; navrat do DOSu</i>
&nbsp;
&nbsp;
<i>; datova cast</i>
section .data
&nbsp;
section .bss
</pre>

<p>Výsledky by nyní měly vypadat následovně:</p>

<pre>
00010000 ≅ 1.0
00030000 ≅ 3.0 = 1.0 + 2.0
00020000 ≅ 2.0 = 0.5 + 1.5
</pre>



<p><a name="k10"></a></p>
<h2 id="k10">10. Realizace operace součinu: naivní varianta</h2>

<p>Jak jsme mohli vidět v&nbsp;předchozí dvojici kapitol, byla realizace
operace součtu s&nbsp;FX hodnotami triviální. Ovšem jak tomu bude u operace
součinu? Zkusme si nejdříve i tuto operaci realizovat tím nejvíce naivním
způsobem, konkrétně zavoláním instrukce <strong>MUL</strong>:</p>

<pre>
<i>;-----------------------------------------------------------------------------</i>
org  0x100        <i>; zacatek kodu pro programy typu COM (vzdy se zacina na 256)</i>
&nbsp;
<strong>start</strong>:
        jmp main                   <i>; skok na zacatek kodu</i>
&nbsp;
%include "io.asm"                  <i>; nacist symboly, makra a podprogramy</i>
%include "print.asm"               <i>; nacist symboly, makra a podprogramy</i>
&nbsp;
P       equ     65536              <i>; poloha desetinne tecky v FX-pointu</i>
&nbsp;
<strong>main</strong>:
        mov  eax, 2 * P            <i>; konstanta v FX-pointu: 2.0</i>
        print_hex eax
&nbsp;
        mov  eax, 3 * P            <i>; konstanta v FX-pointu: 3.0</i>
        print_hex eax
&nbsp;
        mov  eax, 2 * P            <i>; konstanta v FX-pointu: 1.0</i>
        mov  ebx, 3 * P            <i>; konstanta v FX-pointu: 2.0</i>
        mul  ebx                   <i>; nasobeni v FX-pointu do EDX:EAX</i>
        print_hex eax
&nbsp;
        mov  eax, 1 * P / 2        <i>; konstanta v FX-pointu: 0.5</i>
        print_hex eax
&nbsp;
        mov  eax, 3 * P            <i>; konstanta v FX-pointu: 3.0</i>
        print_hex eax
&nbsp;
        mov  eax, 1 * P / 2        <i>; konstanta v FX-pointu: 0.5</i>
        mov  ebx, 3 * P            <i>; konstanta v FX-pointu: 3.0</i>
        mul  ebx                   <i>; nasobeni v FX-pointu do EDX:EAX</i>
        print_hex eax
&nbsp;
<strong>finish</strong>:
        wait_key                   <i>; cekani na klavesu</i>
        exit                       <i>; navrat do DOSu</i>
&nbsp;
&nbsp;
<i>; datova cast</i>
section .data
&nbsp;
section .bss
</pre>

<p>Výsledky nebudou příliš uspokojivé:</p>

<pre>
00020000 ≅ 2.0
00030000 ≅ 3.0
&nbsp;
00000000 ≅ 0.0 ≠ 2.0 + 3.0
&nbsp;
00008000 ≅ 0.5
00030000 ≅ 3.0
80000000 ≅ 32768.0 ≠ 1.5
</pre>

<p>Vidíme, že tato realizace násobení je zcela evidentně nekorektní.</p>



<p><a name="k11"></a></p>
<h2 id="k11">11. Úprava operandů před provedením součinu</h2>

<pre>
        mov  eax, první_operand
        mov  ebx, druhý operand
        shr  eax, 8                <i>; posun jeste pred nasobenim (ztrata presnosti)</i>
        shr  ebx, 8                <i>; posun jeste pred nasobenim (ztrata presnosti)</i>
        mul  ebx                   <i>; nasobeni v FX-pointu do EDX:EAX</i>
</pre>

<pre>
<i>;-----------------------------------------------------------------------------</i>
org  0x100        <i>; zacatek kodu pro programy typu COM (vzdy se zacina na 256)</i>
&nbsp;
<strong>start</strong>:
        jmp main                   <i>; skok na zacatek kodu</i>
&nbsp;
%include "io.asm"                  <i>; nacist symboly, makra a podprogramy</i>
%include "print.asm"               <i>; nacist symboly, makra a podprogramy</i>
&nbsp;
P       equ     65536              <i>; poloha desetinne tecky v FX-pointu</i>
&nbsp;
<strong>main</strong>:
        mov  eax, 2 * P            <i>; konstanta v FX-pointu: 2.0</i>
        print_hex eax
&nbsp;
        mov  eax, 3 * P            <i>; konstanta v FX-pointu: 3.0</i>
        print_hex eax
&nbsp;
        mov  eax, 2 * P            <i>; konstanta v FX-pointu: 1.0</i>
        mov  ebx, 3 * P            <i>; konstanta v FX-pointu: 2.0</i>
        shr  eax, 8                <i>; posun jeste pred nasobenim (ztrata presnosti)</i>
        shr  ebx, 8                <i>; posun jeste pred nasobenim (ztrata presnosti)</i>
        mul  ebx                   <i>; nasobeni v FX-pointu do EDX:EAX</i>
        print_hex eax
&nbsp;
        mov  eax, 1 * P / 2        <i>; konstanta v FX-pointu: 0.5</i>
        print_hex eax
&nbsp;
        mov  eax, 3 * P            <i>; konstanta v FX-pointu: 3.0</i>
        print_hex eax
&nbsp;
        mov  eax, 1 * P / 2        <i>; konstanta v FX-pointu: 0.5</i>
        mov  ebx, 3 * P            <i>; konstanta v FX-pointu: 3.0</i>
        shr  eax, 8                <i>; posun jeste pred nasobenim (ztrata presnosti)</i>
        shr  ebx, 8                <i>; posun jeste pred nasobenim (ztrata presnosti)</i>
        mul  ebx                   <i>; nasobeni v FX-pointu do EDX:EAX</i>
        print_hex eax
&nbsp;
<strong>finish</strong>:
        wait_key                   <i>; cekani na klavesu</i>
        exit                       <i>; navrat do DOSu</i>
&nbsp;
&nbsp;
<i>; datova cast</i>
section .data
&nbsp;
section .bss
</pre>



<p><a name="k12"></a></p>
<h2 id="k12">12. Úprava operandů po provedení součinu</h2>

<pre>
        mov  eax, první_operand
        mov  ebx, druhý_operand
        mul  ebx                   <i>; nasobeni v FX-pointu do EDX:EAX</i>
        mov  ax, dx                <i>; bity 16-32</i>
        ror  eax, 16               <i>; prohodit horni a spodni polovinu registru</i>
</pre>

<pre>
<i>;-----------------------------------------------------------------------------</i>
org  0x100        <i>; zacatek kodu pro programy typu COM (vzdy se zacina na 256)</i>
&nbsp;
<strong>start</strong>:
        jmp main                   <i>; skok na zacatek kodu</i>
&nbsp;
%include "io.asm"                  <i>; nacist symboly, makra a podprogramy</i>
%include "print.asm"               <i>; nacist symboly, makra a podprogramy</i>
&nbsp;
P       equ     65536              <i>; poloha desetinne tecky v FX-pointu</i>
&nbsp;
<strong>main</strong>:
        mov  eax, 2 * P            <i>; konstanta v FX-pointu: 2.0</i>
        print_hex eax
&nbsp;
        mov  eax, 3 * P            <i>; konstanta v FX-pointu: 3.0</i>
        print_hex eax
&nbsp;
        mov  eax, 2 * P            <i>; konstanta v FX-pointu: 1.0</i>
        mov  ebx, 3 * P            <i>; konstanta v FX-pointu: 2.0</i>
        mul  ebx                   <i>; nasobeni v FX-pointu do EDX:EAX</i>
        mov  ax, dx                <i>; bity 16-32</i>
        ror  eax, 16               <i>; prohodit horni a spodni polovinu registru</i>
        print_hex eax
&nbsp;
        mov  eax, 1 * P / 2        <i>; konstanta v FX-pointu: 0.5</i>
        print_hex eax
&nbsp;
        mov  eax, 3 * P            <i>; konstanta v FX-pointu: 3.0</i>
        print_hex eax
&nbsp;
        mov  eax, 1 * P / 2        <i>; konstanta v FX-pointu: 0.5</i>
        mov  ebx, 3 * P            <i>; konstanta v FX-pointu: 3.0</i>
        mul  ebx                   <i>; nasobeni v FX-pointu do EDX:EAX</i>
        mov  ax, dx                <i>; bity 16-32</i>
        ror  eax, 16               <i>; prohodit horni a spodni polovinu registru</i>
        print_hex eax
&nbsp;
<strong>finish</strong>:
        wait_key                   <i>; cekani na klavesu</i>
        exit                       <i>; navrat do DOSu</i>
&nbsp;
&nbsp;
<i>; datova cast</i>
section .data
&nbsp;
section .bss
</pre>



<p><a name="k13"></a></p>
<h2 id="k13">13. </h2>

<pre>
#include <stdint.h>

uint32_t fx_add(uint32_t x, uint32_t y) {
    return x+y;
}

uint32_t fx_mul_1(uint32_t x, uint32_t y) {
    return (x>>8) * (y>>8);
}

uint32_t fx_mul_2(uint32_t x, uint32_t y) {
    return (x*y)>>16;
}
</pre>

<pre>
fx_add(unsigned int, unsigned int):
        push    rbp
        mov     rbp, rsp
        mov     DWORD PTR [rbp-4], edi
        mov     DWORD PTR [rbp-8], esi
        mov     edx, DWORD PTR [rbp-4]
        mov     eax, DWORD PTR [rbp-8]
        add     eax, edx
        pop     rbp
        ret

fx_mul_1(unsigned int, unsigned int):
        push    rbp
        mov     rbp, rsp
        mov     DWORD PTR [rbp-4], edi
        mov     DWORD PTR [rbp-8], esi
        mov     eax, DWORD PTR [rbp-4]
        shr     eax, 8
        mov     edx, eax
        mov     eax, DWORD PTR [rbp-8]
        shr     eax, 8
        imul    eax, edx
        pop     rbp
        ret

fx_mul_2(unsigned int, unsigned int):
        push    rbp
        mov     rbp, rsp
        mov     DWORD PTR [rbp-4], edi
        mov     DWORD PTR [rbp-8], esi
        mov     eax, DWORD PTR [rbp-4]
        imul    eax, DWORD PTR [rbp-8]
        shr     eax, 16
        pop     rbp
        ret
</pre>

<pre>
fx_add(unsigned int, unsigned int):
        lea     eax, [rdi+rsi]
        ret

fx_mul_1(unsigned int, unsigned int):
        shr     edi, 8
        shr     esi, 8
        mov     eax, edi
        imul    eax, esi
        ret

fx_mul_2(unsigned int, unsigned int):
        imul    edi, esi
        mov     eax, edi
        shr     eax, 16
        ret
</pre>

Os

<pre>
fx_add(unsigned int, unsigned int):
        lea     eax, [rdi+rsi]
        ret

fx_mul_1(unsigned int, unsigned int):
        shr     edi, 8
        shr     esi, 8
        mov     eax, edi
        imul    eax, esi
        ret

fx_mul_2(unsigned int, unsigned int):
        imul    edi, esi
        mov     eax, edi
        shr     eax, 16
        ret
</pre>



<p><a name="k14"></a></p>
<h2 id="k14">14. </h2>



<p><a name="k15"></a></p>
<h2 id="k15">15. Výpočet Mandelbrotovy množiny ve formátu s&nbsp;pevnou řádovou tečkou</h2>

<p></p>

<pre>
mov     EAX, dword [zx2]   <i>;</i>
sar     EAX, 8             <i>;</i>
imul    EAX                <i>; ZX3:=ZX2^2 (v X-pointu)</i>
mov     dword [zx3], EAX   <i>;</i>
</pre>

<p></p>

<pre>
mov     EAX, dword [zy2]   <i>;</i>
sar     EAX, 8             <i>;</i>
imul    EAX                <i>; ZY3:=ZY2^2 (v X-pointu)</i>
mov     dword [zy3], EAX   <i>;</i>
</pre>

<p></p>

<pre>
mov     EAX, [zx2]         <i>;</i>
sar     EAX, 8             <i>; ZX2 div 256 (pro mul v X-pointu)</i>
&nbsp;
mov     EBX, [zy2]         <i>;</i>
sar     EBX, 7             <i>; ZY2 div 256 * 2 (pro mul v X-pointu)</i>
&nbsp;
imul    EBX                <i>; ZY2:=2*ZX2*ZY2</i>
add     EAX, [zy1]         <i>; ZY2:=2*ZX2*ZY2+CY (u Mandelbrota poc.iter.)</i>
mov     [zy2], EAX         <i>; ulozit novou hodnotu ZY2</i>
</pre>

<p></p>

<pre>
mov     EAX, [zx3]         <i>;</i>
sub     EAX, [zy3]         <i>; ZX3:=ZX3-ZY3=ZX2^2-ZY2^2</i>
add     EAX, [zx1]         <i>;</i>
mov     [zx2], EAX         <i>; ZX2:=ZX2^2-ZY2^2+CX</i>
</pre>

<p></p>

<pre>
dec     CL                 <i>; upravit pocitadlo iteraci</i>
jz      short mpokrac      <i>; konec iteraci ?</i>
mov     EAX, [zx3]         <i>;</i>
add     EAX, [zy3]         <i>; ==ZX2^2+ZY2^2</i>
cmp     EAX, BAILOUT*P     <i>; kontrola na bailout (abs[Z]<4)</i>
jc      short iter_loop    <i>; abs[Z]<4 =>dalsi iterace</i>
</pre>



<p><a name="k16"></a></p>
<h2 id="k16">16. Základní způsob realizace výpočtů</h2>

<pre>
<i>;-----------------------------------------------------------------------------</i>
org  0x100        <i>; zacatek kodu pro programy typu COM (vzdy se zacina na 256)</i>

<i>; konstanty</i>
P       equ     65536              <i>; poloha desetinne tecky v X-pointu</i>
K       equ     4*P/256            <i>; vzdalenost mezi dvema body (krok smycky)</i>
L       equ     4*P/192
MIN     equ     -2*P               <i>; minimalni a maximalni hodnota konstant fraktalu</i>
                                   <i>; v komplexni rovine</i>
MAXITER equ     40                 <i>; maximalni pocet iteraci</i>
BAILOUT equ     4

section .text

start:
        jmp main                   <i>; skok na zacatek kodu</i>

%include "io.asm"                  <i>; nacist symboly, makra a podprogramy</i>


main:
        mov     ax, 13h            <i>; graficky rezim 320x200x256</i>
        int     10h

<i>;:::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::</i>
<i>;: MANDELBROTOVA MNOZINA                                                    ::</i>
<i>;:::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::</i>

        push    0xa000
        pop     ES                 <i>; segment obrazove pameti karty VGA</i>

        mov     DI, 320*8+32       <i>; zacatek vykreslovani na obrazovce</i>
        mov     BP, 192            <i>; BP==[x] fraktal bude velikosti 256x192 pixelu</i>
mforx:  mov     dword [zx1], MIN   <i>; od -2 (imaginarni osa)</i>
        mov     SI, 256            <i>; SI==[y]</i>
mfory:  mov     CL, MAXITER        <i>; maximalni pocet iteraci</i>
        xor     EAX, EAX           <i>;</i>
        mov     dword [zx2], EAX   <i>; nastaveni real.casti zacatku</i>
        mov     dword [zy2], EAX   <i>; nastaveni imag.casti zacatku</i>

iter_loop:                         <i>; *** iteracni smycka ***</i>
        mov     EAX, dword [zx2]   <i>;</i>
        sar     EAX, 8             <i>;</i>
        imul    EAX                <i>; ZX3:=ZX2^2 (v X-pointu)</i>
        mov     dword [zx3], EAX   <i>;</i>

        mov     EAX, dword [zy2]   <i>;</i>
        sar     EAX, 8             <i>;</i>
        imul    EAX                <i>; ZY3:=ZY2^2 (v X-pointu)</i>
        mov     dword [zy3], EAX   <i>;</i>

        mov     EAX, [zx2]         <i>;</i>
        sar     EAX, 8             <i>; ZX2 div 256 (pro mul v X-pointu)</i>

        mov     EBX, [zy2]         <i>;</i>
        sar     EBX, 7             <i>; ZY2 div 256 * 2 (pro mul v X-pointu)</i>

        imul    EBX                <i>; ZY2:=2*ZX2*ZY2</i>
        add     EAX, [zy1]         <i>; ZY2:=2*ZX2*ZY2+CY (u Mandelbrota poc.iter.)</i>
        mov     [zy2], EAX         <i>; ulozit novou hodnotu ZY2</i>

        mov     EAX, [zx3]         <i>;</i>
        sub     EAX, [zy3]         <i>; ZX3:=ZX3-ZY3=ZX2^2-ZY2^2</i>
        add     EAX, [zx1]         <i>;</i>
        mov     [zx2], EAX         <i>; ZX2:=ZX2^2-ZY2^2+CX</i>

        dec     CL                 <i>; upravit pocitadlo iteraci</i>
        jz      short mpokrac      <i>; konec iteraci ?</i>
        mov     EAX, [zx3]         <i>;</i>
        add     EAX, [zy3]         <i>; ==ZX2^2+ZY2^2</i>
        cmp     EAX, BAILOUT*P     <i>; kontrola na bailout (abs[Z]<4)</i>
        jc      short iter_loop    <i>; abs[Z]<4 =>dalsi iterace</i>
mpokrac:
        mov     AL, CL             <i>; pocet iteraci</i>
        add     AL, 32             <i>; posun na vhodne barvy v palete</i>
        stosb                      <i>; vykreslit pixel+posun na dalsi pixel</i>
        add     dword [zx1], K     <i>; ZY1:=ZY1+K</i>
        dec     si
        jnz     mfory              <i>; Y!=0 ->dalsi radek</i>
        add     DI, 320-256        <i>; dalsi radek na obrazovce</i>
        add     dword [zy1], L     <i>; ZX1:=ZX1+K</i>
        dec     BP                 <i>; x=x-1</i>
        jnz     mforx              <i>; X!=0 ->dalsi radek</i>

finish:
        wait_key                   <i>; cekani na klavesu</i>
        exit                       <i>; navrat do DOSu</i>


section .data

zy1     dd MIN                     <i>; poloha v komplexni rovine rovine</i>

section .bss

zx1     resd 1                     <i>;</i>
zx2     resd 1                     <i>;</i>
zy2     resd 1                     <i>; aktualni poloha v komplexni rovine</i>
zx3     resd 1                     <i>; zx3=zx2^2 (aby se to nemuselo pocitat 2x)</i>
zy3     resd 1                     <i>; zy3=zy2^2</i>



<i>; finito</i>
</pre>



<p><a name="k17"></a></p>
<h2 id="k17">17. </h2>



<p><a name="k18"></a></p>
<h2 id="k18">18. </h2>

<pre>
<i>;-----------------------------------------------------------------------------</i>
org  0x100        <i>; zacatek kodu pro programy typu COM (vzdy se zacina na 256)</i>

<i>; konstanty</i>
P       equ     4096               <i>; poloha desetinne tecky v X-pointu</i>
K       equ     4*P/256            <i>; vzdalenost mezi dvema body (krok smycky)</i>
L       equ     4*P/192
MIN     equ     -2*P               <i>; minimalni a maximalni hodnota konstant fraktalu</i>
                                   <i>; v komplexni rovine</i>
MAXITER equ     40                 <i>; maximalni pocet iteraci</i>
BAILOUT equ     4
SLOUPCU equ     320                <i>; pocet sloupcu na obrazovce</i>

section .text

start:
        jmp main                   <i>; skok na zacatek kodu</i>

%include "io.asm"                  <i>; nacist symboly, makra a podprogramy</i>


main:
        mov     ax, 13h            <i>; graficky rezim 320x200x256</i>
        int     10h

<i>;:::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::</i>
<i>;: MANDELBROTOVA MNOZINA                                                    ::</i>
<i>;:::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::</i>

        push    0xa000
        pop     ES                 <i>; segment obrazove pameti karty VGA</i>

        xor     DI, DI             <i>; zacatek vykreslovani na obrazovce</i>
        mov     CL, 6              <i>; posun pro FX format</i>

mforx:  mov     dword [zx1], MIN   <i>; od -2 (imaginarni osa)</i>
        mov     SI, SLOUPCU        <i>; x</i>
mfory:  mov     CH, MAXITER        <i>; pocet iteraci</i>
        xor     EAX, EAX           <i>;</i>
        mov     EBP, EAX           <i>; nastaveni real.casti zacatku</i>
        mov     dword [zy2], EAX   <i>; nastaveni imag.casti zacatku</i>
iter_loop:                         <i>; *** iteracni smycka ***</i>
        mov     EAX, EBP           <i>;</i>
        sar     EAX, CL            <i>;</i>
        imul    EAX                <i>; ZX3:=ZX2^2 (v X-pointu)</i>
        mov     dword [zx3], EAX   <i>;</i>

        mov     EAX, dword [zy2]   <i>;</i>
        sar     EAX, CL            <i>; </i>
        imul    EAX                <i>; ZY3:=ZY2^2 (v X-pointu)</i>
        mov     dword [zy3], EAX   <i>;</i>

        mov     EAX, EBP           <i>;</i>
        sar     EAX, CL            <i>; ZX2 div 256 (pro mul v X-pointu)</i>

        mov     EBX, [zy2]         <i>;</i>
        sar     EBX, 5             <i>; ZY2 div 256 * 2 (pro mul v X-pointu)</i>

        imul    EBX                <i>; ZY2:=2*ZX2*ZY2</i>
        add     EAX, [zy1]         <i>; ZY2:=2*ZX2*ZY2+CY (u Mandelbrota poc.iter.)</i>
        mov     [zy2], EAX         <i>; ulozit novou hodnotu ZY2</i>

        mov     EAX, [zx3]         <i>;</i>
        sub     EAX, [zy3]         <i>; ZX3:=ZX3-ZY3=ZX2^2-ZY2^2</i>
        add     EAX, [zx1]         <i>;</i>
        mov     EBP, EAX           <i>; ZX2:=ZX2^2-ZY2^2+CX</i>

        dec     CH                 <i>; pocitadlo iteraci</i>
        jz      short mpokrac      <i>; konec iteraci ?</i>
        mov     EAX, [zx3]         <i>;</i>
        add     EAX, [zy3]         <i>; ==ZX2^2+ZY2^2</i>
        cmp     EAX, BAILOUT*P     <i>; kontrola na bailout (abs[Z]<4)</i>
        jc      short iter_loop    <i>; abs[Z]<4 =>dalsi iterace</i>
mpokrac:
        mov     AL, CH             <i>; pocet iteraci</i>
        add     AL, 32             <i>; posun na vhodne barvy v palete</i>
        stosb                      <i>; vykreslit pixel+posun na dalsi pixel</i>
        add     dword [zx1], K     <i>; ZY1:=ZY1+K</i>
        dec     si
        jnz     short mfory        <i>; Y!=0 ->dalsi radek</i>

        add     dword [zy1], L     <i>; ZX1:=ZX1+K</i>
        cmp     di, 64000          <i>; konec obrazku ?</i>
        jne     mforx

finish:
        wait_key                   <i>; cekani na klavesu</i>
        exit                       <i>; navrat do DOSu</i>


section .data

zy1     dd MIN                     <i>; poloha v komplexni rovine rovine</i>

section .bss

zx1     resd 1                     <i>;</i>
zy2     resd 1                     <i>; aktualni poloha v komplexni rovine</i>
zx3     resd 1                     <i>; zx3=zx2^2 (aby se to nemuselo pocitat 2x)</i>
zy3     resd 1                     <i>; zy3=zy2^2</i>



<i>; finito</i>
</pre>



<p><a name="k19"></a></p>
<h2 id="k19">19. Repositář s&nbsp;demonstračními příklady</h2>

<p>Demonstrační příklady napsané v&nbsp;assembleru, které jsou určené pro
překlad s&nbsp;využitím assembleru <strong>NASM</strong>, byly uloženy do Git
repositáře, který je dostupný na adrese <a
href="https://github.com/tisnik/8bit-fame">https://github.com/tisnik/8bit-fame</a>.
Jednotlivé demonstrační příklady si můžete v&nbsp;případě potřeby stáhnout i
jednotlivě bez nutnosti klonovat celý (dnes již poměrně rozsáhlý)
repositář:</p>

<table>
<tr><th> #</th><th>Příklad</th><th>Stručný popis</th><th>Adresa</th></tr>
<tr><td> 1</td><td>hello.asm</td><td>program typu &bdquo;Hello world&ldquo; naprogramovaný v&nbsp;assembleru pro systém DOS</td><td><a href="https://github.com/tisnik/8bit-fame/blob/master/pc-dos/hello.asm">https://github.com/tisnik/8bit-fame/blob/master/pc-dos/hello.asm</a></td></tr>
<tr><td> 2</td><td>hello_shorter.asm</td><td>kratší varianta výskoku z&nbsp;procesu zpět do DOSu</td><td><a href="https://github.com/tisnik/8bit-fame/blob/master/pc-dos/hello_shorter.asm">https://github.com/tisnik/8bit-fame/blob/master/pc-dos/hello_shorter.asm</a></td></tr>
</table>



<p><a name="k20"></a></p>
<h2 id="k20">20. Odkazy na Internetu</h2>

<ol>

<li>VESA BIOS Extensions<br />
<a href="https://en.wikipedia.org/wiki/VESA_BIOS_Extensions">https://en.wikipedia.org/wiki/VESA_BIOS_Extensions</a>
</li>

<li>Video Electronics Standards Association<br />
<a href="https://en.wikipedia.org/wiki/Video_Electronics_Standards_Association">https://en.wikipedia.org/wiki/Video_Electronics_Standards_Association</a>
</li>

<li>DJGPP (Wikipedia)<br />
<a href="https://cs.wikipedia.org/wiki/DJGPP">https://cs.wikipedia.org/wiki/DJGPP</a>
</li>

<li>DJGPP home page<br />
<a href="http://www.delorie.com/djgpp/">http://www.delorie.com/djgpp/</a>
</li>

<li>DJGPP Zip File Picker<br />
<a href="http://www.delorie.com/djgpp/zip-picker.html">http://www.delorie.com/djgpp/zip-picker.html</a>
</li>

<li>The Intel 8088 Architecture and Instruction Set<br />
<a href="https://people.ece.ubc.ca/~edc/464/lectures/lec4.pdf">https://people.ece.ubc.ca/~edc/464/lectures/lec4.pdf</a>
</li>

<li>x86 Opcode Structure and Instruction Overview<br />
<a href="https://pnx.tf/files/x86_opcode_structure_and_instruction_overview.pdf">https://pnx.tf/files/x86_opcode_structure_and_instruction_overview.pdf</a>
</li>

<li>x86 instruction listings (Wikipedia)<br />
<a href="https://en.wikipedia.org/wiki/X86_instruction_listings">https://en.wikipedia.org/wiki/X86_instruction_listings</a>
</li>

<li>x86 assembly language (Wikipedia)<br />
<a href="https://en.wikipedia.org/wiki/X86_assembly_language">https://en.wikipedia.org/wiki/X86_assembly_language</a>
</li>

<li>Intel Assembler (Cheat sheet)<br />
<a href="http://www.jegerlehner.ch/intel/IntelCodeTable.pdf">http://www.jegerlehner.ch/intel/IntelCodeTable.pdf</a>
</li>

<li>25 Microchips That Shook the World<br />
<a href="https://spectrum.ieee.org/tech-history/silicon-revolution/25-microchips-that-shook-the-world">https://spectrum.ieee.org/tech-history/silicon-revolution/25-microchips-that-shook-the-world</a>
</li>

<li>Chip Hall of Fame: MOS Technology 6502 Microprocessor<br />
<a href="https://spectrum.ieee.org/tech-history/silicon-revolution/chip-hall-of-fame-mos-technology-6502-microprocessor">https://spectrum.ieee.org/tech-history/silicon-revolution/chip-hall-of-fame-mos-technology-6502-microprocessor</a>
</li>

<li>Chip Hall of Fame: Intel 8088 Microprocessor<br />
<a href="https://spectrum.ieee.org/tech-history/silicon-revolution/chip-hall-of-fame-intel-8088-microprocessor">https://spectrum.ieee.org/tech-history/silicon-revolution/chip-hall-of-fame-intel-8088-microprocessor</a>
</li>

<li>Jak se zrodil procesor?<br />
<a href="https://www.root.cz/clanky/jak-se-zrodil-procesor/">https://www.root.cz/clanky/jak-se-zrodil-procesor/</a>
</li>

<li>Apple II History Home<br />
<a href="http://apple2history.org/">http://apple2history.org/</a>
</li>

<li>The 8086/8088 Primer<br />
<a href="https://www.stevemorse.org/8086/index.html">https://www.stevemorse.org/8086/index.html</a>
</li>

<li>flat assembler: Assembly language resources<br />
<a href="https://flatassembler.net/">https://flatassembler.net/</a>
</li>

<li>FASM na Wikipedii<br />
<a href="https://en.wikipedia.org/wiki/FASM">https://en.wikipedia.org/wiki/FASM</a>
</li>

<li>Fresh IDE FASM inside<br />
<a href="https://fresh.flatassembler.net/">https://fresh.flatassembler.net/</a>
</li>

<li>MS-DOS Version 4.0 Programmer's Reference<br />
<a href="https://www.pcjs.org/documents/books/mspl13/msdos/dosref40/">https://www.pcjs.org/documents/books/mspl13/msdos/dosref40/</a>
</li>

<li>DOS API (Wikipedia)<br />
<a href="https://en.wikipedia.org/wiki/DOS_API">https://en.wikipedia.org/wiki/DOS_API</a>
</li>

<li>Bit banging<br />
<a href="https://en.wikipedia.org/wiki/Bit_banging">https://en.wikipedia.org/wiki/Bit_banging</a>
</li>

<li>IBM Basic assembly language and successors (Wikipedia)<br />
<a href="https://en.wikipedia.org/wiki/IBM_Basic_assembly_language_and_successors">https://en.wikipedia.org/wiki/IBM_Basic_assembly_language_and_successors</a>
</li>

<li>X86 Assembly/Bootloaders<br />
<a href="https://en.wikibooks.org/wiki/X86_Assembly/Bootloaders">https://en.wikibooks.org/wiki/X86_Assembly/Bootloaders</a>
</li>

<li>Počátky grafiky na PC: grafické karty CGA a Hercules<br />
<a href="https://www.root.cz/clanky/pocatky-grafiky-na-pc-graficke-karty-cga-a-hercules/">https://www.root.cz/clanky/pocatky-grafiky-na-pc-graficke-karty-cga-a-hercules/</a>
</li>

<li>Co mají společného Commodore PET/4000, BBC Micro, Amstrad CPC i grafické karty MDA, CGA a Hercules?<br />
<a href="https://www.root.cz/clanky/co-maji-spolecneho-commodore-pet-4000-bbc-micro-amstrad-cpc-i-graficke-karty-mda-cga-a-hercules/">https://www.root.cz/clanky/co-maji-spolecneho-commodore-pet-4000-bbc-micro-amstrad-cpc-i-graficke-karty-mda-cga-a-hercules/</a>
</li>

<li>Karta EGA: první použitelná barevná grafika na PC<br />
<a href="https://www.root.cz/clanky/karta-ega-prvni-pouzitelna-barevna-grafika-na-pc/">https://www.root.cz/clanky/karta-ega-prvni-pouzitelna-barevna-grafika-na-pc/</a>
</li>

<li>RGB Classic Games<br />
<a href="https://www.classicdosgames.com/">https://www.classicdosgames.com/</a>
</li>

<li>Turbo Assembler (Wikipedia)<br />
<a href="https://en.wikipedia.org/wiki/Turbo_Assembler">https://en.wikipedia.org/wiki/Turbo_Assembler</a>
</li>

<li>Microsoft Macro Assembler<br />
<a href="https://en.wikipedia.org/wiki/Microsoft_Macro_Assembler">https://en.wikipedia.org/wiki/Microsoft_Macro_Assembler</a>
</li>

<li>IBM Personal Computer (Wikipedia)<br />
<a href="https://en.wikipedia.org/wiki/IBM_Personal_Computer">https://en.wikipedia.org/wiki/IBM_Personal_Computer</a>
</li>

<li>Intel 8251<br />
<a href="https://en.wikipedia.org/wiki/Intel_8251">https://en.wikipedia.org/wiki/Intel_8251</a>
</li>

<li>Intel 8253<br />
<a href="https://en.wikipedia.org/wiki/Intel_8253">https://en.wikipedia.org/wiki/Intel_8253</a>
</li>

<li>Intel 8255<br />
<a href="https://en.wikipedia.org/wiki/Intel_8255">https://en.wikipedia.org/wiki/Intel_8255</a>
</li>

<li>Intel 8257<br />
<a href="https://en.wikipedia.org/wiki/Intel_8257">https://en.wikipedia.org/wiki/Intel_8257</a>
</li>

<li>Intel 8259<br />
<a href="https://en.wikipedia.org/wiki/Intel_8259">https://en.wikipedia.org/wiki/Intel_8259</a>
</li>

<li>Support/peripheral/other chips - 6800 family<br />
<a href="http://www.cpu-world.com/Support/6800.html">http://www.cpu-world.com/Support/6800.html</a>
</li>

<li>Motorola 6845<br />
<a href="http://en.wikipedia.org/wiki/Motorola_6845">http://en.wikipedia.org/wiki/Motorola_6845</a>
</li>

<li>The 6845 Cathode Ray Tube Controller (CRTC)<br />
<a href="http://www.tinyvga.com/6845">http://www.tinyvga.com/6845</a>
</li>

<li>CRTC operation<br />
<a href="http://www.6502.org/users/andre/hwinfo/crtc/crtc.html">http://www.6502.org/users/andre/hwinfo/crtc/crtc.html</a>
</li>

<li>The 6845 Cathode Ray Tube Controller (CRTC)<br />
<a href="http://www.tinyvga.com/6845">http://www.tinyvga.com/6845</a>
</li>

<li>Motorola 6845 and bitwise graphics<br />
<a href="https://retrocomputing.stackexchange.com/questions/10996/motorola-6845-and-bitwise-graphics">https://retrocomputing.stackexchange.com/questions/10996/motorola-6845-and-bitwise-graphics</a>
</li>

<li>IBM Monochrome Display Adapter<br />
<a href="http://en.wikipedia.org/wiki/Monochrome_Display_Adapter">http://en.wikipedia.org/wiki/Monochrome_Display_Adapter</a>
</li>

<li>Color Graphics Adapter<br />
<a href="http://en.wikipedia.org/wiki/Color_Graphics_Adapter">http://en.wikipedia.org/wiki/Color_Graphics_Adapter</a>
</li>

<li>Color Graphics Adapter and the Brown color in IBM 5153 Color Display<br />
<a href="https://www.aceinnova.com/en/electronics/cga-and-the-brown-color-in-ibm-5153-color-display/">https://www.aceinnova.com/en/electronics/cga-and-the-brown-color-in-ibm-5153-color-display/</a>
</li>

<li>The Modern Retrocomputer: An Arduino Driven 6845 CRT Controller<br />
<a href="https://hackaday.com/2017/05/14/the-modern-retrocomputer-an-arduino-driven-6845-crt-controller/">https://hackaday.com/2017/05/14/the-modern-retrocomputer-an-arduino-driven-6845-crt-controller/</a>
</li>

<li>flat assembler: Assembly language resources<br />
<a href="https://flatassembler.net/">https://flatassembler.net/</a>
</li>

<li>FASM na Wikipedii<br />
<a href="https://en.wikipedia.org/wiki/FASM">https://en.wikipedia.org/wiki/FASM</a>
</li>

<li>Fresh IDE FASM inside<br />
<a href="https://fresh.flatassembler.net/">https://fresh.flatassembler.net/</a>
</li>

<li>MS-DOS Version 4.0 Programmer's Reference<br />
<a href="https://www.pcjs.org/documents/books/mspl13/msdos/dosref40/">https://www.pcjs.org/documents/books/mspl13/msdos/dosref40/</a>
</li>

<li>DOS API (Wikipedia)<br />
<a href="https://en.wikipedia.org/wiki/DOS_API">https://en.wikipedia.org/wiki/DOS_API</a>
</li>

<li>IBM Basic assembly language and successors (Wikipedia)<br />
<a href="https://en.wikipedia.org/wiki/IBM_Basic_assembly_language_and_successors">https://en.wikipedia.org/wiki/IBM_Basic_assembly_language_and_successors</a>
</li>

<li>X86 Assembly/Arithmetic<br />
<a href="https://en.wikibooks.org/wiki/X86_Assembly/Arithmetic">https://en.wikibooks.org/wiki/X86_Assembly/Arithmetic</a>
</li>

<li>Art of Assembly - Arithmetic Instructions<br />
<a href="http://oopweb.com/Assembly/Documents/ArtOfAssembly/Volume/Chapter_6/CH06-2.html">http://oopweb.com/Assembly/Documents/ArtOfAssembly/Volume/Chapter_6/CH06-2.html</a>
</li>

<li>ASM Flags<br />
<a href="http://www.cavestory.org/guides/csasm/guide/asm_flags.html">http://www.cavestory.org/guides/csasm/guide/asm_flags.html</a>
</li>

<li>Status Register<br />
<a href="https://en.wikipedia.org/wiki/Status_register">https://en.wikipedia.org/wiki/Status_register</a>
</li>

<li>Linux assemblers: A comparison of GAS and NASM<br />
<a href="http://www.ibm.com/developerworks/library/l-gas-nasm/index.html">http://www.ibm.com/developerworks/library/l-gas-nasm/index.html</a>
</li>

<li>Programovani v assembleru na OS Linux<br />
<a href="http://www.cs.vsb.cz/grygarek/asm/asmlinux.html">http://www.cs.vsb.cz/grygarek/asm/asmlinux.html</a>
</li>

<li>Is it worthwhile to learn x86 assembly language today?<br />
<a href="https://www.quora.com/Is-it-worthwhile-to-learn-x86-assembly-language-today?share=1">https://www.quora.com/Is-it-worthwhile-to-learn-x86-assembly-language-today?share=1</a>
</li>

<li>Why Learn Assembly Language?<br />
<a href="http://www.codeproject.com/Articles/89460/Why-Learn-Assembly-Language">http://www.codeproject.com/Articles/89460/Why-Learn-Assembly-Language</a>
</li>

<li>Is Assembly still relevant?<br />
<a href="http://programmers.stackexchange.com/questions/95836/is-assembly-still-relevant">http://programmers.stackexchange.com/questions/95836/is-assembly-still-relevant</a>
</li>

<li>Why Learning Assembly Language Is Still a Good Idea<br />
<a href="http://www.onlamp.com/pub/a/onlamp/2004/05/06/writegreatcode.html">http://www.onlamp.com/pub/a/onlamp/2004/05/06/writegreatcode.html</a>
</li>

<li>Assembly language today<br />
<a href="http://beust.com/weblog/2004/06/23/assembly-language-today/">http://beust.com/weblog/2004/06/23/assembly-language-today/</a>
</li>

<li>Assembler: Význam assembleru dnes<br />
<a href="http://www.builder.cz/rubriky/assembler/vyznam-assembleru-dnes-155960cz">http://www.builder.cz/rubriky/assembler/vyznam-assembleru-dnes-155960cz</a>
</li>

<li>Programming from the Ground Up Book - Summary<br />
<a href="http://savannah.nongnu.org/projects/pgubook/">http://savannah.nongnu.org/projects/pgubook/</a>
</li>

<li>DOSBox<br />
<a href="https://www.dosbox.com/">https://www.dosbox.com/</a>
</li>

<li>The C Programming Language<br />
<a href="https://en.wikipedia.org/wiki/The_C_Programming_Language">https://en.wikipedia.org/wiki/The_C_Programming_Language</a>
</li>

<li>Hercules Graphics Card (HCG)<br />
<a href="https://en.wikipedia.org/wiki/Hercules_Graphics_Card">https://en.wikipedia.org/wiki/Hercules_Graphics_Card</a>
</li>

<li>Complete 8086 instruction set<br />
<a href="https://content.ctcd.edu/courses/cosc2325/m22/docs/emu8086ins.pdf">https://content.ctcd.edu/courses/cosc2325/m22/docs/emu8086ins.pdf</a>
</li>

<li>Complete 8086 instruction set<br />
<a href="https://yassinebridi.github.io/asm-docs/8086_instruction_set.html">https://yassinebridi.github.io/asm-docs/8086_instruction_set.html</a>
</li>

<li>8088 MPH by Hornet + CRTC + DESiRE (final version)<br />
<a href="https://www.youtube.com/watch?v=hNRO7lno_DM">https://www.youtube.com/watch?v=hNRO7lno_DM</a>
</li>

<li>Area 5150 by CRTC &amp; Hornet (Party Version) / IBM PC+CGA Demo, Hardware Capture<br />
<a href="https://www.youtube.com/watch?v=fWDxdoRTZPc">https://www.youtube.com/watch?v=fWDxdoRTZPc</a>
</li>

<li>80x86 Integer Instruction Set Timings (8088 - Pentium)<br />
<a href="http://aturing.umcs.maine.edu/~meadow/courses/cos335/80x86-Integer-Instruction-Set-Clocks.pdf">http://aturing.umcs.maine.edu/~meadow/courses/cos335/80x86-Integer-Instruction-Set-Clocks.pdf</a>
</li>

<li>Colour Graphics Adapter: Notes<br />
<a href="https://www.seasip.info/VintagePC/cga.html">https://www.seasip.info/VintagePC/cga.html</a>
</li>

<li>Restoring A Vintage CGA Card With Homebrew HASL<br />
<a href="https://hackaday.com/2024/06/12/restoring-a-vintage-cga-card-with-homebrew-hasl/">https://hackaday.com/2024/06/12/restoring-a-vintage-cga-card-with-homebrew-hasl/</a>
</li>

<li>Demoing An 8088<br />
<a href="https://hackaday.com/2015/04/10/demoing-an-8088/">https://hackaday.com/2015/04/10/demoing-an-8088/</a>
</li>

<li>Video Memory Layouts<br />
<a href="http://www.techhelpmanual.com/89-video_memory_layouts.html">http://www.techhelpmanual.com/89-video_memory_layouts.html</a>
</li>

<li>Screen Attributes<br />
<a href="http://www.techhelpmanual.com/87-screen_attributes.html">http://www.techhelpmanual.com/87-screen_attributes.html</a>
</li>

<li>IBM PC Family  -  BIOS Video Modes<br />
<a href="https://www.minuszerodegrees.net/video/bios_video_modes.htm">https://www.minuszerodegrees.net/video/bios_video_modes.htm</a>
</li>

<li>EGA Functions<br />
<a href="https://cosmodoc.org/topics/ega-functions/#the-hierarchy-of-the-ega">https://cosmodoc.org/topics/ega-functions/#the-hierarchy-of-the-ega</a>
</li>

<li>Why the EGA can only use 16 of its 64 colours in 200-line modes<br />
<a href="https://www.reenigne.org/blog/why-the-ega-can-only-use-16-of-its-64-colours-in-200-line-modes/">https://www.reenigne.org/blog/why-the-ega-can-only-use-16-of-its-64-colours-in-200-line-modes/</a>
</li>

<li>How 16 colors saved PC gaming - the story of EGA graphics<br />
<a href="https://www.custompc.com/retro-tech/ega-graphics">https://www.custompc.com/retro-tech/ega-graphics</a>
</li>

<li>List of 16-bit computer color palettes<br />
<a href="https://en.wikipedia.org/wiki/List_of_16-bit_computer_color_palettes">https://en.wikipedia.org/wiki/List_of_16-bit_computer_color_palettes</a>
</li>

<li>Why were those colors chosen to be the default palette for 256-color VGA?<br />
<a href="https://retrocomputing.stackexchange.com/questions/27994/why-were-those-colors-chosen-to-be-the-default-palette-for-256-color-vga">https://retrocomputing.stackexchange.com/questions/27994/why-were-those-colors-chosen-to-be-the-default-palette-for-256-color-vga</a>
</li>

<li>VGA Color Palettes<br />
<a href="https://www.fountainware.com/EXPL/vga_color_palettes.htm">https://www.fountainware.com/EXPL/vga_color_palettes.htm</a>
</li>

<li>Hardware Level VGA and SVGA Video Programming Information Page<br />
<a href="http://www.osdever.net/FreeVGA/vga/vga.htm">http://www.osdever.net/FreeVGA/vga/vga.htm</a>
</li>

<li>Hardware Level VGA and SVGA Video Programming Information Page - sequencer<br />
<a href="http://www.osdever.net/FreeVGA/vga/seqreg.htm">http://www.osdever.net/FreeVGA/vga/seqreg.htm</a>
</li>

<li>VGA Basics<br />
<a href="http://www.brackeen.com/vga/basics.html">http://www.brackeen.com/vga/basics.html</a>
</li>

<li>Introduction to VGA Mode 'X'<br />
<a href="https://web.archive.org/web/20160414072210/http://fly.srk.fer.hr/GDM/articles/vgamodex/vgamx1.html">https://web.archive.org/web/20160414072210/http://fly.srk.fer.hr/GDM/articles/vgamodex/vgamx1.html</a>
</li>

<li>VGA Mode-X<br />
<a href="https://web.archive.org/web/20070123192523/http://www.gamedev.net/reference/articles/article356.asp">https://web.archive.org/web/20070123192523/http://www.gamedev.net/reference/articles/article356.asp</a>
</li>

<li>Mode-X: 256-Color VGA Magic<br />
<a href="https://downloads.gamedev.net/pdf/gpbb/gpbb47.pdf">https://downloads.gamedev.net/pdf/gpbb/gpbb47.pdf</a>
</li>

<li>Instruction Format in 8086 Microprocessor<br />
<a href="https://www.includehelp.com/embedded-system/instruction-format-in-8086-microprocessor.aspx">https://www.includehelp.com/embedded-system/instruction-format-in-8086-microprocessor.aspx</a>
</li>

<li>How to use "AND," "OR," and "XOR" modes for VGA Drawing<br />
<a href="https://retrocomputing.stackexchange.com/questions/21936/how-to-use-and-or-and-xor-modes-for-vga-drawing">https://retrocomputing.stackexchange.com/questions/21936/how-to-use-and-or-and-xor-modes-for-vga-drawing</a>
</li>

<li>VGA Hardware<br />
<a href="https://wiki.osdev.org/VGA_Hardware">https://wiki.osdev.org/VGA_Hardware</a>
</li>

<li>Programmer's Guide to Yamaha YMF 262/OPL3 FM Music Synthesizer<br />
<a href="https://moddingwiki.shikadi.net/wiki/OPL_chip">https://moddingwiki.shikadi.net/wiki/OPL_chip</a>
</li>

<li>Does anybody understand how OPL2 percussion mode works?<br />
<a href="https://forum.vcfed.org/index.php?threads/does-anybody-understand-how-opl2-percussion-mode-works.60925/">https://forum.vcfed.org/index.php?threads/does-anybody-understand-how-opl2-percussion-mode-works.60925/</a>
</li>

<li>Yamaha YMF262 OPL3 music - MoonDriver for OPL3 DEMO [Oscilloscope View]<br />
<a href="https://www.youtube.com/watch?v=a7I-QmrkAak">https://www.youtube.com/watch?v=a7I-QmrkAak</a>
</li>

<li>Yamaha OPL vs OPL2 vs OPL3 comparison<br />
<a href="https://www.youtube.com/watch?v=5knetge5Gs0">https://www.youtube.com/watch?v=5knetge5Gs0</a>
</li>

<li>OPL3 Music Crockett's Theme<br />
<a href="https://www.youtube.com/watch?v=HXS008pkgSQ">https://www.youtube.com/watch?v=HXS008pkgSQ</a>
</li>

<li>Bad Apple (Adlib Tracker - OPL3)<br />
<a href="https://www.youtube.com/watch?v=2lEPH6Y3Luo">https://www.youtube.com/watch?v=2lEPH6Y3Luo</a>
</li>

<li>FM Synthesis Chips, Codecs and DACs<br />
<a href="https://www.dosdays.co.uk/topics/fm_synthesizers.php">https://www.dosdays.co.uk/topics/fm_synthesizers.php</a>
</li>

<li>The Zen Challenge - YMF262 OPL3 Original (For an upcoming game)<br />
<a href="https://www.youtube.com/watch?v=6JlFIFz1CFY">https://www.youtube.com/watch?v=6JlFIFz1CFY</a>
</li>

<li>[adlib tracker II techno music - opl3] orbit around alpha andromedae I<br />
<a href="https://www.youtube.com/watch?v=YqxJCu_WFuA">https://www.youtube.com/watch?v=YqxJCu_WFuA</a>
</li>

<li>[adlib tracker 2 music - opl3 techno] hybridisation process on procyon-ii<br />
<a href="https://www.youtube.com/watch?v=daSV5mN0sJ4">https://www.youtube.com/watch?v=daSV5mN0sJ4</a>
</li>

<li>Hyper Duel - Black Rain (YMF262 OPL3 Cover)<br />
<a href="https://www.youtube.com/watch?v=pu_mzRRq8Ho">https://www.youtube.com/watch?v=pu_mzRRq8Ho</a>
</li>

<li>IBM 5155-5160 Technical Reference<br />
<a href="https://www.minuszerodegrees.net/manuals/IBM/IBM_5155_5160_Technical_Reference_6280089_MAR86.pdf">https://www.minuszerodegrees.net/manuals/IBM/IBM_5155_5160_Technical_Reference_6280089_MAR86.pdf</a>
</li>

<li>a ymf262/opl3+pc speaker thing i made<br />
<a href="https://www.youtube.com/watch?v=E-Mx0lEmnZ0">https://www.youtube.com/watch?v=E-Mx0lEmnZ0</a>
</li>

<li>[OPL3] Like a Thunder<br />
<a href="https://www.youtube.com/watch?v=MHf06AGr8SU">https://www.youtube.com/watch?v=MHf06AGr8SU</a>
</li>

<li>(PC SPEAKER) bad apple<br />
<a href="https://www.youtube.com/watch?v=LezmKIIHyUg">https://www.youtube.com/watch?v=LezmKIIHyUg</a>
</li>

<li>Powering devices from PC parallel port<br />
<a href="http://www.epanorama.net/circuits/lptpower.html">http://www.epanorama.net/circuits/lptpower.html</a>
</li>

<li>Magic Mushroom (demo pro PC s DOSem)<br />
<a href="http://www.crossfire-designs.de/download/articles/soundcards//mushroom.rar">http://www.crossfire-designs.de/download/articles/soundcards//mushroom.rar</a>
</li>

<li>Píseň Magic Mushroom - originál<br />
<a href="http://www.crossfire-designs.de/download/articles/soundcards/speaker_mushroom_converted.mp3">http://www.crossfire-designs.de/download/articles/soundcards/speaker_mushroom_converted.mp3</a>
</li>

<li>Píseň Magic Mushroom - hráno na PC Speakeru<br />
<a href="http://www.crossfire-designs.de/download/articles/soundcards/speaker_mushroom_speaker.mp3">http://www.crossfire-designs.de/download/articles/soundcards/speaker_mushroom_speaker.mp3</a>
</li>

<li>Pulse Width Modulation (PWM) Simulation Example<br />
<a href="http://decibel.ni.com/content/docs/DOC-4599">http://decibel.ni.com/content/docs/DOC-4599</a>
</li>

<li>Resistor/Pulse Width Modulation DAC<br />
<a href="http://www.k9spud.com/traxmod/pwmdac.php">http://www.k9spud.com/traxmod/pwmdac.php</a>
</li>

<li>Class D Amplifier<br />
<a href="http://en.wikipedia.org/wiki/Electronic_amplifier#Class_D">http://en.wikipedia.org/wiki/Electronic_amplifier#Class_D</a>
</li>

<li>Covox Speech Thing / Disney Sound Source (1986)<br />
<a href="http://www.crossfire-designs.de/index.php?lang=en&amp;what=articles&amp;name=showarticle.htm&amp;article=soundcards/&amp;page=5">http://www.crossfire-designs.de/index.php?lang=en&amp;what=articles&amp;name=showarticle.htm&amp;article=soundcards/&amp;page=5</a>
</li>

<li>Covox Digital-Analog Converter (Rusky, obsahuje schémata)<br />
<a href="http://phantom.sannata.ru/konkurs/netskater002.shtml">http://phantom.sannata.ru/konkurs/netskater002.shtml</a>
</li>

<li>PC-GPE on the Web<br />
<a href="http://bespin.org/~qz/pc-gpe/">http://bespin.org/~qz/pc-gpe/</a>
</li>

<li>Keyboard Synthesizer<br />
<a href="http://www.solarnavigator.net/music/instruments/keyboards.htm">http://www.solarnavigator.net/music/instruments/keyboards.htm</a>
</li>

<li>FMS - Fully Modular Synthesizer<br />
<a href="http://fmsynth.sourceforge.net/">http://fmsynth.sourceforge.net/</a>
</li>

<li>Javasynth<br />
<a href="http://javasynth.sourceforge.net/">http://javasynth.sourceforge.net/</a>
</li>

<li>Software Sound Synthesis &amp; Music Composition Packages<br />
<a href="http://www.linux-sound.org/swss.html">http://www.linux-sound.org/swss.html</a>
</li>

<li>Mx44.1 Download Page (software synthesizer for linux)<br />
<a href="http://hem.passagen.se/ja_linux/">http://hem.passagen.se/ja_linux/</a>
</li>

<li>Software synthesizer<br />
<a href="http://en.wikipedia.org/wiki/Software_synthesizer">http://en.wikipedia.org/wiki/Software_synthesizer</a>
</li>

<li>Frequency modulation synthesis<br />
<a href="http://en.wikipedia.org/wiki/Frequency_modulation_synthesis">http://en.wikipedia.org/wiki/Frequency_modulation_synthesis</a>
</li>

<li>Yamaha DX7<br />
<a href="http://en.wikipedia.org/wiki/Yamaha_DX7">http://en.wikipedia.org/wiki/Yamaha_DX7</a>
</li>

<li>Wave of the Future<br />
<a href="http://www.wired.com/wired/archive/2.03/waveguides_pr.html">http://www.wired.com/wired/archive/2.03/waveguides_pr.html</a>
</li>

<li>Analog synthesizer<br />
<a href="http://en.wikipedia.org/wiki/Analog_synthesizer">http://en.wikipedia.org/wiki/Analog_synthesizer</a>
</li>

<li>Minimoog<br />
<a href="http://en.wikipedia.org/wiki/Minimoog">http://en.wikipedia.org/wiki/Minimoog</a>
</li>

<li>Moog synthesizer<br />
<a href="http://en.wikipedia.org/wiki/Moog_synthesizer">http://en.wikipedia.org/wiki/Moog_synthesizer</a>
</li>

<li>Tutorial for Frequency Modulation Synthesis<br />
<a href="http://www.sfu.ca/~truax/fmtut.html">http://www.sfu.ca/~truax/fmtut.html</a>
</li>

<li>An Introduction To FM<br />
<a href="http://ccrma.stanford.edu/software/snd/snd/fm.html">http://ccrma.stanford.edu/software/snd/snd/fm.html</a>
</li>

<li>John Chowning<br />
<a href="http://en.wikipedia.org/wiki/John_Chowning">http://en.wikipedia.org/wiki/John_Chowning</a>
</li>

<li>I'm Impressed, Adlib Music is AMAZING!<br />
<a href="https://www.youtube.com/watch?v=PJNjQYp1ras">https://www.youtube.com/watch?v=PJNjQYp1ras</a>
</li>

<li>Milinda- Diode Milliampere ( OPL3 )<br />
<a href="https://www.youtube.com/watch?v=oNhazT5HG0E">https://www.youtube.com/watch?v=oNhazT5HG0E</a>
</li>

<li>Dune 2 - Roland MT-32 Soundtrack <br />
<a href="https://www.youtube.com/watch?v=kQADZeB-z8M">https://www.youtube.com/watch?v=kQADZeB-z8M</a>
</li>

<li>Interrupts<br />
<a href="https://wiki.osdev.org/Interrupts#Types_of_Interrupts">https://wiki.osdev.org/Interrupts#Types_of_Interrupts</a>
</li>

<li>Assembly8086SoundBlasterDmaSingleCycleMode<br />
<a href="https://github.com/leonardo-ono/Assembly8086SoundBlasterDmaSingleCycleMode/blob/master/sbsc.asm">https://github.com/leonardo-ono/Assembly8086SoundBlasterDmaSingleCycleMode/blob/master/sbsc.asm</a>
</li>

<li>Interrupts in 8086 microprocessor<br />
<a href="https://www.geeksforgeeks.org/interrupts-in-8086-microprocessor/">https://www.geeksforgeeks.org/interrupts-in-8086-microprocessor/</a>
</li>

<li>Interrupt Structure of 8086<br />
<a href="https://www.eeeguide.com/interrupt-structure-of-8086/">https://www.eeeguide.com/interrupt-structure-of-8086/</a>
</li>

<li>A20 line<br />
<a href="https://en.wikipedia.org/wiki/A20_line">https://en.wikipedia.org/wiki/A20_line</a>
</li>

<li>Extended memory<br />
<a href="https://en.wikipedia.org/wiki/Extended_memory#eXtended_Memory_Specification_(XMS)">https://en.wikipedia.org/wiki/Extended_memory#eXtended_Memory_Specification_(XMS)</a>
</li>

<li>Expanded memory<br />
<a href="https://en.wikipedia.org/wiki/Expanded_memory">https://en.wikipedia.org/wiki/Expanded_memory</a>
</li>

<li>Protected mode<br />
<a href="https://en.wikipedia.org/wiki/Protected_mode">https://en.wikipedia.org/wiki/Protected_mode</a>
</li>

<li>Virtual 8086 mode<br />
<a href="https://en.wikipedia.org/wiki/Virtual_8086_mode">https://en.wikipedia.org/wiki/Virtual_8086_mode</a>
</li>

<li>Unreal mode<br />
<a href="https://en.wikipedia.org/wiki/Unreal_mode">https://en.wikipedia.org/wiki/Unreal_mode</a>
</li>

<li>DOS memory management<br />
<a href="https://en.wikipedia.org/wiki/DOS_memory_management">https://en.wikipedia.org/wiki/DOS_memory_management</a>
</li>

<li>Upper memory area<br />
<a href="https://en.wikipedia.org/wiki/Upper_memory_area">https://en.wikipedia.org/wiki/Upper_memory_area</a>
</li>

<li>Removing the Mystery from SEGMENT : OFFSET Addressing<br />
<a href="https://thestarman.pcministry.com/asm/debug/Segments.html">https://thestarman.pcministry.com/asm/debug/Segments.html</a>
</li>

<li>Segment descriptor<br />
<a href="https://en.wikipedia.org/wiki/Segment_descriptor">https://en.wikipedia.org/wiki/Segment_descriptor</a>
</li>

<li>When using a 32-bit register to address memory in the real mode, contents of the register must never exceed 0000FFFFH. Why?<br />
<a href="https://stackoverflow.com/questions/45094696/when-using-a-32-bit-register-to-address-memory-in-the-real-mode-contents-of-the">https://stackoverflow.com/questions/45094696/when-using-a-32-bit-register-to-address-memory-in-the-real-mode-contents-of-the</a>
</li>

<li>A Brief History of Unreal Mode<br />
<a href="https://www.os2museum.com/wp/a-brief-history-of-unreal-mode/">https://www.os2museum.com/wp/a-brief-history-of-unreal-mode/</a>
</li>

<li>Segment Limits<br />
<a href="https://wiki.osdev.org/Segment_Limits">https://wiki.osdev.org/Segment_Limits</a>
</li>

<li>How do 32 bit addresses in real mode work?<br />
<a href="https://forum.osdev.org/viewtopic.php?t=30642">https://forum.osdev.org/viewtopic.php?t=30642</a>
</li>

<li>The LOADALL Instruction by Robert Collins<br />
<a href="https://www.rcollins.org/articles/loadall/tspec_a3_doc.html">https://www.rcollins.org/articles/loadall/tspec_a3_doc.html</a>
</li>

<li>How do you put a 286 in Protected Mode?<br />
<a href="https://retrocomputing.stackexchange.com/questions/7683/how-do-you-put-a-286-in-protected-mode">https://retrocomputing.stackexchange.com/questions/7683/how-do-you-put-a-286-in-protected-mode</a>
</li>

<li>Control register<br />
<a href="https://en.wikipedia.org/wiki/Control_register">https://en.wikipedia.org/wiki/Control_register</a>
</li>

<li>CPU Registers x86<br />
<a href="https://wiki.osdev.org/CPU_Registers_x86">https://wiki.osdev.org/CPU_Registers_x86</a>
</li>

<li>x86 Assembly/Protected Mode<br />
<a href="https://en.wikibooks.org/wiki/X86_Assembly/Protected_Mode">https://en.wikibooks.org/wiki/X86_Assembly/Protected_Mode</a>
</li>

<li>MSW: Machine Status Word<br />
<a href="https://web.itu.edu.tr/kesgin/mul06/intel/intel_msw.html">https://web.itu.edu.tr/kesgin/mul06/intel/intel_msw.html</a>
</li>

<li>80x87 Floating Point Opcodes<br />
<a href="http://www.techhelpmanual.com/876-80x87_floating_point_opcodes.html">http://www.techhelpmanual.com/876-80x87_floating_point_opcodes.html</a>
</li>

<li>Page Translation<br />
<a href="https://pdos.csail.mit.edu/6.828/2005/readings/i386/s05_02.htm">https://pdos.csail.mit.edu/6.828/2005/readings/i386/s05_02.htm</a>
</li>

<li>80386 Paging and Segmenation<br />
<a href="https://stackoverflow.com/questions/38229741/80386-paging-and-segmenation">https://stackoverflow.com/questions/38229741/80386-paging-and-segmenation</a>
</li>

<li>80386 Memory Management<br />
<a href="https://tldp.org/LDP/khg/HyperNews/get/memory/80386mm.html">https://tldp.org/LDP/khg/HyperNews/get/memory/80386mm.html</a>
</li>

<li>DOSEMU<br />
<a href="http://www.dosemu.org/">http://www.dosemu.org/</a>
</li>

<li>Intel 80386, a revolutionary CPU<br />
<a href="https://www.xtof.info/intel80386.html">https://www.xtof.info/intel80386.html</a>
</li>

<li>PAI Unit 3 Paging in 80386 Microporcessor<br />
<a href="https://www.slideshare.net/KanchanPatil34/pai-unit-3-paging-in-80386-microporcessor">https://www.slideshare.net/KanchanPatil34/pai-unit-3-paging-in-80386-microporcessor</a>
</li>

<li>64 Terabytes of virtual memory for 32-bit x86 using segmentation: how?<br />
<a href="https://stackoverflow.com/questions/5444984/64-terabytes-of-virtual-memory-for-32-bit-x86-using-segmentation-how">https://stackoverflow.com/questions/5444984/64-terabytes-of-virtual-memory-for-32-bit-x86-using-segmentation-how</a>
</li>

<li>Pi in the Pentium: reverse-engineering the constants in its floating-point unit<br />
<a href="http://www.righto.com/2025/01/pentium-floating-point-ROM.html">http://www.righto.com/2025/01/pentium-floating-point-ROM.html</a>
</li>

<li>Simply FPU<br />
<a href="http://www.website.masmforum.com/tutorials/fptute/">http://www.website.masmforum.com/tutorials/fptute/</a>
</li>

<li>Art of Assembly language programming: The 80x87 Floating Point Coprocessors<br />
<a href="https://courses.engr.illinois.edu/ece390/books/artofasm/CH14/CH14-3.html">https://courses.engr.illinois.edu/ece390/books/artofasm/CH14/CH14-3.html</a>
</li>

<li>Art of Assembly language programming: The FPU Instruction Set<br />
<a href="https://courses.engr.illinois.edu/ece390/books/artofasm/CH14/CH14-4.html">https://courses.engr.illinois.edu/ece390/books/artofasm/CH14/CH14-4.html</a>
</li>

<li>INTEL 80387 PROGRAMMER'S REFERENCE MANUAL<br />
<a href="http://www.ragestorm.net/downloads/387intel.txt">http://www.ragestorm.net/downloads/387intel.txt</a>
</li>

<li>x86 Instruction Set Reference: FLD<br />
<a href="http://x86.renejeschke.de/html/file_module_x86_id_100.html">http://x86.renejeschke.de/html/file_module_x86_id_100.html</a>
</li>

<li>x86 Instruction Set Reference: FLD1/FLDL2T/FLDL2E/FLDPI/FLDLG2/FLDLN2/FLDZ<br />
<a href="http://x86.renejeschke.de/html/file_module_x86_id_101.html">http://x86.renejeschke.de/html/file_module_x86_id_101.html</a>
</li>

<li>X86 Assembly/Arithmetic<br />
<a href="https://en.wikibooks.org/wiki/X86_Assembly/Arithmetic">https://en.wikibooks.org/wiki/X86_Assembly/Arithmetic</a>
</li>

<li>8087 Numeric Data Processor<br />
<a href="https://www.eeeguide.com/8087-numeric-data-processor/">https://www.eeeguide.com/8087-numeric-data-processor/</a>
</li>

<li>Data Types and Instruction Set of 8087 co-processor<br />
<a href="https://www.eeeguide.com/data-types-and-instruction-set-of-8087-co-processor/">https://www.eeeguide.com/data-types-and-instruction-set-of-8087-co-processor/</a>
</li>

<li>8087 instruction set and examples<br />
<a href="https://studylib.net/doc/5625221/8087-instruction-set-and-examples">https://studylib.net/doc/5625221/8087-instruction-set-and-examples</a>
</li>

<li>GCC documentation: Extensions to the C Language Family<br />
<a href="https://gcc.gnu.org/onlinedocs/gcc/C-Extensions.html#C-Extensions">https://gcc.gnu.org/onlinedocs/gcc/C-Extensions.html#C-Extensions</a>
</li>

<li>GCC documentation: Using Vector Instructions through Built-in Functions<br />
<a href="https://gcc.gnu.org/onlinedocs/gcc/Vector-Extensions.html">https://gcc.gnu.org/onlinedocs/gcc/Vector-Extensions.html</a>
</li>

<li>SSE (Streaming SIMD Extentions)<br />
<a href="http://www.songho.ca/misc/sse/sse.html">http://www.songho.ca/misc/sse/sse.html</a>
</li>

<li>Timothy A. Chagnon: SSE and SSE2<br />
<a href="http://www.cs.drexel.edu/~tc365/mpi-wht/sse.pdf">http://www.cs.drexel.edu/~tc365/mpi-wht/sse.pdf</a>
</li>

<li>Intel corporation: Extending the Worldr's Most Popular Processor Architecture<br />
<a href="http://download.intel.com/technology/architecture/new-instructions-paper.pdf">http://download.intel.com/technology/architecture/new-instructions-paper.pdf</a>
</li>

<li>SIMD architectures:<br />
<a href="http://arstechnica.com/old/content/2000/03/simd.ars/">http://arstechnica.com/old/content/2000/03/simd.ars/</a>
</li>

<li>Tour of the Black Holes of Computing!: Floating Point<br />
<a href="http://www.cs.hmc.edu/~geoff/classes/hmc.cs105.../slides/class02_floats.ppt">http://www.cs.hmc.edu/~geoff/classes/hmc.cs105.../slides/class02_floats.ppt</a>
</li>

<li>3Dnow! Technology Manual<br />
AMD Inc., 2000</li>

<li>Intel MMX<sup>TM</sup> Technology Overview<br />
Intel corporation, 1996</li>

<li>MultiMedia eXtensions<br />
<a href="http://softpixel.com/~cwright/programming/simd/mmx.php">http://softpixel.com/~cwright/programming/simd/mmx.php</a>i
</li>

<li>AMD K5 ("K5" / "5k86")<br />
<a href="http://www.pcguide.com/ref/cpu/fam/g5K5-c.html">http://www.pcguide.com/ref/cpu/fam/g5K5-c.html</a>
</li>

<li>Sixth Generation Processors<br />
<a href="http://www.pcguide.com/ref/cpu/fam/g6.htm">http://www.pcguide.com/ref/cpu/fam/g6.htm</a>
</li>

<li>Great Microprocessors of the Past and Present<br />
<a href="http://www.cpushack.com/CPU/cpu1.html">http://www.cpushack.com/CPU/cpu1.html</a>
</li>

<li>Very long instruction word (Wikipedia)<br />
<a href="http://en.wikipedia.org/wiki/Very_long_instruction_word">http://en.wikipedia.org/wiki/Very_long_instruction_word</a>
</li>

<li>CPU design (Wikipedia)<br />
<a href="http://en.wikipedia.org/wiki/CPU_design">http://en.wikipedia.org/wiki/CPU_design</a>
</li>

<li>Grafické karty a grafické akcelerátory (14)<br />
<a href="https://www.root.cz/clanky/graficke-karty-a-graficke-akceleratory-14/">https://www.root.cz/clanky/graficke-karty-a-graficke-akceleratory-14/</a>
</li>

<li>Grafické karty a grafické akcelerátory (15)<br />
<a href="https://www.root.cz/clanky/graficke-karty-a-graficke-akceleratory-15/">https://www.root.cz/clanky/graficke-karty-a-graficke-akceleratory-15/</a>
</li>

<li>Grafické karty a grafické akcelerátory (16)<br />
<a href="https://www.root.cz/clanky/graficke-karty-a-graficke-akceleratory-16/">https://www.root.cz/clanky/graficke-karty-a-graficke-akceleratory-16/</a>
</li>

<li>VESA Video Modes<br />
<a href="https://wiki.osdev.org/VESA_Video_Modes">https://wiki.osdev.org/VESA_Video_Modes</a>
</li>

<li>Introduction to VESA programming<br />
<a href="http://www.monstersoft.com/tutorial1/VESA_intro.html">http://www.monstersoft.com/tutorial1/VESA_intro.html</a>
</li>

<li>Guide: VBE 2.0 graphics modes<br />
<a href="https://delorie.com/djgpp/doc/ug/graphics/vbe20.html">https://delorie.com/djgpp/doc/ug/graphics/vbe20.html</a>
</li>

<li>NASM instruction list<br />
<a href="https://userpages.cs.umbc.edu/chang/cs313/nasmdoc/html/nasmdocb.html">https://userpages.cs.umbc.edu/chang/cs313/nasmdoc/html/nasmdocb.html</a>
</li>

<li>BitBlt function (wingdi.h)<br />
<a href="https://learn.microsoft.com/en-us/windows/win32/api/wingdi/nf-wingdi-bitblt">https://learn.microsoft.com/en-us/windows/win32/api/wingdi/nf-wingdi-bitblt</a>
</li>

<li>SetDIBitsToDevice function (wingdi.h)<br />
<a href="https://learn.microsoft.com/en-us/windows/win32/api/wingdi/nf-wingdi-setdibitstodevice">https://learn.microsoft.com/en-us/windows/win32/api/wingdi/nf-wingdi-setdibitstodevice</a>
</li>

<li>Why did line printers have 132 columns?<br />
<a href="https://retrocomputing.stackexchange.com/questions/7838/why-did-line-printers-have-132-columns">https://retrocomputing.stackexchange.com/questions/7838/why-did-line-printers-have-132-columns</a>
</li>

<li>Tabulating machine<br />
<a href="https://en.wikipedia.org/wiki/Tabulating_machine">https://en.wikipedia.org/wiki/Tabulating_machine</a>
</li>

<li>Why do printers print 132 columns on 14 7/8″ paper? It’s history<br />
<a href="https://blog.adafruit.com/2019/01/22/why-do-printers-print-132-columns-on-14-7-8-paper-its-history-vintagecomputing-kenshirriff-ibm/">https://blog.adafruit.com/2019/01/22/why-do-printers-print-132-columns-on-14-7-8-paper-its-history-vintagecomputing-kenshirriff-ibm/</a>
</li>

<li>IBM 1403 (Wikipedia)<br />
<a href="https://en.wikipedia.org/wiki/IBM_1403">https://en.wikipedia.org/wiki/IBM_1403</a>
</li>

</ol>



<p></p><p></p>
<p><small>Autor: <a href="https://github.com/tisnik/">Pavel Tišnovský</a> &nbsp; 2025</small></p>
</body>
</html>

