<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
        "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html>
<head>
<title>Výpočty v systému pevné řádové čárky na platformě IBM PC</title>
<meta name="Author" content="Pavel Tisnovsky" />
<meta name="Generator" content="vim" />
<meta http-equiv="content-type" content="text/html; charset=utf-8" />
<style type="text/css">
         body {color:#000000; background:#ffffff;}
         h1  {font-family: arial, helvetica, sans-serif; color:#ffffff; background-color:#c00000; text-align:center; padding-left:1em}
         h2  {font-family: arial, helvetica, sans-serif; color:#ffffff; background-color:#0000c0; padding-left:1em; text-align:left}
         h3  {font-family: arial, helvetica, sans-serif; color:#000000; background-color:#c0c0c0; padding-left:1em; text-align:left}
         h4  {font-family: arial, helvetica, sans-serif; color:#000000; background-color:#e0e0e0; padding-left:1em; text-align:left}
         a   {font-family: arial, helvetica, sans-serif;}
         li  {font-family: arial, helvetica, sans-serif; color:#000000; text-align:justify; width:450px;}
         ol  {font-family: arial, helvetica, sans-serif; color:#000000; text-align:justify; width:450px;}
         ul  {font-family: arial, helvetica, sans-serif; color:#000000; text-align:justify; width:450px;}
         p   {font-family: arial, helvetica, sans-serif; color:#000000; text-align:justify;}
         pre {background:#e0e0e0}
</style>
</head>

<body>

<h1>Výpočty v systému pevné řádové čárky na platformě IBM PC</h1>

<h3>Pavel Tišnovský</h3>

<p></p>

<h1>Úvodník</h1>

<p>Počítače IBM PC sice mohly být vybaveny matematickým koprocesorem, ovšem v prvním desetiletí existence této platformy se v žádném případě nejednalo o standardní modul; mnohá PC jím vybavena nebyla. Proto vývojáři hledali jiné způsoby realizace výpočtů s reálnými hodnotami.</p>



<h2>Obsah</h2>

<p><a href="#k01">1. Výpočty v&nbsp;systému pevné řádové čárky na platformě IBM PC</a></p>
<p><a href="#k02">2. Jakými způsoby je možné reprezentovat numerické hodnoty v&nbsp;operační paměti počítače?</a></p>
<p><a href="#k03">3. Uložení čísel ve formátu pevné řádové binární tečky</a></p>
<p><a href="#k04">4. Přednosti a zápory formátu pevné řádové tečky</a></p>
<p><a href="#k05">5. Dvojkový doplněk a čísla s&nbsp;pevnou řádovou binární čárkou</a></p>
<p><a href="#k06">6. Základní vlastnosti čísel reprezentovaných v&nbsp;systému pevné řádové čárky</a></p>
<p><a href="#k07">7. Praktická část</a></p>
<p><a href="#k08">8. Realizace operace součtu v&nbsp;systému pevné řádové čárky</a></p>
<p><a href="#k09">9. Součet realizovaný formou makra</a></p>
<p><a href="#k10">10. Realizace operace součinu: naivní varianta</a></p>
<p><a href="#k11">11. Korektní implementace součinu</a></p>
<p><a href="#k12">12. Úprava operandů před provedením součinu</a></p>
<p><a href="#k13">13. Úprava operandů po provedení součinu</a></p>
<p><a href="#k14">14. Krátká odbočka: jakým způsobem se přeloží FX operace při použití jazyka C</a></p>
<p><a href="#k15">15. Výpočet Mandelbrotovy množiny ve formátu s&nbsp;pevnou řádovou tečkou</a></p>
<p><a href="#k16">16. Základní způsob realizace výpočtů</a></p>
<p><a href="#k17">17. Neoptimalizovaná verze výpočtu Mandelbrotovy množiny</a></p>
<p><a href="#k18">18. Částečně optimalizovaná verze výpočtu Mandelbrotovy množiny</a></p>
<p><a href="#k19">19. Repositář s&nbsp;demonstračními příklady</a></p>
<p><a href="#k20">20. Odkazy na Internetu</a></p>



<p><a name="k01"></a></p>
<h2 id="k01">1. Výpočty v&nbsp;systému pevné řádové čárky na platformě IBM PC</h2>

<p><a
href="https://www.root.cz/serialy/vyvoj-her-a-grafickych-dem-pro-platformu-pc/">V&nbsp;seriálu
o tvorbě her a dem pro úspěšnou i nenáviděnou platformu IBM PC</a> jsme si
popsali základní aritmetické instrukce mikroprocesorů řady Intel 80x86. Taktéž
jsme si podrobně popsali matematický koprocesor Intel 8087 i jeho následovníky
(zejména čipy 80287, 80387). Pokud mělo PC některý z&nbsp;těchto koprocesorů
nainstalován, mohlo poměrně rychle provádět operace s&nbsp;hodnotami uloženými
v&nbsp;systému plovoucí řádové čárky (<i>FP &ndash; Floating Point</i>). Ovšem
zdaleka ne všechna PC byla tímto relativně drahým čipem vybavena. Pokud
matematický koprocesor nebyl nainstalován, bylo nutné všechny FP operace
emulovat, což bylo poměrně pomalé (o řád až dva řády v&nbsp;porovnání
s&nbsp;reálným koprocesorem).</p>

<p>I z&nbsp;tohoto důvodu se například v&nbsp;mnoha hrách vůbec FP operace
neprováděly a využívala se zde odlišná technika. Ta byla založena na uložení
vybrané podmnožiny numerických hodnot v&nbsp;systému <i>pevné řádové (binární)
tečky</i>. V&nbsp;tomto článku se budeme záměrně dopouštět drobného prohřešku
oproti stávající normě českého jazyka, protože budeme neustále psát o řádové,
desetinné a binární <i>tečce</i> a nikoli o <i>čárce</i> &ndash;
z&nbsp;hlediska anglické terminologie to bude více konzistentní, i když
z&nbsp;češtinského hlediska by bylo zcela jistě korektnější psát o řádové
<i>čárce</i>, protože se v&nbsp;češtině celá část čísla od části desetinné
odděluje právě čárkou a nikoli tečkou, jak je tomu zvykem v&nbsp;anglosaských
zemích (programátoři, kterým je tento článek určen především, však tuto
skutečnost zcela jistě znají &ndash; ostatně IT je plná podobných podivností a
nepřesností &ndash; &bdquo;kilobajt&ldquo; apod.).</p>

<p>V&nbsp;anglické literatuře se zmíněná forma reprezentace číselných hodnot
označuje zkratkou <i>FX</i> nebo <i>FXP</i> (<i><i>f</i>i<i>x</i>ed
<i>p</i>oint</i>), zatímco dnes častěji používaná reprezentace v&nbsp;systému
plovoucí řádové tečky se všeobecně označuje zkratkou <i>FP</i> (<i>floating
point</i>). V&nbsp;jednom článku jsem dokonce místo zkratky <i>FX</i> viděl i
zkratku <i>XP</i> (<i>fi<u>x</u>ed <u>p</u>oint</i>), ale to bylo před mnoha
lety, v&nbsp;době Windows 95, tedy dávno před Windows XP :-).</p>

<p>Dnes si nejprve vysvětlíme princip obou metod použitých pro ukládání
podmnožiny racionálních čísel a posléze si také řekneme, jaké výhody a nevýhody
jednotlivé principy přináší v&nbsp;každodenní programátorské praxi a ve kterých
situacích je vhodnější použít pevnou řádovou čárku. V&nbsp;dalším textu budeme
formát pevné binární řádové tečky zkracovat na <i>FX formát</i> a formát
používající plovoucí řádovou tečku budeme zapisovat jako <i>FP formát</i>.</p>



<p><a name="k02"></a></p>
<h2 id="k02">2. Jakými způsoby je možné reprezentovat numerické hodnoty v&nbsp;operační paměti počítače?</h2>

<p>Při ukládání numerických hodnot do operační paměti počítače poměrně záhy
narazíme na některé problémy, z&nbsp;nichž některé souvisí s&nbsp;konečným
počtem bitů, které pro uložení dané hodnoty &bdquo;obětujeme&ldquo; a další
vycházejí z&nbsp;vlastního způsobu zpracování hodnot mikroprocesorem či
matematickým koprocesorem. V&nbsp;konečném počtu bitů je totiž pochopitelně
možné uložit pouze <i>konečné</i> množství různých hodnot a je plně
v&nbsp;rukou programátora, jak efektivně daný počet bitů využije či naopak
promrhá ukládáním nepodstatných informací. Poměrně často se totiž stává, že i
program využívající dvojitou či dokonce rozšířenou přesnost čísel při <i>FP</i>
operacích (tj.&nbsp;když používá datové typy <i>double</i> a
<i>extended/temporary</i>) dává nesprávné výsledky dané nepochopením principu
práce <i>FP</i> aritmetiky a přitom je v&nbsp;některých případech možné se
přesnějších výsledků dobrat i při použití pouhých 32 bitů, ale s&nbsp;pečlivě
vyváženými aritmetickými a bitovými operacemi.</p>

<p>Na druhou stranu nejsou dnes používané mikroprocesory tak univerzálními
zařízeními, jak by se na první pohled možná mohlo zdát. Mikroprocesory jsou
totiž (většinou) navrženy tak, aby účinně, například v&nbsp;rámci jedné operace
či instrukce, zpracovávaly pouze konstantní počet bitů zvolený výrobcem
mikroprocesoru. Příkladem mohou být dnes velmi rozšířené procesory řady x86
(x86-64), které jsou velmi dobré při práci s&nbsp;32 bitovými hodnotami nebo
hodnotami 64bitovými, ale při požadavku na aritmetické výpočty probíhající na
(řekněme) 21 bitech se veškerá jejich efektivita ztrácí a procesor se širokými
vnitřními sběrnicemi, matematickým koprocesorem atd.&nbsp;se potýká
s&nbsp;prohazováním jednotlivých bitů (a naopak &ndash; mnohé DSP pracují
s&nbsp;dvaceti nebo 24 bity a nikoli s&nbsp;32/64 bity).</p>

<p>Mnohem lepší situace nastane v&nbsp;případě, že se nějaká operace
implementuje na programovatelném poli FPGA &ndash; zde je možné vytvořit obvody
provádějící matematické a logické operace s&nbsp;libovolným počtem bitů, čímž
se oproti univerzálním řešením (např.&nbsp;konstantní bitová šířka sběrnice
a/nebo registrů) ušetří mnoho plochy těchto velmi zajímavých obvodů (FPGA mohou
mimochodem znamenat i velkou šanci pro hnutí open source &ndash; pomocí nich by
mohlo vznikat, a někde už vzniká <i>open hardware</i>, které by mohlo odstranit
závislost na &bdquo;uzavřených&ldquo; síťových a grafických kartách apod.).</p>

<p>Vraťme se však ke způsobům reprezentace číselných hodnot v&nbsp;operační
paměti počítače. Nejprve předpokládejme, že pro reprezentaci vlastností
určitého objektu či stavu z&nbsp;reálného světa použijeme <i>N</i> binárních
číslic (bitů), tj.&nbsp;základních jednotek informace, která může nabývat pouze
jedné ze dvou povolených hodnot (ty se značí například symboly <i>yes/no</i>
nebo <i>true</i>/<i>false</i>, ale my se budeme spíše držet označení <i>0</i> a
<i>1</i>). Pomocí této uspořádané <i>N</i>-tice je možné popsat celkem:</p>

<p><i>2<sub>0</sub>&times;2<sub>1</sub>&times;2<sub>2</sub> ... 2<sub>N-1</sub>=2<sup>N</sup></i></p>

<p>jednoznačných, tj.&nbsp;navzájem odlišných, stavů. Množina těchto stavů může
reprezentovat prakticky jakýkoliv abstraktní či reálný objekt. Přitom si musíme
uvědomit, že u této množiny není <i>nikde</i> implicitně řečeno ani myšleno, že
se jedná například o celá kladná čísla, to je pouze jedna z&nbsp;mnoha možných
interpretací zvolené <i>N</i>-tice (my programátoři máme tendenci považovat
celá kladná čísla za přirozenou interpretaci bitové <i>N</i>-tice, to však
vychází pouze z&nbsp;našeho pohledu na svět a z&nbsp;našich zkušeností).
Reprezentaci momentálního stavu abstraktního či reálného objektu si můžeme
představit jako zobrazení z&nbsp;množiny binárních stavů na elementy vzorové (a
obecně neuspořádané) množiny. Nejčastěji používanými zobrazeními jsou zobrazení
množiny binárních stavů na interval celých kladných čísel (<i>Unsigned
Integers</i>), popřípadě na interval celých čísel (<i>Signed Integers</i>).</p>



<p><a name="k03"></a></p>
<h2 id="k03">3. Uložení čísel ve formátu pevné řádové binární tečky</h2>

<p>Numerické hodnoty zapsané ve&nbsp;formátu <i>pevné řádové binární tečky</i>
se chápou jako podmnožina racionálních čísel, což jsou taková čísla, jejichž
hodnoty je možné vyjádřit vztahem:</p>

<p><i>x<sub>FX</sub>=a/b &nbsp;&nbsp; a,b leží v Z, b &ne; 0</i></p>

<p>Číselné hodnoty z&nbsp;uvažované podmnožiny jsou navíc omezeny další
podmínkou:</p>

<p><i>b=2<sup>k</sup> &nbsp;&nbsp; b leží v Z, k leží v Z<sup>+</sup></i></p>

<p>Protože <i>b</i> je celočíselnou mocninou dvojky (a ne desítky či jiného
základu), určuje jeho hodnota <i>n</i> polohu <i>binární tečky</i>
v&nbsp;uloženém čísle. Další podmínkou, která má však spíše implementační
charakter, je zachování stejného počtu binárních cifer v&nbsp;každém
reprezentovaném čísle, což mimo jiné znamená, že všechna čísla mají řádovou
binární tečku umístěnou na stejném místě &ndash; z&nbsp;této podmínky ostatně
plyne i název popisovaného způsobu reprezentace vybrané podmnožiny racionálních
čísel (to je zásadní rozdíl oproti <i>FP</i> formátům). Tak jako i
v&nbsp;jiných reprezentacích čísel, jsou nulové číslice před první nenulovou
cifrou a za poslední nenulovou cifrou nevýznamné, proto je není zapotřebí
uvádět (naše příklady jsou ovšem napsány poměrně primitivně a budou vypisovat
všechny uložené cifry).</p>

<p>Prakticky může být číselná hodnota v&nbsp;systému pevné řádové tečky uložena
na osmi bitech například následujícím způsobem (uvažujeme pouze kladné
hodnoty):</p>

<table>
<tr><td>Pozice bitu        </td><td>8&nbsp;&nbsp;&nbsp;&nbsp;</td><td>7&nbsp;&nbsp;&nbsp;&nbsp;</td><td>6&nbsp;&nbsp;&nbsp;&nbsp;</td><td>5&nbsp;&nbsp;&nbsp;&nbsp;</td><td>4&nbsp;&nbsp;&nbsp;&nbsp;</td><td>3&nbsp;&nbsp;&nbsp;&nbsp;</td><td>2&nbsp;&nbsp;&nbsp;&nbsp;</td><td>1&nbsp;&nbsp;&nbsp;&nbsp;</td></tr>
<tr><td>Váha bitu          </td><td>2<sup>4</sup></td><td>2<sup>3</sup></td><td>2<sup>2</sup></td><td>2<sup>1</sup></td><td>2<sup>0</sup></td><td>2<sup>-1</sup></td><td>2<sup>-2</sup></td><td>2<sup>-3</sup></td></tr>
<tr><td>Desítková váha bitu</td><td>16</td><td>8</td><td>4</td><td>2</td><td>1</td><td>0,5</td><td>0,25</td><td>0,125</td></tr>
</table>



<p><a name="k04"></a></p>
<h2 id="k04">4. Přednosti a zápory formátu pevné řádové tečky</h2>

<p>Ve výše uvedeném příkladu je <i>pevná</i> binární řádová tečka umístěna vždy
<i>napevno</i> mezi třetím a čtvrtým bitem. A vzhledem k&nbsp;tomu, že je tato
skutečnost dopředu známá algoritmům, které provádí zpracování čísel (součet,
rozdíl, součin, výpočet druhé odmocniny, výpočet goniometrické funkce atd.),
není zapotřebí spolu s&nbsp;číslem uchovávat i pozici binární tečky, což
výrazně snižuje počet bitů, které je zapotřebí rezervovat pro čísla ze zadaného
rozsahu. To je tedy první přednost systému pevné řádové tečky &ndash; pokud
programátor dokáže dopředu určit rozsah všech zpracovávaných hodnot a
požadovanou přesnost, může být výhodné tento systém použít. Programátor také
díky explicitním určení polohy řádové tečky může určit, ve kterém místě
programu se musí přesnost či rozsah zvýšit a kdy naopak snížit. Lépe se tak
využije počet bitů, které můžeme pro uložení jednoho čísla obětovat (typicky je
tento počet bitů roven délce slova mikroprocesoru, popř.&nbsp;jeho
celočíselnému násobku či naopak podílu).</p>

<p>Jak se dozvíme v&nbsp;následujících kapitolách, je možné základní
matematické operace (sčítání, odčítání, násobení a dělení) poměrně jednoduše
implementovat i při použití formátu pevné řádové tečky. V&nbsp;případě, že není
k&nbsp;dispozici specializovaný (a současně velmi komplikovaný) matematický
koprocesor, je mnohdy mnohem jednodušší a rychlejší implementovat matematické
operace v&nbsp;FX formátu. To je případ mnoha jednočipových mikroprocesorů
(mikrořadičů), signálových procesorů, ale i specializovaných zařízení
obsahujících programovatelné obvody CPLD či FPGA. A byl to i případ platformy
IBM PC až do (přibližně) roku 1995 (u nás ještě později). Dnes sice mají
komplikovanější (a dražší) FPGA implementovanou i jednotku FPU, ale mnohdy je
výhodnější použít FPGA bez této jednotky a potřebné operace si do tohoto obvodu
&bdquo;vypálit&ldquo; po svém.</p>

<p>Třetí výhodou je fakt, že u FX formátu může programátor navrhnout a posléze
také dodržet požadovanou přesnost všech prováděných výpočtů. To je velký rozdíl
oproti FP formátu (resp.&nbsp;jeho podmnožinám, které se nejčastěji používají).
Jak jsme si již řekli v&nbsp;úvodních kapitolách, není vzácností narazit na
aplikace, které používají datové typy <i>float</i> či <i>double</i> a přitom
jsou výpočty prováděné v&nbsp;těchto programech zatíženy velkou chybou, protože
si programátoři plně neuvědomují některé zásadní limity FP formátu. Kritické
jsou například výpočty s&nbsp;peněžními hodnotami, ale i pouhé sčítání čísel,
jež se od sebe o mnoho řádů liší, vede k&nbsp;velkým chybám, které dokonce
mohou zapříčinit vznik nekonečných smyček, populární dělení nulou atd.</p>

<p>FX formát má však i některé nevýhody. První nevýhoda spočívá v&nbsp;tom, že
tento formát není příliš podporován, a to ani po programové stránce (podpora
v&nbsp;programovacích jazycích), ani výrobci mikroprocesorů pro počítače PC.
Situace je však odlišná v&nbsp;oblasti jednočipových mikropočítačů, signálových
procesorů (DSP), řídicích systémů, nebo například u IBM RS 6000, který kromě
jednotky FPU obsahuje i FXU &ndash; jednotku pro provádění výpočtů v&nbsp;pevné
řádové binární čárce. Na platformě x86 je možné pro FX formát použít instrukce
<strong>MMX</strong> resp.&nbsp;v&nbsp;moderních PC spíše <strong>SSEx</strong>
a <strong>AVX</strong>.</p>

<p>Dále může být použití FX formátu nevýhodné v&nbsp;případě, že se mají
zpracovávat numerické hodnoty, které mají velkou <i>dynamiku</i>,
tj.&nbsp;poměr mezi nejvyšší a nejnižší absolutní hodnotou. V&nbsp;takovém
případě by se mohlo stát, že by se při použití FX formátu muselo pro každé
číslo alokovat velké množství bitů, které by mohlo dokonce překročit počet bitů
nutných pro FP formát. Také v&nbsp;případě, kdy dopředu nevíme, jaké hodnoty se
budou zpracovávat, může být výhodnější použití FP formátu. Zde se však nabízí
otázka, ve kterých případech nevíme, jaké hodnoty můžeme na vstupu získat:
většinou je již z&nbsp;podstaty úlohy dopředu známé, s&nbsp;čím je možné
počítat a které hodnoty jsou naprosto nesmyslné.</p>

<p>Je však pravdou, že takovou analýzu málokdo dělá a když při výpočtech ve
<i>floatech</i> dochází k&nbsp;chybám, tak se bez přemýšlení program přepíše na
<i>doubly</i> a problém se tak buď odstraní, nebo alespoň odsune na pozdější
dobu, například do chvíle, kdy jsou programu předložena reálná data a ne
&bdquo;pouze&ldquo; data testovací.</p>



<p><a name="k05"></a></p>
<h2 id="k05">5. Dvojkový doplněk a čísla s&nbsp;pevnou řádovou binární čárkou</h2>

<p>V&nbsp;praxi je pochopitelně mnohdy (ale zdaleka ne vždy!) nutné pracovat i
se zápornými hodnotami. Zde se typicky využívá takzvaný <i>dvojkový
doplněk</i>. Dvojkový doplněk hodnoty <i>x</i> (označovaný zde kvůli
nedostatkům HTML symbolem <i>#x</i>) lze získat z&nbsp;jejího jedničkového
doplňku <i>~x</i> (tedy prosté negace všech bitů) velmi jednoduše tak, že se
k&nbsp;tomuto doplňku přičte jednotka, tj.:</p>

<p><i>#x=~x+1=2<sup>N</sup>-x</i></p>

<p>Operaci jedničkového i dvojkového doplňku je možné provádět kromě
celočíselných reprezentací i u&nbsp;reprezentace v&nbsp;pevné řádové binární
čárce. Pokud je <i>N</i>-bitové slovo interpretováno ve&nbsp;vyjádření
v&nbsp;pevné řádové čárce, může nabývat hodnot ležících v&nbsp;podmnožině
<i>P<sub>2</sub></i> racionálních čísel:</p>

<p><i>P<sub>2</sub>=p/2<sup>b</sup> | -2<sup>N-1</sup> &le; p &le; 2<sup>N-1</sup>-1</i></p>

<p>Podmnožina <i>P<sub>2</sub></i> obsahuje stále <i>2<sup>N</sup></i> prvků,
stejně jako podmnožina <i>P<sub>1</sub></i> definovaná v&nbsp;předchozích
kapitolách. Novou reprezentaci čísel budu v&nbsp;dalším textu označovat
symbolem <i>A(a,b)</i>, kde platí <i>a=N-b-1</i>.</p>

<p>Hodnota <i>N</i>-bitového čísla <i>x</i> je v&nbsp;reprezentaci
<i>A(a,b)</i> vyjádřena výrazem:</p>

<p><i>x=1/2<sup>b</sup>(-2<sup>N-1</sup>x<sub>N-1</sub>+&sum;<sub>0</sub><sup>N-2</sup>2<sup>n</sup>x<sub>n</sub>)</i></p>

<p>kde symbol <i>x<sub>n</sub></i> značí hodnotu <i>n</i>-tého bitu čísla
<i>x</i>. Rozsah čísel reprezentovaných v&nbsp;<i>A(a,b)</i> je možné vyjádřit
nerovností:</p>

<p><i>-2<sup>N-1-b</sup> &le; x &le; 2<sup>N-1-b</sup>-1/2<sup>b</sup></i></p>

<p>Za zmínku stojí také skutečnost, že počet významových bitů je
v&nbsp;reprezentaci <i>A(a,b)</i> vždy o&nbsp;jednotku nižší, než
u&nbsp;reprezentace <i>U(a,b)</i>. Pro reprezentaci absolutní hodnoty čísla je
použito pouze nižších <i>N-1</i> bitů, nejvyšší bit je díky své funkci
označován jako <strong>znaménkový bit</strong> (<i>sign bit</i>), což je
ostatně patrné z&nbsp;podvýrazu <i>-2<sup>N-1</sup>x<sub>N-1</sub></i>.</p>



<p><a name="k06"></a></p>
<h2 id="k06">6. Základní vlastnosti čísel reprezentovaných v&nbsp;systému pevné řádové čárky</h2>

<p>V&nbsp;následujících odstavcích jsou vypsány základní vlastnosti numerických
hodnot, které jsou reprezentovány v&nbsp;systému s&nbsp;pevnou řádovou binární
čárkou. Pravidla jsou uvedena jak pro formát <i>U(a,b)</i> (tj.&nbsp;pouze pro
podmnožinu z&nbsp;kladných racionálních čísel), tak i pro formát <i>A(a,b)</i>,
tj.&nbsp;pro podmnožinu z&nbsp;kladných i záporných racionálních čísel. Každé
vlastnosti je věnována samostatná podkapitola.</p>



<p><a name="k061"></a></p>
<h2>6.1 Počet bitů</h2>

<p>Počet bitů nutných pro uložení číselné hodnoty v&nbsp;reprezentaci
<i>U(a,b)</i> je jednoduše roven výsledku výrazu <i>a+b</i>, což mimo jiné
značí, že&nbsp;všechny bity daného bitového vektoru jsou beze zbytku použity
pro uložení číselné hodnoty (nejsou rezervovány žádné speciální bity).
V&nbsp;reprezentaci <i>A(a,b)</i> je počet bitů roven hodnotě <i>a+b+1</i>,
protože jeden bit navíc je nutné rezervovat pro uložení znaménka ukládané
číselné hodnoty &ndash; viz výše zmíněný znaménkový bit.</p>



<p><a name="k062"></a></p>
<h2>6.2 Rozsah hodnot</h2>

<p>Rozsah hodnot v&nbsp;reprezentaci čísel ve&nbsp;formátu <i>U(a,b)</i> lze
vyjádřit vztahem <i>0&le; x<sub>1</sub> &le; 2<sup>a</sup>-2<sup>-b</sup></i>,
pro reprezentaci <i>A(a,b)</i> je rozsah hodnot vyjádřen nerovností:
<i>-2<sup>a</sup>&le; x<sub>2</sub> &le; 2<sup>a</sup>-2<sup>-b</sup></i>, což
značí, že&nbsp;ve druhém uvedeném typu reprezentace je možné zaznamenat
dvojnásobné množství navzájem odlišných hodnot &ndash; tato skutečnost je
ostatně dána i větším počtem bitů pro reprezentaci <i>A(a,b)</i> oproti
reprezentaci <i>U(a,b)</i> při stejných hodnotách parametrů <i>a</i> i
<i>b</i>.</p>



<p><a name="k063"></a></p>
<h2>6.3 Platnost aritmetické operace součtu či rozdílu</h2>

<p>Platnost aritmetické operace součtu či rozdílu hodnot uložených ve formátu
<i>U(a,b)</i> pro kladná čísla <i>U(a<sub>1</sub>,b<sub>1</sub>)<i> a
</i>U(a<sub>2</sub>,b<sub>2</sub>)</i> lze zaručit pouze tehdy, jestliže je
<i>a<sub>1</sub></i> rovno <i>a<sub>2</sub></i> a současně <i>b<sub>1</sub></i>
rovno <i>b<sub>2</sub></i>, tj.&nbsp;obě hodnoty jsou uloženy ve&nbsp;slově
(bitovém vektoru) se stejným množstvím (počtem) bitů a poloha řádové binární
čárky je konstantní. Pro číselné hodnoty uložené ve&nbsp;druhém popisovaném
formátu <i>A(a<sub>1</sub>,b<sub>1</sub>)<i> a
</i>A(a<sub>2</sub>,b<sub>2</sub>)</i> platí stejné podmínky. Pokud není
alespoň jedna z&nbsp;podmínek splněna, je nutné před provedením aditivní
operace provést konverzi hodnot na shodný formát <i>U(a<sub>x</sub>,
b<sub>y</sub>)</i> resp. <i>A(a<sub>x</sub>, b<sub>y</sub>)</i>.</p>



<p><a name="k064"></a></p>
<h2>6.4 Rozsah výsledků po aritmetické operaci sčítání</h2>

<p>Rozsah výsledků po aritmetické operaci sčítání dvou číselných hodnot
ve&nbsp;formátu <i>U(a,b)</i> lze vyjádřit následujícím způsobem:</p>

<p><i>U(a,b)+U(a,b)=U(a+1,b)</i></p>

<p>tj.&nbsp;pro uložení výsledku je obecně zapotřebí vyhradit slovo širší právě
o&nbsp;jeden bit. Pro dvě hodnoty ve&nbsp;formátu <i>A(a,b)</i> platí stejný
vztah, jelikož se počet bitů obecně také zvyšuje o&nbsp;jednotku bez ohledu na
znaménko výsledku:</p>

<p><i>A(a,b)+A(a,b)=A(a+1,b)</i></p>



<p><a name="k065"></a></p>
<h2>6.5 Rozsah výsledků po provedené aritmetické operaci násobení</h2>

<p>Rozsah výsledků po provedené aritmetické operaci násobení dvou libovolných
číselných hodnot uložených ve&nbsp;formátu
<i>U(a<sub>1</sub>,b<sub>1</sub>)</i> a <i>U(a<sub>2</sub>,b<sub>2</sub>)</i>
je možné vyjádřit následujícím vztahem:</p>

<p><i>U(a<sub>1</sub>, b<sub>1</sub>) &times; U(a<sub>2</sub>, b<sub>2</sub>)=U(a<sub>1</sub>+a<sub>2</sub>, b<sub>1</sub>+b<sub>2</sub>)</i></p>

<p>Výše uvedeným vztahem je popsáno, že se při ukládání výsledků takto
provedené multiplikativní operace zvyšuje jak počet významových bitů před
binární řádovou čárkou, tak i stejnou měrou počet zlomkových bitů,
tj.&nbsp;bitů umístěných za binární čárkou. Při provádění multiplikativní
operace s&nbsp;číselnými hodnotami uloženými ve&nbsp;formátu
<i>A(a<sub>1</sub>,b<sub>1</sub>)<i> a </i>A(a<sub>2</sub>,b<sub>2</sub>)</i>
je situace při ukládání výsledků následující:</p>

<p><i>A(a<sub>1</sub>,b<sub>1</sub>) &times; A(a<sub>2</sub>, b<sub>2</sub>)=A(a<sub>1</sub>+a<sub>2</sub>+1, b<sub>1</sub>+b<sub>2</sub>)</i></p>

<p>Tento vztah je poněkud odlišný od vztahu předchozího, ale při bližším
rozboru je opět snadno pochopitelný. U&nbsp;číselných hodnot ve&nbsp;formátu
<i>A(a,b)</i> je totiž jeden (nejvyšší) bit rezervován pro vyjádření znaménka
uložené hodnoty. Po násobení je také nutné vyjádřit znaménko výsledku, ale
opětovně pouze na jednom bitu, nikoli na bitech dvou.</p>

<p><div class="rs-tip-major">Poznámka: toto je důležitý závěr, který ovlivní
způsob realizace operace součinu.</div></p>



<p><a name="k07"></a></p>
<h2 id="k07">7. Praktická část</h2>

<p>Praktická část dnešního článku je rozdělena na dvě poloviny. V&nbsp;první
polovině si na jednoduchých příkladech ukážeme způsob realizace základních FX
operací, konkrétně operace součtu a taktéž operace součinu. A posléze si
ukážeme relativně složitější příklady, ve kterých budeme vykreslovat
Mandelbrotovu množinu (autorův oblíbený matematický objekt), a to plně
s&nbsp;využitím pouze FX operací a s&nbsp;využitím standardního grafického
režimu karty VGA s&nbsp;rozlišením 320&times;200 pixelů a s&nbsp;256 barvami.
Tyto příklady tedy budou bez problémů spustitelné i na IBM PC bez matematického
koprocesoru.</p>



<p><a name="k08"></a></p>
<h2 id="k08">8. Realizace operace součtu v&nbsp;systému pevné řádové čárky</h2>

<p>Implementačně nejjednodušší je realizace operace součtu nebo rozdílu,
protože tuto operaci je možné provést instrukcemi typu <strong>ADD</strong>,
<strong>SUB</strong> atd., a to bez ohledu na pozici binární řádové tečky.
V&nbsp;případě, že budeme pracovat s&nbsp;hodnotami s&nbsp;celkovou šířkou 32
bitů, přičemž 16 bitů je rezervováno pro část před tečkou a 16 bitů pro část za
tečkou, je součet triviální &ndash; použijeme instrukci <strong>ADD</strong>
s&nbsp;32bitovými registry použitými ve formě operandů:</p>

<pre>
<i>;-----------------------------------------------------------------------------</i>
org  0x100        <i>; zacatek kodu pro programy typu COM (vzdy se zacina na 256)</i>
&nbsp;
<strong>start</strong>:
        jmp main                   <i>; skok na zacatek kodu</i>
&nbsp;
%include "io.asm"                  <i>; nacist symboly, makra a podprogramy</i>
%include "print.asm"               <i>; nacist symboly, makra a podprogramy</i>
&nbsp;
P       equ     65536              <i>; poloha desetinne tecky v FX-pointu</i>
&nbsp;
<strong>main</strong>:
        mov  eax, 1 * P            <i>; konstanta v FX-pointu: 1.0</i>
        print_hex eax
&nbsp;
        mov  eax, 1 * P            <i>; konstanta v FX-pointu: 1.0</i>
        mov  ebx, 2 * P            <i>; konstanta v FX-pointu: 2.0</i>
        add  eax, ebx              <i>; scitani v FX-pointu</i>
        print_hex eax
&nbsp;
        mov  eax, 1 * P / 2        <i>; konstanta v FX-pointu: 0.5</i>
        print_hex eax
&nbsp;
        mov  eax, 3 * P / 2        <i>; konstanta v FX-pointu: 1.5</i>
        print_hex eax
&nbsp;
        mov  eax, 1 * P / 2        <i>; konstanta v FX-pointu: 0.5</i>
        mov  ebx, 3 * P / 2        <i>; konstanta v FX-pointu: 1.5</i>
        add  eax, ebx              <i>; scitani v FX-pointu</i>
        print_hex eax
&nbsp;
<strong>finish</strong>:
        wait_key                   <i>; cekani na klavesu</i>
        exit                       <i>; navrat do DOSu</i>
&nbsp;
&nbsp;
<i>; datova cast</i>
section .data
&nbsp;
section .bss
</pre>

<p>Výsledky v&nbsp;surové podobě tak, jak je vypsal příklad:</p>

<pre>
00010000
00030000
00008000
00018000
00020000
</pre>

<p>Což lze interpretovat následovně:</p>

<pre>
0001.0000 ≅ 1.0
&nbsp;
0003.0000 ≅ 1.0 + 2.0 = 3.0
&nbsp;
0000.8000 ≅ 0.5
0001.8000 ≅ 1.5
0002.0000 ≅ 0.5 + 1.5 = 2.0
</pre>



<p><a name="k09"></a></p>
<h2 id="k09">9. Součet realizovaný formou makra</h2>

<p>Vzhledem k&nbsp;jednoduchosti realizace součtu ve formátu pevné řádové tečky
můžeme tuto operaci navrhnout i formou makra, což se v&nbsp;assembleru NASM
provádí následujícím způsobem:</p>

<pre>
%macro <strong>fx_add</strong> 2
        add %1, %2
%endmacro
</pre>

<p>Celý příklad se potom změní jen nepatrně (expanze makra je podtržena):</p>

<pre>
<i>;-----------------------------------------------------------------------------</i>
org  0x100        <i>; zacatek kodu pro programy typu COM (vzdy se zacina na 256)</i>
&nbsp;
%macro <strong>fx_add</strong> 2
        add %1, %2
%endmacro
&nbsp;
&nbsp;
<strong>start</strong>:
        jmp main                   <i>; skok na zacatek kodu</i>
&nbsp;
%include "io.asm"                  <i>; nacist symboly, makra a podprogramy</i>
%include "print.asm"               <i>; nacist symboly, makra a podprogramy</i>
&nbsp;
P       equ     65536              <i>; poloha desetinne tecky v FX-pointu</i>
&nbsp;
<strong>main</strong>:
        mov  eax, 1 * P            <i>; konstanta v FX-pointu: 1.0</i>
        print_hex eax
&nbsp;
        mov  eax, 1 * P            <i>; konstanta v FX-pointu: 1.0</i>
        mov  ebx, 2 * P            <i>; konstanta v FX-pointu: 2.0</i>
        <u>fx_add eax, ebx</u>            <i>; scitani v FX-pointu</i>
        print_hex eax
&nbsp;
        mov  eax, 1 * P / 2        <i>; konstanta v FX-pointu: 0.5</i>
        mov  ebx, 3 * P / 2        <i>; konstanta v FX-pointu: 1.5</i>
        <u>fx_add eax, ebx</u>            <i>; scitani v FX-pointu</i>
        print_hex eax
&nbsp;
<strong>finish</strong>:
        wait_key                   <i>; cekani na klavesu</i>
        exit                       <i>; navrat do DOSu</i>
&nbsp;
&nbsp;
<i>; datova cast</i>
section .data
&nbsp;
section .bss
</pre>

<p>Výsledky by nyní měly vypadat následovně:</p>

<pre>
00010000 ≅ 1.0
00030000 ≅ 3.0 = 1.0 + 2.0
00020000 ≅ 2.0 = 0.5 + 1.5
</pre>



<p><a name="k10"></a></p>
<h2 id="k10">10. Realizace operace součinu: naivní varianta</h2>

<p>Jak jsme mohli vidět v&nbsp;předchozí dvojici kapitol, byla realizace
operace součtu s&nbsp;FX hodnotami triviální. Ovšem jak tomu bude u operace
součinu? Zkusme si nejdříve i tuto operaci realizovat tím nejvíce naivním
způsobem, konkrétně zavoláním instrukce <strong>MUL</strong>:</p>

<pre>
<i>;-----------------------------------------------------------------------------</i>
org  0x100        <i>; zacatek kodu pro programy typu COM (vzdy se zacina na 256)</i>
&nbsp;
<strong>start</strong>:
        jmp main                   <i>; skok na zacatek kodu</i>
&nbsp;
%include "io.asm"                  <i>; nacist symboly, makra a podprogramy</i>
%include "print.asm"               <i>; nacist symboly, makra a podprogramy</i>
&nbsp;
P       equ     65536              <i>; poloha desetinne tecky v FX-pointu</i>
&nbsp;
<strong>main</strong>:
        mov  eax, 2 * P            <i>; konstanta v FX-pointu: 2.0</i>
        print_hex eax
&nbsp;
        mov  eax, 3 * P            <i>; konstanta v FX-pointu: 3.0</i>
        print_hex eax
&nbsp;
        mov  eax, 2 * P            <i>; konstanta v FX-pointu: 1.0</i>
        mov  ebx, 3 * P            <i>; konstanta v FX-pointu: 2.0</i>
        mul  ebx                   <i>; nasobeni v FX-pointu do EDX:EAX</i>
        print_hex eax
&nbsp;
        mov  eax, 1 * P / 2        <i>; konstanta v FX-pointu: 0.5</i>
        print_hex eax
&nbsp;
        mov  eax, 3 * P            <i>; konstanta v FX-pointu: 3.0</i>
        print_hex eax
&nbsp;
        mov  eax, 1 * P / 2        <i>; konstanta v FX-pointu: 0.5</i>
        mov  ebx, 3 * P            <i>; konstanta v FX-pointu: 3.0</i>
        mul  ebx                   <i>; nasobeni v FX-pointu do EDX:EAX</i>
        print_hex eax
&nbsp;
<strong>finish</strong>:
        wait_key                   <i>; cekani na klavesu</i>
        exit                       <i>; navrat do DOSu</i>
&nbsp;
&nbsp;
<i>; datova cast</i>
section .data
&nbsp;
section .bss
</pre>

<p>Výsledky nebudou příliš uspokojivé:</p>

<pre>
00020000 ≅ 2.0
00030000 ≅ 3.0
&nbsp;
00000000 ≅ 0.0 ≠ 2.0 * 3.0
&nbsp;
00008000 ≅ 0.5
00030000 ≅ 3.0
80000000 ≅ 32768.0 ≠ 1.5 = (0.5 * 3.0)
</pre>

<p>Vidíme, že tato realizace násobení je zcela evidentně nekorektní.</p>



<p><a name="k11"></a></p>
<h2 id="k11">11. Korektní implementace součinu</h2>

<p>Problémy s&nbsp;operací součinu (a vlastně i podílu, i když zde se bude
postupovat &bdquo;opačně&ldquo;), které jsme mohli vidět <a
href="#k10">v&nbsp;předchozí kapitole</a>, je možné vyřešit dvěma základními
způsoby:</p>

<ol>

<li>Úpravou operandů <i>před</i> provedením operace součinu s&nbsp;tím, že
výsledek bude korektní. Úpravou se zde myslí aritmetický nebo bitový posun
operandů doprava o vhodný počet bitů (8, 16 atd. podle pozice řádové
tečky).</li>

<li>Úpravou výsledku <i>po</i> provedení operace součinu, tj.&nbsp;výsledek
bude nutné vhodným způsobem opravit/upravit. Tato úprava opět spočívá
v&nbsp;aritmetickém nebo bitovém posunu doprava.</li>

</ol>

<p>Oba výše naznačené způsoby mají své klady i zápory. Při použití prvního
způsobu ztrácíme přesnost výpočtů (některé operandy totiž budou po úpravě
vynulovány, některé budou naopak nepřesné), ovšem bitová šířka výsledku bude
odpovídat bitové šířce operandů (což ovšem na platformě 8086 nemusíme docenit).
A naopak druhý způsob je obecně přesnější, ovšem je nutné pracovat
s&nbsp;mezivýsledkem, jehož bitová šířka je dvojnásobná oproti bitové šířce
operandů, tedy například 64 bitů pro 32 bitové operandy atd.</p>



<p><a name="k12"></a></p>
<h2 id="k12">12. Úprava operandů před provedením součinu</h2>

<p>Podívejme se nyní na konkrétní způsob úpravy operandů <i>před</i> provedením
operace součinu. Vstupem budou 32bitové operandy, takže pro jejich uložení
budou použity 32bitové registry <strong>EAX</strong> a <strong>EBX</strong>
(80386 a vyšší). Hodnotu každého z&nbsp;těchto operandů posuneme <i>doprava</i>
o osm bitů, čímž vlastně snížíme přesnost a i řádová tečka se posune o osm
pozic. Následně je možné provést běžný součin a výsledek bude korektní,
resp.&nbsp;přesněji řečeno dolní registr výsledku bude korektní (výsledek je
totiž obecně 64bitový). Operaci násobení ve formátu FX lze tedy realizovat
relativně snadným způsobem:</p>

<pre>
mov  eax, první_operand
mov  ebx, druhý operand
shr  eax, 8                <i>; posun jeste pred nasobenim (ztrata presnosti)</i>
shr  ebx, 8                <i>; posun jeste pred nasobenim (ztrata presnosti)</i>
mul  ebx                   <i>; nasobeni v FX-pointu do EDX:EAX</i>
</pre>

<p>Původní <a href="#k10">naivní variantu</a> součinu můžeme upravit do této
(sice nepřesné, ale rychlé) podoby:</p>

<pre>
<i>;-----------------------------------------------------------------------------</i>
org  0x100        <i>; zacatek kodu pro programy typu COM (vzdy se zacina na 256)</i>
&nbsp;
<strong>start</strong>:
        jmp main                   <i>; skok na zacatek kodu</i>
&nbsp;
%include "io.asm"                  <i>; nacist symboly, makra a podprogramy</i>
%include "print.asm"               <i>; nacist symboly, makra a podprogramy</i>
&nbsp;
P       equ     65536              <i>; poloha desetinne tecky v FX-pointu</i>
&nbsp;
<strong>main</strong>:
        mov  eax, 2 * P            <i>; konstanta v FX-pointu: 2.0</i>
        print_hex eax
&nbsp;
        mov  eax, 3 * P            <i>; konstanta v FX-pointu: 3.0</i>
        print_hex eax
&nbsp;
        mov  eax, 2 * P            <i>; konstanta v FX-pointu: 1.0</i>
        mov  ebx, 3 * P            <i>; konstanta v FX-pointu: 2.0</i>
        shr  eax, 8                <i>; posun jeste pred nasobenim (ztrata presnosti)</i>
        shr  ebx, 8                <i>; posun jeste pred nasobenim (ztrata presnosti)</i>
        mul  ebx                   <i>; nasobeni v FX-pointu do EDX:EAX</i>
        print_hex eax
&nbsp;
        mov  eax, 1 * P / 2        <i>; konstanta v FX-pointu: 0.5</i>
        print_hex eax
&nbsp;
        mov  eax, 3 * P            <i>; konstanta v FX-pointu: 3.0</i>
        print_hex eax
&nbsp;
        mov  eax, 1 * P / 2        <i>; konstanta v FX-pointu: 0.5</i>
        mov  ebx, 3 * P            <i>; konstanta v FX-pointu: 3.0</i>
        shr  eax, 8                <i>; posun jeste pred nasobenim (ztrata presnosti)</i>
        shr  ebx, 8                <i>; posun jeste pred nasobenim (ztrata presnosti)</i>
        mul  ebx                   <i>; nasobeni v FX-pointu do EDX:EAX</i>
        print_hex eax
&nbsp;
<strong>finish</strong>:
        wait_key                   <i>; cekani na klavesu</i>
        exit                       <i>; navrat do DOSu</i>
&nbsp;
&nbsp;
<i>; datova cast</i>
section .data
&nbsp;
section .bss
</pre>

<p>Ověřme si, zda výpočty skutečně probíhají podle očekávání:</p>

<pre>
00020000 ≅ 2.0
00030000 ≅ 3.0
&nbsp;
00060000 ≅ 6.0 = 2.0 * 3.0
&nbsp;
00008000 ≅ 0.5
00030000 ≅ 3.0
00018000 ≅ 1.5 = 0.5 * 3.0
</pre>

<p>Z&nbsp;výsledků je patrné, že pro tyto konkrétní operandy skutečně dostaneme
správné výsledky. Příště se zaměříme na diskusi o ztrátě přesnosti atd.</p>



<p><a name="k13"></a></p>
<h2 id="k13">13. Úprava operandů po provedení součinu</h2>

<p>Můžeme se pokusit implementovat i &bdquo;opačný&ldquo; způsob provedení
operace součinu, tj.&nbsp;nejdříve oba operandy vynásobit a teprve poté provést
bitový posun. Tato metoda je výhodnější z&nbsp;toho pohledu, že výsledek bude
přesnější (bity totiž ztrácíme až po provedení součinu), ovšem nevýhodou je, že
operace násobení musí výsledek uložit do dvojnásobného počtu bitů. To konkrétně
znamená, že pro dvojici 32bitových operandů bude výsledek 64bitový. Na
platformě 80386 je toho možné dosáhnout relativně snadno, protože operace
<strong>MUL</strong> v&nbsp;tomto případě vrátí výsledek ve dvojici registrů
EDX:EAX. Tento obsah musíme posunout doprava o šestnáct bitů. To lze provést
malým trikem &ndash; přesunem šestnáctibitové části výsledku (bity 15 až 23 do
bitů 0 až 7) a rotací 32bitového registru o šestnáct bitů (musí se jednat o
rotaci, nikoli o posun):</p>

<pre>
mov  eax, první_operand
mov  ebx, druhý_operand
mul  ebx                   <i>; nasobeni v FX-pointu do EDX:EAX</i>
mov  ax, dx                <i>; bity 16-32</i>
ror  eax, 16               <i>; prohodit horni a spodni polovinu registru</i>
</pre>

<p>Praktická realizace takto realizovaného součinu využívajícího FX formát
vypadá následovně:</p>

<pre>
<i>;-----------------------------------------------------------------------------</i>
org  0x100        <i>; zacatek kodu pro programy typu COM (vzdy se zacina na 256)</i>
&nbsp;
<strong>start</strong>:
        jmp main                   <i>; skok na zacatek kodu</i>
&nbsp;
%include "io.asm"                  <i>; nacist symboly, makra a podprogramy</i>
%include "print.asm"               <i>; nacist symboly, makra a podprogramy</i>
&nbsp;
P       equ     65536              <i>; poloha desetinne tecky v FX-pointu</i>
&nbsp;
<strong>main</strong>:
        mov  eax, 2 * P            <i>; konstanta v FX-pointu: 2.0</i>
        print_hex eax
&nbsp;
        mov  eax, 3 * P            <i>; konstanta v FX-pointu: 3.0</i>
        print_hex eax
&nbsp;
        mov  eax, 2 * P            <i>; konstanta v FX-pointu: 1.0</i>
        mov  ebx, 3 * P            <i>; konstanta v FX-pointu: 2.0</i>
        mul  ebx                   <i>; nasobeni v FX-pointu do EDX:EAX</i>
        mov  ax, dx                <i>; bity 16-32</i>
        ror  eax, 16               <i>; prohodit horni a spodni polovinu registru</i>
        print_hex eax
&nbsp;
        mov  eax, 1 * P / 2        <i>; konstanta v FX-pointu: 0.5</i>
        print_hex eax
&nbsp;
        mov  eax, 3 * P            <i>; konstanta v FX-pointu: 3.0</i>
        print_hex eax
&nbsp;
        mov  eax, 1 * P / 2        <i>; konstanta v FX-pointu: 0.5</i>
        mov  ebx, 3 * P            <i>; konstanta v FX-pointu: 3.0</i>
        mul  ebx                   <i>; nasobeni v FX-pointu do EDX:EAX</i>
        mov  ax, dx                <i>; bity 16-32</i>
        ror  eax, 16               <i>; prohodit horni a spodni polovinu registru</i>
        print_hex eax
&nbsp;
<strong>finish</strong>:
        wait_key                   <i>; cekani na klavesu</i>
        exit                       <i>; navrat do DOSu</i>
&nbsp;
&nbsp;
<i>; datova cast</i>
section .data
&nbsp;
section .bss
</pre>

<p>Opět se podívejme na vypočtené výsledky a pokusme se je analyzovat:</p>

<pre>
00020000 ≅ 2.0
00030000 ≅ 3.0
&nbsp;
00060000 ≅ 6.0 = 2.0 * 3.0
&nbsp;
00008000 ≅ 0.5
00030000 ≅ 3.0
00018000 ≅ 1.5 = 0.5 * 3.0
</pre>

<p>Z&nbsp;výsledků je opět patrné, že jsou korektní.</p>



<p><a name="k14"></a></p>
<h2 id="k14">14. Krátká odbočka: jakým způsobem se přeloží FX operace při použití jazyka C</h2>

<p>Jen pro zajímavost se podívejme na to, jak dobře (nebo naopak špatně) jsou
přeloženy operace s&nbsp;pevnou řádovou tečkou v&nbsp;případě, pokud pro jejich
zápis použijeme programovací jazyk C. Výsledky nemusí dopadnout dobře tehdy,
když explicitně nespecifikujeme, že mezivýsledky mohou mít vyšší počet bitů,
než operandy (resp.&nbsp;parametry příslušných funkcí). Ostatně se o tom můžeme
přesvědčit sami:</p>

<pre>
#include &lt;stdint.h&gt;
&nbsp;
uint32_t <strong>fx_add</strong>(uint32_t x, uint32_t y) {
    return x+y;
}
&nbsp;
uint32_t <strong>fx_mul_1</strong>(uint32_t x, uint32_t y) {
    return (x&gt;&gt;8) * (y&gt;&gt;8);
}
&nbsp;
uint32_t <strong>fx_mul_2</strong>(uint32_t x, uint32_t y) {
    return (x*y)&gt;&gt;16;
}
</pre>

<p>Překlad provedený bez optimalizací, tj.&nbsp;s&nbsp;přepínačem
<strong>-O0</strong>:</p>

<pre>
<strong>fx_add</strong>(unsigned int, unsigned int):
        push    rbp
        mov     rbp, rsp
        mov     DWORD PTR [rbp-4], edi
        mov     DWORD PTR [rbp-8], esi
        mov     edx, DWORD PTR [rbp-4]
        mov     eax, DWORD PTR [rbp-8]
        add     eax, edx
        pop     rbp
        ret
&nbsp;
<strong>fx_mul_1</strong>(unsigned int, unsigned int):
        push    rbp
        mov     rbp, rsp
        mov     DWORD PTR [rbp-4], edi
        mov     DWORD PTR [rbp-8], esi
        mov     eax, DWORD PTR [rbp-4]
        shr     eax, 8
        mov     edx, eax
        mov     eax, DWORD PTR [rbp-8]
        shr     eax, 8
        imul    eax, edx
        pop     rbp
        ret
&nbsp;
<strong>fx_mul_2</strong>(unsigned int, unsigned int):
        push    rbp
        mov     rbp, rsp
        mov     DWORD PTR [rbp-4], edi
        mov     DWORD PTR [rbp-8], esi
        mov     eax, DWORD PTR [rbp-4]
        imul    eax, DWORD PTR [rbp-8]
        shr     eax, 16
        pop     rbp
        ret
</pre>

<p>Překlad provedený s&nbsp;optimalizacemi na výkon,
tj.&nbsp;<strong>-O9</strong>:</p>

<pre>
<strong>fx_add</strong>(unsigned int, unsigned int):
        lea     eax, [rdi+rsi]
        ret
&nbsp;
<strong>fx_mul_1</strong>(unsigned int, unsigned int):
        shr     edi, 8
        shr     esi, 8
        mov     eax, edi
        imul    eax, esi
        ret
&nbsp;
<strong>fx_mul_2</strong>(unsigned int, unsigned int):
        imul    edi, esi
        mov     eax, edi
        shr     eax, 16
        ret
</pre>

<p><div class="rs-tip-major">Poznámka: poslední funkce není korektní.</div></p>

<p>Překlad provedený s&nbsp;optimalizacemi na velikost výsledného kódu,
tj.&nbsp;<strong>-Os</strong>:</p>

<pre>
<strong>fx_add</strong>(unsigned int, unsigned int):
        lea     eax, [rdi+rsi]
        ret
&nbsp;
<strong>fx_mul_1</strong>(unsigned int, unsigned int):
        shr     edi, 8
        shr     esi, 8
        mov     eax, edi
        imul    eax, esi
        ret
&nbsp;
<strong>fx_mul_2</strong>(unsigned int, unsigned int):
        imul    edi, esi
        mov     eax, edi
        shr     eax, 16
        ret
</pre>

<p><div class="rs-tip-major">Poznámka: poslední funkce opět není
korektní.</div></p>

<p>Pochopitelně je možné správným přetypováním dosáhnout kýženého výsledku,
ovšem v&nbsp;tomto konkrétním případě si dovolím tvrdit, že assemblerovský kódu
bude mnohem čitelnější v&nbsp;porovnání s&nbsp;céčkovou variantou.</p>



<p><a name="k15"></a></p>
<h2 id="k15">15. Výpočet Mandelbrotovy množiny ve formátu s&nbsp;pevnou řádovou tečkou</h2>

<p>V&nbsp;závěrečné části dnešního článku si ukážeme, jakým způsobem je možné
formát s&nbsp;pevnou řádovou tečkou použít v&nbsp;praxi. Budeme provádět
výpočet Mandelbrotovy množiny, který již byl na stránkách Roota realizován
mnoha různými způsoby a v&nbsp;mnoha programovacích jazycích. Nyní se ovšem
zaměříme na realizaci využívající assembler, reálný režim IBM PC a navíc bude
pro vykreslování použit grafický režim karty VGA s&nbsp;rozlišením
320&times;200 pixelů s&nbsp;256 barvami (což je z&nbsp;pohledu programátora ten
nejjednodušší grafický režim vůbec). Díky použití formátu s&nbsp;pevnou řádovou
čárkou není nutné, aby byl nainstalován matematický koprocesor &ndash; ten
dokonce ani nemusí být emulován, protože není použita ani jedna jeho instrukce.
V&nbsp;každém případě by výsledkem měl být přesně tento obraz (bude bitově
totožný na všech variantách IBM PC, protože nezáleží na přesnosti FP výpočtů,
na jeho zaokrouhlovacích režimech, optimalizacích překladače atd.):</p>

<div class="rs-img-center" style="margin-left: auto; margin-right: auto; max-width: 700px"><a href="https://www.root.cz/obrazek/1208319/"><img src="https://i.iinfo.cz/images/517/fx-mandelbrot-1-large.png" class="image-1208319" width="700" height="525" data-prev-filename="https://i.iinfo.cz/images/517/fx-mandelbrot-1-prev.png" data-prev-filename-webp="https://i.iinfo.cz/images/517/fx-mandelbrot-1-prev.webp" data-prev-width="360" data-prev-height="270" data-large-filename="https://i.iinfo.cz/images/517/fx-mandelbrot-1-large.png" data-large-filename-webp="https://i.iinfo.cz/images/517/fx-mandelbrot-1-large.webp" data-large-width="700" data-large-height="525" alt="Mandelbrotova množina vykreslená kódem zapsaným v assembleru" data-description="Mandelbrotova množina vykreslená kódem zapsaným v assembleru" title="Autor: tisnik, podle licence: &lt;a href=&quot;http://en.wikipedia.org/wiki/Rights_Managed&quot;&gt;Rights Managed&lt;/a&gt;" style="width: 100%; height: auto; max-width: 700px" /></a><p>Obrázek 1: Mandelbrotova množina vykreslená kódem zapsaným v assembleru<br class="_remove" /></p><p class="author">Autor: tisnik, podle licence: <a href="http://en.wikipedia.org/wiki/Rights_Managed">Rights Managed</a><br class="_remove" /></p></div>



<p><a name="k16"></a></p>
<h2 id="k16">16. Základní způsob realizace výpočtů</h2>

<p>V&nbsp;pseudokódu (a Python můžeme v&nbsp;tomto kontextu za pseudokód
považovat) může výpočet Mandelbrotovy množiny vypadat následovně. Většina
použitých proměnných jsou typu <i>double</i>, pouze proměnná <strong>i</strong>
je typu <i>int/long</i>:</p>

<pre>
def <strong>calc_mandelbrot</strong>(width, height, maxiter, palette):
&nbsp;
    cy_ = -1.5
    for y in range(height):
        cx_ = -2.0
        for x in range(width):
            zx1 = 0.0
            zy1 = 0.0
            i = 0
            while i &lt; maxiter:
                zx2 = zx1 * zx1
                zy2 = zy1 * zy1
                if zx2 + zy2 &gt; 4.0:
                    break
                zy1 = 2.0 * zx1 * zy1 + cy_
                zx1 = zx2 - zy2 + cx_
                i += 1
&nbsp;
            r = palette[i][0]
            g = palette[i][1]
            b = palette[i][2]
            putpixel(x, y, r, g, b)
            cx_ += 3.0/width
        cy_ += 3.0/height
</pre>

<p><div class="rs-tip-major">Poznámka: proměnné <strong>cx_</strong> a
<strong>cy_</strong> mají podtržítko z&nbsp;toho důvodu, aby nedocházelo
k&nbsp;jejich záměně s&nbsp;pracovním registrem CX.</div></p>

<p>Podívejme se nyní na realizaci některých výše uvedených výpočtů
v&nbsp;assembleru s&nbsp;využitím formátu FX.</p>

<p>Proměnná <strong>cy_</strong> je na začátku inicializována, další pak
nikoli:</p>

<pre>
section .data
&nbsp;
<strong>cy_</strong>     dd MIN                     <i>; poloha v komplexni rovine rovine</i>
&nbsp;
section .bss
&nbsp;
<strong>cx_</strong>     resd 1                     <i>;</i>
<strong>zx1</strong>     resd 1                     <i>;</i>
<strong>zy1</strong>     resd 1                     <i>; aktualni poloha v komplexni rovine</i>
<strong>zx2</strong>     resd 1                     <i>; zx2=zx1^2 (aby se to nemuselo pocitat 2x)</i>
<strong>zy2</strong>     resd 1                     <i>; zy2=zy1^2</i>
</pre>

<p>Realizace výpočtu <i>zx2 = zx1 * zx1</i>:</p>

<pre>
        mov     EAX, dword [zx1]   <i>;</i>
        sar     EAX, 8             <i>;</i>
        imul    EAX                <i>; zx2:=zx1^2 (v X-pointu)</i>
        mov     dword [zx2], EAX   <i>;</i>
</pre>

<p>Realizace výpočtu <i>zy2 = zy1 * zy1</i>:</p>

<pre>
        mov     EAX, dword [zy1]   <i>;</i>
        sar     EAX, 8             <i>;</i>
        imul    EAX                <i>; zy2:=zy1^2 (v X-pointu)</i>
        mov     dword [zy2], EAX   <i>;</i>
</pre>

<p>Realizace výpočtů:</p>

<pre>
zy1 = 2.0 * zx1 * zy1 + cy_
zx1 = zx2 - zy2 + cx_
</pre>

<p>vypadá následovně:</p>

<pre>
        mov     EAX, [zx1]         <i>;</i>
        sar     EAX, 8             <i>; zx1 div 256 (pro mul v X-pointu)</i>
&nbsp;
        mov     EBX, [zy1]         <i>;</i>
        sar     EBX, 7             <i>; zy1 div 256 * 2 (pro mul v X-pointu)</i>
&nbsp;
        imul    EBX                <i>; zy1:=2*zx1*zy1</i>
        add     EAX, [cy_]         <i>; zy1:=2*zx1*zy1+CY (u Mandelbrota poc.iter.)</i>
        mov     [zy1], EAX         <i>; ulozit novou hodnotu zy1</i>
&nbsp;
        mov     EAX, [zx2]         <i>;</i>
        sub     EAX, [zy2]         <i>; zx2:=zx2-zy2=zx1^2-zy1^2</i>
        add     EAX, [cx_]         <i>;</i>
        mov     [zx1], EAX         <i>; zx1:=zx1^2-zy1^2+CX</i>
</pre>

<p><div class="rs-tip-major">Poznámka: posun o sedm bitů a nikoli o bitů osm
vlastně nahrazuje násobení dvěma.</div></p>

<p>A konečně test, zda <i>zx2+zy2</i> nepřesáhla hodnotu <strong>BAILOUT</strong>:</p>

<pre>
        mov     EAX, [zx2]         <i>;</i>
        add     EAX, [zy2]         <i>; ==zx1^2+zy1^2</i>
        cmp     EAX, BAILOUT*P     <i>; kontrola na bailout (abs[Z]&lt;4)</i>
        jc      short iter_loop    <i>; abs[Z]<4 =>dalsi iterace</i>
</pre>



<p><a name="k17"></a></p>
<h2 id="k17">17. Neoptimalizovaná verze výpočtu Mandelbrotovy množiny</h2>

<p>Neoptimalizovaná varianta programu, který po svém spuštění vykreslí
Mandelbrotovu množinu, vypadá následovně. Velikost výsledného kódu je 188
bajtů:</p>

<pre>
<i>;-----------------------------------------------------------------------------</i>
org  0x100        <i>; zacatek kodu pro programy typu COM (vzdy se zacina na 256)</i>
&nbsp;
<i>; konstanty</i>
P       equ     65536              <i>; poloha desetinne tecky v X-pointu</i>
K       equ     4*P/256            <i>; vzdalenost mezi dvema body (krok smycky)</i>
L       equ     4*P/192
MIN     equ     -2*P               <i>; minimalni a maximalni hodnota konstant fraktalu</i>
                                   <i>; v komplexni rovine</i>
MAXITER equ     40                 <i>; maximalni pocet iteraci</i>
BAILOUT equ     4
&nbsp;
section .text
&nbsp;
<strong>start</strong>:
        jmp main                   <i>; skok na zacatek kodu</i>
&nbsp;
%include "io.asm"                  <i>; nacist symboly, makra a podprogramy</i>
&nbsp;
&nbsp;
<strong>main</strong>:
        mov     ax, 13h            <i>; graficky rezim 320x200x256</i>
        int     10h
&nbsp;
<i>;:::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::</i>
<i>;: MANDELBROTOVA MNOZINA                                                    ::</i>
<i>;:::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::</i>
&nbsp;
        push    0xa000
        pop     ES                 <i>; segment obrazove pameti karty VGA</i>
&nbsp;
        mov     DI, 320*8+32       <i>; zacatek vykreslovani na obrazovce</i>
        mov     BP, 192            <i>; BP==[x] fraktal bude velikosti 256x192 pixelu</i>
<strong>mforx</strong>:  mov     dword [cx_], MIN   <i>; od -2 (imaginarni osa)</i>
        mov     SI, 256            <i>; SI==[y]</i>
<strong>mfory</strong>:  mov     CL, MAXITER        <i>; maximalni pocet iteraci</i>
        xor     EAX, EAX           <i>;</i>
        mov     dword [zx1], EAX   <i>; nastaveni real.casti zacatku</i>
        mov     dword [zy1], EAX   <i>; nastaveni imag.casti zacatku</i>
&nbsp;
<strong>iter_loop</strong>:                         <i>; *** iteracni smycka ***</i>
        mov     EAX, dword [zx1]   <i>;</i>
        sar     EAX, 8             <i>;</i>
        imul    EAX                <i>; zx2:=zx1^2 (v X-pointu)</i>
        mov     dword [zx2], EAX   <i>;</i>
&nbsp;
        mov     EAX, dword [zy1]   <i>;</i>
        sar     EAX, 8             <i>;</i>
        imul    EAX                <i>; zy2:=zy1^2 (v X-pointu)</i>
        mov     dword [zy2], EAX   <i>;</i>
&nbsp;
        mov     EAX, [zx1]         <i>;</i>
        sar     EAX, 8             <i>; zx1 div 256 (pro mul v X-pointu)</i>
&nbsp;
        mov     EBX, [zy1]         <i>;</i>
        sar     EBX, 7             <i>; zy1 div 256 * 2 (pro mul v X-pointu)</i>
&nbsp;
        imul    EBX                <i>; zy1:=2*zx1*zy1</i>
        add     EAX, [cy_]         <i>; zy1:=2*zx1*zy1+CY (u Mandelbrota poc.iter.)</i>
        mov     [zy1], EAX         <i>; ulozit novou hodnotu zy1</i>
&nbsp;
        mov     EAX, [zx2]         <i>;</i>
        sub     EAX, [zy2]         <i>; zx2:=zx2-zy2=zx1^2-zy1^2</i>
        add     EAX, [cx_]         <i>;</i>
        mov     [zx1], EAX         <i>; zx1:=zx1^2-zy1^2+CX</i>
&nbsp;
        dec     CL                 <i>; upravit pocitadlo iteraci</i>
        jz      short mpokrac      <i>; konec iteraci ?</i>
        mov     EAX, [zx2]         <i>;</i>
        add     EAX, [zy2]         <i>; ==zx1^2+zy1^2</i>
        cmp     EAX, BAILOUT*P     <i>; kontrola na bailout (abs[Z]&lt;4)</i>
        jc      short iter_loop    <i>; abs[Z]<4 =>dalsi iterace</i>
<strong>mpokrac</strong>:
        mov     AL, CL             <i>; pocet iteraci</i>
        add     AL, 32             <i>; posun na vhodne barvy v palete</i>
        stosb                      <i>; vykreslit pixel+posun na dalsi pixel</i>
        add     dword [cx_], K     <i>; cy_:=cy_+K</i>
        dec     si
        jnz     mfory              <i>; Y!=0 ->dalsi radek</i>
        add     DI, 320-256        <i>; dalsi radek na obrazovce</i>
        add     dword [cy_], L     <i>; cx_:=cx_+K</i>
        dec     BP                 <i>; x=x-1</i>
        jnz     mforx              <i>; X!=0 ->dalsi radek</i>
&nbsp;
<strong>finish</strong>:
        wait_key                   <i>; cekani na klavesu</i>
        exit                       <i>; navrat do DOSu</i>
&nbsp;
&nbsp;
section .data
&nbsp;
<strong>cy_</strong>     dd MIN                     <i>; poloha v komplexni rovine rovine</i>
&nbsp;
section .bss
&nbsp;
<strong>cx_</strong>     resd 1                     <i>;</i>
<strong>zx1</strong>     resd 1                     <i>;</i>
<strong>zy1</strong>     resd 1                     <i>; aktualni poloha v komplexni rovine</i>
<strong>zx2</strong>     resd 1                     <i>; zx2=zx1^2 (aby se to nemuselo pocitat 2x)</i>
<strong>zy2</strong>     resd 1                     <i>; zy2=zy1^2</i>
&nbsp;
&nbsp;
&nbsp;
<i>; finito</i>
</pre>



<p><a name="k18"></a></p>
<h2 id="k18">18. Částečně optimalizovaná verze výpočtu Mandelbrotovy množiny</h2>

<p>Některé výpočty prováděné v&nbsp;příkladu uvedeném <a
href="#k17">v&nbsp;předchozí kapitole</a>, je možné optimalizovat. Mezivýsledky
mohou být uloženy přímo v&nbsp;pracovních registrech, polohu řádové tečky je
možné posunout o několik bitů (a zmenšit tak rozsah registrů) a vykreslování
může být prováděno přes všech 320 sloupců, což poněkud zjednoduší programovou
logiku. Výsledný program bude generovat nepatrně odlišný obrázek a bude kratší
(172 bajtů namísto 188 bajtů):</p>

<div class="rs-img-center" style="margin-left: auto; margin-right: auto; max-width: 700px"><a href="https://www.root.cz/obrazek/1208322/"><img src="https://i.iinfo.cz/images/517/fx-mandelbrot-2-large.png" class="image-1208322" width="700" height="525" data-prev-filename="https://i.iinfo.cz/images/517/fx-mandelbrot-2-prev.png" data-prev-filename-webp="https://i.iinfo.cz/images/517/fx-mandelbrot-2-prev.webp" data-prev-width="360" data-prev-height="270" data-large-filename="https://i.iinfo.cz/images/517/fx-mandelbrot-2-large.png" data-large-filename-webp="https://i.iinfo.cz/images/517/fx-mandelbrot-2-large.webp" data-large-width="700" data-large-height="525" alt="Mandelbrotova množina vykreslená kódem zapsaným v assembleru" data-description="Mandelbrotova množina vykreslená kódem zapsaným v assembleru" title="Autor: tisnik, podle licence: &lt;a href=&quot;http://en.wikipedia.org/wiki/Rights_Managed&quot;&gt;Rights Managed&lt;/a&gt;" style="width: 100%; height: auto; max-width: 700px" /></a><p>Obrázek 2: Mandelbrotova množina vykreslená kódem zapsaným v assembleru<br class="_remove" /></p><p class="author">Autor: tisnik, podle licence: <a href="http://en.wikipedia.org/wiki/Rights_Managed">Rights Managed</a><br class="_remove" /></p></div>

<p>Zdrojový kód demonstračního příkladu byl upraven do této podoby:</p>

<pre>
<i>;-----------------------------------------------------------------------------</i>
org  0x100        <i>; zacatek kodu pro programy typu COM (vzdy se zacina na 256)</i>
&nbsp;
<i>; konstanty</i>
P       equ     4096               <i>; poloha desetinne tecky v X-pointu</i>
K       equ     4*P/256            <i>; vzdalenost mezi dvema body (krok smycky)</i>
L       equ     4*P/192
MIN     equ     -2*P               <i>; minimalni a maximalni hodnota konstant fraktalu</i>
                                   <i>; v komplexni rovine</i>
MAXITER equ     40                 <i>; maximalni pocet iteraci</i>
BAILOUT equ     4
SLOUPCU equ     320                <i>; pocet sloupcu na obrazovce</i>
&nbsp;
section .text
&nbsp;
<strong>start</strong>:
        jmp main                   <i>; skok na zacatek kodu</i>
&nbsp;
%include "io.asm"                  <i>; nacist symboly, makra a podprogramy</i>
&nbsp;
&nbsp;
<strong>main</strong>:
        mov     ax, 13h            <i>; graficky rezim 320x200x256</i>
        int     10h
&nbsp;
<i>;:::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::</i>
<i>;: MANDELBROTOVA MNOZINA                                                    ::</i>
<i>;:::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::</i>
&nbsp;
        push    0xa000
        pop     ES                 <i>; segment obrazove pameti karty VGA</i>
&nbsp;
        xor     DI, DI             <i>; zacatek vykreslovani na obrazovce</i>
        mov     CL, 6              <i>; posun pro FX format</i>
&nbsp;
<strong>mforx</strong>:  mov     dword [cx_], MIN   <i>; od -2 (imaginarni osa)</i>
        mov     SI, SLOUPCU        <i>; x</i>
<strong>mfory</strong>:  mov     CH, MAXITER        <i>; pocet iteraci</i>
        xor     EAX, EAX           <i>;</i>
        mov     EBP, EAX           <i>; nastaveni real.casti zacatku</i>
        mov     dword [zy1], EAX   <i>; nastaveni imag.casti zacatku</i>
<strong>iter_loop</strong>:                         <i>; *** iteracni smycka ***</i>
        mov     EAX, EBP           <i>;</i>
        sar     EAX, CL            <i>;</i>
        imul    EAX                <i>; zx2:=zx1^2 (v X-pointu)</i>
        mov     dword [zx2], EAX   <i>;</i>
&nbsp;
        mov     EAX, dword [zy1]   <i>;</i>
        sar     EAX, CL            <i>; </i>
        imul    EAX                <i>; zy2:=zy1^2 (v X-pointu)</i>
        mov     dword [zy2], EAX   <i>;</i>
&nbsp;
        mov     EAX, EBP           <i>;</i>
        sar     EAX, CL            <i>; zx1 div 256 (pro mul v X-pointu)</i>
&nbsp;
        mov     EBX, [zy1]         <i>;</i>
        sar     EBX, 5             <i>; zy1 div 256 * 2 (pro mul v X-pointu)</i>
&nbsp;
        imul    EBX                <i>; zy1:=2*zx1*zy1</i>
        add     EAX, [cy_]         <i>; zy1:=2*zx1*zy1+CY (u Mandelbrota poc.iter.)</i>
        mov     [zy1], EAX         <i>; ulozit novou hodnotu zy1</i>
&nbsp;
        mov     EAX, [zx2]         <i>;</i>
        sub     EAX, [zy2]         <i>; zx2:=zx2-zy2=zx1^2-zy1^2</i>
        add     EAX, [cx_]         <i>;</i>
        mov     EBP, EAX           <i>; zx1:=zx1^2-zy1^2+CX</i>
&nbsp;
        dec     CH                 <i>; pocitadlo iteraci</i>
        jz      short mpokrac      <i>; konec iteraci ?</i>
        mov     EAX, [zx2]         <i>;</i>
        add     EAX, [zy2]         <i>; ==zx1^2+zy1^2</i>
        cmp     EAX, BAILOUT*P     <i>; kontrola na bailout (abs[Z]&lt;4)</i>
        jc      short iter_loop    <i>; abs[Z]<4 =>dalsi iterace</i>
<strong>mpokrac</strong>:
        mov     AL, CH             <i>; pocet iteraci</i>
        add     AL, 32             <i>; posun na vhodne barvy v palete</i>
        stosb                      <i>; vykreslit pixel+posun na dalsi pixel</i>
        add     dword [cx_], K     <i>; cy_:=cy_+K</i>
        dec     si
        jnz     short mfory        <i>; Y!=0 ->dalsi radek</i>
&nbsp;
        add     dword [cy_], L     <i>; cx_:=cx_+K</i>
        cmp     di, 64000          <i>; konec obrazku ?</i>
        jne     mforx
&nbsp;
<strong>finish</strong>:
        wait_key                   <i>; cekani na klavesu</i>
        exit                       <i>; navrat do DOSu</i>
&nbsp;
&nbsp;
section .data
&nbsp;
<strong>cy_</strong>     dd MIN                     <i>; poloha v komplexni rovine rovine</i>
&nbsp;
section .bss
&nbsp;
<strong>cx_</strong>     resd 1                     <i>;</i>
<strong>zy1</strong>     resd 1                     <i>; aktualni poloha v komplexni rovine</i>
<strong>zx2</strong>     resd 1                     <i>; zx2=zx1^2 (aby se to nemuselo pocitat 2x)</i>
<strong>zy2</strong>     resd 1                     <i>; zy2=zy1^2</i>
&nbsp;
&nbsp;
&nbsp;
<i>; finito</i>
</pre>



<p><a name="k19"></a></p>
<h2 id="k19">19. Repositář s&nbsp;demonstračními příklady</h2>

<p>Demonstrační příklady napsané v&nbsp;assembleru, které jsou určené pro
překlad s&nbsp;využitím assembleru <strong>NASM</strong>, byly uloženy do Git
repositáře, který je dostupný na adrese <a
href="https://github.com/tisnik/8bit-fame">https://github.com/tisnik/8bit-fame</a>.
Jednotlivé demonstrační příklady si můžete v&nbsp;případě potřeby stáhnout i
jednotlivě bez nutnosti klonovat celý (dnes již poměrně rozsáhlý)
repositář:</p>

<table>
<tr><th> #</th><th>Příklad</th><th>Stručný popis</th><th>Adresa</th></tr>
<tr><td> 1</td><td>hello.asm</td><td>program typu &bdquo;Hello world&ldquo; naprogramovaný v&nbsp;assembleru pro systém DOS</td><td><a href="https://github.com/tisnik/8bit-fame/blob/master/pc-dos/hello.asm">https://github.com/tisnik/8bit-fame/blob/master/pc-dos/hello.asm</a></td></tr>
<tr><td> 2</td><td>hello_shorter.asm</td><td>kratší varianta výskoku z&nbsp;procesu zpět do DOSu</td><td><a href="https://github.com/tisnik/8bit-fame/blob/master/pc-dos/hello_shorter.asm">https://github.com/tisnik/8bit-fame/blob/master/pc-dos/hello_shorter.asm</a></td></tr>
<tr><td> 3</td><td>hello_wait.asm</td><td>čekání na stisk klávesy</td><td><a href="https://github.com/tisnik/8bit-fame/blob/master/pc-dos/hello_wait.asm">https://github.com/tisnik/8bit-fame/blob/master/pc-dos/hello_wait.asm</a></td></tr>
<tr><td> 4</td><td>hello_macros.asm</td><td>realizace jednotlivých částí programu makrem</td><td><a href="https://github.com/tisnik/8bit-fame/blob/master/pc-dos/hello_macros.asm">https://github.com/tisnik/8bit-fame/blob/master/pc-dos/hello_macros.asm</a></td></tr>
<tr><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td></tr>
<tr><td> 5</td><td>gfx_4_putpixel.asm</td><td>vykreslení pixelu v&nbsp;grafickém režimu 4</td><td><a href="https://github.com/tisnik/8bit-fame/blob/master/pc-dos/gfx_4_putpixel.asm">https://github.com/tisnik/8bit-fame/blob/master/pc-dos/gfx_4_putpixel.asm</a></td></tr>
<tr><td> 6</td><td>gfx_6_putpixel.asm</td><td>vykreslení pixelu v&nbsp;grafickém režimu 6</td><td><a href="https://github.com/tisnik/8bit-fame/blob/master/pc-dos/gfx_6_putpixel.asm">https://github.com/tisnik/8bit-fame/blob/master/pc-dos/gfx_6_putpixel.asm</a></td></tr>
<tr><td> 7</td><td>gfx_4_line.asm</td><td>vykreslení úsečky v&nbsp;grafickém režimu 4</td><td><a href="https://github.com/tisnik/8bit-fame/blob/master/pc-dos/gfx_4_line.asm">https://github.com/tisnik/8bit-fame/blob/master/pc-dos/gfx_4_line.asm</a></td></tr>
<tr><td> 8</td><td>gfx_6_line.asm</td><td>vykreslení úsečky v&nbsp;grafickém režimu 6</td><td><a href="https://github.com/tisnik/8bit-fame/blob/master/pc-dos/gfx_6_line.asm">https://github.com/tisnik/8bit-fame/blob/master/pc-dos/gfx_6_line.asm</a></td></tr>
<tr><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td></tr>
<tr><td> 9</td><td>gfx_6_fill_1.asm</td><td>vyplnění obrazovky v&nbsp;grafickém režimu, základní varianta</td><td><a href="https://github.com/tisnik/8bit-fame/blob/master/pc-dos/gfx_6_fill_1.asm">https://github.com/tisnik/8bit-fame/blob/master/pc-dos/gfx_6_fill_1.asm</a></td></tr>
<tr><td>10</td><td>gfx_6_fill_2.asm</td><td>vyplnění obrazovky v&nbsp;grafickém režimu, varianta s&nbsp;instrukcí <strong>LOOP</strong></td><td><a href="https://github.com/tisnik/8bit-fame/blob/master/pc-dos/gfx_6_fill_2.asm">https://github.com/tisnik/8bit-fame/blob/master/pc-dos/gfx_6_fill_2.asm</a></td></tr>
<tr><td>11</td><td>gfx_6_fill_3.asm</td><td>vyplnění obrazovky instrukcí <strong>REP STOSB</strong></td><td><a href="https://github.com/tisnik/8bit-fame/blob/master/pc-dos/gfx_6_fill_3.asm">https://github.com/tisnik/8bit-fame/blob/master/pc-dos/gfx_6_fill_3.asm</a></td></tr>
<tr><td>12</td><td>gfx_6_fill_4.asm</td><td>vyplnění obrazovky, synchronizace vykreslování s&nbsp;paprskem</td><td><a href="https://github.com/tisnik/8bit-fame/blob/master/pc-dos/gfx_6_fill_4.asm">https://github.com/tisnik/8bit-fame/blob/master/pc-dos/gfx_6_fill_4.asm</a></td></tr>
<tr><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td></tr>
<tr><td>13</td><td>gfx_4_image_1.asm</td><td>vykreslení rastrového obrázku získaného z&nbsp;binárních dat, základní varianta</td><td><a href="https://github.com/tisnik/8bit-fame/blob/master/pc-dos/gfx_4_image_1.asm">https://github.com/tisnik/8bit-fame/blob/master/pc-dos/gfx_4_image_1.asm</a></td></tr>
<tr><td>14</td><td>gfx_4_image_2.asm</td><td>varianta vykreslení rastrového obrázku s&nbsp;využitím instrukce <strong>REP MOVSB</strong></td><td><a href="https://github.com/tisnik/8bit-fame/blob/master/pc-dos/gfx_4_image_2.asm">https://github.com/tisnik/8bit-fame/blob/master/pc-dos/gfx_4_image_2.asm</a></td></tr>
<tr><td>15</td><td>gfx_4_image_3.asm</td><td>varianta vykreslení rastrového obrázku s&nbsp;využitím instrukce <strong>REP MOVSW</strong></td><td><a href="https://github.com/tisnik/8bit-fame/blob/master/pc-dos/gfx_4_image_3.asm">https://github.com/tisnik/8bit-fame/blob/master/pc-dos/gfx_4_image_3.asm</a></td></tr>
<tr><td>16</td><td>gfx_4_image_4.asm</td><td>korektní vykreslení všech sudých řádků bitmapy</td><td><a href="https://github.com/tisnik/8bit-fame/blob/master/pc-dos/gfx_4_image_4.asm">https://github.com/tisnik/8bit-fame/blob/master/pc-dos/gfx_4_image_4.asm</a></td></tr>
<tr><td>17</td><td>gfx_4_image_5.asm</td><td>korektní vykreslení všech sudých i lichých řádků bitmapy</td><td><a href="https://github.com/tisnik/8bit-fame/blob/master/pc-dos/gfx_4_image_5.asm">https://github.com/tisnik/8bit-fame/blob/master/pc-dos/gfx_4_image_5.asm</a></td></tr>
<tr><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td></tr>
<tr><td>18</td><td>gfx_4_image_6.asm</td><td>nastavení barvové palety před vykreslením obrázku</td><td><a href="https://github.com/tisnik/8bit-fame/blob/master/pc-dos/gfx_4_image_6.asm">https://github.com/tisnik/8bit-fame/blob/master/pc-dos/gfx_4_image_6.asm</a></td></tr>
<tr><td>19</td><td>gfx_4_image_7.asm</td><td>nastavení barvové palety před vykreslením obrázku, snížená intenzita barev</td><td><a href="https://github.com/tisnik/8bit-fame/blob/master/pc-dos/gfx_4_image_7.asm">https://github.com/tisnik/8bit-fame/blob/master/pc-dos/gfx_4_image_7.asm</a></td></tr>
<tr><td>20</td><td>gfx_4_image_8.asm</td><td>postupná změna barvy pozadí</td><td><a href="https://github.com/tisnik/8bit-fame/blob/master/pc-dos/gfx_4_image_8.asm">https://github.com/tisnik/8bit-fame/blob/master/pc-dos/gfx_4_image_8.asm</a></td></tr>
<tr><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td></tr>
<tr><td>21</td><td>gfx_6_putpixel_1.asm</td><td>vykreslení pixelu, základní varianta se 16bitovým násobením</td><td><a href="https://github.com/tisnik/8bit-fame/blob/master/pc-dos/gfx_6_putpixel_1.asm">https://github.com/tisnik/8bit-fame/blob/master/pc-dos/gfx_6_putpixel_1.asm</a></td></tr>
<tr><td>22</td><td>gfx_6_putpixel_2.asm</td><td>vykreslení pixelu, varianta s&nbsp;osmibitovým násobením</td><td><a href="https://github.com/tisnik/8bit-fame/blob/master/pc-dos/gfx_6_putpixel_2.asm">https://github.com/tisnik/8bit-fame/blob/master/pc-dos/gfx_6_putpixel_2.asm</a></td></tr>
<tr><td>23</td><td>gfx_6_putpixel_3.asm</td><td>vykreslení pixelu, varianta bez násobení</td><td><a href="https://github.com/tisnik/8bit-fame/blob/master/pc-dos/gfx_6_putpixel_3.asm">https://github.com/tisnik/8bit-fame/blob/master/pc-dos/gfx_6_putpixel_3.asm</a></td></tr>
<tr><td>24</td><td>gfx_6_putpixel_4.asm</td><td>vykreslení pixelu přes obrázek, nekorektní chování (přepis obrázku)</td><td><a href="https://github.com/tisnik/8bit-fame/blob/master/pc-dos/gfx_6_putpixel_4.asm">https://github.com/tisnik/8bit-fame/blob/master/pc-dos/gfx_6_putpixel_4.asm</a></td></tr>
<tr><td>25</td><td>gfx_6_putpixel_5.asm</td><td>vykreslení pixelu přes obrázek, korektní varianta pro bílé pixely</td><td><a href="https://github.com/tisnik/8bit-fame/blob/master/pc-dos/gfx_6_putpixel_5.asm">https://github.com/tisnik/8bit-fame/blob/master/pc-dos/gfx_6_putpixel_5.asm</a></td></tr>
<tr><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td></tr>
<tr><td>26</td><td>cga_text_mode_1.asm</td><td>standardní textový režim s&nbsp;rozlišením 40&times;25 znaků</td><td><a href="https://github.com/tisnik/8bit-fame/blob/master/pc-dos/cga_text_mode_1.asm">https://github.com/tisnik/8bit-fame/blob/master/pc-dos/cga_text_mode_1.asm</a></td></tr>
<tr><td>27</td><td>cga_text_mode_3.asm</td><td>standardní textový režim s&nbsp;rozlišením 80&times;25 znaků</td><td><a href="https://github.com/tisnik/8bit-fame/blob/master/pc-dos/cga_text_mode_3.asm">https://github.com/tisnik/8bit-fame/blob/master/pc-dos/cga_text_mode_3.asm</a></td></tr>
<tr><td>28</td><td>cga_text_mode_intensity.asm</td><td>změna významu nejvyššího bitu atributového bajtu: vyšší intenzita namísto blikání</td><td><a href="https://github.com/tisnik/8bit-fame/blob/master/pc-dos/cga_text_mode_intensity.asm">https://github.com/tisnik/8bit-fame/blob/master/pc-dos/cga_text_mode_intensity.asm</a></td></tr>
<tr><td>29</td><td>cga_text_mode_cursor.asm</td><td>změna tvaru textového kurzoru</td><td><a href="https://github.com/tisnik/8bit-fame/blob/master/pc-dos/cga_text_mode_cursor.asm">https://github.com/tisnik/8bit-fame/blob/master/pc-dos/cga_text_mode_cursor.asm</a></td></tr>
<tr><td>30</td><td>cga_text_gfx_1.asm</td><td>zobrazení &bdquo;rastrové mřížky&ldquo;: pseudografický režim 160&times;25 pixelů (interně textový režim)</td><td><a href="https://github.com/tisnik/8bit-fame/blob/master/pc-dos/cga_text_gfx_1.asm">https://github.com/tisnik/8bit-fame/blob/master/pc-dos/cga_text_gfx_1.asm</a></td></tr>
<tr><td>31</td><td>cga_text_mode_char_height.asm</td><td>změna výšky znaků</td><td><a href="https://github.com/tisnik/8bit-fame/blob/master/pc-dos/cga_text_mode_char_height.asm">https://github.com/tisnik/8bit-fame/blob/master/pc-dos/cga_text_mode_char_height.asm</a></td></tr>
<tr><td>32</td><td>cga_text_160x100.asm</td><td>grafický režim 160&times;100 se šestnácti barvami (interně upravený textový režim)</td><td><a href="https://github.com/tisnik/8bit-fame/blob/master/pc-dos/cga_text_160x100.asm">https://github.com/tisnik/8bit-fame/blob/master/pc-dos/cga_text_160x100.asm</a></td></tr>
<tr><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td></tr>
<tr><td>33</td><td>hercules_text_mode_1.asm</td><td>využití standardního textového režimu společně s&nbsp;kartou Hercules</td><td><a href="https://github.com/tisnik/8bit-fame/blob/master/pc-dos/hercules_text_mode_1.asm">https://github.com/tisnik/8bit-fame/blob/master/pc-dos/hercules_text_mode_1.asm</a></td></tr>
<tr><td>34</td><td>hercules_text_mode_2.asm</td><td>zákaz blikání v&nbsp;textových režimech</td><td><a href="https://github.com/tisnik/8bit-fame/blob/master/pc-dos/hercules_text_mode_2.asm">https://github.com/tisnik/8bit-fame/blob/master/pc-dos/hercules_text_mode_2.asm</a></td></tr>
<tr><td>35</td><td>hercules_turn_off.asm</td><td>vypnutí generování video signálu</td><td><a href="https://github.com/tisnik/8bit-fame/blob/master/pc-dos/hercules_turn_off.asm">https://github.com/tisnik/8bit-fame/blob/master/pc-dos/hercules_turn_off.asm</a></td></tr>
<tr><td>36</td><td>hercules_gfx_mode_1.asm</td><td>přepnutí karty Hercules do grafického režimu (základní varianta)</td><td><a href="https://github.com/tisnik/8bit-fame/blob/master/pc-dos/hercules_gfx_mode_1.asm">https://github.com/tisnik/8bit-fame/blob/master/pc-dos/hercules_gfx_mode_1.asm</a></td></tr>
<tr><td>37</td><td>hercules_gfx_mode_2.asm</td><td>přepnutí karty Hercules do grafického režimu (vylepšená varianta)</td><td><a href="https://github.com/tisnik/8bit-fame/blob/master/pc-dos/hercules_gfx_mode_2.asm">https://github.com/tisnik/8bit-fame/blob/master/pc-dos/hercules_gfx_mode_2.asm</a></td></tr>
<tr><td>38</td><td>hercules_putpixel.asm</td><td>subrutina pro vykreslení jediného pixelu na kartě Hercules</td><td><a href="https://github.com/tisnik/8bit-fame/blob/master/pc-dos/hercules_putpixel.asm">https://github.com/tisnik/8bit-fame/blob/master/pc-dos/hercules_putpixel.asm</a></td></tr>
<tr><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td></tr>
<tr><td>39</td><td>ega_text_mode_80x25.asm</td><td>standardní textový režim 80&times;25 znaků na kartě EGA</td><td><a href="https://github.com/tisnik/8bit-fame/blob/master/pc-dos/ega_text_mode_80x25.asm">https://github.com/tisnik/8bit-fame/blob/master/pc-dos/ega_text_mode_80x25.asm</a></td></tr>
<tr><td>40</td><td>ega_text_mode_80x43.asm</td><td>zobrazení 43 textových řádků na kartě EGA</td><td><a href="https://github.com/tisnik/8bit-fame/blob/master/pc-dos/ega_text_mode_80x43.asm">https://github.com/tisnik/8bit-fame/blob/master/pc-dos/ega_text_mode_80x43.asm</a></td></tr>
<tr><td>41</td><td>ega_gfx_mode_320x200.asm</td><td>přepnutí do grafického režimu 320&times;200 pixelů se šestnácti barvami</td><td><a href="https://github.com/tisnik/8bit-fame/blob/master/pc-dos/ega_gfx_mode_320x200.asm">https://github.com/tisnik/8bit-fame/blob/master/pc-dos/ega_gfx_mode_320x200.asm</a></td></tr>
<tr><td>42</td><td>ega_gfx_mode_640x200.asm</td><td>přepnutí do grafického režimu 640&times;200 pixelů se šestnácti barvami</td><td><a href="https://github.com/tisnik/8bit-fame/blob/master/pc-dos/ega_gfx_mode_640x200.asm">https://github.com/tisnik/8bit-fame/blob/master/pc-dos/ega_gfx_mode_640x200.asm</a></td></tr>
<tr><td>43</td><td>ega_gfx_mode_640x350.asm</td><td>přepnutí do grafického režimu 640&times;350 pixelů se čtyřmi nebo šestnácti barvami</td><td><a href="https://github.com/tisnik/8bit-fame/blob/master/pc-dos/ega_gfx_mode_640x350.asm">https://github.com/tisnik/8bit-fame/blob/master/pc-dos/ega_gfx_mode_640x350.asm</a></td></tr>
<tr><td>44</td><td>ega_gfx_mode_bitplanes_1.asm</td><td>ovládání zápisu do bitových rovin v&nbsp;planárních grafických režimech (základní způsob)</td><td><a href="https://github.com/tisnik/8bit-fame/blob/master/pc-dos/ega_gfx_mode_bitplanes_1.asm">https://github.com/tisnik/8bit-fame/blob/master/pc-dos/ega_gfx_mode_bitplanes_1.asm</a></td></tr>
<tr><td>45</td><td>ega_gfx_mode_bitplanes_2.asm</td><td>ovládání zápisu do bitových rovin v&nbsp;planárních grafických režimech (rychlejší způsob)</td><td><a href="https://github.com/tisnik/8bit-fame/blob/master/pc-dos/ega_gfx_mode_bitplanes_2.asm">https://github.com/tisnik/8bit-fame/blob/master/pc-dos/ega_gfx_mode_bitplanes_2.asm</a></td></tr>
<tr><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td></tr>
<tr><td>46</td><td>ega_320x200_putpixel.asm</td><td>vykreslení pixelu v&nbsp;grafickém režimu 320&times;200 pixelů se šestnácti barvami</td><td><a href="https://github.com/tisnik/8bit-fame/blob/master/pc-dos/ega_320x200_putpixel.asm">https://github.com/tisnik/8bit-fame/blob/master/pc-dos/ega_320x200_putpixel.asm</a></td></tr>
<tr><td>47</td><td>ega_640x350_putpixel.asm</td><td>vykreslení pixelu v&nbsp;grafickém režimu 640&times;350 pixelů se šestnácti barvami</td><td><a href="https://github.com/tisnik/8bit-fame/blob/master/pc-dos/ega_640x350_putpixel.asm">https://github.com/tisnik/8bit-fame/blob/master/pc-dos/ega_640x350_putpixel.asm</a></td></tr>
<tr><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td></tr>
<tr><td>48</td><td>ega_standard_font.asm</td><td>použití standardního fontu grafické karty EGA</td><td><a href="https://github.com/tisnik/8bit-fame/blob/master/pc-dos/ega_standard_font.asm">https://github.com/tisnik/8bit-fame/blob/master/pc-dos/ega_standard_font.asm</a></td></tr>
<tr><td>49</td><td>ega_custom_font.asm</td><td>načtení vlastního fontu s&nbsp;jeho zobrazením</td><td><a href="https://github.com/tisnik/8bit-fame/blob/master/pc-dos/ega_custom_font.asm">https://github.com/tisnik/8bit-fame/blob/master/pc-dos/ega_custom_font.asm</a></td></tr>
<tr><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td></tr>
<tr><td>50</td><td>ega_palette_1.asm</td><td>změna barvové palety (všech 16 barev) v&nbsp;grafickém režimu 320&times;200 se šestnácti barvami</td><td><a href="https://github.com/tisnik/8bit-fame/blob/master/pc-dos/ega_palette_1.asm">https://github.com/tisnik/8bit-fame/blob/master/pc-dos/ega_palette_1.asm</a></td></tr>
<tr><td>51</td><td>ega_palette_2.asm</td><td>změna barvové palety (všech 16 barev) v&nbsp;grafickém režimu 640&times;350 se šestnácti barvami</td><td><a href="https://github.com/tisnik/8bit-fame/blob/master/pc-dos/ega_palette_2.asm">https://github.com/tisnik/8bit-fame/blob/master/pc-dos/ega_palette_2.asm</a></td></tr>
<tr><td>52</td><td>ega_palette_3.asm</td><td>změna všech barev v&nbsp;barvové paletě s&nbsp;využitím programové smyčky</td><td><a href="https://github.com/tisnik/8bit-fame/blob/master/pc-dos/ega_palette_3.asm">https://github.com/tisnik/8bit-fame/blob/master/pc-dos/ega_palette_3.asm</a></td></tr>
<tr><td>53</td><td>ega_palette_4.asm</td><td>změna všech barev, včetně barvy okraje, v&nbsp;barvové paletě voláním funkce BIOSu</td><td><a href="https://github.com/tisnik/8bit-fame/blob/master/pc-dos/ega_palette_4.asm">https://github.com/tisnik/8bit-fame/blob/master/pc-dos/ega_palette_4.asm</a></td></tr>
<tr><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td></tr>
<tr><td>54</td><td>vga_text_mode_80x25.asm</td><td>standardní textový režim 80&times;25 znaků na kartě VGA</td><td><a href="https://github.com/tisnik/8bit-fame/blob/master/pc-dos/vga_text_mode_80x25.asm">https://github.com/tisnik/8bit-fame/blob/master/pc-dos/vga_text_mode_80x25.asm</a></td></tr>
<tr><td>55</td><td>vga_text_mode_80x50.asm</td><td>zobrazení 50 a taktéž 28 textových řádků na kartě VGA</td><td><a href="https://github.com/tisnik/8bit-fame/blob/master/pc-dos/vga_text_mode_80x50.asm">https://github.com/tisnik/8bit-fame/blob/master/pc-dos/vga_text_mode_80x50.asm</a></td></tr>
<tr><td>56</td><td>vga_text_mode_intensity_1.asm</td><td>změna chování atributového bitu pro blikání (nebezpečná varianta změny registrů)</td><td><a href="https://github.com/tisnik/8bit-fame/blob/master/pc-dos/vga_text_mode_intensity_1.asm">https://github.com/tisnik/8bit-fame/blob/master/pc-dos/vga_text_mode_intensity_1.asm</a></td></tr>
<tr><td>57</td><td>vga_text_mode_intensity_2.asm</td><td>změna chování atributového bitu pro blikání (bezpečnější varianta změny registrů)</td><td><a href="https://github.com/tisnik/8bit-fame/blob/master/pc-dos/vga_text_mode_intensity_2.asm">https://github.com/tisnik/8bit-fame/blob/master/pc-dos/vga_text_mode_intensity_2.asm</a></td></tr>
<tr><td>58</td><td>vga_text_mode_9th_column.asm</td><td>modifikace způsobu zobrazení devátého sloupce ve znakových režimech (720 pixelů na řádku)</td><td><a href="https://github.com/tisnik/8bit-fame/blob/master/pc-dos/vga_text_mode_9th_column.asm">https://github.com/tisnik/8bit-fame/blob/master/pc-dos/vga_text_mode_9th_column.asm</a></td></tr>
<tr><td>59</td><td>vga_text_mode_cursor_shape.asm</td><td>změna tvaru textového kurzoru na grafické kartě VGA</td><td><a href="https://github.com/tisnik/8bit-fame/blob/master/pc-dos/vga_text_mode_cursor_shape.asm">https://github.com/tisnik/8bit-fame/blob/master/pc-dos/vga_text_mode_cursor_shape.asm</a></td></tr>
<tr><td>60</td><td>vga_text_mode_custom_font.asm</td><td>načtení vlastního fontu s&nbsp;jeho zobrazením</td><td><a href="https://github.com/tisnik/8bit-fame/blob/master/pc-dos/vga_text_mode_custom_font.asm">https://github.com/tisnik/8bit-fame/blob/master/pc-dos/vga_text_mode_custom_font.asm</a></td></tr>
<tr><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td></tr>
<tr><td>61</td><td>vga_gfx_mode_640x480.asm</td><td>přepnutí do grafického režimu 640&times;480 pixelů se šestnácti barvami, vykreslení vzorků</td><td><a href="https://github.com/tisnik/8bit-fame/blob/master/pc-dos/vga_gfx_mode_640x480.asm">https://github.com/tisnik/8bit-fame/blob/master/pc-dos/vga_gfx_mode_640x480.asm</a></td></tr>
<tr><td>62</td><td>vga_gfx_mode_320x200.asm</td><td>přepnutí do grafického režimu 320&times;200 pixelů s&nbsp;256 barvami, vykreslení vzorků</td><td><a href="https://github.com/tisnik/8bit-fame/blob/master/pc-dos/vga_gfx_mode_320x200.asm">https://github.com/tisnik/8bit-fame/blob/master/pc-dos/vga_gfx_mode_320x200.asm</a></td></tr>
<tr><td>63</td><td>vga_gfx_mode_palette.asm</td><td>změna všech barev v&nbsp;barvové paletě grafické karty VGA</td><td><a href="https://github.com/tisnik/8bit-fame/blob/master/pc-dos/vga_gfx_mode_palette.asm">https://github.com/tisnik/8bit-fame/blob/master/pc-dos/vga_gfx_mode_palette.asm</a></td></tr>
<tr><td>64</td><td>vga_gfx_mode_dac_1.asm</td><td>využití DAC (neočekávané výsledky)</td><td><a href="https://github.com/tisnik/8bit-fame/blob/master/pc-dos/vga_gfx_mode_dac_1.asm">https://github.com/tisnik/8bit-fame/blob/master/pc-dos/vga_gfx_mode_dac_1.asm</a></td></tr>
<tr><td>65</td><td>vga_gfx_mode_dac_2.asm</td><td>využití DAC (očekávané výsledky)</td><td><a href="https://github.com/tisnik/8bit-fame/blob/master/pc-dos/vga_gfx_mode_dac_2.asm">https://github.com/tisnik/8bit-fame/blob/master/pc-dos/vga_gfx_mode_dac_2.asm</a></td></tr>
<tr><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td></tr>
<tr><td>66</td><td>vga_640x480_putpixel.asm</td><td>realizace algoritmu pro vykreslení pixelu v&nbsp;grafickém režimu 640&times;480 pixelů se šestnácti barvami</td><td><a href="https://github.com/tisnik/8bit-fame/blob/master/pc-dos/vga_640x480_putpixel.asm">https://github.com/tisnik/8bit-fame/blob/master/pc-dos/vga_640x480_putpixel.asm</a></td></tr>
<tr><td>67</td><td>vga_320x200_putpixel_1.asm</td><td>realizace algoritmu pro vykreslení pixelu v&nbsp;grafickém režimu 320&times;200 s&nbsp;256 barvami (základní varianta)</td><td><a href="https://github.com/tisnik/8bit-fame/blob/master/pc-dos/vga_320x200_putpixel_1.asm">https://github.com/tisnik/8bit-fame/blob/master/pc-dos/vga_320x200_putpixel_1.asm</a></td></tr>
<tr><td>68</td><td>vga_320x200_putpixel_2.asm</td><td>realizace algoritmu pro vykreslení pixelu v&nbsp;grafickém režimu 320&times;200 s&nbsp;256 barvami (rychlejší varianta)</td><td><a href="https://github.com/tisnik/8bit-fame/blob/master/pc-dos/vga_320x200_putpixel_2.asm">https://github.com/tisnik/8bit-fame/blob/master/pc-dos/vga_320x200_putpixel_2.asm</a></td></tr>
<tr><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td></tr>
<tr><td>69</td><td>vga_gfx_mode_dac_3.asm</td><td>přímé využití DAC v&nbsp;grafickém režimu 13h</td><td><a href="https://github.com/tisnik/8bit-fame/blob/master/pc-dos/vga_gfx_mode_dac_3.asm">https://github.com/tisnik/8bit-fame/blob/master/pc-dos/vga_gfx_mode_dac_3.asm</a></td></tr>
<tr><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td></tr>
<tr><td>70</td><td>vga_gfx_mode_unchained_step_1.asm</td><td>zobrazení barevných pruhů v&nbsp;režimu 13h</td><td><a href="https://github.com/tisnik/8bit-fame/blob/master/pc-dos/vga_gfx_mode_unchained_step_1.asm">https://github.com/tisnik/8bit-fame/blob/master/pc-dos/vga_gfx_mode_unchained_step_1.asm</a></td></tr>
<tr><td>71</td><td>vga_gfx_mode_unchained_step_2.asm</td><td>vypnutí zřetězení bitových rovin a změna způsobu adresování pixelů</td><td><a href="https://github.com/tisnik/8bit-fame/blob/master/pc-dos/vga_gfx_mode_unchained_step_2.asm">https://github.com/tisnik/8bit-fame/blob/master/pc-dos/vga_gfx_mode_unchained_step_2.asm</a></td></tr>
<tr><td>72</td><td>vga_gfx_mode_unchained_step_3.asm</td><td>vykreslení barevných pruhů do vybraných bitových rovin</td><td><a href="https://github.com/tisnik/8bit-fame/blob/master/pc-dos/vga_gfx_mode_unchained_step_3.asm">https://github.com/tisnik/8bit-fame/blob/master/pc-dos/vga_gfx_mode_unchained_step_3.asm</a></td></tr>
<tr><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td></tr>
<tr><td>73</td><td>vga_gfx_mode_320x400.asm</td><td>nestandardní grafický režim s&nbsp;rozlišením 320&times;400 pixelů a 256 barvami</td><td><a href="https://github.com/tisnik/8bit-fame/blob/master/pc-dos/vga_gfx_mode_320x400.asm">https://github.com/tisnik/8bit-fame/blob/master/pc-dos/vga_gfx_mode_320x400.asm</a></td></tr>
<tr><td>74</td><td>vga_320x200_image.asm</td><td>zobrazení rastrového obrázku ve standardním grafickém režimu 320&times;200 pixelů</td><td><a href="https://github.com/tisnik/8bit-fame/blob/master/pc-dos/vga_320x200_image.asm">https://github.com/tisnik/8bit-fame/blob/master/pc-dos/vga_320x200_image.asm</a></td></tr>
<tr><td>75</td><td>vga_320x200_unchained_image_1.asm</td><td>zobrazení rastrového obrázku v&nbsp;režimu s&nbsp;nezřetězenými rovinami (nekorektní řešení)</td><td><a href="https://github.com/tisnik/8bit-fame/blob/master/pc-dos/vga_320x200_unchained_image_1.asm">https://github.com/tisnik/8bit-fame/blob/master/pc-dos/vga_320x200_unchained_image_1.asm</a></td></tr>
<tr><td>76</td><td>vga_320x200_unchained_image_2.asm</td><td>zobrazení rastrového obrázku v&nbsp;režimu s&nbsp;nezřetězenými rovinami (korektní řešení)</td><td><a href="https://github.com/tisnik/8bit-fame/blob/master/pc-dos/vga_320x200_unchained_image_2.asm">https://github.com/tisnik/8bit-fame/blob/master/pc-dos/vga_320x200_unchained_image_2.asm</a></td></tr>
<tr><td>77</td><td>vga_320x400_unchained_image.asm</td><td>zobrazení rastrového obrázku v&nbsp;nestandardním režimu 320&times;400 pixelů</td><td><a href="https://github.com/tisnik/8bit-fame/blob/master/pc-dos/vga_320x400_unchained_image.asm">https://github.com/tisnik/8bit-fame/blob/master/pc-dos/vga_320x400_unchained_image.asm</a></td></tr>
<tr><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td></tr>
<tr><td>78</td><td>vga_vertical_scroll_1.asm</td><td>vertikální scrolling na kartě VGA v&nbsp;režimu s&nbsp;rozlišením 320&times;200 pixelů</td><td><a href="https://github.com/tisnik/8bit-fame/blob/master/pc-dos/vga_vertical_scroll_1.asm">https://github.com/tisnik/8bit-fame/blob/master/pc-dos/vga_vertical_scroll_1.asm</a></td></tr>
<tr><td>79</td><td>vga_vertical_scroll_2.asm</td><td>vertikální scrolling na kartě VGA v&nbsp;režimu s&nbsp;rozlišením 320&times;400 pixelů</td><td><a href="https://github.com/tisnik/8bit-fame/blob/master/pc-dos/vga_vertical_scroll_2.asm">https://github.com/tisnik/8bit-fame/blob/master/pc-dos/vga_vertical_scroll_2.asm</a></td></tr>
<tr><td>80</td><td>vga_split_screen_1.asm</td><td>režim split-screen a scrolling, nefunční varianta</td><td><a href="https://github.com/tisnik/8bit-fame/blob/master/pc-dos/vga_split_screen_1.asm">https://github.com/tisnik/8bit-fame/blob/master/pc-dos/vga_split_screen_1.asm</a></td></tr>
<tr><td>81</td><td>vga_split_screen_2.asm</td><td>režim split-screen a scrolling, plně funkční varianta</td><td><a href="https://github.com/tisnik/8bit-fame/blob/master/pc-dos/vga_split_screen_2.asm">https://github.com/tisnik/8bit-fame/blob/master/pc-dos/vga_split_screen_2.asm</a></td></tr>
<tr><td>82</td><td>vga_horizontal_scroll_1.asm</td><td>horizontální scrolling bez rozšíření počtu pixelů na virtuálním řádku</td><td><a href="https://github.com/tisnik/8bit-fame/blob/master/pc-dos/vga_horizontal_scroll_1.asm">https://github.com/tisnik/8bit-fame/blob/master/pc-dos/vga_horizontal_scroll_1.asm</a></td></tr>
</table>



<p><a name="k20"></a></p>
<h2 id="k20">20. Odkazy na Internetu</h2>

<ol>

<li>VESA BIOS Extensions<br />
<a href="https://en.wikipedia.org/wiki/VESA_BIOS_Extensions">https://en.wikipedia.org/wiki/VESA_BIOS_Extensions</a>
</li>

<li>Video Electronics Standards Association<br />
<a href="https://en.wikipedia.org/wiki/Video_Electronics_Standards_Association">https://en.wikipedia.org/wiki/Video_Electronics_Standards_Association</a>
</li>

<li>DJGPP (Wikipedia)<br />
<a href="https://cs.wikipedia.org/wiki/DJGPP">https://cs.wikipedia.org/wiki/DJGPP</a>
</li>

<li>DJGPP home page<br />
<a href="http://www.delorie.com/djgpp/">http://www.delorie.com/djgpp/</a>
</li>

<li>DJGPP Zip File Picker<br />
<a href="http://www.delorie.com/djgpp/zip-picker.html">http://www.delorie.com/djgpp/zip-picker.html</a>
</li>

<li>The Intel 8088 Architecture and Instruction Set<br />
<a href="https://people.ece.ubc.ca/~edc/464/lectures/lec4.pdf">https://people.ece.ubc.ca/~edc/464/lectures/lec4.pdf</a>
</li>

<li>x86 Opcode Structure and Instruction Overview<br />
<a href="https://pnx.tf/files/x86_opcode_structure_and_instruction_overview.pdf">https://pnx.tf/files/x86_opcode_structure_and_instruction_overview.pdf</a>
</li>

<li>x86 instruction listings (Wikipedia)<br />
<a href="https://en.wikipedia.org/wiki/X86_instruction_listings">https://en.wikipedia.org/wiki/X86_instruction_listings</a>
</li>

<li>x86 assembly language (Wikipedia)<br />
<a href="https://en.wikipedia.org/wiki/X86_assembly_language">https://en.wikipedia.org/wiki/X86_assembly_language</a>
</li>

<li>Intel Assembler (Cheat sheet)<br />
<a href="http://www.jegerlehner.ch/intel/IntelCodeTable.pdf">http://www.jegerlehner.ch/intel/IntelCodeTable.pdf</a>
</li>

<li>25 Microchips That Shook the World<br />
<a href="https://spectrum.ieee.org/tech-history/silicon-revolution/25-microchips-that-shook-the-world">https://spectrum.ieee.org/tech-history/silicon-revolution/25-microchips-that-shook-the-world</a>
</li>

<li>Chip Hall of Fame: MOS Technology 6502 Microprocessor<br />
<a href="https://spectrum.ieee.org/tech-history/silicon-revolution/chip-hall-of-fame-mos-technology-6502-microprocessor">https://spectrum.ieee.org/tech-history/silicon-revolution/chip-hall-of-fame-mos-technology-6502-microprocessor</a>
</li>

<li>Chip Hall of Fame: Intel 8088 Microprocessor<br />
<a href="https://spectrum.ieee.org/tech-history/silicon-revolution/chip-hall-of-fame-intel-8088-microprocessor">https://spectrum.ieee.org/tech-history/silicon-revolution/chip-hall-of-fame-intel-8088-microprocessor</a>
</li>

<li>Jak se zrodil procesor?<br />
<a href="https://www.root.cz/clanky/jak-se-zrodil-procesor/">https://www.root.cz/clanky/jak-se-zrodil-procesor/</a>
</li>

<li>Apple II History Home<br />
<a href="http://apple2history.org/">http://apple2history.org/</a>
</li>

<li>The 8086/8088 Primer<br />
<a href="https://www.stevemorse.org/8086/index.html">https://www.stevemorse.org/8086/index.html</a>
</li>

<li>flat assembler: Assembly language resources<br />
<a href="https://flatassembler.net/">https://flatassembler.net/</a>
</li>

<li>FASM na Wikipedii<br />
<a href="https://en.wikipedia.org/wiki/FASM">https://en.wikipedia.org/wiki/FASM</a>
</li>

<li>Fresh IDE FASM inside<br />
<a href="https://fresh.flatassembler.net/">https://fresh.flatassembler.net/</a>
</li>

<li>MS-DOS Version 4.0 Programmer's Reference<br />
<a href="https://www.pcjs.org/documents/books/mspl13/msdos/dosref40/">https://www.pcjs.org/documents/books/mspl13/msdos/dosref40/</a>
</li>

<li>DOS API (Wikipedia)<br />
<a href="https://en.wikipedia.org/wiki/DOS_API">https://en.wikipedia.org/wiki/DOS_API</a>
</li>

<li>Bit banging<br />
<a href="https://en.wikipedia.org/wiki/Bit_banging">https://en.wikipedia.org/wiki/Bit_banging</a>
</li>

<li>IBM Basic assembly language and successors (Wikipedia)<br />
<a href="https://en.wikipedia.org/wiki/IBM_Basic_assembly_language_and_successors">https://en.wikipedia.org/wiki/IBM_Basic_assembly_language_and_successors</a>
</li>

<li>X86 Assembly/Bootloaders<br />
<a href="https://en.wikibooks.org/wiki/X86_Assembly/Bootloaders">https://en.wikibooks.org/wiki/X86_Assembly/Bootloaders</a>
</li>

<li>Počátky grafiky na PC: grafické karty CGA a Hercules<br />
<a href="https://www.root.cz/clanky/pocatky-grafiky-na-pc-graficke-karty-cga-a-hercules/">https://www.root.cz/clanky/pocatky-grafiky-na-pc-graficke-karty-cga-a-hercules/</a>
</li>

<li>Co mají společného Commodore PET/4000, BBC Micro, Amstrad CPC i grafické karty MDA, CGA a Hercules?<br />
<a href="https://www.root.cz/clanky/co-maji-spolecneho-commodore-pet-4000-bbc-micro-amstrad-cpc-i-graficke-karty-mda-cga-a-hercules/">https://www.root.cz/clanky/co-maji-spolecneho-commodore-pet-4000-bbc-micro-amstrad-cpc-i-graficke-karty-mda-cga-a-hercules/</a>
</li>

<li>Karta EGA: první použitelná barevná grafika na PC<br />
<a href="https://www.root.cz/clanky/karta-ega-prvni-pouzitelna-barevna-grafika-na-pc/">https://www.root.cz/clanky/karta-ega-prvni-pouzitelna-barevna-grafika-na-pc/</a>
</li>

<li>RGB Classic Games<br />
<a href="https://www.classicdosgames.com/">https://www.classicdosgames.com/</a>
</li>

<li>Turbo Assembler (Wikipedia)<br />
<a href="https://en.wikipedia.org/wiki/Turbo_Assembler">https://en.wikipedia.org/wiki/Turbo_Assembler</a>
</li>

<li>Microsoft Macro Assembler<br />
<a href="https://en.wikipedia.org/wiki/Microsoft_Macro_Assembler">https://en.wikipedia.org/wiki/Microsoft_Macro_Assembler</a>
</li>

<li>IBM Personal Computer (Wikipedia)<br />
<a href="https://en.wikipedia.org/wiki/IBM_Personal_Computer">https://en.wikipedia.org/wiki/IBM_Personal_Computer</a>
</li>

<li>Intel 8251<br />
<a href="https://en.wikipedia.org/wiki/Intel_8251">https://en.wikipedia.org/wiki/Intel_8251</a>
</li>

<li>Intel 8253<br />
<a href="https://en.wikipedia.org/wiki/Intel_8253">https://en.wikipedia.org/wiki/Intel_8253</a>
</li>

<li>Intel 8255<br />
<a href="https://en.wikipedia.org/wiki/Intel_8255">https://en.wikipedia.org/wiki/Intel_8255</a>
</li>

<li>Intel 8257<br />
<a href="https://en.wikipedia.org/wiki/Intel_8257">https://en.wikipedia.org/wiki/Intel_8257</a>
</li>

<li>Intel 8259<br />
<a href="https://en.wikipedia.org/wiki/Intel_8259">https://en.wikipedia.org/wiki/Intel_8259</a>
</li>

<li>Support/peripheral/other chips - 6800 family<br />
<a href="http://www.cpu-world.com/Support/6800.html">http://www.cpu-world.com/Support/6800.html</a>
</li>

<li>Motorola 6845<br />
<a href="http://en.wikipedia.org/wiki/Motorola_6845">http://en.wikipedia.org/wiki/Motorola_6845</a>
</li>

<li>The 6845 Cathode Ray Tube Controller (CRTC)<br />
<a href="http://www.tinyvga.com/6845">http://www.tinyvga.com/6845</a>
</li>

<li>CRTC operation<br />
<a href="http://www.6502.org/users/andre/hwinfo/crtc/crtc.html">http://www.6502.org/users/andre/hwinfo/crtc/crtc.html</a>
</li>

<li>The 6845 Cathode Ray Tube Controller (CRTC)<br />
<a href="http://www.tinyvga.com/6845">http://www.tinyvga.com/6845</a>
</li>

<li>Motorola 6845 and bitwise graphics<br />
<a href="https://retrocomputing.stackexchange.com/questions/10996/motorola-6845-and-bitwise-graphics">https://retrocomputing.stackexchange.com/questions/10996/motorola-6845-and-bitwise-graphics</a>
</li>

<li>IBM Monochrome Display Adapter<br />
<a href="http://en.wikipedia.org/wiki/Monochrome_Display_Adapter">http://en.wikipedia.org/wiki/Monochrome_Display_Adapter</a>
</li>

<li>Color Graphics Adapter<br />
<a href="http://en.wikipedia.org/wiki/Color_Graphics_Adapter">http://en.wikipedia.org/wiki/Color_Graphics_Adapter</a>
</li>

<li>Color Graphics Adapter and the Brown color in IBM 5153 Color Display<br />
<a href="https://www.aceinnova.com/en/electronics/cga-and-the-brown-color-in-ibm-5153-color-display/">https://www.aceinnova.com/en/electronics/cga-and-the-brown-color-in-ibm-5153-color-display/</a>
</li>

<li>The Modern Retrocomputer: An Arduino Driven 6845 CRT Controller<br />
<a href="https://hackaday.com/2017/05/14/the-modern-retrocomputer-an-arduino-driven-6845-crt-controller/">https://hackaday.com/2017/05/14/the-modern-retrocomputer-an-arduino-driven-6845-crt-controller/</a>
</li>

<li>flat assembler: Assembly language resources<br />
<a href="https://flatassembler.net/">https://flatassembler.net/</a>
</li>

<li>FASM na Wikipedii<br />
<a href="https://en.wikipedia.org/wiki/FASM">https://en.wikipedia.org/wiki/FASM</a>
</li>

<li>Fresh IDE FASM inside<br />
<a href="https://fresh.flatassembler.net/">https://fresh.flatassembler.net/</a>
</li>

<li>MS-DOS Version 4.0 Programmer's Reference<br />
<a href="https://www.pcjs.org/documents/books/mspl13/msdos/dosref40/">https://www.pcjs.org/documents/books/mspl13/msdos/dosref40/</a>
</li>

<li>DOS API (Wikipedia)<br />
<a href="https://en.wikipedia.org/wiki/DOS_API">https://en.wikipedia.org/wiki/DOS_API</a>
</li>

<li>IBM Basic assembly language and successors (Wikipedia)<br />
<a href="https://en.wikipedia.org/wiki/IBM_Basic_assembly_language_and_successors">https://en.wikipedia.org/wiki/IBM_Basic_assembly_language_and_successors</a>
</li>

<li>X86 Assembly/Arithmetic<br />
<a href="https://en.wikibooks.org/wiki/X86_Assembly/Arithmetic">https://en.wikibooks.org/wiki/X86_Assembly/Arithmetic</a>
</li>

<li>Art of Assembly - Arithmetic Instructions<br />
<a href="http://oopweb.com/Assembly/Documents/ArtOfAssembly/Volume/Chapter_6/CH06-2.html">http://oopweb.com/Assembly/Documents/ArtOfAssembly/Volume/Chapter_6/CH06-2.html</a>
</li>

<li>ASM Flags<br />
<a href="http://www.cavestory.org/guides/csasm/guide/asm_flags.html">http://www.cavestory.org/guides/csasm/guide/asm_flags.html</a>
</li>

<li>Status Register<br />
<a href="https://en.wikipedia.org/wiki/Status_register">https://en.wikipedia.org/wiki/Status_register</a>
</li>

<li>Linux assemblers: A comparison of GAS and NASM<br />
<a href="http://www.ibm.com/developerworks/library/l-gas-nasm/index.html">http://www.ibm.com/developerworks/library/l-gas-nasm/index.html</a>
</li>

<li>Programovani v assembleru na OS Linux<br />
<a href="http://www.cs.vsb.cz/grygarek/asm/asmlinux.html">http://www.cs.vsb.cz/grygarek/asm/asmlinux.html</a>
</li>

<li>Is it worthwhile to learn x86 assembly language today?<br />
<a href="https://www.quora.com/Is-it-worthwhile-to-learn-x86-assembly-language-today?share=1">https://www.quora.com/Is-it-worthwhile-to-learn-x86-assembly-language-today?share=1</a>
</li>

<li>Why Learn Assembly Language?<br />
<a href="http://www.codeproject.com/Articles/89460/Why-Learn-Assembly-Language">http://www.codeproject.com/Articles/89460/Why-Learn-Assembly-Language</a>
</li>

<li>Is Assembly still relevant?<br />
<a href="http://programmers.stackexchange.com/questions/95836/is-assembly-still-relevant">http://programmers.stackexchange.com/questions/95836/is-assembly-still-relevant</a>
</li>

<li>Why Learning Assembly Language Is Still a Good Idea<br />
<a href="http://www.onlamp.com/pub/a/onlamp/2004/05/06/writegreatcode.html">http://www.onlamp.com/pub/a/onlamp/2004/05/06/writegreatcode.html</a>
</li>

<li>Assembly language today<br />
<a href="http://beust.com/weblog/2004/06/23/assembly-language-today/">http://beust.com/weblog/2004/06/23/assembly-language-today/</a>
</li>

<li>Assembler: Význam assembleru dnes<br />
<a href="http://www.builder.cz/rubriky/assembler/vyznam-assembleru-dnes-155960cz">http://www.builder.cz/rubriky/assembler/vyznam-assembleru-dnes-155960cz</a>
</li>

<li>Programming from the Ground Up Book - Summary<br />
<a href="http://savannah.nongnu.org/projects/pgubook/">http://savannah.nongnu.org/projects/pgubook/</a>
</li>

<li>DOSBox<br />
<a href="https://www.dosbox.com/">https://www.dosbox.com/</a>
</li>

<li>The C Programming Language<br />
<a href="https://en.wikipedia.org/wiki/The_C_Programming_Language">https://en.wikipedia.org/wiki/The_C_Programming_Language</a>
</li>

<li>Hercules Graphics Card (HCG)<br />
<a href="https://en.wikipedia.org/wiki/Hercules_Graphics_Card">https://en.wikipedia.org/wiki/Hercules_Graphics_Card</a>
</li>

<li>Complete 8086 instruction set<br />
<a href="https://content.ctcd.edu/courses/cosc2325/m22/docs/emu8086ins.pdf">https://content.ctcd.edu/courses/cosc2325/m22/docs/emu8086ins.pdf</a>
</li>

<li>Complete 8086 instruction set<br />
<a href="https://yassinebridi.github.io/asm-docs/8086_instruction_set.html">https://yassinebridi.github.io/asm-docs/8086_instruction_set.html</a>
</li>

<li>8088 MPH by Hornet + CRTC + DESiRE (final version)<br />
<a href="https://www.youtube.com/watch?v=hNRO7lno_DM">https://www.youtube.com/watch?v=hNRO7lno_DM</a>
</li>

<li>Area 5150 by CRTC &amp; Hornet (Party Version) / IBM PC+CGA Demo, Hardware Capture<br />
<a href="https://www.youtube.com/watch?v=fWDxdoRTZPc">https://www.youtube.com/watch?v=fWDxdoRTZPc</a>
</li>

<li>80x86 Integer Instruction Set Timings (8088 - Pentium)<br />
<a href="http://aturing.umcs.maine.edu/~meadow/courses/cos335/80x86-Integer-Instruction-Set-Clocks.pdf">http://aturing.umcs.maine.edu/~meadow/courses/cos335/80x86-Integer-Instruction-Set-Clocks.pdf</a>
</li>

<li>Colour Graphics Adapter: Notes<br />
<a href="https://www.seasip.info/VintagePC/cga.html">https://www.seasip.info/VintagePC/cga.html</a>
</li>

<li>Restoring A Vintage CGA Card With Homebrew HASL<br />
<a href="https://hackaday.com/2024/06/12/restoring-a-vintage-cga-card-with-homebrew-hasl/">https://hackaday.com/2024/06/12/restoring-a-vintage-cga-card-with-homebrew-hasl/</a>
</li>

<li>Demoing An 8088<br />
<a href="https://hackaday.com/2015/04/10/demoing-an-8088/">https://hackaday.com/2015/04/10/demoing-an-8088/</a>
</li>

<li>Video Memory Layouts<br />
<a href="http://www.techhelpmanual.com/89-video_memory_layouts.html">http://www.techhelpmanual.com/89-video_memory_layouts.html</a>
</li>

<li>Screen Attributes<br />
<a href="http://www.techhelpmanual.com/87-screen_attributes.html">http://www.techhelpmanual.com/87-screen_attributes.html</a>
</li>

<li>IBM PC Family  -  BIOS Video Modes<br />
<a href="https://www.minuszerodegrees.net/video/bios_video_modes.htm">https://www.minuszerodegrees.net/video/bios_video_modes.htm</a>
</li>

<li>EGA Functions<br />
<a href="https://cosmodoc.org/topics/ega-functions/#the-hierarchy-of-the-ega">https://cosmodoc.org/topics/ega-functions/#the-hierarchy-of-the-ega</a>
</li>

<li>Why the EGA can only use 16 of its 64 colours in 200-line modes<br />
<a href="https://www.reenigne.org/blog/why-the-ega-can-only-use-16-of-its-64-colours-in-200-line-modes/">https://www.reenigne.org/blog/why-the-ega-can-only-use-16-of-its-64-colours-in-200-line-modes/</a>
</li>

<li>How 16 colors saved PC gaming - the story of EGA graphics<br />
<a href="https://www.custompc.com/retro-tech/ega-graphics">https://www.custompc.com/retro-tech/ega-graphics</a>
</li>

<li>List of 16-bit computer color palettes<br />
<a href="https://en.wikipedia.org/wiki/List_of_16-bit_computer_color_palettes">https://en.wikipedia.org/wiki/List_of_16-bit_computer_color_palettes</a>
</li>

<li>Why were those colors chosen to be the default palette for 256-color VGA?<br />
<a href="https://retrocomputing.stackexchange.com/questions/27994/why-were-those-colors-chosen-to-be-the-default-palette-for-256-color-vga">https://retrocomputing.stackexchange.com/questions/27994/why-were-those-colors-chosen-to-be-the-default-palette-for-256-color-vga</a>
</li>

<li>VGA Color Palettes<br />
<a href="https://www.fountainware.com/EXPL/vga_color_palettes.htm">https://www.fountainware.com/EXPL/vga_color_palettes.htm</a>
</li>

<li>Hardware Level VGA and SVGA Video Programming Information Page<br />
<a href="http://www.osdever.net/FreeVGA/vga/vga.htm">http://www.osdever.net/FreeVGA/vga/vga.htm</a>
</li>

<li>Hardware Level VGA and SVGA Video Programming Information Page - sequencer<br />
<a href="http://www.osdever.net/FreeVGA/vga/seqreg.htm">http://www.osdever.net/FreeVGA/vga/seqreg.htm</a>
</li>

<li>VGA Basics<br />
<a href="http://www.brackeen.com/vga/basics.html">http://www.brackeen.com/vga/basics.html</a>
</li>

<li>Introduction to VGA Mode 'X'<br />
<a href="https://web.archive.org/web/20160414072210/http://fly.srk.fer.hr/GDM/articles/vgamodex/vgamx1.html">https://web.archive.org/web/20160414072210/http://fly.srk.fer.hr/GDM/articles/vgamodex/vgamx1.html</a>
</li>

<li>VGA Mode-X<br />
<a href="https://web.archive.org/web/20070123192523/http://www.gamedev.net/reference/articles/article356.asp">https://web.archive.org/web/20070123192523/http://www.gamedev.net/reference/articles/article356.asp</a>
</li>

<li>Mode-X: 256-Color VGA Magic<br />
<a href="https://downloads.gamedev.net/pdf/gpbb/gpbb47.pdf">https://downloads.gamedev.net/pdf/gpbb/gpbb47.pdf</a>
</li>

<li>Instruction Format in 8086 Microprocessor<br />
<a href="https://www.includehelp.com/embedded-system/instruction-format-in-8086-microprocessor.aspx">https://www.includehelp.com/embedded-system/instruction-format-in-8086-microprocessor.aspx</a>
</li>

<li>How to use "AND," "OR," and "XOR" modes for VGA Drawing<br />
<a href="https://retrocomputing.stackexchange.com/questions/21936/how-to-use-and-or-and-xor-modes-for-vga-drawing">https://retrocomputing.stackexchange.com/questions/21936/how-to-use-and-or-and-xor-modes-for-vga-drawing</a>
</li>

<li>VGA Hardware<br />
<a href="https://wiki.osdev.org/VGA_Hardware">https://wiki.osdev.org/VGA_Hardware</a>
</li>

<li>Programmer's Guide to Yamaha YMF 262/OPL3 FM Music Synthesizer<br />
<a href="https://moddingwiki.shikadi.net/wiki/OPL_chip">https://moddingwiki.shikadi.net/wiki/OPL_chip</a>
</li>

<li>Does anybody understand how OPL2 percussion mode works?<br />
<a href="https://forum.vcfed.org/index.php?threads/does-anybody-understand-how-opl2-percussion-mode-works.60925/">https://forum.vcfed.org/index.php?threads/does-anybody-understand-how-opl2-percussion-mode-works.60925/</a>
</li>

<li>Yamaha YMF262 OPL3 music - MoonDriver for OPL3 DEMO [Oscilloscope View]<br />
<a href="https://www.youtube.com/watch?v=a7I-QmrkAak">https://www.youtube.com/watch?v=a7I-QmrkAak</a>
</li>

<li>Yamaha OPL vs OPL2 vs OPL3 comparison<br />
<a href="https://www.youtube.com/watch?v=5knetge5Gs0">https://www.youtube.com/watch?v=5knetge5Gs0</a>
</li>

<li>OPL3 Music Crockett's Theme<br />
<a href="https://www.youtube.com/watch?v=HXS008pkgSQ">https://www.youtube.com/watch?v=HXS008pkgSQ</a>
</li>

<li>Bad Apple (Adlib Tracker - OPL3)<br />
<a href="https://www.youtube.com/watch?v=2lEPH6Y3Luo">https://www.youtube.com/watch?v=2lEPH6Y3Luo</a>
</li>

<li>FM Synthesis Chips, Codecs and DACs<br />
<a href="https://www.dosdays.co.uk/topics/fm_synthesizers.php">https://www.dosdays.co.uk/topics/fm_synthesizers.php</a>
</li>

<li>The Zen Challenge - YMF262 OPL3 Original (For an upcoming game)<br />
<a href="https://www.youtube.com/watch?v=6JlFIFz1CFY">https://www.youtube.com/watch?v=6JlFIFz1CFY</a>
</li>

<li>[adlib tracker II techno music - opl3] orbit around alpha andromedae I<br />
<a href="https://www.youtube.com/watch?v=YqxJCu_WFuA">https://www.youtube.com/watch?v=YqxJCu_WFuA</a>
</li>

<li>[adlib tracker 2 music - opl3 techno] hybridisation process on procyon-ii<br />
<a href="https://www.youtube.com/watch?v=daSV5mN0sJ4">https://www.youtube.com/watch?v=daSV5mN0sJ4</a>
</li>

<li>Hyper Duel - Black Rain (YMF262 OPL3 Cover)<br />
<a href="https://www.youtube.com/watch?v=pu_mzRRq8Ho">https://www.youtube.com/watch?v=pu_mzRRq8Ho</a>
</li>

<li>IBM 5155-5160 Technical Reference<br />
<a href="https://www.minuszerodegrees.net/manuals/IBM/IBM_5155_5160_Technical_Reference_6280089_MAR86.pdf">https://www.minuszerodegrees.net/manuals/IBM/IBM_5155_5160_Technical_Reference_6280089_MAR86.pdf</a>
</li>

<li>a ymf262/opl3+pc speaker thing i made<br />
<a href="https://www.youtube.com/watch?v=E-Mx0lEmnZ0">https://www.youtube.com/watch?v=E-Mx0lEmnZ0</a>
</li>

<li>[OPL3] Like a Thunder<br />
<a href="https://www.youtube.com/watch?v=MHf06AGr8SU">https://www.youtube.com/watch?v=MHf06AGr8SU</a>
</li>

<li>(PC SPEAKER) bad apple<br />
<a href="https://www.youtube.com/watch?v=LezmKIIHyUg">https://www.youtube.com/watch?v=LezmKIIHyUg</a>
</li>

<li>Powering devices from PC parallel port<br />
<a href="http://www.epanorama.net/circuits/lptpower.html">http://www.epanorama.net/circuits/lptpower.html</a>
</li>

<li>Magic Mushroom (demo pro PC s DOSem)<br />
<a href="http://www.crossfire-designs.de/download/articles/soundcards//mushroom.rar">http://www.crossfire-designs.de/download/articles/soundcards//mushroom.rar</a>
</li>

<li>Píseň Magic Mushroom - originál<br />
<a href="http://www.crossfire-designs.de/download/articles/soundcards/speaker_mushroom_converted.mp3">http://www.crossfire-designs.de/download/articles/soundcards/speaker_mushroom_converted.mp3</a>
</li>

<li>Píseň Magic Mushroom - hráno na PC Speakeru<br />
<a href="http://www.crossfire-designs.de/download/articles/soundcards/speaker_mushroom_speaker.mp3">http://www.crossfire-designs.de/download/articles/soundcards/speaker_mushroom_speaker.mp3</a>
</li>

<li>Pulse Width Modulation (PWM) Simulation Example<br />
<a href="http://decibel.ni.com/content/docs/DOC-4599">http://decibel.ni.com/content/docs/DOC-4599</a>
</li>

<li>Resistor/Pulse Width Modulation DAC<br />
<a href="http://www.k9spud.com/traxmod/pwmdac.php">http://www.k9spud.com/traxmod/pwmdac.php</a>
</li>

<li>Class D Amplifier<br />
<a href="http://en.wikipedia.org/wiki/Electronic_amplifier#Class_D">http://en.wikipedia.org/wiki/Electronic_amplifier#Class_D</a>
</li>

<li>Covox Speech Thing / Disney Sound Source (1986)<br />
<a href="http://www.crossfire-designs.de/index.php?lang=en&amp;what=articles&amp;name=showarticle.htm&amp;article=soundcards/&amp;page=5">http://www.crossfire-designs.de/index.php?lang=en&amp;what=articles&amp;name=showarticle.htm&amp;article=soundcards/&amp;page=5</a>
</li>

<li>Covox Digital-Analog Converter (Rusky, obsahuje schémata)<br />
<a href="http://phantom.sannata.ru/konkurs/netskater002.shtml">http://phantom.sannata.ru/konkurs/netskater002.shtml</a>
</li>

<li>PC-GPE on the Web<br />
<a href="http://bespin.org/~qz/pc-gpe/">http://bespin.org/~qz/pc-gpe/</a>
</li>

<li>Keyboard Synthesizer<br />
<a href="http://www.solarnavigator.net/music/instruments/keyboards.htm">http://www.solarnavigator.net/music/instruments/keyboards.htm</a>
</li>

<li>FMS - Fully Modular Synthesizer<br />
<a href="http://fmsynth.sourceforge.net/">http://fmsynth.sourceforge.net/</a>
</li>

<li>Javasynth<br />
<a href="http://javasynth.sourceforge.net/">http://javasynth.sourceforge.net/</a>
</li>

<li>Software Sound Synthesis &amp; Music Composition Packages<br />
<a href="http://www.linux-sound.org/swss.html">http://www.linux-sound.org/swss.html</a>
</li>

<li>Mx44.1 Download Page (software synthesizer for linux)<br />
<a href="http://hem.passagen.se/ja_linux/">http://hem.passagen.se/ja_linux/</a>
</li>

<li>Software synthesizer<br />
<a href="http://en.wikipedia.org/wiki/Software_synthesizer">http://en.wikipedia.org/wiki/Software_synthesizer</a>
</li>

<li>Frequency modulation synthesis<br />
<a href="http://en.wikipedia.org/wiki/Frequency_modulation_synthesis">http://en.wikipedia.org/wiki/Frequency_modulation_synthesis</a>
</li>

<li>Yamaha DX7<br />
<a href="http://en.wikipedia.org/wiki/Yamaha_DX7">http://en.wikipedia.org/wiki/Yamaha_DX7</a>
</li>

<li>Wave of the Future<br />
<a href="http://www.wired.com/wired/archive/2.03/waveguides_pr.html">http://www.wired.com/wired/archive/2.03/waveguides_pr.html</a>
</li>

<li>Analog synthesizer<br />
<a href="http://en.wikipedia.org/wiki/Analog_synthesizer">http://en.wikipedia.org/wiki/Analog_synthesizer</a>
</li>

<li>Minimoog<br />
<a href="http://en.wikipedia.org/wiki/Minimoog">http://en.wikipedia.org/wiki/Minimoog</a>
</li>

<li>Moog synthesizer<br />
<a href="http://en.wikipedia.org/wiki/Moog_synthesizer">http://en.wikipedia.org/wiki/Moog_synthesizer</a>
</li>

<li>Tutorial for Frequency Modulation Synthesis<br />
<a href="http://www.sfu.ca/~truax/fmtut.html">http://www.sfu.ca/~truax/fmtut.html</a>
</li>

<li>An Introduction To FM<br />
<a href="http://ccrma.stanford.edu/software/snd/snd/fm.html">http://ccrma.stanford.edu/software/snd/snd/fm.html</a>
</li>

<li>John Chowning<br />
<a href="http://en.wikipedia.org/wiki/John_Chowning">http://en.wikipedia.org/wiki/John_Chowning</a>
</li>

<li>I'm Impressed, Adlib Music is AMAZING!<br />
<a href="https://www.youtube.com/watch?v=PJNjQYp1ras">https://www.youtube.com/watch?v=PJNjQYp1ras</a>
</li>

<li>Milinda- Diode Milliampere ( OPL3 )<br />
<a href="https://www.youtube.com/watch?v=oNhazT5HG0E">https://www.youtube.com/watch?v=oNhazT5HG0E</a>
</li>

<li>Dune 2 - Roland MT-32 Soundtrack <br />
<a href="https://www.youtube.com/watch?v=kQADZeB-z8M">https://www.youtube.com/watch?v=kQADZeB-z8M</a>
</li>

<li>Interrupts<br />
<a href="https://wiki.osdev.org/Interrupts#Types_of_Interrupts">https://wiki.osdev.org/Interrupts#Types_of_Interrupts</a>
</li>

<li>Assembly8086SoundBlasterDmaSingleCycleMode<br />
<a href="https://github.com/leonardo-ono/Assembly8086SoundBlasterDmaSingleCycleMode/blob/master/sbsc.asm">https://github.com/leonardo-ono/Assembly8086SoundBlasterDmaSingleCycleMode/blob/master/sbsc.asm</a>
</li>

<li>Interrupts in 8086 microprocessor<br />
<a href="https://www.geeksforgeeks.org/interrupts-in-8086-microprocessor/">https://www.geeksforgeeks.org/interrupts-in-8086-microprocessor/</a>
</li>

<li>Interrupt Structure of 8086<br />
<a href="https://www.eeeguide.com/interrupt-structure-of-8086/">https://www.eeeguide.com/interrupt-structure-of-8086/</a>
</li>

<li>A20 line<br />
<a href="https://en.wikipedia.org/wiki/A20_line">https://en.wikipedia.org/wiki/A20_line</a>
</li>

<li>Extended memory<br />
<a href="https://en.wikipedia.org/wiki/Extended_memory#eXtended_Memory_Specification_(XMS)">https://en.wikipedia.org/wiki/Extended_memory#eXtended_Memory_Specification_(XMS)</a>
</li>

<li>Expanded memory<br />
<a href="https://en.wikipedia.org/wiki/Expanded_memory">https://en.wikipedia.org/wiki/Expanded_memory</a>
</li>

<li>Protected mode<br />
<a href="https://en.wikipedia.org/wiki/Protected_mode">https://en.wikipedia.org/wiki/Protected_mode</a>
</li>

<li>Virtual 8086 mode<br />
<a href="https://en.wikipedia.org/wiki/Virtual_8086_mode">https://en.wikipedia.org/wiki/Virtual_8086_mode</a>
</li>

<li>Unreal mode<br />
<a href="https://en.wikipedia.org/wiki/Unreal_mode">https://en.wikipedia.org/wiki/Unreal_mode</a>
</li>

<li>DOS memory management<br />
<a href="https://en.wikipedia.org/wiki/DOS_memory_management">https://en.wikipedia.org/wiki/DOS_memory_management</a>
</li>

<li>Upper memory area<br />
<a href="https://en.wikipedia.org/wiki/Upper_memory_area">https://en.wikipedia.org/wiki/Upper_memory_area</a>
</li>

<li>Removing the Mystery from SEGMENT : OFFSET Addressing<br />
<a href="https://thestarman.pcministry.com/asm/debug/Segments.html">https://thestarman.pcministry.com/asm/debug/Segments.html</a>
</li>

<li>Segment descriptor<br />
<a href="https://en.wikipedia.org/wiki/Segment_descriptor">https://en.wikipedia.org/wiki/Segment_descriptor</a>
</li>

<li>When using a 32-bit register to address memory in the real mode, contents of the register must never exceed 0000FFFFH. Why?<br />
<a href="https://stackoverflow.com/questions/45094696/when-using-a-32-bit-register-to-address-memory-in-the-real-mode-contents-of-the">https://stackoverflow.com/questions/45094696/when-using-a-32-bit-register-to-address-memory-in-the-real-mode-contents-of-the</a>
</li>

<li>A Brief History of Unreal Mode<br />
<a href="https://www.os2museum.com/wp/a-brief-history-of-unreal-mode/">https://www.os2museum.com/wp/a-brief-history-of-unreal-mode/</a>
</li>

<li>Segment Limits<br />
<a href="https://wiki.osdev.org/Segment_Limits">https://wiki.osdev.org/Segment_Limits</a>
</li>

<li>How do 32 bit addresses in real mode work?<br />
<a href="https://forum.osdev.org/viewtopic.php?t=30642">https://forum.osdev.org/viewtopic.php?t=30642</a>
</li>

<li>The LOADALL Instruction by Robert Collins<br />
<a href="https://www.rcollins.org/articles/loadall/tspec_a3_doc.html">https://www.rcollins.org/articles/loadall/tspec_a3_doc.html</a>
</li>

<li>How do you put a 286 in Protected Mode?<br />
<a href="https://retrocomputing.stackexchange.com/questions/7683/how-do-you-put-a-286-in-protected-mode">https://retrocomputing.stackexchange.com/questions/7683/how-do-you-put-a-286-in-protected-mode</a>
</li>

<li>Control register<br />
<a href="https://en.wikipedia.org/wiki/Control_register">https://en.wikipedia.org/wiki/Control_register</a>
</li>

<li>CPU Registers x86<br />
<a href="https://wiki.osdev.org/CPU_Registers_x86">https://wiki.osdev.org/CPU_Registers_x86</a>
</li>

<li>x86 Assembly/Protected Mode<br />
<a href="https://en.wikibooks.org/wiki/X86_Assembly/Protected_Mode">https://en.wikibooks.org/wiki/X86_Assembly/Protected_Mode</a>
</li>

<li>MSW: Machine Status Word<br />
<a href="https://web.itu.edu.tr/kesgin/mul06/intel/intel_msw.html">https://web.itu.edu.tr/kesgin/mul06/intel/intel_msw.html</a>
</li>

<li>80x87 Floating Point Opcodes<br />
<a href="http://www.techhelpmanual.com/876-80x87_floating_point_opcodes.html">http://www.techhelpmanual.com/876-80x87_floating_point_opcodes.html</a>
</li>

<li>Page Translation<br />
<a href="https://pdos.csail.mit.edu/6.828/2005/readings/i386/s05_02.htm">https://pdos.csail.mit.edu/6.828/2005/readings/i386/s05_02.htm</a>
</li>

<li>80386 Paging and Segmenation<br />
<a href="https://stackoverflow.com/questions/38229741/80386-paging-and-segmenation">https://stackoverflow.com/questions/38229741/80386-paging-and-segmenation</a>
</li>

<li>80386 Memory Management<br />
<a href="https://tldp.org/LDP/khg/HyperNews/get/memory/80386mm.html">https://tldp.org/LDP/khg/HyperNews/get/memory/80386mm.html</a>
</li>

<li>DOSEMU<br />
<a href="http://www.dosemu.org/">http://www.dosemu.org/</a>
</li>

<li>Intel 80386, a revolutionary CPU<br />
<a href="https://www.xtof.info/intel80386.html">https://www.xtof.info/intel80386.html</a>
</li>

<li>PAI Unit 3 Paging in 80386 Microporcessor<br />
<a href="https://www.slideshare.net/KanchanPatil34/pai-unit-3-paging-in-80386-microporcessor">https://www.slideshare.net/KanchanPatil34/pai-unit-3-paging-in-80386-microporcessor</a>
</li>

<li>64 Terabytes of virtual memory for 32-bit x86 using segmentation: how?<br />
<a href="https://stackoverflow.com/questions/5444984/64-terabytes-of-virtual-memory-for-32-bit-x86-using-segmentation-how">https://stackoverflow.com/questions/5444984/64-terabytes-of-virtual-memory-for-32-bit-x86-using-segmentation-how</a>
</li>

<li>Pi in the Pentium: reverse-engineering the constants in its floating-point unit<br />
<a href="http://www.righto.com/2025/01/pentium-floating-point-ROM.html">http://www.righto.com/2025/01/pentium-floating-point-ROM.html</a>
</li>

<li>Simply FPU<br />
<a href="http://www.website.masmforum.com/tutorials/fptute/">http://www.website.masmforum.com/tutorials/fptute/</a>
</li>

<li>Art of Assembly language programming: The 80x87 Floating Point Coprocessors<br />
<a href="https://courses.engr.illinois.edu/ece390/books/artofasm/CH14/CH14-3.html">https://courses.engr.illinois.edu/ece390/books/artofasm/CH14/CH14-3.html</a>
</li>

<li>Art of Assembly language programming: The FPU Instruction Set<br />
<a href="https://courses.engr.illinois.edu/ece390/books/artofasm/CH14/CH14-4.html">https://courses.engr.illinois.edu/ece390/books/artofasm/CH14/CH14-4.html</a>
</li>

<li>INTEL 80387 PROGRAMMER'S REFERENCE MANUAL<br />
<a href="http://www.ragestorm.net/downloads/387intel.txt">http://www.ragestorm.net/downloads/387intel.txt</a>
</li>

<li>x86 Instruction Set Reference: FLD<br />
<a href="http://x86.renejeschke.de/html/file_module_x86_id_100.html">http://x86.renejeschke.de/html/file_module_x86_id_100.html</a>
</li>

<li>x86 Instruction Set Reference: FLD1/FLDL2T/FLDL2E/FLDPI/FLDLG2/FLDLN2/FLDZ<br />
<a href="http://x86.renejeschke.de/html/file_module_x86_id_101.html">http://x86.renejeschke.de/html/file_module_x86_id_101.html</a>
</li>

<li>X86 Assembly/Arithmetic<br />
<a href="https://en.wikibooks.org/wiki/X86_Assembly/Arithmetic">https://en.wikibooks.org/wiki/X86_Assembly/Arithmetic</a>
</li>

<li>8087 Numeric Data Processor<br />
<a href="https://www.eeeguide.com/8087-numeric-data-processor/">https://www.eeeguide.com/8087-numeric-data-processor/</a>
</li>

<li>Data Types and Instruction Set of 8087 co-processor<br />
<a href="https://www.eeeguide.com/data-types-and-instruction-set-of-8087-co-processor/">https://www.eeeguide.com/data-types-and-instruction-set-of-8087-co-processor/</a>
</li>

<li>8087 instruction set and examples<br />
<a href="https://studylib.net/doc/5625221/8087-instruction-set-and-examples">https://studylib.net/doc/5625221/8087-instruction-set-and-examples</a>
</li>

<li>GCC documentation: Extensions to the C Language Family<br />
<a href="https://gcc.gnu.org/onlinedocs/gcc/C-Extensions.html#C-Extensions">https://gcc.gnu.org/onlinedocs/gcc/C-Extensions.html#C-Extensions</a>
</li>

<li>GCC documentation: Using Vector Instructions through Built-in Functions<br />
<a href="https://gcc.gnu.org/onlinedocs/gcc/Vector-Extensions.html">https://gcc.gnu.org/onlinedocs/gcc/Vector-Extensions.html</a>
</li>

<li>SSE (Streaming SIMD Extentions)<br />
<a href="http://www.songho.ca/misc/sse/sse.html">http://www.songho.ca/misc/sse/sse.html</a>
</li>

<li>Timothy A. Chagnon: SSE and SSE2<br />
<a href="http://www.cs.drexel.edu/~tc365/mpi-wht/sse.pdf">http://www.cs.drexel.edu/~tc365/mpi-wht/sse.pdf</a>
</li>

<li>Intel corporation: Extending the Worldr's Most Popular Processor Architecture<br />
<a href="http://download.intel.com/technology/architecture/new-instructions-paper.pdf">http://download.intel.com/technology/architecture/new-instructions-paper.pdf</a>
</li>

<li>SIMD architectures:<br />
<a href="http://arstechnica.com/old/content/2000/03/simd.ars/">http://arstechnica.com/old/content/2000/03/simd.ars/</a>
</li>

<li>Tour of the Black Holes of Computing!: Floating Point<br />
<a href="http://www.cs.hmc.edu/~geoff/classes/hmc.cs105.../slides/class02_floats.ppt">http://www.cs.hmc.edu/~geoff/classes/hmc.cs105.../slides/class02_floats.ppt</a>
</li>

<li>3Dnow! Technology Manual<br />
AMD Inc., 2000</li>

<li>Intel MMX<sup>TM</sup> Technology Overview<br />
Intel corporation, 1996</li>

<li>MultiMedia eXtensions<br />
<a href="http://softpixel.com/~cwright/programming/simd/mmx.php">http://softpixel.com/~cwright/programming/simd/mmx.php</a>i
</li>

<li>AMD K5 ("K5" / "5k86")<br />
<a href="http://www.pcguide.com/ref/cpu/fam/g5K5-c.html">http://www.pcguide.com/ref/cpu/fam/g5K5-c.html</a>
</li>

<li>Sixth Generation Processors<br />
<a href="http://www.pcguide.com/ref/cpu/fam/g6.htm">http://www.pcguide.com/ref/cpu/fam/g6.htm</a>
</li>

<li>Great Microprocessors of the Past and Present<br />
<a href="http://www.cpushack.com/CPU/cpu1.html">http://www.cpushack.com/CPU/cpu1.html</a>
</li>

<li>Very long instruction word (Wikipedia)<br />
<a href="http://en.wikipedia.org/wiki/Very_long_instruction_word">http://en.wikipedia.org/wiki/Very_long_instruction_word</a>
</li>

<li>CPU design (Wikipedia)<br />
<a href="http://en.wikipedia.org/wiki/CPU_design">http://en.wikipedia.org/wiki/CPU_design</a>
</li>

<li>Grafické karty a grafické akcelerátory (14)<br />
<a href="https://www.root.cz/clanky/graficke-karty-a-graficke-akceleratory-14/">https://www.root.cz/clanky/graficke-karty-a-graficke-akceleratory-14/</a>
</li>

<li>Grafické karty a grafické akcelerátory (15)<br />
<a href="https://www.root.cz/clanky/graficke-karty-a-graficke-akceleratory-15/">https://www.root.cz/clanky/graficke-karty-a-graficke-akceleratory-15/</a>
</li>

<li>Grafické karty a grafické akcelerátory (16)<br />
<a href="https://www.root.cz/clanky/graficke-karty-a-graficke-akceleratory-16/">https://www.root.cz/clanky/graficke-karty-a-graficke-akceleratory-16/</a>
</li>

<li>VESA Video Modes<br />
<a href="https://wiki.osdev.org/VESA_Video_Modes">https://wiki.osdev.org/VESA_Video_Modes</a>
</li>

<li>Introduction to VESA programming<br />
<a href="http://www.monstersoft.com/tutorial1/VESA_intro.html">http://www.monstersoft.com/tutorial1/VESA_intro.html</a>
</li>

<li>Guide: VBE 2.0 graphics modes<br />
<a href="https://delorie.com/djgpp/doc/ug/graphics/vbe20.html">https://delorie.com/djgpp/doc/ug/graphics/vbe20.html</a>
</li>

<li>NASM instruction list<br />
<a href="https://userpages.cs.umbc.edu/chang/cs313/nasmdoc/html/nasmdocb.html">https://userpages.cs.umbc.edu/chang/cs313/nasmdoc/html/nasmdocb.html</a>
</li>

<li>BitBlt function (wingdi.h)<br />
<a href="https://learn.microsoft.com/en-us/windows/win32/api/wingdi/nf-wingdi-bitblt">https://learn.microsoft.com/en-us/windows/win32/api/wingdi/nf-wingdi-bitblt</a>
</li>

<li>SetDIBitsToDevice function (wingdi.h)<br />
<a href="https://learn.microsoft.com/en-us/windows/win32/api/wingdi/nf-wingdi-setdibitstodevice">https://learn.microsoft.com/en-us/windows/win32/api/wingdi/nf-wingdi-setdibitstodevice</a>
</li>

<li>Why did line printers have 132 columns?<br />
<a href="https://retrocomputing.stackexchange.com/questions/7838/why-did-line-printers-have-132-columns">https://retrocomputing.stackexchange.com/questions/7838/why-did-line-printers-have-132-columns</a>
</li>

<li>Tabulating machine<br />
<a href="https://en.wikipedia.org/wiki/Tabulating_machine">https://en.wikipedia.org/wiki/Tabulating_machine</a>
</li>

<li>Why do printers print 132 columns on 14 7/8″ paper? It’s history<br />
<a href="https://blog.adafruit.com/2019/01/22/why-do-printers-print-132-columns-on-14-7-8-paper-its-history-vintagecomputing-kenshirriff-ibm/">https://blog.adafruit.com/2019/01/22/why-do-printers-print-132-columns-on-14-7-8-paper-its-history-vintagecomputing-kenshirriff-ibm/</a>
</li>

<li>IBM 1403 (Wikipedia)<br />
<a href="https://en.wikipedia.org/wiki/IBM_1403">https://en.wikipedia.org/wiki/IBM_1403</a>
</li>

</ol>



<p></p><p></p>
<p><small>Autor: <a href="https://github.com/tisnik/">Pavel Tišnovský</a> &nbsp; 2025</small></p>
</body>
</html>

