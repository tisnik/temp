<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
        "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html>
<head>
<title>Struktura obrazové paměti grafické karty CGA, blokové přenosy a základy optimalizace</title>
<meta name="Author" content="Pavel Tisnovsky" />
<meta name="Generator" content="vim" />
<meta http-equiv="content-type" content="text/html; charset=utf-8" />
<style type="text/css">
         body {color:#000000; background:#ffffff;}
         h1  {font-family: arial, helvetica, sans-serif; color:#ffffff; background-color:#c00000; text-align:center; padding-left:1em}
         h2  {font-family: arial, helvetica, sans-serif; color:#ffffff; background-color:#0000c0; padding-left:1em; text-align:left}
         h3  {font-family: arial, helvetica, sans-serif; color:#000000; background-color:#c0c0c0; padding-left:1em; text-align:left}
         h4  {font-family: arial, helvetica, sans-serif; color:#000000; background-color:#e0e0e0; padding-left:1em; text-align:left}
         a   {font-family: arial, helvetica, sans-serif;}
         li  {font-family: arial, helvetica, sans-serif; color:#000000; text-align:justify; width:450px;}
         ol  {font-family: arial, helvetica, sans-serif; color:#000000; text-align:justify; width:450px;}
         ul  {font-family: arial, helvetica, sans-serif; color:#000000; text-align:justify; width:450px;}
         p   {font-family: arial, helvetica, sans-serif; color:#000000; text-align:justify;}
         pre {background:#e0e0e0}
</style>
</head>

<body>

<h1>Struktura obrazové paměti grafické karty CGA, blokové přenosy a základy optimalizace</h1>

<h3>Pavel Tišnovský</h3>

<p></p>

<h1>Úvodník</h1>

<p>Ve třetím článku o programování her a grafických dem pro osobní mikropočítač IBM PC se "slavnou" kartou CGA se zaměříme na důležité nízkoúrovňové operace: přístup do obrazové paměti, využití vertikálního zatemnění pro vykreslování a použití blokových instrukcí pro zápis i přenos dat.</p>



<h2>Obsah</h2>

<p><a href="#k01">1. Struktura obrazové paměti grafické karty CGA, blokové přenosy a základy optimalizace</a></p>
<p><a href="#k02">2. Vyplnění obrazovky konstantní barvou, naivní varianta</a></p>
<p><a href="#k03">3. Úplný zdrojový kód prvního demonstračního příkladu</a></p>
<p><a href="#k04">4. Programová smyčka realizovaná instrukcí <strong>LOOP</strong></a></p>
<p><a href="#k05">5. Použití instrukce <strong>REP STOSB</strong></a></p>
<p><a href="#k06">6. Úplný zdrojový kód třetího demonstračního příkladu</a></p>
<p><a href="#k07">7. Porovnání rychlosti tří variant vyplnění obrazovky bílou barvou</a></p>
<p><a href="#k08">8. Synchronizace zápisu na obrazovku s&nbsp;vertikálním synchronizačním pulsem</a></p>
<p><a href="#k09">9. Úplný zdrojový kód čtvrtého demonstračního příkladu</a></p>
<p><a href="#k10">10. Odvození snímkové frekvence na základě trvání vyplnění obrazu</a></p>
<p><a href="#k11">11. Vykreslení rastrového obrázku získaného z&nbsp;binárních dat</a></p>
<p><a href="#k12">12. Úplný zdrojový kód pátého demonstračního příkladu</a></p>
<p><a href="#k13">13. Blokový přenos dat operací <strong>REP MOSVB</strong> či <strong>REP MOVSW</strong></a></p>
<p><a href="#k14">14. Realizace přenosu dat operací <strong>REP MOVSB</strong></a></p>
<p><a href="#k15">15. Realizace přenosu dat operací <strong>REP MOVSW</strong></a></p>
<p><a href="#k16">16. Problematika rozdělení obrazové paměti na liché a sudé řádky</a></p>
<p><a href="#k17">17. Vykreslení lichých řádků získaných z&nbsp;rastrového obrázku</a></p>
<p><a href="#k18">18. Korektní vykreslení všech sudých i lichých řádků získaných z&nbsp;rastrového obrázku</a></p>
<p><a href="#k19">19. Repositář s&nbsp;demonstračními příklady</a></p>
<p><a href="#k20">20. Odkazy na Internetu</a></p>



<p><a name="k01"></a></p>
<h2 id="k01">1. Struktura obrazové paměti grafické karty CGA, blokové přenosy a základy optimalizace</h2>

<p>Ve třetím článku o programování her a grafických dem pro osobní mikropočítač
IBM PC se &bdquo;slavnou&ldquo; grafickou kartou CGA se zaměříme na některé
důležité nízkoúrovňové operace. Popíšeme si strukturu obrazové paměti karty CGA
v&nbsp;grafických režimech (výsledek nás nepotěší), dále si ukážeme přenosy
rastrových dat do obrazové paměti a taktéž synchronizaci kódu s&nbsp;vertikální
(snímkovou) frekvencí, což nám mj.&nbsp;zajistí konstantní rychlost běhu a
navíc i zamezí &bdquo;sněžení&ldquo;, které na kartě CGA nastává při zápisu do
obrazové paměti (už jsem říkal, že práce s&nbsp;touto kartou je peklem pro
programátora?). Ovšem seznámíme se i s&nbsp;některými zajímavými instrukcemi
mikroprocesoru Intel 8086/Intel 8088, například s&nbsp;instrukcemi pro blokové
přenosy dat (a proč je na CGA nevyužijeme v&nbsp;plné síle). Toto téma do jisté
míry souvisí s&nbsp;optimalizacemi, takže si porovnáme některé algoritmy
realizované několika různými způsoby.</p>



<p><a name="k02"></a></p>
<h2 id="k02">2. Vyplnění obrazovky konstantní barvou, naivní varianta</h2>

<p>Ukažme si nyní, jakým způsobem je možné vyplnit (skoro) celou obrazovku
bílou barvou ve chvíli, kdy máme nastaven grafický režim s&nbsp;rozlišením
640&times;200 pixelů a možností nastavení každého pixelu na barvu pozadí
(černá) nebo barvu popředí (bílá). Nejprve zapíšeme do segmentového registru
<strong>ES</strong> adresu segmentu 0xb800. To lze provést jen nepřímo, protože
operace <strong>mov segmentový_registr, konstanta</strong> není podporována
(jedno z&nbsp;omezení CISCové instrukční sady):</p>

<pre>
        mov ax, 0xb800    <i>; video segment</i>
        mov es, ax        <i>; do segmentoveho registru ES</i>
</pre>

<p>Dále vynulujeme pracovní registr <strong>BX</strong> použitý pro adresování
(ze základních registrů pouze tento lze použít v&nbsp;roli adresního registru)
v&nbsp;rámci video RAM (tedy segmentu <strong>0xb800</strong>). Registr
<strong>AL</strong> bude obsahovat hodnoty osmi pixelů (každý pixel=1 bit) a do
registru <strong>CX</strong> zapíšeme počet bajtů video RAM (zde naschvál
zapisuji nižší údaj, ale aby se obrazovka skutečně zaplnila, musíte použít
hodnotu 16384).</p>

<pre>
        xor bx, bx        <i>; adresa pro zapis barev pixelu</i>
        mov al, 255       <i>; zapisovana kombinace barev pixelu</i>
        mov cx, 640*200/8 <i>; pocitadlo smycky</i>
</pre>

<p>Následuje vlastní programová smyčka, v&nbsp;níž je operace vyplnění
obrazovky realizována. Na adresu <strong>[ES:BX]</strong> jsou zapsány barvy
osmi pixelů, adresa uložená v&nbsp;registru <strong>BX</strong> je zvýšena o
jedničku, hodnota počitadla uložená v&nbsp;registru <strong>CX</strong> je
naopak o jedničku snížena a pokud počitadlo nedosáhne nulové hodnoty, bude se
programová smyčka opakovat:</p>

<pre>
<strong>fill_loop</strong>:
        mov [es:bx], al   <i>; zapis barev osmi pixelu</i>
        inc bx            <i>; na dalsi pixel</i>
        dec cx            <i>; snizeni hodnoty CL</i>
        jnz fill_loop     <i>; skok pri nenulovosti vysledku</i>
</pre>

<p><div class="rs-tip-major">Poznámka: jedná se o velmi neefektivní zápis
vyplnění oblasti paměti, což si ostatně ukážeme v&nbsp;dalších
příkladech.</div></p>

<a href="https://www.root.cz/obrazek/1128189/"><img src="https://i.iinfo.cz/images/132/pc-03-1-prev.webp" class="image-1128189" width="343" height="270" data-prev-filename="https://i.iinfo.cz/images/132/pc-03-1-prev.webp" data-prev-width="343" data-prev-height="270" data-large-filename="https://i.iinfo.cz/images/132/pc-03-1-large.webp" data-large-width="667" data-large-height="525" alt="&#160;" title="Autor: tisnik, authors of Golden Axe, podle licence: &lt;a href=&quot;http://en.wikipedia.org/wiki/Rights_Managed&quot;&gt;Rights Managed&lt;/a&gt;" /></a>
<p><i>Obrázek 1: Výsledek vyplnění prvních 16000 bajtů obrazové paměti.
Povšimněte si, že ve skutečnosti některé (sudé) řádky na konci vyplněny nejsou.
K&nbsp;této problematice se ještě vrátíme.</i></p>



<p><a name="k03"></a></p>
<h2 id="k03">3. Úplný zdrojový kód prvního demonstračního příkladu</h2>

<p>Úplný zdrojový kód dnešního prvního demonstračního příkladu, který po svém
spuštění vyplní (skoro) celou obrazovku bílou barvou, vypadá následovně:</p>

<pre>
<i>; Vykresleni sady pixelu, vyplneni obrazovky.</i>
<i>;</i>
<i>; preklad pomoci:</i>
<i>;     nasm -f bin -o gfx_6.com gfx_6_fill_1.asm</i>
<i>;</i>
<i>; nebo pouze:</i>
<i>;     nasm -o gfx_6.com gfx_6_fill_1.asm</i>
&nbsp;
&nbsp;
<i>;-----------------------------------------------------------------------------</i>
&nbsp;
<i>; ukonceni procesu a navrat do DOSu</i>
%macro <strong>exit</strong> 0
        mov     ah, 0x4c
        int     0x21
%endmacro
&nbsp;
<i>; vyprazdneni bufferu klavesnice a cekani na klavesu</i>
%macro <strong>wait_key</strong> 0
        xor     ax, ax
        int     0x16
%endmacro
&nbsp;
<i>; nastaveni grafickeho rezimu</i>
%macro <strong>gfx_mode</strong> 1
        mov     ah, 0
        mov     al, %1
        int     0x10
%endmacro
&nbsp;
<i>;-----------------------------------------------------------------------------</i>
org  0x100        <i>; zacatek kodu pro programy typu COM (vzdy se zacina na 256)</i>
&nbsp;
<strong>start</strong>:
        gfx_mode 6
        wait_key
&nbsp;
        mov ax, 0xb800    <i>; video segment</i>
        mov es, ax        <i>; do segmentoveho registru ES</i>
        xor bx, bx        <i>; adresa pro zapis barev pixelu</i>
        mov al, 255       <i>; zapisovana kombinace barev pixelu</i>
        mov cx, 640*200/8 <i>; pocitadlo smycky</i>
<strong>fill_loop</strong>:
        mov [es:bx], al   <i>; zapis barev osmi pixelu</i>
        inc bx            <i>; na dalsi pixel</i>
        dec cx            <i>; snizeni hodnoty CL</i>
        jnz fill_loop     <i>; skok pri nenulovosti vysledku</i>
&nbsp;
        wait_key
        exit
</pre>



<p><a name="k04"></a></p>
<h2 id="k04">4. Programová smyčka realizovaná instrukcí <strong>LOOP</strong></h2>

<p>V&nbsp;předchozím demonstračním příkladu jsme použili registr
<strong>CX</strong> v&nbsp;roli počitadla programové smyčky. Zápis této smyčky
vypadal zhruba následovně:</p>

<pre>
<strong>smyčka</strong>:
        ...
        ...
        ...
        dec cx            <i>; snizeni hodnoty CL</i>
        jnz smyčka        <i>; skok pri nenulovosti vysledku</i>
</pre>

<p>Ve skutečnosti je možné tyto dvě instrukce nahradit za jedinou instrukci
<strong>LOOP</strong>, která provádí totožnou operaci, tj.&nbsp;snížení hodnoty
<strong>CX</strong> následované skokem ve chvíli, kdy <strong>CX</strong> ještě
nedosáhla nuly:</p>

<pre>
<strong>smyčka</strong>:
        ...
        ...
        ...
        loop smyčka    <i>; snizeni hodnoty CX, skok pri nenulovosti vysledku</i>
</pre>

<p>Jak je tato smyčka výhodná nám ukáže následující tabulka:</p>

<table>
<tr><th>Operace</th><th>Bajtů</th><th>Cyklů</th></tr>
<tr><td>DEC+JNZ</td><td>1+2</td><td>3+4 nebo 3+16</td></tr>
<tr><td>LOOP</td><td>2</td><td>5 nebo 17</td></tr>
</table>

<p>Druhá varianta je tedy pomalejší a současně i delší, než varianta
s&nbsp;instrukcí <strong>LOOP</strong>.</p>

<p><div class="rs-tip-major">Poznámka: doba trvání instrukcí skoku (sem patří i
<strong>LOOP</strong>) se liší podle toho, zda se skok provede či
nikoli.</div></p>

<p>A takto vypadá výsledek:</p>

<pre>
<i>; Vykresleni sady pixelu, vyplneni obrazovky.</i>
<i>;</i>
<i>; preklad pomoci:</i>
<i>;     nasm -f bin -o gfx_6.com gfx_6_ver_fill_2.asm</i>
<i>;</i>
<i>; nebo pouze:</i>
<i>;     nasm -o gfx_6.com gfx_6_ver_fill_2.asm</i>
&nbsp;
&nbsp;
<i>;-----------------------------------------------------------------------------</i>
&nbsp;
<i>; ukonceni procesu a navrat do DOSu</i>
%macro <strong>exit</strong> 0
        mov     ah, 0x4c
        int     0x21
%endmacro
&nbsp;
<i>; vyprazdneni bufferu klavesnice a cekani na klavesu</i>
%macro <strong>wait_key</strong> 0
        xor     ax, ax
        int     0x16
%endmacro
&nbsp;
<i>; nastaveni grafickeho rezimu</i>
%macro <strong>gfx_mode</strong> 1
        mov     ah, 0
        mov     al, %1
        int     0x10
%endmacro
&nbsp;
<i>;-----------------------------------------------------------------------------</i>
org  0x100        <i>; zacatek kodu pro programy typu COM (vzdy se zacina na 256)</i>
&nbsp;
<strong>start</strong>:
        gfx_mode 6
        wait_key
&nbsp;
        mov ax, 0xb800    <i>; video segment</i>
        mov es, ax        <i>; do segmentoveho registru ES</i>
        xor bx, bx        <i>; adresa pro zapis barev pixelu</i>
        mov al, 255       <i>; zapisovana kombinace barev pixelu</i>
        mov cx, 640*200/8 <i>; pocitadlo smycky</i>
<strong>fill_loop</strong>:
        mov [es:bx], al   <i>; zapis barev osmi pixelu</i>
        inc bx            <i>; na dalsi pixel</i>
        loop fill_loop    <i>; snizeni hodnoty CX, skok pri nenulovosti vysledku</i>
&nbsp;
        wait_key
        exit
</pre>


<p><a name="k05"></a></p>
<h2 id="k05">5. Použití instrukce <strong>REP STOSB</strong></h2>

<p>Ve skutečnosti je možné vyplnění (prakticky) celé obrazovky realizovat ještě
snadněji, a to konkrétně opakováním instrukce <strong>STOSB</strong>. Samotná
instrukce <strong>STOSB</strong> znamená &bdquo;STOre String (byte)&ldquo; a
provádí tyto operace:</p>

<ul>
<li>Zápis hodnoty uložené v&nbsp;registru <strong>AL</strong> na adresu <strong>[ES:DI]</strong></li>
<li>Zvýšení hodnoty registru <strong>DI</strong> o jedničku</li>
</ul>

<p>Pokud se navíc před tuto instrukce předá prefix představovaný instrukcí
<strong>REP</strong>, bude se celá operace <strong>STOSB</strong> opakovat
CX-krát.</p>

<p><div class="rs-tip-major">Poznámka: zde je jasně patrné, proč Intel 8086
patří mezi CISC procesory &ndash; realizace REP STOSB evidentně vyžaduje
mikrokód a nikoli RISCovou pipeline.</div></p>

<p>Jedna iterace takto realizované programové smyčky trvá deset cyklů,
k&nbsp;nimž musíme připočítat inicializačních devět cyklů.</p>



<p><a name="k06"></a></p>
<h2 id="k06">6. Úplný zdrojový kód třetího demonstračního příkladu</h2>

<pre>
<i>; Vyplneni obrazovky instrukci REP STOSB</i>
<i>;</i>
<i>; preklad pomoci:</i>
<i>;     nasm -f bin -o gfx_6.com gfx_6_ver_fill_1.asm</i>
<i>;</i>
<i>; nebo pouze:</i>
<i>;     nasm -o gfx_6.com gfx_6_ver_fill_1.asm</i>
&nbsp;
&nbsp;
<i>;-----------------------------------------------------------------------------</i>
&nbsp;
<i>; ukonceni procesu a navrat do DOSu</i>
%macro <strong>exit</strong> 0
        mov     ah, 0x4c
        int     0x21
%endmacro
&nbsp;
<i>; vyprazdneni bufferu klavesnice a cekani na klavesu</i>
%macro <strong>wait_key</strong> 0
        xor     ax, ax
        int     0x16
%endmacro
&nbsp;
<i>; nastaveni grafickeho rezimu</i>
%macro <strong>gfx_mode</strong> 1
        mov     ah, 0
        mov     al, %1
        int     0x10
%endmacro
&nbsp;
<i>;-----------------------------------------------------------------------------</i>
org  0x100        <i>; zacatek kodu pro programy typu COM (vzdy se zacina na 256)</i>
&nbsp;
<strong>start</strong>:
        gfx_mode 6        <i>; nastaveni grafickeho rezimu 640x200 se 2 barvami</i>
        wait_key
&nbsp;
        mov ax, 0xb800    <i>; video segment</i>
        mov es, ax        <i>; do segmentoveho registru ES</i>
        xor di, di        <i>; adresa pro zapis barev pixelu</i>
        mov al, 255       <i>; zapisovana kombinace barev pixelu</i>
        mov cx, 640*200/8 <i>; pocitadlo smycky</i>
&nbsp;
        rep stosb         <i>; vlastni vyplneni</i>
&nbsp;
        wait_key
        exit
</pre>



<p><a name="k07"></a></p>
<h2 id="k07">7. Porovnání rychlosti tří variant vyplnění obrazovky bílou barvou</h2>

<p>Nyní si všechny tři varianty vyplnění obrazovky bílou barvou porovnáme.
Všechny smyčky zapisují v&nbsp;každé iteraci jediný bajt, ovšem doba trvání se
bude odlišovat.</p>

<pre>
mov [es:bx], al   14  14
inc bx             3   3
dec cx             3   3
jnz fill_loop     16   4  (provedení/neprovedení skoku)
-------------------------
                  36  24
</pre>

<p>Celkově: 36&times;15999+24=574008 cyklů (to je hodně)</p>

<pre>
mov [es:bx], al   14  14
inc bx             3   3
loop fill_loop    17   5
-------------------------
                  34  22
</pre>

<p>Celkově: 34&times;15999+22=542118 cyklů (to je hodně)</p>

<pre>
rep stosb        17  9
</pre>

<p>Celkově: 17&times;15999+9=271057 cyklů.</p>

<p><div class="rs-tip-major">Poznámka: poslední způsob je tedy zdaleka
nejrychlejší, což programátory nutilo k&nbsp;ručním optimalizacím (obsazení
pracovních registrů atd.).</div></p>



<p><a name="k08"></a></p>
<h2 id="k08">8. Synchronizace zápisu na obrazovku s&nbsp;vertikálním synchronizačním pulsem</h2>

<p>U všech režimů původní varianty grafické karty <i>CGA</i> se vyskytuje ještě
jeden fenomén, který uživatelé jiných počítačů neznali &ndash; souběžný přístup
mikroprocesoru a grafického řadiče do obrazové paměti nebyl kupodivu nijak
ošetřen, což způsobovalo nechvalně známé &bdquo;sněžení&ldquo; (<i>snow</i>).
Jediná možnost, jak zabránit &bdquo;sněžení&ldquo;, byl zápis do obrazové
paměti při vertikálním zatemnění elektronového paprsku (horizontální zatemnění
má příliš krátký interval). A to byl další problém, protože karta CGA
negenerovala přerušení před vertikálním zatemněním &ndash; tedy něco, co uměly
již mnohé osmibitové mikropočítače. Takže čekání na zatemnění muselo probíhat
tím nejhorším možným způsobem &ndash; kontinuálním čtením příslušného bitu ze
stavového registru karty CGA.</p>

<p>Realizace čekání na vertikální přerušení je sice &ndash; samozřejmě pokud
nám nevadí &bdquo;pálení strojového času&ldquo; &ndash; vlastně až primitivně
jednoduché. Postačuje nám totiž kontinuálně sledovat čtvrtý bit portu 0x3da.
Pokud je tento bit nastaven, probíhá vertikální přerušení (a zápis je tedy
možné provést); jinak neprobíhá. Jenže ono to v&nbsp;praxi není až tak
jednoduché, protože i když je tento bit nastaven, tak vlastně nevíme, zda
přerušení v&nbsp;dalším cyklu neskončí (nevíme, ve kterém okamžiku přerušení se
nacházíme). Musíme tedy provádět dvě operace: čekání na dokončení aktuálního
přerušení (pokud probíhá) a čekání na nové přerušení, tedy na jeho začátek.
Celá realizace čekání na <i>začátek</i> vertikálního přerušení vypadá
takto:</p>

<pre>
<strong>wait_sync</strong>:
        mov dx, 0x3da      <i>; adresa stavoveho registru graficke karty CGA</i>
<strong>wait_sync_end</strong>:
        in al, dx          <i>; precteni hodnoty stavoveho registru</i>
        test al, 8         <i>; odmaskovat priznak vertikalniho synchronizacniho pulsu</i>
        jnz wait_sync_end  <i>; probiha - cekat na konec</i>
<strong>wait_sync_start</strong>:
        in al, dx          <i>; precteni hodnoty stavoveho registru</i>
        test al, 8         <i>; odmaskovat priznak vertikalniho synchronizacniho pulsu</i>
        jz wait_sync_start <i>; neprobiha - cekat na zacatek</i>
        ret                <i>; ok - synchronizacni kurz probiha, lze zapisovat do pameti</i>
</pre>

<p>Synchronizovaný zápis do video RAM nám &bdquo;prozradí&ldquo; její strukturu:</p>

<a href="https://www.root.cz/obrazek/1128190/"><img src="https://i.iinfo.cz/images/132/pc-03-2-prev.webp" class="image-1128190" width="343" height="270" data-prev-filename="https://i.iinfo.cz/images/132/pc-03-2-prev.webp" data-prev-width="343" data-prev-height="270" data-large-filename="https://i.iinfo.cz/images/132/pc-03-2-large.webp" data-large-width="667" data-large-height="525" alt="&#160;" title="Autor: tisnik, authors of Golden Axe, podle licence: &lt;a href=&quot;http://en.wikipedia.org/wiki/Rights_Managed&quot;&gt;Rights Managed&lt;/a&gt;" /></a>
<p><i>Obrázek 2: Začátek vyplňování (prozatím jen liché řádky).</i></p>

<a href="https://www.root.cz/obrazek/1128191/"><img src="https://i.iinfo.cz/images/132/pc-03-3-prev.webp" class="image-1128191" width="343" height="270" data-prev-filename="https://i.iinfo.cz/images/132/pc-03-3-prev.webp" data-prev-width="343" data-prev-height="270" data-large-filename="https://i.iinfo.cz/images/132/pc-03-3-large.webp" data-large-width="667" data-large-height="525" alt="&#160;" title="Autor: tisnik, authors of Golden Axe, podle licence: &lt;a href=&quot;http://en.wikipedia.org/wiki/Rights_Managed&quot;&gt;Rights Managed&lt;/a&gt;" /></a>
<p><i>Obrázek 3: Vyplnění prvních 8000 bajtů video RAM.</i></p>

<a href="https://www.root.cz/obrazek/1128192/"><img src="https://i.iinfo.cz/images/132/pc-03-4-prev.webp" class="image-1128192" width="343" height="270" data-prev-filename="https://i.iinfo.cz/images/132/pc-03-4-prev.webp" data-prev-width="343" data-prev-height="270" data-large-filename="https://i.iinfo.cz/images/132/pc-03-4-large.webp" data-large-width="667" data-large-height="525" alt="&#160;" title="Autor: tisnik, authors of Golden Axe, podle licence: &lt;a href=&quot;http://en.wikipedia.org/wiki/Rights_Managed&quot;&gt;Rights Managed&lt;/a&gt;" /></a>
<p><i>Obrázek 4: Pokračuje se vyplněním sudých řádků.</i></p>



<p><a name="k09"></a></p>
<h2 id="k09">9. Úplný zdrojový kód čtvrtého demonstračního příkladu</h2>

<p>Úplný zdrojový kód dnešního čtvrtého demonstračního příkladu, v&nbsp;němž se
na obrazovku zapisují pixely se synchronizací této operace, vypadá
následovně:</p>

<pre>
<i>; Vykresleni sady pixelu, vyplneni obrazovky.</i>
<i>;</i>
<i>; preklad pomoci:</i>
<i>;     nasm -f bin -o gfx_6.com gfx_6_ver_fill_1.asm</i>
<i>;</i>
<i>; nebo pouze:</i>
<i>;     nasm -o gfx_6.com gfx_6_ver_fill_1.asm</i>
&nbsp;
&nbsp;
<i>;-----------------------------------------------------------------------------</i>
&nbsp;
<i>; ukonceni procesu a navrat do DOSu</i>
%macro <strong>exit</strong> 0
        mov     ah, 0x4c
        int     0x21
%endmacro
&nbsp;
<i>; vyprazdneni bufferu klavesnice a cekani na klavesu</i>
%macro <strong>wait_key</strong> 0
        xor     ax, ax
        int     0x16
%endmacro
&nbsp;
<i>; nastaveni grafickeho rezimu</i>
%macro <strong>gfx_mode</strong> 1
        mov     ah, 0
        mov     al, %1
        int     0x10
%endmacro
&nbsp;
<i>;-----------------------------------------------------------------------------</i>
org  0x100        <i>; zacatek kodu pro programy typu COM (vzdy se zacina na 256)</i>
&nbsp;
<strong>start</strong>:
        gfx_mode 6
        wait_key
&nbsp;
        mov ax, 0xb800    <i>; video segment</i>
        mov es, ax        <i>; do segmentoveho registru ES</i>
        xor bx, bx        <i>; adresa pro zapis barev pixelu</i>
        mov cx, 640*200/8 <i>; pocitadlo smycky</i>
<strong>fill_loop</strong>:
        call wait_sync
        mov al, 255       <i>; zapisovana kombinace barev pixelu</i>
        mov [es:bx], al   <i>; zapis barev osmi pixelu</i>
        inc bx            <i>; na dalsi pixel</i>
        loop fill_loop    <i>; snizeni hodnoty CX, skok pri nenulovosti vysledku</i>
&nbsp;
        wait_key
        exit
&nbsp;
<strong>wait_sync</strong>:
        mov dx, 0x3da      <i>; adresa stavoveho registru graficke karty CGA</i>
<strong>wait_sync_end</strong>:
        in al, dx          <i>; precteni hodnoty stavoveho registru</i>
        test al, 8         <i>; odmaskovat priznak vertikalniho synchronizacniho pulsu</i>
        jnz wait_sync_end  <i>; probiha - cekat na konec</i>
<strong>wait_sync_start</strong>:
        in al, dx          <i>; precteni hodnoty stavoveho registru</i>
        test al, 8         <i>; odmaskovat priznak vertikalniho synchronizacniho pulsu</i>
        jz wait_sync_start <i>; neprobiha - cekat na zacatek</i>
        ret                <i>; ok - synchronizacni kurz probiha, lze zapisovat do pameti</i>
</pre>



<p><a name="k10"></a></p>
<h2 id="k10">10. Odvození snímkové frekvence na základě trvání vyplnění obrazu</h2>

<p>Předchozímu programu trvá vyplnění celé obrazovky poměrně dlouhou dobu.
Vezměme tedy do ruky stopky a zkusme tuto dobu alespoň přibližně zjistit a
odvodit z&nbsp;ní snímkovou frekvenci (tedy počet snímků zobrazených monitorem
za sekundu).</p>

<p>Začneme s&nbsp;výchozím nastavením DOSBoxu, který emuluje karty
VGA a SVGA. V&nbsp;této konfiguraci je obrazovka vyplněna za přibližně 230
sekund (měřeno běžnými stopkami, takže &plusm; 1 sekunda). Přitom se provedlo
celkem 640&times;200/8=16000 zápisů. Z&nbsp;toho plyne></p>

<pre>
16000/230 = 69,5
</pre>

<p>Za sekundu se tedy provedlo přibližně 69,5 zápisů, což odpovídá snímkové
frekvenci, která dosahuje taktéž této hodnoty (necelých 70 Hz).</p>

<p>Ovšem korektní je měření ve chvíli, kdy je DOSBox nakonfigurován tak, aby
emuloval počítač s&nbsp;kartou CGA. V&nbsp;souboru
<strong>~/.config/dosbox/dosbox-staging.conf</strong> je nutné nastavit řádek
<strong>machine</strong> na hodnotu <strong>cga</strong>. Nyní bude vyplnění
obrazovky trvat 268 sekund, což při stejném počtu 640&times;200/8=16000 zápisů
vede ke snímkové frekvenci:</p>

<pre>
16000/268 = 59,70 Hz
</pre>

<p>To je velmi blízko skutečné snímkové frekvenci, která dosahuje 59,923 Hz.
Tato na první pohled poněkud divná hodnota je odvozena od frekvence hodinového
signálu 14,318181 MHz, která je dělena osmi a následně ještě 114. Tím získáme
řádkovou frekvenci (přibližně 15699,8 řádků za sekundu) a podělením hodnotou
262 pak dostaneme onu snímkovou frekvenci 59,923 Hz.</p>

<p><div class="rs-tip-major">Poznámka: jedná se o přibližně dvojnásobnou
frekvenci televizní normy NTSC (29,97 Hz).</div></p>



<p><a name="k11"></a></p>
<h2 id="k11">11. Vykreslení rastrového obrázku získaného z&nbsp;binárních dat</h2>

<p>Ve druhé polovině dnešního článku se zaměříme na zdánlivě jednoduchou úlohu:
jak na obrazovku řízenou grafickou kartou CGA vykreslit následující obrázek ze
slavné hry <i>Golden Axe</i>:</p>

<img src="https://i.iinfo.cz/images/132/pc-03-5.webp" class="image-1128193" width="640" height="400" alt="&#160;" title="Autor: tisnik, authors of Golden Axe, podle licence: &lt;a href=&quot;http://en.wikipedia.org/wiki/Rights_Managed&quot;&gt;Rights Managed&lt;/a&gt;" />
<p><i>Obrázek 5: Obrázek ze hry Golden Axe, který máme k&nbsp;dispozici
v&nbsp;binární podobě (16000 bajtů čistých obrazových dat).</i></p>

<p>Z&nbsp;tohoto obrázku nejdříve musíme získat &bdquo;surová&ldquo; rastrová
data, tj.&nbsp;barvy jednotlivých pixelů. Obrázek využívá grafický režim
s&nbsp;rozlišením 320&times;200 pixelů, přičemž každý pixel je uložen ve dvou
bitech (tedy čtyři pixely v&nbsp;jednom bajtu). Pokud máme k&nbsp;dispozici
data obrázku <a
href="https://www.root.cz/clanky/graficky-format-bmp-pouzivany-a-pritom-neoblibeny/">ve
formátu BMP</a> s&nbsp;bitovou hloubkou 8bpp, získáme z&nbsp;něho surová data
ve vhodném formátu následujícím konvertorem, který přeskočí (a ignoruje)
hlavičku BMP, paletu (dohromady 1162 bajtů &ndash; ovšem pozor, někdy vypadá
hlavička jinak či chybí paleta &ndash; níže uvedený konvertor je až příliš
primitivní, aby tyto nuance odhalil) a následně přečtené hodnoty pixelů uloží
ve formátu 4 pixely na bajt:</p>

<pre>
#include <stdio.h>

#define PIXELS 320*200

int main(void) {
    FILE *fin;
    FILE *fout;
    int i;

    fin = fopen("1.bmp", "r");
    fseek(fin, 1162, SEEK_SET);

    fout = fopen("image.bin", "w");

    for (i=0; i&lt;PIXELS/4; i++) {
        unsigned char pixels[4];
        unsigned int out;
        fread(pixels, 4, 1, fin);

        out = pixels[3] &amp; 0x03 |
              ((pixels[2] &amp; 0x03) &lt;&lt; 2) |
              ((pixels[1] &amp; 0x03) &lt;&lt; 4) |
              ((pixels[0] &amp; 0x03) &lt;&lt; 6);
        printf("%x ", out);
        fputc(out, fout);
    }

    fclose(fin);
    fclose(fout);
}
</pre>

<pre>

<pre>
        mov cx, 16000   <i>; pocet zapisovanych bajtu</i>
</pre>

<pre>
adresa_zdroje = (DS &lt;&lt; 4) + SI
</pre>

<p>Podobným způsobem si v&nbsp;registrech <strong>ES:DI</strong> připravíme
cílovou adresu, tedy v&nbsp;našem případě adresu prvního bajtu v&nbsp;obrazové
paměti (ta je rovna <strong>b0xb800:0</strong> v&nbsp;zápisu
segment:offset):</p>

<pre>
mov ax, 0xb800
mov es, ax
mov di, 0       <i>; nyni ES:DI obsahuje adresu prvniho pixelu ve video RAM</i>
</pre>

<p><div class="rs-tip-major">Poznámka: zatímco <strong>SI</strong> znamená
&bdquo;source index&ldquo;, tak <strong>DI</strong> značí &bdquo;destination
index&ldquo;. Ten se typicky spojuje právě se segmentovým registrem
<strong>ES</strong> (<i>extra segment</i>).</div></p>

<p>Zbývá nám nastavit si počitadlo přenášených bajtů, což je snadné. Pro tento
účel se téměř vždy používá registr <strong>CX</strong> popř.&nbsp;jeho spodním
osm bitů <strong>CL</strong>:</p>

<pre>
mov cx, 16000   <i>; pocet zapisovanych bajtu</i>
</pre>

<p>Vlastní programová smyčka, která přenese všech 16000 bajtů, může
v&nbsp;naivním provedení vypadat následovně:</p>

<pre>
<strong>move</strong>:   mov al, [ds:si]   <i>; precteni jednoho bajtu z obrazku</i>
        mov [es:di], al   <i>; zapis tohoto bajtu do video RAM</i>
        inc si          <i>; posun ve zdrojovem "poli"</i>
        inc di          <i>; posun ve video RAM</i>
        loop move       <i>; opakovat CX-krat</i>
</pre>

<a href="https://www.root.cz/obrazek/1128194/"><img src="https://i.iinfo.cz/images/132/pc-03-6-prev.webp" class="image-1128194" width="343" height="270" data-prev-filename="https://i.iinfo.cz/images/132/pc-03-6-prev.webp" data-prev-width="343" data-prev-height="270" data-large-filename="https://i.iinfo.cz/images/132/pc-03-6-large.webp" data-large-width="667" data-large-height="525" alt="&#160;" title="Autor: tisnik, authors of Golden Axe, podle licence: &lt;a href=&quot;http://en.wikipedia.org/wiki/Rights_Managed&quot;&gt;Rights Managed&lt;/a&gt;" /></a>
<p><i>Obrázek 6: Výsledek přesunu rastrových dat obrázku do obrazové paměti
(špatné proložení sudých a lichých řádků).</i></p>

<p><div class="rs-tip-major">Poznámka: zdaleka se nejedná o nejkratší ani o
nejrychlejší řešení, ale ukazují se na něm některé vlastnosti čipu Intel 8086,
zejména jeho adresovací režimy (segment+offset), specializované instrukce pro
inkrementaci registrů a nám již známá instrukce <strong>LOOP</strong> pro
snížení obsahu počitadla <strong>CX</strong> a skok v&nbsp;případě, že
počitadlo ještě nedosáhlo nuly.</div></p>

<p>V&nbsp;případě assembleru NASM je možné vynechat hranaté závorky u výpočtu
adresy, takže se zápis zkrátí následovně (zda je čitelnější, ponechám na
laskavém čtenáři):</p>

<pre>
<strong>move</strong>:   mov al, ds:si   <i>; precteni jednoho bajtu z obrazku</i>
        mov es:di, al   <i>; zapis tohoto bajtu do video RAM</i>
        inc si          <i>; posun ve zdrojovem "poli"</i>
        inc di          <i>; posun ve video RAM</i>
        loop move       <i>; opakovat CX-krat</i>
</pre>



<p><a name="k12"></a></p>
<h2 id="k12">12. Úplný zdrojový kód pátého demonstračního příkladu</h2>

<p>Opět se podívejme na úplný zdrojový kód demonstračního příkladu, který po
svém spuštění vykreslí na obrazovku rastrový obrázek. Přitom výsledný obrázek
<i>nebude</i> korektní; tuto chybu opravíme v&nbsp;rámci navazujících
kapitol:</p>

<pre>
<i>; Vykresleni rastroveho obrazku ziskaneho z binarnich dat.</i>
<i>; Zakladni varianta s explicitne zapsanou programovou smyckou.</i>
<i>;</i>
<i>; preklad pomoci:</i>
<i>;     nasm -f bin -o gfx_4.com gfx_4_image.asm</i>
<i>;</i>
<i>; nebo pouze:</i>
<i>;     nasm -o gfx_4.com gfx_4_image.asm</i>
&nbsp;
&nbsp;
<i>;-----------------------------------------------------------------------------</i>
&nbsp;
<i>; ukonceni procesu a navrat do DOSu</i>
%macro <strong>exit</strong> 0
        mov     ah, 0x4c
        int     0x21
%endmacro
&nbsp;
<i>; vyprazdneni bufferu klavesnice a cekani na klavesu</i>
%macro <strong>wait_key</strong> 0
        xor     ax, ax
        int     0x16
%endmacro
&nbsp;
<i>; nastaveni grafickeho rezimu</i>
%macro <strong>gfx_mode</strong> 1
        mov     ah, 0
        mov     al, %1
        int     0x10
%endmacro
&nbsp;
<i>;-----------------------------------------------------------------------------</i>
org  0x100        <i>; zacatek kodu pro programy typu COM (vzdy se zacina na 256)</i>
&nbsp;
<strong>start</strong>:
        gfx_mode 4      <i>; nastaveni grafickeho rezimu 320x200 se ctyrmi barvami</i>
&nbsp;
        mov ax, cs
        mov ds, ax
        mov si, image   <i>; nyni DS:SI obsahuje adresu prvniho bajtu v obrazku</i>
&nbsp;
        mov ax, 0xb800
        mov es, ax
        mov di, 0       <i>; nyni ES:DI obsahuje adresu prvniho pixelu ve video RAM</i>
&nbsp;
        mov cx, 16000   <i>; pocet zapisovanych bajtu</i>
&nbsp;
move:   mov al, ds:si   <i>; precteni jednoho bajtu z obrazku</i>
        mov es:di, al   <i>; zapis tohoto bajtu do video RAM</i>
        inc si          <i>; posun ve zdrojovem "poli"</i>
        inc di          <i>; posun ve video RAM</i>
        loop move       <i>; opakovat CX-krat</i>
&nbsp;
        wait_key
        exit
&nbsp;
<i>; pridani binarnich dat s rastrovym obrazkem</i>
<strong>image</strong>:
    incbin "image.bin"
</pre>



<p><a name="k13"></a></p>
<h2 id="k13">13. Blokový přenos dat operací <strong>REP MOSVB</strong> či <strong>REP MOVSW</strong></h2>

<p>V&nbsp;programu <a href="#k12">z&nbsp;předchozí kapitoly</a> je přenos dat
z&nbsp;kódového+datového segmentu do segmentu s&nbsp;video pamětí (Video RAM)
řešen programovou smyčkou, v&nbsp;níž se přenáší bajty z&nbsp;adresy
<strong>[DS:SI]</strong> na adresu <strong>[ES:DI]</strong>. Jako počitadlo
této programové smyčky opět slouží registr <strong>CX</strong>. Smyčka vypadá
následovně:</p>

<pre>
move:   mov al, ds:si   <i>; precteni jednoho bajtu z obrazku</i>
        mov es:di, al   <i>; zapis tohoto bajtu do video RAM</i>
        inc si          <i>; posun ve zdrojovem "poli"</i>
        inc di          <i>; posun ve video RAM</i>
        loop move       <i>; opakovat CX-krat</i>
</pre>

<p>Jak dlouho ovšem potrvá přenesení jednoho bajtu? Zkusme si to spočítat, opět
pro případ původního čipu Intel 8086 (a Intel 8088 je  v&nbsp;tomto případě
prakticky stejně rychlý):</p>

<pre>
mov al, ds:si   14
mov es:di, al   13+5
inc si           3
inc di           3
loop move       17
------------------------
                50 až 55
</pre>

<p>To je poměrně dlouhá doba! Ovšem již mikroprocesor Intel 8086 (a samozřejmě
i Intel 8088) obsahoval instrukci <strong>movsb</strong> určenou pro přenos
jednoho bajtu z&nbsp;adresy <strong>[DS:SI]</strong> na adresu
<strong>[ES:DI]</strong> se zvýšením <strong>SI</strong> i <strong>DI</strong>
o jedničku. Navíc je možné i před tuto instrukci vložit prefix
<strong>rep</strong> pro její opakování <strong>CX-krát</strong>. A navíc
existuje i instrukce <strong>movsw</strong> určená pro přenos celých 16bitových
slov. Rychlosti těchto instrukcí jsou následující:</p>

<table>
<tr><th>Instrukce</th><th>Délka (bajtů)</th><th>Cyklů</th></tr>
<tr><td>movsb</td><td>1</td><td>18</td></tr>
<tr><td>movsw</td><td>1</td><td>26</td></tr>
<tr><td>rep movsb</td><td>2</td><td>9+17&times;n</td></tr>
<tr><td>rep movsw</td><td>2</td><td>9+28&times;n</td></tr>
</table>

<p><div class="rs-tip-major">Poznámka: použití <strong>rep movsw</strong> je
tedy na procesoru Intel 8086 skoro dvakrát rychlejší, než <strong>rep
movsb</strong>, ovšem u Intelu 8088 tomu tak není kvůli poloviční šířce externí
datové sběrnice!</div></p>

<p>Pokud vám doby trvání instrukcí stále připadnou dlouhé, vězte, že na Pentiu
trvají operace <strong>rep movs*</strong> pouze 3+n cyklů, kde <i>n</i> je
počet přenášených bajtů, 16bitových slov či 32bitových slov. Tedy Pentium, i
kdyby bylo taktované pouze na 4,77 MHz, jako původní PC s&nbsp;Intelem 8088, by
stále bylo několikanásobně rychlejší, protože podobně se urychlila i většina
ostatních operací.</p>



<p><a name="k14"></a></p>
<h2 id="k14">14. Realizace přenosu dat operací <strong>REP MOVSB</strong></h2>

<p>Pro přenos obrazu z&nbsp;původního segmentu, do něhož je nahrán náš program,
do segmentu video RAM můžeme využít jak <strong>rep movsb</strong>, tak i
<strong>rep movsw</strong>. Nejprve použijeme <strong>rep movsb</strong>, tedy
přenos po jednotlivých bajtech. Celkový počet opakování přenosové operace bude
roven 16000:</p>

<pre>
mov cx, 16000   <i>; pocet zapisovanych bajtu</i>
</pre>

<p>A blokový přenos bude proveden instrukcí <strong>movsb</strong>
s&nbsp;prefixem <strong>rep</strong>:</p>

<pre>
rep movsb       <i>; provest cely blokovy prenos po bajtech</i>
</pre>

<p>Úplný zdrojový kód takto upraveného programu bude vypadat následovně:</p>

<pre>
<i>; Vykresleni rastroveho obrazku ziskaneho z binarnich dat.</i>
<i>; Varianta zalozena na instrukci REP MOVSB</i>
<i>;</i>
<i>; preklad pomoci:</i>
<i>;     nasm -f bin -o gfx_4.com gfx_4_image.asm</i>
<i>;</i>
<i>; nebo pouze:</i>
<i>;     nasm -o gfx_4.com gfx_4_image.asm</i>
&nbsp;
&nbsp;
<i>;-----------------------------------------------------------------------------</i>
&nbsp;
<i>; ukonceni procesu a navrat do DOSu</i>
%macro <strong>exit</strong> 0
        mov     ah, 0x4c
        int     0x21
%endmacro
&nbsp;
<i>; vyprazdneni bufferu klavesnice a cekani na klavesu</i>
%macro <strong>wait_key</strong> 0
        xor     ax, ax
        int     0x16
%endmacro
&nbsp;
<i>; nastaveni grafickeho rezimu</i>
%macro <strong>gfx_mode</strong> 1
        mov     ah, 0
        mov     al, %1
        int     0x10
%endmacro
&nbsp;
<i>;-----------------------------------------------------------------------------</i>
org  0x100        <i>; zacatek kodu pro programy typu COM (vzdy se zacina na 256)</i>
&nbsp;
<strong>start</strong>:
        gfx_mode 4      <i>; nastaveni grafickeho rezimu 320x200 se ctyrmi barvami</i>
&nbsp;
        mov ax, cs
        mov ds, ax
        mov si, image   <i>; nyni DS:SI obsahuje adresu prvniho bajtu v obrazku</i>
&nbsp;
        mov ax, 0xb800
        mov es, ax
        mov di, 0       <i>; nyni ES:DI obsahuje adresu prvniho pixelu ve video RAM</i>
&nbsp;
        mov cx, 16000   <i>; pocet zapisovanych bajtu</i>
&nbsp;
        rep movsb       <i>; provest cely blokovy prenos po bajtech</i>
&nbsp;
        wait_key
        exit
&nbsp;
<strong>image</strong>:
    incbin "image.bin"
</pre>



<p><a name="k15"></a></p>
<h2 id="k15">15. Realizace přenosu dat operací <strong>REP MOVSW</strong></h2>

<p>Rychlejší bude přenos pixelů nikoli po bajtech, ale po šestnáctibitových
slovech. To znamená, že se počet přenosových operací sníží na polovinu:</p>

<pre>
mov cx, 16000/2 <i>; pocet zapisovanych slov</i>
</pre>

<p>A vlastní přenos zahájíme instrukcí <strong>movsw</strong> s&nbsp;prefixem
<strong>rep</strong>:</p>

<pre>
rep movsw       <i>; provest cely blokovy prenos po slovech</i>
</pre>

<p>Opět se podívejme na úplný zdrojový kód takto upraveného programu:</p>

<pre>
<i>; Vykresleni rastroveho obrazku ziskaneho z binarnich dat.</i>
<i>; Varianta zalozena na instrukci REP MOVSW</i>
<i>;</i>
<i>; preklad pomoci:</i>
<i>;     nasm -f bin -o gfx_4.com gfx_4_image.asm</i>
<i>;</i>
<i>; nebo pouze:</i>
<i>;     nasm -o gfx_4.com gfx_4_image.asm</i>
&nbsp;
&nbsp;
<i>;-----------------------------------------------------------------------------</i>
&nbsp;
<i>; ukonceni procesu a navrat do DOSu</i>
%macro <strong>exit</strong> 0
        mov     ah, 0x4c
        int     0x21
%endmacro
&nbsp;
<i>; vyprazdneni bufferu klavesnice a cekani na klavesu</i>
%macro <strong>wait_key</strong> 0
        xor     ax, ax
        int     0x16
%endmacro
&nbsp;
<i>; nastaveni grafickeho rezimu</i>
%macro <strong>gfx_mode</strong> 1
        mov     ah, 0
        mov     al, %1
        int     0x10
%endmacro
&nbsp;
<i>;-----------------------------------------------------------------------------</i>
org  0x100        <i>; zacatek kodu pro programy typu COM (vzdy se zacina na 256)</i>
&nbsp;
<strong>start</strong>:
        gfx_mode 4      <i>; nastaveni grafickeho rezimu 320x200 se ctyrmi barvami</i>
&nbsp;
        mov ax, cs
        mov ds, ax
        mov si, image   <i>; nyni DS:SI obsahuje adresu prvniho bajtu v obrazku</i>
&nbsp;
        mov ax, 0xb800
        mov es, ax
        mov di, 0       <i>; nyni ES:DI obsahuje adresu prvniho pixelu ve video RAM</i>
&nbsp;
        mov cx, 16000/2 <i>; pocet zapisovanych slov</i>
&nbsp;
        rep movsw       <i>; provest cely blokovy prenos po slovech</i>
&nbsp;
        wait_key
        exit
&nbsp;
<strong>image</strong>:
    incbin "image.bin"
</pre>



<p><a name="k16"></a></p>
<h2 id="k16">16. Problematika rozdělení obrazové paměti na liché a sudé řádky</h2>

<p>Ve všech předchozích demonstračních příkladech, ve kterých jsme se snažili o
vykreslení rastrového obrázku, bylo zřejmé, že vykreslení není korektní. Je
tomu tak z&nbsp;toho důvodu, že v&nbsp;grafických režimech karty CGA (jak
v&nbsp;monochromatickém, tak i ve &bdquo;čtyřbarevném&ldquo;) jsou
v&nbsp;prvních osmi kilobajtech uloženy liché řádky (pokud řádky počítáme od
jedničky) a ve druhých osmi kilobajtech pak řádky sudé. Mapa video RAM tedy
vypadá zhruba takto:</p>

<pre>
====================================
0xb800         řádek 1
0xb800+80      řádek 3
0xb800+160     řádek 5
...            ...
...            ...
...            ...
0xb800+7920    řádek 199
0xb800+8000    nepoužitých 192 bajtů
====================================
0xd800         řádek 2
0xd800+80      řádek 4
0xd800+160     řádek 6
...            ...
...            ...
...            ...
0xd800+7920    řádek 200
0xb800+8000    nepoužitých 192 bajtů
====================================
</pre>

<p>Toto řešení sice může do určité míry vyhovovat v&nbsp;prokládaných
(<i>interlaced</i>) režimech, ovšem znesnadňuje veškeré další operace,
tj.&nbsp;vykreslování pixelů, úseček, bitmap atd.</p>



<p><a name="k17"></a></p>
<h2 id="k17">17. Vykreslení lichých řádků získaných z&nbsp;rastrového obrázku</h2>

<p>Upravme si tedy předchozí demonstrační příklady do takové podoby, aby se
rastrový obrázek (který je uložen kontinuálně, tj.&nbsp;ve formě řádků 1, 2, 3,
4, ...  99, 100, ... 199, 200) vykreslil korektně. První úprava bude spočívat
v&nbsp;tom, že vykreslíme pouze liché řádky a přitom budeme korektně ve
<i>vstupním</i> obrázku přeskakovat řádky sudé &ndash; tedy budeme se posouvat
o 80 bajtů bez přenosu. Realizace řešení poloviny našeho problému může vypadat
následovně (registry budou nastaveny stejně, jako v&nbsp;předchozích
příkladech):</p>

<pre>
        mov bl, 100     <i>; pocitadlo radku</i>
&nbsp;
<strong>outer_loop</strong>:
        mov cx, 80/2    <i>; velikost bloku ve slovech</i>
        rep movsw       <i>; prenest jeden obrazovy radek</i>
        add si, 80      <i>; preskocit lichy/sudy radek</i>
        dec bl
        jnz outer_loop  <i>; opakovat smycku BL-krat</i>
</pre>

<p>Povšimněte si, že původní blokový přenos realizovaný jedinou instrukcí
<strong>rep movsb</strong> nebo <strong>rep movsw</strong> je nyní nutné
rozdělit na přenos jednotlivých řádků &ndash; děkovné dopisy posílejte do IBM.
A navíc je nutné registr <strong>SI</strong> zvýšit o 80 (bajtů), aby se ve
vstupním obrázku přeskočil sudý řádek.</p>

<p>Výsledkem bude následující obrazovka:</p>

<a href="https://www.root.cz/obrazek/1128195/"><img src="https://i.iinfo.cz/images/132/pc-03-7-prev.webp" class="image-1128195" width="343" height="270" data-prev-filename="https://i.iinfo.cz/images/132/pc-03-7-prev.webp" data-prev-width="343" data-prev-height="270" data-large-filename="https://i.iinfo.cz/images/132/pc-03-7-large.webp" data-large-width="667" data-large-height="525" alt="&#160;" title="Autor: tisnik, authors of Golden Axe, podle licence: &lt;a href=&quot;http://en.wikipedia.org/wiki/Rights_Managed&quot;&gt;Rights Managed&lt;/a&gt;" /></a>
<p><i>Obrázek 7: Vykreslení pouze lichých řádků, korektní přeskočení řádků
sudých.</i></p>

<p>Výsledný program vypadá následovně:</p>

<pre>
<i>; Vykresleni rastroveho obrazku ziskaneho z binarnich dat.</i>
<i>; Korektni vykresleni vsech lichych radku obrazku.</i>
<i>;</i>
<i>; preklad pomoci:</i>
<i>;     nasm -f bin -o gfx_4.com gfx_4_image.asm</i>
<i>;</i>
<i>; nebo pouze:</i>
<i>;     nasm -o gfx_4.com gfx_4_image.asm</i>
&nbsp;
&nbsp;
<i>;-----------------------------------------------------------------------------</i>
&nbsp;
<i>; ukonceni procesu a navrat do DOSu</i>
%macro <strong>exit</strong> 0
        mov     ah, 0x4c
        int     0x21
%endmacro
&nbsp;
<i>; vyprazdneni bufferu klavesnice a cekani na klavesu</i>
%macro <strong>wait_key</strong> 0
        xor     ax, ax
        int     0x16
%endmacro
&nbsp;
<i>; nastaveni grafickeho rezimu</i>
%macro <strong>gfx_mode</strong> 1
        mov     ah, 0
        mov     al, %1
        int     0x10
%endmacro
&nbsp;
<i>;-----------------------------------------------------------------------------</i>
org  0x100        <i>; zacatek kodu pro programy typu COM (vzdy se zacina na 256)</i>
&nbsp;
<strong>start</strong>:
        gfx_mode 4      <i>; nastaveni grafickeho rezimu 320x200 se ctyrmi barvami</i>
&nbsp;
        mov ax, cs
        mov ds, ax
        mov si, image   <i>; nyni DS:SI obsahuje adresu prvniho bajtu v obrazku</i>
&nbsp;
        mov ax, 0xb800
        mov es, ax
        mov di, 0       <i>; nyni ES:DI obsahuje adresu prvniho pixelu ve video RAM</i>
&nbsp;
        mov bl, 100     <i>; pocitadlo radku</i>
&nbsp;
<strong>outer_loop</strong>:
        mov cx, 80/2    <i>; velikost bloku ve slovech</i>
        rep movsw       <i>; prenest jeden obrazovy radek</i>
        add si, 80      <i>; preskocit lichy/sudy radek</i>
        dec bl
        jnz outer_loop  <i>; opakovat smycku BL-krat</i>
&nbsp;
        wait_key
        exit
&nbsp;
<strong>image</strong>:
    incbin "image.bin"
</pre>



<p><a name="k18"></a></p>
<h2 id="k18">18. Korektní vykreslení všech sudých i lichých řádků získaných z&nbsp;rastrového obrázku</h2>

<p>Nyní již můžeme přistoupit k&nbsp;finální úpravě našeho vykreslovače
obrázků. Nejprve budeme přenos poloviny obrazových řádků (sudých nebo lichých)
realizovat v&nbsp;podprogramu, přičemž se předpokládá korektní nastavení adres
<strong>[DS:SI]</strong> a <strong>[ES:DI]</strong>. Tento kód již známe, pouze
je doplněn o instrukci <strong>ret</strong> na konci:</p>

<pre>
<strong>move_half_image</strong>:
        mov bl, 100     <i>; pocitadlo radku</i>
<strong>outer_loop</strong>:
        mov cx, 80/2    <i>; velikost bloku ve slovech</i>
        rep movsw       <i>; prenest jeden obrazovy radek</i>
        add si, 80      <i>; preskocit lichy/sudy radek</i>
        dec bl
        jnz outer_loop  <i>; opakovat smycku BL-krat</i>
        ret
</pre>

<p>Následuje vykreslení lichých řádků s&nbsp;využitím tohoto podprogramu:</p>

<pre>
        mov ax, 0xb800
        mov es, ax
        mov di, 0       <i>; nyni ES:DI obsahuje adresu prvniho pixelu ve video RAM</i>
&nbsp;
        call move_half_image
</pre>

<p>Dále nám již postačuje posunout se ve zdrojovém obrázku o jeden obrazový
řádek a upravit adresu v&nbsp;registru <strong>DI</strong> tak, aby ukazoval na
začátek druhé poloviny Video RAM (stačilo by i pouhé přičtení hodnoty 192, to
je však poněkud matoucí):</p>

<pre>
        mov si, image+80; adresa prvniho pixelu na DRUHEM radku
        mov di, 8192    <i>; druha "stranka" video RAM</i>
        call move_half_image
</pre>

<p>Výsledek:</p>

*** image ***
<p><i>Obrázek </i></p>

<p>Opět se podívejme na výslednou podobu demonstračního příkladu:</p>

<pre>
<i>; Vykresleni rastroveho obrazku ziskaneho z binarnich dat.</i>
<i>; Korektni vykresleni vsech sudych i lichych radku obrazku.</i>
<i>;</i>
<i>; preklad pomoci:</i>
<i>;     nasm -f bin -o gfx_4.com gfx_4_image.asm</i>
<i>;</i>
<i>; nebo pouze:</i>
<i>;     nasm -o gfx_4.com gfx_4_image.asm</i>
&nbsp;
&nbsp;
<i>;-----------------------------------------------------------------------------</i>
&nbsp;
<i>; ukonceni procesu a navrat do DOSu</i>
%macro <strong>exit</strong> 0
        mov     ah, 0x4c
        int     0x21
%endmacro
&nbsp;
<i>; vyprazdneni bufferu klavesnice a cekani na klavesu</i>
%macro <strong>wait_key</strong> 0
        xor     ax, ax
        int     0x16
%endmacro
&nbsp;
<i>; nastaveni grafickeho rezimu</i>
%macro <strong>gfx_mode</strong> 1
        mov     ah, 0
        mov     al, %1
        int     0x10
%endmacro
&nbsp;
<i>;-----------------------------------------------------------------------------</i>
org  0x100        <i>; zacatek kodu pro programy typu COM (vzdy se zacina na 256)</i>
&nbsp;
<strong>start</strong>:
        gfx_mode 4      <i>; nastaveni grafickeho rezimu 320x200 se ctyrmi barvami</i>
&nbsp;
        mov ax, cs
        mov ds, ax
        mov si, image   <i>; nyni DS:SI obsahuje adresu prvniho bajtu v obrazku</i>
&nbsp;
        mov ax, 0xb800
        mov es, ax
        mov di, 0       <i>; nyni ES:DI obsahuje adresu prvniho pixelu ve video RAM</i>
&nbsp;
        call move_half_image
&nbsp;
        mov si, image+80; adresa prvniho pixelu na DRUHEM radku
        mov di, 8192    <i>; druha "stranka" video RAM</i>
        call move_half_image
&nbsp;
        wait_key
        exit
&nbsp;
<strong>move_half_image</strong>:
        mov bl, 100     <i>; pocitadlo radku</i>
<strong>outer_loop</strong>:
        mov cx, 80/2    <i>; velikost bloku ve slovech</i>
        rep movsw       <i>; prenest jeden obrazovy radek</i>
        add si, 80      <i>; preskocit lichy/sudy radek</i>
        dec bl
        jnz outer_loop  <i>; opakovat smycku BL-krat</i>
        ret
&nbsp;
&nbsp;
<strong>image</strong>:
    incbin "image.bin"
</pre>

<a href="https://www.root.cz/obrazek/1128197/"><img src="https://i.iinfo.cz/images/132/pc-03-9-prev.webp" class="image-1128197" width="343" height="270" data-prev-filename="https://i.iinfo.cz/images/132/pc-03-9-prev.webp" data-prev-width="343" data-prev-height="270" data-large-filename="https://i.iinfo.cz/images/132/pc-03-9-large.webp" data-large-width="667" data-large-height="525" alt="&#160;" title="Autor: tisnik, authors of Golden Axe, podle licence: &lt;a href=&quot;http://en.wikipedia.org/wiki/Rights_Managed&quot;&gt;Rights Managed&lt;/a&gt;" /></a>
<p><i>Obrázek 9: Po přepnutí barvové palety získáme originál (podrobnosti budou
popsány příště).</i></p>



<p><a name="k19"></a></p>
<h2 id="k19">19. Repositář s&nbsp;demonstračními příklady</h2>

<p>Demonstrační příklady napsané v&nbsp;assembleru, které jsou určené pro
překlad pomocí assembleru <strong>NASM</strong>, byly uložen do Git repositáře,
který je dostupný na adrese <a
href="https://github.com/tisnik/8bit-fame">https://github.com/tisnik/8bit-fame</a>.
Jednotlivé demonstrační příklady si můžete v&nbsp;případě potřeby stáhnout i
jednotlivě bez nutnosti klonovat celý (dnes již poměrně rozsáhlý)
repositář:</p>

<table>
<tr><th> #</th><th>Příklad</th><th>Stručný popis</th><th>Adresa</th></tr>
<tr><td> 1</td><td>hello.asm</td><td>program typu &bdquo;Hello world&ldquo; naprogramovaný v&nbsp;assembleru pro systém DOS</td><td><a href="https://github.com/tisnik/8bit-fame/blob/master/pc-dos/hello.asm">https://github.com/tisnik/8bit-fame/blob/master/pc-dos/hello.asm</a></td></tr>
<tr><td> 2</td><td>hello_shorter.asm</td><td>kratší varianta výskoku z&nbsp;procesu zpět do DOSu</td><td><a href="https://github.com/tisnik/8bit-fame/blob/master/pc-dos/hello_shorter.asm">https://github.com/tisnik/8bit-fame/blob/master/pc-dos/hello_shorter.asm</a></td></tr>
<tr><td> 3</td><td>hello_wait.asm</td><td>čekání na stisk klávesy</td><td><a href="https://github.com/tisnik/8bit-fame/blob/master/pc-dos/hello_wait.asm">https://github.com/tisnik/8bit-fame/blob/master/pc-dos/hello_wait.asm</a></td></tr>
<tr><td> 4</td><td>hello_macros.asm</td><td>realizace jednotlivých částí programu makrem</td><td><a href="https://github.com/tisnik/8bit-fame/blob/master/pc-dos/hello_macros.asm">https://github.com/tisnik/8bit-fame/blob/master/pc-dos/hello_macros.asm</a></td></tr>
<tr><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td></tr>
<tr><td> 5</td><td>gfx_4_putpixel.asm</td><td>vykreslení pixelu v&nbsp;grafickém režimu 4</td><td><a href="https://github.com/tisnik/8bit-fame/blob/master/pc-dos/gfx_4_putpixel.asm">https://github.com/tisnik/8bit-fame/blob/master/pc-dos/gfx_4_putpixel.asm</a></td></tr>
<tr><td> 6</td><td>gfx_6_putpixel.asm</td><td>vykreslení pixelu v&nbsp;grafickém režimu 6</td><td><a href="https://github.com/tisnik/8bit-fame/blob/master/pc-dos/gfx_6_putpixel.asm">https://github.com/tisnik/8bit-fame/blob/master/pc-dos/gfx_6_putpixel.asm</a></td></tr>
<tr><td> 7</td><td>gfx_4_line.asm</td><td>vykreslení úsečky v&nbsp;grafickém režimu 4</td><td><a href="https://github.com/tisnik/8bit-fame/blob/master/pc-dos/gfx_4_line.asm">https://github.com/tisnik/8bit-fame/blob/master/pc-dos/gfx_4_line.asm</a></td></tr>
<tr><td> 8</td><td>gfx_6_line.asm</td><td>vykreslení úsečky v&nbsp;grafickém režimu 6</td><td><a href="https://github.com/tisnik/8bit-fame/blob/master/pc-dos/gfx_6_line.asm">https://github.com/tisnik/8bit-fame/blob/master/pc-dos/gfx_6_line.asm</a></td></tr>
<tr><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td></tr>
<tr><td> 9</td><td>gfx_6_fill_1.asm</td><td>vyplnění obrazovky v&nbsp;grafickém režimu, základní varianta</td><td><a href="https://github.com/tisnik/8bit-fame/blob/master/pc-dos/gfx_6_fill_1.asm">https://github.com/tisnik/8bit-fame/blob/master/pc-dos/gfx_6_fill_1.asm</a></td></tr>
<tr><td>10</td><td>gfx_6_fill_2.asm</td><td>vyplnění obrazovky v&nbsp;grafickém režimu, varianta s&nbsp;instrukcí <strong>LOOP</strong></td><td><a href="https://github.com/tisnik/8bit-fame/blob/master/pc-dos/gfx_6_fill_2.asm">https://github.com/tisnik/8bit-fame/blob/master/pc-dos/gfx_6_fill_2.asm</a></td></tr>
<tr><td>11</td><td>gfx_6_fill_3.asm</td><td>vyplnění obrazovky instrukcí <strong>REP STOSB</strong></td><td><a href="https://github.com/tisnik/8bit-fame/blob/master/pc-dos/gfx_6_fill_3.asm">https://github.com/tisnik/8bit-fame/blob/master/pc-dos/gfx_6_fill_3.asm</a></td></tr>
<tr><td>12</td><td>gfx_6_fill_4.asm</td><td>vyplnění obrazovky, synchronizace vykreslování s&nbsp;paprskem</td><td><a href="https://github.com/tisnik/8bit-fame/blob/master/pc-dos/gfx_6_fill_4.asm">https://github.com/tisnik/8bit-fame/blob/master/pc-dos/gfx_6_fill_4.asm</a></td></tr>
<tr><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td></tr>
<tr><td>13</td><td>gfx_4_image_1.asm</td><td>vykreslení rastrového obrázku získaného z&nbsp;binárních dat, základní varianta</td><td><a href="https://github.com/tisnik/8bit-fame/blob/master/pc-dos/gfx_4_image_1.asm">https://github.com/tisnik/8bit-fame/blob/master/pc-dos/gfx_4_image_1.asm</a></td></tr>
<tr><td>14</td><td>gfx_4_image_2.asm</td><td>varianta vykreslení rastrového obrázku s&nbsp;využitím instrukce <strong>REP MOVSB</strong></td><td><a href="https://github.com/tisnik/8bit-fame/blob/master/pc-dos/gfx_4_image_2.asm">https://github.com/tisnik/8bit-fame/blob/master/pc-dos/gfx_4_image_2.asm</a></td></tr>
<tr><td>15</td><td>gfx_4_image_3.asm</td><td>varianta vykreslení rastrového obrázku s&nbsp;využitím instrukce <strong>REP MOVSW</strong></td><td><a href="https://github.com/tisnik/8bit-fame/blob/master/pc-dos/gfx_4_image_3.asm">https://github.com/tisnik/8bit-fame/blob/master/pc-dos/gfx_4_image_3.asm</a></td></tr>
<tr><td>16</td><td>gfx_4_image_4.asm</td><td>korektní vykreslení všech sudých řádků bitmapy</td><td><a href="https://github.com/tisnik/8bit-fame/blob/master/pc-dos/gfx_4_image_4.asm">https://github.com/tisnik/8bit-fame/blob/master/pc-dos/gfx_4_image_4.asm</a></td></tr>
<tr><td>17</td><td>gfx_4_image_5.asm</td><td>korektní vykreslení všech sudých i lichých řádků bitmapy</td><td><a href="https://github.com/tisnik/8bit-fame/blob/master/pc-dos/gfx_4_image_5.asm">https://github.com/tisnik/8bit-fame/blob/master/pc-dos/gfx_4_image_5.asm</a></td></tr>
<tr><td>18</td><td>gfx_4_image_6.asm</td><td>nastavení barvové palety před vykreslením obrázku</td><td><a href="https://github.com/tisnik/8bit-fame/blob/master/pc-dos/gfx_4_image_6.asm">https://github.com/tisnik/8bit-fame/blob/master/pc-dos/gfx_4_image_6.asm</a></td></tr>
</table>



<p><a name="k20"></a></p>
<h2 id="k20">20. Odkazy na Internetu</h2>

<ol>

<li>The Intel 8088 Architecture and Instruction Set<br />
<a href="https://people.ece.ubc.ca/~edc/464/lectures/lec4.pdf">https://people.ece.ubc.ca/~edc/464/lectures/lec4.pdf</a>
</li>

<li>x86 Opcode Structure and Instruction Overview<br />
<a href="https://pnx.tf/files/x86_opcode_structure_and_instruction_overview.pdf">https://pnx.tf/files/x86_opcode_structure_and_instruction_overview.pdf</a>
</li>

<li>x86 instruction listings (Wikipedia)<br />
<a href="https://en.wikipedia.org/wiki/X86_instruction_listings">https://en.wikipedia.org/wiki/X86_instruction_listings</a>
</li>

<li>x86 assembly language (Wikipedia)<br />
<a href="https://en.wikipedia.org/wiki/X86_assembly_language">https://en.wikipedia.org/wiki/X86_assembly_language</a>
</li>

<li>Intel Assembler (Cheat sheet)<br />
<a href="http://www.jegerlehner.ch/intel/IntelCodeTable.pdf">http://www.jegerlehner.ch/intel/IntelCodeTable.pdf</a>
</li>

<li>25 Microchips That Shook the World<br />
<a href="https://spectrum.ieee.org/tech-history/silicon-revolution/25-microchips-that-shook-the-world">https://spectrum.ieee.org/tech-history/silicon-revolution/25-microchips-that-shook-the-world</a>
</li>

<li>Chip Hall of Fame: MOS Technology 6502 Microprocessor<br />
<a href="https://spectrum.ieee.org/tech-history/silicon-revolution/chip-hall-of-fame-mos-technology-6502-microprocessor">https://spectrum.ieee.org/tech-history/silicon-revolution/chip-hall-of-fame-mos-technology-6502-microprocessor</a>
</li>

<li>Chip Hall of Fame: Intel 8088 Microprocessor<br />
<a href="https://spectrum.ieee.org/tech-history/silicon-revolution/chip-hall-of-fame-intel-8088-microprocessor">https://spectrum.ieee.org/tech-history/silicon-revolution/chip-hall-of-fame-intel-8088-microprocessor</a>
</li>

<li>Jak se zrodil procesor?<br />
<a href="https://www.root.cz/clanky/jak-se-zrodil-procesor/">https://www.root.cz/clanky/jak-se-zrodil-procesor/</a>
</li>

<li>Apple II History Home<br />
<a href="http://apple2history.org/">http://apple2history.org/</a>
</li>

<li>The 8086/8088 Primer<br />
<a href="https://www.stevemorse.org/8086/index.html">https://www.stevemorse.org/8086/index.html</a>
</li>

<li>flat assembler: Assembly language resources<br />
<a href="https://flatassembler.net/">https://flatassembler.net/</a>
</li>

<li>FASM na Wikipedii<br />
<a href="https://en.wikipedia.org/wiki/FASM">https://en.wikipedia.org/wiki/FASM</a>
</li>

<li>Fresh IDE FASM inside<br />
<a href="https://fresh.flatassembler.net/">https://fresh.flatassembler.net/</a>
</li>

<li>MS-DOS Version 4.0 Programmer's Reference<br />
<a href="https://www.pcjs.org/documents/books/mspl13/msdos/dosref40/">https://www.pcjs.org/documents/books/mspl13/msdos/dosref40/</a>
</li>

<li>INT 21 - DOS Function Dispatcher (DOS)<br />
<a href="https://www.stanislavs.org/helppc/int_21.html">https://www.stanislavs.org/helppc/int_21.html</a>
</li>

<li>DOS API (Wikipedia)<br />
<a href="https://en.wikipedia.org/wiki/DOS_API">https://en.wikipedia.org/wiki/DOS_API</a>
</li>

<li>Bit banging<br />
<a href="https://en.wikipedia.org/wiki/Bit_banging">https://en.wikipedia.org/wiki/Bit_banging</a>
</li>

<li>IBM Basic assembly language and successors (Wikipedia)<br />
<a href="https://en.wikipedia.org/wiki/IBM_Basic_assembly_language_and_successors">https://en.wikipedia.org/wiki/IBM_Basic_assembly_language_and_successors</a>
</li>

<li>X86 Assembly/Bootloaders<br />
<a href="https://en.wikibooks.org/wiki/X86_Assembly/Bootloaders">https://en.wikibooks.org/wiki/X86_Assembly/Bootloaders</a>
</li>

<li>Počátky grafiky na PC: grafické karty CGA a Hercules<br />
<a href="https://www.root.cz/clanky/pocatky-grafiky-na-pc-graficke-karty-cga-a-hercules/">https://www.root.cz/clanky/pocatky-grafiky-na-pc-graficke-karty-cga-a-hercules/</a>
</li>

<li>Co mají společného Commodore PET/4000, BBC Micro, Amstrad CPC i grafické karty MDA, CGA a Hercules?<br />
<a href="https://www.root.cz/clanky/co-maji-spolecneho-commodore-pet-4000-bbc-micro-amstrad-cpc-i-graficke-karty-mda-cga-a-hercules/">https://www.root.cz/clanky/co-maji-spolecneho-commodore-pet-4000-bbc-micro-amstrad-cpc-i-graficke-karty-mda-cga-a-hercules/</a>
</li>

<li>Karta EGA: první použitelná barevná grafika na PC<br />
<a href="https://www.root.cz/clanky/karta-ega-prvni-pouzitelna-barevna-grafika-na-pc/">https://www.root.cz/clanky/karta-ega-prvni-pouzitelna-barevna-grafika-na-pc/</a>
</li>

<li>RGB Classic Games<br />
<a href="https://www.classicdosgames.com/">https://www.classicdosgames.com/</a>
</li>

<li>Turbo Assembler (Wikipedia)<br />
<a href="https://en.wikipedia.org/wiki/Turbo_Assembler">https://en.wikipedia.org/wiki/Turbo_Assembler</a>
</li>

<li>Microsoft Macro Assembler<br />
<a href="https://en.wikipedia.org/wiki/Microsoft_Macro_Assembler">https://en.wikipedia.org/wiki/Microsoft_Macro_Assembler</a>
</li>

<li>IBM Personal Computer (Wikipedia)<br />
<a href="https://en.wikipedia.org/wiki/IBM_Personal_Computer">https://en.wikipedia.org/wiki/IBM_Personal_Computer</a>
</li>

<li>Intel 8251<br />
<a href="https://en.wikipedia.org/wiki/Intel_8251">https://en.wikipedia.org/wiki/Intel_8251</a>
</li>

<li>Intel 8253<br />
<a href="https://en.wikipedia.org/wiki/Intel_8253">https://en.wikipedia.org/wiki/Intel_8253</a>
</li>

<li>Intel 8255<br />
<a href="https://en.wikipedia.org/wiki/Intel_8255">https://en.wikipedia.org/wiki/Intel_8255</a>
</li>

<li>Intel 8257<br />
<a href="https://en.wikipedia.org/wiki/Intel_8257">https://en.wikipedia.org/wiki/Intel_8257</a>
</li>

<li>Intel 8259<br />
<a href="https://en.wikipedia.org/wiki/Intel_8259">https://en.wikipedia.org/wiki/Intel_8259</a>
</li>

<li>Support/peripheral/other chips - 6800 family<br />
<a href="http://www.cpu-world.com/Support/6800.html">http://www.cpu-world.com/Support/6800.html</a>
</li>

<li>Motorola 6845<br />
<a href="http://en.wikipedia.org/wiki/Motorola_6845">http://en.wikipedia.org/wiki/Motorola_6845</a>
</li>

<li>The 6845 Cathode Ray Tube Controller (CRTC)<br />
<a href="http://www.tinyvga.com/6845">http://www.tinyvga.com/6845</a>
</li>

<li>CRTC operation<br />
<a href="http://www.6502.org/users/andre/hwinfo/crtc/crtc.html">http://www.6502.org/users/andre/hwinfo/crtc/crtc.html</a>
</li>

<li>6845 - Motorola CRT Controller<br />
<a href="https://stanislavs.org/helppc/6845.html">https://stanislavs.org/helppc/6845.html</a>
</li>

<li>The 6845 Cathode Ray Tube Controller (CRTC)<br />
<a href="http://www.tinyvga.com/6845">http://www.tinyvga.com/6845</a>
</li>

<li>Motorola 6845 and bitwise graphics<br />
<a href="https://retrocomputing.stackexchange.com/questions/10996/motorola-6845-and-bitwise-graphics">https://retrocomputing.stackexchange.com/questions/10996/motorola-6845-and-bitwise-graphics</a>
</li>

<li>IBM Monochrome Display Adapter<br />
<a href="http://en.wikipedia.org/wiki/Monochrome_Display_Adapter">http://en.wikipedia.org/wiki/Monochrome_Display_Adapter</a>
</li>

<li>Color Graphics Adapter<br />
<a href="http://en.wikipedia.org/wiki/Color_Graphics_Adapter">http://en.wikipedia.org/wiki/Color_Graphics_Adapter</a>
</li>

<li>Color Graphics Adapter and the Brown color in IBM 5153 Color Display<br />
<a href="https://www.aceinnova.com/en/electronics/cga-and-the-brown-color-in-ibm-5153-color-display/">https://www.aceinnova.com/en/electronics/cga-and-the-brown-color-in-ibm-5153-color-display/</a>
</li>

<li>The Modern Retrocomputer: An Arduino Driven 6845 CRT Controller<br />
<a href="https://hackaday.com/2017/05/14/the-modern-retrocomputer-an-arduino-driven-6845-crt-controller/">https://hackaday.com/2017/05/14/the-modern-retrocomputer-an-arduino-driven-6845-crt-controller/</a>
</li>

<li>flat assembler: Assembly language resources<br />
<a href="https://flatassembler.net/">https://flatassembler.net/</a>
</li>

<li>FASM na Wikipedii<br />
<a href="https://en.wikipedia.org/wiki/FASM">https://en.wikipedia.org/wiki/FASM</a>
</li>

<li>Fresh IDE FASM inside<br />
<a href="https://fresh.flatassembler.net/">https://fresh.flatassembler.net/</a>
</li>

<li>MS-DOS Version 4.0 Programmer's Reference<br />
<a href="https://www.pcjs.org/documents/books/mspl13/msdos/dosref40/">https://www.pcjs.org/documents/books/mspl13/msdos/dosref40/</a>
</li>

<li>INT 21 - DOS Function Dispatcher (DOS)<br />
<a href="https://www.stanislavs.org/helppc/int_21.html">https://www.stanislavs.org/helppc/int_21.html</a>
</li>

<li>DOS API (Wikipedia)<br />
<a href="https://en.wikipedia.org/wiki/DOS_API">https://en.wikipedia.org/wiki/DOS_API</a>
</li>

<li>IBM Basic assembly language and successors (Wikipedia)<br />
<a href="https://en.wikipedia.org/wiki/IBM_Basic_assembly_language_and_successors">https://en.wikipedia.org/wiki/IBM_Basic_assembly_language_and_successors</a>
</li>

<li>X86 Assembly/Arithmetic<br />
<a href="https://en.wikibooks.org/wiki/X86_Assembly/Arithmetic">https://en.wikibooks.org/wiki/X86_Assembly/Arithmetic</a>
</li>

<li>Art of Assembly - Arithmetic Instructions<br />
<a href="http://oopweb.com/Assembly/Documents/ArtOfAssembly/Volume/Chapter_6/CH06-2.html">http://oopweb.com/Assembly/Documents/ArtOfAssembly/Volume/Chapter_6/CH06-2.html</a>
</li>

<li>ASM Flags<br />
<a href="http://www.cavestory.org/guides/csasm/guide/asm_flags.html">http://www.cavestory.org/guides/csasm/guide/asm_flags.html</a>
</li>

<li>Status Register<br />
<a href="https://en.wikipedia.org/wiki/Status_register">https://en.wikipedia.org/wiki/Status_register</a>
</li>

<li>Linux assemblers: A comparison of GAS and NASM<br />
<a href="http://www.ibm.com/developerworks/library/l-gas-nasm/index.html">http://www.ibm.com/developerworks/library/l-gas-nasm/index.html</a>
</li>

<li>Programovani v assembleru na OS Linux<br />
<a href="http://www.cs.vsb.cz/grygarek/asm/asmlinux.html">http://www.cs.vsb.cz/grygarek/asm/asmlinux.html</a>
</li>

<li>Is it worthwhile to learn x86 assembly language today?<br />
<a href="https://www.quora.com/Is-it-worthwhile-to-learn-x86-assembly-language-today?share=1">https://www.quora.com/Is-it-worthwhile-to-learn-x86-assembly-language-today?share=1</a>
</li>

<li>Why Learn Assembly Language?<br />
<a href="http://www.codeproject.com/Articles/89460/Why-Learn-Assembly-Language">http://www.codeproject.com/Articles/89460/Why-Learn-Assembly-Language</a>
</li>

<li>Is Assembly still relevant?<br />
<a href="http://programmers.stackexchange.com/questions/95836/is-assembly-still-relevant">http://programmers.stackexchange.com/questions/95836/is-assembly-still-relevant</a>
</li>

<li>Why Learning Assembly Language Is Still a Good Idea<br />
<a href="http://www.onlamp.com/pub/a/onlamp/2004/05/06/writegreatcode.html">http://www.onlamp.com/pub/a/onlamp/2004/05/06/writegreatcode.html</a>
</li>

<li>Assembly language today<br />
<a href="http://beust.com/weblog/2004/06/23/assembly-language-today/">http://beust.com/weblog/2004/06/23/assembly-language-today/</a>
</li>

<li>Assembler: Význam assembleru dnes<br />
<a href="http://www.builder.cz/rubriky/assembler/vyznam-assembleru-dnes-155960cz">http://www.builder.cz/rubriky/assembler/vyznam-assembleru-dnes-155960cz</a>
</li>

<li>Programming from the Ground Up Book - Summary<br />
<a href="http://savannah.nongnu.org/projects/pgubook/">http://savannah.nongnu.org/projects/pgubook/</a>
</li>

<li>DOSBox<br />
<a href="https://www.dosbox.com/">https://www.dosbox.com/</a>
</li>

<li>The C Programming Language<br />
<a href="https://en.wikipedia.org/wiki/The_C_Programming_Language">https://en.wikipedia.org/wiki/The_C_Programming_Language</a>
</li>

<li>Hercules Graphics Card (HCG)<br />
<a href="https://en.wikipedia.org/wiki/Hercules_Graphics_Card">https://en.wikipedia.org/wiki/Hercules_Graphics_Card</a>
</li>

<li>Complete 8086 instruction set<br />
<a href="https://content.ctcd.edu/courses/cosc2325/m22/docs/emu8086ins.pdf">https://content.ctcd.edu/courses/cosc2325/m22/docs/emu8086ins.pdf</a>
</li>

<li>Complete 8086 instruction set<br />
<a href="https://yassinebridi.github.io/asm-docs/8086_instruction_set.html">https://yassinebridi.github.io/asm-docs/8086_instruction_set.html</a>
</li>

<li>8088 MPH by Hornet + CRTC + DESiRE (final version)<br />
<a href="https://www.youtube.com/watch?v=hNRO7lno_DM">https://www.youtube.com/watch?v=hNRO7lno_DM</a>
</li>

<li>Area 5150 by CRTC &amp; Hornet (Party Version) / IBM PC+CGA Demo, Hardware Capture<br />
<a href="https://www.youtube.com/watch?v=fWDxdoRTZPc">https://www.youtube.com/watch?v=fWDxdoRTZPc</a>
</li>

<li>80x86 Integer Instruction Set Timings (8088 - Pentium)<br />
<a href="http://aturing.umcs.maine.edu/~meadow/courses/cos335/80x86-Integer-Instruction-Set-Clocks.pdf">http://aturing.umcs.maine.edu/~meadow/courses/cos335/80x86-Integer-Instruction-Set-Clocks.pdf</a>
</li>

</ol>



<p></p><p></p>
<p><small>Autor: <a href="http://www.fit.vutbr.cz/~tisnovpa">Pavel Tišnovský</a> &nbsp; 2024</small></p>
</body>
</html>

