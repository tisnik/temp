<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
        "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html>
<head>
<title></title>
<meta name="Author" content="Pavel Tisnovsky" />
<meta name="Generator" content="vim" />
<meta http-equiv="content-type" content="text/html; charset=utf-8" />
<style type="text/css">
         body {color:#000000; background:#ffffff;}
         h1  {font-family: arial, helvetica, sans-serif; color:#ffffff; background-color:#c00000; text-align:center; padding-left:1em}
         h2  {font-family: arial, helvetica, sans-serif; color:#ffffff; background-color:#0000c0; padding-left:1em; text-align:left}
         h3  {font-family: arial, helvetica, sans-serif; color:#000000; background-color:#c0c0c0; padding-left:1em; text-align:left}
         h4  {font-family: arial, helvetica, sans-serif; color:#000000; background-color:#e0e0e0; padding-left:1em; text-align:left}
         a   {font-family: arial, helvetica, sans-serif;}
         li  {font-family: arial, helvetica, sans-serif; color:#000000; text-align:justify; width:450px;}
         ol  {font-family: arial, helvetica, sans-serif; color:#000000; text-align:justify; width:450px;}
         ul  {font-family: arial, helvetica, sans-serif; color:#000000; text-align:justify; width:450px;}
         p   {font-family: arial, helvetica, sans-serif; color:#000000; text-align:justify;}
         pre {background:#e0e0e0}
</style>
</head>

<body>

<h1></h1>

<h3>Pavel Tišnovský</h3>

<p></p>

<h1>Úvodník</h1>

<p></p>



<h2>Obsah</h2>

<p><a href="#k01">*** 1. Krátké zopakování z&nbsp;minula: symboly zastupující konkrétní hodnoty</a></p>
<p><a href="#k02">*** 2. Kódy barev a bitové operace podporované assemblerem <i>Pasmo</i></a></p>
<p><a href="#k03">*** 3. Automatické vygenerování &bdquo;loaderu&ldquo; pro obraz magnetofonové pásky</a></p>
<p><a href="#k04">4. Mikroprocesor Zilog Z80 z&nbsp;pohledu programátora</a></p>
<p><a href="#k05">5. Sada univerzálních a speciálních registrů</a></p>
<p><a href="#k06">6. Sada instrukcí mikroprocesoru Z80</a></p>
<p><a href="#k07">7. Proč se jména instrukcí na Z80 odlišují od Intel 8080?</a></p>
<p><a href="#k08">8. Adresovací režimy a všudypřítomná instrukce <strong>LD</strong></a></p>
<p><a href="#k09">*** 9. Vybrané instrukce použité v&nbsp;demonstračních příkladech</a></p>
<p><a href="#k10">10. Jednoduchá počítaná programová smyčka: naivní varianta</a></p>
<p><a href="#k11">11. Celková délka kódu, časování instrukcí</a></p>
<p><a href="#k12">12. Zkrácení kódu pro vynulování použitých pracovních registrů</a></p>
<p><a href="#k13">13. Optimalizace skoku na konci smyčky (instrukce <strong>DJNZ</strong>)</a></p>
<p><a href="#k14">14. Optimalizace využití pracovních registrů</a></p>
<p><a href="#k15">15. Náhrada registrového páru HL za index registry IX nebo IY?</a></p>
<p><a href="#k16">16. Porovnání kódů založených na registrech HL, IX a IY</a></p>
<p><a href="#k17">17. Programová smyčka se šestnáctibitovým počitadlem: naivní varianta</a></p>
<p><a href="#k18">18. Dosažení prakticky stejné rychlosti, jako v&nbsp;případě smyčky s&nbsp;osmibitovým počitadlem</a></p>
<p><a href="#k19">19. Repositář s&nbsp;demonstračními příklady</a></p>
<p><a href="#k20">20. Odkazy na Internetu</a></p>



<p><a name="k01"></a></p>
<h2 id="k01">1. Krátké zopakování z&nbsp;minula: symboly zastupující konkrétní hodnoty</h2>

<p></p>

<pre>
        org <strong>$8000</strong>
&nbsp;
start:
        ld a,<strong>%11010110</strong>
        ld (<strong>$5800</strong>),a
        ret
</pre>

<pre>
attribute_adr equ $5800
entry_point   equ $8000
&nbsp;
&nbsp;
        org <strong>entry_point</strong>
&nbsp;
start:
        ld a,%11010110
        ld (<strong>attribute_adr</strong>),a
        ret
</pre>

<p></p>

<img src="https://i.iinfo.cz/images/342/devel-speccy-1-26.png" class="image-763288" alt="&#160;" title="Autor: tisnik + third party, podle licence: &lt;a href=&quot;http://en.wikipedia.org/wiki/Rights_Managed&quot;&gt;Rights Managed&lt;/a&gt;" width="640" height="480" />
<p><i>Obrázek 1: Blikající atribut v&nbsp;levém horním rohu obrazovky.</i></p>

<img src="https://i.iinfo.cz/images/342/devel-speccy-1-27.png" class="image-763289" alt="&#160;" title="Autor: tisnik + third party, podle licence: &lt;a href=&quot;http://en.wikipedia.org/wiki/Rights_Managed&quot;&gt;Rights Managed&lt;/a&gt;" width="640" height="480" />
<p><i>Obrázek 2: Blikající atribut v&nbsp;levém horním rohu obrazovky.</i></p>



<p><a name="k02"></a></p>
<h2 id="k02">2. Kódy barev a bitové operace podporované assemblerem <i>Pasmo</i></h2>

<p></p>

<pre>
attribute_adr equ $5800
entry_point   equ $8000

blink_bit     equ %10000000
intensity_bit equ %01000000
black_color   equ %000
blue_color    equ %001
red_color     equ %010
magenta_color equ %011
green_color   equ %100
cyan_color    equ %101
yellow_color  equ %110
white_color   equ %111


        org entry_point

start:
        ld a,blink_bit | intensity_bit | (blue_color &lt;&lt; 3) | white_color
        ld (attribute_adr),a
        ret
</pre>

<p></p>

<pre>
attribute_adr   EQU 5800
entry_point     EQU 8000
blink_bit       EQU 0080
intensity_bit   EQU 0040
black_color     EQU 0000
blue_color      EQU 0001
red_color       EQU 0002
magenta_color   EQU 0003
green_color     EQU 0004
cyan_color      EQU 0005
yellow_color    EQU 0006
white_color     EQU 0007
                ORG 8000
8000:           label start
8000:3ECF       LD A, CF
8002:320058     LD (5800), A
8005:C9         RET
Emiting TAP from 8000 to 8005
</pre>

<pre>
ATTRIBUTE_ADR equ $5800
ENTRY_POINT   equ $8000

BLINK_BIT     equ %10000000
INTENSITY_BIT equ %01000000
BLACK_COLOR   equ %000
BLUE_COLOR    equ %001
RED_COLOR     equ %010
MAGENTA_COLOR equ %011
GREEN_COLOR   equ %100
CYAN_COLOR    equ %101
YELLOW_COLOR  equ %110
WHITE_COLOR   equ %111


        org ENTRY_POINT

start:
        ld a,BLINK_BIT | INTENSITY_BIT | (BLUE_COLOR &lt;&lt; 3) | WHITE_COLOR
        ld (ATTRIBUTE_ADR),a
        ret
</pre>

<p></p>

<pre>
ATTRIBUTE_ADR   EQU 5800
ENTRY_POINT     EQU 8000
BLINK_BIT       EQU 0080
INTENSITY_BIT   EQU 0040
BLACK_COLOR     EQU 0000
BLUE_COLOR      EQU 0001
RED_COLOR       EQU 0002
MAGENTA_COLOR   EQU 0003
GREEN_COLOR     EQU 0004
CYAN_COLOR      EQU 0005
YELLOW_COLOR    EQU 0006
WHITE_COLOR     EQU 0007
                ORG 8000
8000:           label start
8000:3ECF       LD A, CF
8002:320058     LD (5800), A
8005:C9         RET
Emiting TAP from 8000 to 8005
</pre>

<img src="http://i.iinfo.cz/images/206/jones-1.png" class="image-177655" width="320" height="256" alt="&#160;" />
<p><i>Obrázek 2: Loading screen hry Indiana Jones a Chrám zkázy.</i></p>



<p><a name="k03"></a></p>
<h2 id="k03">3. Automatické vygenerování &bdquo;loaderu&ldquo; pro obraz magnetofonové pásky</h2>

<p></p>

<pre>
ATTRIBUTE_ADR equ $5800
ENTRY_POINT   equ $8000

BLINK_BIT     equ %10000000
INTENSITY_BIT equ %01000000
BLACK_COLOR   equ %000
BLUE_COLOR    equ %001
RED_COLOR     equ %010
MAGENTA_COLOR equ %011
GREEN_COLOR   equ %100
CYAN_COLOR    equ %101
YELLOW_COLOR  equ %110
WHITE_COLOR   equ %111


        org ENTRY_POINT

start:
        ld a,BLINK_BIT | INTENSITY_BIT | (BLUE_COLOR &lt;&lt; 3) | WHITE_COLOR
        ld (ATTRIBUTE_ADR),a
        ret

end
</pre>

<pre>
ATTRIBUTE_ADR   EQU 5800
ENTRY_POINT     EQU 8000
BLINK_BIT       EQU 0080
INTENSITY_BIT   EQU 0040
BLACK_COLOR     EQU 0000
BLUE_COLOR      EQU 0001
RED_COLOR       EQU 0002
MAGENTA_COLOR   EQU 0003
GREEN_COLOR     EQU 0004
CYAN_COLOR      EQU 0005
YELLOW_COLOR    EQU 0006
WHITE_COLOR     EQU 0007
                ORG 8000
8000:           label start
8000:3ECF       LD A, CF
8002:320058     LD (5800), A
8005:C9         RET
8006:           END
Emiting TAP basic loader
Emiting TAP from 8000 to 8005
</pre>

<pre>
ATTRIBUTE_ADR equ $5800
ENTRY_POINT   equ $8000

BLINK_BIT     equ %10000000
INTENSITY_BIT equ %01000000
BLACK_COLOR   equ %000
BLUE_COLOR    equ %001
RED_COLOR     equ %010
MAGENTA_COLOR equ %011
GREEN_COLOR   equ %100
CYAN_COLOR    equ %101
YELLOW_COLOR  equ %110
WHITE_COLOR   equ %111

        org ENTRY_POINT

start:
        ld a,BLINK_BIT | INTENSITY_BIT | (BLUE_COLOR &lt;&lt; 3) | WHITE_COLOR
        ld (ATTRIBUTE_ADR),a
        ret

end ENTRY_POINT
</pre>

<pre>
ATTRIBUTE_ADR   EQU 5800
ENTRY_POINT     EQU 8000
BLINK_BIT       EQU 0080
INTENSITY_BIT   EQU 0040
BLACK_COLOR     EQU 0000
BLUE_COLOR      EQU 0001
RED_COLOR       EQU 0002
MAGENTA_COLOR   EQU 0003
GREEN_COLOR     EQU 0004
CYAN_COLOR      EQU 0005
YELLOW_COLOR    EQU 0006
WHITE_COLOR     EQU 0007
                ORG 8000
8000:           label start
8000:3ECF       LD A, CF
8002:320058     LD (5800), A
8005:C9         RET
8006:           END 8000
Emiting TAP basic loader
Emiting TAP from 8000 to 8005
</pre>

<p><a name="k04"></a></p>
<h2 id="k04">4. Mikroprocesor Zilog Z80 z&nbsp;pohledu programátora</h2>

<p>Programátorský model mikroprocesoru Zilog Z80 se v&nbsp;mnoha ohledech
odlišuje od jeho největšího dobového konkurenta &ndash; mikroprocesoru MOS
6502. Zatímco MOS 6502 byl v&nbsp;mnoha ohledech čistě osmibitovým čipem (i
index registry měly šířku pouhých osmi bitů) a většina operací byla implicitně
prováděna s&nbsp;akumulátorem <strong>A</strong>, je tomu u Z80 jinak. Z80
totiž obsahuje větší počet univerzálních registrů a i když většina ALU operací
vyžadovala jako jeden z&nbsp;operandů akumulátor, další operace se prováděly i
s&nbsp;ostatními registry. Navíc se pracovní registry mohly spojovat do
šestnáctibitových registrových párů a existovalo i několik čistě
šestnáctibitových aritmetických instrukcí (zvýšení a snížení obsahu
registrového páru atd.). K&nbsp;dispozici byla i dvojice čistě 16bitových index
registrů atd.</p>

<img src="http://i.iinfo.cz/images/206/jones-7.png" class="image-177661" width="320" height="256" alt="&#160;" />
<p><i>Obrázek 2: Tento obrázek jsem viděl dosti často.</i></p>

<p>Výsledkem je, že tvorba programů vyžaduje zcela odlišné přístupy. U MOS 6502
se do značné míry využívá nulté stránky paměti (prvních 256 bajtů) zkombinované
s&nbsp;pokročilými adresovacími režimy, zatímco u Z80 se spíše využívá široké
sady pracovních registrů s&nbsp;tím, že adresování je oproti MOS 6502 poněkud
omezeno. Některé přístupy si ostatně budeme moci porovnat s&nbsp;programy (či
jejich částmi) psanými pro MOS 6502 a herní konzoli NES.</p>



<p><a name="k05"></a></p>
<h2 id="k05">5. Sada univerzálních a speciálních registrů</h2>

<p>Mikroprocesor Zilog Z80 obsahuje celkem osmnáct osmibitových registrů a
čtyři šestnáctibitové registry, přičemž všechny registry jsou implementovány
formou statické RAM. Všechny zmíněné registry jsou rozděleny do několika
skupin. Začneme univerzálními registry (i když pojem &bdquo;univerzální&ldquo;
zde má poněkud jiný význam, než u moderních mikroprocesorů, protože mnoho
operací se provádí pouze s&nbsp;akumulátorem). Těch je sedm:</p>

<table>
<tr><th>Registr</th><th>Registr</th><th>Pár</th></tr>
<tr><td>A</td><td>&nbsp;</td><th>(AF)</th></tr>
<tr><td>B</td><td>C</td><td>BC</td></tr>
<tr><td>D</td><td>E</td><td>DE</td></tr>
<tr><td>H</td><td>L</td><td>HL (M)</td></tr>
</table>

<p>Z&nbsp;tabulky je patrné, že vždy dvojici osmibitových registrů lze použít
jako registrový pár, tedy jako 16bitovou hodnotu, například pro adresování atd.
U Intelu 8080 se registrový pár HL nazýval M (<i>memory</i>). Navíc se setkáme
i s&nbsp;registrovým párem AF, což je akumulátor spojený s&nbsp;příznakovými
bity.</p>

<p>Všechny univerzální registry existují ve dvou kopiích &ndash; jsou tedy
zdvojeny (navíc je zdvojen i příznakový registr). To například umožňuje snadnou
tvorbu přerušovacích rutin atd. a současně je adresování registrů
v&nbsp;instrukcích stále velmi krátké (tři bity):</p>

<table>
<tr><th>Registr</th><th>Registr</th></tr>
<tr><td>A'</td><td>&nbsp;</td></tr>
<tr><td>B'</td><td>C'</td></tr>
<tr><td>D'</td><td>E'</td></tr>
<tr><td>H'</td><td>L'</td></tr>
</table>

<img src="http://i.iinfo.cz/images/619/belegost-zx-1.png" class="image-177651" width="320" height="256" alt="&#160;" />
<p><i>Obrázek 3: Belegost pro ZX Spectrum &ndash; loading screen.</i></p>

<p>Všechny další registry mají speciální význam a neexistují jejich kopie:</p>

<table>
<tr><th>Registr</th><th>Šířka</th><th>Popis</th></tr>
<tr><td>IX</td><td>16b</td><td>indexový resp. bázový registr pro adresování</td></tr>
<tr><td>IY</td><td>16b</td><td>indexový resp. bázový registr pro adresování</td></tr>
<tr><td>SP</td><td>16b</td><td>ukazatel na vrchol zásobníku (<i>Stack Pointer</i>)</td></tr>
<tr><td>PC</td><td>16b</td><td>programový čítač (<i>Program Counter</i>)</td></tr>
<tr><td>I</td><td>8b</td><td>vyšší bajt adresy tabulky obsluhy přerušení</td></tr>
<tr><td>R</td><td>8b(7b)</td><td>automaticky zvyšovaný čítač pro občerstvování (<i>Refresh</i>) pamětí DRAM</td></tr>
</table>

<img src="http://i.iinfo.cz/images/619/belegost-zx-4.png" class="image-177654" width="320" height="256" alt="&#160;" />
<p><i>Obrázek 4: Belegost pro ZX Spectrum &ndash; grafické uživatelské
rozhraní hry.</i></p>



<p><a name="k06"></a></p>
<h2 id="k06">6. Sada instrukcí mikroprocesoru Z80</h2>

<p>Procesor Zilog Z80 podporuje všechny instrukce svého ideového předchůdce
Intelu 8080 a navíc přidává mnoho instrukcí dalších; další instrukce byly
naopak upraveny tak, že akceptují další operandy. Navíc došlo
k&nbsp;přejmenování mnemotechnických zkratek instrukcí (viz <a
href="#k07">navazující kapitolu</a>), což je z&nbsp;pohledu programátora asi
jen dobře (8080 totiž obsahoval zbytečné &bdquo;špeky&ldquo; typu LXI, LHLD,
SPHL atd.). Celou instrukční sadu lze zhruba rozdělit do těchto kategorií:</p>

<table>
<tr><th>Přesuny osmibitových operandů (zde nazýváno <i>load</i>, nikoli <i>move</i>)</th></tr>
<tr><td>Přesuny šestnáctibitových operandů</td></tr>
<tr><td>Blokové přesuny a vyhledávání</td></tr>
<tr><td>Výměna operandů (<i>exchange</i>)</td></tr>
<tr><td>Osmibitové aritmetické instrukce</td></tr>
<tr><td>Šestnáctibitové aritmetické instrukce</td></tr>
<tr><td>Rotace a bitové posuny</td></tr>
<tr><td>Vynulování, nastavení a test bitů</td></tr>
<tr><td>Řízení CPU atd.</td></tr>
<tr><td>Skoky (podmíněné/nepodmíněné, absolutní/relativní)</td></tr>
<tr><td>Volání podprogramů a návrat z&nbsp;podprogramů</td></tr>
<tr><td>Operace se vstupními a výstupními porty</td></tr>
</table>

<p>Dnes si popíšeme pouze malou část instrukcí; podrobnější přehled bude uveden
příště.</p>



<p><a name="k07"></a></p>
<h2 id="k07">7. Proč se jména instrukcí na Z80 odlišují od Intel 8080?</h2>

<p>I když je mikroprocesor Zilog Z80 do značné míry binárně zpětně kompatibilní
s&nbsp;mikroprocesorem Intel 8080, používají se v&nbsp;assembleru odlišné názvy
instrukcí. Je tomu tak ze dvou důvodů. Prvním důvodem je, že společnost Intel
tvrdila, že drží vlastnická práva na mnemotechnické zkratky instrukcí (které
původně pochází z&nbsp;Datapointu 2200 a byly poměrně náhodně doplňovány o
další instrukce), druhý důvod spočívá ve snaze o zjednodušení celé instrukční
sady a o dosažení alespoň zdání její ortogonality (například se již nerozlišuje
mezi instrukcemi s&nbsp;registrem a osmibitovou konstantou atd.). Někdy je
ovšem nové jméno instrukce maličko matoucí, což je případ <strong>CMP</strong>
versus <strong>CP</strong>, která měla původně jiný význam. Celá
&bdquo;Rosettská deska&ldquo; je dostupná na adrese <a
href="https://retroprogramming.it/2021/02/8080-z80-instruction-set/">https://retroprogramming.it/2021/02/8080-z80-instruction-set/</a>
a v&nbsp;následující tabulce jsou změny přehledně vypsány (vynechávám ovšem
variant s&nbsp;dalšími pracovními registry atd.):</p>

<table>
<tr><th>Zápis podle Intel 8080</th><th>Zápis podle Zilog Z80</th><th>Poznámka</th></tr>
<tr><td>XCHG        </td><td>EX   DE,HL</td><td>náhrada za obecnější instrukci EX</td></tr>
<tr><td>XTHL        </td><td>EX   (SP),HL</td><td>náhrada za obecnější instrukci EX</td></tr>
<tr><td>ADD  A      </td><td>ADD  A,A</td><td>explicitní uvedení obou operandů</td></tr>
<tr><td>ADD  B      </td><td>ADD  A,B</td><td>dtto</td></tr>
<tr><td>ADD  M      </td><td>ADD  A,(HL)</td><td>explicitní uvedení adresovacího režimu a registrového páru</td></tr>
<tr><td>SBB  A      </td><td>SBC  A</td><td>explicitní uvedení obou operandů</td></tr>
<tr><td>SBB  B      </td><td>SBC  B</td><td>dtto</td></tr>
<tr><td>SBB  M      </td><td>SBC  (HL)</td><td>explicitní uvedení adresovacího režimu a registrového páru</td></tr>
<tr><td>DAD  B      </td><td>ADD  HL,BC</td><td>explicitní uvedení obou registrových párů, náhrada za obecnější instrukci ADD</td></tr>
<tr><td>DAD  D      </td><td>ADD  HL,DE</td><td>dtto</td></tr>
<tr><td>DAD  H      </td><td>ADD  HL,HL</td><td>dtto</td></tr>
<tr><td>DAD  SP     </td><td>ADD  HL,SP</td><td>dtto</td></tr>
<tr><td>INR  A      </td><td>INC  A</td><td>náhrada za obecnější instrukci INC</td></tr>
<tr><td>INR  B      </td><td>INC  B</td><td>náhrada za obecnější instrukci INC</td></tr>
<tr><td>INR  M      </td><td>INC  (HL)</td><td>náhrada za obecnější instrukci INC, zápis registrového páru</td></tr>
<tr><td>DCR  A      </td><td>DEC  A</td><td>dtto jako DCR/DEC</td></tr>
<tr><td>DCR  B      </td><td>DEC  B</td><td>dtto jako DCR/DEC</td></tr>
<tr><td>DCR  M      </td><td>DEC  (HL)</td><td>dtto jako DCR/DEC</td></tr>
<tr><td>INX  B      </td><td>INC  BC</td><td>explicitní uvedení obou registrového páru, náhrada za obecnější instrukci INC</td></tr>
<tr><td>INX  D      </td><td>INC  DE</td><td>dtto</td></tr>
<tr><td>INX  H      </td><td>INC  HL</td><td>dtto</td></tr>
<tr><td>INX  SP     </td><td>INC  SP</td><td>dtto</td></tr>
<tr><td>DCX  B      </td><td>DEC  BC</td><td>explicitní uvedení obou registrového páru, náhrada za obecnější instrukci DEC</td></tr>
<tr><td>DCX  D      </td><td>DEC  DE</td><td>dtto</td></tr>
<tr><td>DCX  H      </td><td>DEC  HL</td><td>dtto</td></tr>
<tr><td>DCX  SP     </td><td>DEC  SP</td><td>dtto</td></tr>
<tr><td>RLC         </td><td>RLCA</td><td>&nbsp;</td></tr>
<tr><td>RRC         </td><td>RRCA</td><td>&nbsp;</td></tr>
<tr><td>RAL         </td><td>RLA</td><td>&nbsp;</td></tr>
<tr><td>RAR         </td><td>RRA</td><td>&nbsp;</td></tr>
<tr><td>ANA  A      </td><td>AND  A</td><td>náhrada za obecnější instrukci AND</td></tr>
<tr><td>ANA  B      </td><td>AND  B</td><td>dtto</td></tr>
<tr><td>ANA  M      </td><td>AND (HL)</td><td>explicitní uvedení adresovacího režimu a registrového páru</td></tr>
<tr><td>ANI  byte   </td><td>AND  byte</td><td>náhrada za obecnější instrukci AND i pro konstanty</td></tr>
<tr><td>XRA  A      </td><td>XOR  A</td><td>náhrada za obecnější instrukci XOR</td></tr>
<tr><td>XRA  B      </td><td>XOR  B</td><td>dtto</td></tr>
<tr><td>XRA  M      </td><td>XOR  (HL)</td><td>explicitní uvedení adresovacího režimu a registrového páru</td></tr>
<tr><td>XRI  byte   </td><td>XOR  byte</td><td>náhrada za obecnější instrukci XOR</td></tr>
<tr><td>ORA  A      </td><td>OR   A</td><td>náhrada za obecnější instrukci OR i pro konstanty</td></tr>
<tr><td>ORA  B      </td><td>OR   B</td><td>dtto</td></tr>
<tr><td>ORA  M      </td><td>OR   (HL)</td><td>explicitní uvedení adresovacího režimu a registrového páru</td></tr>
<tr><td>ORI  byte   </td><td>OR   byte</td><td>náhrada za obecnější instrukci OR</td></tr>
<tr><td>CMP  A      </td><td>CP   A</td><td>náhrada za obecnější instrukci CP</td></tr>
<tr><td>CMP  B      </td><td>CP   B</td><td>dtto</td></tr>
<tr><td>CMP  M      </td><td>CP   (HL)</td><td>explicitní uvedení adresovacího režimu a registrového páru</td></tr>
<tr><td>CPI  byte   </td><td>CP   byte</td><td>náhrada za obecnější instrukci CP i pro konstanty</td></tr>
<tr><td>JMP  address</td><td>JP   address</td><td>všechny skoky jsou nyní zapisovány formou JP+případná podmínka</td></tr>
<tr><td>JNZ  address</td><td>JP   NZ,address</td><td>dtto</td></tr>
<tr><td>JZ   address</td><td>JP   Z,address</td><td>dtto</td></tr>
<tr><td>JNC  address</td><td>JP   NC,address</td><td>dtto</td></tr>
<tr><td>JC   address</td><td>JP   C,address</td><td>dtto</td></tr>
<tr><td>JPO  address</td><td>JP   PO,address</td><td>dtto</td></tr>
<tr><td>JPE  address</td><td>JP   PE,address</td><td>dtto</td></tr>
<tr><td>JP   address</td><td>JP   P,address</td><td>dtto</td></tr>
<tr><td>JM   address</td><td>JP   M,address</td><td>dtto</td></tr>
<tr><td>PCHL        </td><td>JP   (HL)</td><td>nepřímý skok na adresu uloženou v&nbsp;registrovém páru</td></tr>
<tr><td>CALL address</td><td>CALL address</td><td></td></tr>
<tr><td>CNZ  address</td><td>CALL NZ,address</td><td>všechna volání jsou nyní zapisována formou CALL+případná podmínka</td></tr>
<tr><td>CZ   address</td><td>CALL Z,address</td><td>dtto</td></tr>
<tr><td>CNC  address</td><td>CALL NC,address</td><td>dtto</td></tr>
<tr><td>CC   address</td><td>CALL C,address</td><td>dtto</td></tr>
<tr><td>CPO  address</td><td>CALL PO,address</td><td>dtto</td></tr>
<tr><td>CPE  address</td><td>CALL PE,address</td><td>dtto</td></tr>
<tr><td>CP   address</td><td>CALL P,address</td><td>dtto</td></tr>
<tr><td>CM   address</td><td>CALL M,address</td><td>dtto</td></tr>
<tr><td>RNZ         </td><td>RET  NZ</td><td>všechny návraty z&nbsp;podprogramů jsou nyní zapisovány formou RET+případná podmínka</td></tr>
<tr><td>RZ          </td><td>RET  Z</td><td>dtto</td></tr>
<tr><td>RNC         </td><td>RET  NC</td><td>dtto</td></tr>
<tr><td>RC          </td><td>RET  C</td><td>dtto</td></tr>
<tr><td>RPO         </td><td>RET  PO</td><td>dtto</td></tr>
<tr><td>RPE         </td><td>RET  PE</td><td>dtto</td></tr>
<tr><td>RP          </td><td>RET  P</td><td>dtto</td></tr>
<tr><td>RM          </td><td>RET  M</td><td>dtto</td></tr>
<tr><td>RST  0      </td><td>RST  0</td><td>explicitní uvedení adresy vektoru</td></tr>
<tr><td>RST  1      </td><td>RST  8</td><td>dtto</td></tr>
<tr><td>RST  2      </td><td>RST  10H</td><td>dtto</td></tr>
<tr><td>RST  3      </td><td>RST  18H</td><td>dtto</td></tr>
<tr><td>RST  4      </td><td>RST  20H</td><td>dtto</td></tr>
<tr><td>RST  5      </td><td>RST  28H</td><td>dtto</td></tr>
<tr><td>RST  6      </td><td>RST  30H</td><td>dtto</td></tr>
<tr><td>RST  7      </td><td>RST  38H</td><td>dtto</td></tr>
<tr><td>PUSH B      </td><td>PUSH BC</td><td>explicitní uvedení celého jména registrového páru</td></tr>
<tr><td>PUSH D      </td><td>PUSH DE</td><td>dtto</td></tr>
<tr><td>PUSH H      </td><td>PUSH HL</td><td>dtto</td></tr>
<tr><td>PUSH PSW    </td><td>PUSH AF</td><td>dtto (náhrada za <i>program status word</i>)</td></tr>
<tr><td>POP  B      </td><td>POP  BC</td><td>explicitní uvedení celého jména registrového páru</td></tr>
<tr><td>POP  D      </td><td>POP  DE</td><td>dtto</td></tr>
<tr><td>POP  H      </td><td>POP  HL</td><td>dtto</td></tr>
<tr><td>POP  PSW    </td><td>POP  AF</td><td>dtto (náhrada za <i>program status word</i>)</td></tr>
<tr><td>IN   byte   </td><td>IN   A,(byte)</td><td>explicitní uvedení operandu + naznačení nepřímé adresace</td></tr>
<tr><td>OUT  byte   </td><td>OUT  (byte),A</td><td>dtto</td></tr>
</table>

<p><div class="rs-tip-major">Poznámka: instrukce <strong>LD</strong>, která na
Zilogu Z80 nahrazuje hned několik instrukcí mikroprocesoru Intel 8080, bude
uvedena <a href="#k08">v&nbsp;navazující kapitole</a>.</div></p>



<p><a name="k08"></a></p>
<h2 id="k08">8. Adresovací režimy a všudypřítomná instrukce <strong>LD</strong></h2>

<p>Největší změny v&nbsp;instrukční sadě Z80 oproti 8080 se týkají instrukcí
pro přenosy dat mezi registry, mezi registrem a pamětí, mezi registrovými páry
a taktéž instrukcí pro načtení konstanty do registru nebo registrového páru.
Celá sada původně odlišných instrukcí byla nahrazena jedinou instrukcí
<strong>LD</strong> neboli <i>load</i>. Kromě toho došlo k&nbsp;náhradě
pseudoregistru <strong>M</strong> za <strong>(HL)</strong>, protože se nejedná
o nic jiného, než o přístup k&nbsp;obsahu adresy uložené právě
v&nbsp;registrovém páru <strong>HL</strong> (který navíc nikdy neměl výsadní
postavení &ndash; viz použití dalších párů):</p>

<tr><th>Zápis podle Intel 8080</th><th>Zápis podle Zilog Z80</th><th>Poznámka</th></tr>
<tr><td>MOV  A,A    </td><td>LD   A,A</td><td>náhrada jména instrukce</td></tr>
<tr><td>MOV  A,B    </td><td>LD   A,B</td><td>dtto</td></tr>
<tr><td>MOV  A,M    </td><td>LD   A,(HL)</td><td>náhrada <strong>M</strong> za explicitní jméno registrového páru</td></tr>
<tr><td>LDAX B      </td><td>LD   A,(BC)</td><td>explicitní uvedení celého registrového páru i způsobu adresování</td></tr>
<tr><td>LDAX D      </td><td>LD   A,(DE)</td><td>dtto</td></tr>
<tr><td>LDA  word   </td><td>LD   A,(word)</td><td>explicitní uvedení způsobu adresování</td></tr>
<tr><td>MOV  M,A    </td><td>LD   (HL),A</td><td>náhrada <strong>M</strong> za explicitní jméno registrového páru</td></tr>
<tr><td>MVI  A,byte </td><td>LD   A,byte</td><td>už se nerozlišuje mezi MOVE IMMEDIATE a prostou instrukcí LD s&nbsp;konstantou</td></tr>
<tr><td>STAX B      </td><td>LD   (BC),A</td><td>explicitní uvedení celého registrového páru i způsobu adresování</td></tr>
<tr><td>STAX D      </td><td>LD   (DE),A</td><td>dtto</td></tr>
<tr><td>LXI  B,word </td><td>LD   BC,word</td><td>už se nerozlišuje mezi LOAD IMMEDIATE a prostou instrukcí LD s&nbsp;konstantou</td></tr>
<tr><td>LXI  SP,word</td><td>LD   SP,word</td><td>dtto</td></tr>
<tr><td>LHLD word   </td><td>LD   HL,(word)</td><td>explicitní uvedení celého registrového páru i způsobu adresování</td></tr>
<tr><td>SHLD word   </td><td>LD   (word),HL</td><td>explicitní uvedení celého registrového páru i způsobu adresování</td></tr>
<tr><td>SPHL        </td><td>LD   SP,HL</td><td>náhrada univerzálnější instrukcí</td></tr>
</table>

<p><div class="rs-tip-major">Poznámka: původní &bdquo;poslepovaná&ldquo; sada
instrukcí 8080 (v&nbsp;podstatě sada instrukcí pro 8008 rozšířená o 16bitové
instrukce) se tak opět stává více ortogonální.</div></p>

<p>Navíc došlo i k&nbsp;přidání nového adresovacího režimu
<strong>(IX+d)</strong> a <strong>(IY+d)</strong>, v&nbsp;němž nové index
registry obsahují bázovou adresu, ke které se přičítá zadaná osmibitová
konstanta.</p>



<p><a name="k09"></a></p>
<h2 id="k09">9. Vybrané instrukce použité v&nbsp;demonstračních příkladech</h2>

<p>V&nbsp;demonstračních příkladech uvedených v&nbsp;následujících kapitolách
je použito pouze několik instrukcí. Ty jsou, společně se stručným popisem,
vypsány v&nbsp;následující tabulce:</p>

<table>
<tr><th>Strojový kód</th><th>Instrukce</th><th>Operandy</th><th>Stručný popis instrukce</th></tr>
<tr><td>3E00    </td><td>LD A, 00     </td><td></td><td></td></tr>
<tr><td>0600    </td><td>LD B, 00     </td><td></td><td></td></tr>
<tr><td>78      </td><td>LD A, B      </td><td></td><td></td></tr>
<tr><td>47      </td><td>LD B, A      </td><td></td><td></td></tr>
<tr><td>45      </td><td>LD B, L      </td><td></td><td></td></tr>
<tr><td>010002  </td><td>LD BC, 0200  </td><td></td><td></td></tr>
<tr><td>210058  </td><td>LD HL, 5800  </td><td></td><td></td></tr>
<tr><td>DD210058</td><td>LD IX, 5800  </td><td></td><td></td></tr>
<tr><td>FD210058</td><td>LD IY, 5800  </td><td></td><td></td></tr>
<tr><td>320058  </td><td>LD (5800), A </td><td></td><td></td></tr>
<tr><td>77      </td><td>LD (HL), A   </td><td></td><td></td></tr>
<tr><td>75      </td><td>LD (HL), L   </td><td></td><td></td></tr>
<tr><td>DD7700  </td><td>LD (IX+00), A</td><td></td><td></td></tr>
<tr><td>FD7700  </td><td>LD (IY+00), A</td><td></td><td></td></tr>
<tr><td>3C      </td><td>INC A        </td><td></td><td></td></tr>
<tr><td>DD23    </td><td>INC IX       </td><td></td><td></td></tr>
<tr><td>FD23    </td><td>INC IY       </td><td></td><td></td></tr>
<tr><td>3D      </td><td>DEC A        </td><td></td><td></td></tr>
<tr><td>05      </td><td>DEC B        </td><td></td><td></td></tr>
<tr><td>0B      </td><td>DEC BC       </td><td></td><td></td></tr>
<tr><td>2C      </td><td>INC L        </td><td></td><td></td></tr>
<tr><td>23      </td><td>INC HL       </td><td></td><td></td></tr>
<tr><td>AF      </td><td>XOR A        </td><td></td><td></td></tr>
<tr><td>B1      </td><td>OR C         </td><td></td><td></td></tr>
<tr><td>C20580  </td><td>JP NZ, 8005  </td><td></td><td></td></tr>
<tr><td>20FA    </td><td>JR NZ, 8007  </td><td></td><td></td></tr>
<tr><td>10F8    </td><td>DJNZ 8006    </td><td></td><td></td></tr>
<tr><td>C9      </td><td>RET          </td><td></td><td></td></tr>
</table>



<p><a name="k10"></a></p>
<h2 id="k10">10. Jednoduchá počítaná programová smyčka: naivní varianta</h2>

<p>Ve druhé části dnešního článku si některé operace vyzkoušíme na praktických
příkladech. Začneme zdánlivě triviální úlohou, která by na moderních čipech
(AArch64, RISC-V apod.) měla jen jedno správné řešení. Jak ovšem uvidíme dále,
na Zilogu Z80 je situace z&nbsp;pohledu programátora mnohem zábavnější a úlohu
lze řešit různými způsoby.</p>

<p>Samotné zadání je jednoduché: máme vyplnit 256bajtový blok paměti od adresy
0x5800 sekvencí hodnot 0 až 255. Připomeňme si, že od adresy 0x5800 začíná blok
barvových atributů, takže po spuštění programu ihned uvidíme, zda náš program
pracuje korektně. Výsledek by měl vypadat následovně (vyplňujeme jen barvové
atributy, takže text vypisovaný interpretrem BASICu do změněné oblasti, je jen
třešničkou na dortu):</p>

*** image ***
<p><i>Obrázek X: První třetina atributové paměti vyplněná hodnotami 0..255
(varianta po spuštění se standardní ROM, první obrázek).</i></p>

<p>Nastavení nejvyššího bitu atributu vede k&nbsp;blikání dané oblasti
8&times;8 pixelů:</p>

*** image ***
<p><i>Obrázek X: První třetina atributové paměti vyplněná hodnotami 0..255
(varianta po spuštění se standardní ROM, po &bdquo;blink&ldquo;).</i></p>

<p>Varianta po spuštění s&nbsp;emulátorem s&nbsp;ROM s&nbsp;OpenSE BASICem:</p>

<p><i>Obrázek X: Příklad spuštění v&nbsp;emulátoru s&nbsp;OpenSE BASICem.</i></p>

<p><i>Obrázek X: Příklad spuštění v&nbsp;emulátoru s&nbsp;OpenSE BASICem.</i></p>

<p>Podívejme se nyní na poněkud naivní (nebo spíše přímočarý) způsob realizace
programové smyčky s&nbsp;řešením výše uvedeného zadání. Ve smyčce se používá
dvojregistr <strong>HL</strong> ve funkci ukazatele do právě zapisované
paměťové buňky, takže se v&nbsp;každé iteraci jeho hodnota zvyšuje o jedničku.
Dále používáme registr <strong>A</strong>, jenž obsahuje zapisovanou hodnotu
(opět musíme obsah registru postupně zvyšovat) a registr <strong>B</strong>
slouží jako počitadlo smyčky, které se naopak postupně snižuje od hodnoty 0
(resp.&nbsp;256, protože první dekrementace nuly vrátí výsledek 255)
k&nbsp;nule. Teprve po dosažení nuly operací <strong>dec B</strong> se nastaví
příznakový bit &bdquo;zero&ldquo; a smyčka se ukončí:</p>

<pre>
ATTRIBUTE_ADR equ $5800
ENTRY_POINT   equ $8000
&nbsp;
        org ENTRY_POINT
&nbsp;
start:
        ld hl, ATTRIBUTE_ADR  <i>; adresa pro zápis</i>
        ld a, 0               <i>; zapisovaná hodnota</i>
        ld b, 0               <i>; počitadlo smyčky</i>
&nbsp;
loop:
        ld (hl),a             <i>; zápis hodnoty na adresu (HL)</i>
        inc hl                <i>; zvýšení adresy</i>
        inc a                 <i>; zvýšení zapisované hodnoty</i>
        dec b                 <i>; snížení hodnoty počitadla</i>
        jp NZ, loop           <i>; skok pokud se ještě nedosáhlo nuly</i>
        ret
&nbsp;
end ENTRY_POINT
</pre>

<p><div class="rs-tip-major">Poznámka: už nyní jste možná našli mnoho částí
kódu, které se dají zkrátit či urychlit.</div></p>



<p><a name="k11"></a></p>
<h2 id="k11">11. Celková délka kódu, časování instrukcí</h2>

<p>Nyní se podívejme na to, jakým způsobem se předchozí programová smyčka
přeložila do strojového kódu:</p>

<pre>
ATTRIBUTE_ADR   EQU 5800
ENTRY_POINT     EQU 8000
                ORG 8000
8000:           label start
8000:210058     LD HL, 5800
8003:3E00       LD A, 00
8005:0600       LD B, 00
8007:           label loop
8007:77         LD (HL), A
8008:23         INC HL
8009:3C         INC A
800A:05         DEC B
800B:C20780     JP NZ, 8007
800E:C9         RET
800F:           END 8000
Emiting TAP basic loader
Emiting TAP from 8000 to 800E
</pre>

<p>Výsledný strojový kód má délku patnácti bajtů (což později dokážeme zkrátit
na devět bajtů). A jak je tomu s&nbsp;rychlostí výpočtu, resp.&nbsp;počtem
cyklů na instrukci? Pomůže nám následující velmi užitečná stránka <a
href="https://clrhome.org/table/">https://clrhome.org/table/</a>, protože
jednou z&nbsp;výhod osmibitových mikroprocesorů je, že počet cyklů lze spočítat
poměrně snadno (nejsou superskalární, nemají spekulativní provádění instrukcí
ani branch delay sloty):</p>

<table>
<tr><th>Instrukce</th><th>Počet cyklů</th><th>&times; počet iterací</th></tr>
<tr><td>ld hl, adresa</td><td>10</td><td>10</td></tr>
<tr><td>ld a, 0      </td><td>7</td><td>7</td></tr>
<tr><td>ld b, 0      </td><td>7</td><td>7</td></tr>
<tr><td>ld (hl),a    </td><td>7</td><td>1792</td></tr>
<tr><td>inc hl       </td><td>6</td><td>1536</td></tr>
<tr><td>inc a        </td><td>4</td><td>1024</td></tr>
<tr><td>dec b        </td><td>4</td><td>1024</td></tr>
<tr><td>jp NZ, loop  </td><td>10</td><td>2560</td></tr>
<tr><td>ret          </td><td>10</td><td>10</td></tr>
<tr><td>Celkem:      </td><td>&nbsp;</td><td>7970</td></tr>
</table>

<p>Teoreticky by tedy smyčka měla být dokončena za 7970 cyklů. V&nbsp;praxi to
bude více, a to kvůli obsluhám přerušení a přístupům čipu ULA do paměti (což si
vysvětlíme později).</p>

<p><div class="rs-tip-major">Poznámka: pokud nahradíme <strong>JP</strong> za
<strong>JR</strong>, ušetříme jeden bajt, ale doba trvání se zvýší o
255&times;2-7=503 cyklů.</div></p>



<p><a name="k12"></a></p>
<h2 id="k12">12. Zkrácení kódu pro vynulování použitých pracovních registrů</h2>

<p><a href="#k11">V&nbsp;první verzi programu</a> se před vstupem do programové
smyčky vynulovaly osmibitové pracovní registry <strong>A</strong> i
<strong>B</strong> instrukcemi, které jsou uloženy ve dvou bajtech (druhý bajt
pochopitelně obsahuje zapisovanou hodnotu):</p>

<pre>
8003:3E00       LD A, 00
8005:0600       LD B, 00
</pre>

<p>Ovšem stejného výsledku můžeme dosáhnout malým trikem: vynulováním obsahu
registru <strong>A</strong> například instrukcí <strong>XOR</strong> (se sebou
samým) nebo <strong>SUB</strong> (opět se sebou samým) a následně přesunout
výslednou nulovou hodnotu do registru <strong>B</strong> instrukcí <strong>LD
B,A</strong>. Upravený zdrojový kód příkladu bude nyní vypadat následovně:</p>

<pre>
ATTRIBUTE_ADR equ $5800
ENTRY_POINT   equ $8000
&nbsp;
        org ENTRY_POINT
&nbsp;
start:
        ld hl, ATTRIBUTE_ADR  <i>; adresa pro zápis</i>
        xor a                 <i>; zapisovaná hodnota</i>
        ld b, a               <i>; počitadlo smyčky</i>
&nbsp;
loop:
        ld (hl),a             <i>; zápis hodnoty na adresu (HL)</i>
        inc hl                <i>; zvýšení adresy</i>
        inc a                 <i>; zvýšení zapisované hodnoty</i>
        dec b                 <i>; snížení hodnoty počitadla</i>
        jp NZ, loop           <i>; skok pokud se ještě nedosáhlo nuly</i>
        ret
&nbsp;
end ENTRY_POINT
</pre>

<p>Po překladu takto upraveného příkladu je zřejmé, že program bude kratší o
dva bajty. Tato úspora z&nbsp;dnešního pohledu nemusí znamenat mnoho, ale na
počítačích s&nbsp;16kB nebo 48kB paměti RAM se i podobné
&bdquo;maličkosti&ldquo; mohou postupně nasčítat:</p>

<pre>
ATTRIBUTE_ADR   EQU 5800
ENTRY_POINT     EQU 8000
                ORG 8000
8000:           label start
8000:210058     LD HL, 5800
8003:<strong>AF</strong>         XOR A
8004:<strong>47</strong>         LD B, A
8005:           label loop
8005:77         LD (HL), A
8006:23         INC HL
8007:3C         INC A
8008:05         DEC B
8009:C20580     JP NZ, 8005
800C:C9         RET
800D:           END 8000
Emiting TAP basic loader
Emiting TAP from 8000 to 800C
</pre>

<p>A jak je to s&nbsp;urychlením celého programu? Porovnejme si oba
přístupy:</p>

<table>
<tr><th>Instrukce</th><th>Cyklů</th><th>Instrukce</th><th>Cyklů</th></tr>
<tr><td>ld a, 0</td><td>7</td><td>xor a</td><td>4</td></tr>
<tr><td>ld b, 0</td><td>7</td><td>ld b, a</td><td>4</td></tr>
<tr><td>Celkem:</td><td>14</td><td>Celkem:</td><td>8</td></tr>
</table>

<p><div class="rs-tip-major">Poznámka: jedná se o inicializaci smyčky, která se
neopakuje, takže reálná úspora nebude velká, pokud se ovšem progrm nevolá
například při každém snímku atd.</div></p>



<p><a name="k13"></a></p>
<h2 id="k13">13. Optimalizace skoku na konci smyčky (instrukce <strong>DJNZ</strong>)</h2>

<p>Další optimalizace, kterou se můžeme pokusit provést, je náhrada dvojice
instrukcí:</p>

<pre>
        dec b                 <i>; snížení hodnoty počitadla</i>
        jp NZ, loop           <i>; skok pokud se ještě nedosáhlo nuly</i>
</pre>

<p>Za jedinou instrukci:</p>

<pre>
        djnz loop             <i>; kombinace dec b + jp NZ, loop</i>
                              <i>; snížení hodnoty počitadla</i>
                              <i>; skok pokud se ještě nedosáhlo nuly</i>
</pre>

<p>Instrukce <strong>DJNZ</strong> implicitně pracuje s&nbsp;registrem
<strong>B</strong>, takže další změny v&nbsp;programu již nejsou nutné
(mimochodem, na 8086 se v&nbsp;podobné instrukci <strong>LOOP</strong> pracuje
s&nbsp;registrem <strong>CX</strong>, což se lépe pamatuje protože
C=counter).</p>

<p>Upravený program založený na instrukci <strong>DJNZ</strong> pro řízení
průchodu smyčkou nyní bude vypadat takto:</p>

<pre>
ATTRIBUTE_ADR equ $5800
ENTRY_POINT   equ $8000
&nbsp;
        org ENTRY_POINT
&nbsp;
start:
        ld hl, ATTRIBUTE_ADR  <i>; adresa pro zápis</i>
        xor a                 <i>; zapisovaná hodnota</i>
        ld b, a               <i>; počitadlo smyčky</i>
&nbsp;
loop:
        ld (hl),a             <i>; zápis hodnoty na adresu (HL)</i>
        inc hl                <i>; zvýšení adresy</i>
        inc a                 <i>; zvýšení zapisované hodnoty</i>
        djnz loop             <i>; kombinace dec b + jp NZ, loop</i>
                              <i>; snížení hodnoty počitadla</i>
                              <i>; skok pokud se ještě nedosáhlo nuly</i>
        ret
&nbsp;
end ENTRY_POINT
</pre>

<p>Po překladu zjistíme, že opět došlo ke zkrácení celkové délky strojového
kódu, nyní na jedenáct bajtů:</p>

<pre>
ATTRIBUTE_ADR   EQU 5800
ENTRY_POINT     EQU 8000
                ORG 8000
8000:           label start
8000:210058     LD HL, 5800
8003:AF         XOR A
8004:47         LD B, A
8005:           label loop
8005:77         LD (HL), A
8006:23         INC HL
8007:3C         INC A
8008:10FB       DJNZ 8005
800A:C9         RET
800B:           END 8000
Emiting TAP basic loader
Emiting TAP from 8000 to 800A
</pre>

<p>A jak je to s&nbsp;urychlením celého programu? Porovnejme si oba
přístupy:</p>

<table>
<tr><th>Instrukce</th><th>Cyklů</th><th>Instrukce</th><th>Cyklů</th></tr>
<tr><td>dec b</td><td>4</td><td>djnz loop</td><td>13 (8)</td></tr>
<tr><td>jp NZ, loop</td><td>10</td><td>&nbsp;</td><td>&nbsp;</td></tr>
<tr><td>Celkem:</td><td>256&times;14=3584</td><td>Celkem:</td><td>255&times;13+8=3323</td></tr>
</table>

<p>V&nbsp;případě instrukce DJNZ se délka provádění odvíjí od toho, zda ke
skoku dojde či nikoli. Při opakování smyčky bude tato instrukce trvat 13 taktů,
po posledním průchodu jen 8 taktů.</p>



<p><a name="k14"></a></p>
<h2 id="k14">14. Optimalizace využití pracovních registrů</h2>

<p>Program je možné modifikovat ještě jiným způsobem. Postačuje si totiž
uvědomit, že pokud do registrového páru <strong>HL</strong> zapisujeme hodnotu
0x5800, znamená to vlastně, že do registru <strong>H</strong> se zapíše hodnota
0x58 a do registru <strong>L</strong> hodnota 0. To vlastně znamená, že registr
<strong>L</strong>, jenž je postupně zvyšován o jedničku, může být použit i pro
zápis atributu namísto registru <strong>A</strong>. Program tedy můžeme změnit
takto:</p>

<pre>
ATTRIBUTE_ADR equ $5800
ENTRY_POINT   equ $8000
&nbsp;
        org ENTRY_POINT
&nbsp;
start:
        ld hl, ATTRIBUTE_ADR  <i>; adresa pro zápis</i>
        ld b, l               <i>; zapisovaná hodnota + počitadlo smyčky</i>
&nbsp;
loop:
        ld (hl),l             <i>; zápis hodnoty na adresu (HL)</i>
        inc hl                <i>; zvýšení adresy i zapisované hodnoty</i>
        djnz loop             <i>; kombinace dec b + jp NZ, loop</i>
                              <i>; snížení hodnoty počitadla</i>
                              <i>; skok pokud se ještě nedosáhlo nuly</i>
        ret
&nbsp;
end ENTRY_POINT
</pre>

<p>Opět pochopitelně dojde ke zkrácení výsledného strojového kódu, a to na
pouhých devět bajtů:</p>

<pre>
ATTRIBUTE_ADR   EQU 5800
ENTRY_POINT     EQU 8000
                ORG 8000
8000:           label start
8000:210058     LD HL, 5800
8003:45         LD B, L
8004:           label loop
8004:75         LD (HL), L
8005:23         INC HL
8006:10FC       DJNZ 8004
8008:C9         RET
8009:           END 8000
Emiting TAP basic loader
Emiting TAP from 8000 to 8008
</pre>

<p>Na tomto místě si navíc můžeme uvědomit, že nemá smysl zvyšovat hodnotu
registrového páru <strong>HL</strong>, ale pouze registru <strong>L</strong>,
protože blok má délku jen 256 bajtů. Výsledek nebude kratší z&nbsp;hlediska
obsazeného místa paměti, ale z&nbsp;hlediska rychlosti výpočtu ano (ušetříme
6-4=2 cykly v&nbsp;každé iteraci, tedy 512 cyklů):</p>

<pre>
ATTRIBUTE_ADR equ $5800
ENTRY_POINT   equ $8000
&nbsp;
        org ENTRY_POINT
&nbsp;
start:
        ld hl, ATTRIBUTE_ADR  <i>; adresa pro zápis</i>
        ld b, l               <i>; zapisovaná hodnota + počitadlo smyčky</i>
&nbsp;
loop:
        ld (hl),l             <i>; zápis hodnoty na adresu (HL)</i>
        inc l                 <i>; zvýšení adresy i zapisované hodnoty</i>
        djnz loop             <i>; kombinace dec b + jp NZ, loop</i>
                              <i>; snížení hodnoty počitadla</i>
                              <i>; skok pokud se ještě nedosáhlo nuly</i>
        ret
&nbsp;
end ENTRY_POINT
</pre>



<p><a name="k15"></a></p>
<h2 id="k15">15. Náhrada registrového páru HL za index registry IX nebo IY?</h2>

<p><a href="#k05">V&nbsp;páté kapitole</a> jsme si mj.&nbsp;řekli, že
mikroprocesor Zilog Z80 obsahuje i dvojici index registrů nazvaných
<strong>IX</strong> a <strong>IY</strong>. Jedná se o šestnáctibitové registry,
které mohou kromě indexů obsahovat i bázové adresy, protože u některých
instrukcí lze použít adresování typu <i>bázová adrese+offset</i>. Můžeme tedy
tyto registry použít v&nbsp;naší smyčce namísto registrového páru
<strong>HL</strong>? Samozřejmě to možné je, ovšem ztratíme možnost triku
&ndash; přímého přístupu ke spodnímu bajtu registrového páru
<strong>HL</strong>:</p>

<pre>
ATTRIBUTE_ADR equ $5800
ENTRY_POINT   equ $8000
&nbsp;
        org ENTRY_POINT
&nbsp;
start:
        ld ix, ATTRIBUTE_ADR  <i>; adresa pro zápis</i>
        xor a                 <i>; zapisovaná hodnota</i>
        ld b, a               <i>; počitadlo smyčky</i>
&nbsp;
loop:
        ld (ix),a             <i>; zápis hodnoty na adresu (IX)</i>
        inc ix                <i>; zvýšení adresy</i>
        inc a                 <i>; zvýšení zapisované hodnoty</i>
        djnz loop             <i>; kombinace dec b + jp NZ, loop</i>
                              <i>; snížení hodnoty počitadla</i>
                              <i>; skok pokud se ještě nedosáhlo nuly</i>
        ret
&nbsp;
end ENTRY_POINT
</pre>

<p>Překlad do strojového kódu dopadne následovně:</p>

<pre>
ATTRIBUTE_ADR   EQU 5800
ENTRY_POINT     EQU 8000
                ORG 8000
8000:           label start
8000:<strong>DD</strong>210058   LD IX, 5800
8004:AF         XOR A
8005:47         LD B, A
8006:           label loop
8006:<strong>DD</strong>7700     LD (IX+00), A
8009:3C         INC A
800A:<strong>DD</strong>23       INC IX
800C:10F8       DJNZ 8006
800E:C9         RET
800F:           END 8000
Emiting TAP basic loader
Emiting TAP from 8000 to 800E
</pre>

<p>Příklad bude plně funkční, ovšem povšimněte si, že instrukce pracující
s&nbsp;registrem <strong>IX</strong> jsou delší o prefix <strong>0xDD</strong>
(na předchozím výpisu zvýrazněno).</p>

<p>Podobně si můžeme vyzkoušet náhradu <strong>IX</strong> za
<strong>IY</strong>:</p>

<pre>
ATTRIBUTE_ADR equ $5800
ENTRY_POINT   equ $8000
&nbsp;
        org ENTRY_POINT
&nbsp;
start:
        ld iy, ATTRIBUTE_ADR  <i>; adresa pro zápis</i>
        xor a                 <i>; zapisovaná hodnota</i>
        ld b, a               <i>; počitadlo smyčky</i>
&nbsp;
loop:
        ld (iy),a             <i>; zápis hodnoty na adresu (IY)</i>
        inc iy                <i>; zvýšení adresy</i>
        inc a                 <i>; zvýšení zapisované hodnoty</i>
        djnz loop             <i>; kombinace dec b + jp NZ, loop</i>
                              <i>; snížení hodnoty počitadla</i>
                              <i>; skok pokud se ještě nedosáhlo nuly</i>
        ret
&nbsp;
end ENTRY_POINT
</pre>

<p>S&nbsp;jiným výsledkem, resp.&nbsp;přesněji řečeno s&nbsp;odlišným prefixem
<strong>0xFD</strong> namísto <strong>0xDD</strong>:</p>

<pre>
ATTRIBUTE_ADR   EQU 5800
ENTRY_POINT     EQU 8000
                ORG 8000
8000:           label start
8000:<strong>FD210058</strong>   LD IY, 5800
8004:AF         XOR A
8005:47         LD B, A
8006:           label loop
8006:<strong>FD7700</strong>     LD (IY+00), A
8009:<strong>FD23</strong>       INC IY
800B:3C         INC A
800C:10F8       DJNZ 8006
800E:C9         RET
800F:           END 8000
Emiting TAP basic loader
Emiting TAP from 8000 to 800E
</pre>



<p><a name="k16"></a></p>
<h2 id="k16">16. Porovnání kódů založených na registrech HL, IX a IY</h2>

<p>Porovnání kódů založených na registrovém páru <strong>HL</strong>,
popř.&nbsp;na index registrech <strong>IX</strong> a <strong>IY</strong> nám do
určité míry prozradí, jak jsou instrukce zakódovány. Tento rozdílný způsob
zakódování je do značné míry způsobený snahou o dosažení zpětné binární
kompatibility s&nbsp;Intelem 8080. Porovnáme si ty programy, které provádí
naprosto stejné operace, pouze s&nbsp;odlišnými registry:</p>

<pre>
ATTRIBUTE_ADR   EQU 5800           ATTRIBUTE_ADR   EQU 5800          ATTRIBUTE_ADR   EQU 5800
ENTRY_POINT     EQU 8000           ENTRY_POINT     EQU 8000          ENTRY_POINT     EQU 8000
                ORG 8000                           ORG 8000                          ORG 8000
8000:           label start        8000:           label start       8000:           label start
8000:210058     LD HL, 5800        8000:DD210058   LD IX, 5800       8000:FD210058   LD IY, 5800
8003:AF         XOR A              8004:AF         XOR A             8004:AF         XOR A
8004:47         LD B, A            8005:47         LD B, A           8005:47         LD B, A
8005:           label loop         8006:           label loop        8006:           label loop
8005:77         LD (HL), A         8006:DD7700     LD (IX+00), A     8006:FD7700     LD (IY+00), A
8006:23         INC HL             8009:DD23       INC IX            8009:FD23       INC IY
8007:3C         INC A              800B:3C         INC A             800B:3C         INC A
8008:10FB       DJNZ 8005          800C:10F8       DJNZ 8006         800C:10F8       DJNZ 8006
800A:C9         RET                800E:C9         RET               800E:C9         RET
800B:           END 8000           800F:           END 8000          800F:           END 8000
Emiting TAP basic loader           Emiting TAP basic loader          Emiting TAP basic loader
Emiting TAP from 8000 to 800A      Emiting TAP from 8000 to 800E     Emiting TAP from 8000 to 800E
</pre>

<p>Rozdíly tedy spočívají v&nbsp;použití prefixů <strong>0xDD</strong>
resp.&nbsp;<strong>0xFD</strong>. Navíc se u instrukcí <strong>LD (IX),
A</strong> přidává nulový offset, což tyto instrukce o jeden bajt zvětší (a
zpomalí).</p>



<p><a name="k17"></a></p>
<h2 id="k17">17. Programová smyčka se šestnáctibitovým počitadlem: naivní varianta</h2>

<p>Na závěr dnešního článku si ukažme, jak by mohla vypadat (poněkud naivní)
programová smyčka používající šestnáctibitové počitadlo. Předchozí demonstrační
příklady upravíme takovým způsobem, aby se nevyplnilo pouze prvních 256
barvových atributů, ale 512 atributů (nebo klidně i celý blok o délce 768
bajtů). Jako počitadlo bude použit registrový pár <strong>BC</strong> (nikoli
jen <strong>B</strong>) a pro kontrolu, zda šestnáctibitové počitadlo dosáhlo
nuly jednoduše oba osmibitové části počitadla zkombinujeme operací logického
součtu bit po bitu. Výsledek bude nulový pouze tehdy, pokud budou nulové i oba
operandy logického součtu:</p>

<pre>
        ld a,b
        or c
        <i>; následuje test na nulovost výsledku</i>
</pre>

<p>První varianta smyčky se šestnáctibitovým počitadlem může vypadat
následovně:</p>

<pre>
ATTRIBUTE_ADR equ $5800
ENTRY_POINT   equ $8000
&nbsp;
        org ENTRY_POINT
&nbsp;
start:
        ld hl, ATTRIBUTE_ADR  <i>; adresa pro zápis</i>
        ld bc, 512            <i>; počitadlo smyčky</i>
&nbsp;
loop:
        ld (hl),l             <i>; zápis hodnoty na adresu (HL)</i>
        inc hl                <i>; zvýšení adresy i zapisované hodnoty</i>
        dec bc                <i>; snížení hodnoty počitadla</i>
        ld a,b
        or c
        jp NZ, loop           <i>; skok pokud se ještě nedosáhlo nuly</i>
        ret
&nbsp;
end ENTRY_POINT
</pre>

<p>Způsob překladu do strojového kódu:</p>

<pre>
ATTRIBUTE_ADR   EQU 5800
ENTRY_POINT     EQU 8000
                ORG 8000
8000:           label start
8000:210058     LD HL, 5800
8003:010002     LD BC, 0200
8006:           label loop
8006:75         LD (HL), L
8007:23         INC HL
8008:0B         DEC BC
8009:78         LD A, B
800A:B1         OR C
800B:C20680     JP NZ, 8006
800E:C9         RET
800F:           END 8000
Emiting TAP basic loader
Emiting TAP from 8000 to 800E
</pre>

<p>A takto bude vypadat obrazovka po spuštění tohoto demonstračního
příkladu:</p>

*** image ***
<p><i>Obrázek XX: Obrazovka po nastavení 512 atributových bajtů (2/3 atributové paměti).</i></p>

*** image ***
<p><i>Obrázek XX: Obrazovka po nastavení 512 atributových bajtů (2/3 atributové paměti).</i></p>



<p><a name="k18"></a></p>
<h2 id="k18">18. Dosažení prakticky stejné rychlosti, jako v&nbsp;případě smyčky s&nbsp;osmibitovým počitadlem</h2>

<p>Předchozí řešení nebylo příliš rychlé, neboť vyžadovalo použití relativně
velkého množství operací pro zjištění nulovosti počitadla. Ovšem smyčku můžeme
přepsat do podoby, která je prakticky stejně rychlá, jako smyčka
s&nbsp;osmibitovým počitadlem. Trik spočívá v&nbsp;tom, že se smyčka rozdělí na
vnitřní (ta se v&nbsp;našem případě vždy provede 256&times;) a na vnější (ta se
provede dvakrát). Vnitřní smyčka je naprosto stejně rychlá jako čistě
osmibitová varianta a vnější smyčka (resp.&nbsp;její testy) se zopakuje pouze
2&times; a tudíž nemá na celkovou délku provedení žádný zásadní vliv.
Mimochodem &ndash; vhodnou volbou konstant předávných do registrů
<strong>A</strong> a <strong>B</strong> můžeme docílit prakticky libovolného
množství celkového počtu opakování; nemusí se tudíž jednat o násobky 256:</p>

<pre>
ATTRIBUTE_ADR equ $5800
ENTRY_POINT   equ $8000
&nbsp;
        org ENTRY_POINT
&nbsp;
start:
        ld hl, ATTRIBUTE_ADR  <i>; adresa pro zápis</i>
        ld a, 2               <i>; počet opakování bloku s 256 zápisy</i>
        ld b, 0               <i>; počitadlo vnitřní smyčky</i>
&nbsp;
loop:
        ld (hl),l             <i>; zápis hodnoty na adresu (HL)</i>
        inc hl                <i>; zvýšení adresy i zapisované hodnoty</i>
        djnz loop             <i>; vnitřní smyčka: blok s 256 zápisy</i>
        dec a                 <i>; počitadlo vnější smyčky</i>
        jp NZ, loop           <i>; skok pokud se ještě nedosáhlo nuly</i>
        ret
&nbsp;
end ENTRY_POINT
</pre>

<p>A takto bude vypadat překlad do strojového kódu:</p>

<pre>
ATTRIBUTE_ADR   EQU 5800
ENTRY_POINT     EQU 8000
                ORG 8000
8000:           label start
8000:210058     LD HL, 5800
8003:3E02       LD A, 02
8005:0600       LD B, 00
8007:           label loop
8007:75         LD (HL), L
8008:23         INC HL
8009:10FC       DJNZ 8007
800B:3D         DEC A
800C:C20780     JP NZ, 8007
800F:C9         RET
8010:           END 8000
Emiting TAP basic loader
Emiting TAP from 8000 to 800F
</pre>



<p><a name="k19"></a></p>
<h2 id="k19">19. Repositář s&nbsp;demonstračními příklady</h2>

<p>V&nbsp;tabulce zobrazené pod tímto odstavcem jsou uvedeny odkazy na všechny
prozatím popsané demonstrační příklady určené pro překlad a spuštění na
osmibitovém domácím mikropočítači ZX Spectrum (libovolný model či jeho klon),
které jsou psány v&nbsp;assembleru mikroprocesoru Zilog Z80. Pro překlad těchto
demonstračních příkladů je možné použít například assembler <i>Pasmo</i> (viz
též <a
href="https://www.root.cz/clanky/kouzlo-minimalismu-potreti-vyvoj-her-a-dem-pro-slavne-zx-spectrum/">úvodní
článek</a>):</p>

<table>
<tr><th> #</th><th>Soubor</th><th>Stručný popis</th><th>Adresa</th></tr>
<tr><td> 1</td><td>01-color-attribute.asm</td><td>modifikace jednoho barvového atributu</td><td><a href="https://github.com/tisnik/8bit-fame/blob/master/Speccy-asm/01-color-attribute.asm">https://github.com/tisnik/8bit-fame/blob/master/Speccy-asm/01-color-attribute.asm</a></td></tr>
<tr><td> 2</td><td>02-blinking-attribute.asm</td><td>barvový atribut s&nbsp;nastavením bitů pro blikání a vyšší intenzitu</td><td><a href="https://github.com/tisnik/8bit-fame/blob/master/Speccy-asm/02-blinking-attribute.asm">https://github.com/tisnik/8bit-fame/blob/master/Speccy-asm/02-blinking-attribute.asm</a></td></tr>
<tr><td> 3</td><td>03-symbolic-names.asm</td><td>symbolická jména v&nbsp;assembleru</td><td><a href="https://github.com/tisnik/8bit-fame/blob/master/Speccy-asm/03-symbolic-names.asm">https://github.com/tisnik/8bit-fame/blob/master/Speccy-asm/03-symbolic-names.asm</a></td></tr>
<tr><td> 4</td><td>04-operators.asm</td><td>operátory a operace se symbolickými hodnotami</td><td><a href="https://github.com/tisnik/8bit-fame/blob/master/Speccy-asm/04-operators.asm">https://github.com/tisnik/8bit-fame/blob/master/Speccy-asm/04-operators.asm</a></td></tr>
<tr><td> 5</td><td>05-better-symbols.asm</td><td>tradičnější symbolická jména</td><td><a href="https://github.com/tisnik/8bit-fame/blob/master/Speccy-asm/05-better-symbols.asm">https://github.com/tisnik/8bit-fame/blob/master/Speccy-asm/05-better-symbols.asm</a></td></tr>
<tr><td> 6</td><td>06-tapbas-v1.asm</td><td>vygenerování BASICovského loaderu (neúplný příklad)</td><td><a href="https://github.com/tisnik/8bit-fame/blob/master/Speccy-asm/06-tapbas-v1.asm">https://github.com/tisnik/8bit-fame/blob/master/Speccy-asm/06-tapbas-v1.asm</a></td></tr>
<tr><td> 7</td><td>07-tapbas-v2.asm</td><td>vygenerování BASICovského loaderu (úplný příklad)</td><td><a href="https://github.com/tisnik/8bit-fame/blob/master/Speccy-asm/07-tapbas-v2.asm">https://github.com/tisnik/8bit-fame/blob/master/Speccy-asm/07-tapbas-v2.asm</a></td></tr>
<tr><td> 8</td><td>08-loop.asm</td><td>jednoduchá počítaná programová smyčka: naivní varianta</td><td><a href="https://github.com/tisnik/8bit-fame/blob/master/Speccy-asm/08-loop.asm">https://github.com/tisnik/8bit-fame/blob/master/Speccy-asm/08-loop.asm</a></td></tr>
<tr><td> 9</td><td>09-loop.asm</td><td>programová smyčka: zkrácení kódu pro vynulování použitých pracovních registrů</td><td><a href="https://github.com/tisnik/8bit-fame/blob/master/Speccy-asm/09-loop.asm">https://github.com/tisnik/8bit-fame/blob/master/Speccy-asm/09-loop.asm</a></td></tr>
<tr><td>10</td><td>10-loop.asm</td><td>programová smyčka: optimalizace skoku na konci smyčky (instrukce <strong>DJNZ</strong>)</td><td><a href="https://github.com/tisnik/8bit-fame/blob/master/Speccy-asm/10-loop.asm">https://github.com/tisnik/8bit-fame/blob/master/Speccy-asm/10-loop.asm</a></td></tr>
<tr><td>11</td><td>11-loop.asm</td><td>programová smyčka: optimalizace využití pracovních registrů</td><td><a href="https://github.com/tisnik/8bit-fame/blob/master/Speccy-asm/11-loop.asm">https://github.com/tisnik/8bit-fame/blob/master/Speccy-asm/11-loop.asm</a></td></tr>
<tr><td>12</td><td>12-loop.asm</td><td>programová smyčka: použití pracovního registru IX</td><td><a href="https://github.com/tisnik/8bit-fame/blob/master/Speccy-asm/12-loop.asm">https://github.com/tisnik/8bit-fame/blob/master/Speccy-asm/12-loop.asm</a></td></tr>
<tr><td>13</td><td>13-loop.asm</td><td>programová smyčka: použití pracovního registru IY</td><td><a href="https://github.com/tisnik/8bit-fame/blob/master/Speccy-asm/13-loop.asm">https://github.com/tisnik/8bit-fame/blob/master/Speccy-asm/13-loop.asm</a></td></tr>
<tr><td>14</td><td>14-loop.asm</td><td>programová smyčka se šestnáctibitovým počitadlem, základní varianta</td><td><a href="https://github.com/tisnik/8bit-fame/blob/master/Speccy-asm/14-loop.asm">https://github.com/tisnik/8bit-fame/blob/master/Speccy-asm/14-loop.asm</a></td></tr>
<tr><td>15</td><td>15-loop.asm</td><td>programová smyčka se šestnáctibitovým počitadlem, vylepšená varianta</td><td><a href="https://github.com/tisnik/8bit-fame/blob/master/Speccy-asm/15-loop.asm">https://github.com/tisnik/8bit-fame/blob/master/Speccy-asm/15-loop.asm</a></td></tr>
<tr><td>16</td><td>16-loop.asm</td><td>použití relativního skoku a nikoli skoku absolutního</td><td><a href="https://github.com/tisnik/8bit-fame/blob/master/Speccy-asm/16-loop.asm">https://github.com/tisnik/8bit-fame/blob/master/Speccy-asm/16-loop.asm</a></td></tr>
<tr><td>17</td><td>17-loop.asm</td><td>programová smyčka: <strong>inc l</strong> namísto <strong>inc hl</strong></td><td><a href="https://github.com/tisnik/8bit-fame/blob/master/Speccy-asm/17-loop.asm">https://github.com/tisnik/8bit-fame/blob/master/Speccy-asm/17-loop.asm</a></td></tr>
<tr><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td></tr>
<tr><td>18</td><td>Makefile</td><td>Makefile pro překlad a slinkování všech příkladů</td><td><a href="https://github.com/tisnik/8bit-fame/blob/master/Speccy-asm/Makefile">https://github.com/tisnik/8bit-fame/blob/master/Speccy-asm/Makefile</a></td></tr>
</table>



<p><a name="k20"></a></p>
<h2 id="k20">20. Odkazy na Internetu</h2>

<ol>

<li>z80 standalone assembler<br />
<a href="https://www.asm80.com/onepage/asmz80.html">https://www.asm80.com/onepage/asmz80.html</a>
</li>

<li>The ZX BASIC Compiler<br />
<a href="https://www.boriel.com/pages/the-zx-basic-compiler.html">https://www.boriel.com/pages/the-zx-basic-compiler.html</a>
</li>

<li>Z80 Assembly programming for the ZX Spectrum<br />
<a href="https://www.chibiakumas.com/z80/ZXSpectrum.php">https://www.chibiakumas.com/z80/ZXSpectrum.php</a>
</li>

<li>8-BIT SMACKDOWN! 65C02 vs. Z80: slithy VLOGS #6<br />
<a href="https://www.youtube.com/watch?v=P1paVoFEvyc">https://www.youtube.com/watch?v=P1paVoFEvyc</a>
</li>

<li>Instrukce mikroprocesoru Z80<br />
<a href="https://clrhome.org/table/">https://clrhome.org/table/</a>
</li>

<li>Z80 instructions: adresní režimy atd.<br />
<a href="https://jnz.dk/z80/instructions.html">https://jnz.dk/z80/instructions.html</a>
</li>

<li>Z80 Instruction Groups<br />
<a href="https://jnz.dk/z80/instgroups.html">https://jnz.dk/z80/instgroups.html</a>
</li>

<li>Elena, New programming language for the ZX Spectrum Next<br />
<a href="https://vintageisthenewold.com/elena-new-programming-language-for-the-zx-spectrum-next/">https://vintageisthenewold.com/elena-new-programming-language-for-the-zx-spectrum-next/</a>
</li>

<li>Sinclair BASIC<br />
<a href="https://worldofspectrum.net/legacy-info/sinclair-basic/">https://worldofspectrum.net/legacy-info/sinclair-basic/</a>
</li>

<li>Grafika na osmibitových počítačích firmy Sinclair<br />
<a href="https://www.root.cz/clanky/grafika-na-osmibitovych-pocitacich-firmy-sinclair/">https://www.root.cz/clanky/grafika-na-osmibitovych-pocitacich-firmy-sinclair/</a>
</li>

<li>Grafika na osmibitových počítačích firmy Sinclair II<br />
<a href="https://www.root.cz/clanky/grafika-na-osmibitovych-pocitacich-firmy-sinclair-ii/">https://www.root.cz/clanky/grafika-na-osmibitovych-pocitacich-firmy-sinclair-ii/</a>
</li>

<li>HiSoft BASIC<br />
<a href="https://worldofspectrum.net/infoseekid.cgi?id=0008249">https://worldofspectrum.net/infoseekid.cgi?id=0008249</a>
</li>

<li>YS MegaBasic<br />
<a href="https://worldofspectrum.net/infoseekid.cgi?id=0008997">https://worldofspectrum.net/infoseekid.cgi?id=0008997</a>
</li>

<li>Beta Basic<br />
<a href="https://worldofspectrum.net/infoseekid.cgi?id=0007956">https://worldofspectrum.net/infoseekid.cgi?id=0007956</a>
</li>

<li>BASIC+<br />
<a href="https://worldofspectrum.net/infoseekid.php?id=0014277">https://worldofspectrum.net/infoseekid.php?id=0014277</a>
</li>

<li>Spectrum ROM Memory Map<br />
<a href="https://skoolkit.ca/disassemblies/rom/maps/all.html">https://skoolkit.ca/disassemblies/rom/maps/all.html</a>
</li>

<li>Goto subroutine<br />
<a href="https://skoolkit.ca/disassemblies/rom/asm/7783.html">https://skoolkit.ca/disassemblies/rom/asm/7783.html</a>
</li>

<li>Spectrum Next: The Evolution of the Speccy<br />
<a href="https://www.specnext.com/about/">https://www.specnext.com/about/</a>
</li>

<li>Sedmdesátiny assemblerů: lidsky čitelný strojový kód<br />
<a href="https://www.root.cz/clanky/sedmdesatiny-assembleru-lidsky-citelny-strojovy-kod/">https://www.root.cz/clanky/sedmdesatiny-assembleru-lidsky-citelny-strojovy-kod/</a>
</li>

<li>Programovací jazyk BASIC na osmibitových mikropočítačích<br />
<a href="https://www.root.cz/clanky/programovaci-jazyk-basic-na-osmibitovych-mikropocitacich/">https://www.root.cz/clanky/programovaci-jazyk-basic-na-osmibitovych-mikropocitacich/</a>
</li>

<li>Programovací jazyk BASIC na osmibitových mikropočítačích (2)<br />
<a href="https://www.root.cz/clanky/programovaci-jazyk-basic-na-osmibitovych-mikropocitacich-2/#k06">https://www.root.cz/clanky/programovaci-jazyk-basic-na-osmibitovych-mikropocitacich-2/#k06</a>
</li>

<li>Programovací jazyk BASIC na osmibitových mikropočítačích (3)<br />
<a href="https://www.root.cz/clanky/programovaci-jazyk-basic-na-osmibitovych-mikropocitacich-3/">https://www.root.cz/clanky/programovaci-jazyk-basic-na-osmibitovych-mikropocitacich-3/</a>
</li>

<li>Sinclair BASIC (Wikipedia CZ)<br />
<a href="http://cs.wikipedia.org/wiki/Sinclair_BASIC">http://cs.wikipedia.org/wiki/Sinclair_BASIC</a>
</li>

<li>Assembly Language: Still Relevant Today<br />
<a href="http://wilsonminesco.com/AssyDefense/">http://wilsonminesco.com/AssyDefense/</a>
</li>

<li>Programovani v assembleru na OS Linux<br />
<a href="http://www.cs.vsb.cz/grygarek/asm/asmlinux.html">http://www.cs.vsb.cz/grygarek/asm/asmlinux.html</a>
</li>

<li>Why Assembly Language Programming? (Why Learning Assembly Language Is Still a Good Idea)<br />
<a href="https://wdc65xx.com/markets/education/why-assembly-language-programming/">https://wdc65xx.com/markets/education/why-assembly-language-programming/</a>
</li>

<li>Low Fat Computing<br />
<a href="http://www.ultratechnology.com/lowfat.htm">http://www.ultratechnology.com/lowfat.htm</a>
</li>

<li>Assembly Language<br />
<a href="https://www.cleverism.com/skills-and-tools/assembly-language/">https://www.cleverism.com/skills-and-tools/assembly-language/</a>
</li>

<li>Why do we need assembly language?<br />
<a href="https://cs.stackexchange.com/questions/13287/why-do-we-need-assembly-language">https://cs.stackexchange.com/questions/13287/why-do-we-need-assembly-language</a>
</li>

<li>Assembly language (Wikipedia)<br />
<a href="https://en.wikipedia.org/wiki/Assembly_language#Historical_perspective">https://en.wikipedia.org/wiki/Assembly_language#Historical_perspective</a>
</li>

<li>Assembly languages<br />
<a href="https://curlie.org/Computers/Programming/Languages/Assembly/">https://curlie.org/Computers/Programming/Languages/Assembly/</a>
</li>

<li>vasm<br />
<a href="http://sun.hasenbraten.de/vasm/">http://sun.hasenbraten.de/vasm/</a>
</li>

<li>B-ELITE<br />
<a href="https://jsj.itch.io/b-elite">https://jsj.itch.io/b-elite</a>
</li>

<li>ZX-Spectrum Child<br />
<a href="http://www.dotkam.com/2008/11/19/zx-spectrum-child/">http://www.dotkam.com/2008/11/19/zx-spectrum-child/</a>
</li>

<li>Speccy.cz<br />
<a href="http://www.speccy.cz/">http://www.speccy.cz/</a>
</li>

<li>Planet Sinclair<br />
<a href="http://www.nvg.ntnu.no/sinclair/">http://www.nvg.ntnu.no/sinclair/</a>
</li>

<li>World of Spectrum<br />
<a href="http://www.worldofspectrum.org/">http://www.worldofspectrum.org/</a>
</li>

<li>Z80 Assembly Language for the ZX Spectrum Tutorial, Episode 1: The Basics<br />
<a href="https://www.youtube.com/watch?v=_J4ahkWtNYw">https://www.youtube.com/watch?v=_J4ahkWtNYw</a>
</li>

<li>Z80 assembly resources when starting programming in assembler<br />
<a href="https://www.youtube.com/watch?v=mjLHSnQmHV4">https://www.youtube.com/watch?v=mjLHSnQmHV4</a>
</li>

<li>Setting up Visual Studio Code with Pasmo, Sprite Example ZX Spectrum Next<br />
<a href="https://www.youtube.com/watch?v=lKDaFWPObLY">https://www.youtube.com/watch?v=lKDaFWPObLY</a>
</li>

<li>RetroCoder ZX Spectrum development (Z80 Assembly)- Day 1 - Hello World.asm<br />
<a href="https://www.youtube.com/watch?v=Xv6NAC--x24">https://www.youtube.com/watch?v=Xv6NAC--x24</a>
</li>

<li>Rozšíření paměti<br />
<a href="https://wiki.ilnx.cz/doku.php/lnxspectrum:memorymap">https://wiki.ilnx.cz/doku.php/lnxspectrum:memorymap</a>
</li>

<li>ZX-Spectrum 48K video memory map<br />
<a href="https://www.reddit.com/r/zxspectrum/comments/phi7lt/zxspectrum_48k_video_memory_map/">https://www.reddit.com/r/zxspectrum/comments/phi7lt/zxspectrum_48k_video_memory_map/</a>
</li>

<li>Memory Map: 48K Spectrum<br />
<a href="http://www.breakintoprogram.co.uk/hardware/computers/zx-spectrum/memory-map">http://www.breakintoprogram.co.uk/hardware/computers/zx-spectrum/memory-map</a>
</li>

<li>ZX Basic: Git repository<br />
<a href="https://github.com/boriel/zxbasic">https://github.com/boriel/zxbasic</a>
</li>

<li>ZX Basic Wiki<br />
<a href="https://zxbasic.readthedocs.io/en/docs/">https://zxbasic.readthedocs.io/en/docs/</a>
</li>

<li>ZX Spectrum Games: svět osmibitové herní legendy<br />
<a href="https://www.zx-spectrum.cz/">https://www.zx-spectrum.cz/</a>
</li>

<li>TAP format<br />
<a href="https://sinclair.wiki.zxnet.co.uk/wiki/TAP_format">https://sinclair.wiki.zxnet.co.uk/wiki/TAP_format</a>
</li>

<li>Contended memory<br />
<a href="https://worldofspectrum.org/faq/reference/48kreference.htm#Contention">https://worldofspectrum.org/faq/reference/48kreference.htm#Contention</a>
</li>

<li>Screen Memory Layout<br />
<a href="http://www.breakintoprogram.co.uk/hardware/computers/zx-spectrum/screen-memory-layout">http://www.breakintoprogram.co.uk/hardware/computers/zx-spectrum/screen-memory-layout</a>
</li>

<li>OpenSE BASIC<br />
<a href="https://zxdesign.itch.io/opense">https://zxdesign.itch.io/opense</a>
</li>

<li>Domácí a školní mikropočítače řady Didaktik<br />
<a href="https://www.root.cz/clanky/domaci-a-skolni-mikropocitace-rady-didaktik/">https://www.root.cz/clanky/domaci-a-skolni-mikropocitace-rady-didaktik/</a>
</li>

<li>Z80 Assembler for Dummies<br />
<a href="https://www.msx.org/wiki/Z80_Assembler_for_Dummies">https://www.msx.org/wiki/Z80_Assembler_for_Dummies</a>
</li>

<li>Z80 Resources<br />
<a href="https://www.assemblytutorial.com/z80/">https://www.assemblytutorial.com/z80/</a>
</li>

<li>How do Z80 Block Transfer instructions work?<br />
<a href="https://retrocomputing.stackexchange.com/questions/5416/how-do-z80-block-transfer-instructions-work">https://retrocomputing.stackexchange.com/questions/5416/how-do-z80-block-transfer-instructions-work</a>
</li>

<li>How fast is memcpy on the Z80?<br />
<a href="https://retrocomputing.stackexchange.com/questions/4744/how-fast-is-memcpy-on-the-z80">https://retrocomputing.stackexchange.com/questions/4744/how-fast-is-memcpy-on-the-z80</a>
</li>

<li>Comparing Datapoint 2200, 8008, 8080 and Z80 Instruction Sets<br />
<a href="https://bread80.com/comparing-datapoint-2200-8008-8080-and-z80-instruction-sets/">https://bread80.com/comparing-datapoint-2200-8008-8080-and-z80-instruction-sets/</a>
</li>

<li>8080/Z80 Instruction Set<br />
<a href="https://retroprogramming.it/2021/02/8080-z80-instruction-set/">https://retroprogramming.it/2021/02/8080-z80-instruction-set/</a>
</li>

<li>Zilog Z80A Technical Information<br />
<a href="https://worldofspectrum.org/faq/reference/z80reference.htm">https://worldofspectrum.org/faq/reference/z80reference.htm</a>
</li>

<li>Z80 programming techniques - Loops<br />
<a href="http://map.grauw.nl/articles/fast_loops.php">http://map.grauw.nl/articles/fast_loops.php</a>
</li>

</ol>



<p></p><p></p>
<p><small>Autor: <a href="http://www.fit.vutbr.cz/~tisnovpa">Pavel Tišnovský</a> &nbsp; 2023</small></p>
</body>
</html>

