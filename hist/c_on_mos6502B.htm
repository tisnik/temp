<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
        "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html>
<head>
<title>Překladače programovacího jazyka C pro historické osmibitové mikroprocesory 2</title>
<meta name="Author" content="Pavel Tisnovsky" />
<meta name="Generator" content="vim" />
<meta http-equiv="content-type" content="text/html; charset=utf-8" />
<style type="text/css">
         body {color:#000000; background:#ffffff;}
         h1  {font-family: arial, helvetica, sans-serif; color:#ffffff; background-color:#c00000; text-align:center; padding-left:1em}
         h2  {font-family: arial, helvetica, sans-serif; color:#ffffff; background-color:#0000c0; padding-left:1em; text-align:left}
         h3  {font-family: arial, helvetica, sans-serif; color:#000000; background-color:#c0c0c0; padding-left:1em; text-align:left}
         h4  {font-family: arial, helvetica, sans-serif; color:#000000; background-color:#e0e0e0; padding-left:1em; text-align:left}
         a   {font-family: arial, helvetica, sans-serif;}
         li  {font-family: arial, helvetica, sans-serif; color:#000000; text-align:justify; width:450px;}
         ol  {font-family: arial, helvetica, sans-serif; color:#000000; text-align:justify; width:450px;}
         ul  {font-family: arial, helvetica, sans-serif; color:#000000; text-align:justify; width:450px;}
         p   {font-family: arial, helvetica, sans-serif; color:#000000; text-align:justify;}
         pre {background:#e0e0e0}
</style>
</head>

<body>

<h1>Překladače programovacího jazyka C pro historické osmibitové mikroprocesory 2</h1>

<h3>Pavel Tišnovský</h3>

<p></p>

<h1>Úvodník</h1>

<p>Ve druhé a současně i závěrečné části článku o překladači cc65 si řekneme, jakým způsobem můžeme využít některé jeho speciální vlastnosti, například možnost mixovat kód psaný v jazyku C s assemblerem (na úrovni zdrojového kódu) nebo použití pseudoproměnných __A__, __AX__ atd.</p>



<h2>Obsah</h2>

<p><a href="#k01">1. Dokončení popisu překladače jazyka C pro osmibitové mikroprocesory MOS 6502: cc65</a></p>
<p><a href="#k02">*** 2. Volba, do jaké paměťové oblasti se mají uložit lokální proměnné</a></p>
<p><a href="#k03">*** 3. Vliv klíčového slova <strong>register</strong> na způsob uložení lokálních proměnných</a></p>
<p><a href="#k04">*** 4. Přímý přístup k&nbsp;akumulátoru s&nbsp;využitím identifikátoru <strong>__A__strong></a></p>
<p><a href="#k05">*** 5. Přístup k&nbsp;registrovému páru A + X s&nbsp;využitím identifikátoru <strong>__AX__</strong></a></p>
<p><a href="#k06">*** 6. Přístup k&nbsp;32bitové hodnotě uložené ve dvou buňkách RAM a v&nbsp;registrovém páru A + X</a></p>
<p><a href="#k07">*** 7. Rozdíl mezi chováním operátoru pro pre-inkrementaci a post-inkrementaci</a></p>
<p><a href="#k08">*** 8. Součet celých čísel bez znaménka a se znaménkem</a></p>
<p><a href="#k09">*** 9. Modifikace bloku paměti s&nbsp;využitím ukazatele a offsetu</a></p>
<p><a href="#k10">*** 10. Přímý zápis instrukcí v&nbsp;assembleru do céčkového kódu</a></p>
<p><a href="#k11">*** 11. Použití reference na lokální proměnnou v&nbsp;assembleru</a></p>
<p><a href="#k12">*** 12. Nepatrně složitější příklad: ručně optimalizovaný součet dvou proměnných</a></p>
<p><a href="#k13">13. Přístup ke globálním proměnným z&nbsp;assembleru</a></p>
<p><a href="#k14">*** 14. Bitové posuny a další operace prováděné s&nbsp;akumulátorem</a></p>
<p><a href="#k15">15. Násobení a dělení dvěma popř.&nbsp;mocninou dvou</a></p>
<p><a href="#k16">*** 16. cc65 nakonec není tak hloupý &ndash; násobení třemi a pěti</a></p>
<p><a href="#k17">*** 17. </a></p>
<p><a href="#k18">*** 18. Upravený soubor Makefile</a></p>
<p><a href="#k19">19. Repositář s&nbsp;demonstračními příklady</a></p>
<p><a href="#k20">20. Odkazy na Internetu</a></p>



<p><a name="k01"></a></p>
<h2 id="k01">1. Dokončení popisu překladače jazyka C pro osmibitové mikroprocesory MOS 6502: cc65</h2>

<p>Na <a
href="https://www.root.cz/clanky/prekladace-jazyka-c-pro-historicke-osmibitove-mikroprocesory/">úvodní
článek o překladačích jazyka C určených pro různé osmibitové procesory</a> dnes
navážeme. Připomeňme si, že jsme se zabývali překladem zdrojových kódů
napsaných v&nbsp;céčku do assembleru (a posléze i strojového kódu) osmibitových
mikroprocesorů MOS 6502, které byly použity například v&nbsp;domácích
počítačích Atari a Commodore, v&nbsp;osobních mikropočítačích Apple,
v&nbsp;herních konzolích Atari 2600 (zjednodušený MOS 6507), NES atd. Jednalo
se tedy o populární mikroprocesor, pro nějž vzniklo hned několik překladačů
jazyka C. Nás však zajímá především cross překladač <strong>cc65</strong>,
který umožňuje překlad zdrojových kódů na PC s&nbsp;přenosem výsledného
strojového kódu na zvolenou osmibitovou architekturu. Cross překladač
<strong>cc65</strong> je poměrně populární, ovšem neprovádí žádné složitější
optimalizace a pro jeho úspěšné použití je nutné znát jeho limity a různá temná
zákoutí &ndash; v&nbsp;opačném případě nebude produkovaný kód kvalitní.</p>

<p><div class="rs-tip-major">Poznámka: na rozdíl od moderních překladačů
určených pro (taktéž) moderní architektury mikroprocesorů je v&nbsp;případě
<strong>cc65</strong> <i>vždy</i> možné bez většího úsilí tento překladač
překonat a naprogramovat optimalizovaný kód přímo v&nbsp;assembleru.
V&nbsp;případě moderních architektur je to samozřejmě mnohem složitější (a
většinou taktéž zbytečné, což o MOS 6502 neplatí &ndash; zde je znalost
assembleru takřka nutností).</div></p>

<p>Na úvod se podívejme na to, jakým způsobem se přeloží prázdná funkce
<strong>main</strong>, kterou jsme navíc (poněkud v&nbsp;rozporu se standardem
céčka) nadeklarovali bez parametrů a bez návratové hodnoty:</p>

<pre>
void main(void)
{
}
</pre>

<p>Překlad do assembleru provedeme příkazem:</p>

<pre>
$ <strong>cc65 -T -Cl -O -o empty_main.asm empty_main.c</strong>
</pre>

<p>Význam jednotlivých přepínačů:</p>

<ul>

<li><strong>-T</strong> zajistí, že se do kódu v&nbsp;assembleru
v&nbsp;poznámkách vloží i původní zdrojový kód, takže bude zřejmé, jaké
strojové instrukce odpovídají danému řádku v&nbsp;céčku.</li>

<li><strong>-Cl</strong> povolí použití statických lokálních proměnných, což
vede ke kratšímu a současně i rychlejšímu kódu, protože MOS 6502 neumí (dobře)
adresovat operandy na zásobníku.</li>

<li><strong>-O</strong> povolí základní optimalizace prováděně překladačem. Bez
tohoto přepínače nemá smysl <strong>cc65</strong> vůbec používat
(skutečně!).</li>

<li><strong>-o</strong> je volba určující jméno výsledného souboru
s&nbsp;assemblerem.</li>

</ul>

<p>Výsledkem bude soubor nazvaný <strong>empty_main.asm</strong>, jenž bude
vypadat následovně:</p>

<pre>
<i>;</i>
<i>; File generated by cc65 v 2.18 - Ubuntu 2.18-1</i>
<i>;</i>
        .fopt           compiler,"cc65 v 2.18 - Ubuntu 2.18-1"
        .setcpu         "6502"
        .smart          on
        .autoimport     on
        .case           on
        .debuginfo      off
        .importzp       sp, sreg, regsave, regbank
        .importzp       tmp1, tmp2, tmp3, tmp4, ptr1, ptr2, ptr3, ptr4
        .macpack        longbranch
        .forceimport    __STARTUP__
        .export         _main
&nbsp;
<i>; ---------------------------------------------------------------</i>
<i>; void __near__ main (void)</i>
<i>; ---------------------------------------------------------------</i>
&nbsp;
.segment        "CODE"
&nbsp;
.proc   _main: near
&nbsp;
.segment        "CODE"
&nbsp;
<i>;</i>
<i>; }</i>
<i>;</i>
        <strong>rts</strong>
&nbsp;
.endproc
</pre>

<p>Povšimněte si, že překlad je alespoň v&nbsp;tomto případě velmi úsporný
&ndash; samotný kód obsahuje pouze jedinou instrukci <strong>rts</strong>
neboli návrat z&nbsp;podprogramu (<i>subrutiny</i>).</p>



<p><a name="k02"></a></p>
<h2 id="k02">2. Volba, do jaké paměťové oblasti se mají uložit lokální proměnné</h2>

<pre>
void main(void)
{
    unsigned char x = 42;
}
</pre>

<pre>
<i>;</i>
<i>; File generated by cc65 v 2.18 - Ubuntu 2.18-1</i>
<i>;</i>
        .fopt           compiler,"cc65 v 2.18 - Ubuntu 2.18-1"
        .setcpu         "6502"
        .smart          on
        .autoimport     on
        .case           on
        .debuginfo      off
        .importzp       sp, sreg, regsave, regbank
        .importzp       tmp1, tmp2, tmp3, tmp4, ptr1, ptr2, ptr3, ptr4
        .macpack        longbranch
        .forceimport    __STARTUP__
        .export         _main
&nbsp;
<i>; ---------------------------------------------------------------</i>
<i>; void __near__ main (void)</i>
<i>; ---------------------------------------------------------------</i>
&nbsp;
.segment        "CODE"
&nbsp;
.proc   _main: near
&nbsp;
.segment        "BSS"
&nbsp;
L0002:
        .res    1,$00
&nbsp;
.segment        "CODE"
&nbsp;
<i>;</i>
<i>; unsigned char x = 42;</i>
<i>;</i>
        lda     #$2A
        sta     L0002
<i>;</i>
<i>; }</i>
<i>;</i>
        rts
&nbsp;
.endproc
</pre>

<pre>
<i>;</i>
<i>; File generated by cc65 v 2.18 - Ubuntu 2.18-1</i>
<i>;</i>
        .fopt           compiler,"cc65 v 2.18 - Ubuntu 2.18-1"
        .setcpu         "6502"
        .smart          on
        .autoimport     on
        .case           on
        .debuginfo      off
        .importzp       sp, sreg, regsave, regbank
        .importzp       tmp1, tmp2, tmp3, tmp4, ptr1, ptr2, ptr3, ptr4
        .macpack        longbranch
        .forceimport    __STARTUP__
        .export         _main
&nbsp;
<i>; ---------------------------------------------------------------</i>
<i>; void __near__ main (void)</i>
<i>; ---------------------------------------------------------------</i>
&nbsp;
.segment        "CODE"
&nbsp;
.proc   _main: near
&nbsp;
.segment        "CODE"
&nbsp;
<i>;</i>
<i>; unsigned char x = 42;</i>
<i>;</i>
        lda     #$2A
        jsr     pusha
<i>;</i>
<i>; }</i>
<i>;</i>
        jmp     incsp1
&nbsp;
.endproc
</pre>



<p><a name="k03"></a></p>
<h2 id="k03">3. Vliv klíčového slova <strong>register</strong> na způsob uložení lokálních proměnných</h2>

<pre>
void main(void)
{
    register unsigned char x = 42;
}
</pre>

<pre>
<i>;</i>
<i>; File generated by cc65 v 2.18 - Ubuntu 2.18-1</i>
<i>;</i>
        .fopt           compiler,"cc65 v 2.18 - Ubuntu 2.18-1"
        .setcpu         "6502"
        .smart          on
        .autoimport     on
        .case           on
        .debuginfo      off
        .importzp       sp, sreg, regsave, regbank
        .importzp       tmp1, tmp2, tmp3, tmp4, ptr1, ptr2, ptr3, ptr4
        .macpack        longbranch
        .forceimport    __STARTUP__
        .export         _main
&nbsp;
<i>; ---------------------------------------------------------------</i>
<i>; void __near__ main (void)</i>
<i>; ---------------------------------------------------------------</i>
&nbsp;
.segment        "CODE"
&nbsp;
.proc   _main: near
&nbsp;
.segment        "BSS"
&nbsp;
L0002:
        .res    1,$00
&nbsp;
.segment        "CODE"
&nbsp;
<i>;</i>
<i>; register unsigned char x = 42;</i>
<i>;</i>
        lda     #$2A
        sta     L0002
<i>;</i>
<i>; }</i>
<i>;</i>
        rts
&nbsp;
.endproc
</pre>

<pre>
<i>;</i>
<i>; File generated by cc65 v 2.18 - Ubuntu 2.18-1</i>
<i>;</i>
        .fopt           compiler,"cc65 v 2.18 - Ubuntu 2.18-1"
        .setcpu         "6502"
        .smart          on
        .autoimport     on
        .case           on
        .debuginfo      off
        .importzp       sp, sreg, regsave, regbank
        .importzp       tmp1, tmp2, tmp3, tmp4, ptr1, ptr2, ptr3, ptr4
        .macpack        longbranch
        .forceimport    __STARTUP__
        .export         _main
&nbsp;
<i>; ---------------------------------------------------------------</i>
<i>; void __near__ main (void)</i>
<i>; ---------------------------------------------------------------</i>
&nbsp;
.segment        "CODE"
&nbsp;
.proc   _main: near
&nbsp;
.segment        "CODE"
&nbsp;
<i>;</i>
<i>; register unsigned char x = 42;</i>
<i>;</i>
        lda     regbank+5
        jsr     pusha
        lda     #$2A
        sta     regbank+5
<i>;</i>
<i>; }</i>
<i>;</i>
        ldy     #$00
        lda     (sp),y
        sta     regbank+5
        jmp     incsp1
&nbsp;
.endproc
</pre>



<p><a name="k04"></a></p>
<h2 id="k04">4. Přímý přístup k&nbsp;akumulátoru s&nbsp;využitím identifikátoru <strong>__A__strong></h2>

<pre>
void main(void)
{
    __A__ = 42;

    ++__A__;
}
</pre>

<pre>
<i>;</i>
<i>; File generated by cc65 v 2.18 - Ubuntu 2.18-1</i>
<i>;</i>
        .fopt           compiler,"cc65 v 2.18 - Ubuntu 2.18-1"
        .setcpu         "6502"
        .smart          on
        .autoimport     on
        .case           on
        .debuginfo      off
        .importzp       sp, sreg, regsave, regbank
        .importzp       tmp1, tmp2, tmp3, tmp4, ptr1, ptr2, ptr3, ptr4
        .macpack        longbranch
        .forceimport    __STARTUP__
        .export         _main
&nbsp;
<i>; ---------------------------------------------------------------</i>
<i>; void __near__ main (void)</i>
<i>; ---------------------------------------------------------------</i>
&nbsp;
.segment        "CODE"
&nbsp;
.proc   _main: near
&nbsp;
.segment        "CODE"
&nbsp;
<i>;</i>
<i>; __A__ = 42;</i>
<i>;</i>
        lda     #$2A
<i>;</i>
<i>; ++__A__;</i>
<i>;</i>
        clc
        adc     #$01
<i>;</i>
<i>; }</i>
<i>;</i>
        rts
&nbsp;
.endproc
</pre>



<p><a name="k05"></a></p>
<h2 id="k05">5. Přístup k&nbsp;registrovému páru A + X s&nbsp;využitím identifikátoru <strong>__AX__</strong></h2>

<pre>
void main(void)
{
    __AX__ = 0x1234;

    ++__AX__;
}
</pre>

<pre>
<i>;</i>
<i>; File generated by cc65 v 2.18 - Ubuntu 2.18-1</i>
<i>;</i>
        .fopt           compiler,"cc65 v 2.18 - Ubuntu 2.18-1"
        .setcpu         "6502"
        .smart          on
        .autoimport     on
        .case           on
        .debuginfo      off
        .importzp       sp, sreg, regsave, regbank
        .importzp       tmp1, tmp2, tmp3, tmp4, ptr1, ptr2, ptr3, ptr4
        .macpack        longbranch
        .forceimport    __STARTUP__
        .export         _main
&nbsp;
<i>; ---------------------------------------------------------------</i>
<i>; void __near__ main (void)</i>
<i>; ---------------------------------------------------------------</i>
&nbsp;
.segment        "CODE"
&nbsp;
.proc   _main: near
&nbsp;
.segment        "CODE"
&nbsp;
<i>;</i>
<i>; __AX__ = 0x1234;</i>
<i>;</i>
        ldx     #$12
        lda     #$34
<i>;</i>
<i>; ++__AX__;</i>
<i>;</i>
        jsr     incax1
<i>;</i>
<i>; }</i>
<i>;</i>
        rts
&nbsp;
.endproc
</pre>

<pre>
<i>;</i>
<i>; File generated by cc65 v 2.18 - Ubuntu 2.18-1</i>
<i>;</i>
        .fopt           compiler,"cc65 v 2.18 - Ubuntu 2.18-1"
        .setcpu         "6502"
        .smart          on
        .autoimport     on
        .case           on
        .debuginfo      off
        .importzp       sp, sreg, regsave, regbank
        .importzp       tmp1, tmp2, tmp3, tmp4, ptr1, ptr2, ptr3, ptr4
        .macpack        longbranch
        .forceimport    __STARTUP__
        .export         _main

<i>; ---------------------------------------------------------------</i>
<i>; void __near__ main (void)</i>
<i>; ---------------------------------------------------------------</i>

.segment        "CODE"

.proc   _main: near

.segment        "CODE"

<i>;</i>
<i>; __AX__ = 0x1234;</i>
<i>;</i>
        lda     #$34
<i>;</i>
<i>; ++__AX__;</i>
<i>;</i>
        clc
        adc     #$01
<i>;</i>
<i>; }</i>
<i>;</i>
        rts

.endproc
</pre>



<p><a name="k06"></a></p>
<h2 id="k06">6. Přístup k&nbsp;32bitové hodnotě uložené ve dvou buňkách RAM a v&nbsp;registrovém páru A + X</h2>

<pre>
void main(void)
{
    __EAX__ = 0x12345678;

    ++__EAX__;
}
</pre>

<pre>
<i>;</i>
<i>; File generated by cc65 v 2.18 - Ubuntu 2.18-1</i>
<i>;</i>
        .fopt           compiler,"cc65 v 2.18 - Ubuntu 2.18-1"
        .setcpu         "6502"
        .smart          on
        .autoimport     on
        .case           on
        .debuginfo      off
        .importzp       sp, sreg, regsave, regbank
        .importzp       tmp1, tmp2, tmp3, tmp4, ptr1, ptr2, ptr3, ptr4
        .macpack        longbranch
        .forceimport    __STARTUP__
        .export         _main

<i>; ---------------------------------------------------------------</i>
<i>; void __near__ main (void)</i>
<i>; ---------------------------------------------------------------</i>

.segment        "CODE"

.proc   _main: near

.segment        "CODE"

<i>;</i>
<i>; __EAX__ = 0x12345678;</i>
<i>;</i>
        ldx     #$56
        lda     #$34
        sta     sreg
        lda     #$12
        sta     sreg+1
        lda     #$78
<i>;</i>
<i>; ++__EAX__;</i>
<i>;</i>
        ldy     #$01
        jsr     inceaxy
<i>;</i>
<i>; }</i>
<i>;</i>
        rts

.endproc
</pre>

<pre>
<i>;</i>
<i>; File generated by cc65 v 2.18 - Ubuntu 2.18-1</i>
<i>;</i>
        .fopt           compiler,"cc65 v 2.18 - Ubuntu 2.18-1"
        .setcpu         "6502"
        .smart          on
        .autoimport     on
        .case           on
        .debuginfo      off
        .importzp       sp, sreg, regsave, regbank
        .importzp       tmp1, tmp2, tmp3, tmp4, ptr1, ptr2, ptr3, ptr4
        .macpack        longbranch
        .forceimport    __STARTUP__
        .export         _main

<i>; ---------------------------------------------------------------</i>
<i>; void __near__ main (void)</i>
<i>; ---------------------------------------------------------------</i>

.segment        "CODE"

.proc   _main: near

.segment        "CODE"

<i>;</i>
<i>; __EAX__ = 0x12345678;</i>
<i>;</i>
        ldx     #$56
        lda     #$34
        sta     sreg
        lda     #$12
        sta     sreg+1
        lda     #$78
<i>;</i>
<i>; ++__EAX__;</i>
<i>;</i>
        ldy     #$01
        jmp     inceaxy

.endproc
</pre>



<p><a name="k07"></a></p>
<h2 id="k07">7. Rozdíl mezi chováním operátoru pro pre-inkrementaci a post-inkrementaci</h2>

<pre>
void main(void)
{
    register unsigned int x = 42;
    x++;
}
</pre>

<pre>
void main(void)
{
    register unsigned int x = 42;
    ++x;
}
</pre>

<pre>
<i>;</i>
<i>; File generated by cc65 v 2.18 - Ubuntu 2.18-1</i>
<i>;</i>
        .fopt           compiler,"cc65 v 2.18 - Ubuntu 2.18-1"
        .setcpu         "6502"
        .smart          on
        .autoimport     on
        .case           on
        .debuginfo      off
        .importzp       sp, sreg, regsave, regbank
        .importzp       tmp1, tmp2, tmp3, tmp4, ptr1, ptr2, ptr3, ptr4
        .macpack        longbranch
        .forceimport    __STARTUP__
        .export         _main

<i>; ---------------------------------------------------------------</i>
<i>; void __near__ main (void)</i>
<i>; ---------------------------------------------------------------</i>

.segment        "CODE"

.proc   _main: near

.segment        "BSS"

L0002:
        .res    2,$00

.segment        "CODE"

<i>;</i>
<i>; register unsigned int x = 42;</i>
<i>;</i>
        ldx     #$00
        lda     #$2A
        sta     L0002
        stx     L0002+1
<i>;</i>
<i>; x++;</i>
<i>;</i>
        clc
        adc     #$01
        bcc     L0005
        inx
L0005:  sta     L0002
        stx     L0002+1
<i>;</i>
<i>; }</i>
<i>;</i>
        rts

.endproc
</pre>

<pre>
<i>;</i>
<i>; File generated by cc65 v 2.18 - Ubuntu 2.18-1</i>
<i>;</i>
        .fopt           compiler,"cc65 v 2.18 - Ubuntu 2.18-1"
        .setcpu         "6502"
        .smart          on
        .autoimport     on
        .case           on
        .debuginfo      off
        .importzp       sp, sreg, regsave, regbank
        .importzp       tmp1, tmp2, tmp3, tmp4, ptr1, ptr2, ptr3, ptr4
        .macpack        longbranch
        .forceimport    __STARTUP__
        .export         _main

<i>; ---------------------------------------------------------------</i>
<i>; void __near__ main (void)</i>
<i>; ---------------------------------------------------------------</i>

.segment        "CODE"

.proc   _main: near

.segment        "CODE"

<i>;</i>
<i>; register unsigned int x = 42;</i>
<i>;</i>
        lda     #$2A
        jsr     pusha0
<i>;</i>
<i>; x++;</i>
<i>;</i>
        ldy     #$01
        lda     (sp),y
        tax
        dey
        lda     (sp),y
        clc
        adc     #$01
        bcc     L0004
        inx
L0004:  jsr     stax0sp
<i>;</i>
<i>; }</i>
<i>;</i>
        jmp     incsp2

.endproc
</pre>

<pre>
<i>;</i>
<i>; File generated by cc65 v 2.18 - Ubuntu 2.18-1</i>
<i>;</i>
        .fopt           compiler,"cc65 v 2.18 - Ubuntu 2.18-1"
        .setcpu         "6502"
        .smart          on
        .autoimport     on
        .case           on
        .debuginfo      off
        .importzp       sp, sreg, regsave, regbank
        .importzp       tmp1, tmp2, tmp3, tmp4, ptr1, ptr2, ptr3, ptr4
        .macpack        longbranch
        .forceimport    __STARTUP__
        .export         _main

<i>; ---------------------------------------------------------------</i>
<i>; void __near__ main (void)</i>
<i>; ---------------------------------------------------------------</i>

.segment        "CODE"

.proc   _main: near

.segment        "BSS"

L0002:
        .res    2,$00

.segment        "CODE"

<i>;</i>
<i>; register unsigned int x = 42;</i>
<i>;</i>
        ldx     #$00
        lda     #$2A
        sta     L0002
        stx     L0002+1
<i>;</i>
<i>; ++x;</i>
<i>;</i>
        inc     L0002
        bne     L0005
        inc     L0002+1
<i>;</i>
<i>; }</i>
<i>;</i>
L0005:  rts

.endproc
</pre>

<pre>
<i>;</i>
<i>; File generated by cc65 v 2.18 - Ubuntu 2.18-1</i>
<i>;</i>
        .fopt           compiler,"cc65 v 2.18 - Ubuntu 2.18-1"
        .setcpu         "6502"
        .smart          on
        .autoimport     on
        .case           on
        .debuginfo      off
        .importzp       sp, sreg, regsave, regbank
        .importzp       tmp1, tmp2, tmp3, tmp4, ptr1, ptr2, ptr3, ptr4
        .macpack        longbranch
        .forceimport    __STARTUP__
        .export         _main

<i>; ---------------------------------------------------------------</i>
<i>; void __near__ main (void)</i>
<i>; ---------------------------------------------------------------</i>

.segment        "CODE"

.proc   _main: near

.segment        "CODE"

<i>;</i>
<i>; register unsigned int x = 42;</i>
<i>;</i>
        lda     #$2A
        jsr     pusha0
<i>;</i>
<i>; ++x;</i>
<i>;</i>
        lda     #$01
        jsr     addeq0sp
<i>;</i>
<i>; }</i>
<i>;</i>
        jmp     incsp2

.endproc
</pre>



<p><a name="k08"></a></p>
<h2 id="k08">8. Součet celých čísel bez znaménka a se znaménkem</h2>

<pre>
void main(void)
{
    register unsigned char a;
    register unsigned char b;
    register unsigned char c;
    a = 10;
    b = 20;
    c = a + b;
}
</pre>

<pre>
void main(void)
{
    register signed char a;
    register signed char b;
    register signed char c;
    a = 10;
    b = 20;
    c = a + b;
}
</pre>

<pre>
<i>;</i>
<i>; File generated by cc65 v 2.18 - Ubuntu 2.18-1</i>
<i>;</i>
        .fopt           compiler,"cc65 v 2.18 - Ubuntu 2.18-1"
        .setcpu         "6502"
        .smart          on
        .autoimport     on
        .case           on
        .debuginfo      off
        .importzp       sp, sreg, regsave, regbank
        .importzp       tmp1, tmp2, tmp3, tmp4, ptr1, ptr2, ptr3, ptr4
        .macpack        longbranch
        .forceimport    __STARTUP__
        .export         _main

<i>; ---------------------------------------------------------------</i>
<i>; void __near__ main (void)</i>
<i>; ---------------------------------------------------------------</i>

.segment        "CODE"

.proc   _main: near

.segment        "BSS"

L0002:
        .res    1,$00
L0003:
        .res    1,$00
L0004:
        .res    1,$00

.segment        "CODE"

<i>;</i>
<i>; a = 10;</i>
<i>;</i>
        lda     #$0A
        sta     L0002
<i>;</i>
<i>; b = 20;</i>
<i>;</i>
        lda     #$14
        sta     L0003
<i>;</i>
<i>; c = a + b;</i>
<i>;</i>
        lda     L0002
        clc
        adc     L0003
        sta     L0004
<i>;</i>
<i>; }</i>
<i>;</i>
        rts

.endproc
</pre>

<pre>
<i>;</i>
<i>; File generated by cc65 v 2.18 - Ubuntu 2.18-1</i>
<i>;</i>
        .fopt           compiler,"cc65 v 2.18 - Ubuntu 2.18-1"
        .setcpu         "6502"
        .smart          on
        .autoimport     on
        .case           on
        .debuginfo      off
        .importzp       sp, sreg, regsave, regbank
        .importzp       tmp1, tmp2, tmp3, tmp4, ptr1, ptr2, ptr3, ptr4
        .macpack        longbranch
        .forceimport    __STARTUP__
        .export         _main

<i>; ---------------------------------------------------------------</i>
<i>; void __near__ main (void)</i>
<i>; ---------------------------------------------------------------</i>

.segment        "CODE"

.proc   _main: near

.segment        "BSS"

L0002:
        .res    1,$00
L0003:
        .res    1,$00
L0004:
        .res    1,$00

.segment        "CODE"

<i>;</i>
<i>; a = 10;</i>
<i>;</i>
        lda     #$0A
        sta     L0002
<i>;</i>
<i>; b = 20;</i>
<i>;</i>
        lda     #$14
        sta     L0003
<i>;</i>
<i>; c = a + b;</i>
<i>;</i>
        ldx     #$00
        lda     L0002
        bpl     L000B
        dex
L000B:  sta     ptr1
        stx     ptr1+1
        ldx     #$00
        lda     L0003
        bpl     L000C
        dex
L000C:  clc
        adc     ptr1
        pha
        txa
        adc     ptr1+1
        pla
        cmp     #$80
        sta     L0004
<i>;</i>
<i>; }</i>
<i>;</i>
        rts

.endproc
</pre>



<p><a name="k09"></a></p>
<h2 id="k09">9. Modifikace bloku paměti s&nbsp;využitím ukazatele a offsetu</h2>

<pre>
#include <stdint.h>

void memset8(uint8_t * dest, const uint8_t c, const uint8_t n)
{
    register uint8_t i;

    for (i = 0; i < n; i++) {
        dest[i] = c;
    }
}

int main(void)
{
    uint8_t *dest = (uint8_t *) 0x0600;
    uint8_t bytes = 0xff;
    uint8_t fill = 0x00;
    memset8(dest, fill, bytes);

    return 0;
}
</pre>

<pre>
<i>;</i>
<i>; File generated by cc65 v 2.18 - Ubuntu 2.18-1</i>
<i>;</i>
        .fopt           compiler,"cc65 v 2.18 - Ubuntu 2.18-1"
        .setcpu         "6502"
        .smart          on
        .autoimport     on
        .case           on
        .debuginfo      off
        .importzp       sp, sreg, regsave, regbank
        .importzp       tmp1, tmp2, tmp3, tmp4, ptr1, ptr2, ptr3, ptr4
        .macpack        longbranch
        .forceimport    __STARTUP__
        .export         _memset8
        .export         _main

<i>; ---------------------------------------------------------------</i>
<i>; void __near__ memset8 (__near__ unsigned char *, const unsigned char, const unsigned char)</i>
<i>; ---------------------------------------------------------------</i>

.segment        "CODE"

.proc   _memset8: near

.segment        "BSS"

L0002:
        .res    1,$00

.segment        "CODE"

<i>;</i>
<i>; {</i>
<i>;</i>
        jsr     pusha
<i>;</i>
<i>; for (i = 0; i < n; i++) {</i>
<i>;</i>
        lda     #$00
        sta     L0002
L001B:  lda     L0002
        ldy     #$00
        cmp     (sp),y
        bcs     L0004
<i>;</i>
<i>; dest[i] = c;</i>
<i>;</i>
        ldy     #$03
        jsr     ldaxysp
        clc
        adc     L0002
        bcc     L001A
        inx
L001A:  sta     ptr1
        stx     ptr1+1
        ldy     #$01
        lda     (sp),y
        dey
        sta     (ptr1),y
<i>;</i>
<i>; for (i = 0; i < n; i++) {</i>
<i>;</i>
        inc     L0002
        jmp     L001B
<i>;</i>
<i>; }</i>
<i>;</i>
L0004:  jmp     incsp4

.endproc

<i>; ---------------------------------------------------------------</i>
<i>; int __near__ main (void)</i>
<i>; ---------------------------------------------------------------</i>

.segment        "CODE"

.proc   _main: near

.segment        "BSS"

L000F:
        .res    2,$00
L0011:
        .res    1,$00
L0013:
        .res    1,$00

.segment        "CODE"

<i>;</i>
<i>; uint8_t *dest = (uint8_t *) 0x0600;</i>
<i>;</i>
        ldx     #$06
        lda     #$00
        sta     L000F
        stx     L000F+1
<i>;</i>
<i>; uint8_t bytes = 0xff;</i>
<i>;</i>
        lda     #$FF
        sta     L0011
<i>;</i>
<i>; uint8_t fill = 0x00;</i>
<i>;</i>
        lda     #$00
        sta     L0013
<i>;</i>
<i>; memset8(dest, fill, bytes);</i>
<i>;</i>
        lda     L000F
        ldx     L000F+1
        jsr     pushax
        lda     L0013
        jsr     pusha
        lda     L0011
        jsr     _memset8
<i>;</i>
<i>; return 0;</i>
<i>;</i>
        ldx     #$00
        txa
<i>;</i>
<i>; }</i>
<i>;</i>
        rts

.endproc
</pre>

<pre>
#include <stdint.h>

void memset8(uint8_t * dest, const uint8_t c, const uint8_t n)
{
    register uint8_t i;

    for (i = 0; i < n; i++) {
        *(dest+i) = c;
    }
}

int main(void)
{
    uint8_t *dest = (uint8_t *) 0x0600;
    uint8_t bytes = 0xff;
    uint8_t fill = 0x00;
    memset8(dest, fill, bytes);

    return 0;
}
</pre>

<pre>
<i>;</i>
<i>; File generated by cc65 v 2.18 - Ubuntu 2.18-1</i>
<i>;</i>
        .fopt           compiler,"cc65 v 2.18 - Ubuntu 2.18-1"
        .setcpu         "6502"
        .smart          on
        .autoimport     on
        .case           on
        .debuginfo      off
        .importzp       sp, sreg, regsave, regbank
        .importzp       tmp1, tmp2, tmp3, tmp4, ptr1, ptr2, ptr3, ptr4
        .macpack        longbranch
        .forceimport    __STARTUP__
        .export         _memset8
        .export         _main

<i>; ---------------------------------------------------------------</i>
<i>; void __near__ memset8 (__near__ unsigned char *, const unsigned char, const unsigned char)</i>
<i>; ---------------------------------------------------------------</i>

.segment        "CODE"

.proc   _memset8: near

.segment        "BSS"

L0002:
        .res    1,$00

.segment        "CODE"

<i>;</i>
<i>; {</i>
<i>;</i>
        jsr     pusha
<i>;</i>
<i>; for (i = 0; i < n; i++) {</i>
<i>;</i>
        lda     #$00
        sta     L0002
L001B:  lda     L0002
        ldy     #$00
        cmp     (sp),y
        bcs     L0004
<i>;</i>
<i>; *(dest+i) = c;</i>
<i>;</i>
        ldy     #$03
        jsr     ldaxysp
        clc
        adc     L0002
        bcc     L001A
        inx
L001A:  sta     ptr1
        stx     ptr1+1
        ldy     #$01
        lda     (sp),y
        dey
        sta     (ptr1),y
<i>;</i>
<i>; for (i = 0; i < n; i++) {</i>
<i>;</i>
        inc     L0002
        jmp     L001B
<i>;</i>
<i>; }</i>
<i>;</i>
L0004:  jmp     incsp4

.endproc

<i>; ---------------------------------------------------------------</i>
<i>; int __near__ main (void)</i>
<i>; ---------------------------------------------------------------</i>

.segment        "CODE"

.proc   _main: near

.segment        "BSS"

L000F:
        .res    2,$00
L0011:
        .res    1,$00
L0013:
        .res    1,$00

.segment        "CODE"

<i>;</i>
<i>; uint8_t *dest = (uint8_t *) 0x0600;</i>
<i>;</i>
        ldx     #$06
        lda     #$00
        sta     L000F
        stx     L000F+1
<i>;</i>
<i>; uint8_t bytes = 0xff;</i>
<i>;</i>
        lda     #$FF
        sta     L0011
<i>;</i>
<i>; uint8_t fill = 0x00;</i>
<i>;</i>
        lda     #$00
        sta     L0013
<i>;</i>
<i>; memset8(dest, fill, bytes);</i>
<i>;</i>
        lda     L000F
        ldx     L000F+1
        jsr     pushax
        lda     L0013
        jsr     pusha
        lda     L0011
        jsr     _memset8
<i>;</i>
<i>; return 0;</i>
<i>;</i>
        ldx     #$00
        txa
<i>;</i>
<i>; }</i>
<i>;</i>
        rts

.endproc
</pre>



<p><a name="k10"></a></p>
<h2 id="k10">10. Přímý zápis instrukcí v&nbsp;assembleru do céčkového kódu</h2>

<pre>
void main(void)
{
    __asm__ ("lda #1");
    __asm__ ("clc");
    __asm__ ("adc #2");
}
</pre>

<pre>
<i>;</i>
<i>; File generated by cc65 v 2.18 - Ubuntu 2.18-1</i>
<i>;</i>
        .fopt           compiler,"cc65 v 2.18 - Ubuntu 2.18-1"
        .setcpu         "6502"
        .smart          on
        .autoimport     on
        .case           on
        .debuginfo      off
        .importzp       sp, sreg, regsave, regbank
        .importzp       tmp1, tmp2, tmp3, tmp4, ptr1, ptr2, ptr3, ptr4
        .macpack        longbranch
        .forceimport    __STARTUP__
        .export         _main

<i>; ---------------------------------------------------------------</i>
<i>; void __near__ main (void)</i>
<i>; ---------------------------------------------------------------</i>

.segment        "CODE"

.proc   _main: near

.segment        "CODE"

<i>;</i>
<i>; __asm__ ("lda #1");</i>
<i>;</i>
        lda     #1
<i>;</i>
<i>; __asm__ ("clc");</i>
<i>;</i>
        clc
<i>;</i>
<i>; __asm__ ("adc #2");</i>
<i>;</i>
        adc     #2
<i>;</i>
<i>; }</i>
<i>;</i>
        rts

.endproc
</pre>



<p><a name="k11"></a></p>
<h2 id="k11">11. Použití reference na lokální proměnnou v&nbsp;assembleru</h2>

<pre>
void main(void)
{
    register unsigned char a;

    __asm__ ("lda #1");
    __asm__ ("clc");
    __asm__ ("adc #2");
    __asm__ ("sta %v", a);
}
</pre>

<pre>
<i>;</i>
<i>; File generated by cc65 v 2.18 - Ubuntu 2.18-1</i>
<i>;</i>
        .fopt           compiler,"cc65 v 2.18 - Ubuntu 2.18-1"
        .setcpu         "6502"
        .smart          on
        .autoimport     on
        .case           on
        .debuginfo      off
        .importzp       sp, sreg, regsave, regbank
        .importzp       tmp1, tmp2, tmp3, tmp4, ptr1, ptr2, ptr3, ptr4
        .macpack        longbranch
        .forceimport    __STARTUP__
        .export         _main

<i>; ---------------------------------------------------------------</i>
<i>; void __near__ main (void)</i>
<i>; ---------------------------------------------------------------</i>

.segment        "CODE"

.proc   _main: near

.segment        "CODE"

<i>;</i>
<i>; register unsigned char a;</i>
<i>;</i>
        lda     regbank+5
        jsr     pusha
<i>;</i>
<i>; __asm__ ("lda #1");</i>
<i>;</i>
        lda     #1
<i>;</i>
<i>; __asm__ ("clc");</i>
<i>;</i>
        clc
<i>;</i>
<i>; __asm__ ("adc #2");</i>
<i>;</i>
        adc     #2
<i>;</i>
<i>; __asm__ ("sta %v", a);</i>
<i>;</i>
        sta     regbank+5
<i>;</i>
<i>; }</i>
<i>;</i>
        ldy     #$00
        lda     (sp),y
        sta     regbank+5
        jmp     incsp1

.endproc
</pre>



<p><a name="k12"></a></p>
<h2 id="k12">12. Nepatrně složitější příklad: ručně optimalizovaný součet dvou proměnných</h2>

<pre>
void main(void)
{
    register unsigned char a;
    register unsigned char b;
    register unsigned char c;
&nbsp;
&nbsp;
    __asm__ ("lda %v", a);
    __asm__ ("clc");
    __asm__ ("adc %v", b);
    __asm__ ("sta %v", c);
}
</pre>

<pre>
<i>;</i>
<i>; File generated by cc65 v 2.18 - Ubuntu 2.18-1</i>
<i>;</i>
        .fopt           compiler,"cc65 v 2.18 - Ubuntu 2.18-1"
        .setcpu         "6502"
        .smart          on
        .autoimport     on
        .case           on
        .debuginfo      off
        .importzp       sp, sreg, regsave, regbank
        .importzp       tmp1, tmp2, tmp3, tmp4, ptr1, ptr2, ptr3, ptr4
        .macpack        longbranch
        .forceimport    __STARTUP__
        .export         _main
&nbsp;
<i>; ---------------------------------------------------------------</i>
<i>; void __near__ main (void)</i>
<i>; ---------------------------------------------------------------</i>
&nbsp;
.segment        "CODE"
&nbsp;
.proc   _main: near
&nbsp;
.segment        "CODE"
&nbsp;
<i>;</i>
<i>; register unsigned char a;</i>
<i>;</i>
        lda     regbank+5
        jsr     pusha
<i>;</i>
<i>; register unsigned char b;</i>
<i>;</i>
        lda     regbank+4
        jsr     pusha
<i>;</i>
<i>; register unsigned char c;</i>
<i>;</i>
        lda     regbank+3
        jsr     pusha
<i>;</i>
<i>; __asm__ ("lda %v", a);</i>
<i>;</i>
        lda     regbank+5
<i>;</i>
<i>; __asm__ ("clc");</i>
<i>;</i>
        clc
<i>;</i>
<i>; __asm__ ("adc %v", b);</i>
<i>;</i>
        adc     regbank+4
<i>;</i>
<i>; __asm__ ("sta %v", c);</i>
<i>;</i>
        sta     regbank+3
<i>;</i>
<i>; }</i>
<i>;</i>
        ldy     #$00
L000A:  lda     (sp),y
        sta     regbank+3,y
        iny
        cpy     #$03
        bne     L000A
        jmp     incsp3
&nbsp;
.endproc
</pre>



<p><a name="k13"></a></p>
<h2 id="k13">13. Přístup ke globálním proměnným z&nbsp;assembleru</h2>

<p>S&nbsp;naší znalostí toho, jakým způsobem lze kombinovat céčko a assembler,
se můžeme pustit i do &bdquo;složitějšího&ldquo; příkladu. Například se můžeme
pokusit o realizaci součtu dvou globálních proměnných, přičemž výsledek bude
taktéž uložen do globální proměnné. Samotná realizace programu může vypadat
následovně:</p>

<pre>
unsigned char a;
unsigned char b;
unsigned char c;
&nbsp;
void main(void)
{
    __asm__ ("lda %v", a);
    __asm__ ("clc");
    __asm__ ("adc %v", b);
    __asm__ ("sta %v", c);
}
</pre>

<p>Tento program se přeloží následujícím způsobem (zvýrazněny jsou bloky
s&nbsp;globálními proměnnými i dotčená čtveřice instrukcí):</p>

<pre>
<i>;</i>
<i>; File generated by cc65 v 2.18 - Ubuntu 2.18-1</i>
<i>;</i>
        .fopt           compiler,"cc65 v 2.18 - Ubuntu 2.18-1"
        .setcpu         "6502"
        .smart          on
        .autoimport     on
        .case           on
        .debuginfo      off
        .importzp       sp, sreg, regsave, regbank
        .importzp       tmp1, tmp2, tmp3, tmp4, ptr1, ptr2, ptr3, ptr4
        .macpack        longbranch
        .forceimport    __STARTUP__
        .export         _a
        .export         _b
        .export         _c
        .export         _main
&nbsp;
.segment        "BSS"
&nbsp;
<strong>_a:</strong>
        .res    1,$00
<strong>_b:</strong>
        .res    1,$00
<strong>_c:</strong>
        .res    1,$00
&nbsp;
<i>; ---------------------------------------------------------------</i>
<i>; void __near__ main (void)</i>
<i>; ---------------------------------------------------------------</i>
&nbsp;
.segment        "CODE"
&nbsp;
.proc   _main: near
&nbsp;
.segment        "CODE"
&nbsp;
<i>;</i>
<i>; __asm__ ("lda %v", a);</i>
<i>;</i>
        <strong>lda     _a</strong>
<i>;</i>
<i>; __asm__ ("clc");</i>
<i>;</i>
        <strong>clc</strong>
<i>;</i>
<i>; __asm__ ("adc %v", b);</i>
<i>;</i>
        <strong>adc     _b</strong>
<i>;</i>
<i>; __asm__ ("sta %v", c);konkrétní </i>
<i>;</i>
        <strong>sta     _c</strong>
<i>;</i>
<i>; }</i>
<i>;</i>
        rts
&nbsp;
.endproc
</pre>

<p>Zajímavé bude vysledovat, jak vlastně budou instrukce, které ke globálním
proměnným přistupují, přeloženy do strojového kódu:</p>

<pre>
$ <strong>ca65 --listing assembly4_list.asm assembly4.asm</strong>
</pre>

<p>S&nbsp;následujícím výsledkem:</p>

<pre>
000000r 1               ;
000000r 1               ; __asm__ ("lda %v", a);
000000r 1               ;
000000r 1  AD rr rr             lda     _a
000003r 1               ;
000003r 1               ; __asm__ ("clc");
000003r 1               ;
000003r 1  18                   clc
000004r 1               ;
000004r 1               ; __asm__ ("adc %v", b);
000004r 1               ;
000004r 1  6D rr rr             adc     _b
000007r 1               ;
000007r 1               ; __asm__ ("sta %v", c);
000007r 1               ;
000007r 1  8D rr rr             sta     _c
00000Ar 1               ;
00000Ar 1               ; }
00000Ar 1               ;
00000Ar 1  60                   rts
</pre>

<p><div class="rs-tip-major">Poznámka: povšimněte si, že se používají
&bdquo;dlouhé&ldquo; adresy, což není ideální ve chvíli, kdy se podobné
globální proměnné používají velmi často &ndash; tehdy je lepší použít nultou
stránku paměti.</div></p>



<p><a name="k14"></a></p>
<h2 id="k14">14. Bitové posuny a další operace prováděné s&nbsp;akumulátorem</h2>

<pre>
void main(void)
{
    __A__ = 42;

    __A__ += 1;
}
</pre>

<pre>
<i>;</i>
<i>; File generated by cc65 v 2.18 - Ubuntu 2.18-1</i>
<i>;</i>
        .fopt           compiler,"cc65 v 2.18 - Ubuntu 2.18-1"
        .setcpu         "6502"
        .smart          on
        .autoimport     on
        .case           on
        .debuginfo      off
        .importzp       sp, sreg, regsave, regbank
        .importzp       tmp1, tmp2, tmp3, tmp4, ptr1, ptr2, ptr3, ptr4
        .macpack        longbranch
        .forceimport    __STARTUP__
        .export         _main

<i>; ---------------------------------------------------------------</i>
<i>; void __near__ main (void)</i>
<i>; ---------------------------------------------------------------</i>

.segment        "CODE"

.proc   _main: near

.segment        "CODE"

<i>;</i>
<i>; __A__ = 42;</i>
<i>;</i>
        lda     #$2A
<i>;</i>
<i>; __A__ += 1;</i>
<i>;</i>
        clc
        adc     #$01
<i>;</i>
<i>; }</i>
<i>;</i>
        rts

.endproc
</pre>

<pre>
void main(void)
{
    __A__ = 42;

    __A__ <<= 1;
}
</pre>

<pre>
<i>;</i>
<i>; File generated by cc65 v 2.18 - Ubuntu 2.18-1</i>
<i>;</i>
        .fopt           compiler,"cc65 v 2.18 - Ubuntu 2.18-1"
        .setcpu         "6502"
        .smart          on
        .autoimport     on
        .case           on
        .debuginfo      off
        .importzp       sp, sreg, regsave, regbank
        .importzp       tmp1, tmp2, tmp3, tmp4, ptr1, ptr2, ptr3, ptr4
        .macpack        longbranch
        .forceimport    __STARTUP__
        .export         _main

<i>; ---------------------------------------------------------------</i>
<i>; void __near__ main (void)</i>
<i>; ---------------------------------------------------------------</i>

.segment        "CODE"

.proc   _main: near

.segment        "CODE"

<i>;</i>
<i>; __A__ = 42;</i>
<i>;</i>
        lda     #$2A
<i>;</i>
<i>; __A__ <<= 1;</i>
<i>;</i>
        asl     a
<i>;</i>
<i>; }</i>
<i>;</i>
        rts

.endproc
</pre>

<pre>
void main(void)
{
    __A__ = 42;

    __A__ >>= 1;
}
</pre>

<pre>
<i>;</i>
<i>; File generated by cc65 v 2.18 - Ubuntu 2.18-1</i>
<i>;</i>
        .fopt           compiler,"cc65 v 2.18 - Ubuntu 2.18-1"
        .setcpu         "6502"
        .smart          on
        .autoimport     on
        .case           on
        .debuginfo      off
        .importzp       sp, sreg, regsave, regbank
        .importzp       tmp1, tmp2, tmp3, tmp4, ptr1, ptr2, ptr3, ptr4
        .macpack        longbranch
        .forceimport    __STARTUP__
        .export         _main

<i>; ---------------------------------------------------------------</i>
<i>; void __near__ main (void)</i>
<i>; ---------------------------------------------------------------</i>

.segment        "CODE"

.proc   _main: near

.segment        "CODE"

<i>;</i>
<i>; __A__ = 42;</i>
<i>;</i>
        lda     #$2A
<i>;</i>
<i>; __A__ >>= 1;</i>
<i>;</i>
        lsr     a
<i>;</i>
<i>; }</i>
<i>;</i>
        rts

.endproc
</pre>



<p><a name="k15"></a></p>
<h2 id="k15">15. Násobení a dělení dvěma popř.&nbsp;mocninou dvou</h2>

<p>V&nbsp;případě, že budeme obsah proměnné (a ještě lépe obsah akumulátoru)
násobit dvěma či nějakou vyšší mocninou dvojky, bude tato operace převedena na
instrukci pro bitový posun doleva. Můžeme si to snadno otestovat na tomto
příkladu:</p>

<pre>
void main(void)
{
    __A__ = 42;
&nbsp;
    __A__ *= 2;
}
</pre>

<p>Po překladu je zřejmé, že se skutečně použila instrukce <strong>ASL</strong>
určená pro bitový posun doleva:</p>

<pre>
<i>;</i>
<i>; File generated by cc65 v 2.18 - Ubuntu 2.18-1</i>
<i>;</i>
        .fopt           compiler,"cc65 v 2.18 - Ubuntu 2.18-1"
        .setcpu         "6502"
        .smart          on
        .autoimport     on
        .case           on
        .debuginfo      off
        .importzp       sp, sreg, regsave, regbank
        .importzp       tmp1, tmp2, tmp3, tmp4, ptr1, ptr2, ptr3, ptr4
        .macpack        longbranch
        .forceimport    __STARTUP__
        .export         _main
&nbsp;
<i>; ---------------------------------------------------------------</i>
<i>; void __near__ main (void)</i>
<i>; ---------------------------------------------------------------</i>
&nbsp;
.segment        "CODE"
&nbsp;
.proc   _main: near
&nbsp;
.segment        "CODE"
&nbsp;
<i>;</i>
<i>; __A__ = 42;</i>
<i>;</i>
        <strong>lda     #$2A</strong>
<i>;</i>
<i>; __A__ *= 2;</i>
<i>;</i>
        <strong>asl     a</strong>
<i>;</i>
<i>; }</i>
<i>;</i>
        rts
&nbsp;
.endproc
</pre>

<p>Naopak při dělení dvěma nebo dělení vyšší mocninou dvojky se použije bitový
posun doprava. Opět si to otestujeme:</p>

<pre>
void main(void)
{
    __A__ = 42;
&nbsp;
    __A__ /= 2;
}
</pre>

<p>Výsledek bude po překladu vypadat následovně:</p>

<pre>
<i>;</i>
<i>; File generated by cc65 v 2.18 - Ubuntu 2.18-1</i>
<i>;</i>
        .fopt           compiler,"cc65 v 2.18 - Ubuntu 2.18-1"
        .setcpu         "6502"
        .smart          on
        .autoimport     on
        .case           on
        .debuginfo      off
        .importzp       sp, sreg, regsave, regbank
        .importzp       tmp1, tmp2, tmp3, tmp4, ptr1, ptr2, ptr3, ptr4
        .macpack        longbranch
        .forceimport    __STARTUP__
        .export         _main
&nbsp;
<i>; ---------------------------------------------------------------</i>
<i>; void __near__ main (void)</i>
<i>; ---------------------------------------------------------------</i>
&nbsp;
.segment        "CODE"
&nbsp;
.proc   _main: near
&nbsp;
.segment        "CODE"
&nbsp;
<i>;</i>
<i>; __A__ = 42;</i>
<i>;</i>
        <strong>lda     #$2A</strong>
<i>;</i>
<i>; __A__ /= 2;</i>
<i>;</i>
        <strong>lsr     a</strong>
<i>;</i>
<i>; }</i>
<i>;</i>
        rts
&nbsp;
.endproc
</pre>

<p>Při násobení čtyřmi se posun provede dvakrát, což je taktéž korektní:</p>

<pre>
void main(void)
{
    __A__ = 42;
&nbsp;
    __A__ *= 4;
}
</pre>

<p>S&nbsp;výsledkem, v&nbsp;němž můžeme vidět dvojí použití instrukce
<strong>ASL</strong>:</p>

<pre>
<i>;</i>
<i>; File generated by cc65 v 2.18 - Ubuntu 2.18-1</i>
<i>;</i>
        .fopt           compiler,"cc65 v 2.18 - Ubuntu 2.18-1"
        .setcpu         "6502"
        .smart          on
        .autoimport     on
        .case           on
        .debuginfo      off
        .importzp       sp, sreg, regsave, regbank
        .importzp       tmp1, tmp2, tmp3, tmp4, ptr1, ptr2, ptr3, ptr4
        .macpack        longbranch
        .forceimport    __STARTUP__
        .export         _main
&nbsp;
<i>; ---------------------------------------------------------------</i>
<i>; void __near__ main (void)</i>
<i>; ---------------------------------------------------------------</i>
&nbsp;
.segment        "CODE"
&nbsp;
.proc   _main: near
&nbsp;
.segment        "CODE"
&nbsp;
<i>;</i>
<i>; __A__ = 42;</i>
<i>;</i>
        <strong>lda     #$2A</strong>
<i>;</i>
<i>; __A__ *= 4;</i>
<i>;</i>
        <strong>asl     a</strong>
        <strong>asl     a</strong>
<i>;</i>
<i>; }</i>
<i>;</i>
        rts
&nbsp;
.endproc
&nbsp;
</pre>



<p><a name="k16"></a></p>
<h2 id="k16">16. cc65 nakonec není tak hloupý &ndash; násobení třemi a pěti</h2>

<pre>
void main(void)
{
    __A__ = 42;

    __A__ *= 3;
}
</pre>

<pre>
<i>;</i>
<i>; File generated by cc65 v 2.18 - Ubuntu 2.18-1</i>
<i>;</i>
        .fopt           compiler,"cc65 v 2.18 - Ubuntu 2.18-1"
        .setcpu         "6502"
        .smart          on
        .autoimport     on
        .case           on
        .debuginfo      off
        .importzp       sp, sreg, regsave, regbank
        .importzp       tmp1, tmp2, tmp3, tmp4, ptr1, ptr2, ptr3, ptr4
        .macpack        longbranch
        .forceimport    __STARTUP__
        .export         _main

<i>; ---------------------------------------------------------------</i>
<i>; void __near__ main (void)</i>
<i>; ---------------------------------------------------------------</i>

.segment        "CODE"

.proc   _main: near

.segment        "CODE"

<i>;</i>
<i>; __A__ = 42;</i>
<i>;</i>
        lda     #$2A
<i>;</i>
<i>; __A__ *= 3;</i>
<i>;</i>
        sta     tmp1
        asl     a
        clc
        adc     tmp1
<i>;</i>
<i>; }</i>
<i>;</i>
        rts

.endproc
</pre>

<pre>
void main(void)
{
    __A__ = 42;

    __A__ *= 5;
}
</pre>

<pre>
<i>;</i>
<i>; File generated by cc65 v 2.18 - Ubuntu 2.18-1</i>
<i>;</i>
        .fopt           compiler,"cc65 v 2.18 - Ubuntu 2.18-1"
        .setcpu         "6502"
        .smart          on
        .autoimport     on
        .case           on
        .debuginfo      off
        .importzp       sp, sreg, regsave, regbank
        .importzp       tmp1, tmp2, tmp3, tmp4, ptr1, ptr2, ptr3, ptr4
        .macpack        longbranch
        .forceimport    __STARTUP__
        .export         _main

<i>; ---------------------------------------------------------------</i>
<i>; void __near__ main (void)</i>
<i>; ---------------------------------------------------------------</i>

.segment        "CODE"

.proc   _main: near

.segment        "CODE"

<i>;</i>
<i>; __A__ = 42;</i>
<i>;</i>
        lda     #$2A
<i>;</i>
<i>; __A__ *= 5;</i>
<i>;</i>
        sta     tmp1
        asl     a
        asl     a
        clc
        adc     tmp1
<i>;</i>
<i>; }</i>
<i>;</i>
        rts

.endproc
</pre>



<p><a name="k17"></a></p>
<h2 id="k17">17. </h2>

<pre>
void main(void)
{
    __A__ = 42;

    __A__ *= 42;
}
</pre>

<pre>
<i>;</i>
<i>; File generated by cc65 v 2.18 - Ubuntu 2.18-1</i>
<i>;</i>
        .fopt           compiler,"cc65 v 2.18 - Ubuntu 2.18-1"
        .setcpu         "6502"
        .smart          on
        .autoimport     on
        .case           on
        .debuginfo      off
        .importzp       sp, sreg, regsave, regbank
        .importzp       tmp1, tmp2, tmp3, tmp4, ptr1, ptr2, ptr3, ptr4
        .macpack        longbranch
        .forceimport    __STARTUP__
        .export         _main

<i>; ---------------------------------------------------------------</i>
<i>; void __near__ main (void)</i>
<i>; ---------------------------------------------------------------</i>

.segment        "CODE"

.proc   _main: near

.segment        "CODE"

<i>;</i>
<i>; __A__ = 42;</i>
<i>;</i>
        lda     #$2A
<i>;</i>
<i>; __A__ *= 42;</i>
<i>;</i>
        jsr     pusha0
        jmp     tosumulax

.endproc
</pre>



<p><a name="k18"></a></p>
<h2 id="k18">18. Upravený soubor Makefile</h2>

<p>Pro úplnost si ještě ukažme, jak vypadá soubor Makefile, kterým byly
přeloženy všechny minule i dnes popsané demonstrační příklady. Tento soubor
předpokládá, že je <strong>cc65</strong> nainstalován tak, že je dostupný bez
nutnosti uvedení celé cesty k&nbsp;překladači. V&nbsp;opačném případě je nutné
změnit prvních několik řádků tohoto souboru:</p>

<pre>
</pre>



<p><a name="k19"></a></p>
<h2 id="k19">19. Repositář s&nbsp;demonstračními příklady</h2>

<p>Demonstrační příklady napsané v&nbsp;jazyku C, které jsou určené pro překlad
pomocí překladače <strong>cc65</strong>, byly uložen do Git repositáře, který
je dostupný na adrese <a
href="https://github.com/tisnik/8bit-fame">https://github.com/tisnik/8bit-fame</a>.
Jednotlivé demonstrační příklady si můžete v&nbsp;případě potřeby stáhnout i
jednotlivě bez nutnosti klonovat celý (dnes již poměrně rozsáhlý)
repositář:</p>

<table>
<tr><th> #</th><th>Příklad</th><th>Stručný popis</th><th>Adresa</th></tr>
<tr><td> 1</td><td>local_add.c</td><td>funkce pro součet dvou celých čísel</td><td><a href="https://github.com/tisnik/8bit-fame/blob/master/cc65/local_add.c">https://github.com/tisnik/8bit-fame/blob/master/cc65/local_add.c</a></td></tr>
<tr><td> 2</td><td>memset1.c</td><td>vyplnění bloku paměti zadanou hodnotou, základní verze</td><td><a href="https://github.com/tisnik/8bit-fame/blob/master/cc65/memset1.c">https://github.com/tisnik/8bit-fame/blob/master/cc65/memset1.c</a></td></tr>
<tr><td> 3</td><td>memset2.c</td><td>vyplnění bloku paměti zadanou hodnotou, použití klíčového slova <strong>register</strong></td><td><a href="https://github.com/tisnik/8bit-fame/blob/master/cc65/memset2.c">https://github.com/tisnik/8bit-fame/blob/master/cc65/memset2.c</a></td></tr>
<tr><td> 4</td><td>memset3.c</td><td>vyplnění bloku paměti zadanou hodnotou, použití konstantních parametrů</td><td><a href="https://github.com/tisnik/8bit-fame/blob/master/cc65/memset3.c">https://github.com/tisnik/8bit-fame/blob/master/cc65/memset3.c</a></td></tr>
<tr><td> 5</td><td>memset4.c</td><td>vyplnění bloku paměti zadanou hodnotou, přepis na smyčku <strong>while</strong></td><td><a href="https://github.com/tisnik/8bit-fame/blob/master/cc65/memset4.c">https://github.com/tisnik/8bit-fame/blob/master/cc65/memset4.c</a></td></tr>
<tr><td> 6</td><td>memset5.c</td><td>vyplnění bloku paměti zadanou hodnotou, přepis na smyčku <strong>do-while</strong></td><td><a href="https://github.com/tisnik/8bit-fame/blob/master/cc65/memset5.c">https://github.com/tisnik/8bit-fame/blob/master/cc65/memset5.c</a></td></tr>
<tr><td> 7</td><td>memset6.c</td><td>použití ukazatele namísto indexování přes pole</td><td><a href="https://github.com/tisnik/8bit-fame/blob/master/cc65/memset6.c">https://github.com/tisnik/8bit-fame/blob/master/cc65/memset6.c</a></td></tr>
<tr><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td></tr>
<tr><td> 8</td><td>empty_main.c</td><td>zdrojový kód obsahující pouze prázdnou funkci <strong>main</strong></td><td><a href="https://github.com/tisnik/8bit-fame/blob/master/cc65/empty_main.c">https://github.com/tisnik/8bit-fame/blob/master/cc65/empty_main.c</a></td></tr>
<tr><td> 9</td><td>local_var.c</td><td>funkce <strong>main</strong> s&nbsp;lokální proměnnou</td><td><a href="https://github.com/tisnik/8bit-fame/blob/master/cc65/local_var.c">https://github.com/tisnik/8bit-fame/blob/master/cc65/local_var.c</a></td></tr>
<tr><td>10</td><td>register_var.c</td><td>funkce <strong>main</strong> s&nbsp;proměnnou s&nbsp;deklarací <strong>register</strong></td><td><a href="https://github.com/tisnik/8bit-fame/blob/master/cc65/register_var.c">https://github.com/tisnik/8bit-fame/blob/master/cc65/register_var.c</a></td></tr>
<tr><td>11</td><td>a_register.c</td><td>manipulace s&nbsp;registrem A</td><td><a href="https://github.com/tisnik/8bit-fame/blob/master/cc65/a_register.c">https://github.com/tisnik/8bit-fame/blob/master/cc65/a_register.c</a></td></tr>
<tr><td>12</td><td>ax_register.c</td><td>manipulace s&nbsp;dvojicí registrů A a X</td><td><a href="https://github.com/tisnik/8bit-fame/blob/master/cc65/ax_register.c">https://github.com/tisnik/8bit-fame/blob/master/cc65/ax_register.c</a></td></tr>
<tr><td>13</td><td>eax_register.c</td><td>manipulace s&nbsp;dvojicí registrů A, X a dvojicí paměťových míst</td><td><a href="https://github.com/tisnik/8bit-fame/blob/master/cc65/eax_register.c">https://github.com/tisnik/8bit-fame/blob/master/cc65/eax_register.c</a></td></tr>
<tr><td>14</td><td>post_increment.c</td><td>použití operátoru ++ <i>za</i> operandem (postfixová varianta)</td><td><a href="https://github.com/tisnik/8bit-fame/blob/master/cc65/post_increment.c">https://github.com/tisnik/8bit-fame/blob/master/cc65/post_increment.c</a></td></tr>
<tr><td>15</td><td>pre_increment.c</td><td>použití operátoru ++ <i>před</i> operandem (prefixová varianta)</td><td><a href="https://github.com/tisnik/8bit-fame/blob/master/cc65/pre_increment.c">https://github.com/tisnik/8bit-fame/blob/master/cc65/pre_increment.c</a></td></tr>
<tr><td>16</td><td>assembly1.c</td><td>mixování kódu v&nbsp;C a assembleru</td><td><a href="https://github.com/tisnik/8bit-fame/blob/master/cc65/assembly1.c">https://github.com/tisnik/8bit-fame/blob/master/cc65/assembly1.c</a></td></tr>
<tr><td>17</td><td>assembly2.c</td><td>uložení výsledku do lokální proměnné jedinou instrukcí assembleru</td><td><a href="https://github.com/tisnik/8bit-fame/blob/master/cc65/assembly2.c">https://github.com/tisnik/8bit-fame/blob/master/cc65/assembly2.c</a></td></tr>
<tr><td>18</td><td>assembly3.c</td><td>součet ručně optimalizovaný v&nbsp;assembleru</td><td><a href="https://github.com/tisnik/8bit-fame/blob/master/cc65/assembly3.c">https://github.com/tisnik/8bit-fame/blob/master/cc65/assembly3.c</a></td></tr>
<tr><td>19</td><td>assembly4.c</td><td>taktéž součet, ovšem tentokrát s&nbsp;globálními proměnnými</td><td><a href="https://github.com/tisnik/8bit-fame/blob/master/cc65/assembly4.c">https://github.com/tisnik/8bit-fame/blob/master/cc65/assembly4.c</a></td></tr>
<tr><td>20</td><td>local_add_B.c</td><td>součet bez použití assembleru</td><td><a href="https://github.com/tisnik/8bit-fame/blob/master/cc65/local_add_B.c">https://github.com/tisnik/8bit-fame/blob/master/cc65/local_add_B.c</a></td></tr>
<tr><td>21</td><td>local_mul.c</td><td>vynásobení dvou proměnných bez použití assembleru</td><td><a href="https://github.com/tisnik/8bit-fame/blob/master/cc65/local_mul.c">https://github.com/tisnik/8bit-fame/blob/master/cc65/local_mul.c</a></td></tr>
<tr><td>22</td><td>a_register_add.c</td><td>přičtení jedničky k&nbsp;akumulátoru</td><td><a href="https://github.com/tisnik/8bit-fame/blob/master/cc65/a_register_add.c">https://github.com/tisnik/8bit-fame/blob/master/cc65/a_register_add.c</a></td></tr>
<tr><td>23</td><td>a_register_shift.c</td><td>aritmetický posun akumulátoru doleva</td><td><a href="https://github.com/tisnik/8bit-fame/blob/master/cc65/a_register_shift.c">https://github.com/tisnik/8bit-fame/blob/master/cc65/a_register_shift.c</a></td></tr>
<tr><td>24</td><td>a_register_rshift.c</td><td>aritmetický posun akumulátoru doprava</td><td><a href="https://github.com/tisnik/8bit-fame/blob/master/cc65/a_register_rshift.c">https://github.com/tisnik/8bit-fame/blob/master/cc65/a_register_rshift.c</a></td></tr>
<tr><td>25</td><td>a_register_half.c</td><td>vydělení akumulátoru dvěma</td><td><a href="https://github.com/tisnik/8bit-fame/blob/master/cc65/a_register_half.c">https://github.com/tisnik/8bit-fame/blob/master/cc65/a_register_half.c</a></td></tr>
<tr><td>26</td><td>a_register_double.c</td><td>vynásobení akumulátoru dvěma</td><td><a href="https://github.com/tisnik/8bit-fame/blob/master/cc65/a_register_double.c">https://github.com/tisnik/8bit-fame/blob/master/cc65/a_register_double.c</a></td></tr>
<tr><td>27</td><td>a_register_triple.c</td><td>vynásobení akumulátoru třemi</td><td><a href="https://github.com/tisnik/8bit-fame/blob/master/cc65/a_register_triple.c">https://github.com/tisnik/8bit-fame/blob/master/cc65/a_register_triple.c</a></td></tr>
<tr><td>28</td><td>a_register_quadruple.c</td><td>vynásobení akumulátoru čtyřmi</td><td><a href="https://github.com/tisnik/8bit-fame/blob/master/cc65/a_register_quadruple.c">https://github.com/tisnik/8bit-fame/blob/master/cc65/a_register_quadruple.c</a></td></tr>
<tr><td>29</td><td>a_register_times5.c</td><td>vynásobení akumulátoru pěti</td><td><a href="https://github.com/tisnik/8bit-fame/blob/master/cc65/a_register_times5.c">https://github.com/tisnik/8bit-fame/blob/master/cc65/a_register_times5.c</a></td></tr>
<tr><td>30</td><td>a_register_times42.c</td><td>vynásobení akumulátoru konstantou 42</td><td><a href="https://github.com/tisnik/8bit-fame/blob/master/cc65/a_register_times42.c">https://github.com/tisnik/8bit-fame/blob/master/cc65/a_register_times42.c</a></td></tr>
<tr><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td></tr>
<tr><td>31</td><td>Makefile</td><td>soubor zajišťující překlad všech demonstračních příkladů do assembleru s&nbsp;různými volbami</td><td><a href="https://github.com/tisnik/8bit-fame/blob/master/cc65/Makefile">https://github.com/tisnik/8bit-fame/blob/master/cc65/Makefile</a></td></tr>
</table>



<p><a name="k20"></a></p>
<h2 id="k20">20. Odkazy na Internetu</h2>

<ol>

<li>When did people first start thinking 'C is portable assembler'?<br />
<a href="https://stackoverflow.com/questions/3040276/when-did-people-first-start-thinking-c-is-portable-assembler">https://stackoverflow.com/questions/3040276/when-did-people-first-start-thinking-c-is-portable-assembler</a>
</li>

<li>The Thirty Million Line Problem<br />
<a href="https://www.youtube.com/watch?v=kZRE7HIO3vk">https://www.youtube.com/watch?v=kZRE7HIO3vk</a>
</li>

<li>cc65 coding hints<br />
<a href="https://cc65.github.io/doc/coding.html">https://cc65.github.io/doc/coding.html</a>
</li>

<li>NesDev.org<br />
<a href="https://www.nesdev.org/">https://www.nesdev.org/</a>
</li>

<li>How to Program an NES game in C<br />
<a href="https://nesdoug.com/">https://nesdoug.com/</a>
</li>

<li>Cycle reference chart<br />
<a href="https://www.nesdev.org/wiki/Cycle_reference_chart">https://www.nesdev.org/wiki/Cycle_reference_chart</a>
</li>

<li>Getting Started Programming in C: Coding a Retro Game with C Part 2<br />
<a href="https://retrogamecoders.com/getting-started-with-c-cc65/">https://retrogamecoders.com/getting-started-with-c-cc65/</a>
</li>

<li>NES game development in 6502 assembly - Part 1<br />
<a href="https://kibrit.tech/en/blog/nes-game-development-part-1">https://kibrit.tech/en/blog/nes-game-development-part-1</a>
</li>

<li>NES 6502 Programming Tutorial - Part 1: Getting Started<br />
<a href="https://dev.xenforo.relay.cool/index.php?threads/nes-6502-programming-tutorial-part-1-getting-started.858389/">https://dev.xenforo.relay.cool/index.php?threads/nes-6502-programming-tutorial-part-1-getting-started.858389/</a>
</li>

<li>List of 6502-based Computers and Consoles<br />
<a href="https://www.retrocompute.co.uk/list-of-6502-based-computers-and-consoles/">https://www.retrocompute.co.uk/list-of-6502-based-computers-and-consoles/</a>
</li>

<li>6502 - the first RISC &micro;P<br />
<a href="http://ericclever.com/6500/">http://ericclever.com/6500/</a>
</li>

<li>ca65 Users Guide<br />
<a href="https://cc65.github.io/doc/ca65.html">https://cc65.github.io/doc/ca65.html</a>
</li>

<li>cc65 Users Guide<br />
<a href="https://cc65.github.io/doc/cc65.html">https://cc65.github.io/doc/cc65.html</a>
</li>

<li>ld65 Users Guide<br />
<a href="https://cc65.github.io/doc/ld65.html">https://cc65.github.io/doc/ld65.html</a>
</li>

<li>da65 Users Guide<br />
<a href="https://cc65.github.io/doc/da65.html">https://cc65.github.io/doc/da65.html</a>
</li>

<li>“Hello, world” from scratch on a 6502 — Part 1<br />
<a href="https://www.youtube.com/watch?v=LnzuMJLZRdU">https://www.youtube.com/watch?v=LnzuMJLZRdU</a>
</li>

<li>A Tour of 6502 Cross-Assemblers<br />
<a href="https://bumbershootsoft.wordpress.com/2016/01/31/a-tour-of-6502-cross-assemblers/">https://bumbershootsoft.wordpress.com/2016/01/31/a-tour-of-6502-cross-assemblers/</a>
</li>

<li>6502 PRIMER: Building your own 6502 computer<br />
<a href="http://wilsonminesco.com/6502primer/">http://wilsonminesco.com/6502primer/</a>
</li>

<li>6502 Instruction Set<br />
<a href="https://www.masswerk.at/6502/6502_instruction_set.html">https://www.masswerk.at/6502/6502_instruction_set.html</a>
</li>

<li>Chip Hall of Fame: MOS Technology 6502 Microprocessor<br />
<a href="https://spectrum.ieee.org/tech-history/silicon-revolution/chip-hall-of-fame-mos-technology-6502-microprocessor">https://spectrum.ieee.org/tech-history/silicon-revolution/chip-hall-of-fame-mos-technology-6502-microprocessor</a>
</li>

<li>Single-board computer<br />
<a href="https://en.wikipedia.org/wiki/Single-board_computer">https://en.wikipedia.org/wiki/Single-board_computer</a>
</li>

<li>www.6502.org<br />
<a href="http://www.6502­.org/">http://www.6502­.org/</a>
</li>

<li>6502 PRIMER: Building your own 6502 computer &ndash; clock generator<br />
<a href="http://wilsonminesco.com/6502primer/ClkGen.html">http://wilsonminesco.com/6502primer/ClkGen.html</a>
</li>

<li>Great Microprocessors of the Past and Present (V 13.4.0)<br />
<a href="http://www.cpushack.com/CPU/cpu.html">http://www.cpushack.com/CPU/cpu.html</a>
</li>

<li>Jak se zrodil procesor?<br />
<a href="https://www.root.cz/clanky/jak-se-zrodil-procesor/">https://www.root.cz/clanky/jak-se-zrodil-procesor/</a>
</li>

<li>Osmibitové mikroprocesory a mikrořadiče firmy Motorola (1)<br />
<a href="https://www.root.cz/clanky/osmibitove-mikroprocesory-a-mikroradice-firmy-motorola-1/">https://www.root.cz/clanky/osmibitove-mikroprocesory-a-mikroradice-firmy-motorola-1/</a>
</li>

<li>Mikrořadiče a jejich použití v jednoduchých mikropočítačích<br />
<a href="https://www.root.cz/clanky/mikroradice-a-jejich-pouziti-v-jednoduchych-mikropocitacich/">https://www.root.cz/clanky/mikroradice-a-jejich-pouziti-v-jednoduchych-mikropocitacich/</a>
</li>

<li>Mikrořadiče a jejich aplikace v jednoduchých mikropočítačích (2)<br />
<a href="https://www.root.cz/clanky/mikroradice-a-jejich-aplikace-v-jednoduchych-mikropocitacich-2/">https://www.root.cz/clanky/mikroradice-a-jejich-aplikace-v-jednoduchych-mikropocitacich-2/</a>
</li>

<li>25 Microchips That Shook the World<br />
<a href="https://spectrum.ieee.org/tech-history/silicon-revolution/25-microchips-that-shook-the-world">https://spectrum.ieee.org/tech-history/silicon-revolution/25-microchips-that-shook-the-world</a>
</li>

<li>Comparison of instruction set architectures<br />
<a href="https://en.wikipedia.org/wiki/Comparison_of_instruction_set_architectures">https://en.wikipedia.org/wiki/Comparison_of_instruction_set_architectures</a>
</li>

<li>Vývojové nástroje používané v dobách osmibitových mikropočítačů<br />
<a href="https://www.root.cz/clanky/vyvojove-nastroje-pouzivane-v-dobach-osmibitovych-mikropocitacu/">https://www.root.cz/clanky/vyvojove-nastroje-pouzivane-v-dobach-osmibitovych-mikropocitacu/</a>
</li>

<li>Historie vývoje počítačových her (112. část – vývojové nástroje pro herní konzole)<br />
<a href="https://www.root.cz/clanky/historie-vyvoje-pocitacovych-her-112-cast-vyvojove-nastroje-pro-herni-konzole/">https://www.root.cz/clanky/historie-vyvoje-pocitacovych-her-112-cast-vyvojove-nastroje-pro-herni-konzole/</a>
</li>

<li>Programovací jazyky a vývojové nástroje pro mikropočítače společnosti Sinclair Research<br />
<a href="https://www.root.cz/clanky/programovaci-jazyky-a-vyvojove-nastroje-pro-mikropocitace-spolecnosti-sinclair-research/">https://www.root.cz/clanky/programovaci-jazyky-a-vyvojove-nastroje-pro-mikropocitace-spolecnosti-sinclair-research/</a>
</li>

<li>Programovací jazyky používané na platformě osmibitových domácích mikropočítačů Atari<br />
<a href="https://www.root.cz/clanky/programovaci-jazyky-pouzivane-na-platforme-osmibitovych-domacich-mikropocitacu-atari/">https://www.root.cz/clanky/programovaci-jazyky-pouzivane-na-platforme-osmibitovych-domacich-mikropocitacu-atari/</a>
</li>

<li>Programovací jazyky používané na platformě osmibitových domácích mikropočítačů Atari (2)<br />
<a href="https://www.root.cz/clanky/programovaci-jazyky-pouzivane-na-platforme-osmibitovych-domacich-mikropocitacu-atari-2/">https://www.root.cz/clanky/programovaci-jazyky-pouzivane-na-platforme-osmibitovych-domacich-mikropocitacu-atari-2/</a>
</li>

<li>Cross assemblery a cross překladače pro platformu osmibitových domácích mikropočítačů Atari<br />
<a href="https://www.root.cz/clanky/cross-assemblery-a-cross-prekladace-pro-platformu-osmibitovych-domacich-mikropocitacu-atari/">https://www.root.cz/clanky/cross-assemblery-a-cross-prekladace-pro-platformu-osmibitovych-domacich-mikropocitacu-atari/</a>
</li>

<li>C Isn't A Programming Language Anymore<br />
<a href="https://faultlore.com/blah/c-isnt-a-language/">https://faultlore.com/blah/c-isnt-a-language/</a>
</li>

<li>Why the C Language Will Never Stop You from Making Mistakes<br />
<a href="https://thephd.dev/your-c-compiler-and-standard-library-will-not-help-you">https://thephd.dev/your-c-compiler-and-standard-library-will-not-help-you</a>
</li>

<li>Benchmark: C compilers for the 6502 CPU<br />
<a href="https://sgadrat.itch.io/super-tilt-bro/devlog/219534/benchmark-c-compilers-for-the-6502-cpu">https://sgadrat.itch.io/super-tilt-bro/devlog/219534/benchmark-c-compilers-for-the-6502-cpu</a>
</li>

<li>Advanced optimizations in CC65<br />
<a href="https://github.com/ilmenit/CC65-Advanced-Optimizations">https://github.com/ilmenit/CC65-Advanced-Optimizations</a>
</li>

<li>The 6502/65C02/65C816 Instruction Set Decoded<br />
<a href="https://llx.com/Neil/a2/opcodes.html">https://llx.com/Neil/a2/opcodes.html</a>
</li>

<li>6502 C Compilers Comparison<br />
<a href="https://gglabs.us/node/2293">https://gglabs.us/node/2293</a>
</li>

<li>6502 C compilers benchmark<br />
<a href="https://github.com/sgadrat/6502-compilers-bench">https://github.com/sgadrat/6502-compilers-bench</a>
</li>

<li>cc65: Differences to the ISO standard<br />
<a href="https://cc65.github.io/doc/cc65.html#s4">https://cc65.github.io/doc/cc65.html#s4</a>
</li>

<li>Compilers<br />
<a href="http://www.6502.org/tools/lang/">http://www.6502.org/tools/lang/</a>
</li>

<li>Překladače jazyka C pro historické osmibitové mikroprocesory<br />
<a href="https://www.root.cz/clanky/prekladace-jazyka-c-pro-historicke-osmibitove-mikroprocesory/">https://www.root.cz/clanky/prekladace-jazyka-c-pro-historicke-osmibitove-mikroprocesory/</a>
</li>

</ol>



<p></p><p></p>
<p><small>Autor: <a href="http://www.fit.vutbr.cz/~tisnovpa">Pavel Tišnovský</a> &nbsp; 2022</small></p>
</body>
</html>

