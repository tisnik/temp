<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
        "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html>
<head>
<title>Překladače programovacího jazyka C pro historické osmibitové mikroprocesory 2</title>
<meta name="Author" content="Pavel Tisnovsky" />
<meta name="Generator" content="vim" />
<meta http-equiv="content-type" content="text/html; charset=utf-8" />
<style type="text/css">
         body {color:#000000; background:#ffffff;}
         h1  {font-family: arial, helvetica, sans-serif; color:#ffffff; background-color:#c00000; text-align:center; padding-left:1em}
         h2  {font-family: arial, helvetica, sans-serif; color:#ffffff; background-color:#0000c0; padding-left:1em; text-align:left}
         h3  {font-family: arial, helvetica, sans-serif; color:#000000; background-color:#c0c0c0; padding-left:1em; text-align:left}
         h4  {font-family: arial, helvetica, sans-serif; color:#000000; background-color:#e0e0e0; padding-left:1em; text-align:left}
         a   {font-family: arial, helvetica, sans-serif;}
         li  {font-family: arial, helvetica, sans-serif; color:#000000; text-align:justify; width:450px;}
         ol  {font-family: arial, helvetica, sans-serif; color:#000000; text-align:justify; width:450px;}
         ul  {font-family: arial, helvetica, sans-serif; color:#000000; text-align:justify; width:450px;}
         p   {font-family: arial, helvetica, sans-serif; color:#000000; text-align:justify;}
         pre {background:#e0e0e0}
</style>
</head>

<body>

<h1>Překladače programovacího jazyka C pro historické osmibitové mikroprocesory 2</h1>

<h3>Pavel Tišnovský</h3>

<p></p>

<h1>Úvodník</h1>

<p>Ve druhé a současně i závěrečné části článku o překladači cc65 si řekneme, jakým způsobem můžeme využít některé jeho speciální vlastnosti, například možnost mixovat kód psaný v jazyku C s assemblerem (na úrovni zdrojového kódu) nebo použití pseudoproměnných __A__, __AX__ atd.</p>



<h2>Obsah</h2>

<p><a href="#k01">1. Dokončení popisu překladače jazyka C pro osmibitové mikroprocesory MOS 6502: cc65</a></p>
<p><a href="#k02">2. Volba, do jaké paměťové oblasti se mají uložit lokální proměnné</a></p>
<p><a href="#k03">3. Vliv klíčového slova <strong>register</strong> na způsob uložení lokálních proměnných</a></p>
<p><a href="#k04">4. Přímý přístup k&nbsp;akumulátoru s&nbsp;využitím identifikátoru <strong>__A_</strong></a></p>
<p><a href="#k05">5. Přístup k&nbsp;registrovému páru A + X s&nbsp;využitím identifikátoru <strong>__AX__</strong></a></p>
<p><a href="#k06">6. Přístup k&nbsp;32bitové hodnotě uložené ve dvou buňkách RAM a v&nbsp;registrovém páru A + X</a></p>
<p><a href="#k07">7. Rozdíl mezi chováním operátoru pro pre-inkrementaci a post-inkrementaci</a></p>
<p><a href="#k08">8. Součet celých čísel bez znaménka a se znaménkem</a></p>
<p><a href="#k09">9. Modifikace bloku paměti s&nbsp;využitím ukazatele a offsetu</a></p>
<p><a href="#k10">10. Přímý zápis instrukcí v&nbsp;assembleru do céčkového kódu</a></p>
<p><a href="#k11">11. Použití reference na lokální proměnnou v&nbsp;assembleru</a></p>
<p><a href="#k12">12. Nepatrně složitější příklad: ručně optimalizovaný součet dvou proměnných</a></p>
<p><a href="#k13">13. Přístup ke globálním proměnným z&nbsp;assembleru</a></p>
<p><a href="#k14">14. Bitové posuny a další operace prováděné s&nbsp;akumulátorem</a></p>
<p><a href="#k15">15. Násobení a dělení dvěma popř.&nbsp;mocninou dvou</a></p>
<p><a href="#k16">16. cc65 nakonec není tak hloupý &ndash; násobení třemi a pěti</a></p>
<p><a href="#k17">17. Násobení větší konstantou</a></p>
<p><a href="#k18">18. Upravený soubor Makefile</a></p>
<p><a href="#k19">19. Repositář s&nbsp;demonstračními příklady</a></p>
<p><a href="#k20">20. Odkazy na Internetu</a></p>



<p><a name="k01"></a></p>
<h2 id="k01">1. Dokončení popisu překladače jazyka C pro osmibitové mikroprocesory MOS 6502: cc65</h2>

<p>Na <a
href="https://www.root.cz/clanky/prekladace-jazyka-c-pro-historicke-osmibitove-mikroprocesory/">úvodní
článek o překladačích jazyka C určených pro různé osmibitové procesory</a> dnes
navážeme. Připomeňme si, že jsme se zabývali překladem zdrojových kódů
napsaných v&nbsp;céčku do assembleru (a posléze i strojového kódu) osmibitových
mikroprocesorů MOS 6502, které byly použity například v&nbsp;domácích
počítačích Atari a Commodore, v&nbsp;osobních mikropočítačích Apple,
v&nbsp;herních konzolích Atari 2600 (zjednodušený MOS 6507), NES atd. Jednalo
se tedy o populární mikroprocesor, pro nějž vzniklo hned několik překladačů
jazyka C. Nás však zajímá především cross překladač <strong>cc65</strong>,
který umožňuje překlad zdrojových kódů na PC s&nbsp;přenosem výsledného
strojového kódu na zvolenou osmibitovou architekturu. Cross překladač
<strong>cc65</strong> je poměrně populární, ovšem neprovádí žádné složitější
optimalizace a pro jeho úspěšné použití je nutné znát jeho limity a různá temná
zákoutí &ndash; v&nbsp;opačném případě nebude produkovaný kód kvalitní.</p>

<p><div class="rs-tip-major">Poznámka: na rozdíl od moderních překladačů
určených pro (taktéž) moderní architektury mikroprocesorů je v&nbsp;případě
<strong>cc65</strong> <i>vždy</i> možné bez většího úsilí tento překladač
překonat a naprogramovat optimalizovaný kód přímo v&nbsp;assembleru.
V&nbsp;případě moderních architektur je to samozřejmě mnohem složitější (a
většinou taktéž zbytečné, což o MOS 6502 neplatí &ndash; zde je znalost
assembleru takřka nutností).</div></p>

<p>Na úvod se podívejme na to, jakým způsobem se přeloží prázdná funkce
<strong>main</strong>, kterou jsme navíc (poněkud v&nbsp;rozporu se standardem
céčka) nadeklarovali bez parametrů a bez návratové hodnoty:</p>

<pre>
void main(void)
{
}
</pre>

<p>Překlad do assembleru provedeme příkazem:</p>

<pre>
$ <strong>cc65 -T -Cl -O -o empty_main.asm empty_main.c</strong>
</pre>

<p>Význam jednotlivých přepínačů:</p>

<ul>

<li><strong>-T</strong> zajistí, že se do kódu v&nbsp;assembleru
v&nbsp;poznámkách vloží i původní zdrojový kód, takže bude zřejmé, jaké
strojové instrukce odpovídají danému řádku v&nbsp;céčku.</li>

<li><strong>-Cl</strong> povolí použití statických lokálních proměnných, což
vede ke kratšímu a současně i rychlejšímu kódu, protože MOS 6502 neumí (dobře)
adresovat operandy na zásobníku.</li>

<li><strong>-O</strong> povolí základní optimalizace prováděně překladačem. Bez
tohoto přepínače nemá smysl <strong>cc65</strong> vůbec používat
(skutečně!).</li>

<li><strong>-o</strong> je volba určující jméno výsledného souboru
s&nbsp;assemblerem.</li>

</ul>

<p>Výsledkem bude soubor nazvaný <strong>empty_main.asm</strong>, jenž bude
vypadat následovně:</p>

<pre>
<i>;</i>
<i>; File generated by cc65 v 2.18 - Ubuntu 2.18-1</i>
<i>;</i>
        .fopt           compiler,"cc65 v 2.18 - Ubuntu 2.18-1"
        .setcpu         "6502"
        .smart          on
        .autoimport     on
        .case           on
        .debuginfo      off
        .importzp       sp, sreg, regsave, regbank
        .importzp       tmp1, tmp2, tmp3, tmp4, ptr1, ptr2, ptr3, ptr4
        .macpack        longbranch
        .forceimport    __STARTUP__
        .export         _main
&nbsp;
<i>; ---------------------------------------------------------------</i>
<i>; void __near__ main (void)</i>
<i>; ---------------------------------------------------------------</i>
&nbsp;
.segment        "CODE"
&nbsp;
.proc   _main: near
&nbsp;
.segment        "CODE"
&nbsp;
<i>;</i>
<i>; }</i>
<i>;</i>
        <strong>rts</strong>
&nbsp;
.endproc
</pre>

<p>Povšimněte si, že překlad je alespoň v&nbsp;tomto případě velmi úsporný
&ndash; samotný kód obsahuje pouze jedinou instrukci <strong>rts</strong>
neboli návrat z&nbsp;podprogramu (<i>subrutiny</i>).</p>



<p><a name="k02"></a></p>
<h2 id="k02">2. Volba, do jaké paměťové oblasti se mají uložit lokální proměnné</h2>

<p>Nyní do původně prázdné funkce <strong>main</strong> přidáme deklaraci a
inicializaci lokální proměnné:</p>

<pre>
void main(void)
{
    unsigned char x = 42;
}
</pre>

<p>Na moderních mikroprocesorových architekturách by se tato proměnná uložila
do zásobníkového rámce (<i>stack frame</i>), což je ovšem na MOS 6502 obtížná
operace (zásobníkové rámce by se musely relativně složitě emulovat). Proto
existuje možnost uložit tuto proměnnou do segmentu BSS, který není obsažen
v&nbsp;objektovém kódu &ndash; jedná se jen o pojmenování paměťové oblasti:</p>

<pre>
.segment        "BSS"
&nbsp;
<strong>L0002:</strong>
        <strong>.res    1,$00</strong>
</pre>

<p>Přístup k&nbsp;této paměťové oblasti vyžaduje &bdquo;dlouhé&ldquo;
adresování, tedy použití 16bitové adresy v&nbsp;instrukci:</p>

<pre>
        <strong>lda     #$2A</strong>
        <strong>sta     L0002</strong>
</pre>

<p><div class="rs-tip-major">Poznámka: oblast může být využita více funkcemi
&ndash; proměnné lze přepisovat.</div></p>

<p>Úplný kód napsaný v&nbsp;assembleru vzniklý překladem původního céčkového
kódu vypadá následovně:</p>

<pre>
<i>;</i>
<i>; File generated by cc65 v 2.18 - Ubuntu 2.18-1</i>
<i>;</i>
        .fopt           compiler,"cc65 v 2.18 - Ubuntu 2.18-1"
        .setcpu         "6502"
        .smart          on
        .autoimport     on
        .case           on
        .debuginfo      off
        .importzp       sp, sreg, regsave, regbank
        .importzp       tmp1, tmp2, tmp3, tmp4, ptr1, ptr2, ptr3, ptr4
        .macpack        longbranch
        .forceimport    __STARTUP__
        .export         _main
&nbsp;
<i>; ---------------------------------------------------------------</i>
<i>; void __near__ main (void)</i>
<i>; ---------------------------------------------------------------</i>
&nbsp;
.segment        "CODE"
&nbsp;
.proc   _main: near
&nbsp;
.segment        "BSS"
&nbsp;
<strong>L0002:</strong>
        <strong>.res    1,$00</strong>
&nbsp;
.segment        "CODE"
&nbsp;
<i>;</i>
<i>; unsigned char x = 42;</i>
<i>;</i>
        <strong>lda     #$2A</strong>
        <strong>sta     L0002</strong>
<i>;</i>
<i>; }</i>
<i>;</i>
        rts
&nbsp;
.endproc
</pre>

<p>Alternativně je možné přepínačem <strong>-Or</strong> zajistit, že se
původně lokální nestatické proměnné uloží do nulté stránky paměti
popř.&nbsp;přímo do pracovního registru <strong>A</strong> (akumulátoru):</p>

<pre>
<i>;</i>
<i>; File generated by cc65 v 2.18 - Ubuntu 2.18-1</i>
<i>;</i>
        .fopt           compiler,"cc65 v 2.18 - Ubuntu 2.18-1"
        .setcpu         "6502"
        .smart          on
        .autoimport     on
        .case           on
        .debuginfo      off
        .importzp       sp, sreg, regsave, regbank
        .importzp       tmp1, tmp2, tmp3, tmp4, ptr1, ptr2, ptr3, ptr4
        .macpack        longbranch
        .forceimport    __STARTUP__
        .export         _main
&nbsp;
<i>; ---------------------------------------------------------------</i>
<i>; void __near__ main (void)</i>
<i>; ---------------------------------------------------------------</i>
&nbsp;
.segment        "CODE"
&nbsp;
.proc   _main: near
&nbsp;
.segment        "CODE"
&nbsp;
<i>;</i>
<i>; unsigned char x = 42;</i>
<i>;</i>
        <strong>lda     #$2A</strong>
        <strong>jsr     pusha</strong>
<i>;</i>
<i>; }</i>
<i>;</i>
        <strong>jmp     incsp1</strong>
&nbsp;
.endproc
</pre>

<p><div class="rs-tip-major">Poznámka: zde se volá podprogram (subrutina)
určená pro emulaci zásobníkového rámce, resp.&nbsp;přesněji pro uložení obsahu
akumulátoru <strong>A</strong> do emulovaného zásobníkového rámce.</div></p>



<p><a name="k03"></a></p>
<h2 id="k03">3. Vliv klíčového slova <strong>register</strong> na způsob uložení lokálních proměnných</h2>

<p>Programovací jazyk C umožňuje v&nbsp;deklaraci proměnných
(resp.&nbsp;lokálních proměnných) použít <a
href="https://www.programiz.com/c-programming/list-all-keywords-c-language">klíčové
slovo</a> <strong>register</strong>, kterým se překladači říká, že daná
proměnná je využívána často (například v&nbsp;programové smyčce) a bylo by ji
tedy vhodné umístit přímo do registru. Co však toto klíčové slovo říká
překladači cc65, který musí pracovat pouze se třemi registry? Můžeme si to
relativně snadno vyzkoušet:</p>

<pre>
void main(void)
{
    <strong>register</strong> unsigned char x = 42;
}
</pre>

<p>Překlad provedeme dvakrát, nejdříve s&nbsp;přepínači <strong>-Cl</strong> a
<strong>-O</strong>:</p>

<pre>
<i>;</i>
<i>; File generated by cc65 v 2.18 - Ubuntu 2.18-1</i>
<i>;</i>
        .fopt           compiler,"cc65 v 2.18 - Ubuntu 2.18-1"
        .setcpu         "6502"
        .smart          on
        .autoimport     on
        .case           on
        .debuginfo      off
        .importzp       sp, sreg, regsave, regbank
        .importzp       tmp1, tmp2, tmp3, tmp4, ptr1, ptr2, ptr3, ptr4
        .macpack        longbranch
        .forceimport    __STARTUP__
        .export         _main
&nbsp;
<i>; ---------------------------------------------------------------</i>
<i>; void __near__ main (void)</i>
<i>; ---------------------------------------------------------------</i>
&nbsp;
.segment        "CODE"
&nbsp;
.proc   _main: near
&nbsp;
.segment        "BSS"
&nbsp;
<strong>L0002:</strong>
        <strong>.res    1,$00</strong>
&nbsp;
.segment        "CODE"
&nbsp;
<i>;</i>
<i>; register unsigned char x = 42;</i>
<i>;</i>
        <strong>lda     #$2A</strong>
        <strong>sta     L0002</strong>
<i>;</i>
<i>; }</i>
<i>;</i>
        rts
&nbsp;
.endproc
</pre>

<p><div class="rs-tip-major">Poznámka: v&nbsp;tomto případě je &bdquo;lokální
proměnná, kterou lze uložit do registru&ldquo; ve skutečnosti opět umístěna do
segmentu BSS, tedy stejně jako neinicializovaná globální proměnná!</div></p>

<p>Druhý překlad je proveden s&nbsp;přepínači <strong>-Or</strong> a
<strong>-O</strong>:</p>

<pre>
<i>;</i>
<i>; File generated by cc65 v 2.18 - Ubuntu 2.18-1</i>
<i>;</i>
        .fopt           compiler,"cc65 v 2.18 - Ubuntu 2.18-1"
        .setcpu         "6502"
        .smart          on
        .autoimport     on
        .case           on
        .debuginfo      off
        .importzp       sp, sreg, regsave, regbank
        .importzp       tmp1, tmp2, tmp3, tmp4, ptr1, ptr2, ptr3, ptr4
        .macpack        longbranch
        .forceimport    __STARTUP__
        .export         _main
&nbsp;
<i>; ---------------------------------------------------------------</i>
<i>; void __near__ main (void)</i>
<i>; ---------------------------------------------------------------</i>
&nbsp;
.segment        "CODE"
&nbsp;
.proc   _main: near
&nbsp;
.segment        "CODE"
&nbsp;
<i>;</i>
<i>; register unsigned char x = 42;</i>
<i>;</i>
        lda     regbank+5
        jsr     pusha
        <strong>lda     #$2A</strong>
        <strong>sta     regbank+5</strong>
<i>;</i>
<i>; }</i>
<i>;</i>
        ldy     #$00
        lda     (sp),y
        sta     regbank+5
        jmp     incsp1
&nbsp;
.endproc
</pre>

<p>Nyní je stejná proměnná umístěna na nultou stránku paměti, takže přístup
k&nbsp;ní bude rychlejší a i výsledný kód může být kratší.</p>

<p>Podívejme se, jak rozdíl v&nbsp;obou generovaných assemblerech zvýrazní
<strong>diff</strong>:</p>

<pre>
; -------------------------------------------   ; -------------------------------------------
; void __near__ main (void)                     ; void __near__ main (void)
; -------------------------------------------   ; -------------------------------------------
&nbsp;
.segment        "CODE"                          .segment        "CODE"
&nbsp;
.proc   _main: near                             .proc   _main: near
&nbsp;
.segment        "BSS"                         &lt;
                                              &lt;
L0002:                                        &lt;
        .res    1,$00                         &lt;
                                              &lt;
.segment        "CODE"                          .segment        "CODE"
&nbsp;
;                                               ;
; register unsigned char x = 42;                ; register unsigned char x = 42;
;                                               ;
                                              &gt;         lda     regbank+5
                                              &gt;         jsr     pusha
        lda     #$2A                                    lda     #$2A
        sta     L0002                         |         sta     regbank+5
;                                               ;
; }                                             ; }
;                                               ;
        rts                                   |         ldy     #$00
                                              &gt;         lda     (sp),y
                                              &gt;         sta     regbank+5
                                              &gt;         jmp     incsp1
&nbsp;
.endproc                                        .endproc
</pre>

<p><div class="rs-tip-major">Poznámka: druhý kód je sice delší, ale při dalších
manipulacích s&nbsp;proměnnou výhodnější.</div></p>



<p><a name="k04"></a></p>
<h2 id="k04">4. Přímý přístup k&nbsp;akumulátoru s&nbsp;využitím identifikátoru <strong>__A__</strong></h2>

<p>Překladač cc65 umožňuje přímou manipulaci s&nbsp;akumulátorem
s&nbsp;využitím identifikátoru <strong>__A__</strong>. Z&nbsp;pohledu
programátora se jedná o proměnnou typu <strong>unsigned char</strong>.
Podívejme se na jednoduchý příklad manipulace s&nbsp;akumulátorem:</p>

<pre>
void main(void)
{
    __A__ = 42;
&nbsp;
    ++__A__;
}
</pre>

<p>Po překladu do assembleru uvidíme, že výsledkem je do značné míry optimální
kód &ndash; viz zvýrazněné instrukce:</p>

<pre>
<i>;</i>
<i>; File generated by cc65 v 2.18 - Ubuntu 2.18-1</i>
<i>;</i>
        .fopt           compiler,"cc65 v 2.18 - Ubuntu 2.18-1"
        .setcpu         "6502"
        .smart          on
        .autoimport     on
        .case           on
        .debuginfo      off
        .importzp       sp, sreg, regsave, regbank
        .importzp       tmp1, tmp2, tmp3, tmp4, ptr1, ptr2, ptr3, ptr4
        .macpack        longbranch
        .forceimport    __STARTUP__
        .export         _main
&nbsp;
<i>; ---------------------------------------------------------------</i>
<i>; void __near__ main (void)</i>
<i>; ---------------------------------------------------------------</i>
&nbsp;
.segment        "CODE"
&nbsp;
.proc   _main: near
&nbsp;
.segment        "CODE"
&nbsp;
<i>;</i>
<i>; __A__ = 42;</i>
<i>;</i>
        <strong>lda     #$2A</strong>
<i>;</i>
<i>; ++__A__;</i>
<i>;</i>
        <strong>clc</strong>
        <strong>adc     #$01</strong>
<i>;</i>
<i>; }</i>
<i>;</i>
        rts
&nbsp;
.endproc
</pre>



<p><a name="k05"></a></p>
<h2 id="k05">5. Přístup k&nbsp;registrovému páru A + X s&nbsp;využitím identifikátoru <strong>__AX__</strong></h2>

<p><a href="#k04">V&nbsp;předchozí kapitole</a> jsme si ukázali, jak lze velmi
snadno využít <strong>__A__</strong> ve funkci velmi rychle přístupné proměnné
typu <strong>unsigned char</strong> (jejíž obsah je ovšem později přepsán
dalšími příkazy). Podobně lze použít identifikátor <strong>__AX__</strong>,
který představuje registrový pár A + X, ve funkci lokální proměnné typu
<strong>unsigned short int</strong>, tedy 16bitového celého čísla bez
znaménka:</p>

<pre>
void main(void)
{
    __AX__ = 0x1234;
&nbsp;
    ++__AX__;
}
</pre>

<p>Podívejme se nyní na vygenerovaný kód, který je velmi zajímavý. Povšimněte
si, že registr X obsahuje horní bajt, zatímco akumulátor A dolní bajt
šestnáctibitové hodnoty:</p>

<pre>
<i>;</i>
<i>; File generated by cc65 v 2.18 - Ubuntu 2.18-1</i>
<i>;</i>
        .fopt           compiler,"cc65 v 2.18 - Ubuntu 2.18-1"
        .setcpu         "6502"
        .smart          on
        .autoimport     on
        .case           on
        .debuginfo      off
        .importzp       sp, sreg, regsave, regbank
        .importzp       tmp1, tmp2, tmp3, tmp4, ptr1, ptr2, ptr3, ptr4
        .macpack        longbranch
        .forceimport    __STARTUP__
        .export         _main
&nbsp;
<i>; ---------------------------------------------------------------</i>
<i>; void __near__ main (void)</i>
<i>; ---------------------------------------------------------------</i>
&nbsp;
.segment        "CODE"
&nbsp;
.proc   _main: near
&nbsp;
.segment        "CODE"
&nbsp;
<i>;</i>
<i>; __AX__ = 0x1234;</i>
<i>;</i>
        <strong>ldx     #$12</strong>
        <strong>lda     #$34</strong>
<i>;</i>
<i>; ++__AX__;</i>
<i>;</i>
        <strong>jsr     incax1</strong>
<i>;</i>
<i>; }</i>
<i>;</i>
        rts
&nbsp;
.endproc
</pre>

<p>Zajímavé je, že při zapnutí všech optimalizací se <strong>++__AX__;</strong>
přeloží takovým způsobem, že se zvyšuje pouze hodnota akumulátoru, což je chyba
překladače (překlad bude stejný, i když použijeme například konstantu
0x00ff):</p>

<pre>
<i>;</i>
<i>; File generated by cc65 v 2.18 - Ubuntu 2.18-1</i>
<i>;</i>
        .fopt           compiler,"cc65 v 2.18 - Ubuntu 2.18-1"
        .setcpu         "6502"
        .smart          on
        .autoimport     on
        .case           on
        .debuginfo      off
        .importzp       sp, sreg, regsave, regbank
        .importzp       tmp1, tmp2, tmp3, tmp4, ptr1, ptr2, ptr3, ptr4
        .macpack        longbranch
        .forceimport    __STARTUP__
        .export         _main
&nbsp;
<i>; ---------------------------------------------------------------</i>
<i>; void __near__ main (void)</i>
<i>; ---------------------------------------------------------------</i>
&nbsp;
.segment        "CODE"
&nbsp;
.proc   _main: near
&nbsp;
.segment        "CODE"
&nbsp;
<i>;</i>
<i>; __AX__ = 0x1234;</i>
<i>;</i>
        <strong>lda     #$34</strong>
<i>;</i>
<i>; ++__AX__;</i>
<i>;</i>
        <strong>clc</strong>
        <strong>adc     #$01</strong>
<i>;</i>
<i>; }</i>
<i>;</i>
        rts
&nbsp;
.endproc
</pre>



<p><a name="k06"></a></p>
<h2 id="k06">6. Přístup k&nbsp;32bitové hodnotě uložené ve dvou buňkách RAM a v&nbsp;registrovém páru A + X</h2>

<p>Pokračujme dále v&nbsp;popisu speciálních vlastností překladače céčka cc65.
V&nbsp;některých případech je nutné pracovat s&nbsp;32bitovými hodnotami. To
již pro osmibitový mikroprocesor MOS 6502 vybavený pouhými třemi osmibitovými
registry představuje poměrně zásadní problém. Překladač cc65 sice programátorům
nabízí pseudoproměnnou nazvanou <strong>__EAX__</strong>, která je 32bitová,
ovšem interně nemůže být tato hodnota uložena v&nbsp;registrech mikroprocesoru
(alespoň ne celá). Proto cc65 přistupuje ke kompromisu &ndash; horních šestnáct
bitů je uloženo v&nbsp;nulté stránce paměti a dolních šestnáct bitů v&nbsp;nám
již známé dvojici registrů X a A (Y se používá při adresování, předávání hodnot
interním subrutinám atd.):</p>

<pre>
void main(void)
{
    __EAX__ = 0x12345678;
&nbsp;
    ++__EAX__;
}
</pre>

<p>Zajímavý bude překlad tohoto céčkového kódu do assembleru:</p>

<pre>
<i>;</i>
<i>; File generated by cc65 v 2.18 - Ubuntu 2.18-1</i>
<i>;</i>
        .fopt           compiler,"cc65 v 2.18 - Ubuntu 2.18-1"
        .setcpu         "6502"
        .smart          on
        .autoimport     on
        .case           on
        .debuginfo      off
        .importzp       sp, sreg, regsave, regbank
        .importzp       tmp1, tmp2, tmp3, tmp4, ptr1, ptr2, ptr3, ptr4
        .macpack        longbranch
        .forceimport    __STARTUP__
        .export         _main
&nbsp;
<i>; ---------------------------------------------------------------</i>
<i>; void __near__ main (void)</i>
<i>; ---------------------------------------------------------------</i>
&nbsp;
.segment        "CODE"
&nbsp;
.proc   _main: near
&nbsp;
.segment        "CODE"
&nbsp;
<i>;</i>
<i>; __EAX__ = 0x12345678;</i>
<i>;</i>
        <strong>ldx     #$56</strong>
        <strong>lda     #$34</strong>
        <strong>sta     sreg</strong>
        <strong>lda     #$12</strong>
        <strong>sta     sreg+1</strong>
        <strong>lda     #$78</strong>
<i>;</i>
<i>; ++__EAX__;</i>
<i>;</i>
        <strong>ldy     #$01</strong>
        jsr     inceaxy
<i>;</i>
<i>; }</i>
<i>;</i>
        rts
&nbsp;
.endproc
</pre>

<p><div class="rs-tip-major">Poznámka: jasně patrný je způsob rozložení
32bitového slova na čtyři bajty (horní dva bajty do paměťových oblastí sreg a
sreg+1). Taktéž můžeme vidět, že registr <strong>Y</strong> se používá interně
překladačem, zde konkrétně pro předání konstanty do subrutiny.</div></p>

<p>V&nbsp;tomto případě žádné optimalizace nepomůžou &ndash; optimalizován je
jen poslední skok do subrutiny <strong>jsr</strong> následovaný návratem ze
subrutiny <strong>rts</strong> za běžný skok <strong>jmp</strong>:</p>

<pre>
<i>;</i>
<i>; File generated by cc65 v 2.18 - Ubuntu 2.18-1</i>
<i>;</i>
        .fopt           compiler,"cc65 v 2.18 - Ubuntu 2.18-1"
        .setcpu         "6502"
        .smart          on
        .autoimport     on
        .case           on
        .debuginfo      off
        .importzp       sp, sreg, regsave, regbank
        .importzp       tmp1, tmp2, tmp3, tmp4, ptr1, ptr2, ptr3, ptr4
        .macpack        longbranch
        .forceimport    __STARTUP__
        .export         _main
&nbsp;
<i>; ---------------------------------------------------------------</i>
<i>; void __near__ main (void)</i>
<i>; ---------------------------------------------------------------</i>
&nbsp;
.segment        "CODE"
&nbsp;
.proc   _main: near
&nbsp;
.segment        "CODE"
&nbsp;
<i>;</i>
<i>; __EAX__ = 0x12345678;</i>
<i>;</i>
        ldx     #$56
        lda     #$34
        sta     sreg
        lda     #$12
        sta     sreg+1
        lda     #$78
<i>;</i>
<i>; ++__EAX__;</i>
<i>;</i>
        ldy     #$01
        jmp     inceaxy
&nbsp;
.endproc
</pre>



<p><a name="k07"></a></p>
<h2 id="k07">7. Rozdíl mezi chováním operátoru pro pre-inkrementaci a post-inkrementaci</h2>

<p>Na stránce <a href="https://cc65.github.io/doc/coding.html">cc65 coding
hints</a> jsou uvedeny některé užitečné tipy pro práci s&nbsp;překladačem cc65.
Mj.&nbsp;se zde dozvíme, že je vhodnější používat prefixový operátor ++
(resp.&nbsp;--) a nikoli postfixovou variantu stejného operátoru. Teoreticky
&ndash; pokud výsledek nijak nepoužijeme (tedy zaměříme se jen na vedlejší
efekt tohoto operátoru) by měl být přeložený kód totožný, ovšem v&nbsp;případě
cc65 tomu tak není. Snadno si to můžeme otestovat na těchto dvou příkladech,
které oba de facto provádí stejnou operaci &ndash; zvýšení hodnoty interní
proměnné <strong>x</strong> o jedničku:</p>

<pre>
void main(void)
{
    register unsigned int x = 42;
    x++;
}
</pre>

<pre>
void main(void)
{
    register unsigned int x = 42;
    ++x;
}
</pre>

<p>Výsledkem překladu prvního příkladu s&nbsp;<strong>x++</strong> je kód,
v&nbsp;němž jsou pro výpočet použity registry A a X, přičemž se testuje
přetečení do vyššího bajtu (instrukce <strong>bcc</strong>):</p>

<pre>
<i>;</i>
<i>; File generated by cc65 v 2.18 - Ubuntu 2.18-1</i>
<i>;</i>
        .fopt           compiler,"cc65 v 2.18 - Ubuntu 2.18-1"
        .setcpu         "6502"
        .smart          on
        .autoimport     on
        .case           on
        .debuginfo      off
        .importzp       sp, sreg, regsave, regbank
        .importzp       tmp1, tmp2, tmp3, tmp4, ptr1, ptr2, ptr3, ptr4
        .macpack        longbranch
        .forceimport    __STARTUP__
        .export         _main
&nbsp;
<i>; ---------------------------------------------------------------</i>
<i>; void __near__ main (void)</i>
<i>; ---------------------------------------------------------------</i>
&nbsp;
.segment        "CODE"
&nbsp;
.proc   _main: near
&nbsp;
.segment        "BSS"
&nbsp;
L0002:
        .res    2,$00
&nbsp;
.segment        "CODE"
&nbsp;
<i>;</i>
<i>; register unsigned int x = 42;</i>
<i>;</i>
        ldx     #$00
        lda     #$2A
        sta     L0002
        stx     L0002+1
<i>;</i>
<i>; x++;</i>
<i>;</i>
        <strong>clc</strong>
        <strong>adc     #$01</strong>
        <strong>bcc     L0005</strong>
        <strong>inx</strong>
<strong>L0005:  sta     L0002</strong>
        <strong>stx     L0002+1</strong>
<i>;</i>
<i>; }</i>
<i>;</i>
        rts
&nbsp;
.endproc
</pre>

<p>Při zapnutí optimalizací bude výsledný kód vypadat jinak. Až na odlišný
způsob uložení proměnné se ovšem stále provádí stejný výpočet s&nbsp;podmíněným
skokem:</p>

<pre>
<i>;</i>
<i>; File generated by cc65 v 2.18 - Ubuntu 2.18-1</i>
<i>;</i>
        .fopt           compiler,"cc65 v 2.18 - Ubuntu 2.18-1"
        .setcpu         "6502"
        .smart          on
        .autoimport     on
        .case           on
        .debuginfo      off
        .importzp       sp, sreg, regsave, regbank
        .importzp       tmp1, tmp2, tmp3, tmp4, ptr1, ptr2, ptr3, ptr4
        .macpack        longbranch
        .forceimport    __STARTUP__
        .export         _main
&nbsp;
<i>; ---------------------------------------------------------------</i>
<i>; void __near__ main (void)</i>
<i>; ---------------------------------------------------------------</i>
&nbsp;
.segment        "CODE"
&nbsp;
.proc   _main: near
&nbsp;
.segment        "CODE"
&nbsp;
<i>;</i>
<i>; register unsigned int x = 42;</i>
<i>;</i>
        lda     #$2A
        jsr     pusha0
<i>;</i>
<i>; x++;</i>
<i>;</i>
        ldy     #$01
        lda     (sp),y
        tax
        dey
        lda     (sp),y
        clc
        adc     #$01
        bcc     L0004
        inx
L0004:  jsr     stax0sp
<i>;</i>
<i>; }</i>
<i>;</i>
        jmp     incsp2
&nbsp;
.endproc
</pre>

<p>Výsledek překladu příkladu s&nbsp;<strong>++x</strong> vypadá odlišně
&ndash; celý výpočet je proveden s&nbsp;hodnotou uloženou v&nbsp;operační
paměti a nikoli v&nbsp;pracovních registrech, a to s&nbsp;využitím pouhých
třech instrukcí (ve výpisu jsou zvýrazněny):</p>

<pre>
<i>;</i>
<i>; File generated by cc65 v 2.18 - Ubuntu 2.18-1</i>
<i>;</i>
        .fopt           compiler,"cc65 v 2.18 - Ubuntu 2.18-1"
        .setcpu         "6502"
        .smart          on
        .autoimport     on
        .case           on
        .debuginfo      off
        .importzp       sp, sreg, regsave, regbank
        .importzp       tmp1, tmp2, tmp3, tmp4, ptr1, ptr2, ptr3, ptr4
        .macpack        longbranch
        .forceimport    __STARTUP__
        .export         _main
&nbsp;
<i>; ---------------------------------------------------------------</i>
<i>; void __near__ main (void)</i>
<i>; ---------------------------------------------------------------</i>
&nbsp;
.segment        "CODE"
&nbsp;
.proc   _main: near
&nbsp;
.segment        "BSS"
&nbsp;
L0002:
        .res    2,$00
&nbsp;
.segment        "CODE"
&nbsp;
<i>;</i>
<i>; register unsigned int x = 42;</i>
<i>;</i>
        ldx     #$00
        lda     #$2A
        sta     L0002
        stx     L0002+1
<i>;</i>
<i>; ++x;</i>
<i>;</i>
        <strong>inc     L0002</strong>
        <strong>bne     L0005</strong>
        <strong>inc     L0002+1</strong>
<i>;</i>
<i>; }</i>
<i>;</i>
L0005:  rts
&nbsp;
.endproc
</pre>

<p>Po zapnutí optimalizací se paradoxně volá podprogram pro součet hodnot:</p>

<pre>
<i>;</i>
<i>; File generated by cc65 v 2.18 - Ubuntu 2.18-1</i>
<i>;</i>
        .fopt           compiler,"cc65 v 2.18 - Ubuntu 2.18-1"
        .setcpu         "6502"
        .smart          on
        .autoimport     on
        .case           on
        .debuginfo      off
        .importzp       sp, sreg, regsave, regbank
        .importzp       tmp1, tmp2, tmp3, tmp4, ptr1, ptr2, ptr3, ptr4
        .macpack        longbranch
        .forceimport    __STARTUP__
        .export         _main
&nbsp;
<i>; ---------------------------------------------------------------</i>
<i>; void __near__ main (void)</i>
<i>; ---------------------------------------------------------------</i>
&nbsp;
.segment        "CODE"
&nbsp;
.proc   _main: near
&nbsp;
.segment        "CODE"
&nbsp;
<i>;</i>
<i>; register unsigned int x = 42;</i>
<i>;</i>
        lda     #$2A
        jsr     pusha0
<i>;</i>
<i>; ++x;</i>
<i>;</i>
        lda     #$01
        jsr     addeq0sp
<i>;</i>
<i>; }</i>
<i>;</i>
        jmp     incsp2
&nbsp;
.endproc
</pre>



<p><a name="k08"></a></p>
<h2 id="k08">8. Součet celých čísel bez znaménka a se znaménkem</h2>

<p>Mikroprocesor MOS 6502 sice dokáže do určité míry pracovat s&nbsp;hodnotami
se znaménkem (<strong>signed char</strong>, <strong>signed int</strong> atd.),
ovšem výsledný kód bude poměrně komplikovaný. Ostatně můžeme se o tom
přesvědčit sami při porovnání assembleru vygenerovaného pro následující dva
céčkové zdrojové kódy, které se liší &bdquo;jen&ldquo; rozdílem mezi
<strong>signed</strong> a <strong>unsigned</strong> (což na moderních
mikroprocesorech není vůbec problematické).</p>

<p>Operace s&nbsp;hodnotami bez znaménka:</p>

<pre>
void main(void)
{
    register unsigned char a;
    register unsigned char b;
    register unsigned char c;
    a = 10;
    b = 20;
    c = a + b;
}
</pre>

<p>Operace s&nbsp;hodnotami se znaménkem:</p>

<pre>
void main(void)
{
    register signed char a;
    register signed char b;
    register signed char c;
    a = 10;
    b = 20;
    c = a + b;
}
</pre>

<p>První příklad, tj.&nbsp;součet dvou hodnot bez znaménka, se přeloží
přímočaře (i když ruční optimalizace jsou stále na místě):</p>

<pre>
<i>;</i>
<i>; File generated by cc65 v 2.18 - Ubuntu 2.18-1</i>
<i>;</i>
        .fopt           compiler,"cc65 v 2.18 - Ubuntu 2.18-1"
        .setcpu         "6502"
        .smart          on
        .autoimport     on
        .case           on
        .debuginfo      off
        .importzp       sp, sreg, regsave, regbank
        .importzp       tmp1, tmp2, tmp3, tmp4, ptr1, ptr2, ptr3, ptr4
        .macpack        longbranch
        .forceimport    __STARTUP__
        .export         _main
&nbsp;
<i>; ---------------------------------------------------------------</i>
<i>; void __near__ main (void)</i>
<i>; ---------------------------------------------------------------</i>
&nbsp;
.segment        "CODE"
&nbsp;
.proc   _main: near
&nbsp;
.segment        "BSS"
&nbsp;
L0002:
        .res    1,$00
L0003:
        .res    1,$00
L0004:
        .res    1,$00
&nbsp;
.segment        "CODE"
&nbsp;
<i>;</i>
<i>; a = 10;</i>
<i>;</i>
        lda     #$0A
        sta     L0002
<i>;</i>
<i>; b = 20;</i>
<i>;</i>
        lda     #$14
        sta     L0003
<i>;</i>
<i>; c = a + b;</i>
<i>;</i>
        <strong>lda     L0002</strong>
        <strong>clc</strong>
        <strong>adc     L0003</strong>
        <strong>sta     L0004</strong>
<i>;</i>
<i>; }</i>
<i>;</i>
        rts
&nbsp;
.endproc
</pre>

<p>Ovšem u druhého příkladu, tj.&nbsp;při součtu dvou hodnot se znaménkem, je
již vygenerovaný kód dosti komplikovaný a vyžaduje dvojici podmíněných skoků
<strong>bpl</strong> (skok, pokud je hodnota kladná):</p>

<pre>
<i>;</i>
<i>; File generated by cc65 v 2.18 - Ubuntu 2.18-1</i>
<i>;</i>
        .fopt           compiler,"cc65 v 2.18 - Ubuntu 2.18-1"
        .setcpu         "6502"
        .smart          on
        .autoimport     on
        .case           on
        .debuginfo      off
        .importzp       sp, sreg, regsave, regbank
        .importzp       tmp1, tmp2, tmp3, tmp4, ptr1, ptr2, ptr3, ptr4
        .macpack        longbranch
        .forceimport    __STARTUP__
        .export         _main
&nbsp;
<i>; ---------------------------------------------------------------</i>
<i>; void __near__ main (void)</i>
<i>; ---------------------------------------------------------------</i>
&nbsp;
.segment        "CODE"
&nbsp;
.proc   _main: near
&nbsp;
.segment        "BSS"
&nbsp;
L0002:
        .res    1,$00
L0003:
        .res    1,$00
L0004:
        .res    1,$00
&nbsp;
.segment        "CODE"
&nbsp;
<i>;</i>
<i>; a = 10;</i>
<i>;</i>
        lda     #$0A
        sta     L0002
<i>;</i>
<i>; b = 20;</i>
<i>;</i>
        lda     #$14
        sta     L0003
<i>;</i>
<i>; c = a + b;</i>
<i>;</i>
        ldx     #$00
        lda     L0002
        bpl     L000B
        dex
L000B:  sta     ptr1
        stx     ptr1+1
        ldx     #$00
        lda     L0003
        bpl     L000C
        dex
L000C:  clc
        adc     ptr1
        pha
        txa
        adc     ptr1+1
        pla
        cmp     #$80
        sta     L0004
<i>;</i>
<i>; }</i>
<i>;</i>
        rts
&nbsp;
.endproc
</pre>

<p><div class="rs-tip-major">Poznámka: pokud se tedy můžete hodnotám se
znaménkem vyhnout, je to vždy žádoucí.</div></p>



<p><a name="k09"></a></p>
<h2 id="k09">9. Modifikace bloku paměti s&nbsp;využitím ukazatele a offsetu</h2>

<p><a
href="https://www.root.cz/clanky/prekladace-jazyka-c-pro-historicke-osmibitove-mikroprocesory/">Minule</a>
jsme si ukázali několik způsobů implementace funkce nazvané
<strong>memset8</strong>, která dokáže vyplnit určitý blok paměti (menší než
256 bajtů) zadanou hodnotou. Používali jsme přitom přístup do bloku
s&nbsp;využitím operátoru [], tj.&nbsp;chovali jsme se k&nbsp;celému bloku jako
k&nbsp;poli:</p>

<pre>
#include &lt;stdint.h&gt;
&nbsp;
void memset8(uint8_t * dest, const uint8_t c, const uint8_t n)
{
    register uint8_t i;
&nbsp;
    for (i = 0; i &lt; n; i++) {
        dest[i] = c;
    }
}
&nbsp;
int main(void)
{
    uint8_t *dest = (uint8_t *) 0x0600;
    uint8_t bytes = 0xff;
    uint8_t fill = 0x00;
    memset8(dest, fill, bytes);
&nbsp;
    return 0;
}
</pre>

<p>Výsledný kód vypadat po optimalizaci takto:</p>

<pre>
<i>;</i>
<i>; File generated by cc65 v 2.18 - Ubuntu 2.18-1</i>
<i>;</i>
        .fopt           compiler,"cc65 v 2.18 - Ubuntu 2.18-1"
        .setcpu         "6502"
        .smart          on
        .autoimport     on
        .case           on
        .debuginfo      off
        .importzp       sp, sreg, regsave, regbank
        .importzp       tmp1, tmp2, tmp3, tmp4, ptr1, ptr2, ptr3, ptr4
        .macpack        longbranch
        .forceimport    __STARTUP__
        .export         _memset8
        .export         _main
&nbsp;
<i>; ---------------------------------------------------------------</i>
<i>; void __near__ memset8 (__near__ unsigned char *, const unsigned char, const unsigned char)</i>
<i>; ---------------------------------------------------------------</i>
&nbsp;
.segment        "CODE"
&nbsp;
.proc   _memset8: near
&nbsp;
.segment        "BSS"
&nbsp;
L0002:
        .res    1,$00
&nbsp;
.segment        "CODE"
&nbsp;
<i>;</i>
<i>; {</i>
<i>;</i>
        jsr     pusha
<i>;</i>
<i>; for (i = 0; i &lt; n; i++) {</i>
<i>;</i>
        lda     #$00
        sta     L0002
L001B:  lda     L0002
        ldy     #$00
        cmp     (sp),y
        bcs     L0004
<i>;</i>
<i>; dest[i] = c;</i>
<i>;</i>
        ldy     #$03
        jsr     ldaxysp
        clc
        adc     L0002
        bcc     L001A
        inx
L001A:  sta     ptr1
        stx     ptr1+1
        ldy     #$01
        lda     (sp),y
        dey
        sta     (ptr1),y
<i>;</i>
<i>; for (i = 0; i &lt; n; i++) {</i>
<i>;</i>
        inc     L0002
        jmp     L001B
<i>;</i>
<i>; }</i>
<i>;</i>
L0004:  jmp     incsp4
&nbsp;
.endproc
&nbsp;
<i>; ---------------------------------------------------------------</i>
<i>; int __near__ main (void)</i>
<i>; ---------------------------------------------------------------</i>
&nbsp;
.segment        "CODE"
&nbsp;
.proc   _main: near
&nbsp;
.segment        "BSS"
&nbsp;
L000F:
        .res    2,$00
L0011:
        .res    1,$00
L0013:
        .res    1,$00
&nbsp;
.segment        "CODE"
&nbsp;
<i>;</i>
<i>; uint8_t *dest = (uint8_t *) 0x0600;</i>
<i>;</i>
        ldx     #$06
        lda     #$00
        sta     L000F
        stx     L000F+1
<i>;</i>
<i>; uint8_t bytes = 0xff;</i>
<i>;</i>
        lda     #$FF
        sta     L0011
<i>;</i>
<i>; uint8_t fill = 0x00;</i>
<i>;</i>
        lda     #$00
        sta     L0013
<i>;</i>
<i>; memset8(dest, fill, bytes);</i>
<i>;</i>
        lda     L000F
        ldx     L000F+1
        jsr     pushax
        lda     L0013
        jsr     pusha
        lda     L0011
        jsr     _memset8
<i>;</i>
<i>; return 0;</i>
<i>;</i>
        ldx     #$00
        txa
<i>;</i>
<i>; }</i>
<i>;</i>
        rts
&nbsp;
.endproc
</pre>

<p>Kdysi, zhruba v&nbsp;dobách vlády DOSu (a nastupující vlády Linuxu) se
tvrdilo, že indexování prvků pole operátorem <strong>[]</strong> je pomalé a že
je lepší ho nahradit za operaci <strong>*(bázová_adresa+offset)</strong>, tedy
za přímou manipulaci s&nbsp;pamětí (nebo ještě lépe kompletní eliminací offsetu
a posunem bázové adresy). Jak je tomu ovšem v&nbsp;případě překladače cc65?
Pokusme se předchozí příklad upravit tak, aby se používalo adresování bajtů
v&nbsp;bloku paměti pomocí bázové adresy a offsetu:</p>

<pre>
#include &lt;stdint.h&gt;
&nbsp;
void memset8(uint8_t * dest, const uint8_t c, const uint8_t n)
{
    register uint8_t i;
&nbsp;
    for (i = 0; i &lt; n; i++) {
        <strong>*(dest+i) = c;</strong>
    }
}
&nbsp;
int main(void)
{
    uint8_t *dest = (uint8_t *) 0x0600;
    uint8_t bytes = 0xff;
    uint8_t fill = 0x00;
    memset8(dest, fill, bytes);
&nbsp;
    return 0;
}
</pre>

<p>Zajímavé je, že tento příklad se přeloží do <strong>zcela totožné</strong>
sekvence instrukcí, jako příklad předchozí, takže naše
&bdquo;optimalizace&ldquo; na úrovni céčkového kódu v&nbsp;tomto případě
postrádá smysl:</p>

<pre>
<i>;</i>
<i>; File generated by cc65 v 2.18 - Ubuntu 2.18-1</i>
<i>;</i>
        .fopt           compiler,"cc65 v 2.18 - Ubuntu 2.18-1"
        .setcpu         "6502"
        .smart          on
        .autoimport     on
        .case           on
        .debuginfo      off
        .importzp       sp, sreg, regsave, regbank
        .importzp       tmp1, tmp2, tmp3, tmp4, ptr1, ptr2, ptr3, ptr4
        .macpack        longbranch
        .forceimport    __STARTUP__
        .export         _memset8
        .export         _main
&nbsp;
<i>; ---------------------------------------------------------------</i>
<i>; void __near__ memset8 (__near__ unsigned char *, const unsigned char, const unsigned char)</i>
<i>; ---------------------------------------------------------------</i>
&nbsp;
.segment        "CODE"
&nbsp;
.proc   _memset8: near
&nbsp;
.segment        "BSS"
&nbsp;
L0002:
        .res    1,$00
&nbsp;
.segment        "CODE"
&nbsp;
<i>;</i>
<i>; {</i>
<i>;</i>
        jsr     pusha
<i>;</i>
<i>; for (i = 0; i &lt; n; i++) {</i>
<i>;</i>
        lda     #$00
        sta     L0002
L001B:  lda     L0002
        ldy     #$00
        cmp     (sp),y
        bcs     L0004
<i>;</i>
<i>; *(dest+i) = c;</i>
<i>;</i>
        ldy     #$03
        jsr     ldaxysp
        clc
        adc     L0002
        bcc     L001A
        inx
L001A:  sta     ptr1
        stx     ptr1+1
        ldy     #$01
        lda     (sp),y
        dey
        sta     (ptr1),y
<i>;</i>
<i>; for (i = 0; i &lt; n; i++) {</i>
<i>;</i>
        inc     L0002
        jmp     L001B
<i>;</i>
<i>; }</i>
<i>;</i>
L0004:  jmp     incsp4
&nbsp;
.endproc
&nbsp;
<i>; ---------------------------------------------------------------</i>
<i>; int __near__ main (void)</i>
<i>; ---------------------------------------------------------------</i>
&nbsp;
.segment        "CODE"
&nbsp;
.proc   _main: near
&nbsp;
.segment        "BSS"
&nbsp;
L000F:
        .res    2,$00
L0011:
        .res    1,$00
L0013:
        .res    1,$00
&nbsp;
.segment        "CODE"
&nbsp;
<i>;</i>
<i>; uint8_t *dest = (uint8_t *) 0x0600;</i>
<i>;</i>
        ldx     #$06
        lda     #$00
        sta     L000F
        stx     L000F+1
<i>;</i>
<i>; uint8_t bytes = 0xff;</i>
<i>;</i>
        lda     #$FF
        sta     L0011
<i>;</i>
<i>; uint8_t fill = 0x00;</i>
<i>;</i>
        lda     #$00
        sta     L0013
<i>;</i>
<i>; memset8(dest, fill, bytes);</i>
<i>;</i>
        lda     L000F
        ldx     L000F+1
        jsr     pushax
        lda     L0013
        jsr     pusha
        lda     L0011
        jsr     _memset8
<i>;</i>
<i>; return 0;</i>
<i>;</i>
        ldx     #$00
        txa
<i>;</i>
<i>; }</i>
<i>;</i>
        rts
&nbsp;
.endproc
</pre>



<p><a name="k10"></a></p>
<h2 id="k10">10. Přímý zápis instrukcí v&nbsp;assembleru do céčkového kódu</h2>

<p>V&nbsp;rámci předchozích kapitol jsme si ukázali některé problematické rysy
překladače cc65. V&nbsp;případě, že narazíme na neoptimální kód, lze situaci
zachránit, a to přímým zápisem instrukcí v&nbsp;assembleru. Pro tento účel se
používá &bdquo;funkce&ldquo; nazvaná <strong>__asm__</strong>, které se
v&nbsp;řetězci předá jak vlastní instrukce, tak i popř.&nbsp;proměnná,
s&nbsp;níž má instrukce operovat. Podívejme se na ten nejjednodušší možný
případ, tj.&nbsp;na vygenerování sekvence instrukcí, které nepracují
s&nbsp;žádnou lokální ani globální proměnnou:</p>

<pre>
void main(void)
{
    __asm__ (<strong>"lda #1"</strong>);
    __asm__ (<strong>"clc"</strong>);
    __asm__ (<strong>"adc #2"</strong>);
}
</pre>

<p>Sekvence instrukcí, které jsme zapsali do <strong>__asm__</strong>, se
objeví ve výsledném assemblerovském kódu:</p>

<pre>
<i>;</i>
<i>; File generated by cc65 v 2.18 - Ubuntu 2.18-1</i>
<i>;</i>
        .fopt           compiler,"cc65 v 2.18 - Ubuntu 2.18-1"
        .setcpu         "6502"
        .smart          on
        .autoimport     on
        .case           on
        .debuginfo      off
        .importzp       sp, sreg, regsave, regbank
        .importzp       tmp1, tmp2, tmp3, tmp4, ptr1, ptr2, ptr3, ptr4
        .macpack        longbranch
        .forceimport    __STARTUP__
        .export         _main
&nbsp;
<i>; ---------------------------------------------------------------</i>
<i>; void __near__ main (void)</i>
<i>; ---------------------------------------------------------------</i>
&nbsp;
.segment        "CODE"
&nbsp;
.proc   _main: near
&nbsp;
.segment        "CODE"
&nbsp;
<i>;</i>
<i>; __asm__ ("lda #1");</i>
<i>;</i>
        <strong>lda     #1</strong>
<i>;</i>
<i>; __asm__ ("clc");</i>
<i>;</i>
        <strong>clc</strong>
<i>;</i>
<i>; __asm__ ("adc #2");</i>
<i>;</i>
        <strong>adc     #2</strong>
<i>;</i>
<i>; }</i>
<i>;</i>
        rts
&nbsp;
.endproc
</pre>



<p><a name="k11"></a></p>
<h2 id="k11">11. Použití reference na lokální proměnnou v&nbsp;assembleru</h2>

<p>Jak jsme si již řekli <a href="#k10">v&nbsp;předchozí kapitole</a>, je možné
pseudofunkci <strong>__asm__</strong> předat i proměnnou, s&nbsp;níž má
instrukce pracovat. Například v&nbsp;následujícím příkladu vypočteme součet 1+2
a uložíme jeho výsledek do lokální proměnné <strong>a</strong>:</p>

<pre>
void main(void)
{
    register unsigned char a;
&nbsp;
    __asm__ (<strong>"lda #1"</strong>);
    __asm__ (<strong>"clc"</strong>);
    __asm__ (<strong>"adc #2"</strong>);
    __asm__ (<strong>"sta %v"</strong>, <strong>a</strong>);
}
</pre>

<p><div class="rs-tip-major">Poznámka: zde je patrné, že
<strong>__asm__</strong> není a ani nemůže být funkce, ale spíše makro, protože
proměnnou <strong>a</strong> nevyhodnocuje tak, jak by tomu bylo u klasické
céčkové funkce.</div></p>

<p>V&nbsp;assemblerovském výpisu si povšimněte zejména toho, jakým způsobem je
přeložena poslední instrukce &ndash; tedy zápis výsledku do lokální proměnné
<strong>a</strong>:</p>

<pre>
<i>;</i>
<i>; File generated by cc65 v 2.18 - Ubuntu 2.18-1</i>
<i>;</i>
        .fopt           compiler,"cc65 v 2.18 - Ubuntu 2.18-1"
        .setcpu         "6502"
        .smart          on
        .autoimport     on
        .case           on
        .debuginfo      off
        .importzp       sp, sreg, regsave, regbank
        .importzp       tmp1, tmp2, tmp3, tmp4, ptr1, ptr2, ptr3, ptr4
        .macpack        longbranch
        .forceimport    __STARTUP__
        .export         _main
&nbsp;
<i>; ---------------------------------------------------------------</i>
<i>; void __near__ main (void)</i>
<i>; ---------------------------------------------------------------</i>
&nbsp;
.segment        "CODE"
&nbsp;
.proc   _main: near
&nbsp;
.segment        "CODE"
&nbsp;
<i>;</i>
<i>; register unsigned char a;</i>
<i>;</i>
        lda     regbank+5
        jsr     pusha
<i>;</i>
<i>; __asm__ ("lda #1");</i>
<i>;</i>
        <strong>lda     #1</strong>
<i>;</i>
<i>; __asm__ ("clc");</i>
<i>;</i>
        <strong>clc</strong>
<i>;</i>
<i>; __asm__ ("adc #2");</i>
<i>;</i>
        <strong>adc     #2</strong>
<i>;</i>
<i>; __asm__ ("sta %v", a);</i>
<i>;</i>
        <strong>sta     regbank+5</strong>
<i>;</i>
<i>; }</i>
<i>;</i>
        ldy     #$00
        lda     (sp),y
        sta     regbank+5
        jmp     incsp1
&nbsp;
.endproc
</pre>



<p><a name="k12"></a></p>
<h2 id="k12">12. Nepatrně složitější příklad: ručně optimalizovaný součet dvou proměnných</h2>

<p>Se znalostí toho, jak lze assemblerovským instrukcím předávat proměnné
(tj.&nbsp;jejich jména, nikoli hodnoty nebo reference), můžeme součet
<strong>c=a+b</strong> realizovat optimalizovaným assemblerem, a to například
takto:</p>

<pre>
void main(void)
{
    register unsigned char a;
    register unsigned char b;
    register unsigned char c;
&nbsp;
&nbsp;
    __asm__ (<strong>"lda %v"</strong>, <strong>a</strong>);
    __asm__ (<strong>"clc"</strong>);
    __asm__ (<strong>"adc %v"</strong>, <strong>b</strong>);
    __asm__ (<strong>"sta %v"</strong>, <strong>c</strong>);
}
</pre>

<p>Ve vygenerovaném assembleru je ona čtveřice instrukcí zvýrazněna, aby bylo
zřejmé, že se skutečně pracuje s&nbsp;adresami proměnných:</p>

<pre>
<i>;</i>
<i>; File generated by cc65 v 2.18 - Ubuntu 2.18-1</i>
<i>;</i>
        .fopt           compiler,"cc65 v 2.18 - Ubuntu 2.18-1"
        .setcpu         "6502"
        .smart          on
        .autoimport     on
        .case           on
        .debuginfo      off
        .importzp       sp, sreg, regsave, regbank
        .importzp       tmp1, tmp2, tmp3, tmp4, ptr1, ptr2, ptr3, ptr4
        .macpack        longbranch
        .forceimport    __STARTUP__
        .export         _main
&nbsp;
<i>; ---------------------------------------------------------------</i>
<i>; void __near__ main (void)</i>
<i>; ---------------------------------------------------------------</i>
&nbsp;
.segment        "CODE"
&nbsp;
.proc   _main: near
&nbsp;
.segment        "CODE"
&nbsp;
<i>;</i>
<i>; register unsigned char a;</i>
<i>;</i>
        lda     regbank+5
        jsr     pusha
<i>;</i>
<i>; register unsigned char b;</i>
<i>;</i>
        lda     regbank+4
        jsr     pusha
<i>;</i>
<i>; register unsigned char c;</i>
<i>;</i>
        lda     regbank+3
        jsr     pusha
<i>;</i>
<i>; __asm__ ("lda %v", a);</i>
<i>;</i>
        <strong>lda     regbank+5</strong>
<i>;</i>
<i>; __asm__ ("clc");</i>
<i>;</i>
        <strong>clc</strong>
<i>;</i>
<i>; __asm__ ("adc %v", b);</i>
<i>;</i>
        <strong>adc     regbank+4</strong>
<i>;</i>
<i>; __asm__ ("sta %v", c);</i>
<i>;</i>
        <strong>sta     regbank+3</strong>
<i>;</i>
<i>; }</i>
<i>;</i>
        ldy     #$00
L000A:  lda     (sp),y
        sta     regbank+3,y
        iny
        cpy     #$03
        bne     L000A
        jmp     incsp3
&nbsp;
.endproc
</pre>



<p><a name="k13"></a></p>
<h2 id="k13">13. Přístup ke globálním proměnným z&nbsp;assembleru</h2>

<p>S&nbsp;naší znalostí toho, jakým způsobem je možné kombinovat céčko a
assembler, se můžeme pustit i do nepatrně &bdquo;složitějšího&ldquo; příkladu.
Například se můžeme pokusit o realizaci součtu dvou globálních proměnných,
přičemž výsledek bude taktéž uložen do globální proměnné. Samotná realizace
takového programu, v&nbsp;němž budeme přímo generovat instrukce
v&nbsp;assembleru, může vypadat následovně:</p>

<pre>
unsigned char a;
unsigned char b;
unsigned char c;
&nbsp;
void main(void)
{
    __asm__ ("lda %v", a);
    __asm__ ("clc");
    __asm__ ("adc %v", b);
    __asm__ ("sta %v", c);
}
</pre>

<p><div class="rs-tip-major">Poznámka: pro jistotu je opět nutné před vlastním
součtem vynulovat příznak <i>carry</i>, protože mikroprocesor MOS 6502 má pouze
instrukci <strong>adc</strong> a nikoli <strong>add</strong> (bez
<i>carry</i>).</div></p>

<p>Tento program se přeloží následujícím způsobem (zvýrazněny jsou bloky
s&nbsp;globálními proměnnými i dotčená čtveřice instrukcí):</p>

<pre>
<i>;</i>
<i>; File generated by cc65 v 2.18 - Ubuntu 2.18-1</i>
<i>;</i>
        .fopt           compiler,"cc65 v 2.18 - Ubuntu 2.18-1"
        .setcpu         "6502"
        .smart          on
        .autoimport     on
        .case           on
        .debuginfo      off
        .importzp       sp, sreg, regsave, regbank
        .importzp       tmp1, tmp2, tmp3, tmp4, ptr1, ptr2, ptr3, ptr4
        .macpack        longbranch
        .forceimport    __STARTUP__
        .export         _a
        .export         _b
        .export         _c
        .export         _main
&nbsp;
.segment        "BSS"
&nbsp;
<strong>_a:</strong>
        .res    1,$00
<strong>_b:</strong>
        .res    1,$00
<strong>_c:</strong>
        .res    1,$00
&nbsp;
<i>; ---------------------------------------------------------------</i>
<i>; void __near__ main (void)</i>
<i>; ---------------------------------------------------------------</i>
&nbsp;
.segment        "CODE"
&nbsp;
.proc   _main: near
&nbsp;
.segment        "CODE"
&nbsp;
<i>;</i>
<i>; __asm__ ("lda %v", a);</i>
<i>;</i>
        <strong>lda     _a</strong>
<i>;</i>
<i>; __asm__ ("clc");</i>
<i>;</i>
        <strong>clc</strong>
<i>;</i>
<i>; __asm__ ("adc %v", b);</i>
<i>;</i>
        <strong>adc     _b</strong>
<i>;</i>
<i>; __asm__ ("sta %v", c);konkrétní </i>
<i>;</i>
        <strong>sta     _c</strong>
<i>;</i>
<i>; }</i>
<i>;</i>
        rts
&nbsp;
.endproc
</pre>

<p>Zajímavé bude vysledovat, jak vlastně budou instrukce, které ke globálním
proměnným přistupují, přeloženy do strojového kódu:</p>

<pre>
$ <strong>ca65 --listing assembly4_list.asm assembly4.asm</strong>
</pre>

<p>S&nbsp;následujícím výsledkem:</p>

<pre>
000000r 1               ;
000000r 1               ; __asm__ ("lda %v", a);
000000r 1               ;
000000r 1  <strong>AD rr rr             lda     _a</strong>
000003r 1               ;
000003r 1               ; __asm__ ("clc");
000003r 1               ;
000003r 1  <strong>18                   clc</strong>
000004r 1               ;
000004r 1               ; __asm__ ("adc %v", b);
000004r 1               ;
000004r 1  <strong>6D rr rr             adc     _b</strong>
000007r 1               ;
000007r 1               ; __asm__ ("sta %v", c);
000007r 1               ;
000007r 1  <strong>8D rr rr             sta     _c</strong>
00000Ar 1               ;
00000Ar 1               ; }
00000Ar 1               ;
00000Ar 1  60                   rts
</pre>

<p><div class="rs-tip-major">Poznámka: povšimněte si, že se používají
&bdquo;dlouhé&ldquo; adresy (tedy instrukce s&nbsp;celkovou délkou tří bajtů),
což není ideální ve chvíli, kdy se podobné globální proměnné používají velmi
často &ndash; tehdy je lepší použít nultou stránku paměti.</div></p>



<p><a name="k14"></a></p>
<h2 id="k14">14. Bitové posuny a další operace prováděné s&nbsp;akumulátorem</h2>

<p>Vyzkoušejme si nyní, jakým způsobem se přeloží céčkovské příkazy, které
manipulují s&nbsp;akumulátorem s&nbsp;využitím základních céčkovských
operátorů. Začneme operací <strong>__A__ += 1</strong>, protože způsob překladu
operátoru ++ (jak v&nbsp;prefixové, tak i v&nbsp;postfixové variantě) jsme si
již ukázali v&nbsp;rámci předchozích kapitol:</p>

<pre>
void main(void)
{
    __A__ = 42;
&nbsp;
    __A__ += 1;
}
</pre>

<p>Překlad je v&nbsp;tomto případě (ovšem pouze při zapnutí optimalizací)
přímočarý a odpovídá tomu, co bychom sami zapsali do assembleru:</p>

<pre>
<i>;</i>
<i>; File generated by cc65 v 2.18 - Ubuntu 2.18-1</i>
<i>;</i>
        .fopt           compiler,"cc65 v 2.18 - Ubuntu 2.18-1"
        .setcpu         "6502"
        .smart          on
        .autoimport     on
        .case           on
        .debuginfo      off
        .importzp       sp, sreg, regsave, regbank
        .importzp       tmp1, tmp2, tmp3, tmp4, ptr1, ptr2, ptr3, ptr4
        .macpack        longbranch
        .forceimport    __STARTUP__
        .export         _main
&nbsp;
<i>; ---------------------------------------------------------------</i>
<i>; void __near__ main (void)</i>
<i>; ---------------------------------------------------------------</i>
&nbsp;
.segment        "CODE"
&nbsp;
.proc   _main: near
&nbsp;
.segment        "CODE"
&nbsp;
<i>;</i>
<i>; __A__ = 42;</i>
<i>;</i>
        <strong>lda     #$2A</strong>
<i>;</i>
<i>; __A__ += 1;</i>
<i>;</i>
        <strong>clc</strong>
        <strong>adc     #$01</strong>
<i>;</i>
<i>; }</i>
<i>;</i>
        rts
&nbsp;
.endproc
</pre>

<p>Podobně si můžeme vyzkoušet překlad céčkovského kódu, v&nbsp;němž se obsah
akumulátoru posune doleva:</p>

<pre>
void main(void)
{
    __A__ = 42;
&nbsp;
    __A__ &lt;&lt;= 1;
}
</pre>

<p>Výsledek je v&nbsp;tomto případě opět optimální:</p>

<pre>
<i>;</i>
<i>; File generated by cc65 v 2.18 - Ubuntu 2.18-1</i>
<i>;</i>
        .fopt           compiler,"cc65 v 2.18 - Ubuntu 2.18-1"
        .setcpu         "6502"
        .smart          on
        .autoimport     on
        .case           on
        .debuginfo      off
        .importzp       sp, sreg, regsave, regbank
        .importzp       tmp1, tmp2, tmp3, tmp4, ptr1, ptr2, ptr3, ptr4
        .macpack        longbranch
        .forceimport    __STARTUP__
        .export         _main
&nbsp;
<i>; ---------------------------------------------------------------</i>
<i>; void __near__ main (void)</i>
<i>; ---------------------------------------------------------------</i>
&nbsp;
.segment        "CODE"
&nbsp;
.proc   _main: near
&nbsp;
.segment        "CODE"
&nbsp;
<i>;</i>
<i>; __A__ = 42;</i>
<i>;</i>
        <strong>lda     #$2A</strong>
<i>;</i>
<i>; __A__ &lt;&lt;= 1;</i>
<i>;</i>
        <strong>asl     a</strong>
<i>;</i>
<i>; }</i>
<i>;</i>
        rts
&nbsp;
.endproc
</pre>

<p>A pro úplnost si ukažme i posun doprava, tedy vlastně dělení dvěma (bez
znaménka!):</p>

<pre>
void main(void)
{
    __A__ = 42;
&nbsp;
    __A__ &gt;&gt;= 1;
}
</pre>

<p>S&nbsp;výsledkem:</p>

<pre>
<i>;</i>
<i>; File generated by cc65 v 2.18 - Ubuntu 2.18-1</i>
<i>;</i>
        .fopt           compiler,"cc65 v 2.18 - Ubuntu 2.18-1"
        .setcpu         "6502"
        .smart          on
        .autoimport     on
        .case           on
        .debuginfo      off
        .importzp       sp, sreg, regsave, regbank
        .importzp       tmp1, tmp2, tmp3, tmp4, ptr1, ptr2, ptr3, ptr4
        .macpack        longbranch
        .forceimport    __STARTUP__
        .export         _main
&nbsp;
<i>; ---------------------------------------------------------------</i>
<i>; void __near__ main (void)</i>
<i>; ---------------------------------------------------------------</i>
&nbsp;
.segment        "CODE"
&nbsp;
.proc   _main: near
&nbsp;
.segment        "CODE"
&nbsp;
<i>;</i>
<i>; __A__ = 42;</i>
<i>;</i>
        <strong>lda     #$2A</strong>
<i>;</i>
<i>; __A__ >>= 1;</i>
<i>;</i>
        <strong>lsr     a</strong>
<i>;</i>
<i>; }</i>
<i>;</i>
        rts
&nbsp;
.endproc
</pre>

<p>Pro úplnost doplňme posun o dva bity doleva i doprava:</p>

<pre>
void main(void)
{
    __A__ = 42;
&nbsp;
    __A__ &gt;&gt;= 2;
    __A__ &lt;&lt;= 2;
}
</pre>

<p>Což se přeloží do kódu:</p>

<pre>
<i>;</i>
<i>; File generated by cc65 v 2.18 - Ubuntu 2.18-1</i>
<i>;</i>
        .fopt           compiler,"cc65 v 2.18 - Ubuntu 2.18-1"
        .setcpu         "6502"
        .smart          on
        .autoimport     on
        .case           on
        .debuginfo      off
        .importzp       sp, sreg, regsave, regbank
        .importzp       tmp1, tmp2, tmp3, tmp4, ptr1, ptr2, ptr3, ptr4
        .macpack        longbranch
        .forceimport    __STARTUP__
        .export         _main
&nbsp;
<i>; ---------------------------------------------------------------</i>
<i>; void __near__ main (void)</i>
<i>; ---------------------------------------------------------------</i>
&nbsp;
.segment        "CODE"
&nbsp;
.proc   _main: near
&nbsp;
.segment        "CODE"
&nbsp;
<i>;</i>
<i>; __A__ = 42;</i>
<i>;</i>
        lda     #$2A
<i>;</i>
<i>; __A__ &gt;&gt;= 2;</i>
<i>;</i>
        <strong>lsr     a</strong>
        <strong>lsr     a</strong>
<i>;</i>
<i>; __A__ &lt;&lt;= 2;</i>
<i>;</i>
        <strong>asl     a</strong>
        <strong>asl     a</strong>
<i>;</i>
<i>; }</i>
<i>;</i>
        rts
&nbsp;
.endproc
&nbsp;
</pre>



<p><a name="k15"></a></p>
<h2 id="k15">15. Násobení a dělení dvěma popř.&nbsp;mocninou dvou</h2>

<p>V&nbsp;případě, že budeme obsah proměnné (a ještě lépe obsah akumulátoru)
násobit dvěma či nějakou vyšší mocninou dvojky, bude tato operace překladačem
cc65 převedena na instrukci pro bitový posun doleva &ndash; ovšem pouze
v&nbsp;případě, že povolíme optimalizace (bez těch není možné cc65 reálně
používat). Můžeme si to ostatně velmi snadno otestovat na tomto příkladu:</p>

<pre>
void main(void)
{
    __A__ = 42;
&nbsp;
    __A__ *= 2;
}
</pre>

<p>Po překladu je zřejmé, že se skutečně použila instrukce <strong>ASL</strong>
určená pro bitový posun doleva:</p>

<pre>
<i>;</i>
<i>; File generated by cc65 v 2.18 - Ubuntu 2.18-1</i>
<i>;</i>
        .fopt           compiler,"cc65 v 2.18 - Ubuntu 2.18-1"
        .setcpu         "6502"
        .smart          on
        .autoimport     on
        .case           on
        .debuginfo      off
        .importzp       sp, sreg, regsave, regbank
        .importzp       tmp1, tmp2, tmp3, tmp4, ptr1, ptr2, ptr3, ptr4
        .macpack        longbranch
        .forceimport    __STARTUP__
        .export         _main
&nbsp;
<i>; ---------------------------------------------------------------</i>
<i>; void __near__ main (void)</i>
<i>; ---------------------------------------------------------------</i>
&nbsp;
.segment        "CODE"
&nbsp;
.proc   _main: near
&nbsp;
.segment        "CODE"
&nbsp;
<i>;</i>
<i>; __A__ = 42;</i>
<i>;</i>
        <strong>lda     #$2A</strong>
<i>;</i>
<i>; __A__ *= 2;</i>
<i>;</i>
        <strong>asl     a</strong>
<i>;</i>
<i>; }</i>
<i>;</i>
        rts
&nbsp;
.endproc
</pre>

<p>Naopak při dělení dvěma nebo dělení vyšší mocninou dvojky se použije bitový
posun doprava. Opět si to otestujeme:</p>

<pre>
void main(void)
{
    __A__ = 42;
&nbsp;
    __A__ /= 2;
}
</pre>

<p>Výsledek bude po překladu vypadat následovně:</p>

<pre>
<i>;</i>
<i>; File generated by cc65 v 2.18 - Ubuntu 2.18-1</i>
<i>;</i>
        .fopt           compiler,"cc65 v 2.18 - Ubuntu 2.18-1"
        .setcpu         "6502"
        .smart          on
        .autoimport     on
        .case           on
        .debuginfo      off
        .importzp       sp, sreg, regsave, regbank
        .importzp       tmp1, tmp2, tmp3, tmp4, ptr1, ptr2, ptr3, ptr4
        .macpack        longbranch
        .forceimport    __STARTUP__
        .export         _main
&nbsp;
<i>; ---------------------------------------------------------------</i>
<i>; void __near__ main (void)</i>
<i>; ---------------------------------------------------------------</i>
&nbsp;
.segment        "CODE"
&nbsp;
.proc   _main: near
&nbsp;
.segment        "CODE"
&nbsp;
<i>;</i>
<i>; __A__ = 42;</i>
<i>;</i>
        <strong>lda     #$2A</strong>
<i>;</i>
<i>; __A__ /= 2;</i>
<i>;</i>
        <strong>lsr     a</strong>
<i>;</i>
<i>; }</i>
<i>;</i>
        rts
&nbsp;
.endproc
</pre>

<p>Při násobení čtyřmi se posun provede dvakrát, což je taktéž korektní:</p>

<pre>
void main(void)
{
    __A__ = 42;
&nbsp;
    __A__ *= 4;
}
</pre>

<p>S&nbsp;výsledkem, v&nbsp;němž můžeme vidět dvojí použití instrukce
<strong>ASL</strong>:</p>

<pre>
<i>;</i>
<i>; File generated by cc65 v 2.18 - Ubuntu 2.18-1</i>
<i>;</i>
        .fopt           compiler,"cc65 v 2.18 - Ubuntu 2.18-1"
        .setcpu         "6502"
        .smart          on
        .autoimport     on
        .case           on
        .debuginfo      off
        .importzp       sp, sreg, regsave, regbank
        .importzp       tmp1, tmp2, tmp3, tmp4, ptr1, ptr2, ptr3, ptr4
        .macpack        longbranch
        .forceimport    __STARTUP__
        .export         _main
&nbsp;
<i>; ---------------------------------------------------------------</i>
<i>; void __near__ main (void)</i>
<i>; ---------------------------------------------------------------</i>
&nbsp;
.segment        "CODE"
&nbsp;
.proc   _main: near
&nbsp;
.segment        "CODE"
&nbsp;
<i>;</i>
<i>; __A__ = 42;</i>
<i>;</i>
        <strong>lda     #$2A</strong>
<i>;</i>
<i>; __A__ *= 4;</i>
<i>;</i>
        <strong>asl     a</strong>
        <strong>asl     a</strong>
<i>;</i>
<i>; }</i>
<i>;</i>
        rts
&nbsp;
.endproc
&nbsp;
</pre>

<p>Pozor ovšem na situaci, kdy jsou optimalizace zakázány. V&nbsp;takovém
případě dostaneme zcela neoptimální kód:</p>

<pre>
        ldx     #$00
        lda     #$2A
        jsr     shlax1
        rts
</pre>



<p><a name="k16"></a></p>
<h2 id="k16">16. cc65 nakonec není tak hloupý &ndash; násobení třemi a pěti</h2>

<p>V&nbsp;předchozích kapitolách jsme si uvedli poměrně velké množství
příkladů, z&nbsp;nichž je zřejmé, že překladač cc65 nedokáže provádět mnohé
optimalizace, na které jsme zvyklí z&nbsp;moderních překladačů určených pro
moderní mikroprocesory. Na druhou stranu ovšem není cc65 úplně hloupý, protože
dokáže optimalizovat alespoň násobení určitými konstantami. Ukázali jsme si,
jak je rozpoznáno násobení mocninou dvojky, ovšem cc65 dokáže nahradit i
násobení dalšími konstantami optimalizovaným kódem. Začněme vynásobením
akumulátoru třemi (násobíme akumulátor, aby výsledný kód neobsahoval zbytečné
paměťové operace):</p>

<pre>
void main(void)
{
    __A__ = 42;
&nbsp;
    __A__ *= 3;
}
</pre>

<p>V&nbsp;tomto případě je násobení nahrazeno posunem doleva (tedy vynásobením
dvěma) a součtem s&nbsp;původní hodnotou, tedy A=A&lt;&lt;1+A=A*2+A=A*3, což je
poměrně příjemné zjištění:</p>

<pre>
<i>;</i>
<i>; File generated by cc65 v 2.18 - Ubuntu 2.18-1</i>
<i>;</i>
        .fopt           compiler,"cc65 v 2.18 - Ubuntu 2.18-1"
        .setcpu         "6502"
        .smart          on
        .autoimport     on
        .case           on
        .debuginfo      off
        .importzp       sp, sreg, regsave, regbank
        .importzp       tmp1, tmp2, tmp3, tmp4, ptr1, ptr2, ptr3, ptr4
        .macpack        longbranch
        .forceimport    __STARTUP__
        .export         _main
&nbsp;
<i>; ---------------------------------------------------------------</i>
<i>; void __near__ main (void)</i>
<i>; ---------------------------------------------------------------</i>
&nbsp;
.segment        "CODE"
&nbsp;
.proc   _main: near
&nbsp;
.segment        "CODE"
&nbsp;
<i>;</i>
<i>; __A__ = 42;</i>
<i>;</i>
        lda     #$2A
<i>;</i>
<i>; __A__ *= 3;</i>
<i>;</i>
        <strong>sta     tmp1</strong>
        <strong>asl     a</strong>
        <strong>clc</strong>
        <strong>adc     tmp1</strong>
<i>;</i>
<i>; }</i>
<i>;</i>
        rts

.endproc
</pre>

<p>V&nbsp;dalším příkladu zkusíme vynásobení pěti:</p>

<pre>
void main(void)
{
    __A__ = 42;
&nbsp;
    __A__ *= 5;
}
</pre>

<p>V&nbsp;tomto případě je násobení nahrazeno posunem doleva o dva bity (tedy
vynásobením čtyřmi) a součtem s&nbsp;původní hodnotou, tedy
A=A&lt;&lt;2+A=A*4+A=A*5:</p>

<pre>
<i>;</i>
<i>; File generated by cc65 v 2.18 - Ubuntu 2.18-1</i>
<i>;</i>
        .fopt           compiler,"cc65 v 2.18 - Ubuntu 2.18-1"
        .setcpu         "6502"
        .smart          on
        .autoimport     on
        .case           on
        .debuginfo      off
        .importzp       sp, sreg, regsave, regbank
        .importzp       tmp1, tmp2, tmp3, tmp4, ptr1, ptr2, ptr3, ptr4
        .macpack        longbranch
        .forceimport    __STARTUP__
        .export         _main
&nbsp;
<i>; ---------------------------------------------------------------</i>
<i>; void __near__ main (void)</i>
<i>; ---------------------------------------------------------------</i>
&nbsp;
.segment        "CODE"
&nbsp;
.proc   _main: near
&nbsp;
.segment        "CODE"
&nbsp;
<i>;</i>
<i>; __A__ = 42;</i>
<i>;</i>
        lda     #$2A
<i>;</i>
<i>; __A__ *= 5;</i>
<i>;</i>
        <strong>sta     tmp1</strong>
        <strong>asl     a</strong>
        <strong>asl     a</strong>
        <strong>clc</strong>
        <strong>adc     tmp1</strong>
<i>;</i>
<i>; }</i>
<i>;</i>
        rts
&nbsp;
.endproc
</pre>

<p><div class="rs-tip-major">Poznámka: v&nbsp;obou případech je výsledný kód
poměrně dobrý &ndash; zde cc65 ukázal své lepší stránky.</div></p>



<p><a name="k17"></a></p>
<h2 id="k17">17. Násobení větší konstantou</h2>

<p>V&nbsp;případě, že konstanta, kterou je násoben obsah akumulátoru, je
složitější, tj.&nbsp;pokud ji nelze snadno rozepsat na několik mocnin dvojky,
bude namísto optimalizovaného kódu zavolán podprogram (subrutina) pro násobení.
Připomeňme si totiž, že osmibitový mikroprocesor MOS 6502 neobsahoval instrukci
pro součin, což je ostatně s&nbsp;ohledem na jeho cenu a interní jednoduchost
pochopitelné:</p>

<pre>
void main(void)
{
    __A__ = 42;
&nbsp;
    __A__ *= 42;
}
</pre>

<p>Ve výše uvedeném příkladu se pokoušíme násobit konstantou 42, což se přeloží
do tohoto kódu:</p>

<pre>
<i>;</i>
<i>; File generated by cc65 v 2.18 - Ubuntu 2.18-1</i>
<i>;</i>
        .fopt           compiler,"cc65 v 2.18 - Ubuntu 2.18-1"
        .setcpu         "6502"
        .smart          on
        .autoimport     on
        .case           on
        .debuginfo      off
        .importzp       sp, sreg, regsave, regbank
        .importzp       tmp1, tmp2, tmp3, tmp4, ptr1, ptr2, ptr3, ptr4
        .macpack        longbranch
        .forceimport    __STARTUP__
        .export         _main

<i>; ---------------------------------------------------------------</i>
<i>; void __near__ main (void)</i>
<i>; ---------------------------------------------------------------</i>

.segment        "CODE"

.proc   _main: near

.segment        "CODE"

<i>;</i>
<i>; __A__ = 42;</i>
<i>;</i>
        <strong>lda     #$2A</strong>
<i>;</i>
<i>; __A__ *= 42;</i>
<i>;</i>
        <strong>jsr     pusha0</strong>
        <strong>jmp     tosumulax</strong>
&nbsp;
.endproc
</pre>

<p><div class="rs-tip-major">Poznámka: povšimněte si volání subrutiny pro
násobení. Mimochodem &ndash; otrocký překlad by měl vypadat takto:</div></p>

<pre>
        <strong>jsr     pusha0</strong>
        <strong>jsr     tosumulax</strong>
        rts
</pre>

<p>Překladač dvojici <strong>jsr+rts</strong> zaměnil za <strong>jmp</strong>,
protože ono <strong>rts</strong> je vlastně &bdquo;schováno&ldquo; ve volané
subrutině.</p>



<p><a name="k18"></a></p>
<h2 id="k18">18. Upravený soubor Makefile</h2>

<p>Pro úplnost si ještě ukažme, jak vypadá soubor Makefile, kterým byly
přeloženy všechny minule i dnes popsané demonstrační příklady. Tento soubor
předpokládá, že je <strong>cc65</strong> nainstalován tak, že je dostupný bez
nutnosti uvedení celé cesty k&nbsp;překladači. V&nbsp;opačném případě je nutné
změnit prvních několik řádků tohoto souboru:</p>

<pre>
CC65=cc65
&nbsp;
STD_FLAGS = 
INCLUDE_SOURCE =-T
STATIC_LOCAL_VARS = -Cl
STD_OPTIMIZATION = -O
REGISTER_VARS = -Or
INLINE_FUNC = -Oi
ALL_OPTIMIZATIONS = -Osir
&nbsp;
all:    local_add_1.asm local_add_2.asm local_add_3.asm local_add_4.asm local_add_5.asm local_add_6.asm local_add_7.asm \
        memset1.asm memset2.asm memset3.asm memset4.asm memset5.asm memset6.asm \
        empty_main.asm local_var_1.asm local_var_2.asm register_var_1.asm register_var_2.asm \
        a_register.asm ax_register_1.asm ax_register_2.asm eax_register_1.asm eax_register_2.asm \
        post_increment_1.asm post_increment_2.asm pre_increment_1.asm pre_increment_2.asm \
        assembly1.asm assembly2.asm assembly3.asm assembly4.asm \
        a_register_add.asm a_register_shift.asm a_register_rshift.asm a_register_double.asm \
        a_register_triple.asm a_register_quadruple.asm \
        a_register_half.asm a_register_times5.asm a_register_times42.asm
&nbsp;
clean:
        rm *.asm
&nbsp;
local_add_1.asm:        local_add.c
        ${CC65} ${STD_FLAGS} -o $@ $&lt;
&nbsp;
local_add_2.asm:        local_add.c
        ${CC65} ${STD_FLAGS} ${INCLUDE_SOURCE} -o $@ $&lt;
&nbsp;
local_add_3.asm:        local_add.c
        ${CC65} ${STD_FLAGS} ${INCLUDE_SOURCE} ${STATIC_LOCAL_VARS} -o $@ $&lt;
&nbsp;
local_add_4.asm:        local_add.c
        ${CC65} ${STD_FLAGS} ${INCLUDE_SOURCE} ${STATIC_LOCAL_VARS} ${STD_OPTIMIZATION} -o $@ $&lt;
&nbsp;
local_add_5.asm:        local_add.c
        ${CC65} ${STD_FLAGS} ${INCLUDE_SOURCE} ${STATIC_LOCAL_VARS} ${REGISTER_VARS} -o $@ $&lt;
&nbsp;
local_add_6.asm:        local_add.c
        ${CC65} ${STD_FLAGS} ${INCLUDE_SOURCE} ${STATIC_LOCAL_VARS} ${INLINE_FUNC} -o $@ $&lt;
&nbsp;
local_add_7.asm:        local_add.c
        ${CC65} ${STD_FLAGS} ${INCLUDE_SOURCE} ${STATIC_LOCAL_VARS} ${ALL_OPTIMIZATIONS} -o $@ $&lt;
&nbsp;
local_add_B.asm:        local_add_B.c
        ${CC65} ${STD_FLAGS} ${INCLUDE_SOURCE} ${STATIC_LOCAL_VARS} ${INLINE_FUNC} -o $@ $&lt;
&nbsp;
local_mul.asm:  local_mul.c
        ${CC65} ${STD_FLAGS} ${INCLUDE_SOURCE} ${STATIC_LOCAL_VARS} ${ALL_OPTIMIZATIONS} -o $@ $&lt;
&nbsp;
memset1.asm:    memset1.c
        ${CC65} ${STD_FLAGS} ${INCLUDE_SOURCE} ${STATIC_LOCAL_VARS} ${STD_OPTIMIZATION} -o $@ $&lt;
&nbsp;
memset2.asm:    memset2.c
        ${CC65} ${STD_FLAGS} ${INCLUDE_SOURCE} ${STATIC_LOCAL_VARS} ${STD_OPTIMIZATION} -o $@ $&lt;
&nbsp;
memset3.asm:    memset3.c
        ${CC65} ${STD_FLAGS} ${INCLUDE_SOURCE} ${STATIC_LOCAL_VARS} ${STD_OPTIMIZATION} -o $@ $&lt;
&nbsp;
memset4.asm:    memset4.c
        ${CC65} ${STD_FLAGS} ${INCLUDE_SOURCE} ${STATIC_LOCAL_VARS} ${STD_OPTIMIZATION} -o $@ $&lt;
&nbsp;
memset5.asm:    memset5.c
        ${CC65} ${STD_FLAGS} ${INCLUDE_SOURCE} ${STATIC_LOCAL_VARS} ${STD_OPTIMIZATION} -o $@ $&lt;
&nbsp;
memset6.asm:    memset6 .c
        ${CC65} ${STD_FLAGS} ${INCLUDE_SOURCE} ${STATIC_LOCAL_VARS} ${STD_OPTIMIZATION} -o $@ $&lt;
&nbsp;
empty_main.asm: empty_main.c
        ${CC65} ${STD_FLAGS} ${INCLUDE_SOURCE} ${STATIC_LOCAL_VARS} ${STD_OPTIMIZATION} -o $@ $&lt;
&nbsp;
local_var_1.asm:        local_var.c
        ${CC65} ${STD_FLAGS} ${INCLUDE_SOURCE} ${STATIC_LOCAL_VARS} ${STD_OPTIMIZATION} -o $@ $&lt;
&nbsp;
local_var_2.asm:        local_var.c
        ${CC65} ${STD_FLAGS} ${INCLUDE_SOURCE} ${REGISTER_VARS} ${STD_OPTIMIZATION} -o $@ $&lt;
&nbsp;
register_var_1.asm:     register_var.c
        ${CC65} ${STD_FLAGS} ${INCLUDE_SOURCE} ${STATIC_LOCAL_VARS} ${STD_OPTIMIZATION} -o $@ $&lt;
&nbsp;
register_var_2.asm:     register_var.c
        ${CC65} ${STD_FLAGS} ${INCLUDE_SOURCE} ${REGISTER_VARS} ${STD_OPTIMIZATION} -o $@ $&lt;
&nbsp;
a_register.asm: a_register.c
        ${CC65} ${STD_FLAGS} ${INCLUDE_SOURCE} ${STD_OPTIMIZATION} -o $@ $&lt;
&nbsp;
ax_register_1.asm:      ax_register.c
        ${CC65} ${STD_FLAGS} ${INCLUDE_SOURCE} -o $@ $&lt;
&nbsp;
ax_register_2.asm:      ax_register.c
        ${CC65} ${STD_FLAGS} ${INCLUDE_SOURCE} ${STD_OPTIMIZATION} -o $@ $&lt;
&nbsp;
eax_register_1.asm:     eax_register.c
        ${CC65} ${STD_FLAGS} ${INCLUDE_SOURCE} -o $@ $&lt;
&nbsp;
eax_register_2.asm:     eax_register.c
        ${CC65} ${STD_FLAGS} ${INCLUDE_SOURCE} ${STD_OPTIMIZATION} -o $@ $&lt;
&nbsp;
post_increment_1.asm:   post_increment.c
        ${CC65} ${STD_FLAGS} ${INCLUDE_SOURCE} ${STATIC_LOCAL_VARS} ${STD_OPTIMIZATION} ${INLINE_FUNC} -o $@ $&lt;
&nbsp;
post_increment_2.asm:   post_increment.c
        ${CC65} ${STD_FLAGS} ${INCLUDE_SOURCE} ${post_incrementS} ${STD_OPTIMIZATION} ${INLINE_FUNC} -o $@ $&lt;
&nbsp;
pre_increment_1.asm:    pre_increment.c
        ${CC65} ${STD_FLAGS} ${INCLUDE_SOURCE} ${STATIC_LOCAL_VARS} ${STD_OPTIMIZATION} ${INLINE_FUNC} -o $@ $&lt;
&nbsp;
pre_increment_2.asm:    pre_increment.c
        ${CC65} ${STD_FLAGS} ${INCLUDE_SOURCE} ${pre_incrementS} ${STD_OPTIMIZATION} ${INLINE_FUNC} -o $@ $&lt;
&nbsp;
assembly1.asm:  assembly1.c
        ${CC65} ${STD_FLAGS} ${INCLUDE_SOURCE} ${pre_incrementS} ${STD_OPTIMIZATION} ${REGISTER_VARS} -o $@ $&lt;
&nbsp;
assembly2.asm:  assembly2.c
        ${CC65} ${STD_FLAGS} ${INCLUDE_SOURCE} ${pre_incrementS} ${STD_OPTIMIZATION} ${REGISTER_VARS} -o $@ $&lt;
&nbsp;
assembly3.asm:  assembly3.c
        ${CC65} ${STD_FLAGS} ${INCLUDE_SOURCE} ${pre_incrementS} ${STD_OPTIMIZATION} ${REGISTER_VARS} -o $@ $&lt;
&nbsp;
assembly4.asm:  assembly4.c
        ${CC65} ${STD_FLAGS} ${INCLUDE_SOURCE} ${pre_incrementS} ${STD_OPTIMIZATION} ${REGISTER_VARS} -o $@ $&lt;
&nbsp;
a_register_add.asm:     a_register_add.c
        ${CC65} ${STD_FLAGS} ${INCLUDE_SOURCE} ${STD_OPTIMIZATION} -o $@ $&lt;
&nbsp;
a_register_shift.asm:   a_register_shift.c
        ${CC65} ${STD_FLAGS} ${INCLUDE_SOURCE} ${STD_OPTIMIZATION} -o $@ $&lt;
&nbsp;
a_register_rshift.asm:  a_register_rshift.c
        ${CC65} ${STD_FLAGS} ${INCLUDE_SOURCE} ${STD_OPTIMIZATION} -o $@ $&lt;
&nbsp;
a_register_double.asm:  a_register_double.c
        ${CC65} ${STD_FLAGS} ${INCLUDE_SOURCE} ${STD_OPTIMIZATION} -o $@ $&lt;
&nbsp;
a_register_triple.asm:  a_register_triple.c
        ${CC65} ${STD_FLAGS} ${INCLUDE_SOURCE} ${STD_OPTIMIZATION} -o $@ $&lt;
&nbsp;
a_register_quadruple.asm:       a_register_quadruple.c
        ${CC65} ${STD_FLAGS} ${INCLUDE_SOURCE} ${STD_OPTIMIZATION} -o $@ $&lt;
&nbsp;
a_register_times5.asm:  a_register_times5.c
        ${CC65} ${STD_FLAGS} ${INCLUDE_SOURCE} ${STD_OPTIMIZATION} -o $@ $&lt;
&nbsp;
a_register_times42.asm: a_register_times42.c
        ${CC65} ${STD_FLAGS} ${INCLUDE_SOURCE} ${STD_OPTIMIZATION} -o $@ $&lt;
&nbsp;
a_register_half.asm:    a_register_half.c
        ${CC65} ${STD_FLAGS} ${INCLUDE_SOURCE} ${STD_OPTIMIZATION} -o $@ $&lt;
</pre>



<p><a name="k19"></a></p>
<h2 id="k19">19. Repositář s&nbsp;demonstračními příklady</h2>

<p>Demonstrační příklady napsané v&nbsp;jazyku C, které jsou určené pro překlad
pomocí překladače <strong>cc65</strong>, byly uložen do Git repositáře, který
je dostupný na adrese <a
href="https://github.com/tisnik/8bit-fame">https://github.com/tisnik/8bit-fame</a>.
Jednotlivé demonstrační příklady si můžete v&nbsp;případě potřeby stáhnout i
jednotlivě bez nutnosti klonovat celý (dnes již poměrně rozsáhlý)
repositář:</p>

<table>
<tr><th> #</th><th>Příklad</th><th>Stručný popis</th><th>Adresa</th></tr>
<tr><td> 1</td><td>local_add.c</td><td>funkce pro součet dvou celých čísel</td><td><a href="https://github.com/tisnik/8bit-fame/blob/master/cc65/local_add.c">https://github.com/tisnik/8bit-fame/blob/master/cc65/local_add.c</a></td></tr>
<tr><td> 2</td><td>memset1.c</td><td>vyplnění bloku paměti zadanou hodnotou, základní verze</td><td><a href="https://github.com/tisnik/8bit-fame/blob/master/cc65/memset1.c">https://github.com/tisnik/8bit-fame/blob/master/cc65/memset1.c</a></td></tr>
<tr><td> 3</td><td>memset2.c</td><td>vyplnění bloku paměti zadanou hodnotou, použití klíčového slova <strong>register</strong></td><td><a href="https://github.com/tisnik/8bit-fame/blob/master/cc65/memset2.c">https://github.com/tisnik/8bit-fame/blob/master/cc65/memset2.c</a></td></tr>
<tr><td> 4</td><td>memset3.c</td><td>vyplnění bloku paměti zadanou hodnotou, použití konstantních parametrů</td><td><a href="https://github.com/tisnik/8bit-fame/blob/master/cc65/memset3.c">https://github.com/tisnik/8bit-fame/blob/master/cc65/memset3.c</a></td></tr>
<tr><td> 5</td><td>memset4.c</td><td>vyplnění bloku paměti zadanou hodnotou, přepis na smyčku <strong>while</strong></td><td><a href="https://github.com/tisnik/8bit-fame/blob/master/cc65/memset4.c">https://github.com/tisnik/8bit-fame/blob/master/cc65/memset4.c</a></td></tr>
<tr><td> 6</td><td>memset5.c</td><td>vyplnění bloku paměti zadanou hodnotou, přepis na smyčku <strong>do-while</strong></td><td><a href="https://github.com/tisnik/8bit-fame/blob/master/cc65/memset5.c">https://github.com/tisnik/8bit-fame/blob/master/cc65/memset5.c</a></td></tr>
<tr><td> 7</td><td>memset6.c</td><td>použití ukazatele namísto indexování přes pole</td><td><a href="https://github.com/tisnik/8bit-fame/blob/master/cc65/memset6.c">https://github.com/tisnik/8bit-fame/blob/master/cc65/memset6.c</a></td></tr>
<tr><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td></tr>
<tr><td> 8</td><td>empty_main.c</td><td>zdrojový kód obsahující pouze prázdnou funkci <strong>main</strong></td><td><a href="https://github.com/tisnik/8bit-fame/blob/master/cc65/empty_main.c">https://github.com/tisnik/8bit-fame/blob/master/cc65/empty_main.c</a></td></tr>
<tr><td> 9</td><td>local_var.c</td><td>funkce <strong>main</strong> s&nbsp;lokální proměnnou</td><td><a href="https://github.com/tisnik/8bit-fame/blob/master/cc65/local_var.c">https://github.com/tisnik/8bit-fame/blob/master/cc65/local_var.c</a></td></tr>
<tr><td>10</td><td>register_var.c</td><td>funkce <strong>main</strong> s&nbsp;proměnnou s&nbsp;deklarací <strong>register</strong></td><td><a href="https://github.com/tisnik/8bit-fame/blob/master/cc65/register_var.c">https://github.com/tisnik/8bit-fame/blob/master/cc65/register_var.c</a></td></tr>
<tr><td>11</td><td>a_register.c</td><td>manipulace s&nbsp;registrem A</td><td><a href="https://github.com/tisnik/8bit-fame/blob/master/cc65/a_register.c">https://github.com/tisnik/8bit-fame/blob/master/cc65/a_register.c</a></td></tr>
<tr><td>12</td><td>ax_register.c</td><td>manipulace s&nbsp;dvojicí registrů A a X</td><td><a href="https://github.com/tisnik/8bit-fame/blob/master/cc65/ax_register.c">https://github.com/tisnik/8bit-fame/blob/master/cc65/ax_register.c</a></td></tr>
<tr><td>13</td><td>eax_register.c</td><td>manipulace s&nbsp;dvojicí registrů A, X a dvojicí paměťových míst</td><td><a href="https://github.com/tisnik/8bit-fame/blob/master/cc65/eax_register.c">https://github.com/tisnik/8bit-fame/blob/master/cc65/eax_register.c</a></td></tr>
<tr><td>14</td><td>post_increment.c</td><td>použití operátoru ++ <i>za</i> operandem (postfixová varianta)</td><td><a href="https://github.com/tisnik/8bit-fame/blob/master/cc65/post_increment.c">https://github.com/tisnik/8bit-fame/blob/master/cc65/post_increment.c</a></td></tr>
<tr><td>15</td><td>pre_increment.c</td><td>použití operátoru ++ <i>před</i> operandem (prefixová varianta)</td><td><a href="https://github.com/tisnik/8bit-fame/blob/master/cc65/pre_increment.c">https://github.com/tisnik/8bit-fame/blob/master/cc65/pre_increment.c</a></td></tr>
<tr><td>16</td><td>assembly1.c</td><td>mixování kódu v&nbsp;C a assembleru</td><td><a href="https://github.com/tisnik/8bit-fame/blob/master/cc65/assembly1.c">https://github.com/tisnik/8bit-fame/blob/master/cc65/assembly1.c</a></td></tr>
<tr><td>17</td><td>assembly2.c</td><td>uložení výsledku do lokální proměnné jedinou instrukcí assembleru</td><td><a href="https://github.com/tisnik/8bit-fame/blob/master/cc65/assembly2.c">https://github.com/tisnik/8bit-fame/blob/master/cc65/assembly2.c</a></td></tr>
<tr><td>18</td><td>assembly3.c</td><td>součet ručně optimalizovaný v&nbsp;assembleru</td><td><a href="https://github.com/tisnik/8bit-fame/blob/master/cc65/assembly3.c">https://github.com/tisnik/8bit-fame/blob/master/cc65/assembly3.c</a></td></tr>
<tr><td>19</td><td>assembly4.c</td><td>taktéž součet, ovšem tentokrát s&nbsp;globálními proměnnými</td><td><a href="https://github.com/tisnik/8bit-fame/blob/master/cc65/assembly4.c">https://github.com/tisnik/8bit-fame/blob/master/cc65/assembly4.c</a></td></tr>
<tr><td>20</td><td>local_add_B.c</td><td>součet bez použití assembleru</td><td><a href="https://github.com/tisnik/8bit-fame/blob/master/cc65/local_add_B.c">https://github.com/tisnik/8bit-fame/blob/master/cc65/local_add_B.c</a></td></tr>
<tr><td>21</td><td>local_mul.c</td><td>vynásobení dvou proměnných bez použití assembleru</td><td><a href="https://github.com/tisnik/8bit-fame/blob/master/cc65/local_mul.c">https://github.com/tisnik/8bit-fame/blob/master/cc65/local_mul.c</a></td></tr>
<tr><td>22</td><td>a_register_add.c</td><td>přičtení jedničky k&nbsp;akumulátoru</td><td><a href="https://github.com/tisnik/8bit-fame/blob/master/cc65/a_register_add.c">https://github.com/tisnik/8bit-fame/blob/master/cc65/a_register_add.c</a></td></tr>
<tr><td>23</td><td>a_register_shift.c</td><td>aritmetický posun akumulátoru doleva</td><td><a href="https://github.com/tisnik/8bit-fame/blob/master/cc65/a_register_shift.c">https://github.com/tisnik/8bit-fame/blob/master/cc65/a_register_shift.c</a></td></tr>
<tr><td>24</td><td>a_register_rshift.c</td><td>aritmetický posun akumulátoru doprava</td><td><a href="https://github.com/tisnik/8bit-fame/blob/master/cc65/a_register_rshift.c">https://github.com/tisnik/8bit-fame/blob/master/cc65/a_register_rshift.c</a></td></tr>
<tr><td>25</td><td>a_register_half.c</td><td>vydělení akumulátoru dvěma</td><td><a href="https://github.com/tisnik/8bit-fame/blob/master/cc65/a_register_half.c">https://github.com/tisnik/8bit-fame/blob/master/cc65/a_register_half.c</a></td></tr>
<tr><td>26</td><td>a_register_double.c</td><td>vynásobení akumulátoru dvěma</td><td><a href="https://github.com/tisnik/8bit-fame/blob/master/cc65/a_register_double.c">https://github.com/tisnik/8bit-fame/blob/master/cc65/a_register_double.c</a></td></tr>
<tr><td>27</td><td>a_register_triple.c</td><td>vynásobení akumulátoru třemi</td><td><a href="https://github.com/tisnik/8bit-fame/blob/master/cc65/a_register_triple.c">https://github.com/tisnik/8bit-fame/blob/master/cc65/a_register_triple.c</a></td></tr>
<tr><td>28</td><td>a_register_quadruple.c</td><td>vynásobení akumulátoru čtyřmi</td><td><a href="https://github.com/tisnik/8bit-fame/blob/master/cc65/a_register_quadruple.c">https://github.com/tisnik/8bit-fame/blob/master/cc65/a_register_quadruple.c</a></td></tr>
<tr><td>29</td><td>a_register_times5.c</td><td>vynásobení akumulátoru pěti</td><td><a href="https://github.com/tisnik/8bit-fame/blob/master/cc65/a_register_times5.c">https://github.com/tisnik/8bit-fame/blob/master/cc65/a_register_times5.c</a></td></tr>
<tr><td>30</td><td>a_register_times42.c</td><td>vynásobení akumulátoru konstantou 42</td><td><a href="https://github.com/tisnik/8bit-fame/blob/master/cc65/a_register_times42.c">https://github.com/tisnik/8bit-fame/blob/master/cc65/a_register_times42.c</a></td></tr>
<tr><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td></tr>
<tr><td>31</td><td>Makefile</td><td>soubor zajišťující překlad všech demonstračních příkladů do assembleru s&nbsp;různými volbami</td><td><a href="https://github.com/tisnik/8bit-fame/blob/master/cc65/Makefile">https://github.com/tisnik/8bit-fame/blob/master/cc65/Makefile</a></td></tr>
</table>



<p><a name="k20"></a></p>
<h2 id="k20">20. Odkazy na Internetu</h2>

<ol>

<li>When did people first start thinking 'C is portable assembler'?<br />
<a href="https://stackoverflow.com/questions/3040276/when-did-people-first-start-thinking-c-is-portable-assembler">https://stackoverflow.com/questions/3040276/when-did-people-first-start-thinking-c-is-portable-assembler</a>
</li>

<li>The Thirty Million Line Problem<br />
<a href="https://www.youtube.com/watch?v=kZRE7HIO3vk">https://www.youtube.com/watch?v=kZRE7HIO3vk</a>
</li>

<li>cc65 coding hints<br />
<a href="https://cc65.github.io/doc/coding.html">https://cc65.github.io/doc/coding.html</a>
</li>

<li>NesDev.org<br />
<a href="https://www.nesdev.org/">https://www.nesdev.org/</a>
</li>

<li>How to Program an NES game in C<br />
<a href="https://nesdoug.com/">https://nesdoug.com/</a>
</li>

<li>Cycle reference chart<br />
<a href="https://www.nesdev.org/wiki/Cycle_reference_chart">https://www.nesdev.org/wiki/Cycle_reference_chart</a>
</li>

<li>Getting Started Programming in C: Coding a Retro Game with C Part 2<br />
<a href="https://retrogamecoders.com/getting-started-with-c-cc65/">https://retrogamecoders.com/getting-started-with-c-cc65/</a>
</li>

<li>NES game development in 6502 assembly - Part 1<br />
<a href="https://kibrit.tech/en/blog/nes-game-development-part-1">https://kibrit.tech/en/blog/nes-game-development-part-1</a>
</li>

<li>NES 6502 Programming Tutorial - Part 1: Getting Started<br />
<a href="https://dev.xenforo.relay.cool/index.php?threads/nes-6502-programming-tutorial-part-1-getting-started.858389/">https://dev.xenforo.relay.cool/index.php?threads/nes-6502-programming-tutorial-part-1-getting-started.858389/</a>
</li>

<li>List of 6502-based Computers and Consoles<br />
<a href="https://www.retrocompute.co.uk/list-of-6502-based-computers-and-consoles/">https://www.retrocompute.co.uk/list-of-6502-based-computers-and-consoles/</a>
</li>

<li>6502 - the first RISC &micro;P<br />
<a href="http://ericclever.com/6500/">http://ericclever.com/6500/</a>
</li>

<li>ca65 Users Guide<br />
<a href="https://cc65.github.io/doc/ca65.html">https://cc65.github.io/doc/ca65.html</a>
</li>

<li>cc65 Users Guide<br />
<a href="https://cc65.github.io/doc/cc65.html">https://cc65.github.io/doc/cc65.html</a>
</li>

<li>ld65 Users Guide<br />
<a href="https://cc65.github.io/doc/ld65.html">https://cc65.github.io/doc/ld65.html</a>
</li>

<li>da65 Users Guide<br />
<a href="https://cc65.github.io/doc/da65.html">https://cc65.github.io/doc/da65.html</a>
</li>

<li>“Hello, world” from scratch on a 6502 — Part 1<br />
<a href="https://www.youtube.com/watch?v=LnzuMJLZRdU">https://www.youtube.com/watch?v=LnzuMJLZRdU</a>
</li>

<li>A Tour of 6502 Cross-Assemblers<br />
<a href="https://bumbershootsoft.wordpress.com/2016/01/31/a-tour-of-6502-cross-assemblers/">https://bumbershootsoft.wordpress.com/2016/01/31/a-tour-of-6502-cross-assemblers/</a>
</li>

<li>6502 PRIMER: Building your own 6502 computer<br />
<a href="http://wilsonminesco.com/6502primer/">http://wilsonminesco.com/6502primer/</a>
</li>

<li>6502 Instruction Set<br />
<a href="https://www.masswerk.at/6502/6502_instruction_set.html">https://www.masswerk.at/6502/6502_instruction_set.html</a>
</li>

<li>Chip Hall of Fame: MOS Technology 6502 Microprocessor<br />
<a href="https://spectrum.ieee.org/tech-history/silicon-revolution/chip-hall-of-fame-mos-technology-6502-microprocessor">https://spectrum.ieee.org/tech-history/silicon-revolution/chip-hall-of-fame-mos-technology-6502-microprocessor</a>
</li>

<li>Single-board computer<br />
<a href="https://en.wikipedia.org/wiki/Single-board_computer">https://en.wikipedia.org/wiki/Single-board_computer</a>
</li>

<li>www.6502.org<br />
<a href="http://www.6502­.org/">http://www.6502­.org/</a>
</li>

<li>6502 PRIMER: Building your own 6502 computer &ndash; clock generator<br />
<a href="http://wilsonminesco.com/6502primer/ClkGen.html">http://wilsonminesco.com/6502primer/ClkGen.html</a>
</li>

<li>Great Microprocessors of the Past and Present (V 13.4.0)<br />
<a href="http://www.cpushack.com/CPU/cpu.html">http://www.cpushack.com/CPU/cpu.html</a>
</li>

<li>Jak se zrodil procesor?<br />
<a href="https://www.root.cz/clanky/jak-se-zrodil-procesor/">https://www.root.cz/clanky/jak-se-zrodil-procesor/</a>
</li>

<li>Osmibitové mikroprocesory a mikrořadiče firmy Motorola (1)<br />
<a href="https://www.root.cz/clanky/osmibitove-mikroprocesory-a-mikroradice-firmy-motorola-1/">https://www.root.cz/clanky/osmibitove-mikroprocesory-a-mikroradice-firmy-motorola-1/</a>
</li>

<li>Mikrořadiče a jejich použití v jednoduchých mikropočítačích<br />
<a href="https://www.root.cz/clanky/mikroradice-a-jejich-pouziti-v-jednoduchych-mikropocitacich/">https://www.root.cz/clanky/mikroradice-a-jejich-pouziti-v-jednoduchych-mikropocitacich/</a>
</li>

<li>Mikrořadiče a jejich aplikace v jednoduchých mikropočítačích (2)<br />
<a href="https://www.root.cz/clanky/mikroradice-a-jejich-aplikace-v-jednoduchych-mikropocitacich-2/">https://www.root.cz/clanky/mikroradice-a-jejich-aplikace-v-jednoduchych-mikropocitacich-2/</a>
</li>

<li>25 Microchips That Shook the World<br />
<a href="https://spectrum.ieee.org/tech-history/silicon-revolution/25-microchips-that-shook-the-world">https://spectrum.ieee.org/tech-history/silicon-revolution/25-microchips-that-shook-the-world</a>
</li>

<li>Comparison of instruction set architectures<br />
<a href="https://en.wikipedia.org/wiki/Comparison_of_instruction_set_architectures">https://en.wikipedia.org/wiki/Comparison_of_instruction_set_architectures</a>
</li>

<li>Vývojové nástroje používané v dobách osmibitových mikropočítačů<br />
<a href="https://www.root.cz/clanky/vyvojove-nastroje-pouzivane-v-dobach-osmibitovych-mikropocitacu/">https://www.root.cz/clanky/vyvojove-nastroje-pouzivane-v-dobach-osmibitovych-mikropocitacu/</a>
</li>

<li>Historie vývoje počítačových her (112. část – vývojové nástroje pro herní konzole)<br />
<a href="https://www.root.cz/clanky/historie-vyvoje-pocitacovych-her-112-cast-vyvojove-nastroje-pro-herni-konzole/">https://www.root.cz/clanky/historie-vyvoje-pocitacovych-her-112-cast-vyvojove-nastroje-pro-herni-konzole/</a>
</li>

<li>Programovací jazyky a vývojové nástroje pro mikropočítače společnosti Sinclair Research<br />
<a href="https://www.root.cz/clanky/programovaci-jazyky-a-vyvojove-nastroje-pro-mikropocitace-spolecnosti-sinclair-research/">https://www.root.cz/clanky/programovaci-jazyky-a-vyvojove-nastroje-pro-mikropocitace-spolecnosti-sinclair-research/</a>
</li>

<li>Programovací jazyky používané na platformě osmibitových domácích mikropočítačů Atari<br />
<a href="https://www.root.cz/clanky/programovaci-jazyky-pouzivane-na-platforme-osmibitovych-domacich-mikropocitacu-atari/">https://www.root.cz/clanky/programovaci-jazyky-pouzivane-na-platforme-osmibitovych-domacich-mikropocitacu-atari/</a>
</li>

<li>Programovací jazyky používané na platformě osmibitových domácích mikropočítačů Atari (2)<br />
<a href="https://www.root.cz/clanky/programovaci-jazyky-pouzivane-na-platforme-osmibitovych-domacich-mikropocitacu-atari-2/">https://www.root.cz/clanky/programovaci-jazyky-pouzivane-na-platforme-osmibitovych-domacich-mikropocitacu-atari-2/</a>
</li>

<li>Cross assemblery a cross překladače pro platformu osmibitových domácích mikropočítačů Atari<br />
<a href="https://www.root.cz/clanky/cross-assemblery-a-cross-prekladace-pro-platformu-osmibitovych-domacich-mikropocitacu-atari/">https://www.root.cz/clanky/cross-assemblery-a-cross-prekladace-pro-platformu-osmibitovych-domacich-mikropocitacu-atari/</a>
</li>

<li>C Isn't A Programming Language Anymore<br />
<a href="https://faultlore.com/blah/c-isnt-a-language/">https://faultlore.com/blah/c-isnt-a-language/</a>
</li>

<li>Why the C Language Will Never Stop You from Making Mistakes<br />
<a href="https://thephd.dev/your-c-compiler-and-standard-library-will-not-help-you">https://thephd.dev/your-c-compiler-and-standard-library-will-not-help-you</a>
</li>

<li>Benchmark: C compilers for the 6502 CPU<br />
<a href="https://sgadrat.itch.io/super-tilt-bro/devlog/219534/benchmark-c-compilers-for-the-6502-cpu">https://sgadrat.itch.io/super-tilt-bro/devlog/219534/benchmark-c-compilers-for-the-6502-cpu</a>
</li>

<li>Advanced optimizations in CC65<br />
<a href="https://github.com/ilmenit/CC65-Advanced-Optimizations">https://github.com/ilmenit/CC65-Advanced-Optimizations</a>
</li>

<li>The 6502/65C02/65C816 Instruction Set Decoded<br />
<a href="https://llx.com/Neil/a2/opcodes.html">https://llx.com/Neil/a2/opcodes.html</a>
</li>

<li>6502 C Compilers Comparison<br />
<a href="https://gglabs.us/node/2293">https://gglabs.us/node/2293</a>
</li>

<li>6502 C compilers benchmark<br />
<a href="https://github.com/sgadrat/6502-compilers-bench">https://github.com/sgadrat/6502-compilers-bench</a>
</li>

<li>cc65: Differences to the ISO standard<br />
<a href="https://cc65.github.io/doc/cc65.html#s4">https://cc65.github.io/doc/cc65.html#s4</a>
</li>

<li>Compilers<br />
<a href="http://www.6502.org/tools/lang/">http://www.6502.org/tools/lang/</a>
</li>

<li>Překladače jazyka C pro historické osmibitové mikroprocesory<br />
<a href="https://www.root.cz/clanky/prekladace-jazyka-c-pro-historicke-osmibitove-mikroprocesory/">https://www.root.cz/clanky/prekladace-jazyka-c-pro-historicke-osmibitove-mikroprocesory/</a>
</li>

</ol>



<p></p><p></p>
<p><small>Autor: <a href="http://www.fit.vutbr.cz/~tisnovpa">Pavel Tišnovský</a> &nbsp; 2022</small></p>
</body>
</html>

