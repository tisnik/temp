<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
        "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html>
<head>
<title>Algoritmus CORDIC a numerické formáty s pevnou řádovou čárkou</title>
<meta name="Author" content="Pavel Tisnovsky" />
<meta name="Generator" content="vim" />
<meta http-equiv="content-type" content="text/html; charset=utf-8" />
<style type="text/css">
         body {color:#000000; background:#ffffff;}
         h1  {font-family: arial, helvetica, sans-serif; color:#ffffff; background-color:#c00000; text-align:center; padding-left:1em}
         h2  {font-family: arial, helvetica, sans-serif; color:#ffffff; background-color:#0000c0; padding-left:1em; text-align:left}
         h3  {font-family: arial, helvetica, sans-serif; color:#000000; background-color:#c0c0c0; padding-left:1em; text-align:left}
         h4  {font-family: arial, helvetica, sans-serif; color:#000000; background-color:#e0e0e0; padding-left:1em; text-align:left}
         a   {font-family: arial, helvetica, sans-serif;}
         li  {font-family: arial, helvetica, sans-serif; color:#000000; text-align:justify; width:450px;}
         ol  {font-family: arial, helvetica, sans-serif; color:#000000; text-align:justify; width:450px;}
         ul  {font-family: arial, helvetica, sans-serif; color:#000000; text-align:justify; width:450px;}
         p   {font-family: arial, helvetica, sans-serif; color:#000000; text-align:justify;}
         pre {background:#e0e0e0}
</style>
</head>

<body>

<h1>Algoritmus CORDIC a numerické formáty s pevnou řádovou čárkou</h1>

<h3>Pavel Tišnovský</h3>

<p></p>

<h1>Úvodník</h1>

<p></p>



<h2>Obsah</h2>

<p><a href="#k01">1. Algoritmus CORDIC a numerické formáty s&nbsp;pevnou řádovou čárkou</a></p>
<p><a href="#k02">2. Výpočet délky vektoru pomocí algoritmu CORDIC</a></p>
<p><a href="#k03">3. První demonstrační příklad: výpočet délky vektoru</a></p>
<p><a href="#k04">4. Výpočet logaritmu algoritmem CORDIC</a></p>
<p><a href="#k05">5. Druhý demonstrační příklad: výpočet přirozeného logaritmu</a></p>
<p><a href="#k06">6. Výsledky získané předchozím příkladem</a></p>
<p><a href="#k07">7. Algoritmus CORDIC s&nbsp;hodnotami uloženými ve formátu pevné řádové binární čárky</a></p>
<p><a href="#k08">8. Realizace funkce určené pro naplnění tabulky <strong>atans</strong>[] (arkustangenty vhodně zvolených úhlů)</a></p>
<p><a href="#k09">*** 9. </a></p>
<p><a href="#k10">*** 10. </a></p>
<p><a href="#k11">*** 11. </a></p>
<p><a href="#k12">*** 12. </a></p>
<p><a href="#k13">*** 13. </a></p>
<p><a href="#k14">*** 14. </a></p>
<p><a href="#k15">*** 15. </a></p>
<p><a href="#k16">*** 16. </a></p>
<p><a href="#k17">*** 17. </a></p>
<p><a href="#k18">*** 18. Repositář s&nbsp;demonstračními příklady</a></p>
<p><a href="#k19">19. Literatura</a></p>
<p><a href="#k20">*** 20. Odkazy na Internetu</a></p>



<p><a name="k01"></a></p>
<h2 id="k01">1. Algoritmus CORDIC a numerické formáty s&nbsp;pevnou řádovou čárkou</h2>

<p>V&nbsp;předchozích článcích jsme si uvedli, jakým způsobem je možné
algoritmus <strong>CORDIC</strong> (<i><strong>CO</strong>ordinate
<strong>RO</strong>tation <strong>DI</strong>gital
<strong>C</strong>omputer</i>) použít pro výpočet goniometrických funkcí
s&nbsp;hodnotami uloženými ve formátu plovoucí řádové binární čárky (FP).
Tentýž algoritmus je však po mírné modifikaci možné použít i při práci
s&nbsp;formátem pevné řádové binární čárky (FX) a dá se říci, že teprve zde se
plně ukazuje jeho implementační jednoduchost a současně i velká vyjadřovací
síla &ndash; pomocí jednoho iteračního postupu je možné vypočítat poměrně velké
množství navzájem značně odlišných funkcí, přičemž paměťové nároky algoritmu
jsou minimální a rovnají se tabulce s&nbsp;cca deseti až dvaceti prvky
s&nbsp;rozsahem 32 (popř.&nbsp;pouze 16) bitů. To je výhodné především při
implementaci na mikrořadičích (oblíbená řada 8051, PICy, řada 68HC11 atd.) a
také při práci s&nbsp;programovatelnými obvody typu FPGA.</p>

<p>Dnes se budeme zabývat právě tímto problémem. Nejdříve si však
v&nbsp;kapitolách 2-6 ukážeme, jak lze CORDIC po úpravách použít i pro další
(sofistikovanější) výpočty, například pro výpočet délky vektoru, výpočet
hyperbolických funkcí, ale i pro výpočet logaritmů.</p>



<p><a name="k02"></a></p>
<h2 id="k02">2. Výpočet délky vektoru pomocí algoritmu CORDIC</h2>

<p>Délka vektoru (pro jednoduchost zůstaneme v&nbsp;rovině) se kupodivu počítá
naprosto stejným způsobem, jako funkce <i>arkustangenty</i>. Je tomu tak
z&nbsp;toho důvodu, že se arkustangenta iterativně vypočítá pootočením
vstupního vektoru do polohy, ve které má y-ovou souřadnici nulovou. To však
logicky znamená, že jeho x-ová souřadnice odpovídá délce vektoru, protože
platí:</p>

<p><i>d=sqrt(x<sup>2</sup>+y<sup>2</sup>)=sqrt(x<sup>2</sup>+0)=sqrt(x<sup>2</sup>)=x</i></p>

<p>To tedy znamená, že se <a
href="https://www.root.cz/clanky/vypocty-v-systemu-pevne-radove-carky-na-platforme-ibm-pc-3-cast/">minule
uvedená funkce pro výpočet arkustangenty</a> je po malých úpravách použitelná i
pro výpočet délky vektoru. Postačuje ji jen upravit tak, že se výsledná hodnota
<i>x<sub>i</sub></i> (vzniklá po <i>i</i> iteracích) vynásobí konstantou
<i>K<sub>i</sub></i> stejným způsobem, jaký jsme prováděli u výpočtů funkcí
<i>sin()</i> a <i>cos()</i> v&nbsp;předchozím pokračování tohoto seriálu.</p>

<p>Vlastnosti algoritmu CORDIC, díky které je možné jednoduše spočítat délku
vektoru, není (resp.&nbsp;přesněji řečeno nebyla) široce známa, proto některé
FPU pro tuto činnost ani neobsahují instrukci, což je škoda, zejména při práci
s&nbsp;grafikou, kde se délky velmi často počítají a je pro ně nutné použít
dvojici násobení, jedno sečítání a k&nbsp;tomu ještě druhou odmocninu,
tj.&nbsp;poměrně zdlouhavé a složité operace.</p>



<p><a name="k03"></a></p>
<h2 id="k03">3. První demonstrační příklad: výpočet délky vektoru</h2>

<p>Po překladu a spuštění dnešního prvního demonstračního příkladu se zobrazí
tabulka s&nbsp;délkami vektorů, jejichž souřadnice postupně nabývají hodnot od
nuly do desíti (včetně):</p>

<pre>
<i>// --------------------------------------------------------</i>
<i>// Výpočet délky vektoru pomocí iteračního algoritmu</i>
<i>// CORDIC.</i>
<i>// --------------------------------------------------------</i>
&nbsp;
#include &lt;math.h&gt;
#include &lt;stdio.h&gt;
&nbsp;
#ifndef M_PI
#define M_PI 3.14159265358979323846
#endif
&nbsp;
<i>// maximální počet iterací při běhu algoritmu</i>
#define MAX_ITER 20
&nbsp;
<i>// "zesílení" při rotacích</i>
#define K 0.6073
&nbsp;
<i>// tabulka arkustangentu úhlů</i>
double atans[MAX_ITER];
&nbsp;
<i>// tabulka záporných celočíselných mocnin hodnoty 2</i>
double pows[MAX_ITER];
&nbsp;
<i>// naplnění tabulek atans[] a pows[]</i>
void <strong>createTables</strong>(void) {
    int i;
    for (i = 0; i &lt; MAX_ITER; i++) {
        double p = pow(2.0, -i);
        atans[i] = atan(p);
        pows[i] = p;
    }
}
&nbsp;
<i>// výpočet velikosti vektoru pomocí algoritmu CORDIC</i>
double <strong>mag_cordic</strong>(double y, double x) {
    int i;
    double x0 = x; <i>// nastavení počátečních podmínek</i>
    double y0 = y;
    double xn;
    double delta = 0.0;
    for (i = 0; i &lt; MAX_ITER; i++) { <i>// iterační smyčka</i>
        if (y0 &gt; 0) {                <i>// kladná polorovina =&gt; rotace doleva</i>
            xn = x0 + y0 * pows[i];
            y0 -= x0 * pows[i];
            delta += atans[i];
        } else { <i>// záporná polorovina =&gt; rotace doprava</i>
            xn = x0 - y0 * pows[i];
            y0 += x0 * pows[i];
            delta -= atans[i];
        }
        x0 = xn;
    }
    return x0 * K;      <i>// délka vektoru</i>
}
&nbsp;
int <strong>main</strong>(void) {
    double x, y;
    createTables();
    printf("%f\n", mag_cordic(3, 4));       <i>// výpočet Pythagorova trojúhelníka</i>
    for (y=0.0; y&lt;=10.0; y+=1.0) {          <i>// tabulka velikostí různých vektorů</i>
        for (x=0.0; x&lt;=10.0; x+=1.0) {
            printf("%5.2f ", mag_cordic(x,y));
        }
        putchar('\n');
    }
    return 0;
}
&nbsp;
<i>// finito</i>
</pre>

<p>Povšimněte si, že přesnost výpočtů je poměrně velká, například pro vektor
<i>(6,8)</i> je prakticky přesně vypočtena délka 10:</p>

<table>
<tr><th>d(x,y)</th><th> 0,00</th><th> 1,00</th><th> 2,00</th><th> 3,00</th><th> 4,00</th><th> 5,00</th><th> 6,00</th><th> 7,00</th><th> 8,00</th><th> 9,00</th><th>10,00</th></tr>
<tr><th> 0,00</th><td> 0,00</td><td> 1,00</td><td> 2,00</td><td> 3,00</td><td> 4,00</td><td> 5,00</td><td> 6,00</td><td> 7,00</td><td> 8,00</td><td> 9,00</td><td>10,00</td></tr>
<tr><th> 1,00</th><td> 1,00</td><td> 1,41</td><td> 2,24</td><td> 3,16</td><td> 4,12</td><td> 5,10</td><td> 6,08</td><td> 7,07</td><td> 8,06</td><td> 9,06</td><td>10,05</td></tr>
<tr><th> 2,00</th><td> 2,00</td><td> 2,24</td><td> 2,83</td><td> 3,61</td><td> 4,47</td><td> 5,39</td><td> 6,33</td><td> 7,28</td><td> 8,25</td><td> 9,22</td><td>10,20</td></tr>
<tr><th> 3,00</th><td> 3,00</td><td> 3,16</td><td> 3,61</td><td> 4,24</td><td> 5,00</td><td> 5,83</td><td> 6,71</td><td> 7,62</td><td> 8,54</td><td> 9,49</td><td>10,44</td></tr>
<tr><th> 4,00</th><td> 4,00</td><td> 4,12</td><td> 4,47</td><td> 5,00</td><td> 5,66</td><td> 6,40</td><td> 7,21</td><td> 8,06</td><td> 8,94</td><td> 9,85</td><td>10,77</td></tr>
<tr><th> 5,00</th><td> 5,00</td><td> 5,10</td><td> 5,39</td><td> 5,83</td><td> 6,40</td><td> 7,07</td><td> 7,81</td><td> 8,60</td><td> 9,43</td><td>10,30</td><td>11,18</td></tr>
<tr><th> 6,00</th><td> 6,00</td><td> 6,08</td><td> 6,33</td><td> 6,71</td><td> 7,21</td><td> 7,81</td><td> 8,49</td><td> 9,22</td><td>10,00</td><td>10,82</td><td>11,66</td></tr>
<tr><th> 7,00</th><td> 7,00</td><td> 7,07</td><td> 7,28</td><td> 7,62</td><td> 8,06</td><td> 8,60</td><td> 9,22</td><td> 9,90</td><td>10,63</td><td>11,40</td><td>12,21</td></tr>
<tr><th> 8,00</th><td> 8,00</td><td> 8,06</td><td> 8,25</td><td> 8,54</td><td> 8,94</td><td> 9,43</td><td>10,00</td><td>10,63</td><td>11,31</td><td>12,04</td><td>12,81</td></tr>
<tr><th> 9,00</th><td> 9,00</td><td> 9,06</td><td> 9,22</td><td> 9,49</td><td> 9,85</td><td>10,30</td><td>10,82</td><td>11,40</td><td>12,04</td><td>12,73</td><td>13,45</td></tr>
<tr><th>10,00</th><td>10,00</td><td>10,05</td><td>10,20</td><td>10,44</td><td>10,77</td><td>11,18</td><td>11,66</td><td>12,21</td><td>12,81</td><td>13,45</td><td>14,14</td></tr>
</table>



<p><a name="k04"></a></p>
<h2 id="k04">4. Výpočet logaritmu algoritmem CORDIC</h2>

<p>Algoritmus CORDIC ve své prapůvodní podobě pracoval na principu rotace
vektoru v&nbsp;běžném L2 prostoru. Díky tomu bylo možné počítat goniometrické
funkce, délky vektorů atd. Ovšem například výpočty hyperbolických funkcí nebo
logaritmů vyžadují více či méně podstatné úpravy algoritmu, které spočívají
v&nbsp;tom, že se (snadno pochopitelné) rotace nahradí odlišnými operacemi.
Ovšem princip činnosti CORDICu zůstává stále stejný &ndash; máme
k&nbsp;dispozici předpočítanou tabulku hodnot (původně úhlů) vypočtenou tak,
aby jeden sloupec obsahoval mocniny dvou nebo podobné velmi snadno spočitatelné
hodnoty. A snažíme se vektorem postupně &bdquo;otočit&ldquo; tak, aby jedna
z&nbsp;jeho složek byla nulová. Ze druhé složky je poté odvozena výsledná
hodnota.</p>

<p>Pro zajímavost se podívejme na způsob výpočtu hodnoty přirozeného logaritmu
(se základem <i>e</i>), opět s&nbsp;využitím upraveného algoritmu CORDIC. Sice
se jedná o výpočet odlišný od (například) výpočtu goniometrických funkcí, ovšem
původní myšlenka s&nbsp;postupnými rotacemi zůstává zachována (dokonce i včetně
úpravy výsledné hodnoty vynásobením konstantou log(2)):</p>

<pre>
<i>// výpočet logaritmu algoritmem CORDIC</i>
double <strong>log_cordic</strong>(double a)
{
    const double three_eigth = 0.375;
    int sk, expo;
    double sum = tabm[0];
    double x = 2.0 * frexpf (a, &amp;expo);
    double ex2 = 1.0; <i>// dvojková mocnina</i>
    int k;
&nbsp;
    for (k = 0; k &lt; MAXITER; k++) {
        sk = 0;
        <i>// zjistit směr rotace</i>
        if ((x - 1.0) &lt;  (-three_eigth * ex2)) {
            sk = +1;
        }
        if ((x - 1.0) &gt;= (+three_eigth * ex2)) {
            sk = -1;
        }
        ex2 /= 2.0;
        if (sk == 1) { <i>// přímá rotace</i>
            x = x + x * ex2;
            sum = sum - tabp [k];
        } 
        if (sk == -1) { <i>// opačná rotace</i>
            x = x - x * ex2;
            sum = sum - tabm [k];
        }
    }
    return expo * K + sum; <i>// přepočet logaritmu</i>
}
</pre>

<p>Povšimněte si, že tento výpočet závisí na dvojici tabulek
<strong>tabm</strong> a <strong>tabp</strong>. Jejich obsah je možné vypočítat
buď při inicializaci programu, nebo může program obsahovat již předpočtené
hodnoty (viz například <a
href="https://stackoverflow.com/questions/77088843/problems-with-cordic-for-logarithm-in-c">Problems
with CORDIC for Logarithm in C</a>):</p>

<pre>
<i>// ln(1+2*(-i))</i>
double <strong>tabp</strong>[MAXITER] =
{ 
    0.40546510810816,
    0.22314355131421,
    0.11778303565638,
    0.06062462181643,
    0.03077165866675,
    0.01550418653597,
    0.00778214044205,
    0.00389864041566,
    0.00195122013126,
    0.00097608597306,
};
&nbsp;
<i>// ln(1-2*(-i))</i>
double <strong>tabm</strong>[MAXITER] =
{
    -0.69314718055995,
    -0.28768207245178,
    -0.13353139262452,
    -0.06453852113757,
    -0.03174869831458,
    -0.01574835696814,
    -0.00784317746103,
    -0.00391389932114,
    -0.00195503483580,
    -0.00097703964783,
};
</pre>



<p><a name="k05"></a></p>
<h2 id="k05">5. Druhý demonstrační příklad: výpočet přirozeného logaritmu</h2>

<p>Úplný zdrojový kód dnešního druhého demonstračního příkladu vypadá
následovně:</p>

<pre>
<i>//</i> --------------------------------------------------------
<i>//</i> Výpočet hodnot funkce log() pomocí iteračního
<i>//</i> algoritmu CORDIC.
<i>//</i> --------------------------------------------------------
&nbsp;
#include &lt;math.h&gt;
#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;
&nbsp;
<i>//</i> maximální počet iterací při běhu algoritmu
#define MAXITER 10
&nbsp;
<i>//</i> "zesílení" při rotacích (odpovídá ln(2))
#define K 0.69314718056
&nbsp;
<i>//</i> ln(1+2*(-i))
double <strong>tabp</strong>[MAXITER] =
{ 
    0.40546510810816,
    0.22314355131421,
    0.11778303565638,
    0.06062462181643,
    0.03077165866675,
    0.01550418653597,
    0.00778214044205,
    0.00389864041566,
    0.00195122013126,
    0.00097608597306,
};
&nbsp;
<i>//</i> ln(1-2*(-i))
double <strong>tabm</strong>[MAXITER] =
{
    -0.69314718055995,
    -0.28768207245178,
    -0.13353139262452,
    -0.06453852113757,
    -0.03174869831458,
    -0.01574835696814,
    -0.00784317746103,
    -0.00391389932114,
    -0.00195503483580,
    -0.00097703964783,
};
&nbsp;
<i>//</i> výpočet logaritmu algoritmem CORDIC
double <strong>log_cordic</strong>(double a)
{
    const double three_eigth = 0.375;
    int sk, expo;
    double sum = tabm[0];
    double x = 2.0 * frexpf (a, &amp;expo);
    double ex2 = 1.0; <i>//</i> dvojková mocnina
    int k;
&nbsp;
    for (k = 0; k &lt; MAXITER; k++) {
        sk = 0;
        <i>//</i> zjistit směr rotace
        if ((x - 1.0) &lt;  (-three_eigth * ex2)) {
            sk = +1;
        }
        if ((x - 1.0) &gt;= (+three_eigth * ex2)) {
            sk = -1;
        }
        ex2 /= 2.0;
        if (sk == 1) { <i>//</i> přímá rotace
            x = x + x * ex2;
            sum = sum - tabp [k];
        } 
        if (sk == -1) { <i>//</i> opačná rotace
            x = x - x * ex2;
            sum = sum - tabm [k];
        }
    }
    return expo * K + sum; <i>//</i> přepočet logaritmu
}
&nbsp;
&nbsp;
int <strong>main</strong>(void) {
    double a = M_E - 2.0; <i>//</i> "pěkná" počáteční hodnota
&nbsp;
    for (; a&lt;=2.0*M_E; a+=0.1) {
        double log_value = log_cordic(a);
        double log_correct = log(a);
        double log_error = fabs(log_correct - log_value);
        <i>//</i> tisk výsledků
        printf("%5.3f\t%12.10f\t%12.10f\t%8.3f%%\n",
               a,
               log_value,
               log_error,
               (log_value != 0.0) ? 100.0 * log_error / fabs(log_value) : 0.0);
    }
    return 0;
}
&nbsp;
<i>//</i> finito
</pre>



<p><a name="k06"></a></p>
<h2 id="k06">6. Výsledky získané předchozím příkladem</h2>

<p>Po spuštění demonstračního příkladu uvedeného <a
href="#k05">v&nbsp;předchozí kapitole</a> získáme tabulku se vstupními
hodnotami <i>x</i> (v&nbsp;rozsahu od e-2 do 2e), vypočtené přirozené logaritmy
vstupních hodnot, absolutní chybu i chybu relativní:</p>

<table>
<tr><th>x</th><th>log(x)</th><th>absolutní chyba</th><th>relativní chyba</th></tr>
<tr><td>0.718</td><td>-0.3311283747</td><td>0.0002351065</td><td>   0.071%</td></tr>
<tr><td>0.818</td><td>-0.2007169448</td><td>0.0001684767</td><td>   0.084%</td></tr>
<tr><td>0.918</td><td>-0.0855043232</td><td>0.0002533904</td><td>   0.296%</td></tr>
<tr><td>1.018</td><td>0.0177033937</td><td>0.0004133313</td><td>   2.335%</td></tr>
<tr><td>1.118</td><td>0.1122001024</td><td>0.0004066767</td><td>   0.362%</td></tr>
<tr><td>1.218</td><td>0.1972628335</td><td>0.0001786953</td><td>   0.091%</td></tr>
<tr><td>1.318</td><td>0.2760012935</td><td>0.0003279501</td><td>   0.119%</td></tr>
<tr><td>1.418</td><td>0.3492932894</td><td>0.0001528696</td><td>   0.044%</td></tr>
<tr><td>1.518</td><td>0.4172221868</td><td>0.0003571327</td><td>   0.086%</td></tr>
<tr><td>1.618</td><td>0.4817607079</td><td>0.0003957212</td><td>   0.082%</td></tr>
<tr><td>1.718</td><td>0.5406938477</td><td>0.0006310069</td><td>   0.117%</td></tr>
<tr><td>1.818</td><td>0.5978522616</td><td>0.0000397433</td><td>   0.007%</td></tr>
<tr><td>1.918</td><td>0.6516717826</td><td>0.0002418782</td><td>   0.037%</td></tr>
<tr><td>2.018</td><td>0.7019674015</td><td>0.0002791680</td><td>   0.040%</td></tr>
<tr><td>2.118</td><td>0.7499035651</td><td>0.0007017367</td><td>   0.094%</td></tr>
<tr><td>2.218</td><td>0.7968839580</td><td>0.0001510129</td><td>   0.019%</td></tr>
<tr><td>2.318</td><td>0.8404757138</td><td>0.0003506063</td><td>   0.042%</td></tr>
<tr><td>2.418</td><td>0.8826278755</td><td>0.0004294242</td><td>   0.049%</td></tr>
<tr><td>2.518</td><td>0.9241185343</td><td>0.0005416794</td><td>   0.059%</td></tr>
<tr><td>2.618</td><td>0.9623977642</td><td>0.0001205478</td><td>   0.013%</td></tr>
<tr><td>2.718</td><td>1.0004915131</td><td>0.0004915131</td><td>   0.049%</td></tr>
<tr><td>2.818</td><td>1.0366095515</td><td>0.0004821330</td><td>   0.047%</td></tr>
<tr><td>2.918</td><td>1.0707784472</td><td>0.0002165810</td><td>   0.020%</td></tr>
<tr><td>3.018</td><td>1.1044812266</td><td>0.0002065119</td><td>   0.019%</td></tr>
<tr><td>3.118</td><td>1.1372700939</td><td>0.0000120602</td><td>   0.001%</td></tr>
<tr><td>3.218</td><td>1.1690197478</td><td>0.0001721243</td><td>   0.015%</td></tr>
<tr><td>3.318</td><td>1.2001045670</td><td>0.0006574396</td><td>   0.055%</td></tr>
<tr><td>3.418</td><td>1.2289814442</td><td>0.0001565913</td><td>   0.013%</td></tr>
<tr><td>3.518</td><td>1.2578018827</td><td>0.0001708708</td><td>   0.014%</td></tr>
<tr><td>3.618</td><td>1.2862147211</td><td>0.0002154409</td><td>   0.017%</td></tr>
<tr><td>3.718</td><td>1.3131033699</td><td>0.0001583176</td><td>   0.012%</td></tr>
<tr><td>3.818</td><td>1.3400185197</td><td>0.0002179814</td><td>   0.016%</td></tr>
<tr><td>3.918</td><td>1.3659154520</td><td>0.0002622034</td><td>   0.019%</td></tr>
<tr><td>4.018</td><td>1.3902082662</td><td>0.0006461393</td><td>   0.046%</td></tr>
<tr><td>4.118</td><td>1.4160918450</td><td>0.0006558006</td><td>   0.046%</td></tr>
<tr><td>4.218</td><td>1.4391521071</td><td>0.0002757884</td><td>   0.019%</td></tr>
<tr><td>4.318</td><td>1.4626826045</td><td>0.0001749937</td><td>   0.012%</td></tr>
<tr><td>4.418</td><td>1.4851554604</td><td>0.0005954335</td><td>   0.040%</td></tr>
<tr><td>4.518</td><td>1.5081449786</td><td>0.0000131835</td><td>   0.001%</td></tr>
<tr><td>4.618</td><td>1.5296239718</td><td>0.0003987656</td><td>   0.026%</td></tr>
<tr><td>4.718</td><td>1.5515744578</td><td>0.0001297438</td><td>   0.008%</td></tr>
<tr><td>4.818</td><td>1.5719417606</td><td>0.0004756368</td><td>   0.030%</td></tr>
<tr><td>4.918</td><td>1.5929729045</td><td>0.0000136569</td><td>   0.001%</td></tr>
<tr><td>5.018</td><td>1.6133518175</td><td>0.0002642076</td><td>   0.016%</td></tr>
<tr><td>5.118</td><td>1.6334714200</td><td>0.0006526177</td><td>   0.040%</td></tr>
<tr><td>5.218</td><td>1.6526451471</td><td>0.0004769511</td><td>   0.029%</td></tr>
<tr><td>5.318</td><td>1.6710491332</td><td>0.0001011534</td><td>   0.006%</td></tr>
<tr><td>5.418</td><td>1.6897247963</td><td>0.0000539631</td><td>   0.003%</td></tr>
</table>

<p><div class="rs-tip-major">Poznámka: povšimněte si, že největší relativní
chyba byla vypočtena pro hodnoty v&nbsp;blízkosti nuly, což je logické &ndash;
zde se každá odchylka dělí velmi malou hodnotou, takže (relativně) se bude
jednat o velkou chybu. Ovšem stále se nacházíme v&nbsp;řádu procent, což je na
tak jednoduchý algoritmus velmi dobrý výsledek.</div></p>



<p><a name="k07"></a></p>
<h2 id="k07">7. Algoritmus CORDIC s&nbsp;hodnotami uloženými ve formátu pevné řádové binární čárky</h2>

<p>Hlavním tématem dnešního článku je přepis algoritmu CORDIC do podoby, ve
které se již nepoužije matematický koprocesor (a tedy ani datové typy
<i>float</i> či <i>double</i>), ale výpočty budou probíhat na běžné celočíselné
aritmeticko-logické jednotce.</p>

<p>Před vlastním uvedením implementace algoritmu CORDIC s&nbsp;čísly uloženými
ve formátu pevné řádové binární čárky je zapotřebí provést náležitou přípravu,
protože formát FX (většinou) není ani mikroprocesory ani překladači podporován.
Z&nbsp;tohoto důvodu si v&nbsp;této kapitole pro připomenutí uvedeme všechny
základní aritmetické funkce určené pro práci s&nbsp;formátem FX. Jedná se o
funkce <strong>fx_add()</strong>, <strong>fx_sub()</strong>,
<strong>fx_mul()</strong> a <strong>fx_div()</strong> (tyto funkce byly
podrobněji vysvětleny v&nbsp;předchozím díle). Kromě toho jsou uvedena i těla
dalších pomocných funkcí, zejména <strong>fx_print()</strong> i maker určených
pro převod stupňů na radiány a naopak. Pomocí konstant <strong>A</strong> a
<strong>B</strong> je určen rozsah a přesnost numerických hodnot uložených ve
formátu <strong>fx</strong> &ndash; ten je v&nbsp;naší implementaci shodný
s&nbsp;třicetidvoubitovým datovým typem <strong>signed int</strong>, jelikož
potřebujeme pracovat jak s&nbsp;kladnými, tak i se zápornými hodnotami.</p>

<pre>
#include &lt;stdlib.h&gt;
#include &lt;stdio.h&gt;
#include &lt;math.h&gt;
&nbsp;
<i>/* počet míst před a za binární řádovou tečkou */</i>
#define <strong>A</strong> 16
#define <strong>B</strong> 16
&nbsp;
<i>/* Ludolfovo číslo */</i>
#ifndef <strong>M_PI</strong>
#define <strong>M_PI</strong> 3.14159265358979323846
#endif
&nbsp;
<i>/* maximální počet iterací při běhu algoritmu */</i>
#define <strong>MAX_ITER</strong> 16
&nbsp;
<i>/* "zesílení" při rotacích */</i>
#define <strong>K</strong> 0.6073
&nbsp;
<i>/* převody mezi stupni a radiány */</i>
#define <strong>rad2deg</strong>(rad) ((rad)*180.0/M_PI)
#define <strong>deg2rad</strong>(deg) ((deg)/180.0*M_PI)
&nbsp;
<i>/* datový typ, se kterým budeme pracovat */</i>
typedef signed int fx;
&nbsp;
<i>/* hlavičky použitých funkcí */</i>
void   <strong>fx_print</strong>(fx x);
fx     <strong>fp2fx</strong>(double x);
double <strong>fx2fp</strong>(fx x);
&nbsp;
<i>/* tabulka arkustangentu úhlů */</i>
fx <strong>atans</strong>[MAX_ITER];
&nbsp;
<i>/* tabulka záporných celočíselných mocnin hodnoty 2 */</i>
fx <strong>pows</strong>[MAX_ITER];
&nbsp;
<i>/*</i>
<i> * Tisk numerické hodnoty uložené ve formátu pevné</i>
<i> * řádové binární čárky (FX)</i>
<i> */</i>
void <strong>fx_print</strong>(fx x)
{
    int i;
    int val=x;                         <i>/* pomocná proměnná pro převod do dvojkové soustavy */</i>
    printf("bin: ");
    for (i=0; i&lt;A+B; i++) {            <i>/* převod na řetězec bitů (do dvojkové soustavy) */</i>
        putchar(!!(val &amp; (1&lt;&lt;(A+B-1)))+'0'); <i>/* výpis hodnoty aktuálně nejvyššího bitu */</i>
        if (i==B-1) putchar('.');      <i>/* po řádové binární čárce vypsat značku */</i>
        val=val&lt;&lt;1;                    <i>/* posun na další (méně významný) bit */</i>
    }
&nbsp;
    printf("   hex: %08x   fp: %+11.5f\n", x, fx2fp(x));
}
&nbsp;
<i>/*</i>
<i> * Převod z formátu plovoucí řádové binární čárky (FP)</i>
<i> * do formátu pevné řádové binární čárky (FX)</i>
<i> */</i>
fx <strong>fp2fx</strong>(double x)
{
    return (fx)(x*(2&lt;&lt;(B-1)));
}
&nbsp;
<i>/*</i>
<i> * Převod z celočíselného formátu (integer)</i>
<i> * do formátu pevné řádové binární čárky (FX)</i>
<i> */</i>
fx <strong>int2fx</strong>(int x)
{
    return (fx)(x&lt;&lt;B);
}
&nbsp;
<i>/*</i>
<i> * Převod z formátu pevné řádové binární čárky (FX)</i>
<i> * do formátu plovoucí řádové binární čárky (FP)</i>
<i> */</i>
double <strong>fx2fp</strong>(fx x)
{
    return (double)x/(2&lt;&lt;(B-1));
}
&nbsp;
<i>/*</i>
<i> * Součet dvou hodnot uložených ve shodném formátu</i>
<i> * pevné binární řádové čárky (FX)</i>
<i> */</i>
fx <strong>fx_add</strong>(fx x, fx y)
{
    return x+y;
}
&nbsp;
<i>/*</i>
<i> * Rozdíl dvou hodnot uložených ve shodném formátu</i>
<i> * pevné binární řádové čárky (FX)</i>
<i> */</i>
fx <strong>fx_sub</strong>(fx x, fx y)
{
    return x-y;
}
&nbsp;
<i>/*</i>
<i> * Součin dvou hodnot uložených ve shodném formátu</i>
<i> * pevné binární řádové čárky (FX)</i>
<i> */</i>
fx <strong>fx_mul</strong>(fx x, fx y)
{
    fx result=(x&gt;&gt;(B/2))*(y&gt;&gt;(B/2));
    return result;
}
&nbsp;
<i>/*</i>
<i> * Podíl dvou hodnot uložených ve shodném formátu</i>
<i> * pevné binární řádové čárky (FX)</i>
<i> */</i>
fx <strong>fx_div</strong>(fx x, fx y)
{
    fx result=x/(y&gt;&gt;(B/2));
    return result&lt;&lt;(B/2);
}
</pre>



<p><a name="k08"></a></p>
<h2 id="k08">8. Realizace funkce určené pro naplnění tabulky <strong>atans</strong>[] (arkustangenty vhodně zvolených úhlů)</h2>

<p>Podobně jako při implementaci algoritmu CORDIC pro hodnoty ve formátu FP
(tedy s&nbsp;plovoucí řádovou čárkou), i v&nbsp;případě práce s&nbsp;formátem
FX je nutné některé hodnoty předpočítat. Opět se jedná o tabulku
<strong>atans[]</strong> obsahující arkustangenty vybraných úhlů. Kromě toho
naplníme i tabulku <strong>pows[]</strong>, ve které jsou uloženy záporné
mocniny čísla 2. Jak však uvidíme v&nbsp;dalším textu, není v&nbsp;případě FX
výpočtů tato tabulka využita a algoritmus CORDIC se z&nbsp;tohoto důvodu
poněkud zjednoduší. Funkce pro výpočet obou zmiňovaných tabulek vypadá
následovně:</p>

<pre>
<i>/*</i>
<i> * Vytvoření tabulky pro výpočet goniometrických</i>
<i> * funkcí pomocí algoritmu CORDIC</i>
<i> */</i>
void <strong>fx_create_tables</strong>(void)
{
    int i;
    for (i=0; i&lt;MAX_ITER; i++) {
        double p=pow(2.0, -i);
        atans[i]=fp2fx(atan(p));
        pows[i]=fp2fx(p);
    }
}
</pre>

<p>To, zda je tabulka korektně naplněna, je možné otestovat velmi
jednoduše:</p>

<pre>
    <i>/* kontrolní výpis tabulky atans[] */</i>
    for (i=0; i&lt;MAX_ITER; i++)
        printf("%d\t%f\n", i, fx2fp(rad2deg(atans[i])));

</pre>

<p>Výsledkem běhu předchozího testu je tabulka hodnot arkustangent úhlů
(zhruba) odpovídajících FP verzi:</p>

<table>
<tr><th>Index</th><th>Hodnota úhlu</th></tr>
<tr><td> 0</td><td>44.999252</td></tr>
<tr><td> 1</td><td>26.564514</td></tr>
<tr><td> 2</td><td>14.035431</td></tr>
<tr><td> 3</td><td> 7.124374</td></tr>
<tr><td> 4</td><td> 3.575729</td></tr>
<tr><td> 5</td><td> 1.789612</td></tr>
<tr><td> 6</td><td> 0.894363</td></tr>
<tr><td> 7</td><td> 0.446747</td></tr>
<tr><td> 8</td><td> 0.222931</td></tr>
<tr><td> 9</td><td> 0.111023</td></tr>
<tr><td>10</td><td> 0.055069</td></tr>
<tr><td>11</td><td> 0.027100</td></tr>
<tr><td>12</td><td> 0.013107</td></tr>
<tr><td>13</td><td> 0.006119</td></tr>
<tr><td>14</td><td> 0.002609</td></tr>
<tr><td>15</td><td> 0.000870</td></tr>
</table>

<p>S&nbsp;takto připravenou tabulkou je možné pokračovat v&nbsp;dalších
výpočtech.</p>



<p><a name="k09"></a></p>
<h2 id="k09">9. </h2>



<p><a name="k10"></a></p>
<h2 id="k10">10. </h2>



<p><a name="k11"></a></p>
<h2 id="k11">11. </h2>



<p><a name="k12"></a></p>
<h2 id="k12">12. </h2>



<p><a name="k13"></a></p>
<h2 id="k13">13. </h2>



<p><a name="k14"></a></p>
<h2 id="k14">14. </h2>



<p><a name="k15"></a></p>
<h2 id="k15">15. </h2>



<p><a name="k16"></a></p>
<h2 id="k16">16. </h2>



<p><a name="k17"></a></p>
<h2 id="k17">17. </h2>



<p><a name="k18"></a></p>
<h2 id="k18">18. Repositář s&nbsp;demonstračními příklady</h2>

<table>
<tr><th> #</th><th>Příklad</th><th>Stručný popis</th><th>Adresa</th></tr>
<tr><td> 1</td><td>hello.asm</td><td>program typu &bdquo;Hello world&ldquo; naprogramovaný v&nbsp;assembleru pro systém DOS</td><td><a href="https://github.com/tisnik/8bit-fame/blob/master/pc-dos/hello.asm">https://github.com/tisnik/8bit-fame/blob/master/pc-dos/hello.asm</a></td></tr>
<tr><td> 2</td><td>hello_shorter.asm</td><td>kratší varianta výskoku z&nbsp;procesu zpět do DOSu</td><td><a href="https://github.com/tisnik/8bit-fame/blob/master/pc-dos/hello_shorter.asm">https://github.com/tisnik/8bit-fame/blob/master/pc-dos/hello_shorter.asm</a></td></tr>
<tr><td> 3</td><td>hello_wait.asm</td><td>čekání na stisk klávesy</td><td><a href="https://github.com/tisnik/8bit-fame/blob/master/pc-dos/hello_wait.asm">https://github.com/tisnik/8bit-fame/blob/master/pc-dos/hello_wait.asm</a></td></tr>
<tr><td> 4</td><td>hello_macros.asm</td><td>realizace jednotlivých částí programu makrem</td><td><a href="https://github.com/tisnik/8bit-fame/blob/master/pc-dos/hello_macros.asm">https://github.com/tisnik/8bit-fame/blob/master/pc-dos/hello_macros.asm</a></td></tr>
<tr><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td></tr>
<tr><td> 5</td><td>gfx_4_putpixel.asm</td><td>vykreslení pixelu v&nbsp;grafickém režimu 4</td><td><a href="https://github.com/tisnik/8bit-fame/blob/master/pc-dos/gfx_4_putpixel.asm">https://github.com/tisnik/8bit-fame/blob/master/pc-dos/gfx_4_putpixel.asm</a></td></tr>
<tr><td> 6</td><td>gfx_6_putpixel.asm</td><td>vykreslení pixelu v&nbsp;grafickém režimu 6</td><td><a href="https://github.com/tisnik/8bit-fame/blob/master/pc-dos/gfx_6_putpixel.asm">https://github.com/tisnik/8bit-fame/blob/master/pc-dos/gfx_6_putpixel.asm</a></td></tr>
<tr><td> 7</td><td>gfx_4_line.asm</td><td>vykreslení úsečky v&nbsp;grafickém režimu 4</td><td><a href="https://github.com/tisnik/8bit-fame/blob/master/pc-dos/gfx_4_line.asm">https://github.com/tisnik/8bit-fame/blob/master/pc-dos/gfx_4_line.asm</a></td></tr>
<tr><td> 8</td><td>gfx_6_line.asm</td><td>vykreslení úsečky v&nbsp;grafickém režimu 6</td><td><a href="https://github.com/tisnik/8bit-fame/blob/master/pc-dos/gfx_6_line.asm">https://github.com/tisnik/8bit-fame/blob/master/pc-dos/gfx_6_line.asm</a></td></tr>
<tr><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td></tr>
<tr><td> 9</td><td>gfx_6_fill_1.asm</td><td>vyplnění obrazovky v&nbsp;grafickém režimu, základní varianta</td><td><a href="https://github.com/tisnik/8bit-fame/blob/master/pc-dos/gfx_6_fill_1.asm">https://github.com/tisnik/8bit-fame/blob/master/pc-dos/gfx_6_fill_1.asm</a></td></tr>
<tr><td>10</td><td>gfx_6_fill_2.asm</td><td>vyplnění obrazovky v&nbsp;grafickém režimu, varianta s&nbsp;instrukcí <strong>LOOP</strong></td><td><a href="https://github.com/tisnik/8bit-fame/blob/master/pc-dos/gfx_6_fill_2.asm">https://github.com/tisnik/8bit-fame/blob/master/pc-dos/gfx_6_fill_2.asm</a></td></tr>
<tr><td>11</td><td>gfx_6_fill_3.asm</td><td>vyplnění obrazovky instrukcí <strong>REP STOSB</strong></td><td><a href="https://github.com/tisnik/8bit-fame/blob/master/pc-dos/gfx_6_fill_3.asm">https://github.com/tisnik/8bit-fame/blob/master/pc-dos/gfx_6_fill_3.asm</a></td></tr>
<tr><td>12</td><td>gfx_6_fill_4.asm</td><td>vyplnění obrazovky, synchronizace vykreslování s&nbsp;paprskem</td><td><a href="https://github.com/tisnik/8bit-fame/blob/master/pc-dos/gfx_6_fill_4.asm">https://github.com/tisnik/8bit-fame/blob/master/pc-dos/gfx_6_fill_4.asm</a></td></tr>
<tr><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td></tr>
<tr><td>13</td><td>gfx_4_image_1.asm</td><td>vykreslení rastrového obrázku získaného z&nbsp;binárních dat, základní varianta</td><td><a href="https://github.com/tisnik/8bit-fame/blob/master/pc-dos/gfx_4_image_1.asm">https://github.com/tisnik/8bit-fame/blob/master/pc-dos/gfx_4_image_1.asm</a></td></tr>
<tr><td>14</td><td>gfx_4_image_2.asm</td><td>varianta vykreslení rastrového obrázku s&nbsp;využitím instrukce <strong>REP MOVSB</strong></td><td><a href="https://github.com/tisnik/8bit-fame/blob/master/pc-dos/gfx_4_image_2.asm">https://github.com/tisnik/8bit-fame/blob/master/pc-dos/gfx_4_image_2.asm</a></td></tr>
<tr><td>15</td><td>gfx_4_image_3.asm</td><td>varianta vykreslení rastrového obrázku s&nbsp;využitím instrukce <strong>REP MOVSW</strong></td><td><a href="https://github.com/tisnik/8bit-fame/blob/master/pc-dos/gfx_4_image_3.asm">https://github.com/tisnik/8bit-fame/blob/master/pc-dos/gfx_4_image_3.asm</a></td></tr>
<tr><td>16</td><td>gfx_4_image_4.asm</td><td>korektní vykreslení všech sudých řádků bitmapy</td><td><a href="https://github.com/tisnik/8bit-fame/blob/master/pc-dos/gfx_4_image_4.asm">https://github.com/tisnik/8bit-fame/blob/master/pc-dos/gfx_4_image_4.asm</a></td></tr>
<tr><td>17</td><td>gfx_4_image_5.asm</td><td>korektní vykreslení všech sudých i lichých řádků bitmapy</td><td><a href="https://github.com/tisnik/8bit-fame/blob/master/pc-dos/gfx_4_image_5.asm">https://github.com/tisnik/8bit-fame/blob/master/pc-dos/gfx_4_image_5.asm</a></td></tr>
<tr><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td></tr>
<tr><td>18</td><td>gfx_4_image_6.asm</td><td>nastavení barvové palety před vykreslením obrázku</td><td><a href="https://github.com/tisnik/8bit-fame/blob/master/pc-dos/gfx_4_image_6.asm">https://github.com/tisnik/8bit-fame/blob/master/pc-dos/gfx_4_image_6.asm</a></td></tr>
<tr><td>19</td><td>gfx_4_image_7.asm</td><td>nastavení barvové palety před vykreslením obrázku, snížená intenzita barev</td><td><a href="https://github.com/tisnik/8bit-fame/blob/master/pc-dos/gfx_4_image_7.asm">https://github.com/tisnik/8bit-fame/blob/master/pc-dos/gfx_4_image_7.asm</a></td></tr>
<tr><td>20</td><td>gfx_4_image_8.asm</td><td>postupná změna barvy pozadí</td><td><a href="https://github.com/tisnik/8bit-fame/blob/master/pc-dos/gfx_4_image_8.asm">https://github.com/tisnik/8bit-fame/blob/master/pc-dos/gfx_4_image_8.asm</a></td></tr>
<tr><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td></tr>
<tr><td>21</td><td>gfx_6_putpixel_1.asm</td><td>vykreslení pixelu, základní varianta se 16bitovým násobením</td><td><a href="https://github.com/tisnik/8bit-fame/blob/master/pc-dos/gfx_6_putpixel_1.asm">https://github.com/tisnik/8bit-fame/blob/master/pc-dos/gfx_6_putpixel_1.asm</a></td></tr>
<tr><td>22</td><td>gfx_6_putpixel_2.asm</td><td>vykreslení pixelu, varianta s&nbsp;osmibitovým násobením</td><td><a href="https://github.com/tisnik/8bit-fame/blob/master/pc-dos/gfx_6_putpixel_2.asm">https://github.com/tisnik/8bit-fame/blob/master/pc-dos/gfx_6_putpixel_2.asm</a></td></tr>
<tr><td>23</td><td>gfx_6_putpixel_3.asm</td><td>vykreslení pixelu, varianta bez násobení</td><td><a href="https://github.com/tisnik/8bit-fame/blob/master/pc-dos/gfx_6_putpixel_3.asm">https://github.com/tisnik/8bit-fame/blob/master/pc-dos/gfx_6_putpixel_3.asm</a></td></tr>
<tr><td>24</td><td>gfx_6_putpixel_4.asm</td><td>vykreslení pixelu přes obrázek, nekorektní chování (přepis obrázku)</td><td><a href="https://github.com/tisnik/8bit-fame/blob/master/pc-dos/gfx_6_putpixel_4.asm">https://github.com/tisnik/8bit-fame/blob/master/pc-dos/gfx_6_putpixel_4.asm</a></td></tr>
<tr><td>25</td><td>gfx_6_putpixel_5.asm</td><td>vykreslení pixelu přes obrázek, korektní varianta pro bílé pixely</td><td><a href="https://github.com/tisnik/8bit-fame/blob/master/pc-dos/gfx_6_putpixel_5.asm">https://github.com/tisnik/8bit-fame/blob/master/pc-dos/gfx_6_putpixel_5.asm</a></td></tr>
<tr><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td></tr>
</table>



<p><a name="k19"></a></p>
<h2 id="k19">19. Literatura</h2>

<ol>

<li>Andraka, Ray: <i>"A survey of CORDIC algorithms for FPGA based computers"</i>,<br />ACM, 1998</li>

<li>Despain, A.M.:<i>"Fourier Transform Computations Using CORDIC Iterations"</i>,<br />IEEE Transactions on Computers, Volume 23, strany 993-1001, 1974</li>

<li>Mazenc C., Merrheim, X., Muller, J.M.: <i>"Computing Functions Arccos and Arcsin Using CORDIC"</i>,<br />IEEE Transactions on Computers, Volume 42, strany 118-122, 1993</li>

<li>Volder, Jack: <i>"Binary computation algorithms for coordinate rotation and function generation"</i>,<br />Convair Report IAR-1, 1956</li>

<li>Volder, Jack: <i>"The CORDIC Trigonometric Computing Technique"</i>,<br />IRE Transactions on Electronic Computing, Vol EC-8, strany 330-334, 1959</li>

<li>NVIDIA Corporation: <i>"Floating-Point Specials on the GPU"</i>,<br />2005</li>

<li>Grant R. Griffin: <i>CORDIC FAQ</i>,<br />
<a href="http://www.dspguru.com/info/faqs/cordic.htm">http://www.dspguru.com/info/faqs/cordic.htm</a></li>

<li>Andraka Consulting Group, Inc.: <i>What is all this CORDIC stuff anyhow?</i>,<br />
<a href="http://www.andraka.com/cordic.htm">http://www.andraka.com/cordic.htm</a></li>

<li>Cyliax Ingo: <i>CORDIC (COordinate Rotation DIgital Computer), the swiss army knife for computing math functions...</i><br />
<a href="http://www.ee.ualberta.ca/courses/ee401/microboard/cordic_CCink.html">http://www.ee.ualberta.ca/courses/ee401/microboard/cordic_CCink.html</a></li>

</ol>



<p><a name="k20"></a></p>
<h2 id="k20">20. Odkazy na Internetu</h2>

<ol>

<li>VESA BIOS Extensions<br />
<a href="https://en.wikipedia.org/wiki/VESA_BIOS_Extensions">https://en.wikipedia.org/wiki/VESA_BIOS_Extensions</a>
</li>

<li>Video Electronics Standards Association<br />
<a href="https://en.wikipedia.org/wiki/Video_Electronics_Standards_Association">https://en.wikipedia.org/wiki/Video_Electronics_Standards_Association</a>
</li>

<li>DJGPP (Wikipedia)<br />
<a href="https://cs.wikipedia.org/wiki/DJGPP">https://cs.wikipedia.org/wiki/DJGPP</a>
</li>

<li>DJGPP home page<br />
<a href="http://www.delorie.com/djgpp/">http://www.delorie.com/djgpp/</a>
</li>

<li>DJGPP Zip File Picker<br />
<a href="http://www.delorie.com/djgpp/zip-picker.html">http://www.delorie.com/djgpp/zip-picker.html</a>
</li>

<li>The Intel 8088 Architecture and Instruction Set<br />
<a href="https://people.ece.ubc.ca/~edc/464/lectures/lec4.pdf">https://people.ece.ubc.ca/~edc/464/lectures/lec4.pdf</a>
</li>

<li>x86 Opcode Structure and Instruction Overview<br />
<a href="https://pnx.tf/files/x86_opcode_structure_and_instruction_overview.pdf">https://pnx.tf/files/x86_opcode_structure_and_instruction_overview.pdf</a>
</li>

<li>x86 instruction listings (Wikipedia)<br />
<a href="https://en.wikipedia.org/wiki/X86_instruction_listings">https://en.wikipedia.org/wiki/X86_instruction_listings</a>
</li>

<li>x86 assembly language (Wikipedia)<br />
<a href="https://en.wikipedia.org/wiki/X86_assembly_language">https://en.wikipedia.org/wiki/X86_assembly_language</a>
</li>

<li>Intel Assembler (Cheat sheet)<br />
<a href="http://www.jegerlehner.ch/intel/IntelCodeTable.pdf">http://www.jegerlehner.ch/intel/IntelCodeTable.pdf</a>
</li>

<li>25 Microchips That Shook the World<br />
<a href="https://spectrum.ieee.org/tech-history/silicon-revolution/25-microchips-that-shook-the-world">https://spectrum.ieee.org/tech-history/silicon-revolution/25-microchips-that-shook-the-world</a>
</li>

<li>Chip Hall of Fame: MOS Technology 6502 Microprocessor<br />
<a href="https://spectrum.ieee.org/tech-history/silicon-revolution/chip-hall-of-fame-mos-technology-6502-microprocessor">https://spectrum.ieee.org/tech-history/silicon-revolution/chip-hall-of-fame-mos-technology-6502-microprocessor</a>
</li>

<li>Chip Hall of Fame: Intel 8088 Microprocessor<br />
<a href="https://spectrum.ieee.org/tech-history/silicon-revolution/chip-hall-of-fame-intel-8088-microprocessor">https://spectrum.ieee.org/tech-history/silicon-revolution/chip-hall-of-fame-intel-8088-microprocessor</a>
</li>

<li>Jak se zrodil procesor?<br />
<a href="https://www.root.cz/clanky/jak-se-zrodil-procesor/">https://www.root.cz/clanky/jak-se-zrodil-procesor/</a>
</li>

<li>Apple II History Home<br />
<a href="http://apple2history.org/">http://apple2history.org/</a>
</li>

<li>The 8086/8088 Primer<br />
<a href="https://www.stevemorse.org/8086/index.html">https://www.stevemorse.org/8086/index.html</a>
</li>

<li>flat assembler: Assembly language resources<br />
<a href="https://flatassembler.net/">https://flatassembler.net/</a>
</li>

<li>FASM na Wikipedii<br />
<a href="https://en.wikipedia.org/wiki/FASM">https://en.wikipedia.org/wiki/FASM</a>
</li>

<li>Fresh IDE FASM inside<br />
<a href="https://fresh.flatassembler.net/">https://fresh.flatassembler.net/</a>
</li>

<li>MS-DOS Version 4.0 Programmer's Reference<br />
<a href="https://www.pcjs.org/documents/books/mspl13/msdos/dosref40/">https://www.pcjs.org/documents/books/mspl13/msdos/dosref40/</a>
</li>

<li>DOS API (Wikipedia)<br />
<a href="https://en.wikipedia.org/wiki/DOS_API">https://en.wikipedia.org/wiki/DOS_API</a>
</li>

<li>Bit banging<br />
<a href="https://en.wikipedia.org/wiki/Bit_banging">https://en.wikipedia.org/wiki/Bit_banging</a>
</li>

<li>IBM Basic assembly language and successors (Wikipedia)<br />
<a href="https://en.wikipedia.org/wiki/IBM_Basic_assembly_language_and_successors">https://en.wikipedia.org/wiki/IBM_Basic_assembly_language_and_successors</a>
</li>

<li>X86 Assembly/Bootloaders<br />
<a href="https://en.wikibooks.org/wiki/X86_Assembly/Bootloaders">https://en.wikibooks.org/wiki/X86_Assembly/Bootloaders</a>
</li>

<li>Počátky grafiky na PC: grafické karty CGA a Hercules<br />
<a href="https://www.root.cz/clanky/pocatky-grafiky-na-pc-graficke-karty-cga-a-hercules/">https://www.root.cz/clanky/pocatky-grafiky-na-pc-graficke-karty-cga-a-hercules/</a>
</li>

<li>Co mají společného Commodore PET/4000, BBC Micro, Amstrad CPC i grafické karty MDA, CGA a Hercules?<br />
<a href="https://www.root.cz/clanky/co-maji-spolecneho-commodore-pet-4000-bbc-micro-amstrad-cpc-i-graficke-karty-mda-cga-a-hercules/">https://www.root.cz/clanky/co-maji-spolecneho-commodore-pet-4000-bbc-micro-amstrad-cpc-i-graficke-karty-mda-cga-a-hercules/</a>
</li>

<li>Karta EGA: první použitelná barevná grafika na PC<br />
<a href="https://www.root.cz/clanky/karta-ega-prvni-pouzitelna-barevna-grafika-na-pc/">https://www.root.cz/clanky/karta-ega-prvni-pouzitelna-barevna-grafika-na-pc/</a>
</li>

<li>RGB Classic Games<br />
<a href="https://www.classicdosgames.com/">https://www.classicdosgames.com/</a>
</li>

<li>Turbo Assembler (Wikipedia)<br />
<a href="https://en.wikipedia.org/wiki/Turbo_Assembler">https://en.wikipedia.org/wiki/Turbo_Assembler</a>
</li>

<li>Microsoft Macro Assembler<br />
<a href="https://en.wikipedia.org/wiki/Microsoft_Macro_Assembler">https://en.wikipedia.org/wiki/Microsoft_Macro_Assembler</a>
</li>

<li>IBM Personal Computer (Wikipedia)<br />
<a href="https://en.wikipedia.org/wiki/IBM_Personal_Computer">https://en.wikipedia.org/wiki/IBM_Personal_Computer</a>
</li>

<li>Intel 8251<br />
<a href="https://en.wikipedia.org/wiki/Intel_8251">https://en.wikipedia.org/wiki/Intel_8251</a>
</li>

<li>Intel 8253<br />
<a href="https://en.wikipedia.org/wiki/Intel_8253">https://en.wikipedia.org/wiki/Intel_8253</a>
</li>

<li>Intel 8255<br />
<a href="https://en.wikipedia.org/wiki/Intel_8255">https://en.wikipedia.org/wiki/Intel_8255</a>
</li>

<li>Intel 8257<br />
<a href="https://en.wikipedia.org/wiki/Intel_8257">https://en.wikipedia.org/wiki/Intel_8257</a>
</li>

<li>Intel 8259<br />
<a href="https://en.wikipedia.org/wiki/Intel_8259">https://en.wikipedia.org/wiki/Intel_8259</a>
</li>

<li>Support/peripheral/other chips - 6800 family<br />
<a href="http://www.cpu-world.com/Support/6800.html">http://www.cpu-world.com/Support/6800.html</a>
</li>

<li>Motorola 6845<br />
<a href="http://en.wikipedia.org/wiki/Motorola_6845">http://en.wikipedia.org/wiki/Motorola_6845</a>
</li>

<li>The 6845 Cathode Ray Tube Controller (CRTC)<br />
<a href="http://www.tinyvga.com/6845">http://www.tinyvga.com/6845</a>
</li>

<li>CRTC operation<br />
<a href="http://www.6502.org/users/andre/hwinfo/crtc/crtc.html">http://www.6502.org/users/andre/hwinfo/crtc/crtc.html</a>
</li>

<li>The 6845 Cathode Ray Tube Controller (CRTC)<br />
<a href="http://www.tinyvga.com/6845">http://www.tinyvga.com/6845</a>
</li>

<li>Motorola 6845 and bitwise graphics<br />
<a href="https://retrocomputing.stackexchange.com/questions/10996/motorola-6845-and-bitwise-graphics">https://retrocomputing.stackexchange.com/questions/10996/motorola-6845-and-bitwise-graphics</a>
</li>

<li>IBM Monochrome Display Adapter<br />
<a href="http://en.wikipedia.org/wiki/Monochrome_Display_Adapter">http://en.wikipedia.org/wiki/Monochrome_Display_Adapter</a>
</li>

<li>Color Graphics Adapter<br />
<a href="http://en.wikipedia.org/wiki/Color_Graphics_Adapter">http://en.wikipedia.org/wiki/Color_Graphics_Adapter</a>
</li>

<li>Color Graphics Adapter and the Brown color in IBM 5153 Color Display<br />
<a href="https://www.aceinnova.com/en/electronics/cga-and-the-brown-color-in-ibm-5153-color-display/">https://www.aceinnova.com/en/electronics/cga-and-the-brown-color-in-ibm-5153-color-display/</a>
</li>

<li>The Modern Retrocomputer: An Arduino Driven 6845 CRT Controller<br />
<a href="https://hackaday.com/2017/05/14/the-modern-retrocomputer-an-arduino-driven-6845-crt-controller/">https://hackaday.com/2017/05/14/the-modern-retrocomputer-an-arduino-driven-6845-crt-controller/</a>
</li>

<li>flat assembler: Assembly language resources<br />
<a href="https://flatassembler.net/">https://flatassembler.net/</a>
</li>

<li>FASM na Wikipedii<br />
<a href="https://en.wikipedia.org/wiki/FASM">https://en.wikipedia.org/wiki/FASM</a>
</li>

<li>Fresh IDE FASM inside<br />
<a href="https://fresh.flatassembler.net/">https://fresh.flatassembler.net/</a>
</li>

<li>MS-DOS Version 4.0 Programmer's Reference<br />
<a href="https://www.pcjs.org/documents/books/mspl13/msdos/dosref40/">https://www.pcjs.org/documents/books/mspl13/msdos/dosref40/</a>
</li>

<li>DOS API (Wikipedia)<br />
<a href="https://en.wikipedia.org/wiki/DOS_API">https://en.wikipedia.org/wiki/DOS_API</a>
</li>

<li>IBM Basic assembly language and successors (Wikipedia)<br />
<a href="https://en.wikipedia.org/wiki/IBM_Basic_assembly_language_and_successors">https://en.wikipedia.org/wiki/IBM_Basic_assembly_language_and_successors</a>
</li>

<li>X86 Assembly/Arithmetic<br />
<a href="https://en.wikibooks.org/wiki/X86_Assembly/Arithmetic">https://en.wikibooks.org/wiki/X86_Assembly/Arithmetic</a>
</li>

<li>Art of Assembly - Arithmetic Instructions<br />
<a href="http://oopweb.com/Assembly/Documents/ArtOfAssembly/Volume/Chapter_6/CH06-2.html">http://oopweb.com/Assembly/Documents/ArtOfAssembly/Volume/Chapter_6/CH06-2.html</a>
</li>

<li>ASM Flags<br />
<a href="http://www.cavestory.org/guides/csasm/guide/asm_flags.html">http://www.cavestory.org/guides/csasm/guide/asm_flags.html</a>
</li>

<li>Status Register<br />
<a href="https://en.wikipedia.org/wiki/Status_register">https://en.wikipedia.org/wiki/Status_register</a>
</li>

<li>Linux assemblers: A comparison of GAS and NASM<br />
<a href="http://www.ibm.com/developerworks/library/l-gas-nasm/index.html">http://www.ibm.com/developerworks/library/l-gas-nasm/index.html</a>
</li>

<li>Programovani v assembleru na OS Linux<br />
<a href="http://www.cs.vsb.cz/grygarek/asm/asmlinux.html">http://www.cs.vsb.cz/grygarek/asm/asmlinux.html</a>
</li>

<li>Is it worthwhile to learn x86 assembly language today?<br />
<a href="https://www.quora.com/Is-it-worthwhile-to-learn-x86-assembly-language-today?share=1">https://www.quora.com/Is-it-worthwhile-to-learn-x86-assembly-language-today?share=1</a>
</li>

<li>Why Learn Assembly Language?<br />
<a href="http://www.codeproject.com/Articles/89460/Why-Learn-Assembly-Language">http://www.codeproject.com/Articles/89460/Why-Learn-Assembly-Language</a>
</li>

<li>Is Assembly still relevant?<br />
<a href="http://programmers.stackexchange.com/questions/95836/is-assembly-still-relevant">http://programmers.stackexchange.com/questions/95836/is-assembly-still-relevant</a>
</li>

<li>Why Learning Assembly Language Is Still a Good Idea<br />
<a href="http://www.onlamp.com/pub/a/onlamp/2004/05/06/writegreatcode.html">http://www.onlamp.com/pub/a/onlamp/2004/05/06/writegreatcode.html</a>
</li>

</ol>



<p></p><p></p>
<p><small>Autor: <a href="https://github.com/tisnik/">Pavel Tišnovský</a> &nbsp; 2025</small></p>
</body>
</html>

