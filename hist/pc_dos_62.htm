<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
        "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html>
<head>
<title>Funkce vestavěné v GCC pro provádění nízkoúrovňových bitových operací a rotací (2. část)</title>
<meta name="Author" content="Pavel Tisnovsky" />
<meta name="Generator" content="vim" />
<meta http-equiv="content-type" content="text/html; charset=utf-8" />
<style type="text/css">
         body {color:#000000; background:#ffffff;}
         h1  {font-family: arial, helvetica, sans-serif; color:#ffffff; background-color:#c00000; text-align:center; padding-left:1em}
         h2  {font-family: arial, helvetica, sans-serif; color:#ffffff; background-color:#0000c0; padding-left:1em; text-align:left}
         h3  {font-family: arial, helvetica, sans-serif; color:#000000; background-color:#c0c0c0; padding-left:1em; text-align:left}
         h4  {font-family: arial, helvetica, sans-serif; color:#000000; background-color:#e0e0e0; padding-left:1em; text-align:left}
         a   {font-family: arial, helvetica, sans-serif;}
         li  {font-family: arial, helvetica, sans-serif; color:#000000; text-align:justify; width:450px;}
         ol  {font-family: arial, helvetica, sans-serif; color:#000000; text-align:justify; width:450px;}
         ul  {font-family: arial, helvetica, sans-serif; color:#000000; text-align:justify; width:450px;}
         p   {font-family: arial, helvetica, sans-serif; color:#000000; text-align:justify;}
         pre {background:#e0e0e0}
</style>
</head>

<body>

<h1>Funkce vestavěné v GCC pro provádění nízkoúrovňových bitových operací a rotací (2. část)</h1>

<h3>Pavel Tišnovský</h3>

<p></p>

<h1>Úvodník</h1>

<p></p>



<h2>Obsah</h2>

<p><a href="#k01">*** 1. Funkce vestavěné v&nbsp;GCC pro provádění nízkoúrovňových bitových operací a rotací (2. část)</a></p>
<p><a href="#k02">*** 2. Vyhledání prvního nebo posledního bitu se zadanou hodnotou</a></p>
<p><a href="#k03">*** 3. Důležitá odbočka: instrukce pro hledání bitů dostupné na architektuře x86-64</a></p>
<p><a href="#k04">4. Základní použití instrukcí <strong>BSF</strong> a <strong>BSR</strong></a></p>
<p><a href="#k05">5. Realizace výpočtů pozice nejvyššího a nejnižšího bitu s&nbsp;jedničkovou hodnotou pro vstupy 0 až 16</a></p>
<p><a href="#k06">*** 6. Chování instrukcí <strong>BSF</strong> a <strong>BSR</strong> v&nbsp;případě, že je vstup nulový</a></p>
<p><a href="#k07">7. Upravené příklady pro výpočty pozice nejvyššího a nejnižšího bitu s&nbsp;jedničkovou hodnotou pro vstupy 0 až 16</a></p>
<p><a href="#k08">8. Vypočtené výsledky</a></p>
<p><a href="#k09">*** 9. Zjištění počtu nulových bitů na začátku nebo konci testované hodnoty</a></p>
<p><a href="#k10">10. Příklad použití instrukce <strong>LZCNT</strong></a></p>
<p><a href="#k11">11. Příklad použití instrukce <strong>TZCNT</strong></a></p>
<p><a href="#k12">*** 12. <strong>LZCNT</strong> == <strong>REP BSR</strong></a></p>
<p><a href="#k13">*** 13. <strong>TZCNT</strong> == <strong>REP BSF</strong></a></p>
<p><a href="#k14">*** 14. Volání vestavěné funkce <strong>__builtin_stdc_first_trailing_one</strong></a></p>
<p><a href="#k15">*** 15. Překlad funkce <strong>__builtin_stdc_first_trailing_one</strong> do strojového kódu</a></p>
<p><a href="#k16">*** 16. </a></p>
<p><a href="#k17">*** 17. </a></p>
<p><a href="#k18">18. Příloha: soubor Makefile pro překlad příkladů napsaných v&nbsp;assembleru NASM</a></p>
<p><a href="#k19">*** 19. Repositář s&nbsp;demonstračními příklady</a></p>
<p><a href="#k20">20. Odkazy na Internetu</a></p>



<p><a name="k01"></a></p>
<h2 id="k01">1. Funkce vestavěné v&nbsp;GCC pro provádění nízkoúrovňových bitových operací a rotací (2. část)</h2>

<p></p>

int __builtin_ffs(int x)
int __builtin_clz(unsigned int x)
int __builtin_ctz(unsigned int x)
int __builtin_clrsb(int x)
int __builtin_popcount(unsigned int x)
int __builtin_ffsl(long)
int __builtin_clzl(unsigned long)
int __builtin_ctzl(unsigned long)
int __builtin_clrsbl(long)
int __builtin_popcountl(unsigned long)
int __builtin_ffsll(long long)
int __builtin_clzll(unsigned long long)
int __builtin_ctzll(unsigned long long)
int __builtin_clrsbll(long long)
int __builtin_popcountll(unsigned long long)
int __builtin_ffsg(...)
int __builtin_clzg(...)
int __builtin_ctzg(...)
int __builtin_clrsbg(...)
int __builtin_popcountg(...)
type __builtin_stdc_bit_ceil(type arg)
type __builtin_stdc_bit_floor(type arg)
unsigned int __builtin_stdc_bit_width(type arg)
unsigned int __builtin_stdc_count_ones(type arg)
unsigned int __builtin_stdc_count_zeros(type arg)
unsigned int __builtin_stdc_first_leading_one(type arg)
unsigned int __builtin_stdc_first_leading_zero(type arg)
unsigned int __builtin_stdc_first_trailing_one(type arg)
unsigned int __builtin_stdc_first_trailing_zero(type arg)
unsigned int __builtin_stdc_has_single_bit(type arg)
unsigned int __builtin_stdc_leading_ones(type arg)
unsigned int __builtin_stdc_leading_zeros(type arg)
unsigned int __builtin_stdc_trailing_ones(type arg)
unsigned int __builtin_stdc_trailing_zeros(type arg)



<p><a name="k02"></a></p>
<h2 id="k02">2. Vyhledání prvního nebo posledního bitu se zadanou hodnotou</h2>



<p><a name="k03"></a></p>
<h2 id="k03">3. Důležitá odbočka: instrukce pro hledání bitů dostupné na architektuře x86-64</h2>

BSF
BSR
TZCNT - count trailing zeroes
LZCNT



<p><a name="k04"></a></p>
<h2 id="k04">4. Základní použití instrukcí <strong>BSF</strong> a <strong>BSR</strong></h2>

<p>Vyzkoušejme si nyní, jaké výsledky získáme, pokud instrukcím
<strong>BSF</strong> a <strong>BSR</strong> předáme bitovou hodnotu 0b01000010.
Nezávisle na bitové šířce operandu (16 bitů, 32 bitů či 64 bitů) by měla
instrukce <strong>BSF</strong> vrátit hodnotu 1, protože první jedničkový bit
hledaný zprava (od nejnižšího bitu) má index roven jedné. Instrukce
<strong>BSR</strong> vrátí hodnotu 6, protože první jedničkový bit hledaný
zleva (od nejvyššího bitu) má index roven právě šesti.</p>

<p>Použití instrukce <strong>BSF</strong>:</p>

<pre>
[bits 32]
&nbsp;
%include "linux_macros.asm"
&nbsp;
<i>;-----------------------------------------------------------------------------</i>
section .data
&nbsp;
<strong>hex_message</strong>:
         times 8 db '?'
         db 0x0a
         hex_message_length equ $ - hex_message
&nbsp;
<i>;-----------------------------------------------------------------------------</i>
section .bss
&nbsp;
<i>;-----------------------------------------------------------------------------</i>
section .text
        global _start                <i>; tento symbol ma byt dostupny i linkeru</i>
&nbsp;
<strong>_start</strong>:
        mov     eax, 0x42            <i>; == 0b01000010</i>
        bsf     edx, eax             <i>; zjisteni indexu nejvyssiho nenuloveho bitu</i>
&nbsp;
        mov     ebx, hex_message     <i>; buffer, ktery se zaplni hexa cislicemi</i>
        call    hex2string           <i>; zavolani prislusne subrutiny</i>
        print_string   hex_message, hex_message_length    <i>; tisk hexadecimalni hodnoty</i>
&nbsp;
        exit                         <i>; ukonceni procesu</i>
&nbsp;
&nbsp;
%include "hex2string.asm"
</pre>

<p>Výsledek:</p>

<pre>
00000001
</pre>

<p>Použití instrukce <strong>BSR</strong>:</p>

<pre>
[bits 32]
&nbsp;
%include "linux_macros.asm"
&nbsp;
<i>;-----------------------------------------------------------------------------</i>
section .data
&nbsp;
<strong>hex_message</strong>:
         times 8 db '?'
         db 0x0a
         hex_message_length equ $ - hex_message
&nbsp;
<i>;-----------------------------------------------------------------------------</i>
section .bss
&nbsp;
<i>;-----------------------------------------------------------------------------</i>
section .text
        global _start                <i>; tento symbol ma byt dostupny i linkeru</i>
&nbsp;
<strong>_start</strong>:
        mov     eax, 0x42            <i>; == 0b01000010</i>
        bsr     edx, eax             <i>; zjisteni indexu nejvyssiho nenuloveho bitu</i>
&nbsp;
        mov     ebx, hex_message     <i>; buffer, ktery se zaplni hexa cislicemi</i>
        call    hex2string           <i>; zavolani prislusne subrutiny</i>
        print_string   hex_message, hex_message_length    <i>; tisk hexadecimalni hodnoty</i>
&nbsp;
        exit                         <i>; ukonceni procesu</i>
&nbsp;
&nbsp;
%include "hex2string.asm"
</pre>

<p>Výsledek:</p>

<pre>
00000006
</pre>



<p><a name="k05"></a></p>
<h2 id="k05">5. Realizace výpočtů pozice nejvyššího a nejnižšího bitu s&nbsp;jedničkovou hodnotou pro vstupy 0 až 16</h2>

<p>Předchozí demonstrační příklady si nepatrně upravíme, a to tak, že si
necháme vypsat indexy bitů získaných instrukcemi <strong>BSF</strong> a
<strong>BSR</strong> pro vstupní hodnoty 0 až 16, tj.&nbsp;binárně 0x00000000
až 0x00010000. Pro realizaci počítané smyčky použijeme pracovní registr
<strong>ECX</strong>, který bude fungovat jako počitadlo a současně i vstup do
instrukce <strong>BSF</strong> nebo <strong>BSR</strong>.</p>

<p>První z&nbsp;příkladů vypíše indexy nejnižšího jedničkového bitu:</p>

<pre>
[bits 32]
&nbsp; 
%include "linux_macros.asm"
&nbsp;
<i>;-----------------------------------------------------------------------------</i>
section .data
&nbsp;
<strong>hex_message</strong>:
         times 8 db '?'
         db 0x0a
         hex_message_length equ $ - hex_message
&nbsp;
<i>;-----------------------------------------------------------------------------</i>
section .bss
&nbsp;
<i>;-----------------------------------------------------------------------------</i>
section .text
        global _start                <i>; tento symbol ma byt dostupny i linkeru</i>
&nbsp;
<strong>_start</strong>:
&nbsp;
        xor     ecx, ecx             <i>; pocitadlo</i>
&nbsp;
<strong>repeat</strong>:
        bsf     edx, ecx             <i>; zjisteni indexu prvniho nenuloveho bitu</i>
&nbsp;
        push    ecx
        mov     ebx, hex_message     <i>; buffer, ktery se zaplni hexa cislicemi</i>
        call    hex2string           <i>; zavolani prislusne subrutiny</i>
        print_string   hex_message, hex_message_length    <i>; tisk hexadecimalni hodnoty</i>
        pop     ecx
        inc     ecx                  <i>; zvysit hodnotu pocitadla</i>
        cmp     ecx, 17              <i>; test na konec pocitane smycky</i>
        jne     repeat               <i>; for-loop</i>
&nbsp;
        exit                         <i>; ukonceni procesu</i>
&nbsp;
&nbsp;
%include "hex2string.asm"
</pre>

<p>Druhý z&nbsp;příkladů vypíše indexy nejvyššího jedničkového bitu:</p>

<pre>
[bits 32]
&nbsp; 
%include "linux_macros.asm"
&nbsp; 
<i>;-----------------------------------------------------------------------------</i>
section .data
&nbsp; 
<strong>hex_message</strong>:
         times 8 db '?'
         db 0x0a
         hex_message_length equ $ - hex_message
&nbsp;
<i>;-----------------------------------------------------------------------------</i>
section .bss
&nbsp;
<i>;-----------------------------------------------------------------------------</i>
section .text
        global _start                <i>; tento symbol ma byt dostupny i linkeru</i>
&nbsp;
<strong>_start</strong>:
&nbsp;
        xor     ecx, ecx             <i>; pocitadlo</i>
&nbsp;
<strong>repeat</strong>:
        bsr     edx, ecx             <i>; zjisteni indexu nejvyssiho nenuloveho bitu</i>
&nbsp;
        push    ecx
        mov     ebx, hex_message     <i>; buffer, ktery se zaplni hexa cislicemi</i>
        call    hex2string           <i>; zavolani prislusne subrutiny</i>
        print_string   hex_message, hex_message_length    <i>; tisk hexadecimalni hodnoty</i>
        pop     ecx
        inc     ecx                  <i>; zvysit hodnotu pocitadla</i>
        cmp     ecx, 17              <i>; test na konec pocitane smycky</i>
        jne     repeat               <i>; for-loop</i>
&nbsp;
        exit                         <i>; ukonceni procesu</i>
&nbsp;
&nbsp;
%include "hex2string.asm"
</pre>

<p>Výsledky obou příkladů (bez úprav):</p>

<pre>
00000000
00000000
00000001
00000000
00000002
00000000
00000001
00000000
00000003
00000000
00000001
00000000
00000002
00000000
00000001
00000000
00000004
</pre>

<pre>
00000000
00000000
00000001
00000001
00000002
00000002
00000002
00000002
00000003
00000003
00000003
00000003
00000003
00000003
00000003
00000003
00000004
</pre>

<p>Vysvětlení výsledků je patrné z&nbsp;následující tabulky:</p>

<table>
<tr><th>Dec</th><th>Bin</th><th>BSF</th><th>BSR</th></tr>
<tr><td> 0</td><td>00000</td><td>0</td><td>0</td></tr>
<tr><td> 1</td><td>00001</td><td>0</td><td>0</td></tr>
<tr><td> 2</td><td>00010</td><td>1</td><td>1</td></tr>
<tr><td> 3</td><td>00011</td><td>0</td><td>1</td></tr>
<tr><td> 4</td><td>00100</td><td>2</td><td>2</td></tr>
<tr><td> 5</td><td>00101</td><td>0</td><td>2</td></tr>
<tr><td> 6</td><td>00110</td><td>1</td><td>2</td></tr>
<tr><td> 7</td><td>00111</td><td>0</td><td>2</td></tr>
<tr><td> 8</td><td>01000</td><td>3</td><td>3</td></tr>
<tr><td> 9</td><td>01001</td><td>0</td><td>3</td></tr>
<tr><td>10</td><td>01010</td><td>1</td><td>3</td></tr>
<tr><td>11</td><td>01011</td><td>0</td><td>3</td></tr>
<tr><td>12</td><td>01100</td><td>2</td><td>3</td></tr>
<tr><td>13</td><td>01101</td><td>0</td><td>3</td></tr>
<tr><td>14</td><td>01110</td><td>1</td><td>3</td></tr>
<tr><td>15</td><td>01111</td><td>0</td><td>3</td></tr>
<tr><td>16</td><td>10000</td><td>4</td><td>4</td></tr>
</table>



<p><a name="k06"></a></p>
<h2 id="k06">6. Chování instrukcí <strong>BSF</strong> a <strong>BSR</strong> v&nbsp;případě, že je vstup nulový</h2>

<p></p>



<p><a name="k07"></a></p>
<h2 id="k07">7. Upravené příklady pro výpočty pozice nejvyššího a nejnižšího bitu s&nbsp;jedničkovou hodnotou pro vstupy 0 až 16</h2>

<p>Oba demonstrační příklady <a href="#k05">z&nbsp;páté kapitoly</a> upravíme
takovým způsobem, že kromě výsledků získaných instrukcemi <strong>BSF</strong>
a <strong>BSR</strong> vypíšeme i stav příznakového bitu <strong>ZF</strong>,
což se provede s&nbsp;využitím podmíněného skoku.</p>

<p>Varianta demonstračního příkladu s&nbsp;instrukcí <strong>BSF</strong>
vypadá následovně:</p>

<pre>
[bits 32]
&nbsp; 
%include "linux_macros.asm"
&nbsp; 
<i>;-----------------------------------------------------------------------------</i>
section .data
&nbsp; 
<strong>hex_message</strong>:
         times 8 db '?'
         db 0x0a
         hex_message_length equ $ - hex_message
&nbsp;
<strong>zf_set_message</strong>:
         db "ZF set   "
         zf_set_message_length equ $ - zf_set_message
&nbsp;
<strong>zf_reset_message</strong>:
         db "ZF reset "
         zf_reset_message_length equ $ - zf_reset_message
&nbsp;
<i>;-----------------------------------------------------------------------------</i>
section .bss
&nbsp;
<i>;-----------------------------------------------------------------------------</i>
section .text
        global _start                <i>; tento symbol ma byt dostupny i linkeru</i>
&nbsp;
<strong>_start</strong>:
&nbsp;
        xor     ecx, ecx             <i>; pocitadlo</i>
&nbsp;
<strong>repeat</strong>:
        bsf     edx, ecx             <i>; zjisteni indexu prvniho nenuloveho bitu</i>
        push    ecx
        push    edx
&nbsp;
        jnz     zf_reset
&nbsp;
<strong>zf_set</strong>:
        print_string   zf_set_message, zf_set_message_length
        jmp     continue
&nbsp;
<strong>zf_reset</strong>:
        print_string   zf_reset_message, zf_reset_message_length
&nbsp;
<strong>continue</strong>:
        pop     edx
&nbsp;
        mov     ebx, hex_message     <i>; buffer, ktery se zaplni hexa cislicemi</i>
        call    hex2string           <i>; zavolani prislusne subrutiny</i>
        print_string   hex_message, hex_message_length    <i>; tisk hexadecimalni hodnoty</i>
        pop     ecx
        inc     ecx                  <i>; zvysit hodnotu pocitadla</i>
        cmp     ecx, 17              <i>; test na konec pocitane smycky</i>
        jne     repeat               <i>; for-loop</i>
&nbsp;
        exit                         <i>; ukonceni procesu</i>
&nbsp;
&nbsp;
%include "hex2string.asm"
</pre>

<p>Varianta demonstračního příkladu s&nbsp;instrukcí <strong>BSR</strong>
vypadá následovně:</p>

<pre>
[bits 32]
&nbsp; 
%include "linux_macros.asm"
&nbsp; 
<i>;-----------------------------------------------------------------------------</i>
section .data
&nbsp;
<strong>hex_message</strong>:
         times 8 db '?'
         db 0x0a
         hex_message_length equ $ - hex_message
&nbsp;
<strong>zf_set_message</strong>:
         db "ZF set   "
         zf_set_message_length equ $ - zf_set_message
&nbsp;
<strong>zf_reset_message</strong>:
         db "ZF reset "
         zf_reset_message_length equ $ - zf_reset_message
&nbsp; 
<i>;-----------------------------------------------------------------------------</i>
section .bss
&nbsp;
<i>;-----------------------------------------------------------------------------</i>
section .text
        global _start                <i>; tento symbol ma byt dostupny i linkeru</i>
&nbsp;
<strong>_start</strong>:
&nbsp;
        xor     ecx, ecx             <i>; pocitadlo</i>
&nbsp;
<strong>repeat</strong>:
        bsr     edx, ecx             <i>; zjisteni indexu nejvyssiho nenuloveho bitu</i>
        push    ecx
        push    edx
&nbsp;
        jnz     zf_reset
&nbsp;
<strong>zf_set</strong>:
        print_string   zf_set_message, zf_set_message_length
        jmp     continue
&nbsp;
<strong>zf_reset</strong>:
        print_string   zf_reset_message, zf_reset_message_length
&nbsp;
<strong>continue</strong>:
        pop     edx
&nbsp;
        mov     ebx, hex_message     <i>; buffer, ktery se zaplni hexa cislicemi</i>
        call    hex2string           <i>; zavolani prislusne subrutiny</i>
        print_string   hex_message, hex_message_length    <i>; tisk hexadecimalni hodnoty</i>
        pop     ecx
        inc     ecx                  <i>; zvysit hodnotu pocitadla</i>
        cmp     ecx, 17              <i>; test na konec pocitane smycky</i>
        jne     repeat               <i>; for-loop</i>
&nbsp;
        exit                         <i>; ukonceni procesu</i>
&nbsp;
&nbsp;
%include "hex2string.asm"
</pre>



<p><a name="k08"></a></p>
<h2 id="k08">8. Vypočtené výsledky</h2>

<p>Podívejme se nyní na vypočtené výsledky, které prozradí, za jakých okolností
se nastavuje příznak <strong>ZF</strong>. První tabulka ukazuje výsledky
získané instrukcí <strong>BSF</strong>. Podle očekávání je příznak
<strong>ZF</strong> nastaven pouze v&nbsp;případě, že vstupem je nulová
hodnota, přesněji řečeno hodnota, která má všechny své bity nulové a instrukce
tedy nenašla žádný jedničkový bit:</p>

<pre>
ZF set   00000000
ZF reset 00000000
ZF reset 00000001
ZF reset 00000000
ZF reset 00000002
ZF reset 00000000
ZF reset 00000001
ZF reset 00000000
ZF reset 00000003
ZF reset 00000000
ZF reset 00000001
ZF reset 00000000
ZF reset 00000002
ZF reset 00000000
ZF reset 00000001
ZF reset 00000000
ZF reset 00000004
</pre>

<p>Instrukce <strong>BSR</strong> sice pro některé vstupy vrací odlišné indexy
bitů (což je očekávané chování), ovšem příznak <strong>ZF</strong> nastavuje
naprosto stejným způsobem, jako je tomu u instrukce <strong>BSF</strong>. To je
ostatně patrné z&nbsp;následující tabulky:</p>

<pre>
ZF set   00000000
ZF reset 00000000
ZF reset 00000001
ZF reset 00000001
ZF reset 00000002
ZF reset 00000002
ZF reset 00000002
ZF reset 00000002
ZF reset 00000003
ZF reset 00000003
ZF reset 00000003
ZF reset 00000003
ZF reset 00000003
ZF reset 00000003
ZF reset 00000003
ZF reset 00000003
ZF reset 00000004
</pre>



<p><a name="k09"></a></p>
<h2 id="k09">9. Zjištění počtu nulových bitů na začátku nebo konci testované hodnoty</h2>



<p><a name="k10"></a></p>
<h2 id="k10">10. Příklad použití instrukce <strong>LZCNT</strong></h2>

<p>Základní chování instrukce <strong>LZCNT</strong> si ověříme na
demonstračním příkladu, ve kterém této instrukci opět předáme hodnotu 0x42,
kterou je možné v&nbsp;binární podobě vyjádřit jako 0b01000010:</p>

<pre>
[bits 32]
&nbsp; 
%include "linux_macros.asm"
&nbsp;
<i>;-----------------------------------------------------------------------------</i>
section .data
&nbsp;
<strong>hex_message</strong>:
         times 8 db '?'
         db 0x0a
         hex_message_length equ $ - hex_message
&nbsp;
<i>;-----------------------------------------------------------------------------</i>
section .bss
&nbsp;
<i>;-----------------------------------------------------------------------------</i>
section .text
        global _start                <i>; tento symbol ma byt dostupny i linkeru</i>
&nbsp;
<strong>_start</strong>:
        mov     eax, 0x42            <i>; == 0b01000010</i>
        lzcnt   edx, eax
&nbsp;
        mov     ebx, hex_message     <i>; buffer, ktery se zaplni hexa cislicemi</i>
        call    hex2string           <i>; zavolani prislusne subrutiny</i>
        print_string   hex_message, hex_message_length    <i>; tisk hexadecimalni hodnoty</i>
&nbsp;
        exit                         <i>; ukonceni procesu</i>
&nbsp;
&nbsp;
%include "hex2string.asm"
</pre>

<p>Po překladu a spuštění by se měla vypsat hodnota:</p>

<pre>
00000019
</pre>

<p>Proč tomu tak je? Ve skutečnosti pracujeme s&nbsp;32bitovým registrem a
vypsaná hodnota 0x19 decimálně odpovídá hodnotě 25. A pokud se podíváme na
binární vyjádření vstupu, tak zjistíme, že plná 32bitová hodnota
0b00000000000000000000000001000010 má na začátku dvacet pět nul.</p>



<p><a name="k11"></a></p>
<h2 id="k11">11. Příklad použití instrukce <strong>TZCNT</strong></h2>

<p>V&nbsp;dalším demonstračním příkladu naprogramovaném v&nbsp;assembleru
zavoláme instrukci <strong>TZCNT</strong>:</p>

<pre>
[bits 32]
&nbsp; 
%include "linux_macros.asm"
&nbsp;
<i>;-----------------------------------------------------------------------------</i>
section .data
&nbsp;
<strong>hex_message</strong>:
         times 8 db '?'
         db 0x0a
         hex_message_length equ $ - hex_message
&nbsp;
<i>;-----------------------------------------------------------------------------</i>
section .bss
&nbsp;
<i>;-----------------------------------------------------------------------------</i>
section .text
        global _start                <i>; tento symbol ma byt dostupny i linkeru</i>
&nbsp;
<strong>_start</strong>:
        mov     eax, 0x42            <i>; == 0b01000010</i>
        tzcnt   edx, eax
&nbsp;
        mov     ebx, hex_message     <i>; buffer, ktery se zaplni hexa cislicemi</i>
        call    hex2string           <i>; zavolani prislusne subrutiny</i>
        print_string   hex_message, hex_message_length    <i>; tisk hexadecimalni hodnoty</i>
&nbsp;
        exit                         <i>; ukonceni procesu</i>
&nbsp;
&nbsp;
%include "hex2string.asm"
</pre>

<p>Nyní se vypíše:</p>

<pre>
00000001
</pre>

<p>To taktéž odpovídá očekávání, protože (počítáno od nejnižšího bitu) končí
analyzovaná 32bitová hodnota přesně jedním nulovým bitem.</p>



<p><a name="k12"></a></p>
<h2 id="k12">12. <strong>LZCNT</strong> == <strong>REP BSR</strong></h2>

<pre>
[bits 32]
 
%include "linux_macros.asm"

<i>;-----------------------------------------------------------------------------</i>
section .data

hex_message:
         times 8 db '?'
         db 0x0a
         hex_message_length equ $ - hex_message

<i>;-----------------------------------------------------------------------------</i>
section .bss

id_string: resb 8

 
<i>;-----------------------------------------------------------------------------</i>
section .text
        global _start                <i>; tento symbol ma byt dostupny i linkeru</i>

_start:
        mov     eax, 0x42            <i>; == 0b01000010</i>
        rep bsr   edx, eax

        mov     ebx, hex_message     <i>; buffer, ktery se zaplni hexa cislicemi</i>
        call    hex2string           <i>; zavolani prislusne subrutiny</i>
        print_string   hex_message, hex_message_length    <i>; tisk hexadecimalni hodnoty</i>

        exit                         <i>; ukonceni procesu</i>


%include "hex2string.asm"
</pre>

<pre>
0FBDD0         bsr     edx, eax
</pre>

<pre>
F30FBDD0       lzcnt   edx, eax
</pre>

<pre>
F30FBDD0       rep bsr   edx, eax
</pre>



<p><a name="k13"></a></p>
<h2 id="k13">13. <strong>TZCNT</strong> == <strong>REP BSF</strong></h2>

<pre>
[bits 32]
 
%include "linux_macros.asm"

<i>;-----------------------------------------------------------------------------</i>
section .data

hex_message:
         times 8 db '?'
         db 0x0a
         hex_message_length equ $ - hex_message

<i>;-----------------------------------------------------------------------------</i>
section .bss

id_string: resb 8

 
<i>;-----------------------------------------------------------------------------</i>
section .text
        global _start                <i>; tento symbol ma byt dostupny i linkeru</i>

_start:
        mov     eax, 0x42            <i>; == 0b01000010</i>
        rep bsf   edx, eax

        mov     ebx, hex_message     <i>; buffer, ktery se zaplni hexa cislicemi</i>
        call    hex2string           <i>; zavolani prislusne subrutiny</i>
        print_string   hex_message, hex_message_length    <i>; tisk hexadecimalni hodnoty</i>

        exit                         <i>; ukonceni procesu</i>


%include "hex2string.asm"
</pre>

<pre>
0FBCD0         bsf     edx, eax
</pre>

<pre>
F30FBCD0       tzcnt   edx, eax
</pre>

<pre>
F30FBCD0       rep bsf   edx, eax
</pre>



<p><a name="k14"></a></p>
<h2 id="k14">14. Volání vestavěné funkce <strong>__builtin_stdc_first_trailing_one</strong></h2>

<p></p>

<pre>
#include &lt;stdio.h&gt;
#include &lt;stdint.h&gt;
&nbsp;
uint8_t <strong>bsf_8bit</strong>(uint8_t x) {
    uint8_t z;
    z = __builtin_stdc_first_trailing_one(x);
    return z;
}
&nbsp;
void <strong>print_bin</strong>(uint8_t x) {
    int i;
&nbsp;
    for (i = 7; i &gt;= 0; i--) {
        printf("%d", (x &gt;&gt; i) &amp; 1);
    }
}
&nbsp;
void <strong>test_bsf</strong>(uint8_t x) {
    printf("%u \t", x);
    print_bin(x);
    printf("\t%d\n", bsf_8bit(x));
}
&nbsp;
int <strong>main</strong>(void) {
    uint8_t i;
&nbsp;
    for (i=0; i&lt;=17; i++) {
        test_bsf(i);
    }
&nbsp;
    test_bsf(0xff);
}
</pre>

<p></p>

<pre>
0       00000000        0
1       00000001        1
2       00000010        2
3       00000011        1
4       00000100        3
5       00000101        1
6       00000110        2
7       00000111        1
8       00001000        4
9       00001001        1
10      00001010        2
11      00001011        1
12      00001100        3
13      00001101        1
14      00001110        2
15      00001111        1
16      00010000        5
17      00010001        1
255     11111111        1
</pre>



<p><a name="k15"></a></p>
<h2 id="k15">15. Překlad funkce <strong>__builtin_stdc_first_trailing_one</strong> do strojového kódu</h2>

<p></p>

<pre>
#include &lt;stdint.h&gt;

uint8_t bsf_8bit(uint8_t x) {
    uint8_t z;
    z = __builtin_stdc_first_trailing_one(x);
    return z;
}

uint16_t bsf_16bit(uint16_t x) {
    uint16_t z;
    z = __builtin_stdc_first_trailing_one(x);
    return z;
}

uint32_t bsf_32bit(uint32_t x) {
    uint32_t z;
    z = __builtin_stdc_first_trailing_one(x);
    return z;
}

uint64_t bsf_64bit(uint64_t x) {
    uint64_t z;
    z = __builtin_stdc_first_trailing_one(x);
    return z;
}
</pre>

<pre>
bsf_8bit:
        movzx   edi, dil
        xor     eax, eax
        xor     edx, edx
        rep bsf eax, edi
        add     eax, 1
        test    edi, edi
        cmove   eax, edx
        ret

bsf_16bit:
        movzx   edi, di
        xor     eax, eax
        xor     edx, edx
        rep bsf eax, edi
        add     eax, 1
        test    edi, edi
        cmove   eax, edx
        ret

bsf_32bit:
        xor     eax, eax
        xor     edx, edx
        rep bsf eax, edi
        add     eax, 1
        test    edi, edi
        cmove   eax, edx
        ret

bsf_64bit:
        xor     eax, eax
        rep bsf rax, rdi
        add     eax, 1
        test    rdi, rdi
        cdqe
        cmove   rax, rdi
        ret
</pre>



<p><a name="k16"></a></p>
<h2 id="k16">16. </h2>



<p><a name="k17"></a></p>
<h2 id="k17">17. </h2>



<p><a name="k18"></a></p>
<h2 id="k18">18. Příloha: soubor Makefile pro překlad příkladů napsaných v&nbsp;assembleru NASM</h2>

<p>Všechny výše uvedené demonstrační příklady naprogramované v&nbsp;assembleru
NASM je možné přeložit s&nbsp;využitím souboru Makefile, jehož obsah je vypsán
níže. Postačuje zadat příkaz <strong>make all</strong>:</p>

<pre>
ASM=nasm
LINKER=ld
&nbsp;
execs := bsf1 bsr1 bsf2 bsr2 bsf3 bsr3 lzcnt1 lzcnt2 tzcnt1 tzcnt2
&nbsp;
all:    $(execs)
&nbsp;
clean:
        rm -f *.o $(execs)
&nbsp;
&nbsp;
.PHONY: all clean
&nbsp;
%.o: %.asm linux_macros.asm hex2string.asm
        ${ASM} -f elf $&lt; -o $@
&nbsp;
bsf1:   bsf1.o
        ld -melf_i386 $&lt; -o $@
&nbsp;
bsr1:   bsr1.o
        ld -melf_i386 $&lt; -o $@
&nbsp;
bsf2:   bsf2.o
        ld -melf_i386 $&lt; -o $@
&nbsp;
bsr2:   bsr2.o
        ld -melf_i386 $&lt; -o $@
&nbsp;
bsf3:   bsf3.o
        ld -melf_i386 $&lt; -o $@
&nbsp;
bsr3:   bsr3.o
        ld -melf_i386 $&lt; -o $@
&nbsp;
lzcnt1: lzcnt1.o
        ld -melf_i386 $&lt; -o $@
&nbsp;
lzcnt2: lzcnt2.o
        ld -melf_i386 $&lt; -o $@
&nbsp;
tzcnt1: tzcnt1.o
        ld -melf_i386 $&lt; -o $@
&nbsp;
tzcnt2: tzcnt2.o
        ld -melf_i386 $&lt; -o $@
</pre>



<p><a name="k19"></a></p>
<h2 id="k19">19. Repositář s&nbsp;demonstračními příklady</h2>

<table>
<tr><th> #</th><th>Příklad</th><th>Stručný popis</th><th>Adresa</th></tr>
<tr><td> 1</td><td>bsf1.asm</td><td></td><td><a href="https://github.com/tisnik/8bit-fame/blob/master/pc-linux/bsf1.asm">https://github.com/tisnik/8bit-fame/blob/master/pc-linux/bsf1.asm</a></td></tr>
<tr><td> 2</td><td>bsf1_lst.asm</td><td></td><td><a href="https://github.com/tisnik/8bit-fame/blob/master/pc-linux/bsf1_lst.asm">https://github.com/tisnik/8bit-fame/blob/master/pc-linux/bsf1_lst.asm</a></td></tr>
<tr><td> 3</td><td>bsf2.asm</td><td></td><td><a href="https://github.com/tisnik/8bit-fame/blob/master/pc-linux/bsf2.asm">https://github.com/tisnik/8bit-fame/blob/master/pc-linux/bsf2.asm</a></td></tr>
<tr><td> 4</td><td>bsf3.asm</td><td></td><td><a href="https://github.com/tisnik/8bit-fame/blob/master/pc-linux/bsf3.asm">https://github.com/tisnik/8bit-fame/blob/master/pc-linux/bsf3.asm</a></td></tr>
<tr><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td></tr>
<tr><td> 5</td><td>bsr1.asm</td><td></td><td><a href="https://github.com/tisnik/8bit-fame/blob/master/pc-linux/bsr1.asm">https://github.com/tisnik/8bit-fame/blob/master/pc-linux/bsr1.asm</a></td></tr>
<tr><td> 6</td><td>bsr1_lst.asm</td><td></td><td><a href="https://github.com/tisnik/8bit-fame/blob/master/pc-linux/bsr1_lst.asm">https://github.com/tisnik/8bit-fame/blob/master/pc-linux/bsr1_lst.asm</a></td></tr>
<tr><td> 7</td><td>bsr2.asm</td><td></td><td><a href="https://github.com/tisnik/8bit-fame/blob/master/pc-linux/bsr2.asm">https://github.com/tisnik/8bit-fame/blob/master/pc-linux/bsr2.asm</a></td></tr>
<tr><td> 8</td><td>bsr3.asm</td><td></td><td><a href="https://github.com/tisnik/8bit-fame/blob/master/pc-linux/bsr3.asm">https://github.com/tisnik/8bit-fame/blob/master/pc-linux/bsr3.asm</a></td></tr>
<tr><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td></tr>
<tr><td> 9</td><td>lzcnt1.asm    </td><td></td><td><a href="https://github.com/tisnik/8bit-fame/blob/master/pc-linux/lzcnt1.asm">https://github.com/tisnik/8bit-fame/blob/master/pc-linux/lzcnt1.asm</a></td></tr>
<tr><td>10</td><td>lzcnt1_lst.asm</td><td></td><td><a href="https://github.com/tisnik/8bit-fame/blob/master/pc-linux/lzcnt1_lst.asm">https://github.com/tisnik/8bit-fame/blob/master/pc-linux/lzcnt1_lst.asm</a></td></tr>
<tr><td>11</td><td>lzcnt2.asm    </td><td></td><td><a href="https://github.com/tisnik/8bit-fame/blob/master/pc-linux/lzcnt2.asm">https://github.com/tisnik/8bit-fame/blob/master/pc-linux/lzcnt2.asm</a></td></tr>
<tr><td>12</td><td>lzcnt2_lst.asm</td><td></td><td><a href="https://github.com/tisnik/8bit-fame/blob/master/pc-linux/lzcnt2_lst.asm">https://github.com/tisnik/8bit-fame/blob/master/pc-linux/lzcnt2_lst.asm</a></td></tr>
<tr><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td></tr>
<tr><td>13</td><td>tzcnt1.asm    </td><td></td><td><a href="https://github.com/tisnik/8bit-fame/blob/master/pc-linux/tzcnt1.asm">https://github.com/tisnik/8bit-fame/blob/master/pc-linux/tzcnt1.asm</a></td></tr>
<tr><td>14</td><td>tzcnt1_lst.asm</td><td></td><td><a href="https://github.com/tisnik/8bit-fame/blob/master/pc-linux/tzcnt1_lst.asm">https://github.com/tisnik/8bit-fame/blob/master/pc-linux/tzcnt1_lst.asm</a></td></tr>
<tr><td>15</td><td>tzcnt2.asm    </td><td></td><td><a href="https://github.com/tisnik/8bit-fame/blob/master/pc-linux/tzcnt2.asm">https://github.com/tisnik/8bit-fame/blob/master/pc-linux/tzcnt2.asm</a></td></tr>
<tr><td>16</td><td>tzcnt2_lst.asm</td><td></td><td><a href="https://github.com/tisnik/8bit-fame/blob/master/pc-linux/tzcnt2_lst.asm">https://github.com/tisnik/8bit-fame/blob/master/pc-linux/tzcnt2_lst.asm</a></td></tr>
<tr><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td></tr>
<tr><td>17</td><td>hex2string.asm  </td><td></td><td><a href="https://github.com/tisnik/8bit-fame/blob/master/pc-linux/hex2string.asm">https://github.com/tisnik/8bit-fame/blob/master/pc-linux/hex2string.asm</a></td></tr>
<tr><td>18</td><td>linux_macros.asm</td><td></td><td><a href="https://github.com/tisnik/8bit-fame/blob/master/pc-linux/linux_macros.asm">https://github.com/tisnik/8bit-fame/blob/master/pc-linux/linux_macros.asm</a></td></tr>
<tr><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td></tr>
<tr><td>19</td><td>Makefile</td><td>Makefile určený pro překlad všech výše uvedených demonstračních příkladů</td><td><a href="https://github.com/tisnik/8bit-fame/blob/master/pc-linux/Makefile">https://github.com/tisnik/8bit-fame/blob/master/pc-linux/Makefile</a></td></tr>
</table>

<p>Demonstrační příklady napsané v&nbsp;jazyku C, které jsou určené pro překlad
s&nbsp;využitím překladače <strong>gcc</strong>, byly uloženy do Git
repositáře, který je dostupný na adrese <a
href="https://github.com/tisnik/8bit-fame">https://github.com/tisnik/8bit-fame</a>.
Jednotlivé demonstrační příklady si můžete v&nbsp;případě potřeby stáhnout i
jednotlivě bez nutnosti klonovat celý (dnes již poměrně rozsáhlý)
repositář:</p>

<table>
<tr><th> #</th><th>Příklad</th><th>Stručný popis</th><th>Adresa</th></tr>
<tr><td> 1</td><td>rotate_left.c</td><td>volání vestavěné funkce v&nbsp;C (GCC) realizující rotaci doleva</td><td><a href="https://github.com/tisnik/8bit-fame/blob/master/gcc-builtins/rotate_left.c">https://github.com/tisnik/8bit-fame/blob/master/gcc-builtins/rotate_left.c</a></td></tr>
<tr><td> 2</td><td>rotate_left_x86_00.asm</td><td>překlad volání funkce <strong>__builtin_stdc_rotate_left</strong> na platformě x86-64 bez aplikace optimalizací</td><td><a href="https://github.com/tisnik/8bit-fame/blob/master/gcc-builtins/rotate_left_x86_00.asm">https://github.com/tisnik/8bit-fame/blob/master/gcc-builtins/rotate_left_x86_00.asm</a></td></tr>
<tr><td> 3</td><td>rotate_left_x86_09.asm</td><td>překlad volání funkce <strong>__builtin_stdc_rotate_left</strong> na platformě x86-64 s&nbsp;aplikací optimalizací</td><td><a href="https://github.com/tisnik/8bit-fame/blob/master/gcc-builtins/rotate_left_x86_09.asm">https://github.com/tisnik/8bit-fame/blob/master/gcc-builtins/rotate_left_x86_09.asm</a></td></tr>
<tr><td> 4</td><td>rotate_left_arm32.asm</td><td>překlad volání funkce <strong>__builtin_stdc_rotate_left</strong> pro 32bitové ARMy</td><td><a href="https://github.com/tisnik/8bit-fame/blob/master/gcc-builtins/rotate_left_arm32.asm">https://github.com/tisnik/8bit-fame/blob/master/gcc-builtins/rotate_left_arm32.asm</a></td></tr>
<tr><td> 5</td><td>rotate_left_arm64.asm</td><td>překlad volání funkce <strong>__builtin_stdc_rotate_left</strong> pro 64bitové ARMy (AArch64)</td><td><a href="https://github.com/tisnik/8bit-fame/blob/master/gcc-builtins/rotate_left_arm64.asm">https://github.com/tisnik/8bit-fame/blob/master/gcc-builtins/rotate_left_arm64.asm</a></td></tr>
<tr><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td></tr>
<tr><td> 6</td><td>rotate_right.c</td><td>volání vestavěné funkce v&nbsp;C (GCC) realizující rotaci doleva</td><td><a href="https://github.com/tisnik/8bit-fame/blob/master/gcc-builtins/rotate_right.c">https://github.com/tisnik/8bit-fame/blob/master/gcc-builtins/rotate_right.c</a></td></tr>
<tr><td> 7</td><td>rotate_right_x86_00.asm</td><td>překlad volání funkce <strong>__builtin_stdc_rotate_right</strong> na platformě x86-64 bez aplikace optimalizací</td><td><a href="https://github.com/tisnik/8bit-fame/blob/master/gcc-builtins/rotate_right_x86_00.asm">https://github.com/tisnik/8bit-fame/blob/master/gcc-builtins/rotate_right_x86_00.asm</a></td></tr>
<tr><td> 8</td><td>rotate_right_x86_09.asm</td><td>překlad volání funkce <strong>__builtin_stdc_rotate_right</strong> na platformě x86-64 s&nbsp;aplikací optimalizací</td><td><a href="https://github.com/tisnik/8bit-fame/blob/master/gcc-builtins/rotate_right_x86_09.asm">https://github.com/tisnik/8bit-fame/blob/master/gcc-builtins/rotate_right_x86_09.asm</a></td></tr>
<tr><td> 9</td><td>rotate_right_arm32.asm</td><td>překlad volání funkce <strong>__builtin_stdc_rotate_right</strong> pro 32bitové ARMy</td><td><a href="https://github.com/tisnik/8bit-fame/blob/master/gcc-builtins/rotate_right_arm32.asm">https://github.com/tisnik/8bit-fame/blob/master/gcc-builtins/rotate_right_arm32.asm</a></td></tr>
<tr><td>10</td><td>rotate_right_arm64.asm</td><td>překlad volání funkce <strong>__builtin_stdc_rotate_right</strong> pro 64bitové ARMy (AArch64)</td><td><a href="https://github.com/tisnik/8bit-fame/blob/master/gcc-builtins/rotate_right_arm64.asm">https://github.com/tisnik/8bit-fame/blob/master/gcc-builtins/rotate_right_arm64.asm</a></td></tr>
<tr><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td></tr>
<tr><td>11</td><td>parity_unsigned.c</td><td>volání vestavěných funkcí <strong>__builtin_parity</strong>, <strong>__builtin_parityl</strong> a <strong>__builtin_parityll</strong></td><td><a href="https://github.com/tisnik/8bit-fame/blob/master/gcc-builtins/parity_unsigned.c">https://github.com/tisnik/8bit-fame/blob/master/gcc-builtins/parity_unsigned.c</a></td></tr>
<tr><td>12</td><td>parity_unsigned_x86_00.asm</td><td>překlad volání funkcí <strong>__builtin_parity*</strong> na platformě x86-64 bez aplikace optimalizací</td><td><a href="https://github.com/tisnik/8bit-fame/blob/master/gcc-builtins/parity_unsigned_x86_00.asm">https://github.com/tisnik/8bit-fame/blob/master/gcc-builtins/parity_unsigned_x86_00.asm</a></td></tr>
<tr><td>13</td><td>parity_unsigned_x86_09.asm</td><td>překlad volání funkcí <strong>__builtin_parity*</strong> na platformě x86-64 s&nbsp;aplikací optimalizací</td><td><a href="https://github.com/tisnik/8bit-fame/blob/master/gcc-builtins/parity_unsigned_x86_09.asm">https://github.com/tisnik/8bit-fame/blob/master/gcc-builtins/parity_unsigned_x86_09.asm</a></td></tr>
<tr><td>14</td><td>parity_unsigned_arm32.asm</td><td>překlad volání funkcí <strong>__builtin_parity*</strong> pro 32bitové ARMy</td><td><a href="https://github.com/tisnik/8bit-fame/blob/master/gcc-builtins/parity_unsigned_arm32.asm">https://github.com/tisnik/8bit-fame/blob/master/gcc-builtins/parity_unsigned_arm32.asm</a></td></tr>
<tr><td>15</td><td>parity_unsigned_arm64.asm</td><td>překlad volání funkcí <strong>__builtin_parity*</strong> pro 64bitové ARMy (AArch64)</td><td><a href="https://github.com/tisnik/8bit-fame/blob/master/gcc-builtins/parity_unsigned_arm64.asm">https://github.com/tisnik/8bit-fame/blob/master/gcc-builtins/parity_unsigned_arm64.asm</a></td></tr>
<tr><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td></tr>
<tr><td>16</td><td>parityg_unsigned.c</td><td>volání vestavěné funkce <strong>__builtin_parityg</strong></td><td><a href="https://github.com/tisnik/8bit-fame/blob/master/gcc-builtins/parityg_unsigned.c">https://github.com/tisnik/8bit-fame/blob/master/gcc-builtins/parityg_unsigned.c</a></td></tr>
<tr><td>17</td><td>parityg_unsigned_arm32.asm</td><td>překlad volání funkce <strong>__builtin_parityg</strong> na platformě x86-64 bez aplikace optimalizací</td><td><a href="https://github.com/tisnik/8bit-fame/blob/master/gcc-builtins/parityg_unsigned_arm32.asm">https://github.com/tisnik/8bit-fame/blob/master/gcc-builtins/parityg_unsigned_arm32.asm</a></td></tr>
<tr><td>18</td><td>parityg_unsigned_arm64.asm</td><td>překlad volání funkce <strong>__builtin_parityg</strong> na platformě x86-64 s&nbsp;aplikací optimalizací</td><td><a href="https://github.com/tisnik/8bit-fame/blob/master/gcc-builtins/parityg_unsigned_arm64.asm">https://github.com/tisnik/8bit-fame/blob/master/gcc-builtins/parityg_unsigned_arm64.asm</a></td></tr>
<tr><td>19</td><td>parityg_unsigned_x86_00.asm</td><td>překlad volání funkce <strong>__builtin_parityg</strong> pro 32bitové ARMy</td><td><a href="https://github.com/tisnik/8bit-fame/blob/master/gcc-builtins/parityg_unsigned_x86_00.asm">https://github.com/tisnik/8bit-fame/blob/master/gcc-builtins/parityg_unsigned_x86_00.asm</a></td></tr>
<tr><td>20</td><td>parityg_unsigned_x86_09.asm</td><td>překlad volání funkce <strong>__builtin_parityg</strong> pro 64bitové ARMy (AArch64)</td><td><a href="https://github.com/tisnik/8bit-fame/blob/master/gcc-builtins/parityg_unsigned_x86_09.asm">https://github.com/tisnik/8bit-fame/blob/master/gcc-builtins/parityg_unsigned_x86_09.asm</a></td></tr>
<tr><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td></tr>
<tr><td>21</td><td>parity_signed.c</td><td>výpočet parity celočíselných hodnot se znaménkem: realizace pomocí vestavěných funkcí <strong>__builtin_parity</strong>, <strong>__builtin_parityl</strong> a <strong>__builtin_parityll</strong></td><td><a href="https://github.com/tisnik/8bit-fame/blob/master/gcc-builtins/parity_signed.c">https://github.com/tisnik/8bit-fame/blob/master/gcc-builtins/parity_signed.c</a></td></tr>
<tr><td>22</td><td>parityg_signed.c</td><td>výpočet parity celočíselných hodnot se znaménkem: realizace pomocí vestavěné funkce <strong>__builtin_parityg</strong></td><td><a href="https://github.com/tisnik/8bit-fame/blob/master/gcc-builtins/parityg_signed.c">https://github.com/tisnik/8bit-fame/blob/master/gcc-builtins/parityg_signed.c</a></td></tr>
</table>

<p>Všechny demonstrační příklady z&nbsp;článku <a
href="https://www.root.cz/clanky/funkce-vestavene-v-gcc-pro-provadeni-nizkourovnovych-aritmetickych-operaci/">Funkce
vestavěné v&nbsp;GCC pro provádění nízkoúrovňových aritmetických operací</a>
jsou vypsány v&nbsp;následující tabulce:</p>

<table>
<tr><th> #</th><th>Příklad</th><th>Stručný popis</th><th>Adresa</th></tr>
<tr><td> 1</td><td>add_overflow.c</td><td>volání vestavěné funkce <strong>__builtin_add_overflow</strong> s&nbsp;předáním operandů různých typů</td><td><a href="https://github.com/tisnik/8bit-fame/blob/master/gcc-builtins/add_overflow.c">https://github.com/tisnik/8bit-fame/blob/master/gcc-builtins/add_overflow.c</a></td></tr>
<tr><td> 2</td><td>add_overflow_x86_64_O0.asm</td><td>překlad volání funkce <strong>__builtin_add_overflow</strong> na platformě x86-64 bez aplikace optimalizací</td><td><a href="https://github.com/tisnik/8bit-fame/blob/master/gcc-builtins/add_overflow_x86_64_O0.asm">https://github.com/tisnik/8bit-fame/blob/master/gcc-builtins/add_overflow_x86_64_O0.asm</a></td></tr>
<tr><td> 3</td><td>add_overflow_x86_64_Os.asm</td><td>překlad volání funkce <strong>__builtin_add_overflow</strong> na platformě x86-64 s&nbsp;aplikací optimalizací</td><td><a href="https://github.com/tisnik/8bit-fame/blob/master/gcc-builtins/add_overflow_x86_64_Os.asm">https://github.com/tisnik/8bit-fame/blob/master/gcc-builtins/add_overflow_x86_64_Os.asm</a></td></tr>
<tr><td> 4</td><td>add_overflow_arm_32.asm</td><td>překlad volání funkce <strong>__builtin_add_overflow</strong> pro 32bitové ARMy</td><td><a href="https://github.com/tisnik/8bit-fame/blob/master/gcc-builtins/add_overflow_arm_32.asm">https://github.com/tisnik/8bit-fame/blob/master/gcc-builtins/add_overflow_arm_32.asm</a></td></tr>
<tr><td> 5</td><td>add_overflow_arm_64.asm</td><td>překlad volání funkce <strong>__builtin_add_overflow</strong> pro 64bitové ARMy (AArch64)</td><td><a href="https://github.com/tisnik/8bit-fame/blob/master/gcc-builtins/add_overflow_arm_64.asm">https://github.com/tisnik/8bit-fame/blob/master/gcc-builtins/add_overflow_arm_64.asm</a></td></tr>
<tr><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td></tr>
<tr><td> 6</td><td>add_diff_types.c</td><td>součet s&nbsp;využitím různých kombinací hodnot typu <strong>char</strong> a <strong>int</strong></td><td><a href="https://github.com/tisnik/8bit-fame/blob/master/gcc-builtins/add_diff_types.c">https://github.com/tisnik/8bit-fame/blob/master/gcc-builtins/add_diff_types.c</a></td></tr>
<tr><td> 7</td><td>add_diff_types_x86_64.asm</td><td>překlad volání funkce <strong>__builtin_add_overflow</strong> na platformě x86-64 s&nbsp;aplikací optimalizací</td><td><a href="https://github.com/tisnik/8bit-fame/blob/master/gcc-builtins/add_diff_types_x86_64.asm">https://github.com/tisnik/8bit-fame/blob/master/gcc-builtins/add_diff_types_x86_64.asm</a></td></tr>
<tr><td> 8</td><td>add_diff_types_arm32.asm</td><td>překlad volání funkce <strong>__builtin_add_overflow</strong> pro 32bitové ARMy</td><td><a href="https://github.com/tisnik/8bit-fame/blob/master/gcc-builtins/add_diff_types_arm32.asm">https://github.com/tisnik/8bit-fame/blob/master/gcc-builtins/add_diff_types_arm32.asm</a></td></tr>
<tr><td> 9</td><td>add_diff_types_arm64.asm</td><td>překlad volání funkce <strong>__builtin_add_overflow</strong> pro 64bitové ARMy (AArch64)</td><td><a href="https://github.com/tisnik/8bit-fame/blob/master/gcc-builtins/add_diff_types_arm64.asm">https://github.com/tisnik/8bit-fame/blob/master/gcc-builtins/add_diff_types_arm64.asm</a></td></tr>
<tr><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td></tr>
<tr><td>10</td><td>sub_overflow.c</td><td>operace rozdílu s&nbsp;využitím funkce <strong>__builtin_sub_overflow</strong></td><td><a href="https://github.com/tisnik/8bit-fame/blob/master/gcc-builtins/sub_overflow.c">https://github.com/tisnik/8bit-fame/blob/master/gcc-builtins/sub_overflow.c</a></td></tr>
<tr><td>11</td><td>sub_overflow.asm</td><td>překlad volání funkce <strong>__builtin_sub_overflow</strong> na platformě x86-64</td><td><a href="https://github.com/tisnik/8bit-fame/blob/master/gcc-builtins/sub_overflow.asm">https://github.com/tisnik/8bit-fame/blob/master/gcc-builtins/sub_overflow.asm</a></td></tr>
<tr><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td></tr>
<tr><td>12</td><td>addc_subc.c</td><td>operace součtu tří hodnot a operace rozdílu: s&nbsp;výpůjčkou nebo s&nbsp;přetečením</td><td><a href="https://github.com/tisnik/8bit-fame/blob/master/gcc-builtins/addc_subc.asm">https://github.com/tisnik/8bit-fame/blob/master/gcc-builtins/addc_subc.asm</a></td></tr>
</table>

<table>
<tr><th>#</th><th>Příklad</th><th>Stručný popis</th><th>Adresa</th></tr>
<tr><td>1</td><td>rdrand_support.asm</td><td>test, jestli je instrukce <strong>RDRAND</strong> mikroprocesorem podporována</td><td><a href="https://github.com/tisnik/8bit-fame/blob/master/pc-linux/rdrand_support.asm">https://github.com/tisnik/8bit-fame/blob/master/pc-linux/rdrand_support.asm</a></td></tr>
<tr><td>2</td><td>rdrand_read.asm</td><td>přečtení jedné 32bitové hodnoty instrukcí <strong>RDRAND</strong></td><td><a href="https://github.com/tisnik/8bit-fame/blob/master/pc-linux/rdrand_read.asm">https://github.com/tisnik/8bit-fame/blob/master/pc-linux/rdrand_read.asm</a></td></tr>
<tr><td>3</td><td>rdrand_read_loop.asm</td><td>přečtení sekvence 32bitových hodnot instrukcí <strong>RDRAND</strong></td><td><a href="https://github.com/tisnik/8bit-fame/blob/master/pc-linux/rdrand_read_loop.asm">https://github.com/tisnik/8bit-fame/blob/master/pc-linux/rdrand_read_loop.asm</a></td></tr>
<tr><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td></tr>
<tr><td>4</td><td>rdrand_read.c</td><td>přečtení náhodné 32bitové hodnoty, realizace s&nbsp;využitím vestavěné funkce GCC</td><td><a href="https://github.com/tisnik/8bit-fame/blob/master/gcc-builtins/rdrand_read.c">https://github.com/tisnik/8bit-fame/blob/master/gcc-builtins/rdrand_read.c</a></td></tr>
<tr><td>5</td><td>rdrand_read.asm</td><td>výsledek překladu předchozího zdrojového kódu do assembleru</td><td><a href="https://github.com/tisnik/8bit-fame/blob/master/gcc-builtins/rdrand_read.asm">https://github.com/tisnik/8bit-fame/blob/master/gcc-builtins/rdrand_read.asm</a></td></tr>
<tr><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td></tr>
<tr><td>6</td><td>rand_gen.c</td><td>vygenerování binárního souboru s&nbsp;pseudonáhodnými 32bitovými hodnotami</td><td><a href="https://github.com/tisnik/8bit-fame/blob/master/gcc-builtins/rand_gen.c">https://github.com/tisnik/8bit-fame/blob/master/gcc-builtins/rand_gen.c</a></td></tr>
<tr><td>7</td><td>rdrand_gen.c</td><td>vygenerování binárního souboru s&nbsp;hodnotami vrácenými instrukcí <strong>RDRAND</strong></td><td><a href="https://github.com/tisnik/8bit-fame/blob/master/gcc-builtins/rdrand_gen.c">https://github.com/tisnik/8bit-fame/blob/master/gcc-builtins/rdrand_gen.c</a></td></tr>
</table>



<p><a name="k20"></a></p>
<h2 id="k20">20. Odkazy na Internetu</h2>

<ol>

<li>Funkce vestavěné v&nbsp;GCC pro provádění nízkoúrovňových aritmetických operací<br />
<a href="https://www.root.cz/clanky/funkce-vestavene-v-gcc-pro-provadeni-nizkourovnovych-aritmetickych-operaci/">https://www.root.cz/clanky/funkce-vestavene-v-gcc-pro-provadeni-nizkourovnovych-aritmetickych-operaci/</a>
</li>

<li>Generátor náhodných čísel založený na instrukcích RDSEED a RDRAND<br />
<a href="https://www.root.cz/clanky/generator-nahodnych-cisel-zalozeny-na-instrukcich-rdseed-a-rdrand/">https://www.root.cz/clanky/generator-nahodnych-cisel-zalozeny-na-instrukcich-rdseed-a-rdrand/</a>
</li>

<li>Circular shift (Wikipedia)<br />
<a href="https://en.wikipedia.org/wiki/Bitwise_operation#Circular_shift">https://en.wikipedia.org/wiki/Bitwise_operation#Circular_shift</a>
</li>

<li>Parity bit (Wikipedia)<br />
<a href="https://en.wikipedia.org/wiki/Parity_bit">https://en.wikipedia.org/wiki/Parity_bit</a>
</li>

<li>Parity function (Wikipedia)<br />
<a href="https://en.wikipedia.org/wiki/Parity_function">https://en.wikipedia.org/wiki/Parity_function</a>
</li>

<li>RDRAND (Wikipedia)<br />
<a href="https://en.wikipedia.org/wiki/RDRAND">https://en.wikipedia.org/wiki/RDRAND</a>
</li>

<li>RDRAND instruction<br />
<a href="https://www.felixcloutier.com/x86/rdrand">https://www.felixcloutier.com/x86/rdrand</a>
</li>

<li>Random Number Generator<br />
<a href="https://wiki.osdev.org/Random_Number_Generator">https://wiki.osdev.org/Random_Number_Generator</a>
</li>

<li>GCC documentation: Extensions to the C Language Family<br />
<a href="https://gcc.gnu.org/onlinedocs/gcc/C-Extensions.html#C-Extensions">https://gcc.gnu.org/onlinedocs/gcc/C-Extensions.html#C-Extensions</a>
</li>

<li>GCC documentation: Using Vector Instructions through Built-in Functions<br />
<a href="https://gcc.gnu.org/onlinedocs/gcc/Vector-Extensions.html">https://gcc.gnu.org/onlinedocs/gcc/Vector-Extensions.html</a>
</li>

<li>SSE (Streaming SIMD Extentions)<br />
<a href="http://www.songho.ca/misc/sse/sse.html">http://www.songho.ca/misc/sse/sse.html</a>
</li>

<li>Timothy A. Chagnon: SSE and SSE2<br />
<a href="http://www.cs.drexel.edu/~tc365/mpi-wht/sse.pdf">http://www.cs.drexel.edu/~tc365/mpi-wht/sse.pdf</a>
</li>

<li>CPU design (Wikipedia)<br />
<a href="http://en.wikipedia.org/wiki/CPU_design">http://en.wikipedia.org/wiki/CPU_design</a>
</li>

<li>GCC Compiler Intrinsics<br />
<a href="https://iq.opengenus.org/gcc-compiler-intrinsics/">https://iq.opengenus.org/gcc-compiler-intrinsics/</a>
</li>

<li>Other Built-in Functions Provided by GCC<br />
<a href="https://gcc.gnu.org/onlinedocs/gcc/Other-Builtins.html">https://gcc.gnu.org/onlinedocs/gcc/Other-Builtins.html</a>
</li>

<li>GCC: 6.60 Built-in Functions Specific to Particular Target Machines<br />
<a href="https://gcc.gnu.org/onlinedocs/gcc/Target-Builtins.html#Target-Builtins">https://gcc.gnu.org/onlinedocs/gcc/Target-Builtins.html#Target-Builtins</a>
</li>

<li>Additional Builtins for Numeric Operations<br />
<a href="https://gcc.gnu.org/onlinedocs/gcc/Numeric-Builtins.html">https://gcc.gnu.org/onlinedocs/gcc/Numeric-Builtins.html</a>
</li>

<li>Bit Operation Builtins<br />
<a href="https://gcc.gnu.org/onlinedocs/gcc/Bit-Operation-Builtins.html">https://gcc.gnu.org/onlinedocs/gcc/Bit-Operation-Builtins.html</a>
</li>

<li>Stránka projektu Compiler Explorer<br />
<a href="https://godbolt.org/">https://godbolt.org/</a>
</li>

<li>The LLVM Compiler Infrastructure<br />
<a href="https://llvm.org/">https://llvm.org/</a>
</li>

<li>GCC, the GNU Compiler Collection<br />
<a href="https://gcc.gnu.org/">https://gcc.gnu.org/</a>
</li>

<li>Clang<br />
<a href="https://clang.llvm.org/">https://clang.llvm.org/</a>
</li>

<li>Clang: Assembling a Complete Toolchain<br />
<a href="https://clang.llvm.org/docs/Toolchain.html">https://clang.llvm.org/docs/Toolchain.html</a>
</li>

<li>Integer overflow<br />
<a href="https://en.wikipedia.org/wiki/Integer_overflow">https://en.wikipedia.org/wiki/Integer_overflow</a>
</li>

<li>SETcc — Set Byte on Condition<br />
<a href="https://www.felixcloutier.com/x86/setcc">https://www.felixcloutier.com/x86/setcc</a>
</li>

<li>The ARMv8 instruction sets<br />
<a href="http://infocenter.arm.com/help/index.jsp?topic=/com.arm.doc.den0024a/ch05s01.html">http://infocenter.arm.com/help/index.jsp?topic=/com.arm.doc.den0024a/ch05s01.html</a>
</li>

<li>A64 Instruction Set<br />
<a href="https://developer.arm.com/products/architecture/instruction-sets/a64-instruction-set">https://developer.arm.com/products/architecture/instruction-sets/a64-instruction-set</a>
</li>

<li>Switching between the instruction sets<br />
<a href="http://infocenter.arm.com/help/index.jsp?topic=/com.arm.doc.den0024a/ch05s01.html">http://infocenter.arm.com/help/index.jsp?topic=/com.arm.doc.den0024a/ch05s01.html</a>
</li>

<li>The A64 instruction set<br />
<a href="http://infocenter.arm.com/help/index.jsp?topic=/com.arm.doc.den0024a/ch05s01.html">http://infocenter.arm.com/help/index.jsp?topic=/com.arm.doc.den0024a/ch05s01.html</a>
</li>

<li>Introduction to ARMv8 64-bit Architecture<br />
<a href="https://quequero.org/2014/04/introduction-to-arm-architecture/">https://quequero.org/2014/04/introduction-to-arm-architecture/</a>
</li>

<li>Undefined behavior (Wikipedia)<br />
<a href="https://en.wikipedia.org/wiki/Undefined_behavior">https://en.wikipedia.org/wiki/Undefined_behavior</a>
</li>

<li>Is signed integer overflow still undefined behavior in C++?<br />
<a href="https://stackoverflow.com/questions/16188263/is-signed-integer-overflow-still-undefined-behavior-in-c">https://stackoverflow.com/questions/16188263/is-signed-integer-overflow-still-undefined-behavior-in-c</a>
</li>

<li>Allowing signed integer overflows in C/C++<br />
<a href="https://stackoverflow.com/questions/4240748/allowing-signed-integer-overflows-in-c-c">https://stackoverflow.com/questions/4240748/allowing-signed-integer-overflows-in-c-c</a>
</li>

<li>SXTB, SXTH, SXTW<br />
<a href="https://www.scs.stanford.edu/~zyedidia/arm64/sxtb_z_p_z.html">https://www.scs.stanford.edu/~zyedidia/arm64/sxtb_z_p_z.html</a>
</li>

<li>BX, BXNS<br />
<a href="https://developer.arm.com/documentation/100076/0200/a32-t32-instruction-set-reference/a32-and-t32-instructions/bx--bxns?lang=en">https://developer.arm.com/documentation/100076/0200/a32-t32-instruction-set-reference/a32-and-t32-instructions/bx--bxns?lang=en</a>
</li>

<li>Carry and Borrow Principles<br />
<a href="https://www.tpub.com/neets/book13/53a.htm">https://www.tpub.com/neets/book13/53a.htm</a>
</li>

<li>In binary subtraction, how do you handle a borrow when there are no bits left to borrow form<br />
<a href="https://stackoverflow.com/questions/68629408/in-binary-subtraction-how-do-you-handle-a-borrow-when-there-are-no-bits-left-to">https://stackoverflow.com/questions/68629408/in-binary-subtraction-how-do-you-handle-a-borrow-when-there-are-no-bits-left-to</a>
</li>

<li>Is there any legitimate use for Intel's RDRAND?<br />
<a href="https://stackoverflow.com/questions/26771329/is-there-any-legitimate-use-for-intels-rdrand">https://stackoverflow.com/questions/26771329/is-there-any-legitimate-use-for-intels-rdrand</a>
</li>

<li>Intel® Digital Random Number Generator (DRNG) Software Implementation Guide<br />
<a href="https://www.intel.com/content/www/us/en/developer/articles/guide/intel-digital-random-number-generator-drng-software-implementation-guide.html">https://www.intel.com/content/www/us/en/developer/articles/guide/intel-digital-random-number-generator-drng-software-implementation-guide.html</a>
</li>

<li>Hardware random number generator<br />
<a href="https://en.wikipedia.org/wiki/Hardware_random_number_generator">https://en.wikipedia.org/wiki/Hardware_random_number_generator</a>
</li>

<li>Random number generator attack<br />
<a href="https://en.wikipedia.org/wiki/Random_number_generator_attack">https://en.wikipedia.org/wiki/Random_number_generator_attack</a>
</li>

<li>random_r.c (Glibc)<br />
<a href="https://github.com/lattera/glibc/blob/master/stdlib/random_r.c#L341">https://github.com/lattera/glibc/blob/master/stdlib/random_r.c#L341</a>
</li>

<li>Xorshift<br />
<a href="https://en.wikipedia.org/wiki/Xorshift">https://en.wikipedia.org/wiki/Xorshift</a>
</li>

<li>x86 instruction listings<br />
<a href="https://en.wikipedia.org/wiki/X86_instruction_listings">https://en.wikipedia.org/wiki/X86_instruction_listings</a>
</li>

<li>Odd inline asm code generation with pointless memory operand<br />
<a href="https://github.com/llvm/llvm-project/issues/56789">https://github.com/llvm/llvm-project/issues/56789</a>
</li>

<li>Bit scanning equivalencies<br />
<a href="https://fgiesen.wordpress.com/2013/10/18/bit-scanning-equivalencies/">https://fgiesen.wordpress.com/2013/10/18/bit-scanning-equivalencies/</a>
</li>

<li>BSF — Bit Scan Forward<br />
<a href="https://www.felixcloutier.com/x86/bsf">https://www.felixcloutier.com/x86/bsf</a>
</li>

<li>BSR — Bit Scan Reverse<br />
<a href="https://www.felixcloutier.com/x86/bsr">https://www.felixcloutier.com/x86/bsr</a>
</li>

<li>TZCNT — Count the Number of Trailing Zero Bits<br />
<a href="https://www.felixcloutier.com/x86/tzcnt">https://www.felixcloutier.com/x86/tzcnt</a>
</li>

<li>LZCNT — Count the Number of Leading Zero Bits<br />
<a href="https://www.felixcloutier.com/x86/lzcnt">https://www.felixcloutier.com/x86/lzcnt</a>
</li>

</ol>



<p></p><p></p>
<p><small>Autor: <a href="https://github.com/tisnik/">Pavel Tišnovský</a> &nbsp; 2025</small></p>
</body>
</html>

