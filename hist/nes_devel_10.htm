<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
        "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html>
<head>
<title>Vývoj pro osmibitovou herní konzoli NES s využitím překladače jazyka C</title>
<meta name="Author" content="Pavel Tisnovsky" />
<meta name="Generator" content="vim" />
<meta http-equiv="content-type" content="text/html; charset=utf-8" />
<style type="text/css">
         body {color:#000000; background:#ffffff;}
         h1  {font-family: arial, helvetica, sans-serif; color:#ffffff; background-color:#c00000; text-align:center; padding-left:1em}
         h2  {font-family: arial, helvetica, sans-serif; color:#ffffff; background-color:#0000c0; padding-left:1em; text-align:left}
         h3  {font-family: arial, helvetica, sans-serif; color:#000000; background-color:#c0c0c0; padding-left:1em; text-align:left}
         h4  {font-family: arial, helvetica, sans-serif; color:#000000; background-color:#e0e0e0; padding-left:1em; text-align:left}
         a   {font-family: arial, helvetica, sans-serif;}
         li  {font-family: arial, helvetica, sans-serif; color:#000000; text-align:justify; width:450px;}
         ol  {font-family: arial, helvetica, sans-serif; color:#000000; text-align:justify; width:450px;}
         ul  {font-family: arial, helvetica, sans-serif; color:#000000; text-align:justify; width:450px;}
         p   {font-family: arial, helvetica, sans-serif; color:#000000; text-align:justify;}
         pre {background:#e0e0e0}
</style>
</head>

<body>

<h1>Vývoj pro osmibitovou herní konzoli NES s využitím překladače jazyka C</h1>

<h3>Pavel Tišnovský</h3>

<p></p>

<h1>Úvodník</h1>

<p>V desáté a současně i předposlední části seriálu o vývoji her pro historickou herní konzoli si ukážeme, jakým způsobem je možné namísto assembleru (nebo společně s assemblerem) využít i programovací jazyk C. Konkrétně si ukážeme použití překladače CC65 společně s knihovnou NESlib.</p>



<h2>Obsah</h2>

<p><a href="#k01">1. Vývoj pro osmibitovou herní konzoli NES s&nbsp;využitím překladače jazyka C</a></p>
<p><a href="#k02">2. Struktura jednoduchého projektu pro NES založeného na jazyku C</a></p>
<p><a href="#k03">3. Zdrojový kód kostry projektu</a></p>
<p><a href="#k04">4. Soubor <strong>crt0.s</strong> s&nbsp;inicializačním kódem</a></p>
<p><a href="#k05">5. Knihovna <strong>neslib</strong></a></p>
<p><a href="#k06">6. Překlad a slinkování celého projektu</a></p>
<p><a href="#k07">7. Výsledek překladu ve formě assembleru</a></p>
<p><a href="#k08">8. Spuštění vygenerovaného obrazu cartridge</a></p>
<p><a href="#k09">9. Přístup do paměti PPU &ndash; vykreslení pozadí herní scény</a></p>
<p><a href="#k10">10. Výsledek překladu do assembleru</a></p>
<p><a href="#k11">11. Modifikace barvových atributů</a></p>
<p><a href="#k12">12. Výsledek překladu do assembleru</a></p>
<p><a href="#k13">13. Využití definice dlaždic z&nbsp;herního světa Maria</a></p>
<p><a href="#k14">14. Výsledek překladu do assembleru</a></p>
<p><a href="#k15">*** 15. Specifikace, která sada dlaždic se má použít pro vykreslování pozadí</a></p>
<p><a href="#k16">*** 16. Opravený příklad ze třinácté kapitoly</a></p>
<p><a href="#k17">*** 17. Výsledek překladu do assembleru</a></p>
<p><a href="#k18">18. Obsah závěrečné části seriálu</a></p>
<p><a href="#k19">19. Repositář s&nbsp;demonstračními příklady</a></p>
<p><a href="#k20">20. Odkazy na Internetu</a></p>



<p><a name="k01"></a></p>
<h2 id="k01">1. Vývoj pro osmibitovou herní konzoli NES s&nbsp;využitím překladače jazyka C</h2>

<p>Jak je z&nbsp;demonstračních příkladů, které jsme si prozatím <a
href="https://www.root.cz/serialy/vyvoj-her-pro-herni-konzoli-nes/">v&nbsp;seriálu
o vývoji pro slavnou osmibitovou herní konzoli NES ukázali</a> ukázali, patrné,
je možné s&nbsp;využitím &bdquo;pouhého&ldquo; assembleru napsat i relativně
složitý kód. V&nbsp;minulosti se ostatně v&nbsp;assembleru psaly celé hry. Je
to umožněno mj.&nbsp;i možností pojmenovat si všechna důležitá paměťová místa i
hodnoty, dále možností deklarovat subrutiny (podprogramy) a v&nbsp;neposlední
řadě nesmíme zapomenout ani na význam maker, zejména maker s&nbsp;parametry
(tato makra jsou v&nbsp;assembleru <strong>ca65</strong> plně podporována). I
přesto je však tvorba větších aplikací přímo v&nbsp;assembleru
komplikovaná.</p>

<p>Z&nbsp;tohoto důvodu si v&nbsp;dnešním článku ukážeme práci
s&nbsp;překladačem programovacího jazyka C, jehož varianta určená pro
osmibitový mikroprocesor MOS 6502 se jmenuje <strong>cc65</strong> (viz též
články <a
href="https://www.root.cz/clanky/prekladace-jazyka-c-pro-historicke-osmibitove-mikroprocesory/">[1]</a>
a <a
href="https://www.root.cz/clanky/prekladace-programovaciho-jazyka-c-pro-historicke-osmibitove-mikroprocesory-2/">[2]</a>
věnované konkrétním vlastnostem tohoto céčka a odlišnostmi od ANSI či ISO C).
Na rozdíl do překladačů programovacího jazyka C určeného pro moderní rychlé
mikroprocesory je však nutné při použití <strong>cc65</strong> přemýšlet o tom,
jak se konkrétní jazykové konstrukce přeloží do sekvence strojových instrukcí.
V&nbsp;opačném případě by výsledný strojový kód byl příliš velký a především
pomalý, což není v&nbsp;případě herní konzole NES akceptovatelné (nelze říct
&bdquo;kupte si lepší CPU&ldquo;).</p>

<p><div class="rs-tip-major">Poznámka: ze stejného důvodu se na NESu
nepoužívají interpretované jazyky typu BASIC, i když několik pokusů o využití
interpretovaných jazyků existovalo.</div></p>

<p>Překladač <strong>cc65</strong> taktéž programátorům nabízí ucelený pohled
na celý projekt, a to včetně inicializačního kódu (&bdquo;co je spuštěno před
<i>main</i>?&ldquo;), tvorby základních knihoven prakticky na zelené louce,
struktury výsledného obrazu cartridge atd. Tj.&nbsp;může se jednat i o poměrně
zajímavou učební pomůcku.</p>



<p><a name="k02"></a></p>
<h2 id="k02">2. Struktura jednoduchého projektu pro NES založeného na jazyku C</h2>

<p>Podívejme se nyní na strukturu velmi jednoduchého projektu se zdrojovými
kódy pro herní konzoli NES. Tento projekt je sice založen na jazyku C, ale
obsahuje i dva soubory zapsané v&nbsp;assembleru &ndash; inicializační kód a
implementaci knihovny. Celý projekt naleznete na adrese <a
href="https://github.com/tisnik/8bit-fame/blob/master/NES-cc65/01_Intro/">https://github.com/tisnik/8bit-fame/blob/master/NES-cc65/01_Intro/</a>:</p>

<pre>
-rw-rw-r-- 1 ptisnovs ptisnovs  8192 Dec 23 16:46 Alpha.chr
-rw-rw-r-- 1 ptisnovs ptisnovs  4221 Dec 24 08:47 crt0.s
-rw-rw-r-- 1 ptisnovs ptisnovs   635 Dec 24 09:00 intro.c
-rw-rw-r-- 1 ptisnovs ptisnovs   418 Dec 24 08:59 Makefile
-rw-rw-r-- 1 ptisnovs ptisnovs  8877 Dec 23 16:46 neslib.h
-rw-rw-r-- 1 ptisnovs ptisnovs 14481 Dec 24 08:46 neslib.s
-rw-rw-r-- 1 ptisnovs ptisnovs  2019 Dec 23 16:46 nrom_32k_vert.cfg
</pre>

<p>Jaký je však význam jednotlivých souborů? To je uvedeno v&nbsp;další
tabulce:</p>

<table>
<tr><th>Soubor</th><th>Stručný popis souboru</th><th>Popsáno v</th></tr>
<tr><td>Alpha.chr</td><td>binární soubor s&nbsp;definicí dlaždic pozadí i spritů (4kB+4kB)</td><td><a href="https://www.root.cz/clanky/vyvoj-her-pro-herni-konzoli-nes-zobrazeni-pozadi-priorita-spritu-vuci-pozadi/"></a></td></tr>
<tr><td>intro.c</td><td>vlastní zdrojový kód demonstračního příkladu</td><td><a href="#k03">třetí kapitola</a></td></tr>
<tr><td>crt0.s</td><td>inicializační kód spuštěný před <strong>main</strong></td><td><a href="#04">čtvrtá kapitola</a></td></tr>
<tr><td>neslib.h</td><td>hlavičkový soubor &bdquo;standardní&ldquo; knihovny pro NES</td><td><a href="#k05">pátá kapitola</a></td></tr>
<tr><td>neslib.s</td><td>implementace funkcí ze standardní knihovny (assembler)</td><td><a href="#k05">pátá kapitola</a></td></tr>
<tr><td>Makefile</td><td>pravidla pro překlad a slinkování příkladu do formy NES cartridge</td><td><a href="#k06">šestá kaptiola</a></td></tr>
<tr><td>nrom_32k_vert.cfg</td><td>konfigurace pro linker <strong>ld65</strong></td><td>&times;</td></tr>
</table>



<p><a name="k03"></a></p>
<h2 id="k03">3. Zdrojový kód kostry projektu</h2>

<p>Podívejme se nyní na základ celého projektu; konkrétně na soubor nazvaný
<strong>intro.c</strong>, jenž obsahuje kostru aplikace (dema, hry) určené pro
herní konzoli NES. Jedná se o zdrojový kód napsaný v&nbsp;C určený pro překlad
céčkovým překladačem <strong>cc65</strong>. Až na řádek
<strong>#pragma</strong> se vlastně jedná o standardní céčko:</p>

<pre>
#include "neslib.h"
&nbsp;
#define BLACK_COLOR      0x0f
#define DARK_GRAY_COLOR  0x00
#define LIGHT_GRAY_COLOR 0x10
#define WHITE_COLOR      0x30
#define MARIO_BACKGROUND_COLOR 0x22
&nbsp;
#pragma bss-name(push, "ZEROPAGE")
&nbsp;
const unsigned char <strong>palette</strong>[] = {
    MARIO_BACKGROUND_COLOR, DARK_GRAY_COLOR, LIGHT_GRAY_COLOR, WHITE_COLOR,
    BLACK_COLOR, BLACK_COLOR, BLACK_COLOR, BLACK_COLOR,
    BLACK_COLOR, BLACK_COLOR, BLACK_COLOR, BLACK_COLOR,
    BLACK_COLOR, BLACK_COLOR, BLACK_COLOR, BLACK_COLOR
};
&nbsp;
void <strong>game_loop</strong>(void)
{
    while (1) {
    }
}
&nbsp;
void <strong>main</strong>(void)
{
    ppu_off();
    pal_bg(palette);
    ppu_on_all();
&nbsp;
    game_loop();
}
</pre>

<p><div class="rs-tip-major">Poznámka: tento zdrojový kód naleznete na adrese
<a
href="https://github.com/tisnik/8bit-fame/blob/master/NES-cc65/01_Intro/intro.c">https://github.com/tisnik/8bit-fame/blob/master/NES-cc65/01_Intro/intro.c</a>.</div></p>

<p>Celý program z&nbsp;pohledu céčkovského programátora začíná funkcí
<strong>main</strong>. Zde se provádí pouhé čtyři operace, které jsme prozatím
museli realizovat přímo v&nbsp;assembleru:</p>

<ol>
<li>Zákaz vykreslování obrazu čipem PPU</li>
<li>Nastavení barvové palety pozadí (background)</li>
<li>Povolení vykreslování obrazu čipem PPU</li>
<li>Vstup do (nekonečné) herní smyčky</li>
</ol>

<p>Tyto čtyři operace se v&nbsp;céčku realizují triviálně:</p>

<pre>
void <strong>main</strong>(void)
{
    ppu_off();
    pal_bg(palette);
    ppu_on_all();
&nbsp;
    game_loop();
}
</pre>

<p>Samozřejmě musíme specifikovat i data pro paletu barev použitou pro pozadí
herní scény. Připomeňme si, že barvová paleta pozadí obsahuje osmibitové indexy
šestnácti barev, takže pozadí můžeme snadno realizovat polem hodnot typu
<strong>unsigned char</strong>:</p>

<pre>
#define BLACK_COLOR      0x0f
#define DARK_GRAY_COLOR  0x00
#define LIGHT_GRAY_COLOR 0x10
#define WHITE_COLOR      0x30
#define MARIO_BACKGROUND_COLOR 0x22
&nbsp;
const unsigned char <strong>palette</strong>[] = {
    MARIO_BACKGROUND_COLOR, DARK_GRAY_COLOR, LIGHT_GRAY_COLOR, WHITE_COLOR,
    BLACK_COLOR, BLACK_COLOR, BLACK_COLOR, BLACK_COLOR,
    BLACK_COLOR, BLACK_COLOR, BLACK_COLOR, BLACK_COLOR,
    BLACK_COLOR, BLACK_COLOR, BLACK_COLOR, BLACK_COLOR
};
</pre>

<img src="http://i.iinfo.cz/images/357/8417-1.png" width="256" height="76" alt="&#160;" />
<p><i>Obrázek 1: Sada barev používaná herní konzolí NES.</i></p>

<p>Dále ve zdrojovém kódu nalezneme tento řádek:</p>

<pre>
#pragma bss-name(push, "ZEROPAGE")
</pre>

<p>Za tímto řádkem lze zapsat deklarace globálních proměnných, které budou
uloženy do nulté stránky paměti, ke které mikroprocesor MOS 6502 přistupuje
rychleji a s&nbsp;využitím kratších instrukcí, než k&nbsp;ostatním
stránkám.</p>

<p>Zbytek zdrojového kódu je jednoduchý &ndash; jedná se o implementaci
(nekonečné) herní smyčky, kterou můžeme zapsat například takto:</p>

<pre>
void <strong>game_loop</strong>(void)
{
    while (1) {
    }
}
</pre>

<p><div class="rs-tip-major">Poznámka: pokud by tato smyčka nebyla zavolána,
pokračoval by mikroprocesor v&nbsp;interpretaci instrukcí uvedených až za kódem
programu, což by u klasického NESu způsobilo &bdquo;zatuhnutí&ldquo; nebo reset
herní konzole, v&nbsp;případě emulátoru pak většinou detekci nekorektní
instrukce.</div></p>



<p><a name="k04"></a></p>
<h2 id="k04">4. Soubor <strong>crt0.s</strong> s&nbsp;inicializačním kódem</h2>

<p>V&nbsp;projektu se kromě samotného zdrojového kódu <strong>intro.c</strong>
nachází i další důležité soubory, o nichž jsme se ve stručnosti zmínili <a
href="#k02">ve druhé kapitole</a>. Jedná se především o soubor pojmenovaný
<strong>crt0.s</strong>, tedy o soubor obsahující zdrojový kód psaný
v&nbsp;assembleru (ostatně právě proto má koncovku .s). Jméno
<strong>crt0</strong> může napovídat, že tento soubor obsahuje inicializační
kód, který je spuštěn ještě před zavoláním funkce <strong>main</strong>,
resp.&nbsp;přesněji řečeno před sekvencí instrukcí, které vzniknou překladem
zdrojového kódu funkce <strong>main</strong>. Musíme si totiž uvědomit, že NES
neobsahuje žádnou ROM s&nbsp;BIOSem ani operačním systémem, takže i samotná
inicializace herní konzole po RESETu je plně ponechána na programátorovi.</p>

<p>A právě tato inicializace mikroprocesoru i všech dalších čipů herní konzole
NES (především pak čipu PPU, jenž se stará o zobrazení herní scény) je popsána
v&nbsp;souboru <strong>crt0.s</strong>. Povšimněte si, že se provádí již
zmíněná inicializace PPU, smazání video paměti, čekání na dokončení minimálně
dvou snímků (tedy na stabilizaci činnosti všech čipů) a až na konci je proveden
skok na kód funkce <strong>main</strong>:</p>

<pre>
<i>; Startup code for cc65 and Shiru's NES library</i>
<i>; based on code by Groepaz/Hitmen &lt;groepaz@gmx.net&gt;, Ullrich von Bassewitz &lt;uz@cc65.org&gt;</i>
&nbsp;
&nbsp;
&nbsp;
FT_BASE_ADR     = $0100     ;page in RAM, should be $xx00
FT_DPCM_OFF     = $f000     ;$c000..$ffc0, 64-byte steps
FT_SFX_STREAMS  = 1         ;number of sound effects played at once, 1..4
&nbsp;
FT_THREAD       = 1     ;undefine if you call sound effects in the same thread as sound update
FT_PAL_SUPPORT  = 1     ;undefine to exclude PAL support
FT_NTSC_SUPPORT = 1     ;undefine to exclude NTSC support
FT_DPCM_ENABLE  = 0     ;undefine to exclude all DMC code
FT_SFX_ENABLE   = 1     ;undefine to exclude all sound effects code
&nbsp;
&nbsp;
&nbsp;
&nbsp;
&nbsp;
<i>;REMOVED initlib</i>
<i>;this called the CONDES function</i>
&nbsp;
    .export _exit,__STARTUP__:absolute=1
    .import push0,popa,popax,_main,zerobss,copydata
&nbsp;
<i>; Linker generated symbols</i>
    .import __STACK_START__   ,__STACKSIZE__ ;changed
    .import __ROM0_START__  ,__ROM0_SIZE__
    .import __STARTUP_LOAD__,__STARTUP_RUN__,__STARTUP_SIZE__
    .import __CODE_LOAD__   ,__CODE_RUN__   ,__CODE_SIZE__
    .import __RODATA_LOAD__ ,__RODATA_RUN__ ,__RODATA_SIZE__
    .import NES_MAPPER, NES_PRG_BANKS, NES_CHR_BANKS, NES_MIRRORING
&nbsp;
    .importzp _PAD_STATE, _PAD_STATET ;added
    .include "zeropage.inc"
&nbsp;
&nbsp;
&nbsp;
&nbsp;
&nbsp;
&nbsp;
PPU_CTRL    =$2000
PPU_MASK    =$2001
PPU_STATUS  =$2002
PPU_OAM_ADDR=$2003
PPU_OAM_DATA=$2004
PPU_SCROLL  =$2005
PPU_ADDR    =$2006
PPU_DATA    =$2007
PPU_OAM_DMA =$4014
PPU_FRAMECNT=$4017
DMC_FREQ    =$4010
CTRL_PORT1  =$4016
CTRL_PORT2  =$4017
&nbsp;
OAM_BUF     =$0200
PAL_BUF     =$01c0
VRAM_BUF    =$0700
&nbsp;
&nbsp;
&nbsp;
.segment "ZEROPAGE"
&nbsp;
NTSC_MODE:          .res 1
FRAME_CNT1:         .res 1
FRAME_CNT2:         .res 1
VRAM_UPDATE:        .res 1
NAME_UPD_ADR:       .res 2
NAME_UPD_ENABLE:    .res 1
PAL_UPDATE:         .res 1
PAL_BG_PTR:         .res 2
PAL_SPR_PTR:        .res 2
SCROLL_X:           .res 1
SCROLL_Y:           .res 1
SCROLL_X1:          .res 1
SCROLL_Y1:          .res 1
PAD_STATE:          .res 2      ;one byte per controller
PAD_STATEP:         .res 2
PAD_STATET:         .res 2
PPU_CTRL_VAR:       .res 1
PPU_CTRL_VAR1:      .res 1
PPU_MASK_VAR:       .res 1
RAND_SEED:          .res 2
FT_TEMP:            .res 3
&nbsp;
TEMP:               .res 11
SPRID:              .res 1
&nbsp;
PAD_BUF     =TEMP+1
&nbsp;
PTR         =TEMP   ;word
LEN         =TEMP+2 ;word
NEXTSPR     =TEMP+4
SCRX        =TEMP+5
SCRY        =TEMP+6
SRC         =TEMP+7 ;word
DST         =TEMP+9 ;word
&nbsp;
RLE_LOW     =TEMP
RLE_HIGH    =TEMP+1
RLE_TAG     =TEMP+2
RLE_BYTE    =TEMP+3
&nbsp;
<i>;nesdoug code requires</i>
VRAM_INDEX:         .res 1
META_PTR:           .res 2
DATA_PTR:           .res 2
&nbsp;
&nbsp;
&nbsp;
&nbsp;
&nbsp;
.segment "HEADER"
&nbsp;
    .byte $4e,$45,$53,$1a
    .byte &lt;NES_PRG_BANKS
    .byte &lt;NES_CHR_BANKS
    .byte &lt;NES_MIRRORING|(&lt;NES_MAPPER&lt;&lt;4)
    .byte &lt;NES_MAPPER&amp;$f0
    .res 8,0
&nbsp;
&nbsp;
&nbsp;
.segment "STARTUP"
&nbsp;
start:
_exit:
&nbsp;
    sei
    cld
    ldx #$40
    stx CTRL_PORT2
    ldx #$ff
    txs
    inx
    stx PPU_MASK
    stx DMC_FREQ
    stx PPU_CTRL        ;no NMI
&nbsp;
initPPU:
    bit PPU_STATUS
@1:
    bit PPU_STATUS
    bpl @1
@2:
    bit PPU_STATUS
    bpl @2
&nbsp;
clearPalette:
    lda #$3f
    sta PPU_ADDR
    stx PPU_ADDR
    lda #$0f
    ldx #$20
@1:
    sta PPU_DATA
    dex
    bne @1
&nbsp;
clearVRAM:
    txa
    ldy #$20
    sty PPU_ADDR
    sta PPU_ADDR
    ldy #$10
@1:
    sta PPU_DATA
    inx
    bne @1
    dey
    bne @1
&nbsp;
clearRAM:
    txa
@1:
    sta $000,x
    sta $100,x
    sta $200,x
    sta $300,x
    sta $400,x
    sta $500,x
    sta $600,x
    sta $700,x
    inx
    bne @1
&nbsp;
    lda #4
    jsr _pal_bright
    jsr _pal_clear
    jsr _oam_clear
&nbsp;
    jsr zerobss
    jsr copydata
&nbsp;
    lda #&lt;(__STACK_START__+__STACKSIZE__) ;changed
    sta sp
    lda #&gt;(__STACK_START__+__STACKSIZE__)
    sta sp+1            ; Set argument stack ptr
&nbsp;
<i>;   jsr initlib</i>
<i>; removed. this called the CONDES function</i>
&nbsp;
    lda #%10000000
    sta &lt;PPU_CTRL_VAR
    sta PPU_CTRL        ;enable NMI
    lda #%00000110
    sta &lt;PPU_MASK_VAR
&nbsp;
waitSync3:
    lda &lt;FRAME_CNT1
@1:
    cmp &lt;FRAME_CNT1
    beq @1
&nbsp;
detectNTSC:
    ldx #52             ;blargg's code
    ldy #24
@1:
    dex
    bne @1
    dey
    bne @1
&nbsp;
    lda PPU_STATUS
    and #$80
    sta &lt;NTSC_MODE
&nbsp;
    jsr _ppu_off
&nbsp;
    lda #0
    ldx #0
    jsr _set_vram_update
&nbsp;
    lda #$fd
    sta &lt;RAND_SEED
    sta &lt;RAND_SEED+1
&nbsp;
    lda #0
    sta PPU_SCROLL
    sta PPU_SCROLL
&nbsp;
    jmp _main           ;no parameters
&nbsp;
    .include "neslib.s"
&nbsp;
&nbsp;
.segment "RODATA"
&nbsp;
music_data:
<i>;   .include "music.s"</i>
&nbsp;
&nbsp;
&nbsp;
    .if(FT_SFX_ENABLE)
sounds_data:
<i>;   .include "sounds.s"</i>
    .endif
&nbsp;
&nbsp;
&nbsp;
.segment "SAMPLES"
<i>;   .incbin "music_dpcm.bin"</i>
&nbsp;
&nbsp;
&nbsp;
.segment "VECTORS"
&nbsp;
    .word nmi   ;$fffa vblank nmi
    .word start ;$fffc reset
    .word irq   ;$fffe irq / brk
&nbsp;
&nbsp;
.segment "CHARS"
&nbsp;
    .incbin "Alpha.chr"
</pre>

<p><div class="rs-tip-major">Poznámka: pro porovnání se podívejme na to, jak
jsme inicializaci NESu prováděli přímo v&nbsp;assembleru. Některé sekvence
instrukcí jsou zcela totožné:</div></p>

<pre>
<i>; Obslužná rutina pro RESET</i>
&nbsp;
.proc reset
        <i>; nastavení stavu CPU</i>
        setup_cpu
&nbsp;
        <i>; nastavení řídicích registrů</i>
        ldx #$40
        stx $4017        <i>; zákaz IRQ z APU</i>
&nbsp;
        ldx #$00
        stx PPUCTRL      <i>; nastavení PPUCTRL = 0 (NMI)</i>
        stx PPUMASK      <i>; nastavení PPUMASK = 0</i>
        stx DMC_FREQ     <i>; zákaz DMC IRQ</i>
&nbsp;
        ldx #$40
        stx $4017        <i>; interrupt inhibit bit</i>
&nbsp;
        <i>; čekání na vnitřní inicializaci PPU (dva snímky)</i>
        wait_for_frame
        wait_for_frame
&nbsp;
        <i>; vymazání obsahu RAM</i>
        clear_ram
&nbsp;
        <i>; čekání na další snímek</i>
        wait_for_frame
&nbsp;
        cli              <i>; vynulování bitu I - povolení přerušení</i>
        lda #%10010000      
        sta PPUCTRL      <i>; při každém VBLANK se vyvolá NMI (důležité!)</i>
.endproc
</pre>



<p><a name="k05"></a></p>
<h2 id="k05">5. Knihovna <strong>neslib</strong></h2>

<p>V&nbsp;projektu kromě nezbytného souboru <strong>crt.0</strong> nalezneme i
soubory nazvané <strong>neslib.h</strong> a <strong>neslib.s</strong>. Jedná se
o obdobu standardní knihovny céčka, která obsahuje konstanty a funkce používané
při ovládání herní konzole NES. Tato knihovna je postupně rozšiřována a
optimalizována, což je ostatně patrné i při pohledu na první řádky
v&nbsp;hlavičkovém souboru <strong>neslib.h</strong>:</p>

<pre>
<i>//NES hardware-dependent functions by Shiru (shiru@mail.ru)</i>
<i>//Feel free to do anything you want with this code, consider it Public Domain</i>
&nbsp;
<i>// for nesdoug version 1.2, 1/1/2022</i>
<i>// changes, removed sprid from oam functions, oam_spr 11% faster, meta 5% faster</i>
&nbsp;
<i>//Versions history:</i>
<i>// 050517 - pad polling code optimized, button bits order reversed</i>
<i>// 280215 - fixed palette glitch caused by the active DMC DMA glitch</i>
<i>// 030914 - minor fixes in the VRAM update system</i>
<i>// 310814 - added vram_flush_update</i>
<i>// 120414 - removed adr argument from vram_write and vram_read,</i>
<i>//          unrle_vram renamed to vram_unrle, with adr argument removed</i>
<i>// 060414 - many fixes and improvements, including sequential VRAM updates</i>
<i>// previous versions were created since mid-2011, there were many updates</i>
</pre>

<p>Samotná knihovna <i>NESlib</i> je sice implementována v&nbsp;assembleru,
ovšem vzhledem k&nbsp;tomu, že její funkce mají být volány z&nbsp;céčka,
obsahuje i hlavičkový soubor <strong>neslib.h</strong>. Ten v&nbsp;první řadě
obsahuje hlavičky funkcí, z&nbsp;nichž prakticky všechny používají modifikátor
<strong>__fastcall__</strong> používaný u běžných NEvariadických funkcí (tedy u
funkcí s&nbsp;pevným počtem parametrů). Díky tomuto modifikátoru je práce
překladače zjednodušena, protože se zkrátí kód pro předávání parametrů.</p>

<p>Nalezneme zde například funkce pro práci s&nbsp;barvovou paletou NESu, které
využijeme v&nbsp;demonstračních příkladech (samotná paleta je představována
polem s&nbsp;prvky typu <strong>char</strong> resp.&nbsp;<strong>unsigned
char</strong>):</p>

<pre>
void __fastcall__ <strong>pal_all</strong>(const char *data);
void __fastcall__ <strong>pal_bg</strong>(const char *data);
void __fastcall__ <strong>pal_spr</strong>(const char *data);
void __fastcall__ <strong>pal_col</strong>(unsigned char index,unsigned char color);
void __fastcall__ <strong>pal_clear</strong>(void);
</pre>

<p>Dále využijeme funkce ovládající čip PPU, jenž generuje v&nbsp;NESu grafický
obraz:</p>

<pre>
void __fastcall__ <strong>ppu_wait_nmi</strong>(void);
void __fastcall__ <strong>ppu_wait_frame</strong>(void);
void __fastcall__ <strong>ppu_off</strong>(void);
void __fastcall__ <strong>ppu_on_all</strong>(void);
</pre>

<p>Z&nbsp;obecných funkcí jedná především o dvojici užitečných funkcí
<strong>memcpy</strong> a <strong>memfil</strong>:</p>

<pre>
void __fastcall__ <strong>memcpy</strong>(void *dst,void *src,unsigned int len);
void __fastcall__ <strong>memfill</strong>(void *dst,unsigned char value,unsigned int len);
</pre>

<p><div class="rs-tip-major">Poznámka: pochopitelně zde (kvůli omezenému
množství ROM na cartridge) nenalezneme například obdobu
<strong>sprintf</strong> ani žádné funkce pro práci s&nbsp;hodnotami
s&nbsp;plovoucí řádovou tečkou atd.</div></p>

<p>Dále v&nbsp;hlavičkovém souboru nalezneme množství užitečných konstant,
například masky příznaků jednotlivých tlačítek ovladačů (D-padů):</p>

<pre>
#define PAD_A                   0x80
#define PAD_B                   0x40
#define PAD_SELECT              0x20
#define PAD_START               0x10
#define PAD_UP                  0x08
#define PAD_DOWN                0x04
#define PAD_LEFT                0x02
#define PAD_RIGHT               0x01
</pre>

<p>Další tři konstanty použijeme příště při práci se sprity &ndash; jedná se o
masky atributů spritů:</p>

<pre>
#define OAM_FLIP_V              0x80
#define OAM_FLIP_H              0x40
#define OAM_BEHIND              0x20
</pre>

<p>V&nbsp;souboru <strong>neslib.h</strong> se taktéž nachází definice několika
adres, například začátků paměťových regionů s&nbsp;uloženými dlaždicemi
pozadí:</p>

<pre>
#define NAMETABLE_A             0x2000
#define NAMETABLE_B             0x2400
#define NAMETABLE_C             0x2800
#define NAMETABLE_D             0x2c00
</pre>

<p>A konečně zde najdeme i několik užitečných maker, zejména makra pro výpočet
adresy v&nbsp;paměťových regionech s&nbsp;uloženými dlaždicemi pozadí:</p>

<pre>
#define NTADR_A(x,y)    (NAMETABLE_A|(((y)&lt;&lt;5)|(x)))
#define NTADR_B(x,y)    (NAMETABLE_B|(((y)&lt;&lt;5)|(x)))
#define NTADR_C(x,y)    (NAMETABLE_C|(((y)&lt;&lt;5)|(x)))
#define NTADR_D(x,y)    (NAMETABLE_D|(((y)&lt;&lt;5)|(x)))
</pre>

<p>Soubor <strong>neslib.s</strong> je napsán v&nbsp;assembleru. Všechny
funkce, jejichž hlavičky jsou uvedeny v&nbsp;souboru <strong>neslib.h</strong>
jsou nejprve exportovány; přesněji řečeno jsou exportovány symboly
s&nbsp;adresami těchto funkcí:</p>

<pre>
.export _pal_all,_pal_bg,_pal_spr,_pal_col,_pal_clear
.export _pal_bright,_pal_spr_bright,_pal_bg_bright
.export _ppu_off,_ppu_on_all,_ppu_on_bg,_ppu_on_spr,_ppu_mask,_ppu_system
.export _oam_clear,_oam_size,_oam_spr,_oam_meta_spr,_oam_hide_rest
.export _ppu_wait_frame,_ppu_wait_nmi
.export _scroll,_split
.export _bank_spr,_bank_bg
.export _vram_read,_vram_write
.export _sfx_play,_sample_play
.export _pad_poll,_pad_trigger,_pad_state
.export _rand8,_rand16,_set_rand
.export _vram_adr,_vram_put,_vram_fill,_vram_inc,_vram_unrle
.export _set_vram_update,_flush_vram_update
.export _memcpy,_memfill,_delay
.export _flush_vram_update2, _oam_set, _oam_get
</pre>

<p>Implementace jednotlivých funkcí vždy začínají návěštím (<i>label</i>),
jehož adresa je následně použita linkerem. Příkladem mohou být funkce
<strong>ppu_off</strong> a <strong>ppu_on_all</strong>, jejichž implementace
v&nbsp;assembleru vypadá takto:</p>

<pre>
<strong>_ppu_off</strong>:
&nbsp;
        lda &lt;PPU_MASK_VAR
        and #%11100111
        sta &lt;PPU_MASK_VAR
        jmp _ppu_wait_nmi
&nbsp;
&nbsp;
<strong>_ppu_on_all</strong>:
&nbsp;
        lda &lt;PPU_MASK_VAR
        ora #%00011000
</pre>

<p>Implementace funkce pracující s&nbsp;barvovou paletou:</p>

<pre>
<strong>_pal_bg</strong>:
&nbsp;
        sta &lt;PTR
        stx &lt;PTR+1
        ldx #$00
        lda #$10
        bne pal_copy ;bra
</pre>

<p>Uvnitř některých implementovaných funkcí se používají lokální návěští:</p>

<pre>
@skipUpd:
&nbsp;
        lda #0
        sta PPU_ADDR
        sta PPU_ADDR
&nbsp;
        lda &lt;SCROLL_X
        sta PPU_SCROLL
        lda &lt;SCROLL_Y
        sta PPU_SCROLL
&nbsp;
        lda &lt;PPU_CTRL_VAR
        sta PPU_CTRL
&nbsp;
@skipAll:
&nbsp;
        lda &lt;PPU_MASK_VAR
        sta PPU_MASK
&nbsp;
        inc &lt;FRAME_CNT1
        inc &lt;FRAME_CNT2
        lda &lt;FRAME_CNT2
        cmp #6
        bne @skipNtsc
        lda #0
        sta &lt;FRAME_CNT2
</pre>

<p>V&nbsp;navazujícím článku využijeme i funkci <strong>oam_clear</strong> pracující s&nbsp;pamětí pro sprity:</p>

<pre>
<strong>_oam_clear</strong>:
&nbsp;
        ldx #0
        stx SPRID <i>; automatically sets sprid to zero</i>
        lda #$ff
@1:
        sta OAM_BUF,x
        inx
        inx
        inx
        inx
        bne @1
        rts
</pre>

<p>A konečně se pro zajímavost podívejme na implementaci funkcí
<strong>memcpy</strong> a <strong>memfill</strong>, u nichž se předpokládá
velká míra optimalizace:</p>

<pre>
<i>;void __fastcall__ memcpy(void *dst,void *src,unsigned int len);</i>
&nbsp;
<strong>_memcpy</strong>:
&nbsp;
        sta &lt;LEN
        stx &lt;LEN+1
        jsr popax
        sta &lt;SRC
        stx &lt;SRC+1
        jsr popax
        sta &lt;DST
        stx &lt;DST+1
&nbsp;
        ldx #0
&nbsp;
@1:
&nbsp;
        lda &lt;LEN+1
        beq @2
        jsr @3
        dec &lt;LEN+1
        inc &lt;SRC+1
        inc &lt;DST+1
        jmp @1
&nbsp;
@2:
&nbsp;
        ldx &lt;LEN
        beq @5
&nbsp;
@3:
&nbsp;
        ldy #0
&nbsp;
@4:
&nbsp;
        lda (SRC),y
        sta (DST),y
        iny
        dex
        bne @4
&nbsp;
@5:
&nbsp;
        rts
&nbsp;
&nbsp;
&nbsp;
<i>;void __fastcall__ memfill(void *dst,unsigned char value,unsigned int len);</i>
&nbsp;
<strong>_memfill</strong>:
&nbsp;
        sta &lt;LEN
        stx &lt;LEN+1
        jsr popa
        sta &lt;TEMP
        jsr popax
        sta &lt;DST
        stx &lt;DST+1
&nbsp;
        ldx #0
&nbsp;
@1:
&nbsp;
        lda &lt;LEN+1
        beq @2
        jsr @3
        dec &lt;LEN+1
        inc &lt;DST+1
        jmp @1
&nbsp;
@2:
&nbsp;
        ldx &lt;LEN
        beq @5
&nbsp;
@3:
&nbsp;
        ldy #0
        lda &lt;TEMP
&nbsp;
@4:
&nbsp;
        sta (DST),y
        iny
        dex
        bne @4
&nbsp;
@5:
&nbsp;
        rts
</pre>

<p><div class="rs-tip-major">Poznámka: obecně platí, že právě
<strong>neslib.s</strong> může být vhodným zdrojem jak pro studium assembleru
pro MOS 6502, tak i způsobu ovládání herní konzole NES.</div></p>



<p><a name="k06"></a></p>
<h2 id="k06">6. Překlad a slinkování celého projektu</h2>

<p>Pro zjednodušení překladu a slinkování celého projektu je určen soubor
<strong>Makefile</strong>, jenž je interpretován standardním nástrojem <i>GNU
Make</i> (není tedy součástí instalace <strong>ca65</strong> ani
<strong>cc65</strong>). V&nbsp;<strong>Makefile</strong> jsou zapsána pravidla
pro překlad zdrojového kódu v&nbsp;C do assembleru, pro překlad souborů
zapsaných v&nbsp;assembleru do objektového kódu i pravidla pro slinkování
objektových souborů do výsledného obrazu NESovské cartridge:</p>

<pre>
CC65 = cc65
CA65 = ca65
LD65 = ld65
NAME = intro
CFG = nrom_32k_vert.cfg
&nbsp;
&nbsp;
.PHONY: default clean
&nbsp;
default: $(NAME).nes
&nbsp;
&nbsp;
$(NAME).nes: $(NAME).o crt0.o $(CFG)
        $(LD65) -C $(CFG) -o $(NAME).nes crt0.o $(NAME).o nes.lib
&nbsp;
crt0.o: crt0.s Alpha.chr
        $(CA65) crt0.s
&nbsp;
$(NAME).o: $(NAME).s
        $(CA65) $(NAME).s -g
&nbsp;
$(NAME).s: $(NAME).c
        $(CC65) -Oirs $(NAME).c --add-source
&nbsp;
clean:
        rm -f $(NAME).nes
        rm -f *.o
</pre>

<p>Překlad provedeme snadno, a to příkazem:</p>

<pre>
$ <strong>make</strong>
</pre>

<p>Měly by se postupně provést následující kroky: překlad zdrojového kódu
(<strong>*.c</strong>) překladačem céčka do assembleru (<strong>*.s</strong>),
dále překlad z&nbsp;kódu zapsaného v&nbsp;assembleru (<strong>*.s</strong>) do
objektového kódu (<strong>*.o</strong>) a následně slinkování do souboru
<strong>intro.nes</strong>, což je obraz cartridge NESu:</p>

<pre>
cc65 -Oirs intro.c --add-source
ca65 intro.s -g
ca65 crt0.s
ld65 -C nrom_32k_vert.cfg -o intro.nes crt0.o intro.o nes.lib
</pre>



<p><a name="k07"></a></p>
<h2 id="k07">7. Výsledek překladu ve formě assembleru</h2>

<p>Překladač <strong>cc65</strong> nevygeneroval přímo objektový kód (tedy
soubory s&nbsp;koncovkou <strong>.o</strong>), ale provedl překlad zdrojových
kódů z&nbsp;céčka do assembleru (s&nbsp;tím, že druhá fáze překladu bude
provedena assemblerem <strong>as65</strong>). Výsledkem překladu souboru
nazvaného <strong>intro.c</strong> je tedy soubor se jménem
<strong>intro.s</strong>, jenž obsahuje, jak je ostatně patrné, pouze kód
získaný překladem céčka &ndash; prozatím se tedy neprovádí spojení s&nbsp;kódem
z&nbsp;knihovny <i>NESlib</i> ani s&nbsp;kódem, jenž je zapsán ve výše zmíněném
souboru <strong>crt0.s</strong>.</p>

<p>Nejprve zde kromě konfiguračních voleb nalezneme import symbolů tří funkcí
z&nbsp;NESlibu a naopak export symbolů tří funkcí, které zapsal přímo
programátor:</p>

<pre>
        .import         _pal_bg
        .import         _ppu_off
        .import         _ppu_on_all
        .export         _palette
        .export         _game_loop
        .export         _main
</pre>

<p>Dále je definována sekce (segment) s&nbsp;neměnnými daty, v&nbsp;nichž je
deklarováno pole s&nbsp;barvovou paletou:</p>

<pre>
.segment        "RODATA"
&nbsp;
_palette:
        .byte   $22
        .byte   $00
        .byte   $10
        ...
        ...
        ...
        .byte   $30
        .byte   $0F
        .byte   $0F
        .byte   $0F
</pre>

<p>A konečně ve vygenerovaném kódu nalezneme i funkce původně psané
v&nbsp;jazyku C, které byly přeloženy do assembleru do formy procedur/subrutin.
Příkladem je funkce <strong>game_loop</strong>, jejíž exportovaný symbol je
změněn na <strong>_game_loop</strong>, jak je tomu ve světě céčka dobrým
zvykem:</p>

<pre>
<i>; ---------------------------------------------------------------</i>
<i>; void __near__ game_loop (void)</i>
<i>; ---------------------------------------------------------------</i>
&nbsp;
.segment        "CODE"
&nbsp;
.proc   _game_loop: near
&nbsp;
.segment        "CODE"
&nbsp;
<i>;</i>
<i>; while (1) {</i>
<i>;</i>
L001D:  jmp     L001D
&nbsp;
.endproc
</pre>

<p>Takto vypadá <a
href="https://github.com/tisnik/8bit-fame/blob/master/NES-cc65/01_Intro/intro.s">celý
soubor <strong>intro.s</strong></a> (žádná velká &bdquo;magie&ldquo; zde tedy
není použita; vše je přímočaré):</p>

<pre>
<i>;</i>
<i>; File generated by cc65 v 2.18 - Ubuntu 2.18-1</i>
<i>;</i>
        .fopt           compiler,"cc65 v 2.18 - Ubuntu 2.18-1"
        .setcpu         "6502"
        .smart          on
        .autoimport     on
        .case           on
        .debuginfo      off
        .importzp       sp, sreg, regsave, regbank
        .importzp       tmp1, tmp2, tmp3, tmp4, ptr1, ptr2, ptr3, ptr4
        .macpack        longbranch
        .forceimport    __STARTUP__
        .import         _pal_bg
        .import         _ppu_off
        .import         _ppu_on_all
        .export         _palette
        .export         _game_loop
        .export         _main
&nbsp;
.segment        "RODATA"
&nbsp;
_palette:
        .byte   $22
        .byte   $00
        .byte   $10
        .byte   $30
        .byte   $0F
        .byte   $0F
        .byte   $0F
        .byte   $0F
        .byte   $0F
        .byte   $0F
        .byte   $0F
        .byte   $0F
        .byte   $0F
        .byte   $0F
        .byte   $0F
        .byte   $0F
&nbsp;
<i>; ---------------------------------------------------------------</i>
<i>; void __near__ game_loop (void)</i>
<i>; ---------------------------------------------------------------</i>
&nbsp;
.segment        "CODE"
&nbsp;
.proc   _game_loop: near
&nbsp;
.segment        "CODE"
&nbsp;
<i>;</i>
<i>; while (1) {</i>
<i>;</i>
L001D:  jmp     L001D
&nbsp;
.endproc
&nbsp;
<i>; ---------------------------------------------------------------</i>
<i>; void __near__ main (void)</i>
<i>; ---------------------------------------------------------------</i>
&nbsp;
.segment        "CODE"
&nbsp;
.proc   _main: near
&nbsp;
.segment        "CODE"
&nbsp;
<i>;</i>
<i>; ppu_off();</i>
<i>;</i>
        jsr     _ppu_off
<i>;</i>
<i>; pal_bg(palette);</i>
<i>;</i>
        lda     #&lt;(_palette)
        ldx     #&gt;(_palette)
        jsr     _pal_bg
<i>;</i>
<i>; ppu_on_all();</i>
<i>;</i>
        jsr     _ppu_on_all
<i>;</i>
<i>; game_loop();</i>
<i>;</i>
        jmp     _game_loop
&nbsp;
.endproc
</pre>



<p><a name="k08"></a></p>
<h2 id="k08">8. Spuštění vygenerovaného obrazu cartridge</h2>

<p>Výsledkem překladu a slinkování dnešního prvního demonstračního příkladu je
soubor nazvaný <strong>intro.nes</strong>. Jedná se o přesný obraz cartridge
(resp.&nbsp;paměti v&nbsp;cartridgi) pro reálnou herní konzoli NES. Tento obraz
můžeme spustit v&nbsp;prakticky libovolném emulátoru NESu. V&nbsp;mém případě
používám emulátor nazvaný <i>Nestopia</i>. Náš příklad se v&nbsp;tomto
emulátoru spustí následovně:</p>

<pre>
$ <strong>nestopia intro.nes</strong>
</pre>

<p>Výsledek by měl vypadat následovně:</p>

*** image ***
<p><i>Obrázek 2: Herní scéna zobrazená po spuštění dnešního prvního
demonstračního příkladu v&nbsp;emulátoru herní konzole NES.</i></p>



<p><a name="k09"></a></p>
<h2 id="k09">9. Přístup do paměti PPU &ndash; vykreslení pozadí herní scény</h2>

<p>Připomeňme si, že u herní konzole <i>NES</i> se obraz posílaný na televizor
skládal ze dvou částí: pozadí a pohyblivých spritů. Nejprve si stručně
popíšeme, jakým způsobem se vytvářelo pozadí. Při použití televizní normy PAL
bylo rozlišení obrazu rovno 256&times;240 pixelům, zatímco u normy SECAM bylo
horních osm řádků a spodních osm řádků zatemněných, tj.&nbsp;rozlišení bylo
sníženo na 256&times;224 pixelů. Teoreticky sice bylo možné vytvořit klasický
framebuffer, v&nbsp;němž by bylo celé pozadí uloženo, ale při šestnáctibarevném
obrazu, tj.&nbsp;při použití čtyř bitů na pixel, by musela být kapacita
framebufferu poměrně velká: 28 kilobajtů (navíc je 16 &bdquo;globálních&ldquo;
barev relativně malé množství). Konstruktéři čipu <i>PPU</i> tedy využili
technologii, s&nbsp;níž jsme se seznámili i u dalších typů herních konzolí:
namísto framebufferu byly v&nbsp;obrazové paměti uloženy vzorky o velikosti
8&times;8 pixelů, které byly skládány do mřížky 32&times;30 dlaždic, což přesně
odpovídá již zmíněnému rozlišení 256&times;240 pixelů (32&times;8=256,
30&times;8=240).</p>

<img src="https://i.iinfo.cz/images/130/nes-devel-3.png" class="image-576977" alt="&#160;" title="Autor: tisnik, podle licence: &lt;a href=&quot;https://creativecommons.org/publicdomain/mark/1.0/deed.en&quot;&gt;Public Domain&lt;/a&gt;" width="524" height="617" />
<p><i>Obrázek 3: Takto vypadají dlaždice pro pozadí zobrazené v&nbsp;k&nbsp;tomu určeném grafickém editoru.</i></p>

<p>Pole s&nbsp;indexy dlaždic pro zobrazení pozadí se nazývá <i>tabulka
jmen</i>. Ta je z&nbsp;pohledu PPU (nikoli CPU!) uložena od adresy $2000 a má
délku přesně 960 bajtů (32&times;30). Ihned za touto tabulkou se nachází
tabulka s&nbsp;atributy (použijeme později). Vyplnění této tabulky by
v&nbsp;assembleru vypadalo přibližně takto &ndash; data se přenáší do PPU a pro
jednoduchost přeneseme jen 256 bajtů, tedy jedinou stránku paměti:</p>

<pre>
<i>; načtení tabulky jmen</i>
.proc <strong>load_nametable</strong>
        lda PPUSTATUS         <i>; reset záchytného registru</i>
        lda #&gt;NAME_TABLE_0 <i>; horní bajt adresy</i>
        sta PPUADDR
        lda #&lt;NAME_TABLE_0 <i>; spodní bajt adresy</i>
        sta PPUADDR
&nbsp;
        ldx #$00              <i>; počitadlo</i>
:
        lda nametabledata,X
        sta PPUDATA           <i>; zápis indexu dlaždice</i>
        inx 
        cpx #$80              <i>; chceme přenést 128 bajtů</i>
        bne :-
&nbsp;
        rts                   <i>; návrat ze subrutiny</i>
.endproc
</pre>

<p>V&nbsp;céčku se nemusíme tímto nízkoúrovňovým kódem příliš zabývat, protože
postačuje napsat jednoduchou programovou smyčku, v&nbsp;níž dlaždice vyplníme
hodnotami 0, 1, ...255, 0, 1, .... Povšimněte si, že nejdříve musíme nastavit
ukazatel zápisu na první dlaždici funkcí <strong>vram_adr</strong>
s&nbsp;makrem <strong>NTADR_D</strong> a poté se již ve funkci
<strong>vram_put</strong> specifikují pouze indexy dlaždic, nikoli jejich
souřadnice:</p>

<pre>
void <strong>fill_in_ppu_ram</strong>(void)
{
    vram_adr(NTADR_A(0, 0));
    for (i = 0; i &lt; 32 * 30; i++) {
        vram_put(i);
    }
}
</pre>

<p>Dále si povšimněte, že čítač předchozí programové smyčky, tedy proměnná
<strong>i</strong>, není deklarována jako proměnná lokální, jak by se slušelo.
Takto deklarovaná proměnná by se totiž vytvářela na zásobníku a na tento
koncept není procesor MOS 6502 příliš dobře připraven. Z&nbsp;hlediska
velikosti a rychlosti výsledného kódu je lepší tuto proměnnou deklarovat jako
globální, ovšem uloženou v&nbsp;nulté stránce paměti (s&nbsp;tím, že se
proměnná použije i v&nbsp;dalších částech kódu):</p>

<pre>
#pragma bss-name(push, "ZEROPAGE")
int <strong>i</strong>;
</pre>

<p>Úplný zdrojový kód dnešního druhého demonstračního příkladu bude vypadat
následovně:</p>

<pre>
#include "neslib.h"
&nbsp;
#define BLACK_COLOR      0x0f
#define DARK_GRAY_COLOR  0x00
#define LIGHT_GRAY_COLOR 0x10
#define WHITE_COLOR      0x30
#define MARIO_BACKGROUND_COLOR 0x22
&nbsp;
#pragma bss-name(push, "ZEROPAGE")
int <strong>i</strong>;
&nbsp;
const unsigned char <strong>palette</strong>[] = {
    MARIO_BACKGROUND_COLOR, DARK_GRAY_COLOR, LIGHT_GRAY_COLOR, WHITE_COLOR,
    BLACK_COLOR, BLACK_COLOR, BLACK_COLOR, BLACK_COLOR,
    BLACK_COLOR, BLACK_COLOR, BLACK_COLOR, BLACK_COLOR,
    BLACK_COLOR, BLACK_COLOR, BLACK_COLOR, BLACK_COLOR
};
&nbsp;
void <strong>fill_in_ppu_ram</strong>(void)
{
    vram_adr(NTADR_A(0, 0));
    for (i = 0; i &lt; 32 * 30; i++) {
        vram_put(i);
    }
}
&nbsp;
void <strong>game_loop</strong>(void)
{
    while (1) {
    }
}
&nbsp;
void <strong>main</strong>(void)
{
    ppu_off();
    pal_bg(palette);
    fill_in_ppu_ram();
    ppu_on_all();
&nbsp;
    game_loop();
}
</pre>

*** image ***
<p><i>Obrázek: 4: Takto vypadá tento demonstrační příklad po překladu a
spuštění v&nbsp;emulátoru herní konzole NES.</i></p>



<p><a name="k10"></a></p>
<h2 id="k10">10. Výsledek překladu do assembleru</h2>

<p>Nyní se podívejme na to, jakým způsobem se vlastně přeloží naše nová funkce
<strong>fill_in_ppu_ram</strong>, která mj.&nbsp;obsahuje i programovou smyčku.
Tato funkce začíná specifikací adresy, od níž se má do PPU RAM provádět zápis.
Tato adresa se zapamatuje v&nbsp;interních strukturách NESlibu:</p>

<pre>
<i>;</i>
<i>; vram_adr(NTADR_A(0, 0));</i>
<i>;</i>
        ldx     #$20
        lda     #$00
        jsr     _vram_adr
</pre>

<p><div class="rs-tip-major">Poznámka: konstany 0x20 a 0x00 jsou vypočteny
makrem <strong>NTADR_A</strong>.</div></p>

<p>Následuje samotná realizace programové smyčky. Ta je poměrně složitá,
protože se pracuje s&nbsp;proměnnou <strong>i</strong>, což je šestnáctibitová
hodnota uložená v&nbsp;nulté stránce paměti. Všechny šestnáctibitové operace se
musí rozkládat na dvojici osmibitových operací a navíc je součet
(resp.&nbsp;zvýšení hodnoty <strong>i</strong> o 1) realizován poněkud podivným
způsobem &ndash; testem přetečení ze spodních osmi bajtů následovaný podmíněným
skokem, pokud k&nbsp;přetečení nedošlo (pokud došlo, zvýší se horní bajt
proměnné):</p>

<pre>
        lda     _i
        ldx     _i+1
        clc
        adc     #$01
        bcc     L0023
        inx
L0023:  sta     _i
        stx     _i+1
</pre>

<p>Celá realizace smyčky tedy není v&nbsp;žádném případě optimalizována:</p>

<pre>
<i>;</i>
<i>; for (i = 0; i &lt; 32 * 30; i++) {</i>
<i>;</i>
        lda     #$00
        sta     _i
        sta     _i+1
L001A:  lda     _i
        cmp     #$C0
        lda     _i+1
        sbc     #$03
        bvc     L0021
        eor     #$80
L0021:  bpl     L001B
<i>;</i>
<i>; vram_put(i);</i>
<i>;</i>
        lda     _i
        jsr     _vram_put

        lda     _i
        ldx     _i+1
        clc
        adc     #$01
        bcc     L0023
        inx
L0023:  sta     _i
        stx     _i+1
        jmp     L001A
</pre>

<p>A pro úplnost: takto vypadá <a
href="https://github.com/tisnik/8bit-fame/blob/master/NES-cc65/02_PPU_RAM/ppu_ram.s">celý
soubor <strong>ppu_ram.s</strong></a>:</p>

<pre>
<i>;</i>
<i>; File generated by cc65 v 2.18 - Ubuntu 2.18-1</i>
<i>;</i>
        .fopt           compiler,"cc65 v 2.18 - Ubuntu 2.18-1"
        .setcpu         "6502"
        .smart          on
        .autoimport     on
        .case           on
        .debuginfo      off
        .importzp       sp, sreg, regsave, regbank
        .importzp       tmp1, tmp2, tmp3, tmp4, ptr1, ptr2, ptr3, ptr4
        .macpack        longbranch
        .forceimport    __STARTUP__
        .import         _pal_bg
        .import         _ppu_off
        .import         _ppu_on_all
        .import         _vram_adr
        .import         _vram_put
        .export         _i
        .export         _palette
        .export         _fill_in_ppu_ram
        .export         _game_loop
        .export         _main
&nbsp;
.segment        "RODATA"
&nbsp;
_palette:
        .byte   $22
        .byte   $00
        .byte   $10
        .byte   $30
        .byte   $0F
        .byte   $0F
        .byte   $0F
        .byte   $0F
        .byte   $0F
        .byte   $0F
        .byte   $0F
        .byte   $0F
        .byte   $0F
        .byte   $0F
        .byte   $0F
        .byte   $0F
&nbsp;
.segment        "BSS"
&nbsp;
.segment        "ZEROPAGE"
_i:
        .res    2,$00
&nbsp;
<i>; ---------------------------------------------------------------</i>
<i>; void __near__ fill_in_ppu_ram (void)</i>
<i>; ---------------------------------------------------------------</i>
&nbsp;
.segment        "CODE"
&nbsp;
.proc   _fill_in_ppu_ram: near
&nbsp;
.segment        "CODE"
&nbsp;
<i>;</i>
<i>; vram_adr(NTADR_A(0, 0));</i>
<i>;</i>
        ldx     #$20
        lda     #$00
        jsr     _vram_adr
<i>;</i>
<i>; for (i = 0; i &lt; 32 * 30; i++) {</i>
<i>;</i>
        lda     #$00
        sta     _i
        sta     _i+1
L001A:  lda     _i
        cmp     #$C0
        lda     _i+1
        sbc     #$03
        bvc     L0021
        eor     #$80
L0021:  bpl     L001B
<i>;</i>
<i>; vram_put(i);</i>
<i>;</i>
        lda     _i
        jsr     _vram_put
<i>;</i>
<i>; for (i = 0; i &lt; 32 * 30; i++) {</i>
<i>;</i>
        lda     _i
        ldx     _i+1
        clc
        adc     #$01
        bcc     L0023
        inx
L0023:  sta     _i
        stx     _i+1
        jmp     L001A
<i>;</i>
<i>; }</i>
<i>;</i>
L001B:  rts
&nbsp;
.endproc
&nbsp;
<i>; ---------------------------------------------------------------</i>
<i>; void __near__ game_loop (void)</i>
<i>; ---------------------------------------------------------------</i>
&nbsp;
.segment        "CODE"
&nbsp;
.proc   _game_loop: near
&nbsp;
.segment        "CODE"
&nbsp;
<i>;</i>
<i>; while (1) {</i>
<i>;</i>
L0032:  jmp     L0032
&nbsp;
.endproc
&nbsp;
<i>; ---------------------------------------------------------------</i>
<i>; void __near__ main (void)</i>
<i>; ---------------------------------------------------------------</i>
&nbsp;
.segment        "CODE"
&nbsp;
.proc   _main: near
&nbsp;
.segment        "CODE"
&nbsp;
<i>;</i>
<i>; ppu_off();</i>
<i>;</i>
        jsr     _ppu_off
<i>;</i>
<i>; pal_bg(palette);</i>
<i>;</i>
        lda     #&lt;(_palette)
        ldx     #&gt;(_palette)
        jsr     _pal_bg
<i>;</i>
<i>; fill_in_ppu_ram();</i>
<i>;</i>
        jsr     _fill_in_ppu_ram
<i>;</i>
<i>; ppu_on_all();</i>
<i>;</i>
        jsr     _ppu_on_all
<i>;</i>
<i>; game_loop();</i>
<i>;</i>
        jmp     _game_loop
&nbsp;
.endproc
</pre>



<p><a name="k11"></a></p>
<h2 id="k11">11. Modifikace barvových atributů</h2>

<p>Při definici pozadí herního světa se kromě tabulky s&nbsp;dlaždicemi
(<i>name table</i>) o rozměrech 32&times;30 dlaždic používá i mnohem menší
<i>tabulka atributů</i>. Tato tabulka má velikost pouhých 64 bajtů a obsahuje
horní dva bity (výběr barvové palety) pro oblast o velikosti 4&times;4
dlaždice, tj.&nbsp;32&times;32 pixelů. I tuto tabulku můžeme v&nbsp;céčku velmi
snadno modifikovat resp.&nbsp;vyplnit, protože nám knihovna NESlib dává
k&nbsp;dispozici potřebné funkce. Zkusme tedy vyplnit vždy jednu čtvrtinu této
tabulky (tedy šestnáct bajtů) stejnou hodnotou. Výsledkem by mělo být, že na
obrazovce se objeví čtyři regiony, každý s&nbsp;odlišnou barvou dlaždic:</p>

<pre>
void <strong>fill_in_attributes</strong>(void)
{
    vram_adr(ATTRIBUTE_TABLE);
&nbsp;
    vram_fill(0, 16);
    vram_fill(0x55, 16);
    vram_fill(0xAA, 16);
    vram_fill(0xFF, 16);
}
</pre>

<p><div class="rs-tip-major">Poznámka: používáme zde novou funkci nazvanou
<strong>vram_fill</strong>, která dokáže vyplnit část PPU RAM (a tabulka
atributů leží v&nbsp;této oblasti) zvolenou konstantou. Výsledný kód by měl být
kratší, než explicitně zapsaná programová smyčka.</div></p>

<p>Celý zdrojový kód dnešního třetího demonstračního příkladu naleznete na
adrese <a
href="https://github.com/tisnik/8bit-fame/blob/master/NES-cc65/03_Attributes/attributes.c">https://github.com/tisnik/8bit-fame/blob/master/NES-cc65/03_Attributes/attributes.c</a>:</p>

<pre>
#include "neslib.h"
&nbsp;
#define ATTRIBUTE_TABLE 0x23c0
&nbsp;
#pragma bss-name(push, "ZEROPAGE")
int i;
int address;
&nbsp;
const unsigned char <strong>palette</strong>[16] = {
    0x0f, 0x00, 0x10, 0x30,
    0x0f, 0x01, 0x21, 0x31,
    0x0f, 0x06, 0x26, 0x36,
    0x0f, 0x09, 0x29, 0x39
};
&nbsp;
void <strong>fill_in_ppu_ram</strong>(void)
{
    vram_adr(NTADR_A(0, 0));
    for (i = 0; i &lt; 32 * 30; i++) {
        vram_put(i);
    }
}
&nbsp;
void <strong>fill_in_attributes</strong>(void)
{
    vram_adr(ATTRIBUTE_TABLE);
&nbsp;
    vram_fill(0, 16);
    vram_fill(0x55, 16);
    vram_fill(0xAA, 16);
    vram_fill(0xFF, 16);
}
&nbsp;
void <strong>game_loop</strong>(void)
{
    while (1) {
    }
}
&nbsp;
void <strong>main</strong>(void)
{
    ppu_off();
    pal_bg(palette);
    fill_in_ppu_ram();
    fill_in_attributes();
    ppu_on_all();
&nbsp;
    game_loop();
}
</pre>

<p>Po spuštění v&nbsp;emulátoru herní konzole je patrné, že se barvové atributy
skutečně změnily podle očekávání:</p>

<p><i>Obrázek 5: Herní scéna vytvořená třetím demonstračním příkladem po
spuštění v&nbsp;emulátoru herní konzole NES.</i></p>



<p><a name="k12"></a></p>
<h2 id="k12">12. Výsledek překladu do assembleru</h2>

<p>Opět se podívejme na to, jak bude vypadat výsledek překladu našeho céčkového
programu do assembleru. Zajímat nás pochopitelně bude především způsob
přeložení funkce <strong>fill_in_attributes</strong>. Jedná se vlastně
&bdquo;pouze&ldquo; o sekvenci volání příslušné subrutiny s&nbsp;předáním
parametrů:</p>

<pre>
<i>;</i>
<i>; vram_adr(ATTRIBUTE_TABLE);</i>
<i>;</i>
        ldx     #$23
        lda     #$C0
        jsr     _vram_adr
<i>;</i>
<i>; vram_fill(0, 16);</i>
<i>;</i>
        lda     #$00
        jsr     pusha
        tax
        lda     #$10
        jsr     _vram_fill
<i>;</i>
<i>; vram_fill(0x55, 16);</i>
<i>;</i>
        lda     #$55
        jsr     pusha
        ldx     #$00
        lda     #$10
        jsr     _vram_fill
<i>;</i>
<i>; vram_fill(0xAA, 16);</i>
<i>;</i>
        lda     #$AA
        jsr     pusha
        ldx     #$00
        lda     #$10
        jsr     _vram_fill
<i>;</i>
<i>; vram_fill(0xFF, 16);</i>
<i>;</i>
        lda     #$FF
        jsr     pusha
        ldx     #$00
        lda     #$10
        jmp     _vram_fill
&nbsp;
.endproc
</pre>

<p>Samotná volaná subrutina je součástí <i>NESlibu</i> a vypadá takto (opět
tedy platí, že v&nbsp;assembleru bychom dosáhli kratšího a rychlejšího kódu
&ndash; to je daň za použití céčka a předpřipravených obecných knihoven):</p>

<pre>
_vram_fill:
        sta &lt;LEN
        stx &lt;LEN+1
        jsr popa
        ldx &lt;LEN+1
        beq @2
        ldx #0
@1:
        sta PPU_DATA
        dex
        bne @1
        dec &lt;LEN+1
        bne @1
@2:
        ldx &lt;LEN
        beq @4
@3:
        sta PPU_DATA
        dex
        bne @3
@4:
        rts
</pre>

<p>Pro úplnost se podívejme na to, jak vlastně dopadl překlad celého kódu:</p>

<pre>
<i>;</i>
<i>; File generated by cc65 v 2.18 - Ubuntu 2.18-1</i>
<i>;</i>
        .fopt           compiler,"cc65 v 2.18 - Ubuntu 2.18-1"
        .setcpu         "6502"
        .smart          on
        .autoimport     on
        .case           on
        .debuginfo      off
        .importzp       sp, sreg, regsave, regbank
        .importzp       tmp1, tmp2, tmp3, tmp4, ptr1, ptr2, ptr3, ptr4
        .macpack        longbranch
        .forceimport    __STARTUP__
        .import         _pal_bg
        .import         _ppu_off
        .import         _ppu_on_all
        .import         _vram_adr
        .import         _vram_put
        .import         _vram_fill
        .export         _i
        .export         _address
        .export         _palette
        .export         _fill_in_ppu_ram
        .export         _fill_in_attributes
        .export         _game_loop
        .export         _main
&nbsp;
.segment        "RODATA"
&nbsp;
_palette:
        .byte   $0F
        .byte   $00
        .byte   $10
        .byte   $30
        .byte   $0F
        .byte   $01
        .byte   $21
        .byte   $31
        .byte   $0F
        .byte   $06
        .byte   $26
        .byte   $36
        .byte   $0F
        .byte   $09
        .byte   $29
        .byte   $39
&nbsp;
.segment        "BSS"
&nbsp;
.segment        "ZEROPAGE"
_i:
        .res    2,$00
_address:
        .res    2,$00
&nbsp;
<i>; ---------------------------------------------------------------</i>
<i>; void __near__ fill_in_ppu_ram (void)</i>
<i>; ---------------------------------------------------------------</i>
&nbsp;
.segment        "CODE"
&nbsp;
.proc   _fill_in_ppu_ram: near
&nbsp;
.segment        "CODE"
&nbsp;
<i>;</i>
<i>; vram_adr(NTADR_A(0, 0));</i>
<i>;</i>
        ldx     #$20
        lda     #$00
        jsr     _vram_adr
<i>;</i>
<i>; for (i = 0; i &lt; 32 * 30; i++) {</i>
<i>;</i>
        lda     #$00
        sta     _i
        sta     _i+1
L001B:  lda     _i
        cmp     #$C0
        lda     _i+1
        sbc     #$03
        bvc     L0022
        eor     #$80
L0022:  bpl     L001C
<i>;</i>
<i>; vram_put(i);</i>
<i>;</i>
        lda     _i
        jsr     _vram_put
<i>;</i>
<i>; for (i = 0; i &lt; 32 * 30; i++) {</i>
<i>;</i>
        lda     _i
        ldx     _i+1
        clc
        adc     #$01
        bcc     L0024
        inx
L0024:  sta     _i
        stx     _i+1
        jmp     L001B
<i>;</i>
<i>; }</i>
<i>;</i>
L001C:  rts
&nbsp;
.endproc
&nbsp;
<i>; ---------------------------------------------------------------</i>
<i>; void __near__ fill_in_attributes (void)</i>
<i>; ---------------------------------------------------------------</i>
&nbsp;
.segment        "CODE"
&nbsp;
.proc   _fill_in_attributes: near
&nbsp;
.segment        "CODE"
&nbsp;
<i>;</i>
<i>; vram_adr(ATTRIBUTE_TABLE);</i>
<i>;</i>
        ldx     #$23
        lda     #$C0
        jsr     _vram_adr
<i>;</i>
<i>; vram_fill(0, 16);</i>
<i>;</i>
        lda     #$00
        jsr     pusha
        tax
        lda     #$10
        jsr     _vram_fill
<i>;</i>
<i>; vram_fill(0x55, 16);</i>
<i>;</i>
        lda     #$55
        jsr     pusha
        ldx     #$00
        lda     #$10
        jsr     _vram_fill
<i>;</i>
<i>; vram_fill(0xAA, 16);</i>
<i>;</i>
        lda     #$AA
        jsr     pusha
        ldx     #$00
        lda     #$10
        jsr     _vram_fill
<i>;</i>
<i>; vram_fill(0xFF, 16);</i>
<i>;</i>
        lda     #$FF
        jsr     pusha
        ldx     #$00
        lda     #$10
        jmp     _vram_fill
&nbsp;
.endproc
&nbsp;
<i>; ---------------------------------------------------------------</i>
<i>; void __near__ game_loop (void)</i>
<i>; ---------------------------------------------------------------</i>
&nbsp;
.segment        "CODE"
&nbsp;
.proc   _game_loop: near
&nbsp;
.segment        "CODE"
&nbsp;
<i>;</i>
<i>; while (1) {</i>
<i>;</i>
L0043:  jmp     L0043
&nbsp;
.endproc
&nbsp;
<i>; ---------------------------------------------------------------</i>
<i>; void __near__ main (void)</i>
<i>; ---------------------------------------------------------------</i>
&nbsp;
.segment        "CODE"
&nbsp;
.proc   _main: near
&nbsp;
.segment        "CODE"
&nbsp;
<i>;</i>
<i>; ppu_off();</i>
<i>;</i>
        jsr     _ppu_off
<i>;</i>
<i>; pal_bg(palette);</i>
<i>;</i>
        lda     #&lt;(_palette)
        ldx     #&gt;(_palette)
        jsr     _pal_bg
<i>;</i>
<i>; fill_in_ppu_ram();</i>
<i>;</i>
        jsr     _fill_in_ppu_ram
<i>;</i>
<i>; fill_in_attributes();</i>
<i>;</i>
        jsr     _fill_in_attributes
<i>;</i>
<i>; ppu_on_all();</i>
<i>;</i>
        jsr     _ppu_on_all
<i>;</i>
<i>; game_loop();</i>
<i>;</i>
        jmp     _game_loop
&nbsp;
.endproc
</pre>



<p><a name="k13"></a></p>
<h2 id="k13">13. Využití definice dlaždic z&nbsp;herního světa Maria</h2>

<p>V&nbsp;dnešním čtvrtém demonstračním příkladu, který naleznete na adrese <a
href="https://github.com/tisnik/8bit-fame/blob/master/NES-cc65/04_Mario_world_A">https://github.com/tisnik/8bit-fame/blob/master/NES-cc65/04_Mario_world_A</a>,
jsou provedeny pouze dvě změny, které však mají velký dopad na to, <i>jaké</i>
objekty je vlastně možné zobrazit v&nbsp;herním světě. Jedna ze změn spočívá
v&nbsp;tom, že barvová paleta obsahuje nejenom definici šestnácti barev pozadí,
ale i definici šestnácti barev používaných sprity:</p>

<pre>
const unsigned char <strong>palette</strong>[32] = {
    0x22, 0x29, 0x1a, 0x0F, 0x22, 0x36, 0x17, 0x0F, 0x22, 0x30, 0x21, 0x0F, 0x22, 0x27, 0x17, 0x0F,  <i>// barvy pozadí</i>
    0x22, 0x16, 0x27, 0x18, 0x22, 0x1A, 0x30, 0x27, 0x22, 0x16, 0x30, 0x27, 0x22, 0x0F, 0x36, 0x17,  <i>// barvy spritů</i>
};
</pre>

<p>Druhou změnou je nahrazení binárního souboru <strong>Alpha.chr</strong> za
soubor <strong>mario.chr</strong>, s&nbsp;čímž souvisí i nepatrné úpravy
souboru <strong>Makefile</strong> a <strong>crt0.s</strong>. Připomeňme si, že
soubory <strong>*.chr</strong> mají typicky velikost 8192 bajtů. V&nbsp;těchto
souborech je uložena definice 256 dlaždic pozadí a 256 dlaždic spritů. Každá
dlaždice má velikost 8&times;8 pixelů, přičemž každý pixel je definován dvojicí
bitů. To znamená, že jedna dlaždice je uložena v&nbsp;šestnácti bitech a tedy
celková velikost tohoto binárního souboru je skutečně rovna
2&times;256&times;(8&times;8/4)=8192 bajtům.</p>

<p>Po překladu a spuštění tohoto demonstračního příkladu se zobrazí následující
obraz:</p>

*** image ***
<p><i>Obrázek 6: Všechny dostupné dlaždice zobrazené postupně ve čtyřech
kombinacích barev.</i></p>

<p><div class="rs-tip-major">Poznámka: jak uvidíme dále, zobrazujeme vlastně
dlaždice spritů a nikoli dlaždice pozadí. Tento problém lze napravit jediným
řádkem v&nbsp;programovém kódu.</div></p>

<p>Žádné další změny (kromě změny palety zmíněné výše) ve zdrojovém kódu
provedeny nejsou:</p>

<pre>
#include "neslib.h"
&nbsp;
#define ATTRIBUTE_TABLE 0x23c0
&nbsp;
#pragma bss-name(push, "ZEROPAGE")
int i;
int address;
&nbsp;
const unsigned char <strong>palette</strong>[32] = {
    0x22, 0x29, 0x1a, 0x0F, 0x22, 0x36, 0x17, 0x0F, 0x22, 0x30, 0x21, 0x0F, 0x22, 0x27, 0x17, 0x0F,  // barvy pozadí
    0x22, 0x16, 0x27, 0x18, 0x22, 0x1A, 0x30, 0x27, 0x22, 0x16, 0x30, 0x27, 0x22, 0x0F, 0x36, 0x17,  // barvy spritů
};
&nbsp;
void <strong>fill_in_ppu_ram</strong>(void)
{
    vram_adr(NTADR_A(0, 0));
    for (i = 0; i &lt; 32 * 30; i++) {
        vram_put(i);
    }
}
&nbsp;
void <strong>fill_in_attributes</strong>(void)
{
    vram_adr(ATTRIBUTE_TABLE);
&nbsp;
    vram_fill(0, 16);
    vram_fill(0x55, 16);
    vram_fill(0xAA, 16);
    vram_fill(0xFF, 16);
}

void <strong>game_loop</strong>(void)
{
    while (1) {
    }
}
&nbsp;
void <strong>main</strong>(void)
{
    ppu_off();
    pal_bg(palette);
    fill_in_ppu_ram();
    fill_in_attributes();
    ppu_on_all();
&nbsp;
    game_loop();
}
</pre>



<p><a name="k14"></a></p>
<h2 id="k14">14. Výsledek překladu do assembleru</h2>

<p>Bez dalších podrobností si ukažme, jak se zdrojový kód <a
href="#k13">z&nbsp;předchozí kapitoly</a> přeložil do assembleru:</p>

<pre>
<i>;</i>
<i>; File generated by cc65 v 2.18 - Ubuntu 2.18-1</i>
<i>;</i>
        .fopt           compiler,"cc65 v 2.18 - Ubuntu 2.18-1"
        .setcpu         "6502"
        .smart          on
        .autoimport     on
        .case           on
        .debuginfo      off
        .importzp       sp, sreg, regsave, regbank
        .importzp       tmp1, tmp2, tmp3, tmp4, ptr1, ptr2, ptr3, ptr4
        .macpack        longbranch
        .forceimport    __STARTUP__
        .import         _pal_bg
        .import         _ppu_off
        .import         _ppu_on_all
        .import         _vram_adr
        .import         _vram_put
        .import         _vram_fill
        .export         _i
        .export         _address
        .export         _palette
        .export         _fill_in_ppu_ram
        .export         _fill_in_attributes
        .export         _game_loop
        .export         _main
&nbsp;
.segment        "RODATA"
&nbsp;
_palette:
        .byte   $22
        .byte   $29
        .byte   $1A
        .byte   $0F
        .byte   $22
        .byte   $36
        .byte   $17
        .byte   $0F
        .byte   $22
        .byte   $30
        .byte   $21
        .byte   $0F
        .byte   $22
        .byte   $27
        .byte   $17
        .byte   $0F
        .byte   $22
        .byte   $16
        .byte   $27
        .byte   $18
        .byte   $22
        .byte   $1A
        .byte   $30
        .byte   $27
        .byte   $22
        .byte   $16
        .byte   $30
        .byte   $27
        .byte   $22
        .byte   $0F
        .byte   $36
        .byte   $17
&nbsp;
.segment        "BSS"
&nbsp;
.segment        "ZEROPAGE"
_i:
        .res    2,$00
_address:
        .res    2,$00
&nbsp;
<i>; ---------------------------------------------------------------</i>
<i>; void __near__ fill_in_ppu_ram (void)</i>
<i>; ---------------------------------------------------------------</i>
&nbsp;
.segment        "CODE"
&nbsp;
.proc   _fill_in_ppu_ram: near
&nbsp;
.segment        "CODE"
&nbsp;
<i>;</i>
<i>; vram_adr(NTADR_A(0, 0));</i>
<i>;</i>
        ldx     #$20
        lda     #$00
        jsr     _vram_adr
<i>;</i>
<i>; for (i = 0; i &lt; 32 * 30; i++) {</i>
<i>;</i>
        lda     #$00
        sta     _i
        sta     _i+1
L002B:  lda     _i
        cmp     #$C0
        lda     _i+1
        sbc     #$03
        bvc     L0032
        eor     #$80
L0032:  bpl     L002C
<i>;</i>
<i>; vram_put(i);</i>
<i>;</i>
        lda     _i
        jsr     _vram_put
<i>;</i>
<i>; for (i = 0; i &lt; 32 * 30; i++) {</i>
<i>;</i>
        lda     _i
        ldx     _i+1
        clc
        adc     #$01
        bcc     L0034
        inx
L0034:  sta     _i
        stx     _i+1
        jmp     L002B
<i>;</i>
<i>; }</i>
<i>;</i>
L002C:  rts
&nbsp;
.endproc
&nbsp;
<i>; ---------------------------------------------------------------</i>
<i>; void __near__ fill_in_attributes (void)</i>
<i>; ---------------------------------------------------------------</i>
&nbsp;
.segment        "CODE"
&nbsp;
.proc   _fill_in_attributes: near
&nbsp;
.segment        "CODE"
&nbsp;
<i>;</i>
<i>; vram_adr(ATTRIBUTE_TABLE);</i>
<i>;</i>
        ldx     #$23
        lda     #$C0
        jsr     _vram_adr
<i>;</i>
<i>; vram_fill(0, 16);</i>
<i>;</i>
        lda     #$00
        jsr     pusha
        tax
        lda     #$10
        jsr     _vram_fill
<i>;</i>
<i>; vram_fill(0x55, 16);</i>
<i>;</i>
        lda     #$55
        jsr     pusha
        ldx     #$00
        lda     #$10
        jsr     _vram_fill
<i>;</i>
<i>; vram_fill(0xAA, 16);</i>
<i>;</i>
        lda     #$AA
        jsr     pusha
        ldx     #$00
        lda     #$10
        jsr     _vram_fill
<i>;</i>
<i>; vram_fill(0xFF, 16);</i>
<i>;</i>
        lda     #$FF
        jsr     pusha
        ldx     #$00
        lda     #$10
        jmp     _vram_fill
&nbsp;
.endproc
&nbsp;
<i>; ---------------------------------------------------------------</i>
<i>; void __near__ game_loop (void)</i>
<i>; ---------------------------------------------------------------</i>
&nbsp;
.segment        "CODE"
&nbsp;
.proc   _game_loop: near
&nbsp;
.segment        "CODE"
&nbsp;
<i>;</i>
<i>; while (1) {</i>
<i>;</i>
L0053:  jmp     L0053
&nbsp;
.endproc
&nbsp;
<i>; ---------------------------------------------------------------</i>
<i>; void __near__ main (void)</i>
<i>; ---------------------------------------------------------------</i>
&nbsp;
.segment        "CODE"
&nbsp;
.proc   _main: near
&nbsp;
.segment        "CODE"
&nbsp;
<i>;</i>
<i>; ppu_off();</i>
<i>;</i>
        jsr     _ppu_off
<i>;</i>
<i>; pal_bg(palette);</i>
<i>;</i>
        lda     #&lt;(_palette)
        ldx     #&gt;(_palette)
        jsr     _pal_bg
<i>;</i>
<i>; fill_in_ppu_ram();</i>
<i>;</i>
        jsr     _fill_in_ppu_ram
<i>;</i>
<i>; fill_in_attributes();</i>
<i>;</i>
        jsr     _fill_in_attributes
<i>;</i>
<i>; ppu_on_all();</i>
<i>;</i>
        jsr     _ppu_on_all
<i>;</i>
<i>; game_loop();</i>
<i>;</i>
        jmp     _game_loop
&nbsp;
.endproc
</pre>



<p><a name="k15"></a></p>
<h2 id="k15">15. Specifikace, která sada dlaždic se má použít pro vykreslování pozadí</h2>

<p></p>

<pre>
ppu_off();
pal_bg(palette);
<strong>bank_bg(1);</strong>
fill_in_ppu_ram();
fill_in_attributes();
ppu_on_all();
&nbsp;
game_loop();
</pre>

<p>Samotná funkce <strong>bank_bg</strong> je realizována v&nbsp;assembleru. Nastavuje se v&nbsp;ní řídicí registr</p>

<pre>
_bank_bg:
&nbsp;
	and #$01
	asl a
	asl a
	asl a
	asl a
	sta &lt;TEMP
	lda &lt;PPU_CTRL_VAR
	and #%11101111
	ora &lt;TEMP
	sta &lt;PPU_CTRL_VAR
&nbsp;
	rts
</pre>

<p></p>

*** image ***
<p><i>Obrázek 7: Všechny dostupné dlaždice zobrazené postupně ve čtyřech
kombinacích barev.</i></p>



<p><a name="k16"></a></p>
<h2 id="k16">16. Opravený příklad ze třinácté kapitoly</h2>

<p></p>

<pre>
#include "neslib.h"
&nbsp;
#define ATTRIBUTE_TABLE 0x23c0
&nbsp;
#pragma bss-name(push, "ZEROPAGE")
int <strong>i</strong>;
int <strong>address</strong>;
&nbsp;
const unsigned char <strong>palette</strong>[32] = {
    0x22, 0x29, 0x1a, 0x0F, 0x22, 0x36, 0x17, 0x0F, 0x22, 0x30, 0x21, 0x0F, 0x22, 0x27, 0x17, 0x0F,  // barvy pozadí
    0x22, 0x16, 0x27, 0x18, 0x22, 0x1A, 0x30, 0x27, 0x22, 0x16, 0x30, 0x27, 0x22, 0x0F, 0x36, 0x17,  // barvy spritů
};
&nbsp;
void <strong>fill_in_ppu_ram</strong>(void)
{
    vram_adr(NTADR_A(0, 0));
    for (i = 0; i &lt; 32 * 30; i++) {
        vram_put(i);
    }
}
&nbsp;
void <strong>fill_in_attributes</strong>(void)
{
    vram_adr(ATTRIBUTE_TABLE);
&nbsp;
    vram_fill(0, 16);
    vram_fill(0x55, 16);
    vram_fill(0xAA, 16);
    vram_fill(0xFF, 16);
}
&nbsp;
void <strong>game_loop</strong>(void)
{
    while (1) {
    }
}
&nbsp;
void <strong>main</strong>(void)
{
    ppu_off();
    pal_bg(palette);
    <strong>bank_bg(1);</strong>
    fill_in_ppu_ram();
    fill_in_attributes();
    ppu_on_all();
&nbsp;
    game_loop();
}
</pre>



<p><a name="k17"></a></p>
<h2 id="k17">17. Výsledek překladu do assembleru</h2>

<p></p>

<pre>
<i>;</i>
<i>; File generated by cc65 v 2.18 - Ubuntu 2.18-1</i>
<i>;</i>
        .fopt           compiler,"cc65 v 2.18 - Ubuntu 2.18-1"
        .setcpu         "6502"
        .smart          on
        .autoimport     on
        .case           on
        .debuginfo      off
        .importzp       sp, sreg, regsave, regbank
        .importzp       tmp1, tmp2, tmp3, tmp4, ptr1, ptr2, ptr3, ptr4
        .macpack        longbranch
        .forceimport    __STARTUP__
        .import         _pal_bg
        .import         _ppu_off
        .import         _ppu_on_all
        .import         _bank_bg
        .import         _vram_adr
        .import         _vram_put
        .import         _vram_fill
        .export         _i
        .export         _address
        .export         _palette
        .export         _fill_in_ppu_ram
        .export         _fill_in_attributes
        .export         _game_loop
        .export         _main
&nbsp;
.segment        "RODATA"
&nbsp;
_palette:
        .byte   $22
        .byte   $29
        .byte   $1A
        .byte   $0F
        .byte   $22
        .byte   $36
        .byte   $17
        .byte   $0F
        .byte   $22
        .byte   $30
        .byte   $21
        .byte   $0F
        .byte   $22
        .byte   $27
        .byte   $17
        .byte   $0F
        .byte   $22
        .byte   $16
        .byte   $27
        .byte   $18
        .byte   $22
        .byte   $1A
        .byte   $30
        .byte   $27
        .byte   $22
        .byte   $16
        .byte   $30
        .byte   $27
        .byte   $22
        .byte   $0F
        .byte   $36
        .byte   $17
&nbsp;
.segment        "BSS"
&nbsp;
.segment        "ZEROPAGE"
_i:
        .res    2,$00
_address:
        .res    2,$00
&nbsp;
<i>; ---------------------------------------------------------------</i>
<i>; void __near__ fill_in_ppu_ram (void)</i>
<i>; ---------------------------------------------------------------</i>
&nbsp;
.segment        "CODE"
&nbsp;
.proc   _fill_in_ppu_ram: near
&nbsp;
.segment        "CODE"
&nbsp;
<i>;</i>
<i>; vram_adr(NTADR_A(0, 0));</i>
<i>;</i>
        ldx     #$20
        lda     #$00
        jsr     _vram_adr
<i>;</i>
<i>; for (i = 0; i &lt; 32 * 30; i++) {</i>
<i>;</i>
        lda     #$00
        sta     _i
        sta     _i+1
L002B:  lda     _i
        cmp     #$C0
        lda     _i+1
        sbc     #$03
        bvc     L0032
        eor     #$80
L0032:  bpl     L002C
<i>;</i>
<i>; vram_put(i);</i>
<i>;</i>
        lda     _i
        jsr     _vram_put
<i>;</i>
<i>; for (i = 0; i &lt; 32 * 30; i++) {</i>
<i>;</i>
        lda     _i
        ldx     _i+1
        clc
        adc     #$01
        bcc     L0034
        inx
L0034:  sta     _i
        stx     _i+1
        jmp     L002B
<i>;</i>
<i>; }</i>
<i>;</i>
L002C:  rts
&nbsp;
.endproc
&nbsp;
<i>; ---------------------------------------------------------------</i>
<i>; void __near__ fill_in_attributes (void)</i>
<i>; ---------------------------------------------------------------</i>
&nbsp;
.segment        "CODE"
&nbsp;
.proc   _fill_in_attributes: near
&nbsp;
.segment        "CODE"
&nbsp;
<i>;</i>
<i>; vram_adr(ATTRIBUTE_TABLE);</i>
<i>;</i>
        ldx     #$23
        lda     #$C0
        jsr     _vram_adr
<i>;</i>
<i>; vram_fill(0, 16);</i>
<i>;</i>
        lda     #$00
        jsr     pusha
        tax
        lda     #$10
        jsr     _vram_fill
<i>;</i>
<i>; vram_fill(0x55, 16);</i>
<i>;</i>
        lda     #$55
        jsr     pusha
        ldx     #$00
        lda     #$10
        jsr     _vram_fill
<i>;</i>
<i>; vram_fill(0xAA, 16);</i>
<i>;</i>
        lda     #$AA
        jsr     pusha
        ldx     #$00
        lda     #$10
        jsr     _vram_fill
<i>;</i>
<i>; vram_fill(0xFF, 16);</i>
<i>;</i>
        lda     #$FF
        jsr     pusha
        ldx     #$00
        lda     #$10
        jmp     _vram_fill
&nbsp;
.endproc
&nbsp;
<i>; ---------------------------------------------------------------</i>
<i>; void __near__ game_loop (void)</i>
<i>; ---------------------------------------------------------------</i>
&nbsp;
.segment        "CODE"
&nbsp;
.proc   _game_loop: near
&nbsp;
.segment        "CODE"
&nbsp;
<i>;</i>
<i>; while (1) {</i>
<i>;</i>
L0055:  jmp     L0055
&nbsp;
.endproc
&nbsp;
<i>; ---------------------------------------------------------------</i>
<i>; void __near__ main (void)</i>
<i>; ---------------------------------------------------------------</i>
&nbsp;
.segment        "CODE"
&nbsp;
.proc   _main: near
&nbsp;
.segment        "CODE"
&nbsp;
<i>;</i>
<i>; ppu_off();</i>
<i>;</i>
        jsr     _ppu_off
<i>;</i>
<i>; pal_bg(palette);</i>
<i>;</i>
        lda     #&lt;(_palette)
        ldx     #&gt;(_palette)
        jsr     _pal_bg
<i>;</i>
<i>; bank_bg(1);</i>
<i>;</i>
        lda     #$01
        jsr     _bank_bg
<i>;</i>
<i>; fill_in_ppu_ram();</i>
<i>;</i>
        jsr     _fill_in_ppu_ram
<i>;</i>
<i>; fill_in_attributes();</i>
<i>;</i>
        jsr     _fill_in_attributes
<i>;</i>
<i>; ppu_on_all();</i>
<i>;</i>
        jsr     _ppu_on_all
<i>;</i>
<i>; game_loop();</i>
<i>;</i>
        jmp     _game_loop
&nbsp;
.endproc
</pre>



<p><a name="k18"></a></p>
<h2 id="k18">18. Obsah závěrečné části seriálu</h2>

<p>V&nbsp;jedenácté a současně i závěrečné části seriálu o vývoji her
popř.&nbsp;multimediálních dem určených pro historickou osmibitovou herní
konzoli NES si ukážeme některé další možnosti, které nám kombinace překladače
<i>CC65</i> s&nbsp;knihovnou <i>NESlib</i> poskytují. Vykreslíme si (poněkud
upravenou) úvodní obrazovku ze světa Maria, ukážeme si výpis řetězců, řekneme
si, jak se pracuje se sprity i s&nbsp;takzvanými <i>multisprity</i> a
nezapomeneme ani na čtení stavu ovladačů (D-pad) popř.&nbsp;na realizaci
scrollingu celého herního světa. Z&nbsp;demonstračních příkladů bude zřejmé, že
naprostou většinu těchto operací je možné v&nbsp;céčku (díky NESlibu) napsat na
jediný řádek či na pouhých několik řádků (v&nbsp;porovnání s&nbsp;desítkami
řádků, které vyžaduje tatáž operace zapsaná v&nbsp;assembleru).</p>

*** image ***
<p><i>Obrázek 8: Upravená úvodní obrazovka ze světa Maria vykreslená
demonstračním příkladem, který si popíšeme příště.</i></p>



<p><a name="k19"></a></p>
<h2 id="k19">19. Repositář s&nbsp;demonstračními příklady</h2>

<p>V&nbsp;tabulce zobrazené pod tímto odstavcem jsou uvedeny odkazy na všechny
demonstrační příklady určené pro překlad a spuštění na osmibitové herní konzoli
NES, které jsou psány v&nbsp;céčku a určeny pro překlad pomocí
<strong>cc65</strong>. Vždy se jedná o ucelené a současně i samostatně
použitelné projekty, což mj.&nbsp;znamená, že každý příklad obsahuje i svoji
lokální verzi souboru <strong>crt0.s</strong> a <strong>neslibu</strong>:</p>

<table>
<tr><th> #</th><th>Soubor</th><th>Stručný popis</th><th>Adresa</th></tr>
<tr><td> 1</td><td>01_Intro/Makefile</td><td>Makefile pro překlad a slinkování aplikace</td><td><a href="https://github.com/tisnik/8bit-fame/blob/master/NES-cc65/01_Intro/Makefile">https://github.com/tisnik/8bit-fame/blob/master/NES-cc65/01_Intro/Makefile</a></td></tr>
<tr><td> 2</td><td>01_Intro/nrom_32k_vert.cfg</td><td>konfigurace paměťových regionů herní konzole NES</td><td><a href="https://github.com/tisnik/8bit-fame/blob/master/NES-cc65/01_Intro/nrom_32k_vert.cfg">https://github.com/tisnik/8bit-fame/blob/master/NES-cc65/01_Intro/nrom_32k_vert.cfg</a></td></tr>
<tr><td> 3</td><td>01_Intro/Alpha.chr</td><td>binární soubor obsahující definice dlaždic pozadí a spritů</td><td><a href="https://github.com/tisnik/8bit-fame/blob/master/NES-cc65/01_Intro/Alpha.chr">https://github.com/tisnik/8bit-fame/blob/master/NES-cc65/01_Intro/Alpha.chr</a></td></tr>
<tr><td> 4</td><td>01_Intro/crt0.s</td><td>inicializační rutiny naprogramované v&nbsp;assembleru</td><td><a href="https://github.com/tisnik/8bit-fame/blob/master/NES-cc65/01_Intro/crt0.s">https://github.com/tisnik/8bit-fame/blob/master/NES-cc65/01_Intro/crt0.s</a></td></tr>
<tr><td> 5</td><td>01_Intro/neslib.h</td><td>hlavičkový soubor s&nbsp;pomocnými funkcemi pro vývoj v&nbsp;C pro NES</td><td><a href="https://github.com/tisnik/8bit-fame/blob/master/NES-cc65/01_Intro/neslib.h">https://github.com/tisnik/8bit-fame/blob/master/NES-cc65/01_Intro/neslib.h</a></td></tr>
<tr><td> 6</td><td>01_Intro/neslib.s</td><td>implementace funkcí předběžně definovaných v&nbsp;hlavičkovém souboru</td><td><a href="https://github.com/tisnik/8bit-fame/blob/master/NES-cc65/01_Intro/neslib.s">https://github.com/tisnik/8bit-fame/blob/master/NES-cc65/01_Intro/neslib.s</a></td></tr>
<tr><td> 7</td><td>01_Intro/intro.c</td><td>zdrojový kód prvního demonstračního příkladu psaný v&nbsp;C</td><td><a href="https://github.com/tisnik/8bit-fame/blob/master/NES-cc65/01_Intro/intro.c">https://github.com/tisnik/8bit-fame/blob/master/NES-cc65/01_Intro/intro.c</a></td></tr>
<tr><td> 8</td><td>01_Intro/intro.s</td><td>demonstrační příklad přeložený do assembleru</td><td><a href="https://github.com/tisnik/8bit-fame/blob/master/NES-cc65/01_Intro/intro.s">https://github.com/tisnik/8bit-fame/blob/master/NES-cc65/01_Intro/intro.s</a></td></tr>
<tr><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td></tr>
<tr><td> 9</td><td>02_PPU_RAM/Makefile</td><td>Makefile pro překlad a slinkování aplikace</td><td><a href="https://github.com/tisnik/8bit-fame/blob/master/NES-cc65/02_PPU_RAM/Makefile">https://github.com/tisnik/8bit-fame/blob/master/NES-cc65/02_PPU_RAM/Makefile</a></td></tr>
<tr><td>10</td><td>02_PPU_RAM/nrom_32k_vert.cfg</td><td>konfigurace paměťových regionů herní konzole NES</td><td><a href="https://github.com/tisnik/8bit-fame/blob/master/NES-cc65/02_PPU_RAM/nrom_32k_vert.cfg">https://github.com/tisnik/8bit-fame/blob/master/NES-cc65/02_PPU_RAM/nrom_32k_vert.cfg</a></td></tr>
<tr><td>11</td><td>02_PPU_RAM/Alpha.chr</td><td>binární soubor obsahující definice dlaždic pozadí a spritů</td><td><a href="https://github.com/tisnik/8bit-fame/blob/master/NES-cc65/02_PPU_RAM/Alpha.chr">https://github.com/tisnik/8bit-fame/blob/master/NES-cc65/02_PPU_RAM/Alpha.chr</a></td></tr>
<tr><td>12</td><td>02_PPU_RAM/crt0.s</td><td>inicializační rutiny naprogramované v&nbsp;assembleru</td><td><a href="https://github.com/tisnik/8bit-fame/blob/master/NES-cc65/02_PPU_RAM/crt0.s">https://github.com/tisnik/8bit-fame/blob/master/NES-cc65/02_PPU_RAM/crt0.s</a></td></tr>
<tr><td>13</td><td>02_PPU_RAM/neslib.h</td><td>hlavičkový soubor s&nbsp;pomocnými funkcemi pro vývoj v&nbsp;C pro NES</td><td><a href="https://github.com/tisnik/8bit-fame/blob/master/NES-cc65/02_PPU_RAM/neslib.h">https://github.com/tisnik/8bit-fame/blob/master/NES-cc65/02_PPU_RAM/neslib.h</a></td></tr>
<tr><td>14</td><td>02_PPU_RAM/neslib.s</td><td>implementace funkcí předběžně definovaných v&nbsp;hlavičkovém souboru</td><td><a href="https://github.com/tisnik/8bit-fame/blob/master/NES-cc65/02_PPU_RAM/neslib.s">https://github.com/tisnik/8bit-fame/blob/master/NES-cc65/02_PPU_RAM/neslib.s</a></td></tr>
<tr><td>15</td><td>02_PPU_RAM/ppu_ram.c</td><td>zdrojový kód druhého demonstračního příkladu psaný v&nbsp;C</td><td><a href="https://github.com/tisnik/8bit-fame/blob/master/NES-cc65/02_PPU_RAM/ppu_ram.c">https://github.com/tisnik/8bit-fame/blob/master/NES-cc65/02_PPU_RAM/ppu_ram.c</a></td></tr>
<tr><td>16</td><td>02_PPU_RAM/ppu_ram.s</td><td>demonstrační příklad přeložený do assembleru</td><td><a href="https://github.com/tisnik/8bit-fame/blob/master/NES-cc65/02_PPU_RAM/ppu_ram.s">https://github.com/tisnik/8bit-fame/blob/master/NES-cc65/02_PPU_RAM/ppu_ram.s</a></td></tr>
<tr><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td></tr>
<tr><td>17</td><td>03_Attributes/Makefile</td><td>Makefile pro překlad a slinkování aplikace</td><td><a href="https://github.com/tisnik/8bit-fame/blob/master/NES-cc65/03_Attributes/Makefile">https://github.com/tisnik/8bit-fame/blob/master/NES-cc65/03_Attributes/Makefile</a></td></tr>
<tr><td>18</td><td>03_Attributes/nrom_32k_vert.cfg</td><td>konfigurace paměťových regionů herní konzole NES</td><td><a href="https://github.com/tisnik/8bit-fame/blob/master/NES-cc65/03_Attributes/nrom_32k_vert.cfg">https://github.com/tisnik/8bit-fame/blob/master/NES-cc65/03_Attributes/nrom_32k_vert.cfg</a></td></tr>
<tr><td>19</td><td>03_Attributes/Alpha.chr</td><td>binární soubor obsahující definice dlaždic pozadí a spritů</td><td><a href="https://github.com/tisnik/8bit-fame/blob/master/NES-cc65/03_Attributes/Alpha.chr">https://github.com/tisnik/8bit-fame/blob/master/NES-cc65/03_Attributes/Alpha.chr</a></td></tr>
<tr><td>20</td><td>03_Attributes/crt0.s</td><td>inicializační rutiny naprogramované v&nbsp;assembleru</td><td><a href="https://github.com/tisnik/8bit-fame/blob/master/NES-cc65/03_Attributes/crt0.s">https://github.com/tisnik/8bit-fame/blob/master/NES-cc65/03_Attributes/crt0.s</a></td></tr>
<tr><td>21</td><td>03_Attributes/neslib.h</td><td>hlavičkový soubor s&nbsp;pomocnými funkcemi pro vývoj v&nbsp;C pro NES</td><td><a href="https://github.com/tisnik/8bit-fame/blob/master/NES-cc65/03_Attributes/neslib.h">https://github.com/tisnik/8bit-fame/blob/master/NES-cc65/03_Attributes/neslib.h</a></td></tr>
<tr><td>22</td><td>03_Attributes/neslib.s</td><td>implementace funkcí předběžně definovaných v&nbsp;hlavičkovém souboru</td><td><a href="https://github.com/tisnik/8bit-fame/blob/master/NES-cc65/03_Attributes/neslib.s">https://github.com/tisnik/8bit-fame/blob/master/NES-cc65/03_Attributes/neslib.s</a></td></tr>
<tr><td>23</td><td>03_Attributes/attributes.c</td><td>zdrojový kód třetího demonstračního příkladu psaný v&nbsp;C</td><td><a href="https://github.com/tisnik/8bit-fame/blob/master/NES-cc65/03_Attributes/attributes.c">https://github.com/tisnik/8bit-fame/blob/master/NES-cc65/03_Attributes/attributes.c</a></td></tr>
<tr><td>24</td><td>03_Attributes/attributes.s</td><td>demonstrační příklad přeložený do assembleru</td><td><a href="https://github.com/tisnik/8bit-fame/blob/master/NES-cc65/03_Attributes/attributes.s">https://github.com/tisnik/8bit-fame/blob/master/NES-cc65/03_Attributes/attributes.s</a></td></tr>
<tr><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td></tr>
<tr><td>25</td><td>04_Mario_world_A/Makefile</td><td>Makefile pro překlad a slinkování aplikace</td><td><a href="https://github.com/tisnik/8bit-fame/blob/master/NES-cc65/04_Mario_world_A/Makefile">https://github.com/tisnik/8bit-fame/blob/master/NES-cc65/04_Mario_world_A/Makefile</a></td></tr>
<tr><td>26</td><td>04_Mario_world_A/nrom_32k_vert.cfg</td>konfigurace paměťových regionů herní konzole NES<td></td><td><a href="https://github.com/tisnik/8bit-fame/blob/master/NES-cc65/04_Mario_world_A/nrom_32k_vert.cfg">https://github.com/tisnik/8bit-fame/blob/master/NES-cc65/04_Mario_world_A/nrom_32k_vert.cfg</a></td></tr>
<tr><td>27</td><td>04_Mario_world_A/mario.chr</td><td>binární soubor obsahující definice dlaždic pozadí a spritů</td><td><a href="https://github.com/tisnik/8bit-fame/blob/master/NES-cc65/04_Mario_world_A/mario.chr">https://github.com/tisnik/8bit-fame/blob/master/NES-cc65/04_Mario_world_A/mario.chr</a></td></tr>
<tr><td>28</td><td>04_Mario_world_A/crt0.s</td><td>inicializační rutiny naprogramované v&nbsp;assembleru</td><td><a href="https://github.com/tisnik/8bit-fame/blob/master/NES-cc65/04_Mario_world_A/crt0.s">https://github.com/tisnik/8bit-fame/blob/master/NES-cc65/04_Mario_world_A/crt0.s</a></td></tr>
<tr><td>29</td><td>04_Mario_world_A/neslib.h</td><td>hlavičkový soubor s&nbsp;pomocnými funkcemi pro vývoj v&nbsp;C pro NES</td><td><a href="https://github.com/tisnik/8bit-fame/blob/master/NES-cc65/04_Mario_world_A/neslib.h">https://github.com/tisnik/8bit-fame/blob/master/NES-cc65/04_Mario_world_A/neslib.h</a></td></tr>
<tr><td>30</td><td>04_Mario_world_A/neslib.s</td><td>implementace funkcí předběžně definovaných v&nbsp;hlavičkovém souboru</td><td><a href="https://github.com/tisnik/8bit-fame/blob/master/NES-cc65/04_Mario_world_A/neslib.s">https://github.com/tisnik/8bit-fame/blob/master/NES-cc65/04_Mario_world_A/neslib.s</a></td></tr>
<tr><td>31</td><td>04_Mario_world_A/mario_world.c</td><td>zdrojový kód čtvrtého demonstračního příkladu psaný v&nbsp;C</td><td><a href="https://github.com/tisnik/8bit-fame/blob/master/NES-cc65/04_Mario_world_A/mario_world.c">https://github.com/tisnik/8bit-fame/blob/master/NES-cc65/04_Mario_world_A/mario_world.c</a></td></tr>
<tr><td>32</td><td>04_Mario_world_A/mario_world.s</td><td>demonstrační příklad přeložený do assembleru</td><td><a href="https://github.com/tisnik/8bit-fame/blob/master/NES-cc65/04_Mario_world_A/mario_world.s">https://github.com/tisnik/8bit-fame/blob/master/NES-cc65/04_Mario_world_A/mario_world.s</a></td></tr>
<tr><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td></tr>
<tr><td>33</td><td>05_Mario_world_B/Makefile</td><td>Makefile pro překlad a slinkování aplikace</td><td><a href="https://github.com/tisnik/8bit-fame/blob/master/NES-cc65/05_Mario_world_B/Makefile">https://github.com/tisnik/8bit-fame/blob/master/NES-cc65/05_Mario_world_B/Makefile</a></td></tr>
<tr><td>34</td><td>05_Mario_world_B/nrom_32k_vert.cfg</td><td>konfigurace paměťových regionů herní konzole NES</td><td><a href="https://github.com/tisnik/8bit-fame/blob/master/NES-cc65/05_Mario_world_B/nrom_32k_vert.cfg">https://github.com/tisnik/8bit-fame/blob/master/NES-cc65/05_Mario_world_B/nrom_32k_vert.cfg</a></td></tr>
<tr><td>35</td><td>05_Mario_world_B/mario.chr</td><td>binární soubor obsahující definice dlaždic pozadí a spritů</td><td><a href="https://github.com/tisnik/8bit-fame/blob/master/NES-cc65/05_Mario_world_B/mario.chr">https://github.com/tisnik/8bit-fame/blob/master/NES-cc65/05_Mario_world_B/mario.chr</a></td></tr>
<tr><td>36</td><td>05_Mario_world_B/crt0.s</td><td>inicializační rutiny naprogramované v&nbsp;assembleru</td><td><a href="https://github.com/tisnik/8bit-fame/blob/master/NES-cc65/05_Mario_world_B/crt0.s">https://github.com/tisnik/8bit-fame/blob/master/NES-cc65/05_Mario_world_B/crt0.s</a></td></tr>
<tr><td>37</td><td>05_Mario_world_B/neslib.h</td><td>hlavičkový soubor s&nbsp;pomocnými funkcemi pro vývoj v&nbsp;C pro NES</td><td><a href="https://github.com/tisnik/8bit-fame/blob/master/NES-cc65/05_Mario_world_B/neslib.h">https://github.com/tisnik/8bit-fame/blob/master/NES-cc65/05_Mario_world_B/neslib.h</a></td></tr>
<tr><td>38</td><td>05_Mario_world_B/neslib.s</td><td>implementace funkcí předběžně definovaných v&nbsp;hlavičkovém souboru</td><td><a href="https://github.com/tisnik/8bit-fame/blob/master/NES-cc65/05_Mario_world_B/neslib.s">https://github.com/tisnik/8bit-fame/blob/master/NES-cc65/05_Mario_world_B/neslib.s</a></td></tr>
<tr><td>39</td><td>05_Mario_world_B/mario_world.c</td><td>zdrojový kód pátého demonstračního příkladu psaný v&nbsp;C</td><td><a href="https://github.com/tisnik/8bit-fame/blob/master/NES-cc65/05_Mario_world_B/mario_world.c">https://github.com/tisnik/8bit-fame/blob/master/NES-cc65/05_Mario_world_B/mario_world.c</a></td></tr>
<tr><td>40</td><td>05_Mario_world_B/mario_world.s</td><td>demonstrační příklad přeložený do assembleru</td><td><a href="https://github.com/tisnik/8bit-fame/blob/master/NES-cc65/05_Mario_world_B/mario_world.s">https://github.com/tisnik/8bit-fame/blob/master/NES-cc65/05_Mario_world_B/mario_world.s</a></td></tr>
</table>

<p>Pro úplnost si ještě uveďme odkazy na demonstrační příklady napsané
v&nbsp;assembleru, které jsou určené pro překlad pomocí assembleru
<strong>ca65</strong> (jenž je součástí <strong>cc65</strong>), byly uloženy do
Git repositáře, který je dostupný na adrese <a
href="https://github.com/tisnik/8bit-fame">https://github.com/tisnik/8bit-fame</a>.
Jednotlivé demonstrační příklady si můžete v&nbsp;případě potřeby stáhnout i
jednotlivě bez nutnosti klonovat celý (dnes již poměrně rozsáhlý)
repositář:</p>

<table>
<tr><th> #</th><th>Příklad</th><th>Stručný popis</th><th>Adresa</th></tr>
<tr><td> 1</td><td>example01.asm</td><td>zdrojový kód příkladu tvořeného kostrou aplikace pro NES</td><td><a href="https://github.com/tisnik/8bit-fame/blob/master/NES-ca65/example01.asm">https://github.com/tisnik/8bit-fame/blob/master/NES-ca65/example01.asm</a></td></tr>
<tr><td> 2</td><td>example02.asm</td><td>použití standardní konfigurace linkeru pro konzoli NES</td><td><a href="https://github.com/tisnik/8bit-fame/blob/master/NES-ca65/example02.asm">https://github.com/tisnik/8bit-fame/blob/master/NES-ca65/example02.asm</a></td></tr>
<tr><td> 3</td><td>example03.asm</td><td>symbolická jména řídicích registrů PPU</td><td><a href="https://github.com/tisnik/8bit-fame/blob/master/NES-ca65/example03.asm">https://github.com/tisnik/8bit-fame/blob/master/NES-ca65/example03.asm</a></td></tr>
<tr><td> 4</td><td>example04.asm</td><td>zjednodušený zápis lokálních smyček v&nbsp;assembleru</td><td><a href="https://github.com/tisnik/8bit-fame/blob/master/NES-ca65/example04.asm">https://github.com/tisnik/8bit-fame/blob/master/NES-ca65/example04.asm</a></td></tr>
<tr><td> 5</td><td>example05.asm</td><td>zvukový výstup s&nbsp;využitím prvního &bdquo;square&ldquo; kanálu</td><td><a href="https://github.com/tisnik/8bit-fame/blob/master/NES-ca65/example05.asm">https://github.com/tisnik/8bit-fame/blob/master/NES-ca65/example05.asm</a></td></tr>
<tr><td> 6</td><td>example06.asm</td><td>použití maker bez parametrů</td><td><a href="https://github.com/tisnik/8bit-fame/blob/master/NES-ca65/example06.asm">https://github.com/tisnik/8bit-fame/blob/master/NES-ca65/example06.asm</a></td></tr>
<tr><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td></tr>
<tr><td> 7</td><td>example07.asm</td><td>nastavení barvové palety, zvýšení intenzity zvolené barvové složky</td><td><a href="https://github.com/tisnik/8bit-fame/blob/master/NES-ca65/example07.asm">https://github.com/tisnik/8bit-fame/blob/master/NES-ca65/example07.asm</a></td></tr>
<tr><td> 8</td><td>example08.asm</td><td>využití operátorů &lt; a &gt;</td><td><a href="https://github.com/tisnik/8bit-fame/blob/master/NES-ca65/example08.asm">https://github.com/tisnik/8bit-fame/blob/master/NES-ca65/example08.asm</a></td></tr>
<tr><td> 9</td><td>example09.asm</td><td>vymazání barvové palety realizované makrem</td><td><a href="https://github.com/tisnik/8bit-fame/blob/master/NES-ca65/example09.asm">https://github.com/tisnik/8bit-fame/blob/master/NES-ca65/example09.asm</a></td></tr>
<tr><td>10</td><td>example10.asm</td><td>vymazání barvové palety realizované podprogramem</td><td><a href="https://github.com/tisnik/8bit-fame/blob/master/NES-ca65/example10.asm">https://github.com/tisnik/8bit-fame/blob/master/NES-ca65/example10.asm</a></td></tr>
<tr><td>11</td><td>example11.asm</td><td>nastavení barvové palety pozadí i spritů</td><td><a href="https://github.com/tisnik/8bit-fame/blob/master/NES-ca65/example11.asm">https://github.com/tisnik/8bit-fame/blob/master/NES-ca65/example11.asm</a></td></tr>
<tr><td>12</td><td>example12.asm</td><td>refaktoring předchozího příkladu makrem</td><td><a href="https://github.com/tisnik/8bit-fame/blob/master/NES-ca65/example12.asm">https://github.com/tisnik/8bit-fame/blob/master/NES-ca65/example12.asm</a></td></tr>
<tr><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td></tr>
<tr><td>13</td><td>example13.asm</td><td>zobrazení spritů tvořících Maria</td><td><a href="https://github.com/tisnik/8bit-fame/blob/master/NES-ca65/example13.asm">https://github.com/tisnik/8bit-fame/blob/master/NES-ca65/example13.asm</a></td></tr>
<tr><td>14</td><td>example14.asm</td><td>posun spritů, aby se zdůraznila jejich nezávislost</td><td><a href="https://github.com/tisnik/8bit-fame/blob/master/NES-ca65/example14.asm">https://github.com/tisnik/8bit-fame/blob/master/NES-ca65/example14.asm</a></td></tr>
<tr><td>15</td><td>example15.asm</td><td>větší množství spritů na obrazovce rozdělených do řádků</td><td><a href="https://github.com/tisnik/8bit-fame/blob/master/NES-ca65/example15.asm">https://github.com/tisnik/8bit-fame/blob/master/NES-ca65/example15.asm</a></td></tr>
<tr><td>16</td><td>example16.asm</td><td>větší množství spritů na obrazovce na jediném řádku</td><td><a href="https://github.com/tisnik/8bit-fame/blob/master/NES-ca65/example16.asm">https://github.com/tisnik/8bit-fame/blob/master/NES-ca65/example16.asm</a></td></tr>
<tr><td>17</td><td>example17.asm</td><td>pohyb jednoho spritu pomocí ovladače</td><td><a href="https://github.com/tisnik/8bit-fame/blob/master/NES-ca65/example17.asm">https://github.com/tisnik/8bit-fame/blob/master/NES-ca65/example17.asm</a></td></tr>
<tr><td>18</td><td>example18.asm</td><td>odvozeno z&nbsp;předchozího příkladu, symbolická jména adres</td><td><a href="https://github.com/tisnik/8bit-fame/blob/master/NES-ca65/example18.asm">https://github.com/tisnik/8bit-fame/blob/master/NES-ca65/example18.asm</a></td></tr>
<tr><td>19</td><td>example19.asm</td><td>odvozeno z&nbsp;předchozího příkladu, pomocná makra pro pohyb spritu</td><td><a href="https://github.com/tisnik/8bit-fame/blob/master/NES-ca65/example19.asm">https://github.com/tisnik/8bit-fame/blob/master/NES-ca65/example19.asm</a></td></tr>
<tr><td>20</td><td>example20.asm</td><td>pohyb spritu je založen na instrukcích <strong>INC</strong> a <strong>DEC</strong></td><td><a href="https://github.com/tisnik/8bit-fame/blob/master/NES-ca65/example20.asm">https://github.com/tisnik/8bit-fame/blob/master/NES-ca65/example20.asm</a></td></tr>
<tr><td>21</td><td>example21.asm</td><td>přesun celého Maria (8 spritů)</td><td><a href="https://github.com/tisnik/8bit-fame/blob/master/NES-ca65/example21.asm">https://github.com/tisnik/8bit-fame/blob/master/NES-ca65/example21.asm</a></td></tr>
<tr><td>22</td><td>example22.asm</td><td>(rychlá) změna barvové palety spritů tlačítkem A</td><td><a href="https://github.com/tisnik/8bit-fame/blob/master/NES-ca65/example22.asm">https://github.com/tisnik/8bit-fame/blob/master/NES-ca65/example22.asm</a></td></tr>
<tr><td>23</td><td>example23.asm</td><td>realizace čítače pro snížení frekvence změn barvové palety</td><td><a href="https://github.com/tisnik/8bit-fame/blob/master/NES-ca65/example23.asm">https://github.com/tisnik/8bit-fame/blob/master/NES-ca65/example23.asm</a></td></tr>
<tr><td>24</td><td>example24.asm</td><td>horizontální a vertikální zrcadlení spritů řízené hráčem stiskem tlačítek</td><td><a href="https://github.com/tisnik/8bit-fame/blob/master/NES-ca65/example24.asm">https://github.com/tisnik/8bit-fame/blob/master/NES-ca65/example24.asm</a></td></tr>
<tr><td>25</td><td>example25.asm</td><td>definice pozadí a zobrazení pozadí</td><td><a href="https://github.com/tisnik/8bit-fame/blob/master/NES-ca65/example25.asm">https://github.com/tisnik/8bit-fame/blob/master/NES-ca65/example25.asm</a></td></tr>
<tr><td>26</td><td>example26.asm</td><td>zobrazení pozadí i spritů</td><td><a href="https://github.com/tisnik/8bit-fame/blob/master/NES-ca65/example26.asm">https://github.com/tisnik/8bit-fame/blob/master/NES-ca65/example26.asm</a></td></tr>
<tr><td>27</td><td>example27.asm</td><td>pohyb spritu řízený ovladačem, změna atributů spritů</td><td><a href="https://github.com/tisnik/8bit-fame/blob/master/NES-ca65/example27.asm">https://github.com/tisnik/8bit-fame/blob/master/NES-ca65/example27.asm</a></td></tr>
<tr><td>28</td><td>example28.asm</td><td>definice pozadí přes téměř celou obrazovku</td><td><a href="https://github.com/tisnik/8bit-fame/blob/master/NES-ca65/example28.asm">https://github.com/tisnik/8bit-fame/blob/master/NES-ca65/example28.asm</a></td></tr>
<tr><td>29</td><td>example29.asm</td><td>scrolling pozadí s&nbsp;využitím ovladače</td><td><a href="https://github.com/tisnik/8bit-fame/blob/master/NES-ca65/example29.asm">https://github.com/tisnik/8bit-fame/blob/master/NES-ca65/example29.asm</a></td></tr>
<tr><td>30</td><td>example30.asm</td><td>zobrazení hodnot offsetů pro pozadí</td><td><a href="https://github.com/tisnik/8bit-fame/blob/master/NES-ca65/example30.asm">https://github.com/tisnik/8bit-fame/blob/master/NES-ca65/example30.asm</a></td></tr>
<tr><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td></tr>
<tr><td>31</td><td>link.cfg</td><td>konfigurace segmentů pro linker <strong>ld65</strong></td><td><a href="https://github.com/tisnik/8bit-fame/blob/master/NES-ca65/link.cfg">https://github.com/tisnik/8bit-fame/blob/master/NES-ca65/link.cfg</a></td></tr>
<tr><td>32</td><td>Makefile</td><td>Makefile pro překlad a slinkování všech příkladů</td><td><a href="https://github.com/tisnik/8bit-fame/blob/master/NES-ca65/Makefile">https://github.com/tisnik/8bit-fame/blob/master/NES-ca65/Makefile</a></td></tr>
</table>

<p><div class="rs-tip-major">Poznámka: pro slinkování a spuštění většiny těchto
demonstračních příkladů potřebujete i soubor <a
href="https://github.com/ericdigioia/6502-Assembly-NES-Game-Development-Playground/raw/main/mario.chr">mario.chr</a>.
Ten je stažen automaticky po zadání <strong>make example16</strong> až
<strong>make example30</strong>.</div></p>



<p><a name="k20"></a></p>
<h2 id="k20">20. Odkazy na Internetu</h2>

<ol>

<li>Překladače jazyka C pro historické osmibitové mikroprocesory<br />
<a href="https://www.root.cz/clanky/prekladace-jazyka-c-pro-historicke-osmibitove-mikroprocesory/">https://www.root.cz/clanky/prekladace-jazyka-c-pro-historicke-osmibitove-mikroprocesory/</a>
</li>

<li>Překladače programovacího jazyka C pro historické osmibitové mikroprocesory (2)<br />
<a href="https://www.root.cz/clanky/prekladace-programovaciho-jazyka-c-pro-historicke-osmibitove-mikroprocesory-2/">https://www.root.cz/clanky/prekladace-programovaciho-jazyka-c-pro-historicke-osmibitove-mikroprocesory-2/</a>
</li>

<li>Program a NES game in C<br />
<a href="https://learncgames.com/program-a-nes-game-in-c/">https://learncgames.com/program-a-nes-game-in-c/</a>
</li>

<li>The Thirty Million Line Problem<br />
<a href="https://www.youtube.com/watch?v=kZRE7HIO3vk">https://www.youtube.com/watch?v=kZRE7HIO3vk</a>
</li>

<li>crt0<br />
<a href="https://en.wikipedia.org/wiki/Crt0">https://en.wikipedia.org/wiki/Crt0</a>
</li>

<li>NesDev.org<br />
<a href="https://www.nesdev.org/">https://www.nesdev.org/</a>
</li>

<li>The Sprite Attribute Byte<br />
<a href="https://www.patater.com/nes-asm-tutorials/day-17/">https://www.patater.com/nes-asm-tutorials/day-17/</a>
</li>

<li>How to Program an NES game in C<br />
<a href="https://nesdoug.com/">https://nesdoug.com/</a>
</li>

<li>Cycle reference chart<br />
<a href="https://www.nesdev.org/wiki/Cycle_reference_chart">https://www.nesdev.org/wiki/Cycle_reference_chart</a>
</li>

<li>Getting Started Programming in C: Coding a Retro Game with C Part 2<br />
<a href="https://retrogamecoders.com/getting-started-with-c-cc65/">https://retrogamecoders.com/getting-started-with-c-cc65/</a>
</li>

<li>NES game development in 6502 assembly - Part 1<br />
<a href="https://kibrit.tech/en/blog/nes-game-development-part-1">https://kibrit.tech/en/blog/nes-game-development-part-1</a>
</li>

<li>NES (Nintendo Entertainment System) controller pinout<br />
<a href="https://pinoutguide.com/Game/NES_controller_pinout.shtml">https://pinoutguide.com/Game/NES_controller_pinout.shtml</a>
</li>

<li>NES Controller Shift Register<br />
<a href="https://www.allaboutcircuits.com/uploads/articles/nes-controller-arduino.png?v=1469416980041">https://www.allaboutcircuits.com/uploads/articles/nes-controller-arduino.png?v=1469416980041</a>
</li>

<li>"Game Development in Eight Bits" by Kevin Zurawel<br />
<a href="https://www.youtube.com/watch?v=TPbroUDHG0s&amp;list=PLcGKfGEEONaBjSfQaSiU9yQsjPxxDQyV8&amp;index=4">https://www.youtube.com/watch?v=TPbroUDHG0s&amp;list=PLcGKfGEEONaBjSfQaSiU9yQsjPxxDQyV8&amp;index=4</a>
</li>

<li>Game Development for the 8-bit NES: A class by Bob Rost<br />
<a href="http://bobrost.com/nes/">http://bobrost.com/nes/</a>
</li>

<li>Game Development for the 8-bit NES: Lecture Notes<br />
<a href="http://bobrost.com/nes/lectures.php">http://bobrost.com/nes/lectures.php</a>
</li>

<li>NES Graphics Explained<br />
<a href="https://www.youtube.com/watch?v=7Co_8dC2zb8">https://www.youtube.com/watch?v=7Co_8dC2zb8</a>
</li>

<li>NES GAME PROGRAMMING PART 1<br />
<a href="https://rpgmaker.net/tutorials/227/?post=240020">https://rpgmaker.net/tutorials/227/?post=240020</a>
</li>

<li>NES 6502 Programming Tutorial - Part 1: Getting Started<br />
<a href="https://dev.xenforo.relay.cool/index.php?threads/nes-6502-programming-tutorial-part-1-getting-started.858389/">https://dev.xenforo.relay.cool/index.php?threads/nes-6502-programming-tutorial-part-1-getting-started.858389/</a>
</li>

<li>Minimal NES example using ca65<br />
<a href="https://github.com/bbbradsmith/NES-ca65-example">https://github.com/bbbradsmith/NES-ca65-example</a>
</li>

<li>List of 6502-based Computers and Consoles<br />
<a href="https://www.retrocompute.co.uk/list-of-6502-based-computers-and-consoles/">https://www.retrocompute.co.uk/list-of-6502-based-computers-and-consoles/</a>
</li>

<li>History of video game consoles (second generation): Wikipedia<br />
<a href="http://en.wikipedia.org/wiki/History_of_video_game_consoles_(second_generation)">http://en.wikipedia.org/wiki/History_of_video_game_consoles_(second_generation)</a>
</li>

<li>6502 - the first RISC &micro;P<br />
<a href="http://ericclever.com/6500/">http://ericclever.com/6500/</a>
</li>

<li>3 Generations of Game Machine Architecture<br />
<a href="http://www.atariarchives.org/dev/CGEXPO99.html">http://www.atariarchives.org/dev/CGEXPO99.html</a>
</li>

<li>bee - The Multi-Console Emulator<br />
<a href="http://www.thebeehive.ws/">http://www.thebeehive.ws/</a>
</li>

<li>Nerdy Nights Mirror<br />
<a href="https://nerdy-nights.nes.science/">https://nerdy-nights.nes.science/</a>
</li>

<li>The Nerdy Nights ca65 Remix<br />
<a href="https://github.com/ddribin/nerdy-nights">https://github.com/ddribin/nerdy-nights</a>
</li>

<li>NES Development Day 1: Creating a ROM<br />
<a href="https://www.moria.us/blog/2018/03/nes-development">https://www.moria.us/blog/2018/03/nes-development</a>
</li>

<li>How to Start Making NES Games<br />
<a href="https://www.matthughson.com/2021/11/17/how-to-start-making-nes-games/">https://www.matthughson.com/2021/11/17/how-to-start-making-nes-games/</a>
</li>

<li>ca65 Users Guide<br />
<a href="https://cc65.github.io/doc/ca65.html">https://cc65.github.io/doc/ca65.html</a>
</li>

<li>cc65 Users Guide<br />
<a href="https://cc65.github.io/doc/cc65.html">https://cc65.github.io/doc/cc65.html</a>
</li>

<li>ld65 Users Guide<br />
<a href="https://cc65.github.io/doc/ld65.html">https://cc65.github.io/doc/ld65.html</a>
</li>

<li>da65 Users Guide<br />
<a href="https://cc65.github.io/doc/da65.html">https://cc65.github.io/doc/da65.html</a>
</li>

<li>Nocash NES Specs<br />
<a href="http://nocash.emubase.de/everynes.htm">http://nocash.emubase.de/everynes.htm</a>
</li>

<li>Nintendo Entertainment System<br />
<a href="http://cs.wikipedia.org/wiki/NES">http://cs.wikipedia.org/wiki/NES</a>
</li>

<li>Nintendo Entertainment System Architecture<br />
<a href="http://nesdev.icequake.net/nes.txt">http://nesdev.icequake.net/nes.txt</a>
</li>

<li>NesDev<br />
<a href="http://nesdev.parodius.com/">http://nesdev.parodius.com/</a>
</li>

<li>2A03 technical reference<br />
<a href="http://nesdev.parodius.com/2A03%20technical%20reference.txt">http://nesdev.parodius.com/2A03%20technical%20reference.txt</a>
</li>

<li>NES Dev wiki: 2A03<br />
<a href="http://wiki.nesdev.com/w/index.php/2A03">http://wiki.nesdev.com/w/index.php/2A03</a>
</li>

<li>Ricoh 2A03<br />
<a href="http://en.wikipedia.org/wiki/Ricoh_2A03">http://en.wikipedia.org/wiki/Ricoh_2A03</a>
</li>

<li>2A03 pinouts<br />
<a href="http://nesdev.parodius.com/2A03_pinout.txt">http://nesdev.parodius.com/2A03_pinout.txt</a>
</li>

<li>27c3: Reverse Engineering the MOS 6502 CPU (en)<br />
<a href="https://www.youtube.com/watch?v=fWqBmmPQP40">https://www.youtube.com/watch?v=fWqBmmPQP40</a>
</li>

<li>“Hello, world” from scratch on a 6502 — Part 1<br />
<a href="https://www.youtube.com/watch?v=LnzuMJLZRdU">https://www.youtube.com/watch?v=LnzuMJLZRdU</a>
</li>

<li>A Tour of 6502 Cross-Assemblers<br />
<a href="https://bumbershootsoft.wordpress.com/2016/01/31/a-tour-of-6502-cross-assemblers/">https://bumbershootsoft.wordpress.com/2016/01/31/a-tour-of-6502-cross-assemblers/</a>
</li>

<li>Nintendo Entertainment System (NES)<br />
<a href="https://8bitworkshop.com/docs/platforms/nes/">https://8bitworkshop.com/docs/platforms/nes/</a>
</li>

<li>Question about NES vectors and PPU<br />
<a href="https://archive.nes.science/nesdev-forums/f10/t4154.xhtml">https://archive.nes.science/nesdev-forums/f10/t4154.xhtml</a>
</li>

<li>How do mapper chips actually work?<br />
<a href="https://archive.nes.science/nesdev-forums/f9/t13125.xhtml">https://archive.nes.science/nesdev-forums/f9/t13125.xhtml</a>
</li>

<li>INES<br />
<a href="https://www.nesdev.org/wiki/INES">https://www.nesdev.org/wiki/INES</a>
</li>

<li>NES Basics and Our First Game<br />
<a href="http://thevirtualmountain.com/nes/2017/03/08/nes-basics-and-our-first-game.html">http://thevirtualmountain.com/nes/2017/03/08/nes-basics-and-our-first-game.html</a>
</li>

<li>Where is the reset vector in a .nes file?<br />
<a href="https://archive.nes.science/nesdev-forums/f10/t17413.xhtml">https://archive.nes.science/nesdev-forums/f10/t17413.xhtml</a>
</li>

<li>CPU memory map<br />
<a href="https://www.nesdev.org/wiki/CPU_memory_map">https://www.nesdev.org/wiki/CPU_memory_map</a>
</li>

<li>How to make NES music<br />
<a href="http://blog.snugsound.com/2008/08/how-to-make-nes-music.html">http://blog.snugsound.com/2008/08/how-to-make-nes-music.html</a>
</li>

<li>Nintendo Entertainment System Architecture<br />
<a href="http://nesdev.icequake.net/nes.txt">http://nesdev.icequake.net/nes.txt</a>
</li>

<li>MIDINES<br />
<a href="http://www.wayfar.net/0xf00000_overview.php">http://www.wayfar.net/0xf00000_overview.php</a>
</li>

<li>FamiTracker<br />
<a href="http://famitracker.com/">http://famitracker.com/</a>
</li>

<li>nerdTracker II<br />
<a href="http://nesdev.parodius.com/nt2/">http://nesdev.parodius.com/nt2/</a>
</li>

<li>How NES Graphics work<br />
<a href="http://nesdev.parodius.com/nesgfx.txt">http://nesdev.parodius.com/nesgfx.txt</a>
</li>

<li>NES Technical/Emulation/Development FAQ<br />
<a href="http://nesdev.parodius.com/NESTechFAQ.htm">http://nesdev.parodius.com/NESTechFAQ.htm</a>
</li>

<li>Adventures with ca65<br />
<a href="https://atariage.com/forums/topic/312451-adventures-with-ca65/">https://atariage.com/forums/topic/312451-adventures-with-ca65/</a>
</li>

<li>example ca65 startup code<br />
<a href="https://atariage.com/forums/topic/209776-example-ca65-startup-code/">https://atariage.com/forums/topic/209776-example-ca65-startup-code/</a>
</li>

<li>6502 PRIMER: Building your own 6502 computer<br />
<a href="http://wilsonminesco.com/6502primer/">http://wilsonminesco.com/6502primer/</a>
</li>

<li>6502 Instruction Set<br />
<a href="https://www.masswerk.at/6502/6502_instruction_set.html">https://www.masswerk.at/6502/6502_instruction_set.html</a>
</li>

<li>Chip Hall of Fame: MOS Technology 6502 Microprocessor<br />
<a href="https://spectrum.ieee.org/tech-history/silicon-revolution/chip-hall-of-fame-mos-technology-6502-microprocessor">https://spectrum.ieee.org/tech-history/silicon-revolution/chip-hall-of-fame-mos-technology-6502-microprocessor</a>
</li>

<li>Single-board computer<br />
<a href="https://en.wikipedia.org/wiki/Single-board_computer">https://en.wikipedia.org/wiki/Single-board_computer</a>
</li>

<li>www.6502.org<br />
<a href="http://www.6502­.org/">http://www.6502­.org/</a>
</li>

<li>6502 PRIMER: Building your own 6502 computer &ndash; clock generator<br />
<a href="http://wilsonminesco.com/6502primer/ClkGen.html">http://wilsonminesco.com/6502primer/ClkGen.html</a>
</li>

<li>Great Microprocessors of the Past and Present (V 13.4.0)<br />
<a href="http://www.cpushack.com/CPU/cpu.html">http://www.cpushack.com/CPU/cpu.html</a>
</li>

<li>Jak se zrodil procesor?<br />
<a href="https://www.root.cz/clanky/jak-se-zrodil-procesor/">https://www.root.cz/clanky/jak-se-zrodil-procesor/</a>
</li>

<li>Osmibitové mikroprocesory a mikrořadiče firmy Motorola (1)<br />
<a href="https://www.root.cz/clanky/osmibitove-mikroprocesory-a-mikroradice-firmy-motorola-1/">https://www.root.cz/clanky/osmibitove-mikroprocesory-a-mikroradice-firmy-motorola-1/</a>
</li>

<li>Mikrořadiče a jejich použití v jednoduchých mikropočítačích<br />
<a href="https://www.root.cz/clanky/mikroradice-a-jejich-pouziti-v-jednoduchych-mikropocitacich/">https://www.root.cz/clanky/mikroradice-a-jejich-pouziti-v-jednoduchych-mikropocitacich/</a>
</li>

<li>Mikrořadiče a jejich aplikace v jednoduchých mikropočítačích (2)<br />
<a href="https://www.root.cz/clanky/mikroradice-a-jejich-aplikace-v-jednoduchych-mikropocitacich-2/">https://www.root.cz/clanky/mikroradice-a-jejich-aplikace-v-jednoduchych-mikropocitacich-2/</a>
</li>

<li>25 Microchips That Shook the World<br />
<a href="https://spectrum.ieee.org/tech-history/silicon-revolution/25-microchips-that-shook-the-world">https://spectrum.ieee.org/tech-history/silicon-revolution/25-microchips-that-shook-the-world</a>
</li>

<li>Comparison of instruction set architectures<br />
<a href="https://en.wikipedia.org/wiki/Comparison_of_instruction_set_architectures">https://en.wikipedia.org/wiki/Comparison_of_instruction_set_architectures</a>
</li>

<li>Day 1 - Beginning NES Assembly<br />
<a href="https://www.patater.com/nes-asm-tutorials/day-1/">https://www.patater.com/nes-asm-tutorials/day-1/</a>
</li>

<li>Day 2 - A Source Code File's Structure<br />
<a href="https://www.patater.com/nes-asm-tutorials/day-2/">https://www.patater.com/nes-asm-tutorials/day-2/</a>
</li>

<li>Assembly Language Misconceptions<br />
<a href="https://www.youtube.com/watch?v=8_0tbkbSGRE">https://www.youtube.com/watch?v=8_0tbkbSGRE</a>
</li>

<li>How Machine Language Works<br />
<a href="https://www.youtube.com/watch?v=HWpi9n2H3kE">https://www.youtube.com/watch?v=HWpi9n2H3kE</a>
</li>

<li>Super Mario Bros. (1985) Full Walkthrough NES Gameplay [Nostalgia]<br />
<a href="https://www.youtube.com/watch?v=rLl9XBg7wSs">https://www.youtube.com/watch?v=rLl9XBg7wSs</a>
</li>

<li>[Longplay] Castlevania (NES) - All Secrets, No Deaths<br />
<a href="https://www.youtube.com/watch?v=mOTUVXrAOE8">https://www.youtube.com/watch?v=mOTUVXrAOE8</a>
</li>

<li>Herní série Castlevania<br />
<a href="https://www.root.cz/clanky/historie-vyvoje-pocitacovych-her-24-cast-hry-pro-konzoli-nes/#k07">https://www.root.cz/clanky/historie-vyvoje-pocitacovych-her-24-cast-hry-pro-konzoli-nes/#k07</a>
</li>

</ol>



<p></p><p></p>
<p><small>Autor: <a href="http://www.fit.vutbr.cz/~tisnovpa">Pavel Tišnovský</a> &nbsp; 2022</small></p>
</body>
</html>
